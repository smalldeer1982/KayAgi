# [CSP-S2019] 括号树

## 题目背景

本题中**合法括号串**的定义如下：
1.	`()` 是合法括号串。
2.	如果 `A` 是合法括号串，则 `(A)` 是合法括号串。
3.	如果 `A`，`B` 是合法括号串，则 `AB` 是合法括号串。

本题中**子串**与**不同的子串**的定义如下：
1.	字符串 `S` 的子串是 `S` 中**连续**的任意个字符组成的字符串。`S` 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l, r)$（$1 \leq l \leq r \leq |S |$，$|S |$ 表示 S 的长度）。
2.	`S` 的两个子串视作不同**当且仅当**它们在 `S` 中的位置不同，即 $l$ 不同或 $r$ 不同。

## 题目描述

一个大小为 $n$ 的树包含 $n$ 个结点和 $n - 1$ 条边，每条边连接两个结点，且任意两个结点间**有且仅有**一条简单路径互相可达。

小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1 \sim n$ 编号，$1$ 号结点为树的根。除 $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \leq u \leq n$）号结点的父亲为 $f_u$（$1 ≤ f_u < u$）号结点。

小 Q 发现这个树的每个结点上**恰有**一个括号，可能是`(` 或`)`。小 Q 定义 $s_i$ 为：将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。
 
显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1\leq i\leq n$）求出，$s_i$ 中有多少个**互不相同的子串**是**合法括号串**。
 
这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串， 你只需要告诉小 Q 所有 $i \times k_i$ 的异或和，即：
$$ (1 \times k_1)\ \text{xor}\ (2 \times k_2)\ \text{xor}\ (3 \times k_3)\ \text{xor}\ \cdots\ \text{xor}\ (n \times k_n) $$
其中 $xor$ 是位异或运算。

## 说明/提示

【样例解释1】

树的形态如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/10z2scex.png)

将根到 1 号结点的简单路径上的括号，按经过顺序排列所组成的字符串为 `(`，子串是合法括号串的个数为 $0$。

将根到 2 号结点的字符串为 `((`，子串是合法括号串的个数为 $0$。

将根到 3 号结点的字符串为 `()`，子串是合法括号串的个数为 $1$。

将根到 4 号结点的字符串为 `(((`，子串是合法括号串的个数为 $0$。

将根到 5 号结点的字符串为 `(()`，子串是合法括号串的个数为 $1$。

【数据范围】

![](https://cdn.luogu.com.cn/upload/image_hosting/1k6fabxr.png)


## 样例 #1

### 输入

```
5
(()()
1 1 2 2```

### 输出

```
6```

# 题解

## 作者：Inkyo (赞：2744)

>这里是墨攸，平生没有什么爱好，~~就喜欢做T2~~（不好意思这次T2做得我心态炸了）

## 最完整的题解！不服求超过~~QWQ

# 2019 - CSP-S DAY-1 T2 括号树

- **$\text{Update}$ $19-11-23:$ 修复了一些文本上的小错误。**

  话说看的人居然有这么多，真是受宠若惊qwq

----

$ok$和你们聊聊我考场上的心路历程吧：

**跟着心路历程走，更容易懂这道题哦！**

------------

开题。

woc这是什么东西？完全没有思路啊！！！！

想了$10min$，决定先敲个暴力。

## 1、暴力：10~20pts，复杂度$O(n^4)$，只能解决链

暴力很容易就会了。

因为只解决链，所以不用建树，用一个数组存就可以了。恰好这题很良心，编号为 $i$ 的祖先恰好是 $i-1$，也就是说本身编号就是顺序的（~~不像毒瘤T3，链的编号还有可能乱序~~）

先套一重$for$ 枚举 $i$，代表从根节点走到了 $i$ 号节点。由于要计算 $1-i$ 中究竟有多少个子括号序列，所以我们还需要枚举左端点 $l$ 和右端点 $r$，表示枚举到区间为$[l,r]$的子括号序列。然后还要写一个判断括号是否匹配的$check$子函数。子函数的复杂度为$O(r-l)$。

$check$子函数应该都会写吧，开栈来判断即可。具体可以看[这题](https://www.luogu.org/problem/P1739)。

$3$重循环套一个$check$，所以复杂度为 $O(n^4)$。实际上是跑不满的，所以有望过 $n=200$ 的数据。

## 2、55pts，复杂度$O(n)$，只解决链

发现链居然有$55pts$的友好分，果断开链。

观察我们暴力究竟慢在哪里了？无非就是计算 $1-i$ 之中有多少个匹配的括号子序列。

观察数据，发现数据 $5e5$，讲道理 $O(nlogn)$ 跑这样的数据本身就带悬。加上 $\text{CCF}$ 老年机的 $\text{debuff}$ ，还真的没法保证能跑过去。

~~我深信~~ $\text{CCF}$ 是不会卡常的 (jiade) ，所以我当时就在想，只能$O(1)$计算每次的贡献值。

怎么 $O(1)$ 计算呢？不知道啊，要不来举几个例子推一推？

**注意，以下的例子第一个字符的下标均为$1$**


------------

```
例子1：
()()()
```

我们发现，$i=2$ 的时候，对答案的贡献值为 $1$。而 $i=4$ 的时候，本身 $[3,4]$就有一个满足要求的括号序列，在合并上前面的成为$[1,4]$，同样满足，于是对答案的贡献值就为$2$，再加上前面$[1,2]$本身有的括号序列，总共为 $3$。

$i=6$时同理，总共的贡献值为 $3$，加上前面的有 $3+3=6$ 种。其他位置均没有贡献。

换句话说，$i$为$1-6$时对答案的贡献分别为$0,1,0,2,0,3$，合并后的总答案为$0,1,1,3,3,6$


------------

```
例子2:
())()
```

继续前面的思想，$i=2$时，对答案贡献$1$。而$i=3$时，由于不满足成匹配的括号序列，所以没有贡献。而$i=5$时，由于$i=3$多了一个后括号，$[1,3]$不匹配，导致$[1,5]$成不了一个匹配的括号序列。故对答案的贡献仍为 $1$

$i$为$1-5$时对答案的贡献分别为$0,1,0,0,1$，合并后的总答案为$0,1,1,1,2$


------------

```
例子3:
()(())
```

接着刚刚的分析，$i=2$时，贡献为$1$，而$i=5$时，由于$i=3$在中间断开，使$[1,5]$不能匹配，所以贡献仍为$1$。

当$i=6$情况有了变化。我们发现$[1,2]$是匹配的。故$[1,2],[3,6]$能合成一个匹配的序列，故对答案贡献为$2$。

$i$为$1-6$时对答案的贡献分别为$0,1,0,0,1,2$，合并后的总答案为$0,1,1,1,2,4$

------------

**ok，理论的分析就先告一段落了！有没有发现什么规律？**

我们发现，一个后括号如果能匹配一个前括号，**假设这个前括号的前$1$位同样有一个已经匹配了的后括号，那么我们势必可以把当前的匹配和之前的匹配序列合并，当前的这个后括号的贡献值，其实就等于前面那个后括号的贡献值$+1$！**

**这是一个非常重要的结论，可以在递推过程中，直接完成 $O(1)$ 计算贡献值！**

你可以用这个结论带入到前面的例子中推一下，马上就明白了（不要嫌麻烦，嫌麻烦就做不了题。考场上就是要多手推）

有了贡献值，当前位置答案总和就很好算了。很明显，第 $i$ 位的总和等于 $i-1$ 位的总和 加上 第 $i$ 位的贡献值。

**那怎么判断括号是否匹配呢？** 我们同样可以用[这题](https://www.luogu.org/problem/P1739)的思想开栈做。每次压入一个括号然后进行操作即可。

**就算后括号匹配了，那我又如何知道前括号的位置呢？** 其实也很简单。我们把压入括号改一改，不压括号，取之而代，压入前括号的位置即可。判断是否匹配只需要看栈里有没有数即可。

我们用 $lst[i]$ 表示第 $i$ 位的贡献，$sum[i]$ 表示第 $i$ 位的答案总合。那么就有：

```cpp

//s是栈，top是栈顶，手写栈貌似要快很多。

if(c[i] == ')') //是后括号
{
	if(top == 0) continue; //栈为空，则没有匹配
	int t = s[top]; //匹配的前括号的位置 
	lst[i] = lst[t - 1] + 1 //结论计算贡献值
    top --;
}
else if(c[i] == '(') s[++ top] = i; //是前括号，就压入它的位置 
sum[i] = sum[i - 1] +  lst[i]; //计算总和 
```

很容易发现，这样处理一个位置的总和其实是$O(1)$的

当然整个代码要放进一个循环里。完整代码如下：

```cpp
for(int i = 1; i <= n; i ++) //好吧只多了个循环....
{
	if(c[i] == ')')
	{
		if(top == 0) continue; //判断栈是否为空 
		int t = s[top]; //匹配的前括号的位置 
		lst[i] = lst[t - 1] + 1 //结论计算贡献值
        top --;
	}
	else if(c[i] == '(') s[++ top] = i; //是前括号，就压入它的位置 
	sum[i] = sum[i - 1] +  lst[i]; //计算总和 
} 
```

**这样，你就有了 55pts 稳稳的分！**

## 2、100pts，复杂度$O(n)$，正解

解决了链，有了稳稳的 55pts。想想好像可以实现化链成树，果断开正解。

很明显，我们解决链的做法在树里有很多行不通的地方。

**细细想来，困难主要出现在这$2$个方面。**

首先，你没法遍历整颗树的时候编号是连续的。这代表着我们 `lst[i] = lst[t - 1] + 1` 这样计算是完全行不通了。

其次，遍历一棵树必然会有递归和回溯。而处理链我们不考虑回溯，一直向下找就可以找完了。

但是我们怎么能退缩呢？！大家跟我一起念！~~（我们遇到什么困难，也不要怕！微笑着面对他....）~~

咳咳，言归正传，我们来解决这两个问题。

--------------

**先看第一个问题**

冷静分析一波，你会发现，虽然编号不连续了，但是你的括号序列**一定是从父节点传递下来的！**

仔细一想，我们发现，在链的情况里，为什么能用 `lst[i] = lst[t - 1] + 1` 计算贡献？其实，$t-1$ 就是 $t$ 的父亲节点！无非是 $[t,i]$ 的括号序列继承了 $[1,t-1]$，也就是 $[1,fa[t]]$ 的括号序列！（$fa[i]$ 代表 $i$ 的父亲）

然后我们惊喜的发现，这条定则对于树完全适用。

于是我们就可以修改一波原来的柿子：

`lst[i] = lst[t - 1] + 1` $->$ `lst[x] = lst[fa[t]] + 1;` 

$\text{perfect}$！

当然计算总答案也要修改：

`sum[i] = sum[i - 1] +  lst[i];` $->$ `sum[x] = sum[fa[x]] + lst[x];`

这样我们就解决了问题$1$

--------------

**接下来考虑解决第二个问题：**

在树中遍历有回溯，回溯后栈里的信息可能就无法对应当前的版本...

其实这个问题很容易解决。由于每次回溯只回溯一层，所以我们在回溯的时候，执行我们递归时相反的操作即可！

比如，如果我们扫到右括号，递归时如果栈不为空，照理来说会弹出一个位置信息。

**那么我们就可以记录这个信息，回溯的时候再把它压回去，又变成了我们当前的版本。**

扫到左括号也一样。**我们会压入一个位置信息，那么回溯时，直接弹出这个压入的信息就可以了！**

其实这也相当于“复原”操作，让栈里的信息永远留在我们现在的状态！

递归代码就很好写了：

```cpp
//我使用的链表存图qwq，head,nxt,to都是链表所用（应该都看得懂吧？）

void dfs(int x)
{
	int tmp = 0;
	if(c[x] == ')')
	{
		if(top)
		{
			tmp = s[top];
			lst[x] = lst[fa[tmp]] + 1;
			-- top; 
		}
	}
	else if(c[x] == '(') s[++ top] = x; 
	sum[x] = sum[fa[x]] + lst[x]; //如上所述 
	for(int i = head[x]; i; i = nxt[i])
		dfs(to[i]); //递归 
	//回溯复原操作
	if(tmp != 0) s[++ top] = tmp; //不为 0 代表有信息被弹出 
	else if(top) -- top; 
	//为 0 代表没有弹出，如果栈不为空说明一定压入了一个信息，需要弹出这个信息复原 
}
```

跑过小数据了，跑过中样例了，跑过大样例了！

恭喜你切了这道题qwq！！

下面就放完整代码吧！

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
#define ll long long
#define maxn 500005;

using namespace std;

int n;
char c[maxn];
int head[maxn], nxt[maxn], to[maxn], cnt, fa[maxn];
ll lst[maxn], sum[maxn], ans;
int s[maxn], top;

void add_edge(int u, int v)
{
	nxt[++ cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
}

void dfs(int x)
{
	int tmp = 0;
	if(c[x] == ')')
	{
		if(top)
		{
			tmp = s[top];
			lst[x] = lst[fa[tmp]] + 1;
			-- top; 
		}
	}
	else if(c[x] == '(') s[++ top] = x; 
	sum[x] = sum[fa[x]] + lst[x]; //如上所述 
	for(int i = head[x]; i; i = nxt[i])
		dfs(to[i]); //递归 
	//回溯复原操作
	if(tmp != 0) s[++ top] = tmp; //不为 0 代表有信息被弹出 
	else if(top) -- top; 
	//为 0 代表没有弹出，如果栈不为空说明一定压入了一个信息，需要弹出这个信息复原 
}

int main()
{
	scanf("%d", &n);
	scanf("%s", c + 1);
	for(int i = 2; i <= n; i ++)
	{
		int f;
		scanf("%d", &f);
		add_edge(f, i);
		fa[i] = f;
	}
	dfs(1);
	for(int i = 1; i <= n; i ++)
		ans ^= sum[i] * (ll)i;
	printf("%lld", ans);
	return orz;
}
```

**顺带提醒！不仅 $ans$ 要开 $long~long$，$lst$ 和 $sum$ 同样需要！否则你会被构造数据卡得崩溃...**

## 总结

一步一步分析，这道题是不是就没有这么难了？

这也告诉了我们，考场上，一开始绝对不要先想正解，先看一看部分分，对你想正解有帮助哦！

很明显，我们这次解题的步骤就是由 暴力 -> 链 -> 正解的！

---------

**希望能帮到你们哦！**

~~这篇题解码了287行，写了快1h30min了...可不可以点个大拇指啊QAQ，谢谢各位DALAO啊啊啊啊QAQ~~



---

## 作者：万弘 (赞：47)

个人认为这题暴力比正解难想吧(却也是考场上唯二写出的正解了..)...

考虑$[1,u]$的合法子串数$=[1,fa[u]]$的合法子串数+加入$u$后新增的合法子串数.

前面这个,直接在dfs的时候向下传递就好了.后面这部分呢?

分类讨论,并维护一个栈,存未被匹配的左括号的编号.    
数组$f[u]$表示以$u$结尾的新增的合法子串数  
- 当前点的字符为`(`:新增的合法子串数为0,直接进栈.   
- 当前点字符为`)`,但栈为空,新增的合法子串数也是0.  
- 当前点字符为`)`,且栈非空,更新$f[u]=f[fa[s[top]]]+1$(这句话的含义是,到u的新增合法子串,要么是由栈顶父亲那里的合法串加上$[s[top],u]$这一对括号构成的,要么就是$[s[top],u]$这一对括号),并pop掉栈顶.

PS:我的实现全局只用一个栈,而$u$在dfs完某部分子树后,栈内部分元素可能被这部分子树内的`(`所覆盖,导致dfs完后,现在的栈存的不再是$[1,u]$中未被匹配的`(`编号了.这个问题有很多种解决办法,我的解决方案是:如果当前的$u$触发了退栈操作,存一下当前的栈顶,再pop,dfs完所有子树后,恢复栈顶.

时间复杂度显然是线性的,即$O(n)$
```cpp
/**********/省略快读

#define MAXN 500011
struct Edge
{
	ll v,nxt;
}e[MAXN];
ll cnt=0,last[MAXN];
void adde(ll u,ll v)
{
	e[++cnt].v=v;
	e[cnt].nxt=last[u],last[u]=cnt;
}
char a[MAXN];
ll fa[MAXN],s[MAXN],f[MAXN];//父亲,栈,f如上所述
ll ans=0;
void dfs(ll u,ll pre,ll top)//当前点为u,1到父亲的合法子串数为pre,当前栈顶指针
{
	ll flag=0;//用于处理上述特殊情况
	if(a[u]=='(')//分类讨论
	{
		s[++top]=u;
	}
	else
	{
		if(!top)f[u]=0;
		else
		{
			flag=s[top];//存下栈顶
			f[u]=f[fa[s[top]]]+1;//更新f
			pre+=f[u];//更新pre
			--top;//pop
		}
		
	}
	//printf("vis %lld,f=%lld\n",u,pre);
	ans^=(u*pre);//统计贡献
	for(ll i=last[u];i;i=e[i].nxt)
		dfs(e[i].v,pre,top);
	if(flag)s[top+1]=flag;//恢复栈顶
}
int main()
{
	ll n=read();
	scanf("%s",a+1);
	for(ll i=2;i<=n;++i)
	{
		fa[i]=read();
		adde(fa[i],i);
	}
	dfs(1,0,0);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xht (赞：43)

考虑以每个节点为结尾的合法括号子串有多少个。

以 `(` 为 $1$ `)` 为 $-1$ 做一个树上前缀和，设点 $x$ 的前缀和为 $s_x$。

则以 $x$ 结尾的合法括号子串的开头 $v$ 需要满足：

1. $s_u = s_v$。
2. $v \to u$ 的路径上所有点的 $s \ge s_u$。

遍历一遍树，用一个 $c$ 数组记录从根节点到当前节点的所有 $s$ 出现的个数，同时用一个 $p$ 数组记录每一个 $s$ 上一次出现的位置。

那么对于一个点 $u$，以 $u$ 结尾的合法括号子串的个数应该为，在点 $u$ 的时候 $c[s_u]$ 的值（去掉 $s_u$ 本身）减去在点 $p[s_u-1]$ 的时候 $c[s_u]$ 的值。

前者可以直接加到 $ans_u$ 中，后者则需要等到回溯到 $p[s_u-1]$ 再从 $ans_u$ 减掉，用一个 `vector` 记录即可。

其中，更新 $p$ 数组时，需要用一个额外的变量记录更新前的值。

总时间复杂度 $\mathcal O(n)$。

```cpp
const int N = 5e5 + 7;
int n, c[N<<1], p[N<<1];
char s[N];
vi e[N], g[N];
ll ans[N], Ans;

void dfs(int x, int o) {
	o += s[x] == '(' ? 1 : -1;
	ans[x] = c[o];
	++c[o];
	int w = p[o];
	p[o] = x;
	g[p[o-1]].pb(x);
	for (ui i = 0; i < e[x].size(); i++) dfs(e[x][i], o);
	for (ui i = 0; i < g[x].size(); i++) ans[g[x][i]] -= c[o+1];
	--c[o];
	p[o] = w;
}

void dfs(int x) {
	for (ui i = 0; i < e[x].size(); i++) {
		int y = e[x][i];
		ans[y] += ans[x];
		dfs(y);
	}
}

int main() {
	rd(n), rds(s, n);
	for (int i = 2, x; i <= n; i++) rd(x), e[x].pb(i);
	c[n+1] = 1;
	dfs(1, n + 1);
	dfs(1);
	for (int i = 1; i <= n; i++) Ans ^= i * ans[i];
	print(Ans);
	return 0;
}
```

---

## 作者：asd369 (赞：28)

[也许更好的阅读体验](https://www.cnblogs.com/asd369-blog/p/CSP-S2-2019-brackets.html)
## 说在前面的话
> 谨以此篇题解，纪念我初中的两年$OI$生涯以及不长不短的停课时光。
>
> 但愿高中还能够继续学习$OI$吧，也衷心希望其他$OIer$不要再犯类似我的错误。

## 题意
[原题链接](https://www.luogu.org/problem/P5658)

给定一棵有$n$个节点的树，每个节点对应一个括号（左或右），需要求出从该节点到根节点的简单路径所构成的括号串中合法括号子串的数量。  
其中合法括号串的定义是这样的
1. `()`是合法括号串。
2. 如果`A`是合法括号串，则`(A)`是合法括号串。
3. 如果`A`，`B`是合法括号串，则`AB`是合法括号串。

其中$n\le 5\times 10^5$

## 题解
### 1. 初步思路
令$cnt_i$表示从$i$节点到根节点所构成的括号串中合法括号子串的数量，$f$表示$i$节点的父亲，则有一个很显然的结论：
$$ cnt_i=cnt_f+(\text{以i节点为结尾的合法括号子串的个数}) $$
这个结论应该无需证明了……这是解题的关键，于是我们就只需要考虑以$i$节点为结尾的合法括号子串的个数了（设其为$t_i$）。

### 2. 统计答案
先考虑怎么暴力统计，显然直接从$i$节点往上跳，统计合法括号子串数即可，这样做是$O(n_2)$的。

再考虑给出的合法括号串的定义：**“如果`A`，`B`是合法括号串，则`AB`是合法括号串”**。

举个例子，考虑暴力的过程，如果以$i$为结尾的括号串是`()()()()`，我们总共了统计了$4$个，但其实，我们只需要统计**最右边（dfs序最大）的那一对合法的括号，而左边的三对括号就相当于$t_{f_f}$（即以$f_f$为结尾的合法括号串的数量），这是因为最左边的括号串`()`合法，右边的三个括号串`()`，`()()`，`()()()`合法，联系上面的性质，所以将它们连起来同样合法。**

到这一步之后，貌似大多数人都用栈来做，我在考场上$yy$出了一种奇♂妙的方法，在这里分享一下。

于是我们设$re_i$为满足**从$i$节点到该节点所构成的括号串为合法括号串，且深度最大**的节点，得到$cnt_i$的表达式
$$ cnt_i=cnt_f+t_{f_{re_i}}+1 $$
结合一下先前的例子`()()()()`，$cnt_f$不用多讲，$1$表示的是以$re_i$为开头以$i$为结尾的合法括号串（即例子中最左边的的`()`），$t_{f_{re_i}}$就是例子中右边的三个合法括号串`()`，`()()`，`()()()`，至于这三个括号串为什么要记入答案上文已讨论。

再结合一下代码看看：
```cpp
cnt[x]+=cnt[f],fa[x]=f;
if (a[x]==1) // 只有a[x]==1（即括号为')'）才有可能存在以x为结尾的合法括号串
{
	while (a[f]!=-1&&re[f]!=-1) f=fa[re[f]]; // 找到re[x]
	if (f==0||a[f]==1) re[x]=-1; // re[x]需合法
	else re[x]=f,cnt[x]+=cnt[fa[f]]-cnt[fa[fa[f]]]+1; // 统计答案。cnt[fa[f]]-cnt[fa[fa[f]]]就等于上文中的t[fa[f]]
}
else re[x]=-1;
```

## 经验教训
笔者在考场做这道题时，将上文中的`while`打成了`if`，于是（洛谷自测）$100 \to 10$

其实是没有考虑到这种情况`((())())`。（至于为什么错可以手玩一下）

~~然后就开开心心$\text{AFO}$搞文化课了~~

这里以亲身教训提醒大家，**一定要注意细节！考虑情况一定要充分！不要重蹈我的覆辙！**

祝大家人人取得满意的成绩（我是拿不到了）

## 代码
其实代码就很短啦，$qwq$。
```cpp
#include <stdio.h>

using namespace std;

template <typename T> inline void Read(T &t)
{
	int c=getchar(),f=0;
	for (;c<'0'||c>'9';c=getchar()) f=(c=='-');
	for (t=0;c>='0'&&c<='9';c=getchar()) t=(t<<3)+(t<<1)+(c^48);
	if (f) t=-t;
}

typedef long long ll;
const int N=5e5+5;

int n,tot,head[N],a[N],fa[N],re[N];
ll ans,cnt[N];
char temp[N];
 
struct Edge
{
	int to,next;
	void add(int x, int y) { to=y,next=head[x],head[x]=tot; }
} e[N<<1];
 
void dfs(int x, int f)
{
	cnt[x]+=cnt[f],fa[x]=f;
	if (a[x]==1)
	{
		while (a[f]!=-1&&re[f]!=-1) f=fa[re[f]];
		if (f==0||a[f]==1) re[x]=-1;
		else re[x]=f,cnt[x]+=cnt[fa[f]]-cnt[fa[fa[f]]]+1;
	}
	else re[x]=-1;
	for (int i=head[x];i;i=e[i].next)
	{
		int v=e[i].to;
		dfs(v,x);
	}
}	

signed main()
{
	Read(n);
	scanf("%s",temp);
	for (int i=1;i<=n;i++) 
		a[i]=(temp[i-1]=='('?-1:1);
	for (int i=2,f;i<=n;i++) Read(f)，e[++tot].add(f,i);

	re[0]=-1;
	dfs(1,0);
	
	for (ll i=1;i<=n;i++) ans^=(cnt[i]*i);
	printf("%lld\n",ans);
	
    return 0;
}
```

## 结语
笔者大概率是$\text{AFO}$了，但还是希望这篇题解能给做出或没有做出这道题的人带来一些帮助，也算是我$OI$生涯的~~回光返照~~吧

去搞文化课准备中考了。


---

## 作者：George1123 (赞：18)

[${\color{#00ccee}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P5658 【括号树【民间数据】】](https://www.luogu.org/problem/P5658)

### 此题算法:$dp$+$dfs$+回溯

好好的一道线性$dp$长在树上了，但只需当线性$dp$做。

**大致思路:**

在一串括号中，维护两个数组:

**dp[$i$]**：表示从根节点到$i$点的括号串中的合法括号子串数。

**lst[$i$]**：表示从根节点到$i$点的括号串中以$i$为结尾的合法括号子串数。

这个$lst[]$用来辅助$dp[]$，考试结束前$10min$我才写上的。

再维护一个**栈**，栈中存的是还未匹配的括号(同时用来树上维护)。

**对于每个$x$，分以下几种情况讨论：**

($fa[x]$即$x$的树上父亲，串中前面一个括号)

**1.栈为空(没有待匹配的括号)：**

一个孤独的括号"("或")"

```cpp
if(s.empty()){
	tmp=x,s.push(bra[x]);
	dp[x]=dp[fa[x]];
	lst[x]=0;
}
```

**2.栈中有能与$x$匹配的括号：**

如下括号串(最后一个是$x$)

# $()()(()(()())$

($fs$表示与$x$匹配的括号，是第$8$个)

($rs$表示栈中取出$fs$后剩下的括号，是第$5$个)

**$dp[x]=rs$之前的$+rs$和$fs$之间的$+x$和$fs$之间的$+$跨越$fs$的**

**$rs$之前的**：$dp[fa[rs]]$

**$rs$和$fs$之间的**：$dp[fa[fs]]-dp[rs]$

**$x$和$fs$之间的**：$1+dp[fa[x]]-dp[fs]$

$1$表示取包括$x$和$fs$的整块

**跨越$fs$的**：$lst[fa[fs]]$

因为要跨越$fs$，所以必取$fs$。

而$fs$和$x$是一个整体，所以也要取包括$x$和$fs$的整块。

而括号串必须联通，所以乘以以$fa[fs]$为结尾的合法括号子串数。

**所以$dp[x]=dp[fa[rs]]+dp[fa[fs]]-dp[rs]+1+dp[fa[x]]-dp[fs]+lst[fa[fs]]$**

**再特判一下没有$rs$的情况就行了。**



```cpp
else if(s.top().f==1&&bra[x].f==0){//不用管，意思如题
	int fs=s.top().d;//那个能与x匹配的括号下标
	tmp=-fs,s.pop();//维护dfs的回溯，表示栈中取得了fs
	lst[x]=lst[fa[fs]]+1;//lst数组的递推
	if(s.empty()){ //特判
		dp[x]=1LL+dp[fa[x]]-dp[fs]+dp[fa[fs]]+lst[fa[fs]];
	} else { //如题
		int rs=s.top().d;
		dp[x]=dp[fa[rs]]+dp[fa[fs]]-dp[rs]+1+dp[fa[x]]-dp[fs]+lst[fa[fs]];
	}
}
```

**3.栈中没有能与$x$匹配的括号**

同上第$1$种情况。

```cpp
else {
	tmp=x,s.push(bra[x]);
	dp[x]=dp[fa[x]];
	lst[x]=0;
}
```



## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define lng long long
const int N=5e5+10;
int n,fa[N];
struct brack{ //括号，f表示左右，d表示节点编号
	bool f;
	int d;
}bra[N];
char inp[N];
lng ans,dp[N],lst[N];
struct edge{ //树上加边
	int adj,nex;
}e[N];
int g[N],top;
void add(int x,int y){
	e[++top]=(edge){y,g[x]};
	g[x]=top;
}
stack<brack> s;
void dfs(int x){
	int tmp; //维护回溯
	if(s.empty()){ //RT
		tmp=x,s.push(bra[x]);
		dp[x]=dp[fa[x]];
		lst[x]=0;
	} else if(s.top().f==1&&bra[x].f==0){ //RT
		int fs=s.top().d;
		tmp=-fs,s.pop();
		lst[x]=lst[fa[fs]]+1;
		if(s.empty()){
			dp[x]=1LL+dp[fa[x]]-dp[fs]+dp[fa[fs]]+lst[fa[fs]];
		} else {
			int rs=s.top().d;
			dp[x]=dp[fa[rs]]+1+dp[fa[x]]-
			dp[fs]+dp[fa[fs]]-dp[rs]+lst[fa[fs]];
		}
	} else { //RT
		tmp=x,s.push(bra[x]);
		dp[x]=dp[fa[x]];
		lst[x]=0;
	}
	for(int i=g[x];i;i=e[i].nex)
		dfs(e[i].adj); //递归
	if(tmp>0) s.pop();
	else s.push(bra[-tmp]);
	//★别☆忘★回☆溯★
}
int main(){
	scanf("%d\n%s",&n,inp+1);
	for(int i=1;i<=n;i++)
		bra[i]=(brack){(inp[i]=='('),i};
	for(int i=2;i<=n;i++){
		scanf("%d",fa+i);
		add(fa[i],i);
	}
	dfs(1); //dfs
	for(int i=1;i<=n;i++) 
		ans^=dp[i]*i; //不用异或见祖宗
	printf("%lld\n",ans); //不开long long见祖宗
	return 0;
}
```

考时有如神助，关键时刻想出用$lst$数组，要不然就没了。

此题细节多，容易见祖宗，读题一定要认真仔细。

谢谢大家! !


---

## 作者：majingxuan123 (赞：6)

# 题目描述
给定一个树，求从根节点到每个节点的括号串中，有多少个合法括号串。
# 解题思路
## 链的优化
1. 枚举节点，枚举区间，判断区间合法性（10pts）。

PS：洛谷可以得 20 分。
 
时间复杂度：$O(n^4)$。

代码如下：
```cpp
#include<iostream>
using namespace std;
const int N=5e5+10;
int n;
char s[N];
int a[N];
bool legitimate(int l,int r){
	int x=0;
	for(int i=l;i<=r;i++){
		if(s[i]=='(')x++;
		else x--;
		if(x<0)return false;
	}
	return (x==0);
}//判断括号串是否合法 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s+1;
	for(int p=1;p<=n;p++){
		for(int l=1;l<p;l++){
			for(int r=l+1;r<=p;r++){
				if(legitimate(l,r))a[p]++;
			}
		}
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans^=(long long)i*a[i];
	}
	cout<<ans<<'\n';
	return 0;
}
```
2. 容易发现，若区间 $(l,r)$ 是区间 $(1,x)$ 合法子串的合法子串，那么它一定是区间 $(1,x+1)$ 的合法子串。

所以，我们可以定义数组 $g$，$g_i$ 表示以第 $i$ 个字符结尾的合法括号串的数量；再定义数组 $f$，$f$ 为 $g$ 的前缀和，$f_i$ 即区间 $(1,i)$ 的合法子串的数量（20pts）。

时间复杂度：$O(n^3)$。

PS：洛谷可以得 35 分。

代码如下：
```cpp
#include<iostream>
using namespace std;
const int N=5e5+10;
int n;
char s[N];
int g[N],f[N];
bool legitimate(int l,int r){
	int x=0;
	for(int i=l;i<=r;i++){
		if(s[i]=='(')x++;
		else x--;
		if(x<0)return false;
	}
	return (x==0);
} 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s+1;
	for(int l=1;l<n;l++){
		for(int r=l+1;r<=n;r++){
			if(legitimate(l,r))g[r]++;
		}
	}
	for(int i=1;i<=n;i++)f[i]=f[i-1]+g[i];//计算前缀和 
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans^=(long long)i*f[i];
	}
	cout<<ans<<'\n';
	return 0;
}
```
3. 枚举 $l$，一边枚举 $r$ 一边判断是否合法（35pts）。

时间复杂度：$O(n^2)$。

代码如下：
```cpp
#include<iostream>
using namespace std;
const int N=5e5+10;
int n;
char s[N];
int g[N],f[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s+1;
	for(int l=1;l<n;l++){
		int x=0;
		for(int r=l;r<=n;r++){
			if(s[r]=='(')x++;
			else x--;
			if(x<0)break;
			else if(x==0)g[r]++;
		}
	}
	for(int i=1;i<=n;i++)f[i]=f[i-1]+g[i];
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans^=(long long)i*f[i];
	}
	cout<<ans<<'\n';
	return 0;
}
```
4. **重难点：**

设与 $s_i$ 匹配的左括号的下标为 $p_i$。

我们可以发现，第 $i$ 个字符可以匹配的字符串，一定包含了 $(p_i,i)$ 这段区间，于是我们可以把第 $i$ 个字符可以匹配的字符串分为两段：以 $p_i-1$ 结尾的合法括号串和区间 $(p_i,i)$，所以我们可以用一个栈存储 $p_i$，进一步推出 $g_i=g_{p_i-1}+1$，从而用线性的复杂度推出每个 $g_i$（55pts）。

时间复杂度：$O(n)$。

代码如下：
```cpp
#include<iostream>
#include<vector>
using namespace std;
const int N=5e5+10;
vector<int> v[N];
int n;
char s[N];
int fa[N];
long long g[N],f[N];
int stk[N],top;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s+1;
	for(int i=2;i<=n;i++){
		cin>>fa[i];
	}
	for(int i=1;i<=n;i++){
		if(s[i]=='(')stk[++top]=i;
		else{
			if(top)g[i]=g[stk[top--]-1]+1;//计算贡献 
		}
		f[i]=f[i-1]+g[i];
	} 
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans^=(long long)i*f[i];
	}
	cout<<ans<<'\n';
	return 0;
}
```
## 化链为树
有了链的线性做法，我们不难想出树上的做法（因为树可以转化为多条链），我们可以采用深度优先搜索来遍历树。

我们需解决两个难题：
- $g$ 数组和 $f$ 数组的求法。
- dfs 的回溯。

对于第一个难题，我们可以想，之所以在链时我么可以用 $g_i=g_{p_i-1}+1,f_i=f_{i-1}+g_i$ 的式子，是因为题目保证了节点编号是连续的，而 $i-1$ 是 $i$ 的父节点，即 $fa_i$。

所以我们只需把 $g_i=g_{p_i-1}+1,f_i=f_{i-1}+g_i$ 改成 $g_i=g_{fa_{p_i}}+1,f_i=f_{fa_{i-1}}+g_i$ 即可。

对于第二个难题，我们不难发现，在 dfs 的过程中，我们只需要还原存储左括号下标的栈即可。

这样，问题就得到了完美地解决（100pts）。

时间复杂度：$O(n)$。

代码如下：
```cpp
#include<iostream>
#include<vector>
using namespace std;
const int N=5e5+10;
vector<int> v[N];
int n;
char s[N];
int fa[N];
long long g[N],f[N];
int stk[N],top;
void dfs(int x){
	int tmp=0;
	if(s[x]=='('){
		stk[++top]=x;
	}
	else{
		if(top){
			tmp=stk[top];
			g[x]=g[fa[tmp]]+1;//计算贡献
			top--;
		}
	}
	f[x]=f[fa[x]]+g[x];//计算前缀和
	for(int i=0,len=v[x].size();i<len;i++){
		dfs(v[x][i]);
	}
	if(tmp)stk[++top]=tmp;
	else if(top)top--;//回溯
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s+1;
	for(int i=2;i<=n;i++){
		cin>>fa[i];
		v[fa[i]].push_back(i);
	}
	dfs(1);
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans^=(long long)i*f[i];
	}
	cout<<ans<<'\n';
	return 0;
}
```

# 总结

对于这种树上问题，我们可以先考虑链的做法，在逐步推广到树，最终得到正确的解法。

希望这篇题解能帮助到大家。

---

## 作者：JayJessy (赞：5)

本蒟蒻的第一篇全站推荐题解，~~给个赞！~~

一道类似树形 DP 的题目。  
## 题目解析
设 $dp_i$ 为从根到 $i$ 号节点，以 $i$ 结尾的**合法括号串**的数量。  
我们遍历整棵树，使用栈来维护每个 `)` 匹配的 `(` 的节点编号，对于每个节点 $u$：
- 若 $u$ 号结点上的括号为 `(`，则 $dp_u=0$，接着将该点的编号加进栈，继续 dfs，然后回溯。
```cpp
if(s[u-1]=='(') {
	res[u]=res[f[u]];
	stk.push(u);
	for(ll v:e[u]) dfs(v);
	stk.pop();
}
```
- 若 $u$ 号结点上的括号为 `)` 且栈空，则 $u$ 匹配不到 `(`，$dp_u=0$，继续 dfs。
```cpp
else if(stk.empty()) {
	res[u]=res[f[u]];
	for(ll v:e[u]) dfs(v);
}
```
- 若 $u$ 号结点上的括号为 `)` 且栈不空，则 $u$ 能匹配到 `(`，则将栈顶元素 $k$ 取出，$dp_u=dp_{f_k}+1$，因为对于每个从根到 $k$ 且以 $k$ 结尾的**合法括号串**（**还有空串**），末尾加上从 $k$ 到 $u$ 的括号串同样合法。别忘了将 $k$ 弹出！最后继续 dfs 并回溯。
```cpp
else {
	ll k=stk.top();
	dp[u]=dp[f[k]]+1;
	res[u]=res[f[u]]+dp[u];
	stk.pop();
	for(ll v:e[u]) dfs(v);
	stk.push(k);
}
```
**还有，别忘记做异或和！**  
好了，该说的都说了，接下来是
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e5+10;
stack<ll> stk;
vector<ll> e[N];
string s;
ll n,f[N],dp[N],res[N],ans;
void dfs(ll u) {
	if(s[u-1]=='(') {
		res[u]=res[f[u]];
		stk.push(u);
		for(ll v:e[u]) dfs(v);
		stk.pop();
	} else if(stk.empty()) {
		res[u]=res[f[u]];
		for(ll v:e[u]) dfs(v);
	} else {
		ll k=stk.top();
		dp[u]=dp[f[k]]+1;
		res[u]=res[f[u]]+dp[u];
		stk.pop();
		for(ll v:e[u]) dfs(v);
		stk.push(k);
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>s;
	for(ll i=2; i<=n; i++) cin>>f[i],e[f[i]].push_back(i);
	dfs(1);
	for(ll i=1; i<=n; i++) ans^=res[i]*i;
	cout<<ans;
	return 0;
}
```
完结撒花~~

---

## 作者：Aleph1022 (赞：3)

我的做法怎么这么奇异？目前似乎没找到和我一样的……  
也是 DP，但是和大多数人的思路不大一样。

首先考虑把 $\texttt ($ 看做 $1$，$\texttt )$ 看做 $-1$，再来考虑一个串合法的充要条件：
1. 和为 $0$，即 $\texttt (,\texttt )$ 个数相等。
2. 任意位置的前缀和非负。

考虑一个序列上的弱化版问题，则易想到设状态 $f_{i,j}$ 表示**以 $i$ 结尾，和为 $j$，任意位置的前缀和非负的子串个数**。  
若设 $a_i$ 表示字符串第 $i$ 位的字符，则有转移
$$f_{i,j}=\begin{cases}0,&a_i=\texttt ( \land j=0 \\f_{i-1,0}+1,&a_i=\texttt ( \land j=1 \\f_{i-1,j-1},&a_i=\texttt ( \land j \ge 2 \\f_{i-1,j+1},&a_i=\texttt )\end{cases}$$

注意到若缩掉第一维，转移相当于将整个状态**平移 $1$ 或 $-1$ 位**，并修改部分状态。  
由于修改的状态很少，所以可以直接暴力修改。

转回树上，发现只需要支持一个回溯操作。  
容易发现只需要记下被修改为 $0$ 的状态原来如何即可。

复杂度是 $O(n)$ 的。

代码：
```cpp
#include <cstdio>
using namespace std;
const int N = 5e5;
int n,a[N + 5];
int to[N * 2 + 5],pre[N * 2 + 5],first[N + 5];
inline void add(int u,int v)
{
	static int tot = 0;
	to[++tot] = v,pre[tot] = first[u],first[u] = tot;
}
int _f[N * 3 + 5],*f = _f + N,rot,temp[N + 5];
long long cur,ans;
void dfs(int p)
{
	rot += a[p];
	a[p] == 1 && (temp[p] = f[-rot],f[-rot] = 0,++f[1 - rot]);
	ans ^= p * (cur += f[-rot]);
	for(register int i = first[p];i;i = pre[i])
		dfs(to[i]);
	cur -= f[-rot];
	a[p] == 1 && (--f[1 - rot],f[-rot] = temp[p]);
	rot -= a[p];
}
int main()
{
	scanf("%d",&n);
	char ch;
	for(register int i = 1;i <= n;++i)
		scanf(" %c",&ch),a[i] = ch == '(' ? 1 : -1;
	int u;
	for(register int i = 2;i <= n;++i)
		scanf("%d",&u),add(u,i);
	dfs(1);
	printf("%lld\n",ans);
}
```

---

## 作者：ix35 (赞：3)

我的解法：

记$dep[i]$表示$i$到根的路径中左括号的个数减右括号的个数，$pre[i]$表示$i$的祖先中第一个$dep$值比$i$小的。$query(i,v)$表示查询$i$到根节点中有多少个点$dep$值为$v$。

然后$i$这个点的答案设为$dp[i]$，那么：

$dp[i]=dp[fa_i]+query(i,dep[i])-query(pre[i],dep[i])$

表示首先考虑右端点不是$i$的，然后考虑右端点是$i$的，那么左端点的$dep$值显然要和$dep[i]$相等，且$dep[i]$必然是路径上最小的$dep$（否则有一个前缀右括号比左括号多就不满足要求了），所以要差分掉$pre[i]$上面的答案。

计算$query$可以离线，所有询问按照$dfn$排序，用一个桶记录当前$dfs$到的点到根的路径上所有点的$dep$，然后询问就是求桶里一个位置的值了。

```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=500010;
struct Q {
	Q () {ps=v=fr=flg=0;}
	Q (int a,int b,int c,int d) {ps=a,v=b,fr=c,flg=d;}
	int ps,v,fr,flg;
}q[2*MAXN];
int n,x,eg,tot,cnt,cur,v[MAXN],dep[MAXN],bac[2*MAXN],hd[MAXN],ver[2*MAXN],nx[2*MAXN];
int f[MAXN][22],mn[MAXN][22],dfn[MAXN],pre[MAXN];
ll dp[MAXN],ans;
char c[MAXN];
bool cmp (Q a,Q b) {return dfn[a.ps]<dfn[b.ps];}
void add_edge (int x,int y) {
	ver[++eg]=y;
	nx[eg]=hd[x];
	hd[x]=eg;
	return;
}
void dfs1 (int x,int fa) {
	dep[x]=dep[fa]+v[x],dfn[x]=++cnt,f[x][0]=fa,mn[x][0]=dep[fa];
	for (int i=1;i<=20;i++) {
		f[x][i]=f[f[x][i-1]][i-1];
		mn[x][i]=min(mn[x][i-1],mn[f[x][i-1]][i-1]);
	}
	int pos=x;
	for (int i=20;i>=0;i--) {
		if (mn[pos][i]>=dep[x]) {pos=f[pos][i];}
	}
	pre[x]=f[pos][0];
	q[++tot]=Q(x,dep[x],x,1);
	q[++tot]=Q(pre[x],dep[x],x,-1);
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs1(ver[i],x);
	}
	return;
}
void dfs2 (int x,int fa) {
	while (cur<=tot&&q[cur].ps==x) {
		dp[q[cur].fr]+=1ll*q[cur].flg*bac[q[cur].v];
		cur++;
	}
	bac[dep[x]]++;
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs2(ver[i],x);
	}
	bac[dep[x]]--;
	return;
}
void dfs3 (int x,int fa) {
	dp[x]+=dp[fa];
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs3(ver[i],x);
	}
	return;
}
int main () {
	freopen("brackets.in","r",stdin);
	freopen("brackets.out","w",stdout);
	scanf("%d",&n);
	scanf("%s",c+1);
	bac[MAXN-10]=1,dep[0]=MAXN-10;
	for (int i=1;i<=n;i++) {v[i]=(c[i]=='('?1:-1);}
	for (int i=2;i<=n;i++) {
		scanf("%d",&x);
		add_edge(i,x),add_edge(x,i);
	}
	dfs1(1,0);
	sort(q+1,q+tot+1,cmp);
	cur=1;
	while (cur<=tot&&q[cur].ps==0) {cur++;}
	dfs2(1,0);
	dfs3(1,0);
	for (int i=1;i<=n;i++) {ans^=(1ll*i*dp[i]);}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：dove (赞：2)

很好玩的模拟题，虽然[一些神仙可以 20 loc dp 切掉](https://www.luogu.org/discuss/show/170329)

## 引入

首先思考：当一对括号被补全了，它对当前这个前缀的有效子串数量有何影响？

```
( ( ( ) ) ( ) ( )
                ^
1 2 3 4 5 6 7 8 9
```

考虑上例，假设我们刚刚将 9 位置的括号加入进串。

- 显然形成了新的有效串 $(8,9)$
- 同时可以加入前面的有效串组成 $(6,9)$
- 同理，再加入，还有 $(2,9)$ （即$(2,5) + (6,7) + (8,9)$）。

显然，我们每次增加一个括号进串使得有新的括号对产生时，增加的有效子串数即是套在上一层括号里所有并列的括号对的数量。

## 解法

我们定义一个栈 $nest$，令 $nest_i$ 表示*恰*在第 $i$ 层嵌套内的括号对数量（嵌套更深的不计）：

```cpp
vector<int> nest;
```

那么，我们就可以分类讨论：

- **当上一个字符是 `(` 且当前字符是 `(`**：又嵌套了一层，所以 `nest.push_back(0);`
- **当上一个字符是 `(` 且当前字符是 `)`**：新增了一对括号，所以 `nest.back()++` 并且当前节点有效子串数 `+= nest.back()`；
- **当上一个字符是 `)` 且当前字符是 `(`**：直接接上前面的串，毫无影响；
- **当上一个字符是 `)` 且当前字符是 `)`**：更内一层的嵌套没了，所以 `nest.pop_back()`；同时注意到当前一层的嵌套新增了一对括号，所以需要再同第 2 种情况处理。

以上是正常情况，再考虑边界情况：
- 最开始的 `)` 以及栈弹空之后的 `)` 毫无贡献，故全数忽略；
- 最开始的 `(` 以及栈弹空之后的 `(` 必须要 `nest.push_back(0)`，因为之前并没有任何串可以接上。

搜完节点不要忘了回溯哦

## *Code*
挺丑的，凑合看下吧

```cpp
#include <iostream>
#include <vector>
#include <string>
#define int long long
using namespace std;

// 树
vector<vector<int>> tree;
// 栈
vector<int> nest;
// 存储到各节点路径上的有效子串数量
vector<int> len;
// 各节点对应的括号
string paren;

void dfs(int fa, int from) {
    #define match(a,b) if (paren[fa] == a && paren[from] == b)
    // 到该节点的路径中的有效子串数量至少为到其父节点的路径的有效子串数量
    len[from] = len[fa];
    // 回溯标记
    bool pushed = false, added = false; int popped = -1;
    // 各种情况
    match('(', '(')
        pushed = true, nest.push_back(0);
    match('(', ')')
        added = true, nest.back()++, len[from] += nest.back();
    match(')', '(')
        if (!nest.size())
            pushed = true, nest.push_back(0);
    match(')', ')') {
        if (nest.size())
            popped = nest.back(), nest.pop_back();
        if (nest.size())
            added = true, nest.back()++, len[from] += nest.back();
    }
    // 搜
    for (int to = 0; to < tree[from].size(); to++)
        dfs(from, tree[from][to]);
    // 回溯
    if (pushed) nest.pop_back();
    if (added) nest.back()--;
    if (popped > -1) nest.push_back(popped);
}
signed main() {
    int cnt;
    cin >> cnt;
    tree.resize(cnt);
    len.resize(cnt);
    cin >> paren;
    // 建树
    for (int i = 1; i < cnt; i++) {
        int fa;
        cin >> fa;
        tree[fa - 1].push_back(i);
    }
    dfs(0, 0);
    // 算异或和
    int result = len[0];
    for (int i = 1; i < cnt; i++) {
        result ^= (i + 1) * len[i];
    }
    cout << result;
}
```


---

## 作者：FatLLion (赞：1)

好题，确实需要一定的递推能力。

括号会组成一棵树，而我们需要处理的是树上的每一条从根节点出发的简单路径，这里我们先想象成在一行上进行处理和思考。

根据题意，一个合法的括号串里会有如下的情况：

- 若干个合法字符串连在一起，形如 `ABCD`。
- 括号叠叠乐，形如 `((()))`。

而我们这个时候可以多观察观察这些合法字符串，或者自己手写几个，不难发现，合法字符串其实都是有独立性的。

做个解释：如果我们利用前缀和的思想，将每一个独立的合法字符串的贡献单独计算，那么形如括号叠叠乐的形式的合法字符串，最外层括号里头的所有括号都只会对当前这个合法字符串的贡献起作用，不会影响到其他的合法字符串。而如果是若干个合法字符串连在一起，那么就会发现，每一个合法字符串都会多出额外 2 点的贡献。

回想匹配字符串的方法，常用的是栈，可是如果使用这个方法，就很难把每一个合法字符串都单独拎出来，于是我们在刚刚的思路基础上改变一下，我们的前缀和不再基于大的独立的合法字符串，而是基于每一个括号，这样在每次弹出的时候也可以对每一个大的独立的合法字符串的最外层括号进行单独处理。

做个解释：因为大的独立的合法字符串都是最外层的括号挨在一起的，所以我们只需要去看我们当前的右括号所匹配的左括号前边一个是不是被匹配过的右括号即可，这样也可以对里层的括号进行贡献值单独的处理。

这里我们把思路从一个单独的列上转移回树的方向，不难想到用另外一个数组 $f_i$ 表示节点 $i$ 的前一个节点。

接下来就是代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int INF = 1e9;
const int N = 5e5+100;

void read (int &x) {
    int f = 1;x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') { x = x*10+ch-'0'; ch = getchar();}
    x *= f;
}

void print (int x) {
    if (x<0) putchar('-'), x = -x;
    if (x<10) putchar(x+'0');
    else print(x/10), putchar(x%10+'0');
}

struct R {
	int u, v, lst;
}road[N];

int n, final[N], tot, fa[N], top, stk[N];
ll cnt[N], res[N], ans;
char s[N];

void add (int u, int v) { road[++tot].u = u, road[tot].v = v, road[tot].lst = final[u], final[u] = tot; }

void push (int pos) { stk[++top] = pos; }
void pop () { --top; }
bool have () { return top; }

void dfs (int rt) {
	int lst = 0;
	if (s[rt] == ')') {
		if (have()) lst = stk[top], cnt[rt] = cnt[fa[lst]]+1, pop();
	} else if (s[rt] == '(') push(rt);
	res[rt] = res[fa[rt]] + cnt[rt];
	for (int i = final[rt];i;i = road[i].lst) dfs(road[i].v);
	if (lst) push(lst);
	else if (top) pop();
}

int main () {
	//freopen("xxx.in", "r", stdin);
	//freopen("xxx.out", "w", stdout);
	read(n);
	scanf("%s", s+1);
	for (int i = 1;i < n;i++) {
		int f; read(f);
		add(f, i+1);
		fa[i+1] = f;
	}
	dfs(1);
	for (int i = 1;i <= n;i++) ans = ans^(res[i]*(ll)i);
	printf("%lld\n", ans);
	return 0;
}

```

---

## 作者：封禁用户 (赞：1)

第一眼看到题目，还以为是动态规划，根本看不懂，后来把所有题目都看了一遍，发现都看不懂，只能先切这道,思考了 $10$ 分钟，想到了可不可以用 dfs 遍历树！

用 dfs 遍历树，每一次遍历进来的字符是不是 `(`，如果是，用一个数组存下 `(` 的位置,如果是 `)`，就判断一下还有没有 `(`，如果有，做一个 $p_x=p_{fl_x}+1$（$fl_x$ 指左括号的父节点）来统计贡献，然后把左括号数组的总数减 $1$。

做完这些，考虑计算最后答案，用$sum_x=sum_{f_x}+p_x$（$f_x$ 指 $x$ 的父节点）来计算根节点到 $x$ 的最多组成的合法字串。

然后 dfs 下一个点（记得链式前向星存图）。

最后别忘记“子承父业”把 $ls_{cnt}$ 回溯一下。

最后计算答案，AC！

```cpp
#include <bits/stdc++.h>
#define ll long long
#define R register
#define rep(i, x, n) for(R int i = x; i <= n; i = -~i)
#define Rep(i, a, b, c) for(R int i = a; i <= b; i += c)
#define endl "\n"
#define spa  printf(" ")
#define fop(x) freopen(#x".in", "r", stdin);freopen(#x".out", "w", stdout);
#define endl "\n"
#define Yesn puts("Yes")
#define Yes printf("Yes")
#define Non puts("No")
#define No printf("No")
#define YESn puts("YES")
#define YES printf("YES")
#define NOn puts("NO")
#define NO printf("NO")
#define inf 2e18
#define pt printf
#define sf scanf
#define sd "%d"
#define sld "%lld"
#define db double
using namespace std;

void fre() {
#ifdef ONLINE_JUDGE
	fop(1);
#endif
}
const int Arr_Max_size = 500005;
//using namespace Fast;
/*
----------------------------------
        This is main code
----------------------------------
*/
int nxt[Arr_Max_size], to[Arr_Max_size], head[Arr_Max_size], cnt;
ll N, ans, f[Arr_Max_size];
ll p[Arr_Max_size], ls[Arr_Max_size], cnnt, sum[Arr_Max_size];
string s;

void add(int u, int v) {
	nxt[++ cnt] = head[u];
	to[cnt] = v;
	head[u] = cnt;
}

void Dfs(int x) {
	int bz = 0;
	if(s[x] == ')') {
		if(cnnt != 0) {
			bz = ls[cnnt];
			p[x] = p[f[bz]] + 1;
			-- cnnt;
		}
	} else if(s[x] == '(') ls[++ cnnt] = x;
	sum[x] = sum[f[x]] + p[x];
	for(int i = head[x]; i != 0; i = nxt[i]) {
		Dfs(to[i]);
	}
	if(bz != 0) ls[++ cnnt] = bz;
	else if(cnnt != 0) cnnt --;
}

void solve() {
	cin >> N;
	cin >> s;
	s = " " + s;
	rep(i, 2, N) {
		int x;
		cin >> x;
		add(x, i);
		f[i] = x;
	}
	Dfs(1);
	rep(i, 1, N) {
		ans = ans ^ (sum[i] * (ll)i);
	}
	cout << ans;
}
int main() {
	solve();
	return 0;
}
```

---

## 作者：Gu_Pigeon (赞：1)

决定 $\Huge\text{AFO}$ 前写篇题解，讲讲考场上的过程吧，也就当写游记吧 ~~（游什么）~~。

$\text{2019-11-16 08:2x}$ 考场老师公布解压密码，，认真思考…???~~突然感觉受到质疑却又觉得挺对~~

$\text{2019-11-16 09:xx}$ 打了四十几分钟才肝完T1，~~唉我真没有实力~~（~~还没开 `ull` 结果95~~）

在草稿纸上画了两笔手玩样例以后，对T2大概有点理解了。

最暴力的，枚举每一个节点( $O(n)$ )，再枚举每一个子区间( $O(n^2)$ )，再判断是否合法( $O(n)$ )，时间复杂度 $O(n^4)$

接下来考虑优化。

**发现**：

1. 一个节点到1号节点（根节点）之间的括号序列合法子串数，等于其父节点到1号节点（根节点）之间的括号序列合法子串数，加上以该节点为结尾的合法子串数

$ prove $: 显然的，节点到根节点之间的括号序列和其父亲节点到根节点之间的括号序列只是多了一个 `(` 或者 `)` ，而在括号序列末尾接一个符号，增加的合法序列数一定是与新加上的这个括号有关的（否则就会计入父节点的答案）

$RT$(如图)：

![](https://cdn.luogu.com.cn/upload/image_hosting/fugopsoe.png)

那么，有一种想法，就是dfs整棵树，将父节点的答案下传到子节点，然后判断以最后一个括号为结尾的合法括号序列有多少就可以了。

朴素判断序列是否合法，即 $O(n)$ 枚举以最后一个括号为结尾的序列，$O(n)$ 判断，复杂度$O(n^3)$，少了个n。

~~当然你可以判断最后一位是 `(` 的情况就跳过枚举直接转到下一层~~

$\text{2019-11-16 09:3x}$ 现在还有一个问题，判断括号序列实在是**太 慢 了**

然后就想起一种 基 本 操 作，用栈模拟括号序列

> `(` 表示将栈中的 `size++`

> `)` 表示将栈中的 `size--`

2. 符合的括号序列，需要size的值一直为非负数且开始的size与结束的size相等

$ prove $: 当一个括号序列为合法的，当且仅当：

> * `(` 的个数 = `)` 的个数
>
> * 对于每一个位置，前缀`(`的个数不少于`)`的个数

那么实际上我们不需要一个真正的栈而只需要记录size值即可

那么如何判断子串是否合法？毕竟子串的开头size不一定为零

举栗：

```
bracket sequence: ( ( ) ( ( ) ) ( ( ) ) )  ) (  ) ( ( 
value of size:    1 2 1 2 3 2 1 2 3 2 1 0 -1 0 -1 0 1
```

附上方样例折线图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0vglismo.png)

为保证子串为合法序列，根据上方~~照猫画葫芦~~可得合法条件为：

> * 子串头的size值 = 子串尾的size值
>
> * 在子串中所有位置的size值都大于等于子串尾的size

在图形上直观的表示就是：在一段范围内形成“山峰”

![](https://cdn.luogu.com.cn/upload/image_hosting/bcgk2gyf.png)

上图中颜色覆盖部分是合法的，因为这段区间两端的值相等且中间点的高度都不小于两端

$\text{2019-11-16 10:xx}$ 所以可以想到，对于每一个右端点固定的询问，在一段符合的区间内找到与右端点值相等的点的个数，**符合**的区间指区间内的所有点的高度不小于右端点高度，例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/na1wigrp.png)

求以点A结尾的合法区间个数时，发现在x坐标为1的点至A点之间的点都是不低于A点的，所以左端点的取值可以在 `[1, A - 1]` 之间，而在合法区间内有3个高度与A相等的点，事实上这些点都可以作为左端点，所以以A为右端点的合法括号序列子串有3个。

计算出各个高度后，我们在$O(n)$时间内计算出了合法子串数。

$\text{2019-11-16 10:2x}$ 需要注意：

* 左端点的合法区间的左边界需要保证区间内的点的高度**全部**都要大于等于右端点，所以发现第一个小于右端点的，则马上停止。

现在，时间复杂度$O(n^2)$，考虑继续优化。

两种选择：

1. 数据结构优化

2. 省去冗余数据

用数据结构处理的话，需要考虑在尽量短的时间内求出**一段区间内**某一个**值**出现的个数

## 主席树是你的最佳选择！

~~什么？不会？~~

## 树状数组现身！

毕竟以往的NOIP中（~~虽然现在是CSP~~）有很多毒瘤数据结构题（比如列队？）都可以用树状数组来做，不如就往这方面想一想。

$\text{2019-11-16 10:3x}$ 树状数组不会MLE吗？

~~当然会了~~

如果直接用树状数组代行主席树的功能的话当然会MLE，所以考虑简化记录下来的数据。

然后发现，要找的区间其实是有一定规律的，就是在 `(目前最后一个x-1的位置, 目前位置)` 其中找出 `x` 的个数（其中 `x` 指的是目前位置的`size`值，注意是**全开区间**）

那么其实我们只需要记下**最近一次**`x-1`出现的位置，再维护一下前缀和是不是就可以了呢？

~~似乎没有那么简单~~

> Q:这玩意用树状数组咋维护啊？
>
> A:树状数组维护前缀和，再加一个以值域为下标的数组，记录最近的`x-1`出现在哪里就可以了。
>
> Q:但是这还是要用值域中各个值出现次数前缀和的树状数组，还是会MLE吧？
>
> A:~~对啊~~
> 
> Q:但是这前缀和**直接用数组记下来**不就好了吗！
>
> A:~~emmm你说的都对~~

$\text{2019-11-16 10:5x}$ 经过一定的推导，我们发现只需要记下当前值为 `x-1` 时前面已经有几个值为 `x` 的点，并在找到一个值为 `x` 的点时，先将answer加上 `目前 x 的出现次数（不包括该点）-先前求出的x-1前的x个数`，那么我们就在 $O(1)$时间内完成了一次答案的统计！

$\text{2019-11-16 11:00}$ 再梳理一下，我们就得出了统计的流程：

```
dfs の 过程：
开始
  求出当前size值;
  让cnt[当前size值]等于precnt[当前size值 + 1];
  precnt加上1
  统计该节点答案 = precnt[x] - cnt[x-1]
  对于该节点的所有儿子 dfs(儿子);
  回溯
结束
```
`cnt[x-1]` 表示最近的 `x-1` 的前面 `x` 的个数。
`precnt[x]` 表示 `x` 出现的个数

这部分的代码写出来如下：

```
void dfs(int x, long long res, int sum)
{
	int tt = res, tmp;
	sum += a[x];
	tmp = cnt[sum + N];
	if (~a[x]) cnt[sum + N] = precnt[sum + N]; else tt += precnt[sum + N] - cnt[sum + N];
	++precnt[sum + N];
	for (int i = head[x]; i; i = nxt[i])
	{
		int y = to[i];
		dfs(y, tt, sum);
	}
	ans ^= (long long)x * tt;
	cnt[sum + N] = tmp;
	--precnt[sum + N];
}
```

你可能会发现这里的实现有一些不同：

```
if (~a[x]) cnt[sum + N] = precnt[sum + N]; else tt += precnt[sum + N] - cnt[sum + N];
```

这一句中，因为 `a[x]` 要么是 `1` ，要么是 `-1` 。

当 `a[x] == 1` 时，说明当前的值 `x` 是由 `x-1` 加一得来的，所以要改变 `cnt` 的值，而当一个序列以 `(` 结尾（即 `a[x] == 1`）时，很明显这个括号是不会有贡献的；

当 `a[x] == -1` 时，说明当前的值 `x` 是由 `x+1` 减去一得来的，所以要统计新增加的答案，而不去更新 `cnt`；

这样，基本上这题就解决了，**注意：`cnt` 数组和 `precnt` 数组是以值域为下标的，而会出现负数所以上面的数组下标在使用时要 `+N`**

$\text{2019-11-16 11:10}$ 然后就有了下面的代码：

```
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 5;
int to[N], nxt[N], head[N], tot, cnt[N << 1], precnt[N << 1], a[N], n, x;
long long ans;
char s[N];

inline void addedge(int x, int y)
{
	to[++tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
}

void dfs(int x, long long res, int sum)
{
	int tt = res, tmp;
	sum += a[x];
	tmp = cnt[sum + N];
	if (~a[x]) cnt[sum + N] = precnt[sum + N]; else tt += precnt[sum + N] - cnt[sum + N];
	++precnt[sum + N];
	for (int i = head[x]; i; i = nxt[i])
	{
		int y = to[i];
		dfs(y, tt, sum);
	}
	ans ^= (long long)x * tt;
	cnt[sum + N] = tmp;
	--precnt[sum + N];
}

int main()
{
	scanf("%d%s", &n, s);
	for (int i = 0; i < n; i++)
		if (s[i] == '(') a[i + 1] = 1; else a[i + 1] = -1;
	for (int i = 2; i <= n; i++)
		scanf("%d", &x), addedge(x, i);
	++precnt[N];
	dfs(1, 0, 0);
	printf("%lld", ans);
}
```

~~然后就只剩下写T3暴力的时间了~~

~~虽然也就只会暴力~~

最后 Day1 205分，还行吧~~虽然人均210~~

~~Day2 爆炸，我$\Huge\text{AFO}$了~~


---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P5658)

---

# 思路：

对于一个点，我们分类讨论左括号和右括号的两种操作。

对于加入点的策略。

首先让当前点继承父节点的答案，然后考虑新增答案。

如果加入的是右括号，它可能会与前面的第一个左括号匹配，所以考虑对左括号维护一个栈。考虑这两个括号中间的部分，它一定是一个合法子串或空串（假如中间有不匹配的右括号，那么它一定会和当前左括号匹配，假如中间有不匹配的左括号，那么它会成为第一个左括号，变成当前右括号的匹配对象）。所以当前右括号匹配后一定会新增一个答案，考虑其他的答案，一定是多组匹配的括号相连，形如 $(⋯)(⋯)(⋯)$。所以我们用 ```while``` 循环查询当前 $now$ 节点匹配的左括号的前一个是否是右括号且有匹配（匹配括号内部一样也是合法子串。同时我们需要对右括号维护一个匹配左括号）：如果是，那么答案加 $1$，并将 $now$ 更新为这个右括号，循环查询；如果不是，那么退出。这样就可以正确地维护出当前加入点的新增答案了。

如果加入的是左括号，那么不会有新增的答案（不可能与另一个右括号匹配），只需维护栈。

对于退出点时策略。

如果退出的是右括号，那么其他点的影响只有“可能占据了一个匹配的左括号”，重新在栈里加入这个左括号即可。

如果退出的是左括号，那么在栈里弹出即可。

代码如下：
```cpp
 #include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
struct E{
	int start,to;
}e[N];
int h[N],st[N],v[N],f[N],ans[N],sum[N],n,m,P,tot;
string s;
stack<int> q;
void add(int start,int to){
	e[++P].to=to;
	e[P].start=h[start];
	h[start]=P;
}
void dfs(int p){
    int t=q.top(),flag=0;
    if(!q.empty()&&st[q.top()]==1&&st[p]==2){
        t=q.top();
        q.pop();
		v[t]=1;
        flag=1;
        ans[p]=ans[f[t]]+1;
    }else{
        q.push(p);
    }
    sum[p]=sum[f[p]]+ans[p];
    for(int i=h[p];i;i=e[i].start){
    	int k=e[i].to;
    	dfs(k);
	}   
	if(flag){
        q.push(t);
        v[t]=0;
    }else if(v[p]==0){
        q.pop();   
    }
}
signed main(){
    cin>>n>>s;
	q.push(0);
    for(int i=0;i<=n-1;i++){
        if(s[i]=='('){
            st[i+1]=1;
        }else{
            st[i+1]=2;
        }
    }
    for(int i=2;i<=n;i++){
        cin>>f[i];
        add(f[i],i);
    }
    dfs(1);
    for(int i=1;i<=n;i++){
	    tot^=i*sum[i];
    }
    cout<<tot<<endl;
    return 0;
}
```
完结撒花~

---

## 作者：lylcpp (赞：0)

## 合法括号串判断方法

本题中合法括号串的定义如下：

1. `()` 是合法括号串。
2. 如果 `A` 是合法括号串，则 `(A)` 是合法括号串。
3. 如果 `A`，`B` 是合法括号串，则 `AB` 是合法括号串。

这里介绍一下用栈和前缀和来判断合法括号串。

按照字符串一位一位遍历，遇到左括号`(`就塞进去。如果遇到`)`就判断栈顶是否是`(`，前提是栈不为空，如果是，那就匹配成功，弹出栈顶，否则就不可能匹配成功。

第二个前缀和，还是一位一位遍历，假设有一个变量 $x$，如果遇到`(`，$x = x + 1$，否则 $x = x - 1$，原理就是每一个左括号抵消一个右括号，如果最终 $x = 0$，就代表匹配成功，否则就是不成功。

## $20$ pts $O(n^4)$

看到 Subtask $1 \sim 2$，$n \le 8$ 和 $n \le 200$，很明显，可以直接暴力，虽然 $200$ 的数据有点悬。

第一层循环枚举结尾 $i$，第二第三层循环枚举左右下标，第四层从判断是否合法。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
#include<vector>

using namespace std;

const int N = 209;
int n, fa[N], k[N];
string s;
long long ans;

bool check(int l, int r) {
	int sum = 0;
	for (int i = l; i <= r; i++) {
		if (s[i] == '(') sum++;
		if (s[i] == ')') sum--;
		if (sum < 0) return 0;
	}
	if (sum > 0) return 0;
	else return 1; 
}

int main() {
	cin >> n >> s;
	s = " " + s;
	for (int i = 2; i <= n; i++) scanf("%d", &fa[i]);
	for (int i = 1; i <= n; i++) {
		for (int l = 1; l < i; l++) {
			for (int r = l + 1; r <= i; r++) {
				if (check(l, r))
					k[i]++;
			}
		}
		ans ^= (long long)(i * k[i]);
	} 
	printf("%lld", ans);
	return 0;
}
``````

## $55$ pts $O(n)$

还是针对链的情况，即 Subtask $11 \sim 14$ 和 $5 \sim 7$。

我们假设 $w_i$ 表示以 $i$ 结尾的合法括号串数量，而 $k_i$ 表示从 $1 \sim i$ 中所有合法括号串的数量。假设当前匹配到第 $t$ 位，并且这一位是 `)`，那么就有 $w_i = w_{t-1} + 1$，$t-1$ 是 $t$ 的父亲。$k_i = k_{i-1} + w_i$，$i$ 是 $i-1$ 的父亲。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
#include<vector>
#define int long long

using namespace std;

const int N = 500005;
int n, fa[N], k[N], w[N], ans;
stack<int> st;
string s;

signed main() {
	cin >> n >> s;
	s = " " + s;
	for (int i = 2; i <= n; i++) scanf("%d", &fa[i]);
	for (int i = 1; i <= n; i++) {
		if (s[i] == ')') {
			if (st.size()) {
				int h = st.top(); st.pop();
				w[i] = w[h-1] + 1;
			}
		}
		else if (s[i] == '(') st.push(i);
		k[i] = k[i-1] + w[i];
		ans ^= (long long)(i * k[i]);
	} 
	printf("%lld", ans);
	return 0;
}
``````

## $70$ pts

针对数据规模较小的数据结构为树的情况，从下往上遍历，但要记录每个节点的孩子，于是，对于 $w$ 和 $k$ 的转移有了新的变化。

$w_j = w_{son_t} + 1, k_i = k_i + w_j$

$son_t$ 表示 $t$ 的孩子，之前数组下标是 $t - 1$ 是因为我们从上往下遍历，孩子要依赖于父亲，而现在从下往上遍历，父亲依赖于孩子。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
#include<vector>
#define int long long

using namespace std;

const int N = 500005;
int n, fa[N], k[N], w[N], ans, son[N];
stack<int> st;
string s;

void solve1() {
	for (int i = 1; i <= n; i++) {
		if (s[i] == ')') {
			if (st.size()) {
				int h = st.top(); st.pop();
				w[i] = w[h-1] + 1;
			}
		}
		else if (s[i] == '(') st.push(i);
		k[i] = k[i-1] + w[i];
		ans ^= (long long)(i * k[i]);
	} 
}

void solve2() {
	for (int i = 1; i <= n; i++) {
		stack<int> stk;
		memset(w, 0, sizeof(w));
		memset(k, 0, sizeof(k));
		for (int j = i; j; j = fa[j]) {
			son[fa[j]] = j;
			if (s[j] == ')') stk.push(j);
			else {
				if (stk.size()) {
					int h = stk.top(); stk.pop();
					w[j] = w[son[h]] + 1;
				}
			}
			k[i] += w[j];
		}
		ans ^= (i * k[i]);
	}
}

signed main() {
	cin >> n >> s;
	s = " " + s;
	bool A = 1;
	for (int i = 2; i <= n; i++) {
		scanf("%lld", &fa[i]);
		if (fa[i] != i - 1) A = 0;
	}
	if (A) solve1();
	else solve2();
	printf("%lld", ans);
	return 0;
}
``````

## 100pts

相对于 $70$ 分的解法，我们选择从上往下遍历，从根节点开始，这时，$w$ 和 $k$ 是这样转移的：

$w_x = w_{fa_t} + 1, k_x = k_{fa_x} + w_x$，$fa_t$ 表示 $t$ 的父亲，这里因为是从上往下，所以是儿子依赖于父亲。

这还不够，因为回溯的过程中会导致字符串可能不一样，假设节点 $u$，在 dfs 过程中匹配后我们会得到 $t$ 的值，如果 $t \ne 0$，说明 $u$ 和 $t$ 匹配，且 $t$ 的深度比 $u$ 小，所以在回溯过程中，我们要把 $t$ 重新放会栈里。$u$ 不放是因为我们已经把 $u$ 的情况都搜索完了。

还有一种是 $t = 0$，那么把栈顶去掉，因为 $t$ 最后没有能匹配的字符了，所以我们把 $u$ 去掉。

## 代码

代码中的 $res$ 就是 $w$，$sum$ 就是 $k$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
#include<vector>
#define int long long

using namespace std;

const int maxn = 500005;
int n, fa[maxn], res[maxn], sum[maxn], ans;
char c[maxn];
stack<int> s;
vector<int> g[maxn];

void dfs(int x) {
	int tmp = 0;
	if (c[x] == ')') {
		if (s.size()) {
			tmp = s.top();
			res[x] = res[fa[tmp]] + 1;
			s.pop(); 
		}
	}
	else if (c[x] == '(') s.push(x);
	sum[x] = sum[fa[x]] + res[x];
	for (auto v : g[x])	
		dfs(v);
	if (tmp != 0) s.push(tmp);
	else if (s.size()) s.pop();
}

signed main() {
	scanf("%lld%s", &n, c + 1);
	for (int i = 2; i <= n; i++) {
		int u;
		scanf("%d", &u);
		g[u].push_back(i); 
		fa[i] = u;
	}
	dfs(1);
	for (int i = 1; i <= n; i++) 
		ans ^= (sum[i] * i);
	printf("%lld", ans);
	return 0;
}
``````

---


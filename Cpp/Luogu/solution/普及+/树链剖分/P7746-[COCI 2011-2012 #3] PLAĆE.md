# [COCI 2011/2012 #3] PLAĆE

## 题目背景

Mirko 喜欢汽车，他终于成功地开办了自己的汽车工厂。

## 题目描述

工厂有 $n$ 个员工，每个人都有一个上司（除了 Mirko 默认为每个人的上司）。Mirko 用 $1$ 号表示，其余员工用 $2\sim n$ 号表示。每个员工都可以提高或降低他所有下属（包括直接下属和等级树上的下属）的工资。Mirko 的职责是防止这种权力的滥用，所以他不时地想知道某个雇员的工资。他要求你写一个程序，给定一系列命令（见输入格式部分），帮助他监控工资的变化。注意：在任何时候，所有的工资都是正整数，并适合于标准的 $32$ 位整数类型（C/C++ 中的 `int`，Pascal 中的 `longint`）。

## 说明/提示

**【数据范围】**

对于所有数据，$1\leqslant n,m\leqslant 5\times 10^5$，$1\leqslant a\leqslant n$，$-10^4\leqslant x\leqslant 10^4$。

**【题目来源】**

本题来源自 **_[COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST 3](https://hsin.hr/coci/archive/2011_2012/contest3_tasks.pdf) T5 PLAĆE_**，按照原题数据配置，满分 $140$ 分。

由 [Eason_AC](/user/112917) 翻译整理提供， [123asdf123](/user/576074) 微调。

## 样例 #1

### 输入

```
2 3
5
3 1
p 1 5
u 2
u 1```

### 输出

```
8
5```

## 样例 #2

### 输入

```
5 5
4
2 1
6 1
7 1
3 4
u 3
p 1 -1
u 3
p 4 5
u 5```

### 输出

```
6
5
7```

## 样例 #3

### 输入

```
6 7
5
4 1
3 2
7 3
2 3
3 5
p 3 2
p 2 4
u 3
u 6
p 5 -2
u 6
u 1```

### 输出

```
7
9
7
5```

# 题解

## 作者：ChengJY_ (赞：7)

## 题目大意

给定一棵初始权值已知的树，每次操作:
1. 对某个节点子树上的所有节点加上 $ x $ 。
1. 查询某个节点的权值。


------------
## 具体思路
- **1.暴力(112 pts)**
	
   对于每次修改操作，我们把修改值储存下来，然后每次询问操作我们历遍所求点的祖先，计算总和。
   
   这看起来是 $\mathcal{O}( m\log n )$ 的正解，但是这仅限于这棵树是平衡的时候。在退化成链的极限条件下会被卡到 $\mathcal{O}( mn )$ ，在 $ 1 \le  n , m , \le 5 \times 10^5 $ 的数据范围下会T掉。
   
   核心代码：
	```c
  int a=read();
  int x=tree[a].fa,w=tree[a].num;
  while(1){
      if(x==0) break;
      w+=tag[x];
      x=tree[x].fa;
  }
  printf("%d\n",w);
	```
- **2.正解(树状数组)(140 pts)**

	我们观察两个操作：
    
   1. 修改树上的一段区间。
   1. 求树上单点的值。
   
   这不就是树状数组吗！
  	
   我们可以将树转化为一个差分数组，然后就是树状数组的模板了。
   
   这题并不是完全意义上的树上差分，但是我们可以用类似于树剖的方法做。
   
   这是样例二的树：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/l4s3uq2q.png)
   
   我们将其转化为一个差分数组。
   ![](https://cdn.luogu.com.cn/upload/image_hosting/f2arihlg.png)
   
   
   对于每次修改的 $ x $  ，我们将 $ head_{x+1} $ 加上要加的值，在 $ tail_{x} $ 上减去要加的值。 
   
   查询操作即为求区间和。
   
   这样实现出来就是严格 $\mathcal{O}( m\log n )$ 的了。
   
   具体实现看代码。
   



   
##   Code


  ```c
  #include<bits/stdc++.h>
  #define int long long
  #define maxn 1000005
  #define maxm 1000005
  using namespace std;

    inline int read(){
        int x=0,w=1;
        char ch=getchar();
        while(ch>'9'||ch<'0'){if(ch=='-')w=-1;ch=getchar();}
        while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
        return x*w;
    }

    int cnt,n,m,k,tot=1;
    int head[maxn],h[maxn],t[maxn],num[maxn],c[maxn];
    struct e{int to,next;}edge[maxm];
    int tree[maxn];

    inline void addedge(int u,int v){
        edge[++cnt].to=v;
        edge[cnt].next=head[u];
        head[u]=cnt;
    }

    void dfs(int x){
        h[x]=++tot;
        for(int i=head[x];i;i=edge[i].next)
            dfs(edge[i].to);
        t[x]=++tot;
    }

    inline int lowbit(int x){
        return x&-x;
    }

    void add(int x,int k){
        while(x<=tot){
            c[x]+=k;
            x+=lowbit(x);
        }
    }

    int query(int x){
        int sum=0;
        while(x){
            sum+=c[x];
            x-=lowbit(x);
        }
        return sum;
    }

    signed main(){
        n=read();m=read();
        tree[1]=read();
        for(int i=2;i<=n;++i){
            tree[i]=read();
            int x=read();
            addedge(x,i);
        }
        dfs(1);
        for(int i=1;i<=m;++i){
            char opt;
            cin>>opt;
            if(opt=='p'){
                int a=read(),x=read();
                add(h[a]+1,x);
                add(t[a],-x);
            }
            else{
                int a=read();
                printf("%d\n",tree[a]+query(h[a]));
            }
        }
        return 0;
    }
   ```
码风比较丑，还请见谅。
 
------------






   


   

---

## 作者：Nazale_ (赞：3)

## 思路：

一道真的真的很明显的**树剖模版**，本人采用的是**线段树**维护信息，利用一些**卡常**目前是线段树最快代码。这里的 $p$ 操作也很明显对应**子树操作**，唯一需要注意的是这里的操作**不包括结点本身**（代码中即是 $dfn[u] +1$），**查询为单点操作**。

## 优化：
1. 考虑**优化内存**：可采用**链式前向星存图**，且开一倍就够（即不需要反向存边）；再考虑重链剖分的过程，正常我们会开一堆数组，但此题真的需要吗？**没有链上操作**，所以自然可以把 $dep$，$top$ 等数组删去，更稳妥的满足 64MB 的要求（这里有一个坑点，对于爱 
```cpp
#define int long long
```
的选手一定要注意，此题空间并不适用。。）**这些方面都提醒我们平时遇到这种水题也不要太过于松懈，最好巩固再打一遍，考虑细节与优化。**

2. **线段树**：**懒标记** 属于是区间操作的常识了吧。另外对于此题其实我们并不需要 pushup 函数，这点其实无所谓，但目的同上。
3. 考虑**超级快读**。(


这里再给大家提供一份别的大佬收集的
[树剖练习](https://www.luogu.com.cn/training/1654) 合集。

详细代码细节如下：
```cpp
#include <bits/stdc++.h> 
#define ls (u<<1)
#define rs ((u<<1)|1)
using namespace std;
const int maxn=5e5+5;
/* --------------- fast io --------------- */ // begin
namespace Fread {
  const int SIZE = 1 << 21;
  char buf[SIZE], *S, *T;
  inline char getchar() {
    if (S == T) {
      T = (S = buf) + fread(buf, 1, SIZE, stdin);
      if (S == T) return EOF;
    }
    return *S++;
  }
} // namespace Fread
namespace Fwrite {
  const int SIZE = 1 << 21;
  char buf[SIZE], *S = buf, *T = buf + SIZE;
  inline void flush() {
    fwrite(buf, 1, S - buf, stdout);
    S = buf;
  }
  inline void putchar(char c) {
    *S++ = c;
    if (S == T) flush();
  }
  struct NTR {
    ~ NTR() { flush(); }
  }ztr;
} // namespace Fwrite
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio {
  struct Reader {
    template<typename T>
    Reader& operator >> (T& x) {
      char c = getchar();
      T f = 1;
      while (c < '0' || c > '9') {
	if (c == '-') f = -1;
	c = getchar();
      }
      x = 0;
      while (c >= '0' && c <= '9') {
	x = x * 10 + (c - '0');
	c = getchar();
      }
      x *= f;
      return *this;
    }
    Reader& operator >> (char& c) {
      c = getchar();
      while (c == '\n' || c == ' ') c = getchar();
      return *this;
    }
    Reader& operator >> (char* str) {
      int len = 0;
      char c = getchar();
      while (c == '\n' || c == ' ') c = getchar();
      while (c != '\n' && c != ' ') {
	str[len++] = c;
	c = getchar();
      }
      str[len] = '\0';
      return *this;
    }
    Reader(){}
  }cin;
  const char endl = '\n';
  struct Writer {
    template<typename T>
    Writer& operator << (T x) {
      if (x == 0) { putchar('0'); return *this; }
      if (x < 0) { putchar('-'); x = -x; }
      static int sta[45];
      int top = 0;
      while (x) { sta[++top] = x % 10; x /= 10; }
      while (top) { putchar(sta[top] + '0'); --top; }
      return *this;
    }
    Writer& operator << (char c) {
      putchar(c);
      return *this;
    }
    Writer& operator << (char* str) {
      int cur = 0;
      while (str[cur]) putchar(str[cur++]);
      return *this;
    }
    Writer& operator << (const char* str) {
      int cur = 0;
      while (str[cur]) putchar(str[cur++]);
      return *this;
    }
    Writer(){}
  }cout;
} // namespace Fastio
#define cin Fastio :: cin
#define cout Fastio :: cout
#define endl Fastio :: endl
/* --------------- fast io --------------- */ // end

int n,m;
int t[maxn];
int head[maxn],cnt;
int siz[maxn],fa[maxn],wc[maxn];
int vistime,dfn[maxn],rdfn[maxn];
struct edge{
	int u,v,nxt;
}e[maxn];
void add(int u,int v){
	e[++cnt].nxt=head[u];
	e[cnt].v=v;
	head[u]=cnt;
}
void dfs1(int u,int f){
	siz[u]=1;
	fa[u]=f;
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==f) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[wc[u]]<siz[v]) wc[u]=v;
	}
}
void dfs2(int u,int T){
	dfn[u]=++vistime;
	rdfn[vistime]=u;
	if(!wc[u]) return;
	dfs2(wc[u],T);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa[u] || v==wc[u]) continue;
		dfs2(v,v);
	}
}
struct tree{
	int l,r;
	int w;
	int tag;
}a[maxn<<2];
void build(int u,int l,int r){
	a[u].l=l,a[u].r=r;
	if(l==r){
		a[u].w=t[rdfn[l]];
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void maketag(int u,int x){
	a[u].tag+=x;
	a[u].w+=(a[u].r-a[u].l+1)*x;
}
void pushdown(int u){
	maketag(ls,a[u].tag);
	maketag(rs,a[u].tag);
	a[u].tag=0;
}
void update(int u,int l,int r,int x){
	if(a[u].l>=l && a[u].r<=r){
		maketag(u,x);
		return;
	}
	int mid=a[u].l+a[u].r>>1;
	pushdown(u);
	if(mid>=l) update(ls,l,r,x);
	if(mid<r) update(rs,l,r,x); 
}
int query(int u,int p){
	if(a[u].l==a[u].r){
		return a[u].w;
	}
	int mid=a[u].l+a[u].r>>1;
	pushdown(u);
	if(mid>=p) return query(ls,p);
	else return query(rs,p);
}
signed main(){
	cin>>n>>m;
	cin>>t[1];
	for (int u,i=2;i<=n;i++){
		cin>>t[i]>>u;
		add(u,i);
	}
	dfs1(1,0);
	dfs2(1,0);
	build(1,1,n);
	while(m--){
		char op;
		int p,x;
		cin>>op;
		if(op=='p'){
			cin>>p>>x;
			update(1,dfn[p]+1,dfn[p]+siz[p]-1,x);
		}
		else{
			cin>>p;
			cout<<query(1,dfn[p])<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：QCurium (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P7746)

[视频讲解（顺便点个赞吧](https://www.bilibili.com/video/BV13K4y1w7UM/?spm_id_from=333.999.0.0&vd_source=a8f2ca9bd086cb49d933fb93cb7409c0)

## 题意

建立一个树，两种操作：

- 将子树的所有节点的值全部变化 $x$。

- 查询一个点的值。

## 题目分析

一看这两种操作，这不就是重链剖分吗，而且这个重链剖分甚至都没有对链的操作了，所以就不用维护 $top$ 数组了。

我们需要排出 dfn 序，然后进行建树，因为操作一是修改子树，所以 dfn 序是连续的。操作二直接按照 dfn 序在线段树中查找就可以了。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,m,tot=0,cnt=0;
int gz[N],head[N],dep[N],fa[N],siz[N],son[N],w[N],dfn[N];
struct node{
	int l,r;
	int sum,tag;
}a[N<<2];
struct edge{
	int to,nxt;
}e[N<<1];
///////////////////////////////////////
void ade(int u,int v){
	e[tot]=(edge){v,head[u]};
	head[u]=tot++;
	e[tot]=(edge){u,head[v]};
	head[v]=tot++;
	return ;
}
void dfs1(int nw,int f){
	fa[nw]=f;
	dep[nw]=dep[f]+1;
	siz[nw]=1;
	int asd=-1;
	for(int i=head[nw];~i;i=e[i].nxt){
		int er=e[i].to;
		if(er==f)
			continue;
		dfs1(er,nw);
		siz[nw]+=siz[er];
		if(siz[er]>asd){
			asd=siz[er];
			son[nw]=er;
		}
	}
	return ;
}
void dfs2(int nw){
	dfn[nw]=++cnt;
	w[cnt]=gz[nw];
	if(!son[nw])
		return ;
	dfs2(son[nw]);
	for(int i=head[nw];~i;i=e[i].nxt){
		int er=e[i].to;
		if(er==fa[nw]||er==son[nw])
			continue;
		dfs2(er);
	}
	return ;
}
///////////////////////////////////////
void push_up(int aa){
	a[aa].sum=a[aa*2].sum+a[aa*2+1].sum;
	return ;
}
void push_down(int aa){
	if(a[aa].tag!=0){
		a[aa*2].sum+=(a[aa*2].r-a[aa*2].l+1)*a[aa].tag;
		a[aa*2+1].sum+=(a[aa*2+1].r-a[aa*2+1].l+1)*a[aa].tag;
		a[aa*2].tag+=a[aa].tag;
		a[aa*2+1].tag+=a[aa].tag;
		a[aa].tag=0;
	}
	return ;
}
void build(int aa,int l,int r){
	a[aa].l=l;
	a[aa].r=r;
	a[aa].tag=0;
	if(l==r){
		a[aa].sum=w[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(aa*2,l,mid);
	build(aa*2+1,mid+1,r);
	push_up(aa);
	return ;
}
void modify(int aa,int l,int r,int z){
	if(a[aa].l>=l&&a[aa].r<=r){
		a[aa].sum=a[aa].sum+(a[aa].r-a[aa].l+1)*z;
		a[aa].tag+=z;
		return ;
	}
	push_down(aa);
	int mid=(a[aa].l+a[aa].r)>>1;
	if(l<=mid)
		modify(aa*2,l,r,z);
	if(r>mid)
		modify(aa*2+1,l,r,z);
	push_up(aa);
	return ; 
}
int query(int aa,int lr){
	if(a[aa].l==a[aa].r)
		return a[aa].sum;
	push_down(aa);
	int asd=0,mid=(a[aa].l+a[aa].r)>>1;
	if(lr<=mid)
		return query(aa*2,lr);
	else
		return query(aa*2+1,lr);
}
///////////////////////////////////////
void mson(int x,int z){
	if(siz[x]==1)
		return ;
	modify(1,dfn[x]+1,dfn[x]+siz[x]-1,z);
	return ;
}
///////////////////////////////////////
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    memset(head,-1,sizeof(head));
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int u;
		if(i==1)
			cin>>gz[i];
		else{
			cin>>gz[i]>>u;
			ade(i,u);
		}
	}
	dfs1(1,1);
	dfs2(1);
	build(1,1,n);
	while(m--){
		char op;
		int a,x;
		cin>>op;
		if(op=='p'){
			cin>>a>>x;
			mson(a,x);
		}
		else{
			cin>>a;
			cout<<query(1,dfn[a])<<'\n';
		}
	}
	return 0;
}

```

[AC 记录](https://www.luogu.com.cn/record/125124089)

---

## 作者：Erica_N_Contina (赞：2)

# [COCI2011-2012#3] PLAĆE


## 思路

dfs 序+线段树维护区间修改，单点查询。



我们可以知道，我们把每个点按 dfs 序排序，那么每个子树都是序列上的一个区间。

那么很显然，我们就维护这个 dfs 序的序列，然后进行区间修改，单点查询即可。

详细的首先方法是，我们先 dfs 一遍，求出每个点 $u$ 的 dfs 序（我们记录在 $ll$ 中），然后 dfs 下去——当返回到 $u$ 时，我们再记录当前的 dfs 序，这就是 $u$ 的子树中最后一个点的 dfs 序。我们记录在 $rr$ 中。

那么现在我们知道了，点 $u$ 的子树在 dfs 序中就是 $ll_u\sim rr_u$ 这段区间里。

本题既然是要求修改其后代，就算是子树去掉根节点，那么我们每次就修改区间 $ll_u+1\sim rr_u$ 即可。

注意，我们还要特判 $ll_u+1> rr_u$，这表明 $u$ 没有下属。

可以证明，复杂度合适，算法正确。



当然题解也有树状数组的做法，也很不错，码量比线段树优秀。

## 代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
//#define int long long
#define db double
#define rtn return
using namespace std;

const int N=5e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

vector<int> e[N];
int ll[N],rr[N],dfn,tr[N<<2],tag[N<<2],w[N],n,m;

void add(int a,int b){
	e[a].push_back(b);
}

void dfs(int x,int fa){
	ll[x]=++dfn;
	for(auto v:e[x]){
		if(v==fa)continue;
		dfs(v,x);
	}
	rr[x]=dfn;
}

void addtag(int x,int l,int r,int tg){
	if(l==r)tr[x]+=tg;
	tag[x]+=tg;
	
}

void pushdown(int x,int l,int r){
	int mid=l+r>>1;
	addtag(x<<1,l,mid,tag[x]);
	addtag(x<<1|1,mid+1,r,tag[x]);
	tag[x]=0;
}


void build(int x,int l,int r){
	if(l==r){
		tr[x]=w[ll[l]];
		return ;
	}
	int mid=l+r>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
//	pushup(x);
}

void change(int x,int l,int r,int pl,int pr,int v){
	if(l>r)return ;
	if(l>=pl&&r<=pr){
		addtag(x,l,r,v);
		return ;
	}
	pushdown(x,l,r);
	int mid=l+r>>1;
	if(pl<=mid)change(x<<1,l,mid,pl,pr,v);
	if(pr>mid)change(x<<1|1,mid+1,r,pl,pr,v);
//	pushup(x);
	return ;
}

int query(int x,int l,int r,int v){
	if(l==r)return tr[x];
	
	pushdown(x,l,r);
	int mid=l+r>>1;
	if(v<=mid)return query(x<<1,l,mid,v);
	return query(x<<1|1,mid+1,r,v);
}

signed main(){
	cin>>n>>m;
	cin>>w[1];
	for(int i=2;i<=n;i++){
		int fa;
		cin>>w[i]>>fa;
		add(fa,i);
	}
	dfs(1,0);
	
//	for(int i=1;i<=n;i++){
//		cerr<<i<<" l,r= "<<ll[i]<<' '<<rr[i]<<endl;
//	} 
	
	build(1,1,n);
	
//	cerr<<"\nallPoint: ";
//	for(int i=1;i<=n;i++){
//		cerr<<query(1,1,n,ll[i])<<' ';
//	}cerr<<endl;
	
	
	while(m--){
		char op;
		int x,a;
		cin>>op>>a;
		if(op=='p'){
			cin>>x;
//			cerr<<"change="<<ll[a]+1<<' '<<rr[a]<<endl;
			change(1,1,n,ll[a]+1,rr[a],x);
			
//			cerr<<"\nallPoint: ";
//	for(int i=1;i<=n;i++){
//		cerr<<query(1,1,n,ll[i])<<' ';
//	}cerr<<endl;
		}else{
			cout<<query(1,1,n,ll[a])<<endl;
		}
	}
	return 0;
}

```


（不知道为什么挂了）（小声）



---

## 作者：Oracynx (赞：1)

## P7746 [COCI2011-2012#3] PLAĆE 题解

### 题目大意

给出一颗树，要求支持子树操作（**不包含根节点**）、单点查询。

### 思路分析

树链剖分模板弱化版，没有学过可以先去过[模板题](https://www.luogu.com.cn/problem/P3384)。

对于这道题，我们可以利用树链剖分的思想，将其剖为不超过 $\log_{2}{n}$ 条链，转换为区间问题（这里用到了树链剖分的一个性质：对于一个子树，它的 dfs 序是连续的），即可轻松维护。

Tips：这道题卡空间（只有 64MB），只需要开线段树和懒标记的 `long long` 即可，否则会 MLE。

踩线过的：![](https://cdn.luogu.com.cn/upload/image_hosting/lbmxalja.png)

### 代码实现

下面代码由树链剖分模板修改而来，所以修改和查询可能会不是很自然。

重点：子树修改时不需要修改当前根节点，所以还要用路径修改减回来。

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
const int MaxN = 5e5 + 5;
int n, m;
int id_cnt;
int id[MaxN];
int fa[MaxN];
int son[MaxN];
int top[MaxN];
int size[MaxN];
int depth[MaxN];
int value[MaxN];
std::vector<int> link[MaxN];
long long tree[4 * MaxN];
long long lazy[4 * MaxN];
void build(int root, int s, int t)
{
    if (s == t)
    {
        tree[root] = 0;
        return;
    }
    int mid = (s + t) / 2;
    build(root * 2, s, mid);
    build(root * 2 + 1, mid + 1, t);
    tree[root] = (tree[root * 2] + tree[root * 2 + 1]);
}
void pushDown(int root, int s, int t)
{
    int mid = (s + t) / 2;
    if (lazy[root] != 0)
    {
        tree[root * 2] += lazy[root] * (mid - s + 1);
        tree[root * 2 + 1] += lazy[root] * (t - mid);
        lazy[root * 2] += lazy[root];
        lazy[root * 2 + 1] += lazy[root];
        lazy[root] = 0;
    }
}
void change(int root, int s, int t, int l, int r, int c)
{
    if (l <= s && t <= r)
    {
        tree[root] += c * (t - s + 1);
        lazy[root] += c;
        return;
    }
    pushDown(root, s, t);
    int mid = (s + t) / 2;
    if (l <= mid)
    {
        change(root * 2, s, mid, l, r, c);
    }
    if (r >= mid + 1)
    {
        change(root * 2 + 1, mid + 1, t, l, r, c);
    }
    tree[root] = tree[root * 2] + tree[root * 2 + 1];
}
long long query(int root, int s, int t, int l, int r)
{
    if (l <= s && t <= r)
    {
        return tree[root];
    }
    pushDown(root, s, t);
    int mid = (s + t) / 2;
    int res = 0;
    if (l <= mid)
    {
        res += query(root * 2, s, mid, l, r);
    }
    if (r >= mid + 1)
    {
        res += query(root * 2 + 1, mid + 1, t, l, r);
    }
    return res;
}
void dfsInformation(int root, int fat, int deep)
{
    fa[root] = fat;
    size[root] = 1;
    depth[root] = deep;
    for (int next : link[root])
    {
        if (next == fat)
        {
            continue;
        }
        dfsInformation(next, root, deep + 1);
        size[root] += size[next];
        if (size[next] > size[son[root]])
        {
            son[root] = next;
        }
    }
    return;
}
void dfsSplit(int root, int fat, int top_root)
{
    id_cnt++;
    id[root] = id_cnt;
    top[root] = top_root;
    if (son[root] == 0)
    {
        return;
    }
    dfsSplit(son[root], root, top_root);
    for (int next : link[root])
    {
        if (next == fat || next == son[root])
        {
            continue;
        }
        dfsSplit(next, root, next);
    }
}
long long queryRouteSum(int x, int y)
{
    long long res = 0;
    for (;;)
    {
        if (depth[top[x]] < depth[top[y]])
        {
            std::swap(x, y);
        }
        if (top[x] == top[y])
        {
            break;
        }
        res += query(1, 1, n, id[top[x]], id[x]);
        x = fa[top[x]];
    }
    if (depth[x] > depth[y])
    {
        std::swap(x, y);
    }
    res += query(1, 1, n, id[x], id[y]);
    return res;
}
void changeRouteValue(int x, int y, int c)
{
    for (;;)
    {
        if (depth[top[x]] < depth[top[y]])
        {
            std::swap(x, y);
        }
        if (top[x] == top[y])
        {
            break;
        }
        change(1, 1, n, id[top[x]], id[x], c);
        x = fa[top[x]];
    }
    if (depth[x] > depth[y])
    {
        std::swap(x, y);
    }
    change(1, 1, n, id[x], id[y], c);
}
void changeSonTreeSum(int x, int c)
{
    change(1, 1, n, id[x], id[x] + size[x] - 1, c);
}
int main()
{
    scanf("%d%d", &n, &m);
    scanf("%d", &value[1]);
    for (int i = 2; i <= n; i++)
    {
        int val, fa;
        scanf("%d%d", &val, &fa);
        value[i] = val;
        link[i].push_back(fa);
        link[fa].push_back(i);
    }
    dfsInformation(1, 0, 1);
    dfsSplit(1, 0, 1);
    build(1, 1, n);
    for (int i = 1; i <= n; i++)
    {
        change(1, 1, n, id[i], id[i], value[i]);
    }
    for (int i = 1; i <= m; i++)
    {
        char op = '\0';
        for (; op != 'p' && op != 'u';)
        {
            scanf("%c", &op);
        }
        if (op == 'p')
        {
            int x, y;
            scanf("%d%d", &x, &y);
            changeSonTreeSum(x, y);
            changeRouteValue(x, x, -y);
        }
        else if (op == 'u')
        {
            int x;
            scanf("%d", &x);
            printf("%lld\n", queryRouteSum(x, x));
        }
    }
    return 0;
}
```

---

## 作者：囧仙 (赞：1)

## 题目大意

给定一棵 $n$ 个节点的有根树，每个节点带权。有 $m$ 个操作，共两种：

- 给以 $x$ 为根的子树所有的子节点（不包括 $x$ 本身）的权值加上 $a$。  
- 询问节点 $a$ 的权值。

## 题解

容易发现这就像是一个树剖板子题。但是因为不需要支持链的操作，所以甚至不需要树剖。直接对原树跑一次 $\text{dfs}$，求出每个节点的 $\text{dfs}$ 序，那么一棵以 $x$ 为根的子树的所有节点的 $\text{dfs}$ 序肯定是一个连续的区间。记为 $[S_x,T_x]$。并且可以发现，$x$ 的 $\text{dfs}$ 序就是 $S_x$。

所以问题等价于，区间加、单点查询。对于操作 $1$，等价于让区间 $[S_x+1,T_x]$ 加上 $a$；对于操作 $2$，等价于查询 $S_x$ 位置的值。

当然可以用线段树实现。但因为我是懒狗，所以写了个树状数组。时间复杂度为 $\mathcal O((n+m)\log n)$。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=3e5+3;
int H[MAXN],V[MAXN*2],N[MAXN*2],S[MAXN],T[MAXN],s,t;
void ade(int u,int v){
    V[++t]=v,N[t]=H[u],H[u]=t;
}
void dfs(int u,int f){
    S[u]=++s;
    for(int i=H[u],v;i;i=N[i]) if((v=V[i])!=f) dfs(v,u);
    T[u]=s;
}
int A[MAXN],D[MAXN],n,m;
void add(int u,int x){
    while(u<=n) D[u]+=x,u+=u&-u;
}
int  qry(int u){
    int r=0; while(u) r+=D[u],u-=u&-u; return r;
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
char rdc(){
    char c; while(!isgraph(c=getchar())); return c;
}
int main(){
    n=qread(),m=qread(); A[1]=qread();
    up(2,n,i){
        A[i]=qread(); int f=qread(); ade(f,i);
    }
    dfs(1,0);
    up(1,n,i) add(S[i],A[i]),add(S[i]+1,-A[i]);
    up(1,m,i){
        char op=rdc(); if(op=='p'){
            int a=qread(),u=qread(); add(S[a]+1,u),add(T[a]+1,-u);
        } else{
            int a=qread(); printf("%d\n",qry(S[a]));
        }
    }
    return 0;
}
```

---

## 作者：2c_s (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7746)

## 思路

很明显的一道树剖题。

### 建树部分

读入数据后先跑一遍树剖，之后建树即可。

- 数据量比较大，建议别用 cin。

- 记得 Mirko **没有上司**，读入时要特判。

树剖及建树代码：

```cpp
void dfs(int x,int f){//先确定重儿子。
	fa[x]=f;
	dep[x]=dep[f]+1;
	siz[x]=1;
	for(auto i:g[x]){
		if(i==f)continue;
		dfs(i,x);
		siz[x]+=siz[i];
		if(siz[son[x]]<siz[i])son[x]=i;
	}
	return ;
}
void dfs2(int x,int tp){//再把这棵树剖成一条一条的链。
	top[x]=tp;
	dfn[x]=++cnt;
	rnk[cnt]=x;
	if(son[x])dfs2(son[x],tp);
	for(auto i:g[x]){
		if(i==fa[x]||i==son[x])continue;
		dfs2(i,i);
	}
	return ;
}
void build(int i,int l,int r){//最后建线段树。
	tree[i].l=l;
	tree[i].r=r;
	if(l==r){
		tree[i].sum=a[rnk[l]];
		return ;
	}
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	tree[i].sum=tree[i<<1].sum+tree[i<<1|1].sum;
	return ;
}
```

### 加工资

读入修改的数据后首先要判断这个人是否为最底层员工（叶子节点），如果是就**不要**进行修改了，因为访问他的下属的 `dfn` 序时，会访问到另一条链上。

特判完成后我们所做的就是将这个人**下属**的工资修改，即为修改这个人第一个下属的 `dfn` 序到这个人总领员工数量 $-1$ 的员工的 `dfn` 序。

加工资代码：

```cpp
void pushdown(int i){//别忘下传 lazytag。
	if(tree[i].tag!=0){
		tree[i<<1].tag+=tree[i].tag;
		tree[i<<1|1].tag+=tree[i].tag;
		tree[i<<1].sum+=tree[i].tag*(tree[i<<1].r-tree[i<<1].l+1);
		tree[i<<1|1].sum+=tree[i].tag*(tree[i<<1|1].r-tree[i<<1|1].l+1);
		tree[i].tag=0;
	}
	return ;
}
inline void add(int i,int l,int r,int k){//线段树区间加模板代码。
	if(l<=tree[i].l&&tree[i].r<=r){
		tree[i].sum+=(tree[i].r-tree[i].l+1)*k;
		tree[i].tag+=k;
		return ;
	}
	pushdown(i);
	int mid=tree[i].l+tree[i].r>>1;
	if(l<=mid)add(i<<1,l,r,k);
	if(mid+1<=r)add(i<<1|1,l,r,k);
	tree[i].sum=tree[i<<1].sum+tree[i<<1|1].sum;
	return ;
}
```

主函数部分：

```cpp
if(siz[x]==1)continue;//特判是否他就是最底层员工。
add(1,dfn[x]+1,dfn[x]+siz[x]-1,k);
```

### 查询工资

查询工资可以看作查询左端点等于右端点的这个区间的员工的工资之和，于是我们把它转化成线段树的区间求和。

- 查询时也别忘**下传 lazytag**。

查询工资部分代码：

```cpp
inline int query(int i,int l,int r){//线段树单点求值（套区间和模板）。
	if(l<=tree[i].l&&tree[i].r<=r)return tree[i].sum;
	pushdown(i);//这里的 pushdown() 和上文相同。
	int mid=tree[i].l+tree[i].r>>1;
	if(l<=mid)return query(i<<1,l,r);
	if(mid+1<=r)return query(i<<1|1,l,r);
}
```

主函数部分即为查询 `query(1,dfn[x],dfn[x])`，之后输出。

- 这题对空间要求很高，所以变量**能少开就少开**，题目里给了**不用开 long long**。

## 完整 AC 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
using namespace std;
inline ll read(){//快读。
	ll k=0,flag=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')flag=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar();
	}
	return k*flag;
}
inline void print(ll x){//快写。
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<1)+(y<<3);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
    return ;
}
inline char readc(){//字符快读。
	char c=getchar();
	while(c==' '||c=='\n'||c=='\r')c=getchar();
	return c;
}
const int N=5e5+10;
int n,q,cnt,fa[N],dep[N],top[N],son[N],siz[N],dfn[N],rnk[N],a[N];
struct node{
	int l,r,sum,tag;
}tree[N<<2];//记得开 4 倍。
vector<int>g[N];
void dfs(int x,int f){
	fa[x]=f;
	dep[x]=dep[f]+1;
	siz[x]=1;
	for(auto i:g[x]){
		if(i==f)continue;
		dfs(i,x);
		siz[x]+=siz[i];
		if(siz[son[x]]<siz[i])son[x]=i;
	}
	return ;
}
void dfs2(int x,int tp){
	top[x]=tp;
	dfn[x]=++cnt;
	rnk[cnt]=x;
	if(son[x])dfs2(son[x],tp);
	for(auto i:g[x]){
		if(i==fa[x]||i==son[x])continue;
		dfs2(i,i);
	}
	return ;
}
void build(int i,int l,int r){//建线段树。
	tree[i].l=l;
	tree[i].r=r;
	if(l==r){
		tree[i].sum=a[rnk[l]];
		return ;
	}
	int mid=l+r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
	tree[i].sum=tree[i<<1].sum+tree[i<<1|1].sum;
	return ;
}
void pushdown(int i){//下传 lazytag。
	if(tree[i].tag!=0){
		tree[i<<1].tag+=tree[i].tag;
		tree[i<<1|1].tag+=tree[i].tag;
		tree[i<<1].sum+=tree[i].tag*(tree[i<<1].r-tree[i<<1].l+1);
		tree[i<<1|1].sum+=tree[i].tag*(tree[i<<1|1].r-tree[i<<1|1].l+1);
		tree[i].tag=0;
	}
	return ;
}
inline void add(int i,int l,int r,int k){//线段树区间加
	if(l<=tree[i].l&&tree[i].r<=r){
		tree[i].sum+=(tree[i].r-tree[i].l+1)*k;
		tree[i].tag+=k;
		return ;
	}
	pushdown(i);
	int mid=tree[i].l+tree[i].r>>1;
	if(l<=mid)add(i<<1,l,r,k);
	if(mid+1<=r)add(i<<1|1,l,r,k);
	tree[i].sum=tree[i<<1].sum+tree[i<<1|1].sum;
	return ;
}
inline int query(int i,int l,int r){//线段树单点求值（套区间和模板）。
	if(l<=tree[i].l&&tree[i].r<=r)return tree[i].sum;
	pushdown(i);
	int mid=tree[i].l+tree[i].r>>1;
	if(l<=mid)return query(i<<1,l,r);
	if(mid+1<=r)return query(i<<1|1,l,r);
}
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		a[i]=read();
		if(i==1)continue;//特判这个员工是否为 Mirko。
		int x=read();
		g[i].pb(x);
		g[x].pb(i);
	}
	dfs(1,0);
	dfs2(1,1);
	build(1,1,n);
	while(q--){
		char op=readc();
		int x=read();
		if(op=='p'){
			int k=read();
			if(siz[x]==1)continue;//特判是否他就是最底层员工。
			add(1,dfn[x]+1,dfn[x]+siz[x]-1,k);
		}
		else{
			print(query(1,dfn[x],dfn[x]));
			putchar('\n');
		}
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/139442948)

---

## 作者：VIOLET__FOREVER (赞：0)

[传送门](https://www.luogu.com.cn/problem/P7746)

## 题目分析
题目中可以看出，是一个树上问题，要求满足两种操作：
1. 给一个点子树中的所有点（除了自身）加上一个 $x$ 值
1. 查询一个节点的值

这样我们很容易想到树剖，并且用线段树维护每个节点的值，需要支持区间加和单点查，这比较板子，但是本题的空间限制是 64MB 所以还是避免开不必要的数组。

注意：如果操作 $1$ 面对的根是叶子节点的话，不用进行操作，不然会喜提 $112$。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
#define ls root<<1
#define rs root<<1|1
#define as (start+end)>>1

const int N=500005;

using namespace std;

inline int read(){
	int t=1,x=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') t=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return t*x;
}

struct node{
	int to,next;
}edge[N<<1];
int head[N],tot;
int n,m;
int top[N],son[N],fa[N],siz[N];
int id[N],back[N],cnt,a[N];
int tr[N<<2],tag[N<<2];

void add(int x,int y){
	tot++;
	edge[tot].to=y;
	edge[tot].next=head[x];
	head[x]=tot;
}

void dfs1(int x,int father){
	siz[x]=1;
	for(int i=head[x];i;i=edge[i].next){
		int xx=edge[i].to;
		if(xx==father) continue;
		fa[xx]=x;
		dfs1(xx,x);
		siz[x]+=siz[xx];
		if(!son[x] || siz[xx]>siz[son[x]]) son[x]=xx;
	}
}

void dfs2(int x,int tv){
	top[x]=tv;
	id[x]=++cnt;
	back[cnt]=a[x];
	if(!son[x]) return ;
	dfs2(son[x],tv);
	for(int i=head[x];i;i=edge[i].next){
		int xx=edge[i].to;
		if(xx==fa[x] || xx==son[x]) continue;
		dfs2(xx,xx);
	}
}

void pushup(int root){
	tr[root]=tr[ls]+tr[rs];
}

void build(int root,int start,int end){
	if(start==end){
		tr[root]=back[start];
		return ;
	}
	int mid=as;
	build(ls,start,mid);
	build(rs,mid+1,end);
	pushup(root);
}

void pushdown(int root,int start,int end){
	int mid=as;
	tag[ls]+=tag[root];
	tag[rs]+=tag[root];
	tr[ls]+=tag[root]*(mid-start+1);
	tr[rs]+=tag[root]*(end-mid);
	tag[root]=0;
}

void updata(int root,int start,int end,int l,int r,int v){
	if(start>=l && end<=r){
		tr[root]+=(end-start+1)*v;
		tag[root]+=v;
		return ;
	}
	int mid=as;
	pushdown(root,start,end);
	if(mid>=l) updata(ls,start,mid,l,r,v);
	if(mid<r) updata(rs,mid+1,end,l,r,v);
	pushup(root);
}

int qurey(int root,int start,int end,int loc){
	if(start==end) return tr[root];
	int mid=as;
	pushdown(root,start,end);
	if(loc<=mid) return qurey(ls,start,mid,loc);
	else return qurey(rs,mid+1,end,loc);
}

signed main(){
	cin>>n>>m;
	a[1]=read();
	for(int i=2;i<=n;i++){
		a[i]=read();
		int x=read();
		add(i,x);
		add(x,i);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,n);
	while(m--){
		char ch;
		cin>>ch;
		if(ch=='u'){
			int x=read();
			cout<<qurey(1,1,n,id[x])<<endl;
		}
		else{
			int x=read(),val=read();
			if(siz[x]==1) continue;
			updata(1,1,n,id[x]+1,id[x]+siz[x]-1,val);
		}
	}
	return 0;
}
```
~~码分比较丑，勿喷。~~

---

## 作者：whx2009 (赞：0)

## 本题思路：
这道题是一道非常板子的树链剖分，我们从题目中可以知道每一个上司都可以改变他子节点员工的工资（这里注意一下，这名上司可能是一个黑心的资本家，给你涨负数的钱，传递懒标记时注意一下）。

我们在这里就可以按照步骤先把树给剖成一条条链的形态，然后根据 dfs 序进行线段树的维护工作即可。

如果不会树链剖分的，建议先去做[这道题](https://www.luogu.com.cn/problem/P3384)。
## 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500001],m[500001];
vector<int>v[500001];
struct f{
	int fa,dep,son,top,size,id;
}tr[2000001];
struct f1{
	int add,sum,r,l;
}b[2000001];
int cnt;
void dfs1(int p,int fa,int dep)//求出父亲节点，子节点数量，重子节点，深度 
{
	tr[p].fa=fa;
	tr[p].dep=dep;
	tr[p].size=1; 
	tr[p].son=0;
	for(int i=0;i<v[p].size();i++)
	{
		if(v[p][i]==fa) continue;
		dfs1(v[p][i],p,dep+1);
		tr[p].size+=tr[v[p][i]].size;
		if(tr[v[p][i]].size>tr[tr[p].son].size)
		{
			tr[p].son=v[p][i];
		}
	}
}
int vis[500001];
void dfs2(int p,int tp)//求出链头，dfs序 
{
	tr[p].top=tp; 
	tr[p].id=++cnt; 
	m[cnt]=a[p];
	if(!tr[p].son) return;
	dfs2(tr[p].son,tp);  
	for(int i=0;i<v[p].size();i++) 
	{
		if(v[p][i]==tr[p].fa || v[p][i]==tr[p].son) continue;
		dfs2(v[p][i],v[p][i]); 
	}
}
void jianshu(int p,int l,int r)//按照dfs序维护一棵线段树 
{
	b[p].l=l,b[p].r=r;
	if(l==r)
	{
		b[p].sum=m[l];
		return;
	}
	int mid=(l+r)/2;
	jianshu(p*2,l,mid);
	jianshu(p*2+1,mid+1,r);
	b[p].sum=b[p*2].sum+b[p*2+1].sum;
}
void chuandi(int p) 
{
	if(b[p].add!=0)//注意，可能是负数 
	{
		b[p*2].add+=b[p].add;
		b[p*2+1].add+=b[p].add;
		b[p*2].sum+=(b[p*2].r-b[p*2].l+1)*b[p].add; 
		b[p*2+1].sum+=(b[p*2+1].r-b[p*2+1].l+1)*b[p].add;
		b[p].add=0;		
	}
}
void xiugai(int p,int l,int r,int k)
{
	if(l>r) return;
	if(b[p].l>=l && b[p].r<=r)
	{
		b[p].sum+=(b[p].r-b[p].l+1)*k;
		b[p].add+=k;
		return;
	}
	chuandi(p);
	int mid=(b[p].r+b[p].l)/2;
	if(l<=mid) xiugai(p*2,l,r,k);
	if(r>mid) xiugai(p*2+1,l,r,k);
	b[p].sum=(b[p*2].sum+b[p*2+1].sum);
}
int chaxun(int p,int l,int r)
{
	if(b[p].l>=l && b[p].r<=r){return b[p].sum;}
	chuandi(p);
	int mid=(b[p].r+b[p].l)/2,ans=0;
	if(l<=mid) ans=chaxun(p*2,l,r);
	if(r>mid) ans=chaxun(p*2+1,l,r);
	return ans;
}
signed main()
{
	long long n,m;
	cin>>n>>m;
	int x,y;cin>>x;a[1]=x;
	for(int i=2;i<=n;i++)
	{
		cin>>x>>y;
		v[y].push_back(i);
		v[i].push_back(y);
		a[i]=x;
	}
	dfs1(1,0,1);
	dfs2(1,1);
	jianshu(1,1,n); 
	while(m--)
	{
		char op;
		cin>>op;
		if(op=='p')
		{
			int x,k;
			cin>>x>>k;
			xiugai(1,tr[x].id+1,tr[x].id+tr[x].size-1,k);
		}
		if(op=='u')
		{
			int x;
			cin>>x;
			cout<<chaxun(1,tr[x].id,tr[x].id)<<endl;
		}
	}
	return 0;
}
```


---

## 作者：sjr3065335594 (赞：0)

## 题意简述

给定一棵树，每次可以将以一个点为根的子树上每个点的权值加上一个数，也可以询问某一个点上的值，对于每次询问输出答案。

## 思路

看到修改子树很容易想到用树剖解决，我们直接跑两遍 dfs 求一下每个结点的编号和子树大小，用线段树维护，修改就是线段树上的区间修改，查询就是一个单点查询。

## 代码实现

```cpp
#include <bits/stdc++.h>
#define mkp(x,y) make_pair(x,y)
using namespace std;
const int N=5e5+5;
const int M=1e6+5;
struct EDGE {
	int v,next;
}edge[M];
int head[N],cnt,n,m,r,tot,id[N],fa[N],siz[N],son[N],dep[N],a[N],st[N];
void add_edge(int x,int y) {
	edge[++cnt]=(EDGE){y,head[x]};
	head[x]=cnt;
}
struct SegmentTree {
	int l,r;
	int sum,add;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define add(x) tree[x].add
}tree[4*N];
void build(int p,int l,int r) {
	l(p)=l,r(p)=r;
	if(l==r){sum(p)=st[l];return;}
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	sum(p)=(sum(p*2)+sum(p*2+1));
}
void spread(int p) {
	if(add(p)) {
		add(p*2)=(add(p)+add(p*2));
		add(p*2+1)=(add(p)+add(p*2+1));
		sum(p*2)=(sum(p*2)+(r(p*2)-l(p*2)+1)*add(p));
		sum(p*2+1)=(sum(p*2+1)+(r(p*2+1)-l(p*2+1)+1)*add(p));
		add(p)=0; 
	}
}
void change(int p,int l,int r,int d) {
	if(l(p)>=l&&r(p)<=r){sum(p)=(sum(p)+(r(p)-l(p)+1)*d);add(p)=(add(p)+d);return;}
	spread(p);
	int mid=l(p)+r(p)>>1;
	if(l<=mid)change(p*2,l,r,d);
	if(r>mid)change(p*2+1,l,r,d);
	sum(p)=(sum(p*2)+sum(p*2+1));
}
int ask(int p,int l,int r) {
	if(l(p)>=l&&r(p)<=r){return sum(p);}
	spread(p);
	int val=0;
	int mid=l(p)+r(p)>>1;
	if(l<=mid)val=(val+ask(p*2,l,r));
	if(r>mid)val=(val+ask(p*2+1,l,r));
	return val;
}
//以上为线段树
void dfs1(int x,int f,int deep) {
	fa[x]=f;
	dep[x]=deep;
	siz[x]=1;
	int maxson=-1;
	for(int i=head[x];~i;i=edge[i].next) {
		int v=edge[i].v;
		if(v!=f) {
			dfs1(v,x,deep+1);
			if(maxson<siz[v]) {
				maxson=siz[v];
				son[x]=v;
			}
			siz[x]+=siz[v];
		}
	}
}
void dfs2(int x,int tp) {
	id[x]=++tot;
	st[tot]=a[x];
	if(!son[x])return;
	dfs2(son[x],tp);
	for(int i=head[x];~i;i=edge[i].next) {
		int v=edge[i].v;
		if(v!=fa[x]&&v!=son[x])
			dfs2(v,v);
	}
}
void upd(int x,int d) {
	if(id[x]+1<=id[x]+siz[x]-1)change(1,id[x]+1,id[x]+siz[x]-1,d);
}
int q(int x) {
	return ask(1,id[x],id[x]);
}
int main() {
	memset(head,-1,sizeof(head));
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		int x;
		if(i==1)cin>>a[i];
		else {
			cin>>a[i]>>x;
			add_edge(i,x);
			add_edge(x,i);
		}
	}
	dfs1(1,1,1);
	dfs2(1,1);
	build(1,1,n);
	while(m--) {
		char op;
		int a,x;
		cin>>op;
		if(op=='p') {
			cin>>a>>x;
			upd(a,x);
		}
		if(op=='u') {
			cin>>x;
			cout<<q(x)<<endl;
		} 
		
	}
	return 0;
}

```

~~这题用树剖的好处就是不用动什么脑子~~


---

## 作者：KawaragiMomoka (赞：0)

# 题目大意

给定一棵树，要求干两个事情。

1. 将某个节点的子树（不包含自己）所有点的点权增加一个数（这个数可能为负，所以这个 Mirko 显然是个黑心资本家）。
2. 查询当前某个节点的点权。

# 思路

这就是一道树链剖分的模板。

如果不会树剖建议先把[模板](https://www.luogu.com.cn/problem/P3384)做了再看此题解。

先通过两遍 dfs 把树剖成链，同时记录下树上节点的时间戳。由于一条链上的节点和每棵子树的时间戳都是连续的，所以可以把其看成一个连续的区间，用线段树来维护。这样，以上两种操作就可以通过更新和访问线段树来解决了。

1. 针对第一种操作，比方说我们要给 $u$ 的下属更改工资，其在线段树上的位置为 $id_u$，其子树大小为 $size_u$，那么我们要修改的区间为 $[id_u + 1,id_u + size_u - 1]$。**注意，如果 $u$ 为叶子节点，那么 $id_u + 1$ 在此时是大于 $id_u + size_u - 1$ 的，此时不做修改。**
2. 针对第二种操作，如果我们要查询 $u$ 的工资，直接对 $id_u$ 进行单点访问即可。

# Code

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int maxn = 5e5 + 5;
int n, m;
int stamp, root = 1;
int father[maxn], son[maxn], size[maxn], depth[maxn], id[maxn], top[maxn];
int head[maxn], value[maxn], newvalue[maxn];
struct Edge {
    int from;
    int to;
    int next;
} edge[maxn << 1];
struct SegmentTree {
    int left, right;
    int value, tag;
} tree[maxn << 2];

inline void pushup(int root) {
    tree[root].value = tree[root << 1].value + tree[root << 1 | 1].value;
}

inline void pushdown(int root, int l, int r) {
    if (!tree[root].tag) return;
    int mid = (l + r) >> 1;
    tree[root << 1].value += tree[root].tag * (mid - l + 1);
    tree[root << 1 | 1].value += tree[root].tag * (r - mid);
    tree[root << 1].tag += tree[root].tag;
    tree[root << 1 | 1].tag += tree[root].tag;
    tree[root].tag = 0;
}

void build(int root, int l, int r) {
    tree[root].left = l;
    tree[root].right = r;
    if (l == r) {
        tree[root].value = newvalue[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(root << 1, l, mid);
    build(root << 1 | 1, mid + 1, r);
    pushup(root);
}

void update(int root, int l, int r, int val) {
    if (l > r) return;
    if (tree[root].left >= l && tree[root].right <= r) {
        tree[root].value += val * (tree[root].right - tree[root].left + 1);
        tree[root].tag += val;
        return;
    }
    pushdown(root, tree[root].left, tree[root].right);
    int mid = (tree[root].left + tree[root].right) >> 1;
    if (mid >= l) update(root << 1, l, r, val);
    if (mid < r) update(root << 1 | 1, l, r, val);
    pushup(root);
}

int query(int root, int l, int r) {
    if (tree[root].left >= l && tree[root].right <= r) {
        return tree[root].value;
    }
    pushdown(root, tree[root].left, tree[root].right);
    int mid = (tree[root].left + tree[root].right) >> 1;
    int ans = 0;
    if (mid >= l) ans += query(root << 1, l, r);
    if (mid < r) ans += query(root << 1 | 1, l, r);
    return ans;
}

inline void insertEdge(int u, int v) {
    static int edgecnt;
    edge[++edgecnt].from = u;
    edge[edgecnt].to = v;
    edge[edgecnt].next = head[u];
    head[u] = edgecnt;
}

void dfs1(int u, int parent) {
    father[u] = parent;
    depth[u] = depth[parent] + 1;
    size[u] = 1;
    for (int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if (v == parent) continue;
        dfs1(v, u);
        size[u] += size[v];
        if (!son[u] || size[son[u]] < size[v]) {
            son[u] = v;
        }
    }
}

void dfs2(int u, int utop) {
    id[u] = ++stamp;
    newvalue[stamp] = value[u];
    top[u] = utop;
    if (!son[u]) return;
    dfs2(son[u], utop);
    for (int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if (v == father[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

void subUpdate(int u, int val) {
    update(1, id[u] + 1, id[u] + size[u] - 1, val);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        int v;
        scanf("%d", &value[i]);
        if (i > 1) {
            scanf("%d", &v);
            insertEdge(i, v);
            insertEdge(v, i);
        }
    }
    dfs1(root, 0);
    dfs2(root, root);
    build(1, 1, n);
    while (m--) {
        char action;
        int u, val;
        scanf(" %c", &action);
        switch (action) {
        case 'p':
            scanf("%d%d", &u, &val);
            subUpdate(u, val);
            break;
        case 'u':
            scanf("%d", &u);
            printf("%d\n", query(1, id[u], id[u]));
            break;
        }
    }
    return 0;
}
```

---


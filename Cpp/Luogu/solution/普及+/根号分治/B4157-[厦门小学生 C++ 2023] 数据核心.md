# [厦门小学生 C++ 2023] 数据核心

## 题目背景

本试题为 2023 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

Sora 有一块神奇的数据核心，这块数据核心里有 $n\times m$ 个数据块，这些数据块组成了一个 $n\times m$ 的矩阵。

在数据核心中，每个数据块都有一个强度 $a_{i,j}$，代表这个数据块存在数据核心中时会提供多少的运算力。但是随着时间的推移，数据核心中有一些数据块出现了硬件老化，有些数据块的强度是一个负数，继续保留过多的老化数据块会影响数据核心的使用效率，所以 Sora 决定从原本的数据核心的矩阵中，先确定一个数据块作为新数据核心的左上角，其位置为 $(x, y)$ ，向右下方切割出一块数据核心（子矩阵），以保证其使用效率。

但是 Sora 是一个有着天马行空想象力的科学家，她想知道在确定了新的数据核心左上角的数据块的情况下，其位置为 $(x, y)$，新的数据核心（子矩阵）能够获得的最大运算力是多少。

当然她的问题很多，有 $Q$ 次询问，每次询问都会给出一个位置 $(x, y)$，你需要算出以这个位置为左上角的新数据核心对应的最大运算力。


## 说明/提示

### 样例解释

- 第一个询问对应的新数据核心是 $(1,1)$ 到 $(5,5)$。
- 第二个询问对应的新数据核心是 $(2,2)$ 到 $(5,5)$。
- 第三个询问对应的新数据核心是 $(3,3)$ 到 $(5,4)$。
- 第四个询问对应的新数据核心是 $(5,1)$ 到 $(5,4)$。
- 第五个询问对应的新数据核心是 $(5,5)$ 到 $(5,5)$。

### 数据范围

- 对于 $20\%$ 的数据，$n\times m \leq 500$，$Q \leq 500$，$a_{i,j} \leq 10^5$。
- 对于 $50\%$ 的数据，$n\times m \leq 5000$，$Q \leq 5000$，$a_{i,j} \leq 10^5$。
- 对于 $80\%$ 的数据，$n\times m \leq 10000$，$Q \leq 10000$，$a_{i,j} ≤ 10^5$。
- 对于 $100\%$ 的数据，$n\times m \leq 100000$，$Q \leq 100000$，$|a_{i,j}| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
1 -1 1 -1 1
2 2 2 -1 2
1 1 2 -1 -1
-1 -1 2 2 1
1 1 1 1 -1
6
1 1
2 2
3 3
2 4
5 1
5 5```

### 输出

```
16
12
7
2
4
-1```

# 题解

## 作者：yedalong (赞：4)

在写这道题之前请先学会二维前缀和。  
本篇题解**不会**讲解任何有关前缀和的知识，不会请出门[左转](https://blog.csdn.net/m0_65998513/article/details/132534198)。
## Solution
### 20pts
这是最简单的做法。对于每一次询问，暴力枚举右下角，接着再暴力求出这个区间内的和，时间复杂度 $O(Qn^2m^2)$。  
由于过于简单，代码就不给了。
### 80pts
用上二维前缀和，对于每一次询问枚举右下角，$O(1)$ 直接求出区间内的和，取最大值即可。  
时间复杂度 $O(Qnm)$。  
参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
unordered_map<int,int> a[100005],qzh[100005],anss[100005];
int n,m,Q,x,y;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=m;j++)
			cin>>a[i][j];
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=m;j++)
			qzh[i][j]=qzh[i-1][j]+qzh[i][j-1]-qzh[i-1][j-1]+a[i][j];
	cin>>Q;
	while(Q--){
		int ans=-1e18;
		cin>>x>>y;
		if(anss[x][y]){
			cout<<anss[x][y]<<'\n';
			continue;
		}
		for(int i = x;i<=n;i++){
			for(int j = y;j<=m;j++){
				ans=max(ans,qzh[i][j]-qzh[x-1][j]-qzh[i][y-1]+qzh[x-1][y-1]);
			}
		}
		cout<<ans<<'\n';
		anss[x][y]=ans;
	}
	return 0;
}
/*
这里的80分做法不太正经，因为用上了unordered_map，所以很浪费时间，加上一个记忆化才能卡到80。。。
建议使用vector来解决 
*/
```
### 100pts
考虑提前预处理好答案数组。  
原本暴力预处理要四重循环，我们考虑只用三重循环来解决。  
剩下的一重跑哪里去了？很简单，我们枚举的矩阵是宽为 $1$ 的不就好了？那要怎样操作呢？这样为什么是正确的呢？  
先说一下是怎样枚举的。外面两重循环，一重是 $l$ 从 $1$ 到 $n$，另一重是 $r$ 从 $l$ 到 $n$，里面那一重是 $i$ 从 $m$ 到 $1$。  
这是对于这样操作的一点解释：
![](https://cdn.luogu.com.cn/upload/image_hosting/0smgtp4t.png)  
这里有点像[最大子段和](https://www.luogu.com.cn/problem/P1115)。  
当然，如果 $n$ 取到 $10^5$，$O(Q+n^2m)$ 的时间复杂度肯定是炸掉的。但是同理，如果 $n$ 太大我们可以选择 $m$，只是操作倒过来了而已。  
时间复杂度 $O(Q+nm\sqrt{nm})$。可以通过此题。  
## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,Q,x,y,last;
#define f(x,y,xx,yy) qzh[xx][yy]-qzh[xx][y-1]-qzh[x-1][yy]+qzh[x-1][y-1]
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	vector<int> a[n+5],qzh[n+5],ans[n+5];
	for(int i = 0;i<=n+1;i++) 
		for(int j = 0;j<=m+1;j++) 
			a[i].push_back(0),
			ans[i].push_back(-1e15),
			qzh[i].push_back(0);
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=m;j++)
			cin>>a[i][j];
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<=m;j++)
			qzh[i][j]=qzh[i-1][j]+qzh[i][j-1]-qzh[i-1][j-1]+a[i][j];
	if(n<=m)
		for(int l = 1;l<=n;l++)
			for(int r = l;r<=n;r++){
				last=0;
				for(int i = m;i>=1;i--)
					ans[l][i]=max(ans[l][i],f(l,i,r,i)+max(0ll,last)),last=f(l,i,r,i)+max(0ll,last);
			}
	else
		for(int l = 1;l<=m;l++)
			for(int r = l;r<=m;r++){
				last=0;
				for(int i = n;i>=1;i--)
					ans[i][l]=max(ans[i][l],f(i,l,i,r)+max(0ll,last)),last=f(i,l,i,r)+max(0ll,last);
			}
	cin>>Q;
	while(Q--)
		cin>>x>>y,
		cout<<ans[x][y]<<'\n';
	return 0;
}
```

---

## 作者：C202301 (赞：1)

### 前言
两年前刚学信息的时候写的题，当时只会打暴力。现在奔着 DP 的标签来找，终于过了这道题。这道题也不是很 DP？
###  题意简述
给定 $n$，$m$ 和一个大小为 $n \times m$ 的矩阵，位置 $(i,j)$ 提供的价值为 $a_{i,j}$，有 $Q$ 个询问，每次询问给定位置 $(x,y)$，求以 $(x,y)$，为左上角形成的矩形中所包含的最大价值是多少。
### 前置知识
#### 一维前缀和
一种常用的技巧，可以做到 $O(n)$ 预处理，让每次查询的复杂度达到 $O(1)$，比方说给一个数组 $a$，它的前缀和数组 $d$ 是指 :
$$d_i=\sum_{j=1}^{i} a_j$$
例如：一个数组的数值为 $1,3,5,7,9$，那么它的前缀和数组是 $1,4,9,16,25$。

它的意义就是原数组下标为 $1$ 至 $i$ 的和，因此我们有更简单的递推式：$d_i=d_{i-1}+a_i$。

当我们要查询一个区间 $[x,y]$ 的和时，我们可以通过 $d_y-d_{x-1}$ 求得。

实现如下：
```cpp
#include<iostream>
#define ll long long
using namespace std;
ll a[100005],d[100005];
int main()
{
    int n,q;
    cin>>n>>q;
    for(int i=1;i<=n;i++)
    cin>>a[i],d[i]=d[i-1]+a[i];
    while(q--){
        int x,y;
        cin>>x>>y;
        cout<<d[y]-d[x-1]<<endl;
    }
    return 0;
}
```
#### 二维前缀和
类比一维前缀和，我们在大小为 $n \times m $ 矩阵中可以通过 $O(nm)$ 预处理来 $O(1)$ 回答左上角为 $(i,j)$ 右下角为 $(x,y)$ 的矩阵的元素和。

假设原数组为 $a$，前缀和数组是一个这样的数组 $d$，$d_{i,j}$ 代表左上角为 $(1,1)$，右下角为 $(i,j)$ 的矩阵元素和，那么有 $d_{i,j}=d_{i-1,j}+d_{i,j-1}-d_{i-1,j-1}+a_{i,j}$，然后询问时用 $d_{x,y}-d_{i-1,y}-d_{x,j-1}+d_{i-1,j-1}$ 即可求得。

建议读者自行推导理解，可以先做一下 P2280。
#### 补充
最大字段和 P1115 可以说是这道题的类似一维版本，可以先尝试。
### 思路
非常直观的一个思路是用预处理二维前缀和，然后每个询问枚举右下角，但这个时间复杂度是很劣的，为 $O(Qn^2m^2+nm)$，看看数据范围，无法通过。

我们可以发现，我们多次重复枚举了一些东西，这使得复杂度较高。例如，位置为 $(a,b)$ 的枚举位置和位置为 $(a-1,b)$ 的枚举位置很大一部分是一样的。本着优化复杂度的目的，我们考虑对于一个点 $(x,y)$ 他的答案会由什么得出。

假设我们已经知道这个矩阵的长度或者宽度，那么我们需要枚举多少次呢？只需要再枚举 $n-x+1$ 或 $n-y+1$ 次。而这些我们可否预处理呢？答案是可以。由上文的分析可以得出，我们很大一部分重复枚举就来源于这里，那么我们就可以在预处理二维前缀和后来预处理。

定义 $dp_{i,j,k}$ 为左上角为 $(k,i)$，右上角为 $(k,j)$ 构成的矩阵的最大价值和。我们可以考虑以下两点：

1. 不选择其他，那么获得的价值就是左上角为 $(k,i)$，右下角 $(k,j)$ 的矩阵的价值和。

2. 选择更下面的一些行，那么我们一定包含第 $k+1$ 行的一些数值，那一定要取左上角为 $(k+1,i)$，右上角为 $(k+1,j)$ 的矩阵的最大值，也即 $dp_{i,j,k+1}$。

设 $a(k,i,j)$ 代表左上角为 $(k,i)$，右下角 $(k,j)$ 的矩阵的价值和。这一部分可以通过二维前缀和求出。

所以可以得到状态转移方程  $dp_{i,j,k}=\max(a(k,i,j),a(k,i,j)+dp_{i,j,k})$，确定另一边来枚举的情况同理，读者可自行推导，看一下题目的内存大小为 512MB，可以开得下数组。
### 一些要点
1. 注意到这道题 $-10^9 \le a_{i,j} \le 10^9$，那么记得开 long long。

2. 这道题我们需要选取 $n$，$m$ 之中较小的一个预处理，记得开不同的 dp 数组。时间复杂度是 $O(nm\sqrt{nm}+Q\min(n,m))$，可过。
### 代码实现
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#define ll long long
using namespace std;
ll n,m;
int main()
{
	cin>>n>>m;
	ll a[n+55][m+55],p[n+55][m+55];
	for(int i=0;i<=n;i++) p[i][0]=0;
	for(int i=0;i<=m;i++) p[0][i]=0;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		cin>>a[i][j];
		p[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+a[i][j];
	}
	if(n<m){
		ll dp[n+5][n+5][m+5];
		for(int i=1;i<=n;i++)
		    for(int j=i;j<=n;j++){
		    	for(int k=m;k>=1;k--){
		    		if(m==k) 
					dp[i][j][k]=p[j][m]-p[i-1][m]-p[j][m-1]+p[i-1][m-1];
					else{
						dp[i][j][k]=p[j][k]-p[i-1][k]-p[j][k-1]+p[i-1][k-1];
						if(dp[i][j][k+1]>=0)
					    dp[i][j][k]+=dp[i][j][k+1];
					}
				}
			}
		int q;
		cin>>q;
		while(q--){
			int x,y;
			ll ans=-1000000000000000;
			cin>>x>>y;
			for(int i=1;x+i-1<=n;i++)
				ans=max(ans,dp[x][x+i-1][y]);
			cout<<ans<<endl;
		}	
	}else{
		ll dp[m+5][m+5][n+5];
		for(int i=1;i<=m;i++)
		    for(int j=i;j<=m;j++){
		    	for(int k=n;k>=1;k--){
		    		if(n==k) 
					dp[i][j][k]=p[n][j]-p[n][i-1]-p[n-1][j]+p[n-1][i-1];
					else{
						dp[i][j][k]=p[k][j]-p[k][i-1]-p[k-1][j]+p[k-1][i-1];
						if(dp[i][j][k+1]>=0)
					    dp[i][j][k]+=dp[i][j][k+1];
					}
				}
			}
		int q;
		cin>>q;
		while(q--){
			int x,y;
			ll ans=-1000000000000000;
			cin>>x>>y;
			for(int i=1;y+i-1<=m;i++)
				ans=max(ans,dp[y][y+i-1][x]);
			cout<<ans<<endl;
		}
	}
	return 0;
}
```
### 后记
这道题我初始的思路是想通过某一些状转来实现 $O(nm)$ 预处理每一个答案，但并没有实现，因为无法满足 DP 最优子结构的性质。

这道题 DP 方程很朴素以至于它更像一道二位前缀和的应用的题目。所以我们在考试时更应该优先考虑用朴素简单的思路来解决一道题，有可能就可以得到正解，避免了多余消耗的时间。

---


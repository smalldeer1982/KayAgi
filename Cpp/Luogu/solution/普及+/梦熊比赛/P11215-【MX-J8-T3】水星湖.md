# 【MX-J8-T3】水星湖

## 题目背景

原题链接：<https://oier.team/problems/J8C>。

## 题目描述

有一个 $n\times m$ 的矩形网格。用数对 $(x, y)$ 表示第 $x$ 行、第 $y$ 列的位置。

网格内有 $q$ 片湖泊（$q$ 可能为 $0$），第 $i$ 片湖泊覆盖了左上角为 $(a_{i, 1}, b_{i, 1})$、右下角为 $(a_{i, 2}, b_{i, 2})$ 的矩形区域，这片区域里的所有位置都被称为湖泊。如果一个位置不属于任何一片湖泊，它就是陆地。湖泊两两不会重叠，但可能相邻。

小 Y 会进行 $r$ 次种树。第 $i$ 次，他在第 $t_i$ 秒向 $(x_i, y_i)$ 里种下一棵树，保证该位置不为湖泊，且要么没有种下或生长过树，要么曾经种下或生长的树已经死亡。保证种树是按照时间顺序进行的，即 $t_1, t_2, \dots, t_r$ 单调不降。

每一秒，对于每个位置 $(x, y)$，若它同时满足如下所有条件，则会在 $(x, y)$ 处生长出一棵树：
- 它是一块无树存活的陆地；
- 它与一块湖泊**相邻**；
- 它**在前一秒**与一棵存活的树**相邻**。

（上述所说的**相邻**是在四连通意义下的，即位置 $(x_1, y_1)$ 和 $(x_2, y_2)$ 相邻当且仅当 $\lvert x_1 - x_2 \rvert + \lvert y_1 - y_2 \rvert = 1$。）

如果一棵树在存活**大于 $\bm k$ 秒**后（以其被种下或生长出来时开始计算），与其相邻的所有位置**均为无树存活的陆地**，则它会死亡。

小 Y 想要知道：经过充分多时间后（也即，经过足够多的时间，使得网格内不会有新的位置长出树，也不会有旧的树死去的状态下），网格内最终会有多少棵树。

## 说明/提示

**【样例解释 \#1】**

如图所示，为经过充分多时间后网格中的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/kdlmoo7p.png)

网格内不会有新的位置长出树，也不会有旧的树死去，所以经过充分多时间后，网格内有 $10$ 棵树。

**【样例解释 \#2】**

在这一组数据中，所有位置都是陆地，没有湖泊。

第 $1$ 秒时，第一棵树在 $(3, 1)$ 被种下。

第 $2$ 秒时，第二棵树在 $(1, 1)$ 被种下。紧接着，第一棵树已存活 $> 1$ 秒，且与其相邻的所有位置均为没有存活的树的陆地，因此死亡。

第 $3$ 秒时，第三棵树在 $(2, 1)$ 被种下。紧接着，第二棵树已存活 $> 1$ 秒，而此时第三棵树与其相邻，因此不死亡。

随后，网格内不会有新的位置长出树，也不会有旧的树死去。所以经过充分多时间后，网格内有 $2$ 棵树。

**【样例 \#3】**

见附件中的 `lake/lake3.in` 与 `lake/lake3.ans`。

该组样例满足测试点 $4 \sim 7$ 的约束条件。

**【样例 \#4】**

见附件中的 `lake/lake4.in` 与 `lake/lake4.ans`。

该组样例满足测试点 $8 \sim 10$ 的约束条件。

**【样例 \#5】**

见附件中的 `lake/lake5.in` 与 `lake/lake5.ans`。

该组样例满足测试点 $13 \sim 15$ 的约束条件。

**【样例 \#6】**

见附件中的 `lake/lake6.in` 与 `lake/lake6.ans`。

该组样例满足测试点 $16 \sim 20$ 的约束条件。

**【数据范围】**

本题共 $20$ 个测试点，每个 $5$ 分。

|测试点编号|$n,m\le$|$q\le$|$r\le$|$t_i,k\le$|
| :-----------: | :-------------:|:-----------: |:-----------: |:-----------: |
|$1\sim3$|$10$|$10$|$10$|$10$|
|$4\sim7$|$50$|$100$|$1000$|$1000$|
|$8\sim 10$|$3000$|$0$|$10^5$|$10^9$|
|$11\sim12$|$3000$|$10^5$|$1$|$10^9$|
|$13\sim15$|$1000$|$10^5$|$10^5$|$12$|
|$16\sim20$|$3000$|$10^5$|$10^5$|$10^9$|

对于全部数据，保证：
- $1 \leq n, m \leq 3000$；
- $0 \leq q \leq 10^5$；
- $1 \leq a_{i, 1} \le a_{i, 2} \leq n$，$1 \leq b_{i, 1} \le b_{i, 2} \leq m$；
- 湖泊两两不会重叠；
- $1 \leq r \leq 10^5$；
- $1 \leq t_1 \leq t_2 \leq \dots \leq t_r \leq 10^9$；
- $1 \leq x_i \leq n$，$1 \leq y_i \leq m$；
- 位置 $(x_i, y_i)$ 不是湖泊且无树存活；
- $1 \leq k \leq 10^9$。


## 样例 #1

### 输入

```
5 6 2 1 1
2 1 3 3
3 5 5 6
1 1 5```

### 输出

```
10```

## 样例 #2

### 输入

```
3 3 0 3 1
1 3 1
2 1 1
3 2 1
```

### 输出

```
2```

# 题解

## 作者：tallnut (赞：15)

好题。

![](https://cdn.luogu.com.cn/upload/image_hosting/yxaoejfk.png)
# 思路
首先把湖的信息存在二维数组里面。由于题目保证所有湖不重叠，因此复杂度是 $\Theta(nm)$ 的。

为了按照时间顺序处理操作，使用**优先队列**存储事件。一个事件包含 $4$ 种信息：
- 发生时间；
- 是哪种事件：生成了一颗新树，还是一棵树死亡；
- 发生地点：$x$ 坐标；
- 发生地点：$y$ 坐标。

然后把这些事件按照时间排序放进优先队列里面，每次取出堆顶即可做到根据时间的推移模拟事件的发生过程。

考虑如何处理这些事件。
- 生成了一棵树：在地图上标记这棵树，然后将它死亡的信息放入堆中。（如果它身边有湖或者有其他树，则永远不会死，因为它和另外那棵树可以互相保护。）若当前时间是 $t$，则它死亡的时间应当是 $t+k+0.5$（因为题目中说**大于 $k$ 秒后**，但在下一秒之前），但为了避免出现浮点数，可以把所有时间乘以 $2$ 存储起来。随后向四个方向扩展，判断是否符合题目中生成树的要求。
- 一棵树死亡：判断它身边是否有湖或树，没有则移除这棵树。

于是就做完了这道题。算上堆的时间，时间复杂度为 $\Theta(nm\log(nm))$。

**记得开 `long long`。**
# AC 代码
场上没开 `long long` 痛失 $40$ 分。/fn

```cpp
/*
用优先队列模拟事件发生的顺序
*/
// NOTE: "[EDIT]" means you should edit this part by yourself
#include <bits/stdc++.h>
// [EDIT] please enable this line if there are many tests
//#define MULTITEST
using namespace std;
// [EDIT] if you want to copy some templates, please paste them here

typedef long long ll;
#define int ll
#define rep1(i,x,y) for (int i = (x);i <= (y);i++)
#define rep2(i,x,y) for (int i = (x);i >= (y);i--)
#define rep3(i,x,y,z) for (int i = (x);i <= (y);i += (z))
#define rep4(i,x,y,z) for (int i = (x);i >= (y);i -= (z))
#define cl(a) memset(a,0,sizeof(a))
// [EDIT] define some constants here
const int N = 3010;
// [EDIT] define some variables, arrays, etc here
struct happening
{
	//存储：乘以2的值
	int t;
	//0表示生长出一棵树，1表示这棵树死亡
	int thing;
	//x,y坐标
	int x;
	int y;
	bool operator<(const happening& xx) const { return t > xx.t; }
} tmp;
int n,m,qq,r,k,aa,bb,cc,dd,tt,xx,yy,ans;
priority_queue<happening> q;
//0表示啥都没有，1表示有水，2表示有树
int mp[N][N];
inline bool check_grow(int x,int y) { return x >= 1 && x <= n && y >= 1 && y <= m && mp[x][y] == 0 && (mp[x - 1][y] == 1 || mp[x + 1][y] == 1 || mp[x][y - 1] == 1 || mp[x][y + 1] == 1); }
// [EDIT] a function to solve the problem
void solve()
{
    //input
	cin >> n >> m >> qq >> r >> k;
	k *= 2;
	rep1(i,1,qq)
	{
		cin >> aa >> bb >> cc >> dd;
		rep1(j,aa,cc)
			rep1(kk,bb,dd)
				mp[j][kk] = 1;
	}
	rep1(i,1,r)
	{
		cin >> tt >> xx >> yy;
		q.push({tt * 2,0,xx,yy});
	}
    //solve
	while (q.size())
	{
		tmp = q.top();
		q.pop();
		//判断是什么事件
		//是树生长的事件
		if (tmp.thing == 0)
		{
			//判断；这个格子上面没树
			if (mp[tmp.x][tmp.y] == 0)
			{
				mp[tmp.x][tmp.y] = 2;
				//如果他旁边没树且没水：那么加入死亡事件，否则他们俩可以互相固定，都不会死
				if (mp[tmp.x - 1][tmp.y] == 0 && mp[tmp.x + 1][tmp.y] == 0 && mp[tmp.x][tmp.y - 1] == 0 && mp[tmp.x][tmp.y + 1] == 0)
					q.push({tmp.t + k + 1,1,tmp.x,tmp.y});
				//向旁边扩展
				if (check_grow(tmp.x - 1,tmp.y))
					q.push({tmp.t + 2,0,tmp.x - 1,tmp.y});
				if (check_grow(tmp.x + 1,tmp.y))
					q.push({tmp.t + 2,0,tmp.x + 1,tmp.y});
				if (check_grow(tmp.x,tmp.y - 1))
					q.push({tmp.t + 2,0,tmp.x,tmp.y - 1});
				if (check_grow(tmp.x,tmp.y + 1))
					q.push({tmp.t + 2,0,tmp.x,tmp.y + 1});
			}
		}
		//是树死亡的事件
		else if (tmp.thing == 1)
		{
			//判断：都是陆地
			if (mp[tmp.x - 1][tmp.y] == 0 && mp[tmp.x + 1][tmp.y] == 0 && mp[tmp.x][tmp.y - 1] == 0 && mp[tmp.x][tmp.y + 1] == 0)
				mp[tmp.x][tmp.y] = 0;
		}
	}
	rep1(i,1,n)
		rep1(j,1,m)
			if (mp[i][j] == 2)
				ans++;
    //output
	cout << ans;
    //clear

}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t;
#ifdef MULTITEST
    cin >> t;
#else
    t = 1;
#endif
    while (t--)
        solve();
}
```

---

## 作者：ShizukuQWQ (赞：6)

题目数据范围不大，我们考虑大模拟。
首先可以得出两个结论。
#### 结论1
对于任意一棵树，若它离湖的距离不大于二，则它可以产生树并且不会死亡（因为此时必然存在一棵相邻它的树或它本身与湖面相邻）。
#### 结论2
一棵树如果能够存活 $k$ 秒，则它一定会对答案产生影响。反之如果它死了，一定不会产生影响。（当一棵树能使另一棵树存活时，另一棵树同样也能使它存活，而死去的树不可能能保护其他的树，不然它也不会死）。
#### 做法
题目中说了种树时要么这里没种过树，要么以前的树死了，因为死了的树不会对结果产生影响，所以可以直接把后面的树覆盖掉前面的树。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,q,r,k;
const long long N=1e5+5;
long long z1,z2,z3,z4,x[N],y[N],t[N],ans;
int a[3005][3005];
int nx[12]={0,1,0,-1,1,1,-1,-1,0,0,2,-2};
int ny[12]={1,0,-1,0,-1,1,-1,1,2,-2,0,0};
bool ch1(int u,int p){//判断这棵树是否与湖相邻
	for(int i=0;i<4;++i){
		if(a[u+nx[i]][p+ny[i]]<0) return 1;
	}
	return 0;
}
bool ch3(int u,int p){//判断当前这棵树能否活下去
	for(int i=0;i<4;++i){
		if(a[u+nx[i]][p+ny[i]]<=0) continue;
		if(a[u+nx[i]][p+ny[i]]-a[u][p]<=k) return 1;
//不用加绝对值，当之前那棵树的时间更小时，说明这棵树永远能够活下去（超过k秒还不死）
	}
	return 0;
}
inline void dfs(int u,int p){
	for(int i=0;i<4;++i){
		int X=u+nx[i],Y=p+ny[i];
		if(X<0||Y<0||X>n||Y>m) continue;
//直接暴力，由于生成的树和湖相邻不会死，因此直接暴力最坏也只是把整张图都种满树，而不会重复种。
		if(a[X][Y]==0&&ch1(X,Y)){
			a[X][Y]=1;
			dfs(X,Y);
		}
	}
}
bool ch2(int u,int p){
//判断周围2距离有没有湖
	if(a[u][p]<0) return 0;
	for(int i=0;i<12;++i){
		if(a[u+nx[i]][p+ny[i]]<0) return 1;
	}
	return 0;
}
int main(){
//	freopen("lake6.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>n>>m>>q>>r>>k;
	for(int i=1;i<=q;++i){
		cin>>z1>>z2>>z3>>z4;
		a[z1][z2]--;
		a[z3+1][z2]++;
		a[z1][z4+1]++;
		a[z3+1][z4+1]--;
//可以直接暴力把湖设为-1，也可以利用二维前缀和（具体看板子题目）
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
		}
	}
	for(int i=1;i<=r;++i){
		cin>>t[i]>>x[i]>>y[i];
		a[x[i]][y[i]]=t[i];//设置当前树生成的时间
	}
	for(int i=1;i<=r;++i){
		if(ch2(x[i],y[i])) dfs(x[i],y[i]);//生成了树
		else{
			if(ch3(x[i],y[i])==0) a[x[i]][y[i]]=0;//死了
		}
	}
	ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]>0) ans++;//统计活着的树
		}
	}
	cout<<ans;
}

---

## 作者：lovelish (赞：6)

两种做法。

做法一：

首先，使用一个数组（或两个数组）表示网格上的情况，对于整个过程中所有活的树，直接将其添加到网格中。

使用一个队列维护所有在上一秒长出树的信息，然后每一秒对队列中的树判断其上下左右四个格子是否会生长出树，若生长了，则将该位置入队列。（队列里存着生长时间）

再使用一个队列维护所有刚种下时没有与其他树或湖相邻的树，对于第 $i$ 棵树，如果其入了该队列，那么在 $t_i+k$ 秒时再次判断其是否与其他树或湖相邻，如果没有，那么删去这棵树。

最后统计结果即可。

可以发现，只要一个格子中只中过一棵树，那么这个格子最多只会入第一个队列一次，也就是说，在不考虑时间的情况下时间复杂度为 $O(nm+r)$。如果一秒一秒枚举，那么显然时间会非常大，但是实际上过程中至多有 $nm+r$ 棵树入过第一个队列，于是我们可以直接把空队列时直接跳过，一个跳到下一个 $t_i$ 即可，因为在这期间第一个队列一定是空的。那么整体的时间复杂度即 $\mathcal O(nm+r)$。

做法二：

我们把一棵树种下去后，若其附近有湖且能因这棵树长出其他树的行为称为这棵树在湖边蔓延。

通过定义可以发现，如果一棵树不能在湖边蔓延，那么它也不可能被其他从湖边蔓延的树给相邻使得其存活。

那么我们便可以将所有的树分成两组：可以在湖边蔓延的、不可以在湖边蔓延的。对于可以在湖边蔓延的，我们先让这些树全部蔓延完毕直到不能再蔓延（dfs），然后对不可以在湖边蔓延的使用做法一中的第二个队列维护即可。

时间复杂度： $\mathcal O(nm+r)$。

---

## 作者：ArenaBreakout_CDQZ (赞：5)

## 0th 一些约定

我们将湖记为 $1$，常青树（即题目中“经过充分多时间后” 网格内剩下的树）记为 $2$，种下的马上死亡的树记为 $3$，可以长树的地方记为 $4$。

## 1st 图的存储

观察数据可得，$n,m\le3000$，则考虑将整表打出，又因 $2s$ 的时限，可考虑直接在输入时将湖泊进表（实测不超时）。

```cpp
for(int x=x1;x<=x2;x++){
    for(int y=y1;y<=y2;y++){
         s[x][y]=1;
    }
}
```

## 2nd 主要思想

爆搜，以每次种的树为起点，首先检测是否能存活。

```cpp
s[x+1][y]!=0||s[x-1][y]!=0||s[x][y + 1]!=0||s[x][y-1]!=0
```

再搜索四方是否有能长出或能常青的树：

```cpp
int dx[]={0,0,0,1,-1};
int dy[]={0,1,-1,0,0};
for(int i=0;i<=3;i++){
    int nx=dx[i]+x,ny=dy[i]+y;
    if(s[nx][ny]==3||s[nx][ny]==4) dfs(nx, ny);
}
```

而在我们开始搜的这颗树的位置的四联通内若有：

- 种下的，马上死亡的树（见 3rd->Ⅰ）
- 可以长树的地方（见 3rd->Ⅱ）

那么这里将会有一棵常青树。

```cpp
s[x][y]=2,ans++;
```

（题目死亡条件：**与其相邻的所有位置均为无树存活的陆地**，则它会死亡；）\
（题目长树条件：它是一块无树存活的陆地，它与一块湖泊相邻，它在前一秒**与一棵存活的树相邻**。）

## 3rd 图的一些其他处理

### Ⅰ

种下的，马上死亡的树 ->$3$

```cpp
if(!s[x+1][y]!=0||s[x-1][y]!=0||s[x][y + 1]!=0||s[x][y-1]!=0){
//四周都是荒土
   s[t[p].l][t[p].r]=3;//快死了
}
```

### Ⅱ

可以长树的地方 ->$4$

```cpp
if(s[x-1][y]==1||s[x+1][y]==1||s[x][y-1]==1||s[x][y+1]==1){
//周围有水
    s[i][j]=4;//可以长
}
```

## 4th 一些细节

在遍历种的树的时候，可以使用**队列**数据结构，每遍历到一个先看是否能立即存活，若不能则 **push** 进队列里，再在下一次遍历时看下一次有没有可能帮助这棵树存活下来。

```cpp
node f=q.front();
while(!q.empty()&&f.t<t[p].t){//队列里有快死的树且救不活了（下一个种下的时间比要死的时间完）
    if(s[f.l][f.r]==3) s[f.l][f.r]=0;//成荒土
    q.pop();//重开
   	f = q.front();
}
bool flag=check(t[p].l,t[p].r);//能不能存活:s[x+1][y]!=0||s[x-1][y]!=0||s[x][y + 1]!=0||s[x][y-1]!=0
if(flag)dfs(t[p].l,t[p].r);//爆搜
else{
     s[t[p].l][t[p].r]=3;//要死了
     t[p].t+=k;//时间到死的时候
     q.push(t[p]);//进队列
}
p++;
```

## 5th 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e3+10,M=1e5+10;
int n,m,qq,r,k,s[N][N],ans;
struct node{
	int l,r,t;
}t[M];
queue<node>q;
inline bool c1(int x,int y){
	return s[x-1][y]==1||s[x+1][y]==1||s[x][y-1]==1||s[x][y+1]==1;
}
inline bool check(int x,int y){
    return s[x+1][y]!=0||s[x-1][y]!=0||s[x][y + 1]!=0||s[x][y-1]!=0;
}
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
void dfs(int x,int y){
    s[x][y]=2,ans++;
    for(int i=0;i<=3;i++){
        int nx=dx[i]+x,ny=dy[i]+y;
        if(s[nx][ny]==3||s[nx][ny]==4) dfs(nx, ny);
    }
}

signed main(){
    cin>>n>>m>>qq>>r>>k;
    for(int i=1;i<=qq;i++){
        int x1,x2,y1,y2;
        cin>>x1>>y1>>x2>>y2;
        for(int x=x1;x<=x2;x++)for(int y=y1;y<=y2;y++) s[x][y] = 1;
    }
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
	        if(s[i][j]==1)continue;
	        if(c1(i,j))s[i][j]=4;
	    }
	}	
    for(int i=1;i<=r;i++) cin>>t[i].t>>t[i].l>>t[i].r;
    int p=1;
    while(p<=r){
        node f=q.front();
        while(!q.empty()&&f.t<t[p].t){
            if(s[f.l][f.r]==3) s[f.l][f.r]=0;
            q.pop();
            f=q.front();
        }
        bool flag=check(t[p].l,t[p].r);
        if(flag)dfs(t[p].l,t[p].r);
        else{
            s[t[p].l][t[p].r]=3;
            t[p].t+=k;
            q.push(t[p]);
        }
        p++;
    }
    cout<<ans<<'\n';
}
```

---

## 作者：沉石鱼惊旋 (赞：3)

一个很关键的性质是，一棵树如果周围有树，或者周围有湖，就不会死。

虽然这是题面告诉你的，但是稍微想一下就知道，每个位置只可能有过树然后死掉了，或者根本没有过树，或者种下的树一直活着。

再想一下就知道，如果树的生长蔓延了，被蔓延到的位置全都是永久存活的。这个蔓延会形成一个个绕着湖的**联通块**，中间靠一些零散的树连接起来，联通块内部一定是树挨着的，满足『周围有树』的生长条件。

那么如果我们发现这棵树种下之后会永久存活，就从这棵树开始搜索，搜出一个全都能生长树的联通块，标记成永久存活的位置即可。

复杂度是正确的，因为如果已经被标记为永久存活，下一次搜到这里想给它打标记，就可以直接不管这棵树。这样一个位置只可能被标记一次，复杂度正确。

处理树的死亡可以开一个队列储存。每一次种树的时候看一下队首元素，如果生长了超过 $k$ 秒就尝试让它死亡。只有标记成永久存活的位置的树才可以不死亡。

---

## 作者：_zuoqingyuan (赞：3)

好像有点麻烦了。

# 思路分析

我们开一个二维数组表示地图，湖泊为 `1`，树木为 `2`。对于湖泊的标记，可以用二维差分来做，时间复杂度 $O(nm)$。

我们发现，一个地图中只存在三种事件发生。

- 小 Y 种树

- 树木扩散到四周

- 树木死亡

我们可以将每个事件用四元组 $(op,t,x,y)$ 表示，这四个元素分别表示事件类型，发生时间，发生位置，然后把他们按照时间执行即可

同时，事件一的发生可能会导致事件二和事件三的出现，事件二的发生可能会导致新的事件二和事件三的出现，所以我们需要一个数据结构，支持插入一个任务，并取出时间最小的任务，显然可以优先队列，时间复杂度 $O(nm\log nm+nm)$。

不过仍然有点慢，我们考虑用三个不同的队列维护三堆不同的任务，这样不需要数据结构就可以确保单调性。初始时只有队列 $1$ 有任务，每次查找当前时间最小的事件，就对比三个队头，返回时间最小的（如果存在时间相同则优先返回事件 $1,2$，最后返回事件 $3$）。

其他就是一些细节问题了，可以当大模拟练手。

时间复杂度为 $O(nm)$，可以通过本题。


```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
const int N=3005;
int c[N][N],n,m,q,r,k,mp[N][N],fx[]={-1,0,1,0},fy[]={0,1,0,-1},ans;
struct node{
    int t,tim,x,y;
};
queue<node>q1,q2,q3;
void add(int x,int y,int xx,int yy){
    c[x][y]++,c[x][yy+1]--,c[xx+1][y]--,c[xx+1][yy+1]++;
}
node get(){
    if(!q1.size()&&!q2.size()&&!q3.size())return node{-1,0,0,0};//没有任务
    node tmp;
    if(q1.size()&&!q2.size()&&!q3.size())tmp=q1.front(),q1.pop();
    if(!q1.size()&&q2.size()&&!q3.size())tmp=q2.front(),q2.pop();
    if(!q1.size()&&!q2.size()&&q3.size())tmp=q3.front(),q3.pop();
    if(q1.size()&&q2.size()&&!q3.size()){
        if(q1.front().tim<=q2.front().tim)tmp=q1.front(),q1.pop();
        else tmp=q2.front(),q2.pop();
    }
    if(!q1.size()&&q2.size()&&q3.size()){
        if(q2.front().tim<=q3.front().tim)tmp=q2.front(),q2.pop();
        else tmp=q3.front(),q3.pop();
    }
    if(q1.size()&&!q2.size()&&q3.size()){
        if(q1.front().tim<=q3.front().tim)tmp=q1.front(),q1.pop();
        else tmp=q3.front(),q3.pop();
    }
    if(q1.size()&&q2.size()&&q3.size()){
        tmp=q1.front();
        if(tmp.tim>q2.front().tim)tmp=q2.front();
        if(tmp.tim>q3.front().tim)tmp=q3.front();
        if(tmp.t==1)q1.pop();
        if(tmp.t==2)q2.pop();
        if(tmp.t==3)q3.pop();
    }
    return tmp;
}
bool inside(int x,int y){
    return !(x<1||x>n||y<1||y>m);
}//判断是否在地图内
bool check(int x,int y){
    if(!inside(x,y)||mp[x][y]!=0)return 0;
    for(int i=0;i<4;i++){
        int xx=x+fx[i],yy=y+fy[i];
        if(inside(xx,yy)&&mp[xx][yy]==1)return 1;
    }
    return 0;
}//判断能否扩散成树木
bool judge(int x,int y){
    for(int i=0;i<4;i++){
        int xx=x+fx[i],yy=y+fy[i];
        if(inside(xx,yy)&&mp[xx][yy]!=0)return 0;
    }
    return 1;
}//判断会不会死
int main(){
    scanf("%d %d %d %d %d",&n,&m,&q,&r,&k);
    for(int i=1,a,b,c,d;i<=q;i++){
        scanf("%d %d %d %d",&a,&b,&c,&d);
        add(a,b,c,d);//二维差分
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            c[i][j]+=c[i-1][j]+c[i][j-1]-c[i-1][j-1];
            if(c[i][j]>=1)mp[i][j]=1;
        }
    }
    for(int i=1,a,b,c;i<=r;i++){
        scanf("%d %d %d",&a,&b,&c);
        q1.push(node{1,a,b,c});
    }
    while(1){
        node t=get();
        if(t.t==-1)break;
        if(t.t==1){
            q2.push(node{2,t.tim,t.x,t.y});
            q3.push(node{3,t.tim+k,t.x,t.y});
            mp[t.x][t.y]=2;
        }else if(t.t==2){
            for(int i=0;i<4;i++){
                int x=t.x+fx[i],y=t.y+fy[i];
                if(check(x,y)){
                    mp[x][y]=2;
                    q2.push(node{2,t.tim+1,x,y});
                    q3.push(node{3,t.tim+k,x,y});
                }
            }
        }else if(t.t==3){
            if(judge(t.x,t.y)){
                mp[t.x][t.y]=0;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(mp[i][j]==2)ans++;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
如有错误，请指出。

---

## 作者：wyhgko (赞：3)

# P11215 题解

[题目链接](https://www.luogu.com.cn/problem/P11215)


## 法一
根据题目跑模拟，期望得分不详

## 分析 
考虑一棵树何时诞生，显然要满足
>  1.它是一块无树存活的陆地；
2.它与一块湖泊相邻；
> 3.它在前一秒与一棵存活的树相邻

根据第二条我们可以将土地分为两种：~~肝帝~~干地和湿地
对于湿地，树可以生长，干地则不行，可以定义数组$lake$，用先处理是否为湖，再处理干地和湿地；
代码：
```cpp

for(int i=1;i<=Q;i++){
		int x,y,x2,y2;
		scanf("%d%d%d%d",&x,&y,&x2,&y2);//读入
		for(int j=x;j<=x2;j++){
			for(int k=y;k<=y2;k++){
				lake[j][k]=1;//1代表是湖
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(lake[i][j]==1)continue;
			for(int k=0;k<=3;k++){
				int px=i+tox[k],py=j+toy[k];
				if(lake[px][py]==1&&lake[i][j]==0){
					lake[i][j]=2;//2代表湿地，0代表旱地
					break;
				}
			}
		}
	}
```
读懂题意后，看一眼数据范围$t,k<=1e9$,
这就是模拟T飞的罪魁祸首，考虑优化：

>经过充分多时间后（也即，经过足够多的时间，使得网格内不会有新的位置长出树，也不会有旧的树死去的状态下），网格内最终会有多少棵树

每次种树bfs一遍找出 增加的树 和 旱地上临死又救活的树 ，时间$n^2m^2$,又T飞了:(

## 再优化
有一个显而易见的结论：
>若任意两树在没死时相连，则必然能永久存活

因此我们不必考虑树的每秒情况，而是用两个数组$die$&$grow$记录数的出生时刻与死亡时刻，$die[x][y]=inf$即为不死，当两点间$die[x][y]>grow[x2][y2]$，两树便能永生

所以当遍历到永生树，就不必加入队列，因为当前树能优化的，永生树也能优化，永生树不能优化，当前也树不能优化

当点被遍历到，即两树在没死时相连，则能永久存活，所以一个点最多遍历一次，时间复杂度$n*m$

## 代码
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
const int N=3010;
const int inf=2e9+100;//旱地树最多能坚持到t+k秒
int grow[N][N],die[N][N],lake[N][N];// 1 water  2 wet land  0 dry land
queue<pair<int,int> >q;
// grow:time to plant 
// die:time to die   
//  if die[i][j]=inf => dont die
int n,m,Q,R,tim,tox[4]={1,-1,0,0},toy[4]={0,0,1,-1};//bfs小优化
inline bool pd(int x,int y){
	return (x>=1&&x<=n&&y>=1&&y<=m);//判断是否出界
}
void bfs(int x,int y){
	q.push(make_pair(x,y));
	while(!q.empty()){
		pair<int,int> pii=q.front();q.pop();
		int x=pii.first,y=pii.second;
		for(int i=0;i<=3;i++){
			int px=x+tox[i],py=y+toy[i];
			if(!pd(px,py))continue;
			if(grow[px][py]==0){
				if(lake[px][py]==2){//树的生长
					grow[px][py]=grow[x][y]+1;
					die[px][py]=inf;
					bfs(px,py);
				}
			}
			if(die[px][py]>=grow[x][y]){//两树在没死时相连
				die[px][py]=inf;
				die[x][y]=inf;
			}
		}
	}
}
signed main(){
	scanf("%d%d%d%d%d",&n,&m,&Q,&R,&tim);
	for(int i=1;i<=Q;i++){
		int x,y,x2,y2;
		scanf("%d%d%d%d",&x,&y,&x2,&y2);
		for(int j=x;j<=x2;j++){
			for(int k=y;k<=y2;k++){
				lake[j][k]=1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(lake[i][j]==1)continue;
			for(int k=0;k<=3;k++){
				int px=i+tox[k],py=j+toy[k];
				if(lake[px][py]==1&&lake[i][j]==0){
					lake[i][j]=2;
					break;
				}
			}
		}
	}
	for(int i=1;i<=R;i++){
		int tt,x,y;
		scanf("%d%d%d",&tt,&x,&y);
		grow[x][y]=tt;//出生
		if(lake[x][y]==0)die[x][y]=tt+tim; //旱地树死期
		if(lake[x][y]==2)die[x][y]=inf;//湿地树死期
		bfs(x,y);
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(die[i][j]==inf)ans++;//统计永生树
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Aventurine_stone (赞：2)

## 1. 题目分析
我是用 bfs 做的这道题。  
首先我们每种下一颗树，就可以考虑对其 bfs，搜索出因为它种下而新长出的所有树，最后统计答案。  
这样做会被卡超时，我们可以在它的基础上进行优化。
## 2. 题目做法
既然跑多遍 bfs 会超时，为什么我们不能让每个点只遍历一遍呢。由于 $t$ 单调不降，我们就不用对其排序了，我们将数一个一个插进去，用 $a$ 数组记录这个位置树生成的时间，若当前搜索到的时间等于了我们要种的一些树的种下时间，且这些树还未插入队列，则将它们插入队列。因为是按照时间先后搜索的，所以每个点最多被搜一次，$O(nm)$ 的时间复杂度完全可过。  
求出了每个树的生成时间，我们知道在湖边的树和相邻的两颗且时间差小于等于 $k$ 的树是必定存活的。那么我们将所有必定存活的树先入队，进行 bfs，若一颗可能存活的树与一颗必定存活的树相邻，且这棵树生成的时间晚于这颗必定存活的树，那么这棵树必定存活，否则必定不存活。这次 bfs 同样也是 $O(nm)$ 的时间复杂度。  
接下来直接统计答案即可。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3010,M=100010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int n,m,q,r,k;
int a[N][N];
bool w[N][N];
int sx[4]={1,-1,0,0},sy[4]={0,0,1,-1};
#define can(x,y) ((x&&y&&x<=n&&y<=m)&&(!w[x][y]&&!a[x][y])&&(w[x+1][y]||w[x-1][y]||w[x][y+1]||w[x][y-1]))
struct PT{
	int t,x,y;
}tr[M];
int cnt;
typedef pair<int,int> P;
void bfs()
{
	queue<P>d;
	d.push({tr[cnt].x,tr[cnt].y});
	a[tr[cnt].x][tr[cnt].y]=tr[cnt].t;
	cnt++;
	while(!d.empty())
	{
		int x=d.front().first,y=d.front().second;
		d.pop();
		while(cnt<=r&&tr[cnt].t==a[x][y])
			a[tr[cnt].x][tr[cnt].y]=tr[cnt].t,d.push({tr[cnt].x,tr[cnt].y}),cnt++;
		for(int i=0;i<4;i++)
		{
			int xx=x+sx[i],yy=y+sy[i];
			if(can(xx,yy))
			{
				d.push({xx,yy});
				a[xx][yy]=a[x][y]+1;
			}
		}
	}
}
void bfs2()
{
	queue<P>d;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(w[i][j])
				d.push({i,j});
	while(!d.empty())
	{
		int x=d.front().first,y=d.front().second;
		d.pop();
		for(int i=0;i<4;i++)
		{
			int xx=x+sx[i],yy=y+sy[i];
			if(xx&&yy&&xx<=n&&yy<=m&&!w[xx][yy]&&a[xx][yy]>a[x][y])
				d.push({xx,yy}),w[xx][yy]=1;
		}
	}
}
int sum;
int main()
{
	n=read(),m=read(),q=read(),r=read(),k=read();
	while(q--)
	{
		int a1=read(),b1=read(),a2=read(),b2=read();
		for(int i=a1;i<=a2;i++)
			for(int j=b1;j<=b2;j++)
				w[i][j]=1;
	}
	for(int i=1;i<=r;i++)
		tr[i]={read(),read(),read()};
	cnt=1;
	while(cnt<=r)
		bfs();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j])
			{ 
				if((a[i+1][j]&&abs(a[i+1][j]-a[i][j])<=k)||(a[i-1][j]&&abs(a[i-1][j]-a[i][j])<=k)||(a[i][j+1]&&abs(a[i][j+1]-a[i][j])<=k)||(a[i][j-1]&&abs(a[i][j-1]-a[i][j])<=k))
					w[i][j]=1;
			}
	bfs2();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]&&w[i][j])
				sum++;
	printf("%d",sum);
	return 0;
}
```

---

## 作者：not_so_littlekayen (赞：2)

我个人认为这是一道非常好的**深度优先搜索**的练习题。

如果不知道深度优先搜索是什么的请左转百度。

标记湖泊以及求一棵树向周围生长的范围都很好实现，接下来我要介绍的是：如何判断树死亡？

很明显，只要不是一开始种下的树都不会死亡，所以我们只考虑**一开始种下的树**。而且，可以知道的是，只有**不会向周围生长的树**才有可能死亡。于是我们存下所以可能死亡的树，并将树种下或长出的时间记录下来，在深度优先搜索完之后，我们判断树是否死亡。

这一部分的代码如下：


```cpp
#define rep(i, a, b) for(register int i = a;i <= b;i++)
rep(i, 1, r)
{
		int ti, x, y;
		cin >> ti >> x >> y;
		t[x][y] = ti;
		//记录树种下的时间
		a[x][y] = 2;
		if(!check_lake(x, y))
			sx[++snum] = x,
			sy[snum] = y;
		//这棵树可能会消失 
		dfs(x, y);
}
rep(j, 1, snum)
{
		int x = sx[j], y = sy[j];
		bool flag = 0;
		rep(i, 0, 3)
		{
			int nx = x+dx[i], ny = y+dy[i];
			if(a[nx][ny] == 2&&t[nx][ny]-t[x][y] <= k)
			{
				flag = 1;
				break;
			}
		}
		if(!flag)a[x][y] = 0;
}
```

全部代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, b) for(register int i = a;i <= b;i++)
#define int long long
#define Max 3005
const int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
int a[Max][Max], n, m, q, r, k, ans;
int t[Max][Max];//标记树种下或长出的时间
int sx[100005], sy[100005], snum;//可能会消失的树 
bool check_lake(int x, int y)//周围是否存在湖泊 
{
	rep(i, 0, 3)
	{
		int nx = x+dx[i], ny = y+dy[i];
		if(a[nx][ny] == 1)return 1;
	}
	return 0;
}
void dfs(int x, int y)
{
	rep(i, 0, 3)
	{
		int nx = x+dx[i], ny = y+dy[i];
		if(nx >= 1&&nx <= n&&ny >= 1&&ny <= m)
			if(check_lake(nx, ny)&&!a[nx][ny])
			{
				a[nx][ny] = 2;
				t[nx][ny] = t[x][y]+1;
				dfs(nx, ny);
			}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n >> m >> q >> r >> k;
	rep(i, 1, q)
	{
		int lx, ly, rx, ry;
		cin >> lx >> ly >> rx >> ry;
		rep(col, lx, rx)
			rep(row, ly, ry)
				a[col][row] = 1;
		//标记湖泊
	}
	rep(i, 1, r)
	{
		int ti, x, y;
		cin >> ti >> x >> y;
		t[x][y] = ti;
		//记录树种下的时间
		a[x][y] = 2;
		if(!check_lake(x, y))
			sx[++snum] = x,
			sy[snum] = y;
		//这棵树可能会消失 
		dfs(x, y);
	}
	rep(j, 1, snum)
	{
		int x = sx[j], y = sy[j];
		bool flag = 0;
		rep(i, 0, 3)
		{
			int nx = x+dx[i], ny = y+dy[i];
			if(a[nx][ny] == 2&&t[nx][ny]-t[x][y] <= k)
			{
				flag = 1;
				break;
			}
		}
		if(!flag)a[x][y] = 0;
	}
	rep(i, 1, n)
		rep(j, 1, m)
			if(a[i][j] == 2)ans++;
	cout << ans;
	return 0;
}
```

---

## 作者：zzy0618 (赞：2)

不得不说挺麻烦的一个题目。

最终存活的树有两类，一类是在湖旁边树，一类是在团在一起的树。湖旁边的会生长，甚至会影响到不靠近湖的树，就很麻烦。

考虑转化。

我们可以求出每一个在湖旁边长出来的树的出生时间，而湖相当于一个最先被种出来的树。长在湖旁边的树相当于连接上了湖这样一棵永远不会死亡的树。

所以可以将长在湖旁边的树看做一种操作，这样就转化成了一种操作。

具体的，我们将树分为孤立存在与团体存在两种，所有的湖都看做团体存在。团体存在的一定不会死，孤立存在的树在存活期间如果旁边有树那么他们都变为团体存在。最终统计有多少团体存在的树即可。

特别的，在处理湖旁边的树时，我们会使用 bfs。为了保证复杂度，我们要保证队列中的数值（即长出来的时间）不下降，所以我使用了双端队列维护。

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define mk make_pair
#define fi first
#define se second
using namespace std;
const int N=3005,M=2e6+5;
const int bx[]={1,-1,0,0},by[]={0,0,1,-1};
int n,m,q,r,k,ans;
int a[N][N],wd[N][N];
//wd 为是否永远不会死亡 
bool check(int x,int y){
	if(a[x][y-1]==-1||a[x][y+1]==-1||
		a[x-1][y]==-1||a[x+1][y]==-1)return 1;
	return 0;
}struct upd{int t,x,y;}b[M];
void bfs(){
	int j=2;
	deque<pii> q;q.push_back(mk(b[1].x,b[1].y));
	while(q.size()){
		int x=q.front().fi,y=q.front().se;
		while(j<=r&&b[j].t<=a[x][y])
			q.push_front(mk(b[j].x,b[j].y)),++j;
		x=q.front().fi,y=q.front().se;q.pop_front();
		for(int i=0;i<4;++i){
			int nx=x+bx[i],ny=y+by[i];
			if(nx<1||ny<1||nx>n||ny>m)continue;
			if(a[nx][ny]==-1)continue;
			if(check(nx,ny)){
				if(!a[nx][ny]||a[x][y]+1<a[nx][ny]){
					a[nx][ny]=a[x][y]+1;
					q.push_back(mk(nx,ny));					
				}
			}
		}if(q.empty()&&j<=r)
			q.push_front(mk(b[j].x,b[j].y)),++j;
	}
}inline bool cmp(upd a,upd b){
	return a.t<b.t;
}signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>q>>r>>k;
	for(int t=1,x,y,X,Y;t<=q;++t){
		cin>>x>>y>>X>>Y;
		for(int i=x;i<=X;++i)
			for(int j=y;j<=Y;++j)
				a[i][j]=-1,wd[i][j]=1;
	}for(int i=1;i<=r;++i){
		cin>>b[i].t>>b[i].x>>b[i].y;
		a[b[i].x][b[i].y]=b[i].t;
	}bfs();r=0;//先对原操作处理 
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j)
			if(a[i][j]>0)b[++r]=(upd){a[i][j],i,j},a[i][j]=0;
	}sort(b+1,b+r+1,cmp);
	for(int i=1;i<=r;++i){
		int x=b[i].x,y=b[i].y;a[x][y]=b[i].t;
		for(int t=0;t<4;++t){
			int nx=x+bx[t],ny=y+by[t];
			if(!a[nx][ny])continue;
			if(wd[nx][ny])wd[x][y]=1;
			else if(abs(a[x][y]-a[nx][ny])<=k)wd[x][y]=wd[nx][ny]=1;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j)
			if(a[i][j]>0&&wd[i][j])
				++ans;
	}cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：yty2010 (赞：1)

### 前言
这道题我认为我的做法偏向于官方题解的第二种，官方题解详见梦熊用户群。
## 正文
通过读题，可以发现这些信息：

1. 一棵能自己生长的树与前 1 秒的情况有关，而一棵人工种下的树是否死亡与第 $t_i+k$ 秒有关（也就是说一棵在第 $t_i+k$ 秒长出或种下的树也会对这棵树造成影响）。

2. 如果种下的一棵树离湖有两格距离，或者它就在湖边，则这棵树一定能活下来（因为这棵树的种下能使湖边长出其他树，由此让这棵树不会孤独而死）。

3. 我们命名确定能活着的树为定树，不确定能否活着的树为不定树（不定树一定是种下的树）。则如果一棵树种在了一棵不定树旁边，那么这两棵树都为定树。

4. 在第二条的基础上，我们标记在湖边的点，对于一棵树，与之相邻的被标记的点也一定会长出树（而且是定树），这里可以 dfs 处理。

注意：一棵种在湖边的树使得湖边的树进行的蔓延不会对其他不定树产生影响，因此想让一棵不定树（指不在湖边或离湖2格）变成定树只能在它旁边种树，所以时间仅仅与在某棵不定树的死亡时间前是否在它旁边又种了一棵树有关，与 dfs 无关。

那么我们可以用一个数组记录每个点的情况：$map_{i,j}=1/2/3/4$ 分别表示湖 / 定树 / 不定树 / 在湖边的点，然后对于每次的输入，按上述操作就好了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int mp[3005][3005],n,m,q,r,k,ans;
struct node
{
	int l,r,t;
}t[100005];  //突然发现输入用数组没必要
queue<node>que; //用于记录种下时自己无法成活的树的死亡时间
bool check(int l,int r)
{
	 if(mp[l+1][r]!=0||mp[l-1][r]!=0||mp[l][r+1]!=0||mp[l][r-1]!=0)
	 	return 1;
	 return 0;
}
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
void dfs(int x,int y)
{
  if(mp[x][y]!=2)
    ans++;
	mp[x][y]=2; //只有确定下来的树才需要记录答案
	for(int i=0;i<4;i++)
	{
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(mp[xx][yy]==3||mp[xx][yy]==4)  //蔓延
			dfs(xx,yy);
	}
}
signed main(){
//	freopen("lake6.in","r",stdin);
//	freopen("lake.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>q>>r>>k;
	for(int i=1;i<=q;i++)
	{
		int sx,sy,xx,xy;
		cin>>sx>>sy>>xx>>xy;
		for(int l=sx;l<=xx;l++)
			for(int r=sy;r<=xy;r++)  //标记湖，总时间O(nm)
				mp[l][r]=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(mp[i][j]==1)
				continue;
			if(mp[i-1][j]==1||mp[i+1][j]==1||mp[i][j-1]==1||mp[i][j+1]==1)   //标记在湖边的点
				mp[i][j]=4;
		}
	}
	for(int i=1;i<=r;i++)
		cin>>t[i].t>>t[i].l>>t[i].r;
	int i=1;
	while(i<=r)
	{
		while(!que.empty()&&que.front().t<t[i].t)  //如果有种下的树到了死亡时间
		{
			if(mp[que.front().l][que.front().r]==3) //如果仍旧是不定树
			{
				mp[que.front().l][que.front().r]=0;
			}
			que.pop();
		}
		bool flag=check(t[i].l,t[i].r);  //判断能否成为不定树
		if(flag==1)
		{
			 dfs(t[i].l,t[i].r);  //蔓延（包括湖边蔓延，将相邻的不定树变成定树）
		}
		else
		{
			mp[t[i].l][t[i].r]=3;
			t[i].t+=k;
			que.push(t[i]);
		}
		i++;
	}
	cout<<ans<<endl;
}
```
~~但是赛后我把代码给我朋友，被我朋友转载到梦熊用户群里了qwq~~

dfs 时最坏时间为搜了整张图，队列里每个点最多经过一次，所以时间复杂度是 $O(nm+r)$。

---

## 作者：andycode (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11215)

[或许更好的阅读体验](https://blog.csdn.net/andycode_/article/details/143147880)
# 思路讲解
我们用一个结构体 `struct` 存储每一个格子的状态，`tp` 表示格子的类型，`t` 表示如果该格子种过树，种树的最近时间，`die` 表示如果该格子有树，这棵树会不会永远都不会死亡。
```cpp
struct block{
	int tp,t;//0为空地，1为湖泊，2为种过树
	bool die;
}g[3003][3003];
```
首先我们要将每个是湖泊的格子的状态设为 $1$，容易想到用二维差分解决。

然后我们定义一个 `bool` 类型的二维数组 `nl`，表示该格子是否接近湖泊，方便我们决定它长出树后会不会永远不死。

对于每一次种树操作，我们进行 `bfs` 搜索，
+ 如果搜到一颗树，设这棵树被种下的时间为 $x$，如果这棵树在 $t_i$ 这个时间有没有死亡，即 $x+k\ge t_i$，或者这棵树本身就被标记为不死，则说明这相邻的两个树，永远都不会死亡。所以将它们标记为永远不死，并将该树的位置加入搜索的队列。

+ 如果搜到一块没有树且与湖泊相邻的陆地，则在这里长出一颗新的树，并将其标记为不死，因为它与湖泊相邻。并将搜到它的那棵树也标记为不死，因为它与一个不会死亡的树相邻，最后将搜到的树加入队列。

+ 否则不进行任何操作。

答案为所有不会死的树的数量。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
struct block{
	int tp,t;
	bool die;
}g[3003][3003];
int di[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
int n,m,q,r,k,cf[3003][3003],sum[3003][3003],ans;
bool nl[3003][3003];
void bfs(int t,int sx,int sy){
	queue<int> x,y;
	x.push(sx),y.push(sy);
	while(x.size()){
		int fx=x.front(),fy=y.front();
		x.pop(),y.pop();
		for(int i=0;i<4;i++){
			int xx=fx+di[i][0],yy=fy+di[i][1];
			if(xx>0 && yy>0 && xx<=n && yy<=m && g[xx][yy].tp!=1){
				if(g[xx][yy].tp==2){
					if(g[xx][yy].t+k>=t){
						if(g[xx][yy].die==false)
							g[xx][yy].die=1,ans++,x.push(xx),y.push(yy);
						if(g[fx][fy].die==false)
							g[fx][fy].die=1,ans++;
					}
					if(g[xx][yy].die)
						if(g[fx][fy].die==false)
							g[fx][fy].die=1,ans++;
				}else if(nl[xx][yy]){
					g[xx][yy]={2,0,1};
					ans++;
					if(g[fx][fy].die==false)
						g[fx][fy].die=1,ans++;
					x.push(xx),y.push(yy);
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d%d%d",&n,&m,&q,&r,&k);
	for(int i=0;i<q;i++){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		cf[a][b]++,cf[a][d+1]--,cf[c+1][b]--,cf[c+1][d+1]++; //差分
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			sum[i][j]=cf[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];//统计前缀和
			if(sum[i][j])
				nl[i-1][j]=nl[i+1][j]=nl[i][j-1]=nl[i][j+1]=1;//如果该位置为湖泊，则设置和它相邻的所有nl为true
			g[i][j]={sum[i][j],0,false};
            //初始化
		}
	for(int i=0;i<r;i++){
		int t,x,y;
		scanf("%d%d%d",&t,&x,&y);
		g[x][y]={2,t,nl[x][y]};
		ans+=nl[x][y];
        //如果该位置与湖泊相邻，则将其标记为不死
		bfs(t,x,y);
	}
	printf("%d",ans);
	return 0;
}
```
完结撒花！

---

## 作者：2c_s (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11215)

## 思路

本题掌握几个性质之后很好解决。

**性质一**：如果一棵树种在了湖边或者与湖只隔一格的地方，肯定可以留到最后。

>种在湖边，按照题意会**不断扩展**，树木不会死亡。种在与湖只隔一格的地方，在临死时湖边会生长出树，同样**不断扩展**，不会死亡。

**性质二**：如果两棵树相邻（都不在性质一范围内），并且种植时间相差不超过 $k$，肯定可以留到最后。

>直接按照题意即可解释。
>>如果一棵树在存活大于 $k$ 秒后（以其被种下或生长出来时开始计算），与其相邻的所有位置均为无树存活的陆地，则它会死亡。

我们考虑先把湖、湖边预处理出来，然后种树时直接判断。如果**可以扩展**，进行广搜，种植“永久树木”。

如果不在上述的两条性质中，那么保存在临时变量里，每次统计。如果某棵树存在时间超过 $k$，删除这个临时变量即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define pf push_front
#define pob pop_back
#define pof pop_front
#define pii pair<int,int>
#define pil pair<int,ll>
#define pli pair<ll,int>
#define pll pair<ll,ll>
#define fi first
#define se second
#define lb lower_bound
#define ub upper_bound
using namespace std;
signed solution();
signed main(){solution();system("pause");return 0;}
ll read(){
	ll k=0;bool flag=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')flag=0;c=getchar();}
	while(isdigit(c)){k=(k<<1)+(k<<3)+(c^48);c=getchar();}
	if(flag)return k;return -k;
}
const int N=3010;
int n,m,Q,r,k,mp[N][N];
bool mk[N][N],vis[N][N],lake[N][N],tmp[N][N];
//mk 湖边，vis 标点，lake 湖，tmp 临时树，mp 永久树。
const int dx[]={1,-1,0,0};
const int dy[]={0,0,1,-1};
multiset<pair<int,pii>>st;
queue<pii>q;
bool next_mk(int x,int y){return mk[x-1][y]|mk[x+1][y]|mk[x][y-1]|mk[x][y+1];}
void plant_mk(int x,int y){
	q.push({x,y});
	vis[x][y]=1;
	while(q.size()){
		auto now=q.front();
		q.pop();
		mp[now.fi][now.se]=1;
		for(int i=0;i<4;++i){
			int nx=now.fi+dx[i],ny=now.se+dy[i];
			if(nx<1||nx>n||ny<1||ny>m||!mk[nx][ny]||mp[nx][ny]||vis[nx][ny])continue;
			vis[nx][ny]=1;
			q.push({nx,ny});
		}
	}
	return ;
}
bool next_tree(int x,int y){return tmp[x-1][y]|tmp[x+1][y]|tmp[x][y-1]|tmp[x][y+1]|mp[x-1][y]|mp[x+1][y]|mp[x][y-1]|mp[x][y+1];}
void plant_land(int x,int y){
	q.push({x,y});
	while(q.size()){
		auto now=q.front();
		q.pop();
		mp[now.fi][now.se]=1;
		for(int i=0;i<4;++i){
			int nx=now.fi+dx[i],ny=now.se+dy[i];
			if(nx<1||nx>n||ny<1||ny>m||!tmp[nx][ny]||mp[nx][ny])continue;
			q.push({nx,ny});
			tmp[nx][ny]=0;
		}
	}
	return ;
}
signed solution(){
	cin>>n>>m>>Q>>r>>k;
	while(Q--){
		int x=read(),y=read(),xx=read(),yy=read();
		for(int i=x;i<=xx;++i){
			for(int j=y;j<=yy;++j)lake[i][j]=1;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(lake[i][j]){
				if(!lake[i-1][j])mk[i-1][j]=1;
				if(!lake[i+1][j])mk[i+1][j]=1;
				if(!lake[i][j-1])mk[i][j-1]=1;
				if(!lake[i][j+1])mk[i][j+1]=1;
			}
		}
	}
	memset(vis,0,sizeof vis);
	for(int i=1;i<=r;++i){
		int t=read(),x=read(),y=read();
		auto it=st.begin();
		while(st.size()&&t-(*it).fi>k){
			tmp[(*it).se.fi][(*it).se.se]=0;
			st.erase(it);
			it=st.begin();
		}
		if(mp[x][y])continue;
		if(mk[x][y]||next_mk(x,y)){
			if(!vis[x][y])plant_mk(x,y);//性质 1.
			plant_land(x,y);//性质 2.
		}
		else if(next_tree(x,y))plant_land(x,y);//性质 2.
		else{
			tmp[x][y]=1;
			st.insert({t,{x,y}});
		}
	}
	int ans=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j)ans+=mp[i][j];
	}
	cout<<ans<<"\n";
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/183473860)

---


# 【MX-S5-T1】王国边缘

## 题目背景

原题链接：<https://oier.team/problems/S5A>。

---

> 纷飞白雪零碎了异客的心，在无数的高山外，故人是否还在记忆的流水中，细嗅往年往月的百花？
> 
> 只是他们在旧地的怀抱中，但有一个人却在海的那一端，潸然泪下……
> 
> 人都有归属，只是某些人看不到罢了……

**约定记号 $S^c$ 表示字符串 $S$ 循环 $c$ 次拼接而成的字符串。特别地，若 $c = \infty$，则表示字符串 $S$ 无限循环拼接而成的字符串。**

## 题目描述

异客在一个无限循环的 $\texttt{01}$ 字符串 $T=S^\infty$ 上进行着他的旅程，其中 $S$ 的长度为 $n$，$T$ 的第 $i$ 个字符为 $T_i$。

异客的视野有限，只能看到后面 $m$ 个字符。

异客会进行 $q$ 次旅程，每次起点不同，移动次数也不同。

当异客在 $T_i$ 上时：

- 若 $T_{i+1\dots i+m}$ 中存在 $\texttt{1}$，则异客下一次会移动到其中最远的一个 $\texttt{1}$ 上。
- 否则，异客下一次会移动到下一个字符 $T_{i+1}$ 上。

你需要告诉异客，他会在哪里停下。由于答案会很大，你只需要告诉他对 $10^9+7$ 取模后的结果。



## 说明/提示

**【样例解释 #1】**

$T$ 的前 $16$ 位为 $\texttt{1000101110001011}$。

第一次询问，位置移动为 $1 \to 2 \to 5$。

第二次询问，位置移动为 $4 \to 7 \to 9 \to 10$。

**【样例 #2】**

见附件中的 `kingdom/kingdom2.in` 与 `kingdom/kingdom2.ans`。

**【样例 #3】**

见附件中的 `kingdom/kingdom3.in` 与 `kingdom/kingdom3.ans`。

该组样例满足测试点 $5$ 的约束条件。

**【样例 #4】**

见附件中的 `kingdom/kingdom4.in` 与 `kingdom/kingdom4.ans`。

该组样例满足测试点 $9\sim 10$ 的约束条件。

**【样例 #5】**

见附件中的 `kingdom/kingdom5.in` 与 `kingdom/kingdom5.ans`。

该组样例满足测试点 $18\sim 20$ 的约束条件。

**【数据范围】**

对于所有测试数据，保证：$1 \le n \le 2 \times 10^{5}$，$1 \le m \le 10^{18}$，$1 \le q \le 2 \times 10^5$，$1 \le s \le 10^{18}$，$0 \le k \le 10^{18}$。

|  测试点编号  |    $n \le$     |  $m \le$  |    $q \le$     |  $s \le$  |    $k \le$     |    特殊性质    |
| :----------: | :------------: | :-------: | :------------: | :-------: | :------------: | :------------: |
|     $1$      | $2\times 10^5$ |  $10^9$   | $2\times 10^5$ |  $10^9$   |      $0$       |       无       |
|     $2$      | $2\times 10^5$ | $10^{18}$ | $2\times 10^5$ | $10^{18}$ |      $0$       |       无       |
|  $3\sim 4$   | $2\times 10^5$ |  $10^9$   | $2\times 10^5$ |  $10^9$   |     $10^9$     | $S$ 为 $\texttt{0}^n$ 或 $\texttt{1}^n$ |
|     $5$      | $2\times 10^5$ | $10^{18}$ | $2\times 10^5$ | $10^{18}$ |   $10^{18}$    | $S$ 为 $\texttt{0}^n$ 或 $\texttt{1}^n$ |
|  $6\sim 8$   |     $10^2$     |   $ n $   |     $10^2$     |    $n$    |     $10^2$     |       无       |
|  $9\sim 10$  | $3\times 10^3$ |   $ n $   | $3\times 10^3$ |    $n$    | $3\times 10^3$ |       无       |
| $11\sim 12$  | $2\times 10^5$ |    $n$    | $2\times 10^5$ |    $n$    |      $1$       |       无       |
| $13\sim 14$  | $2\times 10^5$ | $10^{18}$ | $2\times 10^5$ | $10^{18}$ |      $1$       |       无       |
| $15\sim 17$  | $2\times 10^5$ |  $10^9$   | $2\times 10^5$ |  $10^9$   |     $10^9$     |       无       |
| $18 \sim 20$ | $2\times 10^5$ | $10^{18}$ | $2\times 10^5$ | $10^{18}$ |   $10^{18}$    |       无       |







## 样例 #1

### 输入

```
8 3 2
10001011
1 2
4 3```

### 输出

```
5
10```

# 题解

## 作者：Ratio_Y (赞：35)

是题解区目前唯一的 $\mathcal{O(n)}$ 做法！


---

## 思路

我们先不管扩展后的串，考虑只将字符在原串中的位置连边，容易发现形成了一个内向基环树森林。而我们要求的，就是求出给定的点在树上走 $k$ 条边后路径的总长加上原来下标对 $10^9+7$ 取模的值。

先考虑一个点如果最后会落在环上怎么做。我们可以提前 $\mathcal{O(n)}$ 处理出每个环外点到环的距离和步数，以及连向环的哪个点；同时环的大小、长度也是可以处理出来的。这样我们就可以将原来的跳跃轨迹砍成三段：走到环 $\rightarrow$ 走完整环 $\rightarrow$ 走部分环。前两段求法比较平凡，对于最后一段，我们可以在环上断边处理出出前缀和，同样可以实现 $\mathcal{O(1)}$ 查询。

再考虑如果没走到环上怎么办。如果依然倍增处理到环距离那么和 $\mathcal{O(n\log n)}$ 的做法相比就没有优势了，因此我们考虑另一种处理到 $k$ 级祖先距离的方法：离线后将询问挂在点上做。实现上，我们反向建一棵外向基环树，从环上点向外 dfs，此时每个深度一定只对应一个点，容易根据当前点的深度差分求出其到 $k$ 级祖先的距离。

那么就做完了！理论复杂度 $\mathcal{O(n)}$，可能带有较大的常数。

[8.2k 的代码](https://www.luogu.com.cn/paste/48j5dst1)


---

完结撒花~

[Welcome to my blog](https://www.cnblogs.com/Ratio-Yinyue1007)

---

## 作者：Night_sea_64 (赞：20)

以此篇题解纪念我此题赛时挂成 60pts，并且 T2T3 也都挂分了。

首先可以处理出每个点前面（包括自己）最靠近的一个 $1$ 在哪里，用 $last$ 记录。这么做是为了快速找到一个点走一步之后到哪。但是因为它是循环的，所以算这个的时候需要把原序列复制一遍。

现在已经知道每个点走一步之后到哪了，然后发现 $k$ 很大，可以瞬间想到倍增，预处理好每个点走 $2^j$ 步会走多少格。

我是处理了两个数组，一个是这个答案模 $n$ 意义下的，另一个是模 $10^9+7$ 意义下的。这是因为我们既需要知道最终答案，又需要知道它等效于在 $S$ 中哪个位置。

时间复杂度 $O(n\log W)$。$W$ 是值域。细节很多，我调了很久。代码如下：

```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,m,q,a[400010],last[400010];
int d1[200010][70],d2[200010][70];
signed main()
{
    scanf("%lld%lld%lld",&n,&m,&q);
    for(int i=1;i<=n;i++)
    {
        char c;
        cin>>c;
        a[i]=a[i+n]=c-'0';
    }
    for(int i=1;i<=2*n;i++)
    {
        if(a[i]==1)last[i]=i;
        else last[i]=last[i-1];
    }
    for(int i=1;i<=n;i++)
        if(m<n)
        {
            if(last[i+m]<=i)d1[i][0]=d2[i][0]=1;
            else d1[i][0]=d2[i][0]=last[i+m]-i;
        }
        else
        {
            if(!last[n])d1[i][0]=1%n,d2[i][0]=1;
            else
            {
                int r=n+(i+m-1)%n+1;
                d1[i][0]=(m-r+last[r])%n,d2[i][0]=(m-r+last[r])%mod;
            }
        }
    for(int j=1;j<=61;j++)
        for(int i=1;i<=n;i++)
        {
            int nxt=(i+d1[i][j-1]-1)%n+1;
            d1[i][j]=(d1[i][j-1]+d1[nxt][j-1])%n;
            d2[i][j]=(d2[i][j-1]+d2[nxt][j-1])%mod;
        }
    while(q--)
    {
        int ss,k;
        scanf("%lld%lld",&ss,&k);
        int now=(ss-1)%n+1,ans=ss%mod;
        for(int i=61;i>=0;i--)
            if(k>=(1ll<<i))
            {
                k-=(1ll<<i);
                ans=(ans+d2[now][i])%mod;
                now=(now+d1[now][i]-1)%n+1;
            }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：__Luna__ (赞：16)

## 朴素算法

**本题的暴力思路是模拟**。模拟的一个问题是，在模拟过程中取模会破坏模拟结果的正确性，因此我们要避免取模。

**注意到使用 `__int128` 可以做到完整地存下答案而不会溢出**。如果用 `__int128` 存储答案，我们只需要在输出前做一次取模。这个技巧同样也应用在了之后的第一、二级优化方法中。

直接暴力模拟的复杂度 $O(qkm)$，显然是不够的。

## 优化

### 第一级优化
**依然使用模拟，考虑用预处理进行优化**。通过以下代码，读入 $S$ 时可以直接预处理出 $S$ 的每一个位置前（包括本身）最近的 `'1'` 的位置：

```cpp
long long l=-m; //记录前一个 `1` 的位置。
for(int i=0;i<n;i++)
{
    char c;
    cin>>c;
    if(c=='1')S[i]=i,l=i; //当前位置就是 `1`。
    else S[i]=l;
}
if(l!=-m)for(int i=0;i<n&&S[i]==-m;i++)S[i]=l-n; //这一句很重要！可以说就是它为避免分讨创造了可能。
```
我们直接将预处理结果代替原字符串存储在 `S[i]` 中。注意，对于处于字符串开头的 `'0'`，其之前最近的 `'1'` 位于前一个字符串的末尾，我们需要记录这个 `'1'`，但是要将它的位置减去 `n` 以体现**相对位置**。

特殊地，如果字符串全 `'0'`，`S[i]` 会被赋值成 $-m$。这么做的原因**请参考下面计算移动量时的代码**进行理解。

得到了预处理数组 `S[i]` 后，我们可以这么计算在 $T$  中从 $i$ 位置移动 $1$ 次到达的位置（不需要分讨）：

```cpp
max(i+m-(i+m)%k+S[(i+m)%k],(long long)(i+1));
```

在这里，我们找到 $T$ 中 $i+m$ 位置前最近的 `'1'` 的相对位置，并加上 $i+m$ 前完整的 $S$ 的数目以转换为**绝对位置**。移动后的下一个位置即为该位置和 $i+1$  中的较大值（最近的 $1$ 可能在 $i+1$  之前，我们需要舍去，当然，`S[i]` 为 $-m$ 时也会舍去）。

请注意此处的 $i$ 下标从 $0$ 开始，而输入中的起点位置是从 $1$ 开始的，输入输出时分别需要加上偏移。

经过优化，当前算法的复杂度为 $O(qk)$，可得 [$55$ 分](https://www.luogu.com.cn/record/187722732)。

### 第二级优化

如何进一步优化？$O(qk)$ 已经是模拟的极限了，为了更好的复杂度，我们需要舍弃模拟法。

**让我们使用一下倍增的思想**。依然是预处理，我们在处理出 `S[i]` 的基础上再处理一个数组 `t[i][j]`，表示从 $T$ 中 $j$ 位置移动 $2^i$ 步到达的位置。这里的 $j$ 只需要处理到 $n-1$ 即可，之后的位置可以通过相对位置的方法计算。

`t[0][j]` 的计算是很容易的，我们再第一级优化中就已经提供了单次 $O(1)$，共 $O(n)$ 的计算方法：

```cpp
for(int j=0;j<n;j++)
{
    int k=(j+m)%n; //减少取模运算。
    t[0][j]=max(j+m-k+S[k],(long long)(j+1));
}
```

从 `t[1][j]` 开始，可以通过连续进行两次 `t[i-1][j]` 移动的方式计算 `t[i][j]` ：

```cpp
for(int i=1;i<60;i++)
{
    for(int j=0;j<n;j++)
    {
        int k=t[i-1][j]%n;
        t[i][j]=t[i-1][k]-k+t[i-1][j];
    }
}
```

一共需要处理到 $i=59$（参考数据：$\log_210^{18}\approx59.79470575$）。

最终位置可以根据倍增数组以 $O(\log n)$ 的复杂度求出：

```cpp
for(int i=0;k;k>>=1,i++)
{
    if(k&1) //位运算将 k 分解为 2 的幂次
    {
        int tt=s%n;
        s=t[i][tt]+s-tt;
    }
}
```

分析时间复杂度。预处理 $O(n+n\log k)=O(n\log k)$，求解询问 $O(q\log k)$，总复杂度 $O((n+q)\log k)$，是可以接受的。

再分析空间。倍增法依旧会受取模而影响正确性，为了避免计算过程中的取模，我们可以将 `t[i][j]` 开成 `__int128`，需要的最大空间为 $2\times10^5\cdot 60\cdot128~\rm bit=192000000~B=183.10546875~MB$，在内存限制允许的范围内。

做到这里已经足够 AC 本题了。

### 第三级优化

赛时我是用 `__int128` 存储答案的，故前面三个思路中我都用到 `__int128` 来解决求解过程中取模造成的答案正确性问题。

其实在倍增法中 `__int128` 是完全可以避免的，避免了 `__int128` 的运算可以一定程度上减小常数。而且，使用 `__int128` 也有一定的投机取巧成分。

`long long` 是无法存下完整的答案的，所以我们需要在计算过程中就进行对 $10^9+7$ 的取模。然而我们发现倍增过程中存在模 $n$ 的操作，**为了防止 $10^9+7$ 和 $n$ 两个模数发生冲突，我们可以将二者分开处理**。

开一个辅助数组 `t2[i][j]`，与 `t[i][j]` 同步更新。不同的是，`t2[i][j]` 模 $n$，而 `t[i][j]` 模 $10^9+7$。所有需要使用模 $n$ 的结果时都改为使用 `t2[i][j]` 即可。

**代码详见 AC 代码部分**。

## AC 代码

赛时上由于某个小小的疏忽，这道题只得了 [$95$ 分](https://www.luogu.com.cn/record/187595833#%E4%BD%A0%E7%9C%8B%E5%87%BA%E6%9D%A5%E5%93%AA%E9%87%8C%E7%96%8F%E5%BF%BD%E4%BA%86%E5%90%97%EF%BC%9F)。

赛后经过调试得到的 AC 代码如下（使用 `__int128`）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
int n,q;
long long S[200005];
__int128 t[60][200005];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	long long m;
	cin>>n>>m>>q;
	long long l=-m;
	for(int i=0;i<n;i++)
	{
		char c;
		cin>>c;
		if(c=='1')S[i]=i,l=i;
		else S[i]=l;
	}
	if(l!=-m)for(int i=0;i<n&&S[i]==-m;i++)S[i]=l-n;
	for(int j=0;j<n;j++)
	{
		int k=(j+m)%n;
		t[0][j]=max(j+m-k+S[k],(long long)(j+1));
	}
	for(int i=1;i<60;i++)
	{
		for(int j=0;j<n;j++)
		{
			int k=t[i-1][j]%n;
			t[i][j]=t[i-1][k]-k+t[i-1][j];
		}
	}
	while(q--)
	{
		long long s1,k;
		cin>>s1>>k;
		__int128 s=s1-1;
		for(int i=0;k;k>>=1,i++)
		{
			if(k&1)
			{
				int tt=s%n;
				s=t[i][tt]+s-tt;
			}
		}
		cout<<(long long)((s+1)%mod)<<endl;
	}
}
```

另附不用 `__int128` 的代码，常数比使用 `__int128` 小了一半：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
int n,q;
long long S[200005];
long long t[60][200005];
long long t2[60][200005];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	long long m;
	cin>>n>>m>>q;
	long long l=-m;
	for(int i=0;i<n;i++)
	{
		char c;
		cin>>c;
		if(c=='1')S[i]=i,l=i;
		else S[i]=l;
	}
	if(l!=-m)for(int i=0;i<n&&S[i]==-m;i++)S[i]=l-n;
	for(int j=0;j<n;j++)
	{
		int k=(j+m)%n;
		t[0][j]=max(j+m-k+S[k],(long long)(j+1));
		t2[0][j]=t[0][j]%n;
		t[0][j]%=mod;
	}
	for(int i=1;i<60;i++)
	{
		for(int j=0;j<n;j++)
		{
			int k=t2[i-1][j];
			t2[i][j]=t2[i-1][k];
			t[i][j]=(t[i-1][k]-k+t[i-1][j])%mod;
		}
	}
	while(q--)
	{
		long long s,k,s2;
		cin>>s>>k;
		s-=1;
		s2=s%n;
		for(int i=0;k;k>>=1,i++)
		{
			if(k&1)
			{
				s=(t[i][s2]+s-s2)%mod;
				s2=t2[i][s2];
			}
		}
		cout<<(s+1)%mod<<endl;
	}
}
```

---

## 作者：2huk (赞：9)

为了方便我们从 $0$ 开始下标。

考虑倍增。设 $f(i, j)$ 表示从 $i$ 开始，移动 $2^j$ 次后，实际位置的偏移量。转移：
$$
f(i, j) = f(i,j-1)+f((i+f(i,j-1)) \bmod n, j-1)
$$
考虑 $f(i, 0)$，也就是移动 $1$ 次走的实际步数怎么求。

先令 $g(l, r)$（$0 \le l,r < n$）表示 $[l, r]$ 内最后一个 $1$ 的位置。可以二分+预处理前缀和轻易求解。

分类讨论 $[i+1,i+m]$ 是否跨过至少一次完整的 $S$。

举个例子。$n=4$。那么 $T_{0\sim 3} = T_{4 \sim 7} = T_{8 \sim 11} = \dots = S$。希望求解 $f(2, 0)$。有三种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/lzwfwgmm.png)

- $i+m < n$（即图中 $\color{red}m=1$）：显然 $f(i,0) = g(i+1, n-1)-i$。毕竟你都没走出第一段。

- $n \le i+m < 2n$（即图中 $\color{blue}m=4$）：也就是先走第一段的一段后缀（具体是 $[i+1,n-1]$），再走第二段的一段前缀（具体是 $[0, m-n+i]$）。先看第二段的前缀中是否存在 $1$，有则 $f(i,0)=n-1-i+g(0,m-n+i)$。否则 $f(i, 0) = g(i+1,n-1)-i$，也就是第一种情况。

- $i+m \ge 2n$（即图中 $\color{green} m=11$）：也就是先走第一段的一段后缀（$[i+1,n-1]$），然后走 $\left\lfloor \dfrac{m-n+1+x}n \right\rfloor$ 个完整段，再走下一段的一段前缀（$[0,(x+m) \bmod n]$）。跟第二种情况类似，先判断最后一段的前缀中是否存在 $1$，再判最后一个完整段中是否存在 $1$，再判倒数第二个完整段中是否存在 $1$，以此类推，最后判第一段的前缀中是否存在 $1$。

  注意到每个完整段都是相同的，都是 $S$。所以我们只需要判最后一个完整段即可。~~式子有一坨懒得打了。~~

然后就差不多做完了。细节还是很多的。推荐一道相似的答辩题 AT_abc346_f，也有这么一坨分类讨论。

一个细节：

- $f(i, j)$ 最大是 $km$，会炸 `long long`。有两种方法：一种是直接 `__int128`，但带很多取模常数很大；一种是观察到我们只需要知道 $f(i, j) \bmod n$ 和 $f(i,j) \bmod P$（$P = 10^9 + 7$），所以开两个数组分别维护这两个模数的值。这样甚至 `long long` 都不用开，而且取模可以用减法优化掉，常数很小。

代码：

```cpp
#include "bits/stdc++.h"

using namespace std;

typedef long long ll;

const int N = 2e5 + 10, P = 1e9 + 7;

int n, q;
ll m;
char s[N];
int sum[N];
int st_n[N][63], st_P[N][63];

int mod_n(int a) {
	return a < n ? a : a - n;
}

int mod_P(int a) {
	return a < P ? a : a - P;
}

int calc(const int l, const int r) {
	// 查询 [l, r] 中最后一个 1 的位置。
	int lo = l, hi = r, res = -1;
	while (lo <= hi) {
		const int mid = lo + hi >> 1;
		if (sum[r] - sum[mid - 1]) {
			res = mid;
			lo = mid + 1;
		} else {
			hi = mid - 1;
		}
	}
	return res;
}

ll get(const int x) {
	// 从 x 开始移动一次，位置的偏移量
	if (x + m < n) {
		int res = calc(x + 1, x + m);
		return res == -1 ? 1 : res - x;
	}

	if (x + m >= 2 * n) {
		// 至少经过完整一段
		int res = calc(0, (x + m) % n);
		if (~res) {
			if ((x + m) % n == n - 1) {
				return n - 1 - x + (m - n + 1 + x) / n * n;
			}
			return n - 1 - x + (m - n + 1 + x) / n * n + res + 1;
		}
		res = calc(0, n - 1);
		if (~res) {
			return n - 1 - x + ((m - n + 1 + x) / n - 1) * n + res + 1;
		}
		return 1;
	}
  
	// 一段前缀和一段后缀
	int res = calc(0, m - n + x);
	if (~res) {
		return res + 1 + n - 1 - x;
	}
	res = calc(x + 1, n - 1);
	if (~res) {
		return res - x;
	}
	return 1;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m >> q;

	for (int i = 0; i < n; ++ i ) {
		cin >> s[i];
		sum[i] = sum[i - 1] + s[i] - '0';
	}

	for (int i = 0; i < n; ++ i ) {
		ll t = get(i); 
		st_n[i][0] = t % n;
		st_P[i][0] = t % P;
	}

	for (int j = 1; j < 63; ++ j ) {
		for (int i = 0; i < n; ++ i ) {
			st_n[i][j] = mod_n(st_n[i][j - 1] + st_n[mod_n(i + st_n[i][j - 1])][j - 1]);
			st_P[i][j] = mod_P(st_P[i][j - 1] + st_P[mod_n(i + st_n[i][j - 1])][j - 1]);
		}
	}
  
  while (q -- ) {
		ll s, k;
		cin >> s >> k;
		s -- ;
		int res_n = 0, res_P = 0;
		
		for (int i = 62; ~i; -- i ) {
			if (k >= (1ll << i)) {
				k -= 1ll << i;
				int ans_n = st_n[(s + res_n) % n][i];
				int ans_P = st_P[(s + res_n) % n][i];
				res_n = mod_n(res_n + ans_n);
				res_P = mod_P(res_P + ans_P);
			}
		}
  	
		cout << (s + res_P + 1) % P << '\n';
	}
	
	return 0;
}
```

---

## 作者：SafariMo (赞：7)

来一种简单写法。

首先可以想到倍增。

然后难点在于求一个点之后能看到的最远的个 $1$ 点，用 $f_i$ 表示，如果不存在 $f_i = i$。

首先，$f_0$ 时可以简单 $\mathcal O(n)$ 计算（因为如果后面 $3n$ 个都不是的话就说明看不见 $1$）。

否则判断 $i + m$ 是不是 $1$，如果不是，则 $f_i = f_{i - 1}$。

代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string S;
const int N = 2E5 + 66;
int c[N][63] , p[N][63];
const int P = 1e9 + 7; 
signed main(){
	int n , m , q; 
	cin >> n >> m >> q;
	cin >> S;
	int pre = 0;
	for(int i = 0 ; i < n; ++ i){
		int p = (i + m);
		if(!i){
			//找到第一个。 
			int cnt = 0;
			while(S[p % n] != '1' && p != i){
				-- p;
				cnt ++;
				if(cnt >= 3 * n){
					p = i;
					break;
				}
			}
		}
		else{
			if(S[p % n] != '1'){
				p = pre;
			}
		}
		if(p == i)
			p = i + 1; 
		pre = p;
		:: p[i][0] = p % n;//找到下一个最远的 1
		c[i][0] = (p - i) % P;//走的距离
	//	cout << i << ' ' << p << '\n';	
	}
	for(int i = 1; i <= 62; ++ i){
		for(int j = 0; j < n; ++ j){
			p[j][i] = p[p[j][i - 1]][i - 1];
			c[j][i] = c[j][i - 1] + c[p[j][i - 1]][i - 1];
			c[j][i] %= P;
		}
	}
	while(q --){
		int s , k ;
		cin >> s >> k;
		int cnt = s % P;
		-- s;
		s %= n;
		for(int i = 62; i >= 0; i --){
			if(k >> i & 1){
				cnt += c[s][i];
		//		cout << "T: " << cnt << '\n';
				cnt %= P; 
				s = p[s][i];
			}
		} 
		cout << cnt << '\n';
	}
	return 0;  
}
```

---

## 作者：内拉组里 (赞：4)

一道吸氧优化基础题

# Thoughts :

> 题干中要抓住两个关键信息
>
> 1. 每一步怎么跳
> 2. 循环字符串
>
> 首先对字符串 $ S $ 作一个前缀和 $ p_i $ 方便处理
>
> 如果 $ S $ 中全是`0`，那么每一步都是下一个字符，特判掉デス～
>
> 令当前字符为 $ S_i $，分两种情况讨论
>
> 1. $ i + m \le n $ 
>
>    如果 $ S_i \sim S_{i + m} $ 全部都是 $ 0 $，即 $ p_i = p_{i + m} $ 那么就只能跳到下一个字符上了
>
>    否则可以跳到第一个 $ p_x \ge p_{i + m} $ 的位置 $ x $ 上
>
>    步数即为 $ x - i $ 
>
> 2. $ i + m > n $ 
>
>    即可能跳到下一周期的字符上
>
>    首先判断在最后一个可能跳到的周期判断是否存在`1` ，如果存在则优先跳到那里
>
>    其次判断是否跨越多个周期，如果是那么说明落脚点可能在 $ S $ 中的任意一个字符上，那么找到第一个 $ p_x = p_n $ 的位置 $ x $ 即为答案
>
>    以上情况计算步数用 $ m $ 减去落脚点与最远距离的距离差デス～
>
>    如果仍不符合，那就和 $ i + m \le n $ 部分一样处理 (反正多出来的也没用)
>
> 至此，题意分析完毕

# Optimizations:

> - 倍增优化
>
>   我们记 $ nxt[i][j] $ 为在从 $ S_i $ 开始跳 $ 2^j $ 步走到的字符下标
>
>   再记一个 $ stp[i][j] $ 为相同情况下所能跳动的最远距离
>
>   易得：
>
>   ```cpp
>   for (int j = 1; j < 60; j++)
>   {
>   	for (int i = 1; i <= n; i++)
>   	{
>   		nxt[i][j] = nxt[nxt[i][j - 1]][j - 1];
>   		dst[i][j] = (dst[i][j - 1] + dst[nxt[i][j - 1]][j - 1]) % modd;
>   	}
>   }
>   ```
>
>   输出时二进制按位枚举在将距离相加デス～

# Faillables :

> $ \text{If you WA on } \#3 : $ [想想 $ k = 0 $ 的情况](https://www.luogu.com.cn/discuss/989853) 

# Analyses :

> 总时间复杂度 $ \Theta (N \log{N} + Q \log{K}) $ 
>
> 总空间复杂度 $ \Theta (N \log{N}) $ 

# Code :

```cpp
/* L92,L93 的 log2(lowbit(k)) 其实也可以预处理出来 */
#include	<iostream>
#include	<cmath>
#define		int		long long
using namespace std;
constexpr int maxn = 2e5+4;
constexpr int modd = 1e9+7;

int n, m, q;
int a[maxn];
char s[maxn];
int nxt[maxn][60];
int dst[maxn][60];

inline int lowbit (int k)
{
	return k & -k;
}

signed main (void)
{
//	freopen ("..\\Stream Data\\P11269\\kingdom5.in", "r", stdin);
//	freopen ("stdout", "w", stdout);
	
	cin >> n >> m >> q >> s + 1;
	for (int i = 1; i <= n; i++) a[i] = a[i - 1] + (s[i] ^ '0');
	for (int i = 1; i <= n; i++)
	{
		if (!a[n])
		{
			nxt[i][0] = i % n + 1;
			dst[i][0] = 1;
		}
		else
		{
			if (i + m > n)
			{
				if (a[(i + m - 1) % n + 1])
				{
					nxt[i][0] = lower_bound (a + 1, a + n + 1, a[(i + m - 1) % n + 1]) - a;
					dst[i][0] = m - ((i + m - 1) % n + 1 - nxt[i][0]);
				}
				else if (i + m > (n << 1))
				{
					nxt[i][0] = lower_bound (a + 1, a + n + 1, a[n]) - a;
					dst[i][0] = m - ((i + m - 1) % n + 1) - (n - nxt[i][0]);
				}
				else
				{
					if (i == n)
					{
						nxt[i][0] = 1;
						dst[i][0] = 1;
					}
					else
					{
						nxt[i][0] = lower_bound (a + i + 1, a + n + 1, a[n]) - a;
						dst[i][0] = nxt[i][0] - i;
					}
				}
			}
			else
			{
				if (a[i] == a[i + m])
				{
					nxt[i][0] = i % n + 1;
					dst[i][0] = 1;
				}
				else
				{
					nxt[i][0] = lower_bound (a + 1, a + n + 1, a[i + m]) - a;
					dst[i][0] = nxt[i][0] - i;
				}
			}
		}
	}
	for (int j = 1; j < 60; j++)
	{
		for (int i = 1; i <= n; i++)
		{
			nxt[i][j] = nxt[nxt[i][j - 1]][j - 1];
			dst[i][j] = (dst[i][j - 1] + dst[nxt[i][j - 1]][j - 1]) % modd;
		}
	}
	
//	for (int i = 1; i <= n; i++) cout << i << ' ';
//	cout << endl;
//	for (int i = 1; i <= n; i++) cout << dst[i][0] << ' ';
//	cout << endl;
	
	for (int s, k, i = 1; i <= q; i++)
	{
		cin >> s >> k;
		if (!k)
		{
			cout << s % modd << endl;
			continue;
		}
		int idx = s;
		s = (s - 1 + n) % n + 1;
		while (k)
		{
			idx = (idx + dst[s][(int) log2 (lowbit (k))]) % modd;
			s = nxt[s][(int) log2 (lowbit (k))];
			k &= k - 1;
		}
		cout << idx << endl;
	}
	return 0;
}
```

---

## 作者：晴空一鹤 (赞：4)

大家好，这题显然可以直接倍增就做完了，但我们有常数更小的做法。

首先每个位置的下一个转移点是确定的，这个可以直接扫一遍得到，我们以此来建成一张有向图。

容易发现每个点出度为 $1$，这很星战，因此这是一张基环树森林。那直接找环，环上倍增，树的部分也求一个倍增祖先。

回答询问时先跳到环上，然后算一下要绕几圈再倍增求解，时间复杂度 $O((q+n)\log n)$，是直接倍增时空的四分之一左右，反正连我这样的大常数选手都挤进最优解第一页了。

~~快快把时空缩小卡掉愚蠢的直接倍增做法！！！~~

---

## 作者：_JF_ (赞：3)

[P11267 【MX-S5-T1】王国边缘 ](https://www.luogu.com.cn/problem/P11267)

细节题。赛时不知道在干嘛，搞得很复杂，还没写出来，失败透顶了。

我们不妨假设点 $i$，在看完后 $m$ 个以后，假设到点 $j$，那么我们对 $(i,j)$ 连边。

那么我们对于一个连通块而言，显然只有 $n$ 条边，并且每个点只有一个出边，感性看一下，必然是产生一个环，然后，把这个环缩点以后，成为一个 DAG。

注意到 $k$ 很大，一步一步跳很慢，所以直接倍增，处理出 $f_{i,j}$ 表示从 $i$ 开始跳 $2^j$ 步的位置，以及路上的贡献。

这里我赛时就想着分成环上和环外，然后找到循环节搞搞搞。十分麻烦，其实直接倍增即可。

所以这样就做完了，但是还是要讲一下，我 $i$ 怎么找到这个 $j$，分两种情况：

- $m <n$，直接找出在原序列对应的一段，看最靠近右端点的 $1$，分讨即可。

- $m\geq n$，这时候就，相当于转了若干圈，这时候分三类，一类是看余数段有无 $1$，第二类是看 $[1,i]$ 部分有无 $1$，第三类是看 $[i+1,n]$ 有无 $1$，但是这第三类就要少转一圈。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =6e5+10;
const int mod=1e9+7;
#define int long long 
char s[N],S[N];
int Left[N],Sum[N],nxt[N],Num[N][65],Dus[N][65],n,m,q;
int change(int x){
	if(x%n==0)	return n;
	return x%n;
}
int rcalc(int x,int y){
	return (x<=y)?(y-x):(y+n-x);
}
int Jump(int x,int len1){
	if(len1==0)	return x+0;
	int rdis=0,lst=x; x=change(x);
	for(int i=60;i>=0;i--)	
		if(len1&(1ll<<i))	
			rdis+=Num[x][i],rdis%=mod,x=Dus[x][i],rdis%=mod;
	return (lst+rdis)%mod;
}
void init(){
	for(int j=1;j<=62;j++)
		for(int i=1;i<=n;i++){
			Dus[i][j]=Dus[Dus[i][j-1]][j-1];
			Num[i][j]=(Num[i][j-1]%mod+Num[Dus[i][j-1]][j-1]%mod)%mod;
			
		}
//	cout<<Dus[4][0]<<endl;
//	cout<<Num[4][1]<<endl;
}
signed main(){
//	freopen("kingdom5.in","r",stdin);
//	freopen("ans.out","w",stdout);
	cin>>n>>m>>q,scanf("%s",s+1);
	for(int i=1;i<=n;i++)	S[i]=S[i+n]=s[i];
	int node=0;
	for(int i=1;i<=2*n;i++){
		if(S[i]=='1')	node=i,Sum[i]=Sum[i-1]+1;
		else Sum[i]=Sum[i-1];
		Left[i]=node%n; if(Left[i]==0)	Left[i]=n;
	}
	for(int i=1;i<=n;i++){
		int dus1=0;
		if(m>=n){
			int nowdus=m%n; dus1=m/n;
//			cout<<n<<' '<<nowdus<<endl;
			bool f=true;
			if(Sum[n]==0)	dus1=0,nxt[i]=change(i+1);
			else{
				if(Sum[i+nowdus]-Sum[i]==0){
					if(S[i]==0)	nxt[i]=change(Left[n]),dus1--;
					else{
						nxt[i]=change(Left[i+n]);
						if(nxt[i]!=i)	dus1--;
					}
				}
				else	nxt[i]=change(Left[i+nowdus]);
			}
		}
		else{
			if(Sum[i+m]-Sum[i]==0)	nxt[i]=change(i+1);
			else{
				int now=Left[i+m];
				if(now==i)	nxt[i]=change(i+1);
				else	nxt[i]=change(now);
			}
		}
		Dus[i][0]=nxt[i];
		Num[i][0]=(dus1*n%mod+rcalc(i,nxt[i])%mod)%mod;
//		cout<<i<<' '<<nxt[i]<<' '<<Num[i][0]<<endl;
	}
	init();
	while(q--){
		int S1,K;
		cin>>S1>>K;
		cout<<Jump(S1,K)%mod<<endl;
	}
	return 0;
} 
```

---

## 作者：wmrqwq (赞：3)

# 题目链接

[P11267 【MX-S5-T1】王国边缘](https://www.luogu.com.cn/problem/P11267)

# 解题思路

先考虑对于 $1 \sim n$ 中的每一个点往后跳 $1$ 次会跳的距离。

那么为什么只用处理 $1 \sim n$ 这些点而不去处理其余的点往后跳的距离呢？

我们可以发现，由于字符串是无线循环的，所以对于位置模 $n$ 的结果相同时，那么往后跳的距离也是相同的。

我们可以先将字符串断环成链倍长后做前缀和来处理 $l \sim r$ 中的 $1$ 的数量。

然后容易二分得出往后跳的距离。

然后我们就可以求出对于每个点 $i$ 往后可以跳跃的距离。

然后问题询问的是往后跳 $k$ 次的最终位置。

这是一个经典的倍增问题，直接倍增即可。

注意，在倍增过程中，可能答案会爆 `long long`。

# 参考代码

记得加上快读。

```cpp
ll n,m,k;
ll x,y;
string s;
ll corn=1;
ll mod=1e9+7;
ll sum[400010];
__int128 nxt[400010][70];
ll ask(ll x) // 1~x 有几个 1
{
    return sum[x%n]+sum[n]*(x/n);
}
ll query(ll l,ll r){// l~r 中有几个 1
    return ask(r)-ask(l-1);
}
ll f(__int128 x)
{
    if(x%n==0)
        return n;
    return x%n;
}
ll corn2=1;
void solve()
{
    _clear();
    cin>>n>>m>>k>>s;
    s=s+s;
    s=' '+s;
    forl(i,1,n)
        corn&=s[i]=='0',
        corn2&=s[i]=='1';
    if(corn)
    {
        while(k--)
            cin>>x>>y,
            cout<<(x+y)%mod<<endl;
        return ;
    }
    if(corn2)
    {
        while(k--)
            cin>>x>>y,
            cout<<(x+(y%mod)*(m%mod))%mod<<endl;
        return ;
    }
    forl(i,1,n*2)
        sum[i]=sum[i-1]+(s[i]=='1');
    forl(i,1,n)
    {
        ll L=i+1,R=i+m;
        while(L<R)
        {
            ll Mid=(L+R)/2;
            if(query(Mid+1,i+m)>=1)
                L=Mid+1;
            else
                R=Mid;
        }
        if(query(L,L)>=1)
            nxt[i][0]=L-i;
        else
            nxt[i][0]=1;
    }
    forl(j,1,62)
        forl(i,1,n)
            nxt[i][j]=(nxt[i][j-1]+nxt[f(i+nxt[i][j-1])][j-1]);
    while(k--)
    {
        cin>>x>>y;
        ll ans=x%mod;
        forr(i,62,0)
            if(y&(1ll<<i))
            {
                x%=n;
                if(x==0)
                    x=n;
                ans=(ans+nxt[x][i]%mod)%mod;
                x+=nxt[x][i]%n;
            }
        cout<<ans<<endl;
    }
}
```

---

## 作者：gghack_Nythix (赞：2)

## 前言：

赛场上脑子再次丢失，只会写 70pts 暴力，还写挂了。

## 分析：

首先考虑暴力，即使用并查集查找从当前点 $i$ 查找 $[i,i+m]$ 的最靠后的 $1$。然后计算步数，这样子可以拿到 70 分。

考虑优化，发现 $k$ 和 $m$ 的值很诡异，考虑倍增优化跳 $k$ 步的过程。设 $nxt_{i,j}$ 表示从 $i$ 点进行 $2^j$ 次移动操作后会往前移动**多少步数**。

$nxt_{i,0}$ 是好求的，按照 70 分的思路即可，考虑 $nxt_{i,j}$ 怎么求，首先可以从 $i$ 点移动 $2^{j-1}$ 次，那么我们会到达一个新的点，记作 $f_{i,j-1}$，则我们再从这个点移动 $2^{j-1}$ 次就可以凑够步数了。

即：

$$
nxt_{i,j}=nxt_{f_{i,j-1},j-1}
$$

$f_{i,j}$ 的处理也类似上文，即：

$$
f_{i,j}=f_{f_{i,j-1},j-1}
$$

然后每次查询把 $k$ 的每个二进制位跳一遍即可。


我的代码比较恶臭，仅供参考（倍增没有处理好 $S^{\infty}=0^{\infty}$ 的情况，直接特判）。
```cpp
# include <bits/stdc++.h>
# define int long long
//# define calc (x) 
using namespace std;
const int N = 4e5 + 5 , mod = 1e9 + 7;
int n , m , q , sum[N] , nxt[N][65] , nxtpos[N][65];
int pos = -1,rpos = -1;
char s[N];
static inline void print (int x) {
    if (x < 0) x = -x,putchar('-');
    if (x >= 10) print(x / 10);
    putchar(x % 10 + '0');
}
class Merge_Set {
	public:
		int s[N];
		void init (int sz) { iota(s + 1 , s + sz + 1 , 1); }
		int find (int x) { return s[x] == x?s[x]:s[x] = find(s[x]); }
		void merge (int x , int y) { s[find(x)] = find(y); }
	private:
} mq ;
static inline int calc (int x) { return x % n + ( x % n == 0 ) * n; }
void solve () {
	int st , k, stt;
	cin >> st >> k;
	stt = st;
	if (sum[n] == 0) return cout << (stt % mod + k % mod) % mod << "\n",void();
	st = calc(st);
	int ans = 0;
	for (int i = 63ll;i >= 0ll;--i) {
		if ((k >> i) & 1ll) ans = (ans + nxt[st][i]) % mod , st = calc (nxtpos[st][i]);
	}
	cout << (stt % mod + ans % mod) % mod << "\n";
	return void ();
}
signed main () {
	// freopen("kingdom4.in","r",stdin);
	// freopen("kingdom.out","w",stdout);
	ios::sync_with_stdio(false);
	cin >> n >> m >> q;
	for (int i = 1;i <= n;++i) cin >> s[i];
	for (int i = 1;i <= n;++i) sum[i] = sum[i - 1] + (s[i] == '1');
	mq.init (n);
	for (int i = n;i >= 1;--i) if (s[i] == '1') {pos = i ; break;}
	rpos = pos;
	for (int i = 1;i <= n;++i) {
		if (s[i] == '0' && mq.find(i) == i) mq . merge (i , rpos);
		else if (s[i] == '1') rpos = i;
	}
	for (int i = 1;i <= n;++i) {
		int nex = calc(i + m) ;
		if ((i + m < n && sum[nex] - sum[i] == 0) || (i + m > n && m < n && sum[i] - sum[nex] == sum[n] ) || (i + m > n && m >= n && sum[n] == 0)) {
			nxt[i][0] = 1;
			nxtpos[i][0] = calc (i + 1);
			continue;
		}
		int step = (nex - mq.find(nex) < 0 ? nex + n - mq.find(nex) : nex - mq.find(nex));
		nex = mq . find (nex) ;
		nxt[i][0] = m - step;
		nxt[i][0] %= mod; 
		nxtpos[i][0] = calc ( nex );
	}
	for (int bit = 1;bit <= 63;++bit) {
		for (int i = 1;i <= n;++i) {
			nxtpos[i][bit] = nxtpos[nxtpos[i][bit - 1]][bit - 1];
			nxt[i][bit] = nxt[i][bit - 1] % mod + nxt[nxtpos[i][bit - 1]][bit - 1] % mod ;
			nxt[i][bit] %= mod;
		}
	} 
	while (q -- > 0) solve ();
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

首先由于 $m$ 固定，那么每个位置跳一次移动的次数是固定的。

先预处理出 $a_i$ 表示小于等于 $i$ 的位置中离 $i$ 最近的 $1$ 的位置。

考虑求出 $nxt_i, h_i$ 表示 $i$ 下次跳到 $S^{+\inf}$ 中的某个 $T$ 的第 $nxt_i$ 个位置，移动了 $h_i$ 的距离；可以分三种情况讨论：

- $i + m \le n$：直接找 $a_{i + m}$ 即可，没有的话就是 $i + 1$。

- $i + m \le 2n$：先找 $a_{i + m - n}$，若没有的话找 $a_n$，还没有就是 $i + 1$。

- 此时 $[i + 1, i + m]$ 中必有至少一个完整的 $T%$，找 $a_{(i + m) \bmod n}$ 即可，没有也去找 $a_n$，否则就是 $i + 1$。

然后要多次询问某些位置跳多次的移动次数，直接倍增 $f_{j,i}, g_{j, i}$ 表示 $i$ 跳 $2^j$ 次到达的位置和移动的次数。

时间复杂度为 $O((n + q) \log W)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it = l; it != r; ++it) (*it)=x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1,s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i,l,r) for(register int i = l; i <= r; ++i)
#define _For(i,l,r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2e5 + 10, M = 62, mod = 1e9 + 7; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
ll m, x, t, k; 
int n, q, ans;
int a[N], nxt[N], h[N];
int f[M][N], g[M][N];
char s[N];
bool End;
int main(){
//	open("A.in", "A.out");
	n = read(), m = read(), q = read();
	scanf("%s", s + 1);
	for(int i = 1; i <= n; ++i){
		if(s[i] == '1')
		  a[i] = i;
		else
		  a[i] = a[i - 1];
	}
	for(int i = 1; i <= n; ++i){
		if(i + m <= n){
			if(a[i + m] > i)
			  nxt[i] = a[i + m];
			else
			  nxt[i] = i + 1;
			h[i] = nxt[i] - i;
		}
		else if(i + m <= (n << 1)){
			if(a[i + m - n]){
				nxt[i] = a[i + m - n];
				h[i] = n - i + a[i + m - n];
			}
			else if(a[n] > i){
				nxt[i] = a[n];
				h[i] = nxt[i] - i;
			}
			else{
				nxt[i] = i + 1;
				h[i] = 1;
			}
		}
		else{
			ll t = (i + m) % n, p = (m - n + i) / n;
			if(a[t]){
				nxt[i] = a[t];
				h[i] = (1ll * p * n + n - i + a[t]) % mod;
			}
			else if(a[n]){
				nxt[i] = a[n];
				h[i] = (1ll * (p - 1) * n + a[n] + n - i) % mod;
			}
			else{
				nxt[i] = i + 1;
				h[i] = 1;
			}
		}
		if(nxt[i] > n)
		  nxt[i] -= n;
		f[0][i] = nxt[i], g[0][i] = h[i];
	}
	for(int j = 1; j < M; ++j){
		for(int i = 1; i <= n; ++i){
			f[j][i] = f[j - 1][f[j - 1][i]];
			g[j][i] = (g[j - 1][i] + g[j - 1][f[j - 1][i]]) % mod;
		}
	}
	while(q--){
		ans = 0;
		x = t = read(), k = read();
		x %= n;
		if(!x)
		  x = n;
		for(int j = M - 1; j >= 0; --j){
			if(k >= (1ll << j)){
				k -= (1ll << j);
				ans = (ans + g[j][x]) % mod;
				x = f[j][x];
			}
		}
		write((t + ans) % mod);
		putchar('\n'); 
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：鲤鱼江 (赞：2)

为在模 $n$ 下方便描述，本题解下标从 $0$ 开始。

发现最后停在哪里可以描述为我们走过了多少个 $n$ 和我们最后停留的下标模 $n$ 是多少，我们先想想怎么得到第二个。

我们用 $p_i$ 表示从 $p$ 开始走一步能到达什么地方，那么每次行走都相当于对序列进行一次变换。不难发现问题被转化为了 [AT_abc367_e](https://www.luogu.com.cn/problem/AT_abc367_e)。

我们是可以发现这种变换是具有结合律的，那么就可以快速幂。

AT_abc367_e 的转移代码：

```cpp
struct Trans{
	int to[N];
	int operator [](const int &x){return to[x];}
	void F(const Trans T){
		for(int i=1;i<=n;++i) c[i]=to[i];
		for(int i=1;i<=n;++i) to[i]=c[T.to[i]];
	}
};
```
此题本质大同小异，可以发现带上轮数之后同样满足结合律。

```cpp
struct Per{
	int p[N],len[N];
	Per(){memset(p,0,sizeof(p));memset(len,0,sizeof(len));}
	inline void Set(int x,int y,int z){p[x]=y;len[x]=z;}
	Per operator *(const Per &t)const{
		Per z;
		for(int i=0;i<n;++i){z.len[i]=(t.len[p[i]]+len[i])%mod;z.p[i]=t.p[p[i]];}
		return z;
	}
	void out(){for(int i=0;i<n;++i) cout<<p[i]+1<<' ';cout<<endl;}
	void out1(){for(int i=0;i<n;++i) cout<<len[i]<<' ';cout<<endl;}
}P[101];
```

然后提前预处理出快速幂得到的转移数组，到时候 $O(\log V)$ 转移即可。

$x$ 是起始位置，$len$ 是轮数。

```
for(int i=63;~i;--i) if((y>>i)&1){len=(len+P[i].len[x])%mod;x=P[i].p[x];}
```

然后问题来到了如何处理最开始的 $P$ 数组。

细节有点，但不多。

首先用一个 vector 把所有 $1$ 的位置存下来，到时候在里面二分，详见下面代码。

```cpp
  int tmp=(m/n)%mod;m%=n;
	for(int i=0;i<n;++i){
		int y=0,z=tmp;
		int ne=upper_bound(v.begin(),v.end(),i+m)-v.begin();
		if((!ne)||(v[ne-1]<=i)){
			if(!z) y=i+1;
			else {--z;y=*(upper_bound(v.begin(),v.end(),i+n+m)-1);}
		}else y=v[ne-1];
		if(y>=n){y-=n;++z;}
		P[0].Set(i,y,z);
	}
```

不难发现我的代码已经差不多全给了，下面放一个完整的：

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'

using namespace std;

const int N=2e5+10;
const int mod=1e9+7;
int a[N<<1],n,m,q;
char x;vector < int > v;

struct Per{
	int p[N],len[N];
	Per(){memset(p,0,sizeof(p));memset(len,0,sizeof(len));}
	inline void Set(int x,int y,int z){p[x]=y;len[x]=z;}
	Per operator *(const Per &t)const{
		Per z;
		for(int i=0;i<n;++i){z.len[i]=(t.len[p[i]]+len[i])%mod;z.p[i]=t.p[p[i]];}
		return z;
	}
	void out(){for(int i=0;i<n;++i) cout<<p[i]+1<<' ';cout<<endl;}
	void out1(){for(int i=0;i<n;++i) cout<<len[i]<<' ';cout<<endl;}
}P[101];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);cin>>n>>m>>q;
	for(int i=0;i<n;++i){cin>>x;a[i+n]=a[i]=x-'0';}
	for(int i=0;i<n<<1;++i) if(a[i]) v.emplace_back(i);
	if(v.empty()){
		while(q--){
			int x,y;
			cin>>x>>y;
			cout<<(x+y)%mod<<endl;
		}
		return 0;
	}
	int tmp=(m/n)%mod;m%=n;
	for(int i=0;i<n;++i){
		int y=0,z=tmp;
		int ne=upper_bound(v.begin(),v.end(),i+m)-v.begin();
		if((!ne)||(v[ne-1]<=i)){
			if(!z) y=i+1;
			else {--z;y=*(upper_bound(v.begin(),v.end(),i+n+m)-1);}
		}else y=v[ne-1];
		if(y>=n){y-=n;++z;}
		P[0].Set(i,y,z);
	}
	for(int i=1;i<=64;++i) P[i]=P[i-1]*P[i-1];
	while(q--){
		int x,y;
		cin>>x>>y;--x;
		int len=x/n;x%=n;
		for(int i=63;~i;--i) if((y>>i)&1){len=(len+P[i].len[x])%mod;x=P[i].p[x];}
		cout<<(len*n+x+1)%mod<<endl;
	}
	return 0;
}
```

评价：比较符合我对 NOIP 的预期

---

## 作者：Missa (赞：1)

非常小清新的 1.3k 写法。

容易发现下一步跳到哪里只与当前位置模 $n$ 的余数有关。于是先算出当前位置模 $n$ 余 $i$ 时，下一步跳多远，跳到模 $n$ 余几的位置，再倍增，就做完了。

那么要找到 $[i+1, i+m]$ 范围内的最后一个 $1$，对每个 $i$ 处理它左边第一个 $1$ 到 $i$ 的距离 $pre_i$ 就行了，找距离是为了更方便判是否 $> m$，注意如果 $a_i=1$ 则认为 $pre_i=0$。

那么对于每个 $i$，我们要找到 $nxt_i$，即跳一步的距离。找到 $pre_{i+m}$，这里认为下标模是在 $n$ 意义下的，如果 $pre_{i+m}>1$ 则 $nxt_i=1$，否则 $nxt_i=m-pre_{i+m}$。有了距离，也容易知道到达的点模 $n$ 的余数。

代码中特判了全 `0`，只要把代码中维护上一个 $1$ 位置的指针初始化为一个比 $-m$ 小的数就行了，我不想开 `long long` 就特判了。

```cpp
#include <bits/stdc++.h>

const int mod = 1e9 + 7;
using LL = long long;

int main() {
  int n, q; LL m; scanf("%d %lld %d", &n, &m, &q);
  std::vector<int> a(n), pre(n);
  int lst = -1; // 设成比 -m 小的数可以不用全 0 的特判
  for (int i = 0; i < n; i++) {
    scanf("%1d", &a[i]);
    if (a[i]) lst = i - n;
  }
  if (std::accumulate(a.begin(), a.end(), 0) == 0) { // 全 0 的情况
    while (q--) {
      LL s, x; scanf("%lld %lld", &s, &x);
      printf("%d\n", (s + x) % mod);
    }
    return 0;
  }
  for (int i = 0; i < n; i++) {
    if (a[i]) lst = i;
    pre[i] = i - lst;
  }
  int k = 64;
  std::vector<std::vector<int>> f(k, std::vector<int>(n)), t(k, std::vector<int>(n));
  for (int i = 0; i < n; i++) {
    int p = (i + m) % n, l = pre[p];
    if (l >= m) f[0][i] = 1, t[0][i] = (i + 1) % n;
    else t[0][i] = (p - l + n) % n, f[0][i] = (m - l) % mod;
  }
  for (int i = 1; i < k; i++)
    for (int j = 0; j < n; j++) {
      f[i][j] = (f[i - 1][j] + f[i - 1][t[i - 1][j]]) % mod;
      t[i][j] = t[i - 1][t[i - 1][j]];
    }
  while (q--) {
    LL s, x; scanf("%lld %lld", &s, &x);
    --s;
    int ans = (s + 1) % mod; s %= n;
    for (int i = k - 1; i >= 0; i--) if (x & (1ll << i)) {
      ans = (ans + f[i][s]) % mod;
      s = t[i][s];
    }
    printf("%d\n", ans);
  }
}
```

---

## 作者：forever_nope (赞：1)

Tag：基环树，倍增。

先将每个点看为一个模 $n$ 同余的一类点。

注意到我们可以把从每个点开始走 $1$ 步的位置找出来。

容易联想到，这么连边，最终的图一定是一个内向基环森林。

那么走 $k$ 次就是基环树上面走 $k$ 步，可以简单的倍增解决。

但是还要求目标点的原始编号，而不是同余后的。

发现可以给基环树的边权设置为，走过这条边之后加多少个 $n$。

也就是走这条边会绕着走多少个循环。

基环树倍增的同时，倍增一下边权即可，容易实现的。

```cpp
#include <bits/stdc++.h>

#define endl "\n"

using namespace std;

void Main();

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	return Main(), 0;
}

using ll = long long;

#define int ll

constexpr int mod = 1e9 + 7;

constexpr int N = 2e5 + 10;

int n, m;

int nxt[N][63], val[N][63];

int calc(int s, int k) {
	int w = ((s - 1) / n) % mod;
	s = (s - 1) % n + 1;
	while (k) {
		int u = __builtin_ctzll(k);
		w = (w + val[s][u]) % mod;
		s = nxt[s][u];
		k &= k - 1;
	}
	return (s + w * n % mod) % mod;
}

namespace graph {
	void add(int u, int v, int w = 0) {
		if (v > n)
			v -= n, w = 1;
		nxt[u][0] = v;
		val[u][0] = w % mod;
	}

	void init() {
		for (int k = 1; k < 63; ++k) {
			for (int i = 1; i <= n; ++i) {
				nxt[i][k] = nxt[nxt[i][k - 1]][k - 1];
				val[i][k] = (val[i][k - 1] + val[nxt[i][k - 1]][k - 1]) % mod;
			}
		}
	}
}

void init(string &str) {
	if (m < n) {
		str = "#" + str + str;
		vector<int> pre(2 * n + 1);
		for (int i = 1; i <= 2 * n; ++i)
			pre[i] = pre[i - 1] + (str[i] == '1');
		for (int i = 1; i <= n; ++i) {
			if (pre[i + m] - pre[i] == 0)
				graph::add(i, i + 1);
			else {
				auto it = lower_bound(pre.begin(), pre.end(), pre[i + m]);
				graph::add(i, it - pre.begin());
			}
		}
	}
	else {
		// m >= n
		str = "#" + str;
		vector<int> pre(n + 1);
		int last = -1, beg = -1;
		for (int i = n; i >= 1; --i) {
			if (str[i] == '1') {
				last = i;
				break;
			}
		}
		for (int i = 1; i <= n; ++i) {
			if (str[i] == '1') {
				if (beg == -1)
					beg = i;
				last = i;
			}
			pre[i] = last;
		}
		for (int i = 1; i <= n; ++i) {
			int j = (i + m - 1) % n + 1;
			graph::add(i, pre[j], (i + m - 1) / n - (j < beg));
		}
	}
	graph::init();
}

void Main() {
	int q;
	string str;
	cin >> n >> m >> q;
	cin >> str;
	if (count(str.begin(), str.end(), '0') == n) {
		while (q--) {
			int s, k;
			cin >> s >> k;
			cout << (s + k) % mod << endl;
		}
		return;
	}
	if (count(str.begin(), str.end(), '1') == n) {
		m %= mod;
		while (q--) {
			int s, k;
			cin >> s >> k;
			k %= mod;
			cout << (s + k * m % mod) % mod << endl;
		}
		return;
	}
	init(str);
	while (q--) {
		int s, k;
		cin >> s >> k;
		cout << calc(s, k) << endl;
	}
}
```

代码里面特判了全 $0$ 的情况，因为在 `init` 中的大 `else` 没有 $1$ 会寄；特判全 $1$ 是卡常。

---


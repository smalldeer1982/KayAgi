# 【MX-S6-T1】「KDOI-11」打印

## 题目背景

原题链接：<https://oier.team/problems/S6A>。

## 题目描述

巡的家有 $m$ 台打印机，编号从 $1$ 到 $m$。她有 $n$ 个文件想要打印。其中第 $i$ 个文件会在第 $t_i$ 时刻下发打印命令，打印这个文件需要 $s_i$ 的时间。

每次发送一个文件打印会选择等待时间最短的打印机，如有多个，选择编号最小的。

你需要告诉巡每台打印机打印了哪些文件。

**保证同一时刻不会下发多个打印命令。**

## 说明/提示

**【样例解释 #1】**

共有 $3$ 台打印机。按时间顺序，打印命令如下：
- 文件 $2$ 在第 $1$ 秒被下发。此时所有打印机等待时间都是 $0$。因此选择编号最小的 $1$ 号打印机。
- 文件 $3$ 在第 $2$ 秒被下发。此时 $1$ 号打印机正在打印文件 $2$，其余打印机等待时间都是 $0$。因此选择编号最小的 $2$ 号打印机。
- 文件 $1$ 在第 $3$ 秒被下发。此时 $1$ 号打印机已经完成文件 $2$ 的打印，等待时间为 $0$。因此选择 $1$ 号打印机。

故三台打印机分别打印了编号为 $[1,2],[3],[]$ 的文件。

**【样例 #2】**

见附件中的 `print/print2.in` 与 `print/print2.ans`。

该组样例满足测试点 $1\sim 3$ 的约束条件。

**【样例 #3】**

见附件中的 `print/print3.in` 与 `print/print3.ans`。

该组样例满足测试点 $4\sim 9$ 的约束条件。

**【样例 #4】**

见附件中的 `print/print4.in` 与 `print/print4.ans`。

该组样例满足测试点 $18\sim 20$ 的约束条件。

**【数据范围】**

对于所有测试数据，保证：$1\leq n,m\leq 2\times 10^5$，$1\leq s_i,t_i\leq 10^9$，所有 $t_i$ 互不相同。

| 测试点编号  |   $n,m\leq$    | $s_i\leq $ |   $t_i\leq $   |
| :---------: | :------------: | :--------: | :------------: |
|  $1\sim 3$  |      $10$      |   $10^9$   |     $10^9$     |
|  $4\sim 9$  |     $5000$     |   $10^9$   |     $10^9$     |
| $10\sim 13$ | $2\times 10^5$ |    $1$     |     $2\times 10^5$     |
| $14\sim 17$ | $2\times 10^5$ |   $10^9$   | $2\times 10^5$ |
| $18\sim 20$ | $2\times 10^5$ |   $10^9$   |     $10^9$     |



## 样例 #1

### 输入

```
3 3
2 3
2 1
5 2```

### 输出

```
2 1 2
1 3
0```

# 题解

## 作者：zhujiangyuan (赞：23)

[P11289 【MX-S6-T1】「KDOI-11」打印](https://www.luogu.com.cn/problem/P11289)

优先队列简单应用题。10 min 过了。

将文件按照加入时间从小到大排序，对于每一个文件分别去选打印机。

对于打印机，需要选择当前最早能使用的。开一个堆，按照最早可以使用的时间从小到大排序。堆顶为可使用时间最早的打印机。

对于最早可使用的时间小于 $t_i$ 的打印机，它们对我们来说都无需等待，因此只有编号上的差异。我们将这些打印机的最早使用时间都赋为 $0$，这样方便按照编号排序。具体的，对于最早可使用时间等于 $0$ 的开一个堆 $q$，对于最早可使用时间大于 $0$ 的开一个堆 $Q$，每次将 $Q$ 中的若干个打印机移动到 $q$ 中，并将最早可使用时间设为 $0$。 

处理过后，如果 $q$ 中有打印机，即有不需要等待的，使用 $q$ 中编号最小的打印机。否则使用 $Q$ 中等待时间最短的打印机。

时间复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e6 + 10;
int n, m;
struct File_ { int s, t, id; } a[N];
bool operator < (File_ a, File_ b) {
    return a.t < b.t;
}
struct Print {
    LL now, id;
    bool operator < (const Print &x) const {
        return now > x.now || (now == x.now && id > x.id);
    }
};
priority_queue <Print> q, Q;
// q 中存 0 Q 中存非 0
vector <int> ans[N];
signed main () {
    ios::sync_with_stdio (false);
    cin.tie (0); cout.tie (0);
    
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        cin >> a[i].s >> a[i].t, a[i].id = i;
    sort (a + 1, a + n + 1);
    for (int i = 1; i <= m; ++i)
        q.push ({0, i});
    for (int i = 1; i <= n; ++i) {
        if (!Q.empty ()) {
            vector <int> v;
            while (!Q.empty ()) { // 将 Q 中无需等待的打印机移至 q 中
                LL x = Q.top ().now;
                if (x > a[i].t) break;
                v.push_back (Q.top ().id), Q.pop ();
            }
            for (auto j : v) q.push ({0, j});
        }
        int id;
        if (!q.empty ()) { // 有无需等待的
            id = q.top ().id; q.pop ();
            Q.push ({a[i].t + a[i].s, id});
        }
        else { // 需要等待
            id = Q.top ().id;
            Q.push ({Q.top ().now + a[i].s, id});
            Q.pop ();
        }
        ans[id].push_back (a[i].id); // 记录答案
    }
    for (int i = 1; i <= m; ++i) {
        cout << ans[i].size () << ' ';
        sort (ans[i].begin (), ans[i].end ());
        for (auto &j : ans[i]) cout << j << ' ';
        cout << '\n';
    }
    return 0;
}
```

---

## 作者：SpringQinHao (赞：7)

思路：用两个优先队列，一个维护**当前可以选的最小的打印机**，一个处理正在被使用的打印机，按发起时间排序后，每次让时间跳到**下一个发起时间**，当然要考虑没有打印机可以用时让时间跳到**等待时间最小的打印机的结束时间**。

当时在自己电脑上跑不用快写跑的超级慢……不过不用也可以拿满。

关于优先队列排序结构体可以看我这篇专栏 [关于优先队列中结构体中重载运算符的问题](https://www.luogu.com.cn/article/2n6n4m0v)

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;
typedef long long ll;
const ll N=2e5+10;
struct wq
{
	ll id,t;
	bool operator < (const wq &a)const
	{
		return t>a.t;
	}
}o;
ll cnt,n,m,t=1,id,temp[N];
priority_queue<ll,vector<ll>,greater<ll> > q;
priority_queue<wq> v;
vector<ll> vec[N];
struct node
{
	ll s,t,id;
}a[N];
bool cmp(node a,node b)
{
	return a.t<b.t;
}
ll read()
{
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x*=10,x+=c-'0';
		c=getchar();
	}
	return x*f;
}
inline void print(ll x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
	{
		print(x/10);
	}
	putchar(x%10+'0');
}
int main()
{
	freopen("print4.in","r",stdin);
	freopen("print.out","w",stdout);
	n=read(),m=read();
	for(ll i=1;i<=n;i++)
	{
		a[i].s=read();
		a[i].t=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	for(ll i=1;i<=m;i++)
	{
		q.push(i);
	}
	for(ll i=1;i<=n;i++)
	{
		t=max(a[i].t,t);
		while(!v.empty()&&v.top().t<=t)
		{
			q.push(v.top().id);
			v.pop();
		}
		if(q.empty()) t=v.top().t;
		while(!v.empty()&&v.top().t<=t)
		{
			q.push(v.top().id);
			v.pop();
		}
		id=q.top();
		q.pop();
		o.id=id,o.t=t+a[i].s;
		v.push(o);
		vec[id].push_back(a[i].id);
	}
	for(ll i=1;i<=m;i++)
	{
		print(vec[i].size());
		putchar(' ');
		ll len=vec[i].size();
		
		for(ll j=0;j<vec[i].size();j++) temp[j]=vec[i][j];
		sort(temp,temp+len);
		for(ll j=0;j<vec[i].size();j++) print(temp[j]),putchar(' ');
		putchar('\n');
	}
	
	
	return 0;
 }

```

---

## 作者：xxxalq (赞：6)

赛时一个小时才过。

[题目链接](https://www.luogu.com.cn/problem/P11289)

# 思路分析

首先很容易想到用一个堆来维护所有的打印机，然后将所有任务按照下发时间升序排序来模拟整个过程。

然后考虑堆除了编号之外维护什么东西。

一种想法是维护每个打印机到当前任务需要等多久，但这样每次都需要更新一变，时间复杂度为 $O(nm\log m)$。

发现可以维护每个打印机当前的最后一个任务的结束时间，在堆中首先按照结束时间升序排序，结束时间相同再按照编号。这样又会出现一个问题就是当有打印机在这个任务之前结束时，事实上它们对于这个任务的等待时间都是 $0$，此时应按照编号排序，但是在堆中会按照打印机中上一个任务的结束时间排序，这样就不对了。

于是我们考虑维护两个堆，分别维护对于当前任务不需要等待和需要等待的打印机。枚举每一个任务，如果第一个堆中有打印机那就用这个打印机并把它加入第二个堆，否则就用第二个堆中的堆顶打印机。

每次操作第二个堆最多加入一个元素，减少 $m$ 个元素；第一个堆最多加入 $m$ 个元素，减少一个元素。均摊下来是 $O(n\log m)$ 的。堆的话不想手写用优先队列就行了。

# 代码


```cpp
//code by xxxalq
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=200003;

int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch>57||ch<48){
		if(ch==45){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>=48&&ch<=57){
		x=(x<<1)+(x<<3)+(ch-48);
		ch=getchar();
	}
	return x*f;
}

struct node{
	int s,t,idx;
}a[maxn];

bool cmp(node x,node y){
	return x.s<y.s;
}

int n,m;

vector<int>ans[maxn];

priority_queue<pair<int,int> >q2;
priority_queue<int>q1;

signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i].t=read(),a[i].s=read();
		a[i].idx=i;
	}
	for(int i=1;i<=m;i++){
		q1.push(-i);
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		while((!q2.empty())&&-q2.top().first<=a[i].s){
			q1.push(q2.top().second);
			q2.pop();
		}
		if(q1.empty()){
			int id=-q2.top().second,tim=-q2.top().first;
			q2.pop();
			ans[id].push_back(a[i].idx);
			q2.push(make_pair(-tim-a[i].t,-id));
		}else{
			int id=-q1.top();
			ans[id].push_back(a[i].idx);
			q1.pop();
			q2.push(make_pair(-a[i].s-a[i].t,-id));
		}
	}
	for(int i=1;i<=m;i++){
		cout<<ans[i].size()<<' ';
		sort(ans[i].begin(),ans[i].end());
		for(int j=0;j<ans[i].size();j++){
			cout<<ans[i][j]<<' ';
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：Heldivis (赞：5)

## 「KDOI-11」打印

看到这题，第一反应感觉比较水，感觉直接把每个打印机的“最后使用时间-编号”插入一个 `std::set` 中，按照时间将任务排序后每次选取 `begin()` 所表示的打印机。

但是这样过不了样例，因为这样第一关键字是**最后一次打印时间**而非**等待时间**，即**等待时间**为**上次打印时间**减去**使用时间**，对 $0$ **取最大值**，即负值视为 $0$。

有一个比较暴力的想法，每次暴力将不到当前时间的打印机改为当前时间，时间复杂度 $O(n^2\log n)$，实测能过 $60$ 分。

```cpp
for (int tmp, i = 1; i <= n; ++i) {
    const auto &[p, s, t] = w[i];
    while (set.begin()->first < t)
      tmp = set.begin()->second, set.erase({set.begin()}), set.insert({t, tmp});
    const auto &[tim, id] = *set.begin();
    set.erase(set.begin()), vec[id]->push_back(p);
    set.insert({std::max(tim, t) + s, id});
  }
  for (int i = 1; i <= m; ++i) {
    cout << vec[i]->size();
    std::sort(vec[i]->begin(), vec[i]->end());
    for (const int &j : *vec[i]) cout << ' ' << j;
    cout << '\n';
  }
```

然后考虑这样写，时间复杂度太大的原因主要在**枚举打印时间小于当前时间的打印机**，考虑用某种方式消除。**每次都修改不如查询时取 $\min$**，考虑使用线段树，线段树上的一个叶子节点表示一个打印机。维护区间最小值，那么选取一个区间内的打印机，最小的等待时间就可以通过 `std::max(0LL, tr[p].min - t)` 求得。每次插入时在线段树上二分，以等待时间为第一关键字选择子节点选取，如果相同选择左半部分，即编号更小的打印机。

线段树二分是没有区间限制的那种，剩下的都是板子，没什么细节，感觉很简单，记得开 `long long`。[代码见此](https://www.luogu.com.cn/paste/0rw65kq0)。

---

## 作者：nothing__ (赞：3)

我的做法是无脑线段树。

* 对于每一个打印机，我们使他们初始的可以使用的时间为零。

* 对于每一次打印操作，我们可以通过线段树快速求出等待时间最少的并且编号最小的点。

* 求出以后我们将这个打印机下一次可以使用的时间更新。

* 因为线段树维护的是下一次使用的时间节点，所以在查询时我们需要判断如果他的下一次使用节点小于等于当前时间那么我们默认他为零，否则减去当前时间再进行比较。

具体实现见代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read() {
	int x=0, w=1; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') w=-1; ch=getchar();}
	while(isdigit(ch)) {x=x*10+(ch-'0'); ch=getchar();}
	return x*w;
}
const int N=3e5+10;
const int inf=0x3f3f3f3f;
int n, m;
struct node {int d, st, id;} a[N];
bool cmp(node a, node b) {return a.st<b.st;}
struct type {int p, t;} ;
vector<int> as[N];
struct trnode{
	int l, r, lc, rc, mn;
} tr[N<<2]; int trlen;
#define lc(x) tr[x].lc
#define rc(x) tr[x].rc
void pushup(int now) {
	tr[now].mn=min(tr[lc(now)].mn, tr[rc(now)].mn);
}
void build(int l, int r) {
	int now=++trlen;
	tr[now]={l, r, -1, -1, inf};
	if(l==r) {tr[now].mn=0; return ;}
	int mid=(l+r)>>1;
	tr[now].lc=trlen+1, build(l, mid);
	tr[now].rc=trlen+1, build(mid+1, r);
	pushup(now);
}
void update(int now, int l, int r, int c) {
	if(tr[now].l>=l&&tr[now].r<=r) {
		tr[now].mn=c; return ;
	}
	int mid=(tr[now].l+tr[now].r)>>1;
	if(l<=mid) update(lc(now), l, r, c);
	if(r>mid) update(rc(now), l, r, c);
	pushup(now);
}
type query(int now, int c) {
	if(tr[now].l==tr[now].r) return {tr[now].l, tr[now].mn};
	int L=(tr[lc(now)].mn>c)?(tr[lc(now)].mn-c):0;
	int R=(tr[rc(now)].mn>c)?(tr[rc(now)].mn-c):0;
	if(L<=R) return query(lc(now), c);
	else return query(rc(now), c);
}
signed main() {
	n=read(); m=read();
	for(int i=1;i<=n;i++) {
		a[i]={read(), read(), i};
	}
	sort(a+1, a+1+n, cmp);
	build(1, m);
	for(int i=1;i<=m;i++) update(1, i, i, 0);
	for(int i=1;i<=n;i++) {
		int now=a[i].st;
		type tp=query(1, now);
		as[tp.p].push_back(a[i].id);
		update(1, tp.p, tp.p, max(now, tp.t)+a[i].d); 
	}
	for(int i=1;i<=m;i++) {
		printf("%lld ", as[i].size());
		sort(as[i].begin(), as[i].end());
		for(int j:as[i]) printf("%lld ", j);
		puts("");
	}
	return 0;
}
```

---

## 作者：cff_0102 (赞：3)

考虑对每个打印机记录下它会在什么时候开始变得空闲。那么，就需要做到：

- 修改某个打印机的空闲时间。
- 查找编号最小的空闲时间 $\le x$ 的打印机的编号，如果没有就查找空闲时间最早的那个打印机编号。

直接线段树二分即可解决。

赛时代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
using pii=pair<int,int>;
using piii=pair<pii,int>;
//文件：下发命令的时刻；打印时间；编号 
//只需要支持：单点修改、查询编号最小的小于等于 x（若无，则最小）的数的位置 
//segtree 即可 
vector<int>pri[N];
piii fi[N];
int n,m;
struct segt{
	struct node{
		int l,r,mn;
	}a[N<<2];
	#define lc(p) ((p)<<1)
	#define rc(p) (((p)<<1)|1)
	void build(int p,int l,int r){
		a[p].l=l,a[p].r=r;
		if(l==r)return;
		int mid=(l+r)>>1;
		build(lc(p),l,mid);
		build(rc(p),mid+1,r);
	}
	void ch(int p,int chp,int x){
		int l=a[p].l,r=a[p].r;
		if(chp<l||r<chp)return;
		if(l==r){
			a[p].mn=x;
			return;
		}
		ch(lc(p),chp,x);
		ch(rc(p),chp,x);
		a[p].mn=min(a[lc(p)].mn,a[rc(p)].mn);
	}
	pii query(int p,int x){
		int l=a[p].l,r=a[p].r;
		if(l==r)return {l,a[p].mn};
		if(max(a[lc(p)].mn,x)<=max(a[rc(p)].mn,x))return query(lc(p),x);
		return query(rc(p),x);
	}
}st;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int s,t;cin>>s>>t;
		fi[i]={{t,s},i};
	}
	sort(fi+1,fi+1+n);
	st.build(1,1,m);
	for(int i=1;i<=n;i++){
		auto tmp=fi[i];
		int s=tmp.first.second,t=tmp.first.first,x=tmp.second;
		auto tmp1=st.query(1,t);
		int xx=tmp1.first,num=tmp1.second;
		pri[xx].emplace_back(x);
		num=max(num,t);
		st.ch(1,xx,num+s);
	}
	for(int i=1;i<=m;i++){
		sort(pri[i].begin(),pri[i].end());
		cout<<pri[i].size();
		for(int x:pri[i])cout<<" "<<x;
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：WZWZWZWY (赞：3)

以“时刻”为轴（忘记画轴了），把一个文件当成一个线段，以命令时间为起点，打印时间为长度，这条线段就是 $[t_i,t_i+s_i)$。注意一条线段表示的区间包括左端点不包括右端点。

![](https://cdn.luogu.com.cn/upload/image_hosting/23dwj8r5.png)

例如上图 $m=3$，现在考虑三条线段，起点分别为 $t_i$、$t_{i+1}$、$t_{i+2}$，长度分别为 $s_i$、$s_{i+1}$、$s_{i+2}$（已经将线段按左端点排序）。

一个“时刻”被线段覆盖的次数，就是这个时刻需要的打印机的数量，所以我们要**控制每个时刻的打印机数量小于等于 $m$**。

这时候添加一条线段 $i+3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d14hx8h8.png)

时刻 $t_{i+3}$ 被覆盖了 $4$ 次，大于打印机的数量，所以不能添加这条线段。于是把这条线段向右平移到右边的黄线上，即最前面的一个右端点，使用线段 $i$ 使用过的打印机。

![](https://cdn.luogu.com.cn/upload/image_hosting/l012gk6k.png)


这下左端点变成了 $t_i+s_i$，右端点变成了 $(t_i+s_i)+s_{i+3}$。

那么我们就可以建个优先队列，存每个遍历到的右端点，然后按权值从小到大排序，若权值相等则按线段编号从小到大排序（题目要求的）。

上面那个是“左端点比优先队列里存的右端点都小”的情况，那如果左端点比一些点大呢？这就更简单了，只需要选择编号最小的点就可以了，可以再建一个优先队列维护所有“第一个优先队列里的元素比当前左端点小”的元素。

总而言之，更新完第二个优先队列后，若第二个优先队列里有元素，则取队头并弹出；否则取第一个优先队列的队头并弹出。再把这个线段的右端点加入第一个优先队列。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

typedef pair <int, int> PII;
const int N = 2e5 + 5, INF = 1e18;

struct node {
	int s, t, id;
} a[N];
bool cmp(node a, node b) {
	return a.t < b.t;
}

struct node2 {
	int tim, id; // 时间，打印机编号 
};
struct cmp2 {
	bool operator() (node2 a, node2 b) { 
		if (a.tim == b.tim) return a.id > b.id;
		return a.tim > b.tim; 
	} // 注意优先队列排序时符号是反着的 
};
struct cmp3 {
	bool operator() (node2 a, node2 b) {
		return a.id > b.id;
	}
};

priority_queue <node2, vector <node2>, cmp2> q; 
priority_queue <node2, vector <node2>, cmp3> q2;
vector <int> ans[N];

signed main() {
	cin.tie(0); ios::sync_with_stdio(0);
	int n, m; cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].s >> a[i].t;
		a[i].id = i;
	}
	sort(a + 1, a + 1 + n, cmp);
	
	for (int i = 1; i <= m; i++) q.push({0, i});

	for (int i = 1; i <= n; i++) {
		while (q.size() && q.top().tim <= a[i].t) {
			q2.push(q.top());
			q.pop();
		}
		
		if (q2.size()) {
			int tim = q2.top().tim, id = q2.top().id;
			int tim2 = a[i].t + a[i].s;
			q2.pop();

			ans[id].push_back(a[i].id);
			q.push({tim2, id});		
		} else {
			int tim = q.top().tim, id = q.top().id;
			int tim2 = tim + a[i].s;
			q.pop();

			ans[id].push_back(a[i].id);
			q.push({tim2, id});			
		}
	}
	for (int i = 1; i <= m; i++) {
		cout << ans[i].size();
		sort(ans[i].begin(), ans[i].end());
		for (auto v : ans[i]) cout << " " << v;
		cout << "\n";
	}
	return 0;
}
```

看得出来，因为懒所以部分代码是复制粘贴上一段的（大雾

觉得写的好就点个赞吧。如果有什么问题或者建议也可以发在评论区哦。

---

## 作者：Yoimiya_miii (赞：3)

# 题解：P11289 【MX-S6-T1】「KDOI-11」打印
## 锐评
不得不说作为一道模拟题它是非常好的，类似于廊桥分配这题。\
但是**谴责黑心大样例！！！**
## 题意
对于每一个文件，选择一个编号最小以及等待时间最短的打印机进行打印。
## 40Pts TLE
使用一个优先队列存储每个节点信息，然后每次取队顶，对于每一次时间增加我们重新更新队列。\
由于优先队列不支持直接修改，也没有迭代器，因此我们只能一个一个更新出队再进队，所以非常费时。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn int(2e5)
#define _for(a,b,c) for(int i = a;i <= b;i+=c)
struct p{
	int nxt,id;
	bool operator < (const struct p &a) const{
		return nxt == a.nxt ? id > a.id : nxt > a.nxt;
	}
};
priority_queue<p> q;
struct wj{
	int s,t,id;
} w[maxn];
bool cmp(wj A,wj B){return A.t < B.t;}
int read(){
    int X=0,w=0; char c=0;
    while(c<'0'||c>'9') {w|=c=='-';c=getchar();}
    while(c>='0'&& c<='9') X=(X<<3)+(X<<1)+(c^48),c=getchar();
    return w? -X : X;
}
vector<int> ans[maxn+10];
int c1[maxn+10],c2[maxn+10];
signed main(){
	//freopen("print3.in","r",stdin);
	//freopen("print.txt","w",stdout);
	int n = read(),m = read();
	_for(1,n,1) w[i].s = read(),w[i].t = read(),w[i].id = i;
	sort(w+1,w+1+n,cmp);
	_for(1,m,1) q.push(p{0,i}); 
	_for(1,n,1){
		int tot = 0;
		while(!q.empty()){
			int tmp1 = q.top().nxt;
			tmp1 -= (w[i].t - w[i-1].t);
			if(tmp1 < 0) tmp1 = 0;
			int tmp2 = q.top().id;
			q.pop();
			c1[++tot] = tmp1,c2[tot] = tmp2;
		}
		for(int j = 1;j <= tot;j++){
			q.push((p){c1[j],c2[j]});
		}
		//printf("%d %d\n",q.top().nxt,q.top().id);
		ans[q.top().id].push_back(w[i].id);
		int tmp = q.top().nxt + w[i].s;
		int tmp2 = q.top().id;
		q.pop();
		q.push((p){tmp,tmp2}); 
	}
	_for(1,m,1){
		printf("%d ",ans[i].size());
		sort(ans[i].begin(),ans[i].end());
		for(int j = 0;j < ans[i].size();j++) printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
} 
```
## About 60 Pts
这个原因各有吧，至少我自己是没有考虑没有打印机空闲的情况。
## 正解
还是优先队列，但是这次变成了两个。\
一个用于存储没有打印任务的打印机，一个存储有任务的打印机。\
如果有打印机没有打印任务直接选择里面最小的。\
否则，找到等待时间最小的那一个。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 200010;
#define int long long
int n,m;
struct node{int s,t,id;}a[maxn];
bool cmp(node &A,node &B){return A.t<B.t;}
struct print{
    int id,t;
    bool operator < (const print &x)const{
        return t==x.t ? id>x.id : t>x.t;
    }
};    
priority_queue <print> q;
priority_queue <int,vector<int>,greater<int> > v;
priority_queue <int,vector<int>,greater<int> > ans[maxn];
int read(){
    int X=0,w=0; char c=0;
    while(c<'0'||c>'9') {w|=c=='-';c=getchar();}
    while(c>='0'&& c<='9') X=(X<<3)+(X<<1)+(c^48),c=getchar();
    return w? -X : X;
}
signed main(){
    int n = read(),m = read();
    for(int i = 1;i <= n;i++) a[i].s = read(),a[i].t = read(),a[i].id=i;
    sort(a+1,a+1+n,cmp);
    for(int i = 1;i <= m;i++) v.push(i);
    for(int i = 1;i <= n;i++){
        while(q.size() && q.top().t <= a[i].t) v.push(q.top().id),q.pop();
        if(v.empty()) ans[q.top().id].push(a[i].id),q.push({q.top().id,q.top().t+a[i].s}),q.pop();
        else ans[v.top()].push(a[i].id),q.push({v.top(),a[i].s+a[i].t}),v.pop();
    }
    for(int i = 1;i <= m;i++){
        printf("%d ",ans[i].size());
        for(int j = 0;j < ans[i].size();j++){
            while(!ans[i].empty()){
                printf("%d ",ans[i].top());
                ans[i].pop();
            }      
        }
        printf("\n");
    }
    if(1+1==3) cout << "I_I_A_K_I_O_I!!!!";
    return 0;
}
```

---

## 作者：wbh20090611 (赞：2)

一种更新的方法。

### 45 分的朴素做法：

**首先**，给所有的文件按照排序，并且对于每一个打印机，我们使他们初始的可以使用的时间为零。  
**然后**，对于每一次打印操作，枚举每个文件和每个打印机求出最小值。

但是，这个算法最坏情况的时间复杂度是 $O(nm + n \log n)$，瓶颈在找最小值。

**考虑优化**

### 100 分做法：

我们可以用线段树维护打印机结束打印的时间和编号。  
其中以结束打印的时间为下标。  
通过区间查询 $[0, ti]$ 获取答案。  
但是，最大的时间可能到 $2 \times {10}^{14}$，  
所以考虑用动态开点线段树解决这个问题。  
对于一个节点存储多个点的时候，直接用一个小根堆处理。  
其他均按 45 分暴力做法做即可。

最好时间复杂度 $O(n \log n + (50 + \log n) n)$。

最坏时间复杂度 $O(n \log n + (50 \log m + \log n) n)$。

上代码：


```cpp
#include <bits/stdc++.h>
#define mid ((root->l + root->r) >> 1ll)
#define int long long
using namespace std;
const int N = 200005;
int n, m, t[N], ti;
struct pii
{
	int a, b, c;
}s[N];
struct node
{
	int minn, l, r;
	priority_queue <int, vector <int>, greater<int> > p;
	node *lef, *rig;
} *r;
multiset <int> ss; 
vector <int> f[N];
bool cmp (pii a, pii b)
{
	return a.b == b.b ? a.a < b.a : a.b < b.b;
}
//上传 
void update(node *root, int x, int num)
{
	if (root->l == root->r)
	{
		root->p.push(num);
		root->minn = root->p.top();
		return;
	}
	if (x > mid)
	{
		if (root->rig == NULL)
		{
			node *y = new node;
			y->lef = y->rig = NULL;
			y->l = mid + 1ll;
			y->r = root->r;
			root->rig = y;
		}
		update(root->rig, x, num);
		if (root->lef == NULL)
			root->minn = root->rig->minn;
		else
			root->minn = min(root->lef->minn, root->rig->minn);
	}
	else
	{
		if (root->lef == NULL)
		{
			node *y = new node;
			y->lef = y->rig = NULL;
			y->l = root->l;
			y->r = mid;
			root->lef = y;
		}
		update(root->lef, x, num);
		if (root->rig == NULL)
			root->minn = root->lef->minn;
		else
			root->minn = min(root->lef->minn, root->rig->minn);
	}
	return;
}
//删除 
bool del(node *root, int x)
{
	if (root->l == root->r)
	{
		root->p.pop();
		if (!root->p.empty())
			root->minn = root->p.top();
		return root->p.empty();
	}
	if (x > mid)
	{
		bool t = del(root->rig, x);
		if (t)
			free(root->rig), root->minn = (1ll << 50ll), root->rig = NULL;
		else
			root->minn = root->rig->minn;
		if (root->lef == NULL)
			return t;
		else
			root->minn = min(root->minn, root->lef->minn);
		return false;
	}
	else
	{
		bool t = del(root->lef, x);
		if (t)
			free(root->lef), root->minn = (1ll << 50ll), root->lef = NULL;
		else
			root->minn = root->lef->minn;
		if (root->rig == NULL)
			return t;
		else
			root->minn = min(root->minn, root->rig->minn);
		return false;
	}
}
//区间查询 
int query(node *root, int x)
{
	if (root->r <= x)
		return root->minn;
	if (root->l == root->r && root->r > x)
		return (1ll << 50ll);
	int pp = (1ll << 50ll);
	if (x > mid && root->rig != NULL)
		pp = min(pp, query(root->rig, x));
	if (x >= root->l && root->lef != NULL)
		pp = min(pp, query(root->lef, x));
	return pp;
}
signed main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		scanf("%lld%lld", &s[i].a, &s[i].b), s[i].c = i;
	sort(s + 1, s + 1 + n, cmp);
	r = new node;
	r->minn = (1ll << 50ll);
	r->l = 0;
	r->r = (1ll << 50ll);
	r->rig = r->lef = NULL;
	for (int i = 1; i <= m; i++)
		ss.insert(0), update(r, 0, i); //用 multiset 存储深度 
	for (int i = 1; i <= n; i++)
	{
		ti = max((long long)(*(ss.begin())), (long long)s[i].b);
		int u = query(r, ti);
		del(r, t[u]);
		ss.erase(--ss.upper_bound(t[u]));
		t[u] = (long long)(ti) + (long long)(s[i].a); // t 数组用于存储深度 
		f[u].push_back(s[i].c); // vector 数组记录 
		ss.insert(t[u]);
		update(r, t[u], u); // 上传 
	}
	for (int i = 1; i <= m; i++)
	{
		printf("%lld", f[i].size());
		sort(f[i].begin(), f[i].end()); // 排序后输出 
		for (auto j : f[i])
			printf(" %lld", j);
		printf("\n");
	}
}
```

---

## 作者：lfxxx_ (赞：2)

先对命令按照 $t_i$ 升序进行排序，方便处理。

我们定义 $pre_i$ 为这个打印机最后打印的时刻。

当对于所有的 $j$ 满足 $1\le j \le n$ 的 $pre_j$ 的最小值  $k$ 满足 $k \le t_i$  时，则我们找到最小的 $j$，使得 $pre_j\le t_i$，然后把 $j$ 号打印机最后打印的时刻修改为 $s_i+t_i$，同时让 $i$ 号指令给到 $j$ 号打印机。

否则，我们找到 $pre$ 数组里面最前面的 $k$，设其下表为 $j$，把 $j$ 号打印机的打印的最后时刻修改为 $s_i+k$，同时让 $i$ 号指令给到 $j$ 号打印机。

用线段树简单维护最小值以及单点修改即可。查找可以使用二分。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5,inf=0x3f3f3f3f3f3f3f3f;
vector<int>ans[N];
int tr[N<<2];
struct node{int s,t,id;}a[N];
bool cmp(node n1,node n2){return n1.t<n2.t;}
void pushup(int p){tr[p]=min(tr[p<<1],tr[p<<1|1]);}
void update(int p,int pl,int pr,int x,int d)
{
	if(x<pl||pr<x)
		return;
	if(pl==pr)
	{
		tr[p]+=d;
		return;
	}
	int mid=(pl+pr)>>1;
	update(p<<1,pl,mid,x,d);
	update(p<<1|1,mid+1,pr,x,d);
	pushup(p);
}
void change(int p,int pl,int pr,int x,int d)
{
	if(x<pl||pr<x)
		return;
	if(pl==pr)
	{
		tr[p]=d;
		return;
	}
	int mid=(pl+pr)>>1;
	change(p<<1,pl,mid,x,d);
	change(p<<1|1,mid+1,pr,x,d);
	pushup(p);
}
int query(int p,int pl,int pr,int L,int R)
{
    if(R<pl||pr<L)
        return inf;
    if(L<=pl&&pr<=R)
        return tr[p];
    int mid=(pl+pr)>>1;
    return min(query(p<<1,pl,mid,L,R),query(p<<1|1,mid+1,pr,L,R));
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i].s>>a[i].t,a[i].id=i;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)
	{
		// cout<<'\n';
		int l=0,r=m+1,k=tr[1];
		if(k<=a[i].t)
		{
			while(l+1<r)
			{
				int mid=(l+r)>>1;
				if(query(1,1,m,1,mid)<=a[i].t)
					r=mid;
				else
					l=mid;
			}
			change(1,1,m,r,a[i].t+a[i].s);
			ans[r].emplace_back(a[i].id);
		}
		else
		{
			while(l+1<r)
			{
				int mid=(l+r)>>1;
				if(query(1,1,m,1,mid)==k)
					r=mid;
				else
					l=mid;
			}
			update(1,1,m,r,a[i].s);
			ans[r].emplace_back(a[i].id);
		}
	}
	for(int i=1;i<=m;i++)
	{
		sort(ans[i].begin(),ans[i].end());
		cout<<ans[i].size()<<' ';
		for(auto &j:ans[i])
			cout<<j<<" ";
		cout<<'\n';
	}
}
```

---

## 作者：SXqwq (赞：2)

闲话：大样例以及 $60$ 分的数据，全都是不需要等待的情况。所以你咋写挂都能过大样例。太神秘了。

首先将所有打印任务按照 $t$ 升序排序。

注意到**若不需要等待，选编号最小的。若需要等待，选等待时间最短的**。看上去非常优先队列。我们开两个优先队列 $q_1,q_2$ 分别维护需要等待的打印机，能直接使用的打印机。维护它们的编号和可使用的时间戳。判定能否直接使用只需比较时间戳和 $t$ 的大小即可。

初始化 $m$ 个打印机都是可直接使用的，全部放入 $q_2$ 中，时间戳为 $0$。按照编号升序排序。

每个打印机决策前，首先将 $q_1$ 中可使用的打印机扔到 $q_2$ 中，如下。

```cpp
while(wait.size() && wait.top().first <= t)
{
    release.push(PII(wait.top().second,wait.top().first));wait.pop();
}
```
其中，`wait` 为需要等待的打印机，`release` 为可直接使用的打印机。`wait` 的 `first,second` 分别为可使用的时间戳，打印机编号。按照时间戳升序排序。`release` 的 `first,second` 分别为为打印机编号和时间戳。按照打印机编号升序排序。

接下来，若 $q_2$ 中有元素，直接取队头即可。注意修改其时间戳。若修改后的时间戳，大于下一次任务的起始时间，就把它扔到 $q_1$ 中。

若 $q_2$ 中没有元素，该如何处理？此时必须要等待了。我们从 $q_1$ 中找到时间戳最小的打印机即可。**注意，时间戳最小的打印机并不一定唯一，若有多个最小的，需使用编号最小的！**

```cpp
if(!release.size()) 
{
    priority_queue <PII,vector<PII>,greater<PII> > printer;
    int flag = wait.top().first;
    printer.push(PII(wait.top().second,wait.top()first));
    wait.pop();
    while(wait.top().first == flag){printer.push(PII(wait.to().second,wait.top().first));wait.pop();}
    release.push(PII(printer.top().first,flag));
    printer.pop();
    while(!printer.empty()){wait.push(PII(printer.top()second,printer.top().first));printer.pop();}
    }
```
实现略微繁琐。仅供参考。

完整代码如下。

```cpp
namespace solution
{
    typedef pair<int,int> PII; // time,number
    struct ASK
    {
        int s,t,num;
        bool operator<(const ASK &a)const{
            return t < a.t;
        }
    };
    vector <ASK> ask;
    vector <int> ans[N];
    priority_queue <PII,vector<PII>,greater<PII> > wait,release;
    int n,m;
    int tot = 0; //wait:time,number
    void solve()
    {
        n = read<int>(),m = read<int>();
        for(int i=1;i<=n;i++) {int s,t; s = read<int>(),t = read<int>();ask.push_back({s,t,i});}
        for(int i=1;i<=m;i++) release.push(PII(i,0)); //number,time
        sort(ask.begin(),ask.end());
        for(auto [s,t,num]:ask)
        {
            while(wait.size() && wait.top().first <= t){release.push(PII(wait.top().second,wait.top().first));wait.pop();}
            if(!release.size()) 
            {
                priority_queue <PII,vector<PII>,greater<PII> > printer;
                int flag = wait.top().first;
                printer.push(PII(wait.top().second,wait.top().first));
                wait.pop();
                while(wait.top().first == flag){printer.push(PII(wait.top().second,wait.top().first));wait.pop();}
                release.push(PII(printer.top().first,flag));
                printer.pop();
                while(!printer.empty()){wait.push(PII(printer.top().second,printer.top().first));printer.pop();}
            }
            ans[release.top().first].push_back(num);
            auto tt = release.top().second;
            tt = max(release.top().second,t) + s;
            tot ++;
            if(tot >= n) break;
            if(tt > ask[tot].t) {wait.push(PII(tt,release.top().first));release.pop();}
            else 
            {
                int number = release.top().first;
                release.pop();
                release.push(PII(number,tt));
            }
        }
        for(int i=1;i<=m;i++) sort(ans[i].begin(),ans[i].end()); // 输出前记得排个序
        for(int i=1;i<=m;i++) {print(ans[i].size(),' ');for(auto t:ans[i])print(t,' '); puts("");}
    }
}
```

---

## 作者：Laisira (赞：1)

### 思路
比较简单的小签题。

让我们维护到时间 $t_i$ 的等待时间最短编号最小的机器，于是用平衡树维护每个机器完成当前工作的时间，然后特殊的，每一个在 $t_i$ 之前完成工作的机器都等待时间都相同而且至少有一个数，于是答案即平衡树上权值大于 $t_i$ 与所有最小完成时间的最大值的编号最小值。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 1000005 
using namespace std;
int val[Maxn],sz[Maxn],id[Maxn],sgt[Maxn],minv[Maxn],lson[Maxn],rson[Maxn],prio[Maxn],rt,tot;
void pushup(int x) {
	minv[x] = val[x];
	if(lson[x])minv[x] = min(minv[x],minv[lson[x]]);
	if(rson[x])minv[x] = min(minv[x],minv[rson[x]]);
	sgt[x] = x;
	if(lson[x]&&id[sgt[lson[x]]] < id[sgt[x]])sgt[x] = sgt[lson[x]];
	if(rson[x]&&id[sgt[rson[x]]] < id[sgt[x]])sgt[x] = sgt[rson[x]];
	sz[x] = sz[lson[x]] + sz[rson[x]] + 1;
}
int NewNote(int k,int d) {
	id[++tot] = d;
	val[tot] = k;
	prio[tot] = rand();
	sz[tot] = 1;
	minv[tot] = val[tot];
	sgt[tot] = tot;
	return tot;
}
void split(int now,int bound,int Id,int &x,int &y) {
	if(!now)return x = y = 0,void();
	if(val[now] < bound||(val[now] == bound&&id[now] <= Id)) {
		x = now;
		split(rson[now],bound,Id,rson[now],y);
	} else {
		y = now;
		split(lson[now],bound,Id,x,lson[now]);
	} pushup(now);
}
int Merge(int x,int y) {
	if(!x || !y)return x + y;
	if(prio[x] <= prio[y]) {
		rson[x] = Merge(rson[x],y);
		pushup(x); return x;
	} else {
		lson[y] = Merge(x,lson[y]);
		pushup(y); return y;
	}
}
void Insert(int k,int d) {
	int x,y = NewNote(k,d),z;
	split(rt,k,d,x,z);
	rt = Merge(x,Merge(y,z));
}
vector<int> q[Maxn];
struct node {
	int s,t,id;
	bool operator<(const node&is)
	const{return t < is.t;}
} r[Maxn];
signed main()
{
//	freopen("print1.in","r",stdin);
//	freopen("print.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
//	cout<<n<<" "<<m<<"\n";
	for(int i=1;i<=m;i++)
		Insert(1,i);
	for(int i=1;i<=n;i++)
		cin>>r[i].s>>r[i].t,r[i].id = i;
	sort(r+1,r+1+n);
	for(int i=1;i<=n;i++) {
//		cout<<r[i].id<<" ";
		int s = r[i].s,t = r[i].t;
		int w = max(t,minv[rt]),x,y,z;
//		cout<<w<<" ";
		split(rt,w,m,x,y);
//		cout<<id[x]<<" "<<id[y]<<" ";
		// x 中含要找的 
		int p = sgt[x],w1 = val[p],I = id[p];
//		cout<<id[p]<<" "<<w1<<" "<<I<<"\n";
		q[I].push_back(r[i].id);
		rt = Merge(x,y);
		split(rt,w1,I-1,x,y);
		split(y,w1,I,y,z);
//		cout<<id[y]<<"\n";
		y = Merge(lson[y],rson[y]);
		rt = Merge(x,Merge(y,z));
		Insert(max(w1,t)+s,I);
	}
	for(int i=1;i<=m;i++) {
		cout<<q[i].size();
		if(q[i].size())cout<<" "; 
		sort(q[i].begin(),q[i].end());
//		for(int u:q[i])cout<<u<<" ";
		for(int j=0;j<(int)q[i].size();j++) {
			cout<<q[i][j];
			if(j != (int)q[i].size()-1)cout<<" ";
		}
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：GI录像机 (赞：1)

## 思路

考虑直接维护每台打印机的等待时间，线段树上二分查找最小值的最小编号。

先把文件按 $t_i$ 排序，每次给全局减上 $t_i-t_{i-1}$（注意要和 $0$ 取 max）。然后线段树上二分找到要使用的打印机。最后再给要使用的这台单点加一就行了。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(c > '9' || c < '0') {
		if(c == '-')f = -f;
		c = getchar();
	}
	while(c <= '9' && c >= '0') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
void write(int x) {
	if(x < 0) {
		putchar('-');
		x = -x;
	} if(x > 9)write(x / 10);
	putchar((x % 10) + '0');
}
const int N = 2e5 + 10, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
int n, m, minn[N << 2], lazy[N << 2];
struct Node {
	int s, t, id;
}a[N];
bool cmp(Node x, Node y) {
	return x.t < y.t;
}
vector<int>ans[N];
void pushup(int pos) {
	minn[pos] = min(minn[pos << 1], minn[pos << 1 | 1]);
}
void pushdown(int pos) {
	if(lazy[pos]) {
		minn[pos << 1] = max(minn[pos << 1] + lazy[pos], 0ll);
		minn[pos << 1 | 1] = max(minn[pos << 1 | 1] + lazy[pos], 0ll);
		lazy[pos << 1] += lazy[pos], lazy[pos << 1 | 1] += lazy[pos];
		lazy[pos] = 0;
	}
}
void add(int pos, int l, int r, int L, int R, int k) {
	if(L <= l && r <= R) {
		minn[pos] = max(minn[pos] + k, 0ll);
		lazy[pos] += k;
		return;
	}
	int mid = (l + r) >> 1;
	pushdown(pos);
	if(L <= mid)add(pos << 1, l, mid, L, R, k);
	if(mid + 1 <= R)add(pos << 1 | 1, mid + 1, r, L, R, k);
	pushup(pos);
}
int query(int pos, int l, int r) {
	if(l == r)return l;
	int mid = (l + r) >> 1;
	pushdown(pos);
	if(minn[pos << 1] <= minn[pos << 1 | 1])return query(pos << 1, l, mid);
	return query(pos << 1 | 1, mid + 1, r);
}
signed main() {
	//freopen("print.in", "r", stdin);
	//freopen("print.out", "w", stdout);
	n = read(), m = read();
	for(int i = 1; i <= n; i++)a[i].s = read(), a[i].t = read(), a[i].id = i;
	sort(a + 1, a + n + 1, cmp);
	for(int i = 1; i <= n; i++) {
		add(1, 1, m, 1, m, -(a[i].t - a[i - 1].t));
		int idx = query(1, 1, m);
		ans[idx].push_back(a[i].id);
		add(1, 1, m, idx, idx, a[i].s);
	}
	for(int i = 1; i <= m; i++) {
		sort(ans[i].begin(), ans[i].end());
		write(ans[i].size());
		putchar(' ');
		for(int j = 0; j < ans[i].size(); j++) {
			write(ans[i][j]);
			if(j != ans[i].size() - 1)putchar(' ');
		}
		if(i != m)putchar('\n');
	}
	return 0;
}

```

---

## 作者：xibaohe (赞：1)

# 题目大意
有 $m$ 台打印机，编号从 $1$ 到 $m$。有 $n$ 个文件要打印。第 $t_i$ 时刻下发打印命令，打印需要 $s_i$ 的时间。
每次选择等待时间最短的打印机，**如有多个，选择编号最小的。**

# 解题思路
看到这道题，第一思路是用优先队列记录等待时间最短的，每次输出队首。但可以观察到题目中要求输出编号最小的，如果有多个满足要求，就会出现问题。因此，本题至少需要 $2$ 个优先队列。

# 思路实现
首先可以用一个优先队列 $q$ 记录满足要求、可以打印的打印机，重载运算符使该优先队列按编号排序。

```cpp
priority_queue<node> q;
bool operator<(node x,node y)
{
	return x.id>y.id;
}
```

然后再用一个优先队列 $wt$ 记录正在打印中的打印机，按时间从小到大排序。


```cpp
priority_queue<node2> wt;
bool operator<(node2 x,node2 y)
{
	if(x.fi==y.fi) return x.id>y.id;
	return x.fi>y.fi;
}
```

每次更新时，只要 $q$ 非空，就用 $q$ 中第一个元素进行打印，否则就用 $wt$ 中第一个元素进行打印。


```cpp
for(int i=1;i<=n;i++)
{
		while(!wt.empty()&&wt.top().fi<=a[i].t)
		{
			q.push({wt.top().id,wt.top().fi});
			wt.pop();
		}
		if(!q.empty()) 
		{
			node us=q.top();
			q.pop();
			ans[us.id].push(a[i].id);
			wt.push({us.id,a[i].t+a[i].s});
		}
		else
		{
			node2 us=wt.top();
			wt.pop();
			ans[us.id].push(a[i].id);
			wt.push({us.id,us.fi+a[i].s});
		}
}
```

# 注意事项
- 要将打印任务数组进行排序。

- 不开 `long long` 见祖宗。

# 满分代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,idx;
priority_queue<int,vector<int>,greater<int> > ans[200005];
struct task
{
	int s,t,id;
} a[200005];
struct node
{
	int id,fi;
};
struct node2
{
	int id,fi;
};
priority_queue<node> q;
bool operator<(node x,node y)
{
	return x.id>y.id;
}
priority_queue<node2> wt;
bool operator<(node2 x,node2 y)
{
	if(x.fi==y.fi) return x.id>y.id;
	return x.fi>y.fi;
}
bool cmp(task x,task y)
{
	return x.t<y.t;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].s>>a[i].t;
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=m;i++)
	{
		q.push({i,0});
	}
	for(int i=1;i<=n;i++)
	{
		while(!wt.empty()&&wt.top().fi<=a[i].t)
		{
			q.push({wt.top().id,wt.top().fi});
			wt.pop();
		}
		if(!q.empty()) 
		{
			node us=q.top();
			q.pop();
			ans[us.id].push(a[i].id);
			wt.push({us.id,a[i].t+a[i].s});
		}
		else
		{
			node2 us=wt.top();
			wt.pop();
			ans[us.id].push(a[i].id);
			wt.push({us.id,us.fi+a[i].s});
		}
	}
	for(int i=1;i<=m;i++)
	{
		int sz=ans[i].size();
		cout<<sz<<" ";
		while(!ans[i].empty())
		{
			cout<<ans[i].top()<<" ";
			ans[i].pop();
		}
		cout<<endl;
	}
	return 0;
}


```

---

## 作者：shuqiang (赞：1)

这题有一个非常方便的方法，就是用线段树来存区间最小值。

用 $a_i$ 存第 $i$ 台打印机会在什么时候完成打印，那么设当前时间为 $t$，那么等待时间就是 $\max(a_i - t, 0)$。

首先，我们要建一颗树：

```cpp
void build(int u, int l, int r){
	if(l == r){
		segt[u] = 0;
		return;
	}
	int mid = (l + r) / 2;
	build(u*2, l, mid);
	build(u*2+1, mid+1, r);
	segt[u] = min(segt[u*2], segt[u*2+1]);
}
```

这里用 `segt` 数组来存某个区间的最小值。

然后就要打印文件了，要找到等待时间最短且编号最小的打印机，我们可以在这个线段树上搜索：


```cpp
int update(int u, int l, int r, int ad, int t){
	if(l == r){
		segt[u] = t + max(segt[u] - t, 0ll) + ad;
		return l;
	}
	int mid = (l + r) / 2, ret;
	if(max(segt[u*2] - t, 0ll) == max(segt[u] - t, 0ll)){
		ret = update(u*2, l, mid, ad, t);
	}
	else{
		ret = update(u*2+1, mid+1, r, ad, t);
	}
	segt[u] = min(segt[u*2], segt[u*2+1]);
	return ret;
}
```

从根节点开始，如果左儿子的最小等待时间和这个节点的最小等待时间相等，说明左边的区间中有等待时间最小的打印机，因为题目要求编号最小，所以可以不用考虑右边，找到了后，可以顺便把当前的打印文件命令下发给这个打印机。

等待时间的刷新有两种可能：
1. 当前已经没有打印任务，那么结束时间即为 $s_i+t_i$。
2. 当前还有打印任务，答案是原来的打印时间加 $s_i$。

综上，设完成打印时间为 $a_i$，答案可以合并成 $s_i+t_i+\max(a_i-t_i,0)$。

最后为了方便统计答案，可以把打印文件的打印机编号返回。

AC 代码：

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;
typedef long long ll;

const int N = 2e5 + 10;
int n, m;
vector<int> ans[N];

struct Thing{
	int id, s, t;
	
	bool operator < (const Thing & o) const{
		return t < o.t;
	}
} a[N];

ll segt[N * 31];

void build(int u, int l, int r){
	if(l == r){
		segt[u] = 0;
		return;
	}
	int mid = (l + r) / 2;
	build(u*2, l, mid);
	build(u*2+1, mid+1, r);
	segt[u] = min(segt[u*2], segt[u*2+1]);
}

int update(int u, int l, int r, int ad, int t){
	if(l == r){
		segt[u] = t + max(segt[u] - t, 0ll) + ad;
		return l;
	}
	int mid = (l + r) / 2, ret;
	if(max(segt[u*2] - t, 0ll) == max(segt[u] - t, 0ll)){
		ret = update(u*2, l, mid, ad, t);
	}
	else{
		ret = update(u*2+1, mid+1, r, ad, t);
	}
	segt[u] = min(segt[u*2], segt[u*2+1]);
	return ret;
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		cin >> a[i].s >> a[i].t;
		a[i].id = i;
	}
	sort(a + 1, a + 1 + n);
	build(1, 1, m);
	for(int i = 1; i <= n; i++){
		ans[update(1, 1, m, a[i].s, a[i].t)].push_back(a[i].id);
	}
	for(int i = 1; i <= m; i++){
		sort(ans[i].begin(), ans[i].end());
		cout << ans[i].size();
		for(int j: ans[i]) cout << ' ' << j;
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：wdsjl (赞：1)

# 题目大意
给定打印任务的开始时间和持续时间，求每个打印机打印的任务数量和编号（会优先选择编号小的打印机）。
# 思路分析
我们开两个优先队列，分别维护当前空闲打印机（按照编号为第一关键字）；和当前有任务打印机（按照任务结束时间为第一关键字，编号为第二关键字）。

注意：需要开 longlong 的变量!
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+10;

int n,m;

vector <int> pr[N];

struct node{
	int ed;
	int idx;
};

struct node1{
	int ed;
	int idx;
};

struct fil{
	int st;
	int vl;
	int idx;
}tx[N];

bool cmp(const fil &x,const fil &y){
	return x.st<y.st;
}

priority_queue <node> q;
priority_queue <node1> q_u;

bool operator <(const node &x,const node &y){
	return x.idx>y.idx;
} 

bool operator <(const node1 &x,const node1 &y){
	if(x.ed==y.ed)return x.idx>y.idx;
	return x.ed>y.ed;
}

signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&tx[i].vl,&tx[i].st);
		tx[i].idx=i;
	}
	sort(tx+1,tx+1+n,cmp);
	for(int i=1;i<=m;i++)q.push((node){0,i});
	for(int i=1;i<=n;i++){
		while(q_u.size()&&q_u.top().ed<=tx[i].st){
			node1 k=q_u.top();
			node k1={k.ed,k.idx};
			q_u.pop();
			q.push(k1);
		}
		if(q.empty()){
			node1 k=q_u.top();
			node k1={k.ed,k.idx};
			q_u.pop();
			q.push(k1);
		}
		node p=q.top();
		q.pop();
		pr[p.idx].push_back(tx[i].idx);
		p.ed=max(p.ed+tx[i].vl,tx[i].st+tx[i].vl);
		node1 o={p.ed,p.idx};
		q_u.push(o);
	}
	for(int i=1;i<=m;i++){
		sort(pr[i].begin(),pr[i].end());
		printf("%d",pr[i].size());
		for(int j=0;j<pr[i].size();j++)printf(" %lld",pr[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：szh_AK_all (赞：1)

这题还是比较一眼的。

## 分析
首先按照每个文件下发打印命令的时间顺序为每个文件进行排序，接着依次考虑整条时间轴上下发打印命令的文件。假设第 $i$ 个打印机在第 $k_i$ 时刻会完成打印任务（初始时 $k_i=0$），那么对于当前下发打印命令的文件 $x$，我们需要找到一台打印机 $y$ 使得 $t_x-k_y$ 最小，并且使用这台打印机，此时，这台打印机会在第 $t_y+s_x$ 时刻完成打印任务。这恰好可以用堆来维护。

但是注意到一个细节：$t_x-k_y$ 可能为 $0$。也就是当多台打印机完成打印任务的时间在当前文件下发打印命令的时间之前时，我们去比较每个 $t_x-k_y$ 的值便没有意义了，因为无论是这些打印机中的哪台，打印文件的等待时间都为 $0$，那么此时需要选择编号最小的那台打印机。这显然可以另开一个堆维护。

至此思路便明了了，首先我们将所有的打印机放入记录等待时间为 $0$ 的堆 $qq$ 中（按照编号排序），然后依次考虑每个打印命令。若此时的堆 $qq$ 不为空，则取出堆 $qq$ 的堆顶，并重新计算堆顶对应的打印机的完成任务的时刻，并加入记录完成打印任务时间的堆 $q$ 中（按照完成打印任务的时间排序）；若堆 $qq$ 为空，则取出堆 $q$ 的堆顶，按照类似的操作执行即可。

最后需要注意的是，若 $q$ 的堆顶对于当前打印任务来说，等待时间为 $0$，那么应当将它加入到堆 $qq$ 当中。由于我们已经将每个文件按照下发打印命令的时间排好序了，所以对于当前文件来说等待时间为 $0$，那么对于以后的文件来说打印时间也为 $0$；并且每次使用打印机时，我们只会更改一台打印机，所以最终堆的操作次数是 $O(n)$ 级别的。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

struct node {
	int s, t, id;
	friend bool operator<(node l, node r) {
		return l.t < r.t;
	}
} a[200005];

struct no {
	int ti, id;
	friend bool operator<(no l, no r) {
		if (l.ti != r.ti)
			return l.ti > r.ti;
		return l.id > r.id;
	}
	no(int aa = 0, int bb = 0) {
		ti = aa;
		id = bb;
	}
};

struct o {
	int ti, id;
	friend bool operator<(o l, o r) {
		return l.id > r.id;
	}
	o(int aa = 0, int bb = 0) {
		ti = aa;
		id = bb;
	}
};
priority_queue<no>q;
priority_queue<o>qq;
vector<int>g[200005];

signed main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].s >> a[i].t;
		a[i].id = i;
	}
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= m; i++)
		qq.push(o(0, i));
	for (int i = 1; i <= n; i++) {
		while (!q.empty() && q.top().ti <= a[i].t) {
			qq.push(o(q.top().ti, q.top().id));
			q.pop();
		}
		int x = 0;
		if (qq.empty()) {
			x = q.top().id;
			q.push(no(q.top().ti + a[i].s, q.top().id));
			q.pop();
		} else {
			x = qq.top().id;
			q.push(no(a[i].t + a[i].s, qq.top().id));
			qq.pop();
		}
		g[x].push_back(a[i].id);
	}
	for (int i = 1; i <= m; i++) {
		int k = g[i].size();
		cout << k << " ";
		sort(g[i].begin(), g[i].end());
		for (int j = 0; j < k; j++)
			cout << g[i][j] << " ";
		cout << "\n";
	}
}
```

---

## 作者：AK_400 (赞：0)

首先考虑暴力。按题意模拟，即按下发打印命令的时间排序文件，每次考虑新一个文件时枚举放入哪个打印机即可，复杂度 $O(nm)$，不能通过此题。

然后考虑优化，开两个优先队列，一个存当前可用的打印机，一个存正在使用的打印机，每枚举到一个文件，判断是否有可用的打印机，如果有，选择编号最小的，否则选择最早打印完的编号最小的打印机即可，时间复杂度 $O(n\log(n+m))$，可以通过。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
struct doc{
    int s,t,id;
}f[2000005];
priority_queue<int,vector<int>,greater<int>>id;//可用打印机
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>prt;//使用中打印机
vector<int>ans[200005];
bool cmp(doc x,doc y){
    return x.t<y.t;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>f[i].s>>f[i].t;
        f[i].id=i;
    }
    sort(f+1,f+1+n,cmp);
    for(int i=1;i<=m;i++){
        id.push(i);
    }
    for(int i=1;i<=n;i++){
        while(prt.size()&&prt.top().first<=f[i].t){//把使用完的加入到空闲中
            id.push(prt.top().second);
            prt.pop();
        }
        if(id.size()){//有可用打印机
            ans[id.top()].push_back(f[i].id);
            prt.push({f[i].t+f[i].s,id.top()});
            id.pop();
        }
        else{//无可用打印机
            ans[prt.top().second].push_back(f[i].id);
            auto top=prt.top();
            prt.pop();
            prt.push({top.first+f[i].s,top.second});
        }
    }
    for(int i=1;i<=m;i++){
        cout<<ans[i].size()<<" ";
        sort(ans[i].begin(),ans[i].end());
        for(int x:ans[i])cout<<x<<" ";
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：XCDRF_ (赞：0)

# P11289 【MX-S6-T1】「KDOI-11」打印 题解

[原题传送门](https://www.luogu.com.cn/problem/P11289)

[更好的阅读体验](https://www.luogu.com.cn/article/xb254c5x)

## 解题思路

看到题后，首先想暴力做法。

先对文件按时间开始早晚排序。对于每个文件，遍历一遍这时有没有打印机空着，如果有，那么选编号最小的。如果没有，那么就等到有空时再打印。

复杂度 $O(n^2)$，看数据范围，显然超时。

再想一想。每个文件都要尽快被打印，那我们只需要用一个堆来维护此时打印机空闲时间的最小值。对于每一个文件，如果堆顶小于它的开始时间，就用这台打印机打印。如果大于，则分两种情况。如果还能再用一个打印机，就再新用一个。如果不行，就等到有空时再打印。打印完后再把结束时间放到堆里，并维护一个 vector 存每个打印机都打印了那些文件即可。

但这个题真的这么简单吗？

注意到题目是让我们每次用编号最小的打印机打印，但用一个堆只能存储时间最小的，不能存编号最小的。这个简单，每次遍历一遍空闲时间小于该文件的开始时间的打印机，选出来编号最小的不就行了。

[彳亍。](https://www.luogu.com.cn/record/189383843)

这时我们想到，每一个文件打印的开始时间都不同，排序后就是单调递增的。如果这个打印机的空闲时间比前一个文件的开始时间都早，那肯定比后一个文件的开始时间早。

考虑再用一个堆来存储比现在的文件开始时间早的打印机，每次选出堆顶。如果这个堆是空的，就用原做法做。

时间复杂度来到了 $O(n\log n)$，问题得解。

## 注意事项

1. 记得开 long long。
2. 最后输出时别忘了对每个 vector 排序。
3. 第二个堆是根据打印机编号大小排序，别写反了。
4. 将打印机放进第二个堆里之前别忘弹出第一个堆。
5. 在执行如上操作之前就把开始时间最小的用编号为 $1$ 的打印机打印好，入堆。

## 参考代码

[代码](https://www.luogu.com.cn/paste/rw6t5k8c)

这个题细节还是很多的，写代码时一定要注意。

感谢管理大大审核，求通过 QwQ。

---

## 作者：Jadonyzx (赞：0)

一眼题，不就是[廊桥分配](https://www.luogu.com.cn/problem/P7913)吗？

然而因为考场没开 long long 挂到 $70$ 分，无语。

开两个优先队列，一个表示等待中的打印机，一个表示空闲的打印机，再开一个布尔数组表示是否空闲，维护即可。

具体流程：

首先把所有打印机放到空闲队列中。

将打印任务按照时间排序后依次处理。

对于每一个任务，如果有空闲的打印机，用空闲的打印机，否则取等待中时间最前的即可，具体实现看代码。


```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 200005
using namespace std;
namespace IO{
	inline int read(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-')f=-1;
			ch=getchar();
		}
		while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
		return x*f;
	}
	inline void write(int x){
		if(x<0){putchar('-');x=-x;}
		if(x>=10)write(x/10);
		putchar(x%10+'0');return;
	}
}
using namespace IO;
int n,m;
struct print_{int t,s,uid;}p[maxn];
bool cmp(print_ aaa,print_ bbb){
	if(aaa.t!=bbb.t)return aaa.t<bbb.t;
	return aaa.uid<bbb.uid;
}
priority_queue<pair<int,int>>qwait;
priority_queue<int>qsafe;
vector<int>ord[maxn];
bool judgeing[maxn];
signed main(){
// 	freopen("print.in","r",stdin);
// 	freopen("print.out","w",stdout);
	n=read();m=read();
	for(int i=1;i<=n;++i){
		p[i].s=read();
		p[i].t=read();
		p[i].uid=i;
	}
	sort(p+1,p+1+n,cmp);
	for(int i=1;i<=m;++i)qsafe.push(-i);
	for(int i=1;i<=n;++i){
		while(qwait.size()){
			auto now=qwait.top();
			if((-now.first)<=p[i].t){
				judgeing[-now.second]=0;
				qwait.pop();
				qsafe.push(now.second);
			}
			else break;
		}
		int id=0;judgeing[0]=1;
		while(judgeing[id]&&qsafe.size()){id=-qsafe.top();qsafe.pop();}
		if(id!=0&&!judgeing[id]){
			judgeing[id]=1;ord[id].push_back(p[i].uid);
			qwait.push(make_pair(-(p[i].t+p[i].s),-id));
		}
		else{
			auto orz=qwait.top();qwait.pop();
			int id=-orz.second;int tl=-orz.first;
			ord[id].push_back(p[i].uid);
			qwait.push(make_pair(-(tl+p[i].s),-id));
		}
	}
	for(int i=1;i<=m;++i){
		int siz=ord[i].size();
		write(siz);
		sort(ord[i].begin(),ord[i].end());
		for(auto j : ord[i]){putchar(' ');write(j);}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：naroto2022 (赞：0)

# P11289 题解

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P11289)

### 思路

题目浅显易懂，模拟题。

首先按下发命令的 $t$ 给它排序，接下来考虑一个个的分配给打印机。

由于每次会选择等待时间最短的打印机，所以可以用两个优先队列来维护，一个优先队列 $q$ 用来维护当前需要等待的打印机要等多久以及其编号，另一个 $num$ 用来维护不用等待的打印机的编号。

每一次先把已经打印完的打印机出队，并让这些打印机的编号插入 $num$，接下来开始判断当前这个文件该用哪个打印机来打印，有以下两种情况。

- $num$ 是空的，那么所有的打印机都需要等待，那就是等一等啦，就用 $q$ 最前面的那个打印机。
- $num$ 是非空的，那就直接用 $num$ 中编号最小的。

于是开始模拟，就过了。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#define ll long long
#define pll pair<ll,ll>
using namespace std;
const int MN=2e5+5;
ll n,m;
priority_queue<pll,vector<pll>,greater<pll> > q;
priority_queue<ll,vector<ll>,greater<ll> > num;
vector<ll> ans[MN];
struct point{ll s,t,id;}p[MN];
void write(ll n){if(n<0){putchar('-');write(-n);return;}if(n>9)write(n/10);putchar(n%10+'0');}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
bool cmp(point a, point b){return a.t<b.t;}
int main(){
    // freopen("print4.in","r",stdin);
    // freopen("1.out","w",stdout);
    n=read();m=read();
    for(int i=1; i<=n; i++) p[i].s=read(),p[i].t=read(),p[i].id=i;
    sort(p+1,p+1+n,cmp);
    for(int i=1; i<=m; i++) num.push(i);
    for(int i=1; i<=n; i++){
        while(!q.empty()&&q.top().first<=p[i].t) num.push(q.top().second),q.pop();//出队
        if(num.empty()){
            pll tmp=q.top();q.pop();
            ans[tmp.second].push_back(p[i].id);
            q.push({tmp.first+p[i].s,tmp.second});
        }
        else{
            ans[num.top()].push_back(p[i].id);
            q.push({p[i].s+p[i].t,num.top()});num.pop();
        }
    }
    for(int i=1; i<=m; i++){
        write(ans[i].size());putchar(' ');
        sort(ans[i].begin(),ans[i].end());
        for(int j=0; j<(int)ans[i].size(); j++) write(ans[i][j]),putchar(' ');
        putchar('\n');
    }
    return 0;
}
```

---


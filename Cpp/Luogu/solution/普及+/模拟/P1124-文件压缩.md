# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# 题解

## 作者：MC_Launcher (赞：143)

发一弹题解啦

#### 我第一眼看到这题就懵了，自己模拟一下，诶，有个规律！

什么规律呢，来，我放个图——等等，我先讲一下。

咱们先把输入的那个$S'$给按字典序排个序，然后捏，咱们就得到压缩前依次每个首字母了，那之前输入的那个不就是对应的尾字母吗？这玩意我之前照到了规律想了半天才想明白为哈。

接着呢，咱们再接着把这个尾字母变成首字母重复上述过程，到现在，~~细心的读者朋友们~~肯定能想到这是怎么回事了：这不是个环吗？首字母其实和尾字母连在一起的！然后一步步把这个环推出来，香！

好的现在可以放图了~~(作图粗糙，请原谅)~~。

![](https://cdn.luogu.com.cn/upload/image_hosting/7al63400.png)

恩好的大家已经看到一步步怎么推出来的了是吧，剩下就不用我赘术了~~就可以让我偷懒了~~

但是呢，我们正着写虽然直观易懂，但是会有错，可能有些字母会错位，我第一次正着排就才10分，所以我们要倒着找，最后反着输出，如果不理解，可以输出中间变量，然后也就懂了。

献上代码+注释

```cpp
#include<bits/stdc++.h>//可食用头文件
using namespace std;
int main()
{
	int n,shou,now;//n为S串长度，shou即为题目中p，首字母所在压缩后的位置，now为现在进行到哪个位置了
	cin>>n;//输入
	char a[n],b[n],ans[n];//a——压缩串，b——字典序串，ans——答案串
	cin>>a>>shou;//万能cin
	for(int i=0;i<n;i++)b[i]=a[i];//a带给b
	sort(b,b+n);//自动排序
	for(int i=0;i<n;i++)//首先按首字母找到最后一个字母
	{
		if(b[i]==a[shou-1])
		{
			now=i;
			b[i]=')';//标记，退出
			break;
		}
	}
	ans[0]=a[now];//计入答案
	for(int i=1;i<n;i++)//ans[i]表示倒数第i+1个字母
	{
		for(int j=n-1;j>=0;j--)//从后往前搜到第一个与原char串匹配的字典序串
		{
			if(b[j]==a[now])
			{
				now=j;//更改现在所在位置，即跳到前一个字母
				ans[i]=a[now];//计入答案
				b[j]=')';//标记
				break;
			}
		}	
	}
	for(int i=n-1;i>=0;i--)cout<<ans[i];//倒序输出
}
```

#### MC_Launcher衷心提醒您：题解千万条，理解第一条。直接粘题解，棕名两行泪。


---

## 作者：liuzhaoxu (赞：43)

这道题的基本思路：
+ 给定字符串$S1$，所以字符串中字母我们都已经得到了。

+ 因为字符串排列的各种情况是按首位排序的，那么我们对其进行排序，得到字符串$S2$，也就得到了各种情况下字符串的首位。

+ 每种情况中末位字符在原字符串中下一个字符就是本情况首位字符没问题吧，我们知道了了第一个字符，进而不断递推，由当前一个推出下一个求出原字符序列。 这是正着推。

但是我在此解释一下为什么不能正着推，我遇到了这个问题，题解中和讨论中我没有找到解释，并且又有很多人有疑问。

+  正着推的话，我们先由给出的p确定出第一个字符，与其对应的字符串首位是下一个字符，然后再在给出的字符串$S1$中找出该字符，通过下标相等得到$S2$中对应的字符，即他后一位的字符，就这样不断循环，直到确定出原字符串的所有字符。

+ 但是这有一个问题，每次在$S1$中找字符时候，$S1$是**无序**的，所以找到$S1$中的某个字符时可能并不能接上已经确定的答案字符串。

有一组数据：
```plain
4
baab
2
```
正确答案：
```plain
aabb
```
自己手模一下就可以发现正着推的问题了。

所以我们倒着推可以避免这个问题。
+ 首先由第一个字符在$S2$中的位置得到$S1$中相等下标的字符，即答案中的最后一个字符;

+ 然后在$S1$中找到相同的字符，再得到$S2$中对应的的字符。是倒数第二个，以此类推。

这样每次找字符时都是从有序序列中找，不会错位。

代码及注释如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=10000+5;
int n,p;
char s[maxn],ss[maxn]; // s[]是题目给的，ss[]是你排出的对应的各中情况中的首位
char ans[maxn];
int main(){
	//freopen("1.in","r",stdin);
	scanf("%d%s%d",&n,s+1,&p);
	memcpy(ss+1,s+1,sizeof s);
	sort(ss+1,ss+1+n); // 对原字符串排序得到首位
	int cnt=n+1; //cnt 用于记录答案
	for(int i=1;i<=n;++i) if(ss[i]==s[p]) { p=i;break; } //找到 s[p] 即答案中最后一个字符
	while(cnt>1){ // 不能正着推，因为正着推肯定得从给你的序列中按顺序找，但是给你的序列无序
		ans[--cnt]=s[p]; //将s[p]作为当前未确定的答案的最后一位
		ss[p]='#';//ss[p] 是 s[p]的前一位，确定s[p]前一步是确定ss[p],他们下标相同(都是p)。 现在s[p]已记录，ss[p] 没用了，为了防止重复选，置为'#'
		for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;} //找到一个与本次while的s[p]相同的一个ss[p],进而推出s[p]的前一位
	}						           //因为找ss[p]是在ss[]中，ss有序，所以不会算重
	printf("%s\n",ans+1); 
	return 0;
}
```

---

## 作者：张心博harry (赞：26)

第一眼看到这个题，啊，是道水题！

一个星期后：终于AC了......

[题目传送门](https://www.luogu.com.cn/problem/P1124)

[在博客园界面食用](https://www.cnblogs.com/31-a259/articles/16538695.html)（不推荐）

------------

### 大体思路：

文件压缩，妥妥的模拟嘛！

人家题目中正推给的这么详细了，倒推一下还不会吗！

我们可以发现，在字符串排序之前每个字符串的开头和结尾在原字符串中是紧挨着的（显而易见，原字符串的开头和结尾除外）。那么字符串排序后，每个字符串的开头和结尾仍然是紧挨着的。

所以我们只需要排序后每个字符串的开头和结尾，就能求出原字符串了！

字符串 $S'$ 自然就是每个字符串的结尾了，那么开头也很简单，只需要将 $S'$ 进行排序就可以得到。

#### 整理一下思路：

我们先新建一个字符串用来存排序后的 $S'$ （每个字符串的开头元素），然后找到原字符串的开头，从那里开始查找，并一个一个地寻找并压入答案字符串，最终输出答案字符串。

（说道我挂了一周的这件事，主要是因为我把寻找原字符串的开头放到了最后，这就导致了很多麻烦。种种原因，使我只得了......[十分](https://www.luogu.com.cn/record/81466319)。）

这么简单的题，就直接上代码吧。

-----------------------

### 代码：


```
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
string s,ss;
string ans;
int a[10001]={0};
int v[10001]={0};
int main(){
	int n,p;
	cin>>n;
	cin>>s;
	ss=s;
	cin>>p;
	for(int i=0;i<n;i++){
		a[i]=s[i]-'a';
	}
	sort(a,a+n); //用了很笨的方法排序。
	for(int i=0;i<n;i++){
		s[i]=a[i]+'a';
	}
	int now=0;
	for(int i=0;i<n;i++){ //寻找原字符串的开头，当时就挂在了这，后来参考大佬的题解才改过来的。
		if(s[i]==ss[p-1]){
			now=i;
			v[i]=1;
			break;
		}
	}
	for(int j=n-1;j>=0;j--){ //计算答案，大体步骤就是找到与上次字符串结尾相同的字符串开头，然后记下它的结尾。
		ans[j]=ss[now];
		for(int k=n-1;k>=0;k--){
			if(ss[now]==s[k]&&v[k]!=1){
				now=k;
				v[k]=1;
				break;
			}
		}
	}
	for(int i=0;i<n;i++){ //由于我是边倒向边倒算，所以最终还是要正着输出的。
		cout<<ans[i];
	}
	return 0;
}
```

--------------------------


### 总结：

模拟题目一般比较简单，挂就挂在顺序、边界条件上，这种事情还是要注意的。

---

## 作者：Elgo87 (赞：15)

![](https://cdn.luogu.com.cn/upload/image_hosting/597g58a3.png)

这是一道字符串 + 模拟题，而它评为了绿，说明这个模拟还是很有难度的。

## 思路

大家不知道有没有找到一个规律，样例中的字符串 `xelpame` 排序后是 `aeelmpx`，正好对应着解释第二步中，各个字符串的首字母。

也就是说，给你一个字符串 `xelpame`，排序后为 `aeelmpx`，你就可以确定压缩前排列好的字符串的首、尾字母：

```
a*****x
e*****e
e*****l
l*****p
m*****a
p*****m
x*****e
```

而你现在只需要把这个还原成第一步的状态。

第一步变成第二步，就是把每个字符串的首字母往最后一位移。

你只要逆向思考，让尾字母一个一个匹配首字母，就可以得出第一步中的字符串。

## 具体实现

设排序前的 $S'$ 为 $a$ 串，排序后的为 $b$ 串。

1. 让 $a$ 串的最后一个字符匹配到 $b$ 串，$b$ 串对应的 $a$ 串字符就是答案的最后一个字符。

[![obk5GD.png](https://s4.ax1x.com/2021/12/12/obk5GD.png)](https://imgtu.com/i/obk5GD)

2. 划掉 $b$ 串中已经匹配过的字符。

[![obA2lQ.png](https://s4.ax1x.com/2021/12/12/obA2lQ.png)](https://imgtu.com/i/obA2lQ)

3. 继续用 $b$ 串的字符匹配 $a$ 串的字符，再重复第二条和第三条，直到 $b$ 串中所有字符被划掉：

[![obV82D.png](https://s4.ax1x.com/2021/12/12/obV82D.png)](https://imgtu.com/i/obV82D)

4. 最后按 $a$ 串匹配的**倒序**组合成字符串，这个字符串就是答案。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

char a[100005],b[100005],c[100005];
int len, p, x;
int main()
{
	cin >> len >> a >> p;
	strcpy(b,a); sort(b,b+len);

	for (int i=0; i<len; i++)   //匹配第一个
	{
		if (b[i] == a[p-1])
		{
			x = i;
			b[i] = '!';  //划掉的标记
			break;
		}
	}

	c[0] = a[x];
	for (int i=1; i<len; i++)  //重复匹配，直到所有字符都被标记上 '!'
	{
		for (int j=len-1; j>=0; j--)
		{
			if (b[j] == a[x])
			{
				x = j;
				c[i] = a[x]; //这里要正序组合 c 串
				b[j] = '!';
				break;
			}
		}
	}

	for (int i=len-1; i>=0; i--)
		cout << c[i]; //倒序输出 c 串
	return 0;
}

/*
7
xelpame
7
*/

```

完结撒花~




















---

## 作者：Archer_Gilgamesh (赞：15)

用两个字符串ss和se储存同样的s'，然后把ss按字母的顺序排序

在相同位置处se和其对应的ss即为一个情况下首字母和尾字母，

其实只要找到拿se[p]得到ss[p]，再从尾向前找到一个和ss[p]相同的se[p]，再进行同样的操作就行了，

刚开始做的时候是从前向尾找，结果只有20分

因为排序的原因，要从后向前找

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int len, p, i;
    while (cin >> len){
        char se[10001], ss[10001], ans[10001], c;
        int cnt = 1;
        cin >> se >> p;
        if (len == 1){
            cout << se << endl;
            continue;
        }
        strcpy(ss, se);
        sort(ss, ss + len);
        c = se[p - 1];
        for (i = 0; i < len; i++)
            if (ss[i] == c)break;
        ans[0] = se[i];
        c = se[i];
        ss[i] = '#';
        for (i = len - 1; i >= 0; i--){
            if (ss[i] == c){
                c = se[i];
                ans[cnt++] = c;
                ss[i] = '#';
                i = len;
            }
        }
        for (i = len - 1; i >= 0; i--)
            cout << ans[i];
        cout << endl;
    }
    return 0;
}
```

---

## 作者：Cat_cc (赞：15)

把输入的字母按字典序排好竖着放在左边
输入的字符串按输入顺序竖着放在右边
使其一一对应

找到第p个字符字典序排第几，相同取最靠上的  ①

作为起点
向右水平连线，记连到的字母为c1

在左边找到对应的字母，如果相同取最靠下的   ②

向右水平连线，记连到的字母为c2
……

最终答案为c（n），c（n-1），c（n-2）……c2，c1

为什么①取最靠上
因为c1为字符串的最后一个字符，它所对应的是第一个字符，在相同字典序的情况下，没有位置比它更靠前的
为什么②取最靠下
因为我们是从后往前构造字符串，在相同字典序的情况下，位置更靠后。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10001;
char s[N],ans[N];
int a[26],l[26],r[26];
int main()
{
    int n,p;
    scanf("%d%s%d",&n,s+1,&p);
    for(int i=1;i<=n;i++) a[s[i]-'a']++;
    for(int i=0;i<26;i++) 
    {
        l[i]=r[i-1]+1;
        r[i]=l[i]+a[i]-1;
    }
    int now=l[s[p]-'a'];
    int tot=0;
    while(tot<n)
    {
        ans[tot]=s[now];
        now=r[s[now]-'a']--;
        tot++;
    }
    for(int i=n-1;i>=0;i--) putchar(ans[i])；
  return 0;
}
```


---

## 作者：Mevinsp (赞：7)

准备好一张纸，一支笔：
把输入的字母按字典序排好竖着放在左边
输入的字符串按输入顺序竖着放在右边
使其一一对应
找到第p个字符字典序排第几，相同取最靠上的  ①
作为起点
向右水平连线，记连到的字母为c1
在左边找到对应的字母，如果相同取最靠下的   ②
向右水平连线，记连到的字母为c2
……
最终答案为c（n），c（n-1），c（n-2）……c2，c1

为什么①取最靠上
因为c1为字符串的最后一个字符，它所对应的是第一个字符，在相同字典序的情况下，没有位置比它更靠前的
为什么②取最靠下
因为我们是从后往前构造字符串，在相同字典序的情况下，位置更靠后

你们最喜欢的

# 代码
（QAQ）

```
#include<cstdio>
#define N 10001 
using namespace std;
char s[N],ans[N];
int a[26],l[26],r[26];
int main()
{
    int n,p;
    scanf("%d%s%d",&n,s+1,&p);
    for(int i=1;i<=n;i++) a[s[i]-'a']++;
    for(int i=0;i<26;i++) 
    {
        l[i]=r[i-1]+1;
        r[i]=l[i]+a[i]-1;
    }
    int now=l[s[p]-'a'];
    int tot=0;
    while(tot<n)
    {
        ans[tot]=s[now];
        now=r[s[now]-'a']--;
        tot++;
    }
    for(int i=n-1;i>=0;i--) putchar(ans[i]);
}
```

---

## 作者：minVan (赞：5)

**题目大意**

一个长度为 $n$ 的字符串 $S$，进行以下操作。

假设 $s$ 为 `acbdef`，每一次将首字母移至末尾，得到 $6$ 个字符串：

```
acbdef
cbdefa
bdefac
defacb
efacbd
facbde
```

将每个字符串的首字母排序：

```
acbdef
bdefac
cbdefa
defacb
efacbd
facbde
```

每个字符串的末尾连在一起为 `fcabde`，这就是 $S'$。

最后让你反推出 $S$。

**解题思路**

1. 原串将首字母移至末尾就得到构造串。
2. 构造的第一个串就是原串。
3. 构造的其余字符串的“末尾字符”是“该串首字母”在“原串 $ans[\ ]$ ”中的前一个字符。
4. 维护 $cur$ 表示 $s1[\ ]$ 的位置，则 $s_{cur}$ 是 $s1_{cur}$ 的前一个字符。
5. 倒序确认原串的位置，因为倒序的字符在 $s1[\ ]$ 中寻找是有序的，反之正序确认则需要在 $s[\ ]$ 中找，是无序的。

**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, p, cur;
char s[10005], s1[10005], ans[10005]; // s1表示排序后的串，s表示排序前的串
bool vis[10005];
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> s[i];
		s1[i] = s[i];
	}
	cin >> p;
	sort(s1 + 1, s1 + n + 1);
	ans[1] = s[p]; // 首字母确认
	for(int i = 1; i <= n; i++) {
		if(s1[i] == s[p]) {
			cur = i; // 找构造的第一个串编号
			break;
		}
	}
	for(int i = n; i >= 2; i--) { // 倒序确认位置
		vis[cur] = 1; // 标记s1[cur]已经使用
		ans[i] = s[cur]; // 原串i个位置的字母就是s[cur]
		for(int j = n; j >= 1; j--) {
			if(s1[j] == s[cur] && !vis[j]) {
				cur = j;
				break;
			}
		}
	}
	for(int i = 1; i <= n; i++) {
		cout << ans[i];
	}
	return 0;
}
```

---

## 作者：BreakPlus (赞：4)

好久没发题解了，来发一波，延续我的 Blog 梦（

### Part1 推导过程

从题目中得知，数据给出的排序后的字符串的尾字母。由于它是一个环，这肯定覆盖了所有字符，给它们排一下序，便是首字母了。

```

	首字母	尾字母
	a	x
	e	e
	e	l
	l	p
	m	a
	p	m
	x	e
```

我们根据给定的位置，找到尾字母对应的首字母，即 ``x``。由于它是一个环，首字母就是下一个字母啦！

然后找到与当前首字母 ``x`` 相同的尾字母，再看对应的首字母，为 ``a``。

一步一步推下去，得到 ``example`` 。

### Part2 Code

```cpp
/*
  Author: BreakPlus
  Online Judge: Luogu
  Problem: P1124
  Date: 2020/8/31
*/
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream>

typedef long long ll;
typedef std::pair<int,int> P;

#define ls pos<<1
#define rs pos<<1|1
#define maxn 100100
int len,p;
char a[maxn];int now;
char b[maxn],c[maxn];
using namespace std;
signed main()
{
  cin>>len>>a>>p;
  for(register int i=0;i<len;i++) b[i]=a[i];
  sort(b,b+len);
  for(register int i=0;i<len;i++)
    if(b[i]==a[p-1])
    {
      b[i]='@';
      now=i;
      break;
    }
  c[0]=a[now];
  for(register int i=1;i<len;i++)
  {
    for(register int j=len-1;j>=0;j--)
    {
      if(b[j]==a[now])
      {
        now=j;
        c[i]=a[now];
        b[j]='@';
        break;
      }
    }
  }
  for(register int i=len-1;i>=0;i--) putchar(c[i]);
  puts("");
  return 0;
}
```

---

## 作者：Jorisy (赞：3)

挺有难度的一道模拟题。

---

以样例为例，在排列并排序后，我们省略中间的字母，是这样的：
```
a-----x
e-----e
e-----l
l-----p
m-----a
p-----m
x-----e
```
可以发现，首字母与尾字母是可以相对应的。

样例中 $p=7$，我们可以立刻知道，原字符串首字母是 `e`，然后是其对应的 `x`；然后找到尾字母是 `x` 的，知道对应的首字母是 `a`……以此类推，就可以得到 `example`。

所以我们只要将尾字母排序就会得到首字母了。

但是，当我们在找对应的字母时，正推字母会乱，举个例子：
```
5
yxxxx
4
```
按上面的操作，我们会得到：
```
x---y
x---x
x---x
x---x
y---x
```
那这样子去操作，不同的写法会得到不同的答案。

因此，我们选择倒推，来避免这种现象。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n,p,now;
	string s;
	cin>>n>>s>>p;
	string t=s;
	sort(t.begin(),t.end());
	for(int i=1;i<=n;i++)
	{
		if(t[i]==s[p-1])
		{
			now=i;
			t[i]='$';//标记，下同
			break;
		}
	}//先推出最后一个字母
	string ans;
	ans.resize(10005);
	ans[0]=s[now];
	for(int i=1;i<n;i++)
	{
		for(int j=n-1;j>=0;j--)
		{
			if(t[j]==s[now])
			{
				now=j;
				ans[i]=s[now];
				t[j]='$';
				break;
			}
		}	
	}
	for(int i=n-1;i>=0;i--)//倒序输出
	{
		cout<<ans[i];
	}
 	return 0;
}

```

---

## 作者：ADivT (赞：2)

我又来发题解啦。

可能更好的[阅读体验](https://www.luogu.com.cn/blog/alvincwz/solution-p1124)

### 解题思路

这道题的思路还是很清晰的，很明显尾字母可以构成一个环，排序将首字母处理出来后，倒序搜索反向输出即可。注意第一次找字符串末尾时要正向查找。

以下是使用$ STL$::$string $ 的写法，介绍一下string的一点操作吧。

### 对字符串类的排序
$string$的$sort$依赖于两个指针，如果排序整个数组，就直接
```
	sort(st2.begin(), st2.end());
```
同样可以用$cmp$来改变比较规则。

### 使用时的小坑
前面我调试了好久，却一直RE。后请高人指教，$string$在没有开好空间之前不能强行赋值，容易出锅。于是就使用$resize$函数先预处理字符串。

以下是完整代码:

```
#include<bits/stdc++.h>

#define R register

#define ll long long

#define rep(i, o, p) for(R int i = o; i <= p; ++ i)

#define dep(i, o, p) for(R int i = o; i >= p; -- i)

using namespace std;

string st1, st2, ans;

int ls, p;

int main(){
	ans.resize(100000);
	cin >> ls >> st1 >> p;
	-- p, -- ls, st2 = st1;
	sort(st2.begin(), st2.end());
	rep(j, 0, ls){
		if(st2[j] == st1[p]){
			p = j;
			ans[0] = st1[p];
			st2[j] = '&';
			break;
		}
	}
	rep(i, 1, ls){
		dep(j, ls, 0){
			if(st2[j] == st1[p]){
				p = j;
				ans[i] = st1[p];
				st2[j] = '&';
				break;
			}
		}
	}
	dep(i, ls, 0) putchar(ans[i]);
	putchar('\n');
	return 0;
}
```



---

## 作者：huoing (赞：2)

	如题意:"①按首字符从小到大排序,若两字符串首字符相等,②则按其
    
    在S中位置从小到大排序。"
	
    依①,必得首字符递增序列,设其为c。
    
    故此序列可由所给字符串s排序得,且与s首尾一一对应。
    
    这种首尾关系,体现在原序列上是相邻。
    
    即s内字符在原序列中是c内字符前一位。
    
    故当确定一字符位置,可推其余字符位置。
    
    现在暴力分析:
    
    	由于②,该排序方式体现在c上,原序列一定有重复字母。
        
        所以只能由c推,所以只能从后往前推(c->s)。
    
    	已知第一字符,由于其位置第一,在c中必为相等字符之首。
        
        由此,线性推。
        
    #include<bits/stdc++.h>
	#define rep(i,a,b) for(int i=(a);i<=(b);i++)//宏定义的for
	#define per(i,a,b) for(int i=(a);i>=(b);i--)//循环简写
	using namespace std;
	int n,p;char s[10010],c[10010],t[10010];
	int main(){
		scanf("%d",&n);cin>>s;
		scanf("%d",&p);p--;
		strcpy(c,s);sort(c,c+n);//strcpy复制
		rep(j,0,n-1) if(c[j]==s[p]) {p=j;break;}//找起始点
		rep(i,0,n-1) {
			t[n-1-i]=s[p];//倒推,倒放
			per(j,n-1,0) if(c[j]==s[p]) {c[j]=' ';p=j;break;}//访后记空
		}
		rep(i,0,n-1) cout<<t[i];cout<<endl;
		return 0;
	}
    cbyzsl

---

## 作者：Alisa (赞：2)

这个题是一个模拟。可以正推也可以倒推，代码是倒推的

注意这里并不是按照字典序排序，而是出现顺序！！！

le数组表示出现的所以字母排序，与ri数组意义对应

可以通过第一个字母找到最后一个字母，然后再根据最后一个字母找到上一个字母

找到一个字母就把这个字母出现的最后位置-1，就能找到上一个字母了

另外1的时候要特判

（逻辑有些混乱，详情参照代码）

```delphi

(program zip;  
var le,ri,sum,ans:array[0..10000] of longint;  
    n,mid,i,j,p,num:Longint;  
    ch:char;  
procedure sort(l,r: longint);  
      var  
         i,j,x,y: longint;  
      begin  
         i:=l;  
         j:=r;  
         x:=le[(l+r) div 2];  
         repeat  
           while le[i]<x do  
            inc(i);  
           while x<le[j] do  
            dec(j);  
           if not(i>j) then  
             begin  
                y:=le[i];  
                le[i]:=le[j];  
                le[j]:=y;  
                inc(i);  
                j:=j-1;  
             end;  
         until i>j;  
         if l<j then  
           sort(l,j);  
         if i<r then  
           sort(i,r);  
      end;  
  
  
begin  
    readln(n);  
    mid:=n;  
    for i:=1 to n do  
    begin  
        read(ch);  
        num:=ord(ch)-ord('a')+1;  
        ri[i]:=num;  
        le[i]:=num;  
    end;  
    read(p);  
    if n=1 then  
    begin  
        write(char(ri[n]+ord('a')-1));  
        halt;  
    end;  
    sort(1,n);  
    write(chr(ri[p]+ord('a')-1));  
    for i:=1 to n do sum[le[i]]:=i;  
    for i:=1 to n do if le[i]=ri[p] then  
    begin  
        ans[n]:=ri[i];  
        p:=ri[i];    
        break;  
    end;  
  
    while true do  
    begin  
  
        if n=2 then break;  
        dec(n);  
        ans[n]:=ri[sum[p]];  
         dec(sum[p]);  
        p:=ans[n];  
    end;  
    for i:=2 to mid do  
    begin  
        write(char(ans[i]+ord('a')-1));  
    end;  
end.  )

```

---


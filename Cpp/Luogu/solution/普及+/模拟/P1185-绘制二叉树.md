# 绘制二叉树

## 题目描述

二叉树是一种基本的数据结构，它要么为空，要么由根结点，左子树和右子树组成，同时左子树和右子树也分别是二叉树。

当一颗二叉树高度为 $m-1$ 时，共有 $m$ 层。若一棵二叉树除第 $m$ 层外，其他各层的结点数都达到最大，且叶子结点都在第 $m$ 层时，则其为一棵满二叉树。

现在，需要你用程序来绘制一棵二叉树，它由一棵满二叉树去掉若干结点而成。对于一棵满二叉树，我们需要按照以下要求绘制：

1. 结点用小写字母 `o` 表示，对于一个父亲结点，用 `/` 连接左子树，用 `\` 连接右子树。

2. 定义 $[i,j]$ 为位于第 $i$ 行第 $j$ 列的某个字符。若 $[i,j]$ 为 `/` ，那么 $[i-1,j+1]$ 与 $[i+1,j-1]$ 要么为 `o` ，要么为 `/`。若 $[i,j]$ 为 `\` ，那么 $[i-1,j-1]$ 与 $[i+1,j+1]$ 要么为 `o`，要么为 `\` 。同样，若 $[i,j]$ 为第 $1\sim m-1$ 层的某个结点 `o` ，那么 $[i+1,j-1]$ 为 `/`，$[i+1,j+1]$ 为 `\`。

3. 对于第 $m$ 层结点也就是叶子结点点，若两个属于同一个父亲，那么它们之间由 $3$ 个空格隔开；若两个结点相邻但不属于同一个父亲，那么它们之间由 $1$ 个空格隔开。第 $m$ 层左数第 $1$ 个结点之前没有空格。

最后需要在一棵绘制好的满二叉树上删除 $n$ 个结点（包括这个结点的左右子树，以及与父亲的连接），原有的字符用空格替换（空格为 `ASCII 32`，若输出 `ASCII 0` 会被算作错误答案）。

## 说明/提示

$30\%$ 的数据满足：$n=0$；

$50\%$ 的数据满足：$2\le m\le 5$；

$100\%$ 的数据满足：$2\le m\le10,0\le n\le 10,1<i\le M,j\le 2^{i-1}$。

## 样例 #1

### 输入

```
2 0
```

### 输出

```
  o  
 / \ 
o   o
```

## 样例 #2

### 输入

```
4 0```

### 输出

```
           o           
          / \          
         /   \         
        /     \        
       /       \       
      /         \      
     o           o     
    / \         / \    
   /   \       /   \   
  o     o     o     o  
 / \   / \   / \   / \ 
o   o o   o o   o o   o```

## 样例 #3

### 输入

```
4 3
3 2
4 1
3 4
```

### 输出

```
           o           
          / \          
         /   \         
        /     \        
       /       \       
      /         \      
     o           o     
    /           /      
   /           /       
  o           o        
   \         / \       
    o       o   o      ```

# 题解

## 作者：ailanxier (赞：95)

&emsp;&emsp;[在博客中观看](https://www.cnblogs.com/ailanxier/p/13556307.html) 
## 题意概述
&emsp;&emsp;根据规则绘制一棵被删去部分节点的满二叉树。节点用 $o$ 表示，树枝用```/\```表示。每一层树枝长度会变化，以满足叶子结点有如下特定：

+ 相邻叶子节点是兄弟节点（同一个父亲）时，间隔 $3$ 个空格。
+ 相邻叶子节点不是兄弟节点，之间隔一个空格。

&emsp;&emsp;一棵层数为 $4$ 的满二叉树长这样（可能会出现因为字符宽度不一而出现偏移）：
```cpp
           o           
          / \          
         /   \         
        /     \        
       /       \       
      /         \      
     o           o     
    / \         / \    
   /   \       /   \   
  o     o     o     o  
 / \   / \   / \   / \ 
o   o o   o o   o o   o
```
&emsp;&emsp;删除节点的输入格式为：删除第 $i$ 层从左往右数的第 $j$ 个节点。注意删除时，**把原有的字符用空格替换，结果是要打印空格的**。

## 分析
&emsp;&emsp;又是一道画图模拟题，需要耐心分析。我采取的是找规律的方法，代码可能长，但是应该比较容易理解吧 $QAQ$ 。

&emsp;&emsp;先看我们得维护什么信息才能实现初始化满二叉树和删点两个操作。初始化的方法有挺多，可以先铺好叶子结点，往上递归建树，也可以从根节点往下建树。但是有个问题是我们并不知道叶子结点到根节点的垂直距离，也不知道根节点的坐标。这时候我们就得找树枝的规律了。建好树后我们要删点，但是输入点的方式不能直接确定点的坐标，得找同一层节点分布的规律。为了后续讨论方便，我们约定**叶子节点为第一层，根节点在第 $m$ 层**。
### 树枝的规律
&emsp;&emsp;打表加看图硬分析（**这里的树枝长定义为连接第 $i$ 层节点与第 $i+1$ 层节点的树枝长**）：

| 层数 | $1$ | $2$ |$3$|$4$|$5$|
| :----:| :----: | :----: | :----: | :----: | :----: | 
| 树枝长 $len$ | $1$ | $2$ |$5$ | $11$ |$23$ | 
| 规律 | $1$ | $1+(2-1)$  |$(1+2)+(3-1)$  |$(1+2+5)+(4-1)$  |$(1+2+5+11)+(5-1)$  |


[表格如果显示不全可以到我的博客上看](https://www.cnblogs.com/ailanxier/p/13556307.html)

&emsp;&emsp;可以看出，对于第 $i(2 \leq i )$ 层的树枝长，其实是等于前 $i-1$ 层树枝的长度之和与 $i-1$ 的和的。看图更容易发现这一规律：

![](https://images.cnblogs.com/cnblogs_com/ailanxier/1834440/o_200824131945%E6%A0%91%E6%9E%9D.jpg)

&emsp;&emsp;这里第 $3$ 层的树枝和前两层的树枝和节点有一一对应的关系（红色实线），可以看出长度恰好就是前两层节点数2加上前两层的树枝长度，$O(n)$ 递推可以得到树枝长度数组，记为 $len$ 。

### 同层节点规律
&emsp;&emsp;观察可知除了第一层外的其他层的同层相邻节点距离是一定的。所以确定每一层第一个节点的位置就可以推出其他节点的位置了。

&emsp;&emsp;让第一层第一个节点水平位置为 $1$ 。再次观察前面的图，可以发现**第 $i$ 层第一个节点的水平位置其实就是 $len_i+1$** 。所以根据前面推出来的树枝长数组可以推出。竖直位置就得从根节点（也就是第 $m$ 层）往下推了，根节点竖直位置为 $1$ ，**第 $i$ 层竖直位置就其实就是 $=$ 第 $i+1$ 层竖直位置 $+$ 第 $i$ 层的树枝长度 $+1$** ，也是比较明显的。我代码中将两个方向的位置分别用 $pos$ 和 $h$ 表示了。以下是初始化函数和一些数组定义：
```cpp
const int N = 3100;
int len[20],m,n,pos[20],h[20];
char a[N][N];  //满二叉树数组，注意开大一点
void prepare(){
    int sum = 1;            //记录树枝长的前缀和
    len[1] = 1;pos[1] = 1;  //第一层树枝长为1，第一个节点水平位置为1
    FOR(i,2,m) {
        len[i] = sum + i-1; //递推式子
        sum += len[i];
        pos[i] = len[i] + 1;//顺便得到第i层第一个节点的水平位置
    }
    h[m] = 1;
    for(int i = m-1; i ;i --) h[i] = h[i+1]+len[i]+1;//得到第i层的竖直位置
    memset(a,' ',sizeof(a)); //全都铺满空格
}
```

&emsp;&emsp;第一层节点的分布已在题目中确定了，相邻节点是兄弟就隔 $3$ 个，不是隔 $1$ 个，因为与其他层分布不同，是要特判的。其他层结点间距也是很好找到规律的，就是 $2 \times len_i+1$ 。至此，我们这棵树的信息基本完备了，下面就是比较轻松的绘制和删点了。
## 绘制和删点
&emsp;&emsp;这两个操作都是递归进行的。

&emsp;&emsp;因为我们已经知道了每一层的树枝长度，所以我们可以从根节点开始建树，递归左右子树即可。注意我们定义的树枝长度为**连接第 $i$ 层节点与第 $i+1$ 层节点的树枝长度**。代码采用了前序遍历的方式：
```cpp
void draw(int x,int y,int depth){
    a[x][y] = 'o'; //画节点
    if(depth == 1) return;  //到叶子节点了，返回
    //开始画树枝，lx,ly定位左树枝，rx,ry定位右树枝
    int lx = x+1,ly = y-1,rx = x+1,ry = y+1;
    FOR(i,1,len[depth-1]){//注意画的树枝长度为下一层的树枝长度
        a[lx][ly] = '/';
        a[rx][ry] = '\\';
        lx = lx+1,ly = ly-1,rx = rx+1,ry = ry+1;
    }
    draw(lx,ly,depth-1);   //画下一层节点
    draw(rx,ry,depth-1);
}
```
&emsp;&emsp;删点比较暴力，注意删点要同时删除与父亲节点的联系和与孩子节点的联系:
```cpp
void destroy(int x,int y){
    a[x][y] = ' ';           //将该点置为空格
    if(a[x-1][y-1] == '\\') destroy(x-1,y-1);         //左上角
    if(a[x-1][y+1] == '/')  destroy(x-1,y+1);         //右上角
    if(a[x+1][y-1] == '/' || a[x+1][y-1] == 'o') destroy(x+1,y-1); //左下角，因为往下还要删除孩子节点，要多一个判断
    if(a[x+1][y+1] == '\\'|| a[x+1][y+1] == 'o') destroy(x+1,y+1); //右下角同理
}
```
## 一些可能阻止你AC的坑
+ 数组大小要开大一点。满二叉树最大层数为 $10$ ，叶子结点的竖直为置最大为 $768$，该层宽度为 $3072$ 。所以数组大小应至少开到 $769*3073$ 。否则可能出现 $\mathbf{Too~ long~ on~ line~ 1}.$ 或者直接 $\mathbf{RE}$ 等错误。
+ 数组定义比较多，要用一些比较清晰的变量名，并且时刻记得它们的意义。
+ 第 $10$ 个点有点玄学。如果用快读会 $\mathbf{TLE}$ 掉，因为数据量小，全都用 $\mathbf{cin}$ 就可以过了。
## $Code:$
```cpp
#include <bits/stdc++.h>
#define FOR(i,a,b) for(int i = a;i <= b;i++)
using namespace std;
const int N = 3100;
int len[20],m,n,pos[20],h[20];
char a[N][N];  //满二叉树数组，注意开大一点
int read(){int sum = 0,fu = 1;char ch = getchar();while(!isdigit(ch)){if(ch == '-')fu = -1;ch = getchar();}while (isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch = getchar();}return sum*fu;}
//预处理
void prepare(){
    int sum = 1;            //记录树枝长的前缀和
    len[1] = 1;pos[1] = 1;  //第一层树枝长为1，第一个节点水平位置为1
    FOR(i,2,m) {
        len[i] = sum + i-1; //递推式子
        sum += len[i];
        pos[i] = len[i] + 1;//顺便得到第i层第一个节点的水平位置
    }
    h[m] = 1;
    for(int i = m-1; i ;i --) h[i] = h[i+1]+len[i]+1;//得到第i层的竖直位置
    memset(a,' ',sizeof(a)); //全都铺满空格
}

//绘制
void draw(int x,int y,int depth){
    a[x][y] = 'o'; //画节点
    if(depth == 1) return;  //到叶子节点了，返回
    //开始画树枝，lx,ly定位左树枝，rx,ry定位右树枝
    int lx = x+1,ly = y-1,rx = x+1,ry = y+1;
    FOR(i,1,len[depth-1]){ //注意画的树枝长度为下一层的树枝长度
        a[lx][ly] = '/';
        a[rx][ry] = '\\';
        lx = lx+1,ly = ly-1,rx = rx+1,ry = ry+1;
    }
    draw(lx,ly,depth-1);   //画下一层节点
    draw(rx,ry,depth-1);
}

//删点
void destroy(int x,int y){
    a[x][y] = ' ';           //将该点置为空格
    if(a[x-1][y-1] == '\\') destroy(x-1,y-1);         //左上角
    if(a[x-1][y+1] == '/') destroy(x-1,y+1);          //右上角
    if(a[x+1][y-1] == '/' || a[x+1][y-1] == 'o') destroy(x+1,y-1); //左下角，因为往下还要删除孩子节点，要多一个判断
    if(a[x+1][y+1] == '\\'|| a[x+1][y+1] == 'o') destroy(x+1,y+1); //右下角同理
}

//打印
void print(){
    int height = h[1];          //第一层的竖直位置
    int width = 6 * (1<<(m-1)); //第一层的宽度（最宽）
    FOR(i,1,height){
        FOR(j,1,width)
            printf("%c",a[i][j]);
        printf("\n");
    }
}

signed main(){
    m = read();n = read();
    prepare();
    draw(1,pos[m],m); //(1，pos[m])为根节点坐标，位于第m层
    while(n--){
        int i = read(),j = read();
        if(i > 10) continue;
        int x = h[m+1-i],y; //因为层的定义与题目不同，得转化一下
        //分第一层和其他层两种情况计算水平位置y
        if(i == m){
            if(j & 1) y = pos[1] + j/2*6;
            else y = pos[1] + j/2*6 - 2;
        }
        else y = pos[m+1-i] + (j-1)* (2 * len[m+1-i] + 2); //可以手推
        destroy(x,y);
    }
    print();
    return 0;
}
```

&emsp;&emsp;如果你想练习一下类似的画图题，以下两题可以做做看：
+ [P1498 南蛮图腾](https://www.luogu.com.cn/problem/P1498)
+ [P1058 立体图](https://www.luogu.com.cn/problem/P1058)


---

## 作者：巨型方块 (赞：67)

http://blog.csdn.net/largecub233/article/details/72793147

求点赞^\_^


哈哈，我的代码是唯一一个不到1kb的；

时间不是最快的，但是我的代码没用hk跑；

要用hk跑的话，估计也快的飞起；

一看题目就感觉很有意思；

我的方法简单来说就是先找规律，然后一个dfs绘图；

首先我们考虑满二叉树；

我们先要确定画布大小；

然后juicy可以找到这么一种规律；

当k=1的时候，画布n=m=1;

当k!=1时


```cpp
n=3;
for(int i=3;i<=k;i++)n*=2;
m=6*(1<<(k-2))-1;
```
这个倒真的是找规律得出的；

所以我们的数组开800\*1600就很好了；

然后我们先把这个画布填充成空格；

然后从根节点往下dfs画图；

画图方法在找画布的规律的时候自然而然地发现了；

这个难说啊，其实也是找规律了；

看我代码把


```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
int k,n,m,p,x,y;
char c[800][1600];
bool f[800][1600];//在第x,y点,a,b是用来判节点的,k表示点还是边，xx,yy表示这个点或这个边的父亲 
void dfs1(int x,int y,int a,int b,int k,int xx,int yy){
    if(x==n){c[x][y]='o';return;}
    if(k==1){
        c[x][y]='o';
        int X=xx+1,Y=(yy-1)*2+1;//左儿子 
        if(!f[X][Y])dfs1(x+1,y-1,a+1,b,2,X,Y);
        X=xx+1,Y=yy*2;//又儿子 
        if(!f[X][Y])dfs1(x+1,y+1,a+1,b,3,X,Y);
    }else
    if(k==2){
        c[x][y]='/';
        if(a*2==b)dfs1(x+1,y-1,1,a,1,xx,yy);//这个就是判断接下来是边还是点 
        else    dfs1(x+1,y-1,a+1,b,2,xx,yy);
    }else
    if(k==3){
        c[x][y]=92;
        if(a*2==b)dfs1(x+1,y+1,1,a,1,xx,yy);
        else    dfs1(x+1,y+1,a+1,b,3,xx,yy);
    }
}
void make(int k){
    n=3;
    for(int i=3;i<=k;i++)n*=2;
    m=6*(1<<(k-2))-1;//计算画布大小 
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)c[i][j]=' ';//填充画布 
    dfs1(1,m/2+1,1,n,1,1,1);    
}
int main()
{
    scanf("%d%d",&k,&p);
    while(p--){scanf("%d%d",&x,&y);f[x][y]=1;}//记录这个节点是否可以画 
    if(k==1)n=m=1,c[1][1]='o';else make(k);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)cout<<c[i][j];cout<<endl;
    }
}

```



---

## 作者：AzusagawaKaede (赞：19)

# P1185 绘制二叉树 题解(C++)

又是画图题qwq…

果断递归。
****

## 题目分析

这道题只要想明白就很容易 AC，具体思路：

二维 $char$ 数组 + 一维数组存二叉树 + 递归画图；

### 存二叉树

简单介绍一下哈。

一维数组，大小为 $2^m$（$m$ 为树的层数）。

根结点为下标为1，对于结点 $p$，左儿子为 $2 \times n$，右儿子为 $2 \times n + 1$。

### 绘制

首先，我们需要知道每个结点与其父结点之间 '\/' 或 '\\' 的个数。

观察样例，我们不难发现：

- 叶结点与其父亲结点之间的 '\/' 或 '\\' 的个数为1；
- 从叶结点往上走，'\/' 或 '\\' 的个数分别为 $\{1,2,5,11,23,47\cdots\}$（各位大佬发现规律了吧）。

然后就是快（麻）乐（烦）的递归画图了。

## 代码

递上一份蒟蒻调了半天的蒟蒻代码。

$code:$
```cpp
#include <bits/stdc++.h>
#define ls(x) x<<1//等价于2*x 
#define rs(x) (x<<1)|1//等价于2*x+1
//使用位运算不是为了装X，相信我会快一点点点点的 
using namespace std;
int a[12]={0,1,2,5,11,23,47,95,191,383,767,1535}; 
char pic[805][1605];//行数最大为767，列数最大为2*767+1=1535
bool tr[1050];
int m, n;

void draw(int, int, int,int);//函数声明 

void drawl(int p,int n, int x, int y) 
{
	int i = x, j = y, tmp=a[n];
	while(tmp--)
	{
		i++, j--;
		pic[i][j]='/';
	}
	i++,j--;
	pic[i][j]='o';
	draw(p, n-1, i, j); 
}

void drawr(int p,int n, int x, int y)
{
	
	int i = x, j = y, tmp=a[n];
	while(tmp--)
	{
		i++, j++;
		pic[i][j]='\\';
	}
	i++,j++;
	pic[i][j]='o';
	draw(p, n-1, i, j);
}

void draw(int p,int n,int x,int y)
{
	if (n==0) return;
	if (tr[ls(p)])//如果有左子树 
	{
		drawl(ls(p), n, x, y);//画左子树 
	}
	if (tr[rs(p)])//如果有右子树 
	{
		drawr(rs(p), n, x, y);//画右子树 
	}
}

//以上三个函数可以写成一个，但是会使代码晦涩难懂，不易检查 
int main()
{
	memset(pic,char(32),sizeof(pic));//全赋值为空格 
	scanf("%d%d", &m, &n);
	for (int i = 1; i < (1<<m); i++)//层数为m的满二叉树共有2^m-1个结点 
	{
		tr[i]=1;
	}
	while (n--)
	{
		int i, j; 
		scanf("%d%d", &i, &j); 
		int tmp=(1<<(i-1))-1;//满二叉树前i-1层共有2^(i-1)-1个结点
		tmp+=j;//第j个 
		tr[tmp]=0;//删去子树 
	}
	pic[1][a[m]+1]='o';//根结点 
	draw(1, m-1, 1, a[m]+1);//画图 
	for (int i = 1; i <= a[m]+1; i++)
	{
		for (int j = 1; j <= a[m+1]+1; j++)
		{
			putchar(pic[i][j]);
		} 
		putchar('\n');
	} 
	return 0;
}
//Written By ZZY 
```
~~管理大大求过。~~

~~求个关注$qwq$~~




---

## 作者：KaguyaH (赞：14)

~~被普及练习场 / 基础题单虐菜中 /kk~~

[**题目传送门**](https://www.luogu.com.cn/problem/P1185) [**博客查看**](https://www.luogu.com.cn/blog/236807/Solution-luogu-P1185)

本文中，带有上角标的地方可以在文末找到注释。本文主要面向初学者，建议面向提高的选手跳读。斜体字旨在消除一些可能的歧义。

考虑逐行输出。那么，不可避免地，我们需要知道根节点的位置。

我们定义 $r_i$ 为 $(m = i)$ 时根节点的位置。这里从 $0$ 计数比较方便（恰好表示了左右子树的宽度${}^1$），故选择从 $0$ 开始。显然，有${}^2$

$$
r_i = 
\begin{cases}
0 & i = 1\\
2 & i = 2\\
2r_{i - 1} + 1 & i > 2\\
\end{cases}.
$$

综上，我们得到了根节点的位置。

另一个很麻烦的点是，如何得到每个点到其母亲节点的距离。我们发现，该距离应该恰好跳过该点*与母结点间*的子树的宽度，与 $r_i$ 的定义非常相似。故我们发现，当一条边下方有 $i$ 个节点时，该边长度

$$
e_i =
\begin{cases}
1 & i = 1\\
r_i & i > 1\\
\end{cases}.
$$

我们可以记录输出数据每行边 / 点的位置（此处不考虑删除），然后每次输出后，如果是左子树，位置自减；右子树位置自增。节点需要判断并更新数组（分别记录自减和自增，故此时数据数量会变为二倍）。

对于是否删除，我们可以判断父节点删除或节点本身删除。当从上向下扫描时，祖先是否有删除必然体现在父结点上，故不必考虑祖先。这里可以边做边递推或预处理，代码中采用的是预处理。

```cpp
# define _CRT_SECURE_NO_WARNINGS
# include <cstdio>
# include <algorithm>
# include <vector>

typedef short unsigned int hu;
enum { M = 10 };

static hu m, n;
static bool e[M][1 << M - 1]; // 节点是(true)否(false)存在
static hu p[2][1 << M - 1]; // 节点位置

signed int main() {
	scanf("%hu%hu", &m, &n), p[0][0] = (1 << m) - (1 << m - 2); // 根节点位置 使用的是注释中的公式
	for (hu i(0); i < m; ++i)
		for (hu j(0); j < 1 << i; ++j)
			e[i][j] = true;
	for (hu i(0); i < n; ++i) {
		{
			static hu i, j; scanf("%hu%hu", &i, &j);
			e[i - 1][j - 1] = false;
		}
	}
	for (hu i(1); i < m; ++i)
		for (hu j(0); j < 1 << i; ++j)
			if (not e[i - 1][j >> 1])
				e[i][j] = false; // 预处理
	for (hu i(1); i < p[0][0]; ++i) putchar(' ');
	puts("o"); // 特殊处理根节点
	for (hu i(1); i < m; ++i) {
		for (hu j(0); j < 1 << i; ++j) p[1][j] = p[0][j >> 1] + (j & 1 ? 1 : -1);
		std::swap(p[0], p[1]); // 得到本层的边的最上面一行的位置 存入p[0]
		const hu t((1 << m - i) - (1 << m - i - 2));
		for (hu l(1); l < t; ++l) {
			for (hu j(1), k(0); k < 1 << i; ++j)
				if (j == p[0][k]) putchar(e[i][k] ? k & 1 ? '\\' : '/' : ' '), p[0][k] += k & 1 ? 1 : -1, ++k;
				else putchar(' ');
			putchar('\n'); // 依次输出每一行边
		}
		for (hu j(1), k(0); k < 1 << i; ++j)
			putchar(j == p[0][k] && e[i][k++] ? 'o' : ' ');
		putchar('\n'); // 输出节点
	}
	return 0;
}
```

注释：

0. 本文中可能涉及的影响阅读符号：对于所有 $\forall$，向下取整 $\lfloor\rfloor$。

1. 子树的宽度指所占的横向距离。形式化地，定义 $\max$ 为子树内最右侧节点（显然为叶节点）的位置、$\min$ 为子树内最左侧节点（显然为叶节点）的位置，当不考虑删除节点时，子树的宽度即为 $\max - \min + 1$。恰好表示宽度是因为根节点左侧必然有*左子树宽度*个节点。

2. $\forall i \geqslant 2$，希望更优美解法的同学可以从该式中（可利用位运算推导、求值）推出如下式子：$r_i = 2^i - 2^{i - 2} - 1(i \geqslant 2)$。类似，$e_i = 2^i - \lfloor 2^{i - 2} \rfloor - 1$。

---

## 作者：AzzyZhe (赞：14)

## 题解 [P1185 绘制二叉树](https://www.luogu.com.cn/problem/P1185)
~~优化初始化后居然勉强挤到了最优解第一~~刚好来写篇题解。

### 思路分析
----
由题目可以知道所需要的二叉树是在满二叉树的基础上删除子树的，因此我们可以考虑满二叉树的性质，无需任何额外工序建树，并使用类似写堆时候的`p<<1`和`p<<1|1`表示左右子树，通过数值运算达到$O(1)$删树。

再由样例我们可以知道，题目要求输出多余空格，而数据范围也不是很大，因此可以基本确定下来绘制时是在空格基础上替换字符。

最后再通过一遍$\text{dfs}$遍历绘制图形，再输出即可。（数据稍微再大一点的话或许可以考虑$\text{bfs}$，边绘边输出）

### 具体实现
----
首先要确定画布大小，考虑满二叉树时的最底下一行。观察样例及由题意，当树有$m$层时，如果我们把最下方两层节点$3$个节点的子树分离出来，看作这些树构成的森林，则共有$2^{m-2}$棵树（即第$m-1$层节点数），每棵宽度$5$个字符，再加上$2^{m-2}-1$个分隔的空格，一共$5\times(2^{m-2})+(2^{m-2}-1)$即$6\times2^{m-2}-1$个字符，即为画布宽度。同时克制最上一行树根的位置为画布宽度的一半，在字符串中刚好是$line[6\times2^{m-2}-1]$。再由第$m$行第$1$个节点的路径（正方形对角线），我们可以知道画布高度是宽度加一的一半，即$3\times2^{m-2}$。

![手残作图见谅](https://cdn.luogu.com.cn/upload/image_hosting/dlyusdq6.png)

然后在删树时考虑标记节点的左/右儿子为删除（当然直接标记节点，调整遍历时绘制顺序也可以）。画个图可知题目所给表示方法中第$a$行$b$个节点对应直接标记的$2^{a-1}+\left\lfloor\frac{b-1}2\right\rfloor$号节点（前$a-2$层$2^{a-1}-1$个，父亲所在层连父亲$\left\lceil\frac{b-1}2\right\rceil$个），$b$为奇数的作为父亲的左儿子，$b$为偶数的作为父亲的右儿子，可直接标记。

最后遍历时，要确定边的长度，同理上面提到“正方形对角线”的思路（或者将边平移成竖直的线），易知其长度是画布高度减去子树画布高度。考虑到每层子树所在部分画布中$y$位置唯一确定，再从每层第一个节点（最左边一条树链）的特殊情况出发，可以根据上面的关系最终将其转化为总画布高度减去子树根节点$y$坐标整体的一半（详见代码）。然后直接遍历绘出、输出即可，不过需要注意、容易写出问题的是还是边界的确定。

### 代码
----
（其实这段代码忽略了符合题意的删树根的情况（会RE），但居然过了emmmm，不过也只需加个特判就行（或者上文提到的遍历绘制顺序））
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int m,n,len,lend2;//n、m、画布宽度及宽度除以二
char line[3*(1<<9)][6*(1<<9)];//保险起见以及字符串终止\0标记，大一点
bool del[(1<<9)+1][2];
void dfs(int y,int x,int p)
{
	//cout<<y<<' '<<x<<endl;
	line[y][x]='o';
	if(y+1>=lend2)
		return;
	int t=(lend2-y)/2+1;
	if(!del[p][0])
	{
		for(int i=1;i<t;i++)
			line[y+i][x-i]='/';
		dfs(y+t,x-t,p<<1);
	}
	if(!del[p][1])
	{
		for(int i=1;i<t;i++)
			line[y+i][x+i]='\\';
		dfs(y+t,x+t,p<<1|1);
	}
}
int mian()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>m>>n;
	len=(1<<(m-2))*6-1;
	lend2=len/2;
	for(int i=0,a,b;i<n;i++)
		cin>>a>>b,
		del[((1<<(a-2))+(b-1)/2)][(b&1)^1]=1;
	memset(line,' ',sizeof(line));//可优化为按需初始化
	dfs(0,lend2,1);
	for(int i=0;i<=lend2;i++)
		line[i][len]=0,//截断字符串
		cout<<line[i]<<'\n';
	return 0;
}
```

終わり

---

## 作者：跟你沟通 (赞：11)

首先先说一下最后一个测试点很多人RE的问题,我来了一张图:
![](https://cdn.luogu.com.cn/upload/image_hosting/j76jqa31.png)
大概就是图里的那样...

下面是我的思路:
可能~~稍微~~复杂一点...

首先,题意我就不说了,关键在于每一层的边长度不同:
大佬们已经推出来这么个东西:
```cpp
	f[20]={0,1,2,5,11,23,47,95,191,383,767};
```
其中f[i]就是高度为i的那一层到它上一层的边的长度(这里的高度指的是由下往上数的高度,为了方便我把最下边设为了1)
举个例子(样例)![](https://cdn.luogu.com.cn/upload/image_hosting/4ll725uh.png):
也就是说f[i]存的就是第i层到第i-1层的边的长度(几个'/'或'\\')


我是先把最下边一层先初始化弄进去,因为我不知道n,所以我从我开的画布数组最下边一行开始,从下往上:
```cpp
cin>>n>>k;
num=1<<(n-1);
for(long long i=1,j=1;i<=num/2;++i,j+=6)
{
		paint[19000][j]='o';
		paint[19000][j+4]='o';
}
```
两个一组,很容易得出最下面一行共需要(2^(n-1))/2次循环,每次直接两个都放进去'o',然后很容易的j每次加6(横坐标)

然后从倒数第二行开始模拟往画布里填'o'或'/'或'\\'
我们可以这样:计算出当前行的最左/最右结点在画布里的坐标为循环边界,从左边(当前行的所有结点视为向上一行的结点的孩子),即左孩子开始,向右上方朝父节点画'/'.

但是要画几次呢?这时我们的f[]数组就派上用场了...从第i层向上画'/'当然画f[i]次了,然后画完边后再向右上一格把父节点也就是'o'画上,然后从父结点再往右下画回到右孩子,然后这一个子树画完再画旁边的树,画个流程图吧:![](https://cdn.luogu.com.cn/upload/image_hosting/ghvps2ft.png)

就是这样,先上去,再下来,然后虚线跳到下一个子树,注意这时跳跃的长度每层是不一样的,我们用s[]来存,很容易得出(跟f[]很类似):
```cpp
	s[20]={0,2,6,12,24,48,96,192,384,768,1536};
```
每次横坐标加就行了

这样,我们最后就有了一个完全二叉树,然后就是去节点了.
画布里存得是点或边在这张"画"里得坐标,而题目输入进来得是结点在树中得坐标,这时我们就开一个结构体数组存树,数组的每个元素为结点,每个元素(都是一个结构体变量)里的结构体成员x和y存的是通过计算求得的在画布里的坐标,然后找到要删除的点,把它和它的子树所在的一个正方形区都归为' '(空格),如图:![](https://cdn.luogu.com.cn/upload/image_hosting/n0l0wfis.png)

然后,愉快的输出就行了,其他的细节在代码中:

AC代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,num,x,y,line=19000;
long long l,r,f[20]={0,1,2,5,11,23,47,95,191,383,767};//解释过了
long long s[20]={0,2,6,12,24,48,96,192,384,768,1536};//跳跃的长度
char paint[20001][5000];//画布
struct TREE
{
	long long x,y;
}tree[1040];
void draw(long long i)//画边和点
{
	x=line,y=l;
	l=y+f[i]+1;//l---左边界的重新计算要在这里
	for(long long j=1;j<=num/2;++j)
	{
		/////////向右上画//////////////
		for(long long k=1;k<=f[i];++k)
			paint[--x][++y]='/';
		paint[--x][++y]='o';
		//////////////////////////////
		/////////向左下画回去//////////
		for(long long k=1;k<=f[i];++k)
			paint[++x][++y]='\\';
		//////////////////////////////
		++x;
		y++;
		y+=s[i];
		//重新计算坐标
	}
	y-=s[i];
	r=y-f[i]-1;
	line=x-f[i]-1;
	num/=2;
	//把num---即当前行的结点数、
	//r---右边界、
	//line---最高点的所在行
	//重新计算为向上一行(左边界在上边重新计算)
}
void remove_down_all(long long up,long long r_l,long long r_r)//重置矩形区域
{
	for(long long i=up;i<=19000;++i)
		for(long long j=r_l;j<=r_r;++j)
			paint[i][j]=' ';
}
void remove_up_edge(long long x,long long y)//删除(重置为' '(即空格))要删除点向上与父亲的连线
{
	long long ex=x-1,ey=y-1;
	if(paint[ex][ey]!=' ')
		while(paint[ex][ey]!='o')
			paint[ex--][ey--]=' ';
	ex=x-1,ey=y+1;
	if(paint[ex][ey]!=' ')
		while(paint[ex][ey]!='o')
			paint[ex--][ey++]=' ';
}
int main()
{
	cin>>n>>k;
	if(n==0)
	{
		cout<<endl;
		return 0;
	}
	memset(paint,' ',sizeof(paint));
	num=1<<(n-1);
	long long num2=num;
	long long len=0;
	long long to=(num2/2)*6-1;//to为整棵树的宽度,我们要用它输出树(列循环范围)
	l=1;r=(num/2)*6-1;//初始化左右边界
	for(long long i=1,j=1;i<=num/2;++i,j+=6)//初始化最下面一行
	{
		paint[19000][j]='o';
		paint[19000][j+4]='o';
	}
	for(long long i=1;i<n;++i)//开始从下往上每一层"绘画"
		draw(i);

	for(long long i=line;i<=19000;++i)//计算坐标,用以删除结点
		for(long long j=1;j<=to;++j)
		{
			if(paint[i][j]=='o')
			{
				tree[++len].x=i;
				tree[len].y=j;
			}
		}
	long long t,y1,y2;
	for(long long i=1;i<=k;++i)//删除结点(每次删除之前的准备工作)
	{
		scanf("%d%d",&x,&y);
		t=1<<(x-1);
		t=t+y-1;
		if(t>len)continue;
		x=tree[t].x;
		y=tree[t].y;
		y1=y-(19000-x);
		y2=y+(19000-x);

		remove_down_all(x,y1,y2);
		remove_up_edge(x,y);//这两个函数才是真正的删除
	}
	//处理完了......
	for(long long i=line;i<=19000;++i)//输出,结束
	{	
		for(long long j=1;j<=to;++j)
			cout<<paint[i][j];
		cout<<endl;
	}
}
```
管理员求过...真的是自己的做法

---

## 作者：张皓涵 (赞：9)

这道题只要弄明白了一件事情，就可以很顺利地解决——千万不要以为一定要从上往下建造！！！其实可以在数组中搭建出来，再一起输出！！！具体看代码————
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[100]={0,1,2,5,11,23,47,95,191,383,767};//a[i]记录第n-i层往下“/”和“\”的数量（找规律）
int deep[100]={0,1,3,8,19,42,89,184,375,758,1525};//记录树的深度所对应的输出行数（其实可以偷懒直接输出两千行，输出文件末尾空行会忽略）
char draw[2001][2001]; //在数组中处理这棵树
bool book[40000001]; //这个节点编号是否被删掉（编号为BFS序）
int n,m,first; //first为根节点的横坐标
void build(int k,int depth,int x,int y) //k是节点编号，depth是深度，x、y是数组中的坐标
{
	if(book[k]==1) return; //如果被删掉了，就跳过
	if(depth>n) return; //如果这棵树到底了，回溯
	draw[x][y]='o';//节点赋值
	if(!book[k*2]&&!(depth+1>n))//左树枝建造 
	{//左儿子没被删掉，自己不是叶节点
		int x1=x,y1=y; //备份一下，后面还有右儿子
		for(int i=1;i<=a[n-depth];i++)
		{
			x1--;
			y1++;  //往左下移动
			draw[x1][y1]='/'; //画树枝
		}
		build(k*2,depth+1,x1-1,y1+1);//递归建造左儿子
	}
	if(!book[k<<1|1]&&!(depth+1>n))//同理，右树枝建造
	{
		int x2=x,y2=y;
		for(int i=1;i<=a[n-depth];i++)
		{
			x2++;
			y2++; //往右下移动
			draw[x2][y2]="\\"; //记住只有这样才能输出“\”哦！
		}
		build(k*2+1,depth+1,x2+1,y2+1);
	}
}
int main()
{
	for(int i=1;i<=2000;i++)
		for(int j=1;j<=2000;j++)
			draw[i][j]=' ';  //初始化为空格
	cin>>n>>m; //读入深度和删除个数
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b; //读入删除节点
		book[int(pow(2,a-1)-1+b)]=1; //a-1行共有 a-1的平方-1 个节点，第a行有b个，所以是第pow(2,a-1)-1+b个，记住，pow返回的是小数，所以要强制转换，要不数组处理不了
	}
	first=pow(2,n-1)*6/4; //最下面的左叶子、右叶子和空格共占6格，pow(2,n-1)是最下层的叶子总数/2后算出有几组，再/2算出一半（根节点再中间）
	build(1,1,first,1); //开始建造
	for(int i=1;i<=deep[n];i++)
	{
		for(int j=1;j<=first*2;j++)
			cout<<draw[j][i]; //记住不要空格！！（我是不会跟你说我因为cout<<draw[i][j]<<' ';的原因调了20分钟的）
		cout<<endl; //换行
	}
}

---

## 作者：1jia1 (赞：5)

思路：

这题我用了两种算法（？），画二叉树用了分治，

吃(去)掉子节点用了深搜（回溯(sù)）。还有一个，就是第一层前面空格的数量和两个节点之间的线的长度需要计算。怎么算呢？我们机智的c07同学用了打一个二维表的办法。我们先拿4层的满二叉树来举个栗(例)子：

o
/ \
/   \
/     \

/       \

/         \

o           o

/ \         / \

/   \       /   \

o     o     o     o

/ \   / \   / \   / \

o   o o   o o   o o   o

（注意第一个叶子节点前面有个空格）

我们先说两点之间的线段长度。从这里我们可以看到，最底层的倒数1、2层的点之间的长度是1根线段3格长度，2、3层的点之间长度是2根线段4格长度。这在任何在层数足够的二叉树中都是对的。

那要怎么算呢？

比如倒数第三层和倒数第四层之间的距离，从上图可以看到，二叉树可以转换成这样：

o
/ \
/   \
/     \

/       \

/         \

o           o

\         /

\       /

o     o

\   /
o o
o
可以看出，倒数第三层和倒数第四层之间的长度（不是距离）其实就是倒数第三层和倒数第一层之间的长度+1！知道了这点，就可以推出来a[i]=a[i-1]+a[i-2]+…+a[1]+1（其中a[i]是倒数长度。

不过这个长度并没有什么卵用！！所以不需要求这个东西。

我们现在来推两点之间的距离。很简单，除了倒数第一层和倒数第二层的距离是1、倒数第二层和倒数第三层的距离为2以外，其它都是a[i]=a[i-1]\*2+1(i>2,a[i]表示倒数第i层和倒数第i+1层的距离)。推出这一点，正数第一层的点前面的距离就出来了，如果n表示有n层的二叉树，那么第一层的点的前面的空格数量就是a[n]。然后整个二叉树的二维数组就要开for(int i=1;i<=n;i++)nn+=b[i]+1; \* mm=b[n+1]\*2+1;大。


去掉节点就简单了，找到那个点在数组的坐标，然后先把它与父节点的线用循环抹掉，然后用回溯砍掉所有与它连在  1起的非空格的东西就好了。







代码如下：

```cpp
-#include <iostream>-
-#include <cstdio>-
-#define hhh (char)(32)-
-using namespace std;-
-int b[12]={0},n=1,m=1,nn,mm;-
-char a[2005][2005],g[2005][2005];-
-void draw(int x,int y,int c)---c是当前绘制的层数 
-{-
-    a[x][y]='o',g[x][y]='o';-
-    if(c==0)return;-
-    for(int i=1;i<=b[c];i++)-
-    {-
-        a[x+i][y-i]='/';-
-        a[x+i][y+i]='\\';-
-        g[x+i][y-i]='/';-
-        g[x+i][y+i]='\\';-
-    }-
-    draw(x+b[c]+1,y-b[c]-1,c-1);-
-    draw(x+b[c]+1,y+b[c]+1,c-1);-
-    return;-
-}-
-void kill(int x,int y)---砍掉子节点
-{-
-    a[x][y]=' ';-
-    if(a[x+1][y-1]!=hhh&&x+1<=nn&&y-1>=1)kill(x+1,y-1);-
-    if(a[x+1][y+1]!=hhh&&x+1<=nn&&y+1<=mm)kill(x+1,y+1);-
-    return;-
-}-
-int main()-
-{-
-    freopen("binary.in","r",stdin);-
-    freopen("binary.out","w",stdout);-
-    b[1]=1,b[2]=2;-
-    for(int i=3;i<=11;i++)b[i]=b[i-1]*2+1;-
-    cin>>n>>m;-
-    n--;-
-    nn=1;-
-    for(int i=1;i<=n;i++)nn+=b[i]+1;-
-    mm=b[n+1]*2+1;-
-    for(int i=1;i<=nn;i++)for(int j=1;j<=mm;j++)a[i][j]=hhh;-
-    draw(1,b[n+1]+1,n);-
-    cout<<nn<<' '<<mm<<endl;-
-    for(int i=1,xx,yy,xl,yl;i<=m;i++)-
-    {-
-        cin>>xl>>yl;-
-        if(xl==1&&yl==1)-
-        {-
-            for(int i=1;i<=nn;i++)-
-            {-
-                for(int j=1;j<=mm;j++)cout<<hhh;-
-                cout<<endl;-
-            }-
-        }-
-        xl--;-
-        xx=1;-
-        for(int j=n;j>=n-xl+1;j--)xx+=b[j]+1;-
-        int o=0;-
-        yy=1;-
-        while(o<yl&&yy<=mm)---找节点的坐标
-        {-
-            if(g[xx][yy]=='o')o++;-
-            yy++;-
-        }-
-        yy--; -
-        if(a[xx][yy]==hhh)continue;---如果这个点已经被从世界上抹去了，就不用了
-        if(a[xx-1][yy-1]=='\\')---砍掉与父节点的线
-        {-
-            for(int i=1;a[xx-i][yy-i]!='o';i++)a[xx-i][yy-i]=hhh;---for语句大法好
-        }-
-        else-
-        {-
-            for(int i=1;a[xx-i][yy+i]!='o';i++)a[xx-i][yy+i]=hhh;-
-        }-
-        kill(xx,yy);-
-    }-
-    for(int i=1,k;i<=nn;i++)-
-    {-
-        k=mm;-
-        while(a[i][k]!='/'&&a[i][k]!='\\'&&a[i][k]!='o')k--;-
-        for(int j=1;j<=k;j++)cout<<a[i][j];-
-        cout<<endl;-
-    }-
-    return 0;-
-}-

```

---

## 作者：WLHW (赞：4)


### 题外话
- 非常庆幸，此题可以输出多余的空格   $(～￣▽￣)～$
- 被此题逼疯  $ﾍ(;´Д｀ﾍ)$
- 毫无技巧的模拟
___

### 题解__1（先来考虑 $n==0$）
- 首先我们可以定义最后一行为  第 $2002$ 行（为什么是 $2002$ 个人喜好）
- 然后发现每一行是从 $2002 - h+1$ 开始的（$h$ = 所在行）
- 除了最后一行，其他的 $“o”$ 之间的空格都是相同的
- 再然后，我们惊奇地发现 这些 **空格** 恰好 $=$  **斜杠（这个‘o’上面的）的数量**$*2+1$
- 再然后，我们惊奇地发现 **斜杠（这个‘o’上面的）的数量**恰好 $=$  **$2002-h$**
- 所以就可以开始模拟了 $->$ 我是从倒数第三行开始模拟的，最后两行最后填。
```cpp
                            o
                           / \
                          /   \
                         /     \
                        /       \
                       /         \
                      /           \
                     /             \
                    /               \
                   /                 \
                  /                   \
                 /                     \
                o                       o
               / \                     / \
              /   \                   /   \
             /     \                 /     \
            /       \               /       \
           /         \             /         \
          o           o           o           o
         / \         / \         / \         / \
        /   \       /   \       /   \       /   \
       o     o     o     o     o     o     o     o   2000
      / \   / \   / \   / \   / \   / \   / \   / \  2001
     o   o o   o o   o o   o o   o o   o o   o o   o 2002
```


#### 题解__2（ $n！=0$）
- 就是先把$n==0$ 时的二叉树建出
- 然后在向上填数的时候顺便做一个 $earse$（具体见代码）

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[2010][2010],h=2000;
int b[2010][2010];
char turn(int x)
{
	if(x==0) return ' ';
	if(x==1) return 'o';
	if(x==2) return '/';
	if(x==3) return '\\';
}
void earse(int hi,int l,int r)
{
	if(hi==2001) return ;
	if(b[hi][l]==1) earse(hi+1,l-1,l+1);
	if(b[hi][l]==2) earse(hi+1,l-1,l-1);
	if(b[hi][l]==3) earse(hi+1,l+1,l+1);
	if(l!=r)
	{
		if(b[hi][r]==1) earse(hi+1,r-1,r+1);
		if(b[hi][r]==2) earse(hi+1,r-1,r-1);
		if(b[hi][r]==3) earse(hi+1,r+1,r+1);
	}
	b[hi][l]=b[hi][r]=0;
}
void dfs(int x)
{
	int i,j,n=pow(2,x-1),now=2002-h+1,cnt=2002-h;
	b[h][now]=1;
	if(x==1) return ;
	for(i=2; i<=n; i++)
	{
		now+=cnt*2+2;
		b[h][now]=1;
	}
	now=2002-h+1;
	for(i=1; i<=n; i++)
	{
		if(a[x][i]) // 把这个节点下面的已经填好的数删除
		{
			earse(h,now,now);
			now+=cnt*2+2;
			continue;
		}
		// 填写当前结点向上的斜杠。
		if(i&1)
		{
			for(j=1; j<=cnt; j++) b[h-j][now+j]=2;
		}
		else
		{
			for(j=1; j<=cnt; j++) b[h-j][now-j]=3;
		}
		now+=cnt*2+2;
	}
	h=h-cnt-1;
	dfs(x-1);
}
int main()
{
	int n,m,x,y,i,j;
	scanf("%d%d",&m,&n);
	memset(b,0,sizeof(b));
	for(i=1; i<=n; i++)
	{
		scanf("%d%d",&x,&y);
		a[x][y]=1;
	}
	if(a[1][1]) return 0;
	if(m==1) return cout<<'o',0;
	x=1;
	dfs(m-1);
	int now=1;
	for(i=1; i<=pow(2,m-1); i++)
	{
		if(a[m][i]||(i%2!=0&&b[2000][now+2]==0)||(i%2==0&&b[2000][now-2]==0))
		{
			if(i&1) now+=4;
			else now+=2;
			continue;
		}
		b[2002][now]=1;
		if(i&1) b[2001][now+1]=2;
		else b[2001][now-1]=3;
		if(i&1) now+=4;
		else now+=2;
	}
	for(i=h; i<=2002; i++)
	{
		for(j=1; j<=6*pow(2,m-2)-1; j++) cout<<turn(b[i][j]); 
		// 共有 6*pow(2,m-2)-1 列（可以根据最后一行来计算）
		if(i!=2002) puts("");
	}
	return 0;
}
```


---

## 作者：TianLuen (赞：3)

# P1185 C++ 题解
## 题意简述
- 给定 $2$ 个数 $m,n$。
- 绘制一棵层数为 $m$ 的满二叉树，格式详见题面。
- 接下来要删除 $n$ 个结点（包括与父节点的连接、左子树、右子树）。
- 输出这棵已经删除了若干个结点的二叉树。
- $2\le m \le 10, 0\le n \le 10$ 。

## 题意分析
这是一道模拟题，数据范围不大。

我的思路是：

1. 先建立一棵满二叉树，存在一个二维字符数组中。
2. 查到到需要删除结点的坐标。
3. 根据坐标进行查找需要删除的连接和子树，并标记为“已删除”。

首先我们需要计算这棵二叉树的层数，不妨将其命名为 `Floor`，而它的值经过计算，就是 $3\times 2^{m-2}$ 。这个数组的最大宽度就是 $2 \times \text{Floor}$ 。

接下来是每一部分的详细说明。
### 绘制二叉树（ make_tree ）
我的策略是从下往上、从左到右，判断每一个都应该是什么字符。

1. 第 $m$ 层是有规律的，当横向坐标 $j$ 对 $6$ 取模求余的结果是 $1$ 或 $5$ 时，那么它就是个节点。
2. 当一个字符的左下方是左斜杠，右下方是右斜杠时，那么它也是个节点。
3. 当一个字符左下、右下其中有且仅有一个是斜杠或节点时，那么它是个连接。
4. 除此之外，是空格。

注意右斜杠是 `\\` 。

此时加入一个 `flag` 变量，判断连接的朝向。还要注意一个节点不能出现两个父节点，因此在加入左斜杠时需要判断左侧第2个字符不是右斜杠。
### 查找二叉树（ find_tree ）
为了方便查找，因此删除结点不是直接抹除，而是做特殊标记。这个标记因人而异，我把删除的节点标注为 `*` ，删除的链接标注为 `-`。

定义两个计数器 `cnt1,cnt2`，先进行纵向查找，再进行横向查找，查找到节点（包括已标记为删除的），对应的计数器增加1。

当两个计数器分别是输入中的 $i,j$ 时，返回坐标。（可能讲得不太清楚，详细请见下方的代码部分）
### 删除子二叉树（ delete_tree ）
首先用 `find_tree` 查到对应的坐标，然后做如下操作。

1. 如果这个点的左上或右上方有斜杠，那么沿着这条斜杠一直向上搜查，直到遇到父节点或边界，搜查中所有的斜杠标记为删除。
2. 如果这个点的左下或右下方有斜杠，那么分别沿着斜杠一直向下搜查，直到遇到子节点，此时调用自身，递归。搜查过程中所有的斜杠和节点标记为删除。
3. 自身标记为删除。

### 输出二叉树 （ print_tree ）
遍历二维数组，将未标记为删除的字符原样输出，标记为删除的字符输出空格。

## AC代码
```cpp
#include<iostream>
#include<cmath>
#define f first
#define s second
using namespace std;
char tree[2000][2000];
int m,n,Floor,tmp1,tmp2;
void make_tree()
{
    bool flag;
    for(int i=1;i<=Floor;i++)
        for(int j=1;j<=Floor-i;j++)
            tree[i][j]=' ';
    for(int i=Floor;i>=1;i--)
    {
        flag=0;
        for(int j=1;j<=2*Floor;j++)
            if(((j%6==1||j%6==5)&&i==Floor)||(tree[i+1][j-1]=='/'&&tree[i+1][j+1]=='\\'))
                tree[i][j]='o';
            else if((tree[i+1][j-1]=='o'||tree[i+1][j-1]=='/')&&flag==0&&tree[i][j-2]!='\\')
            {
                tree[i][j]='/';
                flag=1;
            }
            else if((tree[i+1][j+1]=='o'||tree[i+1][j+1]=='\\')&&flag==1)
            {
                tree[i][j]='\\';
                flag=0;
            }
            else
                tree[i][j]=' ';
    }
}
pair<int,int> find_tree(int x,int y)
{
    int cnt1=0,cnt2=0,i,j;//cnt1:当前查找到的纵向节点数量，cnt2:当前查找到的横向节点数量
    for(i=1,j=Floor;i<=Floor&&j>=1;i++,j--)
    {
        if(tree[i][j]=='o'||tree[i][j]=='*')
            cnt1++;
        if(cnt1==x)break;
    }
    for(j=j;j<=2*Floor;j++)
    {
        if(tree[i][j]=='o'||tree[i][j]=='*')
            cnt2++;
        if(cnt2==y)break;
    }
    return {i,j};
}
void delete_tree(pair<int,int>x)
{
    tree[x.f][x.s]='*';
    if(tree[x.f-1][x.s-1]=='\\')
        for(int i=x.f-1,j=x.s-1;i>=1&&j>=1;i--,j--)
        {
            if(tree[i][j]=='\\')tree[i][j]='-';
            else if(tree[i][j]=='o')break;
        }
    if(tree[x.f-1][x.s+1]=='/')
        for(int i=x.f-1,j=x.s+1;i>=1&&j<=2*Floor;i--,j++)
        {
            if(tree[i][j]=='/')tree[i][j]='-';
            else if(tree[i][j]=='o')break;
        }
    for(int i=x.f+1,j=x.s-1;i<=Floor&&j>=1;i++,j--)
        if(tree[i][j]=='/')tree[i][j]='-';
        else if(tree[i][j]=='*')break;
        else if(tree[i][j]=='o'){delete_tree({i,j});break;}
    for(int i=x.f+1,j=x.s+1;i<=Floor&&j>=1;i++,j++)
        if(tree[i][j]=='\\')tree[i][j]='-';
        else if(tree[i][j]=='*')break;
        else if(tree[i][j]=='o'){delete_tree({i,j});break;}
}
void print_tree()
{
    for(int i=1;i<=Floor;i++)
    {
        for(int j=1;j<=2*Floor;j++)
            if(tree[i][j]!='*'&&tree[i][j]!='-')cout<<tree[i][j];
            else cout<<" ";
        cout<<endl;
    }
}
int main()
{
    cin>>m>>n;
    Floor=3*pow(2,m-2);
    make_tree();
    for(int i=0;i<n;i++)
    {
        cin>>tmp1>>tmp2;
        delete_tree({find_tree(tmp1,tmp2)});
    }
    print_tree();
    return 0;
}
```
# The end

---

## 作者：DoctorSix (赞：2)

本题的难点之一是删除结点。我们考虑从上往下逐行画图，每次画完一行‘o’之后，逐个检查每个结点的子节点是否被删除，如果被删除则不再画相应的‘/’或‘\’。
本题解不设置完整画布，只设置一行并逐行输出。每一行可以参考上一行画的结果来画。例如，在两行‘o'之间，只要上一行在下标为i的地方是/，则本行中下标为i-1的地方是/，下标为i的地方是空格。但需要注意的是含有‘o'的行的下一行，在此行需要判断下一层的结点是否被删除，如果被删除，则不画/或\。这样在含有‘o’的行的下下行，根据上一行的情况即可绘制下一行，直到碰到下一层‘o'。具体第几行需要画‘o'，找规律即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int i,m,n,del[15][2],sz,gr,lnLim,r,c,k,line;
    cin>>m>>n;
    for(i=0;i<n;i++) cin>>del[i][0]>>del[i][1];
    sz=6*(1<<m-2);gr=sz>>1;
    char *ln;
    ln=(char *)calloc(sz,sizeof(char));
    memset(ln,' ',sz*sizeof(char));
    for(i=0;i<n&&(del[i][0]!=1||del[i][1]!=1);i++);
    if(i>=n) ln[gr]='o';
    for(i=1;i<sz;cout<<ln[i++]);cout<<endl;        //打印一行
    for(r=1,line=2;r<m;gr>>=1,line++,r++){       //
        for(k=1;k<sz;k++){
            if(ln[k]=='o'){                                         //根据下一层的o是否被删除来画/或\
                c=(k-gr)/(gr*2)+1;
                for(i=0;i<n&&(del[i][0]!=r+1||del[i][1]!=2*c-1);i++);
                if(i>=n) ln[k-1]='/';
                for(i=0;i<n&&(del[i][0]!=r+1||del[i][1]!=2*c);i++);
                if(i>=n) ln[k+1]='\\';
                ln[k]=' ';
            }
        }
        for(i=1;i<sz;cout<<ln[i++]);cout<<endl;      //打印一行
        line++;
        lnLim=line+(gr>>1)-2;
        for(;line<lnLim;line++){                                  //上一行有/就画/，有\就画\
            for(i=2;i<sz;i++){
                if(ln[i]=='/') ln[i-1]='/';
                else if(ln[i]=='\\') ln[i+1]='\\';
                if(ln[i]!=' ') ln[i++]=' ';
            }
            for(i=1;i<sz;cout<<ln[i++]);cout<<endl;       //打印一行
        }
        for(i=1;i<sz;i++){                                               // 画这一层的‘o'
            if(ln[i-1]=='\\'||ln[i+1]=='/'){
                ln[i]='o';
                ln[i-1]=ln[i+1]=' ';
            }
        }
        for(i=1;i<sz;cout<<ln[i++]);cout<<endl;            //打印一行
    }
    return 0;
}

```


---

## 作者：dolphin (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
void delson(int,int,int);
void delfat(int,int,int);
void make(int,int,int);
const int N=1025;
int b[11]={1,2,4,8,16,32,64,128,256,512,1024},//初始化2的次方
    tree[20],judge[N][3*N];
char a[N][3*N];
int high1,high2,high3,high4,s=0,m,n;
int main(){
    int x,y,l,w; 
    scanf("%d %d",&m,&n);
    memset(a,' ',sizeof(a));//ASCII32，空格
    w=b[m-1]*3-1;/*总宽度（把最下层同一子树的两个节点加后面的一个空格，即【o‘ ‘’ ’‘ ’o‘ ’】看作【o‘ ’‘ ’‘ ’】*2，并在最后减去一个空格）*/
    high1=(w+1)/2;//总高度 
    make(1,high1,(high1+1)/2);//递归建树
    if (n!=0)
        for (int i=1;i<=n;i++){
            scanf("%d %d",&x,&y);
            l=0;
            high2=tree[x];// 待删除的节点所在高度 
            high3=tree[x-1];//该节点父节点高度 
            high4=tree[x+1];//该节点子节点高度 
            for (int j=1;j<=w;j++){
                if (a[high2][j]=='o'){
                    l++;
                    if (l==y) {
                        delson(high2,j,high4-high2);//删除子树
                        delfat(high2,j,high2-high3);//删除该结点与其父节点的连接
                         break;
                    }
                }    
            }
        }
    for (int i=1;i<=high1;i++){
        for (int j=1;j<=w;j++){
            if (judge[i][j]==0)
                printf("%c",a[i][j]);
            else  cout<<' ';
        }
        printf("\n");
    }
}
void make(int p,int q,int h){  //h：该结点到下一层节点的连接符号个数
    a[p][q]='o';
    if (s<=m){
        s++;tree[s]=p;
    }
    if (h==1) return;
    for (int k=1;k<h;k++){
        a[p+k][q-k]='/';
        a[p+k][q+k]='\';
    }
    make(p+h,q-h,(h+1)/2);
    make(p+h,q+h,(h+1)/2);
}
void delson(int p,int q,int h){
    judge[p][q]=1;
    if (h==0) return;
    if (h==1){
        judge[p+1][q+1]=1;
        judge[p+1][q-1]=1;
        judge[p+2][q+2]=1;
        judge[p+2][q-2]=1;
        return;
    }
    for (int k=1;k<h;k++){
        judge[p+k][q-k]=1;
        judge[p+k][q+k]=1;
    }
    delson(p+h,q-h,h/2);
    delson(p+h,q+h,h/2);    
}
void delfat(int p,int q,int h){
    for (int i=1;i<h;i++){
        judge[p-i][q-i]=1;
        judge[p-i][q+i]=1;
    }
}
```

---


# 序列变换

## 题目描述

给定一个由 $n$ 个整数构成的序列 $a_1, a_2, \ldots , a_n$，你需要对它进行如下操作：

1. 输入格式 `1 x y`，表示把所有 $a_{k x}$（$k$ 为正整数，$k x \le n$）都加上 $y$。
2. 输入格式 `2 j`，表示输出 $a_j$。

## 说明/提示

对于 $40 \%$ 的数据，$n \le 100$。  
对于 $100 \%$ 的数据，$1 \le n \le {10}^6$，$1 \le m \le {10}^5$，$|a_i| \le {10}^6$，$|y| \le {10}^6$，$1 \le x\le n$，$0\le j \le n$，操作 2 不超过 ${10}^4$ 条。

## 样例 #1

### 输入

```
5 4
6 9 9 8 1 
2 4
1 2 5
1 3 1
2 4
```

### 输出

```
8
13```

# 题解

## 作者：小小怪下士___ (赞：28)

# 一开始以为用线段树之类的去写。然后发现不用这么麻烦！！！（标签）
### 写题就是爆~ 得了个60！仔细看了下数据范围 发现操作二不超过10000。我们就直接把题目说的a k的倍数加上x转换一下不就是ok了吗！
## y是x的倍数 也可以说x是y的约数。比如（6是2的倍数，那么2就是6的约数咯）。那我们直接把一操作的位置和值存起来。需要的时候在找是不是我这个数的约数。如果是就加上不是则跳过就ok了。
```c
#include<bits/stdc++.h>
using namespace std;
const int ch=1000010;
int a[ch],n,m,ans;
map<int,int>t;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	while(m--)
	{
		int x;
		scanf("%d",&x);
		if(x==1)
		{
			int y,z;
			scanf("%d%d",&y,&z);
			t[y]+=z;//标记起来 
		}
		if(x==2)
		{
			int z,zhi=0;
			scanf("%d",&z);
			for(int i=1;i<=z/i;i++)//快速判断约数 
			{
				if(z%i==0)//如果这个数的约数 
				{
					if(t[i]){zhi+=t[i];}//且出现过不为0就累加 
					if(i!=z/i&&t[z/i])zhi+=t[z/i];//同上 
				}
			}
			printf("%d\n",a[z]+zhi);//原来的值加上增加的值 
		}
	}
}
```


---

## 作者：pikabi (赞：9)

提供一种**线性筛求约数**的方法

相信对于每一个询问，大家都是用 $\sqrt{n}$ 的复杂度枚举它的所有约数，进行答案的累加。但是，如果题目的操作 2 没有限制在 $10 ^ 4$ 的范围内，我们应该如何实现呢？

因为我们不会对操作 1 有什么大优化操作，所以从查找约数入手的优化入手。

想到线性筛可以做到筛出 1 至 $n$ 种每一个数的最大质因子或最小质因子，这样我们就可以求出一个数的所有质因子及其指数，然后枚举每一个质因子的指数就可以得出它的所有约数了。复杂度为 $ O ( m \times \sigma_0(n)$ ) , 后者也就是所谓除数函数，比一般解法要快。目前为最优解 $rank 1$ 。

code $-->$

```
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cctype>
//#define int long long
#define ll long long
#define inf 1023456789

using namespace std;

inline int read(){
	int x=0,w=0;char ch=getchar();
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return w?-x:x;
}

int n, m, prime[1000005], cnt, min_prime[1000005];
ll a[1000005], b[1000005], res;
bool vis[1000005];
int que[1005], num[1005], now;

inline void dfs(int p, int u){
	if(p == now + 1) {
		res += b[u];
		return ;
	}
	int w = 1;
	for(int i = 0; i <= num[p]; i++){
		dfs(p + 1, u * w);
		w *= que[p];
	}
}

signed main(){
	n = read(), m = read();
	for(int i = 2; i <= n; i++){
		if(!vis[i]){
			prime[++cnt] = i;
			min_prime[i] = i;
		}
		for(int j = 1; j <= cnt && prime[j] * i <= n; j++){
			vis[i * prime[j]] = 1;
			min_prime[i * prime[j]] = prime[j];
			if(i % prime[j] == 0) break;
		}
	}
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= m; i++){
		int op = read();
		if(op == 1){
			int x = read(), y = read();
			b[x] += y;
		}
		else {
			int x = read();
			if(!x) {
				puts("0");
				continue;
			}
			int xx = x;
			res = 0;
			now = 0;
			while(x > 1){
				now++;
				int w = min_prime[x];
				que[now] = w;
				num[now] = 0;
				while(x % w == 0){
					num[now]++;
					x /= w;
				}
			}
			dfs(1, 1);
			printf("%lld\n",a[xx]+res);
		}
	}
}

```

完结撒花 *★,°*:.☆(￣▽￣)/$:*.°★* 。

---

## 作者：litc (赞：7)

kkksc03说：乍看第一题吓坏了，在想要用什么高级数据结构。

其实，这是一道水题。

对于操作1，可以用一个d数组记录——读入“1 x y”后，将d[x]加上y。这样在操作2时，可以用O(j^0.5)枚举j的因数，计算出新的a[j]并打出。由于操作2不超过10000条，所以程序总的运算次数不会超过n+m+10000\*n^0.5，1s轻松ac。

不过有一点需要注意：当j为完全平方数时须特判，否则可能会加两次d[j^0.5]。


---

## 作者：王启源 (赞：6)

同楼下，一看以为是线段树，，，

发现2操作的个数是**小于等于10000**的，用一个数组（下面代码是b数组） ，存下标的倍数加了多少，每次2操作的时候暴力根号拆x判断就行了（注意完全平方数）

下面是代码



```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long LL;
template <class T> inline void read(T & x){
    x=0;
    T f=1;
    char ch = getchar();
    while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=(x<<1)+(x<<3)+ch-'0',ch = getchar();
    x*=f;
}
const int N = 1e6+10;
LL a[N];
LL b[N];
LL n,m;
int main(){
    read(n);
    read(m);
    for(int i=1;i<=n;++i) read(a[i]);
    int opt,x,y;
    for(int i=1;i<=m;++i){
        read(opt);
        if(opt == 1){
            read(x);
            read(y);
            b[x] += (LL)y;
        }
        if(opt == 2){
            read(x);
            LL ans = a[x];
            for(int j=1;j*j<=x;++j)
                if(x%j == 0){
                    if(j*j!=x)ans += b[j]+b[x/j];
                    else ans +=b[j];
                }
            printf("%lld\n",ans);
        }
    }
}
```

---

## 作者：myee (赞：4)

### Update

许多人得了 $60$ 分，而不解原因。$60$ 分的[看过来](https://www.luogu.com.cn/discuss/show/35275)。

其实是因为出题人不讲武德，造假数据，说说是 $1\le j\le n$，实际上有
$j=0$ 的情况，而这**对于有的算法是毁灭性的打击**。

### 思路

根号分治。

设阈值 $\mathtt{lim}$ ，修改操作在阈值以上时，暴力修是 
$O(\frac n{\mathtt{lim}})$ 的；否则打一个懒惰标记，是 $O(1)$ 的。

查询时可以乱搞，统计不超过阈值的懒惰标记中对其有影响的部分，再加上其本身已计部分，即可，复杂度 $O(\mathtt{lim})$；注意特判 $j=0$。

取 $\mathtt{lim}=\sqrt n$ 时，单次操作复杂度是最坏 $O(\sqrt n)$ 的。

其实可以更好，但请参阅其它题解，这里就不多介绍了。

### Code

```cpp
#include <stdio.h>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
const uint lim=1000;
llt Lazy[1005],A[1000005];
int main()
{
	uint n,m,op,x;llt y;scanf("%u%u",&n,&m);
	for(uint i=1;i<=n;i++)scanf("%lld",A+i);
	for(uint i=1;i<=m;i++)
	{
        scanf("%u%u",&op,&x);
        if(op==1)
        {
            scanf("%lld",&y);
            if(x<=lim)Lazy[x]+=y;
            else for(uint j=x;j<=n;j+=x)A[j]+=y;
        }
        else
        {
            if(!x)
            {
                puts("0");
                continue;
            }
            llt ans=A[x];
            for(uint j=1;j<=lim;j++)if(!(x%j))ans+=Lazy[j];
            printf("%lld\n",ans);
        }
    }
	return 0;
}
```


---

## 作者：Mine_King (赞：3)

[在我的博客中看效果更佳](https://www.luogu.com.cn/blog/195331/)

这题，首先最容易想到的是按照题目要求去暴力，然后又是最容易想到的是这样肯定过不了。那么我们思考：让所有$a_{kx}$加上$y$，就是让所有的$z \% x == 0$加上$y$，那么我们就很容易地想到在遇到操作$1$时，记录每对$x$和$y$，然后在遇到操作$2$时枚举所有他们，当$j \% x == 0$时把计数器加上$y$。但是这样还是很慢啊！！！这时，我们注意到，遇到操作$2$时我们是要判断约数的……那我们是不是可以枚举约数？答案是可以的。那就用$w_i$表示要让所有的$ki$加上$w_i$，操作$1$就是$w_x += y$，而操作$2$就是枚举所有数，若是他的因数，则加上$w_i$。等等，这样不还是很慢吗？这说明还能再优化：约数都是成双成对出现的（完全平方数例外），那我们在他得到一个约数$z$时，就可以得到他的另一个约数$x \div z$，那我们就只要枚举前$\sqrt{x}$个就可以了，然后再特判一下完全平方数，就可以让每次查询的时间为$O(\sqrt{x})$了！

讲了这么多，下面来看代码吧。
```cpp
#include<cstdio>
using namespace std;
int n,m,a[1000005];
int w[1000005];//同题解中所述
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1,x,y,opt;i<=m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)//操作1
		{
			scanf("%d%d",&x,&y);
			w[x]+=y;//同题解中所述
		}
		else
		{
			scanf("%d",&x);
			y=0;//用来记录要加多少数
			for(int j=1;j*j<=x;j++)
				if(x%j==0)//是x的约数
				{
					y+=w[j];//加上w[j]
					if(x/j!=j) y+=w[x/j];//x的另一个约数，注意判断完全平方数的情况（完全平方数的话会出现i*i=x的情况）
				}
			printf("%d\n",y+a[x]);//输出时记得加上初始的数哦
		}
	}
	return 0;
}
```

---

## 作者：Y_B_Y (赞：3)

~~**仔细观察你会发现这是一道大水题**~~

### 一.先看操作一

"输入格式“$1~x ~y$”，表示把所有$a[kx] $（$k$为正整数，$kx≤n$）都加上$y$。"

根据数据范围可知,直接操作肯定是不行的(当x都等于1,设操作1进行$m_1$次,时间复杂度$O(nm_1)$,当场爆炸),我们再观察$a[kx]$ ($k$为正整数),发现要加上$y$的数的下标都是$x$的[倍数](https://baike.baidu.com/item/%E5%80%8D%E6%95%B0/7827981?fr=aladdin),所以我们可以存$y$于数组$bf[x]$中,等一下操作2但凡是x的倍数都加上$bf[x]$(相当于$y$).

### 二.看操作二

"输入格式“$2 ~j$”，表示输出$a[j]$"

操作二就是输入下标$j$然后输出$a[j]$,根据前面所述,这里的$a[j]$还是一开始输入的值,并没有通过操作1加过$y$,因此我们在现在加
(因为要保证$a[j]$还是一开始输入的值,所以这里只要定义一个变量$num$,初始值为$a[j]$,然后再用$num$加就可以了)
,前面已经存了bf数组,我们现在要找出数组中$j$为其倍数的下标,首先肯定不能从1找到$j$(时间复杂度爆炸),根据倍数的定义,我们知道"$x$如果是$y$的倍数,那么$y$是$x$的[因数](https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0)",所以我们只要找出$j$的每个因数(设第i个为$j_i$),然后将$num$加上$bf[j_i]$就可以了

### 三.关于求因数

可能第一反应是预处理因数(也就是先算出来存好,然后再用),但是由于数据范围,会爆空间(如果存入数组yin[n][n的第i个因数],[计算](https://blog.csdn.net/qq_21208843/article/details/70173777)可得其远远超出内存限制),因此我们只能进行操作二时求因数就可以了,我们知道如果$a$是数$b$的因数,那么$\frac{b}{a}$也是$b$的因数($b$除以$\frac{b}{a}$等于$a$(正整数)),所以当我们求出一个因数时,也求出了另一个因数,那么我们就可以只找一半因数,我们发现当$a<\sqrt{b}$时$\frac{b}{a}>a$($∵a>0,b>0∴a<\sqrt{b}∴a^2<b∴a<\frac{b}{a}$),同理当$a=\sqrt{b}$时$\frac{b}{a}=a$,当$a>\sqrt{b}$时$\frac{b}{a}>a$,由此我们发现两半因数都关于$\sqrt{b}$对称分布(一个小于$\sqrt{b}$的数都可以推出一个大于$\sqrt{b}$的数,一个等于$\sqrt{b}$的数推出等于$\sqrt{b}$(程序中要舍去),所以对称),所以我们只要找所有小于等于$\sqrt{b}$的因数,因此只要循环$\sqrt{b}$次,因为操作2的的次数为$m$,所以时间复杂度是$O(m\sqrt{j})$(这里求$j$的因数),最大为100000*1000刚好为一亿(且一般达不到),可以ac

#### 小结:先初始化$num$为$a[j]$,循环$i$从1到$\sqrt{j}$,发现是因数(即j%i==0)后,求出另一个因数$\frac{j}{i}$(如果$\frac{j}{i}=i$要舍去(即后面只要加一次)),然后$num$加上$bf[i]$和$bf[\frac{j}{i}]$,循环完后输出$num$

## 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000001;
int bf[N],n,m,a[N];//变量意义上面有提到
int main()
{
    cin>>n>>m;
    for(int p=1;p<=n;p++) scanf("%d",&a[p]);//输入
    for(int p=1;p<=m;p++)
    {
        int x,y,opt,j;
        scanf("%d",&opt);//输入'1'或'2'
        if(opt==1)//操作1
        {
            scanf("%d%d",&x,&y);//输入
            bf[x]+=y;//见上文一部分
        }
        else//操作2
        {
            scanf("%d",&j);//输入
            int num=a[j];//为了不影响a[x]的
            for(int i=1;i<=sqrt(j)/*可换为i*i<=j,更高效*/;i++)//见二三部分
            {
                if(j%i==0)//是因数
                {
                    num+=bf[i];//见二部分
                    if(i!=(j/i))/*如果相等要舍去*/num+=bf[j/i];
                }
            }
            printf("%d\n",num);//输出
        }
    }
    return 0;
}
```


---

## 作者：BigJoker (赞：2)

# 1.前言

一道小水题，认真读了题后都不难。

# 2.思路

## 我会模拟！$70pts$

第一思路是模拟，直接暴力修改，最坏的情况是当 $x=1$ 时，需要修改所有的数，明显会炸。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	while(m--){
		int pd;
		scanf("%d",&pd);
		if(pd==1){
			int x,y;
			scanf("%d %d",&x,&y);
			for(int i=1;i<=n/x;i++)
				a[i*x]+=y;
		}
		else{
			int ans;
			scanf("%d",&ans);
			printf("%d\n",a[ans]);
		}
	}
	return 0;
} 
```

## 我会观察！$40pts$

观察题面的数据范围，发现操作2的数量不超过 $10^4$，想到可以用一个标记在操作1存储一下累加的值，在操作2时直接从 $1$ 到 $n$ 枚举它的因数，加上标记即可，但是复杂度 $10^{10}$，艹，TLE了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,m,tag[N],a[N];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	while(m--){
		int opt,x,y;
		scanf("%d %d",&opt,&x);
		if(opt==1){
			scanf("%d",&y);
			tag[x]+=y;
		}
		else{
			int res=a[x];
			for(int i=1;i<=x;i++)
				if(x%i==0) res+=tag[i];
			printf("%d\n",res);
		}
	}
	return 0;
}
```

## 我会优化！$100pts$

直接根据因数的性质将操作2枚举的范围搞到 $\sqrt{10^6}$，复杂度 $10^7$，AC了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,m,tag[N],a[N];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	while(m--){
		int opt,x,y;
		scanf("%d %d",&opt,&x);
		if(opt==1){
			scanf("%d",&y);
			tag[x]+=y;
		}
		else{
			int res=a[x];
			for(int i=1;i<=sqrt(x);i++)
				if(x%i==0){
					res+=tag[i];
					if(x/i!=i) res+=tag[x/i];
				}
			printf("%d\n",res);
		}
	}
	return 0;
}
```

---

## 作者：moosssi (赞：2)

第一眼看上去貌似要用线段树，但其实是道简单模拟题。

因为询问操作很少，所以对于每次询问，我们可以直接枚举它的因数，加上因数的贡献即可。显然，对于修改操作，单点修改就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,m,w[N],add[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);
	}
	while(m--){
		int x,y,op;
		scanf("%d",&op);
		if(op==1){
			scanf("%d%d",&x,&y);
			add[x]+=y;//单点修改 
		}
		else {
			scanf("%d",&x);
			int ans=w[x];
			for(int i=1;i<=sqrt(x);i++){//枚举因数 
				if(x%i==0){
					ans+=add[i];
					if(i*i!=x)ans+=add[x/i];//注意i*i=x时，不能加两遍 
				}
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}
```


---

## 作者：巨型方块 (赞：2)

菜了点，忘记一个数的所有因数是可以在sqrt的时间里求出来的（数论爆蛋）；

那我们看看题目，对于询问我们去暴力O(n)枚举一个数所有的因数稳定超时；

那我们乱搞一波；

对于1 (x,y)操作

如果x>5000暴力更新

不然的话就存下来

对于2 (x)操作

我们只要暴力把<5000的因数枚举出来加上就可以

1操作的时间复杂度1e5\*200=2e7

2操作的时间复杂度1e4\*5000=5e7

加起来1e8不到；

洛谷的机子是值得信赖的


```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
inline int RR(){int v=0,k=1;char c=0;while('0'>c||c>'9'){if(c=='-')k=-1;c=getchar();}while('0'<=c&&c<='9')v=(v<<3)+(v<<1)+c-48,c=getchar();return v*k;}
inline void W(int x){if(x<0)putchar('-'),x=-x;if(x>9)W(x/10);putchar(x%10+48);}
inline void WW(int x){W(x);puts("");}
inline void read(int &x,int &y){x=RR();y=RR();}
const int N=1e6+5,M=5e3+5;
Ll a[N],b[M];
int n,m,x,y,z;
int main()
{
    read(n,m);
    for(int i=1;i<=n;i++)a[i]=RR();
    while(m--){
        z=RR();
        if(z==1){
            read(x,y);
            if(x<=5000)b[x]+=y;else
            for(int k=1;k*x<=n;k++)a[k*x]+=y;
        }else{
            x=RR();Ll ans=a[x];
            for(int i=min(x,5000);i;i--)
                if(x%i==0)ans+=b[i];
            printf("%lld\n",ans);
        }
    }
}
```

---

## 作者：kfhkx (赞：1)

看到题解里面没有pascal，就来一波吧~

刚开始随机跳题跳到这题，心想一定是线段树或者树状数组，但后来习惯性的点了一下标签，怎么是~~摸你大法~~

后来细看了一下操作一，感觉线段树之类的打不了，然后就开始想暴力模拟

看了一下数据范围，心想正常暴力模拟肯定不行，但还是不死心，交了一个暴力上去，结果。。。
![](https://i.loli.net/2019/03/13/5c88dd1309346.png)

直接爆0，~~就连暴力分都不给点吗？qwq~~

后来仔细想了一下，发现可以用分解质因数的方法来优化一下，用一个b数组来记录一下要加的值，然后再到后面暴力拆根加进ans里面就行了，其他大佬的题解里面已经讲的很不错了，我就不多说了，我主要是来贴一下pascal代码，来帮助一下p系选手的


------------

### P1483.pas
```pascal
var
        n,m,i,kind,x,y:longint;
        ans,h:int64;//一定要开int64，不然会re几个点
        a,b:array[0..1000000] of int64;//同上
begin
        readln(n,m);
        for i:=1 to n do read(a[i]);
        while m>0 do begin
                dec(m);
                read(kind);
                if kind=1 then begin
                        read(x,y);
                        b[x]:=b[x]+y;//先用b数组存一下x要加的y，方便后面将x的倍数加入ans里面
                end else begin
                        read(x);
                        ans:=a[x];//ans要赋初始值
                        h:=1;
                        while h*h<=x do begin
                                if x mod h=0 then begin
                                        if h*h<>x then ans:=ans+b[h]+b[x div h] else ans:=ans+b[h];
                                end;
                                inc(h);
                        end;
                        writeln(ans);
                end;
        end;
end.
```


---

## 作者：Link_Space (赞：1)

首先看到这道题就是一股浓浓的线段树的味道,但是当你卖力打出线段树然后自信满满交上去的时候你就会发现事情并不是那么简单，所以我们再思考一下其它的做法。很容易就可以想到，如果一个数以及他的倍数永远不会被查询的话，那我们的操作1干了也是白干，所以我们可以直接先把操作1存起来，当询问的数需要用到时再直接加起来，而再看数据范围，保证数小于1e6,可以直接用数组下标装下，所以我们此时只需要等到询问到一个数时，用他本身就有的值再加上他应该加的就是他现在的值了，而如何加上他应该加的值呢？只需要把他所有的约数的操作1加上的数加到他的身上就可以了，而我们还可以得到如果x是n的约数，那么n/x也一定是n的约数，所以我们在枚举约数时只需要枚举到$\sqrt{n}$即可，注意特判一下$x=\sqrt{n}$的情况，只需要加一个即可。以下是代码。

```cpp
#include<iostream>
using namespace std;
int a[10000000];
int sum[1000000];
int p;
int r1;
int r2;
int r;
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	int cnt=0;
	for(int i=1;i<=m;i++)
	{
		cin>>p;
		if(p==1)
		{
			cin>>r1>>r2;
			sum[r1]+=r2;//操作1累加
		}
		else if(p==2)
		{
			cin>>r;
			int ans=a[r];//初始值为原始的值
			for(int i=1;i*i<=r;i++)
			{
				if(r%i==0)
				{
					ans+=sum[i];//加上约数的累计的加数
					if(i*i!=r)//特判
						ans+=sum[r/i];//加上该约数对应的另外一个约数的累计的加数
				}
			}
			cout<<ans<<endl;
		}
	}
	return 0;
}
```


---

## 作者：Apro1066 (赞：1)

贡献一个60分的树状数组的写法，主要是在枚举$x×k$时浪费了很多时间。

```cpp
#include <stdio.h>
#include <iostream>
#define N 1000001
using namespace std;
int n,m,a[N],bit[N],s;
inline int lowbit(int x)
{
	return x&-x;
}
inline void update(int x,int k)//单点更改 
{
	while(x<=n)
	{
		bit[x]+=k;
		x+=lowbit(x);
	}
}
inline int query(int k)
{
	int i(0);
	while(k>0)
	{
		i+=bit[k];
		k-=lowbit(k);
	}
	return i;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i,j,k;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		update(i,a[i]);
	}
	for(i=1;i<=m;i++)
	{
		int C,x,y;
		cin>>C>>x;
		if(C==1)
		{
			cin>>y;
			for(k=1;k*x<=n;k++)//枚举k 
			{
				update(x*k,y);
			}
		}
		if(C==2)
		{
			cout<<query(x)-query(x-1)<<endl;//区间查 
		}
	}
	return 0;;
}
```


---

## 作者：lovelive__ (赞：0)

当我第一眼看到p1483这题时，tmd这是什么鬼线段树题啊，后来经过我仔细研究，我惊奇的发现这题其实是~~无敌加强版线段树~~模拟......

如果我们单纯模拟的话会发现关于实现炒作1时间复杂度是o（n/x），然而关于炒作2时间复杂度是o（1）；

让我们来看看原题的数据：
对于100%的数据，n<=1000000，m<=100000，|a[i]|<=1000000，|y|<=1000000，x<=n，j<=n， **操作2不超过10000条。** 	

王德发，炒作2的数量不超过10000条？？？？喂喂喂炒作2的复杂度是o（1）的说；然而炒作1的复杂度却是o（n/x）的，数据却这么不友善？？？？？

那我们是不是可以将一下炒作1的部分炒作转移到炒作2来，以此降低炒作1的复杂度。

可以用分解质因数的想法来降低炒作1的复杂度：用d数组来存储k y d[k]+=y; 当询问一个数（2炒作）2 x
时，用o（j^0.5）来枚举x的因数并将d数组的这些数加起来

这时你才不多完成了这道题了，不过还有一点要注意下：当x为完全平方数时须特判，否则可能会加两d[x^0.5]。

最后这道题的时间复杂度是：n+m+10000*n^0.5（来自litc大神）


------------
最后放上ac代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 1000000
using namespace std;
long long a[maxn],d[maxn]={0};

inline int read()
{
	char ch=getchar();
	int x=0;
	bool b=false;
	while (!isdigit(ch))
		{
			if (ch=='-')
				{
					b=true;
					ch=getchar();
					break;
				}
			ch=getchar();
		}
	while(isdigit(ch))
		{
			x=(x<<3)+(x<<1)+(ch^48);
			ch=getchar();
		}
	if (b) return -x;
	else return x;
}

int main()
{
	long long n,m;
	n=read();
	m=read();
	for (int i=1;i<=n;i++)
		a[i]=read();
	long long  x,y,tmp,ans;
	for (int i=1;i<=m;i++)
	{
		tmp=read();
		if (tmp==1)
		{
			x=read();
			y=read();
			d[x]+=y;
		}
		if (tmp==2)
		{
			x=read();
			ans=a[x];
			for (int j=1;j*j<=x;j++)
			{
				if (x%j==0) 
					if (j*j!=x) ans+=d[j]+d[x/j];
					else	ans+=d[j];
			}
			printf("%lld\n",ans);//特判
		}
	}
	return 0;
}
```

---


# 词编码

## 题目描述

一个发送机可以通过一条隧道发送一些以二进制代码组成的单词。在其尽头的接收机可以使用特殊技术恢复到最初的单词。每个单词最初都由0和1组成。所有的单词最初长度都为n（4<=n<=1000）。当穿过隧道之后单词可能发生以下几种情况之一：

1. 任意（一个）0被1取代
2. 任意（一个）符号被删除
3. 一个符号（0或1）被插入到任何位置
4. 不改变

我们知道最初的单词都具有以下性质：有1的位置号的总和是n+1的倍数，或者是0.


## 样例 #1

### 输入

```
4
0000
011
1011
11011```

### 输出

```
0000
0110
1001
1111```

# 题解

## 作者：Trinity (赞：6)

# P1942 词编码_NOI导刊
## 题目描述
长度为 $n$ 的 $01$ 串满足是 $1$ 位置号总和整除$(n+1)$，而且可以进行以下四种操作：   
$1$ . 将一个 $0$ 变成 $1$   
$2$ . 删去一个 $0$ 或 $1$  
$3$ . 插入一个 $0$ 或 $1$  
$4$ . 不改变  
现给你多个**变换后**的 $01$ 串，需要你求出变换前的 $01$ 串  
有以下规定：  
多解情况，以 $4$ 操作优先 $1$,$2$,$3$ 操作次之。  
同一操作，以从左到右顺序优先。  
操作 $2$ ,以删 $0$ 优先。  
无解，输出$-1$  
## 分析
本题暴力分较高，无论用 $sring+STL$ 还是 $char$ 数组+模拟来维护，都躲不过  操作$2$ , $3$的一次循环，还有模拟修改位置的一次循环，总复杂度为$O($数据组数$\times n^2)$,$1000$的数据范围可以过 $80$ 分。  
所以我们有两种思路，一种是通过数学观察，避免真正地进行操作，另一种是降低插入和删除的操作复杂度（经过实测，套上平衡树板子，因为常数过大而数据范围太小只过了40分，千万不要尝试）。
## 解答
$~~~~~~~$我们通过题目条件原串长度固定为 $n$，而每种修改操作只会修改一个字符，所以新串的长度仅会是 $n-1$ , $n$或 $ n+1$，悄悄告诉你们加上这句话可以把暴力从 $70$ 升到 $80$分。  
$~~~~~~~$针对操作 $4$，直接计算出题目要求的有 $1$ 位置号和（以下称要求值），而且要满足长度要求，判断一下即可。  
$~~~~~~~$针对操作 $2$ 和 $3$，我们发现一旦添加或删去一个字符，整个串的要求值会改变，而暴力的思想就是强行重算。我们仔细观察，其实这两个操作只是改变了选择操作位置之后所有 $1$ 的位置号，从而改变要求值。  
$~~~~~~~$解释完后，一些同学已经明白该怎么搞了，但是不知道代码具体怎么实现的可以继续看看。  
$~~~~~~~$我们考虑对每组数据维护一个前缀和 $pre$ （准确来说是后缀和，反正是相同的），记录从位置 $1$ 到位置 $i$ 有多少个 $1$ 出现，我们就知道修改位置后有多少个 $1$。  
$~~~~~~~$针对 $2$ 的逆过程，选择添加的位置以后，每有一个 $1$ ，就会使操作前的的要求值加上$1$，最后根据添的是 $1$ 或 $0$ 加上这一位的数。  
$~~~~~~~$针对 $3$ 的逆过程，删去的原理也是一样的。  
$~~~~~~~$针对 $1$ 的逆过程，换成 $0$ 改变的是这一位，在原来的要求值上加上选择的位置值。  
$~~~~~~~$看证明：  
$~~~~~~~sum \mod  (n+1)=0~~~~~~~~~~~~~~~~~~~~~$正向操作时满足  
$~~~~~~~(sum+x) \mod (n+1)=x\ne 0~~~~$操作后满足  
$~~~~~~~$而且$1\leq x\leq n$  
$~~~~~~~$显然第 $x$ 个字符就是修改的字符（当然这些是废话，跑一遍循环照样可以得这个答案，但是时间省一点是一点）  
$~~~~~~~$这已经说的不能再详细了，看暴力和$AC$代码吧  
$~~~~~~~$两份代码中的 $STL$ 十分实用，特别是当你写暴力的时候，简直爽。  
$~~~~~~~s.insert(pos,string\ t)~~~~~~$在 $s$ 的 $pos$ 位置**后**插入 $t$  
$~~~~~~~s.erase(pos,length)~~~~~~~~~~$从 $s$ 的 $pos$ 位置删去长度为 $length$的字符
```cpp
inline bool check(string str)
{
    int len=str.length(),sum=0;
    for(int i=0;i<=len-1;i++)
        if(str[i]=='1')sum+=i+1;
    if(sum%(n+1)==0||sum==0)return true;
    return false;
}
inline string solve(string str)//你懂得，就很暴力。
{
    int len=str.length();
    string test=str;
    if(len==n&&check(test))return str;
    if(len==n)
    {
        for(int i=0;i<=len-1;i++)
        {
            test[i]='0';
            if(check(test))return test;
            test=str;
        }
        return "-1";
    }
    if(len<n)
    {
        for(int i=0;i<=len;i++)
        {
            test.insert(i,"0");
            if(check(test))return test;
            test=str;
            test.insert(i,"1");
            if(check(test))return test;
            test=str;
        }
        return "-1";
    }
    if(len>n)
    {
        for(int i=0;i<=len-1;i++)
        {
            test.erase(i,1);
            if(check(test))return test;
            test=str;
        }
        return "-1";
    }
}
int main()
{
    string s;
    n=read();
    while(cin>>s)cout<<solve(s)<<endl;
    return 0;
}
```
然后上 $AC$ 代码
```cpp
int n,sum,cnt,pre[N],x;
string s;
inline string solve(string str)
{
    sum=cnt=x=0;
    memset(pre,0,sizeof(pre));
    int len=str.length();
    if(len<n-1&&len>n+1)return "-1";//长度错误。
    for(int i=0;i<=len-1;i++)
    {
        if(str[i]=='1')cnt++,sum+=i+1,pre[i+1]=pre[i]+1;
        else pre[i+1]=pre[i];//cnt->1的个数，sum->要求值，pre->前缀和，有多少个1.
    }
    x=sum%(n+1);
    if(len==n)
    {
        if(!x||!sum)return str;
        else if(str[x-1]=='1'){str[x-1]='0';return str;}//如以上所说。
        return "-1";
    }
    if(len<n)
    {
        for(int i=0;i<=len;i++)
            if((sum+(cnt-pre[i]))%(n+1)==0){str.insert(i,"0");return str;}//题目要求0优先，两个循环一定不要写在一起，否则···
        for(int i=0;i<=len;i++)
            if((sum+(cnt-pre[i])+i+1)%(n+1)==0){str.insert(i,"1");return str;}
        return "-1";
    }
    if(len>n)
    {
        for(int i=0;i<=len-1;i++)
        {
            if((sum-(cnt-pre[i+1]))%(n+1)==0&&str[i]=='0'){str.erase(i,1);return str;}//一定要带上str【i】的条件，否则···
            if((sum-(cnt-pre[i+1])-i-1)%(n+1)==0&&str[i]=='1'){str.erase(i,1);return str;}
        }
        return "-1";
    }
}
int main()
{
    n=read();
    while(cin>>s)cout<<solve(s)<<endl;
    return 0;
}//完美谢幕。
```
## 总结
说大实话，这其实不太能称得上提高组的题目，暴力分太多，优化很好想，但是对于题目的理解**十！分！重！要！**  
题面给的十分毒瘤，没有明显表明多组数据，还有不明所以的句子。  
最重要的一点，$string$ 用的是真的爽。

---

## 作者：StevenYan (赞：2)

初见是在暑假，浅尝辄止了一下，最后 WA30，**多组数据和不能下载测试点数据**着实劝退。

~~退一步越想越气~~，于是昨晚又尝试重构了一个小时不到，处理完一些细节和人工对拍之后成功 AC。这道题的一些特殊性所以写了一篇题解，希望能帮到困于所困的各位。
## 题目
[P1942](https://www.luogu.com.cn/problem/P1942)

本题是一道**模拟**暴力，逻辑不难，重点在于**题目理解和细节处理**。题目理解是这道题的一大困点（~~蒟蒻看半天没看明白还求问了好几位才读懂的~~）

转化解释：给定变**后**的串，求变**前**的串，所以我们只要进行四种方式的**逆过程**就好。
### 操作 1 和 4（保持不变或者变 1 为 0）
这一步比较简单，实现在函数`string ans(string s)`中。
```cpp
int sum = 0;//表示原串所有1的编号和
int sum_1 = 0;//表示原串含1的总数
int sum_t1 = 0;//表示对当前位置进行增或删会影响到的1的个数
for (int i = 0; i < s.length(); i++) {
		if (s[i] == '1')
			sum += i + 1, sum_1++;
	}//分别记录
//此处也可以采取建立一个pre[]数组记录上面各处的sun_t1
sum_t1 = sum_1;
if (s.length() == n) {
		if (sum % (n + 1) == 0)
			return s;//可以不变就不变
		for (int i = 0; i < n; i++)
			if (s[i] == '1' && (sum - i - 1) % (n + 1) == 0) {
				s[i] = '0';
				return s;
			}//变1为0
	}
``````
以上轻松解决操作 $1$ 和 $4$。
### 处理操作 2 和 3（插入或删减一个字符）
介绍两个函数：
```cpp
string s;
s.insert(i,str);//在字符串 s 的 i 位置插入字符串 str
s.erase(i,len)//在字符串 s 中删除从 i 开始的 len 位（包括 i）
``````
修改复杂度都是 $O(1)$，非常好用，可以针对操作 $2$，$3$。
```cpp
for (int i = 0; i < n; i++) {//可以插入在编号为n的位置
				if (i > 0)//防止爆
					if (s[i - 1] == '1')//此处注意插入一个字符，则原本该处字符会被挤到后面
						sum_t1--;
				if ((sum + sum_t1) % (n + 1) == 0) {
					s.insert(i, "0");//插入一个0
					return s;
				}
			}
sum_t1 = sum_1;//记得重置
for (int i = 0; i < n; i++) {
			if (i > 0)
					if (s[i - 1] == '1')
						sum_t1--;
				if ((sum + sum_t1 + i + 1) % (n + 1) == 0) {
					s.insert(i, "1");//插入一个1
					return s;
				}
			}
`````` 
操作 $3$（删去一个 $0$ 或 $1$）：

与插入有不同在于：
**删去的 $1$ 不被影响**，所以要`s[i]=='1'`再`sum_t1--`。没有优先级之分，可以在同一个循环里判断。
```cpp
for (int i = 0; i < n + 1; i++) {
				if (s[i] == '1')//不同之处
					sum_t1--;
				if ((sum - sum_t1) % (n + 1) == 0 && s[i] == '0') {
					s.erase(i, 1);//删去一位就好
					return s;
				}
				if ((sum - sum_t1 - i - 1) % (n + 1) == 0 && s[i] == '1') {
					s.erase(i, 1);
					return s;
				}
			}
``````
操作 $3$ 完毕。

见完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;

string ans(string s) {
	int sum = 0;//表示原串所有1的编号和
	int sum_1 = 0;//表示原串含1的总数
	int sum_t1 = 0;//表示对当前位置进行增或删会影响到的1的个数
	for (int i = 0; i < s.length(); i++) {
		if (s[i] == '1')
			sum += i + 1, sum_1++;
	}//分别记录
//此处也可以采取建立一个pre[]数组记录上面各处的sun_t1
	if (s.length() > n + 1 || s.length() < n - 1)
		return "-1";
	sum_t1 = sum_1;
	if (s.length() == n) {
		if (sum % (n + 1) == 0)
			return s;//可以不变就不变
		for (int i = 0; i < n; i++)
			if (s[i] == '1' && (sum - i - 1) % (n + 1) == 0) {
				s[i] = '0';
				return s;
			}//变1为0
	} else {
		if (s.length() == n - 1) {
			for (int i = 0; i < n; i++) {//可以插入在编号为n的位置
				if (i > 0)
					if (s[i - 1] == '1')//此处注意
						sum_t1--;
				if ((sum + sum_t1) % (n + 1) == 0) {
					s.insert(i, "0");//插入一个0
					return s;
				}
			}
			sum_t1 = sum_1;//记得重置
			for (int i = 0; i < n; i++) {
				if (i > 0)
					if (s[i - 1] == '1')
						sum_t1--;
				if ((sum + sum_t1 + i + 1) % (n + 1) == 0) {
					s.insert(i, "1");//插入一个1
					return s;
				}
			}
		} else if (s.length() == n + 1) {
			sum_t1 = sum_1;
			for (int i = 0; i < n + 1; i++) {
				if (s[i] == '1')//不同之处
					sum_t1--;
				if ((sum - sum_t1) % (n + 1) == 0 && s[i] == '0') {
					s.erase(i, 1);//删去一位就好
					return s;
				}
				if ((sum - sum_t1 - i - 1) % (n + 1) == 0 && s[i] == '1') {
					s.erase(i, 1);
					return s;
				}
			}
		}
	}
	return "-1";//最后别忘记了Final Verdict()
}
int main() {
	cin >> n;
	while (cin >> s) {
		cout << ans(s) << endl;
	}
	return 0;//完毕
}
``````
时间复杂度为 $O(Tn)$，对于本题目~~比较水的~~数据可以松弛通过。

希望能有帮到您，如有错误或不当之处请一定要指出，感谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢谢观看（）。

---

## 作者：wanghaoran00 (赞：2)

### 思路
因为只能进行一次操作且所有单词最初长度均为 $n$，所以输入中如果比 $n$ 大一定执行删除操作，比 $n$ 小一定进行填入操作，除此之外执行 $0$ 变 $1$，暴力判断所述条件中的每一种可能性是否即可。

ACcode
```
#include <bits/stdc++.h>
using namespace std;
int sum,n,a[2005],x,cnt,t1[2005],t2[2005],b1;
string s;
signed main(){
    cin>>n;
    while(cin>>s){
        x=s.size();
        cnt=0,b1=-1,sum=0;
        for(int j=0;j<x;j++){
            if(s[j]=='1'){
                cnt+=j+1;
                if(j==0){
                   t2[j]=1;
                }
                else{
                    t2[j]=t2[j-1]+1;
                }   
            }
            else{
                if(j==0){
                    t2[j]=0;
                }
                else{
                    t2[j]=t2[j-1];
                }
            }
        }
        for(int j=0;j<x;j++){
            //cout<<t1[j]<<" ";
            //cout<<t2[j]<<" ";
        }
        if(cnt%(n+1)==0&&x==n){//无需操作
            cout<<s<<endl;    
        }
        else if(x==n){//操作1
            for(int j=0;j<x;j++){
                if((cnt-j-1)%(n+1)==0&&s[j]=='1'){
                    b1=j;
                    break;
                }
            }
            if(b1!=-1){
                for(int i=0;i<x;i++){
                    if(i!=b1){
                        cout<<s[i];
                    }
                    else{
                        cout<<"0";
                    }
                }
            }
            else{
                cout<<-1;
            }
                cout<<endl;
        }
        else if(x==n+1){
            //cout<<"!!";
            if(cnt%(n+1)==0){
                for(int j=0;j<x-1;j++){
                    cout<<s[j];
                }
                cout<<endl;
            }
            else{
                //cout<<cnt<<" "<<t2[x-1]<<endl;
                for(int i=0;i<x;i++){
                    if(s[i]=='1'){
                        sum++;
                        //cout<<cnt<<" ";
                        if((cnt-(t2[x-1]-sum)-i-1)%(n+1)==0){
                            b1=i;
                            break;
                        }
                    }
                    else{
                        if((cnt-(t2[x-1]-sum))%(n+1)==0){
                            b1=i;
                            break;
                        }
                    }
                }
                //cout<<b1<<endl;
                if(b1!=-1){
                    for(int i=0;i<x;i++){
                        if(i!=b1){
                            cout<<s[i];
                        }
                    }
                }
                else{
                    cout<<-1;
                }
                cout<<endl;
            }
        }
        else if(x==n-1){
            //cout<<s<<endl;
            if(cnt%(n+1)==0){
                //cout<<"??";
                cout<<s<<"0"<<endl;
            }
            else{
                for(int i=0;i<x;i++){
                    if((cnt+(t2[x-1]-sum))%(n+1)==0){
                        b1=i;
                        break;
                    }
                    if(s[i]=='1'){
                        sum++;
                    }
                }
                if(b1!=-1){//补0
                    for(int i=0;i<x;i++){
                        //cout<<s[i];
                        if(b1!=i){
                            cout<<s[i];
                        }
                        else{
                            cout<<"0"<<s[i];
                        }
                    }
                    cout<<endl;
                }
                else{//补1
                    sum=0;
                    for(int i=0;i<x;i++){
                        //cout<<(cnt+(t2[x-1]-sum))+i+1<<endl;
                        if((cnt+(t2[x-1]-sum)+i+1)%(n+1)==0){
                            b1=i;
                            break;
                        }
                        if(s[i]=='1'){
                            sum++;
                        }
                    }
                    if((cnt+n)%(n+1)==0){
                        cout<<s<<"1"<<endl;
                    }
                    else if(b1!=-1){
                        //cout<<b1<<endl;
                        for(int i=0;i<x;i++){
                            if(i!=b1){
                                cout<<s[i];
                            }
                            else{
                                cout<<1<<s[i];
                            }
                        }
                        cout<<endl;
                    }
                    else{
                        cout<<-1<<endl;
                    }
                }
                
            }
        }
    }
    return 0;
}
```

---

## 作者：Lugar (赞：2)

这个题目也是真的很麻烦了

but使用~~奇怪的~~stl可以带来不少的便利

前面对hm数组的memset没加，一直出现单个数据可以过多组就过不了的状况，还害的我把goto放进了函数里直接return，十分痛苦。

**然后呢s.insert(k,char)是在k之前加入char字符**

如string s = "abcd";

s.insert(0,k);

s 就会是 "kabcd"；

erase(i,k)就是擦去**i-1**后面k个

erase(i,1)就是擦去i了

别的详见代码啦，有注释的哦

```cpp
#include<bits/stdc++.h>
using namespace std;
#define SC scanf

int n,tot,len,hm[5005];
string s;

void jj()
{
	memset(hm,0,sizeof(hm));
	tot = 0;len = s.length();
	for(int i = 0; i < len; i++) if(s[i] == '1') tot += (i+1);
	if(len == n)
	{
		if(tot % (n+1) == 0) cout<<s<<endl;//不变化的情况
		else//把一个1变回0
		{
			for(int i = 0; i < len; i++)
				if(s[i] == '1' && (tot-i-1) % (n+1) == 0)
				{
					s[i] = '0';
					cout<<s<<endl;
					return;
				}
			printf("-1\n");
		}
	}
	else
	{
		for(int i = len-1; i >= 0; i--) hm[i] = hm[i+1] + (s[i] == '1');//hm[i]表示i(含)以后这串有几个1
		if(n > len)
		{
			for(int i = 0; i <= len; i++)
				if((tot+hm[i])%(n+1) == 0)
				{
					s.insert(i,1,'0');
					cout<<s<<endl;return;
				}
			for(int i = 0; i <= len; i++)
				if((tot+hm[i]+i+1)%(n+1) == 0)
				{
					s.insert(i,1,'1');
					cout<<s<<endl;return;
				}
		}
		else
		{
			for(int i = 0; i < len; i++)
			{
				if(s[i] == '1' && (tot-hm[i]-i)%(n+1) == 0)
				{
					s.erase(i,1);
					cout<<s<<endl;return;
				}
				if(s[i] == '0' && (tot - hm[i]) % (n+1) == 0)
				{
					s.erase(i,1);
					cout<<s<<endl;return;
				}
			}
		}
		printf("-1\n");
	}
}

int main()
{
	SC("%d",&n);
	while(cin>>s)
		jj();
}
```

~~忽略我奇怪的函数名~~

---

## 作者：风中の菜鸡 (赞：1)

题目大意：给你若干个只含 $01$ 的字符串，让你对每个字符串进行删掉一个 $0$ 或删掉一个 $1$ 或添加一个 $0$ 或添加一个 $1$ 或将一个 $1$ 变成 $0$ 或不变的操作，使这个字符串变成长度为 $n$ 且有 $1$ 的位置号的总和是 $0$ 或者是 $n+1$ 的倍数。无解输出 $-1$。 

思路：模拟。若该字符串长度比 $n$ 小，就进行加字符的操作；若该字符串长度比 $n$ 大，就进行减字符的操作；若该字符串长度等于 $n$，就不操作或是进行改字符的操作。但要注意操作顺序，这些部分再此不再赘述，代码里有体现。

代码（非常易读）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int ans=0,anss=0,aa,bj;
int k=0,ww=-1,www=-1;
int main(){
	cin>>n;
	string s;
	while(cin>>s){
		ans=0,anss=0,bj=0;
		k=0,ww=-1,www=-1,aa=0;
		if(s.size()==n){//进行操作1或4 
			for(int i=0;i<s.size();i++){
				if(s[i]=='1'){
					ans=ans+i+1;
				}
			}
			if(ans%(n+1)==0&&bj==0){//操作4 
				for(int i=0;i<s.size();i++){
					cout<<s[i];
				}	
				bj=1;
			}
			else{//操作1 
				int wz=-1;
				for(int i=s.size()-1;i>=0;i--){
					if(s[i]=='1'){
						int aa=ans-(i+1);
						if(aa%(n+1)==0){
							wz=i;
						}
					}
				}
				if(wz!=-1){
					
					for(int i=0;i<wz;i++){
						cout<<s[i];
					}
					cout<<'0';
					for(int i=wz+1;i<=s.size();i++)
						cout<<s[i];
					bj=1;
				}
			}
			if(bj==1)
				cout<<endl;
		}
		else if(s.size()<n){//进行操作2了 
			for(int i=0;i<s.size();i++){
				if(s[i]=='1'){
					ans++;
					anss=anss+i+1;
				}
			}		
		//	cout<<anss;
			for(int i=0;i<=s.size();i++){//1被删了 
				int aa=ans-k+anss;	
				if(aa%(n+1)==0){
					ww=i;
					break;
				}
				if(s[i]=='1')
					k++;
			}
			k=0;
			for(int i=0;i<=s.size();i++){//0被删了 
				int aa=ans-k+anss;	
				if((aa+i+1)%(n+1)==0){
					www=i;
					break;
				} 
				if(s[i]=='1')
					k++;
				//cout<<aa<<endl;
			}
			if(ww!=-1){
				for(int i=0;i<ww;i++){
					cout<<s[i];
				}
				cout<<'0';
				for(int i=ww;i<s.size();i++){
					cout<<s[i];
				}
				bj=1;
			}
			else if(www!=-1){
				for(int i=0;i<www;i++){
					cout<<s[i];
				}
				cout<<'1';
				for(int i=www;i<s.size();i++){
					cout<<s[i];
				}
				bj=1;
			} 
			if(bj==1)
				cout<<endl;
		}
		else if(s.size()>n){//进行操作3了 
			for(int i=0;i<s.size();i++){
				if(s[i]=='1'){
					ans++;
					anss=anss+i+1;
				}
			}
			//cout<<anss;
			for(int i=0;i<=s.size();i++){//枚举要删的数 
				if(s[i]=='1'){ 
					aa=anss-i-1;
					k++;
					aa-=(ans-k);
					if(aa%(n+1)==0){
					//	cout<<anss<<' '<<ans<<' '<<k<<endl;
						ww=i;
						break;
					}
				}
				else{
					aa=anss-(ans-k);
					if(aa%(n+1)==0){
						ww=i;
					//	cout<<aa<<endl;
						break;
					}
				}
				
			}
			//cout<<ww;
			if(ww!=-1){
				for(int i=0;i<ww;i++){
					cout<<s[i];
				}
				for(int i=ww+1;i<s.size();i++){
					cout<<s[i];
				} 
				cout<<endl;
				bj=1;
			}
		}
		if(bj==0){//无解 
			cout<<"-1"<<endl;
		}
	} 
	return 0;
} 
/*
5
101101
*/
```


---

## 作者：Aw顿顿 (赞：1)

就是这题，在我计划里待了一年半，还能交题解，令我大为震撼。

首先考虑无解情况：长度小于 $n-1$ 或者长度大于 $n+1$ 显然都是不合法的情况，特判掉。

然后一个一个操作按优先级考虑。

- 不改变：首先长度得正确，然后考虑 $1$ 的位置和，判断是否符合即可。
- 任一 $0$ 被 $1$ 取代：位值改变，根据该变量倒推改变的位置。
- 删除或插入：这一步对于字符串的修改其实只影响**修改位置左侧**的求值，这是显然的，那么求后缀和，判断哪一位被修改。

~~很容易~~ 死磕 char 数组死活过不去样例，发现题解用 STL 写起来竟然这么快，那么很容易写出代码：

```cpp
void solve(){
	int res=0,cnt=0,l=s.size();
    memset(sum,0,sizeof sum);
    if(l<n-1||l>n+1){puts("-1");return;}
    for(int i=0;i<=l-1;i++){
        if(s[i]=='1'){
        	cnt++;res+=(i+1);
			sum[i+1]=sum[i]+1;
		}else sum[i+1]=sum[i];
    }if(l==n){
        if(!(res%(n+1))||!res){
        	cout<<s<<endl;
        	return; 
		}else if(s[(res%(n+1))-1]=='1'){
			s[(res%(n+1))-1]='0';
			cout<<s<<endl;
			return;
		}puts("-1");return;
    }if(l<n){
        for(int i=0;i<=l;i++)
            if((res+cnt-sum[i])%(n+1)==0){
				s.insert(i,"0");
				cout<<s<<endl;
				return;
			}
        for(int i=0;i<=l;i++)
            if((res+(cnt-sum[i])+i+1)%(n+1)==0){
				s.insert(i,"1");
				cout<<s<<endl;
				return;
		}puts("-1");return;
    }
    if(l>n){
        for(int i=0;i<=l-1;i++){
            if((res-(cnt-sum[i+1]))%(n+1)==0&&s[i]=='0'){
				s.erase(i,1);
				cout<<s<<endl;
				return;
			}if((res-(cnt-sum[i+1])-i-1)%(n+1)==0&&s[i]=='1'){
				s.erase(i,1);
				cout<<s<<endl;
				return;
			}
        }puts("-1");return;
    }
}
```






---

## 作者：fanke (赞：1)

[题目描述](https://www.luogu.com.cn/problem/P1942)

算法：模拟。


## 思路：

这是一道模拟题，对于一个只含 $01$ 的字符串进行以下的操作：

- 删除（$0$ 或 $1$）。

- 添加（$0$ 或 $1$）。

- 不变。

最后要使字符串的长度变为 $n$ ,在字符串含 $1$ 的位置的加起来的总和必须是 $n + 1$ 的倍数（$0$ 也可以)，如果最后无法找到答案则输出 $1$。

------------
首先，我们必须保证对于操作的字符串的长度 $< n$ (不然就有答案了对吧)；再如果说字符串的长度 $= n$，我们就要进行改字符的操作，当然也可能不做操作；最后一种情况，字符串长度 $> n$，便进行删减字符的操作。

## 具体实现

~~显然，本题是字符串题~~  我们在变量类型上可以稍作考虑，用 char 还是 string 呢？最后我选了 string ,因为我查了一些资料，找到了许多与本题有关的内置函数（[这里，可以看看](https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&rsv_idx=1&tn=02003390_3_hao_pg&wd=c%20%2B%2B%20string%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0&fenlei=256&oq=c%2520%252B%252B%2520string%25E5%2586%2585%25E7%25BD%25AE%25E5%2587%25BD%25E6%2595%25B0&rsv_pq=b1968dc00001af4e&rsv_t=9ff8RPCXzk%2BTIczN7QzqPUfPOp1sZaA4DpZp6ObGHScs7XsyflaZc3OmP1DMPl8vbHv3VSiE2f4&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_btype=t&rsv_sug3=36&rsv_sug1=6&rsv_sug7=000&rsv_sug2=1&prefixsug=c%2520%252B%252B%2520string&rsp=0&rsv_sug=1)）。

好了，下面是部分代码，主要是删除部分，剩下的靠自己了：


```cpp
	for(int i = 0 ; i <= ls ; i ++)
	{ 
				int x = ans - k + sum;	
				if(x % (n + 1) == 0)
				{
					y = i;
					break;
				}
				if(s[i] == '1')
					k ++;
			}
			k = 0;
			for(int i = 0 ; i <= ls ; i ++)
			{
				int x = ans - k + sum;	
				if((x + i + 1 ) % (n + 1) == 0)
				{
					y1 = i;
					break;
				} 
				if(s[i] == '1')
					k ++;
			}
```


就是这些了。

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1942)
## 思路
由于每个操作最多让字符串增加或减少一位，故若长度大于 $n+1$ 或小于 $n-1$ 一定无解。

记当前有 $1$ 的位置号的总和为 $s$。
### 若长度为 $n$
如果输入的字符串符合要求，直接输出即可。否则由于只能将一个 $1$ 修改为 $0$，对 $s$ 的贡献不超过 $n$，所以只有将第 $s\bmod (n+1)$ 位修改为 $0$ 才符合要求。若此位已经为 $0$，则无解。
### 若长度为 $n-1$
这种情况是操作 $2$ 的结果。考虑逆过程，即在第 $i$ 位添加一个字符，这样会使得之后的每个 $1$ 对 $s$ 的贡献都增加一。暴力查找符合要求的 $i$ 即可。
### 若长度为 $n+1$
与上一种情况类似，逆过程为在第 $i$ 位删除一个字符，这样会使得之后的每个 $1$ 对 $s$ 的贡献都减少一。同样暴力查找符合要求的 $i$ 即可。
### 注意事项
 - 操作 $2$ 要求 $0$ 优先，操作 $3$ 并无此要求。
 - 可以使用前缀和来统计 $1$ 的个数。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string str;
int n;
int s[1145],su;
bool fl;
int main() {
	cin>>n;
	while(cin>>str) {
		su=0;
		for(int i=0; i<str.size(); i++) {
			su+=(str[i]-'0')*(i+1);
			s[i+1]=s[i]+(str[i]-'0');//前缀和
		}
		if(str.size()>n+1||str.size()<n-1)cout<<-1;//无解
		else if(str.size()==n) {
			if(su%(n+1)==0) cout<<str;//操作 4
			else if(str[su%(n+1)-1]=='1') {//操作 1
				str[su%(n+1)-1]='0';
				cout<<str;
			} else cout<<-1;
		} else if(str.size()<n) {//操作 2
			fl=true;
			for(int i=0; i<=str.size(); i++) {
				if((su+s[str.size()]-s[i])%(n+1)==0) {
					for(int j=0; j<i; j++)cout<<str[j];
					cout<<"0";
					for(int j=i; j<str.size(); j++)cout<<str[j];
					fl=false;
					break;
				}
			}
			if(fl) {
				for(int i=0; i<=str.size(); i++) {
					if((su+s[str.size()]-s[i]+i+1)%(n+1)==0) {
						for(int j=0; j<i; j++)cout<<str[j];
						cout<<"1";
						for(int j=i; j<str.size(); j++)cout<<str[j];
						fl=false;
						break;
					}
				}
			}
			if(fl) cout<<-1;
		} else {//操作 3
			fl=true;
			for(int i=0; i<str.size(); i++) {
				if((su-s[str.size()]+s[i+1])%(n+1)==0&&str[i]=='0') {
					for(int j=0; j<i; j++)cout<<str[j];
					for(int j=i+1; j<str.size(); j++)cout<<str[j];
					fl=false;
					break;
				}
				if((su-s[str.size()]+s[i+1]-i-1)%(n+1)==0&&str[i]=='1') {
					for(int j=0; j<i; j++)cout<<str[j];
					for(int j=i+1; j<str.size(); j++)cout<<str[j];
					fl=false;
					break;
				}
			}
			if(fl) cout<<-1;
		}
		cout<<endl;
	}
}
```

---

## 作者：_JF_ (赞：0)

[Link](https://www.luogu.com.cn/problem/P1942)


代码能力还是不太行。。。。。。

四个操作的逆操作非常显然，直接模拟即可。

插入删除对于原序列的改变，用前缀和分开讨论，计算两段贡献即可。

提示一下注意的细节。

- 对于无解的判断，只要相差超过 $1$ 一定无解。
- 注意字符串的数量并不是 $n$，是无限输入状物。
- 在开头插入 $0$ 是有意义的！！！！他可以让你的长度凑到 $n$。。

观看代码应该可以更好理解。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e5+10;
int sum[N],g[N],n;
string s;
int main(){
//	freopen("1.in","r",stdin);
//	freopen("ans1.out","w",stdout); 
	int t; cin>>t; int T=t;
	while(cin>>s){
		n=s.size(); 
		for(int i=0;i<n;i++)	sum[i]=g[i]=0;
		for(int i=0;i<n;i++){
			if(s[i]=='0')	sum[i]=sum[i-1],g[i]=g[i-1];
			else	sum[i]=sum[i-1]+(n-i),g[i]=g[i-1]+1;
		}
		if(abs(n-T)>1)	{cout<<"-1"<<endl; continue;} 
		if(sum[n-1]%(T+1)==0&&n==T)	{cout<<s<<endl; continue;}
		bool f=false;
		if(n==T){
			for(int i=0;i<n;i++)
				if(s[i]=='1'){
					int pre=sum[n-1]-(n-i);
					if(pre%(T+1)==0){
						s[i]='0',cout<<s<<endl; f=true; break;
					}
				}
		}
		if(n==T-1){ // Add 
			if(f==false&&((sum[n-1])%(T+1))==0)	cout<<"0"<<s<<endl,f=true;
			for(int i=0;i<n;i++){ // Add lst  
				int pre=sum[n-1]+g[i]; string now="0";
				if(pre%(T+1)==0&&f==false){
					s.insert(i+1,now); cout<<s<<endl;
					f=true; break;
				}
			}
			for(int i=0;i<n;i++){
				int pre=sum[n-1]+g[i]; string now="1";
				if((pre+(n-i))%(T+1)==0&&f==false){
					s.insert(i+1,now); cout<<s<<endl;
					f=true; break;
				}
			}
			if(f==false&&((sum[n-1]+T)%(T+1))==0)	cout<<"1"<<s<<endl,f=true;
		}	
		if(n==T+1){ //Del 
			for(int i=0;i<n;i++){
				int pre=sum[n-1]-((s[i]=='1')?(n-i):0);
				if(i>0)	pre-=g[i-1];
				if(pre%(T+1)==0){
					s.erase(i,1),cout<<s<<endl; f=true;break;
				}
			}
		}
		if(!f)	cout<<"-1"<<endl;
	}
	return 0;
}
// 9:20 
```

---

## 作者：lym12 (赞：0)

这题都这么久了还能交题解啊？

简单模拟题，无解情况可以先判断长度不合法的。

然后分类讨论：

- 不改变：判断即可。具体的，判断 $\sum [a_i = 1] \times i$ 是否为 $n + 1$ 的倍数即可。
- 更改元素：倒推位置。可以计算 $\sum [a_i = 1] \times i$，计算其对 $n + 1$ 取模的结果，然后就可以简单倒推了。
- 删除插入：求后缀和。由于修改仅会影响这个元素左侧的取值，所以可以根据后缀和判断哪一位被修改。

其实有更简单的做法，但我没搞出来……

其他的看代码吧，自认为码风良好。

```cpp
#include <bits/stdc++.h>
using namespace std;

int hre[1005];
string s;
int n;

void solve(){
    int sv = 0, cnt = 0, len = s.size();
    memset(hre, 0, sizeof(hre));
    
    if (len < n - 1 || len > n + 1){
        puts("-1");
        return ;
    }

    for (int i = 0; i < len; i ++){
        if (s[i] == '1'){
            cnt ++;
            sv += (i + 1);
            hre[i + 1] = hre[i] + 1;
        }else hre[i + 1] = hre[i];
    }
    
    if (len == n){
        if (!(sv % (n + 1)) || !sv){
            cout << s << '\n';
            return ;
        }else if (s[(sv % (n + 1)) - 1] == '1'){
            s[(sv % (n + 1)) - 1] --;
            cout << s << '\n';
            return ;
        }else{
            puts("-1");
            return ;
        }
    }
    
    if (len < n){
        for (int i = 0; i <= len; i ++){
            if ((sv + cnt - hre[i]) % (n + 1) == 0){
                s.insert(i, "0");
                cout << s << '\n';
                return ;
            }
        }

        for (int i = 0; i <= len; i ++){
            if ((sv + (cnt - hre[i]) + i + 1) % (n + 1) == 0){
                s.insert(i, "1");
                cout << s << '\n';
                return ;
            }
        }
        
        puts("-1");
        return ;
    }
    
    if (len > n){
        for (int i = 0; i < len; i ++){
            if ((sv - (cnt - hre[i + 1])) % (n + 1) == 0 && s[i] == '0'){
                s.erase(i, 1);
                cout << s << '\n';
                return ;
            }else if ((sv - (cnt - hre[i + 1]) - i - 1) % (n + 1) == 0 && s[i] == '1'){
                s.erase(i, 1);
                cout << s << '\n';
                return ;
            }
        }
        
        puts("-1");
        return ;
    }
}

int main(){
    cin >> n;
    while (cin >> s) solve();
}
```

---


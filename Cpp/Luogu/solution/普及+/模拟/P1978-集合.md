# 集合

## 题目描述

集合是数学中的一个概念，用通俗的话来讲就是：一大堆数在一起就构成了集合。

集合有如下的特性：

- 无序性：任一个集合中，每个元素的地位都是相同的，元素之间是无序的。

- 互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。

- 确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现。

例如 $A = \{ 1, 2, 3 \}$ 就是一个集合。我们可以知道，$1$ 属于 $A$，即 $1 \in A$；$4$ 不属于 $A$，即 $4 \notin A$。一个集合的大小，就是其中元素的个数。


现在定义一个特殊的 $k$-集合，要求满足：

- 集合的所有特性
- 对任意一个该集合内的元素 $x$，不存在一个数 $y$，使得 $y = k x$ 并且 $y$ 属于该集合。即集合中的任意一个数，它乘以 $k$ 之后的数都不在这个集合内。

给你一个由 $n$ 个不同的数组成的集合，请你从这个集合中找出一个最大的 $k$-集合。


## 说明/提示

提示：在样例所给集合中，找出的最大的 $2$-集合为 $\{ 4, 5, 6 \}$

- 对于 $30 \%$ 的数据：$n, k \le 100$。
- 对于 $40 \%$ 的数据：$a_i \le 2^{31} - 1$。
- 对于 $70 \%$ 的数据：$n, k \le 5000$。
- 对于 $100 \%$ 的数据：$2 \le n, k \le {10}^5$，$1 \le a_i \le 2^{63} - 1$。

## 样例 #1

### 输入

```
6 2	
2 3 6 5 4 10
```

### 输出

```
3
```

# 题解

## 作者：finger25631677 (赞：41)

很棒的是有一种叫set的数据结构，还是stl里面的，真的是太好了

问大佬怎么用set又自己查了一点资料就可以用咯！

照着题目暴力一下，完成！

不过是不是老用stl不太好呀……

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
long long a[100005];
set<long long> A;
int n,k;
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
        if(a[i]%k||A.find(a[i]/k)==A.end()){//如果不能整除k或者集合中没有a[i]/k，满足条件就进入集合
            A.insert(a[i]);
        }
    }
    printf("%d\n",A.size());
    return 0;
}
```

---

## 作者：桜Sakura (赞：20)

楼上dalao的set方法很好，我借鉴了一下，然而对于一些小萌新~~dalao~~来说，并没有深入理解。所以，在此，我重新表述一下。

### set用法简介

begin(),返回set容器的第一个元素

end(),返回set容器的最后一个元素

clear(),删除set容器中的所有的元素

empty(),判断set容器是否为空

max_size(),返回set容器可能包含的元素最大个数

size(),返回当前set容器中的元素个数

find(),返回给定值值得定位器，如果没找到则返回end()

insert(),去重

------------
那么现在我们来分析题意：

查找的条件是：

1.这个数必须是k的倍数（因为所要找的是最大的 k-集合）

2.这个数的k倍在集合中找不到，那么换而言之就是这个数除以k，也就是这个数不是别的数的k倍

3.这个数不能重复（每个数只能出现一次）

### 强调：要排序，因为是按顺序查找数组元素。

核心：
```cpp

if(a[i]%k || ans.find(a[i]/k)==ans.end()){ans.insert(a[i]);}
```
按顺序满足123条件


------------

AC代码：

```cpp
//writer: Sakura
//name: 集合

#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <set>
using namespace std;

typedef long long ll;

int n,k;
set<ll> ans;
ll a[100005];

int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		if(a[i]%k || ans.find(a[i]/k)==ans.end()){ans.insert(a[i]);}
	}
	printf("%d\n",ans.size());
	return 0;
}
```

管理员大大给过，QWQ。。。：）

---

## 作者：此店不售此书 (赞：3)

# 然而我是用map的

首先，根据题意打暴力就行

然后有几个**细节要注意**：

1. 开 long long ！！！

2. 本来是sort 从大到小 或 从小到大都可以，

	然而 **从大到小** 的话，就要用 **s[i]*k**，这样会爆long long（开__int128也会爆qwq）
    
3. 所以用**从小到大**，那么为了判段就必须写 **s[i]/k**,

	但是它没有整除会进1，然后就40了qwq，
    
    所以要用 **s[i]%k || !mmp[s[i]/k]** (意思是不能整除肯定就可以了，可以整除再判断）
    
## 见代码
    
```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define res register int
const int MAXN=100000+10;
ll n,k,total,s[MAXN];
map<ll,bool> mmp;

int main(){
	cin>>n>>k;
	for(res i=1;i<=n;++i) cin>>s[i];
	sort(s+1,s+n+1);
	for(res i=1;i<=n;++i){
		if(!mmp[s[i]]&&(s[i]%k||!mmp[s[i]/k])) mmp[s[i]]=1,++total;
	}
	cout<<total;
	return 0;
}
```

---

## 作者：a15326987 (赞：3)

   **看了此题只有六篇题解并且通过率较低，我就知道又可以水题解了^ ^   ~~不知道是不是我以前水的~~**
   
   首先给大家介绍下什么叫集合；
   
   集合可以看成一组数组但是这组数组没有相同的数据，比如：A={1,1,2}这样出现了同一数据，需变成A={1，2}才叫一个集合。
   
   基本概念介绍完毕
   
   看题：
   
   •集合的所有特性

•对任意一个该集合内的元素 x ，不存在一个数 y ，使得 y = kx 并且 y 属于该集合。即

集合中的任意一个数，它乘以 k 之后的数都不在这个集合内

给你一个由 n 个不同的数组成的集合，请你从这个集合中找出一个最大的 k-集合。

**此题的意思是在以下的数集中找出一个最大的集合，且每个元素不成k倍**

那么我们只需暴力找，满足条件便ans++，但是为了避免出现重复的，我们使用STL中的set容器，即与集合概念相同的一个容器，也可以说他就是集合。他可以帮助你去重，避免出现A={1，1，2}的情况。

介绍完毕上代码

```cpp
#include<iostream>
#include<set>
#include<algorithm>
using namespace std;
set<long long>q;
long long a[1000005];
int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
        if(a[i]%k||q.find(a[i]/k)==q.end())
		{
            q.insert(a[i]);//把此数据放入set容器中
        }
    }
    cout<<q.size();//输出容器大小即集合元素多少
} 
```


---

## 作者：DPair (赞：2)

## 这题我的思路似乎没那么优秀啊，但是很好想啊。

### 思路是这样的：

对于本题，每一个数的$k$倍一定不能选（每个数只出现一次很良心）。

那么，可以贪心地考虑，对于每一个不能第二次被选进集合的数$x$，它的$k$倍，$k^2$倍直到它的$k^n$倍已经不存在时，这么多个数，即$k^0*x$，$k^1*x$一直到$k^n*x$中，有一半的数是可以选的，还可以向上取整。

那么，代码框架就出来了，我用的是$map$

先把每一个存在$map$中，在从小到大对于每一个没有没有判断过的数判断，看它的倍数中可以有几个被选中，累加$ans$计数，最后输出。

主要就是贪心思路。
### 代码
```cpp
#include <bits/stdc++.h>
#define LL unsigned long long
using namespace std;
map <LL, bool> b;
LL n, k, ans;
int main()
{
    ios :: sync_with_stdio(false);
    cin >> n >> k;
    const LL MAXN = 9223372036854775807 / k;
    for (register int i = 1;i <= n;i ++)
    {
        LL a;
        cin >> a;
        b[a] = true;
    }
    map <LL, bool> :: iterator it;
    for (it = b.begin();it != b.end();it ++)
    {
        if(it -> second == true)
        {
            LL cal = 0, num = it -> first;
            while(b[num])
            {
                cal ++;
                b[num] = false;
                if(num >= MAXN) break;//防止溢出
                num *= k;
            }
            ans += (cal >> 1) + (cal & 1);
        }
    }
    cout << ans;
    return 0;
}

```

---

## 作者：嘒彼小星 (赞：2)

证明详见博客http://www.cnblogs.com/huibixiaoxing/p/7015597.html


这道题可以排序后从大到小排序，对于每个数x，若k | x,二分找x / k,标记为不能选


由于是从大往小找，可知当前x是否选取影响不到比它大的数


其实从最小开始选也可以，但是容易爆Long long空间，需要特殊处理一下



从小开始

'''cpp
 
 
 
 
 
```cpp
#include <bits/stdc++.h>
inline void read(long long &x){x = 0;char ch = getchar();while(ch > '9' || ch < '0'){ch = getchar();}while(ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();}
inline long long max(long long a, long long b){return a > b ? a : b;}
inline long long min(long long a, long long b){return a > b ? b : a;}
inline void swap(long long &a, long long &b){long long tmp = a;a = b;b = tmp;}
const long long INF = 0xfffffffffffffff;
const int MAXN = 100000 + 10;
const int MAXK = 100000 + 10;
long long num[MAXN],n,k;
bool b[MAXN];//记录哪一些数不能加入，true表示不能加
long long erfen(int l, int r, long long p)
{
    long long mid;
    while(l < r)
    {
        mid = l + ((r - l) >> 1);
        if(num[mid] >= p)r = mid;
        else l = mid + 1;
    }
    return l;
}
long long ans;
int main()
{
    read(n);read(k);
    for(int i = 1;i <= n;i ++)
    {
        read(num[i]);
    }
    std::sort(num + 1, num + 1 + n);
    float ma = (float)num[n] / (float)k;
    for(long long i = 1;i <= n;i ++)
    {
        if(!b[i])
        {
            ans ++;
            if(num[i] > ma)continue;
            long long tmp = erfen(i, n, num[i] * k);
            if(num[tmp]  == num[i] * k)
                b[tmp] = true;
        }
    }
    printf("%d", ans);
    return 0;
}
```
'''

从大开始

'''cpp
 
 
 
 
 
```cpp
#include <bits/stdc++.h>
inline void read(long long &x){x = 0;char ch = getchar();while(ch > '9' || ch < '0'){ch = getchar();}while(ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();}
inline long long max(long long a, long long b){return a > b ? a : b;}
inline long long min(long long a, long long b){return a > b ? b : a;}
inline void swap(long long &a, long long &b){long long tmp = a;a = b;b = tmp;}
const long long INF = 0xfffffffffffffff;
const int MAXN = 100000 + 10;
const int MAXK = 100000 + 10;
long long num[MAXN],n,k;
bool b[MAXN];//记录哪一些数不能加入，true表示不能加
long long erfen(int l, int r, long long p)
{
    long long mid;
    while(l < r)
    {
        mid = l + ((r - l) >> 1);
        if(num[mid] >= p)r = mid;
        else l = mid + 1;
    }
    return l;
}
long long ans;
int main()
{
     read(n);read(k);
     for(int i = 1;i <= n;i ++)
     {
         read(num[i]);
     }
     std::sort(num + 1, num + 1 + n);
     for(long long i = n;i >= 1;i --)
     {
         if(!b[i])
        {
            ans ++;
            if(num[i] % k == 0)
            {
                long long tmp = erfen(1, i, num[i] / k);
                if(num[tmp] * k == num[i])
                    b[tmp] = true;
            }
        }
     }
     printf("%d", ans);
    return 0;
}
```
'''


---

## 作者：RAYMOND_7 (赞：1)

## 竟然没有平衡树的题解！！！
## 我来补一个FHQ-Treap吧，目前是最优解，87ms



------------
进入正题

### 1. 思路

很显然是个贪心题，那么我们需要得到贪心结论并证明。

假设从小到大n个数依次进入集合k-set

通过略微思考可知，当处理到某个数的时候，前面比它小的数已经处理完，不被k整除的数一定可以进入k-集合，因为它与前面的数一定不冲突，满足最优子结构性质。

同理，若处理到的a[i]满足``k|a[i]``,则a[i]和前面的数，如果有k倍关系，就一定冲突；否则不冲突，可以进入k-set。

### 2. 做法
一堆set做法，常数大到哭o(╥﹏╥)o

手写平衡树多香qwq……

fhq_treap几个基本操作而已，very easy

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define LL long long
#define int long long
void read(int &x){
	char c=getchar();
	int k=1;
	while(c<'0'||c>'9') {if(c=='-') k=-1;c=getchar();}
	for(x=0;c>='0'&&c<='9';c=getchar())
	x=x*10+c-'0';
	x*=k;
}
const int N=1000005,oo=2147483647;
struct FHQ{
	int lc,rc,rnd,size;LL val;
}t[N];
int n,m,cnt,tot,x,y,k,op,root;LL a[N];
#define ls t[rt].lc
#define rs t[rt].rc
void up(int rt){
if(!rt)return;t[rt].size=t[ls].size+t[rs].size+1;
}
int build(LL v){
	tot++;t[tot].rnd=rand()<<15|rand();t[tot].size=1;t[tot].val=v;return tot;
}
void split(int rt,int &l,int &r,int k){
	if(k==0){l=0;r=rt;return;}
	if(k==t[rt].size){l=rt;r=0;return;}
	if(k<=t[ls].size)r=rt,split(ls,l,ls,k);
	else l=rt,split(rs,rs,r,k-1-t[ls].size);
	up(rt);
}
void merge(int &rt,int l,int r){
	if(!l||!r){rt=l+r;return;}
	if(t[l].rnd<t[r].rnd)rt=l,merge(rs,rs,r);
	else rt=r,merge(ls,l,ls);
	up(rt);
}
int rank(int rt,int v){
	if(!rt)return 0;
	if(v<=t[rt].val) return rank(ls,v);
	else return rank(rs,v)+t[ls].size+1;
}
void ins(int v){
	int a,b,c,rk=rank(root,v);
	split(root,a,b,rk);c=build(v);merge(b,c,b);
	merge(root,a,b);
}
bool find(int rt,LL x){
	if(!rt) return false;
	if(t[rt].val==x) return true;
	if(t[rt].val>x) return find(ls,x);
	return find(rs,x);
}
signed main(){
	t[0].rnd=oo;t[0].val=oo;read(n);read(k);
	for(int i=1;i<=n;i++)read(a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(a[i]%k!=0)ins(a[i]);
		else{
			if(!find(root,a[i]/k))ins(a[i]);
		}
	}
	printf("%d\n",t[root].size);
	return 0;
}
```
完结撒花

---

## 作者：tututu (赞：1)

可以发现，两个数为k倍关系是不能被纳入集合，而且一个数只会与k倍和1/k倍发生关系，其余互不影响。

从大到小排序（从小到大可能\*k的时候会炸，只有80），f记录能否被取入，false表示暂时可以。

一个一个枚举，一个数找到后，寻找有无1/k倍的数，如果有，继续找直到没有了。

由于n比较大，须要二分查找。

这样会形成一条长链，其中最多可以取(l+1)/2个（整除），即不能取l/2个，这部分扔掉，找过的f赋为true。

```cpp
var
  n,k,i,ans,num:longint;
  m,s:int64;
  a,t:array[-1..100002] of int64;
  f:array[-1..100002] of boolean;
procedure q(l,r:longint);
var
  i,j,m,k:longint;
begin
  if l=r then exit;
  m:=(l+r) div 2;
  q(l,m);
  q(m+1,r);
  i:=l;
  j:=m+1;
  k:=l;
  while (i<=m) and (j<=r) do
    if a[i]>=a[j] then begin t[k]:=a[i]; inc(i); inc(k); end else begin t[k]:=a[j]; inc(j); inc(k); end;
  while i<=m do
    begin t[k]:=a[i]; inc(i); inc(k); end;
  while j<=r do
    begin t[k]:=a[j]; inc(j); inc(k); end;
  for i:=l to r do
    begin
      a[i]:=t[i];
    end;
end;
function find(x:int64):longint;
var
  l,r,m:longint;
begin
  l:=1;
  r:=n;
  while l<r do
    begin
      m:=(l+r) div 2;
      if a[m]>x then l:=m+1 else r:=m;
    end;
  exit(l);
end;
begin
  readln(n,k);
  for i:=1 to n do read(a[i]);
  q(1,n);//大到小
  ans:=n;//答案，鄙人用的是减法，加法也可。
  for i:=1 to n do if not f[i] then//找到没有被排除的
    begin
      f[i]:=true;
      s:=a[i];
      num:=1;//这个数列的总个数
      while (a[find(s div k)]=s div k) and (s mod k=0) do//首先要能整除，然后再保证有这个数
        begin
          s:=s div k;
          f[find(s)]:=true;//排除
          inc(num);//+1
        end;
      ans:=ans-num div 2;//如果长度为偶数可取一半，奇数可取头尾，故+1后一半，即不可取一半
    end;
  write(ans);
end.
```

---


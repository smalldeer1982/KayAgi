# 小Z的车厢

## 题目描述

小 Z 的家乡有一列在环形铁轨上行驶的火车，共停靠 $n$ 个站（$1$ 号站到 $n$ 号站顺时针排列）。

众所周知，春运是一件非常可怕的事情。不幸的是，小 Z 是铁路公司的员工，现在他收到了 $m$ 条除夕凌晨的订票申请，每个申请 $(x, y, z)$ 表示有 $z$ 个人要从 $x$ 号站顺时针坐到 $y$ 号站，同时，当火车停靠到 $x$ 号站时，所有要在 $x$ 站上车的人都会上车，所有要在 $x$ 号站下车的人都会下车。

由于始发站不确定，现在小 Z 想知道至少需要分配给这列火车多少节车厢（每节车厢可容纳 $36$ 人）才能顺利完成该铁路运输，希望你帮帮他。

## 说明/提示

**【数据规模】**

对于 $30 \%$ 的数据，$n \le 1000$，$m \le 10000$；

对于 $100 \%$ 的数据，$1 \le n, m \le 10^6$，$x \ne y$，$1 \le z \le 100$。


## 样例 #1

### 输入

```
3 2
1 2 36
2 3 36
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 2
1 2 36
4 3 36
```

### 输出

```
2
```

# 题解

## 作者：oistr (赞：14)

$\color{white}\text{洛谷文章编号:139177}$
### update:更正了一点，故重新提交


## 看着各位神仙大显神通，本蒟蒻也来发一篇。
首先有一位大佬用了树状数组啥的，其实根本不用，直接~~暴力~~**模拟**就行了。

其实一开始看到这道题是我还感觉很简单，花了10min就打出了代码:

```cpp
#include <iostream>
using namespace std;
int on[1000000],off[1000000];//on、off数组分别记录第i站上、下车的人数
int main()
{
	int n,m,x,y,z;//按照题目所述
	cin>>n>>m;
	for(int i=1;i<=m;i++)//循环输入并设置on、off数组
	{
		cin>>x>>y>>z;
		on[x]+=z;
		off[y]+=z;
	}
	int train=0,sum=0;//train存放当前的火车上的人数
	for(int i=1;i<=n;i++)
	{
		train+=on[i];
		train-=off[i];//循环模拟上下车
		sum=max(sum,train);//更新最多时的人数
	}
    //判断并输出所需车厢数
	if(sum%36!=0)
	{
		cout<<sum/36+1<<endl;
	}
	else
	{
		cout<<sum/36<<endl;
	}
	return 0;
}
```

但是之后发现$\color{red}\text{WAWAWA了。}$

那么原因何在呢？

（~~憋忘了，$\color{green}\text{这是一道绿题啊。。。}$~~）（滑稽）

为甚会WA呢？我们再仔细读一读题。
```
小Z的家乡有一条环形的铁路
```
```
x不等于y
```
这意味着什么？**环形铁路，x不等于y，不就是说，，，**

## x>y

**吗**

为什么会出现起始站序号大于下车站的序号呢？

我们来看下面的图：

![](https://cdn.luogu.com.cn/upload/pic/61262.png)

应该很清楚了，按照图中的路线，这个旅客共经过了$3->4->1->2$这些站，实现了$x>y$。

那么，这样的订单怎么记录呢？

我们将其化成直线考虑：

假设有一个订单 $n=5,x=4,y=2,z=1$ 。那么这位乘客坐在火车上经过的站是上图涂了色的站。

也就是这个乘客经过了4、5、1、2四站……

然后是 **顿悟时刻**:

这不就相当于：**这位乘客在第一站上车，第二站下车，再在第四站上车吗？！**

所以这就是某巨佬题解中说的他“不知道为什么的玄学语句”
```
on[1]+=z;
```
！

综上，改进的代码如下：
```cpp
#include <iostream>
using namespace std;
int on[1000000],off[1000000];//on、off数组分别记录第i站上、下车的人数
int main()
{
	int n,m,x,y,z;//按照题目所述
	cin>>n>>m;
	for(int i=1;i<=m;i++)//循环输入并设置on、off数组
	{
		cin>>x>>y>>z;
		on[x]+=z;
		off[y]+=z;
       if(x>y)
       {
         on[1]+=z;
       }
	}
	int train=0,sum=0;//train存放当前的火车上的人数
	for(int i=1;i<=n;i++)
	{
		train+=on[i];
		train-=off[i];//循环模拟上下车
		sum=max(sum,train);//更新最多时的人数
	}
    //判断并输出所需车厢数
	if(sum%36!=0)
	{
		cout<<sum/36+1<<endl;
	}
	else
	{
		cout<<sum/36<<endl;
	}
	return 0;
}
```

这就 $\color{green}\text{锕}$了。

---

## 作者：CE_自动机 (赞：10)

题解区的dalao们都用的差分，~~我太菜了~~，只好用比较暴力提点的做法

观察可以发现，它想要求的是在做完区间覆盖后，所有区间中的最大值。首先想到的是用线段树，使用lazy标记，以及维护区间最大值

**一点小细节**:

1.站台其实并不是点，两个站台之间的路程在线段树中才是一个点。即：一个人要从$x$到$y$，它实际覆盖的区间为$(x,y-1)$

2.如样例2，可能会出现x>y的情况，表明该区间经过了线段树上的"第$n$个点"，那可以把该区间分成两段进行考虑，分别是$(x,n)$和$(1,y-1)$


至此分析就完成了，上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int x,y,z;

int read(){
	int x=0;
	char ch=getchar();
	while(!isdigit(ch)){
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x;
}

struct node{
	int l,r;
	int add;
	int max;
}tree[4000001];

void build(int l,int r,int u){
	tree[u].l=l;
	tree[u].r=r;
	if(l==r)return;
	int mid=l+r>>1;
	build(l,mid,u<<1);
	build(mid+1,r,u<<1|1);
}

void add(int l,int r,int u,int k){
	if(tree[u].l==l&&tree[u].r==r){
		tree[u].max+=k;
		tree[u].add+=k;
		return;
	}
	
	if(tree[u].add){
		tree[u<<1].max+=tree[u].add;
		tree[u<<1|1].max+=tree[u].add;
		tree[u<<1].add+=tree[u].add;
		tree[u<<1|1].add+=tree[u].add;
		tree[u].add=0;
	}
	
	int mid=tree[u].l+tree[u].r>>1;
	
	if(r<=mid)add(l,r,u<<1,k);
	else if(l>mid)add(l,r,u<<1|1,k);
	else add(l,mid,u<<1,k),add(mid+1,r,u<<1|1,k);
	
	tree[u].max=max(tree[u<<1].max,tree[u<<1|1].max);
}

int main(){
	n=read();
	m=read();
	build(1,n,1);
	while(m--){
		x=read();
		y=read();
		z=read();
		if(x<y){
			add(x,y-1,1,z);
		}
		else{
			add(x,n,1,z);
			if(y!=1)add(1,y-1,1,z);
		}
	}
	printf("%d",tree[1].max%36?tree[1].max/36+1:tree[1].max/36);
	return 0;
}
```


---

## 作者：dfydada⚡⚡⚡ (赞：3)

这题注意一个点就可以了

有一种情况是要特殊处理的，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/m0hucfhv.png)
从1->2;
然后需要4->3;
你不可能像图里画的一样，饶一个圈。
所以要特殊判断一下就好了。
如果x>y就放都1里面一起算。

上代码：

```cpp
for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		t1[x]+=z;
		t2[y]+=z;
		if(x>y)
		{
			t1[1]+=z;
		}
	}
```
其他的只要把最大的人数求出来余36，如果不等于0就加1。

上总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=1000000+10;
int n,m,x,y,z;
int f1,f2,maxx,t1[N],t2[N];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		t1[x]+=z;
		t2[y]+=z;
		if(x>y)
		{
			t1[1]+=z;
		}
	}
	for(int i=1;i<=n;i++)
	{
		f1+=t1[i];
		f2-=t2[i];
		maxx=max(maxx,f1+f2);
	}
	if(maxx%36)
	{
		cout<<maxx/36+1;
	}
	else
	{
		cout<<maxx/36;
	}
	return 0;
}

```


---

## 作者：BFSBFSBFSBFS (赞：3)

~~补题解+1.~~.

题意.给出**m**个订单.订单形式为**(x, y, z)**.表示从**x**站到**y**站过程中.有**z**人要乘火车.求人数最多的时候有几个..

转化模型.相当于在区间**(x, y)**中每个点**+=z**.如果**x > y**则区间变成**(y, n)**与**(1, x)**.

这个差分1下**(b[i] = b[i] - b[i-1])**.变成单点修改**(b[x] += z,b[y] -= z)**.

**b[i]**表示第**i**个站点的人数.**b[0] = 0**.

最后前缀和计算最大值就行了....

时间复杂度**O(2n)**.空间**O(N)**.

Diu代码.

```cpp
program P2190;
 uses math;
 var
  b:Array[0..2000001] of longint;
  i,m,n,x,y,z,smax,ssum:longint;
 begin
  readln(N,m);
  filldword(b,length(b),0);
  smax:=0;     //最大的人数.
  ssum:=0;     //前缀和.
  for i:=1 to m do
   begin
    readln(x,y,z);
    if x<y then
     begin
      inc(b[x],z);  //经过差分的修改..
      dec(b[y],z);    //对应区间(x, y).
     end
           else
     begin
      inc(b[x],z);  //对应区间(y, n).
      inc(b[1],z);  //对应区间(1, x).
      dec(b[y],z);    //.
     end;
   end;
  for i:=1 to n do
   begin
    inc(ssum,b[i]);       //前缀和还原.
    smax:=max(smax,ssum); //统计最大值.
   end;
  writeln((smax+35) div 36); //输出车厢数..
 end.
```
(ಡωಡ).


---

## 作者：天泽龟 (赞：3)

这题还是有点意思的，写篇题解警醒一下来者。

**我希望各位能记住一句话：面对任何带环的问题，您第一个想到的做法应该是考虑能不能破环为链，在链上解决问题。**

基于以上思路，我们可以从$n$处破开，再将其倍长，考虑原来的操作在这条链上的**等效变形**。

----

我们以样例为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/dara727e.png)

蓝色即为两次操作，易想到对于$x<y$和$x>y$分类讨论：

- 如果$x<y$，则直接正常走即可，由于倍长了我们需要覆盖两段：即$(x,y)~~and~~(x+n,y+n)$。

- 如果$x>y$，则它是从倍长前的链上某起点出发，到达倍长后的第二条链上的终点，即$(x,y+n)$。

可以想到任意一种满足$x>y$的操作都可以在这条倍长后的链上面表示出来确定的一段，所以第二种覆盖方法是很合理的。

$\color{red} \text{于是交上去就全WA了（龇牙）。}$

回过头来想，难道是**破环为链**的思想错了吗，绝对不可能的事，那就是有我们没考虑到的情况。

可以再给你这样一个样例.

![](https://cdn.luogu.com.cn/upload/image_hosting/qoc6epp6.png)

根据此图我们可以看出，对于第二种覆盖方法**也是要覆盖两次的**，因为可能会存在另一种$x>y$的区间，使其在前半段链中的点没覆盖到，在后半段点就覆盖到了。

然后就真的没了，，对于区间覆盖很容易想到用差分解决，最后上我丑陋的代码：
```cpp
#include <iostream>
#include <cstring>
#define inf 2147483647
#define MAXN 3000001  //由于第二种覆盖法可能会越界，所以开三倍。
using namespace std;

int n,m,a[MAXN],b[MAXN];

int main()
{
	cin>>n>>m;
	for (int i=1,x,y,w;i<=m;i++) {
		cin>>x>>y>>w; 
		if (y<x) {
			b[x]+=w,b[y+n]-=w;
			b[x+n]+=w; b[y+2*n]-=w;
		}
		else {
			b[x]+=w; b[y]-=w; 
			b[x+n]+=w; b[y+n]-=w;
		}
	}
	int maxx=0,sum=0;
	for (int i=1;i<=3*n;i++) 
		sum+=b[i],maxx=max(maxx,sum);
	cout<<((maxx%36==0)?maxx/36:maxx/36+1)<<endl;
}
```

---

## 作者：Mine_King (赞：2)

本题 $n,m \le 10^6$，所以暴力枚举肯定不行。那么我们考虑用其他的办法。由于我们要实现区间修改，以及从 $1$ 到 $n$ 求单点的值（一个申请相当于让 $x$~$y-1$ 都加上 $z$（到 $y$ 站就下车了，所以不用加），而结果就是每个点的值的最大值），所以选择差分来解决。  
那么，差分就是让
$$diff_x+=z,diff_y-=z$$
注意，如果 $y>x$,那么就是
$$diff_x+=z,diff_{n+1}-=z,diff_1+=z,diff_y-=z$$
最后，统计答案的时候只要一遍统计一遍用一个变量把前面所有的 $diff$ 加起来即可。  
**code:**
```cpp
#include<cstdio>
using namespace std;
int n,m,diff[1000005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if(x<y) diff[x]+=z,diff[y]-=z;
		else diff[x]+=z,diff[n+1]-=z,diff[1]+=z,diff[y]-=z;
	}
	int ans=0,res=0;
	for(int i=1;i<=n;i++)
	{
		res+=diff[i];
		if((res-1)/36+1>ans) ans=(res-1)/36+1;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：loi_hjh (赞：2)

~~作为首个c++题解，自然要。。。~~ 

# 附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
int n,m,ans,p,x,y,z,tx[2000100],ty[2000100];//tx[i]代表第i站上车的人数，ty是下车的人数 
int main(){
	scanf("%d%d",&n,&m);
	for(ri i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		if(x<y) tx[x]+=z;//x<y时，x站上z人
		else{
			tx[1]+=z;//假设有5个站：1,2,3,4,5, 从4上了z个人，就是这些人一共在4，5，1，2站坐车，可以想成在1上车，x上车 
			tx[x]+=z;
		}
		ty[y]+=z;//y站下z人 
	}
	for(ri i=1;i<=1000000;i++){//最多有100w个站，计算每个站最多时的人数 
		p+=tx[i];
		p-=ty[i];
		ans=max(ans,p);//求出最大值 
	}
	if(ans%36!=0) printf("%d",ans/36+1);//莫名其妙ceil挂了，凑活一下吧 
	else printf("%d",ans/36);
	return ~~(0-0);
}


```


---

## 作者：_Spectator_ (赞：2)

[可能更好的食用体验](https://www.luogu.com.cn/blog/XT-666/solution-p2190)


------------
### ${\color{RoyalBlue}\colorbox {white}{样例解释}}$
```
4 2
1 2 36
4 3 36
```
在这个样例中，第一个订票申请没啥问题，就是有 $36$ 个人从站 $1$ 上车，站 $2$ 下车。问题出在第二个申请：怎么会从站 $4$ 上车，站 $3$ 下车呢？再看题目，铁轨是**环形**的，所以这个申请的路程是 $4$->$1$->$2$->$3$ 。其中，经过站 $1$ 时又会有 $36$ 人上来，所以至少需要 $2$ 节车厢。


------------

### ${\color{RoyalBlue}\colorbox {white}{主要思路}}$

不难看出，至少需要的车厢数就是火车在行驶过程中乘客最多时所需要的车厢数。但是循环从站 $x$ 到站 $y$ 都加上 $z$ 显然会 TLE 。这时我就想，既然要在连续一段都加上同一个数，不妨试试前缀和！每次在  $a_x$ 加上 $z$ 表示上车 $z$ 人，生成前缀和时就会把 $z$ 人加上；然后在 $a_y$ 减去 $z$ 表示下车 $z$ 人，生成前缀和时就会把 $z$ 人减去。最后生成 $a$ 数组的前缀和，找到最多的乘客数。代码：
```cpp
for(int i=1;i<=m;i++)
{
	scanf("%d %d %d",&x,&y,&z);
	a[x]+=z,a[y]-=z;
}
for(int i=1;i<=n;i++)
	sum[i]=sum[i-1]+a[i],ans=max(sum[i],ans);
```
But 还要注意，~~这是一道绿题~~ 轨道是个环形，所以可能会出现 $x>y$ 的情况。这就相当于从站 $x$ 到站 $n$ ，再从站 $1$ 到站 $y$ 。只需要分两段，做两次加减操作即可。即：在 $a_x$ 加上 $z$ ， $a_n$ 减去 $z$ ，再在 $a_1$ 加上 $z$ ， $a_y$ 减去 $z$ ，前缀和部分不变。代码：
```cpp
for(int i=1;i<=m;i++)
{
	scanf("%d %d %d",&x,&y,&z);
	if(x<y)a[x]+=z,a[y]-=z;
	else a[x]+=z,a[n]-=z,a[1]+=z,a[y]-=z;
}
for(int i=1;i<=n;i++)
	sum[i]=sum[i-1]+a[i],ans=max(sum[i],ans);
```
最后判断是否是 $36$ 的倍数，再输出即可。


------------

### ${\color{RoyalBlue}\colorbox {white}{完整代码}}$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,z,ans;
int a[1000005],sum[1000005];
#error\
禁止抄题解
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d %d",&x,&y,&z);
		if(x<y)a[x]+=z,a[y]-=z;
		else a[x]+=z,a[n]-=z,a[1]+=z,a[y]-=z;//分两段，从站x到站n再从站1到站y
	}
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+a[i],ans=max(sum[i],ans);
	if(ans%36==0)cout<<ans/36;
	else cout<<ans/36+1;
	return 0;
}
```

---

## 作者：YanYou (赞：1)

## 不要抄题解啊
### P党又来了

好了，说点正事。

此题第一眼看到一定是想到暴力，but，扫一眼数据，1 ≤ n，m ≤ 10^6，O(nm) 算法一定超时！

于是我们想到一种神奇的维护方法：**差分**

变成单点修改，**a[x]+z , a[y]-z**

最后前缀和计算一遍，找最大值，就行了

献上巨丑的代码

------------

```pascal

var n,m,i,x,y,z,s,ans:longint;
    a:array[0..1000010] of longint;
begin
  assign(input,'小Z的车箱.in');reset(input);
  assign(output,'小Z的车箱.out');rewrite(output);
  readln(n,m);
  for i:=1 to m do begin
    readln(x,y,z);
    if x<y then begin inc(a[x],z); dec(a[y],z); end
    else begin inc(a[x],z); inc(a[1],z); dec(a[y],z); end; //差分
  end;
  for i:=1 to n do begin
    inc(s,a[i]);
    if s>ans then ans:=s;
  end;
  if ans mod 36=0 then ans:=ans div 36 else ans:=ans div 36+1;
  writeln(ans);
  close(input); close(output);
end.

大家不要抄（Ctrl+C) 啊！

```


------------

## 总之，抄题解是不对的！

---

## 作者：WinterRain208 (赞：1)

题解 P2190

### 做法

这题比较简单，就直接说做法。

看到我们这个数据，就立马发现可以按题意跑一边这个环形。记录一下每个站的人数，取最大。

举出反例，因为这是一个环，所以题目中 $x > y$ 可能存在，这样的情况只跑一遍会出错，如何避免？

对于这个数据 $(x,y,z)$ 我们分解一下 $(x>y)$ 。

分解为 $(x,1,z)$ 和 $(1,y,z)$ 。

这样做为什么可以呢？把这两段连起来就是整的了，这样我们就可以避免$x>y$的情况了。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,r) for(int i=j;i<=r;++i)
#define D(i,j,r) for(int i=j;i>=r;--i)
#define INF 0x3f3f3f3f

using namespace std;
const int N=1e6+5;

long long read(){
	long long f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<3)+(x<<1)+s-'0';s=getchar();}
	return x*f;
}

inline void write(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
	return;
}

long long n,m,x,y,z,a[N],b[N],tot=0,M=-INF;
int main(){
	n=read();m=read();
	F(i,1,m){
		x=read(),y=read(),z=read();
		a[x]+=z,b[y]+=z;
		if(x>y)a[1]+=z;
	}
	F(i,1,n){
		tot+=(a[i]-b[i]);
		M=max(M,tot);
	}
	if(M%36)write(M/36+1);
	else write(M/36);
    return 0;
}
```

想要跑得快，写快读，开O2，本题涉及统计，还可以写个线段树记录。

点个赞再走吧！

---

## 作者：泗水一中李琦 (赞：0)

本来想着求区间最大和，按最大子段和的做法来做，然后发现不行，对于x>y的没办法，然后想办法求环形数据的最大子段和，可惜我蒟蒻，不会，然后看了一下C++题解，有个b[1]+=z，然后根据玄学思想，加上了，然后莫名AC了qwq
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int b[1000001];
int main()
{
	int n,m;
	cin>>n>>m;//读入数据 
	int a,B,c;//因为b之前定义了，是个数组，所以这里大写 
	for(int i=1;i<=m;i++)
	{
		cin>>a>>B>>c;//输入abc，即xyz 
		if(a<B)//如果在一圈之内，上车点+z，下车点-z 
		{
			b[a]+=c;
			b[B]-=c;
		}
		else
		{
			if(a>B)//超过了一圈，就把原点也加上（别问我为什么，我看的楼上C++的题解一个步骤拿过来用了，竟然AC了 
			{
				b[1]+=c;
				b[a]+=c;
				b[B]-=c;
			}
		}
	}
	int maxsum=0,sum=0;//sum记录当前和，maxsum记录最大和 
	for(int i=1;i<=n;i++)//dp求最大和 
	{
		sum+=b[i];
		if(sum>maxsum)
		{
			maxsum=sum;
		}
		else
		{
			if(sum<0)
			{
				sum=0;
			}
		}
	}
	int ans;
	if(maxsum%36==0)//算车厢数 
	{
		ans=maxsum/36;
	}
	else
	{
		ans=maxsum/36+1;
	}
	cout<<ans<<endl;//输出 
	return 0;
}
```

---

## 作者：Celebrate (赞：0)

洛谷说这是一道模拟题，不过我觉得这是在坑人

我想到了三个解法（题解上说的差分我不是很懂）：

## 解法1

直接暴力模拟，时间O(NM)这个显然是不行的

## 解法2

如果你很强，对算法掌握的很好的话，就可以直接用险段树做

利用lazy延迟修改，并且查询最大值，比赛的时候一般不用

这样很太复杂而且不容易调试，但是不暴力

时间是O(mlogn+logn)，不过常数和内存都很大

我虽然会不过不想打了

## 解法3
树状数组+差分

这一题我们利用树状数组来维护差分

1修改：

如果x<y
      
那么我们就给点x +z（update(x,z))

给点y -z(update(y,-z))

如果x>y
就update(x,z),update(1,z),update(y,-z)

很好的处理首尾相接

最后

求出每一个数的前缀和，找出最大的，处理一下就行了

代码：
  
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<map>
#include<cmath>
#include<string>
#include<set>
#include<ctime>
#define lowbit(x) x&(-x)
using namespace std;
inline int read(){
	int x=0,f=0;char s=getchar();
	while(!isdigit(s))f|=s=='-',s=getchar();
	while( isdigit(s))x=(x<<1)+(x<<3)+s-48,s=getchar();
	return !f?x:-x;
}
inline void print(int x){
     if(x<0)putchar('-'),x=-x;
     if(x>9)print(x/10);
     putchar(x%10+'0');
}
const int N=1e6+20;
int n,m,a[N];
void update(int x,int t){//给点x加t 
	while(x<=n){
		a[x]+=t;
		x+=lowbit(x);
	}
}
int getsum(int x){//求点x的前缀和 
	int sum=0;
	while(x>0){
		sum+=a[x];
		x-=lowbit(x);
	}
	return sum;
}
int main(){
	n=read();m=read();
	int x,y,z;
	for(int i=1;i<=m;i++){
		x=read();y=read();z=read();//差分修改 
		if(x<y)update(x,z),update(y,-z);
		else update(x,z),update(1,z),update(y,-z);
	}
	int maxx=0;
	for(int i=1;i<=n;i++)//求最大值 
		maxx=max(maxx,getsum(i));
	if(maxx%36==0)maxx/=36;
	else maxx=maxx/36+1;
	print(maxx);//输出 
	return 0;
}

```



---


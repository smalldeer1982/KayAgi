# 奶牛芭蕾

## 题目描述

她的期末汇报演出就在下周，于是Farmer Jhon 就帮她建一个长方形的舞台。


为了防止Bessie从舞台边缘掉下，FJ决定要建一个足够大的舞台。


Bessie的舞蹈将会占用一个由许多1 x 1的正方形方块组成的长方形的区域。为了方便，我们把Bessie的四只脚按如下方式简写：


FR : 前右脚（Front right foot）


FL ：前左脚（Front left foot）


RR ：后右脚（Rear right foot）


RL ：后左脚（Rear left foot）


Bessie将会从一个如下的四个相邻的格子出发，同时她会面向北方。




FL FR

RL RR

Bessie的舞蹈会依据总数为N（1 <= N <= 1000 ) 的指令进行。每一条指令都指示Bessie将一只脚移动一个格子，或者顺时针旋转90°


其中，移动的指示由三个字符组成，其中前两个是脚的代号，最后一个代表脚移动的方向（"F" - 向前 "B" - 向后 "R" - 向右 "L" - 向左）


比如说， "FRF"代表着Bessie的前右脚向前移动一个格子,"RLR"代表她的后左脚将向右移一个格子


当然，我们这里说的方向是以Bessie正面对的方向决定的。




另一方面，旋转的指令也是3个字符，其中前两个字母也是脚的代号，代表着旋转的支点。最后一个字母总是为"P"(pivot)。


比如说， "FRP"代表着Bessie将以前右脚为支点，顺时针旋转90°。


如果我们从图中看，假设现在Bessie的脚是这样的,她正朝向北方。


.. .. ..


.. .. FR


.. FL ..


.. RL RR



那么在进行指令"FRP"之后，她的脚的位置将变成下面这样，同时她将会朝向左边：


RL FL ..

RR .. FR


.. .. ..


.. .. ..




现在已知N条Bessie的舞蹈的指令，请你计算她的整个舞蹈所需要的最小的长方形舞台，使得Bessie的脚不会落到舞台之外。


如果无论怎么样，她都会使自己的两个脚移动到相同的格子里，那么她就会被绊倒，并搞砸这次表演。


在这样的情况下，请输出-1。


不过这是Bessie会被绊倒的唯一的原因，因为她在经过练习之后，身体十分的柔软，可以轻松的做到任何奇怪的动作（比如说把后脚伸到前脚的前面）


（吐槽：那你就不能两只脚放在一起？）


(吐槽2：如果你觉得里面的配图有点怪异的话，就把它复制到记事本 ，把字体改成Courier New即可）


## 说明/提示

样例的输出解释：

Bessie的舞蹈需要至少4 x 4的舞台，并将会按下图进行：


.. .. .. ..

.. .. .. .. (朝向北)

.. .. FL FR

.. .. RL RR


FRF之后:


.. .. .. ..

.. .. .. FR (朝向北)

.. .. FL ..

.. .. RL RR


FRP之后:


.. RL FL ..

.. RR .. FR (朝向东)

.. .. .. ..

.. .. .. ..


RLB之后:


RL .. FL ..

.. RR .. FR (朝向西)

.. .. .. ..

.. .. .. ..


## 样例 #1

### 输入

```
3
FRF
FRP
RLB```

### 输出

```
16```

# 题解

## 作者：ran_qwq (赞：10)

这道题做法显然，是模拟。

如果直接模拟的话代码会冗长，难以调试（这样的代码可以看下面的题解，下面会对这些题解进行一个对比）。

我们需要一些对长度的优化。

其实，四个蹄子的坐标并不需要用 $8$ 个变量，用一个数组记录当前位置，用 map 建立映射关系来查询。

我们在搜索时，会用数组记录四个方向。在这道题中，如果 Bessie 向北，她向前走是向北的；如果她向东，向前走就是向东，向右走就是向南。可以得出她实际上是向那走在模拟。

本题的难点在旋转上。估计不少人卡在了这里。

为了方便，我们假设支点坐标为 $(0,0)$，设要旋转的点坐标为 $(x,y)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/o3hn115i.png)

~~根据小学课本可知~~，上图蓝线长度相等，等于 $x$；绿线长度相等，等于 $y$。则可看出，新点坐标为 $(y,-x)$。经举例得知此规律在任何情况都成立。

然后因为一开始设了支点坐标为 $(0,0)$，所以新点坐标应该加回支点坐标。

则代码写出来就很容易了。

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
#include<map>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=1e5+10;
const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
int n,dir,minx,maxx=1,miny,maxy=1,nx[4]={1,0,1,0},ny[4]={1,1,0,0};//这里设左后脚为原点
map<string,int> mp;
signed main()
{
	cin>>n;
	mp["FR"]=mp["F"]=0,mp["FL"]=mp["R"]=1,mp["RR"]=mp["B"]=2,mp["RL"]=mp["L"]=3;//用 map 建立映射关系
	for(int i=1;i<=n;i++)
	{
		string s,t;
		cin>>s,t=s[2],s.erase(2,1);//把字符串分离
		if(t!="P")//移动脚
			nx[mp[s]]+=dx[(mp[t]+dir)%4],ny[mp[s]]+=dy[(mp[t]+dir)%4];
		else
		{
			dir=(dir+1)%4;//方向改变
			int cx=nx[mp[s]],cy=ny[mp[s]];
			for(int i=0;i<4;i++)
			{
				int disx=nx[i]-cx,disy=ny[i]-cy;
				nx[i]=cx+disy,ny[i]=cy-disx;//新点坐标加回支点坐标
			}
		}
		for(int i=0;i<4;i++)
			minx=min(minx,nx[i]),maxx=max(maxx,nx[i]),miny=min(miny,ny[i]),maxy=max(maxy,ny[i]);//统计最小值
		for(int i=0;i<4;i++)//判断会不会绊倒
			for(int j=i+1;j<4;j++)
				if(nx[i]==nx[j]&&ny[i]==ny[j])
					cout<<-1,exit(0);
	}
	cout<<(maxx-minx+1)*(maxy-miny+1);
	return 0;
}

```


---

## 作者：Mingoal (赞：6)

抢一血！！！！

这好像是USACO里的一道题

算法：纯模拟

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct kk{
    int x,y;
}a[5];
char F[255],G[255],s[4],T[255];
int foot,k,j,i,xx,yy,minx,miny,maxx,maxy,b[4][2]={{-1,0},{0,1},{1,0},{0,-1}},n,t;
int main(){
    F['F']=0;F['R']=1;F['B']=2;F['L']=3;F['P']=4;//判断前进方向
    G['F']=0;G['R']=1;T['L']=0;T['R']=1;//判断是哪只脚
    cin>>n;
    a[1].y=a[2].x=a[3].x=a[3].y=1;
    maxx=maxy=1;
    for (i=1;i<=n;i++){
        scanf("%s",s);
        foot=G[s[0]]*2+T[s[1]];
        k=F[s[2]];
        if (k<4) a[foot].x+=b[(k+t)%4][0],a[foot].y+=b[(k+t)%4][1];//在我的方法中，前进方向加朝向模4就是去的方向
          else{
              t=(t+1)%4;//转向
            for (j=0;j<4;j++) xx=a[j].y-a[foot].y+a[foot].x,yy=a[foot].x-a[j].x+a[foot].y,a[j].x=xx,a[j].y=yy;
        }
        for (j=0;j<4;j++)
            for (k=j+1;k<4;k++)
                if (a[j].x==a[k].x && a[j].y==a[k].y){
                    cout<<-1;
                    return 0;
                }
        for (j=0;j<4;j++) minx=min(minx,a[j].x),maxx=max(maxx,a[j].x),miny=min(miny,a[j].y),maxy=max(maxy,a[j].y);
    }
    cout<<(maxx-minx+1)*(maxy-miny+1);
}
```

---

## 作者：sxyugao (赞：5)

**题意**

给你一系列指令，让你模拟奶牛的行动，若不合法（踩到自己），输出-1。

**算法**

直接按题意模拟（不然呢。。）。

代码如下：
```cpp
const
FL=1;FR=2;RL=3;RR=4;
//脚的代号，同题意
F=1;B=2;R=3;L=4;
//操作的代号
NORTH=1;EAST=2;SOUTH=3;WEST=4;
//朝向的代号，相信地球人都看得懂
var
n,i,facing,minx,miny,maxx,maxy,ans:longint;
//facing表示当前的朝向
s:string[3];
x,y:array[1..4]of longint;
//4个脚的坐标
function max(a,b:longint):longint;
  begin if a>b then exit(a);exit(b);end;
function min(a,b:longint):longint;
  begin if a<b then exit(a);exit(b);end;
procedure update;//更新答案
  var i:longint;
  begin
    for i:=1 to 4 do
      begin
        minx:=min(minx,x[i]);
        maxx:=max(maxx,x[i]);
        miny:=min(miny,y[i]);
        maxy:=max(maxy,y[i]);
      end;
  end;
procedure print;//输出答案
  begin
    write(ans);
    halt;
  end;
procedure go(n,k:longint);//前进操作
  var i:longint;
  begin
    case k of
    F:case facing of
      NORTH:inc(y[n]);
      EAST:inc(x[n]);
      SOUTH:dec(y[n]);
      WEST:dec(x[n]);
      end;
    B:case facing of
      NORTH:dec(y[n]);
      EAST:dec(x[n]);
      SOUTH:inc(y[n]);
      WEST:inc(x[n]);
      end;
    R:case facing of
      NORTH:inc(x[n]);
      EAST:dec(y[n]);
      SOUTH:dec(x[n]);
      WEST:inc(y[n]);
      end;
    L:case facing of
      NORTH:dec(x[n]);
      EAST:inc(y[n]);
      SOUTH:inc(x[n]);
      WEST:dec(y[n]);
      end;
    end;
    for i:=1 to 4 do
      if(x[i]=x[n])and(y[i]=y[n])and(i<>n)then print;
      //脚在同一位置了，输出-1
    update;
  end;
procedure turn(n:longint);//转向
  var i,dx,dy:longint;
  begin
    for i:=1 to 4 do if i<>n then
      begin
        dx:=y[n]-y[i];dy:=x[n]-x[i];
        x[i]:=x[n]-dx;y[i]:=y[n]+dy;
      end;
    inc(facing);if facing>WEST then facing:=NORTH;                  //西后面是北
    update;
  end;
procedure pd(ch:char;s:string);//选择正确的操作
  var i:longint;a:array[1..4]of string[2]=('FL','FR','RL','RR');
  begin
    for i:=1 to 4 do if a[i]=s then break;
    case ch of
    'F':go(i,F);
    'B':go(i,B);
    'R':go(i,R);
    'L':go(i,L);//以上为直行
    'P':turn(i);//旋转
    end;
  end;
begin
readln(n);facing:=NORTH;ans:=-1; 
x[FL]:=1;y[FL]:=2;x[FR]:=2;y[FR]:=2;
x[RL]:=1;y[RL]:=1;x[RR]:=2;y[RR]:=1;
minx:=1;miny:=1;maxx:=2;maxy:=2;
//初始化，假设面朝北
for i:=1 to n do
  begin
    readln(s);
    pd(s[3],copy(s,1,2));
    //选择正确的操作
  end;
ans:=(maxx-minx+1)*(maxy-miny+1);
print;
end.
```

---

## 作者：帝千秋丶梦尘 (赞：2)

## [题目链接](https://www.luogu.com.cn/problem/P2206)

一道练习模拟的好题

那怎么做呢？

按题意模拟呗

我的代码可能有亿点冗长，

但应该比其他的比较好理解（自己认为）

（把后脚伸到前脚的前面让我笑了半天）

$CODE$：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register
using namespace std;
int n;
int fx=1,addx,addy;//fx为1为北,2为东,3为南,4为西。 
int flx=0,frx=0,rlx=1,rrx=1;//四只脚的横坐标
int fly=0,fry=1,rly=0,rry=1;//四只脚的纵坐标
int Minx=0,Miny=0,Maxx=1,Maxy=1;//即为舞台最大的前后左右坐标
string s;//输入的字符串
signed main(void)
{
	std::ios::sync_with_stdio(false);
	cin>>n;
	for(ri int i(1);i<=n;++i)
	{
		cin>>s;
		if(s[2]!='P')//若是走路
		{
			if(s[2]=='F')//若是向前走
			{
				if(fx==1)//分别是四个方向的向前走的走法，就不一一解释了
				{
					addx=-1;
					addy=0;
				}
				else if(fx==2)
				{
					addx=0;
					addy=1;
				}
				else if(fx==3)
				{
					addx=1;
					addy=0;
				}
				else if(fx==4)
				{
					addx=0;
					addy=-1;
				}
			}
			else if(s[2]=='B')//向后
			{
				if(fx==1)
				{
					addx=1;
					addy=0;
				}
				else if(fx==2)
				{
					addx=0;
					addy=-1;
				}
				else if(fx==3)
				{
					addx=-1;
					addy=0;
				}
				else if(fx==4)
				{
					addx=0;
					addy=1;
				}
			}
			else if(s[2]=='R')//向右
			{
				if(fx==1)
				{
					addx=0;
					addy=1;
				}
				else if(fx==2)
				{
					addx=1;
					addy=0;
				}
				else if(fx==3)
				{
					addx=0;
					addy=-1;
				}
				else if(fx==4)
				{
					addx=-1;
					addy=0;
				}
			}
			else if(s[2]=='L')//向左
			{
				if(fx==1)
				{
					addx=0;
					addy=-1;
				}
				else if(fx==2)
				{
					addx=-1;
					addy=0;
				}
				else if(fx==3)
				{
					addx=0;
					addy=1;
				}
				else if(fx==4)
				{
					addx=1;
					addy=0;
				}
			}
			if(s[0]=='F')//若是前面的蹄子
			{
				if(s[1]=='L')//左前蹄
				{
					flx+=addx;
					fly+=addy;
				}
				else//剩下的就是右前蹄子啦
				{
					frx+=addx;
					fry+=addy;
				}
			}
			else if(s[0]=='R')//后腿
			{
				if(s[1]=='L')//后左
				{
					rlx+=addx;
					rly+=addy;
				}
				else//后右
				{
					rrx+=addx;
					rry+=addy;
				}
			}
		}
		else//接下来就是难点转圈圈了
		{
			int flax=0,flay=0,frax=0,fray=0,rlax=0,rlay=0,rrax=0,rray=0;//这些就是记录若以一个地方为支点，另外三条腿距离支点的距离
			if(s[0]=='F')//前面的腿
			{
				if(s[1]=='L')//接下来我解释下我其中一条腿的转圈方法
				{
					frax=frx-flx,fray=fry-fly;
					rlax=rlx-flx,rlay=rly-fly;
					rrax=rrx-flx,rray=rry-fly;
					frax=-1*frax,swap(frax,fray);
					rlax=-1*rlax,swap(rlax,rlay);
					rrax=-1*rrax,swap(rrax,rray);
					frx=flx+frax,fry=fly+fray;
					rlx=flx+rlax,rly=fly+rlay;
					rrx=flx+rrax,rry=fly+rray;
/*前面三行就是另外三条腿距离这个支点腿的距离,
 而中间三行其实也是比较好懂的，可以找个栗子试试
 比如当前支点在（0，0），右前蹄在（1,2）,那么距离就是1,2
 旋转一下，那就是（2，-1），再转一下（-1，-2），最后转一下（-2，1）
 可以发现就是横坐标*（-1），然后交换前后坐标就行了
*/
				}
				else
				{
					flax=flx-frx,flay=fly-fry;
					rlax=rlx-frx,rlay=rly-fry;
					rrax=rrx-frx,rray=rry-fry;
					flax=-1*flax,swap(flax,flay);
					rlax=-1*rlax,swap(rlax,rlay);
					rrax=-1*rrax,swap(rrax,rray);
					flx=frx+flax,fly=fry+flay;
					rlx=frx+rlax,rly=fry+rlay;
					rrx=frx+rrax,rry=fry+rray;
				}
			}
			else if(s[0]=='R')
			{
				if(s[1]=='L')
				{
					flax=flx-rlx,flay=fly-rly;
					frax=frx-rlx,fray=fry-rly;
					rrax=rrx-rlx,rray=rry-rly;
					flax=-1*flax,swap(flax,flay);
					frax=-1*frax,swap(frax,fray);
					rrax=-1*rrax,swap(rrax,rray);
					flx=rlx+flax,fly=rly+flay;
					frx=rlx+frax,fry=rly+fray;
					rrx=rlx+rrax,rry=rly+rray;
				}
				else
				{
					flax=flx-rrx,flay=fly-rry;
					frax=frx-rrx,fray=fry-rry;
					rlax=rlx-rrx,rlay=rly-rry;
					flax=-1*flax,swap(flax,flay);
					frax=-1*frax,swap(frax,fray);
					rlax=-1*rlax,swap(rlax,rlay);
					flx=rrx+flax,fly=rry+flay;
					frx=rrx+frax,fry=rry+fray;
					rlx=rrx+rlax,rly=rry+rlay;
				}
			}
			fx++;
			if(fx==5)//若方向为5，那就变成1
			{
				fx=1;
			}
		}
		Minx=min(Minx,min(min(flx,frx),min(rlx,rrx)));
		Miny=min(Miny,min(min(fly,fry),min(rly,rry)));
		Maxx=max(Maxx,max(max(flx,frx),max(rlx,rrx)));
		Maxy=max(Maxy,max(max(fly,fry),max(rly,rry)));
       		//取最大和最小的
		if((flx==frx&&fly==fry)||(flx==rlx&&fly==rly)||(flx==rrx&&fly==rry))
		{
			cout<<"-1";
			return 0;
		}
		if((frx==rlx&&fry==rly)||(frx==rrx&&fry==rry)||(rlx==rrx&&rly==rry))
		{
			cout<<"-1";
			return 0;
		}//判断是否踩到自己蹄子
	}
	cout<<(Maxx-Minx+1)*(Maxy-Miny+1);//求总面积
	return 0;
}
```
就是这样QvQ，大家看懂了么~~~

---

## 作者：AgrumeStly (赞：1)

一道模拟好题![](//啧.tk/qiang)

### 题意

根据各个指令模拟奶牛动作，最终求出奶牛横纵坐标最大值，并求面积。

### 思路

纯模拟即可。

用 $x,y$ 去存四条腿的坐标偏移

因为奶牛有朝向，所以我们的方向偏移数组 $d_x,d_y$ 存储转向时，应当按照顺时针顺序，这样转向时只需加一即可，因为有四个方向，所以当超过四时进行 $\%4$ 即可解决。

转到各个方向其实就相当于转了多少了 $90^{\circ}$。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
//aks
inline int read() {
    char c=getchar(),f=0;int t=0;
    for (;c<'0'||c>'9'; c=getchar()) if (!(c^45)) f=1;
    for (;c>='0'&&c<='9';c=getchar()) t=(t<<1)+(t<<3)+(c^48);
    return f?-t:t;
}
inline void write(int x) {
    static int t[25]; int tp=0;
    if (x==0) return (void)(putchar('0')); else if (x<0) putchar('-'), x=-x;
    while (x) t[tp++]=x%10,x/=10;
    while (tp--) putchar(t[tp]+48);
}
int n, minx, maxx, miny, maxy;//n条指令，x最小最大值，y最小最大值 
int x[] = {0, 1, 1, 0}; // 0FL， 1FR 
int y[] = {1, 1, 0, 0}; // 2RR， 3RL 
int dx[] = {0, 1, 0, -1}; //0上， 1右， 2下， 3左 
int dy[] = {1, 0, -1, 0};
int d; // 当前方向 
int main() {
    n = read();
    for (int i = 1; i <= n; i++) {
        char a, b, op;
        cin >> a >> b >> op;
        int f;
        if (a == 'F' && b == 'L') f = 0; // 前左腿
        if (a == 'F' && b == 'R') f = 1; // 前右腿
        if (a == 'R' && b == 'R') f = 2; // 后右腿
        if (a == 'R' && b == 'L') f = 3; // 后左腿
        if (op == 'F') x[f] += dx[d], y[f] += dy[d]; // 向前走一步 
        if (op == 'B') x[f] += dx[(d + 2) % 4], y[f] += dy[(d + 2) % 4]; // 顺时针 180（向后退）
        if (op == 'L') x[f] += dx[(d + 3) % 4], y[f] += dy[(d + 3) % 4]; // 顺时针 270（向左）
        if (op == 'R') x[f] += dx[(d + 1) % 4], y[f] += dy[(d + 1) % 4]; // 顺时针 90（向右）
        if (op == 'P') {
            int x0 = x[f], y0 = y[f];
            for (int i = 0; i <= 3; i++) { // 将第x[i], y[i]绕x[f], y[f]顺时针旋转90度 
                x[i] -= x0, y[i] -= y0;
                swap(x[i], y[i]);
                y[i] = -y[i];
                x[i] += x0, y[i] += y0;
            }
            d = (d + 1) % 4;
        }
        for (int i = 0; i <= 3; i++) // 枚举第 i 条腿 
            for (int j = i + 1; j <= 3; j++) // 枚举第 j 条腿 
                if (x[i] == x[j] && y[i] == y[j]) { // 绊倒 
                    puts("-1");
                    return 0;
                }
        for (int i = 0; i <= 3; i++) {
            minx = min(minx, x[i]);
            miny = min(miny, y[i]);
            maxx = max(maxx, x[i]);
            maxy = max(maxy, y[i]);
        }
    }
    cout << (maxx - minx + 1) * (maxy - miny + 1) << endl;
    return 0;
}




---

## 作者：Celebrate (赞：1)

[我的博客](https://blog.csdn.net/zsyzClb/article/details/84338040)

这道题并不是很难，只是模拟起来很恶心，我们要学会化简模拟，比如说利用转化的思想

其实操作只有两种，一种是某一个脚朝一个方向走一格，另一种是以一只脚为中点顺时针选择90度

我们先想想bessie一开始站在平面直角坐标系上，左后脚站在原点，朝着x的正半轴及上方

为了化简我设定了

b[]分别表示Bessie的四个脚
b[0]表示前左脚
b[1]表示前右脚
b[2]表示后左脚
b[3]表示后右脚
 

pos表示bessie当前的方向
pos=0表示朝上
pos=1表示朝左
pos=2表示朝下
pos=3表示朝右
'F' 'B' 'L' 'R'分别表示操作0,1,2,3
'P‘表示操作4
以下是模拟两种操作的方法

 

操作1:
 这个操作就利用了化简的思想

如果需要走，我们只需要改变当前脚的坐标

不是有搜索矩阵的题目吗，需要往上下左右四个方向搜索

我们也可以利用这种方向的思想，来定义两个数组，一个存x坐标的改变，另一个存y坐标的改变

我用的常量是operax[][]和operay[][]

因此我们可以这样利用两个数组

x+=operax[方向][操作]
y+=operay[方向][操作]
 

操作2:
很显然，操作二是一个难点

我们就利用一个函数:

huan(k,centre)//表示将第k只脚以第cntre为中心旋转90度

那怎么转呢?

首先把固定的那只脚想象成原点，别的脚都有对应的关系

举个例子，我们把固定的脚变成原点，并且假设要旋转的脚是在(1,2)

给个图片：

![](https://cdn.luogu.com.cn/upload/pic/44252.png)

这个图好像比较大，不过很清楚的看出，点是如何旋转的

设要旋转的点为(x,y)，旋转完后变成点(y,-x)

这就是旋转的方法了

下面就是各位最想要的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
using namespace std;
struct zb{
    int x,y;
}B[4];//分别表示Bessie的四个脚
//b[0]表示前左脚
//b[1]表示前右脚
//b[2]表示后左脚
//b[3]表示后右脚
int pos;//表示方向
//pos=0表示朝上
//pos=1表示朝左
//pos=2表示朝下
//pos=3表示朝右
const int operax[4][4]={//opera[pos][order],表示脚往哪个方向走多少步 
    0,0,-1,1,
    -1,1,0,0,
    0,0,1,-1,
    1,-1,0,0};
const int operay[4][4]={
    1,-1,0,0,
    0,0,-1,1,
    -1,1,0,0,
    0,0,1,-1};
char ss[5];
inline int foot(){//根据字符串判断脚 
    if(ss[0]=='F'){
        if(ss[1]=='L')return 0;
        return 1;
    }
    else{
        if(ss[1]=='L')return 2;
        return 3;
    }
}
inline int order(){//判断命令 
         if(ss[2]=='F')return 0;
    else if(ss[2]=='B')return 1;
    else if(ss[2]=='L')return 2;
    else if(ss[2]=='R')return 3;
    return 4;
}
zb n1,n2;
inline void update(){//记录左下角和右上角 
    for(int i=0;i<4;i++)
        n1.x=min(n1.x,B[i].x),
        n1.y=min(n1.y,B[i].y),
        n2.x=max(n2.x,B[i].x),
        n2.y=max(n2.y,B[i].y);
}
inline bool check(int t1){//判断是否有和t1在同位的脚 
    for(int i=0;i<4;i++)if(i!=t1)
        if(B[i].x==B[t1].x&&B[i].y==B[t1].y)
            return 0;
    return 1;
}
inline void huan(int k,int centre){//旋转函数 
    int x=B[k].x-B[centre].x;
    int y=B[k].y-B[centre].y;
    /*   if(x>=0&&y>=0)swap(x,y),y=-y;
    else if(x>=0&&y<=0)swap(x,y),y=-y;
    else if(x<=0&&y<=0)swap(x,y),y=-y;
    else               swap(x,y),y=-y;*/
    swap(x,y),y=-y;
    B[k].x=B[centre].x+x;
    B[k].y=B[centre].y+y;
}
int main(){ 
    B[0]=(zb){0,1};//脚的位置 
    B[1]=(zb){1,1};
    B[2]=(zb){0,0};
    B[3]=(zb){1,0};
    pos=0;
    n1=(zb){ 999999999, 999999999};//初始化 
    n2=(zb){-999999999,-999999999};
    int n,t1,t2;cin>>n;
    bool bk=1;
    while(n--){
        cin>>ss;
        t1=foot();t2=order();
        if(t2!=4){//两种不同的操作 
            B[t1].x+=operax[pos][t2];
            B[t1].y+=operay[pos][t2];
            if(!check(t1)){bk=0;break;}
        }
        else{
            for(int i=0;i<4;i++)if(i!=t1)
                huan(i,t1);
            pos--;if(pos==-1)pos=3;
        }
        update();
    }
    if(bk==0)printf("-1\n");
    else printf("%d\n",(n2.x-n1.x+1)*(n2.y-n1.y+1));//记得+1 
    return 0;
}
```

---

## 作者：diltraser (赞：1)

随机跳题跳到模拟题

不断模拟，前进后退向左向右都用dir加常量数组解决，右转就套初中公式，每次操作后更新最大最小值并查看是否不合法，若不合法goto wtf（输出-1并结束
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

int n;
char s[5];
const int dx[]={-1,0,1,0};
const int dy[]={0,1,0,-1};
int x[4],y[4];//FL==0,FR==1,RL==2,RR==3
int dir;
int maxx=1,minx,maxy=1,miny;

int main(){
	scanf("%d",&n);
	int i,j;
	x[0]=y[0]=x[1]=y[2]=0;
	y[1]=x[2]=x[3]=y[3]=1;
	for(i=1;i<=n;i++){
		scanf("%s",s);
		int num=0;
		if(s[0]=='R')num+=2;
		if(s[1]=='R')num+=1; 
		if(s[2]=='F'){
			x[num]+=dx[dir];
			y[num]+=dy[dir];
		}
		if(s[2]=='B'){
			x[num]-=dx[dir];
			y[num]-=dy[dir];
		}
		if(s[2]=='R'){
			int dirr=(dir+1)%4;
			x[num]+=dx[dirr];
			y[num]+=dy[dirr];
		}
		if(s[2]=='L'){
			int dirr=(dir+1)%4;
			x[num]-=dx[dirr];
			y[num]-=dy[dirr];
		}
		if(s[2]=='P'){
			for(j=0;j<4;j++)
				if(j!=num){
					int ddx=x[j]-x[num];
					int ddy=y[j]-y[num];
					x[j]=x[num]+ddy;
					y[j]=y[num]-ddx;
				}
			dir=(dir+1)%4;
		}
		for(j=0;j<4;j++){
			maxx=max(maxx,x[j]);
			minx=min(minx,x[j]);
			maxy=max(maxy,y[j]);
			miny=min(miny,y[j]);
		}
		for(j=0;j<4;j++)
			if(j!=num && x[num]==x[j] && y[num]==y[j])
				goto wtf;
		//printf("case%d: (%d,%d),(%d,%d),(%d,%d),(%d,%d)\n",
		//		i,x[0],y[0],x[1],y[1],x[2],y[2],x[3],y[3]);
	}
	printf("%d",(maxx-minx+1)*(maxy-miny+1));
	return 0;
	wtf:
	printf("-1");return 0;
}
```

---

## 作者：wangyibo201026 (赞：1)

## 本题是一道模拟水题

首先，分为两个部分：

1. 初始化。

2. 移动操作。

3. 一点细节。

注意：本题解的坐标以矩阵的行列为标准。

### 1. 初始化

第一步，初始化四只蹄子的位置：

FL 的坐标初始化为 $(0, 0)$，FR 的坐标初始化为 $(0, 1)$，RL 的坐标初始化为 $(1, 0)$，RR 的坐标初始化为 $(1, 1)$。

则开一个数组，存储每只蹄子的位置，可以方便一点。

第二步，给操作和蹄子编号：

将四只蹄子分别按照一二三四的顺序编号（蹄子的编号顺序自己定），写一个函数，也会方便一点。

随后，**只将** F，B，R，L 操作按照顺序编号，P 操作后面会单独处理。

第三步，维护最小最大的蹄子位置：

由于要求舞台的大小，所以得每次维护最小的坐标和最大的坐标（建议使用结构体），最后才能求出舞台的大小，所以只要设为 $10^9$ 和 $- 10^9$ 就可以了。

### 2. 移动操作

移动操作又分为两个部分：

1. 上下左右。

2. 旋转。

第一部分，上下左右：

此时只要利用要移动的蹄子进行操作即可，顺便判断一下有没有蹄子重复和维护坐标最小值和最大值即可。

第二部分，旋转：

首先，推导旋转前与旋转后的坐标关系。

请看以下这幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/g2ljevx4.png)

其中我们假设现在被旋转点绕标准点**顺时针**旋转 $90$ 度，画的两个三角形是辅助图形，则可以得出各条边（只有辅助边）的长度和各个点的坐标（根据边的长度得到坐标）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gwbayaah.png)

此时，清晰的发现，坐标为 $(x, y)$ 的点，顺时针旋转 $90$ 度后的坐标为 $(x + y' - y, y + x - x')$。

现在，就可以直接套公式了，这时不要判蹄子在一个格子里，因为是不可能两个蹄子在同一个格子里的，这一点可以自己动手推导。

### 3. 一点细节

1. 我们可以利用循环节来建造一个方向数组，方便一点。

2. 建一个变量，来维护 Bessie 的朝向，旋转时改变方向即可。

3. 利用结构体，避免代码过长。

4. 利用函数嵌套，代码有清晰性。

## 代码

以下是蒟蒻的代码，过长勿喷，亲测 AC：

```cpp
//奶牛芭蕾，原地址：http://www.usaco.org/index.php?page=viewproblem2&cpid=278

#include<bits/stdc++.h>

using namespace std;

const int dy[5] = {0, 1, 0, -1};
const int dx[5] = {-1, 0, 1, 0};   //方向数组节省代码量

int n, f = 0;    //f 表示方向，0 表示朝北，2 表示朝南，3 表示朝西，1 表示朝东

struct node{
	int x;
	int y;
}_1, _2, p[5];    //_1 表示最左上角的蹄子，_2 表示最右下角的蹄子，p[] 表示维护四个蹄子的位置

//表示旋转中的操作
void P(int id){
	f++;
	f %= 4;    //改变朝向
	for(int i = 0; i < 4; i++){
		int t1 = p[id].x + p[i].y - p[id].y;    //用 t1, t2 来维护旋转后的新位置
		int t2 = p[id].y + p[id].x - p[i].x;
		p[i].x = t1;
		p[i].y = t2;
		_1.x = min(_1.x, p[i].x);
		_1.y = min(_1.y, p[i].y);
		_2.x = max(_2.x, p[i].x);
		_2.y = max(_2.y, p[i].y);    //维护最小左上角和最大右下角
	}
}

//检查移动的位置有没有另外的蹄子
bool Check(int id, int x){
	p[id].x = p[id].x + dx[(x + f) % 4];
	p[id].y = p[id].y + dy[(x + f) % 4];    //%4 表示存在一个循环节
	for(int i = 0; i < 4; i++){
		_1.x = min(_1.x, p[i].x);
		_1.y = min(_1.y, p[i].y);
		_2.x = max(_2.x, p[i].x);
		_2.y = max(_2.y, p[i].y);   //时刻维护
		if(i != id){
			if(p[id].x == p[i].x && p[id].y == p[i].y){    //如果绊倒了
				return false;
			}
		}
	}
	return true;
}

//获取蹄子编号的函数
int R(string s){
	if(s == "FL"){
		return 0;
	}
	if(s == "FR"){
		return 1;
	}
	if(s == "RL"){
		return 2;
	}
	if(s == "RR"){
		return 3;
	}
	//按照编号 return
}

//转化字符编号，按照上下左右的顺序
int D(char x){
	if(x == 'F'){
		return 0;
	}
	if(x == 'B'){
		return 2;
	}
	if(x == 'L'){
		return 3;
	}
	if(x == 'R'){
		return 1;
	}
}

//帮助操作四个蹄子
void help(){
	string s;
	cin >> s;
	int id = R(s.substr(0, 2));    //id 表示操作蹄子的编号,R() 为获取编号的函数
	char tmp = s[2];   //x 表示操作符号
	//操作区分为两个部分，带旋转和不带旋转
	if(tmp != 'P'){
		int xy = D(tmp);   //将字符转化成编号，由 D() 完成
		if(!Check(id, xy)){   //Check() 检查移动的位置有没有另外的蹄子
			cout << -1;
			exit(0);
		}
	}
	else{
		P(id);   //P() 表示旋转中的操作
	}
}

int main(){
	freopen("test.in", "r", stdin);
	freopen("test.out", "w", stdout);
	_1.x = _1.y = 1e9;
	_2.x = _2.y = -1e9;
	_1.x = min(p[0].x, min(p[1].x, min(p[2].x, p[3].x)));
	_1.y = min(p[0].y, min(p[1].y, min(p[2].y, p[3].y)));
	_2.x = max(p[0].x, max(p[1].x, max(p[2].x, p[3].x)));
	_2.y = max(p[0].y, max(p[1].y, max(p[2].y, p[3].y)));
	p[0].x = 0, p[0].y = 0;    //分别按照前左蹄，前右蹄，后左蹄，后右蹄的顺序排列
	p[1].x = 0, p[1].y = 1;
	p[2].x = 1, p[2].y = 0;
	p[3].x = 1, p[3].y = 1;
	cin >> n;
	for(int i = 1; i <= n; i++){
		help();   //帮助操作四个蹄子
	}
	cout << (_2.x - _1.x + 1) * (_2.y - _1.y + 1);    //输出矩形大小
	return 0;
}
```


---

## 作者：违规用户名S42u&!u& (赞：1)

**蒟蒻的第一篇题解不知该怎么写管理大大求通过qwq**

~~这道题似乎是一个大模拟~~,代码意思写在注释里了

```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
struct node{//结构体存储每个脚的位置
	int x,y;
}p[4],v[2];
int n;
int f(string s){//返回要移动的教的编号
	if(s=="FL")
		return 0;
	if(s=="FR")
		return 1;
	if(s=="RL")
		return 2;
	return 3;
}
int d(char c){//返回往那移
	if(c=='F')
		return 0;
	if(c=='R')
		return 1;
	if(c=='B')
		return 2;
	return 3;
}
bool c(int id){//检查是否有蹄子在一起
	for(int i=0;i<4;i++)
		if(i!=id&&p[i].x==p[id].x&&p[i].y==p[id].y)
			return 0;
	return 1;
}
void u(){//扩大边界
	for(int i=0;i<4;i++){
		v[0].x=min(v[0].x,p[i].x);
		v[0].y=min(v[0].y,p[i].y);
		v[1].x=max(v[1].x,p[i].x);
		v[1].y=max(v[1].y,p[i].y);
	}
	return ;
}
void r(int id){//旋转
	for(int i=0;i<4;i++){
		int t1=p[id].x+p[i].y-p[id].y;
		int t2=p[id].y+p[id].x-p[i].x;
		p[i].x=t1;
		p[i].y=t2;
	}
	return ;
}

int main(){
	cin>>n;
	p[0].x=0,p[0].y=0;//预处理蹄子位置
	p[1].x=0,p[1].y=1;
	p[2].x=1,p[2].y=0;
	p[3].x=1,p[3].y=1;
	v[0].x=INT_MAX,v[0].y=INT_MAX;//预处理边界
	v[1].x=INT_MIN,v[1].y=INT_MIN;
	int dir=0;
	for(int i=0;i<n;i++){//循环枚举每条指令
		string s;
		cin>>s;
		int id=f(s.substr(0,2));//是哪个蹄子
		if(s[2]!='P'){
			int dd=(d(s[2])+dir)%4;
			p[id].x+=dx[dd];
			p[id].y+=dy[dd];
			if(!c(id)){//如果有蹄子在一起输出-1
				cout<<-1;
				return 0;
			}
		}
		else{//旋转
			r(id);
			dir=(dir+1)%4;
		}
		u();//扩大边界
	}
	cout<<(v[1].x-v[0].x+1)*(v[1].y-v[0].y+1);//输出面积
	return 0;//好习惯
}
```

---

## 作者：mouseboy (赞：0)

[原题传送门(P2206)](https://www.luogu.com.cn/problem/P2206)


~~本蒟蒻第一次写题解有点紧张~~



题目大意：
给定一些指令，计算需要多大的舞台。

# 这是一道大模拟！！！

只要遍历每次指令，然后判断是否摔倒，摔倒输出`-1`否则记录，最后求出面积就行了。

小二，上代码！
```cpp
#include <bits/stdc++.h>
using namespace std;
const int xx[] = {-1, 0, 1, 0}, yy[] = {0, 1, 0, -1};//不同方向的x,y移动数量
struct node {
  int y, x;
} a[] = {{114514, 1919810}, {0, 0}, {0, 1}, {1, 0}, {1, 1}};//记录四只脚的位置
int fx, miny = INT_MAX, minx = INT_MAX, maxy = INT_MIN, maxx = INT_MIN, n;
bool flag = 1;
string s;
int help(string s) {
  int f = 1;//记录是那只脚
  if (s[0] == 'F' && s[1] == 'R') {
    f = 2;
  } else if (s[0] == 'R') {
    if (s[1] == 'L') {
      f = 3;
    } else {
      f = 4;
    }
  }
  if (s[2] == 'P') {
    for (int i = 1; i <= 4; i++) {
      int ny = a[f].y + a[i].x - a[f].x;
      int nx = a[f].x + a[f].y - a[i].y;
      a[i].y = ny, a[i].x = nx;
    }
    fx = (fx + 1) % 4;//记录方向（模4可保证不RE）
  } else {
    int m = 0;
    if (s[2] == 'R') {
      m = 1;
    }
    if (s[2] == 'B') {
      m = 2;
    }
    if (s[2] == 'L') {
      m = 3;
    }
    m = (m + fx) % 4;//记录方向（模4可保证不RE）
    a[f].y += xx[m];
    a[f].x += yy[m];//记录坐标
    for (int i = 1; i <= 4; i++) {
      if (f != i && a[f].y == a[i].y && a[f].x == a[i].x) {//判断是否会摔倒
        return 0;//返回不行
      }
    }
  }
  for (int i = 1; i <= 4; i++) {
    miny = min(miny, a[i].y);
    maxy = max(maxy, a[i].y);
    minx = min(minx, a[i].x);
    maxx = max(maxx, a[i].x);//取最大值与最小值
  }
  return 1;//返回可以
}
int main() {
  //freopen("ballet.in", "r", stdin);CSP-J
  //freopen("ballet.out", "w", stdout);备战紧张
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> s;
    if (!(flag = help(s))) {//判断可行性
      break;
    }
  }
  if (flag) {//判断并输出
    cout << (maxy - miny + 1) * (maxx - minx + 1);//计算面积
  } else {
    cout << -1;
  }
  return 0;//华丽的结束
}
```
管理员大大求过

在这祝大家CSP-J2022++RP！

---

## 作者：走开啊你 (赞：0)

# 【题目思路】
就是模拟奶牛跳舞的过程，主要要注意顺时针旋转90度的处理，还是每条指令执行过程中每只脚的位置，还有奶牛的朝向。题目不难，细心就好。

1.每次脚移动到新位置，判断是否需要扩大舞台范围

2.每次完成一次动作判断四个脚的位置是否有重复，有则直接输出-1

3.针对动作不同采取不同的处理方法，标记好方向，前进后退左移右移可以确定，旋转再单独处理。

 _上代码_ 
 ```pascal
var ch:char;
    n,i,x,y,z,l,x1,x2,y1,y2,l1,l2,l3,l4,l5,l6:longint;
    a:array[1..2,1..2,1..2] of longint;
    p:array[1..5] of longint=(1,3,2,4,5);
    e:array[1..4,1..2] of longint=((-1,0),(0,1),(1,0),(0,-1));
procedure sc;
var i,j,k,l:longint;
begin
  for i:=1 to 2 do
    for j:=1 to 2 do
      for k:=1 to 2 do
        for l:=1 to 2 do
          if not ((i=k) and (j=l)) then
              if (a[i,j,1]=a[k,l,1]) and (a[i,j,2]=a[k,l,2]) then
                begin writeln(-1); halt; end;
end;
procedure sk(x,y:longint);
begin
  if x>x1 then x1:=x;
  if x<x2 then x2:=x;
  if y>y1 then y1:=y;
  if y<y2 then y2:=y;
end;
procedure sv(var x1,y1,x2,y2,x3,y3,x4,y4:longint);
var x:longint;
begin
  x:=x2; x2:=(y2-y1)+x1; y2:=y1-(x-x1); sk(x2,y2);
  x:=x3; x3:=(y3-y1)+x1; y3:=y1-(x-x1); sk(x3,y3);
  x:=x4; x4:=(y4-y1)+x1; y4:=y1-(x-x1); sk(x4,y4);
end;
begin
  assign(input,'ballet.in');assign(output,'ballet.out');
  reset(input);rewrite(output);
  readln(n);
  a[1,1,1]:=0; a[1,1,2]:=0;
  a[1,2,1]:=0; a[1,2,2]:=1;
  a[2,1,1]:=1; a[2,1,2]:=0;
  a[2,2,1]:=1; a[2,2,2]:=1;
  x1:=1; x2:=0;
  y1:=1; y2:=0;
  for i:=1 to n do
    begin
    read(ch); if ch='F' then x:=1 else x:=2;
    read(ch); if ch='L' then y:=1 else y:=2;
    readln(ch); z:=5; case ch of 'F':z:=1; 'B':z:=2; 'R':z:=3; 'L':z:=4; end;
    z:=p[z];
    if z=5 then
      begin
      l:=l mod 4+1;
      if (x=1) and (y=1) then begin l1:=1; l2:=2; l3:=2; l4:=1; l5:=2; l6:=2; end
      else if (x=1) and (y=2) then begin l1:=1; l2:=1; l3:=2; l4:=1; l5:=2; l6:=2; end
      else if (x=2) and (y=1) then begin l1:=1; l2:=1; l3:=1; l4:=2; l5:=2; l6:=2; end
      else begin l1:=1; l2:=1; l3:=1; l4:=2; l5:=2; l6:=1; end;
      sv(a[x,y,1],a[x,y,2],a[l1,l2,1],a[l1,l2,2],a[l3,l4,1],a[l3,l4,2],a[l5,l6,1],a[l5,l6,2]);
      end
    else
      begin
      z:=(z+l-1) mod 4+1;
      a[x,y,1]:=a[x,y,1]+e[z,1];
      a[x,y,2]:=a[x,y,2]+e[z,2];
      sk(a[x,y,1],a[x,y,2]);
      end;
    sc;
    end;
  writeln((x1-x2+1)*(y1-y2+1));
  close(input);close(output);
end.
```

大神勿喷，这是不尊重他人的行为！！！） 完结撒花~(≧▽≦)/~啦啦啦

---


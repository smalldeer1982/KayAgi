# yyy 棋

## 题目描述

uim 最近在研究一种游戏，叫做“ yyy 棋”。

这种游戏的规则很简单，就是有一个 $A \times B$ 的棋盘和黑白两色的棋子，两个人轮流在下在格子里面。你可以下黑棋或者白棋，中途可以更换颜色，可以下在任何你喜欢的地方，但是要符合以下条件：

1. 这个位置不能已经被别的棋子占用。

2. 你准备下的地方，上下左右一格范围中不能有和你准备下的颜色一样的棋子。

3. 第一个下的人必须出黑子。


当谁没有地方可以放子，谁就输了。


uim 把你拉了出来，希望你好好地陪他玩。

由于你很忙不太情愿，uim 就让步了，允许你选择先手或者后手。


你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。感觉有点类似，所以，你打算借鉴这个办法。

你知道，通过某种策略，你一定是 $100\%$ 赢的。

既然如此，就让 uim 输个痛快吧。

## 说明/提示

$40\%$ 数据，$2 \le A, B \le 3$。

$100\%$ 数据，$2 \le A, B \le 9$。

然而作为月赛的第一题，自然是简单的。因为标程的核心代码只有 $6$ 行。并不需要使用什么复杂算法就可以得到答案。


## 样例 #1

### 输入

```
2 2
1 2 1
1 1 1```

### 输出

```
Second
2 1 0
Buwanle```

# 题解

## 作者：Zhou_yu (赞：6)

## 题目描述：
### [P2361题目传送门](https://www.luogu.com.cn/problem/P2361)
## 算法思路：
一道必胜策略好题。

应对方法：

须知：以下式子中 $A$ 为长， $B$ 为宽。
1. 如果**有中心点**，己方先手，下中心点。

（通俗讲，如果**长宽都是奇数**，自己先手下 $(A/2+1,B/2+1)$ 位置）

2. 下对手**中心对称**的位置，举个~~栗~~例子，如果对手下 $(x,y)$，我们就下在 $(A-x+1,B-y+1)$。

（通俗讲，**粘着对手下！**）

位置问题解决了，但是颜色该怎么办呢？

#### 1. 考虑长宽都是奇数：
奇数不会出现 $(x,y)$ 在 $(A-x+1,B-y+1)$ 旁边，所以下的颜色跟对手一样。

#### 2. 考虑长或宽有偶数：
偶数会出现 $(x,y)$ 在 $(A-x+1,B-y+1)$ 旁边，所以反着对手的颜色下。

（举个例子，$A=3,B=2,x=2,y=1$，要下的是：$(2,2)$，在对手下面）

## 蒟蒻のAC代码
[AC记录](https://www.luogu.com.cn/record/114044398)

```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b;
struct node
{
	bool is_full=0;//有没有被下过
	int color=-1;//什么颜色
	bool can_be_1=1;//可以下黑棋
	bool can_be_0=1;//可以下白棋
}f[10][10];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
void out()
{
	cout<<"Buwanle";
	exit(0);
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>a>>b;
	int t=0,flag=1;
	if(a%2)t++;
	if(b%2)t++;
   //t作用是看长宽是否都是奇数
	if(t==2)cout<<"First";
	else
	{
		cout<<"Second";
		flag=0;
	}
	cout<<'\n';
	if(t==2)
	{
    //都是奇数的话先手，下中心点
		cout<<a/2+1<<' '<<b/2+1<<' '<<1<<'\n';
		for(int i=0;i<4;i++)
		{
			int tx=dx[i]+a/2+1;
			int ty=dy[i]+b/2+1;
			if(tx<1||ty<1||tx>a||ty>b)continue;
			f[tx][ty].can_be_1=0;
		}
	}
	int x,y,c;
	while(cin>>x>>y>>c)
	{
		
		if(f[x][y].is_full)out();//已被下过
		if(c==1&&f[x][y].can_be_1==0)out();//不可以下黑棋却下黑棋
		if(c==0&&f[x][y].can_be_0==0)out();//不可以下白棋却下白棋
		f[x][y].is_full=1;
		f[x][y].color=c;
		for(int i=0;i<4;i++)
		{
			int tx=dx[i]+x;
			int ty=dy[i]+y;
			if(tx<1||ty<1||tx>a||ty>b)continue;
			if(c==1)f[tx][ty].can_be_1=0;
			else f[tx][ty].can_be_0=0;
		}//给上下左右附上不可以下同样颜色
		int will_color=c;
		if(!flag)
		{
			if(c==1)will_color=0;
			else will_color=1;
		}//看需要下什么颜色
		int will_choose_x=a-x+1;
		int will_choose_y=b-y+1;
   		//中心对称
		cout<<will_choose_x<<' '<<will_choose_y<<' '<<will_color<<'\n';
     		//粘着对手下
		for(int i=0;i<4;i++)
		{
			int tx=dx[i]+will_choose_x;
			int ty=dy[i]+will_choose_y;
			if(tx<1||ty<1||tx>a||ty>b)continue;
			if(will_color==1)f[tx][ty].can_be_1=0;
			else f[tx][ty].can_be_0=0;
		}//给上下左右附上不可以下同样颜色
	}
	return 0;
}
```
## 总结：
遇事不决，小学数学！



---

## 作者：小恐 (赞：4)

~~这道可怜的题好像只有几篇远古时期的题解，于是我就来发一篇~~

作为一个刚刚毕业的初一学生，一不小心看到了这题，深感熟悉。~~然鹅我都快把必胜策略那一讲忘光了QWQ~~

说正事：这道题就是对称，对称就是对手干什么你就跟着干什么，这题就是他选一个点染色你就选和那个点对称的点染色，也就是如果他选$(x,y)$，你就染$(A-x+1,B-y+1)$。

明显如果$A$和$B$都是奇数，则有一个中间的点，那个点的对称点就是它自己，所以如果$A$和$B$都是奇数，那你就选先手，把那个点干了，否则如果队手占了那个点，那他就有必胜策略了。否则你选后手，他怎么下咱都有对策。

知道下哪个点了，可是下什么颜色呢？kkk说$A$和$B$都是奇数时，选颜色一样的，我们举个$3\times 3$的栗子（白色用红色代替）：
![](https://cdn.luogu.com.cn/upload/image_hosting/ft6vpoiy.png)
首先你选了中间的格，题目要求染黑：
![](https://cdn.luogu.com.cn/upload/image_hosting/hnti96db.png)
结果对手选了$(1,2)$染成了白
![](https://cdn.luogu.com.cn/upload/image_hosting/kqfneb6i.png)
如果你对称过去染黑，那你就违规了，所以这时要染颜色一样的。

那当$A$和$B$不全是奇数时会怎样呢？那我们再举个$2\times 3$的栗子：
![](https://cdn.luogu.com.cn/upload/image_hosting/e781n6hq.png)
对手选了$(1,2)$染成了白
![](https://cdn.luogu.com.cn/upload/image_hosting/lrv5cpkh.png)
你对称是如果染成相同的那你又违规了，所以要染成不同的。

综上，如果$A$和$B$都是奇数，染相同的，否则染不同的。

话不多说，上代码：
```cpp
#include<stdio.h>
using namespace std;
char a[15][15];
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
int m,n,x,y,c,tx,ty;
bool read(int &s)
{
	s=0;
	int bei=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch==EOF)
			return 0;
		if(ch=='-')
			bei=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		s=s*10+ch-'0';
		ch=getchar();
	}
	s*=bei;
	return 1;
}
int main()
{
    bool ji;
	read(m),read(n);
	if((m*n)%2)
		printf("First\n%d %d 1\n",(m+1)/2,(n+1)/2),ji=1;
	else
		printf("Second\n"),ji=0;
	while(read(x)&&read(y)&&read(c))
	{
		if(x>m||x<1||y>n||y<1)
		{
			printf("Buwanle");
			break;
		}
		bool flag=1;
		for(int i=0;i<4;++i)
		{
			tx=dx[i]+x,ty=dy[i]+y;
			if(a[tx][ty]=='a'+c)
			{
				flag=0;
				break;
			}
		}
		if(!flag)
		{
			printf("Buwanle");
			break;
		}
		a[x][y]='a'+c;
		a[m-x+1][n-y+1]='a'+c;
		if(ji)
		    printf("%d %d %d\n",m-x+1,n-y+1,c),a[m-x+1][n-y+1]='a'+c;
		else
		    printf("%d %d %d\n",m-x+1,n-y+1,1-c),a[m-x+1][n-y+1]='a'+1-c;
	}
	return 0;
}
```


---

## 作者：Drystynt (赞：3)

题目已经说的很清楚了，我们特别是要注意这一句话：

> 你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。

我们就知道了：我们应当先手，把黑棋放在最中心处，对方出什么子我们就对称放置即可。

**然而，本题只能放在格子里面！** 也就是说，如果棋盘不是奇数×奇数的，它就没有中心格！

这个时候，你就应该下后手。对方出什么子我们还是对称放置即可。

至于颜色，只需看旁边棋子的颜色即可。因为奇数×奇数的棋盘有中心块，只需与对方染颜色一样的。否则染不一样的，因为没有中心块，对称的方格有可能相连。

于是代码就出来了：

```cpp
#include <bits/stdc++.h>
using namespace std;
int p[11][11];
bool f;//判断中心块是否存在
void Buwanle()
{
	cout<<"Buwanle"<<endl;
	exit(0);//注意，一定要发exit(0)!!!
}
int fan(int c)
{
	if(c)	return 1;
	else return 2;
}
int main()
{
	int a,b;
	cin>>a>>b;
	if(a%2==1 && b%2==1) f=true,cout<<"First"<<endl;
	else f=false,cout<<"Second"<<endl;
	if(f)
		printf("%d %d 1\n",(a+1)/2,(b+1)/2),p[(a+1)/2][(b+1)/2]=1;
	int k1,k2,c;//坐标与颜色
	while(cin>>k1>>k2>>c)
	{
		if(p[k1][k2])	Buwanle();
		else if(p[k1-1][k2]==fan(c)||p[k1+1][k2]==fan(c)||p[k1][k2-1]==fan(c)||p[k1][k2+1]==fan(c))
			Buwanle();		
		else
		{
			p[k1][k2]=2-c;
			if(f)
			{
				printf("%d %d %d\n",a+1-k1,b+1-k2,c),p[a+1-k1][b+1-k2]=2-c;
			}
			else
			{
				printf("%d %d %d\n",a+1-k1,b+1-k2,1-c),p[a+1-k1][b+1-k2]=c+1;
			}
		}
	}
	return 0;
} 
```

---

## 作者：封禁用户 (赞：2)

# 题目描述

[yyy 棋](https://www.luogu.com.cn/problem/P2361)

# 算法思路

### 文中重点

你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。感觉有点类似，所以，你打算借鉴这个办法。

### 思路

可以想到通过对称的下法，不难发现，当 $A$ 和 $B$ 均为奇数，我们首先要先下中心点，因为中心点没有与它对称的点，不然的话我们只需跟着 uim 走，下 uim 的对称点（关于中心对称），如果 uim 犯规，直接输出 Buwanle 并结束程序。

当 $A$ 和 $B$ 均为奇数，我们先下中心点，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/5pfiqnzx.png)

当 uim 下棋之后，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/gyqlqw9b.png)

如果我们和 uim 下的棋子颜色相同，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/q6t1ufh2.png)

该方案可行。

如果我们和 uim 下的棋子颜色不同，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/itwzak2y.png)

该方案不可行。

否则 uim 先下，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/ib3ozgfv.png)

如果我们和 uim 下的棋子颜色相同，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/bgg2q6cz.png)

该方案不可行。

如果我们和 uim 下的棋子颜色不同，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/b32lgux6.png)

该方案可行。

所以当 $A$ 和 $B$ 均为奇数，只要和 uim 下的棋子颜色相同即可，否则和 uim 下的棋子颜色不同。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//日常开long long
struct st//定义存储结构体
{
	ll x,y,z;
};
const ll N=110,INF=0x3f3f3f3f3f3f3f3f;//INF是无限大
ll n,m,k,x,y,z,d[4][2]={{-1,0},{0,-1},{1,0},{0,1}},dx,dy,tu[N][N];
//d数组存储方向
//tu数组0表示白子，1表示黑子，无限大表示没有棋子
st a[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	memset(tu,0x3f,sizeof(tu));//一开始没有棋子
	cin>>n>>m;
	while(cin>>x>>y>>z)//输入uim下的棋子
	{
		a[++k]={x,y,z};
	}
	if(n%2&&m%2)//如果棋盘是奇数 ×奇数，则选择先下
	{
		cout<<"First\n";
		dx=n/2+1;
		dy=n/2+1;
		cout<<dx<<" "<<dy<<" "<<"1\n";
		tu[dx][dy]=1;//先下中心点
		for(int i=1;i<=k;i++)
		{
			if(tu[a[i].x][a[i].y]!=INF)//当前位置有棋子了
			{
				cout<<"Buwanle\n";//uim耍赖
				return 0;
			}
			for(int j=0;j<4;j++)
			{
				if(tu[a[i].x+d[j][0]][a[i].y+d[j][1]]==a[i].z)
				//如果上下左右和中间颜色相同
				{
					cout<<"Buwanle\n";//uim耍赖
					return 0;
				}
			}
			tu[a[i].x][a[i].y]=a[i].z;
			dx=n-a[i].x+1;
			dy=m-a[i].y+1;
			cout<<dx<<" "<<dy<<" "<<a[i].z<<"\n";
			tu[dx][dy]=a[i].z;//下与uim下的点按中心点对称的位置
		}
	}
	else//否则选择后下
	{
		cout<<"Second\n";
		for(int i=1;i<=k;i++)
		{
			if(tu[a[i].x][a[i].y]!=INF)//当前位置有棋子了
			{
				cout<<"Buwanle\n";//uim耍赖
				return 0;
			}
			for(int j=0;j<4;j++)
			{
				if(tu[a[i].x+d[j][0]][a[i].y+d[j][1]]==a[i].z)
				//如果上下左右和中间颜色相同
				{
					cout<<"Buwanle\n";//uim耍赖
					return 0;
				}
			}
			tu[a[i].x][a[i].y]=a[i].z;
			dx=n-a[i].x+1;
			dy=m-a[i].y+1;
			cout<<dx<<" "<<dy<<" "<<!a[i].z<<"\n";
			tu[dx][dy]=!a[i].z;//下与uim下的点按中心点对称的位置，颜色相反
		}
	}
    return 0;
}
```
## 结论

### 遇事不决，小学数学。

---

## 作者：Miyamizu_Mitsuha (赞：1)

不知道大家下过围棋没有，里面有一个套路就是模仿棋。

黑棋（先手）的策略就是先下中间（由于棋盘长宽都为奇数），然后对手下什么就下中心对称的点，当然这是有破解方法的，在这道题独特的规则下无法破解，就不说了。

现在把这个思路用到这道题里，简单来说就是对手下哪就下中心对称的点，他下的地方是合法的那你下的地方也一定是合法的，如果他不能下了那你也不能下了，但是当他不能下的时候你就已经赢了。

在上面的思路中，我们总是希望 uim 先走，然后再模仿他的。所以需要讨论一下，就是这个棋盘有没有中心点（长宽是否都为奇数）。如果有中心点，那么就选先手，先下中心点（中心点的对称点就是自己），然后他下在哪你就下对称点就好了。如果没有中心点，那么就选后手，他下哪你就对下对称点。

位置我们确定好了，颜色也不是什么难事。当有中心点时，我们下的颜色要和对手一样，由于有中心点的保护我们无需担心同色撞上，如果总归要撞了那么一定是轮到 uim 了（上文说过）。况且如果对手第一步下在了中心点旁边，那么你模仿时如果下异色的话就和中心点撞色违规了，所以有中心点就下同色，必胜。

如果没有中心点呢？那我们就需要和对手下相反的颜色。要不然你可能开局就违规了。然后一直保持对称性，还是那样，如果总归要撞了那么一定是轮到 uim 了。必胜。


---

## 作者：koreyoshi_lemon (赞：1)

题目很友好的给了我们提示。

两人轮流放硬币，谁先放不下谁输。这启示我们根据棋盘格子的奇偶来分类讨论。

首先拿奇数来说，如果不考虑颜色不能一样的限制，显然是先手必胜的。如果考虑颜色，就添加了一小点技术含量。我们把第一颗棋子放在正中间，然后每一次都猥琐下在对手中心对称的位置，他下什么颜色我们学什么。这样只要他没有犯规，我们也不可能犯规。这样做，就能保证先手必胜。

对于偶数而言，如果不考虑颜色限制，其实是先手必败的。我们同样下在和对手中心对称的位置。不同的是我们此时应该选择与对手相反的颜色。这样做，就能保证后手必胜。

下面解释如此选择颜色的原因。

当两颗棋子相离很远时，不管怎么取都没有影响。主要应该考虑两颗棋子靠近对称中心的情况：

```cpp
/* 
奇数： 
|					|			|					|
|	对手白	|	黑	|	相同白	|
|					|			|					|
偶数： 
|				|						|
|	对手	|	只能不同	|
|				|						|

*/
```

但是为了保持颜色的一致性（你不能说一会儿和对手相同，一会儿和对手不同，结果对手没犯规，自己先犯规了），

贴代码。。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+7;
int n,m;
int v[N][N];
inline bool judge(int x,int y,int z)	{
	if(v[x][y]!=-1) return true;
	if(v[x+1][y]==z) return true;
	if(v[x-1][y]==z) return true;
	if(v[x][y-1]==z) return true;
	if(v[x][y+1]==z) return true;
	return false;
}
inline int cal(int k)	{
	if(m*n&1)	return k;
	return k^1;
}
int main(void)
{
	memset(v,-1,sizeof(v));
	scanf("%d%d",&n,&m);
	if(n*m&1)	{
		printf("First\n");
		printf("%d %d %d\n",n+1>>1,m+1>>1,1);
	}
	else printf("Second\n");
	int x,y,z;
	while(cin>>x>>y>>z)	{
		if(judge(x,y,z))	{
			printf("Buwanle\n");
			return 0;
		}
		v[x][y]=z;
		v[n+1-x][m+1-y]=cal(z);
		printf("%d %d %d\n",n+1-x,m+1-y,v[n+1-x][m+1-y]);
	}
	return 0;
}
```

---

## 作者：帝千秋丶梦尘 (赞：1)

## ~~蒟蒻又来水题解了~~

[没看过题的先看题（总会有不看题目先看题解的童鞋的）](https://www.luogu.com.cn/problem/P2361)

这道题如果你先看到了kkk的题解，那么你已经会做了吧

# 终
###### （但是这样管理员肯定不会给我过的）

so，题解go：

大伙都知道这道题考你是不是个知道必胜策略的~~必胜客~~

个人建议：最基础的例如普通取石子，跳房子之类的必胜策略题一定要知道，但是

别的关于必胜策略的题也要多做，~~不要像我一样一遇到必胜策略就卡几十分钟~~

大伙都知道，必胜策略最好的方法就是

# 				——————~~%你~~（模拟）

所以这道题也一样（终于回到正题

位置：对称就好，你就对称对手（若有一个中心店就先手放中心点，然后就黏他）

颜色：这也好证的，只要弄一个比较小的图模拟一下，长宽改一改，使得对称时两

点的位置相连（有时你会发现不可能相连），所以可以推出颜色求法

# 什么？你问我为什么不证一遍？

### 其实我有一个对这个命题的十分美妙的证明,这里空白太小,我写不下了

			————————————————by 帝千秋丶费马
      
            
话不多说，up代码（bb一句，Buwanle是个好人，不会耍赖）：

```
#include<bits/stdc++.h>//习惯万能头，是个不好的坏习惯
using namespace std;
int a,b,x,y,c,vis[13][13],flag;
int main(void)
{
	memset(vis,0,sizeof(vis));//清空，好习惯
	scanf("%d%d",&a,&b);
	if(a*b%2==0)
	{
		flag=1;
		printf("Second\n");
	}
	else{
		flag=2;
		printf("First\n");
		printf("%d %d 1\n",int(ceil(a*1.0/2)),int(ceil(b*1.0/2)));
		vis[int(ceil(a*1.0/2))][int(ceil(b*1.0/2))]=2;
	}//上面说过的判断先手后手，注意先手要输出
	while(cin>>x>>y>>c)
	{
		vis[x][y]=c+1;
		if(flag==1)
		{
			if(c==0)
			{
				vis[a-x+1][b-y+1]=2;
				printf("%d %d 1\n",a-x+1,b-y+1);
			}
			else if(c==1)
			{
				vis[a-x+1][b-y+1]=1;
				printf("%d %d 0\n",a-x+1,b-y+1);
			}
		}//后手
		if(flag==2)
		{
			vis[a-x+1][b-y+1]=c+1;
			printf("%d %d %d\n",a-x+1,b-y+1,c);
		}//先手
	}
}
```

## 各位看官走好( ^_^ )/~~拜拜

---

## 作者：_smart_stupid_ (赞：0)

# yyy棋


题目：懒得写了，自己去看。

思路：他下 $(x,y)$ ,我们就要下在 $(A-x+1,B-y+1)$ 的地方。

### 然后还有一个值得注意的地方：

如果棋盘的长宽都是奇数，则我们要先手抢占最中间的一个格子，不然就会 ~~爆炸~~ 被 uim 抢占到，则他就有优胜策略；否则，我们就下后手，他怎么下我们都有对策，我们还是有优胜策略。

#### 那么，我们该下什么颜色的棋子呢？

举个例子，棋盘长 $3$ 宽 $3$，长宽都是奇数，我们先手，在中间下一个黑子：

空 空 空

空 黑 空

空 空 空

我们假设他在 $(1,2)$ 的位置下一颗白子：

空 白 空

空 黑 空

空 空 空

我们就要在 $(3-1+1,3-2+1)$ 也就是 $(3,2)$ 的位置下子，如果和他下不同的子，我们就会违规，所以我们要和他下相同颜色的棋子。

#### 那长宽不是奇数呢？

那我们假设棋盘长 $2$ 宽 $2$，拿样例举例：

他在 $(1,2)$ 的位置下一颗黑子：

空 黑

空 空

我们就要根据策略在 $(2,1)$ 的位置落子，样例中落白子，所以我们要和他落不同颜色的子。

话不多说，上代码：
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a,b;
int x,y,c;
int celue;
char qipan[10][10];//开int初始值为0，白子也是0，不方便
int main(){
	cin>>a>>b;
        //制定策略
	if(a%2&&b%2){
		celue=0;
	}
	else{
		celue=1;
	}
	if(!celue) {
		cout<<"First"<<endl<<(a+1)/2<<" "<<(b+1)/2<<" "<<1<<endl;
		qipan[(a+1)/2][(b+1)/2]=1+'a';
	}
	else cout<<"Second"<<endl;
	while(cin>>x>>y>>c){
		if(x>a||x<1||y>b||y<1)
		{
			cout<<"Buwanle"<<endl;
			return 0;
		}
                //判断他是否违规
		if(qipan[x-1][y]==c+'a'||qipan[x][y-1]==c+'a'||qipan[x][y+1]==c+'a'||qipan[x+1][y]==c+'a'){
			cout<<"Buwanle"<<endl;
			return 0;
		}
		qipan[x][y]=c+'a';
		if(celue){
		  cout<<a-x+1<<" "<<b-y+1<<" "<<1-c<<endl;
			qipan[a-x+1][b-y+1]=1-c+'a';
		}
		else{
			cout<<a-x+1<<" "<<b-y+1<<" "<<c<<endl;
			qipan[a-x+1][b-y+1]=c+'a';
		}  
	}
	return 0;
}
```

---


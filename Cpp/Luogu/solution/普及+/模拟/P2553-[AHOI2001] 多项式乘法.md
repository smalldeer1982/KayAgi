# [AHOI2001] 多项式乘法

## 题目描述

请编程序把含有乘法运算的代数多项式表达式改写成不含乘法的代数多项式。为简化计算，特做以下约定：

1. 代数多项式表达式中只涉及一个代数符号 `a`；
2. 保证输入的「含乘法运算的代数多项式」有且仅有一个「代数多项式」与「代数多项式」的乘法。形式化地讲，每一个测试点的输入数据中，一定有且仅有一行 `(...)*(...)`，其中 `...` 为不含乘法运算的代数多项式。
3. 一个「不含乘法运算的代数多项式」会被写作 `XXXa^YYY+XXXa^YYY+XXXa^YYY+...+XXX`（代表 $\text{XXX}a ^ \text{YYY} + \text{XXX}a ^ \text{YYY} + \text{XXX}a ^ \text{YYY} + \cdots + \text{XXX}$），其中 `XXX`、`YYY` 均为正整数，且保证除第一项外每一项的 `YYY` 比上一项的 `YYY` 少 $1$。例如，一个合法的「不含乘法运算的代数多项式」为 `142a^4+9a^3+4a^2+1a^1+3`。

> 对于约定 3，原题目给予了这样一个表述：常数项以外的各项都是 $xa^y$ 的形式，写作 `xa^y`，其中 $x$ 为该项的系数，而 $y$ 是该项的指数。$x = 1$ 时，不得简写成 `a^y`，应写成 `1a^y`。而 $y = 1$ 时，不得简写成 `xa`，应写成 `xa^1`。

## 说明/提示

关于数据范围以及数据若干格式的说明：

* 系数范围和指数范围均为 $[0,30]$。

## 样例 #1

### 输入

```
(5a^2+3a^1+2)*(4a^1+1)
(5a^1+1)* (5a^1+1)```

### 输出

```
20a^3+17a^2+11a^1+2
25a^2+10a^1+1```

# 题解

## 作者：Dispwnl (赞：8)

看到题第一眼，就知道这是个暴力处理多项式然后用fft搞就行了。。。

但是有许多坑点，比如输入字符串中没有'*'就什么也不输出~~题目就™不能讲清楚吗~~

因为这个WA了好几次，又因为只有一个数据点，每次都提示输出多了，我也看不了别人代码对一下。。。

最后在网上找了一个博客，试了几组数据都正确~~并且ta还不能处理没有括号的情况~~

看到ta的代码中有一行：
```
if(ppos == std::string::npos) continue;
```
![](http://a-failure.github.io/img/675.jpg)
这是干啥啊大兄弟。。。似乎是判断有没有'*'？

然后加上就过了。。。这种~~垃圾~~题还是别出了QAQ

代码：
```cpp
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cmath>
using namespace std;
const int MAX=1e6+1;
const double Pi=acos(-1.0);
struct complex{
	double x,y;
	complex(double X=0,double Y=0){x=X,y=Y;}
}a[2][MAX];
int n,m,l,lim=1;
int r[MAX],len[MAX],ans[MAX];
complex operator+ (complex x,complex y)
{
	return complex(x.x+y.x,x.y+y.y);
}
complex operator- (complex x,complex y)
{
	return complex(x.x-y.x,x.y-y.y);
}
complex operator* (complex x,complex y)
{
	return complex(x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x);
}
void fft(complex *A,int tt)
{
	for(int i=0;i<lim;++i)
	  if(i<r[i]) swap(A[i],A[r[i]]);
	for(int i=1;i<lim;i<<=1)
	  {
	  	complex w1(cos(Pi/i),tt*sin(Pi/i));
		for(int l=i<<1,j=0;j<lim;j+=l)
		  {
	  		complex w(1,0);
	  		for(int k=0;k<i;++k,w=w*w1)
	  		  {
	  		  	complex x=A[j+k],y=w*A[j+i+k];
	  		  	A[j+k]=x+y,A[j+i+k]=x-y;
			  }
	  	  }
	  }
	if(tt==-1)
	for(int i=0;i<lim;++i)
	  A[i].x=(int)(A[i].x/lim+0.5);
}
int main()
{
	string s;
	while(getline(cin,s))
	{
		bool fl=0;
		int L=s.length(),num=0;
		for(int i=0;i<L;++i)
		  if(s[i]=='*')
		  {
		  	fl=1;
		  	break;
		  }
		if(!fl) continue;
		memset(a,0,sizeof(a));
		memset(len,0,sizeof(len));
		memset(ans,0,sizeof(ans));
		for(int i=0,tt=0;i<L;i+=tt)
		  {
		  	tt=0;
		  	int x=0;
		  	if(isdigit(s[i]))
			{
				int j=i;
		  		while(isdigit(s[j])) ++tt,x=x*10+s[j++]-48;
		  		while(s[j]==' ') ++j;
		  		if(s[j]=='a')
		  		{
		  			j+=2,tt+=2;
		  			int y=0;
		  			while(isdigit(s[j])) ++tt,y=y*10+s[j++]-48;
		  			len[num]=max(len[num],y);
					a[fl][y].x+=x;
				}
				else if(s[j]=='+'||s[j]==')'||s[j]=='*'||j==L) a[fl][0].x+=x;
			}
			if(s[i]=='*'||i+(tt?tt:1)-1==L-1)
			{
				if(s[i]=='*') ++tt;
				if(num>=1)
				{
					lim=1,l=0;
					memset(r,0,sizeof(r));
					while(lim<=len[num]+len[num-1]) lim<<=1,++l;
					for(int j=0;j<lim;++j)
					  r[j]=(r[j>>1]>>1)|((j&1)<<(l-1));
					fft(a[fl],1),fft(a[fl^1],1);
					for(int j=0;j<=lim;++j)
					  a[fl][j]=a[fl][j]*a[fl^1][j];
					fft(a[fl],-1);
					for(int j=0;j<=lim;++j)
					  a[fl][j].y=a[fl^1][j].y=a[fl^1][j].x=0;
					len[num]=len[num]+len[num-1];
				}
				++num,fl^=1;
			}
			if(!tt) ++tt;
		  }
		bool gg=0;
		for(int j=0;j<=len[num]+len[num-1];++j)
		  {
		  	ans[j]+=a[fl^1][j].x;
		  	if(a[fl^1][j].x!=0) gg=1;
		  }
		if(!gg)
		{
			printf("0\n");
			continue;
		}
		int Len1=0,Len2=0;
		for(int i=0;!ans[i];++i)
		  ++Len1;
		Len2=Len1;
		for(int i=Len1+1;ans[i]!=0;++i)
		  ++Len2;
		if(Len2!=Len1) printf("%da^%d",ans[Len2],Len2);
		for(int i=Len2-1;i>Len1;--i)
		  printf("+%da^%d",ans[i],i);
		if(!Len1)
		{
			if(Len2) printf("+%d\n",ans[0]);
			else printf("%d\n",ans[0]);
		}
		else
		{
			if(Len2!=Len1) printf("+%da^%d\n",ans[Len1],Len1);
			else printf("%da^%d\n",ans[Len1],Len1);
		}
	}
	return 0;
}
```

---

## 作者：vocaloid (赞：6)

$\text{FFT}$+字符串处理。$\text{FFT}$没有什么好说的，主要是讲一下怎么处理读入的字符串。

本来以为 `scanf` 做这题完全没问题，但是被样例的第二组数据卡到了，中间有一个空格，所以改成了 `getline`。虽然 `getline` 有时候有毒，但功能确实强大。

 > 注：下文的“指针”指遍历字符串数组时的循环变量。

读入字符串后照例从头开始往后，如果找到一个数字，那么它肯定是 $x$ ，也就是系数，此时我们用**读入优化**时的方式将指针往后移，并把它存下来，然后此时指针指向的位置应该是 $x$ 的最后一个字符，判断下个位置的字符是不是 `'a'` ，如果是的话意味着我们刚才存的 $x$ 是这一项的系数，而我们将指针后移 $3$ 位，分别经过 $x$ 的最后一位、`'a'` 和 `'^'` ，到达这一项的次数 $y$ 的第一位，依然使用**读入优化**的方式存下 $y$ 。此时记录一下是应该放到 $f$ 中还是 $g$ 中，然后放进去，即 $f[y].x=x$ 或 $g[y].x=x$ 即可。

存下之后，如果正好第二次经过 `')'`，意味着这个多项式结束了（因为保证一组多项式只有一个 `'*'`），照例跑 $\text{FFT}$ 即可，输出也不难，不再赘述。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct Complex
{
	double x,y;
	friend Complex operator + (Complex a,Complex b)
	{
		return (Complex){a.x+b.x,a.y+b.y};
	}
	friend Complex operator - (Complex a,Complex b)
	{
		return (Complex){a.x-b.x,a.y-b.y};
	}
	friend Complex operator * (Complex a,Complex b)
	{
		return (Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
	}
}f[1000005],g[1000005];
const double Pi=acos(-1.0);
int n,m,maxn,L,R[1000005],ans[1000005];
string s;
void FFT(Complex *x,int Type)
{
	for(int i=0;i<maxn;i++) if(i<R[i]) swap(x[i],x[R[i]]);
	for(int i=1;i<maxn;i<<=1)
	{
		Complex W=(Complex){cos(Pi/i),Type*sin(Pi/i)};
		for(int j=0;j<maxn;j+=(i<<1))
		{
			Complex w=(Complex){1,0};
			for(int k=0;k<i;k++)
			{
				Complex a=x[j+k],b=w*x[i+j+k];
				x[j+k]=a+b;
				x[i+j+k]=a-b;
				w=W*w;
			}
		}
	}
}
void CalcWithFFT()
{
	n+=m;
	maxn=1;
	while(maxn<=n)
	{
		maxn<<=1;
		L++;
	}
	for(int i=0;i<maxn;i++) R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));
	FFT(f,1);
	FFT(g,1);
	for(int i=0;i<maxn;i++) f[i]=f[i]*g[i];
	FFT(f,-1);
	bool fg=0;
	for(int i=n;i>=0;i--)
	{
		ll x=(ll)(f[i].x/maxn+0.5);
		if(x)
		{
			if(!fg) fg=1;
			else printf("+");
			if(i) printf("%llda^%d",x,i);
			else printf("%lld\n",x);
		}
	}
}
int main()
{
	while(getline(cin,s))
	{
		L=n=m=0;
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		bool fg=0;
		int len=s.size();
		for(int i=0;i<len;i++)
		{
			if(isdigit(s[i]))
			{
				int x=0;
				while(isdigit(s[i]))
				{
					x=(x<<3)+(x<<1)+(s[i]-48);
					i++;
				}
				i--;
				int y=0;
				if(s[i+1]=='a')
				{
					i+=3;// a + ^ + num
					while(isdigit(s[i]))
					{
						y=(y<<3)+(y<<1)+(s[i]-48);
						i++;
					}
					i--;
				}
				if(!fg)
				{
					n=max(n,y);
					f[y].x=x;
				}
				else
				{
					m=max(m,y);
					g[y].x=x;
				}
			}
			else if(s[i]==')')
			{
				fg^=1;
				if(!fg) CalcWithFFT();
			}
		}
	}
	return 0;
}
```

---

## 作者：徐致远 (赞：4)



### 广告

[戳我呀QwQ](https://www.chnxuzhiyuan.cn/2019/03/04/%E3%80%8CAHOI2001%E3%80%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95-Solution/)

### 题解

好久没写这种处理字符串的大模拟了QwQ。

这题每个多项式的长度都很短，系数也很小，所以直接$O(n^2)$的暴力搞过去就行了。

数据范围大一点的话FFT即可。

注意可能有空格。

注意可能在一行中可能包含一个不完整的表达式（可能没有"*"或者"()"），注意应该什么也不要输出，也要注意不要RE或者怎么样了。

总而言之还是挺好写的QwQ。

### 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int len,a1[50],a2[50],ans[100];char exp[1000];
int main()
{
	while(gets(exp),exp[0])
	{
		len=strlen(exp);memset(a1,0,sizeof(a1));memset(a2,0,sizeof(a2));memset(ans,0,sizeof(ans));
		int i=1;
		while(exp[i]!=')'&&i<len)
		{
			int x=0,z=0;
			while(exp[i]<'0'||exp[i]>'9') i++;
			x=exp[i]-'0';
			if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;x=x*10+exp[i]-'0';}
			i++;
			if(exp[i]=='a')
			{
				i++;i++;z=exp[i]-'0';
				if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;z=z*10+exp[i]-'0';}
				i++;
			}
			a1[z]+=x;
		}
		i++;
		while(exp[i]!=')'&&i<len)
		{
			int x=0,z=0;
			while(exp[i]<'0'||exp[i]>'9') i++;
			x=exp[i]-'0';
			if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;x=x*10+exp[i]-'0';}
			i++;
			if(exp[i]=='a')
			{
				i++;i++;z=exp[i]-'0';
				if('0'<=exp[i+1]&&exp[i+1]<='9'){i++;z=z*10+exp[i]-'0';}
				i++;
			}
			a2[z]+=x;
		}
		for(int i=0;i<=30;i++)
			for(int j=0;j<=30;j++)
				ans[i+j]+=a1[i]*a2[j];
		bool first=false;
		for(int j=60;j>=0;j--)
		{
			if(!ans[j]) continue;
			if(first) putchar('+');
			else first=true;
			if(j>0) printf("%da^%d",ans[j],j);
			else printf("%d",ans[j]);
		}
		putchar('\n');
		memset(exp,0,sizeof(exp));
	}
	return 0;
}
```



---

## 作者：Trick_t (赞：2)

搞不懂泥萌为什么要用$FFT$，看数据范围指数和系数范围都是$[0,30]$，直接处理出各项系数然后$n^2$乘就好了，用$FFT$的话因为常数原因还比不上暴力。

~~由于在while中的边界问题还RE了好多次，以为数据范围是假的~~
```cpp
#include<complex>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=101;
int a[N],b[N],c[N];
char s[N*N];
int main()
{
	while(scanf("%s",s)!=EOF)
	{
		bool f=0;int len=strlen(s),n=0,m=0;
		for(int i=0;i<len;)
		{
			int x=0,y=0;
			while(i<len && s[i]<'0' || s[i]>'9'){if(s[i]==')')f=1;i++;}
			if(i>=len)break;
			while(s[i]>='0' && s[i]<='9'){x=x*10+s[i]-'0';i++;}
			if(s[i]!='a')
			{
				if(!f)a[y]=x;
				else b[y]=x;
				continue;
			}
			i+=2;
			while(s[i]>='0' && s[i]<='9'){y=y*10+s[i]-'0';i++;}
			if(f)b[y]=x,m=max(m,y);
			else a[y]=x,n=max(n,y);
		}
		memset(c,0,sizeof(c));
		for(int i=0;i<=n;i++)
			for(int j=0;j<=m;j++)
				c[i+j]+=a[i]*b[j];
		for(int i=n+m;i>=0;i--)
		{
			if(i!=n+m)putchar('+');
			printf("%d",c[i]);
			if(i)printf("a^%d",i);
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：GNAQ (赞：2)

其实只有一组 `*`

然后找一下 `*` 在哪就可以了

剩下全是 NTT 板子，没啥可讲的。提取部分看代码吧，实现的挺清楚的。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#define ll long long
using namespace std;

const ll mod=998244353;

template<typename int_t>
void readx(int_t& x)
{
	x=0; int_t k=1; char ch=0;
	while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
	while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	x*=k;
}

ll fastpow(ll an,ll p)
{
	ll ret=1;
	for (;p;p>>=1,an=an*an%mod) if (p&1) ret=ret*an%mod;
	return ret%mod;
}

namespace FFT
{
	const ll G=3;
	const ll iG=fastpow(3,mod-2);
	
	ll revf,revt,rev[10010];
	template<typename poly_arr>
	void BtFl(poly_arr y[],ll len)
	{
		if (len!=revf)
		{
			revf=len; revt=-1; ll tmp=1;
			while (tmp<len) { tmp<<=1; revt++; }
			for (int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<revt);
		}
		for (int i=0;i<len;i++) if (i<rev[i]) swap(y[i],y[rev[i]]);
	}
	
	void FFT(ll y[],ll len,ll dd)
	{
		BtFl(y,len);
		for (int i=1;i<len;i<<=1)
		{
			ll wn=fastpow((dd==1?G:iG),(mod-1)/(i<<1));
			for (int j=0;j<len;j+=(i<<1))
			{
				ll w=1;
				for (int k=0;k<i;k++,w=w*wn%mod)
				{
					ll t1=y[j+k],t2=y[i+j+k]*w%mod;
					y[j+k]=(t1+t2)%mod;
					y[i+j+k]=(t1-t2+mod)%mod;
				}
			}
		}
		if (dd==-1) 
		{
			ll inv=fastpow(len,mod-2);
			for (int i=0;i<len;i++) y[i]=(y[i]*inv)%mod;
		}
	}
	
	void Mul(ll A[],ll B[],ll la,ll lb)
	{
		ll len=1;
		while (len<=(la+lb)) len<<=1;
		FFT(A,len,1); FFT(B,len,1);
		for (int i=0;i<len;i++) A[i]=A[i]*B[i]%mod;
		FFT(A,len,-1);
	}
};

string str;
ll Ai[10010],Bi[10010];
ll Ar,Br;

void Extract(string& st,ll l,ll r,ll y[],ll& rk)
{
	ll ep=0,an=0; 
	for (int i=l;i<=r;i++)
	{
		if ((st[i]<'0' || st[i]>'9') && st[i]!='^' && st[i]!='a' && st[i]!='+') continue;
		else if (st[i]=='+') { ep=an=0; }
		else
		{
			while (st[i]>='0' && st[i]<='9' && i<=r) { an=an*10+st[i]-'0'; i++; }
			if (st[i]=='a')
			{
				while (st[i]<'0' || st[i]>'9' && i<=r) i++;
				while (st[i]>='0' && st[i]<='9' && i<=r) { ep=ep*10+st[i]-'0'; i++; }
				rk=max(rk,ep);
			}
			i--;
			y[ep]=an;
		}
	}
}

void Process(string& st)
{
	ll len=st.length(),pos=0; Ar=Br=0;
	memset(Ai,0,sizeof Ai); memset(Bi,0,sizeof Bi); 
	
	for (int i=0;i<len;i++) if (st[i]=='*') pos=i;
	
	Extract(st,0,pos-1,Ai,Ar); Extract(st,pos+1,len-1,Bi,Br);
	FFT::Mul(Ai,Bi,Ar,Br);
	
	for (int i=Ar+Br;i>=0;i--) if (Ai[i])
	{
		printf("%lld",Ai[i]);
		if (i!=0) printf("a^%d+",i);
	}
	putchar('\n');
}

int main()
{
	while (getline(cin,str)) Process(str);
}
```

---

## 作者：This_Rrhar (赞：1)

两个多项式相乘，显然用 FFT/NTT，我用的是 FFT。

关于 FFT 可左转 [P3803 【模板】多项式乘法（FFT）](https://www.luogu.com.cn/problem/P3803)。

此题主要还是字符串处理问题。

对于输入的一个代数式 $s$，可以用一个布尔变量 $f$ 记录乘号是否出现过。我们从前往后读入所有的整式，如果 $f=0$，则存入第一个多项式中，反之则存入第二个多项式中。

读入完毕后，若 $f$ 仍为 $0$，则说明没有乘法，直接输出原式，反之则计算用 FFT 计算两个多项式的卷积，最后再输出。

最后记得清空数组。

AC Code 如下（C++20）：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=int;

#define N 50
#define siz(x) (int(x.size()))

const double pi=acos(-1);
struct cmplex
{
	double x,y;
	void destroy(){x=0,y=0;}
	cmplex(double x=0,double y=0):x(x),y(y){}
	cmplex operator+(cmplex B){return{x+B.x,y+B.y};}
	cmplex operator-(cmplex B){return{x-B.x,y-B.y};}
	cmplex operator*(cmplex B){return{x*B.x-y*B.y,x*B.y+y*B.x};}
	cmplex operator/(cmplex B)
	{
		double t=B.x*B.x+B.y*B.y;
		return{(x*B.x+y*B.y)/t,(x*B.x-y*B.y)/t};
	}
	cmplex operator+=(cmplex B){return*this=*this+B;}
	cmplex operator-=(cmplex B){return*this=*this-B;}
	cmplex operator*=(cmplex B){return*this=*this*B;}
	cmplex operator/=(cmplex B){return*this=*this/B;}
}F[N<<1],G[N<<1];

ll dp[N<<1];
ll n,m,t;
bool f;

void FFT(cmplex*f,double sig)
{
	for(int i=0;i<n;i++)if(i<dp[i])swap(f[i],f[dp[i]]);
	for(int i=2;i<=n;i<<=1)
	{
		cmplex w(cos(pi*2/i),sin(pi*2/i));
		ll j=i>>1;
		w.y*=sig;
		for(int k=0;k<n;k+=i)
		{
			cmplex t(1,0);
			for(int l=k;l<j+k;l++)
			{
				cmplex p=t*f[j+l];
				f[j+l]=f[l]-p,f[l]+=p,t*=w;
			}
		}
	}
}

string s;

int main()
{
	while(getline(cin,s))
	{
		for(int i=0;i<N<<1;i++)F[i].destroy(),G[i].destroy();
		n=m=t=0,f=false,memset(dp,0,sizeof(dp));
		for(int i=0;i<siz(s);i++)
		{
			if(isdigit(s[i]))
			{
				int x=0,y=0;
				while(isdigit(s[i]))x=x*10+s[i++]-'0';
				if(s[i]=='a')
				{
					i+=2;
					while(isdigit(s[i]))y=y*10+s[i++]-'0';
				}
				if(!f)F[y].x=x,n=max(n,y);
				else G[y].x=x,m=max(m,y);
			}
			else if(s[i]=='*')f=true;
		}
		if(!f)cout<<s<<"\n";
		else
		{
			for(m+=n,n=1;n<=m;n<<=1);
			for(int i=0;i<n;i++)dp[i]=(dp[i>>1]>>1)|((i&1)?n>>1:0);
			FFT(F,1),FFT(G,1);
			for(int i=0;i<n;i++)F[i]*=G[i];
			FFT(F,-1),f=false;
			for(int i=m;i>=0;i--)
			{
				t=ll(F[i].x/n+0.5);
				if(t)
				{
					if(f)printf("+");
					printf("%d",t),f=true;
					if(i)printf("a^%d",i);
				}
			}
			printf("\n");
		}
	}
}
```

---

## 作者：Suzt_ilymtics (赞：1)

~~我感觉输入输出难度占整道题的 80%~~

### Solution

题目意思非常简单，就是给你两个多项式，输出他们相乘的结果。

发现系数和指数的范围 $\le 30$，所以转化出来爆算即可，计算公式如下：

$$x_1a^{y_1} \times x_2a^{y_2} = x_1x_2a^{y_1 + y_2}$$

~~当然为了练习 NTT 我用了 NTT。~~

关键在于如何把一个字符串转化成我们想要的，

这里介绍一种读入方式：`scanf("%[^\n]", s)`

它的作用是读入一行，遇到 `\n` 停止，也就是说会读入空格，**但是不读入 `\n`**。更加详细的解释可以参考 [this](https://www.cnblogs.com/AlvinZH/p/6798023.html)

对于没有退出标志的多组数据读入来说可以这样写：

```cpp
while(~scanf("%[^\n]", s)) {
    getchar();
    // do everything you want...
}
```

对于每个字符串，一个方便的做法是把他们扣出来扔进数组里。至于怎么扣出来直接去模拟即可，这里不详细展开。

实现细节可以参考我的代码

```cpp
/*
Work by: Suzt_ilymtics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 998244353;
const int G = 3, G_inv = 332748118;

int n;
char s[MAXN];
int a[MAXN], b[MAXN], r[MAXN];
int stc[MAXN], sc = 0;
int Stc[MAXN], top = 0;

int read() {
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0', ch = getchar();
    return f ? -s : s;
}

int Pow(int x, int p) {
    int res = 1;
    while(p) {
        if(p & 1) res = res * x % mod;
        x = x * x % mod, p >>= 1;
    }
    return res;
}

void NTT(int *a, int lim, int type) {
    for(int i = 0; i < lim; ++i) if(i < r[i]) swap(a[i], a[r[i]]);
    for(int mid = 1; mid < lim; mid <<= 1) {
        int Wn = Pow(type == 1 ? G : G_inv, (mod - 1) / (mid << 1));
        for(int j = 0; j < lim; j += (mid << 1)) {
            for(int k = 0, w = 1, x, y; k < mid; ++k, w = w * Wn % mod) {
                x = a[j + k], y = w * a[j + k + mid] % mod;
                a[j + k] = (x + y) % mod, a[j + k + mid] = (x - y + mod) % mod;
            }
        }
    }
    if(type == 1) return ;
    int lim_inv = Pow(lim, mod - 2);
    for(int i = 0; i < lim; ++i) a[i] = a[i] * lim_inv % mod;
}

signed main()
{
    while(~scanf("%[^\n]", s + 1)) {
        getchar();
        n = strlen(s + 1);
        int wz = 0, n1 = 0, n2 = 0, lim = 1, L = 0;
        memset(a, false, sizeof a);
        memset(b, false, sizeof b);
        for(int i = 1; i <= n; ++i) if(s[i] == '*') wz = i;
        if(!wz) for(int i = 1; i <= n; ++i) if(s[i] != ' ') printf("%c", s[i]);
        for(int i = 1, res = 0; i < wz; ++i) {
            if(isdigit(s[i])) {
                res = res * 10 + s[i] - '0';
            } else {
                if(s[i] == 'a') {
                    int p = 0, j = i + 2;
                    for(; j < wz; ++j) if(isdigit(s[j])) p = p * 10 + s[j] - '0'; else break;
                    a[p] = res;
                    n1 = max(n1, p);
                    i = j, res = 0;
                } else {
                    a[0] = max(a[0], res);
                    res = 0;
                }
            }
        }
        for(int i = wz + 1, res = 0; i <= n; ++i) {
            if(isdigit(s[i])) {
                res = res * 10 + s[i] - '0';
            } else {
                if(s[i] == 'a') {
                    int p = 0, j = i + 2;
                    for(; j <= n; ++j) if(isdigit(s[j])) p = p * 10 + s[j] - '0'; else break;
                    b[p] = res;
                    n2 = max(n2, p);
                    i = j, res = 0;
                } else {
                    b[0] = max(b[0], res);
                    res = 0;
                }
            }
        }
        while(lim <= (n1 + n2)) lim <<= 1, ++L;
        for(int i = 0; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));
        NTT(a, lim, 1), NTT(b, lim, 1);
        for(int i = 0; i < lim; ++i) a[i] = a[i] * b[i] % mod;
        NTT(a, lim, -1);
        for(int i = n1 + n2; i >= 0; --i) {
            if(!a[i]) continue;
            if(i != n1 + n2) printf("+");
            printf("%d", a[i]);
            if(i != 0) printf("a^%d", i);
        }
        puts("");
    }
    return 0;
}
```

---

## 作者：Exschawasion (赞：1)

本题主要考查的是字符串处理。

***

题目有**多组数据**，每一组数据都是一个多项式或者一个多项式乘法。为了方便，下文统称“表达式”。

因为在表达式中可能存在空格，所以直接在字符串里递归要处理的细节会比较多，而我们就采取逐字符处理的方式计算。根据题目所说，**只会存在一个** `*` **号**，因此考虑分左右半边处理。

如果要对这个表达式进行计算，必然要分离出每一个项，这些项包含系数与指数，是解题所需要的。如果舍去常数项（即 `2a^2+5` 中的 `5`），不难发现，每个项被 `a^` 这两个字符分成了系数与指数两部分，如下图所示：

![](https://i.bmp.ovh/imgs/2022/01/220d960b3d958b6d.png)

利用好这个特征就不难分离系数和指数。

接下来加入对常数项的处理。常数项与非常数项最大的区别就在于**数字后面紧跟着的字符是否是字母**，也就是说，读入一个数字之后，可以判断一下其后面的字符是否为 `a`，如果是则为非常数项，否则为常数项。

这就是逐字符处理的难点，但是还要注意一些细节：

- 当读入乘号 $*$ 的时候，说明已经由左半边到了右半边。这可以使用一个标志变量来解决；
- **不需要**读入其他的符号，比如加号 $+$ 和括号。因为本题只会出现两个多项式相乘，并且多项式内部一定不会出现乘法，判断 $*$ 已经足够分辨左右半边；
- 对于每一个表达式，要重置上一个表达式遗留下来的无效数据。

当分离出了系数和指数之后，就可以进行卷积了。本题的数据范围是 $n \leq 30$，数据很小，暴力卷积也可以通过此题。

（虽然数据小，但是不知道表达式的数量有多少，为了避免可能的超时，还是采用了 FFT。）

关于 FFT 的算法介绍有很多，在这里就不展开详细讲述了，可以到[【P3803 】](https://www.luogu.com.cn/problem/P3803)进行相关练习。主要精力将会集中在如何处理输入串上，完整代码请到[剪贴板](https://www.luogu.com.cn/paste/4syjwduo)查看：

```

int main() {
	string s;
	int x = 0, y = 0;
	bool side = false;
	while(getline(cin, s)) {
		n = m = 0;
		side = false; // side 为 false 表示左边，反之为右
		memset(f, 0, sizeof(f));
		memset(p, 0, sizeof(p));
		for(int i = 0; i < s.length(); i++) {
			x = 0, y = 0;
			if(isdigit(s[i])) { // 发现数字
				while(isdigit(s[i])) { // 一直读入数字，读到不是数字为止
					x = x * 10 + (s[i++] - '0'); // 转化为数字
				}
				if(s[i] == 'a') { // 发现下面一个字符为字母，说明是非常数项
					i++; i++; // 跳过 'a' 和 '^' 
					while(isdigit(s[i])) { // 同理，一直读入指数
						y = y * 10 + (s[i++] - '0');
					}
					i--; // 由于现在 s[i] 是第一个非数字字符，需要回退来方便下一次处理
				}
				if(!side) {
					n = max(n, y);
					f[y].x += x; // 可能存在没有同类项合并的情况
				}
				else {
					m = max(m, y);
					p[y].x += x;
				}
			}
			else if(s[i] == '*') { // 发现乘号，左边转移到右边
				side = true;
			}
		}
		run(); // 执行 FFT 函数并且输出，详细见剪贴板
	}
	return 0;
}

```

最后，这份代码是经过了三次重构后的最终 AC 代码，所以大家写代码的时候一定要有一颗持之以恒的心~

求通过~



---

## 作者：star_magic_young (赞：1)

这题就是~~普及暴力模拟板子~~FFT板子,只要把多项式读入进来FFT一下就好了(不会的右转P3803)

重点是读入,~~我本以为这个字符串里到处都有空格,~~这里提供一种简单思路:

因为里面可能有空格,所以用while和scanf读入连续的一段字符,如果读到数字就把这个系数(以及*可能*有的a的次数)抠出来,放在对应的多项式里

如果读到`)`,如果这是第奇数个,那么后面的系数放到第二个多项式里,否则进行FFT并输出,并且让后面的系数放到第一个多项式里

注意多组数据要清空某些变量,数组

把读入函数单独拿出来看一下

```cpp
//cc为字符串,a,b分别存两个多项式
bool f=0;
while(scanf("%s",cc)!=-1)
  {
	int len=strlen(cc);
	for(int i=0;i<len;++i)
	  {
		if(cc[i]>='0'&&cc[i]<='9')
		  {
			int x=0,y=0;
			while(cc[i]>='0'&&cc[i]<='9') x=(x<<3)+(x<<1)+(cc[i]^48),++i;
			--i;
			if(cc[i+1]=='a')
			  {
				++i,++i,++i;
				while(cc[i]>='0'&&cc[i]<='9') y=(y<<3)+(y<<1)+(cc[i]^48),++i;
				--i;
			  }
			if(!f) n=max(n,y),a[y].r=x;
			else m=max(m,y),b[y].r=x;
		  }
		else if(cc[i]==')')
		  {
			f^=1;
			if(!f) work();
		  }
	  }
  }

```

下面是完整代码
```cpp
#include<bits/stdc++.h>
#define LL long long
#define db double
#define il inline
#define re register
  
using namespace std;
const int N=100000+10,M=270000+10;
const db pi=acos(-1);
il int rd()
{
  int x=0,w=1;char ch=0;
  while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
  while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
  return x*w;
}
struct comp
{
  db r,i;
  comp(){r=i=0;}
  comp(db nr,db ni){r=nr,i=ni;}
  il comp operator + (const comp &bb) const {return comp(r+bb.r,i+bb.i);}
  il comp operator - (const comp &bb) const {return comp(r-bb.r,i-bb.i);}
  il comp operator * (const comp &bb) const {return comp(r*bb.r-i*bb.i,r*bb.i+i*bb.r);}
}a[M],b[M];
int n,m,nn,l,rdr[M];
void fft(comp *a,int op)
{
  comp W,w,x,y;
  for(int i=0;i<nn;++i) if(i<rdr[i]) swap(a[i],a[rdr[i]]);
  for(int i=1;i<nn;i<<=1)
    {
      W=comp(cos(pi/i),sin(pi/i)*op);
      for(int j=0;j<nn;j+=i<<1)
        {
          w=comp(1,0);
          for(int k=0;k<i;++k,w=w*W)
            {
              x=a[j+k],y=w*a[j+k+i];
              a[j+k]=x+y,a[j+k+i]=x-y;
            }
        }
    }
}
il void work()
{
  m+=n;
  for(nn=1;nn<=m;nn<<=1) ++l;
  for(int i=0;i<nn;++i) rdr[i]=(rdr[i>>1]>>1)|((i&1)<<(l-1));
  fft(a,1),fft(b,1);
  for(int i=0;i<nn;++i) a[i]=a[i]*b[i];
  fft(a,-1);
  for(int i=m,z=0;i>=0;--i)
	{
	  LL x=(LL)(fabs(a[i].r)/nn+0.5);
	  if(x)
		{
		  if(!z) z=1;
		  else putchar('+');
		  if(i) printf("%llda^%d",x,i);
		  else printf("%lld",x);
		}
	}
  putchar('\n');
  memset(a,0,sizeof(a)),memset(b,0,sizeof(b)),l=n=m=0;
}
char cc[N];
  
int main()
{
  bool f=0;
  while(scanf("%s",cc)!=-1)
	{
	  int len=strlen(cc);
	  for(int i=0;i<len;++i)
		{
		  if(cc[i]>='0'&&cc[i]<='9')
			{
			  int x=0,y=0;
			  while(cc[i]>='0'&&cc[i]<='9') x=(x<<3)+(x<<1)+(cc[i]^48),++i;
			  --i;
			  if(cc[i+1]=='a')
				{
				  ++i,++i,++i;
				  while(cc[i]>='0'&&cc[i]<='9') y=(y<<3)+(y<<1)+(cc[i]^48),++i;
				  --i;
				}
			  if(!f) n=max(n,y),a[y].r=x;
			  else m=max(m,y),b[y].r=x;
			}
		  else if(cc[i]==')')
			{
			  f^=1;
			  if(!f) work();
			}
		}
	}
  return 0;
}
```

---

## 作者：iotang (赞：1)

作为一个社区贡献0分的人，我感觉很难受

---

诶没有NTT的题解诶

那我在这里补一篇吧

---

很明显的，这一题是想让你把很多的多项式乘起来。

为了维护这道题是个省选题的尊严，我们在这里使用比较快速的多项式乘法方法，比如**FFT**和**NTT**。

我们也可以发现，这一题的重点在于**读入**和**蒙数据范围**。(-_-||)

关于读入，在这里提供一个识别一个不带乘号的代数多项式的可以忽略冗余字符的代码。

```cpp
int polyExtractor(string s,lint to[],int tosize)
{
    register int i,c,switchs=0,l;
    register lint buf[2]={0},mx=0;
    s="("+s+")";
    memset(to,0,sizeof(lint)*tosize);
    for(i=0,l=s.length();i<l;i++)
    {
        c=s[i];
        if(c=='+' || c=='(' || c==')')
            mx=max(mx,buf[1]),to[buf[1]]+=buf[0],switchs=0,buf[0]=buf[1]=0;
        if(c=='+')buf[0]=1,buf[1]=0,switchs=0;
        else if(isalpha(c) || c=='^')switchs=1;
        else if(isdigit(c))
        {
            buf[switchs]=c-48,c=s[++i];
            while(isdigit(c))buf[switchs]=buf[switchs]*10+c-48,c=s[++i];
            i--;
        }
    }
    return mx;
}
```

关于数据范围，因为我们要充满信仰，所以就把数组大小开到允许的最大值就行了。(不过好像数据水到暴力都能过)

如果想学NTT和FFT的可以看看[这个](https://www.cnblogs.com/candy99/p/6641972.html)。

然后下面这个是完整代码。

我已经尽量的把代码写的条理清楚了...

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long lint;

const int _ = 999999 , mo = 998244353 , gmo = 3 , igmo = 332748118;

inline lint powa(lint a,lint t)
{
    register lint b=1;
    while(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}
    return b;
}
inline lint inv(lint a){return powa(a,mo-2);}

int rev[_];
void ntt(int n,lint A[],int dir)
{
    register int i,j,k;
    register lint x,y,w,wn;
    for(i=0;i<n;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
    for(i=1;i<n;i<<=1)
        for(j=0,w=powa(dir>0?gmo:igmo,(mo-1)/(i+i));j<n;j+=i+i)
            for(k=0,wn=1;k<i;k++,wn=w*wn%mo)
                x=A[j+k],y=wn*A[j+k+i]%mo,A[j+k]=(x+y)%mo,A[j+k+i]=(x-y+mo)%mo;
    if(dir<0)for(i=0,x=inv(n);i<n;i++)A[i]=A[i]*x%mo;
}
int NTT(int na,lint A[],int nb,lint B[],lint S[])
{
    register int i,nn=1,l=0;
    while(nn<na+nb)nn<<=1,l++;
    for(i=1,rev[0]=0;i<nn;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
    ntt(nn,A,1),ntt(nn,B,1);
    for(i=0;i<nn;i++)S[i]=A[i]*B[i]%mo;
    ntt(nn,A,-1),ntt(nn,B,-1),ntt(nn,S,-1);
    return nn;
}

int polyExtractor(string s,lint to[],int tosize)
{
    register int i,c,switchs=0,l;
    register lint buf[2]={0},mx=0;
    s="("+s+")";
    memset(to,0,sizeof(lint)*tosize);
    for(i=0,l=s.length();i<l;i++)
    {
        c=s[i];
        if(c=='+' || c=='(' || c==')')
            mx=max(mx,buf[1]),to[buf[1]]+=buf[0],switchs=0,buf[0]=buf[1]=0;
        if(c=='+')buf[0]=1,buf[1]=0,switchs=0;
        else if(isalpha(c) || c=='^')switchs=1;
        else if(isdigit(c))
        {
            buf[switchs]=c-48,c=s[++i];
            while(isdigit(c))buf[switchs]=buf[switchs]*10+c-48,c=s[++i];
            i--;
        }
    }
    return mx;
}

lint A[_],lA,S[_],lS,T[_];
int tmp[_],ltmp;
void solve(string s)
{
    memset(A,0,sizeof(A)),memset(S,0,sizeof(S)),S[0]=1,memset(T,0,sizeof(T));
    memset(tmp,0,sizeof(tmp)),ltmp=1;
    register int i,j,l=s.length();
    for(i=0;i<l;i++)if(s[i]=='*')tmp[++ltmp]=i;
    tmp[ltmp+1]=l;
    for(i=1;i<=ltmp;i++)
    {
        lA=polyExtractor(s.substr(tmp[i],tmp[i+1]-tmp[i]+1),A,_)+1;
        lS=NTT(lS,S,lA,A,T),memcpy(S,T,sizeof(lint)*lS),memset(T,0,sizeof(lint)*lS);
    }
    for(i=lS,j=0;i>=0;i--)
    {
        if(!S[i])continue;
        if(j)putchar('+');else j=1;
        if(i>0)printf("%llda^%d",S[i],i);
        else printf("%lld",S[i]);
    }
    puts("");
}
int main()
{
    string str;
    while(getline(cin,str))solve(str);
    return 0;
}
//Ori saikou
```

---

## 作者：Xqbk (赞：0)

观察到数据范围$[0,30]$完全不需要FFT

（当然也有不会FFT的因素

于是只剩一个简单的字符串模拟

考试之前做一做模拟有好处的

解释看注释

```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
string s;
int x[40]; //乘号左侧多项式各项系数
int y[40]; //乘号右侧多项式各项系数
int a[100]; //答案
int f=0;
void work(string s)
{
	memset(x,0,sizeof(x));
	memset(y,0,sizeof(y));
	memset(a,0,sizeof(a));
	for(int i=0;i<s.length();i++)
	{
		if(s[i]=='('||s[i]=='+') //跳到某项
		{
			i++;
			int c=0,d=0;
			while(s[i]>='0'&&s[i]<='9') //输入系数
			{
				c*=10;
				c+=s[i]-'0';
				i++;
			}
			if(s[i]=='a') //没有a的话说明是常数，d=0
			{
				while(!(s[i]>='0'&&s[i]<='9'))i++; //跳到指数
				while(s[i]>='0'&&s[i]<='9') //输入指数
				{
					d*=10;
					d+=s[i]-'0';
					i++;
				}
                i--;
			}
			if(!f)x[d]=c; //f表示乘号左右侧
			else y[d]=c;
		}
		if(s[i]=='*')f=1;
	}
	if(!f)
	{
		cout<<s<<endl;
		return;
	}
	for(int i=0;i<=30;i++) //相乘
	{
		for(int j=0;j<=30;j++)
		{
			a[i+j]+=x[i]*y[j];
		}
	}
	f=1;
	for(int i=60;i>0;i--) //输出
	{
		if(a[i]>0)
		{
			if(f)f=0;
			else cout<<"+";
			cout<<a[i]<<"a^"<<i;
		}
	}
	if(a[0]>0)
	{
		if(f)f=0;
		else cout<<"+";
		cout<<a[0];
	}
	cout<<endl;
	return;
}
int main()
{
	while(getline(cin,s))
	{
		work(s);
	}
	return 0;
}
```

---

## 作者：Jμdge (赞：0)

字符串处理永远是最讨人厌的东西 （~~其实就是我不会~~），于是看了题解的...


然后手~~抄~~打 NTT  

为什么不用 FFT 呢？ 因为 NTT 感觉打起来挺舒服的


# NTT 可行性


我们注意到这道题的数据范围不是很大，并且输入数据都是整数，虽然不用取模，但数据最大值远小于 $998244353$  ，那么我们可以假装着取个模，反正答案输出来一样的...

然后数组大小可以很随意（它数据范围就很小啊！）

# string 处理

这个玩意儿...

反正就是，看耐心呗...


# code

（来一发清新的 NTT ）


```
//by Judge
#include<bits/stdc++.h>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353;
const int inv3=332748118;
const int M=222;
typedef int arr[M];
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int inc(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline bool cmax(int& a,int b){return a<b?a=b,1:0;}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,m,limit,len; arr a,b,r; string s;
inline int qpow(int x,int p=mod-2){ int s=1;
	for(;p;p>>=1,x=mul(x,x))
		if(p&1) s=mul(s,x); return s;
}
inline void NTT(int* a,int tp){
	fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1;mid<limit;mid<<=1){ int Gn=qpow(tp?3:inv3,(mod-1)/(mid<<1));
		for(int j=0;j<limit;j+=mid<<1) for(int k=0,g=1,x,y;k<mid;++k,g=mul(g,Gn))
			x=a[j+k],y=mul(g,a[j+k+mid]),a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	} if(tp) return ; int inv=qpow(limit); fp(i,0,limit-1) a[i]=mul(a[i],inv);
}
inline void work(){
	for(limit=1,len=0;limit<=n+m;limit<<=1) ++len;
	fp(i,0,limit-1) r[i]=(r[i>>1]>>1)|((i&1)<<len-1);
	NTT(a,1),NTT(b,1);
	fp(i,0,limit-1) a[i]=mul(a[i],b[i]); NTT(a,0);
	fd(i,limit-1,0) if(a[i])
		if(i) print(a[i],'a'),
			sr[++C]='^',print(i,'+');
		else print(a[i],'+'); sr[C]='\n';
}
int main(){
	ios::sync_with_stdio(0);
	while(getline(cin,s)){
		bool flg=len=n=m=0;
		memset(a,0,sizeof a);
		memset(b,0,sizeof b);
		int len=s.size();
		fp(i,0,len-1){
			if(isdigit(s[i])){ int x=0,y=0;
				for(;isdigit(s[i]);++i)
					x=x*10+s[i]-48; --i;
				if(s[i+1]=='a'){ i+=3;
					for(;isdigit(s[i]);++i)
						y=y*10+s[i]-48; --i;
				}
				if(!flg) cmax(n,y),a[y]=x;
				else cmax(m,y),b[y]=x;
			} else if(s[i]==')')
				flg^=1,!flg&&(work(),0);
		}
	} return Ot(),0;
}
```



---


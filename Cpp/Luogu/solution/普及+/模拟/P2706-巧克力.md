# 巧克力

## 题目背景

王 7 的生日到了，他的弟弟准备送他巧克力。

## 题目描述

有一个被分成 $n\times m$ 格的巧克力盒，在 $(i,j)$ 的位置上有 $a_{i,j}$ 块巧克力。就在送出它的前一天晚上，有老鼠夜袭巧克力盒，某些位置上被洗劫并且穿了洞。所以，你——王 7 的弟弟王 9，必须从这个满目苍夷的盒子中切割出一个矩形巧克力盒，其中不能有被老鼠洗劫过的格子且使这个盒子里的巧克力尽量多。

## 说明/提示

**样例解释**

第三行前三列 `10 3 4` 组成的矩形的巧克力数最大。

**数据范围**

对于全部的数据，$1\le n,m\le 300$，$0\le a_{i,j} \le 255$。

## 样例 #1

### 输入

```
3 4
1 2 3 4
5 0 6 3
10 3 4 0```

### 输出

```
17
```

# 题解

## 作者：Froranzen (赞：23)

### [题目传送门](https://www.luogu.com.cn/problem/P2706)


------------

### 1.第一种 $O(n^3)$ 做法

本人第一个想到的做法就是用**二维前缀和**来暴力查找最大子矩阵。

具体来讲，就是用一个三维的 bool 数组 $vis_{i,j,k}$，表示在第 $i$  行的第 $j \sim k$ 个数间是否有 $0$。然后在查找最大子矩阵时，在上下两边之间跑一遍循环来检查有无 $0$。


------------

### 二维前缀和

1. 首先，设 $sum_{i,j}$，代表从 $(1,1)$ 为左上角 到 $(i, j)$ 为右下角的矩形区域的加权和。


令 $(i, j)$ 表示位置为从左往右数第 $i$ 列，从上往下数第 $j$ 行的格子。

------------

![a](https://cdn.luogu.com.cn/upload/image_hosting/hcm9oc4s.png)


------------

2. 根据上图，我们可以得出这样的公式：
$$ sum_{i,j} = sum_{i-1,j} + sum_{i,j-1} - sum_{i-1,j-1} + val_{i,j}$$


因为左下角为 $(i - 1, j - 1)$ 的矩形，在 $(i, j - 1)$ 矩形中加了一次，在 $(i - 1, j)$ 矩形中又加了一次，所以要减去矩形 $(i - 1, j - 1)$ 。


------------

![a](https://cdn.luogu.com.cn/upload/image_hosting/qi84cyro.png)


------------

3. 如上图，我们根据 $sum$ 数组的值，可以较为容易地推出下面公式，即**点 $(i,j)$ 为左上角，点 $(l,r)$ 为右下角的矩阵中值的和为**：
$$ sum_{l, r} - sum_{i-1,r} - sum_{l,j-1} + sum_{i-1,j-1}$$

理解了二维前缀和，这道题就没什么难度了。

------------


### 代码


------------

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

int _map[333][333];
int qwq[333][333]; 	//二维前缀和，维护数值
bool wqw[333][333][333];  //维护有无0
int n, m;
int ans;

inline int min (int a, int b) {
	return a < b ?a :b;
}

inline int max (int a, int b) {
	return a >b ?a :b;
}

int main () {
	scanf ("%d %d", &n, &m);
	for (int i(1); i <= n; ++i)
		for (int j(1); j <= m; ++j)
			scanf ("%d", &_map[i][j]);
	for (int i(1); i <= n; ++i) {
		for (int j(1); j <= m; ++j) {
			qwq[i][j] = qwq[i][j - 1] + qwq[i - 1][j] - qwq[i - 1][j - 1] + _map[i][j];  //二维前缀和
		}
	}
	for (int i(1); i <= n; ++i) {  
		for (int l(1); l <= m; ++l) {  //枚举一个点
			int len = m - l;  //求出剩余长度
            bool flag = false;  //标记
			for (int s(0); s <= len; ++s) {  //循环一遍长度
                if (flag == true) wqw[i][l][l+s] = 1;  //如果之前已经有过'0'，直接记录为有'0'
				if (!_map[i][l + s]) {  //如果当前点是'0'
					wqw[i][l][l + s] = 1;
                    flag = true;
				}
			}
		}
	}
	for (int i(1); i <= n; ++i) {
		for (int j(1); j <= m; ++j) {  //枚举一个点
			int tmp = m - j;  //求出剩余长度
			bool flag = false;  //标记
			int orz;  //标记
			for (int len(0); len <= tmp; ++len) {  //枚举长度
				for (int k(i); k <= n; ++k) {  //枚举另一个点，因为是一个矩形，所以我们只枚举行数，相应的顶点都是和上面两层枚举的顶点平行
                    if (flag && k == orz) break;  //剪枝，因为len是正序枚举，所以之前有'0'，现在到了当时的行数，一定还会有'0'
					if (wqw[k][j][j +len]) {  //有0
						flag = true;
						orz = k;  //标记
						break;
					}
					ans = max (ans, qwq[k][j +len] - qwq[i - 1][j +len] - qwq[k][j -1] + qwq[i - 1][j - 1]);  //二维前缀和公式
				}
			}
		}
	}
	printf ("%d", ans);
	return 0;
}

```


------------


upd: 2022.10.17

这样一个暴力题解成了点赞数最多的，感觉有点误导别人了，所以本人在这里补充一下别的做法。

### 2.另外一种 $O(n^3)$ 做法


首先做一步转化：我们直接将 $0$ 位置的权值赋成负无穷，所以不合法的矩形的权值都变成负无穷了，然后求出新矩形的最大子矩形就是答案。

设 $w(l,r,i,j)$ 表示 $(l,r)$ 为左上端点，$(i,j)$ 为右下端点的矩形权值。

暴力 $O(n^2)$ 枚举上下边界 $l, r$，再从左往右扫右边界 $i$，维护最优左边界 $j$。答案的形式一定是 $w(1,l,i,r) - w(1,l,j-1,r)$，所以维护一个 $w(1,l,i,r)$ 的最小值即可。

时间复杂度 $O(n^3)$。



------------


### 3. $O(n^2)$ 做法


来到正题。给 $0$ 位置赋负无穷然后求最大子矩阵的话，其实有点浪费题目给的性质了，我们能选出的矩形，一定是极大的，因为权值为正，而上面的 $O(n^3)$ 做法却抛弃了这个性质。所以我们还是考虑原来的问题。

考虑最后的矩形会长成一个什么样子：扩展一格上边界一定会使得这个矩形不合法，不然我们再扩展一格上边界显然更优。设扩展一格上边界后，第 $x$ 列会变得不合法，那我们不妨去枚举这个 $x$。即对于每个点 $(i, j)$，求出同一列，之前的第一个不合法的位置 $(i, k)$，然后去扩展这个以 $(i, k+1)$ 为右上端点，$(i, j)$ 为左下端点的矩形直到不能扩展。具体求这个左右边界，可以先求出 $(i, j)$ 在当前行里，能扩展到的边界，然后和同一列上一个矩形的左右边界取交即可。 

时间复杂度 $O(n^2)$。



------------


感谢您的阅读 :)

---

## 作者：MloVtry (赞：13)

下面dalao们好强啊...这里给一个咸鱼的n^3做法好了-3-

首先0的位置不可选择，所以赋值为-inf，问题就变成最大子矩阵了

这个可以前缀和啦


我们可以枚举一个行数，在枚举另一个行数，来表示矩阵的上下，然后中间的每一个点都必须要选择，所以可以纵向压缩成一个点

- - - - - -

- - - - - -

- - - - - -

↓
.  .  .  .  .  .

这样，我们只需要处理矩阵的两列就好了，这就是一个最大字段和了，可以o(n)操♂作

然猴就是n^3的复杂度了

代码
```cpp
#define ll long long
#include<iostream>
#define inf 1<<25
#include<cstdio>
using namespace std;
ll n,m;
ll map[310][310],s[310],up[310][310];
ll ans;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        scanf("%d",&map[i][j]);
        if(!map[i][j]) map[i][j]=-inf;
        up[i][j]=up[i-1][j]+map[i][j];
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=i;j<=n;++j)
        {
            ll mi=0;
            for(int k=1;k<=m;++k) s[k]=s[k-1]+up[j][k]-up[i-1][k];
            for(int k=1;k<=m;++k)
            {
                ans=max(ans,s[k]-mi);
                mi=min(s[k],mi);
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：TH讠NK (赞：7)

# 用极大化思想解决最大子矩阵问题


**最大子矩形问题：** 在一个给定的矩形网格中有一些障碍点 ，要找出网格内部不包含任何障碍点 ，且边界与坐标轴平行的最大子矩形。

## 定义：

**极大子矩形：** 一个极大子矩形的四条边一定都不能**向外扩展** 。更进一步地说 ，一个有效子矩形是极大子矩形的充要条件是这个子矩形的每条边要么**覆盖了障碍点** ，要么**与矩形边界重合**。

**有效竖线：** 除了两个端点外 ，不覆盖任何障碍点的竖直线段。

**悬线：** 上端点覆盖了一个障碍点或达到整个矩形上端的有效竖线。 

## 解决方法：

如果把一个极大子矩形按 $x$ 坐标切割成多个（实际上是无数个）与y轴垂直的线段 ，则其中**一定存在一条悬线**。

一条悬线通过**尽可能地向左右移动**恰好能得到一个子矩形（未必是极大子矩形，但只可能向下扩展）。

因此我们可以得到一个非常重要的**定理：**

如果将一条**悬线**向左右两个方向**尽可能移动**所得到的有效子矩形称为这个悬线所对应的子矩形 ，那么所有悬线所对应的有效子矩形的集合一定包含了所有极大子矩形的集合。

因此 ，通过枚举所有的悬线 ，就可以枚举出所有的极大子矩形。

## 算法实现：

悬线的数量为 $(n-1)*m$ ，如果能做到对每条悬线的操作时间都为$O(1)$ ，那么整个算法的复杂度就是$O(NM)$

我们知道，每个极大子矩形都可以通过一条悬线左右平移得到。

所以 ，对于每个确定了底部的悬线 ，我们需要知道有关于它的三个量：**顶部、左右最多能移动到的位置**。

对于底部为 $(i,j)$ 的一条悬线，设它的高为 $h[i,j]$ , 左右最多能移动到的位置分别为   $l[i,j]$ , $r[i,j]$。

为了充分利用以前得到的信息，我们将使用**递推**的方式得到这三个参数。

**对于以点 $(i,j)$ 为底部的悬线：** 

如果点 $(i,j)$ 为障碍点，那么其高度显然为 $0$。在此我们可以假设其左右均可以移动到整个矩形的左右边界 ，因为其高度为 $0$  , 不会影响答案 ，这样的处理方便了后面的递推

```cpp
当 (i,j) 为障碍点时
h[i,j]=1
l[i,j]=0
r[i,j]=m
```


如果点 $(i,j)$ 不为障碍点，那么其高度为以点 $(i-1,j)$ 为底部的悬线的高度 $+1$ 。接着我们考虑其左右可以移动的距离 ，此时 $(i,j)$ 对应的悬线左右能移动的位置要在 $(i-1,j)$ 的基础上变化 , 即 

$l[i,j]=$ $max$ $( l[i-1,j]$ $,$ $(i-1,j)$左边第一个障碍点的位置$)$ 

$r[i,j]$ 的求法类似

综合起来，可以得到这三个参数的递推式：

```cpp
当 (i,j) 不为障碍点时
h[i,j]=h[i-1,j]+1
l[i,j]=max( l[i-1,j] , (i-1,j)左边第一个障碍点位置, 边界0也是障碍点 )
r[i,j]=min( r[i-1,j] , (i-1,j)右边第一个障碍点位置, 边界m也是障碍点 )
```


通过**递推** ，我们充分利用了以前得到的信息 ，使每条悬线的处理时间复杂度降至$O(1)$

对于以点 $(i,j)$ 为底的悬线对应的子矩形 ，它的面积为 $(r[i,j]-l[i,j]+1)*h[i,j]$

这样最后问题的解就是:

$ans=max(ans ,(r[i,j]-l[i,j]+1)*h[i,j]) $ 

这里默认求的是最大面积 ，具体题目要具体分析 ，比如此题就应该写成：

$ans=max(ans,s[i][r[j]]-s[i][l[j]-1]-s[i-h[j]][r[j]]+s[i-h[j]][l[j]-1])$ $(s$为二维前缀和$)$

至此 ， **最大子矩形问题**已被解决 ，整个算法的时间复杂度为 $O(NM)$ ，空间复杂度为 $O(NM)$ , 当然 ，我们发现二维数组中的第一维完全是多余的 ，因此空间复杂度可降为 $O(M)$

**本题AC代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=305;
int ans,n,m,h[maxn],l[maxn],r[maxn],la,ra,s[maxn][maxn];
bool mp[maxn][maxn];
int main(){
    scanf("%d%d",&n,&m); 
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++){
    		scanf("%d",&s[i][j]);//此题数据有锅，用快读会TLE…… 
    		if(s[i][j]==0) mp[i][j]=1;//如果s[i][j]为零，则这个点是障碍点 
    		s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//维护前缀和 
		}
	for(int i=1;i<=m;i++) l[i]=1, r[i]=m;//预处理，假设每个点都能走到矩形的左右两端 
    for(int i=1;i<=n;i++){
        la=0, ra=m+1;//0和m+1也是障碍点 
        for(int j=1;j<=m;j++){
            if(mp[i][j]) la=j, h[j]=0, l[j]=1;
            else h[j]++, l[j]=max(l[j],la+1);
        }
        for(int j=m;j;j--){
            if(mp[i][j]) ra=j, r[j]=m;
            else r[j]=min(r[j],ra-1), 
			ans=max(ans,s[i][r[j]]-s[i][l[j]-1]-s[i-h[j]][r[j]]+s[i-h[j]][l[j]-1]);
			//利用前缀和把(r[j]-l[i]+1)*h[j]这一块矩形的值算出来 
        }
    }
    printf("%d\n",ans);
    return 0;
} 
```


---

## 作者：Lonely_NewYear (赞：6)

# P2706 题解

## 题目分析

观察这题的数据范围可以知道大概 $O(n^3)$ 的复杂度就可以通过本题，所以可以暴力一点，枚举一下最终选出的矩形巧克力的右下角以及右上角（枚举右下角 $O(n^2)$，再枚举右上角只需要从右下角往上一直枚举到第 $1$ 行，所以是 $O(n)$，一起就是 $O(n^3)$）,同时计算答案。

具体如何计算呢？因为我们要求的是巧克力最多的那个矩形，所以只要矩形左边界旁没有 $0$ 就可以继续把左边界往左推。可以维护一个变量 $l$ 表示矩形的左边界，如果 $f_{i,j}$ 表示 $a_{i,j}$ 左边最近的 $0$ 的位置，那么显然 $l=max(l,f_{i,j}+1)$（再往左就碰到 $0$ 了）。此时矩形的右上角，右下角，左边界都确定了，那么就可以确定这个矩形，就可以利用二维前缀和计算矩形内的巧克力数量。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[301][301],f[301][301],s[301][301];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			if(a[i][j])f[i][j]=f[i][j-1];
			else f[i][j]=j;
			s[i][j]=a[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int l=0;
			for(int k=i;k>=1;k--)
			{
				if(!a[k][j])break;
				l=max(l,f[k][j]);
				ans=max(ans,s[i][j]-s[i][l]-s[k-1][j]+s[k-1][l]);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

谢谢观看！

---

## 作者：Three_Soil (赞：5)

# O（N^2)算法！



------------



## ~~下面的巨佬们的神仙代码实在是令人无法理解~~


------------
做法一：暴力枚举

O(N^4)的时间复杂度

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int num[301][301]={};
int sum[301][301]={};
int ans=0;
bool check(int a,int b,int c,int d)
{

    return ((sum[c][d]-sum[c][b-1]-sum[a-1][d]+sum[a-1][b-1])==(c-a+1)*(d-b+1));
}//利用前缀和判断（实际就是这个矩形中不为0的个数是否与这个矩形的大小一致）
int work(int a,int b,int c,int d)
{
    int tot=0;
    for(int i=a;i<=c;i++)
        for(int j=b;j<=d;j++)
        {
        tot+=num[i][j];
    }
    return tot;
}
int main()

------------


------------

{	
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i+=1)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&num[i][j]);
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(num[i][j]!=0);
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int l=i;l<=n;l++)
                for(int k=j;k<=m;k++)
                {
                    if(check(i,j,l,k))
                    {
                    ans=max(ans,work(i,j,l,k));
                    if(ans==work(i,j,l,k));
           
    }
                }
    printf("%d",ans);
    return 0;
}

```
（这里判断时用到了二维前缀和（https://www.cnblogs.com/OIerShawnZhou/p/7348088.html ）
，其实如果不会的话check函数枚举就行）


------------
做法二：悬线法（100分）

时间复杂度：O(N^2)

作为蒟蒻的我一直拿这道题没什么办法

直到有一天

我看到了一种很妙的方法

# 悬线法

简单来讲：过一个点做一条竖线，可以求出这个点最上方可以到的点（下面我们并不关心，因为下一个会重新考虑），再做一条水平线，可以求出最左和最右可以到达的点，这样，我们就求出了过这个点在它上方可以造出的最大矩形

### 先预处理：

### 用数组l，r记录某点向左和向右能到达的最远点的纵坐标。 用数组up记录某点向上能到达的最远距离。

## FOR EXAMPLE:

| 1 |2  | 3 |  4|
| :----------: | :----------: | :----------: | :----------: |
| 5 | 0 |6  | 3 |
| 10 | 3 |4  |  0|



### 第二行第三列这个点 它的左边就是0，所以l[2][3]=3（最左边能到的就是它自己），r[2][3]=4,up[2][3]=2(需要注意的是，up[i][j]指的是上方有几个点，而不是最上方坐标，比如up[3][2]=1

最后求最大值我还是习惯用二维前缀和（见上方）.不过这一题暴力还是可以的

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ma[1001][1001]= {};
int up[1001][1001]={},l[1001][1001]={},r[1001][1001]={};//含义见上方
int ans=0;
int sum[301][301]= {};
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i+=1)
		for(int j=1; j<=m; j++) {
			scanf("%d",&ma[i][j]);
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+ma[i][j];
		}//二维前缀和
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++) {
			if(ma[i][j]) {
				up[i][j]=1;
				l[i][j]=j;
				r[i][j]=j;
			}//开始时默认左右都是自己，上面没有点
		}	
	for(int i=1; i<=n; i++)
		for(int j=2; j<=m; j++)
			if(ma[i][j]&&ma[i][j-1])
				l[i][j]=l[i][j-1];//预处理左边
	for(int i=1; i<=n; i++)
		for(int j=m-1; j>=1; j--)
			if(ma[i][j]&&ma[i][j+1])
				r[i][j]=r[i][j+1];//预处理右边

	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(ma[i][j]&&ma[i-1][j]) {
				l[i][j]=max(l[i][j],l[i-1][j]);//最左边
				r[i][j]=min(r[i][j],r[i-1][j]);//最右边
				up[i][j]=up[i-1][j]+1;//上方
			}
		
			ans=max(ans,sum[i][r[i][j]]-sum[i][l[i][j]-1]-sum[i-(up[i][j]-1)-1][r[i][j]]+sum[i-(up[i][j]-1)-1][l[i][j]-1]);
		}
	}
	printf("%d",ans);
	return 0;
}

```




---

## 作者：x122 (赞：5)

# ~~全洛谷~~唯一单调队列解法
若不会单调队列请[出门左转](https://www.luogu.org/problem/P1886)

### 题意：

### [传送门](https://www.luogu.org/problem/P2706)

### 思路：

我们可以先把矩阵预处理，即 将为被吃掉的位置表记为 $0$，未被吃掉的位置标记为 $1$,用数组$f[i][j]$ 表示。

对于一个点$(i,j)$ 若该点未被吃掉，则记 $f[i][j]=f[i-1][j]+1$

其中 $+1$ 加的是自己这个点，$f[i][j]$ 即为 $j$ 这一列在第 $i$ 行
时未被吃掉的连续长度

那么我们对于每一个点 $(i,j)$ ，若其左边（或右边）的未被吃掉的高度（ 即 $f[i-1][j]$ 或 $f[i][j-1]$）大于等于这个点的高度（ 即 $f[i][j]$ )

那么说明其左边（或右边）可以被拓展 并且 能形成高度为 $f[i][j]$ 的矩形，于是将其拓展

这个我们可以用单调队列维护

详情见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,mx,ans,a[3001][3001],f[3001][3001];
int main(){
	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++) {
		for(long long j=1;j<=m;j++) {
			scanf("%lld",&a[i][j]);
			if(a[i][j]!=0) f[i][j]=f[i-1][j]+1;//求出该点最高高度
		}
	}
	for(long long i=1;i<=n;i++) {
		for(long long j=1;j<=m;j++) {
			long long head=j,tail=j;//单调队列
			if(a[i][j]!=0) {
				while(f[i][head-1]>=f[i][j] && head>1) 
					head-=1;
				while(f[i][tail+1]>=f[i][j] && tail<m) 
					tail+=1;
				ans=0;
				for(long long p=0;p<=f[i][j]-1;p++) {//求出总价值
					for(long long k=head;k<=tail;k++) 
						ans+=a[i-p][k];
				}
				mx=max(mx,ans);//选取最优解
			}
		}
	}
	printf("%lld\n",mx);
	return 0;
}
```


---

## 作者：Mine_King (赞：4)

这题在求最大子矩阵的情况下，要求不能走值为0的点。那么我们可以把值为0的点改成$-inf$，那么就不会走到有0的点上了。   
而求最大子矩阵就是大家很熟悉的$O(n^3)$的做法啦！
```cpp
#include<cstdio>
#define ll long long
#define INF 1<<25
#define rg register
using namespace std;
int n,m;
ll ans,s[1005],sum[1005][1005];
ll max(ll x,ll y){return x>y?x:y;}
ll min(ll x,ll y){return x<y?x:y;}
inline int r()//快读
{
    int x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*f;
}
int main()
{
	n=r(),m=r();
	for(rg int i=1;i<=n;i++)
		for(rg int j=1;j<=m;j++)
		{
			int x;
			x=r();
			if(x==0) x=-INF;//如果是0则赋值为-INF
			sum[i][j]=sum[i-1][j]+x;//记录前缀和
		}
	for(rg int i=1;i<=n;i++)
		for(rg int j=i;j<=n;j++)
		{
			ll area=0;
			for(rg int k=1;k<=m;k++)
			{
				area+=sum[j][k]-sum[i-1][k];
				ans=max(ans,area);
				if(area<0) area=0;
			}
		}
   //大家耳熟能详的三重循环求最大子矩阵
	printf("%lld",ans);
	return 0;
}
```
[安利一发博客~](https://www.luogu.com.cn/blog/195331/)

---

## 作者：I_am_kunzi (赞：2)

# P2706 题解

### 题目概括

有一块 $ N \times M $ 的区域，在第 $ (i , j) $ 的区域有 $ A_{i , j} $ 块巧克力，但是有一些部分被老鼠吃掉，因此需要选取一块没有被老鼠吃掉的部分，且这块区域中的巧克力数量最大。

### 题目分析

这道题目既然要求最大的部分，自然想到了最大子矩阵问题。但是接下来我将要呈现出一种全新的思路，只用两个前缀和数组即可解决。

再审视一遍题目，这道题关键就是有些部分被老鼠吃了而选取的部分不能有被吃掉的。常规思路就是挨个枚举，但是我们可以像前缀和一样用一个数组存被吃掉的部分，与前缀和的思路相同；接着再用一个数组存储巧克力。每次用二维区间和公式计算这片区域有没有被老鼠吃掉的部分，没有的话在求出巧克力数量并用一个 $ maxx $ 维护区间巧克力数量最大值。

### 代码时间

```cpp
#include<iostream>
using namespace std;
long long qzh[305][305] , yl[305][305] , xj[305][305];
//qzh：巧克力前缀和数组；yl：原来的数组；xj：被洗劫格子数量数组 
signed main()
{
	int n , m;
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i++)
	{
		for(int j = 1 ; j <= m ; j++)
		{
			cin >> yl[i][j];
			if(yl[i][j] == 0) //如果值为 0，即被洗劫了 
			{
				xj[i][j] = xj[i - 1][j] + xj[i][j - 1] - xj[i - 1][j - 1] + 1;
			}
			else
			{
				xj[i][j] = xj[i - 1][j] + xj[i][j - 1] - xj[i - 1][j - 1] + 0;
				//等同于 xj[i][j] = xj[i - 1][j] + xj[i][j - 1] - xj[i - 1][j - 1]; 
			}
			qzh[i][j] = qzh[i - 1][j] + qzh[i][j - 1] - qzh[i - 1][j - 1] + yl[i][j];
			//前缀和公式 
			
		}
	}
	long long maxx = 0; 
	for(int i = 1 ; i <= n ; i++)
	{
		for(int j = 1 ; j <= m ; j++)
		{
			if(yl[i][j] == 0) //本身就被洗劫，那么这块巧克力自然不符合要求 
			{
				continue;
			}
			for(int x = i ; x <= n ; x++)
			{
				for(int y = j ; y <= m ; y++)
				{
					int xjgs = xj[x][y] - xj[i - 1][y] - xj[x][j - 1] + xj[i - 1][j - 1];
					//计算这片区域中有几块区域被洗劫 
					if(xjgs > 0) //如果有被洗劫的区域，那么这块巧克力自然不符合要求 
					{
						continue;
					}
					maxx = max(maxx , qzh[x][y] - qzh[i - 1][y] - qzh[x][j - 1] + qzh[i - 1][j - 1]);
					//更新最大巧克力数量 
				}
			}
		}
	}
	cout << maxx << endl;
   	return 0;
}
```

#### 后记：这篇题解算是一个比较新颖的做法了，代码和思路都比较简洁，所以做题也要善于发现新的方法，想出新的思路~

---

## 作者：issue_is_fw (赞：2)

大部分题解是把0处赋值-inf，进而压缩矩阵来写

但是我想不到啊......只好O(n^4)暴力求解。

没关系哦，只要会二位前缀和就好!!

#### 进入正题

我们枚举每一个点作为矩阵的右下角，再枚举矩阵的宽和长

那现在的问题就是如何判断当前矩阵是否包含(0,0)。

**这个很简单，我们维护两个各位前缀和**

一、$he[301][301]:$这个正常做前缀和就好

二、$vis[301][301:$遇到0点时，把当前前缀和多加1.

这样一来，当he与vis计算的矩阵和相等时，矩阵不包括0

若不相等，可以直接break，因为接下来枚举的矩阵也包括这个0点



------------

~~这么算先来，复杂度根本跑不满，也不比O(n^3)慢多少~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[309][309],n,m;
int he[309][309],vis[309][309];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{	
		cin>>a[i][j];
		he[i][j]=he[i-1][j]+he[i][j-1]-he[i-1][j-1]+a[i][j];
		vis[i][j]=vis[i-1][j]+vis[i][j-1]-vis[i-1][j-1]+a[i][j];
		if(a[i][j]==0)	vis[i][j]++;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	for(int k=1;k<=i;k++)
	for(int q=1;q<=j;q++)
	{
		int x=he[i][j]-he[i-k][j]-he[i][j-q]+he[i-k][j-q];
		int y=vis[i][j]-vis[i-k][j]-vis[i][j-q]+vis[i-k][j-q];
		if(x!=y)	break;
		ans=max(ans,x);		
	}	
	cout<<ans;
} 
```


---

## 作者：顾z (赞：2)


# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

表示很水的一个题.~~要不是数据有问题我就切了~~

**悬线法+二维前缀和**。吼啊

~~不过貌似比只写二维前缀和的麻烦一点.~~

我们预处理出来悬线法用的数组.(记得变一下限制条件.

然后真正做悬线法的时候.

我们可以**得到一个合法矩形**.

其左上角坐标,右下角坐标均可求.

然后用二维前缀和算一下即可.

PS：这题数据有问题,读入矩阵的时候要用$cin$

``代码``

```c++
#include<cstdio>
#include<algorithm>
#include<iostream>
#define R register
#define N 308
using namespace std;
inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,ans;
int res[N][N],sum[N][N];
int ri[N][N],le[N][N],up[N][N];
inline int calc(int a,int b,int c,int d)
{
	return (sum[c][d]-sum[c][b-1]-sum[a-1][d]+sum[a-1][b-1]);
}
int main()
{
	in(n),in(m);
	for(R int i=1;i<=n;i++)	
		for(R int j=1;j<=m;j++)
		{
			cin>>res[i][j];
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+res[i][j];
			ri[i][j]=le[i][j]=j;
			up[i][j]=1;
		}
	for(R int i=1;i<=n;i++)
		for(R int j=2;j<=m;j++)
			if(res[i][j] and res[i][j-1])
				le[i][j]=le[i][j-1];
	for(R int i=1;i<=n;i++)
		for(R int j=m-1;j>=1;j--)
			if(res[i][j] and res[i][j+1])
				ri[i][j]=ri[i][j+1];
	for(R int i=1;i<=n;i++)
		for(R int j=1;j<=m;j++)
		{
			if(res[i][j] and res[i-1][j])
			{
				le[i][j]=max(le[i][j],le[i-1][j]);
				ri[i][j]=min(ri[i][j],ri[i-1][j]);
				up[i][j]=up[i-1][j]+1;
			}
			int a=i-up[i][j]+1,b=le[i][j],c=i,d=ri[i][j];
			ans=max(ans,calc(a,b,c,d));
		}
	printf("%d",ans);
}
```



---

## 作者：Otomachi_Una_ (赞：1)

## 题目简述

- 在一块有障碍的非负整数矩阵内求最大矩阵和。

- 要求所求得的矩阵不包含障碍点。

## 解题思路

枚举所有可能的列，后枚举行。

假设 $last$ 为到现在为止第一次未出现障碍点的行数。

因为所给出的矩阵是非负的，所以我们尽可能地往后增加行。

如果直接暴力算的时间复杂度是 $\mathcal{O}(n^5)$，这显然不能接受。

于是可以进行以下优化：

1. 假设 $s_{i,j}$ 为二维前缀和，在求和的时候就可以用 $\mathcal{O}(1)$ 的时间求解。
2. 假设 $t_{i,j}$ 为 $i$ 行前 $j$ 个数有多少个非障碍点，在求第 $k$ 行第 $i$ 到第 $j$ 个数中是否有障碍点，可以直接判断。

有了以上优化，代码的时间复杂度就下降到了 $\mathcal{O}(n^3)$ 完全可以接受（~~为什么还有 $\mathcal{O}(n^2)$ 的神仙解法啊~~）。

## 参考代码

```cpp
#include<iostream>
using namespace std;
const int MAXN=3e2+5;
int n,m;
int a[MAXN][MAXN];
int s[MAXN][MAXN],t[MAXN][MAXN];
int ans=0;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
			t[i][j]=t[i][j-1]+(a[i][j]!=0);
		}
	for(int i=1;i<=m;i++)
		for(int j=i;j<=m;j++){
			int last=1;
			for(int k=1;k<=n;k++){
				if(t[k][j]-t[k][i-1]!=j-i+1){
					last=k+1;
					continue;
				}
				ans=max(ans,s[k][j]-s[k][i-1]-s[last-1][j]+s[last-1][i-1]);
			}
		}
	cout<<ans;
} 
```


---

## 作者：zhangyuhan (赞：1)

我来一个比较套路的题解233

大家都知道最大子矩阵这个问题吧。但是本题不允许矩阵内有$0$的存在，看似没法套用，但实际上另有玄机：

观察数据范围，$0\leq a[i][j] \leq 255$，发现$a[i][j]$并不是很大，那我们就把等于$0$的$a[i][j]$赋为$-INF$，再套上最大子矩阵模板，不就可以$A$了吗？

时间复杂度也不多不少$O(nm^2)$

太神奇了！

~~套路出奇迹，打表拿AU~~

那就直接上代码吧：

$AC$ $Code$

```cpp
#include<iostream>
using namespace std;
const int SIZE=300;
long long matrix[SIZE+1][SIZE+1];//读入的矩阵
long long rowsum[SIZE+1][SIZE+1];//每行的前缀和
long long n,m,area,ans;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>matrix[i][j];
            if(matrix[i][j]==0)
                matrix[i][j]=-1e6;
        }//读入+初始化
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            rowsum[i][j]=rowsum[i][j-1]+matrix[i][j];//统计前缀和部分
    for(int first=1;first<=m;first++)
        for(int last=first;last<=m;last++)
        {
            area=0;//记得清零！
            for(int i=1;i<=n;i++)
            {
                area+=rowsum[i][last]-rowsum[i][first-1];//统计矩阵和
                ans=max(area,ans);//更新答案
                if(area<0)
                    area=0;//记得清零！
            }
        }//计算最大子矩阵部分
    cout<<ans<<endl;//输出
    return 0;//完结撒花！
}
```

---

## 作者：Shallowy (赞：1)

这题n,m最大只有300（水），n(m)^3能过，但再大些就会超时。

我用的悬线法， 参考：王知昆《浅谈用极大化思想解决最大子矩形问题》（算法2）

https://wenku.baidu.com/view/728cd5126edb6f1aff001fbb.html

时间复杂度 O（MN）。

pascal代码

```pascal
uses math;
var
  n,m,i,j,k,l1,r1,ans,s:longint;
  a,h,l,r,f:array[0..1000,0..1000] of longint;
//h为悬线高，l,r为左右最多能移到的位置
begin
  readln(n,m);
  for i:=1 to n do
    begin
      for j:=1 to m do
        begin
          read(a[i,j]);
          f[i,j]:=f[i,j-1]+a[i,j];//前缀和
        end;
      readln;
    end;
  for i:=1 to m do r[0,i]:=m;//初始化，后面用的min
  for i:=1 to n do
    begin
      l1:=0; r1:=m+1;
      for j:=1 to m do
          if a[i,j]=0 then
            begin
              h[i,j]:=0;//等于没有
              l[i,j]:=1; r[i,j]:=m;
              l1:=j;//记录 左侧为0的点中最右边的
            end
                      else
            begin
              h[i,j]:=h[i-1,j]+1;
              l[i,j]:=max(l[i-1,j],l1+1);
            end;
      for j:=m downto 1 do//倒推，找的是右侧为0的点中最左边的
        if a[i,j]=0 then
          r1:=j
                      else
            begin
              r[i,j]:=min(r[i-1,j],r1-1);
              s:=0;
              for k:=i downto i-h[i,j]+1 do//偷懒，就直接枚举了
                inc(s,f[k,r[i,j]]-f[k,l[i,j]-1]);
              ans:=max(ans,s);
            end;
    end;
  write(ans);
end.
```

---

## 作者：66666a (赞：1)

又一篇题解

这次用的是神奇的解法（参考了大佬的程序）

各种初始化，各种数组，各种处理，就是AC

时间复杂度显著提升至O（nm），但空间复杂度升高

c++代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
const int N=1002;
int n,m,a[N][N],l[N][N],s[N][N],u[N][N],r[N][N],ml[N][N],mr[N][N],ans,mu;
int main(){
  cin>>n>>m;
  rep(i,1,n) rep(j,1,m){
    scanf("%d",&a[i][j]);
    if(a[i][j]) l[i][j]=l[i][j-1]+1,u[i][j]=u[i-1][j]+1;
    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
  }
  rep(i,1,n) for(int j=m;j;j--) if(a[i][j]) r[i][j]=r[i][j+1]+1;
  rep(i,1,n) rep(j,1,m) if(a[i][j]){
    if(!a[i-1][j]) ml[i][j]=j-l[i][j]+1,mr[i][j]=j+r[i][j]-1;
      else ml[i][j]=max(ml[i-1][j],j-l[i][j]+1),mr[i][j]=min(mr[i-1][j],j+r[i][j]-1);
    mu=i-u[i][j]+1;
    ans=max(ans,s[i][mr[i][j]]-s[i][ml[i][j]-1]-s[mu-1][mr[i][j]]+s[mu-1][ml[i][j]-1]);
  }
  cout<<ans;
  return 0;
}
```

---


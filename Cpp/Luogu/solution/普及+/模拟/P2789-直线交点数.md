# 直线交点数

## 题目描述

假设平面上有 $N$ 条直线，且无三线共点，那么这些直线有多少种可能的交点数？

## 说明/提示

对于所有数据，满足 $1 \le N \le 25$。

## 样例 #1

### 输入

```
4```

### 输出

```
5```

# 题解

## 作者：Krystalove (赞：147)

直接上代码，对p条直线分情况讨论平行线的条数，已知在有r条平行线时有（p-r）条线与他们相交于p\*（p-r）个交点，再加上对于这p-r个交点的相交组合即可！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=0;bool f[10010];
void suv(int p,int m){
        if(p==0) {if(!f[m]) ans++; f[m]=1;}
        else for(int r=p;r>=1;r--) suv(p-r,r*(p-r)+m);
}
int main(){
    cin>>n;suv(n,0);cout<<ans;
}
```

---

## 作者：yonowaru (赞：117)

我们将n条直线编号,分别称为直线1、直线2、…、直线n。直线2 与直线1 最多有一个交点，直线3与直线1和直线2最多有2个交点，……，直线n与其它 (n-1) 条直线最多 (n-1) 个交点。

由此看出,n条无三线共点的直线最多的交点数 max=1+2+…+(n-1)=n(n-1)/2。

但本题我们要求解的是：这 n 条直线共有多少种不同的交点数？ 仍然从举例出发。下面列举了 n=1、2、3、4 四种情况各自的交点情况：



 ![](https://cdn.luogu.com.cn/upload/pic/5786.png) 

具体分析一下 n=4 的情况：

1)4 条直线全部平行，则 0 交点 { =4\*(4-4)}。

2)其中 3 条直线平行，则 3 交点 { =3\*(4-3) }。

3)其中 2 条直线平行，则这2条直线与另2条直线的交点数为4,而另2条直线之间可能有0个或1个交点（见 n=2 的情况,共 4 个交点或 5 个交点。{=2\*(4-2)+0 或 1 }

4)4 条直线均不平行（可看成 1 条直线平行），这 1 条直线与其它 3 条直线的交点数为 3，而其 它 3 条直线之间的交点数为 3，共 6 个交点。{ =1\*(4-1)+3 }


经过以上分析，我们可以得如下结论：

m 条直线的交点方案=r 条平行线与（m-r）条直线交叉的交点数+（m-r）条直线本身的交点方案

=r\*(m-r)+(m-r)条直线本身的交点方案 （1<=r<=m）

在具体编程时，我们设置一个标志数组 f[0..max]，在使用上述结论递归求解的过程中，每得到一种交点数 k，则置 f[k]为 true（初始 f[0]~f[max]均为 false）。

参考程序如下：




```cpp
#include <iostream>
#include <memory.h>
#include <algorithm>
using namespace std;
int n,MAX=-1,ans=0;
bool f[11000];
void g(int n,int k)
{
        if (n==0) {f[k]=true;MAX=max(k,MAX);}
        else for (int r=n;r>=1;r--)g(n-r,r*(n-r)+k);
}
int main()
{
        cin>>n;
        memset(f,false,sizeof(f));
        g(n,0);
        for (int i=0;i<=MAX;i++)
                if (f[i]) ans++;
    cout<<ans;
        return 0;
}

```

---

## 作者：blazing_freezing (赞：31)

这道题的关键在于： **我们认为线与线之间只存在平行或相交，而不考虑具体位置**

这样一想就非常简单了

不过我们先需要处理下简单的问题

1. 假设平面上有a条平行线，此时如果加入了b条 互相平行 且不与 这a条直线 平行的直线，则交点个数为a\*b

2. 在（1）的条件下，平面上有a+b条直线，有a\*b个交点，此时再加入c条 互相平行 且不与之前任意一条直线平行，那么这c条直线 每一条都会与这a+b条直线相交 产生a+b个交点。则新产生的交点数为(a+b)\*c。所以总交点的个数为a\*b+(a+b)\*c

3. 以此类推。

所以我们可以得出，对n条直线，我们只需要枚举每条线的状态，把互相平行的放在一组，最后便可以统计出交点数

最后再统计有多少种不同的交点数就可以了

**最重要的一步 如何枚举**

我们可以发现，n=4时，这些直线状态为

1 1 1 1【表示这四条直线互不平行】

1 1 2【表示有两条直线是平行的】

1 3【同上】

2 2【前两条直线平行 后两条直线平行 但前两条和后两条相交】

4【所有的直线都是平行的】

**这就变成了<数的拆分>**

我们只需要对每一组拆分得到的结果，带入到a\*b+(a+b)\*c+(a+b+c)\*d...的公式中就可以算出每一种情况的交点数了

（n可以被拆分成自己 此时直接算出交点数为0）

所以就很简单了


代码如下(有Pascal和C++)


**Pascal:**





```cpp
type int=longint;
var n,i,max,ans:int;
    a,k:array[0..300] of int;
procedure chai(t,tot:int);
var i,sum,num:int;
begin
  if tot=n then
  begin
    sum:=a[1]; num:=0;
    for i:=2 to t-1 do
    begin
      inc(num,sum*a[i]);
      inc(sum,a[i]);
    end; //利用公式计算，num是交点总个数
    k[num]:=1; //做标记
    if num>max then max:=num; //求交点的最大数，方便查找
    exit;
  end;
  for i:=a[t-1] to n-tot do
  begin
    if i=0 then continue;
    a[t]:=i;
    chai(t+1,tot+i);
    a[t]:=0;
  end;
end; //数的拆分
begin
  readln(n);
  max:=-1;
  chai(1,0);
  for i:=0 to max do if k[i]=1 then inc(ans);
  writeln(ans); 
end.
```
**C++:**


```cpp
#include <iostream>
using namespace std;
int n,i,max1=-1,ans=0;
int a[201],k[300];
void chai(int t,int tot)
{
  int i;    
  if(tot==n)
  {
    int sum=a[1],num=0;
    for(i=2;i<=t-1;i++)
    {
      num+=sum*a[i];
      sum+=a[i];
    } //利用公式计算，num是交点总个数
    k[num]=1; //做标记
    if(num>max1) max1=num; //求交点的最大数，方便查找
    return;
  }
  for(i=a[t-1];i<=(n-tot);i++)
  {
    if(i==0) continue;
    a[t]=i;
    chai(t+1,tot+i);
    a[t]=0;
  }
```
}//数的拆分



```cpp
int main()
{
  cin>>n;
  chai(1,0);
  a[0]=0;
  for(i=0;i<=max1;i++) if(k[i]==1) ans++;
  cout<<ans;
  return 0;
}

```

---

## 作者：Tyw_ei (赞：24)

杂技dp真的不知道怎么写思路啊QAQ

dp[i][j]表示前i个数构成j个交点是否为真

考虑我们每次放多少个与i条直线不相交的平行线

那么就会得到k\*i个交点

考虑一下为什么这样子就可以保证所有直线的相交情况都被统计到呢?

其实很简单,如果有遗漏的情况,只可能在我们每次放入的平行线有和已经存在的线平行的情况

因为这样的情况是我们没有考虑的

而这样的情况等价于原平面里面的线减少一条而放入的平行线增加一条

很显然这样的情况我们之前已经统计了

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>

using namespace std;

int n,ans,m;
bool dp[30][400];

int main()
{
    scanf("%d",&n);
    m=(n-1)*n/2;
    for(int i=1;i<=n;i++)dp[i][0]=true;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)
            for(int k=1;k<=n-i;k++)
                dp[i+k][j+k*i]|=dp[i][j];
    for(int i=0;i<=m;i++)
        if(dp[n][i])ans++;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Yusani_huh (赞：18)

PS:做完题目一看题解全是递推，然后我整个人就懵了...

因为 **任意三线不共点**，所以除了平行线之外，任意两条直线都一定交在不同的交点上。也就是说，如果往一个已有 $m$ 条直线的平面中添加一条与其中任意一条直线都不平行的直线，就一定会增加 $m$ 个交点，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/zvf6cgib.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/r7dztxys.png)

但如果增加一条与某条（或某组）直线平行的直线，那么若原先这个方向上有 $p$ 条平行线，则会增加 $m-p$ 个交点，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/ozzocghe.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/c9zjf1ce.png)

所以重点就是求这些直线中有多少组直线互相平行，每组直线有几条的问题。

按照上述规律，我们可以将每组互相平行的直线数抽象为一个 $a$ 数组，之后对其进行计算。

举个栗子：

随便取一个 $a$ 数组：`1 1 2 3`，它表示这样一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zpr0tuhm.png)

总共七条直线，有两条直线和三条直线分别互相平行，另外两条直线则不与任何一条直线平行。

那么如何计算这样一个图的交点数？

首先看不与任何一条直线平行的直线，它们可以按照上面讲的第一种情况计算，即它们与其他每条直线都产生一个交点，所以为整个图贡献了 $7-1=6$ 个交点。

再看那两组平行线，它们可以按照上面讲的第二种情况计算，即每组平行线中的每条直线都与除了本组之外的每条直线产生一个焦点，所以三条直线的一组中，每条直线贡献了 $7-3=4$ 个交点；同理，两条直线的一组中，每条直线贡献了 $7-2=5$ 个交点。

将以上数据相加，因为每个交点都被重复计算了一次（两线确定一点），所以再除以二，即可得该图交点数：$\frac{6+6+4\times3+5\times2}{2}=17$ 个。

则一般地，对于 $n$ 条直线抽象成的有 $k$ 个元素的任意数组 $a$，我们可以得到下面一个求交点数 $S$ 的公式：

$$S=\frac{\sum^{k}_{i=1}a_i\times (n-a_i)}{2}$$

因为由我们对 $a$ 数组的定义可知 $\sum^k_{i=1}a_i=n$，所以化简得：

$$S=\frac{n^2-\sum^{k}_{i=1}a_i^2}{2}$$

至于为什么这个公式中的 $S$ 一定是个整数，或许可以交给大家自己思考一下。

那么接下来就是用 DFS 搜出所有可能的 $a$ 数组，之后代入公式计算，求出不同交点数的数量就行了。

直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h[33],ans;
bool f[703];
void dfs(int k,int sum){
	if(sum==n){
		int cnt=n*n;
		for(int i=1;i<k;++i){
			cnt-=h[i]*h[i];
		}
		cnt/=2;
		if(!f[cnt])
			ans++,f[cnt]=true;
		return;
	}
	for(int i=h[k-1];i<=n-sum;i++){
		h[k]=i;
		dfs(k+1,sum+i);
	}
}
int main(){
	scanf("%d",&n);
	h[0]=1,dfs(1,0);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：NXYorz (赞：9)

[原题地址](https://www.luogu.com.cn/problem/P2789)

好像还没有$DFS$题解。

首先可以分析一下题目性质：不存在三线共点。也就是说对于任意两条不平行的直线，它们必定会产生新的交点。

那么任意两条直线间无非就是相交或者平行。如果两条直线相交，那么产生1个交点。如果$1$条直线与$a$条平行的直线相交那么就产生$a$个交点，如果$a$条平行的直线与$b$条平行的直线相交，那么就有$a\times b$ 个交点

我们可以进行$DFS$每一次找有哪些可能平行的直线。然后算出交点数，最后用$f(i)$表示有可能产生$i$个交点的情况。

$DFS$之后循环枚举一遍$f(i)$，统计答案即可。

```cpp
#include<iostream>
#include<cstdio>
#define N 26
using namespace std;
int n,s;
bool f[N*N];
void dfs(int x,int sum)
{
    if(sum==0) {f[s]=1;return;}
    for(int i=1;sum-i>=0;i++)
    {
        s+=x*i;
        dfs(x+i,sum-i);
        s-=x*i;
    }
}
int main()
{
    freopen("aa.in","r",stdin);
    scanf("%d",&n);f[0]=1;
    dfs(0,n);int ans=0;
    for(int i=0;i<=n*n;i++)
        if(f[i]) ans++;
    printf("%d",ans);return 0;
}
```

---

## 作者：呆瓜yy (赞：6)

**注意：此题无三线共点！**(~~为此我卡了很久QAQ~~)

求交点数关键是知道相互平行的直线数。我是用递归(没错！就是最好用的**DFS**)枚举有（n-surplus）条直线平行的情况。n条不相互平行且无三条直线交于一点的直线交点数为n*(n-1)/2（~~小学鸡的知识~~）; 一条直线与n条平行线相交，交点数为n（~~傻瓜都知道~~）。


当有i条直线平行时，我们无法知道剩下的直线中有几条相交，有几条平行。因此，我们需要用递归枚举所有的情况。

```cpp
#include<cstdio>
  
using namespace std;

int n,s;

bool already[500];

//防止重复（其实我也不知道有没有用）

void how_many(int surplus,int now_s) 

//surplus是剩余的直线数，  now_s是当前的总交点数。

{

         if(surplus==0) 
         
        {
        
    	    if(!already[now_s])
            
    	       s++;
               
    	    already[now_s]=true;
            
    	    return;
            
	    }
        
	     for(int i=1;i<=surplus;i++)
         
	       how_many(surplus-i,now_s+i*(n-sur));
           
           //继续用递归枚举剩余直线的交点情况。
  
}

int  main()

{

	     scanf("%d",&n); 
         
	     how_many(n,0);
         
	     printf("%d",s);
         
	     return 0;
    
}
```

---

## 作者：jiangyu98 (赞：5)

核心思想：i 条线的情况可以划分为 j (1<=j<=i-1)条线加上均不与这 j 条线平行的 i - j 条平行线这 i - 1种情况 。i - j 条平行线会与这 j 条线 产生 j * (i - j) 个交点，j 条线的情况又可以继续划分为小情况。因此，该问题可以转化为顺推求解的动态规划问题。
j
其中，dp[i][j] 记录着用 i 条线段能否构成 j 个交点。

该算法的时间复杂度O(n^4) ，n = 300 时，计算约0.6s 。


```cpp
#include <iostream>
#include<ctime>

using namespace std;

#define MAXN 301

int N;
bool dp[MAXN][MAXN * (MAXN - 1) / 2 + 1]; //dp[i][j]记录着i条线段能否构成j个交点

/*N条线的情况可以借1...N-1条线的情况加不与上面的哪些线平行的平行线的方式得到*/
int solve(int N) {
    for (int i = 1; i <= N; i++) { //赋初值
        dp[i][0] = true;
    }
    for (register int i = 1; i <= N; i++) {
        for (register int j = 1; j < i; j++) {
            for (register int k = 0, max_k = j * (j - 1) / 2; k <= max_k; k++) {
                if (dp[j][k]) { //状态转移
                    dp[i][k + (i - j) * j] = true; //状态转移
                }
            }
        }
    }
    /*统计合法的case数*/
    int ret = 0;
    for (int i = 0, max_i = N * (N - 1) / 2; i <= max_i; i++) {
        if (dp[N][i]) {
            ret++;
        }
    }
    return ret;
}

int main() {
    cin >> N;
    cout << solve(N) << endl;
    return 0;
}
```


---

## 作者：__5112_4_8975__ (赞：2)

用 a[x,y]表示直线条数为x时，是否可以有y个交点。（是为1，否为0）。

n条直线相交，最多有n\*(n-1)/2个交点。

设i条直线相交，有j条平行，剩下(i-j)条相交于这j条直线。（1≤j≤i）

则共 ((i-j)\*j+k)个交点,其中k为(i-j)条直线相交可能的点数。

最后，只要统计a[n,i] (0≤i≤n\*(n-1)/2) 中可行方案的总数即可。

代码如下：

```cpp
var a:array[1..25,0..300]of longint;
n,m,i,j,k,ans:longint;
begin
        readln(n);
        fillchar(a,sizeof(a),0);
        for i:=1 to n do
        begin
                a[i,0]:=1;
                for j:=1 to i do
                begin 
                        m:=i-j;
                        for k:=0 to (m*(m-1)) div 2 do
                                if a[m,k]=1 then a[i,m*j+k]:=1;
                end;
        end;
        ans:=0;
        for i:=0 to (n*(n-1))div 2 do 
                if a[n,i]=1 then inc(ans);
        writeln(ans);
end .
```

---

## 作者：fyz2006 (赞：2)

首先大致梳理一下题目的意思：

有n条直线，其中有的直线可能平行，但保证每三条直线不交于一点，求这n条直线的交点数量有多少种可能。

### 什么叫做每三条直线不交于一点？

其实就是，每条直线都恰好与每条其他不与这条直线平行的直线交于一点。

换句话说，如果现在有x条直线，则第x\+1条直线与他们相交（假设没有任何一条直线与该直线平行），必然可以得到x个交点。

## 问题来了，怎么解决平行的问题？

实际上，本题没有可以卡递归（n=25还是很小的）所以我们可以大胆地递归目前剩下来的直线数量，在每层递归里面循环枚举互相平行的直线数量。由上文的分析可以知道，如果总共有total条直线等待讨论，其中i条直线平行，那么这i条直线每条直线就会与其他total\-i条直线交于total\-i个点。所以i条直线总共和其他的直线交于i\*(total\-i)个交点。然后，这i条直线就彻底与其他total\-i条直线断绝了关系，也就是说，后面total\-i条直线之中有没有平行已经没有关系啦。然后就可以新的递归啦！（别忘了要去重哦）
********
我的代码如下
```
#include<bits/stdc++.h>
using namespace std;
bool ac_ak=true;
bool rec[310];//25*24/2=300;
int n;
int sum;
void dfs(int total,int ans)
{
	if(total==0)
	{
		sum+=(rec[ans]==false);
		rec[ans]=true;
		return;
	}
	for(int i=1;i<=total;i++)//i=1,实际上没有平行; 
		dfs(total-i,ans+i*(total-i));
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d",&n);
	dfs(n,0);
	printf("%d\n",sum); 
	return 0;
}
```

---


# 写程序

## 题目背景

zrz在写程序，他叫你帮他看看他的程序有没有问题。


## 题目描述

有一个若干行的程序，每一行只有一个命令，可能出现的命令有一下几种


int a[maxn]    声明一个数组，开头一定是int，不会是别的什么longlong之类的，a是指一个数组的名称（不一定是a，也有可能是别的字母或者多个字母，总之长度不超过10），后面是一个中括号和一个数字或一个变量，表示数组大小（从0到maxn-1，maxn<=100），数组声明之后里面的数均为0。




a[i] h  把h赋给a[i]（也就是a[i]=h），同样h可能是一个数字或者是一个变量，i代表一个数字或者是一个变量。


cout h 输出h，h一定是个变量。


## 说明/提示

行数不会太多的，变量可能嵌套，如 a[a[b[0]]]等等，也有可能出现大写字母，所有的出现的数字不会超过10^9，也不会是负数，更不会是小数。


## 样例 #1

### 输入

```
int a[10]
a[a[0]] 2
cout a[0]```

### 输出

```
2```

## 样例 #2

### 输入

```
int a[10]
a[0] 10
cout a[0]
a[a[0]] 1
cout a[0]```

### 输出

```
10
-1```

# 题解

## 作者：1124828077ccj (赞：11)

疯狂模拟，注意细节处理，判断变量嵌套的时候可以用递归完成，顺便判断是否合法

附上代码（函数名是我的名字哦，所以别抄代码哈）

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<string>
using namespace std;
char s[100][100],a[100],b[100],t[100];
int l[100],p[100][100],y,w,ww,h,hh;
int ccj(string r,int x,int yy){
    if (r[x]>='0' && r[x]<='9')
    {
        int uuu=0;
        for (int i=x;i<=yy;i++)
        uuu=uuu*10+r[i]-'0';
        return uuu;
    }
    int www,e;
    char m[100];
    for (int i=0;i<100;i++)
    m[i]='\0';
    for (int i=x;r[i]!='[';i++,www=i)
    m[i-x]=r[i];
    for (int i=0;i<y;i++)
    if (!strcmp(m,s[i])){e=i;break;}
    int j=ccj(r,www+1,yy-1);
    if (j==-1 || j>=l[e])return -1;
    return p[e][j];
}
int main()
{
    while(scanf("%s%s",a,b)==2)
    {
        if (!strcmp(a,"int"))
        {
            for (int i=0;b[i]!='[';i++,w=i)
            s[y][i]=b[i];h=ccj(b,w+1,strlen(b)-2);
            if (h==-1){printf("-1");return 0;}
            l[y++]=h;
        }
        else if (!strcmp(a,"cout"))
        {
            h=ccj(b,0,strlen(b)-1);
            if (h==-1){printf("-1");return 0;}
            printf("%d\n",h);
        }
        else
        {
            for (int i=0;i<100;i++)
            t[i]='\0';
            for (int i=0;a[i]!='[';i++,w=i)
            t[i]=a[i];
            for (int i=0;i<y;i++)
            if (!strcmp(t,s[i])){ww=i;break;}
            h=ccj(a,w+1,strlen(a)-2);
            if (h==-1 || h>=l[ww]){printf("-1");return 0;}
            hh=ccj(b,0,strlen(b)-1);
            if (hh==-1){printf("-1");return 0;}
            p[ww][h]=hh;
        }
    }
    return 0;
}
```

---

## 作者：Exschawasion (赞：8)

作为一个热爱写解释器的half-oier，这点题~~一点也不~~难~~ \
让我们来分析一下这道题:
### 要素之一：如何保存变量？
解决方案：C++ STL中有一个叫做map的容器，它可以帮助我们做变量映射。\
（最令人高兴的是，它支持直接用[ ]赋值修改）\
\
那么，我们就写一个struct，把map的功能封装起来，形成一个“绑定”，取名叫做Binding。\
在Binding中要有GetVal，SetVal等函数来操作，还要有一个安全系统AccessController，来防范数组越界。（借用了Java中的概念）

### 要素之二：如何处理诸如array[array[4]]这样的嵌套？
\
请注意读题，本题中**不会出现表达式（比如a[1]+5）**\
这就很高兴了，让我们来仔细看看标题中举的例子：
```
array[array[4]]
  ^     ^   ^
 名字 名字 常量
```
我们可以发现，右括号一定是连在一起的，也就是不会出现array[array[4]+1]这样的表达式。\
\
也就是说，我们只要从左括号处分割字符串，遇到右括号时直接停止识别，用一个vector保存识别出来的名字即可。C++中没有返回vector的split函数……没办法，我们自己写吧。\
\
那我们split出来之后会是什么样的呢？
```
===============================
vector下标              值
0			array
1			array
2			4
===============================
```
所以，我们只需要**倒序**求值，以本标题为例，\
求出下标2的值后就可以求下标1的值，\
求出下标1的之后就可以求下标0的值，\
而下标0的值，就是我们要求的啦！\
\
注意一个小细节即可。第一个下标要特判成数字，把字符串转换成int的办法有很多，这里介绍一个简单的：
```cpp
string s = "54321";
int x = atoi(s.c_str());
```
### **至此，两大要素解决！**
但是要小心，遇到下标越界应当及时结束程序，本人的办法是用exit(0)，不过应该有更好的办法：\
就是在执行命令的函数里设定返回值，遇到错误时返回1，没有错误返回0，当返回值不为0时立刻break死循环并输出-1。
## 重头戏来了！上代码
```cpp
#include <bits/stdc++.h>

using namespace std;

//Exceptions will end the process.
void ThrowException() {
	cout << -1;
	exit(0);
}

//A struct that holds variables.
struct Binding {
	map<string, vector<int> > vars;
	
	//Check the sub return true if it is vaild.
	bool CheckAccess(string name, int loc) {
		if(loc < 0) return false;
		else if(loc >= vars[name].size()) return false;
		return true;
	}
	
	//Security holder, throw exceptions when accesses are invaild.
	void Security(string name, int loc) {
		if(!CheckAccess(name, loc)) ThrowException(); 
	}
	
	//Get the values.
	int GetVal(string name, int loc) {
		Security(name, loc);
		return vars[name][loc];
	}
	
	//Set the values.
	void SetVal(string name, int loc, int value) {
		Security(name, loc);
		vars[name][loc] = value;
	}
	
	//Make an array with given size and name.
	void MakeArray(string name, int size) {
		vars[name].resize(size);
	}
};

Binding bind;

//Get the value of expression.
int EvalExpression(string expr) {
	vector<string> names;
	int last = 0;
	
	if(isdigit(expr[0])) return atoi(expr.c_str());
	
	//Split the given expression to tokens.
	for(int i = 0; i < expr.length(); i++) {
		if(expr[i] == '[') {
			names.push_back(expr.substr(last, i - last));
			last = i + 1;
		}
		if(expr[i] == ']') {
			names.push_back(expr.substr(last, i - last));
			break;
		}
	}
	
	//Get the each value.
	int lastVal = atoi(names[names.size() - 1].c_str());
	for(int i = names.size() - 2; i >= 0; i--) {
		lastVal = bind.GetVal(names[i], lastVal); 
	}
	
	return lastVal;
}

//Run the command.
void Command(string command) {
	stringstream ss(command);
	vector<string> str;
	string s;
	while(ss >> s) str.push_back(s);
	
	if(str[0] == "int") {
		string token = str[1];
		string locs;
		string name;
		for(int i = 0; i < str[1].length(); i++) {
			if(str[1][i] == '[') {
				name = str[1].substr(0, i);
				locs = str[1].substr(i + 1, str[1].length() - i - 2);
				break;
			}
		}
		bind.MakeArray(name, EvalExpression(locs));
	}
	else if(str[0] == "cout") {
		cout << EvalExpression(str[1]) << endl;
	}
	else {
		string token = str[0];
		string locs;
		string name;
		for(int i = 0; i < str[0].length(); i++) {
			if(str[0][i] == '[') {
				name = str[0].substr(0, i);
				locs = str[0].substr(i + 1, str[0].length() - i - 2);
				break;
			}
		}
		bind.SetVal(name, EvalExpression(locs), EvalExpression(str[1]));
	}
}

int main() {
	string cmd;
	while(getline(cin, cmd)) Command(cmd);
	return 0;
}
```
第一次写题解，希望能帮到大家哦\
求通过求通过~




---

## 作者：AIH_NUI233 (赞：5)

# 洛谷 P2830

## 前言

一道小模拟

~~和某仙把能踩的坑全踩了 qwqqq~~

第一道模拟 && 第一篇题解

坑点总结（死亡方式大赏）**见文末**

------------

## 题意
* 模拟数组的操作，其中数组名称仅含大小写字母；

* 仅有 $3$ 种操作 `int`，`cout` 和赋值；

* 下标带有循环嵌套操作，如 `a[b[0]]`；

* 错误出现且仅出现数组越界（不存在负数下标情况）；

* 当出现错误时，输出 `-1` 后直接跑路。

------------


## 分析
* 使用了 `map<string,vector<int> >` 存数组信息（`map` 大法好）

* 开始直接硬刚

------------
## 解题
### 常用语句
由于这个 OIer 过于蒟蒻，他写的代码又臭又长，**其中竟然有组代码反复出现 $4$ 次**！

那就是寻找下标的代码，懒得包函数了 qwqqq
```cpp
//在完整代码中以St、Ed注释标记
string pos="";
string name="";
bool f=false;
for(int i=0;i<s.size()-1;i++){
  if(t[i]=='['&&(!f)) {
    f=true;continue;
  }
  if(f) pos=pos+t[i];
  else name=name+t[i];
}
int poss=getpos(pos);
if(poss<0||poss>=w[name].size()) return -1;
else ...
```

此代码同为 `getpos(string)` 函数的主要原理

~~（好傻，白白多了几十行代码 qwqqq）~~

------------

### 代码
码风清奇，见谅 awa

```cpp
//by_AIH_NUI_233
#include <bits/stdc++.h>
#define re register
using namespace std;
int p,cnt=0;
map<string,vector<int> > w; 
string s;

inline int getpos(string t){
    if(t[0]>='0'&&t[0]<='9'){
        int pos=0;
        for(re int i=0;i<t.size();i++)
            pos=pos*10+t[i]-'0';
        return pos;
    }
    else {
//      ---------St---------
        string pos="";
        string name="";
        bool f=false;
        for(re int i=0;i<t.size()-1;i++){
            if(t[i]=='['&&(!f)){
                f=true;
                continue;
            }
            if(f) pos=pos+t[i];
            else name=name+t[i];
        }
        int poss=getpos(pos);
        if(poss<0||poss>=w[name].size()) return -1;
        else return (w[name][poss]);
//      ---------Ed---------
    }
}

int main(){
    while(cin>>s){
        if(s=="int") {//int
            string nas;//s:"int" | nas:array[size]
            cin>>nas;
//      ---------St---------
            string name="";
            string size="";
            bool f=false;
            for(int i=0;i<nas.size()-1;i++){
                if(nas[i]=='['&&(!f)){
                    f=true;
                    continue;
                }
                if(f) size=size+nas[i];
                else name=name+nas[i];
            }
            int sizz=getpos(size);
            if(sizz<0){
                cout<<-1<<endl;
                return 0;
            }
            else{
                for(int i=0;i<sizz;i++) w[name].push_back(0);
            }
//      ---------Ed---------
        }
        else if(s=="cout") {//cout
            string t;//s:"cout" | t:array[pos]
            cin>>t;
            bool f=false;
//      ---------St---------
            string pos="";
            string name="";
            for(int i=0;i<t.size()-1;i++){
                if(t[i]=='['&&(!f)){
                    f=true;
                    continue;
                }
                if(f) pos=pos+t[i];
                else name=name+t[i];
            }
            int poss=getpos(pos);
            if(poss<0||poss>=w[name].size()){
                cout<<-1<<endl;
                return 0;
            }
            else cout<<w[name][poss]<<endl;
//      ---------Ed---------
        }
        else{//赋值
            string inf;//s:array[pos] | inf:值
            cin>>inf;
            bool f=false;
//      ---------St---------
            string pos="";
            string name="";
            for(int i=0;i<s.size()-1;i++){
                if(s[i]=='['&&(!f)){
                    f=true;
                    continue;
                }
                if(f) pos=pos+s[i];
                else name=name+s[i];
            }
            int poss=getpos(pos);
            if(poss<0||poss>=w[name].size()){
                cout<<-1<<endl;
                return 0;
            }
            else {
                int inff=getpos(inf);
                if(inff<0) {
                    cout<<-1;
                    return 0;
                }
                w[name][poss]=inff;
            }
//      ---------Ed---------
        }
    }
    return 0;
}
//by_AIH_NUI_233
```

------------




## 注意点总结
实际上**不存在坑点**，主要由于**读题的不仔细**，但还是把注意点罗列如下：

0. 使用 `while(cin>>s)`

1. `int` 语句数组大小可以是变量，存在循环嵌套与 `-1` 情况；

2. 赋值语句的值也可以是变量，同上；

3. 若你 RE 了，是没考虑到各处数值为变量的情况；

4. 若你 TLE 了，你算法就有问题导致无限循环了（与 3 点也有关）；

5. 若你 WA 了，检查 `-1` 判定。

$21$ 次的提交爆出血淋淋的教训 qwqqq



------------
## 后记

**感谢 @sto_yfz_orz 大佬**在做题过程中（67pts-91pts）给出的帮助

 _完结撒花_ 


---

## 作者：LIXE_115 (赞：4)

# P2830 写程序

真的调了好久……

把所有坑踩了一遍啊啊……

## 题目大意：

### 三种操作：

1. 定义一个数组，形如 `int a[10]`。

2. 给定 $a_{i}$ 赋值为 $h$。**注意 $h$ 可以为一个数字，也可以为一个变量（如 `a[0] a[5]`）！！！**

3. 输出变量 $h$。

**注意：允许出现类似于 `a[b[a[0]]]` 这样的循环嵌套！！！**

## 思路

### 存储

两个 map。

$addr$：存储数组名称，数组下标，该位置的值的大小。

$siz$：存储数组的大小，防溢出。

### 实现

单层嵌套的情况很简单，主要是多重嵌套的处理。

比如上面那个例子：`a[b[a[0]]]`。
定义其为 `string s`。

可以先将 $s$ 从右向左扫，当 $s_{i}$ 第一次为左中括号时记录 $i$ 并 `break` 掉。

后用一个 `find2` 函数，找到这个使用这个左中括号的数组名称。如输入 `a[0]` 找到 `a`。

同时将 $i$ 更新为下一个左中括号的位置，如此循环。**直到 $i<0$ 时**，返回最外一层的数组的名称与其下标。

### 然后就结束啦~~~


## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define re register
map<pair<string,int>,int>addr;//存储数组名称（pair.first），数组下标（pair.second），该位置的值的大小
map<string,int>siz;//存储数组的大小，防溢出
string a,b;
struct anss{string name;int sizee;};//方便存储
struct for_find2{string name;int wei;};//方便存储
inline for_find2 find2(string s,int it){//给定a[0]（s）与左中括号的下标（it），要找到a
    string ans;re int k;
    for(k=it;k>=0;k--){
        if(s[k]=='['||k==0){
            int Max=k+1;
            if(k==0) Max--;
            for(int i=Max;i<=it;i++){
                ans+=s[i];
            }
            break;
        }
    }
    return (for_find2){ans,k-1};
}
inline anss search(string s){//用于找到真正的地址，处理a[b[c[0]]]的情况
    int len=s.size();
    re int i;
    for(i=len-1;i>=0;i--){
        if(s[i]=='['){
            i++;break;
        }
    }
    int x=0;
    for(re int j=i;j<len;j++){//找到循环嵌套最内层的数字的值
        if(s[j]==']'){
            i-=2;break;
        }
        x=x*10+s[j]-48;
    }
    int si=x;//si为当前下标大小，初值为内部数字
    while(i>=0){
        for_find2 tt=find2(s,i);i=tt.wei;
        if(siz[tt.name]<=si){//出现越界，即下标超过当前数组的最大范围
            if(siz[tt.name]==false){//若为新定义数组情况
                return (anss){tt.name,si};
            }
            cout<<-1<<endl;exit(0);
        }
        if(i<0){
            return (anss){tt.name,si};
        }
        si=addr[make_pair(tt.name,si)];
    }
    cout<<-1<<endl;exit(0);
}
int main(){
    ios::sync_with_stdio(false);
    while(cin>>a>>b){
        if(a=="int"){
            anss type=search(b);
            siz[type.name]=type.sizee;
        }
        else if(a=="cout"){
            anss type=search(b);
            cout<<addr[make_pair(type.name,type.sizee)]<<endl;
        }
        else{//给数组赋值的情况
            anss type=search(a);
            if(b[0]>='0'&&b[0]<='9'){//处理a[10] 10这样的情况
                int x=0;
                for(re int i=0;i<b.size();i++){
                    x=x*10+b[i]-48;
                }
                addr[make_pair(type.name,type.sizee)]=x; 
            }
            else{//处理 a[10] b[a[5]] 这样的情况
                anss type2=search(b);
                addr[make_pair(type.name,type.sizee)]=addr[make_pair(type2.name,type2.sizee)];                 
            }
        }
    }
    return 0;
}
```

---

## 作者：_Spectator_ (赞：3)


[可能更好的食用体验](/blog/523641/P2830) $|$ 
[题目传送门](/problem/P2830) $|$ 
[我的其他题解](/blog/523641/#type=题解)

看到其他大佬们的程序实现都比较复杂，本蒟蒻在此写一篇比较简单的题解。

------------

${\large\color{#00CD00}\text{主要思路}}$

本题其实细节不多，这里只列举一些难点的实现方式，具体看代码注释。

- 存储数组：使用`struct`和`map`。
- 嵌套数组：递归实现，一层一层地展开，直到数组下标为常量为止。
- 赋值：可以让递归函数返回一个地址，这样祭可以用来赋值，又可以作数值参与其他运算。
- 数组越界：每次访问数组时进行一次判断，如果越界可以使用`exit(0)`直接终止程序。

~~现在，你可以尝试完成 [P3695](/problem/P3695) 了。~~

------------

${\large\color{#00CD00}\text{完整代码}}$

```cpp
#pragma G++ optimize(2)
#include<bits/stdc++.h>
using namespace std;
string st1,st2;　
struct stu//使用结构体和map控制数组 
{　
	int size,a[100];
	int& operator[](int p)//重载下标运算符方便访问，同时判断越界问题 
	{　
		if(p>=size)cout<<-1,exit(0);//exit(0)可以直接终止程序 
		return a[p];
	} 　
};　
map<string,stu>arr;
int s2i(string st)//将字符串转化为整形数字 
{　
	int ans=0;
	for(int i=0;i<st.size();i++)
		ans=ans*10+st[i]-48;
	return ans;
}　
int& calc(string st)//拆解嵌套数组，返回地址既方便直接赋值又可以作数值参与运算 
{　
	string name,num;int i;
	for(i=0;st[i]!='[';i++)name+=st[i];//将数组名称提取出来 
	for(i++;i<st.size()-1;i++)num+=st[i];//将数组的下标提取出来 
	if(isdigit(num[0]))return arr[name][s2i(num)];//如果下标为纯数字，直接返回 
	else return arr[name][calc(num)];//否则递归继续拆解 
}　
int main()
{　
	ios::sync_with_stdio(false);
	while(cin>>st1>>st2)
	{　
		if(st1=="int")//定义，与calc函数相似，不展开说明 
		{　
			string name,num;int i;
			for(i=0;st2[i]!='[';i++)name+=st2[i];
			for(i++;i<st2.size()-1;i++)num+=st2[i];
			if(isdigit(num[0]))arr[name].size=s2i(num);
			else arr[name].size=calc(num);
		}　
		else if(st1=="cout")//输出，题目保证输出一定是变量就不用分开判断了 
			cout<<calc(st2)<<endl;
		else //赋值，要分开纯数字与变量分开判断 
			if(isdigit(st2[0]))calc(st1)=s2i(st2);　
			else calc(st1)=calc(st2);　
	}　
	return 0;
}　
```

**[${\color{Black}\textbf{xt\_\_}}$](/user/523641) 温馨提示：**


${\large\color{White}\text\colorbox{#AD8800}{题解千万条，理解第一条。直接粘题解，棕名两行泪。}} $

---

## 作者：Raymondzll (赞：2)

## P2830 写程序

### 一道细节比较多的模拟题。

- 所有涉及到的数字都是变量，包括定义数组的时候。

- 超过数组大小直接返回。

- 据讨论区一些说法，会有名为 ```int``` 或 ```cout``` 的数组，不过我这个做法似乎并没有这样的问题。

### 解题思路

考虑怎么存下每个数组。

STL 大法好！

用一个 ```map<string,vector<int> >mp``` 存下数组名和数组元素的对应关系，访问时直接读取 mp[ 数组名 ] 中的元素。

### 函数解释

```bad()```：发生错误，输出 -1 并返回。

```getson(string,string,string)```：将```[```前后内容分离开来。

```toint(string)```：将字符串转成数字。

```expl(string)```：返回字符串对应的值，过程中发生越界会直接退出程序。

### 代码部分

**小声 bb：这是此题最优解&C++最短解，24ms，1.01KB。**

```cpp
#include <bits/stdc++.h>
using namespace std;
string a,b;
map<string,vector<int> >mp;
void bad(){
	cout<<"-1";
	exit(0);//在int main()外退出程序
}
void getson(string s,string& s1,string& s2){
	int i; 
	for(i=0;i<s.size();i++){
		if(s[i]=='[')break;
		else s1+=s[i];
	}
	i++;//跳过[
	for(;i<s.size()-1;i++)s2+=s[i];
}
int toint(string s){
	int res=0;
	for(int i=0;i<s.size();i++){
		res=res*10+s[i]-'0';
		if(res>1000000000)return -1;
	}
	return res;
}
int expl(string s){
	string tmp="",tmp2="";
	getson(s,tmp,tmp2);
	if(tmp2=="")return toint(s);//整个字符串都是数字
	int tmpp=expl(tmp2);//递归调用
	if(tmpp<0||tmpp>=mp[tmp].size())bad();
	return mp[tmp][tmpp];
}
int main(){
	while(cin>>a){
		cin>>b;
		if(a=="int"){
			string tmp="",tmp2="";
			getson(b,tmp,tmp2);
			int tmpp=expl(tmp2);
			mp[tmp]=vector<int>(tmpp);
		}else if(a=="cout"){
			cout<<expl(b)<<endl;
		}else{
			int k=expl(b);
			string tmp="",tmp2="";
			getson(a,tmp,tmp2);
			int tmpp=expl(tmp2);
			if(tmpp>=mp[tmp].size())bad();
			mp[tmp][tmpp]=k;
		}
	}
	return 0;
}
```

---

## 作者：huangx607087 (赞：2)

又是一道大模拟，还带字符串，花了我3个小时，Submit +=17。(~~比上次进步了，上次Submit += 18~~)

①：首先了解一下$substr$函数，它有2个参数x，y。```S.sutstr(x,y)```
表示从S[x]开始，向后y位的一个S的子串，如果x+y超过了$S.length()-1$，那么就取后面所有的内容

设S="0123456789"，T,R是string类型.那么
```
S.substr(1,5)="12345"
S.substr(0,7)="01234567"
S.substr(6,20000)="6789"
T=S.substr(0,7)//赋值T
此时：T.length=8
R=S.sutstr(6,9)//赋值R
此时：R.length=4
```
②：了解字符串是可以直接往后面加字符的
```
string S="asdfgh";
S+='j';
cout<<S;
//结果：asdfghj
```

③：然后，我们用上C++的map，就可以~~一点也不~~愉快地A这道题了
```
#include <bits/stdc++.h>
using namespace std;
string s1,s2;
map<string,int>sto;//storge，存容量
map<string,map<int,int> > val;//value，存数字，其中val["a"][3]=4表示a[3]的值是4
string stk[700];//栈
int top=1;//定义手写栈最好给个top吧，虽然没用
bool output=0;//是否已经输出过
int getnum(string S,int step)//递归求解【请原谅我瞄了一眼有且仅有的一片题解】
{
	stk[step]="";//很重要，一定要赋空串，不然就40分
	int i=0,Numm=0,fushu=0;
	if(S[i]=='-') fushu=1,i++;
	if(S[i]>=48&&S[i]<=57)//数字的ASCII
	{
		while(S[i]>=48&&S[i]<=57&&i<S.length())
		{
			Numm=Numm*10+S[i]-48;
			i++;
		}
		if(fushu) return -Numm;
		else return Numm;
	}
	while(S[i]!='[')
	{
		stk[step]+=S[i];
		i++;
	}
	int H=getnum(S.substr(i+1,607087),step+1);
	if(H<0||H>=sto[stk[step]]) return -1;
	else return val[stk[step]][H];
}
int main()
{
	int i,j;
	while(cin>>s1>>s2)
	{
		if(s1=="int")
		{
			i=0;
			string Name="";
			int Num=0;
			while(s2[i]!='[')
			{
				Name+=s2[i];//字符串可以直接加
				i++;
			}
			Num=getnum(s2.substr(i+1,607087),1);
			sto[Name]=Num;
		}
		if(s1=="cout")
		{
			int EW=getnum(s2,1);//取结果
			cout<<EW<<endl;
			output=1;
			if(EW==-1)
			{
				return 0;
			}
		}
		if(s1!="int"&&s1!="cout")
		{
			i=0;
			string Name="";
			int Num=0;
			while(s1[i]!='[')
			{
				Name+=s1[i];
				i++;
			}
			Num=getnum(s1.substr(i+1,607087),1);
			if(Num<0||Num>=sto[Name])
			{
				output=1;
				cout<<-1<<endl;
				return 0;
			
			}
			val[Name][Num]=getnum(s2,1);
		}
	}
	if(!output)
	{
		cout<<-1<<endl;//如果没输出一定要输出个-1，不然#3和#9会WA(无耻的特判)
	}
	return 0;
}
```


---

## 作者：FJ_OIer (赞：1)

> upd 2025.1.11：修改了一处小错误

~~STL 大法好！！！！！~~

大模拟。

对于定义数组，使用 map 套 vector：
```cpp
map<string,vector<int> > m;
```
这样定义的时候只要 `m[数组名].assign(数组长度,0)` 就可以了。

然后是变量。因为会有嵌套，使用递归，顺带检验是否合法：
```cpp
int *f(string s,int l){//为了方便我把函数做成了指针
    string name="";//数组名字
    int i;
    for (i=l;s[i]!='[';i++){
        name+=s[i];
    }
    if (!isdigit(s[i+1])){//有嵌套
        int *k=f(s,l+2);//递归
        if (*k>=m[name].size()){//检验（注意是大于等于）
            cout<<-1;
            exit(0);
        }
        return &m[name][*k];
    }
    string num="";//无嵌套，求出长度
    for (i++;s[i]!=']';i++){
        num+=s[i];
    }
    if (stoi(num)>=m[name].size()){//同上
        cout<<-1;
        exit(0);
    }
    return &m[name][stoi(num)];
}
```
代码中的 stoi 函数用于字符串转整数，不能用太老的编译器编译~~什么年代了还有人用 C++98~~。

其他没什么问题了。完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int i;
string a,b;
map<string,vector<int> > m;
int *f(string s,int l){
    string name="";
    int i;
    for (i=l;s[i]!='[';i++){
        name+=s[i];
    }
    if (!isdigit(s[i+1])){
        int *k=f(s,i+1);
        if (*k>=m[name].size()){
            cout<<-1;
            exit(0);
        }
        return &m[name][*k];
    }
    string num="";
    for (i++;s[i]!=']';i++){
        num+=s[i];
    }
    if (stoi(num)>=m[name].size()){
        cout<<-1;
        exit(0);
    }
    return &m[name][stoi(num)];
}
int main(){
    while (cin>>a>>b){
        if (a=="int"){
            string name="";
            for (i=0;b[i]!='[';i++){
                name+=b[i];
            }
            if (isdigit(b[i+1])){
                string num="";
                for (i++;b[i]!=']';i++){
                    num+=b[i];
                }
                m[name].assign(stoi(num),0);
            }else{//注意数组长度可能是变量
                m[name].assign(*f(b,i+1),0);
            }
        }else if (a=="cout"){
            cout<<*f(b,0)<<endl;
        }else{
            if (isdigit(b[0])){
                *f(a,0)=stoi(b);
            }else{
                *f(a,0)=*f(b,0);
            }
        }
    }
    return 0;
}
```

---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:P2830](https://www.luogu.com.cn/problem/P2830)

* **【解题思路】**

一道坑多的模拟题。

首先，我们搞清楚怎么模拟。

许多题解采用了一样的做法：

1. 用```struct```或自定义数组分配动态数组。

2. 用```map```把数组与名字关联起来。

3. 用一个递归函数处理数组下标。

4. 判断访问违规。如果确实，用```try```和```catch```或```exit(0)```退出程序。

现在我提供一个新的、可以使你的代码量缩小，~~并且还很玄学~~的方法（没错，我是本题目最短解〈$1.05KB$〉）$\color{white}\tiny Q\!w\!Q$：
用```vector```完成动态数组分配，用它的```at```加上```try```和```catch```完成越界检查。

为什么玄学？等会在实现细节里会说。

* **【实现细节】**

```unordered_map```：窝被泥萌抛弃了吗$Q\omega Q$

是的，我们并不关心数组名和数组组合的位置，所以可以用```unordered_map```。

在这个代码的```catch```块中，仅检测```out_of_bound```异常而不是用省略号捕捉所有异常，因为这样更容易发现bug（之前在本机测试，抛出了一个```bad_alloc```异常）。

注意，在代码中输入的第三种情况（$Line\ 41$）如果去掉中间那个$tmp$会$\color{red}\texttt{WA}$。所以，为什么说它玄学呢？

* **【代码实现】**

```cpp
#include <unordered_map>
#include <iostream>
#include <vector>
#include <string>
#include <cctype>

using namespace std;

unordered_map<string,vector<int>> arrays;
int result;

int& index_access(string index_str)//访问函数
{
	if(isdigit(index_str[0]))//如果开头是数字把它转成整数并返回
	{
		result=0;
		for(int i=0;isdigit(index_str[i]);i++)
			result=result*10+index_str[i]-'0';
		return result;
	}
	string result;//否则读取数组名，并用这个数组名访问元素
	for(int i=0;index_str[i]!='[';i++)
		result+=index_str[i];
	return arrays[result].at(index_access(index_str.substr(result.size()+1,index_str.size()-result.size()-2)));//at如果访问违规会抛出out_of_range异常
}

int main(int argc,char *argv[],char *envp[])
{
	string optype,param;
	int tmp;
	try
	{
		cin>>optype;
		while(cin)
		{
			if(optype=="int")//声明数组
				cin.get(),getline(cin,optype,'[')>>param,arrays[optype]=vector<int>(index_access(param));
			else if(optype=="cout")//输出
				cin>>optype,cout<<index_access(optype)<<endl;
			else//赋值
				cin>>param,index_access(optype)=tmp=index_access(param);//代码中最玄学的一行
			cin>>optype;
		}
	}
	catch(out_of_range& ecpt)//处理访问违规，结束程序
	{
		cout<<-1;
	}
 	return 0;
}

```

---

## 作者：七碳烷烃 (赞：1)

### 题目概要
我们需要构建一个题目中要求的命令解释器，如果出现数组越界则输出`-1`并退出。  
题目中只会出现数组越界这种异常。

### 解释器数据结构
观察题目可以发现，这个解释器只有**一种数据类型**：数组（其实也有整数，但是不能被声明为单独的变量），那么我们先写出一个数组类型的实现（为节省空间，使用动态分配内存（~~虽然在本题似乎没什么用~~））：
```cpp
struct Array {
    int len;
    int* data; // 数据存放
    Array(int len):len(len) {
        data = new int[len];
        for(int i = 0; i < len; i++) data[i] = 0; // 填零
    }
    ~Array() { delete[] data; } 
    // 对于new分配的空间要及时delete掉
    // 但是在本题用处不大
};
```
而变量名的存储查询，我们可以使用STL中的`map`类型，定义如下：
```cpp
map<string, Array*> varList;
```
### 解释器命令
接下来我们需要实现三种命令：
  - `int arrName[arrLen]` ：**声明**一个标识符为`arrName`且长度为`arrLen`的数组
  - `cout arrName[subscript]` : **输出**标识符为`arrName`的数组下标为`subscript`的元素
  - `arrName[subscript] expression` : 给标识符为`arrName`的数组下表为`subscript`的元素**赋值**为`expression`。  
  
需要注意的是，`arrLen`、`subscript`、`expression`都有可能不是字面量（形如`123`，`114514`的“**字面意义的**”量），而是一个表达式（在本题目中仅包含形如`a[x]`的取值操作，但是**可能嵌套**）。  
### 表达式的解析
#### 变量名与下标的解析
我们先考虑获取到我们需要操作的那个**数组的名字**和操作的**元素的下标**。这里出现的`resolve()`函数是**解析表达式的函数**，代码将在更下面给出。
```cpp
// 递归获取到变量名和下标
void separate(char* str, int l, int r, string& outname, int& subscript) {
    // 解析变量名
    outname = "";
    while(str[l] != '[') {
        outname += str[l];
        ++l;
    }
    // 解析下标
    subscript = resolve(str, l + 1, r - 1);
}
```
#### 表达式的解析
获取到变量名之后，我们还需要解析这里面的下标，由于下标可能是一个表达式，因此我们用一个``resolve()``函数来解析这个表达式。如果这个表达式出现了**数组越界等异常情况**，我们考虑使用`throw`语句来**抛出一个异常**。
```cpp
// 解析表达式
int resolve(char* str, int l, int r) {
    // 如果开头为数字，说明这一段一定是一个字面量
    if(str[l] >= '0' && str[l] <= '9') {
        int ret = 0;
        for(; l <= r; ++l) {
            ret *= 10;
            ret += str[l] - '0';
        }
        return ret;
    }
    // 否则就是表达式
    string arrName; int subscript;
    separate(str, l, r, arrName, subscript);

    Array* ap = varList[arrName];
    if(ap->len > subscript && subscript >= 0) // 判断是否下标越界
        return ap->data[subscript];
    else
        throw -1; // 我们考虑采用throw来引发异常，借此中断程序
        // 下文中的throw同理
}
```
需要注意这里和`separate()`函数虽然**相互调用**了，但是`resolve()`函数一定会在一个**字面量**上停止递归，所以不会出现爆栈的情况。
### 命令实现
这里的具体实现代码将会在后面给出。
#### 新建数组
我们对第二个参数使用`separate()`函数解析出变量名和下标，其中下标就是数组的长度。
~~这里我们还需要判断一下数组长度的合法性（需要大于0），但是题目中说只有下标越界，那我也不知道数据到底是怎么样的。为了解释器严谨一点还是写上去吧(x~~

然后我们就用这一句来在varList中定义一个新数组。
```cpp
varList[name] = new Array(len);
```
#### 输出
我们对第二个参数使用`resolve()`函数解析出表达式的值，然后输出就可以了。
#### 赋值
我们对第一个参数使用`separate()`解析出变量名和下标，对第二个个参数使用`resolve()`解析出要赋的值。通过变量名和下标就可以操作数组中的元素了。需要注意这里也需要判断下标的合法性。
### 注意事项
`throw`语句抛出异常必须要有一个`try..catch..`语句来承接，然后输出`-1`并退出，否则应该会RE。
### AC代码
```cpp
/* Headers */
#include <cstdio>
#include <iostream>
#include <cstring>
#include <map>
using namespace std;
/* Type and variables */

// c1 c2 分别为两个参数
char c1[5000];
char c2[5000];

// 数组类型
struct Array {
    int len;
    int* data; // 数据存放
    Array(int len):len(len) {
        data = new int[len];
        for(int i = 0; i < len; i++) data[i] = 0; // 填零
    }
    ~Array() { delete[] data; } 
    // 对于new分配的空间要及时delete掉
    // 但是在本题用处不大
};
map<string, Array*> varList;
/* Functions */

// 需要预先定义原型，因为“获取变量名和下标”和“解析表达式”的函数需要相互调用
void separate(char* str, int l, int r, string& outname, int& subscript);
int resolve(char* str, int l, int r);

// 递归获取到变量名和下标
void separate(char* str, int l, int r, string& outname, int& subscript) {
    // 解析变量名
    outname = "";
    while(str[l] != '[') {
        outname += str[l];
        ++l;
    }
    // 解析下标
    subscript = resolve(str, l + 1, r - 1);
}
// 解析表达式
int resolve(char* str, int l, int r) {
    // 如果开头为数字，说明这一段一定是一个字面量
    if(str[l] >= '0' && str[l] <= '9') {
        int ret = 0;
        for(; l <= r; ++l) {
            ret *= 10;
            ret += str[l] - '0';
        }
        return ret;
    }
    // 否则就是表达式
    string arrName; int subscript;
    separate(str, l, r, arrName, subscript);

    Array* ap = varList[arrName];
    if(ap->len > subscript && subscript >= 0) // 判断是否下标越界
        return ap->data[subscript];
    else
        throw -1; // 我们考虑采用throw来引发异常，借此中断程序，下文中的throw同理
}
// 新建变量
void setArray(char* str, int l, int r) {
    string name; int subscript;
    separate(str, l, r, name, subscript);
    if(subscript > 0) // 判断数组长度是否合理
        varList[name] = new Array(subscript);
    else
        throw -1;
}
/* Main */
int main() {
    try {
        while(scanf("%s%s", c1, c2) != EOF) {
            int l1 = strlen(c1), l2 = strlen(c2);
            if(!strcmp(c1, "int")) {
                setArray(c2, 0, l2 - 1);
                continue;
            }
            if(!strcmp(c1, "cout")) {
                printf("%d\n", resolve(c2, 0, l2 - 1));
                continue;
            }
            string arrName; int subscript;
            separate(c1, 0, l1 - 1, arrName, subscript);
            Array* ap = varList[arrName];
            if(ap->len > subscript && subscript >= 0) // 判断是否下标越界
                ap->data[subscript] = resolve(c2, 0, l2 - 1);
            else
                throw -1;
        }
    } catch (int ex) { // 如果引发异常就输出"-1"并退出
        printf("-1");
    }
    return 0;
}
```


---

## 作者：Alarm5854 (赞：1)

这道题目是一道模拟题，但是有坑点，如使用 `int` 数组或 `cout` 数组，而且还会出现 `int a[b[0]]` 这样的情况。然后就是怎样动态开数组了，我是这样弄的：用一个 `map` 来存储数组名所在的数组编号，用一个 `vector` 来存储每一个数组，套一个结构体，有数组和下标上限，运行过程中只要一个出现越界就输出 `-1`，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int a[111], cap;//cap就是我所说的数组大小上限
	node(int cap = 0): cap(cap){memset(a, 0, sizeof(a));}
	int& operator [](int n) {return a[n];}
};
vector<node> a;
map<string, int> ma;
string opt, arr, h; int cnt;
int getans(string arr) {
	if (isdigit(arr[0])) return stoi(arr);
	int det = 0, st = 1; string res, tmp, temp;
	while (arr[det] != '[') tmp += arr[det++]; ++det;
	while (st) {
		if (arr[det] == '[') ++st;
		if (arr[det] == ']') --st;
		res += arr[det++];
	}
	int k = getans(res);
	if (k >= a[ma[tmp]].cap) cout << -1, exit(0);
	return a[ma[tmp]][k];
}
int main() {
	while (cin >> opt) {
		if (opt == "int") {
			cin >> arr; string temp; int det = 0, st = 1; h = "";
			while (arr[det] != '[') temp += arr[det++]; ++det;
			while (st) {
				if (arr[det] == '[') ++st;
				if (arr[det] == ']') --st;
				h += arr[det++];
			}
			ma[temp] = cnt++, a.push_back(node(getans(h))); continue;
		}
		if (opt == "cout") cin >> arr, cout << getans(arr) << '\n';
		else {
			cin >> h, arr = opt;
			int det = 0, st = 1; string res, tmp, temp;
			while (arr[det] != '[') tmp += arr[det++]; ++det;
			while (st) {
				if (arr[det] == '[') ++st;
				if (arr[det] == ']') --st;
				res += arr[det++];
			}
			int k = getans(res);
			if (k >= a[ma[tmp]].cap) cout << -1, exit(0);
			else a[ma[tmp]][k] = getans(h);
		}
	}
	return 0;
}
```

---

## 作者：jqQt0220 (赞：0)

一眼丁真，鉴定为大%你（

细节不少，难度还行，就是有点坑，我调了半天。

我的思路：可以建立 std::map，映射一个 string 类型的变量名和数组，这里数组可以定义成结构体，里面存值和大小。找变量对应值可以用递归+字符串处理，再写个判越界和退出的函数，就差不多了。

坑点差不多如下：（这里只列出我踩的坑）
- 要一直读入到 EOF，也就是 `while(cin>>op)`；
- 数组要初始化，不然会输出一些奇奇怪怪的东西；
- 一定记得判越界；
- **所有**下标，包括定义时，都可能是变量；
- **sscanf 用不了**（我在这里卡了好久）；
- 数组用 vector 会 MLE 一个点；
- ……

差不多就这些，剩下的看代码。为了简洁一点，采用 C++11 以上的标准。
```cpp
/*
皇帝的新头文件&缺省源
*/
struct arr//数组的结构体类型
{
    int size;//大小
    array<int,110> val;//用这个 array 是为了方便初始化，vector 会 MLE，当然 val[110] 也可以
    arr(){}//一定要写这个默认构造函数，不然会 CE
    arr(int _size):size(_size)
    {
        val.fill(0);//std::array 自带 fill 函数
    }
};
map<string,arr> q;//STL 大法好！建立一个 map 映射库，映射数组名和数组内容
bool isnum(string s)//是不是数字
{
    for(auto p:s)
        if(!isdigit(p))
            return false;
    return true;
}
bool outrg(string name,int ptr)//是否越界
{
    return ptr>=q[name].size||ptr<0;
}
void error()//输出 -1 并退出程序
{
    cout<<-1<<endl;
    exit(0);
}
int value(string s)//递归找到变量对应的值
{
    if(isnum(s))//是数字直接返回
    {
        int num=0;
        for(auto p:s)
            num=num*10+p-'0';
        return num;
    }
    string name,ptr;//name 是数组名，ptr 是下标
    int t;
    for(int i=0;s[i]!='[';i++)//左中括号前面都是数组名
        name+=s[i],t=i;
    t++;//结束后 t 为左中括号前一个值的下标，移到左中括号上
    for(int i=t+1;i<s.length()-1;i++)//跳过左中括号，遍历到右中括号前面
        ptr+=s[i];
    int p=value(ptr);//这个下标可能也是变量，递归查询
    if(outrg(name,p))//越界了
        error();
    return q[name].val[p];//找到值
}
int main()
{
    ___();
    string op;//命令
    while(cin>>op)//读入到 EOF，即文件结束
    {
        if(op=="int")//定义
        {
            string s;
            cin>>s;
            string name,sz;//和函数里差不多
            int t;
            for(int i=0;s[i]!='[';i++)
                name+=s[i],t=i;
            t++;
            for(int i=t+1;i<s.length()-1;i++)
                sz+=s[i];
            int p=value(sz);
            q[name]=arr(p);//新建数组
        }
        else if(op=="cout")//输出
        {
            string s;
            cin>>s;
            string name,ptr;
            int t;
            for(int i=0;s[i]!='[';i++)
                name+=s[i],t=i;
            t++;
            for(int i=t+1;i<s.length()-1;i++)
                ptr+=s[i];
            int p=value(ptr);
            if(outrg(name,p))
                error();
            cout<<q[name].val[p]<<endl;//输出值
        }
        else//赋值
        {
            string name,ptr;
            int t;
            for(int i=0;op[i]!='[';i++)
                name+=op[i],t=i;
            t++;
            for(int i=t+1;i<op.length()-1;i++)
                ptr+=op[i];
            int p=value(ptr);
            if(outrg(name,p))
                error();
            string h;
            cin>>h;
            q[name].val[p]=value(h);//赋值，因为这个 h 可能是变量，所以要调函数
        }
    }
    return 0;//完美结束 QwQ
}
```

其实每个命令的操作都差不多，都是把数组名找出来，然后递归找出下标，最后操作对应的命令。细节挺多，总体来说我踩的坑还比较少。

---

## 作者：huangzhixia (赞：0)

## 题解
### 题意

我们可以看到题目，题目中有三种操作。

- 定义一个数组，题目中说数组名会不一样，这里方便讲解，把他定义成 $a$ 吧。

- 给我们的 $a$ 数组中的某一个**下标上的元素赋值**为 $h$。

- 将数组中的某个元素**输出**。

我们就**模拟**这些操作，就完成了题目啦！

### 思路

#### 存储
首先，这题直接使用 ```map```。

我们的 ```map``` 是用来存储数据信息的，就不是很麻烦。

#### 模拟

接着进行模拟，记得**题目叫我们做的一定做没叫我们做的千万不要做**。

### 注意事项

要注意以下细节：

- 根据样例可得知，我们的 ```a[a[0]]``` 也是可以赋值输出的！里面的下标是可以嵌套的。

- 还有，仔细读题可知，当我们发现数组下标越界了时，务必输出 ```-1```。

- 这种题的读入，可以学楼下大佬们的 ```while(cin>>s)```。

### code:


```c
// 这里就不放注释了 
#include<bits/stdc++.h>   

#define o register

using namespace std;
 
struct ans	{ 
	string name;
	int lpo;
};

struct find_ {
	string name;
	int pui;
};
map<pair<string,int>,int> pop;

map<string,int> pre;

string s1, s2;

inline find_ calc1 (string s, int it){
    string ans;
	o int k;
    for (k = it; k >= 0; k--){
        if (s[k] == '[' || k == 0){
            int Max = k + 1;
            if (!k) 
				Max -= 1;
            for (int i = Max; i <= it; i++)
                ans += s[i];
            break;
        }
    }
    return (find_) {
		ans, k - 1
	};
}

inline ans calc2 (string s){
    int len = s.size();
    o int i;
    for (i = len - 1; i >= 0; i--){
        if (s[i] == '['){
            i += 1;
			break;
        }
    }
    int x = 0;
    for (o int j  = i; j < len; j++){
        if (s[j] == ']'){
            i -= 2;
			break;
        }
        x = x * 10 + s[j] - 48;
    }
    int si = x;
    while (i >= 0){
        find_ tt = calc1(s, i); 
		i = tt.pui;
        if (pre[tt.name] <= si){
            if (!pre[tt.name]){
                return (ans){
					tt.name, si 
				};
            }
            printf("-1\n");
			exit(0);
        }
        if (i < 0)
            return (ans){
				tt.name, si
			};
        si = pop[make_pair(tt.name, si)];
    }
    printf("-1\n");
	exit(0);
}        

int main(){
    ios::sync_with_stdio(false);
    while (cin >> s1 >> s2){
        if (s1 == "int"){
            ans type = calc2(s2);
            pre[type.name] = type.lpo;
        }
        else 
		if (s1 == "cout"){
            ans type = calc2(s2);
            cout << pop[make_pair(type.name,type.lpo)] << endl;
        }
        else{
            ans type = calc2(s1);
            if (s2[0] >= '0' && s2[0] <= '9'){
                int x = 0;
                for (o int i = 0; i < s2.size(); i++)
                    x = x * 10 + s2[i] - 48;
                pop[make_pair(type.name,type.lpo)] = x; 
            }
            else{
                ans type2 = calc2(s2);
                pop[make_pair(type.name, type.lpo)] = pop[make_pair(type2.name, type2.lpo)];                 
            }
        }
    }
}
// 求管理员大大给过 
```


---

## 作者：_zuoqingyuan (赞：0)

# 题面：
[传送门](https://www.luogu.com.cn/problem/P2830)

# 分析：
对于一个数组的储存，可以用结构体和 map 来实现。如果在递归过程中，出现错误，直接是用 exit() 来结束程序。对于求变量和常量的值，可以统一用一个函数解决。
# Code
```cpp
#include <iostream>
#include <cstring>
#include <map>
#include <cstdlib>
#include <cstdio>
using namespace std;
struct node{
    int si,at[105]={0};
};//结构体
map <string,node> mp;
string s1,s2;
int p1,p2;
int get(string s){//求常量和变量的值
    int cnt=0,it2=s.size()-1,it1=0;
    if(s[0]>='0'&&s[0]<='9'){//如果是常量
        for(int i=0;i<=it2;i++)cnt=cnt*10+s[i]-'0';
        return cnt;
    }else{//如果是变量
        while(s[it1]!='[')it1++;
        int t=get(s.substr(it1+1,it2-it1-1));//递归求解
        if(t>=mp[s.substr(0,it1)].si){//越界，错误语句
            printf("-1\n");
            exit(0);//终止程序
        }
        else return mp[s.substr(0,it1)].at[t];
    }
}
int main(){
    while(cin>>s1>>s2){
    	p1=p2=0;
        if(s1=="int"){//定义语句
            while(s2[p1]!='[')p1++;p2=s2.size()-1;
            string str=s2.substr(0,p1);//变量名
            int t=get(s2.substr(p1+1,p2-p1-1));//变量大小
            mp[str].si=t;
        }else if(s1=="cout"){
            printf("%d\n",get(s2));//直接输出
        }else{
            int j1,j2=j1=0,t2;
            while(s1[j1]!='[')j1++;j2=s1.size()-1;
            string str=s1.substr(0,j1);
            int t=get(s1.substr(j1+1,j2-j1-1));
            if(t>=mp[str].si){//判断是否越界
                printf("-1\n");
                exit(0);
            }
            t2=get(s2);
            mp[str].at[t]=t2;
        }
    }
    return 0;
}
```
如有错误，请指出。

---

## 作者：HowardWang (赞：0)

# 洛谷 P2830

## 前言
 蒟蒻在 [P2830 写程序](https://www.luogu.com.cn/problem/P2830) 的题解中发现有很多人说这题细节很多，但是本人觉得这一题细节反而不多。为什么呢？

其实这一道模拟题考察的并不是诸多的细节，而是原原本本地把题目的每一个步骤按题目的意思给还原。这一题最大的难点在于自己把程序给复杂化了。
 
下面就是本蒟蒻的做法：
## 题意
这一题是一道典型的模拟题，类似模拟一种编程语言，需要实现以下三种操作：
* **定义数组**：用语句 `int a[maxn]` 声明一个数组。$a$ 是指一个数组的名称（一个长度不超过 $10$ 的字符串）。后面是一个中括号和一个数字或一个变量，表示数组大小（从 $0$ 到 $maxn-1$，$maxn<=100$ ），数组声明之后里面的数均为 $0$。
* **元素赋值**：用语句 `a[i] h` 表示把 $h$ 赋给 $a_{i}$ （也就是 $a_{i} = h$），同样 $h$ 可能是一个数字或者是一个变量，$i$ 代表一个数字或者是一个变量。
* **输出**：用语句 `cout h` 输出 $h$ , $h$ 一定是个变量。
## 写题基础：STL容器——map
在这一题，我们首先会需要用一个**字符串**来“代表”（专业术语是“ 映射”）一个**数组**。平常的数组中，我们只能用一个较小的整数来代表一个数组中的元素或数组。但是我们使用容器 `map` 就可以解决这个问题。`map` 定义方法：

```cpp
map<type1,type2> m;

```

其中，我们可以用 `type1` 来“代表”`type2` 的元素，而两种类型都不只能是基本类型，可以是结构体等，甚至是 `map` 本身（本题会用到）。


具体请见 [OI Wiki](https://oi-wiki.org/lang/csl/associative-container/) 中的 `map`。
## 题目思路：
拿到这一题，蒟蒻首先就想到了使用 `map` 来表示题目中定义的每一个数组。


我们马上确定了 `map` 的第一个类型是字符串（`string` 类型）。那么我们该怎么让 `type2` 成为一个数组，来模拟题目中的操作呢？


这个时候，我们如果把 `type2` 也定义成一个和数组一样的 `map`（即用 `int` 类型来映射 `int` 类型的 `map`），就可以解决这个问题。


接着，我们还会需要另一个 `map` 来储存数组的最大长度，方便判断数组访问是否越界。


第二个问题是，我们该如何求一个层层嵌套的数组最终的值呢？


我们首先可以想到嵌套就要用递归来解决。首先，我们要能够读取数组的名称。由于 `string` 类型支持加上一个字符的操作，这题就方便多了：只要把原字符串中的字符一一加到一个空字符串里，直到出现一个 `[` 字符即可停止。


然后，若读入的是字符串而非数字，则记录下此时遍历到第几个字符了，然后进行下一层递归，再用返回值找到其对应的变量的值，将其作为返回值再返回；若找到的是数字，则计算出数字的值后返回这个数值即可。


再来就是定义操作和赋值操作输入的第一个字符串，由于是它们被定义或是被重新赋值，我们需要把它的最外层的“皮”给“剥”下来，再计算里面的字符串的值。我们可以先用类似之前的操作把第一个数组名记下来，然后再处理之后的字符串。


还有就是再递归途中遇到了数组越界，我们就会需要一个全局 `flag`，每次主函数执行完求值后都要看一下 `flag` 是否变化，有变化则立马输出 `-1` 并 `return` 就行了。


有了以上几点，我们就可以轻松实现定义、赋值、输出了。
## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
string c;
string cc;
string all;//专门用于计算一个嵌套数组的值的字符串 
map<string,map<int,int> > v;//用string映射一个类似数组的东西 
map<string,int> m;//map储存数组长度 
bool flager;//全局flag，用于判断是否越界 
int getnum(int beg)//beg为下一轮计算的起始点 
{
	string s;
	s.clear(); 
	int k=beg;
	while(k<all.size()&&all[k]!='[')
	{
		s+=all[k];
		k++;
	}//分离变量名 
	
	if(s[0]<'0'||s[0]>'9')//是变量名，继续往里 
	{
		int val=getnum(k+1);
	
		if(val>=m[s])
		{
			flager=1;
			return 0;//越界了
		}
		else
		{
			return v[s][val];//返回其所映射的值
		}
	}
	else//是数字，递归结束 
	{
		int p=0;
		int t=0;
		while(p<s.size())
		{
			t=t*10+s[p]-'0';
			p++;
		}//计算数字值 
		
		return t;
	}
}
int main()
{
	string s;
	while(cin>>c)
	{
		if(c=="int")//定义操作 
		{
			s.clear(); 
			all.clear();//一定要记得随时清空！！！
			cin>>cc;
			int i=0;
			while(i<cc.size()&&cc[i]!='[')
			{
				s+=cc[i];
				i++;
			}//剥出第一层数组名 
			i++;//跳过'['字符 
			while(i<cc.size()&&cc[i]!=']')
			{
				all+=cc[i];
				i++;
			}//准备计算 
			m[s]=getnum(0);
			if(flager)
			{
				printf("-1");
				return 0;
			}
			for(int j=0;j<m[s];j++)
			{
				v[s][j]=0;
				
			}//初始化为0，其实好像不加也行。 
			
		}
		else if(c=="cout")//输出操作 
		{
			all.clear();
			cin>>cc;
			int i=0;
			while(i<cc.size()&&cc[i]!=']')
			{
				all+=cc[i];
				i++;
			}//准备计算 
			int temp=getnum(0);
			if(flager)
			{
				printf("-1");
				return 0;
			}
			cout<<temp<<endl;
		}
		else//赋值操作 
		{
			s.clear();
			all.clear();
			cin>>cc;
			int i=0;
			while(i<c.size()&&c[i]!='[')
			{
				s+=c[i];
				i++;
			}//剥出第一层数组名 
			i++;//跳过'['字符 
			while(i<c.size()&&c[i]!=']')
			{
				all+=c[i];
				i++;
			}
			int temper=getnum(0);
			if(flager||temper>=m[s])//一定不要忘记判断是否越出了被赋值数组的边界！！！ 
			{
				printf("-1");
				return 0;
			}
			all.clear();
			i=0;
			while(i<cc.size()&&cc[i]!=']')
			{
				all+=cc[i];
				i++;
			}//计算要赋予前一个元素的值 
			int temp=getnum(0);
			if(flager)
			{
				printf("-1");
				return 0;
			}
			v[s][temper]=temp;//赋值 
		}
	}
	return 0;
}
```
由于本蒟蒻码风清奇，及其冗长，请各位大佬原谅。
## 后记
坑点1：题目可能以 `cout` 或 `int` 作为变量名，但由于我们直接判断输入的第一个字符串是否是 `int` 或 `cout` ，就不会出现这类问题。


坑点2：题目的所有元素均有可能是数组中的元素，所以一定要读题仔细啊！


其他的一些坑点就是个人算法的一些问题了。总之，这题只要不自己把题目搞复杂（比如 `map` 的 `type2` 用 `vector` ，再用一个 `map` 来映射其下标之类的），这一题还是很好做的。


这是本蒟蒻第一次写题解，如有不足之处，请各位大佬指正。

---

## 作者：xujingyu (赞：0)

毒题，调了两天……

一道绿模拟，这里分享一下蒟蒻的原始做法。

## 思路

多行输入。需要用的：

```cpp
map <string,node> mp;
int num[1001][1001];
```

1. `map`，根据字符串查找名为这个字符串的数组的长度和 `id`。
2. `num`,根据字符串的 `id` 和下标返回对应下标的值。

对于每次输入，

* 若是 `int` 定义一个数组，用 `map` 储存长度。
* 若是 `cout` 输出，递归查询访问的数组下标。访问过程中，若遇到越界情况（即访问的下标大于该数组名的字符串在 `map` 中的值），立马结束程序。否则输出对应的值。
* 若是赋值，也是递归访问该下标，直接赋值。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node//字符串的id和长度
{
	int id,siz;
};

struct chuan
{
	string str;
	int num;
};

map <string,node> mp;
int num[1001][1001],tot;
string s,s1;

int number(string x)//获取数字
{
	int ret = 0;
	for(int i = 0;i < x.size();i++)
	{
		ret = ret * 10 + (x[i] - '0');
	}
	return ret;
}

string jie(string x,int l,int r)//存串
{
	string ret = "";
	for(int i = l;i <= r;i++) ret += x[i];
	return ret;
}

chuan get(string x,bool flag)//递归函数
{
	chuan ret;
	ret.str = "";
	int sit = 0;
	for(int i = 0;i < x.size();i++)
	{
		if(x[i] == '[')
		{
			sit = i;
			break;
		}
		ret.str += x[i];
	}
	ret.num = 0;
	for(int i = sit + 1;i < x.size();i++)
	{
		if(x[i] == ']') break;
		else if(x[i] >= '0' && x[i] <= '9') ret.num = ret.num * 10 + (x[i] - '0');//获取数字
		else
		{
			chuan lin = get(jie(x,i,x.size() - 2),0);//得到下标
			if(lin.num >= mp[lin.str].siz && !flag)//越界
			{
				printf("-1");
				exit(0);
			}
			ret.num = num[mp[lin.str].id][lin.num];//直接赋值
			break;
		}
	}
	return ret;
}

signed main()
{
	while(cin >> s >> s1)//循环输入
	{
		if(s == "int")
		{
			chuan ing = get(s1,0);
			mp[ing.str].id = ++tot;
			mp[ing.str].siz = ing.num;
		}
		else if(s == "cout")
		{
			chuan ing = get(s1,0);
			if(ing.num >= mp[ing.str].siz)
			{
				printf("-1");
				return 0;
			}
			printf("%d\n",num[mp[ing.str].id][ing.num]);
		}
		else
		{
			chuan ing = get(s,0);
			if(ing.num >= mp[ing.str].siz)
			{
				printf("-1");
				return 0;
			}
			int value;
			if(isdigit(s1[0])) value = number(s1);
			else
			{
			    chuan sub = get(s1,0);
			    if(sub.num >= mp[sub.str].siz)
			    {
			    	printf("-1");
			    	return 0;
			    }
			    value = num[mp[sub.str].id][sub.num];
			}
			num[mp[ing.str].id][ing.num] = value;
		}
	}
	return 0;
}
```


---

## 作者：allqpsi (赞：0)

### 大模拟！

对对对，这道题就是个大模拟！

## 题目大意：
给你，三种输入的代码：

定义，定义一个新的数组，定义它的名字和边界。

赋值，给一个数组里面的一个数赋值。

输出，输出一个数组中的一个数。

如果数组越界了，就停止程序。

## 思路：

我们可以用 map 来储存每个数组，访问时用 string 来访问对应的数组。

然后，我们可以在数组的第 100 位来储存它的边界。

接着，用递归访问输入，遍历中括号里面的变量，只到它是一个数为止。

我们再检查它有没有在某一处越界。

最后，在对应的数组里面在对应的地方做操作就行了。
### 注意：

本题细节有点多，慢慢打别着急。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int vi[105];
};
//定义map
map<string,node>mi;
string a,b,s;
int dfs(string x){//递归访问输入
	if(isdigit(x[0])){
		int y=0,v=0;
		while(isdigit(x[y])){
			v*=10;
			v+=x[y]-'0';
			y++;
		}
		return v;
	}
	string b="",s="";
	int l=-1,k;
	while(x[++l]!='['){
		b+=x[l];
	}
	while(l<x.size()-2){
		l++;
		s+=x[l];
	}
	k=dfs(s);
	if(k>=mi[b].vi[100]||k==-1||k>=100){
		return -1;
	}
	return mi[b].vi[k];
}
int main(){
	while(cin>>a){
		if(a=="int"){//输入
			cin>>b;
			a="";
			int l=-1,c=0;
			while(b[++l]!='['){
				a+=b[l];
			}
			l++;
			if(isdigit(b[l])){
				int u=0;
				for(int i=l;i<b.size()-1;i++){
					u*=10;
					u+=b[i]-'0';
				}
				mi[a].vi[100]=u;
				continue;
			}
			string h="",s="";
			l--;
			while(b[++l]!='['){
				h+=b[l];
			}
			l++;
			while(l<b.size()-2){
				s+=b[l];
				l++;
			}
			if(dfs(s)==-1||dfs(s)>=mi[h].vi[100]||dfs(s)>=100){
				cout<<-1;
				return 0;
			}
			mi[a].vi[100]=mi[h].vi[dfs(s)]; 
		}
		else if(a=="cout"){//输出
			cin>>a;
			b="";
			s="";
			int l=-1;
			while(a[++l]!='['){
				b+=a[l];
			}
			while(l<a.size()-2){
				l++;
				s+=a[l];
			}
			if(dfs(s)==-1||dfs(s)>=mi[b].vi[100]||dfs(s)>=100){
				cout<<-1;
				return 0;
			}
			cout<<mi[b].vi[dfs(s)]<<endl;
		}
		else{//赋值
			b="";
			s="";
			int l=-1;
			while(a[++l]!='['){
				b+=a[l];
			}
			while(l<a.size()-2){
				l++;
				s+=a[l];
			}
			if(dfs(s)==-1||dfs(s)>=mi[b].vi[100]||dfs(s)>=100){
				cout<<-1;
				return 0;
			}
			int o=dfs(s);
			cin>>a;
			if(isdigit(a[0])){
				int u=0;
				for(int i=0;i<a.size();i++){
					u*=10;
					u+=a[i]-'0';
				}
				mi[b].vi[o]=u;
				continue;
			}
			string h="";
			s="";
			l=-1;
			while(a[++l]!='['){
				h+=a[l];
			}
			while(l<a.size()-2){
				l++;
				s+=a[l];
			}
			if(dfs(s)==-1||dfs(s)>=mi[h].vi[100]||dfs(s)>=100){
				cout<<-1;
				return 0;
			}
			mi[b].vi[o]=mi[h].vi[dfs(s)];
		}
	}
}
```


---

## 作者：nvqlfi214 (赞：0)

# 题解 P2830 【写程序】
$submit+=6$ $AC+=1$……

- __初步分析__

操作有三种：

```
int 数组名[数据]
```
```
cout 数组名[数据]
```
```
数组名[数据] 数据
```

我们会发现有很多个`数据`，所以可以把它当作一个进行处理。

我们还可以得到以下伪代码：
```cpp
while(cin>>操作){
	if(操作=="int")新建();
	else
	if(操作=="cout")输出();
	else{
		获得正在操作的变量();
		获得下标();
		cin>>数据;
		获得数据();
		变量[下标]=数据;
	}
}
```
- __如何储存？__

可以使用结构体：
```cpp
struct student{
	char name[];
	int size;
	int element;
	int var[];
}
student array[];
```
然后我们会发现```变量[下标]=数据;```错了。

$fix$：```array[变量所处位置].var[下标]=数据```。

- __处理变量嵌套__

与[P1738](https://www.luogu.com.cn/problem/P1738)类似，将 '[' 作为分隔。

Q：那后面的 ']' 呢？

A：你可以发现后面的 ']' 都是连在一块的。

~~好无聊。~~

以 ```a[a[b[0]]]```为例，可以把它分割成`"a"`，`"a"`，`"b"`，`"0"`。

把`"0"`转换成`0`。

找到`"b"`所在的位置，获得`b[0]`并储存`b[0]`的数据，以此类推。

- __特殊情况__

是在```数组名[数据] 数据```时,不要把所有数据都解析出来，要在最前面的位置找到后就停止。

因为这是`数组名`，不是`数据`；

还是在```数组名[数据] 数据```。

这个时候`数据`可能是一个常数。~~当然其实没什么区别。~~ 所以这里也要处理以下。

- ~~__最后完结撒花！__~~

---

## 作者：Mine_King (赞：0)

这题需要记录数组的名称、大小和数组内每个位置的数，那么我们不妨开一个`map`，可以解决名称是字符串的问题。
```cpp
struct node
{
	int len;
	int num[105];
};
map<string,node>mp;
```
然后呢，对于每个题目给出的变量，我们可以把他看做`变量名[下标]`的形式。对于下标，由于会出现嵌套，我们可以递归求职，也就是判断当前是数还是变量，若是数，直接返回值，否则，先知道变量名，再继续递归求出下标，然后返回值。
```cpp
int dfs(int now)
{
	if(opt[now]>='0'&&opt[now]<='9')//当是一个数的时候
	{
		int x=0;
		for(int i=now;i<(int)opt.length();i++)//求这个数
		{
			if(opt[i]==']') break;
			x=x*10+(opt[i]-'0');
		}
		return x;
	}
	string s="";
	int i;
	for(i=now;i<(int)opt.length();i++)//求这个变量的变量名
	{
		if(opt[i]=='[') break;
		s.push_back(opt[i]);
	}
	int k=dfs(i+1);//再求s的下标
	if(k>=mp[s].len)//判是否越界
	{
		printf("-1\n");
		exit(0);
	}
	return mp[s].num[k];//返回值
}
```
可以发现，赋值操作的求值也可以用上面的代码求。

接着，观察三个操作，发现都是先求出其变量的`变量名[下标]`，然后再进行不同的操作。那么我们不妨把他们都放在一个函数里，节省码量，也方便调试。  
那么，对于三个操作，求出`变量名[下标]`，然后对应以下情况：

- 声明数组：`mp[变量名]=(node){数组长度,{}};`，考虑到给数组全赋成 $0$ 可以`a[MAXN]={}`，那么在给结构体里的数组赋值为 $0$ 也可以直接一个 $\{\}$。
- 输出：`printf("%d\n",mp[变量名].num[下标]);`，直接输出，不用多解释
- 赋值：`mp[变量名].num[下标]=值`，也不用解释
- 数组越界：判断下标与数组长度的关系，即看`下标>=mp[变量名].len`是否成立

关于求变量的变量名和下标，可以像上面的 dfs 一样求出最外层的变量名，就是我们需要的变量名，然后里面的下标则 dfs。  
所以三个操作的主要部分就像这样：
```cpp
void yuju(int op,string bl,string zhi)
//op记录是什么操作，bl记录操作的对象，当操作为赋值时赋的值为zhi
//op=1是声明变量，op=2是输出，op=3是赋值
{
	int k;
	if(op==3)//先求zhi的结果
	{
		opt=zhi;
		k=dfs(0);
	}
    //这里用opt字符串记录下标
	for(int i=0;i<(int)bl.length();i++)
		if(bl[i]=='[')//找到最外层的那个变量
		{
			string s=bl.substr(0,i);//截取
			opt=bl.substr(i+1);//截取后面的部分，即下标部分
			int n=dfs(0);//求下标
			if(op>1&&n>=mp[s].len)//判断是否越界
			{
				printf("-1\n");
				exit(0);
			}
			if(op==1) mp[s]=(node){n,{}};
			else if(op==2) printf("%d\n",mp[s].num[n]);
			else mp[s].num[n]=k;
			break;
		}
	return ;
}
```
至此，程序大体就出来了。然后是一些细节：输入建议用`cin`，`scanf`和`getchar`不建议使用，因为你不知道`EOF`在哪里被读掉了，然后就会死循环（至少我是这样）。然后`getline`的话你还需要分解成前后两段，会比较麻烦。

---


# [NOIP 2017 提高组] 时间复杂度

## 题目背景

NOIP2017 提高组 D1T2

## 题目描述

小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。

A++语言的循环结构如下：

 
```cpp
F i x y
    循环体
E
```
 
 
其中`F i x y`表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i +1$，一旦 $i$ 大于 $y$ 终止循环。

$x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 $100$。

`E` 表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。

注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 $\operatorname O$ 表示通常意义下 $Θ$ 的概念。


## 说明/提示

【输入输出样例解释 $1$】

第一个程序 $i$ 从 $1$ 到 $1$ 是常数复杂度。

第二个程序 $x$ 从 $1$ 到 $n$ 是 $n$ 的一次方的复杂度。

第三个程序有一个 `F` 开启循环却没有 `E` 结束，语法错误。

第四个程序二重循环，$n$ 的平方的复杂度。

第五个程序两个一重循环，$n$ 的一次方的复杂度。

第六个程序第一重循环正常，但第二重循环开始即终止（因为 $n$ 远大于 $100$，$100$ 大于 $4$）。

第七个程序第一重循环无法进入，故为常数复杂度。

第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 `ERR`。

【数据规模与约定】

对于 $30\%$ 的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 `F` 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 `E` 开头的语句，$L  \le 10$，若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。

对于 $50\%$ 的数据：不存在语法错误，$L  \le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$， 且只有 $y$ 有可能为 $n$。

对于 $70\%$ 的数据：不存在语法错误，$L  \le 100$。

对于 $100\%$ 的数据：$L  \le 100$。


---
如果需要Hack请私信@zhouyonglong或发讨论，提供数据和能Hack掉的本题的AC记录。

## 样例 #1

### 输入

```
8
2 O(1)
F i 1 1
E
2 O(n^1)
F x 1 n
E
1 O(1)
F x 1 n
4 O(n^2)
F x 5 n
F y 10 n
E
E
4 O(n^2)
F x 9 n
E
F y 2 n
E
4 O(n^1)
F x 9 n
F y n 4
E
E
4 O(1)
F y n 4
F x 9 n
E
E
4 O(n^2)
F x 1 n
F x 1 10
E
E```

### 输出

```
Yes
Yes
ERR
Yes
No
Yes
Yes
ERR```

# 题解

## 作者：叶小枫 (赞：254)

#### [点*我看@题￥目(晚了^会被&删](https://www.luogu.org/problemnew/show/P3952)

## 解题背景

~~我也不知道为什么会有解题背景~~ 这道题很久之前就听说过并且看过题面，但是由于久负盛名的**毒瘤**我一直懒得写。这两天我跟*jiang25262*搞到一起的时候我发现他也在做这道题，而且据*FCL*说，jiang佬已经做这题做了一个多月了……

于是本着~~试试看~~的心态开始着手解决这道题。这道题从接手到AC时间跨度大概**27h**（算上吃饭睡觉~~打游戏~~等时间），时间上可能比jiang佬稍微快一点。说来也巧，就在我刚接手这道题的那天晚上，jiang佬十分神犇地**AC**了……

再看看我自己俩小时写出来的一个爆零和一个28pts，更加坚定了我要A掉这题的想法

当晚心态爆炸

## 解题思路

这道题一眼看上去似乎很好办，操作总结起来就两点
- 求最大循环嵌套层数
- 判断是否有语法错误

为了节省时间和空间，本题我采用**在线做法**。即边读边操作输出。这种做法对于离线做法来说有利有弊，后文将会讲到 （jiang25262采用的是离线做法）

### 求最大循环嵌套层数

循环嵌套的结构非常类似一个栈的结构，都满足**先进后出，后进先出**的性质。那么这个问题就可以用一个栈来维护，具体实现如下

新定义一个栈，姑且命名为`zhan`好了……
- 对于读到的每一个`F`，向栈中压入任意一个元素，我们每次都压入`1`
- 询问当前栈元素的个数，每次保存其最大值
- 对于读到的每一个`E`，弹出栈顶元素
- 栈元素个数的最大值就是最大循环嵌套层数

这样看上去没什么大问题，手出一组数据也是能过的。这个子问题先告一段落

### 判断是否有语法错误

根据题面：

> 其中语法错误只有:1、F和E不匹配  2、新建的变量与已经存在但未被销毁的变量重复两种情况

我们着手解决这样两个子问题
- 匹配`F`和`E`
- 判断冲突变量名

#### 匹配`F`和`E`

我们很容易就可以想出一种显而易见的`ERR`情况：**输入数据的行数为奇数**，这样它无论怎样都不会匹配成功，直接抛出`ERR`

还有一种比较容易想的`ERR`情况：**F和E的个数不相等**，这样也不会匹配成功，抛出`ERR`

在以上两种情况都不满足的情况下，我们大致思考一下，发现只剩下一种`ERR`情况：**一个(不是一层)循环已经完全退出，但还有多余的E试图继续退出该循环**。这种情况实现起来其实也容易，因为我们事先维护了一个栈，所以我们在遇到`E`的时候先判断一下栈是不是空了，如果栈没空，就弹出栈顶元素。如果栈空了，直接抛出`ERR`

#### 判断冲突变量名

这个东西看上去不太好搞，实际上实现起来确实有一定难度。变量名的开辟与销毁虽然也满足**先进后出，后进先出**的结构，但却不能用栈来维护，因为栈不支持元素的查找。所以在碰到一个变量名时，栈无法确认它是否已经出现，故而无法判断变量名冲突。

根据以上分析，我们需要一种结构来同时支持如下两种操作：
- 有类似栈的先进后出后进先出顺序
- 支持元素查找

经过一番思索，我决定使用**字符串**来解决这个问题。具体实现如下：
- 定义一个变量列表字符串`sublist`，并赋初值为"0"
- 每次读入`F`获得一个变量名sub时，将其添加到`sublist`末端。因为字符串的特殊性质，直接`sublist+=sub`即可，需要注意，`sub`也应当是一个字符串类型而不是字符型。
- 使用字符串类自带的函数find()寻找刚读入的`sub`在`sublist`中**第一次**出现的位置，如果满足`sublist.find(sub)==sublist.length()-1`则该变量名未被使用过。
- 每次读入`E`销毁一个变量名时，直接删掉字符串最后一个字符即可

判断语法的两个子问题到此已经解决完毕

按理说，题目要求的两个子问题我们都已经解决，这题应该做完了。但是更加复杂的情况其实还在后面。

## 特殊情况处理

我们回顾“时间复杂度”的性质想一想，一个循环如果想对时间复杂度的指数有影响，那么这个循环的**本身复杂度**必须是一次或更高次项。常数级别的循环不会对复杂度的指数有影响，比如两个例子（以题目标准书写）：

```cpp
  F i 3 n
  F j 2 n
  F k 6 n
```
这个算法的时间复杂度是$O(n^3)$的

```cpp
  F i 4 7
  F j 2 9
  F k 12 95
```
这个算法的时间复杂度是$O(1)$的，因为循环只到达了常数级别

**注意，以上我所说的性质仅仅针对本题而言（因为本题的n趋近于正无穷），不适用于其他环境**

我们再回归“循环”的性质想一想，进入一个循环的条件是什么。那当然是满足`初始值<=终止值`这样一个条件。那么有，`F i 72 1`、`F i n 23`显然是两个不能进入的循环。而对于一个不能进入的循环，**嵌套在它之下的循环也不能进入**

综上，我们在两个子问题的处理上出了漏洞，有这样三个：
- 未判断常数级别的循环
- 未判断是否能进入循环
- 循环嵌套的最大层数判定不正确

我们一一解决

### 判断常数级别的循环

这个好办，只要看一看起始值和终止值是否同时不是n就好了。但是判断好判断，之后的处理不能少。因为这个循环的影响是常数级的，所以嵌套层数可以视为不影响，只要在判出常数级循环后再弹出一个栈顶元素就好了

### 判断能否进入循环&最大层数判定

这无疑是这道题目的一个重大难点。在讨论这部分的时候，我们会将之前所做的一些操作彻底推翻，重新维护新的操作来满足新的需求。

判断能否进入循环也好办，把n视作`inf`，然后比较一下起始值和终止值就能很快得出结果

重难点在于最大层数判定。当我们判出不能进入循环的时候，下面的嵌套应该全部抛弃不看，但是我们面临一个问题：**我们怎么知道哪些嵌套在它下面？**。追根溯源，这个问题的产生就在于我们对之前维护的层数栈的处理。上文提到：

> 对于读到的每一个`F`，向栈中压入任意一个元素，我们每次都压入'1'

问题就出在“每次都压入'1'上面”，这直接导致了我们无法获取当前嵌套的层数。一个很好的解决办法就是，**对于读到的每一个`F`，向栈中压入当前嵌套深度值i**。这样处理的好处是显而易见的，我们在判断无法进入循环后就有了一个舍弃哪些循环的范围。具体操作如下：
- 定义一个`runflag`，并赋初值为-1
- 当我们判定到不能进入当前循环时，把`runflag`的值赋为栈顶元素
- 如果`runflag`是-1，正常取栈元素个数的最大值作为答案。否则不记录
- 读到`F`、`E`时正常压入弹出元素
- 每次弹出都询问栈顶元素，如果栈顶已经退回了`runflag`深度，则把`runflag`还原成-1

特殊情况处理完毕，但在真正实现的时候为了保险我还进行了其他的存储操作，具体见附的AC代码

## 数据处理

真的以为这题做完了吗？当然不是。如果一上来就做这道题，你会发现，连数据的读入都不会，甚至你无法获得小明的答案（我在这里卡了10min ~~真丢人~~）。下面我们对于数据处理重点讨论。因为字符串的灵活性，我的大部分操作直接使用字符串读入完成。

### 获得小明的答案

在读完行数之后用一个字符串`tmp`存`O(xxx)`的内容，然后判断`tmp[2]`是不是数字(其实就是'1')，如果是，则小明的答案可以记为'0'（表示$O(1)$)。如果不是，那么把字符串从头到尾扫一遍，用类似快读的方式获取小明的答案。具体代码如下：

```cpp
for(rint i=0;i<tmp.length();++i)
    if(tmp[i]>='0'&&tmp[i]<='9'){
        hisans+=tmp[i]-'0';
        hisans*=10;
    }
hisans/=10;
```

### 获得循环的各项参数

定义四个字符串`opt`、`sub`、`tmpsta`、`tmpend`，然后读入。如果`tmpsta[0]`是'n'，且`tmpend[0]`和`tmpsta[0]`和`tmpend[0]`不全是'n'，则可以进入循环。

然后用上文类似的代码，获得真正的起始值`sta`和终止值`end`，判断能否执行循环。

## 最后的话

这一题到此就做完了，但是我们仍然要注意一些细节性的问题。

因为我是在线做的，在线做的优点就是边读边做，省时间省空间。但是如果某些变量忘记清零就会导致某些玄幻而低级的错误。jiang25262的离线做法据说开了三个10w级别的数组来模拟栈……但是他的清零就是10行`memset`了事。

除了离线和在线，还要避免重复输出的情况，需要使用一个`flag`来避免输出多次。具体见文末附上的AC代码。

## 感谢阅读

### 欢迎加入我们的团队！ &emsp; [团队传送门](https://www.luogu.org/team/show?teamid=10716)

持续捕捉洛谷野生大佬中（14/1e9+7），也欢迎萌新前来投食。团队QQ群号可**私信叶小枫**获取。

## AC代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rint register int
using namespace std;
stack<int> zhan;
int main(){
    int t;scanf("%d",&t);
    while(t--){
        int n;scanf("%d",&n);
    	int nowline=0,pos=0;
    	int Fcnt=0,Ecnt=0,cnt=0;
        int hisans=0,myans=0;
        int runflag=-1;
    	bool endflag=false;
        string tmp;cin>>tmp;
        string sublist="0";
        for(rint i=0;i<tmp.length();++i)
            if(tmp[i]>='0'&&tmp[i]<='9'){
                hisans+=tmp[i]-'0';
                hisans*=10;
            }
        hisans/=10;
        if(tmp[2]=='1') hisans=0;
        for(rint i=1;i<=n;++i){
            string sub,opt,tmpsta,tmpend;
            int sta=0,end=0;
            cin>>opt;
            if(opt=="F"){
            	++Fcnt;++pos;
                zhan.push(pos);
                cin>>sub>>tmpsta>>tmpend;
                if(tmpend[0]=='n'&& (!(tmpsta[0]=='n'&&tmpend[0]=='n'))) ++cnt;
                for(rint j=0;j<tmpsta.length();++j){
                    sta+=tmpsta[j]-'0';
                    sta*=10;
                }
                sta/=10;
                if(tmpend[0]!='n'){//如果end是数字 
                    for(rint i=0;i<tmpend.length();++i){
                        end+=tmpend[i]-'0';
                        end*=10;
                    }
                    end/=10;
                    if(sta>end)//如果循环不能执行 
                        runflag=pos;
                }
                if(runflag==-1||pos<runflag) myans=max(myans,cnt);
                sublist+=sub;
                if(sublist.find(sub)!=sublist.length()-1){
                	printf("ERR\n");cnt=0;nowline=i;endflag=true;break;
                }
                sta=0;end=0;
            }
            else if(opt=="E"){
            	--cnt;++Ecnt;
                if(zhan.empty()&&!endflag){
            		printf("ERR\n");cnt=0;nowline=i;endflag=true;break;
                }
                if(zhan.top()<=runflag){
                	pos=0;
                	runflag=-1;
                }
                if(!zhan.empty()) zhan.pop();
                if(sublist.length()>0) sublist=sublist.substr(0,sublist.length()-1);
            	if(zhan.empty()) cnt=0;
            }
        }
        if(endflag){
        	cnt=0;
        	while(!zhan.empty())
        		zhan.pop();
        		string cnm;
        	for(rint i=1;i<=n-nowline+1;++i) getline(cin,cnm);
        	continue;
        }
        if(Fcnt!=Ecnt){
        	if(!endflag) printf("ERR\n");
        	while(!zhan.empty()) zhan.pop();
        	cnt=0;
        	continue;
        }
        while(!zhan.empty()) zhan.pop(); 
        if(!endflag){
        	if(myans==hisans) printf("Yes\n");
        	else printf("No\n");
        }
        myans=hisans=0;
    }
    return 0;
}
```

---

## 作者：皎月半洒花 (赞：188)

这个题是我 $A$ 的第三百个……那么首先：

## $\color{pink}AC300$祭！๑乛◡乛๑

嗯，那么下面开始干正事：

## 一、对于这个题的概述

先说明一下，这个题虽然我花了大约两个上午——大约 $5h$ 的时间把它连码带调搞出来了，好像看上去很毒瘤，但是其实这个题根本不毒瘤，只是有些细节值得注意罢了。

不得不说，这是道很不错的题，因为既没有多么难，规则浅显易懂，也会有很多的细节不注意导致 GG（本蒟蒻就几乎把所有这个题能得的分数遍历了一遍 ORZ,多亏可以下载数据……不过考试的时候好像肯定会 GG)。

那么对于这道题我在做的时候就发现，出题人真的是太良心了，因为以下几点完全就是怕 NOIP 出的太难，来均衡难度的：

### 1 循环变量的上下界只有一个字母会出现：$n$。

但是从渐进意义上来讲，任何一个字母都是可以的，而这个地方只出现了 $n$，所以这是送分的。

#### 毒瘤版本：

循环的上下界可以有别的字母，那么以下这种情况也需要考虑进总的时间复杂度，按照 $O(n)$ 算：

```cpp
F i x y
F j 1 i
E
E
```

那么这个时候就要牵扯到除了 $n$ 以外的其他字母实现有没有被定义（如果未定义输出 `ERR`）等诸多问题,比如可能这样：

```cpp
F i 3 66
F j 1 i-1
F k i j
E
E
E
```

那么实际上，在上面这组样例中，$k$这层循环是进不去的。

### 2 所有常数都小于一百

这一点也很良心，由于都小于一百，所以我们在输入或者其他操作里，只用考虑两位就可以。不要小瞧这一点……这直接决定了模拟的难度。

#### 毒瘤版本：

在每个循环中，循环变量的绝对值保证在 `int` 范围里。

### 3、时间复杂度方面，不会出现$log$以二为底

嗯，以上就是本蒟蒻 yy 出来的毒瘤版本，那么看起来这道题不算是个毒瘤题……但为什么会做错呢？因为细节不注意啊 ORZ。

## 二、这个题的做法

我还是倒着说吧：

### 满分做法：

**读入**：

我们先用 `while` 按字符读入每个程序的第一行，抠出需要检验的复杂度， $O(1)$ 用 $0$ 来存 $[n^0=1 (n\neq 0)]$。

注意，有可能有两位数，需要多扣一位……

```cpp
 	  while(o!=')'){
         	if(o=='1'&&!chk) 
			   need_check=0;
         	if(o=='n'){
         	   cin>>o>>o;
               need_check=o-48;
			   chk=1;
			}
            o=getchar();
            if(isdigit(o)&&chk)need_check*=10,need_check+=(o-48); 
       }
       getchar();
```

至于最后为什么要再 `getchar()` 一次……自己试试就知道了。

那么接下来就要按行读入循环了，比较简单。

**初始化**

为了使码风简洁，所以写到函数里了。这个地方我用到了三个栈，一个用来记录每个循环的答案（因为有可能有多个相互独立的循环），一个用来记录每次 `F` 时读入的循环上下界。以上两个都是 `int` 栈,还有一个 `char` 栈，存储每次定义的循环变量，而这个字符栈搭配一个 `bool` 性的数组，用于记录是否可用。
  
 ```cpp
#define MAX 1000000
int i,x,y,t,tt,num,cntf,cnte,res,ans[MAX],T,l,now,need_checks,stk[MAX];
bool check[150],flag,spj,chk;
char s[3010],o,stkk[MAX]; 
inline void init(){
	memset(check,0,sizeof(check));
    memset(stkk,0,sizeof(stkk));
    memset(stk,0,sizeof(stk));
    now=t=tt=cntf=cnte=res=flag=spj=chk=0;
}
 ```
ps: 虽然不知道用一个二进制位的$0$来初始化字符数组会怎样……不过好像海星。
 
 `cnte` 和 `cntf` 用来记录 `F` 和 `E` 的数量， `num` 、 `t` 、 `tt` 都是栈的指针，`spj` 用来判断一个独立循环是否结束（如果结束就把当前的得到压入栈），`now` 用来搭配 `spj` 记录当前独立循环体的时间复杂度， `chk` 用于读入每个程序的第一行（即含有需要判断的时间复杂度的那一行），`flag` 用于判断输出。
 
**主要操作**

对于读入的东西，分类讨论，然后 `continue`……没什么可说的。
```cpp
	   while(l--){
          gets(s);
          for(i=0;i<strlen(s);){
           		while(s[i]==' ')i++;
				if(s[i]=='F'){
					if(cntf>cnte&&cnte){
						ans[++num]=now;
						now=0;
					}
                	cntf++,i++;
                	continue;
            	}
            	if(s[i]=='E'){
            		y=stk[t],t--;
					x=stk[t],t--;
                	cnte++;
                	if(cnte==cntf)spj=1;
                	if(x!=MAX){
                		if(y==MAX)now++;
                		if(y<x)now=0;
                	}
                	else{
                		if(y!=MAX)now=0;
                	}
                	check[stkk[tt]-'a']=0;
                	tt--,i++;
                	if(spj){
                		ans[++num]=now;
						now=0;
						spj=0;
                	}
					continue;
            	}
                if(!isdigit(s[i])&&s[i]!='n'){
                	if(check[s[i]-'a']&&!flag){ 
                	cout<<"ERR"<<endl;
                	flag=1;
					}
                	stkk[++tt]=s[i];
                	check[s[i]-'a']=1;
                }
            	else {  
                	if(s[i]=='n'){
            		my_push(s[i],s[i+1]);
					i+=2;
                }               
                my_push(s[i],s[i+1]);
                }
            	i++;
          }
       }
```

唯一需要注意的是入栈操作，因为要把字符压入整型，所以我又写了个函数来入栈。入栈的时候当然需要注意是不是两位数……

哦，还有，如果这次轮到 $n$ 入栈了，那么就随便入栈一个大于一百的数即可。

```cpp
inline void my_push(char a,char b){
	if(isdigit(a)){
		if(isdigit(b)){
			stk[++t]=(a-48)*10+b-48;
			i++;
		}
		else stk[++t]=a-48; 
	}
	if(a=='n')stk[++t]=MAX;
}
```
最后判断一下输入输出即可。

```cpp
	   if(!flag&&cntf!=cnte){
          cout<<"ERR"<<endl;
          flag=1;
       }
	   while(num){
       	   res=max(res,ans[num]); 
       	   num--;
       }
       if(!flag) if(res==need_check) cout<<"Yes"<<endl;
       			 else 				 cout<<"No"<<endl;
```

嗯~o(*￣▽￣*)o这就是满分做法了。

### $72$ 分做法

这个很坑爹……输出完直接 `break` 会导致你虽然在主观上已经不管这个询问接下来如何，但是客观上，你的程序是一边输入一边操作的，所以你接下来的输入就会 GG，这也就是引入 `mark` 的原因。

### $63$ 分做法

在 72 分的基础上，再输入 `need_check` 忘记判断 $O(n^{11})$ 和 $O(1)$ 了……这就很爆炸。

### $45$ 分做法

没有考虑嵌套在循环中的循环体的独立性，那么我们可以发现，当你在读入一个 `F` 时，如果现在 `F` 的数量大于 `E` 的数量并且 `cnte!=0`，就说明是这种情况那么就提前将结果入栈即可。
```cpp
		if(s[i]=='F'){
			if(cntf>cnte&&cnte){
				ans[++num]=now;//提前入栈
				now=0;
			}
            cntf++,i++;
            continue;
        }
```

### $27$ 分做法

忘记了自然数可以是两位数……所以赶紧打了个入栈。

### $0$ 分做法

全部的爆零都是因为我忘记了把调试用的 `freopen` 注释掉 ORZ。

总结：我认为这个题我在考场上挂的情有可原……因为我既蒟又不细心 OTZ。

还有，如果那位大佬 `hack` 掉了我的程序，别忘了通知我哇！


```cpp
#include<bits/stdc++.h>
#define MAX 1000000
using namespace std;
int i,x,y,t,tt,num,cntf,cnte,res,ans[MAX],T,l,now,need_check,stk[MAX];
bool check[150],flag,spj,chk;
char s[3010],o,stkk[MAX]; 
inline void init(){
    memset(check,0,sizeof(check));
    memset(stkk,0,sizeof(stkk));
    memset(stk,0,sizeof(stk));
    now=t=tt=cntf=cnte=res=flag=spj=chk=0;
}
inline void my_push(char a,char b){
    if(isdigit(a)){
        if(isdigit(b)){
            stk[++t]=(a-48)*10+b-48;
            i++;
        }
        else stk[++t]=a-48; 
    }
    if(a=='n')stk[++t]=MAX;
}
int main(){
    cin>>T;
    while(T--){
       init();
       cin>>l>>o;
       while(o!=')'){
         	if(o=='1'&&!chk) 
               need_check=0;
         	if(o=='n'){
         	   cin>>o>>o;
               need_check=o-48;//the same as above
               chk=1;
            }
            o=getchar();
            if(isdigit(o)&&chk)need_check*=10,need_check+=(o-48); 
       }
       getchar();
       while(l--){
          gets(s);
          for(i=0;i<strlen(s);){
           		while(s[i]==' ')i++;
                if(s[i]=='F'){
                    if(cntf>cnte&&cnte){
                        ans[++num]=now;
                        now=0;
                    }
                	cntf++,i++;
                	continue;
            	}
            	if(s[i]=='E'){
            		y=stk[t],t--;
                    x=stk[t],t--;
                	cnte++;
                	if(cnte==cntf)spj=1;
                	if(x!=MAX){
                		if(y==MAX)now++;
                		if(y<x)now=0;
                	}
                	else{
                		if(y!=MAX)now=0;
                	}
                	check[stkk[tt]-'a']=0;
                	tt--,i++;
                	if(spj){
                		ans[++num]=now;
                        now=0;
                        spj=0;
                	}
                    continue;
            	}
                if(!isdigit(s[i])&&s[i]!='n'){
                	if(check[s[i]-'a']&&!flag){ 
                	cout<<"ERR"<<endl;
                	flag=1;
                    }
                	stkk[++tt]=s[i];
                	check[s[i]-'a']=1;
                }
            	else {  
                	if(s[i]=='n'){
            		my_push(s[i],s[i+1]);
                    i+=2;
                }               
                my_push(s[i],s[i+1]);
                }
            	i++;
          }
       }
       if(!flag&&cntf!=cnte){
          cout<<"ERR"<<endl;
          flag=1;
       }
       while(num){
       	   res=max(res,ans[num]);
           num--; 
       }
       if(!flag) if(res==need_check) cout<<"Yes"<<endl;
                 else 				 cout<<"No"<<endl;
    }
}
```

---

## 作者：Zskioaert1106 (赞：11)

题目传送门：[P3952 [NOIP2017 提高组] 时间复杂度](https://www.luogu.com.cn/problem/P3952)

没什么思维难度的模拟，码量也不算太大，拿来练手很不错。

~~绝不是因为我过了才这么说的！~~

前情：（2024 年）8 月 21 号做完了老师留的作业，老师给了我们这题~~消磨时间~~。当时特别飞舞（虽然现在也是）不会写，看着同学们一个个过了从无助绝望到遗忘（好吧其实就是忘了）。12 月 24 晚想起了这题，然后写了一会没调好。第二天早上起来看着昨晚没写完的作业一点也不想补，于是就继续调这题。从 6:36 调到 6:57 然后就 A 了。（惊讶于曾经的自己怎么比自己还菜）

废话有点多，还是进入正题吧。

### Part 1 读入

读入 $L$，然后怎么计算复杂度？

我们定义一个变量 $w$ 表示小明认为的时间复杂度为 $O(n^w)$（$w=0$ 代表常数复杂度）。发现如果读入的字符串第 $2$ 位（字符串位数从 $0$ 起计）是 `1` 那么就代表是常数复杂度，否则从第 $4$ 位开始一直读入到 $s_i$ 为 `)`，对于每一位加到 $w$ 的末尾。

```cpp
int w=0;
cin>>L>>s;
if(s[2]=='n')
  for(int i=4;s[i]!=')';i++)
    w=w*10+(s[i]-'0');
```

这样得到的是小明认为的时间复杂度。

### Part 2 `F` 语句

我们用结构体来存储每一个循环。有两个变量，分别是该循环的变量名和它的状态（下文会讲）。

```cpp
struct xh{
	short n;//状态
	char nm;//变量名
}a[101];
```

对于每个语句，如果它作为 `F` 开头进入一个新的循环，那么首先要判断一下这个变量名有无重名。

我们定义一个布尔数组 $vis$ 来存储某一个字母当前有没有作为变量名被使用。如果没有则将其标记为有，否则将记录编译错误的标记设为真。后者的话那这个程序就是废了，但是我们还是要一直输入完以免影响后面的程序。

```cpp
bool vis['z'+1];
for(int i='a';i<='z';i++)vis[i]=0;
```

```cpp
char name;
cin>>name;
if(vis[name])err=1;
else vis[name]=1;
a[i].nm=name;
```

然后就是 $x$ 和 $y$ 的读入了。我们生气地发现这玩意也要用字符串之类的来判断是否是 $n$，所以读入之后判断是否是 $n$ 并按每一位转化的方法转换为整数就行了。

```cpp
string str_x,str_y;
cin>>str_x>>str_y;
int x=0,y=0;
for(int j=0;j<str_x.size();j++)x=x*10+(str_x[j]-'0');
for(int j=0;j<str_y.size();j++)y=y*10+(str_y[j]-'0');
```

接下来是一个重点：**判断当前循环的状态**。

如果当前循环的 $x$ 为 $n$ 但是 $y$ 不是，或者 $x > y$，则这个循环和里面的所有语句不会被执行。我们要判断这一点。

如果 $x$ 和 $y$ 都为 $n$ 或者 $x$ 和 $y$ 都不为 $n$ 且 $x \leqslant y$，则这个循环的执行次数是常数级的。计算时间复杂度的时候没有贡献。

否则，$x$ 为常数但 $y$ 为 $n$，那么这个循环贡献了 $O(n)$ 的复杂度。

我们定义结构体中的状态变量：如果为 $-1$ 对应不会执行的，如果为 $0$ 对应没有贡献的，如果为 $1$ 对应有 $O(n)$ 的贡献的。

```cpp
if(str_x=="n"&&str_y!="n"||(str_x!="n"&&str_y!="n"&&x>y))a[i].n=-1;
else if(str_x=="n")a[i].n=0;
else if(str_y=="n")a[i].n=1;
else a[i].n=0;
```

我们还要定义两个计数器，一个 $sum$ 存的是目前到了多高的复杂度，即对所有状态为 $1$ 的循环计算贡献；一个 $sum0$ 存当前的深度有多少个对程序进行腰斩的循环，即只有 $sum0=0$ 时，当前的 $sum$ 才能去更新答案。

```cpp
if(a[i].n==-1)sum0++;
if(a[i].n==1)sum++;
//此处仅记录增加代码，减少的要到结束处理
```

### Part 3 `E` 语句

第一个问题：对于一个 `E`，我们如何判断它是哪个循环的呢？

我们可以用栈轻松解决。对于每个 `F` 语句，将存储循环信息的下标入栈，则弹出时完美遵循就近原则。

```cpp
for(int i=1;i<=L;i++){
	if(opt=='F'){
	    //do sth.
	    q.push(i);
	}
	else{
	    //接下来的操作
	}
}
```

如果遇到一个 `E` 的时候栈已经空了，那语句肯定不匹配，则将存编译错误的变量设为真，然后要跳过本次循环，不然容易 RE。

```cpp
if(q.empty()){
  err=1;
  continue;
}
```

如果当前 $sum0$ 没有存会腰斩程序的循环体，则要判断一下答案与当前 $sum$ 的大小，及时更新。

```cpp
if(sum0==0)ans=max(sum,ans);
```

如果当前语句对应的循环是一个“腰斩循环”，则让 $sum0$ 减 $1$。

```cpp
if(a[q.top()].n<0)sum0--;
```

如果当前语句对应的循环是一个有贡献 $O(n)$ 的循环，则退出循环就要让 $sum$ 减去 $1$。

```cpp
if(a[q.top()].n>0)sum--;
```

别忘了一件事：将该循环的变量名设为未占用。然后将该下标出栈。

```cpp
vis[a[q.top()].nm]=0;
q.pop();
```

### Part 4 答案

输出答案前，别忘了判断一下栈里还有没有存着循环体。如果有，则两种语句不匹配，编译错误。

之后判断一下答案即最高的循环时间复杂度是否等于小明所预测的，输出结果。

```cpp
if(!q.empty())err=1;
if(err)cout<<"ERR";
else cout<<((w==ans)?"Yes":"No");
```

### Part 5 最终代码

恭喜你，你已经把一道简单的模拟看完了！接下来就没什么思维了。模拟题最重要的作用就在于通过代码的编写来提升自己的码力，所以可以尝试自己编写代码了。

```cpp
#include<iostream>
#include<stack>
using namespace std;
string s;
struct node{
	short n;
	char nm;
}a[101];
bool vis['z'+1];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t;
	for(cin>>t;t--;cout<<'\n'){
		for(int i='a';i<='z';i++)vis[i]=0;
		int L,w=0,ans=0,sum=0,sum0=0;
		bool err=0;
		stack<short>q;
		cin>>L>>s;
		if(s[2]=='n')
			for(int i=4;s[i]!=')';i++)
				w=w*10+(s[i]-'0');
		for(int i=1;i<=L;i++){
			char opt;
			cin>>opt;
			if(opt=='F'){
				char name;
				cin>>name;
				if(vis[name])err=1;
				else vis[name]=1;
				a[i].nm=name;
				string str_x,str_y;
				cin>>str_x>>str_y;
				int x=0,y=0;
				for(int j=0;j<str_x.size();j++)x=x*10+(str_x[j]-'0');
				for(int j=0;j<str_y.size();j++)y=y*10+(str_y[j]-'0');
				if(str_x=="n"&&str_y!="n"||(str_x!="n"&&str_y!="n"&&x>y))a[i].n=-1;
				else if(str_x=="n")a[i].n=0;
				else if(str_y=="n")a[i].n=1;
				else a[i].n=0;
				if(a[i].n==-1)sum0++;
				if(a[i].n==1)sum++;
				q.push(i);
			}
			else{
				if(q.empty()){
					err=1;
					continue;
				}
				if(sum0==0)ans=max(sum,ans);
				if(a[q.top()].n<0)sum0--;
				if(a[q.top()].n>0)sum--;
				vis[a[q.top()].nm]=0;
				q.pop();
			}
		}
		if(!q.empty())err=1;
		if(err)cout<<"ERR";
		else cout<<((w==ans)?"Yes":"No");
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/196043800)。

---

## 作者：ClV_Csy (赞：4)

# P3952 [NOIP2017 提高组] 时间复杂度
## 思路
### 一、输入
看到这题的输入数据我是有点懵的，第一眼被局限了，以为又要用烦人的 `getchar`，仔细一想发现还有一种方法读入。  
对于输入的每个程序，都有自己的行数 $L$，重复读入 $L$ 行数据，每行数据先读入一个字符串 `F` 或 `E`。如果是 `F`，就再读入三个字符**串**（注意：为了便于后续程序操作，不读入字符）。
### 二、处理
首先判 `ERR`，题目指出 `ERR` 只有两种情况：
1. `F` 和 `E` 不匹配。
2. 新建的变量与已经存在但未被销毁的变量重复。

第一种情况很好判，可以建立两个量 $cntf$ 和 $cnte$，分别统计 `F` 和 `E` 出现的个数。如果在某一时刻 $cntf < cnte$，那么做一个 `ERR` 标记。如果在程序最后 $cntf \ne cnte$，则也属于 `ERR`。判这种情况的代码如下。

```cpp
#include <iostream>
using namespace std;
int main() {
	int t;
	while (t--) {
		int l;
		string o;
		int cntf = 0, cnte = 0;
		bool err = 0;
		char a;
		cin >> l >> o;
		for (int i = 1; i <= l; i++) {
			cin >> a;
			string x, y, z;
			if (a == 'F') {
				cntf++;
				cin >> x >> y >> z;
				if (err) continue;
			} else if (a == 'E') {
				cnte++;
				if (err) continue;
			}
			if (cntf < cnte) {
				err = 1;
			}
		}
		if (err || cntf != cnte) {
			cout << "ERR\n";
			continue;
		}
	}
	return 0;
}
```

第二种情况，由于题目指出变量名只有一个字符，因此可以利用字符串的 `find` 属性来巧妙判断。  
建立一个字符串 `k` 来存储所有的变量名，把每次输入的**字符串**变量名 `x` 直接加到 `k` 的后面，要判断有没有重复时直接判断 `k.find(x) == string::npos` 即可。循环结束时将 `k` 的最后一个字符删去。

```cpp
#include <iostream>
using namespace std;
int main() {
	int t;
	while (t--) {
		int l;
		string o;
		int cntf = 0, cnte = 0;
		bool err = 0;
		char a;
		cin >> l >> o;
		string k;
		for (int i = 1; i <= l; i++) {
			cin >> a;
			string x, y, z;
			if (a == 'F') {
				cntf++;
				cin >> x >> y >> z;
				if (err) continue;
				if (k.find(x) == string::npos) {
					k += x;
				} else {
					err = 1;
				}
			} else if (a == 'E') {
				cnte++;
				if (err) continue;
				k = k.substr(0, k.size() - 1);
			}
			if (cntf < cnte) {
				err = 1;
			}
		}
		if (err || cntf != cnte) {
			cout << "ERR\n";
			continue;
		}
	}
	return 0;
}
```

接下来就是大膜你。

每次循环都有一个范围 `y` 到 `z`，可能是一个整数也可能是一个字符串 `n`。读入时 `x`，`y` 均为字符串，需要转化为数值。如果它原本就表示一个整数，那么就直接转换（能做这题的巨佬们应该都会转换吧）；如果是 `n`，那就认为它表示 $100$，便于后续操作。

维护一个栈 `st` 用来存储每层循环的一个性质 $c$。这个性质 $c$ 有以下三种情况：
1. 该层循环执行不到。即 `y` 大于 `z`，或上一层循环执行不到，那么这层循环就执行不到了。此时 $c$ 的值记为 $1$。
2. 该层循环可以增加时间复杂度的次数。此时 $c$ 的值记为 $2$。
3. 该层循环既执行得到，又不能增加时间复杂度（常数级别）。即既不满足情况 1，又不满足情况 2。此时 $c$ 的值记为 $3$。

建立一个计数器 $cnt$，统计到该层循环时时间复杂度的幂。再建立一个量 $ans$，为最终时间复杂度的幂，即 $cnt$ 可达到的最大值。  
当执行到 `F` 且 $c = 2$ 时，$cnt \gets cnt + 1$ 并将 $c$ 入栈（因为在执行 `E` 时需要用到 $c$）。  
当执行到 `E` 且 $c = 2$ 时，$cnt \gets cnt - 1$ 并将栈顶元素（$c$）出栈。

**注意：**
1. 当 `err` 标记为真时，之后输入循环语句后就直接跳过，~~偷工减料~~，否则会导致 [RE](https://www.luogu.com.cn/record/199802236)，惨痛的教训。
2. 千万不要在没有判栈非空的情况下弹出栈顶元素，否则也会导致 [RE](https://www.luogu.com.cn/record/199802684)，惨痛的教训加倍。

## 代码

```cpp
#include <iostream>
#include <stack>
using namespace std;
int intstr(string a) {
	int ansa = 100;
	if (a != "n") {
		ansa = 0;
		for (int i = 0; i < a.size(); i++) {
			ansa = ansa * 10 + a[i] - '0';
		}
	}
	return ansa;
}
int gett(string a) {
	if (a == "O(1)") return 0;
	int s = 0;
	for (int i = 4; i < a.size() - 1; i++) {
		s = s * 10 + a[i] - '0';
	}
	return s;
}
int main() {
	int t;
	cin >> t;
	while (t--) {
		int l;
		string o;
		int cntf = 0, cnte = 0;
		bool err = 0;
		char a;
		cin >> l >> o;
		int ans = 0, cnt = 0;
		string k;
		stack <int> st;
		for (int i = 1; i <= l; i++) {
			cin >> a;
			string x, y, z;
			if (a == 'F') {
				cntf++;
				cin >> x >> y >> z;
				if (err) continue;
				if (k.find(x) == string::npos) {
					k += x;
				} else {
					err = 1;
				}
				int iy = intstr(y), iz = intstr(z);
                int c = 0; //1:不可达 2:可计数 剩余情况为3
				if (st.size() != 0) {
					if (st.top() == 1) {
						c = 1;
					}
				}
				if (iy > iz) {
					c = 1;
				} else if (iz == 100 && c == 0 && iy != 100) {
					c = 2;
				} else if (c == 0) {
					c = 3;
				}
				st.push(c);
				if (c == 2) {
					cnt++;
				}
			} else if (a == 'E') {
				cnte++;
				if (err) continue;
				if (st.size() != 0) {
					if (st.top() == 2) {
						cnt--;
					}
				}
				k = k.substr(0, k.size() - 1);
				st.pop();
			}
			if (cntf < cnte) {
				err = 1;
			}
			ans = max(ans, cnt);
		}
		if (err || cntf != cnte) {
			cout << "ERR\n";
			continue;
		} else {
			int t = gett(o);
			if (t == ans) cout << "Yes\n";
			else cout << "No\n";
		}
	}
	return 0;
}
```

## 后记
大模拟的特点，巨难调。看看我五彩斑斓的评测记录：
1. [0pts](https://www.luogu.com.cn/record/199791532)
2. [9pts](https://www.luogu.com.cn/record/199784446)
3. [9pts 梅开二度](https://www.luogu.com.cn/record/199795897)
4. [18pts](https://www.luogu.com.cn/record/199797093)
5. [27pts](https://www.luogu.com.cn/record/199793962)
6. [45pts](https://www.luogu.com.cn/record/199785196)
7. [45pts again](https://www.luogu.com.cn/record/199801072)
8. [54pts](https://www.luogu.com.cn/record/199801533)
9. [55pts](https://www.luogu.com.cn/record/199780273)
10. [64pts](https://www.luogu.com.cn/record/199779350)
11. [72pts](https://www.luogu.com.cn/record/199802083)
12. [72pts * 2](https://www.luogu.com.cn/record/199802236)

---

## 作者：NewbieZZZ (赞：3)

大模拟，打磨你。

---

## 前情提要

夏令营教模拟，老师给了我们这个作业。我当时特喜欢刷水题。当时，我觉得这道题很水，轻松搞定，于是直奔满分而去。结果......[也就调了亿会](https://www.luogu.com.cn/record/list?pid=P3952&user=1120498&page=2)。

为了弥补这一个月之劳累，特写此题解。

## 铺垫

（注：这里我用字符串存储小明认为的复杂度。）

定义该循环“对复杂度有贡献”当且仅当循环下界与上界之差远大于 $100$。这种循环是我们要统计的。

定义“废循环”为不对复杂度的次数有贡献的循环。这种循环是需要避免计算入复杂度的。

### 处理语法错误的方法

一个程序语法错误当且仅当：（括号内为解决方案）

- 变量重名；（用 $arr$ 数组记录变量是否被使用）
- `F` 与 `E` 不对应。（用栈模拟循环）

## 正片

本题解着重讲解思路。

### 处理复杂度步骤描述

首先：读入每行程序的第一个字符。

#### 是 `F`：处理此循环的标记

- 读入变量名、循环下界和上界。
- 如果和 $arr$ 数组之前记录的变量名重名：
   - 标记语法错误，重新读入，忽略该组程序。（避免重复输出）
   - 否则：
        - 在 $arr$ 数组中标记变量名，并将变量名压入循环栈中；（方便销毁变量名）
        - 将 `n` 赋值为一个极大值；（方便计算复杂度）
        - 如果这个循环没有被标记为废循环，且循环对复杂度有贡献：
            - 将该循环标记为有贡献的；
            - 当前次数 $w\to w+1$；
            - 更新最大次数 $res$。
        - 否则：
            - 标记该变量名下的循环为废循环。

```cpp
if(a == 'F'){
    cin >> b >> c >> d;
    if(arr[b - 'a'] && !ERR){
        cout << "ERR\n";
        ERR = 1; 
        continue; //变量名重复
    } else {
        arr[b - 'a'] = 1;
        st.push(b); 
        if(c == "n"){ c = "20000";}
        if(d == "n"){ d = "20000";}
        int C = stoi(c), D = stoi(d);
        if(D-C > 1000 && flag == -1){
            eff[b - 'a'] = 1; ++w;
            res = max(w, res);//判定复杂度
        } else if(C > D){
            flag = b; //废循环
        }
    }
}
```

#### 是 `E`：撤销之前对与之对应的循环的标记

- 如果这个栈是空的：
  - 标记语法错误，重新读入，忽略该组程序。
- 否则：
  - 取出栈顶的变量名；
  - 从栈中弹出这个循环；
  - 撤销变量名重名标记；
  - 如果该变量名下的循环为废循环：
    - 撤销废循环标记。
  - 否则，如果该变量名下的循环对复杂度有贡献：
    - 撤销贡献标记，当前次数 $w\to w-1$。
   
```cpp
else {
    if(st.empty()){
        if(! ERR){
             cout << "ERR\n"; 
             ERR = 1;
        } continue;
    } 
    int cur = st.top();
    st.pop();
    arr[cur - 'a'] = 0;
    if(flag == cur) { flag = -1; }
    if(eff[cur - 'a']) {
        eff[cur - 'a'] = 0;
        w --;
    }
}
```

### 收尾，判定复杂度

- 如果栈中还有元素：
  - 清空栈；
  - 如果没有输出过 `ERR`：
      - 报告语法错误。
  - 读入下一组数据。
- 特判 `O(1)`，即 $\Theta(n^0)$：
  - 如果语法正确且最终次数 $res$ 为 $0$：
    - 输出 `Yes`。
  - 否则：
    - 输出 `No`。
- 否则截取复杂度的次数部分。$^{[1]}$（将截取的字符串转换为 `int` 类型）
- 如果次数部分等于 $res$：
  - 输出 `Yes`；
- 否则：
  - 输出 `No`。
 
$[1]$：这类格式以 `O(n^45)` 为例。前 $4$ 个字符为固定的，不为数字；最后一个字符为 `)`。所以，截取数字要从第 $5$ 个字符开始（即 `s[4]`，`4`）到倒数第二个字符（`s[s.size() - 1]`，`5`），即可截取到 `45`。

```cpp
if(st.size()){
    while(st.size()){
        st.pop();
    }
    if(!ERR) {
        cout << "ERR\n";
    }
    continue;
}
if(s == "O(1)" && !ERR){
    if(res == 0) {
        cout << "Yes\n";
    } else {
        cout << "No\n";
    }
} else if(!ERR) {
    string s1;
    for(int i=4; i<s.size()-1; ++i){
        s1 += s.substr(i, 1);
    }
    if(stoi(s1) == res) {
        cout << "Yes\n";
    } else {
        cout << "No\n";
    }
}
```

## 坑总结

1. 多测必清空！
2. 想好思路再写代码；
3. 把语法错误的循环**完全忽略**。记录是否属于这类循环，并尽量在所有判断的条件加上 `! ERR`；
4. 特判循环下界和上界都是 `n` 的情况；
5. 小明判定的复杂度中，次数可能不止一位。

## 总代码

模拟题最重要的是细节和思维。想到了思路，你完全可以敲出正解代码。此处建议自行编写。

```cpp
#include <bits/stdc++.h>
using namespace std;
int _;
bool arr[30], eff[30];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    stack<int> st;
    cin >> _;    
    while(_ --){
        int n, w=0, res=0, flag = -1, ERR = 0;
        string s, c, d;
        char a, b;
        memset(arr, 0, sizeof arr);
        memset(eff, 0, sizeof eff);
        cin >> n >> s;
        while(n --){
            cin >> a;
            if(a == 'F'){
                cin >> b >> c >> d;
                if(arr[b - 'a'] && !ERR){
                    cout << "ERR\n";
                    ERR = 1; 
                    continue; //变量名重复
                } else {
                    arr[b - 'a'] = 1;
                    st.push(b); 
                    if(c == "n"){ c = "20000";}
                    if(d == "n"){ d = "20000";}
                    int C = stoi(c), D = stoi(d);
                    if(D-C > 1000 && flag == -1){
                        eff[b - 'a'] = 1; ++w;
                        res = max(w, res);//判定复杂度
                    } else if(C > D){
                        flag = b; //废循环
                    }
                }
            } else {
                if(st.empty()){
                    if(! ERR){
                        cout << "ERR\n"; 
                        ERR = 1;
                    } continue;
                } 
                int cur = st.top();
                st.pop();
                arr[cur - 'a'] = 0;
                if(flag == cur) { flag = -1; }
                if(eff[cur - 'a']) {
                    eff[cur - 'a'] = 0;
                    w --;
                }
            }
        }
        if(st.size()){
            while(st.size()){
                st.pop();
            }
            if(!ERR) {
                cout << "ERR\n";
            }
            continue;
        }
        if(s == "O(1)" && !ERR){
            if(res == 0) {
                cout << "Yes\n";
            } else {
                cout << "No\n";
            }
        } else if(!ERR){
            string s1;
            for(int i=4; i<s.size()-1; ++i){
                s1 += s.substr(i, 1);
            }
            if(stoi(s1) == res) {
                cout << "Yes\n";
            } else {
                cout << "No\n";
            }
        }
    } 
    return 0;
}
```

3k 有言：不借鉴题解代码，而借鉴题解思路。如果你高兴的话，点个赞顶它上去。（别问 3k，问就是玩）

谢谢审核大大。

---

## 作者：zyd22 (赞：2)

### [题目传送门](luogu.com.cn/problem/P3952)

## 解题思路

### 嵌套是否合法

首先，本题需要判断 `for` 循环嵌套是否合法，我们用栈维护：

`stack<pair<string,int> >st;`

这里 `string` 维护的是循环变量的名字， `int` 现在还没用，我们暂且不提。

这样每次输入 `F` 时，就让变量名入栈，当输入 `E` 时，变量名出栈。

如果要出栈时栈为空，或者结束后栈不为空，那么不合法，输出 `ERR`。

### 变量名是否重复

这个我们可以用 `map` 维护：

`map<string,int>mp;`

用名字去映射是否用过，每次输入 `F` 时，把输入的名字映射为 $1$，输入 `E` 时，把栈顶对应的名字映射为 $1$。

如果输入时重复，输出 `ERR`。

### 时间复杂度

首先看题：

1. 在开始 $x$ 小于等于结束 $y$ 时：
  -  $x$，$y$ 小于 $100$，复杂度 $O(1)$。
  -  $x$ 小于 $100$，$y$ 为 $n$，复杂度 $O(n)$。
  -  $x$，$y$  均为 $n$，复杂度 $O(1)$。（一定注意！）

2. 在开始 $x$ 大于结束 $y$ 时：不运行。

我们用一个变量 `now` 来维护当前一层循环的复杂度，初始值赋为 $0$。

可以把 $n$ 赋值成一个大数，这里我选用的是 $22719$（作者比较喜欢这个数），用随便一个大于 $100$ 的也可以。

每当满足复杂度为 $n$ 的条件时， `now++;`。

1. 当满足条件的循环结束时， `now--;`。

这里我们栈中第二个元素就有用处了：标记当前循环是否满足该条件。

最终的复杂度就是 `now` 的最大值。

此外，当满足程序不运行时，需要维护一个标记变量 `f` 来判断当前循环是否执行，这里不再详述。

时间复杂度 $O(tL)$。

### 坑点

1. 数字转换别写错了。
2. 记得在出栈前判断栈是否为空，小心RE。
3. 标记变量 `f` 是要取最底下不运行的位置。
4. 不要判断不合法后直接输出！最好要用一个标记变量来存，不然容易多输出或少输入。

## AC code
```
#include<bits/stdc++.h>
using namespace std;
int T;
int num(char c){
    if('0'<=c&&c<='9') return int(c-'0');
    return -22;     //别的也行，只是作者爱用
}
int getnum(int p,string s){
    int k=0;
    while(num(s[p])!=-22) k=k*10+num(s[p++]);
    k=(k==0?22719:k);
    return k;
} //while下面一行是判断是否为n
stack<pair<string,int> >st;  //栈
map<string,int>mp;     //map
int main(){
    cin>>T;
    while(T--){
        while(!st.empty()) st.pop();
        mp.clear();     //多测要清空
        int n=0;
        string o;
        int t=0,err=0;//输入时间，标记
        cin>>n>>o;
        if(o[2]=='1') t=0;
        else t=getnum(4,o);
        int now=0,ans=0,f=0,siz=0;//siz是栈的大小
        while(n--){
            char c;
            cin>>c;
            if(c=='F'){
                siz++;
                string name,s,e;
                cin>>name>>s>>e;
                if(mp[name]==1) err=1;//不要马上输出！
                if(err==1) continue;
                mp[name]=1;
                int x=0,y=0;
                x=getnum(0,s);
                y=getnum(0,e);
                int k=0;
                if(x<y&&y==22719&&f==0) now++,k=1;//注意
                if(x>y) f=(f?min(f,siz):siz);//注意
                st.push(make_pair(name,k));
                ans=max(ans,now);//取最大值
            }
            else if(c=='E'){
                if(st.empty()){
                    err=1;
                    continue;
                }
                mp[st.top().first]=0;
                siz--;
                now-=st.top().second;  //second是标记，如上面所说
                if(f>siz) f=0;//重置标记
                st.pop();
            }
        }
        if(!st.empty()) err=1;
        if(err) printf("ERR\n");
        else if(ans==t) printf("Yes\n");
        else printf("No\n");
        //注意输出格式
    }
    return 0;
}
```

---

## 作者：路人甲2003 (赞：2)

# 蒟蒻的题解
从2109.5.1到2019.6.9的长途跋涉  
在这里将自己的一些感想说一下  

------------
## 1.分析
其实这个问题就是分析时间复杂度了  
那么我们可以看到有五种情况~~但好像2和3都没用~~
1. 从常数到n，单层复杂度为n
1. 从n到常数，此时在这一层之后直到跳出，里面的程序都不会运行
1. 从n到n，单层复杂度为1
1. 从常数a到常数b，a<=b，单层复杂度为1
1. 从常数a到常数b，a>b，此时在这一层之后直到跳出，里面的程序都不会运行
------------
如果没有语法错误这个设定，在碰到2和5的时候就可以不读入之后的代码到该循环跳出了，但是即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR，so。。。  
如果没有多组数据，我们可以在线判断语法错误，就可以避免上面的情况了，但是这样的话无法读入下一组数据，so。。。  

------------
综合上述分析，我们得出了一种做法：  
  保存所有代码，从头到尾分析，在过程中判断语法错误。

------------
## 2.存储
根据刚刚的分析，我们要把代码保存起来处理。但是如果我们怎么读入怎么保存，保存就失去了意义。所以，我们保存的是有价值的信息。  
### 但是，这里面什么信息有价值呢？
有价值的信息有：
- 代码行数
- 当行操作
- 该层复杂度
- 变量名
- 该层是否无法进入循环
- 题目所给的复杂度

------------
想一想，我们可以用一个类（或结构）保存这些内容。  
代码如下：
```cpp
class cx
{
public:
    cx()
    {
        num = 0;
        line = 0;
        complax_rate = 0;
        real_complax_rate = 0;
        name.clear();
        nest.clear();
        tier = 0;
        memset(con, 0, sizeof(con));
    } //构造函数
private:
    int num;                             //num表示这是第几个程序
    int line;                            //line表示行数
    int complax_rate, real_complax_rate; //complax:复杂的，rate:度数，表示输入复杂度与实际复杂度
    vector<string> name;                 //用于记录变量名
    vector<int> nest;                    //记录该层复杂度
    int con[105];                        //记录每层的操作，1为插入，2为删除
};
```
不懂类的可以把class改成struct，并且删掉public和private。

------------
## 3. 读入
对于读入而言，我们可以用string读入当前代码。  
但是string的输入函数有两种，cin和getline。但是该用哪个呢？
首先看两个函数的区别：
- cin是读入一个字符串，遇到空格，换行符就停止
- getline是读入一整行，包括换行符

------------
看这道题，我们发现，我们可以用cin读入前面的字符串，用getline读入最后一组字符串。  
# 注意！！！cin不会读入那个空格！
所以在getline之前，最好加一个getchar把那个空格干掉。  
代码如下：
```cpp
void read(int n)
    {
    	n=num;
        cin >> line; //读入行数
        string rate;
        getline(cin,rate);
        int num=0;
        for(int i=0;i<rate.length();++i){
            if(rate[i]=='^'){
                for(int j=i;j<rate.length();++j){
                    if(rate[j]>='0'&&rate[j]<='9') {
                        num*=10;
                        num+=rate[j]-'0';
                    }
                }
                break;
            }
        }
        complax_rate=num;
        for (int i = 1; i <= line; ++i)
        {
            char ch;
                scanf("%c", &ch);
            if (ch == 'F')
            { //读入为F
                con[i] = 1;
                string Name;
                cin >> Name;
                name.push_back(Name);
                string x, y;
                cin >> x;
                char pxx=getchar();//划重点
                getline(cin,y);
                if (x[0] == 'n' && y[0] == 'n')
                    nest.push_back(0); //从n到n,复杂度为常数
                else if (x[0] == 'n' && y[0] != 'n')
                    nest.push_back(-1); //从n到1,不会进入
                else if (x[0] != 'n' && y[0] == 'n')
                    nest.push_back(1); //从1到n,复杂度为n
                else
                { //从常数到常数
                    int _x=0, _y=0;
                    for (int i = 0; i < x.length(); ++i)
                    {
                        _x *= 10;
                        _x += x[i] - '0';
                    } //把x变成整数
                    for (int i = 0; i < y.length(); ++i)
                    {
                        _y *= 10;
                        _y += y[i] - '0';
                    } //把y变成整数
                    if (_x > _y)
                        nest.push_back(-1); //从大到小，不会进入
                    else
                        nest.push_back(0); //从小到大，复杂度为常数
                }
                tier++;
            }
            else if(ch=='E')
            { //读入为E
            string fz;
            getline(cin,fz);
                con[i] = 2;
            }
             
        }
    }
```
此时  
- 在数组con中保存操作，1为F，0为E  
-    在数组name中保存变量名
- 在数组nest中保存该层复杂度和该层是否无法进入循环，1为n，0为1，-1为不进入


------------
## 4.复杂度分析
思考如何分析  
首先，为了判断变量名是否重复，我们需要一个set。  
但是，为了维护变量的进出顺序，我们需要像真正的电脑一样，维护一个变量栈。  
所以我们需要两个stl，一个set，一个stack。  
故存储应该变成这样：
```cpp
class cx
{
public:
    cx()
    {
        num = 0;
        line = 0;
        complax_rate = 0;
        real_complax_rate = 0;
        name.clear();
        nest.clear();
        tier = 0;
        exist_name.clear();
        memset(con, 0, sizeof(con));
    } //构造函数
private:
    int num;                                //num表示这是第几个程序
    int line;                               //line表示行数
    int complax_rate, real_complax_rate;    //complax:复杂的，rate:度数，表示输入复杂度与实际复杂度
    vector<string> name;                    //用于记录变量名
    vector<int> nest;            //记录该层复杂度
    int con[105];                           //记录每层的操作，1为插入，2为删除
    set<string> exist_name;                 //分析复杂度时，记录已经存在的变量,
    stack<pair<string, int> > xl_exist_name; //同上，为了维护变量的顺序,第二维保存在此变量插入之前的复杂度
} ;
```

------------
上代码：  
（关于如何分析，中间的一些细节在注释里）
```cpp
    int analyze()
    {                                                        //分析复杂度
        int top_complax_rate = 0;                            //记录目前最高的复杂度
        int now_complax_rate = 0;                            //记录当前复杂度
        bool flag = true;                                    //标记不会进入的循环
        string flag1 = "";                                   //同上,第一维为不会进入的变量名,//第二维为该变量名所在的位置
        vector<string> ::iterator it1 = name.begin();        //迭代器1
        vector<int>::iterator it2 = nest.begin();            //迭代器2
        vector<string>::iterator it3 = name.begin();         //迭代器3
        for (int i = 1; i <= line; ++i)
        {
            if (con[i] == 1)
            {
                if (exist_name.count(*it1))
                    return 3;                                          //此时出现语法错误2
                exist_name.insert(*it1);                               //将变量存入集合
                xl_exist_name.push(make_pair(*it1, now_complax_rate)); //保存
                int y = *it2; //方便操作
                if (y == -1)
                {
                    flag = false;
                    flag1 = *it1;
                } //在这个变量弹出之前，其中所有运行复杂度均为0
                if (y == 1)
                {
                    if (flag != false)
                    {
                        now_complax_rate++;                                         //更新变量的值
                        top_complax_rate = max(top_complax_rate, now_complax_rate); //更新当前最高复杂度
                    }
                }
                it1++;
                it2++;
                it3++; //移动迭代器
            }
            else
            {
                if (exist_name.empty())
                    return 3; //此时出现语法错误1
                else
                {
                    string on = xl_exist_name.top().first; //记录要删去的变量
                    int ons = xl_exist_name.top().second;  //ons记录去除变量后的当前复杂度
                    exist_name.erase(on);
                    xl_exist_name.pop(); //去除变量
                    if (flag == false)
                    {                    //如果变量处在无法进入的循环中
                        if (on == flag1) //如果这就是问题变量
                            flag1 = "";
                        flag = true; //清空标记
                    }
                    now_complax_rate = ons; //更新复杂度
                }
            }
        }
        if(!xl_exist_name.empty()) return 3;
        real_complax_rate = top_complax_rate;
        return real_complax_rate == complax_rate ? 1 : 2;
    }
```
结果是1，Yes；2.No；3.ERR。


------------
## 5.输出
已经走到这一步了，最难的关卡都过去了，之后就是善后工作了  
直接上代码吧？
```cpp
void print(int x)
    {
        if (x == 1)
            printf("Yes\n");
        else if (x == 2)
            printf("No\n");
        else
            printf("ERR\n");
    }
```
这个就是用analyze函数的返回值，输出最后的结果

------------
## 最后——上完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
class cx
{
public:
    cx()
    {
        num = 0;
        line = 0;
        complax_rate = 0;
        real_complax_rate = 0;
        name.clear();
        nest.clear();
        exist_name.clear();
        memset(con, 0, sizeof(con));
    } //构造函数
        void read(int n)
    {
    	n=num;
        cin >> line; //读入行数
        string rate;
        getline(cin,rate);
        int num=0;
        for(int i=0;i<rate.length();++i){
            if(rate[i]=='^'){
                for(int j=i;j<rate.length();++j){
                    if(rate[j]>='0'&&rate[j]<='9') {
                        num*=10;
                        num+=rate[j]-'0';
                    }
                }
                break;
            }
        }
        complax_rate=num;
        for (int i = 1; i <= line; ++i)
        {
            char ch;
                scanf("%c", &ch);
            if (ch == 'F')
            { //读入为F
                con[i] = 1;
                string Name;
                cin >> Name;
                name.push_back(Name);
                string x, y;
                cin >> x;
                char pxx=getchar();
                getline(cin,y);
                if (x[0] == 'n' && y[0] == 'n')
                    nest.push_back(0); //从n到n,复杂度为常数
                else if (x[0] == 'n' && y[0] != 'n')
                    nest.push_back(-1); //从n到1,不会进入
                else if (x[0] != 'n' && y[0] == 'n')
                    nest.push_back(1); //从1到n,复杂度为n
                else
                { //从常数到常数
                    int _x=0, _y=0;
                    for (int i = 0; i < x.length(); ++i)
                    {
                        _x *= 10;
                        _x += x[i] - '0';
                    } //把x变成整数
                    for (int i = 0; i < y.length(); ++i)
                    {
                        _y *= 10;
                        _y += y[i] - '0';
                    } //把y变成整数
                    if (_x > _y)
                        nest.push_back(-1); //从大到小，不会进入
                    else
                        nest.push_back(0); //从小到大，复杂度为常数
                }
            }
            else if(ch=='E')
            { //读入为E
            string fz;
            getline(cin,fz);
                con[i] = 2;
            }
             
        }
    }
    int analyze()
    {                                                        //分析复杂度
        int top_complax_rate = 0;                            //记录目前最高的复杂度
        int now_complax_rate = 0;                            //记录当前复杂度
        bool flag = true;                                    //标记不会进入的循环
        string flag1 = "";                                   //同上,第一维为不会进入的变量名,//第二维为该变量名所在的位置
        vector<string> ::iterator it1 = name.begin();         //迭代器1
        vector<int>::iterator it2 = nest.begin(); //迭代器2
        vector<string>::iterator it3 = name.begin();         //迭代器3
        for (int i = 1; i <= line; ++i)
        {
            if (con[i] == 1)
            {
                if (exist_name.count(*it1))
                    return 3;                                          //此时出现语法错误2
                exist_name.insert(*it1);                               //将变量存入集合
                xl_exist_name.push(make_pair(*it1, now_complax_rate)); //保存
                int y = *it2; //方便操作
                if (y == -1)
                {
                    flag = false;
                    flag1 = *it1;
                } //在这个变量弹出之前，其中所有运行复杂度均为0
                if (y == 1)
                {
                    if (flag != false)
                    {
                        now_complax_rate++;                                         //更新变量的值
                        top_complax_rate = max(top_complax_rate, now_complax_rate); //更新当前最高复杂度
                    }
                }
                it1++;
                it2++;
                it3++; //移动迭代器
            }
            else
            {
                if (exist_name.empty())
                    return 3; //此时出现语法错误1
                else
                {
                    string on = xl_exist_name.top().first; //记录要删去的变量
                    int ons = xl_exist_name.top().second;  //ons记录去除变量后的当前复杂度
                    exist_name.erase(on);
                    xl_exist_name.pop(); //去除变量
                    if (flag == false)
                    {                    //如果变量处在无法进入的循环中
                        if (on == flag1) //如果这就是问题变量
                            flag1 = "";
                        flag = true; //清空标记
                    }
                    now_complax_rate = ons; //更新复杂度
                }
            }
        }
        if(!xl_exist_name.empty()) return 3;
        real_complax_rate = top_complax_rate;
        return real_complax_rate == complax_rate ? 1 : 2;
    }
    void print(int x)
    {
        if (x == 1)
            printf("Yes\n");
        else if (x == 2)
            printf("No\n");
        else
            printf("ERR\n");
    }
    void run(int n)
    {
        read(n);
        int op = analyze();
        print(op);
    }

private:
    int num;                                //num表示这是第几个程序
    int line;                               //line表示行数
    int complax_rate, real_complax_rate;    //complax:复杂的，rate:度数，表示输入复杂度与实际复杂度
    vector<string> name;                    //用于记录变量名
    vector<int> nest;            //记录该层复杂度
    //int tier;                               //记录当前层数
    int con[105];                           //记录每层的操作，1为插入，2为删除
    set<string> exist_name;                 //分析复杂度时，记录已经存在的变量,
    stack<pair<string, int> > xl_exist_name; //同上，为了维护变量的顺序,第二维保存在此变量插入之前的复杂度
} ;
int main()
{
    int t;
    cin >> t;
    for (int i = 1; i <= t; ++i)
    {
        cx f1;
        f1.run(i);
    }
    return 0;
}
```
~~最后无耻的求波赞~~  
# END
# 2019.6.15


---

## 作者：yyycj (赞：1)

## 题目简述
A++ 语言的循环语句格式如下：
```
F i x y
  ...
E
```
其与 C++ 中的 `for (int i = x; i <= y; i++) {...}` 等价。

给定 $t$ 个 $L$ 条只有循环语句的程序，判断其中是否出现了语法错误，如果没出现则判断这个程序的时间复杂度是否与给定的时间复杂度相等。

## 宏定义与变量（具体含义后文给出）
```cpp
#define endl '\n'
typedef long long ll;
const int L = 100 + 10;
typedef pair<int, int> pii;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define repr(i, a, b) for (int i = a; i >= b; i--)
// ----------------------------
struct node {
	int depth;
	string start, _end;
	char val_name, type;
};
// ----------------------------
int l, w;
node code[L]; 
char is_use[30];
stack<pii> last_w;
// ----------------------------
int to_int(string s) {
	int ans = 0;
	rep(i, 0, (int)s.length() - 1) ans = ans * 10 + s[i] - '0';
	return ans;
}
```

## 题目分析
没有什么算法，但让人一看题目是依托，一写憋半天——
> 大模拟（打磨你）

## 输入处理
整个输入中唯一需要稍微处理一下的只有时间复杂度了，`string` 是个好东西（~~STL 大法好~~），可以用 `string` 读入。时间复杂度只有两种情况：`O(1)` 和 `O(n^w)`，用 $w$ 来记录 $O(n^{w})$，第一种情况设为 $0$；而第二种为了方便，可以先调用 `.pop_back()` 函数，弹掉右括号，接着调用 `.substr(4)`，表示从字符串的第 $4 + 1$ 个字符开始一直截取到最后，将这个函数返回的字符串转成数字即可。

在输入语句时，由于可能出现语法错误，但后面的输入还要继续，后续的处理比较麻烦，所以这里采用了全部读入再处理的方法，就有了宏定义中的结构体 `node`。除 `depth` 以外的变量含义较为清晰，`depth` 的含义为这个循环在第几层循环内，最外层则为 $0$。

```cpp
void input() {
	cin >> l;
	w = 0;
	string s;
	int depth = -1;
	cin >> s; s.pop_back();
	if (s != "O(1") w = to_int(s.substr(4));
	rep(i, 1, l) {
		cin >> code[i].type;
		if (code[i].type == 'F') {
			depth++;
			cin >> code[i].val_name >> code[i].start >> code[i]._end;
		}
		else depth--;
		code[i].depth = depth;
	}
}
```

## 错误判断
1. `F` 与 `E` 不匹配：这个问题与括号匹配几乎相同，可以用栈或者两个计数变量都可以，此代码中使用栈因为可以同时记录另一种数据。（栈 `stack<pii> last_w`）

2. 变量名重复：这就更简单了，只需要一个 `bool` 数组即可。（数组 `is_use[30]`）

## 时间复杂度计算
```cpp
void solve() {
  // do!
}
```
使用的变量及含义：
```cpp
int now_w = 0;
/*
如果第 i 条语句的类型为 F,那么 now_w 表示只看当前语句所在的一整个大代码块里,运行它前面的未结束循环和自己所用的时间复杂度为 O(n^now_w)。
如果为 E，则 now_w 的值与计算到该语句对应的 F 语句的上一层时的 now_w 的值相同，如果对应的层已是最外层，则为 0。
例如代码为
F i 1 n
F j 1 n
F k 1 n
E
F k 1 n
E
E
E
那么在结束 i=2,4,6 的循环时 now_w=2;在结束 i=3,5 时 now_w=3。
*/
int max_w = 0;
// 最大的记录过的时间复杂度中 n 的指数，也可以说这个程序的时间复杂度就是 O(n^max_w)。
int now_depth = 0;
// 表示当前处于第几层循环，如果有循环不会执行，则计算到此循环内时 now_depth 不会改变。
bool is_use[30];
// 表示现在每个小写字母（变量名）是否存在且未被销毁。(a 的下标为 0)
stack<pii> last_w;
/*
first 表示第 second 条语句的时间复杂度为多少，只计算这一个语句。（第 second 条语句类型必定是 F）
并且这个栈还正好可以判断 F 与 E 不匹配的错误，当这个语句的类型为 E 但栈已空则为错误，代码全部运行完后栈不为空也为错误。
*/
```
### 伪代码（主体部分）
- 初始化：输入，初始 `is_use` 全为 `false`，将栈清空。

- 遍历每条语句

$\ \ \ \ \circ \ $ 判断当前语句类型是否为 `E` 且栈为空。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 输出 `ERR` 并结束函数。

$\ \ \ \ \circ \ $ 判断当前语句类型是否为 `E`。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 将 `now_depth` 减少 $1$，将 `now_w` 减少当前栈顶的 `first`，销毁第当前栈顶的 `second` 条语句的循环变量，弹出栈顶，注意还要判断 `now_depth` 是否会小于 $0$，具体原因会在后面给出。最后 `continue` 掉。

$\ \ \ \ \circ \ $ 现在只剩下代码类型为 `F` 的情况，所以先判断一下是否出现错误，即只有循环变量重复。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 输出 `ERR` 并结束函数。

$\ \ \ \ \circ \ $ 此时 `now_depth` 和结构体中 `depth` 的作用就显现出来了：由于可能出现某个循环根本进不去的情况，该循环内部的循环也就不会执行，但仍然存在，所以在当前循环根本进不去的时候就不更新 `now_depth`，随后在这里判断如果 `now_depth` 小于 `code[i].depth`，表示程序根本没有走到这里，本条语句也就不用执行。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 就算没有运行到这，但题面输出格式的最后一句话：“注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 `ERR`。”也就告诉我们即使不执行也会出现一个相对应的 `E`，而出现 `E` 就会弹出栈顶，所以要多压入一个 `make_pair(0, i)` 占位。最后 `continue` 掉。

$\ \ \ \ \circ \ $ 判断这个循环语句的时间复杂度是否为 $O(1)$，即 $x$ 与 $y$ 都为 $n$ 或者 $x$ 与 $y$ 都为数字且 $x \le y$。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 任何数乘 $1$ 还是这个数，所以 `now_w` 保持不变，由于进入了这个循环，所以 `now_depth` 增加 $1$，接着往栈内压入 `make_pair(0, i)`。

$\ \ \ \ \circ \ $ 如果不是 $O(1)$，判断这个循环语句的时间复杂度是否为 $O(n)$，即 $x$ 为数字且 $y$ 为 $n$。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 此时 `now_w` 和 `now_depth` 就都需要增加 $1$ 了，并且栈内也应该压入的是 `make_pair(1, i)`。

$\ \ \ \ \circ \ $ 题目中已经描述一个语句的时间复杂度只可能是前两种，如果都不符合。

$\ \ \ \ \ \ \ \ \scriptsize \square \ $ 如果都不符合，只能是无法进入，但是还是前面的原因，栈内要压入 `make_pair(0, i)` 占位。这里就涉及到前面要判断 `now_depth` 小于 $0$ 的问题了，还是输出描述最后一句的问题，为了保证这个变量的正确性，所以这里不做改变，但仍然有对应的 `E` 要减去，为了防止 `now_depth` 小于 $0$，所以需要增加这样一个判断。

$\ \ \ \ \circ \ $ 循环内的最后一步，更新 `max_w`。

- `F` 与 `E` 无法匹配前文提到了有两种情况，第二种则是语句全部运行完后栈不为空，在此处判断。

$\ \ \ \ \circ \ $ 如果是这样，输出 `ERR` 并结束函数。

- 函数的最后，所有错误已经判断完毕，判断 `max_w` 是否与在输入部分就计算好的 `w` 相等。

$\ \ \ \ \circ \ $ 如果相等输出 `Yes`。

- 否则

$\ \ \ \ \circ \ $ 否则输出 `No`。

## AC Code
```cpp
#include<stack>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

#define endl '\n'
typedef long long ll;
const int L = 100 + 10;
typedef pair<int, int> pii;
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define repr(i, a, b) for (int i = a; i >= b; i--)
// ----------------------------
struct node {
	int depth;
	string start, _end;
	char val_name, type;
};
// ----------------------------
int l, w;
node code[L]; 
char is_use[30];
stack<pii> last_w;
// ----------------------------
int to_int(string s) {
	int ans = 0;
	rep(i, 0, (int)s.length() - 1) ans = ans * 10 + s[i] - '0';
	return ans;
}

void input() {
	cin >> l;
	w = 0;
	string s;
	int depth = -1;
	cin >> s; s.pop_back();
	if (s != "O(1") w = to_int(s.substr(4));
	rep(i, 1, l) {
		cin >> code[i].type;
		if (code[i].type == 'F') {
			depth++;
			cin >> code[i].val_name >> code[i].start >> code[i]._end;
		}
		else depth--;
		code[i].depth = depth;
	}
}

void solve() {
	input();
	memset(is_use, 0, sizeof is_use);
	while (!last_w.empty()) last_w.pop();
	int now_w = 0, max_w = 0, now_depth = 0;
	rep(i, 1, l) {
		if (code[i].type == 'E' && last_w.empty()) {
			cout << "ERR" << endl;
			return;
		}
		if (code[i].type == 'E') {
			now_depth--;
			now_depth = max(now_depth, 0);
			now_w -= last_w.top().first;
			is_use[code[last_w.top().second].val_name - 'a'] = false;
			last_w.pop();
			continue;
		}
		if (is_use[code[i].val_name - 'a']) {
			cout << "ERR" << endl;
			return;
		}
		is_use[code[i].val_name - 'a'] = true;
		if (now_depth < code[i].depth) {
			last_w.push(make_pair(0, i));
			continue;
		}
		if (code[i].start == "n" && code[i]._end == "n" || isdigit(code[i].start[0]) && isdigit(code[i]._end[0]) && to_int(code[i].start) <= to_int(code[i]._end)) {
			now_depth++;
			last_w.push(make_pair(0, i));
		}
		else if (code[i].start != "n" && code[i]._end == "n") {
			now_w++;
			now_depth++;
			last_w.push(make_pair(1, i));
		}
		else last_w.push(make_pair(0, i));
		max_w = max(max_w, now_w);
	}
	if (!last_w.empty()) {
		cout << "ERR" << endl;
		return;
	}
	if (max_w == w) cout << "Yes" << endl;
	else cout << "No" << endl;
}

int main() {
	int t;
	cin >> t;
	// ----------------------------
	while (t--) solve();
	return 0;
}
/*
				 .-~~~~~~~~~-._       _.-~~~~~~~~~-.
			 __.'              ~.   .~              `.__
		   .'//   A    C    之   \./  之    真    理  \`.
		 .'//                     |                     \`.
	   .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \`.
	 .'//.-"                 `-.  |  .-'                 "-.\`.
   .'//______.============-..   \ | /   ..-============.______\`.
 .'______________________________\|/______________________________`.
*/
```

写这道大模拟算是我运气比较好的一次了，只交了 $4$ 发就过了，甚至分数都是单调上升的（

[$0\ pts$](https://www.luogu.com.cn/record/201373807)  
[$27\ pts$](https://www.luogu.com.cn/record/201374054)  
[$82\ pts$](https://www.luogu.com.cn/record/201375382)  
[$100\ pts$](https://www.luogu.com.cn/record/201377737)

---

## 作者：wanganze (赞：1)

### 题意
给定一段由循环嵌套构成的代码，计算其复杂度。

### 思路
我们可以用 `sscanf` 函数读取字符串中的数据，用一个字符串记录变量以判断是否重名。对于一段合法的代码，我们先将其拆分为循环和结束标志，再对每个循环求其复杂度，借助栈（类似于括号匹配）计算最高复杂度。

记得结束循环时及时弹出循环变量。

巧用特性。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 110;
string codes[N];
int get(string x, string y)
{
	if(x == "n" && y == "n") return 0;
	if(x == "n") return -1;
	if(y == "n") return 1;
	if(stoi(x) > stoi(y)) return -1;
	return 0;
}
string calc(int L)
{
	stack<int> stk;
	string vars;
	int maxv = 0;
	for(int i = 0; i < L; i ++)
	{
		string s = codes[i];
		if(s[0] == 'F')
		{
			char var[3],x[3],y[3];
			sscanf(s.c_str(),"F %s %s %s",var,x,y);
			if(vars.find(var) != string::npos) return "ERR";
			vars += var;
			int t = get(x, y);
			if(stk.empty()) stk.push(t), maxv = max(maxv, t);
			else
			{
				int x = stk.top();
				if(x == -1 || t == -1) stk.push(-1);
				else stk.push(x + t), maxv = max(maxv, x + t);
			}
		}
		else
		{
			if(stk.empty()) return "ERR";
			stk.pop();
			vars.pop_back();
		}
	}
	if(!stk.empty()) return "ERR";
	if(!maxv) return "O(1)";
	return "O(n^" + to_string(maxv) + ")";
}
int main() 
{
	int T, L;
	string a;
	cin >> T;
	while(T --)
	{
		cin >> L >> a;
		getchar();
		for(int i = 0; i < L; i ++) getline(cin, codes[i]);
		
		string res = calc(L);
		if(res == "ERR") puts("ERR");
		else if(res == a) puts("Yes");
		else puts("No");
	} 
	return 0;
}
```

---

## 作者：yaoyuchen2021 (赞：1)

# 题目大意
给出一份用若干个 `for` 组成的伪代码，以 `F` `E` 充当大括号的作用，以及一个形似 `O(1)` 或 `O(n^w)` 的时间复杂度，判断程序，若发生重命名或括号不匹配，输出 `ERR`，否则，若复杂度正确输出 `Yes`，错误输出 `No`。

# 解题思路
- ### ERR
  #### 括号不匹配
  括号不匹配有两种情况：任意时刻右括号数量多于左括号（如 `())`），结束时还有多余的左括号未匹配（如 `(()`）。在代码中分别判断即可。跟详细请出门左转 [P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)。

  #### 重命名
  变量名在出现 `F` 时诞生，随 `E` 销毁，故可以和括号一起处理。开一个栈，当遇到 `F`，判断是否重命名，存入新变量名，检测到 `E` 时弹出最上方的变量名。

- ### Yes&No
  `ERR` 的情况处理完后，就是判断时间复杂度了。注意到，时间复杂度就是最大的循环层数。当 `F` 入栈时，判断该循环次数是否与 `n` 有关，出栈时减减就行了。但还是有几个易错点：

  1. 当外层循环不会被执行时，内层循环复杂度再高也没用，如样例第7组，`F y n 4` 不会被执行，内部的 `F x 9 n` 也不会计算时间复杂度。
  2. 循环次数不与 `n` 有关的，计算复杂度时要忽略。

# AC Code
```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
struct xxx
{
	char c;
	bool f;
}st[30];//栈，c表示变量名，f表示是否与n有关
int T,l,x,y,k,sum,ans;
string s,t;
char c;
bool f[30],flag,F;//f用来判断是否重命名，F对应易错点1。
int turn(string S)
{
	if(S[0]=='n')return 1e7;
	if(!S[1])return (S[0]-'0');
	return (S[0]-'0')*10+(S[1]-'0');
}
string get(int n)
{
	if(n==0)return "O(1)";
	string S="";char C;
	while(n){C=(n%10)+'0';S=C+S;n/=10;}
	return "O(n^"+S+")";
}//自己写出时间复杂度，与给出的进行比较
signed main()
{
	//freopen("xxx.txt","r",stdin);
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>l>>s;k=0;sum=0;ans=0;F=false;flag=false;
		for(int i=0;i<=28;i++)f[i]=false,st[i].f=false;
		for(int i=1;i<=l;i++)
		{
			cin>>c;
			if(c=='F')
			{
				cin>>c;
				cin>>t;x=turn(t);
				cin>>t;y=turn(t);
			}
			if(flag)continue;//多组数据，上一组不读完会让下一组误判，所以判断出ERR也要先读完
			if(c=='E')
			{
				if(!k){flag=true;continue;}
				if(st[k].f)sum--,st[k].f=false,F=false;
				f[st[k--].c-'a']=false;
				continue;
			}
			if(f[c-'a']){flag=true;continue;}
			f[c-'a']=true;st[++k].c=c;
			if(!F&&x>y)F=true;//易错点1
			if(!F&&x+100<y)st[k].f=true,sum++;//x+100<y对应易错点2,100是应为题目规定x,y均小于100
			ans=max(sum,ans);//找出最大循环层数
		}
		if(flag||k)cout<<"ERR\n";
		else if(s==get(ans))cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：くろねこ (赞：1)

**题意**: 给你一个$L$行的循环代码,&ensp;判断是否有语法错误或者时间复杂度正不正确

接下按着代码顺序来讲讲思路.&ensp; 本人的做法是模拟程序的大致运行过程.&ensp;

* 宏定义声明:

  $read()$ $print():$ 读入$/$输出优化

  __ $space$ __ $endl:$ 输出空格$/$换行

  $rg:$ $register$, ~~用来卡常~~

* **读入**:

   * 考虑到代码为字符串,&ensp; 我们选择用二维数组读入.&ensp; 由于每个$F$循环内有诸多空格,&ensp; 故$scanf()$在本题中效果并不理想.&ensp; 我们采用$gets()$读入.&ensp; 值得注意的是,&ensp; $gets()$会将缓冲区的换行符释放$($也就是说你这一次$gets()$的数组末尾是没有换行符的,&ensp; 而且下一次$gets()$之前也不需要$getchar()$吃换行符,&ensp; 因为这个换行已经被释放了$)$,&ensp; 所以我们只需要在第一次$gets()$之前使用$getchar()$将换行符吃掉即可.&ensp;
   
   * 代码实现
    ```cpp
    read(line), scanf("%s", O + 1);
    rg char c = getchar();
    for (rg int i = 1; i <= line; ++i) gets(cpp[i] + 1);
    ```


* **抛出错误**

   
   * 若$F$与$E$不匹配则抛出错误
   
      * 若读入的代码为奇数行,&ensp; 由于$A++$语言的特性,&ensp; 可以知道至少有一个$F$或者一个$E$未成功匹配,&ensp; 直接抛出错误即可.&ensp;
      
      * 若读入的代码为偶数行则需要手动判断匹配.&ensp; 我们考虑采用类似`括号匹配`的做法来完成$FE$匹配.&ensp; 大致做法是循环遍历每一行代码,&ensp; 并使用符号栈维护.&ensp; 
      
         * 若首字母为$F$,&ensp; 则将其放入符号栈.&ensp;
         
         * 若首字母为$E$
         
            * 若符号栈为空,&ensp; 则没有$F$能和这个$E$匹配,&ensp; 抛出错误.&ensp;
            
            * 否则将符号栈弹出一位
         * 若符号栈为空,&ensp; 匹配成功,&ensp; 否则匹配失败,&ensp; 抛出错误.&ensp;
         
     * 若变量名重复,&ensp; 则需要抛出错误.&ensp; 判断方法依旧是遍历代码.&ensp; 可以和$FE$匹配一起完成.&ensp; 由于题目保证变量名是一个小写字母,&ensp; 所以变量一定在下标为$3$的位置.&ensp; 我们使用一个变量栈和$vis$数组来维护,&ensp; $vis$的下标直接用$char$即可,&ensp; 不需要转换为数字.&ensp;
     
        * 若首字母为$F$,&ensp; 取出当前变量$x$
        
           * 若该变量已经使用$(vis[x] == true)$,&ensp; 则抛出错误.&ensp;
           
           * 否则将该变量标记为已使用$(vis[x] = true)$
           
        * 若首字母为$E$,&ensp; 取出当前变量$x$并销毁$(vis[x] = false)$
     * 判断完毕后,&ensp; 说明没有错误可以抛出.&ensp;
     
  * 代码实现
  ```cpp
  inline bool Error_Occur()
  {
      memset(used_inter, false, sizeof used_inter);
      while (!s.empty()) s.pop();
      if (line & 1) return true;
      for (rg int i = 1; i <= line; ++i)
      {
          if (cpp[i][1] == 'F')
          {
              s.push('F');
              if (used_inter[cpp[i][3]]) return true;
              inter.push(cpp[i][3]);
              used_inter[cpp[i][3]] = true;
          }
          else if (cpp[i][1] == 'E')
          {
              if (s.empty()) return true;
              s.pop();
              used_inter[inter.top()] = false;
              inter.pop();
          }
      }
      if (!s.empty()) return true;
      return false;
  }
  ```

* **计算程序真实复杂度**

   * 首先,&ensp; 程序是一个循环一个循环进入,&ensp; 一个循环一个循环退出的.&ensp; 我们应该能想到用一个栈来维护时间复杂度.&ensp; 具体做法是: 进入一个循环.&ensp; 计算其时间复杂度.&ensp; 若复杂度是$O(n)$的,&ensp; 则将$1$加入栈,&ensp; 若复杂度是O$(1)$的,&ensp; 则将$0$加入栈.&ensp; 还有一个特殊的地方在于: 若题目中的$x$是大于$y$的,&ensp; 则不会进入这个循环,&ensp; 那么**该循环所嵌套的循环的时间复杂度是不会被计算的**,&ensp; ~~因为根本进不去啊~~,&ensp; 此时我们将一个极小值放入栈中.&ensp; 最后,&ensp; 当发现一个循环结束后,&ensp; 我们把栈中元素求和,&ensp; 若这个和小于等于$0$,&ensp; 则当前复杂度是$O(1)$的,&ensp; 否则是$O(sum)$的.&ensp; 我们知道程序的渐进复杂度是直接取到最大的一个复杂度,&ensp; 所以该程序的整体复杂度就是这个和的最大值$($当然小于$0$的话就是$O(1)$的$)$.&ensp;
   
   * 若首字母为$F$
   
      * 取出题目所说的$x$和$y$.&ensp;
      
         * 若遇到$n$,&ensp; 则将$x$标记为极大值.&ensp;否则存储$x$的值$($如果你会写读入优化你就应该想到用类似读入优化的方式计算这个常数,&ensp; 类似我的代码: `num[id] = (num[id] << 1) + (num[id] << 3) + (cpp[i][j] ^ 48)`$)$
         
         * 若遇到空格,&ensp; 则该读入$y$了.&ensp;
         
         * $y$的处理方式同$x$.&ensp;
         
     * 若$x$大于$y$,&ensp; 则在栈中放入极小值.&ensp;
     
     * 若$x$小于$y$且差值极大$($大于100$)$,&ensp; 则在栈中放入$1$
     
     * 若$x$等于$y$或者$x$小于$y$且差值非极大值$($小于100$)$,&ensp; 则在栈中放入$0$.&ensp;
     
  * 若首字母为$E$,&ensp; 则进行上述计算并更新程序渐进复杂度.&ensp;
  
  * 代码实现
  
  ```cpp
  inline void Calc_O()
  {
      while (!s.empty()) s.pop();
      O1 = On = false;
      total_cnt = 0;
      for (rg int i = 1; i <= line; ++i)
      {
          if (cpp[i][1] == 'F')
          {
              s.push('F');
              rg int len = strlen(cpp[i] + 1);
              rg int id = 1;
              num[1] = num[2] = 0;
              for (rg int j = 5; j <= len; ++j)
              {
                  if (cpp[i][j] >= '0' && cpp[i][j] <= '9') num[id] = (num[id] << 1) + (num[id] << 3) + (cpp[i][j] ^ 48);
                  else if (cpp[i][j] == 'n') num[id] = 0x7f7f7f7f;
                  else if (cpp[i][j] == ' ' && id == 1) ++id;
                  else if (id == 2) break;
              }
                  if (num[1] > num[2]) O_cnt.push(-233);
                  else if (num[1] < num[2] && num[2] - num[1] > 200) O_cnt.push(1);
                  else O_cnt.push(0);
          }
          else
          {
              now_cnt = 0;
              while (!O_cnt.empty())
              {
                  rg int x = O_cnt.top();
                  O_cnt.pop();
                  tmp.push(x);
                  now_cnt += x;
              }
              while (!tmp.empty()) O_cnt.push(tmp.top()), tmp.pop();
              O_cnt.pop();
              total_cnt = max(total_cnt, now_cnt);
          }
      }
      if (total_cnt <= 0) O1 = true;
      else On = true;
  }
  ```

* **取出小明所说的复杂度**

   * 遍历$O(...)$,&ensp; 若没有遇到$n$就遇到了一个数字,&ensp; 则小明所说的时间复杂度为$O(1)$.&ensp;
   * 否则还是按照读入优化的方式计算指数,&ensp; 类似我的代码`Ming_cnt = (Ming_cnt << 1) + (Ming_cnt << 3) + (O[i] ^ 48)`
   
   * 代码实现
  ```cpp
  inline void Div_XiaoMing_On()
  {
      Ming_O1 = Ming_On = false;
      Ming_cnt = 0;
      rg int len = strlen(O + 1);
      rg bool n_occur = false;
      for (rg int i = 1; i <= len; ++i)
      {
          if (O[i] == 'n') n_occur = true;
          else if (O[i] >= '0' && O[i] <= '9')
          {
              if (!n_occur)
              {
                  Ming_O1 = true;
                  return;
              }
              Ming_cnt = (Ming_cnt << 1) + (Ming_cnt << 3) + (O[i] ^ 48);
          }
      }
      Ming_On = true;
      return;
  }
  ```

* **输出**

   * 若最开始程序就抛出错误,&ensp; 输出$ERR$
   
   * 若小明复杂度和真实复杂度一样,&ensp; 输出$Yes$
   
   * 若小明复杂度和真实复杂度不一样,&ensp; 输出$No$
   
   * 代码实现
   
  ```cpp
  if (Error_Occur())
  {
      puts("ERR");
      continue;
  }
  Calc_O();
  Div_XiaoMing_On();
  if (Ming_O1 != O1)
  {
      puts("No");
      continue;
  }
  else if (Ming_O1)
  {
      puts("Yes");
      continue;
  }
  else
  {
      if (total_cnt == Ming_cnt) puts("Yes");
      else puts("No");
  }
  ```

 

## 总结

对于这种大模拟还是分函数处理比较稳,&ensp; 善用分类讨论~~那么大模拟就是送分的qwq~~


---

## 作者：ZIXT (赞：1)

来个递归做法\_(:з」∠)\_

可以把代码看成一棵树，嵌套关系用右子树表示，并列关系用左子树表示，例如:

![](https://cdn.luogu.com.cn/upload/pic/11835.png)

合并结果的方式是父亲节点加上左子树的结果后与右子树比较取最大值


### 异常处理

1.变量重复:使用set判重，拓展左子树时将变量加入set，

拓展右子树之前将变量从set删除

2.F多于E:那么会有一层读取不到对应的E，返回错误即可

3.E多于F:那么会提前结束，将已读取的行数与输入行数比较即可

以下是具体实现\_(:з」∠)\_

    
    
```cpp
    #include<iostream>
    #include<cstdio>
    #include<set>
    #define ERR -1
    using namespace std;
    int line,lines;
    set<char> vars;
    char code[110][20]; //存储输入方便处理
    int exec(){
        char var,result,x[3],y[3];
        bool enter; 
        //处理当前行
        sscanf(code[line],"F %c %s %s",&var,x,y);
        if(vars.count(var)) return ERR;
        vars.insert(var);
        //繁琐的判断...
        if(x[0]!='n'&&y[0]!='n'){
            int n1,n2;
            sscanf(x,"%d",&n1);
            sscanf(y,"%d",&n2);
            result=0,enter=(n1<=n2);
        }
        else if(x[0]!='n'&&y[0]=='n') result=1,enter=true;
        else if(x[0]=='n'&y[0]!='n') result=0,enter=false;
        else if(x[0]=='n'&&y[0]=='n') result=0,enter=true;
        //判断下一行是否为子循环
        line+=1;
        if(line>lines)return ERR; //超出则说明没有足够E与F匹配，以下同理
        int r=0;
        if(code[line][0]!='E'){ //若有子循环
            r=exec();
            if(r==ERR)return ERR;
            //子循环处理后停留在与子循环匹配的E行上，所以要跳到与当前循环匹配的E行
            line+=1; 
            if(line>lines) return ERR;
        }
        result+=enter?r:0; //当前循环不能进入则子循环复杂度就不用加了
        vars.erase(var); //脱离当前循环作用域，删除当前变量
        if(line<lines&&code[line+1][0]!='E') {//若有并列循环
            line+=1;
            r=exec();
            if(r==ERR) return ERR;
            if(r>result) result=r; //取最大值
        }
        return result;
    }
    int main(){
        int t;
        cin>>t;
        getchar();
        for(int i=1;i<=t;i++){
            char str[20],fzd[20];
            int limit,result;
            gets(str);
            sscanf(str,"%d O(%s)",&lines,fzd);
            if(fzd[0]=='n') sscanf(fzd,"n^%d",&limit);
            else limit=0;
            vars.clear();
            line=1;
            for(int i=1;i<=lines;i++) gets(code[i]);
            result=exec();
            if(result==ERR || line!=lines) cout<<"ERR"<<endl;
            else if(result!=limit) cout<<"No"<<endl;
            else cout<<"Yes"<<endl;
        }
        return 0;
}
```

---

## 作者：_Weslie_ (赞：0)

在 $2024$ 年的一场由我们教练在赛前举办的只有两题的不知道叫什么的比赛中，我在赛时通过了这题，并取得了 AK 的成绩，因此写一篇题解。

## Solution P3952

### 题意疏通

对于模拟题我们一般先把题意捋清楚。

我们的任务是把小明的程序的时间复杂度算出来，同时判断里面有没有语法错误。

我们先从简单入手。

### ERR 的判断

如何判断 ERR？ERR 有两个方面：`F` 和 `E` 不匹配或新建的变量与已经存在但未被销毁的变量重复。

对于第一种情况，我们只需要拿一个栈，到最后判断是否为空就可以了。

对于第二种情况，我们可以拿一个 `map` 记录已经存在的循环变量的个数，如果个数大于 $1$，就会 ERR。

### 时间复杂度的计算

这一部分是一个难题。

对于时间复杂度的计算，一个循环中 `F i x y` 的 $x$ 和 $y$ 无非只有 $4$ 种情况：

- $x$ 为 $n$，$y$ 为常数。这种情况是不会执行的。
- $x$ 为常数，$y$ 为 $n$。这种情况下，该循环需要执行 $n$ 次（事实上是接近于 $n$ 次看做 $n$），对总复杂度的加成为乘 $Θ(n)$。
- $x$ 和 $y$ 均为常数且 $x<y$。这种情况下对总复杂度的加成是乘 $Θ(1)$。或者说不变。
- $x$ 和 $y$ 均为常数且 $x>y$。这种情况是不会执行的。

注意到如果一个循环外层有不会执行的循环，那么这个循环也不会执行。就像下面的代码一样：

```
for(int i=1;i<=0;i++){
    for(int j=1;j<=n;j++){
      for(int k=1;k<=3;k++)//Code
  }
}
```

可以看到虽然第二层、第三层循环单独拿出来都可执行，但是第一层循环无法执行，所以后面两层嵌套在里面就无法执行了。

我们对于循环的记录，用栈来记录（很显然循环这种东西也非常符合栈先进先出的特点）。至于具体的写法，我们还是看下面的代码吧。

### Code

```
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
map<string, int> mp;
// mp 用来记录每个循环变量的出现次数
stack<int> st;
// st 用于把循环压入栈
stack<string> st2;
// st2 记录循环变量名
string ss, a, b, c, d;
// 输入的字符串
int l, T, want, s, t, ans, cnt, tot;
/*
l:循环层数
T:多测数据组数
want:小明计算出的时间复杂度要我们验证的
s:循环开始的数
t:循环结束的数
ans:我们自己算出的时间复杂度
cnt:s>t 型循环的数目
tot:一次循环复杂度为 O(n) 的循环的数目
*/
int main()
{
    scanf("%d", &T); // 多测
    while (T--)
    {
        scanf("%d", &l); // 读入循环个数
        cin >> ss;
        want = 0;
        mp.clear();
        while (!st.empty())
            st.pop();
        ans = 0;
        if (ss == "O(1)")
            want = 0;
        else
        {
            for (int i = 0; i < ss.length(); i++)
            {
                if ('0' <= ss[i] && ss[i] <= '9')
                    want = want * 10 + ss[i] - '0';
            }
        }
        bool f = 0, ff = 1;
        tot = 0;
        cnt = 0;
        while (l--)
        {
            cin >> a;
            if (a == "E")
            {
                if (st.empty())
                { // 结束比开始多
                    f = 2;
                }
                else
                {
                    if (st.top() == -1)
                        cnt--; // 如果是无法执行的循环结束
                    else if (st.top() == 1 && !cnt)
                        tot--; // 如果可执行的循环结束
                    st.pop();
                    mp[st2.top()]--; // 剔除循环变量
                    st2.pop();
                }
            }
            else
            {
                cin >> b >> c >> d;
                if (mp[b])
                    f = 1; // 如果循环变量重复
                s = 0;     // 记录循环起值
                t = 0;     // 记录循环终值
                mp[b]++;
                if (c == "n")
                    s = 114514; // 如果是 n 开始那就把 s 设为极大值
                else
                {
                    for (int i = 0; i < c.length(); i++)
                    {
                        s = s * 10 + c[i] - '0';
                    } // 否则提取 s
                }
                if (d == "n")
                    t = 114514; // t 同理
                else
                {
                    for (int i = 0; i < d.length(); i++)
                    {
                        t = t * 10 + d[i] - '0';
                    }
                }
                st2.push(b);
                if (t - s >= 100000)
                { // t 若为 114514-smax(100)=114414，这里为了保险
                    if (!cnt)
                        tot++;           // 增加一层循环
                    ans = max(ans, tot); // 求出最大时间复杂度
                    st.push(1);          // 塞进去一层可执行循环
                }
                else if (t < s)
                {
                    cnt++;
                    st.push(-1); // 不可执行循环，妨碍后面执行
                }
                else
                    st.push(0); // 其他情况，不必处理
            }
            if (!st.empty() || f)
                printf("ERR\n"); // 如果循环变量重复或者开始和结束不匹配
            else if (want == ans)
                printf("Yes\n"); // 时间复杂度正确
            else
                printf("No\n"); // 错误
        }
        return 0;
    }
}
```

---


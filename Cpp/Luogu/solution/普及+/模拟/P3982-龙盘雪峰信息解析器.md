# 龙盘雪峰信息解析器

## 题目背景

```cpp
薄雾笼罩，远方的雪峰无限迷人，感慨之间，阴影将至。
```
与真程海洋毗邻的龙盘雪山与我们保持着联系，但是龙盘雪山的通讯员常常把信息进行奇怪的加密，然后要我们来破译，很是谨慎。但是，久而久之，我们的通讯员不耐烦了，差点掀桌子砸凳子不干了。所以我们想做一个信息解析器，就是这样。


## 题目描述

龙盘雪峰传来的信息都加密成了复杂的代码，我们需要你来做一个程序，按照解析规则解密这些代码，翻译成文字信息，以下是其解析规则：

该代码应为一连串的二进制码（只存在$ 0 $和$ 1 $，做加法时满$ 2 $进$ 1 $，每个$ 0 $或$ 1 $占一个字符），每八个字符为一单元（这也是规则）。

每个单元都有这样的规则：一、若【前三个字符】为$ 101 $时表示需要转换为字母$ A-Z $，字母$ A $代码为$ 10100000 $，字母$ C $为$ 10100010 $，$ 26 $个**大写字母**以字母表顺序按照这种规律顺序排列，分别对应一个二进制代码。二、若【前三个字符】为$ 111 $，则该单元翻译为空格。三、若【第一个字符】为$ 0 $，则该单元表示一个数，待定**与下一个单元所表示的数做加法**。加法过程中，这两个单元应转换为十进制，然后除以$ 2 $并**舍弃余数**才相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果（翻译结果用十进制表示，**这两个单元**就都翻译完毕了，详见样例$ 3 $）。

由于保险，龙盘雪峰经常发送【假代码】，而假代码则不存在上述规则，如果是假代码，**仅**输出$ Error $。


## 说明/提示

### 样例一说明：

$ 10100000 $代表$ A $，下一个单元开头为$ 111 $，那么翻译为空格，再下一个单元开头为$ 101 $，后接$ 01111 $，比$ A $多了$ 2^0+2^1+2^2+2^3=15 $，那么代表的就是$ P $了，以此类推，最后翻译为$ A\;PIG $。

### 注意：

对于规则一的解释：$ 26 $个大写字母按照字母表的顺序排列，以$ A=10100000 $开始，往后的每一个字母的二进制码的值都比前面一个字母的二进制码的值多$ 1 $（注意满二进一）；

此题目有误解题意的现象，请一定要看清楚题目，搞清楚逻辑关系，注意细节！


## 样例 #1

### 输入

```
1010000011100000101011111010100010100110```

### 输出

```
A PIG```

## 样例 #2

### 输入

```
1```

### 输出

```
Error```

## 样例 #3

### 输入

```
0000001000000010000000100000001010100000```

### 输出

```
22A```

## 样例 #4

### 输入

```
IOIOOOOI```

### 输出

```
Error```

# 题解

## 作者：B_Qu1e7 (赞：8)

写了一篇没人写过的题解

其实这道题说简单，是很简单

但是难就难在它Error的判断和如何操作以0开头的单元

还有一个大家普遍被难的就是，不能操作到一半，输出输一半

哎，发现不对了，赶紧输出Error，这样输出就会变得很奇怪

所以最好像本解的put一样，先存进一个字符串，最后输出

下面我们来看看解析（纯模拟）

```cpp
#include<iostream>
using namespace std;
string s,put="",nm;int pl=0,c,a,b;
string del(string c){for(int i=0;i<8;i++)c.erase(0,1);return c;}
//上面这个地方是每8位操作完毕后清除一次
//个人比较习惯操作字符串时都是在首位操作
int main()
{
    cin>>s;
    if(s.size()%8){cout<<"Error";return 0;}
    //这个地方判断，因为它每8位一个单元
    //所以一定是整数个单元。（易判断）
    while(s.size())
    {
        if((s[0]!='0'&&s[0]!='1')||(s[1]!='0'&&s[1]!='1')||(s[2]!='0'&&s[2]!='1')||(s[3]!='0'&&s[3]!='1')||(s[4]!='0'&&s[4]!='1')||(s[5]!='0'&&s[5]!='1')||(s[6]!='0'&&s[6]!='1')||(s[7]!='0'&&s[7]!='1')){cout<<"Error";return 0;}
        //这个地方写了这么大一长串，啥意思呢
        //其实就是判断，因为它是一个二进制加密码
        //所以每一位都必须是0or1（还不如开头直接全判）
        else if(s[0]=='1'&&s[1]=='1'&&s[2]=='1'){if(pl){cout<<"Error";return 0;}s=del(s);put+=" ";continue;}
        //这个地方的话是加空格
        //但要注意，如果前一个单元是请求加法单元
        //那么这个单元是空格，就错误了，所以应该判错
        else if(s[0]=='1'&&s[1]=='0'&&s[2]=='1')
        {
            if(pl){cout<<"Error";return 0;}
            //跟前一注释一样
            int d=(s[7]-48)*1+(s[6]-48)*2+(s[5]-48)*4+(s[4]-48)*8+(s[3]-48)*16;
            //这里算这个字母是什么
            if(d>25){cout<<"Error";return 0;}
            //防止超过
            put+=(char)(65+d);
            //注意一下，如样例，10100000代表A
            //那么可以推出公式65+00000=ascii(65)=A
        }
        else if(s[0]=='0')
        {
            a=((s[7]-48)*1+(s[6]-48)*2+(s[5]-48)*4+(s[4]-48)*8+(s[3]-48)*16+(s[2]-48)*32+(s[1]-48)*64)/2;
            if(!pl)//还没有加数
            {
                b=a,pl=1;//交换加数和被加数
            }
            else if(pl)//有加数
            {
                c=a+b;a=b=pl=0;nm="";
                if(!c)nm="0";
                else while(c){nm=(char)(c%10+48)+nm,c/=10;}
                //这里，c有可能=0或高于一位数
                //c=0在前一句，而后面是处理多位数
                put+=nm;
                //加到输出中
            }
        }
        else{cout<<"Error";return 0;}
        //如果这个单元不符合任意规则则出错
        s=del(s);
        //删除前八
    }
    if(pl)cout<<"Error";//最后单元为加数（无被加数）
    else cout<<put;
}
```

---

## 作者：天南星魔芋 (赞：4)

### C++ string 大法好


------------

众所周知，C++ 中的 string 是针对字符串处理的类，有很多方便的函数。


$$$$


比如：


* a.find(x,y) 在 string $a$ 中从 $y$ 开始查找字符串 $x$。


* a.substr(x,y) 在 string $a$ 中从 $x$ 开始截取 $y$ 个字符。


* a.erase(x,y) 在 string $a$ 中从 $x$ 开始删除 $y$ 个字符。

$$$$

那么这题就变得简单了，不过有一些坑点需要注意：


* 在代码中混入奇奇怪怪的字符，在开头特判。


* 这一单元是数字而下一单元不是，过程中特判。


* 划分成单元后有剩余，过程中特判。


$$$$



另：对于 仅输出 Error，我们先将答案存入输出缓存数组 buffer （就是个 string 数组）中，特判 Error 后输出就行了。


$$$$

知道这些坑点后我们就可以开始写代码了：


$$$$


#### 首先 define 和定义些基础函数


```cpp
#define sub(x,y,z) x.substr(y,z)
#define len(x) x.length()
int minn(int x,int y){
	return x>y? y:x;
}
```

$$$$


#### read() 每次截取一个单元



```cpp
void read(string &x){//对赋值字符串取址
	x="";//清空
    x=sub(a,0,minn(8,len(a)));//截取，注意可能不满8位 
	if(len(a)>8)a=sub(a,8,len(a)-8);//删除a中截取部分， 			
  			            	       //也就是截取a中未用部分
	else a="";   
}
```

$$$$


#### R_int() 将 string 转化为 int



```cpp
void R_int(string p,int &x){
	x=0;int zz=0;//初始化。
	while(p[zz]=='0'||p[zz]=='1')x=(x<<1)+(p[zz++]^'0'); //符合 0,1 读入
}
```

$$$$



#### write() 将 int 转化为 string


```cpp
void write(int x){//普通快输
	int zan[20],top=0;
	if(!x)zan[++top]=0;
	while(x){
		zan[++top]=x%10;
		x/=10;
	}
	while(top){ 
		buffer+=(zan[top--]^'0');//唯一不同是将输出存入buffer中
	}
}
```


$$$$


#### 处理每个单元


```cpp
void cl(){
	string x,y;//存字符串
	int xx,yy;//存数
	while(1){
		if(error)return ;//有ERROR直接返回
		read(x);//读入下一个串
		if(!x[0])return ;//没串可读（串为空）
		if(len(x)<8){error=true;return ;}//不足8时 ERROR
		if(x.find("101",0)==0){//字符
			x.erase(0,3);//除去开头3个字符 
			R_int(x,xx);//转化为int
			xx+='A';//转化为字符 
			if(xx<'A'||xx>'Z'){error=true;return ;}//若不是A~Z则错误     
			buffer+=(char)xx;//加入缓存      
		} 
		else if(x.find("111",0)==0){//空格 
			buffer+=' ';  
		}
		else if(x[0]=='0'){//为数字
			x.erase(0,1);//擦除标识符
			read(y);//读入下一个数字串
			if(len(y)<8||y[0]!='0'){error=true;return ;}//不合法
			y.erase(0,1);//擦除标识符
			R_int(x,xx);R_int(y,yy);//转int
			xx/=2;
			yy/=2;
			write(xx+yy);//计算，加入缓存 
		}      
		else {error=true;return ;}//啥都不是 ERROR       
	}    
}
```

$$$$


#### 人见人爱的main包


```cpp
int main(){
	cin>>a;    
	for(int i=0;i<len(a);i++){
		if(a[i]!='0'&&a[i]!='1')error=1;//特判有没有奇奇怪怪的字符 
	}
	if(!error)cl();//处理
	if(!error)cout<<buffer<<endl;//输出
	else cout<<"Error"<<endl;
}
```



这篇题解就到这里了，如有不足请指出。



---

## 作者：AuCloud (赞：4)

一道细节爆炸的模拟~~水~~题

# 读入

我采取的是按单元读入——每8个字符为一行进行读入

因为错误时只能输出`Error`，所以没有选择边读边算，而是离线读完一起算

### 细节1

读入的字符可能不都是'0'和'1'（详见样例4）所以要特判

### 细节2

若凑不成一个完整的单元，则不合法，直接Error

```cpp
int n = 1;
while(cin >> a[n][1])
{
    for(int i = 2; i <= 8; i++)
    {
       cin >> a[n][i];
       if(!a[n][i] || (a[n][i] != '1' && a[n][i] != '0'))
       {
            cout << "Error";
            exit(0);
        }
    }
    n++;
}
n--;
```
# 预处理

预处理出了$2^n$（当然可以现算）

```cpp
for(int i = 1; i <= 7; i++)
    num[i] = num[i - 1] * 2;
```

# 字符

先用`a[i][1] == '1' && a[i][2] == '0' && a[i][3] == '1'`判断这是个字符

然后将后面的字按二进制转成10进制就好

### 细节3

编号从0开始而不是1

### 细节4

当转换后的数字+'A'>'Z'时，不合法

```cpp
if(a[i][1] == '1' && a[i][2] == '0' && a[i][3] == '1')
{
    int ls = 0;
    for(int j = 4; j <= 8; j++)
    {
        ls += (a[i][j] - '0') * num[8 - j];
    }
    if(ls + 'A' > 'Z')
    {
        cout << "Error";
        exit(0);
    }
    ans[++tot] = char(ls + 'A');
}
```

# 空格

跟字符一样的判断，这里没有不合法的情况，直接记录答案就行/

```cpp
else if(a[i][1] == '1' && a[i][2] == '1' && a[i][3] == '1')
{
    ans[++tot] = ' ';
}
```
# 数字

判断第一位是不是'0'

第一个数字转换完成后手动`i++`再转换下一个即可

最后加在一起再按位转换回字符串的形式

### 细节5
需要两个数字**分别**除以二向下取整再**相加**（其实算读题的锅啦……）

### 细节6

若下面的单元不是数字/下面没有剩余的单元则不合法

### 细节7

在我的做法里数字为0时要特判，不然不会输出任何东西…

```cpp
else if(a[i][1] == '0')
{
    int x = 0, y = 0;
    for(int j = 2; j <= 8; j++)
    {
        x += (a[i][j] - '0') * num[8 - j];
    }
    i++;
    if(i > n || a[i][1] != '0')
    {
        cout << "Error";
        exit(0);
    }
    for(int j = 2; j <= 8; j++)
    {
        y += (a[i][j] - '0') * num[8 - j];
    }
    int now = x / 2 + y / 2;
    int cnt = 1;
    int qaq = now;
    if(now == 0) ans[++tot] = '0';
    while(now)
    {
        cnt *= 10;
        now /= 10;
    }
    cnt /= 10;
    now = qaq;
    while(cnt)
    {
        ans[++tot] = (char)(now / cnt + '0');
        now %= cnt;
        cnt /= 10;
    }
}
```
# 均不是

若这个单元不是字符不是空格也不是数字，则不合法，直接Error

```cpp
else
{
    cout << "Error";
    exit(0);
}
```

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[200000][10];
char ans[200001];
int num[10];
int tot;
int main()
{
    int n = 1;
    while(cin >> a[n][1])
    {
        for(int i = 2; i <= 8; i++)
        {
            cin >> a[n][i];
            if(!a[n][i] || (a[n][i] != '1' && a[n][i] != '0'))
            {
                cout << "Error";
                exit(0);
            }
        }
        n++;
    }
    n--;
    num[0] = 1;
    for(int i = 1; i <= 7; i++)
        num[i] = num[i - 1] * 2;
    for(int i = 1; i <= n; i++)
    {
        if(a[i][1] == '1' && a[i][2] == '0' && a[i][3] == '1')
        {
            int ls = 0;
            for(int j = 4; j <= 8; j++)
            {
                ls += (a[i][j] - '0') * num[8 - j];
            }
            if(ls + 'A' > 'Z')
            {
                cout << "Error";
                exit(0);
            }
            ans[++tot] = char(ls + 'A');
        }
        else if(a[i][1] == '1' && a[i][2] == '1' && a[i][3] == '1')
        {
            ans[++tot] = ' ';
        }
        else if(a[i][1] == '0')
        {
            int x = 0, y = 0;
            for(int j = 2; j <= 8; j++)
            {
                x += (a[i][j] - '0') * num[8 - j];
            }
            i++;
            if(i > n || a[i][1] != '0')
            {
                cout << "Error";
                exit(0);
            }
            for(int j = 2; j <= 8; j++)
            {
                y += (a[i][j] - '0') * num[8 - j];
            }
            int now = x / 2 + y / 2;
            int cnt = 1;
            int qaq = now;
            if(now == 0) ans[++tot] = '0';
            while(now)
            {
                cnt *= 10;
                now /= 10;
            }
            cnt /= 10;
            now = qaq;
            while(cnt)
            {
                ans[++tot] = (char)(now / cnt + '0');
                now %= cnt;
                cnt /= 10;
            }
        }
        else
        {
            cout << "Error";
            exit(0);
        }
    }
    cout << (ans + 1) << endl;
}

```

感觉细节量跟~~臭名昭著的~~ [斗地主增强版](https://www.luogu.com.cn/problem/P2540)比还是差了那么一点（毕竟是个绿题而已）

想锻炼细节的选手可以去刷刷上面那个哦

---

## 作者：Naptie (赞：3)

## [P3982](https://www.luogu.com.cn/problem/P3982) Java 版题解

 _这题我一看标签，“模拟”“字符串”“进制”，啪的一下就点进来了，很快啊，一个 [IDEA](https://www.jetbrains.com/idea/) 就打开了_
 #### _——用 Java 优雅地解决细节巨多的模拟题_ 
###### 优雅永不过时！
 ~~这道题的大体思路是，按照题目说的去做~~
 
- ### 输出 Error 的情况
	1. 源信息长度不能被 $8$ 整除
	2. 源信息存在除 `0` 与 `1` 以外的字符
	3. 某个单元以 `101` 开头，但是后 $5$ 位转换成的十进制数大于或等于 $26$（即不能表示为 $A-Z$ 中的字符；由于转换之后的十进制数只能是非负整数，所以可以忽略负整数的情况）
	4. 某个单元以 `0` 开头，但是下一个单元不以 `0` 开头
	5. 某个单元以 `0` 开头，但是不存在下一个单元
	6. 某个单元不以 `111`，`101`，`0` 开头
- ### 将源信息转换为由单元组成的列表的方法
```java
	private static List<String> convert(String originalInfo) {
		List<String> result = new ArrayList<>();
		int n = originalInfo.length() / 8;
		for (int i = 0; i < n; i++) {
			result.add(originalInfo.substring(i * 8, i * 8 + 8));
		}
		return result;
	}
```
- ### 将二进制字符串转换为十进制数的方法
```java
Integer.parseInt((new BigInteger(string, 2).toString(10)));
```
其中，`string` 表示待处理的二进制字符串
- ### 小细节
	1. 如果某个单元成功与下一个单元联动出数字，则要直接跳到下下个单元，即除了 `for` 循环的 `i++`，还要额外进行一次 `i++`
	2. 不要将某个单元处理完后立即输出结果，因为你不知道后面的单元是否会爆 `Error`（题目中明确强调“若该二进制代码中存在假代码信息，则只输出`Error`”）
	3. Java 中 `String` 的 `substring(int beginIndex, int endIndex)` 方法所截取的字符串包含下标为 `beginIndex` 的字符，但不包含下标为 `endIndex` 的字符
	4. 提交时代码中不能含有 `package` 语句，否则全 RE

------------

#### 最后，来一个全 RE 代码
```java
package me.naptie.oi;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

	private static boolean debug;

	public static void main(String[] args) {
		debug = args.length != 0;
		Scanner input = new Scanner(System.in);
		String originalInfo = input.next();
		StringBuilder answer = new StringBuilder();
		validate(originalInfo);
		List<String> infoList = convert(originalInfo);
		for (int i = 0; i < infoList.size(); i++) {
			String info = infoList.get(i);
			if (debug) {
				System.out.print("Parsing Info " + i + ": " + info);
			}
			if (info.startsWith("111")) {
				if (debug) {
					System.out.println(", which is a space");
				}
				answer.append(" ");
			} else if (info.startsWith("101")) {
				int dec = Integer.parseInt((new BigInteger(info.substring(3, 8), 2).toString(10)));
				if (dec >= 26) {
					if (debug) {
						System.out.println(", which is an invalid character with Number " + dec);
					}
					error();
				} else {
					answer.append((char) (dec + 'A'));
					if (debug) {
						System.out.println(", which is a valid character '" + (char) (dec + 'A') + "'");
					}
				}
			} else if (i + 1 < infoList.size()) {
				if (info.charAt(0) == '0') {
					String nextInfo = infoList.get(i + 1);
					if (nextInfo.charAt(0) == '0') {
						int a = Integer.parseInt((new BigInteger(info.substring(1, 8), 2).toString(10)));
						int b = Integer.parseInt((new BigInteger(nextInfo.substring(1, 8), 2).toString(10)));
						int c = a / 2 + b / 2;
						answer.append(c);
						i++;
						if (debug) {
							System.out.println(", which is Number " + a + ", calculable with " + b + ", returning " + c);
						}
					} else {
						if (debug) {
							System.out.println(", which is ready to be calculated but its next info is not a number");
						}
						error();
					}
				} else {
					error();
				}
			} else {
				if (debug) {
					System.out.println(", which does not match any rule");
				}
				error();
			}
		}
		System.out.print(answer);
	}

	private static void validate(String originalInfo) {
		if (originalInfo.length() % 8 != 0) {
			error();
		}
		for (char c : originalInfo.toCharArray()) {
			if (c != '0' && c != '1') {
				error();
			}
		}
	}

	private static List<String> convert(String originalInfo) {
		List<String> result = new ArrayList<>();
		int n = originalInfo.length() / 8;
		for (int i = 0; i < n; i++) {
			result.add(originalInfo.substring(i * 8, i * 8 + 8));
		}
		if (debug) {
			System.out.println("The original information has been converted to the following list:");
			for (String info : result) {
				System.out.println(info);
			}
		}
		return result;
	}

	private static void error() {
		System.out.println("Error");
		System.exit(0);
	}
}

```

---

## 作者：uid_310801 (赞：2)

这题是一道~~简单的~~字符串模拟题，但是坑比较多。

具体思路是：分成若干段，每段运行一个判断，如果合法将新字符添加到答案字符串里，否则就输出$Error$。

需要注意的几点：

- $Error$的判断。

	当长度不是$8$的倍数时，输出$Error$。
    
    当出现不是‘$0$’或‘$1$’的字符时，输出$Error$。
    
    当开头三个是“$110$”时，输出$Error$。
   
  当这一段是数字而下一段不是数字时，输出$Error$。

- 字符与数字，十进制与二进制的转化

注意到这些，这道题就很简单了。~~虽然我WA了好几次~~

$Code$（已加防$Ctrl+c,v$）

```cpp
#include<bits/stdc++.h>
#define err printf("error");return 0;//输出Error并且结束程序。
				//注意要把这条语句用大括号括起来，因为这是两个语句。
using namespace std;

char a[23333];//a数组是输入的字符串
int b[10];//代表每一段的数字。
string s="";//答案字符串

int main()
{
	cin>>a;
	int n=strlen(a);
	if(n%8!=0)	{err}//如果不是8的整数倍，就输出Error
	for(int i=0;i<n;i++)
	{
		if(a[i]!='1'&&a[i]!='0'){err}
	}//当出现不是‘0’或‘1’的字符时，输出Error。
	n/=8;//将长度除以八。现在n代表的是段数。
	for(int k=0;k<n;k++)
	{
		for(int j=0;j<8;j++)
			b[j]=a[k*8+j]-'0';//将数据存在b数组里。
		if(b[0]==1&&b[1]==1&&b[2]==1)
		{
			s+=" ";
			continue;
		}//空格。
		else if(b[0]==1&&b[1]==0&&b[2]==1)//字母
		{
			int c=(b[3]*2*2*2*2+b[4]*2*2*2+b[5]*2*2+b[6]*2+b[7]);//暴力二进制转十进制。
			if(c>=26)	{err}//如果大于Z了，就输出Error。我因此调了十几分钟。
			s+=(char)(c+'A');
		}
		else if(b[0]==0&&a[(k+1)*8]=='0')//数字（如果下一个段数不是数字，就输出Error）
		{
			int c=(b[1]*2*2*2*2*2*2+b[2]*2*2*2*2*2+b[3]*2*2*2*2+b[4]*2*2*2+b[5]*2*2+b[6]*2+b[7]);//暴力二转十*10
			k++;//段数+1。
			for(int j=0;j<8;j++)
				b[j]=a[k*8+j]-'0';//再转换一次。
			int d=(b[1]*2*2*2*2*2*2+b[2]*2*2*2*2*2+b[3]*2*2*2*2+b[4]*2*2*2+b[5]*2*2+b[6]*2+b[7]);//暴力二转十*11
			int e=c/2+d/2;//C++的除法自带的向下取整。
			string f="";//备用字符串
			int l=0;//数字的长度
			if(e==0)//0的特判
			{
				s+='0';
				continue;
			}	
			while(e!=0)
			{
				f+=(char)((e%10)+'0');
				e/=10;
               			l++;
			}//将e倒叙存入f中。
			for(int i=l-1;i>=0;i--)
			{
				s+=f[i];
			}//将f倒叙存入答案字符串中。
		}
		else
		{
			err
		}//如果以上几种情况都不满足，输出Error
	}
	cout<<s;//数据无误，输出答案字符串。
	return 0;
	
}
```
理解万岁，切莫抄袭。

祝大家[AC](https://www.luogu.com.cn/record/list?user=310801&pid=P3982&language=&orderBy=0&page=1)这道水绿

---

## 作者：寒酥 (赞：2)

字符串模拟大法，明确题目中的坑：
1.输入不一定为0，1；
2.前三位不能是110；
3.字母只有26个，但是5位二进制可以到31；
4.计算加法时，前后两单元首位都要为0；
然后我就将加法的16位按整体一起算
之后就是按题意模拟了
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
char cha[10005],ch[1000];
int main(){
    cin>>s;
    int len = s.size(),num = 0;
    if(len%8){
        cout<<"Error";
        return 0;
    }
    for(int i = 0;i<len;++i){//1.
        if(s[i]!='1'&&s[i]!='0'){
            cout<<"Error";
            return 0;
        }
    }
    for(int i = 0;i<len;++i){
        if(s[i] == '1'){
            if(s[i+1] == '0'&&s[i+2] == '1'){
                int sum = 0;
                for(int j = i+3,tot = 5;j <= i+7;++j){
                    sum+=(s[j]-'0')*(pow(2,--tot));
                    if(sum>25){3.
                        cout<<"Error";
                        return 0;
                    }
                }
                cha[++num] = (sum+'A');
            }
            if(s[i+1] == '1'){
            	if(s[i+2] == '1') cha[++num] = ' ';
                else{2.
                	cout<<"Error";
                    return 0;
				}
            }
            
            i = i+7;
        }
        else if(s[i] == '0'){4.
            int j,ans1 = 0,ans2 = 0,tot = 7,cnt = 0;
            for(j = i+1;j <= i+7;++j){
                ans1+=(s[j]-'0')*(pow(2,--tot));
            }
            ans1/=2,i = j;
            if(s[i] != '0'){
                cout<<"Error";
                return 0;
            }
            for(j = i+1,tot = 7;j <= i+7;++j){
                ans2+=(s[j]-'0')*(pow(2,--tot));
            }
            ans1+=ans2/2;
            if(!ans1) cha[++num] = '0';
            else{
            	for(cnt = 0;ans1;ans1/=10){
            		ch[++cnt] = ((ans1%10)+'0');
            	}
            	for(;cnt;) cha[++num] = ch[cnt--];
            }
            i = j-1;
        }
    }
    for(int i = 1;i<=num;++i) cout<<cha[i];
    return 0;
}
```

---

## 作者：Waterwzy (赞：0)

这一题很多题解都是边转换边判断，蒟蒻表示不理解，为了~~爽~~方便，我直接先判断合不合法，然后直接转换的。  
总结几个坑点：  
1. 有奇奇怪怪的字符，Error。  
2. 不是 $8$ 的倍数，Error。
3. 字母大于'$Z$'，Error。
4. 只有一个数字或者一个数字后终止了，Error（这里坑了我好多遍）。
5. 一些奇奇怪怪的开头，比如“110”，Error。
6. 数字是**分别**除以 $2$ 然后相加。  
上代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int zh(string e,int w,int mei){
		int ans=0,base=pow(2,mei-1);
		for(int i=w;i<=w+mei-1;i++){
			ans+=(e[i]-'0')*base;
			base/=2;
		}
		return ans;
}
int last;
bool ck(string s){
		if(s.length()%8!=0)return 0;
		for(int i=0;i<s.length();i++)if(s[i]!='1'&&s[i]!='0')return 0;
		for(int i=0;i<s.length();i+=8){
			if(last==1&&s[i]!='0')return 0;
			if(s[i]=='1'&&s[i+1]=='1'&&s[i+2]=='1')continue;
			if(s[i]=='0'){
				if(last==0)last=1;
				else last=0;
				continue;
			}
			if(s[i]=='1'&&s[i+1]=='0'&&s[i+2]=='1'){
				if(zh(s,i+3,5)>25)return 0;
			}
			else return 0;
		}
		return 1;
}
int main(){
		cin>>a;
		if(!ck(a)){
			cout<<"Error";
			return 0;
		}
		if(last==1){
			cout<<"Error";
			return 0;
		}
		int s1=0;
		bool flag=0;
		for(int i=0;i<a.length();i+=8){
			if(a[i]=='1'&&a[i+1]=='1'&&a[i+2]=='1'){
				cout<<" ";
				continue;
			}
			if(a[i]=='0'){
				int wee=zh(a,i,8);
				if(flag==1){
					cout<<s1+wee/2;
					flag=0;
				}
         	}
			else{
				flag=1;
				s1=wee;
				s1/=2; 
			}	
			if(a[i]=='1'&&a[i+1]=='0'&&a[i+2]=='1')cout<<char(zh(a,i+3,5)+'A');
		}
		return 0;
}
```
附上 $AC$ [记录](https://www.luogu.com.cn/record/list?pid=P3982&user=388829&page=1)

---

## 作者：_Spectator_ (赞：0)

首先，我们来分析一下每一个规则：

1. 若【前三个字符】为 $101$ 时表示需要转换为字母 $A-Z$ ，字母 $A$ 代码为  $10100000$ ，字母 $C$ 为 $10100010$ ， $26$ 个大写字母以字母表顺序按照这种规律顺序排列，分别对应一个**二进制代码**。

对于第 $1$ 个规则，该单元是用**第 $4$ 位到第 $8$ 位**来表示这一个字母的二进制代码（ $00000-11010$ 分别代表 $A-Z$）。那么，重点来了： **如果第 $4$ 位到第 $8$ 位所表示的 $2$ 进制数比 $11010$ 大，那么就是“Error”**。

2. 若【前三个字符】为 $111$ ，则该单元翻译为空格。

第 $2$ 个规则，非常好判断。

3. 若【第一个字符】为 $0$ ，则该单元表示一个数，待定与 下一个单元所表示的数做加法。加法过程中，这两个单元应转换为十进制，然后除以 $2$ 取整再相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果（翻译结果用十进制表示，这两个单元**就都翻译完毕了**）。

对于第 $3$ 个规则，如果出现加法单元，那么它必定是**成对出现**的，如果没有满足条件，那么就是“Error”。

---
因为我们可能在判断某一个单元的途中发现“Error”，所以我们需要一个字符串 $ ans $ 来储存答案。

---
---
## ${\color{SkyBlue}General}$  ${\color{SkyBlue}Ideas}$
**重点是判断“Error”的情况。**

那么如何判断是否“Error”呢？如下：

- Error-1. 某个单元不完整。
- Error-2. 代码中出现别的奇奇怪怪的字符。
- Error-3. 加法单元没有成对出现。
- Error-4. 字母单元所表示的字符不在 $A-Z$ 范围内。

---
---
## ${\color{SkyBlue}Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,ans; 
int a,b;
bool p=false;
inline string zs(int x)
{
	string s="\0";
	if(x==0) return "0";
	while(x>0) s+=x%10+48,x/=10;
	reverse(s.begin(),s.end());//用 reverse 让 s 倒序 
	return s;
}
int main()
{
	#error\
	温馨提示：禁止抄题解
	cin>>s;
	if(s.size()%8!=0) 
		{printf("Error");return 0;}//Error-1
	while(s.size()>0)
	{
		string st=s.substr(0,8);//提取出一个单元 
		for(int i=0; i<8; i++)
			if(s[i]!='1' && s[i]!='0')//Error-2
				{printf("Error");return 0;}
		if(s[0]=='1' && p==true) //Error-3
			{printf("Error");return 0;}
		if(s[0]=='1' && s[1]=='1' && s[2]=='1') ans+=" ";//空格 
		if(s[0]=='1' && s[1]=='0' && s[2]=='1')//字母 
		{
			int wq=1,sum=65;
			for(int i=8-1; i>=3; i--)
				sum+=(s[i]-'0')*wq,wq=wq+wq;
			if(sum>90) {printf("Error");return 0;}//Error-4
			ans+=char(sum);
		}
		if(s[0]=='0')//数字
		{
			int wq=1,sum=0;
			for(int i=8-1; i>=0; i--)//把这个单元转换成数字 
				sum+=(s[i]-'0')*wq,wq=wq+wq;
			if(p==true)//它是一组加法单元中的第 2 个 
			{
				b=sum;
				a/=2,b/=2;
				ans+=zs(a+b);
				a=0,b=0;
			}
			else//它是一组加法单元中的第 1 个 
				a=sum;
			p=1-p;
		}
		s.erase(0,8);//删除一个单元 
	} 
	if(p==true) {printf("Error");return 0;}//最后记得特判！ 
	cout<<ans;
 	return 0;
}
```
---
说明：By Xin。本人乃2016级小学生，思路比较简单，题解如有写的不好的地方请指正。

---

## 作者：KevTheDev (赞：0)

## 前置知识

首先我们来了解一个超级好用的函数，跨平台，可以将一个 C 风格字符串转成一个 $2 \sim 36$ 进制的数字，函数签名如下：

```cpp
long int strtol(const char *nptr, char **endptr, int base);
```

其中 `nptr` 是要转换的字符串（C 风格！），`endptr` 为「指向指向字符指针的指针」（语出 cppreference，你只需要知道它平常用时传个 `NULL` 就行），`base` 为进制，可取 ${0, 2, 3, 4, \dots, 36}$，当 `base` 为 $0$ 时则依照前缀自动判断（`0x`$/$`0X` 为 $16$ 进制，`0` 为 $8$ 进制，否则为 $10$ 进制）。

它的扫描方法如下：  
> 舍弃所有空白符（以调用 isspace() 鉴别），直到找到首个非空白符，然后取尽可能多的字符组成底 n （其中 n=base ）的整数表示，并将它们转换成一个整数值。  
> ——cppreference

加上 `string` 大法，语法无障碍！

## 思路

首先我们先判断字符串的长度是否能被 $8$ 整除，再判断这个串是否只包含 `0` 和 `1`，两者有一个不符合直接 `Error`。

然后要注意的是，**不能边处理边打印**，万一中途 `Error` 了呢？所以要把结果存个字符串，最后输出。

再者，就是当我们处理字母的时候，**一定要特判是否越界**。同理，我们还需特判**有没有在加法时插入字符或空格**，for example（为了看着方便，我把单元格用空格分开了）  
`00000010 11100000` $\rightarrow$ `Error`！ 

最后如果加法做了一半戛然而止的话也要 `Error` 的。

## 代码

```cpp
#include <iostream>
#include <string>
#include <cctype>
#include <cstdlib>
#include <sstream>
using namespace std;

string s, res = "";

bool isBin(string s)
{
	for (int i = 0; i < 8; i++)
	{
		if (s[i] != '0' && s[i] != '1')
			return false;
	}
	return true;
}

int main()
{
	cin >> s;

	// 判断长度是否能被 8 整除
	if (s.size() % 8)
	{
		cout << "Error" << endl;
		return 0;
	}

	int prevNum = 0;
	int flag = 0; // 是否在做加法
	for (int i = 0; i < s.size(); i += 8)
	{
		string temp = s.substr(i, 8);

		// 判断是否只由 0 和 1 组成
		if (!isBin(temp))
		{
			cout << "Error" << endl;
			return 0;
		}

		if (temp[0] == '1' && temp[1] == '0' && temp[2] == '1')
		{
			if (flag)
			{
				cout << "Error" << endl;
				return 0;
			}
			// 把前缀分离出去
			string num = temp.substr(3, 5);
			char c = strtol(num.c_str(), NULL, 2) + 'A';
			
			// 判断字母是否越界
			if (!isalpha(c))
			{
				cout << "Error" << endl;
				return 0;
			}
			res += c;
		}
		else if (temp[0] == '1' && temp[1] == '1' && temp[2] == '1')
		{
			if (flag)
			{
				cout << "Error" << endl;
				return 0;
			}
			res += ' ';
		}
		else if (temp[0] == '0')
		{
			if (flag)
			{
				prevNum += strtol(temp.c_str(), NULL, 2) / 2;
				
				// 注意这里用了个 C++ 独有的字符串流拼接数字和字符
				// 这不常用但至少避免了 C 风格字符串和 string 的互相转换
				ostringstream oss;
				oss << res << prevNum;
				res = oss.str();
				flag = 0, prevNum = 0;
			}
			else
			{
				// 标记一下我们在做加法!
				flag = 1;
				prevNum = strtol(temp.c_str(), NULL, 2) / 2;
			}
		}
		else // 如果我们不认识这个前缀
		{
			cout << "Error" << endl;
			return 0;
		}
	}

	// 加法做了一半戛然而止
	if (flag)
		cout << "Error" << endl;
	else
		cout << res << endl;

	return 0;
}
```

---

## 作者：jkrj02 (赞：0)

这道题就是个暴力模拟

考验的其实是耐性和细致

难就难在情况的判定和对数字单元的理解

另外，为了不输出到一半突然出Error

最好是把结果存到一个数组里，最后一块输出

下面是我的代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
char a[172112],b[22389];
int n;
const int s[60]={1,2,4,8,16,32,64};
int main()
{
	int m=0,t=0;//m其实就是个位置符，t是存储数组的下标
	cin>>a;
	if(strlen(a)%8!=0)
	{
		cout<<"Error";
		return 0;
	}
	//如果长度不是8的倍数，那肯定是假代码 
	for(int i=0;i<strlen(a);i++)
	{
		if(a[i]!='0'&&a[i]!='1')
		{
			cout<<"Error";
			return 0;
		}
	}
	//如果代码里有不是0或1的数字，就不是二进制代码，就是假代码了 
	while(m*8<strlen(a))
	{
		//接下来是对各种情况的判定 
		if(a[m*8]=='1')
		{
			if(a[m*8+1]=='1'&&a[m*8+2]=='1')
			{
				b[t]=' ';
			}
			else if(a[m*8+1]=='0'&&a[m*8+2]=='1')
			{
				n=(a[m*8+3]-'0')*s[4]+(a[m*8+4]-'0')*s[3]+(a[m*8+5]-'0')*s[2]+(a[m*8+6]-'0')*s[1]+a[m*8+7]-'0';
				if(n<26)
					b[t]=n+'A';
				else//如果n>=26那就不是字母了 
				{
					cout<<"Error";
					return 0;
				}
			}
			else
			{
				cout<<"Error";
				return 0;
			}
		}
		else if(a[m*8]=='0')
		{
			if(a[m*8+8]=='0')//数字单元必须是两个连在一起的 
			{
				//这里需要注意，数字单元除了第一个数字，其他七位都是二进制数
				n=((a[m*8+1]-'0')*s[6]+(a[m*8+2]-'0')*s[5]+(a[m*8+3]-'0')*s[4]+(a[m*8+4]-'0')*s[3]+(a[m*8+5]-'0')*s[2]+(a[m*8+6]-'0')*s[1]+a[m*8+7]-'0')/2;
				m++;
				n+=((a[m*8+1]-'0')*s[6]+(a[m*8+2]-'0')*s[5]+(a[m*8+3]-'0')*s[4]+(a[m*8+4]-'0')*s[3]+(a[m*8+5]-'0')*s[2]+(a[m*8+6]-'0')*s[1]+a[m*8+7]-'0')/2;
				if(n/100==0)//很暴力的位数判定，因为最大的数也不会超过三位，我就懒得循环了 
				{
					if(n/10==0)
					{
						b[t]=n+'0';
					}
					else
					{
						b[t]=n/10+'0';
						t++;//第二个数字直接存储到下一位 
						b[t]=n%10+'0';
					}
				}
				else
				{
					b[t]=n/100+'0';
					t++;
					b[t]=n/10%10+'0';
					t++;
					b[t]=n%10+'0'; 
				}
			}
			else
			{
				cout<<"Error";
				return 0;
			}
		}
		else
		{
			cout<<"Error";
			return 0;
		}
		m++;
		t++;
	}
	cout<<b;
	return 0;
}
```

---


# 谁能赢呢？

## 题目描述

小明和小红经常玩一个博弈游戏。给定一个 $n\times n$ 的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。

假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？


## 说明/提示

对于 $20\%$ 的数据，保证 $1\le n\le 10$；

对于 $40\%$ 的数据，保证 $1\le n\le 1000$；

对于 $100\%$ 数据，保证 $1\le n\le 10000$。

## 样例 #1

### 输入

```
2
0```

### 输出

```
Alice```

# 题解

## 作者：王熙文 (赞：28)

结论简单但是证明巧妙的题，题解区竟然没有一个像样的证明，因此我写一篇题解。

upd at 2023.7.1: 这篇题解是在大规模撤下题解之前写的，我记得之前提交成题解了，但是不知道为什么也被撤了。我感觉这篇题解证明很清楚啊。

## 思路

结论：当 $n$ 为奇数时后手赢，$n$ 为偶数时先手赢。

证明：

首先将棋盘黑白染色，左上角为黑色。这样先手只会走到白格子，后手只会走到黑格子。将相邻的格子连接。这样形成了二分图。

* 当 $n$ 为奇数时：使用一种方式将不是左上角的格子完美匹配。这样当先手走到一个白格子的时候，后手只需要走到完美匹配中对应的黑格子，就每次都能应对了。但是先手每一次都需要新找到没有被访问过的白格子，迟早会找不到的（最差在最后白格子都染完了先手肯定找不到），所以后手赢。构造完美匹配的方法是：将在第一行相邻的左右匹配，第一列相邻的上下匹配，剩下的位置左右匹配即可。比如，这是 $n=5$ 时的完美匹配。

![](https://cdn.luogu.com.cn/upload/image_hosting/b068ky4q.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

* 当 $n$ 为偶数时：和奇数一样，只不过这次主动权变成了先手。先手先走一步（向下和向右是一样的，所以下面默认向右走），然后使用一种方式将不是左上角和先手走过的格子完美匹配。这样当后手走到一个黑格子里，先手就走到对应的白格子即可。后手迟早会找不到新的，所以先手赢。构造完美匹配的方法是：将每一行相邻的两个左右匹配即可。比如，这是 $n=4$ 时的完美匹配。

![](https://cdn.luogu.com.cn/upload/image_hosting/u8trjzol.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    while(cin>>n && n) cout<<(n%2==0?"Alice":"Bob")<<'\n';
    return 0;
}
```

---

## 作者：StudyingFather (赞：20)

二分图博弈经典题。

所谓**二分图博弈**，指的是这样一类博弈问题：给出一张二分图，指定图上一点 $s$ 放置一颗棋子。两位玩家交替操作，若当前棋子位于 $p$ 点，玩家需要将棋子移动到与 $p$ 有边相邻，且之前还没有被访问的点，不能操作的玩家判负。

四连通的棋盘显然是二分图：向相邻的点移动只能使横坐标或者纵坐标变化 1，当终点与起点重合时，使横坐标增加的移动次数与使横坐标减少的移动次数相等，故横向移动了偶数次，对纵向的情况同理，故图上不存在奇环。

因此本题满足二分图博弈的模型。

对于二分图博弈，有如下定理成立：若起点 $s$ 在该二分图的所有最大匹配中均为匹配点，则先手必胜，反之先手必败。

证明可以参考 [Pecco 的知乎专栏文章](https://zhuanlan.zhihu.com/p/359334008)，此处不再展开。

由于本题的图论模型比较特殊，我们可以直接进行分类讨论，不必再跑 Dinic 判断 $s$ 是否一定在最大匹配中：

- $n$ 为偶数时，最大匹配数为 $\dfrac{n^2}{2}$，为完美匹配，下图给出了一种最大匹配。由于最大匹配为完美匹配，故 $s$ 点一定包含在所有的最大匹配中，先手必胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/19r8acpe.png)

- $n$ 为奇数时，最大匹配数为 $\dfrac{n^2 - 1}{2}$，下图给出了其中一种最大匹配，可见图中左上角的 $s$ 点不在该最大匹配中，故先手必败。

![](https://cdn.luogu.com.cn/upload/image_hosting/wl90yip7.png)

---

## 作者：cmkun (赞：5)

首先我们知道如果 $n$ 为偶数则 $n^2$ 也为偶数，奇数的平方也为奇数。

- 当 $n$ 为偶数时我们可以把整个棋盘分成多个 $1\times 2$ 的方形，因为都是以最优解来走的，所以后手每次都会走到一个新的方形里，给先手留下一个空位，所以后手必败。
- 当 $n$ 为奇数时我们可以把除了起点外整个棋盘分成多个 $1\times 2$ 的方形，那么每次就是先手走到新的方形里，所以先手必败。
  
综上所述我么只需要每次判断 $n$ 的奇偶性就行了。

### 代码实现
```
#include<bits/stdc++.h>
using namespace std;
//puts可以直接换行，在这种题我觉得很好用 
int main(){
	long long n;//十年oi一场空，不开longlong见祖宗 
	while((cin>>n)&&n){
		if(n%2==0) puts("Alice");//n为偶数， 则先手胜 
		else puts("Bob");//否则为后手胜 
	}
	return 0;
}
```


---

## 作者：lbh666 (赞：3)

## 思路
结论：当 $n$ 是奇数时后手赢，否则就先手赢。

先将图黑白染色，左上角为黑色，相邻的两个格子一个黑一个白，一黑一白形成了一个 $1 \times 2$ 的骨牌。

证明如下。

当 $n$ 为偶数时，我们可以得到下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/bd291g4f.png)

- 先手考虑走到右边的白格子中，让剩下的格子恰好能被骨牌覆盖，这样子，后手无论怎么走，都走到新的骨牌中的黑格子，那么先手就可以走骨牌中剩下的白格子，让骨牌被填满，最后，后手一定会走不了，而先手还有一个白格子可以走，故先手必胜。

再来考虑 $n$ 是奇数的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/z3p1ohcw.png)

- 先手无论怎么走，都会走到新的骨牌的白格子中，此时后手掌握了主动权，只需每次走对应骨牌的黑格子，就可以让先手最后没地方可走，故后手必胜。

- 证明完后，我们对于每一次询问，判断 $n$ 是否为偶数，再输出即可。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;

int main(){
	while(cin>>n){
		if(n==0)break;
		if(n%2==0)cout<<"Alice\n";//n是偶数，先手胜 
		else cout<<"Bob\n";//n是奇数，后手胜 
	}
	return 0;
}
```

---

## 作者：Yanran_10086 (赞：2)

首先这道题很明显是二分图博弈。

二分图博弈是指在一个二分图中进行的博弈游戏。二分图是指一个图的顶点可以分为两个独立的集合，且图中不存在同一个集合内的顶点之间有边相连的情况。

在二分图博弈中，通常有两位玩家轮流在图的顶点上放置标记或移动标记。每位玩家根据特定规则选择一个未被标记的顶点，并将自己的标记放置在该顶点上或将标记从一个顶点移动到另一个未被标记的顶点上。博弈的目标通常是使得对手无法进行下一步操作，即找到一个策略使得自己获胜。

其实这道题思路很明了了。

我们考虑以下两种棋盘情况：

#### 1. 我们棋盘大小为奇数

 这时我们先进行棋盘的染色，即左上角为黑色，下一个为白色，再下一个为黑色……以此类推。然后我们可以进行证明。
 
 此时我们的最大匹配数为 $\frac{{n^2 - 1}}{2}$。
 
 然后可以发现最大匹配中并没有 S 点，即 S 点没有被匹配，故易得先手必败。
 
#### 2. 我们棋盘大小为偶数

染色方法同上。

进行分析可以得出，此时的最大匹配数为 $\frac{{n^2}}{2}$。

此时我们发现， S 点包含在最大匹配中，故先手必胜。
 



---

## 作者：Yanami_Anna (赞：2)

很明显的二分图博弈论。

众所周知，当二分图存在完美匹配的时候，后手必败。

那么我们就需要快速判断一张二分图有没有完美匹配了。

但是没有那么麻烦，考虑到本题的特殊性，如果我们能够构造出一组完美匹配那么就认为她是有解的。

抽象到网格图上就是放一大堆 $1\times2$ 的长方形问能不能塞满整个大地图。

然后你发现如果 $n$ 是偶数那么必定存在一组方案，因为你可以直接横着摆一行，再这样摆满整张图，所以如果 $n$ 是偶数则先手必胜。

否则一定没有，你连点数是偶数的都做不到。

然后就是在没有完美匹配的情况下，我们要判断起点是不是最大匹配必选点，也就是说问我们能不能构造出一组最大匹配使得不包含起点。

由于本题的特殊性，这个也是好做的。

去掉了起点之后我们大地图变成了 $(n-1)\times n$ 和 $1\times (n-1)$ 的矩形组起来的地图，这两个矩形明显都能够塞满，所以能构造出一组最大匹配不包含起点，即先手必败。

总结一下就是如果 $n$ 是偶数则先手必胜，否则先手必败。

---


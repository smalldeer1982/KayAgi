# 【深基16.例7】普通二叉树（简化版）

## 题目描述

您需要写一种数据结构，来维护一些数（都是绝对值 $10^9$ 以内的数）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 $q$ 不超过 $10^4$：

1. 定义数 $x$ 的排名为集合中小于 $x$ 的数的个数 $+1$。查询数 $x$ 的排名。**注意 $x$ 不一定在集合里**。
2. 查询排名为 $x(x\ge 1)$ 的数。**保证集合里至少有 $x$ 个数**。
3. 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。若不存在则输出 $-2147483647$。
4. 求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。若不存在则输出 $2147483647$。
5. 插入一个数 $x$，本题的数据保证插入前 $x$ 不在集合中。

保证执行 $1,3,4$ 操作时，集合中有至少一个元素。

## 样例 #1

### 输入

```
7
5 1
5 3
5 5
1 3
2 2
3 3
4 3```

### 输出

```
2
3
1
5
```

# 题解

## 作者：do_while_true (赞：395)

[$\text{更佳的阅读体验}$](https://www.cnblogs.com/do-while-true/p/13566274.html)

#### 2020-11-12 update：修了一操作的锅

[题目传送门](https://www.luogu.com.cn/problem/P5076)

Q: 学习二叉搜索树有什么用？

A: 我们平常所说的"平衡树"（伸展树Splay，替罪羊树等）实际上都属于"平衡二叉搜索树"，也就是既满足"平衡树"又满足"二叉搜索树"。二叉搜索树的效率比平衡二叉搜索树的效率低很多，但是在学习平衡二叉搜索树之前也要理解二叉搜索树的实现原理，此文就是来帮助理解的。

Q: 需要背过代码吗？

A: 不需要，相比背过二叉搜索树，不如多学一两个平衡树。

---

暴力BST最坏时间复杂度是 $\mathcal{O(n^2)}$。

BST就是二叉搜索树，这里讲的是最普通的BST。

------------

BST（Binary Search Tree），二叉搜索树，又叫二叉排序树

是一棵空树或具有以下几种性质的树:

1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值

1. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值

1. 左、右子树也分别为二叉排序树

1. 没有权值相等的结点。

看到第4条，我们会有一个疑问，在数据中遇到多个相等的数该怎么办呢，显然我们可以多加一个计数器，就是当前这个值出现了几遍。

那么我们的每一个节点都包含以下几个信息:

1. 当前节点的权值，也就是序列里的数

1. 左孩子的下标和右孩子的下标，如果没有则为0

1. 计数器，代表当前的值出现了几遍

1. 子树大小和自己的大小的和

至于为什么要有4.我们放到后面讲。

节点是这样的:

```cpp
struct node{
	int val,ls,rs,cnt,siz;
}tree[500010];
```

其中 $val$ 是权值，$ls$ / $rs$ 是左/右 孩子的下标，$cnt$ 是当前的权值出现了几次，$siz$ 是子树大小和自己的大小的和。

以下均以递归方式呈现。

------------

### 插入: 

$x$ 是当前节点的下标，$v$ 是要插入的值。要在树上插入一个 $v$ 的值，就要找到一个合适 $v$ 的位置，如果本身树的节点内有代表 $v$ 的值的节点，就把该节点的计数器加 $1$ ，否则一直向下寻找，直到找到叶子节点，这个时候就可以从这个叶子节点连出一个儿子，代表 $v$ 的节点。具体向下寻找该走左儿子还是右儿子是根据二叉搜索树的性质来的。

```cpp
void add(int x,int v)
{
	tree[x].siz++;
	//如果查到这个节点，说明这个节点的子树里面肯定是有v的，所以siz++
	if(tree[x].val==v){
		//如果恰好有重复的数，就把cnt++，退出即可，因为我们要满足第四条性质
		tree[x].cnt++;
		return ;
	}
	if(tree[x].val>v){//如果v<tree[x].val，说明v实在x的左子树里
		if(tree[x].ls!=0)
		  add(tree[x].ls,v);//如果x有左子树，就去x的左子树
		else{//如果不是，v就是x的左子树的权值
			cont++;//cont是目前BST一共有几个节点
			tree[cont].val=v;
			tree[cont].siz=tree[cont].cnt=1;
			tree[x].ls=cont;
		}
	}
	else{//右子树同理
		if(tree[x].rs!=0)
		  add(tree[x].rs,v);
		else{
			cont++;
			tree[cont].val=v;
			tree[cont].siz=tree[cont].cnt=1;
			tree[x].rs=cont;
		}
	}
}
```

------------

### 找前驱:

$x$ 是当前的节点的下标，$val$ 是要找前驱的值，$ans$ 是目前找到的比 $val$ 小的数的最大值。

找前驱的方法也是不断的在树上向下爬找具体节点，具体爬的方法可以参考代码注释部分。

```cpp
int queryfr(int x, int val, int ans) {
	if (tree[x].val>=val)
	{//如果当前值大于val，就说明查的数大了，所以要往左子树找
		if (tree[x].ls==0)//如果没有左子树就直接返回找到的ans
			return ans;
		else//如果不是的话，去查左子树
			return queryfr(tree[x].ls,val,ans);
	}
	else
	{//如果当前值小于val，就说明我们找比val小的了
		if (tree[x].rs==0)//如果没有右孩子，就返回tree[x].val，因为走到这一步时，我们后找到的一定比先找到的大(参考第二条性质)
			return (tree[x].val<val) ? tree[x].val : ans
		//如果有右孩子，，我们还要找这个节点的右子树，因为万一右子树有比当前节点还大并且小于要找的val的话，ans需要更新
		if (tree[x].cnt!=0)//如果当前节数的个数不为0，ans就可以更新为tree[x].val
			return queryfr(tree[x].rs,val,tree[x].val);
		else//反之ans不需要更新
			return queryfr(tree[x].rs,val,ans);
	}
}
```

------------

### 找后继

与找前驱同理，只不过反过来了，在这里我就不多赘述了。

```cpp
int queryne(int x, int val, int ans) {
	if (tree[x].val<=val)
	{
		if (tree[x].rs==0)
			return ans;
		else
			return queryne(tree[x].rs,val,ans);
	}
	else
	{
		if (tree[x].ls==0)
			return (tree[x].val>val)? tree[x].val : ans;
		if (tree[x].cnt!=0)
			return queryne(tree[x].ls,val,tree[x].val);
		else
			return queryne(tree[x].ls,val,ans);
	}
}
```

------------

### 按值找排名:

这里我们就要用到 $siz$ 了，排名就是比这个值要小的数的个数再 $+1$，所以我们按值找排名，就可以看做找比这个值小的数的个数，最后加上 $1$ 即可。

```cpp
int queryval(int x,int val)
{
	if(x==0) return 0;//没有排名 
	if(val==tree[x].val) return tree[tree[x].ls].siz;
	//如果当前节点值=val，则我们加上现在比val小的数的个数，也就是它左子树的大小 
	if(val<tree[x].val) return queryval(tree[x].ls,val);
	//如果当前节点值比val大了，我们就去它的左子树找val，因为左子树的节点值一定是小的 
	return queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt;
	//如果当前节点值比val小了，我们就去它的右子树找val，同时加上左子树的大小和这个节点的值出现次数 
	//因为这个节点的值小于val，这个节点的左子树的各个节点的值一定也小于val 
}
//注:这里最终返回的是排名-1，也就是比val小的数的个数，在输出的时候记得+1
```

------------

### 按排名找值:

因为性质1和性质2，我们发现排名为 $n$ 的数在BST上是第 $n$ 靠左的数。或者说排名为 $n$ 的数的节点在BST中，它的左子树的 $siz$ 与它的各个祖先的左子树的 $siz$ 相加恰好 $=n$ (这里相加是要减去重复部分)。

所以问题又转化成上一段 **或者说** 的后面的部分

$rk$ 是要找的排名

```cpp
int queryrk(int x,int rk)
{
	if(x==0) return INF; 
	if(tree[tree[x].ls].siz>=rk)//如果左子树大小>=rk了，就说明答案在左子树里 
		return queryrk(tree[x].ls,rk);//查左子树 
	if(tree[tree[x].ls].siz+tree[x].cnt>=rk)//如果左子树大小加上当前的数的多少恰好>=k，说明我们找到答案了 
		return tree[x].val;//直接返回权值 
	return queryrk(tree[x].rs,rk-tree[tree[x].ls].siz-tree[x].cnt);
	//否则就查右子树，同时减去当前节点的次数与左子树的大小 
}
```

------------

### 删除:

具体就是利用二叉搜索树的性质在树上向下爬找到具体节点，把计数器-1。与上文同理就不粘贴代码了

---

BST的弊端: 时间复杂度最坏为 $\mathcal{O(n^2)}$ 。

看完上文，你一定理解了二叉搜索树的具体实现原理和方法，但是如果构建出的一棵BST是个链的话，时间复杂度就会退化到 $\mathcal{O(n^2)}$ 级别，因为如果每次都查找链最低端的叶子节点的复杂度是 $\mathcal{O(n)}$ 的。而去保持这个树是个平衡树，就可以防止出现这个错误的复杂度。这个时候就有了平常所说的[平衡树](https://www.luogu.com.cn/problem/P3369)。

---

完整版代码，仅供参考。

### $\mathcal{Code}:$

```cpp
#include<iostream>
#include<cstdio>
#define re register
using namespace std;
const int INF=0x7fffffff;
int cont;
struct node{
    int val,siz,cnt,ls,rs;
}tree[1000010];
int n,opt,xx;
inline void add(int x,int v)
{
    tree[x].siz++;
    if(tree[x].val==v){
        tree[x].cnt++;
        return ;
    }
    if(tree[x].val>v){
        if(tree[x].ls!=0)
          add(tree[x].ls,v);
        else{
            cont++;
            tree[cont].val=v;
            tree[cont].siz=tree[cont].cnt=1;
            tree[x].ls=cont;
        }
    }
    else{
        if(tree[x].rs!=0)
          add(tree[x].rs,v);
        else{
            cont++;
            tree[cont].val=v;
            tree[cont].siz=tree[cont].cnt=1;
            tree[x].rs=cont;
        }
    }
}
int queryfr(int x, int val, int ans) {
    if (tree[x].val>=val)
    {
        if (tree[x].ls==0)
            return ans;
        else
            return queryfr(tree[x].ls,val,ans);
    }
    else
    {
        if (tree[x].rs==0)
            return tree[x].val;
        return queryfr(tree[x].rs,val,tree[x].val);
    }
}
int queryne(int x, int val, int ans) {
    if (tree[x].val<=val)
    {
        if (tree[x].rs==0)
            return ans;
        else
            return queryne(tree[x].rs,val,ans);
    }
    else
    {
        if (tree[x].ls==0)
            return tree[x].val;
        return queryne(tree[x].ls,val,tree[x].val);
    }
}
int queryrk(int x,int rk)
{
    if(x==0) return INF;
    if(tree[tree[x].ls].siz>=rk)
        return queryrk(tree[x].ls,rk);
    if(tree[tree[x].ls].siz+tree[x].cnt>=rk)
        return tree[x].val;
    return queryrk(tree[x].rs,rk-tree[tree[x].ls].siz-tree[x].cnt);
}
int queryval(int x,int val)
{
    if(x==0) return 0;
    if(val==tree[x].val) return tree[tree[x].ls].siz;
    if(val<tree[x].val) return queryval(tree[x].ls,val);
    return queryval(tree[x].rs,val)+tree[tree[x].ls].siz+tree[x].cnt;
}
inline int read()
{
    re int r=0;
    re char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9'){
        r=(r<<3)+(r<<1)+(ch^48);
        ch=getchar();
    }
    return r;
}
signed main()
{
    n=read();
    while(n--){
        opt=read();xx=read();
        if(opt==1) printf("%d\n",queryval(1,xx)+1);
        else if(opt==2) printf("%d\n",queryrk(1,xx));
        else if(opt==3) printf("%d\n",queryfr(1,xx,-INF));
        else if(opt==4) printf("%d\n",queryne(1,xx,INF));
        else{
            if(cont==0){
                cont++;
                tree[cont].cnt=tree[cont].siz=1;
                tree[cont].val=xx;
            }
            else add(1,xx);
        }
    }
    return 0;
}
```


---

相信你已经掌握了二叉搜索树的基本实现方法，也可以来尝试循环实现的BST：

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#define pb push_back
const int N = 10010;
const int INF = 0x7fffffff;
inline int read() {
	int r = 0; bool w = 0; char ch = getchar();
	while(ch < '0' || ch > '9') w = ch == '-' ? 1 : w, ch = getchar();
	while(ch >= '0' && ch <= '9') r = (r << 3) + (r << 1) + (ch ^ 48), ch = getchar();
	return w ? ~r + 1 : r;
}
#define ls tree[x].son[0]
#define rs tree[x].son[1]
struct Node {
	int val, siz, cnt, son[2];
}tree[N];
int n, root, tot;
inline void add(int v) {
	if(!tot) {
		root = ++tot;
		tree[tot].cnt = tree[tot].siz = 1;
		tree[tot].son[0] = tree[tot].son[1] = 0;
		tree[tot].val = v;
		return ;
	}
	int x = root, last = 0;
	do {
		++tree[x].siz;
		if(tree[x].val == v) {
			++tree[x].cnt;
			break;
		}
		last = x;
		x = tree[last].son[v > tree[last].val];
		if(!x) {
			tree[last].son[v > tree[last].val] = ++tot;
			tree[tot].son[0] = tree[tot].son[1] = 0;
			tree[tot].val = v;
			tree[tot].cnt = tree[tot].siz = 1;
			break;
		}
	} while(true);//Code by do_while_true qwq
}
int queryfr(int val) {
	int x = root, ans = -INF;
	do {
		if(x == 0) return ans;
		if(tree[x].val >= val) {
			if(ls == 0) return ans;
			x = ls;
		}
		else {
			if(rs == 0) return tree[x].val;
			ans = tree[x].val;
			x = rs;
		}
	} while(true);
}
int queryne(int v) {
	int x = root, ans = INF;
	do {
		if(x == 0) return ans;
		if(tree[x].val <= v) {
			if(rs == 0) return ans;
			x = rs;
		}
		else {
			if(ls == 0) return tree[x].val;
			ans = tree[x].val;
			x = ls;
		}
	} while(true);
}
int queryrk(int rk) {
	int x = root;
	do {
		if(x == 0) return INF;
		if(tree[ls].siz >= rk) x = ls;
		else if(tree[ls].siz + tree[x].cnt >= rk) return tree[x].val;
		else rk -= tree[ls].siz + tree[x].cnt, x = rs;
	} while(true);
}
int queryval(int v) {
	int x = root, ans = 0;
	do {
		if(x == 0) return ans;
		if(tree[x].val == v) return ans + tree[ls].siz;
		else if(tree[x].val > v) x = ls;
		else ans += tree[ls].siz + tree[x].cnt, x = rs;
	} while(true);
}
int main() {
	n = read();
	while(n--) {
		int opt = read(), x = read();
		if(opt == 1) printf("%d\n", queryval(x) + 1);
		if(opt == 2) printf("%d\n", queryrk(x));
		if(opt == 3) printf("%d\n", queryfr(x));
		if(opt == 4) printf("%d\n", queryne(x));
		if(opt == 5) add(x);
	}
	return 0;
}
```

---

## 作者：Diamiko (赞：178)

## 使用容器：std::multiset



------------

### mulitset是什么？

multiset是C++ STL里的一种容器。

头文件  `#include<set>`


------------

### multiset有什么性质？

* 里面的元素按顺序排列，默认升序。
* 不去重（这点和set是不同的）。

----------

### 常用方法

```cpp
multiset<int>q;
//定义一个multiset，尖括号里写类型
//如果是自定义类型，需要重载小于号 

q.insert(x);
//插入一个数 x 

q.clear();
//清空 

q.erase(x);
//删除容器中的所有值为 x 的数 

q.erase(it);
//删除容器中迭代器it指向的元素 

q.empty();
//返回bool值，如果容器为空返回true，否则返回false 

q.size()
//返回元素个数

q.begin();
//返回首个元素的迭代器 

q.end();
//返回最后一个元素的下一个位置的迭代器 

q.count(x);
//返回容器中 x 的个数 

q.find(x);
//返回容器中第一个x的位置（迭代器），如果没有就返回q.end() 

q.lower_bound(x);
//返回容器中第一个大于等于x的数的迭代器 

q.upper_bound(x);
//返回容器中第一个大于x的数的迭代器 

```
以上是常用的方法。

值得一提的是，lower_bound方法与upper_bound方法，都是内置二分查找，速度要比遍历暴力查找快很多。

--------------

### 分析题目

#### 1. 查询 x 数的排名

排名，说白了就是排序之后的x的下标。

我们只要用lower_bound方法，找到第一个x的位置。

然后从begin开始往后遍历容器，只要达到这个位置，就输出当前下标即可。

#### 2.查询排名为 x 的数

遍历容器，只要当前排名到达x，就输出当前值。

（因为multiset容器无法进行随机访问）

#### 3.求 x 的前驱（前驱定义为小于 x，且最大的数）

前驱，也就是x的前一个。

我们只要用lower_bound方法找到第一个x的位置，然后输出上一个就OK了。

#### 4.求 x 的后继（后继定义为大于 x，且最小的数）。

后继，也就是第一个大于x的数。

我们可以用upper_bound方法，直接找到这个值。

#### 5.插入一个数 x

直接用insert方法插入即可。

--------------

### 坑点

题目描述其实是不全的，这一点我也是看讨论版才知道的。

* 如果x没有前驱要输出`-0x7fffffff`

* 如果x没有后继要输出 `0x7fffffff`

我们可以提前把这两个值放到容器里，那么，没有前驱的数的前驱一定是`-0x7fffffff`；没有后继的数的后继一定是`0x7fffffff`。

---------------------

### 代码

（详见注释）

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<set>
using namespace std;
multiset<int>q;
int n,t,x,order;
int main()
{
    q.insert(-0x7fffffff);
    q.insert(0x7fffffff);
    //提前放入这两个数，避免错误
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d%d",&t,&x);
        if(t==1)
        {
            auto it=q.lower_bound(x);
            //auto是自动判断数据类型，只有C++14以上才支持
            //可以写作multiset<int>::iterator，因为lower_bound方法返回的是迭代器
            // it 取得 x 的位置
            
            order=0;
            //order为排名
            
            for(auto i=q.begin();i!=it;i++,order++);
            //这里的auto同理，也是迭代器
            //这里就处理出了x的排名——order
            
            printf("%d\n",order);
            //输出order即为答案
        }
        else if(t==2)
        {
            order=-1;
            //初值为-1是因为前面有一个-0x7fffffff，所以order要多跑一步

            for(int i:q)
                if(++order==x)
                //缩写，order先自增一，再判断是否与x相等
                //如果是(order++==x)，那就是先判断再自增，这里要尤其注意
                    printf("%d\n",i);
                //i就是容器里的值，输出i

            //注意这里的for(:)循环，是只有C++11以上才支持的
            //和auto一样，都是noip不能用的
            //这种循环，i就是容器里的值而不是下标
            //也可以使用迭代器循环，上面的循环等价于
            /*
                for(multiset<int>::iterator it=q.begin();it!=q.end();it++)
                {
                    order++;
                    if(order==x)
                        printf("%d\n",*it);
                }
            */
            //这种循环是noip可以使用的
        }
        else if(t==3)
        {
            auto it=q.lower_bound(x);
            //取得第一个大于等于x的值
            //也就是第一个x的位置
            //由于我们要取得前驱，所以it要自减一
            printf("%d\n",*--it);
            //这句是先自减，再输出，是缩写
            //等价于：
            /*
                it--;
                printf("%d\n",*it);
            */
            //因为是迭代器（指针），所以输出前面加 *
        }
        else if(t==4)
        {
            printf("%d\n",*q.upper_bound(x));
            //要取得后继，就是第一个大于x的值
            //用upper_bound方法取得第一个大于x的迭代器
            //输出即可
            //因为是迭代器（指针），所以输出前面加 *
        }
        else
        {
            q.insert(x);
            //直接添加即可
        }
    }
    return 0;
}
```



---

## 作者：vectorwyx (赞：78)

这题其实就是把Splay的删除功能去了。

但是由于蒟蒻不会Splay，而且这题数据明显弱一些，就只好考虑一下其他做法。


------------
其他做法怎么做呢？

很显然，如果我们能一直维护一个**有序**序列$a$，那么：

1. 查询$x$的排名，那就二分查找$x$，单次复杂度为$O(logn)$

2. 查询排名为$x$的数，直接输出$a_{x}$，单次复杂度为$O(1)$

3. 求$x$的前趋，也是二分查找第一个大于等于$x$的数的位置$p$,显然前$p-1$个数均小于$x$,那$a_{p-1}$就是$x$的前缀，输出即可,单次复杂度为$O(logn)$

4. 求$x$的后继，二分查找第一个大于$x$的数并输出。这里要注意一点就是**如果$x$没有后继，需要输出2147483647**。

------------
那问题就变成了维护一个有序序列$a$，其实也很简单：

在插入$x$时，首先**二分查找第一个大于等于$x$的数的位置**$p$，

再把区间$[p+1,n]$的数全部**后移一位**，将x插入到$a_{p}$上。

这样就维护了序列的有效性，单次复杂度为$O(n+logn)$。

至于二分查找，STL自带的**lower_bound**和**upper_bound**就能胜任

（不会lower_bound和upper_bound？[戳这](https://blog.csdn.net/qq_40632760/article/details/86317548)）

------------
OK，接下来是代码环节：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
//upper_bound和lower_bound包含在algorithm库中
#define fo(i,x,y) for(register int i=x;i<=y;++i)
//宏定义简化for循环
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;

inline int read(){//快读
	int x=0,fh=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*fh;
}

const int maxn=1e5+1;
int a[maxn],n;//a是维护的序列，n为序列长度

int main(){
	int q=read();
	while(q--){
		int opt=read(),x=read();
		if(opt==1){//查询x的排名
			int k=lower_bound(a+1,a+1+n,x)-a;
            //二分查找x，注意返回值是指针因此要减去a
			printf("%d\n",k);
		}
		if(opt==2){//查询排名为x的数
			printf("%d\n",a[x]);//直接输出
		}
		if(opt==3){//查询x的前趋
			int k=lower_bound(a+1,a+1+n,x)-a;
			//二分查找第一个大于等于x的数
			printf("%d\n",a[k-1]);
            //输出前一个
		}
		if(opt==4){//查询x的后继
			int k=upper_bound(a+1,a+1+n,x)-a;
            //二分查找
			if(k!=n+1) printf("%d\n",a[k]);
    		//找得到，输出
			else printf("2147483647\n");
            //找不到，注意要输出2147483647
		}
		if(opt==5){//插入x
			int k=lower_bound(a+1,a+1+n,x)-a;
            //二分查找
			if(k==n+1) a[++n]=x;
            //找不到，那说明x是最大的数，直接插在后面
			else{//区间[k+1,n]整体后移一位
				go(i,n,k) a[i+1]=a[i];
				a[k]=x;//插入x
				++n;//注意要把n的值也修改
			}
		}
	}
	return 0;
}

```
你AC了没？AC了就给个赞呗。

---

## 作者：wwldx (赞：24)

正解肯定是BST，但我不会BST，这可咋办嘛
读了一遍题，发现其实主要操作就是找前面一个比他小的，或者后面一个比他大的，也就是**维护一个单调队列**，那stl中有个好东西呀，**multiset**，自动排序，还不会像set一样去重，然后用lower_bound和upper_bound去二分查找相应的值就可以了，但这题有个坑点，要是没有后继的话，需要输出**2147483647**，（题目也没说呀，导致我第一遍就40分），所以在开始前，先手动添加一个2147483647作为最大值，这样即使本来没有后继了，就自动指向2147483647了
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef multiset<int>::iterator sett;//每次都写太长了，typedef一下 
sett c,d;//定义2个迭代器 
int main()
{
	int n,a,x;
	multiset<int> s1;
	cin>>n;
	s1.insert(2147483647);//为防止没有后继，手动添加一个最大值 
	while(n--)
	{
		cin>>a>>x;
		switch(a){
			case 1:{//查询 x数的排名 
				c=s1.lower_bound(x);//二分查找第一个x出现的位置 
				int num=1;//计数器 
				for(d=s1.begin();d!=c;++d)//从第一个开始跑，直到到了第一个x 
				++num;
				cout<<num<<"\n";//输出num 
				break;
			}
			case 2:{//查询排名为x的数
				int num=1;
				for(d=s1.begin();num<x;++num)//不会pbds,只能手动一个一个加了 
				++d;
				cout<<*d<<"\n";
				break;
			}
			case 3:{//求x的前驱 
				c=s1.lower_bound(x);//二分查找第一个x出现的位置 
				--c;//那他前面一个必然是前驱 
				cout<<*c<<"\n";
				break;
			}
			case 4:{//求x的后继
				c=s1.upper_bound(x);//二分查找第一个大于x的位置 
				cout<<*c<<"\n";
				break;
			}
			case 5:{//插入一个数x
				s1.insert(x);//插入元素 
				break;
			}
		}
	}
	return 0;
}
```


---

## 作者：Veranda (赞：20)

# P5076题解
### 这题标准答案是用二叉树，但是呢，考虑到二叉树比较难，我~~蒟蒻~~就发一篇简单易懂~~暴力~~的做法！！
本题解要用到数组和两个函数$lower\_bound()$和$upper\_bound()$不会的戳[这里](https://blog.csdn.net/qq_40160605/article/details/80150252)

具体含义在代码里啦
#### 先看一下五种操作
1. 查询 x 的排名（排名定义为比当前数小的数的个数+1。若有多个相同的数，因输出最小的排名）。

   这个就是标准的$lower\_bound()$函数的作用啦

	```cpp
		if(num==1){
			cin>>number;
			cout<<lower_bound(a+1,a+size+1,number)-a<<endl;
		}
	```
1. 查询排名为 x 的数。

这个很简单，直接输出排名就好

```cpp
		else if(num==2){
			cin>>number;
			cout<<a[number]<<endl;
		}
```
3.求 x 的前驱（前驱定义为小于 x，且最大的数）。

这个有点绕，大家自己多想想，就是普通的$lower\_bound()$再减掉1就可以了

```cpp
		else if(num==3){
			cin>>number;
			int p=lower_bound(a+1,a+size+1,number)-a;
			if(p==1) printf("-2147483647\n");
			else cout<<a[p-1]<<endl;
		}
```
4.求 x 的后继（后继定义为大于 x，且最小的数）。

标准的$upper\_bound()$啦

```cpp
		else if(num==4){
			cin>>number;
			int *p=upper_bound(a+1,a+size+1,number);
			if(p==a+size+1) printf("2147483647\n");
			else cout<<*p<<endl;
		}
```
5.插入一个数 x。

这里需要对新插入的数进行排序，以保证后面$lower\_bound()$和$upper\_bound()$的正常运行

这里复杂度较高，但这道题还是跑的过去的

```
		else if(num==5){
			cin>>number;
			a[++size]=number;
			sort(a+1,a+size+1);
		}
```

综上所述，本题时间复杂度在O(nlogn)左右（n为询问次数），大概可以跑过

### 注意，有坑！！
注意这两句
```
			if(p==1) printf("-2147483647\n");
			if(p==a+size+1) printf("2147483647\n");
```

就是找不到就要输出这两个奇奇怪怪的数~~坑了我好几个小时~~

### 附上AC代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[10010];
//upper_bound(begin,end,number)函数是求begin-end中（排好序）第一个大于 number的数
//lower_bound(begin,end,number)函数是求begin-end中（排好序）第一个大于等于 number的数
//以上两个函数传回一个指针，指针-a就是一个相对位置（所求number的下标） 
int main(){
	int q,num,number,size=0;
	cin>>q;
	while(q--){
		cin>>num;
		if(num==1){
			cin>>number;
			cout<<lower_bound(a+1,a+size+1,number)-a<<endl;
		}
		else if(num==2){
			cin>>number;
			cout<<a[number]<<endl;
		}
		else if(num==3){
			cin>>number;
			int p=lower_bound(a+1,a+size+1,number)-a;
			if(p==1) printf("-2147483647\n");
			else cout<<a[p-1]<<endl;
		}
		else if(num==4){
			cin>>number;
			int *p=upper_bound(a+1,a+size+1,number);
			if(p==a+size+1) printf("2147483647\n");
			else cout<<*p<<endl;
		}
		else if(num==5){
			cin>>number;
			a[++size]=number;
			sort(a+1,a+size+1);
		}
	}
}
```
欢迎dalao批评指正

Update 更改文风

求过！！！

---

## 作者：马角的逆袭 (赞：16)

### luogu5076


#### BST

* 查询排名为$K$的值
  1. 类似于权值线段树, 如果root的左子树节点个数$+1$大于$K$

  2. 则$K$大值一定在左子树    反之在右边子树

  3. ```c++
     int kth(Node* now, int K) { //第k小的值
     	if(!now) //题目要求一个意义不明的返回值
           return 2147483647; 
     	int tmp = now->lsum + 1;
     	if(tmp == K) 
     		return now->val;
     	if(tmp < K) //查右边记得减去lsum+1
     		return kth(now->rig, (K-tmp));
     	else 
     		return kth(now->lef, K);
     }
     ```

* 查询$x$的排名

  1. $x$的排名为: $x$的左子树个数$+1$,如果在root向右查询了要记得加上root的左子树的节点个数

  2. ```c++
     int xth(Node* now, int x, int K) { //查询x的排名
     	if(!now) return K;
     	if(now->val == x) 
           return K+now->lsum+1;
     	if(now->val < x) 
     		return xth(now->rig, x, K+(now->lsum+1));
     	else
     		return xth(now->lef, x, K);
     }
     ```

     ​

* 查询一个数$x$的前驱

  1. 如果$root$比$x$小,那么$root$可能是$x$的前驱, 且$root$的右子树也可能有$x$的前驱

  2. ```c++
     int get_pre(int key) {
     	int ret = -2147483647;
     	Node* p = root;
     	while(p) {
     		if(key > (p->val)) {
     			ret = p->val;
     			p = p->rig;
     		} else {
     			p = p->lef;
     		}
     	}
     	return ret;
     }
     ```

* 查询一个数$x$的后继

  1. 如果$root$比$x$大, 那么$root$可能是$x$的后继, 且$root$的左子树也可能有$x$的后继

  2. ```c++
     int get_suf(int key) {
     	int ret = 2147483647;
     	Node* p = root;
     	while(p) {
     		if(key < p->val) {
     			ret = p->val;
     			p = p->lef;
     		} else {
     			p = p->rig;
     		}
     	}
     	return ret;
     }
     ```

**完整代码**
```c++
#define debug
#ifdef debug
#include <time.h>
#include "/home/majiao/mb.h"
#endif
//luoguP5076

#include <iostream>
#include <algorithm>
#include <vector>
#include <string.h>
#include <map>
#include <set>
#include <stack>
#include <queue>
#define MAXN ((int)1e5+7)
#define ll long long int
#define QAQ (0)

using namespace std;

struct Node {
	Node* lef;
	Node* rig;
	int val, lsum, rsum; //lsum,rsum定义左右子树的节点个数
	Node(int _val) : lef(0), rig(0), val(_val), lsum(0), rsum(0) { }
} *root;

void insert(Node*& now, int key) { //插入记得增加子树个数
	if(!now) {
		now = new Node(key);
		return ;
	}
	if(now->val <= key) 
		insert(now->rig, key), now->rsum ++;
	else 
		insert(now->lef, key), now->lsum ++;
}

bool find_key(Node* now, int key) {
	if(!now) return false;
	if(now->val == key) return true;
	if(now->val < key) 
		return find_key(now->rig, key);
	else
	   	return find_key(now->lef, key);
}

int kth(Node* now, int K) { //第k小的值
	if(!now) return 2147483647;
	int tmp = now->lsum + 1;
	if(tmp == K) 
		return now->val;
	if(tmp < K) 
		return kth(now->rig, (K-tmp));
	else 
		return kth(now->lef, K);
}

int xth(Node* now, int x, int K) { //查询x的排名
	if(!now) return K;
	if(now->val == x) return K+now->lsum+1;
	if(now->val < x) 
		return xth(now->rig, x, K+(now->lsum+1));
	else
		return xth(now->lef, x, K);
}

int get_pre(int key) {
	int ret = -2147483647;
	Node* p = root;
	while(p) {
		if(key > (p->val)) {
			ret = p->val;
			p = p->rig;
		} else {
			p = p->lef;
		}
	}
	return ret;
}

int get_suf(int key) {
	int ret = 2147483647;
	Node* p = root;
	while(p) {
		if(key < p->val) {
			ret = p->val;
			p = p->lef;
		} else {
			p = p->rig;
		}
	}
	return ret;
}

vector<int> vec;
void dfs(Node* now) {
	if(!now) return ;
	dfs(now->lef);
	vec.push_back(now->val);
	dfs(now->rig);
}

int main() {
#ifdef debug
	freopen("test", "r", stdin);
	freopen("out_main", "w", stdout);
	clock_t stime = clock();
#endif
	int n, x, op;
	scanf("%d ", &n);
	while(n--) {
		scanf("%d %d ", &op, &x);
		if(op == 5) insert(root, x);
      //这里的排名莫名其妙的要加1
		if(op == 1) printf("%d\n", xth(root, x, 0)+1);
		if(op == 2) printf("%d\n", kth(root, x));
		if(op == 3) printf("%d\n", get_pre(x));
		if(op == 4) printf("%d\n", get_suf(x));
	}
/**
	while(n--) {
		scanf("%d ", &x);
		insert(root, x);
	}
//	dfs(root);

	//for(auto it : vec)
	//	printf("%d %d\n", it, xth(root, it, 0));

//	for(int i=1; i<=9; i++)
//		printf("%d\n", kth(root, i));
//	for(auto it : vec)
//		printf("%d %d\n", it, get_suf(it));

*/





#ifdef debug
	clock_t etime = clock();
	printf("rum time: %lf 秒\n",(double) (etime-stime)/CLOCKS_PER_SEC);
#endif 
	return 0;
}


```



---

## 作者：YuJieSong (赞：14)

考场上最快的解决方式

还是用lower_bound和upper_bound

本身复杂度为O(logn)，很快

最重要的是代码还好写

~~就是vector的insert慢了一丢丢~~

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    int i,j,n,x,y;
    cin>>n;
    vector<int> v;
    for(i=0;i<n;i++){
        cin>>x>>y;
        if(x == 5){
            if(v.empty()) v.push_back(y);
            else{
                auto it = upper_bound(v.begin(),v.end(),y);
                v.insert(it, y);
            }
        }
        else if(x == 1){
            auto it = lower_bound(v.begin(),v.end(),y);
            cout<<it-v.begin()+1<<endl;
        }
        else if(x == 2){
            cout<<v[y-1]<<endl;
        }
        else if(x == 3){
            auto it = lower_bound(v.begin(),v.end(),y);
            cout<<*(it-1)<<endl;
        }
        else{
            auto it = upper_bound(v.begin(),v.end(),y);
            if(it != v.end()) cout<<*it<<endl;
            else cout<<"2147483647"<<endl;//本题坑点，需要这个奇怪的特判
        }
    }
    return 0;
}
```


---

## 作者：Edmundino (赞：9)

# 题意

这题是树堆的弱化版

就是比标准树堆少了一个删除功能

# 分析

#### 什么是树堆

树堆等于二叉树排序树+堆

1，是一棵二叉树

2，对于每一个结点

它的左孩子小于它，右孩子大于它

3，有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树


#### 关于树的左旋与右旋

![](https://cdn.luogu.com.cn/upload/image_hosting/zlgevfte.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这是平衡树的知识点

旋转可以维护树堆的性质，操作的时间复杂度趋于$O(logn)$

#### 树堆的基本操作

首先我们要知道树堆支持哪些操作


1，插入$x$

2，删除$x$(此题用不到）

3，查$x$的排名

4，查排名为$x$的数

5，查$x$的前驱

6，查$x$的后继

我们还得知道一些数组来储存

$siz_i$：以$i$为根节点的子树的节点总数

$v_i$：$i$节点的权值

$tot_i$:为$i$的点有多少个

$son[i][2]$,$son[i][0]$是指$i$的左儿子

$son[i][1]$是指$i$的右儿子

$rd_i$：$i$节点的随机值。

每次要插入新节点$i$的时候，都会为$i$节点分配一个随机值 $rd_i$

并让全部节点按照这个随机值排成一个堆。

（有点难理解，多读几遍）

# 代码

统计以$p$的为根节点的子树个数

```cpp
void pushup(int x)
{
	siz[x]=siz[son[x][0]]+siz[son[x][1]]+tot[x];
	return;
}
```

旋转。当$d==0$时 左旋；当$d==1$时，右旋

```cpp
void xun(int &p,int d)
{
	int k=son[p][d^1];
	son[p][d^1]=son[k][d];
	son[k][d]=p;
	pushup(p);
	pushup(k);
	p=k;
	return;
}
```
#### 插入一个数x；

当$x$未出现过，就是当$p==0$时

就随机给它一个值；

当$x$出现过了，$v_p==x$时

就只在$tot_p$++,$siz_p$++即可；

否则，当$x<v_p$时，进左子树，$d=0$;否则进右子树,$d=1$；

当它插入左子树时，$p$的$rd$应该小于左子树的$rd$

此时右旋

当它插入右子树时，$p$的$rd$应该小于右子树的$rd$

此时左旋

```cpp
void cha(int &p,int x)
{
	if(p==0)
	{
		p=++sum;
		siz[p]=tot[p]=1;
		v[p]=x;
		rd[p]=rand();
		return;
	}
	if(v[p]==x)
	{
		siz[p]++;
		tot[p]++;
		return ;
	 } 
	int d=(x>v[p]);
	cha(son[p][d],x);
	if(rd[p]<rd[son[p][d]])
       xun(p,1-d);
	pushup(p);	
}
```
删除我就不说了

毕竟这题没用到

#### 查x的排名

当$x$未出现，就返回$0$

当$x==v_p$时，就返回$p$的左子树个数$+1$

当$x>v_p$时，就返回$p$的左子树个数+$p$的节点数+$x$在$p$的右子树的排名

当$x<v_p$时，就返回x在p的左子树的排名

```cpp
int pai(int p,int x)
{
	if(!p)return 0;
	if(v[p]==x) return siz[son[p][0]]+1;
	if(v[p]<x) return siz[son[p][0]]+tot[p]+pai(son[p][1],x);
	if(v[p]>x) return pai(son[p][0],x);
}
```
#### 查排名为x的数

空节点未出现，就返回$0$

当左子树的节点大于$x$时，去左子树

当此节点的个数$>=x-$左节点的个数时，就返回$v[p]$

当左子树的节点数$+$此节点的个数$<x$时，去右子树

```cpp
int ming(int p,int x)
{
	if(!p)return 0;
	if(x<=siz[son[p][0]]) return ming(son[p][0],x);
	else if(x>siz[son[p][0]]+tot[p])
	  return ming(son[p][1],x-siz[son[p][0]]-tot[p]);
	else return v[p];
}
```
#### 求x的前驱

  
当$x$没有前驱时，要输出$-2147483647$


如果$v_p>=x$时，去左子树

否则，就返回$max$($v_p,$右子树返回来的数）

```cpp
int qian(int p,int x)
{
	if(!p)return -2147483647;
	if(x<=v[p]) return qian(son[p][0],x);
	else return max(v[p],qian(son[p][1],x));
  }  

```


#### 求x的后继

当$x$没有后继时，要输出$2147483647$

如果$v_p<=x$,去右子树

否则，就返回$min$($v_p,$左子树返回来的数）

```cpp
int hou(int p,int x)
{
	if(!p)return 2147483647;
	if(x>=v[p]) return hou(son[p][1],x);
	else return min(v[p],hou(son[p][0],x));
}

```
#### 完整代码

```cpp
#include <bits/stdc++.h>

using  namespace std;

#define INF INT_MAX

const int N=1e5+10;

int n,a,x,tot[N],siz[N],rd[N],v[N],son[N][2],d,r,sum;

void pushup(int x)
{
	siz[x]=siz[son[x][0]]+siz[son[x][1]]+tot[x];
	return;
}

void xun(int &p,int d)
{
	int k=son[p][d^1];
	son[p][d^1]=son[k][d];
	son[k][d]=p;
	pushup(p);
	pushup(k);
	p=k;
	return;
}

void cha(int &p,int x)
{
	if(p==0)
	{
		p=++sum;
		siz[p]=tot[p]=1;
		v[p]=x;
		rd[p]=rand();
		return;
	}
	if(v[p]==x)
	{
		siz[p]++;
		tot[p]++;
		return ;
	 } 
	int d=(x>v[p]);
	cha(son[p][d],x);
	if(rd[p]<rd[son[p][d]])
       xun(p,d^1);
	pushup(p);	
}

void shan(int &p,int x)
{
	if(!p) return;
	if(x<v[p]) shan(son[p][0],x);
	else if(x>v[p]) shan(son[p][1],x);
	else
	{
		if(son[p][0]==0&&son[p][1]==0)
		{
			tot[p]--;
			siz[p]--;
			if(tot[p]==0) p=0;
		}
		else
		{
			if(son[p][1]==0)
			{
				xun(p,1);
				shan(son[p][1],x);
			}
			else
			{
				if(son[p][0]==0)
				{
					xun(p,0);
					shan(son[p][0],x);
				}
				else
				{
				   int d=(rd[son[p][0]]>rd[son[p][1]]);
				   xun(p,d);
				   shan(son[p][d],x);
				}
			}
		}
	}
	pushup(p);
}

int pai(int p,int x)
{
	if(!p)return 0;
	if(v[p]==x) return siz[son[p][0]]+1;
	if(v[p]<x) return siz[son[p][0]]+tot[p]+pai(son[p][1],x);
	if(v[p]>x) return pai(son[p][0],x);
}

int ming(int p,int x)
{
	if(!p)return 0;
	if(x<=siz[son[p][0]]) return ming(son[p][0],x);
	else if(x>siz[son[p][0]]+tot[p])
	  return ming(son[p][1],x-siz[son[p][0]]-tot[p]);
	else return v[p];
}

int qian(int p,int x)
{
	if(!p)return -2147483647;
	if(x<=v[p]) return qian(son[p][0],x);
	else return max(v[p],qian(son[p][1],x));
  }  

int hou(int p,int x)
{
	if(!p)return 2147483647;
	if(x>=v[p]) return hou(son[p][1],x);
	else return min(v[p],hou(son[p][0],x));
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>x;
		if(a==5)
		{
			cha(r,x);
		}
		if(a==1)
		{
			cout<<pai(r,x)+1<<endl;
		}
		if(a==2)
		{
			cout<<ming(r,x)<<endl;
		}
		if(a==3)
		{
			cout<<qian(r,x)<<endl;
		}
		if(a==4)
		{
			cout<<hou(r,x)<<endl;
		}
	}
	return 0;
}
```



---

## 作者：do_while_false (赞：9)

[P5076 【【深基16.例7】普通二叉树（简化版）】](https://www.luogu.com.cn/problem/P5076)

其实使用简单的BST就可以通过此题，但是很多神犇已经讲过BST了，就讲一讲vector的具体实现吧。

[vector](https://www.luogu.com.cn/record/31306175) 21ms，苟进最优解的第一页了。

注：本篇题解是以本题为主的，如果想看更好的学习vector，请参考[这里](https://zh.cppreference.com/w/cpp/container/vector)进行学习。

vector在[谷歌翻译](https://translate.google.co.jp/?hl=zh-CN&tab=rT1#view=home&op=translate&sl=auto&tl=zh-CN&text=vector)上翻译为向量，这里呢我们把它当做一个序列处理。(我们要维护这个序列的**单调性**，即**使这个序列有序**)

---

## 我们来看这道题要求的几个操作:

- 查询 x 数的排名

- 查询排名为 x 的数。

- 求 x 的前驱

- 求 x 的后继

- 插入一个数 x

## 那我们怎么实现这些操作呢？

- 二分查找

- 输出第x个数

- 二分查找前驱

- 二分查找后继

- 暴力右移

## 我们来看看具体的实现:

### 查询 x 的排名

STL里有两个超级好用的函数:

lower_bound 和 upper_bound

它们有什么用呢？

分别可以找出一个有序序列里第一个大于或等于 x 的数的指针和第一个大于 x 的数的指针。

具体的实现可以看看这篇[文章](http://blog.sina.com.cn/s/blog_ebd950590102vl88.html)。

```cpp
printf("%d\n",lower_bound(a.begin(),a.end(),x)-a.begin()+1);
//因为返回值是指针所以就减去a.begin()，也可以写成a。
```

这样就能找出排名了，复杂度$O(log n)$.

### 查询排名为 x 的数。

因为数组是有序的，所以我们只用输出第 x 个数即可。

```cpp
printf("%d\n",a[x-1]);//输出第x个数
```
就酱，复杂度$O(1)$

### 求前驱

同样利用lower_bound找出大于等于 x 的第一个数，然后输出前一个数，自然就是 x 的前驱了。

```cpp
vector<int>::iterator p=lower_bound(a.begin(),a.end(),x);//找到大于等于x的第一个数
if(p==a.begin()) printf("-2147483647\n");//如果没有小于x的数，就输出-2148473647
else printf("%d\n",*(p-1));//输出x的前驱
```

复杂度$O(log n)$

### 求后继

和求前驱操作相似，具体就在代码里解释了。

```cpp
vector<int>::iterator p=upper_bound(a.begin(),a.end(),x);//找到大于x的第一个数
if(p==a.end()) printf("2147483647\n");//如果没有大于x的数，就输出2148473637
else printf("%d\n",*p);//输出x的后继
```

复杂度$O(log n)$

### 插入

先用lower_bound找出大于等于 x 的数的指针，为了方便说明，我们不妨将这个数设为 $a[k]$。

然后我们只用把 $a[k]$到$a[n-1]$全部右移一位，然后将$a[k]$赋值为$x$。

~~如果你是懒人，以上全部为假，只用看下面的内容即可~~

如果你仔细读过我在最开始的地方推荐的那个*这里*，你就会发现有一个STL中的函数，**insert**。

这个**insert**能干嘛呢？它对应的操作就是暴力右移，也就是懒人不用看的那两句话。

```cpp

a.insert(upper_bound(a.begin(),a.end(),x),x);
//插入

```
复杂度$O(n)$

## Code

```cpp
#include<bits/stdc++.h>//万能头 
#pragma GCC target("sse,sse2,sse3,sse4.1,sse4.2,popcnt,abm,mmx,avx,ssse3,f16c,fma,avx2,xop,fma4")
#pragma GCC optimize(3,"-fpeephole2,-ftree-vrp,-ftree-pre,-fipa-sra,Ofast,inline,-fgcse,-fgcse-lm,-ffast-math,-fsched-spec,unroll-loops,-falign-jumps,-falign-loops,-falign-labels,-fdevirtualize,-fcaller-saves,-fcrossjumping,-fthread-jumps,-funroll-loops,-fwhole-program,-freorder-blocks,-fschedule-insns,inline-functions,-ftree-tail-merge,-fschedule-insns2,-fstrict-aliasing,-fstrict-overflow,-falign-functions,-fcse-skip-blocks,-fcse-follow-jumps,-fsched-interblock,-fpartial-inlining,no-stack-protector,-freorder-functions,-findirect-inlining,-fhoist-adjacent-loads,-frerun-cse-after-loop,inline-small-functions,-finline-small-functions,-ftree-switch-conversion,-foptimize-sibling-calls,-fexpensive-optimizations,-funsafe-loop-optimizations,inline-functions-called-once,-fdelete-null-pointer-checks")
#pra\
gma GCC diagnostic ignored "-Wnarrowing"
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
inline int read() {
    int ret=0,f=0;char ch=getc();
    while(!isdigit(ch)){if(ch=='-') f=1;ch=getc();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getc();}
    return f?-ret:ret;
}//以上皆为奇奇怪怪的优化和fread快读 
vector <int> a;//开一个vector 
int main(void) {//标准main函数写法 
    int n=read();//接下来就不用注译了 ，自己可以回去看 
    for(int i=0;i<n;++i) {
        int c=read(),x=read();
        if(c==1) printf("%d\n",lower_bound(a.begin(),a.end(),x)-a.begin()+1);
        else if(c==2) printf("%d\n",a[x-1]);
        else if(c==3) {
			vector<int>::iterator p=lower_bound(a.begin(),a.end(),x);
        	if(p==a.begin()) printf("-2147483647\n");
        	else printf("%d\n",*(p-1));
		}
        else if(c==4) {
            vector<int>::iterator p=upper_bound(a.begin(),a.end(),x);
            if(p==a.end() printf("2147483647\n");
            else printf("%d\n",*p);
        }
        else if(c==5) a.insert(upper_bound(a.begin(),a.end(),x),x);
    }
    return 0;
}
```

如果程序CE了不要怪我。

第一次写题解，管理员求过。

感谢各位的学习。

---

## 作者：山蛙or山兔 (赞：7)

此题用二叉查找树就行，无需优化。

需要注意的细节问题是，x不一定在树内，如果找不到需要输出-2147483647或者2147483647，这个是题目描述问题，有待解决。

此题求x的前驱或者后驱时，可以直接利用排名求，算是一个简化代码的小技巧。

完整代码如下：
```cpp
#include <iostream>
#include <cstring>
#define maxn 100000
using namespace std;

int n,son[maxn][2],v[maxn],tot[maxn],s[maxn],f[maxn];
int root,sz;

void insert(int y)
{
	int p=root;
	while (true)
	{
		if (v[p]==-1) 
		{
			v[p]=y;
			son[p][0]=++sz;
			f[sz]=p;
			son[p][1]=++sz;
			f[sz]=p;
			tot[p]=s[p]=1;
			break;
		}
		if (v[p]==y)
		{
			tot[p]++;
			s[p]++;
			break;
		}
		if (v[p]>y)
		{
			s[p]++;
			p=son[p][0];
		}
		else 
		{
			s[p]++;
			p=son[p][1];
		}
	}
}

int solve1(int y)
{
	int p=root;
	int ans=s[son[p][0]]+1;
	while (v[p]!=-1)
	{
		if (v[p]==y) return ans;
		if (v[p]<y)
		{
			if (v[son[p][1]]==-1) return ans+tot[p];
			p=son[p][1];
			ans+=s[son[p][0]]+tot[f[p]];
		}
		else
		{
			if (v[son[p][0]]==-1) return ans;
			p=son[p][0];
			ans-=s[son[p][1]]+tot[p];
		}
	}
	return -1;
}

int solve2(int y)
{
	int p=root;
	int ans=s[son[p][0]]+1;
	while (v[p]!=-1)
	{
		if (ans<=y && y<=ans+tot[p]-1)
		{
			return v[p];
		}
		if (ans+tot[p]-1<y)
		{
			p=son[p][1];
			ans+=s[son[p][0]]+tot[f[p]];
		}
		else
		{
			p=son[p][0];
			ans-=s[son[p][1]]+tot[p];
		}	
	}
	return 2147483647;
}

int find(int y)
{
	int p=root;
	while (v[p]!=-1)
	{
		if (v[p]==y) return p;
		if (v[p]>y) p=son[p][0];
		else p=son[p][1];
	}
	return -1;
}

int solve3(int y)
{
	int p=solve1(y);
	if (p==1) return -2147483647;
	return solve2(p-1);
}

int solve4(int y,int i)
{
	int p=solve1(y),p2=find(y);
	if (p2==-1) return solve2(p);
	return solve2(p+tot[p2]);
}

int main()
{
	cin >> n;
	memset(v,-1,sizeof(v));
	memset(f,-1,sizeof(f));
	memset(s,0,sizeof(s));
	memset(son,0,sizeof(son));
	memset(tot,0,sizeof(tot));
	sz=root=0;
	for (int i=0;i<n;i++)
	{
		int x,y;
		cin >> x >> y;
		if (x==1) cout << solve1(y) << endl;
		if (x==2) cout << solve2(y) << endl;
		if (x==3) cout << solve3(y) << endl;
		if (x==4) cout << solve4(y,i+1) << endl;
		if (x==5) insert(y);
	}
}
```


---


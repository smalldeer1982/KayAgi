# 封锁

## 题目背景

Steve 带领队伍准备去 M 星消灭黑暗势力，即将降落时被 M 星上空的无人机拦截了。

## 题目描述

为了突破封锁，成功降落， Steve 使用了电磁干扰仪，使无人机开始自相残杀。

然而，情况很快就变得混乱，无法了解当前的情况。

幸好 Steve 的部队已经记录了开始混战前的状况，并设法获得了无人机执行操作的顺序。

每架无人机有 $5$ 项属性 $atk,def,mat,mdf,fix$ ，当前生命值 $hp$ ，当前坐标 $(x,y,z)$ ，当前水平朝向 $f$( 范围 0-7) 和竖直朝向 $h$( 范围 0-4) 。

每一时刻，所有存活的无人机会**先**向正前方移动一格。

随后，存活的无人机会**按编号从小到大**依次执行下列操作之一：

无操作 (N)

上下转向 (U/D) ：改变 $h$ 的值，上为增加，下为减少，如果超过了范围就是无效操作，忽略。

左右转向 (L/R) ：改变 $f$ 的值，左为增加，右为减少，循环（分别对应从上面看的逆时针，顺时针）。

例如：当 $h=4$ 时操作 U 无效，当 $f=0$ 时操作 R 会使
 $f$ 变为 $7$ 。

修复 (F) ：使 $hp$ 增加 $fix$ 点。

子弹 (A) ：使位于这架无人机正前方**最近**的飞机受到伤害，伤害的值为当前飞机的 $atk$ 值与目标的 $def$ 值之差（差为负则不会造成伤害），**如果多架飞机处于同一位置，那么只有编号最小的飞机会受到伤害**。

激光 (M) ：使位于这架无人机正前方的**所有**飞机受到伤害，伤害的值为当前飞机的 $mat$ 值与目标的 $mdf$ 值之差（差为负则不会造成伤害）。

注意：与开火飞机重叠的飞机不会受到伤害

如果受到伤害后， $hp\leq 0$ ，那么这架飞机就会坠毁。

对于 $f$ 和 $h$ ，它的“正前方”是这样定义的：

首先，根据 $f$ 确定 $x,y$ 方向，如下图。

![](https://cdn.luogu.com.cn/upload/pic/64952.png)

随后，根据 $h$ 进一步确定方向。

对于 $h=0$ 或 $h=4$ ，正前方是正下或正上（ $x,y$ 不变， $z$ 变化）。

对于 $h=1$ 或 $h=3$ ，在上面方向的基础上再向下/上移动一格。

对于 $h=2$ ，正前方为水平方向（ $x,y$ 如上所述， $z$ 不变）。

（有人反馈看不懂方向，这里直接给出 $f,h$ 和正前方
 $(x,y,z)$ 的对应表）

![](https://cdn.luogu.com.cn/upload/pic/71703.png)

现在， Steve 告诉你了所有飞机初始的状态和之后执行的操作。

你需要告诉他，经过 $t$ 个时刻的混战之后，每架飞机的位置和生命值。

## 说明/提示

两架飞机移动并改变朝向后互相面对，随后它们分别向对面疯狂开火，最终 1 号飞机率先击落 2 号飞机，因为 2 号飞机已经坠毁，所以 1 号飞机不会被击落。

而它们身后分别跟着两架飞机， 2 号飞机使用激光，所以 3 号飞机也会受到伤害， 1 号飞机使用子弹，所以 4 号飞机不会受到伤害，直到 2 号飞机坠毁后， 1 号飞机发出最后一颗子弹，对 4 号飞机造成了一点伤害。同时两架飞机前三次操作分别进行了三次修复， $hp$ 增加了 $3$ 。

测试时，每个 Subtask 包括 3 个测试点，全部通过才能得到该 Subtask 的分数

------------

样例 2 解释：<https://www.luogu.com.cn/discuss/582252>

---

数据范围：

$1\leq n,t\leq 100$

输入的所有数字大小在合理范围内，且绝对值均不大于 $100$ 。

其中 $atk,def,mat,mdf,fix$ 为非负整数。

$hp$ 为正整数。

$x,y,z$ 为整数。

$h$ 为 $0,1,2,3,4$ 中的一个。

$f$ 为 $0,1,2,3,4,5,6,7$ 中的一个。

字符串仅包含 $NFLRUDAM$ $8$ 种字符。

另外，对于前 3 个 subtask ，保证任何时刻飞机的 z 坐标为
 $0$ 。

Subtask | 分值 | 出现的操作
:-: | :-: | :-: 
1| 12| N
2| 14| NF
3| 15| NFLR
4| 17| NFLRUD
5| 19| NFLRUDM
6| 23| NFLRUDMA

## 样例 #1

### 输入

```
4 7
-1 -1 0 2 1 1 0 0 0 5 0 RAAAAAA
51 0 1 1 4 0 0 1 0 5 0 UMMMMMM
-2 0 0 2 0 0 0 0 0 5 1 FFFNNNN
53 0 0 2 4 0 0 0 0 5 1 FFFNNNN
```

### 输出

```
6 0 0 1
45 0 0 0
5 0 0 4
46 0 0 7
```

## 样例 #2

### 输入

```
7 1
0 0 0 0 0 2 0 0 0 1 0 A
1 0 0 0 0 4 0 0 0 3 0 A
1 0 0 0 0 1 1 1 1 4 0 N
1 0 -1 0 0 0 0 0 0 2 0 N
0 1 0 0 0 0 0 3 0 3 0 M
0 1 -1 0 0 0 0 0 1 3 0 N
0 1 -1 0 0 0 0 0 2 3 0 N```

### 输出

```
0 0 -1 1
1 0 -1 3
1 0 -1 4
1 0 -2 2
0 1 -1 3
0 1 -2 1
0 1 -2 2```

# 题解

## 作者：rasing_up (赞：10)

//稍作改动 再次提交 望管理大大通过

**此文核心收到一位大佬（不知名）启发，因不知为何人，在此感谢**

## 刚看到这道题真的是感觉非常~~热血沸腾~~无助！
###### 太弱了看不懂...
#### 后来看了下后面题发现都不会做，就又来看这道题了

其实这道题是一道非常好的模拟????

幸好良心（~~变态~~）出题人给了一张表格
![](https://cdn.luogu.com.cn/upload/pic/71703.png)
因为表里数据比较多，边做边处理太麻烦所以可以先**预处理**（存数组里）
```cpp
int s[5][8][3]=
{
    {
        {0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1}
    },
    {
        {1,0,-1},{1,1,-1},{0,1,-1},{-1,1,-1},{-1,0,-1},{-1,-1,-1},{0,-1,-1},{1,-1,-1}
    },
    {
        {1,0,0},{1,1,0},{0,1,0},{-1,1,0},{-1,0,0},{-1,-1,0},{0,-1,0},{1,-1,0}
    },
    {
        {1,0,1},{1,1,1},{0,1,1},{-1,1,1},{-1,0,1},{-1,-1,1},{0,-1,1},{1,-1,1}
    },
    {
        {0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1}
    }
};
```

**其中第一维是h,第二维是f,第三维就是x,y,z(方位)**
这样便于处理**正方向**
```cpp
x+=s[h][f][0];
y+=s[h][f][1];
z+=s[h][f][2];
```
f:当前水平朝向(范围0-7)
h:竖直朝向(范围0-4)
(如果f,h对应的是什么都不知道的话，你可以去P1000大佬区了)

题中代码中用到 goto
像我一样的蒟蒻看[这里](https://blog.csdn.net/hankai1024/article/details/8011306)
感谢[博主](https://blog.csdn.net/hankai1024)

如有不明白可自行百度

话不多说 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;                  
int a[205][15];//大佬们用的都是结构体，用结构体确实会方便不少
int vis[105][105][105];
char ch[205][205];
int s[5][8][3]=
{
    {
        {0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1}
    },
    {
        {1,0,-1},{1,1,-1},{0,1,-1},{-1,1,-1},{-1,0,-1},{-1,-1,-1},{0,-1,-1},{1,-1,-1}
    },
    {
        {1,0,0},{1,1,0},{0,1,0},{-1,1,0},{-1,0,0},{-1,-1,0},{0,-1,0},{1,-1,0}
    },
    {
        {1,0,1},{1,1,1},{0,1,1},{-1,1,1},{-1,0,1},{-1,-1,1},{0,-1,1},{1,-1,1}
    },
    {
        {0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1}
    }
};
int main(){
	int n,t;
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=11;j++)
		  cin>>a[i][j];
	    cin>>ch[i];
	    a[i][12]=1;
//a[i][1~11]分别对应题中的各个参量
//a[i][12] 表示这架飞机是否死亡 1为活着 0为死亡
	}
	for(int k=0;k<t;k++){
	  for(int i=1;i<=n;i++)
	  {
	  	a[i][1]+=s[a[i][4]][a[i][5]][0];
		a[i][2]+=s[a[i][4]][a[i][5]][1];
		a[i][3]+=s[a[i][4]][a[i][5]][2];
	  }
	  for(int i=1;i<=n;i++)//4 h  5 f 
	  {
		
		if(!a[i][12]||ch[i][k]=='N') continue;//如果已经坠毁或这次无操作就continue
		else if(ch[i][k]=='F'){//回血
		a[i][10]+=a[i][11];
		}
		else if(ch[i][k]=='L'){//若为上限则重载（循环  0，1，2，3，4，5，6，7，0，1  ……）
			if(a[i][5]==7) 
			  a[i][5]=0;
			else
			  a[i][5]++;
		}
		else if(ch[i][k]=='R'){//同上
			if(a[i][5]==0)
			  a[i][5]=7;
			else
			  a[i][5]--;
		}
		else if(ch[i][k]=='U'){//U/D 与L/R 不同 ，超过范围就为无效操作
			if(a[i][4]<4)
			  a[i][4]++;
		}
		else if(ch[i][k]=='D'){//同上
			if(a[i][4]>0)
			  a[i][4]--;
		}
		else if(ch[i][k]=='M'){
                int sum=0;//判断向前移动了几次。
                int xx=a[i][1],yy=a[i][2],zz=a[i][3];//记录当前飞机方位
                there2: xx+=s[a[i][4]][a[i][5]][0];//以下模拟移动
                yy+=s[a[i][4]][a[i][5]][1];
                zz+=s[a[i][4]][a[i][5]][2];
                sum++;//移动次数加1
                for(register int k=1;k<=n;++k){
                    if(!a[k][12]) continue;//如果飞机死亡
                    if(a[k][1]==xx&&a[k][2]==yy&&a[k][3]==zz){
                        int sh=a[i][8]-a[k][9];
                        if(sh>0){//如果差值为正数才有伤害
                            a[k][10]-=sh;
                            if(a[k][10]<=0){
                                a[k][12]=0;
                                a[k][11]=0;
                            }
                        }
                    }
                    if(sum>=100) break;//继续
                }
                if(sum<100) goto there2;//回到there2处（个人理解为变异的while循环）
            }
            else if(ch[i][k]=='A'){//子弹
                int sum=0;
                bool f=0;//判断有没有打到一架飞机
                int xx=a[i][1],yy=a[i][2],zz=a[i][3];
                there: xx+=s[a[i][4]][a[i][5]][0];//同上
                yy+=s[a[i][4]][a[i][5]][1];
                zz+=s[a[i][4]][a[i][5]][2];
                sum++;//移动次数加一
                for(int k=1;k<=n;++k){
                    if(!a[k][12]) continue;//如果当前这架飞机坠毁了，就continue
                    if(a[k][1]==xx&&a[k][2]==yy&&a[k][3]==zz){//如果当前到达了一架没有坠毁的飞机
                        f=1;//打到了，qwq;
                        int sh=a[i][6]-a[k][7];//计算伤害
                        if(sh>0){//扣除血量
                            a[k][10]-=sh;
                            if(a[k][10]<0){//因为坠毁的飞机最后输出时血量为0直接改成0
                                a[k][10]=0;
                                a[k][12]=0;//坠毁
                            }
                        }
                        break;//跳出循坏
                    }
                    if(sum>=100) f=1;//如果进行了100次以上的操作就直接跳出，卡数据
                }
                if(!f) goto there;//如果还没有打到就再移动
            }
	   }
			
	}

	for(int i=1;i<=n;i++){
		cout<<a[i][1]<<" "<<a[i][2]<<" "<<a[i][3]<<" "<<a[i][10]<<endl; 
	}
	return 0;
}
```
**码风粗陋，多多包涵**


---

## 作者：Hope2075 (赞：8)

注：数据是随机的

这道题就是一个模拟，不过需要一点技巧

首先要把方向处理好

一个做法是，按照题意模拟

先确定水平方向，再根据竖直方向作相应修改
```cpp
	void gdir(int &x,int &y,int &z){
		switch(f){
			case 7:case 0:case 1:
				x=1;break;
			case 3:case 4:case 5:
				x=-1;break;
			case 2:case 6:
				x=0;break;
		}
		switch(f){
			case 1:case 2:case 3:
				y=1;break;
			case 5:case 6:case 7:
				y=-1;break;
			case 0:case 4:
				y=0;break;
		}
		switch(h){
			case 0:x=y=0;z=-1;break;
			case 1:z=-1;break;
			case 2:z=0;break;
			case 3:z=1;break;
			case 4:x=y=0;z=1;break;
		}
	}
```
另一个做法是，把所有方向列出来，就是打表（题目中给出了）

```cpp
const int dir[8][5][3]={
	{{0,0,-1},{ 1, 0,-1},{ 1, 0, 0},{ 1, 0, 1},{0,0,1},},
	{{0,0,-1},{ 1, 1,-1},{ 1, 1, 0},{ 1, 1, 1},{0,0,1},},
	{{0,0,-1},{ 0, 1,-1},{ 0, 1, 0},{ 0, 1, 1},{0,0,1},},
	{{0,0,-1},{-1, 1,-1},{-1, 1, 0},{-1, 1, 1},{0,0,1},},
	{{0,0,-1},{-1, 0,-1},{-1, 0, 0},{-1, 0, 1},{0,0,1},},
	{{0,0,-1},{-1,-1,-1},{-1,-1, 0},{-1,-1, 1},{0,0,1},},
	{{0,0,-1},{ 0,-1,-1},{ 0,-1, 0},{ 0,-1, 1},{0,0,1},},
	{{0,0,-1},{ 1,-1,-1},{ 1,-1, 0},{ 1,-1, 1},{0,0,1},},
};
```
接下来，除了M和A操作，剩下的就比较好办了，按照题目要求模拟即可，只要修改对应的值就行

然后考虑M和A操作

最简单的想法是，枚举每架飞机，以及前进的距离，但是这样有超时风险

考虑另一个方法：枚举飞机，判断是否在正前方，如果是，那么计算距离

判断时，一个办法是：判断坐标差值和对应轴的方向，然后判断绝对值是否相等，如果相等，这个绝对值就是距离

这样细节比较多，容易WA
```cpp
int gdis(plane a,plane b){
	//a to b
	//return -1 if can't reach
	int fx=0,fy=0,fz=0;
	int dx,dy,dz;
	int def=0;
	a.f.gdir(fx,fy,fz);
	dx=b.x-a.x;
	dy=b.y-a.y;
	dz=b.z-a.z;
	switch(fx){//第一步：判断符号是否正确，并取出任意一个非零值的绝对值
		case -1:
			if(dx>=0)return -1;
			def=-dx;
			break;
		case 0:
			if(dx!=0)return -1;
			break;
		case 1:
			if(dx<=0)return -1;
			def=dx;
			break;
	}
	switch(fy){
		case -1:
			if(dy>=0)return -1;
			def=-dy;
			break;
		case 0:
			if(dy!=0)return -1;
			break;
		case 1:
			if(dy<=0)return -1;
			def=dy;
			break;
	}
	switch(fz){
		case -1:
			if(dz>=0)return -1;
			def=-dz;
			break;
		case 0:
			if(dz!=0)return -1;
			break;
		case 1:
			if(dz<=0)return -1;
			def=dz;
			break;
	}
	switch(fx){//第二步：判断绝对值是否相等
		case -1:
			if(dx>=0)return -1;
			if(def!=-dx)return -1;
			break;
		case 0:
			if(dx!=0)return -1;
			break;
		case 1:
			if(dx<=0)return -1;
			if(def!=dx)return -1;
			break;
	}
	switch(fy){
		case -1:
			if(dy>=0)return -1;
			if(def!=-dy)return -1;
			break;
		case 0:
			if(dy!=0)return -1;
			break;
		case 1:
			if(dy<=0)return -1;
			if(def!=dy)return -1;
			break;
	}
	switch(fz){
		case -1:
			if(dz>=0)return -1;
			if(def!=-dz)return -1;
			break;
		case 0:
			if(dz!=0)return -1;
			break;
		case 1:
			if(dz<=0)return -1;
			if(def!=dz)return -1;
			break;
	}
	return def;
}
```
另一个方法是：用向量的计算，如果两个非零的三维向量的叉积为零向量，则两个向量共线，方向相同或相反

然后用点积可以判断是相同还是相反，或者其中一个是零向量

而在每次求最近飞机时，一个向量是确定的，如果两个向量共线，那么点积越大，另一个向量的长度就越大，也就是距离越大（当然也可以把距离算出来）

这样就不太容易出错了
```cpp
int gdis(plane a,plane b){
	//a to b
	//return -1 if can't reach
	int dx,dy,dz,fx,fy,fz;
	dx=b.x-a.x;
	dy=b.y-a.y;
	dz=b.z-a.z;
	if(dx==0&&dy==0&&dz==0)return -1;//先特判掉重合的情况
	a.f.gdir(fx,fy,fz);
	int mx,my,mz;
	mx=dy*fz-dz*fy;
	my=dz*fx-dx*fz;
	mz=dx*fy-dy*fx;//叉积
	if(mx!=0||my!=0||mz!=0)return -1;
	int dis=dx*fx+dy*fy+dz*fz;//点积
	if(dis<0)return -1;//已经特判了重合的情况
	return dis/(abs(fx)+abs(fy)+abs(fz));//实际这里必要性不大
}
```


这样，就能处理M和A操作

代码：

写法1：
```cpp
#include<iostream>
using namespace std;
const int N=128,T=128;
char opt[N][T];
struct facing{
	int h,f;
	void chk(){f%=8;f+=8;f%=8;h>4?h=4:0;h<0?h=0:0;}
	void up(){h++;chk();}
	void down(){h--;chk();}
	void left(){f++;chk();}
	void right(){f--;chk();}
	void gdir(int &x,int &y,int &z){
		switch(f){
			case 7:case 0:case 1:
				x=1;break;
			case 3:case 4:case 5:
				x=-1;break;
			case 2:case 6:
				x=0;break;
		}
		switch(f){
			case 1:case 2:case 3:
				y=1;break;
			case 5:case 6:case 7:
				y=-1;break;
			case 0:case 4:
				y=0;break;
		}
		switch(h){
			case 0:x=y=0;z=-1;break;
			case 1:z=-1;break;
			case 2:z=0;break;
			case 3:z=1;break;
			case 4:x=y=0;z=1;break;
		}
	}
};
struct plane{
	facing f;
	int x,y,z;
	int atk,def,mat,mdf,fix,hp;
	bool alive(){return hp>0;}
	void move(){
		int dx=0,dy=0,dz=0;
		f.gdir(dx,dy,dz);
		x+=dx;y+=dy;z+=dz;
	}
	void left(){f.left();}
	void right(){f.right();}
	void up(){f.up();}
	void down(){f.down();}
	void fixing(){
		hp+=fix;
	}
	void attack();
	void magic();
};
int gdis(plane a,plane b){
	//a to b
	//return -1 if can't reach
	int fx=0,fy=0,fz=0;
	int dx,dy,dz;
	int def=0;
	a.f.gdir(fx,fy,fz);
	dx=b.x-a.x;
	dy=b.y-a.y;
	dz=b.z-a.z;
	switch(fx){
		case -1:
			if(dx>=0)return -1;
			def=-dx;
			break;
		case 0:
			if(dx!=0)return -1;
			break;
		case 1:
			if(dx<=0)return -1;
			def=dx;
			break;
	}
	switch(fy){
		case -1:
			if(dy>=0)return -1;
			def=-dy;
			break;
		case 0:
			if(dy!=0)return -1;
			break;
		case 1:
			if(dy<=0)return -1;
			def=dy;
			break;
	}
	switch(fz){
		case -1:
			if(dz>=0)return -1;
			def=-dz;
			break;
		case 0:
			if(dz!=0)return -1;
			break;
		case 1:
			if(dz<=0)return -1;
			def=dz;
			break;
	}
	switch(fx){
		case -1:
			if(dx>=0)return -1;
			if(def!=-dx)return -1;
			break;
		case 0:
			if(dx!=0)return -1;
			break;
		case 1:
			if(dx<=0)return -1;
			if(def!=dx)return -1;
			break;
	}
	switch(fy){
		case -1:
			if(dy>=0)return -1;
			if(def!=-dy)return -1;
			break;
		case 0:
			if(dy!=0)return -1;
			break;
		case 1:
			if(dy<=0)return -1;
			if(def!=dy)return -1;
			break;
	}
	switch(fz){
		case -1:
			if(dz>=0)return -1;
			if(def!=-dz)return -1;
			break;
		case 0:
			if(dz!=0)return -1;
			break;
		case 1:
			if(dz<=0)return -1;
			if(def!=dz)return -1;
			break;
	}
	return def;
}
plane list[N];int n,t;
void plane::attack(){
	int minid=n+1;
	int mindis=0x7fffffff;
	int d;
	for(int i=1;i<=n;i++){
		if(!list[i].alive())continue;
		d=gdis(*this,list[i]);
		if(d==-1)continue;
		if(d<mindis){mindis=d;minid=i;}
	}
	if(minid==n+1){
		return;
	}
	int dh=max(0,this->atk-list[minid].def);
	list[minid].hp-=dh;
}
void plane::magic(){
	int d;
	for(int i=1;i<=n;i++){
		if(!list[i].alive())continue;
		d=gdis(*this,list[i]);
		if(d==-1)continue;
		int dh=max(0,this->mat-list[i].mdf);
		list[i].hp-=dh;
	}
}
bool alive[N];
int main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>list[i].x;
		cin>>list[i].y;
		cin>>list[i].z;
		cin>>list[i].f.h;
		cin>>list[i].f.f;
		
		
		cin>>list[i].atk;
		cin>>list[i].def;
		cin>>list[i].mat;
		cin>>list[i].mdf;
		cin>>list[i].hp;
		cin>>list[i].fix;
		cin>>(opt[i]+1);
	}
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			if(list[j].alive()){
				list[j].move();
			}
		}
		for(int j=1;j<=n;j++){
			if(!list[j].alive())continue;
			switch(opt[j][i]){
				case 'U':list[j].up();break;
				case 'D':list[j].down();break;
				case 'L':list[j].left();break;
				case 'R':list[j].right();break;
				case 'F':list[j].fixing();break;
				case 'A':list[j].attack();break;
				case 'M':list[j].magic();break;
				case 'N':break;
			}
		}
	}
	for(int i=1;i<=n;i++){
		cout<<list[i].x<<" ";
		cout<<list[i].y<<" ";
		cout<<list[i].z<<" ";
		if(list[i].alive())cout<<list[i].hp<<" ";
		else cout<<0<<" ";
		cout<<endl;
	}
}
```

写法2：
```cpp
#include<iostream>
using namespace std;
const int N=128,T=128;
char opt[N][T];
const int dir[8][5][3]={
	{{0,0,-1},{ 1, 0,-1},{ 1, 0, 0},{ 1, 0, 1},{0,0,1},},
	{{0,0,-1},{ 1, 1,-1},{ 1, 1, 0},{ 1, 1, 1},{0,0,1},},
	{{0,0,-1},{ 0, 1,-1},{ 0, 1, 0},{ 0, 1, 1},{0,0,1},},
	{{0,0,-1},{-1, 1,-1},{-1, 1, 0},{-1, 1, 1},{0,0,1},},
	{{0,0,-1},{-1, 0,-1},{-1, 0, 0},{-1, 0, 1},{0,0,1},},
	{{0,0,-1},{-1,-1,-1},{-1,-1, 0},{-1,-1, 1},{0,0,1},},
	{{0,0,-1},{ 0,-1,-1},{ 0,-1, 0},{ 0,-1, 1},{0,0,1},},
	{{0,0,-1},{ 1,-1,-1},{ 1,-1, 0},{ 1,-1, 1},{0,0,1},},
};
struct facing{
	int h,f;
	void chk(){f%=8;f+=8;f%=8;h>4?h=4:0;h<0?h=0:0;}
	void up(){h++;chk();}
	void down(){h--;chk();}
	void left(){f++;chk();}
	void right(){f--;chk();}
	void gdir(int &x,int &y,int &z){
		x=dir[f][h][0];
		y=dir[f][h][1];
		z=dir[f][h][2];
	}
};
struct plane{
	facing f;
	int x,y,z;
	int atk,def,mat,mdf,fix,hp;
	bool alive(){return hp>0;}
	void move(){
		int dx=0,dy=0,dz=0;
		f.gdir(dx,dy,dz);
		x+=dx;y+=dy;z+=dz;
	}
	void left(){f.left();}
	void right(){f.right();}
	void up(){f.up();}
	void down(){f.down();}
	void fixing(){hp+=fix;}
	void attack();
	void magic();
};
#define abs(x) ((x)>=0?(x):(-x))
int gdis(plane a,plane b){
	//a to b
	//return -1 if can't reach
	int dx,dy,dz,fx,fy,fz;
	dx=b.x-a.x;
	dy=b.y-a.y;
	dz=b.z-a.z;
	if(dx==0&&dy==0&&dz==0)return -1;
	a.f.gdir(fx,fy,fz);
	int mx,my,mz;
	mx=dy*fz-dz*fy;
	my=dz*fx-dx*fz;
	mz=dx*fy-dy*fx;
	if(mx!=0||my!=0||mz!=0)return -1;
	int dis=dx*fx+dy*fy+dz*fz;
	if(dis<0)return -1;
	return dis/(abs(fx)+abs(fy)+abs(fz));
}
plane list[N];int n,t;
void plane::attack(){
	int minid=n+1;
	int mindis=0x7fffffff;
	int d;
	for(int i=1;i<=n;i++){
		if(!list[i].alive())continue;
		d=gdis(*this,list[i]);
		if(d==-1)continue;
		if(d<mindis){mindis=d;minid=i;}
	}
	if(minid==n+1)return;
	int dh=max(0,this->atk-list[minid].def);
	list[minid].hp-=dh;
}
void plane::magic(){
	int d;
	for(int i=1;i<=n;i++){
		if(!list[i].alive())continue;
		d=gdis(*this,list[i]);
		if(d==-1)continue;
		int dh=max(0,this->mat-list[i].mdf);
		list[i].hp-=dh;
	}
}
bool alive[N];
int main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>list[i].x;
		cin>>list[i].y;
		cin>>list[i].z;
		cin>>list[i].f.h;
		cin>>list[i].f.f;
		cin>>list[i].atk;
		cin>>list[i].def;
		cin>>list[i].mat;
		cin>>list[i].mdf;
		cin>>list[i].hp;
		cin>>list[i].fix;
		cin>>(opt[i]+1);
	}
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			if(list[j].alive()){
				list[j].move();
			}
		}
		for(int j=1;j<=n;j++){
			if(!list[j].alive())continue;
			switch(opt[j][i]){
				case 'U':list[j].up();break;
				case 'D':list[j].down();break;
				case 'L':list[j].left();break;
				case 'R':list[j].right();break;
				case 'F':list[j].fixing();break;
				case 'A':list[j].attack();break;
				case 'M':list[j].magic();break;
				case 'N':break;
			}
		}
	}
	for(int i=1;i<=n;i++){
		cout<<list[i].x<<" ";
		cout<<list[i].y<<" ";
		cout<<list[i].z<<" ";
		if(list[i].alive())cout<<list[i].hp<<" ";
		else cout<<0<<" ";
		cout<<endl;
	}
}
```

---

## 作者：stone_juice石汁 (赞：7)

# 一道大模拟题

先吐槽一下吧：

这是一个[比赛](https://www.luogu.org/contest/19322)的$T1$。

比赛前，出题人说：“这次比赛难度 普及- 到 省选 难度吧，$T1$是最简单的。” 我自信满满的点开第一道题，瞬间就蒙了。

**你告诉我这题 普及-？？？**

## 言归正传

听说有人打这道题$500+$行的代码 awa，我这里给出一个$80$行的代码题解吧。毕竟代码短，可读性较高，~~而且我对我的码风很自信~~。题解已经尽力写的很详细了，绝对的逐步求解，希望能帮到大家。

**再怎么说，也是一道$T1$的题。一道大模拟，完全可做，思维性不高，就是细节很多，需要逐步把控。**

所以我们一步一步来~，做这种题不能急。

- ## 1、存储

**这道题共有$7$种操作，每驾无人机共包含$12$种信息（各个数值和操作）**

于是，这里开结构体一定是最稳健的。不管后面有没有什么排序一类的操作，打包一堆数据总比一堆零散的数据容错率要高一些。

```cpp
struct feiji
{
	int x, y, z, h, f, atk, deg, mat, mdf, hp, fix, ti;//ti代表飞机的号数。
	string s;//代表操作
}f[205];
```

另外，我在比赛上想过开二维数组来模拟飞机的位置状况，**但是坐标是有负值的。而且在我强行把坐标加上一个较大值，不让坐标为负时，事实证明还是会炸，**（~~其实是我太蒟了~~）。所以我们不选择开数组模拟位置。

- ## 2、移动

每驾存活的无人机，每回合都会移动一轮。而移动方向则是他们面向的方向。

**这里需要注意：所有飞机都移动完之后，各个飞机才会执行各个指令（如转向，攻击）** 

既然我们刚刚把方向的表给打出来了，移动就变得很简单了。

```cpp
for(int j = 1; j <= n; j ++)//枚举每驾飞机
{
	if(f[j].hp > 0)//存活的飞机才能移动
  	{
		f[j].x += dx[f[j].f][f[j].h]; //向自己的方向移动
  		f[j].y += dy[f[j].f][f[j].h];
		f[j].z += dz[f[j].f][f[j].h];
  	}
}
```
**由于我们存储移动方向的单位 正好是前方一格，所以直接加在原坐标上即可。**

有个表是不是很方便？

- ## 3、转向（U/D/L/R操作）

**转向是一个大坑，甚至出题人自己都弄错了。**

最开始这题是没有$f/h$表的，很多人反馈说转向看不懂是什么意思，~~我也看不懂~~。出题人就弄了一个表。

~~然后出题人还把表打错了，后来才改回来~~

**既然有了表，就很简单了。我们把表打上去就可以了。** 也用不着写函数计算什么之类的，这样代码复杂，写错了$debug$也不方便

```cpp
int dx[8][5] = {{0, 1, 1, 1, 0},{0, 1, 1, 1, 0},{0, 0, 0, 0, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0},{0, 0, 0, 0, 0},{0, 1, 1, 1, 0}};
int dy[8][5] = {{0, 0, 0, 0, 0},{0, 1, 1, 1, 0},{0, 1, 1, 1, 0},{0, 1, 1, 1, 0},{0, 0, 0, 0, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0}};
int dz[8][5] = {{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1}};
```

**其中$dx[f][h],dy[f][h],dz[f][h]$分别表示，飞机面向方向 前面的一个格子 的$x,y,z$坐标。**（听起来很绕，多读几遍就好了）

于是，只要有了无人机的$f,h$值，我们就可以知道它面向的方向。

**表打好了，接下来还有修改操作。即修改无人机的$f,h$值。**

**在这里，$h$值是有上下界的。** 譬如$h=4$时，$U$指令无效，$h=0$时，$D$指令无效。

**而$f$值则不同，它的数据构成了一个环。**$f=0$时执行$L$，会使$f=1$，但是会若执行$R$，则会变为$f=7$。当然$f=7$时，执行$L$也会使$f=0$。**所以说，这里的$0,1,2,...,7$构成了一个环，我们实际是在这个环上做着$L,R$操作**

对于这两个值的处理，特判就可以了。

```cpp
//这里，我用char型字符c储存的指令信息，后面也一样。
if(c == 'U') if(f[j].h < 4) f[j].h ++;
if(c == 'D') if(f[j].h > 0) f[j].h --;
if(c == 'L')
{
	f[j].f ++;
	if(f[j].f > 7) f[j].f = 0;
}
if(c == 'R')
{
	f[j].f --;
	if(f[j].f < 0) f[j].f = 7;
}//这组代码没什么好说的，看就可以看懂
```
- ## 4、修复（F操作）

这个是最简单的操作了，对自己的飞机$hp$值加上$fix$值就可以了

题目没说什么生命条上限之类的东西，不用特判。

```cpp
if(c == 'F') f[j].hp += f[j].fix;
```

- ## 5、子弹，激光（A，M操作）

**接下来才是重头戏！** 两个攻击操作是全题最难的点了。

### 方法Ⅰ、

这种方法也是我用的方法。

**我们现在来想象一下：**

无人机发出了子弹/激光。

**无人机 面向方向的前面一格就会出现一颗 子弹/激光束**。（必须是前面一格，因为打不到与自己重叠的飞机）

子弹保持无人机面向的方向飞去 / 激光束保持无人机面向的方向扩散。

我们现在使用慢放的高超技术，**我们可以看到每一时刻，子弹 / 激光束每次以原来的方向移动一格.....**

直到碰到了飞机，子弹消失 / 激光束穿了过去，继续向前飞去....

于是乎，在想象中，我们的算法就完成了：**记录无人机位置的前面一格，使用 $for$循环一直往下找（每次向无人机面向的方向移动一格），直到遇到了无人机，子弹消失（break掉），激光继续行驶。**

怎么判断攻击是否击中了其他飞机呢？？由于我太蒟了，只能用一种笨拙的方法：

**我们在每次子弹/激光束移动完成后，就枚举一遍所有存活的飞机，看是否有飞机的坐标正好与 子弹/激光束 的坐标相同。相同的话就说明打到飞机了，造成伤害即可。**

可以看到，这种方法十分的笨拙，但好在本题数据不大，最高也就开到了$100$。所以是题目是可以$AC$的。

代码：

```cpp
if(c == 'A')
{
	bool flag = false;
	for(int k = 1; k <= 100; k ++)//循环，模拟子弹/激光束移动
	{
		for(int v = 1; v <= n; v ++)//枚举每驾飞机，看是否被攻击。
			if(f[j].x + dx[f[j].f][f[j].h] * k == f[v].x && f[j].y + dy[f[j].f][f[j].h] * k == f[v].y && f[j].z + dz[f[j].f][f[j].h] * k == f[v].z && f[v].hp != 0) //子弹遇上飞机，且那架飞机存活，就减血
			{
				if(f[j].atk > f[v].deg)f[v].hp -= (f[j].atk - f[v].deg);
				flag = true;//由于子弹会消失，所以要及时break;
				break;
			}
		if(flag) break;
	}	
}
if(c == 'M')
{
	for(int k = 1; k <= 100; k ++)
		for(int v = 1; v <= n; v ++)
			if(f[j].x + dx[f[j].f][f[j].h] * k == f[v].x && f[j].y + dy[f[j].f][f[j].h] * k == f[v].y && f[j].z + dz[f[j].f][f[j].h] * k == f[v].z) //激光遇上飞机，且那架飞机存活
		if(f[j].mat > f[v].mdf)f[v].hp -= (f[j].mat - f[v].mdf);		
}
```
提一句：我的判断里写的是：

```cpp
f[j].x/y/z + dx/y/z[f[j].f][f[j].h] * k == f[v].x/y/z
```
**其实这也是很好理解的，把累加换成了乘法而已。因为加上的数是相同的。**

这就和 $1+1+1+1+1$ 与 $1*5$ 相同 是一个道理。

顺带吐槽一句：这道题 $k$ 最小开到 $8$ 居然都能过去，也就是说我的子弹和激光射程为 $8$都能$AC$，这数据是有多 ~~水~~ 好。

### 方法Ⅱ、

方法Ⅰ时间复杂度不稳，很悬？怎么办？

这里给出方法Ⅱ，这需要一颗数学的大脑。

**我们可以求出无人机面向方向的直线方程式**（就是所谓的 $y = kx + b$ 或 $Ax+By+C = 0$）

**拿这个方程式去代入所有飞机的坐标，如果在这条直线上，那么就会被攻击到。**

这里倒是有一个前提：**必须是攻击发起者无人机面对的方向。** 毕竟背对无人机方向的飞机也有可能在这条直线上，所以要特判。

如果是激光，上述所说的就已经完成操作了。**但子弹遇到第一架飞机会消失，这里就比较麻烦了。**

**我们需要计算所有满足上述要求无人机 与 攻击发起者 的距离。距离最短的就是被攻击的目标了。**

由于这种方法是省下了时间，但是代码很容易出错，我也就没去用这种方法。~~当然也没有代码~~。有自信的童鞋们可以去试试 awa。

## 6、合并

上述就是所有操作的讲解及代码了。

（请不要问我为什么无视要$N$操作，什么都不操作那就不叫操作了）

由于在所有飞机移动之后，剩下的飞机就会按编号顺序，每次执行一个指令。**所以上述的指令代码全部都套在一个$for$循环中，这个$for$循环枚举了每驾飞机。**

**最后的最后，由于时间为$t$，所以上述的 移动 + 各个操作 都需要放在一个大循环内**

于是我们把代码合并下来。

```cpp
#include<bits/stdc++.h>
#define mian main
#define QWQ puts("QWQ");
using namespace std;

struct feiji
{
	int x, y, z, h, f, atk, deg, mat, mdf, hp, fix, ti;
	string s;
}f[205];

int n, t;
int dx[8][5] = {{0, 1, 1, 1, 0},{0, 1, 1, 1, 0},{0, 0, 0, 0, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0},{0, 0, 0, 0, 0},{0, 1, 1, 1, 0}};
int dy[8][5] = {{0, 0, 0, 0, 0},{0, 1, 1, 1, 0},{0, 1, 1, 1, 0},{0, 1, 1, 1, 0},{0, 0, 0, 0, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0},{0, -1, -1, -1, 0}};
int dz[8][5] = {{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1},{-1, -1, 0, 1, 1}};

int main()
{
	scanf("%d%d", &n, &t);//输入部分 
	for(int i = 1; i <= n; i ++)
	{
		scanf("%d%d%d%d%d%d%d%d%d%d%d", &f[i].x, &f[i].y, &f[i].z, &f[i].h, &f[i].f, &f[i].atk, &f[i].deg, &f[i].mat, &f[i].mdf, &f[i].hp, &f[i].fix);
		cin >> f[i].s;
		f[i].ti = i;//这里记录了每驾无人机的编号 
	} 
	for(int i = 1; i <= t; i ++)//t表示时间，所以要循环t轮 
	{
		for(int j = 1; j <= n; j ++)
		{
			if(f[j].hp > 0)
				f[j].x += dx[f[j].f][f[j].h], f[j].y += dy[f[j].f][f[j].h], f[j].z += dz[f[j].f][f[j].h];
		}
		for(int j = 1; j <= n; j ++)
		{
			if(f[j].hp <= 0)//坠毁的飞机就不操作了
				continue;
			char c = f[j].s[i - 1];
        //由于字符串是从 s[0]开始存的（而不是1），所以这里要 -1。
			if(c == 'N')continue;//没有操作就continue掉
			if(c == 'U') if(f[j].h < 4) f[j].h ++;
			if(c == 'D') if(f[j].h > 0) f[j].h --;
			if(c == 'L')
			{
				f[j].f ++;
				if(f[j].f > 7) f[j].f = 0;
			}
			if(c == 'R')
			{
				f[j].f --;
				if(f[j].f < 0) f[j].f = 7;
			}
			if(c == 'F') f[j].hp += f[j].fix;
			if(c == 'A')
			{
				bool flag = false;
				for(int k = 1; k <= 100; k ++)
				{
					for(int v = 1; v <= n; v ++)
						if(f[j].x + dx[f[j].f][f[j].h] * k == f[v].x && f[j].y + dy[f[j].f][f[j].h] * k == f[v].y && f[j].z + dz[f[j].f][f[j].h] * k == f[v].z && f[v].hp != 0) 
						{
							if(f[j].atk > f[v].deg)f[v].hp -= (f[j].atk - f[v].deg);
							flag = true;
							break;
						}
					if(flag) break;
				}	
			}
			if(c == 'M')
			{
				for(int k = 1; k <= 100; k ++)
					for(int v = 1; v <= n; v ++)
						if(f[j].x + dx[f[j].f][f[j].h] * k == f[v].x && f[j].y + dy[f[j].f][f[j].h] * k == f[v].y && f[j].z + dz[f[j].f][f[j].h] * k == f[v].z)
							if(f[j].mat > f[v].mdf)f[v].hp -= (f[j].mat - f[v].mdf);		
			}
		}
	}
	for(int i = 1; i <= n; i ++)
	{
		printf("%d %d %d ", f[i].x, f[i].y, f[i].z);
		if(f[i].hp <= 0) printf("0\n");//如果坠毁，生命值输出0
		else printf("%d\n", f[i].hp);
	}
	return 0;
} 
```
看代码好像很长...其实我觉得这个算短的了。

## 7、注意点：

- 1、**如果同一坐标里有多组无人机，编号最小的会被子弹攻击。** 

	这个我们已经在无形之中处理掉了。因为我们枚举每驾飞机就是从 $1$开始枚举的。一旦有飞机被攻击，就会立即$break$，后面编号大的飞机就不会处理了。

- 2、**激光和子弹 分别对应了伤害值和防御值。**
	
    （我在打子弹的代码时不小心把激光的伤害值和防御值套进去了，搞得我调了半天代码...awa）
    
## 8、后记

**不得不说啊...这种大模拟打起来真的很累人。但是多练这种题，代码能力会明显提高。**

毕竟套算法的就是考你算法学习，套模拟就是考你代码能力。

这篇题解总计码了$1h30min$。写的算是比较细了，希望大家能多多支持(~~点赞~~)。希望大家能看懂 QAQ。

有不懂的可以发评论 或者 讨论版 at我，我尽量会看的 awa。


---

## 作者：lengxinjy (赞：4)

蒟蒻的第一篇题解……

看到这个题，直接大模拟。

本题的难点主要在于对正前方的判断以及对攻击范围的判断。

对于正前方……打表大法好。

至于攻击范围的判断，就需要一些黑科技了。

------------

前置知识：空间直角坐标系（参见数学必修2）、向量（参见数学必修4）
对于空间中任意一向量，我们可以用三维坐标$(x,y,z)$来表示。

向量的模长：即向量的长度，用勾股定理求解即可。
$$
|(x,y,z)|=\sqrt{x^2+y^2+z^2}
$$
```cpp
double len(point a)
{
	return sqrt(1.0*a.x*a.x+1.0*a.y*a.y+1.0*a.z*a.z);
}
```

向量的加减：直接将对应维度的坐标相加减即可。
$$
(x_1,y_1,z_1)±(x_2,y_2,z_2)=(x_1±x_2,y_1±y_2,z_1±z_2)
$$
本题中只需用向量减法即可。
```cpp
point minusv(point a,point b)
{
	point ans;
	ans.x=b.x-a.x;
	ans.y=b.y-a.y;
	ans.z=b.z-a.z;
	return ans;
}
```
向量的点乘：两个向量的对应坐标的积之和，结果为一个数。
$$
(x_1,y_1,z_1)\cdot(x_2,y_2,z_2)=x_1x_2+y_1y_2+z_1z_2
$$
```cpp
int dot(point a,point b)
{
	return a.x*b.x+a.y*b.y+a.z*b.z;
}
```
向量点乘可用于判断两向量的夹角大小：点乘为正，夹角小于$\frac{\pi}{2}$；点乘为负，夹角大于$\frac{\pi}{2}$；点乘为零，两向量垂直。

向量叉乘：本题的重头戏，用于判断向量的平行关系。

定义上，向量的叉积的结果仍为向量，其长度为两向量所确定的平行四边形的面积，即：
$$
|\vec a\times\vec b|=|\vec a||\vec b|\sin<\vec a,\vec b>
$$
方向可以用物理上的右手定则来判断，~~由于没啥卵用这里不讲~~。

我们有如下公式：
$$
(x_1,y_1,z_1)\times(x_2,y_2,z_2)=(y_1z_2-y_2z_1,x_2z_1-x_1z_2,x_1y_2-x_2y_1)
$$
```cpp
point det(point a,point b)
{
	point ans;
	ans.x=a.y*b.z-a.z*b.y;
	ans.y=a.z*b.x-a.x*b.z;
	ans.z=a.x*b.y-a.y*b.x;
	return ans;
}
```
如何判断两向量是否平行（共线）？

前面说过，向量叉积的模长等于平行四边形的面积。如果两向量平行，它们确定的平行四边形的面积就是$0$，因此它们叉积的模长也就是$0$。
```cpp
bool para(point a,point b)
{
	if(len(det(a,b))<eps)return true;
	return false;
}
```
（注意判断实数是否相等的方法）

------------

回到本题，刚才我们讲的技巧都是为M和A两个操作服务的。

对于M操作，我们只需要暴力枚举并判断它们是否在当前无人机的正前方即可。

要判断点A是否在另一点B的正前方，我们应检查该点是否符合以下两个条件：

1、连线向量$\overrightarrow {AB}$与方向向量$\vec f$共线。

2、这两个向量的方向相同（即不在后方）。

对于条件1，我们可以直接用上面讲的最后一个技巧判断；对于条件2，我们可以检验这两个向量的点积是否大于$0$。
```cpp
bool judge_m(point a,point b,int F,int H)
{
	return para(minusv(b,a),dire(F,H))&&dot(minusv(a,b),dire(F,H))>0&&!eql(a,b));//注意判断两向量是否相等
}
```
对于A操作，我们按编号顺序从小到大枚举一遍，记录与当前无人机距离最近的且符合条件的目标即可。
```cpp
int judge_a(int a)
{
	point c,d;
	double minl=1.0*INF;
	int g=0;
	c.x=x[a],c.y=y[a],c.z=z[a];
	rep(i,1,n)
	{
		if(i==a)continue;
		d.x=x[i],d.y=y[i],d.z=z[i];
		if(!judge_m(c,d,f[a],h[a]))continue;
		if(len(minusv(c,d))<minl&&!eql(c,d)&&hp[i]>0)minl=len(minusv(c,d)),g=i;
	}
	return g;
}
```
其他操作比较简单，直接按题意模拟即可，详见代码。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int INF=2147483647;
const double eps=1e-6;
inline int read()
{
	int x=0,k=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*k;
}
struct point{
	int x,y,z;
};
int n,t;
int x[103],y[103],z[103],h[103],f[103],atk[103],def[103],mat[103],mdf[103],hp[103],fix[103];
string op[103];
int sx[8]={1,1,0,-1,-1,-1,0,1},sy[8]={0,1,1,1,0,-1,-1,-1};//打表处理方向
point e;
point dire(int F,int H)
{
	point ans;
	if(H==0||H==1)ans.z=-1;
	if(H==3||H==4)ans.z=1;
	if(H==2)ans.z=0;
	if(H==1||H==2||H==3)ans.x=sx[F],ans.y=sy[F];
	else ans.x=ans.y=0;
	return ans;
}//用f,h两个参数确定方向向量
double len(point a)
{
	return sqrt(1.0*a.x*a.x+1.0*a.y*a.y+1.0*a.z*a.z);
}//向量的模长
bool eql(point a,point b)
{
	return (a.x==b.x)&&(a.y==b.y)&&(a.z==b.z);
}//判断两向量是否相等
point minusv(point a,point b)
{
	point ans;
	ans.x=b.x-a.x;
	ans.y=b.y-a.y;
	ans.z=b.z-a.z;
	return ans;
}//首尾坐标相减确定向量
int dot(point a,point b)
{
	return a.x*b.x+a.y*b.y+a.z*b.z;
}//向量点乘
point det(point a,point b)
{
	point ans;
	ans.x=a.y*b.z-a.z*b.y;
	ans.y=a.z*b.x-a.x*b.z;
	ans.z=a.x*b.y-a.y*b.x;
	return ans;
}//向量叉乘
bool para(point a,point b)
{
	if(len(det(a,b))<eps)return true;
	return false;
}//判断两向量是否平行
bool judge_m(point a,point b,int F,int H)
{
	return para(minusv(b,a),dire(F,H))&&dot(minusv(a,b),dire(F,H))>0&&(!eql(a,b));
}//判断是否在正前方
int judge_a(int a)
{
	point c,d;
	double minl=1.0*INF;
	int g=0;
	c.x=x[a],c.y=y[a],c.z=z[a];
	rep(i,1,n)
	{
		if(i==a)continue;
		d.x=x[i],d.y=y[i],d.z=z[i];
		if(!judge_m(c,d,f[a],h[a]))continue;
		if(len(minusv(c,d))<minl&&!eql(c,d)&&hp[i]>0)minl=len(minusv(c,d)),g=i;
	}
	return g;
}//求出子弹能攻击到的目标
int main()
{
	n=read(),t=read();
	e.x=e.y=e.z=0;
	rep(i,1,n)
	{
		x[i]=read(),y[i]=read(),z[i]=read(),h[i]=read(),f[i]=read(),atk[i]=read(),def[i]=read(),mat[i]=read(),mdf[i]=read(),hp[i]=read(),fix[i]=read();
		cin>>op[i];
	}
	rep(now,1,t)
	{
		rep(i,1,n)
		{
			if(hp[i]>0)x[i]+=dire(f[i],h[i]).x,y[i]+=dire(f[i],h[i]).y,z[i]+=dire(f[i],h[i]).z;
		}
		rep(i,1,n)
		{
			if(hp[i]>0)
			{
				char opt=op[i][now-1];
				if(opt=='N')continue;//无操作
				if(opt=='U')
				{
					if(h[i]==4)continue;
					h[i]++;
				}
				if(opt=='D')
				{
					if(h[i]==0)continue;
					h[i]--;
				}//上下转向
				if(opt=='L')f[i]=(f[i]+1)%8;
				if(opt=='R')f[i]=(f[i]+7)%8;//左右转向
				if(opt=='F')hp[i]+=fix[i];//回血
				if(opt=='A')
				{
					int goal=judge_a(i);
					hp[goal]-=((atk[i]>def[goal])?atk[i]-def[goal]:0);
				}//子弹攻击
				if(opt=='M')
				{
					point a,b;
					a.x=x[i],a.y=y[i],a.z=z[i];
					rep(j,1,n)
					{
						b.x=x[j],b.y=y[j],b.z=z[j];
						if(judge_m(a,b,f[i],h[i])&&hp[j]>0)hp[j]-=((mat[i]-mdf[j]>0)?mat[i]-mdf[j]:0);
					}
				}//激光攻击
			}
		}
	}
	rep(i,1,n)
	{
		printf("%d %d %d %d\n",x[i],y[i],z[i],(hp[i]>0)?hp[i]:0);
	}
	return 0;
}
```


---

## 作者：huangx607087 (赞：4)

这道题实际上是一个暴力模拟，n不超过100，坐标不超过±100，复杂度不超过O（20000）

然而，这道题还是非常的~~坑，直接导致我submit+=18才A了这道题~~，因为我太~~蔡~~了。

关于存方向我这里提一下：我们可以用一个3位数表示移动过程，以(1,0,-1)为例，我们可以转成321这个数字，其中百位-2表示x移动方向，十位-2表示y移动方向，个位-2表示z移动方向，然后初始化找规律，可以节省10几行代码和赋值，也避免了开3维数组。。

附上高(ma)清(feng)无(ji)码(chou)的代码，内附解释和注意点
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;//这边我用的m(习惯了) 
int locx[902],locy[902],locz[902],h[902];//loc表示location，位置 
int f[902],atk[902],def[902],mat[902];
int mdf[902],hp[902],fix[902],dir[5][8];
char emo[902][902];//进行操作emotion 
bool live[902];//判断是否活着 
void getdir()
{
	memset(live,1,sizeof(live));//初始化操作 
	int i,j;
	for(i=0;i<=7;i++) dir[0][i]=221;
	for(i=0;i<=7;i++) dir[4][i]=223;
	int p[8]={32,33,23,13,12,11,21,31};
	for(i=1;i<=3;i++)
		for(j=0;j<=7;j++) dir[i][j]=p[j]*10+i;
	//百位存x移动，十位存y移动，个位存z移动 
	//可以避免开3维数组，导致赋值达到10+行 
//	dir[1]={321,331,231,131,121,111,211,311};
//	dir[2]={322,332,232,132,122,112,212,312};
//	dir[3]={323,333,233,133,123,113,213,313};
// 1表示-1,2表示0,3表示+1，到时候取位数就行了 
}
void work(int x,int T)//第x架飞机在第T时刻的行动 
{	
	int i,j,k,atked;
	char doing=emo[x][T];//取动作 
	switch(doing)
	{
		case 'N':{break;};
		case 'R':{f[x]--;break;}//这边不要特判了，因为f[x]我们存的很大，直接取模 
		case 'L':{f[x]++;break;}
		case 'U':{if(h[x]-4) h[x]++;break;}//hx-4就是hx!=4 
		case 'D':{if(h[x]) h[x]--;break;}
		case 'F':{hp[x]+=fix[x];break;}
		case 'A':
		{
			int zidan=400;//子弹>0表示有效，由于是200*200的地图，子弹不会飞超过400格
			//这里一个坑点：当时我zidan=204结果WA 了18和21 
			int Nx=locx[x],Ny=locy[x],Nz=locz[x];
			while(zidan>0)
			{
				Nx+=dir[h[x]][f[x]%8]/100-2;//三位数取其中某一位不要我说吧 。。 
				Ny+=dir[h[x]][f[x]%8]/10%10-2;//x取百位，y取十位，z取个位 
				Nz+=dir[h[x]][f[x]%8]%10-2;
				for(i=1;i<=n;i++)
				{
					if(!live[i]) continue;//死了跳过 
					if(locx[i]==Nx&&locy[i]==Ny&&locz[i]==Nz)//打中敌机 
					{
						zidan=0;
						hp[i]-=max(0,atk[x]-def[i]);
						if(hp[i]<=0)
						{
							live[i]=0;//这玩意pass away了 
							hp[i]=0;//这边也很坑，因为。。。。。不然你会输出负数 
						}
						break;
					}
				}
				zidan--;//while死循环了解一下 
			}
			break;
		}
		case 'M':
		{
			int zidan=400;//模仿A的步骤 
			int Nx=locx[x],Ny=locy[x],Nz=locz[x];
			while(zidan>0)
			{
				Nx+=dir[h[x]][f[x]%8]/100-2;
				Ny+=dir[h[x]][f[x]%8]/10%10-2;
				Nz+=dir[h[x]][f[x]%8]%10-2;
				for(i=1;i<=n;i++)
				{
					if(!live[i]) continue;
					if(locx[i]==Nx&&locy[i]==Ny&&locz[i]==Nz)
					{
						hp[i]-=max(0,mat[x]-mdf[i]);
						if(hp[i]<=0)
						{
							//激光打中了不需要标记子弹无效 
							live[i]=0;
							hp[i]=0;
						}
						break;
					}
				}
				zidan--;
			}
			break;//switch case后面一个case跟一个break 
		}
		default:break;
	}
}
int main()
{
	int i,j;
//	freopen("My.hx902out","w",stdout);
	getdir();
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&locx[i],&locy[i],&locz[i],&h[i]);
		scanf("%d%d%d%d",&f[i],&atk[i],&def[i],&mat[i]);
		scanf("%d%d%d%s",&mdf[i],&hp[i],&fix[i],emo[i]+1);	//一堆输入
		//这边emo+1是一种读字符串然后存字符数组的格式 
		f[i]+=607087800;
		//防f[i]溢出 (>7或者<0)，到时候取模即可 ,这个数一定要是8的倍数 
	}
	for(i=1;i<=m;i++)
	{
		for(j=1;j<=n;j++)
		{
			if(!live[j]) continue;
			locx[j]+=(dir[h[j]][f[j]%8]/100-2);
			locy[j]+=((dir[h[j]][f[j]%8]/10)%10)-2;
			locz[j]+=dir[h[j]][f[j]%8]%10-2;//坑啊，要先同时移动再攻击！WA4个点的同学看过来 
		}
		for(j=1;j<=n;j++) if(live[j]) work(j,i);//发动攻势 
	}
	for(i=1;i<=n;i++)
	{
		printf("%d %d %d %d\n",locx[i],locy[i],locz[i],hp[i]);//输出 
	}
	return 0;
}
//没有注释的话119行，还好
//跟楼上相比可能节省了那些烦人的赋值语句
```
最后我再说两句：历年NOIP模拟都是极重要的，17年时间复杂度(P[P3952](https://www.luogu.org/problem/P3952))
是获得国一的关键

如果各位还想练习模拟的话，可以试一下~~我的题目~~[U82785](https://www.luogu.org/problem/U82785)，标程也有90几行

祝各(zi)位(ji)NOIP 2019 和高考2020 RP++

---

## 作者：yu__xuan (赞：4)

一看题目第一反应是模拟，动手写了150多行A了。
$\large\color{red}\text{注意：读题一定要细心！！！}$

[我的博客园](https://www.cnblogs.com/poi-bolg-poi/p/11349847.html)
解释都在代码里。

$updata:20190814$之前那个代码少了个等号过不了样例，qwq
数据好水~
```cpp
#include<bits/stdc++.h>
#define MAXN 101
using namespace std;
int n,t;
struct qwq{
    int dx,dy,dz;
}movebz[5][8];//用于存储f、h对应的正前方
struct info{
    int x,y,z,h,f;
    int atk,def,mat,mdf,hp,fix;
    string cmd;
    bool flag;
}a[MAXN];//存储每一架飞机的信息
inline int read(){
    int x=0;bool f=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return f?-x:x;
}//读优
inline void write(int x){
    if(x<0){
        putchar('-');
        write(-x);
    }else{
        if(x/10) write(x/10);
        putchar(x%10+'0');
    }
}//输优
inline void move(){
    for(int i=1;i<=n;++i){
        if(!a[i].flag) continue;//注意：已经坠毁的飞机就不用移动了。
        a[i].x+=movebz[a[i].h][a[i].f].dx;
        a[i].y+=movebz[a[i].h][a[i].f].dy;
        a[i].z+=movebz[a[i].h][a[i].f].dz;
    }
}//向正前方移动
void work(){//打表，存储f、h对应的正前方
    for(int i=0;i<=7;++i){
        movebz[0][i].dx=0;movebz[0][i].dy=0;movebz[0][i].dz=-1;
        movebz[4][i].dx=0;movebz[4][i].dy=0;movebz[4][i].dz=1;
    }
    movebz[1][0].dx=1;movebz[1][0].dy=0;movebz[1][0].dz=-1;
    movebz[1][1].dx=1;movebz[1][1].dy=1;movebz[1][1].dz=-1;
    movebz[1][2].dx=0;movebz[1][2].dy=1;movebz[1][2].dz=-1;
    movebz[1][3].dx=-1;movebz[1][3].dy=1;movebz[1][3].dz=-1;
    movebz[1][4].dx=-1;movebz[1][4].dy=0;movebz[1][4].dz=-1;
    movebz[1][5].dx=-1;movebz[1][5].dy=-1;movebz[1][5].dz=-1;
    movebz[1][6].dx=0;movebz[1][6].dy=-1;movebz[1][6].dz=-1;
    movebz[1][7].dx=1;movebz[1][7].dy=-1;movebz[1][7].dz=-1;

    movebz[3][0].dx=1;movebz[3][0].dy=0;movebz[3][0].dz=1;
    movebz[3][1].dx=1;movebz[3][1].dy=1;movebz[3][1].dz=1;
    movebz[3][2].dx=0;movebz[3][2].dy=1;movebz[3][2].dz=1;
    movebz[3][3].dx=-1;movebz[3][3].dy=1;movebz[3][3].dz=1;
    movebz[3][4].dx=-1;movebz[3][4].dy=0;movebz[3][4].dz=1;
    movebz[3][5].dx=-1;movebz[3][5].dy=-1;movebz[3][5].dz=1;
    movebz[3][6].dx=0;movebz[3][6].dy=-1;movebz[3][6].dz=1;
    movebz[3][7].dx=1;movebz[3][7].dy=-1;movebz[3][7].dz=1;

    movebz[2][0].dx=1;movebz[2][0].dy=0;movebz[2][0].dz=0;
    movebz[2][1].dx=1;movebz[2][1].dy=1;movebz[2][1].dz=0;
    movebz[2][2].dx=0;movebz[2][2].dy=1;movebz[2][2].dz=0;
    movebz[2][3].dx=-1;movebz[2][3].dy=1;movebz[2][3].dz=0;
    movebz[2][4].dx=-1;movebz[2][4].dy=0;movebz[2][4].dz=0;
    movebz[2][5].dx=-1;movebz[2][5].dy=-1;movebz[2][5].dz=0;
    movebz[2][6].dx=0;movebz[2][6].dy=-1;movebz[2][6].dz=0;
    movebz[2][7].dx=1;movebz[2][7].dy=-1;movebz[2][7].dz=0;
}

int main(){
    work();//预处理movebz数组
    n=read(),t=read();
    string s;
    for(register int i=1;i<=n;++i){
        a[i].x=read(),a[i].y=read();
        a[i].z=read(),a[i].h=read();
        a[i].f=read(),a[i].atk=read();
        a[i].def=read(),a[i].mat=read();
        a[i].mdf=read(),a[i].hp=read();
        a[i].fix=read(),a[i].flag=1;
        cin>>a[i].cmd;
    }//读入好多好恶心~
    for(int i=0;i<t;++i){
        move();//每一次都要移动注意题目中的`先`
        for(int j=1;j<=n;++j){
            if(!a[j].flag||a[j].cmd[i]=='N') continue;//如果已经坠毁或这次无操作就continue
            if(a[j].cmd[i]=='U'&&a[j].h<4) a[j].h++;//向上
            if(a[j].cmd[i]=='D'&&a[j].h>0) a[j].h--;//向下
            if(a[j].cmd[i]=='L'){//向左
                if(a[j].f<7) a[j].f++;
                else a[j].f=0;//认真读题，当f为7时如果在向左就会变为0
            }
            if(a[j].cmd[i]=='R'){
                if(a[j].f>0) a[j].f--;//认真读题
                else a[j].f=7;
            }
            if(a[j].cmd[i]=='F') a[j].hp+=a[j].fix;//修理
            if(a[j].cmd[i]=='A'){//子弹
                int sum=0;//判断向前移动了几次。
                bool f=0;//判断有没有打到一架飞机
                int xx=a[j].x,yy=a[j].y,zz=a[j].z;
                while(!f){
	                xx+=movebz[a[j].h][a[j].f].dx;//每次向前移动
    	            yy+=movebz[a[j].h][a[j].f].dy;
        	        zz+=movebz[a[j].h][a[j].f].dz;
            	    sum++;//移动次数加一
                	for(int k=1;k<=n;++k){
                    	if(!a[k].flag) continue;//如果当前这架飞机坠毁了，就continue
                    	if(a[k].x==xx&&a[k].y==yy&&a[k].z==zz){//如果当前到达了一架没有坠毁的飞机
                        	f=1;//打到了，qwq
                        	int sh=a[j].atk-a[k].def;//计算伤害
                        	if(sh>0){//抠除血量
                            	a[k].hp-=sh;
                            	if(a[k].hp<=0){//因为坠毁的飞机最后输出时血量为0直接改成0
                                	a[k].hp=0;
                                	a[k].flag=0;//它坠毁了
                            	}
                        	}
                        	break;
                    	}
                	}
                	if(sum>100) break;
                }
            }
            if(a[j].cmd[i]=='M'){//激光和子弹类似qwq
                int sum=0;//同上
                int xx=a[j].x,yy=a[j].y,zz=a[j].z;
                while(sum<100){
                	xx+=movebz[a[j].h][a[j].f].dx;//同上
    	            yy+=movebz[a[j].h][a[j].f].dy;
        	        zz+=movebz[a[j].h][a[j].f].dz;
            	    sum++;//同上
                	for(register int k=1;k<=n;++k){
                	    if(!a[k].flag) continue;//同上
                    	if(a[k].x==xx&&a[k].y==yy&&a[k].z==zz){
                        	int sh=a[j].mat-a[k].mdf;//同上
                        	if(sh>0){//同上
                            	a[k].hp-=sh;
                            	if(a[k].hp<=0){
                                	a[k].flag=0;
                                	a[k].hp=0;
                            	}
                        	}
                    	}
                	}
            	}
        	}
    	}
	}
    for(register int i=1;i<=n;++i){//输出答案qwq
        write(a[i].x);printf(" ");
        write(a[i].y);printf(" ");
        write(a[i].z);printf(" ");
        write(a[i].hp);
        puts("");
    }
    return 0;
}
```

---

## 作者：切格瓦·星 (赞：3)

这题本蒟蒻是在比赛结束后写的，一不小心就写得长了些，反正就是按照题意模拟就行了。（有个地方错了害得我改了好久.....)
```cpp
#include<bits/stdc++.h>
using namespace std;
struct plane{
	int x,y,z,h,f,x2,y2,z2;
	long long atk,def,mat,mdf,hp,fix;
	bool alive;
}pla[10000];
int t,n;
char a[1050][1050];
long long h;
void Hit(int T,int f,int xu){
	long long minn=214748003647;
	int x=pla[xu].x;
	int y=pla[xu].y;
	int z=pla[xu].z;
	if(T==0){
		for(int i=n;i>=1;i--){
			if(pla[i].x==x&&pla[i].y==y){
				if(pla[i].z<z){
					if(z-pla[i].z<=minn&&pla[i].alive==1){
						minn=z-pla[i].z;
						h=i;
					}
				}
			}
		}
		if(pla[xu].atk-pla[h].def>0)
		pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
		if(pla[h].hp<=0)
			pla[h].alive=0;
	}
	if(T==4){
		for(int i=n;i>=1;i--){
			if(pla[i].x==x&&pla[i].y==y){
				if(pla[i].z>z){
					if(pla[i].z-z<=minn&&pla[i].alive==1){
						minn=pla[i].z-z;
						h=i;
					}
				}
			}
		}
		if(pla[xu].atk-pla[h].def>0)
		pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
		if(pla[h].hp<=0)
			pla[h].alive=0;
	}
	if(T==1){
		if(f==0){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(pla[i].x-x==z-pla[i].z&&pla[i].x>x&&pla[i].z<z&&pla[i].alive==1){
						if(pla[i].x-x+z-pla[i].z<=minn){
							minn=pla[i].x-x+z-pla[i].z;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==1){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==z-pla[i].z&&z-pla[i].z==pla[i].y-y&&pla[i].y>y&&pla[i].x>x&&pla[i].z<z&&pla[i].alive==1){
					if(pla[i].x-x+z-pla[i].z+pla[i].y-y<=minn){
						minn=pla[i].x-x+z-pla[i].z+pla[i].y-y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==2){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(z-pla[i].z==pla[i].y-y&&pla[i].y>y&&pla[i].z<z&&pla[i].alive==1){
						if(z-pla[i].z+pla[i].y-y<=minn){
							minn=z-pla[i].z+pla[i].y-y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==3){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==z-pla[i].z&&z-pla[i].z==pla[i].y-y&&pla[i].y>y&&x>pla[i].x&&pla[i].z<z&&pla[i].alive==1){
					if(x-pla[i].x+z-pla[i].z+pla[i].y-y<=minn){
						minn=x-pla[i].x+z-pla[i].z+pla[i].y-y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==4){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(x-pla[i].x==z-pla[i].z&&x>pla[i].x&&pla[i].z<z&&pla[i].alive==1){
						if(z-pla[i].z+x-pla[i].x<=minn){
							minn=z-pla[i].z+x-pla[i].x;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==5){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==z-pla[i].z&&z-pla[i].z==y-pla[i].y&&pla[i].y<y&&x>pla[i].x&&pla[i].z<z&&pla[i].alive==1){
					if(x-pla[i].x+z-pla[i].z+y-pla[i].y<=minn){
						minn=x-pla[i].x+z-pla[i].z+y-pla[i].y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==6){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(y-pla[i].y==z-pla[i].z&&y>pla[i].y&&pla[i].z<z&&pla[i].alive==1){
						if(z-pla[i].z+y-pla[i].y<=minn){
							minn=z-pla[i].z+y-pla[i].y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==7){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==z-pla[i].z&&z-pla[i].z==y-pla[i].y&&pla[i].y<y&&x<pla[i].x&&pla[i].z<z&&pla[i].alive==1){
					if(pla[i].x-x+z-pla[i].z+y-pla[i].y<=minn){
						minn=pla[i].x-x+z-pla[i].z+y-pla[i].y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
	}
	if(T==2){
		if(f==0){
			for(int i=n;i>=1;i--){
				if(y==pla[i].y&&pla[i].z==z){
					if(pla[i].x>x&&pla[i].alive==1){
						if(pla[i].x-x<=minn){
							minn=pla[i].x-x;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==1){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(pla[i].y-y==pla[i].x-x&&y<pla[i].y&&pla[i].x>x&&pla[i].alive==1){
						if(pla[i].x-x+pla[i].y-y<=minn){
							minn=pla[i].x-x+pla[i].y-y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==2){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x&&pla[i].z==z){
					if(pla[i].y>y&&pla[i].alive==1){
						if(pla[i].y-y<=minn){
							minn=pla[i].y-y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==3){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(pla[i].y-y==x-pla[i].x&&y<pla[i].y&&x>pla[i].x&&pla[i].alive==1){
						if(x-pla[i].x+pla[i].y-y<=minn){
							minn=pla[i].y-y+x-pla[i].x;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==4){
			for(int i=n;i>=1;i--){
				if(y==pla[i].y&&pla[i].z==z){
					if(x>pla[i].x&&pla[i].alive==1){
						if(x-pla[i].x<=minn){
							minn=x-pla[i].x;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==5){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(y-pla[i].y==x-pla[i].x&&y>pla[i].y&&x>pla[i].x&&pla[i].alive==1){
						if(x-pla[i].x+y-pla[i].y<=minn){
							minn=x-pla[i].x+y-pla[i].y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==6){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x&&pla[i].z==z){
					if(y>pla[i].y&&pla[i].alive==1){
						if(y-pla[i].y<=minn){
							minn=y-pla[i].y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==7){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(y-pla[i].y==pla[i].x-x&&pla[i].y<y&&pla[i].x>x&&pla[i].alive==1){
						if(pla[i].x-x+y-pla[i].y<=minn){
							minn=pla[i].x-x+y-pla[i].y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
	}
	if(T==3){
		if(f==0){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(pla[i].x-x==pla[i].y-y&&pla[i].x>x&&pla[i].y>y&&pla[i].alive==1){
						if(pla[i].x-x+pla[i].y-y<=minn){
							minn=pla[i].x-x+pla[i].y-y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==1){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==pla[i].z-z&&pla[i].z-z==pla[i].y-y&&pla[i].y>y&&x<pla[i].x&&pla[i].z>z&&pla[i].alive==1){
					if(pla[i].x-x+pla[i].z-z+pla[i].y-y<=minn){
						minn=pla[i].x-x+pla[i].z-z+pla[i].y-y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==2){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(pla[i].y-y==pla[i].z-z&&y<pla[i].y&&pla[i].z>z&&pla[i].alive==1){
						if(pla[i].z-z+pla[i].y-y<=minn){
							minn=pla[i].z-z+pla[i].y-y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==3){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==pla[i].z-z&&pla[i].z-z==pla[i].y-y&&y<pla[i].y&&x>pla[i].x&&z<pla[i].z&&pla[i].alive==1){
					if(x-pla[i].x+pla[i].z-z+pla[i].y-y<=minn){
						minn=x-pla[i].x+pla[i].z-z+pla[i].y-y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==4){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(x-pla[i].x==pla[i].z-z&&x>pla[i].x&&z<pla[i].z&&pla[i].alive==1){
						if(pla[i].z-z+x-pla[i].x<=minn){
							minn=pla[i].z-z+x-pla[i].x;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==5){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==pla[i].z-z&&pla[i].z-z==y-pla[i].y&&pla[i].y<y&&x>pla[i].x&&z<pla[i].z&&pla[i].alive==1){
					if(x-pla[i].x+pla[i].z-z+y-pla[i].y<=minn){
						minn=x-pla[i].x+pla[i].z-z+y-pla[i].y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==6){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(y-pla[i].y==pla[i].z-z&&y>pla[i].y&&z<pla[i].z&&pla[i].alive==1){
						if(pla[i].z-z+y-pla[i].y<=minn){
							minn=pla[i].z-z+y-pla[i].y;
							h=i;
						}
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
		if(f==7){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==pla[i].z-z&&pla[i].z-z==y-pla[i].y&&pla[i].y<y&&x<pla[i].x&&pla[i].z>z&&pla[i].alive==1){
					if(pla[i].x-x+pla[i].z-z+y-pla[i].y<=minn){
						minn=pla[i].x-x+pla[i].z-z+y-pla[i].y;
						h=i;
					}
				}
			}
			if(pla[xu].atk-pla[h].def>0)
			pla[h].hp=pla[h].hp-pla[xu].atk+pla[h].def;
			if(pla[h].hp<=0)
				pla[h].alive=0;
		}
	}
}
void Jg(int h,int f,int xu){
	int x=pla[xu].x;
	int y=pla[xu].y;
	int z=pla[xu].z;
	if(h==0){
		for(int i=n;i>=1;i--){
			if(pla[i].x==x&&pla[i].y==y&&pla[i].alive==1){
				if(pla[i].z<z){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
	}
	if(h==4){
		for(int i=n;i>=1;i--){
			if(pla[i].x==x&&pla[i].y==y){
				if(pla[i].z>z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
	}
	if(h==1){
		if(f==0){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(pla[i].x-x==z-pla[i].z&&pla[i].x>x&&pla[i].z<z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp-=pla[xu].mat-pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==1){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==z-pla[i].z&&z-pla[i].z==pla[i].y-y&&pla[i].y>y&&pla[i].x>x&&pla[i].z<z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
		if(f==2){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(z-pla[i].z==pla[i].y-y&&pla[i].y>y&&pla[i].z<z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==3){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==z-pla[i].z&&z-pla[i].z==pla[i].y-y&&pla[i].y>y&&x>pla[i].x&&pla[i].z<z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
		if(f==4){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(x-pla[i].x==z-pla[i].z&&x>pla[i].x&&pla[i].z<z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==5){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==z-pla[i].z&&z-pla[i].z==y-pla[i].y&&pla[i].y<y&&x>pla[i].x&&pla[i].z<z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
		if(f==6){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(y-pla[i].y==z-pla[i].z&&y>pla[i].y&&pla[i].z<z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==7){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==z-pla[i].z&&z-pla[i].z==y-pla[i].y
				&&pla[i].y<y&&x<pla[i].x&&pla[i].z<z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
	}
	if(h==2){
		if(f==0){
			for(int i=n;i>=1;i--){
				if(y==pla[i].y&&pla[i].z==z){
					if(pla[i].x>x&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==1){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(pla[i].y-y==pla[i].x-x&&y<pla[i].y&&pla[i].x>x&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==2){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x&&pla[i].z==z){
					if(pla[i].y>y&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==3){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(pla[i].y-y==x-pla[i].x&&y<pla[i].y&&x>pla[i].x&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==4){
			for(int i=n;i>=1;i--){
				if(y==pla[i].y&&pla[i].z==z){
					if(x>pla[i].x&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==5){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(y-pla[i].y==x-pla[i].x&&y>pla[i].y&&x>pla[i].x&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==6){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x&&pla[i].z==z){
					if(y>pla[i].y&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==7){
			for(int i=n;i>=1;i--){
				if(pla[i].z==z){
					if(y-pla[i].y==pla[i].x-x&&pla[i].y<y&&pla[i].x>x&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
	}
	if(h==3){
		if(f==0){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){
					if(pla[i].x-x==pla[i].y-y&&pla[i].x>x&&pla[i].y>y&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==1){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==pla[i].z-z&&pla[i].z-z==pla[i].y-y
				&&pla[i].y>y&&x<pla[i].x&&pla[i].z>z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
		if(f==2){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(pla[i].y-y==pla[i].z-z&&y<pla[i].y&&pla[i].z>z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==3){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==pla[i].z-z&&pla[i].z-z==pla[i].y-y&&y<pla[i].y
				&&x>pla[i].x&&z<pla[i].z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
		if(f==4){
			for(int i=n;i>=1;i--){
				if(pla[i].y==y){  
					if(x-pla[i].x==pla[i].z-z&&x>pla[i].x&&z<pla[i].z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==5){
			for(int i=n;i>=1;i--){
				if(x-pla[i].x==pla[i].z-z&&pla[i].z-z==y-pla[i].y
				&&pla[i].y<y&&x>pla[i].x&&z<pla[i].z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
		if(f==6){
			for(int i=n;i>=1;i--){
				if(pla[i].x==x){
					if(y-pla[i].y==pla[i].z-z&&y>pla[i].y&&z<pla[i].z&&pla[i].alive==1){
						if(pla[xu].mat-pla[i].mdf>0)
						pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
						if(pla[i].hp<=0)
							pla[i].alive=0;
					}
				}
			}
		}
		if(f==7){
			for(int i=n;i>=1;i--){
				if(pla[i].x-x==pla[i].z-z&&pla[i].z-z==y-pla[i].y
				&&pla[i].y<y&&x<pla[i].x&&pla[i].z>z&&pla[i].alive==1){
					if(pla[xu].mat-pla[i].mdf>0)
					pla[i].hp=pla[i].hp-pla[xu].mat+pla[i].mdf;
					if(pla[i].hp<=0)
						pla[i].alive=0;
				}
			}
		}
	}
}
void get_to(int h,int f,int xu){
	if(h==0){
		pla[xu].z-=1;
	}
	else if(h==4){
		pla[xu].z+=1;
	}
	else if(h==1){
		if(f==0){
			pla[xu].x+=1;
			pla[xu].z-=1;
		}
		else if(f==1){
			pla[xu].x+=1;
			pla[xu].y+=1;
			pla[xu].z-=1;
		}
		else if(f==2){
			pla[xu].y+=1;
			pla[xu].z-=1;
		}
		else if(f==3){
			pla[xu].x-=1;
			pla[xu].y+=1;
			pla[xu].z-=1;
		}
		else if(f==4){
			pla[xu].x-=1;
			pla[xu].z-=1;
		}
		else if(f==5){
			pla[xu].x-=1;
			pla[xu].y-=1;
			pla[xu].z-=1;
		}
		else if(f==6){
			pla[xu].y-=1;
			pla[xu].z-=1;
		}
		else if(f==7){
			pla[xu].x+=1;
			pla[xu].y-=1;
			pla[xu].z-=1;
		}
	}
	else if(h==2){
		if(f==0){
			pla[xu].x+=1;
		}
		else if(f==1){
			pla[xu].x+=1;
			pla[xu].y+=1;
		}
		else if(f==2){
			pla[xu].y+=1;
		}
		else if(f==3){
			pla[xu].x-=1;
			pla[xu].y+=1;
		}
		else if(f==4){
			pla[xu].x-=1;
		}
		else if(f==5){
			pla[xu].x-=1;
			pla[xu].y-=1;
		}
		else if(f==6){
			pla[xu].y-=1;
		}
		else if(f==7){
			pla[xu].x+=1;
			pla[xu].y-=1;
		}
	}
	else if(h==3){
		if(f==0){
			pla[xu].x+=1;
			pla[xu].z+=1;
		}
		else if(f==1){
			pla[xu].x+=1;
			pla[xu].y+=1;
			pla[xu].z+=1;
		}
		else if(f==2){
			pla[xu].y+=1;
			pla[xu].z+=1;
		}
		else if(f==3){
			pla[xu].x-=1;
			pla[xu].y+=1;
			pla[xu].z+=1;
		}
		else if(f==4){
			pla[xu].x-=1;
			pla[xu].z+=1;
		}
		else if(f==5){
			pla[xu].x-=1;
			pla[xu].y-=1;
			pla[xu].z+=1;
		}
		else if(f==6){
			pla[xu].y-=1;
			pla[xu].z+=1;
		}
		else if(f==7){
			pla[xu].x+=1;
			pla[xu].y-=1;
			pla[xu].z+=1;
		}
	}
}
int main(){
	scanf("%d %d",&n,&t);
	for(int i=1;i<=n;i++){
		scanf("%d %d %d %d %d %lld %lld %lld %lld %lld %lld",
		&pla[i].x,&pla[i].y,&pla[i].z,&pla[i].h,&pla[i].f,
		&pla[i].atk,&pla[i].def,&pla[i].mat,&pla[i].mdf,&pla[i].hp,&pla[i].fix);
		cin>>(a[i]+1);
		if(pla[i].hp>0)
		pla[i].alive=1;
	}
	for(int i=1;i<=t;i++){
		for(int j=1;j<=n;j++){
			if(pla[j].alive)
			get_to(pla[j].h,pla[j].f,j);
		}
		for(int j=1;j<=n;j++){
			if(pla[j].alive){
				if(a[j][i]=='F')
					pla[j].hp+=pla[j].fix;
				if(a[j][i]=='U')
					if(pla[j].h!=4)
						pla[j].h++;
				if(a[j][i]=='D')
					if(pla[j].h!=0)
						pla[j].h--;
				if(a[j][i]=='L'){
					if(pla[j].f==7)
						pla[j].f=0;
					else
						pla[j].f++;
				}
				if(a[j][i]=='R'){
					if(pla[j].f==0)
						pla[j].f=7;
					else
						pla[j].f--;
				}
				if(a[j][i]=='A'){
					Hit(pla[j].h,pla[j].f,j);
					h=0;
				}
				if(a[j][i]=='M'){
					Jg(pla[j].h,pla[j].f,j);
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(pla[i].alive)
			cout<<pla[i].x<<" "<<pla[i].y<<" "<<pla[i].z<<" "<<pla[i].hp<<endl;
		if(!pla[i].alive)
			cout<<pla[i].x<<" "<<pla[i].y<<" "<<pla[i].z<<" "<<0<<endl;
	}
	return 0;
}
/*
4 7
-1 -1 0 2 1 1 0 0 0 5 0 RAAAAAA
51 0 1 1 4 0 0 1 0 5 0 UMMMMMM
-2 0 0 2 0 0 0 0 0 5 0 NNNNNNN
53 0 0 2 4 0 0 0 0 5 0 NNNNNNN

6 0 0 1
45 0 0 0
5 0 0 1
46 0 0 4
*/
```


---

## 作者：星空_寻觅 (赞：2)

~~趁着没有大佬来发题解赶紧来一发~~  
其实就是一个美妙~~恶心~~的大模拟。  


------------

每一个无人机需要记录的信息就是题目展示的11种信息。即代表坐标的x,y,z,代表方向的h,f,代表无人机属性的atk,def,mat,mdf,hp,fix  

先打一个方向表（良心~~毒瘤~~出题人在题面中已给出）方便位置的转移。
```cpp
struct node2{int x,y,z;}fx[5][8]=
{
	(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1}, 
	(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1},
	
	(node2){1,0,-1}, (node2){1,1,-1},  (node2){0,1,-1}, (node2){-1,1,-1},
	(node2){-1,0,-1},(node2){-1,-1,-1},(node2){0,-1,-1},(node2){1,-1,-1},
	
	(node2){1,0,0}, (node2){1,1,0},  (node2){0,1,0}, (node2){-1,1,0}, 
	(node2){-1,0,0},(node2){-1,-1,0},(node2){0,-1,0},(node2){1,-1,0},
	
	(node2){1,0,1}, (node2){1,1,1},  (node2){0,1,1}, (node2){-1,1,1}, 
	(node2){-1,0,1},(node2){-1,-1,1},(node2){0,-1,1},(node2){1,-1,1},
	
	(node2){0,0,1},(node2){0,0,1},(node2){0,0,1},(node2){0,0,1}, 
	(node2){0,0,1},(node2){0,0,1},(node2){0,0,1},(node2){0,0,1}
};
```
接下来的题解按照数据点分布给出：  
### Subtask1：12% 
注意到12%的数据点全部都是N操作，所以什么都不干往前飞就是了。  
```cpp
inline void go_front()
{
	for(rint i=1;i<=n;++i)
	{
		if(pla[i].zh)continue;
		pla[i].x+=fx[pla[i].h][pla[i].f].x;
		pla[i].y+=fx[pla[i].h][pla[i].f].y;
		pla[i].z+=fx[pla[i].h][pla[i].f].z;
		mxx=max(mxx,pla[i].x);mnx=min(mnx,pla[i].x);
		mxy=max(mxy,pla[i].y);mny=min(mny,pla[i].y);
		mxz=max(mxz,pla[i].z);mnz=min(mnz,pla[i].z);
	}
	return ;
}
```
### Subtask2：14%  
fix操作好说，出现之后给无人机的hp加上它的fix值即可。
```cpp
inline void c_fix(int id)
{
	pla[id].hp+=pla[id].fix;
	return ;
}
```
### Subtask3：15%  
多了左右转的操作。只需要处理好向左转7转到0和向右转0转到7的边界问题即可。
```cpp
inline void c_left(int id)
{
	if(pla[id].f==7)pla[id].f=0;
	else pla[id].f++;
	return ;
}
inline void c_right(int id)
{
	if(pla[id].f==0)pla[id].f=7;
	else pla[id].f--;
	return ;
}
```
### Subtask4：17%
又多了上下转的操作，只需要处理一下转到边界（向下到0，向上到4）就不能转了的问题即可。
```cpp
inline void c_up(int id)
{
	if(pla[id].h>=4)
		return ;
	pla[id].h++;
}
inline void c_down(int id)
{
	if(pla[id].h<=0)
		return ;
	pla[id].h--;
}
```
### Subtask5：19%
加了激光攻击操作，我的做法是暴力模拟，相信大家也注意到了我在上面的前进操作里记录了一个mxx、mnx、mxy、mny、mxz、mnz，作为边界（因为懒，我只把边界扩充了出去而没有缩回来过，反正操作数不超过100次也不会超出去太多）  
于是我的激光攻击操作就是一个dfs，判断更暴力，直接枚举每一个无人机。一开始想开一个三维map数组，后来发现出题人说不保证坐标在100范围内。于是只能放弃。
```cpp
inline void c_mat(int id)
{
	int dx=pla[id].x+fx[pla[id].h][pla[id].f].x;
	int dy=pla[id].y+fx[pla[id].h][pla[id].f].y;
	int dz=pla[id].z+fx[pla[id].h][pla[id].f].z;
	while(dx<=mxx && dx>=mnx && dy<=mxy && dy>=mny && dz<=mxz && dz>=mnz)
	{
		for(rint i=1;i<=n;++i)
			if(pla[i].x==dx&&pla[i].y==dy&&pla[i].z==dz)
			{
				if(pla[i].zh)continue;
				pla[i].hp-=max(pla[id].mat-pla[i].maf,0);
				if(pla[i].hp<=0)pla[i].hp=0,pla[i].zh=1;
			}
		dx+=fx[pla[id].h][pla[id].f].x;
		dy+=fx[pla[id].h][pla[id].f].y;
		dz+=fx[pla[id].h][pla[id].f].z;
	}
	return ;
}
```
### Substask6：23%
子弹攻击和激光攻击本质上还是一样的，都是dfs。由于判断打击哪一个无人机的时候是按顺序枚举的，所以不用担心当多个无人机位于同一格点的时候需要打击编号较小的无人机的特殊要求。
当搜到无人机的时候直接打击，然后return掉就可以了。
```cpp
inline void c_atk(int id)
{
	int dx=pla[id].x+fx[pla[id].h][pla[id].f].x;
	int dy=pla[id].y+fx[pla[id].h][pla[id].f].y;
	int dz=pla[id].z+fx[pla[id].h][pla[id].f].z;
	while(dx<=mxx && dx>=mnx && dy<=mxy && dy>=mny && dz<=mxz && dz>=mnz)
	{
		for(rint i=1;i<=n;++i)
			if(pla[i].x==dx&&pla[i].y==dy&&pla[i].z==dz)
			{
				if(pla[i].zh)continue;
				pla[i].hp-=max(pla[id].atk-pla[i].def,0);
				if(pla[i].hp<=0)pla[i].hp=0,pla[i].zh=1;
				return ;
			}
		dx+=fx[pla[id].h][pla[id].f].x;
		dy+=fx[pla[id].h][pla[id].f].y;
		dz+=fx[pla[id].h][pla[id].f].z;
	}
	return ;
}
```
放一下全代码：（不要在意mdf拼错了的细节……）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<cmath>
#include<algorithm>
#define read(A) A=init()
#define rint register int
#define inf 0x7fffffff
using namespace std;
inline int init()
{
	int a=0,b=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')b=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){a=(a<<3)+(a<<1)+ch-'0';ch=getchar();}
	return a*b;
}
int n,t,map[2];
int mxx=-inf,mnx=inf,mxy=-inf,mny=inf,mxz=-inf,mnz=inf;
struct node{
	int atk,def;int mat,maf;int fix,hp;
	int f,h;int x,y,z;bool zh;char con[103];
}pla[103];
struct node2{int x,y,z;}fx[5][8]=
{
	(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1}, 
	(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1},(node2){0,0,-1},
	
	(node2){1,0,-1}, (node2){1,1,-1},  (node2){0,1,-1}, (node2){-1,1,-1},
	(node2){-1,0,-1},(node2){-1,-1,-1},(node2){0,-1,-1},(node2){1,-1,-1},
	
	(node2){1,0,0}, (node2){1,1,0},  (node2){0,1,0}, (node2){-1,1,0}, 
	(node2){-1,0,0},(node2){-1,-1,0},(node2){0,-1,0},(node2){1,-1,0},
	
	(node2){1,0,1}, (node2){1,1,1},  (node2){0,1,1}, (node2){-1,1,1}, 
	(node2){-1,0,1},(node2){-1,-1,1},(node2){0,-1,1},(node2){1,-1,1},
	
	(node2){0,0,1},(node2){0,0,1},(node2){0,0,1},(node2){0,0,1}, 
	(node2){0,0,1},(node2){0,0,1},(node2){0,0,1},(node2){0,0,1}
};
inline void go_front()
{
	for(rint i=1;i<=n;++i)
	{
		if(pla[i].zh)continue;
		pla[i].x+=fx[pla[i].h][pla[i].f].x;
		pla[i].y+=fx[pla[i].h][pla[i].f].y;
		pla[i].z+=fx[pla[i].h][pla[i].f].z;
		mxx=max(mxx,pla[i].x);mnx=min(mnx,pla[i].x);
		mxy=max(mxy,pla[i].y);mny=min(mny,pla[i].y);
		mxz=max(mxz,pla[i].z);mnz=min(mnz,pla[i].z);
	}
	return ;
}
inline void c_up(int id){if(pla[id].h>=4)return ;pla[id].h++;}
inline void c_down(int id){if(pla[id].h<=0)return ;pla[id].h--;}
inline void c_left(int id){if(pla[id].f==7)pla[id].f=0;else pla[id].f++;return ;}
inline void c_right(int id){if(pla[id].f==0)pla[id].f=7;else pla[id].f--;return ;}
inline void c_fix(int id){pla[id].hp+=pla[id].fix;return ;}
inline void c_mat(int id)
{
	int dx=pla[id].x+fx[pla[id].h][pla[id].f].x;
	int dy=pla[id].y+fx[pla[id].h][pla[id].f].y;
	int dz=pla[id].z+fx[pla[id].h][pla[id].f].z;
	while(dx<=mxx && dx>=mnx && dy<=mxy && dy>=mny && dz<=mxz && dz>=mnz)
	{
		for(rint i=1;i<=n;++i)
			if(pla[i].x==dx&&pla[i].y==dy&&pla[i].z==dz)
			{
				if(pla[i].zh)continue;
				pla[i].hp-=max(pla[id].mat-pla[i].maf,0);
				if(pla[i].hp<=0)pla[i].hp=0,pla[i].zh=1;
			}
		dx+=fx[pla[id].h][pla[id].f].x;
		dy+=fx[pla[id].h][pla[id].f].y;
		dz+=fx[pla[id].h][pla[id].f].z;
	}
	return ;
}
inline void c_atk(int id)
{
	int dx=pla[id].x+fx[pla[id].h][pla[id].f].x;
	int dy=pla[id].y+fx[pla[id].h][pla[id].f].y;
	int dz=pla[id].z+fx[pla[id].h][pla[id].f].z;
	while(dx<=mxx && dx>=mnx && dy<=mxy && dy>=mny && dz<=mxz && dz>=mnz)
	{
		for(rint i=1;i<=n;++i)
			if(pla[i].x==dx&&pla[i].y==dy&&pla[i].z==dz)
			{
				if(pla[i].zh)continue;
				pla[i].hp-=max(pla[id].atk-pla[i].def,0);
				if(pla[i].hp<=0)pla[i].hp=0,pla[i].zh=1;
				return ;
			}
		dx+=fx[pla[id].h][pla[id].f].x;
		dy+=fx[pla[id].h][pla[id].f].y;
		dz+=fx[pla[id].h][pla[id].f].z;
	}
	return ;
}
int main()
{
	read(n),read(t);
	for(rint i=1;i<=n;++i)
	{
		read(pla[i].x),read(pla[i].y),read(pla[i].z);
		read(pla[i].h),read(pla[i].f);
		read(pla[i].atk),read(pla[i].def);
		read(pla[i].mat),read(pla[i].maf);
		read(pla[i].hp),read(pla[i].fix);
		scanf("%s",pla[i].con);
		mxx=max(mxx,pla[i].x);mnx=min(mnx,pla[i].x);
		mxy=max(mxy,pla[i].y);mny=min(mny,pla[i].y);
		mxz=max(mxz,pla[i].z);mnz=min(mnz,pla[i].z);
	}
	for(rint i=0;i<t;++i)
	{
		go_front();
		for(rint j=1;j<=n;++j)
		{
			if(pla[j].zh)continue;
			switch(pla[j].con[i])
			{
				case 'U':c_up(j);break;
				case 'D':c_down(j);break;
				case 'L':c_left(j);break;
				case 'R':c_right(j);break;
				case 'F':c_fix(j);break;
				case 'M':c_mat(j);break;
				case 'A':c_atk(j);break;
			}
		}
	}
	for(rint i=1;i<=n;++i)
		printf("%d %d %d %d\n",pla[i].x,pla[i].y,pla[i].z,pla[i].hp);
	return 0;
}
```

---

## 作者：huangxianghui (赞：1)

~~话说最近总是在颓大模拟呢~~

码风不好请见谅，正题来了
## Solution
这道题其实还算好做，~~比起猪国杀鸭棋那不是一般的好做~~，讲一下操作

tip：行动前一定要先向前移动，并且坠毁了的飞机是不能动的

上下左右转向：

这里建议直接打表，不要if语句满天飞

就像下面这样
```
int dx[8][5]= {{0,1,1,1,0},{0,1,1,1,0},{0,0,0,0,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0},{0,0,0,0,0},{0,1,1,1,0}};
int dy[8][5]= {{0,0,0,0,0},{0,1,1,1,0},{0,1,1,1,0},{0,1,1,1,0},{0,0,0,0,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0}};
int dz[8][5]= {{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1}};

```
然后加的时候就可以直接取坐标加了
```
plane[j].x+=dx[plane[j].f][plane[j].h];
plane[j].y+=dy[plane[j].f][plane[j].h];
plane[j].z+=dz[plane[j].f][plane[j].h];
```
然后转向的时候就可以$f$，$h$直接加加减减，没有太大问题

子弹/激光：

这里使用一个极其暴力的方法：复制下当前飞机的坐标，然后~~让子弹飞~~让子弹和激光沿飞机当前方向飞。由于判定当前位置是否有飞机太麻烦，我们可以直接枚举每架飞机是否在当前位置，被打到扣血。

这里三点注意：

1. 飞机有防御值和攻击值，如果两个相减小于零相当于没受伤，不要当治疗弹打出去

2. 子弹打到之后消失，激光打到后不消失

3. 不能打到自己，所以子弹/激光初始位置要先往前一格

另外，题目里这么写
> **如果多架飞机处于同一位置，那么只有编号最小的飞机会受到伤害。**

我们从小到大枚举飞机，被子弹打到的一定是编号最小的。

为什么没有'N'？~~你就当无人机上[有个幽幽子吃了个麻薯](https://www.luogu.com.cn/problem/P4872)（逃）~~

新鲜出炉的代码贴出来
```
#include<bits/stdc++.h>
#define ll long long
#define f(i,a,b) for (ll i=a;i<=b;i++)
#define fx(i,a,b) for (ll i=a;i>=b;i--)
using namespace std;
int n,t;
struct node
{
	int atk,def,mat,mdf,fix;
	int hp,x,y,z,f,h;
	string s;
	bool dead;
} plane[101];
inline ll read()
{
	ll l=0,f=1;
	char c;
	while (!isdigit(c=getchar())) if (c=='-') f=-1;
	while (isdigit(c)) l=(l<<3)+(l<<1)+(c^48),c=getchar();
	return l*f;
}
int dx[8][5]= {{0,1,1,1,0},{0,1,1,1,0},{0,0,0,0,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0},{0,0,0,0,0},{0,1,1,1,0}};
int dy[8][5]= {{0,0,0,0,0},{0,1,1,1,0},{0,1,1,1,0},{0,1,1,1,0},{0,0,0,0,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0},{0,-1,-1,-1,0}};
int dz[8][5]= {{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1},{-1,-1,0,1,1}};//坐标打表
signed main()
{
	n=read(),t=read();
	f(i,1,n)
	{
		plane[i].x=read(),plane[i].y=read(),plane[i].z=read();
		plane[i].h=read(),plane[i].f=read();
		plane[i].atk=read(),plane[i].def=read(),plane[i].mat=read(),plane[i].mdf=read();
		plane[i].hp=read(),plane[i].fix=read(),cin>>plane[i].s;
	}//输入
	f(i,1,t)
	{
		f(j,1,n)
		{
			if (!plane[j].dead)//坠毁了不能动
			{
				plane[j].x+=dx[plane[j].f][plane[j].h];
				plane[j].y+=dy[plane[j].f][plane[j].h];
				plane[j].z+=dz[plane[j].f][plane[j].h];
			}//行动前先往前移动
		}
		f(j,1,n)
		{
			if (!plane[j].dead)
			{
				switch (plane[j].s[i-1])
				{
					case 'N':
						break;//幽幽子吃麻薯
					case 'F':
						plane[j].hp+=plane[j].fix;//修复加血
						break;
					case 'L':
						plane[j].f++;
						if (plane[j].f==8) plane[j].f=0;
						break;
					case 'R':
						plane[j].f--;
						if (plane[j].f==-1) plane[j].f=7;
						break;
					case 'U':
						plane[j].h++;
						if (plane[j].h==5) plane[j].h=4;
						break;
					case 'D':
						plane[j].h--;
						if (plane[j].h==-1) plane[j].h=0;
						break;//上下左右转向
					case 'A':
					{
						int x=plane[j].x,y=plane[j].y,z=plane[j].z;
						x+=dx[plane[j].f][plane[j].h],y+=dy[plane[j].f][plane[j].h],z+=dz[plane[j].f][plane[j].h];//调节初始位置
						while (x>=-200 && x<=200 && y>=-200 && y<=200 && z>=-200 && z<=200)//子弹/激光边界判定
						{
							bool ppp=0;
							f(l,1,n)
							{
								if (!plane[l].dead)//不要鞭尸
								{
									if (x==plane[l].x && y==plane[l].y && z==plane[l].z)
									{
										int num=plane[j].atk-plane[l].def;
										if (num<0) num=0;//根据防御与攻击扣血
										plane[l].hp-=num,ppp=1;
										if (plane[l].hp==0) plane[l].dead=1;
										break;//打完子弹消失
									}
								}
							}
							if (ppp) break;
							x+=dx[plane[j].f][plane[j].h],y+=dy[plane[j].f][plane[j].h],z+=dz[plane[j].f][plane[j].h];//向前移动
						}
						break;
					}
					case 'M':
					{
						int x=plane[j].x,y=plane[j].y,z=plane[j].z;
						x+=dx[plane[j].f][plane[j].h],y+=dy[plane[j].f][plane[j].h],z+=dz[plane[j].f][plane[j].h];
						while (x>=-200 && x<=200 && y>=-200 && y<=200 && z>=-200 && z<=200)
						{
							f(l,1,n)
							{
								if (!plane[l].dead)
								{
									if (x==plane[l].x && y==plane[l].y && z==plane[l].z)
									{
										int num=plane[j].mat-plane[l].mdf;
										if (num<0) num=0;
										plane[l].hp-=num;
										if (plane[l].hp==0) plane[l].dead=1;
									}//打完激光不消失
								}
							}
							x+=dx[plane[j].f][plane[j].h],y+=dy[plane[j].f][plane[j].h],z+=dz[plane[j].f][plane[j].h];
						}
						break;
					}
				}
			}
		}
	}
	f(i,1,n) printf("%d %d %d %d\n",plane[i].x,plane[i].y,plane[i].z,plane[i].hp);
	return 0;
}
```

另外，数据貌似有点水：
```
case 'M':
					{
						int x=plane[j].x,y=plane[j].y,z=plane[j].z;
						x+=dx[plane[j].f][plane[j].h],y+=dy[plane[j].f][plane[j].h],z+=dz[plane[j].f][plane[j].h];
						while (x>=-200 && x<=200 && y>=-200 && y<=200 && z>=-200 && z<=200)
						{
							f(l,1,n)
							{
								if (!plane[l].dead)
								{
									if (x==plane[l].x && y==plane[l].y && z==plane[l].z)
									{
										int num=plane[j].mat-plane[l].mdf;
										if (num<0) num=0;
										plane[l].hp-=num;
										if (plane[l].hp==0) plane[l].dead=1;
										break;//我这里一不小心让激光只打了一个位置上的一架飞机，但仍然AC，数据可能没有让两架飞机在同一位置上
									}
								}
							}
							x+=dx[plane[j].f][plane[j].h],y+=dy[plane[j].f][plane[j].h],z+=dz[plane[j].f][plane[j].h];
						}
						break;
					}
```



---

## 作者：chenxinyang2006 (赞：0)

其实就是一道比较麻烦的模拟，一个部分一个部分讲。

subtask1：

需要判移动、是否坠毁（这个可能不用）

移动建议打表，注意不要打错。

```
#include <cstdio>
int n,t;
int x[8][5] =
{
0,1,1,1,0,
0,1,1,1,0,
0,0,0,0,0,
0,-1,-1,-1,0,
0,-1,-1,-1,0,
0,-1,-1,-1,0,
0,0,0,0,0,
0,1,1,1,0
};

int y[8][5] =
{
0,0,0,0,0,
0,1,1,1,0,
0,1,1,1,0,
0,1,1,1,0,
0,0,0,0,0,
0,-1,-1,-1,0,
0,-1,-1,-1,0,
0,-1,-1,-1,0
};

int z[8][5] = 
{
-1,-1,0,1,1,
-1,-1,0,1,1,
-1,-1,0,1,1,
-1,-1,0,1,1,
-1,-1,0,1,1,
-1,-1,0,1,1,
-1,-1,0,1,1,
-1,-1,0,1,1
};

struct node{
    int x,y,z,h,f,atk,def,mtk,mdf,hp,fix,live;
    char str[105];
}arr[105];

int main(){
	char ch;
    scanf("%d%d",&n,&t);
    for(int i = 1;i <= n;i++){
    	scanf("%d%d%d%d%d%d%d%d%d%d%d %s",&arr[i].x,&arr[i].y,&arr[i].z,&arr[i].h,&arr[i].f,&arr[i].atk,&arr[i].def,&arr[i].mtk,&arr[i].mdf,&arr[i].hp,&arr[i].fix,arr[i].str);
    }
    for(int i = 1;i <= t;i++){
    	for(int j = 1;j <= n;j++){
    		if(arr[j].hp > 0){//先移动，在进行操作
    			arr[j].x += x[arr[j].f][arr[j].h];
                arr[j].y += y[arr[j].f][arr[j].h];
                arr[j].z += z[arr[j].f][arr[j].h];
    		}
    	}    
    	for(int j = 1;j <= n;j++){
            if(arr[i].hp > 0){
                //后面的代码全部加在这里
            }
	}   
    }
    for(int i = 1;i <= n;i++){
    	printf("%d %d %d ",arr[i].x,arr[i].y,arr[i].z);
    	if(arr[i].hp < 0){
            printf("0\n");
    	}else{
            printf("%d\n",arr[i].hp);
    	}
    }
	return 0;
}
```
subtask2~4：

需要支持四方向转向，修复。

其实subtask1拿到以后，这些都是送的

```cpp
if(arr[j].str[i] == 'F'){
   arr[j].hp += arr[j].fix;
}
if(arr[j].str[i] == 'L'){
   arr[j].f = (arr[j].f + 1) % 8;
}
if(arr[j].str[i] == 'R'){
   arr[j].f = (arr[j].f + 7) % 8;
}
if(arr[j].str[i] == 'U'){
   if(arr[j].h != 4){
       arr[j].h++;
   }
}
if(arr[j].str[i] == 'D'){
   if(arr[j].h != 0){
        arr[j].h--;
   }
}
```

subtask5:

支持激光

这部分其实有两种做法，一种是1~n扫一遍，判断子弹x坐标和i架飞机相同需要的时间，是否和y坐标相遇时间，z坐标相遇时间一样。如果一样，判定此飞机被击中。（如果相遇时间都是0，那么不算击中）

但是这个做法思维难度较大，所以我们可以计算出子弹飞行到的每一个点，扫一遍1~n，判断是否击中。当abs(x) > 200 or abs(y) > 200 or abs(z) > 200，子弹就必然不会命中目标（起始坐标绝对值<100，每个回合在一维上最多增加1，一共不会超过100 + 1 * 100 = 200）

本方法时间复杂度较高，每一次最多会到200 * 100次循环。如果出题人毒瘤会被卡，但是本题可过。

下面是方法二代码：

```cpp
if(arr[j].str[i] == 'M'){
    int lx = arr[j].x;
    int ly = arr[j].y;
    int lz = arr[j].z;
    while(abs(lx) <= 200 && abs(ly) <= 200 && abs(lz) <= 200){
        lx += x[arr[j].f][arr[j].h];
        ly += y[arr[j].f][arr[j].h];
        lz += z[arr[j].f][arr[j].h];
        for(int k = 1;k <= n;k++){
            if(lx == arr[k].x && ly == arr[k].y && lz == arr[k].z){
                if(arr[j].mtk - arr[k].mdf > 0){
                	arr[k].hp -= (arr[j].mtk - arr[k].mdf);
				}
			}
		}
	}
}
```

subtask6：

支持子弹操作。

对于方法二，这个和激光没什么区别，碰到第一个hp>0的就直接判定它受伤，然后退出循环即可。

但是对于方法一，需要扫一遍取一个击中时间最小的值（不能为0），然后判定它受伤害。（时间一样就取编号小的）

依然只有方法二的代码（因为我比赛时写的方法二）：
```cpp
if(arr[j].str[i] == 'A'){
    int lx = arr[j].x;
    int ly = arr[j].y;
    int lz = arr[j].z;
    int fl = 0;
    while(abs(lx) <= 200 && abs(ly) <= 200 && abs(lz) <= 200){
        lx += x[arr[j].f][arr[j].h];
        ly += y[arr[j].f][arr[j].h];
        lz += z[arr[j].f][arr[j].h];
        for(int k = 1;k <= n;k++){
            if(lx == arr[k].x && ly == arr[k].y && lz == arr[k].z && arr[k].hp > 0){
                if(arr[j].atk - arr[k].def > 0){
                	arr[k].hp -= (arr[j].atk - arr[k].def);
                }
				fl = 1;
                break;
			}
		}
	    if(fl){
			break;
		}
	}
}   
```


---

## 作者：Ludo (赞：0)

# 这是一道膜你题

还是有做的价值的 **好评** 

不过数据有点水 对数据表示海星

比赛的时候不管三七二十一一直调 还是不行

吃了个饭然后搞了一下就A了 还是太弱了 qAq

这道题最难的部分当然是激光和子弹啦~

这里面的子问题是检查**是否有东西在你正前方**

有两个方法

一个是**直接模拟移动** 不过我感jio比较烦 没有用

还有一个问题就是如果飞机的坐标较大 那么不适用于这种状况

第二是根据**坐标的变化判断是否符合坐标增量**

[例如：向正前方走一步$(1,0,-1)$,你现在位于$(0,7,3)$,一辆未确认飞机的坐标是$(3,7,1)$,那么x,y,z轴分别增加了$2,0,-2$。据此判断，这辆飞机就在我的正前方]

想法

1. 建立check函数

2. 检查是否应该相等 1,0,-1 则三个数的比例应为1：0：-1

```cpp
建立equalcheck函数，检查数的相等关系

建立pncheck函数，检查数的正负关系
```


## 代码

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
using namespace std;
const double eps=1e-5;
//此为打表部分
int h[5]={-1,-1,0,1,1}; //z轴增量 根据h变化
int p1[8][5]= //x轴增量
{
{0,1,1,1,0},
{0,1,1,1,0},
{0,0,0,0,0},
{0,-1,-1,-1,0},
{0,-1,-1,-1,0},
{0,-1,-1,-1,0},
{0,0,0,0,0},
{0,1,1,1,0}
};
int p2[8][5]= //y轴增量
{
{0,0,0,0,0},
{0,1,1,1,0},
{0,1,1,1,0},
{0,1,1,1,0},
{0,0,0,0,0},
{0,-1,-1,-1,0},
{0,-1,-1,-1,0},
{0,-1,-1,-1,0}
};
//End坐标增量打表
struct pl
{
	int x,y,z,h,f,atk,def,mat,mdf,hp,fix;
	bool died;string s;
}plane[101]; //建立一个结构体 储存各种资料
int n,t;
void moveall() //移动
{
	for (int i=1;i<=n;i++)
	{
		if (plane[i].died==false) //不要忘记细节
		{
			plane[i].x=plane[i].x+p1[plane[i].f][plane[i].h];
			plane[i].y=plane[i].y+p2[plane[i].f][plane[i].h];
			plane[i].z=plane[i].z+h[plane[i].h];
		}
	}
}
bool equalcheck(int x,int y,int z,int hee,int f)
{
	//检查坐标增量零变化情况
	if (p1[f][hee]==0&&x!=0) return false;
	if (p2[f][hee]==0&&y!=0) return false;
	if (h[hee]==0&&z!=0) return false;
    //检查是否应该相等 用abs避免出现负数 可以分开检查
    //可能有些不必要的语句 就是作以防万一之用
	if (abs(p1[f][hee])==abs(p2[f][hee]))
	{
		if (abs(x)!=abs(y)) return false;
		if (abs(p2[f][hee])==1&&abs(x)==0) return false; 
		if (abs(p2[f][hee])==0&&abs(x)!=0) return false;
	}
	if (abs(p2[f][hee])==abs(h[hee]))
	{
		if (abs(y)!=abs(z)) return false;
		if (abs(p2[f][hee])==1&&abs(y)==0) return false;
		if (abs(p2[f][hee])==0&&abs(y)!=0) return false;	
	}
	if (abs(p1[f][hee])==abs(h[hee]))
	{
		if (abs(x)!=abs(z)) return false;
		if (abs(h[hee])==1&&abs(x)==0) return false;
		if (abs(h[hee])==0&&abs(z)!=0) return false;
	}
	return true;
}
bool pncheck(int x,int y,int z,int hee,int f)
{
	//如果坐标增量为负，那么实际坐标增量也应该是负数
	if (p1[f][hee]>0) 
	{
		if (!(x>0)) return false;		
	}
	else if (p1[f][hee]<0)
	{
		if (!(x<0)) return false;
	}
	if (p2[f][hee]>0)
	{
		if (!(y>0)) return false;		
	}
	else if (p2[f][hee]<0)
	{
		if (!(y<0)) return false;
	}if (h[hee]>0)
	{
		if (!(z>0)) return false;		
	}
	else if (h[hee]<0)
	{
		if (!(z<0)) return false;
	}
	return true;
}
int checker(int x,int y,int z,int hee,int f)
{
	bool flag=true;
	bool s1=equalcheck(x,y,z,hee,f);
	if (s1==false) return false;
	bool s2=pncheck(x,y,z,hee,f);
	if (s2==false) return false;
	return flag;
}
void lazer(int num)
{
	for (int i=1;i<=n;i++)
		if (i!=num)
			if (plane[i].died==false&&checker(plane[i].x-plane[num].x,plane[i].y-plane[num].y,plane[i].z-plane[num].z,plane[num].h,plane[num].f)) //目标没有坠毁那么检查坐标变化
			{
				if (plane[num].mat-plane[i].mdf>0) //题目要求飞机的激光攻击力必须大于目标飞机的激光防御值
				{
					plane[i].hp-=plane[num].mat-plane[i].mdf;
					if (plane[i].hp<=0) plane[i].died=true;//hp小于等于0 应标记为坠毁
				}
			}
}
double ou(int x1,int x2,int y1,int y2,int z1,int z2)//求两坐标距离
{
	return sqrt(pow(x1-x2,2)+pow(y1-y2,2)+pow(z1-z2,2));
}
void gun(int num)
{
	double mini=999999;
	for (int i=1;i<=n;i++)
	{
		if (i!=num)
		{
			if (plane[i].died==false&&checker(plane[i].x-plane[num].x,plane[i].y-plane[num].y,plane[i].z-plane[num].z,plane[num].h,plane[num].f))
			{
				//cout<<i<<' '; 
				mini=min(mini,ou(plane[num].x,plane[i].x,plane[num].y,plane[i].y,plane[num].z,plane[i].z));
			}
		}
	}//找出符合条件的最小距离
	//cout<<endl;
	for (int i=1;i<=n;i++)
	{
		if (i!=num)
		{
			if (plane[i].died==false&&checker(plane[i].x-plane[num].x,plane[i].y-plane[num].y,plane[i].z-plane[num].z,plane[num].h,plane[num].f)&&abs(mini-ou(plane[num].x,plane[i].x,plane[num].y,plane[i].y,plane[num].z,plane[i].z))<=eps) //枚举 从小到大 可以保证攻击对象编号最小 顺便核对最小距离
			{
				if (plane[num].atk-plane[i].def>0) //题目要求飞机的子弹攻击力必须大于目标飞机的子弹防御值
				{
					//cout<<i<<' ';cout<<endl<<endl<<endl;
					plane[i].hp-=plane[num].atk-plane[i].def;
					if (plane[i].hp<=0) plane[i].died=true;
				}
				return; //找到了目标 返回 不再寻找
			}
		}
	}
	

}
int main(void)
{
	cin>>n>>t;
	for (int i=1;i<=n;i++)
	{
		plane[i].died=false;
		cin>>plane[i].x>>plane[i].y>>plane[i].z>>plane[i].h>>plane[i].f>>plane[i].atk>>plane[i].def>>plane[i].mat>>plane[i].mdf>>plane[i].hp>>plane[i].fix>>plane[i].s; 
	}
	for (int i=0;i<t;i++) //在每一个时刻
	{
		moveall(); //对每辆无人机操作，先移动
		for (int j=1;j<=n;j++) //对每辆无人机操作，后操作
		{
			if (plane[j].hp<=0) plane[j].died=true; //以防万一 判断一下坠毁了没有
			if (plane[j].s[i]=='N'||plane[j].died==true) continue;//N不做事，坠机了做不了
			if (plane[j].s[i]=='F') plane[j].hp+=plane[j].fix;//修复，直接增加hp
			if (plane[j].s[i]=='L') plane[j].f=(plane[j].f+1)%8;//循环增量
			if (plane[j].s[i]=='R') plane[j].f=(plane[j].f-1+8)%8;//循环减量
			if (plane[j].s[i]=='U'&&plane[j].h<4) plane[j].h++; //增量 h为4（大于3）时为无效操作
			if (plane[j].s[i]=='D'&&plane[j].h>0) plane[j].h--;//增量 h为0（小于1）时为无效操作
			if (plane[j].s[i]=='M') lazer(j); //lazer激光
			if (plane[j].s[i]=='A') gun(j); //gun子弹
		}
	}
	for (int i=1;i<=n;i++)//输出部分
	{
		cout<<plane[i].x<<' '<<plane[i].y<<' '<<plane[i].z<<' '<<plane[i].hp<<endl;
	}
}
```
## 评价

此题解法自然 多种解法兼存 部分分设置适宜 

适合作为Luogu比赛中的题目

考察了选手的代码能力

谢谢出题人~ ovo

---

## 作者：Irppy3_40 (赞：0)

这道题真的是我做出来最难的模拟题……

------------

以下为正式内容。

这道题思维难度不大，但是细节较多，~~同时还是一道阅读题~~。。。

把容易错的细节讲一下吧：

1. 每一个时间点，先是每一架飞机先向前走一步，然后在进行操作。

1. 已经坠毁的飞机不能移动、执行操作或受到伤害。

1. 当一架飞机受到伤害后，必须时刻判断其是否死亡。

其余提示见代码。

附上AC代码（90行）：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct plane{
	int x,y,z,h,f,atk,def,mat,mdf,hp,fix;
	string d;
	bool alive;
}p[110];
int n,t;
int fx[5][8]={{0,0,0,0,0,0,0,0},{1,1,0,-1,-1,-1,0,1},{1,1,0,-1,-1,-1,0,1},{1,1,0,-1,-1,-1,0,1},{0,0,0,0,0,0,0,0}};
int fy[5][8]={{0,0,0,0,0,0,0,0},{0,1,1,1,0,-1,-1,-1},{0,1,1,1,0,-1,-1,-1},{0,1,1,1,0,-1,-1,-1},{0,0,0,0,0,0,0,0}};
int fz[5][8]={{-1,-1,-1,-1,-1,-1,-1,-1},{-1,-1,-1,-1,-1,-1,-1,-1},{0,0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1}};//打表记录飞机前进的方向
void do_(char op,int k){	//执行各种操作
	if(p[k].alive){			//存活才能执行操作
		switch(op){
			case 'N': {break;}
			case 'U': {p[k].h=min(p[k].h+1,4);break;}
			case 'D': {p[k].h=max(p[k].h-1,0);break;}//h最大为4，最小为0
			case 'L':{
				if(p[k].f==7)p[k].f=0;
				else p[k].f++;//也可以是p[k].f=(p[k].f+1)%8
				break;
			}
			case 'R':{
				if(p[k].f==0)p[k].f=7;
				else p[k].f--;
				break;
			}
			case 'F': {
				p[k].hp+=p[k].fix;
				break;
			}
			case 'A': {//子弹
				int x=p[k].x,y=p[k].y,z=p[k].z;//记录子弹位置
				bool f=0;//是否打中过飞机
				for(register int i=1;i<=2000;i++){
					x+=fx[p[k].h][p[k].f];
					y+=fy[p[k].h][p[k].f];
					z+=fz[p[k].h][p[k].f];//子弹移动
					for(register int j=1;j<=n;j++){
						if(p[j].x==x&&p[j].y==y&&p[j].z==z&&p[j].alive){//其中p[j].alive很容易遗忘
							f=1;//打中了
							p[j].hp-=max(0,p[k].atk-p[j].def);
							if(p[j].hp<=0)p[j].alive=0;//判断是否死亡
						}
					}
					if(f)break;//打中了子弹就会消失
				}
				break;
			}
			case 'M':{//和子弹几乎一样，不同之处在于打中了依然继续
				int x=p[k].x,y=p[k].y,z=p[k].z;
				for(register int i=1;i<=2000;i++){
					x+=fx[p[k].h][p[k].f];
					y+=fy[p[k].h][p[k].f];
					z+=fz[p[k].h][p[k].f];
					for(register int j=1;j<=n;j++){
						if(p[j].x==x&&p[j].y==y&&p[j].z==z&&p[j].alive){
							p[j].hp-=max(0,p[k].mat-p[j].mdf);
							if(p[j].hp<=0)p[j].alive=0;
						}
					}
				}
				break;
			}
		}
	}
}
int main(){
	cin>>n>>t;
	for(register int i=1;i<=n;i++){
		cin>>p[i].x>>p[i].y>>p[i].z>>p[i].h>>p[i].f>>p[i].atk>>p[i].def>>p[i].mat>>p[i].mdf>>p[i].hp>>p[i].fix>>p[i].d;//至今我所写过最壮观的输入
		p[i].alive=1;//飞机一开始都是活的
	}
	for(register int i=0;i<t;i++){
		for(register int j=1;j<=n;j++){
			if(p[j].alive){//活着才能移动
			p[j].x+=fx[p[j].h][p[j].f];
			p[j].y+=fy[p[j].h][p[j].f];
			p[j].z+=fz[p[j].h][p[j].f];
			}
		}
		for(register int j=1;j<=n;j++){
			do_(p[j].d[i],j);
		}
	}
	for(register int i=1;i<=n;i++){//输出
		cout<<p[i].x<<' '<<p[i].y<<' '<<p[i].z<<' '<<p[i].hp<<endl;
	}
	return 0;
} 
```

这是我第一次写题解，求通过qwq

---

## 作者：doyo (赞：0)

一道灰常棒的膜你题

本蒟蒻那天比赛的时候巨颓，拿完这题58分直接拉同机房的同志一起颓大富翁。4个多小时后，才开始写剩下代码。

咳咳 言归正传

那么，对于一般的模拟（码量超100行的，不是很水的那种）

### 最重要的习惯就是！！！

函数宁可多，也不要长

这样自己debug的时候会很舒服，而且这也属于码农的基本素养

于是我们就可以开始愉快的A题了，先建立一个结构体存储飞机的各种状态

首先，这道题的方向描述得比较迷，如题面

	首先，根据f确定x,y方向

	随后，根据h进一步确定方向

	对于h=0或h=4，正前方是正下或正上（x,y不变，z变化）

	对于h=1或h=3，在上面方向的基础上再向下/上移动一格

	对于h=2，正前方为水平方向（x,y如上所述，z不变）
反正代码写出来就是这个样子（本人先对h进行判断）

```cpp
		int dx[8]={1,1,0,-1,-1,-1,0,1};
		int dy[8]={0,1,1,1,0,-1,-1,-1};
		int dz[5]={-1,-1,0,1,1};
		if(!plan[i].h||plan[i].h==4) plan[i].z+=dz[plan[i].h];
		//如果h=0或者h=4的话x,y不变 
		else
		{
			plan[i].x+=dx[plan[i].f];
			plan[i].y+=dy[plan[i].f];
			//当x,y变化时，h不等于2的时候z才有变化 
			if(plan[i].h!=2) plan[i].z+=dz[plan[i].h];
		}
```
然后就是M和A操作了

这里本人使用向量的叉积判断是否共线

如果两个三维向量的叉积为零向量，则两个向量共线

然后判断一下方向，M操作搞定

A操作的话打一个擂台，既然两个向量共线，那么求点积可以代替求距离

这样时间就不可能爆了

代码如下

```cpp
#include<iostream> 
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define il inline 
using namespace std;
const int maxn=105;
const int inf=0x7fffffff;
struct node
{
	int x,y,z;
	int atk,def,mat,mdf,fix;
	int hp,h,f;
	char act[maxn];
	bool die;
}plan[maxn];
int n,t;
int map[maxn][maxn][maxn];
int dx[8]={1,1,0,-1,-1,-1,0,1};
int dy[8]={0,1,1,1,0,-1,-1,-1};
int dz[5]={-1,-1,0,1,1};
il void check(int now)
//判断当前飞机是不是gay gay了 
{
	if(plan[now].hp>0) return;
	plan[now].hp=0;
	plan[now].die=true;
}
il int getdis(node a,node b)
{
	int x1=0,x2=0,x3=0,y1=0,y2=0,y3=0,z1=0,z2=0,z3=0;
	x1=b.x-a.x;
	y1=b.y-a.y;
	z1=b.z-a.z;
	if(!x1&&!y1&&!z1) return -1;//特判一下重合
	if(!a.h||a.h==4) z2=dz[a.h];
	else
	{
		x2=dx[a.f];
		y2=dy[a.f];
		if(a.h!=2) z2=dz[a.h];
	}
	x3=y1*z2-z1*y2;y3=z1*x2-x1*z2;z3=x1*y2-y1*x2;
	//计算向量叉积 
    if(x3||y3||z3) return -1;
    int dis=x1*x2+y1*y2+z1*z2;
    //计算点积 
    if(dis<0) return -1;
    return dis;
}
il void clear()
{
	for(int i=1;i<=n;i++)
	{
		if(plan[i].die) continue;
		check(i);
		if(!plan[i].h||plan[i].h==4) plan[i].z+=dz[plan[i].h];
		//如果h=0或者h=4的话x,y不变 
		else
		{
			plan[i].x+=dx[plan[i].f];
			plan[i].y+=dy[plan[i].f];
			//当x,y变化时，h不等于2的时候z才有变化 
			if(plan[i].h!=2) plan[i].z+=dz[plan[i].h];
		}
	}	
}
il void attack(int now)
{
	int dis,id=0,minn=inf,hur;
	for(int i=1;i<=n;i++)
	{
		if(plan[i].die||i==now) continue;
		dis=getdis(plan[now],plan[i]);
		if(dis==-1) continue;
		if(dis<minn) minn=dis,id=i;
	}
	if(id==inf) return;
	hur=max(0,plan[now].atk-plan[id].def);
	//这里注意一下护甲值大于攻击力的情况，magic也是一样 
	plan[id].hp-=hur;
	check(id);
}
il void magic(int now)
{
	int dis,hur;
	for(int i=1;i<=n;i++)
	{
		if(plan[i].die||i==now) continue;
		dis=getdis(plan[now],plan[i]);
		if(dis==-1) continue;
		hur=max(0,plan[now].mat-plan[i].mdf);
		plan[i].hp-=hur;
		check(i);
	}
}
il void change_h(int i,int val)
{
	int nh=plan[i].h+val;
	if(nh>4||nh<0) return;
	plan[i].h=nh;
}
il void change_f(int i,int val)
{
	int nf=plan[i].f+val;
	if(nf==-1) nf=7;
	if(nf==8) nf=0;
	plan[i].f=nf;
}
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)
	{
		//这里怕因为格式的问题过不了，所以把一行超长的scanf截成几个cin 
		cin>>plan[i].x>>plan[i].y>>plan[i].z;
		cin>>plan[i].h>>plan[i].f>>plan[i].atk;
		cin>>plan[i].def>>plan[i].mat>>plan[i].mdf;
		cin>>plan[i].hp>>plan[i].fix;
		scanf("%s",plan[i].act);
	} 
	for(int u=0;u<t;u++)
	{
		clear();
		//处理战场,可以看做是回合制 
		for(int i=1;i<=n;i++)
		{
			if(plan[i].die) continue;
			char ch=plan[i].act[u];
			if(ch=='N') continue;
			if(ch=='U') change_h(i,1);//更改方向 
			if(ch=='D')	change_h(i,-1);
			if(ch=='L') change_f(i,1);
			if(ch=='R') change_f(i,-1);
			if(ch=='F') plan[i].hp+=plan[i].fix;
			if(ch=='A') attack(i);
			if(ch=='M') magic(i);
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d %d %d %d\n",plan[i].x,plan[i].y,plan[i].z,plan[i].hp);
	return 0;
}
```


---

## 作者：rasing_up (赞：0)

**此文核心收到一位大佬（不知名）启发，因不知为何人，在此感谢**

## 刚看到这道题真的是感觉非常~~热血沸腾~~无助！
###### 看不懂...
#### 后来看了下后面题发现都不会做，就又来看这道题了

幸好良心（~~变态~~）出题人给了一张表格
![](https://cdn.luogu.com.cn/upload/pic/71703.png)
因为表里数据比较多，边做边处理太麻烦所以可以先**预处理**（存数组里）
```cpp
int s[5][8][3]=
{
    {
        {0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1}
    },
    {
        {1,0,-1},{1,1,-1},{0,1,-1},{-1,1,-1},{-1,0,-1},{-1,-1,-1},{0,-1,-1},{1,-1,-1}
    },
    {
        {1,0,0},{1,1,0},{0,1,0},{-1,1,0},{-1,0,0},{-1,-1,0},{0,-1,0},{1,-1,0}
    },
    {
        {1,0,1},{1,1,1},{0,1,1},{-1,1,1},{-1,0,1},{-1,-1,1},{0,-1,1},{1,-1,1}
    },
    {
        {0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1}
    }
};
```

**其中第一维是h,第二维是f,第三维就是x,y,z(方位)**
这样便于处理**正方向**
```cpp
x+=s[h][f][0];
y+=s[h][f][1];
z+=s[h][f][2];
```
f:当前水平朝向(范围0-7)
h:竖直朝向(范围0-4)
(如果f,h对应的是什么都不知道的话，你可以去P1000大佬区了)

题中代码中用到 goto
像我一样的蒟蒻看[这里](https://blog.csdn.net/hankai1024/article/details/8011306)
感谢[博主](https://blog.csdn.net/hankai1024)

如有不明白可自行百度

话不多说 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;                  
int a[205][15];//大佬们用的都是结构体，用结构体确实会方便不少
int vis[105][105][105];
char ch[205][205];
int s[5][8][3]=
{
    {
        {0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1},{0,0,-1}
    },
    {
        {1,0,-1},{1,1,-1},{0,1,-1},{-1,1,-1},{-1,0,-1},{-1,-1,-1},{0,-1,-1},{1,-1,-1}
    },
    {
        {1,0,0},{1,1,0},{0,1,0},{-1,1,0},{-1,0,0},{-1,-1,0},{0,-1,0},{1,-1,0}
    },
    {
        {1,0,1},{1,1,1},{0,1,1},{-1,1,1},{-1,0,1},{-1,-1,1},{0,-1,1},{1,-1,1}
    },
    {
        {0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1}
    }
};
int main(){
	int n,t;
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=11;j++)
		  cin>>a[i][j];
	    cin>>ch[i];
	    a[i][12]=1;
//a[i][1~11]分别对应题中的各个参量
//a[i][12] 表示这架飞机是否死亡 1为活着 0为死亡
	}
	for(int k=0;k<t;k++){
	  for(int i=1;i<=n;i++)
	  {
	  	a[i][1]+=s[a[i][4]][a[i][5]][0];
		a[i][2]+=s[a[i][4]][a[i][5]][1];
		a[i][3]+=s[a[i][4]][a[i][5]][2];
	  }
	  for(int i=1;i<=n;i++)//4 h  5 f 
	  {
		
		if(!a[i][12]||ch[i][k]=='N') continue;//如果已经坠毁或这次无操作就continue
		else if(ch[i][k]=='F'){//回血
		a[i][10]+=a[i][11];
		}
		else if(ch[i][k]=='L'){//若为上限则重载（循环  0，1，2，3，4，5，6，7，0，1  ……）
			if(a[i][5]==7) 
			  a[i][5]=0;
			else
			  a[i][5]++;
		}
		else if(ch[i][k]=='R'){//同上
			if(a[i][5]==0)
			  a[i][5]=7;
			else
			  a[i][5]--;
		}
		else if(ch[i][k]=='U'){//U/D 与L/R 不同 ，超过范围就为无效操作
			if(a[i][4]<4)
			  a[i][4]++;
		}
		else if(ch[i][k]=='D'){//同上
			if(a[i][4]>0)
			  a[i][4]--;
		}
		else if(ch[i][k]=='M'){
                int sum=0;//判断向前移动了几次。
                int xx=a[i][1],yy=a[i][2],zz=a[i][3];//记录当前飞机方位
                there2: xx+=s[a[i][4]][a[i][5]][0];//以下模拟移动
                yy+=s[a[i][4]][a[i][5]][1];
                zz+=s[a[i][4]][a[i][5]][2];
                sum++;//移动次数加1
                for(register int k=1;k<=n;++k){
                    if(!a[k][12]) continue;//如果飞机死亡
                    if(a[k][1]==xx&&a[k][2]==yy&&a[k][3]==zz){
                        int sh=a[i][8]-a[k][9];
                        if(sh>0){//如果差值为正数才有伤害
                            a[k][10]-=sh;
                            if(a[k][10]<=0){
                                a[k][12]=0;
                                a[k][11]=0;
                            }
                        }
                    }
                    if(sum>=100) break;//继续
                }
                if(sum<100) goto there2;//回到there2处（个人理解为变异的while循环）
            }
            else if(ch[i][k]=='A'){//子弹
                int sum=0;
                bool f=0;//判断有没有打到一架飞机
                int xx=a[i][1],yy=a[i][2],zz=a[i][3];
                there: xx+=s[a[i][4]][a[i][5]][0];//同上
                yy+=s[a[i][4]][a[i][5]][1];
                zz+=s[a[i][4]][a[i][5]][2];
                sum++;//移动次数加一
                for(int k=1;k<=n;++k){
                    if(!a[k][12]) continue;//如果当前这架飞机坠毁了，就continue
                    if(a[k][1]==xx&&a[k][2]==yy&&a[k][3]==zz){//如果当前到达了一架没有坠毁的飞机
                        f=1;//打到了，qwq;
                        int sh=a[i][6]-a[k][7];//计算伤害
                        if(sh>0){//扣除血量
                            a[k][10]-=sh;
                            if(a[k][10]<0){//因为坠毁的飞机最后输出时血量为0直接改成0
                                a[k][10]=0;
                                a[k][12]=0;//坠毁
                            }
                        }
                        break;//跳出循坏
                    }
                    if(sum>=100) f=1;//如果进行了100次以上的操作就直接跳出，卡数据
                }
                if(!f) goto there;//如果还没有打到就再移动
            }
	   }
			
	}

	for(int i=1;i<=n;i++){
		cout<<a[i][1]<<" "<<a[i][2]<<" "<<a[i][3]<<" "<<a[i][10]<<endl; 
	}
	return 0;
}
```
**码风粗陋，多多包涵**


---


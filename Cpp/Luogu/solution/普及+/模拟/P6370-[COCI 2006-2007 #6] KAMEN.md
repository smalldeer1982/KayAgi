# [COCI 2006/2007 #6] KAMEN

## 题目描述

在一个 $r\times c$ 的方阵里，有些点是 `.`，表示为空；有些点是 `X`，表示这里是一堵墙。

我们可以认为这个方阵在竖直方向放置。

有一个人在这 $c$ 列的第一行会抛下 $n$ 块石头，用 `O` 来表示。如果这一个石头由于重力作用会向下滚动。具体来说，就是会从第一行向最后一行滚动，规则如下：

- 如果下一个格子是空格，那么向下运动一格。
- 如果下一个格子是墙或者已经到了第 $r$ 行，则停止滚动并停在原处。
- 如果下一个格子是一块停止的石头，则如果在左侧和左下方为空格时首选滚动到左侧的那一行，否则如果右侧和右下方为空格，则滚动到右侧的那一行。如果两侧都不为空，则石头静止不在移动。

只有前一块石头永久静止后，下一块石头才会被抛下。

请你输出最终方阵的状态。




## 说明/提示

#### 样例 1 解释

$4$ 块石头依次在第一列被抛下。第一块石头被唯一一堵墙堵住。这样剩下的石头都可以向右滚动一列。第二块石头毫无障碍地下落，第三四块分别落在了它的左边和右边。

#### 数据规模与约定

- 对于 $60\%$ 的数据，保证 $r\le 30$。
- 对于 $100\%$ 的数据，保证 $1\le r\le 3\times 10^4$，$1\le c\le 30$，$1\le n\le 10^5$。
#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T4 KAMEN***。

## 样例 #1

### 输入

```
5 4
....
....
X...
....
....
4
1
1
1
1```

### 输出

```
....
O...
X...
....
OOO.```

## 样例 #2

### 输入

```
7 6
......
......
...XX.
......
......
.XX...
......
6
1
4
4
6
4
4```

### 输出

```
......
...O..
...XX.
......
.OO...
.XX...
O..O.O```

# 题解

## 作者：xiaolilsq (赞：10)

[题目链接](https://www.luogu.com.cn/problem/P6370)

刚开始看到这道题目没有任何思路，但是如果知道一个性质这题就很好做了：**如果从第$x$列下落的路径为$a_1\dots a_y$，那么经过若干轮后，必然只有后面经过的一段连续路径会被石子覆盖**。

考虑反证法，如果存在一个$t$，使得$a_t$被石子覆盖而$a_{t+1}$没有被覆盖，那么由于可以从$a_t$下落到$a_{t+1}$，$a_{t+1}$必然也被石子覆盖，与假设$a_{t+1}$没有被覆盖相矛盾，所以**经过若干轮后，必然只有后面经过的一段连续路径会被石子覆盖**。

那么我们可以想出一种算法：先保留从每一行下降的路径，进行某行的操作的时候，先把路径被占的部分退回去，然后再寻找一条其他的路径进行下落。

AC代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
template<typename T>void read(T &x){
	x=0;int f(1);char c(getchar());
	for(;!isdigit(c);c=getchar())if(c=='-')f=-f;
	for(; isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)write(x/10),x%=10;
	putchar(x+'0');
}
char map[30005][35];
int sap[35][30005],cn[35],r,c;
void push(int x){//下落函数
	while(true){
		int t=sap[x][cn[x]];
		if(map[cn[x]][t]=='O')--cn[x];//如果被占领则将路径退回
		else if(cn[x]==r)break;//到底了
		else if(map[cn[x]+1][t]=='X')break;//有墙壁不再下落
		else if(map[cn[x]+1][t]=='.')sap[x][++cn[x]]=t;//往下走
		else if(t>1&&map[cn[x]][t-1]=='.'&&map[cn[x]+1][t-1]=='.')sap[x][++cn[x]]=t-1;//往左走
		else if(t<c&&map[cn[x]][t+1]=='.'&&map[cn[x]+1][t+1]=='.')sap[x][++cn[x]]=t+1;//往右走
		else break;//无路可走
	}
	map[cn[x]][sap[x][cn[x]]]='O';//占领最后的格子
}
int main(){
	read(r),read(c);
	for(int i=1;i<=r;++i){//读入
		for(int j=1;j<=c;++j){
			char c=getchar();
			while(c!='X'&&c!='.')
				c=getchar();
			map[i][j]=c;
		}
	}
	for(int j=1;j<=c;++j)
		sap[j][0]=j;//初始每列从该列开始下落
	int n;read(n);
	while(n--){
		int tmp;read(tmp);
		push(tmp);//下落
	}
	for(int i=1;i<=r;++i,putchar('\n'))
		for(int j=1;j<=c;++j)
			putchar(map[i][j])//输出;
	return 0;
}

```
复杂度为什么是对的？其实我也不会证呜呜呜。

希望有大佬可以证明复杂度。


---

## 作者：ReseeCher (赞：4)

首先考虑暴力怎么做。

对于一个位置，

- 如果下面有障碍物，就按照题意判断平移或者静止；

- 否则下面就是空的，直接移动到下面第一个障碍物的上一格

---

观察发现，每个石头和上一个从同一列抛下的石头的运动轨迹有很大一部分是重合的。

#### 性质：重合的路径是一段前缀


    
证明：

若某时刻石头在$P_1$ $(x,y)$，那么下一刻只能在$(x+1,y)$，$(x+1,y-1)$，$(x+1,y+1)$中的一个位置$P_2$。

那么如果$P_2$为空，位于$P_1$的石头还是会滑下来，也就是说不可能出现$P_2$能走$P_1$不能走的情况，这样就证明了不能走的一定是一段后缀

---

那么我们考虑对每一列$i$开始的石头分别记录路径，记作队列$A_i$，每次从最后一个能到达的位置开始走。

**复杂度分析**：对于每一列$i$，一个位置出队列时一定是被占据了，不可能再次进入队列，所以顶多是把每个位置都访问一遍

$c*(r*c)$，所以是$O(rc^2)$

实际上做法和第一篇题解是一样的

---

## 作者：Pengzt (赞：4)

[cnblogs](https://www.cnblogs.com/Pengzt/p/17929943.html)

[P6370](https://www.luogu.com.cn/problem/P6370)

暴力是很容易的，可以直接搜索。

发现可以直接对暴力进行优化。每次有一个地方变为 ```O``` 后，重构代价太大，设这个坐标为 $(i, j)$，同时维护一个类型为 ```pair<int, int>``` 的 $to$ 数组表示将球放在第 $i$ 列第一行的时候，最后到达的位置。再用一个 $path_i$ 记录下从第一行第 $i$ 列出发的路径以及一个 $vis_{i, j, k}$ 表示第 $i$ 行第 $j$ 列是否能通过放在第 $k$ 列到达，如果可以，记录的就是再 $path$ 中的下标。然后发现只有 $(i, j)$ 附近的八个格子可能会受影响，剪枝一下，即判断 $(i, j)$ 之前是否在 $(i', j')$ 所经过的路径上即可。这样实际上就是根据路径上的前缀不变对暴力进行的优化。

为什么这样的时间复杂度是对的呢？因为每次 $to_i$ 的行数要么增加 $\Delta$，要么 $-1$，所以均摊下来的时间复杂度就是对的了。

但是这样空间是 $\mathcal{O}(rc^2)$，无法通过。发现每次的 ```O``` 所在的位置一定是所有路径的终点，所以就不用记录 $vis$ 数组了，因为每次操作一定是 $path$ 的栈顶，直接 ```pop``` 即可。

时间复杂度：$\mathcal{O}(rc^2)$。

空间复杂度：$\mathcal{O}(rc)$。

代码：
```cpp
mt19937_64 rng(35);
constexpr int N = 3e4 + 10;
int n, m, q;
int tp[35], pa[35][N];
char ch[N][35];
void work(int x) {
	while(1) {
		int y = pa[x][tp[x]];
		if(ch[tp[x]][y] == 'O') --tp[x];
		else if(tp[x] == n) break;
		else if(ch[tp[x] + 1][y] == 'X') break;
		else if(ch[tp[x] + 1][y] == '.') pa[x][++tp[x]] = y;
		else if(y > 1 && ch[tp[x]][y - 1] == '.' && ch[tp[x] + 1][y - 1] == '.') pa[x][++tp[x]] = y - 1;
		else if(y < m && ch[tp[x]][y + 1] == '.' && ch[tp[x] + 1][y + 1] == '.') pa[x][++tp[x]] = y + 1;
		else break;
	}
	ch[tp[x]][pa[x][tp[x]]] = 'O';
}
int main() {
	ios :: sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			cin >> ch[i][j];
	for(int i = 1; i <= m; ++i)
		pa[i][tp[i] = 0] = i;
	cin >> q;
	for(int qi = 1; qi <= q; ++qi) {
		int x;
		cin >> x;
		work(x);
	}
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= m; ++j)
			cout << ch[i][j];
		cout << "\n";
	}
	return 0;
}
```

---

## 作者：DAI33DAI (赞：4)

列数不多，行数很多。所以只要记录每一列的路径即可，每一个石子就可以一步到位。

石子到位后，只会占据其他路径的终点位置，检查一下所有路径，把终点冲突的路径回退一格往下维护即可。

很容易每次最多只会回退一格，往下最多就是走到了底，最后意会一下就能体会到均摊时间复杂度没有问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int r, c, m;
//存图
char g[30005][35];
//(1,i)为起点的路径，第j个点为(j,path[i][j])
int path[35][30005];
//(1,i)为起点的路径，最后一个点在第lastRow[i]行
int lastRow[35];
//维护路径
void xjb(int ith, int nowX, int nowY)
{
    path[ith][nowX] = nowY;
    while (1)
    {
        if (g[nowX + 1][nowY] == 'X')
            break;
        if (g[nowX + 1][nowY] == '.')
            nowX++;
        else if (g[nowX][nowY - 1] == '.' && g[nowX + 1][nowY - 1] == '.')
            nowX++, nowY--;
        else if (g[nowX][nowY + 1] == '.' && g[nowX + 1][nowY + 1] == '.')
            nowX++, nowY++;
        else
            break;
        path[ith][nowX] = nowY;
    }
    lastRow[ith] = nowX;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> r >> c;
    memset(g, 'X', sizeof(g));
    for (int i = 1; i <= r; i++)
        for (int j = 1; j <= c; j++)
            cin >> g[i][j];
    for (int i = 1; i <= c; i++)
        xjb(i, 1, i);
    cin >> m;
    while (m--)
    {
        int nowC;
        cin >> nowC;
        int toX, toY;
        toX = lastRow[nowC];
        toY = path[nowC][toX];
        g[toX][toY] = 'O';
        for (int i = 1; i <= c; i++)
            if (lastRow[i] == toX && path[i][toX] == toY)
                xjb(i, toX - 1, path[i][toX - 1]);
    }
    for (int i = 1; i <= r; i++)
    {
        for (int j = 1; j <= c; j++)
            cout << g[i][j];
        cout << endl;
    }
    return 0;
}
```

---

## 作者：jr_linys (赞：3)

来看看这道题 [弹飞绵羊](https://www.luogu.com.cn/problem/P3203)  
~~这题比弹飞绵羊绵羊还难一点，建议升紫。~~

按行分块，维护石头从这个点会滚到的块内的哪个位置。  
块长 $L$ 建议取 $50$，时间复杂度 $O(rc+n(\frac{r}{L}+Lc))$。

我的实现是若石头从 $i,j$ 这个点最终会滚到的块内的位置 $(x,y)$，在 `p[i][j]` 中存贮 `&p[x][y]-p[0]`，即 `p[x][y]` 与数组开头的相对位置。

传入 `p[i][j]` 的相对位置给 `get()`，得到从 $(i,j)$ 滚到在 $i+1$ 行所在块的最终位置，如果滚不了了就返回自身位置。


```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T=int>
T read(){
	char c;
	while(c=getchar(),c<'0'||c>'9');
	T x=c^'0';
	while(c=getchar(),c>='0'&&c<='9') x=x*10+(c^'0');
	return x;
}
const int N=30000,M=30,MS=M+2,L=50;
int n,m,bSum;
int bId[N+2],bPos[N+2],p[N+2][MS];
char mp[N+2][MS];
int get(int pos){//获得滚到在 $i+1$ 行所在块的最终位置，如果滚不了了就返回自身位置。
	if(*(mp[0]+pos+MS)=='.') return *(p[0]+pos+MS);
	else if(*(mp[0]+pos+MS)=='O'){
		if(*(mp[0]+pos-1)=='.'&&*(mp[0]+pos+MS-1)=='.') return *(p[0]+pos+MS-1);
		else if(*(mp[0]+pos+1)=='.'&&*(mp[0]+pos+MS+1)=='.') return *(p[0]+pos+MS+1);
	}
	return pos;
}

void build(const int i,const int xx){
	const int le=bPos[i]+1;
	if(xx==bPos[i+1]) for(int i=1;i<=m;++i) p[xx][i]=xx*MS+i;//边界特殊处理
	for(int i=xx-1;i>=le;--i)
		for(int j=1;j<=m;++j)
			if(mp[i][j]=='.') p[i][j]=get(i*MS+j);
}
void bInit(){
	for(int i=1;i<=n;++i) bId[i]=(i-1)/L;
	bSum=bId[n];
	for(int i=0;i<=bSum;++i) bPos[i]=i*L;
	bPos[bSum+1]=n;
	for(int i=bSum;i>=0;--i) build(i,bPos[i+1]);
}

int main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i) scanf("%s",mp[i]+1);
	bInit();
	int q=read();
	while(q--){
		int pos=*(p[0]+MS+read()),pp;
		while((pp=get(pos))!=pos) pos=pp;//不断跳到边界
		mp[pos/MS][pos%MS]='O';
		build(bId[pos/MS],pos/MS);
	}
	for(int i=1;i<=n;++i) printf("%s\n",mp[i]+1);
}
```

---

## 作者：Creeper_l (赞：3)

原题链接：[P6370](https://www.luogu.com.cn/problem/P6370)

## 思路

题意不多赘述。

首先这道题的 $60$ 分暴力很好打，直接按题目中的操作做即可，时间复杂度 $O(nr)$。

考虑优化暴力。我们会发现很多次石头的起始点为同一列的情况，其实每一次下落的轨迹是差不多的。具体来讲应该是第一次下落的轨迹一定包含了后面每一次的轨迹。所以我们可以模拟一个类似于栈的东西 $s_{i,j}$ 表示起始点在第 $i$ 列，当前在第 $j$ 行（即跳过的步数为 $j$，因为每跳一次一定下落一行）时，当前在 $s_{i,j}$ 列。那么，对于起始点在每一列的情况，第一次直接暴力将栈填满，之后的每一次再看栈顶的位置合不合法，如果不合法的话就弹出直到合法为止。则栈顶的位置就是这颗石头所在的位置。

因为起始点只可能有 $O(c)$ 个，且对于每个起始点的暴力操作最多 $O(rc)$ 次，于是总时间复杂度 $O(rc^{2}$)。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x3f
#define inf_db 127
#define ls id << 1
#define rs id << 1 | 1
#define re register
#define endl '\n'
typedef pair <int,int> pii;
const int MAXN = 3e4 + 10;
const int MAXM = 30 + 10;
int n,m,q,x,s[MAXM][MAXN],cnt[MAXN];
char c[MAXN][MAXM];
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i = 1;i <= n;i = -~i)  scanf("%s",(c[i] + 1)); 
	for(int i = 1;i <= m;i = -~i) c[n + 1][i] = 'X';
	for(int i = 1;i <= m;i++) s[i][++cnt[i]] = i;
	scanf("%lld",&q);
	while(q--)
	{
		scanf("%lld",&x);
		while(true)
		{
			int now = s[x][cnt[x]];
			//x 表示最开始时的列数，now 表示当前的列数（即跳过的步数），cnt[x] 表示当前的行数 
			if(c[cnt[x]][now] == 'O') cnt[x]--;
			else if(cnt[x] >= n) break;
			else if(c[cnt[x] + 1][now] == 'X') break;
			else if(c[cnt[x] + 1][now] == '.') s[x][++cnt[x]] = now;
			else if(c[cnt[x]][now - 1] == '.' && c[cnt[x] + 1][now - 1] == '.') s[x][++cnt[x]] = now - 1;
			else if(c[cnt[x]][now + 1] == '.' && c[cnt[x] + 1][now + 1] == '.') s[x][++cnt[x]] = now + 1;
			else break;
		}
		c[cnt[x]][s[x][cnt[x]]] = 'O';
	}
	for(int i = 1;i <= n;i = -~i) printf("%s\n",(c[i] + 1));
	return 0;
} 
```




---

## 作者：SunsetLake (赞：2)

[题目](https://www.luogu.com.cn/problem/P6370) 

神奇模拟题。最直接的做法就是每个石头暴力向下滚，有 $60$ 分。但是大样例跑了 $15s$。稍微观察一下，会发现很多次循环都是在重复向下走到一格空位上，于是考虑优化：用 set 维护每一列的那些位置有障碍（包括石头），每次直接 lower_bound 跳到下一个位置，会快很多，大样例 $1.7s$。赛时就写的这个，但还是过不去的。因为反复横跳就会将其卡至 $O(nr \log r)$。

我们发现 $c$ 是很小的，也就意味着会有很多次都是从同一列向下滚。观察发现：同一列的滚动路径只会有**后面连续的一段会被改变**。也就是说假如这列第一个球的路径是 $p_1,p_2...p_x$ ，那么下一个小球的路径的前半段一定与当前小球相同。因为假设有一个位置 $y$ 使得 $p_y$ 被覆盖而 $p_{y+1}$ 没有被覆盖，那么小球沿着滚动路径一定能放下滚去覆盖 $p_{y+1}$，与假设矛盾。

因此，我们直接维护从当前列开始扔，到第 $x$ 行是在第几列。因为有可能会有一些小球会把当前位置占掉，所以我们在进行操作前要先将被占的位置撤销，找到一个空列再下落。这样时间复杂度就均摊下来了，为 $O(rc^2)$。

## code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int r,c;
char a[30005][35];
int n,x,vis[30005][35];
int h[35][300005],pos[34];//h[i][j]表示从第i列开始扔，到第j行在哪一列
set<int>s[35];
int main(){
//	freopen("kamen.in","r",stdin);
//	freopen("kamen.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>r>>c;
	for(int i=1;i<=r;++i){
		for(int j=1;j<=c;++j){
			cin>>a[i][j];
			if(a[i][j]=='X')vis[i][j]=1;
		}
	}
	for(int i=1;i<=c;++i)h[i][0]=i;
	int q;
	cin>>q;
	while(q--){
		cin>>x;
		while(1){
			int now=h[x][pos[x]];//pos[x]相当于记录从x列滚到了多少行
			if(vis[pos[x]][now])pos[x]--; //先把被占的地方退回
			else if(pos[x]==r)break;//到底了
			else if(a[pos[x]+1][now]=='X')break;//遇到障碍
			else if(!vis[pos[x]+1][now])h[x][++pos[x]]=now;//可以向下走
			else if(now-1>=1&&(!vis[pos[x]][now-1])&&(!vis[pos[x]+1][now-1]))h[x][++pos[x]]=now-1;//向左
			else if(now+1<=c&&(!vis[pos[x]][now+1])&&(!vis[pos[x]+1][now+1]))h[x][++pos[x]]=now+1;//向右
			else break;//走不了了
		}
		a[pos[x]][h[x][pos[x]]]='O';//更新
		vis[pos[x]][h[x][pos[x]]]=1;
	}
	for(int i=1;i<=r;++i){
		for(int j=1;j<=c;++j)cout<<a[i][j];
		cout<<'\n';
	}
	return 0;
}
```


---

## 作者：MrSWdAxiv (赞：2)

## 题意

给一个方阵，从上面往下抛石子，算出石子最后的位置然后输出。

## 做法

一看题，第一秒想到的就是模拟。不过会超时四个点，那只好想想该怎么优化。

这时就会发现从同一列抛石子下落的路线**基本相同**，那就只需要预处理一下路线，当下一个石子再从这一列丢下时就更新预处理路线。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long r,c,n,x,j,column;
long long sy_column[35][30005];//石子下落后的列
long long sx_layer[30005];//石子下落后的上一行
char Map[30005][35];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>r>>c;
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			cin>>Map[i][j];
		}
	}
	for(int i=1;i<=c;i++){//初始化每一列
		sy_column[i][0]=i;
	}
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		while(1){
			column=sy_column[x][sx_layer[x]];
			if(Map[sx_layer[x]][column]=='O'){//当一个石子下落完成后
				sx_layer[x]--;//更新预处理的行
			}else if(sx_layer[x]==r){
				break;
			}else if(Map[sx_layer[x]+1][column]=='X'){
				break;
			}else if(Map[sx_layer[x]+1][column]=='.'){//石子一直下落
				sx_layer[x]++;
				sy_column[x][sx_layer[x]]=column;
			}else if(Map[sx_layer[x]][column-1]=='.'&&Map[sx_layer[x]+1][column-1]=='.'){//落到石子上从左边滑下
				sx_layer[x]++;
				sy_column[x][sx_layer[x]]=column-1;
			}else if(Map[sx_layer[x]][column+1]=='.'&&Map[sx_layer[x]+1][column+1]=='.'){//落到石子上从右边滑下
				sx_layer[x]++;
				sy_column[x][sx_layer[x]]=column+1;
			}else{
				break;
			}
		}
		Map[sx_layer[x]][sy_column[x][sx_layer[x]]]='O';
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			cout<<Map[i][j];
		}
		cout<<'\n';
	}
	return 0;
}
```


---

## 作者：djh0314 (赞：2)

###   传送门 [P6370 [COCI2006-2007#6] KAMEN](https://www.luogu.com.cn/problem/P6370)

### 题意
比较简单就不详细解释了。   
    就是模拟石子下落，输出最终效果。
### 暴力 60
暴力模拟的代码应该是好敲的。         
    对于每一次，逐层下落，直至落至最后一层。   
    附赠代码。
   ```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
const int N = 3e4+5;
const int M = 32;
int r,c,n;
char ma[N][M];
map<char,int >dy;
bool check(int a,int x) {
	if(dy[ma[a][x]]||dy[ma[a+1][x]]) return 0;
	else return 1;
}
signed main() {
	dy['O']=1;
	dy['X']=2;
	cin>>r>>c;
	for(int i=1; i<=r; ++i) {
		for(int j=1; j<=c; ++j) {
			cin>>ma[i][j];
		}
	}
	cin>>n;
	for(int i=1; i<=n; ++i) {
		int x;
		cin>>x;
		int now=1;
		for(now=1; now<=r; ++now) {
			if(now==r) break;
			if(ma[now+1][x]=='X') break;
			if(ma[now+1][x]=='.') continue;
			if(ma[now+1][x]=='O') {
				if(x>1&&check(now,x-1)) {
					x--;
					continue;
				}
				if(x<c&&check(now,x+1)) {
					x++;
					continue;
				}
				break;
			}
		}
		ma[now][x]='O';
	}
	for(int i=1; i<=r; ++i) {
		for(int j=1; j<=c; ++j) {
			cout<<ma[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

### AC 
可以看出，对于相同的下落点，每一次下落会有大量路程重复去刷。    
以此为出发点。

用一个数组 $cnt[x] $ 表示从 $x$ 下落最终到达的层数。        
用 $to[i][j]$ 表示从 $j$ 下落到第 $i$ 层到达的列。

当然，每一次下落路径并不是完全相同，也可能会受到其他下落的影响。     
因此，我们对于每次受影响的列从**原落点**的**前一层**开始更新一下。


### AC代码
```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
const int N = 3e4+5;
const int M = 100;
int n, m;
char ma[N][M];
int cnt[N];
int to[N][M];
bool check(int now,int x) {
	if(ma[now][x]=='.'&&ma[now+1][x]=='.') return 1;
	return 0;
}
void down(int x,int now,int st) {
	while(1) {
		cnt[st]=now;
		to[now][st]=x;
		if(ma[now+1][x]=='X') break;
		else if(ma[now+1][x]=='.'){} 
		else if(ma[now+1][x]=='O') {
			if((x>1)&&check(now,x-1)) x--;
			else if((x<m)&&check(now,x+1)) x++;
			else break;
		}
		now++;
	}
}
signed main() {
	cin>>n>>m;
	for(int i=1;i<=n;++i) {
		string s;
		cin>>s;
		for(int j=1;j<=m;++j) {
			ma[i][j]=s[j-1];
		}
	}
	for(int i=1;i<=m;++i) ma[n+1][i]='X';
	for(int i=1;i<=m;++i) {
		down(i,1,i);
	}
	int T;
	cin>>T;
	while (T--) {
		int x;
		cin>>x;
		ma[cnt[x]][to[cnt[x]][x]] ='O';
		for(int i=1;i<=m;++i) {
			if(ma[cnt[i]][to[cnt[i]][i]]=='O')
				down(to[cnt[i]-1][i],cnt[i]-1,i);
		}	
	} 
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=m;++j ) {
			cout<<ma[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

    

---

## 作者：ღꦿ࿐ (赞：1)

直接模拟的复杂度是 $O(nc)$，无法通过，考虑列数很少，维护每列开始放一个球下去掉落的路径，一个球一定会掉落到路径的末端，我们直接将球放在这里。

考虑这个球对所有起点开始的路径的影响，如果影响了，一定是堵上了某条路径末端，因为假设这个球堵住了某条路径中间的部分，那么它一定会随着这条路径继续滚下去，所以堵住的一定是末端，我们将被堵住的末端删除，从末端的上一步开始暴力模拟下去，重新求出这条路径新的样子即可。

复杂度证明：

考虑每条路径一定只会改变末端，路径的长度是 $O(c)$ 的，每一步只会使得路径的长度减少最多 $O(1)$，并重新扩展路径，时间复杂度是 $O(|\text{扩展长度}|)$ 的，所以每一步最多只会对每条路径贡献 $O(1)$ 的复杂度，共有 $c$ 条路径，时间复杂度 $O(rc + nc)$，空间 $O(rc)$。



一些想复杂了的做法：

维护每一层的 $to_i$，表示从这一层 $i$ 位置进入的球会从哪个位置出去，然后使用线段树维护区间 $to$ 的复合，时间复杂度 $O(rc + nc\log r)$。

还有更逆天的可以拿 lct 动态这个连向关系的森林，复杂度 $O((rc+n)\log rc)$。


```cpp

/*
	所有的感受都将被铭记在心
		不必劳烦群星指引
*/ 
#include <bits/stdc++.h>
#define rep(i,x,y) for(auto i(x);i<=(y);++i)
#define Rep(i,x,y) for(auto i(x);i>=(y);--i)
signed main () {
	std :: ios :: sync_with_stdio (false); std :: cin.tie(0) , std :: cout.tie(0) ;
	int r , c; 
	std :: cin >> r >> c;
	std :: vector< std :: string > g(r) ;
	for (auto &ths : g) {
		std :: cin >> ths ;
	} 
	std :: vector < std :: vector < std :: pair <int, int> > >epos(c) ;
	auto check = [&] (int x,int y) {
		if (x < 0 || y < 0 || x >= r || y >= c) return -1 ;
		if (g[x][y] == 'X') return -1;
		return g[x][y] == 'O' ? 1 : 0 ; 
	} ;
	auto imple = [&check] (int x,int y) {
		std :: vector <std :: pair<int,int>> path ;
		if (check(x,y)) return path;
		while (1) {
			path.emplace_back (x , y) ;
			int t = check (x + 1 , y) ;
			if (t == 0) {
				++ x ;
				continue ;
			}
			if (t == -1) {
				break ;
			}
			if (!check (x + 1 , y - 1) && !check (x , y - 1)) {
				-- y; ++ x;
				continue ;	
			}
			if (!check (x + 1 , y + 1) && !check (x , y + 1)) {
				++ y; ++ x;
				continue ;
			}
			break ;
		}
		return path ;	
	} ;
	rep (i,0,c-1) {
		epos[i] = imple (0 , i); 
	}
	int q , i;
	std :: cin >> q ;
	while (q--) {
		std :: cin >> i ; -- i;
		int x = epos[i].back ( ).first , y = epos[i].back( ).second; 
		g[x][y] = 'O' ;
		rep (t,0,c - 1) {
			if(epos[t].back ( ) == std :: make_pair(x,y)) {
				epos[t].pop_back ( ) ;
				if (epos[t].size( )) {	
					auto pth = imple (epos[t].back( ).first , epos[t].back ( ).second) ;
					epos[t].pop_back  ( ) ;
					for (const auto &v : pth) {
						epos[t].push_back (v);
					}
				}
			}
		}
	}
	for(const auto &ths : g)  {
		std :: cout << ths << '\n';
	}
}
```

---

## 作者：lizhous (赞：0)

不需要寻找任何性质。

首先有比较明显的暴力做法，可以直接搜索。

想到搜索有很多重复的地方，而每次搜索相当于整个重新搜索一遍，十分的缓慢。所以我们自然的想到每次只重构一部分的搜索。

具体的，我们设定一个阈值 $B$。令 $f_{i,j}$ 表示位置 $(i,j)$ 向下走 $B$ 层达到的点，由于我们只会走到 $1,B+1,\cdots,n$ 等点，我们只需处理出 $B|(i-1)$ 的 $f$ 值即可。

考虑一次搜索，我们从 $x$ 开始，根据 $f_{i,j}$ 一直往下跳直到停止，这样只会搜索 $\frac{r}{B}$ 次。而由于我们在结束位置 $(x,y)$ 新增了一个石头，这会使得一些 $f$ 的值改变。而我们又发现，改变的 $f$ 他所对应跳跃过的区间必然是包含 $(x,y)$ 的，所以他们必然是同一层的 $f$，最多 $c$ 个，重新处理这些 $f$ 的值是 $c\times B$ 的。

测试发现 $B$ 取 $1000$ 最快，代码是好写的。

---

## 作者：0xFF (赞：0)

#### 思路分析


------------
想不到正解不如先打个[暴力](https://www.luogu.com.cn/paste/o3yd7f1x)，可以发现暴力只能通过 $r$ 较小的测试点，那么当 $r$ 较大时，爆搜会重复进行很多无意义的操作，因为如果从同一列扔石子，他们下落的路线一定相同，且他们都会堆积在路线的最后，那么只需要预处理出从 $x$ 列扔石子的路线，每次查看目标位置是否被之前扔下的石头占领即可，每次操作完后更新从第 $x$ 列扔下石头的目标位置即可。

共有 $c$ 列，每一列最多被枚举一次，每次下落操作最多遍历 $r\times c$ 个位置，故总复杂度不超过 $\Theta(r\times c^2)$。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<deque>
#include<queue>
#include<map>
#include<vector>
#define int long long//
using namespace std;
const int INF = 2e15;
const int mod = 1e9 + 7;
const int N = 3e4 + 10;
const int M = (1<<20) + 10;

inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
char mp[N][51];
int path[51][N],cnt[51],r,c;
void down(int x){
	while(true){
		int tmp = path[x][cnt[x]];
		if(mp[cnt[x]][tmp] == 'O') --cnt[x];
		else if(cnt[x] == r) break;
		else if(mp[cnt[x]+1][tmp] == 'X') break;
		else if(mp[cnt[x]+1][tmp] == '.') path[x][++cnt[x]] = tmp;
		else if(mp[cnt[x]+1][tmp-1] == '.' && mp[cnt[x]][tmp-1] == '.') path[x][++cnt[x]] = tmp - 1;
		else if(mp[cnt[x]+1][tmp+1] == '.' && mp[cnt[x]][tmp+1] == '.') path[x][++cnt[x]] = tmp + 1;
		else break;
	}
	mp[cnt[x]][path[x][cnt[x]]] = 'O';
}
signed main(){
	r = read() , c = read();
	for(int i=1;i<=r;i++){
		scanf("%s",mp[i]+1);
	}
	for(int i=1;i<=c;i++) path[i][0] = i;
	int n = read();
	for(int i=1;i<=n;i++){
		int x = read();
		down(x);
	}
	for(int i=1;i<=r;i++){
		printf("%s\n",mp[i]+1);
	}
	return 0;
}

/*

*/
```


---

## 作者：yxy666 (赞：0)

这道题目好恶心啊，我调了好长时间，结果发现自己死在了读入上！

题意：给我们一个 $R*C$ 的矩阵，有的地方的点是 $' .'$ ，表示可以走的。还有一种情况就是 $'X'$，是不可以走的。然后执行 $m$ 次，每次在 $1-C$ 列从最上面丢一个石头下去，石头的下落规则是这样的：

$·$ 如果下一个格子是空格，那么向下运动一格。

$·$ 如果下一个格子是墙或者已经到了第 $r$ 行，则停止滚动并停在原处。

$·$ 如果下一个格子是一块停止的石头，则如果在左侧和左下方为空格时首选滚动到左侧的那一行，否则如果右侧和右下方为空格，则滚动到右侧的那一行。如果两侧都不为空，则石头静止不在移动。

思路：我们把所有格子可能降落在这儿的情况给预处理一下，然后没丢一个石头都修正一下每一个的情况。

$code$ :
```cpp
//模拟的题目,首先推导出每一列放下石头后,最后逃到哪里?当然可能有多条线路下来最后汇集到同一个节点,那么再重新调整一下这样的线路即可 
#include<bits/stdc++.h>
using namespace std;
int r,c,m,path[35][30005],nxt_r[35];
char g[30005][35];
int read(){
	int ret=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return ret*f;
}
void fall(int th,int x,int y){
    path[th][x]=y;
    for (;;){
        if (g[x+1][y]=='X') break;
        if (g[x+1][y]=='.') x++;else//扔进来的石头'O' 
		if (g[x][y-1]=='.' && g[x+1][y-1]=='.') x++,y--;else
		if (g[x][y+1]=='.' && g[x+1][y+1]=='.') x++,y++;else break;
        path[th][x]=y;
    }
    nxt_r[th]=x;
}
int main(){
    r=read(),c=read();
    memset(g,'X',sizeof(g));
    for (int i=1;i<=r;i++)
    for (int j=1;j<=c;j++){
    	g[i][j]=getchar();
    	while(g[i][j]!='.'&&g[i][j]!='X')g[i][j]=getchar(); 
	} 
    for (int j=1;j<=c;j++) fall(j,1,j);
    m=read();
    while (m--){
        int C=read();
        int now_x=nxt_r[C],now_y=path[C][now_x];
        if (g[now_x][now_y]=='O') continue;else g[now_x][now_y]='O';
        for (int j=1;j<=c;j++)
          if (nxt_r[j]==now_x && path[j][now_x]==now_y) fall(j,now_x-1,path[j][now_x-1]);
    }
    for (int i=1;i<=r;i++){
    	g[i][c+1]=0;
        printf("%s\n",g[i]+1);
    }
    return 0;
}
```


---

## 作者：Mu_leaf (赞：0)

## [题目链接](https://www.luogu.com.cn/problem/P6370)

### [题意]

显而易见，在此不多说啦。

### [思路]

很明显，如果深搜模拟肯定会超时毕竟 $1 \le n \le 10^5$。

这里有个很显而易见的结论：**那么经过若干轮后，必然只有后面经过的一段连续路径会被石子覆盖。（发现其他题解全部证明了，我就不献丑了）**。

可以考虑用数组 $\mathit{cnt}_{x}$ 存下每列下降的路径，如果还要进行对第 $x$ 列操作时，考虑退回去找另一条路径。

# Code:

```cpp
#include <bits/stdc++.h>

using namespace std;
int r,c;
int q;
int x;
char mp[30005][35];
int ne[30005][35],cnt[35];
void dwmjj_push(int x){
	while(1){
		int tmp=ne[cnt[x]][x];
		if(mp[cnt[x]][tmp]=='O') --cnt[x];
		else if(cnt[x] == r) break;
		else if(mp[cnt[x] + 1][tmp]=='X') break;
		else if(mp[cnt[x] + 1][tmp]=='.') ne[++cnt[x]][x] = tmp;
		else if(tmp > 1 && mp[cnt[x]][tmp-1]=='.' && mp[cnt[x]+1][tmp - 1]=='.') ne[++cnt[x]][x]=tmp-1;
		else if(tmp < c && mp[cnt[x]][tmp+1]=='.' && mp[cnt[x]+1][tmp + 1]=='.') ne[++cnt[x]][x]=tmp+1;
		else break;
	}mp[cnt[x]][ne[cnt[x]][x]]='O';
}
int main(){
	cin >> r >> c;
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			cin >> mp[i][j];
	for(int i=1;i<=c;i++)
		ne[0][i]=i;
	
	cin >> q;
	while(q--){
		cin >> x;
		dwmjj_push(x);
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			cout << mp[i][j];
		}printf("\n");
	}
	
	return 0;
}
```


---


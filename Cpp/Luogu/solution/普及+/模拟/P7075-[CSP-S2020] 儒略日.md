# [CSP-S2020] 儒略日

## 题目描述

为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。

现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。

我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：

1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。
2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。
3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。
4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。

## 说明/提示

**【数据范围】**

| 测试点编号 | $Q =$ | $r_i \le$ |
|:-:|:-:|:-:|
| $1$ | $1000$ | $365$ |
| $2$ | $1000$ | $10^4$ |
| $3$ | $1000$ | $10^5$ |
| $4$ | $10000$ | $3\times 10^5$ |
| $5$ | $10000$ | $2.5\times 10^6$ |
| $6$ | $10^5$ | $2.5\times 10^6$ |
| $7$ | $10^5$ | $5\times 10^6$ |
| $8$ | $10^5$ | $10^7$ |
| $9$ | $10^5$ | $10^9$ |
| $10$ | $10^5$ | 年份答案不超过 $10^9$ |

## 样例 #1

### 输入

```
3
10
100
1000```

### 输出

```
11 1 4713 BC
10 4 4713 BC
27 9 4711 BC```

## 样例 #2

### 输入

```
3
2000000
3000000
4000000```

### 输出

```
14 9 763
15 8 3501
12 7 6239```

## 样例 #3

### 输入

```
见附件中的 julian/julian3.in```

### 输出

```
见附件中的 julian/julian3.ans```

# 题解

## 作者：「已注销」 (赞：145)

在一种历法中，日期计算以400年为周期，每400年都有恰好146097天

预处理出400年内的情况，将年份模400即可快速得到答案

几个简化代码的技巧：

对于格里高利历，以1200年1月1日为起始日，$r$减去跳过的天数（2159351）

判断历法：$r\leqslant2299160$即为儒略历

公元前$x$年视为$1-x$年

```cpp
#include<bits/stdc++.h>
typedef long long ll;
const int N=146097;//格里高利历400年的天数
int T,y[N],m[N],d[N];
ll n,t;
inline int md(int y,int m){//格里高利历y年m月的天数
    if(m==2)return y%4?28:y%100?29:y%400?28:29;
    return m==4||m==6||m==9||m==11?30:31;
}
int main(){
    m[0]=d[0]=1;
    for(int i=1;i<N;++i){
        d[i]=d[i-1]+1;m[i]=m[i-1];y[i]=y[i-1];
        if(d[i]>md(y[i],m[i]))++m[i],d[i]=1;
        if(m[i]>12)++y[i],m[i]=1;
    }//y[i],m[i],d[i]分别表示从0年1月1日经过i天的年月日
    scanf("%d",&T);
    while(T--){
        scanf("%lld",&n);
        if(n>2299160){//格里高利历
            n-=2159351;
            t=n/N*400+1200;
            n%=N;
        }else{
            t=n/1461*4-4712;//1461是儒略历4年的天数
            n%=1461;
        }
        if(t+y[n]>0)printf("%d %d %lld\n",d[n],m[n],t+y[n]);
        else printf("%d %d %lld BC\n",d[n],m[n],1-t-y[n]);
    }
}
```


---

## 作者：OMG_wc (赞：33)

中规中矩的模拟题，考察了对时间的理解。

给的大样例也不是很强，所以 OI 赛制下这题可能会丢很多分，甚至爆 $0$。

有趣的是，**比赛那天 $2020$ 年 $11$ 月 $7$ 日正好距离 $1582$ 年 $10$ 月 $15$ 日 $16$ 万天整**，~~由此断定出题人就是罗马教皇格列高利十三世转世~~。

![](https://cdn.luogu.com.cn/upload/image_hosting/clbnwv8a.png)

有两种思路：
1. Day by Day 模拟然后找规律计算。
2. 二分年份再剩余日期模拟。

写起来会有一些坑，比如：

- 判定闰年要分 $1582$ 年前和后，规则不一样。
- 不存在公元 $0$ 年，那就手动把公元前往后偏移一个位置，最后输出答案再减 $1$。
- 消失的那 $10 $天，会带来一些特判。
- 二分里计算到某年的总天数，会有一些细节，也是和闰年及消失的 $10$ 天有关。
- 天数要用`long long`。

时间复杂度 $O(Q\log Y)$，其中 $Y$ 为年份范围，具体实现如下：

```cpp
int a[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
LL cal(LL x) {
    int sb = -4712;
    if (x < sb) return 0;
    LL res = (x - sb + 1) * 365;
    if (x < 1582) {
        res += (x - sb) / 4 + 1;
    } else {
        res -= 10;
        res += (1581 - sb) / 4 + 1;
        res += (x - 1580) / 4 - (x - 1500) / 100 + (x - 1200) / 400;
    }
    return res;
}
bool pd(int x) {
    if (x > 1582) {
        return x % 4 == 0 && x % 100 != 0 || x % 400 == 0;
    } else {
        return x % 4 == 0;
    }
}
int main() {
    int _;
    scanf("%d", &_);
    while (_--) {
        LL n;
        scanf("%lld", &n);
        n++;
        int l = -4712, r = 1e9 + 5;
        while (l < r) {
            int mid = l + r >> 1;
            if (cal(mid) >= n) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        n -= cal(l - 1);
        a[2] = 28 + pd(l);
        a[10] = l == 1582 ? 21 : 31;
        int m;
        for (int i = 1; i <= 12; i++) {
            if (n > a[i]) {
                n -= a[i];
            } else {
                m = i;
                break;
            }
        }
        if (l == 1582 && m == 10) {
            if (n >= 5) n += 10;
            printf("%lld %d %d\n", n, m, l);
        } else {
            if (l > 0)
                printf("%lld %d %d\n", n, m, l);
            else
                printf("%lld %d %d BC\n", n, m, -l + 1);
        }
    }
    return 0;
}
```

---

## 作者：PrincessQi (赞：19)

## 0.题外话：

CSP-S T1 放这个真的好吗。。。T2都比这个简单

## 1. $10$ 分做法

由于第一个点 $r_i\leq 365$ ，所以判断几月几日就好。

等等，好像没那么简单？

有的同学发现了一点：一月一日是第 $0$ 天，那么第 $365$ 天不就到后一年去了吗？

其实公元前4713年是一个闰年，因为 $4713\equiv 1\ \ \ (\text{mod}\ 4)$ ，而公元前1年为闰年。

所以只要枚举判断月份的前缀和是否超过了 $r_i$ 即可。

```
	month[2]++;
	int qwq=0,mth;
	for(int i=1;i<=12;i++){
		qwq+=month[i];
		if(qwq>=k){
			mth=i;
			k-=(qwq-month[i]);
			printf("%lld %lld 4713 BC\n",k,mth);
			break;
		}
	}
	month[2]--;
```

## 2. $40$ 分做法

首先，公元1582年10月4日是第 $2299160$ 天，所以只处理适用儒略历的就可以拿到 $40$ 分了。

那如何处理儒略历呢？

注意到，儒略历 $4$ 年一循环，所以可以让 $r_i$ 对 $365\times 4+1$ 取余，求出大致年份，再一年一年判断在哪一年。

然后再向上面一样判断月、日就好了。
```
void count_date(int year,int k,int r){
	if(r==1)month[2]++;
	int qwq=0,mth;
	for(int i=1;i<=12;i++){
		qwq+=month[i];
		if(qwq>=k){
			mth=i;
			k-=(qwq-month[i]);
			if(year-4713<0)printf("%lld %lld %lld BC\n",k,mth,4713-year);
			else printf("%lld %lld %lld\n",k,mth,year-4712);
			break;
		}
	}
	if(r==1)month[2]--;
}
```


```
		scanf("%lld",&n);
			int k=n%(365*4+1),year=n/(365*4+1)*4,r=1;
			if(k>=366)k-=365,year++,r=0;
			if(k>=366)k-=365,year++;
			if(k>=366)k-=365,year++;
			if(r==1)k++;
			count_date(year,k,r);
```

## 3. $100$ 分做法

没错，就是 $100$ 分做法。

首先，对于格里高利历，有个~~很没良心~~的地方：当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。

所以，变成了 $400$ 一周期。怎么办？

其实和 $40$ 分做法一样处理就行了。

具体来说，就是把那几个``if``语句写个循环，道理是一样的。

注意，循环里还是要判断闰年。

还有，由于以公元1600年1月1日为原点写起来会比较舒服（周期起点），所以可以为了减少代码量，特判一下公元1582年和公元1600年之间的那几年。

下面是完整的代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int q,n,rsum,month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
void count_date(int year,int k,int r){
	if(r==1)month[2]++;
	int qwq=0,mth;
	for(int i=1;i<=12;i++){
		qwq+=month[i];
		if(qwq>=k){
			mth=i;
			k-=(qwq-month[i]);
			if(year-4713<0)printf("%lld %lld %lld BC\n",k,mth,4713-year);
			else printf("%lld %lld %lld\n",k,mth,year-4712);
			break;
		}
	}
	if(r==1)month[2]--;
}//儒略历时代的count_date
void count_date2(int year,int k,int r){
	if(r==1)month[2]++;
	int qwq=0,mth,f=0;
	for(int i=1;i<=12;i++){
		qwq+=month[i];
		if(qwq>=k){
			mth=i;
			k-=(qwq-month[i]);
			printf("%lld %lld %lld\n",k,mth,year+1600);
			f=1;
			break;
		}
	}
	if(f==0)printf("1 1 %lld\n",year+1601);
	if(r==1)month[2]--;
}//格里高利历时代的count_date
signed main(){
	//freopen("julian.in","r",stdin);
	//freopen("julian.out","w",stdout);
	for(int i=1;i<=400;i++)
		if((i%4==0&&i%100!=0)||i%400==0)rsum++;
	scanf("%lld",&q);
	while(q--){
		scanf("%lld",&n);
		if(n<=2299160){
			int k=n%(365*4+1),year=n/(365*4+1)*4,r=1;
			if(k>=366)k-=365,year++,r=0;
			if(k>=366)k-=365,year++;
			if(k>=366)k-=365,year++;
			if(r==1)k++;
			count_date(year,k,r);
		}//儒略历时代
		else {
			n+=10;//完美跳过不存在的那几天
			if(n<=2305457){
				int k=n%(365*4+1),year=n/(365*4+1)*4,r=1;
				if(k>=366)k-=365,year++,r=0;
				if(k>=366)k-=365,year++;
				if(k>=366)k-=365,year++;
				if(r==1)k++;
				count_date(year,k,r);
			}//特判的那几年
			else{
				n-=2305458;
				int k=n%(365*400+rsum),year=n/(365*400+rsum)*400,r=1;
				if(k>=366)k-=365,year++,r=0;
				for(int i=2;i<=399;i++){
					if(i%4==0&&i%100!=0){
						if(k>=367)k-=366,year++,r=1;
						else break;
					}
					else{
						if(k>=366)k-=365,year++,r=0;
						else break;
					}
				}
				if(r==1)k++;
				count_date2(year,k,r);
			}//格里高利历时代
		}
	}
	return 0;
}
```
时间复杂度：这看起来暴力的做法实际上是 $O(q)$ 的~~不过常数比较大~~。

---

## 作者：囧仙 (赞：5)

## $\stackrel{\text{废话}}{\textbf{前言}}$

- 这条题目成功加冕成为新一代毒瘤题我是没想到的。但 $\frak{u1s1}$ ，个人感觉这题不是很难，主要考的选手的细心程度。

- 个人总结，只要**不贪**，这题还是挺容易做的。

## 题解

让我们首先解决一些题面中给出的特殊情况。

- 起始时间为公元前 $4713$ 年 $1$ 月 $1$ 日。

- 公元 $1582$ 年 $10$ 月 $4$ 日以前，当一个年份被四整除时为闰年。但是如果一个年份在公元前，则应当将这个年份减去 $1$ 后进行闰年判定。

- 公元 $1582$ 年 $10$ 月 $5$ 日至 $10$ 月 $14$ 日被删除。

- 公元 $1582$ 年 $10$ 月 $15$ 日以后，一个年份为闰年，当且仅当它被四百整除或者能被四整除但不能被一百整除。

- 公元前一年的下一年，就是公元元年。

让我们先把闰年判定写出来。为了区分公元前后，我们用数字的正负进行区分。

```cpp
bool chk(i64 y){
	if(y<=1582ll){
		if(y<0ll) y=-y-1ll; return y%4ll==0ll;
	}
	return (y%400ll==0ll)||(y%4ll==0ll&&y%100ll!=0ll);
}
```

题目给了相当多的信息，尤其是非常多的时段分类……但是，如果你仔细思考时段的长度，你能发现，

$$\textbf{4713.1.1 BC 至 1582.10.15 一共不超过 2.5}\boldsymbol{\times 10^6 }\textbf{天}$$

所以，我们能非常简单的写出这样一份代码，直接枚举这所有天的情况。


```cpp
up(1,2305447,i){
	Y[i]=Y[i-1],M[i]=M[i-1],D[i]=D[i-1]+1;
	if(M[i]==12ll&&D[i]==32ll){
		if(Y[i]==-1) Y[i]=1; else ++Y[i];
		M[i]=1,D[i]=1;
	} else if(Y[i]==1582ll&&M[i]==10ll&&D[i]==5ll){
		Y[i]=1582ll,M[i]=10ll,D[i]=15ll;
	} else if(M[i]==2ll&&chk(Y[i])&&D[i]==29ll){
		continue;
	} else if(D[i]>MD[M[i]]) ++M[i],D[i]=1;
}
//其中Yi,Mi,Di分别为第i天的年份、月份、日数。
//chk(Yi) 是检查Yi年是否是闰年。
```

- 经过一些暴力计算，我们能发现，$1600.1.1$ 的儒略日是 $2305448$ 。

好了，我们已经砍掉这题一半的难度了。下面考虑 $1600$ 年之后的事情。

要注意的是，**从天数推日期总是比从日期推天数难**。

这里启发我们二分年份，计算它和 $1600.1.1$ 的日期之差。（为什么是差值？因为差值可以忽略掉一些可能导致的错误，因为两个错误相减后会互相消去，可以大大提升调对的概率）。月份和日期都可以直接枚举。这题就做完了。

```cpp
//计算绝对日期
#define f(x) ((x)/4-(x)/100+(x)/400)
i64 clc(i64 y,i64 m,i64 d){
	return 365ll*(y-1ll)+f(y-1ll)+((chk(y)&&m>=3ll)?1ll:0ll)+S[m-1ll]+d;
//这部分并不需要非常严格，因为我们只需要计算日期和1600.1.1的差值。
}

//主程序片段
dn(qread(),1,Q){
	i64 t=qread(); if(t<=2305447ll){
		i64 y=Y[t],m=M[t],d=D[t];	//直接从表中获取答案
		if(y<0) printf("%lld %lld %lld BC\n",d,m,-y);	//公元前
		else    printf("%lld %lld %lld\n",d,m, y);		//公元后
	} else {
		t-=2305448ll; i64 y=0,m=1,d=1;
		dn(30,0,i){	//二分
			if(clc(y|(1<<i),m,d)-clc(1600,1,1)<=t) y|=1<<i;
		}
		up(1,12,i) if(clc(y,i,d)-clc(1600,1,1)<=t) m=i;	//枚举月
		up(1,31,i) if(clc(y,m,i)-clc(1600,1,1)<=t) d=i;	//枚举日
		printf("%lld %lld %lld\n",d,m,y);
	}
}
```

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef unsigned int u32;
typedef long long    i64;
typedef unsigned long long u64;
i64 qread(){
	i64 r=0,w=1,c=0;
	for(c=getchar();!isdigit(c);c=getchar()) w=(c=='-'?-1:1); r=c-'0';
	for(c=getchar(); isdigit(c);c=getchar()) r=r*10+c-'0';
	return r*w;
}
const int MD[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
const int MAXN =2400000+3;
int Y[MAXN],M[MAXN],D[MAXN],S[13];
bool chk(i64 y){
	if(y<=1582ll){
		if(y<0ll) y=-y-1ll; return y%4ll==0ll;
	}
	return (y%400ll==0ll)||(y%4ll==0ll&&y%100ll!=0ll);
}
#define f(x) ((x)/4-(x)/100+(x)/400)
i64 clc(i64 y,i64 m,i64 d){
	return 365ll*(y-1ll)+f(y-1ll)+((chk(y)&&m>=3ll)?1ll:0ll)+S[m-1ll]+d;
}
int main(){
	freopen("julian.in","r",stdin);
	freopen("julian.out","w",stdout);
	Y[0]=-4713ll,M[0]=1ll,D[0]=1ll; up(1,12,i) S[i]=S[i-1]+MD[i];
	up(1,2305447,i){
		Y[i]=Y[i-1],M[i]=M[i-1],D[i]=D[i-1]+1;
		if(M[i]==12ll&&D[i]==32ll){
			if(Y[i]==-1) Y[i]=1; else ++Y[i];
			M[i]=1,D[i]=1;
		} else if(Y[i]==1582ll&&M[i]==10ll&&D[i]==5ll){
			Y[i]=1582ll,M[i]=10ll,D[i]=15ll;
		} else if(M[i]==2ll&&chk(Y[i])&&D[i]==29ll){
			continue;
		} else if(D[i]>MD[M[i]]) ++M[i],D[i]=1;
	}
	dn(qread(),1,Q){
		i64 t=qread(); if(t<=2305447ll){
			i64 y=Y[t],m=M[t],d=D[t];
			if(y<0) printf("%lld %lld %lld BC\n",d,m,-y);
			else    printf("%lld %lld %lld\n",d,m, y);
		} else {
			t-=2305448ll; i64 y=0,m=1,d=1;
			dn(30,0,i){
				if(clc(y|(1<<i),m,d)-clc(1600,1,1)<=t) y|=1<<i;
			}
			up(1,12,i) if(clc(y,i,d)-clc(1600,1,1)<=t) m=i;
			up(1,31,i) if(clc(y,m,i)-clc(1600,1,1)<=t) d=i;
			printf("%lld %lld %lld\n",d,m,y);
		}
	}
	return 0;
}
//这是赛时代码，马蜂可能比较丑，请见谅。

```

---

## 作者：Zskioaert1106 (赞：4)

题目传送门：[P7075 [CSP-S2020] 儒略日](https://www.luogu.com.cn/problem/P7075)

前情：第一次在 $24$ 小时内过掉的绿题大模拟（喜）。

## Part 1 遇事不决打暴力

我们首先可以写出一个判断某年某月天数的函数：如果是 $1582$ 年 $10$ 月则返回 $21$ 天，否则判断是否是 $2$ 月——如果是再判断是否是闰年，再判断是 $30$ 天的还是 $31$ 天的。

```cpp
int day(int y,int i){
	if(y==1582&&i==10)return 21;
	if(i==2){
		if(y<0&&(-y)%4==1||y>0&&y<=1582&&y%4==0||y>1582&&(y%4==0&&!(y%100==0&&y%400!=0)))return 29;
		else return 28;
	}
	if(i<8&&(i&1)||i>7&&!(i&1))return 31;
	else return 30;
}
```

然后打出初版的处理函数：如果当前以处理天数加上当月的所有天数仍不大于目标天数则整月加，否则按日处理。

```cpp
void doing(long long n){
	int year=-4713,month=1,date=1;
	long long i=0;
	while(i<n){
		int now=day(year,month);
		if(i+now>n){//时间差小于一个月
			date+=n-i;
			i=n;
			break;
		}
		else i+=now;
		if(year==0)year++;//公元零年的判定
		month++;
		if(month>12)year++,month=1;
	}
	cout<<date<<' '<<month<<' '<<abs(year);
	if(year<0)cout<<" BC";
	return;
}
```

主函数：

```cpp
int main(){
	int Q;
	for(cin>>Q;Q--;cout<<'\n'){
		long long r;
		cin>>r;
		doing(r);
	}
	return 0;
}
```

得分：[$40$ pts](https://www.luogu.com.cn/record/196116665)。

## Part 2 按年处理的优化

我们现在是对于每月分块处理的，可以考虑进一步按年分块，则要写出判断整年天数的函数：

```cpp
int day_year(int y){
	if(y==1582)return 355;
	if(day_month(y,2)==29)return 366;
	return 365;
}
```

主函数改为先按年处理整块，再按月、再按日的顺序：

```cpp
void doing(long long n){
	int year=-4713,month=1,date=1;
	long long i=0;
	while(i<n){
		int now=day_year(year);
		if(i+now>n){//时间差小于一年
			while(i<n){
				now=day_month(year,month);
				if(i+now>n){//时间差小于一个月
					date+=n-i;
					i=n;
					break;
				}
				else i+=now;
				if(year==0)year++;
				month++;
				if(month>12)year++,month=1;
			}
			break;
		}
		else i+=now;
		year++;
		if(year==0)year++;
	}
	cout<<date<<' '<<month<<' '<<abs(year);
	if(year<0)cout<<" BC";
	return;
}
```

得分：[$50$ pts](https://www.luogu.com.cn/record/196118703)。

## Part 3 再优化！取整余零

我们可以考虑：当 $n$（等同于 $r_i$）小于到公元 $1600$ 年的天数时，按之前的年块处理方法。否则我们可以算出来每过 $400$ 年所用的天数，然后直接从公元 $1600$ 年起整块增加（直接加到到 $n$ 不足 $400$ 年时），剩下的依旧可以按年月日暴力处理。

为什么选择 $1600$ 呢？~~因为这样可以有效避免处理一堆复杂的情况~~。

```cpp
const long long k=2305448;//从 -4713/1/1 到 1600/1/1
const long long k400=146097;//从 1600/1/1 到 1999/12/31
void doing(long long n){
	int year=-4713,month=1,date=1;
	long long i=0;
	if(n>=k){
		int s400=(n-k)/k400;//包含的 400 年轮回的块数
		i=k+s400*k400;//增加的总天数
		year=1600+s400*400;//增加的年数
	}
	while(i<n){
		long long now=day_year(year);
		if(i+now>n){
			while(i<n){
				long long now2=day_month(year,month);
				if(i+now2>n){
					date+=n-i;
					i=n;
					break;
				}
				else i+=now2;
				month++;
			}
			break;
		}
		else i+=now;
		year++;
		if(year==0)year++;
	}
	cout<<date<<' '<<month<<' '<<abs(year);
	if(year<0)cout<<" BC";
}
```

得分：[$90$ pts](https://www.luogu.com.cn/record/196178570)。

## Part 4 特殊情况

效果良好，但是好像踩到坑了。

我们发现上述代码对于 $1582$ 年 $10$ 月的处理会出逝，所以我们要判断一下让在公元 $1582$ 年 $10$ 月 $4$ 日至 $15$ 日的日期加 $10$，之后再处理下进月。

```cpp
while(i<n){
  long long now=day_year(year);
  if(i+now>n){
    while(i<n){
      long long now2=day_month(year,month);
      if(i+now2>n){
        date+=n-i;
        if(year==1582&&month==10&&date>=5){
          date+=10;
          if(date>31){//进月
            date-=31;
            month++;
          }
        }
        i=n;
        break;
      }
      else i+=now2;
      month++;
    }
    break;
  }
}
```

得分：[$100$ pts](https://www.luogu.com.cn/record/196179311)。

## Part 5 卡个常

值得一提的是，这种方法可以卡常。上述代码是在关闭同步流加氧气优化的情况下 AC 的，~~这也体现出了这些优化的重要性~~。关闭同步流或者 O2 优化都会 TLE 一个点。这时我们还可以再对公元前的年份加以一个判断，具体代码见下（其实与之前讲的差不多，读者可以尝试自己实践一下）：

```cpp
#include<iostream>
using namespace std;
const long long k=2305448,k0=1721424;//1 1 1600,1 1 1
const long long k400=146097,k400bc=146100;
void doing(long long n){
//……
	if(n>=k){
		int s400=(n-k)/k400;
		i=k+s400*k400;
		year=1600+s400*400;
	}
	else if(n<k0){
		int s400bc=(n)/k400bc;
		i=s400bc*k400bc;
		year+=s400bc*400;
	}
	else{
		i=k0;
		year=1;
	}
//……
}
```

现在，[即使同时关闭同步流与 O2 优化也不会 TLE 了](https://www.luogu.com.cn/record/196265502)。氨醛苛銬。

其实这道题还可以卡常的地方多的很，读者~~有兴趣可以去一一实践~~。

---

## 作者：dear_deer_land (赞：3)

## 题意

给出一个儒略日日期，需要我们将它转化成格里高利历（公历）日期。\
推荐一个好用的小工具，可以帮助检验代码问题：[儒略日数和日干支计算器](https://ytliu0.github.io/ChineseCalendar/Julian_simp.html)，注意表格中的日期如果是公元前的话要减一，建议看中部的蓝字显示的日期。

## 思路

其实就是暴力模拟，但是需要注意不少要点，也可以说是坑点。

- 闰年的判断方式不同，在 $1852$ 及以前判断闰年只需要判断是否为 $4$ 的倍数即可，但在 $1853$ 及以后，判断闰年的方法便变为需要满足年份是 $400$ 的倍数或者年份是 $4$ 的倍数且不是 $100$ 的倍数。
- 当年份是公元前的年份时，因为没有公元零年，必须将年份先加一，再判断是否为 $4$ 的倍数。\
  这样看来，这个题还是比较水的，但是当你打完下面给出的暴力后，会看到只有 $50$ 分，并且还是超时了。\
  暴力 $60$ 分代码：

```
#include <bits/stdc++.h>
#define  int long long
#define  rint register int
#define  ll long long
#define  INF 0x3f3f3f3f
#define  LINF 0x3f3f3f3f3f3f3f3f
#define  bug puts("!!!====!!!=");
using namespace std;
int t,n,day,year,month,aly;
int date[2][13]={0,31,28,31,30,31,30,31,31,30,31,30,31,0,31,29,31,30,31,30,31,31,30,31,30,31};;
bool BC,flag,ru;
bool run(int x){
	if(BC){
		x++;
		if(x%4==0){
			return 1;
		}
		return 0;
	}
	if((x%400==0)||(x%4==0&&x%100!=0)||(x%4==0&&ru)){
		return 1;
	}
	return 0;
}
signed main(){
	BC=1;
	BC=1;
	cin>>t; 
	while(t--){
		cin>>n;
		BC=1;
		ru=1;
		year=-4713;
		month=1;
		day=1;
		while(1){
			if(year==1582){
				ru=0;
			}
			if(!run(year)){
				if(n>=355){
					n-=355;
					if(year!=1582){
						n-=10;
						if(n<0){
							n+=365;
							break;
						}
					}
					year++;
					if(year==0){
						year++;
						BC=0;
					}
				}
				else{
					break;
				}
			}
			else{
				if(n>=356){
					n-=356;
					if(year!=1582){
						n-=10;
						if(n<0){
							n+=366;
							break;
						}
					}
					year++;
					if(year==0){
						year++;
						BC=0;
					}
				}
				else{
					break;
				}
			}
		}
		flag=run(year);
		while(n--){
			day++;
			if(day==date[flag][month]+1){
				day=1;
				month++;
			}
			if(year==1582&&month==10&&day==5){
				day=15;
			}
		}
		cout<<day<<' '<<month<<' '<<abs(year);
		if(BC){
			cout<<" BC";
		}
		cout<<'\n';
	}
    return 0;
}
```

那么此刻，很多人既不知道如何优化，又不想重写代码，诶，那么此时，我们会发现一个规律：在 $1852$ 年（既开始使用格里高利历）后，每 $400$ 年为一个周期，那么我们选择 $80000$、$8000$、$800$ 来进行循环，只需要在循环时把减去每年的天数变成减去 $80000$、$8000$、$800$ 年的天数即可。\
那么这样我们便得到了一段优化代码：

```

		while(n-29219400>0){
			n-=29219400;
		   year+=80000;
		}
		while(n-2921940>0){
			n-=2921940;
			year+=8000;
		}
		while(n-292194>0){
			n-=292194;
			year+=800;
		}
```

## 完整代码

~~其实一开始我是写火车头的，但是害怕审核直接因为码风不好直接给我毙掉，含泪删代码。~~

```
#include <bits/stdc++.h>
#define  int long long
#define  rint register int
#define  ll long long
#define  INF 0x3f3f3f3f
#define  LINF 0x3f3f3f3f3f3f3f3f
#define  bug puts("!!!====!!!=");
using namespace std;
int t,n,day,year,month,aly;
int date[2][13]={0,31,28,31,30,31,30,31,31,30,31,30,31,0,31,29,31,30,31,30,31,31,30,31,30,31};;
bool BC,flag,ru;
bool run(int x){
	if(BC){
		x++;
		if(x%4==0){
			return 1;
		}
		return 0;
	}
	if((x%400==0)||(x%4==0&&x%100!=0)||(x%4==0&&ru)){
		return 1;
	}
	return 0;
}
signed main(){
	BC=1;
	BC=1;
	cin>>t; 
	while(t--){
		cin>>n;
		BC=1;
		ru=1;
		year=-4713;
		month=1;
		day=1;
		if(n>=1721424){
			n-=1721424;
			BC=0;
			year=1;
		}
		while(1){
			if(year==1582){
				ru=0;
			}
			if(!run(year)){
				if(n>=355){
					n-=355;
					if(year!=1582){
						n-=10;
						if(n<0){
							n+=365;
							break;
						}
					}
					year++;
					if(year==0){
						year++;
						BC=0;
					}
				}
				else{
					break;
				}
			}
			else{
				if(n>=356){
					n-=356;
					if(year!=1582){
						n-=10;
						if(n<0){
							n+=366;
							break;
						}
					}
					year++;
					if(year==0){
						year++;
						BC=0;
					}
				}
				else{
					break;
				}
			}
			if(year==1583){
				break;
			}
		}
		while(n-29219400>0){
			n-=29219400;
		   year+=80000;
		}
		while(n-2921940>0){
			n-=2921940;
			year+=8000;
		}
		while(n-292194>0){
			n-=292194;
			year+=800;
		}
		while(n-365>0){
			n-=365;
			if((year%4==0&&year%100!=0)||year%400==0){
				n--;
			}
			year++;
		}
		flag=run(year);
		while(n--){
			day++;
			if(day==date[flag][month]+1){
				day=1;
				month++;
				if(month==13){
					month=1;
					year++;
					flag=run(year);
				}
			}
			if(year==1582&&month==10&&day==5){
				day=15;
			}
		}
		cout<<day<<' '<<month<<' '<<abs(year);
		if(BC){
			cout<<" BC";
		}
		cout<<'\n';
	}
    return 0;
}
```

---

## 作者：Super_Cube (赞：3)

# Preface

登洛谷看到首页有个神秘的题解补充计划，就顺手来写了。

这题好像是我初二的某次模拟赛 T1，没记错就是场切。

想到当时学 OI 的快乐生活，真是满满的回忆啊。

# Solution

首先一个很明显的思路，对于输入的总天数，如果大于当前所判断年份的天数，那么让总天数减去这一年天数，年份向后。

然后判断剩余的总天数，如果大于当前所判断月份的天数，那么让总天数减去这一月天数，月数向后。

最后剩余的总天数就是那一个月的所在日期。

很明显会 TLE...

想想看慢在哪里？当总天数很大的时候，你只是一年一年的判断并减去，这就是问题所在。

不难发现，对于 1600 年及以后的每 400 年所经过的天数都是一样的，为 146097 天，所以只要总天数大于到 1600 年后所需天数，就可以用除法算出来经过的周期数。用总天数减去经过的周期所需的天数来代替循环一年一年跳，这样代码就会快到飞起。

剩下的在 1600.1.1 之前的呢？ 你会发现这时总天数还挺小的，用之前的思路可过。

神机加上 O2 优化，助力每一个神秘复杂度代码实现 AC 梦！

# Code

```cpp
while (T--) {
	scanf("%lld", &n);
	++n;
	if (n >= 2305449) {  // 1600.1.1
		n -= 2305448;
		year = 1600;
		long long tmp = (n - 1) / 146097;
		n -= tmp * 146097;
		year += tmp * 400;
	} else
		year = -4713;
	for (; n > Day(year); ++year) {
		if (!year)
			continue;
		n -= Day(year);
	}
	lim[2] = 28 + special(year);
	if (year == 1582)
		lim[10] = 21;
	else
		lim[10] = 31;
	for (month = 1; n > lim[month]; ++month)
		n -= lim[month];
	if (year == 1582 && month == 10) {
		if (n <= 4)
			day = n;
		else
			day = n + 10;
	} else
		day = n;
	printf("%d %d ", day, month);
	if (year >= 0)
		printf("%d\n", year);
	else
		printf("%d BC\n", -year);
}
```

---

## 作者：Macesuted (赞：3)

**Update: 被官方数据 hack 了一个点，已修正，对此表示抱歉。**

[题面](https://www.luogu.com.cn/problem/P7075)

# 分析

听说可以用二分做，但是我直接模拟。

最开始我先直接把所有的日子直接转换成儒略历。

若转换后没有超过公元年，那么直接输出，**结束**。

若超过公元年，先给年号 $+1$ （跳过 $0$ 年），然后再判断：

若没有超过 1582.10.5，直接输出。

否则，给天数加上十天，然后开始补格里高利历与儒略历之间的差距：每 400 年 3 天的差距。

补完之后输出就可以了。

注意你需要对这个做法进行加速，不然会 TLE 10 pts。

细节在代码里有。

# 代码

比较丑陋。考场上炸了 90 pts，因为第一次膜 $1461$ 时没有特殊处理导致 `day` 直接等于 $0$，直接爆炸。后来被官方数据又 hack 一个点，是中间的地方膜 $146097$ 时没有特殊处理的原因。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
T read(void) {
    T f = 1, num = 0;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -f;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        num = (num << 3) + (num << 1) + (c ^ 48);
        c = getchar();
    }
    return f * num;
}

const int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

inline int daysBefore(int year, int month) {  //儒略历天数
    if (month != 2) return days[month - 1];
    if ((year > 0 && year % 4 == 0) || (year < 0 && year % 4 == -1)) return 29;
    return 28;
}
inline int daysNear(int year, int month) {  //格里高利历天数
    if (month != 2) return days[month - 1];
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) return 29;
    return 28;
}
inline int daysInYear(int year) {  //格里高利历每年天数
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) return 366;
    return 365;
}

int main() {
    int Q = read<int>();
    while (Q--) {
        long long day = read<long long>();
        int year = -4713 + day / 1461 * 4, month = 1;
        //4年一个循环，4年天数共365*4+1=1461
        day %= 1461;
        day++;  //注意开始的时候是一月一号，所以要加一
        //公元年特判
        if (year >= 0) year++;
        //暴力弥补剩下的月份
        while (day > daysBefore(year, month)) {
            day -= daysBefore(year, month);
            if (++month == 13) month = 1, year++;
            if (year == 0) year++;
        }
        if (year < 0)  //公元前
            printf("%lld %d %d BC\n", day, month, -year);
        else {
            if (year > 1582 || (year == 1582 && month > 10) || (year == 1582 && month == 10 && day > 4)) {
                //如果超过了1582.10.4
                day += 10;  //补上十天
                //暴力处理月份
                if (daysBefore(year, month) < day) {
                    day -= daysBefore(year, month);
                    if (++month == 13) month = 1, year++;
                }
                //每400年补上3天
                long long plus = (year - 1600) / 400 * 3;
                //暴力枚举不足400年的剩余部分
                for (register int i = (year - 1600) / 400 * 400 + 1600; i < year || (i == year && month > 2); i += 100)
                    if (i % 400 != 0) plus++;
                //加上
                day += plus;
                //先将没有满的年份补满
                while (daysNear(year, month) < day) {
                    day -= daysNear(year, month);
                    if (++month == 13) {
                        month = 1, year++;
                        break;
                    }
                }
                //每400年一个轮回，400*365+100-4+1=146097天
                day--, year += day / 146097 * 400, day %= 146097, day++;
                while (daysInYear(year) < day) day -= daysInYear(year++);  //对于多余的年份加速处理
                //处理剩余出的月份
                while (daysNear(year, month) < day) {
                    day -= daysNear(year, month);
                    if (++month == 13) month = 1, year++;
                }
            }
            printf("%lld %d %d\n", day, month, year);
        }
    }
    return 0;
}
```

---

## 作者：pomelo_nene (赞：3)

写了个很丑的代码。因为是个大模拟（没写二分）讲一下具体实现思路。因为是考场代码所以丑的 1p，函数也没装思路也没写，所以代码用精神领略即可。

这个东西有点长。考虑一下怎么把它搞得好看一点。

- 公元前的闰年与公元不太一样，拆开。注意没有公元 $0$ 年；   
- $1582.10.5 \sim 1582.10.14$ 不存在，左右拆开；   
- 观看数据范围，年份可能很大，需要一个优秀的算法去算年份。这里拆成 $400$ 剩下的可以暴力。比较好处理的是将 $1582.10.15 \sim 1600.12.31$ 拆开，剩下的处理。

通过计算器可以得出：

- $0 \leq r \leq 1721423$，此时是公元前；   
- $1721424 \leq r \leq 2299160$，此时是公元，但是是在 $1582.10.4$ 之前；   
- $2299161 \leq r \leq 2299238$，此时在 $1582.10.15 \sim 1600.12.31$ 范围内；   
- 剩下的暴力算出 $400$ 年为 $146097$ 天。随便算算就能算出来。

注意一下运算符优先级，推荐将日期的多少天后写成一个函数，比较好看。不至于每个情况都要写一遍，虽然也不难打。

几个坑点：

- 待会儿附个数据看你的边界；    
- 负数取模答案是负数，所以 `(-1%4==1)==false`；   
- 闰年判断注意二路运算符优先级；   
- 修改月和日的时候不要混淆了；   
- 注意开 `long long`。

贴个[代码](https://paste.ubuntu.com/p/mDBckGfYhq/)。因为暴力跑了四百年没有打表优化，所以会很慢，时间复杂度是 $O(Qc)$，其中 $c$ 是一个常数，最坏等于 $400+12+31=443$。

数据点：[julian4.in](https://paste.ubuntu.com/p/8RWQY9rRv6/) & [julian4.ans](https://paste.ubuntu.com/p/FsbbynfTj5/)。这个数据点涵盖了以下坑点：

- 公元前闰年；   
- 不存在的公元 $0$ 年；   
- 适用儒略历的公元闰年（$4,100,400$）；   
- 不存在的 $1582.10.5 \sim 1582.10.14$；   
- $1600,1601$ 与 $1583$ 的边界（这份代码的需要的调试点）；   
- 使用格里高利历的公元闰年（$4,100,400$）；   
- 答案比较大的点。

希望能有所帮助。

哇我的数据还没随机数据强，权当玩玩就好了。

---

## 作者：Piwry (赞：3)

~~毒瘤大模拟题。~~

![chenzhe](https://cdn.luogu.com.cn/upload/image_hosting/lh2jai60.png)

调了我三小时...最后发现是在某一处忘记把“公元前一年”算进闰年了。

“多组数据”真的很容易使人离开“暴力 - 预处理”的思路思考 \fad。

实质上地成功使我挂掉 CSP 2020 :(。

## 解析

虽然直接 `if` 套 `if` 大模拟也不是不能做，但考虑到调试的难度，我们试着找到一个**便于实现**的做法。

首先发现大部分讨论都集中在【公元 $1582$ 年 $10$ 月 $15$ 日】前，因此考虑将答案在这日期内的 $r$ 都预处理出来。注意到从 $1600$ 正好可以被 $400$ 整除，为了方便后面的讨论，我们干脆直接预处理到【公元 $1600$ 年 $1$ 月 $1$ 日】。

这部分最大的 $r$ 是 $10^6$ 的量级，不会炸时间或空间。

接着可以想到以 $400$ 年为一块地跳，具体实现取模即可；于是接下来就只许考虑在 $400$ 年内的日期增量了。

然而每 $400$ 年的块内的讨论也很麻烦...发现 $400$ 年也不大，因此可以考虑**将日期增量在 $400$ 年内的具体增量（年，月，日）也预处理出来**。

（可能描述得不是很清楚...具体可见代码。）

于是这题就做完了，去掉读入代码 2K 都不到；且主要都是单纯的暴力 `for` 循环模拟，调试应该不会太难。

## CODE

```cpp
#include <cstdio>
#define ll long long

const int MAXN =3e6+20;

/*------------------------------IO------------------------------*/

ll read(){
	ll x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

void write(const int &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

/*------------------------------Main------------------------------*/

int m[12] ={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

struct qaq{
	int Y, M, D;
}rem[MAXN], rem_400[400*366];
int tot =-1, tot_400 =-1;

void pre(){/*注意 1600.1.1 也会被统计进去*/
	for(int Y =-4712, M =1, D =1; Y < 1600; ++D){
		int check =-1;
		if(Y <= 1582)/*<<- */
			check =(int)((-Y)%4 == 0);
		else
			check =(int)(Y%400 == 0 || (Y%4 == 0 && Y%100 != 0));
		
		if(D > m[M-1]+(int)(M == 2)*check){
			D =1, ++M;
			if(M > 12)
				M =1, ++Y;
		}
		
		if(Y == 1582 && M == 10 && D == 5)
			D =15;
		
		++tot;
		rem[tot].Y =Y, rem[tot].M =M, rem[tot].D =D;
	}
}

void pre2(){/*把 400 年内的也处理出来*/
	for(int Y =0, M =1, D =1; Y < 400; ++D){
		if(D > m[M-1]+(int)(M == 2)*(int)(Y == 0 || (Y%4 == 0 && Y%100 != 0))){
			D =1, ++M;
			if(M > 12)
				M =1, ++Y;
		}
		
		++tot_400;
		rem_400[tot_400].Y =Y, rem_400[tot_400].M =M, rem_400[tot_400].D =D;
	}
}

void put_ans(const int &Y, const int &M, const int &D){
	write(D), putchar(' '), write(M), putchar(' ');
	if(Y <= 0)
		write(-Y+1), putchar(' '), putchar('B'), putchar('C');
	else
		write(Y);
	putchar('\n');
}

int main(){
//	freopen("julian.in", "r", stdin);
//	freopen("julian.out", "w", stdout);
	pre();
	pre2();
	for(int t =0, T =read(); t < T; ++t){
		ll r =read();
		if(r <= tot)
			put_ans(rem[r].Y, rem[r].M, rem[r].D);
		else{
			r -=tot;
			int Y =1600;
			if(r >= 365*400+100-3){
				Y +=(r/(365*400+100-3))*400;
				r %=365*400+100-3;
			}
			put_ans(Y+rem_400[r].Y, rem_400[r].M, rem_400[r].D);
		}
	}
}
```

---

## 作者：TainityAnle (赞：2)

这篇题解本来有很多前言，但是说多了都是泪，还是不说了。

### 题意

给定 $n$，请你求从公元前 4713 年 1 月 1 日往后数 $n$ 天的日期。

简明的题意，屎山的代码。

### 思路

发现公元 1582 年 10 月 4 日之后改了历法，那么这里就是一个转折点。为了防止出错，我选择将此之前和此之后分开处理，写成 `solve1()` 和 `solve2()`。

- **儒略历处理**

  每 $400$ 年有 $146100$ 天。我的做法的流程如下：

  1. 设 $N$ 为经过了多少个整 $400$ 年，即取 $N=\lfloor\frac{n}{146100}\rfloor$，然后使天数 $n$ 减去 $N\times 146100$。
  2. 取年份 $y=-4713+N\times400$。
  3. 因为公元零年并不存在，所以若 $y>1$，使 $y$ 自增 $1$。
  4. 因为公元前 4713 年 1 月 1 日被记作第 $0$ 天，我们又是把公元前 4713 年 1 月 1 日当做第 $1$ 天数的，所以要把 $n$ 加上 $1$。注意这里不可以一开始就这样做，否则会 [$80$ 分](https://www.luogu.com.cn/record/196853142)。
  5. 处理不足 $400$ 年的整年。这一块可以枚举。从已经得到的 $y$ 开始，只要 $n>366$，每次判断 $y$ 是否是闰年。若是，$n$ 每次减去 $366$，否则每次减去 $365$。每次 $y$ 增加 $1$。
  6. 处理月。设 $month_i$ 表示 $i$ 月有 $month_i$ 天。先判断现在得到的年份 $y$ 是否为闰年，若是把 $month_2$ 设为 $29$，否则设为 $28$。从一月开始，设月份 $yue=1$，只要 $n>month_{yue}$，$yue$ 每次增加 $1$，$n$ 减去 $month_{yue}$。
  7. 这时我们已经处理好了年和月，剩下的 $n$ 就是日期。但是还有很多细节等待我们处理。让我们一一处理这些细节。  
     由于前面年是一个一个加的，所以有可能加到 $0$ 年，把它变成 $1$ 年就好了。  
     因为月份是从 $1$ 开始数的，所以有可能会数到 $13$ 月。需要把年份加 $1$，把月份变为 $1$。  
     输出时，要输出 $|y|$，若 $y<0$，不要忘了输出 `BC`。

好的那么 `solve1()` 就大功告成了。

`solve2()` 只需要在 `solve1()` 的基础上改一些地方。

1. 每 $400$ 年有 $146097$ 天，所以取 $N=\lfloor\frac{n}{146097}\rfloor$。
2. 我们是从公元 1582 年 10 月 15 日开始数的，所以要把 $n$ 减去 $2299171$，这是从公元前 4713 年 1 月 1 日到公元 1582 年 10 月 15 日的天数；把 $y$ 的初始值赋成 $1582$，再把 $n$ 加上 $287$，这是从 1 月 1 日到 10 月 15 日的天数。
3. 免去了判断公元前和零年的判断，因为最少到 1582 年。

考虑主函数里怎么写。考虑到换历法删除的 $10$ 天，若该日期在公元 1582 年 10 月 15 日（含）以后，直接把 $n$ 加上 $10$ 即可。

按儒略历手算可以算出公元 1582 年 10 月 4 日的儒略日是 $2299160$。所以判断若 $n\le2299160$，按儒略日用 `solve1()` 处理，否则将 $n$ 加上 $10$，用 `solve2()` 处理。

最后也是最重要的判断闰年。仔细读题可以发现，1582 年之前用的儒略历，只要年份是 $4$ 的倍数就闰，否则就是我们熟悉的闰年法。对于公元前的年份 $x$，应把它看做 $-x-1$ 年。

到这就写完了，可是这些调了我 3 天。我的码风不怎么样，写了 70 行。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,x;
int month[15]= {29,31,28,31,30,31,30,31,31,30,31,30,31};
bool check(int x) {
	if(x<=1582) {//如果是儒略历判断闰年就是4年一闰 
		if(x<=0) x=-x-1;
		return x%4==0;
	}
	if(x%400==0||(x%4==0&&x%100!=0)) return 1;//格里高利历判断闰年 
	return 0;
}
void solve1(int x) {
	int N=x/146100;
	int y=-4713+N*400;
	if(y>1) y++;
	x-=N*146100;//处理整400年 
	x++;
	for(; x>366; y++) {//处理整年 
		int f=0;
		if(y==0) y++;
		f=check(y);
		if(f) x-=366;
		else x-=365;
	}
	int yue=1;
	int f=0;
	f=check(y);
	if(f) month[2]=29;//如果是闰年，把month[2]设成29 
	for(; yue<=12&&x>month[yue]; yue++) x-=month[yue];//处理月 
	if(y==0) y=1;
	if(yue==13) yue=1,y++;//处理细节 
	cout<<x<<' '<<yue<<' '<<abs(y);
	if(y<0) cout<<" BC";
	cout<<endl;
}
void solve2(int x) {
	x-=2299171;
	int y=1582,yue=1;
	x+=287;
	int N=x/146097;
	y+=N*400;
	x-=N*146097;
	x++;
	for(; x>366; y++) {
		int f=0;
		f=check(y);
		if(f) x-=366;
		else x-=365;
	}
	int f=0;
	f=check(y);
	if(f) month[2]=29;
	for(; yue<=12&&x>month[yue]; yue++) x-=month[yue];
	if(yue==13) yue=1,y++;
	cout<<x<<' '<<yue<<' '<<y;
	cout<<endl;
}
signed main() {
	cin>>T;
	while(T--) {
		cin>>x;
		month[2]=28;
		if(x>=2299161) x+=10;
		if(x<=2299160) solve1(x);//判断用solve1还是solve2 
		else solve2(x);
	}
	return 0;
}
```

---

## 作者：normalpcer (赞：2)

## 题意简述
给定若干个儒略日，记录它们的年月日表示。

## 分析
大致分为以下几个需要处理的时间段。

### 公元前
此时 $x < 1721424$。

通过与公元元年 1 月 1 日的距离反推。

首先可以计算得，1/1/1（年/月/日）的儒略日为 $1721424$，这两天的距离则为 $1721424 - x$（含 $x$，不含 1/1）。此时 $4$ 年为一个周期，一个周期共有 $1461$ 天。先加上 $4\lfloor \frac{1721424 - x}{1461} \rfloor$ 年跳到一个整周期（此时我们会位于某一年的 1 月 1 日，而它的前一年为闰年），然后逐年向下减，找到第一个不晚于它的年初。

接下来，对剩余的负数取相反数，表示从这个 1 月 1 日（不含）到目标日期（包含）的天数。

我们可以用一个函数来计算一年中的某天对应的月和日。可以先计算出每个月天数的前缀和，然后二分查找月份，计算日期即可。

代码如下：
```cpp
const int AverageYearsMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
const int LeapYearsMonth[] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
// 计算年内的某个日期
// 传入：从某年的 1/1 到目标日期的天数，左闭右开。
// 返回：月，日（可直接输出）
std::pair<int, int> calculateDateInYear(ll days, bool leap = false) {
    const int *YearMonth = leap? LeapYearsMonth: AverageYearsMonth;
    // 一个月中包含的天数恰好大于 days
    auto monthPointer = std::upper_bound(YearMonth, YearMonth + 13, days);
    auto month = std::distance(YearMonth, monthPointer);
    auto currentDay = days - YearMonth[month - 1] + 1;
    return {month, currentDay};
}
```
### 公元 1582 年 10 月 4 日（含）以前
此时 $1721424\le x < 2299161$ 。

同样地，我们可以用 $x-1721424$ 计算从 1/1/1 到目标日期的天数（左闭右开），周期和公元前相同。

跳过若干个整周期之后，我们需要向后拨若干年，找到最晚的一年，使得剩余天数大于等于 $0$。

计算月和日即可。

### 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）
这段日期不存在。

### 公元 1582 年 10 月 15 日（含）以后
此时 $x\le 2299161$。
首先可以注意到，历法的更改实际上只会影响 1583/1/1 之后的日期。在此之前的日期减去被删除的 10 天，当做儒略历处理即可。

首先计算出，1583/1/1 的儒略日为 2299239。

不妨先凑一个整，暴力逐年推到 1601/1/1，然后考虑周期。每一次跳过若干个整周期，都跳到目标年份向下取整。

对于一个 $400$ 年（$146097$ 天）的周期，特判 $400$ 的倍数。

对于一个 $100$ 年（$36524$ 天）的周期，特判 $100$ 的倍数。

接下来跳过若干个 $4$ 年（$1461$ 天）的周期，再逐年逼近即可。

剩余的数即为当年的 1 月 1 日到目标日期的距离（左闭右开），计算日期并输出。

## 代码
```cpp
/**
 * @link https://www.luogu.com.cn/problem/P7075
 */

#include <bits/stdc++.h>
using ll = long long;

namespace Solution {
    int Q;

    const int AverageYearsMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
    const int LeapYearsMonth[] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
    
    bool isLeap(int year, bool usingGregorian=true) {
        if (year<0)  year++;
        if (not usingGregorian)
            return (year%4 == 0);
        else
            return (year%400 == 0) or (year%100!=0 and year%4==0);
    }
    // 计算年内的某个日期
    // 传入：从某年的 1/1 到目标日期的天数，左闭右开。
    // 返回：月，日（可直接输出）
    std::pair<int, int> calculateDateInYear(ll days, bool leap=false) {
        const int *YearMonth = leap? LeapYearsMonth: AverageYearsMonth;
        // 一个月中包含的天数恰好大于 days
        auto monthPointer = std::upper_bound(YearMonth, YearMonth + 13, days);
        auto month = std::distance(YearMonth, monthPointer);
        auto currentDay = days - YearMonth[month - 1] + 1;
        return {month, currentDay};
    }
    void BC(ll julian) {
        auto daysNegativeCount = 1721424 - julian;  // 到 1/1/1 的天数
        auto termsCount = daysNegativeCount / 1461;  // 周期（4 年）数量
        auto yearAbs = termsCount * 4;  // 年份的绝对值
        daysNegativeCount %= 1461;  // 向前拨回若干周期后剩余的天数；到某年的 1 月 1 日，该年份绝对值是 4 的倍数
        auto newDays = daysNegativeCount;  // 再拨回一年，这一年一定是一个闰年
        while (newDays > 0) {
            newDays = newDays - 365 - isLeap(-yearAbs-1, false);
            yearAbs++;
        }

        int dayIndex = 0 - newDays;  // 目标日期到那年 1 月 1 日的天数，左闭右开

        auto [month, day] = calculateDateInYear(dayIndex, isLeap(-yearAbs, false));
        printf("%d %d %lld BC\n", day, month, yearAbs);
    }
    void DC_WithJulianCalender(ll julian) {
        auto daysCount = julian - 1721424;  // 到 1/1/1 的天数
        auto termsCount = daysCount / 1461;  // 四年周期
        auto years = termsCount * 4 + 1;  // 此时是这一年的 1/1
        daysCount %= 1461;
        auto newDays = daysCount;
        // 向后拨若干年，直到这个数大于等于 0 时的最小值
        while (newDays - 365 - isLeap(years, false) >= 0) {
            newDays = newDays - 365 - isLeap(years, false);
            years++;
        }
        auto [month, day] = calculateDateInYear(newDays, isLeap(years, false));
        printf("%d %d %lld\n", day, month, years);
    }
    void DC_WithGregorianCalender(ll julian) {
        const auto newYearJulianDay = 2299249-10;  // 1583/1/1 的儒略日
        if (julian < newYearJulianDay) {
            DC_WithJulianCalender(julian+10);
            return;
        }
        auto daysAfterNewYear = julian - newYearJulianDay;  // 从 1583/1/1 开始，左闭右开
        // 先暴力推 17 年
        auto year = 1583LL;  // 当前处于 year/1/1
        while (daysAfterNewYear - 365 - isLeap(year) >= 0) {
            daysAfterNewYear = daysAfterNewYear - 365 - isLeap(year);
            year++;
            if (year == 1601)  break;
        }
        if (year > 1600) {
            // 对于一个 400 年的大周期
            const auto bigTermLength = 146097;
            auto bigTermCount = daysAfterNewYear / bigTermLength;
            daysAfterNewYear %= bigTermLength;
            year += bigTermCount * 400; assert(year%400==1);

            // 直接特判 400 年的倍数
            if (daysAfterNewYear >= bigTermLength - 366) {
                year += 399;
                auto [month, day] = calculateDateInYear(daysAfterNewYear - bigTermLength + 366, 1);
                printf("%d %d %lld\n", day, month, year);
                return;
            }

            // 100 年的中等周期
            const auto midTermLength = 36524;
            auto midTermCount = daysAfterNewYear / midTermLength;
            daysAfterNewYear %= midTermLength;
            year += midTermCount * 100;

            // 特判 100 的倍数
            if (daysAfterNewYear >= midTermLength - 365) {
                year += 99;
                auto [month, day] = calculateDateInYear(daysAfterNewYear - midTermLength + 365, 0);
                printf("%d %d %lld\n", day, month, year);
                return;
            }

            // 4 年
            const auto littleTermLength = 1461;
            auto littleTermCount = daysAfterNewYear / littleTermLength;
            daysAfterNewYear %= littleTermLength;
            year += littleTermCount * 4;
            while (daysAfterNewYear - 365 - isLeap(year) >= 0) {
                daysAfterNewYear = daysAfterNewYear - 365 - isLeap(year);
                year++;
            }
            auto [month, day] = calculateDateInYear(daysAfterNewYear, isLeap(year));
            printf("%d %d %lld\n", day, month, year);
        } else {
            auto [month, day] = calculateDateInYear(daysAfterNewYear, isLeap(year));
            printf("%d %d %lld\n", day, month, year);
        }
    }

    void solve() {
        std::cin >> Q;
        ll x;

        for (auto i = 0; i < Q; i++) {
            std::cin >> x;
            if (x < 1721424) {
                BC(x);// 1/1/1 BC 及以前
            } else if (x <= 2299160) {
                DC_WithJulianCalender(x);  // 适用儒略历
            } else {
                DC_WithGregorianCalender(x);  // 适用格里高利历
            }
        }
    }
}

int main() {
    Solution::solve();
    return 0;
}
```

---

## 作者：Bismuth_Sulfate (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7075)

## 题意简述

给你 $T$ 个数代表天数，然后你要输出这 $T$ 个数对应的日期。然后把数字 $\to$ 日期的方式告诉你了。

## 分析

这还不简单吗？都把计算方法告诉你了，模拟不就完了？

首先先进行一个分类讨论，把 $1582/10/4$ 之前和 $1582/10/15$ 分开。

[用这个软件](https://ytliu0.github.io/ChineseCalendar/Julian_simp.html)可以实现转换，在这个软件里可以看到 $1582/10/15$ 是第 $2299161$ 天。

于是可以写个 `if` 然后分开。

### 对于儒略历

由于这部分日期只有从公元前 $4713$ 年到公元 $1582$ 年的部分，总共只有大约六千多年，可以直接暴力伺候。

在存储时，我们可以不傻乎乎的存公元前 $4713$ 年，我们可以存一个 $-4712$ 进去，输出时再改一下。这样做的好处十分明显，就不用写两个判闰年函数了。

然后暴力，把输入值 $r$ 每次减一个 $365$，然后如果当前年是闰年就再减一个 $1$，然后把年份值加一，直到最终 $r$ 不足 $366$。

接着用类似的方法，暴力过掉月份和日期，最后输出就行。

```cpp
y=-4712,m=1,d=1;
while(r > 365){
    r -= 365;
    if(!(y%4))r--;
    y++;
}
bool leap=!(y%4);
if(r==365 && !leap){
    r=0;
    y++;
}
if(leap)month[1]=29;
else month[1]=28;
for(int i = 0;i < 12;++i){
    if(r >= month[i]){
        m++;
        r -= month[i];
    }else{
        d += r;
        break;
    }
}
if(y < 1){
    printf("%lld %lld %lld BC\n",d,m,-y+1);
}else{
    printf("%lld %lld %lld\n",d,m,y);
}
```

### 对于格里历

我们可以从 $1582/10/15$ 开始，把时间减去 $2299161$，把 $1582/10/15$ 作为 $0$。

然后先暴力把 $1582$ 年过完，走到 $1583$ 年，再暴力。

但有个问题：题目说答案年份可以干到 $10^9$ 去。这很明显原地超时。

我们可以这样做：以 $400$ 年为一组，每次过 $146097$ 天，这样可以减少一点循环。

这样写出来能拿 $90$ 分，测试点 $10$ 会 $1.06\text{s}$ 极限超时。

没关系，再以 $10000$ 年为一组，每次再过 $3652425$ 天即可。

这样就能非常暴力的切掉这道题了。

~~顺便一提，我在写这段代码的时候关了同步流然后全用的 `printf`。~~

最终代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int month[12]={31,28,31,30,31,30,31,31,30,31,30,31};
bool leaF(int y){
    int n=0;
    if(y%4)n++;
    if(y%100)n++;
    if(y%400)n++;
    return !(n%2);
}
int q,r/*[100005]*/;
signed main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> q;
    /*for(int i = 0;i < q;++i)
    	cin >> r[i];*/
    for(int i = 0;i < q;++i){
        int y,m,d;
        cin >> r;
        if(r < 2299161){
            y=-4712,m=1,d=1;
            while(r > 365){
                r -= 365;
                if(!(y%4))r--;
                y++;
            }
            bool leap=!(y%4);
            if(r==365 && !leap){
                r=0;
                y++;
            }
            if(leap)month[1]=29;
            else month[1]=28;
            for(int i = 0;i < 12;++i){
                if(r >= month[i]){
                    m++;
                    r -= month[i];
                }else{
                    d += r;
                    break;
                }
            }
            if(y < 1){
                printf("%lld %lld %lld BC\n",d,m,-y+1);
            }else{
                printf("%lld %lld %lld\n",d,m,y);
            }
        }else{
            r -= 2299161;
            y=1582,m=10,d=15;
            for(int i = 0;i < 78;++i){
                if(r){
                    d++;
                    if(m==10&&d==32){
                        m++;
                        d -= 31;
                    }
                    if(m==11&&d==31){
                        m++;
                        d -= 30;
                    }
                    if(m==12&&d==32){
                        y++;
                        d -= 31;
                        m -= 11;
                    }
                }else{
                	break;
				}
				r--;
            }
            while(r > 3652425){
                r -= 3652425;
                y += 10000;
            }
            while(r > 146097){
                r -= 146097;
                y += 400;
            }
            while(r > 365){
                r -= 365;
                if(leaF(y))r--;
                y++;
            }
            bool leap=leaF(y);
            if(r==365 && !leap){
                r=0;
                y++;
            }
            if(leap)month[1]=29;
            else month[1]=28;
            for(int i = 0;i < 12;++i){
                if(r >= month[i]){
                    m++;
                    r -= month[i];
                }else{
                    d += r;
                    break;
                }
            }
            printf("%lld %lld %lld\n",d,m,y);
        }
    }
    return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/141578589)。

---

## 作者：qiuby123456 (赞：1)

本篇文章代码部分使用 C 语言编写。

# 处理闰年

在 $1582$ 年 $10$ 月 $4$ 日及以前，闰年只需要被 $4$ 整除即可。\
在 $1582$ 年 $10$ 月 $15$ 日及以后，
- 如果年份被 $400$ 整除：是闰年
- 否则如果年份被 $100$ 整除：是平年。
- 否则如果年份被 $4$ 整除：是闰年。
- 否则：是平年。

函数如下：

```c
int is_a_leap_year(int y){
	if (y < 1582){
		return y % 4 == 0;
	}
	if (y % 400 == 0){
		return 1;
	}
	if (y % 100 == 0){
		return 0;
	}
	return y % 4 == 0;
}
```

# 处理月日

假设 $r$ 为一年内的儒略日，那么先处理月，再处理日。

- 如果当年是闰年，那么当年一月范围为第 $0$ 天到第 $30$ 天，二月范围为第 $31$ 天到第 $59$ 天，三月范围为第 $60$ 天到第 $90$ 天，四月范围为第 $91$ 天到第 $120$ 天，五月范围为第 $121$ 天到第 $151$ 天，以此类推。
- 如果当年是平年，那么当年一月范围为第 $0$ 天到第 $30$ 天，二月范围为第 $31$ 天到第 $58$ 天，三月范围为第 $59$ 天到第 $89$ 天，四月范围为第 $90$ 天到第 $119$ 天，五月范围为第 $120$ 天到第 $150$ 天，以此类推。

记当月一日为第 $0$ 天，则二日为第 $1$ 天，三日为第 $2$ 天，以此类推。

~~`if` 屎山~~代码如下：

```c
if (is_a_leap_year(year)){
	if (r < 31ll){//January
		month = 1;
	}
	else if(r < 60ll /*60 = 31 + 29*/){//February
		month = 2;
		r -= 31ll;
	}
	else if(r < 91ll /*90 = 31 + 29 + 31*/){//March
		month = 3;
		r -= 60ll;
	}
	else if(r < 121ll /*120 = 31 + 29 + 30 + 31*/){//April
		month = 4;
		r -= 91ll;
	}
	else if(r < 152ll /*151 = 31 + 29 + 31 + 30 + 31*/){//May
		month = 5;
		r -= 121ll;
	}
	else if(r < 182ll /*etc.*/){//June
		month = 6;
		r -= 152ll;
	}
	else if(r < 213ll /*etc.*/){//July
		month = 7;
		r -= 182ll;
	}
	else if(r < 244ll /*etc.*/){//August
		month = 8;
		r -= 213ll;
	}
	else if(r < 274ll /*etc.*/){//September
		month = 9;
		r -= 244ll;
	}
	else if(r < 305ll /*etc.*/){//October
		month = 10;
		r -= 274ll;
	}
	else if(r < 335ll /*etc.*/){//November
		month = 11;
		r -= 305ll;
	}
	else{//December
		month = 12;
		r -= 335ll;
	}
}
else{
	if (r < 31ll){//January
		month = 1;
	}
	else if(r < 59ll /*59 = 31 + 28*/){//February
		month = 2;
		r -= 31ll;
	}
	else if(r < 90ll /*90 = 31 + 28 + 31*/){//March
		month = 3;
		r -= 59ll;
	}
	else if(r < 120ll /*120 = 31 + 28 + 30 + 31*/){//April
		month = 4;
		r -= 90ll;
	}
	else if(r < 151ll /*151 = 31 + 28 + 31 + 30 + 31*/){//May
		month = 5;
		r -= 120ll;
	}
	else if(r < 181ll /*etc.*/){//June
		month = 6;
		r -= 151ll;
	}
	else if(r < 212ll /*etc.*/){//July
		month = 7;
		r -= 181ll;
	}
	else if(r < 243ll /*etc.*/){//August
		month = 8;
		r -= 212ll;
	}
	else if(r < 273ll /*etc.*/){//September
		month = 9;
		r -= 243ll;
	}
	else if(r < 304ll /*etc.*/){//October
		month = 10;
		r -= 273ll;
	}
	else if(r < 334ll /*etc.*/){//November
		month = 11;
		r -= 304ll;
	}
	else{//December
		month = 12;
		r -= 334ll;
	}
}
day = (int)r + 1;
```

# 处理儒略历年份

儒略历平年有 $365$ 天，闰年有 $366$ 天，每四年有一个闰年。一个 $4$ 年有 $1\ 461$ 天。\
在 $1582$ 年 $10$ 月 $4$ 日及以前采用儒略历，四年为一周期，则第 $n$ 周期第 $d$ 天的儒略日就是 $d+n\times1\ 461$。\
记公元前 $4713$ 年 $1$ 月 $1$ 日为第 $0$ 周期第 $0$ 个儒略日。\
对于每周期的第 $d$ 天，我们使用 `if` 语句。由此可以反推。\
要记得公元前 $4n+1$ 年 是闰年，公元（后）$4n$ 年 是平年。第 $0$ 个儒略日是公元前 $4713$ 年 $1$ 月 $1$ 日。\
人工（计算器）算得前 $2\ 299\ 161$ 个儒略日使用儒略历。

这部分~~未经优化~~代码如下：

```c
if (r < 2299161ll){
	//There are 2299161 numbers from 0 to 2 299 160.
	round1 = r / 1461ll;
	r -= round1 * 1461ll;
	if (r < 366ll){
		//Pay attention to that there are 366 days in the first year of a round.
		year = (int)round1 * 4 - 4712;
	}
	else if(r < 731ll /*731 = 366 + 365*/){
		year = (int)round1 * 4 - 4711;
		r -= 366ll;
	}
	else if(r < 1096ll /*1096 = 366 + 365 + 365*/){
		year = (int)round1 * 4 - 4710;
		r -= 731ll;
	}
	else{
		year = (int)round1 * 4 - 4709;
		r -= 1096ll;
	}
}
```

# 处理格里高利历年份

格里高利历平年有 $365$ 天，闰年有 $366$ 天，每 $400$ 年有 $97$ 个闰年，有 $146\ 097$ 天。\
在 $1582$ 年 $10$ 月 $15$ 日及以后采用格里高利历，从 $1600$ 年 $1$ 月 1 日开始的每四年为一周期，则由人工推理得第 $n$ 周期第 $d$ 天的儒略日就是 $2\ 159\ 351+d+n\times146\ 097$。\
记 $1582$ 年 $10$ 月 $15$ 日到 $1599$ 年 $12$ 月 $31$ 日为第 $0$ 周期第 $139\ 810$ 到 $146\ 096$ 个儒略日，共 $6\ 287$ 天。\
对于每周期的第 $d$ 天，我们使用 `if` 语句。由此可以反推。\
人工（计算器）算得从第 $2\ 299\ 161$ 个儒略日开始使用格里高利历。

这部分~~未经优化~~代码如下：

```c
else{
	round2 = (r -= 2159351ll) / 146097ll;
	r -= round2 * 146097ll;
	year = 1200 + (int)round2 * 400;//Accurate to four hundred years
	round2 = (r - 1ll) / 36524ll;
	r -= round2 * 36524ll;
	year += (int)round2 * 100;//Accurate to one hundred years
	round2 = r / 1461ll;
	r -= round2 * 1461ll;
	year += (int)round2 * 4;//Accurate to four years
	if (r < 366ll){
		//Pay attention to that there are only 365 days in the 101st, 201st, 301st year of a round.
		if (!is_a_leap_year(year)){
			--r;
		}
	}
	else if(r < 731ll /*731 = 366 + 365*/){
		++year;
		r -= 366ll;
	}
	else if(r < 1096ll /*1096 = 366 + 365 + 365*/){
		year += 2;
		r -= 731ll;
	}
	else{
		year += 3;
		r -= 1096ll;
	}
}
```

最后串起来即可。

完整 AC 代码：

```c
#include <stdio.h>
int is_a_leap_year(int y){
	if (y < 1582){
		return y % 4 == 0;
	}
	if (y % 400 == 0){
		return 1;
	}
	if (y % 100 == 0){
		return 0;
	}
	return y % 4 == 0;
}
int main(){
	long long r, round1, round2;
	int q, day, month, year;
	scanf("%d", &q);
	while (q--){
		scanf("%lld", &r);
		if (r < 2299161ll){
			//There are 2299161 numbers from 0 to 2 299 160.
			round1 = r / 1461ll;
			r -= round1 * 1461ll;
			if (r < 366ll){
				//Pay attention to that there are 366 days in the first year of a round.
				year = (int)round1 * 4 - 4712;
			}
			else if(r < 731ll /*731 = 366 + 365*/){
				year = (int)round1 * 4 - 4711;
				r -= 366ll;
			}
			else if(r < 1096ll /*1096 = 366 + 365 + 365*/){
				year = (int)round1 * 4 - 4710;
				r -= 731ll;
			}
			else{
				year = (int)round1 * 4 - 4709;
				r -= 1096ll;
			}
		}
		else{
			round2 = (r -= 2159351ll) / 146097ll;
			r -= round2 * 146097ll;
			year = 1200 + (int)round2 * 400;//Accurate to four hundred years
			round2 = (r - 1ll) / 36524ll;
			r -= round2 * 36524ll;
			year += (int)round2 * 100;//Accurate to one hundred years
			round2 = r / 1461ll;
			r -= round2 * 1461ll;
			year += (int)round2 * 4;//Accurate to four years
			if (r < 366ll){
				//Pay attention to that there are only 365 days in the 101st, 201st, 301st year of a round.
				if (!is_a_leap_year(year)){
					--r;
				}
			}
			else if(r < 731ll /*731 = 366 + 365*/){
				++year;
				r -= 366ll;
			}
			else if(r < 1096ll /*1096 = 366 + 365 + 365*/){
				year += 2;
				r -= 731ll;
			}
			else{
				year += 3;
				r -= 1096ll;
			}
		}
		if (is_a_leap_year(year)){
			if (r < 31ll){//January
				month = 1;
			}
			else if(r < 60ll /*60 = 31 + 29*/){//February
				month = 2;
				r -= 31ll;
			}
			else if(r < 91ll /*90 = 31 + 29 + 31*/){//March
				month = 3;
				r -= 60ll;
			}
			else if(r < 121ll /*120 = 31 + 29 + 30 + 31*/){//April
				month = 4;
				r -= 91ll;
			}
			else if(r < 152ll /*151 = 31 + 29 + 31 + 30 + 31*/){//May
				month = 5;
				r -= 121ll;
			}
			else if(r < 182ll /*etc.*/){//June
				month = 6;
				r -= 152ll;
			}
			else if(r < 213ll /*etc.*/){//July
				month = 7;
				r -= 182ll;
			}
			else if(r < 244ll /*etc.*/){//August
				month = 8;
				r -= 213ll;
			}
			else if(r < 274ll /*etc.*/){//September
				month = 9;
				r -= 244ll;
			}
			else if(r < 305ll /*etc.*/){//October
				month = 10;
				r -= 274ll;
			}
			else if(r < 335ll /*etc.*/){//November
				month = 11;
				r -= 305ll;
			}
			else{//December
				month = 12;
				r -= 335ll;
			}
		}
		else{
			if (r < 31ll){//January
				month = 1;
			}
			else if(r < 59ll /*59 = 31 + 28*/){//February
				month = 2;
				r -= 31ll;
			}
			else if(r < 90ll /*90 = 31 + 28 + 31*/){//March
				month = 3;
				r -= 59ll;
			}
			else if(r < 120ll /*120 = 31 + 28 + 30 + 31*/){//April
				month = 4;
				r -= 90ll;
			}
			else if(r < 151ll /*151 = 31 + 28 + 31 + 30 + 31*/){//May
				month = 5;
				r -= 120ll;
			}
			else if(r < 181ll /*etc.*/){//June
				month = 6;
				r -= 151ll;
			}
			else if(r < 212ll /*etc.*/){//July
				month = 7;
				r -= 181ll;
			}
			else if(r < 243ll /*etc.*/){//August
				month = 8;
				r -= 212ll;
			}
			else if(r < 273ll /*etc.*/){//September
				month = 9;
				r -= 243ll;
			}
			else if(r < 304ll /*etc.*/){//October
				month = 10;
				r -= 273ll;
			}
			else if(r < 334ll /*etc.*/){//November
				month = 11;
				r -= 304ll;
			}
			else{//December
				month = 12;
				r -= 334ll;
			}
		}
		day = (int)r + 1;
		if (year > 0){
			printf("%d %d %d\n", day, month, year);
		}
		else{
			printf("%d %d %d BC\n", day, month, 1 - year);
		}
	}
	return 0;
}
```

#### 题外话：

在代码中把 `146097ll` 写成了 `1640971ll` 和 `164097ll`，害我调了好久。

---

## 作者：Danny_chan (赞：1)

我们可以先算出年里的每天对应的年，月，日。然后每次询问每四百年为一组打包就可以很快算出答案了。

特殊数字备注：

$2159351$：以 $1200$ 年 $1$ 月 $1$ 日为起始日，每次询问要减去的跳过的天数。

$146097$：四百年的天数。

$1461$：儒略历四年的天数。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n=146097;
int t,y[146100],m[146100],d[146100],q,sum;
int is(int a,int b){//判断每个月的天数 
	if(b==2){
		if(a%4==0&&(a%100!=0||a%400==0)){
			return 29;
		}
		else return 28;
	}
	if(b==1||b==3||b==5||b==7||b==8||b==10||b==12){
		return 31;
	}
	else return 30;
}
signed main(){
	m[0]=1;
	d[0]=1;
	for(int i=1;i<n;i++){
		d[i]=d[i-1]+1;
		m[i]=m[i-1];
		y[i]=y[i-1];
		if(d[i]>is(y[i],m[i])){
			m[i]++;
			d[i]=1;
		}
		if(m[i]>12){
			m[i]=1;
			y[i]++;
		}
	}//预处理年，月，日 
	cin>>q;
	while(q--){
		int x;
		cin>>x;
		if(x>2299160){
            x-=2159351;
            sum=x/n*400+1200;
            x%=n;//打包 
        }
		else{
            sum=x/1461*4-4712;
            x%=1461;//打包 
        }
        if(sum+y[x]>0){//判断是否是公元前 
        	cout<<d[x]<<" "<<m[x]<<" "<<sum+y[x]<<endl; 
		}
		else{
			cout<<d[x]<<" "<<m[x]<<" "<<1-sum-y[x]<<" "<<"BC"<<endl;
		}
	}
	return 0;
}

```

---

## 作者：wsm52 (赞：1)

十分炸裂的一道模拟题。
# 思路
这显然不能不能一天一天的加，肯定超时。那要怎么做呢？我们应该先分一下时间段。我的分段是先把公元前的归为一段时间，即 $BC 4713.1.1-BC 1.12.31$。然后在将从公元 $1$ 年到 $1581$ 年归为一段，即 $1.1.1-1581.12.31$。$1582$ 年要特殊处理，所以 $1582.1.1-1582.12.31$ 归为一段。最后 $1582$ 年以后归为一段，即 $1583.1.2-1145141919810.12.31$ 为一段。

然后最难的是如何确定到达每一段时间的天数。首先从 $BC 4713.1.1-1.1.1$，所需的天数是 $1721424$ 天，大家可以自行计算。然后，从$BC 4713.1.1-1582.1.1$，所需的天数是 $2298884$ 天。最后，从$BC 4713.1.1-1583.1.1$，所需的天数是 $2299239$ 天。知道这些过后，这道题就很简单了，无非就是细节问题。
## 坑点
第一（闰年），在使用格里高利历之前，闰年的判断条件是 $n \bmod 4=0$（注意：在公园前是 $(n-1)\bmod4=0$）；在格里高利历之后的判断条件是 $(n \bmod 4 = 0 \land n\bmod100=k,(k \in N_+,k<n))\lor(n \bmod 400 = 0)$。

第二（关于 $1582$ 年），$1582$年从 $10$ 月 $5$ 日到 $10$ 月 $14$ 日是不存在的。
# 代码
主函数

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int BC=1721424,Julia=2298884,Gregorian=2299239; //1.1.1 | 1582.1.1 | 1583.1.1
int q,mon[2][13]={{0,31,29,31,30,31,30,31,31,30,31,30,31},{0,31,28,31,30,31,30,31,31,30,31,30,31}};
LL r;
int main(){
	scanf("%d",&q);
	while(q--){
		scanf("%lld",&r);
		if(r<BC) BCday(r);
		else if(r==BC) printf("1 1 1\n");
		else if(r<Julia) Juliaday(r-BC);
		else if(r==Julia) printf("1 1 1582\n");
		else if(r>Julia&&r<Gregorian) Julia_Gregorian(r);
		else if(r==Gregorian) printf("1 1 1583\n");
		else Gregorianday(r-Gregorian);
	}
	return 0;
}
```
$BC 4713.1.1-BC 1.12.31$
```cpp
void BCday(LL r){ //BC 4713.1.1-BC 1.12.31
	int day=1,month=1,year=4713;
	while(r-((year-1)%4==0?366:365)>=0){
		r-=((year-1)%4==0?366:365);
		year--;
	}
	while(r-mon[min(1,(year-1)%4)][month]>=0){
		r-=mon[min(1,(year-1)%4)][month];
		month++;
	}
	day+=r;
	printf("%d %d %d BC\n",day,month,year);
}
```
$1.1.1-1581.12.31$

```cpp
void Juliaday(LL r){ //1.1.1-1581.12.31
	int day=1,month=1,year=1;
	while(r-(year%4==0?366:365)>=0){
		r-=(year%4==0?366:365);
		year++;
	}
	while(r-mon[min(1,year%4)][month]>=0){
		r-=mon[min(1,year%4)][month];
		month++;
	}
	day+=r;
	printf("%d %d %d\n",day,month,year);
}
```
$1582.1.1-1582.12.31$

```cpp
void Julia_Gregorian(LL r){ //1582.1.1-1582.12.31
	int October=2299157,December=2299178;
	int day=1,month=1;
	if(r==October) printf("1 10 1582\n");
	else if(r==December) printf("1 11 1582\n");
	else if(r<October||r>December){
		if(r>December) month=11,r-=December;
		else r-=Julia;
		while(r-mon[1][month]>=0){
			r-=mon[1][month];
			month++;
		}
		day+=r;
		printf("%d %d 1582\n",day,month);
	}else{
		month=10;
		r-=October;
		if(r<=3) day+=r;
		else day=11+r;
		printf("%d %d 1582\n",day,month); 
	}
}
```
$1583.1.2-1145141919810.12.31$

```cpp
int check(int n){
	if(n%400==0||(n%4==0&&n%100!=0)) return 366;
	return 365;
}
void Gregorianday(LL r){ //1583.1.2-1145141919810.12.31
	int day=1,month=1,year=1583,rp=1;
	while(r-check(year)>=0){
		r-=check(year);
		year++;
	}
	if(check(year)==366) rp=0;
	while(r-mon[rp][month]>=0){
		r-=mon[rp][month];
		month++;
	}
	day+=r;
	printf("%d %d %d\n",day,month,year);
}
```
但是将上述代码一交才 $70pts$。这是为什么呢？是因为在加年数的时候是一次一次加的，这在 $1583$ 年及以后计算是非常慢的，所以我们可以计算在 $1583$ 年及以后，以 $400$ 年为一周期，即 $146097$ 天，减下去，就可以过了。当然，$1581$ 年及以前，我们也可以以 $4$ 年为一周前，即 $1461$ 天，减下去，也可以加快。
# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int BC=1721424,Julia=2298884,Gregorian=2299239; //1.1.1 | 1582.1.1 | 1583.1.1 
const int mod1=1461,mod2=146097; //1582年以前4年一周期的天数，1583年后400年一周期的天数 
int q,mon[2][13]={{0,31,29,31,30,31,30,31,31,30,31,30,31},{0,31,28,31,30,31,30,31,31,30,31,30,31}};
LL r;
int check(int n){
	if(n%400==0||(n%4==0&&n%100!=0)) return 366;
	return 365;
}
void BCday(LL r){ //BC 4713.1.1-BC 1.12.31
	int day=1,month=1,year=4713;
	int t=r/mod1;
	year-=t*4;
	r-=t*mod1;
	while(r-((year-1)%4==0?366:365)>=0){
		r-=((year-1)%4==0?366:365);
		year--;
	}
	while(r-mon[min(1,(year-1)%4)][month]>=0){
		r-=mon[min(1,(year-1)%4)][month];
		month++;
	}
	day+=r;
	printf("%d %d %d BC\n",day,month,year);
}
void Juliaday(LL r){ //1.1.1-1581.12.31
	int day=1,month=1,year=1;
	int t=r/mod1;
	year+=t*4;
	r-=t*mod1;
	while(r-(year%4==0?366:365)>=0){
		r-=(year%4==0?366:365);
		year++;
	}
	while(r-mon[min(1,year%4)][month]>=0){
		r-=mon[min(1,year%4)][month];
		month++;
	}
	day+=r;
	printf("%d %d %d\n",day,month,year);
}
void Julia_Gregorian(LL r){ //1582.1.1-1582.12.31
	int October=2299157,December=2299178;
	int day=1,month=1;
	if(r==October) printf("1 10 1582\n");
	else if(r==December) printf("1 11 1582\n");
	else if(r<October||r>December){
		if(r>December) month=11,r-=December;
		else r-=Julia;
		while(r-mon[1][month]>=0){
			r-=mon[1][month];
			month++;
		}
		day+=r;
		printf("%d %d 1582\n",day,month);
	}else{
		month=10;
		r-=October;
		if(r<=3) day+=r;
		else day=11+r;
		printf("%d %d 1582\n",day,month); 
	}
}
void Gregorianday(LL r){ //1583.1.1-1145141919810.12.31
	int day=1,month=1,year=1583,rp=1;
	int t=r/mod2;
	year+=t*400;
	r-=(long long)t*mod2;
	while(r-check(year)>=0){
		r-=check(year);
		year++;
	}
	if(check(year)==366) rp=0;
	while(r-mon[rp][month]>=0){
		r-=mon[rp][month];
		month++;
	}
	day+=r;
	printf("%d %d %d\n",day,month,year);
}
int main(){
	scanf("%d",&q);
	while(q--){
		scanf("%lld",&r);
		if(r<BC) BCday(r);
		else if(r==BC) printf("1 1 1\n");
		else if(r<Julia) Juliaday(r-BC);
		else if(r==Julia) printf("1 1 1582\n");
		else if(r>Julia&&r<Gregorian) Julia_Gregorian(r);
		else if(r==Gregorian) printf("1 1 1583\n");
		else Gregorianday(r-Gregorian);
	}
	return 0;
}
```

---

## 作者：vectorwyx (赞：1)

先说一下本题的几个坑点：

* 闰年的不同判断方式：**公元前**年份的绝对值模 $4$ 余 $1$ 时为闰年，**公元后到 1582 年**年份是 $4$ 的倍数为闰年，**1582 年之后**年份是 $4$ 的倍数但不是 $100$ 的倍数，或年份为 $400$ 的倍数时为闰年。

* **被删除的 $10$ 天**。千万不要忘记处理它。很多人在洛谷上测的40分（包括我）就是因为这里或多或少的出了疏漏。

* **数据范围**。由于年份最大是 $10^{9}$，我们可以推断出给定的 $r$ 最大为 $365\times10^{9}$ 左右。因此第一点就是要**开 long long**，其次就是要**注意时间复杂度**。直接枚举年份或日期肯定过不了。



------------
 

再说一下我的思路：

先确定年份，然后确定月份，最后由年份和月份推出具体的日子。

确定年份需要写一个`count_year`函数，用来计算从公元前 4713 年 1 月 1 日到某年 12 月 31 日 一共有多少天。注意这里是有多少天而非过了多少天，唯一的区别就是公元前 4713 年 1 月 1 日 到底算 $1$ 还是算 $0$。当然题目中给定的 $r$ 是经过了多少天，因此实际操作的时候还需要把给定的 $r$ 加上 $1$ 再处理，不过没太大差别（。

`count_year`函数的难点在于计算闰年的数量。如果是标准的四年一闰，那么闰年数量显然为 $\frac{k}{4}$（$k$ 为过了多少年）。而公元前是从公元前 4713 年开始，这是个闰年，把它单独摘出来后就成了标准的四年一闰。公元后元年到 1582 年本来就是标准的四年一闰，直接处理即可。1582 年以后就比较麻烦，为了简便运算我把 1582 年以后又分成了四段：1582 年，1583 年，1584 年到 1600 年，1601 年及以后。写出来大概是这样：
```
ll count_year(int year){//计算截止到year年12月31日有多少天 
	if(year<0){
		int cnt=year+4713+1;
		return 1ll*cnt*365+ceil(cnt/4.0);
	}
	else if(year<1582){
		return count_year(-1)+year*365+year/4;
	}
	//注意，1582这一年少了10天 
	else if(year==1582){
		return count_year(1581)+355; 
	}
	else if(year==1583){
		return count_year(1581)+355+365;
	}
	else if(year<=1600){
		int cnt=year-1583;
		return count_year(1583)+cnt*365+(cnt-1)/4+1;
	}
	else{
		int cnt=year-1600;
		return count_year(1600)+1ll*cnt*365+cnt/4-cnt/100+cnt/400;
	}
}
```

有了`count_year`函数后，由于起始日期到答案日期的天数 $r$ 一定小于等于起始日期到答案的年份的最后一天的天数，我们可以使用二分求出答案的年份，得到年份之后我们只需要枚举一下月份，思路和求年份是共通的，只不过由于月份只有十二种取值因此没必要用二分。这里也需要写一个`count_month`函数，用来计算从某一年的 1 月 1 日到某个月的最后一天有多少天：
```cpp
int mo[30]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int sum[30];
int count_month(int year,int month){//截止到year年month月的最后一天有多少天
	return sum[month]+(check(year)&&(month>=2))-(year==1582&&month>=10)*10;
}
```
年份和月份都得到了，那么具体的日期只需要把总天数减去年份和月份所占的天数。千万不要忘记在求出答案后再处理一下那消失的十天！

完整代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;

inline ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}

ll count_year(int year){//计算截止到year年12月31日有多少天 
	if(year<0){
		int cnt=year+4713+1;
		return 1ll*cnt*365+ceil(cnt/4.0);
	}
	else if(year<1582){
		return count_year(-1)+year*365+year/4;
	}
	//注意，1582这一年少了10天 
	else if(year==1582){
		return count_year(1581)+355; 
	}
	else if(year==1583){
		return count_year(1581)+355+365;
	}
	else if(year<=1600){
		int cnt=year-1583;
		return count_year(1583)+cnt*365+(cnt-1)/4+1;
	}
	else{
		int cnt=year-1600;
		return count_year(1600)+1ll*cnt*365+cnt/4-cnt/100+cnt/400;
	}
}

bool check(int x){
	if(x<0) return ((-x)%4==1);
	if(x<=1582) return x%4==0;
	return ((x%4==0&&x%100!=0)||(x%400==0));
}

int mo[30]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int sum[30];
int count_month(int year,int month){//截止到year年month月的最后一天有多少天
	return sum[month]+(check(year)&&(month>=2))-(year==1582&&month>=10)*10;
   //sum是mo数组的前缀和
}

int main(){
	fo(i,1,12) sum[i]=sum[i-1]+mo[i];
	int T=read();
	while(T--){
		ll ri=read()+1;
		int L,R,mid,Year,Month,Day; 
		L=-4713,R=1e9+5;
		while(L<=R){//二分年份 
			mid=(L+R)>>1;
			if(count_year(mid)>=ri) Year=mid,R=mid-1;
			else L=mid+1;
		}
		ri-=count_year(Year-1);
		fo(i,1,12){
			int cm=count_month(Year,i);
			if(cm>=ri){
				Month=i;
				Day=ri-count_month(Year,i-1);
				break;
			}
		}
		if(Year==1582&&Month==10&&Day>4) Day+=10;
		if(Year<0) printf("%d %d %d BC\n",Day,Month,-Year);
		else printf("%d %d %d\n",Day,Month,Year);
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

## 题意回顾

不强制在线地给定 $ Q $ 个整数儒略日数值，分别求出它们对应的日期。

具体地，儒略日计算规则如下：

* 1582 年 10 月 4 日（含）以前，闰年与非闰年每月天数与现今相同，但是公元后年份为 $ 4 $ 的倍数即为闰年，公元前年份的绝对值模 $ 4 $ 余 $ 1 $ 即为闰年，注意公元 $ 0 $ 年并不存在！
* 1582 年 10 月 5 日（含）至同年 10 月 14 日（含）被删除。
* 1582 年 10 月 15 日（含）以后，适用现今历法：一/三/五/七/八/十/十二这些月份为 $ 31 $ 日的大月，四/六/九/十一这些月份为 $ 30 $ 日的小月，二月为 $ 28 $ 日（平年）或 $ 29 $ 日（闰年），闰年的充要条件为年份为 $ 4,100,400 $ 三个数中一个数或三个数的倍数。
* 一个时刻的儒略日的定义为从公元前 4713 年 1 月 1 日正午 12 时整时到此时刻经过的天数（实数）。

$ 1 \le Q \le 10^5 $，给出的儒略日均为整数，它们的年份均不超过 $ 10^9 $。

## 分析

遇事不决先打表，我们发现以下日期节点对于我们处理这个问题有着很大的帮助：

* 公元前 1 年 12 月 31 日，即 $ 1721423 $ 儒略日，这是公元前的最后一个整儒略日，在此前后的闰年判定标准不同。
* 公元 1582 年 10 月 4 日，即 $ 2299160 $ 儒略日，这是被删除的十天之前，下一个整数儒略日日期之后的所有日期均可被同一个历法刻画。

$ 2299160 $ 是一个很小的数，小到一台运算速度为 $ 1 \times 10^8 $ 次运算每秒的计算机（这是我们对于评测机速度的最悲观预估）只需要大约 20ms 即可完成对于这些日期的模拟，这里简述日期模拟中前进一天日期的年月日变化流程：

* 日增加 $ 1 $，若超过该月天数则日归为 $ 1 $ ，月增加 $ 1 $；
* 若为 $ 13 $ 月则月归为 $ 1 $，往后 $ 1 $ 年，且根据新年的闰平情况更新 $ 2 $ 月的天数。

我们可以选择开一个数组来记录这些预先模拟出的日期的答案，也可以选择排序所有询问的日期记录询问编号，然后因为模拟的顺序相当于排序后询问的顺序直接遇到可以模拟到的询问就记录答案，因为逐日模拟所以肯定不会遗漏询问。

对于之后的日期，我们发现可能会达到 $ 10^9 \times 365 \approx 3 \times 10^{11} $  天，无法直接模拟！但是我们发现两次询问可能相距很远，所以我们进行以下优化：

* 对于相差 $ 400 $ 年内没有下一个询问，直接跳过 $ 400 $ 年并增加 $ 146097 $ 天，因为这 $ 400 $ 年里闰平状态正好一个周期；
* 如果今天在 $ 2 $ 月 $ 28 $ 日（含）以前，且根据当年闰平情况可以跳过一年，就跳过去，并更新闰平情况；
* 如果今天在 $ 2 $ 月 $ 29 $ 日（不含）以后，那么与上一种情况类似，但是要依据次年闰平情况；
* 如果今天是 $ 2 $ 月 $ 29 $ 日（仅闰年当日），那么按照 $ 365 $ 天为条件跳过，且跳到次年 $ 2 $ 月 $ 28 $ 日；
* 对于 $ 400 $ 年跳跃，带来的总和运算次数不会超过 $ \frac{10^9}{400}=2.5 \times 10^6 $，对于 $ 1 $ 年或 $ 1 $ 天跳跃，带来的每两组相邻询问之间的运算次数不会超过 $ 400+366=766 $ 次。故本题综合时间复杂度为 $ O(L+\frac{V}{w} + (w+d)\times Q) $，其中 $ V $ 为年份值域，$ w $ 为最大的跳跃步长以年为单位即为 $ 400 $，$ d $ 为每年天数因为时间复杂度不用过于精确取 $ 366 $ 即可，$ L $ 为删除日期前的的天数，前文中有述。运算次数的主要贡献量为 $ (w+d) \times Q \approx 8 \times 10^7 $ 次左右，可过。

## 参考实现

```cpp
//0:{BC4713,1,1}
//1721423:{BC1,12,31}
//1721424:{1,1,1}
//2299160:{1582,10,4}
//2299161:{1582,10,15}
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int q;
struct ask {
	int id;
	long long days;
} data[N];
bool cmp(ask p1, ask p2) {
	if(p1.days == p2.days) {
		return p1.id < p2.id;
	}
	return p1.days < p2.days;
}
struct date {
	bool BC;
	int y;
	int m;
	int d;
};
date ans[N];
int day1[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
void out(date da) {
	printf("%d %d %d ", da.d, da.m, da.y);
	if(da.BC) {
		cout << "BC";
	}
	cout << endl;
}
bool isleap(int y1) {
	return y1 % 400 == 0 || (y1 % 4 == 0 && y1 % 100 != 0);
}
int main() {
	//freopen("julian3.in", "r", stdin);
	//freopen("julian.out", "w", stdout);
	cin >> q;
	for(int i = 1; i <= q; i++) {
		scanf("%lld", &data[i].days);
		data[i].id = i;
	}
	sort(data + 1, data + q + 1, cmp);
	date now;
	now.BC = true;
	now.y = 4713;
	now.m = 1;
	now.d = 1;
	int que = 1;
	while(data[que].days == 0 && que <= q) {
		ans[data[que].id] = now;
		que++;
	}
	if(now.y % 4 == 1) {
		day1[2] = 29;
	} else {
		day1[2] = 28;
	}
	for(int i = 1; i <= 1721423; i++) {
		now.d++;
		if(now.d > day1[now.m]) {
			now.d = 1;
			now.m++;
		}
		if(now.m > 12) {
			now.m = 1;
			now.y--;
		}
		if(now.y % 4 == 1) {
			day1[2] = 29;
		} else {
			day1[2] = 28;
		}
		while(data[que].days == i && que <= q) {
			ans[data[que].id] = now;
			que++;
		}
	}
	now.BC = false;
	now.y = 1;
	now.m = 1;
	now.d = 0;
	if(now.y % 4 == 0) {
		day1[2] = 29;
	} else {
		day1[2] = 28;
	}
	for(int i = 1721424; i <= 2299160; i++) {
		now.d++;
		if(now.d > day1[now.m]) {
			now.d = 1;
			now.m++;
		}
		if(now.m > 12) {
			now.m = 1;
			now.y++;
		}
		if(now.y % 4 == 0) {
			day1[2] = 29;
		} else {
			day1[2] = 28;
		}
		while(data[que].days == i && que <= q) {
			ans[data[que].id] = now;
			que++;
		}
	}
	long long cnt = 2299160;
	now.BC = false;
	now.y = 1582;
	now.m = 10;
	now.d = 14;
	//400 year = 146097 days
	while(que <= q) {
		if(cnt + 146097 <= data[que].days) {
			now.y += ((data[que].days - cnt) / 146097) * 400;
			cnt += ((data[que].days - cnt) / 146097) * 146097;
		}
		while(true) {
			if(now.m < 2 || (now.m == 2 && now.d <= 28)) {
				if(cnt + 365 + isleap(now.y) <= data[que].days) {
					cnt += 365 + isleap(now.y);
					now.y++;
				} else {
					break;
				}
			} else if(now.m == 2 && now.d == 29) {
				if(cnt + 365 <= data[que].days) {
					cnt += 365;
					now.y++;
					now.d = 28;
				} else {
					break;
				}
			} else {
				if(cnt + 365 + isleap(now.y + 1) <= data[que].days) {
					cnt += 365 + isleap(now.y + 1);
					now.y++;
				} else {
					break;
				}
			}
		}
		if(isleap(now.y)) {
			day1[2] = 29;
		} else {
			day1[2] = 28;
		}
		while(cnt < data[que].days) {
			cnt++;
			now.d++;
			if(now.d > day1[now.m]) {
				now.d = 1;
				now.m++;
				if(now.m > 12) {
					now.m = 1;
					now.y++;
					if(isleap(now.y)) {
						day1[2] = 29;
					} else {
						day1[2] = 28;
					}
				}
			}
		}
		ans[data[que].id] = now;
		que++;
	}
	for(int i = 1; i <= q; i++) {
		out(ans[i]);
	}
	return 0;
}
```

---

## 作者：strcmp (赞：0)

首先如果你是考场上做到这题，肯定是先打出 $80$ 分暴力的。

简单来说就是直接枚举儒略日，然后记录它对应的公历，直接对着题目模拟即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
using pll = pair<ll, ll>;
using pii = pair<int, int>;
const int maxn = 1e7 + 10;
const ll mod = 1000000007LL;
ll mt[15] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
int ye[maxn], mo[maxn], da[maxn], isb[maxn];
inline int pre_run(int x) {
    return x % 4 == 0;
}
inline int nxt_run(int x) {
    return (x % 400 == 0) || (x % 4 == 0 && x % 100 != 0);
}
//这两个函数分别计算那个日期之前的闰年和之后的闰年
int main() {
    int ny = 4713, nm = 1, nd = 1, bc = 1; int guo = 0;
    for (int i = 0; i <= 10000000; i++) {
        ye[i] = ny, mo[i] = nm, da[i] = nd; isb[i] = bc;
        if (bc) {
            ++nd; int u = 0;
            u = (nm == 2 && pre_run(ny - 1));
            if (nd > mt[nm] + u) {
                nd = 1; ++nm;
                if (nm > 12) nm = 1, --ny;
                if (!ny) bc = 0, ny = 1;
            }
        }
        else {
            ++nd; int u = 0;
            if (!guo) u = (nm == 2 && pre_run(ny));
            else u = (nm == 2 && nxt_run(ny));
            if (ny == 1582 && nm == 10 && nd == 5) { nd = 15; guo = 1; continue; }
            if (nd > mt[nm] + u) {
                nd = 1; ++nm;
                if (nm > 12) nm = 1, ++ny;
            }
        }
    }
    int t; scanf("%d", &t);
    while (t--) {
        int x;
        scanf("%d", &x);
        printf("%d %d %d ", da[x], mo[x], ye[x]);
        if (isb[x]) puts("BC");
        else puts("");
    }
    return 0;
}
```

简单来说我们代码的主要难度就在于 $1582$ 年 $10$ 月 $5$ 日之后这堆东西。要分类讨论一下。还有公元前公元后的判定。

好了现在你要获得 $100$ 分，考虑如何获得。

首先儒略日小于等于 $10^7$ 的我们先处理出来。

然后你考虑，儒略日大于 $10^7$ 了，肯定每 $400$ 年形成一个循环节，我们直接一直减这个循环节把它减到小于等于 $10^7$，然后直接用我们计算出来的答案就好了。

减循环节的过程显然可以直接用个除法优化掉。

一些常数建议自己用计算器算。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define mid (l + r >> 1)
#define pb push_back
#define rep(i, a, b) for (int i = a; i <= b; i++)
using namespace std;
using ld = double;
typedef long long int ll;
using pii = pair<int, int>;
using iter = multiset<ll>::iterator;
constexpr int maxn = 1e7 + 10, mod = 1e9 + 7;
ll mt[15] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
int ye[maxn], mo[maxn], da[maxn], isb[maxn];
ll ny = 4713, nm = 1, nd = 1, bc = 1, guo = 0;
inline int pre_run(int x) {
    return x % 4 == 0;
}
inline int nxt_run(int x) {
    return (x % 400 == 0) || (x % 4 == 0 && x % 100 != 0);
}
inline void ad() {
	if (bc) {
        ++nd; int u = 0;
        u = (nm == 2 && pre_run(ny - 1));
        if (nd > mt[nm] + u) {
            nd = 1; ++nm;
            if (nm > 12) nm = 1, --ny;
            if (!ny) bc = 0, ny = 1;
        }
    }
    else {
        ++nd; int u = 0;
        if (!guo) u = (nm == 2 && pre_run(ny));
        else u = (nm == 2 && nxt_run(ny));
        if (ny == 1582 && nm == 10 && nd == 5) { nd = 15; guo = 1; return; }
        if (nd > mt[nm] + u) {
            nd = 1; ++nm;
            if (nm > 12) nm = 1, ++ny;
        }
    }
}
int main() {
    for (int i = 0; i <= 10000000; i++) {
        ye[i] = ny, mo[i] = nm, da[i] = nd; isb[i] = bc;
        ad();
    }
    const int wx = 2451545, dsy = 146097;
    int t; scanf("%d", &t); 
    while (t--) {
        ll x, qwq = 0, w = 0;
        scanf("%lld", &x);
        if (x > 2597642) {
        	w = (x - wx) / dsy;
        	x = (x - wx) % dsy + wx; qwq = 1;
		}
        printf("%d %d %lld ", da[x], mo[x], w * 400 + ye[x]);
        if (!qwq && isb[x]) puts("BC");
        else puts("");
    }
    return 0;
}
//2000年1月1日 4172933 
//146097
```

---


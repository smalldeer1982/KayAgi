# [CRCI2008-2009] CIJEVI

## 题目描述

为了帮助设计天然气管道，克罗地亚和莫斯科正在使用电脑游戏「管道狂热」。

在游戏中，欧洲分为 $R$ 行和 $C$ 列。每个单元格可以为空，也可以包含七个基本管道构建块之一：

![](https://cdn.luogu.com.cn/upload/image_hosting/r3k1hpsp.png)
气体可以通过构建块沿任一方向流动。 构建块 `+` 的特殊之处在于气体必须沿两个方向（一个垂直方向，一个水平方向）流动，如以下示例所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/te8dolym.png)

当黑客从计划中删除了一个构建块时，但新管道已经开始投入使用。

编写一个程序，确定被删除构建块的位置和它的类型。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$1 \le R, C \le 25$。
#### 说明
- 本题满分 $70$ 分。
- Subtask 1 为 hack 数据，不计分。
- 本题译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CRCI2008-2009](https://hsin.hr/coci/archive/2008_2009/regional_tasks.pdf) CIJEVI，译者 @[tearing](https://www.luogu.com.cn/user/219791)。
- 2023.11.17 添加一组 hack 数据。
- 2024.02.16 再添加一组 hack 数据。

## 样例 #1

### 输入

```
3 7
.......
.M-.-Z.
....... 
```

### 输出

```
2 4 - 
```

## 样例 #2

### 输入

```
3 5
..1-M
1-+..
Z.23. 
```

### 输出

```
2 4 4
```

## 样例 #3

### 输入

```
6 10
Z.1----4..
|.|....|..
|..14..M..
2-+++4....
..2323....
.......... 
```

### 输出

```
3 3 |```

# 题解

## 作者：_xiaxii (赞：7)

# [P7185 [CRCI2008-2009] CIJEVI](https://www.luogu.com.cn/problem/P7185)

~~还没有题解，赶紧水一篇。~~

$Wrote\space on\space 2022/11/29$

$Updated\space on\space 2023/11/12$ 被 $Hack$ 力。

## 题意理解

![](https://s1.ax1x.com/2020/08/08/a5eXKf.png)

输入一张管道的图，求缺失的一块管道的信息。

这是一道模拟题，给出一种~~有趣~~繁琐的做法。题目给出了起点终点，且只有一块管道是缺失的。我们其实可以沿着整个管道走一遍。考虑到地图和管道的种类不是很多，可以采用枚举的方法。首先我们使用一个 `map` 来表示这个方向是否可走。定义一个函数 `f(int x,int y,int d)` 来走路径，其中 $x$ 与 $y$ 来表示当前的坐标，$d$ 表示方向。第一次调用 `f(x,y,d)` 函数我们通过第一个空格可以找到缺少的管道的坐标。然后再进行 $7$ 次的对管道类型的枚举，我们就可以开始走了。

首先在起点处找第一个管道，且只有一条，因为题目说明了**该计划将没有冗余构建块，即在添加丢失的块之后必须使用计划中的所有块**，否则管道的另一边会被堵死。如果检测到撞到管道壁或者当前在空格的位置，即无法继续往后走下去了，这种填法就是错误的。

我们定义向上为 $1$，向右为 $2$，向下为 $3$，向左为 $4$。方向的变换之间有一对一的关系，变换稍微有点复杂，要注意不要写错。

- 若当前管道为 `+`，则方向不改变。
- 若当前管道为 `-`，则方向不改变。
- 若当前管道为 `|`，则方向不改变。
- 若当前管道为 `1`，则方向 $1$ 变为 $2$，$4$ 变为 $3$。
- 若当前管道为 `2`，则方向 $3$ 变为 $2$，$4$ 变为 $1$。
- 若当前管道为 `3`，则方向 $3$ 变为 $4$，$2$ 变为 $1$。
- 若当前管道为 `4`，则方向 $2$ 变为 $3$，$1$ 变为 $4$。

枚举要把 `+` 的情况放在最后，因为这个管道会影响到 `-` 和 `|` 的情况。

看似已经没有问题了，交上去，[错了两个点](https://www.luogu.com.cn/record/96034428)。

仔细思考，就会发现一个问题，比如说如下的结构：

$$\begin{matrix}
. &.&1&-&4\\
. & .&|&.&|\\
M & -&.&-&3\\
.&.&|&.&.\\
.&.&Z&.&.
\end{matrix}$$

根据题目所说的**该计划将没有冗余构建块，即在添加丢失的块之后必须使用计划中的所有块**，我们很容易看出来在 $(3,3)$ 的位置应该填 `+`，**然而程序填了 `4`**。

这个问题很好解决，用一个 `book` 数组标记每个管道是否用过就行了。

## Hack

~~时隔一年的Hack。~~

考虑这样的数据：

```
1 3
M.Z
```

运行之后发现什么也没输出。仔细看看代码会发现，如果入口处没有任何管道，则 `fixx` 和 `fixy` 中都不会有值。解决办法是直接在入口周围的空地上枚举管道直到成功。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int r,c;
int sx,sy,fx,fy,dir,fixx,fixy,block=6;
int book[50][50];//记录是否走过
char e[30][30];
bool flag=true, hack = false;

//用几个map来标记当前是否可走

map<char,int> _left;
map<char,int> up;
map<char,int> _right;
map<char,int> down;

int nt[4][2]={{-1,0},{0,1},{1,0},{0,-1}};//位置的变化量
char bl[8]={'+','-','|','1','2','3','4'};//记录每种管道

void check()//找到第一步的方向
{
	if(up[e[sx-1][sy]])
	{
		dir=1;
	}
	if(_right[e[sx][sy+1]])
	{
		dir=2;
	}
	if(down[e[sx+1][sy]])
	{
		dir=3;
	}
	if(_left[e[sx][sy-1]])
	{
		dir=4;
	}
}

bool k(int x,int y,int d)//判断这一步是否可走
{
	x+=nt[d-1][0];
	y+=nt[d-1][1];
	if(d==1)
	{
		return up[e[x][y]];
	}
	if(d==2)
	{
		return _right[e[x][y]];
	}
	if(d==3)
	{
		return down[e[x][y]];
	}
	if(d==4)
	{
		return _left[e[x][y]];
	}
}

void f(int x,int y,int d)
{
	book[x][y]=1;
	
    //对方向的更新
    
	int p=d;
	if(e[x][y]==bl[3])
	{
		p=d==1?2:3; 
	}
	if(e[x][y]==bl[4])
	{
		p=d==3?2:1; 
	}
	if(e[x][y]==bl[5])
	{
		p=d==3?4:1;
	}
	if(e[x][y]==bl[6])
	{
		p=d==1?4:3;
	}
    
    //模拟每种管道的走法
	
	if(e[x][y]==bl[0]&&((d==1&&k(x,y,d))||(d==2&&k(x,y,d))||(d==3&&k(x,y,d))||(d==4&&k(x,y,d))))
	{
		f(x+nt[d-1][0],y+nt[d-1][1],d);
	}
	else if(e[x][y]==bl[1]&&((d==2&&k(x,y,d))||(d==4&&k(x,y,d))))
	{
		f(x,y+nt[d-1][1],d);
	}
	else if(e[x][y]==bl[2]&&((d==1&&k(x,y,d))||(d==3&&k(x,y,d))))
	{
		f(x+nt[d-1][0],y,d);
	}
	else if(e[x][y]==bl[3]&&((d==1&&k(x,y,2))||(d==4&&k(x,y,3))))
	{
		p=d==1?2:3; 
		f(x+nt[p-1][0],y+nt[p-1][1],p);
	}
	else if(e[x][y]==bl[4]&&((d==3&&k(x,y,2))||(d==4&&k(x,y,1))))
	{
		p=d==3?2:1; 
		f(x+nt[p-1][0],y+nt[p-1][1],d==3?2:1);
	}
	else if(e[x][y]==bl[5]&&((d==2&&k(x,y,1))||(d==3&&k(x,y,4))))
	{
		p=d==3?4:1; 
		f(x+nt[p-1][0],y+nt[p-1][1],d==3?4:1);
	}
	else if(e[x][y]==bl[6]&&((d==2&&k(x,y,3))||(d==1&&k(x,y,4))))
	{
		p=d==1?4:3; 
		f(x+nt[p-1][0],y+nt[p-1][1],d==1?4:3);
	}
	else if(x+nt[p-1][0]==fx&&y+nt[p-1][1]==fy)//如果走到了终点
	{
		
	    bool flag2=true;
		for(int i=1;i<=r;i++)
		{
			for(int j=1;j<=c;j++)
			{
				if(e[i][j]!='.'&&e[i][j]!='M'&&e[i][j]!='Z')//如果是管道
				{
					if(!book[i][j])//如果没走过
						flag2=false;
				}
			}
		}
		if(flag2)
		{
			if(hack) --block;
		    cout<<fixx<<" "<<fixy<<" "<<bl[block];//满足所有的要求就是答案了，可以直接退出
		    exit(0);
		}
	}
	else if(flag)//第一次进入
	{
		flag=false;
		fixx=x+nt[p-1][0],fixy=y+nt[p-1][1];
	}
}

int main()
{
	cin>>r>>c;
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
		{
			cin>>e[i][j];
			if(e[i][j]=='M')
			{
				sx=i;
				sy=j;
			}
			if(e[i][j]=='Z')
			{
				fx=i;
				fy=j;
			}
		}
	}
    
    //定义哪些可以走
	
	_left['+']=1;
	_left['-']=1;
	_left['1']=1;
	_left['2']=1;
	
	up['+']=1;
	up['|']=1;
	up['1']=1;
	up['4']=1;
	
	_right['+']=1;
	_right['-']=1;
	_right['3']=1;
	_right['4']=1;
	
	down['+']=1;
	down['|']=1;
	down['2']=1;
	down['3']=1;
	
	check();
	f(sx+nt[dir-1][0],sy+nt[dir-1][1],dir);//第一遍调用找到缺少的坐标
	
	if(fixx == sx && fixy == sy){ //新增的Hack内容 
		hack = true;
		for(; block >= 0; block--){
			for(int i=0; i<4; i++){
				int x = sx + nt[i][0];
				int y = sy + nt[i][1];
				if(e[x][y] == '.'){
					e[x][y] = bl[max(0, block)];
					fixx = x, fixy = y;
					check();
					f(sx+nt[dir-1][0],sy+nt[dir-1][1],dir);
					e[x][y] = '.';
				}
			}
		}
	}
	
	while(block>=0)
	{
		memset(book, 0, sizeof(book));//每次枚举要重置book数组
		
		if(!flag)e[fixx][fixy]=bl[max(0,block)];//将枚举的管道拼接到地图中
		
		f(sx+nt[dir-1][0],sy+nt[dir-1][1],dir);
		block--;//记得从后向前枚举，前文有提及
	}
}
```
实测[满分](https://www.luogu.com.cn/record/96036189)。

本[蒟蒻](https://www.luogu.com.cn/user/728002)的第六篇题解。

---

## 作者：Xie2Yue (赞：4)

# P7185

## UPDATE ON $2024/1/29$

如果您 `Subtask #1` 过不去，请看本篇题解的 Hack 部分。

## 正文

刚好比赛时打到这一题，本蒟蒻就来发个题解。

显然，大部分人看到这一道题时想的思路是通过模拟管道送气的过程找出被删掉的构建块，即模拟算法。

其实，由[题意](https://www.luogu.com.cn/problem/P7185)可知：

整个 R 行 C 列的地图中**有且只有一个格子**满足是被黑客删掉的构建块，而且所有在地图上的构建块都不是是冗余的，即不会出现以下情况：

（下图中：红色表示构建块方向，黄色表示可能被删掉的格子，蓝色代表有冗余的构建块。）

![](https://cdn.luogu.com.cn/upload/image_hosting/v9palgj6.png)

**有多个被删掉的格子**

![](https://cdn.luogu.com.cn/upload/image_hosting/c9h6gu3p.png)

**有冗余构建块**

当然，以上情况均可归为有**不止一个**空白地块（即“.”地块）有管道与之相连。

所以我们可以遍历整个地图判断哪个空白地块与未连通的构建块相邻。

## 核心代码 $1$：

**判断四个方向是否联通。**

由题目中的图：![](https://cdn.luogu.com.cn/upload/image_hosting/r2lz6pxl.png)

可知：
- 从上方联通的只有‘|’、‘+’、‘$1$’、‘$4$’
- 从左方联通的只有‘-’、‘+’、‘$1$’、‘$2$’
- 从下方联通的只有‘|’、‘+’、‘$3$’、‘$2$’
- 从右方联通的只有‘-’、‘+’、‘$3$’、‘$4$’

可得代码：（教练标程）
```cpp

bool left( int r, int s ) {
   return s >  1  && (a[r][s-1]=='+' || a[r][s-1]=='-' || a[r][s-1]=='1' || a[r][s-1]=='2');
}
bool right( int r, int s ) {
   return s < S   && (a[r][s+1]=='+' || a[r][s+1]=='-' || a[r][s+1]=='3' || a[r][s+1]=='4');
}
bool up( int r, int s ) {
   return r >  1  && (a[r-1][s]=='+' || a[r-1][s]=='|' || a[r-1][s]=='1' || a[r-1][s]=='4');
}
bool down( int r, int s ) {
   return r < R   && (a[r+1][s]=='+' || a[r+1][s]=='|' || a[r+1][s]=='2' || a[r+1][s]=='3');
}

```

## 核心代码 $2$ 与优化 $1$：

**判断被删掉构建块的形态。**

由上段，可得代码：（教练标程）

```cpp
     if( left(r,s) && right(r,s) && up(r,s) && down(r,s) ) printf( "%d %d +\n", r, s );
else if( left(r,s) && right(r,s) ) printf( "%d %d -\n", r, s );
else if(  up (r,s) &&  down(r,s) ) printf( "%d %d |\n", r, s );
else if(right(r,s) &&  down(r,s) ) printf( "%d %d 1\n", r, s );
else if(right(r,s) &&   up (r,s) ) printf( "%d %d 2\n", r, s );
else if( left(r,s) &&   up (r,s) ) printf( "%d %d 3\n", r, s );
else if( left(r,s) &&  down(r,s) ) printf( "%d %d 4\n", r, s );
```

**但是**！这个代码需多次调用函数，不符合新时代 IOers 更快更短的追求，所以我们考虑状压。

给上、右、下、左分别附上 $1$、$2$、$4$、$8$ 的权值来快速找出是哪种构建块。

![](https://cdn.luogu.com.cn/upload/image_hosting/r2lz6pxl.png)

从左起对应权值：$5$、$10$、$15$、$6$、$3$、$9$、$12$。

可得代码：（自己代码）

```cpp

if(tot){
	printf("%d %d ",i,j);
	     if(tot==5 )puts("|");
	else if(tot==10)puts("-");
	else if(tot==15)puts("+");
	else if(tot==6 )puts("1");
	else if(tot==3 )puts("2");
	else if(tot==9 )puts("3");
	else            puts("4");
	return 0;
}

```

## Hack 与对策

我正在改题时，教练多加了两组 Hack，上面代码的分数降到了 $81$。

个人认为 Hack 与题意相悖，但是还是附上 Hack 与思路：

### Hack $1$：

### Input：
```
1 3
M.Z
```
### Output：
```
1 2 -
```


### Hack $2$：
### Input：

```
2 3
M.Z
23.
```
### Output：
```
1 2 1
```

### 思路：
第一遍搜索如果未搜出答案则进入第二次（注意考虑第一遍搜索时 Hack $2$ 中坐标为 $(1,2)$ 的格子权值为 $4$，不要让它输出）。

并且在第一次搜索中预处理出 莫斯科 与 克罗地亚 是否有管道相邻（虽然题面说至少有一，但 Hack 没有）。

在第二次搜索中把 莫斯科 与 克罗地亚 当作管道（前提该城市是没有管道相邻）从而得出答案。

附代码：（码风很丑）

```cpp

for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
	if(ch[i][j]=='M'||ch[i][j]=='Z'){//       预处理 莫斯科 与 克罗地亚 是否作为管道
		if(i>1){
			if(ch[i][j]=='M')flagz&=(ch[i-1][j]=='.');
			else if(ch[i][j]=='Z')flagm&=(ch[i-1][j]=='.');
		}
		if(i<n){
			if(ch[i][j]=='M')flagz&=(ch[i+1][j]=='.');
			else if(ch[i][j]=='Z')flagm&=(ch[i+1][j]=='.');
		}
		if(j>1){
			if(ch[i][j]=='M')flagz&=(ch[i][j-1]=='.');
			else if(ch[i][j]=='Z')flagm&=(ch[i][j-1]=='.');
		}
		if(j<m){
			if(ch[i][j]=='M')flagz&=(ch[i][j+1]=='.');
			else if(ch[i][j]=='Z')flagm&=(ch[i][j+1]=='.');
		}
	}
	else if(ch[i][j]=='.'){
		tot=0;
		tmp=ch[i-1][j];
		cnt=tot+=(tmp=='+'||tmp=='|'||tmp=='1'||tmp=='4');
		tmp=ch[i][j+1];
		tot+=(tmp=='+'||tmp=='-'||tmp=='3'||tmp=='4')?2:0;cnt+=tot/2;
		tmp=ch[i+1][j];
		tot+=(tmp=='+'||tmp=='|'||tmp=='2'||tmp=='3')?4:0;cnt+=tot/4;
		tmp=ch[i][j-1];
		tot+=(tmp=='+'||tmp=='-'||tmp=='1'||tmp=='2')?8:0;cnt+=tot/8;
		
		//cnt 用于特判 Hack2
		
		if(tot&&(cnt+1)&1){
			printf("%d %d ",i,j);
			if(tot==10)puts("-");
			else if(tot==5)puts("|");
			else if(tot==15)puts("+");
			else if(tot==6)puts("1");
			else if(tot==3)puts("2");
			else if(tot==9)puts("3");
			else puts("4");
			return 0;
		}
	}
}
for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){
	if(ch[i][j]!='.')continue;
	tot=0;
	tmp=ch[i-1][j];tot+=(tmp=='+'||tmp=='|'||tmp=='1'||tmp=='4'||(flagm&&tmp=='Z')||(flagz&&tmp=='M'));
	tmp=ch[i+1][j];tot+=(tmp=='+'||tmp=='|'||tmp=='2'||tmp=='3'||(flagm&&tmp=='Z')||(flagz&&tmp=='M'))?4:0;
	tmp=ch[i][j-1];tot+=(tmp=='+'||tmp=='-'||tmp=='1'||tmp=='2'||(flagm&&tmp=='Z')||(flagz&&tmp=='M'))?8:0;
	tmp=ch[i][j+1];tot+=(tmp=='+'||tmp=='-'||tmp=='3'||tmp=='4'||(flagm&&tmp=='Z')||(flagz&&tmp=='M'))?2:0;
	if(tot){
		printf("%d %d ",i,j);
		if(tot==10)puts("-");
		else if(tot==5)puts("|");
		else if(tot==15)puts("+");
		else if(tot==6)puts("1");
		else if(tot==3)puts("2");
		else if(tot==9)puts("3");
		else puts("4");
		return 0;
	}
}

```

## 总代码：（非 Hack）

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
char ch[26][26],tmp;int n,m,tot;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%s",ch[i]+1);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){if(ch[i][j]!='.')continue;tot=0;
		tmp=ch[i-1][j];if(tmp=='+'||tmp=='|'||tmp=='1'||tmp=='4')tot+=1;
		tmp=ch[i+1][j];if(tmp=='+'||tmp=='|'||tmp=='2'||tmp=='3')tot+=4;
		tmp=ch[i][j-1];if(tmp=='+'||tmp=='-'||tmp=='1'||tmp=='2')tot+=8;
		tmp=ch[i][j+1];if(tmp=='+'||tmp=='-'||tmp=='3'||tmp=='4')tot+=2;
		if(tot){
			printf("%d %d ",i,j);
			if(tot==10)puts("-");
			else if(tot==5)puts("|");
			else if(tot==15)puts("+");
			else if(tot==6)puts("1");
			else if(tot==3)puts("2");
			else if(tot==9)puts("3");
			else puts("4");
			return 0;
		}
	}
	return 0;
}
```

校内 oj 实测 $13$ ms，$760$ b，最短第四快。

这是本蒟蒻的第一篇题解，如题解有解释不清等错误请见谅，也欢迎各位大佬提意见或建议。

---

## 作者：zdd6310 (赞：4)

# solution
在模拟赛出了这道模拟。

## 题意
给定一个 $R\times C$ 的图形，给定起点和终点，有一条管道，在其中有一个 **断点**。

你需要找到这个断点。

保证合法并没有冗余的管道。

## 思考
~~大模拟不用思考。~~

## first step
因为管道是有方向的，定义结构体 $node$ 为当前点的位置和方向。


代码：
```cpp
struct node{
    Pair place;//位置
    int fang;//方向
    //0 下
    //1 上
    //2 右
    //3 左
};
```
## second step
对于起点和终点，`bfs` 枚举它到达的断点 $endd1$ 和 $endd2$。

发现断点可能是本身，所以选用 `bfs`，采取距离起点最远的断点。

在 `bfs` 中只用考虑管道的位置和方向转换即可。

`bfs` 代码：
```cpp
node bfs(Pair start){
    queue<node>q;
    node endd;
    q.push((node){start,1});
    q.push((node){start,2});
    q.push((node){start,3});
    q.push((node){start,0});
    while(!q.empty()){
        Pair head=q.front().place;
        //标记已经到达
        vis[head.first][head.second]=1;
        int delta=q.front().fang;
        q.pop();
        bool flag=1;
        //新的位置
        int xx=head.first+dx[delta];
        int yy=head.second+dy[delta];
        //是否合法
        if(xx<1||yy<1||xx>n||yy>m||a[xx][yy]=='.'){endd=(node){head,delta};continue;}
        //转换方向
        if(a[xx][yy]=='|'&&(delta==0||delta==1)){
            flag=0;
            q.push((node){mp(xx,yy),delta});
        }
        if(a[xx][yy]=='-'&&(delta==2||delta==3)){
            flag=0;
            q.push((node){mp(xx,yy),delta});
        }
        if(a[xx][yy]=='+'){
            flag=0;
            q.push((node){mp(xx,yy),delta});
        }
        if(a[xx][yy]=='1'&&(delta==1||delta==3)){
            flag=0;
            if(delta==1)q.push((node){mp(xx,yy),2});
            if(delta==3)q.push((node){mp(xx,yy),0});
        }
        if(a[xx][yy]=='2'&&(delta==0||delta==3)){
            flag=0;
            if(delta==0)q.push((node){mp(xx,yy),2});
            if(delta==3)q.push((node){mp(xx,yy),1});
        }
        if(a[xx][yy]=='3'&&(delta==0||delta==2)){
            flag=0;
            if(delta==0)q.push((node){mp(xx,yy),3});
            if(delta==2)q.push((node){mp(xx,yy),1});
        }
        if(a[xx][yy]=='4'&&(delta==1||delta==2)){
            flag=0;
            if(delta==1)q.push((node){mp(xx,yy),3});
            if(delta==2)q.push((node){mp(xx,yy),0});
        }
        //标记断点
        if(flag)endd=(node){head,delta};
    }
    return endd;
}
```
## third step
枚举到断点之后如何判断位置和类型呢？

发现如果不是十字交叉的结构，其他很好判断，只需要记录两个端点的相对位置即可。

但是如果是十字交叉，一定有剩余一圈的管道没有走到。

只需要记录每一个管道是否被走到即可。

代码：
```cppPair 
    Pair delta;
    delta.first=endd1.place.first-endd2.place.first;
    delta.second=endd1.place.second-endd2.place.second;
    if(delta.first<0){delta.first=-delta.first,delta.second=-delta.second;}
    if(delta.second<0){
        if(endd1.fang==2||endd1.fang==3)cout<<1<<"\n";
        else cout<<3<<"\n";
    }else{
        if(endd1.fang==2||endd1.fang==3)cout<<4<<"\n";
        else cout<<2<<"\n";
    }
```

发现这样就可以顺利通过此题啦。

---

## 作者：Adolfo_North (赞：2)

[hack](https://www.luogu.com.cn/discuss/770610)&&[虐题解](https://www.luogu.com.cn/discuss/777634)爽！

[私题](https://www.luogu.com.cn/problem/U407574)里有 $3$ 组 hack.

还得是中模拟。

从 `M` 或者 `Z` 遍历整个管道，若遇到断点。断点有两种情况，若与 `M` 或者 `Z` 不直接接触，枚举附近的一个九宫格，找到接口，匹配管道构建块即可。此时你可以通过除 hack 外的所有数据。

若直接接触，枚举 `M` 或者 `Z` 附近的一个九宫格，找到接口，匹配管道构建块即可。此时你可以通过我的 hack。

若图中没有管道构建块，如：

```cpp
1 3
M.Z
```
您可以将 `M` 与 `Z` 看作一个 `+` 型管道构建块，匹配管道接口即可。此时，你可以通过本题的所有数据。

具体看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int xm,ym,xz,yz;
char a[26][26];
int dx[]={-1,1,0,0},dy[]={0,0,-1,1};
int f[4];
bool flag[26][26];

void dfs(int lx,int ly,int x,int y){
	if(x<1||x>n||y<1||y>m||flag[x][y]) return;
	flag[x][y]=1;
	if(a[x][y]=='.'){
		cout<<x<<' '<<y<<' ';
		for(int i=0;i<=3;i++){
			int px=x+dx[i],py=y+dy[i];
			if(i==0&&(a[px][py]=='|'||a[px][py]=='+'||a[px][py]=='1'||a[px][py]=='4')) f[i]=1;
			if(i==1&&(a[px][py]=='|'||a[px][py]=='+'||a[px][py]=='2'||a[px][py]=='3')) f[i]=1;
			if(i==2&&(a[px][py]=='-'||a[px][py]=='+'||a[px][py]=='1'||a[px][py]=='2')) f[i]=1;
			if(i==3&&(a[px][py]=='-'||a[px][py]=='+'||a[px][py]=='3'||a[px][py]=='4')) f[i]=1;
            if(a[px][py]=='M'||a[px][py]=='Z') f[i]=1;
			//上下左右
		}
		if(f[0]==1&&f[1]==1&&f[2]==0&&f[3]==0) {cout<<'|';exit(0);}
		if(f[0]==0&&f[1]==0&&f[2]==1&&f[3]==1) {cout<<'-';exit(0);}
		if(f[0]==1&&f[1]==1&&f[2]==1&&f[3]==1) {cout<<'+';exit(0);}
		if(f[0]==0&&f[1]==1&&f[2]==0&&f[3]==1) {cout<<'1';exit(0);}
		if(f[0]==1&&f[1]==0&&f[2]==0&&f[3]==1) {cout<<'2';exit(0);}
		if(f[0]==1&&f[1]==0&&f[2]==1&&f[3]==0) {cout<<'3';exit(0);}
		if(f[0]==0&&f[1]==1&&f[2]==1&&f[3]==0) {cout<<'4';exit(0);}
	}
	if(a[x][y]=='|'){
		if(lx>x) dfs(x,y,x-1,y);
		else dfs(x,y,x+1,y);
	}
	else if(a[x][y]=='-'){
		if(ly<y) dfs(x,y,x,y+1);
		else dfs(x,y,x,y-1);
	}
	else if(a[x][y]=='+'){
		if(lx>x) {dfs(x,y,x-1,y),dfs(x,y,x,y-1),dfs(x,y,x,y+1);}
		else if(lx<x) {dfs(x,y,x+1,y),dfs(x,y,x,y-1),dfs(x,y,x,y+1);}
		else if(ly<y) {dfs(x,y,x-1,y),dfs(x,y,x+1,y),dfs(x,y,x,y+1);}
		else if(ly>y) {dfs(x,y,x,y-1),dfs(x,y,x+1,y),dfs(x,y,x-1,y);}
	}
	else if(a[x][y]=='1') {
		if(ly>y) dfs(x,y,x+1,y);
		else if(lx>x) dfs(x,y,x,y+1);
	}
	else if(a[x][y]=='2') {
		if(lx<x) dfs(x,y,x,y+1);
		else dfs(x,y,x-1,y);
	}
	else if(a[x][y]=='3'){
		if(ly<y) dfs(x,y,x-1,y);
		else dfs(x,y,x,y-1);
	}
	else if(a[x][y]=='4'){
		if(ly<y) dfs(x,y,x+1,y);
		else dfs(x,y,x,y-1);
	}
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			if(a[i][j]=='Z') xz=i,yz=j;
			if(a[i][j]=='M') xm=i,ym=j;
		}
	} 
	bool fla=0;//从 M 开始找通向远方的道路。 
	for(int i=0;i<=3;i++){
		int px=xm+dx[i],py=ym+dy[i];
		if(i==0&&(a[px][py]=='|'||a[px][py]=='+'||a[px][py]=='1'||a[px][py]=='4')) dfs(xm,ym,px,py),fla=1;
		if(i==1&&(a[px][py]=='|'||a[px][py]=='+'||a[px][py]=='2'||a[px][py]=='3')) dfs(xm,ym,px,py),fla=1;
		if(i==2&&(a[px][py]=='-'||a[px][py]=='+'||a[px][py]=='1'||a[px][py]=='2')) dfs(xm,ym,px,py),fla=1;
		if(i==3&&(a[px][py]=='-'||a[px][py]=='+'||a[px][py]=='3'||a[px][py]=='4')) dfs(xm,ym,px,py),fla=1;
	}
	if(fla){//找到了路，但断点与 Z 接触。 
		if(flag[xz-2][yz]==1) cout<<'|';
		else if(flag[xz+2][yz]==1) cout<<'|';
		else if(flag[xz][yz+2]==1) cout<<'-';
		else if(flag[xz][yz-2]==1) cout<<'-';
		else if(flag[xz-1][yz-1]==1) {
			if(a[xz][yz-1]=='.') cout<<2;
			else cout<<4;
		}
		else if(flag[xz-1][yz+1]==1) {
			if(a[xz-1][yz]=='.') cout<<1;
			else cout<<3;
		}
		else if(flag[xz+1][yz-1]==1) {
			if(a[xz][yz-1]=='.') cout<<1;
			else cout<<3;
		}
		else if(flag[xz+1][yz+1]==1) {
			if(a[xz][yz+1]=='.') cout<<4;
			else cout<<2;
		}
	}
	else{//没找到路 
		for(int i=0;i<=3;i++){//从 Z 开始找通向远方的道路。
			int px=xz+dx[i],py=yz+dy[i];
			if(i==0&&(a[px][py]=='|'||a[px][py]=='+'||a[px][py]=='1'||a[px][py]=='4')) dfs(xz,yz,px,py),fla=1;
			if(i==1&&(a[px][py]=='|'||a[px][py]=='+'||a[px][py]=='2'||a[px][py]=='3')) dfs(xz,yz,px,py),fla=1;
			if(i==2&&(a[px][py]=='-'||a[px][py]=='+'||a[px][py]=='1'||a[px][py]=='2')) dfs(xz,yz,px,py),fla=1;
			if(i==3&&(a[px][py]=='-'||a[px][py]=='+'||a[px][py]=='3'||a[px][py]=='4')) dfs(xz,yz,px,py),fla=1;
		}
		if(fla){//找到了路，但断点与 M 接触。
			if(flag[xm-2][ym]==1) cout<<'|';
			else if(flag[xm+2][ym]==1) cout<<'|';
			else if(flag[xm][ym+2]==1) cout<<'-';
			else if(flag[xm][ym-2]==1) cout<<'-';
			else if(flag[xm-1][ym-1]==1) {
				if(a[xm][ym-1]=='.') cout<<2;
				else cout<<4;
			}
			else if(flag[xm-1][ym+1]==1) {
				if(a[xm-1][ym]=='.') cout<<1;
				else cout<<3;
			}
			else if(flag[xm+1][ym-1]==1) {
				if(a[xm][ym-1]=='.') cout<<1;
				else cout<<3;
			}
			else if(flag[xm+1][ym+1]==1) {
				if(a[xm][ym+1]=='.') cout<<4;
				else cout<<2;
			}
		}
		else{//图中没有管道构建块
            flag[xz][yz]=flag[xm][ym]=1;//当作 + 型管道构建块处理。
			if(flag[xm-2][ym]==1) cout<<xm-1<<' '<<ym<<' '<<'|';
			else if(flag[xm+2][ym]==1) cout<<xm+1<<' '<<ym<<' '<<'|';
			else if(flag[xm][ym+2]==1) cout<<xm<<' '<<ym+1<<' '<<'-';
			else if(flag[xm][ym-2]==1) cout<<xm<<' '<<ym-1<<' '<<'-';
			else if(flag[xm-1][ym-1]==1) {
				if(a[xm][ym-1]=='.') cout<<xm<<' '<<ym-1<<' '<<2;
				else cout<<xm-1<<' '<<ym<<' '<<4;
			}
			else if(flag[xm-1][ym+1]==1) {
				if(a[xm-1][ym]=='.') cout<<xm-1<<' '<<ym<<' '<<1;
				else cout<<xm<<' '<<ym+1<<' '<<3;
			}
			else if(flag[xm+1][ym-1]==1) {
				if(a[xm][ym-1]=='.') cout<<xm<<' '<<ym-1<<' '<<1;
				else cout<<xm+1<<' '<<ym<<' '<<3;
			}
			else if(flag[xm+1][ym+1]==1) {
				if(a[xm][ym+1]=='.') cout<<xm<<' '<<ym+1<<' '<<4;
				else cout<<xm+1<<' '<<ym<<' '<<2;
			}
		}
	}
	return 0;
}
```


---

## 作者：2011FYCCCTA (赞：2)

[题目](https://www.luogu.com.cn/problem/P7185)

中模拟，爱了爱了。

---
### 分析&思路

题目中的限制很多，数据范围很小，直接乱搞。

大致分为两个部分：

1. 首先需要知道哪里被删除了，很简单，直接从 `M` 开始（当然也可以从 `Z` 开始啦，我从 `M` 开始搜的，以下均按此标准）深搜，直到搜到 `.` 为止。搜索时要确定方向，可以设为与 `M` 相邻的构建块的方向。

	[但是……](https://www.luogu.com.cn/discuss/729416)

  	如上 Hack 把被删除的地方设在了与 `M` 相邻的地方上，再加上题目中说：莫斯科和克罗地亚的每一个都将恰好有一个构建块。没有与 `M` 相邻的构建块，无法确定方向，怎么办呢？很简单，这不就相当于**有多个可能被删除的地方**嘛！直接枚举每个可能被删除的地方，然后进行步骤 2，这样就可以确定方向了，因为可以把可能被删除的地方看成与 `M` 相邻的构建块。

2. 再暴力枚举，把被删除的地方依次替换成 $7$ 种管道再按步骤 1 的方式在搜一遍看能否到达对方。

---
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
// 下，右，上，左
const int dx[] = {1 , 0 , -1 , 0};
const int dy[] = {0 , 1 , 0 , -1};
int r , c , mx , my , zx , zy , bx , by;
char mp[30][30] , ansc;

bool check(int x , int y) {return x >= 1 && x <= r && y >= 1 && y <= c && mp[x][y] != '.';}

int get_d(int x , int y , int d)
{
    int nd = d;
    if (mp[x][y] == '1') nd = (d == 2 ? 1 : 0);
    else if (mp[x][y] == '2') nd = (d == 0 ? 1 : 2);
    else if (mp[x][y] == '3') nd = (d == 1 ? 2 : 3);
    else if (mp[x][y] == '4') nd = (d == 1 ? 0 : 3);
    return nd;
}

void dfs1(int x , int y , int d)
{
    if (mp[x][y] == '.') {bx = x; by = y; return;}
    d = get_d(x , y , d);
    int nx = x + dx[d] , ny = y + dy[d];
    dfs1(nx , ny , d);
    return;
}

void dfs2(int x , int y , int d)
{
    if (mp[x][y] == 'Z') {printf("%d %d %c" , bx , by , mp[bx][by]); exit(0);}
    int nx = x + dx[d] , ny = y + dy[d];
    if (check(nx , ny) && 
    //看与下一个构建块是否相连
    (mp[nx][ny] == 'Z' || 
    (mp[nx][ny] == '|' && d % 2 == 0) || 
    (mp[nx][ny] == '-' && d % 2 == 1) || 
    mp[nx][ny] == '+' || 
    (mp[nx][ny] == '1' && (d == 2 || d == 3)) || 
    (mp[nx][ny] == '2' && (d == 3 || d == 0)) || 
    (mp[nx][ny] == '3' && (d == 0 || d == 1)) || 
    (mp[nx][ny] == '4' && (d == 1 || d == 2))
    )) dfs2(nx , ny , get_d(nx , ny , d));
    return;
}

int main()
{
    cin >> r >> c;
    for (int i = 1 ; i <= r ; i++)
        for (int j = 1 ; j <= c ; j++)
        {
            cin >> mp[i][j];
            if (mp[i][j] == 'M') {mx = i; my = j;}
            if (mp[i][j] == 'Z') {zx = i; zy = j;}
        }
    
    int mtd = -1;
    for (int i = 0 ; i < 4 ; i++)
    {
        int tx = mx + dx[i] , ty = my + dy[i];
        if (check(tx , ty)) {mtd = i; break;}
    }
    if (mtd != -1) dfs1(mx , my , mtd);
    
    if (mtd == -1)
    {
        for (int i = 0 ; i < 4 ; i++)
        {
            bx = mx + dx[i] , by = my + dy[i];
            if (bx >= 1 && bx <= r && by >= 1 && by <= c)
            {
                mp[bx][by] = '|';
                dfs2(mx , my , i);
                mp[bx][by] = '-';
                dfs2(mx , my , i);
                mp[bx][by] = '+';
                dfs2(mx , my , i);
                mp[bx][by] = '1';
                dfs2(mx , my , i);
                mp[bx][by] = '2';
                dfs2(mx , my , i);
                mp[bx][by] = '3';
                dfs2(mx , my , i);
                mp[bx][by] = '4';
                dfs2(mx , my , i);
            }
        }
    }
    else
    {
        mp[bx][by] = '|';
        dfs2(mx , my , mtd);
        mp[bx][by] = '-';
        dfs2(mx , my , mtd);
        mp[bx][by] = '+';
        dfs2(mx , my , mtd);
        mp[bx][by] = '1';
        dfs2(mx , my , mtd);
        mp[bx][by] = '2';
        dfs2(mx , my , mtd);
        mp[bx][by] = '3';
        dfs2(mx , my , mtd);
        mp[bx][by] = '4';
        dfs2(mx , my , mtd);
    }
    return 0;
}
```

---

## 作者：All_In_Atom (赞：1)

# [P7185 [CRCI2008-2009] CIJEVI](https://www.luogu.com.cn/problem/P7185)

## 题意描述

给定一个 $R \times C$ 的图形，给定 **唯一** 的终点和起点。

有一条通道，在其中有一个 **被删去** 的节点，你需要找到这个节点并输出它的位置和种类。

没有冗余节点。

输入将保证解决方案存在并且是唯一的。

## 方法&代码

### Solution 1
看到这个题，我们很容易将其联想到一个大模拟。
题目中的限制很多，数据范围也是很小的，所以可以直接模拟，好的代码很多，试着去看一看。

### Solution 2

相信某些同学像我一样，学会了第一种方法又想要第二种方法（实际上是因为第一种方法太难而被劝退），于是这里就有了第二种清晰易懂的方法。

在平常的解法中，我们都是依照 dfs/bfs 进行搜索来找到断点，并根据断点前后情况进行对断点的状态选择。

那我们不妨换个方式来找断点。

断点一定是存在于图上的，而且由题意可以得出来 **有且仅有一个** 断点。

于是我们就可以通过遍历整张图的方式，找到们一个断点。

空间复杂度不够怎么办？

我们观察到， $1 \le R,C \le 25$ 。数据量远没有想象中的那么大。于是就可以开心地写代码了！

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
char c[1005][1005];

bool l(int x,int j) {//判断左侧是否开口
	return j>1&&(c[x][j-1]=='-'||c[x][j-1]=='1'||c[x][j-1]=='2'||c[x][j-1]=='+');
}
bool r(int x,int j) {//判断右侧是否开口
	return j<n&&(c[x][j+1]=='-'||c[x][j+1]=='3'||c[x][j+1]=='4'||c[x][j+1]=='+');
}
bool u(int x,int j) {//判断上侧是否开口
	return x>1&&(c[x-1][j]=='|'||c[x-1][j]=='1'||c[x-1][j]=='4'||c[x-1][j]=='+');
}
bool d(int x,int j) {//判断下侧是否开口
	return x<n&&(c[x+1][j]=='|'||c[x+1][j]=='2'||c[x+1][j]=='3'||c[x+1][j]=='+');
}

int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			cin>>c[i][j];
		}
	}

	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(c[i][j]!='.')continue;
			else if(l(i,j)&&r(i,j)&&u(i,j)&&d(i,j)) {//+
				cout<<i<<' '<<j<<' '<<'+';
				return 0;
			} else if(l(i,j)&&r(i,j)) {//-
				cout<<i<<' '<<j<<' '<<'-';
				return 0;
			} else if(u(i,j)&&d(i,j)) {//|
				cout<<i<<' '<<j<<' '<<'|';
				return 0;
			} else if(r(i,j)&&d(i,j)) {//1
				cout<<i<<' '<<j<<' '<<'1';
				return 0;
			} else if(r(i,j)&&u(i,j)) {//2
				cout<<i<<' '<<j<<' '<<'2';
				return 0;
			} else if(l(i,j)&&u(i,j)) {//3
				cout<<i<<' '<<j<<' '<<'3';
				return 0;
			} else if(l(i,j)&&d(i,j)) {//4
				cout<<i<<' '<<j<<' '<<'4';
				return 0;
			}
		}
	}
	return 0;
}
```
#### HACK

你在写完这个代码提交上去之后，是不是错了两个点？

原因还是要归结到它们身上：

1.
```
4 3
..1.
..|M
Z-3.
```
2.

```
1 3
M.Z
```

它们有一个共同的特点，就是在起点或终点前是断点。
在你没有进行对起点和终点的特判时，你就会出错。

你可以将那 $ 4 $ 个判断函数改成这个样子，就可以通过这个hack了。

```
bool l(int x, int j) {
	return j > 1 && (c[x][j - 1] == '-' || c[x][j - 1] == '1' || c[x][j - 1] == '2' || c[x][j - 1] == '+' || c[x ][j - 1] == 'M' || c[x ][j - 1] == 'Z');
}
bool r(int x, int j) {
	return j < m&&(c[x][j + 1] == '-' || c[x][j + 1] == '3' || c[x][j + 1] == '4' || c[x][j + 1] == '+' || c[x ][j + 1] == 'M' || c[x ][j + 1] == 'Z');
}
bool u(int x, int j) {
	return x > 1 && (c[x - 1][j] == '|' || c[x - 1][j] == '1' || c[x - 1][j] == '4' || c[x - 1][j] == '+' || c[x - 1][j ] == 'M' || c[x - 1][j ] == 'Z');
}
bool d(int x, int j) {
	return x < n&&(c[x + 1][j] == '|' || c[x + 1][j] == '2' || c[x + 1][j] == '3' || c[x + 1][j] == '+' || c[x + 1][j ] == 'M' || c[x + 1][j ] == 'Z');
}
```
在这个判断中，我实际上将起点和终点看做了 '+' 这个符号，进行了特判。
这样就可以避免了hack数据的错误。

感谢阅读。（第四篇题解）

---

## 作者：rainygame (赞：1)

本题有 $O(nm)$ 的做法。

注意到**输入将保证解决方案存在并且是唯一的**，所以只需要考虑哪个地方可以放即可。如果它可以放在这个位置，那么它肯定会被放。

那么只需要 $O(1)$ 和周围的管道判断即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define up(x, y) (x > 1 && (ch[x-1][y] == '|' || ch[x-1][y] == '+' || ch[x-1][y] == '1' || ch[x-1][y] == '4'))
#define down(x, y) (x < n && (ch[x+1][y] == '|' || ch[x+1][y] == '+' || ch[x+1][y] == '2' || ch[x+1][y] == '3'))
#define left(x, y) (y > 1 && (ch[x][y-1] == '-' || ch[x][y-1] == '+' || ch[x][y-1] == '1' || ch[x][y-1] == '2'))
#define right(x, y) (y < m && (ch[x][y+1] == '-' || ch[x][y+1] == '+' || ch[x][y+1] == '3' || ch[x][y+1] == '4'))

int n, m;
char ch[26][26];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    for (int i(1); i<=n; ++i){
        for (int j(1); j<=m; ++j) cin >> ch[i][j];
    }

    for (int i(1); i<=n; ++i){
        for (int j(1); j<=m; ++j){
            if (ch[i][j] != '.') continue;
            if (up(i, j) && down(i, j) && left(i, j) && right(i, j)) cout << i << ' ' << j << " +";
            else if (right(i, j) && left(i, j)) cout << i << ' ' << j << " -";
            else if (up(i, j) && down(i, j)) cout << i << ' ' << j << " |";
            else if (down(i, j) && right(i, j)) cout << i << ' ' << j << " 1";
            else if (up(i, j) && right(i, j)) cout << i << ' ' << j << " 2";
            else if (up(i, j) && left(i, j)) cout << i << ' ' << j << " 3";
            else if (down(i, j) && left(i, j)) cout << i << ' ' << j << " 4";
        }
    }

    return 0;
}

```


---

## 作者：CYZZ (赞：1)

# [P7185](https://www.luogu.com.cn/problem/P7185)
模拟赛出的模拟题。

没什么特别的，直接沿着管道走，走到空缺的就计算答案。

可以用 $0,1,2,3$ 代表四个方向，记录每一种管道的那些方向是开口的，方便判断两个管道是否连通。

dfs 传两个参数，一个是当前位置，一个是**走过上一步来**的方向，如果遇见十字管道顺着原来的方向走即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,mp[30][30];
int fx[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
int bk[10][4];
struct Node
{
    int x,y;
}st,ed;
int R(int x)//求 x 的反方向
{
    if(x==0) return 2;
    if(x==2) return 0;
    if(x==1) return 3;
    return 1;
}
bool check(Node x,int dir)
{
    return mp[x.x+fx[dir][0]][x.y+fx[dir][1]]&&bk[mp[x.x+fx[dir][0]][x.y+fx[dir][1]]][R(dir)];
}
void dfs(Node now,int dir)
{
    if(dir==847)
    {
        for(int i=0;i<4;i++)
        {
            if(bk[mp[now.x+fx[i][0]][now.y+fx[i][1]]][R(i)])
                dfs({now.x+fx[i][0],now.y+fx[i][1]},i);
        }
    }
    if(!mp[now.x][now.y])//找到空缺
    {
        int _[5];
        char ans;
        for(int i=0;i<4;i++) _[i]=check(now,i);//和哪些方向联通
        if(_[0]&&_[1]&&_[2]&&_[3]) ans='+';
        else if(_[0]&&_[2]) ans='|';
        else if(_[1]&&_[3]) ans='-';
        else if(_[2]&&_[3]) ans='1';
        else if(_[0]&&_[3]) ans='2';
        else if(_[0]&&_[1]) ans='3';
        else ans='4';
        printf("%d %d ",now.x,now.y);
        cout << ans;
        exit(0);
    }
    if(mp[now.x][now.y]==7)
        dfs({now.x+fx[dir][0],now.y+fx[dir][1]},dir);
    else
    {
        for(int i=0;i<4;i++)
        {
            if((i!=R(dir))&&bk[mp[now.x][now.y]][i])
                dfs({now.x+fx[i][0],now.y+fx[i][1]},i);
        }
    }
}
void init()
{
    //bk[i][j] 表示编号为 i 的管道的方向 j 是开口的
    bk[1][2]=bk[1][3]=1;
    bk[2][0]=bk[2][3]=1;
    bk[3][0]=bk[3][1]=1;
    bk[4][1]=bk[4][2]=1;
    bk[5][0]=bk[5][2]=1;
    bk[6][1]=bk[6][3]=1;
    bk[7][0]=bk[7][1]=bk[7][2]=bk[7][3]=1;
}
int main()
{
    init();
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            char c;cin>>c;
            if(c=='M') st={i,j},mp[i][j]=-1;
            if(c=='Z') ed={i,j},mp[i][j]=-1;
            if(c>='1'&&c<='4') mp[i][j]=c-'0';
            if(c=='|') mp[i][j]=5;
            if(c=='-') mp[i][j]=6;
            if(c=='+') mp[i][j]=7;
        }
    }
    dfs(st,847);
}
```

有可能有一些小 bug，有 hack 欢迎指出。

---

## 作者：Spark_King (赞：0)

# P7185题解

~~这道题是真的肝，调了我一晚上。~~

## 题目大意

在一个 $ n\times m $ 的矩阵中通过在特定位置添加某一种管道使得图中从 M 到 Z 的路径联通且没有管道赘余。

当然题目保证数据有唯一解。

## 分析

这是一道十分《简单》的模拟题。

由于保证有唯一解并且没有管道赘余，于是我们可以从 M 或 Z 出发进行 BFS，只要在搜索途中发现有地方断开，那么这个地方就是缺少管道的地方，之后就可以根据该点周围的管道类型来输出答案。

就比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/gkc5dl5x.png)

不难看出，图中 $(3,4)$ 处缺少一个横向管道，依据是图中 $(3,3)$ 所连接的位置是空的，且该点也应与 $(3,5)$ 连接。

于是我们可以按照上述思路大致模拟一下。

不过这道题存在两个 Hack 数据，类似于以下两个特殊情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/46hj5spo.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/3x085rfm.png)

在图一中除了 M 和 Z 以外没有管道，所以这种情况下需要在这两个地点之间添加管道。图二中 $(2,4)$ 点周围没有管道，但是有一个 Z 点，所以在这种情况下我们要将地点看作管道。

清楚了这些，我们就可以快乐地写代码了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m; 
char mp[30][30];
pair<ll,ll> M,Z;
struct node
{
	ll x,y;
};
queue<node> q;
ll dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0};
bool flag,b[30][30];
void op1(ll x,ll y)
{
	cout<<x+1<<" "<<y<<" ";
	bool f[4]={0,0,0,0};
	if(mp[x+1][y-1]=='M'||mp[x+1][y-1]=='Z'||mp[x+1][y-1]=='-'||mp[x+1][y-1]=='+'||mp[x+1][y-1]=='1'||mp[x+1][y-1]=='2') f[1]++;
	if(mp[x+2][y]=='M'||mp[x+2][y]=='Z'||mp[x+2][y]=='|'||mp[x+2][y]=='+'||mp[x+2][y]=='2'||mp[x+2][y]=='3') f[2]++;
	if(mp[x+1][y+1]=='M'||mp[x+1][y+1]=='Z'||mp[x+1][y+1]=='-'||mp[x+1][y+1]=='+'||mp[x+1][y+1]=='3'||mp[x+1][y+1]=='4') f[3]++;
	if(f[1]&&f[2]&&f[3]) cout<<"+";
	else if(f[1]) cout<<3; 
	else if(f[2]) cout<<"|";
	else if(f[3]) cout<<2;
	return;
}
void op2(ll x,ll y)
{
	cout<<x-1<<" "<<y<<" ";
	bool f[4]={0,0,0,0}; 
	if(mp[x-1][y-1]=='M'||mp[x-1][y-1]=='Z'||mp[x-1][y-1]=='-'||mp[x-1][y-1]=='+'||mp[x-1][y-1]=='1'||mp[x-1][y-1]=='2') f[1]++;
	if(x-2>0&&(mp[x-2][y]=='M'||mp[x-2][y]=='Z'||mp[x-2][y]=='|'||mp[x-2][y]=='+'||mp[x-2][y]=='1'||mp[x-2][y]=='4')) f[2]++;
	if(mp[x-1][y+1]=='M'||mp[x-1][y+1]=='Z'||mp[x-1][y+1]=='-'||mp[x-1][y+1]=='+'||mp[x-1][y+1]=='4'||mp[x-1][y+1]=='3') f[3]++;
	if(f[1]&&f[2]&&f[3]) cout<<"+";
	else if(f[1]) cout<<4;
	else if(f[2]) cout<<"|";
	else if(f[3]) cout<<1;
	return;
}
void op3(ll x,ll y)
{
	cout<<x<<" "<<y+1<<" ";
	bool f[4]={0,0,0,0};
	if(mp[x-1][y+1]=='M'||mp[x-1][y+1]=='Z'||mp[x-1][y+1]=='|'||mp[x-1][y+1]=='+'||mp[x-1][y+1]=='1'||mp[x-1][y+1]=='4') f[1]++;
	if(mp[x][y+2]=='M'||mp[x][y+2]=='Z'||mp[x][y+2]=='-'||mp[x][y+2]=='+'||mp[x][y+2]=='4'||mp[x][y+2]=='3') f[2]++;
	if(mp[x+1][y+1]=='M'||mp[x+1][y+1]=='Z'||mp[x+1][y+1]=='|'||mp[x+1][y+1]=='+'||mp[x+1][y+1]=='3'||mp[x+1][y+1]=='2') f[3]++;
	if(f[1]&&f[2]&&f[3]) cout<<"+";
	else if(f[1]) cout<<3;
	else if(f[2]) cout<<"-";
	else if(f[3]) cout<<4;
	return;
}
void op4(ll x,ll y)
{
	cout<<x<<" "<<y-1<<" ";
	bool f[4]={0,0,0,0};
	if(mp[x-1][y-1]=='M'||mp[x-1][y-1]=='Z'||mp[x-1][y-1]=='|'||mp[x-1][y-1]=='+'||mp[x-1][y-1]=='2'||mp[x-1][y-1]=='3') f[1]++;
	if(y-2>0&&(mp[x][y-2]=='M'||mp[x][y-2]=='Z'||mp[x][y-2]=='-'||mp[x][y-2]=='+'||mp[x][y-2]=='1'||mp[x][y-2]=='2')) f[2]++;
	if(mp[x+1][y-1]=='M'||mp[x+1][y-1]=='Z'||mp[x+1][y-1]=='|'||mp[x+1][y-1]=='+'||mp[x+1][y-1]=='2'||mp[x+1][y-1]=='3') f[3]++;
	if(f[1]&&f[2]&&f[3]) cout<<"+";
	else if(f[1]) cout<<2;
	else if(f[2]) cout<<"-";
	else if(f[3]) cout<<1;
	return;
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=m;j++)
		{
			cin>>mp[i][j];
			if(mp[i][j]=='M') M.first=i,M.second=j,b[i][j]=1;
			if(mp[i][j]=='Z') Z.first=i,Z.second=j,b[i][j]=1; 
		}
	}
	for(ll i=1;i<=4;i++)
	{
		ll kx=M.first+dx[i],ky=M.second+dy[i];
		if(mp[kx][ky]=='.'||kx<=0||kx>n||ky<=0||ky>m) continue;
		if(mp[kx][ky]!='.')
		{
			flag=1;
			q.push({kx,ky});
		}
	}
	if(!flag)
	{
		for(ll i=1;i<=4;i++)
		{
			ll kx=Z.first+dx[i],ky=Z.second+dy[i];
			if(mp[kx][ky]=='.'||kx<=0||kx>n||ky<=0||ky>m) continue;
			if(mp[kx][ky]!='.')
			{
				flag=1;
				q.push({kx,ky});	
			}
		}
		if(!flag)
		{
			ll mx=M.first,my=M.second;
			ll zx=Z.first,zy=Z.second;
			if(zx==mx)
			{
				cout<<zx<<" "<<(zy+my)/2<<" -";
				return 0;
			}
			else if(zy==my)
			{
				cout<<(zx+mx)/2<<" "<<zy<<" |";
				return 0;
			}
		}
	}
	while(!q.empty())
	{
		ll x=q.front().x,y=q.front().y;
		q.pop();
		b[x][y]=1;
		if(mp[x][y]=='|')
		{
			if(mp[x+1][y]=='.')
			{
				op1(x,y);
				return 0;
			}
			if(mp[x-1][y]=='.')
			{
				op2(x,y);					
				return 0;
			}
			if(b[x+1][y]==0) q.push({x+1,y});
			if(b[x-1][y]==0) q.push({x-1,y});
		}
		else if(mp[x][y]=='-')
		{
			if(mp[x][y+1]=='.')
			{
				op3(x,y);
				return 0;
			}
			if(mp[x][y-1]=='.')
			{
				op4(x,y);
				return 0;
			}
			if(b[x][y+1]==0) q.push({x,y+1});
			if(b[x][y-1]==0) q.push({x,y-1});
		}
		else if(mp[x][y]=='1')
		{
			if(mp[x][y+1]=='.')
			{
				op3(x,y);
				return 0;
			}
			if(mp[x+1][y]=='.')
			{
				op1(x,y);
				return 0;
			}
			if(b[x][y+1]==0) q.push({x,y+1});
			if(b[x+1][y]==0) q.push({x+1,y});
		}
		else if(mp[x][y]=='2')
		{
			if(mp[x-1][y]=='.')
			{
				op2(x,y);				
				return 0;
			}
			if(mp[x][y+1]=='.')
			{
				op3(x,y);
				return 0;
			}
			if(b[x][y+1]==0) q.push({x,y+1});
			if(b[x-1][y]==0) q.push({x-1,y});
		}
		else if(mp[x][y]=='3')
		{
			if(mp[x][y-1]=='.')
			{
				op4(x,y);					
				return 0;
			}
			if(mp[x-1][y]=='.')
			{
				op2(x,y);				
				return 0;
			}
			if(b[x][y-1]==0) q.push({x,y-1});
			if(b[x-1][y]==0) q.push({x-1,y});
		}
		else if(mp[x][y]=='4')
		{
			if(mp[x][y-1]=='.')
			{
				op4(x,y);					
				return 0;
			}
			if(mp[x+1][y]=='.')
			{
				op1(x,y);
				return 0;
			}
			if(b[x][y-1]==0) q.push({x,y-1});
			if(b[x+1][y]==0) q.push({x+1,y});
		}
		else if(mp[x][y]=='+')
		{
			if(mp[x][y-1]=='.')
			{
				op4(x,y);				
				return 0;
			}
			if(mp[x+1][y]=='.')
			{
				op1(x,y);
				return 0;
			}
			if(mp[x-1][y]=='.')
			{
				op2(x,y);					
				return 0;
			}
			if(mp[x][y+1]=='.')
			{
				op3(x,y);
				return 0;
			}
			if(b[x][y+1]==0) q.push({x,y+1});
			if(b[x-1][y]==0) q.push({x-1,y});
			if(b[x][y-1]==0) q.push({x,y-1});
			if(b[x+1][y]==0) q.push({x+1,y});
		}
	}
	return 0;
}
```

---

## 作者：VitrelosTia (赞：0)

其实这道题的思路就是枚举和判断，判断每个点是否能合法就可以了，我们一步步来看。

首先是枚举，就是把每个 `.` 点尝试每一种变化，然后看看这种网格是不是正确的。大概写成这样。
```
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int k = 0; k <= 6; k++) {
				if (mp[i][j] != '.') continue;
				if (check(i, j, dir[k])) {
					cout << i << ' ' << j << ' ' << dir[k] << '\n';
					return 0;
				}
			}
		}
	}
```

然后就是 `check` 怎么写了，首先先把新的网格搞出来，然后枚举每一个点，看它是不是可以和附近的相连的。
```
bool check(int x, int y, char c) {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			a[i][j] = mp[i][j];
		}
	}
	a[x][y] = c;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (!ck(i, j)) {
				return false;
			}
		}
	}
	return true;
}
```

判断每一个点的过程在 `ck` 里。这个函数比较复杂，但其实思路很清晰，就是对于网格上的每一种情况进行讨论，每一种情况可以总结出这几个方式是不行的：

1. 开口处都是 `.` 即障碍；
2. 开口处与其它管道不连接。

我们就根据图分别把所有情况判断掉就行了。比较烦的是开头和终点，这个你需要特殊处理，因为这种情况只要有一边是连进管道的就行了。最终代码是比较长的，但其实内核思路非常清晰。
```
bool ck(int x, int y) {
	if (a[x][y] == '.') return true;
	if (a[x][y] == 'M' || a[x][y] == 'Z') {
		if (x > 1 && x < n && y > 1 && y < m) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4' || 
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		} 
		if (x == 1) {
			if (a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4' || 
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		}
		if (x == n) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4' || 
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		}
		if (y == 1) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y + 1] != '.' && a[x][y + 1] != '|' &&
				a[x][y + 1] != '1' || a[x][y + 1] != '2') return true;
		}
		if (y == m) {
			if (a[x - 1][y] != '.' && a[x - 1][y] != '-' &&
				a[x - 1][y] != '2' && a[x - 1][y] == '3' || 
				a[x + 1][y] != '.' && a[x + 1][y] != '-' &&
				a[x + 1][y] != '1' && a[x + 1][y] != '4' ||
				a[x][y - 1] != '.' && a[x][y - 1] != '|' &&
				a[x][y - 1] != '3' && a[x][y - 1] != '4') return true;
		}
		return false;
	}
	if (a[x][y] == '|') {
		if (x == 1 || x == n) return false;
		if (a[x - 1][y] == '.' || a[x + 1][y] == '.' ||
		    a[x - 1][y] == '-' || a[x + 1][y] == '-' ||
			a[x - 1][y] == '2' || a[x - 1][y] == '3' || 
			a[x + 1][y] == '1' || a[x + 1][y] == '4') return false;
		return true;
	}
	if (a[x][y] == '-') {
		if (y == 1 || y == m) return false;
		if (a[x][y - 1] == '.' || a[x][y + 1] == '.' ||
		    a[x][y - 1] == '|' || a[x][y + 1] == '|' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4' || 
			a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '+') {
		if (x == 1 || x == n || y == 1 || y == m) return false;
		if (a[x - 1][y] == '.' || a[x + 1][y] == '.' || a[x][y - 1] == '.' || a[x][y + 1] == '.' || 
			a[x - 1][y] == '-' || a[x + 1][y] == '-' ||
			a[x][y - 1] == '|' || a[x][y + 1] == '|' || 
			a[x - 1][y] == '2' || a[x - 1][y] == '3' || a[x + 1][y] == '1' || a[x + 1][y] == '4' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4' || a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '1') {
		if (x == n || y == m) return false;
		if (a[x + 1][y] == '.' || a[x][y + 1] == '.' || 
			a[x + 1][y] == '-' ||
			a[x][y + 1] == '|' ||
			a[x + 1][y] == '1' || a[x + 1][y] == '4' ||
			a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '2') {
		if (x == 1 || y == m) return false;
		if (a[x - 1][y] == '.' || a[x][y + 1] == '.' ||
			a[x - 1][y] == '-' ||
			a[x][y + 1] == '|' || 
			a[x - 1][y] == '2' || a[x - 1][y] == '3' || 
			a[x][y + 1] == '1' || a[x][y + 1] == '2') return false;
		return true;
	}
	if (a[x][y] == '3') {
		if (x == 1 || y == 1) return false;
		if (a[x - 1][y] == '.' || a[x][y - 1] == '.' ||
			a[x - 1][y] == '-' ||
			a[x][y - 1] == '|' ||
			a[x - 1][y] == '2' || a[x - 1][y] == '3' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4') return false;
		return true;
	}
	if (a[x][y] == '4') {
		if (x == n || y == 1) return false;
		if (a[x + 1][y] == '.' || a[x][y - 1] == '.' ||
			a[x + 1][y] == '-' ||
			a[x][y - 1] == '|' || 
			a[x + 1][y] == '1' || a[x + 1][y] == '4' ||
			a[x][y - 1] == '3' || a[x][y - 1] == '4') return false;
		return true;
	}
}
```

那么这道题就愉快地做完了。

---


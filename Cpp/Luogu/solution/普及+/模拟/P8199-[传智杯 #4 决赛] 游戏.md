# [传智杯 #4 决赛] 游戏

## 题目背景

小智正在看 B 站非著名 up 主脚踢喷火幼儿园（下称喷火）和他的朋友 ATA_Radio_STN 和 sltheen 正在游玩著名游戏《PLAYERUNKNOWN’S BATTLEGROUNDS》（绝地求生：大逃杀）。

## 题目描述

喷火刚刚跳伞落地，周围危机四伏，他的手中有一个初始背包，他捡到的所有物资都会装在这个背包里，游戏地图被简化为一个 $n \times m$ 的网格图，每个格子里要么是物资，要么是敌人。

物资分为主/副武器和弹药，其中弹药又分为子弹与投掷物。每种武器会对应使用某种子弹。例如：Beryl M762 突击步枪使用 7.62mm 子弹，M416 突击步枪使用 5.56mm 子弹，而 AKM 突击步枪也使用 7.62mm 子弹。

当喷火走到一个含有物资的格子的时候，他会拾起地上的物资并放入背包。但背包容量有限，因此当背包装满的时候，他将会扔掉一部分物资以装下新的物资。他将按照以下规则丢弃物资：
1.	如果捡到的是武器，那么按照霰弹枪>突击步枪>射手步枪>栓动步枪>空手的优先级进行替换。优先替换主武器，且主武器优先级必须严格高于副武器。如果替换主武器，那么替换下来的主武器被**直接丢弃**，不再用其替换副武器。
2.	若有不需要的子弹（指主副武器均不使用的子弹），最优先丢掉这些子弹，直至空间足够装下新的物资。
3.	若丢掉全部不需要子弹后空间仍旧不足，或有多种不需要的子弹，优先丢掉最晚拾取时间最早的弹药（包括主副武器使用的子弹和投掷物），直至空间足够装下新的物资（需要注意的是，即使新物资是「不需要的子弹」，在丢掉所有原有的「不需要的子弹」后如果背包空间还是不够，则喷火依然会丢掉其他弹药直到捡起所有「不需要的子弹」）。
4.	无论捡到的是新物资，还是已经有的物资，该物资的最晚拾取时间都将被更新为当前时间点。
5.	武器最多同时持有两种，即主/副武器，同优先级的主/副武器不进行替换。

每个格子的物资只会拾取一次。当第二次进入某个格子的时候，物品不会刷新，即不会捡起上次在这个格子丢掉的物品，也不会再次捡到初始时的物品。

当喷火走到含有敌人的格子的时候，他会与敌人进行战斗，他的战斗力很强悍，只需要有足够的子弹即可消灭敌人。每个敌人有两个参数 $a,b$，代表需要消耗 $a$ 发主武器子弹，若主武器子弹不够，则不消耗主武器子弹，而消耗 $b$ 发副武器子弹。若主副武器均没有足够子弹，则喷火被敌人反杀，然后敌人会在喷火的盒子上做蹲起嘲讽他。

每个格子的敌人只会出现一次。如果第二次进入某一个有敌人的格子，则什么都不会发生。

现在，喷火跳在了第一行第一列的格子上，ATA_Radio_STN 已经为喷火摸清了地图形势，而 sltheen 会给喷火下指示，喷火想知道，当他执行完最后一条指示之后，他是否还存活，若存活，按照最晚拾取时间时间从早到晚，输出背包内物品种类和数量，若死亡，输出他死亡格子的坐标。

下附可能出现的物资、物资类别、物资使用的子弹种类、物资所需空间以及物资对应编号。

武器：
| 武器名称 | 武器类型| 使用的子弹类型 | 编号 |
| --- | --- | ---  | ---|
| 空手 | 空手 | N/A | 0|
|BerylM762|突击步枪|7.62mm子弹|1|
|AKM|突击步枪|7.62mm子弹|2|
|SKS|射手步枪|7.62mm子弹|3|
|Kar98K|栓动步枪|7.62mm子弹|4|
|M416|突击步枪|5.56mm子弹|5|
|MK12|射手步枪|5.56mm子弹|6|
|Mini14|射手步枪|5.56mm子弹|7|
|S686|霰弹枪|12号霰弹|8|
|DBS|霰弹枪|12号霰弹|9|

弹药
|弹药名称| 类型 | 占用空间 | 编号 |
| - | - | - | - |
|FragGrenade|投掷物| 5  |   10|
|SmokeGrenade| 投掷物 |    4|    11|
|MolotovCocktail |投掷物  | 3 |    12|
|Flashbang |投掷物        | 2    | 13|
|7.62mm |子弹 |0.2|                14|
|5.56mm| 子弹| 0.1                |15|
|3in（12号霰弹）| 子弹| 0.5|                     16|

请注意，上表中子弹的「占用空间」表示一发子弹所占用的空间。

另外，敌人在地图上的编号为 17。



## 说明/提示

### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n, m \leq 100$，且 $1 \leq  n \times m \leq 100$。
- $1 \leq k \leq 500$，$1 \leq t,a,b  \leq 200$。
- $1 \leq x \leq 16$，$1 \leq y \leq 5000$。
- $1 \leq op \leq 4$。
- 数据保证每个格子内只有一种物资（或一个敌人），且背包能够装下任意一格的物资。

## 样例 #1

### 输入

```
3 3 60 8
1 1
14 300
15 30
5 1
10 1
17 11 10
17 10 10
17 10 10
15 10
4
4
2
3
3
2
4
4
```

### 输出

```
1
0
14 254
10 1
15 12
```

# 题解

## 作者：一扶苏一 (赞：13)

## E. 游戏

**题意**：略，详见题面。

**关键词**：模拟。

**参考难度**：绿。

**解析**：依照题意模拟即可。

对于每种武器开一个 use 数组表示他们使用子弹的编号，即可快速判断某种弹药是不是「无用的」；

可以维护一个变量 last 表示目前背包的剩余空间，在捡物资时，先将物资捡起来并更新 last，然后在 $\mathrm{last} \lt 0$ 时，枚举所有的物资，找到最符合要求的并扔掉即可。

设 $used(i)$ 表示 $i$ 是否是「被用到的」弹药，则 $i$ 比 $j$ 「更应该」被扔掉当且仅当 $used(i) \lt used(j)$ 或者 $used(i) = used(j)$ 且 $tm(i) \gt tm(j)$，其中 $tm(i)$ 表示 $i$ 最后被捡起的时间。

需要注意的是：使用浮点数进行运算可能产生精度误差，因此可以将容量和占用空间都乘 $10$，这样就可以全部使用整形运算了。

std 的长度为 69 行，2.5k。

(C++)

```cpp
#include <array>
#include <iostream>
#include <algorithm>

const int maxn = 105;

int n, m, s, t, w1, w2, lst;

std::array<std::array<int, maxn>, maxn> type, a, b, vis;
std::array<int, maxn> tm, arr, cnt;
const std::array<int, 5> dx{0, -1, 1, 0, 0}, dy{0, 0, 0, -1, 1};
const std::array<int, 10> use{0,  14, 14, 14, 14, 15, 15, 15, 16, 16}, level{5, 2, 2, 3, 4, 2, 3, 3, 1, 1};
const std::array<int, 17> weight{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 40, 30, 20, 2, 1, 5};

inline bool used(int x) { return x && ((x <= 13) ? true : (use[w1] == x || use[w2] == x)); }
inline bool cmp(const int x, const int y) { return tm[x] > tm[y]; }

void work(int curx, int cury) {
  vis[curx][cury] = true;
  if (type[curx][cury] == 17) {
    if (cnt[use[w1]] >= a[curx][cury]) {
      cnt[use[w1]] -= a[curx][cury];
      lst += a[curx][cury] * weight[use[w1]];
    } else if (cnt[use[w2]] >= b[curx][cury]) {
      cnt[use[w2]] -= b[curx][cury];
      lst += b[curx][cury] * weight[use[w2]];
    } else {
      std::cout << curx << ' ' << cury << '\n';
      exit(0);
    }
  } else if (type[curx][cury] < 10) {
    if (level[w1] > level[type[curx][cury]]) w1 = type[curx][cury];
    else if (level[w1] < level[type[curx][cury]] && level[w2] > level[type[curx][cury]]) w2 = type[curx][cury];
  } else {
    lst -= a[curx][cury] * weight[type[curx][cury]];
    for (int i = 0; lst < 0; i = 0) {
      for (int p = 10; p < 17; ++p) if (cnt[p]) 
        if ((!cnt[i]) || (used(p) < used(i)) || ((used(p) == used(i)) && (tm[p] > tm[i]))) i = p;
      int tmp = std::min(cnt[i], (-lst) / weight[i] + ((lst % weight[i]) ? 1 : 0));
      lst += tmp * weight[i];
      cnt[i] -= tmp;
    }
    tm[type[curx][cury]] = t;
    cnt[type[curx][cury]] += a[curx][cury];
  }
}

int main() {
  std::cin >> n >> m >> s >> t; lst = s *= 10;
  for (int i = 1; i <= n; ++i) 
    for (int j = 1; j <= m; ++j) {
      std::cin >> type[i][j] >> a[i][j];
      if (type[i][j] == 17) 
        std::cin >> b[i][j];
    }
  tm.fill(998244353); 
  work(1, 1);
  --t;
  for (int op, curx = 1, cury = 1; ~t; --t) {
    std::cin >> op;
    if (vis[curx += dx[op]][cury += dy[op]]) continue;
    work(curx, cury);
  }
  for (int i = 10; i < 17; ++i) arr[i] = i;
  std::sort(arr.begin() + 10, arr.begin() + 17, cmp);
  std::cout << w1 << '\n' << w2  << '\n';
  for (int i = 1; i < 17; ++i) if (cnt[arr[i]] != 0) 
    std::cout << arr[i] << ' ' << cnt[arr[i]] << '\n';
}
```

题外话：本题构造数据的方法是：随机修改 std 若干处，然后和正确的 std 对拍，拍出一组加一组。

---

## 作者：XBaiC (赞：2)

# 1.题目概述

~~作者太蒻了，写不出来~~。。。

就是个大模拟，仔细读题吧。

# 2.解析

写点注意事项吧。子弹占用空间要 $ \times 10 $，以消除浮点误差。丢掉子弹的时候一定要找到最早捡到的并且是主副武器均不可使用的。

之后就按照题意模拟就行了，~~可以去其他题解里看~~，可以先定义一个变量，代表背包剩余空间，先将物资捡起来并更新变量，枚举所有的物资，找到最符合要求的并扔掉就可以了。这里就不多说了。

# 3.AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mm = 1005;
int mapp[mm][mm][5];
bool p[mm][mm];
int bb[17][4];//背包。1数量，2时间，3输出时调用 
int n,k,l,m,t,kn,xi,yi,KO,qiang1,qiang2,need1,need2,xxx;
void moves(int x){//向四个方向的移动
	if(x==1)xi--;
	if(x==2)xi++;
	if(x==3)yi--;
	if(x==4)yi++;
}
int level(int x){
	if(x==0) return 0;
	if(x==4) return 1;
	if(x==3||x==6||x==7) return 2;
	if(x==1||x==2||x==5) return 3;
	if(x==8||x==9) return 4;
}
void qiang(int x){
	int l1,l2,l3;
	l1=level(qiang1);l2=level(qiang2);l3=level(x);
	if(l3>l1){
		qiang1=x;
		return;
	}
	if(l3<l1&&l3>l2){
		qiang2=x;
		return;
	}
}
int space(int x,int y){//计算占用空间时*10，避免浮点误差
	if(x==10) return 50*y;
	if(x==11) return 40*y;
	if(x==12) return 30*y;
	if(x==13) return 20*y;
	if(x==14) return 2*y;
	if(x==15) return y;
	if(x==16) return 5*y;
}
int need_fire(int x){//需要的子弹类型
	if(x==0) return 0;
	if(x==1||x==2||x==3||x==4) return 14;
	if(x==5||x==6||x==7) return 15;
	if(x==8||x==9) return 16;
} 
int up(int x,int y){// x/y 向上取整
	if(x%y) return x/y+1;
	return x/y;
}
int need_lose(int spa,int x){
	if(x==10) return up(spa,50);
	if(x==11) return up(spa,40);
	if(x==12) return up(spa,30);
	if(x==13) return up(spa,20);
	if(x==14) return up(spa,2);
	if(x==15) return up(spa,1);
	if(x==16) return up(spa,5);
}
void take_fire(int spa){
	if(kn+spa<=k){
		kn+=spa;
		bb[mapp[xi][yi][0]][1]+=mapp[xi][yi][1];
		bb[mapp[xi][yi][0]][2]=xxx;
	}
	else{
		int p1=1,p2=0;
		while(kn+spa>k){
			if(p1){
				p2=1;
				int kkk=1e9,ccf;
				for(int i=14;i<=16;i++){
					if(bb[i][1]&& i!=need1 && i!=need2){
						if(kkk>bb[i][2]){
							kkk=bb[i][2];ccf=i;p2=0;
						}
					}
				}
				
				if(p2){
					p1=0;continue;
				}
				int loss=need_lose(kn+spa-k,ccf);
				kn-=space(ccf,min(loss,bb[ccf][1]));
				bb[ccf][1]=max(0,bb[ccf][1]-loss);		
			}
			else{
				int kkk=1e9,ccf;
				for(int i=10;i<=16;i++){
					if(bb[i][1]){
						if(kkk>bb[i][2]){
							kkk=bb[i][2];ccf=i;
						}
					}
				}
				int loss=need_lose(kn+spa-k,ccf);
				kn-=space(ccf,min(loss,bb[ccf][1]));
				bb[ccf][1]=max(0,bb[ccf][1]-loss);	
			}
		}
		kn+=spa;
		bb[mapp[xi][yi][0]][1]+=mapp[xi][yi][1];
		bb[mapp[xi][yi][0]][2]=xxx;
	}
}
void fight(){
	int now1,now2;
	now1=bb[need_fire(qiang1)][1];
	now2=bb[need_fire(qiang2)][1];
	if(now1>=mapp[xi][yi][1]){
		bb[need_fire(qiang1)][1]-=mapp[xi][yi][1];
		kn-=space(need_fire(qiang1),mapp[xi][yi][1]);
	}
	else if(now2>=mapp[xi][yi][2]){
		bb[need_fire(qiang2)][1]-=mapp[xi][yi][2];
		kn-=space(need_fire(qiang2),mapp[xi][yi][2]);
	}
	else KO=1;
}
void doo(){
	if(p[xi][yi]) return;
	p[xi][yi]=1;
	if(mapp[xi][yi][0]>=1&&mapp[xi][yi][0]<=9){
		qiang(mapp[xi][yi][0]);
		return;
	}
	if(mapp[xi][yi][0]>=10&&mapp[xi][yi][0]<=16){
		int spa=space(mapp[xi][yi][0],mapp[xi][yi][1]);
		need1=need_fire(qiang1);need2=need_fire(qiang2);
		take_fire(spa);
	}
	if(mapp[xi][yi][0]==17) fight();
	
}
int main(){
	int i,j;
	cin>>n>>m>>k>>t;
	k*=10;
	for(i=1;i<=n;i++){//读入地图 
		for(j=1;j<=m;j++){
			cin>>mapp[i][j][0]>>mapp[i][j][1];
			if(mapp[i][j][0]==17){
				cin>>mapp[i][j][2];
			}
		}
	}
	xi=1;yi=1;KO=0;xxx=0;
	doo();
	for(xxx=1;xxx<=t;xxx++){
		cin>>l;
		moves(l);
		doo();
		if(KO){
			break;
		}
	} 
	if(KO){
		printf("%d %d\n",xi,yi);
	}
	else{
		printf("%d\n",qiang1);
		printf("%d\n",qiang2);
		int p1=1;
		while(p1){
			p1=0;
			int kkk=1e9,ccf;
			for(int i=10;i<=16;i++){
				if(bb[i][1]){
					if(kkk>bb[i][2]){
						kkk=bb[i][2];ccf=i;p1=1;
					}
				}
			}
			if(p1==0) break;
			printf("%d %d\n",ccf,bb[ccf][1]);
			bb[ccf][1]=0;
		}
		
	}
	return 0;
} 

```


---

## 作者：kardsOI (赞：1)

题意还是很容易看懂的，代码构造也不算很难，不过还是有许多点要注意的，这里列一下大型翻车点：
1. 走过的格子要马上想办法让它不会再拿一次物资或打一次敌人。
2. 退出子弹的顺序，先退出那些没用的子弹，然后**再是投掷物**和主副武器用的子弹，这里没有更多例如“副武器先退”之类的无中生有的原则
3. 如果退出子弹时需要腾出的空间不能被单颗待退子弹占用空间整除，注意多退一颗子弹。
4. 杀掉敌人后，要及时减去用了的子弹，并腾出相应背包空间。
5. 如果代替换武器优先级与现有主武器优先级相等，它不会替换任何武器，因为且主武器优先级必须严格高于副武器。
6. 注意第一行第一列是地图的左上角，最后一行第一列是地图的左下角，走法一定要算好。
7. 落地第一格的物资也要拿。

我发现的大概也就那么多了。直接上代码吧。代码中有不少优化技巧，注释中都给写上了，应该算易懂了吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,kn,orn,order,used,map2[110][110],need;
int map1[110][110],map3[110][110];
int nx,ny,id,goal;
int needn[15]={0,5,5,5,5,6,6,6,7,7},par[15]={0,3,3,2,1,3,2,2,4,4};
//需要弹药号码，优先强度（越高越不容易被替换）
int v[10]={0,50,40,30,20,2,1,5}; //子弹占用空间*10,no float! 
int zgun,fgun;//主，副武器 
bool killed;//成盒了 
int dx,dy;//成盒地点 
int buln[10],bult[10],cn;//弹药数量，最后拾取的时间，拾取过几次弹药 
void attack()
{
	if(buln[needn[zgun]]>map2[ny][nx])
	{
		buln[needn[zgun]]-=map2[ny][nx];
		used-=map2[ny][nx]*v[needn[zgun]];
	}
	else if(buln[needn[fgun]]>map3[ny][nx])
	{
		buln[needn[fgun]]-=map3[ny][nx];
		used-=map3[ny][nx]*v[needn[fgun]];
	}
	else 
	{
		killed=1;
		dx=nx;
		dy=ny;
	}
	map1[ny][nx]=0;
}
void bullet()
{
	map1[ny][nx]-=9;//编号-9以适应记录的代号
	need=v[map1[ny][nx]]*map2[ny][nx];
	if(need+used<=kn)
	{
		buln[map1[ny][nx]]+=map2[ny][nx];
		bult[map1[ny][nx]]=++cn;
		used+=need;
		map1[ny][nx]=0;
		return;
	}
	used+=need;
	do//超过背包容量,先从非武器弹药找 
	{
		id=0;//用来替换的子弹 
		for(int i=5;i<=7;i++)
		{
			if(buln[i]&&needn[zgun]!=i&&needn[fgun]!=i&&bult[i]<bult[id]) id=i;
		}
		goal=used-kn;//需要空间数量 
		if(buln[id]*v[id]<=goal)//退完还不够或者刚好，全退了 
		{
			used-=buln[id]*v[id];
			buln[id]=0;
			continue;
		}
		if(goal%v[id]==0)
		{
			used=kn;
			buln[id]-=goal/v[id];
		}
		else
		{
			used=used-(goal/v[id]+1)*v[id];//不整除则多抛弃一发弹药 
			buln[id]-=goal/v[id]+1;
		}
	}
	while(used>kn&&id!=0);
	if(used>kn)
	do//还超过背包容量,全局找！ 
	{
		id=0;//用来替换的子弹 
		for(int i=1;i<=7;i++)
		{
			if(buln[i]&&bult[i]<bult[id]) id=i;
		}
		goal=used-kn;//需要空间数量 
		if(buln[id]*v[id]<=goal)//退完还不够或者刚好，全退了 
		{
			used-=buln[id]*v[id];
			buln[id]=0;
			continue;
		}
		if(goal%v[id]==0)
		{
			used=kn;
			buln[id]-=goal/v[id];
		}
		else
		{
			used=used-(goal/v[id]+1)*v[id];//不整除则多抛弃一发弹药 
			buln[id]-=goal/v[id]+1;
		}
	}
	while(used>kn&&id!=0);
	buln[map1[ny][nx]]+=map2[ny][nx];
	bult[map1[ny][nx]]=++cn;
	map1[ny][nx]=0;
}
void gun()
{
	if(par[map1[ny][nx]]>par[zgun]) zgun=map1[ny][nx];
	else if(par[map1[ny][nx]]>par[fgun]&&par[map1[ny][nx]]<par[zgun]) fgun=map1[ny][nx];
	map1[ny][nx]=0;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&kn,&orn);
	kn*=10;//no float!
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&map1[i][j]);
			if(map1[i][j]==17) scanf("%d%d",&map2[i][j],&map3[i][j]);//敌人 
			else  scanf("%d",&map2[i][j]);//物资 
		}
	}
	bult[0]=100000;
	nx=1;
	ny=1;
	if(map1[ny][nx]>0&&map1[ny][nx]<10) gun();
	else if(map1[ny][nx]>=10&&map1[ny][nx]<=16) bullet();
	else if(map1[ny][nx]==17) attack();
	for(int i=1;i<=orn;i++)
	{
		scanf("%d",&order);
		if(killed) continue;
		if(order==1) ny--;
		else if(order==2) ny++;
		else if(order==3) nx--;
		else if(order==4) nx++;
		if(map1[ny][nx]>0&&map1[ny][nx]<10) gun();
		else if(map1[ny][nx]>=10&&map1[ny][nx]<=16) bullet();
		else if(map1[ny][nx]==17) attack();
	}
	if(killed)
	{
		printf("%d %d\n",dy,dx);
	}
	else
	{
		printf("%d\n%d\n",zgun,fgun);
		do
		{
			id=0;
			for(int i=1;i<=7;i++)
			{
				if(bult[i]<bult[id]&&buln[i]) id=i;
			}
			if(!id) break;
			printf("%d %d\n",id+9,buln[id]);
			buln[id]=0;
		}
		while(1);
	}
    return 0;
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/plnhfv1l.png)

有什么问题可以私信，我尽量抽时间回答。

---

## 作者：wuhan1234 (赞：1)

## 1.编程思路。
本题是一道模拟题，按题目的要求进行直接模拟即可。

题目中涉及有 $9$ 种武器（空手除外），$7$ 种弹药，每种武器需要指定类型的子弹，每种弹药在背包中需要占一定的空间。武器在替换时，还有替换的优先级设定。在进行模拟前，需要先要将题目给出的这些信息保存下来，便于后面程序处理时引用。

为此，可以定义如下 $3$ 个数组：

``int level[10]={0,3,3,2,1,3,2,2,4,4}; ``

``int needBullet[10]={0,14,14,14,14,15,15,15,16,16}; ``

``int needSpace[17]={0,0,0,0,0,0,0,0,0,0,50,40,30,20,2,1,5}; ``

其中，数组 $level$ 保存武器替换的优先级，数字越大优先级越高。例如，数组元素 $level[8]$ 和 $level[9]$ 的值均为最大值 $4$，表示武器替换时，霰弹枪的优先级最高。编号为 $8$ 和 $9$ 的武器均为霰弹枪。

 数组 $needBullet$ 保存各种武器需要的子弹类型，数组元素 $needBullet[i]$ 的值就是编号为 $i$ 的武器所需子弹的编号。
 
 数组 $needSpace$ 保存各种类型弹药所需占用的背包空间，为避免浮点运算，将所占空间大小的值均乘以 $10$。数组元素 
 $needSpace[i]$ 的值就是编号为 $i$ 的弹药所需占用的背包空间。 
 
 另外，根据题意还定义如下 $3$ 个数组：
 
 ``int map[105][105][3];  ``
 
 ``int vis[105][105]={0}; ``
 
 ``int bp[17][3]; ``
 
 其中，数组 $map$ 用于保存游戏地图。数组元素 
$map[i][j][0]$ 表示格子 $(i,j)$处的物资（武器或弹药）的编号，$map[i][j][1]$ 表示该物资的数量，$map[i][j][2]$ 只在 $map[i][j][0]=17$ 时使用，表示敌人的参数 $b$（此时 $map[i][j][1]$ 表示敌人的参数 $a$）。

数组 $vis$ 用于记录每个格子的访问情况，初始值全部设为 $0$。数组元素 $vis[i][j]=0$ 表示格子 $(i,j)$ 之前未来过，需要根据格子中的物资情况进行处理，访问过后修改为 $1$。这样下次再进入这个格子，什么事都不用做。当然，$vis$ 数组也可以不用。一种可行的替代方案是，处理完某个第 $1$ 次到达的格子 $(i,j)$ 后，将数组元素 $map[i][j][0]$ 的值置为 $0$ 即可，格子 $(i,j)$ 中没有物资，当然不用进行任何处理。
       
数组 $bp$ 用于保存背包(backpack）中弹药的装载情况。数组元素 $bp[i][1]$ 保存背包中所装载的编号为 $i$ 的弹药的数量，$bp[i][2]$ 保存所装载的编号为 $i$ 的弹药的最晚捡起时间。

之后，就是对游戏中喷火接收到的指令进行处理，根据指令到达了一个格子后，若格子是第 $1$ 次到达，根据游戏地图所保存的格子中物资的情况，进行相应的处理，或者更换武器，或者腾出空间拾取弹药装入背包，或者与敌人战斗。按题目要求进行直接模拟。

具体的实现细节参看给出的源程序。

## 2.源程序。

```c
#include <stdio.h>
int level[10]={0,3,3,2,1,3,2,2,4,4};  // 武器替换优先级，数字越大优先级越高
int needBullet[10]={0,14,14,14,14,15,15,15,16,16};         // 各武器需要的子弹类型
int needSpace[17]={0,0,0,0,0,0,0,0,0,0,50,40,30,20,2,1,5}; // 各类型子弹占用空间*10
int map[105][105][3];
int vis[105][105]={0};
int bp[17][3];
int k,times;           // 背包总容量和捡起弹药的时间（以下达指令的顺序计时）
int mw,sw;             // 主武器（mainWeapon）和副武器（subWeapon）的编号
int x,y;               // 格子(x,y)的坐标位置
int KO=0;              // KO=1表示喷火在格子(x,y)处被敌人干掉
int used=0;            // 背包已经使用的空间
void pickUp()          // 捡起格子(x,y)中的弹药
{
    int space=needSpace[map[x][y][0]]*map[x][y][1];  // 计算格子(x,y)处弹药需占用空间
	int need1=needBullet[mw];
	int need2=needBullet[sw];
	if (used+space<=k)        // 背包剩余空间可以装下格子(x,y)处的弹药
    {
	    used+=space;
	    bp[map[x][y][0]][1]+=map[x][y][1];
	    bp[map[x][y][0]][2]=times;
    }
    else                      // 背包剩余空间不够，需要先腾出空间，再装格子(x,y)处的弹药
    {
	    int flag1=1,flag2=0;  // flag1=1表示找的是主副武器均不需要的子弹
	    int i,mint,id,loss;
	    while (used+space>k)
	    {
		    if (flag1)
		    {
			    flag2=1;
			    mint=1e9;
			    for (i=14;i<=16;i++)  // 找主副武器均不需要的最晚拾取时间最早的弹药
                {
				    if (bp[i][1] && i!=need1 && i!=need2)
				    {
					    if (mint>bp[i][2])
					    {
						    mint=bp[i][2];   id=i;
						    flag2=0;
					    }
				    }
			    }
			    if (flag2)    // 背包中找不到主副武器均不需要的子弹
			    {
				    flag1=0;  continue;
			    }
			    loss=(used+space-k+needSpace[id]-1)/needSpace[id];// 计算需要丢掉的弹药数量
			    loss=loss<bp[id][1]?loss:bp[id][1];      // 背包中实际可以丢掉的弹药数量
			    used-=needSpace[id]*loss;
			    bp[id][1]=bp[id][1]-loss;
		    }
		    else
		    {
			    mint=1e9;
			    for (i=10;i<=16;i++)
			    {
				    if (bp[i][1])
				    {
					    if (mint>bp[i][2])
					    {
						   mint=bp[i][2];  id=i;
					    }
				    }
			    }
			    loss=(used+space-k+needSpace[id]-1)/needSpace[id];  // 计算需要丢掉的弹药数量
			    loss=loss<bp[id][1]?loss:bp[id][1];      // 背包中实际可以丢掉的弹药数量
			    used-=needSpace[id]*loss;
			    bp[id][1]=bp[id][1]-loss;
		    }
	    }
	    used+=space;      // 捡起格子中的弹药装入背包
	    bp[map[x][y][0]][1]+=map[x][y][1];
	    bp[map[x][y][0]][2]=times;
    }
}
void fight()           // 在格子(x,y)中与敌人战斗
{
	int a,b;
	a=bp[needBullet[mw]][1];
	b=bp[needBullet[sw]][1];
	if (a>=map[x][y][1])    // 有足够的主武器子弹，消耗a发主武器子弹
    {
		bp[needBullet[mw]][1]-=map[x][y][1];
		used-=needSpace[needBullet[mw]]*map[x][y][1];
	}
	else if (b>=map[x][y][2])  // 主武器子弹不够，有足够的副武器子弹，消耗b发副武器子弹
	{
		bp[needBullet[sw]][1]-=map[x][y][2];
		used-=needSpace[needBullet[sw]]*map[x][y][2];
	}
	else KO=1;   // 主副武器均没有足够子弹，被敌人反杀
}
void deal()   // 进入格子(x,y)后进行相应的处理
{
	if (vis[x][y]) return;
	vis[x][y]=1;
	if (map[x][y][0]>=1&&map[x][y][0]<=9)  // 格子(x,y)中是武器,进行武器替换
    {
        int l1,l2,l3;
	    l1=level[mw];
	    l2=level[sw];
	    l3=level[map[x][y][0]];
	    if (l3>l1)	mw=map[x][y][0];
	    else if (l3<l1 && l3>l2) sw=map[x][y][0];
	}
	else if (map[x][y][0]>=10&&map[x][y][0]<=16)  // 格子(x,y)中是弹药,腾出空间捡起弹药
        pickUp();
	else if (map[x][y][0]==17)                   // 格子(x,y)中是敌人，进行战斗
        fight();
}
int main()
{
    int dx[5]={0,-1,1,0,0};
    int dy[5]={0,0,0,-1,1};
    int n,m,t;
	scanf("%d%d%d%d",&n,&m,&k,&t);
	k*=10;    // 背包容量扩大10倍，以避免浮点运算
    int i,j;
	for (i=1;i<=n;i++)
    {
		for (j=1;j<=m;j++)
        {
			scanf("%d%d",&map[i][j][0],&map[i][j][1]);
			if (map[i][j][0]==17)
            {
				scanf("%d",&map[i][j][2]);
			}
		}
	}
	x=1;  y=1;
	deal();
	for (times=1;times<=t;times++)
    {
        int op;
		scanf("%d",&op);
		if (KO)     // 喷火已死亡，将后面的指令直接读完
        {
			continue;
		}
        x=x+dx[op];
        y=y+dy[op];
		deal();
	}
	if (KO)
    {
		printf("%d %d\n",x,y);
	}
	else
    {
		printf("%d\n",mw);
		printf("%d\n",sw);
		int pos[7];
		for (i=0;i<=6;i++)
            pos[i]=10+i;
		for (i=0;i<6;i++)
            for (j=i+1;j<=6;j++)
                if (bp[pos[i]][2]>bp[pos[j]][2])
                {
                    int tmp=pos[i];
                    pos[i]=pos[j]; pos[j]=tmp;
                }
		for (i=0;i<=6;i++)
            if (bp[pos[i]][1]) printf("%d %d\n",pos[i],bp[pos[i]][1]);
	}
	return 0;
}

```
## 3.题外说明
上面的源程序提交给 P8199 后可以 Accepted。但我觉得并不踏实。命题人给出的测试数据集没法看到，也就不知道命题人考虑过如下的问题没有。

题目中给出了手榴弹、烟雾弹、燃烧弹、闪光弹等 $4$ 种弹药，实际上除了拾取装入背包或为了腾出空间从背包中丢弃外，什么作用也不起。按我们的理解，这 $4$ 种弹药是可以用手进行投掷的，也就是说它们可以作为手这个武器所使用的子弹类型，除非主、副武器均不是手，双手被占用，没法投掷。但题目中并没有进行交代，题目也没交代这 $4$ 种投掷类弹药用于消灭敌人时如何消耗。

如果上面的 $4$ 种弹药不用于消灭敌人，那放在题目中进行设置其意义不大。还不如改成宝物类物资（可以设定每种宝物的价值），表示喷火可以根据背包容量和已有宝物价值的情况，决定是否拾取这个宝物。最后正好可以列举喷火捡到的宝物情况。

 

---

## 作者：违规用户名^3Zj=Oha (赞：0)

## 一、思路分析

题目中看似输入十分麻烦，但实际上就直接用常规的输入即可，遇到敌人特判。

用两个函数去处理枪械对应的子弹编号和枪械等级，然后去按 sltheen 的指示操控喷火遍历地图。

按 sltheen 的指示去进行遍历，每个地方有以下几个情况：

* $(x,y)$ 项为枪械：我们去看枪械的等级，若比主武器高，即替换。若比主武器低且比副武器高，替换副武器。若和主武器相等，则无事发生。
* $(x,y)$ 项为敌人：我们用此前记录的敌人所需的子弹数和喷火所拥有的子弹比较。若不够，则输出 $(x,y)$  。若足够，则喷火子弹减去所需子弹。**注意：此时背包空间也要增加**
* $(x,y)$ 项为物资：因为必然要全部拿走，且题目中说**背包能够装下任意一格的物资**所以我们直接用剩余背包容量减去此处物资的重量，若小于零，即为装不下，需要去丢弃此前的物资，所以我们遍历所拥有的弹药，先把用不到的子弹扔掉，**注意：时间顺序为从早到晚**，如果扔掉仍然不够，那么从投掷物开始把有用的也扔掉。**注意：在扔掉时不能直接用差除以重量，因为有可能不能整除**，接着更新 $(x,y)$ 处物资捡起的最晚时间。

然后去把 $(x,y)$ 更新，进入下一轮。

最后遍历所有的子弹，若此时有子弹在背包里，那就时间从早到晚的顺序输出，直到全部输出。

此题中大多数人都会在**优先丢掉最晚拾取时间最早的弹药**上出现困惑，其实很简单，用另一种话说就是**优先丢掉最终拾取时间最早的弹药**。举个栗子：

背包：

| 编号 | 时间 | 数量 |
| :---: | :---: | :---: |
| $13$ | $10$ | $100$  |
| $15$ | $24$ | $50$ |
| $11$ | $1$ |  $2$ |

则丢掉的顺序为 `11 -> 13 -> 15` 。

**这是我的第一版AC代码**

但孙××提出了一组 hack，即在丢掉无用的子弹时，我有可能无法扔完，因为我只遍历一遍，所以应在遍历无用子弹时也加上一个 while。


```cpp
#include<bits/stdc++.h>
using namespace std;
const double tag[20]={0,0,0,0,0,0,0,0,0,0,5,4,3,2,0.2,0.1,0.5};//重量 
double k;
int T,wz[5005][5005],num[5005][5005],op,x=1,y=1,zhu=0,fu=0,zidan[5005],tim[5005],a[5005][5005],b[5005][5005];
int n,m;
int zd(int f){//处理枪械对应子弹 
    if(f==1||f==2||f==3||f==4) return 14;
    if(f==5||f==6||f==7) return 15;
    return 16;
}
int ch(int f){//处理枪械编号 
    if(f==1||f==2||f==5) return 3;
    if(f==3||f==6||f==7) return 2;
    if(f==0) return 0;
    if(f==4) return 1;
    return 4;
}
int main(){
	memset(wz,0,sizeof(wz));
	memset(num,0,sizeof(num));//初始化 
    cin>>n>>m>>k>>T;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){//题目说的输入很麻烦，实际就是之前的输入方式 
    		int x,y;
	        cin>>wz[i][j];
	        if(wz[i][j]==17){
	        	int u,v;
	        	cin>>u>>v;//敌人特判 
	        	a[i][j]=u;
	        	b[i][j]=v;
	        	num[i][j]=0;
	        	continue;
			}
	        cin>>y;
	        num[i][j]=y;
		}
	        
    }
    for(int j=1;j<=T+1;j++){
        if(wz[x][y]<10){//如果是枪 
            if(ch(zhu)<ch(wz[x][y])){//等级比主武器高，替换 
                zhu=wz[x][y];
                wz[x][y]=0;
            }
            else if(ch(zhu)>ch(wz[x][y])){
                if(ch(fu)<ch(wz[x][y])){//等级比主武器低，但比副武器高，替换 
                    fu=wz[x][y];
                    wz[x][y]=0;//标记 
                }
            }
            num[x][y]=0;
        }
        else if(wz[x][y]>=10&&wz[x][y]<=16){
            k-=tag[wz[x][y]]*num[x][y];//必定要拿走，所以我直接减去重量 
            if(k<0){//此处应该加一个 while ，因为扔没用的子弹时有可能有 2 种
					//因为我 think 一共要遍历三个，而我又 continue 了 2 种 
                int tm=1000000,now=0;
                for(int i=14;i<=16;i++){//一开始只能是用不到的子弹 
                	if(i==zd(zhu)) continue;
                	if(i==zd(fu)) continue;//
                    if(tim[i]<tm&&zidan[i]!=0){
                        tm=tim[i];
                        now=i;
                    }
                }
                for(int i=1;;i++){//不能直接 if ，因为有可能不整除 
                	if(zidan[now]==0) break;
                	zidan[now]--;
                	k+=tag[now];
                	if(k>=0) break;
                	if(zidan[now]==0) break;
				}
                if(k<0){//如果用不到的都丢掉了还不够 
                    while(1){
                        int tm=1000000,now;
                        for(int i=10;i<=16;i++){
                            if(tim[i]<tm&&zidan[i]!=0){//所有都开始丢 
                                tm=tim[i];
                                now=i;
                            }
                        }
                        for(int i=1;;i++){
                        	zidan[now]--;
                        	k+=tag[now];
                        	if(k>=0) break;
                        	if(zidan[now]==0) break;
						}
						if(k>=0) break;
                    }
                }
            }
            tim[wz[x][y]]=j;//时间更新 
            zidan[wz[x][y]]+=num[x][y];//子弹数不能等于，因为之前可能就有 
            wz[x][y]=0;
            num[x][y]=0;
        }
        else if(wz[x][y]==17){
            if(zidan[zd(zhu)]<a[x][y]&&zidan[zd(fu)]<b[x][y]){
                cout<<x<<" "<<y;
                return 0;//如果打不过 
            }
            if(zidan[zd(zhu)]>=a[x][y]){
            	k+=a[x][y]*tag[zd(zhu)];//减去 
            	zidan[zd(zhu)]-=a[x][y];
            	if(zidan[zd(zhu)]==0) tim[zd(zhu)]=0;//背包空间增加 
			}
            else{
            	k+=b[x][y]*tag[zd(fu)];
            	zidan[zd(fu)]-=b[x][y];
            	if(zidan[zd(fu)]==0) tim[zd(fu)]=0;
			}
            wz[x][y]=0;
        }
		if(j==T+1) break;
		cin>>op;
        if(op==1) x--;//路线 
        if(op==2) x++;
        if(op==3) y--;
        if(op==4) y++;
    }
    cout<<zhu<<endl<<fu<<endl;
    for(int i=1;i<=6;i++){
    	int tm=100000000,sum,now;
    	for(int j=10;j<=16;j++){
    		if(tim[j]<tm&&zidan[j]!=0){//若这种子弹背包中有，就看时间的顺序 
                tm=tim[j];
                now=j;
            }
		}
		if(tm==100000000) break;//若都输出了，就 break 
		cout<<now<<" "<<sum<<endl;
		zidan[now]=0;//标记输出过了 
		tim[now]=10000000000;
	}
	return 0;
}
```


**另外，数据实在太水了**

## 二、构造代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const double tag[20]={0,0,0,0,0,0,0,0,0,0,5,4,3,2,0.2,0.1,0.5};//重量 
double k;
int T,wz[5005][5005],num[5005][5005],op,x=1,y=1,zhu=0,fu=0,zidan[5005],tim[5005],a[5005][5005],b[5005][5005];
bool vis[5005];
int n,m;
int zd(int f){//处理枪械对应子弹 
    if(f==1||f==2||f==3||f==4) return 14;
    if(f==5||f==6||f==7) return 15;
    return 16;
}
int ch(int f){//处理枪械编号 
    if(f==1||f==2||f==5) return 3;
    if(f==3||f==6||f==7) return 2;
    if(f==0) return 0;
    if(f==4) return 1;
    return 4;
}
int main(){
	memset(wz,0,sizeof(wz));
	memset(num,0,sizeof(num));//初始化 
    cin>>n>>m>>k>>T;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){//题目说的输入很麻烦，实际就是之前的输入方式 
    		int x,y;
	        cin>>wz[i][j];
	        if(wz[i][j]==17){
	        	int u,v;
	        	cin>>u>>v;//敌人特判 
	        	a[i][j]=u;
	        	b[i][j]=v;
	        	num[i][j]=0;
	        	continue;
			}
	        cin>>y;
	        num[i][j]=y;
		}
	        
    }
    for(int j=1;j<=T+1;j++){
        if(wz[x][y]<10){//如果是枪 
            if(ch(zhu)<ch(wz[x][y])){//等级比主武器高，替换 
                zhu=wz[x][y];
                wz[x][y]=0;
            }
            else if(ch(zhu)>ch(wz[x][y])){
                if(ch(fu)<ch(wz[x][y])){//等级比主武器低，但比副武器高，替换 
                    fu=wz[x][y];
                    wz[x][y]=0;//标记 
                }
            }
            num[x][y]=0;
        }
        else if(wz[x][y]>=10&&wz[x][y]<=16){
            k-=tag[wz[x][y]]*num[x][y];//必定要拿走，所以我直接减去重量 
            if(k<0){
            	while(1){
                	int tm=1000000,sum,now=0;
	                for(int i=14;i<=16;i++){//一开始只能是用不到的子弹 
	                	if(i==zd(zhu)) continue;
	                	if(i==zd(fu)) continue;
	                    if(tim[i]<tm&&zidan[i]!=0){
	                        tm=tim[i];
	                        sum=zidan[i];
	                        now=i;
	                    }
	                }
	                if(tm==1000000) break; 
	                for(int i=1;;i++){//不能直接 if ，因为有可能不整除 
	                	if(zidan[now]==0) break;
	                	zidan[now]--;
	                	k+=tag[now];
	                	if(k>=0) break;
	                	if(zidan[now]==0) break;
					}
					if(k>=0) break;
				}
                if(k<0){//如果用不到的都丢掉了还不够 
                    while(1){
                        int tm=1000000,sum,now;
                        for(int i=10;i<=16;i++){
                            if(tim[i]<tm&&zidan[i]!=0){//所有都开始丢 
                                tm=tim[i];
                                sum=zidan[i];
                                now=i;
                            }
                        }
                        for(int i=1;;i++){
                        	zidan[now]--;
                        	k+=tag[now];
                        	if(k>=0) break;
                        	if(zidan[now]==0) break;
						}
						if(k>=0) break;
                    }
                }
            }
            tim[wz[x][y]]=j;//时间更新 
            zidan[wz[x][y]]+=num[x][y];//子弹数不能等于，因为之前可能就有 
            wz[x][y]=0;
            num[x][y]=0;
        }
        else if(wz[x][y]==17){
            if(zidan[zd(zhu)]<a[x][y]&&zidan[zd(fu)]<b[x][y]){
                cout<<x<<" "<<y;
                return 0;//如果打不过 
            }
            if(zidan[zd(zhu)]>=a[x][y]){
            	k+=a[x][y]*tag[zd(zhu)];//减去 
            	zidan[zd(zhu)]-=a[x][y];
            	if(zidan[zd(zhu)]==0) tim[zd(zhu)]=0;//背包空间增加 
			}
            else{
            	k+=b[x][y]*tag[zd(fu)];
            	zidan[zd(fu)]-=b[x][y];
            	if(zidan[zd(fu)]==0) tim[zd(fu)]=0;
			}
            wz[x][y]=0;
        }
		if(j==T+1) break;
		cin>>op;
        if(op==1) x--;//路线 
        if(op==2) x++;
        if(op==3) y--;
        if(op==4) y++;
    }
    cout<<zhu<<endl<<fu<<endl;
    for(int i=1;i<=6;i++){
    	int tm=100000000,sum,now;
    	for(int j=10;j<=16;j++){
    		if(tim[j]<tm&&zidan[j]!=0){//若这种子弹背包中有，就看时间的顺序 
                tm=tim[j];
                sum=zidan[j];
                now=j;
            }
		}
		if(tm==100000000) break;//若都输出了，就 break 
		cout<<now<<" "<<sum<<endl;
		zidan[now]=0;//标记输出过了
		tim[now]=10000000000;
	}
	return 0;
}
```

---

## 作者：qusia_MC (赞：0)

由于直接讲过于麻烦所以我分成一段一段的给各位 OIer 们讲。

修改于 $2024/9/9:$ 增加了大型坑点和一些的语法错误。

## 输入处理
题目看似有什么向下取整，又是取 $\bmod$ 的，其实就是普通的 $n$ 行 $m$ 列输入。

输入的时候先读入一个元素 $a_{ij}$，表示这一格有什么枪（物品，敌人），然后如果是敌人就再输入两个数（$a_{ij}=17$），如果是其他的就再输入一个数即数量。

在循环 $t$ 次输入一个指令之前一定要判断 $(1,1)$ 有没有东西。我就因为这个第一个样例第一个数总是输出 $5$。

## 对战部分

建议大家单独开一个函数来封装，这样看上去不会太乱。

判断子弹够不够倒是好解决，只需要建立一个数存三种子弹的个数就好了。但如何判喷火是不是嗝了呢？我们可以建一个返回值，如果嗝屁了就返回 $-1$ 直接输出坐标，退出程序。

## 拾取部分

这可能是最重要的部分了。我们先判断这个位置是不是枪，以下分两种情况：

- 是枪

  这个时候我们需要判断这把枪的优先级和主武器的优先级，以下分两种情况：

  - 比主武器高
  
    这个不用说了吧，直接替换。

  - 比主武器低
 
     这样的话，我们需要再次比较这把武和副武器的优先级：
 
    - 比副武器高
 
      大部分人都会想到直接替换，但题目中有这么一句：“主武器优先级必须严格高于副武器优先级”，所以如果优先级（这把武器的）跟主武器一样则不替换副武器。
   
    - 比副武器低
   
       这样的话，直接丢掉就行。
   
- 是物品

   这时候，我们需要判断一下背是否塞的下：

    - 塞的下

       这样的话，我们直接塞里头就完事。

     - 塞不下
 
       这样的话，我们就需要按照题意丢掉一部分物品给这个物品腾地方。
 
       我们需要在编号 $10\sim 16$ 中选一种。

        首先肯定这个物品数量不能是 $0$，那么这样再把它拿出来相当于拿出了空气啥用处也没有。
 
        然后我们一个循环在刚才说的编号里找最佳的，设当前的最优方案为编号为 $k$ 的物品（以下简称 $k$），那么我们需要比较 $k$ 和当前循环到的物品（设为 $i$，简称方式不变）：
 
       - $k$ 是“用不上的子弹”而 $i$ 是“用得上的子弹”：

         这样的话我们要优先选择“用不上的子弹”，故 $k$ 不变。

       -  $k$ 是“用的上的子弹”，而 $i$ 是“用不上的子弹”
      
           这样的话，直接优先丢 $i$。
      

       - 这两个的优先级相同（即要么全是“用得上”或全都是“用不上”）
      
         按照题意就比较时间就行。注意，由于一个时间只能走到一个格子且只能拾取一种物品，故不会出现时间相同的情况。

## 大型坑点

1. 出生点也要捡一下。被卡时长：$10$ 分钟（样例第一个数总输出 $5$）

2. 一定注意主武器优先级严格大于副武器！！！！
 
3. 注意哈，这个敌人不能满血复活，物资也不会刷新，所以走过一个格子要马上清空这个格子里的所有东西（敌人）。被卡时长：$15$ 分钟（下载数据发现子弹最后少很多）。

4. 注意走法。一定是上、下、左、右 对应着 $1\sim 4$。

5. 虽然投掷物屁用没有，但是这东西~~占背包贼大，纯属占坑不拉屎~~是属于“需要的子弹”（靓仔疑惑）所以特判。（被卡一次）。

6. 别忘了子弹这个物品的数量打完敌人要减少。（被卡一次）

OK 啊，最后就是一些细节的处理了。具体看代码。

## 代码

模拟题，不贴代码怎么行呢？？

```
#include <bits/stdc++.h>
using namespace std;
int zd_sl[4];//3 种子弹的数量
struct gun
{
	int yxj; int zd;
}a[17];//一把枪的数据是由他的优先级和使用的子弹。
struct wz
{
	int rl; int sl; int sj; int bh;
//rl 为一个该物品占的背包。
//sl 为这个物品的数量。
// sj 为这个物品的最晚拾取时间。
//bh 为这个东西的编号。
}b[17];
int gun1, gun2, n, m, k, t, maxk, yxsj;
bool ifgun (int a)
{
	if (a >= 0 && a <= 9) return 1;
	return 0;
}//判断是不是枪
bool ifxt (int k1, int k2)
//判断编号 k2 的枪和编号为 k1 的子弹是否匹配
{
	if (k1 <= 13) return 1;//是投掷物，由于只统计子弹，所以这个算是能匹配
	if (k1 == 14 && k2 == 1) return 1;//762毫米子弹
	else if (k1 == 15 && k2 == 2) return 1;//556子弹
	else if (k1 == 16 && k2 == 3) return 1;//12口径
	return 0;
}
void sq(int gunname, int age)//拾取物品
{
	if (ifgun (gunname))
	{
		if (a[gun1].yxj < a[gunname].yxj) gun1 = gunname;//主武器判断是否替换
		else if (a[gun2].yxj < a[gunname].yxj && a[gun1].yxj > a[gunname].yxj) gun2 = gunname;
//判断副武器，注意的是，如果和主武器优先级一样则不替换
	}
	else
	{
		if (maxk - k >= b[gunname].rl * age)
//剩余容量能塞下
		{
			k += b[gunname].rl * age;
			b[gunname].sl += age;
			b[gunname].sj = yxsj;
			if (gunname >= 14)zd_sl[gunname - 13] += age;//直接塞
        }
        else
        {
			int cnt;
			cnt = b[gunname].rl * age - (maxk - k);
    //cnt表示至少要丢掉容量为几的物品才能让新东西放下
			while (cnt > 0)
			{
				int minid = 10;
				for (int i = 11; i <= 16; i ++)
        	    {
        	    	if (b[minid].sl == 0 && b[i].sl != 0) 
					{
						minid = i;
						continue ;//丢掉任何东西肯定比丢掉空气强。
					}
        	    	if (b[i].sl == 0)continue ;
       //是空气，丢了也无意义。
        	    	if (!ifxt(b[minid].bh, a[gun1].zd) && !ifxt(b[minid].bh, a[gun2].zd) && (ifxt(b[i].bh, a[gun1].zd) || ifxt(b[i].bh, a[gun2].zd))) continue;
      //如果 minid 是需要的，i 是不需要的，直接跳过
        	    	if ((ifxt(b[minid].bh, a[gun1].zd) || ifxt(b[minid].bh, a[gun2].zd)) && !ifxt(b[i].bh, a[gun1].zd) && !ifxt(b[i].bh, a[gun2].zd)) minid = i;
      //如果 i 是不需要的，minid 是要的，则直接替换。
        	    	else if (b[i].sj < b[minid].sj) minid = i;
      //否则比较时间。
			    }
			    	int s = min(b[minid].sl, (int)ceil(1.0 * cnt / b[minid].rl));
        //这个防止后期 cnt 和 b[minid].sl 会改变，所以先设好
        //最多丢 b[minid].sl 个，不能无中生有给丢了。
					if (minid >= 14) zd_sl[minid - 13] -= s;
			        k = k - min(b[minid].sl, s) * b[minid].rl;//背包使用的容量减少
                    b[minid].sl -= s;
        //该物品数量减少
                    cnt -= s * b[minid].rl;
        //需要腾出的背包容量减少
			}
            k += b[gunname].rl * age;
        //把新物品全都塞进去
			if (gunname >= 14)zd_sl[gunname - 13] += age;//注意如果是子弹的话别忘了一起减少
			b[gunname].sl += age;
      //数量增加
			b[gunname].sj = yxsj;
       //时间更新为当前游戏时间。
		}
	}
	return ;
}
int zy (int a1, int b1)//遭遇敌人
{
	if (zd_sl[a[gun1].zd] >= a1)//主武器子弹够
	{
		zd_sl[a[gun1].zd] -= a1;//消耗子弹
		b[a[gun1].zd + 13].sl -= a1;//子弹数量减少
		k = k - a1 * b[a[gun1].zd + 13].rl;//背包容量减少
		return 1;
    //胜利并蹲起嘲讽敌人
	}
	else if (zd_sl[a[gun2].zd] >= b1)//副武器也行
	{
		zd_sl[a[gun2].zd] -= b1;//消耗子弹
		b[a[gun2].zd + 13].sl -= b1;//物品数量减少
		k = k - b1 * b[a[gun2].zd + 13].rl;//背包使用容量减少
		return 1;
//成功拉爆，蹲起嘲讽
	}
	return -1;
//敌人：不是哥们，你不捡子弹啊？？直接嘲讽！！
}
int x, y;
void yd (int k)
{
	if (k == 1) x --;
	else if (k == 2) x ++;
	else if (k == 3) y --;
	else if (k == 4) y ++;
	return ;
}//移动
int main()
{
	x = 1, y = 1, yxsj = 1;
//更新跳伞坐标和游戏时间
	//int gun1, gun2, n, m, k, t, maxk, yxsj;
	cin >> n >> m >> maxk >> t;
//输入
	maxk *= 10;
//防止子弹容量数小数，直接乘 10 就 OK。
	zd_sl[0] = 0;//拳头子弹可不是无限哈，不然喷火用拳头跟敌人打枪硬刚还能反杀？？？？不可能的
	a[0].yxj = 0; a[0].zd = 0;
    a[1].yxj = 3; a[1].zd = 1;
    a[2].yxj = 3; a[2].zd = 1;
    a[3].yxj = 2; a[3].zd = 1;
    a[4].yxj = 1; a[4].zd = 1;
    a[5].yxj = 3; a[5].zd = 2;
    a[6].yxj = 2; a[6].zd = 2;
    a[7].yxj = 2; a[7].zd = 2;
    a[8].yxj = 4; a[8].zd = 3;
    a[9].yxj = 4; a[9].zd = 3;
    b[10].bh = 10; b[10].rl = 50;
    b[11].bh = 11; b[11].rl = 40;
    b[12].bh = 12; b[12].rl = 30;
    b[13].bh = 13; b[13].rl = 20;
    b[14].bh = 14; b[14].rl = 2;
    b[15].bh = 15; b[15].rl = 1;
    b[16].bh = 16; b[16].rl = 5;//这里不讲了，初始化
    int aa[101][101], sl[101][101], zd1[101][101], zd2[101][101];
    for (int i = 1; i <= n; i ++)
    {
    	for (int j = 1; j <= m; j ++)
    	{
    		cin >> aa[i][j];
    		if (aa[i][j] == 17) cin >> zd1[i][j] >> zd2[i][j];//输入消灭敌人用的两种子弹
    		else cin >> sl[i][j];//输入个数
		}
	}
		if (aa[x][y] == 17)
			{
				if (zy(zd1[x][y], zd2[x][y]) == -1)
				{
					cout << x << " " << y; return 0;
          //被嘲讽了，，啊啊，我不服，再来一把！！！
				}
			}
			else
			{
				sq(aa[x][y], sl[x][y]);
				//捡起东西
			}
aa[x][y] = 0; sl[x][y] = 0;
    while (t --)
    {
    	yxsj ++;
    	int fx;
    	cin >> fx;
		yd(fx);
		if (aa[x][y] == 17)
		{
			if (zy(zd1[x][y], zd2[x][y]) == -1)
			{
				cout << x << " " << y; return 0;
			}
//被嘲讽了，，啊啊，我不服，再来一把！！！
		}
		else
		{
			sq(aa[x][y], sl[x][y]);
			
		}
		aa[x][y] = 0; sl[x][y] = 0;
//注意无论是敌人还是物品，打（捡）完了就完了，要归零防止遇到两次敌人（敌人 -> 外挂：无限复活）
	}
	cout << gun1 << "\n" << gun2 << "\n";
	for (int i = 10; i <= 16; i ++)
	{
		for (int j = 16; j >= i + 1; j --)
		{
			if (b[j].sj < b[j - 1].sj)
			{
				swap(b[j].bh, b[j - 1].bh);
				swap(b[j].rl, b[j - 1].rl);
				swap(b[j].sj, b[j - 1].sj);
				swap(b[j].sl, b[j - 1].sl);
			}
		}
	}//手敲冒泡（sort也行）
	for (int i = 10; i <= 16; i ++)
	{
		if (b[i].sl != 0)//如果有就输出
		{
			cout << b[i].bh << " " << b[i].sl << "\n";//<< " " << b[i].sj << endl;
		}
	}
	return 0;
}
```

~~字数统计：6521字符，共 299 行~~

---


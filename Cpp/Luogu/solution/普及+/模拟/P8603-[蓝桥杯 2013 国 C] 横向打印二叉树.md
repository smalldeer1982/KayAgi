# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# 题解

## 作者：LaDeX (赞：13)

## 题意

给定一个数组，依次插入进排序二叉树（这玩意不是叫二叉搜索树吗）中，然后 **横向** 打印这棵树。

## 解法

二叉搜索树的部分不再多说，题目里说的很清楚了，主要是输出格式。为了方便，本人把它存进一个字符数组 `mp[1010][1010]`，最后再输出。

样例 $1$ 输出:

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4
```


观察样例 $1$，可发现这就是一个中序遍历，所以我处理时是用递归中序遍历的。

```cpp
void output(LL p, LL space);
```

(虽然叫 `output` 但它不是输出，是处理怎样输出的。)

其中 `p` 是当前结点的编号，`space` 是要输出几个空格。

为了方便，可以将结点的值转换为字符串。

```cpp
string trans(LL x){
	string res;
	while (x > 0)
		res = ((char)(x % 10 + '0')) + res, x /= 10;
	return res;
}
```

（很简单不说了。）

再观察，可发现每一层增加的空格都是由 这个数 和 两边的 `-|` 与 `|-` 组成，要特判一下 **根节点** ，因为根节点开头没有字符。

所以 增加的空格数就是：

```cpp
string num = trans(val);
LL Add = (p == 1 ? 0 : 2) + (LL)num.size() + 1;
```

（三元运算符的意思就是如果这个是编号 $1$ 的根节点，就不加上开头的 $2$ 个字符，否则加上。）

由于是中序遍历，所以结构这样：

```cpp
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
...
void output(LL p, LL space){
	...
	output(ls(p), space + Add);
	....
	....
	output(rs(p), space + Add);
	....
	return ;
}
```

（(~~线段树好习惯~~)`ls(x)` 是 $x$ 的左儿子，`rs(x)` 同理，Add 就是刚才求出的增加空格数。）

在处理完左子树后，就该处理自己结点了。

先在全局定义一个变量 `nowL`，代表现在处理到第几行了。

再是一个局部变量 `ind`，代表 index，现在处理到这一行的第几个了，初始化为 $0$。

开始我们应先输出全部的空格。

```cpp
for (LL i = 1; i <= space; i ++){
	if (mp[nowL][++ ind] != '|')
		mp[nowL][ind] = '.';
}
```

关于这个 `if` 有什么用，暂不讨论，看下面。

再次观察样例 $1$。

可发现除了根节点和叶子结点外，输出的就为 `|-` 加上 这个数（可以用刚才的字符串） 加上 `-|` 。

**根节点就除去开头的 `|-`。**

**叶子结点就除去结尾的 `-|`。**

如下：

```cpp
// 根节点特判
if (p != 1){
	mp[nowL][++ ind] = '|'; mp[nowL][++ ind] = '-';
}

// 输出这个数字
for (LL i = 0; i < (LL)num.size(); i ++)
	mp[nowL][++ ind] = num[i];

// 叶子结点特判
if (tree[ls(p)] != -1 || tree[rs(p)] != -1)
	mp[nowL][++ ind] = '-', mp[nowL][++ ind] = '|';
```

为了输出方便，可在结尾加上一个标识符，代表这一行结束。

```cpp
mp[nowL][++ ind] = '@';
```

然后处理左子树（根据前面的结构代码）。

这样算完成了 $80\%$。

最后是重头戏。

继续观察样例，可发现如果自身与子节点隔了几行，那么要在那几行加上几个 `|`，列的位置和自己这一行的最后那一个 `|` 是一样的。

这样就还要开一个数组 `line[110]` 表示当前结点所在的行数。

```cpp
// 如果有左子树
if (tree[ls(p)] != -1){
	// L 为 左子树的 行位置
	LL L = line[ls(p)], now = line[p];
	for (LL i = L; i >= now; i --)
		mp[i][ind - 1] = '|';
}
// 如果有右子树
if (tree[rs(p)] != -1){
	// R 为 右子树的 行位置
	LL R = line[rs(p)], now = line[p];
	for (LL i = now; i >= R; i --)
		mp[i][ind - 1] = '|';
}	
```

这样在看刚才输出空格时的 `if`，就明白了它是什么意思了吧，它就是 **防止后面的空格把前面的 `|` 覆盖**。

这样整个代码就差不多完成了。

其余部分不讲了。

## Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
#define Fcin\
	ios :: sync_with_stdio(0);\
	cin.tie(0); cout.tie(0)
using namespace std;
const LL N = 110;
LL n, tree[N * 4], nowL = 0, line[N * 4];
char mp[N * 10][N * 10]; 

void insert(LL x, LL p){
	if (tree[p] == -1){
		tree[p] = x;
		return ;
	}
	if (x < tree[p])
		insert(x, ls(p));
	else
		insert(x, rs(p));
	return ;
}

string trans(LL x){
	string res;
	while (x > 0)
		res = ((char)(x % 10 + '0')) + res, x /= 10;
	return res;
}

void output(LL p, LL space){
	if (tree[p] == -1)
		return ;
	LL val = tree[p];
	
	string num = trans(val);
	LL Add = (p == 1 ? 0 : 2) + (LL)num.size() + 1;
	
	output(rs(p), space + Add);
	
	++ nowL;
	line[p] = nowL;
	LL ind = 0;
	
	for (LL i = 1; i <= space; i ++){
		if (mp[nowL][++ ind] != '|')
			mp[nowL][ind] = '.';
	}
	
	if (p != 1){
		mp[nowL][++ ind] = '|'; mp[nowL][++ ind] = '-';
	}
	
	for (LL i = 0; i < (LL)num.size(); i ++)
		mp[nowL][++ ind] = num[i];
		
	if (tree[ls(p)] != -1 || tree[rs(p)] != -1)
		mp[nowL][++ ind] = '-', mp[nowL][++ ind] = '|';
		
	mp[nowL][++ ind] = '@';
	output(ls(p), space + Add);
	
	if (tree[ls(p)] != -1){
		LL L = line[ls(p)], now = line[p];
		for (LL i = L; i >= now; i --)
			mp[i][ind - 1] = '|';
	}
	if (tree[rs(p)] != -1){
		LL R = line[rs(p)], now = line[p];
		for (LL i = now; i >= R; i --)
			mp[i][ind - 1] = '|';
	}	
	
	return ;
}

int main(){
	memset(tree, -1, sizeof(tree));
    Fcin;
    LL x;
    while (cin >> x){
    	++ n;
    	insert(x, 1);
	}
	
	output(1, 0);
	for (LL i = 1; i <= nowL; i ++){
		LL j = 1;
		while (mp[i][j] != '@'){
			cout << mp[i][j];
			++ j;
		}
		cout << "\n";
	}

	return 0;
}

```




---

## 作者：Wing_ (赞：11)

# P8603 横向打印二叉树

## 题意
给定若干个数，将它们依次放进二叉搜索树中，并横向打印该二叉搜索树。

## 分析
可分为两步：

1. 构建二叉搜索树。
1. 横向打印。

### 构建二叉搜索树
按照题意，对于一个数 $x$，比当前节点的值大就插入右子树，比当前节点的值小就插入左子树，递归操作，直到访问到空节点，插入。

代码：

```cpp
void insert(int &u, int x)//插入函数 
{
	if (!u)//访问到空节点，就在这里插入 
	{
		u=++idx;//赋一个新的编号给u 
		tr[u].val=x;//新节点的数值为x 
		return;
	}
	else if (x<tr[u].val) insert(tr[u].l,x);//在左边插入 
	else if (x>tr[u].val) insert(tr[u].r,x);//在右边插入 
}
```

关于为什么用引用：为了方便更新。例如：当调用 `insert(tr[u].l,x)` 时，下一层的 $u$ 就是这一层的左儿子，若左儿子为空（值为 $0$），按照程序下一层的 $u$ 就会被赋一个新的编号，并通过引用将编号赋给这一层的左儿子。

### 横向打印
注意：为了操作方便，我们先用字符数组把答案**存储**下来，最后输出。

样例 $1$ 输出：

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4
```

观察样例可以发现，一行只会输出一个数。一棵树，向左旋转 $90$ 度后，**右边**会转到**上面**（自行想象）。因此，可以采取**右根左**的方式递归打印，一个数**第几个被打印**就在**第几行**。因此，**只需要确定这个数在这一行中的第几个**。

又观察样例发现，发现除根外每个数前都有 `|-` 和若干个 `.`（当然 `.` 中间也可能有 `|`，先暂时忽略，留到下一步再处理），除叶子外每个数后都有 `-|`。

那么每个数前面有多少字符呢？根节点前自然有 $0$ 个。因为是递归打印的，设当前节点前有 $sum$ 个字符，那么它儿子前面首先也会有 $sum$ 个字符，然后是当前节点的位数 $cnt$ 个字符，然后是当前节点后的 `-|` 和儿子前的 `|-`，**注意两个 `|` 是在同一列的，只能算一次**。因此，下一层递归的 $sum$ 应为 $sum+cnt+3$。

因此，`print` 函数有两个参数，当前节点编号 $u$ 和当前节点前的字符数 $sum$。

代码：

```cpp
void print(int u, int sum)//sum表示该节点前的字符数 
{
	if (!u) return;//边界
	int t=tr[u].val, cnt=0;//拆数，cnt为位数
	char num[10];
	while (t) num[++cnt]=t%10+'0', t/=10;
	reverse(num+1,num+cnt+1);
	print(tr[u].r,sum+3+cnt);//递归打印右边
	h++;//h为行数
	tr[u].h=h;
	if (sum)//该节点前有字符 
	{
		for (int i = 1; i <= sum-2; i++) c[h][i]='.';//把第h行（即当前行）1~sum-2位设置成'.'
		c[h][sum-1]='|', c[h][sum]='-';
	}
	tr[u].z=sum+1;//该值的第一个字符的列数为sum+1 
	for (int i = 1; i <= cnt; i++) c[h][sum+i]=num[i];//把sum后的cnt位设置成数
	if (tr[u].l||tr[u].r) c[h][sum+cnt+1]='-', c[h][sum+cnt+2]='|';//如果不是叶子，把后两位设置成"-|" 
	print(tr[u].l,sum+3+cnt);//递归打印左边
}
```

然后我们会发现并没有做完，如果此时就打印字符数组会发现是这样的（以样例 $3$ 为例）：

```
.......|-20
..|-10-|
.......|-8-|
...........|-7
5-|
..|-4
```

显然是错误的，正确的应为：

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4
```

可以发现第三行和第四行少了一个 `|`，原因是我们只打印了数字前后的 `|` 和 `-`，而把连接父亲和儿子的 `|` 误设为了 `.`。

又双叒叕观察样例发现，在父节点后面的 `-` 与子节点前面的 `-` 之间有一列 `|` 连接。它们的列数相等，设子节点第一个字符的列数为 $z$，则 `|` 的列数为 $z-2$；设父节点的行数为 $uh$，左、右子节点的行数分别为 $lh$、$rh$，左子节点与父亲之间的 `|` 的行数为 $uh\sim lh$，右子节点为父亲之间的 `|` 的行数为 $rh\sim uh$。递归连接起每一对父子即可。

具体见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=110;
struct Node
{
	int val/*数值*/, h, z, l/*左儿子*/, r/*右儿子*/;//h，z表示该数的第一个字符在第h行第z列输出 
}tr[N];//结构体存树 
int idx/*编号*/, root/*根*/, h/*行数*/;
char c[110][10010];//字符数组 

void insert(int &u, int x)//插入函数 
{
	if (!u)//访问到空节点，就在这里插入 
	{
		u=++idx;//赋一个新的编号给u 
		tr[u].val=x;//新节点的数值为x 
		return;
	}
	else if (x<tr[u].val) insert(tr[u].l,x);//在左边插入 
	else if (x>tr[u].val) insert(tr[u].r,x);//在右边插入 
}

void print(int u, int sum)//sum表示该节点前的字符数 
{
	if (!u) return;//边界
	int t=tr[u].val, cnt=0;//拆数，cnt为位数
	char num[10];
	while (t) num[++cnt]=t%10+'0', t/=10;
	reverse(num+1,num+cnt+1);
	print(tr[u].r,sum+3+cnt);//递归打印右边
	h++;//h为行数
	tr[u].h=h;
	if (sum)//该节点前有字符 
	{
		for (int i = 1; i <= sum-2; i++) c[h][i]='.';//把第h行（即当前行）1~sum-2位设置成'.'
		c[h][sum-1]='|', c[h][sum]='-';
	}
	tr[u].z=sum+1;//该值的第一个字符的列数为sum+1 
	for (int i = 1; i <= cnt; i++) c[h][sum+i]=num[i];//把sum后的cnt位设置成数
	if (tr[u].l||tr[u].r) c[h][sum+cnt+1]='-', c[h][sum+cnt+2]='|';//如果不是叶子，把后两位设置成"-|" 
	print(tr[u].l,sum+3+cnt);//递归打印左边
}

void work(int u)
{
	if (!u) return;//边界 
	int uh=tr[u].h;
	if (tr[u].r)//连接右儿子 
	{
		int rh=tr[tr[u].r].h, rz=tr[tr[u].r].z;
		for (int i = rh; i <= uh; i++) c[i][rz-2]='|';//循环修改
	}
	if (tr[u].l)//连接左儿子 
	{
		int lh=tr[tr[u].l].h, lz=tr[tr[u].l].z;
		for (int i = uh; i <= lh; i++) c[i][lz-2]='|';//循环修改
	}
	work(tr[u].l), work(tr[u].r);//递归 
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int x;
	while (cin >> x) insert(root,x);//插入x 
	print(root,0);//从根开始打印，根前有0个字符 
	work(root);//从根开始连接 
	for (int i = 1; i <= h; i++)//输出 
	{
		for (int j = 1; c[i][j]; j++) cout << c[i][j];
		cout << "\n";
	}
	return 0;
}
```

有不完善的地方请指出，谢谢！

---

## 作者：ChampionCyan (赞：6)

## 前言

[闲话](https://www.luogu.com.cn/paste/p11xf7jb)。

[更加清晰移动的版本](https://www.luogu.com.cn/paste/zstx44wn)， 必看！

## 做法

我们要做的有以下几点：

- 初始化与输入数据。
- 插入数据。
- 处理数据。
- 输出答案。

开始之前，请先看一下一开始的全局变量和宏定义，以免影响理解：

```cpp
#include <bits/stdc++.h>
#define int long long
#define eof '$'
#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)
using namespace std;
const int MAXN = 110;
int node[MAXN << 2], tot = 0, line[MAXN << 2];
// * MAXN << 2 == MAXN * 4

char ans[(MAXN << 1) + (MAXN << 3)][(MAXN << 1) + (MAXN << 3)];
// * (MAXN << 1) + (MAXN << 3) == MAXN * 10
```

### 第一步，初始化与输入数据

很简单了吧，注意**输入数据没有** $n$。

```cpp
signed main() {
    memset(node, -1, sizeof(node));
    int x;
    while (~scanf("%d", &x))
        insert(x, 1);
    ......
    return 0;
}
```

### 第二步，插入数据

我看很多大佬是递归插入的，但是这样费时费空间，不如循环好。

```cpp
// insert function to insert a node.
inline void insert(int x, int p) {
    // * while loop is better than recurcion.
    while (node[p] != -1) {
        if (x < node[p])
            p = lc(p);
        else
            p = rc(p);
    }
    node[p] = x;
}
```

### 第三步，处理数据

这一步是最复杂的。我们一步一步来。

首先这个函数应该有两个参数，分别是：

- 要处理哪个节点。
- 前面 `.` 和 `|` 的总数。

然后我们知道，输出的顺序是**右根左**（**注意不是左根右**）的。

我们先处理左子节点，处理完后我们处理自己本身，然后处理右子节点。因为左右子节点都可以通过递归实现，所以难点在于处理自己。

处理自己，分为以下几个步骤：

- 输出 `.` 和 `|`。
- 输出 `|-`，注意根节点不用输出 `|-`。
- 输出数字本身。
- 输出 `-|`，注意叶节点不用输出 `-|`。
- 处理左子节点到自己这一段的 `|`。
- 处理自己到右子节点这一段的 `|`。



给出处理数据函数的代码：

观前提示：str 函数是用于将一个数字转化成字符串用的（python 党应该很熟吧，别误解，我只是学过一点 python，并不是 python 党）。

```cpp
// work function to print the answer into "char ans[][]"
inline void work(int p, int len) {
    if (node[p] == -1)
		return;
	int val = node[p];
	string num = str(val);
	int front = (p == 1 ? 0 : 2) + (int)num.size() + 1;
	// recurcion to solve the right child node.
	work(rc(p), len + front);
	++tot;
	line[p] = tot;
	int idx = 0;
	// * draw character '.' in "ans[][]".
	for (int i = 1; i <= len; i++)
		if (ans[tot][++idx] != '|')
			ans[tot][idx] = '.';
    // * draw character '|' in "ans[][]".
	if (p != 1)
		ans[tot][++idx] = '|', ans[tot][++idx] = '-';
	for (int i = 0; i < (int)num.size(); i++)
		ans[tot][++idx] = num[i];
	if (node[lc(p)] != -1 || node[rc(p)] != -1)
		ans[tot][++idx] = '-', ans[tot][++idx] = '|';
	ans[tot][++idx] = eof;
    // recurcion to solve the left child node.
	work(lc(p), len + front);
	if (node[lc(p)] != -1) {
		int L = line[lc(p)], now = line[p];
		for (int i = L; i >= now; i--)
			ans[i][idx - 1] = '|';
	}
	if (node[rc(p)] != -1) {
		int R = line[rc(p)], now = line[p];
		for (int i = now; i >= R; i--)
			ans[i][idx - 1] = '|';
	}
}
```

### 第四步，输出数据

最简单的一步，不过多解释。

```cpp
signed main() {
    ......
    for (int i = 1; i <= tot; i++) {
        int j = 1;
        while (ans[i][j] != eof) {
            putchar(ans[i][j]);
            j++;
        }
        puts("");
    }
    return 0;
}
```

## Code

最后，献上只有 $87$ 行的代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define eof '$'
#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)
using namespace std;
const int MAXN = 110;
int node[MAXN << 2], tot = 0, line[MAXN << 2];
// * MAXN << 2 == MAXN * 4

char ans[(MAXN << 1) + (MAXN << 3)][(MAXN << 1) + (MAXN << 3)];
// * (MAXN << 1) + (MAXN << 3) == MAXN * 10

// insert function to insert a node.
inline void insert(int x, int p) {
    // * while loop is better than recurcion.
    while (node[p] != -1) {
        if (x < node[p])
            p = lc(p);
        else
            p = rc(p);
    }
    node[p] = x;
}

// str function to turn an "int" to a "string".
inline string str(int x) {
    string s;
    while (x > 0)
        s = ((char)(x % 10 + '0')) + s, x /= 10;
    return s;
}

// work function to print the answer into "char ans[][]"
inline void work(int p, int len) {
    if (node[p] == -1)
		return;
	int val = node[p];
	string num = str(val);
	int front = (p == 1 ? 0 : 2) + (int)num.size() + 1;
	// recurcion to solve the right child node.
	work(rc(p), len + front);
	++tot;
	line[p] = tot;
	int idx = 0;
	// * draw character '.' in "ans[][]".
	for (int i = 1; i <= len; i++)
		if (ans[tot][++idx] != '|')
			ans[tot][idx] = '.';
    // * draw character '|' in "ans[][]".
	if (p != 1)
		ans[tot][++idx] = '|', ans[tot][++idx] = '-';
	for (int i = 0; i < (int)num.size(); i++)
		ans[tot][++idx] = num[i];
	if (node[lc(p)] != -1 || node[rc(p)] != -1)
		ans[tot][++idx] = '-', ans[tot][++idx] = '|';
	ans[tot][++idx] = eof;
    // recurcion to solve the left child node.
	work(lc(p), len + front);
	if (node[lc(p)] != -1) {
		int L = line[lc(p)], now = line[p];
		for (int i = L; i >= now; i--)
			ans[i][idx - 1] = '|';
	}
	if (node[rc(p)] != -1) {
		int R = line[rc(p)], now = line[p];
		for (int i = now; i >= R; i--)
			ans[i][idx - 1] = '|';
	}
}

signed main() {
    memset(node, -1, sizeof(node));
    int x;
    while (~scanf("%d", &x))
        insert(x, 1);
    work(1, 0);
    for (int i = 1; i <= tot; i++) {
        int j = 1;
        while (ans[i][j] != eof) {
            putchar(ans[i][j]);
            j++;
        }
        puts("");
    }
    return 0;
}
```

---

## 作者：jsisonx (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8603)

# 题目分析
这是一道比较综合的题目，大体可以分为两步：建树和横向输出这棵树。

### 建树
这是相对简单的一步，基本思想就是每次递归地查找当前节点应该放在什么位置。注意，由于 $n$ 的最大值可以到 $100$，所以在建树的时候无法使用左儿子 $2x$，右儿子 $2x+1$ 的编号方式，所以对于每个节点都要设两个变量分别指向左儿子和右儿子，编号就可以直接用所有自然数表示了。依照题意，每次加点时从根节点开始遍历这棵树，如果当前值大于根节点，则递归遍历右子树，否则遍历左子树。当发现当前节点在目标方向上没有子节点，那么把当前节点加到这个地方。

### 横向输出
这一步相对复杂。通过观察样例的输出，我们发现每一行有且只有一个点，所以输出总行数为 $n$ 行。再深入研究可以发现，儿子节点与父节点隔了多少行取决于两个节点之间夹着多少节点。比如一个节点与它的右儿子节点隔的行数取决于右儿子的左子树的节点数，因为左子树中每一个节点都要占一行且夹在父节点与右儿子节点之间。因此，我们可以采用动态规划的方式来求一个节点左右子树的节点数。具体地，设一个节点 $i$ 左子树节点数为 $suml_i$，右子树节点数为 $sumr_i$，则如果该节点有左儿子，则

$$suml_i=suml_j+sumr_j+1$$
其中 $j$ 是 $i$ 的左儿子，也就是以该节点左儿子为根的子树的节点数加上左儿子自己。右子树是一样的。

这样的话，我们就可以预处理出每个节点在哪一行，具体地，设 $line_i$ 表示第 $i$ 个节点所在行，则若 $j$ 是 $i$ 的左儿子，则
$$line_j=line_i+sunr_j+1$$
否则
$$line_j=line_i-suml_j-1$$
这样，每个节点所在行就都知道了，然后把数字转字符放到需要输出的字符矩阵中，然后再用横竖线连边输出即可，这些应该比较简单。注意每一行输出最后一个非句点的字符后就要停止输出。

# 代码
```cpp
#include<bits/stdc++.h>
#define N 2001
using namespace std;
struct tree{
	int fa;
	int l,r;
	int num;
	int line;
	int id;
	int lsum,rsum;
}t[N];
int s=1;
int judgeL(int x){
	if(t[x].l==0){
		return 0;
	}
	return 1;
}
int judgeR(int x){
	if(t[x].r==0){
		return 0;
	}
	return 1;
}
void add(int num,int x){
	if(num>t[x].num){
		if(judgeR(x)){
			add(num,t[x].r);
		}
		else{
			t[x].r=s;
			t[s].num=num;
			t[s].id=s;
			t[s].fa=x;
			t[s].rsum=t[s].lsum=0;
			s++;
		}
	}
	else{
		if(judgeL(x)){
			add(num,t[x].l);
		}
		else{
			t[x].l=s;
			t[s].num=num;
			t[s].id=s;
			t[s].fa=x;
			t[s].rsum=t[s].lsum=0;
			s++;
		}
	}
	t[x].rsum=t[t[x].r].rsum+t[t[x].r].lsum+judgeR(x);
	t[x].lsum=t[t[x].l].rsum+t[t[x].l].lsum+judgeL(x);
	return;
}
int n=1,a[N];
char c[N][N];
void init(int n){
	for(int i=1;i<=n;i++){
		for(int j=1;j<N;j++){
			c[i][j]='.';
		}
	}
	return;
}
void mark(int x,int fx){
	if(fx==-1){
		t[x].line=t[x].rsum+1;
	}
	else if(fx==1){
		t[x].line=t[t[x].fa].line-t[x].lsum-1;
	}
	else if(fx==2){
		t[x].line=t[t[x].fa].line+t[x].rsum+1;
	}
	if(judgeL(x)){
		mark(t[x].l,2);
	}
	if(judgeR(x)){
		mark(t[x].r,1);
	}
	return;
}
void addIn(int x,int l){
	stack<int>s;
	while(!s.empty()){
		s.pop();
	}
	int x2=t[x].num;
	if(x2<0){
		c[t[x].line][l]='-';
		l++;
		x2=-x2;
	}
	while(x2){
		s.push(x2%10);
		x2/=10;
	}
	while(!s.empty()){
		c[t[x].line][l]=s.top()+'0';
		s.pop();
		l++;
		x2/=10;
	}
	if(t[x].l==t[x].r&&t[x].l==0){
		return;
	}
	c[t[x].line][l]='-';
	c[t[x].line][l+1]='|';
	l++;
	int l2=l;
	if(t[x].l!=0){
		int left=t[x].l;
		int newLine=t[left].line;
		for(int i=t[x].line+1;i<=newLine;i++){
			c[i][l]='|';
		}
		l++;
		c[newLine][l]='-';
		l++;
		addIn(t[x].l,l);
	}
	l=l2;
	if(t[x].r!=0){
		int right=t[x].r;
		int newLine=t[right].line;
		for(int i=t[x].line-1;i>=newLine;i--){
			c[i][l]='|';
		}
		l++;
		c[newLine][l]='-';
		l++;
		addIn(t[x].r,l);
	}
	return;
}
void out(int n){
	for(int i=1;i<=n;i++){
		int endL;
		for(int j=N-1;j>=1;j--){
			if(c[i][j]!='.'){
				endL=j;
				break;
			}
		}
		for(int j=1;j<=endL;j++){
			cout<<c[i][j];
		}
		cout<<endl;
	}
	return;
}
int main(){
	while(cin>>a[n]){
		n++;
	}
	n--;
	t[1].num=a[1];
	t[1].fa=0;
	t[1].id=1;
	t[1].rsum=t[1].lsum=0;
	s++;
	for(int i=2;i<=n;i++){
		add(a[i],1);
	}
	init(n);
	mark(1,-1);
	addIn(1,1);
	out(n);
	return 0;
} 
```

---

## 作者：leiaxiwo (赞：1)

# 题解：P8603 [蓝桥杯 2013 国 C] 横向打印二叉树
## 模拟+树形数据结构
### [传送门](https://www.luogu.com.cn/problem/P8603)
### 题意分析
这是一道小模拟无疑，疑惑的是 [P7073 [CSP-J2020] 表达式](https://www.luogu.com.cn/problem/P7073) 这道题都评绿，此题不知为何评黄。

题目要求我们维护一棵二叉树（注意不是二叉平衡树），所以我们可以考虑用结构体封装每一行的情况，并且按序输出，完成此题。

观前提醒：本题码量不大但是极其难调，建议做好心理准备。
### 代码部分
#### 结构体
```cpp
struct node{
	int l,r,l_s,r_s;//左儿子；右儿子；左孙子；右孙子  
	int val,id,ak;//点权；点编号（之后用来重构二叉树）；这一行的字符指针，用数组模拟 
	char a[10];//这一行的字符 
}tree[50005];//按说开110即可，但是笔者喜欢开大一点 
```
这里展示了笔者重构时需要的信息，当然此题做法应该不需要这么繁琐，只是笔者暂时想不出更好的办法了。
#### 插入函数
```cpp
void insert(int x,int y){//insret，即为插入二叉树节点，这里也兼顾了构造，x表示根节点
	if(tree[y].val>tree[x].val){//比较插入权值和根的值大小，比他大则放右边，小放左边 
		tree[x].r_s++;//维护他们的子树大小 
		if(tree[x].r!=-1){//初始化操作在主函数完成，tree[x].r==-1则表示它没有了儿子 
			insert(tree[x].r,y);//递归插入 
		}
		else{
			tree[x].r=y;//否则插入 
		}
	}
	else{//反之亦然 
		tree[x].l_s++;
		if(tree[x].l!=-1){
			insert(tree[x].l,y);
		}
		else{
			tree[x].l=y;
		}
	}
}
```

#### 编号函数
```cpp
void id_set(int x,int y){//id表示这个应该在第几行，因为图的构造为右中左的中序遍历，为此要用改结点的右子树的结点个数进行计算 
	tree[y].id=x+tree[y].r_s+1;//标记数量是根节点的id加上右子树的结点个数+1，+1是为了不用map[0] 
	if(tree[y].r!=-1){//如果这个结点有右子树，递归进入下一层进行计算 
		id_set(x,tree[y].r);
	}
	if(tree[y].l!=-1){//反之亦然 
		id_set(tree[y].id,tree[y].l);
	}
}
```
#### 构造函数
```cpp
void map_set(int x,int y){//图的构造 ,y定位字符串结尾'\0'的位置 
	for(int i=0;i<tree[x].ak;i++){//进行结点的值的填充 
		maps[tree[x].id][y+i]=tree[x].a[tree[x].ak-i-1];
	}
	y+=tree[x].ak;//字符串的结束下标要在值的后面，所以要加上字符数组a的长度 
	if(tree[x].l!=-1||tree[x].r!=-1){ //如果这个结点有左子树或者右子树 
		maps[tree[x].id][y++]='-';//就在应该填充'\0'的位置填充'-'，并将y的数值+1 
		int max,min;
		max=min=tree[x].id;
		if(tree[x].l!=-1){
		    max=tree[tree[x].l].id;
			maps[tree[tree[x].l].id][y+1]='-';
			map_set(tree[x].l,y+2);	
		}
		if(tree[x].r!=-1){
			min=tree[tree[x].r].id;
			maps[tree[tree[x].r].id][y+1]='-';
			map_set(tree[x].r,y+2);
		}
		for(int i=min;i<=max;i++){
			maps[i][y]='|';
		}
		maps[tree[x].id][y+1]='\0';
	}
	else{
		maps[tree[x].id][y]='\0';
		return ;
	}
}
```


### 样例代码
```cpp
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,l_s,r_s;//左儿子；右儿子；左子树结点个数；右子树结点个数
	int val,id,ak;//点权；点编号（之后用来重构二叉树）；这一行的字符指针，用数组模拟 
	char a[10];//这一行的字符 
}tree[50005];//按说开110即可，但是笔者喜欢开大一点 
char maps[5005][5005];
void insert(int x,int y){//insret，即为插入二叉树节点，这里也兼顾了构造，x表示根节点
	if(tree[y].val>tree[x].val){//比较插入权值和根的值大小，比他大则放右边，小放左边 
		tree[x].r_s++;//维护他们的子树大小 
		if(tree[x].r!=-1){//初始化操作在主函数完成，tree[x].r==-1则表示它没有了儿子 
			insert(tree[x].r,y);//递归插入 
		}
		else{
			tree[x].r=y;//否则插入 
		}
	}
	else{//反之亦然 
		tree[x].l_s++;
		if(tree[x].l!=-1){
			insert(tree[x].l,y);
		}
		else{
			tree[x].l=y;
		}
	}
}
void id_set(int x,int y){//id表示这个应该在第几行，因为图的构造为右中左的中序遍历，为此要用改结点的右子树的结点个数进行计算 
	tree[y].id=x+tree[y].r_s+1;//标记数量是根节点的id加上右子树的结点个数+1，+1是为了不用map[0] 
	if(tree[y].r!=-1){//如果这个结点有右子树，递归进入下一层进行计算 
		id_set(x,tree[y].r);
	}
	if(tree[y].l!=-1){//反之亦然 
		id_set(tree[y].id,tree[y].l);
	}
}
void map_set(int x,int y){//图的构造 ,y定位字符串结尾'\0'的位置 
	for(int i=0;i<tree[x].ak;i++){//进行结点的值的填充 
		maps[tree[x].id][y+i]=tree[x].a[tree[x].ak-i-1];
	}
	y+=tree[x].ak;//字符串的结束下标要在值的后面，所以要加上字符数组a的长度 
	if(tree[x].l!=-1||tree[x].r!=-1){ //如果这个结点有左子树或者右子树 
		maps[tree[x].id][y++]='-';//就在应该填充'\0'的位置填充'-'，并将y的数值+1 
		int max,min;
		max=min=tree[x].id;
		if(tree[x].l!=-1){
		    max=tree[tree[x].l].id;
			maps[tree[tree[x].l].id][y+1]='-';
			map_set(tree[x].l,y+2);	
		}
		if(tree[x].r!=-1){
			min=tree[tree[x].r].id;
			maps[tree[tree[x].r].id][y+1]='-';
			map_set(tree[x].r,y+2);
		}
		for(int i=min;i<=max;i++){
			maps[i][y]='|';
		}
		maps[tree[x].id][y+1]='\0';
	}
	else{
		maps[tree[x].id][y]='\0';
		return ;
	}
}
int tot,sum,A[5005];
string s;
int main(){
	getline(cin,s);
	istringstream ss(s);//使用 istringstream 切割字符串 
	while(ss>>sum){
		A[tot++]=sum;
	}
	for(int i=0;i<tot;i++){
		sum=A[i];
		tree[i].l=tree[i].r=-1;
		tree[i].l_s=tree[i].r_s=0;
		tree[i].ak=0;
		tree[i].val=sum;
		while(sum){
			tree[i].a[tree[i].ak++]=sum%10+'0';
			sum/=10;
		}
	}
	for(int i=1;i<tot;i++){
		insert(0,i);
	}
	id_set(0,0);
	for(int i=1;i<=tot;i++){
		for(int j=0;j<710;j++){//这是图的上界 
			maps[i][j]='.';
		}
	}
	map_set(0,0);
	for(int i=1;i<=tot;i++){
		printf("%s\n",maps[i]);
	}
	return 0;//完结撒花 
}
```

---


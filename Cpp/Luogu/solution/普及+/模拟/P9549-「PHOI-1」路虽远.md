# 「PHOI-1」路虽远

## 题目背景

$update$ $on$ $2023.8.17$ $12:25$ 
**数据修复&加强完成，可重新提交代码。**

路虽远，行则将至。

![](https://cdn.luogu.com.cn/upload/image_hosting/ugqt01zi.png)

## 题目描述

**请注意本题特殊的时限。**

小 X 来到了 Z 市，Z 市有 $n$ 个交通路口，$m$ 条马路。其中第 $i$ 条马路连接着第 $u_i$ 个交通路口和第 $v_i$ 个交通路口（可以从 $u_i$ 到 $v_i$，也可以从 $v_i$ 到 $u_i$），小 X 通过这条马路时要花费 $p_i$ 秒，若有限速，则通过这条马路时要花费 $q_i$ 秒。

现在，市长要在 $k$ 条马路上添加限速，然而，要在哪 $k$ 条马路上限速是小 X 自己规定的。

同时，市长会在每个交通路口处添加红绿灯。第 $i$ 个交通路口的红绿灯先亮绿灯 $x_i$ 秒，再亮黄灯 $y_i$ 秒，之后亮红灯 $z_i$ 秒，然后再亮绿灯，黄灯，红灯，如此往复。如果一个交通路口的红绿灯不是红灯，小 X 可以从这个交通路口出发，到达另一个交通路口。若到达交通路口时，灯的颜色瞬间变了，则按照变了之后的灯计算，灯的黄灯和红灯的持续时间可能为 $0$。并且，小 X 最多只能闯 $g$ 次黄灯。

过了一会儿，市长突然发现，所有的红绿灯在某一刻都变成了绿灯。与此同时，小 X 从第 $1$ 个路口出发，前往第 $n$ 个路口。他想问你，他至少要花多少时间才能到达第 $n$ 个路口？

因为路虽远，行则将至，数据保证一定可以到达，即 $1\sim n$ 一定连通。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n,m$ | $y_i,z_i$ | $k,g$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $0$ | $1 \le n,m \le 5$ | 无特殊限制 | 无特殊限制 | $20$ |
| $1$ | 无特殊限制 | $y_i=z_i=0$ | $k=g=0$ | $5$ |
| $2$ | 无特殊限制 | $y_i=0,0 \le z_i \le 10^9$ | 无特殊限制 | $25$ | 
| $3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $50$ |

对于 $100\%$ 的数据，保证 $1 \le n,m \le 100$，$0 \le k,g \le m$，$1 \le x_i \le 10^9$，$0 \le y_i,z_i \le 10^9$，$1 \le u,v \le n$，$0 \leq p_i \leq q_i \leq 10^9$。
### 样例解释 #1：


$1 \to 3 \to 4 \to 5$ 并在编号为 $1,2,4,6,7,8$ 的马路上添加限速，到 $3$ 时闯黄灯，到 $4$ 时绿灯直接过，这时候，$1 \to 3$ 花费 $1$ 秒，$3 \to 4$ 花费 $0$ 秒，$4 \to 5$ 花费 $3$ 秒，共花费 $4$ 秒。

### 样例解释 #2：

$1 \to 2 \to 5 \to 6 \to 9$ 并在编号为 $2,3,4,5,6,7,8,9,10,11,13,14,15,16$ 的马路上添加限速，到 $2,5$ 时闯黄灯，到 $4$ 时绿灯直接过，到 $6$ 时等 $1$ 秒红灯，这时候，$1 \to 2$ 花费 $1$ 秒，$2 \to 5$ 花费 $4$ 秒，$5 \to 6$ 花费 $9$ 秒，$6 \to 9$ 花费 $3$ 秒，加上等红灯的 $1$ 秒共花费 $18$ 秒。

## 样例 #1

### 输入

```
5 8 6 1
1 2 2
1 0 3
1 1 4
3 1 0
5 1 4
1 2 1 4
2 4 2 4
3 4 0 2
1 5 7 8
1 3 1 2
5 4 2 3
2 5 2 4
1 4 4 7```

### 输出

```
4```

## 样例 #2

### 输入

```
9 16 14 2
1 7 2
1 5 3
1 6 4
3 5 0
1 6 5
1 0 4
1 7 5
3 8 8
3 8 6
1 2 1 4
8 5 2 6
2 4 2 4
8 6 3 5
3 4 0 2
6 7 1 4
1 5 7 8
5 9 16 21
1 3 2 2
7 6 2 3
5 4 2 3
6 9 3 5
2 5 2 4
8 9 4 7
1 4 4 7
6 5 6 9```

### 输出

```
18```

# 题解

## 作者：FiraCode (赞：6)

## 路虽远题解

### 题意：

给你一个 $n$ 个点 $m$ 条边的图，从一个节点出发到另一个节点时可能要等红绿灯，可以闯黄灯 $g$ 次，要在 $k$ 条边上添加限速，限速会使小 $X$ 经过这条边的时间变长，求小 $X$ 从第一个节点到第 $n$ 个节点的最短时间。

### Subtask0

可以直接爆搜，让后每次就记录当前时间，当前节点，以及还剩多少条边需要限速，以及还可以闯多少次黄灯，因为可以通过每个灯的时间算出来当前是哪个灯，然后判断要不要闯黄灯，以及需要等多长时间。

得分：$20pts$。

### Subtask1

因为只有绿灯，而且无法闯红灯，没有限速，那么就直接对原图跑最短路就可以了。

加上前面的 Subtask 可以拿 $25$ 分。

### Subtask2

没有黄灯，也就是无法闯黄灯。

那么考虑如何做限速。

因为相当于修改 $k$ 条边的边权，那么可以考虑分层图。

那么可以考虑都限速，然后建 $m - k$ 层，每层由不限速的边连起来，这样到达最后一层中相当于第一层的的 $n$ 个点（后面统称为**终点**），就相当于一定有 $k$ 条边是限速的（因为最多走 $m - k$ 条不限速的边）。

然后再把每一层的终点向最后一层的终点连一条边权为 $0$ 的边连起来，这样能保证走不足 $m - k$ 条不限速的边可以直接到达。

最后就输出到达终点的最短距离即可，因为 spfa 会被卡，所以要用堆优化的 dijkstra。

加上前面的 Subtask 可以拿 $50$。

### Subtask3

其实可以使用三维的 dijkstra，每一维分别表示当前是那个点，当前还剩多少条边可以不限速，当前还可以闯多少黄灯。

设当前时刻为 $t$。

 *	1.若还可以不限速：
 > 则有两种情况：
 > * 1.不闯黄灯，则判断当前时刻当前路口是否为绿灯，若是则可以直接冲过去，权值为不限速的权值，否则就加上等红绿灯的时间，也就是灯亮的总时间减去当前时刻 $t$，也就是总时间减去已经过去的时间。
 > * 2.闯黄灯，那么当前是绿灯或者黄灯时间，那么可以直接冲过去，否则再加上等红绿灯的时间即可。
 *  2.若不可以不限速：
 > 同上，只不过把通过的时间改为限速的权值即可。

按照权值跑 dijkstra 即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 110, M = N << 1;
const int INF = 1ll << 60;

int n, m, k, g;
int a[N], b[N], c[N], dist[N][N][N];
int h[N], e[M], ne[M], p[M], q[M], idx;

struct Node {
    int x, y, z, w;
    const bool operator<(const Node &x) const{
        return w > x.w;
    }
};
priority_queue<Node> q1;

void add(int a, int b, int n, int m) {
    e[idx] = b, p[idx] = n, q[idx] = m, ne[idx] = h[a], h[a] = idx++;
}

void update(int x, int y, int z, int w) {
    if (dist[x][y][z] > w) {
        dist[x][y][z] = w;
        q1.push({x, y, z, w});
    }
}

void dijkstra() {
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= k; ++j)
            for (int k = 0; k <= g; ++k)
                dist[i][j][k] = INF;

    dist[1][0][0] = 0;
    q1.push({1, 0, 0, 0});

    while (!q1.empty()) {
        auto u = q1.top();
        q1.pop();
        int x = u.x, y = u.y, z = u.z, w = u.w, now = w % (a[x] + b[x] + c[x]);
        if (dist[x][y][z] < w) continue;
        for (int i = h[x]; ~i; i = ne[i]) {
            int v = e[i];
            if (y < k) {
                if (now < a[x]) update(v, y + 1, z, w + p[i]);
                else update(v, y + 1, z, w + a[x] + b[x] + c[x] - now + p[i]);
                if (z < g) {
                    if (now < (a[x] + b[x])) update(v, y + 1, z + 1, w + p[i]);
                    else update(v, y + 1, z + 1, w + a[x] + b[x] + c[x] - now + p[i]);
                }
            }
            if (now < a[x]) update(v, y, z, w + q[i]);
            else update(v, y, z, w + a[x] + b[x] + c[x] - now + q[i]);
            if (z < g) {
                if (now < (a[x] + b[x])) update(v, y, z + 1, w + q[i]);
                else update(v, y, z + 1, w + a[x] + b[x] + c[x] - now + q[i]);
            }
        }
    }
}

signed main() {
    memset(h, -1, sizeof(h));
    scanf("%lld%lld%lld%lld", &n, &m, &k, &g);
    k = m - k;

    for (int i = 1; i <= n; ++i) scanf("%lld%lld%lld", &a[i], &b[i], &c[i]);

    for (int i = 1; i <= m; ++i) {
        int u, v, p, q;
        scanf("%lld%lld%lld%lld", &u, &v, &p, &q);
        add(u, v, p, q);
        add(v, u, p, q);
    }

    dijkstra();
    int ans = INF;

    for (int i = 0; i <= k; ++i)
        for (int j = 0; j <= g; ++j)
            ans = min(ans, dist[n][i][j]);

    if (ans == INF) puts("-1");
    else printf("%lld\n", ans);

    return 0;
}
```

---

## 作者：Night_sea_64 (赞：5)

~~这题明明是个最短路练手题，为什么会评蓝啊（~~

是个分层图的 dijkstra。我们求解的过程中，记录四个量：**当前点号、不限速边的个数、闯黄灯次数和用时**。其中前三个量用在 flag 数组里，因为前三个量取不同值，得到的答案显然不同。

对于某个点连向的每条边，分类：

1. 现在是绿灯，枚举限速和不限速，很简单。
2. 现在是黄灯，限不限速、闯不闯黄灯都要枚举。
3. 现在是红灯，枚举限速和不限速。

当需要等待时，将等待时间算在边权里就行。需要知道当前是什么灯，用 $d\bmod(x+y+z)$ 来判断。要开 long long。

```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#define int long long
using namespace std;
int n,m,k,g,a[110],b[110],c[110];
int d[110][110][110];
bool flag[110][110][110];
struct edge{int x,p,q;};
vector<edge>v[110];
struct node{int x,lim,cnt,dis;};
bool operator<(const node &x,const node &y){
    return x.dis>y.dis;
}
priority_queue<node>qq;
void go(int,int,int,int,int,int,int);
void dij();
signed main()
{
    cin>>n>>m>>k>>g;
    for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];
    for(int i=1;i<=m;i++)
    {
        int x,y,p,q;
        cin>>x>>y>>p>>q;
        v[x].push_back({y,p,q});
        v[y].push_back({x,p,q});
    }
    dij();
    return 0;
}
void go(int x,int limx,int cntx,int y,int limy,int cnty,int w)
{
    if(d[x][limx][cntx]+w<d[y][limy][cnty])
    {
        d[y][limy][cnty]=d[x][limx][cntx]+w;
        qq.push({y,limy,cnty,d[y][limy][cnty]});
    }
}
void dij()
{
    qq.push({1,0,0,0});
    memset(d,999999,sizeof(d));
    d[1][0][0]=0;
    while(!qq.empty())
    {
        int x=qq.top().x,lim=qq.top().lim;
        int cnt=qq.top().cnt,dis=qq.top().dis;
        qq.pop();
        int t=a[x]+b[x]+c[x],now=dis%t;
        if(x==n)
        {
            cout<<dis<<endl;
            exit(0);
        }
        if(flag[x][lim][cnt])continue;
        flag[x][lim][cnt]=1;
        for(auto e:v[x])
        {
            int p=e.p,q=e.q;
            if(now<a[x])//绿灯
            {
                //限速
                go(x,lim,cnt,e.x,lim,cnt,q);
                //不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,p);
            }
            else if(now<a[x]+b[x])//黄灯
            {
                //不闯黄灯，限速
                go(x,lim,cnt,e.x,lim,cnt,t-now+q);
                //不闯黄灯，不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,t-now+p);
                //闯黄灯，限速
                if(cnt<g)go(x,lim,cnt,e.x,lim,cnt+1,q);
                //闯黄灯，不限速
                if(cnt<g&&lim<m-k)
                    go(x,lim,cnt,e.x,lim+1,cnt+1,p);
            }
            else//红灯
            {
                //限速
                go(x,lim,cnt,e.x,lim,cnt,t-now+q);
                //不限速
                if(lim<m-k)go(x,lim,cnt,e.x,lim+1,cnt,t-now+p);
            }
        }
    }
}
```

---

## 作者：DerrickLo (赞：3)

我们可以使用 $dis[i][j][k]$ 表示当前点为 $i$，闯了 $j$ 次黄灯，目前经过了 $k$ 条没有限速的边，然后就可以对每一种情况跑 `dijkstra` 了。先判断现在是什么灯，如果是绿灯或者红灯那么可以限速也可以不限速，黄灯还需要判断是否要闯。最后答案就是 $\displaystyle{\max_{i=1}^{n}{\max_{j=0}^{m-k}{dis[n][i][j]}}}$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,g,x[105],y[105],z[105],dis[105][105][205],vis[105][105][105],ans=LONG_LONG_MAX;
struct edge{
	int v,p,q;
};
struct nd{
	int u,dis,cnt1,cnt2;
	friend bool operator<(const nd &a,const nd &b){
		return a.dis>b.dis;
	} 
};
vector<edge>ve[105];
priority_queue<nd> qu;
void add(nd a,nd b,int p){//是否更优
	if(dis[a.u][a.cnt1][a.cnt2]>dis[b.u][b.cnt1][b.cnt2]+p){
		dis[a.u][a.cnt1][a.cnt2]=dis[b.u][b.cnt1][b.cnt2]+p;
		qu.push({a.u,dis[a.u][a.cnt1][a.cnt2],a.cnt1,a.cnt2});
	}
}
signed main(){
	cin>>n>>m>>k>>g;
	for(int i=1;i<=n;i++)cin>>x[i]>>y[i]>>z[i];
	for(int i=1;i<=m;i++){
		int u,v,p,q;
		cin>>u>>v>>p>>q;
		ve[u].push_back({v,p,q});
		ve[v].push_back({u,p,q});
	}
	for(int i=0;i<=100;i++)for(int j=0;j<=100;j++)for(int k=0;k<=200;k++)dis[i][j][k]=1e18;
	qu.push({1,0,0,0});
	dis[1][0][0]=0;
	while(!qu.empty()){
		auto ft=qu.top();qu.pop();
		int nw=ft.dis%(x[ft.u]+y[ft.u]+z[ft.u]);
		if(vis[ft.u][ft.cnt1][ft.cnt2])continue;
		vis[ft.u][ft.cnt1][ft.cnt2]=1;
		for(auto v:ve[ft.u]){
			int dd=x[ft.u]+y[ft.u]+z[ft.u]-nw;
			if(nw<x[ft.u]){
				add({v.v,0,ft.cnt1,ft.cnt2+1},ft,v.p);//不限速
				add({v.v,0,ft.cnt1,ft.cnt2},ft,v.q);//限速
			}
			else if(nw<x[ft.u]+y[ft.u]){
				add({v.v,0,ft.cnt1,ft.cnt2+1},ft,dd+v.p);//不限速，不闯
				if(ft.cnt1<g)add({v.v,0,ft.cnt1+1,ft.cnt2+1},ft,v.p);//不限速，闯
				add({v.v,0,ft.cnt1,ft.cnt2},ft,dd+v.q);//限速，不闯
				if(ft.cnt1<g)add({v.v,0,ft.cnt1+1,ft.cnt2},ft,v.q);//限速，闯
			}
			else{
				add({v.v,0,ft.cnt1,ft.cnt2+1},ft,dd+v.p);//不限速
				add({v.v,0,ft.cnt1,ft.cnt2},ft,dd+v.q);//限速
			}
		}
	}
	for(int i=0;i<=m-k;i++)for(int j=0;j<=g;j++)ans=min(ans,dis[n][j][i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Tom17 (赞：1)

### 思路

- 分层图的 Dijkstra。

- 要在 $k$ 条马路上添加限速，等价于小X最多经过 $m - k$ 条不限速的道路。

- 得到状态转移数组：

	 $dp(cu,i,j,0/1)$ 分别表示**当前小X到达的路口**、**经过不限速的道路数量**、**闯黄灯的次数**、**是否通过当前路口**，其值表示**当前情况所用最短时间**。

### 分别考虑通过路口、通过道路时的情况

- 通过路口：
   
   1. 绿灯通行，时间不变。
   
   1. 红灯通行，等下一次绿灯。
   
   1. 黄灯通行，闯黄灯等同于绿灯通行，**闯黄灯的次数加 $1$**。
 
 	1. 黄灯通行，不闯黄灯等同于红灯通行。

- 通过道路：
	
	1. 限速时，加上限速的时间。
   
   1. 不限速时，**经过不限速的道路数量加 $1$**，加上不限速的时间。

### 如何判断当前的时间是什么灯

- 可以将各灯所用时间分段记录，记录各灯结束时间。

	例如某个路口绿灯 $5$ 秒、黄灯 $3$ 秒、红灯 $6$ 秒，记录时记绿灯第 $5$ 秒、黄灯第 $8$ 秒，红灯第 $14$ 秒结束（不含）。
  
- 此时红灯结束时间即为一轮总时间。用当前时间对红灯结束时间取模即可。

	以上面为例，当第 $19$ 秒通过这个路口时，因为 $19 \bmod 14 = 5$，所以通过该路口时为黄灯。
   
### 答案求解与时间复杂度

- 当第一次得到合法的答案时，即为最终答案。

- 时间复杂度为 $O(k \times g \times (n+m) \times \log(k \times g \times n))$。


### 代码

```cpp
#include<bits/stdc++.h>
#define N 110
#define int long long
using namespace std;

int n,m,k,g,head[N],l=1;

struct side{
    int last,to,small,big;
}e[N*2];

int green[N],yellow[N],red[N];

void add_side(int x,int y,int w1,int w2)
{
    e[l].last=head[x];
    e[l].to=y;
    e[l].small=w1;
    e[l].big=w2;
    head[x]=l;
    ++l;
}

int dp[N][N][N][2];

struct dp_node
{
    int cu,speed,light;
    bool passing;
    bool operator <(const dp_node a) const
    {
        return dp[a.cu][a.speed][a.light][a.passing]<dp[cu][speed][light][passing];
    }
};

bool vis[N][N][N][2];

priority_queue<dp_node> q;

void calc(int cu,int speed,int light,bool passing,int t)
{
    if(dp[cu][speed][light][passing]>t)
    {
        dp[cu][speed][light][passing]=t;
        q.push((dp_node){cu,speed,light,passing});
    }
}

signed main()
{
    cin>>n>>m>>k>>g;

    //初始化
    for(int i=1;i<=n;++i) for(int j=0;j<=m;++j) for(int p=0;p<=n;++p) dp[i][j][p][0]=dp[i][j][p][1]=1000000000000000000ll;

    //将各灯所用时间分段记录，记录各灯结束时间
    for(int i=1;i<=n;++i)
    {
        cin>>green[i]>>yellow[i]>>red[i];
        yellow[i]+=green[i];
        red[i]+=yellow[i];
    }

    for(int i=1;i<=m;++i)
    {
        int x,y,w1,w2;
        cin>>x>>y>>w1>>w2;
        add_side(x,y,w1,w2);
        add_side(y,x,w1,w2);
    }

    q.push((dp_node){1,0,0,1});
    dp[1][0][0][1]=0;

    dp_node r;

    while(!q.empty())
    {
        r=q.top();
        q.pop();

        if(r.cu==n&&r.speed<=m-k&&r.light<=g)
        {
            cout<<dp[r.cu][r.speed][r.light][r.passing];
            break;
        }
        else if((r.speed>m-k)||(r.light>g))
        {
            continue;
        }

        if(vis[r.cu][r.speed][r.light][r.passing])
        {
            continue;
        }
        else
        {
            vis[r.cu][r.speed][r.light][r.passing]=true;
        }

        int t=dp[r.cu][r.speed][r.light][r.passing];

        //分开讨论优点在于：代码更加清晰，更容易调试

        //通过路口
        if(!r.passing)
        {
            if(t%red[r.cu]<green[r.cu])//绿灯通行
            {
                calc(r.cu,r.speed,r.light,1,t);
            }
            else if(t%red[r.cu]<yellow[r.cu])//黄灯通行
            {
                calc(r.cu,r.speed,r.light+1,1,t);//闯黄灯
                calc(r.cu,r.speed,r.light,1,(int)ceil(t*1.0/red[r.cu])*red[r.cu]);//不闯黄灯
            }
            else//红灯通行
            {
                calc(r.cu,r.speed,r.light,1,(int)ceil(t*1.0/red[r.cu])*red[r.cu]);
            }
        }

        //通过道路
        else
        {
            for(int i=head[r.cu];i;i=e[i].last)
            {
                calc(e[i].to,r.speed,r.light,0,t+e[i].big);//限速
                calc(e[i].to,r.speed+1,r.light,0,t+e[i].small);//不限速
            }
        }
    }
    return 0;
}
```

---

## 作者：iakioi114514 (赞：0)

### 前置废话：

我开始做的时候：绿题，简单。

在中间的时候：好像有点难度。

做完后：为什么是绿题，不是蓝题。

主要是因为我忘记取反了，卡了我两个小时！

### 正题：

其实这个题是一个分层图，也可以用三维的 Dijkstra。第一维表示当前点，第二维表示还有多少条边不限速，第三维表示还可以闯多少黄灯。

设当前时刻是 $time$。

- 如果还能不限速：

> 就有两种情况：
>
> - 不闯黄灯，就判断当前路口是否为路灯如果是就直接冲过去。否则就加上等红绿灯的时间。
- 如果不能不限速：

> 和第一种情况一样，就是把时间改为限速的权值就可以了。

最后按照权值跑 Dijkstra 就可以了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,g,a[1000001],b[1000001],c[1000001],dis[101][101][101];
int h[1000001],e[1000001],ee[1000001],p[1000001],q[1000001],d;
void add_edge(int a,int b,int n,int m){
	e[d]=b;
	p[d]=n;
	q[d]=m;
	ee[d]=h[a];
	h[a]=d;
	d++;
}
struct s{
	int x,y,z,w;
	friend bool operator < (s u,s v){
		return u.w>v.w;
	}
};
priority_queue<s> qq;
void youxi(int x,int y,int z,int w){
	if(dis[x][y][z]>w){
		dis[x][y][z]=w;
		qq.push((s){x,y,z,w});
	}
}
void dijkstra(){
	for(int i=1;i<=n;i++){
		for(int j=0;j<=k;j++){
			for(int k=0;k<=g;k++){
				dis[i][j][k]=0x3f3f3f3f3f3f3f3f;
			}
		}
	}
	dis[1][0][0]=0;
	qq.push((s){1,0,0,0});
	while(!qq.empty()){
		s u=qq.top();
		qq.pop();
		int x=u.x,y=u.y,z=u.z,w=u.w,now=w%(a[x]+b[x]+c[x]);
		if(dis[x][y][z]<w) continue;
		for(int i=h[x];~i;i=ee[i]){
			int v=e[i];
			if(y<k){
				if(now<a[x]) youxi(v,y+1,z,w+p[i]);
				else youxi(v,y+1,z,w+a[x]+b[x]+c[x]-now+p[i]);
				if(z<g){
					if(now<a[x]+b[x]) youxi(v,y+1,z+1,w+p[i]);
					else youxi(v,y+1,z+1,w+a[x]+b[x]+c[x]-now+p[i]);
				}
			}
			if(now<a[x]) youxi(v,y,z,w+q[i]);
			else youxi(v,y,z,w+a[x]+b[x]+c[x]-now+q[i]);
			if(z<g){
				if(now<a[x]+b[x]) youxi(v,y,z+1,w+q[i]);
				else youxi(v,y,z+1,w+a[x]+b[x]+c[x]-now+q[i]);
			}
		}
	}
}
signed main(){
	memset(h,-1,sizeof(h));
	cin>>n>>m>>k>>g;
	k=m-k;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i]>>c[i];
	}
	for(int i=1;i<=m;i++){
		int u,v,xp,xq;
		cin>>u>>v>>xp>>xq;
		add_edge(u,v,xp,xq);
		add_edge(v,u,xp,xq);
	}
	dijkstra();
	int ans=0x3f3f3f3f3f3f3f3f;
	for(int i=0;i<=k;i++){
		for(int j=0;j<=g;j++){
			ans=min(ans,dis[n][i][j]);
		}
	}
	if(ans==0x3f3f3f3f3f3f3f3f) cout<<"-1"<<endl;
	else cout<<ans<<endl;
	return 0;
}
```
这题就这么水灵灵的过啦！

---


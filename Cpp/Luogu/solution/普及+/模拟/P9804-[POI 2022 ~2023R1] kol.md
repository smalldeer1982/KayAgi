# [POI 2022 ~2023R1] kol

## 题目背景

题目译自 [POI2022~2023R1 kol](https://sio2.mimuw.edu.pl/c/oi30-1/p/kol/)。

注意：原题时限为 32s，为避免卡评测，此题时限改为 3s。


## 题目描述

你在一个 $m \times m$ 的棋盘上玩贪吃蛇游戏，已知原本蛇长度为 $1$，内容为 `0`，在 $(1,1)$ 处，棋盘上存在 $p$ 个“食物点”，当一条蛇吃了一个“食物点”时，它将会在其头部增加一个食物点对应数值的部分，下图可以更清楚的演示吃食物的过程（红色数字为蛇身）：

![](https://cdn.luogu.com.cn/upload/image_hosting/8t9pu2br.png)

现在你进行了 $n$ 个操作，存在移动操作（上下左右）和查询操作（询问一个点是否被蛇覆盖），请编写一个程序求出它。

## 说明/提示

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $m \leq 300$ 且 $p,n \leq 2000$ | $20$ |
| $2$ | $m \leq 800$ 且 $p,n \leq 50000$ | $20$ |
| $3$ | $c_i=0$ | $20$ |
| $4$ | 无附加限制 | $40$ |

本题中，子任务 $0$ 为样例。

## 样例 #1

### 输入

```
6 5 14
1 3 1
5 1 5
2 3 2
3 4 1
3 5 3
Z 1 1
Z 1 2
P
P
D
D
P
Z 3 5
P
Z 3 5
D
Z 3 5
L
Z 3 5```

### 输出

```
0
-1
-1
3
1
2```

# 题解

## 作者：佬头 (赞：6)

## Description
你在一个 $m\times m$ 的棋盘上玩[**贪吃蛇游戏**](https://www.luogu.com.cn/problem/P9804)，已知原本蛇长度为 $1$，数值为 `0`，在 $(1,1)$ 处，棋盘上存在 $p$ 个**食物点**，当一条蛇吃了一个食物点时，其头部将会增加一个食物点对应数值的部分。

现在你进行了 $n$ 个操作：
- 移动操作（上下左右）。上（`G`）、下（`D`）、左（`L`）、右（`P`）。
- 查询操作（询问一个点是否被蛇覆盖）。不覆盖则输出 `-1`，否则输出对应数值。

## Solution
一眼鉴定为**小模拟**。

当看到查询 $(w,k)$ 是否有蛇身时，考虑开一个 `bool` 型数组表示是否有蛇身，维护头部坐标的同时再维护一个尾部坐标，把运动方式都放在一个队列里。如果吃到食物点，尾部坐标不动；否则将尾部的 `bool` 清 $0$，按照队首操作移动，最后弹出队首元素。

但是我们发现他不仅需要判断，还需要输出对应蛇身的数值。显然是要用一个数组来存储蛇身对应部分数值的，但是查询的坐标和我们存的数值没有太大关系，考虑如何建立联系。

那就要用到此类模拟的惯用做法**打时间戳**了。如果说我们给每一个运动过的点打上一个时间戳 $t$（最近一次运动到的时间。也是移动操作的次数，与查询操作无关。**~~因此还吃掉我一发提交~~**）。设此时蛇身长为 $len$，此时的时间为 $tim$（同时也是头部位置的时间戳），不难想到：
- 如果 $len\le tim-t[w][k]$，则此处没有蛇身。
- 否则 $(w,k)$ 就是从蛇尾开始第 $len - (tim - t[w][k])$ 段蛇身所处位置。我们把这段蛇身的数值输出即可。

时间复杂度 $\mathcal O(p+n)$。

## Code
由于题目给定的 $c_i\ge0$，为了将**食物点**与**空点**区分开，代码中将 $c_i$ 都加了 $1$，输出时再减去。

```cpp
#include <iostream>
using namespace std;
const int M = 2003, N = 1000006;
int m, p, n, w, k, mmp[M][M], x, y, val[N], tim = 1, len, t[M][M];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	m = read(), p = read(), n = read();
	for(int i = 1; i <= p; ++ i){
		w = read(), k = read();
		mmp[w][k] = read() + 1;
	}
	t[x = 1][y = 1] = 1, len = 1;
	for(int i = 1; i <= n; ++ i){
		char a = getchar();
		while(a < 'A' || 'Z' < a) a = getchar();
		if(a == 'Z'){
			w = read(), k = read();
			if(tim - t[w][k] >= len) fputs("-1\n", stdout);
			else write(val[len - (tim - t[w][k])]), putchar('\n');
		}
		else{
			if(a == 'G') x --;
			else if(a == 'D') ++ x;
			else if(a == 'L') y --;
			else ++ y;
			if(!t[x][y] && mmp[x][y]) val[++ len] = mmp[x][y] - 1;
			t[x][y] = ++ tim;
		}
	}
	return 0;
}
```


---

## 作者：zhuweiqi (赞：3)

本题原来的时限为 $32$s，做法显然是不加任何优化的朴素大模拟，这里就不多赘述了。我们主要还是来讲讲优化的思路：首先，我们发现每次查询只是让我们求出一个特定格子上的值（这里的“值”的定义为：如果当前位置存在蛇身，就是蛇身上对应的数值；否则即为 $-1$），因此可以考虑两种优化方案，第一种是维护一个队列依次记录从蛇头到蛇尾的坐标及其对应的数值，每次查询就遍历一遍队列得出答案，显然此方案的时间复杂度会在蛇身非常长（即经过的食物点特别多）的时候变得很大，不能适用于所有测试点；第二种方案是维护每个点当前时间点在从蛇头到蛇尾的第几个位置上，或者证明它压根不在蛇身上，从而得出答案，维护的方式为：定义一个二维数组 $f$，$f_{i,j}$ 表示蛇上一次经过是在第几步，为方便实现，初始时除了 $f_{1,1}$ 的值为 $1$ 之外，其它点的 $f$ 的值均为 $0$，当 $f_{i,j}$ 的值为 $0$ 时就表示蛇还没有经过 $(i,j)$ 这个点，记录当前时间点（即蛇移动的步数）$cnt$（初始值为 $1$），和当前蛇的长度 $len$（初始值为 $1$），维护一个动态的一维数组 $num$，$num_1$ 至 $num_{cnt}$ 表示从蛇头依次到蛇尾上的数值，当遇到一个查询 $(x,y)$ 的时候，我们先判断其是否在蛇身上，如果 $f_{x,y}=0$（蛇还没有经过）或者 $cnt-f_{x,y}+1>len$（蛇虽然经过了，但蛇已经跑走了），输出 $-1$；否则便可以得出 $(x,y)$ 现在是在从蛇头到蛇尾的第 $len-(cnt-f_{x,y})$ 个位置上，输出 $num$ 数组中对应的值即可。

查询部分优化完了，我们再来看操作部分如何维护，每次移动操作，蛇会向上或下或左或右移动一格，因此我们需要两个变量 $sx$ 和 $sy$ 分别时时维护蛇头的横纵坐标，记 $nx$ 和 $ny$ 分别为蛇移动后蛇头的横纵坐标，在蛇移动后，我们需要先把 $cnt$ 变量自增（即 ```++cnt```，下同），然后把 $f_{nx,ny}$ 赋值为 $cnt$，如果此时 $(nx,ny)$ 有个食物点，我们就需要把蛇的长度 $len$ 自增，并把 $num_{len}$ 赋值为 $b_{x,y}$（$b_{x,y}$ 定义为 $(x,y)$ 上的食物，如果没有则为 $-1$），然后别忘了，把 $b_{x,y}$ 赋值为 $-1$，因为这个食物点的食物一旦被吃掉了，以后再来这个地方就没有食物了，最后把蛇头的横纵坐标分别更新为 $nx$ 和 $ny$，就大功告成啦。

此代码的时间复杂度为 $O(m^2)$，且常数较小，跑出了 $590$ms 的不错的成绩（[link](https://www.luogu.com.cn/record/131878210)），比原时限快了五十多倍。In The End，献上我长度不到 $1$KB 的 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=2002,N=1e6+2;
int sx,sy;
int f[M][M];
int b[M][M];
int num[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	memset(b,-1,sizeof(b));
	int m,p,n,cnt=1,len=1;
	cin>>m>>p>>n;
	while(p--){
		int x,y,z;
		cin>>x>>y>>z;
		b[x][y]=z;
	}
	f[1][1]=1;
	num[1]=0;
	sx=1,sy=1;
	while(n--){
		char op;
		cin>>op;
		if(op=='Z'){
			int x,y;
			cin>>x>>y;
			if(!f[x][y] || cnt-f[x][y]+1>len) cout<<"-1\n";
			else cout<<num[len-(cnt-f[x][y])]<<"\n";
		}
		else {
			int nx,ny;
			if(op=='G') nx=sx-1,ny=sy;
			if(op=='D') nx=sx+1,ny=sy;
			if(op=='L') nx=sx,ny=sy-1;
			if(op=='P') nx=sx,ny=sy+1;
			f[nx][ny]=++cnt;
			if(b[nx][ny]!=-1){
				num[++len]=b[nx][ny];
				b[nx][ny]=-1;
			}
			sx=nx,sy=ny;
		}
	}
	return 0;
}
```

---

## 作者：xuan_gong_dong (赞：3)

## 题面
[P9804 [POI2022~2023R1] kol](https://www.luogu.com.cn/problem/P9804)

其实就是模拟贪吃蛇，感觉并不简单。

## 分析
### 先说说暴力吧（口胡的有问题请指出）
用一个数组存储贪吃蛇的身体。每一次移动分两种情况

- 吃到食物
- 没吃到食物

对于第一种情况，直接在数组中添加该点即可。
对于第二种情况，则添加下一步的点，删除尾巴，再把身体的所有点按照**时间戳**往后挪一位。时间复杂度 $O(n^2)$。

### 优化

注意我们暴力中是按照时间戳向后挪动，那可不可以记录该点被访问的时间戳，以及后来访问了多少次非食物的点（因为是食物的点身体不会移动的哟），这里可以用差分的方法记录。

即设$num$为已经走到空的节点的个数，$tot$ 为当前蛇的长度，则访问到该节点的时间戳为 $book_{ij}\gets tot + num$。

再处理查询的时候，如果 $book_{ij}-num \le 0$ 这表示该点未被访问过或者被访问过但蛇身已离开。否则蛇身覆盖该点，此时按照时间戳输出是蛇身上的那个位置。

时间效率为 $O(n)$。
![](https://cdn.luogu.com.cn/upload/image_hosting/xr1ds700.png)

## 细节

1. 访问到有食物的点后因应当将该点修改为无食物(血的教训)。

2. 无食物的点应被赋值为 $-1$，因为食物的序号 $0 \le c_i$。

3. 样例并不是题目中的图！！！

4. 要记录初始的蛇蛇 $0$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,m;
int vis[2010][2010];//判断该点是不是有食物，如果有，则表示食物的序号 
int book[2010][2010];//时间戳
int q[1000010];//吃到的顺序
int tot;//吃到多少食物 
int food[1000010];//食物的序号 
int num;//走到空的次数
int x,y;//蛇头的坐标 
inline int read() {
	int x=0;
	char c=getchar();
	while(!isdigit(c)) {
		c=getchar();
	}
	while(isdigit(c)) {
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}
inline char readc() {
	char c=getchar();
	while(c<'A'||c>'Z')c=getchar();
	return c;
}
inline void write(int x) {
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
int main() {
	m=read(),p=read(),n=read();
	x=1,y=1;//蛇头的坐标 
	for(int i=1; i<=m; i++)
		for(int j=1; j<=m; j++)
			vis[i][j]=-1;//无食物 
	for(int i=1; i<=p; i++) {
		int w,k,c;
		w=read(),k=read(),c=read();
		vis[w][k]=i;
		food[i]=c;
	}
	food[0]=0;
	book[1][1]=1;
	q[++tot]=0;
	for(int i=1; i<=n; i++) {
		char opt=readc();
		if(opt=='Z') {
			int tx,ty;
			tx=read(),ty=read();
			if(book[tx][ty]-num<=0)//是否有蛇 
				printf("-1\n");
			else {
				write(food[q[book[tx][ty]-num]]);
				putchar(10);
			}
		} else {
			if(opt=='G')x--;
			if(opt=='D')x++;
			if(opt=='L')y--;
			if(opt=='P')y++;
			if(vis[x][y]!=-1)
				q[++tot]=vis[x][y],vis[x][y]=-1;//有食物 
			else
				num++;//无食物 
			book[x][y]=tot+num;//访问到该点的时间戳 
		}

	}
	return 0;
}
```


---

## 作者：yr409892525 (赞：1)

### 题解 [P9804 [POI2022~2023R1] kol](https://www.luogu.com.cn/problem/P9804)
我们发现 $p \le 10^6$ 直接模拟肯定会超时。           
我们不妨使用时间戳来进行模拟，当一个位置上一次经过它的时间不超过他的长度，就说明存在蛇身，我们再用一个数组记录一下他蛇身的每个数字。             
当存在蛇身，就输出他当前的长度加上上一次经过这个格子的时间减去现在的时间，就可以的到他在蛇的哪个位置。               
### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2005;
int m,p,n;
int t[N][N];
int a[N][N];
int x,y,k,now=1,nx=1,ny=1;
int s[N*N],l=1; 
int main(){
	cin>>m>>p>>n;
	while(p--){
		cin>>x>>y>>k;
		a[x][y]=k+1;
	}
	t[1][1]=1;
	while(n--){
		char c;
		cin>>c;
		if(c=='Z'){
			cin>>x>>y;
			if(now-t[x][y]>=l) cout<<"-1\n";
			else cout<<s[l-now+t[x][y]]<<"\n";
		}else{
			if(c=='G') nx--;
			if(c=='D') nx++;
			if(c=='L') ny--;
			if(c=='P') ny++;
			if(a[nx][ny]){
				l++;
				s[l]=a[nx][ny]-1;
				a[nx][ny]=0;
			}
			now++;
			t[nx][ny]=now;
		}
	}
	return 0;
}
```

---

## 作者：cosf (赞：1)

## [P9804](https://www.luogu.com.cn/problem/P9804)

这道题，是一道模拟题。

显然，我们可以维护一个进入时间 $a_{i, j}$，表示蛇头最晚在 $a_{i, j}$ 进入到 $(i, j)$ 这个点。

同时，我们还要维护一个 $l$，表示蛇尾所在的格子的 $a$。

对于 `Z` 操作，我们判断该格子上有没有蛇，只需要判断该格子的 $a$ 是否大于等于 $l$ 即可。

注意：$c_i$ 可能等于 $0$，需要特判，否则你的代码可能会忽视这些点，并且获得 $0$ 分的高分（我因此罚了 $9$ 发）。

## 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

#define MAXM 2005

int mp[MAXM][MAXM];
int va[MAXM][MAXM];

vector<int> s;

int m, p, n;

int main()
{
	cin >> m >> p >> n;
	for (int i = 1; i <= p; i++)
	{
		int w, k, c;
		cin >> w >> k >> c;
		mp[w][k] = c + 1;
	}
	int l = 1;
	va[1][1] = 1;
	mp[1][1] = 0;
	s.push_back(0);
	int px = 1, py = 1;
	for (int i = 1; i <= n; i++)
	{
		char ch;
		cin >> ch;
		if (ch == 'Z')
		{
			int w, k;
			cin >> w >> k;
			if (va[w][k] < l)
			{
				cout << -1 << endl;
			}
			else
			{
				cout << s[va[w][k] - l] << endl;
			}
		}
		else
		{
			if (ch == 'G')
			{
				px--;
			}
			if (ch == 'D')
			{
				px++;
			}
			if (ch == 'L')
			{
				py--;
			}
			if (ch == 'P')
			{
				py++;
			}
			if (mp[px][py] == 0)
			{
				l++;
				va[px][py] = l + s.size() - 1;
			}
			else
			{
				s.push_back(mp[px][py] - 1);
				mp[px][py] = 0;
				va[px][py] = l + s.size() - 1;
			}
		}
//		for (int j = 1; j <= m; j++) // 输出棋盘
//		{
//			for (int k = 1; k <= m; k++)
//			{
//				if (va[j][k] == 0)
//				{
//					if (mp[px][py])
//					{
//						cout << mp[px][py] - 1;
//					}
//					else
//					{
//						cout << '.';
//					}
//				}
//				else if (va[j][k] < l)
//				{
//					cout << '.';
//				}
//				else
//				{
//					cout << s[va[j][k] - l];
//				}
//			}
//			cout << endl;
//		}
	}
	return 0;
}

```


---

## 作者：sieve (赞：0)

# 题解：[P9804 [POI2022~2023R1] kol](https://www.luogu.com.cn/problem/P9804)

## 思路

我们定义一个时间戳，记录到达这里的时间，如果头和尾的时间戳的差小于等于长度，说明是一个部分，然后按照题目模拟就行了。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int a[N][N];
int snake[N*N],len;
int ti[N][N],now;
int main()
{
	int m,p,n;
	cin>>m>>p>>n;
	for(int i=1;i<=m;++i)
	{
		for(int j=1;j<=m;++j)
		{
			a[i][j]=-1;
		}
	}
	while(p--)
	{
		int x,y,w;
		cin>>x>>y>>w;
		a[x][y]=w;
	}
	now=1;
	snake[1]=0;
	ti[1][1]=1;
	len=1;
	int nowx=1,nowy=1;
	while(n--)
	{
		char c;
		cin>>c;
		if(c=='Z')
		{
			int x,y;
			cin>>x>>y;
			int t=ti[x][y];
			if(now-t>=len)
			{
				cout<<-1<<'\n';
			}
			else
			{
				cout<<snake[len-(now-t)]<<'\n';
			}
		}
		else
		{
			if(c=='G') nowx--;
			else if(c=='D') nowx++;
			else if(c=='L') nowy--;
			else nowy++;
			if(a[nowx][nowy]!=-1)
			{
				len++;
				snake[len]=a[nowx][nowy];
				a[nowx][nowy]=-1;
			}
			now++;
			ti[nowx][nowy]=now;
		}
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P9804 [POI2022~2023R1] kol 题解

## 题意回顾

模拟贪吃蛇游戏：给定所有带颜色食物位置及贪吃蛇移动方向，可能在任意时刻要求你求出特定位置蛇身的颜色。

正方形棋盘边长不超过 $ 2 \times 10^3 $，操作次数不超过 $ 10^6 $，保证所有操作合法。

## 分析

蛇身如果拉成一条直线的话会发现每个元素被加入蛇身后颜色和相对位置都不变，因此由蛇的长度和每个位置到蛇头的距离求出这个位置到蛇尾的距离即可求出颜色，每个位置的颜色不难用支持结尾加入元素的动态数组维护。

蛇头牵着蛇身走，所以一个格子被蛇头抵达后才能被蛇身抵达，且会被每个蛇身依次抵达，故求出每个格子最晚一次被蛇头抵达的时间即可求出这个位置目前是蛇的第几个身位，即可求出颜色。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
const int M = 2005;
int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
int m, p, n;
int col[M][M];
int tim[M][M];
vector<int> snake;
int mp[256];
int main() {
    scanf("%d%d%d", &m, &p, &n);
    int x, y, w;
    memset(mp, -1, sizeof(mp));
    mp['G'] = 0, mp['D'] = 1, mp['L'] = 2, mp['P'] = 3, mp['Z'] = 4;
    memset(col, -1, sizeof(col));
    for(int i = 1; i <= p; i++) {
        scanf("%d%d%d", &x, &y, &w);
        col[x][y] = w;
    }
    x = 1, y = 1, w = 1;
    int nowt = 1;
    tim[1][1] = 1;
    char opt;
    int op;
    snake.push_back(0);
    int tx, ty;
    for(int i = 1; i <= n; i++) {
        scanf(" %c", &opt);
        op = mp[opt];
        if(op <= 3) {
            x += dir[op][0], y += dir[op][1];
            tim[x][y] = ++nowt;
            if(col[x][y] != -1) {
                w++;
                snake.push_back(col[x][y]);
                col[x][y] = -1;
            }
        } else if(op == 4) {
            scanf("%d%d", &tx, &ty);
            if(tim[tx][ty] + w - 1 < nowt) {
                printf("-1\n");
            } else {
                printf("%d\n", snake[w - nowt + tim[tx][ty] - 1]);
            }
        } else {
            printf("dthkxy AK IOI\n");
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：Akabane_Karuma (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P9804)

~~提示：洛谷中 Python 代码用 **PyPy3** 提交比 Python3 更快，但空间占用更多。~~

## Part 0：题目描述

有一个 $m \times m$ 的棋盘，贪吃蛇一开始在 $(1, 1)$ 的位置，长度为 $1$。棋盘上共有 $p$ 个食物。共有 $n$ 次操作，可以查询或者移动。查询：给出一个坐标 $(x, y)$，如果该点有蛇的身体，输出对应数字；否则输出 $-1$。移动：按照贪吃蛇的规则进行移动，若蛇蛇吃到食物，则蛇头会增加这个食物对应的数字。

## Part 1：朴素的做法（20pts）

做法一就是暴力做法啦。

主要有四个列表，分别是 `sx` `sn` `fx` `fn`。

`sx`：每项分为 $[x,y]$ 两个值，表示蛇身的坐标。

`sn`：每项表示蛇身对应的数字。

`fx`：每项分为 $[x,y,b]$ 三个值，表示食物的坐标与该食物是否被吃过。

`fn`：每项表示食物对应的数字。

根据题意模拟即可，但只能过样例、Subtask1。

```python
m, p, n = map(int, input().split())
sx = [[1, 1]]
sn = [0]
fx = []
fn = []
for i in range(p):
    w, k, c = map(int, input().split())
    fx.append([k, w, 1])
    fn.append(c)
for i in range(n):
    string = input().split()
    if len(string) == 3:  # 根据输入长度判断查询 or 移动
        y, x = int(string[1]), int(string[2])
        if [x, y] in sx:
            print(sn[sx.index([x, y])])  # 找到则输出对应数字
        else:
            print(-1)  # 找不到则输出-1
        continue
    s = string[0]
    if s == 'L':  # 上下左右移动规则
        dx, dy = -1, 0
    elif s == 'P':
        dx, dy = 1, 0
    elif s == 'G':
        dx, dy = 0, -1
    else:
        dx, dy = 0, 1
    xy = sx[len(sx)-1]
    sx.append([xy[0]+dx, xy[1]+dy])  # 蛇头到达对应位置
    if [xy[0]+dx, xy[1]+dy, 1] in fx:  # 吃到食物
        sn.append(fn[fx.index([xy[0]+dx, xy[1]+dy, 1])])
        fx[fx.index([xy[0]+dx, xy[1]+dy, 1])][2] = 0
    else:
        del sx[0]  # 没吃到食物，删除蛇尾
```

## Part2 大聪明做法（0pts，若不捆绑 23pts）

该做法是 Part1 的优化版。

可以看到，在 Part1 中，用到了 in 和 index，它们会让时间复杂度大大增加，从而导致超时。

因此，我们可以使用字典来解决这个问题。

通过设置键值和运用 try 语句，我们可以避免使用 in 和 index，让程序一下子就能找到对应的结果。

由于键值不能为列表（否则 `TypeError`），因此这里使用元组代替。

但是，由于 keys() 函数的返回值不是列表或元组，我们需要将其转化为列表或元组来解决问题，这样也会增加时间复杂度。

不过效果还是比较显著的：Subtask1、Subtask2 都是部分 AC，不过会出现 RE 的情况。（如果有大佬知道 RE 的原因请指点指点）

```python
m, p, n = map(int, input().split())
sx = {(1, 1): 0}
sn = [0]
fx = {}
cnt = 0
num = 0
for i in range(p):
    w, k, c = map(int, input().split())
    fx.update({(k, w): [c, 1]})
for i in range(n):
    string = input().split()
    if len(string) == 3:
        y, x = int(string[1]), int(string[2])
        try:
            print(sn[sx[(x, y)]-cnt])
        except KeyError:
            print(-1)
        continue
    s = string[0]
    if s == 'L':
        dx, dy = -1, 0
    elif s == 'P':
        dx, dy = 1, 0
    elif s == 'G':
        dx, dy = 0, -1
    else:
        dx, dy = 0, 1
    xy = tuple(sx.keys())[len(sx.keys())-1]
    num += 1
    sx.update({(xy[0]+dx, xy[1]+dy): num})
    try:
        if fx[(xy[0]+dx, xy[1]+dy)][1]:
            sn.append(fx[(xy[0]+dx, xy[1]+dy)][0])
            fx[(xy[0]+dx, xy[1]+dy)][1] = 0
    except KeyError:
        del sx[tuple(sx.keys())[0]]
        cnt += 1
```

## Part 3：正解

前面两个代码中都没有出现 $m$ 这个变量，而正解需要模拟出整张地图。

由于 $n$ 的范围比较大，我们应该考虑 $O(n)$ 算法。

因此，我们可以运用时间戳来解决这道题。

[感谢这位大佬在本题给出的时间戳概念！](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-p9804)

建立一个二维列表 `time`，表示蛇蛇在移动过程中留下的时间戳。蛇蛇每次到一个位置（包括初始状态）就打上一个时间戳 $t$。$t$ 初始值为 $1$，随着移动增加，不会被查询操作影响。

这样代码就出来了（时间复杂度 $O(n)$ 级）：

```
m, p, n = map(int, input().split())
sn = [-1, '0']
length = t = x = y = 1
mp = [['.' for j1 in range(m+1)] for i1 in range(m+1)]
time = [[0 for j2 in range(m+1)] for i2 in range(m+1)]
time[1][1] = 1
for i in range(p):
    w, k, c = map(int, input().split())
    mp[w][k] = str(c)
for i in range(n):
    s = input().split()
    if s[0] == 'Z':
        if t-time[int(s[1])][int(s[2])] >= length:
            print(-1)
        else:
            print(sn[length+time[int(s[1])][int(s[2])]-t])
    else:
        s = s[0]
        if s == 'L':
            y -= 1
        elif s == 'P':
            y += 1
        elif s == 'G':
            x -= 1
        else:
            x += 1
        if time[x][y] == 0 and mp[x][y] != '.':
            length += 1
            sn.append(mp[x][y])
        t += 1
        time[x][y] = t

```


---

## 作者：_EternalRegrets_ (赞：0)

#### 题意简化：

你正在玩贪吃蛇游戏。现在有 $j$ 个询问，表示 $(w_j,k_j)$ 位置上有没有蛇身，若有，输出蛇身此处的字符，否则输出 $-1$ 。

------------

直接模拟即可。 用 $a[x][y]$ 存储地图，用 ```vector``` 存储蛇身，再用数组 $b[x][y]$ 表示蛇在 $b[x][y]$ 时间达到 $(x,y)$ 。

用 $len$ 存储蛇的运动距离（即没有吃到食物的次数，因为当蛇吃到食物，它不会移动,只是在头上增加长度）

判断 $(w,k)$ 处是否有蛇身：

$b[w][k] \geqslant len$ 即这里有蛇身，输出 $v[b[w][k]-len]。$

否则， $(w,k)$ 为空位，输出 $-1$ 。

#### 注意：食物的数值可能会是 $0$，因此需要将 $a$ 数组初值设为 $-1$。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[2005][2005];
int b[2005][2005];

vector <int> v;

signed main(){
	int m; cin>>m;
	int p; cin>>p;
	int n; cin>>n;
	
	memset(a,-1,sizeof a);
	for(int i=1;i<=p;i++){
		int w; cin>>w;
		int k; cin>>k;
		int c; cin>>c;
		
		a[w][k]=c;
	}
	
	a[1][1]=-1;
	b[1][1]=1;
	
	v.push_back(0);
	
	int x,y,len; x=y=len=1;
	for(int i=1;i<=n;i++){
		char op; cin>>op;
		
		if(op=='Z'){
			int w; cin>>w;
			int k; cin>>k;
			
			if(b[w][k]<len){
				cout<<-1<<endl;
			}
			else{
				cout<<v[b[w][k]-len]<<endl;
			}
		}
		else{
			if(op=='G'){
				x--;
			}
			
			if(op=='D'){
				x++;
			}
			
			if(op=='L'){
				y--;
			}
			
			if(op=='P'){
				y++;
			}
			
			if(a[x][y]!=-1){
				v.push_back(a[x][y]);
				a[x][y]=-1; 
			}
			else{
				len++;
			}
			
			b[x][y]=v.size()+len-1;
		}
	}
	
	return 0;
}
```

---


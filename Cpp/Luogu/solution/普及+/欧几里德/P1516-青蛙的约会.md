# 青蛙的约会

## 题目描述

两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。

我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 $x$，青蛙 B 的出发点坐标是 $y$。青蛙 A 一次能跳 $m$ 米，青蛙 B 一次能跳 $n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。

## 说明/提示

对于 $100\%$ 的数据，$1 \le x, y, m, n \le 2 \times 10^9$，$x \ne y$，$1 \le L \le 2.1 \times 10^9$。

## 样例 #1

### 输入

```
1 2 3 4 5
```

### 输出

```
4
```

# 题解

## 作者：皎月半洒花 (赞：592)

这是一篇有详细证明的题解 $qwq$~

首先我们可以发现，这个题就是为了让我们解一个方程：

$$
x+km\equiv y+kn\pmod{l}
$$

其中 $k$ 为所求。

让我们把这个看上去很 zz 的方程变化一下：

$$
x+km-(y+kn)=lz,z \in Z
$$

那么就是：

$$
\begin{aligned}
x-y+k(m-n)-lz&=0\\
k(m-n)-lz&=-(x-y)
\end{aligned}
$$

我们设 $S=x-y,W=n-m$（注意这个地方有变号，即 $m-n$ 被我设作 $n-m$，为的是让等式右边的 $S$ 冠正号）。

这个式子便可写作：

$$
kW+lz=S
$$

诶，这不就是一个不定方程吗？

对啊，所以我们所要做的就是对这个不定方程求出最小解。

那么其实，对于这个方程，我们是要解出步数的最小值，所以我们只需要求出$k$最小即可。我们可以通过扩展欧几里德算法求出一组特解，然后对于这组特解，我们再推导出最小解来。

但由于这个方程在解 $exgcd$ 的时候，那个方程转化成了：

$$
k_jW+lz_j=(W,l)
$$

那么我们求出的 $k_j$ 就是这个方程得一个特解。

之后，这个方程的所有解就可以表示成

$$
k_i=k_j+t\frac{l}{gcd(W,l)}
$$

________________________


_这是上面这个式子为什么可以这么做的证明：_

若有 $ax+by=c$ 且 $a_0x+b_0y=c$。

那么便有 $a(x-x_0)+b(y-y_0)=0$。

两边同时除以 $gcd(a,b)$ 可得

$$
\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)\quad (1)

$$

而因为

$$
(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1
$$

所以由 $(1)$ 可得 $\frac{b}{gcd(a,b)}$ 整除 $(x-x_0)$。

所以很显然有 

$$
\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in \mathbb{Z}
$$

那么就有对于任意一个 $x_i$，有

$$
x_i=x_0+\frac{b}{gcd(a,b)} \times{t}
$$
________________________
____________________________

让我们回到原问题。因为

$$ 
k_j=k_{min}+\frac{l}{gcd(W,l)} \times{t} 
$$

这个方程对于 $t \in Z$ 而言，想要通过一个特解推出最小解，可以如此做：

$$
k_{min}=k_j \bmod \frac{l}{gcd(W,l)}
$$

而因为这个 $k$ 是建立在 $\rm exgcd$ 得出的方程上的，方程右边是 $gcd(W,l)$ 而不是 $S$。所以最后我们需要将结果 $\times{ \frac{S}{gcd(W,l)} }$ 。

```cpp
ll ans,x1,y1;

ll exgcd(ll a,ll b,ll &x1, ll &y1){
    if(!b){
        x1=1;
        y1=0;
        return a;
    }
    ans=exgcd(b,a%b,x1,y1);
    ll t=x1;
    x1=y1;
    y1=t-a/b*y1;
    return ans;
}

int main(){
    ll n,m,x,y,l;
    cin>>x>>y>>m>>n>>l;
    ll b=n-m,a=x-y;
    if(b<0){
        b=-b;
        a=-a;
    }//处理负数 
    exgcd(b,l,x1,y1);
    if(a%ans!=0)//判断方程有无解。 
        cout<<"Impossible";
    else
        cout<<((x1*(a/ans))%(l/ans)+(l/ans))%(l/ans);//处理负数 
}
```

















---

## 作者：FlashHu (赞：212)

很容易想到，如果他们相遇，他们初始的位置坐标之差$x-y$和跳的距离$(n-m)t$（设$t$为跳的次数）之差应该是模纬线长$l$同余的，即$(n-m)t\equiv x-y(\mod l)$

转化一下，不就变成了让我们求一个不定方程$(n-m)t+kl=x-y(k\in \mathbb Z)$中$t$的最小非负整数解么？

设$a=n-m,b=l,c=x-y$，把它转化成我们比较熟悉的一般不定方程的形式$ax+by=c$（此式的$x,y$与题目给的坐标意义不同）

首先，设$g=\gcd(a,b)$我们可以通过扩欧求出$ax_0+by_0=g$中$x_0$的一个解

这时，因为$\frac{ax+by}g$为整数，所以$\frac c g$也必须是整数，否则无解

否则，等式两边同乘$\frac cg$，得$a\frac{cx_0}g+b\frac{cy_0}{g}=c$

那么，$x=\frac{cx_0}g$就是$ax+by=c$中$x$的一个解

如何由一个解得到其它解呢？有一个恒等式$a(x+db)+b(y-da)=c$

在保证$db,da$都是整数的情况下，我们让$d$最小，就可以得到所有的整数解，那么$d=\frac 1g$

如果解出的$x>0$，那么最小非负整数解等于$x\mod\frac b g$；否则等于$x\mod\frac b g+\frac b g$

代码就可以直接写`(x%(b/g)+b/g)%(b/g)`

然后就可以交上去了，发现获得了70分

怎么回事？因为$\gcd$只对非负整数有意义，所以如果$a<0$等式两边要同时取负，$a,c$都要变成相反数；$b$本来就是正数，不用变也不能变。

总之，虽然是裸的exgcd题，但是很容易被细节实现坑到，尤其是求最小非负整数解和处理$a$为负数的地方。
```cpp
#include<cstdio>
#define LL long long
LL x,y,m,n,l,a,b,c,x0,y0,g,tmp;
void exgcd(LL a,LL b){
	if(!b){x0=1;g=a;return;}//顺便求gcd
	exgcd(b,a%b);
	tmp=x0;x0=y0;y0=tmp-a/b*y0;
}
int main(){
	scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
	a=n-m;b=l;c=x-y;
	if(a<0)a=-a,c=-c;//处理a为负数情况
	exgcd(a,b);
	if(c%g)puts("Impossible");
	else printf("%lld\n",(c/g*x0%(b/g)+b/g)%(b/g));//求最小非负整数解
	return 0;
}
```

---

## 作者：aiyougege (赞：77)

#### Solution
可以写出以下的方程
$$a(m-n)+bl=y-x$$
**如何判断是否存在解?**

我们知道对于方程$ax+by=c$成立的最小的c为$(a,b)$.
所以对于此题, 当$(m-n,l)\mid y-x$时存在解.

**如何求出方程的一组特解?**

记$d=(m-n,l)$,那么便可以将此方程写成以下形式
$$a\frac{m-n}{d}+b\frac{l}{d}=\frac{y-x}{d}$$

(*此形式就是我们后面讨论的形式.*)

由于$(\frac{m-n}{d},\frac{l}{d})=1$, 所以便可以求出对于方程$a\frac{m-n}{d}\equiv 1\mod \frac{l}{d}$的一组特解$a'$.

那么对于方程$a\frac{m-n}{d}+b\frac{l}{d}=\frac{y-x}{d}$的一组特解为$a_0=a'\frac{y-x}{d}$.

**如何求出方程的通解**

假设方程的另一组解记作$a_1$
那么$$a_0\frac{m-n}{d}+b_0\frac{l}{d}=\frac{y-x}{d}$$
$$a_1\frac{m-n}{d}+b_1\frac{l}{d}=\frac{y-x}{d}$$
联立两式得$$(a_1-a_0)\frac{m-n}{d}+(b_1-b_0)\frac{l}{d}=0$$
由于$(\frac{m-n}{d},\frac{l}{d})=1$, 所以必定有$(a_1-a_0)\mid \frac{l}{d}$.
也就是说
$$a_1=a_0+t\frac{l}{d}$$
因为$a_1$是任意的, 所以可以说对于方程的任何一组解$a$都可以表示成$a=a_0+t\frac{l}{d}$的形式.

求出通解后, 最小正整数解$a_{\min}$便可以表示成$a \equiv a_{\min}\mod \frac{l}{d}$的形式.
#### Code
```c++
#include<cstdio>
#include<cstdlib>
#define int long long
using namespace std;

int gcd(int a,int b){return b?gcd(b,a%b):a;}
void exgcd(int a,int b,int &x,int &y){
	if(!b){x=1,y=0;return ;}
	exgcd(b,a%b,y,x);
	y-=a/b*x;
}
main(){
	int a,b,x,y,n,m,l;
	scanf("%lld%lld%lld%lld%lld",&a,&b,&m,&n,&l);
	int gg=gcd(m-n,l),mod=abs(l/gg);
	exgcd(m-n,l,x,y);
	if((b-a)%gg){
		printf("Impossible");
		return 0;
	}
	x=(x*((b-a)/gg)%mod+mod)%mod;
	printf("%lld",x);
	return 0;
}
```

---

## 作者：QSWei (赞：77)

解释：

1.两只青蛙相遇，会有[(x-y)+k(m-n)]%l=0;(k表示跳的次数)。【方程来源】

2.将(x-y)记为A,(m-n)记为B,即(A+kB)%l=0,(A+kB)对l取余等于零可以等价为(A+kB)减去y个l等于零，即(A+kB)-yl=0，移项得kB-yl=-A。【方程】

3.将k换为x，得到xB-yl=A(由于将-A变成了A，在开始赋值时若B=m-n，A就为y-x，若B=n-m，A就为x-y)，然后判断是否有解：令d为B与l的最大公约数gcd(B,l);方程两边同时除以d，得到

了xB/d-yl/d=A/d,由于d=gcd(B,l),所以B/d、l/d为整数，然后x、-y也是整数，所以方程成立的条件就是A/d也为整数。【证明方程成立】

4.这个方程就是扩展欧几里得exgcd(B,l,x,y)（忽略y前的负号），这样可以解出x，此时的x不是最优解，还要转换，即((x\*(A/d))%(l/d)+(l/d))%(l/d)【求最小解的式子，不理解先背下来】。



代码（c++）【部分表示与解释中不同，也没关系，注意一下就好了】

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long m,n,xn,yy,l;
long long r,a,b,x,y;
int exgcd(long long a,long long b,long long &x, long long &y);
int main()
{
    cin>>xn>>yy>>m>>n>>l;
    a=xn-yy;
    b=n-m;
    if(b<0)
    {
        b=-b;
        a=-a;
    }
    exgcd(b,l,x,y);
    if(a%r!=0)
        printf("Impossible");
    else
        cout<<((x*(a/r))%(l/r)+(l/r))%(l/r);
    return 0;
}
int exgcd(long long a,long long b,long long &x, long long &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    r=exgcd(b,a%b,x,y);
    long long cnt=x;
    x=y;
    y=cnt-a/b*y;
    return r;
}

```

---

## 作者：不知名的蒟蒻 (赞：45)

本蒟蒻在dalao们的指导下终于A了这道题，然后去看题解，发现根本看不懂QAQ于是乎就写了这个非常通俗的题解ovo应该会有问题qwq

**核心**
```cpp
int exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int ans=exgcd(b,a%b,x,y);
    int temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}			//得出的x,y为一组特解
```
证明
设gcd(a,b)=a*x+b*y

gcd(a,b)=gcd(a%b)

gcd(b,a%b)  =b*x'+(a%b)*y'

=b*x'+(a-a/b*b)*y'

=b*x'+a*y'-a/b*b*y'

=a*y'+b*(x'-a/b*y')

∴a*x+b*y=a*y'+b*(x'-a/b*y')

∴x=y',y=x'-a/b*y'


-----神奇的分割线-------


例题分析
P1516 青蛙的约会

[题目](https://www.luogu.org/problemnew/show/P1516)

由题意可得

设共跳了k次，那么

x+k*m≡y+k*n(mod l)

设x+k*m除l商为a，余z，设y+k*n除l商为b，余z。那么

x+k*m+a*l=y+k*m+b*l

化简得

k*(m-n)+(a-b)*l=y-x

此时(m-n)已知,(y-x)已知,l已知

设(m-n)=A,k=X,(a-b)+Y,l=B,(x-y)=K

若A<0,要处理负数

```cpp
if(A<0)
{
A=-A;
B=-B;
}
```
即A*X+B*Y=K

是一个不定项方程，此时即可以用

exgcd(B,x,y),求出一组特解x0,y0去求他的另一组特解X,Y

此时，有

A*X+B*Y=K

A*x0+B*y0=gcd(A,B)

设gcd(A,B)*m=K，则

m*(A*x0+B*y0)=gcd(A,B)*m=K=A*X+B*Y
m=K/gcd(A,B)

即A*m*x0+B*m*y0=A*X+B*Y

∴X=m*x0,Y=m*y0;

此时再套用求最小整数解的公式

 _**((x0*(K/gcd(a,b)))%(l/gcd(a,b))+(l/gcd(a,b)))%(l/gcd(a,b))**_ 

求出k

注意：若K%gcd(a,b)!=0,此方程无解

下面是代码：
--------------------------------------------------------------------------------
```cpp
#include<iostream>
using namespace std;
long long x,y,m,n,l,r=0;
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(b==0)
	{
		x=1;
		y=0;
		return a;
	}
	r=exgcd(b,a%b,x,y);
	long long t=x;
	x=y;
	y=t-a/b*y;
	return r;
}
int main(){
	cin>>x>>y>>m>>n>>l;
	long long A=n-m,B=x-y;
	if(A<0)
	{
		A=-A;
		B=-B;
	}
	exgcd(A,l,x,y);
	if(B%r!=0)
		cout<<"Impossible";
	else cout<<((x*(B/r))%(l/r)+(l/r))%(l/r);
}
```
--------------------------------------------------------------------------------


---

## 作者：606gtfp6k1 (赞：39)

## 从零开始理解一次不定方程

之前的题解虽然已经很详细了，但是总感觉不是对新人（比如我）不是很友好。所以这里再讲一遍，争取逻辑顺畅。

P1516，青蛙的约会，本质就是求解**一次不定方程**。 何谓一次不定方程，通俗的来说，就是一个存在两个未知数的方程，所以这种方程的答案是以解集的形式呈现的。

那么如何求解一次不定方程呢？需要提前了解两个数学定理——****扩展欧几里得算法和裴蜀定理**

------------

------------


### 扩展欧几里得算法（exgcd）

扩展欧几里得算法即为求解形如 ax + by = gcd(a, b) （并且有a,b∈N*, x,y∈Z）的方程的解集，gcd()即为求解最大公因数。

是不是有人要问了，我TM为什么要求长得这么丑，看起来毫无意义的方程 ? 只能说，先不要急，后面要用。

关于exgcd求法的推导，其实本质上是一个**迭代递推**的过程，即利用gcd(a, b) = gcd(b, a % b)，从而缩小a, b的数值，最终达到终末状态——再回溯求得原方程的解。这里简单推导一下

**设** x, y, 有方程 ax + by = gcd(a, b)

**再设** x', y', 有方程 bx' + (a%b)y' = gcd(b, a%b)

**因为** gcd(a, b) == gcd(b, a%b)

**所以** 联立得 ax + by = bx' + (a%b)y'
（接下来，需要我们推导x与x', y和y'的关系，原因见上文）

**因为** a%b = a - (a / b) * b 
[ 注：这里除号为下取整 ]

 _（关于为什么可以这么表示，具体可以自己在数轴上划一划，就可以明白了）_ 

**所以** 有 ax + by = bx' + (a - a/b * b) y'

**合并同类项** 得 ax + by = ay' + b * (x' - a/b * y')

**所以** 观察等式两边，得:

 _1_ . x = y'

 _2_ . y = x' - (a/b) * y'
 
 _(那么是不是只要知道x'与y'，就可以得出x,y的值了？)
(那么x’，y’怎么求？只需要把x',y'看做是要求解的x，y，再进一步迭代即可。)_ 

**观察** 在a,b逐渐减小时有:

**当b=0时**， a * 1 + b * 0 = gcd(a, b)

**即得** 边界条件x0 = 1, y0 = 0;
(关于b是如何变为0的，请代上数值详细模拟一边gcd的算法)

**至此，推导完毕.**

总结以上推导，我们便拥有了求解ax + by = gcd(a, b)的工具。


------------

### 裴蜀（贝祖）定理

具体证明比较复杂，此处略（自行百度即可）

**定理**->  方程 ax+by=c （a,b,c∈N*）有解的充要条件是 gcd(a, b) | c

 _( gcd(a, b) | c的意思是，gcd(a, b)是c的一个因数，或者说， c % gcd(a, b) == 0。充要条件的定义请左转见数学必修2)_ 

通过这个定理，我们不仅能够判断方程的**可解性**，还可以得出方程的解集，推导见下：

设 a·x0 + b·y0 = gcd(a, b)

则令 k = c ÷ gcd(a, b)

得 a·x0·k + b·y0·k = c

设变量t，则
又变形得

a·(x0·k + b / gcd(a, b) * t) + b·(y0·k - a / gcd(a, b) * t) = c

所以 ax + by = c  的解集就是

{(x, y)|x = x0·k + b / gcd(a, b) * t, 

y = y0·k - a / gcd(a, b) * t, 且t∈Z}

所以，我们就解完了一元不定方程？是不是非常简单2333




------------


------------

------------

## 那么这个题？

关键词：**「转化能力」**

根据题目所述，我们有x, y, m, n, L, 那么根据题目条件便有(设t是经过的时间，L*k即为两个青蛙（？）的距离)：

(方便起见，不妨设n > m)

**由** x + mt - (y + nt) = L * k,  k∈Z

**得**  (x - y) - (n - m)t = L * k

**移项得** Lk + (n - m) * t = (x - y)

未知数只有k和t了，那么这个方程是不是感觉在哪里见过啊？？

那么是不是可以很愉快地解方程啦？

最后我们得到了关于t、k的解集。

**因为** t>=0恒成立（为什么?你见过时间倒流吗=.=）

**所以** 只取t的最小正整数即可。
这里稍微说明一个小技巧——
如果有y = x + a*t， 那么y的最小正整数y'可以这么求：
（这里的字母是瞎编的，不是原题。）

y' = (x % t + t) % t; 

最后就做完了。代码奉上



```
.....
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

void exgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b){x = 1; y = 0; return;}
	exgcd(b, a % b, y, x);
	y -= a / b * x;
}

ll gcd(ll a, ll b){
	return (b == 0) ? a : gcd(b, a % b);
}

ll X, Y, M, N, L, g, x, y;

int main()
{
	ios::sync_with_stdio(0);
	cin >> X >> Y >> M >> N >> L;
	if(N < M) swap(X, Y), swap(M, N);
	g = gcd(L, N - M);
	exgcd(L, N - M, x, y);
	if((X - Y) % g != 0) cout << "Impossible" << endl;
	else {
		cout << (y * ((X - Y) / g) % (L / g) + (L / g)) % (L / g) << endl;
	}
	return 0;
}
```


---

## 作者：1jia1 (赞：19)

这道题目首先需要简单地推导一下，就可以算出来了。

核心思路：通过推导得出一个不定方程组，然后用坠吼的扩欧求出一组特解就能算出来了。

先放上chen刚开始画的图。

![](https://cdn.luogu.com.cn/upload/pic/20502.png)

为什么画的这么差呢？因为chen的画图软件用的是一种鸭嘴的笔，旁边有一个调色盘，最痛苦的就是选取调色盘最佳的颜色给这支笔调上去，然后描图的时候手就抖了，还得用橡皮擦去擦，这个就是画图最痛苦的。

我们设青蛙跳了X步。

首先根据题意，列出式子

$$(x+Xm) mod L=(y+Xn) mod L$$

意思是第一只青蛙从自己的位置向某个方向跳X步，经过多次跳跃碰到了从自己的位置向某个方向跳X步的另一只青蛙，他们的坐标是相同的。

_//青蛙：I am angry!_

$$(x+Xm-y-Xn)modL=0$$

$$[x-y+X(m-n)]modL=0$$

$$x-y+X(m-n)=YL$$

$$X(n-m)+YL=x-y$$

把已知常量换元，设A=n-m,B=L,C=x-y得

$$AX+BY=C$$

就变成扩欧了！

接下来的事情就简单多了，把X Y的一组特解求出来，X就是答案了。

至于Y有什么意义，可能只有神奇海螺知道了吧！

~~神奇海螺：无可奉告~~

---

## 作者：PHarr (赞：9)

这道题，是一道挺有难度的题。

设两只青蛙跳了$a$步，则$A$蛙的坐标是$x+ma$,$B$蛙的坐标是$y+na$

所以两只青蛙相遇的充分条件是$x+ma-(y+na) = Lb\ (b \in Z)$

提公因式得$(m-n)a + (x-y) = Lb$

移项，方程两边同城$-1$得$(n-m)a + Lb = (x-y)$

令$x = (m-n)$,$y = L$,$d = gcd(x,y)$

用扩展欧几里得解$xa + yb = d$的一组解$(a,b)$

若$(x-y) \% d \neq 0$或$m = n$无解

否则$a$就是我们求的一组解，但不一定是题目要求的解

所以还要对$a$进行操作

令$c = (x-y)$,为了方便表示我们$swap(x,a) \ swap(y,b)$

呢么我们本来要解的方程式是$ax_0+by_0 = c$

但是我们解的方程式是$ax_1+by_1 = d$


对于这个方程我们同乘$\frac{c}{d}$得$ax_1\frac{c}{d}+by_1\frac{c}{d} = c$

所以对于一组$(x_1,y_1)$符合$ax_1+by_1 = d$,则必有一组$(x_1\frac{c}{d},y_1\frac{c}{d})$符合$ax_0+by_0 = c$

又因为如果$(x,y)$是丢番图方程的一组解则$(x-\frac{b}{d} ,y+\frac{a}{d})$也是一组解

所以如果我们知道$x$是一个正整数解，则最小就是让$x$不断地的减$\frac{b}{d}$这个过程就相当于取模$(x_1\frac{c}{d})\% \frac{b}{d}$

在把x,y,a,b换回来，并代入数据得$result = (a\times(\frac{x-y}{d}) \% (\frac{L}{d})+(\frac{L}{d}))\%(\frac{L}{d})$

**coding**
```cpp
#include <iostream>
#define LL long long
using namespace std;


LL x,y,n,m,l;


inline LL exgcd(LL a,LL b,LL &x,LL &y)
{
	if(a == 0)
	{
		x = 0,y = 1;
		return b;
	}
	register LL d = exgcd(b%a,a,y,x);
	x -= b / a * y;
	return d;
}


int main()
{
	LL a,b,d;
	cin >> x >> y >>  m >> n >> l;
	if(n < m) swap(m,n), swap(x,y);
	d = exgcd(n-m,l,a,b);
	if((x-y) % d || m == n) puts("Impossible");
	else cout << (a*(x-y) / d % (l/d) + (l/d)) % (l/d) << endl;
	return 0;
} 
```

---

## 作者：星爵 (赞：8)

令**A=x-y**,**B=m-n**，**K为步数**，**L为距离**

也就是A为初始位置的距离差   B为速度差；

可以得到**abs（A+K\*B）%L=0**

变形得**abs（A+KB）=YL**

再变得**xB-yL=-A**

这就很容易想到拓展欧几里得定理

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
ll x,y,m,n,l,k,r,a,b;
int xx,yy;
ll gcd(ll a,ll b,int &xx,int &yy)//拓欧
{
    if(b==0)
    {
        xx=1;yy=0;
        return a;
    }
    ll r=gcd(b,a%b,xx,yy);
    int t=xx;
    xx=yy;
    yy=t-(a/b)*yy;
    return r;
}
int main()
{
    scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
    a=x-y;b=n-m;//定义A,B
    if(b<0)
    {
        a=-a;
        b=-b;
    }
    r=gcd(b,l,xx,yy);
    if(a%r!=0)
    {
        printf("Impossible");
        return 0;
    }
    printf("%lld",((xx*(a/r))%(l/r)+(l/r))%(l/r));
    return 0;
}

```

---

## 作者：ez_lcw (赞：6)

不妨设青蛙A的出发点坐标是$m1$，青蛙B的出发点坐标是$n1$。青蛙A一次能跳$m$米，青蛙B一次能跳$n$米，跳一圈长$l$米，设青蛙A、B跳了$x$次。

那么题目要求的是满足下面这个柿子最小$x$正整数解：

$$(m-n)\times x\equiv m1-n1\pmod{l}$$

不妨把这个不定方程变形一下：

$$(m-n)\times x+l\times y=m1-n1$$

看到这个形式，就想到用**扩展欧几里得**来求解。

不妨设$a=m-n,b=l,c=m1-n1$。

那么原方程就是：

$$a\times x+b\times y=c$$

然后我们知道一个性质：

若$a\times x+b\times y=c$有解，则满足$gcd(a,b)|c$。

所以说我们先判断方程是否有解，若无解就输出$\mathbf{Impossible}$。

然后如果有解，我们就先用扩展欧几里得求出$a\times x+b\times y=gcd(a,b)$的一组解。

然后我们对这个方程左右两边同时乘上$c\div gcd(a,b)$。

那么有：

$a\times(c\div gcd(a,b))\times x+b\times(c\div gcd(a,b))\times y=c$

为了方便起见，我们这里令$p=a\times(c\div gcd(a,b))$，$q=b\times(c\div gcd(a,b))$。

这时，我们就可以求出满足下列方程的一组特解：

$p\times x+q\times y=c$

此时，我们发现$x$可以任意变为$(x+k\times \frac{q}{gcd(p,q)})$，且总有对应的一个整数解$y$使得原方程依旧成立，因为：

若$p\times x+q\times y=c$成立，则必有$p\times (x+\frac{q}{gcd(p,q)})+q\times (y-\frac{p}{gcd(p,q)})=c$ 成立。

（为什么一定要除$gcd(p,q)$？因为在电脑中会向下取整，而且我们要使得$\frac{q}{gcd(p,q)}$尽量小，这样才能找到更多的$x$解）。

所以令$g=\frac{q}{gcd(p,q)}$，即：

$$g=\frac{q}{gcd(p,q)}=\frac{b\times(c\div gcd(a,b))}{gcd(a\times(c\div gcd(a,b)),b\times(c\div gcd(a,b)))}=\frac{q}{gcd(a,b)}$$

那么$x$的最小正整数解为：

$$((x \bmod g)+g)\bmod g$$

那么我们就可以输出答案了。

最后代码如下：

```cpp
#include<bits/stdc++.h>
 
#define ll long long
 
using namespace std;
 
ll m1,n1,m,n,l;
 
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b)
    {
        x=1ll,y=0ll;
        return a;
    }
    ll ans=exgcd(b,a%b,x,y);
    ll xx=x;
    x=y;
    y=xx-(a/b)*y;
    return ans;
}
 
int main()
{
    while(~scanf("%lld%lld%lld%lld%lld",&m1,&n1,&m,&n,&l))
    {
        if(n<m)
        {
            swap(n,m);
            swap(n1,m1);
        }
        ll a=n-m,b=l,c=m1-n1,x,y;
        ll t=exgcd(a,b,x,y);
        if(c%t)
        {
            puts("Impossible");
            continue;
        }
        c/=t;
        x*=c;
        ll mod=b/t;
        x=(x%mod+mod)%mod;
        printf("%lld\n",x);
    }
    return 0;
}
```

---

## 作者：z7z_Eta (赞：3)

### 一篇清楚（~~字少~~）的题解

由于纬度线是环形的，自然的想到了同余方程

对于$x$，$y$，$m$，$n$，$L$，我们令

$$a=y-x,\ b=n-m,\ p=L$$

令答案为$k$，可得方程

$$a+b*k\equiv 0\mod p$$

如果$gcd(b,p)=1$，则 $b$ 有逆元，直接得出

$$k\equiv -a*b^{-1}$$

此时方程有在$\text{mod}\ p$ 意义下有唯一解。

但是我们还要考虑到方程整体，比如a=4，b=2，p=6，虽然$gcd(b,p)=2$，但是k=2时，方程是成立的，这时我们应该对方程取模。

令$g=gcd(a,b,p)$，则

$$A=\frac ag,B=\frac bg,P=\frac pg$$

此时如果$gcd(B,P)\ne 1$，则 $B$ 无逆元，可判无解。

### code：

```cpp
// SeptEtavioxy
#include<cstdio>
#define ll long long
using namespace std;

void exgcd(ll a,ll b,ll&d,ll&x,ll&y){
	if( !b ){ d=a,x=1,y=0;return ;}
	exgcd(b,a%b,d,y,x); y-=x*(a/b);
}
ll gcd(ll a,ll b){
	return b? gcd(b,a%b):a;
}
int main(){
	int a1,a2,a3,a4,a5;
	scanf("%d%d%d%d%d",&a1,&a2,&a3,&a4,&a5);
	
	ll a=((a2-a1)%a5+a5)%a5, b=((a4-a3)%a5+a5)%a5, p= a5;
	
	ll g= gcd(a,gcd(b,p));
	a/=g, b/=g, p/=g;
	
	ll d,x,y;
	exgcd(b,p,d,x,y);
	if( d==1 ) printf("%lld",((-a)*x%p+p)%p);
	else puts("Impossible");
	
	return 0;
}
```

---

## 作者：丶雖 (赞：3)

~~青蛙都有约会     www~~~

# 前言

#### ◆扩展欧几里得算法
对于任意整数a.b,存在一对整数x，y,满足ax+by=gcd(a.b)。
,在欧几里得算法的最后一步,即b=0时,显然有一对整数x=1，y=0,使得a+0=gcd(a,O);若b>0,则假设存在一对整数x,y,满足b*x+
(a mod b)*y=gcd(b, a mod b),又根据模性质，拆开后得：
ay+b(x-ay/b)=gcd(b,a mod b);则可让x=y,y=x-(a/b)*y一步步递归下去。

#### ◆线性同余方程
给定整数a，b，m,求一个整数x满足a*x≡b(mod m),或者给出无解。因为
未知数的指数为1,所以我们称之为一次同余方程,也称线性同余方程。
a*x≡b(mod m)等价于ax-b是m的倍数,不妨设为-y倍。于是,该
方程可以改写为a*x+m*y=b。
根据定理及其证明过程,线性同余方程有解当且仅当b是gcd(a,m)的倍数。
在有解时,先用欧几里得算法求出一组整数x0，y0,满足a*x0+m*y0=gcd(a,m)
。然后**x=x0+b/gcd(a,m)** 就是原线性同余方程的一个解
方程的通解则是所有模m/gcd(a,m)与x同余的整数。

# 开始正题

注意向西为正方向，可自行画一个圆模拟样例

易得方程 **x+km=y+kn;** k即为所求

则有x+km与y+kn关于mod l同余，即x+km≡（y+kn）mod l

既然余数相等 则x+km减去y+kn一定为l倍数，设为p

**（（x+km）-(y+kn）)=pl**

合并得k(m-n)+pl=y-x

再设a=m-n; b=l res=y-x;就有ak+bp=res

等等，好熟悉，这不是同余方程求k吗

那问题就简单了，就是用扩欧求方程的方法

impossble的情况即c不是gcd(a,b)的倍数时。

我们先把式子看成ak+bp=gcd(a,b)，用扩欧求出k，再用上面所讲的同余方程的知识求出真正方程ak+bp=res的一个解k
不过这个解可能不是最小值，我们需要再考虑，如下：

若有ax+by=c，ax0+by0=c，则有a（x-x0）+b(y-y0)=
0，
两边同时除以gcd(a,b)可得：a/gcd(a,b)乘以（x-x0）=-b/gcd(a,b)乘以(y-y0)。
由a/gcd(a,b)与b/gcd(a,b)互质//**一项基本定理**
可得要使等式成立一定有（x-x0）是b/gcd(a,b)的倍数，即x=x0+k*(b/gcd(a,b)),k∈Z;
那么k的最小正整数解即可用k = (k % (b / cd) + (b / cd)) % (b / cd)表示    ~~//cd即gcd(a,b)~~
想一下，为什么要这样表示？

好吧，~~我还是太善良了~~，这样可以直接将正负数都给化简成最小正整数解，就不用分类讨论了qwq。

那这道题就work out了  //~~来自英语蒟蒻的显摆~~

AC code

```cpp
#include<iostream>
#include<cstdio>
#define ll long long

using namespace std;

ll x, y, n, m, l, ans;

ll gcd(ll x, ll y)
{
	if(!y)
		return x;
	return gcd(y, x % y);
}

void exgcd(ll a, ll b)
{
	if(!b)
	{
		x = 1;
		y = 0;
		return;
	}
	exgcd(b, a % b);
	ll t = x;
	x = y;
	y = t - (a / b * y);
}

int main()
{
	scanf("%lld%lld%lld%lld%lld", &x, &y, &m, &n, &l);
	ll a = m - n, b = l;
	ll res = y - x;
	if(a < 0)
		a = -a, res = - res;//这里注意取值
	if(res % gcd(a, b) != 0) 
	{
		printf("Impossible");
		return 0;
	}
	else
	{
		exgcd(a, b);
		ll cd = gcd(a, b);
		ll bei = res / cd;
		x = x * bei;
		x = (x % (b / cd) + (b / cd)) % (b / cd);
	}
	printf("%lld", x);
	
return 0;
}
```
结束了吗？？？
好吧再见qwq

---

## 作者：liuzitong (赞：2)

dalao们真是太强了,吊打我无名蒟蒻

我连题解都看不懂,在此篇题解中,我尽量用语言描述,不用公式推导(~~dalao喜欢看公式的话绕道,这篇题解留给像我一样弱的~~)

进入正题

如果不会扩展欧里几德的话请先去做

洛谷 p1082 同余方程


设跳了k次

所以km - kn + x - y = 0(mod l)
所以k(m - n) + h * l = y - x
~~这个移项应该没问题吧~~

设(m - n)为a,k为x,h为y,
l为b,(y - x)为m

那么转换为ax + by = m
根据裴蜀定理ax + by = gcd(a,b)有解

但不代表ax + by = m无解
我们可以让等式两边同除一个m,再同乘一个gcd(a,b)

就成了ax / m * gcd(a,b) + by / m * gcd(a,b) = gcd(a,b)

把(x / m * gcd(a,b))作为新的x,(y / m * gcd(a,b))作为新的y

再利用扩展欧里几德可以求出新的x
即(x / m * gcd(a,b))

我们如果求出了(x / m * gcd(a,b)),那么也可以求出x(乘一个m再除一个gcd就好了)

但是这并不意味这每个方程都有解,因为我们的x代表的是k
也就是x代表跳的次数,所以仅可以作为整数
也就是如果我们必须让 m整除gcd(a,b)即m % gcd(a,b) == 0
如果m % gcd(a,b)不等于0,那么方程无解
 
```cpp
#include<bits/stdc++.h>

using namespace std;

inline long long read(){long long s=0,w=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();return s*w;}

long long xx,yy,t,AC = 0;

long long gcd(long long x,long long y){//求gcd
	if(y == 0) return x;
	return gcd(y,x % y);
}

void exgcd(long long a,long long b){//正宗exgcd
	if(b == 0){
		xx = 1;
		yy = 0;
		return ;
	}
	exgcd(b,a % b);
	t = xx;
	xx = yy;
	yy = t - a / b * yy;
}

int main()
{
	long long x = read(),y = read();
	long long m = read(),n = read();
	long long l = read();

	long long a = n - m,b = l,mm = x - y;
	if(a < 0){//我们让第一只青蛙开始再第二只后面,如果不是这样就调换位置(~~因为青蛙是一样的~~)
		mm = -mm;
		a = -a;
	}
	long long g = gcd(a,b);
	long long t = b / g;

	if(mm % g){//不是0则无解
		cout<<"Impossible"<<endl;
		return AC;
	}

	exgcd(a,b);
	long long ans = xx * (mm / g);//我以为答案就是这样

	cout<<(ans % t + t) % t<<endl;//至于%t+t%t也是看了其他大佬的题解才知道的,不过我并不知道为什么,(太弱了,雾)

	return AC;//返回AC保平安
}

```

---

## 作者：Manjusaka丶梦寒 (赞：2)

题意还是非常好理解的.....

假如这不是一道环形的跑道而是一条直线，你会怎样做呢？

如果是我就会列一个方程，像

$$x+m \times k = y+n \times k $$

求出方程解得k值。

然而这是一个环形跑道，也就有了取模的问题，然而我们只需要稍微改变一下方程

$$x + m \times k = y + n \times k + l \times z(z \in \mathbb{Z})$$ 

z表示被%掉了多少圈，我们试着两边转移一下

$$(x-y)+(m-n) \times k = l \times z$$

我们定义$a=(x-y),b=(m-n)$

$$a +b \times k= l \times z $$

$$ bk+lz=a $$

那么我们的任务就变成了解出这个二元一次方程了。

首先判断$ a是否整除gcd(b,l) $，不整除则无解，否则有解的话就可以用扩展欧几里得求得解。

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
#define LL long long 
LL xx,yy,n,m,x,y,a,b,l,r;
LL gcd(LL a,LL b)
{
    return !b?a:gcd(b,a%b);
}
LL exgcd(LL a,LL b,LL &x,LL &y)
{
    return !b?(x=1,y=0):(exgcd(b,a%b,y,x),y-=a/b*x);
}
int main()
{
    cin>>xx>>yy>>m>>n>>l;
    a=xx-yy;
    b=n-m;
    if(b<0)b=-b,a=-a;
    r=gcd(b,l);
    exgcd(b,l,x,y);
    //现在我们解出的是bx+lz=gcd(b,l)的解，输出答案是要扩大至a. 
    if(a%r!=0)printf("Impossible");
    else  cout<<((x*(a/r))%(l/r)+(l/r))%(l/r);
    //这个答案我研究了好久，最后才发现这个模数是因为组这么多步以后
	//他们两个都回到了起始点. 
//cout<<x*(a/r);
}
```

---

## 作者：luminouris (赞：1)

分析：
由题意易得出同余方程：
x + k*m ≡ y + k*n (mod L)；
化解方程得：
(n-m) * k ≡ x-y (mod L)；
转化为一般方程得：
(n-m)*k + L*s = x-y；
看成ax+by=c；
要求ax + by = c的整数解 x，首先，设d = gcd(a, b)，方程两边同时除以d得到a/d * x + b/d * y = c/d，由于a是整除d的，b也是整除d的，而x、y都是整数解，所以要求c/d也是整数。如果c不整除d，就输出Impossible。不然的话，如果我们能求出ax0+by0=d的解x0和y0，那么两边乘以c/d即a(c/d * x0) + b(c/d * y0) = c，就可以得到原来方程的解x = (c/d * x0)，y = (c/d * y0)。
代码如下：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long 
using namespace std;
ll ans,x1,y1;

ll exgcd(ll a,ll b,ll &x1, ll &y1)
{
    if(!b)
    {
        x1=1;
        y1=0;
        return a;
    }
    ans=exgcd(b,a%b,x1,y1);
    ll t=x1;
    x1=y1;
    y1=t-a/b*y1;
    return ans;
}

int main()
{
    ll n,m,x,y,l;
    cin>>x>>y>>m>>n>>l;
    ll b=n-m,a=x-y;
    if(b<0)
    {
        b=-b;
        a=-a;
    }//处理负数 
    exgcd(b,l,x1,y1);
    if(a%ans!=0)//判断方程有无解。 
        cout<<"Impossible";
    else
        cout<<((x1*(a/ans))%(l/ans)+(l/ans))%(l/ans);//处理负数 
}
```


---

## 作者：kevin006 (赞：1)

[传送门](https://www.luogu.org/problem/P1516)

# 前置知识
### 欧几里得算法

- 欧几里得算法是用来求两个数的最大公因数的一个算法，它的复杂度是 $O(log(a+b))$
- $ \forall a,b \in N,b \neq 0 $有$ gcd(a,b) =gcd(b,a \bmod b) $

证明如下：

若$ a<b ,gcd(b,a \bmod b)=gcd(b,a)=gcd(a,b)$,成立；

若$ a \geq b$

- 设$ a=q \times b+r(q,r \in N,0 \leq r<b) $
- 那么$ r = a \bmod b $。
- 对于所有的$a,b$的公因数$d$都有 $ d|a,d|q \times b $,所以$d|r$
- $a,b$的公因数集合与$b,a \bmod b$的公因数集合相等，成立

```cpp
int gcd(int x,int y)
{
	return b ? gcd(b,a%b) : a;
}
```

## 扩展欧几里得
### TA的用途是解ax+by==gcd(a,b)的一组特解

方法如下：
- 设$d=gcd(a,b)$
- $ax_{1}+by_{1}=d,bx_{2}+(a\bmod b)y_{2}=d$
- $bx_{2}+(a-  \lfloor\frac{a}{b}\rfloor\times b)y_{2}=d$
- $bx_{2}+ay_{2}-\lfloor\frac{a}{b}\rfloor \times by_{2}=d$
- $ay_{2}+b(x_{2}- \lfloor\frac{a}{b}\rfloor \times y_{2})=d$

- $x_{1}=y_{2},y_{1}=x_{2}- \lfloor\frac{a}{b}\rfloor \times y_{2}$

```cpp
int exgcd(int a,int b,int &x,int &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    int gcd=exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-a/b*y;
    return gcd;
}
```

### 它还可以用来求$ax+by=c$的通解
**（以下推导均极不严谨，仅供理解）**
- **当$c$是$d$的整数倍时**

我们先用扩欧求出$ax+by=d$的一组特解$a_{0},b_{0}$.

然后把左右两边同时乘上$\frac{c}{d}$
,得到$a_{0}\frac{c}{d}x+b_{0}\frac{c}{d}y=c$
,即目标方程的一组特解。

那么怎么求通解呢？？

其实，感觉一下，要求通解，两个未知数应该是此消彼长的关系,就是一个变大另一个变小啦.

不妨设$(\frac{c}{d}x+p)a_{0}+(\frac{c}{d}y-q)b_{0}=c(p,q\in Z)$

整理一下，$\frac{c}{d}xa_{0}+pa_{0}+\frac{c}{d}yb_{0}-qb_{0}=c$

即$pa_{0}=qb_{0}$

现在再拍出通解公式：$x=\frac{c}{d}x_{0}+k\times\frac{b}{d},y=\frac{c}{d}y_{0}+k\times\frac{a}{d}$,是不是好理解了一些？

其中$k$取遍整数，这也比较好理解，加一次成立，加两次三次自然也成立，同理,减同样成立。

- **当$c$不是$d$的整数倍时**

此方程无整数解.

## 接下来看题：

一句话题意:已知$ x+qm=y+qn(mod L) $,求$q$的最小正整数解

先变形：
- $x+qm-y-qn=pL$
- $(m-n)q-Lp=y-x$
- $(n-m)q+Lp=x-y$

这样就变成了$ax+by=c$的形式了呢

其中$a=n-m,b=L,c=x-y$

仍然求$q$的最小整数解.

根据通解公式，应该用特解的加上或减去$k\frac{b}{d}$,用取模实现，详见代码。

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    ll ans=exgcd(b,a%b,x,y);
    ll t=x;
    x=y;
    y=t-a/b*y;
    return ans;
}
int main()
{
    ll x,y,m,n,l;
    scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
    ll q0=0,p0=0,a=n-m,b=l,c=x-y;
    ll d=exgcd(a,b,q0,p0);
    //cout<<d<<" "<<q0<<" "<<p0<<endl;
    if(c%d!=0)puts("Impossible\n");
    else
    {
        ll q=c/d*q0%(b/d);
        if(q<=0)q+=abs(b/d);///防止出现负数
        printf("%d\n",q);
    }
}
```


---

## 作者：James_Brady (赞：1)

这是一个典型数论（~~本人认为数论难到炸~~）

废话不多说，进入正题

两只青蛙在一个环上,初始位置为x，y，速度为m，n，问多长时间后相遇

先把图放出来便于理解：

![](https://cdn.luogu.com.cn/upload/pic/61821.png)

设两只青蛙跳了x步，则红色就是A青蛙要追的路程，蓝色就是剩余路程

由图知两段相加等于整圈的整数倍

方程如下：

**(n-m) * x + y1 - x1 = l * y**

**(n-m) * x - l * y = x1 - y1**

就化成了ax+by=c的形式，x的值由exgcd求出，若无解则输出Impossible

具体细节看代码

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll n,m,t,l,x,y;
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    int ret=exgcd(b,a%b,x,y);
    int t=x;x=y;y=t-a/b*y;
    return ret;
}//扩欧模板
int main()
{
    ll x1,y1,c,d,a,b;
    scanf("%lld%lld%lld%lld%lld",&x1,&y1,&m,&n,&l);
    if(m==n)//如果速度相同则无法相遇（相对静止）
    t=1;
    else
    {
        a=n-m;
        b=l;
        d=x1-y1;
        if(a<0)//如果不这样做就会解出负数
        {
            a=-a;
            d=-d;
        }
        c=exgcd(a,b,x,y);
        if(d%c)
        t=1;//无解
    }
    if(t)
    printf("Impossible\n");
    else
    {
        b/=c,d/=c;
        printf("%lld\n",((x*d)%b+b)%b);
    }
    return 0;
}
```


---

## 作者：风随逐影 (赞：1)

# 简单数论

（我的第一道数论题）

------------
由题意知：
1. x+mt≡y+nt(mod L)
1. x+mt+kL=y+nt
1. (m-n)t+Lk=(y-x)

一定存在一组t,k,使(m-n)t+Lk==gcd(m-n,L)

拓展欧几里德定理求出一组t,k；

如果(y-x)%gcd(m-n,L)!=0,无解

否则t*=((y-x)/gcd(m-n,L))

通过a(x+b/d*t)+b(y-b/d*t)=c调整t，使t为最小正整数即可


------------

### 代码：
```c
#include<bits/stdc++.h>
using namespace std;
#define go(i,a,b) for(int i=(a);i<=(b);++(i))
#define com(i,a,b) for(int i=(a);i>=(b);--(i))
#define mem(a,b) memset((a),(b),sizeof(a))
#define inf 0x3f3f3f3f
#define fin freopen("input.txt","r",stdin)
#define fout freopen("output.txt","w",stdout)
typedef long long ll;

void exgcd(ll a,ll b,ll &x,ll& y,ll& d){
	if(b) exgcd(b,a%b,y,x,d),y-=a/b*x;
	else d=a,x=1,y=0;
}

void init(){
	ll x,y,m,n,l;
	scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
	ll d,t,k;
	if(m<n){
		swap(m,n),swap(x,y);
	}
	exgcd(m-n,l,t,k,d);
	if((y-x)%d){
		printf("Impossible");
	}
	else{
		t*=((y-x)/d);
		t=(t%(l/d)+(l/d))%(l/d);
		printf("%lld",t);
	}
	
}

int main()
{
	//fin;
	init();
	return 0;
}
```

---

## 作者：七条玲奈 (赞：1)

//扩展gcd真好玩！

因为题目给出的是一条首尾相接的数轴，所以我们可以把题目的问题转化成成：求解 x+m*k≡y+n*k(mod L)

来来来让我们化简这个式子！

k*(m-n)≡y-x(mod L)

再把mod L去掉行不行啊qwq

可以啊！

$$k*(m-n)+r*L=y-x$$

这个时候设**a=m-n,b=L,y-x=c**，则这个式子就满足了ax+by=c的形式，可以代入扩展欧几里得算法 [不会扩展gcd的同学建议先去百度学一下再来打qwq] 求得一组特解

但是求出特解后问题又来了 题目要求的是一组最小正整数解 可是我们求出的只是一组特解，并不保证它的正负性，怎么办呢？

我们要解决这个问题就要知道另外一个性质 ax+by=c 在求出一组特解之后 $x+k*a/gcd(a,b)$ 也会是原方程的一组解[自己稍微推一下应该是可以推出来的qwq]

本人蒟蒻qwq 推得如果有错请指出来qwq
下面上代码[写的巨丑QAQ]

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,mss,yss;
long long x,y,xx,yy,mm,nn,L;
void Exgcd(long long a,long long b)
{
	if (a%b==0)
	{
		x=0;
		y=1;
	   return;
	}
	Exgcd(b,a%b);
    long long r=x;
	x=y;
	y=r-(a/b)*y;
}
int main()
{
	scanf("%lld%lld%lld%lld%lld",&xx,&yy,&mm,&nn,&L);
	if (mm<nn) swap(mm,nn),swap(xx,yy);
	long long rr=mm-nn;
	long long qwq=yy-xx;
	long long nq=__gcd(rr,L);
	if (qwq%nq) 
	{
		cout<<"Impossible";
		return 0;
	}
	Exgcd(rr,L);
	long long ms=L/nq;
	cout<<((x*qwq/nq)%ms+ms)%ms;
	return 0;
} 
```

---

## 作者：ghmgjf (赞：1)

典型的exgcd题目。
设走k步，首先由题目可得
（mk+x）%l=（nk+y）%l；由同余公式可得
（mk+x）%l-（nk+y）%l=0；
（（mk+x）%l=（nk+y）%l）%l=0；
即mk-nk+x-y=ul【u为一整数】。
k（m-n）-ul=y-x。
把k看成x，n-m看成a，l看成b，u看成y即可求exgcd；
此题还要对最后结果去最小整数解，公式见代码：
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define xx 10010 
long l,x,y,m,n;
long xz,yz,r;
int exgcd(long a,long b)
{
	if(b==0)
	{
		xz=1;
		yz=0;
		return a;
	}
	r=exgcd(b,a%b);
	long u=xz;
	xz=yz;
	yz=u-(a/b)*yz;
	return r;
}
int main()
{
	cin>>x>>y>>m>>n>>l;
	long az=n-m,bz=l;
	long a=x-y;
	if(az<0)//负数处理。 
    {
        az=-az;
        a=-a;
    }
	exgcd(az,bz);
	if(a%r!=0) 
    cout<<"Impossible";
    else
    cout<<((xz*(a/r))%(l/r)+(l/r))%(l/r);
    //有特殊解得最小解的公式。 
	return 0;
}
```

---

## 作者：zclong (赞：1)

令A=x-y;B=n-m;

可得到abs(A+B\*y)%l=0;

即A+B\*y=x\*l;

化简的B\*y-x\*l=-A;

这不就是就是拓展欧几里得吗；

上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n,m,x,y,l,t;
ll b,a;
ll x1,y2,r,d;
int gcd(ll a,ll b,ll&x,ll&y)
{
    if(b==0)
    {
        x=1;y=0;
        return a;
    }
    d=gcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-(a/b)*y;
    return d;
}
int main()
{
    scanf("%lld%lld%lld%lld%lld",&x1,&y2,&m,&n,&l);
     a=(x1-y2);
    b=(n-m);
    if(b<0)
    {
        a=-a;
        b=-b;
    }
    r=gcd(b,l,x,y);
    if(a%r!=0)
        printf("Impossible");
    else
    printf("%lld",((x*a/r)%(l/r)+(l/r))%(l/r));
return 0;
}
```

---

## 作者：安好 (赞：1)

/\*
扩展欧几里得应用

(x+m\*t)-(y+n\*t)=p\*L (t是跳的次数，p是a,b的圈数差)

等价于:(n-m)\*t+L\*p=y-x;

令a=n-m;b=L;c=y-x;

等价于:a\*t+b\*p=c;

求t的最小整数解。


用扩展欧几里得求出其中一组解t0,p0,令g=gcd(a,b);

因为不定方程有解,所以a\*t/g  b\*t/g  d/g 为整数

方程两边都乘(c/g) 得到 a\*t0\*(c/g)+b\*p0\*(c/g)=c\*(c/g);

所以 t0\*(c/g)是最小解.但有可能是负数

因为 a\*(t0\*(c/g)+b\*k)+b\*(p0\*(c/g)-a\*k)=c\*(c/g);其中k是自然数

所以解为 (t0\*(c/g)%b+b)%b;

\*/





```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long a,b,c,m,n,l,x,y,g;
void ex_gcd(long long a,long long b)//求出一组解t0,p0 
{
    if(b==0)
    {
        x=1;y=0;g=a;
        return;
    }
    ex_gcd(b,a%b);
    long long tmp=x;x=y;y=tmp-a/b*y;
}
int main()
{
    scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
    a=m-n;b=l;c=y-x;
    if(a<0){a=-a;c=-c;}
    ex_gcd(a,b);
    if(c%g){printf("Impossible\n");return 0;}//无解 
    else//有解 
    {
        x=x*c/g;l=l/g;
        x=(x%l+l)%l;//处理x可能为负 
        printf("%d\n",x);
    }
    return 0;
}
```

---

## 作者：飞翔 (赞：1)

一开始的建模部分。很容易写出下面的等式:

(x + a\*m) mod L = (y + b\*n) mod L 

利用线性同余进一步化成如下形式:

a\*x = b (mod n)   

其中 a = (n - m)

        b = (x - y)   

        n = L 

首先判断此线性同余方程是否有解，有解的话，给出最小正数解。

这个线性方程有解，当且仅当gcd(a, n)能整除b。而求gcd，当然就是递归的。

若求gcd(a, b),假设a < b, 那么一定可以写成:

b = a\*q + r 

其中q是商，r是余数。假设d = gcd(a, b); 那么显然d能整除b和a，所以d也能整除上式的r。由于r 一定小于a

所以，我们只要求 gcd(r, a)。于是问题的规模就递归化简了。再想想边界条件，显然是 a | b。这时r为0.

```cpp
var
  x,y,l,m,n:int64;
function exgcd(a,b:int64;var x,y:int64):int64;
begin
  if b=0 then begin x:=1;y:=0;exit(a); end;
  exgcd:=exgcd(b,a mod b,y,x);
  y:=y-(a div b)*x;
end;
procedure work(a,b,m:int64);
var
  n,x,y:int64;
begin
  n:=exgcd(a,b,x,y);
  if m mod n<>0 then begin
        write('Impossible');
        halt;
    end;
  m:=m div n;
  b:=abs(b div n);
  x:=x*m;
  x:=(x mod b+b) mod b;
  writeln(x);
end;
begin
  readln(x,y,m,n,l);
  if m=n then begin
        write('Impossible');
        halt;
    end;
  work(m-n,l,y-x);
end.
```

---

## 作者：ShuYuMo (赞：1)

# 青蛙的约会
## 原题

> [原题](https://www.luogu.org/problemnew/show/P1516)

今得青蛙两只，其一名为$A$， 另一名为$B$。

青蛙$A$从$x$开始跳，每次跳$m$米， 青蛙$B$从$y$开始跳，每次跳$n$米，两青蛙同时开始往同一方向跳，问跳几次可以跳到同一位置。（地球是圆得，周长是$L$）

如果不能跳到同一位置，就输出`Impossible`

## 分析

设一起跳$K$次能跳到同一位置。

> $$x + mK \equiv y + nK \pmod L$$

移向得到

> $$\left ( x - y \right ) + \left ( m - n \right )K \equiv 0 \pmod L$$

转换为欧几里得方程得到

> $$\left ( x - y\right ) + (m - n)K + K'L = 0$$

移向得到

> $$(m - n)K + K'L = \left ( y - x\right )$$

$(m - n)$、$(y - x)$和$L$已经知道，拓展欧几里得求出一组$K$和$K'$即可

然后将$K$调整到最小正整数解。

关于不定方程从一组解得到其他解得过程：

设
> $$d = gcd(a,b)$$

> $$ d = ax + by = a(x + \frac{b}{d} \times t) + b(y - \frac{a}{d} \times t) ,t \in \mathbb{Z} $$

通过确定调整 $t$，即可调整一解到最小正整数解。

## 源代码
```cpp
/*!
 * FileName: luogu-1516.cpp
 * This Problem is on luogu. The ID of the problem is 1516. 
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define inf 0x7fffffff
#define LL long long
using namespace std;
const int _ = 233;
inline LL read()
{
    char c = getchar(); LL sign = 1; LL x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } 
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
void exgcd(LL a, LL b, LL &x, LL &y, LL &g)
{
    if(b == 0)
    { g = a; x = 1;y = 0; }
    else
    {exgcd(b, a%b, x, y, g);  int X = x; x = y; y = X - (a / b) * y;}
}
int main()
{
    LL x = read(), y = read(), m = read(), n = read(), L = read(), d, tx, ty;
//	exgcd(//, y, tx, ty, d);
//	cout<<tx<< ' '<< ty<<' '<<d<<endl; 
    if(n > m)
        swap(x, y), swap(m, n);
    exgcd(m - n, L, tx, ty, d);
    int k = (y - x) % d;
    if(k != 0)
        puts("Impossible");
    else
    {
        tx = (y - x) / d * tx;//调整方程`c`至gcd(a, b)
        printf("%lld", (tx % (L / d) + (L / d)) % (L / d));
    }
    return 0;
}
```

## tips
 - 拓展欧几里得需要使a和b为正数，若 n > m 时，交换两青蛙的信息。
 - 对于调整到最小正整数解，例如得到一个解$K$，通过乘 $t$ 倍的 $\frac{a}{d}$ 得到最小正整数解。只需要
 $$K = ((K mod \frac{a}{d} )+ \frac{a}{d})mod\frac{a}{d}$$
 
 注意 $long long$。

---

## 作者：Edward_Elric (赞：0)

## 推导
根据题意不难得出这样子的同余方程

$$x+mx_0≡y+nx_0\ (mod\ l)$$

然后就是个套路题。

对于$x≡y(mod\ m)$,当且仅当$x=km+y$

然后我们可以列出这样的方程

$$x+mx_0=y_0L+y+nx_0$$

化为一般形式

$$(m-n)x_0+ly_0=y-x$$

剩下的就是个$exgcd$

## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y,m,n,l;
ll x_,y_,d;
void exgcd(ll a,ll b,ll &x,ll &y){
	if(!b){
		x=1,y=0;d=a;return;
    }
	exgcd(b,a%b,y,x);
   	y-=a/b*x;
}
int main(){
	scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l);
	ll a=m-n,b=y-x;
	if(a<0)a=-a,b=-b;
	exgcd(a,l,x_,y_);
	if(b%d){
		puts("Impossible");
		exit(0);
    }
	else printf("%lld\n",(x_*b/d%(l/d)+(l/d))%(l/d));
	return 0;
}
```

---

## 作者：wyhwyh (赞：0)

一看这道题就是同余。然后就开始推方程qwq

$$x+mk\equiv y+nk\pmod L$$

$$x+mk-(y+nk)=Lz$$

$$(m-n)k+Lz=y-x$$

因为$m-n$、$L$、$y-x$都是已知的，所以这就是一个扩欧的模型。

扩欧就不说了，可以看[这篇](https://www.luogu.org/blog/wyhwyh/shu-lun)文章

总体来说，如果你看懂了扩欧，这倒题应该不难，不过细节蛮多的。

1. 不能乱用abs()，考虑好再用。

2. 千万不要变量重名，这导致了我20min的题做了2h。

3. 注意取模时的判负，这是（我认为的）难点

4. 开long long ! 开long long ! 开long long !

……应该就这些了。

**Code**

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;

typedef long long ll;

ll x_0,y_0,m,n,L;
ll g,x,y,ans;
ll a,b,c,mod;

inline void readx(ll &x)
{
	x=0;
	int s=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			s=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=s;
}

inline ll gcd(ll a,ll b)
{
	if(b==0) return a;
	return gcd(b,a%b);
}

inline void exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) {x=1;y=0;return;}
	exgcd(b,a%b,y,x);
	y-=a/b*x;
}

int main()
{
	readx(x_0);readx(y_0);
	readx(m);readx(n);readx(L);
	a=m-n,b=L,c=y_0-x_0;
	g=gcd(a,b);
	mod=abs(L/g);
	if(c%g)
	{
		printf("Impossible\n");
		return 0;
	}
	exgcd(a,b,x,y);
	ans=(x*(c/g)%mod+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：Tony_Wong (赞：0)

题目传送门: [「Luogu P1516」青蛙的约会](https://www.luogu.org/problemnew/show/P1516)

### 题目大意
(规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴)
现有两只青蛙$A,B$
设青蛙$A$的出发点坐标是$x$，青蛙$B$的出发点坐标是$y$
青蛙$A$一次能跳$m$米，青蛙$B$一次能跳$n$米，两只青蛙跳一次所花费的时间相同
纬度线总长$l$米
求两只青蛙跳了几次以后才会碰面

### 题解
__*同余方程*__ 模板题
求解$x + km\equiv y + kn \pmod l$

$Solve:$

$x+km-(y+kn)=lz, z\in Z$

$(x-y)+k(m-n)-lz=0$

$k(n-m)+lz=(x-y)$

令$a=x-y,b=n-m$

上式可化为:
$$
kb+lz=a
$$
求这个方程的最小整数解
化为求此不定方程最小整数解
$$k'b+lz'=gcd(b,l)$$
使用扩展欧几里得算法可得一组特解$(k',b')$
最小解为$k_{min} = k'\bmod \frac{l}{gcd(b,l)}$
以上解$k_{min}$的方程右边是$gcd(b,l)$而不是$a$
所以结果为
$$\boxed{ (k'\times \frac{a}{gcd(b,l)})\bmod \frac{l}{gcd(b,l)} }$$

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

void exgcd(LL a, LL b, LL& d, LL& x, LL& y) {
    if (!b) { d = a; x = 1; y = 0; }
    else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }
}

int main() {
    LL n, m, x, y, l, gcd, x1, y1;
    scanf("%lld %lld %lld %lld %lld", &x, &y, &m, &n, &l);
    LL b = n - m, a = x - y;
    if (b < 0) { b = -b, a = -a; }
    exgcd(b, l, gcd, x1, y1);
    if (a % gcd) {
        printf("Impossible\n");
    } else {
        LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd);
        printf("%lld\n", ans);
    }
    return 0;
}
/* 26ms 916kB */
```

---

## 作者：white_Norton (赞：0)

这是我发的第二篇题 解，其实这题很~~简单~~
exgcd函数用的是我~~自己~~老师写的模板
然后主函数用的是不定式思想，我记得有大佬已经写了，我就不多BB了


------------

内心os：~~装逼的机会没了 嘤嘤嘤~~


------------
代码如下（AC版本）
```cpp
#include<bits/stdc+.h>//通用头文件，避免复制粘贴，我动了点手脚
#define ll long long
using namespace std;
int exgcd(ll a,ll b,ll&x,ll&y){
	if(b==0){
		x=1;
		y=0;
		return a;
	}
	int g=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return g;
}
int main(){
	ll x,y,m,n,l;
	cin>>x>>y>>m>>n>>l;
	ll b=n-m,a=x-y;
	if(b<0){
		b=-b;
		a=-a;
	}
	int g=exgcd(b,l,x,y);
	if(a%g!=0){
		cout<<"Impossible";
	}
	else
        cout<<((x*(a/g))%(l/g)+(l/g))%(l/g);
    return 0;
}


```


---


# 瑞瑞的木棍

## 题目描述

瑞瑞有一堆的玩具木棍，每根木棍的两端分别被染上了某种颜色，现在他突然有了一个想法，想要把这些木棍连在一起拼成一条线，并且使得木棍与木棍相接触的两端颜色都是相同的，给出每根木棍两端的颜色，请问是否存在满足要求的排列方式。

例如，如果只有 $2$ 根木棍，第一根两端的颜色分别为 `red` 和 `blue`，第二根两端的颜色分别为 `red` 和 `yellow`，那么 `blue --- red | red --- yellow` 便是一种满足要求的排列方式。

## 样例 #1

### 输入

```
blue red
red violet
cyan blue
blue magenta
magenta cyan
```

### 输出

```
Possible
```

# 题解

## 作者：热言热语 (赞：25)


主要的算法是欧拉路。

题目要求每条木棍都用过，同颜色的两端可以相接，~~如果没有字符串处理，几乎是一道欧拉路的模板题~~

把每种颜色看做一个点，木棍看做连接两种颜色的无向边，整个问题就转化成了求这个图是否存在欧拉路。

对于点的编号，可以采用字典树或者用STL里的unordered\_map（map会超时）。**重要：建议不选STL,非常慢……**

接下来就是欧拉路的判定。

首先图**必须是联通的**。楼下给出了用dfs的方法，这里给出用并查集的方法。

对于所有的点建立一个并查集。对于每条边，尝试把它两端的点合并，并记录有效合并（即合并前两个点不在同一组中）的次数。

设点（注意不是边）的数量为N，有效合并次数为M，则当且仅当M==N-1时图是联通的。下面给出简单说明：

如果图是联通图，并查集就只有一个组。而初始有N个组，每次有效合并会减少一个组，最后只剩一个组，所以有效合并次数M=N-1。

其次（也是最后），图中奇数度数的点的个数必须为0（最后回到出发点）或2（一个点出发，另一个点结束）。对此，输入时记录每个点度数，最后全部扫一遍即可。

## 代码

**核心部分代码如下：**

```cpp
#include <stdio.h>
#define N 500010//题目中说最多有250000条边，也就是最多有500000个点
int n=0,deg[N];char s[15];//n:点数（颜色数）,deg:每个点度数
/*求编号部分(getid)*/
//...
/*并查集*/
int fa[N];
inline int find(int a) {
    return fa[a]?fa[a]=find(fa[a]):a;
}
inline bool join(int a,int b) {//有效合并返回true,无效返回false 
    int x=find(a),y=find(b);
    if(x==y) return false;
    fa[x]=y;return true;
}
/********************/
inline bool check() {
    int x,y,cnt=0;
    while(~scanf("%s",s)) {
        x=getid(s);
        scanf("%s",s);
        y=getid(s);//getid求编号 
        if(join(x,y)) ++cnt;//记录有效合并次数 
        ++deg[x];++deg[y];//统计度数 
    }
    if(cnt<n-1) return false;//判联通:只有当cnt==n-1时是联通的 
    cnt=0;//记录奇数度点的个数
    for(int i=1;i<=n;++i) if((deg[i]&1)&&++cnt>2) return false;//扫一遍颜色的度,奇数度点个数>2就退出 
    return true;
}
int main() {
    puts(check()?"Possible":"Impossible");
    return 0;
}
```
**求编号的部分(两种做法)：**

```cpp
/*1.Trie/字典树*/
int nd=1,root=1;struct node{int son[26],num;}t[1000010];
int getid(const char *s) {
    int k=root;char c;
    for(int i=0;s[i];++i) {
        c=s[i]-'a';
        if(!t[k].son[c]) t[k].son[c]=++nd;//动态开点
        k=t[k].son[c];
    }
    if(!t[k].num) t[k].num=++n;
    return t[k].num;
}
/*2.unordered_map*/
#include <string>
#include <unordered_map>
using namespace std;
unordered_map<string,int> M;
int getid(const char *s) {
    return M[s]?M[s]:M[s]=++n;
}
```

---

## 作者：Minclxc (赞：18)

hash大法好，程序很短，就是速度比字典树慢。
思路和楼下一样，欧拉路，判断奇入度点个数和块数，奇入度点小于3块数小于2为欧拉路
```cpp
#include<cstdio>
#include<cstring>
#include<iostream> 
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int seed=10086,mo=1e6+7;
int a[mo],fa[mo];
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int hash(string s){
	int ha=0;
	fo(i,0,s.size()-1)ha=(1ll*ha*seed+s[i])%mo;
	return ha;
}//hash
int main(){
    int cnt=0,fct=0,sum=0;
    for(string s[2];cin>>s[0]>>s[1];){
    	int b[2];
    	fo(j,0,1){
    		if(!a[b[j]=hash(s[j])]++)fa[b[j]]=b[j],fct++;//如果是新的颜色，并查集赋初值，块数+1
			if(a[b[j]]&1)sum++;else sum--;//调整奇入度点
		}
		if(find(b[0])!=find(b[1]))
		    fa[fa[b[0]]]=fa[b[1]],fct--;//合并
	}
	cout<<((fct<2&&sum<3)?"P":"Imp")<<"ossible";
    return 0;
}
```

---

## 作者：Vanilla_chan (赞：15)

## 说在前面

用M↓写的第一篇题解，欢迎提出意见

## 分析

一根木棒就相当于一条边，木棒两边的颜色就是这条边所连的点

那么，这道题就是问一张图是否存在欧拉路

欧拉路的判定很简单——所有点都连通（并查集），最多两个点的度为奇数（一个数组就可以搞定）

那么这道题之所以是蓝题，是因为它对时间要求很严格——最多2.5e6个木棒

以及读入的字符串的处理

### 字符串的处理

这里最最最快的方式是用$trie$

$trie$中每个节点都有两个元素，$num$标记和$26$个指针

**这里我们用数组模拟指针**

1. 设$0$是根节点，实际上不代表任何的字母
2. 对于要加入的每一个字符串，逐位考虑
3. 如果当前节点没有$str[i]$这个子节点的话就新建一个节点为子节点
4. 跳转到这个子节点，判断下一位
5. 重复3、4步骤
6. 如果最终的节点没有被分配一个编号的话，那么这个就新建一个编号给这个终节点

这样每一个字符串都有了唯一的编号，且编号是连续的，方便开数组等后续操作

这就完成了trie的部分——字符串到正整数的映射

```cpp
struct Trie
{
	int son[26],num;
}trie[2000010];
int n,trie_cnt;
int insert(string str)
{
	int now=0;
	for(int i=0;i<str.size();i++)
	{
		if(!trie[now].son[str[i]-'a']) trie[now].son[str[i]-'a']=++trie_cnt;
		now=trie[now].son[str[i]-'a'];
	}
	if(!trie[now].num) trie[now].num=++n;
	return trie[now].num;
}
```
可能有人会问为什么不用$map$？

>因为$map$每次插入是$logn$的，而$trie$每次插入与字符串的长度有关（看作$O(1)$就好），题目也说了每个单词不超过$10$个字母
>
>当然也可以用$unordered_map$（需要C++11!），不会$STL$的同学可以用$hash$(这个还是有点慢)
>
>所以这里最优的就是$trie$啦！

### 判断欧拉路

欧拉路有个经典的故事——**七桥问题**，相信你应该耳熟能详了

即：经过每条边正好一次，能不能把所有边都走一遍？

可以证明，只要整个图是**连通**的，且有**奇数度的点不超过两个**，那么就存在欧拉路！

度的统计只需要在读入木棒的时候标记一下

判断连通图用**并查集**

#### 读入

```cpp
while(cin>>str)
{
	x=insert(str);
	cin>>str;
	y=insert(str);
	merge(x,y);
	degree[x]++;
	degree[y]++;
}
```
#### 判断

判断这里我用了点小技巧，同时判断度和并查集
* 如果有相邻的两项的祖先是不同的，那么这肯定不是连通图，给flag加上一个大数字
* 如果这点的度是奇数，那么flag+1就好
* 最后判断flag，大于2说明奇度点多了或者图不连通，即不可能有欧拉路，反之则存在
```cpp
int flag=(degree[1]&1);
for(int i=2;i<=n;i++)
{
	if(getf(i)!=getf(i-1)) flag+=10;
	if(degree[i]&1) flag++;
}
if(flag>2) cout<<"Impossible"<<endl;
else cout<<"Possible"<<endl;
```
## Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<map>
#include<queue>
#include<vector>
#define IL inline
#define re register
#define LL long long
#define ULL unsigned long long
#define re register
#define debug printf("Now is %d\n",__LINE__);
using namespace std;

template<class T>inline void read(T&x)
{
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    x=ch-'0';ch=getchar();
    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
}
inline int read()
{
	int x=0;
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    x=ch-'0';ch=getchar();
    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
    return x;
}
int G[55];
template<class T>inline void write(T x)
{
    int g=0;
    if(x<0) x=-x,putchar('-');
    do{G[++g]=x%10;x/=10;}while(x);
    for(re int i=g;i>=1;--i)putchar('0'+G[i]);putchar('\n');
}



struct Trie
{
	int son[26],num;
}trie[2000010];
int n,trie_cnt;
int insert(string str)
{
	int now=0;
	for(int i=0;i<str.size();i++)
	{
		if(!trie[now].son[str[i]-'a']) trie[now].son[str[i]-'a']=++trie_cnt;
		now=trie[now].son[str[i]-'a'];
	}
	if(!trie[now].num) trie[now].num=++n;
	return trie[now].num;
}
int f[500010];
int getf(int x)
{
	while(x!=f[x]) x=f[x];
	return x;
}
void merge(int x,int y)
{
	x=getf(x);
	y=getf(y);
	f[x]=y;
}
int degree[500010];
int main()
{
	string str;
	int x,y;
	for(int i=1;i<=500000;i++) f[i]=i;
	while(cin>>str)
	{
		x=insert(str);
		cin>>str;
		y=insert(str);
		merge(x,y);
		degree[x]++;
		degree[y]++;
	}
	int flag=(degree[1]&1);
	for(int i=2;i<=n;i++)
	{
		if(getf(i)!=getf(i-1)) flag+=10;
		if(degree[i]&1) flag++;
	}
	if(flag>2) cout<<"Impossible"<<endl;
	else cout<<"Possible"<<endl;
	return 0;
}
```
## 疑惑

如果出现，有两根相同的木棒怎么办？题目中并没有否认这种情况，但是不这样判断的话也过了啊……奇怪

如果以后这道题修改或者加强了，请来踢我一脚（

---

## 作者：封禁用户 (赞：7)

考的是hash函数。这里我们不去构造hash函数。而用字典树的方法来实现hash。即将单词这样的字符串转换为int类型。便于我们用下标访问。然后用木棍的信息建立一张图。即一根木棍就是一条边。然后需要连接起来。它的条件就是。这整张图为欧拉图。也就是一笔画。然后判断的方法是。

1.图是联通的。

2.统计所有的点的出度。如果出度全部为偶数或者恰好只有两个点为奇数。则可以一笔画。则能够把所有的木棍都连接起来。

//联通的话用并查集也可以。用dfs从任意一个点进行搜索然后看下能不能走到所有的点。也可以。但是推荐用dfs，因为可以一边统计出度信息。

然后如果不想打字典树。还有一种方法。就是把边的信息记录下来(记录的时候，两个字符串进行一下比较，小的放前面)。然后对边的信息进行排序。以边的左端点作为关键字排序。然后左端点相同的边就会紧邻在一起。我们把字符串编号一下就可以，然后还是一样建图即可。。

```cpp
#include <cstdio>  
#include <cstring>  
  
struct tree//用字典树的方法来获取某个单词的hash值。  
{  
    int hash;  
    int next[27];  
};  
  
int tot = 0, ne[500001], first[500001], en[500001], totm = 0, chudu[500001] = { 0 },temp_tot,tot_v=1;  
//用邻接表来存储图的信息。  
bool visited[500001] = { 0 };  
tree a[800001]; //用数组来模拟链表。  
  
int sear_ch(char s[50])//用字典树。来获取s这个字符串对应的hash值。  
{  
    int l = strlen(s);//获取字符串的长度。  
    int p = 1;//从根节点开始往下走  
    for (int i = 1; i <= l; i++)  
    {  
        int x = s[i - 1] - 'a' + 1;//把小写字母和数字1..26对应  
        if (a[p].next[x] == 0)//如果这个节点不存在。则新建一个节点、  
        {  
            tot_v++;  
            a[p].next[x] = tot_v;  
        }  
        p = a[p].next[x];//一直往下走。  
    }  
    if (a[p].hash == 0)//如果这条路径(这个字符串)之前没人走过，则给其一个新的hash值  
        a[p].hash = ++tot;  
    return a[p].hash;//然后直接返回这个值就可以了。。  
}  
  
void add(int x, int y)//加一条从x指向y的边  
{  
    totm++;  
    ne[totm] = first[x];//邻接表用的是链式存储的方式。  
    first[x] = totm;  
    en[totm] = y;  
}  
  
void dfs(int now)//这个程序会从最后一个点开始进行dfs看一下能不能走遍所有的点。  
{  
    temp_tot--;//找到了一个点，点的数目就减少。最后看temp_tot是否为0  
    visited[now] = true;  
    int temp = first[now];  
    while (temp != 0)//用邻接表来获取这个点的出度。  
    {  
        chudu[now]++;//顺便记录出度  
        int y = en[temp];  
        if (!visited[y])//如果没有访问过就访问。  
            dfs(y);  
        temp = ne[temp];//寻找下一个出度  
    }  
}  
  
int main()  
{  
    char s1[50], s2[50];  
    while (scanf("%s%s", s1, s2) != -1)//多行输入  
    {  
        int x, y;  
        x = sear_ch(s1);  
        y = sear_ch(s2);  
        add(x, y);  
        add(y, x);  
    }  
    temp_tot = tot;//用来递减的temp  
    if (tot>0) //如果什么都没输入也算是可以的。  
        dfs(tot);  
    if (temp_tot != 0)//如果图是不连通的则不能一笔画  
    {  
        printf("Impossible");  
        return 0;  
    }  
    int oushu = 0, jishu = 0;//统计奇数的出度和偶数的出度的个数。  
    for (int i = 1; i <= tot; i++)  
        if ((chudu[i] % 2) == 0)//其实只要统计奇数的出度的个数就可以了。  
            oushu++;  
        else  
            jishu++;  
    if (jishu == 0 || jishu == 2)//可以看到只要统计奇数的出度个数就可以。。  
        printf("Possible");  
    else  
        printf("Impossible");  
    return 0;  
}  
```

---

## 作者：Great_Influence (赞：7)

题目具体解法是欧拉路，我想没什么好说了。并且题目并没有要你求具体方案，所以难度更低了，只需要记录一下每个点度的奇偶，判断度为奇数的点是否超过2就可以了。

然而这样打只有80分，因为有2个点的情况木棍之间并不连通，连不起来。所以需要并查集来判断连通。

然而这样打的话只有90分，因为map+并查集时间复杂度会爆一个点。所以考虑优化。

可以发现，map使用RBT结构，时间复杂度为O(nlogn)，占去了大部分时间复杂度。所以考虑更快的方法。

这时候就是pb\_ds库登场的时候了。在pb\_ds中的hash\_table使用哈希的方法，时间复杂度仅为O(n)，可以快速调用。

然后就没有然后了。

代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>//pb_ds库
#include<cctype>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
using namespace __gnu_pbds;//命名空间
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("P1333.in","r",stdin);
    freopen("P1333.out","w",stdout);
    #endif
}
const int MAXN=250050;
char l[15],r[15];
int e,f[MAXN];
bool in[MAXN];
gp_hash_table<string,int>G;//hash_table定义
int find(int x)
{
    int t=f[x],d;while(t!=f[t])t=f[t];
    while(f[x]!=t){d=f[x];f[x]=t;x=d;}
    return t;
}
void work()
{
    while(scanf("%s%s",l,r)!=EOF)
    {
        if(!G[l])G[l]=++e,f[e]=e;
        if(!G[r])G[r]=++e,f[e]=e;
        if(e>250010)//如果点数超过n+1的话，一定不存在通路，直接返回。
        {
            printf("Impossible\n");
            return;
        }
        in[G[l]]^=1;//修改奇偶情况
        in[G[r]]^=1;
        f[find(G[l])]=find(G[r]);//合并并查集
    }
    int flag=0;
    int i;
    For(i,1,e)if(in[i])//判断奇点个数是否超过2
    {
        if(flag==2)
        {
            printf("Impossible\n");
            return;
        }
        else ++flag;
    }
    int father=find(1);
    For(i,2,e)if(find(i)^father)//判断是否连通
    {
        printf("Impossible\n");
        return;
    }
    printf("Possible\n");
}
int main(void){
    file();
    work();
    return 0;
}
```

---

## 作者：Na2PtCl6 (赞：4)

次优解来发一篇题解 （orz [Terrible](https://www.luogu.com.cn/user/195942)
## 分析题目
### 对字符串的处理
我看题解里哈希的 $base$ 好像都是随便选一个数的，其实对于这题是有技巧的。

考虑到字符串 **都是小写** 字母，我们可以基于 $26$ 进制对字符串进行哈希，设哈希值为 $x$，每读入一个字符 $c$ ，就把 $x$ 赋值为 $(x \times 26 + c - 97)$（$97$ 是字符 $a$ 的 ASCII 码），这样就保证了 $x$ 是唯一的，可以避免一些冲突。

由于 $x$ 可能会达到 $26^{10}$，所以要对它不断取模。

哈希常数较小，而且 **可以结合快读边读边哈希** ，所以时间复杂度优于字典树。

### 欧拉路
#### 定义

先把样例的图放在这里（颜色用单词首字母表示,虚线暂时不管）：

![](https://cdn.luogu.com.cn/upload/image_hosting/me5wc8di.png)

> 欧拉路是指联通图（无向图或有向图亦可）中所有边且每边仅通过一次通路。

用人话来讲就是，这个图可以被你沿着边一笔画成，并不重不漏地经过所有边。

我对欧拉路感性的认识是一条 **会变形的链**，某些节点被粘在一起了。 

#### 结论1

> 遍历欧拉图中的每一条边，并合并两个点所在的集合，**合并次数大于等于颜色总数** $-1$

证明：

\* 以下“同色环”意义为所有节点颜色相同的环

对于没有同色环的图，我们要走到图中的每一个点以及每一条边，并要保证不重不漏。我们走过的任意两个点有一条边连接，所有的点又是联通的，自然就会有 $color-1$ 次的合并；

对于有同色环的图，可能会有一些同色的节点被多次合并，所以会有 $>color-1$ 次的合并

综上所述：合并次数 $\ge color-1$

#### 结论2
> 欧拉图度数为奇数的点数量 $<2$ 

还是放上样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/me5wc8di.png)

证明：

我们说欧拉路是一个会变形的链，那么其起点和终点的度 **可能** 为奇数；当图是环时，则没有出度为奇数的点。

我们发现，加上这条虚线后，入度为奇数的点超过了 $2$，我们在走完有点却无法遍历所有的边，原因是这条边 **破坏了“会变形的链”的形态** 。

### 解法
先哈希字符串，得到其编号。

我们用并查集维护点。根据哈希值判断这是否是新颜色，如果是总颜色数加一，并更新这个哈希值对应的颜色；否则沿用原来的颜色。接着判断颜色是否相等，如果是就合并，合并次数加一；否则不管。

然后统计度数为奇数的点的数量，发现数量大于 $2$ 就可以结束程序了。

最后，判断合并次数是否比 $color-1$ 小即可。



## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
//因为木棍有两头,所以最多会有 250000*2 个节点 
const int maxn=500004,mod=1000007;
char c,str1[24],str2[24];
int n,mer,odd,col1,col2,deg[maxn],f[maxn],id[mod];

//得出字符串对应的颜色,返回值是输入是否结束 
bool getnum(int &num){   
	c=getchar();int ret=0;
	if(~c)  //读到EOF就说明输入结束 
		return 0;
	for(;c<'a'||c>'z';c=getchar());
	for(;c>='a'&&c<='z';c=getchar())
		ret=(ret*26+c-'a')%mod;
	num=!id[ret]?id[ret]=++n:id[ret];  //判断是第几种颜色 
	return 1;
}

int find(const int &k){ return f[k]==k?k:f[k]=find(f[k]);}

inline bool link(const int &a,const int &b){
	int c=find(a),d=find(b);
	f[c]=d;
	return c!=d;
}

int main(){
	register int i;
	for(i=1;i<maxn;i++)
		f[i]=i;
	while(getnum(col1)&&getnum(col2)){
		//如果把不在同一个连通块里的点连接了,合并次数加一 
		if(link(col1,col2))
			++mer;
		++deg[col1],++deg[col2];
	} 
	for(i=1;i<=n;i++){
		if(deg[i]&1)
			++odd;
		if(odd>2){
			puts("Impossible");
			return 0;
		}
	}
	puts(mer<n-1?"Impossible":"Possible");
	return 0;
}
```

---

## 作者：wshz (赞：3)

/*这是该题的并查集写法，好理解有兴趣来看看；
首先这题是一个欧拉路，但是仅仅判断是不是欧拉路只有70分想拿满分需要判断其中的每一根是不是都相连，这就可以用并查集了，具体看代码。；
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,q,p,z,cnt,t;
string d[500000],qq[250000][2];
char a[11],b[11];
unordered_map<string,int>c,l;/*听说unordered_map
比map快*/
unordered_map<string,string>f;
string find(string x)//并查集模板；
{
    if(f[x]!=x)	f[x]=find(f[x]);/*找一种颜色的父亲
    节点；*/
    return f[x];
}
int main()
{
    while(scanf("%s%s",a,b)!=EOF)
    {
        qq[++t][0]=a;
        qq[t][1]=b;
       	c[a]++;//计算a的入度；
       	c[b]++;//同上；
       	if(!l[a])
       	{
       		d[++w]=a;//计不相同的点；
            l[a]=1;//标记；
        }
        if(!l[b])
       	{
            d[++w]=b;//同上；
            l[b]=1;
        }
    }
    for(int i=1;i<=w;i++)
    f[d[i]]=d[i];//并查集预处理；
    for(int i=1;i<=t;i++)
    {
        string x1=find(qq[i][0]),x2=find(qq[i][1]);
        if(x1!=x2)
        {
            f[x1]=x2;
        }
    }
    for(int i=1;i<=w;i++)//判断是否在一个集合中；
    {
        if(f[d[i]]==d[i])
        cnt++;
    }
    if(cnt>1)//如果集合大于1个说明不能连起来；
    {
        cout<<"Impossible";
        return 0;
    }
    for(int i=1;i<=w;i++)//判断是否为欧拉路；
    {
        if(c[d[i]]%2!=0)//判断该种颜色入度是否为奇数；
        p++;
    }
    if(p==0||p==2)//如果奇点个数为2或0说明构成了欧拉路
    {
        cout<<"Possible";
        return 0;
    }
    cout<<"Impossible";
    return 0;
}
```

---

## 作者：ipLee (赞：3)

# 一种错误的思路

首先这题肯定要将字符串hash成int，下面讲的时候会直接用int而不是字符串

这题我一开始想的思路是这样的：记录每个输入和编号，比如
```c++
2 3
3 4
3 5
```
就当成第一个结点有两条分别为2和3的边，之后输入完后对拥有同一个编号的点连边，比如这里就是第一个点和第二、三个点有一条边连接，第二、三个点同理。这样的话最后只要对图跑一条“每个点只走一次”的路就行

然后我就去翻《离散数学及其应用》（~~ACM选手无所谓开卷闭卷~~），然后发现每个点只走一次的路叫做哈密顿回路/通路，以及：

**判断一个图是否存在哈密顿回路/通路是NPC的！**

得，想别的方法吧


# 正解

## 基本思路

我们把每个颜色都当成一个结点（可以想到这肯定要用到hash），每组颜色自然都是一条边，于是我们就有了一张图，在这张图上判断欧拉通路就行

另外判断欧拉图的时候是不需要考虑自环的，也就是输入相同的颜色并没有影响

## 判断欧拉图的方法：

*（当且仅当是充要条件别忘了）*

下面的图都是允许自环、重边的

* 对于无向图$\rm G$，$\rm G$是欧拉图当且仅当$\rm G$**是连通的**且没有奇度顶点

  有奇度定点就意味着“一去不返”了，这很好理解

* 对于无向图$\rm G$，$\rm G$是半欧拉图当且仅当$\rm G$**是连通的**且$\rm G$中恰有$\rm 0$个或$\rm 2$个奇度顶点

  对于有两个奇度定点的，欧拉通路一定是从其中一个出发到另一个

* 对于有向图$\rm G$，$\rm G$是欧拉图当且仅当$\rm G$的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同

  其中有向图$\rm G$强连通是指，$\rm G$中任意两个结点连通

* 对于有向图$\rm G$，$\rm G$是半欧拉图当且仅当$\rm G$的所有顶点属于同一个强连通分量且

  * 最多只有一个顶点的出度与入度差为$\rm 1$
  * 最多只有一个顶点的入度与出度差为$\rm 1$
  * 所有其他顶点的入度和出度相同

这样一来判断欧拉图只要输入之后跑一遍连通性然后查找每个点的度就行，这是$\rm O(n)$的

## 构建hash的方法

我使用的是`map`法，这样的时间复杂度相当于“往`map<string,int>`里插`string`”的时间复杂度，即$\rm O(n\log n)$，是很可以接受的

另外我也使用刘汝佳大爷的一种写法，即将构建新hash和获得hash的函数放到一起，这样可以减少码量

个人自认为码风不错，可以直接看代码

# 代码
```c++
#include <bits/stdc++.h>

//#define _DEBUG_
#ifdef _DEBUG_
#define debug(x) cout << #x << ": " << x << "  "
#define print_n printf("\n")
#define cout_n cout<<'\n'
#else
#define debug(x)
#define print_n
#define cout_n
#endif

using namespace std;
#ifdef _DEBUG_
const int MAXN=10+5;
#else
const int MAXN=5e5+100;
#endif

// 使用map的hash
int strcnt;
map<string,int>msi;
string mis[MAXN];
int Getint(string str){
    int org=msi[str];
    if (!org) {
        msi[str]=++strcnt;
        mis[strcnt]=str;
        return strcnt;
    }else{
        return org;
    }
}

vector<int>G[MAXN];
void add(int u,int v){G[u].push_back(v);G[v].push_back(u);}
int vis[MAXN];
void visdfs(int u){
    vis[u]=true;
    for (auto v : G[u]) {
        if (!vis[v]) {
            visdfs(v);
        }
    }
}

int d[MAXN];
string buf;
int main(int argc, const char * argv[]) {
    ios::sync_with_stdio(false);
    memset(d, 0, sizeof(d));
    while ( cin>>buf ) {
        string bufl;
        cin>>bufl;
        
        int u,v;
        u=Getint(buf);
        v=Getint(bufl);
        if (u!=v) {
            d[u]++;d[v]++;
            add(u, v);
        }
    }
    memset(vis, false, sizeof(vis));
    visdfs(1);
    for (int i=1; i<=strcnt; i++) {
        if (!vis[i]) {
            cout<<"Impossible"<<'\n';
            return 0;
        }
    }
    int oddi=0;
    for (int i=1; i<=strcnt; i++) {
        if (d[i]&1) {
            oddi++;
        }
    }
    if ( oddi==0 || oddi==2 ) {
        cout<<"Possible"<<'\n';
    }else{
        cout<<"Impossible"<<'\n';
    }
    return 0;
}
```


---

## 作者：ghmgjf (赞：2)

题其实很简单，就是个标准的欧拉回路（一笔画），个人觉得字典树比较难（可能是我菜，没见过）。
解析在代码中了：
```c
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<map>
#include<cstring>
using namespace std;
#define xx 1000010
char s1[51],s2[50];
int tot=0,tot_v=1,k,ta=0;
//tot记录点数 ，k记录出度为奇数的点的个数。 
int exist[xx],sum=0;
//这两个用于判断是否只有一个树。 
struct er  
{  
    int hash;  
    int next[27];  
}a[800001];
struct re
{
	int t,next,head,s,out,in;
}e[xx*4];
int search(char s[50])//hash字典树 
{  
    int l = strlen(s);  
    int p = 1; 
    for (int i = 1; i <= l; i++)  
    {  
        int x = s[i - 1] - 'a' + 1;
        if (a[p].next[x] == 0)  
        {  
            tot_v++;  
            a[p].next[x] = tot_v;  
        }  
        p = a[p].next[x];  
    }  
    if (a[p].hash == 0)
        a[p].hash = ++tot;  
    return a[p].hash;  
}  
void build(int x,int y)//建树 
 {
 	e[++ta].t=y;e[ta].s=x;
 	e[x].out++;e[y].in++;
	e[ta].next=e[x].head;e[x].head=ta;
 }
 void dfs(int x)//遍历判断是否是一个树或森林。 
 {
 	for(int i=e[x].head;i;i=e[i].next)
 	{
 		if(exist[e[i].t]==0)
 		{
 			exist[e[i].t]=1;
 			++sum;//记录一个树中的点数，看是否等于tot。 
 			dfs(e[i].t);
 		}
 	}
 }
int main()
{
	while(cin>>s1>>s2)
	{
		int x,y;
		x=search(s1);//变字符为数字，方便记录。 
		y=search(s2);
		build(x,y);build(y,x);
	}
	for(int i=1;i<=tot;++i)
	{
		if(e[i].out%2!=0)
		++k;
	}
	dfs(1);
	int u=0;
	if(sum==tot)
	u=0;
	else u=1;
	if(u==1)//如果是森林，则不联通。 
	{
		cout<<"Impossible";
		return 0;
	}
	if((k==2||k==0))
	cout<<"Possible";
	if(k!=2&&k!=0)
	cout<<"Impossible";
	return 0;
}

```

---


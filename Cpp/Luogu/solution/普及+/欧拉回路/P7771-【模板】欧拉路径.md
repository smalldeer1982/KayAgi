# 【模板】欧拉路径

## 题目描述

求有向图字典序最小的欧拉路径。

## 说明/提示

对于 $50\%$ 的数据，$n,m\leq 10^3$。

对于 $100\%$ 的数据，$1\leq u,v\leq n\leq 10^5$，$m\leq 2\times 10^5$。

保证将有向边视为无向边后图连通。

本题的数据生成器：

```cpp
#include<bits/stdc++.h>
#include<windows.h>
using namespace std;
typedef unsigned long long ull;
#define N 100005
#define For(i,x,y)for(i=x;i<=(y);i++)
bool bo[N];
queue<int>p,q;
ull R=GetTickCount();
int deg[N][2],dep[N],fa[N];
inline int Rand(int _,int __)
{
	R^=R<<13;
	R^=R>>7;
	R^=R<<17;
	return R%(__-_+1)+_;
}
int find(int p)
{
	if(p!=fa[p])fa[p]=find(fa[p]);
	return fa[p];
}
inline void unite(int p,int q)
{
	p=find(p),q=find(q);
	if(p==q)return;
	if(dep[p]<dep[q])fa[p]=q;
	else fa[q]=p;
	if(dep[p]==dep[q])dep[p]++;
}
int main()
{
	freopen("P7771.in","w",stdout);
	int n=Rand(1,100000),m=Rand(190000,200000),i,u,v;
	cout<<n<<' '<<m;
	For(i,1,n)fa[i]=i;
	For(i,1,m>>1)
	{
		u=Rand(1,n),v=Rand(1,n);
		cout<<endl<<u<<' '<<v;
		unite(u,v);
		deg[u][0]++;
		deg[v][1]++;
	}
	m-=m>>1;
	For(i,1,n)
	if(deg[i][0]<deg[i][1])p.push(i);
	else if(deg[i][0]>deg[i][1])q.push(i);
	while(m)
	{
		if(p.empty()||q.empty())break;
		u=p.front();
		v=q.front();
		p.pop();
		q.pop();
		unite(u,v);
		cout<<endl<<u<<' '<<v;
		deg[u][0]++;
		deg[v][1]++;
		if(deg[u][0]<deg[u][1])p.push(u);
		if(deg[v][0]>deg[v][1])q.push(v);
		m--;
	}
	For(i,1,n-1)
	if(find(i)!=find(n))
	{
		cout<<endl<<n<<' '<<i<<endl<<i<<' '<<n;
		m-=2;
		unite(n,i);
	}
	if(m<2)
	while(1);
	while(m>Rand(0,1))
	{
		u=Rand(1,n);
		cout<<endl<<u<<' '<<u;
		m--;
	}
	if(m)cout<<endl<<Rand(1,n)<<' '<<Rand(1,n);
	return 0;
}
```

## 样例 #1

### 输入

```
4 6
1 3
2 1
4 2
3 3
1 2
3 4```

### 输出

```
1 2 1 3 3 4 2```

## 样例 #2

### 输入

```
5 5
1 2
3 5
4 3
3 4
2 3```

### 输出

```
1 2 3 4 3 5```

## 样例 #3

### 输入

```
4 3
1 2
1 3
1 4```

### 输出

```
No```

# 题解

## 作者：Marsrayd (赞：475)

upd 2021.8.26：修改评论区指出的代码的错误，实在抱歉，十分感谢 @[mazymaze](https://www.luogu.com.cn/user/33578) 指出我代码的错误。

upd 2021.12.18：修改评论区两位超级大巨佬 @[Dragon_in_Bed](https://www.luogu.com.cn/user/65289) 和 @[ix35](https://www.luogu.com.cn/user/113546) 指出的我的题解中叙述不严谨的地方，十分感谢他们（我咕了好久啊qwq）。

upd 2023.2.6：再次修改评论区指出的代码的错误，十分感谢 @[Tibrella](https://www.luogu.com.cn/user/655192)。

## [题目传送门](https://www.luogu.com.cn/problem/P7771)

## 前置芝士：

$1$. **欧拉路径定义**：

图中经过所有边**恰好一次**的路径叫**欧拉路径**（也就是一笔画）。如果此路径的**起点**和**终点**相同，则称其为一条**欧拉回路**。

$2.$ **欧拉路径判定（是否存在）**：
- **有向图欧拉路径**：图中**恰好**存在 $1$ 个点出度比入度多 $1$（这个点即为 **起点** $S$），$1$ 个点入度比出度多 $1$（这个点即为 **终点** $T$），其余节点出度=入度。

- **有向图欧拉回路**：**所有点**的入度=出度（起点 $S$ 和终点 $T$ 可以为任意点）。
- **无向图欧拉路径**：图中**恰好**存在 $2$ 个点的度数是**奇数**，其余节点的度数为**偶数**，这两个度数为**奇数**的点即为欧拉路径的 **起点** $S$ 和 **终点** $T$。
- **无向图欧拉回路**：**所有点**的度数都是**偶数**（起点 $S$ 和终点 $T$ 可以为任意点）。

注：存在欧拉回路（即满足存在欧拉回路的条件），也一定存在欧拉路径。

当然，一副图有欧拉路径，还**必须满足**将它的有向边视为无向边后它是**连通**的（不考虑度为 $0$ 的孤立点），连通性的判断我们可以使用```并查集```或 ```dfs``` 等。


$3.$ **寻找欧拉路径（默认存在）**：

- 首先根据题意以及判定先确定起点 $S$。
- 从起点 $S$ 开始 ```dfs``` 。

```dfs``` 伪代码如下：
```cpp
void dfs(int now)
{
	枚举now的出边。
		如果该边还未被访问
			标记为已访问
			dfs(该边连向的另一个点)
	now入栈
}
```

- 最后倒序输出栈内的所有节点即可。
	- 感性理解倒序输出的原因：如果是欧拉回路，那么遍历到哪，输出到哪也是对的，因为不管怎么走都会绕某个环走回起点，所以不到最后不会出栈，然而欧拉路径会出现边都被走过了，走不回起点，最后会停留在终点，遇到这种情况这种路径会最先出栈，于是只要把这个路径先走了，前面就和欧拉回路一样随便走就行，不会出栈，于是倒序输出就是对的。

##  $\texttt{Solution}$：
**题意**：给定 $n$ 个点，$m$ 条边，求这副有向图字典序最小的欧拉路径。

**思路**：

本题需要判断 $+$ 找出**有向图**的欧拉路径。

由于本题保证“将有向边视为无向边后图连通”，所以判定时不用判断连通性。

还有一点要注意的是本题需要按照**字典序**输出。

这一点如何解决呢？

法一：

- 直接使用数组存邻接矩阵，枚举点 $x$ 出边时，直接枚举编号从 $1$ 到 $n$ 的点 $y$，再判断 $x$，$y$ 之间是否有未访问边，这样就解决了字典序的问题。 
- dfs 代码（对应伪代码）:
	```cpp
    void dfs(int now)
    {
        for(int i=1;i<=n;i++)
        {
            if(G[u][i]>0)
            {
                G[u][i]--;
                dfs(i);
            }
        }
        st.push(now);
    }
	```

- 但是这样的做法时间复杂度为 $\mathcal{O}(n^2)$，显然会超时。

法二：

- 既然邻接矩阵不行，那我们就用时间复杂度更优的邻接表，将 $now$ 的所有出边排序即可。链式前向星对于排序出边的操作有些困难（是我太菜了qwq），而 ```vector``` 则容易的多，所以我选用了 ```vector```。
- sort 代码：
	```cpp
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    ```
- dfs 代码：
	```cpp
    void dfs(int now)
    {
    	for(int i=del[now];i<G[i].size();i=del[now])
		{
			del[now]=i+1;
			dfs(G[now][i])
		}
		st.push(now);
     }
     //其中 del[now] 表示 G[now][1,2……,del[now]-1] 都已经被标记访问过，下一次要从G[now][del[now]]开始访问。
    ```
  


- dfs 时间复杂度：$\mathcal{O(n)}$。

- sort 时间复杂度：$\mathcal{O(m\log m)}$。

- 总时间复杂度：$\mathcal{O(n+m\log m)}$。

- 足以 AC 本题。

## $\texttt{AC Code}$：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX=100010;
int n,m,u,v,del[MAX];
int du[MAX][2];//记录入度和出度 
stack <int> st;
vector <int> G[MAX];
void dfs(int now)
{
	for(int i=del[now];i<G[now].size();i=del[now])
	{ 
		del[now]=i+1;
		dfs(G[now][i]);
	}
	st.push(now);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d",&u,&v),G[u].push_back(v),du[u][1]++,du[v][0]++;  
    for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());
    int S=1,cnt[2]={0,0}; //记录
    bool flag=1; //flag=1表示,所有的节点的入度都等于出度,
    for(int i=1;i<=n;i++)
	{
        if(du[i][1]!=du[i][0])
        {
            flag=0;
            if(du[i][1]-du[i][0]==1/*出度比入度多1*/) cnt[1]++,S=i;
            else if(du[i][0]-du[i][1]==1/*入度比出度多1*/) cnt[0]++;
            else return puts("No"),0;
        }
    }
    if((!flag)&&!(cnt[0]==cnt[1]&&cnt[0]==1)) return !puts("No"),0;
	//不满足欧拉回路的判定条件，也不满足欧拉路径的判定条件，直接输出"No" 
    dfs(S);
    while(!st.empty()) printf("%d ",st.top()),st.pop();
    return 0; 
}

```


练习：
- [luogu P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)：判定 $+$ 寻找欧拉路径（可用邻接矩阵）。
- [luogu P2731 骑马修栅栏](https://www.luogu.com.cn/problem/P2731)：寻找欧拉路径（可用邻接矩阵）。
- [luogu P1127 词链](https://www.luogu.com.cn/problem/P1127)：判定 $+$ 寻找欧拉路径。

**最后：** 由于本人能力有限，难免出错，欢迎大家指正。

---

## 作者：Alex_Wei (赞：77)

- Upd on 2022.8.22 改正笔误。

> [P7771 【模板】欧拉路径](https://www.luogu.com.cn/problem/P7771)。
>
> 摘自学习笔记 [初级图论](https://www.cnblogs.com/alex-wei/p/basic_graph_theory.html) 第六章。
>
> **建议在博客内阅读**。

### 6.1 定义与判定

- 欧拉路径：通过 **连通图** 中所有边恰好一次的路径称为欧拉路径。
- 欧拉回路：通过 **连通图** 中所有边恰好一次的 **回路** 称为欧拉回路。回路，即路径起点和终点相同。
- 欧拉图：具有欧拉 **回路** 的有向图或无向图称为欧拉图。
- 半欧拉图：具有欧拉 **通路** 但 **不具有欧拉回路** 的有向图或无向图称为半欧拉图。

做题时基本用不到上述定义（大雾）。

不严谨地说，欧拉图能够从任意一点作为起点一笔画完整张图然后回到该点，而半欧拉图只能从某两个点 $S,T$ 开始才能画完整张图，其中 $S,T$ 分别作为起点和终点。

欧拉图的判定：一张无向图 $G$ 是欧拉图，当且仅当 $G$ 是连通图且每个顶点的 **度数都是偶数**。一张有向图 $G$ 是欧拉图，当且仅当 $G$ 是 SCC 且每个顶点的入度和出度相等。

考虑证明上述结论。

无论是对于无向图还是有向图而言，必要性都是显然的。考虑最终欧拉回路的形态，每次进入一个点，都要从该点走出去，所以出边和入边必须两两抵消。对于起始点，它一开始走出去的边和最后走回它的边同样抵消了，所以有向图存在欧拉回路必须满足每个点出度和入度相等。同理可证无向图每个点的度数必须为偶数。

充分性通过构造法证明。考虑无向图，首先找到图上任何一个回路 $P$（不需要是欧拉回路）。因为除掉所有孤立点，每个点的度数都 $\geq 2$，所以回路必然存在。然后从图上删去 $P$ 的所有边，并删去所有孤立点。形成的所有子图仍然满足每个点的度数均为偶数，因为 $P$ 中每个点的度数为 $2$。由于每个子图均与 $P$ 有交点，所以只需要将子图的欧拉回路接到 $P$ 上即可得到原图的欧拉回路。因此我们对子图进行同样的操作。边的个数有穷，所以整个过程必然结束，继而我们得到原图的欧拉回路。同理可证有向图欧拉回路判定条件的充分性。

半欧拉图的判定：一张无向图 $G$ 是半欧拉图，当且仅当 $G$ 存在两个奇度数顶点。一张有向图 $G$ 是半欧拉图，当且仅当 $G$ 弱连通，恰存在一个顶点使得出度减入度等于 $1$，恰存在一个顶点使得入度减出度等于 $1$，且剩余所有顶点出入度相等。弱连通定义为将所有有向边替换为无向边后，整张图连通。

### 6.2 求欧拉路径：Hierholzer 算法

Hierholzer 算法的核心是不断往当前回路的某个点中插入环，这和欧拉回路存在的判定条件的充分性证明如出一辙，或者说完全等价。

先考虑有向图吧，因为有向图不需要考虑重边的问题。

#### 6.2.1 朴素方法

根据流程，我们有一个朴素的实现方法：首先 dfs 找到经过某个点的任意一个环 $P$（不需要是简单环），将 $P$ 上的所有边标记为已删去。然后依次加入 $P$ 上的每个节点 $p_1, p_2, \cdots, p_{|P|}, p_1$。加入 $p_i$ 之前，我们先递归找到 $p_i$ 所在子图（我们删去了一些边）的欧拉回路，然后插入当前路径。因此这是一个递归形式的算法。

每次枚举到一个点时，我们都要遍历它的所有出边以找到第一个没有被删去的边，复杂度为 $\mathcal{O}(m ^ 2)$。

若用双向链表维护每个点剩余的所有出边，则每条边只会被遍历一次，时间复杂度 $\mathcal{O}(n + m)$。

进一步地，我们发现每次删去的环边一定是每个节点所有没有被删去的出边中开头的若干个。也就是说，如果给 $u$ 的所有出边 $(u, v_i)$ 钦定一个遍历顺序 $(u, v_1), \cdots, (u, v_{out(u)})$，那么找环时被删去的一定是开头的若干条边 $(u, v_1), (u, v_2), \cdots, (u, v_k)$。因为我们不会因找不到环而反悔掉走某一条边的操作。

**不断无脑深搜，最终一定能找到环**。

证明该结论。不妨设我们从 $u$ 开始找环，每次走当前节点第一条没有被删去的出边并删去。走到节点 $v \neq u$ 时，设这是我们第 $i$ 次进入 $v$，那么我们只会离开 $v$ 共 $i - 1$ 次（每次离开必然对应一次进入，而在第 $i$ 次进入之前，只有 $i - 1$ 次进入）。故此时我们只删掉了 $v$ 的 $i - 1$ 条出边，而 $v$ 有不少于 $i$ 条出边：第 $i$ 次进入 $v$ 意味着 $in(v) \geq i$，而 $in(v) = out(v)$ 所以 $out(v) \geq i$。因此我们必然能从 $v$ 走出去到别的节点。

因此，最终必然只可能在 $u$ 处走不到其它节点。但这意味着我们已经找到了一个环。

根据上述结论，我们不需要维护双向链表了。存图用的链式前向星可以满足我们的要求，因为我们每次只会删去开头的出边。这样改进后，链表头就和网络最大流 Dinic 算法的当前弧非常相似，都是 **记录第一个有用的边** 以省去一条条跳无用边的时间。

该结论同时也证明了找到一个环的复杂度关于环上边数线性，所以总复杂度即 $\mathcal{O}(n + m)$。

注意，需要使用双向链表维护将一个环插入当前回路的过程，否则复杂度会退化成 $\mathcal{O}(n(n +m))$（如果一旦走到目标节点而非目标节点不可以在往外走时就认为找到环，复杂度会退化成 $\mathcal{O}(m(n + m))$）。因为这样处理一个环的复杂度变成了所有未处理的边的个数之和。

#### 6.2.2 巧妙方法

上述做法的时间复杂度已经足够优秀，但实现起来稍微有些复杂。我们希望算法能够更简单。

我们可以用自己的语言描述复杂的方法干了些什么，再思考有哪些地方可以简化。

从整体上考察，我们无非就是实现了这样的步骤：从一个起点开始找到一个环，然后以环上的每个起点开始找到一个环 …… 不断递归下去。

然后思考究竟是哪里麻烦了。我们会发现，为了依次从环上的每个起点开始找环，我们需要先 **显式** 地将这个环找到，排出来，再依次处理上面的所有节点。所以我们需要一个 dfs 函数找环，另一个递归式函数解决欧拉回路问题。

这样太蠢了，因为无论以怎样的顺序安排环上节点的找环顺序，都不会影响欧拉回路的正确性。我们只是找环并插入啊，换个顺序又不会让问题变得无解。

因此，我们直接在 dfs 找环的回溯过程中，直接对环上的每个节点找环。换句话说，我们将原来找环的顺序倒过来，这样我们就没有必要先显式地找到当前环了，而是在回溯的过程中，一边对当前点找环，一边往回路中插入当前环。

综上，我们得到了求解欧拉回路的最常用算法 —— Hierholzer 算法的具体步骤：遍历当前节点 $u$ 的所有出边 $(u,v)$，若 $(u,v)$ 未走过，那么向节点 $v$ 深搜。遍历完所有出边后，将 $u$ 加入路径。最终得到的就是一条反着的欧拉路径。倒过来即可。

如果要求字典序最小，只需在一开始对每个点的所有出边从小到大排序。这样一来，欧拉回路上从左往右看，每个点的后继都取到了理论最小值。

#### 6.2.3 无向图和欧拉通路

以上，我们通过两小节的篇幅提出并优化了有向图欧拉回路的求解方法。

对于无向图的欧拉回路，我们可以类似有向图欧拉回路一样做，唯一的注意点是我们需要对边判重。使用求桥边时的成对变换技巧，用 $2k$ 和 $2k + 1$ 存储一条边的两个方向，并开桶记录。不能只判返祖边，因为可能有重边。

对于无向图和有向图的欧拉通路，注意必须从奇点或唯一的出度大于入度的点开始 dfs。其它地方和欧拉回路没有区别。

模板题 [P7771 【模板】欧拉路径](https://www.luogu.com.cn/problem/P7771) 代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, m, lar, top, stc[N], in[N], hd[N];
vector<int> e[N];
void dfs(int id) {
  for(int &i = hd[id]; i < e[id].size(); ) dfs(e[id][i++]);
  stc[++top] = id;
}
int main() {
  cin >> n >> m;
  for(int i = 1; i <= m; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    e[u].push_back(v), in[v]++;
  }
  for(int i = 1; i <= n; i++) {
    sort(e[i].begin(), e[i].end());
    if(abs((int) e[i].size() - in[i]) > 1) puts("No"), exit(0);
    if(e[i].size() > in[i])
      if(lar) puts("No"), exit(0);
      else lar = i;
  }
  dfs(lar ? lar : 1);
  if(top != m + 1) puts("No");
  else {
    reverse(stc + 1, stc + top + 1);
    for(int i = 1; i <= top; i++) cout << stc[i] << " ";
  }
  return 0;
}
```

### 6.3 参考文章

- [欧拉回路与欧拉通路存在性的充要条件及其证明](https://wenku.baidu.com/view/f1dc5c467b3e0912a21614791711cc7930b77849.html)。
- [欧拉图 - OI Wiki](https://oi-wiki.org/graph/euler/)。

---

## 作者：gaozitao1 (赞：63)

# P7771 【模板】欧拉路径 题解
题目大意：求出图中字典序最小的欧拉路径。

欧拉路径就是在不重复经过边的情况下走过每一条边，和一笔画问题很相似。

#### 首先，需要判断是否存在欧拉路径。

一个图存在欧拉路径有两个条件：

- 将有向边视为无向边后，整张图联通。如果不连通，那么不可能走完所有的边。（这个条件本题已经保证，但是有些题没有保证，需要自行判断）。

- 每个点的入度等于出度或者一个点的入度比出度大一，一个点的入度比出度小一，其他点入度等于出度。如果不满足这些条件，那么一个入度比出度大许多的点周围的边不可能都被经过。

#### 之后，就是确定起点。

如果每个点的入度等于出度，那么无论从哪个点开始走都可以，但是题目要求是字典序最小的，那么就从一开始。如果一个点的入度比出度大一，一个点的入度比出度小一，那么只有从入度比出度小一的点走到入度比出度大一的点才可以。

#### 确定了起点之后，就是求解了。

在建边的过程中，按照起点为第一关键字正序，终点为第二关键字倒序（因为链式前向星建边的时候枚举是从后往前枚举的），之后从起点开始搜索，每次走完一个边删去一个边，将一个点的所有边都搜索完之后将这个点入栈，之后从栈顶开始输出即可。

**为什么需要先入栈，直接输出不行吗？**

答案是不行的。会发现当一个点的所有出边都被搜索完之后，才会被入栈，这样，在栈中的点是无法继续往外走的，而栈外的点才可以往外走。所以，栈外的点在欧拉路径中的位置是在栈内的点之前的，否则，如果先走栈内的点，一些只有栈外的点可以到达而栈内的点无法到达的点是不会被走到的，这样就不能经过所有的边的，不符合要求。所以，当一个点的全部出边都经过之后，表示这一个点不能再到达其他点，为了可以到达其他点，只能让这个点位于其他点之后，所以要入栈。

之后，就可以将代码写出来了。

代码（90分）：
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
using std::sort;
int c,T,b[100001],d[100001],h[100001],e[200001],f[200001],s[200001],t[200001];
//b[i]表示第i个点的出度
//d[i]表示第i个点的入度
//f[i]表示第i条边是否被删了
//s是栈
struct node
{
	int u,v;
} a[200001];//记录每一条边
void add(int u,int v)//加边
{
	e[++c]=h[u];
	h[u]=c;
	t[c]=v;
}
void dfs(int u)//求解
{
	int i;
	for(i=h[u]; i; i=e[i])
		if(!f[i])//如果这条边没有被删过
		{
			f[i]=1;//删掉这条边
			dfs(t[i]);
		}
	s[++T]=u;//入栈
}
bool cmp(node a,node b)
{
	if(a.u!=b.u)
		return a.u<b.u;
	return a.v>b.v;
}
int main()
{
	int i,j=0,k=0,n,m,u=1;
	//j记录出度比入度大1的点的个数
	//k记录入度比出度大1的点的个数
	//u表示起点，初始为1
	scanf("%d%d",&n,&m);
	for(i=1; i<=m; ++i)
	{
		scanf("%d%d",&a[i].u,&a[i].v);
		++b[a[i].u];
		++d[a[i].v];
	}//读入并求出入度和出度
	for(i=1; i<=n; ++i)
	{
		if(b[i]-d[i]>1||d[i]-b[i]>1)//如果入度与出度相差大于1，那么不存在欧拉路径
		{
			puts("No");
			return 0;
		}
		if(b[i]-d[i]==1)//出度比入度大1，作为起点
		{
			++j;
			u=i;
		}
		else if(d[i]-b[i]==1)//入度比出度大1
			++k;
	}
	if((j==0&&k==0)||(j==1&&k==1))//有解
	{
		sort(a+1,a+m+1,cmp);
		for(i=1; i<=m; ++i)
			add(a[i].u,a[i].v);//排序后建边
		dfs(u);//求解
		while(T)
		{
		    printf("%d ",s[T]);
		    --T;
		}
	}
	else//无解
		puts("No");
	return 0;
}
```
但是只能得到90分。

分析一下时间复杂度可以发现，排序时间复杂度 $O\left(m\log m\right)$，求解的时间复杂度期望是 $O\left(n+m\right)$ 的，但是如果从一个点连出许多边，那么每次到这个点都需要判断一下这些边是否被经过，如果一个点连的边是 $O\left(m\right)$ 级别的，那么求解的时间复杂度就变成了 $O\left(nm+m^2\right)$，总的时间复杂度就是 $O\left(m\log m+nm+m^2\right)$，很明显，当其中一个点连得边很多的时候就会超时。

这样，就要考虑记录每个点删到哪个边了，所以就需要每次走一条边时改变 $h$ 数组的值，让他记录下一个边即可。

因为只有 dfs 函数改变了，所以只附上 dfs 函数的代码：
```cpp
void dfs(int u)//求解
{
	int i;
	for(i=h[u]; i; i=h[u])
	//if(!f[i])//如果这条边没有被删过
	{
		//f[i]=1;//删掉这条边
		h[u]=e[i];
		//每次走完，将h[u]改为下一条边
		//这样，就不需要用f数组记录一条边是否被删过了
		dfs(t[i]);
	}
	s[++T]=u;//入栈
}
```
这样，求解的时间复杂度就是稳定的 $O\left(n+m\right)$ 了，总时间复杂度为 $n+m+m\log m$，可以过这道题了。

#### 你以为这就结束了？

~~建议在理解上述内容的基础上看。~~

在仔细分析代码发现，将边按照起点排序之后，就不需要建边了，因为每一个点的边都是连在一起的，这样只需要记录每一个点的边是属于哪个范围的即可，所以可以不用建边。优化了空间。

注意，因为不用链式前向星，所以排序时要以起点为第一关键字正序，终点为第二关键字正序，不用倒序了。

又因为已经记录了每个点的出度，所以不用遍历每一个边求每个点的边的范围，只需要枚举每一个点即可， $O\left(m\right)->O\left(n\right)$。

再分析可以发现，如果直接排序，时间复杂度是 $O\left(m\log m\right)$ 的，而在已经记录出每个点的出边的基础上，可以直接求出来每个点对应的边处于的位置，所以可以 $O\left(m\right)$ 的将边按照起点分好类，之后对于相同起点的边内部进行排序，这样在随机图中，每个点为起点大约有 $\frac{m}{n}$ 条边，对一个点排序的时间复杂度为 $O\left(\frac{m}{n}\log\frac{m}{n}\right)$，而总排序复杂度为 $O\left(m\log \frac{m}{n}\right)$。在 本题的极限数据中$\frac{m}{n}=2$，所以总排序的时间复杂度可以认为只有 $O\left(m\right)$ 。只有当 $m$ 很大 $n$ 很小的时候，该方法的时间复杂度为 $O\left(m\log m\right)$。

综上，总时间复杂度下界为 $O\left(n+m+m\log\frac{m}{n}\right)$，上界为 $O\left(m\log m\right)$，在随机图中时间复杂度优秀。

代码：
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
using std::sort;
int t,b[100001],d[100001],e[100001],s[100001],a[200001],u[200001],v[200001],st[200002];
//b[i]表示第i个点的出度
//d[i]表示第i个点的入度
//s[i]表示第i个点连的第一条边
//e[i]表示第i个点连的最后一条边
//st是栈
void dfs(int u)//求解
{
	int i;
	for(i=s[u]; i<=e[u]; i=s[u])
	{
		++s[u];//相当于去掉当前的边
		dfs(a[i]);
	}
	st[++t]=u;
}
int main()
{
	int f=0,i,j=0,k=0,n,m,r=1;
	//f记录上一个点的最后一个边的位置（如果不明白可以往下看看）
	//j记录出度比入度大1的点的个数
	//k记录入度比出度大1的点的个数
	//r表示起点，初始为1
	scanf("%d%d",&n,&m);
	for(i=1; i<=m; ++i)
	{
		scanf("%d%d",&u[i],&v[i]);
		++b[u[i]];
		++d[v[i]];
	}//读入并求出入度和出度
	for(i=1; i<=n; ++i)
	{
		if(b[i]-d[i]>1||d[i]-b[i]>1)//如果入度与出度相差大于1，那么不存在欧拉路径
		{
			puts("No");
			return 0;
		}
		if(b[i]-d[i]==1)//出度比入度大1，作为起点
		{
			++j;
			r=i;
		}
		else if(d[i]-b[i]==1)//入度比出度大1
			++k;
	}
	if((j==0&&k==0)||(j==1&&k==1))//有解
	{
		for(i=1; i<=n; ++i)
		{
			d[i]=s[i]=f+1;
			//f是上一个点连的最后一个边，那么f+1就是这一个点的第一个边
			//d[i]作为临时变量，记录第i个点正在往数组里放第d[i]条边
			e[i]=f+b[i];//第i个点连的最后一个边
			f=e[i];//记录这一个点的最后一个位置
		}
		for(i=1; i<=m; ++i)
			a[d[u[i]]++]=v[i];//按照起点分类
		for(i=1; i<=n; ++i)
			sort(a+s[i],a+e[i]+1);//对相同起点的数进行排序
		dfs(r);
		while(t)
			printf("%d ",st[t--]);
	}
	else//无解
		puts("No");
	return 0;
}
```

---

## 作者：cyffff (赞：46)

[$\text{Link}$](https://www.luogu.com.cn/problem/P7771)

$\text{upd2021.8.1}:$修改时间复杂度错误的代码，通过评论区的 $\text{hack}$。

$\text{upd2021.8.5}:$增加时间复杂度更优的做法。
## 题意
给出一个有 $n$ 个点，$m$ 条边构成的有向图，求其字典序最小的欧拉路径。

$1\le n\le10^5,1\le m\le2\times10^5$
## 思路
是新模板，写个题解。

首先，我们需要了解什么是**欧拉路径**。

> **通过图中所有边恰好一次且行遍所有顶点的通路**称为欧拉路径，又称欧拉通路、欧拉道路。

如何判断一个图是否存在欧拉路径？

当然，如果图是欧拉图的话，即有欧拉回路时肯定存在欧拉路径。对于其余情况，考虑欧拉路径中相邻两个结点之间有边相连，除了路径中第 $1$ 个和第 $m+1$ 个点，每个点都会被进入一次、离开一次，且每条边都被遍历过。即**除了起点、终点，每个点的入度都等于出度**。**对于起点，入度比出度少一，对于终点，入度比出度大一**。

至此，我们就可以 $O(n+m)$ 判断是否有解了。若有解，还可求出起点与终点。

考虑求解，从起点开始 $\text{dfs}$，对于当前搜到的点，随意选择一条以前未选过的与其相连的边继续搜索，退出搜索时压入栈中，最后将栈中所有元素输出即可。

显然，连入每个点和其连出的边都会被遍历一次，对于求任意一条欧拉路径，我们无需考虑每个点被遍历的先后顺序，每次搜至某一点都会使其入度减少一，继续搜时有两种情况：

- 若有回到该点的环，即该点还有入度：
	- 回到该点的环，则此次遍历环使得其入度、出度均减一；
   - 进入其他环内，则由于连向此点的点还有出度，必有入度，能够对进入的环进行此分析，最终将进入的环内的点的入度均变为 $0$（若里面有终点，其入度为  $1$）后必可回到该点（因为已经证明有欧拉路径）；
- 没有回到该点的环，则此时入度已为 $0$，出度只可能为 $1$，向下搜之后此点出、入度均变为 $0$。

最终每个点的入度、出度均变为 $0$，故此算法是正确的，时间复杂度为 $O(n+m)$。

考虑原问题，即求字典序最小的欧拉路径。

考虑贪心，靠前的位置应尽可能小，使每次转移的点尽量小即可，可以预先将每个点连出的所有点按照编号大小排序，时间复杂度 $O(n+m\log m)$。

其中有一个细节：若每扫边次都从 $0$ 开始，即以下搜索代码：

```cpp
inline void dfs(int x){
    for(int i=0;i<a[x].size();i++){
        int t=a[x][i].first;
        if(!vis[a[x][i].second]){
            vis[a[x][i].second]=1;
            dfs(t);
        }
    }
    ans.push(x);
}
```
的复杂度可以通过构造 $10^5$ 条 $1\to2$，$10^5$ 条 $2\to1$ 的边卡到 $O(m^2)$。

解决方案就是记录目前删到第几条边，从删到的下一条边开始枚举，时间复杂度才能正确。

$O(n+m\log m)$ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
    
}
#define mpr make_pair
const int N=1e5+10;
int cnt,n,m,ind[N],oud[N],st[N];
vector<pair<int,int>>a[N];
bool vis[N<<1];
stack<int>ans;
inline void dfs(int x){
    for(int i=st[x];i<a[x].size();i=max(i+1,st[x])){
        int t=a[x][i].first;
        if(!vis[a[x][i].second]){
            vis[a[x][i].second]=1;
            st[x]=i+1;
            dfs(t);
        }
    }
    ans.push(x);
}
int main(){
    int s=0,t=0;
    n=read(),m=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        oud[u]++,ind[v]++;
        a[u].push_back(mpr(v,i));
    }
    for(int i=1;i<=n;i++)
        if(ind[i]!=oud[i]){
            cnt++;
            if(ind[i]==oud[i]-1)
                s=i;
            if(ind[i]==oud[i]+1)
                t=i;
        }
    if(cnt!=0&&cnt!=2)
        return puts("No"),0;
    if(cnt==0)
        s=t=1;
    if(!s||!t)
        return puts("No"),0;
    for(int i=1;i<=n;i++)
        sort(a[i].begin(),a[i].end());
    dfs(s);
    while(!ans.empty()){
    	write(ans.top()),putc(' ');
    	ans.pop();
	}
    flush();
}
```
当然，如果使用计数排序/基数排序等方法可以将时间复杂度降至 $O(n+m)$，但由于常数原因，在实际运行中没有 `sort` 快，具体代码见[这里](https://www.luogu.com.cn/paste/0l5qyep4)。

再见 qwq~

---

## 作者：ycw123 (赞：20)

## Luogu P7771 【模板】欧拉路径
### 题意

给定一个 $n$ 个点 $m$ 条边的有向图，求该图字典序最小的欧拉路径。

### 数据范围
对于 50\% 的数据，$n,m\le 10^3$。

对于 100\% 的数据，$1\leq u,v\leq n\leq 10^5$，$m\leq 2\times 10^5$。


## Solution:

来系统地整理一下有关欧拉回路和欧拉路径的问题。

### 什么是欧拉路径？

>**通过图中所有边恰好一次且行遍所有顶点**（允许多次经过同一个点）**的通路**称为欧拉路径。即一笔画。

>如果这条路径的起点和终点重合，那么就是**欧拉回路**。

### 如何判断图是否有欧拉回路或者欧拉路径？

- **无向图**：因为欧拉路径中，除了起点与终点以外，任意点的“进”“出”次数相等，所以除了两个点为奇点（度数为奇数的点）（终点和起点）以外，其它点的度数均为偶数。

  如果是欧拉回路，奇点的个数应该为0。

- **有向图**：欧拉路径中，最多只有两个点的入度不等于出度。起点出度比入度大1，终点入度比出度大1。

  如果是欧拉回路，所有点的 入度 = 出度 。

### 寻找欧拉回路或欧拉路径的算法有？

**Fluery** 算法和 **Hierholzer** 算法。

这里只讲解 **Hierholzer** 算法。

**Hierholzer** 算法自动寻找欧拉回路，在找不到欧拉回路的情况下会找到欧拉路径。前提是得给它指定好起点。

- 算法流程（无向图）：

1. 判断奇点数。奇点数若为0则任意指定起点，奇点数若为2则指定起点为奇点。

2. 开始递归函数 Hierholzer(x):

   循环寻找与 $x$ 相连的边 $x \to u$:
  
   删除 $x \to u$
    
   删除 $u \to x$
    
   Hierholzer(u);
    
   回溯时将 $x$ 插入答案队列之中

3. 倒序输出答案队列

### 举个栗子

![1206306-20170818160200881-1164016577.png](https://ae04.alicdn.com/kf/H8913f029940e4f0fbd1db61a3ff1bf5fW.png)

对于该图，算法的执行流程如下：

step1： 找到该图没有奇点，从1开始进行 **Hierholzer** 算法。

step2： 删边 $1 \to 2$ 递归到2

step3： 删边 $2 \to 3$ 递归到3

step4： 删边 $3 \to 7$ 递归到7

step5： 删边 $7 \to 1$ 递归到1

step6： 1无边，1加入队列，返回

step7： 7加入队列，返回

step8： 删边 $3 \to 4$ 递归到4

step9： 删边 $4 \to 5$ 递归到5

step10： 删边 $5 \to 6$ 递归到6

step11： 删边 $6 \to 3$ 递归到3

step12： 3加入队列，返回

step13： 6加入队列，返回

step14： 5加入队列，返回

step15： 4加入队列，返回

step16： 3加入队列，返回

step17： 2加入队列，返回

step18： 1加入队列，返回

答案队列为：1 7 3 6 5 4 3 2 1。反向输出即为答案。

有向图除判断是否存在有一点点不同以外同理。


------------

对于该【模板】题，要求按字典序输出答案。所以起点首先要选的尽量小，然后在边的储存上面加一点小 trick。

使用邻接表储存图时，除了用链式前向星还可以用 vector 储存。我们可以把 vector 排序，这样就可以保证该点前往的下一个点是最小值，同时保证了答案的最小值。
```
sort(a.begin(),a.end(),cmp); //vector排序方法
```

基于上面对算法的分析，我们可以写出 dfs 基本框架了：

```cpp
void dfs(int x){
	for(){ //遍历所有与x相邻的点u 
		if(!vis[u]){   //x与u的这条边没被访问过 
			vis[u]=1;    
			dfs(u);  //递归与x相邻的点u 
		}
	}
	s.push(x); //没有边了,将x进入序列 (用栈处理倒序输出）
}
```

但对于本题来说，这样的时间复杂度过不去的。按照算法，我们不能走重复边，但如果每次都 vis 判断一遍，则会出现很多次访问同一条边，会被~~毒瘤数据~~卡掉。

#### 处理：

对于任意一个点 $u$ 来说，建完图之后访问边是有顺序的，我们新开一个数组 $st$ 记录访问到哪个位置即可（即该删除哪个位置）。

## Code

```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std;

struct node{
	int u;
	bool vis;  //记录是否被访问过
};
int n,m; 

vector<node> v[100010];
int in[100010],st[100010]; //in表示每个结点入度与出度的差（即入读-出度）

stack<int> s;  //记录答案

void dfs(int x){
	for(int i=0;i<v[x].size();i=max(i+1,st[x])){
		if(v[x][i].vis) continue;
		v[x][i].vis=1;
		st[x]=i+1;
		dfs(v[x][i].u);
	}
	s.push(x);
}

bool cmp(node a,node b){
	return a.u<b.u;
}

int main(){

	cin>>n>>m;
	for(int i=1,x,y;i<=m;i++){
		cin>>x>>y;
		v[x].push_back(node{y,0});
		in[y]++;
		in[x]--;
	}
    
	int fb=0,fe=0,pb=1,pe; 
	for(int i=1;i<=n;i++){  //判断是否存在欧拉路径
		if(in[i]>1||in[i]<-1) {
			printf("No");
			return 0;
		}
		if(in[i]==1) fe++,pe=i;
		if(in[i]==-1) fb++,pb=i;
		if(fb>1||fe>1) {
			printf("No");
			return 0;
		}
	}
    
	for(int i=1;i<=n;i++) sort(v[i].begin(),v[i].end(),cmp);
    
	dfs(pb);
    
	while(s.size()){
		printf("%d ",s.top());
		s.pop();
	}
	return 0;
}

```


---

## 作者：翼德天尊 (赞：12)

第一次写板子题题解呢（惊喜）



------------

## Part 1 欧拉路径

欧拉路径即一条使得图上的所有边都被且只被经过一次的路径。

提到欧拉路径，就不得不提到小学奥数都学过的一笔画问题。

但与之不同的是，一笔画问题针对的对象是无向图。而一个无向图是否能被一笔画成的决定性因素就是图中是否有且只有零个或两个度数为奇数的节点。如果是，则可以被一笔画成，否则不行。

而有向图的条件则更加苛刻。若要有向图上存在一条欧拉路径，则必须要将无向图条件中的【度】细分为【入度】和【出度】——毕竟如果有一个入度为 $1$，出度为 $3$ 的节点显然也是无法一笔画成的——所以存在欧拉路径的有向图有两种：

1. 所有节点入度与出度相同。

2. 一个节点入度比出度大 $1$（终点），一个点出度比入度大 $1$（起点），剩下的节点入度与出度相同。

如果不满足其中任何一个条件，输出 `No` 即可。

知道这些之后，求欧拉路劲的方法就显而易见了。

## Part 2 本题解法

会求欧拉路径可还不够，我们还需要求出字典序最小的欧拉路径。

考虑到确定起点后，沿着周围的边走一定可以到终点结束，所以我们只需要考虑如何将走边的顺序最优化——排序邻边。

于是我们可以用 vector 存下所有的边，然后对于每个节点的所有邻边进行排序，即：

```
for (int i=1;i<=n;i++)
	sort(e[i].begin(),e[i].end());
```

然后再 dfs 从起点递归所有节点即可。由于遍历顺序，我们可以在遍历完一个节点后将该节点推入栈中，最后从栈顶到栈底依次输出所有元素即为答案。

注意 dfs 的时候记录每个节点遍历到了第几条边，保证不会重复遍历同一条边。即：

```
void dfs(int x){
	for (int i=cur[x];i<e[x].size();i=cur[x]){
		cur[x]=i+1;//记录i号节点遍历到了第几条边
		dfs(e[x][i]);
	}
	sta[++stot]=x;//将元素推入栈中
}
```


## Part 3 AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
int n,m,r[N],c[N],st=1,en,cur[N],sta[N],stot;
vector<int> e[N]; 
int read(){
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
void no(){
	puts("No");
	exit(0);
}
void dfs(int x){
	for (int i=cur[x];i<e[x].size();i=cur[x]){
		cur[x]=i+1;
		dfs(e[x][i]);
	}
	sta[++stot]=x;
}
int main(){
	n=read(),m=read();
	for (int i=1;i<=m;i++){
		int u=read(),v=read();
		e[u].push_back(v);
		c[u]++,r[v]++;
	}
	for (int i=1;i<=n;i++)
		sort(e[i].begin(),e[i].end());
	bool pd=0;
	for (int i=1;i<=n;i++){ 
		if (c[i]==r[i]) continue;
		else if (c[i]==r[i]+1){
			if (st&&pd) no();
			else st=i;
		}else if (c[i]==r[i]-1){
			if (en) no();
			else en=i;
		}else no();
		if (c[i]!=r[i]) pd=1;
	}
	dfs(st);
	while (stot>0){
		printf("%d ",sta[stot--]);
	}
	return 0;
}
```


---

## 作者：phil071128 (赞：10)

# 题解【模板】有向图欧拉路径

$\mathrm{update}$ $ 2021.8.2$ 感谢评论区的Hack数据，~~献丑了,连夜改。~~
### 前置芝士:

1. **欧拉路径**

    - 定义：从一个点出发，不重不漏的经过图中每一条边的一条路径（允许多次经过同一个点）。
    
   **判断方法**
    - 若为无向图，则需连通，且图中恰好存在两个点的度数是奇数，其他节点的度数为偶数，这两个度数为奇数的点就是起点与终点；或者所有点度数都是偶数。
    
    - 若为有向图，则需连通，且图中恰好存在一个点入度比出度多一，一个点出度比入度多一，其他节点的出度等于入度；或者所有点入度等于出度。
    
2. **欧拉回路**

    -  定义：起点和终点是一个点的欧拉路径。 

    - 若为无向图，则需连通，且所有点的度数都是偶数。

     - 若为有向图，则需连通，且所有点的入度等于出度
     
在本题中，我们要在一个**有向图**中找到字典序最小的**欧拉路径**。

## Solution

既然是【模板】了,那就直接讲具体做法了。

对于欧拉路径，我们一般采用 **$\mathrm{Hierholzer}$ 算法**

- 首先我们要确定出起点，然后从起点开始不走重复边的递归。

- 对于每一个点,当访问完所有的边时，把这个点加入答案序列。

- 最后，输出答案序列即为一条欧拉路径依次经过的点。

至此,我们可以写出的基本框架了：
```cpp
void dfs(int u){
	for(){ //遍历所有与u相邻的点v 
		if(!vis[v]){   //u与v的这条边没被访问过 
			vis[v]=1;    
			dfs(v);  //递归与u相邻的点v 
		}
	}
	s.push(u); //没有边了,将u进入序列 
}
```
但这样**时间复杂度**是不对的。按照算法，我们不能走重复边，但如果每次都vis判断一遍，则会出现很多次访问同一条边，时间复杂度是不正确的。

#### 处理：

对于任意一个点 $u$ 来说，建完图之后访问边是有顺序的，我们新开一个数组 $delete $ 记录访问到哪个位置即可（即该删除哪个位置）。

这题另一个 ex 的地方还是在于**按照字典序输出** 。
## Code
#### 判断是否有欧拉路径部分：
```cpp

//有向图欧拉路径：一个点入度=出度+1，一个点出度=入度+1，其余点(或所有点)入度=出度
bool flag1=1;//所有点入度是否出度
int sum1=0,sum2=0;//出度-入度=1的数量 和 入度-出度=1的数量 
for(int i=1;i<=n;i++){
	if(chu[i]!=ru[i]){
		flag1=0;
	} 
	if(chu[i]-ru[i]>1){
		cout<<"No";
   	        return 0;
	}
	if(chu[i]-ru[i]==1){
		start=i;
		sum1++;	
	}
	if(ru[i]-chu[i]==1){
		sum2++; 
	} 
}
if(!(flag1==1||(sum1==sum2)&&sum1==1)){
	cout<<"No";
	return 0;
} 
```
#### 邻接矩阵 60pts:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+10;
int ru[N],chu[N],mapp[N][N],n,m;
int delet[N];  //记录该访问(删除)哪个点
stack <int> s;
void dfs(int u){
    for(int v=1;v<=n;v++){ //遍历所有点 
		if(mapp[u][v]>0){  //有边,说明u与v相连 
			mapp[u][v]--; //删边 
			dfs(v);  //递归 
		}
	}
    s.push(u); 
}

int main(){
	cin>>n>>m;
   	int u,v;
	for(int i=1;i<=m;i++){
		cin>>u>>v;
		mapp[u][v]++;  // 邻接矩阵 
		chu[u]++,ru[v]++;  //统计点的出度和入度 
	}
    	int start=1;
	//判断部分
	dfs(start);
	while(!s.empty()){
		cout<<s.top()<<" ";
		s.pop();
	} 
	return 0; 
}
```
为什么这里要提到邻接矩阵呢，因为邻接矩阵有个极大的优点就是**不需要排序**（类似于桶），不用考虑字典序的问题。



### vector 模拟邻接表 100pts

注：vector的排序方法
```cpp
sort(a.begin(),a.end(),cmp);

```


------------
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int ru[N],chu[N],n,m;
stack <int> s;
int delet[N];
vector <int> a[N];
void dfs(int u){
    for(int i=delet[u];i<a[u].size();i=delet[u]){ 
        delet[u]=i+1;
        dfs(a[u][i]); 
    }
    s.push(u); 
}
int main(){
    cin>>n>>m;
    int u,v;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        a[u].push_back(v);
        chu[u]++,ru[v]++;  
    }
    for(int i=1;i<=n;i++){
        sort(a[i].begin(),a[i].end());
    }
    int start=1;  
    bool flag1=1;
    int sum1=0,sum2=0;
    for(int i=1;i<=n;i++){
        if(chu[i]!=ru[i]){
            flag1=0;
        } 
        if(chu[i]-ru[i]>1){
            cout<<"No";
            return 0;
        }
        if(chu[i]-ru[i]==1){
            start=i;
            sum1++; 
        }
        if(ru[i]-chu[i]==1){
            sum2++; 
        } 
    }
    if(!(flag1==1||(sum1==sum2)&&sum1==1)){
        cout<<"No";
        return 0;
    } 
    dfs(start);
    while(!s.empty()){
        cout<<s.top()<<" ";
        s.pop();
    } 
    return 0; 
}








---

## 作者：BetterGodPig (赞：7)

#### Upd 2021.8.4 ：更改时间复杂度的错误。
---

[传送门](https://www.luogu.com.cn/problem/P7771)

简化题意：如果一个图存在一笔画，则一笔画的路径叫做欧拉路，如果最后又回到起点，那这个路径叫做欧拉回路。

我们定义奇点为这个与点相连的边数目为奇数的点。则，对于欧拉路，有以下两个定理（好像小学奥数学一笔画时学过？）。
>定理1：存在欧拉路的条件：图是联通的；图有且只有两个奇点。

>定理2：存在欧拉回路的条件：图是联通的，并且没有奇点。

略证：因为每条边都要经过一次，那么对于欧拉路，处了起点和终点外，每个点如果进入一次，~~显然~~要出去一次，那么这个点就成为了偶点。但如果是欧拉回路，每个点进入和出去次数一定都是相等的，所以没有奇点。证毕。

所以我们只需要分别开两个数组 `in[maxn]` 和 `out[maxn]` 分别记录每个点进入和出去的次数，就可以判断一个图是否存在欧拉（回）路了。代码如下:
```cpp
    bool f=1;
    
    for(int i = 1;i <= n;i++){
        if(out[i] != in[i]){
            f = 0;
        } 
        if(out[i]-in[i] > 1){
        	no
        }
        if(out[i]-in[i] == 1){
            start = i;
            ++cnt1; 
        }
        if(in[i]-out[i] == 1){
            ++cnt2; 
        } 
    }
    if(!(f == 1 || (cnt1 == cnt2) && cnt1 == 1)){
    	no
    }
```
接下来就只需要解决存在欧拉路或欧拉回路时的输出了。根据上文的两个定理，如果存在欧拉回路，就对任何一点执行深度优先搜索（PS：题目要求按字典序输出），如果存在欧拉路，则对奇点执行，时间复杂度为 $O(mlogm+n)$ ，其中 $m$ 为边数，$n$ 为点数。
找到路径后，将路径存入栈中，最后输出即可。

------------
 _**Code：**_ （无注释代码最可爱！）
 ```cpp
#include <bits/stdc++.h>
using namespace std;
#define no puts("No");return 0;
const int maxn=1e5+10;
int in[maxn],out[maxn],n,m,start,cnt1,cnt2;
stack <int> ans;
int cur[maxn];
vector <int> g[maxn];
void dfs(int i){
    for(int j = cur[i];j < g[i].size();j = cur[i]){ 
        cur[i]=j+1;
        dfs(g[i][j]); 
    }
    ans.push(i); 
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
    	int x,y;
        cin>>x>>y;
        g[x].push_back(y);
        ++out[x];
		++in[y];  
    }
    for(int i = 1;i <= n;i++){
        sort(g[i].begin(),g[i].end());
    }
    
    start=1;  
    bool f=1;
    
    for(int i = 1;i <= n;i++){
        if(out[i] != in[i]){
            f = 0;
        } 
        if(out[i]-in[i] > 1){
        	no
        }
        if(out[i]-in[i] == 1){
            start = i;
            ++cnt1; 
        }
        if(in[i]-out[i] == 1){
            ++cnt2; 
        } 
    }
    if(!(f == 1 || (cnt1 == cnt2) && cnt1 == 1)){
    	no
    }
    
    dfs(start);
    
    while(!ans.empty()){
        cout << ans.top() << " ";
        ans.pop();
    }
    return 0; 
}
```

 PS:最开始用领接矩阵储存图，发现数据规模有点大，所以改用 `vector` 辣！

---

## 作者：Utilokasteinn (赞：5)

## [P7771 【模板】欧拉路径](https://www.luogu.com.cn/problem/P7771)

题目大意：

给定一个 $n$ 个点 $m$ 条边的有向图，求该图字典序最小的欧拉路径。

那首先就要理解什么是欧拉路径。

欧拉路径（通路）定义：

> 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。-- OI-Wiki

而存在欧拉路径图被成为半欧拉图（也可能是欧拉图）。

不难发现，在这种图中，**除了起点和终点的点入度等于出度**（进去了就肯定要出来呀）。

而起点的入度比出度少 $1$ （只出不进），终点的出度比入度少 $1$ （只进不出）。

当然也可能是欧拉图，那这样全部点都是入度等于出度。

这样就可以判断起点和终点了：

- 每个点的入度等于出度，即每个点都可以当起点和终点。因为要字典序最小，故选点 $1$。

- 可以作为起点和终点的点数不等于 $2$，即不存在欧拉路径。

- 没有点满足起点或终点，即不存在欧拉路径。

- 否则存在唯一的起点和终点。

然后 dfs 找欧拉路径。注意是字典序最小，所以应该先将边按前往点进行排序，这样 dfs 后所得的欧拉路径就是字典序最小的。所以应用 vector 存储，而不是用邻接表。

在 dfs 时，每经过一条边便将该边标记经过，并记录点。直到每条边都被标记。**然后就会被卡掉……**

正解是记录该点最后一次访问的边的编号，因为前面的边都访问过了，所以就不需要重新遍历一遍都访问过的边。

对与 $n=2,m=2\times10^5$ 的数据，两个点之间一直互相连边，若暴力就会退化成 $O(\frac{m}{2}+\frac{m^2}{4})$,也就是 $O(m^2)$ 的时间复杂度.。而正解保证了同一个点只会访问同一条边一次，只比 $O(m)$ 略高。

最后倒序输出。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,in[100005],out[100005];
int st,ed;
int ans[200010],top;
struct edge{
    edge(int x=0,int y=0){to=x,id=y;}
    int to,id;
}; 
vector<edge>a[100005];
int last[100005];
bool vis[200010];//判断该边是否经过 
inline int read()
{
    int s=0;char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        s=s*10+c-'0';
    return s;
}
bool cmp(edge x,edge y)
{
    return x.to<y.to;//按前往点排序，使字典序最小 
}
void input()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        int u=read(),v=read();
        out[u]++,in[v]++;//入度出度加1 
        a[u].push_back(edge(v,i));
    }
    for(int i=1;i<=n;i++)
        if(in[i]!=out[i])//是起点或终点 
        {
            cnt++;
            if(in[i]+1==out[i])st=i;//起点 
            if(in[i]==out[i]+1)ed=i;//终点 
        }
    if(!cnt)st=ed=1;
    //哪个点都可以作为起点和终点，故选字典序最小的 
    else if(cnt!=2||!st||!ed)//若有多个起点或终点说明没有欧拉路径 
    {
        printf("No");
        exit(0);
    }
    for(int i=1;i<=n;i++)
        sort(a[i].begin(),a[i].end(),cmp);
}
void dfs(int x)
{
    for(int i=0;i<a[x].size();i=max(i,last[x])+1)//遍历边 
        if(!vis[a[x][i].id])
        {
            vis[a[x][i].id]=1;
            last[x]=i;
            dfs(a[x][i].to);
        }
    ans[++top]=x;
}
void print()
{
    for(int i=top;i;i--)//倒序输出 
        printf("%d ",ans[i]);
}
int main()
{
    input();
    dfs(st);
    print();
    return 0;
}
```
谢谢观赏。

---


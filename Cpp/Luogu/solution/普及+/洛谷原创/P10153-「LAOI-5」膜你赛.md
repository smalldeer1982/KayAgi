# 「LAOI-5」膜你赛

## 题目背景

LAOI 团员们出了一场有 $10^{100}$ 道题的 CSP-J 膜你赛！


2025.1.24 本题 Idea 来源为 [xzCyanBrad](/user/380730)。

## 题目描述

比赛是 ICPC 赛制，先以过题数为第一关键字不升排序，再以罚时数为第二关键字不降排序。

有 $n$ 个巨佬前来爆切这场比赛，比赛一共 $m$ 分钟。

在第 $i$ 分钟（$0 \le i \le m-1$）的开始，$s_i$ 号巨佬先提交了 $t_i$ 个 WA 的评测（每个罚时 $x$ 分钟），然后通过了某一道题目。**于是，TA 的通过数增加 $1$，总罚时增加 $x \times t_i + i$ 分钟。**

第 $i$ 个巨佬共有 $k_i$ 个 WA，共过了 $a_i$ 道题（保证 $\sum_{i=1}^n a_i=m$）。为什么巨佬们没有把题目全部切完呢？因为他们觉得题目太简单了，觉得没意思，走了。

如果巨佬 $i$ 在**结束自己的所有提交**之后，发现自己在排行榜上的第一名（**不能并列**），那么称他「爆切比赛」。

试构造数列 $\{s_m\}$ 和 $\{t_m\}$，使得第 $i$ 个巨佬共有 $k_i$ 个 WA，共过了 $a_i$ 道题，且使「爆切比赛」的人数尽量多。

## 说明/提示

### 样例 1 解释

$2$ 分钟时，巨佬 $3$ 结束提交，通过 $3$ 题，罚时 $20 \times 2 + 0 + 1 + 2 = 43$ 分钟。

$5$ 分钟时，巨佬 $2$ 结束提交，通过 $3$ 题，罚时 $20 \times 1 + 3 + 4 + 5 = 32$ 分钟。

$8$ 分钟时，巨佬 $1$ 结束提交，通过 $3$ 题，罚时 $20 \times 0 + 6 + 7 + 8 = 21$ 分钟。

### 数据范围

**不保证数据随机。**

**本题采用捆绑测试。**

|子任务编号|分值|$n,m,x$|
|:--:|:--:|:--:|
|$1$|$10$|$n\le5$，$m \le50$，$x\le5$|
|$2$|$10$|$n\le50$，$m\le500$|
|$3$|$20$|$n\le10^3$，$m \le5\times10^3$|
|$4$|$20$|$x=0$，$k_i=0$|
|$5$|$40$|无特殊限制|

对于 $100\%$ 的数据，保证：

- $m\ge 3n$；
- $3 \le n\le10^5$；
- $9\le m\le 3\times10^5$；
- $0\le x\le 5\times10^4$；
- $0\le k_i \le 4\times10^4$；
- $3\le\color{black} a_i \le 3\times10^5$；
- $\sum ^{n}_{i=1} a_i = m$。


## 样例 #1

### 输入

```
3 9 20
3 3 3
0 1 2```

### 输出

```
3
3 3 3 2 2 2 1 1 1
1 0 1 0 1 0 0 0 0```

## 样例 #2

### 输入

```
3 16 3
5 5 6
2 0 8```

### 输出

```
3
1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 3
0 0 1 0 0 1 1 0 2 1 0 2 0 0 1 1```

# 题解

## 作者：Anemones (赞：3)

贪心构造即可。

先考虑没有罚时的情况，那么根据 ACM 赛制中题目数为第一关键字这一性质，可以发现先让题目数少的大佬先做题更优。

此时我们发现通过第一关键字解出的题目数进行排序后，只需要特殊处理重复的情况，我们先不考虑罚时数，那么我们就要让先离场的做题时间尽可能长，后离场的做题时间尽可能短，比如说有 $\text{ABCD}$ 四个人 $a_i$ 都为 $3$，那么他们的做题顺序应该是 $\text{AABBCCDDDCBA}$，其中最后 $4$ 道题安排了 $\text{DCBA}$ 的离场顺序，而前 $8$ 道题则安排了每个人的做题时间，这种做题顺序在 $3\le a_i$ 的情况下，是绝对满足所有大佬爆切比赛的，所以结果就是 $n$。

考虑到罚时数，还是那个思路，罚时数多的先离场，少的后离场，所以只需排序一下即可，很容易就可以发现，带上罚时数以后只会让结果更优，所以爆切比赛的大佬数还是 $n$。

然后罚时数的输出方法如上。

代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m,qut[300002],wa[300002],ans=0;
ll x,tim[300002];
struct node{
	int id;
	ll a,k;
	friend bool operator <(node x,node y){
		return x.a<y.a||x.a==y.a&&x.k<y.k;
	}
}pl[300002];
int main(){
	scanf("%d%d%d",&n,&m,&x);
	for(int i=1;i<=n;++i)
		scanf("%lld",&pl[i].a);
	for(int i=1;i<=n;++i){
		scanf("%lld",&pl[i].k);
		pl[i].id=i;	
	}
	sort(pl+1,pl+n+1);
	for(int i=1;i<=n;++i) tim[i]=pl[i].k*x;
	int num=0;
	ll cnt=0;
	pl[n+1].a=-1;
	for(int i=1;i<=n;++i){
		wa[cnt+1]=pl[i].k;
		for(int j=1;j<pl[i].a;++j){
			qut[++cnt]=pl[i].id;
			tim[i]+=cnt;
		}
		num++;
		bool flag=0;
		if(pl[i].a!=pl[i+1].a){
			for(int j=i;j>i-num;j--){
				qut[++cnt]=pl[j].id;
				tim[j]+=cnt;
				if(flag){
					flag=0;
					swap(qut[cnt],qut[cnt-1]);
					tim[j]--;
					tim[j+1]=tim[j+2];
				}
				if(j==i) ans++;
				else if(tim[j]<tim[j+1]) ans++;
				else flag=1;
			}
			num=0;	
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=m;++i) printf("%d ",qut[i]);
	printf("\n");
	for(int i=1;i<=m;++i) printf("%d ",wa[i]);

	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：2)

## 思路

关键结论：所有人都能爆切比赛。

下面构造证明。

首先把题数不同的分开，升序排列。这是显然的。

同题数的要求罚时递减。

我们发现有个每人切了至少三个题的条件。考虑怎么用。

如果我们有 AB 两个人，那么放一个 BA 会使 B 罚时比 A 少一分钟，放两个就是少两分钟，最后放一个 AB，结果就是 A 比 B 先结束，但是 B 罚时比 A 少一分钟。

为了避免 WA 题的影响，同过题数的人里面 WA 题数要递减排序。

## code

```cpp
int n,m,x,ans[M],bns[M],p;
struct node
{
	int id,ac,wa;
	inline bool operator<(const node&kkk)const
		{return ac^kkk.ac?ac<kkk.ac:wa>kkk.wa;}
}a[N];
main()
{
	read(n);read(m);read(x);
	for(int i=0;i<n;a[i].id=i+1,read(a[i++].ac));
	for(int i=0;i<n;read(a[i++].wa));
	sort(a,a+n);
	for(int l=0,r;l<n;)
	{
		for(r=l;r<n-1&&a[r+1].ac==a[r].ac;++r);
		for(int i=a[l].ac;--i;)for(int j=r;j>=l;--j)ans[p++]=a[j].id;
		for(;l<=r;++l)ans[p]=a[l].id,bns[p++]=a[l].wa;
	}
	pr(n);pc('\n');
	for(int i=0;i<m;pr(ans[i++]),pc(' '));pc('\n');
	for(int i=0;i<m;pr(bns[i++]),pc(' '));pc(0);
}
```

---

## 作者：H3PO4 (赞：2)

要让「爆切比赛」的人尽量多，过题总数少的人应该先离场。对于过题总数相同的人，罚时大的人应该先离场。

设过题总数都为 $c$ 的 $d$ 个人按 WA 次数 $t_{b_i}$ 升序排为 $b_1,b_2,\dots,b_d$，可以在 $\{s_m\}$ 中排列为 
$$\langle b_1^{c-1} b_2^{c-1} \dots b_{d-1}^{c-1} b_d^{c-1} b_d b_{d-1} \dots b_2 b_1\rangle$$
其中 $x^y$ 表示 $x$ 重复 $y$ 次。$b_i$ 的罚时比 $b_{i-1}$ 多 $(t_{b_i}-t_{b_{i-1}})x+(c-1)^2-1$，
当 $c\ge 3$（即题目所给的范围 ${a_i}\ge 3$）时一定是正数，所以这样安排能使所有人都「爆切比赛」。

在哪些时刻 WA 不影响罚时，可以任意安排。

```cpp
#include<cstdio>
#include<algorithm>
const int N=3e5+10;int a[N],b[N],c[N],s[N];
int main(){
	int n,m,x;scanf("%d%d%d",&n,&m,&x);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=n;i++)scanf("%d",c+i),b[i]=i;
	std::sort(b+1,b+n+1,[](int l,int r)
		{return a[l]!=a[r]?a[l]<a[r]:c[l]<c[r];});
	int f=0;
	for(int i=1;i<=n;){
		int j;
		for(j=i;a[b[j]]==a[b[i]];j++)
			for(int k=1;k<=a[b[i]]-1;k++)s[++f]=b[j];
		int t=j;
		for(j--;j>=i;j--)s[++f]=b[j];
		i=t;
	}
	printf("%d\n",n);
	for(int i=1;i<=m;i++)printf("%d ",s[i]);puts("");
	for(int i=1;i<=m;i++)printf("%d ",c[s[i]]),c[s[i]]=0;puts("");
	return 0;
}
```

---

## 作者：Xlon_WU (赞：1)

## $\large\mathfrak{1st.\ Preamble|}$ 前言

[题目传送门](https://www.luogu.com.cn/problem/P10153) & [更好的阅读体验](https://xlon-wu.github.io/2024/09/21/solution-luogu-P10153/)。

一道有趣的构造题。

## $\large\mathfrak{2nd.\ Solution|}$ 题解

### 基本思路

【因为】以过题数为第一关键字不升排序，\
【所以】过题数数少的先离场。

【因为】以罚时数为第二关键字不降排序，\
【所以】同过题数，罚时多的先离场。

【所以】存在一种构造能使所有人「爆切比赛」。

### 构造方法

把所有人按题目要求排序。

过题数相同的人合在一块，把这些块按每一块的过题数递增排列。

对于每一块内，我们把每人按 WA 数从大到小安排离场顺序。

**错误的构造方法**：直接给每个人都安排一段单独的连续时间交题离场。

例如：

+ 小 A 通过 $6$ 题，WA 了 $10$ 次；小 B 通过 $6$ 题，WA 了 $9$ 次；$x=1$；按照上面的方法构造。

+ 小 A 在第 $6$ 分钟通过了 $6$ 题，总罚时数 $10x+6=16$​。
+ 小 B 在第 $12$ 分钟通过了 $6$ 题，总罚时数 $9x+12=21$​。
+ $21>16$，小 B 没有「爆切比赛」。

【所以】我们需要让先离场的罚时尽可能大，后离场的罚时尽可能小，

【所以】**先离场的后开始交，后离场的先开始交。**

听着有点绕，请看正确的构造方法。

**正确的构造方法**：

+ WA **少**的**先**提交，WA **多**的**后**提交，
+ 每个人**留一题**到最后，WA **多**的**先**交完最后一题离场，WA **少**的**后**提交最后一题再离场。

这样就可以保证前面离场的罚时大于后面离场的。

## $\large\mathfrak{3rd.\ Code|}$ 代码

排序方式清奇请见谅（因为懒得写结构体（雾。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define FILE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout);
using namespace std;
const int N = 1e5 + 10, M = 3e5 + 10;
int n, m, x, a[N], k[N], p[N], s[M], t[M], cnt;
inline bool cmp(int x, int y) {
    if (a[x] == a[y]) return k[x] > k[y];
    return a[x] < a[y];
}
int main() {
    // clock_t Start_Time=clock();
    // ios::sync_with_stdio(false);
    // cin.tie(0),cout.tie(0);
    cin >> n >> m >> x;
    cout << n << endl;
    for (int i = 1; i <= n; p[i] = i, i ++) cin >> a[i];
    for (int i = 1; i <= n; i ++) cin >> k[i];
    sort(p + 1, p + n + 1, cmp);
    for (int i = 1; i <= n; i ++) {
        int q = i;
        for (; q <= n && a[p[q]] == a[p[q + 1]]; q ++) ;
        for (; q >= i; q --) 
            for (int j = 1; j < a[p[q]]; j++)   // 这里是小于号！因为还要留一题。
                s[++ cnt] = p[q];			    // 后离场先开做。
        for (; i <= n && a[p[i]] == a[p[i + 1]]; i ++) 
            s[++ cnt] = p[i], t[cnt] = k[p[i]]; // 留一题最后交。
        s[++ cnt] = p[i], t[cnt] = k[p[i]];
    }
    for (int i = 1; i <= cnt; i ++) cout << s[i] << " ";
    cout << endl;
    for (int i = 1; i <= cnt; i ++) cout << t[i] << " ";
    // cout<<"\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nRuntime: "<<clock()-Start_Time<<" ms\n";
    // system("pause");
    return 0;
}
```

---

## 作者：ycy1124 (赞：0)

### 思路
由于此题是先按照通过的题目数量不降排序的，所以我们考虑先让过题数量少的选手先走。因此我们会将所有的选手按通过的题目的数量分成很多段，让通过题目数量较少的那一段的选手先走，不难发现由于后面每一段的选手的过题数量相同所以对他们来说并没有影响。

考虑一段内如何安排做题顺序。我们肯定是要让罚时数量比较多的选手先走来避免比前面的选手时间更长。但是这时又出现了一个问题，如果罚时数量较多的选手走了之后，由于他的提交都在比较前面，有可能会导致后面的罚时数量小于等于他的选手花的时间比他长。我们希望使罚时数量小于等于一个选手的最终用时比这个选手的最终用时更短。观察一下数据范围，发现每个选手至少都切了三题。为什么一定要切至少三题呢，我们发现，如果我们让通过数量相同的选手除了最后一次提交，其余的提交都让罚时数量较少的选手先交，就一定可以保证罚时数量少的选手的最终用时小于罚时数量大的选手。因为前面 $a_i-1$ 次提交罚时少的选手拉开罚时多的选手的时间至少是最后一次提交罚时多的选手拉开罚时少的选手的时间的两倍及以上。

于是这题就做完了。
### 代码
```cpp
#include<bits/stdc++.h>
#define flush() fwrite(obuf,1,O-obuf,stdout)
#define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
__inline__ int read(){
	register int x=0;
	register char ch=getchar();
	while(!(ch>='0'&&ch<='9'))
		ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+(ch^48),ch=getchar();
	return x;
}
__inline__ void write(register long long x){
    (x>9)?write(x/10):void();
    putchar((x%10)^48);
}
struct Flush{
    ~Flush(){flush();}
}_;
#define N 100000 + 39
using namespace std;
struct Node
{
	int a, k, id;
}a[N];
int n, m, x;
vector<int>ans,Ans;
inline bool cmp(Node x1, Node x2)
{
	return x1.a == x2.a ? x1.k > x2.k : x1.a < x2.a;
}//按通过数为第一关键字，罚时为第二关键字排序
int main()
{
	ios :: sync_with_stdio(0), cin.tie(0), cout.tie(0);
	n = read(), m = read(), x = read();
	for(int i = 1; i <= n; i ++)
	{
		a[i].a = read();
	}
	for(int i = 1; i <= n; i ++)
	{
		a[i].k = read();
		a[i].id = i;
	}
	sort(a + 1, a + n + 1, cmp);
	int l = 1, r;
	for(int i = 1; i <= n + 1; i ++)
	{
		if(a[i].a == a[l].a)
		{
			r = i;
		}
		else
		{
			for(int j = r; j >= l; j --)
			{
				for(int k = 1; k < a[l].a; k ++)//对于这一段选手，罚时少的先交
				{
					ans.push_back(a[j].id);
					Ans.push_back(0);
				}
			}
			for(int j = l; j <= r; j ++)//最后提交罚时多的先交
			{
				ans.push_back(a[j].id);
				Ans.push_back(a[j].k);
			}
			l = i;
			r = i;
		}
	}
	write(n);
	putchar('\n');
	for(auto it : ans)
	{
		write(it);
		putchar(' ');
	}
	putchar('\n');
	for(auto it : Ans)
	{
		write(it);
		putchar(' ');
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/231725313)。

---

## 作者：lcycl (赞：0)

# 前文
发现构造题还能写题解，赶紧水一发。  
[传送门](https://www.luogu.com.cn/problem/P10153)   
# 题目大意 
给出巨佬们每题 WA 的次数，要求构造巨佬做题的顺序和答案情况（WA 几次），使巨佬做完题时，发现自己为第一名的最大人数。  
# 思路
首先，我们要知道巨佬「爆切比赛」的人数最大是多少。我们可以发现，在最优情况下时（罚时最多的人第一个交完，罚时最少的最后交完，中间的人以此类推），所有巨佬都能「爆切比赛」。所以，我们的任务转换为了如何构造这样一个序列。我们分几步解决。  
+ WA 的数量和提交时间。这两个因素决定了巨佬这道题的罚时。我们可以把 WA 最多的巨佬的题目放在最后，罚时最少的放在最前，这样，我们就可以抛开提交时间这个因素，可以看成罚时只会由 WA 的数量决定。
+ 做题数。我们的任务是要让每个巨佬都「爆切比赛」。但是那些 WA 数量多的巨佬们已经被我们抛在了后面，罚时数很高（巨佬：QWQ），所以，那些巨佬只能在做题数上超越其他人。我们可以把所有人的最后一题提交单独拿出来排序，按 WA 的数量多少来排（WA 数量越多，排越前）。这样，罚时多的巨佬们做完题发现自己是做完题里的人中罚时数最少的，排第一。

这样，我们就成功构造出了序列，巨佬们都成功「爆切比赛」力！
# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,tot,k;
struct shenniu{
	int i,a,w;
}mb[114514];
struct num{
	int id,cp;
}kkk[1114514];
bool cmp(shenniu x,shenniu y){
	return x.a==y.a?x.w<y.w:x.a<y.a;
}//自定义排序函数
void ki(int k){
	kkk[tot].id=mb[k].i;
}//有重复，封装函数使代码简洁
void kw(int k){
	kkk[tot].cp=mb[k].w;
}//同上
signed main() {
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++){cin>>mb[i].a;mb[i].i=i;}
	for(int i=1;i<=n;i++) cin>>mb[i].w;//读入
	sort(mb+1,mb+n+1,cmp);//排序
	for(int i=1;i<=n;i++){
		for(int j=1;j<mb[i].a;j++){
			++tot;
			ki(i);
		}
		if(mb[i].a!=mb[i+1].a){
			++tot;
			ki(i);
			kw(i);
			k=i-1;
			while(mb[k].a==mb[k+1].a&&k>0) {
				++tot;
				ki(k);
				kw(k);
				--k;
			}//判AC数相同
		}
	}
	cout<<n<<"\n";
	for(int i=1;i<=m;i++) cout<<kkk[i].id<<" ";
	cout<<"\n";
	for(int i=1;i<=m;i++) cout<<kkk[i].cp<<" ";
	//输出
	return 0;
}
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10153)

## 思路
由于以过题数为第一关键字排序，所以可以将切题数少的大佬放在前面，多的放在后面。切题数相同的，WA 多的在前，WA 少的在后，这样每个大佬都能爆切比赛。但是这样做是错的（由于 WA 少的大佬后交题，所以罚时可能会比 WA 多的大佬还高，这样原来的构造方法就错了）。

正确的构造应该让通过数相同的大佬 WA 少的先交，WA 多的后交，但是都留一题到最后交，最后让 WA 多的先交，WA 少的后交，这样全部大佬就都可以爆切比赛了。
### 正确性证明

由于 WA 最多的第一个交最后一题，所以过题数最多，能爆切比赛；后交最后一题的大佬由于前面先交，所以罚时少，同样能爆切比赛。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct person {
	int wa,ac,id;
} a[114514];
bool cmp(person x,person y) {
	if(x.ac==y.ac)return x.wa<y.wa;
	else return x.ac<y.ac;
}
int n,m,x,cnt;
int s[314514],t[314514];
int main() {
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++)a[i].id=i;
	for(int i=1; i<=n; i++)cin>>a[i].ac;
	for(int i=1; i<=n; i++)cin>>a[i].wa;
	sort(a+1,a+n+1,cmp);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<a[i].ac; j++)s[++cnt]=a[i].id;
		if(a[i].ac!=a[i+1].ac) {
			s[++cnt]=a[i].id;
			t[cnt]=a[i].wa;
			int j=i-1;
			while(a[j].ac==a[j+1].ac&&j>0) {
				s[++cnt]=a[j].id;
				t[cnt]=a[j].wa;
				j--;
			}
		}
	}
	cout<<n<<endl;
	for(int i=1; i<=m; i++)cout<<s[i]<<" ";
	cout<<endl;
	for(int i=1; i<=m; i++)cout<<t[i]<<" ";
}
```

---

## 作者：ICU152_lowa_IS8 (赞：0)

一道有点难度的构造题。

观察题目，如果一位巨佬在**自己**的代码全部提交完之后排在 rk1，那么他就满足条件。

那么很显然，第一步：

以 $a_i$ 为关键字排序，尽量让通过题目数少的在前面评测完（放在后面就可能丢失成为第一的机会，同时放在前面对后面通过题目数更多的人没有影响）。

经过第一步，我们处理完了 $a_i$ 不相等的情况，把数组划分成了一个一个 $a_i$ 相等的群，那么到这一步怎么处理？

第二步，对于每一个群：

首先，$1\sim a_i-1$ 次评测的**结果**对结果没有影响，因此可以全部放在前面，每个人的第 $a_i$ 次评测单独放在后面；

对于第 $a_i$ 次评测，可以得到一个序列，序列靠前的先评测完。在这一步，考虑贪心：由于靠前的时间越长对越靠后的越有利，故最后一次评测越靠前的，其余评测应当越靠后。

那么最后一个序列如何生成？

根据“靠前的时间越长对越靠后的越有利”这一条，很容易得出按 $k_i$ 从大到小排序的结论。

至此，我们完成了对 $s$ 数组的处理，那么 $t$ 数组呢？

显然的，在 $s_i$ 确定的情况下，无论你怎么颠来倒去换 $t_i$，总的罚时（不考虑顺序，因为 $s_i$ 确定）都是 $k_i\times x$，因此任意一种放法均可。

把每一个群的结果按照第一步的顺序拼在一起，即得到了我们最终需要的结果。然后对结果数组跑一遍，就可以得到最多有多少个巨佬可以满足条件。

上代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int ai,ki,id;
}a[1000005];
bool cmp(node a,node b){
	if(a.ai==b.ai)return a.ki>b.ki;
	return a.ai<b.ai;
}
int s[1000005],t[1000005],p,cnt[1000005],cnt2[1000005];
bool Cmp(node a,node b){
	return a.id<b.id;
}
signed main(){
	ios::sync_with_stdio(false);
	int n,m,x;
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++){
		cin>>a[i].ai;
		a[i].id=i;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].ki;
	}
	sort(a+1,a+n+1,cmp);
	int now=1;
	for(int i=1;i<=n;i=now){
		while(a[i].ai==a[now].ai){
			now++;
		}
		now--;
		int j;//划分群
		for(j=1;j<a[i].ai;j++){
			for(int k=now;k>=i;k--){//这里是一轮一轮放置的，可以证明在结果上和按j一块一块放完全等价
				s[++p]=a[k].id;
			}
		}
		for(int k=i;k<=now;k++){
			s[++p]=a[k].id;
		}
		now++;
	}
	sort(a+1,a+n+1,Cmp);
	int mk=LLONG_MAX,ma=0,ans=0;
	for(int i=1;i<=m;i++){
		t[i]=a[s[i]].ki;
		cnt2[s[i]]+=a[s[i]].ki*x;
		a[s[i]].ki=0;
		cnt[s[i]]++;
		cnt2[s[i]]+=i;
		if(cnt[s[i]]==a[s[i]].ai){
			if(a[s[i]].ai>ma){
				ans++;
				ma=a[s[i]].ai;
				mk=cnt2[s[i]];
			}
			else if(a[s[i]].ai==ma&&cnt2[s[i]]<mk){
				mk=cnt2[s[i]];
				ans++;
			}
		}
	}
	cout<<ans<<endl;
	for(int i=1;i<=m;i++)cout<<s[i]<<" ";
	cout<<endl;
	for(int i=1;i<=m;i++)cout<<t[i]<<" ";
	return 0;
}
/*
10 40 0
1 1 4 5 1 4 5 4 4 11
1 1 4 5 1 4 1 9 1 9
*/
```


---

## 作者：Shadow_T (赞：0)

### 题目分析

简单贪心。

我们先来看看第 $4$ 个子任务，考虑不存在 WA 罚时的情况。很明显，要让「爆切比赛」的人尽量多，那么过题数量少的人就要先提交题目，成功「爆切比赛」。但是对于过题数一样为 $d$ 的人，我们可以使用提交时间的罚时来拉开差距。可以先让他们先**以一定的顺序**过掉 $d-1$ 个题目，然后在**倒序**过掉最后 $1$ 题。对于 $a_i \geq 3$ 的情况这个策略就是最优的。

然后考虑加上罚时的情况，那么就要那么过题数量少且罚时数尽量小的人就要先提交题目，成功「爆切比赛」。按照刚刚的策略在提交一遍，然后把罚时全部丢最后 $1$ 发，不会影响答案。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
const int maxm=3e5+10;
int f[maxm];
int t[maxn];
struct st
{
	int AC,fs;
	int id;
}a[maxn];
bool cmp(st a,st b)
{
	if(a.AC==b.AC) return a.fs<b.fs;
	return a.AC<b.AC;
}
int main()
{
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i].AC);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i].fs),a[i].id=i;
    sort(a+1,a+1+n,cmp);
    cout<<n<<"\n";
    vector<int> v;
    v.push_back(1);
    int times=0;
    for(int i=2;i<=n;i++)
    {
    	if(a[i].AC!=a[i-1].AC)
    	{
    		for(int i=0;i<v.size();i++)
    		for(int j=1;j<a[v[i]].AC;j++)
    		cout<<a[v[i]].id<<" ",times++;
    		for(int j=v.size()-1;j>=0;j--)
    		cout<<a[v[j]].id<<" ",times++,f[times]=a[v[j]].fs;
    		v.clear();
		}
		v.push_back(i);
	}
	for(int i=0;i<v.size();i++)
    for(int j=1;j<a[v[i]].AC;j++)
	cout<<a[v[i]].id<<" ",times++;
    for(int j=v.size()-1;j>=0;j--)
    cout<<a[v[j]].id<<" ",times++,f[times]=a[v[j]].fs;
    cout<<"\n";
    for(int i=1;i<=m;i++)
    cout<<f[i]<<" ";
}
```

---


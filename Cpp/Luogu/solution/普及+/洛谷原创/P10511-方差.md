# 方差

## 题目背景

定义一个长度为 $n$ 的序列 $a$ 的方差为：

$$s^2=\frac{1}{n} \sum_{i=1}^n (a_i-\overline{a})^2$$

其中：$\sum$ 为累加求和符号，例如 $\sum_{i=1}^5 a_i=a_1+a_2+a_3+a_4+a_5$。$\overline{a}$ 为序列 $a$ 的平均数。

例如对于序列 $\{3,5,1,4,2\}$，$\overline{a}=3$，此时 $s^2=\frac{1}{n} \sum_{i=1}^n (a_i-\overline{a})^2=\frac{1}{5}[(3-3)^2+(5-3)^2+(1-3)^2+(4-3)^2+(2-3)^2]=2$。

## 题目描述

小 S 认为数学很简单，于是小 R 想要考考她。

小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。

现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。

由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\cdot s^2\bmod 998244353$。可以证明 $(r-l+1)^2\cdot s^2$ 一定是整数。

作为小 S 的好朋友，你能帮帮她吗？

## 说明/提示

**【样例解释】**

序列 $a$ 为 $\{ 5, 7, 8, 8, 8 \}$。对于第 $12$ 组询问，区间 $[3, 5]$ 的平均数 $\overline{a} = 8$，方差 $s^2 = \frac{1}{3} [(8 - 8)^2 + (8 - 8)^2 + (8 - 8)^2] = 0$。

**【数据范围】**

- 对于 $20\%$ 的数据，保证 $n,q\leq 100$。
- 对于 $50\%$ 的数据，保证 $n\leq 10^6$，$m\leq 10^3$。
- 对于另外 $10\%$ 的数据，保证 $r_i-l_i\leq 1000$，$q \leq 10^4$。
- 对于另外 $10\%$ 的数据，保证 $m\leq 10^3$。

对于所有数据，保证：
- $1\leq l_i\leq r_i\leq n\leq 10^{18}$，$1\leq m\leq \min(n,2\times 10^5)$，$1\leq q\leq 2\times 10^5$，$1\leq x\leq y\leq n$，$1\leq b_i\leq 10^{18}$。
- 数据保证对于任意 $i<j$，$l_i<l_j$，且 $[l_i,r_i]$ 与 $[l_j,r_j]$ 不存在交集，即 $[l_i,r_i]\cap[l_j,r_j]=\varnothing$。
- 数据保证，若将所有的 $[l_i,r_i]$ 取并集，则其覆盖了 $[1,n]$ 上所有的正整数。即：$\bigcup_{i=1}^n[l_i,r_i] \cap \Z=[1,n] \cap \Z$。

## 样例 #1

### 输入

```
5 3 15
1 1 5
2 2 7
3 5 8
1 1
1 2
1 3
1 4
1 5
2 2
2 3
2 4
2 5
3 3
3 4
3 5
4 4
4 5
5 5```

### 输出

```
0
4
14
24
34
0
1
2
3
0
0
0
0
0
0
```

# 题解

## 作者：Rigel (赞：19)

## 思路

数学题。

对于区间 $[l,r]$，设 $m=r-l+1$，则：

$
\begin{aligned}
m^2s^2&=m\sum\limits_{i=l}^{r}(a_i-\overline{a})^2\\
&=m\sum\limits_{i=l}^{r}(a_i^2-2a_i\overline{a}+\overline{a}^2)\\
&=m\left(\sum\limits_{i=l}^{r}a_i^2-2\sum\limits_{i=l}^{r}a_i\overline{a}+\sum\limits_{i=l}^{r}\overline{a}^2\right)\\
&=m\left(\sum\limits_{i=l}^{r}a_i^2-\frac{2}{m}\left(\sum\limits_{i=l}^{r}a_i\right)^2+\frac{1}{m}\left(\sum\limits_{i=l}^{r}a_i\right)^2\right)\\
&=m\sum\limits_{i=l}^{r}a_i^2-2\left(\sum\limits_{i=l}^{r}a_i\right)^2+\left(\sum\limits_{i=l}^{r}a_i\right)^2\\
&=m\sum\limits_{i=l}^{r}a_i^2-\left(\sum\limits_{i=l}^{r}a_i\right)^2.
\end{aligned}
$

不难发现，维护**区间和**与**区间平方和**即可。

利用前缀和维护区间和与区间平方和。查询时，利用 `upper_bound()` 找到完全包含查询区间的区间，计算区间和与区间平方和，分别减去两边多余的部分，最后计算方差。

## 代码

取模使用 `modint`。

特别地，`l` 数组与 `r` 数组应存储原始值。

```cpp
#include<bits/stdc++.h>
#define int long long
#define TT 998244353
#define M(x) (modint){x}
#define maxm 200010
using namespace std;
int n,m,q,l[maxm],r[maxm];
struct modint{
	int v;
	bool operator<(const modint &b)const{return v<b.v;}
	modint operator+(const modint &b)const{return (modint){(v+b.v)%TT};}
	modint operator-(const modint &b)const{return (modint){((v-b.v)%TT+TT)%TT};}
	modint operator*(const modint &b)const{return (modint){(v*b.v)%TT};}
}b[maxm],s1[maxm],s2[maxm],ans; 
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')ret=ret*10+(ch&15),ch=getchar();
	return ret*f;
}
signed main(){
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)l[i]=read(),r[i]=read(),b[i].v=read()%TT;
	for(int i=1;i<=m;i++){
		s1[i]=s1[i-1]+b[i]*M((r[i]-l[i]+1)%TT);
		s2[i]=s2[i-1]+b[i]*b[i]*M((r[i]-l[i]+1)%TT);
	}
	while(q--){
		modint S1={0},S2={0};
		int x=read(),y=read();
		int L=upper_bound(l+1,l+m+1,x)-l-1;
		int R=upper_bound(l+1,l+m+1,y)-l-1;
		if(L<=R){
			S1=S1+s1[R]-s1[L-1];
			S2=S2+s2[R]-s2[L-1];
		}
		if(l[L]!=x){
			S1=S1-b[L]*M((x-l[L])%TT);
			S2=S2-b[L]*b[L]*M((x-l[L])%TT);
		}
		if(r[R]!=y){
			S1=S1-b[R]*M((r[R]-y)%TT);
			S2=S2-b[R]*b[R]*M((r[R]-y)%TT);
		}
		ans=M((y-x+1)%TT)*S2-S1*S1;
		printf("%lld\n",ans.v);
	}
	return 0;
}
```

---

## 作者：tder (赞：12)

令 $m=r-l+1$，不难有：

$$
\begin{aligned}
m^2\cdot s^2
&=m^2\cdot\frac1m\sum_{i=l}^r(a_i-\overline{a})^2 \\
&=m\sum_{i=l}^r(a_i^2-2a_i\overline{a}+\overline{a}^2) \\
&=m\left(\sum_{i=l}^r a_i^2-2\cdot\overline{a}\sum_{i=l}^r a_i+m\cdot\overline{a}^2\right)
\end{aligned}
$$

根据定义，将 $\displaystyle\overline{a}=\dfrac{1}{m}\cdot\sum_{i=l}^r a_i$ 代入，得：

$$
\begin{aligned}
m^2\cdot s^2
&=m\left(\sum_{i=l}^r a_i^2-2\cdot\overline{a}\sum_{i=l}^r a_i+m\cdot\overline{a}^2\right) \\
&=m\left(\sum_{i=l}^r a_i^2-2\cdot\left(\dfrac{1}{m}\cdot\sum_{i=l}^r a_i\right)\cdot\sum_{i=l}^r a_i+m\cdot\left(\dfrac{1}{m}\cdot\sum_{i=l}^r a_i\right)^2\right) \\
&=m\left(\sum_{i=l}^r a_i^2-\dfrac{2}{m}\cdot\left(\sum_{i=l}^r a_i\right)^2+\dfrac{1}{m}\cdot\left(\sum_{i=l}^r a_i\right)^2\right) \\
&=m\cdot\sum_{i=l}^r a_i^2-\left(\sum_{i=l}^r a_i\right)^2 \\
\end{aligned}
$$

观察到仅需维护区间和以及区间平方和即可，不难想到使用前缀维护。唯一问题是本题中是区间赋值，故不能用传统方式。

不妨举个例子来说明一下，将形如 $\text{A}$ 和 $\text{B}$ 等称作一个「赋值区间」：

![](https://cdn.luogu.com.cn/upload/image_hosting/yml9qqah.png)

此时 $(l_i,r_i)\in\{(1,4),(5,7),(8,8),(9,12)\}$。

若查询区间 $[p,q]=[2,10]$ 的方差，我们仅需知道该区间内的元素之和以及平方和即可。

观察到其中包含若干个完整的赋值区间（在本例中是 $\text{B}$ 和 $\text{C}$），以及一个在开头位置的不完整的赋值区间（在本例中是 $\text{A}$）和一个在结尾位置的不完整的赋值区间（在本例中是 $\text{D}$）。

不妨令开头和结尾处的不完整区间的编号分别为 $x$ 和 $y$，观察到给定的赋值区间序列是单调的，故可以通过二分在 $O(\log m)$ 的复杂度内求出其编号。

对于完整赋值区间部分，可以预处理出前缀 $\displaystyle c_i=\sum_{j=1}^{r_i}a_j$，若朴素处理复杂度为 $O(n)$ 是不可取的。考虑变形成 $\displaystyle\sum_{j=1}^{i}(r_i-l_i+1)\cdot b_j$，即每个赋值区间内元素的和加起来，这么做是 $O(m)$ 的，可以接受。那么完整区间部分的区间和即为 $c_{y-1}-c_{x}$。

而对于开头结尾的不完整部分，显然的，区间和分别为 $(r_x-p+1)\cdot b_x$ 和 $(p-l_y+1)\cdot b_y$。

综上，区间 $[p,q]$ 中元素之和为：

$$
\sum_{i=p}^qa_i=(c_{y-1}-c_{x})+(r_x-p+1)\cdot b_x+(p-l_y+1)\cdot b_y
$$

区间平方和同理。

于是可以用 $O(m)$ 预处理，加上 $O(\log m)$ 的单次查询，总复杂度 $O(m+q\log m)$。

具体实现时可用 modint，注意特判 $x=y$ 的情况。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e6 + 5, M = 998244353;
template<int Mod, int Value = (int)1e18>
class Modint {
	public:
		int v = 0, V = Mod;
		Modint(int x = 0): v(x % Mod) {
			V = (Value / Mod + 1) * Mod;
		};
		operator int() {
			return v;
		}
		Modint operator+(int x) {
			return (v + x + V) % Mod;
		}
		Modint operator-(int x) {
			return (v - x + V) % Mod;
		}
		Modint operator*(int x) {
			return (v * x + V) % Mod;
		}
		Modint operator/(int x) {
			return (v / x + V) % Mod;
		}
		Modint operator%(int x) {
			return v % x;
		}
		Modint operator&(int x) {
			return ((v & x) + V) % Mod;
		}
		Modint operator|(int x) {
			return ((v | x) + V) % Mod;
		}
		Modint operator^(int x) {
			return ((v ^ x) + V) % Mod;
		}
		Modint operator~() {
			return (~v + V) % Mod;
		}
		Modint operator++(signed x) {
			auto p = *this;
			*this = *this + 1;
			return p;
		}
		Modint& operator++() {
			*this = *this + 1;
			return *this;
		}
		Modint operator--(signed x) {
			auto p = *this;
			*this = *this - 1;
			return p;
		}
		Modint& operator--() {
			*this = *this - 1;
			return *this;
		}
		Modint operator+=(int x) {
			*this = *this + x;
			return *this;
		}
		Modint operator-=(int x) {
			*this = *this - x;
			return *this;
		}
		Modint operator*=(int x) {
			*this = *this * x;
			return *this;
		}
		Modint operator/=(int x) {
			*this = *this / x;
			return *this;
		}
		Modint operator%=(int x) {
			*this = *this % x;
			return *this;
		}
		Modint operator&=(int x) {
			*this = *this & x;
			return *this;
		}
		Modint operator|=(int x) {
			*this = *this | x;
			return *this;
		}
		Modint operator^=(int x) {
			*this = *this ^ x;
			return *this;
		}
};
#define mint Modint<M>
int n, m, q, l[N], r[N]; mint b[N], c1[N], c2[N];
signed main() {
	cin>>n>>m>>q;
	for(int i = 1; i <= m; i++) {
		int x, y, z; cin>>x>>y>>z;
		l[i] = x, r[i] = y, b[i] = z;
	}
	for(int i = 1; i <= m + 1; i++) c1[i] = c1[i - 1] + b[i] * mint(r[i] - l[i] + 1);
	for(int i = 1; i <= m + 1; i++) c2[i] = c2[i - 1] + b[i] * b[i] * mint(r[i] - l[i] + 1);
	while(q--) {
		int i, j; cin>>i>>j;
		int x = upper_bound(l + 1, l + m + 1, i) - l - 1, y = upper_bound(l + 1, l + m + 1, j) - l - 1;
		mint s1, s2;
		if(x != y) s1 = (c1[y - 1] - c1[x]) + b[x] * mint(r[x] - i + 1) + b[y] * mint(j - l[y] + 1);
		else s1 = b[x] * mint(j - i + 1);
		if(x != y) s2 = (c2[y - 1] - c2[x]) + b[x] * b[x] * mint(r[x] - i + 1) + b[y] * b[y] * mint(j - l[y] + 1);
		else s2 = b[x] * b[x] * mint(j - i + 1);
		cout<<s2 * mint(j - i + 1) - s1 * s1<<endl;
	}
}
```

---

## 作者：Flanksy (赞：4)

### 数学、前缀和

------------

看到方差，首先想到方差等于**平方的平均数**减去**平均数的平方**。因为连乘的形式不好维护，而上边两个量可以用前缀和轻松维护。

题目给的定义式很显然没用，所以需要记结论或者推式子。

$$\frac{1}{n} \sum\limits^{n}_{i=1} (a_{i}-\overline{a})^{2}= \frac{1}{n} \sum\limits^{n}_{i=1} (a_{i}^{2} - 2a_{i}\overline{a} + \overline{a}^{2}) = \frac{1}{n} \sum\limits^{n}_{i=1} a_{i}^{2} - \frac{1}{n} \sum\limits^{n}_{i=1} 2a_{i}\overline{a} + \frac{1}{n} \sum\limits^{n}_{i=1} \overline{a}^{2}$$

而

$$\frac{1}{n} \sum\limits^{n}_{i=1} a_{i}^{2} = \overline{a^{2}}$$

$$\frac{1}{n} \sum\limits^{n}_{i=1} 2a_{i}\overline{a} = 2 \overline{a} \times \frac{1}{n} \sum\limits^{n}_{i=1} a_i = 2 \overline{a} \times \overline{a} = 2 \overline{a}^{2}$$

$$\frac{1}{n} \sum\limits^{n}_{i=1} \overline{a}^{2} = \overline{a}^{2}$$

所以

$$\frac{1}{n} \sum\limits^{n}_{i=1} a_{i}^{2} - \frac{1}{n} \sum\limits^{n}_{i=1} 2a_{i}\overline{a} + \frac{1}{n} \sum\limits^{n}_{i=1} \overline{a}^{2} = \overline{a^{2}} - 2 \overline{a}^{2} + \overline{a}^{2} = \overline{a^{2}} - \overline{a}^{2}$$

也就是**平方的平均数**减去**平均数的平方**的形式。

按照值是否相同把给出的序列分成 $m$ 个块，预处理得到前缀和信息，二分出左右边界计算即可，注意左右边界在一个块的情况。此外给定的元素上界为 $10^{18}$，计算前应当先行取模。题目所求的答案乘上了区间长度，所以不需要乘法逆元。

由于 $m,q$ 同阶，时间复杂度 $O(m \log m)$。

代码里直接把 $n$ 扔了，题目中的 $m$ 是代码中的 $n$，题目中的 $q$ 是代码里的 $m$。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int mod=998244353;
long long a[1000005],sum[1000005],squ[1000005],p[2000005];
int n,m,pos;
inline long long sq(long long x){return x*x%mod;}
int main(){
    scanf("%*d%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        static long long x,l,r;
        scanf("%lld%lld%lld",&l,&r,&x);
        x%=mod,a[i]=x,p[++pos]=l,p[++pos]=r;
        sum[i]=(r-l+1)%mod*x%mod;
        squ[i]=(r-l+1)%mod*sq(x)%mod;
    }
    for(int i=1;i<=n;i++) sum[i]=(sum[i-1]+sum[i])%mod;
    for(int i=1;i<=n;i++) squ[i]=(squ[i-1]+squ[i])%mod;
    for(int i=1;i<=m;i++){
        static long long l,r,pl,pr;
        scanf("%lld%lld",&l,&r);
        pl=lower_bound(p+1,p+pos+1,l)-p;
        pr=lower_bound(p+1,p+pos+1,r)-p;
        pl+=pl&1,pr+=pr&1,pl>>=1,pr>>=1;
        if(pl!=pr){
            static long long mid,msq,ans;
            mid=(sum[pr-1]-sum[pl])%mod;
            mid=(mid+(p[pl*2]-l+1)%mod*a[pl])%mod;
            mid=(mid+(r-p[pr*2-1]+1)%mod*a[pr])%mod;
            msq=(squ[pr-1]-squ[pl])%mod;
            msq=(msq+(p[pl*2]-l+1)%mod*sq(a[pl]))%mod;
            msq=(msq+(r-p[pr*2-1]+1)%mod*sq(a[pr]))%mod;
            ans=((r-l+1)%mod*msq-sq(mid))%mod;
            ans=(ans+mod)%mod;
            printf("%lld\n",ans);
        }
        else puts("0");
    }
    return 0;
}
```

---

## 作者：what_can_I_do (赞：3)

[传送门](https://www.luogu.com.cn/problem/P10511)

首先就是推式子。

令 $v=\sum_{i=1}^n a_i$。

$$\frac{1}{n}\sum_{i=1}^n(a_i-\frac{v}{n})^2=\frac{1}{n}\sum_{i=1}^n(a_i^2+\frac{v^2}{n^2}-2\times a_i\times\frac{v}{n})=\frac{1}{n}(\sum_{i=1}^n\frac{v^2}{n^2}+\sum_{i=1}^na_i^2-\sum_{i=1}^n2\times a_i\times\frac{v}{n})$$

令 $u=\sum_{i=1}^n a_i^2$。

$$\frac{1}{n}(\sum_{i=1}^n\frac{v^2}{n^2}+\sum_{i=1}^na_i^2-\sum_{i=1}^n2\times a_i\times\frac{v}{n})=\frac{v^2}{n^2}+\frac{u}{n}-\frac{2\times v^2}{n^2}=\frac{u\times n-v^2}{n^2}$$

$$\frac{u\times n-v^2}{n^2}\times n^2=u\times n-v^2$$

这时可以发现如果忽略掉 $x$ 和 $y$ 的数据范围的话 $u$ 和 $v$ 是可以很好地用前缀和求的。不过现在依然可以。前缀和下标 $i$ 的数表示的是前 $i$ 段的和，这样在询问的时候可以先求出来被 $x$ 和 $y$ 所在段夹在中间的段的和，让 $u$ 和 $v$ 先加上。

对于 $x$ 和 $y$ 所在段的处理因为段内每个数相等，所以可以直接求出 $x$ 和 $y$ 所在段的平方和以及和，让 $u$ 和 $v$ 分别加上。

式子中的 $n$ 就相当于 $y-x+1$。

不过要注意的是 $x$ 和 $y$ 可能在同一段，此时答案为 $0$，因为平均值与每个数相等。

还要注意的一点是 $y-x+1\le10^{18}$，所以要先对 $y-x+1$ 进行取模之后再进行乘运算。

# CODE:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
int m,q;
const ll mod=998244353;
ll v[200010],u[200010];
ll l[200010],r[200010],b[200010];
int main()
{
	scanf("%lld%d%d",&n,&m,&q);
	for(register int i=1;i<=m;i++)
	{
		scanf("%lld%lld%lld",&l[i],&r[i],&b[i]);
		b[i]%=mod;
		v[i]=v[i-1]+((b[i]*((r[i]-l[i]+1)%mod))%mod);
		u[i]=u[i-1]+((((b[i]*b[i])%mod)*((r[i]-l[i]+1)%mod))%mod);
		v[i]%=mod,u[i]%=mod;
	}
	while(q--)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		ll px,py;
		px=upper_bound(l+1,l+m+1,x)-l-1;
		py=upper_bound(l+1,l+m+1,y)-l-1;
		ll su=0,sv=0;
		if(px==py)
		{
			puts("0");
			continue;
		}
		if(px+1<py) su=u[py-1]-u[px],sv=v[py-1]-v[px],su%=mod,sv%=mod;
		su+=(((r[px]-x+1)%mod)*((b[px]*b[px])%mod))%mod,su%=mod;
		sv+=(((r[px]-x+1)%mod)*b[px])%mod,sv%=mod;
		su+=(((y-l[py]+1)%mod)*((b[py]*b[py])%mod))%mod,su%=mod;
		sv+=(((y-l[py]+1)%mod)*b[py])%mod,sv%=mod;
		ll len=(y-x+1)%mod;
		printf("%lld\n",((su*len%mod-sv*sv%mod)%mod+mod)%mod);
	}
	return 0;
}
```

---

## 作者：Crushxl (赞：2)

# LGR-186-Div.2 - P10511 方差

## 题意简述

给定一个数组，回答 $q$ 次 $[l,r]$ 区间上的方差。特别地：

- 数组不直接给出，而是被切分成了 $m$ 段，每段上的数都相同。
- 数组大小在 $10^{18}$ 数量级，无法直接模拟，答案输出 $(r−l+1)^2 \cdot s^2 \mod 998244353$，且题目保证方差 $s^2$ 经过上述操作后一定为整数。



## 分块+二分做法

由于题目已经暗示答案一定是整数，我们先尝试化简要求的式子，这一步官方解析写得也比较清楚。
$$
\begin{aligned}
s^{2} & =\frac{1}{n} \sum_{i=1}^{n}\left(a_{i}-\bar{a}\right)^{2} \\
& =\frac{1}{n}\left[\sum a_{i}^{2}-2 \frac{\sum a_{i}}{n} \sum a_{i}+\left(\sum a_{i}\right)^{2}\right] \\
& =\frac{1}{n^{2}}\left[n \sum a_{i}^{2}-\left(\sum a_{i}\right)^{2}\right]
\end{aligned}
$$
结合题目，最终我们要求：
$$
s^{2} \cdot n^{2}=n \sum a_{i}^{2}-\left(\sum a_{i}\right)^{2}
$$
那么目标就很明确了，**我们需要维护区间和、区间平方和这两个信息**。因为不能直接开数组将 $m$ 段区间转化为完整的数组，所以我们考虑在原先给定的片段中维护信息。这就很像分块思想，只不过这个块题目中已经给我们分好了。

那么对于每个块，在读入时预处理该块的和以及平方和，这里用 `Block` 结构体表示。

```C++
struct Block{
    ll l,r,n,nn,s,ss;
}block[MAXN];

int main(){
    cin >> n >> m >> q;
    for(int i=1;i<=m;i++){
        cin >> block[i].l >> block[i].r >> block[i].n;
        ll len = (block[i].r-block[i].l+1);		//计算块大小 len
        block[i].n = num;						//块元素 n
        block[i].nn = block[i].n*block[i].n;	//块元素的平方 nn
        block[i].s = len*block[i].n;			//块元素和 s
        block[i].ss = len*block[i].nn;			//块元素的平方和 ss
    }
}
```

对于一次 $[l,r]$ 的询问，我们需要判断该区间覆盖了哪些块。考虑到块与块之间不重叠，且一定能组成完整的数组，所以我们可以**先以左端点给块排序，利用块之间的单调性二分地求出 $l$ 端点和 $r$ 端点所在的块编号**，那么存在覆盖的块就是两个块编号之间的所有块。

```C++
bool cmp(Block a,Block b){return a.l < b.l;}
sort(block+1,block+1+m,cmp);	//块排序

ll find(ll x){		//二分查找第x个元素所在的块编号
    ll l=1,r=m;
    while(l<=r){
        ll mid = (l+r)/2;
        if(block[mid].r < x){
            l = mid + 1;
        }else if(block[mid].l > x){
            r = mid - 1;
        }else{
            return mid;
        }
    }
}
```

接下来，按照题意遍历所有存在覆盖的块，累加和与平方和，这里用两个函数实现。注意头尾两个块可能覆盖不完整，要单独处理一下。

```C++
ll get_sum(ll l,ll r){			// 求[l,r]区间和
	ll len = r - l + 1;
    ll bl=find(l), br=find(br);		// 起始块和终止块编号
    if(bl == br) return len * block[br].n;		// 如果只覆盖了一个块，直接计算返回
    ll ans = (block[bl].r-l+1) * block[bl].n;	// 否则，累加起始块
	ans += (r-block[br].l+1) * block[br].n;		// 累加终止块
    for(int i=bl+1;i<=br-1;i++) ans += block[i].s;	// 累加中间的块
    return ans;
}

ll get_square_sum(ll l,ll r){	// 同理，求[l,r]区间平方和
	ll len = r - l + 1;
    ll bl=find(l), br=find(br);	
    if(bl == br) return len * block[br].nn;
    ll ans = (block[bl].r-l+1) * block[bl].nn;
	ans += (r-block[br].l+1)*block[br].nn;
    for(int i=bl+1;i<=br-1;i++) ans += block[i].ss;
    return ans;
}
```

最后按照公式计算一下，答案就出来了。

```C++
ll len = r - l + 1;
ll sum = get_sum(l,r);
ll ssum = ssum = get_square_sum(l,r);
ll ans = (len*ssum) - sum*sum;
```

遗憾的是，按以上做法只能拿到 $60$ 的分数，剩下四个点会超时，考虑进一步优化。



## 前缀和优化

事实上，二分+分块的做法，得到的算法复杂度是比较优秀的，但为什么还会超时呢？

这是因为块并不是我们人为划分的，而是题目给定的。很可能由于块本身划分的不合理，导致 $q\ (1 \leq q \leq 2 \times 10^5) $ 次询问中访问了大量的块 $(1 \leq m \leq 2 \times 10^5) $ ，显然我们不能接受 $mq$ 的时间复杂度。

优化办法也很简单，**将块看作元素，使用前缀和维护块**，对于连续的块，我们就可以用前缀和的办法 $O(1)$ 地得到所求的信息。 在读入预处理时，多维护两个 `pre_s` 前缀和、 `pre_ss` 前缀平方和数组即可。

最后不要忘了开 `long long` 。上面的代码为了可读性起见都没有取模，实际过程中每一步都要模。



## AC Code

```C++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 2e5+5;
const ll MOD = 998244353;
ll n,m,q,l,r;
struct Block{ll l,r,n,nn,s,ss;}block[MAXN];
ll pre_s[MAXN],pre_ss[MAXN];

bool cmp(Block a,Block b){return a.l < b.l;}

ll find(ll x){
    ll l=1,r=m;
    while(l<=r){
        ll mid = (l+r)/2;
        if(block[mid].r < x){
            l = mid + 1;
        }else if(block[mid].l > x){
            r = mid - 1;
        }else{
            return mid;
        }
    }
}

ll get_sum(ll l,ll r,ll bl,ll br){
	ll len = (r - l + 1) % MOD;
    if(bl == br) return (len*block[br].n)%MOD;
    ll ans = (((block[bl].r-l+1)%MOD)*block[bl].n)%MOD;
	ans = (ans + ((((r-block[br].l+1)%MOD)*block[br].n)%MOD))%MOD;
    ans = (ans + (pre_s[br-1]-pre_s[bl]+MOD))%MOD;		// 前缀和求连续的完整块
    return ans;
}

ll get_square_sum(ll l,ll r,ll bl,ll br){
	ll len = (r - l + 1) % MOD;
    if(bl == br) return (len*block[br].nn)%MOD;
    ll ans = (((block[bl].r-l+1)%MOD)*block[bl].nn)%MOD;
	ans = (ans + ((((r-block[br].l+1)%MOD)*block[br].nn)%MOD))%MOD;
	ans = (ans + (pre_ss[br-1]-pre_ss[bl]+MOD))%MOD;	// 前缀和求连续的完整块
    return ans;
}

int main(){
    scanf("%lld %lld %lld",&n,&m,&q);
    for(int i=1;i<=m;i++){
    	ll num;
    	scanf("%lld %lld %lld",&block[i].l,&block[i].r,&num);
    	ll len = (block[i].r-block[i].l+1) % MOD;
        block[i].n = num % MOD;
        block[i].nn = (block[i].n*block[i].n) % MOD;
        block[i].s = (len*block[i].n)%MOD;
        block[i].ss = (len*block[i].nn)%MOD;
        pre_s[i] = (pre_s[i-1] + block[i].s) % MOD;
        pre_ss[i] = (pre_ss[i-1] + block[i].ss) % MOD;
    }
    sort(block+1,block+1+m,cmp);
    for(int i=1;i<=q;i++){
        cin >> l >> r;
        ll bl=find(l), br=find(r);
        ll len = (r - l + 1) % MOD;
        ll sum = (get_sum(l,r,bl,br) + MOD) % MOD;
        ll ssum = (get_square_sum(l,r,bl,br) + MOD) % MOD;
        ll ans = ((len*ssum)%MOD - sum*sum%MOD+MOD) % MOD;
        printf("%lld\n",ans%MOD);
    }
    return 0;
}
```

---

## 作者：VitrelosTia (赞：2)

一道比较容易的数学题，不过取模很坑，假如调不过可以查一下取模的问题。

下记 $len = r - l + 1，sum = \sum_{i=l}^{r}a_i$。

首先题目要求 $len^2 \times s^2$，注意到 $s^2$ 里面其实有一个 $\dfrac{1}{len}$，那我们先乘个 $len$ 进去看看会发生什么。

$$len \times s^2 = \sum_{i=l}^{r}(a_i-\overline{a})^2$$

这个式子不好搞的，这种求和的式子的思路通常是搞出一些能直接算或者前缀和算的项，现在的式子并没有这种特质，那我们考虑用完全平方公式拆开它。

$$len \times s^2 = \sum_{i=l}^{r}a_i^2 + \overline{a}^2 - 2a_i\overline{a}$$

这已经比较好看了，直接把它分出来。

$$len \times s^2 = \sum_{i=l}^{r}a_i^2 + \sum_{i=l}^{r}\overline{a}^2 - 2\overline{a}sum$$

这就很有感觉了，平方和显然是好搞的，然后我们想一下 $\overline{a}$ 的意义其实是 $\dfrac{sum}{len}$，于是可以继续化。

$$len \times s^2 = \sum_{i=l}^{r}a_i^2 + \dfrac{sum^2}{len} - \dfrac{2sum^2}{len}$$

看起来没什么头绪？别忘了还有一个 $len$ 没乘进去！

$$len ^2 \times s^2 = len \times \sum_{i=l}^{r}a_i^2 - sum^2$$

这下式子就很好看了。

但是我们发现区间非常长，根本没法正常做前缀和，怎么办？考虑对于一段区间直接记前缀和，区间的和是可以用 $len \times v$ 直接算出来的。

但是一次询问可以不完全包含某个区间，那我们像分块处理散块一样单独做两边的区间，找区间位置可以直接二分。最后三块加起来就可以得到想要的东西了。

---

## 作者：Dangerise (赞：1)

对于原式，显然不太方便计算，我们进行一些转化。

令$$d = r - l + 1$$

$$
\sum_{i=l}^r (a_i - \overline a)^2 
\\
\begin{aligned}
&= (a_l-\overline a)^2 + (a_{l+1}-\overline a)^2 + \dots + (a_{r-1}-\overline a)^2 + (a_r-\overline a)^2\\
&= (a_{l}^2 - 2a_{l}\overline a + \overline a^2) + (a_{l+1}^2 - 2a_{l+1}\overline a + \overline a^2) + \dots + (a_{r-1}^2 - 2a_{r-1}\overline a + \overline a^2) + (a_{r}^2 - 2a_{r}\overline a + \overline a^2) \\
&= (a_l^2 + a_{l+1}^2 + \dots + a_{r-1}^2 + a_{r}^2) - 2 \overline a(a_l + a_{l+1} + \dots + a_{r-1} + a_{r}) + d\overline a^2 \\
&= (\sum_{i=1}^r a_i^2) - 2\overline a(\sum_{i=1}^r a_i) + d \overline a^2\\
\end{aligned}
$$

根据平均数的定义 $\overline a = \frac {\sum_{i=l}^r a_i} {d} $ 并将其带入可得

$ = (\sum_{i=1}^r a_i^2) - \frac {(\sum_{i=1}^r a_i)^2}{d}$


$$
\begin{aligned}
&=d^2 \cdot s^2\\
&=d(\sum_{i=1}^r a_i^2) - (\sum_{i=1}^r a_i)^2
\end{aligned}
$$

那么思路很明确，我们通过前缀和，对一段区间统计 $\sum_{i=1}^r a_i^2$ 与 $\sum_{i=1}^r a_i$。只不过这一题它以“段”的形式给出每个元素，那我们可以先将段进行排序，使段的序列具有单调性，然后对于每个询问，通过二分查找确定这个询问涉及到的段的范围，它将是一块由连续的段组成的段的区间。显然，除去两端的段，中间部分的段都是被查询区间全部覆盖的，而对于两端的段，我们进行特殊的处理。

时间复杂度为 $O(m \log m)$

代码实现如下

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

inline int qread() {
	int ans=0;
	char c=getchar();
	bool f=0;
	while(c<'0'||c>'9') {
		if(c=='-') {
			f=1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		ans=ans*10+c-'0';
		c=getchar();
	}
	if(f) {
		return -ans;
	} else {
		return ans;
	}
}

const int N=2e5+114514;
const int mod=998244353;

struct S {
	int l,r,v;
};

inline bool operator<(const S& x,const S& y) {
	return x.l<y.l;
}

int n,m,q;
S seg[N];

// 二分查找某个元素在哪个段里 
inline int find(int x) {
	int l=1,r=m;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(seg[mid].r<x) {
			l=mid+1;
		} else if(seg[mid].l>x) {
			r=mid-1;
		} else {
			return mid;
		}
	}
	// 显然这个二分查找必定命中 
}

int s1[N],s2[N];
// s1 为普通的前缀和
// s2 为每个元素的平方的前缀和 

inline int qs1(int l,int r){
	return ((s1[r]-s1[l-1])%mod+mod)%mod;
	// 由于取模的原因 s1[r]-s1[l-1]可能为负数
	// 所以以上运算可以将负数变成正数，并且保证正确 
}

inline int qs2(int l,int r){
	return ((s2[r]-s2[l-1])%mod+mod)%mod;
}

signed main() {
	n=qread(),m=qread(),q=qread();
	for(int i=1; i<=m; i++) {
		seg[i]= {qread(),qread(),qread()%mod};
	}

	sort(seg+1,seg+1+m);

	// 预处理前缀和 
	for(int i=1; i<=m; i++) {
		int d=(seg[i].r-seg[i].l+1)%mod;
		int v=seg[i].v;
		s1[i]=(s1[i-1]+d*v%mod)%mod;
		s2[i]=(s2[i-1]+d*v%mod*v%mod)%mod;
	}

	// 注意，对于任何可以取模的地方都必须取模 
	for(int i=1; i<=q; i++) {
		int x=qread(),y=qread();
		int l=find(x),r=find(y);
		
		int ld=(seg[l].r%mod-x%mod+1)%mod,rd=(y%mod-seg[r].l%mod+1)%mod;
		//  ld为左端段被覆盖的长度，rd为右端段被覆盖的长度 
		int lv=seg[l].v,rv=seg[r].v;
		
		int v1=((ld*lv%mod+qs1(l+1,r-1))%mod+rd*rv%mod)%mod;
		// a_i 的和 
		int v2=((ld*lv%mod*lv%mod+qs2(l+1,r-1))%mod+rd*rv%mod*rv%mod)%mod;
		// a_i 的平方的和 
		
		int d=(y-x+1)%mod;
		int ans=d*v2%mod-v1*v1%mod;
		ans=(ans%mod+mod)%mod;
		printf("%lld\n",ans);
	}
	
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：1)

推一波式子。题目中这个方差要乘上长度的平方。

$$s^2=\dfrac{1}{n}\sum\limits_{i=1}^n(a_i-\overline{a})^2$$
$$n^2s^2=n\sum\limits_{i=1}^n(a_i^2-2a_i\overline{a}+\overline{a}^2)$$
$$=n\sum\limits_{i=1}^na_i^2-2n\overline{a}\sum\limits_{i=1}^na_i+n^2\overline{a}^2$$

根据 $n\overline{a}=\sum\limits_{i=1}^na_i$ 得

$$=n\sum\limits_{i=1}^na_i^2-2\left(\sum\limits_{i=1}^na_i\right)^2+\left(\sum\limits_{i=1}^na_i\right)^2$$

$$=n\sum\limits_{i=1}^na_i^2-\left(\sum\limits_{i=1}^na_i\right)^2$$

这里给每一段从左到右排个序，然后可以维护从开始到每一段结尾的 $a_i$ 的前缀和以及 $a_i^2$ 的前缀和。

查询区间时，二分查找覆盖到的段是哪些，得到前缀和。然后对于只有一部分在查询的区间中的段，把多出去的部分减掉即可。

乘法可能会爆 long long，要特别小心。

```cpp
/*
A 为平均数
 n*sum((ai-A)^2)
=n*(sum(ai^2)-2*A*sum(ai)+n*A^2)
=n*sum(ai^2)-2*n^2*A^2+n^2*A^2
=n*sum(ai^2)-n^2*(sum(ai)^2)/(n^2)
=n*sum(ai^2)-sum(ai)^2
*/
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
const int mod=998244353;
int n,m,q,s[200010],s2[200010];
struct node{int r,x,x2;}a[200010];
bool operator<(const node &x,const node &y){
    return x.r<y.r;
}
signed main()
{
    cin>>n>>m>>q;
    for(int i=1;i<=m;i++)
    {
        int l;
        cin>>l>>a[i].r>>a[i].x;
        a[i].x%=mod;
        a[i].x2=a[i].x*a[i].x%mod;
    }
    sort(a+1,a+m+1);
    for(int i=1;i<=m;i++)
    {
        s[i]=(s[i-1]+(a[i].r-a[i-1].r)%mod*a[i].x%mod)%mod;
        s2[i]=(s2[i-1]+(a[i].r-a[i-1].r)%mod*a[i].x2%mod)%mod;
    }
    while(q--)
    {
        int l,r;
        cin>>l>>r;
        int pl=lower_bound(a+1,a+m+1,(node){l,0,0})-a-1;
        int pr=lower_bound(a+1,a+m+1,(node){r,0,0})-a;
        int lcnt=(l-a[pl].r-1)%mod;
        int rcnt=(a[pr].r-r)%mod;
        int sum=(s[pr]+mod-s[pl])%mod;
        int sum2=(s2[pr]+mod-s2[pl])%mod;
        sum=(sum+lcnt*(mod-a[pl+1].x)%mod)%mod;
        sum=(sum+rcnt*(mod-a[pr].x)%mod)%mod;
        sum2=(sum2+lcnt*(mod-a[pl+1].x2)%mod)%mod;
        sum2=(sum2+rcnt*(mod-a[pr].x2)%mod)%mod;
        cout<<((r-l+1)%mod*sum2%mod+mod-sum*sum%mod)%mod<<endl;
    }
    return 0;
}
```

---

## 作者：紪絽 (赞：1)

## 思路

首先好像高一就学过 $s^2= \frac{1}{n}\sum{a_i^2}-\overline{a}^2$。但还是推一下：  
令 $r - l + 1 = k$，则

$$\begin{aligned}
s^2 &= \frac{1}{k} \sum_{i=1}^k (a_i-\overline{a})^2 \\
&= \frac{1}{k} \left(\sum_{i=1}^k a_i^2 - 2 \cdot \sum_{i=1}^k a_i \cdot \overline{a}+\sum_{i=1}^k \overline{a}^2 \right) \\
&= \frac{1}{k}\sum_{i=1}^k a_i^2-\overline{a}^2 \\
&= \frac{1}{k}\sum_{i=1}^k a_i^2-\frac{1}{k^2}\left (\sum_{i=1}^k a_i\right )^2,\\
k^2s^2 &=k \sum_{i=1}^k a_i^2-\left (\sum_{i=1}^k a_i\right )^2
\end{aligned}
$$

也就是要维护区间平方和与区间和。这可以考虑用前缀和维护。考虑到有散块的可能，所以先把夹在 $x$ 和 $y$ 中间的整块求出来，再把 $x$ 旁边的或 $y$ 旁边的散块求出来。记得及时取膜。

我们可以先把 $x$ 和 $y$ 所在的块的坐标求出来，再把指针各往中间移一块来计算整块。

![](https://cdn.luogu.com.cn/upload/image_hosting/d2zcl5p8.png)

例如，想要求 $x$ 所在的块编号，只要找到离它最近且大于等于它的 $r_0$ 或小于它 $l_0$ 即可。注意，$r_0$ 可以和 $x$ 重合，但 $l_0$ 不可以，如果重合的话 $0$ 号块也可以算作被夹在中间的块了。代码写出来就是 `dx = lower_bound(r + 1, r + m + 1, x) - r; ` 或 `dx = lower_bound(l + 1, l + m + 1, x) - l - 1`。$y$ 所在的编号也是差不多的求法。 

其他小细节在代码注释里。注意取膜哦！


## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll M = 2e5 + 100, mod = 998244353;
ll n, m, q;
ll l[M], r[M];
ll s[M], qs[M], len[M], b[M];

int main()
{
    cin >> n >> m >> q;
    for (int i = 1; i <= m; i++)
    {
        cin >> l[i] >> r[i] >> b[i]; b[i] %= mod;
        len[i] = (r[i] - l[i] + 1) % mod;  
        s[i] = (len[i] * b[i]) % mod; 
        qs[i] = (s[i] * b[i]) % mod; 
        len[i] = (len[i - 1] + len[i]) % mod;
        s[i] = (s[i - 1] + s[i]) % mod;
        qs[i] = (qs[i - 1] + qs[i]) % mod;
    }
    
    for (int i = 1; i <= q; i++)
    {
        /* 一开始想先把离 x/y 右/左 边最近的 左/右 端点编号求出来的……但是实现起来有点麻烦（ */
        
        ll x, y, dx, dy /* dx 为 x 所在的编号；dy 含义亦然 */, S, QS, ans; cin >> x >> y;
        dx = lower_bound(l + 1, l + m + 1, x) - l - 1, // 也就是 dx = lower_bound(r + 1, r + m + 1, x) - r;
        dy = lower_bound(r + 1, r + m + 1, y) - r;
        if (dx == dy) { cout << 0 << endl; continue; }
        
//      S = S + (r[dx] - x + 1) * b[dx] + (y - l[dy] + 1) * b[dy];  
        S = (r[dx] - x + 1) % mod * b[dx] % mod + (y - l[dy] + 1) % mod * b[dy] % mod;
        QS = (r[dx] - x + 1) % mod * b[dx] % mod * b[dx] % mod + (y - l[dy] + 1) % mod* b[dy] % mod * b[dy] % mod;
    
        dx++, dy--; // 移到里面夹着的整块
        if (dx <= dy) // 排除里面没夹着整块的情况
        {
            S = (S + s[dy] - s[dx - 1] + mod) % mod;
            QS = (QS + qs[dy] - qs[dx - 1] + mod) % mod;
        }
        ans = ((y - x + 1) % mod * QS % mod - S * S % mod + mod) % mod;
        cout << (ans + mod) % mod << endl;
    }
    
    return 0;
}
```

---

## 作者：ran_qwq (赞：1)

upd on 2024/5/21：修改了式子的一处错误。

推一下式子，记 $k=y-x+1$：

$$\begin{aligned}k^2s^2&=k^2\sum\limits_{i=x}^y(a_i-\bar a)^2\\&=\sum\limits_{i=x}^y[k(a_i-\bar a)]^2\\&=\sum\limits_{i=x}^y(ka_i-k\bar a)^2\\&=\sum\limits_{i=x}^y(ka_i-\sum\limits_{j=x}^ya_j)^2\\&=\sum\limits_{i=x}^y[(ka_i)^2-2ka_i\sum\limits_{j=x}^ya_j+(\sum\limits_{j=x}^ya_j)^2]\\&=\sum\limits_{i=x}^y(ka_i)^2-\sum\limits_{i=x}^y(2ka_i\sum\limits_{j=x}^ya_j)+\sum\limits_{i=x}^y(\sum\limits_{j=x}^ya_j)^2\\&=\sum\limits_{i=x}^y(ka_i)^2-2k(\sum\limits_{i=x}^ya_i)\cdot(\sum\limits_{i=x}^ya_i)+k(\sum\limits_{i=x}^ya_i)^2\\&=\sum\limits_{i=x}^y(ka_i)^2-k(\sum\limits_{i=x}^ya_i)^2\\&=k[\sum\limits_{i=x}^ya_i^2-(\sum\limits_{i=x}^ya_i)^2]
\end{aligned}$$

预处理出 $a_i$ 和 $a_i^2$ 的前缀和，二分找出处于 $x,y$ 哪一块，差分求出 $\sum\limits_{i=x}^ya_i$ 和 $\sum\limits_{i=x}^ya_i^2$ 即可。

```cpp
int m,q,s1[N],s2[N]; ll n,l[N],r[N],b[N];
il int vadd(int x,int y) {return x+y>=Mod?x+y-Mod:x+y;}
il int vsub(int x,int y) {return x>=y?x-y:x-y+Mod;}
il int vmul(int x,int y) {return 1ll*x*y%Mod;}
int sum1(ll x) {int p=lb(r+1,r+1+m,x)-r; return vsub(s1[p],vmul(b[p]%Mod,(r[p]-x)%Mod));}
int sum2(ll x) {int p=lb(r+1,r+1+m,x)-r; return vsub(s2[p],vmul(vmul(b[p]%Mod,b[p]%Mod),(r[p]-x)%Mod));}
void QwQ() {
	n=rdll(),m=rd(),q=rd();
	for(int i=1;i<=m;i++) l[i]=rdll(),r[i]=rdll(),b[i]=rdll(),s1[i]=vadd(s1[i-1],vmul(b[i]%Mod,(r[i]-l[i]+1)%Mod)),s2[i]=vadd(s2[i-1],vmul(vmul(b[i]%Mod,b[i]%Mod),(r[i]-l[i]+1)%Mod));
	for(ll x,y;q--;) {
		x=rdll(),y=rdll(); int p=vsub(sum1(y),sum1(x-1)),q=vsub(sum2(y),sum2(x-1));
		wr(vsub(vmul((y-x+1)%Mod,q),vmul(p,p)),"\n");
	}
}
```

---

## 作者：b__b (赞：0)

我们先不管取模操作。

对于区间 $\left[l,r \right]$，令 $m=r-l+1$，则：

$\bar a=\frac{\sum \limits_{i=l}^r a_i}{m}$

$s^2=\frac{\sum \limits_{i=l}^r(a_i-\bar a)^2}{m}$

$
\begin{aligned}
m^2s^2&=m^2 \cdot \frac{\sum \limits_{i=l}^r(a_i-\bar a)^2}{m}\\
&=m\sum \limits_{i=l}^r(a_i^2-2a_i \bar a+\bar a^2)\\
&=m(\sum \limits_{i=l}^r a_i^2-2 \sum \limits_{i=l}^r a_i \bar a+\sum \limits_{i=l}^r \bar a^2)\\
&=m(\sum \limits_{i=l}^r a_i^2-2 \bar a \sum \limits_{i=l}^r a_i+m\bar a^2)\\
&=m\left[\sum \limits_{i=l}^r a_i^2-2 \cdot \frac{\sum \limits_{i=l}^r a_i}{m} \sum \limits_{i=l}^r a_i+m(\frac{\sum \limits_{i=l}^r a_i}{m})^2\right]\\
&=m\left[\sum \limits_{i=l}^r a_i^2-\frac{2(\sum \limits_{i=l}^r a_i)^2}{m}+m \cdot \frac{(\sum \limits_{i=l}^r a_i)^2}{m^2}\right]\\
&=m\left[\sum \limits_{i=l}^r a_i^2-\frac{2(\sum \limits_{i=l}^r a_i)^2}{m}+\frac{(\sum \limits_{i=l}^r a_i)^2}{m}\right]\\
&=m\left[\sum \limits_{i=l}^r a_i^2-\frac{(\sum \limits_{i=l}^r a_i)^2}{m}\right]\\
&=m\sum \limits_{i=l}^r a_i^2-(\sum \limits_{i=l}^r a_i)^2
\end{aligned}
$

即我们需要维护 $\sum \limits_{i=l}^r a_i^2$ 和 $(\sum \limits_{i=l}^r a_i)^2$，也就是平方和与数字和。

但是 $n$ 最大为 $10^{18}$，也就是说如果单点修改的话肯定会 TLE，因为 $m \leq \min(n,2 \times 10^5)$，即 $m$ 最大为 $2 \times 10^5$，于是我们考虑以区间来计算前缀和。

区间的端点是只会在一个区间内或在区间分界线上的，因此区间的和只需要考虑两端不同的区间。

下面会将一段数字加上括号。

例如，对于序列 $((5),(7,7),(2,2,2),(8,8,8))$，询问 $\left[3,8 \right]$，则需要处理的数字就是（在数字下加上下划线表示需要处理）：
$$((5),(7,\underline 7),(\underline 2,\underline 2,\underline 2),(\underline 8,\underline 8,8))$$

我们看到，第三段被完全覆盖，因此可以直接加上，而这段区间只覆盖了第二段区间的最后一个与第四段区间的前两个。

我们先看第二段区间。因为一段里面的数都是一样的，因此我们可以考虑把整个段加上然后减去多余的部分。这一段的平方总和为 $2 \times 7^2=98$，数字总和为 $2 \times 7=14$，多余的部分长度只有一个，平方总和为 $1 \times 7^2=49$，数字总和为 $1 \times 7=7$，因此这一段的数字和为 $14-7=7$，平方和为 $98-49=49$。

不难得出，设左端点 $l$ 所在的一段为 $\left[p,q \right]$，这一段里面的数字都是 $a$，区间和为 $s$，区间平方和为 $d$，则区间 $\left[ p,l \right)$ 的数字和为 $(l-p)a$，区间平方和为 $(l-p)a^2$。

同理，设右端点 $r$ 所在的一段为 $\left[p,q \right]$，这一段里面的数字都是 $a$，区间和为 $s$，区间平方和为 $d$，则区间 $\left[ p,r \right)$ 的数字和为 $s-(q-r)a$，区间平方和为 $d-(q-r)a^2$。

答案就只需要将第二段区间，第三段区间与第四段区间加上再减去上面得出的两个和即可。于是问题变成如何找到左端点与右端点所在的区间。
> 数据保证对于任意 $i<j$，$l_i<l_j$。

也就是说给出的区间的左端点是升序的，且一个左端点只会对应一个区间，于是我们可以直接二分查找一个一个数在哪一个区间即可。
## 代码
```cpp
#include <cstdio>
#include <algorithm>
typedef long long ll;
const int mod = 998244353, N = 2e5 + 5;
struct modi {
    ll v;
    inline bool operator<(const modi &b) {return v < b.v;}
    inline modi operator+(const modi &b) {return modi{(v + b.v) % mod};}
    inline modi &operator-=(const ll &b) {v = (((v - b) % mod) + mod) % mod; return *this;}
    inline modi operator-(const modi &b) {return modi{((v - b.v) % mod + mod) % mod};}
    inline modi operator*(const ll &b) {return modi{v * (b % mod) % mod};}
    inline modi operator*(const modi &b) {return modi{v * (b.v % mod) % mod};}
} sum[N], pfsum[N], tmsum, tmpfsum, ys[N];
ll n, m, q, i = 1, l[N], r[N], tm, x, y, qjl, qjr;
int main() {
    for (scanf("%lld%lld%lld", &n, &m, &q); i <= m; ++i) scanf("%lld%lld%lld", l + i, r + i, &ys[i].v),
        ys[i].v %= mod, sum[i] = sum[i - 1] + ys[i] * ((r[i] - l[i] + 1) % mod),
        pfsum[i] = pfsum[i - 1] + ys[i] * ys[i] * ((r[i] - l[i] + 1) % mod);
    while (q--) {
        scanf("%lld%lld", &x, &y), qjl = std::upper_bound(l + 1, l + 1 + m, x) - l - 1,
        qjr = std::upper_bound(l + 1, l + 1 + m, y) - l - 1;
        tmsum = sum[qjr] - sum[qjl - 1] - ys[qjl] * ((x - l[qjl]) % mod) - ys[qjr] * ((r[qjr] - y) % mod),
        tmpfsum = pfsum[qjr] - pfsum[qjl - 1] - ys[qjl] * ys[qjl] * ((x - l[qjl]) % mod) - 
            ys[qjr] * ys[qjr] * ((r[qjr] - y) % mod);
        printf("%lld\n", (tmpfsum * (y - x + 1) - tmsum * tmsum).v);
    }
}
```

---

## 作者：Determination_Y (赞：0)

同步发表于 [Cnblogs](https://www.cnblogs.com/Sundar-2022/p/18336422)。

### 【题目简述】

定义一个长度为 $n$ 的序列 $a$ 的方差为：$s^2=\frac{1}{n} \sum_{i=1}^n (a_i-\overline{a})^2$。

$\sum$ 为累加求和符号，$\overline{a}$ 为序列 $a$ 的平均数。

给定 $m$ 个形如 $[l,r,b]$ 的组合，表示 $a_l,a_{l+1},\ldots,a_r$ 为 $b$。

给定 $q$ 个询问，每个询问形如 $[l,r]$，你要求出区间 $[l,r]$ 的方差 $s^2 \times (r-l+1)^2$ 的值。

对 $998244353$ 取模。

### 【思路】

一道很好的推式子题。。。

前置知识，区间长度乘其平均值，等于区间和，即：$n \times \overline{a}=\sum_{i=1}^{n}a_i$，暂且称之为：“拆平均”。

再设 $n=r-l+1$，然后给我死命推！

$\begin{aligned}
&s^2 \times n^2 \\
=& \left[\frac{1}{n} \sum_{i=1}^n (a_i-\overline{a})^2\right]\times n^2 \text{（根据定义展开 s）}\\
=& \left[\sum_{i=1}^n (a_i-\overline{a})^2\right]\times n \text{（把一个 n 乘进去）}\\
=& \left[\sum_{i=1}^n (a_i^2-2a_i\overline{a}+\overline{a}^2)\right]\times n \text{（完全平方公式展开）}\\
=& \left(\sum_{i=1}^n a_i^2 - \sum_{i=1}^n 2a_i\overline{a} +\sum_{i=1}^n \overline{a}^2\right)\times n \text{（分裂）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - n \times 2 \overline{a}\sum_{i=1}^n a_i + n \times \sum_{i=1}^n \overline{a}^2 \text{（拆括号）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + n \times \sum_{i=1}^n \overline{a}^2 \text{（拆中项平均）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + \frac{1}{n} \times n^2 \sum_{i=1}^n \overline{a}^2 \text{（拆 n）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + \frac{1}{n} \times \sum_{i=1}^n n^2 \overline{a}^2 \text{（把 n方 乘进去）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + \frac{1}{n} \times \sum_{i=1}^n (n \times \overline{a})^2 \text{（提平方）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + \frac{1}{n} \sum_{i=1}^n (\sum_{j=1}^{n}a_j)^2 \text{（拆平均）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + \frac{1}{n} \times n (\sum_{j=1}^{n}a_j)^2 \text{（末项括号内值与 i 无关）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - 2 \left(\sum_{i=1}^n a_i \right)^2 + (\sum_{i=1}^{n}a_i)^2 \text{（常数互相抵消）}\\
=& n \times \left(\sum_{i=1}^n a_i^2 \right) - \left(\sum_{i=1}^n a_i \right)^2 \text{（二、三项合并）}\\
\end{aligned}$

至此，我们已经消除了所有的 $\overline{a}$，把式子转化为了一个比较好看的形式。

发现式子中的两个求和符号可以用前缀和维护，恭喜你这道题就~~做完~~ RE 了。

发现数据范围 $1\le l_i\le r_i\le n\le \color{red}10^{18}$，原地趋势。

于是借鉴分块的思想（？），把每一段的和 & 平方和维护出来，对于两侧不满足一整段的部分，直接暴力求解。

具体现代码。

### 【Code】

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int mod=998244353;

int n,m,q,l[200005],r[200005],b[200005];
int sum1[200005],sum2[200005];           //区间和&区间平方和
int x,y;

int Baoli1(int l,int r,int b){
	return (((r-l+1)%mod)*b)%mod;
}

int Baoli2(int l,int r,int b){
	return (((r-l+1)%mod)*((b*b)%mod))%mod;
}

int Calc(int x,int y){
	int len=(y-x+1)%mod;
	int flagx=lower_bound(r+1,r+1+m,x)-r; //最左端在哪一段
	int flagy=lower_bound(r+1,r+1+m,y)-r; //最右端在哪一段
	if(flagx==flagy){
		return 0; //如果再同一段，说明区间全部相等，直接输出 0
	}else{
		int s1=(Baoli1(x,r[flagx],b[flagx])+Baoli1(l[flagy],y,b[flagy]))%mod; //暴力求两端的和
		int s2=(Baoli2(x,r[flagx],b[flagx])+Baoli2(l[flagy],y,b[flagy]))%mod; //暴力求两端的平方和
		flagx++,flagy--;
		s1=(s1+(sum1[flagy]-sum1[flagx-1]+mod))%mod;   //加上中间段的和
		s2=(s2+(sum2[flagy]-sum2[flagx-1]+mod))%mod;   //加上中间段的平方和
		return (((len*s2)%mod+mod)-((s1*s1)%mod))%mod; //公式最后一步
	}
}

signed main()
{
	scanf("%lld%lld%lld",&n,&m,&q);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld%lld",&l[i],&r[i],&b[i]);b[i]%=mod;
		int len=(r[i]-l[i]+1)%mod;
		sum1[i]=(sum1[i-1]+((len*b[i])%mod))%mod;              //长度*数值
		sum2[i]=(sum2[i-1]+((len*((b[i]*b[i])%mod))%mod))%mod; //长度*数值的平方
	}
	for(int i=1;i<=q;i++){
		scanf("%lld%lld",&x,&y);
		printf("%lld\n",Calc(x,y));
	}
	return 0;
}
```

---

## 作者：AKPC (赞：0)

注意到 $n$ 很大，但是 $m$ 不算很大，可以通过这个性质来突破本题。

首先，可以考虑把原式按照完全平方公式拆开，然后因为 $\overline a=\frac{1}{n}\sum a_i$，一系列化简后就可以得到 $s^2=\frac{1}{n}\sum a_i^2-\frac{1}{n^2}(\sum a_i)^2$，那么，对于询问，我们需要求的量分别是 $\sum a_i$ 和 $\sum a_i^2$。

因为本题的数列是分段的，所以求区间也按照这个段来分。先把输入的每个段排序，对于询问的左右两个散块，可以考虑二分求出包含左（或者右）端点的是哪一段，然后就很好搞了。

---

## 作者：HHC883 (赞：0)

# 题目分析
原式不好直接计算，于是我们先对其进行变形。令原序列的区间 $[l,r]$ 为序列 $b$，则有：
$$\begin{aligned}
(r-l+1)^2 \cdot s^2
&=(r-l+1)^2 \cdot \frac{1}{r-l+1} \sum_{i=1}^{r-l+1} (b_i-\overline{b})^2\\
&=(r-l+1) \sum_{i=1}^{r-l+1} (b_i^2-2\overline{b}b_i+\overline{b}^2)\\
&=(r-l+1)\sum_{i=1}^{r-l+1} b_i^2-(r-l+1)\sum_{i=1}^{r-l+1} 2\overline{b}b_i+(r-l+1)\sum_{i=1}^{r-l+1} \overline{b}^2\\
&=(r-l+1)\sum_{i=1}^{r-l+1} b_i^2-2(\sum_{i=1}^{r-l+1} b_i)^2+(r-l+1)^2 \cdot \overline{b}^2\\
&=(r-l+1)\sum_{i=1}^{r-l+1} b_i^2-2(\sum_{i=1}^{r-l+1} b_i)^2+(\sum_{i=1}^{r-l+1}b_i)^2\\
&=(r-l+1)\sum_{i=1}^{r-l+1} b_i^2-(\sum_{i=1}^{r-l+1} b_i)^2\\
\end{aligned}$$
于是，我们只需要计算区间平方和（$\sum_{i=1}^{r-l+1} b_i^2$）以及区间和（$\sum_{i=1}^{r-l+1} b_i$）即可，而这些都可以用前缀和来维护。

但是题目中的序列是分段给出的，且长度极大，不可以直接计算前缀和。于是我们可以先把所有段排序，再利用类似于分块的思路，对序列开头和序列末尾的非整块单独处理，中间的整块利用前缀和维护即可。而不同于分块的一点是这里的块（即题目中的段）长度不一，但没事，我们可以利用二分来判断开头和结尾分别属于哪一段。

最后，写代码的时候一定要勤取模（非常重要）。
# 参考代码
```cpp
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
const int mod=998244353;
int n,m,q,pre1[(int)2e5+5],pre2[(int)2e5+5];
struct sec{
	int l,r,b;
} secs[(int)2e5+5];
int bin(sec a[],int l,int r,int x){
	int mid=(l+r)>>1;
	if(a[mid].l<=x&&x<=a[mid].r) return mid;
	else if(x<a[mid].l) return bin(a,l,mid-1,x);
	else return bin(a,mid+1,r,x);
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>q;
	int l,r,b;
	for(int i=1;i<=m;i++){
		cin>>l>>r>>b;
		secs[i]=sec{l,r,b%mod};
	}
	sort(secs+1,secs+m+1,[](sec a,sec b){return a.l<b.l;});
	for(int i=1;i<=m;i++){
		pre1[i]=(pre1[i-1]+secs[i].b*secs[i].b%mod*((secs[i].r-secs[i].l+1)%mod)%mod)%mod;
		pre2[i]=(pre2[i-1]+secs[i].b*((secs[i].r-secs[i].l+1)%mod)%mod)%mod;
	}
	int x,y;
	int tot1,tot2,ans;
	while(q--){
		cin>>x>>y;
		int start=bin(secs,1,m,x),end=bin(secs,1,m,y);
		if(start<end){
			tot1=secs[start].b*secs[start].b%mod*((secs[start].r-x+1)%mod)%mod;
			tot2=secs[start].b*((secs[start].r-x+1)%mod)%mod;
			tot1=(tot1+secs[end].b*secs[end].b%mod*((y-secs[end].l+1)%mod)%mod)%mod;
			tot2=(tot2+secs[end].b*((y-secs[end].l+1)%mod)%mod)%mod;
			if(start+1<=end-1){
				tot1=(tot1+(pre1[end-1]-pre1[start]+mod)%mod)%mod;
				tot2=(tot2+(pre2[end-1]-pre2[start]+mod)%mod)%mod;
			}
		}else{
			tot1=secs[start].b*secs[start].b%mod*((y-x+1)%mod)%mod;
			tot2=secs[start].b*((y-x+1)%mod)%mod;
		}
		ans=((y-x+1)%mod*tot1%mod-tot2*tot2%mod+mod)%mod;
		cout<<ans<<endl;
	}
	return 0;
}

```

---

## 作者：RegisterFault (赞：0)

先推一波式子。下面假设 $s$ 表示一个数列的所有数的和，$s_2$ 表示所有数的平方和。

$$n  \times \sum (a_i - \overline{a}) ^ 2 = n \times \sum (a_i ^ 2 - 2a_i\overline{a} + \overline{a} ^ 2)\\\\=n \times s_2 -2n\overline{a}s+n^2\overline{a}^2
\\\\=n\times s_2 - 2s ^ 2 + s ^ 2\\\\= n s_2 -s^2$$

可以看到，答案只与数列平方和、数列和以及数列长度有关。可以预处理数列平方和前缀和、数列和前缀和。查询时二分到具体区间即可做到 $O(1)$。考虑二分的复杂度，单次询问 $O(\log n)$。

取模加的比较丑。下面是省略快读的代码：

```cpp
map<int, int> bin; set<int> st;
int n, m, q, l[N], r[N], w[N], s[N], ss[N];
signed main() {
	read(n, m, q);
	rep(i, 1, m) read(l[i], r[i], w[i]), w[i] %= mod;
	rep(i, 1, m) bin[l[i]] = i; bin[n + 1] = m + 1;
	rep(i, 1, m) s[i] = (s[i - 1] + (r[i] - l[i] + 1) % mod * w[i] % mod) % mod;
	rep(i, 1, m) ss[i] = (ss[i - 1] + (r[i] - l[i] + 1) % mod * w[i] % mod * w[i] % mod) % mod;
	rep(i, 1, m) st.insert(l[i]); st.insert(n + 1);
	while (q -- ) {
		int L, R; read(L, R);
		int lb = *prev(st.upper_bound(L)), rb = *prev(st.upper_bound(R));
		lb = bin[lb], rb = bin[rb]; int len = (R - L + 1) % mod; if (lb == rb) puts("0");
		else {
			int s1 = s[rb - 1] - s[lb], s2 = ss[rb - 1] - ss[lb];
			s1 = (s1 % mod + mod) % mod; s2 = (s2 % mod + mod) % mod;
			s1 += (r[lb] - L + 1) % mod * w[lb] % mod, s2 += (r[lb] - L + 1) % mod * w[lb] % mod * w[lb] % mod;
			s1 += (R - l[rb] + 1) % mod * w[rb] % mod, s2 += (R - l[rb] + 1) % mod * w[rb] % mod * w[rb] % mod;
			s1 = s1 % mod, s2 = s2 % mod;
			write('\n', (len * s2 % mod - s1 * s1 % mod + mod) % mod);
		}
	} return 0;
}
```

---

## 作者：Jadonyzx (赞：0)

分析数据范围。

$10^{18}$ 的大小可以看出，不开 `long long` 见祖宗；$2\times10^5$ 的输入量最好要加上快读。你不会以为 `long long` 就够了吧？由于我们要用到前缀和，还应当开 `__int128`。

快读快写代码如下。

```cpp
#define int __int128
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
	return;
}
```

排序代码如下。

```cpp
struct node{
	int l,r,val;
}a[200010];
bool cmp(node ccf,node ioi){
	return ccf.r<ioi.l;
}
                        
sort(a+1,a+1+m,cmp);
```

进一步分析。

简单推一下式子。首先假设查找的区间有 $cnt$ 个数字，区间数字之和为 $sum$。

所求的答案等于 $cnt^2\times\frac{1}{cnt}\times\Sigma_{i=l}^{r}(a_i-\frac{sum}{cnt})^2$。

化简裂项得 $cnt\times\Sigma_{i=l}^{r}(a_i^2-\frac{2\times sum \times a_i}{cnt}+\frac{sum^2}{cnt^2})$。

再打开得 $cnt\times\Sigma_{i=l}^{r}(a_i^2)-sum^2$。

那么我们只需要两个前缀和数组维护 $\Sigma a_i^2$ 和 $\Sigma a_i$ 即可。

注意，$10^{18}\times{10^{18}}$ 会爆 `long long`。

关键代码。

```cpp
#define int __int128
```

预处理代码如下。

```cpp
for(int i=1;i<=m;++i)s[i]=s[i-1]%mod+(a[i].r-a[i].l+1)%mod*a[i].val%mod;
for(int i=1;i<=m;++i)x2[i]=x2[i-1]%mod+(a[i].r-a[i].l+1)%mod*a[i].val%mod*a[i].val%mod;
```

其中 $findl$ 和 $findr$ 为询问区间最左和最右的区间在数组中的下标，$x2$ 为 $\Sigma a_i^2$ 的前缀和数组，$s$ 为 $\Sigma a_i$ 的前缀和数组，askl 和 askr 为询问的左右端点。

求答案的代码如下。

```cpp
sum=s[findr]-s[findl-1]-(askl-a[findl].l)%mod*a[findl].val%mod-(a[findr].r-askr)%mod*a[findr].val%mod;
cnt=askr-askl+1;
ANS=cnt%mod*(x2[findr]%mod-x2[findl-1]%mod-(askl-a[findl].l)%mod*a[findl].val%mod*a[findl].val%mod-(a[findr].r-askr)%mod*a[findr].val%mod*a[findr].val%mod+mod)%mod;
ANS=(ANS-sum%mod*sum%mod+mod)%mod;
ANS=(ANS+5*mod)%mod;
```

那么如何查找 $findl$ 和 $findr$ 呢？

显然用二分查找，这里就不多赘述了。

二分查找代码如下。

```cpp
L=1;R=m;
while(R>=L){
	M=(L+R)/2;
	if(a[M].r<=askl)L=M+1;
	else R=M-1;
}
while(a[M+1].l<=askl&&M<m)M++;
while(a[M].l>askl&&M>1)M--;
findl=M;
L=1;R=m;
while(R>=L){
	M=(L+R)/2;
	if(a[M].l>=askr)R=M-1;
	else L=M+1;
}
while(a[M-1].r>=askr&&M>1)M--;
while(a[M].r<askr&&M<m)M++;
findr=M;
while(a[findl].r<askl)findl++;
while(a[findr].l>askr)findr--;
```

还有一些重要的小细节。

1.别忘了取模，到处都要！[后果预览](https://www.luogu.com.cn/record/159525748)

2.查找区间的时候最左边最右边的多出来的部分要减掉！

3.数组别开小了。

---

## 作者：_IceCream_ (赞：0)

## Content

给你一个长度为 $n$ 的正整数序列 $a$，然后用多个区间覆盖，保证区间无交集。每次对于 $[l,r]$ 这个区间求 ${(r - l + 1)}^2 \times s^2 \bmod 998244353$ 的值。

## Solution

看到这题就想起了 P1471，但是这题相对来说更简单一些。

首先我们知道，方差这东西的公式直接使用肯定是会超时的，那么我们可以来简化一下式子。

$$\begin{aligned} \dfrac{1}{n}\sum _ {i = 1} ^ n {(a_i - \overline{a})}^2 &= \dfrac{1}{n}\sum _ {i = 1} ^ n (a_i^2 - 2a_i\overline{a} + \overline{a}^2) \\ &= \dfrac{1}{n}\sum _ {i = 1} ^ n a_i^2 - 2\dfrac{a_1+a_2+a_3+\cdots+a_n}{n}\overline{a} + \overline{a}^2 \\ &= \dfrac{1}{n}\sum _ {i = 1} ^ n a_i^2 - 2\overline{a}^2 + \overline{a}^2 \\ &= \dfrac{1}{n}\sum _ {i = 1} ^ n a_i^2 - \overline{a}^2
\end{aligned}$$

**注意 $\sum$ 后跟的式子打没打括号。**

那么把这玩意带到答案式子里面就是这样的。

$${(r - l + 1)}^2 \times \dfrac{1}{r - l + 1} \sum _ {i = l} ^ r a_i^2 - \overline{a}^2 = (r - l + 1) \times \sum _ {i = l} ^ r a_i^2 - \overline{a}^2$$

注意到题目辅助方法是覆盖式的，我们可以把每一个覆盖相同数字的区间看做一个块，每次预处理每个块的前缀平方和与前缀和。

统计答案时直接用二分查找左右两个整块的端点，然后用整块加散块的统计方式统计就可以了。

但是题目里面可能爆的地方很多，我们怎么避免呢？

很简单，最粗暴的方式就是用 __int128。

但是开发者实在是~~太懒了~~，没有写关于 __int128 的一些函数。所以说输入输出我们仍然需要 long long。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
const __int128 mod = 998244353;
__int128 n, m, q;
__int128 l[N], r[N];
__int128 val[N];
long long tmpl[N], tmpr[N]; // 防止 __int128 没有专门的 upper_bound。 
__int128 sum1[N], sum2[N];

// 用 long long 来输入输出 
void read (__int128 &a) {
	long long t;
	cin >> t;
	a = t;
}
void print (__int128 a) {
	long long t = a;
	cout << t << endl;
}

int main () {
	
	
	read (n), read (m), read (q);
	
	for (int i = 1; i <= m; ++i) {
		read(l[i]), read(r[i]), read(val[i]);
		val[i] %= mod;
		(sum1[i] = sum1[i - 1] + (val[i] * (r[i] % mod - l[i] % mod + 1) % mod)) %= mod; 
		(sum2[i] = sum2[i - 1] + (val[i] * val[i] % mod * (r[i] % mod - l[i] % mod + 1) % mod)) %= mod;
		sum1[i] %= mod;
		sum2[i] %= mod;
		tmpl[i] = l[i], tmpr[i] = r[i];
	}
	
	while (q--) {
		__int128 x, y;
		read (x), read (y);
		
		__int128 L = upper_bound (tmpl + 1, tmpl + m + 1, x) - tmpl - 1, // 二分找整区间左右端点 
			     R = upper_bound (tmpr + 1, tmpr + m + 1, y) - tmpr;
		if (y == n) R--; // 如果 y 为 n，upper_bound 会返回 n + 1，所以这时候需要减一个。 
			
		if (L >= R) {
			cout << 0 << endl;
			continue;
		}
		
		__int128 ans1 = ((sum1[R] - sum1[L - 1]) % mod /*前面是整块的处理，后面是散块的处理*/ + (l[L] % mod - x) % mod * val[L] % mod + (y - r[R]) * val[R] % mod) % mod, 
				  ans2 = ((sum2[R] - sum2[L - 1]) % mod /*前面是整块的处理，后面是散块的处理*/ + (l[L] % mod - x) % mod * val[L] % mod * val[L] % mod + (y % mod - r[R] % mod) % mod * val[R] % mod * val[R] % mod) % mod;
		
		print ((((y % mod - x % mod + 1) % mod * ans2 % mod - (ans1 % mod * ans1 % mod) % mod) % mod + mod) % mod);  
	}
	
	return 0;
}
```

---


# 『FLA - I』庭中有奇树

## 题目背景

![zuzong](https://cdn.luogu.com.cn/upload/image_hosting/6zbja7sn.png)

某天晚上小 G 和小 Y 本打算激情 CF 但过掉两题就下班了，然后他们准备玩一个游戏。

## 题目描述

给定一棵有 $n$ 个节点的无根树，边带权，树上有一个起始节点 $S$ 和一个终止节点 $T$。

有一枚可以沿着边在节点之间移动的棋子，它每次移动花费的硬币数量等于经过的边的权值。

如果当前棋子所在节点为 $u$ 且节点 $v$ 与节点 $u$ 之间连有一条权值为 $w$ 的边，小 G 就能花费 $w$ 个硬币把棋子移动到节点 $v$。游戏开始时棋子位于节点 $S$，我们的小 G 要控制棋子移动到节点 $T$。

由于曾经有人告诉小 G 玩某游戏不开挂等于没玩，小 G 决定开挂。他的外挂可以花费 $k$ 个硬币把棋子从当前节点传送到任意一个**没有和当前节点连边**的节点，小 G 只能用这个外挂至多一次。

正义的小 Y 不能坐视不管，在小 G 开始行动之前，小 Y 可以封锁至多 $m$ 条可能的传送路线。假设小 Y 封锁了从节点 $x$ 向节点 $y$ 的传送路线，小 G 把棋子从节点 $x$ 传送到节点 $y$ 花费的硬币数量就会变成 $10^9$。由于外挂功能强大，小 G 知道小 Y 都封锁了哪些路线。**请注意传送路线是单向的，封锁节点 $x$ 向节点 $y$ 的传送路线不影响小 G 从节点 $y$ 向节点 $x$ 传送。**

有趣的是，游戏中小 G 不仅负责控制棋子移动到节点 $T$，还想**最小化**花费的硬币数量；而小 Y 想要**最大化**小  G 花费的硬币数量。

如果两人都采取最优策略，小 G 总共会花掉多少硬币？

## 说明/提示

**「样例解释 #1」**

![example](https://cdn.luogu.com.cn/upload/image_hosting/1u16xc9r.png)

给出一种可能发生的情况：小 Y 封锁节点 $1$ 向节点 $2$ 的传送路线和节点 $4$ 向节点 $2$ 的传送路线。

小 G 控制棋子从初始节点到达节点 $4$，从节点 $4$ 传送到节点 $3$ 后再到达终止节点，总共花费 $14$ 个硬币。

**「数据范围」**

**本题采用捆绑测试。**

|Subtask|$n\leq$|$m \leq$|特殊性质|分值|
|:---:|:---:|:---:|:---:|:---:|
|**#1**|$1000$|$10^5$|无|$10$|
|**#2**|$10^5$|$0$|无|$10$|
|**#3**|$10^5$|$10^5$|无|$10$|
|**#4**|$10^5$|$10^9$|A|$15$|
|**#5**|$10^5$|$10^9$|B|$15$|
|**#6**|$10^5$|$10^9$|无|$40$|

- 特殊性质 A：保证 $k=10^9$。
- 特殊性质 B：保证 $k=0$。

对于所有测试数据，$2 \leq n \leq 10^5$，$0 \leq m,k \leq 10^9$，$1 \leq S,T,u_i,v_i \leq n$，$1 \leq w_i \leq 10^9$，$S \neq T$，$u_i \neq v_i$。节点的编号是从 $1$ 到 $n$ 的整数。

2024 年 8 月 4 日：将样例置于 Subtask #0。

## 样例 #1

### 输入

```
4 2 2 1 2
2 3 6
4 1 6
3 1 8
```

### 输出

```
14
```

## 样例 #2

### 输入

```
9 7 4 1 6
3 8 7
6 8 6
6 7 4
2 5 3
3 2 2
3 9 12
2 1 2
8 4 11
```

### 输出

```
12
```

# 题解

## 作者：ScaredQiu (赞：29)

### 二分答案

小 Y 是 **Ycyofmine**，小 G 是不知名人士。

------------

#### Subtask #1

预处理每个节点到 $S$ 和 $T$ 的距离，枚举点对 $(u,v)$，如果枚举到的点对没有连边则计算从 $S$ 到达 $T$ 且中途从 $u$ 传送到 $v$ 的路径代价。

找到第 $m+1$ 小的路径代价，比较其与**直接走树边**和**花费 $10^9$ 代价传送**的代价，三种情况中的最小值即为答案。

时间复杂度 $O(n^2 \log n)$，容易优化到 $O(n^2)$。

#### Subtask #2

**注意到 $m=0$，此时可以直接从 $S$ 传送到 $T$**，比较 $k$ 和走树边的代价大小，较小值即为答案。

时间复杂度 $O(n)$。

**该做法可以通过 Subtask #2 和 Subtask #4 并获得 $25$ 分。**

#### Subtask #3

考虑贪心，类似[最小函数值](https://www.luogu.com.cn/problem/P2085)，使用堆维护全局最小路径，扩展到全局第 $m+1$ 小路径。

比较第 $m+1$ 小路径、走树边和在封锁路径上传送的代价，三种情况中的最小值即为答案。

时间复杂度 $O(m \log n)$。

**该做法可以通过前三个 Subtask 并获得 $30$ 分。**

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr long long inf=1'000'000'000ll;
struct Path{
    int i;long long w;
    Path(int x,long long y):i(x),w(y){}
    Path(){}
    bool operator<(const Path &x)const{
        return this->w>x.w;
    }
}d[100'005],p[100'005];
struct Edge{int w,to;Edge(int x,int y):w(x),to(y){}};
unordered_map<int,bool> on[100'005];
int n,m,k,S,T,pos[100'005];
vector<Edge> v[100'005];
priority_queue<Path> q;
void dfs(int x,int las,Path *u){
    for(auto i:v[x]) if(i.to!=las) u[i.to].w=u[x].w+i.w,dfs(i.to,x,u);
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m>>k>>S>>T;
    for(int i=1;i<=n-1;i++){
        static int x,y,w;
        cin>>x>>y>>w;
        v[x].push_back(Edge(w,y));
        v[y].push_back(Edge(w,x));
        on[x][y]=1,on[y][x]=1;
    }
    for(int i=1;i<=n;i++) d[i].i=i,p[i].i=i;
    dfs(S,0,d),dfs(T,0,p);
    sort(p+1,p+n+1,[](auto x,auto y){return x.w<y.w;});
    fill(pos+1,pos+n+1,1);
    for(int i=1;i<=n;i++){
        while(pos[i]<=n&&on[i][p[pos[i]].i]) ++pos[i];
        if(pos[i]<=n) q.push(Path(i,d[i].w+p[pos[i]].w+k)),++pos[i];
    }
    for(int i=1;i<=m&&!q.empty();i++){
        auto now=q.top();q.pop();
        while(pos[now.i]<=n&&on[now.i][p[pos[now.i]].i]) ++pos[now.i];
        if(pos[now.i]<=n) q.push(Path(now.i,d[now.i].w+p[pos[now.i]].w+k)),++pos[now.i];
    }
    long long ans=inf;
    if(!q.empty()) ans=min(ans,q.top().w);
    ans=min(ans,d[T].w);
    cout<<ans<<'\n';
    return 0;
}
```

#### Subtask #4

**注意到 $k=10^9$，封锁不会对传送造成影响**，比较 $10^9$ 和走树边的代价大小，较小值即为答案。

时间复杂度 $O(n)$。

#### Subtask #5

**注意到 $k=0$，传送没有代价**，考虑二分使用传送操作到达节点 $T$ 的路径代价。对于给定的值 $x$ 计算能凑出多少条长度不大于它的路径，若路径数量大于 $m$，则花费 $x$ 代价必定能从 $S$ 到 $T$，因为只有前 $m$ 小的路径会被封锁。

具体地，处理出节点到 $S$ 和 $T$ 的距离之后将每个节点到 $T$ 的距离从小到大排序，检查给定的值 $x$ 时枚举每个节点，令节点 $u$ 到 $S$ 的距离为 $dis_{u,S}$，二分得到满足 $dis_{u,S}+dis_{v,T} \leq x$ 的节点 $v$ 的数量，枚举与 $u$ 连边的节点排除不可传送的情况。

时间复杂度 $O(n \log n \log V)$，其中 $V$ 为二分上界。

#### Subtask #6

扩展 **Subtask #5** 的做法，二分出**不包含 $k$ 的**第 $m+1$ 小路径代价后，将代价加上 $k$ 并与直接走树边、花费 $10^9$ 代价传送比较，取最小值即可。

时间复杂度 $O(n \log n \log V)$，这里给出验题人 [shinzanmono](https://www.luogu.com/user/610557) 的代码。

```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
const int sz=1e5+10;
struct edge{
    int nxt,to,w;
}graph[sz<<1];
int head[sz],hpp;
void addEdge(int from,int to,int w){
    graph[++hpp]=edge{head[from],to,w};
    head[from]=hpp;
}
ll diss[sz],dist[sz];
void dfs(int u,int fau,ll *dis){
    for(int p=head[u];p;p=graph[p].nxt){
        int v=graph[p].to;
        if(v==fau)continue;
        dis[v]=dis[u]+graph[p].w;
        dfs(v,u,dis);
    }
}
int n,m,k,s,t;
std::basic_string<ll>td;
ll rank(ll dis){
    ll tot=0;
    for(int u=1;u<=n;u++){
        if(diss[u]+dist[u]<=dis)tot--;
        for(int p=head[u];p;p=graph[p].nxt){
            int v=graph[p].to;
            if(dist[v]+diss[u]<=dis)tot--;
        }
        tot+=std::upper_bound(td.begin(),td.end(),dis-diss[u])-td.begin();
    }
    return tot;
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin>>n>>m>>k>>s>>t;
    for(int i=1,u,v,w;i<n;i++)
        std::cin>>u>>v>>w,addEdge(u,v,w),addEdge(v,u,w);
    dfs(s,0,diss),dfs(t,0,dist);
    for(int i=1;i<=n;i++)td+=dist[i];
    std::sort(td.begin(),td.end());
    ll l=0,r=1e18;
    while(l<r){
        ll mid=l+r>>1;
        if(rank(mid)>=m+1)r=mid;
        else l=mid+1;
    }
    std::cout<<std::min({diss[t],l+k,1000000000ll})<<"\n";
    return 0;
}
```

可以双指针将检查的时间复杂度优化到 $O(n)$，总体时间复杂度 $O(n \log V)$。

这里列举一些实现中的细节。

- 写 $30$ 分做法时，堆可能被删空。
- 路径数量会爆 `int`，不开 `long long` 只能获得 $25$ 分。
- 二分下界是 $0$，设为 $1$ 只能获得 $50$ 分。
- 走树边和花费 $10^9$ 代价传送的情况都可能比找到没被封锁的点对后传送更优。
- 没有必要排除原地传送的情况，原地传送能计入路径数时走树边必定不劣。
- ~~我的代码跑构造数据访问了 99999 次空堆但结果还是对的。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr long long inf=1'000'000'000ll;
struct Edge{int w,to;Edge(int x,int y):w(x),to(y){}};
struct Path{int i;long long w;}d[100'005],p[100'005];
vector<Edge> v[100'005];
long long dis[100'005];
int n,m,k,S,T;
void dfs(int x,int las,Path *u){
    for(auto i:v[x]) if(i.to!=las) u[i.to].w=u[x].w+i.w,dfs(i.to,x,u);
}
bool fail(long long x){
    long long sum=0ll;
    int pos=n;
    for(int i=1;i<=n;i++){
        while(pos&&d[i].w+p[pos].w>x) --pos;
        sum+=pos;
        for(auto j:v[d[i].i]) if(d[i].w+dis[j.to]<=x) --sum;
        if(d[i].w+dis[d[i].i]<=x) --sum;
    }
    return sum<=m;
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m>>k>>S>>T;
    for(int i=1;i<=n-1;i++){
        static int x,y,w;
        cin>>x>>y>>w;
        v[x].push_back(Edge(w,y));
        v[y].push_back(Edge(w,x));
    }
    for(int i=1;i<=n;i++) d[i].i=i,p[i].i=i;
    dfs(S,0,d),dfs(T,0,p);
    for(int i=1;i<=n;i++) dis[i]=p[i].w;
    sort(d+1,d+n+1,[](auto x,auto y){return x.w<y.w;});
    sort(p+1,p+n+1,[](auto x,auto y){return x.w<y.w;});
    long long l=0ll,r=inf,ans=inf;
    while(l<=r){
        long long mid=(l+r)/2;
        if(fail(mid)) l=mid+1;
        else ans=mid,r=mid-1;
    }
    ans=min(ans+k,min(inf,dis[S]));
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：zjpwdyf (赞：21)

## 0. 前言

一开始看到这道题，以为是什么双人博弈问题，后来仔细一分析，并没有那么复杂。

主要考察的知识点有：树的遍历，二分，贪心。

## 1. 思路

先考虑小 G 有哪些行走方案。

记 $\text{dis}(x, y)$ 为 $x$ 到 $y$ 的简单路径上 $w$ 之和。

令 $\rightarrow$ 表示走树边，$\Rightarrow$ 表示使用传送门传送。

**方案一**：直接走树边，即 $s \rightarrow t$，代价为 $\text{dis}(s, t)$。

**方案二**：使用传送门。因为小 Y 会封锁部分传送门，所以可能并不能直接 $s \Rightarrow t$，而是 $s \rightarrow x \Rightarrow y\rightarrow t$，代价为 $\text{dis}(s, x) + k + \text{dis}(y, t)$。

**方案三**：直接走封锁后 $s$ 到 $t$ 的传送门，代价为 $10^9$。

可能存在其他方案，但一定不会更优。

---

考虑封锁传送路线会带来什么。

显然方案二会受到影响。因为小 Y 想让答案最大，所以 $\text{dis}(s, x) + \text{dis}(y, t)$ 要尽可能大。换句话讲，对于传送路线 $x \Rightarrow y$ 而言，如果其代价 $\text{dis}(s, x) + \text{dis}(y, t)$ 比较小，那么小 Y 会将其封锁。

不难想到小 Y 封锁的是代价前 $m$ 小的传送路径。

所以小 G 如果采取第二种方案，那么走的是代价第 $m+1$ 小的传送路径。

## 2. 实现

首先要处理两点之间的 $\text{dis}$，可以用树上倍增，但是这明显超纲。观察到 $\text{dis}$ 函数必定以 $s$ 或 $t$ 为一端，于是分别处理 $s$ 和 $t$ 到其他点的 $\text{dis}$ 即可，这里使用 dfs：

```cpp
void dfs(ll x, ll fa, ll sum, ll dis[]) {
	dis[x] = sum;
	for(edge e : G[x]) {
		ll y = e.v, z = e.w;
		if(y == fa) continue;
		dfs(y, x, sum + z, dis);
	}
}
```

代码中，`x` 表示当前节点，`fa` 表示 `x` 的父节点，`sum` 表示树根到 `x` 的 $\text{dis}$，`dis[]` 为距离数组。

原理：若 $r$ 为树根，$y$ 为 $x$ 的孩子，$w$ 表示走树边 $x \to y$ 的代价，则有：
  $$\text{dis}(r, y) = \text{dis} (r, x) + w$$

---

其次，也是本题中最难的点，找到代价第 $m+1$ 小的传送路径。类似 [序列合并](https://www.luogu.com.cn/problem/P1631)。

采取二分答案的方法。二分最大代价 $\text{mx}$，然后统计有多少条代价 $\le \text{mx}$ 的传送路径，若条数 $>m$，则合法。最终答案即 $\text{mx}$ 的最小值。

发现难点在于统计条数。考虑枚举 $x$，查询满足 $\text{dis}(y, t) \le \text{mx} - \text{dis}(s,x)$ 的 $y$ 的个数，这可以先对以 $t$ 为起点的 $\text{dis}$ 数组进行排序，然后二分查找即可。

值得注意的是，这样统计，可能会把 $x, y$ 之间不存在传送门（即 $x, y$ 之间有树边）的情况也统计进去，所以需要花 $O(n)$ 的时间遍历每条树边，把多余情况减去。

二分答案：

```cpp
ll l = 0, r = 1e18, t = 1e18;
while(l <= r) {
	ll mid = (l + r) / 2;
	if(check(mid)) t = mid, r = mid - 1;
	else l = mid + 1;
}
```

值得注意的是，可能出现 $m$ 非常大的情况，此时 `check` 函数永远返回 false，`t` 的值不会被更新。故 `t` 的初值要赋成无穷大。

`check` 函数：

```cpp
bool check(ll mid) {
	ll sum = 0;
	for(ll i = 1; i <= n; i++)
		sum += upper_bound(tt + 1, tt + n + 1, mid - ss[i]) - tt - 1;
	for(ll i = 1; i <= n; i++) {
		for(edge e : G[i]) {
			ll j = e.v;
			if(ds[i] + dt[j] <= mid) sum--;
		}
	}
	return sum > m;
}
```

其中 `ds` 和 `dt` 分别表示 $s$ 和 $t$ 到其他点的 $\text{dis}$，`ss` 和 `tt` 为排序后的 `ds` 和 `dt`。

## 3. 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 1e5 + 5, cst = 1e9;
struct edge { ll v, w; };
ll n, m, k, S, T, u, v, w;
ll ds[N], dt[N], ss[N], tt[N];
vector <edge> G[N];
void dfs(ll x, ll fa, ll sum, ll dis[]) {
	dis[x] = sum;
	for(edge e : G[x]) {
		ll y = e.v, z = e.w;
		if(y == fa) continue;
		dfs(y, x, sum + z, dis);
	}
}
bool check(ll mid) {
	ll sum = 0;
	for(ll i = 1; i <= n; i++)
		sum += upper_bound(tt + 1, tt + n + 1, mid - ss[i]) - tt - 1;
	for(ll i = 1; i <= n; i++) {
		for(edge e : G[i]) {
			ll j = e.v;
			if(ds[i] + dt[j] <= mid) sum--;
		}
	}
	return sum > m;
}
int main() {
	cin >> n >> m >> k >> S >> T;
	for(ll i = 1; i < n; i++) {
		cin >> u >> v >> w;
		G[u].push_back({v, w});
		G[v].push_back({u, w});
	}
	dfs(S, 0, 0, ds);
	dfs(T, 0, 0, dt);
	for(ll i = 1; i <= n; i++)
		ss[i] = ds[i], tt[i] = dt[i];
	sort(ss + 1, ss + n + 1);
	sort(tt + 1, tt + n + 1);
	ll l = 0, r = 1e18, t = 1e18;
	while(l <= r) {
		ll mid = (l + r) / 2;
		if(check(mid)) t = mid, r = mid - 1;
		else l = mid + 1;
	}
	cout << min(ds[T], min(t + k, cst));
	return 0;
}
```

### 4. 结语

作为一道 Div3 D，这道题还是挺考验基本功的。

如果对本题解有任何疑问，可以在评论区指出或私信我。

如果您喜欢这篇题解，记得点个赞喵。你们的赞就是我把题解写得更好的动力~

---

## 作者：ty_mxzhn (赞：6)

题意是选出一个 $S \to a \to b \to T$ 的路径，然后 $a\to b$ 是用传送传过去的。

有三种方法：

1. 不开挂，直接走过去。
2. 开挂，但是我们不敢被小 Y 堵。
3. 开挂，但是我们不怕被小 Y 堵！直接传送过去终点。

第 $1$ 种和第 $3$ 种都很简单。我们考虑第 $2$ 种怎么做。现在前 $m$ 大的解都被小 Y 堵了，所以小 G 会选到第 $m+1$ 大的解。我们可以二分 $x$，然后求出有多少条合法路径满足其代价 $\le x$。

合法路径中，代价分为两个部分，一个是 $S\to a$，另一个是 $b \to T$。那么这两部分的代价都可以直接预处理。二分判定时，我们可以直接把代价双指针。

但是注意题目里面还有一个限制，那我们直接就把这部分限制不满足的合法路径从计数中去除就可以了。

时间复杂度 $O(n \log V)$。

# 题解翻译

The problem is to find a path of $S \to a \to b \to T $, and then $a \to b $ is by teleportation.

There are three cases:

1. Don't open the hook, walk straight over.
2. Open the hook, but we can't be blocked by Little Y.
3. Open the hook, but we are not afraid of being blocked by Little Y. We can directly teleport to the destination.

The first and third cases are both very simple. We are considering how to deal with the second case. 

Now, all the solutions with the $m$ th biggest are blocked by Little Y, so Little G will choose the solution with the $m+1$ th biggest. We can use binary search, get $x$ and then determine how many valid paths satisfy its cost $\le x $.

In a path, the cost can be divided into two parts, one is $S \to a$ and another is $b \to T $. So the costs of both parts can be directly preprocessed.

When we judge the answer, we can directly use two-pointer to solve this.

But please note that there is another restriction in the question, so we can simply remove the invalid paths from the count.

The solution is $O(n \log V)$.

**The Code is here**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

struct stu{
	int v,w;
}h[100007];
vector<stu> g[100007];
int n,m,k,S,T,dis[2][100007],a[2][100007];
void dfs(int u,int fa,int p){ // get distance from S,T
	a[p][u]=dis[p][u];
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i].v,w=g[u][i].w;
		if(v==fa) continue;
		dis[p][v]=dis[p][u]+w;
		dfs(v,u,p);
	}
}
bool check(int x){ //check how many val<=x
	int ans=0;
	for(int i=1,r=n;i<=n;i++){ // two-pointers to find all cases
		while(r>0&&a[0][r]+a[1][i]>x) r--; // max pos:val<=x
		ans+=r;
	}
	for(int i=1;i<n;i++){ // except invalid cases
		int u=h[i].v,v=h[i].w;
		if(dis[0][u]+dis[1][v]<=x) ans--;
		if(dis[0][v]+dis[1][u]<=x) ans--;
	}
	return ans>=m+1;
}
signed main(){
	scanf("%lld%lld%lld%lld%lld",&n,&m,&k,&S,&T);
	for(int i=1,x;i<n;i++){
		scanf("%lld%lld%lld",&h[i].v,&h[i].w,&x);
		g[h[i].v].push_back((stu){h[i].w,x});
		g[h[i].w].push_back((stu){h[i].v,x});
	}
	// preprocess
	dfs(S,-1,0);
	dfs(T,-1,1);
	sort(a[0]+1,a[0]+n+1);
	sort(a[1]+1,a[1]+n+1);
	int lb=-1,ub=1e18;
	while(ub-lb>1){ // binary search
		int mid=(lb+ub)>>1;
		if(check(mid)) ub=mid;
		else lb=mid;
	}
	printf("%lld\n",min(1000000000ll,min(ub+k,dis[0][T]))); // merge 3 cases
	return 0;
}
```

---

## 作者：LiaoYF (赞：3)

场切。
## 做法

感觉思路比较经典？

想到二分答案，二分是否能用 $m$ 次操作使得距离大于等于 $x$。于是我们要求出此时最少的操作次数。

不传送的情况首先判掉。如果传送，路径一定长成 $S$ 走到 $A$ 传送到 $B$ 再走到 $T$ 的样子。那么我们枚举 $A$，因为我们要让所有路径长度大于等于 $x$，所以需要封锁从 $A$ 到所有距离 $T$ 在 $x-dis(S,A)-k$ 以内的点的传送。

然后预处理 $S$ 和 $T$ 到每一个点的距离，以及每一个点的相邻的点到 $T$ 的距离（不能传送到相邻的点）。然后二分就可以找到有多少点满足距离 $T$ 在 $x-dis(S,A)-k$ 以内了。时间复杂度 $O(n \log n \log V)$。

注意答案需要跟 $10^9$ 取 `min`。 

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
using namespace std;
#ifdef LOCAL
#include "debug.h"
#else
#define debug(...) 42
#endif
const int inf=1e18;
const int N=100005;
int n,m,k,s,t,f[2][N];
vector<pii> G[N];
void dfs(int u,int fa,int dis[]){
    for(auto &[v,w]:G[u]){
        if(v==fa)continue;
        dis[v]=dis[u]+w;
        dfs(v,u,dis);
    }
}
vector<int> b,c[N];
bool check(int x){//能否用m的操作次数使得距离>=x
    if(f[0][t]<x)return 0;
    int cnt=0;
    for(int i=1;i<=n;i++){//从s出发走到i
        if(f[0][i]>x)continue;
        int now=x-f[0][i]-k;//还剩下now的花费可以使用
        //要封锁从i到[所有到 t now 步以内的点]
        int pos=lower_bound(b.begin(),b.end(),now)-b.begin();
        int pos2=lower_bound(c[i].begin(),c[i].end(),now)-c[i].begin();
        cnt+=pos-pos2;
    }
    return cnt<=m;
}
void solve(){
    cin>>n>>m>>k>>s>>t;
    for(int i=1;i<n;i++){
        int u,v,w;
        cin>>u>>v>>w;
        G[u].push_back({v,w});
        G[v].push_back({u,w});
    }
    dfs(s,0,f[0]);
    dfs(t,0,f[1]);
    for(int i=1;i<=n;i++){
        b.push_back(f[1][i]);
    }
    for(int i=1;i<=n;i++){
        for(auto &[v,w]:G[i]){
            c[i].push_back(f[1][v]);
        }
        sort(c[i].begin(),c[i].end());
    }
    sort(b.begin(),b.end());
    int l=0,r=inf,res=0;
    while(l<=r){
        int mid=(l+r)/2;
        if(check(mid)){
            l=mid+1;
            res=mid;
        }else{
            r=mid-1;
        }
    }
    cout<<min((int)1e9,res)<<"\n";
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t,multitest=0;
    if(multitest)cin>>t;
    else t=1;
    while(t--){
        solve();
    }
    return 0;
}
```

---

## 作者：ZHR100102 (赞：2)

# 转化题意

因为要封锁 $m$ 条路径，根据贪心思想，他一定会封锁最短的 $m$ 条路径。所以我们能走的最短传送路径就是最短的第 $m+1$ 条路径。

这应该是本题最关键的一步转化了，几个月前降智了根本没想到这个。

# 做法

求第 $m+1$ 短的路径，这个很显然通过二分求解，求出**最后一个**比它小的数的个数小于 $m+1$ 个的数。

二分 check 函数的实现也是容易的，我们从起点 $s$ 与终点 $t$ 各自做一遍 dfs 求出两个点与其他点之间的距离，然后按路径长度从小到大排序。注意这时候要记录下标以进行相邻点传送与同点转送的特判。

接下来我们对于每一个传送起点，通过双指针维护最后一个小于 $dis$ 的指针 $p$ 计算出该点的贡献，最后遍历与该点相邻的点，判断他们是否被统计进答案，如果被统计进了就删掉这个贡献即可。注意自己传送到自己的情况也要特判。

答案在传送路径、直接走的路径和直接从 $s$ 传送到 $t$ 的 $10^9$ 代价里取最小值即可。

时间复杂度 $O(n \log v)$。

# 代码

细节挺多的，尤其是 check 函数。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;
int n,m,k,s,t;
struct edge{
    int to,w;
};
struct node{
    ll w,id;
}d[2][100005];
ll td[100005];
vector<edge>g[100005];
bool cmp(node a,node b)
{
    return a.w<b.w;
}
void dfs(int u,int fa,int mode)
{
    for(auto eg:g[u])
    {
        int v=eg.to,w=eg.w;
        if(fa==v)continue;
        d[mode][v].w=d[mode][u].w+w;
        dfs(v,u,mode);
    }
}
ll check(ll dis)
{
    ll res=0,p=n;
    for(int i=1;i<=n;i++)
    {
        while(p>0&&d[0][i].w+d[1][p].w>=dis)p--;
        res+=p;
        int u=d[0][i].id;
        for(auto eg:g[u])
        {
            int v=eg.to;
            if(d[0][i].w+td[v]<dis)res--;
        }
        if(d[0][i].w+td[u]<dis)res--;
    }
    return res;
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>k>>s>>t;
    for(int i=1;i<n;i++)
    {
        int u,v,w;
        cin>>u>>v>>w;
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }
    dfs(s,0,0);
    dfs(t,0,1);
    for(int i=1;i<=n;i++)
    {
        d[0][i].id=i;
        d[1][i].id=i;
        td[i]=d[1][i].w;
    }
    sort(d[0]+1,d[0]+n+1,cmp);
    sort(d[1]+1,d[1]+n+1,cmp);
    ll l=0,r=1e18,mid;
    while(l<r)
    {
        mid=(l+r+1)>>1;
        if(check(mid)<m+1)l=mid;
        else r=mid-1;
    }
    ll ans=min(ll(1e9),min(l+k,td[s]));
    cout<<ans;
    return 0;
}
```

---

## 作者：yanbinmu (赞：2)

## 分析

显然的，因为小 G 只能开一次挂，所以他的行进路线只能是以下三种：

1. 走 - 传送;
2. 传送 - 走;
3. 走 - 传送 - 走;

前两种情况我们可以通过两遍 dfs 求得每一个点分别到 $S$ 和 $T$ 的路径长度，然后看传送是否比走更优。

然后我们考虑第三种情况，发现第三种情况可以将前两种情况包含（最开始一步也不走就是情况一）。

因为小 Y 会封掉最短的 m 条路径，那我们要求的就是第 $m + 1$ 长的路径。

考虑二分答案，我们去二分硬币花费，然后看有没有 $m$ 条比他短的路径。

那如何 check 呢？

如果我们知道了我们是先从 $S$ 一步步走到 $x$ 然后传送到 $y$ 再从 $y$ 走到 $T$，那么我们的花费就是：

$$
disS_x + k + disT_y
$$

其中 disS 为一个点到 S 的距离，disT 为到 T 的距离。

我们考虑枚举 $x$。

那么我们只需要统计有多少个 $y$ 满足：

$$
disS_x + k + disT_y \le mid
$$

发现我们不需要考虑 $y$ 到底是谁，只需要关注 $disT_y$ 的大小。

我们将其排序，就可以二分查找出满足条件的 $y$ 的个数。

使用双指针可将 check () 的复杂度优化为 $O(n)$。

同时我们应考虑传送到两点之间是否有边相连，我们遍历每一个点以及其连边，看这两点是否满足情况，如满足则从方案数中减去。

### 细节

可能会将所有传送封起来，这是我们要比较顶着 $10^9$ 的惩罚硬跳和一步步走过去的大小。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 100005;

struct node {
	int to, nxt, w;
}edge[N << 1];

int head[N], tot = 1;
void add(int u, int  v, int w) {
	edge[tot].to = v;
	edge[tot].w = w;
	edge[tot].nxt = head[u];
	head[u] = tot ++ ;
}

int dis[N];
int disS[N], disT[N];

void dfsS(int u, int fa) {
	for(int i = head[u];i;i = edge[i].nxt) {
		int v = edge[i].to;
		if(v == fa) continue;
		disS[v] = disS[u] + edge[i].w;
		dfsS(v, u);
	}
}

void dfsT(int u, int fa) {
	for(int i = head[u];i;i = edge[i].nxt) {
		int v = edge[i].to;
		if(v == fa) continue;
		disT[v] = disT[u] + edge[i].w;
		dfsT(v, u);
	}
}

int n, m, k, S, T;

bool check(int mid) {
	int cnt = 0;
	for(int i = 1, j = n;i <= n;i ++ ) {
		cnt += upper_bound(dis + 1, dis + n + 1, mid - (disS[i] + k)) - dis - 1;
		// upper_bound 找比 mid - (disS[i] + k) 严格大于的，减一后就是小于等于。
	}
	for(int i = 1;i <= n;i ++ ) {
		for(int j = head[i];j;j = edge[j].nxt) {
			int v = edge[j].to;
			if(disS[i] + k + disT[v] <= mid) cnt -- ;
		}
	}
	if(cnt > m) return 1;
	else return 0;
}

signed main() {
	cin >> n >> m >> k >> S >> T;
	for(int i = 1;i < n;i ++ ) {
		int u, v, w;
		cin >> u >> v >> w;
		add(u, v, w);
		add(v, u, w);
	}
	dfsS(S, 0);
	dfsT(T, 0);
	memcpy(dis, disT, sizeof(disT));
	sort(dis + 1, dis + n + 1);// 将到 T 的路径长度排序
	
	int l, r, ans; // 二分答案
	/*
	mid 为一条路线的权值， 去看有没有 m 条比他小的路线
	check 需要为 O(n log n)
	枚举一个点 x，
	disT[y] <= mid - (disS[x] + k)
	*/
	l = 0, r = 1e9;//
	ans = 1e9;//将 ans 设置为直接从 S 跳到 T的花费
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid)) {
			r = mid - 1;
			ans = mid;
		}
		else l = mid + 1;
	}
	cout << min(disS[T], ans);
	return 0;
} 
```

---

## 作者：NightTide (赞：2)

~~幽默样例写错两个地方反而能过导致调了 1h。~~

不难发现，小 G 的策略只有三种，不作弊老实走，走封锁线路花费 $10^9$ 速通，或者作弊。

前两种的值都是定值，可以很快求出来。现在来考虑第三种情况。

由于最多封锁 $m$ 条线路，所以在作弊情况下的第 $m + 1$ 短路就是作弊后的最优解。~~所以很容易想到构造分层图跑 $k$ 短路。~~

我们可以预处理出每个点分别到 $s$ 和 $t$ 的最短路程，再枚举传送的两个点 $u,v$，将所有值统计出来最后排个序，取第 $m + 1$ 个，时间复杂度 $O(n^2)$。

考虑二分答案，对于当前答案 $x$，只要路程小于等于 $x$ 的路径多于 $m$ 条，则 $x$ 可行。问题转化为如何统计路程小于等于 $x$ 的路径条数。

对于一条使用传送的路径来说，总路程分为三部分，$s$ 走树边到 $u$，耗费 $ds_u$；$u$ 传送到 $v$，耗费 $k$；$v$ 走树边到 $t$，耗费 $dt_v$。（$ds_i$ 和 $dt_i$ 分别表示 $i$ 到 $s$ 和 $i$ 到 $t$ 的距离。）

即 $dis = ds_u + k + dt_v$。

我们要求 $dis \le x$ 的个数，枚举 $u$，此时 $ds_u$ 与 $k$ 均为定值，即求 $dt_v \le x - k - ds_u$ 的个数，将 $dt$ 排序二分即可。

最终得到的答案再与不作弊老实走和走封锁线路花费 $10^9$ 速通的答案比较，取最小值。

时间复杂度 $O(n\log n \log V)$，$V$ 是二分值域，开到 $10^9$ 足够。若大于 $10^9$ 则不如走封锁路线速通。

代码如下：
```cpp
#include<bits/stdc++.h>
#define MAXN 500010
#define MAXM 1000010
using namespace std;
typedef long long ll;
struct edge{ ll pre, to, w; };
ll n, m, k, s, t, cnt;
edge e[MAXM];
ll head[MAXN], deep[MAXN], vis[MAXN], dis[MAXN], ans[MAXN], dis_s[MAXN], dis_t[MAXN], dt[MAXN];
ll fa[MAXN][30];
void add_edge(ll u, ll v, ll w){
	e[++cnt].pre = head[u];
	e[cnt].to = v; e[cnt].w = w;
	head[u] = cnt;
}
void bfs(ll root){
	queue<ll> s;
	s.push(root);
	vis[root] = true;
	deep[root] = 0; dis[root] = 0;
	while(!s.empty()){
		ll p = s.front(); s.pop();
		for(ll i = head[p]; i; i = e[i].pre){
			if(!vis[e[i].to]){
				vis[e[i].to] = true;
				deep[e[i].to] = deep[p] + 1;
                dis[e[i].to] = dis[p] + e[i].w;
				fa[e[i].to][0] = p;
				s.push(e[i].to);
			}
		}
	}
}
ll get_lca(ll x, ll y){
	if(deep[x] < deep[y]) swap(x, y);
	ll maxi=0;
	while((1 << maxi) <= deep[x]) maxi++;
	maxi--;
	for(ll i = maxi; i >= 0; i--){
		if(deep[x] - (1 << i) >= deep[y]){
			x = fa[x][i];
		}
	}
	if(x == y) return x;
	for(ll i = maxi; i >= 0; i--){
		if(fa[x][i] != fa[y][i]) x=fa[x][i], y=fa[y][i];
	}
	return fa[x][0];
}
ll get_dis(int u, int v){
    ll lca = get_lca(u, v);
    ll ans = dis[u] + dis[v] - dis[lca] * 2;
    return ans;
}
bool check(ll x){
    ll cnt = 0;
    for(int i = 1; i <= n; i++){
        ll tmp = x - dis_s[i];
        cnt += upper_bound(dt + 1, dt + n + 1, tmp) - dt - 1;
        for(int j = head[i]; j; j = e[j].pre){
            if(dis_t[e[j].to] <= tmp) cnt--;
        }
        if(dis_t[i] <= tmp) cnt--;
    }
    return cnt > m;
}
int main(){
	scanf("%lld%lld%lld%lld%lld",&n,&m,&k,&s,&t);
	for(ll i = 1; i < n; i++){
        ll u, v, w;
		scanf("%lld%lld%lld",&u,&v,&w);
		add_edge(u, v, w); add_edge(v, u, w);
	}
	bfs(1);
	for(ll i = 1; (1 << i) <= n; i++){
		for(ll j = 1; j <= n; j++){
			fa[j][i] = fa[fa[j][i - 1]][i - 1];
		}
	}
    ll ans = get_dis(s, t);
    for(int i = 1; i <= n; i++){
        dis_s[i] = get_dis(i, s);
        dt[i] = dis_t[i] = get_dis(i, t);
    }
    sort(dt + 1, dt + n + 1);
    ll l = 0, r = 1e9, res = r;
    while(l < r){
        ll mid = (l + r) >> 1;
        if(check(mid)){
            r = mid;
            res = mid;
        }else{
            l = mid + 1;
        }
    }
    res = min(res + k, 1000000000ll);
    printf("%lld\n",min(ans, res));
}
```

---

## 作者：fengyaun (赞：1)

## [P10838 『FLA - I』庭中有奇树](\(https://www.luogu.com.cn/problem/P10838\))

### 前言

这是一道~~贪心~~二分好题。~~说实话我并不知道这属于二分还是贪心。~~

### 简化题意

给定一棵无根树，小 G 可以从 $u$ 花费 $w$ 到 $v$，或耗费 $k$ 进行一次从当前节点到**不和当前节连边的点**的点的传送（全局仅可使用一次）。小 Y 将 $m$ 条传送路径被封锁（题目不给出具体封锁路径），求在双方使用最优策略的情况下，小 G 总共的最小的花费。

### 分析

小 G 的最优路径一定是在直接走或走一段再跳再走一段（下文简称走跳走）。

我们预处理一个以 $S$ 为起点的最短路 $s$，然后预处理一个以 $T$ 为起点的最短路 $weight$，对于最优的走跳走定是以 $S$ 为起点最短的点传送至另一个以 $T$ 为起点最短的点。

但是小 Y 会封锁传送路径，若令其最优，则一定是封锁令走跳走的耗费前 $m$ 小的。

那么对于走跳走的情况一定是走第 $m + 1$ 大的最优。这道题就变成了对于 $dis$ 和 $weight$，求 $dis_i + weight_i$ 的第 $m + 1$ 大是什么。

那么怎么寻找 $dis_i + weight_i$ 的第 $m + 1$ 大。

我们考虑二分答案，先将 $weight$ 的值排序。随后二分第 $k$ 大的值 $mid$，遍历每一个 $dis_i$ 求 $dis_i + weight_i > mid$ 的个数，如果大于 $k$ 个，那么移动右边界，否则移动左边界。

### 实现

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

int n, m, k, S, T;

long long answer;

long long dis[N];

long long value[N];

long long weight[N];

bool vis[N];

queue<int> cnt;

vector<pair<int, int>> edges[N];

void init()
{
    for (int i = 1; i < N; i++)
    {
        dis[i] = LONG_LONG_MAX;
        weight[i] = LONG_LONG_MAX;
    }
}

void spfa(int address, long long *tot)
{
    int cur;
    tot[address] = 0;
    vis[address] = true;
    cnt.push(address);
    while (!cnt.empty())
    {
        cur = cnt.front();
        cnt.pop();
        vis[cur] = false;
        for (auto v : edges[cur])
        {
            if (tot[v.first] > tot[cur] + v.second)
            {
                tot[v.first] = tot[cur] + v.second;
                if (!vis[v.first])
                {
                    vis[v.first] = true;
                    cnt.push(v.first);
                }
            }
        }
    }
}

bool check(long long mid)
{
    long long cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        cnt += upper_bound(weight + 1, weight + n + 1, mid - dis[i]) - weight - 1;
        for (auto v : edges[i])
        {
            if (dis[i] + value[v.first] <= mid)
            {
                cnt--;
            }
        }
    }
    return cnt > m;
}

int main()
{
    init();
    cin >> n >> m >> k >> S >> T;
    for (int i = 1, u, v, w; i <= n; i++) // 注意为无向图
    {
        cin >> u >> v >> w;
        edges[u].push_back({v, w});
        edges[v].push_back({u, w});
    }
    spfa(S, dis); // 求 dis
    spfa(T, weight); // 求 weight
    for (int i = 1; i <= n; i++)
    {
        value[i] = weight[i];
    }
    sort(weight + 1, weight + n + 1);
    long long l = 0; // 二分第 m + 1 大
    long long r = 1e18;
    long long ans = 1e18;
    long long mid;
    while (l <= r)
    {
        mid = (l + r) / 2;
        if (check(mid))
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    cout << min({ans + k, dis[T], 1000000000LL}); // 如果答案大于1e9，那么就可以直接花费1e9跳
    return 0;
}
```

---

## 作者：JiuZhE66666 (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P10838)

[更好的阅读体验](https://www.cnblogs.com/pure4knowledge/p/18347141)

# 获取题意

只能**传送**一次。

走树边没有限制。

只能传送至非相邻节点。

路径一定是如下形式之一：

$S\to x \to T$ 其中要么 $x\to T$ 传送要么 $S\to x$ 传送。

$S\to x \to y \to T$ 其中 $x\to y$ 传送。

$S\to T$ 要么直接传送，要么全程走树边。



# 分析

我们发现，如果传送，那么每一组**传送**对应的**最短路径**是**唯一**的。

因此，我们可以遍历所有传送起点 $x$ 和传送终点 $y$，计算 $dis_{S,x}$ 和 $dis_{y,T}$。

然后累加上代价取第 $m+1$ 小，时间复杂度 $O(n^2)$。

# 考虑优化。

由于传送的代价都是一样的，因此求第 $m+1$ 小的传送最短路径等价于求第 $m+1$ 小的 $dis_{S,x}+dis_{y,T}$。

我们预处理所有点到 $S$ 和 $T$ 的距离，排好序，将排好序的数组分别记作 $a$ 和 $b$。

该问题就变成了取所有 $a_i+b_j$ 中的第 $m+1$ 小。

这是一个[经典的问题](https://www.luogu.com.cn/problem/P1631)，我们可以用堆处理。

时间复杂度 $O(m\cdot \log n)$。

# 再次考虑优化。

我们换个角度思考，给定一个值，求有多少 $a_i+b_j$ 比它小，怎么求？

这又是一个[经典的问题](https://acm.hdu.edu.cn/showproblem.php?pid=7409)，我们可以用双指针求出 ，这样我们只需要二分查找这个值就可以了。

时间复杂度 $O(n\cdot \log n+n\cdot \log V)$。

注意细节：也可以不传送，也可以走被封锁的路。

# code

```
#include<bits/stdc++.h>
using namespace std;

#define int long long

struct node
{
    int to, val;
};
vector<node> G[200005];

struct fresh
{
    int id, val;
} dis1[200005], dis2[200005], dis3[200005], dis4[200005];

void dfs1(int now, int fa, int val)
{
    dis1[now].val = val;
    dis1[now].id = now;

    dis3[now].val=val;
    dis3[now].id=now;

    for(auto next : G[now])
    {
        auto [to, len] = next;
        if(to == fa) continue;
        dfs1(to, now, val + len);
    }
}

void dfs2(int now, int fa, int val)
{
    dis2[now].val = val;
    dis2[now].id = now;

    dis4[now].val=val;
    dis4[now].id=now;
    for(auto next : G[now])
    {
        auto [to, len] = next;
        if(to == fa) continue;
        dfs2(to, now, val + len);
    }
}

struct unit
{
    int val, x, y;
    bool operator < (const unit &c) const
    {
        return c.val < val;
    }
};
const int inf = 1e9;

int n, m, k, s, t;

bool check(int x)
{
    int it2 = n;
    int sum = 0;
    for(int i = 1; i <= n; i++)
    {
        while(it2 && dis2[it2].val + dis1[i].val > x) it2--;
        sum += it2;
        if(!it2) break;

        for(auto next : G[dis1[i].id])
        {
            if(dis1[i].val + dis4[next.to].val <=x) sum--;//相邻节点无法传送
        }
        if(dis1[i].val + dis4[dis1[i].id].val <= x) sum--;
    }
    return sum>=m+1;
}

void solve()
{
    cin >> n >> m >> k >> s >> t;

    for(int i = 1; i < n; i++)
    {
        int x, y, w;
        cin >> x >> y >> w;
        G[x].push_back({y, w});
        G[y].push_back({x, w});
    }

    dfs1(s, s, 0);
    dfs2(t, t, 0);

    int ans = dis1[t].val; // 不传送，直接走树边

    sort(dis1 + 1, dis1 + 1 + n, [](auto b, auto c) { return b.val < c.val; });
    sort(dis2 + 1, dis2 + 1 + n, [](auto b, auto c) { return b.val < c.val; });

    ans=min(ans,dis1[1].val+dis2[1].val+(m?inf:k));//直接传送，不走树边

    int l = 0, r = 2e14;
    while(l + 1 < r)
    {
        int mid = (l + r) / 2;
        if(check(mid)) r = mid;
        else l = mid;
    }

    ans = min(ans, r + k);//传送和树边都走

    cout << ans << '\n';
}

signed main()
{
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int TT = 1;
    // cin >> TT;
    while(TT--) solve();
    return 0;
}

```

---


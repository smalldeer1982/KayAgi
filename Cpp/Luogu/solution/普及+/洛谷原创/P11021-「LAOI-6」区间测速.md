# 「LAOI-6」区间测速

## 题目描述

小 A 正在一条笔直的公路上行驶（可以随时掉头，掉头的时间和路程忽略不计），这条公路可以被抽象为一条数轴。

你现在得到了 $n$ 个监控的信息，第 $i$ 条信息记录到：小 A 在 $t_i$ 时刻经过了坐标为 $x_i$ 之处。

有 $m$ 次询问，第 $i$ 次询问给定 $u_i$ 和 $v_i$，表示：假如将第 $u_i$ 个监控记录到小 A 经过 $x_i$ 的时间改为 $v_i$，小 A 所有可能的行驶过程中，最快时速的最小值是多少（答案向下取整）？**询问之间互相独立，即每次询问的改动是暂时的**。

### 形式化题意

给定 $n,m$，有长度为 $n$ 的数组 $x$ 与 $t$。进行 $m$ 次独立的修改，第 $i$ 次会将 $t_{u_i}$ 修改为 $v_i$，并询问：

$$\max_{i=1}^{n}\max_{j=i+1}^n \left\lfloor\frac{|x_i-x_j|}{|t_i-t_j|}\right\rfloor$$

**前一次修改不会影响后一次修改，即询问结束后会撤销修改**。

## 说明/提示

样例解释：

第 $1$ 次询问：

小 A 第 $0$ 时刻位于 $-5$，第 $1$ 时刻位于 $-10$，第 $2$ 时刻位于 $10$，第 $5$ 时刻位于 $0$，第 $7$ 时刻位于 $10$，最快时速最慢是 $20$（$1$ 时刻到 $2$ 时刻，从 $-10$ 移动到 $10$ 的时候）。

---

本题共有 $10$ 个测试点，每个测试点分值均为 $10$ 分。

| 测试点编号 | 特殊性质 |
| :----------: | :----------: |
| $1 \sim 3$ | $n,m\leq 10^3$ |
| $4 \sim 5$ | $-10^5\leq x_i\leq 10^5$ |
| $6 \sim 7$ | $m\leq 100$ |
| $8 \sim 10$ | N/A |

对于 $100\%$ 的数据，$2\leq n\leq 10^5$，$1\leq m\leq 10^5$，$-10^9\leq x_i\leq 10^9$，$0\leq t_i,v_i\leq 10^9$，$1\leq u_i\leq n$，保证任意时刻不存在两个监控记录的时间相同。

## 样例 #1

### 输入

```
5 3
10 3
-10 1
0 5
-5 0
10 7
1 2
2 2
3 100```

### 输出

```
20
20
10```

# 题解

## 作者：zhuweiqi (赞：13)

求答案并不难，将 $t_i$ 排序，容易发现只需要求 $\max\limits_{i=1}^{n-1}\left\lfloor\frac{|x_i-x_{i+1}|}{|t_i-t_{i+1}|}\right\rfloor$ 的值即可，因为如果 $i,j$ 不相邻，且其中小区间的值都比大区间的小，大区间才有可能是最优解，但显然这不可能，大区间的值一定在所有小区间的最小值和最大值这个范围内。

因此，现在我们要解决如何快速求出修改后的答案这个问题：

注意到每次修改能影响答案的值只有三个：由于原来那个时间点的记录信息没了，所以需要将其左右两边的小区间（这里的小区间指的是相邻两点之间的区间，下同）合并为一个区间，答案可能会变小，同理，由于有新的时间点产生了记录信息，所以就要把原来包含这个时间点的小区间切割成两个区间，答案就可能会变大。最方便实现的是用 set 维护时间点，当然，用普及组的方法配合一些记录数组也是能做的，只不过稍微麻烦了一点。

下面给出由 [jason_sun](https://www.luogu.com.cn/user/399762) 大佬提供的 std：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2e5+5;
int a[N], b[N];
vector<pair<ll,ll>> vc1;
vector<ll> vc2, vc3, vc4;
int get(pair<ll,ll> x, pair<ll,ll> y){
	return abs(x.second-y.second)/abs(x.first-y.first);
}
void insert(int x, int y, int p, int q){
	auto it=lower_bound(vc1.begin(), vc1.end(), make_pair((ll)x, (ll)y));
	auto it1=it, it2=it;
	it1--;
	if(*it1==make_pair((ll)p, (ll)q)) it1--;
	if(*it2==make_pair((ll)p, (ll)q)) it2++; 
	vc4.push_back(get(*it1, {x, y}));
	vc4.push_back(get({x, y}, *it2));
}
void erase(int x, int y){
	auto it=lower_bound(vc1.begin(), vc1.end(), make_pair((ll)x, (ll)y));
	auto it1=it, it2=it;
	it1--, it2++;
	vc4.push_back(get(*it1, *it2));
	vc3.push_back(get(*it1, *it));
	vc3.push_back(get(*it, *it2));
}
bool cmp(int x, int y){
	return x>y;
}
int main(){
	vector<pair<ll,ll>>().swap(vc1);
	vector<ll>().swap(vc2);
	vc1.push_back({-1e18, -1});
	vc1.push_back({1e18, 1e9+1});
	vc2.push_back(0);
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i=1; i<=n; ++i){
		scanf("%d%d", &a[i], &b[i]);
		vc1.push_back({b[i], a[i]});
	}
	sort(vc1.begin(), vc1.end());
	for(int i=0; i<n-1; ++i){
		vc2.push_back(get(vc1[i], vc1[i+1]));
	}
	sort(vc2.begin(), vc2.end(), cmp);
	for(int i=1; i<=m; ++i){
		vector<ll>().swap(vc3);
		vector<ll>().swap(vc4);
		int x, y;
		scanf("%d%d", &x, &y);
		erase(b[x], a[x]);
		insert(y, a[x], b[x], a[x]);
		sort(vc3.begin(), vc3.end(), cmp);
		sort(vc4.begin(), vc4.end(), cmp);
		ll ans=vc4[0]; int p=0;
		while(p<(int)vc3.size()&&vc2[p]==vc3[p]) p++;
		ans=max(ans, vc2[p]);
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：thousands_of_years (赞：10)

# 题目传送门： P11021 [「LAOI-6」区间测速](https://www.luogu.com.cn/problem/P11021)
## 前言： 
第一次在洛谷比赛中切绿题，有些激动，回学校又写不了，于是星期天上午加急写了这一篇题解。
## 思路：
1. 我们先把监控信息按时间从小到大排序，因为询问操作需要监控信息的原来的顺序，于是用数组记录下原来位置的监控信息被移到哪里。

```cpp
for(int i=1;i<=n;i++)
	{
		cin>>e[i].x>>e[i].t;
		e[i].id=i;
	}
	sort(e+1,e+1+n,cmp);
	for(int i=1;i<=n;i++)
	po[e[i].id]=i;
```


---


2. 因为改变一个监控信息，最大速度可能会变大，也有可能变小，先想变小的情况，我们再记录下每相邻两个监控信息所显示出的速度，再从大到小排序，目的是求出排名前三个最大速度，至于为什么是前三个，因为一个监控信息的改变而只会影响两个速度。与上一步骤一样，将每两个影响速度的监控信息记录下来。
```cpp
for(int i=2;i<=n;i++)
	{
		ee[i].kl=(int)(floor(abs(e[i].x-e[i-1].x)/(double)(e[i].t-e[i-1].t)));
		ee[i].id=i;
	}
	sort(ee+2,ee+1+n,cmp1);
	for(int i=2;i<=4;i++)
	mo1[ee[i].id]=i,mo2[ee[i].id-1]=i;
```


---


3. 接下来也很简单，所以我先在代码中给你说明 ~~才不是因为太麻烦了~~

```cpp
for(int i=1;i<=m;i++)
	{
		int u,v,ans;
		cin>>u>>v;
		int now=po[u];//排序后u点位置 
		int yu=find(v);//二分查找，寻找到第一个大于v时间的监控信息 
		if(mo1[now]==2||mo2[now]==2)// 如果now点对最大速度有影响 
		{
			if(mo1[now]==3 ||mo1[now]==3)// 如果now点对第二大速度还有影响 
			{
				ans=ee[4].kl;//选第三大速度 
			}
			else
			ans=ee[3].kl;//选第二大速度 
		}
		else
		ans=ee[2].kl;//选第一大速度 
		if(now!=yu)//当不在原位时 
		{
			if(yu>1)//当左边监控信息存在时 
			ans=max(ans,(int)(floor(abs(e[now].x-e[yu-1].x)/(double)(v-e[yu-1].t))));
			if(yu<=n)//当右边监控信息存在时 
			ans=max(ans,(int)(floor(abs(e[yu].x-e[now].x)/(double)(e[yu].t-v))));
			ans=max(ans,(int)(floor(abs(e[now+1].x-e[now-1].x)/(double)(e[now+1].t-e[now-1].t))));
		}
		else//当在原位时 
		{
			ans=max(ans,(int)(floor(abs(e[yu].x-e[yu-1].x)/(double)(v-e[yu-1].t))));
			ans=max(ans,(int)(floor(abs(e[yu+1].x-e[yu].x)/(double)(e[yu+1].t-v))));
		}
		cout<<ans<<endl;
	}
```
我们具体来讲一讲 $ans$ 下面的一坨取 $max$ 。
这个调整的监控信息出现在任何位置，影响答案的都只有这几个因素；

- 当修改后不在原位置时
1. 调整的监控信息与最大的小于 $v$ 时间的监控信息之间产生的新速度
2. 调整的监控信息与最小的大于 $v$ 时间的监控信息之间产生的新速度
3. 调整的监控信息离开原来位置后，原来的前一个监控信息与原来的后一个监控信息之间产生的新速度
- 当在原位置时
1. 调整的监控信息与前一个监控信息之间产生的新速度。
2. 调整的监控信息与后一个监控信息之间产生的新速度。

---
4. AC [提交记录](https://www.luogu.com.cn/record/176844782)
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int x,t,id;
}e[100006];
struct node{
	int id,kl;
}ee[100006];
int n,m,po[100006],mo1[100006],mo2[100006];
bool cmp(Node a,Node b)
{
	return a.t<b.t;
}
bool cmp1(node a,node b)
{
	return a.kl>b.kl;
}
int find(int x)//改后时间 
{
	int l=1,r=n+1;
	while(l<r-1)
	{
		int mid=l+r>>1;
		if(e[mid].t<x)
		l=mid;
		else
		r=mid;
	}
	return r;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>e[i].x>>e[i].t;
		e[i].id=i;
	}
	sort(e+1,e+1+n,cmp);
	for(int i=1;i<=n;i++)
	po[e[i].id]=i;
	for(int i=2;i<=n;i++)
	{
		ee[i].kl=(int)(floor(abs(e[i].x-e[i-1].x)/(double)(e[i].t-e[i-1].t)));
		ee[i].id=i;
	}
	sort(ee+2,ee+1+n,cmp1);
	for(int i=2;i<=4;i++)
	mo1[ee[i].id]=i,mo2[ee[i].id-1]=i;
	for(int i=1;i<=m;i++)
	{
		int u,v,ans;
		cin>>u>>v;
		int now=po[u];//排序后u点位置 
		int yu=find(v);//二分查找，寻找到第一个大于v时间的监控信息 
		if(mo1[now]==2||mo2[now]==2)// 如果now点对最大速度有影响 
		{
			if(mo1[now]==3 ||mo1[now]==3)// 如果now点对第二大速度还有影响 
			{
				ans=ee[4].kl;//选第三大速度 
			}
			else
			ans=ee[3].kl;//选第二大速度 
		}
		else
		ans=ee[2].kl;//选第一大速度 
		if(now!=yu)//当不在原位时 
		{
			if(yu>1)//当左边监控信息存在时 
			ans=max(ans,(int)(floor(abs(e[now].x-e[yu-1].x)/(double)(v-e[yu-1].t))));
			if(yu<=n)//当右边监控信息存在时 
			ans=max(ans,(int)(floor(abs(e[yu].x-e[now].x)/(double)(e[yu].t-v))));
			ans=max(ans,(int)(floor(abs(e[now+1].x-e[now-1].x)/(double)(e[now+1].t-e[now-1].t))));
		}
		else//当在原位时 
		{
			ans=max(ans,(int)(floor(abs(e[yu].x-e[yu-1].x)/(double)(v-e[yu-1].t))));
			ans=max(ans,(int)(floor(abs(e[yu+1].x-e[yu].x)/(double)(e[yu+1].t-v))));
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
## 后记：
感谢 @Contingency_Core 和 @
lsc72 的$hack$。~~第一次写成功题解就被hack~~

---

## 作者：ZMQ_Ink6556 (赞：9)

## 题解：P11021 「LAOI-6」区间测速

正解似乎是线段树，但我是一点也不会 ~~（线段树板子都是拿树状数组水的）~~，所以来分享一种不用线段树的方法。

### 前置知识

- [结构体](https://oi-wiki.org/lang/struct)
- [排序](https://oi-wiki.org/basic/sort-intro)
- [关联式容器（map）](https://oi-wiki.org/lang/csl/associative-container)
- [容器适配器（优先队列）](https://oi-wiki.org/lang/csl/container-adapter)
- [二分](https://oi-wiki.org/basic/binary)

### 解题思路

首先看暴力的打法：对于每次修改，按照时间排序，验证，复杂度：$O(n m \log n)$。

发现每次修改时仅会更改一小部分数值，也就是**暴力算法进行了大量重复计算**。考虑优化。

首先，很明确的一点，**每次更改最多影响前 $5$ 大的数据**。如图：

![pic](https://cdn.luogu.com.cn/upload/image_hosting/lo9gv4en.png)

会影响原位置的 $3$ 个数据和新位置的 $2$ 个数据：

若给上图的十个方块编号 $1$ 到 $10$ ~~相信读者数得出来~~，则删除 $(2,3)$ 和 $(3,4)$ 对答案的贡献，添加 $(2,4)$、$(7,3)$ 和 $(3,8)$ 的贡献。

此时我们就可以只在这几个值里面枚举答案。

### 实现细节

为降低复杂度，我们需要大量 $O(\log n)$ 的算法，下面会简单介绍在这道题的具体使用方法。

- 首先，对初始数据用 $t_i$ 从小至大排序，复杂度 $O(n \log n)$，代码：`sort(a + 1 , a + n + 1 , cmp);`。
- 其次，使用 map 记录排序后 $a_i$ 对应的原位置，复杂度 $O(n \log n)$，代码：`map<int , int> mp;`、`mp[a[i].num] = i;`。
- 然后，使用优先队列取出答案前 $5$ 大值（我为了保证正确性取了前 $10$ 大），复杂度 $O(\text{取的数的个数} \times \log n)$。
- 进入每次询问：
  + 找到原位置对应的现在的位置，用 map 直接取出，复杂度 $O(\log n)$，代码：`place = mp[u];`。
  + 优先队列边界处理删除，复杂度 $O(\log n)$。
  + 二分查找 $a_i$ 移动到的新时间位置，复杂度 $O(\log n)$。
  + 优先队列边界处理加入，复杂度 $O(\log n)$。
  + 此时，堆顶即为此次询问的答案，查询，复杂度 $O(\log n)$。
  + 别忘了恢复优先队列，复杂度 $O(\text{取的数的个数} \times \log n)$。

最终复杂度：$O((n + m \times \text{取的数的个数}) \log n)$。

如果不理解可以参照代码，~~但是没有注释~~。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct p
{
	int x , t , num;
}a[100005];
struct p_ 
{
	int l , r , val;
	inline bool operator <(const p_ &other) const
	{
		return val < other.val;
	}
	inline bool operator >(const p_ &other) const
	{
		return val > other.val;
	}
}aq[15];
bool cmp(p l , p r)
{
	return l.t < r.t;
}
int n , m , u , v , ans , place , tp;
priority_queue<p_> q , qtmp;
map<int , int> mp;
int floating(int q)
{
	if(q == 0)
	{
		return 1000000007;
	}
	return q;
}
int calc(int p , int q)
{
	return abs(a[p].x - a[q].x) / floating(a[p].t - a[q].t);
}
int find(int q)
{
	int l = 1 , r = n , mid , ans = 0;
	while(l <= r)
	{
		mid = (l + r) / 2;
		if(a[mid].t < q)
		{
			ans = mid;
			l = mid + 1;
		}
		else
		{
			r = mid - 1;
		}
	}
	return ans;
}
int main()
{
	ios::sync_with_stdio(0);
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i++)
	{
		cin >> a[i].x >> a[i].t;
		a[i].num = i;
	}
	sort(a + 1 , a + n + 1 , cmp);
	for(int i = 1 ; i <= n ; i++)
	{
		mp[a[i].num] = i;
	}
	for(int i = 2 ; i <= n ; i++)
	{
		q.push(p_{i - 1 , i , calc(i , i - 1)});
	}
	for(int i = 1 ; i <= min(n - 1 , 10) ; i++)
	{
		aq[i] = q.top();
		q.pop();
	}
	while(m--)
	{
		for(int i = 1 ; i <= min(n - 1 , 10) ; i++)
		{
			qtmp.push(aq[i]);
		}
		cin >> u >> v;
		place = mp[u];
		int l , r , val;
		l = qtmp.top().l;
		r = qtmp.top().r;
		val = qtmp.top().val;
		while(l == place || r == place)
		{
			qtmp.pop();
			l = qtmp.top().l;
			r = qtmp.top().r;
			val = qtmp.top().val;
		}
		if(place > 1 && place < n)
		{
			qtmp.push(p_{place - 1 , place + 1 , calc(place + 1 , place - 1)});
		}
		tp = find(v);
		if(tp == 0)
		{
			qtmp.push(p_{place , tp + 1 , abs(a[tp + 1].x - a[place].x) / floating(a[tp + 1].t - v)});
		}
		else if(tp == n)
		{
			qtmp.push(p_{tp , place , abs(a[place].x - a[tp].x) / floating(v - a[tp].t)});
		}
		else
		{
			qtmp.push(p_{place , tp + 1 , abs(a[tp + 1].x - a[place].x) / floating(a[tp + 1].t - v)});
			qtmp.push(p_{tp , place , abs(a[place].x - a[tp].x) / floating(v - a[tp].t)});
		}
		cout << qtmp.top().val << '\n';
		while(!qtmp.empty())
		{
			qtmp.pop();
		}
	}
	return 0;
}
```

**[赛时记录](https://www.luogu.com.cn/record/176166137)**

### 坑点提醒

- 如果目标位置在边界，不要把两边算上，会 RE。
- 除法要注意向下取整时不出现除零错误，参照代码 `floating()` 函数。
- 初始状态下，可能的答案总共有 $n - 1$ 个而不是 $n$ 个。

**STL 大法好！！！**

考场手搓的非正解做法，希望大家支持（毕竟这是我写过的最长的一篇题解了），代码这么史，应该没人会抄的。

---

## 作者：ICU152_lowa_IS8 (赞：5)

这场比赛之前，我曾经祈祷最后两题不要出构造。

不知道是不是有更简便的解法，但在我看完题面并想好做法之后，突然就开始想念构造了，起码只用动脑子。

有点大的分讨。

首先得出一个结论：

假设 $t_a<t_b<t_c$，那么无论 $x_a,x_b,x_c$ 的值为多少，$a$ 到 $b$ 或者 $b$ 到 $c$ 的平均速度一定大于等于从 $a$ 到 $c$ 的平均速度。

假设 $v$ 为通过一段的速度，证明如下：

- 如果 $v_{ab}=v_{bc}$，那么最后的答案一定小于等于（小于还是等于和移动方向有关，可以自己画几个图）$v_{ac}$；

- 如果 $v_{ab}\not=v_{bc}$，显然答案一定小于 $\max(v_{ab},v_{bc})$。

用一张图来表示（假设每个监控的信息被抽象为一个点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/u5lw44po.png)

然后我们可以开始考虑如何执行题目的操作了。

有一个简单并且显而易见的思路：当一个点被修改，先得出该点拿掉之后该序列的最大值，然后再看这个点按照时间顺序插入之后的**最靠近该点左右的两个点**（这里用到了上面那个结论，想一想为什么）所提供的答案，将这三个结果取最大值。

还是用一张图表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/s8zb7pkw.png)

这种做法可以解决一大部分情况，但万一修改到的红色点在两个蓝色段上呢？

简单，只要再维护一个第二大不就行了吗？

然后还是看图吧，更清楚：

![](https://cdn.luogu.com.cn/upload/image_hosting/j0pb1fi4.png)

这个方法可以解决很多问题，但还有一种特殊情况：如果修改到的红色点同时在两个段上呢？

简单，只要再维护一个第三大不就行了吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/0vc1j13u.png)

由于一个点一定不能同时覆盖到三个区间，因此我们不用再说“简单，只要再维护一个第四大不就行了吗？”

值得注意的是，我们统计的第一、第二、第三大只是长度为一的区间的大小顺序，所以我们才需要引入紫色段（这个长度为二的区间仍然可能大于第二大、第三大）。

思路大概到这里，至于代码……长度有点吓人，码量作为基础赛第三题感觉有点过于凶残了。

具体的实现方法还有一些实现上的细节本题解并未提及，可以参考于代码。

因为是比赛写的，所以代码没有经过任何优化也不简洁，并不值得借鉴。

代码没有注释，还请见谅。


```
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int xi,ti,id;
}a[1000005];
bool cmp(node a,node b){
	return a.ti<b.ti;
}
int f[1000005];
signed main(){
	int n,m;
	int maxn1=0,maxn2=0,maxi1=0,maxi2=0,maxn3=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].xi>>a[i].ti;
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=2;i<=n;i++){
//		cout<<a[i].xi-a[i-1].xi<<" "<<a[i].ti<<" "<<a[i-1].ti<<endl;
		if(maxn1<abs(a[i].xi-a[i-1].xi)/(a[i].ti-a[i-1].ti)){
			maxn3=maxn2;
			maxn2=maxn1;
			maxi2=maxi1;
			maxn1=abs(a[i].xi-a[i-1].xi)/(a[i].ti-a[i-1].ti);
			maxi1=i-1;
		}
		else if(maxn2<abs(a[i].xi-a[i-1].xi)/(a[i].ti-a[i-1].ti)){
			maxn3=maxn2;
			maxn2=abs(a[i].xi-a[i-1].xi)/(a[i].ti-a[i-1].ti);
			maxi2=i-1;
		}
		else if(maxn3<abs(a[i].xi-a[i-1].xi)/(a[i].ti-a[i-1].ti)){
			maxn3=abs(a[i].xi-a[i-1].xi)/(a[i].ti-a[i-1].ti);
		}
		f[a[i].id]=i;
	}
//	cout<<"___________________________________________\n";
//	cout<<maxn1<<" "<<maxn2<<" "<<maxn3<<"ASD\n";
	while(m--){
		int u,v;
		cin>>u>>v;
		u=f[u];
		int nt=-1;
		if(u==maxi1){
//			cout<<"MAXI____\n";
			if(u==maxi2+1){
				nt=max(abs(a[maxi1+1].xi-a[maxi1-1].xi)/(a[maxi1+1].ti-a[maxi1-1].ti),maxn3);
			}
			else{
				nt=max(abs(a[maxi1+1].xi-a[maxi1-1].xi)/(a[maxi1+1].ti-a[maxi1-1].ti),maxn2);
			}
		}
		else if(u==maxi1+1){
//			cout<<"MAXI++++\n";
			if(u==maxi2){
//				cout<<"@\n";
				nt=max(abs(a[maxi1+2].xi-a[maxi1].xi)/(a[maxi1+2].ti-a[maxi1].ti),maxn3);
			}
			else{
				nt=max(abs(a[maxi1+2].xi-a[maxi1].xi)/(a[maxi1+2].ti-a[maxi1].ti),maxn2);
			}
		}
		else{
			nt=maxn1;
		}
//		cout<<nt<<endl;
		int l=1,r=n,mid,tmp=0;
		while(l<=r){
			mid=l+r>>1;
			if(a[mid].ti<=v){
				tmp=mid;
				l=mid+1;
			}
			else{
				r=mid-1;
			}
		}
		int now=0;
//		cout<<u<<"________________"<<tmp<<endl;
		if(tmp==0){
			if(u==1){
				now=max(now,abs(a[2].xi-a[u].xi)/(a[2].ti-v));
			}
			else{
				now=max(now,abs(a[1].xi-a[u].xi)/(a[1].ti-v));
			}
		}
		else{
			if(u==tmp&&tmp!=1){
				now=max(now,abs(a[u].xi-a[tmp-1].xi)/(v-a[tmp-1].ti));
			}
			else{
//				cout<<"ASDJKLAS\n";
//				cout<<a[u].xi<<" "<<a[tmp].xi<<" "<<a[u].ti<<" "<<a[tmp].ti<<endl;
				now=max(now,abs(a[u].xi-a[tmp].xi)/(v-a[tmp].ti));
			}
			if(u==tmp+1&&tmp!=n){
				now=max(now,abs(a[tmp+2].xi-a[u].xi)/(a[tmp+2].ti-v));
			}
			else{
				now=max(now,abs(a[tmp+1].xi-a[u].xi)/(a[tmp+1].ti-v));
			}
		}
		cout<<max(nt,now)<<"\n";
	}
	return 0;
}

```

---

## 作者：MoonCake2011 (赞：3)

首先看张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/anwl8j79.png?x-oss-process=image/resize,m_lfit,h_500,w_700)

发现只有 $t$ 相邻的点对才会为最优答案。

直接尝试用 `set` 维护，发现因为是按 $t$ 排序，先计算出最开始的答案并放入一个堆中，和一个桶中。

因为有删除加入操作，堆是最合适的，因为要删除任意数，所以用桶配合堆延迟删除。

改完后改回来就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
pair<int,int>a[100010];
set<pair<int,int> >s,t;
set<pair<int,int> >::iterator IT[100010];
priority_queue<long long>q;
unordered_map<long long,int>mp;
signed main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		pair<int,int>a;
		cin>>a.second>>a.first;
		IT[i]=s.insert(a).first;//记录点对应的迭代器
	}
	for(set<pair<int,int> >::iterator it=s.begin();next(it)!=s.end();it++){
		set<pair<int,int> >::iterator it2=next(it);
		mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]++;//相邻贡献入堆入桶
		q.push((long long)(fabs(it2->second-it->second)/abs(it2->first-it->first)));
	}
	while(m--){
		int x,y;
		cin>>x>>y;//修改
		set<pair<int,int> >::iterator it=IT[x];//找到迭代器
		int YX=it->second,YT=it->first;//记录原来的值，方便改回去
		if(it!=s.begin()){//删除与前面的贡献
			set<pair<int,int> >::iterator it2=prev(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]--;
		}
		if(next(it)!=s.end()){//删除与后面的贡献
			set<pair<int,int> >::iterator it2=next(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]--;
		}
		if(it!=s.begin() && next(it)!=s.end()){//加入两边的贡献  
			set<pair<int,int> >::iterator it2=prev(it);
			set<pair<int,int> >::iterator it3=next(it);
			mp[(long long)(fabs(it3->second-it2->second)/abs(it3->first-it2->first))]++;
			q.push((long long)(fabs(it3->second-it2->second)/abs(it3->first-it2->first)));
		}
		s.erase(it);//删掉原迭代器
		IT[x]=it=s.insert({y,YX}).first;//记录新迭代器
		if(it!=s.begin()){//加入与前面的贡献
			set<pair<int,int> >::iterator it2=prev(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]++;
			q.push((long long)(fabs(it2->second-it->second)/abs(it2->first-it->first)));
		}
		if(next(it)!=s.end()){//加入与后面的贡献
			set<pair<int,int> >::iterator it2=next(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]++;
			q.push((long long)(fabs(it2->second-it->second)/abs(it2->first-it->first)));
		}
		if(it!=s.begin() && next(it)!=s.end()){//删除两边的贡献  
			set<pair<int,int> >::iterator it2=prev(it);
			set<pair<int,int> >::iterator it3=next(it);
			mp[(long long)(fabs(it3->second-it2->second)/abs(it3->first-it2->first))]--;
		}
		while(!mp[q.top()]) q.pop();//延迟删除，可以证明这里均摊 O(n log n)
		cout<<q.top()<<"\n";//输出
		
		
		y=YT;//给改回去
		it=IT[x];//下面的操作就完全一样了
		YX=it->second,YT=it->first;
		if(it!=s.begin()){
			set<pair<int,int> >::iterator it2=prev(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]--;
		}
		if(next(it)!=s.end()){
			set<pair<int,int> >::iterator it2=next(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]--;
		}
		if(it!=s.begin() && next(it)!=s.end()){//加入两边的贡献  
			set<pair<int,int> >::iterator it2=prev(it);
			set<pair<int,int> >::iterator it3=next(it);
			mp[(long long)(fabs(it3->second-it2->second)/abs(it3->first-it2->first))]++;
			q.push((long long)(fabs(it3->second-it2->second)/abs(it3->first-it2->first)));
		}
		s.erase(it);
		IT[x]=it=s.insert({y,YX}).first;
		if(it!=s.begin()){
			set<pair<int,int> >::iterator it2=prev(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]++;
			q.push((long long)(fabs(it2->second-it->second)/abs(it2->first-it->first)));
		}
		if(next(it)!=s.end()){
			set<pair<int,int> >::iterator it2=next(it);
			mp[(long long)(fabs(it2->second-it->second)/abs(it2->first-it->first))]++;
			q.push((long long)(fabs(it2->second-it->second)/abs(it2->first-it->first)));
		}
		if(it!=s.begin() && next(it)!=s.end()){//删除两边的贡献  
			set<pair<int,int> >::iterator it2=prev(it);
			set<pair<int,int> >::iterator it3=next(it);
			mp[(long long)(fabs(it3->second-it2->second)/abs(it3->first-it2->first))]--;
		}
	}
	return 0;
}
```
用 `set` 维护可以支持前一次修改会影响后一次修改。

~~你看此题这个直接将我的代码增长了很多行~~。

时间复杂度 $O(n\log n)$，具有大常数，能过。

---

## 作者：xixisuper (赞：3)

# P11021 「LAOI-6」区间测速

没做出来的肯定是被那个抽象的题面唬住了，其实这个题没有那么难。

upd on 2024.9.14：通过了讨论区的 hack。

## 思路

重新说一遍题意：

- 给定 $n$ 个监控信息，第 $i$ 个信息包含两个数 $t_i$ 和 $x_i$，表示在 $t_i$ 秒时汽车在 $x_i$ 处。
- 有 $m$ 次询问，第 $i$ 询问包含两个数 $u_i$ 和 $v_i$，表示把原 $t_{u_i}$ 修改为 $v_i$，每次询问后输出当前情况下，汽车**最快时速的最小值**是多少（下取整），输出后立即撤销本次修改。

很多人都没读懂这个**最快时速的最小值**是什么东西，我们感性理解一下。假设我们知道 $t_i$ 时刻小车在 $x_i$，而 $t_j$ 时刻小车到 $x_j$ 了，根据中学物理知识，已知位移和时间，能够求出平均速度 $\overline{v}$，如果此时汽车严格按照平均速度行驶，则此时得最快时速就是平均速度本身。显然，如果最快时速低于平均速度，那么小车不可能在 $|t_j-t_i|$ 的时间内走完 $|x_j-x_i|$ 的距离，所以说，**最快速度的最小值就是小车走某一段的平均速度**。

下面给出一个相邻时间的定义，假设 $t_i$ 与 $t_j$ 是相邻时间，且 $t_j>t_i$，那么不存在一个 $k$，使得 $t_i<t_k<t_j$。

我们显然能够证明，在一段时间内走的路程越短，平均速度越小，我们不希望小车走更远的距离，所以说，对于一对相邻时间 $t_i$ 与 $t_j$，其对答案的贡献就是：

$$
\left\lfloor\frac{|x_j-x_i|}{|t_j-t_i|}\right\rfloor
$$

假设题目不带修，我们只需要对原来的 $n$ 个监控信息以时间大小为关键字进行排序，然后求出：

$$
\max_{i=1}^{n-1}\left\lfloor\frac{|x_{i+1}-x_i|}{|t_{i+1}-t_i|}\right\rfloor
$$

那么现在考虑带修的怎么做，首先我们删除操作很简单，我们无需真的删除，只需预处理出前缀最大值和后缀最大值，删除哪个就以哪个为界，求其前面的前缀最大和后面的后缀最大即可。然后，删完某个时间后，有可能使原来两端合并到一起，所以找到原来的位置后还要判断两端连接后的值。对于更新的时间也很简单，由于我们对时间这一维排序了，所以我们只需要二分一下更新的 $v_i$ 在哪一个位置，然后求其跟其附近的两个数对答案的贡献即可，如果不放心的话可以多求几个，用以求稳。

综上，这个题我们就做完了，时间主要花在排序和二分上，总时间复杂度为 $O((n+m)\log n)$，足以通过此题。

## 代码

考场上的代码，有点难看，见谅。

```cpp
#include <iostream>
#include <algorithm>
#include <map> 
#include <vector>
#define ll long long
using namespace std;
const ll N=1e5+10;
inline ll read(){
	register ll x=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
inline ll jue(ll x){return (x<0)?(-x):x;}
ll n,m,qz[N],hz[N],t[N];
struct node{
	ll x,t;
	friend bool operator<(const node a,const node b){return a.t<b.t;}
}trex[N];
int main(){
	n=read(),m=read();
	for(ll i=1;i<=n;i++){
		trex[i].x=read(),trex[i].t=read();
		t[i]=trex[i].t;
	}
	sort(trex+1,trex+1+n);
	for(ll i=2;i<=n;i++) qz[i]=max(qz[i-1],(ll)(jue(trex[i].x-trex[i-1].x)/jue(trex[i].t-trex[i-1].t)));
	for(ll i=n-1;i>=1;i--) hz[i]=max(hz[i+1],(ll)(jue(trex[i].x-trex[i+1].x)/jue(trex[i].t-trex[i+1].t)));
	while(m--){
		ll u,v;
		u=read(),v=read();
		node lin;
		lin.t=t[u];
		ll pos=lower_bound(trex+1,trex+1+n,lin)-trex,ans=0;
		if(pos>1) ans=max(ans,qz[pos-1]);
		if(pos<n) ans=max(ans,hz[pos+1]);
		if(pos>1&&pos<n) ans=max(ans,(ll)(jue(trex[pos-1].x-trex[pos+1].x)/jue(trex[pos-1].t-trex[pos+1].t))); 
		lin.t=v;
		ll npos=lower_bound(trex+1,trex+1+n,lin)-trex;
		if(npos+1!=pos&&npos+1>0&&npos-1<=n) ans=max(ans,(ll)(jue(trex[pos].x-trex[npos+1].x)/jue(trex[npos+1].t-v)));
		if(npos-1!=pos&&npos-1>0&&npos-1<=n) ans=max(ans,(ll)(jue(trex[pos].x-trex[npos-1].x)/jue(trex[npos-1].t-v)));
		if(npos!=pos&&npos>0&&npos<n) ans=max(ans,(ll)(jue(trex[pos].x-trex[npos].x)/jue(trex[npos].t-v)));
		printf("%lld\n",ans);
	}
	return 0;
}
```

感谢 @lsc72 和 @Contingency_Core 的 hack。

---

## 作者：2c_s (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11021)

## 思路

二分、排序。由于本题思维难度较大，所以我们考虑一步一步逼近正确答案。

### 0 分做法

直接暴力。时间复杂度 $\mathcal{O}(n^2m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,x[N],t[N],u,v;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>x[i]>>t[i];
	while(m--){
		cin>>u>>v;
		int ans=-2e9;
		swap(t[u],v);
		for(int i=1;i<=n;++i){
			for(int j=i+1;j<=n;++j){
				ans=max(ans,abs(x[i]-x[j])/abs(t[i]-t[j]));
			}
		}
		cout<<ans<<"\n";
		swap(t[u],v);
	}
	return 0;
}
```

### 30 分做法

`set` 优化后，每次重新计算更改后对结果有影响的值即可。时间复杂度 $\mathcal{O}(n^2\log n+nm\log n)$，卡卡常能过这部分测试点。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
struct node{
	int x,t;
}a[N];
multiset<int>st;
vector<int>ve;
#define abs(x) ((x)>0?(x):-(x))//手写更快。
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>a[i].x>>a[i].t;
	for(int i=1;i<=n;++i){
		for(int j=i+1;j<=n;++j)st.insert(abs(a[i].x-a[j].x)/abs(a[i].t-a[j].t));
	}//预处理。
	while(m--){
		int u,v;
        cin>>u>>v;
		ve.clear();
		for(int i=1;i<=n;++i){//删除更改后对结果有影响的。
			if(i!=u){
				auto p=st.find(abs(a[u].x-a[i].x)/abs(a[u].t-a[i].t));
				ve.pb(*p);
				st.erase(p);
			}
		}
		for(int i=1;i<=n;++i){//加上更改后的新值。
			if(i!=u)st.insert(abs(a[u].x-a[i].x)/abs(v-a[i].t));
		}
		auto p=st.end();
		--p;
		printf("%d\n",*p);
		for(int i:ve)st.insert(i);//找回以前的老值。
		for(int i=1;i<=n;++i){
			if(i!=u)st.erase(st.find(abs(a[u].x-a[i].x)/abs(v-a[i].t)));
		}
	}
	return 0;
}
```

### 50 分做法

观察题意，很容易推导出来，若两段速度 $v_1,v_2$ 的平均速度是 $\overline{v}$，则区间最大值一定是这两**小段**的最大值。

所以我们按照 $t$ 从小到大排序，在查询的时候只查**更改后**的每个**小段**即可。时间复杂度降为 $\mathcal{O}(nm)$。

此时排序后顺序被打乱，所以我们要开个桶映射一下初始位置。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define abs(x) ((x)>0?(x):-(x))
const int N=1e5+10;
int n,m,id[N];
struct node{
	int x,t,id;
}a[N];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>a[i].x>>a[i].t=read(),a[i].id=i;
	sort(a+1,a+1+n,[](node a,node b){return a.t<b.t;});
	for(int i=1;i<=n;++i)id[a[i].id]=i;//映射数组。
	while(m--){
		int u,v,ans=-2e9,ori=a[u].t;
        cin>>u>>v;
        u=id[u];
		a[u].t=v;
		for(int i=2;i<=n;++i){
			if(i==u||i-1==u)continue;
			ans=max(ans,abs(a[i].x-a[i-1].x)/(a[i].t-a[i-1].t));
		}
		for(int i=1;i<=n;++i){
			if(i==u)continue;
			ans=max(ans,abs(a[i].x-a[u].x)/abs(a[i].t-a[u].t));
		}
		printf("%d\n",ans);
		a[u].t=ori;
	}
	return 0;
}
```

### 100 分做法

继续推导，发现对结果有影响的只是**被更改**的两小段和**更改后新增的**两小段。我们考虑预处理出来，用 ``set`` 维护值，用一个数组维护时间区间。时间复杂度降为 $\mathcal{O}(m\log n)$。

- $n=3$ 时有可能会导致被更改的两小段删除后**越界**，要加特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define abs(x) ((x)>0?(x):-(x))
const int N=1e5+10;
int n,m,id[N],b[N];
struct node{
	int x,t,id;
}a[N];
multiset<int>st;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>a[i].x>>a[i].t,a[i].id=i;
	sort(a+1,a+1+n,[](node a,node b){return a.t<b.t;});
	for(int i=1;i<=n;++i)id[a[i].id]=i;
	for(int i=2;i<=n;++i)st.insert(abs(a[i].x-a[i-1].x)/(a[i].t-a[i-1].t));
	for(int i=1;i<=n;++i)b[i]=a[i].t;//再定义一个不被更改的时间数组，方便二分找位置。
	while(m--){
		int u,v,ans,ori=a[u].t;
        cin>>u>>v;
        u=id[u];
		if(v==ori){//没更改直接输出。
			auto p=st.end();
			printf("%d\n",*--p);
			continue;
		}
		if(u>1)st.erase(st.find(abs(a[u].x-a[u-1].x)/(a[u].t-a[u-1].t)));//头的位置不用算。
		if(u<n)st.erase(st.find(abs(a[u+1].x-a[u].x)/(a[u+1].t-a[u].t)));//尾的位置不用算。
		a[u].t=v;
		auto p=st.end();
		if(st.size()){//如果没删完才处理，防止越界。
			--p;
			ans=*p;//相当于上一个做法的第一个循环。
		}
		int pos=lb(b+1,b+1+n,v)-b;//找改后的时间应该在哪段，相当于上一个做法的第二个循环。
		if(pos>1)ans=max(ans,abs(a[u].x-a[pos-1].x)/(v-b[pos-1]));//找前一小段比较。
		if(pos<=n)ans=max(ans,abs(a[u].x-a[pos].x)/(b[pos]-v));//找后一小段比较。
		if(u>1&&u<n)ans=max(ans,abs(a[u+1].x-a[u-1].x)/(b[u+1]-b[u-1]));//再判原来两边两个是否相等（对应越界判断）。
		printf("%d\n",ans);
		a[u].t=ori;//复原。
		if(u>1)st.insert(abs(a[u].x-a[u-1].x)/(a[u].t-a[u-1].t));
		if(u<n)st.insert(abs(a[u+1].x-a[u].x)/(a[u+1].t-a[u].t));
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/176200404)

---

## 作者：yezicong1104 (赞：3)

### 思路
- 首先对 $t_i$ 从小到大排序，可以得出最大速度一定是两个相邻的时间内的速度，因为任何速度和相邻时间内最快的速度结合后平均速度都会降低；最小值意味着每两个相邻时间内都做匀速直线运动。
- 每次把 $t_{u_i}$ 改成 $v_i$ 后，就把和 $t_{u_i}$ 相邻的时间内的速度去掉了，变成了和 $v_i$ 相邻的时间内的速度。那和 $v_i$ 相邻的时间怎么求呢？由于排序后 $t$ 时严格上升的，所以考虑二分，用函数 $f(num)$ 记录再排好序的 $t$ 中最后一个小于等于 $num$ 的位置。这样和 $v_i$ 相邻的时间就能求出来了，之后再进行大小比较就能解决了。时间复杂度为 $O(m\log_n)$。
### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n, m, v[N], vn[N]; // v[i] 记录原排列的速度，vn[i] 是将 v[i] 从小到大的排序
struct node {
	int x, t;
}xt[N], xtn[N]; //xt 时原排列，xtn 按照时间排列
bool cmp(node a, node b) { //比较函数
	return a.t < b.t;
}
int f(int num) { //记录 xtn 中最后一个小于等于 num 的位置
	int l = 0, r = n;
	while (l < r) { //二分，时间复杂度 O(logn) 
		int mid = (l + r) / 2 + 1;
		if (xtn[mid].t <= num) l = mid;
		else r = mid - 1;
	}
	return l;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", &xt[i].x, &xt[i].t);
		xtn[i] = xt[i];
	}
	sort(xtn + 1, xtn + n + 1, cmp); //对 xtn 按照时间排序
	for (int i = 1; i < n; i++) v[i] = vn[i] = abs(xtn[i + 1].x - xtn[i].x) / (xtn[i + 1].t - xtn[i].t); //计算速度
	sort(vn + 1, vn + n); //对 vn 从小到大排序
	while (m--) {
		int u, t, l, r; //l 和 r 记录与改变后的时间的相邻的两个时间在排好序的时间中的位置
		scanf("%d%d", &u, &t);
		int pos = f(xt[u].t), k = n - 1;
		if (max(v[pos - 1], v[pos]) == vn[k]) k--; //若v[pos - 1] 和 v[pos] 中的较大者是 vn 中的最大值
		if (min(v[pos - 1], v[pos]) == vn[k]) k--; //这句代码和上一句代码的顺序不能调换
		if (xtn[pos - 1].t < t && xtn[pos + 1].t > t) l = pos - 1, r = pos + 1; //如果改变后的时间还和原来两个相邻的时间相邻，那 l 和 r 就是 xtn 中和原时间相邻的两个位置
		else l = f(t), r = l + 1; //否则 l 是 xtn 中最后一个小于等于改变后的时间的位置
		int v1 = (pos > 0 ? abs(xt[u].x - xtn[l].x) / (t - xtn[l].t) : 0); //v1 计算改变后的时间和前一个相邻时间内的速度，如果没有前一个时间，就默认是 0
		int v2 = (pos < n ? abs(xt[u].x - xtn[r].x) / (xtn[r].t - t) : 0);//v2 计算改变后的时间和后一个相邻时间内的速度，如果没有后一个时间，就默认是 0
		printf("%d\n", max(max(v1, v2), vn[k])); //答案是 v1，v2，vn[k] 中的最大值
	}
	return 0;
}
```

---

## 作者：Eternatis (赞：2)

考虑将所有点按时间排序，观察性质，发现每次临时修改只会影响 $O(1)$ 个点：当前点的前驱后继，以及当前点更改时间后的前驱后继。其中，第一部分的贡献要消去，而第二部分的贡献要加上，最后求 $\max$。

维护第二部分是容易的，将时间排序后在数组上二分即可找到对应的前驱后继，答案可以直接计算。

对于第一部分，考虑记 $w_i$ 表示**排序后**第 $i-1$ 个点到第 $i$ 个点之间的速度，把所有 $w$ 插入一个 multiset，对于一次询问 $(u,v)$，删除 $w_u$ 与 $w_{u+1}$，计算 $u-1$ 到 $u+1$ 的速度，并查询最大值即可。

---

## 作者：Lele_Programmer (赞：1)

# P11021 题解

一种比较新奇的线段树做法。

## 思路

按 $t$ 递增排序后，所有最大值会在相邻两个记录之间的速度之中产生，这个不难证明，就不证明了。

修改操作，把某个 $t$ 改掉，可以看作将原来对应的这个信息从原位置删除，然后找到他应该到达的新位置，插入，也就是始终保持 $t$ 单调递增。

将某个 $t$ 删除，发现只会影响它与它左右两个点之间的两个段，所以删除这两个段，然后创建一个新段，表示它删除后，它左右两个记录之间的速度。

插入同理，只会影响某一个段，只需删除这个段，然后分别创建两个段，分别表示它与插入后它和它左边和右边的记录的速度。

![](https://cdn.luogu.com.cn/upload/image_hosting/reyxy4am.png)

这样一来，需要改到的信息并不多，考虑用线段树维护，但是线段树貌似不支持插入删除，那怎么办呢？

发现题目求最大值，删除操作可以视为将某一段设为 $0$ 或负无穷都可以，插入操作可以看作添加一个新的段在第 $n$ 段的后面，作为额外参与最大值计算的段，因为求最大值和顺序没啥关系，在线段树里面放哪里都可以。

当然，插入删除遇到边界情况，比如最左侧、最右侧，都要进行特判。

由于插入操作不多，但的确需要插入一点点东西，保险一点建立线段树多开 $10$ 个位置来存。

查找第一个大于等于（虽然在本题不会出现等于）$t$ 的数的位置，可以用二分。

这里我还进行了另一个特判，如果删除和插入后，它的位置不变，也就是它左右两个信息还是原来的那两个，则直接更新左右两段的信息。

当然，操作与操作之间没有影响，有影响的话这样就做不了了，所以做完修改查询，还要恢复，开一个数组，存两个值，表示哪一个位置要还原会哪一个数字，在代码中，我将它存在 `vec` 变量里面，使用 `restore()` 进行恢复。

有一点要记得，为了插入操作我们刚刚开多了一点点空间，在使用完这些位置后，也要把它们还原为 $0$。

## 代码

代码有点长，可能有点难理解，不过上面讲得很详细了，结合理解一下。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for (int i=(a);i<=(b);c)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for (int i=(a);i>=(b);c)
#define _iter(i,a) for (auto i=a.begin();i!=a.end();++i)
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])
#define rint register int
#define LL long long

const int N=100055;

typedef pair<int,int> pii;

int n,m;
int bk[N];
int arr2[N];
vector<pii> vec;

struct node {
    int x,t,i;
    bool operator < (const node& a) const {
        return t<a.t;
    }
} arr[N];

struct SegmentTree {
    int l,r;
    int max;
} tr[N<<2];

void pushup(int u) {
    tr[u].max=max(tr[u<<1].max,tr[u<<1|1].max);
}

void build(int u,int l,int r) {
    tr[u]={l,r,arr2[l]};
    if (l==r) return;
    int mid=l+r>>1;
    build(u<<1,l,mid); build(u<<1|1,mid+1,r);
    pushup(u);
}

void modify(int u,int p,int k) {
    if (tr[u].l==p && tr[u].r==p) {
        tr[u].max=k;
        return;
    }
    int mid=tr[u].l+tr[u].r>>1;
    if (p<=mid) modify(u<<1,p,k);
    else modify(u<<1|1,p,k);
    pushup(u);
}

int query(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].max;
    int mid=tr[u].l+tr[u].r>>1;
    int ans=0;
    if (l<=mid) ans=max(ans,query(u<<1,l,r));
    if (r>mid) ans=max(ans,query(u<<1|1,l,r));
    return ans;
}

int get(node& l,node& r) {
    return abs((l.x-r.x)/(l.t-r.t));
}

void restore() {
    while (!vec.empty()) {
        int a=vec.back().first;
        int b=vec.back().second;
        modify(1,a,b);
        vec.pop_back();
    }
}

int main() {
    scanf("%d %d",&n,&m);
    _rep(i,1,n) {
        int x,t;
        scanf("%d %d",&x,&t);
        arr[i]={x,t,i};
    }
    sort(arr+1,arr+1+n);
    _rep(i,1,n) bk[arr[i].i]=i;
    _rep(i,1,n-1) arr2[i]=abs((arr[i].x-arr[i+1].x)/(arr[i].t-arr[i+1].t));
    build(1,1,n+10);
    while (m--) {
        int a,b;
        scanf("%d %d",&a,&b);
        int pos=bk[a];
        auto &cur=arr[pos];
        node nw={cur.x,b,0};
        if (pos!=1 && pos!=n && arr[pos-1].t<b && b<arr[pos+1].t) {
            vec.push_back({pos-1,query(1,pos-1,pos-1)});
            vec.push_back({pos,query(1,pos,pos)});
            modify(1,pos-1,get(arr[pos-1],nw));
            modify(1,pos,get(nw,arr[pos+1]));
            printf("%d\n",query(1,1,n+10));
            restore();
            continue;
        }
        if (pos==1) {
            vec.push_back({1,query(1,1,1)});
            modify(1,1,0);
        } else if (pos==n) {
            vec.push_back({n-1,query(1,n-1,n-1)});
            modify(1,n-1,0);
        } else {
            vec.push_back({pos-1,query(1,pos-1,pos-1)});
            vec.push_back({pos,query(1,pos,pos)});
            modify(1,pos-1,0);
            modify(1,pos,0);
            vec.push_back({n,0});
            modify(1,n,get(arr[pos-1],arr[pos+1]));
        }
        int npos=lower_bound(arr+1,arr+1+n,nw)-(arr+1)+1;
        if (npos==1) {
            vec.push_back({n+1,0});
            modify(1,n+1,get(nw,arr[npos]));
        } else if (npos==n+1) {
            vec.push_back({n+1,0});
            modify(1,n+1,get(nw,arr[npos-1]));
        } else {
            vec.push_back({npos-1,query(1,npos-1,npos-1)});
            modify(1,npos-1,0);
            vec.push_back({n+1,0});
            vec.push_back({n+2,0});
            modify(1,n+1,get(nw,arr[npos-1]));
            modify(1,n+2,get(nw,arr[npos]));
        }
        printf("%d\n",query(1,1,n+10));
        restore();
    }
    return 0;
}

/*

hack:

in:
5 1
15 16
14 13
19 3
18 2
9 11
4 12

ans:
9

wa:
2

*/
```

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

下文所说的“速度”均指速率。

有一个很重要而且比较好证明的结论：当我们将这些点描到一个 $x-t$ 图像当中时，会发现速度的最大值一定会出现在时间相邻的两个点间。

证明？很简单，我们假设有三个点 $A(t_1,x_1),B(t_2,x_2),C(t_3,x_3),(t_1<t_2<t_3)$。

这时候，如果我们连接 $AC$，我们发现其一定会过点 $B^\prime(t_2,\frac{(t_3-t_2)x_1+(t_2-t_1)x_2}{t_3-t_1})$。我们令 $x_0=\frac{(t_3-t_2)x_1+(t_2-t_1)x_2}{t_3-t_1}$，这时候分情况讨论。

1. 如果 $x_2=x_0$，那么说明 $B$ 在 $AC$ 上，也就是说 $AC$ 所表示的速度与 $AB$ 或 $BC$ 表示的一样。
2. 如果 $x_2<x_0$，则 $B$ 在 $B^\prime$ 下面，这时候在 $t_2$ 两侧一定至少有一部分的从 $B$ 开始的位移大于从 $B^\prime$ 开始的位移。具体的可以选择分讨 $x_1$ 和 $x_0$ 的位置关系。又因为位移所用的时间一样，所以一定有一部分是 $B$ 开始的更大。
3. 如果 $x_2>x_0$，本质上与第二种情况相同，方法也一样，不做赘述。

其实上述内容也可以用函数的凹凸性来解释，只是本质相同。

因此，我们只需要考虑相邻的两点的贡献就行了。暴力维护这个的话是 $O(nm)$ 的，期望 $50pts$。

考虑一下优化。我们发现每一次真正有变化的地方只有被更改的点的位置的贡献以及他被插入到的位置形成的贡献。

因此我们可以考虑预处理出没有某一个点的时候的全局最大值，然后与这个点在新插入的位置的贡献。由于我们前面证明的这个结论，因此我们不需要预处理去除一点一间隔的答案。反正他在新的位置的贡献只会更大。

思路就这样。细节有一点点多，看实现方式而异。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int l, r, p;
}a[100005];
int n, m, mx[100005], l, r, ps[100005], fmx[100005], bmx[100005], lp, rp, mid;
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		cin >> a[i].l >> a[i].r, a[i].p = i;
	sort(a + 1, a + n + 1, [](node l, node r) { return l.r < r.r; });
	for (int i = 1; i < n; ++i)
		mx[i] = abs(a[i + 1].l - a[i].l) / abs(a[i + 1].r - a[i].r), ps[a[i].p]=i;
	for (int i = 1; i <= n; ++i) fmx[i] = max(fmx[i - 1], mx[i]);
	for (int i = n; i >= 1; --i) bmx[i] = max(bmx[i + 1], mx[i]);
	mx[1] = bmx[2]; mx[n] = fmx[n - 2]; ps[a[n].p] = n;
	for (int i = 2; i < n; ++i) mx[i] = max(fmx[i - 2], bmx[i + 1]);
	for (int i = 2; i < n; ++i)
		mx[i] = max(mx[i], abs(a[i + 1].l - a[i - 1].l) / abs(a[i + 1].r - a[i - 1].r));
	for (int i = 1; i <= m; ++i) {
		cin >> l >> r; l = ps[l];
		int ans = mx[l]; lp = 0; rp = n;
		while (lp != rp)
			if (a[mid = lp + rp + 1 >> 1].r > r) rp = mid - 1;
			else lp = mid;
		ans = max(ans, abs(a[lp + 1].l - a[l].l) / abs(a[lp + 1].r - r));
		if (lp > 0 && a[lp].r - r != 0)ans = max(ans, abs(a[lp].l - a[l].l) / abs(a[lp].r - r));
		else if (lp > 0) ans = max(ans, abs(a[lp - 1].l - a[l].l) / abs(a[lp - 1].r - r));
		cout << ans << endl;
	}
}
```

---

## 作者：AK_heaven (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P11021)

我们会发现直接求解会有问题，但是并没有任何明显的结论，这个时候我们把 $t_i$ 作为 $x$，把 $x_i$ 作为 $y_i$，我们就会发现其实我们要求的是整个坐标系里面斜率最大的线段的斜率为多少，经过画图，我们会发现对于每个点，与其他点的连线中，斜率最大的线段必然是相邻的两个点与它的连线之一，有了这个结论以后，我们相当于每次操作就是移动一个点，我们只需要丢弃掉被移动的点原先与相邻点的两个连线的斜率答案，并加入新的位置与两个新的相邻点的连线的答案，最后求整个答案集合中的 $\max$ 即可。

具体实现我们只需要先对所有点按照 $t_i$ 从小到大重新排列并编号，然后对于所有的 $i \in [1, n-1]$，$i$ 向着 $i+1$ 的连线求一个前缀最大值，对于所有 $i \in [2, n]$，$i$ 向着 $i-1$ 的连线求一个后缀最大值。

查询的时候二分即可找到新的位置，并且计算新的相邻点的答案。

总时间复杂度 $O(n + n \log n + m \log n)$，可以轻松通过本题目。

**The code**


```cpp
#include <bits/stdc++.h>

#define L(i, a, b) for(int i = (a); i <= (b); i++)
#define R(i, a, b) for(int i = (a); i >= (b); i--)
#define ll long long
#define ls (p<<1)
#define rs (p<<1|1)

using namespace std;

const int N = 3e5 + 10;

struct Node {
	int x, t, id;
	bool operator < (const Node & T) const {
		return t < T.t;
	}
}a[N];

int n, m, mp[N], ans[N], s[N], p[N];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	L(i, 1, n) cin>> a[i].x >> a[i].t, a[i].id = i;
	sort(a+1, a+n+1);
	L(i, 2, n) {
		mp[a[i].id] = i;
		if(i > 1) s[i] = max(s[i-1], abs(a[i].x-a[i-1].x)/abs(a[i].t-a[i-1].t));
	}
	R(i, n, 1) {
		if(i < n) p[i] = max(p[i+1], abs(a[i].x-a[i+1].x)/abs(a[i].t-a[i+1].t));
	}
//	cout << '\n';
	L(i, 1, m) {
		int u, v; cin >> u >> v;
		u = mp[u];
		int ans = max(s[u-1], p[u+1]);
		int l = 1, r = n;
		while(l < r) {
			int mid = (l + r + 1) >> 1;
			if(a[mid].t > v) r = mid-1;
			else l = mid;
		}
        int L = l, R = l+1;
        if(L == u) L--;
        if(1 <= L && L <= n) ans = max(ans, abs(a[u].x-a[L].x)/abs(v-a[L].t));
        if(1 <= R && R <= n) ans = max(ans, abs(a[u].x-a[R].x)/abs(v-a[R].t));
		cout << ans << '\n';
	}
	return 0; 
}

```

---

## 作者：Night_sea_64 (赞：0)

赛时看着形式化题意怎么也想不到，赛后仔细看了看原来的题意，一下子懂了。。。我还是太菜了。

一想感觉真的是原来的题意更好理解一些。一大段内的平均速率怎么可能比每一小段的平均速率的最大值还大呢？如果把它看成坐标系上的点的话感觉真的不容易看出来。结论就是只有横坐标排序后相邻的点可能贡献答案。

首先可以很容易处理出把每个点删掉之后的答案。方法就是先求个全局答案，然后把答案对应的两个点分别删掉再求一遍。不是这两个点的话，删掉就没有影响。

然后修改的话就可以当作直接把那个点删了，然后临时新加入一个点，看他到相邻两个点的斜率。直接二分查找即可。

细节很多，见代码。时间复杂度 $O((n+m)\log n)$。

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,mx[100010],np[100010];
struct node{int id,x,y;}a[100010];
bool operator<(const node &x,const node &y){
    return x.x<y.x;
}
int slope(node x,node y){
    return abs(x.y-y.y)/abs(x.x-y.x);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].y>>a[i].x;
        a[i].id=i;
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)np[a[i].id]=i;
    int maxn=-1,id;
    for(int i=1;i<n;i++)
        if(slope(a[i],a[i+1])>maxn)
            maxn=slope(a[i],a[i+1]),id=i;
    for(int i=1;i<=n;i++)
        if(i!=id&&i!=id+1)mx[i]=maxn;
    maxn=-1;
    for(int i=1;i<n;i++)
        if(i!=id)
        {
            if(i==id-1)maxn=max(maxn,slope(a[i],a[i+2]));
            else maxn=max(maxn,slope(a[i],a[i+1]));
        }
    mx[id]=maxn;
    maxn=-1;
    for(int i=1;i<n;i++)
        if(i!=id+1)
        {
            if(i==id&&i<n-1)maxn=max(maxn,slope(a[i],a[i+2]));
            else maxn=max(maxn,slope(a[i],a[i+1]));
        }
    mx[id+1]=maxn;
    while(m--)
    {
        int p,x;
        cin>>p>>x;
        p=np[p];
        int ans=mx[p];
        int pos=upper_bound(a+1,a+n+1,(node){0,x,a[p].y})-a;
        if(pos==p)pos++;
        if(pos<=n)ans=max(ans,slope((node){0,x,a[p].y},a[pos]));
        pos=lower_bound(a+1,a+n+1,(node){0,x,a[p].y})-a-1;
        if(pos==p)pos--;
        if(pos>=1)ans=max(ans,slope((node){0,x,a[p].y},a[pos]));
        cout<<ans<<endl;
    }
    return 0;
}
```

---


# 吻秋

## 题目背景

[English statement](https://www.luogu.com.cn/problem/U500140). **You must submit your code at the Chinese version of the statement.**

秋雨刚刚亲吻过大地，白云便卷起赤橙黄绿青蓝紫。

波长在可见光范围内自由落体，让蒸腾的水汽都带上了递进的旋律。

渐变色模糊的印象总被晴天匆匆带过，但往往反常的极差让我们更加记忆犹新。

所以有序，真的最优吗？

## 题目描述

小 C 有 $m$ 个整数序列 $a_1\dots a_m$，每个序列的长度都为 $n$。

小 C 想要把自己的序列按照整数大小排序。于是小 C 有 $q$ 次操作，每次操作：

- 要么，小 C 给出 $x, y\ (x \neq y)$，他想把 $a_x, a_y$ 拼接在一起形成长度为 $2n$ 的序列 $b$，将 $b$ 升序排序后取 $b_1\dots b_n$ 作为新的 $a_x$，$b_{n+1}\dots b_{2n}$ 作为新的 $a_y$；
- 要么，小 C 给出 $i, j$，细心的小 C 想要询问你，经过前面的若干次操作后，$a_{i,j}$ 的值，你需要准确回答他的问题。

## 说明/提示

### 数据规模与约定

**本题采用捆绑测试和子任务依赖**。

因为最后两个 Subtask 的极限输入数据大小分别达到 18MB、50MB 以上，C++ 选手可以选择使用下面的 **快速输入输出模板**：

```cpp
namespace FastIO {
	char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
}; using namespace FastIO;
#undef getchar()
```

**不保证除了 C++ 以外的语言一定能够通过，但保证对于 C++ 语言有充足的时限。**

---

- Subtask 0（0 pts）：样例。
- Subtask 1（9 pts）：$n \leq 10^4$，$q \leq 3000$。依赖于子任务 $0$。
- Subtask 2（23 pts）：$q \leq 3000$。依赖于子任务 $0, 1$。
- Subtask 3（20 pts）：$m \leq 5$，$q \leq 4\times 10^5$。依赖于子任务 $0$。
- Subtask 4（28 pts）：$q \leq 4\times 10^5$。依赖于子任务 $0 \sim 3$。
- Subtask 5（20 pts）：无特殊限制。依赖于子任务 $0 \sim 4$。

对于所有数据，满足 $1 \leq n\cdot m \leq 2\times 10^6$，$1 \leq m \leq 20$，$1 \leq q \leq 5\times 10^6$，$1 \leq a_{i,j} \leq 10^7$；对于操作或询问，$1 \leq x \neq y \leq m$，$1 \leq i \leq m$，$1 \leq j \leq n$。

## 样例 #1

### 输入

```
5 3 6
1 3 2 5 6
2 7 8 2 2
3 5 3 4 8
2 1 5
1 1 2
2 2 4
1 1 3
1 2 1
2 2 3```

### 输出

```
6
7
2
```

## 样例 #2

### 输入

```
6 5 20
5 14 13 1 15 17
7 7 19 3 8 6
16 13 13 6 14 2
12 5 4 17 12 3
19 19 4 6 3 3
2 5 3
1 4 3
2 1 1
1 2 5
2 4 6
2 2 2
1 4 2
1 2 4
2 1 1
2 3 3
2 3 3
1 4 2
1 4 1
2 3 5
1 3 4
1 4 1
1 1 4
1 5 1
2 2 4
2 4 2
```

### 输出

```
4
5
12
3
5
13
13
16
6
14
```

# 题解

## 作者：zichen3004 (赞：17)

非常好诈骗题，使我的大脑旋转。

观察到 $m \le 20$，显然是降低时间复杂度的重要结论，如果你分析过 selection sort 的最大比较次数就会发现应该是在 $O(M^2)$ 量级的*，所以有效的归并次数不会多于 $400$ 次，归并这块的总复杂度 $O(NM^2)$ 完全可以接受。

考虑 quick sort 的次数，每个序列至多一次 quick sort，所以这块的时间复杂度应该是 $O(NM \log N)$，同样可以接受。

最后考虑怎么处理两个“绝对有序”的序列，即可以通过拼接获得有序序列的两个序列。这样的序列无需内部排序，设原本序列为 $S_1$，$S_2$。如果原本 $S_1+S_2$ 就有序的话，无需进行操作，否则 $S_2+S_1$ 有序，交换 $S_1$，$S_2$ 即可。

如果直接交换复杂度是 $O(NQ)$ 的，不能接受。开一个 $NowPos$ 记录当前行实际在第几行，如果要交换两行 $i$，$j$ 直接交换 $NowPos_i$，$NowPos_j$ 即可，复杂度降到 $O(Q)$。

最终复杂度为以上三部分复杂度最大值，要注意的是输入数据确实很大，注意快读快写。

最后献上赛时代码，代码不短但是很好写。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, q;
int ifFinishSort[25], NowPos[25];
vector<int> vec[21];

void read(int &x){
    x=0;int flg=1;char ch=getchar();
    for(;ch<'0'||ch>'9';) {if(ch=='-') flg=-1;ch=getchar();}
    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    x=x*flg;
}

void write(int x)
{
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}

void Merge(int X, int Y)
{
	int TrueX = NowPos[X], TrueY = NowPos[Y];
	vector<int> TmpArray;
	int i = 0, j = 0; 
	if(!ifFinishSort[X])
		sort(vec[TrueX].begin(), vec[TrueX].end()), ifFinishSort[X] = true;
	if(!ifFinishSort[Y])
		sort(vec[TrueY].begin(), vec[TrueY].end()), ifFinishSort[Y] = true;
	while(i < n && j < n)
		TmpArray.emplace_back(vec[TrueX][i] < vec[TrueY][j] ? vec[TrueX][i++] : vec[TrueY][j++]);
	while(i < n)
		TmpArray.emplace_back(vec[TrueX][i++]);
	while(j < n)
		TmpArray.emplace_back(vec[TrueY][j++]);
	for(int i = 0; i < n; i++)
		vec[TrueX][i] = TmpArray[i];
	for(int i = n; i < (n << 1); i++)
		vec[TrueY][i - n] = TmpArray[i];
}

void DealWithSortedArrayAndExchange(int X, int Y)
{
	int TrueX = NowPos[X], TrueY = NowPos[Y];
	if(vec[TrueX][n - 1] <= vec[TrueY][0])
		return;
	if(vec[TrueX][0] >= vec[TrueY][n - 1])
	{
		swap(NowPos[X], NowPos[Y]);
		return;
	}
	Merge(X, Y);
}

int tmp;

int main()
{
	read(n), read(m), read(q);
	for(int i = 1; i <= m; i++)
		ifFinishSort[i] = false, NowPos[i] = i;
	for(int i = 1; i <= m; i++)
		for(int j = 1; j <= n; j++)
			read(tmp), vec[i].emplace_back(tmp);
	while(q--)
	{
		int opt, u, v; read(opt), read(u), read(v);
		if(opt == 1)
		{
			if(!ifFinishSort[u] || !ifFinishSort[v])
				Merge(u, v);
			else
				DealWithSortedArrayAndExchange(u, v);
//			for(int i = 1; i <= m; i++)
//			{
//				for(int j = 0; j < n; j++)
//					cout << vec[NowPos[i]][j] << ' ';
//				cout << endl;
//			}
		}
		if(opt == 2)
		{
			write(vec[NowPos[u]][v - 1]), putchar('\n');
		}
	}
	return 0;
}
```

---



$^*$ 考虑为什么在 $M^2$ 的时间复杂度中可以完成排序，使得任意两行“绝对有序”：

对于任意两行可以交换他们的位置，因此我们不妨设最后 $S_1+S_2+…+S_m$ 有序，操作保证 $i < j$。

不同的整数对 $(i, j)$ 有 $\frac{(m-1)m}{2}$ 个，所以我们可以保证 $M^2$ 量级内每一个序列都被选中，即变得内部有序。

而我们发现，对于第一行，我们能在 $M - 1$ 次操作以内使其变成：


```
1 2 3 … n
```


因为执行完一次操作后，就会新增一组关于 $S_1$ 的绝对有序, $M - 1$ 组绝对有序，即全局绝对有序，保证了其最小的形态。

考虑其他操作是否会使关于 $S_1$ 绝对有序的数量减少。

假设原本 $S_1$ 和 $S_u$ 绝对有序，$S_1$ 和 $S_v$ 绝对有序，操作后 $S_1$ 和 $S_u$，$S_v$ 一定还都是绝对有序的。

假设原本 $S_1$ 和 $S_u$ 绝对有序，$S_1$ 和 $S_v$ 非绝对有序，操作后，$S_1$ 和 $S_v$ 绝对有序，因为 $S_u$ 里有 $n$ 个大于 $S_{1, n}$ 的数字，所以总共大于 $S_{1, n}$ 的数字数量不少于 $n$ 个，其中最大的 $n$ 个会全部有序地排在 $S_v$ 中。

其他行同理，注意我们只考虑当前行 $S_u$ 绝对小于 $S_v(u<v)$，与前面行的关系由前面行保证，因此操作次数 $T\le\frac{(m-1)m}{2}$。

---

## 作者：irris (赞：12)

我们猜想很多次操作都是，要么什么都不干，要么仅交换 $a_x, a_y$。

我们将证明不属于以上两种操作的操作次数不会超过 $\mathcal O(m^2)$。事实上，证明了这个也相当于解决了本题。

让我们在 $[1, m]$ 之间定义一种 **偏序关系**。称 $x$ 偏序 $y$ 当且仅当 $\min(a_x) \geq \max(a_y)$。

考虑一次操作，若 $y$ 偏序 $x$，那么我们什么都不干。若 $x$ 偏序 $y$ 相当于交换 $a_x, a_y$，这可以通过懒标记等方式做到 $\mathcal O(1)$ 复杂度（并且我们需要交换所有 $x, i$、$y, i$ 类的偏序关系）。

在进行一次没有确定偏序关系的操作 $(x, y)$ 时，我们先确定是否 $(x, y)$ 已经存在偏序关系（否则可能会出现一些错误的结果），如果是则仿照上例进行。现在我们暴力 $\mathcal O(n)$ 模拟归并排序，我们同样希望更新所有 $x, i$、$y, i$ 类的偏序关系。

首先由于 $(x, y)$ 操作前没有偏序关系，所以不存在 $y$ 偏序 $i$ 偏序 $x$ 等情况（或反之）。如果 $i$ 和 $x, y$ 在操作前都没有关系，我们也忽视它；如果 $i$ 被 $x, y$ 同时偏序或被偏序，那操作也不会带来影响。剩余 $4$ 种情况，我们会发现可能归结为 $i$ 偏序其中之一，最终 $i$ 一定偏序 $x$；或 $i$ 被其中之一偏序，最终 $i$ 一定被 $y$ 偏序。

这告诉我们，一次使得我们 $\mathcal O(n)$ 暴力归并操作一定会增加 $1$ 个偏序关系，而偏序关系最多有 $\mathcal O(m^2)$ 对，维护每个数列最大最小值，时间复杂度即为 $\mathcal O(nm^2 + q)$。

---

## 作者：Brilliant11001 (赞：7)

[更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18522997)

## [题目传送门](https://www.luogu.com.cn/problem/P11244)

题目大意已经很清楚，不再赘述。

### 思路：

将所有序列的状态分为 $3$ 个阶段。

先给出一个定义，**序列的跨度**：

定义一个序列 $a$，设其中的最大值为 $r$，最小值为 $l$，那么它的跨度为 $[l, r]$。

#### 第一阶段：

首先注意到 $m\le 20$，而且每次操作 $1$ 都会将两个序列排好序，所以不难发现一些操作后所有的序列都有序了，所以可以记录一下哪些序列是有序的，若当前操作的序列无序再用 $\operatorname{sort}$ 把它变成有序的。每个序列都最多 $\operatorname{sort}$ 一遍，总时间复杂度不会超过 $O(mn\log n)$。

#### 第二阶段：

当所有序列都有序后再进行操作 $1$，还可能会出现值域相交的情况（这里的相交定义为跨度代表的区间**除掉端点**后有交集）。比如 $\{1, 3, 4, 5\}$ 和 $\{2, 4, 5, 6\}$。这时候由于序列已经有序了，所以可以直接进行归并，最多进行 $m^2$ 次归并就能使得所有序列两两值域都不相交，总时间复杂度不会超过 $O(m^2n)$（至于为什么将在下文讨论）。

#### 第三阶段：

这时候操作 $1$ 的本质已经变为了交换两个序列，但我们不用真的交换，从一开始就建立一个 $id$ 数组记录每一个序号究竟对应哪一个序列，对于每个询问直接交换对应的 $id$ 值即可，单次询问时间复杂度 $O(1)$。


---


那么为什么第二阶段的归并次数不会超过 $m^2$ 呢？事实上，不会超过 $\frac{m(m - 1)}{2}$。

这里我用了**数学归纳法**来证明。

#### 命题：有 $m$ 个序列且都有序的情况下，第二阶段的归并次数不会超过 $\frac{m(m - 1)}{2}$。

当 $m = 1$ 时，归并次数为 $0$，显然不会超过 $\frac{m(m - 1)}{2}$。

当 $m = k$ 时假设命题成立，即“有 $k$ 个序列且都有序的情况下，第二阶段的归并次数不会超过 $\frac{k(k - 1)}{2}$”。

那么当 $m = k + 1$ 时，相当于在原来的基础上多加了一个序列，那么由于前 $k$ 个序列已经两两互不相交，那么只需考虑有关第 $k + 1$ 个序列的操作。

>**引理1：**
>设两个序列为 $x, y$ 且 $x,y$ 的跨度不是包含关系，$y$ 的跨度的右端点大于等于 $x$ 的跨度右端点，则对于操作 $\texttt{1 x y}$ 进行了有效归并操作后，设原来的跨度分别为 $S_1,S_2$，新得到的跨度分别为 $S_1',S_2'$，则有
>
>$$S_1'\subseteq S_1,S_2'\subseteq S_2$$
>
>
>**证明：**
>
>设 $x$ 中的最大值为 $mx_x$，最小值是 $mn_x$，$y$ 中的最大值为 $mx_y$，最小值是 $mn_y$，那么 $x$ 的跨度为 $S_1 = [mn_x, mx_x]$，$y$ 的跨度为 $S_2 = [mn_y, mx_y]$。
>
>
>因为只有当 $mx_x > mn_y$ 时才归并，且归并必定将足够多的等于 $mx_x$ 的项移到 $y$ 中，也必定会将足够多的等于 $mn_y$ 的项移到 $x$ 中。
>
>设新得到的 $x,y$ 的跨度分别为 $S_1' = [l_x, r_x],S_2' = [l_y, r_y]$，那么必然有 $r_x \le mx_x,l_y \ge mn_y$，而 $l_x = mn_x,r_y = mx_y$ 这两个不会变，故有 $S_1'\subseteq S_1,S_2'\subseteq S_2$。
>
>
>证明完毕。

这说明：当所有操作的两个序列跨度**不相互包含**时，设势能函数 $F(k + 1)$ 表示与第 $k + 1$ 个序列相交的序列数，显然这个数不会大于 $k$，又因为只有相交我们才归并，根据引理 $1$ 可知，**每次归并只会使得这个数 $-1$ 而不会使它增加**，所以最多 $k$ 次操作就能使它变为 $0$，即此时第 $k + 1$ 个序列不与其它 $k$ 个序列相交。

并且根据引理 $1$，**其他的 $k$ 个序列原本就各不相交，在操作后肯定也各不相交**，所以在此种情况下，第二阶段的归并次数不会超过 $\frac{k(k - 1)}{2} + k = \frac{k(k + 1)}{2}$。

**但是还有一种可能：当两个序列的跨度相互包含的情况呢？**

显然上述引理就不满足了，比如归并 $\{1, 1, 2, 3, 4\}$ 和 $\{2, 2, 2, 2, 2\}$，第二个序列的跨度显然会扩大。

表面上看起来第二个序列变为了 $\{2, 2, 3, 3, 4\}$ 可能和之前的 $k$ 个序列相交从而产生新的势能但是实际上产生的势能不会大于降低的势能。

先考虑以下这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/fzv1a4je.png)

第一行表示的是已经互不相交的 $k$ 个序列，第二行是现在考虑的第 $k + 1$ 个，只从相交的序列中选择一个来操作，现在不妨操作这两个红色的序列（其他的都是同理），上记为 $A$，下记为 $B$，操作后为 $A',B'$。

左红圈表示 $A'$ 的左端点，右红圈表示 $B'$ 的右端点，蓝色线 $k$ 表示操作完后 $A, B$ 的跨度右端点和左端点（有可能不重合，但最多只会相差 $1$），由于将小的元素放在上面或下面都是对称的，所以不妨放上面。

那么很轻松就能得出蓝色线一定是在 $A$ 的右端点左边的，即 $k\le r_A'$，设原来 $A,B$ 产生的势能 $F(A) = 0, F(B) = cnt$。

当蓝线往左移动时，$B$ 的势能每增加 $1$，$A$ 的势能就会减小 $1$，且本次操作消除了 $A, B$ 之间的势能 $1$，那么操作后假设 $F(A) = \lambda$，则 $F(B) = cnt - \lambda - 1$，总势能永远都是 $-1$ 的。

$F(k + 1)\le k$ 所以最多操作 $k$ 次就能使得势能减为 $0$，所以在此种情况下，第二阶段的归并次数也不会超过 $\frac{k(k + 1)}{2}$。

证明完毕。

综上所述：总的时间复杂度不会超过 $O(nm\log n + m^2n + q)$，可以通过此题。

非常感谢你还能看到这里，本人实力有限，这种证明方法感觉太过繁琐，不如官方题解的证明。

~~（先猜后证）~~

$\texttt{Code:}$

```cpp
#include <queue>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2000010;

int n, m, q;
int a[21][N];
bool st[N];
int tmp[N << 1];
int id[21];

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for(int i = 1; i <= m; i++)
        for(int j = 1; j <= n; j++)
            scanf("%d", &a[i][j]);
    for(int i = 1; i <= m; i++) id[i] = i; 
    int op, x, y;
    while(q--) {
        scanf("%d%d%d", &op, &x, &y);
        if(op == 1) {
            int xx = x, yy = y;
            x = id[x], y = id[y];
            if(st[x] && st[y]) {
                if(a[x][n] > a[y][1]) {
                    if(a[x][1] >= a[y][n])
                        swap(id[xx], id[yy]);
                    else {
                        int pos1 = lower_bound(a[x] + 1, a[x] + n + 1, a[y][1]) - a[x];
                        int pos2 = lower_bound(a[y] + 1, a[y] + n + 1, a[x][n]) - a[y];
                        if(a[x][pos1] == a[y][1]) pos1++;
                        if(a[y][pos2] == a[x][n]) pos2--;
                        if(pos2 == n + 1) pos2--;
                        int p1 = pos1, p2 = 1, top = 0;
                        while(p1 <= n && p2 <= pos2) {
                            if(a[x][p1] < a[y][p2]) tmp[++top] = a[x][p1++];
                            else tmp[++top] = a[y][p2++];
                        }
                        while(p1 <= n) tmp[++top] = a[x][p1++];
                        while(p2 <= pos2) tmp[++top] = a[y][p2++];
                        top = 1;
                        for(int i = pos1; i <= n; i++)
                            a[x][i] = tmp[top++];
                        for(int i = 1; i <= pos2; i++)
                            a[y][i] = tmp[top++];
                    }
                }
            }
            else {
                if(!st[x]) sort(a[x] + 1, a[x] + n + 1);
                if(!st[y]) sort(a[y] + 1, a[y] + n + 1);
                st[x] = st[y] = true;
                int pos1 = lower_bound(a[x] + 1, a[x] + n + 1, a[y][1]) - a[x];
                int pos2 = lower_bound(a[y] + 1, a[y] + n + 1, a[x][n]) - a[y];
                if(a[x][pos1] == a[y][1]) pos1++;
                if(a[y][pos2] == a[x][n]) pos2--;
                if(pos2 == n + 1) pos2--;
                int p1 = pos1, p2 = 1, top = 0;
                while(p1 <= n && p2 <= pos2) {
                    if(a[x][p1] < a[y][p2]) tmp[++top] = a[x][p1++];
                    else tmp[++top] = a[y][p2++];
                }
                while(p1 <= n) tmp[++top] = a[x][p1++];
                while(p2 <= pos2) tmp[++top] = a[y][p2++];
                top = 1;
                for(int i = pos1; i <= n; i++)
                    a[x][i] = tmp[top++];
                for(int i = 1; i <= pos2; i++)
                    a[y][i] = tmp[top++];
            }
        }
        else printf("%d\n", a[id[x]][y]);
    }
    return 0;
}
```

其实也可以用 vector 直接 $O(1)$ 交换，就不用写 $id$ 数组了。（只是需要做一些下标上的转换）

~~这一场怎么这么奇怪？~~

---

## 作者：BruceTong (赞：6)

# P11244 吻秋 题解

## 题目

### 题目内容

有 $m$ 个长度为 $n$ 的序列，有 $q$ 次操作，分别是将两个序列排序并分成大小两段和查询某个位置的值。

### 题意理解

不难发现操作的次数 $q$ 过分多而序列的数量 $m$ 过分少，在一定次数操作后会收敛，不管怎么再进行排序操作也不会发生改变。

## 做法

>只要心里有玫瑰，答案就不再那么难了--T4

我们定义有效操作是能够使序列内部元素发生变化的操作。

### 命题：有效操作的数量不超过 $m^2$

证明如下：

#### 做法一（容易理解，但不严谨）

将每个序列当成一个点，每个排序操作相当于当两个，点的顺序不符合单调递增时进行交换。

不难发现每个点最多交换 $m$ 次（~~其实还多了~~），有 $m$ 个点，所以最多 $m^2$ 次。

#### 做法二（严谨，~~也很容易理解~~）

每个序列有 $n$ 个点，在所处在已排序的序列中处于正确位置，但在所有序列中不一定位置正确。

交换操作能够使得该点在两个排序的序列中处于正确位置，相当于做法一。

由做法一我们还能发现，对于 $m^2$ 个不同操作一定能让序列中某个元素到正确位置。

### 理论转化

对于每个排序操作，如果对应两个序列没有排过序，则先排序。

如果序列 $x$ 的最大值小于等于序列 $y$ 的最小值，则无需操作。

如果序列 $y$ 的最大值小于等于序列 $x$ 的最小值，则交换两个序列，这里用 $id_i$ 储存每个序列对应下标。

如果上述条件均不成立，该操作为有效操作，用归并排序思路排序。

查询直接读取。

时间复杂度为 $O(m^2n)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,q;
struct node{
	int a[2000010];
}ns[22];
int id[22];
bool vis[22];
int b[4000010];

int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) scanf("%d",&ns[i].a[j]);
	for(int i=1;i<=m;i++) id[i]=i;
	for(int i=1;i<=q;i++){
		int op,xx,yy;
		scanf("%d%d%d",&op,&xx,&yy);
		int x=id[xx],y=id[yy];
		if(op==1){
			if(vis[x]==0){
				sort(ns[x].a+1,ns[x].a+1+n);
				vis[x]=1;
			}
			if(vis[y]==0){
				sort(ns[y].a+1,ns[y].a+1+n);
				vis[y]=1;
			}
			if(ns[x].a[n]<=ns[y].a[1]) continue;
			if(ns[y].a[n]<=ns[x].a[1]){
				swap(id[xx],id[yy]);
				continue;
			}
			for(int i=1,j=1;i<=n||j<=n;){
				if(i<=n&&(j>n||ns[x].a[i]<ns[y].a[j])) b[i+j-1]=ns[x].a[i],i++;
				else b[i+j-1]=ns[y].a[j],j++;
			}
			for(int i=1;i<=n;i++) ns[x].a[i]=b[i];
			for(int i=1;i<=n;i++) ns[y].a[i]=b[i+n];
		}else{
			printf("%d\n",ns[x].a[yy]);
		}
	}
	
	return 0;
}
```

---

## 作者：_H17_ (赞：3)

## 前言

~~通常只有遇到好题或者切掉难题才会有前言。~~

超级有意思的暴力诈骗题。

虽然知道是诈骗，还是从暴力着手。

## 暴力

每次暴力快速排序、直接查询，时间复杂度 $O(n\times q\log n)$。

## 考虑优化

一开始看起来比较像数据结构，然而支持排序的数据结构也难以完成（反正我不知道能不能用堆），估计是势能暴力。

首先我们得到的一个结论：一个序列只会排序一次。

显然：序列要么没排序，任意操作一之后就会有序，要么有序，无论如何不会被打乱。

此时操作一只需要归并。

时间复杂度 $O(n\times m\log n+n\times q)$。

## 进一步优化（重点、精华）

显然此时可以优化的点不多，考虑势能的暴力优化。

这种优化指的是本质不变，进行剪枝，但是可以证明时间复杂度正确的做法。

由于 $m$ 很小，考虑与之相关的做法。

我们的瓶颈目前在归并，显然当 $a_x,a_y$ 都有序，且 $a_{x,n}<a_{y,1}$ 时不需要排序，$a_{y,n}<a_{x,1}$ 时需要整体交换（我们可以开一个数组来维护交换前的位置）。

对于如上情况，我们称之为 $a_x,a_y$ 彻底分离（用等号表示），同时通过两者大小用大于、小于号表示，融合用不等号表示。

但是如何进行时间复杂度证明？

什么时候**不**彻底分离的两个序列分离时会融合其他序列？当 $a_x=a_t=a_y$ 或者 $a_x\ne a_t,a_y \ne a_t$ 时，对 $a_t$ 没有影响。当不存在 $a_t=a_x,a_t\ne a_y$（同理的情况不列举，此时 $a_t$ 与其中一个分离），$a_t$ 将会彻底分离于 $a_x,a_y$ 中的一个（此时不会增加、减少除了 $a_x,a_y$ 的分离关系）。

上面的情况：会建立 $a_x,a_y$ 的分离关系，影响的其他关系会和建立的抵消。

总共有 $m^2$ 级别的关系，所以会归并 $m^2$ 次。

时间复杂度 $O(n\times m\log n+n\times m^2+q)$。

## 代码实现

势能暴力优化，代码比较简单，有一点卡常，但是我不用快读硬着过去了（主要是卡懒得写归并排序最后硬用快速排序搞的，但是这个也没卡掉，原因是快读就能过）。

总而言之：数据没卡后面的归并，也就是快排也可以。

```cpp
#include<bits/stdc++.h>
#define ALL(x) x.begin(),x.end()
#define int unsigned //常数优化
using namespace std;
int n,m,q,sorted[21],now[21];
vector<int>a[21],tmp;
void sort(int id){
    if(!sorted[id]){
        sort(ALL(a[id]));
        sorted[id]=1;
    }//只排序没排过的
    return;
}
void merge(int x,int y){
    sort(now[x]),sort(now[y]);
    if(a[now[x]][n-1]<=a[now[y]][0])
        return;
    if(a[now[x]][0]>=a[now[y]][n-1]){
        swap(now[x],now[y]);
        return;
    }//排序过（势能优化）
    x=now[x],y=now[y];
    tmp.clear();
    for(int i=0,j=0;i<n||j<n;){
        if(i==a[x].size()){
            while(j<a[y].size())
                tmp.push_back(a[y][j++]);
            continue;
        }
        if(j==a[y].size()){
            while(i<a[x].size())
                tmp.push_back(a[x][i++]);
            continue;
        }
        if(a[x][i]<=a[y][j])
            tmp.push_back(a[x][i++]);
        else
            tmp.push_back(a[y][j++]);
    }//归并
    for(int i=0;i<n;i++)
        a[x][i]=tmp[i];
    for(int i=0;i<n;i++)
        a[y][i]=tmp[n+i];//放回去
    return;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr);//常数优化
    cin>>n>>m>>q;
    for(int i=1;i<=m;i++){
        a[i].resize(n);
        now[i]=i;//记得初始值
        for(int j=0;j<n;j++)
            cin>>a[i][j];
    }
    for(int op,x,y;q;--q){
        cin>>op>>x>>y;
        if(op==1)
            merge(x,y);
        else
            cout<<a[now[x]][y-1]<<'\n';//注意下标细节
    }
    return 0;
}
```

---

## 作者：SXqwq (赞：1)

### Description

有 $m$ 个整数序列 $a_1\dots a_m$，每个序列长度都为 $n$。$q$ 次操作，操作有如下两种。

- `1 x y` 将 $a_x,a_y$ 拼接在一起形成长度为 $2n$ 的序列 $b$，将 $b$ 升序排序后取 $b_1\dots b_n$ 作为新的 $a_x,b_{n+1}\dots b_{2n}$ 作为新的 $a_y$。

- `2 i j` 求 $a_{i,j}$ 的值。

$1\le n\cdot m\le 2\times 10^6,1\le m\le 20,1\le q\le 5\times 10^6,1\le a_{i,j}\le 10^7$。

### Analysis

诈骗题。

暴力是显然的，直接模拟即可，可获得 $9$ 分的好成绩。

考虑优化这个暴力。注意到对数组 $a_i$ 执行 $1$ 次操作一后，它必定是有序的。而当 $\min\{a_i\}\ge \max\{a_j\}$ 时，执行操作 $1$ 对答案是没有影响的，反之，当 $\max\{a_i\}\le \min\{a_j\}$ 时，执行操作 $1$ 的效果是将两数组整体交换。当然，我们不必整体交换，对每个数组开一个指针 $p$ 记录其指向哪个数组，交换指针 $p$ 即可。

这就过了。

事实上，最多执行 $m^2$ 次暴力合并。下面给出证明。

定义数组 $a_i,a_j$“相对有序”当且仅当 $\min\{a_i\}\ge \max\{a_j\}$ 或 $\max\{a_i\}\le \min\{a_j\}$。数组 $a_i$“绝对有序”当且仅当与 $\forall a_j(j\in[1,m])$ 再执行操作一不改变。$C=a_i+a_j$ 当且仅当 $C=\{a_{i,1}+\dots+a_{i,n}+a_{j,1}+\dots+a_{j,n}\}$。$a_i$“满足条件”当且仅当 $a_i$与 $\forall a_j(j\in[1,m])$ 各执行 $1$ 次操作一。$a_i$ ”最小“当且仅当对于数组 $C=\sum\limits_{i=1}^m a_i$，将 $C$ 升序排序，满足 $a_i=\{C_1,C_2\dots C_n\}$，$a_i$“第二小，第三小”可类比定义，不再赘述。

我们希望任意两对数组都“相对有序”。这样就不需要暴力合并了，直接交换指针或者不操作即可。不难发现，任意两对数组“相对有序”的充要条件为每个数组都“绝对有序”。

不妨假设我们的最终目标是令每个数组都“绝对有序”。

**Claim.** 若 $a_i$ 有序，$a_i$ 与 $\forall a_j(j\in[1,m])$ 执行操作一，$a_i$ 的字典序不可能变大。换言之，不可能有 $a_{j,p}\rightarrow a_{i,q},a_{j,p}>a_{i,q},(p,q\in[1,n])$。

**Proof.** 分两种情况讨论。

- 若 $\max\{a_i\}\le \min\{a_j\}$ 时，$a_i$ 不变。

- 否则，$\exists a_{j,p}<a_{i,q},(i,j\in[1,m],p,q\in[1,n])$，即 $a_{j,p}\rightarrow a_{i,q}$，$a$ 的字典序变小。

证毕。

将上述结论推广，任意“满足条件”的 $a_i$，必定“绝对有序”。由上述结论得，若 $a_i$ 是**第一个**“满足条件”的，$a_i$ 必定“最小”。类似的，若 $a_j$ 是第二个“满足条件”的，$a_j$ 必定“第二小”。以此类推，对于任意 $a_i$，与其余 $m-1$ 个数组执行操作一后，必定“绝对有序”，总共最多执行 $m\times(m-1)$ 次，可近似看作 $m^2$。

综上，最多执行 $m^2$ 次暴力合并，若使用 sort，时间复杂度 $O(m^2n\log n+q)$。可以通过本题。

### Code

```cpp
constexpr int N = 2e6+10;
namespace FastIO {
	char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)
	template <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }
	template <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }
	template <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }
	template <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }
}; using namespace FastIO;
#undef getchar()
namespace solution
{
    int mp[100][N];
    int n,m,q;
    int t[N];
    int p[N];
    void solve()
    {
        n = FastIO::read<int>(),m = FastIO::read<int>(),q = FastIO::read<int>();
        for(int i=1;i<=m;i++) p[i] = i;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++) mp[i][j] = FastIO::read<int>();
        while(q--)
        {
            int op,x,y;
            op = FastIO::read<int>(),x = FastIO::read<int>(),y = FastIO::read<int>();
            int u = x,v = y;
            x = p[x];
            if(op == 1)
            {   
                y = p[y];
                if(mp[x][0] && mp[y][0])
                {
                    if(mp[x][n] <= mp[y][1]) continue;
                    if(mp[x][1] >= mp[y][n]) {swap(p[u],p[v]);continue;}
                }
                int tot = 0;
                for(int i=1;i<=n;i++) t[++tot] = mp[x][i];
                for(int i=1;i<=n;i++) t[++tot] = mp[y][i];
                sort(t+1,t+2*n+1);
                for(int i=1;i<=n;i++) mp[x][i] = t[i];
                for(int i=1;i<=n;i++) mp[y][i] = t[i+n];   
                mp[x][0] = mp[y][0] = 1;
            }
            else print(mp[x][y],'\n');
        }
    }
}
```

---

## 作者：__ex (赞：0)

我非常菜，不知道什么是归并排序

于是就想乱搞优化暴力

考虑到有序数组 $a$ 和 $b$ 之间进行排序，若要求前一半存 $a$ 里面，就大致分为两种情况，原来的 $a$ 比较小，和原来的 $a$ 比较大

如果原来的 $a$ 比较小，那么 $a$ 再进行排序，而且取前一半，那么 $a$ 的变化也不大

如果原来的 $a$ 比较大，那么 $a$ 再进行排序，而且取前一半，可以把 $a$，$b$ 换一下，让 $a$ 实际存大的那一半，$b$ 实际存小的那一半，并记录一下 $a$，$b$ 所**真正**表示的数组是什么

然后发现这样做的话，“比较小的数组”经过排序只会越来越小

由于 $m$ 很小，排序次数很多，小的数组就会非常非常小，数组的变化就会很小

看到暴力要把两个数组拆开重排，不妨只把两个数组值域有交集的部分拆开重排

那怎么感觉出来哪个数组比较小？

可以记录一下每个数组**排序被放在前面的次数**，次数多的就感觉会比较小，下次排序仍然放前面

特判一下初始的无序数组

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
template<typename T>inline T read(){
    T a=0;bool s=0;
    char ch=getchar();
    while(ch>'9' || ch<'0'){
        if(ch=='-')s^=1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9'){
        a=(a<<3)+(a<<1)+(ch^48);
        ch=getchar();
    }
    return s?-a:a;
}
const int mn=2e6+10;
int n,m,q,o[mn],bel[22],tot,L[22];
vector<int> a[mn];
bool sorted[mn];
int main(){
    n=read<int>();m=read<int>();q=read<int>();
    for(int i=1;i<=m;i++)
        bel[i]=i;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            a[i].push_back(read<int>());
    for(int i=1;i<=q;i++){
        int op=read<int>();
        int x=read<int>(),y=read<int>();
        if(op==1){
            if(!sorted[bel[x]]){
                sort(a[bel[x]].begin(),a[bel[x]].end());
                sorted[bel[x]]=1;
            }
            if(!sorted[bel[y]]){
                sort(a[bel[y]].begin(),a[bel[y]].end());
                sorted[bel[y]]=1;
            }
            if(L[bel[x]]<L[bel[y]])
                swap(bel[x],bel[y]);
            L[bel[x]]++;
            int l=n,r=1;
            while(l && a[bel[x]][l-1]>a[bel[y]][0])l--;
            while(r<=n && a[bel[y]][r-1]<a[bel[x]][n-1])r++;
            if(l==n)continue;
            r-=2;tot=0;
            for(int i=l;i<n;i++)
                o[++tot]=a[bel[x]][i];
            for(int i=0;i<=r;i++)
                o[++tot]=a[bel[y]][i];
            sort(o+1,o+tot+1);
            for(int i=l;i<n;i++)
                a[bel[x]][i]=o[i-l+1];
            for(int i=0;i<=r;i++)
                a[bel[y]][i]=o[i+n-l+1];
        }
        else printf("%d\n",a[bel[x]][y-1]);
    }
    return 0;
}
```

时间复杂度不会算，但至少很难被卡

---


# 歌唱练习

## 题目背景

2077 年，万众瞩目的天依 v100 声库发布了！

但是要熟悉这套新声库可不是件容易的事。

## 题目描述

天依制定了一个长为 $n$ 天的练习计划。天依十分努力，她每天的练习时长必须**单调不降**。同时，为了保护嗓子，第 $i$ 天**最多**练习 $t_i$ 个单位时间。每一天练习的效果都是不同的，受到天气等多种因素影响，我们用 $w_i$ 量化第 $i$ 天的练习效果，表示她在第 $i$ 天每练习一个单位时间会使她的熟悉度提升 $w_i$。注意 $w_i<0$ 也是可能发生的，或许这天太热她越练越糟。

现在，天依已经查明了 $n$ 天的天气预报并估算出了每天的 $t_i$ 与 $w_i$，请问她至多能将她的熟悉度提升多少？

## 说明/提示

### 样例解释
第 $1$ 天练习 $2$ 个单位时间，使熟悉度提高 $4$；  
第 $2$ 天练习 $2$ 个单位时间，使熟悉度提高 $-2$（降低 $2$）；  
第 $3$ 天练习 $3$ 个单位时间，使熟悉度提高 $3$。  
天依的熟悉度总共提高了 $5$。

可以证明，不存在比上述方案更优的选择。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$1\le n\le10^6$，$0\le t_i\le10^9$，$-1000\le w_i\le1000$。

对于不同的子任务，作如下约定：

|子任务编号|$n\le$|$t_i\le$|特殊性质|子任务分值|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$15$|$15$|无|$10$|
|$2$|$15$|$10^9$|无|$10$|
|$3$|$100$|$100$|无|$10$|
|$4$|$5000$|$5000$|无|$10$|
|$5$|$5000$|$10^9$|无|$10$|
|$6$|$10^5$|$10^5$|无|$10$|
|$7$|$10^6$|$1$|无|$5$|
|$8$|$10^6$|$10^9$|有|$15$|
|$9$|$10^6$|$10^9$|无|$20$|

特殊性质：保证 $t_i$ 在 $[0,10^9]$ 中均匀随机生成。

## 样例 #1

### 输入

```
3
3 2 3
2 -1 1```

### 输出

```
5```

# 题解

## 作者：DyingEncoder (赞：7)

### 题目大意
要确定每天训练的时间 $a_i$ ，满足$a_i \le t_i$ 且  $a_i$ 单调递增
所求的答案为：
$$max \sum_{i=1}^{n} a_i w_i$$

### 问题分析
1. $t_i$ 应该要满足$t_{i-1} \le t_i$ ,这点需要预处理
2. 技巧：
   - 贪心时，某一天的选择会对后一天产生影响（前一天的练习时间 $a_{i-1}$ 选择过大，可能导致后面遇到 $w_i<0$ 的极小值干扰结果）
   - 而某一天的选择一定不会对前一天产生影响，故从后往前贪心
### 问题解决
1. 预处理：在 $t_i$ 被调整后，调整 $t_{i-1}$ 使得 $t_{i-1} \le t_i$ ，因此需要从后往前遍历
   ```cpp
   for(int i=n-1;i>=1;i--) t[i]=min(t[i],t[i+1]);
   ```
2. 主体部分贪心：从后往前贪心，记答案为 $ans$ 。对于 $w_i$ 分两种情况讨论
   
   (1) 若当前 $w_i \ge 0$ ，则要使当前的用时 $a_i$ 最大，由于 $a_i \le t_i$ ，所以直接取 $a_i \gets t_i$ ，这时 $ans$ 就应该增加 $ w_i t_i$ 。
   ```cpp
   if(w[i]>=0){
      ans+=1ll*w[i]*t[i];
      //注意：如果w和t用int存，那么一定要乘以1ll
      //否则有可能超出int范围
   }
   ```

   (2) 若当前 $w_i < 0$ ，那么我们希望最小化 $a_i$ 的值，这时就要和前面的练习时间发生关联。观察下面最小化的过程：
  ![](https://cdn.luogu.com.cn/upload/image_hosting/611koizf.png)
   这时 $2$ ~ $3$ 天的练习情况可以表示为 $(w_3+w_2)t_2$
   同理，在最小化考虑的范围超过 $2$ 时，也可以用以上方式计算
   ![](https://cdn.luogu.com.cn/upload/image_hosting/znuygmjt.png)

   这时候 $4$ ~ $6$ 天，可不断合并，直到合并的点权值 $w_i \ge 0$ 。若第 $k$ ~ $i$ 天，合并点权值为：
   $$\sum_{j = k}^{i} w_j$$
   合并点时间为
   $$t=min(t_{j(j \in [k,i])})$$
   我们可以把合并点权值放在 $w_i$ ，时间放在 $t_i$ 。那么什么时候结束合并呢？当该合并点权值 $w_i \ge 0$ 时即可。
   
   合并代码如下：
   ```cpp
   while(j>=1&&1ll*w[i]*t[i]<0ll){
      //k点(左界)不确定，选择while循环，直到满足条件或越界为止
      w[i]+=w[j];
      t[i]=min(t[i],t[j]);
      j--;
   }
   ```
### 总代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n;
long long ans;//十年OI一场空，不开longlong( )( )( )
int t[N],w[N];
int main(){
	
	cin>>n;
	for(int i=1;i<=n;i++) cin>>t[i];
	for(int i=1;i<=n;i++) cin>>w[i];
	
	for(int i=n-1;i>=1;i--) t[i]=min(t[i],t[i+1]);
	
	for(int i=n;i>=1;i--){
		if(w[i]>=0){
			ans+=1ll*w[i]*t[i];
            //注意：如果w和t用int存，那么一定要乘上1ll
		}else{
			int j=i-1;
			while(j>=1&&1ll*w[i]*t[i]<0ll){
                //注意：如果w和t用int存，那么一定要写0ll
				w[i]+=w[j];
				t[i]=min(t[i],t[j]);
				j--;
			}
			if(1ll*w[i]*t[i]<0ll&&j==0){
                //也要写1ll、0ll
				ans+=0;
			}else{
				ans+=1ll*w[i]*t[i];//也要写1ll
			}
			i=j+1;//因为for循环本身有i-- 
		}
	}
	cout<<ans;
	return 0;
	
}
```

---

## 作者：mysterys (赞：7)

为啥题解区写得都这么复杂……

# 思路
1. 一个很显然的事情：由于练习时长单调不降，所以每一天的实际练习情况应该是后缀最小值。
2. 发现正着贪心会影响后面的状态，考虑正难则反。
3. 不难发现一个点作为决策点当且仅当它到上一个决策点之间的 $ \sum{w_i}$ 非负，此时用直接用最大值去贪即可。同时，每次都使用最大值，也保证了单调不降的条件。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define endl '\n'
#define int long long
const int N=1e6+5;
int n,t[N],w[N],s[N];
int minn[N],lst,ans;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;lst=n+1;
	for(int i=1;i<=n;i++) cin>>t[i];
	for(int i=1;i<=n;i++){
		cin>>w[i];s[i]=s[i-1]+w[i];
	}
	s[n+1]=s[n]; minn[n]=t[n];
	for(int i=n-1;i;i--) minn[i]=min(minn[i+1],t[i]);
	for(int i=n;i;i--){
		if(s[lst-1]-s[i-1]>=0) ans+=minn[i]*(s[lst-1]-s[i-1]),lst=i;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Po7ed (赞：6)

### 题意

设第 $i$ 天练习 $a_i$ 单位时间，那么题意即为 

$$
\begin{cases}
0\le a_1\\
a_{i-1}\le a_i & (1<i\le n)\\
a_i\le t_i & (1\le i\le n)
\end{cases}
$$

最大化

$$
ans=\sum_{i=1}^{n}a_iw_i
$$

### 思路

因为小于等于的传递性，不难发现 $\forall j\ge i,\,a_i\le t_j$，所以可以先对 $t$ 做一遍后缀最小值。

对于每一个 $1\le i\le n$，当 $w_i\ge 0$ 时，我们应最大化 $a_i$，即 $a_i\gets t_i$；当 $w_i<0$ 时，应最小化 $a_i$，即令 $a_i\gets a_{i-1}$，此时观察 $i-1,i$ 的贡献 $a_{i-1}w_{i-1}+a_iw_i$，其中 $a_i=a_{i-1}$，故贡献即为 $a_{i-1}(w_{i-1}+w_i)$。

发现了什么？**我们可以直接将 $\boldsymbol{i-1,i}$ 合并**，新权值为 $w_{i-1}+w_i$，训练时间以 $a_{i-1}$ 为准，这样方便计算答案。

若合并后权值仍为负，需要继续向前合并。无法合并（已经是第一天）的直接放弃。

### 代码

注意代码实现与思路有部分差异。

```cpp
#include <bits/stdc++.h>

using std::cin;
typedef long long ll;
constexpr int N=1e6+114;
int n;
ll t[N],w[N];

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>t[i];
	for(int i=1;i<=n;i++)cin>>w[i];
	for(int i=n-1;i;i--)t[i]=std::min(t[i],t[i+1]); // 后缀最小值
	int j=n;
	for(int i=n-1;i;i--) // 这里是从后向前枚举，更方便处理合并
	{
		if(w[j]<0)w[j]+=w[i],t[j]=t[i]; // 如果下一个日期权值为负，则合并
		else w[--j]=w[i],t[j]=t[i]; // 否则直接平移
	}
	ll ans=0;
	for(int i=j;i<=n;i++) // [j,n] 是合并后的日期
	{
		if(i==j&&w[i]<0)continue; // 注意！！！第一天练习时间可以为 0
		ans+=t[i]*w[i];
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ycy1124 (赞：5)

### 题意
天依在未来的 $n$ 天内想要计划训练，每天练习的时间必须单调不降，在第 $i$ 天她最多练习 $t_i$ 的时间，并且在当天她每练习一个时间就能使她的熟练度提升 $w_i$。试问在 $n$ 天的训练后天依的最大熟练度是多少。
### 思路
观察数据范围，$n$ 刚好够 $n\log n$ 的算法通过，于是往这方面想。首先肯定是要给 $t$ 数组取个后缀 min，给 $w$ 取个后缀和，第 $i$ 天练习的价值就是这个后缀和乘上练习时间。然后不难想到一个贪心思路，对于每一天，我们最终方案这一天的练习时间要是会增加，那么一定就会增加到最大。其次，对于每一个练习的时间，我们肯定会取其后缀和最大的那一个值作为贡献。当时没有想到反着贪心，正着来于是写了一个反悔贪心。

考虑反悔贪心如何贪，我们首先可以遍历 $n$ 天，对于每一天，根据我们的第一个结论，我们可以先让 $t_i-t_{i-1}$ 的时间在今天练习。然后考虑反悔，对于前面所有练习的时间，我们将他们练习的时间长度，当天每次练习的价值用结构体放在一个堆里面。按练习的价值将堆排成一个小根堆，每次将堆里面练习价值小于今天练习价值的练习时间全换到今天练习。然后将今天的值放进堆里面就算统计完了一天的贡献。我们只需要在每一天维护一下总价值然后 $ans$ 在每一天取个 max 然后输出即可。

证明：首先发现对于每个练习的时间取他的最大的练习价值肯定是正确的。然后对于方案能否能构造出来，我们只需要在被弹出的那一天不增长练习的时间，然后将后面的练习时间减去原本今天要增长的练习时间，最后在今天多练习这么多时间即可完成一次弹出的构造。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define flush() fwrite(obuf,1,O-obuf,stdout)//从同学那偷的超级快读
#define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read(){
	register int x=0,f=1;
	register char ch=getchar();
	while(!(ch>='0'&&ch<='9'))
		if(ch=='-')f=-1,ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+(ch^48),ch=getchar();
	return x*f;
}
inline void write(register int x){
    (x>9)?write(x/10):void();
    putchar((x%10)^48);
}
struct Flush{
    ~Flush(){flush();}
}_;
int t[1000005],n,w[1000005],qzh[1000005],tmp,sum,ans,dp[1000005],tot;
struct Node{
	int w,s;
}b[1000005];
void work1(int p){//手写堆的函数
	if(p*2+1<=tot&&b[p*2].w>b[p*2+1].w&&b[p].w>b[p*2+1].w){
		swap(b[p],b[p*2+1]);
		work1(p*2+1);
	}
	else if(p*2<=tot&&b[p*2].w<b[p].w){
		swap(b[p],b[p*2]);
		work1(p*2);
	}
}
void work(int p){
	if(p>1&&b[p].w<b[p/2].w){
		swap(b[p],b[p/2]);
		work(p/2);
	}
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		t[i]=read();
	}
	for(int i=1;i<=n;i++){
		w[i]=read();
	}
	for(int i=n;i>=1;i--){//价值的后缀和
		qzh[i]=qzh[i+1]+w[i];
	}
	for(int i=n-1;i>=1;i--){//练习时间的后缀min
		t[i]=min(t[i],t[i+1]);
	}
	for(int i=1;i<=n;i++){//遍历每一天
		int js=0;//当天练习的时间
		js+=t[i]-t[i-1];//先将能增长的全涨了，后面反悔会调整
		while(tot&&qzh[i]>b[1].w){//将堆顶那些较劣的弹出
			js+=b[1].s;//将当天的练习放到今天练习
			sum-=b[1].s*b[1].w;//更新价值
			swap(b[1],b[tot]);//弹出
			--tot;
			work1(1);
		}
		sum+=js*qzh[i];//计算价值
		ans=max(sum,ans);//统计答案
		b[++tot]={qzh[i],js};//放入堆
		work(tot);
	}
	write(ans);
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/204526939)。
### 优化
论优化。你会发现如果有一天会弹出前面的，那肯定只会将前面的连续一段都弹出，于是不用堆，直接线性即可。至于为什么，前面的所有练习价值一定是保持单调不升的，不然就被弹掉了，所以每次只有可能弹掉连续的一段，这样就能线性复杂度了。
### 优化代码
此时直接拿单调栈维护即可，加上优化后跑得飞快。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define flush() fwrite(obuf,1,O-obuf,stdout)//从同学那偷的超级快读
#define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
__inline__ int read(){
	register int x=0,f=1;
	register char ch=getchar();
	while(!(ch>='0'&&ch<='9'))
		if(ch=='-')f=-1,ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+(ch^48),ch=getchar();
	return x*f;
}
__inline__ void write(register int x){
    (x>9)?write(x/10):void();
    putchar((x%10)^48);
}
struct Flush{
    ~Flush(){flush();}
}_;
int t[1000005],n,w[1000005],qzh[1000005],sum,ans,ww[1000005],ti[1000005],tot;
__inline__ int Max(int x,int y){
    return x>y?x:y;
}
__inline__ int Min(int x,int y){
    return x<y?x:y;
}
signed main(){
	n=read();
	for(register int i=1;i<=n;i++){
		t[i]=read();
	}
	for(register int i=1;i<=n;i++){
		w[i]=read();
	}
    t[n+1]=1e9;
	for(register int i=n;i>=1;i--){//价值的后缀和
		qzh[i]=qzh[i+1]+w[i];
        t[i]=Min(t[i],t[i+1]);//练习时间的后缀min
	}
	for(register int i=1;i<=n;i++){//遍历每一天
		int js=t[i]-t[i-1];//当天练习的时间
		while(tot&&qzh[i]>ww[tot]){//将栈顶那些较劣的弹出
			js+=ti[tot];//将当天的练习放到今天练习
			sum-=ti[tot]*ww[tot];//更新价值
			--tot;//弹出
		}
        if(!js){//今天不练习，让你的代码跑得更快
            continue;
        }
		sum+=js*qzh[i];//计算价值
		ans=Max(sum,ans);//统计答案
		ww[++tot]=qzh[i];//插入栈
        ti[tot]=js;
	}
	write(ans);
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/204690897)。

---

## 作者：Tjaweiof (赞：4)

# P11769 题解
[题目传送门](https://www.luogu.com.cn/problem/P11769)

由于每天的练习时长单调不降，于是判断第 $i$ 天的训练时长的多少需要考虑 $\sum_{j=i}^nw_i$ 的值。所以我们需要记录 $w_i$ 的后缀和，设 $s_i=\sum_{j=i}^nw_i$。注意到如果 $t_i>t_j(1\le i<j\le n)$，那么 $t_i$ 不能全部用，所以让 $t_i=\min{t_i,t_{i+1},\dots,t_n}$ 也不会有区别。

于是，问题转化为了：给定 $t_i,s_i$，求一个长度为 $n$ 非负整数序列 $ans$，满足对于任意 $1\le i\le n$，有 $\sum_{j=1}^ians_j\le t_i$。在满足条件的情况下，使得 $\sum ans_i\times s_i$ 最大，并输出这个最大值。

显然贪心，先找到当前使得 $s_i$ 最大的 $i$，然后让 $ans_i$ 取到最大。然后继续从 $i+1$ 到 $n$ 之间找到使 $s_j$ 最大的 $j$，重复进行这个操作，直到选到了 $n$ 或者当前最大的 $s_i<0$，那么退出，计算答案即可。找最大的过程可以用单调队列完成。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in", "r", stdin);freopen(x".out", "w", stdout);
int n;
long long t[1000001], w[1000001], tmp, ans;
deque <int> q;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> t[i];
	}
	for (int i = 1; i <= n; i++){
		cin >> w[i];
	}
	for (int i = n - 1; i >= 1; i--){
		w[i] += w[i + 1];
		t[i] = min(t[i], t[i + 1]);
	}
	for (int i = 1; i <= n; i++){
		while (!q.empty() && w[q.back()] < w[i]){
			q.pop_back();
		}
		q.push_back(i);
	}
	while (!q.empty()){
		if (w[q.front()] <= 0){
			break;
		}
		ans += w[q.front()] * (t[q.front()] - tmp);
		tmp = t[q.front()];
		q.pop_front();
	}
	cout << ans;
	return 0;
}
```

---

## 作者：MafuyuQWQ (赞：4)

## 简化题意

给定 $ n $ 天，每天有最大练习时长 $ t_i $ 和单位收益 $ w_i $。要求选择每天的练习时长 $ x_i $，满足 $ x_i \le t_i $ 单调不降，求最大化总收益 $ \sum_{i=1}^{n}(x_i \times w_i) $。注意 $ w_i $ 可能为负数。

## Solution

首先考虑 $ w_i $ 都大于 $ 0 $ 的情况，直接倒序从末尾开始练习时间能取大则取大。

然后对于 $ w_i $ 有负值的情况，贪心地考虑将其与前一位合并。新开一个数组存放合并后的段，将 $ i $ 与其前面的合并，直到 $ w_i > 0 $ 或者存放合并后的段都被合并到当前的 $ i $ 这一位。在合并操作中，累加 $ w_i $，并对于 $ t_i $ 取段中较小值。因为要求 $ t_i $ 是单调不降的，所以这个操作就相当于将 $ w_i < 0 $ 的位与前面的位绑定，可以证明正确性。

合并完了之后，段的 $ w_i $ 就分为 $ 2 $ 种情况了。

* 第一段 $ w_i $ 为负值，剩下都是正值，这种情况直接不考虑第一段即可。
* 转换为了 $ w_i $ 都大于 $ 0 $ 的情况，同上。

## 实现实例

```
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 2000010;

int n;
struct Day
{
    int t, w;
} pt[N], d[N];
int cnt;

signed main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> pt[i].t;
    for (int i = 1; i <= n; i ++ ) cin >> pt[i].w;
    
    for (int i = 1; i <= n; i ++ )
    {
        if (pt[i].w < 0)
        {
            int j = cnt;
            while (j > 0 && pt[i].w + d[j].w < 0) pt[i].w += d[j].w, pt[i].t = min(pt[i].t, d[j].t), j -- ;
            if (j < 1) d[cnt = 1] = pt[i];
            else
            {
                cnt = j;
                d[cnt] = {min(pt[i].t, d[j].t), pt[i].w + d[j].w};
            }
        }
        else d[ ++ cnt] = pt[i];
    }

    // for (int i = 1; i <= cnt; i ++ ) cout << d[i].t << ' ' << d[i].w << '\n';
    int st = (d[1].w < 0 ? 2 : 1), mn = 1e10, res = 0;
    for (int i = cnt; i >= st; i -- )
        mn = min(mn, d[i].t), res += d[i].w * mn;
    
    cout << res << '\n';
    
    return 0;
}
```

---

## 作者：Lawrenceling (赞：3)

## 前言
华风夏韵，洛水天依！

~~这题有原题，还跟我们集训时的一道题很像~~。
## 思路
考虑贪心。

注意到如果 $w_i$ 是负数，则一定尽量让其的天数贴在前一天，反之则将天数“拉满”。比如下图：

则可以对 $t$ 做后缀最小值（因为要满足天数单调），如果过程中后缀的 $w$ 非负，则直接将这几天的天数拉满（最大天数即后缀 $t$ 中的最小值），也可以用后缀和优化。


## AC CODE

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=1e6+10;
int n,t[N],ans;
int s[N],w[N];

signed main()
{
	cin>>n;
	t[n+1]=9e18;
	for(int i=1;i<=n;++i)cin>>t[i];
	for(int i=1;i<=n;++i)cin>>w[i];
	
	for(int i=n;i>=1;--i)t[i]=min(t[i+1],t[i]);
	for(int i=n;i>=1;--i)s[i]=s[i+1]+w[i];
	
	int ans=0,sum=0; 
	for(int i=n;i>=1;--i)
	{
		sum+=w[i];
		if(sum>0)
		{
			ans+=t[i]*sum;//后缀最小值 
			sum=0;
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：_parsley_ (赞：2)

因为 $t_i$ 单调不降，所以 $t_i > t_{i+1}$ 的部分是不能也不会被使用的，从后往前将 $t_i$ 改成 $\min({t_i,t_{i+1})}$。

若第 $x$ 天练习了 $k$ 此，则之后的所有天也都至少练 $k$ 次，因此对 $w_i$ 求后缀和 $suf_i$。

可以观察到，若 $suf_i \leq suf_{i+1}$，$i$ 一定比 $i+1$ 不优，因为有 $t_i \leq t_{i+1}$，完全可以将 $i$ 新增的练习次数全部调整到 $i+1$。 

对 $suf_i$ 维护一个单调栈（递减）即可。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int M=1e6+5;
int n,m,t[M],suf[M],w[M],sum,ans;
int stk[M],top;
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>t[i];
	for(int i=1;i<=n;i++)cin>>w[i];
	suf[n]=w[n];
	for(int i=n-1;i;i--){
		t[i]=min(t[i],t[i+1]);
		suf[i]=suf[i+1]+w[i];
	}
	for(int i=1;i<=n;i++){
		while(top&&suf[stk[top]]<=suf[i])top--;
		stk[++top]=i;
	}
	for(int i=1;i<=top;i++){
		if(suf[stk[i]]<=0)break;
		ans+=(t[stk[i]]-sum)*suf[stk[i]];
		sum=t[stk[i]];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Nailoong_SHM (赞：1)

# 题解：P11769 歌唱练习
想了好久，总结一下，力求通俗易懂。
## 贪心思路
### 1. 考虑转移方向并构造时间序列
前面的决策肯定会影响后面的选择，因为一定要满足**单调不降**，如果从前往后构造满足条件，那么如果遇到一个小的就完了。所以考虑从后往前构造最多的练习时间。

很显然，必须满足单调不降，那么从后往前构造一定是取**后缀最小值**，这样一定能保证从当前点到最后是单调递减的且可以最大化每天的练习时间。

### 2. 求出最大贡献
秉承着一个原则：**正数越多越好，负数越少越好**。
很容易想到一个思路，从前往后枚举，如果是正数就取时间的最大值，如果是负数就取与前面的相同的时间达到满足单调不降且负数最少（**并不是最少的！等会儿会解释**）。写完发现喜提零分。

这是为什么呢？看着挺对的啊？重新考虑我们需要的，**正数越多越好，负数越少越好**这个原则一定是对的，那么说明我们的思路并不能保证负数最少。

举个例子，下方第一行是构造出的时间序列，第二行是 $w_i$。
```
1  2  3     4  5
1  2  -100  4  5
```
在这个例子中，很明显最优的方案是前面三天都不练习，时间为 $0$，这是最优的方案。

举出了反例，那么重新构造思路，不能构造出负数最小，那么就构造出正数最大，考虑样例与刚才举的例子。

:::info[解释样例]
为什么样例取了负数？因为这个负数与后面的可以组成一段非负的贡献。
:::
:::info[解释上面的例子]
为什么不取这个负数？因为这个负数与后面的不能组成一段非负贡献的区间。
:::

这样就可以构造出最终的思路，从后往前构造，每次找到最短且连续的非负贡献区间，把原来的序列分成若干个贡献非负的区间，时间就取当中最小的，如果最后的一个区间的贡献仍未负数，那么干脆舍弃。

## 代码
比较简单，代码就不加注释了（别忘记开长整型）。
```cpp line-numbers
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int t[1000010];
int w[1000010];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&t[i]);
	for(int i=1;i<=n;i++){
		scanf("%lld",&w[i]);
		w[i]+=w[i-1];
	}
	for(int i=n-1;i>=1;i--){
		t[i]=min(t[i],t[i+1]);
	}
	int last=n;
	int ans=0;
	for(int i=n;i>=1;i--){
		if(w[last]-w[i-1]>=0){
			ans+=t[i]*(w[last]-w[i-1]);
			last=i-1;
		}
	}
	printf("%lld",ans);
	return 0;
}

```

---

## 作者：D_Chloroplast (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11769)
## Step1：简化题意
有两组数列 ${t_i}$ 和 ${w_i}$ ， ${t_i}$ 恒为非负而 ${w_i}$ 可能小于零。现在需要构造单调增数列 ${a_i}$ ，使 ${a_i}\le{t_i}$ 且 $\sum_{k = 1}^{n} {a_i}{w_i}$ 最大。
## Step2：思路梳理
本题可以采用贪心的思路解决。（~~当然标签里也写了~~）

我们发现，依照天数从前往后贪心并不一定能达到最优解，因为在枚举第 ${i}$ 天的时候，我们还不了解第 ${i+1}$ 到 ${n}$ 天的情况，无法作出最有判断。

所以，自然可以想到——

**倒！着！贪！心！**

（为什么？因为如果第 ${i+1}$ 到 ${n}$ 天已经确定，此时第 ${i}$ 天的练习时长也有具体范围。）
## Step3：具体分析
开始时最长时长显然等于 ${t_n}$ （我们记为$tmp$ ），随后对于每一天都有三种情况：

1. ${w_i} = 0$，这时候不管练习多久不会对答案产生影响，所以只需更新 $tmp$ 。（记得要更新！不然subtask#5和#8过不了）
2.  ${w_i} > 0$ ，直接贪心，更新完 $tmp$ 后加到答案里就行。
3.  ${w_i} < 0$ ，有点复杂的情况，举个栗子可能会清楚一点：
   考察 ${t_i}={1,2,3,4}$ ，同时 ${w_i}={3,2,1,-2}$ ，~~暴力枚举~~发现取 ${a_i}={1,2,2,2}$ 时最优解。即向前累加 ${w_i}$ （将这几天“捆绑”在一起，以采用 ${w_i} > 0$ 的思路解题），同时不断更新 $tmp$ ，直至 $\sum{w_i} > 0$ 为止。而若一直累加到第一天还有 ${w_i} \le 0 $ 则这几天都取 ${a_i} = 0$ 即可（否则会加入负的练习效果）。
*为什么累加到 $\sum{w_i} > 0$ 就立刻停止？因为根据贪心的解题思路， $\sum{w_i} > 0$ 的每时每刻都应当采用最长的 $tmp$ 。例如栗子中如果不及时停止，使第一天的情况也被考虑在内，那么得出的结论就是 ${a_i}={1,1,1,1}$ ，不是最优解。

## Step4：最终代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int i,j,n;
	long long t[1000001]={},w[1000001]={},tmp,tmp2,ans=0;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>t[i];
	}
	for(i=1;i<=n;i++)
	{
		cin>>w[i];
	}
	tmp=t[n];//tmp表示截至目前可以练习的最长时长 
	for(i=n;i>=1;i--)
	{
		if(w[i]==0)
		{
			if(t[i]<tmp) tmp=t[i];//对练习效果为0的情况，只更新时长就行 
			continue;
		}
		if(w[i]>0)//练习效果大于0，直接贪心练习最长时长 
		{
			if(t[i]<tmp) tmp=t[i];
			ans+=w[i]*tmp;
		}
		if(w[i]<0)
		{
			tmp2=0;
			for(j=i;j>=1;j--)
			{
				if(t[j]<tmp) tmp=t[j];//随时更新时长 
				tmp2+=w[j];//tmp2记录目前积累的练习效果 
				if(tmp2>0) break;//及时打住 
			}
			if(!j) break;//如果j=0，说明tmp2一直到第一天还未大于0，这几天都不练习是最优解 
			ans+=tmp2*tmp;
			i=j;//更新目前位置 
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

p.s.第一次写题解，还请大家多多指教

---

## 作者：albertting (赞：1)

### 分析

题意不难理解，挺字面的。

这个题是贪心，根据我们正难则反的原则，这里应该倒过来跑。因为有负贡献，我们可以把它向前合并，把两个一起算。

设当前练习日（负贡献的）和前一天时间分别为 $t$ 和 $t_p$，贡献分别为 $w$ 和 $w_p$。

那么，两天的总贡献为：
$$
t \times w + \min\{t, t_p\} \times w_p
$$
由题意得：$t \ge t_p$

且 $w < 0$

所以易得在 $t = t_p$ 时，原式取得最大值为：
$$
\min\{t, t_p\} \times (w + w_p)
$$
但是呢，这里的时间不能比之后的日子练习时间长，所以设目前时间最小值为 $mint$ （欸怎么是薄荷），则原式最大值为：
$$
\min\{t, t_p, mint\} \times (w + w_p)
$$
那么，只要用这个式子一直往前推，计算 $w$ 的后缀和直到总贡献为正时，再照贡献为正的情况来算就是最优情况力。

哦对了，贡献为正时，计算方式为：
$$
\min\{t, mint\} \times w
$$
剩下小的事项在代码里标出来力。

### Code!

```cpp
// Author: albertting
// Time: 2025/06/26 20:35:22
#include <bits/stdc++.h>
#define __Made return
#define in 0
#define China__ ;
using namespace std;

int n;
int t[1000005], w[1000005];

void init() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    for(int i = 1; i <= n; i++) cin >> t[i];
    for(int i = 1; i <= n; i++) cin >> w[i];
}

void solve() {
    long long ans = 0; // 十年 OI 一场空
    int mint = 1e9 + 1;
    for(int i = n; i >= 1; i--) {
        if(w[i] < 0) {
            w[i - 1] += w[i];
            t[i - 1] = min(t[i - 1], t[i]);
        } else {
            mint = min(mint, t[i]); // 这里要更新吼
            ans += 1ll * w[i] * mint;
        }
    }
    cout << ans;
}

int main() {
    init();
    solve();
    __Made in China__
}
```

---

## 作者：bianshiyang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11769)

好像和其他题解的写法和思考方式都有些不同。

# 分析
我们会发现最终的贡献形如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gprsal9o.png)

横坐标表示第几天，纵坐标表示 $t_i$（这里的 $t_i$ 表示第 $i$ 天所练习的时间，与题面有出入请读者注意），那么我们每钦定一个 $t_i$ 实际上就是增加了一个矩形的贡献（矩形指就是图中不同颜色的矩形）。我们定义矩形的长为矩形所覆盖的天数的 $w$ 之和，而矩形的宽为这几天共同的 $t$ 与上一个矩形的 $t$ 的差值，为了简便，我们这里假设可以出现长小于宽的情况。

我们从小到大扫描每一个 $i$，贪心的判断在 $i$ 这个位置是沿用 $t_{i-1}$ 还是增加一些时间变成 $t_i$（$t_i>t_{i-1}$）。我们直接思考加入的这个矩形满不满足**局部最优能推出全局最优**，一个很显然的想法就是既然矩形的宽 $t_i-t_{i-1}>0$，那么若矩形的长为正则尽可能地增大 $t_i$ 为限制的后缀最小值，否则沿用 $t_i=t_{i-1}$。

这想法似乎很对，但其实这种写法交上去几乎对不了几个点。原因出在虽然此时满足局部最优解，但是这里的决策可能会对后面的决策产生影响，做不到全局最优。假设对于一个矩形来说，如果我们割去其一段前缀能够使得答案更优，注意一定不会只割去一个角，因为矩形的正负只由长决定，如果割去的部分的长为正那么没必要割去，否则全割去一定更优，那么我们可能在之前做了错误的决策导致答案变差。

![](https://cdn.luogu.com.cn/upload/image_hosting/nx9011j8.png)

比如上图中我们在考虑黄色矩形的时候有可能按照错误的贪心策略在 $i$ 位置就加上了黄色矩形的贡献，而如果绿色矩形的贡献为负，且最优解是在 $j$ 处加上更优，那么我们之前的做法就错了。不过实际上只需要在判断矩形长的正负同时判断此处矩形的长是否为后缀最大值即可（这里的后缀最大值指的是从此位置开始以及之后的所有后缀的矩形长的最大值）。

这里的贪心策略可以使用决策包容性证明。设想，如果我们在 $i$ 位置需要增加一个矩形，想必一定会将矩形的宽增加到题目所给的限制的后缀最小值处（即越大越好但是不能超过限制），如果矩形长的后缀最大值不在 $i$ 处出现，那么考虑后缀最大值出现的位置 $j$，必然满足 $j$ 位置的矩形宽的限制不小于 $i$ 位置，所以在 $j$ 位置增加一个矩形所产生的贡献一定不劣于在 $i$ 处增加一个矩形。所以在后缀最大值处增加一个矩形一定不劣于在之前的某个位置增加矩形。

这里的后缀最大、最小值大家可能有点懵，建议结合代码阅读和注释更好理解。

# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+10;
  int n,t[N],w[N],minn[N];//minn就是后缀时间最小值，可以理解为矩形宽的限制
ll s[N],maxx[N],ans;//s表示后缀长度，maxx表示矩形长的后缀最大值
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&t[i]);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	minn[n+1]=2e9;maxx[n+1]=-1e18;
	for(int i=n;i;i--)
	{
		minn[i]=min(minn[i+1],t[i]);
		s[i]=s[i+1]+w[i];
		maxx[i]=max(maxx[i+1],s[i]);
	}//预处理
	for(int i=1,nn=0;i<=n;i++)
		if(s[i]>0&&maxx[i]==s[i]) ans+=1ll*(minn[i]-nn)*s[i],nn=minn[i];//矩形长为正且在后缀最大值处时才增加矩形，nn就是上一个矩形的上边界，minn[i]是新矩形所能增加的宽度的上限，把它作为新矩形的上边界
	printf("%lld\n",ans);
	return 0;
}
```

---


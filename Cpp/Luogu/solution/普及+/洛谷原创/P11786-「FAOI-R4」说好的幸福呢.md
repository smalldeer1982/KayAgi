# 「FAOI-R4」说好的幸福呢

## 题目背景

**UPD：数据已加强。**


------------


![](bilibili:BV1fx411N7bU?page=111)

## 题目描述

小 M 有一个长度为 $n$ 的排列 $a$。

对于一个长度为 $k$ 的序列 $b$，小 M 可以执行以下操作：
- 选择一个满足 $1\leq i\leq k$ 的位置 $i$，将序列变为 $[b_i,b_{i+1},\cdots,b_{k},b_{1},b_{2},\cdots,b_{i-2},b_{i-1}]$。也就是说，将 $b$ 的一个后缀移到开头。

定义序列 $b$ 的价值 $f(b)$ 为「将 $b$ 变成严格上升序列的最小操作数」。若无法通过操作变成严格上升序列，则 $f(b)=0$。

你需要求出 $\sum\limits_{l=1}^{n}\sum\limits_{r=l}^{n}f([a_{l},a_{l+1},\cdots,a_{r-1},a_{r}])$，即 $a$ 中所有子串的价值之和。

## 说明/提示

#### 【样例解释】

对于第三组样例：区间 $[1,1],[2,2]$ 已经是严格上升序列，不需要操作。而对于区间 $[1,2]$，选择 $i=2$ 即可将其变为严格上升序列。故答案为 $0+0+1=1$。

对于第六组样例：区间 $[1,2]$ 可以通过一次 $i=2$ 的操作变为严格上升序列，而对于区间 $[1,3]$，可以证明无论如何操作都无法将其排序。

#### 【数据范围与约定】

**本题开启子任务捆绑测试。**

- Subtask 1（15 pts）：$n\leq10$，$\sum n\leq20$。
- Subtask 2（35 pts）：$n\leq10^3$，$\sum n\leq10^4$。
- Subtask 3（30 pts）：$n\leq10^5$，$\sum n\leq5\times10^5$。
- Subtask 4（20 pts）：无特殊限制。

对于所有数据，保证 $1\leq T\leq10^5$，$1\leq n\leq5\times10^6$，$\sum n\leq10^7$。

#### 【提示】

本题输入量略大，你可以在程序的开头加上 `std::cin.tie(0)->sync_with_stdio(0)`，并使用 `std::cin` 来读入，保证可以在 600ms 内读入所有数据。可以参考以下程序：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e6 + 1;
long long T, n, ans, a[N];
int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> T;
	while (T --) {
		cin >> n;
		for (int i = 1; i <= n; i ++)
			cin >> a[i];
		// compute the answer
		cout << ans << '\n';
	}
	return 0;
}
```

## 样例 #1

### 输入

```
12
1
1
2
1 2
2
2 1
3
1 2 3
3
1 3 2
3
2 1 3
3
2 3 1
3
3 1 2
3
3 2 1
6
1 2 5 6 3 4
9
9 8 7 6 5 4 3 2 1
12
1 2 3 4 5 6 7 8 9 10 11 12
```

### 输出

```
0
0
1
0
1
1
2
2
2
4
8
0```

# 题解

## 作者：喵仔牛奶 (赞：10)

## Solution

我们可以发现操作多次等于操作一次，考虑然后求出需要恰好一次操作的区间个数。

将序列划分为若干个极长上升子段，也就是说从 $a_i>a_{i+1}$ 处断开。

考虑区间 $[l,r]$ 需要恰好一次操作的条件：
- 恰好在两个子段内。因为在一个子段内无需操作，而在三个子段内无法将其排序。
- $a_l>a_r$，否则无法排序。

枚举所有子段 $x$，我们需要对所有 $x$ 中的下标 $i$ 求出有多少在子段 $x-1$ 中的下标 $j$ 满足 $a_j>a_i$。由于子段内单调递增，使用双指针法，从左往右扫描 $i$，维护最小的满足 $a_j>a_i$ 的 $j$，若 $a_j<a_i$ 一直 $j\gets j+1$ 即可。

## Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 5e6 + 5;
	LL n, rs, a[N]; vector<pii> s;
	int main() {
		cin >> n, rs = 0, s.clear();
		REP(i, 1, n) cin >> a[i];
		REP(i, 1, n) {
			int p = i;
			while (p < n && a[p] < a[p + 1]) p ++;
			s.pb(i, p), i = p;
		}
		REP(x, 1, SZ(s) - 1) {
			auto [l, r] = s[x - 1];
			int p = l;
			REP(i, s[x].fi, s[x].se) {
				while (p <= r && a[p] < a[i]) p ++;
				rs += r - p + 1;
			}
		}
		cout << rs << '\n';
		return 0;
	}
}
```

---

## 作者：穼柗° (赞：3)

提供一篇详细严谨且不用双指针的题解。

注意到：如果存在一个形如 $ABC$ 的序列，并操作了两次：$ABC\rarr CAB\rarr BCA$，显然可以一次性把 $BC$ 移到前面：$ABC\rarr BCA$，也就是说 $x$ 次操作可以变为 $x-1$ 操作，因此最小操作数一定不大于 $1$。

所以，如果一个不严格上升的序列可以通过操作变为严格上升序列，那一次操作就能完成，此时它是由两个严格上升序列组成的。

以上得出一个结论：**如果一个序列不严格上升，那么“它首项大于末项并且由两个严格上升序列构成”与“它操作一次就能严格上升”互为充要条件**。

不妨设 $dp_i$ 表示以第 $i$ 个位置结尾的严格上升子序列的最长长度，显然有 $dp_1=1$。而对于 $2\le i\le n$，有
$$$
dp_i=\begin{cases}
dp_{i-1}+1,a_{i-1}<a_i\\
1,a_{i-1}\ge a_i
\end{cases}
$$$

看到题目中的式子，
$$$
\sum\limits_{l=1}^{n}\sum\limits_{r=l}^{n}f([a_{l},a_{l+1},\cdots,a_{r-1},a_{r}])
$$$
变一下形，
$$$
\sum\limits_{r=1}^{n}\sum\limits_{l=1}^{r}f([a_{l},a_{l+1},\cdots,a_{r-1},a_{r}])
$$$
也就是说，可以先枚举子串的右端点，再看下有几个对答案有贡献的左端点。假设枚举的右端点是 $i$，如果对答案有贡献，那这一段是由正好两个严格上升序列构成的不严格上升序列。

根据上面 $dp_i$ 的定义，靠后的严格上升序列的位置是确定的 $[i-dp_i+1,i]$，所以可以找有多少个以 $i-dp_i$ 结尾的严格上升子串。显然，它的左端点在区间 $[i-dp_i-dp_{i-dp_i}+1,i-dp_i]$ 内（不然就不是刚好两个严格上升序列了）。然后注意到：序列 $\{a_n\}$ 在区间 $[i-dp_i-dp_{i-dp_i}+1,i-dp_i]$ 内严格上升。所以可以在这个区间内二分出最左的左端点 $pos$ 满足 $a_{pos}>a_i$，（确保标粗结论的“它首项大于末项”成立）。

最坏时间复杂度 $O(n\log n)$，但是因为二分的区间 $[i-dp_i-dp_{i-dp_i}+1,i-dp_i]$ 不会特别长，所以 “$\log n$” 对应的数不会大到哪，能过。

核心代码
```cpp
long long ans=0;
for(int i=1;i<=n;i++) {
	dp[i]=(a[i-1]<a[i])*dp[i-1]+1;
	if(i<=dp[i]) continue;
	const int pos=upper_bound(a+(i-dp[i]-dp[i-dp[i]]+1),a+(i-dp[i]+1),a[i])-a;
    if(pos==i) continue;
	ans+=i-dp[i]-pos+1;
}
```
一共有 $\frac{n(n+1)}{2}$ 个子串，是有可能[爆 `int`](https://www.luogu.com.cn/record/218938588) 的。

---

## 作者：沉石鱼惊旋 (赞：3)

一个必要的观察（当然也可以通过手玩样例得出来）：一个序列能被这样操作为有序，那么最少步数一定是操作一次。

考虑操作两次的时候，选出的两个区间在原序列的情况。

$[b_i,b_{i+1},\cdots,b_{k},b_{1},b_{2},\cdots,b_{i-2},b_{i-1}]$

假定这是操作一次的序列。设我们这次选择的是 $j$。

那么一种可能是 $b_j$ 在 $[b_i,b_{i+1},\cdots,b_{k}]$ 之间。这个情况，我们操作两次结果是 $[b_{j},b_{j+1},\dots,b_k,b_{1},b_{2},\cdots,b_{i-2},b_{i-1},b_i,b_{i+1},\cdots,b_{j-1}]$。那么这可以直接由选择一次 $j$ 得到。

还有一种是 $b_j$ 在 $[b_{1},b_{2},\cdots,b_{i-2},b_{i-1}]$ 之间。个情况，我们操作两次结果是 $[b_j,b_{j+1},\cdots,b_{i-2},b_{i-1},b_i,b_{i+1},\cdots,b_{k},b_{1},b_{2},\dots,b_{j-1}]$。那么这仍然可以直接由选择一次 $j$ 得到。

同理我们可以说明任意两次操作一定可以转化为一次操作，那么任意多次操作则一定可以转化为一步操作。

样例给的太充足了，其实手玩样例就能看出来了。

用一次操作能排好序则当且仅当是两段上升的子串拼接而成。如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/8gac9un6.png)

红线用来分割序列的位置的前后，绿线用来分割 $a_i$ 的值的大小。黑色斜线表示连接 $a_{i-1}\to a_i$ 形成的线段。

我们不妨枚举这个交界点，也就是红线的位置。

对于在 $i+0.5$ 的每条红线，令左端点 $l=i$，先找到最右侧的 $r$ 满足 $a_{l+1}\lt a_{l+2}\lt \dots \lt a_r\lt \color{red}{a_l}$。那么对于所有的 $l\lt r'\lt r$，$[l,r']$ 都会产生 $1$ 的贡献。总计产生 $r-i$ 的贡献。

之后我们从大往小移动 $l$，发现随着 $l$ 往左移动，$r$ 也一定会往左移动。那么用双指针维护 $l,r$。每次移动到极长区间（也就是停止移动）时则会有 $r-i$ 的贡献。注意双指针的时候还要保证 $a_r\lt a_l$。

这个做法实际是 $\mathcal O(n)$ 的。注意红线只会在 $a_i\gt a_{i+1}$ 的地方出现。我们称图中这样的两条黑线被红线支配了。那么每一段黑线左右都会有两条红线支配他，每一段黑线只会有 $l$ 和 $r$ 各扫描一次。因此时间复杂度 $\mathcal O(n)$。

<https://www.luogu.com.cn/record/204321523>

```cpp
#include <bits/stdc++.h>
using namespace std;
#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++
char buf[1000000], *p1 = buf, *p2 = buf;
template <typename T>
void read(T &x)
{
    x = 0;
    int f = 1;
    char c = getchar();
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-')
            f = -f;
    for (; c >= '0' && c <= '9'; c = getchar())
        x = x * 10 + c - '0';
    x *= f;
}
template <typename T, typename... Args>
void read(T &x, Args &...y)
{
    read(x);
    read(y...);
}
template <class T>
void write(T x)
{
    static int stk[30];
    if (x < 0)
        putchar('-'), x = -x;
    int top = 0;
    do
    {
        stk[top++] = x % 10, x /= 10;
    } while (x);
    while (top)
        putchar(stk[--top] + '0');
}
template <class T>
void write(T x, char lastChar) { write(x), putchar(lastChar); }
typedef long long ll;
void solve()
{
    int n;
    read(n);
    int a[n + 1];
    for (int i = 1; i <= n; i++)
        read(a[i]);
    ll ans = 0;
    for (int i = 1; i < n; i++)
    {
        if (a[i] <= a[i + 1])
            continue;
        int l = i, r = i + 1;
        while (r + 1 <= n && a[r] <= a[r + 1] && a[r + 1] < a[l])
            r++;
        ans += r - i;
        while (l >= 2)
        {
            l--;
            if (a[l] > a[l + 1])
                break;
            while (r >= i + 1 && a[r] >= a[l])
                r--;
            ans += r - i;
            if (r == i)
                break;
        }
        // cout << i << ' ' << ans << '\n';
    }
    cout << ans << '\n';
}
int main()
{
    int t;
    cin >> t;
    while (t--)
        solve();
    return 0;
}
```

---

## 作者：niuzh (赞：2)

~~貌似是不一样的做法，并且简单好想。~~

#### 思路

显然，一个子序列的价值只能是 $0$ 或 $1$。

价值是 $1$ 的子序列只可能是两个严格上升子序列连起来，其中第二个序列的末项比第一个序列的首项要小。

考虑数组 $a$ 分割成几段相邻的严格上升子序列，再对于相邻两个序列中第二个序列里的每个前缀，在第一个序列里找到可以与其连接构成价值为 $1$ 的子序列个数，就是在第一个子序列中比第二个子序列当前前缀的最后一个数（是最大的）要大的数的数量（把它俩之间连起来一定可行）。

又因为序列都是严格上升的，所以可以用二分寻找。

用第 $10$ 个样例举例：

把 $1,2,5,6,3,4$ 分割成 $(1,2,5,6),(3,4)$，对于 $3$ 可以将 $(1,2,5,6)$ 中后两位与后一位与 $3$ 组成价值为 $1$ 的子序列，分别是 $5,6,3$ 与 $6,3$，对于 $4$，同样是后两位与后一位，分别是 $5,6,3,4$ 与 $6,3,4$。

#### 代码


```cpp
/*
 * @FilePath: test.cpp
 * @Author: niu-zh
 */
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e6+10;
int a[N];
struct node
{
	int l,r;
}v[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	while(T--)
	{
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		int idx=0;
		v[idx].l=1;
		v[idx].r=1;
		for(int i=2;i<=n;i++)
		{
			if(a[i]>a[i-1])
			{
				v[idx].r=i;
			}
			else
			{
				v[++idx].l=i;
				v[idx].r=i;
			}
		}
		int ans=0;
		for(int i=1;i<=idx;i++)
		{
			for(int j=v[i].l;j<=v[i].r;j++)
			{
				if(a[j]>=a[v[i-1].r])
				{
					break;
				}
				ans+=v[i-1].r-(lower_bound(a+v[i-1].l,a+v[i-1].r,a[j])-a)+1;
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：UKE_Piu (赞：2)

对于题目中的总价值，不难看出共有三种贡献：

1. 子串 $s$ 本身就是严格上升序列，无需操作，贡献为 $0$。
2. 子串 $s$ 不能经过操作变为严格上升序列，贡献为 $0$。
3. 子串 $s$ 可以经过操作变为严格上升序列，贡献为 $f(s)$。

那么什么样的串可以经过操作变为严格上升序列呢？我们来分析一下题目中的操作。


分两种情况讨论：

1. $s$ 是由两个严格上升序列组成的。则当前 $s$ 中所有元素的排名有两部分是连续的。设前一个序列为 $s_1$，后一个为 $s_2$。若 $s_1$ 的最小值大于 $s_2$ 的最大值，即 $s_1$ 所有元素的排名都大于 $s_2$，则可以通过一次操作将 $s$ 变为严格上升序列，$f(s)=1$，否则 $f(s)=0$。
2. $s$ 是多个严格上升序列组成的。设 $s$ 是由 $m$ 个严格上升序列组成，这 $m$ 个序列分别为 $s_1,s_2,\cdots,s_m$。若 $s$ 最后可以变为严格上升序列，则 $s_m+s_1+s_2+\cdots+s_m$ 满足情况 $1$，即 $s_m$ 的最小值大于 $s_{m-1}$ 的最大值，所以 $s_{m-1}+s_m$ 也是一个严格上升序列，这与 $s_{m-1}+s_m$ 不是严格上升序列的条件不符。所以此时 $s$ 不能通过操作变为严格上升序列。

综上所述，**$s$ 能经过操作变为严格上升序列当且仅当 $s$ 是由两个严格上升序列组成的，且前一个严格上升序列的最小值大于后一个严格上升序列的最大值。**

现在进行统计即可。这种统计的方式类似于归并排序求逆序对的思路：

遍历 $a$ 中的第 $i$ 个严格上升序列时：
设当前遍历下标为 $j$，第 $i$个严格上升序列的起始下标为 $b_i$，我们需要在第 $i+1$ 个严格上升序列中找到一个最大的 $k$，使得 $a_k < a_j$。

易知：$[a_j,a_{j+1},\cdots,a_{b_{i+1}-1}]$ 与 $[a_{b_{i+1}},a_{b_{i+1}+1},\cdots,a_k]$ 可以构成情况 $1$。

因为 $[a_{b_{i+1}},a_{b_{i+1}+1},\cdots,a_k]$ 是一个严格上升序列，这个序列中 $a_k$ 之前的元素都小于 $a_k$，所以共有 $k-b_{i+1}$ 个可能的子段可以与 $[a_j,a_{j+1},\cdots,a_{b_{i+1}-1}]$ 构成情况 $1$。

找 $k$ 的操作其实就是一个二分。

完整代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,m;
const int N=5e6+6;
int a[N],b[N];
// b[i]: {i+1}-th LIS's begin inedx
void solve(){
	cin>>n;
	m=0;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) if(a[i-1]>a[i]) b[++m]=i;
	if(m==0) cout<<"0\n";
	else {
		int ans=0;
		b[0]=1; b[m+1]=n+1;
		for(int i=1;i<=m;i++){
			for(int j=b[i-1];j<b[i];j++){
				int k=lower_bound(a+b[i],a+b[i+1],a[j])-a;
				if(a[j]<a[b[i+1]-1]&&k==b[i+1]) continue;  // out of range
				ans+=k-b[i];
			}
		}
		cout<<ans<<'\n';
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：Getaway_Car_follower (赞：2)

赛时 10min 场切了。

我们注意到 $f([b_1,b_2,b_3,\cdots,b_k])$ 最多为 $1$。因为假如我们位移了两次，可以合并为位移一次。

那么我们不妨把 $a$ 分为 $k$ 段递增的「块」，第 $i$ 段为 $[l_i,r_i]$。

求一段内部贡献是容易的，那么我们就要看两段之间的贡献。

我们注意到，$f(b)$ 为 $1$ **当且仅当**存在一个 $i$ 满足 $b_{1\sim i}$ 递增且 $b_{i\sim  k}$ 递增。同时 $b_k<b_1$。

那么我们就发现，对于一个 $k\in [l_j,r_j]$，所有 $i\in[l_{j+1},r_{j+1}]$ 且 $a_i<a_k$ 的 $i$ 都可以产生贡献。

这个东西双指针很好求，那么就好了。

时间复杂度 $O(n)$，不带 $\log$ 所以 [容易通过](https://www.luogu.com.cn/record/211984865)。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>

const int N=5e6+5;
int T,n,a[N];
vector<pii> v;

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>T;while(T--){
		v.clear();
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		int lst=0,l=1;
		for(int i=1;i<=n;i++){
			if(a[i]>lst) lst=a[i];
			else{
				lst=a[i];
				v.push_back({l,i-1});
				l=i;
			}
		}
		v.push_back({l,n});
		pii ls=v.front();
		int ans=0;
		for(pii i:v){
			if(i==ls) continue;
			for(int l1=ls.first,l2=i.first;l1<=ls.second&&l2<=i.second;l2++){
				while(a[l1]<a[l2]&&l1<ls.second){
					l1++;
				}
				if(a[l1]>a[l2]) ans+=ls.second-l1+1;
			}
			ls=i;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：CaiZi (赞：1)

首先我们发现，多次将序列 $b$ 的一个后缀移到开头，可以合并成一次将序列 $b$ 的一个后缀移到开头，这是显然的，因此 $f(b)$ 只能为 $0$ 或 $1$。

考虑将序列 $a$ 划分成若干个极长上升子段。然后我们可以发现，若 $f([a_l,a_{l+1},\cdots,a_{r-1},a_r])=1$，则：
- $l,r$ 不可能在同一个极长上升子段内，否则 $i$ 不可能存在（将一个后缀前移后肯定不会保持上升）。且 $l,r$ 所在的极长上升子段间不能有其他极长上升子段，因为进行操作最多只能将一处 $l\le p<r,a_p>a_{p+1}$ 消除，而此时有至少两处 $a_p>a_{p+1}$。所以我们得出结论，**$l,r$ 所在的极长上升子串相邻**。
- 由上一点，由于操作后 $a_r$ 将会被移动到 $a_l$ 前一位，因此我们还需要保证 $a_l>a_r$。

考虑枚举每两个相邻的极长上升子段，设这两个子段分别为 $[x,y],[y+1,z]$，我们需要求出 $l\in[x,y],r\in[y+1,z],a_l>a_r$ 的个数。由于 $a_x\sim a_y,a_{y+1}\sim a_z$ 均严格上升，枚举 $r$，并且利用双指针求出最小的 $l$ 即可。

时间复杂度 $O(\sum n)$。

注意这题是需要开 `long long` 的，我们构造序列 $[\frac{n}{2}+1,\frac{n}{2}+2,\cdots,n-1,n,1,2,\cdots,\frac{n}{2}-1,\frac{n}{2}]$（$n$ 为偶数），答案将会是 $\frac{n^2}{4}$。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[5010501],s;
vector<pair<int,int>>g;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>t;
	while(t--){
		cin>>n;
		g.clear();
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		s=a[n+1]=0;
		for(int i=1,j=1;i<=n;i++,j++){
			while(j<=n&&a[j]<=a[j+1]){
				j++;
			}
			g.emplace_back(i,j);
			i=j;
		}
		for(int k=1;k<=(int)(g.size())-1;k++){
			int i=g[k-1].first;
			for(int j=g[k].first;j<=g[k].second;j++){
				while(i<=g[k-1].second&&a[i]<=a[j]){
					i++;
				}
				s+=g[k-1].second-i+1;
			}
		}
		cout<<s<<'\n';
	}
	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：0)

下面是本人赛时的思考逻辑：

容易发现，对于每个子序列，只能操作一次或零次。

则对于所有 $a_i>a_{i+1}$ 的下标 $i$，需要找出所有所有段 $[l,r]$，使得区间 $[l,i]$ 与区间 $[i+1,r]$ 都单调递增，且 $a_r<a_l$。

我们可以枚举每一个 $a_i>a_{i+1}$ 的下标 $i$，并枚举区间的左端点，使用双指针法求出右端点的取值范围，使得区间内只有一个 $a_i>a_{i+1}$ 的下标 $i$。

由于我们已经计算过所有 $a_i>a_{i+1}$ 的下标 $i$，所以可以简单地计算出对于 $a_i>a_{i+1}$ 的下标 $i$，使得区间 $[l,i]$ 与区间 $[i+1,r]$ 都单调递增时，$l$ 和 $r$ 的取值范围。

则具体实现思路如下：

计算所有 $a_i>a_{i+1}$ 的下标 $i$，下面我们把所有 $i$ 称之为“断点”，并令第 $i$ 个断点为 $d_i$。

所以可以保证对于 $d_i$，$[d_{i-1}+1,d_i]$ 单调递增， $[d_i+1,d_{i+1}]$ 单调递增。

则对于刚好可以操作一次的区间 $[l,r]$，$l$ 可以在 $[d_{i-1}+1,d_i]$ 间任意取一个数，$r$ 则通过双指针法求有多少个 $r$ 满足要求，答案 $+r$ 即可。

写得有点啰嗦，可能是因为当时的思路有点忘记了。

下面是小号的赛时代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t;
int n;
int a[5000005];
int d[5000005],cnt;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>t;
    while(t--){
        cin>>n;
        cnt=0;
        for(int i=1;i<=n;i++)cin>>a[i];
        d[0]=0;
        a[n+1]=0;
        for(int i=1;i<=n;i++){
            if(a[i+1]<a[i])d[++cnt]=i;
        }int ans=0;
        for(int i=1;i<cnt;i++){
            int lt=d[i],rt=d[i+1];
            for(int j=lt;j>d[i-1];j--){
                while(rt>d[i]&&a[rt]>a[j]){
                    rt--;
                }ans+=(rt-d[i]);
            }
        }cout<<ans<<"\n";
    }
    return 0;
}
```

最后一个小小的坑是注意清空，如果你所有子任务都是最后一个点错了。

---

## 作者：MPLN (赞：0)

## 思路

找规律题，简单题简单写，这里详细讲讲思路。

发现操作多少次都可以用一次来代替，于是得到两个性质：

1.  $0\le f(a)\le 1$
2.  对于一个序列 $a$ ，当且仅当其**非一个单调上升序列**，且**由 2 个单调上升序列拼接而成**时，$f(a)=1$ 。

下文 “上升子串” 均指自某位置开始的最长上升串。

预处理出原序列每个位置开始的上升子串长度，即可得到以任意一个位置开始的上升子串结尾，和“下一串”的结尾。如：

$$
4,5,6,2,3,7,1\dots
$$

6 就是 4 开始的上升子串的结尾，3 就是“下一串”的结尾。为什么下一串到 3 结束而不是 7 ？因为下一串拼再本串前面之后应该形成一个上升序列。

根据性质 2 ，对于一个起点 $l$ ： $l$ 开始的上升子串结尾之后，“下一串”的结尾及之前的点 $r$ 都能和 $l$ 配对为序列的左右端点成为一个 $f$ 值为1的序列。

如：

$$
4,5,6\text{(本串结尾)},2,3\text{(“下一串”结尾)},7,1\dots
$$

对于起点 4 ，以 2 或 3 为右端点的序列都是最少操作次数为 1 的。

可以再多举几个例子想想。

## Code

预处理 / 求解都可以用双指针。

时间复杂度 $O(\sum n)$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t, n, a[5000010], llen[5000010], ans;
int nxt(int x) { return x + llen[x]; } // 返回下一个上升子串的起始索引
signed main() {
    scanf("%lld", &t);
    while (t--) {
        scanf("%lld", &n);
        for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
        // 初始化 + 边界条件
        ans = 0, llen[n + 1] = 0, a[n + 1] = INT_MAX;
        // 计算每个位置开始的上升子串长度
        for (int l = 1, r = 1; l <= n; l++) {
            while (r < n && (r < l || a[r + 1] > a[r])) r++;
            llen[l] = r - l + 1;
        }
        for (int l = 1, r = 1; l <= n; l++) {
            while (r < nxt(nxt(l)) - 1 && (r < nxt(l) || a[r + 1] < a[l])) r++;
            // 下一串截止到 r 都可以构成合法串
            if (a[r] < a[l]) ans += r - nxt(l) + 1;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---


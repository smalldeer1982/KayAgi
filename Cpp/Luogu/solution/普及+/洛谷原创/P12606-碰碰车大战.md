# 碰碰车大战

## 题目背景

[别样的碰碰车大战 2](https://www.luogu.com.cn/article/ne0xme6i)

## 题目描述

我原本以为我恐吓了肚子的，肚子的应该躲在机房，不敢找我，可正当这时，我听见了音乐声，原来是我洛谷私信响了，一看，竟然是构造 $k$ 个 $m$ 元组 $(x_{i,1},x_{i,2},\dots,x_{i,m})$，满足：

- 任意一个 $m$ 元组的任意一个元素均为 $[1,n]$ 中的整数；
- 任意两个 $m$ 元组删去相同位置的任意一对元素后得到的两个 $m-1$ 元组不相等，换句话说就是仍存在某一对位置相同的元素取值不相等。

形式化地，需要满足：

- $\forall 1\le i\le k,1\le j\le m,x_{i,j}\in [1,n] \cap \mathbb{Z^+}$；
- $\forall 1\le i<j\le k,1\le p\le m,\exists 1\le l\le m,l\neq p,x_{i,l}\neq x_{j,l}$。


## 说明/提示

本题输出规模巨大，推荐使用 I/O 优化。

本题采取子任务依赖，未通过当前子任务依赖的子任务会导致当前子任务得零分。

对于 $100\%$ 的数据，$1\le n\le 10^9,2\le m\le 10^5,1\le k \le n^{m-1},k\times m\le 10^6$。

|子任务|$n$|$m$|$k$|分值|依赖子任务|
|:-------:|:-:|:-:|:-:|:--:|:-:|
|$1$|$\le 10^9$|$=2$|$\le n$|$10$|-|
|$2$|$\le 10^9$|$\le 10^5$|$\le n$|$5$|$1$|
|$3$|$\le 10$|$=3$|-|$20$|-|
|$4$|$\le 10$|$\le 10$|$\le 10$|$20$|-|
|$5$|$\le 10^4$|$\le 100$|-|$20$|$3,4$|
|$6$|$\le 10^9$|$\le 10^5$|-|$25$|$1\sim 5$|

后来，他构造出了 $k$ 个 $m$ 元组，不知不觉的睡着了，我趁着这个好机会，使用宇宙射线远程轰击他的评测机让他爆零，挂的他不敢还手，对他的打击比 freopen 写错还大。

## 样例 #1

### 输入

```
3 3 3```

### 输出

```
1 2 1
2 1 2
3 3 3```

# 题解

## 作者：Undead2008 (赞：6)

答案是构造所有元素和为 $n$ 倍数的元组。

如果删去的是一对相同的元素，那么因为元组两两不同，一定还会有一个位置不同。否则，剩下的元组元素之和模 $n$ 不同余，所以一定还有不同。所以构造合法。

这样能构造 $n^{m-1}$ 个合法的元组，因为前 $m-1$ 位可以随便选，而第 $m$ 位可以根据前 $m-1$ 位唯一确定。

对于任意合法解，根据鸽笼原理，其最多包含 $n^{m-1}$ 个元组，所以这组构造顶到了合法元组数量上界。

这不是 Ad-Hoc。这个构造方式是可以通过手玩 $n=1,2,3$ 直接导出的。

---

## 作者：CleverSea (赞：5)

Update 2025/7/25：为契合题目主题，增加文章《别样的构造大战》。

# 别样的构造大战

##### 往下翻，有正常版题解。

一天，肚子的给我打来电话。他说："你敢不敢和我举行碰碰车大战？给定三个整数 $n, m, k$，构造 $k$ 个 $m$ 元组，满足每个元素在 $[1, n]$ 中，且任意两个元组删去任意相同位置的一对元素后，剩下的部分都不相同。"我豪爽地答应了："我当然敢！周日下午在 xx 路 xx 大厦举行，谁不来谁就是怂货。"

我原本以为我恐吓了肚子的，肚子的应该躲在机房，不敢找我，可正当这时，我听见了音乐声，原来是我洛谷私信响了，一看，竟然是肚子的发来的输入样例：`3 3 3`。他还真有勇气，我轻蔑一笑，准备构造 $3$ 个 $3$ 元组，使每个元组的每个元素都相同：

```cpp
1 1 1
2 2 2
3 3 3
```

可正当这时，肚子的打来电话："小废物，当 $k$ 超过 $n$，你这方法不就被 hack 了？再不会正解你的锣鼓账号就要被我机惨了！"听到他对我的毒骂之后，我回击道："我要用 $n$ 进制展开构造，前 $m-1$ 个分量用 $n$ 进制表示索引，最后一个分量由前 $m-1$ 个分量的和模 $n$ 决定，使任意两个元组至少有两个位置不同，再把你的 $2147483647$ 个小号挂在同一场锣鼓月赛上并提交 AI 生成的代码，让你被封掉，你说好不好啊。"

他吓得没再回应我，可是到了周日，肚子的竟然又给我打电话了，他还真要和我举行构造大战，于是我按照约定，到达了 xx 大厦，可他已经等我很久了。

第一回合，我占上风，当 $k \leq n$ 时，我直接输出 $k$ 个元组，每个元组都是相同的数字：

```cpp
for (int i = 1; i <= k; i++) {
    for (int j = 0; j < m; j++) {
        printf("%d ", i);
    }
    printf("\n");
}
```

肚子的还在手算 $k=1 \times 10^5$ 的情况，他比不过我，到了第六回合，他就主动认输了。

第二回合，他开始占上风，构造出了一个 $n=2, m=3, k=4$ 的情况。我也不甘示弱，我们僵持了 $10^9+7$ 个回合，我由于轻敌地尝试：

```cpp
// 错误示范：最后一个分量随便填
元组0: (1, 1, 1)
元组1: (1, 2, 2)
元组2: (2, 1, 2)
元组3: (2, 2, 1)
```

结果发现我的策略看似正确，但当 $k=5$ 时，我无论如何都构造不出第五个元组，被他击败了。

从那时开始，我就不轻敌了，我认真研究他的套路，于是我总结出了一种方案：最后一个分量取前 $m-1$ 个分量的和模 $n$ 再加一，这样如果两个元组前 $m-1$ 位只有一个位置不同，那么最后一个分量就会不同：

```cpp
last = (sum(a[0] to a[m-2]) - 1) % n + 1;
```

第二天，我们举行第三局，他使用祖传暴力，对我发动猛烈的攻击，我们势均力敌，平分秋色，$k \times m$ 最大 $10^6$ 的数据规模使我们比了 $998244353$ 个小时，也没分出胜负。

后来，他不知不觉的睡着了，我趁着这个好机会，一记凌车漂移，一飞冲天，精准地输出了所有元组：

```cpp
// 对于k>n的情况
int d = m - 1;
for (long long i = 0; i < k; i++) {
    long long temp = i;
    // 将i转换成d位的n进制数
    for (int j = d-1; j>=0; j--) {
        a[j] = temp % n + 1;  // 映射到[1,n]
        temp /= n;
    }
    long long s = 0;
    for (int j = 0; j < d; j++) s += a[j];
    long long last = (s-1) % n + 1;  // 关键操作
    
    // 输出
    for (int j = 0; j < d; j++) printf("%d ", a[j]);
    printf("%lld\n", last);
}
```

打的他不敢还手，对他的打击比 `freopen` 写成 `freeopen` 还大。

# 正常版题解

这是一道 Special Judge 题目。

### 题意简述

本题要求构造 $k$ 个 $m$ 元组，满足以下条件：

1. 每个元素均为 $[1, n]$ 中的整数。

3. 对于任意两个不同的元组 $i$ 和 $j$，以及任意位置 $p$，存在一个位置 $l \neq p$ 使得 $x_{i,l} \neq x_{j,l}$（即删除任意位置 $p$ 后，剩余部分不同）。

### 思路

通过（~~kàn~~）观（~~tí~~）察（~~jiě~~），我们**注意到**：

- 条件 $2$ 等价于任意两个元组的汉明距离（不同位置的个数）至少为 $2$。若两个元组仅有 $1$ 个位置不同，则删除该位置后剩余部分相同，违反条件。
  
- 当 $k \leq n$ 时，可构造每个元组的所有分量相同（即 $(i, i, \dots, i)$ 形式），且 $i$ 互不相同。此时任意两个元组的所有位置均不同，汉明距离为 $m \geq 2$，满足条件。

- 当 $k > n$ 时（此时 $n$ 较小，因 $k \leq n^{m-1}$ 且 $k \times m \leq 10^6$）：

  1. 将索引 $i$（$0$ 到 $k-1$）转换为 $m-1$ 位的 $n$ 进制数（每位数加 1 后映射到 $[1, n]$），作为元组的前 $m-1$ 个分量。
  
  3. 第 $m$ 个分量取前 $m-1$ 个分量的和减 1 模 $n$ 再加 1，即 $(s - 1) \bmod n + 1$（$s$ 为分量和）。该操作确保若前 $m-1$ 个分量仅有一处不同，则第 $m$ 个分量不同（汉明距离至少为 $2$）。

### Steps

1. 当 $k \leq n$ 时：
   
    - 输出 $k$ 个元组，第 $i$ 个元组所有分量为 $i$。

2. 当 $k > n$ 时：
     - 初始化 $d = m - 1$。
     - 对每个索引 $i \in [0, k-1]$：
       - 将 $i$ 转换为 $d$ 位 $n$ 进制数（每位数加 $1$ 存储）。
       - 计算前 $d$ 个分量的和 $s$。
       - 第 $m$ 个分量为 $(s - 1) \bmod n + 1$。
       - 输出整个元组。

### Code

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int main() {
    long long n, m, k;
    scanf("%lld %lld %lld", &n, &m, &k);
    // k <= n 时：输出所有分量相同的元组
    if (k <= n) {
        for (int i = 1; i <= k; ++i) {
            for (int j = 0; j < m; ++j) {
                if (j > 0) {
                    printf(" ");
                }
                printf("%d", i);
            }
            printf("\n");
        }
    }
    // k > n 时：使用 n 进制展开构造
    else {
        int d = sc<int>(m - 1);  // 前 m-1 个分量
        static int a[100000];
        for (long long i = 0; i < k; ++i) {
            long long temp = i;
            // 将 i 转换为 n 进制（d 位），存储到 a（高位在前）
            for (int j = d - 1; j >= 0; --j) {
                a[j] = sc<int>(temp % n) + 1;  // 映射到 [1, n]
                temp = temp / n;
            }
            // 计算前 d 个分量的和
            long long s = 0;
            for (int j = 0; j < d; ++j) {
                s += a[j];
            }
            // 计算最后一个分量：(s-1) mod n + 1
            long long last = (s - 1) % n + 1;
            if (last == 0) {  // 确保在 [1, n] 范围内
                last = n;
            }
            // 输出元组
            for (int j = 0; j < d; ++j) {
                printf("%d ", a[j]);
            }
            printf("%lld\n", last);
        }
    }
    return 0;
}
```

时间复杂度为 $O(k \times m)$，足以通过本题。（题目限制 $k \times m \leq 10^6$）

---

## 作者：l15130880055 (赞：3)

提供一个跟其他题解不太一样的做法（话说这个 spj 是怎么写的）。

设序列 $x$（下标从 $0$ 开始且长度为 $m+1$）中的 $x_0$ 和 $x_m$ 为 $0$，其他元素从 $0$ 到 $n-1$ 任取一个值。再设序列 $a$（下标从 $0$ 开始且长度为 $m$），让 $a_i\gets (x_i+x_{i+1}+n-1)\bmod n+1$。

易证该构造能使任意两组序列 $a$ 使得其中至少存在某一对位置相同的元素取值不相等。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,now;
vector<long long>v;
void dfs(long long x)
{
	if(x==m){
		for(int i=0;i<m;++i)printf("%lld ",v[i]);
		now++;printf("\n");
		if(now==k)exit(0);
		return;
	}
	dfs(x+1);
	for(int i=1;i<n;++i){
		v[x-1]++;
		v[x]++;
		while(v[x-1]>n)v[x-1]-=n;
		while(v[x]>n)v[x]-=n;
		dfs(x+1);
	}
	v[x-1]++,v[x]++;
	while(v[x-1]>n)v[x-1]-=n;
	while(v[x]>n)v[x]-=n;
	
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=m;++i)v.push_back(1);
	dfs(1);
	return 0;
}
```

---

## 作者：wanganze (赞：2)

### 题意
要求构造 $k$ 个值域为 $[0,n-1]$ 的 $m$ 元组，每两个 $m$ 元组至少要有 $2$ 个位置的值不同。

保证 $k \le n^{m-1}$。
### 思路
注意到 $k$ 恰好在 $m-1$ 位 $n$ 进制表示的范围内，因此易得前 $m-1$ 项可以随便排，换句话说前 $m-1$ 项一定可以做到至少一项不等。

考虑最后一项的构造。

猜想：最后一项可以是对前 $m-1$ 项求和后对 $n$ 取模。

即 $x_n=\left( \sum_{i=1}^{n-1} x_i \right) \bmod n,y_n=\left( \sum_{i=1}^{n-1} y_i \right) \bmod n$。

证明：设 $m$ 元组 $x,y$ 的前 $m-1$ 项只有第 $j$ 项不相等（否则结论一定成立）。

则需满足最后一项不相等。

消去相等的项，得到 $x_n-y_n \equiv x_j-y_j \ne 0 \pmod n$。

$x_n \ne y_n$，证毕。
### 实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,k;
	cin>>n>>m>>k;
	for(int i = 1; i <= k; i ++)
	{
		int res = 0;
		for(int j = 1,t = i; j < m; j ++) res = (res + t % n) % n,cout<<t % n + 1<<' ',t /= n;
		cout<<res + 1<<'\n';
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：2)

我原本以为我恐吓了幸运草，幸运草应该躲在机房，不敢找我，可正当这时，我听见了音乐声，原来是我 qq 私信响了，一看，竟然是。

下文中 $v$ 即为题目中的 $n$。

题目即构造 $k$ 个值域为 $[1,v]$ 的 $m$ 元组满足两两之间都有至少两个数不相同。

考虑对于所有 $m$ 元组都使其元素和为 $n$ 的的倍数。即前 $m-1$ 个数随机构造，第 $m$ 个数补上余数。这样对于两个 $m$ 元组一定有两个对应位置的数不相同，因为：若前 $m-1$ 个对应位置的数相同，则第 $m$ 个数一定相同；若前 $m-1$ 个对应位置的数有且仅有一个数不同，因为两数差最大为 $v-1<v$，因此第 $m$ 个数也一定不同。这样构造 $m$ 元组个数的最大值为 $n^{m-1}$，符合题目要求。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    int v,m,k;cin>>v>>m>>k;
    for(int i=1; i<=k; i++){
        int temp=i,ans=0;
        for(int j=1; j<m; j++){
            cout<<temp%v+1<<" ";
            ans+=temp%v+1;temp/=v;
        }
        cout<<(ans-1)%v+1<<"\n";
    }
    return 0;
}
```

---

## 作者：_H17_ (赞：2)

## 题目分析

很有意思的一道题，很有思维难度。个人差比较大。

需要给出 $k(n^{m-1})$ 个长 $m$，两两之间至少有两个位置不同的且值域在 $[1,n]$ 的元组。

不难发现数据范围中 $k$ 很特殊，同时显然可以造出来 $n^{m-1}$ 个至少有一个位置不同的长 $m-1$ 的元组。

显然要通过最后一位把他们变成有至少两个不同的。

不难发现有没有相同和每一个数都有关系，考虑对所有数做某种运算。

不妨尝试最常见的求和（取余）。

和相同的两个不同元组一定有至少两个位置不同（一多一少），接下来考虑取余过的情况。

取余过说明和的差距比 $n$ 大，显然一个数最多造成 $n-1$ 的差（$1\to n$），所以至少改了两个数。

暴搜实现即可，时间复杂度 $O(mk)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,p[1000001],ans;
void dfs(int step,int sum){
    if(step>=m){
        for(int i=1;i<m;i++)
            cout<<p[i]<<' ';
        cout<<(sum+1)%n+1<<'\n';
        if((++ans)==k)
            exit(0);
        return;
    }
    for(int i=1;i<=n;i++)
        p[step]=i,dfs(step+1,sum+i);
}
signed main(){
    cin>>n>>m>>k;
    dfs(1,0);
    return 0;
}
```

---

## 作者：hanyu0722 (赞：1)

### 题目链接    

[P12606 碰碰车大战](https://www.luogu.com.cn/problem/P12606)

### 题目思路

提供一种偶然试出来的方法，但证明正确性较为简单。

这道题很明显是一道构造题。注意到题目中范围为 $1 \le k \le n^{m-1}$，根据题意，很轻易就能想到可以使前 $m-1$ 个数中的每一个都取 $1$ 到 $n$ 的范围，这样就带来了 $n^{m-1}$ 种可能性。

最后剩下的一个数需要用前面的数去计算，实际操作发现如果最后一个数为 $(a_1-1+a_2-1+...+a_{m-1}-1) \bmod n+1$ 时，其必满足题目的要求。可分类讨论三种情况证明正确性，在此不过多赘述。

### 代码实现

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k;
signed main(){
	cin>>n>>m>>k;
	for (int i=1;i<=k;i++){
		int x=i;
		int ans=0;
		for (int j=1;j<m;j++){
			printf("%d ",x%n+1);
			ans+=x%n;
			x/=n;
		}
		printf("%d\n",ans%n+1);
	}
	return 0; 
}

```

---

## 作者：__CJY__ (赞：1)

## 思路
本文把每个元组设为 $a$。

每个元组的前 $m-1$ 个元素可以任意选择 $1 \sim n$ 之间的整数，第 $m$ 个元素则根据前 $m-1$ 个元素的和来确定，使得总和为 $n$ 的倍数。具体来说，$a_m=\left(n-\sum\limits_{i=1}^{m-1}a_i \pmod n\right) \bmod n$。
## Code
~~**正常的**代码很简单，就不放了，可以去看其他题解。所以以下是**不正常**的代码……~~

这里献上一种非常丑陋的方法，内有注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxm=1e5+5;
int a[maxm],n,m,k;
int main(){
	cin>>n>>m>>k,fill(a+1,a+m+1,1);
	for(int i=1;i<=k;i++){
		int s=0;
		for(int j=1;j<m;j++) s+=a[j];
		int t=(n-s%n)%n;
		if(!t) t=n;
		for(int j=1;j<m;j++) cout<<a[j]<<' ';//输出当前元组
		cout<<t<<'\n';
		int c=1;//生成下一个前 m-1 元组，类似于 n 进制加法
		for(int j=m-1;j&&c;j--){
			a[j]+=c;
			if(a[j]>n) a[j]=1,c=1;
			else c=0;
		}
	}
}
```
**注意数组开始时要全部设为 $1$，不能使用 `memset`，可以用 `fill`。**

---

## 作者：tuntunQwQ (赞：1)

因为题目保证 $1\le k \le n^{m-1}$，所以我们最多要构造出 $n^{m-1}$ 个元组。

注意到前 $m-1$ 个元素中每个都选一个 $[1,n]$ 范围内的整数一共有 $n^{m-1}$ 个不同的选法，这里的不同是指任意两个元组至少一对位置相同的元素不同。而题目要求我们构造的任意两个元组至少两对位置相同的元素不同，所以对于每 $n$ 个只有第 $i$ 个元素不同而其他位置元素都相同的元组，它们的第 $m$ 个元素应该不同。

对于这样的 $n$ 个元组，它们前 $m-1$ 个元素的和均不相同，并且最大的和与最小的和差值为 $n-1$，我们可以计算它们中每一个元组的前 $m-1$ 个元素的和对 $n$ 取模的值记为 $sum$。因为它们中每一个元组的 $sum$ 都互不相等，我们令这些元组的第 $m$ 个元素为 $sum+1$，这样对于这些前 $m-1$ 个位置中只有一个位置的元素不同的元组，它们的第 $m$ 个元素也不同，我们就保证了任意两个元组至少一对位置相同的元素不同。

至于为什么令第 $m$ 个元素为 $sum+1$，因为 $sum$ 是对 $n$ 取模后的结果，可能为 $0$，也不可能大于或等于 $n$。为保证每个元素都在 $[1,n]$ 范围内，我们要令第 $m$ 个元素为 $sum+1$。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,k,add[N],sum;
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++){
    	sum=0;
    	for(int j=1;j<m;j++)cout<<add[j]+1<<' ',sum=(sum+add[j]+1)%n;
    	add[m-1]++;
		for(int j=m-1;j>=1;j--){if(add[j]==n)add[j]=0,add[j-1]++;}
		cout<<sum+1<<'\n';
	}
    return 0;
}
```

前 $m-1$ 个元素中的 $n^{m-1}$ 个不同的选法可以用类似进位的方法求出，即逢 $n$ 进一。

---

## 作者：haoyan1103 (赞：1)

一道构造题。
## 题目解析
题目就是求构造 $k$ 个长度为 $m$ 的序列，使得删掉序列中某一列，剩下的序列两两不相同。  
也就是要使构造出的序列，至少有两位相同位置上数值不同。  
先考虑暴力枚举，发现用深搜构造出的序列，两两至少有一位不同，但我们需要至少两位不同。所以我们用深搜构造出长度为 $m-1$ 的序列，第 $m$ 位则为前面的和模 $n$ 再加 $1$。  
证明这样构造不会重复：  
因为深搜构造出的序列两两至少有一位不同，所以只要证明深搜构造出的序列两两**有一位不同**的情况下的 $m$ 不同。  
当深搜构造出的序列两两有一位不同时，那么这两序列的前 $m-1$ 项之和的差最大不超过 $n-1$ 则前面的和模 $n$ 再加 $1$ 就不相同。  
那么直接深搜构造就做完了，且这样也刚好可以最多构造出 $n^{m-1}$ 种序列。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
int n,m,k;
int a[100005];
void dfs(int id,int x)
{
    if(id==m)
    {
        for(int i=1;i<m;i++)cout<<a[i]<<" ";
        cout<<(x%n+1)<<"\n";//第 m 项
        k--;
        if(k==0)exit(0);//满 k 行就结束
        return ;
    }
    for(int i=1;i<=n;i++)
    {
        a[id]=i;
        dfs(id+1,x+i);
    }
}
signed main()
{
    cin>>n>>m>>k;
    dfs(1,0);
    return 0;
}
```

---

## 作者：FamousKillerconan (赞：0)

## 思路
明显构造。


题目要求使构造出的序列，至少有两位相同位置上数值不同。


使用暴力枚举。我们用深搜构造出长度为 $m−1$ 的序列，第 $m$ 位则为前面的和模 $n$ 再加 $1$（因为深搜只能保证一列不相同）。


可以证明这是正确的。


接下来来证明这是对的：


按照上面构造方法，可以得出 $n^{m-1}$ 个合法序列（最后一个可以按前面的确定）


由于 $k$ 上限为 $n^{m-1}$，故构造方法成立。


证毕。


AC 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
#define endl "\n"
using namespace std;
const int N=1e6+5;
const int INF=0x3f3f3f3f;
const double EPS=1e-6;
const int MOD=1e9+7;
int n,m,k,a[N];
void dfs(int dep,int x){
	if(dep==m){
		for(int i=1;i<m;i++)cout<<a[i]<<" ";
		cout<<x%n+1<<endl;
		k--;
		if(k==0)exit(0);
		return;
	}for(int i=1;i<=n;i++){
		a[dep]=i;
		dfs(dep+1,x+i);
	}
}
void solve(){
	cin>>n>>m>>k;
	dfs(1,0);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P12606 碰碰车大战](https://www.luogu.com.cn/problem/P12606)

场切这题至少保住了我的等级分。

### 做题过程

看到这题瞬间我就想起了[一个之前见过的 idea](https://www.luogu.com.cn/discuss/1080374)，于是快速照打了一遍，并不成功，应该是因为 $m$ 太小时 $\dfrac{m}{2}!!$ 并不够。

观察数据范围。注意到 $k \le n^{m-1}$ 这个就很有提示性，于是考虑如下构造：

```
1 1 X
1 2 X
1 3 X

2 1 X
2 2 X
2 3 X

3 1 X
3 2 X
3 3 X
```

有点类似 $n$ 进制的循环。此时已经保证了两两之间至少一位不同。我们要找到一个设置 $X$ 的好方法，以保证只有一位不同的 $m-1$ 元组的 $X$ 一定不同。

这是什么？哈希。哈希想到什么？取模。

对，我们将 $X$ 设为前 $m-1$ 个元素的和对 $n$ 取模的结果。此时如果两个 $m-1$ 元组只有一位不同，那么它们和模 $n$ 的结果一定不同。

甜菜！

### 代码实现

用一个变量 $s$，初值为 $i$，每次移位除以 $n$。这样可以模拟 $n$ 进制位的循环。当前位的值就是 $s \bmod n $，当然要加 $1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>k;
    for(int i=1;i<=k;i++){
        long long sum=0,s=i;
        for(int j=1;j<m;j++){
            int k=s%n+1;
            s/=n;
            cout<<k<<' ';
            sum+=k;
        }
        cout<<sum%n+1<<'\n';
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/218804600)。

---

## 作者：sbno333 (赞：0)

注意到数据范围 $k\le n ^{m-1}$。

我们先确定前 $m-1$ 个数。

然后最后一个数根据前面的数计算，来保证两个序列至少两个位置不同。

发现如果值域范围改为 $0\le x_{i,j}<n$。

那么就是模 $n$。

可以先求和，然后模 $n$ 作为最后一个数。

对于任意两个序列，前面 $m-1$ 恰有一个不同，此时和相差 $1$ 到 $n-1$ 之间，此时两个序列最后一个位置可以证明也一定不同，因为相差不是 $n$ 的倍数。

于是代码很简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
inline void f(int x){
	int sum;
	sum=0;
	for(int i=1;i<m;i++){
		cout<<x%n+1<<" ";
		sum+=x%n+1;
		x/=n;
	}
	cout<<sum%n+1<<endl;
}
signed main(){
	cin>>n>>m>>k;
	for(int i=0;i<k;i++){
		f(i);
	}
	return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：0)

这道题目的背景是[ RS 编码](https://zh.wikipedia.org/zh-cn/%E9%87%8C%E5%BE%B7-%E6%89%80%E7%BD%97%E9%97%A8%E7%A0%81)。

## 思路
从背景中得知，汉明距离至少为 $d$ 时，至多有 $n^{m-d+1}$ 个元组。这道题要求任意两个元组之间汉明距离至少为 2，也就是说至多有 $n^{m-1}$ 个元组，其实这一点已经在数据范围的提示中暗示了，而 $n^{m-1}$ 的组合意义就是在前 $m-1$ 个位置上任意填充 $n$ 种字符。

前 $m-1$ 个位置已经填好了，现在来看最后一位怎么填充。任意两个元组的前 $m-1$ 个位置中至少有一个位置上是不同的，如果已经有两位不同了那么就不需要考虑了。而如果前面只有一个不同，那么就要想办法让最后一位也不同，于是想到对前面求和来使得最后一位不同。

从背景中可以得知，一般性的解法是在有限域上构造降幂的消息多项式，除掉有限域的生成多项式得到的余式称为校验多项式，减去余式得到码字多项式，它的系数就是最后的码字。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
    long long n,m,k;
    cin>>n>>m>>k;
    if(k<=n){
        for(int i=0;i<k;++i){
            for(int j=0;j<m;++j){
                cout<<i+1<<' ';
            }
            cout<<'\n';
        }
        return 0;
    }

    int havedone=0;
    vector<long long> nums(m);
    int loc=0;
    function<void()> dfs=[&](){
        if(havedone==k){
            return;
        }
        if(loc==m-1){
            ++havedone;
            long long ss=0;
            for(int i=0;i<m-1;++i){
                cout<<nums[i]<<' ';
                ss+=nums[i];
                ss%=n;
            }
            cout<<ss+1<<'\n';
            return;
        }
        for(int i=1;i<=n;++i){
            nums[loc]=i;
            ++loc;
            dfs();
            --loc;
            if(havedone==k){
                return;
            }
        }
    };
    dfs();
    return 0;
}
```

---


# 通天之潜水

## 题目背景

直达通天路·小 A 历险记第三篇


## 题目描述

在猴王的帮助下，小 A 终于走出了这篇荒山，却发现一条波涛汹涌的河拦在了自己的面前。河面上并没有船，但好在小 A 有 $n$ 个潜水工具。由于他还要背重重的背包，所以他只能背 $m$ 重的工具，又因为他的力气并不是无限的，河却很宽，所以他只能背有 $v$ 阻力的工具。但是这条河下有非常重要的数据，所以他希望能够停留的时间最久。于是他找到了你，让你告诉他方案。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le m, v \le 200$，$1 \le n \le 100$。

数据保证一定有方案。

若有多种方案，输出前面尽量小的方案。


## 样例 #1

### 输入

```
100 100 3
50 60 289
40 10 116
50 50 106
```

### 输出

```
405 
1 2
```

# 题解

## 作者：WaterSky (赞：22)

[题目传送门：P1759 通天之潜水。](https://www.luogu.com.cn/problem/P1759)

## 前言：
这篇题解共分为两部分。

## Part 1：
这是一道动态规划的题目，既然是动态规划，那么就要弄清楚状态，状态转移公式。

从题目中可以看出，这是一道背包问题。那么既然知道了是背包问题，那么状态和状态转移公式就很容易得出了。首先是状态，对于 $dp[i][j]$，表示重量为 $i$，阻力为 $j$ 的能够获得的最大价值。其次，就是状态转移公式，根据背包问题的公式，可以得出：
$$dp[i][j]=\max(dp[i][j],dp[i-m][j-v]+w)$$
其中，$v$ 代表这件物品的阻力，$m$ 代表这件物品的重量，$w$ 代表这件物品的价值。

确定好状态和状态转移公式，还要确定怎么记录使用的工具有哪些。我使用的方法是用二维字符串数组来记录，当当前的最高价值要更新时，这个字符串数组的对应字符串也要跟着更新。

弄清楚以上代码后，就可以轻松的打出代码来：
```
#include <bits/stdc++.h>//万能头文件。
using namespace std;
long long n,m,v,dp[1005][1005];//定义背包数组。
string ans[1005][1005];//定义字符串二维数组。
struct wbx{
	long long a,b,c;
}a[1005];//每一个工具都用结构体记录。
int main(){
	cin>>m>>v>>n;//输入变量。
	for(int i=1;i<=n;i++) cin>>a[i].a>>a[i].b>>a[i].c;//输入每一个工具对应的数值。
	for(int i=1;i<=n;i++)
		for(int j=m;j>=a[i].a;j--)
			for(int k=v;k>=a[i].b;k--)
            			//如果用现在可以的阻力和重量分别减少这个工具所产生的价值大于原来的价值，
                        	那么就应该更新这个最大价值。
				if(dp[j-a[i].a][k-a[i].b]+a[i].c>dp[j][k])
					dp[j][k]=dp[j-a[i].a][k-a[i].b]+a[i].c,ans[j][k]=ans[j-a[i].a][k-a[i].b]+char(i);
                    		//状态转移公式
	cout<<dp[m][v]<<endl;//输出最大价值。
	for(int i=0;i<ans[m][v].size();i++) cout<<int(ans[m][v][i])<<" ";//输出答案。
	return 0;
}
```

## Part 2：
但是在添加了 能够 Hack 掉所有题解的数据，怎么可能这么容易让你对？

我一开始也是被 Hack 掉了，在仔细的读题之后，发现，我一直都省略掉了一句话：若有多种方案，输出前面尽量小的方案。

在讨论版找到了 Hack 数据后，我发现我就是错了这一个地方。
那么要怎么办呢？可以在判断条件中加入一个：如果价值相等，那么就挑选字典序更小的那一个。这样子，就可以 AC 了。
```
#include <bits/stdc++.h>//这个程序在上面有对应的注释。
using namespace std;
long long n,m,v,dp[1005][1005];
string ans[1005][1005];
struct wbx{
	long long a,b,c,t;
}a[1005];
int main(){
	cin>>m>>v>>n;
	for(int i=1;i<=n;i++) cin>>a[i].a>>a[i].b>>a[i].c,a[i].t=i;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=a[i].a;j--)
			for(int k=v;k>=a[i].b;k--)
			{
				if(dp[j-a[i].a][k-a[i].b]+a[i].c>dp[j][k] || dp[j-a[i].a][k-a[i].b]+a[i].c==dp[j][k] && ans[j-a[i].a][k-a[i].b]+char(a[i].t)<ans[j][k])
				dp[j][k]=dp[j-a[i].a][k-a[i].b]+a[i].c,ans[j][k]=ans[j-a[i].a][k-a[i].b]+char(a[i].t);
			}
				
	cout<<dp[m][v]<<endl;
	for(int i=0;i<ans[m][v].size();i++) cout<<int(ans[m][v][i])<<" ";
	return 0;
}
	return 0;
}
```
---

谢谢！

---

## 作者：dsy2022 (赞：5)

[题目传送门：P1759 通天之潜水](https://www.luogu.com.cn/problem/P1759)

当解决这个问题时，我们可以采用动态规划的方法。(废话)

不了解动态规划的看这位老兄[博客](https://blog.csdn.net/qq_37771475/article/details/126855564)

好了，不废话了，正片开始：

1. 问题分析：这是一个组合优化问题，我们需要从 $n$ 个潜水工具中选择若干个携带，使得携带的工具重力总和不超过 $m$，阻力总和不超过 $v$，且所选的工具能够使小 A 在河底停留的时间最长。

2. 解决思路：如下

3. 定义状态：

	我们使用一个二维数组 $dp _ {j,k}$ 来表示在重力为 $j$、阻力为 $k$ 	的情况下，小 A 能停留的最长时间。其中，$dp _ {j,k}$ 表示在当前重力和阻力情况下的最长停留时间。

	我们还需要使用一个三维数组 $ans _ {j,k,i}$ 来记录选择潜水工具的方案。其中，$ans _ {j,k,i}$ 为 `true` 表示在重力为 $j$、阻力为 $k$ 的情况下，第 $i$ 个潜水工具被选择放入背包。

4. 状态转移方程：根据背包问题的特点，我们可以得到状态转移方程如下：

	$$dp _ {j,k} = \max(dp _ {j,k}, dp _ {j-g[i],[k-f[i]] + v[i])}$$
	这表示在选择第 $i$ 个潜水工具和不选择第 $i$ 个潜水工具两种情况中，选择能使停留时间更长的方案。其中，$dp _ {j-g[i],[k-f[i]] + v[i])}$ 表示选择第 $i$ 个工具后的停留时间，$dp _ {j,k}$ 表示不选择第 $i$ 个工具的停留时间。

5. 初始化：我们将数组 $dp$ 和 $ans$ 全部初始化为 $0$，表示在重力和阻力都为 $0$ 时停留的时间为 $0$，且所有潜水工具都未被选择。(额你确定这不是废话吗？)

6. 状态转移：按照状态转移方程，我们遍历所有潜水工具和所有的重力和阻力情况，更新数组 $dp$ 和 $ans$。

7. 输出结果：最后，在 $dp _ {m,v,n}$ 处得到的值即为在重力为 $m$、阻力为 $v$ 的情况下停留的最长时间。我们可以根据记录的 $ans$ 数组，回溯找出所选的潜水工具，并输出最优解。

代码实现：
```
#include<stack>
#include<queue> 
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define fo(i,j,k) for(i=j;i<=k;i++)
using namespace std;
int n,m,t;
int g[105],f[105],v[105];
int dp[205][205]; // dp数组用于记录最长停留时间
bool ans[205][205][105]; // ans数组用于记录选择潜水工具的方案

int main()
{
    int i,j,k,p;
    scanf("%d%d%d",&m,&t,&n); // 输入背包的重力限制m，阻力限制t，潜水工具数量n
    fo(i,1,n) 
        scanf("%d%d%d",&g[i],&f[i],&v[i]); // 输入每个潜水工具的重力、阻力和能够支撑的时间

    fo(i,1,n) {
        for(j=m;j>=g[i];j--) {
            for(k=t;k>=f[i];k--) {
                if(dp[j-g[i]][k-f[i]]+v[i]>dp[j][k]) {
                    dp[j][k]=dp[j-g[i]][k-f[i]]+v[i]; // 更新最长停留时间
                    fo(p,1,i) 
                        ans[j][k][p]=ans[j-g[i]][k-f[i]][p]; // 复制上一个状态的所选潜水工具编号
                    ans[j][k][i]=1; // 将当前潜水工具编号加入当前状态的方案中
                }
                else if(dp[j-g[i]][k-f[i]]+v[i]==dp[j][k]) {
                    bool flag=0;
                    fo(p,1,i) {
                        if(ans[j][k][p] && !ans[j-g[i]][k-f[i]][p]) // 当前潜水工具被选择，而上一个状态的该工具未被选择
                            break;
                        else if(!ans[j][k][p] && ans[j-g[i]][k-f[i]][p]) { // 当前潜水工具未被选择，而上一个状态的该工具被选择
                            flag=1;
                            break;
                        }
                    }
                    if(flag) {
                        fo(p,1,i) 
                            ans[j][k][p]=ans[j-g[i]][k-f[i]][p], // 复制上一个状态的所选潜水工具编号
                            ans[j][k][i]=1; // 将当前潜水工具编号加入当前状态的方案中
                    }
                }
            }
        }
    }

    printf("%d\n",dp[m][t]); // 输出最长停留时间
    fo(i,1,n) 
        if(ans[m][t][i]) 
            printf("%d ",i); // 输出所选的潜水工具编号
    return 0;
}

```
[AC 记录](https://www.luogu.com.cn/record/117689148)

时间复杂度分析：

代码中使用了三重循环来更新状态数组 $dp$ 和 $ans$，其中第一重循环遍历 $n$ 个潜水工具，第二重和第三重循环遍历背包的重力和阻力限制。因此,代码的时间复杂度为 $O(nmt)$，其中 $n$ 为潜水工具数量，$m$ 为背包的重力限制，$t$ 为背包的阻力限制。

空间复杂度分析：

代码中使用了两个二维数组 $dp$ 和 $ans$，以及三个一维数组 $g$、$f$ 和 $v$。因此，代码的空间复杂度为 $O (nmt + n)$，其中 $n$ 为潜水工具数量，$m$ 为背包的重力限制，$t$ 为背包的阻力限制。

蒟蒻的第一篇题解求过，谢谢观看！(完结撒花)

---

## 作者：2011FYCCCTA (赞：4)

# [原题](https://www.luogu.com.cn/problem/P1759)

### 思路
很明显是一道 01 背包。设 $f_{i , j}$ 表示总重量为 $i$，总浮力为 $j$ 时所能支撑的最长时间，那么状态转移方程为：$f_{i , j} = \max(f_{i , j} , f_{i - a , j - b} + c)$，$a$，$b$，$c$ 分别为当前这件物品的重力，阻力和能支撑的时间，而 $f_{m , v}$ 就是题目中所要求的最多能支撑的时间。

[背包问题详解](https://blog.csdn.net/qq_54847231/article/details/123850995?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169071804116800185814036%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169071804116800185814036&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123850995-null-null.142^v91^insert_down1,239^v12^control2&utm_term=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&spm=1018.2226.3001.4187)

但本题需输出具体的方案，还需要**保证字典序最小**，因此可以用字符串来存储，具体来说，定义一个二维数组（以下称为 $s$ 数组）记录转移数组每一种状态所对应的方案，并在转移时更新，这样既方便添加（直接将数字转换成所对应的字符）又方便比较。注意要保证字典序最小，因此在 $f_{i , j} = f_{i - a , j - b} + c$ 时要从 $s_{i , j}$ 和 $s_{i - a , j - b} + c$ 中选最小的。

--- 
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100;
const int MAXM = 200;
int m , v , n , a[MAXN + 5] , b[MAXN + 5] , c[MAXN + 5] , f[MAXM + 5][MAXM + 5];
string s[MAXM + 5][MAXM + 5];
int main()
{
    cin >> m >> v >> n;
	for (int i = 1 ; i <= n ; i++)
		cin >> a[i] >> b[i] >> c[i]; 
	
	for (int i = 1 ; i <= n ; i++)
		for (int j = m ; j >= a[i] ; j--)
			for (int k = v ; k >= b[i] ; k--)
			{
				char ci = (char)i;
				if (f[j][k] < f[j - a[i]][k - b[i]] + c[i])
				{
					f[j][k] = f[j - a[i]][k - b[i]] + c[i];
					s[j][k] = s[j - a[i]][k - b[i]] + ci;
				}
				else if (f[j][k] == f[j - a[i]][k - b[i]] + c[i] && s[j - a[i]][k - b[i]] + ci < s[j][k])
					s[j][k] = s[j - a[i]][k - b[i]] + ci;
			}
	cout << f[m][v] << endl;
	for (int i = 0 ; i < s[m][v].size() ; i++)
		cout << s[m][v][i] - 0 << ' ';
    return 0;
}
```

---

## 作者：落花月朦胧 (赞：2)

# 题意
一个拥有两种物品的背包。

# Solution

`dp` 板子。

设 $dp_{i, j, k}$ 表示考虑到了第 $i$ 个物品，选的物品已经有 $j$ 的重量和 $k$ 的阻力的时候的最长时间。

显然有 $dp_{i,j,k}=\max (dp_{i,j,k},{dp_{i-1,j-a_i, k-b_i}+c_i} ) $。和 $01$ 背包一样，我们可以倒序优化，即 $dp_{j,k}=\max(dp_{j,k},{dp_{j-a_i,k-b_i}+c_i})$。

然后是考虑怎么记录方案，这里我使用了 `string`，因为它比较方便，可以简便的增加和缩短，换而言之就是一个 `char` 的 `vector`。

顺带一提，`string` 可以用 `+` 的方式累加长度。

方案数量也可以考虑用 `dp` 来求，我们设 $g_{j,k}$ 表示 $j$ 的重量， $k$ 的阻力的方案是什么，这里的 $g$ 数组就是开的 `string` 了，类似与上面的方程，这里我们也可以写这样的一个转移：（ 姑且让 `get` 是一个 `int` 转换成 `string` 类型的函数。）

如果发现当前从 $dp_{j-a_i,k-b_i}+c_i$ 比当前的 $dp_{j,k}$ 更优秀，就让 $g_{j,k}=g_{j-a_i,k-b_i}+get(i)$。

然后这样写之后，你就发现你得到了 $100$ 分的好分数，但是没有 AC， hack 数据成功的 hack 了你的代码。

而这其中的原因就是题目中的一句话： 若有多种方案，输出前面尽量小的方案。。

所以我们还有一种情况是需要我们考虑的，就是 $dp_{j-a_i,k-b_i}+c_i=dp_{j,k}$，但是 $g_{j-a_i,k-b_i}+get(i)$ 比 $g_{j,k}$ 更加的优秀，这也是需要更新的，具体见代码。

至此，模板题就结束了。

# Code

```cpp
// Code by 落花月朦胧. 
// blog (https://www.cnblogs.com/falling-flowers/)
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') f = ch == '-' ? -1 : 1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x * f;
}

constexpr int N = 1E6 + 10;

int m, v, n;
int a[N], b[N], c[N];
int dp[210][210];
string g[210][210];
string turn(int x) {
    string s = "";
    while (x) {
        s += char(x % 10 + '0');
        x /= 10;
    }
    reverse(s.begin(), s.end());
    return s;
}
int main() {
    m = read(), v = read(), n = read();
    for (int i = 1; i <= n; i++) {
        a[i] = read(), b[i] = read(), c[i] = read();
    }
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= a[i]; j--) {
            for (int k = v; k >= b[i]; k--) {
                int ndp = dp[j - a[i]][k - b[i]] + c[i];
                if (ndp > dp[j][k] || (ndp == dp[j][k] && g[j][k] > g[j - a[i]][k - b[i]] + turn(i))) {
                    dp[j][k] = ndp;
                    g[j][k] = g[j - a[i]][k - b[i]] + turn(i) + " ";
                }
            }
        }
    }
    printf("%d\n", dp[m][v]);
    cout << g[m][v] << "\n";

    return 0;
}
```


---

## 作者：Reset_vod (赞：2)

这是一道动态规划的题目，既然是动态规划，那么就要弄清楚状态，状态转移公式。

从题目中可以看出，这是一道背包问题，需要求出状态和状态转移公式。

首先是状态，对于 $\mathit{dp}_{i,j}$，表示重量为 $i$，阻力为 $j$ 的能够获得的最大价值。

其次，就是状态转移公式，根据背包问题的公式，可以得出：
$$\mathit{dp}_{i,j}=\max(\mathit{dp}_{i,j},\mathit{dp}_{i-m,j-v}+w)$$

确定好状态和状态转移公式，还要记录使用的工具，使用二维字符串数组记录，如果价值相等，那么就挑选字典序更小的那一个。
```
#include <bits/stdc++.h>
using namespace std;
int n,m,v,dp[1005][1005];
string ans[1005][1005];
struct wbx{
	long long a,b,c,t;
}a[1005];
int main(){
	cin>>m>>v>>n;
	for(int i=1;i<=n;i++) 
    cin>>a[i].a>>a[i].b>>a[i].c,a[i].t=i;
	for(int i=1;i<=n;i++)
	for(int j=m;j>=a[i].a;j--)
	for(int k=v;k>=a[i].b;k--)
	{
		if(dp[j-a[i].a][k-a[i].b]+a[i].c>dp[j][k])//如果坚持的时间大于当前的dp值，替换。
		{
			dp[j][k]=dp[j-a[i].a][k-a[i].b]+a[i].c;
			ans[j][k]=ans[j-a[i].a][k-a[i].b]+char(a[i].t);//记录答案。
		}
		if(dp[j-a[i].a][k-a[i].b]+a[i].c==dp[j][k] && ans[j-a[i].a][k-a[i].b]+char(a[i].t)<ans[j][k])如果价值相等，那么就挑选字典序更小的那一个
		{
			dp[j][k]=dp[j-a[i].a][k-a[i].b]+a[i].c;
			ans[j][k]=ans[j-a[i].a][k-a[i].b]+char(a[i].t);
		}
	}
				
	cout<<dp[m][v]<<endl;
	for(int i=0;i<ans[m][v].size();i++) 
    	cout<<int(ans[m][v][i])<<" ";
	return 0;
}
```
---

谢谢！

---

## 作者：fqfengqi (赞：1)

[P1759 通天之潜水](https://www.luogu.com.cn/problem/P1759)


#### 二维费用背包问题模板题

前置知识：01 背包

01 背包中的经典公式：

 $$ dp_v=\max(dp_v,dp_{v-C_i}+W_i)$$

不过很明显这里每个工具不仅仅只有一个花费，本题中每个工具有 $m$ 重，$v$ 阻力，两种花费，同时容量也分为 $m$，$v$ 两个上限分别对应重量和阻力。

所以我们考虑让增加一个维度拓展为两个维度分别对应**重量**和**阻力**。

故定义 $dp_{i,j}$ 为当背 $i$ 重，$j$ 阻力的工具时，所能停留的最长时间。对照 01 背包的状态转移方程我们不难推出本题下的状态转移方程为：

 $$ dp_{i,j}=\max(dp_{i,j},dp_{i-a_k,j-b_k}+c_k)  $$

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define debug1 cout<<"test1"<<endl;
#define debug2 cout<<"test2"<<endl;
#define ed putchar('\n');
ll read(){
	ll x = 0;char ch = getchar();int f = 1;
	while(ch<'0'||ch>'9'){
		if(ch=='-') f = -1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = x*10+ch-'0';
		ch = getchar();
	}
	return x*f;
}
const int N = 107;
int a[N],b[N],c[N];
int m,v,n; 
int dp[2*N+7][2*N+7];
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	m=read(),v=read(),n=read();
	for(int i = 1;i<=n;i++){
		a[i]=read(),b[i]=read(),c[i]=read();
	}
	for(int k = 1;k<=n;k++){
		for(int i = m;i>=a[k];i--){
			for(int j = v;j>=b[k];j--){
				dp[i][j]=max(dp[i][j],dp[i-a[k]][j-b[k]]+c[k]);
			}
		}
	}
	cout<<dp[m][v];
	return 0;
}
```


------------

现在已经算出能够停留的最长时间了，但是我们还需要输出选择的工具，并输出最小的一种方案，不过最小并没有明确，在此我暂时将其理解为字典序最小的一种方案。对于保存方案，我们定义 $ans_{i,j}$ 为当背 $i$ 重，$j$ 阻力的工具时，使能停留时间最长的方法的选择方案。如果一一按照每个工具的编号将其转为字符串过于麻烦，注意到数据范围 $1\leqslant n \leqslant 100$。容易想到字符类型的表示范围为 $0\thicksim255$，这说明工具的编号完全可以直接用字符来表示。所以在需要更新方案时，直接将编号转为字符接在后面即可。输出方案时将字符串每个元素依次转为整型输出。

故核心代码代码如下：

```cpp
int sum = dp[i-a[k]][j-b[k]]+c[k];
string s = ans[i-a[k]][j-b[k]]+char(k);
if(sum>dp[i][j]||(sum==dp[i][j]&&s<ans[i][j])){//如果两种方法相同，应当取字典序较小的方式
	dp[i][j] = sum;
	ans[i][j] = s;
}
```




完整代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define debug1 cout<<"test1"<<endl;
#define debug2 cout<<"test2"<<endl;
#define ed putchar('\n');
ll read(){
	ll x = 0;char ch = getchar();int f = 1;
	while(ch<'0'||ch>'9'){
		if(ch=='-') f = -1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = x*10+ch-'0';
		ch = getchar();
	}
	return x*f;
}
const int N = 107;
int a[N],b[N],c[N];
int m,v,n; 
int dp[2*N+7][2*N+7];
string ans[2*N+7][2*N+7];
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	m=read(),v=read(),n=read();
	for(int i = 1;i<=n;i++){
		a[i]=read(),b[i]=read(),c[i]=read();
	}
	for(int k = 1;k<=n;k++){
		for(int i = m;i>=a[k];i--){
			for(int j = v;j>=b[k];j--){
				int sum = dp[i-a[k]][j-b[k]]+c[k];
				string s = ans[i-a[k]][j-b[k]]+char(k);
				if(sum>dp[i][j]||(sum==dp[i][j]&&s<ans[i][j])){
					dp[i][j] = sum;
					ans[i][j] = s;
				}
			}
		}
	}
	cout<<dp[m][v]<<endl;
	int len = ans[m][v].size();
	for(int i = 0;i<len;i++){
		cout<<int(ans[m][v][i])<<" ";
	}
	return 0;
}



```











---

## 作者：mayike (赞：1)

#### [题目传送门](https://www.luogu.com.cn/problem/P1759)
这是一道稍有小坑的二维费用DP。

------------
## 思路
我们可以记 $f[i][j]$ 表示重量剩 $i$，阻力剩 $j$ 时的最大时间，则有

$$f[i][j]=\max(f[i][j],f[i-a][j-b]+c)$$

$a$ 表示这个物品的重量，$b$ 表示阻力，$c$ 是时间，以此就可以算出最大时间了。

由于还要算编号，所以我们可以开一个二维字符串 $s[i][j]$ 来记录编号，在时间相等时字典序判断即可。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int n,u,m,a[201],b[201],c[201],f[201][201];
string s[201][201];
int main(){
	cin>>m>>u>>n;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];
	for(int i=1;i<=n;i++)
	    for(int j=m;j>=a[i];j--)
	        for(int k=u;k>=b[i];k--)
	        	if(f[j][k]<f[j-a[i]][k-b[i]]+c[i]||(f[j][k]==f[j-a[i]][k-b[i]]+c[i]&&s[j][k]>s[j-a[i]][k-b[i]]+char(i)))//强制转字符
	        	    f[j][k]=f[j-a[i]][k-b[i]]+c[i],s[j][k]=s[j-a[i]][k-b[i]]+char(i);
	cout<<f[m][u]<<endl;
	for(int i=0;i<s[m][u].size();i++)cout<<int(s[m][u][i])<<" ";//转整型
	return 0;
}
```


---

## 作者：c_y_y (赞：0)

# P1759题解

~~显然~~这是一道**二维费用**的 01 背包。

我们设 $dp[i][j]$ 表示承重剩余 $i$，阻力剩余 $j$ 时的最大时间。

初值：$dp[0][0]=0$ 

答案：$dp[m][v]$

状态转移：$dp[j][k]=\max(dp[j][k],dp[j-a[i]][j-b[i]]+c[i])$

~~( 其中的字母题目中都有，不必赘述 )~~

对于记录方案，我们只需要再来一个字符串记录就可以了。

AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,v,f[1005][1005];
string ans[1005][1005]; //记录方案
struct node {
	long long a,b,c;
} a[1005];
int main() {
	cin>>m>>v>>n;
	for(int i=1; i<=n; i++) cin>>a[i].a>>a[i].b>>a[i].c;
	for(int i=1; i<=n; i++)
		for(int j=m; j>=a[i].a; j--)
			for(int k=v; k>=a[i].b; k--) {
				if(f[j-a[i].a][k-a[i].b]+a[i].c>f[j][k] || f[j-a[i].a][k-a[i].b]+a[i].c==f[j][k] && ans[j-a[i].a][k-a[i].b]+char(i)<ans[j][k]){
					f[j][k]=f[j-a[i].a][k-a[i].b]+a[i].c;
					ans[j][k]=ans[j-a[i].a][k-a[i].b]+char(i);
				}
					
			}

	cout<<f[m][v]<<"\n";
	for(int i=0; i<ans[m][v].size(); i++) cout<<int(ans[m][v][i])<<" ";
	return 0;
}
```

本蒟蒻的第一篇题解，多多支持～

---

## 作者：keinog (赞：0)


## 题目简意：

一个背包有最大质量限定，以及最大体积限定，所以物品也都有质量值、体积值和价值，问背包在满足条件下可获得的最大价值，并且输出字典序最小的选择物品方案。

## 分析：

比较裸的 $0/1$ 背包问题，就是多了一个记录路径，其实还是很简单，跟记录最短路径一样，记录一下前缀就好了，或者直接开一个结构体，记录当前状态的路径，每次从转移过来的那个状态那里路径 $+1$。

## 思路：

- 我提供的写法一维枚举所有物品，一维枚举质量，一维枚举体积。

- 不难想到，如果我们不用滚动数组进行内存优化，我们就可以利用前面的 dp 值，推出它的路径。

- dp 转移很简单，设 $dp[i][j][k]$ 为到达第 i 个物品时，消耗 $j$ 质量和 $k$ 体积的最大价值，转移方程为

$dp[i][j][k] = \max(dp[i-1][j][k],dp[i-1][j-a[i]][k-b[i]] + c[i])$


---


# 矩形分割

## 题目描述

有一个长为 $a$，宽为 $b$ 的矩形（$1 \le a \le 6$，$2 \le b \le 6$）。可以把这个矩形看作是 $a\times b$ 个小方格。

我们现在接到了这样的一个任务：请你计算出，把这个矩形分割成两个部分的方法总数。

你不是可以任意地分割这个大的矩形，必须满足：

分割后，每个部分，至少各自均有一个方格是在大矩形的最外边上（即大矩形最外面一环的方格）。



## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/buv0992j.png)

## 样例 #1

### 输入

```
3 2```

### 输出

```
15```

# 题解

## 作者：yyyyyyyf (赞：39)

- 这道题的思路实际非常简单
- 一个由ab个小矩形组成的矩形
- 事实上可以看成一个由(a+1)(b+1)个点组成的点图
- 那么题目就可以转换为从一个边缘上的点出发，到另一个边缘点，一共有几个方案
- 为了避免重复方案的出现，我们将出发点设置在最左及最上的边上（或者最右和最下的边）
- 接下来考虑无效切割的处理（如切割(1,1)与(2,1)之间的边，这样图依然只有一个），显然，如果我们直接从边缘点开始搜索，无效切割的出现是必然的，所以我们需要做一些处理
- 首先，不将矩形的四个顶点（即边与边的交点）作为出发点，因为从顶点出发必然会导致无效切割
- 其次，我们手动将出发点走到点阵内(如从(1,1)到(1,2)),然后再进行搜索，就可以避免无效切割。这时可能会有人问，如果"手动走到的那个点"也是边缘点怎么办？我们只需要把关于边缘点的判断写在dfs开头即可。
- 最后，跳出搜索的条件就是当前位置再次到达边缘点，答案+1，回溯
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 10
int n,m;
int ans=0;
int movex[4]={1,0,-1,0};
int movey[4]={0,1,0,-1};
int vis[N][N];
void dfs(int x,int y)
    {
        vis[x][y]=1;
        if(x==1 || y==m || x==n || y==1) //到达另一个边缘点
            {
                ans++;
                vis[x][y]=0;
                return;
            }
        for(int i=0;i<4;++i)
            {
                int xx=x+movex[i],yy=y+movey[i];
                if(xx<1 || yy<1 || xx>n || yy>m || vis[xx][yy]) continue;
                dfs(xx,yy);
            }
        vis[x][y]=0;
    }
int main()  
    {
        scanf("%d%d",&n,&m);
        n++;m++; //转换为点图
        memset(vis,0,sizeof(vis));
        for(int i=2;i<n;++i) //这么写就是为了去掉交点
            {
                vis[i][1]=1;//手动将出发点设为已访问
                dfs(i,2);//然后手动走第一步，防止无效切割
                vis[i][1]=0;//回溯
            }
        for(int i=2;i<m;++i) //同上
            {
                vis[1][i]=1;
                dfs(2,i);
                vis[1][i]=0;
            }
        printf("%d",ans);
        return 0;
    }
```

---

## 作者：shuiyuhan (赞：9)

这题刚拿到，发现可以用dfs枚举切割点，但是一看数据范围，1≤a≤6，2≤b≤6?自然想到了打表，所以就打了一个表，然后就表过了此题，时间范围O(1)，空间范围O(答案),~~(比dfs不知道快到哪里去了)~~

代码:
```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[]={1,2,3,4,5,6,15,28,45,66,15,52,143,350,799,28,143,614,2431,9184,45,350,2431,16000,102147,66,799,9184,102147,1114394};//发现不会用二维数组存值，所以就用了一维的，用的时候直接输出a[(n-1)*5+(m-2)]就好了
int main(){
  scanf("%d%d",&n,&m);//把n,m读入
  printf("%d",a[(n-1)*5+(m-2)]);//因为5个一组，有(N-1)组，又是第(m-2)个，所以(随便带进去几个值试一试后发现)(划掉)有了这个式子
}
···

---

## 作者：linyinuo2008 (赞：5)

[原题链接](https://www.luogu.com.cn/problem/P1790)

我是参照第一篇题解的思路写的，大家可以这篇文章当成第一篇题解的一个参考。

# 为什么是暴搜

显然，当我们看到 $1 \leq a,b \leq 6$ 的时候，差不多就能确定这是一个非常暴力的算法。并且基本上什么复杂度都能过，如 $O(n^n)$ ， $O(n!)$ 等等。而像暴搜这种不稳定的算法也可以轻松过掉。并且再加上对方格的处理，暴搜肯定是最好想，最好写的算法。

# 处理想法

我们不难发现如果处理格子的话，很难设计搜索的边界条件。若把找到答案的条件设为`if(x==1||x==n||y==1||y==m)`，那么我们就无法找出单列或单行的格子因为进去后就会直接返回。

例：

[![RCHKgA.png](https://z3.ax1x.com/2021/06/19/RCHKgA.png)](https://imgtu.com/i/RCHKgA)

如图，我们就不可能分到这个图形，因为如果我们从 $(1,1)$ 开始搜，那么我们会直接返回。

所以该怎样处理呢？很简单，我们只需转化一下，不是格子图不好做吗？转化成点图。也就是说把上面那个例子变成这样：

[![RCXCmn.png](https://z3.ax1x.com/2021/06/19/RCXCmn.png)](https://imgtu.com/i/RCXCmn)

然后来考虑一下怎样来满足这个条件：
>每个部分至少各自均有一个方格是在大矩形的最外边上。

这句话更直接的意思是：让你找出一个子矩形，使这个子矩形至少有一个顶点在大矩形的四条边上。

这时我们就可以巧妙运用我们的点图。如何确定一个矩形？只需要知道它对角线的两个端点就可以了。所以我们可以把一个符合要求的矩形看成从大矩形内部的一个点指向其边缘的一个点就可以了。所以我们最开始的那个例子就可以变成这样：

[![RP96IA.png](https://z3.ax1x.com/2021/06/19/RP96IA.png)](https://imgtu.com/i/RP96IA)

如果没懂的话可以再看一个例子：

这个矩形

[![RPCuod.png](https://z3.ax1x.com/2021/06/19/RPCuod.png)](https://imgtu.com/i/RPCuod)

可以变成这个样子

[![RPCHmD.png](https://z3.ax1x.com/2021/06/19/RPCHmD.png)](https://imgtu.com/i/RPCHmD)

所以此时我们就可以看成从一个点深搜直到边缘，然后添加答案，返回的的过程。

但是这仅仅是主题思路，还有许多分割与判重的细节需要注意，大家可以参照第一篇题解。

代码就不放了，大家可以想清楚后尝试写一写。

---

## 作者：君玘 (赞：4)

题解第一篇ywwuyi大佬是我学长。

这题主要是想不到把分割矩形改成搜索分割线。想到后发现这一题其实不难。

首先，两个部分就是得保证分割两端都在边界。接着按正常搜索就不会出现分出多个部分的情况。

但是你会发现，若是从四边开始搜必然会出现一条其实是边的分割线，这是无效分割的。还有，四个角是产生不了分割线的。我们可以手动让它往中间走一步。

代码如下：
```cpp
#include<bits/stdc++.h>
#define gc ch=getchar()
using namespace std;
template <class T>void read(T &s){
	s=0;T f=1;char gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;gc;}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';gc;}
	s*=f;	
}
template <class T>void put(T s){
	if(s<0) putchar('-'),s=-s;
	if(s>9) put(s/10);
	putchar(s%10+'0');
}
int a,b,ans,vis[505][505],v[505][505],dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};
void dfs(int x,int y){
	//到边界意味着分割完毕，答案+1 
	if(x==1||x==a||y==1||y==b){++ans;return;}
	v[x][y]=1;
	for(int i=0;i<4;++i){
		int nx=x+dx[i],ny=y+dy[i];
		if(v[nx][ny]) continue;
		dfs(nx,ny);
	} 
	v[x][y]=0;
}
int main(){
	read(a),read(b);++a,++b;//变成点图 
	//这个2就是手动往下走一步，1的位置记得先记录 
	for(int i=2;i<b;++i) v[1][i]=1,dfs(2,i),v[1][i]=0;
	for(int i=2;i<b;++i) v[a][i]=1,dfs(a-1,i),v[a][i]=0;
	for(int i=2;i<a;++i) v[i][1]=1,dfs(i,2),v[i][1]=0;
	for(int i=2;i<a;++i) v[i][b]=1,dfs(i,b-1),v[i][b]=0;
	//从一端搜出的线必然会在搜令一端的时候再次被搜出，所以答案/2 
	put(ans/2);
}
```


---

## 作者：骗分过样例 (赞：2)

注：blog观看效果更佳

# ~~打表是数学。~~

我看了一下数据范围，据说这数据很弱，$1\leq a \leq 6 , 2\leq b \leq 6$。

这种数据，用用打表应该是个不错的选择。

关键在于，打表的时间复杂度是$O(1)$(常数级别）哇！！！

下面先附上打表的代码：

```cpp
#include<iostream>
using namespace std;

int n,m;
int a[]=
{1,2,3,4,5,6,15,28,45,66,15,52,143,350,799,28,143,614,2431,9184,45,350,2431,16000,102147,66,799,9184,102147,1114394}; //数全是自己算的

int main(){
	cin>>n>>m;
	cout<<a[(n-1)*5+(m-2)];
	return 0;
}
```

------------

下面切入正题：如何用DFS求解呢？？？

不要着急，咱慢慢来。

这个数据很小，首先想到的是最暴力的搜索：直接将所有的格子的状态进行枚举。但是仔细一算就不难发现，这样运算次数达到了$2^{36}$次，一般$10^8$就危险了，那么前面这种算法就不可能能用了。

其次就是要分析了。根据题目，要分割，实际上就是求矩形中有效的分割线。首先想到，能否偷个懒，找找计算公式？可是，似乎并没有。

那该怎么办呢？？？

现在就来讲讲：用DFS求解！！！

------------

既然要用DFS，不妨先搞清楚要干什么。显然，要找分割线。分割线必须以格点出发，再以另一个格点结尾。如此，DFS的思路应该已经有一些了。

当然，应该注意以下情况：如果出现分割在$(2,1)$与$(2,2)$之间，那么，我们必须手动预防这种情况的发生。

那么，究竟该怎么预防呢？

对此，我们有以下策略：

1. 提前把“危险的”那个坐标设为$1$，即禁止访问；
2. 在搜索时跳过这一格，直接搜索下面一个。

------------

现在，来理理思路：

1. 输入；
2. 清零（如果是全局变量，则不用清零）
3. 对行进行搜索（即从$(i,2)$开始搜索，先把“危险坐标”$(i,1)$设为$1$;
4. 对列的处理与行相同；
5. 完美的输出！！！

好了，说了好多，上代码最要紧。代码有详细解释，大家可以看看。注：代码可以直接复制并AC，但是骗分过样例提醒您：非紧急情况尽量不要使用！

```cpp
#include<iostream>
using namespace std;

int ans; //统计个数 
int n,m; //行、列 
int vis[20][20]; //访问数组 

const int dx[4]={0,1,0,-1}; 
const int dy[4]={1,0,-1,0}; 

void dfs(int x,int y){ //搜索函数 
	vis[x][y]=1; //先标记1 
	if(x==1||y==1||x==n||y==m){ //判断是否成功 
		ans++;
		vis[x][y]=0;
		return; //回溯并返回 
	}
	for(int i=0;i<4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis[nx][ny]){ //边界条件判断 
			dfs(nx,ny);
		}
	}
	vis[x][y]=0; //回溯、返回 
	return;
}

int main(){
	cin>>n>>m; //输入 
	n++,m++; //行、列加1，因为共有(n+1)*(m+1)个点 
	for(int i=2;i<n;i++){ //循环 
		vis[i][1]=1; //为了预防上述情况，即出现无效分割，做如下处理 
		dfs(i,2); //搜索！！！ 
		vis[i][1]=0;
	}
	for(int i=2;i<m;i++){ //操作同上 
		vis[1][i]=1;
		dfs(2,i);
		vis[1][i]=0;
	}
	cout<<ans; //输出！！！ 
	return 0; //完美的结束！！！ 
}
```

---

## 作者：SBofGaySchool (赞：2)

大佬们清一色说的都是将问题转化为分界线然后搜索，但是如果在考场上想破头都没有想出这种这种转化该怎么办呢？本蒟蒻来贡献一发完全不考虑分界线，只考虑方格填涂情况的暴力方法。

### 1. 枚举边缘填涂情况

题目要求分割后，两部分都必须有至少一个方格在原矩形的边缘上，同时（显然）每部分所有方格均联通（不然就不能被称之为分成两部分了）。

为表述简单，假设分割后一部分方格被涂为为黑色，另一部分为白色，则原矩形边缘那一圈方格一定有连续的一段是黑色的，另一段是白色的。我们可以先枚举出这一圈方格的所有填涂情况。对于每一种情况，再枚举中间所有方格的合法填涂，加起来即为答案所求。

为避免重复计算，规定左上角的方格必须为黑色。从左上角开始分别沿顺时针、逆时针方向将方格依次填涂为黑色，即可枚举出边缘一圈方格的所有填涂情况。

### 2. 计算中间所有方格的合法填涂

中间的方格最多有 $4\times4=16$ 个，直接暴力枚举有点过于暴力。我们可以采用回溯法进行搜索，在当前填涂情况之下，尝试将所有能被涂为黑色的方格涂为黑色，然后以新得到的填涂情况（一定是一种合法填涂）为基础，进一步进行搜索即可。

如何判断将一个方格填涂为黑色是否合法呢？为了保证填涂之后两部分方格的连通性，合法的填涂必然满足下述条件：

- 方格的上、下、左、右中必有一个已经被涂黑的方格；
- 从与方格相邻的八个方格中任意一个作为起点，绕方格一周，回到起点，经过的所有方格（一共九个）的颜色一定变化两次（黑-白-黑 或 白-黑-白）；

其中，第一个条件较好理解，第二个条件比较有技巧，但是我们通过观察不难发现，在满足条件一，且当前填涂情况合法的情况下，如果颜色变化次数超过两次，则白色部分必定被分割成了两个不相连的部分。

直接暴力回溯仍然过于暴力，我们可以通过状态压缩记忆已经搜索过的填涂情况。对于每一种合法填涂情况，令答案 $+1$ 即可。

### 3. 迷幻时间复杂度

枚举边缘填涂情况复杂度为 $O((a+b)^2)$，而枚举中间方格填涂情况为 $O(2^{ab})$，故本方法理论上时间复杂度为 $O((a+b)^22^{ab})$。但由于存在大量不合法情况，使得时间并不能跑满。故能通过本题 $a\le6,b\le6$ 的数据。

在[双倍经验](https://www.luogu.com.cn/problem/P4537)中，这么做会被卡掉一个点，这时候只需要额外打出一个点的表就可以了（逃）。

总之，在无法想到将方格分割转化为分界线的情况下，还是可以通过暴力乱搞通过此题的。

#### 4. 代码实现
```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int d[][2] = {
    {-1, 1},
    {0, 1},
    {1, 1},
    {1, 0},
    {1, -1},
    {0, -1},
    {-1, -1},
    {-1, 0},
    {-1, 1}
};
// 状压记录已经搜索过的填涂情况
int vis[1 << 21];
int cnt = 1;
int g[8][8];
int n, m;
int ans;
// 回溯搜索，当前将第r行第c列的格子填为黑色，基础填涂情况为cur
void dfs(int r, int c, int cur)
{
    // 记忆化+状态压缩，如果填涂情况已被搜索过则直接返回
    cur = cur | (1 << ((r - 1) * (m - 2) + c - 1));
    if (vis[cur] == cnt)
        return;
    vis[cur] = cnt;
    // 检查是否满足条件1与条件2
    bool ok = false;
    int count = 0, prv = 0;
    for (int i = 0; i < 9; i++)
    {
        if (g[r + d[i][0]][c + d[i][1]] == 1 && i % 2)
            ok = true;
        if (i && prv != g[r + d[i][0]][c + d[i][1]])
            count++;
        prv = g[r + d[i][0]][c + d[i][1]];
    }
    if (!ok || count > 2)
        return;
    // 满足条件，为合法填涂，答案+1
    g[r][c] = 1;
    ans++;
    // 继续搜索
    for (int i = 1; i < n - 1; i++)
        for (int j = 1; j < m - 1; j++)
            if (!g[i][j])
                dfs(i, j, cur);
    // 回溯
    g[r][c] = 0;
    return;
}
int main()
{
    scanf("%d %d", &n, &m);
    // 特殊值直接返回
    if (n == 1)
    {
        printf("%d\n", (m + 1) / 2);
        return 0;
    }
    else if (m == 1)
    {
        printf("%d\n", (n + 1) / 2);
        return 0;
    }
    // 枚举所有边缘方格的填涂情况
    // i为顺时针涂黑的边缘方格数量，j为逆时针涂黑的边缘方格数量
    for (int i = 0; i < m + m + n + n - 5; i++)
    {
        for (int j = 0; j < m + m + n + n - 5 - i; j++)
        {
            // 四种情况下（只有左上为黑色，只有右上、右下、左下为白色）
            // 中间方格只能要么都涂黑，或都不涂黑
            // 否则，中间方格都不涂黑也是一种合法填涂
            ans++;
            // 
            if (n == 2 || m == 2 || (i == 0 && j == 0) || ((i == m - 2 || i == m + n - 3 || i == m + m + n - 4) && j + i == m + m + n + n - 6))
                continue;
            cnt++;
            memset(g, 0, sizeof(g));
            // 顺时针填涂所有方格
            for (int k = 0, r = 0, c = 0, l = 1; k <= i; k++)
            {
                g[r][c] = 1;
                if (!(0 <= r + d[l][0] && r + d[l][0] < n && 0 <= c + d[l][1] && c + d[l][1] < m))
                    l += 2;
                r = r + d[l][0];
                c = c + d[l][1];
            }
            // 逆时针填涂所有方格
            for (int k = 0, r = 0, c = 0, l = 7; k <= j; k++)
            {
                g[r][c] = 1;
                if (!(0 <= r - d[l][0] && r - d[l][0] < n && 0 <= c - d[l][1] && c - d[l][1] < m))
                    l -= 2;
                r = r - d[l][0];
                c = c - d[l][1];
            }
            // 回溯搜索中间方格的所有合法填涂情况
            for (int r = 1; r < n - 1; r++)
                for (int c = 1; c < m - 1; c++)
                    dfs(r, c, 0);
        }
    }
    printf("%d\n", ans);
	return 0;
}
```

---

## 作者：yzh_Error404 (赞：2)

[双倍经验1](https://www.luogu.com.cn/problem/P1817)

[双倍经验2](https://www.luogu.com.cn/problem/P4537)

本题正解[插头DP](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E6%8F%92%E5%A4%B4DP&fenlei=256&rsv_pq=efeaadb300051d30&rsv_t=164fn9SvNzwtPlsEPW%2FsxGMonLYh%2F5x%2BS2sSiiANTxSvvAKDxvjU8HUadu0&rqlang=cn&rsv_dl=tb&rsv_enter=1&rsv_sug3=11&rsv_sug1=10&rsv_sug7=101&rsv_sug2=0&rsv_btype=i&inputT=3864&rsv_sug4=4268)，可惜我太垃圾了不会。

一看数据范围 $a \le 6$ ，$b \le 6$ 。

数据范围这么小，~~一看就可以打表~~。

用 $dfs$ 爆搜出分界线的种数即可。

因为分界线有两个端点，两边连过来的方案是一样的，所以我们只考虑以上面和右边为起点的方案。

打表程序：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=10;
struct node
{
	int x,y;
};
int n,m;
int fx[MAXN]={0,-1,1,0,0};
int fy[MAXN]={0,0,0,-1,1};
int vis[MAXN][MAXN];
int ans=0;
inline void dfs(int x,int y)
{
	vis[x][y]=1;
	for(int i=1;i<=4;i++)
	{
		int nx=x+fx[i],ny=y+fy[i];
		if(x<1||x>=n||y<1||y>=m)ans++;//到了矩阵外面，需要计数
		else
        if(!vis[nx][ny])dfs(nx,ny);
	}
	vis[x][y]=0;
}
signed main()
{
	freopen("test.out","w",stdout);
	for(n=1;n<=6;n++)
	{
		printf("{");
		for(m=1;m<=6;m++)
		{
			ans=0;
			for(register int i=1;i<n;i++)
			{
				memset(vis,0,sizeof(vis));
				vis[i][0]=1;
				dfs(i,1);
			}
			for(register int i=1;i<m;i++)
			{
				memset(vis,0,sizeof(vis));
				vis[0][i]=1;
				dfs(1,i);
			}
			printf("%lld",ans);
			if(m!=8)printf(",");
		}
		printf("}");
		if(n!=7)puts(",");
		else puts(";");
	}
	return 0;
}
```
打出来的表：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans[10][10]={{0,2,4,6,8,10,12,14},
				 {2,12,30,56,90,132,182,240},
				 {4,30,104,286,700,1598,3488,7390},
				 {6,56,286,1228,4862,18368,67206,240180},
				 {8,90,700,4862,32000,204294,1274660,7807790},
				 {10,132,1598,18368,204294,2228788,23896710,252488208},
				 {12,182,3488,67206,1274660,23896710,441524056,8056291934}};
signed main()
{
	int n,m;
	scanf("%lld%lld",&n,&m);
	printf("%lld",ans[n-1][m-1]/2);//一定要减一！
   //上一道题的表需要乘2，现在除回来
	return 0;
}
```

---

## 作者：XL4453 (赞：1)



------------
解题思路：

读题，发现数据范围奇小。

考虑搜索，从一端出发，搜索一条合法路径至另一端。

可以发现，其实只要搜索两端就可以了，另外两端的路径一定是相同的。（如果一定要卡，搜索较大的一端并在中途统计答案也未尝不可，但会比较麻烦，优化幅度也不大）

细节上注意只要枚举 1 到 $m-1$ 和 $n-1$ ，因为最后一个点 $m$ 和 $n$ 其实是归属在另一端的。

当然这题也可以打表，但暴力就能过的为什么要表呢？

------------
代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int v[10][10],n,m,dx[5]={0,0,1,-1},dy[5]={1,-1,0,0};
long long ans;
void dfs(int x,int y){
	if(x<1||x>=n||y<1||y>=m){
		ans++;
		return;
	}
	v[x][y]=1;
	for(int i=0;i<=3;i++){
		if(!v[x+dx[i]][y+dy[i]]){
			dfs(x+dx[i],y+dy[i]);
		}
	}
	v[x][y]=0;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<m;i++){
		v[0][i-1]=0;
		v[0][i]=1;
		dfs(1,i);
	}
	v[0][m-1]=0;
	for(int i=1;i<n;i++){
        v[i-1][0]=0;
		v[i][0]=1;
		dfs(i,1);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：light_ght (赞：1)


# dfs


------------
[题目](https://www.luogu.com.cn/problem/P1790)

[**博客食用风味佳**](https://www.luogu.com.cn/blog/Rstar-PanzerTigerII/solution-p1790)

### [双倍经验 ~~真香~~](https://www.luogu.com.cn/problem/P4537)



------------



## 简单分析


------------
数据范围让人很兴奋！直接暴力······吗？

当然不行（大概吧？）！~~给绿题一点面子好不好！~~

- 维护两个边界 $ x , y$ ，如果超出边界 $ {a , b}$  直接使答案计数器+1。由于满足一搜到底的结构，显而易见（大概吧？）可以使用~~爆搜~~ **dfs**。

- 实现过程中，要注意**判重**——使用一个数组来记录是否已经访问过。

- 同时也需要注意判重数组的赋初值、回溯赋值等细节。

 ~~当然您也可以手模之后打表。~~

**详细做法分析请看代码注释。**



------------


------------


## 具体实现+具体说明（dfs版）


------------


贴**核心代码：**（注：本蒟蒻在某些小小的地方做了个反作弊）

```cpp
//By xajdfz OIer ght,programme v1.0.00.0

int a,b,ans;
int X[]={1,-1,0,0},Y[]={0,0,1,-1};	//移动操作
bool been[10][10];	//been[]是标记是否已经访问过の数组 

void pan(int x,int y)	//dfs，对象为两个边界 
{
	if(x<1||y<1||x>=a||y>=b)ans++;	//超出边界，ans+1 
	else
	{
		been[x][y]=true;	//预设该位置已经访问过，准备dfs
		for(int i=0;i<4;i++)          
			if(!been[x+X[i]][y+Y[i]])  
				pan(x+X[i],y+Y[i]);		
		been[x][y]=false;	//dfs完成后回溯
	}return; //啥也不干
}
int main()
{
ios::sync_with_stdio(0);
cin.tie(0)；cout.tie(0);//加速cin、cout(不建议使用，加速完也没有scanf/printf快) 
	cin>>a>>b;
	for(int i=1;i<a;i++)	//第一次以任意一个方向开始dfs。对结果无影响
	{
		memset(been,false,sizeof been);	//初始化been数组为未访问
		been[i][0]=true;	//记录访问
		pan(i,1);	
	}
	for(int i=1;i<b;i++)	//另外一个方向のdfs同理
	{
		memset(been,false,sizeof been);
		been[0][i]=true;
		pan(1,i);
	}
	cout<<ans;
	return 0;
}

```
为防止本蒟蒻重回蓝名发篇题解~忘管理员大大高抬贵手~

逃~


---


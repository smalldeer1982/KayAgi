# 猴子选大王数据再加强版

## 题目描述

有 $n$ 只猴子围成一圈，顺时针编号依次为 $1, 2, 3,\cdots, n$。从第一只猴子开始，不断进行如下操作：顺时针数恰好 $m$ 只猴子，使其出列，再从下一只猴子开始重新计数，如此循环，直到最后只剩下一只猴子。最后剩下来的猴子是这局游戏的获胜者。

现在你需要对于 $n=a,a+1,\cdots,b$ 计算出哪只猴子成为获胜者的次数最多，输出对应的编号。如果有多只猴子成为获胜者的次数均最多，将它们的编号从小到大输出。


## 说明/提示

### 样例解释

| $n=$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $10$ |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| **大王编号** | $1$ | $2$ | $2$ | $1$ | $4$ | $1$ | $4$ | $7$ | $1$ | $4$ |

因此最多的是 $1$ 号，共获胜了 $4$ 回。

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq a \leq b \leq 10 ^ 6$，$m \leq 3000$。


## 样例 #1

### 输入

```
1 10 3```

### 输出

```
4
1```

# 题解

## 作者：asdfo123 (赞：15)

# 约瑟夫问题典型例题
这类问题模板：
> n 个人标号 1~ n。逆时针站一圈，从1号开始，每一次从当前的人逆时针数m个，然后让这个人出局。问最后剩下的人是谁。

我们思考，有 $N$ 个猴子，如果现在一个猴子出列，那么剩下的猴子就变成了 $(n-1)$ 个猴子数数的子问题。

我们设 $f_i$ 为 $i$ 个猴子数数选出的大王编号，那么由于新的子问题要从下一个猴子开始数，编号要加上 $m$ 

那么可以得到递推式子：
$f[1] = 0$

$f[i] = (f[i-1]+m)\ mod \ i\ (i>1) $ 

这样是编号从0开始的，我们想要编号从１开始

那么：
$f[0] = 0$

$f[i] = (f[i-1]+m-1)\ mod \ i+1\ (i>=1) $ 

最后别忘了要从 $a$开始统计最大值...

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000010];
int vis[1000010];
int a,b,m;
int main()
{
	scanf("%d%d%d",&a,&b,&m);
	f[1] = 1;
	int ans = 0;
	for(int i = 1;i <= b;i++)
	{
		f[i] = (f[i-1]+m-1)%i+1;
		if(i>=a)
		{
			vis[f[i]]++;
			ans = max(ans,vis[f[i]]);
		}
	}
	printf("%d\n",ans);
	for(int i = 1;i <= b;i++)
	{
		if(vis[i] == ans) printf("%d ",i);
	}
	return 0;
}
```



---

## 作者：xuanxuan001 (赞：7)

蒟蒻的第三篇题解，第三十三道蓝题。

题目大意

有若干只猴子，数量在$a$到$b$之间，从第一个猴子开始从1开始报数，报到$m$的出圈，请问最后剩下第几只猴子的可能性最大，第一行输出可能性最大的猴子有多少种取值能让他剩下，第二行输出这个猴子是第几个，如果有多个就全部从大到小输出。

这题DP。

$dp_i$表示有$i$个猴子报数最后会剩下第几只猴子，$dp_1=1$。

对于$dp_i$的转移：

1. 先求出第一个出圈的是第几个猴子，为了描述方便，设这只猴子是第$t$只。
2. 将剩下的猴子从第$t+1$只开始重新编号，第$t+1$只编号1，第$t+2$只编号2，$\ldots$,第$t-1$只编号$i-1$
3. 那么剩下的就是新编号的第$dp_{i-1}$只，是旧编号中的$t+dp_{i-1}$只（若大于$i$就需要减）。

看不懂就参考下图（$i=5,m=3,$则$dp_4=1$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/29zw4i7y.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

DP预处理完了以后就将$a$到$b$的所有数做个桶，然后找出现次数最多的就可以了。

代码（由于$t$的名字被桶占了，所以上文中的变量$t$在代码中叫$fir$）：
```
#include<cstdio>
using namespace std;
int a,b,m,fir,dp[1000002],t[1000002],best=1;
int main(){
	scanf("%d%d%d",&a,&b,&m);
	dp[1]=1;
	for(int i=2;i<=b;i++){
		fir=m;//第一个出圈的猴子 
		while(fir>i) fir-=i;//超过了就要减 
		dp[i]=dp[i-1]+fir;//dp[i-1]是剩下的猴子的新编号，所以再加上fir 
		while(dp[i]>i) dp[i]-=i;//超过了就要减 
	}
	for(int i=a;i<=b;i++) t[dp[i]]++;//桶 
	for(int i=1;i<=b;i++) if(t[i]>best) best=t[i];//找出现次数最多的数的出现次数 
	printf("%d\n",best);
	for(int i=1;i<=b;i++) if(t[i]==best) printf("%d ",i);//在循环一遍，找编号 
    return 0;
}
```

---

## 作者：Misaka_Mik0t0 (赞：3)

暴力算法：枚举每个在 $[a,b]$ 范围内的 $i$，求出大王。时间复杂度 $O((b-a)^2m)$，肯定爆。

实际上各种情况猴子的个数是**连续的**。也就是说，当我们要处理的猴子个数为 $i$ 时，先淘汰掉第 $m$ 只猴子，之后剩余 $i-1$ 只猴子。而 $i-1$ 只猴子的情况我们之前已经求过了！设为第 $x$ 只猴子称王，那么 $i$ 只猴子的情况就是从第 $m+1$ 只猴子开始，第 $x$ 只猴子称王。因为 $x\le i-1$，即**第 $(m+1+x-1)\bmod i=(m+x)\bmod i$ 只猴子称王**。

最后再统计一下最大值就好了。

参考代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int read(){
	char ch=getchar();int res=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+ch-'0';
		ch=getchar(); 
	}
	return res;
}
int p[1000005],a,b,m,res;
struct G{
	int num,id;
	bool operator<(G g)const{return num>g.num||num==g.num&&id<g.id;}
}ans[1000005];
int main(){
	a=read();b=read();m=read();
	for(int i=1;i<=b;++i){
		p[i]=(p[i-1]+m)%i;
		if(p[i]==0)p[i]=i;
		ans[i].id=i;
	}
	for(int i=a;i<=b;++i)ans[p[i]].num++;
	sort(ans+1,ans+b+1);
	res=ans[1].num;printf("%d\n",res);
	for(int i=1;ans[i].num==res;++i)printf("%d ",ans[i].id);
	return 0;
}
```

---

## 作者：liuziwen0224 (赞：3)

# problem
有$t$只猴子，$t\in[a,b]$，从第一个猴子开始从1开始报数，报到$m$的出圈，请问最后剩下第几只猴子的可能性最大?

第一行输出可能性最大的猴子有多少次剩下了，第二行输出这个猴子是第几个，多个就从大到小输出。
# solution
动态规划的思想。考虑$dp_i$表示有$i$个猴子报数最后会剩下第几只猴子，$dp_1=1$。

对于$dp_i$的转移，首先先求出第一个出圈的是第几个猴子，比如是第$U$只。剩下的第$U+1$只猴子记为$1$，第$U+2$只编号$2$，$...$，$1$左边的记作$U-1$。这样我们可以看出，剩下的是新编号的第$dp_{i-1}$只，是旧编号中的$U+dp_{i-1}$只，若大于$i$就需要减。


# code

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;
int read(){
	long long a=0,op=1;char c=getchar();
	while(c>'9'||c<'0') {if(c=='-') op=-1;c=getchar();}
	while(c>='0'&&c<='9'){a*=10,a+=c^48,c=getchar();}
	return a*op;
}
const int maxn=1e6+5;
int a,b,m,hed,dp[maxn],t[maxn],best=1;
int main(){
	a=read(),b=read(),m=read();
	dp[1]=1;
	for(int i=2;i<=b;i++){
		hed=m;
		while(hed>i) hed-=i;
		dp[i]=dp[i-1]+hed;
		while(dp[i]>i) dp[i]-=i;
 	}
 	for(int i=a;i<=b;i++) t[dp[i]]++;
 	for(int i=1;i<=b;i++) if(t[i]>best) best=t[i];
 	printf("%d\n",best);
 	for(int i=1;i<=b;i++) if(t[i]==best) printf("%d ",i);
 	return 0;
}

```

---

## 作者：ryf_loser (赞：1)

这一道题是一道约瑟夫问题的延伸题。

如果这一道题用暴力枚举，$O(N^2)$ ，~~直接祭~~。

所以我们必须要想一种 $O(N)$ 的算法解决。

这就要隆重清楚我们的递推了！

我们设 $last$ 为上一次当选的猴子。那么由于新的问题要从下一个猴子开始数。

那么通过推到，我们可以轻松得出递推式：

一开始 $last\rightarrow1$。

接下来每次 $last\rightarrow(last+m-1) \mod i$ 最后再 $+1$。

别忘了要统计最大值。

AC CODE

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a,b,m,last=1,s[1000001],maxx;
int main(){
	scanf ("%d%d%d",&a,&b,&m);
	for (int i=1;i<=b;i++){
		last=(last+m-1)%i+1;//递推公式
		if (i>=a){
			s[last]++;
			maxx=max(maxx,s[last]);求最大值
		}
	}
	printf ("%d\n",maxx);
	for (int i=1;i<=b;i++) 
		if (s[i]==maxx)
			printf ("%d ",i);输出所有可能的猴子
	return 0;
}
```


---

## 作者：AKPC (赞：0)

## 这一题的思路是DP（动态规划）
### 分析
首先定义一个 $f$ 转移数组，$f_i$ 表示的意义是有 $i$ 只猴子的时候选出的大王。

接着，$f_1=1$，因为在只有一只猴子的时候，这一只猴子必定是大王。

然后，由于新的子问题要从下一个猴子开始数，编号要加上 $m$。

最后就可以推状态转移方程了：

$f_i=(f_{i-1}+m-1) \bmod i+1$（前提是 $i \geq 1$）。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a,b,m,f[1000001],t[1000001],maxn=0;
signed main(){
	cin>>a>>b>>m;
	f[1]=1;
	//f[i]=(f[i-1]+m-1)%i+1
	for (int i=1;i<=b;i++){
		f[i]=(f[i-1]+m-1)%i+1;
		if (i>=a) {t[f[i]]++,maxn=max(maxn,t[f[i]]);}
	}
	cout<<maxn<<endl;
	for (int i=1;i<=b;i++) if (t[i]==maxn) cout<<i<<' ';
	return 0;
}
```


---

## 作者：无名ZWH (赞：0)

直接看代码吧（觉得注释比较详细）  
```cpp
#include<bits/stdc++.h>
#define itn int
#define lrzwh for(int i = 1; i <= b; i++) 
using namespace std;
itn a, b, m, wang, c[1000002], ans[1000002], besans = 1;
itn main()
{
    scanf("%d%d%d", &a, &b, &m);
    c[1] = 1;

    for(int i = 2; i <= b; i++)
    {
        wang = m;//第一个出圈的猴子

        for(;wang > i;) wang -= i; //多了，减掉

        c[i] = c[i - 1] + wang; //剩下的猴子编号，记得加第一个出圈的猴子的标号
        
        for(;c[i] > i;) c[i] -= i;//多了，减掉
    } //选大王过程

    for(itn i = a; i <= b; i++) 
	ans[c[i]]++;// 存答案

    lrzwh {
		if(ans[i] > besans) besans = ans[i];//当大王最多的猴子次数
	}
    
    
    printf("%d\n", besans);

    lrzwh{
		if(ans[i] == besans) printf("%d ", i);//编号
	}

    return 0;//记得
}
```



---


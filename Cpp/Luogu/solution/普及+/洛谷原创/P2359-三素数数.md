# 三素数数

## 题目背景

蛟川书院的一道练习题QAQ


## 题目描述

如果一个数的所有连续三位数字都是大于100的素数，则该数称为三素数数。比如113797是一个6位的三素数数。


## 说明/提示

区域动归QAQ


## 样例 #1

### 输入

```
4```

### 输出

```
204```

# 题解

## 作者：dspr (赞：27)

对于一般dp解法下面都有，我这里就不再赘述。
然后我们会发现每一遍dp转移都是一样的，然后转移次数也是一定的，这时我们会想到什么，没错就是矩阵，根据素数判断构造出一个转移矩阵，跑一遍矩阵快速幂，可以跑过$n=10^9$的数据(~~建议出个数据加强版~~)。

**update:无意中看到自己的题解，发现以前写的代码实在丑陋，忍受不了，于是改了一下**

```
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
const int M=1e9+9,_=101;
struct matrix{
    ll a[_][_];
	matrix operator *(matrix b){
		matrix c;
		for(int i=1;i<=99;++i)
			for(int j=1;j<=99;++j){
				c.a[i][j]=0;
				for(int k=1;k<=99;++k)
					c.a[i][j]+=a[i][k]*b.a[k][j]%M;
				c.a[i][j]%=M;
			}
		return c;
	}
}b;
ll a[_*10],c[_],n;
matrix js(matrix x,matrix y){
    matrix z;
    for(int i=1;i<=99;++i)
		for(int j=1;j<=99;++j){
			z.a[i][j]=0;
			for(int k=1;k<=99;++k)
				z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%M;
		}
    return z;
}
int main(){
    cin>>n;n-=3;
    int tt=0;
    for(int i=2;i<=1000;++i)
		for(int j=i+i;j<=1000;j+=i)
			a[j]=1;
    for(int i=100;i<=999;++i)
        if(!a[i]){
            tt++;
            c[i/10]++;
            b.a[i%100][i/10]++;
        }
    if(n==0){cout<<tt;return 0;}
    matrix ans=b;n--;
	while(n){
        if(n&1)ans=ans*b;
        b=b*b;
        n/=2;
    }
    ll t=0;
    for(int i=1;i<=99;++i)
        for(int j=1;j<=99;++j){
            t+=ans.a[i][j]*c[i];
            t%=M;
        }
    cout<<t<<endl;
    return 0;

}

```

---

## 作者：d3ac (赞：22)

设$dp[k][i][j]$表示到了第$k$位，这个数字是$i$，上一个数字是$j$的方案数

+ 初始化 $dp[2][0\to9][0\to9]=1$
+ 枚举第几位$i$，现在的数字$now$，之前的数字$pre$，上上个数字$last$
+ 如果$now*100+pre+10+last$是素数，那么$dp[i][now][pre]+=dp[i-1][pre][last]$

代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define mod 1000000009
using namespace std;
int prime[1200],PRIME[1200],cnt,n,dp[10010][10][10],ans;
void getprime(){
	prime[1]=prime[0]=1; 
	for(int i=2;i<=1010;i++){
		if(!prime[i]) PRIME[++cnt]=i;
		for(int j=1;j<=cnt && i*PRIME[j]<=1010;j++){
			prime[PRIME[j]*i]=1;
			if(!(i%PRIME[j])) {break;}
		}
	}
}
int get(int bai,int shi,int ge){
	return bai*100+shi*10+ge;
}
int main(){
	scanf("%d",&n);
	if(n<3) printf("0"),exit(0);
	getprime();
	for(int i=0;i<=9;i++) for(int j=0;j<=9;j++) dp[2][i][j]=1;
	for(int i=3;i<=n;i++)
		for(int now=1;now<=9;now++)
			for(int pre=0;pre<=9;pre++)
				for(int last=0;last<=9;last++)
					if(!prime[get(now,pre,last)]) 
						dp[i][now][pre]=(dp[i][now][pre]+dp[i-1][pre][last])%mod;
	for(int i=0;i<=9;i++)
		for(int j=0;j<=9;j++)
			ans=(ans+dp[n][i][j])%mod;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Youngsc (赞：9)

[Youngsc](http://youngscc.github.io/)

对于枚举每一位的解法，有的会涉及枚举到不是质数的三位数，那么有的时间就浪费在了这里，枚举一个不是质数的数对我的答案没有任何贡献，我们能不能想办法避免这种情况呢？答案是**肯定的**。

我们可以先通过素数筛将所有的素数筛选出来，然后我们定义$f[i][j]$为共有$i$位数且最后两位数是$j$时有多少个合法数字。

对于转移，我们就可以每句每一个三位质数，然后不用加判断直接更新，设某一质数为p，转移方程则为$f[i][p\ mod\ 100] = {f[i-1][p/10]}$。

亲测32ms。

## 代码如下

（减少代码复制，共创美好洛谷）

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cmath>
# define R register
# define LL long long
# define mod 1000000009

using namespace std;

int n,pri[500],p,f[10010][100],ans;
bool v[1010];

inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c  =getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x\*f;
}

inline int yg(){
    // freopen("submatrix.in","r",stdin);
    // freopen("submatrix.out","w",stdout);
    for(R int i=2; i<=999; ++i)
    {
        if(!v[i]) pri[++p] = i;
        for(R int j=1; j<=p&&pri[j]\*i<=999; ++j)
        {
            v[i\*pri[j]] = 1;
            if(i%pri[j] == 0) break;
        }
    }
    in(n);
    for(R int i=1; i<=p; ++i) if(pri[i]>=100) f[3][pri[i]%100]++;//初始化
    for(R int i=4; i<=n; ++i){
        for(R int j=1; j<=p; ++j)
        {
            if(pri[j]<100) continue;
            f[i][pri[j]%100] = (f[i][pri[j]%100]+f[i-1][pri[j]/10])%mod;//关键点
        }
    }
    for(R int i=1; i<=99; ++i) ans = (ans+f[n][i])%mod;//最后求和答案
    printf("%d",ans);
    return 0;
}

int youngsc = yg();
int main(){;}
```

---

## 作者：cbyybccbyybc (赞：6)

## 题意：
#### **三素数数**，指这个数的**每连续3位数都是质数**。

#### 问在长度为n的所有数中，有多少个三素数数？

## 题解思路：
由于$n$非常的大，所以不能通过暴力枚举$+check$的方式通过此题（~~不然就是红题了~~
#### 所以我采用了**DP（动态规划）**
有题意可以得到，如果保证前面的数都满足三素数数，那么在这个数后面加上一个数，只要满足**后三位数位是素数**，则可以判断这个新数为三素数数，那么我们就可以使用递归，时间复杂度为$O(n)$，**用$f[i][j][k]$表示当数位为$i$，倒数第二位为$j$，最后一位为$k$时的三素数数数量**(滑稽

可以推出$dp$方程：$if$：$a*100+j*10+k$是素数（$a$为在这个三素数数倒数第三位的数），则$f[i][j][k]+=f[i-1][a][j];$

最后我们只要统计$f[n][j][k]$的所有和即可

#### 别忘了每次都取模1000000009

## 代码
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
long long f[10010][15][15];
int vis[1010];
int a[200]={101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997};
//将所有三位素数全部存下来打表，只用判断一下就可以了（能节省一些时间
int main()
{
    memset(f,0,sizeof f);
    memset(vis,0,sizeof vis);
    int n;
    cin>>n;
    for(int i=0;i<143;i++) vis[a[i]]=1;
    for(int i=0;i<143;i++)
    {
        int b=a[i]/10;
        f[3][b%10][a[i]%10]++;//将三位素数提前预处理
    }
    long long Max=0;
    for(int i=4;i<=n;i++)
    {
        for(int j=0;j<=9;j++)
        {
            for(int k=0;k<=9;k++)
            {
                for(int a=0;a<=9;a++)
                {
                    if(vis[a*100+j*10+k]==1) f[i][j][k]+=f[i-1][a][j];
                    //dp转换方程
                    f[i][j][k]%=1000000009;
                    //别忘了取模
                }
            }
        }
    }
    for(int i=0;i<=9;i++)
        for(int j=0;j<=9;j++)
        {
            Max+=f[n][i][j];//统计和
	    Max%=1000000009;//别忘了取模    	
	}
    cout<<Max;//输出即可
    return 0;
}
```

---

## 作者：TMXi (赞：6)

初看这题本以为是求n位质数的个数，我一想这不坑么。。。果断眼瘸飘过233


（又说废话）


动归常规题，比较裸了


对于**符合题意的n-1位数** a，

设a的末两位是i , j .

那么如果i\*100 +  j\*10 +k为质数**（0≤k≤9）**

则以j , k结尾的n位数一定符合题意


方程
dp[i][j][k]=Σ( dp[i-1][h][j] ) (h=1..9, 三位数[u]hjk[/u]为素数)



[color=#AFAFAF]**HINT**[/color]

\* 为了满足“大于100”的要求，dp的时候可以直接从1到9

\* 大于100的素数末尾只能是1,3,7,9

\* 初始化可以打表

\* 鉴于3k神要禁止抄代码，我就不粘代码了23333


---

## 作者：zhangyuhan (赞：2)

做$DP$题，无疑要考虑如下几点：

$1.$状态定义

$2.$状态转移方程

$3.$边界

$4.$目标

那我们来依次分析。

**状态定义**

$f_{i,j,k}$：第$i$位数，最后两位为$j$、$k$，的三素数数个数。

**状态转移方程**

首先，我们知道$j$，$k$，即个位和十位，所以我们考虑枚举百位，设百位为$l$，则有：

$f_{i,j,k}=\sum{f_{i-1,l,j}}(\overline{ljk}$ $is$ $prime$ $)$ 

但是要注意，百位不能为$0$，所以$1<=l<=9$

**边界**

这一点有些复杂，我稍微讲仔细点。

首先，有答案的时候肯定是$n>=3$，所以我们可以考虑初始化$f_{2,i,j}$。

由于答案为累加，所以$f_{2,i,j}=1$。

**但是！**

$i$可能为$0$吗？

所以这是一个坑点。。。

但是$j$可以取$0$。

**目标**

肯定是$\sum{f_{n,i,j}}$ 喽。

$AC$ $Code$

```cpp
#include <iostream>
#include <cmath>
using namespace std;

const int Mod = 1e9 + 9;

int n, f[10010][11][11], ans;

bool is_prime(int x) {
	if (x == 0 || x == 1) return false;
	for (int i=2; i<=sqrt(x); i++)
		if (x % i == 0) return false;
	return true;
}

int main() {
	cin >> n;
	for (int i=1; i<=9; i++)
		for (int j=0; j<=9; j++)
			f[2][i][j] = 1;
	for (int i=3; i<=n; i++)
		for (int j=0; j<=9; j++)
			for (int k=0; k<=9; k++)
				for (int l=1; l<=9; l++)
					if (is_prime(l*100 + j*10 + k))	f[i][j][k] = (f[i][j][k] + f[i-1][l][j]) % Mod;
	for (int i=0; i<=9; i++)
		for (int j=0; j<=9; j++)
			ans = (ans + f[n][i][j]) % Mod;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：梦梦子 (赞：2)

欧拉法线性筛质数+dp（其实不用欧拉法也行）

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int dp[10001][10][10],a[1000],p[1000],r[100],t[10][10][10],cnt=0,cnt2=0,i,c,d,e,j,ans,n;
void premanage()
{
    memset(a,0,sizeof(a));
    memset(p,0,sizeof(p));
    memset(r,0,sizeof(r));
    memset(t,0,sizeof(t));
    memset(dp,0,sizeof(dp));
    for(i=2;i<1000;i++)
    {
        if(!a[i])
        {
            if(i<100)p[++cnt]=i;
            else
            {
                c=i/10%10;d=i%10;e=i/100;
                dp[3][c][d]++;
                if(!t[c][d][0])r[++cnt2]=i%100;
                t[c][d][0]++;
                t[c][d][t[c][d][0]]=e;
            }
        }
        for(j=1;j<=cnt&&i*p[j]<1000;j++)a[i*p[j]]=1;
    }
}
int dpp(int n,int c,int d)
{
    int i;
    if(n<3)return 0;
    if(!dp[n][c][d])for(i=1;i<=t[c][d][0];i++)dp[n][c][d]=(dp[n][c][d]+dpp(n-1,t[c][d][i],c))%1000000009;
    return dp[n][c][d];
}
void solve()
{
for(i=1;i<=cnt2;i++)ans=(ans+dpp(n,r[i]/10,r[i]%10))%1000000009;
}
int main()
{
    scanf("%d",&n);
    premanage();
    solve();
    printf("%d",ans);
    return 0;    
}
```

---

## 作者：Ally_unstoppable (赞：1)

方法和楼下类似，用f[i][j][k]表示i位数以j和k结尾的个数，那么枚举百位即可

麻烦的是初始化数据，其实也不需要打表，按照枚举百位的方法能完成初始化

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[10001][11][11],ans = 0,n;
bool check(int x)//判断素数
{
    if(x == 1)    return false;
    int mid = sqrt(x);
    for(int i = 2; i <= mid; i ++)
    if(x % i == 0)    return false;
    return true;
}
int main()
{
    memset(f,0,sizeof(f));
    for(int i = 1; i <= 9;i ++)
        for(int j = 1; j <= 9; j ++)
        {
            int tmp = 0;
            for(int k = 1; k <= 9;k ++)
            if(check(100*k+10*i+j))    tmp++;
            f[3][i][j] = tmp;
        }
    scanf("%lld",&n);
    for(int i = 4; i <= n; i ++)
    for(int k = 1; k <= 9; k ++) 
        for(int e = 1; e <= 9; e ++)
        {
            for(int j = 1; j <= 9;j ++)
            if(check(100*j+10*e+k))
            f[i][e][k] = (f[i][e][k] + f[i-1][j][e]) % 1000000009;
        }
    for(int i = 1; i <= 9; i ++)
        for(int j=1; j <= 9; j ++)
        ans = (ans + f[n][i][j] ) % 1000000009;
        printf("%lld\n",ans);
}
```

---

## 作者：king_xbz (赞：0)

一道基础的DP题，模拟赛是做到了。来发一波题解。

我们可以开一个三维的数组f[t][i][j],i表示n位数，j表示此时末位数，i表示末位数前一位数，进行三层循环

预处理
-
```cpp
inline void pre()
{
	for(fint i=0;i<=9;i++)
	for(fint j=0;j<=9;j++)
	{
	for(fint k=1;k<=9;k++)
	if(Pri(k*100+j*10+i))
	f[3][i][j]=++cnt;
	cnt=0;
	}
	return ;
}
```
转移方程
-
```cpp
for(fint T=4;T<=n;T++)
for(fint i=0;i<=9;i++)
for(fint j=0;j<=9;j++)
for(fint k=1;k<=9;k++)
if(Pri(k*100+j*10+i))
f[T][i][j]=(f[T][i][j]+f[T-1][j][k]);
```
**注意**：很多题解在循环上都是1-9，这是不对的，因为预处理后当输入3，结果是128，而正确答案是134.

最后上完整代码：
```cpp
#include<bits/stdc++.h>
#define fint register int
#define h 11
#define p 10005
#define int long long
using namespace std;
const int mods=1000000009;
int ans;
int a[p];
int n;
int cnt;
int f[p][h][h];
inline bool Pri(int x);
inline void pd(int x);
inline void pre();
signed main()
{
	//freopen("threeprime.in","r",stdin);
	//freopen("threeprime.out","w",stdout);
	cin>>n;
	pre();
	pd(n);
	cout<<ans%mods;
	return 0;
}

inline void pd(int n)
{
	for(fint T=4;T<=n;T++)
	for(fint i=0;i<=9;i++)
	for(fint j=0;j<=9;j++)
	for(fint k=1;k<=9;k++)
	if(Pri(k*100+j*10+i))
	f[T][i][j]=(f[T][i][j]+f[T-1][j][k])%mods;
	for(fint i=0;i<=9;i++)
	for(fint j=0;j<=9;j++)
	ans+=f[n][i][j],f[n][i][j]%=mods;
	return ;
}

inline bool Pri(int x)
{
	if(x==0||x==1)
	return 0;
	if(x==2||x==3)
	return 1;
	if(x%6!=5&&x%6!=1)
	return 0;
	for(fint i=5;i<=sqrt(x);i++)
	if(x%i==0||x%(i+2)==0)	
	return 0;
	return 1;
}

inline void pre()
{
	for(fint i=0;i<=9;i++)
	for(fint j=0;j<=9;j++)
	{
	for(fint k=1;k<=9;k++)
	if(Pri(k*100+j*10+i))
	f[3][i][j]=++cnt;
	cnt=0;
	}
	return ;
}
```
祝大家AC愉快

---

## 作者：wtyqwq (赞：0)

- [P2359 三素数数](https://www.luogu.com.cn/problem/P2359)

- 解题思路：简单的数位 $\text{DP}$。令 $f(i,j,k)$ 表示当前在算前 $i$ 位的总的“三素数数”个数，且第 $i$ 为数字 $j$，第 $i - 1$ 位数字 $k$ 的方案数。状态转移方程：

  $$f(i,j,k)=\sum_{(j\times 100+k\times 10 + w)\in \mathbb{P}} f(i-1,k,w)(3\le i\le n,1\le j\le 9, 0\le k,w\le 9)$$

  初始状态：$f(2,0\sim 9,0\sim 9)=1$。
  
  目标状态：$\sum_{i = 1}^9 \sum_{j = 0} ^ 9 f(n, i, j)$。
  
  预处理小于 $1000$ 的质数表即可做到在 $O(1)$ 的时间复杂度内判断状态转移方程中 $j\times 100+k\times 10 + w$ 是否是质数。

------------
```cpp
#include <stdio.h>
#define N 10005
#define SIZE 1000
#define mod 1000000009
int f[N][10][10], n, res;
bool vis[SIZE + 5];
void GetPrime(int n) {
	vis[1] = true;
	for (int i = 2; i * i <= n; ++i)
		if (vis[i] == false)
			for (int j = i * i; j <= n; j += i) vis[j] = true;
}
int main() {
	GetPrime(SIZE);
	scanf("%d", &n);
	for (int i = 0; i < 10; ++i)
		for (int j = 0; j < 10; ++j) f[2][i][j] = 1;
	for (int i = 3; i <= n; ++i)
		for (int j = 1; j < 10; ++j)
			for (int k = 0; k < 10; ++k)
				for (int w = 0; w < 10; ++w)
					if (!vis[j * 100 + k * 10 + w])
						f[i][j][k] = (f[i][j][k] + f[i - 1][k][w]) % mod;
	for (int i = 0; i < 10; ++i)
		for (int j = 0; j < 10; ++j) res = (res + f[n][i][j]) % mod;
	printf("%d\n", res);
	return 0;
}
```
- 算法标签：数位动态规划。

- 时间复杂度：$O(1000n)$。

- 空间复杂度：$O(100n)$。

- 期望得分：$100$ 分。[提交记录](https://www.luogu.com.cn/record/33346075)。

---

## 作者：qianfujia (赞：0)

### 滚动数组优化
**除了楼下那位用矩阵快速幂的巨佬，其他人应该都是用空间**$O(100N)$**的吧**

我来一发**滚动数组**

因为只跟前一个状态有关，所以只需存一个一维数组即可

空间$O(1)$

### Code(代码后有惊喜)

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110];
int dp[110];
int prime[1010];
bool b[1010];
int main()
{
	for(int i = 2; i <= 1000; ++ i)
	{
		if(! b[i])
		{
			prime[++ prime[0]] = i;
			if(i > 100)
				++ dp[i % 100];
			for(int j = i * 2; j <= 1000; j += i)
				b[j] = true;
		}
	}
	int n;
	scanf("%d", &n);
	for(int i = 4; i <= n; ++ i)
	{
	    for(int j = 0; j <= 100; ++ j)
	        a[j] = dp[j];
	    memset(dp, 0, sizeof(dp));
	    for(int j = 26; j <= prime[0]; ++ j)
			dp[prime[j] % 100] = (dp[prime[j] % 100] + a[prime[j] / 10]) % 1000000009;
	}
	int Ans = 0;
	for(int i = 0; i <= 100; ++ i)
		Ans = (Ans + dp[i]) % 1000000009;
	printf("%d", Ans);
	return 0;
}
```

再给矩阵大佬的思路给个解释

先看一段二素数数的dp

```cpp
dp[1,3,7,9] += dp[1]
dp[1,7] += dp[3]
dp[1,3,9] += dp[7]
dp[7] += dp[9]
```
如此周而复始

考虑一个矩阵B，使$$(a_1,a_3,a_7,a_9)*B$$
等于
$$(a_1+a_3+a_7,a_1+a_7,a_1+a_3+a_9,a_1 + a_7)$$
易得
$$B=$$
$$1\ 1\ 1\ 1$$
$$1\ 0\ 1\ 0$$
$$1\ 1\ 0\ 1$$
$$0\ 0\ 1\ 0$$
$$\therefore Ans=B^k*a$$
统计一遍即可

三素数数则只是B更大，a更长而已

同样思路计算即可

Code
详见他的代码

---


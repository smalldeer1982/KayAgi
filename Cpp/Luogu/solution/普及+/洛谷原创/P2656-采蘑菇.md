# 采蘑菇

## 题目描述

小胖和 ZYR 要去 ESQMS 森林采蘑菇。

ESQMS 森林间有 $N$ 个小树丛，$M$ 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。

比如，一条路上有 $4$ 个蘑菇，这条路的“恢复系数”为 $0.7$，则第一~四次经过这条路径所能采到的蘑菇数量分别为 $4,2,1,0$。

现在，小胖和 ZYR 从 $S$ 号小树丛出发，求他们最多能采到多少蘑菇。


## 说明/提示

对于 $30\%$ 的数据，$N\le 7$，$M\le15$

另有 $30\%$ 的数据，满足所有“恢复系数”为 $0$。

对于 $100\%$ 的数据，$1
\le N\le 8\times 10^4$，$1\le M\le 2\times 10^5$，$0\le\text{恢复系数}\le 0.8$ 且最多有一位小数， $1\le S\le N$。

## 样例 #1

### 输入

```
3 3
1 2 4 0.5
1 3 7 0.1
2 3 4 0.6
1```

### 输出

```
8```

# 题解

## 作者：银杉水杉秃杉 (赞：45)

看到这道题所有题解都被撤了，我啪的一声就打开了博客，很快啊！

题是很简单的啊，我们就按题目给的标签（缩点 + spfa）做，不要整些歪门邪道的（像 dp 等什么的，跑的又慢还阴间）。

先跑 tarjan 缩点后图变成一个 DAG ，将每个强连通分量能采的蘑菇数算出来（包括恢复的蘑菇），最后跑 spfa 求最长路即可。相当于每到一个强连通分量就把它里面的蘑菇采光。

注意一点，这道题是不用开 double 的，刚开始记录恢复系数时乘以 $10$ 就可以保证是 int 类型，求恢复的蘑菇是再整除以 $10$，这样就可以保证是向下取整的。

相信来做这道题的同学们都是会 spfa 和 tarjan 的哈，不会的建议可以先去学学再来做这道题，因为可能没有比这个更简单更容易理解的做法 QwQ

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 8e4 + 10, M = 2e5 + 10;
int n, m, t, cnt, tot, T, s, ans;
int head[N], dfn[N], low[N], vis[N];
int col[N], H[N], sum[N], dis[N], V[N];
struct edge
{
    int from, to, next, val, k;
} e[M], E[M];
stack<int> st;
queue<int> q;
void addedge(int u, int v, int w, int k)
{
    e[++t] = (edge){u, v, head[u], w, k};
    head[u] = t;
}
void add(int u, int v, int w)
{
    E[++T].to = v;
    E[T].next = H[u];
    E[T].val = w;
    H[u] = T;
}
void tarjan(int u)//tarjan缩点模板
{
    dfn[u] = low[u] = ++cnt;
    vis[u] = 1;
    st.push(u);
    for (int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].to;
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u])
    {
        tot++;
        int v;
        do
        {
            v = st.top();
            st.pop();
            col[v] = tot;
            vis[v] = 0;
        } while (v != u);
    }
}
void spfa(int s)//spfa跑最长路
{
    memset(dis, -1, sizeof(dis));
    memset(V, 0, sizeof(V));
    dis[s] = sum[s];
    V[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        V[u] = 0;
        for (int i = H[u]; i; i = E[i].next)
        {
            int v = E[i].to, w = E[i].val;
            if (dis[v] < dis[u] + w + sum[v])
            {
                dis[v] = dis[u] + w + sum[v];
                if (!V[v])
                {
                    V[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int x, y, z;
        double k;
        scanf("%d%d%d%lf", &x, &y, &z, &k);
        addedge(x, y, z, k * 10);//先让恢复系数乘10
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i);
    for (int i = 1; i <= m; i++)
    {
        int x = e[i].from, y = e[i].to, z = e[i].val, k = e[i].k;
        if (col[x] == col[y])
            while (z)//同一个强连通分量就统计蘑菇数
            {
                sum[col[x]] += z;
                z = z * k / 10;//再整除10
            }
        else
            add(col[x], col[y], z);//不是同一个强连通分量就建边
    }
    scanf("%d", &s);
    s = col[s];
    spfa(s);
    for (int i = 1; i <= tot; i++)
        ans = max(ans, dis[i]);//终点是未知的，所以通过比较dis找到最长路
    printf("%d\n", ans);
    return 0;
}
```

顺便说说，人虽然退役了，题解还是要写的哈。

谢谢朋友们！

---

## 作者：Demon_master (赞：29)

看着一旁的同学调了一个上午了，我觉得应该写一篇题解来帮助他！

看一下题，可一很快地反应出这个题是 ` tarjan + dfs ` 得答案。

但是有个问题亟待解决：

1.缩点后的边权如何处理？

答：把它加在点权里，因为是`dfs`，最后加上点权回溯就可以了。

2.恢复系数如何处理？

答：因为是有向图，所以只有在环里的才有用，在环里的边才回多次走。关于浮点数，可以不用存，在读入时直接把一条边最多可以摘得的蘑菇算出来，存在边里。


由于本人文笔不好，其余请看代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+99,maxm=2e6+12;
struct E{
	int f,t,n,v,v_;
}edge_old[maxn];
int m,n,B,l_old,head_old[maxn];//存旧图

inline long long read_int(){
	long long x=0;bool f=0;char c=getchar();
	while (c<'0'||c>'9'){if (c=='-')f=1;c=getchar();}
	while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return f?-x:x;
}

stack<int> p;
int tme,low[maxn],dfn[maxn],belong[maxn],tot,vis[maxn];
void tarijan(int num){
	low[num]=dfn[num]=++tme;
	p.push(num);
	for(int i=head_old[num];i;i=edge_old[i].n){
		int t=edge_old[i].t;
		if(vis[t]==-1) {continue;}
		if(dfn[t]) low[num]=min(low[num],dfn[t]);
		else{
			tarijan(t);
			low[num]=min(low[num],low[t]);
		}
	}
	if(low[num]==dfn[num]){
		++tot;
		while(1){
			int c=p.top();
			p.pop();
			belong[c]=tot;
			vis[c]=-1;
			if(c==num) break;
		}
	}
}
//tarjan 模板

E edge[maxn];
int head[maxn],l,power[maxn];
inline void builid_new(){//建新图
	for(int i=1;i<=l_old;i++){
		int t=belong[edge_old[i].t],f=belong[edge_old[i].f];
		if(f==t){
			power[f]+=edge_old[i].v_;//注意，边权转点权
			continue;
		}
		l++,edge[l]=(E){f,t,head[f],edge_old[i].v,0},head[f]=l;
	}
}

int dp[maxn];
void dfs(int num){
	if(dp[num]) return;//记忆化，不然回重复计算出错
	int ans=0;
	for(int i=head[num];i;i=edge[i].n){
		int t=edge[i].t;
		dfs(t);
		ans=max(ans,dp[t]+edge[i].v);
	}
	dp[num]+=power[num];//加上点权
	dp[num]+=ans;
	return;
}

int ans=0;
inline void work(){
	dfs(belong[B]);
	printf("%d\n",dp[belong[B]]);
}

inline void read(){
	n=read_int(),m=read_int();
	for(int i=1;i<=m;i++){
		int f=read_int(),t=read_int(),v_=0,fz,v=read_int();
		long double xs;
		fz=v;
		scanf("%Lf",&xs);
		while(fz){
			v_+=fz;
			fz*=xs;//提前吧回复系数的蘑菇数算出来
		}
		l_old++,edge_old[l_old]=(E){f,t,head_old[f],v,v_},head_old[f]=l_old;
	}
	B=read_int();
	tarijan(B);
	builid_new();
	work();
}

int main (){
	read();
}
```


本人第一篇题解，跪求过。

---

## 作者：Aryper (赞：11)

采蘑菇

已通过新数据。

本来以为 ```read()``` 两次可以直接读入它的系数，没想到它的系数还可以是 0，然后居然读入超时了。考场上要是没反应到系数为 0 的情况估计当场去世了。（投机分子的悲剧）

我们发现这个题很 DP，所以意识上往 DP 靠。但显然一张平凡的图并没有 DP 的方法，我们需要转化。

于是想到 SCC 缩点，把改图缩为有向无环图，然后 DP。

然后就好处理了，一个 SCC 内的所有边是可以通过无限转圈取完的，所以可以把这种边不断取得到这个点的权值。问题是取这个边取完需要多少次？经过计算器瞎按（或者算个 $\log$），只要乘上 97 次 0.8，就可以让 $2^{31}-1$ 的下取整变成 0。显然这个边数是允许这样瞎搞的。

然后就是一个普通的 DAG 上 DP。原来没有使用记忆化也能过，但毕竟复杂度是错的，所以就改了一下。

原来这里提了一嘴这个错误，但是因为人比较懒所以就没改，也就只是提了一嘴。后来有人提出来了，我觉得不改可能不太合适所以就加了记忆化。实际上只有几句话，一般人都会写。。。

然后就过了。

时间复杂度 $O(n+m+m\log_k \dfrac{1}{w})$。

代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=8e4,M=2e5;

ll n,m,u,v,w,s,top,tot,cnt,tc,num;

ll ver[M+5],nxt[M+5],wt[M+5],k[M+5],head[N+5];

ll vc[M+5],nc[M+5],wc[M+5],hc[N+5];

ll dfn[N+5],low[N+5],stk[N+5],c[N+5],val[N+5],f[N+5];

bool ins[N+5],vis[N+5];

char ch;

ll dp(ll p) {
	if(vis[p]) return f[p];vis[p]=1;
	ll ma=0;
	for(ll i=hc[p];i;i=nc[i]) {
		ma=max(ma,dp(vc[i])+wc[i]);
	}
	return f[p]=ma+val[p];
}

void tarjan(ll x) {
	dfn[x]=low[x]=++num;
	stk[++top]=x;ins[x]=1;
	for(ll i=head[x];i;i=nxt[i]) {
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);low[x]=min(low[x],low[ver[i]]);
		}
		else {
			if(ins[ver[i]]) low[x]=min(low[x],dfn[ver[i]]);
		}
	}
	if(dfn[x]==low[x]) {
		cnt++;
		do{
			ins[stk[top]]=0;
			c[stk[top]]=cnt;
		} while(x!=stk[top--]);
	}
}

void add(ll u,ll v,ll w,ll tmpk) {
	ver[++tot]=v;wt[tot]=w;k[tot]=tmpk;
	nxt[tot]=head[u];head[u]=tot;
}

void addc(ll u,ll v,ll w) {
	vc[++tc]=v;wc[tc]=w;
	nc[tc]=hc[u];hc[u]=tc;
}

inline ll read() {
	ll ret=0,f=1;ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') {ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
	return ret*f;
}

void write(ll x) {
	static char buf[22];static ll len=-1;
	if(x>=0) {
		do{buf[++len]=x%10+48;x/=10;}while(x);
	}
	else {
		putchar('-');
		do{buf[++len]=-(x%10)+48;x/=10;}while(x);
	}
	while(len>=0) putchar(buf[len--]);
}

int main() {
	
    n=read();m=read();

	for(ll i=1;i<=m;i++) {
		ll tmpk;
		u=read();v=read();w=read();tmpk=read();
		if(ch=='.') tmpk=read();
		add(u,v,w,tmpk);
	}

	s=read();

	for(ll i=1;i<=n;i++) {
		if(!dfn[i]) tarjan(i);
	}

	for(ll i=1;i<=n;i++) {
		for(ll j=head[i];j;j=nxt[j]) {
			if(c[i]==c[ver[j]]) {
				while(wt[j]>0) {
					val[c[i]]+=wt[j];
					wt[j]=wt[j]*k[j]/10;
				}
				continue;
			}
			addc(c[i],c[ver[j]],wt[j]);
		}
	}

	write(dp(c[s]));
	
	return 0;
}

```


---

## 作者：Erinyes (赞：7)

## Part 1：算法分析
这道题看起来像是在求一个有向图的最长路径，但是由于每条边可以重复经过，并且经过后得到的权值还不同，所以不能**直接**用动态规划求解。

由于每条边都可以重复经过，所以如果几个点构成了一个两两均可互相到达的环时，这个环中的所有边就都可以被重复经过无数次，也就是说，这条边的作用可以被发挥到最大。

所以，我们只需要找出所有的“环”，将这个“环”内的价值总和处理完，再在缩点后的图的拓扑序列上动态规划求解出最长路径即可。

## Part 2：题目求解
对于缩点的问题，最好的方法当然是使用 [Tarjan 算法](https://baike.baidu.com/item/tarjan%E7%AE%97%E6%B3%95/10687825)来求解。
```cpp
void tarjan(int x){
	dfn[x]=low[x]=++num; //当到达一个新的节点时，将它的追溯值（low）标记为它的时间戳（dfn） 
	sta.push(x),in[x]=1; //将这个点入栈 
	for(int i=h[x];i;i=t[i].next){ //枚举每条出边 
		int y=t[i].to;
		if(!dfn[y]){ //如果这个点没有被访问过，则递归访问 
			tarjan(y);
			low[x]=min(low[x],low[y]); //更新追溯值 
		}else if(in[y]) low[x]=min(low[x],dfn[y]); //如果这个子节点在栈里，则也需要更新追溯值 
	}
	if(dfn[x]==low[x]){ //找到了一个强连通分量 
		cnt++;
		int y;
		do{ //将这个强连通分量中的所有的点出栈，并将它染色 
			y=sta.top(); sta.pop(); in[y]=0;
			c[y]=cnt;
		}while(x!=y);
	}
}
```
接下来我们就需要通过枚举每条边，来实现缩点的过程。
```cpp
for(int x=1;x<=n;x++){ //枚举边的起点 
	for(int i=h[x];i;i=t[i].next){ //枚举每条出边 
		int y=t[i].to;
		if(c[x]!=c[y]){ //如果这两个点不在同一个强连通分量中，则需要将这两个点所在的强连通分量连一条边 
			addc(c[x],c[y],t[i].v); //两个强连通分量之间的边只能被经过一次（DAG），所以边权就是原本两个点的边权 
			rd[c[y]]++; //统计入度 
		}else{
			int s=0,a=t[i].v;
			while(a){ //将这条边所能贡献的最大权值累加起来 
				s+=a;
				a*=t[i].g; //g就是这条边的恢复系数 
				a/=10;
			}
			sum[c[x]]+=s; //sum[i]就是编号为i的强连通分量中的边权和
		}
	}
}
```
然后就是将这个缩点后的有向无环图进行拓扑排序，并在拓扑序列上进行动态规划。
```cpp
void toposort(){
	//f[i]定义为起点s到i采到的最大的蘑菇数 
	queue<int> q; //用队列来储存入度为0的点 
    for(int i=1;i<=cnt;i++){
       	if(!rd[i]) q.push(i); //将入度为0的强连通分量入队 
    	f[i]=-INF; //DP初始化 
    }
    f[c[s]]=sum[c[s]]; //将起点s所在的强连通分量的DP值赋值为边权总和 
    while(!q.empty()){
        int x=q.front(); q.pop(); //取出队头，并将它出队 
        for(int i=hc[x];i;i=tc[i].next){ //枚举这个强连通分量的每条出边 
            int y=tc[i].to;
            f[y]=max(f[y],f[x]+tc[i].v+sum[y]); //用这个点的父节点的DP值来更新它 
            rd[y]--; //将子节点的入度减1 
            if(!rd[y]) q.push(y); //将入度为0的点入队 
        }
    }
}
```
由于每一个节点的 DP 值都不同（相当于结束的点不一定），所以需要将所有的 DP 值扫描一边，求出最大值。
```cpp
int ans=0;
for(int i=1;i<=cnt;i++) ans=max(ans,f[i]);
```
## Part 3：Code
```cpp
#include<bits/stdc++.h>
#define maxn 200005
#define INF 0x7fffffff
using namespace std;
struct node{int to,next,v,g;};
node t[maxn*2],tc[maxn*2];
int n,m,s;
int tot,totc,cnt,num;
int h[maxn],hc[maxn],dfn[maxn],low[maxn],c[maxn],in[maxn],sum[maxn],rd[maxn],f[maxn];
stack<int> sta;
void add(int x,int y,int z,int l){ //加边
	t[++tot].to=y;
	t[tot].next=h[x];
	t[tot].v=z;
	t[tot].g=l;
	h[x]=tot;
}
void addc(int x,int y,int z){ //新图加边
	tc[++totc].to=y;
	tc[totc].next=hc[x];
	tc[totc].v=z;
	hc[x]=totc;
}
void tarjan(int x){
	dfn[x]=low[x]=++num; //当到达一个新的节点时，将它的追溯值（low）标记为它的时间戳（dfn） 
	sta.push(x),in[x]=1; //将这个点入栈 
	for(int i=h[x];i;i=t[i].next){ //枚举每条出边 
		int y=t[i].to;
		if(!dfn[y]){ //如果这个点没有被访问过，则递归访问 
			tarjan(y);
			low[x]=min(low[x],low[y]); //更新追溯值 
		}else if(in[y]) low[x]=min(low[x],dfn[y]); //如果这个子节点在栈里，则也需要更新追溯值 
	}
	if(dfn[x]==low[x]){ //找到了一个强连通分量 
		cnt++;
		int y;
		do{ //将这个强连通分量中的所有的点出栈，并将它染色 
			y=sta.top(); sta.pop(); in[y]=0;
			c[y]=cnt;
		}while(x!=y);
	}
}
void toposort(){
	//f[i]定义为起点s到i采到的最大的蘑菇数 
	queue<int> q; //用队列来储存入度为0的点 
    for(int i=1;i<=cnt;i++){
       	if(!rd[i]) q.push(i); //将入度为0的强连通分量入队 
    	f[i]=-INF; //DP初始化 
    }
    f[c[s]]=sum[c[s]]; //将起点s所在的强连通分量的DP值赋值为边权总和 
    while(!q.empty()){
        int x=q.front(); q.pop(); //取出队头，并将它出队 
        for(int i=hc[x];i;i=tc[i].next){ //枚举这个强连通分量的每条出边 
            int y=tc[i].to;
            f[y]=max(f[y],f[x]+tc[i].v+sum[y]); //用这个点的父节点的DP值来更新它 
            rd[y]--; //将子节点的入度减1 
            if(!rd[y]) q.push(y); //将入度为0的点入队 
        }
    }
}
int main(){
	int x,y,z;
	double l;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d %d %d %lf",&x,&y,&z,&l);
		add(x,y,z,int(l*10)); //将恢复系数乘10，用整型边储存，减少精度损耗
	}
	for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	for(int x=1;x<=n;x++){ //枚举边的起点 
		for(int i=h[x];i;i=t[i].next){ //枚举每条出边 
			int y=t[i].to;
			if(c[x]!=c[y]){ //如果这两个点不在同一个强连通分量中，则需要将这两个点所在的强连通分量连一条边 
				addc(c[x],c[y],t[i].v); //两个强连通分量之间的边只能被经过一次（DAG），所以边权就是原本两个点的边权 
				rd[c[y]]++; //统计入度 
			}else{
				int s=0,a=t[i].v;
				while(a){ //将这条边所能贡献的最大权值累加起来 
					s+=a;
					a*=t[i].g; //g就是这条边的恢复系数 
					a/=10;
				}
				sum[c[x]]+=s; //sum[i]就是编号为i的强连通分量中的边权和
			}
		}
	}
	scanf("%d",&s);
	toposort();
	int ans=0;
	for(int i=1;i<=cnt;i++) ans=max(ans,f[i]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Gao_yc (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P2656)

$ \mathcal{Solution} $：

##### 看见还没有 _spfa_ 的题解 ~~（而且题目标签是 _spfa_ ）~~，就来写一篇。

如果没有这个“恢复系数”（或“恢复系数”为 0）且图中无环（DAG），可以直接用 _spfa_ 求最长路，可是每次走过一条边后，这条边的边权会发生变化。

我们注意到，如果一条边可以多次经过，不断走这条边直到边权变为 0 显然最优，可以直接处理边权，于是边权改变的问题就能解决。

那就要判断每条边是否能够多次经过，而能够多次经过的边，两个点一定在同一个强连通分量内，所以只需要用 _tarjan_ 算法判断强连通分量并缩点为 DAG ，然后再 _spfa_ 跑最长路，问题就解决了。

注意用 double 存“恢复系数”的话会挂。


代码（我的代码可能有些冗长）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,m,s,tot,head[N],ver[N],nxt[N],edge[N];
int u[N],v[N],w[N];float h[N];
void add(int u,int v,int w){
	ver[++tot]=v,edge[tot]=w;nxt[tot]=head[u],head[u]=tot;
}
int dfn[N],num,low[N],top,stac[N],cnt,c[N],ww[N];
bool ins[N];
void tarjan(int x){
	low[x]=dfn[x]=++num;
	stac[++top]=x,ins[x]=1;
	for(int i=head[x],y;i;i=nxt[i])
	{
		y=ver[i];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y]) 
		{
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(low[x]==dfn[x])
	{
		cnt++;int y;
		do{
			y=stac[top--],ins[y]=0;
			c[y]=cnt;
		}while(x!=y);
	}
}
void init(){ 
	tot=0;
	memset(head,0,sizeof(head));
	memset(ver,0,sizeof(ver));
	memset(nxt,0,sizeof(nxt));
	memset(edge,0,sizeof(edge));
}
int d[N],ans;
bool vi[N];
queue<int> q;
void spfa(){
	d[s]=0,vi[s]=1;
	q.push(s);
	while(q.size())
	{
		int x=q.front();q.pop();vi[x]=0;
		for(int i=head[x],y,z;i;i=nxt[i])
		{
			y=ver[i],z=edge[i];
			if(d[y]<=d[x]+z)
			{
				d[y]=d[x]+z;
				if(!vi[y]) q.push(y),vi[y]=1;
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%f",&u[i],&v[i],&w[i],&h[i]);
		add(u[i],v[i],1);//在tarjan中没用到边权，所以此时建图边权随意 。 
	}
	for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	init();//缩点前清空图
	//缩点后强连通分量内的边权实际存在一个点中，可以把一个点i拆为i和i+cnt，i作为入点的点，i+cnt作为出点的点。
	for(int i=1;i<=m;i++){
		if(c[u[i]]==c[v[i]])
		{
			ww[c[u[i]]]+=w[i];
			while(w[i])
			{
				w[i]=w[i]*h[i];
				ww[c[u[i]]]+=w[i];
			}
		}
		else add(c[u[i]]+cnt,c[v[i]],w[i]);
	}
	for(int i=1;i<=cnt;i++) add(i,i+cnt,ww[i]); //将强连通分量内的边权作为i至i+cnt的边权 
	scanf("%d",&s);
	s=c[s];
	spfa();
	for(int i=1;i<=2*cnt;i++) ans=max(ans,d[i]);
	printf("%d\n",ans);
    return 0;
}
```
我的缩点后的操作有点奇异，可以用自己的方法建图。

如果对我的算法有疑问，欢迎在评论区中评论。

---

## 作者：luoyx (赞：4)

首先整理一下思路，题目给出一个有向图，每条边可以走无数次，但获得的蘑菇数减少。

于是我们就自然地想到 `tarjan` 缩点了。在一个环内的边可以一直走，直到边权将为 $0$。缩点后的图变为 `DAG` ，所以环外的点就只能走一次。

最后在 `DAG` 上跑最长路就行，可以用拓扑，也可以用 `spfa` 或 `dijkstra` 。这里我用的是 `spfa` 。当然要是怕被卡，topo时间复杂度确实比 `spfa` 稳定。

具体细节放在代码注释里了。
```cpp
#include <bits/stdc++.h>
#define N 80005
#define M 200005
using namespace std;
int n,m;
int u,v,w;
int hf[M];
double rd;
/*这里要注意精度的问题，直接存double精度不够， 
题目中也注明了恢复值为一位小数，所以乘十后存进int型的数组hf中 
*/ 
int head[N],ecnt;
struct edge{
	int v,w,nxt;
}e[M];
int head2[N],ecnt2;
struct edge2{
	int v,w,nxt;
}e2[M];//链式前项星存初始图和缩点后的图 
void add(int u,int v,int w){
	e[ecnt].v=v;
	e[ecnt].nxt=head[u];
	e[ecnt].w=w;
	head[u]=ecnt;
	ecnt++;
}
void add2(int u,int v,int w){
	e2[ecnt2].v=v;
	e2[ecnt2].nxt=head2[u];
	e2[ecnt2].w=w;
	head2[u]=ecnt2;
	ecnt2++;
}//加边函数 
int dfn[N],low[N],color[N],cl_cnt;
int cl_w[N];
int windex;
stack<int> st;
void tarjan(int u){//tarjan缩点模板 
	dfn[u]=low[u]=++windex;
	st.push(u);
	for(int i=head[u];i+1;i=e[i].nxt){
		int v=e[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!color[v]) low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		cl_cnt++;
		while(st.top()!=u){
			int o=st.top();
			st.pop();
			color[o]=cl_cnt;
		}
		st.pop();
		color[u]=cl_cnt;
	}
}
int dfs(int cur,int hf){//递归求一条边多次经过获得蘑菇数量之和 
	if(cur==0) return 0;
	else return cur+dfs(cur*hf/10,hf);
}
int dis[N],in[N];
int s;
void spfa(){//spfa求最长路 
	queue<int> q;
	q.push(color[s]);
	dis[color[s]]=cl_w[color[s]];
	int ans=dis[color[s]];//ans储存最大值 
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head2[u];i+1;i=e2[i].nxt){
			int v=e2[i].v;
			if(dis[v]<dis[u]+e2[i].w+cl_w[v]){
				dis[v]=dis[u]+e2[i].w+cl_w[v];
				ans=max(ans,dis[v]);
				q.push(v);
			}
		}
	}
	//for(int i=1;i<=cl_cnt;i++) cout<<dis[i]<<endl;
	cout<<ans;
}
int main(){
	cin>>n>>m;
	memset(head,-1,sizeof(head));
	memset(head2,-1,sizeof(head2));
	/*不要忘记初始化head，否则会死循环
	（不要问我是怎么知道的，每次写都会忘）*/ 
	for(int i=1;i<=m;i++){
		cin>>u>>v>>w>>rd;
		hf[i-1]=rd*10;//因为这个位置wa了好久，i从一开始，ecnt从零开始，所以要减一 
		add(u,v,w);
	}
	cin>>s;
	for(int i=1;i<=n;i++){ 
		if(!dfn[i]) tarjan(i);
	}
	for(int i=1;i<=n;i++){
		for(int j=head[i];j+1;j=e[j].nxt){
			u=i;
			v=e[j].v;//看着舒服一些 
			if(color[u]==color[v]){
				cl_w[color[u]]+=dfs(e[j].w,hf[j]);
				//如果两点在同一个强连通分量中，就让强连通分量的权值加等于每次经过的边权 
			}
			else{
				add2(color[u],color[v],e[j].w);
				//不在同一个强连通分量中就加一条链接两个强连通分量的边 
			}
		}
	}
	spfa();//最长路 
	return 0;//养成好习惯 
}
/*
4 5
1 2 4 0.5
2 1 4 0.5
2 3 4 0.5
3 4 4 0.5
4 3 4 0.5
1
*/ 
```


---

## 作者：Xu_brezza (赞：3)

刚学完强连通分量缩点模板，~~就来水这题了~~

建议做这题之前先去看看[板子](https://www.luogu.com.cn/problem/P3387)，就会豁然开朗。

题意 ： 一个有向图，可以重复经过边，每条边经过一次后边权就会变成该边原来的边权乘以他的恢复系数，求从给定起点最大边权之和是多少。

分析 ： 不难发现，可以重复经过的边，能重复一次就能重复第二次，然后无数次，换句话说，他在强连通分量里。有了这个结论，我们就可以先强连通分量缩点，强连通分量内每一条边都可以一直取边权直到为 $0$ ,最后缩成的点的点权就是边权和，这样一次深搜就能求出最大权值和，用动态规划实现。设 $f_{i}$ 表示从起点到该点路径的最大值，转移方程就是 $f_{i} = max\left \{ f_{to_{i}} + val_{i-to_{i}} \right \}$ 最后加上点权。

PS：精度一定好好处理，不然会只得 $60$ 分，别问我怎么知道的。


```cpp
#include<cstdio>
#include<stack>
#include<queue>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
const int N = 1e5;
int top,head[N],nxt[N<<1],to[N<<1],val[N<<1],pre[N<<1];//这是存原图的 
inline void link(int u,int v,int w,int ww){
	nxt[++top] = head[u];
	to[top] = v;
	head[u] = top;
	pre[top] = w;//不在强连通分量中原来的边权 
	val[top] = ww;//在强连通分量中最多能取到的权值 
}
stack<int>s;
int n,m,start;
int scccnt,dfn_cnt,sccnum[N],ss[N],sum[N],dfn[N],low[N],f[N],vis[N];
void tarjan(int u){//tarjan缩点 
	dfn[u] = low[u] = ++dfn_cnt;
	s.push(u);
	for(int i=head[u];i;i=nxt[i]){
		int v = to[i];
		if(!dfn[v]){
			tarjan(v);
			low[u] = min(low[u],low[v]);
		}
		else if(!sccnum[v])
			low[u] = min(low[u],dfn[v]);
	}
	if(low[u] == dfn[u]){
		scccnt++;
		while(1){
			int x = s.top();
			s.pop();
			sccnum[x] = scccnt;
			if(x == u)break;
		}
	}
}
struct qwq{
	int x,w;
};
queue<int>q;
vector<qwq>g[N];//存缩完点后的图 
void build(){
	for(int u=1;u<=n;++u)
		for(int i=head[u];i;i=nxt[i]){
			int v = to[i];
			if(sccnum[v] == sccnum[u]){//同一强连通分量就缩成点权 
				sum[sccnum[v]] += val[i];//注意加的是最多能取的 
				continue;
			}
			g[sccnum[u]].push_back((qwq){sccnum[v],pre[i]});//点与点的边权是原来的边权 
		}
		
}
void tuopu_sort(int u){//这里是深搜，我把板子搬过来了，名字懒得改.... 
	for(auto xx : g[u]){//注意我们缩完点后就不会有找回来的情况了，所以不需要特判visit 
		int v = xx.x,w = xx.w;
		tuopu_sort(v);
		f[u] = max(f[u],f[v] + w);  
	}
	f[u] += sum[u];//点权也别忘了 
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int u,v,w;
		double k;
		scanf("%d%d%d",&u,&v,&w);
		scanf("%lf",&k);
		int kk = (k * 10);//这里预处理出能得到的最多的权值 
		int sss = 0,ww = w;
		while(w){
			sss += w;
			w = w * kk / 10;//一定要这么写，不能直接拿double的k 往上怼，会变得不幸 
		}
		link(u,v,ww,sss);
	}
	scanf("%d",&start);
	tarjan(start);
	build(); 
	tuopu_sort(sccnum[start]);
	printf("%d",f[sccnum[start]]);
}

```


---

## 作者：xia0ji233 (赞：3)

[P2656](https://www.luogu.com.cn/problem/P2656)题解。

就是沿线采蘑菇，然后给定起点，没有给终点，蘑菇采完后会复活，复活的个数为上一次的个数 $\times$ 恢复系数。路是单向的，那么可以据此建一个有向图。如果一条边的两个顶点在同一个强连通分量内的话，那么这条边我可以经过无数次，这很容易证明。但是如果一条边的两个点不在同一个强连通分量，那么我只能采一次上面的蘑菇。因为题目没有规定不能反复横跳，所以我们可以先 tarjan 缩点然后把内部的边权集中到点上，再集中的时候只需要注意一定是要 $\times$ 系数累加上去的，因为我能无数次经过。

缩点之后就是对 DAG 处理，我看大佬们用的都是最短路径算法，这里菜鸡只会拓扑排序 qwq。

这里还需要注意的是，起点所在的强连通分量如果入读不为 $0$ 那么那些蘑菇我是采不到的。因此我在这里设立一个 $flag$ 标记，在拓扑排序的时候如果 $flag$ 为 $0$ 那么我只把点和边删了，不做数值上的处理。然后我对起点所在的强连通分量 $flag$ 设 $1$，然后如果 $flag=1$ 则会向后面的点传递。

在写状态转移方程的时候注意要把路上的蘑菇和那个点的蘑菇都加上。

如果路径上的蘑菇为 $w$，$v$ 强连通分量上的蘑菇数为 $amount[v]$。那么 $u \to v$ 的状态转移方程就应该是：

$ans[v]=\max(ans[v],ans[u]+w+amount[v])$

最后注意一个，那就是一定要记着不管怎样给最终结果赋一个初始值就是起点所在强连通分量的蘑菇数量，这里卡了一下。

下面给出 AC 代码。

```C++
#include<bits/stdc++.h>
#define maxn 80005
using namespace std;
struct eee{
	int to;
	int next;
	int w;
	float p;
}edge[maxn*3],e[maxn*3];
int root[maxn],root2[maxn],dfn[maxn],low[maxn],visited[maxn],s[maxn],degree[maxn],num[maxn],amount[maxn],ans[maxn],flag[maxn],cnt,cnt2,tot,top,deep,n,m;
stack<int>ss;//拓扑排序用的栈
void add(int x,int y,int w,float p){//一开始的建图
	edge[++cnt].to=y;
	edge[cnt].w=w;
	edge[cnt].next=root[x];
	edge[cnt].p=p;
	root[x]=cnt;
}
void add2(int x,int y,int w,float p){//强连通分量的建图
	degree[y]++;
	e[++cnt2].next=root2[x];
	e[cnt2].to=y;
	e[cnt2].w=w;
	e[cnt2].p=p;
	root2[x]=cnt2;
}
void tarjan(int u){//tarjan板子
	visited[u]=1;
	dfn[u]=low[u]=++deep;
	s[++top]=u;
	for(int i=root[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(visited[v]){
			low[u]=min(low[u],low[v]);
		}
	}
	if(dfn[u]==low[u]){
		visited[u]=0;
		num[u]=++tot;
		while(s[top]!=u){
			visited[s[top]]=0;
			num[s[top--]]=tot;
		}
		top--;
	}
}
int main(){
    //freopen("1.txt","r",stdin);
    cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x, y, w;
		float p;
		cin>>x>>y>>w>>p;
		add(x,y,w,p);
	}
	int start;
	scanf("%d",&start);
	
	for(int i=1;i<=n;i++){
		if(!dfn[i])tarjan(i);
	}
	
	for(int i=1;i<=n;i++){
		for(int j=root[i];j;j=edge[j].next){
			int v=edge[j].to,w=edge[j].w;
            float p=edge[j].p;
			if(num[i]==num[v]){//同一个强连通分量内则把所有能产生的蘑菇加上
				while(w!=0){
					amount[num[i]]+=w;
					w=(int)((p)*w);
				}
			}
			else{
				add2(num[i],num[v],w,p);//否则建边
			}
		}
	}
	
	for(int i=1;i<=tot;i++){
		if(!degree[i])ss.push(i);
	}
	ans[num[start]]=amount[num[start]];
	flag[num[start]]=1;
	int res=ans[num[start]];//res一定赋初值不要忘了
	while(!ss.empty()){
		int x=ss.top();
		ss.pop();
		for(int i=root2[x];i;i=e[i].next){
			int v=e[i].to,w=e[i].w;
			degree[v]--;
			if(!degree[v])ss.push(v);
			if(flag[x]){//一定是起点以及起点之后的蘑菇才能采
				ans[v]=max(ans[v],ans[x]+w+amount[v]);//状态转移方程
				res=max(res,ans[v]);//保存结果
				flag[v]=1;//flag向前传播
			}
		}
	}
    if(tot==1){
        printf("%d",ans[1]);
    }	
	else 
        printf("%d",res);
	return 0;
}
```



---

## 作者：gan1234 (赞：2)

### P2656 采蘑菇

[题目传送门](https://www.luogu.com.cn/problem/P2656)

### 需要用到的知识点
- 缩点 (tarjan)
- spfa

关于缩点的模板题在[这里](https://www.luogu.com.cn/problem/P3387)，没有做过的可以先做这个模板题。

## 题目分析
这道题在求有向图中的最长路，但是这道题与其他题不同的一点在于多了一个新的概念：**恢复系数**。

也就是说，路径可以重复经过，且每次经过后，蘑菇 数量会减少。这就不能直接用传统的最长路算法去求了。

那怎么办呢？我们可以把它**转化成传统的最长路问题！**

如果一条路径可以重复经过多次，那么说明图中存在环包含了这条路径，这条路径可以无数次被经过。 而为了求最长路，我们肯定希望一条路径经过次数越多越好，直到这条长不出蘑菇为止。

也就是说，只要能到达强连通分量上任意一点，那么这个强连通分量上的蘑菇（包括再次生长出的）都可以采到！

**那么我们可以把一个强连通分量缩成一个点，这个强连通分量上可以采到的蘑菇为这个缩成的点的点权。** 因为所有强连通分量都缩成了点，所以图上也就不存在两个点可以互相到达的情况，也就不存在一条路会重复经过多次，恢复系数也就不用管了，可以正常求最长路了。

此时这道题也就迎刃而解了。

## 做法

- tarjan 求出图中所有强连通分量。
- 把强连通分量当作一个点，求出这个点的点值（缩点）。
- 缩点后的所有点按原来路径连接（建图）。
- 求最长路。

这里有个比较坑的点,因为某些玄学问题，恢复系数不能用 double 存！ ~~不然你就会和我一样 wa 掉。~~ 那怎么办呢？我们可以把恢复系数乘十倍，用 int 存，在求点权，用到恢复系数时，我们可以再除以十。

### 下面是喜闻乐见的代码环节
本蒟蒻丑陋的代码。

```cpp
#include<bits/stdc++.h>
#define MAXN 80005
using namespace std;
struct Node{
    int to,a, k;
    Node(int _to,int _a,int _k){to=_to;a=_a;k=_k;}
};
vector<Node>G[MAXN],G2[MAXN];//G1 是原图，G2 是缩点后的图
stack<int>s;
int dfn[MAXN],low[MAXN],sccno[MAXN];//dfn 是每个点 dfs 访问到的时间。
//low 是每个点能到达的最远祖先
//sccno 是每个点所在 scc 的编号，scct 是 scc 的数量
int a[MAXN],dis[MAXN];
//a是点权，dis是从起点到其他点的距离（缩点后）
int scct,dfsc;
int n,m,start,ans;
void dfs(int x){//tarjan
    dfn[x]=low[x]=++dfsc;
    s.push(x);
    int l=G[x].size();
    for(int i=0;l>i;i++){
        int y=G[x][i].to;
        if(!dfn[y]){
            dfs(y);
            low[x]=min(low[x],low[y]);
        }else if(!sccno[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x]){
        scct++;
        while(1){
            int y=s.top();s.pop();
            sccno[y]=scct;
            if(x==y)break;
        }
    }
}
void findscc(){
    scct=dfsc=0;
    for(int i=1;n>=i;i++)
        if(!dfn[i])
            dfs(i);
}
void bfs(){//bfs求最长路
    queue<int>q;
    q.push(start);
    dis[start]=a[start];
    while(!q.empty()){
        int x=q.front();q.pop();
        int l=G2[x].size();
        for(int i=0;l>i;i++){
            int y=G2[x][i].to;
            if(G2[x][i].a+dis[x]+a[y]>dis[y]){
                dis[y]=G2[x][i].a+dis[x]+a[y];
                q.push(y);
            }
        }
    }
}
int main(){
    cin>>n>>m;
    int x,y,z;
    double k;
    for(int i=0;m>i;i++){
        cin>>x>>y>>z>>k;
        G[x].push_back(Node(y,z,k*10.0));
    }
    cin>>start;
    findscc();      //tarjan求强连通分量
    for(int i=1;n>=i;i++){//缩点后建新图
        int l=G[i].size();
        for(int j=0;l>j;j++){
            int u=G[i][j].to;
            if(sccno[i]==sccno[u]){//如果所属scc相同，求点权
                int t=G[i][j].a;
                while(t!=0){
                    a[sccno[i]]+=t;
                    t*=G[i][j].k;
                    t/=10;
                }
            }else{//在两个点之连边
                G2[sccno[i]].push_back(Node(sccno[u],G[i][j].a,0));
            }
        }
    }
    start=sccno[start];//不要忘了起点也要改成缩点后的起点
    bfs();
    for(int i=1;scct>=i;i++)ans=max(ans,dis[i]);//bfs完后求最大值
    cout<<ans<<endl;
    return 0;
}
```
希望本题解能给大家帮助

---

## 作者：AmamiyaYuuko (赞：2)

由于题目中没有类似“体力”的限制，不难想到最优的方法是在一个环上一直走直到没有新蘑菇长出，然后再走向下一个环继续这个步骤。

原图是有向图，可以用 Tarjan 算法求出强连通分量。对于每个强连通分量，预处理出在这个连通分量中一直走能获得的所有的蘑菇数量。

接下来将 $S$ 所在的强连通分量入队，进行拓扑排序即可。

在这里有一些细节问题：

- 恢复系数是浮点数，运算时会出现精度误差。由于限定了恢复系数 $p$ 为一位小数，可以用一个 `int` 存下 $10p$。设当前蘑菇数位 $w$，则新长出的蘑菇数为 $\lfloor \dfrac{w \times 10p}{10} \rfloor$。

- 注意 DP 数组的边界情况，对于不包含 $S$ 的连通分量，初始值应设为 $- \infty$。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
#include <queue>

template <class T>
inline void read(T &x) {
    x = 0;
    int f = 0;
    char ch = getchar();
    while (!isdigit(ch))    { f |= ch == '-'; ch = getchar(); }
    while (isdigit(ch))     { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
    x = f ? -x : x;
    return ;
}

typedef unsigned long long uLL;
typedef long long LL;

struct Edge {
    int to, w, p;
} ;

std::queue<int> q;
std::vector<Edge> g[80010], G[80010];
int scc[80010], sta[80010], dfn[80010], low[80010], w[80010], f[80010], in[80010];
int n, m, top, cnt, s, sc, ans;
bool ins[80010];

void tarjan(int x) {
    dfn[x] = low[x] = ++cnt;
    sta[++top] = x;
    ins[x] = true;
    for (auto i : g[x]) {
        if (ins[i.to]) {
            low[x] = std::min(low[x], dfn[i.to]);
        } else if (!dfn[i.to]) {
            tarjan(i.to);
            low[x] = std::min(low[x], low[i.to]);
        }
    }
    if (dfn[x] == low[x]) {
        ++sc;
        while (sta[top] != x) {
            scc[sta[top]] = sc;
            ins[sta[top]] = false;
            --top;
        }
        scc[sta[top]] = sc;
        ins[sta[top]] = false;
        --top;
    }
}

int main() {
    read(n), read(m);
    for (int i = 1, u, v, w; i <= m; ++i) {
        double p;
        scanf("%d%d%d%lf", &u, &v, &w, &p);
        g[u].push_back((Edge){v, w, (int)(p * 10)});
    }
    read(s);
    for (int i = 1; i <= n; ++i) {
        if (!dfn[i]) {
            tarjan(i);
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (auto j : g[i]) {
            if (scc[i] != scc[j.to]) {
                G[scc[i]].push_back((Edge){scc[j.to], j.w, 0});
                ++in[scc[j.to]];
            } else {
                int tw = j.w, val = 0;
                while (tw) {
                    val += tw;
                    tw = tw * j.p / 10;
                }
                w[scc[i]] += val;
            }
        }
    }
    for (int i = 1; i <= sc; ++i) {
        f[i] = -2e9;
        if (!in[i]) {
            q.push(i);
        }
    }
    f[scc[s]] = w[scc[s]];
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (auto i : G[u]) {
            f[i.to] = std::max(f[i.to], f[u] + i.w + w[i.to]);
            --in[i.to];
            if (!in[i.to])    q.push(i.to);
        }
    }
    for (int i = 1; i <= sc; ++i)    ans = std::max(ans, f[i]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

[P2656 采蘑菇](https://www.luogu.com.cn/problem/P2656#submit)

这道题区别于普通最长路问题的点就在于恢复系数。

因为这是有向图，所以一条边要在一个强连通分量里才能反复走。

所以思路就出来了：先缩点求出每一个强连通分量，再把里面的值给累加起来（包括又长出来的），再在缩点之后的图上找最长路。

但是 ``double`` 会出现非常玄学的精度问题，所以要先把恢复系数乘十再在后面计算。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 114514
#define M 1919810
#define ll long long
queue <ll> q;
struct xx{
	ll next,from,to,val,grow;
}e[2*N];
struct xxx{
	ll next,from,to,val,grow;
}ed[2*N];
ll n,m,s;
ll x,y,z;
double zz;
ll head[2*N],e_cnt;
ll headd[2*N],e_cntt;
ll dfn[N],low[N];
ll t_cnt,sstack[N],t;
ll color[N],c_cnt;
ll dis[N],vis[N];
ll di[N];
ll ans=-114514;
void add(ll x,ll y,ll z,double zz){
	e[++e_cnt].next=head[x];
	e[e_cnt].from=x;
	e[e_cnt].to=y;
	e[e_cnt].val=z;
	e[e_cnt].grow=zz;
	head[x]=e_cnt;
}
void adda(ll x,ll y,ll z){
	ed[++e_cntt].from=x;
	ed[e_cntt].next=headd[x];
	ed[e_cntt].to=y;
	ed[e_cntt].val=z;
	headd[x]=e_cntt;
}
void tarjan(ll now){
	dfn[now]=low[now]=++t_cnt;
	sstack[++t]=now;
	vis[now]=1;
	for(int i=head[now];i;i=e[i].next){
		ll v=e[i].to;
		if(!dfn[v]){
			tarjan(v);
			low[now]=min(low[now],low[v]);
		}
		else if(vis[v]) low[now]=min(low[now],dfn[v]);
	}
	if(dfn[now]==low[now]){
		int now_t;
		color[now]=++c_cnt;
		do{
			now_t=sstack[t--];
			color[now_t]=c_cnt;
			vis[now_t]=0;
		}while(now_t!=now);
	}
}
void spfa(ll s){
	memset(dis,-1,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=di[s];
	q.push(s);
	vis[s]=1;
	while(!q.empty()){
		ll x=q.front(); q.pop();
		vis[x]=0;
		for(int i=headd[x];i;i=ed[i].next){
			ll v=ed[i].to;
			if(dis[v]<dis[x]+ed[i].val+di[v]){ //别忘了改成 < 
				dis[v]=dis[x]+ed[i].val+di[v];
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>x>>y>>z>>zz;
		zz*=10;  //把恢复系数乘10 
		add(x,y,z,zz);
	}
	cin>>s;
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	for(int i=1;i<=m;i++){
		if(color[e[i].from]==color[e[i].to]){
			ll v=e[i].val,g=e[i].grow;
			while(v>0){
				di[color[e[i].from]]+=v; //在强连通分量里累加
				v=(v*g)/10;   //恢复系数参与运算 
			}
		}
		else adda(color[e[i].from],color[e[i].to],e[i].val);  //在缩点后建图 
	}
	spfa(color[s]);
	for(int i=1;i<=c_cnt;i++) ans=max(ans,dis[i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：glorious_dream (赞：1)

### 题意描述：

$N$ 个草丛，$M$ 条单向的小道，经过每条道时可以采走这条道上的所有蘑菇，蘑菇有一个恢复系数，即在采过这一片蘑菇后又会新长出蘑菇，求从给定的点出发能采到的蘑菇最大值。

### 算法分析：

很容易想到最后要求一个最大值，可以用树形 DP，不过本人比较懒，推荐 spfa 求最长路，既好理解又好写。

首先明确一点，如果走到一个环中，里面的所有蘑菇包括每一次恢复后新长出来的蘑菇都能采到。

于是想到了什么？ Tarjan 缩点，成为一个有向无环图，把每一个强连通分量里面的蘑菇总数求出来，最后跑一边最长路即可。

然后要注意细节：这道题不需要用 double 存，会有精度问题。可以在存图的时候先把 $k$ 乘 $10$，在后面的处理中把 $k$ 除以 $10$ 就行了。

### 代码+注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){ //快读不解释了
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
const int M = 4e5+10;
stack<int>s; //tarjan里面用
queue<int>q; //spfa求最长路的时候用
int n,m,ss;
int cnt1,cnt2,dfncnt,scccnt,ans;
int head1[M],head2[M],dfn[M],low[M],sccnum[M],sccsize[M];
int dis[M],vis[M],sum[M];
struct edge{ //边，定义结构体变量
    int from,to,nxt,w,k;
}e1[M],e2[M];
void add1(int u,int v,int w,int k){ //跑tarjan用的图
    e1[++cnt1].to = v;
    e1[cnt1].from = u;
    e1[cnt1].w = w;
    e1[cnt1].nxt = head1[u];
    head1[u] = cnt1;
    e1[cnt1].k = k;
}
void add2(int u,int v,int w){ //跑spfa用的图
    e2[++cnt2].to = v;
    e2[cnt2].w = w;
    e2[cnt2].nxt = head2[u];
    head2[u] = cnt2;
}
void tarjan(int u){ //targan版子
    dfn[u] = low[u] = ++dfncnt; //时间戳
    s.push(u);
    for(register int i(head1[u]) ; i ; i=e1[i].nxt){
        int v = e1[i].to;
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u],low[v]);
        }
        else if(!sccnum[v]) low[u] = min(low[u],dfn[v]);
    }
    if(dfn[u] == low[u]){
        scccnt++;
        while(1){
            int x = s.top();
            s.pop();
            sccnum[x] = scccnt; //记录下来该点在哪个强连通分量中
            sccsize[scccnt]++;
            if(x == u) break; //已经把元素从栈中弹出了
        }
    }
}
void spfa(int s){
    memset(dis,-1,sizeof(dis)); //别忘了每次都要清
    memset(vis,0,sizeof(vis));
    dis[s] = sum[s]; //初始化
    vis[s] = 1;
    q.push(s);
    while(!q.empty()){
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for(register int i(head2[u]) ; i ; i=e2[i].nxt){
            int v = e2[i].to,w = e2[i].w;
            if(dis[v] < dis[u] + w + sum[v]){ //别忘了要加上sum[v]
                dis[v] = dis[u] + w + sum[v]; //最长路!
                if(!vis[v]){
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}
signed main(){
    n=read();m=read();
    for(register int i(1) ; i<=m ; i=-~i){
        int u,v,w;
        double k;
        scanf("%d%d%d%lf",&u,&v,&w,&k);
        add1(u,v,w,k*10); //先把k*10加入边中
    }
    for(register int i(1) ; i<=n ; i=-~i) if(!dfn[i]) tarjan(i);
    for(register int i(1) ; i<=m ; i=-~i){
        int x = e1[i].from,y = e1[i].to,w = e1[i].w,k = e1[i].k;
        if(sccnum[x] == sccnum[y]){
            while(w){
                sum[sccnum[x]] += w; //这一个强连通分量里的总价值
                w = w * k / 10; //前面乘10，这里除掉
            }
         }
         else add2(sccnum[x],sccnum[y],w); //第二次加边
    }
    ss = read();
    ss = sccnum[ss];
    spfa(ss); //从这个点开始走最长路
    for(register int i(1) ; i<=scccnt ; i=-~i) ans = max(ans,dis[i]); //由于不知道终点是哪个，把每个点都扫一遍取最大就行了
    printf("%d",ans);
    return 0;
}

```


---

## 作者：清烛 (赞：1)

前置知识：DAG 上 dp，tarjan 求强连通分量，缩点。

已经通过新数据，详情：[/discuss/352760](/discuss/352760)。

回到本题，我们首先注意到，如果一条道路是能被多次通过的，那么肯定是把这条道路上的蘑菇榨干是最优的。而 $\log_{\frac{1}{0.8}}(2^{31} - 1)\approx 96$，这意味着一条边最多走 $96$ 次就会被榨干。所以一条边能产生的贡献是可以暴力计算的。

考虑一个 dp，我们将整张图缩点。显然每个强连通分量内的道路都是可以被全部榨干的（考虑一直在这个 SCC 内转圈圈），这个贡献我们可以预处理好。

然后就是一个极其平凡的 DAG 上的 dp 了，$f_u$ 定义为从 $S$ 点出发到 $u$ 号 SCC 为止能获得的最多的蘑菇个数，用拓扑排序转移即可。当然使用最~~短~~长路进行转移也是完全可以的，下面的~~远古代码~~使用的是 SPFA。

小数只有一位，为了防止精度爆炸，我们先读入这个小数，然后乘上 $10$ 处理即可，详见代码。

实现：

```cpp
#include <cstdio>
#include <stack>
#include <queue>

const int maxn = 8e4 + 5, maxm = 2e5 + 5;
int n, m, st, head1[maxn], head2[maxn], tot;
int dfn[maxn], low[maxn], bel[maxn], times, scc, w[maxn];
bool ins[maxn];
std::stack<int> s;
std::queue<int> q;
int dis[maxn];
bool inq[maxn];

inline int max(int a, int b) {
    return a > b ? a : b;
}

inline int min(int a, int b) {
    return a < b ? a : b;
}

struct edge1 {
    int from, to, w, next, k;
}e1[maxm];

struct edge2 {
    int to, w, next;
}e2[maxm];

inline void add1(int u, int v, int w, int k) {
    e1[++tot].from = u;
    e1[tot].to = v;
    e1[tot].w = w;
    e1[tot].k = k;
    e1[tot].next = head1[u];
    head1[u] = tot;
    return;
}

inline void add2(int u, int v, int w) {
    e2[++tot].to = v;
    e2[tot].w = w;
    e2[tot].next = head2[u];
    head2[u] = tot;
    return;
}

inline int calc(int w, int k) {//暴力计算一条边能产生的贡献
    int ret = 0;
    while (w) {
        ret += w;
        w = w * k / 10;
    }
    return ret;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++times;
    s.push(u);
    ins[u] = 1;
    for (int i = head1[u]; i; i = e1[i].next) {
        int& v = e1[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        scc++;
        while (1) {
            int x = s.top();
            s.pop();
            ins[x] = 0;
            bel[x] = scc;
            if (x == u)
                break;
        }
    }
    return;
}

int spfa() {//用最长路来算答案
    int ans = dis[st] = w[st];
    q.push(st);
    inq[st] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (int i = head2[u]; i; i = e2[i].next) {
            int& v = e2[i].to, & d = e2[i].w;
            if (dis[u] + d + w[v] > dis[v]) {
                dis[v] = dis[u] + d + w[v];
                ans = max(dis[v], ans);
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
            }
        }
    }
    return ans;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; i++) {
        int u, v, w; double k;
        scanf("%d %d %d %lf", &u, &v, &w, &k);
        add1(u, v, w, int(k * 10));//乘上 10 进行贡献处理
    }
    tot = 0;
    scanf("%d", &st);
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i);
    for (int i = 1; i <= m; i++) {
        if (bel[e1[i].from] == bel[e1[i].to])
            w[bel[e1[i].from]] += calc(e1[i].w, e1[i].k);
        else
            add2(bel[e1[i].from], bel[e1[i].to], e1[i].w);
    }
    st = bel[st];
    printf("%d\n", spfa());
    return 0;
}

```

---

## 作者：fanypcd (赞：1)

发现图中同一个强连通分量上的点可以经过任意多次（一直绕圈），那么贪心地想，就要走到没有收益再往下走。

那么对原图跑 tarjan 进行缩点，标注出每一个强连通分量的权值，作为新图的一个点（分量里的所有点的收益之和）。

然后在 DAG 上做 DP 即可。

注意 double 会炸精度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline void read(int &x)
{
	x = 0;
	int f = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		f |= ch == '-';
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	x = f ? -x : x;
	return;
}
#define N 80005
#define M 200005
class Graph1
{
	public:
	int first[N], Next[M], to[M], w1[M], w2[M], tot;
	inline void add(int x, int y, int z1, double z2)
	{
		Next[++tot] = first[x];
		first[x] = tot;
		to[tot] = y;
		w1[tot] = z1;
		w2[tot] = z2;
		return;
	}
};
Graph1 G1;
class Graph2
{
	public:
	int first[N], Next[M], to[M], w[M], tot;
	inline void add(int x, int y, int z)
	{
		Next[++tot] = first[x];
		first[x] = tot;
		to[tot] = y;
		w[tot] = z;
		return;
	}
};
Graph2 G2;
int dfn[N], low[N], sign, sta[N], top, insta[N];
int scc_cnt, bel[N], sum[N];
void tarjan(int u)
{
	dfn[u] = low[u] = ++sign;
	sta[++top] = u, insta[u] = 1;
	for(int i = G1.first[u]; i; i = G1.Next[i])
	{
		int v = G1.to[i];
		if(!dfn[v])
		{
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(insta[v])
		{
			low[u] = min(low[u], dfn[v]);
		}
	}
	if(low[u] == dfn[u])
	{
		scc_cnt++;
		while(sta[top] != u)
		{
			bel[sta[top]] = scc_cnt;
			insta[sta[top]] = 0;
			top--;
		}
		bel[sta[top]] = scc_cnt;
		insta[sta[top]] = 0;
		top--;
	}
	return;
}
int n, m, S;
inline void link()
{
	for(int u = 1; u <= n; u++)
	{
		for(int i = G1.first[u]; i; i = G1.Next[i])
		{
			int v = G1.to[i];
			if(bel[u] == bel[v])
			{
				sum[bel[u]] += G1.w2[i];
			}
			else
			{
				G2.add(bel[u], bel[v], G1.w1[i]);
			}
		}
	}
	return;
}
int ans = 0;
void dfs(int u, int dis)
{
	dis += sum[u];
	ans = max(ans, dis);
	for(int i = G2.first[u]; i; i = G2.Next[i])
	{
		int v = G2.to[i];
		dfs(v, dis + G2.w[i]);
	}
	return;
}
signed main()
{
	read(n), read(m);
	int x, y, z;
	long double rate;
	for(int i = 1; i <= m; i++)
	{
		read(x), read(y), read(z), scanf("%Lf", &rate);
		int v = z, vs = 0;
		while(v)
		{
			vs += v;
			v = floor((long double)v * rate);
		}
		G1.add(x, y, z, vs);
	}
	read(S);
	for(int i = 1; i <= n; i++)
	{
		if(!dfn[i])
		{
			tarjan(i);
		}
	}
	link();
	dfs(bel[S], 0);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：cymrain07 (赞：1)

首先用 Tarjan 求强连通分量。

对于每个强连通分量来说，因为可以在这个分量里无限次走直到把所有蘑菇采完，所以可以缩成一个点。

这个点的点权即为所有蘑菇的总和（每条边都要不断地乘上恢复系数直到变成 $0$）。

缩完点后整张图变成 DAG，可以 DP。

设 $f(x)$ 为从 $s$ 出发到达 $x$ 采的蘑菇的最多数量，$\textit{val}(x)$ 为 $x$ 点点权。

$$
f(v)=\max\{f(u)+(u,v)\}+\textit{val}(v)
$$

注意事项：

- 由于缩点后 $s$ 入度可能并不为 $0$，不能保证 $f(x)$ 是从 $s$ 出发，所以初始化 $f$ 为一个极小值，$f(s)\gets\textit{val}(s)$，这样就可以保证 $f(x)$ 是从 $s$ 出发的。（用记忆化搜索则不用考虑）
- 精度问题。每次乘一个小数精度会爆炸，所以把 $\lfloor x\times 0.?\rfloor$ 改成 $\lfloor\dfrac{x\times?}{10}\rfloor$。

upd：
用记忆化搜索可有效避免处理起点的问题，码量还少，且两者效率差不多。  

代码：

记忆化搜索片段：

```cpp
int f[N];
int DP(int u)
{
    int mx = 0;
    for (edge i : e1[u])
    {
        int v = i.v;
        if (!f[v]) f[v] = DP(v);
        mx = max(mx, f[v] + i.w);
    }
    f[u] = val[u] + mx;
    return f[u];
}
```

DP 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 80005
int dfn[N], low[N], col[N], cnt, tot;
int val[N];
struct edge
{
    int v, w, c;
};
vector<edge> e[N], e1[N];
stack<int> stk;
int separate(int x, int v)
{
    int res = 0;
    while (x) res += x, x = x * v / 10;
    return res;
}
void tarjan(int u)
{
    dfn[u] = low[u] = ++cnt;
    stk.push(u);
    for (edge i : e[u])
    {
        int v = i.v;
        if (!dfn[v])
            tarjan(v), low[u] = min(low[u], low[v]);
        else if (!col[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u])
    {
        tot++;
        while (1)
        {
            int x = stk.top();
            stk.pop();
            col[x] = tot;
            if (x == u) break;
        }
    }
}
int n, m, s;
queue<int> q;
int f[N], in[N], ans;
void DP()
{
    for (int i = 1; i <= tot; i++)
    {
        f[i] = -0x3f3f3f3f;
        if (!in[i]) q.push(i);
    }
    s = col[s];
    f[s] = val[s];
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (edge i : e1[u])
        {
            int v = i.v;
            f[v] = max(f[v], f[u] + i.w + val[v]);
            in[v]--;
            if (!in[v]) q.push(v);
        }
    }
}
int main()
{
    cin >> n >> m;
    while (m--)
    {
        int u, v, w;
        double c;
        cin >> u >> v >> w >> c;
        e[u].push_back({v, w, (int)(c * 10)});
    }
    cin >> s;
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i);
    for (int u = 1; u <= n; u++)
        for (edge i : e[u])
        {
            int v = i.v;
            if (col[u] == col[v])
                val[col[u]] += separate(i.w, i.c);
            else
                e1[col[u]].push_back({col[v], i.w, 0}), in[col[v]]++;
        }
    DP();
    for (int i = 1; i <= tot; i++) ans = max(ans, f[i]);
    cout << ans;
    return 0;
}
```


---


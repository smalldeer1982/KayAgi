# 国事访问

## 题目背景

这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。


## 题目描述

这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。Q国总统ZR想到Yugo国进行十分紧急的国事访问，但不能坐飞机，只能坐车。由于路上有许多不同的国家而且有些无政府国，所以有许多路是坏的。路没有从自己通向自己的（作死吗。。。）。你需要确定一条具体的路线，并且由于WJ联盟的人随时可能过来，你需要把这条路线经过的所有城市周围的其他路都毁掉。你是上帝视角，你需要帮助ZR总统到达Yugo，你可以毁掉一些原本是好的路，也可以把坏的路修好，但不能新修路。给你一份地图，地图上，ZR国坐落在1城，Yugo首都在n城。帮助ZR总统尽快到达Yugo，你可以获得ZR总统在WJ联邦银行的30亿存款和1000万人的军队，和ZR总统一起瓜分地球（以上是诈骗内容。。。）。


## 说明/提示

把 1 2 1 路径变成不可用

把 1 3 0 路径变成可用

把 2 3 1 路径变成不可用

即可

## 样例 #1

### 输入

```
4 4
1 2 1
1 3 0
2 3 1
3 4 1```

### 输出

```
3
```

# 题解

## 作者：天南月 (赞：7)

~~在讲题之前，先发一发牢骚：强烈谴责出题人语义不清QAQ！！！~~

在看到这一道题的一开始，我对照样例和题目看了老久，以为出题人的意思是选择一条最短路，使得除了这条路径上的所有边，这条路上的其他点的其他出边都要被损毁，这样的话就是一个费用计算方式比较与众不同的最小费用最短路，为此我还推了1个小时费用计算公式。满怀信心的交上去，结果......20分?!仅过了样例！！！

把数据点2下下来一看：原来不是路径上的经过点的出边，而是所有非最短路上的边都要求损毁！！！

于是这就变成一个极其容易的最小费用最短路问题了。先把所有未损毁的边的数量统计下来，记一个ans，接着把损毁边(0)的费用设为1（容易理解），把未损毁边(1)的费用设为-1（看下去就理解了），最终答案就是$ans+cost[t]$;

接下来上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+c-48,c=getchar();
	return x;
}
const int N=1e5+5,INF=1061109567;
struct edge{
	int next,to,opt;
}e[N];
int n,m,tot,ans;
int dis[N],head[N],cost[N];
bool vis[N];
void add(int x,int y,int opt){
	e[++tot]=(edge){head[x],y,opt};
	head[x]=tot;
	e[++tot]=(edge){head[y],x,opt};
	head[y]=tot;
}
void Spfa(){
	memset(dis,0x3f,sizeof(dis));
	memset(cost,0x3f,sizeof(cost));
	queue<int>q;
	q.push(1);
	dis[1]=0;
	vis[n]=true;
	cost[1]=0;
	while(!q.empty()){
		int now=q.front();
		q.pop();
		vis[now]=false;
		for(int i=head[now],nxt;i;i=e[i].next){
			if(dis[nxt=e[i].to]>dis[now]+1){
				dis[nxt]=dis[now]+1;
				if(e[i].opt)cost[nxt]=cost[now]-1;
				else cost[nxt]=cost[now]+1;
				if(!vis[nxt])vis[nxt]=true,q.push(nxt);
			}
			else if(dis[nxt]==dis[now]+1){
				if(e[i].opt){
					if(cost[nxt]>cost[now]-1){
						cost[nxt]=cost[now]-1;
						if(!vis[nxt])vis[nxt]=true,q.push(nxt);
					}
				}
				else{
					if(cost[nxt]>cost[now]+1){
						cost[nxt]=cost[now]+1;
						if(!vis[nxt])vis[nxt]=true,q.push(nxt);
					}
				}
			}
		}
	}
}
int main(){
	n=read();m=read();
	int a,b,c;
	for(int i=1;i<=m;++i){
		a=read();b=read();c=read();
		add(a,b,c);
		ans+=c;
	}
	Spfa();
	printf("%d",ans+cost[n]);
	return 0;
}
```
数据比较水，跑个SPFA只要15ms...

---

## 作者：mot1ve (赞：4)

最短路好题，具体思路就是确保距离最小的前提下让花费尽可能小。我们在求最短路时没有必要关心这条边是 $0$ 或 $1$ ，先跑出一个最短路径，不管价值是多少。因为答案成立的前提条件是走的是最短路。然后在spfa内更新价值。如果我们在实际路径中走过了一条 $0$ 边，那么由于我们需要修它之后才能走，所以这条边价值设为 $1$ ，而如果实际路径中走过了一条 $1$ 边，那么由于我们不用修它就可以走并且如果不走它就需要炸毁，那么边权就设为 $-1$ 。由于最后所有不在路径内的 $1$ 边需要被炸毁，先统计出1边有 $tot$ 个，这样 $val[n]+tot$ 就是最终答案。

```
#include<bits/stdc++.h>
using namespace std;
int n,m,idx,cnt;
int dis[1010],val[1010],vis[1010],head[1010];//dis为距离数组，val为价值数组 
struct node{
	int nxt,to,w;
}edge[1000010];
void add(int u,int v,int w)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	if(w==1)
	edge[idx].w=-1;
	if(w==0)
	edge[idx].w=1;
	head[u]=idx;
}
void spfa(int s)
{
	memset(dis,0x3f,sizeof(dis));
	memset(val,0x3f,sizeof(val));
	queue<int> q;
	q.push(s);
	vis[s]=1;
	dis[s]=0;//
	val[s]=0;//
	while(q.size())
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=edge[i].nxt)
		{
			int y=edge[i].to;
			if(dis[x]+1<dis[y])
			{
				dis[y]=dis[x]+1;//距离可以更新，价值不管多大都要更新 
				val[y]=val[x]+edge[i].w;
				if(!vis[y])
				{
					q.push(y);
					vis[y]=1;
				}
			}
			if(dis[x]+1==dis[y])//最短路相同时比较价值
			{
				if(val[x]+edge[i].w<val[y])
				val[y]=val[x]+edge[i].w;
			} 
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		if(w==1)
		cnt++;
		add(u,v,w);
		add(v,u,w);
	}
	spfa(1);
	cout<<val[n]+cnt;
	return 0;
} 
```

---

## 作者：Chiesl (赞：3)

### 题意简述
求 ZR 总统走最短路的情况下的修改次数。 ***注意，一定是最短路***
#### 思路

看到这道题，立刻就想到了 BFS，第一次走到的一定是最短路径，直接累计修改次数在到达时输出就行，这样就可以华丽的解决问题了\
但是这道题题意写的迷迷糊糊，也不咋详细，也没讲道路双向的，所以就诞生了一份 20 分代码。
加了双向后也仅仅能获得 40 分，这题果然不是简简单单的广搜板子
再后来，我就想步数可以省略，再在外面开一个数组记入当前修改次数的值不就行了？于是就把结构体删了，但只做这些并不能 AC 。\
我细细琢磨，之前的程序有许多不妥之处，如之前已经摧毁的道路依旧会走，如果一走这条就切断其余道路又会影响其余状态决策\
那我们不妨就用含 ans 记入一下合法的道路总数,然后记录下每次到这座城市的更改次数，（ ans 事先默认可通行的道路也要改），每次遇到合法道路就让计入的此时的修改次数减一，最后只需要华丽的输出 ans 加上到达目标城市所计入的修改次数就行了！
最终 AC 代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1002][1002], cnt[1002], Count[1002], ans, pre[1002], dis[1002];//Count这个数组是没用的，忘记删除了
bool flag[1002][1002];//表示连接状况
queue<int> q;//广搜队列
int main () {
	int n, m;
	scanf("%d%d", &n, &m);
	int x, y, z;//临时储存的变量
	for (int i = 1; i <= m; i++) {
		scanf("%d%d%d", &x, &y, &z);//拒绝 cin ,从我做起
		if (z) ans++;//可以走就让ans++
		a[x][++cnt[x]] = y;
		a[y][++cnt[y]] = x;//建立双向的连接
		flag[x][y] = flag[y][x] = z;//这个也要建双向，敲黑板
	}
	memset(pre, 0x3f, sizeof(pre));
	memset(dis, 0x3f, sizeof(dis));//初始化为极大值，方便更新数值, 如果嫌这个还不够大的话开long long 用 0x7f
	pre[1] = dis[1] = 0;//这两个要为零，还未出发，从首都到达首都不用进行任何修改
	q.push(1);//从一出发
	while (!q.empty()) {//结束的条件 !q.empty()
		for (int i = 1; i <= cnt[q.front()]; i++) {
			int nx = a[q.front()][i];
			if (dis[nx] > dis[q.front()] + 1) {//没变过，或者确实小于
				dis[nx] = dis[q.front()] + 1;
				pre[nx] = pre[q.front()] + (flag[q.front()][nx] ? -1 : 1);				
				q.push(nx);				
			}
			if (dis[nx] == dis[q.front()] + 1) {//等于也要处理哦
				if (pre[nx] > pre[q.front()] + (flag[q.front()][nx] ? -1 : 1)) {
					pre[nx] = pre[q.front()] + (flag[q.front()][nx] ? -1 : 1);//要打括号！！不然会错（蒟蒻也不知道为什么，上面的也同理）
					q.push(nx);
				}
			}
		
		}
		q.pop();//别忘了
	}
	printf("%d", ans + pre[n]);//华丽的输出吧!
	return 0;
}//如此详细，肯定能会吧
```
本题并不是只能用广搜，而是蒟蒻不会用其他的，本题解仅供参考，神犇们一定能写出更加优秀的代码

---

## 作者：WZKQWQ (赞：2)

~~题解区甚至没有人愿意写广搜就离谱~~

广搜板子？？？

反正这题就是很离谱。

题意有一个坑点就是除了最短路上的点都要毁掉，我开始理解错了（被题目难度迷惑了）。

本题的阳间翻译：给你一副无向图，边的边权都是 $1$，边有 $1$ 边和 $0$ 边两种（和边权无关），求点 $1$ 到点 $n$ 的最短路的同时满足路上 $1$ 边尽量多。

如果你熟练掌握广搜你可以写出如下 $O(m)$ 代码：

```cpp
while(!q.empty()){
		int x = q.front();
		q.pop();
		for(int i = 0;i < e[x].size();i++){
			node tmp = e[x][i];
			if(dis[tmp.to] > dis[x] + 1){
				dis[tmp.to] = dis[x] + 1;
				q.push(tmp.to);
			}
		}
	}
```

（Ps：因为边权都为 $1$ 所以这么做是 $O(m)$ 的。）

然后和这题有什么关系呢？

你会发现，我们令 $ans$ 为 $1$ 边的总数。当我们不需要走时，答案为 $ans$，每走一条 $1$ 边答案 $-1$，每走一条 $0$ 边答案 $+1$。

所以我们令 $1$ 边价值为 $-1$，$0$ 边价值为 $1$。

$num[i]$ 表示从 $1$ 到 $i$ 最短路的同时最小价值，最后答案就是 $ans + num[n]$。

这题理解后也不难，难点在阴间题意，直接上代码吧：

```cpp
#include<cstdio>
#include<queue>
#include<cmath>
using namespace std;
const int N = 1005; 
struct node{
	int to,p;
	node(int _to = 0,int _p = 0):to(_to),p(_p){}
};
vector<node>e[N];
int n,m,ans,num[N],dis[N];
queue<int>q;
int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1,x,y,z;i <= m;i++){
		scanf("%d%d%d",&x,&y,&z);
		ans += z;
		z = z?-1:1;
		e[x].push_back(node(y,z));
		e[y].push_back(node(x,z));
	}
	for(int i = 1;i <= n;i++) num[i] = 1e9,dis[i] = 1e9;
	num[1] = 0,dis[1] = 0;
	q.push(1);
	while(!q.empty()){
		int x = q.front();
		q.pop();
		for(int i = 0;i < e[x].size();i++){
			node tmp = e[x][i];
			if(dis[tmp.to] > dis[x] + 1){
				dis[tmp.to] = dis[x] + 1;
				num[tmp.to] = num[x] + tmp.p;
				q.push(tmp.to);
			}
			if(dis[tmp.to] == dis[x] + 1)
				if(num[tmp.to] > num[x] + tmp.p){
					num[tmp.to] = num[x] + tmp.p;
					q.push(tmp.to);
				}
		}
	}
	printf("%d\n",ans + num[n]);
	return 0;
}
```


---

## 作者：VectorChange (赞：2)

[点我传送至原题](https://www.luogu.com.cn/problem/P3753)

题面翻译：求最短路径中不可通过的路径个数加上其他路径的个数。

看大佬们都是跑的 spfa，身为蒟蒻的我只会写 Dijkstra，于是我就来一发 Dijkstra 的题解。

Dijkstra 是基于贪心实现的最短路代码（这道题没边权，所以不需要贪心），因为这道题是稠密图，所以 Dijkstra 在这道题的速度应该比 SPFA 好一点，如果还不知道 Dijkstra 怎么写，可以点下方传送至博客学学。

前置知识： [点我](https://blog.csdn.net/qq_39521554/article/details/79333690?ops_request_misc=&request_id=&biz_id=102&utm_term=dijkstra%E7%AE%97%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-79333690.first_rank_v2_pc_rank_v29)

初次提交，~~获得了20分的好成绩~~，一看，发现没建双向边，于是建了双向边。
```
for(i=1;i<=m;i++){
  ll j,k,l;
  scanf("%lld%lld%lld",&j,&k,&l);
  if(j==k) continue;
  Add_edge(j,k,l);
  Add_edge(k,j,l);
  if(l==0) orz++; 
}
```
~~获得了40分的好成绩~~

于是我又开始 DeBug 的旅途。

经过我长达 $10$ 分钟的思考，我发现可以开始用 $ans$ 记录下可通过的路，然后用 $pre$ 数组记录了最短路上不可通过的路的个数，将 $pre_n$ 加上 $ans$ 就可以得到答案。

提交后，发现只有 $80$ 分，我又仔细思考了一下，发现这个思路并不完全对，我记录了所有可通过的路，但有一些可通过的路是在最短路上的，并不需要毁掉，所以我在统计 $pre$ 数组时，遇到可通过的路，就减掉，这样就可以求出真正的答案。

AC 代码如下，仅供参考：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
  ll e,v,next;
}edge[1005];
ll n,m,u,dis[1005],head[1005],cnt=0,vis[1005],ans,fuckccf,pre[1005];
queue<int>q;
void Add_edge(ll j,ll k,ll l){
  edge[++cnt].e=k;
  edge[cnt].v=l;
  edge[cnt].next=head[j];
  head[j]=cnt;
}//领接链表存图
void Dij(){
  q.push(1);
  ll j,x=1;
  dis[1]=0;
  pre[1]=0;
  while (!q.empty()){
    int x=q.front();
    q.pop();
    if(vis[x]) continue;//如果边拓展过，就不拓展
    vis[x]=1;
    for(j=head[x];j;j=edge[j].next){
      ll w=edge[j].e;
      if(dis[w]>dis[x]+1){
        dis[w]=dis[x]+1;
        if(edge[j].v==0) pre[w]=pre[x]+1;//如果边不存在，就要加边
        else pre[w]=pre[x]-1;//如果边存在，就减少改变次数
        q.push(w);
      }
    }
  }
}//Dijkstra求最短路
int main(){
  ll i;
  scanf("%lld%lld",&n,&m);
  for(i=0;i<=n;i++) dis[i]=1e17;
  for(i=1;i<=m;i++){
    ll j,k,l;
    scanf("%lld%lld%lld",&j,&k,&l);
    Add_edge(j,k,l);
    Add_edge(k,j,l);
    ans+=l;//统计可通过的路径的数量
  }//初始存图
  Dij(); 
  printf("%d\n",ans+pre[n]);//输出更改次数。
  return 0;
}
```


---

## 作者：Tomwsc (赞：1)

~~吐槽一下，题面描述不是很清楚，还是我看了一眼题解区，才知道原来要销毁所有非最短路上的道路。~~

## 题意：

给你一个无向图，图上的边权变成了 ```1``` 或 ```0```，分别代表能不能走。你需要求出最短路上的不能走的边以及非最短路上能走的边的和。

## 思路：

读完题目后，思路大体就有了：跑一遍最短路，然后统计答案。注意到图上边权为 $1$，对这种图，我们可以使用 bfs 来求最短路。

bfs 代码如下：

```cpp
inline void bfs(int x) {
	queue<pair<int , int> >q;
	q.push(make_pair(1 , 0));
	vis[1] = true;
	while(!q.empty()) {
		int u = q.front().first;
		int t = q.front().second;
		q.pop();
		dis[u] = t;
		for(register int i = 1;i <= n;i ++)
			if(i != u && !vis[i] && mapp[u][i] != INT_MAX) {
				q.push(make_pair(i , t + 1));
				vis[i] = true;
				pre[i] = u;
			}
	}
	return;
}
```

同时，我们发现 $n\le1000$，所以我们便可以使用邻接矩阵存图。

怎样统计答案呢？对于最短路上的边，我们可以在 bfs 时用一个 ```pre[v]``` 来记录 ```v``` 节点的最短路前驱。在 bfs 后，我们便可以用循环来找 $1$ 到 $n$ 的最短路中的答案。对于非最短路上的边，我们可以暴力枚举任意两点间的边，如果它们两个都在从 $1$ 到 $n$ 的最短路上，则 ```continue```。否则判断这条边是否需要销毁，若需要，答案加一。

统计答案代码如下：

```cpp
while(pre[k]) {
		if(!flag[k][pre[k]]) {
			flag[k][pre[k]] = flag[pre[k]][k] = true;
			cnt ++;
		}
		k = pre[k];
		vis[k] = true;
	}
	for(register int i = 1;i <= n;i ++)
		for(register int j = 1;j <= n;j ++)
			if(mapp[i][j] != INT_MAX && (!vis[i] || !vis[j]) && flag[i][j]) {
				flag[i][j] = flag[j][i] = false;
				cnt ++;
			}
```

## 代码实现：

知道了这些东西，完整代码就很好写出来了：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1005;
int n , m;
int mapp[MAXN][MAXN];
int dis[MAXN] , pre[MAXN];
bool flag[MAXN][MAXN] , vis[MAXN];
int idx;

inline void bfs(int x) {
	queue<pair<int , int> >q;
	q.push(make_pair(1 , 0));
	vis[1] = true;
	while(!q.empty()) {
		int u = q.front().first;
		int t = q.front().second;
		q.pop();
		dis[u] = t;
		for(register int i = 1;i <= n;i ++)
			if(i != u && !vis[i] && mapp[u][i] != INT_MAX) {
				q.push(make_pair(i , t + 1));
				vis[i] = true;
				pre[i] = u;
			}
	}
	return;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(register int i = 1;i <= n;i ++)
		for(register int j = 1;j <= n;j ++)
			if(i != j)
				mapp[i][j] = INT_MAX;
	while(m --) {
		int u , v , x;
		cin >> u >> v >> x;
		mapp[u][v] = mapp[v][u] = 1;
		flag[u][v] = flag[v][u] = x;
	}
	bfs(1);
	memset(vis , false , sizeof(vis));
	int k = n , cnt = 0;
	vis[n] = true;
	while(pre[k]) {
		if(!flag[k][pre[k]]) {
			flag[k][pre[k]] = flag[pre[k]][k] = true;
			cnt ++;
		}
		k = pre[k];
		vis[k] = true;
	}
	for(register int i = 1;i <= n;i ++)
		for(register int j = 1;j <= n;j ++)
			if(mapp[i][j] != INT_MAX && (!vis[i] || !vis[j]) && flag[i][j]) {
				flag[i][j] = flag[j][i] = false;
				cnt ++;
			}
	cout << cnt;
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

# P3753 国事访问题解  
实际上非常简单的一道最短路问题，问候作者语义不清，甚至都没说有向还是无向 ~~（如果是我的问题别怪我）~~。 
***
### 解题思路  
事实上就是在进行最短路时维护要修改的权值，这里我使用 SPFA 来解决。暂时就当大家都会 SPFA 了啊。  

现在我们来解决**要修改路径数**的维护，易得在一开始时，要修改的路径数就是 $\sum_{i=1}^{m}c_i$，即所有的路都炸掉，在输入时计算即可。同时，每增加一条路，若该路本来就有，那么**要修改路径数**比前面减 1，否则加 1。
***
大概都理解了哈，用一个结构体存储当前 dis 的值和在此情况下的最小要修改路径数，同时用 dis 的值做第一关键字，要修改路径数做第二关键字，就可以了。
***
### AC 代码

```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
int n,m;
int a,b,c;
int h[1005],ne[1005],w[1005],e[1005],idx;//链式前向星
void add(int a,int b,int c){
	e[idx]=b;
	w[idx]=c;
	ne[idx]=h[a];
	h[a]=idx++;
}
struct dg{//结构体存dis
	int d,c;
}dis[1005];
int o;
int vis[1005];
void spfa(){
	for(int i=1;i<=n;i++)dis[i].d=0x3ffffff;
	dis[1].d=0,dis[1].c=o;
	queue<pair<int,int> > q;
	q.push({1,o});
	vis[1]=1;
	while(q.size()){
		int t=q.front().first,siz=q.front().second;
		q.pop();
		vis[t]=0;
		for(int i=h[t];i!=-1;i=ne[i]){
			int cnt=siz;
			int j=e[i];
			if(w[i]==1)cnt--;//增加路径后更新要修改的路径数
			else cnt++;
			if(dis[j].d>dis[t].d+1){//d 做第一关键字
				dis[j].d=dis[t].d+1;
				dis[j].c=cnt;
				if(!vis[j]){
					vis[j]=1;
					q.push({j,cnt});
				}
			}
			else if(dis[j].d==dis[t].d+1 && dis[j].c>cnt){//c做第二关键字
				dis[j].c=cnt;
				if(!vis[j]){
					vis[j]=1;
					q.push({j,cnt});
				}
			}
			//cout<<t<<"->"<<j<<" "<<dis[j].d<<" "<<dis[j].c<<" "<<dis[t].d<<endl;
		}
	}
}
int main(){
	memset(h,-1,sizeof h);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);//无向图^_^
		o+=c;
	}
	spfa();
	cout<<dis[n].c;
}
```

---

## 作者：yzjznbQWQ (赞：1)

# 题解 P3753 国事访问
[题目传送门](https://www.luogu.com.cn/problem/P3753)


---

# 题目大意
给出一个无向图，每个边有两种 $0$ 与 $1$ 两种状态。
求**仅保留一条**起点到终点的最短路的**最小**修改次数。

**注意是只保留一条**。
# 题解
考虑删掉所有通边（即值为 $1$）的边。然后跑一遍单源最短路，并记录 $cost_i$ 表示到 $i$ 点的最少修改次数。

那么，如何维护 $cost$ 呢？不妨令 $cost$ 的初始值为 $n$。只需要在跑最短路的时候，判断这条边是否是通的（即是否值为 $1$）。

- 如果为 $1$，那么我们让次数减一，因为这样就不必删掉这条边。
- 如果为 $0$，那么我们让次数加一，因为要通过这条边，所以要修好这条边。

于是我们可以建一个边权为 $1$ 的无向图，跑一次 dij。

# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read();

const int max_node=1e5+5;
const int max_edge=1e5+5;

struct node
{
    int u,v;

    inline bool operator <(const node x)const{
        return v>x.v;
    }
};

struct edge
{
    int u,v,w,cost,next;
}e[max_edge];

int n,m,cnt,tot;
int dis[max_node],head[max_node],cost[max_node];

priority_queue<node> q;

bool vis[max_node];

inline void add(int u,int v,int w,int c)
{
    e[++cnt].u=u;
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].cost=c;
    e[cnt].next=head[u];
    head[u]=cnt;
}

inline void init()
{
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[1]=0;
}

inline void dijkstra()
{
    init();
    q.push(node{1,0});
    while(!q.empty())
    {
        node p=q.top();
        q.pop();

        int now=p.u;
        if(vis[now]) continue;
        vis[now]=1;

        for(int i=head[now];i;i=e[i].next)
        {  
            int v=e[i].v;
            if(dis[v]>dis[now]+e[i].w)
            {
                cost[v]=cost[now]+e[i].cost;
                dis[v]=dis[now]+e[i].w;
                q.push(node{v,dis[v]});
            }
            else if(dis[v]==dis[now]+e[i].w)//如果大小相等，取两者cost的最小值 
                cost[v]=min(cost[v],cost[now]+e[i].cost);
        }
    }
}

int main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        int u=read(),v=read(),w=read();
        if(w) tot++;
        w=w?-1:1;//如果是该路是通的，那么将其标记为-1，否则为1 
        add(u,v,1,w),add(v,u,1,w);
    }

    dijkstra();

    printf("%d",tot+cost[n]);
    return 0;
}

inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0') 
    {
        if(c=='-') f=0;
        c=getchar();
    }
    while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return f?x:(~(x-1));
}
```

---

## 作者：mysterys (赞：1)

# 题意简化
 给定一个无向图，将除了 $1$ 到 $n$ 的最短路上的边全部销毁，反之全部修复。初始有给定每条边的状态，求最小销毁次数。
# 思路
1. 转化一下，答案 $=$ 所有边的初始状态 $-$ 不需要改变的边。
2. 跑一次最短路，在松弛的同时总计不需要改变的次数。
# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=1005;
const int M=1005;
int ans;
struct edge{
	int nxt,to,dis;
}e[M<<1];
queue<int>q;
int head[N],cnt;
int dist[N],cost[N];
int n,m;
bitset<N>vis;
inline void add(int u,int v,int d){
	e[++cnt]=(edge){head[u],v,d};
	head[u]=cnt;
}

inline void dij(){
	for(int i=1;i<=n;i++) dist[i]=1e9;
	dist[1]=cost[1]=0;
	q.push(1);
	while(!q.empty()){
		int u = q.front(); q.pop();
		if(vis[u]) continue;
		vis[u] = true;
		for(int i = head[u];i;i = e[i].nxt){
			int v=e[i].to;
			if(dist[v]>dist[u]+1){
				dist[v]=dist[u]+1;
				cost[v]=cost[u]+(e[i].dis?-1:+1);
				q.push(v);
			}
		}
	}
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cout.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,d;
		cin>>u>>v>>d;
		add(u,v,d);add(v,u,d);
		ans+=d;
	}
	dij();
	cout<<ans+cost[n];
	return 0;
}
```

---

## 作者：zhchz (赞：0)

# BFS - Solution - P3753
## 题意简述
将国家视为图的顶点，公路视为边，公路的状态（能通行/不能通行）视为边的权重。

- $n$ 表示图中顶点的数量，即城市的数量。
- $m$ 表示图中边的数量，即公路的数量。

对于每条边 $a,b,c$：

- $a$ 是边的起始顶点（城市），
- $b$ 是边的终止顶点（城市），
- $c$ 表示边的状态，$1$ 表示这条边（公路）是可以通行的，$0$ 表示这条边是不能通行的。

目标是找到一条从顶点 $1$ 到顶点 $n$ 的最短路，路径上的边需为可以通行的状态，并且最短路的前提下，需要改变尽可能少的边的状态（从不能通行改为可以通行，或者从可以通行改为不能通行）。**不在所选路径上的所有边均需炸毁。**
## 案例分析
![](https://cdn.luogu.com.cn/upload/image_hosting/hai6n0fl.png)

记需要改变路状态的数量为 $k$。

解应是 $1\to7\to9$，$k=5$。

路线 $1\to4\to6\to7\to9$ 虽然 $k=1$，但不是最短路，故不是答案。
## 小技巧 I

在这里我们可以将不能通行边的权值设为 $1$，将可通行边的权值设为 $-1$，原因如下：

记边权为 $w$。
- 对于不能通行的边，若要通过需修好，不通过则不作处理，故 $w=1-0=1$。
- 对于可通行的边，若要通过无需操作，不通过则需炸毁，故 $w=0-1=-1$。

## 小技巧 II

因为未在所选路径上的可通行道路均需炸毁，所以可以先处理出其数量，答案即为其数量加BFS结果。

## Code:
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<string.h>
#include<algorithm>
#include<set>
#include<queue>
#define ll long long
#define ull unsigned long long
#define p_q priority_queue
using namespace std;

const int N=1010;
int n,m,st,ed,x,y,z,tot,cnt,w;
int head[N],dis[N],ans[N];
bool vis[N];
queue<int> q;//BFS队列

struct E{
	int next,to,w;
}e[N<<1];

void add(int x,int y,int z){
	e[++tot]=(E){head[x],y,z?-1:1};
	head[x]=tot;
}//邻接表加边

int bfs(int st,int ed){
	memset(dis,0x3f,sizeof dis);
	memset(ans,0x3f,sizeof ans);
	vis[st]=1;
	dis[st]=ans[st]=0;
	q.push(st);
	while(!q.empty()){//BFS
		x=q.front();q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].next){
			y=e[i].to;
			w=e[i].w;
			if(dis[y]>dis[x]+1){
				dis[y]=dis[x]+1;
				ans[y]=ans[x]+w;
				if(!vis[y]){
					q.push(y);
					vis[y]=1;
				}
			}
			if(dis[y]==dis[x]+1){//距离相等
				if(ans[y]>ans[x]+w)
					ans[y]=ans[x]+w;//更新更优解
			}
		}
	}
	return ans[ed];
}

int main(){
	cin>>ed>>m;
	while(m--){
		cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z);//建双向边
		cnt+=z;
	}
	cout<<bfs(1,ed)+cnt;
```

---

## 作者：small_stone (赞：0)

~~先吐槽一下出题人，题意怎么这么不清楚。~~

题目的意思是把总统走的路全修好，其它的路全部毁掉。并在保证总统走的路是最短的情况下，修路代价最小。

不妨设有 $x$ 条边为 $1$ ，其中 $y$ 条是要走的，总统一共走了 $z$ 条边，那么修路代价是：

$(z-y)+(x-y)$

第一个 $(z-y)$ 表示有多少条没修好的边是总统经过的，需要修好。第二个 $(x-y)$ 表示有多少条修好的边是总统没经过的，需要毁坏。将上面的公式整理得到：

$x+(z-y)-y$ （公式一）

可以发现 $(z-y)$ 就是总统经过的还没修好的边的数量，$y$ 就是总统经过的已经修好的边的数量。

可以发现，题目就是求公式一的最小值。$x$ 可以预处理出，$(z-y)-y$ 的求法是把已经毁坏的边的代价设为 $1$，把还没有毁坏的边的代价设为 $-1$，就变成最小费用最短路问题了。

数据范围较小，可用 Bellman-Ford 求出，本人代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,head[1001],dis[1001],val[1001],u,v,w,ans=0,pos=0;
struct edge{
    long long u,v,w,nxt;
}e[2001];
long long f(long long x) {
	if (w==1) return -1;
	return 1;
}
void add(long long u,long long v,long long w)
{
    e[++pos]={u,v,w,head[u]};
    head[u]=pos;
}
void BellmanFord(long long st)
{
    memset(dis,0x3f,sizeof dis);
    dis[st]=0;
    val[st]=0;
    for (long long i=1;i<=n-1;i++) {
    	for (long long j=1;j<=pos;j++) {
            long long u=e[j].u,v=e[j].v,w=e[j].w;
            if (dis[v]>dis[u]+1) {
            	dis[v]=min(dis[v],dis[u]+1);
            	val[v]=val[u]+w;
			}
			else if (dis[v]==dis[u]+1) {
				if (val[v]>val[u]+w) val[v]=val[u]+w;
			}
        }
	}  
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for (long long i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld",&u,&v,&w);
        if (w==1) ans++;
        add(u,v,f(w));
        add(v,u,f(w));
    }
    BellmanFord(1);
    printf("%lld",val[n]+ans);
    return 0;
}
//用时：15ms
//内存：808.00KB
```

---


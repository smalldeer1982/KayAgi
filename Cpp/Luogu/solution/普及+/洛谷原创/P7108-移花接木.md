# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# 题解

## 作者：AsunderSquall (赞：26)

刚推出式子时不知道为什么被卡常了，非常自闭 [link](https://www.luogu.com.cn/record/42758456)   

声明1：下文由于本人菜，分不清“结点”和“节点”，请忽略。 

update:修改了一个笔误。


# 题意  
有一个高度无限的有根满 $a$ 叉树，你每次操作可以选择一棵子树全部删除，或者选择一棵子树，拼到另一个结点下面，问至少需要几次操作可以把这棵树变成高度为$h$的满$b$叉树。  
（题意中有描述的不到位的地方，仅供回忆题目，具体见[原题目](https://www.luogu.com.cn/problem/U133018?contestId=13514)

# 题解  
声明2：下文所说的“删除结点”为删除结点及其子树。  
$\Large\texttt {subtask 1}$  
$h=0$   
也就是说删得只剩根节点，输出 $a$ 即可   
![](https://cdn.luogu.com.cn/upload/image_hosting/cn40tuz9.png)  
如图为 $a=5,b=?,h=0$ 的情况，删去黑色节点。    
`if (h==0) cout<<(a);`  
$\Large\texttt {subtask 2}$  
$a=b$  
只需要将多余的子树删去即可  
设根为第$0$层，那么要保留到第 $h$ 层，$h+1$ 层的所有结点都要删去，而第 $h+1$ 层有 $a^{h+1}$ 个结点  
![](https://cdn.luogu.com.cn/upload/image_hosting/6ta3uorx.png)  
如图为$a=3,b=3,h=1$ 的情况，删去黑色节点。  
`if (a==b) cout<<(ksm(a,h+1,mod));`    
$\Large\texttt {subtask 3}$  
$a=1$  
原始的树为一条链  
那么我们可以把满 $b$ 叉树分成若干条从上到下链，使数量最少，链的条数就是答案。  
设$k$层的满$t$叉树的链的条数为 $f(k,t)$。  
我们考虑使一棵满 $t$ 叉树分成的链最少，根节点一定在某条链中，那我们任取一个儿子 $u$，把经过$u$的链拼上一条 $root\to u$ 的边。  
那么有 $f(k,t)=t\cdot f(k-1,t)$ 又有 $ f(0,t)=1$，所以$ f(k,t)=t^k$。 
以$a=1,b=2,h=3$为例  
![](https://cdn.luogu.com.cn/upload/image_hosting/ojg4yx19.png)  
对于根的每个儿子，都可以分成 $f(2,2)$ 条链，总共 $2f(2,2)$ 条链  
![](https://cdn.luogu.com.cn/upload/image_hosting/5jd0z4cq.png)  
考虑根，只要连到一条经过儿子的链上就行了  
![](https://cdn.luogu.com.cn/upload/image_hosting/717lp22z.png)

`if (a==1) cout<<(ksm(b,h,mod));`  
$\Large\texttt {subtask 4}$  
$b=1$  
要把树删得只剩一条链  
那么第 $0,1,\cdots h-1 $ 层都有多余的 $a-1$ 个结点，而第 $h$ 层则有 $a$ 个，将他们删除即可。  
![](https://cdn.luogu.com.cn/upload/image_hosting/7re2y0uh.png)  
如图为 $a=3,b=1,h=2$ 的情况，删去黑色节点。  
`if (b==1) cout<<(((a-1)*h+a)%mod);`  

$\Large\texttt {subtask 5\&6}$  
我感觉后面的点都没什么用……其实只要把这个式子搞出来后面就一样了。。。 

分为 $a<b$ 和 $a>b$ 两种情况讨论（因为本人很菜）  
$\large \text {对于}a<b\text{的情况}$  
我们要把满$a$叉树补成满 $b$ 叉树  
那么我们分为两个步骤  
- 把前面$h$层补成满$b$叉树  
- 删去第$h+1$层多余的结点  

对于第一步，我们考虑一层一层拖子树。  
先把第$1$层补完，拖来了 $b-a$ 棵子树。  
这个时候第$2$层就有 $b\cdot(b-a)$ 棵子树要拖。  
$\cdots \cdots$  
第$h$层有 $b^{h-1}(b-a)$ 棵子树要拖。  
那么我们只需要将他们加起来 $(b-a)\sum_{i=0}^{h-1}b^i$。  
对于第二步，第 $h$ 层有 $b^h$ 个结点，那么第 $h+1$ 层有 $a b^h$ 棵子树，将他们全部删去。  
所以答案为 $\sum_{i=0}^{h-1}b^i+ab^h$。  

真 的 吗 ？  

显然，如果我们将本来第二步中应该删去的子树给拖走，那么就省去了**删除这个结点**这一步骤。  
所以答案为 $\max(ab^h,(b-a)\sum_{i=0}^{h-1}b^i)=ab^h$

这样说可能有点模糊，我们来举个例子。  
Example:$a=2,b=3,h=2$  （深度 $>3$ 的节点不画出）。   
下面的图的标号和上面 出现什么标什么 的标号不太一样，对于标号为 $i$ 的节点，我们给它的左儿子和右儿子分别标号为 $2i$ 和 $2i+1$ 。   
![](https://cdn.luogu.com.cn/upload/image_hosting/e9ukln1t.png)  
比如说第一层，如果我们随便拖一个下面的节点过来，这样是可行的，但是不够优秀。  
![](https://cdn.luogu.com.cn/upload/image_hosting/b4lspbk5.png)  
我们知道，到时候我们肯定要把 $8$ 这个节点从 $4$ 的儿子中移除，所以我们如果把 $8$ 拖过来，就可以减少操作次数。  
![](https://cdn.luogu.com.cn/upload/image_hosting/y2ne61fx.png)  
同理，要使 $2$ 的儿子数目变成 $3$，我们把 $9$ 号节点拖过去。  
![](https://cdn.luogu.com.cn/upload/image_hosting/b0i98ts8.png)  
然后 $10\to3,11\to 8$  
![](https://cdn.luogu.com.cn/upload/image_hosting/ijokc90i.png)  
最后把底部的所有节点全部删去  
![](https://cdn.luogu.com.cn/upload/image_hosting/k6vbok37.png)


$\large \text {对于}a>b\text{的情况}$   
同样分为两个步骤  
- 把前面$h$层删成满$b$叉树  
- 删去第$h+1$层多余的结点  

对于第一步，我们考虑一层一层删子树，答案与 $a<b$ 的情况类似，为 $(b-a)\sum_{i=0}^{h-1}b^i$  
对于第二步，为 $ab^n$，那么答案就为 $(b-a)\sum_{i=0}^{h-1}b^i+ab^h$   
![](https://cdn.luogu.com.cn/upload/image_hosting/kr2troox.png)  
如图为 $a=3,b=2,h=2$ 的情况，删去黑色节点

事实上我并不理解为什么到了这一步还推不出正确答案（似乎也没有被卡到这一档部分分的人）。  

$\Large\texttt {subtask 7\&8}$  
显然$\sum_{i=0}^{h-1}b^i$可以快速计算。  
$$\text{令 }S=\sum_{i=0}^{h-1}b^i$$
$$\text{有 }bS=\sum_{i=1}^h b^i$$
$$\text{下减上得 }(b-1)S=b^h-1$$
$$\text{则 }S=\dfrac{b^h-1}{b-1}$$
这个应该小学就会了吧。。。  
同时这个也可以解释为什么 $\max\{ab^h,(b-a)\sum_{i=0}^{h-1}b^i\}=ab^h$  
注意 $b=1$ 的时候有除以 $0$ 的情况，要特判。

# 代码  
真的很短，为什么不去自己写呢？
```cpp
#include<bits/stdc++.h>
#define int long long
#define rd(x) x=read()
using namespace std;
const int mod=1e9+7;
inline int read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int ksm(int x,int y,int z){int ret=1;while (y){if (y&1) ret=(ret*x)%z;x=(x*x)%z;y>>=1;}return ret;}
int INV(int x){return ksm(x,mod-2,mod);}
int a,b,h;
int T;
signed main()
{
    rd(T);
    while (T--)
    {
        rd(a);rd(b);rd(h);
        if (b==1) cout<<(((a-1)*h+a)%mod);else
		if (a<=b) cout<<ksm(b,h,mod)*a%mod;
        else cout<<(a*ksm(b,h,mod)%mod+(ksm(b,h,mod)-1)*(a-b)%mod*INV(b-1)%mod)%mod;
        putchar('\n');
    }
}
```

---

## 作者：AuCloud (赞：17)

大数学题……


### 本题解中ksm指“快速幂”（

```
int ksm(int x, int mi)
{
	int ret = 1;
	while(mi)
	{
		if(mi & 1) ret = ret * x % mo;
		x = x * x % mo;
		mi >>= 1;
	}
	return ret;
}
```

## h==0

显然只要把第一层所有都剪掉就好

```
if(h == 0) printf("%lld\n", a % mo);
```
## a==b

第h+1层多余的砍掉即可，总数$a^{h+1}$

```
else if(a == b)
{
	printf("%lld\n", ksm(a, h + 1));
}
```

## a==1

这是从链->b叉树的过程

考虑按顺序给每一层都加上没加上的边

（画图好难QAQ

拿字符画吧（

```
O          O         
|         /|\
O        O O O
|  +2   /  |  \    +6
O  ->  O   O   O   ->   
|               \
.              ...
.
.
```
```
      O 
     /|\
   /  |  \    +1 
  O   O   O   ->
 /|\ /|\ /|\
 OOO OOO OOO
 |
 .
 .
 .
```

```
      O 
     /|\
   /  |  \
  O   O   O 
 /|\ /|\ /|\
 OOO OOO OOO
```
共：9次

~~猜测：$ans=b^h$，好耶~~


推一波柿子：

第一层补齐了b-1个分支

第二层补齐了b*b-1个分支

...

以此类推，第N层补齐了$b^{N-1}(b-1)$个分支

所以总补齐数量=$\sum_{i=1}^{N} b^i(b-1)$

再加上最后的砍去多余的1，总数为

$$\sum_{i=0}^{N} b^i(b-1) + 1$$
$$=(b-1+b^2-b+b^3-b^2+...+b^n-b^{n-1})+1$$
$$=b^n-1+1$$
$$=b^n$$

代码：

```
else if(a == 1)
{
	printf("%lld\n", ksm(b, h));
}
```
## b==1

这回是a叉树到链

同样考虑每一层把没用的删掉

因为只保留一个节点所以每层删除的均为（a-1）条

~~不想画图了QAQ~~

```
      O 
     /|\
   /  |  \   +2
  O   O   O  ->
 /|\ /|\ /|\
 OOO OOO OOO
 .......
 
 
     O
     |   +2
     O   ->
   / | \ 
  O  O  O
 /|\/|\/|\
 ...

O
|
O   +3
|   ->
O
/|\
.
.
.

O
|
O
|
O
```

总数：7

对于每一层都删除了a-1个多余的枝条，剩下的第h+1层剪掉了所有枝条，共a个

所以答案是$(a-1)\times h+a$

(这里程序里写的是$(a-1)\times (h+1) + 1$,本质相同)

```
else if(b == 1)
{
	printf("%lld\n", (a - 1) * (h + 1) % mo + 1);
}
```

## 无特殊限制

~~BOSS来了（~~

根据前面的启发，我们可以知道a,b的大小关系是对答案有很大影响的，所以进行分类讨论：

### $a<b$

还是考虑接好每一层再减去多余部分：

~~图真的画不下去了QAQ~~

**以下较为抽象**

```
     O
    / \    +1
   O   O   ->
  /\   /\
  O O  O O
 /\ /\ /\ /\
  .........
      O
    / | \    +3*1
   O  O  O   --->
  /\  /\  /\
 O O O O  O O  注意：这里在最下层标*的地方拿了一支来填空
 /\/\/\/\/\/ *
 
 .......
 
         O
    /    |    \    +14 
   O     O     O   -->
  /|\   /|\   /|\
 O O O O O O O O O 同样的，这里拿了标*的3支来填空
 /\/\/\/\/\/\**/\*
 .........
 
 
      O 
     /|\
   /  |  \  
  O   O   O
 /|\ /|\ /|\
 OOO OOO OOO
```
继续推柿子：

对于第1层，我们补了b-a个分支；

对于第2层，我们在此基础上补了b*(b-a)个分支

...

对于第N层，我们补了$b^{n-1}\times (b-a)$个分支

为了方便，设我们共补齐了$T$支

### 重点：

**我们最后去掉了一堆东西**

这堆东西就是我们最后一层多余的枝杈

而这堆多余的枝杈个数=原枝杈个数-向上补齐时用到的枝杈个数

$$del=a\times b^h - T$$

而

$$ans=del+add$$
$$=T+a\times b^h-T$$
$$=a\times b^h$$

~~妙啊~~

代码：

```
if(a < b)
{
	printf("%lld\n", a * ksm(b, h) % mo);
}
```

### $a>b$

```
      O 
     /|\      +1
   /  |  \    ->
  O   O   O
 /|\ /|\ /|\
 OOO OOO OOO
 ......
 
    O 
    /\
   /  \   +2
  O    O  ->
 /|\  /|\
 OOO  OOO
/|\/|\/|\....

      O
     /  \
    O    O   +12
   /\    /\  -->
  O O   O  O
 /|\/|\/|\/|\
........
 
      O
     /  \
    O    O 
   /\    /\ 
  O O   O  O
```
继续推柿子

和b=1时类似，考虑推广：

第一层删除了(a-b)个

第二层删除了b*(a-b)个

...

第N层删除了$b^{N-1}*(a-b)$个

最下面删除了$b^{h}*a$个

所以有：

$$ans=\sum_{i=0}^{h-1}(b^i\times (a-b)) + b^h\times a$$

$$=(a-b)\times \sum_{i=0}^{h-1}b^i + b^h\times a$$

然后发现$h<=10^9$，恐怕会T飞

发现中间那个玩意是等比数列的和，套一下公式得：

$$ans=(a-b)\times \frac{b^{h}-1}{b-1}+ b^h\times a$$

其中分数部分求一下逆元，拿费马小定理就可以了

代码：

```
else if(a > b)
{
	int ans = (ksm(b, h) - 1 + mo) % mo * ksm(b - 1, mo - 2) % mo * (a - b) % mo;
	ans = (ans + ksm(b, h) * a) % mo;
	printf("%lld\n", ans);
}
```

### a==b
这个之前讨论过了（

完结撒花~芜湖~

完整代码就不贴了/fad

~~（看在画了那么多图的份上留个赞再走吧QAQ~~

---

## 作者：y0y68 (赞：3)

### 前置芝士：快速幂，逆元，等比数列求和

题意：一棵无穷高的满 $a$ 叉树，可以给一个节点换父亲（接木），也可以给弄死某一个节点的某一个儿子，及这个儿子的所有后代（移花），以上两种都算一次操作，问至少几次能把这棵树变成高度恰好为 $h$ （根节点高度为 $0$）的满 $b$ 叉树。

大致思路即分以下两种情况讨论：

一、 $a \ge b$

显然此时只需“移花”，我们先取 $a=3,b=2,h=2$ 的情况如下图（有些丑 ~~，但还能看~~）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ilyt1fs4.png)

然后进行删边（一条用红色圈圈出的边表示一次删除的所有点的最近公共祖先与其父亲的连边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mxyfuadm.png)

考虑第 $x$ 层与第 $x+1$ 层之间所删的边，发现是 $(a-b)b^x$，第 $h$ 层以下显然需进行 $ab^h$ 次操作。

得到操作次数总和为：

$$[(a-b)b^0+(a-b)b^1+ \cdots +(a-b)b^{h-1}]+ab^h$$

$$=(a-b)(b^0+b^1+ \cdots +b^{h-1})+ab^h$$

$$=\frac{(a-b)(b^h-1)}{b-1}+ab^h$$

快速幂 $+$ 逆元即可算出

二、$a < b$

给图：



此时既需“接木”也需“移花”，其实就是除第 $h$ 层外每一层另接上 $a-b$ 个儿子，第 $h$ 层节点的所有儿子砍掉，为了使操作数最少，我们可以把砍掉的儿子接在所需的地方，合并成“接木”，又因为要砍掉的儿子有无穷多，所以只用 $ab^h$ 次操作（即第 $h$ 层的所有有儿子的节点数量）。

--------------------------

核心代码：
```
inline ll ny(ll x){//逆元
    return qpow(x,mod-2);
}
inline ll db(ll x,ll y){//等比数列求和，即求x^0+x^1+⋯+x^y
	if(x==1)return y+1;//特判
	return (x*(qpow(x,y)-1)%mod*ny(x-1)%mod+1)%mod;
}

if(a>b)out((a*qpow(b,h)%mod+db(b,h-1)*(a-b)%mod)%mod);
else out(a*qpow(b,h)%mod);
```

再加上某一些 $h==0$、$a==1$、$a==b$ 之类的特判即可通过。

看到了就给一个赞吧qwq

---

## 作者：小蒟蒻皮皮鱼 (赞：3)

T3

为方便起见，设原树为 $T1$ ，转换后的树为 $T2$ ，“移花”为一操作，“接木”为二操作。

首先，当 $a \geq b$ 时，因为此时 $T2$ 是 $T1$ 的一部分，所以只进行一操作一定不比进行二操作劣。

 Subtask1：

当 $h = 0$ 时， $T2$ 只有一个节点，这时只需要把这个节点相连的边全部删掉，答案是 $a$ 。

Subtask2：

当 $a = b$ 时， $T2$ 是 $T1$ 的子树。这时候最优方案必然是 $T2$ 与 $T1$ 根相同，然后删除第 $h$ 层节点向下连接的所有边，答案是 $a^{h+1}$ 。

Subtask4：

当 $b=1$ 时， $T2$ 是一条链，此时最优方案一定是在 $T1$ 上找一条链，然后把除了向下连接的边全部删掉。这样每个节点删除的是 $a-1$ 条边，深度最大的节点删除 $n$ 条边，答案是 $(a - 1) \times (h + 1) +1$

考虑正经做法：

由于前文提到的性质，所以首先想到按照 $a > b$ 和 $a < b$ 分成两类。（$a=b$ 已经讨论过了）

当$a> b$ 时：

考虑这样的一棵 $T1$ ：

![](https://cdn.luogu.com.cn/upload/image_hosting/uhnxo71i.png)

假如 $a = 3, b=2$ 。

当 $T2$ 深度为0时，操作次数为3，即 $a$ 。

当 $T2$ 深度为1时，操作次数为7。

![](https://cdn.luogu.com.cn/upload/image_hosting/ly4u577j.png)

分开看：对于点2和4，分别进行了深度为0的操作。在此基础上，又断开了与点1相连的一条边。答案即为 $a \times b - (a - b)$ 。

我们设 $f_i$ 表示当 $T2$ 深度为 $i$ 的时候的答案。则有递推式：
$$
f_0=a\\
f_i=f_{i-1}\times b - (a-b)
$$
考虑求出通项公式：
$$
\begin{aligned}&
f_n=b^n+(a-b)\times (b^{n-1} + b^{n-2}+...+b^0)\\&
\ \ \ \ =a\times b^n - (a-b)\times \frac{b^n-1}{b-1}
\end{aligned}
$$
然后就可以求出答案。 

注意当 $b = 1$ 时要特判，此时 $f_n =  a\times b^n + (a-b)\times h$ 。

~~但是数据好像没有b=1？别问怎么知道的。~~

当 $a < b$ 时

考虑这样一棵 $T1$ ：

![](https://cdn.luogu.com.cn/upload/image_hosting/w2xme4ez.png)

假如 $a = 2,b=3$：

当 $T2$ 深度为0时，操作次数为2，即 $a$ 。

当 $T2$ 深度为1时，操作次数为6，即 $a \times b$ 。

其实也就是把两次一操作用一次二操作替换了。

![](https://cdn.luogu.com.cn/upload/image_hosting/zl5eu6q6.png)

同理，对于深度为 $i$ 时，答案即为 $a\times b^i$



代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read()
{
	ll ans = 0;
	char c = getchar(), last = ' ';
	while(c < '0' || c > '9') last = c, c = getchar();
	while(c >= '0' && c <= '9') ans = (ans << 1) + (ans << 3) + c - '0', c = getchar();
	if(last == '-') ans = -ans;
	return ans;
}
const ll mod = 1e9+7;
ll T, a, b, h;
ll qpow(ll x, ll k)
{
	ll ans = 1;
	while(k)
	{
		if(k & 1) ans = ans * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return ans % mod;
}
ll work1()
{
	ll x = a, cnt = 0;
	x = ((a - 1) * qpow(b, h + 1) % mod - a + b + mod) % mod * qpow(b - 1, mod - 2) % mod;
	return x % mod;
}
ll work2()
{
	ll x = a, cnt = 0;
	x = a * qpow(b, h) % mod;
	return x % mod;
}
int main()
{
	T = read();
	while(T --)
	{
		a = read(), b = read(), h = read();
		if(h == 0) printf("%lld\n", a);
		else if(a == b) printf("%lld\n", qpow(a, h + 1) % mod);
		else if(b == 1) printf("%lld\n", ((a - 1) * (h + 1) % mod + 1) % mod);
		else if(a > b) 
		{
			printf("%lld\n", work1() % mod);
		}
		else if(a < b)
		{
			printf("%lld\n", work2() % mod);
		}
	}
}
```



---

## 作者：peppaking8 (赞：2)

注意到添边用“接木”操作，删边用“移花”操作，所以自然想到考虑 $a,b$ 的大小关系。

1）$a=b$。这时只需要移除深度 $h+1$ 及以上的子树即可。深度为 $h+1$ 的点共 $a^{h+1}$ 个，所以答案就是 $a^{h+1}$。

2）$a>b$。这时只需要删边即可。考虑在当前树中标记一些边，使得标记的边构成一棵深度 $h$ 的完美 $b$ 叉树。这个时候把树上其他所有东西删掉即可。删掉的边分两种：

- 根节点连向叶节点的边中没有被标记的边

这样的点共有 $b^h$ 个，这些点需要删掉它向下连接的 $a$ 条边。

- 有标记的边

这样的点是 $b$ 叉树的前 $h$ 层，共有 $\text{bsize}=1+b+...+b^{h-1}$ 个结点，这些点需要删去 $a-b$ 条边。

综上所述，答案为
$$a\times b^h+(a-b)\times \text{bsize}$$
其中，$\text{bsize}$ 可以用等比数列求和公式快速计算，此时需要特判 $b=1$ 的情况。

3）$a<b$。这时候需要用“接木”操作加边。需要加的点共有 $T=\text{bsize}\times (b-a)$ 个，每个都需要一次“接木”的操作。之后就是将下面多余的子树用“移花”删掉，这些共有 $b^h\times a-T$ 个，减去 $T$ 是因为每次“接木”其实会移掉一个多余的子树。

相加后，得到答案为 $b^h\times a$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MOD 1000000007
using namespace std;
int T;
ll a,b,h;
ll qpow(ll A,ll B){//快速幂，求A^B
	ll ans=1,base=A;
	while(B){
		if(B&1) ans=(ans*base)%MOD;
		base=(base*base)%MOD;
		B>>=1;
	}
	return ans;
}
ll inv(ll x){//求x的逆元
	return qpow(x,MOD-2);
}
ll Moder(ll x){//求整数x对MOD取模
	return (x%MOD+MOD)%MOD;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%lld%lld%lld",&a,&b,&h);
		if(h==0) printf("%lld\n",a);
		else if(a>b){
			ll pbh=qpow(b,h),invb=inv(b-1),at;
			if(b!=1) at=((pbh-1)*invb)%MOD;
			else at=h;
			printf("%lld\n",Moder((at*(a-b))%MOD+a*pbh));
		}
		else if(a==b){
			printf("%lld\n",qpow(a,h+1));
		}
		else{
			printf("%lld\n",Moder(qpow(b,h)*a));
		}
	}
}
```

---

## 作者：WarningQAQ (赞：2)

数学题，高度 $\infty$ 是为了防止你想多考虑嫁接是否够用。 


------------
### 分析：
+ $\text{case1}$：当 $a\ge b$ 时，只需要砍树就行，嫁接没有任何用处。

>第 $0$ 层要砍掉 $(a-b)\to(a-b)\times b^0$ 个树枝；

>第 $1$ 层要砍掉 $(a-b)\times b^1$ 个树枝；

>第 $2$ 层要砍掉 $(a-b)\times b^2$ 个树枝；

>$\cdots$

>第 $h-1$ 层要砍掉 $(a-b)\times b^{h-1}$ 个树枝；

>第 $h$ 层要全部砍光，也就是 $a\times b^h$ 个树枝。

所以一共砍掉了：
$$(a-b)\times\left(b^0+b^1+b^2+\cdots+b^{h-1}\right)+a\times b^h$$
$$=(a-b)\times \frac{1-b^h}{1-b}+a\times b^h$$
用快速幂 $+$ 逆元直接求就行。

注意 $b=1$ 时的特判。
+ $\text{case2}$：当 $a<b$ 时，先用嫁接把 $h$ 层以下的枝补全了，再考虑把 $h$ 层砍光。

换的时候可以贪心，用第 $h$ 层的树枝嫁接给之前的。

>第 $0$ 层要接 $(b-a)\to (b-a)\times b^0$ 个树枝；

>第 $1$ 层由于上一层新添了 $b-a$ 个树枝，所以要接 $(b-a)\times b^1$ 个树枝；

>$\cdots$

>第 $h-1$ 层就要接 $(b-a)\times b^{h-1}$ 个树枝。

所以一共只需要 $a\times b^h$ 次操作。

快速幂直接算。

时间复杂度是 $\mathcal O(T\times log(h))$。

------------
### 代码：
```cpp
#include "cstdio"
#include "cctype"
#include "algorithm"
#define mod 1000000007
#define ll long long
ll ans, t, a, b, h;
char buffer[1 << 28], *S = buffer, puffer[1 << 28], *T = puffer;
inline ll read() {
    int x(0), f(0);

    while (!isdigit(*S))
        f |= (*S++ == '-');

    while (isdigit(*S))
        x = (x << 1) + (x << 3) + (*S++ ^ 48);

    return f ? -x : x;
}
inline void write(ll x) {
    int num[28], sp = 0;

    if (x < 0)
        *T++ = '-', x = -x;

    if (!x)
        *T++ = 48;

    while (x)
        num[++sp] = x % 10, x /= 10;

    while (sp)
        *T++ = num[sp--] + 48;
}
inline ll power(ll x, ll y) {
    ll res = 1;

    while (y) {
        if (y & 1)
            res = res * x % mod;

        x = x * x % mod;
        y >>= 1;
    }

    return res;
}
inline ll pomod(ll x) {
    return power(x, mod - 2);
}
int main() {
    fread(buffer, 1, 1 << 28, stdin);
    t = read();

    while (t--) {
        a = read(), b = read(), h = read();
        int k = power(b, h);

        if (a > b) {
            if (b == 1)
                write(((a - b)*h % mod + a * k % mod) % mod);
            else
                write(((a - b) * (k - 1) % mod * pomod(b - 1) % mod + a * k % mod) % mod);
        } else
            write(a * k % mod);

        *T++ = '\n';
    }

    fwrite(puffer, 1, T - puffer, stdout);
    return 0;
}
```
[$blog$](https://www.cnblogs.com/nakiri-ayame-suki/)

---

## 作者：pitiless0514 (赞：1)

我们考虑这个题在让我们干嘛，首先这个题给了一棵满 $a$ 叉树。

初始高度是 $10^{10^{10^{10}}}$ 的，但是这个树需要变成一颗高为 $h$ ，并且为满 $b$ 叉树的形态。

有两种操作，一种是删除一个子树，一种是将一条边以及他的子树全部移到另一个节点下去， 但是这个必须在高度小于等于 $10^{10^{10}}$ 的时候使用。

首先想想我们要把他变成一颗满 $b$ 叉树。

先分类讨论， $a < b$ 和 $a >b $ 和 $a = b$ 。

发现其实 $a >b$ 是挺好做的，我们不用考虑接木操作! 我们只用考虑移花操作。

那么对于每一层，我们都要去进行移花操作，考虑保留 $h$ 层。

肯定是从低层往下移，那么对于一层，他的上一层已经满足了 $b$ 叉的要求。

假设当前为第 $k$ 层，那么当前是 $ b^{k-1}$ 个，我们的儿子还有 $ b^{k-1} * a $ 个，我们要保留 $b^{k-1} * b$ 个，那么就是要移去 $b^{k-1} * (a - b)$ 个，也就是这一层的操作次数。

最后到了 $h$ 层，我们将下面 $h + 1$ 层的所有节点也移去，于是答案就是：
$$
ans = \sum_{k=1}^{h}b^{k-1}\times(a-b) + b^{h} \times a
$$

$$
ans = \sum_{k=0}^{h-1}b^{k}\times (a-b) + b^{h} \times a
$$

$$
ans = (a-b) \times \sum_{k=0}^{h-1}b^{k} + b^{h} \times a
$$

$$
ans = (a-b) \times \sum_{k=0}^{h-1}b^{k} + b^{h} \times a
$$

求和的部分是一个等比数列，可以使用等比数列公式。
$$
ans=(a-b)\times \dfrac{b^h-1}{b-1} + b^h \times a
$$
接着我们考虑 $a = b$ 这个把多的那些儿子删去就是了。
$$
ans = a^h \times a
$$
然后考虑难一点的 $a < b$ 怎么做。

这里我们不得不考虑的是除了移花还有接木的操作。

用脑子想，我们肯定是先进行接木后移花，不然我们可能无法达成满 $b$ 叉树的要求，然后为了操作次数最少，我们可以拖走那些本来就要被删除的子树。

总共有 $b^h \times a$ 个节点，然后对于每一层 $k$ 我们会移去 $b^{k-1} \times(b-a)$ 个。

也就是 $s = \sum_{k = 0}^{h-1} b^k \times(b-a)$ 。

对 $s$ 进行化简，得到 $(b-a)\times \dfrac{b^h-1}{b-1}$  ，这个显然是小于 $b^h \times a$ 的。

然后我们还剩下 $b^h \times a-s $ 个节点需要进行删除，于是总的答案就是 $b^h \times a$ 。

我写了，只有 $30$ 分，原因是需要特判 $b=1$ 的情况，答案显然为 $(a-1) \times h + a$ ，然后就过了。

```cpp
const int mod = 1e9 + 7;
int T, a, b, h, ans;
int power(int a,int b) {
  int ans = 1;
  while(b) {
    if(b & 1) ans = ans * a % mod;
    b >>= 1;
    a = a * a % mod;
  }
  return ans;
}
signed main () {
  T = read();
  while(T--) {
    a = read(), b = read(), h = read();
    if(b == 1) write( ( (a - 1) * h % mod + a ) % mod ), putc('\n');
    else if(a == b) {
      ans = power(a, h) * a % mod;
      write(ans), putc('\n');
    }  
    else if(a < b) {
      ans = power(b, h) * a % mod;
      write(ans), putc('\n');
    }
    else if(a > b) {
      int inv = power(b - 1, mod - 2) * (power(b, h) - 1 + mod) % mod * (a - b) % mod;
      ans = inv + power(b, h) * a % mod;
      ans %= mod;
      write(ans), putc('\n');
    }
  }
  flush();
  return 0;
}
```





---

## 作者：VinstaG173 (赞：1)

一个奇怪的题目。

首先我们考虑最简单的即 $a=b$ 的情况。此时只需要把叶子移花掉就行了，算叶子个数快速幂即可。

然后考虑 $a>b$ 的情况。此时显然把多余的子树移花掉，发现多余的子树就是最后的树里每个非叶子节点对应 $a-b$ 个，直接套个等比数列求和公式然后用快速幂，但是 $b=1$ 时公式会有问题，会变成 $\frac{0}{0}$，特判一下就行了。

最后考虑 $a<b$ 的情况。此时显然要把下面的子树接木到上面，但是因为显然 $(b-a) \times \sum\limits_{i=0}^{h-1}a^i \le b^h$，所以把叶子移掉的次数会不少于接木的次数，总操作次数相当于直接移花，直接快速幂就可以了。其实和 $a=b$ 是一样的式子。

Code:
```cpp
#include<cstdio>
#define ll long long
const int ntf=1e9+7;
int t,a,b,h;
inline char rc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
inline ll qpw(ll x,int v)
{
	ll r=1;
	while(v)
	{
		(v&1)&&(r=r*x%ntf);
		x=x*x%ntf,v>>=1;
	}
	return r;
}
void print(ll x)
{
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
int main()
{
	t=read();
	while(t--)
	{
		a=read(),b=read(),h=read();
		if(b==1)
		{
			print(((ll)h*(a-b)+a)%ntf),putchar('\n');
		}
		else if(a>b)
		{
			ll v=qpw(b,h);
			print(((v-1)*qpw(b-1,ntf-2)%ntf*(a-b)+a*v)%ntf),putchar('\n');
		}
		else print(a*qpw(b,h)%ntf),putchar('\n');//由于两个式子一样就不分类了，这里有 a==b 和 a<b 两种情况
	}
	return 0;
}
```

---

## 作者：Create_Random (赞：1)

### update on 2020.12.3 修改了一处错误
------------
[题目传送门](https://www.luogu.com.cn/problem/P7108)

题目要求将一棵高度为 $\infty$ 的 $a$ 叉树转化为高度为 $h$ 的 $b$ 叉树，

那么可以对 $a$ 与 $b$ 的关系进行分类讨论。

------------
$a=b$ 时：

相当于将第 $h$ 层的所有节点所连向子节点的边删去，

因为对于第 $h$ 层的 $a$ 叉树有 $a^h$ 个叶节点，

而且每个叶节点有 $a$ 个子节点，

所以这些叶节点连向子节点的边数即为 $a^h \times a$ 条，

直接用快速幂输出 $a^{h+1}$ 即可。

------------
$a<b$ 时：

这里拿二叉树转化为三叉树举个例子：

![](http://wfyzoj-files.oss-cn-beijing.aliyuncs.com/image/user/201142ce64ca003c1267a9262c4dfd3a.png)

用蓝色数字标记的边均为进行“接木”操作的子树

这一步完成后转化为的 $b$ 叉树的第 $h$ 层共有 $b^h$ 个叶节点，

而且每一个叶节点有 $a$ 个子结点

所以这些叶节点连向子节点的边数即为 $b^h \times a$ 条。

然后我们可以观察到一个性质：

最后进行“接木”操作的边数等于叶节点连向子节点的边中不需要进行“移花”操作的边数，

那么 $a<b$ 时操作总数量即为 $b^h \times a$ 次。

------------
$a>b$ 时：

这里拿三叉树转化为二叉树举个例子：

![](http://wfyzoj-files.oss-cn-beijing.aliyuncs.com/image/user/f48233e33f1b3e99eed2030b5b023cb8.png)

因为是将子树数量减小，

那么显然只需要进行“移花”操作，

然后我们可以发现对于每一个非叶节点，

都需要移除 $a-b$ 棵子树，

又因为最后要求的树为 $b$ 叉树，

那么对于第 $i$ 层的节点就需要删去 $b^h$ 次 $a-b$ 棵子树。

（请仔细理解推敲这句话）

同时还需要删去叶节点的 $b^h \times a$ 条边，

所以最后删去的总边数为 $b^h\times a+ \sum \limits_{i=0}^{h-1}(a-b)\times b^i$.

原式就等于 $b^h\times a+(a-b)\times \sum \limits_{i=0}^{h-1} b^i$ .

现在我们需要对 $\sum \limits_{i=0}^{h-1} b^i$ 这个式子进行优化：

设 $y=\sum \limits_{i=0}^{h-1} b^i$ ,

则 $by=\sum \limits_{i=1}^h b^i$ ,

$by-y=\sum \limits_{i=1}^h b^i-\sum \limits_{i=0}^{h-1} b^i=b^h-1$.

所以结果为 $\frac{b^h-1}{b-1}$.

所以 $a>b$ 时操作总数量为 $b^h\times a+(a-b)\times \frac{b^h-1}{b-1}$.

再加个逆元就行了。

### **注意**

此时 $b=1$ 时分母为 $0$ ,

所以需要特判，

因为对于除第 $h$ 层每一层都需要删去 $a-1$ 条边，

且第 $h$ 层需要删去全部的 $a$ 条边，

所以 $b=1$ 时操作总数量为 $h\times (a-1) +a$.

------------
分类讨论结束，

所有操作均 $O(log h)$ 可过。

$Code$:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,a,b,h;
const int mod=1e9+7;
int ans;
int ksm(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1)
		{
			ans=ans*a%mod;
		}
		a=a*a%mod;
		b>>=1;
	}
	return ans%mod;
}
int ny(int x)
{
	return ksm(x,mod-2)%mod;
}
signed main()
{
	scanf("%lld",&t);
	while(t--)
	{
		ans=0;
		scanf("%lld%lld%lld",&a,&b,&h);
		if(h==0)
		{
			printf("%lld\n",a);
			continue;
		}
		if(a==b)
		{
			printf("%lld\n",ksm(a,h+1));
			continue;
		}
		if(a==1)
		{
			printf("%lld\n",ksm(b,h));
			continue;
		}
		if(b==1)
		{
			ans+=h*(a-1)+a;
			ans%=mod;
			printf("%lld\n",ans);
			continue;
		}
		if(a>b)
		{
			ans%=mod;
			ans+=(ksm(b,h)%mod*a%mod)%mod;
			ans%=mod;
			ans+=((((ksm(b,h)%mod)-1)%mod+mod%mod)%mod)*(ny(b-1)%mod)%mod*(a-b)%mod;
			ans%=mod;
			printf("%lld\n",ans);
		}
		else
		{
			ans+=(ksm(b,h)%mod*a%mod)%mod;
			ans%=mod;
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```


---

## 作者：gzlmr (赞：1)

## 23pts解法
对于前四档分数：
- Subtask #1 (3 points)：$h=0$。
- Subtask #2 (4 points)：$a=b$。
- Subtask #3 (8 points)：$a=1$。
- Subtask #4 (8 points)：$b=1$。

我们可以直接推出结论：

设灵树最初的形态为 $A$，转换后的形态为 $B$。

### Subtask #1:
当 $h=0$ 时，我们只需要将根节点所有的叶子都删除（移花）就可以了，答案即为 $a$。

### Subtask #2:
当 $a=b$ 时，我们只需要将叶子节点的儿子全部删除（移花）就可以了，答案即为叶子结点的个数 $a^h$ 再乘上其儿子个数 $a$，答案即为 $a^{h+1}$

### Subtask #3:
当 $a=1$ 时，我们对于 $B$ 的每个叶子节点，只需要一次接木操作即可通过移动加入该叶子节点到其某个祖先的边，因为需要加入 $b^h-1$ 个点，因此需要进行 $b^h-1$ 次移动（接木）操作，又因为最后还要删除多出的一个叶子节点，所以最终答案为 $b^h$
![](https://img2020.cnblogs.com/blog/1923835/202011/1923835-20201129000818994-458989479.png)

### Subtask #4:
当 $b=1$ 时，我们对于 $A$ 中多余的节点需要全部删除，因此，在每一层中，我们都要删除 $a-1$ 个节点，使得该层最后只有一个节点，因为有 $h$ 层，所以要删除 $(a-1) \times h$ 个点，又因为叶子节点需要删除 $a$ 个儿子节点，因此答案为 $(a-1) \times h+1$

## 100pts解法：

分类讨论

### 当 $a \ge b$ 时
对于第 $i$ 层，因为上一层删除完后只剩下 $b^{i-2}$ 个节点，所以需要删除 $b^{i-2} \times b=b^{i-1}$ 个节点的多余儿子，而一个节点的多余的儿子有 $a-b$ 个，因此一共要删除 $(a-b) \times (b^0+b^1+\dots+b^{h-1})$，化简后即为 $(a-b) \times \frac{b^h-1}{b-1}$，可以使用快速幂在 $O(logn)$ 求解，又因为对于 $b^h$ 个子节点每个都要删除 $a$ 个儿子，因此一共要删除 $(a-b) \times \frac{b^h-1}{b-1}+b^h \times a$ 个节点

**tips：当 $b-1=0$ 即 $b=1$ 时 $\frac{b^h-1}{b-1}$ 无法通过逆元求解，因此可以直接推导出 $b^0+b^1+\dots+b^{h-1}=1^0+1^1+\dots+1^{h-1}=h$，也可以使用Subtask #4求解**

### 当 $a<b$ 时
对于第 $i$ 层，因为上一层移动完后有 $b$ 个节点，所以需要再移动 $b^{i-1} \times (b-a)$ 个节点的作为上一层的儿子，因此一共要移动 $(b-a) \times \frac{b^h-1}{b-1}$ 个节点，与上一种情况基本相同，又因为对于 $b^h$ 个子节点每个都要删除 $a$ 个儿子，因此还要删除 $b^h \times a$ 个节点，但又因为我们再刚才移动节点时可以移动要删除的节点减少移动次数，因此删除的节点个数还要减去移动的节点次数，因此设移动的节点次数 $k=(b-a) \times \frac{b^h-1}{b-1}$，答案即为 $k+(b^h \times a-k)$

## 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int mod=1000000007;
long long pow(long long x,int y){//快速幂
	long long res=1;
	while(y){
		if(y&1){
			res=(res*x)%mod; 
		}
		x=(x*x)%mod;
		y=(y>>1);
	}
	return res;
}
int main() {
	int t;
	scanf("%d",&t);
	while(t--){
		int h;
		long long a,b;
		scanf("%lld%lld%d",&a,&b,&h);
		long long k=(pow(b,h)-1+mod)*pow(b-1,mod-2)%mod;
                                             //通过费马小定理求解逆元
		if(a>=b){
			if(b==1)printf("%lld\n",((a-1)*h+a)%mod);
			printf("%lld\n",(k*(a-b)%mod+pow(b,h)*a)%mod);
		}else if(a<b){
			printf("%lld\n",(k*(b-a)%mod+(pow(b,h)*a%mod-k*(b-a)%mod+mod))%mod);
		}
	}
	return 0;
}
```

---


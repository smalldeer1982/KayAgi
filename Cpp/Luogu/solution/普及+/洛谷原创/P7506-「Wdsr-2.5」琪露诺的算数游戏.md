# 「Wdsr-2.5」琪露诺的算数游戏

## 题目描述

#### 游戏概况

《琪露诺的算数游戏》（诨名“⑨牌”），是一款轻松快乐的多玩家卡牌回合制游戏。

**注意：这里的规则与市面上的⑨牌规则不尽相同**。由于⑨牌种类太多不大容易处理，所以这里的规则更类似于 $\text{NEU}$ 游戏。

游戏中有 $n$ 名玩家，围成一圈。一共会进行 $m$ 轮。每个玩家初始时有 $3$ 张手牌。游戏有一个 $k$ 张牌的牌堆。在本题中，你可以认为**不会出现牌堆抽完的情况**（真的）。此外，根据该题给出的规则，你不需要考虑选手手牌的顺序。

为了简述游戏规则，你可以认为每一轮游戏中有一个整型变量（类似于 $\text{int}$ 类型寄存器） $p$ 。玩家打出的牌本质上是对 $p$ 进行操作。

**注**：请注意下文中“局”、“轮”、“回合”的关系。本题你只会进行一局游戏，每局有 $m$ 轮，每一轮会有若干回合，每一回合会有一名玩家出牌。

每一轮开始时，$p$ 会被初始化为 $0$ ，然后从初始玩家开始，按照**顺时针顺序**（$1,2,3,\cdots n-1,n,1,2,\cdots$ ，逆时针同理），依次出牌。如果这是第一轮，那么初始玩家就是 $1$ 号玩家。当某个玩家出完某张牌后，如果此时 $p> 99$ ，视作该玩家成为该局的**失败者**；否则她就会**立刻从牌堆顶部取出一张牌**并进入到下一回合。失败者会丢失手上其余的两张牌，并从牌堆顶部依次摸三张牌放入自己的手牌中。同时，失败者会成为**下一轮初始玩家**。在一局游戏当中，牌堆里的牌只减不增。被使用的牌不会回到牌堆当中。

下面介绍该魔改版游戏的牌型。

#### 基本牌

基本牌可以分为五类：加法牌、减法牌、乘法牌、除法牌、固定牌。

- 加法牌，一共有 $7$ 种： $A_{1},A_{2},A_{5},A_{9},A_{19},A_{49},A_{99}$ 。其中， $A_x$ 的作用效果是，使 $p$ 加上牌面上的数字。即 $p\gets p+x$ 。  
- 减法牌，一共有 $3$ 种： $B_{1},B_{9},B_{19}$ 。作用效果与加法牌类似，只不过会使 $p$ 减去牌面上的数字。  
- 乘法牌，一共只有 $1$ 种： $C_2$ 。它的作用效果是令 $p$ 乘上对应的数字，即 $p\gets p\times x$ 。  
- 除法牌，同样只有 $1$ 种： $D_2$ 。会令 $p$ 除以对应的数字，**向下取整**。即 $p\gets \lfloor p\div x\rfloor$ 。  
- 固定牌，一共有 $3$ 种： $E_{0},E_{49},E_{99}$ ，会将 $p$ 直接设置为牌面上的数字。

#### 解牌

解牌是可以使一名玩家跳过该回合，并附加一些特殊效果的一类牌。

- $\tt{PASS}$ ，跳过你，转到下一个玩家。
- $\tt{TURN}$ ，跳过你，出牌顺序反转（顺时针变为逆时针，逆时针变为顺时针。在下一轮游戏开始时会重置为顺时针）。
- $\tt{DOUBLE}$ ，跳过你，然后给下一名玩家施加 $\verb!"DOUBLE"!$ 效果，也即要出两张牌（先打一摸一，再打一摸一，需要保持全程总数不超过 $99$ 才能保证不失败）。

$\tt{DOUBLE}$ 效果的一些说明：如果你被施加了 $\tt{DOUBLE}$ 的效果，但是你第一张出了解牌（三种解牌都可以），那么你就会立即解除 $\tt{DOUBLE}$ 效果，跳过这一回合，**并且将效果转移到下一名玩家**。 $\tt{DOUBLE}$ 效果不能叠加。

--- 

在输入文件中，卡牌名会形如 $\colorbox{#f0f0f0}\verb!A1 A99 D2 PASS DOUBLE!$ 等等。

#### 策略

这一部分将会讲述本题中所有玩家的运行逻辑。

如果无论怎么出都会失败，那么玩家就会随便打出一张牌并成为失败者（显然，打出哪张牌不会对游戏结局产生实质上的影响）。否则会有两种情形：

1. 如果此时没有被施加 $\tt{DOUBLE}$ 效果：
   - 每名玩家会优先考虑普通牌，并且选择在不成为失败者的前提下使 $p$ 变得**尽可能大**的那种方案（如果有多种方案可以使得 $p$ 最大，那就会按照**乘法牌、加法牌、减法牌、除法牌、固定牌**的顺序优先选择。显然，同一类普通牌中的不同种类的牌不会使 $p$ 产生相同的值）。
   - 如果没有普通牌，或者出牌后会成为失败者，那么就考虑使用解牌。玩家会依次考虑手头是否有 $\tt{PASS,TURN,DOUBLE}$ 牌。如果有，就打出这张牌。
2. 如果被施加了 $\tt{DOUBLE}$ 效果：
   - 优先考虑使用解牌。依次考虑$\tt{PASS,TURN,DOUBLE}$ 。如果有，就打出这张牌。
   - 否则，选择在不成为失败者的前提下使 $p$ 变得**尽可能小**的那种方案（如果有多种方案可以使得 $p$ 最小，那就会按照**除法牌、减法牌、加法牌、乘法牌、固定牌**的顺序优先选择）。此时玩家会被解除 $\tt{DOUBLE}$ 状态，于是她会按照情形 $1$ 来决策。

## 说明/提示

#### 样例 1 说明

牌的使用情况都在输出样例中。这里仅说明每出一张牌后每名玩家当前手牌的情况。具体为什么要使用某张牌，可以参考题目描述。

$$
\def{\c}#1{\texttt{#1}}
\def\arraystretch{1.5}
\begin{matrix}
\begin{gathered}
\textbf{\textsf{初始}}\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{A99} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{D2} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第一回合}}\quad (p: 0\to 99)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{E49} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{D2} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第二回合}}\quad (p:99\to 49)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{E49} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第三回合}}\quad (p:49\to 49)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{C2} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\end{gathered}
&
\begin{gathered}
\textbf{\textsf{第四回合}}\quad (p:49\to 98)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{B9} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第五回合}}\quad (p:98\to 89)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{A49} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{DOUBLE} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第六回合}}\quad (p:89\to 89)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{A49} & \c{PASS} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{A99} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\textbf{\textsf{第七回合}}\quad (p:89\to 89)\cr
\begin{array}{|c|c|c|c|} \hline
\textbf{玩家名} & \textbf{手牌 1} & \textbf{手牌 2}  & \textbf{手牌 3} \cr\hline
\text{JoesSR} & \c{A49} & \c{A99} & \c{PASS} \cr\hline
\text{Cirno} & \c{A19} & \c{A99} & \c{A49} \cr\hline
\end{array}\cr[10pt]
\end{gathered}
\end{matrix}
$$

**注**：初始回合以及第 $2,4,6$ 回合都是 $\text{JoesSR}$ 出牌；第 $1,3,5,7$ 回合都是琪露诺出牌。值得注意的是，尽管第 $5$ 回合琪露诺使用了 $\tt{DOUBLE}$ ，但因为下一回合被 $\tt{PASS}$ 了，所以第 $7$ 回合仍然是琪露诺出牌。

此时琪露诺无论如何都会失败，于是琪露诺成为了失败者。

#### 样例 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，仅包含普通牌，并且 $n\le 3$ 。
- 对于另外 $15\%$ 的数据，不包含 $\tt{TURN}$ 牌和 $\tt{PASS}$ 牌。
- 对于另外 $15\%$ 的数据，不包含 $\tt{DOUBLE}$ 牌。
- 对于 $100\%$ 的数据， 满足 $1\le n\le 30;1\le m\le 100;1\le k\le 3\times 10^5$ 。保证任何时候 $|p|<10^4$ 。

#### 参考资料

[【东方桌游考古】NEU，“⑨牌”，与十年前的同人](https://www.bilibili.com/read/cv9951620)

## 样例 #1

### 输入

```
2 1 10
JoesSR B9 A99 PASS
Cirno C2 D2 A49
E49 DOUBLE PASS A19 A49 A99 A99 A99 A99 A99  ```

### 输出

```
Round 1:
JoesSR used A99,now p=99.
Cirno used D2,now p=49.
JoesSR used E49,now p=49.
Cirno used C2,now p=98.
JoesSR used B9,now p=89.
Cirno used DOUBLE,now p=89.
JoesSR used PASS,now p=89.
Cirno lost the game.```

## 样例 #2

### 输入

```
3 2 25
Cirno A9 A19 B1
Reimu TURN A9 C2
Marisa DOUBLE D2 D2
A9 B9 C2 PASS PASS A9 A1 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99 A99
```

### 输出

```
Round 1:
Cirno used A19,now p=19.
Reimu used C2,now p=38.
Marisa used D2,now p=19.
Cirno used A9,now p=28.
Reimu used A9,now p=37.
Marisa used C2,now p=74.
Cirno used A9,now p=83.
Reimu used B9,now p=74.
Marisa used A9,now p=83.
Cirno used A1,now p=84.
Reimu used PASS,now p=84.
Marisa used D2,now p=42.
Cirno used B1,now p=41.
Reimu used TURN,now p=41.
Cirno used PASS,now p=41.
Marisa used DOUBLE,now p=41.
Reimu lost the game.
Round 2:
Reimu used A99,now p=99.
Marisa lost the game.
```

# 题解

## 作者：囧仙 (赞：19)

## 准备工作

这部分主要讲解如何将牌型映射到对 $p$ 的操作上。观察到牌型总共分为两大类，**普通牌**与**解牌**，于是分别考虑。

$1.$ **普通牌**

对于普通牌，我们能够发现每种牌型对 $p$ 的操作都可以用形如 $p\gets \left\lfloor p\cdot a+b\right\rfloor$ 来表示，其中 $a,b$ 是仅与这种牌型有关的常数。经过简单地讨论，我们可以找出所有这样的 $a,b$ ：

$$\def\arraystretch{1.5}\begin{array}{||c|c|c||c|c|c||}\hline
\textbf{牌型} & \boldsymbol{a} & \boldsymbol{b} &\textbf{牌型} & \boldsymbol{a} & \boldsymbol{b} \cr \hline
A_1 & 1 & 1 & B_1 & 1 & -1\cr\hline
A_2 & 1 & 2 & B_9 & 1 & -9\cr\hline
A_5 & 1 & 5 & B_{19} & 1 & -19\cr\hline
A_9 & 1 & 9 & C_2 & 2 & 0 \cr\hline
A_{19} & 1 & 19 & D_2 & 0.5 & 0\cr\hline
A_{49} & 1 & 49 & E_0 & 0 & 0\cr\hline
A_{99} & 1 & 99 & E_{49} & 0 & 49\cr\hline
&& & E_{99} & 0 & 99\cr\hline
\end{array}$$

具体实践的时候，我们可以开一个 $\text{map}$ ，将 $\text{string}$ 映射到对应的二元组 $(a,b)$ 。


$2.$ **解牌**

对于解牌，因为一共才只有 $3$ 种，所以我们实际模拟的时候再进行考虑。使用带符号整型 $d$ 存储 $1$ 或 $-1$ ，用于判断当前顺序是顺时针还是逆时针；使用布尔型 $f$ 存储当前玩家是否处于 $\text{DOUBLE}$ 状态。三种牌型的处理方式如下：

- $\textbf{PASS}$ ：这部分处理起来比较简单，你只要直接跳过当前玩家就行了。

- $\textbf{TURN}$ ：也比较简单，直接令 $d\gets -d$ ，然后跳过该名玩家。

- $\textbf{DOUBLE}$ ：相对复杂的一部分。我们令 $f=\verb!true!$ ，然后跳过该名玩家。对于 $\text{DOUBLE}$ 状态的主要处理方式，将会在下一部分进行讲解。

---

对于玩家手牌的存储，只要对每名玩家开一个 $\text{map}$ （标记为 $H_{1},H_{2}\cdots$ ），将卡牌名映射到该名玩家持有该卡牌的数量就行了（其实也可以用 $\text{multiset}$ 之类的）。主要好处是，我们可以使用 $\text{STL}$ 自带的 $\text{auto}$ 功能快速遍历每名玩家持有的所有手牌。

## 使用手牌

在下文，我们使用 $o$ 表示当前玩家的序号。

$1.$ **删除手牌**

我们新建函数 $\text{del(c)}$ ，来删除当前玩家手上的牌 $c$ 。这部分非常简单，你只需要 $H_{o,c}\gets H_{o,c}-1$ 就行了。每当删除一张牌，都要从牌堆获取另外一张牌。用 $\text{string}$ 类型的数组 $K$ 存储牌堆中的牌，你只要令 $kk\gets kk+1$ ，然后获取 $K_{kk}$ 即可。删除后，记得输出删除信息。

$2.$ **普通牌**

我们新建函数 $\text{useA(v)}$ ，来处理当前玩家使用**普通牌**的情况，返回一个布尔值表示玩家是否使用成功。特别地，我们传入一个布尔变量 $v$ 用于表示此时需要使 $p$ 最大还是最小。

此时可以用 $\text{auto}$ 枚举该名玩家所有手牌。因为 $\text{useA}$ 函数只考虑普通牌，所以我们直接忽略特殊牌就行了。用 $W_1\sim W_5$ 存储每**类**普通牌产生的最大/最小值，用 $F_1\sim F_5$ 存储对应的牌（$\text{string}$ 类型）。对于手头的普通牌，我们计算出 $p'$ ，表示使用它后 $p$ 会变成的数值。如果它不超过 $99$ ，那就去更新对应的 $W_i$ 和 $F_i$ 就行了。

枚举完之后，按照题目规定的顺序（依次考虑乘法牌、加法牌、减法牌、除法牌、固定牌，或者依次考虑除法牌、减法牌、加法牌、乘法牌、固定牌）从 $W_1\sim W_5$ 中挑选出能使得 $p$ 最大/最小的手牌并使用，接着令 $f\gets \verb!false!$ ，然后返回 $\verb!true!$ 。如果无论如何都会超过 $99$ ，就不决策，并返回 $\verb!false!$ 。

$3.$ **解牌**

我们新建函数 $\text{useB()}$ ，来处理当前玩家使用**解牌**的情况，返回一个布尔值表示玩家是否使用成功。依次判断玩家手头有没有这三张牌，如果有，那就按照“准备工作”章节中的做法处理后删除掉这张牌，并返回 $\verb!true!$ 。否则返回 $\verb!false!$ 。

## 模拟

该部分将讲述如何利用上述函数处理游戏主要过程。

- 初始时，输入所有牌，令 $o\gets 1$ 。这是整局游戏开始时的预处理操作。

- 对于每一轮，依次进行处理。每一轮开始时令 $d\gets 1,p\gets 0$ 。讨论此时 $f$ 的情况，可分为以下 $4$ 个 $\text{Label}$ ，每种 $\text{Label}$ 的对应情况分别是：当前未处于 $\text{DOUBLE}$ 状态；当前处于 $\text{DOUBLE}$ 状态；跳转到下一名玩家；该名玩家成为失败者。初始时根据 $f$ 的值跳转至 $\text{Label 1}$ 或 $2$ 。

  - $\text{Label 1}$ ：当前 $f=\verb!false!$ 。依次考虑 $\text{useA(\verb!true!)}$ 和 $\text{useB()}$ ，如果可行就跳转到 $\text{Label 3}$ ，否则跳转到 $\text{Label 4}$ 。
  
  - $\text{Label 2}$ ：当前 $f=\verb!true!$ 。如果 $\text{useB()}$ 返回 $\verb!true!$ 并跳至 $\text{Label 3}$ ；否则根据 $\text{useA(\verb!false!)}$ 决定跳至 $\text{Label 1}$ 还是 $\text{Label 4}$ 。
  
  - $\text{Label 3}$ ：令 $o\gets p+d$ 。如果 $o=n+1$ ，就令 $o=1$ ；如果 $o=0$ ，就令 $o=n$ ，比较显然。
  
  - $\text{Label 4}$ ：输出该名玩家失败的信息，结束该轮。
  
至此，该题目圆满结束。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;++i)
using namespace std;
const int INF=2e9,NN=30+3,KK=1e6+3;
const string TR="TURN",DB="DOUBLE",PS="PASS";
int n,m,k,o=1,d,p,h=100,kk=0; string N[NN],K[KK],c; bool f;
unordered_map <string,pair<double,double>> M; unordered_map<string,int> H[NN];
enum{ADD=0,MIN,MUL,DIV,SET};
bool del(string c){
	if(!H[o][c]) return 0;
	cout<<N[o]<<" used "<<c<<",now p="<<p<<".\n",--H[o][c],H[o][K[++kk]]++;
	return 1;
}
#define f(x) if(v?W[x]>w:W[x]<w)w=W[x],r=x;
bool useA(bool v){
	int W[5],r,t,y,w=v?-INF:INF; string F[5],s; fill(W,W+5,w); bool e=1;
	for(auto x:H[o]) if((s=x.first)!=TR&&s!=DB&&s!=PS&&x.second){
		t=s[0]-'A',y=floor(M[s].first*p+1e-9+M[s].second);
		if(y<h&&(v?y>W[t]:y<W[t])) W[t]=y,F[t]=s,e=0;
	}
	if(v){
		if(W[MUL]>w) w=W[MUL],r=MUL; if(W[ADD]>w) w=W[ADD],r=ADD;
		if(W[MIN]>w) w=W[MIN],r=MIN; if(W[DIV]>w) w=W[DIV],r=DIV;
		if(W[SET]>w) w=W[SET],r=SET;
	}
	else{
		if(W[DIV]<w) w=W[DIV],r=DIV; if(W[MIN]<w) w=W[MIN],r=MIN;
		if(W[ADD]<w) w=W[ADD],r=ADD; if(W[MUL]<w) w=W[MUL],r=MUL;
		if(W[SET]<w) w=W[SET],r=SET;
	}
	if(e) return 0; p=w,del(F[r]),f=0; return 1;
}
bool useB(){
	if(del(PS)) return 1; if(del(TR)) {d=-d; return 1;} if(del(DB)) {f=1;return 1;}
	return 0;
}
#define g(a,b,c) M[a]=make_pair(b,c)
int main(){ 
	g("A1" ,1, 1);g("A2" , 1, 2);g("A5",1, 5);g("A9" ,1, 9);g("A19",1, 19);
	g("A49",1,49);g("A99", 1,99);g("B1",1,-1);g("B9" ,1,-9);g("B19",1,-19);
	g("C2" ,2, 0);g("D2" ,.5, 0);g("E0",0, 0);g("E49",0,49);g("E99",0, 99);
	cin>>n>>m>>k;
	up(1,n,i){cin>>N[i]; up(1,3,j) cin>>c,++H[i][c]; }
	up(1,k,i) cin>>K[i];
	up(1,m,i){
		cout<<"Round "<<i<<":\n",d=1,p=f=0; while(1){
			if(!f) goto L1;if(useB()) goto L2; if(!useA(0)) break;
			L1: if(!useA(1)&&!useB()) break;
			L2: o+=d; if(o==n+1) o=1; if(!o) o=n;
		}
		cout<<N[o]<<" lost the game.\n";
		H[o].clear(); up(0,2,j) H[o][K[++kk]]++;
	}
	return 0;
}
//好孩子不要抄袭哦
```
  

---

## 作者：2011FYCCCTA (赞：11)

# [原题](https://www.luogu.com.cn/problem/P7506)
一道较难的模拟题，卡了我三天 qwq，细节太多了，感觉难度至少蓝题。

### 分析

- 卡牌

	为了方便进行运算，我定义了一个结构体存储每张卡牌的信息，在输入时定义一个函数处理卡牌：
    1. 卡牌的类型（`A`，`B`，`DOUBLE`……）。
    2. 卡牌上的数值（解牌为 $-1$）。
    3. 卡牌的整体（`A99`，`B1`，`PASS`……），存储整体是为了输出方便。
    
   - 实现效果
   
   	 - 普通牌：不多赘述，直接判断卡牌的类型并执行相应的操作即可。**注意！在 C++ 中，负数除以正数会向上取整，要手动调！否则会[惨遭爆零](https://www.luogu.com.cn/record/109214424)**（爆零原因 1）。
     - 解牌：分别讨论：
     
          1. `PASS`：通俗来讲就是占位的，在程序中可以直接略过。

          2. `TURN`：定义一个 `int` 类型的变量存储方向，$0$ 为顺时针，$1$ 为逆时针，执行此操作时取其反即可。

         3. `DOUBLE`：重点！可定义一个 `int` 类型的变量存储被施加 DOUBLE 的玩家，若此时的玩家不是被施加 DOUBLE 的玩家，则按策略 1 进行操作，否则按策略 2 进行操作。
       
       注意点：
       
       1. 如果你被施加了 DOUBLE 的效果，但是你第一张出了解牌，那么你就会解除 DOUBLE 效果，跳过这一回合，**并且将效果转移到下一名玩家！**（爆零原因 2）。
       2. 将效果转移到下一名玩家时，需要**注意此时的出牌顺序！**（爆零原因 3）。
- 过程
	
    - 找到失败者
    
    	丢弃她的全部手牌并从牌堆顶依次取 $3$ 张，并输出（可以发现牌堆的特性和队列很像）。
        
    - 出牌
    
       根据卡牌种类执行操作，并输出。
       
    - 策略
    
    	 简介概括版：

      1. 如果此时没有被施加 DOUBLE 效果：

          优先考虑使用普通牌，选择在不成为失败者的前提下使 $p$ 变得尽可能**大**的那种方案。
          
          如果没有普通牌，或者出牌后会成为失败者，那么就使用 $1$ 张解牌。

      2. 如果被施加了 DOUBLE 效果：

          优先考虑使用解牌。若有，则使用 $1$ 张。并将 DOUBLE 效果给下一位玩家。
          
          否则，选择在不成为失败者的前提下使 $p$ 变得尽可能**小**的那种方案。之后玩家会按照情形 1 来决策。

蒟蒻的巨长代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int NINF = -1e4 - 5;
//存储优先级
map<string , int> pri1;
map<string , int> pri2;
map<string , int> pri3;

//存储卡牌的结构体
struct Card
{
	string all , type;
	int x;
};
map<int , string> t2;
vector<vector<Card>> pc;
int n , m , k , p , now , d = -1 , dir;
string name , c;
queue<Card> h;//牌堆

//初始化优先级数组
void init()
{
    pri1["C"] = 1; pri1["A"] = 2; pri1["B"] = 3; pri1["D"] = 4; pri1["E"] = 5;
	pri3["C"] = 4; pri3["A"] = 3; pri3["B"] = 2; pri3["D"] = 1; pri3["E"] = 5;
	pri2["PASS"] = 1; pri2["TURN"] = 2; pri2["DOUBLE"] = 3;
	return;
}

//处理卡牌
pair<string , int> processCard(string c)
{
	pair<string , int> pc;
	if (c[c.length() - 1] >= '0' && c[c.length() - 1] <= '9')
	{
		int num = 0;
		for (int k = 1 ; k < c.length() ; k++) num = num * 10 + (c[k] - '0');
		pc = make_pair(c.substr(0 , 1) , num); 
	}
	else pc = make_pair(c , -1);
	return pc;
}

//得到使用1张普通牌后p的值
int getChange(Card c)
{
	int np = p;
	if (c.type == "A") np += c.x;
	else if (c.type == "B") np -= c.x;
	else if (c.type == "C") np *= c.x;
	else if (c.type == "D")
    {
        if (np % 2 == 0) np /= c.x;
        else
        {
            if (np >= 0) np /= c.x;
            else np = np / c.x - 1;
        }
    }
    else np = c.x;
	return np;
}

//处理失败者
void loser(int pn)
{
	pc[pn].clear();
	for (int i = 1 ; i <= 3 ; i++)
	{
		pc[pn].push_back(h.front());
		h.pop();
	}
	cout << t2[pn] << " lost the game.\n";
	return;
}

//出牌
void outCard(int pn , int cn)
{
	if (pc[pn][cn].x > -1)
		p = getChange(pc[pn][cn]);
	else
	{
		if (pc[now][cn].type == "PASS");
		else if (pc[now][cn].type == "TURN") dir = !dir;
		else
        {
            if (!dir) d = (now + 1) % n;
            else d = (now - 1 + n) % n;
        }
	}
	cout << t2[pn] << " used " << pc[pn][cn].all << ",now p=" << p << '.' << endl;
	pc[pn][cn] = h.front();
	h.pop();
	return;
}

int main()
{
	cin >> n >> m >> k;
	for (int i = 0 ; i < n ; i++)
	{
		cin >> name;
		t2[i] = name;
		vector<Card> t;
		for (int j = 0 ; j < 3 ; j++)
		{
			cin >> c;
			t.push_back((Card){c , processCard(c).first , processCard(c).second});
		}
		pc.push_back(t);
	}
	while (k--)
	{
		cin >> c;
		h.push((Card){c , processCard(c).first , processCard(c).second});
	}
	
	init();
	for (int i = 1 ; i <= m ; i++)
	{
		printf("Round %d:\n" , i);
		p = 0; d = -1; dir = 0;
		while (true)
		{
        //没有被施加DOUBLE
			if (d != now)
			{
				int maxp = NINF , cu = -1;
				bool hu = false;
				for (int j = 0 ; j < pc[now].size() ; j++)
					if (pc[now][j].x > -1)
					{
						hu = true;
						if (getChange(pc[now][j]) <= 99)
						{
							if (getChange(pc[now][j]) > maxp) {maxp = getChange(pc[now][j]); cu = j;}
							else if (getChange(pc[now][j]) == maxp) 
								if (pri1[pc[now][j].type] < pri1[pc[now][cu].type]) cu = j;
						}
					}
				
				if (cu != -1) outCard(now , cu);
				else
				{
					int maxpri = 4 , cun = -1;
					bool hun = false;
					for (int j = 0 ; j < pc[now].size() ; j++)
						if (pc[now][j].x == -1)
						{
							hun = true;
							if (pri2[pc[now][j].type] < maxpri) {maxpri = pri2[pc[now][j].type]; cun = j;}
						}
					if (hu && !hun) {loser(now); break;}
					outCard(now , cun);
				}
			}
        //被施加DOUBLE
			else
			{
           //出解牌
				d = -1;
				int maxpri = 4 , cun = -1;
				bool hun = false;
				for (int j = 0 ; j < pc[now].size() ; j++)
					if (pc[now][j].x == -1)
					{
						hun = true;
						if (pri2[pc[now][j].type] < maxpri) {maxpri = pri2[pc[now][j].type]; cun = j;}
					}

				if (hun)
                {
                    outCard(now , cun);
                    if (!dir) d = (now + 1) % n;
                    else d = (now - 1 + n) % n;
                }
           //没有就出2张普通牌
				else
				{
             	//第1张
					int maxp = -NINF , cu = -1;
					for (int j = 0 ; j < pc[now].size() ; j++)
						if (pc[now][j].x > -1)
							if (getChange(pc[now][j]) <= 99)
							{
								if (getChange(pc[now][j]) < maxp) {maxp = getChange(pc[now][j]); cu = j;}
								else if (getChange(pc[now][j]) == maxp) 
									if (pri3[pc[now][j].type] < pri3[pc[now][cu].type]) cu = j;
							}
					if (cu != -1) outCard(now , cu);
					else {loser(now); break;}
					//将策略一的代码再写一遍
					maxp = NINF , cu = -1;
    				bool hu = false;
    				for (int j = 0 ; j < pc[now].size() ; j++)
    					if (pc[now][j].x > -1)
    					{
    						hu = true;
    						if (getChange(pc[now][j]) <= 99)
    						{
    							if (getChange(pc[now][j]) > maxp) {maxp = getChange(pc[now][j]); cu = j;}
    							else if (getChange(pc[now][j]) == maxp) 
    								if (pri1[pc[now][j].type] < pri1[pc[now][cu].type]) cu = j;
    						}
    					}
    				if (cu != -1) outCard(now , cu);
    				else
    				{
    					int maxpri = 4 , cun = -1;
    					bool hun = false;
    					for (int j = 0 ; j < pc[now].size() ; j++)
    						if (pc[now][j].x == -1)
    						{
    							hun = true;
    							if (pri2[pc[now][j].type] < maxpri) {maxpri = pri2[pc[now][j].type]; cun = j;}
    						}
    					if (hu && !hun) {loser(now); break;}
    					outCard(now , cun);
    				}
				}
			}
			if (!dir) {now = (now + 1) % n;}
			else now = (now - 1 + n) % n;
		}
	}
	return 0;
}
```
[悲惨的寄录](https://www.luogu.com.cn/record/list?pid=P7506&user=923403&page=1)


---

## 作者：0tAp (赞：4)

题目链接：[P7506 「Wdsr-2.5」琪露诺的算数游戏](https://www.luogu.com.cn/problem/P7506)

------------

这是一道模拟题，我们不难从题目所给的信息中明确我们要模拟什么，但这题的重点不只是模拟（~~不然也不能评绿~~）而是考察我们的代码实现能力和细节处理能力。

那么我们重点放在细节处理这一块，首先 $p$ 的值会出现负数的情况，那么对于 $D_2$ 操作我们得稍微处理一下，避免在负数的情况下，无法取到正确的数，其次就是 $\tt{TURN}$ 操作，当我们顺时针进行操作时，第 $n$ 位玩家的下一位是第 $1$ 位玩家，逆时针进行操作时，第 $1$ 位玩家的下一位是第 $n$ 位玩家，还有几个小细节就是 $p$ 会在每一轮开始时初始化为 $0$,并且 $\tt{DOUBLE}$ 产生的影响仅当当前玩家进行完解除或一轮结束时解除，否则会传递给下一个玩家。那么当我们能正确处理以上细节时，这题也就迎刃而解了（前提是你码力得过关哦）

顺带提一句 map 用于处理这种题简直不要太好用，接下来我就放出了我 $200$ 多行的代码（~~屎~~）供大家参考参考（~~我知道别人50多行就打出来了~~ :  (   ）


------------
代码如下（~~切勿直接粘贴复制提交哦！！！~~）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define INF 0x3f3f3f3f
const int N=40;

int n,m,k;
map<int,vector<string>>player;
map<int,string>card;
map<string,int>the_val;
int now[6];
int start,the_way;
bool flg=0;

int get_idx1(int id,map<int,int> f){
    int f2=0,f3=0;
    rep(i,1,3){
        if(player[id][i][0]=='C'&&f[the_val[player[id][i]]])f2=i,f3=5;
        else if(player[id][i][0]=='A'&&f[the_val[player[id][i]]]&&f3<=4)f2=i,f3=4;
        else if(player[id][i][0]=='B'&&f[the_val[player[id][i]]]&&f3<=3)f2=i,f3=3;
        else if(player[id][i][0]=='D'&&f[the_val[player[id][i]]]&&f3<=2)f2=i,f3=2;
        else if(player[id][i][0]=='E'&&f[the_val[player[id][i]]]&&f3<=1)f2=i,f3=1;
    }
    return f2;
}
int get_idx2(int id,map<int,int>f){
    int f2=0,f3=0;
    rep(i,1,3){
        if(player[id][i][0]=='D'&&f[the_val[player[id][i]]])f2=i,f3=5;
        else if(player[id][i][0]=='B'&&f[the_val[player[id][i]]]&&f3<=4)f2=i,f3=4;
        else if(player[id][i][0]=='A'&&f[the_val[player[id][i]]]&&f3<=3)f2=i,f3=3;
        else if(player[id][i][0]=='C'&&f[the_val[player[id][i]]]&&f3<=2)f2=i,f3=2;
        else if(player[id][i][0]=='E'&&f[the_val[player[id][i]]]&&f3<=1)f2=i,f3=1;
    }
    return f2;
}
bool game_start(int id,int &p)
{
	map<int,int>f;
	memset(now,INF,sizeof now);
    flag:
    if(flg==0)//判断是否被施加DOUBLE效果
    {
		
        int a=the_val[player[id][1]],
		    b=the_val[player[id][2]],
			c=the_val[player[id][3]];
		now[1]=(a==21?p*2:(a==991)?99:(a==491)?49:(a==22)?((p<0&&p%2?-1:0)+p/2):(a==0)?0:p+a);
		now[2]=(b==21?p*2:(b==991)?99:(b==491)?49:(b==22)?((p<0&&p%2?-1:0)+p/2):(b==0)?0:p+b);
		now[3]=(c==21?p*2:(c==991)?99:(c==491)?49:(c==22)?((p<0&&p%2?-1:0)+p/2):(c==0)?0:p+c);
        
		int max_now=-INF;
        int which_card=0;
        
        
        rep(i,1,3)if(now[i]>=max_now&&now[i]<=99)max_now=now[i];
        rep(i,1,3)if(now[i]>=max_now&&now[i]<=99){
        	if(i==1&&a!=INF)f[a]=1;
        	else if(i==2&&b!=INF)f[b]=1;
        	else if(c!=INF)f[c]=1;
		}
        which_card=get_idx1(id,f);
        if(max_now==-INF){//打不出基本牌，只能看有无解牌
            int f1=0,f2=0,f3=0;
            rep(i,1,3)
            {
                if(player[id][i]=="PASS")f1=i;
                if(player[id][i]=="TURN")f2=i;
                if(player[id][i]=="DOUBLE")f3=i;
            }
            if(f1)which_card=f1;
            else if(f2)which_card=f2;
            else which_card=f3;
            if(which_card!=0)//有解牌可以用
            {
                cout<<player[id][0]
                <<" used "
                <<player[id][which_card]
                <<",now p="<<p<<"."<<endl;
                if(which_card==f2)the_way=!the_way;
                if(which_card==f3)flg=1;
                player[id][which_card]=card[k--];
                return false;
            }
            else{//无解牌，成为输家
                rep(i,1,3){
                    player[id][i]=card[k--];
                }
                start=id;
                cout<<player[id][0]<<" lost "<<"the game."<<endl;
                return true;
            }
        }
        else {//可以打出一张基本牌    
            p=max_now;
            cout<<player[id][0]
            <<" used "
            <<player[id][which_card]
            <<",now p="<<p<<"."<<endl; 
            player[id][which_card]=card[k--];
            return false;
        }
    }
    else{
        int f1=0,f2=0,f3=0;
        int which_card=0;
        rep(i,1,3)
        {
            if(player[id][i]=="PASS")f1=i;
            if(player[id][i]=="TURN")f2=i;
            if(player[id][i]=="DOUBLE")f3=i;
        }
        if(f1||f2||f3){//如果可以打出解牌
            if(f1)which_card=f1;
            else if(f2)which_card=f2;
            else which_card=f3;
            if(which_card==f2)the_way=!the_way;
            cout<<player[id][0]
            <<" used "
            <<player[id][which_card]
            <<",now p="<<p<<"."<<endl;
            player[id][which_card]=card[k--];
            return false;
        }
        else {
            int which_card=0;
            
            int a=the_val[player[id][1]],
		    b=the_val[player[id][2]],
			c=the_val[player[id][3]];
			now[1]=(a==21?p*2:(a==991)?99:(a==491)?49:(a==22)?((p<0&&p%2?-1:0)+p/2):(a==0)?0:p+a);
			now[2]=(b==21?p*2:(b==991)?99:(b==491)?49:(b==22)?((p<0&&p%2?-1:0)+p/2):(b==0)?0:p+b);
			now[3]=(c==21?p*2:(c==991)?99:(c==491)?49:(c==22)?((p<0&&p%2?-1:0)+p/2):(c==0)?0:p+c);
            
            int min_now=INF-1;
            rep(i,1,3)
            {
                if(now[i]<=min_now&&now[i]<=99){
                    min_now=now[i];
                }
            }
            rep(i,1,3)if(now[i]<=min_now&&min_now!=INF-1){
        		if(i==1&&a!=INF)f[a]=1;
        		else if(i==2&&b!=INF)f[b]=1;
        		else if(c!=INF)f[c]=1;
			}
            which_card=get_idx2(id,f);
            if(min_now==INF-1){
                rep(i,1,3){
                    player[id][i]=card[k--];
                }
                start=id;
                cout<<player[id][0]<<" lost "<<"the game."<<endl;
                return true;
            }
            else{
                p=min_now;
                cout<<player[id][0]
                    <<" used "
                    <<player[id][which_card]
                    <<",now p="<<p<<"."<<endl;
                player[id][which_card]=card[k--];
                flg=0;
                f.clear();
                goto flag;
            }
        }
    }
}

int main()
{
	//freopen("P7506_13.in","r",stdin);
    scanf("%d%d%d",&n,&m,&k);
    the_val["A1"]=1,the_val["A2"]=2,the_val["A5"]=5;
    the_val["A9"]=9,the_val["A19"]=19,the_val["A49"]=49;
    the_val["A99"]=99,the_val["B1"]=-1,the_val["B9"]=-9;
    the_val["B19"]=-19,the_val["C2"]=21,the_val["D2"]=22;
    the_val["E0"]=0,the_val["E49"]=491,the_val["E99"]=991;
    the_val["DOUBLE"]=INF,the_val["PASS"]=INF,the_val["TURN"]=INF;
    rep(i,1,n)
    {
        string name,c1,c2,c3;
        cin>>name>>c1>>c2>>c3;
        player[i]={name,c1,c2,c3};
    }
    dwn(i,k,1)
    {
        string c;cin>>c;
        card[i]=c;
    }
    start=1;
    the_way=1;
    int now_cnt=1;
    while(now_cnt<=m)
    {
        int p=0;
        cout<<"Round "<<now_cnt<<":"<<endl;
        while(!game_start(start,p)){
        	if(the_way==1) 
        	{
        		start+=1;
        		if(start>n)start=1;
			}
			else {
				start-=1;
				if(start<1)start=n;
			}
		}
		the_way=1;
		flg=0;
        now_cnt++;
    }
}
```

---

## 作者：ppllxx_9G (赞：2)

## 思路

大模拟，打法暴力。单独考虑普通牌和解牌。

对于普通牌，因为只有三张手牌，所以我们可以在每次
选择出牌时都遍历一遍，找到最大或最小的合法牌。

对于解牌，只有三种，可以暴力搞。按优先级遍历三遍，分别找是否有对应的牌，如果有直接出就好。

比较难处理的是 DOUBLE 标记，其实标记只会传给下一个人，我们只要记录标记是否传递着。如果用解牌跳过，那么标记仍在传递。如果没有解牌只能用普通牌，这时无论输赢，标记都会被消除。
## 注意事项

1. 出牌的优先级在有 DOUBLE 标记和没有时不一样，
	没有标记时为**乘法牌、加法牌、减法牌、除法牌、固定牌，尽可能大**，有标记时为**除法牌、减法牌、加法牌、乘法牌、固定牌，尽可能小**，我们可以预处理优先级。
    
2. 如果有标记时要优先出解牌，没有标记优先出普通牌。DOUBLE 标记如果用解牌消掉**直接跳下一个人**，否则还要按没有标记的再出一次牌。

3. 出牌顺序每次重置。

4. 如果输了要重新摸三张牌。

5. 负数向下取整的问题，在这道题中因为只有除二的操作，所以我们可以直接用**右移一**代替。

6. 建议**多写函数**，把各个函数调好了再整合。

## 参考代码

注释很详细。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5+5;
int n,m,k,now,st,p,fl=1;
string d[N];
bool dou;
map<char,int> mp[2]={{{'C',1},{'A',2},{'B',3},{'D',4},{'E',5}},{{'D',1},{'B',2},{'A',3},{'C',4},{'E',5}}};
//注意优先级 
struct P
{
	string name;
	string c[3];
} a[35];
int cal(int x,string c)
{
	int len=c.length(),tmp=0;
	if(len==2) tmp=c[1]-48;
	else tmp=(c[1]-48)*10+c[2]-48;
	if(c[0]=='A') return x+tmp;
	else if(c[0]=='B') return x-tmp;
	else if(c[0]=='C') return x*2;
	else if(c[0]=='D'&&c[1]!='O') return x>>=1;//和　DOUBLE 区分，注意向下取整 
	else if(c[0]=='E') return tmp; 
	else return 10000000;// 单独考虑解牌，这里不计 
}
bool jd(int i)//暴力搞 
{
	for(int j=0;j<3;j++) if(a[i].c[j]=="PASS")
	{
		cout<<a[i].name<<" used "<<a[i].c[j]<<",now p="<<p<<".\n";
		a[i].c[j]=d[++now]; return 1;	
	}
	for(int j=0;j<3;j++) if(a[i].c[j]=="TURN")
	{
		cout<<a[i].name<<" used "<<a[i].c[j]<<",now p="<<p<<".\n";
		a[i].c[j]=d[++now];fl*=-1; return 1;			
	}	
	for(int j=0;j<3;j++) if(a[i].c[j]=="DOUBLE")
	{
		cout<<a[i].name<<" used "<<a[i].c[j]<<",now p="<<p<<".\n";
		a[i].c[j]=d[++now]; dou=1; return 1;
	}
	return 0;
}
pair<int,int> work(int i,bool op)
{
	int tm,id;
	if(op==0)
	{
		tm=-1e9,id=-1;
		for(int j=0;j<3;j++)
		{
			int tmp=cal(p,a[i].c[j]);
			if(tmp>99) continue;
			else if(tmp>tm) tm=tmp,id=j;//较大的 
			else if(tmp==tm)
			{
				if(mp[op][a[i].c[id][0]]>mp[op][a[i].c[j][0]]) id=j;
			}
		}		
	}
	else
	{
		tm=1e9,id=-1;
		for(int j=0;j<3;j++)
		{
			int tmp=cal(p,a[i].c[j]);
			if(tmp>99) continue;
			else if(tmp<tm) tm=tmp,id=j;//较小的 
			else if(tmp==tm)
			{
				if(mp[op][a[i].c[id][0]]>mp[op][a[i].c[j][0]]) id=j; 
			}
		}		
	}
	return make_pair(tm,id);
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].name>>a[i].c[0]>>a[i].c[1]>>a[i].c[2];
	}
	for(int i=1;i<=k;i++) cin>>d[i];
	st=1;
	for(int g=1;g<=m;g++)
	{
		printf("Round %d:\n",g);
		p=0; fl=1;//重置 
		for(int i=st;;i+=fl)
		{
			if(i==n+1) i=1;
			if(i==0) i=n;
			if(dou)
			{
				if(!jd(i))//先判解牌 
				{
					dou=0;//没有解牌，消除标记 
					pair<int,int> pii=work(i,1);
					int id=pii.second,tm=pii.first;
					if(id!=-1) 
					{
						p=tm;
						cout<<a[i].name<<" used "<<a[i].c[id]<<",now p="<<p<<".\n";
						a[i].c[id]=d[++now];
					}
					else 
					{
						if(jd(i)) continue;
						cout<<a[i].name<<" lost the game.\n";
						for(int j=0;j<3;j++) a[i].c[j]=d[++now];
						st=i; break;
					}									
				}
				else continue;//注意直接跳 
			}
			pair<int,int> pii=work(i,0);
			int id=pii.second,tm=pii.first;
			if(id!=-1) 
			{
				p=tm; 
				cout<<a[i].name<<" used "<<a[i].c[id]<<",now p="<<p<<".\n";
				a[i].c[id]=d[++now];
			}
			else 
			{
				if(jd(i)) continue;//判解牌 
				cout<<a[i].name<<" lost the game.\n";
				for(int j=0;j<3;j++) a[i].c[j]=d[++now];
				st=i; break;
			}
		}
	}
	return 0;
}
```

---

## 作者：NaOH_Frog (赞：2)


一道谔谔模拟题。出题人觉得要评绿，不过我验了三天（悲）

这一题的关键其实还是要想个办法模拟每个人的出牌，而且模拟不要出锅

所以我就采用了把“被施加 double ”和正常状态的出牌顺序都写了一下（指 $s$ 和 $s2$），然后到时候就按需排序。

判断出牌效果应该很简单。

最后就是一些细节判断，注意出牌顺序是顺时针还是逆时针。

还有个奇怪的坑：$D2$ 的效果是**下取整**，所以负数下取整应该是 C++ 内置的上取整。比如 $-2.5$ 在 C++ 的 ceil 里就会变成 $-3$ ，非常野蛮。所以要手写下取整。

附代码（里面应该有每个函数的解释）：

```cpp
#include <bits/stdc++.h>
#define div(x) (x % 2 == 0 ? x / 2 : (x >= 0 ? x / 2 : x / 2 - 1))
using namespace std;
string s[18] = {"C2", "A99", "A49", "A19", "A9", "A5", "A2", "A1", "B1", "B9", "B19", "D2", "E99", "E49", "E0", "PASS", "TURN", "DOUBLE"};
string s2[18] = {"E99", "E49", "E0", "C2", "A99", "A49", "A19", "A9", "A5", "A2", "A1", "B1", "B9", "B19", "D2", "DOUBLE", "TURN", "PASS"};
int p, n, m, k, r = 0, pos = 0;
bool turn = false;
struct player{
	string name, c[3];
	bool under_double = false;
}a[107];
struct nod{
	int x;
	string name;
	int pos;
};
string dump[1000007];
int find(string x){
	for(int i = 0; i < 18; i++) if(x == s[i]) return i;
	return 2147483647;
}
int find2(string x){
	for(int i = 0; i < 18; i++) if(x == s2[i]) return i;
	return 2147483647;
}
bool cmp3(nod a, nod b){
	if(a.x == b.x) return find(a.name) < find(b.name);
	return a.x > b.x;
} 
bool cmp4(nod a, nod b){
	if(a.x == b.x) return find2(a.name) > find2(b.name);
	return a.x < b.x;
}
vector<nod> v;
bool dbl;
void check(string x, int po){//打出x以后的效果，并且记录结果 
	if(x == "C2") v.push_back({p * 2, "C2", po});
	if(x[0] == 'A'){
		int res = 0;
		for(int i = 1; i < x.size(); i++){
			res += x[i] - '0';
			res *= 10;
		}
		res /= 10;
		v.push_back({p + res, x, po});
	}
	if(x[0] == 'B'){
		int res = 0;
		for(int i = 1; i < x.size(); i++){
			res += x[i] - '0';
			res *= 10;
		}
		res /= 10;
		v.push_back({p - res, x, po});
	}
	if(x == "D2") v.push_back({div(p), "D2", po});
	if(x[0] == 'E'){
		int res = 0;
		for(int i = 1; i < x.size(); i++){
			res += x[i] - '0';
			res *= 10;
		}
		res /= 10;
		v.push_back({res, x, po});
	}
	if(x == "PASS" || x == "TURN" || x == "DOUBLE") v.push_back({-2147483647, x, po});
	return;
}
void lose(int x);
void use(int x){//第x个人出牌 
	bool flag = false; 
//	cout << a[x].name << " " << a[x].under_double << " " << turn << " ";
	if(a[x].under_double){
//		cout << "aaa" << endl;
		a[x].under_double = false;
		v.clear();
		for(int i = 0; i < 3; i++) check(a[x].c[i], i);
		sort(v.begin(), v.end(), cmp4);
//		cout << v[0].name << " " << v[0].x << " " << v[1].name << " " << v[1].x << " " << v[2].name << " " << v[2].x << endl;
		for(int i = 0; i < 3; i++){
			if(v[i].name == "PASS"){
				cout << a[x].name << " used " << v[i].name << ",now p=" << p << "." << endl;
				a[x].c[v[i].pos] = dump[pos], pos++;
				turn ? a[(x - 1 + n) % n].under_double = true : a[(x + 1) % n].under_double = true;
				turn ? use((x - 1 + n) % n) : use((x + 1) % n);
				return;
			}
			if(v[i].name == "TURN"){
				cout << a[x].name << " used " << v[i].name << ",now p=" << p << "." << endl;
				a[x].c[v[i].pos] = dump[pos], pos++;
				turn = !turn;
				turn ? a[(x - 1 + n) % n].under_double = true : a[(x + 1) % n].under_double = true;
				turn ? use((x - 1 + n) % n) : use((x + 1) % n);
				return;
			}
			if(v[i].name == "DOUBLE"){
				cout << a[x].name << " used " << v[i].name << ",now p=" << p << "." << endl;
				a[x].c[v[i].pos] = dump[pos], pos++;
				turn ? a[(x - 1 + n) % n].under_double = true : a[(x + 1) % n].under_double = true;
				turn ? use((x - 1 + n) % n) : use((x + 1) % n);
				return;
			}
			if(v[i].name != "PASS" && v[i].name != "TURN" && v[i].name != "DOUBLE"){
				if(v[i].x <= 99){
					cout << a[x].name << " used " << v[i].name << ",now p=" << v[i].x << "." << endl;
					p = v[i].x;
					flag = true;
					a[x].c[v[i].pos] = dump[pos], pos++;
					break;
				}
			}
		}
	}
	if(!flag && a[x].under_double){
		lose(x);
		return;
	}
	flag = false;
	v.clear();
	for(int i = 0; i < 3; i++) check(a[x].c[i], i);
	sort(v.begin(), v.end(), cmp3);
//	cout << v[0].name << " " << v[0].x << " " << v[1].name << " " << v[1].x << " " << v[2].name << " " << v[2].x << endl;
	for(int i = 0; i < 3; i++){
		if(v[i].name != "PASS" && v[i].name != "TURN" && v[i].name != "DOUBLE"){
			if(v[i].x <= 99){
				p = v[i].x;
				cout << a[x].name << " used " << v[i].name << ",now p=" << v[i].x << "." << endl;
				flag = true;
				a[x].c[v[i].pos] = dump[pos], pos++;
				break;
			}
		}else{
			if(v[i].name == "PASS"){
				cout << a[x].name << " used " << v[i].name << ",now p=" << p << "." << endl;
				a[x].c[v[i].pos] = dump[pos], pos++;
				turn ? use((x - 1 + n) % n) : use((x + 1) % n);
				return;
			}
			if(v[i].name == "TURN"){
				cout << a[x].name << " used " << v[i].name << ",now p=" << p << "." << endl;
				a[x].c[v[i].pos] = dump[pos], pos++;
				turn = !turn;
				turn ? use((x - 1 + n) % n) : use((x + 1) % n);
				return;
			}
			if(v[i].name == "DOUBLE"){
				cout << a[x].name << " used " << v[i].name << ",now p=" << p << "." << endl;
				a[x].c[v[i].pos] = dump[pos], pos++;
				turn ? a[(x - 1 + n) % n].under_double = true : a[(x + 1) % n].under_double = true;
				turn ? use((x - 1 + n) % n) : use((x + 1) % n);
				return;
			}
		}
	}
	if(!flag){
		lose(x);
		return;
	}
	turn ? use((x - 1 + n) % n) : use((x + 1) % n);
}
void play(int lst){//last
	p = 0;
	turn = false;
	for(int i = 0; i < n; i++) a[i].under_double = false;
	if(r == m) exit(0);
	r++;
	printf("Round %d:\n", r);
	use(lst); 
}
void lose(int x){//第x个人输了 
	cout << a[x].name << " lost the game." << endl;
	a[x].c[0] = dump[pos], pos++;
	a[x].c[1] = dump[pos], pos++;
	a[x].c[2] = dump[pos], pos++; 
	play(x);
}
int main(){
	cin >> n >> m >> k;
	string pl, s1, s2, s3;
	for(int i = 0; i < n; i++){
		cin >> pl >> s1 >> s2 >> s3;
		a[i].name = pl;
		a[i].c[0] = s1;
		a[i].c[1] = s2;
		a[i].c[2] = s3;
	}
	for(int i = 0; i < k; i++) cin >> dump[i];
	play(0);
	return 0; 
}
//好孩子不要抄袭哦
```


---

## 作者：hbhz_zcy (赞：1)

这是大模拟。  
大致可以分成几个部分：I/O处理，回合遍历，出牌预判。  
数据结构设计：使用数组模拟二元组 $x$，结构体 $user$ 维护用户当前情况，$st$ 维护牌堆，以及一些其他辅助变量。  
```cpp
struct node{char name[maxc];int x[4][2];}user[maxn];
const char spcard[3][maxc]={"PASS","TURN","DOUBLE"};
void qds(int x[2]){
	x[0]=0,x[1]=0;
	char s[maxc];scanf(" %s",s);
	for(int i=0;i<=2;i++)  if(!strcmp(s,spcard[i]))  x[0]=i+6;
	if(x[0])  return;
	x[0]=s[0]-'A'+1;
	x[1]=s[1]-48;
	if(s[2])  x[1]=x[1]*10+s[2]-48;
//	printf("readin%c%d\n",x[0]+'A'-1,x[1]);
}
void qss(int x[2]){
//	printf("/%d,%d/",x[0],x[1]);
	if(x[0]>=6)  printf("%s",spcard[x[0]-6]);
	else  printf("%c%d",'A'-1+x[0],x[1]);
}
```
以上是读入一张牌和输出一张牌，其中一张牌 $6\le x_0\le8$ 时表示特殊牌，否则 $1\le x_0\le5$，表示普通牌，并且 $x_1$ 保存参数。  
```cpp
int main(){
//	freopen("in.txt","r",stdin);
	N=qd(),M=qd(),K=qd();
	for(int i=1;i<=N;i++){
		scanf(" %s",user[i].name);
		qds(user[i].x[1]),qds(user[i].x[2]),qds(user[i].x[3]);
	}
	for(int i=1;i<=K;i++)  qds(st[i]);
	int t=1;
	for(int i=1;i<=M;i++){
		printf("Round %d:\n",i);
		while(1){
			int k=calc(t),c=user[t].x[k][0];
			if(!k){printf("%s lost the game.\n",user[t].name);break;}
			printf("%s used ",user[t].name);qss(user[t].x[k]);printf(",now p=%d.\n",P);
			get(user[t].x[k]);
			if(c<=5&&ded){ded=0;continue;}
			if(!ted){if(++t>N)  t=1;}
			else if(--t<1)  t=N;
		}
		P=ded=ted=0;get(user[t].x[1]),get(user[t].x[2]),get(user[t].x[3]);
	}
	return 0;
}
```
$main$ 函数承担了一些剩下的输入输出，以及遍历和 $ted,ded$ 维护。  
可以看出 $t$ 是循环回合、出牌的指针，$ted$ 表示循环正倒序，$ded$ 表示是否在double状态下，处理的思路是先用 $ded$ 标记第一次出牌，出了普通牌后把它归零，再在同一个人下跑一遍普通局。  
引用的函数 $get$ 是从牌堆里取牌，提供位置会直接覆盖。$calc$ 是选择牌，提供用户编号，返回选择的位置，是主要处理部分。  
```cpp
int calc(int t){
	int l=1;
	if(ded){for(int i=2;i<=3;i++)  if(cmpd(user[t].x[i],user[t].x[l]))  l=i;}
	else{for(int i=2;i<=3;i++)  if(cmp(user[t].x[i],user[t].x[l]))  l=i;}
	if(user[t].x[l][0]==7)  ted^=1;
	if(user[t].x[l][0]==8)  ded=1;
	P=pre(user[t].x[l]);
	return P>99?0:l;
}
```
因为顺序问题与double状态有关，故设计了double意义下的比较 $cmpd$ 和普通比较 $cmp$。以及计算新P值函数（特殊牌不参与计算） $pre$ 。在这里也就各张牌比较了一下出了结果，并维护了 $ted,ded$。  
具体的，上面提到的辅助函数 $get,cmp,cmpd,pre$ 大多直接按题意写的，代码长（压行严重）但浅显（甚至有一些优化没写），就不单独放了。  
有一点是除以 $2$ 向下取整，而非向 $0$ 取整。别的OJ数据因为这个让我挂了 $55$ 分。  
```cpp
//g++ a.cpp -g -o a -std=c++98 -O0 -Wall
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=35,maxm=110,maxk=3e5+10,maxc=50;
const char spcard[3][maxc]={"PASS","TURN","DOUBLE"};
int N,M,K,P,st[maxk][2],stop=1,ded,ted;//user num,game num,heap...doubled,turned
struct node{char name[maxc];int x[4][2];}user[maxn];
int qd(){
	int rt=0;char c=getchar();
	while(c<'0'||c>'9')  c=getchar();
	while('0'<=c&&c<='9')  rt=(rt<<3)+(rt<<1)+c-48,c=getchar();
	return rt;
}
void qds(int x[2]){
	x[0]=0,x[1]=0;
	char s[maxc];scanf(" %s",s);
	for(int i=0;i<=2;i++)  if(!strcmp(s,spcard[i]))  x[0]=i+6;
	if(x[0])  return;
	x[0]=s[0]-'A'+1;
	x[1]=s[1]-48;
	if(s[2])  x[1]=x[1]*10+s[2]-48;
//	printf("readin%c%d\n",x[0]+'A'-1,x[1]);
}
void qss(int x[2]){
//	printf("/%d,%d/",x[0],x[1]);
	if(x[0]>=6)  printf("%s",spcard[x[0]-6]);
	else  printf("%c%d",'A'-1+x[0],x[1]);
}
void get(int x[2]){x[0]=st[stop][0],x[1]=st[stop][1];stop++;}
int pre(int x[2]){
	if(x[0]==1)  return P+x[1];
	if(x[0]==2)  return P-x[1];
	if(x[0]==3)  return P*x[1];
	if(x[0]==4)  return (P<0&&P%2?-1:0)+P/x[1];
	if(x[0]==5)  return x[1];
	return P;
}//cmp:should I choose first
int cmpd(int x[2],int y[2]){
	if(x[0]>=6&&y[0]>=6)  return x[0]<y[0];
	if(x[0]>=6)  return 1;
	if(y[0]>=6)  return 0;
	int vx=pre(x),vy=pre(y);
	if(vx!=vy)  return vx<vy;
	if(x[0]==4)  vx=1;else if(x[0]==2)  vx=2;else if(x[0]==1)  vx=3;else if(x[0]==3)  vx=4;else if(x[0]==5)  vx=5;
	if(y[0]==4)  vy=1;else if(y[0]==2)  vy=2;else if(y[0]==1)  vy=3;else if(y[0]==3)  vy=4;else if(y[0]==5)  vy=5;
	return vx<vy;
}
int cmp(int x[2],int y[2]){
	int vx=pre(x),vy=pre(y);
	if(vx>99)  return 0;
	if(vy>99)  return 1;
	if(x[0]>=6&&y[0]>=6)  return x[0]<y[0];
	if(x[0]>=6)  return 0;
	if(y[0]>=6)  return 1;
	if(vx!=vy)  return vx>vy;
	if(x[0]==3)  vx=1;else if(x[0]==1)  vx=2;else if(x[0]==2)  vx=3;else if(x[0]==4)  vx=4;else if(x[0]==5)  vx=5;
	if(y[0]==3)  vy=1;else if(y[0]==1)  vy=2;else if(y[0]==2)  vy=3;else if(y[0]==4)  vy=4;else if(y[0]==5)  vy=5;
	return vx<vy;
}
int calc(int t){
	int l=1;
	if(ded){for(int i=2;i<=3;i++)  if(cmpd(user[t].x[i],user[t].x[l]))  l=i;}
	else{for(int i=2;i<=3;i++)  if(cmp(user[t].x[i],user[t].x[l]))  l=i;}
	if(user[t].x[l][0]==7)  ted^=1;
	if(user[t].x[l][0]==8)  ded=1;
	P=pre(user[t].x[l]);
	return P>99?0:l;
}
int main(){
//	freopen("in.txt","r",stdin);
	N=qd(),M=qd(),K=qd();
	for(int i=1;i<=N;i++){
		scanf(" %s",user[i].name);
		qds(user[i].x[1]),qds(user[i].x[2]),qds(user[i].x[3]);
	}
	for(int i=1;i<=K;i++)  qds(st[i]);
	int t=1;
	for(int i=1;i<=M;i++){
		printf("Round %d:\n",i);
		while(1){
			int k=calc(t),c=user[t].x[k][0];
			if(!k){printf("%s lost the game.\n",user[t].name);break;}
			printf("%s used ",user[t].name);qss(user[t].x[k]);printf(",now p=%d.\n",P);
			get(user[t].x[k]);
			if(c<=5&&ded){ded=0;continue;}
			if(!ted){if(++t>N)  t=1;}
			else if(--t<1)  t=N;
		}
		P=ded=ted=0;get(user[t].x[1]),get(user[t].x[2]),get(user[t].x[3]);
	}
	return 0;
}
```
总体来说，这道题操作的模拟还是比较简单的，就是题干有点长，不好理解并需要注意细节。建议轻微压行精简代码，但不要破坏主体结构的清晰划分。  


---

## 作者：Ratio_Y (赞：1)

一道挺小的大模拟。

## 思路
对于两种出牌策略，我们分别进行是否按 double 优先级的排序。

对于有 double 效果的回合，先考虑解牌，再考虑基本牌，找到最小值，若仍无解则回合结束。

对于没有 double 效果的回合，先考虑基本牌，找到符合条件的最大值，再考虑解牌，若仍无解则回合结束。

## 细节
思路题面其实就给明了，模拟题主要还是在细节方面。

首先，每回合的 double，turn，p 值都要重新置零，算是写明的隐含条件。

其次，double 效果存在时使用解牌会直接跳过整个回合，若未使用解牌则消除 double 效果，再进行一次正常回合。

最后，败者重新摸牌时一次摸三张。

## Code：
300 行代码奉上。

```
#include<bits/stdc++.h>
#define fo(x,y,z) for(register int (x)=(y);(x)<=(z);(x)++)
#define fu(x,y,z) for(register int (x)=(y);(x)>=(z);(x)--)
using namespace std;
const int Ratio=0;
const int N=3e5+5;
const int mod=1e9+7;
int n,m,k,p,tot=1;
// tot 为牌堆摸取位置
string nam[31],have[31][4],paidui[N];
// 玩家名，玩家拥有手牌，牌堆
bool turnn,doubll,jp,endd;
// 分别表示出牌顺序，double 施加情况，解牌跳过 double，结束回合
// 由于 double 无论如何都是施加在下一个出牌的人身上的，所以一个变量就够
bool cmp(string a,string b)// 无 double 优先级排序
{
	int anum=-1,bnum=-1;
	if(a=="C2") anum=0;
	else if(a=="A99") anum=1;
	else if(a=="A49") anum=2;
	else if(a=="A19") anum=3;
	else if(a=="A9") anum=4;
	else if(a=="A5") anum=5;
	else if(a=="A2") anum=6;
	else if(a=="A1") anum=7;
	else if(a=="B1") anum=8;
	else if(a=="B9") anum=9;
	else if(a=="B19") anum=10;
	else if(a=="D2") anum=11;
	else if(a=="E99") anum=12;
	else if(a=="E49") anum=13;
	else if(a=="E0") anum=14;
	else if(a=="PASS") anum=15;
	else if(a=="TURN") anum=16;
	else if(a=="DOUBLE") anum=17;
	if(b=="C2") bnum=0;
	else if(b=="A99") bnum=1;
	else if(b=="A49") bnum=2;
	else if(b=="A19") bnum=3;
	else if(b=="A9") bnum=4;
	else if(b=="A5") bnum=5;
	else if(b=="A2") bnum=6;
	else if(b=="A1") bnum=7;
	else if(b=="B1") bnum=8;
	else if(b=="B9") bnum=9;
	else if(b=="B19") bnum=10;
	else if(b=="D2") bnum=11;
	else if(b=="E99") bnum=12;
	else if(b=="E49") bnum=13;
	else if(b=="E0") bnum=14;
	else if(b=="PASS") bnum=15;
	else if(b=="TURN") bnum=16;
	else if(b=="DOUBLE") bnum=17;
	return anum<bnum;
}
bool cmpd(string a,string b)// 有 double 优先级排序
{
	int anum=-1,bnum=-1;
	if(a=="PASS") anum=0;
	else if(a=="TURN") anum=1;
	else if(a=="DOUBLE") anum=2;
	else if(a=="D2") anum=3;
	else if(a=="B19") anum=4;
	else if(a=="B9") anum=5;
	else if(a=="B1") anum=6;
	else if(a=="A1") anum=7;
	else if(a=="A2") anum=8;
	else if(a=="A5") anum=9;
	else if(a=="A9") anum=10;
	else if(a=="A19") anum=11;
	else if(a=="A49") anum=12;
	else if(a=="A99") anum=13;
	else if(a=="C2") anum=14;
	else if(a=="E0") anum=15;
	else if(a=="E49") anum=16;
	else if(a=="E99") anum=17;
	if(b=="PASS") bnum=0;
	else if(b=="TURN") bnum=1;
	else if(b=="DOUBLE") bnum=2;
	else if(b=="D2") bnum=3;
	else if(b=="B19") bnum=4;
	else if(b=="B9") bnum=5;
	else if(b=="B1") bnum=6;
	else if(b=="A1") bnum=7;
	else if(b=="A2") bnum=8;
	else if(b=="A5") bnum=9;
	else if(b=="A9") bnum=10;
	else if(b=="A19") bnum=11;
	else if(b=="A49") bnum=12;
	else if(b=="A99") bnum=13;
	else if(b=="C2") bnum=14;
	else if(b=="E0") bnum=15;
	else if(b=="E49") bnum=16;
	else if(b=="E99") bnum=17;
	return anum<bnum;
}
// 排序保证选择普通牌顺序
namespace Wisadel
{
	int Wgetnext(int now)
	{// 找到下一个出牌的人
		if(turnn) now=(now==1?n:now-1);
		else now=(now==n?1:now+1);
		return now;
	}
	void Wworkjp(int now)
	{// 解牌优先
		bool can=0;
		sort(have[now]+1,have[now]+4,cmpd);
		// 按 double 优先级排序
		fo(i,1,3)
		{// 先考虑解牌
			string ss=have[now][i];
			if(ss=="PASS")
			{
				cout<<"used "<<ss<<",now p="<<p<<".\n";
				jp=1;can=1;// 直接跳过
				have[now][i]=paidui[tot++];// 取牌
				break;
			}
			else if(ss=="TURN")
			{
				cout<<"used "<<ss<<",now p="<<p<<".\n";
				jp=1;can=1;
				if(turnn) turnn=0;
				else turnn=1;// 反转出牌顺序
				have[now][i]=paidui[tot++];
				break;
			}
			else if(ss=="DOUBLE")
			{
				cout<<"used "<<ss<<",now p="<<p<<".\n";
				jp=1;can=1;
				doubll=1;// 记录 double 效果
				have[now][i]=paidui[tot++];
				break;
			}
		}
		if(can) return;
		// 若无解牌，则考虑基本牌
		int num=0,no,minn=1e9;
		fo(i,1,3)
		{// 考虑基本牌使用，按要求找最小值
			string ss=have[now][i];no=p;
			if(ss=="A1") no+=1;
			else if(ss=="A2") no+=2;
			else if(ss=="A5") no+=5;
			else if(ss=="A9") no+=9;
			else if(ss=="A19") no+=19;
			else if(ss=="A49") no+=49;
			else if(ss=="A99") no+=99;
			else if(ss=="B1") no-=1;
			else if(ss=="B9") no-=9;
			else if(ss=="B19") no-=19;
			else if(ss=="C2") no*=2;
			else if(ss=="D2") no=floor(1.0*no/2);
			else if(ss=="E0") no=0;
			else if(ss=="E49") no=49;
			else if(ss=="E99") no=99;
			else no=10000;
			if(no<=99&&no<minn) num=i,minn=no,can=1;
		}
		if(!can)
		{// 仍必败
			endd=1;
			cout<<"lost the game.\n";
		}
		else
		{// 可不败，打一摸一
			doubll=0;
			cout<<"used "<<have[now][num]<<",now p="<<minn<<".\n";
			have[now][num]=paidui[tot++];
			p=minn;
		}
	}
	void Wwork(int now)
	{// 普通牌优先
		sort(have[now]+1,have[now]+4,cmp);
		// 按无 double 优先级排序
		bool can=0;int num=0,no,maxx=-1e9;
		fo(i,1,3)
		{// 考虑基本牌使用，按要求找范围内最大值
			string ss=have[now][i];no=p;
			if(ss=="A1") no+=1;
			else if(ss=="A2") no+=2;
			else if(ss=="A5") no+=5;
			else if(ss=="A9") no+=9;
			else if(ss=="A19") no+=19;
			else if(ss=="A49") no+=49;
			else if(ss=="A99") no+=99;
			else if(ss=="B1") no-=1;
			else if(ss=="B9") no-=9;
			else if(ss=="B19") no-=19;
			else if(ss=="C2") no*=2;
			else if(ss=="D2") no=floor(1.0*no/2);
			else if(ss=="E0") no=0;
			else if(ss=="E49") no=49;
			else if(ss=="E99") no=99;
			else no=10000;
			if(no<=99&&no>maxx) num=i,maxx=no,can=1;
		}
		if(can)
		{// 能打则打一摸一
			cout<<"used "<<have[now][num]<<",now p="<<maxx<<".\n";
			p=maxx;
			have[now][num]=paidui[tot++];
			return;
		}
		fo(i,1,3)
		{// 否则考虑解牌
			string ss=have[now][i];
			if(ss=="PASS")
			{
				cout<<"used "<<ss<<",now p="<<p<<".\n";
				can=1;
				have[now][i]=paidui[tot++];
				break;
			}
			else if(ss=="TURN")
			{
				cout<<"used "<<ss<<",now p="<<p<<".\n";
				can=1;
				if(turnn) turnn=0;
				else turnn=1;
				have[now][i]=paidui[tot++];
				break;
			}
			else if(ss=="DOUBLE")
			{
				cout<<"used "<<ss<<",now p="<<p<<".\n";
				can=1;doubll=1;
				have[now][i]=paidui[tot++];
				break;
			}// 过程中直接打一摸一
		}
		if(!can)
		{// 必败
			endd=1;
			cout<<"lost the game.\n";
		}
	}
	short main()
	{
		// freopen("A.in","r",stdin),freopen("1.out","w",stdout);
		scanf("%d%d%d",&n,&m,&k);
		fo(i,1,n) cin>>nam[i]>>have[i][1]>>have[i][2]>>have[i][3];
		fo(i,1,k) cin>>paidui[i];
		// 输入
		int laslos=1;
		// 从上回合熟的人开始，第一回合从 1 号开始
		fo(roundd,1,m)
		{
			printf("Round %d:\n",roundd);
			doubll=p=turnn=endd=0;int now=laslos;
			// 初始化标记变量
			while(1)
			{
				cout<<nam[now]<<' ';jp=0;
				if(doubll)
				{// 有 double 效果
					Wworkjp(now);
					// 先按 double 打一次
					if(jp)
					{// 使用了解牌，直接跳过
						now=Wgetnext(now);
						continue;
					}
					else if(endd)
					{// 败了
						laslos=now;
						if(roundd!=m)
						{// 重新摸牌
							have[now][1]=paidui[tot++];
							have[now][2]=paidui[tot++];
							have[now][3]=paidui[tot++];
						}
						break;
					}
					else 
					{// 否则按无 double 效果再进行一回合
						cout<<nam[now]<<' ';
						Wwork(now);
					}
				}
				else Wwork(now);
				// 无 double 效果
				if(endd)
				{// 败了
					laslos=now;
					if(roundd!=m)
					{
						have[now][1]=paidui[tot++];
						have[now][2]=paidui[tot++];
						have[now][3]=paidui[tot++];
					}
					break;
				}
				now=Wgetnext(now);
			}
		}
		return Ratio;
	}
}
int main(){return Wisadel::main();}
```

感觉大模拟确实是锻炼码力的最好办法。

---


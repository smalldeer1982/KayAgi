# 魔力滋生

## 题目背景

Source：[八仙敬酒](/paste/78f1vlm0)，这是可以点的。

- 吕洞宾——醉酒提壶力千钧；
- 铁拐李——旋肘膝撞醉还真；
- 汉钟离——跌步抱坛兜心顶；
- **蓝采和——单提敬酒拦腰破**；
- 张果老——醉酒抛杯踢连环；
- 曹国舅——仙人敬酒锁喉扣；
- 韩湘子——擒腕击胸醉吹箫；
- 何仙姑——弹腰献酒醉荡步。

## 题目描述

现有一个 $n$ 个点的树 $T$，满足任意一个结点的所连接的结点个数不超过 $2$。

现在依次对结点 $u=1\sim n$ 进行操作：

- 随机一个整数 $x(\ge k)$；
- 新建 $x$ 个结点，每个结点与 $u$ 之间连一条边。

显然操作完成后仍是一棵树 $T'$，其结点数为 $m=n+\sum x$。

已知操作后的树 $T'$ 及其结点数 $m$，请还原原树 $T$，若有多种方案，输出 **任意一组** 使得 $\color{black}n$ **最大** 的。

值得注意的是，我们进行还原和输出时，只关心树的形状，而不关心结点的相对编号。

## 说明/提示

#### 样例说明

样例 $\#1$ 中，只有结点 $1$ 可能在树 $T$ 中：它对应的 $x$ 是 $4$。

样例 $\#2$ 中，结点 $1,2,3$ 在树 $T$ 中：结点 $1$ 对应的 $x$ 是 $4$，结点 $2,3$ 对应的 $x$ 是 $0$。

样例 $\#3$ 中，结点 $1,2,3$ 在树 $T$ 中：它们随机的 $x$ 均为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4mug6pzd.png)

样例 $\#3$ 给出一张示意图，图中红色结点表示树 $T$ 中的结点，图中所有结点都在树 $T'$ 上。

#### 数据范围

| Subtask | Score | $x=$ |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $0$ |
| $2$ | $30$ | $1$ |
| $3$ | $40$ |  |
| $4$ | $0$ | Hack |

说明：Subtask4 为不计分 Hack 数据，只有通过全部的 Subtask $1\sim4$ 才算 AC。

对于 $100\%$ 的数据：$1\le m\le10^5,k\in[0,m)$，数据输入保证有解。

---

### 后记

极光魔花好可爱 $\sim$

![](https://cdn.luogu.com.cn/upload/image_hosting/o0gdk38a.png)

## 样例 #1

### 输入

```
5 1
1 2
1 3
1 4
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
7 0
1 2
1 3
1 4
1 5
1 6
1 7```

### 输出

```
3
1 2
1 3```

## 样例 #3

### 输入

```
9 1
1 2
2 3
1 4
1 5
2 6
2 7
3 8
3 9```

### 输出

```
3
1 2
2 3```

# 题解

## 作者：言琢დ (赞：12)

upd on 2021.10.26：加入代码，删减并修改部分内容。这本身是一篇高赞题解，因此管理员就不用费心再阅读一遍了。

$$\rm C~\text{魔力滋生}$$
	
部分分提示正解：前两个 Subtask 一个满足 $x=0$ 另一个满足 $x=1$，提示了分类讨论。
	
$n$ 个点的树，每个点的度不超过 $2$，也就是说这是一条 **链**。
	
首先考虑 $x=0$：显然此时给出的树 $T'$ 即原来的树 $T$，直接读入什么就输出什么即可。

其次考虑 $x=1$：此时每个点连接了一个新建点，但事实上不难发现，这 $n$ 个新建点的度均为 $1$，原来 **链** 中的点的度至少为 $2$。据此亦不难将所有度为 $1$ 的点从原来的 **链** 上剥离。
	
**满分做法：树的直径**
	
考虑先找到树的最长链。
	
若满足 $k=0$，则这条 **链** 就对应了最大的 $n$。
	
若满足 $k \ne 0$，则去掉这条 **链** 的头部和尾部，因为这两个点一定是新建的（否则 $k=0$）
	
去掉之后的链也一定对应了最大的 $n$。
	
时间复杂度 $O(n)$，期望得分 $100$ 分。

```cpp
#include<cstdio>
#include<cstring>
inline int in();
inline void wr(int);
const int N=(int)1e6+5;
struct Node{
	int next,to;
}s[N<<1];int head[N],sLen;
inline void AddEdge(int,int);
inline void dfs(int);
int dep[N],fa[N],q[N];
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen(argv[1],"r",stdin);
	freopen(argv[2],"w",stdout);
#endif
	register int m=in(),k=in();
	for(register int i=1;i<m;++i)
		AddEdge(in(),in());
	dfs(1);
	register int root=0;
	for(register int i=1;i<=m;++i)
		if(dep[i]>dep[root])
			root=i;
	memset(dep,0,sizeof(dep));
	memset(fa,0,sizeof(fa));
	dfs(root);
	register int tail=0;
	for(register int i=1;i<=m;++i)
		if(dep[i]>dep[tail])
			tail=i;
	if(m==1){
		wr(1),putchar('\n');
		return 0;
	}
	//only one node
	if(!k){
		while(tail!=root){
			q[++q[0]]=tail;
			tail=fa[tail];
		}
		q[++q[0]]=tail;
		wr(q[0]),putchar('\n');
		for(register int i=1;i<q[0];++i)
			wr(i),putchar(' '),wr(i+1),putchar('\n');
	}
	else{
		tail=fa[tail];
		if(root==tail){
			wr(1),putchar('\n');
			return 0;
		}
		while(fa[tail]!=root){
			q[++q[0]]=tail;
			tail=fa[tail];
		}
		q[++q[0]]=tail;
		wr(q[0]),putchar('\n');
		for(register int i=1;i<q[0];++i)
			wr(i),putchar(' '),wr(i+1),putchar('\n');
	}
}
inline void dfs(int u){
	dep[u]=dep[fa[u]]+1;
	for(register int i=head[u];i;i=s[i].next){
		register int v=s[i].to;
		if(v==fa[u])continue;
		fa[v]=u,dfs(v);
	}
}
inline void AddEdge(int u,int v){
	s[++sLen].next=head[u];
	s[sLen].to=v;head[u]=sLen;
	s[++sLen].next=head[v];
	s[sLen].to=u;head[v]=sLen;
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

![](bilibili:BV1U3411z7SQ)

---

## 作者：CPPfive (赞：1)

补充一下出题人的题解。

如果 $k=0$，那么我们找到最长的直径即为答案。但如果 $k≠0$，实际上我们不需要找直径，我们只需要把所有度数为 $1$ 的点都去掉就可以了。唯一需要特判的是原来的树只有一个结点的情况。

这种做法的正确性是很显然的。把原来的树只有一个结点的特殊情况除去后，原来的树中的每一个结点至少度数为 $1$，又因为每个结点至少连到 $1$ 个新结点上，因此原来的树上的结点数一定大于 $1$。而对于每一个新增结点来说，它的度数只能为 $1$，因此这种做法一定可以把所有的新结点去除并把老结点留下。

贴一下代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=100005;
int M,K;
int from[MAXN],to[MAXN],cnt;
int h[MAXN],tooo[MAXN<<1],nxt[MAXN<<1],tot,degree[MAXN],dis[MAXN],use,too[MAXN];

void add(int u,int v){
	tooo[++tot]=v;
	nxt[tot]=h[u];
	h[u]=tot;
}

void dfs(int x,int fa){
	dis[x]=dis[fa]+1;
	for(int i=h[x];i;i=nxt[i]){
		if(tooo[i]==fa) continue;
		dfs(tooo[i],x);
	}
}

int main()
{
	scanf("%d%d",&M,&K);
	for(int i=1;i<M;++i){
		scanf("%d%d",&from[i],&to[i]);
		add(from[i],to[i]);
		add(to[i],from[i]);
		++degree[from[i]];++degree[to[i]];
	}
	
	if(!K){
		dfs(1,1);
		int mx=0,id=0;
		for(int i=1;i<=M;++i){
			if(dis[i]>mx) mx=dis[i],id=i;
		}
		memset(dis,0,sizeof(dis));
		dfs(id,id);
		mx=0;
		for(int i=1;i<=M;++i){
			if(dis[i]>mx) mx=dis[i];
		}
		printf("%d\n",mx);
		for(int i=1;i<mx;++i){
			printf("%d %d\n",i,i+1);
		}
		return 0;
	}
	else{
		for(int i=1;i<=M;++i){
			if(degree[i]==1) ++cnt;
		}
		if(cnt==M){
			printf("1\n");
			return 0;
		}
		printf("%d\n",M-cnt);
		bool flag=0;
		for(int i=1;i<M;++i){
			if(degree[from[i]]==1||degree[to[i]]==1) continue;
			flag=1;
			if(!too[from[i]]) too[from[i]]=++use;
			if(!too[to[i]]) too[to[i]]=++use;
			printf("%d %d\n",too[from[i]],too[to[i]]);
		}
		
		return 0;
	}
}
```


---

## 作者：Lyco_Reco (赞：0)

提供一种不需要树的直径的做法。

分类讨论：当 $k=0$ 时，遍历每一条边，如果当前遍历的边一个端点度数等于一，另一个端点度数大于二，就说明这条边是新加入的，直接删去，最后剩下的边即为答案；当 $k>0$ 时，删掉图中所有度数为一的点，剩下的即为答案。

代码：
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <deque>
#include <queue>
#include <iomanip>
#include <map>
#include <unordered_map>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
#define maxn 100010
int n,m,k,u[maxn],v[maxn],d[maxn],vis[maxn],hs[maxn],idx;
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	void MAIN(){
		m=rd();
		k=rd();
		for(int i=1;i<m;i++){
			u[i]=rd();
			v[i]=rd();
			d[u[i]]++;
			d[v[i]]++;
		}
		if(k==0){
			for(int i=1;i<m;i++){
				if(d[u[i]]==1&&d[v[i]]>2||d[v[i]]==1&&d[u[i]]>2){
					d[u[i]]--;
					d[v[i]]--;
					vis[i]=1;
				}
			}
			for(int i=1;i<m;i++){
				if(vis[i]){
					continue;
				}
				n++;
			}
			wrt(n+1);
			putchar('\n');
			for(int i=1;i<m;i++){
				if(!vis[i]){
					if(!hs[u[i]]){
						hs[u[i]]=++idx;
					}
					if(!hs[v[i]]){
						hs[v[i]]=++idx;
					}
					wrt(hs[u[i]]);
					putchar(' ');
					wrt(hs[v[i]]);
					putchar('\n');
				}
			}
		}
		else{
			for(int i=1;i<m;i++){
				if(d[u[i]]==1||d[v[i]]==1){
					vis[i]=1;
				}
			}
			for(int i=1;i<m;i++){
				if(vis[i]){
					continue;
				}
				n++;
			}
			wrt(n+1);
			putchar('\n');
			for(int i=1;i<m;i++){
				if(!vis[i]){
					if(!hs[u[i]]){
						hs[u[i]]=++idx;
					}
					if(!hs[v[i]]){
						hs[v[i]]=++idx;
					}
					wrt(hs[u[i]]);
					putchar(' ');
					wrt(hs[v[i]]);
					putchar('\n');
				}
			}
		}
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}

```

---

## 作者：GTAyin (赞：0)

**写在前面：**

这是在模拟赛上最有思路的一道题，想到了正解，但没有打出来。整理思路后，有了这篇题解。

**正文：**

官方题解提出了这道题其实就是求树的直径。

为什么呢，我们可以由题目描述得知，每一个点的度小于等于二，所以这个最长的原树就是一条链。

又因为每一个点都会向外伸展出大于等于 $k$ 条边。当 $k>0$ 时，这条链的起点和终点也会向外伸出至少一条边，所以在 $k>0$ 时求的直径要减去二。有前面的推理可知，当 $k=0$ 时，两端点不会向外伸展出边，即求出的直径不用减二。

分析的差不多了。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=1e5+10;
struct node{
    int to,nxt,w;
}e[N*2];
int head[N*2],tot;
int ans;
int n,k;
int f[N*2];
void add(int a,int b,int c) {
    e[++tot].to=b;
    e[tot].nxt=head[a];
    e[tot].w=c;
    head[a]=tot;
}
void dfs(int u,int fa) {
    for(int i=head[u]; i; i=e[i].nxt) {
        int v=e[i].to;
        int w=e[i].w;
        if(v==fa)continue;
        dfs(v,u);
        ans=max(ans,f[u]+f[v]+w);
        f[u]=max(f[u],f[v]+w);
    }
}//求直径有两种方法，一种是这个dp,另外一个是两遍dfs,有兴趣的同学可以去找来看看。
int main() {
    cin>>n>>k;
    int a,b;
    for(int i=1; i<n; i++) {
        scanf("%d%d",&a,&b);
        add(a,b,1);
        add(b,a,1);
    }
    dfs(1,-1);
    int cnt=ans+1;
    if(k==0){
        cout<<cnt<<endl;
        for(int i=1;i<cnt;i++){
            cout<<i<<" "<<i+1<<endl;
        }
    }
    else{
        cout<<max(1,cnt-2)<<endl;//有一点的坑的地方，当cnt-2小于等于零的情况是不存在的，所以要和1取最大值。
        for(int i=1;i<max(1,cnt-2);i++){
            cout<<i<<" "<<i+1<<endl;
        }
    }

    return 0;
}
```

[树的直径](https://www.luogu.com.cn/problem/U81904)

完结撒花，谢谢阅读。

---


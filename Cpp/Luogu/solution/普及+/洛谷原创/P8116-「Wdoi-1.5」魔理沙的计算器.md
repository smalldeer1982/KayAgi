# 「Wdoi-1.5」魔理沙的计算器

## 题目背景

魔理沙是普通而平凡的魔法使。在解决了大大小小的异变后，她终于攒足了足够多的钱在香霖堂里购置了一台 $\verb!Carno!$ 计算器，用来计算魔女之汤各种配料的含量之比。

魔理沙早就听闻灵梦通过河童重工网络[入手了一部 $\verb!Casio!$ 计算器](https://www.luogu.com.cn/problem/P5515)，来计算神社的香火钱，却买到了假货，最多只能显示整数部分（下取整）。而魔理沙的这部可以精确到小数点后面若干位（下取整）的计算器。更高级的是，这部计算器还可以支持其他的进制，其强大的功能高出了灵梦一大截。因此作为灵梦真挚的朋友，魔理沙希望向灵梦表达真挚的遗憾之情。

正当魔理沙打算出发之时，她发现虽然 $\verb!Carno!$ 计算器不会导致一些特别大的误差，但是在计算除法时仍然会出现一定的问题。考虑将计算器的进制调整为 $10$ 进制，而计算器屏幕上最多可以显示 $5$ 位数字（小数点不计入显示位数）。比如，魔理沙希望计算 $1\div 3$ 的值，那么真正显示在屏幕上的则是：

$$
0.3333
$$

按照道理上来讲，$1\div(1\div 3)$ 结果应当等于 $3$。但出乎意料的是，当魔理沙输入 $1\div 0.3333$ 后，得到的结果却是：

$$
3.0003
$$

这当然只是一个个例。当魔理沙计算 $1\div(1\div 4)$ 时，屏幕上显示出了正确的数字。

为了防止在表达遗憾之情的时候自己的计算器也出了漏子，魔理沙希望找到有多少个数字使得计算出的结果是正确的，因此她向你求助了。

## 题目描述

魔理沙的计算器可以进行 $b$ 进制的运算，屏幕上可以显示 $k$ 个数字（不包含小数点）。进行计算后，若某个数字超出了屏幕，就会被**直接舍去**（例如 $b=10$ 时 $1\div 7=0.142857\cdots$，若屏幕大小为 $4$，那么最终显示为 $0.142$）。

魔理沙用计算器计算了 $1\div n=n'$，再计算 $1\div n'=n''$（$n'$ 和 $n''$ 均为显示在屏幕上的结果）。魔理沙希望知道，有多少个正整数 $n$ 使得 $n=n''$。你只需要输出这个答案对 $998,244,353$ 取模后的结果即可。

## 说明/提示

### 样例解释

- 对于第一组询问，符合条件的数（转换成十进制）为 $1,2,4$。
- 对于第二组询问，符合条件的数（转换成十进制）为 $1,5,25$。

### 数据范围及约定

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{subtask}&\textbf{分值} & \bm{b\le} & \bm {k\le } & \textbf{特殊性质} & \textbf{subtask 依赖} \cr\hline
1 & 20 & 10 & 7 & - &-\cr\hline
2 & 20 & 10^5 & 2 & k=2&-\cr\hline
3 & 10 & 10^5 & 3 & k=3&- \cr\hline
4 & 50& 10^5 & 500 & -&1,2,3\cr\hline
\end{array}
$$

对于 $100\%$ 的数据，满足 $1\le T\le 10$，$2\le b\le 10^5$，$1\le k\le 500$。

## 样例 #1

### 输入

```
3
4 2
5 3
12 99```

### 输出

```
3
3
19503```

# 题解

## 作者：囧仙 (赞：12)

## 题解

首先给出结论：

$$n''=n \iff n \mid b^{k-1}$$

考虑设 $n\in[b^s,b^{s+1})$，其中 $0\le s\le k-1$。同时，我们设 $n'$ 在计算器上被舍去的那部分的值为 $\Delta n$。先证明这样一个引理：

$$\Delta n\ge b^{-k+1}\cdot \frac{1}{n} \text{ 或者 } \Delta n=0$$

对于第二种情况，显然是 $n\mid b^{k-1}$；对于第一种情况，我们可以类比竖式计算。如果 $n \nmid b^{k-1}$，那么我们计算到屏幕的末尾时，必然还有一个非常小的数 $t$ 还没被除去，但是 $t\ge b^{-k+1}$。此时的 $\Delta n$ 就是 $\frac{t}{n}$，因此 $\Delta n\ge b^{-k+1}\cdot \frac{1}{n}$。换言之，由于 $1=n\cdot (n'+\Delta n)=n\cdot n'+n\cdot\Delta n$，而 $n\cdot n'<1$ 且 $n\cdot n'$ 是精确到小数点后 $k-1$ 位的（在小数点 $k$ 位往后都是 $0$），那么就有 $n\cdot\Delta n=1-n\cdot n'\ge b^{-k+1}$，因而 $\Delta n\ge b^{-k+1}\cdot\frac{1}{n}$。

---

我们对 $n$ 进行了这样的变换：

$$n\to \frac{1}{n}-\Delta n\to \frac{1}{\frac{1}{n}-\Delta n}-\Delta n'$$

最终显示在屏幕上的 $n$，它右侧最多还能显示 $k-s-1$ 位。因此，一个 $n$ 不满足条件，等价于：

$$\frac{1}{\frac{1}{n}-\Delta n}\ge n+b^{1-k+s}$$

由于 $n \mid b^{k-1}$ 时，$t=0$，因此对于 $n \mid b^{k-1}$ **必然符合题意**。下面证明所有 $n \nmid b^{k-1}$，都不符合题意。

想要证明 $n$ 不符合题意，就是要证明：

$$1\ge 1+\frac{1}{n}\cdot b^{1+s-k}-n\cdot\Delta n-\Delta n\cdot b^{1+s-k}$$

简单移项，可以得到：

$$n\cdot\Delta n+\Delta n\cdot b^{1+s-k}\ge \frac{1}{n}\cdot b^{1+s-k}$$

只要证明：

$$n\cdot\Delta n\ge \frac{1}{n} \cdot b^{1+s-k}$$

根据 $n\in[b^s,b^{s+1})$，以及我们证明的引理 $\Delta n\ge b^{-k+1}\cdot \frac{1}{n}$，就可以得证。于是结论成立。故所有 $n \nmid b^{k-1}$ 的 $n$ **都不满足条件**。

---

现在我们知道了，$n$ 符合条件当且仅当 $n\mid b^{k-1}$，所以我们只要求出 $b^{k-1}$ 的因子数即可。我们将其质因数分解：

$$
\begin{aligned}
b &=\prod p_i^{c_i} \cr
b^{k-1}&=\prod p_i^{c_i\cdot (k-1)}
\end{aligned}
$$

根据乘法原理，每个质因子的指数的取值范围是 $0\sim c_i\cdot(k-1)$ 共有 $c_i\cdot(k-1)+1$ 个。所以最终答案为：

$$\prod (c_i\cdot (k-1)+1)$$


## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MOD =998244353;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    up(1,qread(),T){
        int b=qread(),k=qread(),ans=1;
        if(k==1){puts("1");continue;}
        for(int i=2;i*i<=b;++i){
            int c=0; while(b%i==0) ++c,b/=i; ans=1ll*ans*((k-1)*c+1)%MOD;
        }
        if(b!=1) ans=1ll*ans*k%MOD; printf("%lld\n",ans);
    }
    return 0;
}

```

---

## 作者：Yusani_huh (赞：9)

题目链接：[P8116 魔理沙的计算器](https://www.luogu.com.cn/problem/P8116)

~~证明绝对感性，没有式子。~~

## 大意

给一个 $b$ 进制的计算器，但屏幕上只能显示 $k$ 位数字，求 $b$ 进制下满足 $1\div(1\div n)=n$ 的 $n$ 的个数，其中 $1\div n$ 和 $1\div(1\div n)$ 都使用计算器上显示的值。

## 题解

赛时就感觉这是个神仙思维题。

首先屏幕上只能显示有限位数字，也就说明如果 $\frac{1}{n}$ 是个无限小数是绝无可能满足 $1\div(1\div n)=n$ 的。

这个地方我们形式化描述一下，如果 $\frac{1}{n}$ 是个无限小数，设屏幕上显示的 $1\div n$ 为 $n'=0.a_1a_2\cdots a_{k-1}$，那么因为小数点后第 $k$ 位及之后被省去，$n'$ 再乘上 $n$ 得到的结果相比 $1$ 一定会在小数点后第 $k-1$ 位有缺失。

那么如果在屏幕上显示 $1\div n'=n$ 就会出现矛盾。屏幕上显示 $n$ 说明 $1\div n'$ 的结果 $n''$ 至少在小数点后第 $k-1$ 位及之前都为 $0$，而 $n'$ 小于零，$n''$ 小数点后第 $k$ 位及以后乘上 $n'$ 的贡献显然无法弥补小数点后第 $k-1$ 位的缺失。所以上面的结论成立。

举个栗子，假如拿十进制下的 $1\div 7$ 在屏幕上得到 $0.1428$，会有 $0.1428\times 7=0.9996$，在小数点后第 $4$ 位上就出现了缺失。那么我拿 $1\div 0.1428$ 就不可能在屏幕上显示 $7$（即除出来的真正结果为 $7.0000\cdots$），因为这样的话那 $0.0004$ 的差距不会被弥补。

（这个地方可能说的有点绕，但理是这么个理。）

那么范围就缩小到所有 $b$ 进制下除 $1$ 能得到有限小数的数。然而又有 $k$ 位的限制，这就要求 $\frac{1}{n}$ 的小数点后数字位数不能大于 $k-1$ 位（因为整数部分也占一位）。

设 $1\div n$ 的真实值为 $0.c_1c_2\cdots c_{k-1}$，小数部分不足 $k-1$ 位的用零补齐。自然想到将 $1$ 和 $0.c_1c_2\cdots c_{k-1}$ 同乘 $b^{k-1}$，得到 $b$ 进制下的 $100\cdots0$ 和 $\overline{c_1c_2\cdots c_{k-1}}$。

又由题，$b$ 进制下的 $\overline{c_1c_2\cdots c_{k-1}}$ 必然是 $100\cdots0$ 的一个因子，我们要求的 $n$ 的个数实际上就是满足要求的 $\overline{c_1c_2\cdots c_{k-1}}$ 的个数，也即 $100\cdots0_{[b]}$ 的因子个数。所以将 $100\cdots0_{[b]}$ 转回十进制得到 $b^{k-1}$，问题转化为求 $b^{k-1}$ 的因子个数。

这下这个题目就很数学了，直接对 $b$ 分解质因数，根据唯一分解定理的推论求因子个数即可。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define N 100003
#define LL long long
#define INF 0x3f3f3f3f
#define MOD 998244353
int t,b,k;
LL h[N];
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&b,&k);
		LL ans=1;
		int a=b,ct=0;
		for(int i=2;i*i<=b;++i)
			if(a%i==0){
				ct++;
				while(a%i==0) a/=i,h[ct]++;
				h[ct]=h[ct]*(k-1)%MOD;
			}
		if(a>1) h[++ct]=k-1;
		for(int i=1;i<=ct;++i)
			ans=ans*(h[i]+1)%MOD,h[i]=0;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：minstdfx (赞：8)

针对本题存在大量**无相关**重要结论**证明**，仅仅提供结论，甚至只是乱猜的现象，我们觉得有必要提供带有**严格证明**的题解。  
我对这篇题解中的一些问题进行了一些勘误，感谢大家的支持。  
与囧号官方题解的区别主要在核心证明，即命题**必要性的证明**。建议大家先去资瓷一下[官方题解](https://www.luogu.com.cn/blog/over-knee-socks/solution-p8116)。 

提供另一种证明方式。

首先给出结论：

$$n''=n \iff n \mid b^{k-1}$$

考虑设 $n\in[b^s,b^{s+1})$，其中 $0\le s\le k-1$。同时，我们设 $n'$ 在计算器上被舍去的那部分的值为 $\Delta n$。先证明这样一个引理：

$$\Delta n\ge b^{-k+1}\cdot \frac{1}{n} \text{ 或者 } \Delta n=0$$

对于第二种情况，显然是 $n\mid b^{k-1}$；  
对于第一种情况，已知：
$$\Delta n = \frac{1}{n}-n'>0$$
设
$$\frac{1}{n} = m \cdot \frac{1}{b^{k-1}}+\Delta n$$
其中，$m \in Z, 0 \le \Delta n < \frac{1}{b^{k-1}},n' = m \cdot \frac{1}{b^{k-1}}$  
所以 
$$1 = \frac{n \cdot m}{b^{k-1}} + n \cdot \Delta n$$
$$b^{k-1} = n \cdot m + n \cdot \Delta n \cdot b^{k-1}$$  

$$\because nm \in Z, b^{k-1} \in Z$$  
$$\therefore n \cdot \Delta n \cdot b^{k-1} \in Z$$  
$$\text{又}\because n>0, \Delta n > 0, b^{k-1} > 0$$  
$$\therefore n \cdot \Delta n \cdot b^{k-1} >0$$
$$\therefore n \cdot \Delta n \cdot b^{k-1} \ge 1$$
$$\text{即}\Delta n\ge b^{-k+1}\cdot \frac{1}{n} $$

---

我们对 $n$ 进行了这样的变换：

$$n\to \frac{1}{n}-\Delta n\to \frac{1}{\frac{1}{n}-\Delta n}-\Delta n'$$

最终显示在屏幕上的 $n$，它右侧最多还能显示 $k-s-1$ 位。因此，一个 $n$ 不满足条件，等价于：

$$\frac{1}{\frac{1}{n}-\Delta n}\ge n+b^{1-k+s}$$

由于 $n \mid b^{k-1}$ 时，$t=0$，因此对于 $n \mid b^{k-1}$ **必然符合题意**。下面证明所有 $n \nmid b^{k-1}$，都不符合题意。

想要证明 $n$ 不符合题意，就是要证明：

$$1\ge 1+\frac{1}{n}\cdot b^{1+s-k}-n\cdot\Delta n-\Delta n\cdot b^{1+s-k}$$

简单移项，可以得到：

$$n\cdot\Delta n+\Delta n\cdot b^{1+s-k}\ge \frac{1}{n}\cdot b^{1+s-k}$$

事实上，由于 $\Delta n\cdot b^{1+s-k} > 0$，因此我们只要证明：

$$n\cdot\Delta n\ge \frac{1}{n} \cdot b^{1+s-k}$$

就可以证明原命题。

其实就是要证明：

$$n^2\cdot\Delta n\ge b^{1+s-k}$$

根据 $n\in[b^s,b^{s+1})$，以及我们证明的引理 $\Delta n\ge b^{-k+1}\cdot \frac{1}{n}$，可以得到：

$$n^2\cdot\Delta n\ge n\cdot b^{-k+1}\ge b^{s-k+1}$$

于是结论成立。故所有 $n \nmid b^{k-1}$ 的 $n$ **都不满足条件**。

---

现在我们知道了，$n$ 符合条件当且仅当 $n\mid b^{k-1}$，所以我们只要求出 $b^{k-1}$ 的因子数即可。我们将其质因数分解：

$$
\begin{aligned}
b &=\prod p_i^{c_i} \cr
b^{k-1}&=\prod p_i^{c_i\cdot (k-1)}
\end{aligned}
$$

根据乘法原理，每个质因子的指数的取值范围是 $0\sim c_i\cdot(k-1)$ 共有 $c_i\cdot(k-1)+1$ 个。所以最终答案为：

$$\prod (c_i\cdot (k-1)+1)$$

这题的数据怎么做都能过吧。放一个奇怪的做法：
```
#include <bits/stdc++.h>
#include "wdoi-fastio.hpp" // 省略快读头文件
using namespace std;
const int maxn=1e7+9;
#define int long long
const int mod=998244353;
int gs[maxn],p[maxn],v[maxn],pt;
void init(int n,int k)
{
	pt=0;
	gs[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(!v[i]) // prime 
		{
			v[i]=i;
			p[++pt]=i;
			gs[i]=k;
		}
		for(int j=1;j<=pt && i*p[j]<=n;++j)
		{
			v[i*p[j]]=p[j];
			if(i%p[j]==0){
				gs[i*p[j]]=gs[i]*2+mod-gs[i/p[j]];
				gs[i*p[j]]%=mod;
				break;
			}
			gs[i*p[j]]=gs[i]*gs[p[j]]%mod;
		}
	}
} 
signed main()
{
	int n,k,t;
	fio>>t;
	while(t--)
	{
		fio>>n>>k;
		pt=0;
		memset(gs,0,sizeof(gs));
		memset(v,0,sizeof(v));
		init(n,k); 
		fio<<gs[n]<<_fios::endl;
	}
}
```

---

## 作者：SisconHL (赞：2)

**文中的 $\div$ 均为原题中的操作，不是正规除法。**

令式子为 $1\div(1\div s)$。$s\geq1$。

有 $1\div s=\dfrac{\lfloor\dfrac{b^{k-1}}{s}\rfloor}{b^{k-1}}$。

又 $1\div(1\div s)$ 得到 $s$，所以 $1\div s\in(\dfrac1{s+b^{1-k}},\dfrac1s]$。

所以 $\lfloor\dfrac{b^{k-1}}{s}\rfloor\in (\dfrac{b^{k-1}}{s+b^{1-k}},\dfrac{b^{k-1}}{s}]$。上界成立这一点是平凡的。

当 $b^{k-1}|s$，上式显然成立。下面证明这是必要的。

因为都是整数，我们考虑 $b^{k-1}$ 除以 $s$ 的余数，至少为 $1$，故有 $\lfloor \dfrac{b^{k-1}}{s}\rfloor\leq\dfrac{b^{k-1}-1}{s}$ 成立。

所以不满足 $b^{k-1}|s$ 的 $s$ 符合要求的一个必要条件为 $\dfrac{b^{k-1}}{s+b^{1-k}}<\dfrac{b^{k-1}-1}{s}$，移项易得 $s+b^{1-k}<1$，易知矛盾。

综上，我们证明了 $s$ 符合要求等价于 $b^{k-1}|s$，容易计算出符合要求的 $s$ 的个数。

---

## 作者：VinstaG173 (赞：2)

找个数学题做着玩玩。暂时只有口胡，没有代码。

以下过程是按照我的思路顺序来写的，所以不一定是最顺畅的过程，可能会出现一些“只需证”形式的东西。

首先我们要能显示 $n$，所以 $n$ 的位数不能超过 $k$。

注意到 $n$ 是正整数，如果 $n=1$ 显然 $n''=n$；

否则 $n>1$，显然 $\dfrac{1}{n}$ 整数部分为 $0$，所以我们要的事情是：
1. $n'$ 为 $\dfrac{1}{n}$ 保留 $k-1$ 位小数后的结果；
2. 由于 $n'\le\dfrac{1}{n}$，因此 $\dfrac{1}{n'} \ge n$，所以若 $n$ 是 $t$ 位数（这等价于 $b^{t-1} \le n<b^t$），那么想要 $\dfrac{1}{n'}$ 小数点后 $k-t$ 位全为 $0$。

`2.` 等价于 $\dfrac{1}{n'}-n<b^{t-k}$。对于左侧我们有 $\dfrac{1}{n'}-n=\dfrac{1-n'n}{n'}$，于是我们希望找到 $1-n'n$ 与 $b^{t-k}n'$ 的大小关系。

如果 $n'n=1$，那么 $\dfrac{1}{n}$ 是小数点后位数不超过 $k-1$ 位的有限小数，这等价于 $n \mid b^{k-1}$。这时显然有 $n''=n$。

否则 $1-n'n>0$，我们来证明 $1-n'n$ 不会太小，具体地，考虑到 $n$ 是整数，因此 $n'n$ 小数点后第 $k$ 位及以后全为 $0$，所以 $1-n'n$ 小数点后第 $k$ 位及以后全为 $0$，又其值大于 $0$，从而其值 $\ge b^{-k+1}$。

而 $n \ge b^{t-1}$，因此
$$\begin{aligned}
b^{t-k}n'&\le\dfrac{b^{t-k}}{n}\le b^{(t-k)-(t-1)}\\
&=b^{-k+1}\le1-n'n,
\end{aligned}$$
从而 $\dfrac{1}{n'}-n \ge b^{t-k}$，这告诉我们 $n'' \neq n$。

所以所求的 $n$ 即为所有 $b^{k-1}$ 的约数。

---

## 作者：你的洛 (赞：1)

 # 洛谷P8116题解
 
 [题面传送门](https://www.luogu.com.cn/problem/P8116)

 提供一个与其他题解不同的证明方法，

 首先放结论：

 $${ans = \sum_{i|b^{k-1}}1}$$

 然后就是证明了。

 由于题目给出的是 $b$ 进制，我们先将其转化为十进制：

 $$\frac{1}{n}=\sum_{i=1}^{k-1}\frac{p_i}{b^i}(p_i<b)$$

 ## 首先证明符合结论的状况

 两边同时乘上 $b^{k - 1}$

 $$\frac{b^{k-1}}{n}=\sum_{i=1}^{k-1}{p_i\cdot b^{k-1-i}}(p_i<b)$$

 由题意可知, $b,k,p_i$ 均为正整数，所以右式一定为整数，故左式也一定为整数。

 可以证明 $n|(b-1)$ 时 $\exists p$ 的构造使等式成立。

 ## 然后是不合结论的状况

 $$\frac{1}{n}=n'+\frac{p_k}{b^k}$$

 $$\frac{1}{n'}=\frac{1}{\frac{1}{n}-\frac{p_k}{b^k}}=\frac{n\cdot b^k}{b^k-n\cdot p_k}$$

 要想证明这一状况不合题目，可以构造如下的不等式：

 $$\frac{n\cdot b^k}{b^k-n\cdot p_k}> n+\frac{1}{b^{k-1}}$$

 边界状况为 $p_k=b$ 代入，并将式子变形可得如下的式子：

 $$n\cdot b^{k-1}>-n^2-\frac{1}{b^{k-1}}+1+n\cdot b^{k-1}$$

 消去同项，移项可得：

 $$n^2+\frac{n}{b^{k-1}}>1$$

 $$\because n\in\mathbb{N_+}$$

 $$\therefore\texttt{该不等式恒成立}$$

 由此，我们就可以得出最上面的结论。

 ## AC code : 

 ```cpp
//coding by cxz_0
#include <bits/stdc++.h>
#define awa cerr << "xlx is my superman!!!!!!!!!!!\n";
#define FOR(x,l,r) for(int (x) = (l); (x) <= (r); (x)++)
#define _FOR(x,l,r) for(int (x) = (r); (x) >= (l); (x)--)
#define gc getchar()
#define pb emplace_back
#define mp make_pair
#define pii pair<int, int >
#define PII pair<ll, ll >
#define fi first
#define se second
#define p_q priority_queue
// #define int ll
#define il inline
using namespace std;
typedef long long ll;

const int N = 1e5 + 5,MOD = 998244353;
int b, k, v[N], p[N], tot;
namespace cxz_0
{
    il int read(int x=0,bool f=0,char c=gc){while(!isdigit(c))f=c=='-',c=gc;while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=gc;return f?-x:x;}
    il void write(int x){if(x<0)x=-x,putchar('-');if(x>9)write(x/10);putchar(x%10+'0');}
    il ll readl(ll x=0,bool f=0,char c=gc){while(!isdigit(c))f=c=='-',c=gc;while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=gc;return f?-x:x;}
    il void writel(ll x){if(x<0)x=-x,putchar('-');if(x>9)write(x/10);putchar(x%10+'0');}
    il int qpow(int a, int n, int p){int b=1;while(n){if(n&1)b=1ll*b*a%p;a=1ll*a*a%p;n>>=1;}return b;}
    il int max(int&a,int&b){return a>b?a:b;}
    il int min(int&a,int&b){return a<b?a:b;}
    il void swap(int&a,int&b){a^=b^=a^=b;}
    il int Mod(int x){return x>MOD?Mod(x-MOD):x;}
} using namespace cxz_0;

il void pre()
{
    FOR(i, 2, N - 5)
    {
        if (!v[i]) v[i] = 1, p[++tot] = i;
        FOR(j, 1, tot)
        {
            if (i * p[j] > N - 5) break;
            v[p[j] * i] = 1;
            if (i % p[j] == 0) break;
        }
    }
}

il void solve()
{
    b = read(), k = read();
    int cnt = 0, ans = 1;
    vector<int> v;
    FOR(i, 1, tot)
    {
        if (b % p[i] == 0)
        {
            while (b % p[i] == 0) b /= p[i],cnt++;
            v.pb(cnt);
            cnt = 0;
        }
    }
    for (auto x : v) ans = 1ll * ans * (x * (k - 1) + 1ll) % MOD;
    write(ans);
    putchar(10);
}

signed main()
{
#ifndef ONLINE_JUDGE
    double start = clock();
    freopen("T1.in", "r", stdin);
    freopen("T1.out", "w", stdout);
#endif
    pre();
    int T = read();
    while (T--) solve();
#ifndef ONLINE_JUDGE
    cerr << "Time: " << 1e3 * (clock() - start) / CLOCKS_PER_SEC << " ms" << endl;
    awa
#endif
    return 0;
}

 ```

---

## 作者：August_Light (赞：1)

# P8116 「Wdoi-1.5」魔理沙的计算器 题解

[题目传送门](https://www.luogu.com.cn/problem/P8116)

## 题意简述

使用 $b$ 进制、屏幕能显示 $k$ 个数字、使用去尾法保留小数的计算器，计算了 $1\div n=n'$，再计算 $1\div n'=n''$。求有多少个正整数 $n$ 使得 $n=n''$。

答案对 $998,244,353$ 取模。

$2\le b\le 10^5$，$1\le k\le 500$。

## 解法

$\div$ 是题目中的除法。有 $1 \div n = \dfrac 1 {b^{k-1}} \left\lfloor \dfrac {b^{k-1}} n \right\rfloor$。

设 $a = b^{k-1}$：

$$\begin{aligned}
 & 1 \div (1 \div n) \\
=& \dfrac 1 a \left\lfloor \dfrac a {\frac 1 a \left\lfloor \frac a n \right\rfloor} \right\rfloor \\
=& \dfrac 1 a \left\lfloor \dfrac {a^2} {\left\lfloor \frac a n \right\rfloor} \right\rfloor
\end{aligned}$$

**问题变为解方程**：$\left\lfloor \dfrac {a^2} {\left\lfloor \frac a n \right\rfloor} \right\rfloor = a \times n$。

事情进行到这里似乎卡住了，这时不妨用 Python 打个表找下规律。

```python
a = int(input())
print(f"a={a}")
ans = 0
for n in range(1, a+1):
    if (a * a) // (a // n) == a * n:
        ans += 1
        print(f"n={n}")
print(ans)
```

当输入 $a = 114514$ 时，输出为：

```
a=114514
n=1
n=2
n=31
n=62
n=1847
n=3694
n=57257
n=114514
8
```

不难发现，方程的解似乎就是全部 $a$ 的因数，即 $n | a$。解的个数即为 $d(a) = d(b^{k-1})$。

发现这个结论之后就可以开始写代码了。

### 对结论的证明

证明命题：$\left\lfloor \dfrac {a^2} {\left\lfloor \frac a n \right\rfloor} \right\rfloor = a \times n$ 的充要条件是 $n | a$。

右推左简单。接下来证明左推右：

设 $a = kn+b$，其中 $k = \left\lfloor \dfrac a n \right\rfloor$。（$b,k$ 不是题目中的 $b,k$，撞变量名了）

把 $a = kn+b$ 代入 $\left\lfloor \dfrac {a^2} {\left\lfloor \frac a n \right\rfloor} \right\rfloor = a \times n$：

$$\left\lfloor kn^2 + 2bn + \dfrac {b^2} k \right\rfloor = kn^2 + bn$$

由于 $kn^2 + bn$ 是整数，可以把它从左边提出来：

$$\left\lfloor bn + \dfrac {b^2} k \right\rfloor = 0$$

由于 $bn$ 为自然数，要使得它为 $0$ 只能 $b = 0$。即 $n | a$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll MOD = 998'244'353;

int main() { ios::sync_with_stdio(0); cin.tie(0);
    int T; cin >> T; while (T--) {
        ll b, k; cin >> b >> k;
        ll ans = 1;
        for (ll d = 2; d * d <= b; d++)
            if (b % d == 0) {
                ll e = 0;
                while (b % d == 0) {
                    e++;
                    b /= d;
                }
                (ans *= (e * (k-1) + 1)) %= MOD;
            }
        if (b != 1)
            (ans *= k) %= MOD;
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：aimcf (赞：0)

容易发现，在计算器上能够显示的小数一定满足整数部分加上小数部分不超过 $k$ 位。

由于计算的是 $\frac{1}{\frac{1}{n}}$ 的值，所以只需要让 $\frac{1}{n}$ 的整数部分加上小数部分不超过 $k$ 位即可。

由于 $\frac{1}{n}\le 1$，所以只要 $\frac{1}{n}$ 的小数部分不超过 $k-1$ 位就可以显示。那么显示的 $\frac{1}{n}$ 的最后一位小数位的级别就是 $\frac{1}{b^{k-1}}$ 的。

所以 $n$ 只要满足是 $b^{k-1}$ 的因数，那么就是满足条件的，否则就不满足。

直接分解质因数计算即可。

---

## 作者：zct_sky (赞：0)

### Solution:
-----
首先，如果不考虑进制，什么时候 $1\div(1\div n)=n$（此处及后文中的 $\div$ 都是题目里的除法）。

显然是 $\dfrac{1}{n}$ 可以化成 $k-1$ 位小数（因为整数部分需要一位，所以是 $k-1$ 位小数）。

这里给出一种 ~~不太靠谱~~ 的证明方法：

首先，为了便于除法计算，我们将 $1$ 和 $\dfrac{1}{n}$ 都扩大 $10^{k-1}$ 倍。

那么就变成了求什么时候 $(1\times10^{k-1})\div\left\lfloor \dfrac{1}{n}\times10^{k-1}\right\rfloor=n$ 。

当 $\dfrac{1}{n}\times10^{k-1}$ 是整数时，$(1\times10^{k-1})=\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor\times n=\left(\dfrac{1}{n}\times10^{k-1}\right)\times n$，

即 $(1\times10^{k-1})\div\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor=(1\times10^{k-1})\div\left(\dfrac{1}{n}\times10^{k-1}\right)=1\div\dfrac{1}{n}=n$。

而当 $\dfrac{1}{n}\times10^{k-1}$ 不是整数时，$(1\times 10^{k-1})>\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor\times n$，所以，如果我们模拟竖式除法，那么 $(1\times10^{k-1})\div\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor$ 一定会有余数。

如果我们假设这个余数为 $x$，那么，在经过了 $k-1$ 次补零后，它成了 $x\times10^{k-1}$，一定大于 $\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor$，那么小数部分就不为 $0$ 了，于是 $(1\times10^{k-1})\div\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor>n$ 一定成立。

最后结论：当 $\dfrac{1}{n}\times10^{k-1}$ 是整数时，$(1\times 10^{k-1})\div\left\lfloor\dfrac{1}{n}\times10^{k-1}\right\rfloor=n$，即当 $\dfrac{1}{n}$ 可以化成 $k-1$ 位小数时，$1\div(1\div n)=n$。

而只有 $\dfrac{1}{n}$ 能被 $\dfrac{1}{b^{k-1}}$ 整除时，$\dfrac{1}{n}$ 可以化成 $k-1$ 位小数。

或者说 $b^{k-1}$ 能被 $n$ 整除时，$\dfrac{1}{n}$ 可以化成 $k-1$ 位小数。

所以这题就变成了求 $b^{k-1}$ 能被几个数整除（其实就是求 $b^{k-1}$ 的因数个数）。

而求一个数的因数个数可以通过分解质因数来求：

$b=a_1^{p_1}\times a_2^{p_2}\times a_3^{p_3}\dots\times a_n^{p_n}$（$a_1,a_2,a_3\dots a_n$ 都是质数）

那么 $b^{k-1}=a_1^{p_1\times(k-1)}\times a_2^{p_2\times(k-1)}\times a_3^{p_3\times(k-1)}\dots\times a_n^{p_n\times(k-1)}$

而根据乘法原理 $b^{k-1}$ 的因数个数为 $\prod\limits_{i=1}^n (p_i\times(k-1)+1)$。

### Code:
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*y;
}
ll t,b,k,ans;
const int MOD=998244353,N=1e5;
int prime[N+1],f[N+1],cnt;
void init(){
	f[1]=1;
	for(int i=2;i<=N;i++){
		if(!f[i])prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=N;j++){
			f[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
}
int main(){
	init();
	t=read();
	while(t--){
		ans=1;
		b=read(),k=read();
		for(int i=1;i<=cnt&&prime[i]*prime[i]<=b;i++){
			if(b%prime[i]==0){
				ll num=0;
				while(!(b%prime[i]))b/=prime[i],num++;
				ans=ans*(num*(k-1)%MOD+1)%MOD;
			}
		}
		if(b!=1)ans=ans*k%MOD;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：jxbe6666 (赞：0)

### 题意：
- 给定 $b$ 和 $k$，求 $b$ 进制且保留 $k$ 位的情况下，满足 $1 \div(1 \div n)=n$ 的正整数 $n$ 有多少个。

- 由于答案有多种所以要对 $998244353$ 取模。

---------
再讲正解之前我们先来讲一下前 50 分的获得方法。

我们可以来研究十进制下的情况。根据小学奥数老师的讲述，只有在最简分数下分母的质因数只有 2、5 的情况下才能化成有限小数。仔细一想便可以总结出规律，只有在分母的质因数是进制的因数时，才能化成有限小数。注意，找因数时，只要从 $1$ 到 $\sqrt{n}$ 遍历就好，在 $\sqrt{n}$ 为整数时只能加 1。

部分代码：
``` cpp
    for (int i = 0; i < n; i++)
    {
        x = read();
        y = read();
        y -= 1;
        ll ans = pow(x, y);
        for (ll j = 1; j * j <= ans; j++)
        {
        if (ans % j == 0)
            if (j * j == ans)
                l += 1;
            else
                l += 2;
        }
        cout << l << '\n';
        l = 0;
    }
```
很显然这种方法最后 50 分会 TLE

----------
## 正解：

### 思路分析
不难发现只要 $1 \div n = \frac{1}{n}$ 就行了（这里的 $\frac{1}n $ 指的是没有 $k$ 的限制的情况下）。

整数部分自然会有一位，所以其实只能有 $k-1$ 位小数。所以最小的一位权值为 $\frac{1}{b^{k-1}}$。所以无论如何这个 $b$ 进制分数分母一定是 $b^{k-1}$ 的约数。综上所述，我们只需求出 $b^{k-1}$ 的约数个数就行了。

考虑将 $b$ 质因数分解。设结果为 $a_1^{p_1} \times a_2^{p_2} \cdots a_n^{p_n}$。当 $k-1$ 次方后，所有的指数都变为了原来的 $k-1$ 倍。根据因数个数公式，就可以算出答案为 $\sum\limits_{i=1} ^n p_i \times (k-1)-1$。模拟即可。

### AC Code：
``` cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int Mod = 998244353;
const int N = 1e6 + 5;
int z[N];
int isprime(int x)//判断质数
{
    if (x < 2)
        return 0;
    for (int i = 2; i * i <= x; i++)
        if (x % i == 0)
            return 0;
    return 1;
}
signed main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int b, k;
        cin >> b >> k;
        memset(z, 0, sizeof(z));//清空
        while (b != 1)
        {
            for (int i = 2; i <= b; i++)
            {
                if (b % i == 0 && isprime(i) == 1)
                {
                    b /= i;
                    z[i]++;
                    break;
                }
            }
        }
        int ans = 1;
        for (int i = 1; i <= N; i++)
            ans = ans * (z[i] * (k - 1) + 1) % Mod;//别忘了取模
        cout << ans << '\n';
    }
    return 0;
}

```

---


# 「WHOI-2」ぽかぽかの星

## 题目背景

![](bilibili:BV16J411x7nS)

你在雪洞里喝着热可可数星星。但这次，星星换成了数列，不过聪明的你一定能数清楚数列的吧。

## 题目描述

有多少个长度为 $n$ 的**正整数**数列 $a_i$ 满足：

- $0<a_1\leq a_2\leq a_3\dots \leq a_n\leq k$。
- $\forall i\not = j,a_i+a_j\not = k+1$。

答案对 $10^9+7$ 取模。

## 说明/提示

**本题采用捆绑测试**

- $\text{subtask1(20pts)}:T=5,1\leq n,k\le5$。
- $\text{subtask2(80pts)}:$ 无特殊限制。


对于 $100\%$ 的数据，$T\leq100,1\le n,k\le 5\times 10^6,1\leq  \sum n,  \sum  k\le6\times 10^7$。



## 样例 #1

### 输入

```
3
2 2
1145 1419
19198 12321```

### 输出

```
2
66937457
949924930```

# 题解

## 作者：Otomachi_Una_ (赞：10)

这里仅介绍 $100\%$ 的方法。

考虑我们把一个有序的定长度序列 $a_i$ 转换为每个数出现的次数 $c_i$。那么我们就只用考虑第二个限制了。

考虑到 $k$ 的奇偶性对公式有影响，故分开讨论。

### 当 $\bm k$ 为偶数时，$\bm {k=2m}$.

那么 $c_i,c_{k+1-i}$ 至少有一个为 $0$。实际上，我们可以把这一些 $c_i,c_{k+1-i}$ 分为一组，一共 $m$ 组。

枚举 $m$ 组当中有不为零的组数 $i$。可以发现这样子有 $C_m^i\times C_{n-1}^{i-1}\times 2^i$。这里的三项分别表示

- 选择 $i$ 组的方案。
- 把 $n$ 个元素分配到这 $i$ 组的方案。
- 这 $m$ 组内部分配的方案。

所以答案就是 

$$\sum_{i=1}^{\min(n,m)}C_m^i\times C_{n-1}^{i-1}\times 2^i$$

### 当 $\bm k$ 为奇数时，$\bm {k=2m+1}$.


同偶数的情况，唯一不同的就是要特殊讨论 $c_{m+1}$ 处，至多为 $1$。从 $c_{m+1}=0/1$ 的角度出发同上处理可得答案。


$$\sum_{i=1}^{\min(n,m)}C_m^i\times C_{n-1}^{i-1}\times 2^i+\sum_{i=1}^{\min(n-1,m)}C_m^i\times C_{n-2}^{i-1}\times 2^i$$

---

upd (2022.7.10) 记得特判 $n/k=1$ 的情况。

---

## 作者：Alan_Zhao (赞：5)

## 题解

提供另一种推法。

对于偶数 $k$，设 $f(n,k)$ 表示此时的答案。考虑 $k$ 是奇数的情况，此时 $\frac{k+1}{2}$ 这个值至多在数列中出现一次。所以，当 $k$ 是奇数时，答案就是 $f(n,k-1)+f(n-1,k-1)$。以下只考虑 $k$ 是偶数的情况。

令 $m=\frac{k}{2}$。

对于任意的值 $x\in [1,m]$，如果 $x$ 在数列中出现，那么 $k+1-x$ 就不能在数列中出现。

所以，假如 $[1,m]$ 中有 $i$ 个数出现，那么 $[m+1,k]$ 中就至多有 $(m-i)$ 个数出现。枚举 $i,j$ 分别表示在 $[1,m],[m+1,k]$ 中出现的数的个数，用插板法得到：

$$
f(n,k)=\sum_{i=0}^m \sum_{j=0}^{m-i} \binom{m}{i}\binom{m-i}{j}\binom{n-1}{i+j-1}.
$$

根据范德蒙德卷积，对于任意整数 $s,a,b$ 和正整数 $r$，有：

$$
\begin{aligned}
	&\sum_{i} \binom{r}{a+i}\binom{s}{b+i}\\
	&=\sum_{i} \binom{r}{r-a-i}\binom{s}{b+i}\\
	&=\binom{r+s}{r-a+b}.
\end{aligned}
$$

固定 $i$，令 $(r,s,a,b)\gets (m-i,n-1,0,i-1)$，可以得到：

$$
f(n,k)=\sum_{i=0}^m \binom{m}{i}\binom{m-i+n-1}{m-1}.
$$

预处理组合数即可。**注意特判 $k=1$ 的情况。**

---

## 作者：Sellaris (赞：4)

- **第一个条件：** 首先是重要的转化，把数列转化成小于 $k$ 的数出现的次数。相当于桶的思想。又因为相邻两项可以相等，于是对数在桶里面怎么出现的进行计数。

- **第二个条件：** 考虑桶里面什么时候不满足第二个条件，容易发现对 $k$ 应该分奇偶讨论，偶数的时候桶里面最中间一项的贡献最多不超过 $1$ ，然后再对这个分类讨论。

- 具体式子在码的注释里。

- 本题还有一个关键是注意把阶乘和二的幂次都 **预处理** 掉。

- 特判掉 $n=1$ , $k=1$ 的情况。

```cpp
///*****Sellaris*****///
//#pragma once
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
#include <bits/stdc++.h>
//#include <bits/extc++.h>
using namespace std;
#define int long long 
#define endl "\n"
//using namespace __gnu_pbds;
const int maxn=5e6+10;
const int mo=1e9+7;
inline int read(){
    int ret=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
    return ret*f; //x=(x<<1)+(x<<3)+(ch^48);
}
inline int mod(int x){return x>=mo? x%mo :x;}
inline int qpow(int x,int k){
    int res=1,base=x;
    while(k){
        if(k&1) res*=base,res=mod(res);
        k>>=1; base*=base;base=mod(base);
    }return res;
}
int jc[maxn],jc_inv[maxn];
inline void preC(){
    jc[0]=jc_inv[0]=1;//组合数要考虑 n,m,n-m == 0
    for(int i=1;i<maxn;i++) jc[i]=mod(jc[i-1]*i);
    jc_inv[maxn-1]=mod(qpow(jc[maxn-1],mo-2));
    for(int i=maxn-2;i>=1;i--) jc_inv[i]=mod(jc_inv[i+1]*(i+1));
}
inline int C(int m,int n){
    return mod(mod(jc[n]*jc_inv[n-m])*jc_inv[m]);
}
int a[maxn]={0};
int n,m,k,ans;
int lg2[maxn];
inline void solve(){
	//string s;
    n=read();k=read();ans=0;
    if(n==1){
    	cout<<k<<endl;
    	return ;//包含了k==1 
	}
	if(k==1){
		cout<<0<<endl;
		return ;//不包含n==1 
	}
	if(k%2==0){
		m=k/2;//两两分组，枚举 m 组当中 **有不为零** 的组数 i。
		for(int i=1;i<=min(n,m);i++){
			ans+=mod(C(i,m)*C(i-1,n-1))*lg2[i]; //C(i-1,n-1)隔板法 
			ans=mod(ans);//(选i组的方案)*(n个元素分配到i组的方案)*(m组内部分配的方案)
		}
		cout<<ans<<endl; 
	}else{
		m=(k-1)/2;
		//TONG[m+1]==0
		for(int i=1;i<=min(n,m);i++){
			ans+=mod(C(i,m)*C(i-1,n-1))*lg2[i]; //C(i-1,n-1)隔板法 
			ans=mod(ans);//(选i组的方案)*(n个元素分配到i组的方案)*(m组内部分配的方案)
		}
		//TONG[m+1]==1
		for(int i=1;i<=min(n-1,m);i++){
			ans+=mod(C(i,m)*C(i-1,n-2))*lg2[i]; //C(i-1,n-1)隔板法 
			ans=mod(ans);//(选i组的方案)*(n个元素分配到i组的方案)*(m组内部分配的方案)
		}
		cout<<ans<<endl; 
	}
	return;
}
signed main(){
    //std::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL);
    //freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	int t=read();
	preC();
	for(int i=0;i<maxn;i++) lg2[i]=qpow(2,i);
	while(t--){
		solve();
	}
    return 0;
}




```



---

## 作者：TernaryTree (赞：4)

赛时把式子推出来了，很开心，但是忘了线性求逆元 TLE 了。

***

根据题意，对于任意 $a_i$，有 $1\le a_i\le k$。

我们建立一个长度为 $k$ 的哈希表 $b$，$b_i$ 表示 $i$ 在 $a$ 中出现的次数。

考虑分类讨论。

- ### 当 $k$ 为偶数时：

  根据题目中第二个条件，可以得到：

  因为 $a_i+a_j\ne k+1$，所以对于 $b$ 中的任意一个位置 $b_i$，与其沿中心对称的点 $b_{k-i+1}$ 两者中必然有一个为 $0$。即：

  $$b_ib_{k-i+1}=0$$

- ### 当 $k$ 为奇数时：

  设 $k=2s+1$。

  有对于 $1\le i\le s$，仍满足

  $$b_ib_{k-i+1}=0$$

  而对于中间的元素 $b_{s+1}$，仅有可能为 $0$ 或 $1$。因为当 $b_{s+1}\ge 2$ 时，说明存在超过两个 $s+1$ 元素，而任意两个 $s+1$ 相加等于 $2s+2=k+1$，不满足条件。

  这个时候，我们再进行分类讨论：

  - #### 如果 $b_{s+1}=0$：
  
  	 问题转换为，将 $n$ 分到前 $s$ 个格子，可以不分的方案数，然后因为左右两边只有一个可以放东西，所以乘上 $2^i$ 就可以了。
    
    但是，如果有一个格子没有放，那么左右交换以后实际上分法没有改变，不能算作两种情况。
    
    所以，我们枚举 $1\sim s$ 内的 $i$，表示将 $n$ 分到任意 $i$ 个格子的方案数。
    
    总方案数为：
    
    $$\sum_{i=1}^{s}C_{s}^{i}\times 2^i\times C_{n-1}^{i-1}$$
    
  - #### 如果 $b_{s+1}=1$：
  
  	 容易得到，我们只是在 $b_{s+1}$ 位置占用了一个，$n$ 相应减少 $1$ 即可。总方案数为：
     
     $$\sum_{i=1}^{s}C_{s}^{i}\times 2^i\times C_{n-2}^{i-1}$$
     
  综上，当 $k$ 为奇数时，方案数为
  
  $$\sum_{i=1}^{s}C_{s}^{i}\times 2^i\times (C_{n-1}^{i-1} + C_{n-2}^{i-1})$$
  
而对于偶数，设 $k=2s$，因为没有中间部分的额外方案数，所以总方案数为

$$\sum_{i=1}^{s}C_{s}^{i}\times 2^i\times C_{n-1}^{i-1}$$

那么，如何优化时间复杂度呢？

我们知道，$C_{n}^{m}=\dfrac{n!}{(n-m)!m!}$。

故我们先预处理 $x!\bmod p$，然后对于上式，线性求逆元即可。

这样，总时间复杂度为 $O(tn)$。

式子给的这么清楚了，代码就不附了吧。

---

## 作者：KXY_Moon (赞：2)

## 解法

递推 + 分类讨论。

类似桶我们设 $F_{i}$ 为 $i$ 这个数在 $a$ 中出现的次数，答案为 $Ans$ 有：

分类讨论：

设 $f(x,y)=\min(x,y)$。

 - 如果 $n=1$，有：

   $Ans=k\,\,\,\,(n=1)$

 - 如果 $k$ 是奇数，有：

   $F_{\left\lceil\frac{k}{2}\right\rceil}<=1$

   $\begin{cases}Ans=\sum^{f(n,\left\lceil\frac{k}{2}\right\rceil)}\limits_{i=1}\dbinom{i}{\left\lceil\frac{k}{2}\right\rceil}\dbinom{i-1}{n-1}\,\,(2^i)&F_{\left\lceil\frac{k}{2}\right\rceil}=0\\Ans=\sum^{f(n-1,\left\lceil\frac{k}{2}\right\rceil)}\limits_{i=1}\dbinom{i}{\left\lceil\frac{k}{2}\right\rceil}\dbinom{i-1}{n-2}\,\,(2^i)&F_{\left\lceil\frac{k}{2}\right\rceil}=1\end{cases}$

 - 如果 $k$ 是偶数，有：

   $Ans=\sum^{f(n,\left\lceil\frac{k}{2}\right\rceil)}\limits_{i=1}\dbinom{i}{\left\lceil\frac{k}{2}\right\rceil}\dbinom{i-1}{n-1}\,\,(2^i)$



则最终答案为：

$\begin{cases}Ans=k&(n=1)\\Ans=\sum^{f(n-1,\left\lceil\frac{k}{2}\right\rceil)}\limits_{i=1}\dbinom{i}{\left\lceil\frac{k}{2}\right\rceil}\dbinom{i-1}{n-2}\,\,(2^i)+\sum^{f(n,\left\lceil\frac{k}{2}\right\rceil)}\limits_{i=1}\dbinom{i}{\left\lceil\frac{k}{2}\right\rceil}\dbinom{i-1}{n-1}\,\,(2^i)&(n\not=1)\end{cases}$


式子全都给出来了，不贴代码了。

**自己动手，丰衣足食！**

End.

---

## 作者：DFM_O (赞：1)

## [P8432 题目](https://www.luogu.com.cn/problem/P8432)

### 解题思路
定义 $p_i$ 为 $i$ 在序列 $a$ 中的出现次数，由于 $k\bmod2=1$ 的情况比 $k\bmod2=0$ 特殊，所以我们先考虑 $k\bmod2=0$ 的情况。

若 $k\bmod2=0$，因为 $a_i+a_j=k+1$，所以若 $p_{i}$ 不为 $0$，那么 $p_{k+1-i}$ 就必须为 $0$。

如果我们将每个 $i$ 和 $k+1-i$ 分为一组，不难发现一共有 $\frac{k}{2}$ 组，尝试枚举 $p_i+p_{k+1-i}>0$ 的个数，有 $C_\frac{k}{2}^i$ 种选择，再把 $n$ 个数分别分配给这选出的 $i$ 组数中，有 $C_{n-1}^
{i-1}$ 种选择，每组中又有 $p_i>0$ 和 $+p_{k+1-i}>0$ 两种情况，综上，答案为：

$$\sum_{i=1}^{\min(n,\frac{k}{2})}C_\frac{k}{2}^i\times C_{n-1}^
{i-1}\times2^i$$

若 $k\bmod2=1$，
这种情况特殊在于 $p_{\lfloor\frac{k}{2}\rfloor+1}$ 必须不大于 $1$，那么就有 $2$ 种情况：$p_{\lfloor\frac{k}{2}\rfloor+1}=0$ 和 $p_{\lfloor\frac{k}{2}\rfloor+1}=1$。

如果 $p_{\lfloor\frac{k}{2}\rfloor+1}=0$，则这一部分的答案与 $k\bmod2=0$ 的情况相同：

$$\sum_{i=1}^{\min(n,\lfloor\frac{k}{2}\rfloor)}C_{\lfloor\frac{k}{2}\rfloor}^i\times C_{n-1}^
{i-1}\times2^i$$

如果 $p_{\lfloor\frac{k}{2}\rfloor+1}=1$，则相当于 $n$ 减少了 $1$，这一部分的答案为：

$$\sum_{i=1}^{\min(n-1,\lfloor\frac{k}{2}\rfloor)}C_{\lfloor\frac{k}{2}\rfloor}^i\times C_{n-2}^
{i-1}\times2^i$$

将这两部分合起来就是最终的答案了，为：

$$\sum_{i=1}^{\min(n,\lfloor\frac{k}{2}\rfloor)}C_{\lfloor\frac{k}{2}\rfloor}^i\times C_{n-1}^
{i-1}\times2^i+\sum_{i=1}^{\min(n-1,\lfloor\frac{k}{2}\rfloor)}C_{\lfloor\frac{k}{2}\rfloor}^i\times C_{n-2}^
{i-1}\times2^i$$

别忘了特判 $n=1$ 的情况。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const long long p=1e9+7;
int jc[5000001],jcp[5000001],p2[5000001];
inline long long poww(long long a,long long b)
{
    long long ss=1;
    while(b)
    {
        if(b&1)
            ss=ss*a%p;
        a=a*a%p;
        b>>=1;  
    }
    return ss;
}
signed main()
{
	ios::sync_with_stdio(false);
	jc[0]=1,p2[0]=1,jcp[0]=1;
	for(int i=1;i<=5000000;i++)
		jc[i]=jc[i-1]*i%p,jcp[i]=poww(jc[i],p-2),p2[i]=p2[i-1]*2%p;
	int t;
	cin>>t;
	while(t--)
	{
		int n,k,s=0;
		cin>>n>>k;
		if(n==1)
		{
			cout<<k<<"\n";
			continue;
		}
		int kk=k/2;
		int c=min(n,kk);
		for(int i=1;i<=c;i++)
		{
			int a=jcp[i]*jcp[kk-i]%p*jc[kk]%p,b=jc[n-1]*jcp[n-i]%p*jcp[i-1]%p;
			if(i-1==0)
				b=1;
			s=(s+a*b%p*p2[i]%p)%p;
		}
		if(k%2==0)
		{
			cout<<s<<"\n";
			continue;
		}
		c=min(n-1,kk);
		for(int i=1;i<=c;i++)
		{
			int a=jc[kk]*jcp[kk-i]%p*jcp[i]%p,b=jc[n-2]*jcp[n-1-i]%p*jcp[i-1]%p;
			if(i-1==0)
				b=1;
			s=(s+a*b%p*p2[i]%p)%p;
		}
		cout<<s<<"\n";		
	}
	return 0;
}
/*
hack:

Right Answer:

Wrong Answer:

*/
```

---


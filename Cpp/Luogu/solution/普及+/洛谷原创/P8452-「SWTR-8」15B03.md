# 「SWTR-8」15B03

## 题目背景

15B03 获得了 ION2064 的承办权。

## 题目描述

15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。

根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 **公共点**。严格定义两张桌子 $(i, j)$ 和 $(i', j')$ 相邻当且仅当 $|i - i'|\leq 1$ 且 $|j - j'|\leq 1$。

布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。

小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 **欧几里得** 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。

平行时空中 15B03 的规模不尽相同：多组测试数据。

**请选手认真阅读本题的评分方式。**

## 说明/提示

**「样例解释」**

对于第一组询问，选择 $(1, 1), (1, 3), (3, 1)$ 和 $(3, 3)$ 最优。撤去了 $3\times 3 - 4 = 5$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{2 ^ 2 + 2 ^ 2} = 2\sqrt 2$，因此第二问答案为 $8\sqrt 2$。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/y8fi4qhr.png)

对于第二组询问，选择 $(1, 1)$ 和 $(2, 4)$ 最优。撤去了 $2\times 4 - 2 = 6$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{1 ^ 2 + 3 ^ 2} = \sqrt {10}$，因此第二问答案为 $2\sqrt {10}$。

如果选择 $(1, 1)$ 和 $(2, 3)$，则第二问答案为 $2\sqrt 5$，不优。

**「评分方式」**

对于每组测试数据：

- 若你第一问的答案错误，得 0 分。
- 否则，若你第二问的答案错误，得 0.8 分。
- 否则，得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，**若你输出的格式错误，得 0 分**。因此，如果你只希望获得第一问的分数，请在第二问输出任意合理范围内的实数。

**「数据范围与约定」**

- 测试点 #1（15 points）：$n, m$ 均为奇数。
- 测试点 #2（20 points）：$n = 1$。
- 测试点 #3（25 points）：$n = 2$。
- 测试点 #4（30 points）：$n$ 为奇数。
- 测试点 #5（10 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 57$。
- $1\leq n, m\leq 1064$。

**「帮助与提示」**

- 你可以使用 `cmath` 中的 `sqrt(x)` 函数计算 $x$ 的平方根。它返回 `double` 类型的值。`sqrtl(x)` 精度更高，它返回 `long double` 类型的值。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) A
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
3 3
2 4
15 57
1064 822```

### 输出

```
5 11.313708499
6 6.324555320
623 10206.135788972
655956 222400384.677931725
```

# 题解

## 作者：iiiiiyang (赞：15)

# 题解：【SWTR-8】15B03

[题目链接](https://www.luogu.com.cn/problem/P8452)

### 前言

本篇题解大量配图！

作为一道非常好的有思维深度的题，必须写篇题解记录一下。

谨以此篇献给我的第一道构造题。

### 第一问（80 pts）

求需要撤去多少张桌子。

将问题转化成最多能放多少张桌子，然后用总数减去即可。

由于两张桌子不相邻需要保证对于 $ \forall (i,j) $ 满足 $ \vert i-i' \vert \le 1$ 且 $ \vert j-j' \vert \le 1$，所以当我们摆下一张桌子，下一张桌子一定跟这张桌子隔了一行或者一列。

当行（列）为偶数时，可以发现摆放的时候桌子的数量和比它少一行（列）的情况是相等的，为了计算方便可以直接去掉那一行（列），然后再下一问的时候加回来即可。

因此我们可以得出公式：
$$
Num_{can}=
\begin{cases}
(n/2+1) \times (m/2+1) \quad (n \bmod 2=1 \quad m \bmod 2=1) \\
(n/2+1) \times ((m-1)/2+1) \quad (n \bmod 2=0 \quad m \bmod 2=1) \\
((n-1)/2+1) \times (m/2+1) \quad (n \bmod 2=1 \quad m \bmod 2=0) \\
((n-1)/2+1) \times ((m-1)/2+1) \quad (n \bmod 2=0 \quad m \bmod 2=0) \\
\end{cases}
$$
$$
Ans=Num_{all} - Num_{can}=n \times m - Num_{can}
$$

$Code$ 
```cpp
	bool p=1,q=1;
	cin>>n>>m;
	r=n*m;
	if(n%2==0) n--,p=0;
	if(m%2==0) m--,q=0;
	r-=(n/2+1)*(m/2+1);
	cout<<r<<" ";
```

### 第二问（20 pts）

#### 性质一 （？ pts）

这个性质虽然没有 sub 单独列出来，但是在测试点里面存在。

考虑只有一张桌子的情况，显然这时距离应该为 $0$。

$Code$ 
```cpp
	if(n*m-r==1) {cout<<"0.000000000"<<endl; continue;}
```

#### 性质二 n=1 （4 pts）

依然分奇偶讨论。
当 m 为奇数时，观察下图：
[![vkPgJS.png](https://s1.ax1x.com/2022/07/31/vkPgJS.png)](https://imgtu.com/i/vkPgJS)

可以发现，当摆放的桌子为偶数个时，我们将他们对半分开，左半部分的到最右一个端点为最远距离，右半部分的到最左一个端点为最远距离；而且可以发现，对称的两张桌子到最远端点的距离都相等。当摆放的桌子为奇数个时，最中间的这张桌子到两端距离自然相等，在多算上即可。

当 m 为偶数时，观察下图：
[![vAc4ET.png](https://s1.ax1x.com/2022/08/01/vAc4ET.png)](https://imgtu.com/i/vAc4ET)

绿色表示放在这两个地方都可以。

可以发现，无论摆放的桌子是奇数个还是偶数个，它们的摆放距离规律都跟奇数个类似。只不过**当桌子越过中间的对称轴时，我们需要先再跳一个格子，然后再隔一个摆一张**。

因此我们可以将这个长条折半，只算一半的距离最后乘二即可。

$Code$
```cpp
//q是上面判断m奇偶性的
if(n==1&&(q)) 
{
	for(int i=0;i<(m+1)/2/2;i++)
		ans+=(m-2*i);
	ans*=2;
	if((m/2)%2==0) ans=ans+m-(m-1)/2;
	cout<<fixed<<setprecision(9)<<ans<<endl; 
}
else if(n==1&&(!q)) 
{
	for(int i=0;i<=m/4;i++)
		ans+=(m-2*i);
	ans*=2;
	if((m/2)%2==1) ans=ans+(m+2)/2;
	cout<<fixed<<setprecision(9)<<ans<<endl; 
}
```

#### 性质三 n 和 m 都是奇数 （3 pts）

可以发现，这个性质把 n 从 1 延伸到了更多行，上一个性质中是 m 为偶数的情况较难处理，而这个性质简单在 m 只会是奇数。

我们在上个性质中发现了行为 1 时列的性质，那行会不会具有同样的性质呢？

观察下图：
[![vAgdz9.png](https://s1.ax1x.com/2022/08/01/vAgdz9.png)](https://imgtu.com/i/vAgdz9)

蓝色的箭头是选这个距离也可以，是一样长的。

推荐再配合题目样例一中的图共同食用。

可以发现对于任意一张桌子，它们的最远距离是到和它们相对的角上去。

无独有偶，无论行还是列，关于行、列中线对称的桌子最远距离都是相等的。比如上图中，从行来看，$(1,1)$ 和 $(5,1)$，$(1,3)$ 和 $(5,3)$，$(1,5)$ 和 $(5,5)$  是对称的；从列来看，$(1,1)$ 和 $(1,5)$，$(3,1)$ 和 $(3,5)$，$(5,1)$ 和 $(5,5)$ 是对称的。

因此我们可以把这个方形分成四等份，只算其中一份就行。

#### 无特殊性质 （20 pts）

既然找到了行列都为奇数的规律，不妨大胆猜想，偶数的时候行列的规律也是相同的，这当然是正确的。

计算的时候，暴力计算每一张桌子的最远距离，当跨过行或列的对称轴是将它统一对称过来，特殊的，当行或列为偶数时，跨过对称轴行或列还要额外加一。

时间复杂度 $O(n^2)$。

比赛没有写出只算四分之一个矩形的程序，~~喜提最裂解~~，但是我这个方法比较好理解，也比较好写，最后奉上比赛时的代码。

$Code$
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll s,t,n,m,r;
int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>s>>t;
	for(int i=1;i<=t;i++)
	{
		bool p=1,q=1;
		cin>>n>>m;
		r=n*m;
		if(n%2==0) n--,p=0;
		if(m%2==0) m--,q=0;
		r-=(n/2+1)*(m/2+1);
		cout<<r<<" ";		
		if(p==0) n++;
		if(q==0) m++;
		if(n*m-r==1) {cout<<"0.000000000"<<endl; continue;}
		long double ans=0.0;
		long long k=1,j=1;
		p=1,q=1;
		for(k=1;k<=n;k+=2)
		{
			q=1;
			for(j=1;j<=m;j+=2)
			{
				if(m%2==0&&j>(m/2)&&(q)) j++,q=0;
				long long x,y;
				if(k<=(n+1)/2) x=k;
				else x=n-k+1;
				if(j<=(m+1)/2) y=j;
				else y=m-j+1;
//				cout<<x<<" "<<y<<"     ";
				ans+=sqrtl(((long double)((n-x)*(n-x))+((long double)((m-y)*(m-y)))));
//				cout<<" "<<ans<<"      ";
			}
			if(n%2==0&&k+2>=(n/2)&&(p)) k++,p=0;
		}
		cout<<fixed<<setprecision(9)<<ans<<endl; 
	}
	return (0-0);  
}
```

---

## 作者：封禁用户 (赞：8)

为了回报 Alex_Wei 神犇的私信回复之恩，蒟蒻特地 AC 此题写下这篇题解。

## 题意简述

给你一个 $n \times m$ 的网格，要求撤去最少的椅子使得任意两条桌子没有公共点（一张桌子的左上，左下，右上，右下不能有其他桌子）。

在此基础上最大化剩余每张桌子到距离它最远的桌子的距离之和，这里的距离指 **欧几里得距离** ，即 $(x, y)$ ，  $(x_2, y_2)$ 的距离为 $\sqrt{(x - x_2)^2 + (y - y_2)^2}$ 。

注意： **第一小问答对给80pts，第二小问答对给100pts** 。

## 题目分析

### 80pts

这一题实际上样例的图片已经提示的够清楚了，显然，横纵轴隔一个放一个，是 **拿到80pts** 的最优解。

即：

![](https://cdn.luogu.com.cn/upload/image_hosting/zhkb01ks.png)

那么我们怎么算出答案呢？直接计算虽然可行但是太麻烦，我们可以正难则反，使用总数减去桌子数量，就是答案。

总数自然就是 $n * m$，桌子数量如何计算？

我们通过观察，发现桌子一共有 $\lfloor \frac{n + 1}{2} \rfloor$ 行， $\lfloor \frac{m + 1}{2} \rfloor$ 列，所以桌子的数量即为 $\lfloor \frac{n + 1}{2} \rfloor \times \lfloor \frac{m + 1}{2} \rfloor$ 。

所以答案即为 $n \times m - \lfloor \frac{n + 1}{2} \rfloor \times \lfloor \frac{m + 1}{2} \rfloor$ 。

代码就很好写了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int s, t;
	scanf("%d%d", &s, &t);
	while (t--) {
		int n, m;
		scanf("%d%d", &n, &m);
		printf("%d 114514.0\n", n * m - ((n + 1) / 2) * ((m + 1) / 2));
	}
	return 0;
}
```

### 100pts

显然每张桌子距离四个角（左上，右上，左下，走下）的桌子是最长的，我们把4个距离算一遍取最大值，最后累计结果输出即可。

有几个坑点需要注意：

1. 特判对于只能放一张桌子的情况（ $n < 3, m < 3$ ），输出0。

2. 显然我们要让桌子们分隔的越远越好，当行数为偶数且当前桌子行数过半，桌子的行数需要+1（往下挪一格）；当列数为偶数且当前桌子列数过半，桌子的列数需要+1（往右挪一格）。

为什么必须调整桌子的位置呢？我们看 $n = 8, m = 8$ 的情况。

没有调整的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/1howronb.png)

我们可以把这些桌子分成 4 个区域：

![](https://cdn.luogu.com.cn/upload/image_hosting/qx60dvtq.png)

我们可以发现，

黄色区域里的桌子距离右下角的桌子最远。

红色区域里的桌子距离左下角的桌子最远。

橙色区域里的桌子距离右上角的桌子最远。

绿色区域里的桌子距离左上角的桌子最远。

那么我们想要优化桌子的摆放，就要从上述 4 条结论下手。

我们想要优化黄色区域的和？那么我们就需要想办法把右下角的桌子移动。我们发现刚好右下角多出来了一行一列的空格，我们就可以把绿色区域往右下角挪一格。

红色和橙色同理，它们互相距离左下角、右上角最远，所以红色区域往左上角挪一格，橙色区域往右下角挪一格。

调整后的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/r0p6yh7d.png)

因为黄色区域已经定格，所以无需调整。

理清了思路，其实代码很简单：

```cpp
#include <bits/stdc++.h>
using namespace std; 

int main() {
	int s, t;
	scanf("%d%d", &s, &t);
	while (t--) {
		int n, m;
		scanf("%d%d", &n, &m);
		
		/*---------------80 pts---------------*/
		// n * m：总数
		// ((n + 1) / 2) * ((m + 1) / 2)：桌子数量
		// 两者相减，即为拿走的桌子数量 
		printf("%d ", n * m - ((n + 1) / 2) * ((m + 1) / 2));
		
		/*---------------100 pts---------------*/
		
		// 特判：只有一张桌子时输出0.0 
		if (n < 3 && m < 3) {
			puts("0.0");
			continue;
		}
		
		double sum = 0.0;
		for (int i = 1; i <= n; i += 2) {
			for (int j = 1; j <= m; j += 2) {
				int I = i, J = j;
				if (n % 2 == 0 && i > n / 2) I++;  // 行调整
				if (m % 2 == 0 && j > m / 2) J++;  // 列调整
				double dist = 0.0;
				// 每一个点考虑四个角与它的距离，取最大值。
				// hypot(a - b, c - d) = sqrt((a - b) * (a - b) + (c - d) * (c - d)) 
				// 左上：(1, 1)
				dist = max(dist, hypot(I - 1, J - 1));
				// 右上：(1, m)
				dist = max(dist, hypot(I - 1, J - m));
				// 左下：(n, 1)
				dist = max(dist, hypot(I - n, J - 1));
				// 右下：(n, m) 
				dist = max(dist, hypot(I - n, J - m));
				// 答案统计 
				sum += dist; 
			}
		}
		printf("%.9f\n", sum);
	}
	return 0;
}
```

这就是最终的 AC 代码了。同时赞美良心出题人，第一问就能 ~~骗~~ 拿到 80 分。

---

## 作者：Dregen_Yor (赞：2)

# 题目简述

- 第一问：给定一个大小为 $n\times m$ 的网格，每个网格上有一张桌子，求最少去掉多少张桌子才能满足 $\forall (i,j) $,$ (i', j'),|i - i'|\leq 1$ 且 $|j - j'|\leq 1$。

- 第二问：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指**欧几里得**距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。

# 题目分析
为了使撤去桌子数量最少，我们可以考虑让第一张桌子放在左上角的位置，之后向右每隔一个空放一个桌子，向下每隔一个空放置一个桌子，即从 $(1,1)$ 出发，如果 $(i,j)$ 上存在一张桌子，那么在 $(i+2,j)$ 和 $(i,j+2)$ 上放置一张桌子。我们可以看成**一个桌子在X轴或Y轴方向上占两个空**，这样算出每行最多放置的桌子数量和每列最多放置的桌子数量，**相乘即可得到剩余桌子的最大数量**，再减去总的数量即可得到去掉的桌子的数量。

即 $n\times m-\left\lceil\dfrac{n}{2}\right\rceil \times\left\lceil\dfrac{m}{2}\right\rceil$。
# 代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int s, t, n, m;

int main() {
	scanf("%d", &s);
	scanf("%d", &t);
	while (t--) {
		scanf("%d%d", &n, &m);
		int x = n >> 1, y = m >> 1;//位运算，n>>1=n/2。
		if (n & 1) {
			x++;// 如果是奇数，在另一端还能再放置一张桌子
		}
		if (m & 1) {
			y++;
		}
		printf("%d %0.2Lf\n", n * m - x * y, (long double)rand());
	}
	return 0;
}
```
这样80分就到手了。
# 100分做法
第二问如果按照上面的做法的话会被样例中第二组数据卡掉，因为按上面的思路的话位于$(1,1)$ 和 $(1,3)$ 上的桌子会被留下但最优的情况应该是留下 $(1,1)$ 和 $(2,4)$ 上的桌子。

所以我们可以考虑利用 BFS 的思想枚举每一张桌子，首先在队列中加入位于 $(1,1)$ 和 $(n,m)$ 上的桌子，同时**用一个数组把位于桌子和桌子周围的格子标记** 如果 $(n,1)$ 和 $(1,m)$ 没有被标记也把这两个位置加入队列，之后在进行BFS的时候对于每个在队列中的点 $(i,j)$，遍历一遍位于     $(i+2,j)$,$(i-2,j)$,$(i,j+2)$,$(i,j-2)$ 上的点，如果没有被标记，就把对应的点加入队列，**加入队列的同时把它周围的所有点进行标记**。

对于统计答案，可以考虑在遍历到某个点时，根据贪心的思想，**计算这个点到四个顶点的最大值**，当左下角或右上角没有桌子的时候，易证离该桌子最远的桌子一定位于左上角或者右下角。

# 特殊情况
当剩余桌子数量为 $1$ 时，直接输出 $0$，然后进入下一层循环就好了。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int s, t, n, m;

int px[4] = {2, -2, 0, 0};

int py[4] = {0, 0, 2, -2};
long double ans = 0;
vector <int> xs, ys;
bool v[1067][1067];
queue <int> xq, yq;

long double max(long double a, long double b, long double c, long double d) {
	long double res = a;
	if (b > res) {
		res = b;
	}
	if (c > res) {
		res = c;
	}
	if (d > res) {
		res = d;
	}
	return res;
}

int main() {
	scanf("%d", &s);
	scanf("%d", &t);
	while (t--) {
		scanf("%d%d", &n, &m);
		ans = 0.0;
		memset(v, 0, sizeof(v));
		int _x = n >> 1, _y = m >> 1;
		if (n & 1) {
			_x++;
		}
		if (m & 1) {
			_y++;
		}
		printf("%d ", n * m - _x * _y);
		if (_x * _y == 1) {
			printf("0.000000000\n");
			continue;
		}
		v[1][1] = 1;
		v[n][m] = 1;
		xq.push(1), yq.push(1);
		xq.push(n), yq.push(m);
		v[2][1] = v[1][2] = v[2][2] = 1;
		v[n][m - 1] = v[n - 1][m] = v[n - 1][m - 1] = 1;
		if (!v[1][m]) {
			xq.push(1), yq.push(m);
			v[1][m] = v[2][m] = v[1][m - 1] = v[2][m - 1] = 1;
		}
		if (!v[n][1]) {
			xq.push(n), yq.push(1);
			v[n][1] = v[n][2] = v[n - 1][2] = v[n - 1][1] = 1;
		}
		while (!xq.empty()) {
			int x = xq.front(), y = yq.front();
			xq.pop(), yq.pop();
			ans += (long double)max(sqrtl(abs(x - 1) * abs(x - 1) + abs(y - 1) * abs(y - 1)),
			                        sqrtl(abs(x - n) * abs(x - n) + abs(y - 1) * abs(y - 1)), sqrtl(abs(x - 1) * abs(x - 1) + abs(y - m) * abs(y - m)),
			                        sqrtl(abs(x - n) * abs(x - n) + abs(y - m) * abs(y - m)));

			for (int i = 0; i < 4; i++) {
				int nx = x + px[i], ny = y + py[i];
				if ( nx > 0 && nx <= n && ny > 0 && ny <= m && !v[nx][ny]) {
					v[nx][ny] = v[nx + 1][ny] = v[nx - 1][ny] = v[nx][ny + 1] = v[nx][ny - 1] = v[nx + 1][ny + 1] = v[nx + 1][ny - 1] = 1;
					v[nx - 1][ny + 1] = v[nx - 1][ny - 1] = 1;
					xq.push(nx), yq.push(ny);
				}
			}
		}
		printf("%0.9Lf\n", ans);
	}
	return 0;
}

```


---

## 作者：starrylasky (赞：2)

[博客食用更佳](https://www.cnblogs.com/hhhsky001/articles/16535357.html)

# Solution

## 第一问

很显然，贪心，每两行选其中一行，每两个数选其中一个，就是 $n\cdot m-\frac {n+1}2\cdot\frac {m+1} 2$ 。

## 第二问

还是贪心，留下的每个点尽量远离他的最远点对。

显然，对于 $(x,y)$ 的最远点对一定是 $(1,1),(1,m),(n,1),(n,m)$ 中的一个。

所以首先考虑将这四个角保留。

剩下点对的又分为 $4$ 种。

* $(x,y)\{x \in [1,(n+1)/2],y \in [1,(m+1)/2] \}$ 这一类的最远点对是 $(n,m)$ 。

* $(x,y)\{x \in [(n+1)/2,n],y \in [1,(m+1]/2] \}$ 这一类的最远点对是 $(1,m)$ 。

* $(x,y)\{x \in [1,(n+1)/2],y \in [(m+1]/2,m] \}$ 这一类的最远点对是 $(n,1)$ 。

* $(x,y)\{x \in [(n+1)/2,n],y \in [(m+1]/2,m] \}$ 这一类的最远点对是 $(n,m)$ 。

所以分别按照这四种情况进行构造。

### 特殊情况

* $n \leq 2,m \leq 2$ 这种情况是没法保留的。所以答案为 $0$ 。

* $n=2$ 时，按照原来的思路就只能构造一行，是不符合最优。所以对于 $y \leq (m+1)/2$ 保留在第一行，剩下的保留在第二行。

```cpp
//#pragma GCC optimize("Ofast")
//#pragma GCC optimize("inline")
#include<bits/stdc++.h>
#define re register
#define fep(i,l,r) for(re int i=l;i<=r;++i)
#define For(i,u) for(re int i=head[u];i;i=e[i].nxt)
#define feb(i,r,l) for(re int i=r;i>=l;--i)
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)
#define LL long long
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
//#define int long long
#define pr pair<int,int>
#define mpr make_pair
using namespace std;

const int N = 2000+5,M = 10,mod = 1e9+7;
int n,m; bool vis[N][N];

inline int read() { int s=0,w=1; char ch=getchar(); while(!(ch<='9'&&ch>='0')) {if(ch=='-') w=-1; ch=getchar();} while(ch<='9'&&ch>='0') {s=(s<<1)+(s<<3)+ch-'0'; ch=getchar();} return s*w; }
inline void write(int x) { if(x>=10) write(x/10); putchar(x%10+'0'); }
inline void print(int x,char ch) { if(x<0) putchar('-'),x=~(x-1); write(x); putchar(ch);}
inline double get(int x1,int y1,int x2,int y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}

inline void init(int x)
{
	int now=1;
	while(now<=(m+1)/2) vis[x][now]=true,now+=2;
	feb(i,m,now) vis[x][i--]=true;
}

inline double solve()
{
	double ans=0; if(n<=2&&m<=2) return 0;
	fep(i,1,n) fep(j,1,m) vis[i][j]=false;
	if(n!=2)
	{
		int now=1;
		while(now<=(n+1)/2) init(now),now+=2;
		feb(i,n,now) init(i--);
	}
	else
	{
		int now=1;
		while(now<=(m+1)/2) vis[1][now]=true,now+=2;
		feb(i,m,now) vis[2][i--]=true;
	}
	fep(i,1,n)
	{
		fep(j,1,m) if(vis[i][j])
		{
		//	cout<<i<<" "<<j<<endl;
			if(n!=2) ans+=max(max(get(i,j,1,1),get(i,j,1,m)),max(get(i,j,n,1),get(i,j,n,m)));
			else ans+=max(get(i,j,1,1),get(i,j,2,m));
		}
	}
	return ans;
}

signed main()
{
	int type=read(),_T=read();
	while(_T--)
	{
		n=read(),m=read();
		print(n*m-((n+1)/2)*((m+1)/2),' ');
		printf("%.20lf\n",solve());
	}
	return 0;
}
```

---

## 作者：Alex_Wei (赞：2)

> [P8452 「SWTR-8」15B03](https://www.luogu.com.cn/problem/P8452)

### 题目描述

15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。

根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 **公共点**。严格定义两张桌子 $(i, j)$ 和 $(i', j')$ 相邻当且仅当 $|i - i'|\leq 1$ 且 $|j - j'|\leq 1$。

布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。

小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 **欧几里得** 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。

平行时空中 15B03 的规模不尽相同：多组测试数据。

### 数据范围

- 测试点 #1（15 points）：$n, m$ 均为奇数。
- 测试点 #2（20 points）：$n = 1$。
- 测试点 #3（25 points）：$n = 2$。
- 测试点 #4（30 points）：$n$ 为奇数。依赖测试点 #1，#2。
- 测试点 #5（10 points）：无特殊限制。依赖测试点 #3，#4。

对于 $100\%$ 的数据：

- $1\leq T\leq 57$。
- $1\leq n, m\leq 1064$。

### 解法

第一问的答案是 $\left\lceil \dfrac {n + 1} 2 \right\rceil\left\lceil \dfrac {m + 1} 2 \right\rceil$。选择奇数行和奇数列的所有交点，可以使得每个 $2\times 2$ 的小正方形 $(2k - 1 / 2k, 2k - 1 / 2k)$ 都存在一个格子被选。当 $n$ 或 $m$ 是奇数时，边界处小正方形不满。这种讨论是平凡的。

这样的构造是上界，因为每个小正方形至多选出一个格子。

对于第二问，我们有如下构造：若横坐标为奇数则横坐标固定，若为偶数则当 $\leq \dfrac n 2$ 时选奇数行，否则选偶数行。对于纵坐标同理。这样，四个角均被占用，并且每个位置都取到了它所能贡献的最大值。证明方法是观察到每个 $2\times 2$ 的小正方形 $(2k - 1 / 2k, 2k - 1 / 2k)$ 当中只能恰好放一个，而恰好放的这一个取到了贡献的最大值，具体证明细节略去。

需要特判 $n \leq 2$ 或 $m \leq 2$ 的情况。

根据构造算答案即可，时间复杂度 $\mathcal{O}(nm)$。

据验题人反应，第二问难度较大。我们给第一问 $80$ 分以达到送分的目的。

### 参考代码

```cpp
#include <bits/stdc++.h>
#include <quadmath.h>
using namespace std;
bool Mbe;
bool Med;
int main() {
  fprintf(stderr, "%.3lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("0.in", "r", stdin);
  freopen("0.out", "w", stdout);
#endif
  int S, T;
  cin >> S >> T;
  while(T--) {
    int n, m;
    double ans = 0;
    cin >> n >> m;
    cout << n * m - (n + 1 >> 1) * (m + 1 >> 1) << " ";
    if(n > 2 || m > 2) {
      if(m == 2) swap(n, m);
      for(int i = 1; i <= n + 1 >> 1; i++)
        for(int j = 1; j <= m + 1 >> 1; j++) {
          int x = i * 2 - 1, y = j * 2 - 1;
          if(n % 2 == 0 && x > n / 2) x++;
          if(m % 2 == 0 && y > m / 2) y++;
          int dx = max(x - 1, n - x);
          int dy = max(y - 1, m - y);
          ans += sqrt(dx * dx + dy * dy);
        }
    }
    printf("%.10lf\n", ans);
  }
  return 0;
}
```

---

## 作者：snail2956 (赞：1)

## 题意

[题目链接](https://www.luogu.com.cn/problem/P8452)

**第一问**：给定一个 $n\times m$ 的矩阵，每个位置上有一张桌子，问在去掉桌子最少的情况下，使得任意一张桌子八连通的位置上没有其他桌子。

**第二问**：在撤去桌子最少的前提下，最大化剩余每张桌子到距离其最远的桌子的距离和。这里距离指**欧几里得距离**。

---

## 思路

**第一问**：考虑贪心，在 $(1,1)$ 的位置摆放第一张桌子，之后向右每隔一列放置一张，向下每隔一行放置一张，以此类推，直至无法放置桌子为止。

打个比方，给定一个 $4\times 5$ 的矩阵，就大概长这样（0 表示不放置，1 表示放置）：
$$\begin{matrix}1&0&1&0\\0&0&0&0\\1&0&1&0\\0&0&0&0\\1&0&1&0\end{matrix}$$

最少撤去的数量为 $n\times m-\left\lceil\dfrac{n}{2}\right\rceil\times \left\lceil\dfrac{m}{2}\right\rceil$。

**第二问**：最大化距离和？还是拿刚刚 $4\times 5$ 的矩阵，康康长啥样（0 表示不放置，1 表示放置）：

$$\begin{matrix}1&0&0&1\\0&0&0&0\\1&0&0&1\\0&0&0&0\\1&0&0&1\end{matrix}$$

我们发现，这个矩阵可以分成**四份**：

**左上**
$$\begin{matrix}1&0\\0&0\\1&0\end{matrix}$$
$\left\lceil\dfrac{n}{2}\right\rceil\times \left\lceil\dfrac{m}{2}\right\rceil$ 的矩阵，左上角放置，其中所有放置桌子的位置，距离其最远的桌子为右下角的桌子（以下以此类推）

**右上**
$$\begin{matrix}0&1\\0&0\\0&1\end{matrix}$$
$\left\lfloor\dfrac{n}{2}\right\rfloor\times \left\lceil\dfrac{m}{2}\right\rceil$ 的矩阵，右上角放置

**左下**
$$\begin{matrix}0&0\\1&0\end{matrix}$$
$\left\lceil\dfrac{n}{2}\right\rceil\times \left\lfloor\dfrac{m}{2}\right\rfloor$ 的矩阵，左下角放置

**右下**
$$\begin{matrix}0&0\\0&1\end{matrix}$$
$\left\lfloor\dfrac{n}{2}\right\rfloor\times \left\lfloor\dfrac{m}{2}\right\rfloor$ 的矩阵，右下角放置

分成四个循环，各自跑一遍即可。

另：此做法不需要特判 $n=1$，$m=1$，$n=2$或$m=2$的特殊情况 

---

## $Code$

```cpp
#include<cstdio>
#include<cmath>

int a,t,n,m,ans;
double d;

inline int read(){
	int x=0;
	char ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x;
}
void write(int x){
	if(x>9){
		write(x/10);
	}
	putchar(x%10+'0');
}

int main() {
	a=read(); t=read();
	while(t--){
		d=0;
		n=read(); m=read();
		int n1=n/2,m1=m/2;
		if(n&1) n1++;
		if(m&1) m1++;
		ans=n*m-m1*n1;
		if(n>2||m>2){
			for(int i=1;i<=(n+1)/2;i+=2){
				for(int j=1;j<=(m+1)/2;j+=2){
					d+=sqrtl((i-n)*(i-n)+(j-m)*(j-m));
				}
			}
			for(int i=n;i>n/2+1;i-=2){
				for(int j=m;j>m/2+1;j-=2){
					d+=sqrtl((i-1)*(i-1)+(j-1)*(j-1));
				}
			}
			for(int i=1;i<=(n+1)/2;i+=2){
				for(int j=m;j>m/2+1;j-=2){
					d+=sqrtl((i-n)*(i-n)+(j-1)*(j-1));
				}
			}
			for(int i=n;i>n/2+1;i-=2){
				for(int j=1;j<=(m+1)/2;j+=2){
					d+=sqrtl((i-1)*(i-1)+(j-m)*(j-m));
				}
			}
		}
		printf("%d %.9lf\n",ans,d);
	}
	return 0;
}
```

---

## 作者：xiaohaoaibiancheng66 (赞：1)

# 思路

### 第一问
依据样例，可以想出答案为：只需去除 $i$ 为偶数或 $j$ 为偶数的情况，即为 $\lfloor\dfrac{n+1}{2}\rfloor\times\lfloor\dfrac{m+1}{2}\rfloor$。


因为再任意加一张桌子都会和已有桌子有公共点，所以此为最优解。
- - -
### 第二问
第二问有 $4$ 种情况，要进行分类讨论。
- - -
- $n$ 为奇，$m$ 为奇。

此情况方案唯一，直接按第一问的结果遍历即可。
- - -
- $n$ 为奇，$m$ 为偶。

此情况每个**没撤走的桌子**的 $i$ **是固定的**！

所以只需让 $j$ 尽量分散即可。

这样最优解为：对于小于 $\dfrac{m}{2}$ 的 $j$ 向左移，其余的向右移即可。
- - -
- $n$ 为偶，$m$ 为奇。

本质上和情况二是一样的，只不过把 $j$ 和 $m$ 换成 $i$ 和 $n$ 了。
- - -
- $n$ 为偶，$m$ 为偶。

因为 $i$ 和 $j$ 均不固定，所以把 $i$ 和 $j$ 都按照情况二的方法分散即可。
- - -
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

void work()
{
	int n,m;
	cin>>n>>m;
	cout<<n*m-((n+1)/2)*((m+1)/2)<<' ';
	if(n<=2&&m<=2)//特判
	{
		cout<<"0.000000000\n";
		return ;
	}
	if(n%2==1&&m%2==1)//情况一
	{
		double ans=0;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
			{
				if(i&1||j&1)continue;
				int mx=(i)<(n-1-i)?n-1:0;
				int my=(j)<(m-1-j)?m-1:0;
				ans+=sqrt((mx-i)*(mx-i)+(my-j)*(my-j));
			}
		printf("%.9f\n",ans);
		return ;
	}
	if(n%2==1&&m%2==0)//情况二
	{
		double ans=0;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
			{
				if(i&1)continue;
				if(j&1)continue;
				int j1=j;
				if(j>=m/2)j1++;
			//	cout<<i<<' '<<j1<<'\n';
				int mx=(i)<(n-1-i)?n-1:0;
				int my=(j1)<(m-1-j1)?m-1:0;
				ans+=sqrt((mx-i)*(mx-i)+(my-j1)*(my-j1));
			}
		printf("%.9f\n",ans);
		return ;
	}
	if(m%2==1&&n%2==0)//情况三
	{
		double ans=0;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
			{
				if(i&1)continue;
				if(j&1)continue;
				int i1=i;
				if(i>=n/2)i1++;
			//	cout<<i<<' '<<j1<<'\n';
				int mx=(i1<(n-1-i1))?n-1:0;
				int my=(j)<(m-1-j)?m-1:0;
				ans+=sqrt((mx-i1)*(mx-i1)+(my-j)*(my-j));
			}
		printf("%.9f\n",ans);
		return ;
	}if(m%2==0&&n%2==0)//情况四
	{
		double ans=0;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
			{
				if(i&1)continue;
				if(j&1)continue;
				int i1=i;
				if(i>=n/2)i1++;
					int j1=j;
				if(j>=m/2)j1++;
			//	cout<<i<<' '<<j1<<'\n';
				int mx=(i1<(n-1-i1))?n-1:0;
				int my=(j1)<(m-1-j1)?m-1:0;
				ans+=sqrt((mx-i1)*(mx-i1)+(my-j1)*(my-j1));
			}
		printf("%.9f\n",ans);
		return ;
	}
 } 
 
int main()
{
	int t;
	cin>>t;
	cin>>t;
	while(t--)work();
	return 0;
}
```


---

## 作者：KemononeRou (赞：1)

没想好该干什么好就写一下今天月赛 div2 的题解吧（

首先转化成 $n\times m$ 的网格中选尽量多的格子，使得任意两个格子不是八连通的。

## 第一问：

一个比较显然的贪心就是隔一行选一行，每个选了的行隔一个选一个。

感性理解一下：

每选一个格子，和它八连通的格子都不能选。

于是每次选格子的时候都要最小化不能选的格子增加的数量。

因此每次选的格子都要保证和它八连通的格子中不能选的格子数量最多。

把网格外围看成一堆不能选的格子，然后我们容易发现每次选一个在角落的格子是最优的。

上面说的贪心可以用这种选法选出来同样的格子。

## 第二问：

$n$ 为奇数的时候行只有一种选法，$m$ 为奇数的时候列只有一种选法，因此只须考虑 $n$ 和 $m$ 均为偶数的情况。

容易发现每个格子距离它最远的格子一定在四个角落上。

对于一个格子 $(x,y)$，当 $x\leq\dfrac{n}{2}$ 时距离它最远的点一定在最右边，$x>\dfrac{n}{2}$ 时一定在最左边。$y$ 同理。

然后我们将这个 $n\times m$ 的网格平均分成四个 $\dfrac{n}{2}\times\dfrac{m}{2}$ 的小网格。

这样的话每个小网格对应的最远的格子都会是同一个（如左上对应右下）。

当 $n$ 和 $m$ 均为偶数的时候，如果按上面的贪心选，会发现最后多出来第 $n$ 行和第 $m$ 列。

我们可以考虑将这一行一列移动到四个小网格的交界处来增加行距和列距。

即对于下面的两个小网格，将他们选的格子整体下移一格，对于右边的两个小网格往右移。

[一个例子（？）](https://www.luogu.com.cn/paste/mt92pwzd)

[code](https://www.luogu.com.cn/paste/8iceuo8x)

---

## 作者：BotDand (赞：1)

# $\text{Problems}$

有 $n\times m$ 个网格，求选出最多的网格数使得任意两个网格没有公共点，且要求最大化每个网格到其距离最远的网格的距离之和。

$\texttt{Ps}$：这里的距离指欧几里得距离。

# $\text{Answer}$

$\texttt{80}$ 分的代码很好想，从第 $1$ 排第一列开始选，每次纵坐标加 $2$，横坐标加 $2$，直到碰到边界。

不难得到答案即为 $n\times m-\left \lceil \dfrac{n}{2} \right \rceil \times \left \lceil \dfrac{m}{2} \right \rceil$。

接下来考虑 $\texttt{100}$ 分的。

不难发现每个点距离 $(1,1)$，$(1,m)$，$(n,1)$，$(n,m)$ 中的一个点距离最远。

如果 $n$，$m$ 均为奇数，则按照上面的构造方法即可求出答案。

如果有至少一个为偶数怎么办呢？

考虑最特殊的 $n$，$m$ 均为偶数。

![](https://s1.ax1x.com/2022/08/05/vmxMA1.png)

显然这样的构造方法肯定不是最优的。

可以将其分为四个区块，用不同颜色标记。

![](https://s1.ax1x.com/2022/08/05/vmxNBd.png)

不难发现：

* 红色区块距离 $(n,m)$ 最远；
* 黄色区块距离 $(n,1)$ 最远；
* 蓝色区块距离 $(1,m)$ 最远；
* 绿色区块距离 $(1,1)$ 最远；

考虑将蓝色区块向下平移一格，绿色区块向下向右分别平移一格，黄色区块向右平移一格，这样就可以选定 $(1,1)$，$(1,m)$，$(n,1)$，$(n,m)$。

![](https://s1.ax1x.com/2022/08/05/vmxfNq.png)

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int s,t;
int n,m;
double ans;
int x,y;
double Max(double x,double y)
{
	if(x>y) return x;
	return y;
}
int main()
{
	cin>>s>>t;
	while(t--)
	{
		cin>>n>>m;
		cout<<n*m-((n+1)/2)*((m+1)/2)<<" ";
		/* ----------80 pts----------*/
		if(n<3&&m<3)
		{
			puts("0");
			continue;
		}
		ans=0;
		for(int i=1;i<=n;i+=2)
			for(int j=1;j<=m;j+=2)
			{
				int x=i,y=j;
				if(n%2==0&&i>n/2) x++;
				if(m%2==0&&j>m/2) y++;
				double ma=0;
				ma=Max(ma,sqrt((x-1)*(x-1)+(y-1)*(y-1)));
				ma=Max(ma,sqrt((n-x)*(n-x)+(y-1)*(y-1)));
				ma=Max(ma,sqrt((x-1)*(x-1)+(m-y)*(m-y)));
				ma=Max(ma,sqrt((n-x)*(n-x)+(m-y)*(m-y)));
				ans+=ma;
			}
		cout<<fixed<<setprecision(9)<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：吴思诚 (赞：0)

# P8452 「SWTR-8」15B03 题解
[题目传送门](https://www.luogu.com.cn/problem/P8452)

## 思路
这道题有两问，我们逐个分析。
### 第一问
最少撤去，转化成最少保留，对于相邻两行只能有一行放桌子，所以放桌子的行数是 $\lceil \frac{n}{2}\rceil$ ，然后对于每一行可放的，同理，相邻两列只能有一列放桌子，所以放桌子的列数是 $\lceil \frac{m}{2}\rceil$，所以桌子的总数为 $\lceil \frac{n}{2}\rceil \times \lceil \frac{m}{2}\rceil$，撤去的总数为 $n\times m-\lceil \frac{n}{2}\rceil \times \lceil \frac{m}{2}\rceil$。
### 第二问
最大化剩余每张桌子到距离它最远的桌子的距离之和，这里需要继续分类。

1.$n,m$ **均为奇数**。

这种情况放桌子的方案是唯一的，即奇数行和奇数列有桌子。计算时直接计算每张桌子到四个角($(1,1),(n,1),(1,m),(n,m)$)的距离的最大值即可。

2.$n=1,m$ **为偶数**。

这种情况只有一行，放完桌子和空隙后会有多余的一格，可以放在任意位置，那应该放在哪里使得答案最大？为了使得每对桌子的匹配越远，应该把空格放在最中间的两个桌子的中间，可以使得所有桌子的距离都增加，一定是最优的。

3.其他情况。

有了上面对于列的空格分析，行的分析也是类似的。把空格放在最中间的两个桌子的中间，因为行和列是独立的，所以也是最优的。

___
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,t,n,m;
int main(){
	scanf("%d%d",&s,&t);
	while(t--){
		scanf("%d%d",&n,&m);
		long double ans=0;
		for(int hi=1,hj=n;hi<=hj;hi+=2,hj-=2)//这里从两边向中间放桌子，可以边构造边计算，更方便
			for(int li=1,lj=m;li<=lj;li+=2,lj-=2){//同理
				int t1=max(hi-1,n-hi),t2=max(li-1,m-li),T1=max(hj-1,n-hj),T2=max(lj-1,m-lj);//计算行列最远距离
				long double ans1=sqrtl(t1*t1+t2*t2),ans2=sqrtl(t1*t1+T2*T2),ans3=sqrtl(T1*T1+t2*t2),ans4=sqrtl(t1*t1+T2*T2);//计算两行两列的四个交点的贡献
				bool f1=hj-hi>1,f2=lj-li>1;//判断两边到最中间是否有相邻或重合的情况
				ans+=ans1;//不管重合都有的交点
				if(f1)ans+=ans3;//行无重合的交点
				if(f2)ans+=ans2;//列无重合的交点
				if(f1&&f2)ans+=ans4;//行列均无重合
			}
		printf("%d %.10Lf\n",n*m-(n+1>>1)*(m+1>>1),n<=2&&m<=2?0:ans);//特判n<=2&&m<=2的情况，只有一个点，答案为0
	}
	return 0;
}
```

---

## 作者：Jeremiahy (赞：0)

## 分析

首先考虑第一问。

任何两张课桌不能相邻的含义是任何一张张课桌周围一圈都没有课桌。我们可以先想如何摆放课桌，就知道如何撤去课桌了。

很容易想到一种构造方法：四角都放课桌（如果符合要求），然后隔一行摆一行课桌直到第 $\frac n 2$ 行，下半部分对称摆，摆一行时，隔一列摆一张课桌。这样可以使得撤去的课桌数量最少，因为四角的摆放使得课桌的周围一圈跑到边界之外，相当于多了一部分空间，其他按照要求摆放就可以撤去最少的课桌。

撤去课桌数量怎么计算呢？撤去的课桌是整行整列撤去的，那么行撤去的课桌数就是 $\frac {n} {2} \times m$，同理，列撤去的课桌数量就是 $\frac {m} {2} \times n$，多算了 $\frac {n} {2} \times \frac m 2$，再减去它即可。

化简可得撤去的课桌数量为 $\frac {3mn} 4$。

再考虑第二问。

我们发现，每张课桌最大距离具有某种对称关系。比如左上角的课桌距离右下角的课桌最远，那么右上角的课桌距离左下角的课桌的距离与此相等，左下角和右下角同理，**也就是说，一般情况下，课桌的距离是成** $4$ **出现的**。当然有特殊情况：位于中线上的课桌。只位于行中线或列中线的课桌成对出现。同时位于行中线和列中线的课桌只有一张。所以我们只统计左上部分的课桌最远距离就能得到整体的最远距离了。

最远距离如何求呢？显然，对于左上部分的课桌，右下角的课桌距离它们最远，计算即可。

需要注意的是，当 $n=1,m=2$ 或 $n=2,m=1$ 或 $n=2,m=2$ 时，只有一张课桌，所以距离是 $0$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int T, n, m;
double ans;
inline int read(){//快读
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = (x << 1) + (x << 3) + c - '0', c = getchar();
    return x * f;
}
signed main () {
	T = read(); T = read();
	while (T--) {
		ans = 0.0;
		n = read(); m = read();
		cout << n / 2 * m + m / 2 * n - (m / 2) * (n / 2) << ' ';//计算公式
		for (register int i = 1; i <= ((n + 1) >> 1); i += 2)
			for (register int j = 1; j <= ((m + 1) >> 1); j += 2)
				if (i == (n + 1) / 2 && j == (m + 1) / 2)//位于正中央
					ans += sqrt(1.0 * (n - i) * (n - i) + (m - j) * (m - j));
				else if (i == (n + 1) / 2 || j == (m + 1) / 2)//位于边中线或列中线
					ans += sqrt(1.0 * (n - i) * (n - i) + (m - j) * (m - j)) * 2;
				else//一般情况
					ans += sqrt(1.0 * (n - i) * (n - i) + (m - j) * (m - j)) * 4;				
		if ((n == 1 && m == 2) || (n == 2 && m == 1) || (n == 2 && m == 2))//特殊情况
			cout << 0 << "\n";
		else
			printf("%.9lf\n", ans);
	}
	return 0;
}
```


---

## 作者：Cure_Wing (赞：0)

### 题目
* [丢个链接](https://www.luogu.com.cn/problem/P8452)。

### 解法
* 我们先解决第一个问题：**最少撤去的桌子数量**。
* 由于相邻的两张桌子不能有公共的点，很显然，前后两张桌子之间要空一行，左右两张桌子之间要空一列。
* 其实就是同一列（行）的相邻两行（列）只能有一张桌子。
* 简单推理得出最多只能剩余 $\left\lceil\dfrac{n}{2}\right\rceil\times\left\lceil\dfrac{m}{2}\right\rceil$ 张桌子，所以最少需要撤去 $\left(n\times m-\left\lceil\dfrac{n}{2}\right\rceil\times\left\lceil\dfrac{m}{2}\right\rceil\right)$ 张桌子。
* 这样我们就得到了 $80$ 分的好成绩。

* 现在我们来解决第二个问题：**每张桌子到距离它最远的桌子的距离之和的最大值**。

* **测试点 #1（15 points）：$n,m$ 均为奇数**。
* ![原题的图](https://cdn.luogu.com.cn/upload/image_hosting/y8fi4qhr.png)
* 我们首先考虑图上的情况（$n,m$ 均为奇数）。
* 很明显的一点，为了尽可能多的放置桌子，一行（一列）中两端的桌子的距离一定是个奇数，所以当 $n,m$ 均为奇数时，所在的行或列一定是排的满满当当，没有余地。
* 所以在这种情况下，桌子的排列方案只有一种。
* 接下来我们考虑如何统计最大距离和。
* 我们可以把考场看成[平面直角坐标系](https://baike.baidu.com/item/%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB/1296463?fr=aladdin)，分成四个象限。
* ![平面直角坐标系](https://img1.baidu.com/it/u=1395354419,2722689080&fm=253&app=138&size=w931&n=0&f=JPG&fmt=auto?sec=1659459600&t=7ec1253dab5ed8877174d33bf1570776)
* 其中 $x$ 轴表示考场两侧边中点的连线，$y$ 轴表示考场前后边中点的连线。
* 想必大家很清楚一个点：距离第二象限的点最远的点一定是第四象限的右下角的点，距离第一象限的点最远的点一定是第三象限左下角的点，反之亦然。
* 所以我们可以暴力枚举每张桌子，匹配它所对应的最远的桌子，加起来即可。
* 这样子我们就得到了 $83$ 分的好成绩。

* **测试点 #4（30 points）：$n$ 为奇数**。
* 因为 $n$ 为奇数，所以 $y$ 轴方向我们的处理方式不变。但是当 $m$ 为偶数时，我们会发现一个问题。
* ![图P8452-题解1](https://cdn.luogu.com.cn/upload/image_hosting/hksypycz.png)
* 就是在 $x$ 轴的右边会多出一列，这怎么办？
* 当然是把桌子尽可能的向右靠啊！
* ![图P8452-题解2](https://cdn.luogu.com.cn/upload/image_hosting/0emar66r.png)
* 很显然，下面这张图的方案一定是比上面的优的。

* 让我们把问题问的在再深入一点，当 $m$ 为一般情况下的时候，我们该如何处理呢？
* 若 $m$ 为奇数，处理情况同 **测试点 #1**。
* 若 $m$ 为偶数，我们就要考虑如何拖桌子。
* 让我们把范围稍微搞大一点。
* ![图P8452-题解3](https://cdn.luogu.com.cn/upload/image_hosting/f60cn3d1.png)![图P8452-题解4](https://cdn.luogu.com.cn/upload/image_hosting/oijm8a46.png)![图P8452-题解5](https://cdn.luogu.com.cn/upload/image_hosting/k790lamx.png)
* 我带来了三张图片，让我们来研究以下如何拖桌子。
* ~~让我们用最朴素的方法：暴力计算每张图的答案。~~
* 由于过程太长，就不~~展示~~写了，还是直接比较得了。
* 图[左1]&图[中]：可以看出，图[中]的方案更优，因为第 $1,2,3$ 列与第 $4$ 列之间的距离加大了。
* 图[左1]&图[右1]：可以看出，图[右1]的方案更优，因为第 $1,2$ 列与第 $3,4$ 列之间的距离加大了。
* 图[中]&图[右1]：可以看出，图[右1]的方案更优，因为第 $3$ 列与第 $2,4$ 列之间的距离总和不变，但是第 $1,2$ 到第 $3$ 列的距离的增量却比第 $3$ 列到第 $4$ 列的减量要大得多。
* 所以我们就得出了一条结论：沿 $y$ 轴轴对称分布桌子的方案一定是最优的。
* 所以我们得到了 $89$ 分的好成绩。

* **测试点 #5（10 points）：无特殊限制。**
* 利用同样的方法，我们可以发现相似的结论：沿 $x$ 轴轴对称分布桌子的方案一定是最优的。
* 所以我们得到了 $91$ 分的好成绩。

* **测试点 #2（20 points）：$n=1$。&测试点 #3（25 points）：$n=2$。**
* 有没有人问这个问题，为什么把 **测试点 #2&测试点 #3** 放到后面来讲？
* 如果你写过代码了你就会知道当你不假思索提交上去后发现 **#2,#3 WA** 得很惨。
* 我们其实忽略了一个重要的问题，如果考场内桌子只能放 $1$ 张，那么这张桌子为什么会存在对应象限呢？
* 既然不存在对应象限，那么只能对应它自己了，所以这种情况下的答案为 $0.000000000$。
* 这种情况的范围很容易讨论出来 $1\le n\le2$ 且 $1\le m\le2$。
* 所以我们只需要再特判一下就可以得到 $100$ 分了！

### 代码
* 时间复杂度 $\mathcal{O}(mnT)$。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iomanip>
using std::cin;using std::cout;
int s,t,n,m;
inline long double O(int a,int b,int c,int d){
	return sqrtl(1.00*(a-c)*(a-c)+1.00*(b-d)*(b-d));
}
signed main(){
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	for(cin>>s>>t;t--;){
		cin>>n>>m;
		cout<<n*m-(n+1>>1)*(m+1>>1)<<' ';
		long double ans=0.00;
		if(n==1&&m==2||n==2&&m==2||n==2&&m==1||n==1&&m==1){
            cout<<0.000000000<<'\n';
            continue;
        }
		for(int i=1;i<=n;i+=2)
			for(int j=1;j<=m;j+=2){
				if(i>(n>>1)&&!(n&1)) ++i;
				if(j>(m>>1)&&!(m&1)) ++j;
				if(i<=(n>>1)){
					if(j<=(m>>1)) ans+=O(n,m,i,j);
					else ans+=O(n,1,i,j);
				}else{
					if(j<=(m>>1)) ans+=O(1,m,i,j);
					else ans+=O(1,1,i,j);
				}
				if(i>(n>>1)&&!(n&1)) --i;
				if(j>(m>>1)&&!(m&1)) --j;
			}
		cout<<std::fixed<<std::setprecision(9)<<ans<<'\n';
	}
    return 0;
}
```

---


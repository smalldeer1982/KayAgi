# 「Wdoi-(-1)」恋弹者们的黑集市

## 题目背景

> 天弓千亦有言：「能力卡终将大势所趋归于陈腐，集市终将回归日常，这是发展规律。」但不知为何和神明所说相悖，卡片的价值遭到了炒作。有人在炒作卡的价值吗废话？又或者说，有倒爷在囤积这些卡片吗？卡片市场秩序完全陷入混乱之时，即便是神明也无法介入的集市，就此出现。

$$\quad\tag*{\small\textit{---TH18.5 恋弹者们的黑集市}}$$

魔理沙正在调查妖怪之山的高地，来收集逸散在各地的能力卡片。就在此时，她遇到了住在此处的驹草山如。

在河童与天狗间游刃有余的驹草山如，掌握着此地大量的资源。显而易见的，她掌握着大量的能力卡片——这正是魔理沙探访的目标。

「想要这些卡片吗，那就让我们玩一个游戏吧」

「赢了，这些卡片就都归你；输了，你可要交出身上所有的卡片。」



## 题目描述

### 原始题意



驹草山如将一个六面写满权值的骰子放在了棋盘上。棋盘上花花绿绿写着很多数字。第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

「你能否获得这些能力卡片，取决于你获得的分数。」

魔理沙有两种方法移动这个骰子：将骰子向下一列**翻转**，或者向下一行**翻转**。值得注意的是，翻转骰子后，骰子每面上的数字就会随着翻滚而改变。现在魔理沙需要将骰子滚动至第 $n$ 行第 $m$ 列。

魔理沙的分数被定义为，所有时刻，骰子与棋盘上的数字接触的那一面的数字，乘上棋盘上该数字，再累加起来的和。只有魔理沙最大化这个和，她才能获取她所需要的卡片。

你能帮帮魔理沙吗？

### 简要题意

有一个 $n\times m$ 大小的棋盘，第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

现在有一个骰子，六个面按照前、后、左、右、上、下的顺序，依次写有数字 $w_0,w_1,w_2,w_3,w_4,w_5$。现在骰子摆放在 $(0,0)$ 位置，需要将它**滚动**至 $(n-1,m-1)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2l378eln.png)

骰子只有两种方式滚动：向下一行翻滚、向下一列翻滚。我们记一种方案的权值为，整个过程中（包括骰子在起点和终点时），骰子**最底面**上写着的数字，与此时骰子所在格子上写着的数字的乘积之和。

![](https://cdn.luogu.com.cn/upload/image_hosting/4jwvxax5.png)

（为了方便读者阅读，骰子上的数字已经隐去）

现在你需要最大化这个乘积之和。

## 说明/提示

### 样例解释

#### 样例 1 解释

一种最优的方案为，$(0,0)\to(0,1)\to(1,1)\to(1,2)\to(1,3)\to(2,3)\to(3,3)\to(3,4)\to(4,4)$。

总权值为 $2+8+19+19+3+8+8+17+13=97$。

#### 样例 2 解释

一种最优的方案为，$(0,0)\to(0,1)\to(1,1)\to(1,2)\to(1,3)\to(1,4)$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m\le} & \textbf{特殊性质} & \textbf{分值} \\\hline
1 & 10 & - & 10 \\\hline
2 & 100 & - & 30 \\\hline
3 & 10^3 & \textbf{A} & 10 \\\hline
4 & 10^3 & - & 50 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $w_i=1,i=0,1,2,\cdots 5$。

对于全部数据，保证 $1\le n,m\le 10^3$，$|a_i|\le 10^3$，$|w_i|\le 10^3$。

## 样例 #1

### 输入

```
5 5
2 8 15 1 10
5 19 19 3 5
6 6 2 8 2
12 16 3 8 17
12 5 3 14 13
1 1 1 1 1 1
```

### 输出

```
97```

## 样例 #2

### 输入

```
2 5
2 8 15 3 10
5 19 19 3 5
1 2 3 4 5 6```

### 输出

```
194```

# 题解

## 作者：_•́へ•́╬_ (赞：7)

## 思路

设 $f[i][j][?]$ 表示正方体滚到 $(i,j)$，且正方体的状态（朝向）为 ? 的答案。

如何表示正方体的状态？

~~小学奥数~~初中数学我们学过三视图。

对于本题，我们记录三个方向即可。

我的代码中：$[o][p][q]$ 为下面（贴着棋盘的那个）是 $o$，正对着你的（往 $(i+1,j)$ 翻转就贴着地的那个）是 $p$，右边的（往 $(i,j+1)$ 翻转就贴着地的那个）是 $q$。

判断状态合法：$o,p,q$ 必须是不同方向，也就是说既不能相同也不能相对。

貌似卡空间？用了滚动数组。

## code

```cpp
#include<stdio.h>
#include<string.h>
#define N 1000
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	bool t=0;char c=nc();for(;c<'0'||'9'<c;t|=c=='-',c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());if(t)x=-x;
}
int n,m,a[N][N],f[2][N][6][6][6],w[6],ans=-(1<<30);
inline int max(const int&x,const int&y){return x>y?x:y;}
main()
{
	read(n);read(m);
	for(int i=0;i<n;++i)for(int j=0;j<m;read(a[i][j++]));
	for(int i=0;i<6;read(w[i++]));
	memset(f,0xbb,sizeof(f));
	f[0][0][5][0][3]=a[0][0]*w[5];
	for(int j=1;j<m;++j)for(int o=0;o<6;++o)for(int p=0;p<6;++p)
		if((o^p)&&(o^p^1))for(int q=0;q<6;++q)if((o^q)&&(o^q^1))
			if((p^q)&&(p^q^1))
				f[0][j][o][p][q]=f[0][j-1][q^1][p][o]+a[0][j]*w[o];//第一行
	for(int i=1;i<n;++i)
	{
		for(int o=0;o<6;++o)for(int p=0;p<6;++p)
			if((o^p)&&(o^p^1))for(int q=0;q<6;++q)if((o^q)&&(o^q^1))
				if((p^q)&&(p^q^1))
					f[i&1][0][o][p][q]=f[i&1^1][0][p^1][o][q]+a[i][0]*w[o];//第一列
		for(int j=1;j<m;++j)for(int o=0;o<6;++o)for(int p=0;p<6;++p)
			if((o^p)&&(o^p^1))for(int q=0;q<6;++q)if((o^q)&&(o^q^1))
				if((p^q)&&(p^q^1))
					f[i&1][j][o][p][q]=max(f[i&1][j-1][q^1][p][o],
						f[i&1^1][j][p^1][o][q])+a[i][j]*w[o];
	}
	for(int o=0;o<6;++o)for(int p=0;p<6;++p)if((o^p)&&(o^p^1))
		for(int q=0;q<6;++q)if((o^q)&&(o^q^1)&&(p^q)&&(p^q^1))
			ans=max(ans,f[n&1^1][m-1][o][p][q]);
	printf("%d",ans);
}
```

---

## 作者：蒟蒻炒扇贝 (赞：5)

~~警 惕 大 常 数 题 解 入 侵 题 解 区。~~

------------
看到这道题骰子的运动方式，我们会想到方格取数这道题。考虑 dp。和方格取数一样，骰子只能向下走或者向右走，不会往回走，所以如果将骰子上的数字全部设为 $1$ ，直接设 $f_{i,j}$ 表示滚到点 $(i,j)$ 之后所能获得的最大答案是不会有后效性的。

不过这道题的答案还和目前骰子的状态息息相关，相当朴素的做法就是再给 dp 数组开六维，将骰子目前的六个方向（也就是题目中的 up down front back left right）所对应的编号 （这里的编号就是 $w$ 数组的下标） 记录下来，枚举状态的复杂度为 $\mathop{O(6^6\times nm)}$，无法通过本题。

其实对于本题来说，我们只要给 dp 数组再开两维即可，这两维分别记录目前骰子中的 front 和 right 对应的编号是什么。因为我们仅根据目前 front 和 right 的编号就能推出目前整个骰子是什么状况。对于题目中的两种操作，我们可以直接模拟出进行操作之后的骰子 front 和 right 的状态。时间复杂度为 $\mathop{O(6^2\times nm)}$，可以通过本题。

由于本人很菜，不会推什么厉害的规律，所以直接分类讨论出了个 ```get_down``` 函数，表示在目前 front 和 right 都确定的情况下骰子底面的编号。~~读者朋友们可以自行画图推一推。~~ 注意由于判断的次数较多，常数较大，所以推荐多用 ```else```，尽可能的降低判断次数。

注意在以下代码中，骰子的初始状态和题目描述中的一致（也就是 front 对应 $w_0$，back 对应 $w_1$，left 对应 $w_2$，right 对应 $w_3$，up 对应 $w_4$，down 对应 $w_5$）。

### Code
```cpp
//Coded by weak_shell
#include<bits/stdc++.h>
using namespace std;
#define pir pair<int,int>
#define fs first
#define sc second
int read()
{
    int x=0,fh=1;
    char ch=getchar();
    while(!isdigit(ch))
	{
        if(ch=='-') fh=-1;
        ch=getchar();
    }
    while(isdigit(ch))
	{
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*fh;
}
int a[1005][1005],f[1005][1005][7][7],w[7],n,m;
int get_down(int x,int y)//x:front y:right
{
	if(x==0)
	{
		if(y==2)return 4;
		else if(y==3)return 5;
		else if(y==4)return 3;
		else if(y==5)return 2;
	}
	else if(x==1)
	{
		if(y==2)return 5;
		else if(y==3)return 4;
		else if(y==4)return 2;
		else if(y==5)return 3;
	}
	else if(x==2)
	{
		if(y==0)return 5;
		else if(y==1)return 4;
		else if(y==4)return 0;
		else if(y==5)return 1;
	}
	else if(x==3)
	{
		if(y==0)return 4;
		else if(y==1)return 5;
		else if(y==4)return 1;
		else if(y==5)return 0;
	}
	else if(x==4)
	{
		if(y==0)return 2;
		else if(y==1)return 3;
		else if(y==2)return 1;
		else if(y==3)return 0;
	}
	else if(x==5)
	{
		if(y==0)return 3;
		else if(y==1)return 2;
		else if(y==2)return 0;
		else if(y==3)return 1;
	}
	return 6;//这里 return 6 就表示这种状态不存在 
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=read();
	for(int i=0;i<6;i++)w[i]=read();
	memset(f,-0x3f,sizeof(f));
	f[1][1][0][3]=a[1][1]*w[5];
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	 {
	 	if(i==1&&j==1)continue;
	 	for(int nx=0;nx<6;nx++)for(int ny=0;ny<6;ny++)//这里枚举骰子前一步的状态
	 	{
	 		if(get_down(nx,ny)==6)continue;
	 		int tx=nx,ty=-1;//设tx ty 表示当骰子的 front 和 right 目前分别为 nx ny 时，进行某种操作之后 front 和 right 的状态
	 		if(get_down(nx,ny)==5)ty=4;
	 		if(get_down(nx,ny)==4)ty=5;
	 		if(get_down(nx,ny)==3)ty=2;
	 		if(get_down(nx,ny)==2)ty=3;
	 		if(get_down(nx,ny)==1)ty=0;
	 		if(get_down(nx,ny)==0)ty=1;
	 		int td=get_down(tx,ty);
	 		f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i][j-1][nx][ny]+a[i][j]*w[td]);//向下一行翻滚
	 		ty=ny,tx=-1;
	 		if(get_down(nx,ny)==5)tx=4;
	 		if(get_down(nx,ny)==4)tx=5;
	 		if(get_down(nx,ny)==3)tx=2;
	 		if(get_down(nx,ny)==2)tx=3;
	 		if(get_down(nx,ny)==1)tx=0;
	 		if(get_down(nx,ny)==0)tx=1;
	 		td=get_down(tx,ty);
	 		f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i-1][j][nx][ny]+a[i][j]*w[td]);//向下一列翻滚 
		}
	 }
	 int ans=-1e9;
	 for(int i=0;i<6;i++)for(int j=0;j<6;j++)ans=max(ans,f[n][m][i][j]);
	 printf("%d",ans);
}
```

感谢阅读！

---

## 作者：lyt_awa (赞：3)

## 简要题意
有一个 $n\times m$ 大小的棋盘，第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。

现在有一个骰子，六个面按照前、后、左、右、上、下的顺序，依次写有数字 $w_0,w_1,w_2,w_3,w_4,w_5$。现在骰子摆放在 $(0,0)$ 位置，需要将它滚动至 $(n-1,m-1)$。

骰子只有两种方式滚动：向下一行翻滚、向下一列翻滚。我们记一种方案的权值为，整个过程中（包括骰子在起点和终点时），骰子最底面上写着的数字，与此时骰子所在格子上写着的数字的乘积之和。

现在你需要最大化这个乘积之和。
## 思路
**一眼dp**

### 状态
由于骰子的前、后、左、右、上、下依次写有**确定的**数字 $w_0,w_1,w_2,w_3,w_4,w_5$。所以**只要确定目前骰子的前面和右侧的数字，就可以确定整个骰子的状态**。
于是就可以定下状态:  
$f[i][j][q][y]$ 表示骰子在第 $i$ 行第 $j$ 列前面数字为 $w_q$ 右边数字为 $w_y$ 时最大的乘积之和为多少。

### 转移方程
然后就是状态转移方程（我用刷表）~~这应该很简单吧~~： 

$f[i+1][j][U(q,y)][y]=\max (f[i+1][j][U(q,y)][y],f[i][j][q][y]+a[i+1][j] \times w[q])$

$f[i][j+1][q][U(q,y)]=\max(f[i][j+1][q][U(q,y)],f[i][j][q][y]+a[i][j+1] \times w[y])$

$U(q,y)$ 表示前面数字为 $w_q$ 右边数字为 $w_y$ 时上面的数字为 $w_{U(q,y)}$

### 初始化
重要的是**初始化**，因为 $f[i][j][q][y]$ (不会爆int)可能为负数，所以初始化为 $0xcfcfcfcf$。  
**最开始的状态** $f[1][1][0][3]$ 为 $a[1][1]\times w[5]$。

剩下的就看代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, a[1005][1005], w[6];
int f[1005][1005][6][6], ans = 0xcfcfcfcf;

int U(int q, int y) {
	if (q == 0) {
		if (y == 2) return 5;if (y == 3) return 4;
		if (y == 4) return 2;if (y == 5) return 3;
	}
	if (q == 1) {
		if (y == 2) return 4;if (y == 3) return 5;
		if (y == 4) return 3;if (y == 5) return 2;
	}
	if (q == 2) {
		if (y == 0) return 4;if (y == 1) return 5;
		if (y == 4) return 1;if (y == 5) return 0;
	}
	if (q == 3) {
		if (y == 0) return 5;if (y == 1) return 4;
		if (y == 4) return 0;if (y == 5) return 1;
	}
	if (q == 4) {
		if (y == 0) return 3;if (y == 1) return 2;
		if (y == 2) return 0;if (y == 3) return 1;
	}
	if (q == 5) {
		if (y == 0) return 2;if (y == 1) return 3;
		if (y == 2) return 1;if (y == 3) return 0;
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			scanf("%d", &a[i][j]);
	scanf("%d%d%d%d%d%d", &w[0], &w[1], &w[2], &w[3], &w[4], &w[5]);
	memset(f, 0xcf, sizeof(f));
	f[1][1][0][3] = a[1][1] * w[5];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			for (int q = 0; q < 6; ++q)
				for (int y = 0; y < 6; ++y)
					if (f[i][j][q][y] != 0xcfcfcfcf) {
						f[i + 1][j][U(q, y)][y] = max(f[i + 1][j][U(q, y)][y], f[i][j][q][y] + a[i + 1][j] * w[q]);
						f[i][j + 1][q][U(q, y)] = max(f[i][j + 1][q][U(q, y)], f[i][j][q][y] + a[i][j + 1] * w[y]);
					}
	for (int q = 0; q < 6; ++q)
		for (int y = 0; y < 6; ++y)
			ans = max(ans, f[n][m][q][y]);
	printf("%d\n", ans);
	return 0;
}
```
时间复杂度为 $O(6^2\times nm)$。


---

## 作者：__K2FeO4 (赞：2)

咋一看怎么像方格取数啊？

这道题是我在初赛模拟中做到的一道题。看到它，特别是上下左右前后六个方向，我想到了立方体。果然，这就是立方体的旋转。

我们设 $dp_{i,j,f,r}$ 为第 $i$ 行第 $j$ 列，骰子的前方与右侧下标分别为 $f,r$ 时获得的最大价值。而底部的下标可用一张二维表来表示~~我讨厌枯燥无味浪费行数的打表~~，记作 $d$。这样有利于保证其对称性。

我们发现，一个状态可从左方与后方转移而来。原来左方的 $r$，以及后方的 $f$，都转变成现在的 $d$。于是状态转移方程出来了：

$dp_{i,j,f,r}=max\{dp_{i-1,j,d,r},dp_{i,j-1,f,d}\}+a_{i,j}\times w_d$

初始化，除了 $dp_{1,1,0,3}=a_{1,1}\times w_5$ 之外，其余均赋为 $-\infty$。~~我后来才知道有负数……~~

先循环 $i,j$，再循环 $f,r$，注意 $f=r$ （对应相等）以及 $f\otimes 1=r$ （对应相反）时不执行。

最后循环 $f,r$，寻找 $dp_{n,m,f,r}$ 的最大值并输出即可。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
const int dw[6][6]={
{0,0,4,5,3,2},
{0,0,5,4,2,3},
{5,4,0,0,0,1},
{4,5,0,0,1,0},
{2,3,1,0,0,0},
{3,2,0,1,0,0}};
//up=dw^1
typedef long long ll;
int n,m,a[N][N],w[6];
int f[N][N][6][6];
signed main(){
	memset(f,0xc0,sizeof(f));
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	scanf("%d",&a[i][j]);
	for(int i=0;i<6;i++)
	scanf("%d",w+i);
	//0f 1b 2l 3r 4u 5d
	//f[i][j][fr][rt];
	f[1][1][0][3]=a[1][1]*w[5];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	for(int fr=0;fr<6;fr++)
	for(int rt=0;rt<6;rt++){
		if(fr==rt||(fr^1)==rt||(i==1&&j==1))continue;
		f[i][j][fr][rt]=max(f[i-1][j][dw[fr][rt]][rt],f[i][j-1][fr][dw[fr][rt]])+w[dw[fr][rt]]*a[i][j];
		//printf("%d ",f[i][j][fr][rt]);
	}
	int ans=0xc0c0c0c0;
	for(int fr=0;fr<6;fr++)
	for(int rt=0;rt<6;rt++)
	ans=max(ans,f[n][m][fr][rt]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：free_fall (赞：2)

# 思路

看到题目发现和方格取数非常相似，除了题目里多了一个骰子(这个骰子同时也是题目难点)。

~~知周所众~~，只要确定骰子的两个面，就能确定骰子的状态。

所以使用一个四维数组来记录。

**$dp_{i,j,k,q}$ 表示在坐标为 $(i,j)$ 时骰子前面的面为 $k$，右边的面为 $q$。**

此时若往前走，用上面的面替代前面的面，若往右走，用上面的面替代右边的面，所以只需确定上面的面即可。

用一个数组 $move1_{i,j}$ 确定前面的面为 $i$ 右面的面为 $j$ 时上面的面为 $move1_{i,j}$。

以下为题目重点，建议大家自己推一次，~~还挺有意思的~~。
```
int move1[8][8]={0,0,0,0,0,0,0,0,0,0,0,6,5,3,4,0,0,0,0,5,6,4,3,0,0,5,6,0,0,2,1,0,0,6,5,0,0,1,2,0,0,4,3,1,2,0,0,0,0,3,4,2,1};
```
所以直接用 $dp$，状态转移方程非常容易想到：

$\begin{cases}
f_{i+1,j,move1_{k,q},q}=\max\left \{ f_{i+1,j,move1_{k,q},q},f_{i,j,k,q}+w_k*a_{i+1,j} \right \}
 \\
f_{i,j+1,k,move1_{k,q}}=\max\left \{ f_{i,j+1,k,move1_{k,q}},f_{i,j,k,q}+w_q*a_{i,j+1} \right \} 
\end{cases}$

# 代码


```
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int n,m,ans=0xcfcfcfcf,w[10],a[N][N],dp[N][N][7][7];
int move1[8][8]={0,0,0,0,0,0,0,0,0,0,0,6,5,3,4,0,0,0,0,5,6,4,3,0,0,5,6,0,0,2,1,0,0,6,5,0,0,1,2,0,0,4,3,1,2,0,0,0,0,3,4,2,1};
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=1;i<=6;i++){
		scanf("%d",&w[i]);
	}
	memset(dp,0xcf,sizeof(dp));
	dp[1][1][1][4]=w[6]*a[1][1];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=1;k<=6;k++){
				for(int q=1;q<=6;q++){
					if(dp[i][j][k][q]!=0xcfcfcfcf){
						if(move1[k][q])dp[i+1][j][move1[k][q]][q]=max(dp[i+1][j][move1[k][q]][q],dp[i][j][k][q]+w[k]*a[i+1][j]);
						if(move1[k][q])dp[i][j+1][k][move1[k][q]]=max(dp[i][j+1][k][move1[k][q]],dp[i][j][k][q]+w[q]*a[i][j+1]);
					}
				}
			}
		}
	}
	for(int i=1;i<=6;i++){
		for(int j=1;j<=6;j++){
			ans=max(ans,dp[n][m][i][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
```
时间复杂度为 $O(6^2×nm)$ 	~~丝毫不慌~~ 。

---

## 作者：Sktic (赞：2)

[P8488 「Wdoi-(-1)」恋弹者们的黑集市](https://www.luogu.com.cn/problem/P8488)

2022/8/24 upd ：更改部分 latex 。

题目大意：用一个骰子在 $n\times m$ 的棋盘上滚，从 $(1,1)$ 滚到 $(n,m)$ ，每次可以向下滚或者向右滚，要求最大化每次滚到的方格上的数 $\times$ 此时骰子底面的权值之和。

此题原来是一篇阅读理解，我对着代码中那个诡异的find_down函数的异或猜了半个小时~~还是发电的模拟了10min~~后才看出来这个题面，为了纪念一下这道题目，写篇题解（雾）。



可以发现本题就是方格取数的进阶版本，那我们可以这样考虑设计状态：



设 $dp_{i,j,k,t}$ 的意义为当骰子滚到 $(i,j)$ 时骰子的正上方面的编号为 $k$ ，正前方编号为 $t$ 的最大值。因为当一个骰子被确定两面时，它的状态就是固定的。（可以自己试着模拟一下）于是我们就可以对于每一个已经被确定的 $dp_{i,j,k,t}$ ，去更新它下方与右方的点。对于骰子的状态我们则可以~~大 力 打 表~~转移。



dp方程：
$$
\left\{
\begin{aligned}
dp_{i+1,j,back(t),k}&=\max(dp_{i,j,back(t),k},dp_{i,j,k,t}+w_t\times a_{i+1,j})\\
dp_{i,j+1,back(rightface(k,t)),t}&=\max(dp_{i,j+1,back(rightface(k,t)),t},dp_{i,j,k,t}+w_{rightface(k,t)}\times a_{i,j+1})
\end{aligned}
\right.
$$
其中 $back(t)$ 表示编号为 $t$ 的面的正方体所对的反面（例如 $Front$ 对应 $Back$ ）， $rightface(k,t)$ 表示当正方体上表面为 $k$ ，前表面为 $t$ 时右表面的编号（如 $fightface(Up,Front)$ 就对应 $Right$ ）。

因为我代码写的是默认从 $1$ 开始，这里放张图便于理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/h9yd2vus.png)

总体时间复杂度 $O(6^2\times nm)$ 。代码写的比较简洁，因为考场上~~深受异或毒害~~。



AC code:

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+10;
const int INF=0x3f3f3f3f;
int a[maxn][maxn];
int dp[maxn][maxn][7][7];
int w[7];
/*
设dp[i][j][k][t]为滚到a[i][j]时立方体的上表面编号为k，前表面编号为t时的最大数值 
根据图，可知立方体的初始放置方式为w5朝上，w1朝前 
由dp[i][j][k][t]可以推出dp[i+1][j]与dp[i][j+1]的新值 
*/
enum surface
{
	Front=1,Back,Left,Right,Up,Down
};
int back[7]={0,2,1,4,3,6,5};
int rightface[7][7];
void rfinit()
{
	rightface[1][6]=4,rightface[1][4]=5,rightface[1][5]=3,rightface[1][3]=6;
	rightface[2][6]=3,rightface[2][3]=5,rightface[2][5]=4,rightface[2][4]=6;
	rightface[3][5]=2,rightface[3][2]=6,rightface[3][6]=1,rightface[3][1]=5;
	rightface[4][5]=1,rightface[4][1]=6,rightface[4][6]=2,rightface[4][2]=5;
	rightface[5][1]=4,rightface[5][4]=2,rightface[5][2]=3,rightface[5][3]=1;
	rightface[6][1]=3,rightface[6][3]=2,rightface[6][2]=4,rightface[6][4]=1;
}
int main()
{
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=6;i++)
		cin>>w[i];
	memset(dp,-INF,sizeof(dp));
	rfinit(); 
	dp[1][1][5][1]=a[1][1]*w[6];
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=6;k++)
			{
				for(int t=1;t<=6;t++)
				{
					if(!rightface[k][t])
						continue;
					if(dp[i][j][k][t]!=-INF)
					{
						dp[i+1][j][back[t]][k]=max(dp[i+1][j][back[t]][k],dp[i][j][k][t]+w[t]*a[i+1][j]);
						dp[i][j+1][back[rightface[k][t]]][t]=max(dp[i][j+1][back[rightface[k][t]]][t],dp[i][j][k][t]+w[rightface[k][t]]*a[i][j+1]);
					}
				}
			}
		}
	}
	int ans=-INF;
	for(int i=1;i<=6;i++)
		for(int j=1;j<=6;j++)
			ans=max(ans,dp[n][m][i][j]);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：卷王 (赞：1)

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P8488)

自己理解一下吧，略。

## 大体思路

显而易见可以想出是 dp。

dp 的转移方程和含义大佬们都讲得很清楚了，我不细讲。不过我会讲一些细节问题。

我们看一看 Lucas_Long 大佬的原话：

> 显然，当确定了一个骰子的两个面时，就可以确定这个骰子，因此我们可以将暴力 dp 降维。

有人问我为什么只要两个面就能确定整个立方体呢？其实要根据后面的内容。

上面根据他的 $b$ 数组确定了下面，同理，前面确定了后面。又得根据 $r$ 数组，于是，由上面和前面通过 $r$ 数组就知道了右面。

其中 $b$ 和 $r$ 数组都要打表，$b$ 还好，但是 $r$ 要打很多，所以会觉得很烦人。但是如果你仔细看的话，会发现规律。画一个立方体，由于我们知道上方和前方，那么每次确定上方的一个面（共 $6$ 个面），分情况考虑，再按照可能在前方的 $4$ 个面（也就是与上方那个面相邻的面），依次模拟即可。即使你是小学生，只要空间想象还行，是完全可以模拟出来的（但我不保证你 dp 能写出来）qwq。

为了让大家更好的理解代码和思路，我的有些数组用了比较具体的英文，而且都有中文解释。代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int F = 1, B = 2, L = 3, R = 4, U = 5, D = 6; //六个方向 
//		  front  back   left   right  up     down
int n, m, w[7];
int a[1007][1007];
int dp[1007][1007][7][7];
int reverse_side[1007]; //一个面的反面 
int UF_to_R[1007][1007]; //知道上方和前方，求右方 
//upfront_to_right
//dp[i][j][k][l] 表示现在在 (i,j) 且骰子上方编号为 k，前方编号为 l 时的最大值 
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}
inline void sw(int x, int y, int z) { UF_to_R[x][y] = z; }
inline void init_reverse_side() {
	reverse_side[F] = B;
	reverse_side[B] = F;
	reverse_side[L] = R;
	reverse_side[R] = L;
	reverse_side[U] = D;
	reverse_side[D] = U;
}
inline void init_UF_to_R() { //自己画个立体图就知道了 
	//假设原立体图的前面（F）在上面 
	sw(F, L, D);
	sw(F, D, R);
	sw(F, R, U);
	sw(F, U, L);
	//假设原立体图的后面（B）在上面 
	sw(B, L, U);
	sw(B, U, R);
	sw(B, R, D);
	sw(B, D, L);
	//假设原立体图的左面（L）在上面 
	sw(L, F, U);
	sw(L, U, B);
	sw(L, B, D);
	sw(L, D, F);
	//假设原立体图的右面（R）在上面 
	sw(R, F, D);
	sw(R, D, B);
	sw(R, B, U);
	sw(R, U, F);
	//假设原立体图的上面（U）在上面 
	sw(U, F, R);
	sw(U, R, B);
	sw(U, B, L);
	sw(U, L, F);
	//假设原立体图的下面（D）在上面 
	sw(D, F, L);
	sw(D, L, B);
	sw(D, B, R);
	sw(D, R, F);
}
int main() {
	n = read(), m = read();
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			a[i][j] = read();
	for(int i = 1; i <= 6; i++) w[i] = read();
	init_reverse_side(); init_UF_to_R();
	memset(dp, -0x3f, sizeof(dp)); //由于要求最大值，所以赋值为极小值 
	dp[1][1][5][1] = a[1][1] * w[6]; //原先 5 在上面，1 在前面，6 在下面 
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			for(int k = 1; k <= 6; k++)
				for(int l = 1; l <= 6; l++) {
					if(UF_to_R[k][l] == 0) continue; //如果两个编号无法同时是上面和前面，则跳过 
					if(dp[i][j][k][l] == -0x3f3f3f3f) continue; //未更新，也跳过 
					//更新两个状态，是 “我到哪里去”的思路 
					dp[i + 1][j][reverse_side[l]][k] = max(dp[i + 1][j][reverse_side[l]][k], dp[i][j][k][l] + a[i + 1][j] * w[l]);
					//上面的是往前翻 
					dp[i][j + 1][reverse_side[UF_to_R[k][l]]][l] = max(dp[i][j + 1][reverse_side[UF_to_R[k][l]]][l], dp[i][j][k][l] + a[i][j + 1] * w[UF_to_R[k][l]]);
					//上面的是往右翻 
				}
	int num = -0x3f3f3f3f;
	for(int i = 1; i <= 6; i++)
		for(int j = 1; j <= 6; j++)
			num = max(num, dp[n][m][i][j]);
	cout << num;
	return 0;
}
```

看完这份代码，你有没有发现什么规律呢？

---

## 作者：haozinojc (赞：0)

这道题是为数不多的让我同时体验了爆空间和超时的题目。

## 思路：

在这道题中，通过骰子的运动方式，我们不难联想到[方格取数](https://www.luogu.com.cn/problem/P1004)这类题。

那么对于这种题，我们有个通用的 $dp$ 思路，就是比较骰子是从上面来到这个格子还是从左边来到这个格子所得分数最大。

故最基础的动态转移方程为：$dp_{i,j}=\max(dp_{i-1,j},dp_{i,j-1})+a_{i,j}$。

不过这道题还需要考虑骰子的面，这也是本题一个比较难受人的点。

对于一个骰子，我们只需要随便知道两个面（不能是相对的），就可以确定骰子各个面的方向，因此我们给数组再开两维，用于确定整个骰子。

搞定之后，剩下的就是模拟了，通过给出的两个面来模拟出骰子的右面和正面，就可以进行反转操作了（说的轻巧，写一写就知道有多难受了）。

最后，枚举一遍骰子的各个状态来确定最终答案。

**最后的最后，数组莫开大，记得用快读，否则迎接你的就是 $MLE$ 或 $TLE$。**

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5,M=7;
int a[N][N],f[N][N][M][M],w[M],n,m,ans=-1e9;
int down(int x,int y){
	if(x==0){
		if(y==2)return 4;
		else if(y==3)return 5;
		else if(y==4)return 3;
		else if(y==5)return 2;
	}
	else if(x==1){
		if(y==2)return 5;
		else if(y==3)return 4;
		else if(y==4)return 2;
		else if(y==5)return 3;
	}
	else if(x==2){
		if(y==0)return 5;
		else if(y==1)return 4;
		else if(y==4)return 0;
		else if(y==5)return 1;
	}
	else if(x==3){
		if(y==0)return 4;
		else if(y==1)return 5;
		else if(y==4)return 1;
		else if(y==5)return 0;
	}
	else if(x==4){
		if(y==0)return 2;
		else if(y==1)return 3;
		else if(y==2)return 1;
		else if(y==3)return 0;
	}
	else if(x==5){
		if(y==0)return 3;
		else if(y==1)return 2;
		else if(y==2)return 0;
		else if(y==3)return 1;
	}
	return 6;
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
	}
	for(int i=0;i<6;i++)scanf("%d",&w[i]);
	memset(f,-0x3f,sizeof(f));
	f[1][1][0][3]=a[1][1]*w[5];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
		 	if(i==1&&j==1)continue;
		 	for(int nx=0;nx<6;nx++){
		 		for(int ny=0;ny<6;ny++){
		 			int hh=down(nx,ny);
	 				if(hh==6)continue;
	 				int tx=nx,ty=-1;
	 				if(hh==5)ty=4;
	 				if(hh==4)ty=5;
	 				if(hh==3)ty=2;
	 				if(hh==2)ty=3;
	 				if(hh==1)ty=0;
	 				if(hh==0)ty=1;
	 				int td=down(tx,ty);
	 				f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i][j-1][nx][ny]+a[i][j]*w[td]);
	 				ty=ny,tx=-1;
	 				if(hh==5)tx=4;
	 				if(hh==4)tx=5;
	 				if(hh==3)tx=2;
	 				if(hh==2)tx=3;
	 				if(hh==1)tx=0;
	 				if(hh==0)tx=1;
	 				td=down(tx,ty);
	 				f[i][j][tx][ty]=max(f[i][j][tx][ty],f[i-1][j][nx][ny]+a[i][j]*w[td]);
				}
			}
	 	}
	}
	 
	for(int i=0;i<6;i++){
		for(int j=0;j<6;j++)ans=max(ans,f[n][m][i][j]);
	}
	printf("%d",ans);
	return 0;
}

```


---


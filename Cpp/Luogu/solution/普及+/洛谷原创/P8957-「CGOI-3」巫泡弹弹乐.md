# 「CGOI-3」巫泡弹弹乐

## 题目背景

mc 正在挑战弹弹乐。

![](https://cdn.luogu.com.cn/upload/image_hosting/yaye0cgu.png)

## 题目描述

弹弹乐由 $n$ 个弹力菇组成，每个弹力菇有 $a,b$ 两个属性。

对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\max(a_i,a_j)+\max(b_i,b_j)$ 的双向弹力通道。现在 mc 想知道弹力菇组成的图的最小生成树，以便他打破记录。

## 说明/提示

#### 数据范围

**「本题采用捆绑测试」**

$$\def{\arraystretch}{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & n\le 500 & \text{无} & 20 \cr\hline
2 & n\le 5\times 10^4 & \text{无} & 20\cr\hline
3 & \text{无特殊限制} & \text{数据随机} & 20\cr\hline
4 & \text{无特殊限制} & \text{无} & 40 \cr\hline
\end{array}$$

- 对于 $100\%$ 的数据，满足：$1\le n\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
3
1 2 1
3 2 3```

### 输出

```
9
1 2
1 3```

# 题解

## 作者：MCRS_lizi (赞：5)

贪心思路，简洁明了。

## 题目分析
我们都~~应该~~学过最小生成树的计算方式，这里就不多讲了。

我们考虑一个点一个点的加入进来，这样肯定会和之前某个点产生连接，最简单的贪心思路就是使这条新产生的连边尽可能小就可以了。由于加入点的顺序并不会产生影响，我们不妨按数列 $a$ 从小到大排序，这样加入第 $i$ 个点时数列 $a$ 产生的贡献一定是 $a_i$，这时只需要考虑数列 $b$ 产生的贡献即可。

其实我们只需要找到已经加入的点之中对应 $b_i$ 最小的那个，与其连边即可。这个直接记录之前的最小值即可。

问题来了，怎么证明这个贪心思路的正确性？

首先我们令数列 $A,B$ 分别为 $a,b$ 从小到大排完序后的结果。

很显然，数列 $a$ 产生的贡献就是 $\sum_{i=2}^n A_i$，并且这个贡献值是对于 $a$ 可以取到的最小贡献。

那么对于数列 $b$，我们每加入一个新的 $b_i$，无非有两种情况：

1. 比数列中最小的大，只会计算一次；
2. 比数列中最小的小，不计算，替代最小的，在之后被计算一次后丢弃。

考虑到 $B_1$ 不可能被计算，贡献依然是 $\sum_{i=2}^n B_i$。

这道题就算是搞定了。

## CODE：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
struct edge
{
	int u,v;
}l[1000010];
struct num
{
	int a,b,xh;
}p[1000010],minn;
bool cmp(num u,num v)
{
	return u.a<v.a;
}
signed main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].a;
		p[i].xh=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].b;
		p[i].xh=i;
	}
	sort(p+1,p+n+1,cmp);
	minn=p[1];
	for(int i=2;i<=n;i++)
	{
		ans+=p[i].a;
		num u=minn;
		ans+=max(u.b,p[i].b);
		if(p[i].b<minn.b)
		{
		    minn=p[i];
		}
		l[i].u=p[i].xh,l[i].v=u.xh;
	}
	cout<<ans<<"\n";
	for(int i=2;i<=n;i++)
	{
		cout<<l[i].u<<" "<<l[i].v<<"\n";
	}
 	return 0;
}

```


---

## 作者：irris (赞：2)

## Preface

贪心。

## Solution

如果只有数列 $a$，将其升序排序，我们知道能产生的代价最小值就是 $\sum\limits_{i=2}^n a_i$。

> **证明**：因为这是一棵树，所以代价排序后的第 $k$ 小的最小值是 $a_{k+1}$，如果更小，则无法构成一棵树，因为前 $k$ 条边仅联通了 $\leq k$ 个节点。

现在有了数列 $b$。我们不妨让 $a$ 数列依旧对答案贡献它能产生的代价最小值，而排序后不难发现，**这其实就是 $\bm i$ 向 $\bm{[1, i - 1]}$ 内任选一条边即可**。考虑 $b$ 数列。贪心地考虑这个问题，我们不需要管到底谁大，只要让选的这条边对应的 $b$ 是前缀最小即可，这样答案一定不劣。

那么怎么证明这个最优呢？我们有两种证法：

> **证明 1**：我们试图证明这样做，对于 $b$ 数列产生的也是代价最小值。
> + 显而易见地，如果某一次的 $b_i$ 不是前缀最小值，它只会被计算一次，此后也不会有向它连的边；
> + 否则它是前缀最小值，它在第一次连的时候不会被计算，但在之后被计算的时候，它同样会被新的前缀最小值替代。
> 
> 于是我们就证明了这是最优解。

---

> **证明 2**：还是放到前缀最小上去看，如果我们把 $1$ 看做树根的话，那么只有这些 $b$ 前缀最小的节点有叶子节点（除非它是 $a$ 最大，$b$ 最小），其它的节点都是连向了一个 $a, b$ 都比本身小的父亲，并只有一条连向父亲的边，也就是只会被计算一次。\
> 对于为了让这个节点和整棵树联通来说，这条边是不劣的，没有比它代价更小的边了。\
> 对于剩下的节点，形成了一个 $a$ 不降，$b$ 不增的序列，显然按照我们的顺次连边方式，可以做到代价最小（排序后都是最大的 $n - 1$ 个值，根据上文，这是最优的）。\
> 两个最优拼起来，当然还是最优。

其实证明 1 就是考场上我的思路，证明 2 就是官方题解。

可能大家互相看对方都觉得有点烦不太自然吧。但是两种做法本质上是殊途同归的其实。

无论如何，这题做完了，时间复杂度瓶颈在排序。

## Code

```cpp
#include <bits/stdc++.h>

#define MAXN 1000001
struct Node { int a, b, id; const bool operator < (const Node& k) const { return a < k.a; } } T[MAXN];

std::vector<std::pair<int, int>> vec;
int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	int N, p = 1; std::cin >> N;
	for (int i = 1; i <= N; ++i) T[i].id = i;
	for (int i = 1; i <= N; ++i) std::cin >> T[i].a;
	for (int i = 1; i <= N; ++i) std::cin >> T[i].b;
	std::sort(T + 1, T + N + 1);
	long long ans = 0;
	for (int i = 2; i <= N; ++i) {
		vec.push_back({i, p}), ans += T[i].a + std::max(T[i].b, T[p].b);
		if (T[i].b < T[p].b) p = i;
	}
	std::cout << ans << '\n';
	for (int i = 0; i < N - 1; ++i) 
		std::cout << T[vec[i].first].id << ' ' << T[vec[i].second].id << '\n';
	return 0;
}
```

---

## 作者：wuzr (赞：2)

贪心地考虑，将每个点 $i$ 向点 $j$ 满足 $a_j\le a_i,b_j\le b_i$ 连边，连完边之后将点 $i$ 删掉，因为点 $j$ 一定比点 $i$ 更优。

我们可以钦定每个点 $i$ 连向以 $a_j$ 为第一关键字，$b_j$ 为第二关键字排序后的第一个满足条件的点。

我们发现贪心连边之后剩下点的序列，是一个排序后 $a$ 单调递增，$b$ 单调递减的序列，将排序后相邻的两点连边一定最优。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i=l, _=r; i<=_; ++i)
using namespace std;
const int N = 1e6 + 5;
struct Point {
	int a, b, id;
} p[N];
int n, m = 1, u[N][2], tot;
long long ans;
int main() {
	scanf("%d", &n);
	rep(i, 1, n) scanf("%d", &p[i].a);
	rep(i, 1, n) scanf("%d", &p[i].b), p[i].id = i;
	sort(p + 1, p + n + 1, [](Point x, Point y) {return x.a != y.a ? x.a < y.a : x.b < y.b;});
	rep(i, 2, n)
	if (p[i].b >= p[m].b) u[++tot][0] = p[m].id, u[tot][1] = p[i].id, ans += p[i].b + p[i].a;
	else p[++m] = p[i];
	rep(i, 2, m) u[++tot][0] = p[i - 1].id, u[tot][1] = p[i].id, ans += max(p[i - 1].a, p[i].a) + max(p[i - 1].b, p[i].b);
	printf("%lld\n", ans);
	rep(i, 1, tot) printf("%d %d\n", u[i][0], u[i][1]);
	return 0;
}
```


---

## 作者：Tjaweiof (赞：1)

# P8967 题解
[题目传送门](https://www.luogu.com.cn/problem/P8957)

首先容易发现边权和 $\ge\sum(a_i+b_i)-\min a_i-\min b_i$。即，$a$ 从小到大排序后第 $2$ 个到第 $n$ 个的和加 $b$ 从小到大排序后第 $2$ 个到第 $n$ 个的和。

按照 $a$ 的值从小到大排序，然后考虑每一个 $i\ge2$，$i$ 与使 $b_j$ 的值最小的 $j(j<i)$ 连边。这样产生的树边权和达到 $\sum(a_i+b_i)-\min a_i-\min b_i$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in", "r", stdin);freopen(x".out", "w", stdout);
int n, mink = 1;
long long min1 = 1e9, min2 = 1e9, ans;
pair <pair <long long, long long>, int> a[1000001];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a[i].first.first;
		ans += a[i].first.first;
		min1 = min(min1, a[i].first.first);
		a[i].second = i;
	}
	ans -= min1;
	for (int i = 1; i <= n; i++){
		cin >> a[i].first.second;
		ans += a[i].first.second;
		min2 = min(min2, a[i].first.second);
	}
	ans -= min2;
	cout << ans << "\n";
	sort(a + 1, a + n + 1);
	for (int i = 2; i <= n; i++){
		cout << a[mink].second << " " << a[i].second << "\n";
		if (a[i].first.second < a[mink].first.second){
			mink = i;
		}
	}
	return 0;
}

```

---

## 作者：dci66666 (赞：0)

有趣的思维（构造）题。

对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\max(a_i,a_j)+\max(b_i,b_j)$ 的双向弹力通道。

这个题目有 $a_i$ 和 $b_i$ 两个变量，有点难办。不妨先考虑只有一个变量 $a_i$。

如果只有一个变量，由于边数恒定为 $n-1$ 条，所以可以让权值最小的点连上所有点，这样最优。

可以用反证法证明：假设有更有的边由 $i$ 指向 $j$，且其中没有权值最小的点（点 $i$ 已经加入最小生成树内，而 $j$ 没有，设 $k$ 为最小权值点），那么有 $\max(a_i,a_j) \ge\max(a_k,a_j)$，当且仅当 $a_i\le a_j$ 时取等，故假设不成立。

所以根据以上贪心思想，想想怎么扩展至二元。

显然，我们的策略可以使除了最小权值点以外的所有点权全部贡献一次，可以证明不存在更有解（因为无论最小权值点给谁连边都不会有自己的贡献）。只要我们将两元各自尽力保持这个性质就可以算是最优。

对于第一维 $a_i$ 我们可以排序处理，可以保证在非最小点连边时自己无论连上任意点时一定会贡献一次，这样一定可以保持最优的性质。对于第二维，我们考虑贪心地将所有点插到当前 $b_i$ 最小的点。我们可以惊奇地发现，由于这样做肯定不会使 $a_i$ 的答案劣，但是 $b_i$ 一定是优的。

考虑以下情况：当前已连的点假设是最优的，也就是说除了里面最小的权值点外其他所有点都产生了贡献。我们当前操作的点如果比所有已连的点都小时连上最小值可以维护最优的性质，使之前的最优点产生贡献。否则大于等于当前最小权值时连上最小点自己贡献一次也能维护最优性质。总之，最后的序列也一定满足最优的性质。

所以我们最后可以保证 $a_i$ 和 $b_i$ 都有最优的性质，答案一定最优，随便维护一下就行了。

下面是代码，没有看懂的可以看代码再理解一下：
```cpp
#include<bits/stdc++.h>
using namespace std;//很短的代码（
const int N=1e6+50;
struct node{
	int a,b,id;
	friend bool operator<(const node &x,const node &y){
		if(x.a!=y.a)return x.a<y.a;
		return x.id<y.id;
	}
}t[N];
int n;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return x*f;
}
struct Edge{
	int u,v;
}edge[N];
int minb,minid,tot;
#define ll long long
ll ans=0;
int main(){
	n=read(); 
	for(int i=1;i<=n;i++)t[i].a=read(),t[i].id=i;
    for(int i=1;i<=n;i++)t[i].b=read();
    sort(t+1,t+1+n);
    minb=t[1].b,minid=t[1].id;
    for(int i=2;i<=n;i++){
    	edge[++tot]={t[i].id,minid};
    	ans+=t[i].a+max(minb,t[i].b);
		if(t[i].b<minb){
    		minid=t[i].id;minb=t[i].b;
		}
	}
	printf("%lld\n",ans);
	for(int i=1;i<=tot;i++){
		printf("%d %d\n",edge[i].u,edge[i].v);
	}
    return 0;
}
```

---

## 作者：JackMerryYoung (赞：0)

# 前言

诈骗 T2。

~~但是由于被 T1 卡了 2.5h 所以没写完（）~~

# 正文

考虑先按 $a, b$ 顺序作关键字排升序，把 $a_i < a_j$ 且 $b_i < b_j$ 的 $j$ 连向 $i$。这样子一定不劣。

然后剩下的 $K$ 个蘑菇一定 $a$ 上升 $b$ 下降，所以直接相邻两个连起来即可。

复杂度 $\mathcal{O}(N \log_2 N)$，瓶颈在于排序和读入。

# 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define rll register ll

ll N;

struct Rushmoon { // Mushroom
    ll a, b, num;
} arr[2000005];

bool operator < (Rushmoon lhs, Rushmoon rhs) 
{
    return lhs.a != rhs.a ? lhs.a < rhs.a : lhs.b < rhs.b;
}

ll ans = 0;

vector< pair<ll, ll> > edge;

signed main()
{
    scanf("%lld", &N);
    for(ll i = 1; i <= N; ++ i) 
        scanf("%lld", &arr[i].a), arr[i].num = i;
    
    for(ll i = 1; i <= N; ++ i) 
        scanf("%lld", &arr[i].b), arr[i].num = i;

    sort(arr + 1, arr + N + 1);
    int cnt = 1;
    for(int i = 2; i <= N; ++ i)
    {
        if(arr[i].b >= arr[cnt].b)
        {
            edge.push_back(make_pair(arr[i].num, arr[cnt].num));
            ans += (arr[i].a + arr[i].b);
        }
        else
        {
            arr[++ cnt] = arr[i];
        }
    }
    
    for(int i = 1; i < cnt; ++ i)
    {
        edge.push_back(make_pair(arr[i].num, arr[i + 1].num));
        ans += (max(arr[i].a, arr[i + 1].a) + max(arr[i].b, arr[i + 1].b));
    }

    printf("%lld\n", ans);
    for(auto i : edge)
        printf("%lld %lld\n", i.first, i.second);

    return 0;
}
```

# 后言

感谢【丑国】题森出题组提供的优质题目！

---

## 作者：Saka_Noa (赞：0)

不妨考虑弱化版只有 $a$ 这一维的问题。

考虑 `Prim` 的过程，我们维护一个点集 $S$，每次向外连一条代价最小的边。很自然的想到将 $a$ 排序，从小到大选择点对，这样答案是 $\sum _{i=2}^n a_i$。

加上 $b$ 这一维，我们仍然按 $a$ 排序，这样就可以不考虑 $a$ 这一维对答案的贡献。维护点集 $S$，这时的最小出边是满足 $b_j = \min_{i \in S} b_i $ 的 $j$ 向枚举到的点的连边。

这样每个最大值只会贡献一次，贡献是 $\sum_{i=2}^n b_i$。


关键代码

```cpp

	fin >> n;
    ll ans = 0, ma = 1e9, mb = 1e9;
    for(int i=1;i<=n;++i) fin >> d[i].a, ans += d[i].a, ma = min(ma, (ll)d[i].a), d[i].id = i;
    for(int i=1;i<=n;++i) fin >> d[i].b, ans += d[i].b, mb = min(mb, (ll)d[i].b);
    ans -= ma + mb;
    sort(d + 1, d + n + 1, [](node a, node b) {return a.a < b.a; });
    fout << ans << "\n";
    int id = 1;
    for(int i=2;i<=n;++i) {
      fout << d[id].id << " " << d[i].id << endl; 
      if(d[id].b > d[i].b) id = i;
    }
    
```

---

## 作者：sbno333 (赞：0)

这道题其实不需要什么高深的算法，但是你需要知道意思(会的可以跳过)：

* 树：若一个图有 $n$ 个点，有 $n-1$ 条边，且连通（无向图），则我们称这是一个树。
* 生成树：去掉一个图的一些边（点不变），而且最后形成了一个树，则我们称这是这个图的一个生成树。
* 最小生成树：边的权值之和最小的生成树。

虽然有求最小生成树的算法，但我们不需要。

不难发现，除了某一个节点以外每个点都至少延伸 $1$ 条边。

由于它说 $\max(a_i,a_j)+\max(b_i,b_i)$ 最小，因此点 $i$ 延伸的边至少为 $a_i+b_i$。

我们可以让每个点都延伸一条边，对于 $a_i$，我们可以排序，延伸至 $a_j<a_i$ 时的 $j$，对于 $b_i$，我们可以延伸到之前最小的 $b_j$，可以通过打擂台来求最小值，当然，是筛到几，就打到几，时间复杂度 $O(n)$。
# $CODE$
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tt{
	long long a,b,t;//排序用
}s[1000009];
long long mi;
long long mii;
long long ans;
long long bb[1000009][2];
bool cmp(tt a1,tt a2){
	return a1.a<a2.a;
}
int main(){
	long long n;
	scanf("%lld",&n);//输入
	for(long long i=1;i<=n;i++){
		scanf("%lld",&s[i].a);
	}
	for(long long i=1;i<=n;i++){
		scanf("%lld",&s[i].b);
		s[i].t=i;
	}
	sort(s+1,s+1+n,cmp);//按 a 排序
	mi=s[1].b;
	mii=1;
	for(long long i=2;i<=n;i++){
		ans+=s[i].a;//延伸至a小的边
		ans+=max(s[mii].b,s[i].b);//延伸至之前b的最小值
		bb[i-1][0]=s[mii].t;//记录边
		bb[i-1][1]=s[i].t;
		if(s[i].b<mi){//记录b的最小值
			mi=s[i].b;
			mii=i;
		}
	}
	
	printf("%lld\n",ans);
	for(long long i=1;i<n;i++){//输出
		printf("%lld %lld\n",bb[i][0],bb[i][1]);
	}
	return 0;
} 
```

---


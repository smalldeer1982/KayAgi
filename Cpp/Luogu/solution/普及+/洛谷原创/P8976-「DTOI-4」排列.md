# 「DTOI-4」排列

## 题目背景

**Update on 2023.2.1：新增一组针对 @[yuanjiabao](https://www.luogu.com.cn/user/455558) 的 Hack 数据，放置于 #21。**

**Update on 2023.2.2：新增一组针对 @[CourtesyWei](https://www.luogu.com.cn/user/664070) 和 @[bizhidaojiaosha](https://www.luogu.com.cn/user/613616) 的 Hack 数据，放置于 #22。**

------------

~~构造一个排列 $p$，使得~~$\small\color{white}{下标为奇数的项之和 \geq a 且下标为偶数的项之和 \geq b。}$

## 题目描述

小 L 给你一个**偶数** $n$ 和两个整数 $a, b$，请你构造一个长为 $n$ 的排列 $p$，使得其满足 $\displaystyle\sum_{i = 1}^{\frac{n}{2}} p_i \geq a$ 且 $\displaystyle\sum_{i = \frac{n}{2} + 1}^{n} p_i \geq b$。

## 说明/提示

**本题开启 Special Judge。**

| $\textbf{Subtask}$ | $n$ | $a, b$ | 分值 |
| :------: | :------: | :------: | :------: |
| $1$ | $2 \leq n \leq 10$ | 无特殊限制 | $20 \operatorname{pts}$ |
| $2$ | 无特殊限制 | $a = b = 0$ | $10 \operatorname{pts}$ |
| $3$ | 同上 | $a = 0$ 或 $b = 0$ | $10 \operatorname{pts}$ |
| $4$ | 同上 | 无特殊限制 | $60 \operatorname{pts}$ |

对于 $100\%$ 的数据，$2 \leq n, \sum n \leq 10^5$，$0 \leq a, b \leq \frac{n(n + 1)}{2}$，$1 \leq T \leq 10$，$n$ 为**偶数**。

## 样例 #1

### 输入

```
2
6 6 12
6 8 14```

### 输出

```
1 6 2 5 3 4
-1```

# 题解

## 作者：是青白呀 (赞：8)

## P8976 「DTOI-4」排列
### update 2023/2/2 添加了一个例子便于理解
### 题目描述

给你一个**偶数** $n$ 和两个整数 $a, b$，请你构造一个长为 $n$ 的排列 $p$，使得其满足 $\displaystyle\sum_{i = 1}^{\frac{n}{2}} p_i \geq a$ 且 $\displaystyle\sum_{i = \frac{n}{2} + 1}^{n} p_i \geq b$。无解则输出 $-1$。

### 思路分析
要将长度为 $n$ 的排列分为两部分，分别满足两个不小于某个值的条件，则在考虑其中一个条件时，一定要尽可能使另一个条件能被得到满足。

在本题中，在考虑区间 $\left[1,\frac{n}{2} \right] $ 时，要使该区间和等于 $a$，才能使后半部分区间和大于等于 $b$ 的条件尽可能被满足。于是考虑如何选取 $\frac{n}{2}$ 个数使得其和为 $a$。首先我们容易知道，可以使得和为 $a$ 的条件为 $a \in \left[\frac{n(1+\frac{n}{2})}{4},\frac{n(\frac{n+1}{2}+n)}{4} \right]$，其中左右边界分别对应取 $\left[1,\frac{n}{2} \right] $ 的所有数和取 $\left[\frac{n+1}{2},n \right] $ 的所有数的情况。考虑先选 $\left[1,\frac{n}{2} \right] $ ，此时 $sum=\frac{n(1+\frac{n}{2})}{4}$。考虑将已选择的数替换为更大的数。为了避免替换时发生重复，每一次将已选中的 $\left[1,\frac{n}{2} \right] $ 中最大的数 $maxn$ 替换为 $maxn+\frac{n}{2}$，则每替换一次，$sum$ 的值增加 $\frac{n}{2}$。则我们共需操作 $\lfloor \frac{a-sum}{\frac{n}{2}} \rfloor$ 次，并将下一个 $maxn$ 替换为 $maxn+(a-sum) \mod \frac{n}{2}$ 的值。这样可以保证所选择的数不重复。最后再判断剩余数的和是否满足大于等于 $b$ 即可。

为了便于理解，这里举一个例子。
```
1
8 23 13
```
一开始我们选中的是这些数：
```
1 2 3 4
```
此时 $sum=10$，太小了，与目标 $a=23$ 的差值为 $13$。接下来进行上述替换操作。
```
1 2 3 8
1 2 7 8
1 6 7 8
```
此时的 $sum$ 为 $22$。到此，我们共操作了 $\lfloor \frac{a-sum}{\frac{n}{2}} \rfloor$ 次，即 $3$ 次，每一次都让 $sum$ 的值增加了 $4$。若再操作一次使 $1$ 变成 $5$，$sum$ 的值就会超过 $a$，不满足我们的贪心策略，进而使后四个数不小于 $b$ 的要求无法满足。所以我们将最后一个 $maxn$ 替换为 $maxn+(a-sum) \mod \frac{n}{2}$，使得 $sum=a$。代入数据发现，在这里我们应将 $1$ 替换为 $2$。则最后的序列为：
```
2 6 7 8 1 3 4 5
```
恰好满足条件。

这里需要注意，$a<\frac{n(1+\frac{n}{2})}{4}$ 不意味着无解，在这种情况下直接判断 $b$ 与 $\frac{n(\frac{n+1}{2}+n)}{4}$ 的关系即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int t;
signed main(){
	int t;
	read(t);
	while(t--){
		int n,a,b;
		read(n),read(a),read(b);
		int sum=(1+n/2)*n/4;
		if(sum>=a){//a选择1~n/2
			if((1+n)*n/2-sum<b)printf("-1\n");
			else{
				for(int i=1;i<=n;i++)
				    printf("%d ",i);
				printf("\n");
			}
			continue;
		}
		int movnum=(a-sum)/(n/2);//增加n/2的次数
		if(movnum>n/2||(movnum==n/2&&(a-sum)%(n/2))){//总操作次数不能大于n/2
			printf("-1\n");
			continue;
		}
		bool vis[N]={};//标记哪些数属于前半部分
		int suma=0;
		for(int i=1;i<(n/2)-movnum;i++)
		    suma+=i,vis[i]=1;
		suma+=(n/2)-movnum+(a-sum)%(n/2);
		vis[(n/2)-movnum+(a-sum)%(n/2)]=1;
		for(int i=(n/2)-movnum+1;i<=n/2;i++)
		    suma+=i+n/2,vis[i+n/2]=1;
		if((1+n)*n/2-suma<b)printf("-1\n");
		else{
		    for(int i=1;i<=n;i++)
		    	if(vis[i])printf("%d ",i);
		    for(int i=1;i<=n;i++)
		    	if(!vis[i])printf("%d ",i);
		    printf("\n");
		}
	}
	return 0;
}

```


---

## 作者：lcbridge (赞：6)

**前言：** 蒟蒻第一篇题解，~~赛时调了很久终于A了，发篇题解纪念一下~~，应该思路比较与众不同吧？

**前置知识：** 

排列：一个长度为 $n$ 的排列是指在一个数列中 $1-n$ 这几个数都仅出现一次（本人语文不好，请谅解）。

举个例子，长度为 $5$ 的排列可以是：

$1\ 2\ 3\ 4\ 5$ 或 $1\ 3\ 2\ 4\ 5$ 或 $3\ 2\ 4\ 5\ 1$。

而 $1\ 2\ 4\ 2\ 5$ 就不是一个排列。

好的，相信大家对排列已经明白了（~~实际上大家肯定都明白~~）。

接下来开始分析题目：

**题目大意：**

请构造出一个排列 $p$，满足排列的前一半之和大于等于 $a$，后一半之和大于等于 $b$。

**分析：**

首先，一个长度为 $n$ 的排列，无论数字如何排列，它和一定为  $\sum\limits_{i=1}^na_i$，~~那这不是小学就学过~~它的和就是 $\frac{(1+n)\times n}{2}$ 吗？~~这不需要[解释](https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527418?fr=aladdin)吧~~？

那么，不就可以判断无解了吗？

即 $a+b>\sum\limits_{i=1}^na_i$，这很好理解，就是指 $a$ 与 $b$ 之和已经大于这个排列的和，那显然构造不出来，所以我们就可以愉快的输出 $-1$ 了。

但是不可以总司令！这显然是不够的,因此我们需要想想到底该如何构造。

我们不妨以这种思路来想想。

首先将 $p_i$ 就设为 $i(1\le i\le  n)$，代码如下：

```cpp
for(int i=1;i<=n;i++)p[i]=i;
```


那假如这个排列已经满足要求 (Subtask 2) 就如此，那直接输出就完事。

如果不满足要求，我们就只需要思考如何交换排列中两半中的值即可。

好的，那我们如何交换当前排列中两半左右的值呢？

我们先算出一个 $d$ 表示，在 $p_i=i$ 的情况下，排列中前一半与满足条件的 $a$ 相差多少，最开始将 $d$ 设为 $a$，然后从 $1-n/2$ 循环，每次将 $d-p_i(1\le i\le  n/2)$，代码如下：

```cpp
int d=a;
for(int i=1;i<=n/2;i++)d-=p[i];
```

- 如果 $d\le0$ 那么说明前一半本身就满足条件，只需判断后一半是否之和是否大于 $b$ 即可。

如果大于 $b$ 成功构造出一组排列，输出即可，否则输出 $-1$ 表示无解，那这里为什么不去考虑交换呢？因为当前的排列本身就是 $p_i=i(1\le i\le n/2)$ 所以前一半一定是排列中前 $n/2$ 小的数，后一半一定是排列中后 $n/2$ 大的数，所以后面的和一定是所有排列中最大的方案了，无论怎么交换，只会使得后面的和变小，因此，肯定无解。

- 如果 $d>0$ 就说明需要交换左右两边的元素，让大的变小，小的变大，直至满足要求。

那么考虑如何实现这一过程？

首先两边交换的最大值一定为 $p_n-p_1$ 对吧，第二大值一定为  $p_{n-1}-p_2$ 对吧。

那我们考虑贪心策略。每次如果 $d$ 大于 $p_{n-k+1}-p_k$，那 $d$ 就减去它，并交换 $p_{n-k+1}$ 和 $p_k$，直到 $d$ 减去 $p_{n-k+1}-p_k$ 小于 $0$ 为止，$d$ 减去 $p_{n-k+1}-p_k$ 小于 $0$ 后，我们就考虑如何交换剩下位置中左右两边差为 $d-p_{n-k+1}-p_k$ 的值，那如何快速交换呢？我们定义一个 $len$ 表示第 $k$ 次后结束，左右两个区间剩下的长度。


上面这段话的意思就如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/bcplh9vh.png)

- 如果 $d \ge len \times 2$ 说明无论怎么交换都无法满足要求，输出 $-1$，无解。

- 如果 $d>len$ 那就可以交换第 $cnt$ 和 $cnt+d$ 位满足要求，因为第 $cnt$ 位和第 $cnt+d$ 位正好可以使得 $d$ 减少 $d$，使得 $d$ 正好满足要求。

- 如果 $d \le len$ 那就可以交换 $p_{n/2}$ 和 $p_{n/2+d}$，如上图中交换第 $3$ 位和第 $4$ 位可以满足要求，交换后排列就为 $6\ 2\ 4\ 3\ 5\ 1$ 满足要求，之所以这样做也是让 $d$ 减去 $d$ 正好等于 $a$ 但是因为 $d\le len$，因此第二条操作就不行了。

记得开 ```long long```！


所以，综上代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long//#define int long long qwq!
using namespace std;
int T,n,p[100005],a,b;
signed main(){ //#define int long long过后主函数改成signed
	scanf("%lld",&T);  //T组测试数据 
	while(T--){
		scanf("%lld%lld%lld",&n,&a,&b); //读入 
		for(int i=1;i<=n;i++)p[i]=i; //初始化排列 
		int d=a; //将d设为a 
		for(int i=1;i<=n/2;i++)d-=p[i]; //每次将d-p[i]算出与a相差多少 
		int cnt=1; //第cnt位 
		while(d>0&&cnt<=n/2){ //贪心的每次减去当前最大值 
			if(d-(p[n-cnt+1]-p[cnt])<=0)break; //如果减去已经小于等于0就退出 
			d-=(p[n-cnt+1]-p[cnt]);
			swap(p[cnt],p[n-cnt+1]); //交换cnt位与n-cnt+1为 
			cnt++;
		}
		int len=n/2-cnt+1;
		if(len*2<=d){
			printf("-1\n");//无法满足要求 
			continue;
		}
		if(d>len)swap(p[cnt],p[cnt+d]); //交换cnt与cnt+d 
		if(d<=len&&d>0)swap(p[n/2],p[n/2+d]);//交换n/2与n/2+d
		int tmp1=0;
		for(int i=n/2+1;i<=n;i++)tmp1+=p[i];//算后一半是否满足要求 
		if(tmp1>=b)for(int i=1;i<=n;i++)printf("%lld ",p[i]);//找到合法解，输出 
		else printf("-1");//后一半无法满足要求 
		printf("\n");
	}
    return 0;
}
```




---

## 作者：Leasier (赞：5)

~~应该没有人发现题目背景里的东西就是彩蛋吧？~~

设 $S_1(n) = \displaystyle\sum_{i = 1}^n i = \frac{n(n + 1)}{2}$。

当 $a + b > S_1(n)$ 时显然无解。否则我们分 $a < b$ 和 $a \geq b$ 讨论，两种情况本质相同，下面我们以 $a < b$ 为例。

当左半部分填 $1 \sim \frac{n}{2}$ 都不能满足右半部分的要求即 $S_1(n) - S_1(\frac{n}{2}) < b$ 时显然无解。

否则，我们分两类讨论：

- $S_1(\frac{n}{2}) \geq a$：左半部分填 $1 \sim \frac{n}{2}$，右半部分填 $\frac{n}{2} + 1 \sim n$ 即可。
- $S_1(\frac{n}{2}) < a$：左半部分先填上 $1 \sim \frac{n}{2}$，然后把左半部分每个数都加上 $\lfloor \frac{a - S_1(\frac{n}{2})}{\frac{n}{2}} \rfloor$，再把左半部分的后 $(a - S_1(\frac{n}{2})) \bmod \frac{n}{2}$ 个数都加一，右半部分填上剩下的数即可。此时左半部分之和恰好为 $a$，右半部分之和为 $S_1(n) - a \geq b$，符合条件。

综上，时间复杂度为 $O(\sum n)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

int ans[100007];
bool vis[100007];

inline ll sum1(int n){
	return (ll)n * (n + 1) / 2;
}

int main(){
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++){
		int n;
		ll a, b, t1;
		scanf("%d %lld %lld", &n, &a, &b);
		t1 = sum1(n);
		if (a + b > t1){
			printf("-1\n");
			continue;
		}
		int m = n / 2;
		if (a < b){
			ll sum = sum1(m);
			if (t1 - sum < b){
				printf("-1\n");
				continue;
			}
			for (int j = 1; j <= m; j++){
				ans[j] = j;
			}
			if (sum < a){
				ll t2 = (a - sum) / m;
				a = (a - sum) % m;
				for (int j = 1; j <= m; j++){
					ans[j] += t2;
				}
				for (ll j = 1; j <= a; j++){
					ans[m - j + 1]++;
				}
			}
		} else {
			ll sum = t1 - sum1(m);
			if (sum < a){
				printf("-1\n");
				continue;
			}
			for (int j = 1; j <= m; j++){
				ans[j] = n - j + 1;
			}
			if (t1 - sum < b){
				ll t2 = (sum - a) / m;
				a = (sum - a) % m;
				for (int j = 1; j <= m; j++){
					ans[j] -= t2;
				}
				for (ll j = 1; j <= a; j++){
					ans[m - j + 1]--;
				}
			}
		}
		for (int j = 1; j <= n; j++){
			vis[j] = false;
		}
		for (int j = 1; j <= m; j++){
			vis[ans[j]] = true;
		}
		for (int j = m + 1, k = 1; j <= n; j++, k++){
			while (vis[k]) k++;
			ans[j] = k;
		}
		for (int j = 1; j <= n; j++){
			printf("%d ", ans[j]);
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Jeefy (赞：2)

# DTOI-4 排列

## 题意简述

通过 $1 \sim n$ 这 $n$ 个数，构造出一个**没有重复数字**的排列，满足排列前半段的和 $\ge a$，后半段的和 $\ge b$。

## 解题分析

很明显，这是一个~~简单的~~贪心构造题。

我们考虑先满足前半段的要求。

为了保证后半段尽量大，要保证前半段在满足条件的情况下尽量小。也就是说构造出一个和最小的，满足和 $\ge a$，且最大值不超过 $n$ 的无重复序列。

例如样例中的 $a = 6$，我们可以构造出满足要求的 `1 2 3`，对于 $a = 8$，我们可以构造出 `1 2 5`。

考虑到整个排列的和是一定的，那么保证的前半段的正确性后，后半段的和也就确定了。我们就可以借此判断有无合法的解了。

最后，记录一下前半段用过的数，后半段输出没有用过的数就ok了。

**参考代码**：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

constexpr int N = 1e5 + 7;

void proc() {
	static int p[N];
	long long n, a, b;
	long long sum, k, top, tot;
	scanf("%lld %lld %lld", &n, &a, &b);
	// sum记录前半段的和，k记录前半段的长度，tot记录整个排列的总和
	sum = 0, k = n / 2, top = n, tot = (1 + n) * n / 2;
	// 先构造出最小的，再在此基础上构造满足条件的
	for (int i = 1; i <= k; ++i) {
		p[i] = i, sum += i;
	}
	// need指我们需要增加的大小
	long long need = a - sum;
	if (need > 0) {
		// 为了满足不重复，我们从大的开始向上加，并记录可以加到的最大值
		for (int i = k; i && need; --i) {
			// top - i 指对于 i 这个数，最多可以加到什么位置
			if (top - i < need) {
				need -= top - i;
				sum += top - i;
				p[i] = top--;
			} else /* top - i > need */ { // 并不需要加到最大值
				sum += need;
				p[i] = i + need;
				need = 0;
			}
		}
	}
	
	// 判断是否合法
	if (need > 0 || tot - sum < b) {
		puts("-1");
		return;
	}
	
	static char exi[N];
	memset(exi, 0, sizeof(char) * (2 + n));
	// 记录并输出前半段的数
	for (int i = 1; i <= k; ++i) {
		printf("%d ", p[i]);
		exi[p[i]] = true;
	}
	
	// 输出所有没有出现过的数（后半段）
	for (int i = 1; i <= n; ++i) {
		if (!exi[i]) printf("%d ", i);
	}
	puts(""); // 换行！
}

int main() {
	int T;
	scanf("%d", &T);
	while (T--) {
		proc();
	}
	return 0;
}
```




---

## 作者：Yuki__S2OO8 (赞：2)

若 $a+b>\sum\limits_{i=1}^n i$ 显然无解。

我们先把 $1\sim \dfrac{n}{2}$ 填到左边，剩下的到右边。

考虑维护两个指针 $l,r$。

$l$ 从 $1$ 移到 $\dfrac{n}{2}$，$r$ 从 $n$ 移到 $\dfrac{n}{2} + 1$。

表示选择 $a,b$ 中的两个交换，前提是交换后还能满足左边和大于等于 $a$，右边和小于等于 $b$。

若不满足，则交替移动 $l,r$，否则就让两个指针同时向里移。

最后再判断一下合不合法即可。

```
    cin >> n >> a >> b;
    if (a + b > (1 + n) * n / 2)
    {
        cout << "-1\n";
        return;
    }
    int _1 = 0, _2 = 0;
    for (int i = 1;i <= n / 2;i++)
    {
        _1 += i;
    }
    for (int i = n / 2 + 1;i <= n;i++)
    {
        _2 += i;
    }
    for (int i = 1;i <= n;i++)
    {
        ans[i] = i; 
    }
    l = 1, r = n;
    bool flag = 1;
    while (l <= n / 2 && r > n / 2)
    {
        if (_2 - (r - l) >= b && _1 + (r - l) <= a)
        {
            swap(ans[l], ans[r]);
            _2 -= (r - l);
            _1 += (r - l);
            l++, r--;
        }
        else
        {
            if (flag)
            {
                r--;
            }
            else l++;
            flag ^= 1;
        }
    }
    _1 = 0, _2 = 0;
    for (int i = 1;i <= n / 2;i++)
    {
        _1 += ans[i];
    }
    for (int i = n / 2 + 1;i <= n;i++)
    {
        _2 += ans[i];
    }
    if (_1 >= a && _2 >= b)
    {
        for (int i = 1;i <= n;i++)
        cout << ans[i] << ' ';
        cout << '\n';
    }
    else cout << "-1\n";
```

---

## 作者：fzark (赞：1)

### 前言


------------

看了一圈题解好像没有思路和我的一样，这里就写一个简单易懂的新思路吧

### 题目大意


------------

要求构造一个长度为 $n$ 的排列 $p$，使得
$$∑_{i=1}^{\frac n 2} \geq a,∑_{i= \frac n 2}^{n} \geq b$$
如果无解则报告 $-1$

### 思路


------------

首先假设我们要构造的排列，初始时单调递增，即：
$$1,2,3,4,...,n$$
设 $a_1$ 为左半部分，$a_2$ 为右半部分。~~不难发现~~ 我们发现，只需要进行： 
$$\operatorname{swap}(a_1[n-1],a_2[0]),\operatorname{swap}(a_1[n-2],a_2[0])...\operatorname{swap}(a_1[0],a_2[0])$$

(下面约定索引 $i,j$ 从 $0$ 开始)\
我们会发现每进行一次上述的 $\operatorname{swap}(a_1[i],a_2[j])$ 操作时，数组 $a_1$ 的总和值就会 $+1$，当然，与之变化的是 $a_2$ 的总和值会 $-1$。并且，当上诉操作达到 $j = 0$ 的时候 $i =0$，我们会发现 $a_1$ 的总和值会 $+n$ ，并且我们此时可以让 $j + 1$ 后 $i = len(a_1)$，然后继续循环直到 $j = len(a_2)$ 或者说 $sum(a_1)$ 的值到达 $a$

举个例子：

假设需要我们构造一个长度为 $8$ 的排列(此时先把注意力从 $a$ 和 $b$ 的约束中移除，重点关注构造的方式)

```python
初始时，排列为：
  1,2,3,4,5,6,7,8
设:
  a1 = 1,2,3,4;
  b1 = 5,6,7,8
  
让我们从 i = len(a1) - 1,j = 0 开始，进行swap
i = 3，j = 0 时，进行交换：
a1 = 1,2,3,5
b1 = 4,6,7,8

此时 a1 的总和值 + 1

i = 2，j = 0 时，进行交换：
a1 = 1,2,4,5
b1 = 3,6,7,8

此时 a1 的总和值 + 1（总体 + 2，后面就不额外说明了）

i = 1，j = 0 时，进行交换
a1 = 1,3,4,5
b1 = 2,6,7,8

此时 a1 的总和值 + 1

i = 0，j = 0时，进行交换
a1 = 2,3,4,5
b1 = 1,6,7,8

此时 a1 的总和值 + 1

这个时候 i 到达 0 时，我们可以将 j 指针转移到 1，并且 i 重新设为 0，继续上述操作，我们总能证明在每次交换后，a 的值恒加 1
```
### 证明


------------

为什么上面的每一次 $\operatorname{swap}$ 操作可以使得 $a_1$ 的总和值恒加 $1$ 呢？因为对于每一次交换而言，我们都贪心的去找到 $a_2$ 中的某个元素 $x$，和 $a_1$ 中的某个元素 $y$ 满足
$$|x - y| = 1，x \gt y$$
例如： 

```
在 i = 3，j = 0 中：
a1 = 1,2,3,4
a2 = 5,6,7,8
```
此时，$a_2$ 中比 $4$ 大 $1$ 的元素一定是 $5$ 。因为已经假设初始时排列单调递增，且是从中间将排列划分成两半的。\
当我们进行第一次交换后，会变成：
```
a1 = 1,2,3,5
a2 = 4,5,6,7
```
此时我们会发现，在 $a_1$ 中只有元素 $3$ 和 $a_2$ 中的元素 $4$ 差值为 $1$，且满足上面所提到的贪心策略。于是我们可以不断重复上述的操作，且每次操作，都能保证 $a_1$ 的总和值恒 $+1$ 了。

并且因为两个数组都是 **单调递增** 的原因，所以按照上述的操作，总能满足我们所说的贪心策略。


有了这个重要的结论，代码也很好写了

### 实现代码


------------


```python
def solve():
    n,a,b = map(int,input().split())
    # 初始时分成两半，分别设为 a1 和 a2
    a1 = []
    a2 = []
    for i in range(1,n//2 + 1):a1.append(i)
    for i in range(n//2 + 1, n + 1):a2.append(i)
    # 提前计算 a1 和 a2 的总和值
    suma1 = 0
    suma2 = 0
    for i in range(n // 2):
        suma1 += a1[i]
        suma2 += a2[i]
    i = j = 0
    while suma1 < a:
        # 按照已有的结论进行构造
        a1[len(a1) - 1 - i],a2[j] = a2[j],a1[len(a1) - 1 - i]
        suma1 += 1
        suma2 -=1
        i += 1
        if i == len(a1) - 1:
            i = 0
            j += 1
        # 当j到底或 suma1 的值已经满足a时则退出
        if j == len(a2) - 1:break
    # 如果不满足，则无解
    if suma1 < a or suma2 < b:
        print(-1)
        return
    ans = a1+a2
    for i in range(n):
        print(ans[i],end=' ')
    print()

for i in range(int(input())):solve()
```
### 时间复杂度 

------------
最坏的情况为：设 $x$ 为 $\frac n 2$，则有 $O(x^2)$

即最坏情况是将排列 $reverse$

例如：\
$1,2,3,4,5,6$\
最坏情况：\
$6,5,4,3,2,1$

---

## 作者：E1_de5truct0r (赞：1)

来一个带悔贪心。

srds，我感觉我做法繁了，要不然就这个带悔贪心而言肯定不止橙。

另外这道题风格很 CF，如果我给个评分我大概给 1700~1800 左右。

## 思路

首先显然 $a+b>\dfrac{n(n+1)}{2}$ 一定无解。

否则我们需要去尝试构造才能知道。为了简洁，这里令 $mid=\left\lfloor\dfrac{n}{2}\right\rfloor$。

首先容易发现的是 $\forall x \in \left[\dfrac{mid(mid+1)}{2},\dfrac{mid(mid+n+1)}{2}\right]$，一定可以通过 $mid$ 个数的和求出来。

那么我们只需要凑出恰好为 $a$ 的，同时看一下剩下的是否 $\geq b$ 即可。

那么怎么做呢？

不妨先把左半部分放上 $1,2,\dots,mid$，右半部分放上 $mid+1,mid+2,\dots,r$。

然后我们求出左半部分的和 $sum$，如果已经 $\geq a$ 了那么直接退出。

否则，假设 $a$ 和 $sum$ 的差为 $D$，这一部分我们就需要放更大的数来弥补。显然，最优方法是我们第 $x$ 步可以把最大的数 $n-x+1$ 和最小的数 $x$ 交换，然后我们的差就减少了 $n-2x+1$。

假设进行了多次操作之后，当前位于 $i$，我们发现差小于了 $n-2i+1$，那么我们就只能和 $i+D$ 做交换。分成两种情况：

1. $i+D>mid$：此时，又因为 $i+D<n-i+1$ 所以不会在之前被交换到左半边，因此一定在右半边，于是我们直接交换即可。

2. $i+D\leq mid$：这个时候发现要交换的也在左半边。不过不用慌，因为容易发现 $i+D+1 \leq mid+1$，即 $i+1 \leq mid+1-D$，所以 $mid+1-D$ 不会在之前被交换到右边，一定在左边。所以我们只需要交换 $mid+1$ 和 $mid+1-D$ 即可。

于是我们精准的凑出了左侧的 $a$，那么此时右边一定是可能的最大值，直接判断即可。

吐槽：这题不忽略行末空格我调了半天/oh/hsh

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int MAXN=100005; 
int a[MAXN];

void solve(){
	int n,A,B; cin>>n>>A>>B;
	if(A+B>n*(n+1)/2) return cout<<-1<<'\n',void();
	for(int i=1;i<=n;i++) a[i]=i;
	
	int sum=0,cur=1;
	for(int i=1;i<=n/2;i++) sum+=a[i];
	if(sum<A){
		for(int i=n;i>=1;i--){
			if(sum+a[i]-a[n-i+1]>=A){
				int need=A-sum+a[n-i+1];
//				cout<<"need="<<need<<'\n';
				if(need<=n/2) swap(a[n/2+1-A+sum],a[n/2+1]);
				else swap(a[n-i+1],a[need]);
				break;
			}
			else{
				sum+=a[i]-a[n-i+1];
				swap(a[i],a[n-i+1]);
			}
		}
	}
	
	int ssum=0; sum=0;
	for(int i=1;i<=n/2;i++) sum+=a[i];
	for(int i=n/2+1;i<=n;i++) ssum+=a[i];
	if(ssum<B || sum<A) return cout<<-1<<'\n',void();
	for(int i=1;i<n;i++) cout<<a[i]<<' ';
	cout<<a[n]<<'\n';
}

signed main(){
	int T; cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：AfterFullStop (赞：1)

首先，这题的做题策略能确定下来：先判有无解，若有解则构造 $\sum\limits^{\frac{n}{2}}_{i=1}p_i=a$ ，这样在有解的条件下一定是能保证 $\sum\limits^{n}_{i=\frac{n}{2}+1}p_i \le b$ 的，原因显然。

考虑无解的情况：

- 总和加起来都不够 $a$ 和 $b$ 分配的（即 $\sum\limits^{n}_{i=1}p_i<a+b$ 。由于 $p$ 是排列，因此 $\sum\limits^{n}_{i=1}p_i=\sum\limits^{n}_{i=1}i=\dfrac{n(n+1)}{2}$  )
- 给 $b$ 分的最少了还不够 $a$ 用（即 $\dfrac{n(n+1)}{2}-\dfrac{\frac{n}{2} \times (\frac{n}{2}+1)}{2} = \dfrac{3n^2+2n}{8} < a$ ）

- 给 $a$ 分的最少了还不够 $b$ 用（即 $\dfrac{3n^2+2n}{8} < b$ ）

显然，当这些情况排出后，剩下的一定有解。

考虑构造 $\sum\limits^{\frac{n}{2}}_{i=1}p_i=a$  。

以 $n=6$ 为例，先弄出一个单调上升的排列：

 $$[1,2,3,4,5,6]$$ 
 
接着把 $2,3,4,5,6$ 向前挪一格， $1$ 挪到最后面：

 $$[2,3,4,5,6,1]$$ 
 
容易发现此时前半部分总和增加了 $\dfrac{n}{2}$ 。

证明也十分简单：原排列 $p_{i+1}=p_i+1$ ，向左挪一位就是 $p'_i=p_i+1$ ，一位上加一， $\dfrac{n}{2}$ 位自然加 $\dfrac{n}{2}$ 。

于是，构造的方法就出来了：先用 $\dfrac{a-\sum\limits^{\frac{n}{2}}_{i=1}i}{\frac{n}{2}}$ 判断要移动几次。等移完之后再从前 $\dfrac{n}{2}$ 项中找一项和第 $\dfrac{n}{2}+1$ 项交换使得 $\sum\limits^{\frac{n}{2}}_{i=1}p_i=a$  ，这部分你可以算但也可以暴力找（毕竟查一遍也查完了）。

于是这题就解出来了。

代码不放，需要者私我。

---


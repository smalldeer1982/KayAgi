# 「LAOI-1」小熊游景点

## 题目描述

小熊的地图上有 $n$ 个景点，每个景点有分数 $s_i$。

$n-1$ 个点对之间有双向直达的公交线路，每条线路有收费 $w_i$。

现在小熊在 $a$ 景点，总司令在 $b$ 景点，他们要**沿简单路径**在 $a\to b$ 路径上的 $p$ 景点汇合，然后**沿简单路径**一起去 $q$ 景点。（$q$ 为任意点，每个人不会游览两次 $p$ 景点）

$m$ 次询问，给定 $a,b$，求 $p,q$，使得小熊和总司令花费之和最小的前提下他们经过的景点分数之和最大，输出他们经过的景点分数之和。（指小熊经过的景点分数之和 $+$ 总司令经过的景点分数之和）

**重复经过的线路收费重复计算，重复经过的景点分数重复计算。**

## 说明/提示

### 样例说明
对于第一组样例，小熊的地图如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ktyzyrx7.png)

其中 $a=4,b=7$，令 $p=3,q=6$。

小熊的路径为 $4\to2\to1\to3\to6$，花费之和为 $1+3+6+(-4)=6$，景点分数之和为 $1+1+1+1+1=5$。

总司令的路径为 $7\to3\to6$，花费之和为 $5+(-4)=1$，景点分数之和为 $1+1+1=3$。

小熊和总司令花费之和为 $6+1=7$，经过的景点分数之和为 $5+3=8$。

可以证明此时小熊和总司令花费之和最小的前提下他们经过的景点分数之和最大。

------------

### 数据范围
**本题采用捆绑测试。**

| Subtask | $n,m$ | $s_i,w_i$ | 特殊性质 | 分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $=3\times10^5$ | $\in\lbrack0,10^6\rbrack$ | 无 | $10$ |
| $2$ | $=3\times10^5$ | $\in\lbrack-10^6,10^6\rbrack$ | 小熊的地图是一条链 | $10$ |
| $3$ | $=3\times10^2$ | $\in\lbrack-10^6,10^6\rbrack$ | 无 | $5$ |
| $4$ | $=3\times10^3$ | $\in\lbrack-10^6,10^6\rbrack$ | 无 | $15$ |
| $5$ | $\le 3\times10^5$ | $\in\lbrack-10^6,10^6\rbrack$ | 无 | $60$ |

对于 $100\%$ 的数据，$1\le n,m\le 3\times 10^5$，$\vert s_i\vert,\vert w_i\vert\le10^6$，小熊的地图是一棵树。

（小熊都可以游览景点了，公交价格和景点分数怎么不可以是负数呢？）

## 样例 #1

### 输入

```
7 1
1 1 1 1 1 1 1
1 2 3
3 6 -4
2 5 2
1 3 6
2 4 1
3 7 5
4 7```

### 输出

```
8```

## 样例 #2

### 输入

```
10 10
786755 -687509 368192 154769 647117 -713535 337677 913223 -389809 -824004 
1 2 -785875
1 3 -77082
1 4 -973070
3 5 -97388
2 6 -112274
3 7 657757
4 8 741733
3 9 5656
4 10 -35190
3 3
3 10
7 3
5 1
2 10
10 10
1 6
7 2
8 9
9 1
```

### 输出

```
971424
-1257332
1309101
3420605
-2313033
-2567048
-2467802
352646
759321
1368370
```

# 题解

## 作者：OrezTsim (赞：9)

首先 $a \rightarrow b$ 的路径上的点和边肯定都会遍历到。

显然最终集合点 $p$ 会被遍历两次，其他路径上的点均为一次。

接着，$p \rightarrow q$ 的路径上，$p$ 已经被遍历了，故不算入答案，其余点都计算两次。

现在的问题就很简单了：因为要求走的路径最短，既然 $a \rightarrow b$ 的路径已经确定了，那么这条路径的边权和与点权和就已经确定，接着就只要维护从路径上的每个点出发，能够得到的最小边权和与此时的最大点权和。

这个东西可以通过树形 DP 来解决。

- 维护当前点向自己的子树内走，能形成的最小边权和与此时的最大点权和。设该 DP 数组为 $son_i$。因为从当前点前往自己的子树，肯定只会走一条链，从自己的儿子转移过来即可。

- 维护当前点向自己的父亲走，能形成的最小边权和与此时的最大点权和。设该 DP 数组为 $fa_i$。此时又分为两种情况：

	- 往当前点的父亲走，随后往当前点的兄弟走：如果暴力枚举复杂度会炸，但枚举的时候，每次肯定贪心选取所有兄弟中最优的，所以开个 vector 存一下当前点父亲的所有儿子的 $son$ 数组，排好序，取最优的即可。如果取到自己就取次优的即可。

    - 往当前点的父亲走，随后往当前点父亲的父亲走：此时直接从父亲的 $fa$ 数组转移过来就行。


那么每次询问就相当于在 $a \rightarrow b$ 的路径上倍增。

思想很简单，但是细节比较多，我写的时候遇到的问题大概是以下几点：

- 维护 DP 数组的时候，初始值很重要，不要弄错。

- 树上跳祖先的时候 $1$ 的父亲不是 $0$，跳的时候判一下（我在深搜的时候喜欢把 $1$ 号节点的父亲弄成 $0$，这个是我的问题）。

- `#define int long long` 会导致巨大的常数，从而 TLE。

大概就是这些了，具体看代码，有点长。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define ll long long
#define pii pair <int, int>
#define pll pair <ll, ll>
using namespace std;

template <typename T> inline void read(T &x) {
    x = 0; char ch = getchar(); int f = 1;
    while (!isdigit(ch) && ch ^ '-') ch = getchar();
    if (ch == '-') f = -1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    return x *= f, void();
}

template <typename T, typename ...Args>
inline void read(T &x, Args &...args) { read(x), read(args...); }

const int N = 3e5 + 10;
int n, q, s[N], dep[N], fa[19][N]; ll pt[N];
pll ch[N], fav[N], all[N], Maxi[19][N];
vector <pii> g[N], val[N];

inline void dfs0(int cur, int f) {
    fa[0][cur] = f, ch[cur] = {0, s[cur]};
    dep[cur] = dep[f] + 1, pt[cur] = pt[f] + s[cur];
    for (int i = 1; i < 19; ++i) fa[i][cur] = fa[i - 1][fa[i - 1][cur]];
    if (g[cur].size() == 1 && (*g[cur].begin()).fi == f) return ;
    for (auto it: g[cur]) {
    	int to = it.fi, v = it.se;
        if (to == f) continue; dfs0(to, cur);
        if (ch[to].fi + v < ch[cur].fi || (ch[to].fi + v == ch[cur].fi && ch[to].se + s[cur] > ch[cur].se))
            ch[cur] = {ch[to].fi + v, ch[to].se + s[cur]};
    }
    for (pii it: g[cur]) {
    	int to = it.fi, v = it.se;
		if (to ^ f) val[cur].push_back({ch[to].fi + v, -ch[to].se - s[cur]});
	}
	sort(val[cur].begin(), val[cur].end());
}

inline void dfs1(int cur, int f, int eval) {
    pll ffa = {0, s[cur]}; all[cur] = ch[cur];
    if (f) {
    	pll tmp = {fav[f].fi + eval, fav[f].se + s[cur]};
    	if (tmp.fi < ffa.fi || (tmp.fi == ffa.fi && tmp.se > ffa.se)) ffa = tmp;
        if (val[f].size() > 1) {
        	pll fs = val[f][0];
        	if (fs.fi == ch[cur].fi + eval && fs.se == -ch[cur].se - s[f]) fs = val[f][1];
            fs.se = -fs.se, fs.fi += eval, fs.se += s[cur];
            if (fs.fi < ffa.fi || (fs.fi == ffa.fi && fs.se > ffa.se)) ffa = fs;
        }
    }
    fav[cur] = ffa;
    if (ffa.fi < all[cur].fi || (ffa.fi == all[cur].fi && ffa.se > all[cur].se)) all[cur] = ffa;
    for (pii it: g[cur]) {
    	int to = it.fi, v = it.se;
		if (to ^ f) dfs1(to, cur, v);
	}
}

inline void dfs2(int cur, int f) {
    Maxi[0][cur] = {all[cur].fi, 2 * all[cur].se - s[cur]};
    for (int i = 1; i < 19; ++i) {
        pll lef = Maxi[i - 1][cur], rig = Maxi[i - 1][fa[i - 1][cur]];
        if (lef.fi ^ rig.fi) Maxi[i][cur] = min(lef, rig);
        else Maxi[i][cur] = (lef.se > rig.se? lef : rig);
    }
    for (pii it: g[cur]) {
    	int to = it.fi, v = it.se;
		if (to ^ f) dfs2(to, cur);
	}
}

inline int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 18; ~i; --i) if (dep[fa[i][u]] >= dep[v]) u = fa[i][u];
    if (u == v) return u;
    for (int i = 18; ~i; --i) if (fa[i][u] ^ fa[i][v]) u = fa[i][u], v = fa[i][v];
    return fa[0][u];
}

inline void solve() {
    int beg, ed, lc;
    read(beg, ed), lc = lca(beg, ed);
	ll res = pt[beg] + pt[ed] - pt[lc] - pt[fa[0][lc]];
    pll Maxcur = Maxi[0][lc];
    for (int i = 18; ~i; --i) {
    	if (!fa[i][beg] || dep[fa[i][beg]] + 1 < dep[lc]) continue;
	    pll lef = Maxcur, rig = Maxi[i][beg];
	    if (lef.fi != rig.fi) Maxcur = min(lef, rig);
	    else Maxcur = (lef.se > rig.se? lef : rig);
	    beg = fa[i][beg];
    }
    for (int i = 18; ~i; --i) {
		if (!fa[i][ed] || dep[fa[i][ed]] + 1 < dep[lc]) continue;
        pll lef = Maxcur, rig = Maxi[i][ed];
        if (lef.fi != rig.fi) Maxcur = min(lef, rig);
        else Maxcur = (lef.se > rig.se? lef : rig);
        ed = fa[i][ed];
    }
    return printf("%lld\n", res + Maxcur.se), void();
}

int main() {
    read(n, q); for (int i = 1; i <= n; ++i) read(s[i]);
    for (int i = 1, u, v, w; i < n; ++i)
        read(u, v, w), g[u].push_back({v, w}), g[v].push_back({u, w});
    dfs0(1, 0), dfs1(1, 0, 0), dfs2(1, 0);
    while (q--) solve();
    return 0;
}
```

---

## 作者：5k_sync_closer (赞：8)

出题人题解。

设 $x(u,v)$ 为 $u\to v$ 路径边权和，$y(u,v)$ 为 $u\to v$ 路径点权和。

题目中求 $x(a,p)+x(b,p)+2x(p,q)=x(a,b)+2x(p,q)$ 最小的前提下 $y(a,p)+y(b,p)+2y(p,q)-2s_p=y(a,b)+2y(p,q)-s_p$ 最大，

$x(a,b),y(a,b)$ 是定值，只需令 $x(p,q)$ 最小的前提下 $2y(p,q)-s_p$ 最大。

考虑对每个 $a\to b$ 路径上的 $p$ 维护出 $x(p,q)$ 最小值以及此时 $2y(p,q)-s_p$ 最大值。

用**换根 DP** 维护之。设 $f_{p,0/1}$ 为 $q$ 在 $x$ 子树内时 $x(p,q)$ 的最小值 / 次小值，则容易得到状态转移方程：

$$
\begin{aligned}
f_{p,0}&=\min(\{f_{q,0}+x(p,q)|q\in son_p\}\cup\{0\})\\
f_{p,1}&=\mathop{\operatorname{secondmin}}(\{f_{q,0}+x(p,q)|q\in son_p\}\cup\{0\})
\end{aligned}
$$

转移时记录 $2y(p,q)-s_p$ 最大值。

设 $g_{p,0/1}$ 为 $x(p,q)$ 的最小值 / 次小值，则 $g_p$ 由 $f_p,g_{fa_p}$ 转移而来，$g_{fa_p}$ 由 $f_{fa_p},g_{fa_{fa_p}}$ 转移而来，$f_{fa_p}$ **可能**由 $f_p$ 转移而来，存在重复计算。

需要记录 $k_p$ 为转移到 $g_p$ 的点，从而消除重复计算。

则有状态转移方程：

$$
\begin{aligned}
g_{p,0}&=\min\{f_{p,0},g_{fa_p,[k_{fa_p}=p]}+x(p,fa_p)\}\\
g_{p,1}&=\mathop{\operatorname{secondmin}}\{f_{p,0},f_{p,1},g_{fa_p,[k_{fa_p}=p]}+x(p,fa_p)\}
\end{aligned}
$$

转移时记录 $2y(p,q)-s_p$ 最大值。

则问题转化为求静态树链最小值，用树上倍增维护之。
```cpp
#include <cstdio>
#include <algorithm>
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
using namespace std;
char buf[1 << 23], *p1 = buf, *p2 = buf, obuf[1 << 23], *O = obuf;
inline int R()
{
    int r = 0;
    bool f = 0;
    char c = getchar();
    while (c < '0' || c > '9')
        f = c == '-', c = getchar();
    while (c >= '0' && c <= '9')
        r = r * 10 + c - '0', c = getchar();
    return f ? -r : r;
}
void P(long long x)
{
    if (x < 0)
        *O++ = '-', x = -x;
    if (x >= 10)
        P(x / 10);
    *O++ = x % 10 + '0';
}
struct S
{
    long long x, y, p;
    S operator+(S b) { return {x + b.x, y + b.y}; }
    bool operator<(S b) const { return x == b.x ? y > b.y : x < b.x; }
} Q, F[300050][2], C[300050][20];
struct E
{
    int v, w, t;
} e[1000050];
int n, m, c, a[300050], d[300050], h[300050], f[300050][20];
long long s[300050];
void A(int u, int v, int w)
{
    e[++c] = {v, w, h[u]};
    h[u] = c;
}
void D1(int u)
{
    for (int i = h[u], v; i; i = e[i].t)
        if (!d[v = e[i].v])
        {
            d[v] = d[u] + 1;
            f[v][0] = u;
            for (int i = 1; f[v][i - 1]; ++i)
                f[v][i] = f[f[v][i - 1]][i - 1];
            s[v] = s[u] + a[v];
            D1(v);
            S X = F[v][0] + S{e[i].w, a[v] << 1};
            X.p = v;
            if (X < F[u][0])
                F[u][1] = F[u][0], F[u][0] = X;
            else if (X < F[u][1])
                F[u][1] = X;
        }
}
void D2(int u, int k)
{
    for (int i = h[u], v; i; i = e[i].t)
        if ((v = e[i].v) != k)
        {
            S X = F[u][F[u][0].p == v] + S{e[i].w, a[u] << 1};
            X.p = u;
            if (X < F[v][0])
                F[v][1] = F[v][0], F[v][0] = X;
            else if (X < F[v][1])
                F[v][1] = X;
            D2(v, u);
        }
}
void D3(int u, int k)
{
    for (int i = h[u], v; i; i = e[i].t)
        if ((v = e[i].v) != k)
        {
            C[v][0] = F[v][0];
            for (int i = 1; f[v][i - 1]; ++i)
                C[v][i] = min(C[v][i - 1], C[f[v][i - 1]][i - 1]);
            D3(v, u);
        }
}
int main()
{
    n = R();
    m = R();
    for (int i = 1; i <= n; ++i)
        a[F[i][0].p = F[i][1].p = i] = R();
    for (int i = 1, u, v, w; i < n; ++i)
        u = R(), v = R(), A(u, v, w = R()), A(v, u, w);
    s[1] = a[1];
    D1(d[1] = 1);
    D2(1, 0);
    for (int i = 1; i <= n; ++i)
        F[i][0].y += a[i], F[i][1].y += a[i];
    C[1][0] = F[1][0];
    D3(1, 0);
    for (int i = 0, x, y, u, v, l, k; i < m; ++i)
    {
        Q = {1000000000000000000ll, 0};
        if (d[u = x = R()] < d[v = y = R()])
            swap(x, y);
        while (d[x] > d[y])
            Q = min(Q, C[x][k = __lg(d[x] - d[y])]), x = f[x][k];
        if (x == y)
            Q = min(Q, C[l = x][0]);
        else
        {
            for (k = __lg(d[x]); k >= 0; --k)
                if (f[x][k] != f[y][k])
                    Q = min({Q, C[x][k], C[y][k]}), x = f[x][k], y = f[y][k];
            Q = min({Q, C[x][0], C[y][0], C[l = f[x][0]][0]});
        }
        P(Q.y + s[u] + s[v] - s[l] - s[f[l][0]]);
        *O++ = '\n';
    }
    fwrite(obuf, O - obuf, 1, stdout);
    return 0;
}
```


---

## 作者：sjr3065335594 (赞：1)

## 题意简述

给定一棵树，每个节点有点权，每条边有边权，每次询问给定两个点 $a,b$，要找到一个在 $a\to b$ 的路径上的点 $p$ 和任意一个点 $q$，使得 $a\to p\to q$ 与 $b\to p\to q$ 的边权之和最小，且在边权最小的情况下，使点权最大。

## 思路

由于我们首先要保证边权之和最小，也就是说，我们找到一个 $p$ 的时候，$q$ 的位置是确定的，就是离 $p$ 最近的那个点，于是我们可以进行树形 dp，求出对于每个 $p$ 所对应的 $q$。在转移过程中，要维护路径最短和次短两个值，也要同时更新点权的最大值。

我们令 $dp_{i,0/1}$ 分别表示当 $p=i$ 时，所能到达的所有点路径的最短和次短值。

转移分为两种：

1. 距离 $p$ 最近的点在 $p$ 的子树内。`dp[u][0]=min(dp[v][0],0)`，$v$ 为 $u$ 的子节点。$dp_{u,1}$ 要同时更新。

2. 距离 $p$ 最近的点不在 $p$ 的子树内，我们就可以找 $p$ 的父节点，根据父节点更新，同时父节点可以根据父节点的父节点更新，这样自下而上不好解决，我们就考虑自上而下，记录每个答案是由哪个节点所转移。

我们计算出每个 $p$ 对应的 $q$ 的花费以及价值，利用树上倍增来求出这些里的花费最小值，并在花费最小时取分数最大即可。

## 代码实现

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mkp(x,y) make_pair(x,y)
using namespace std;
const int N=3e5+5;
const int M=1e6+5;
struct EDGE {
	int v,next,c;
}edge[M];
struct Node {
	ll eval,pval;//eval是边权总和，pval是点权总和
	int id;//id记录是由哪个节点转移
	Node operator + (const Node &rhs) const {
		return (Node){eval+rhs.eval,pval+rhs.pval};
	}
	bool operator < (const Node &rhs) const {
		if(eval==rhs.eval)return pval>rhs.pval;
		return eval<rhs.eval;
	}
}dp[N][2],res[N][30];
int head[N],cnt,n,m,f[N][30],a[N],d[N];
ll sum[N];
void add_edge(int x,int y,int z) {
	edge[++cnt]=(EDGE){y,head[x],z};
	head[x]=cnt;
}
void dfs1(int u) {//dfs求q在p子树里的情况
	for(int i=head[u];~i;i=edge[i].next) {
		int v=edge[i].v;
		if(d[v])continue;
		d[v]=d[u]+1;
		f[v][0]=u;//记录父节点
		for(int j=1;f[v][j-1];j++)
			f[v][j]=f[f[v][j-1]][j-1];//一会倍增用
		sum[v]=sum[u]+a[v];//求一个路径上的和
		dfs1(v);
		Node x=dp[v][0]+(Node){edge[i].c,a[v]<<1};
		x.id=v;
		if(x<dp[u][0]) {//转移最短路
			dp[u][1]=dp[u][0];dp[u][0]=x;
		}
		else if(x<dp[u][1]) {//转移次短路
			dp[u][1]=x;
		}
	}
}
void dfs2(int u,int fa) {//当q不在p的子树内
	for(int i=head[u];~i;i=edge[i].next) {
		int v=edge[i].v;
		if(v==fa)continue;
		Node x=dp[u][dp[u][0].id==v]+Node{edge[i].c,a[u]<<1};//根据是否由子节点转移选择最小和次小值
		x.id=u;
		if(x<dp[v][0]) {
			dp[v][1]=dp[v][0];dp[v][0]=x;
		}
		else if(x<dp[v][1]) {
			dp[v][1]=x;
		}
		dfs2(v,u);
	}
}
void dfs3(int u,int fa) {//树上倍增
	for(int i=head[u];~i;i=edge[i].next) {
		int v=edge[i].v;
		if(v==fa)continue;
		res[v][0]=dp[v][0];//res记录最小值
		for(int j=1;f[v][j-1];j++) {
			res[v][j]=min(res[v][j-1],res[f[v][j-1]][j-1]);
		}
		dfs3(v,u);
	}
}
int main() {
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		dp[i][0].id=dp[i][1].id=i;
	}
	for(int i=1;i<=n-1;i++) {
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	sum[1]=a[1];
	d[1]=1;
	dfs1(1);
	dfs2(1,0);
	for(int i=1;i<=n;i++) {
		dp[i][0].pval+=a[i];
		dp[i][1].pval+=a[i];
	}
	res[1][0]=dp[1][0];
	dfs3(1,0);
	for(int i=1;i<=m;i++) {
		int x,y;
		Node ans={LONG_LONG_MAX,LONG_LONG_MIN};
		scanf("%d%d",&x,&y);
		int u=x,v=y,w;
		if(d[x]<d[y])swap(x,y);
		while(d[x]>d[y]) {
			int k=log2(d[x]-d[y]);
			ans=min(ans,res[x][k]);
			x=f[x][k];
		}
		if(x==y)ans=min(ans,res[w=x][0]);
		else {
			for(int k=log2(d[x]);k>=0;k--) {
				if(f[x][k]!=f[y][k])
					ans=min(ans,min(res[x][k],res[y][k])),
					x=f[x][k],y=f[y][k];
			}
			ans=min(min(ans,res[x][0]),min(res[y][0],res[w=f[x][0]][0]));
		}
		printf("%lld\n",ans.pval+sum[u]+sum[v]-sum[w]-sum[f[w][0]]);//输出答案记得去掉重复和加上应多次计算的数
	}
	return 0;
}



```


---

## 作者：262620zzj (赞：0)

# 核心思路

对于一个 $p$，因为小熊和总司令总要先走到 $p$ 再一起出发，所以不论 $a,b$ 如何分布，最优的 $q$ 是一定的。

那么我们可以把一次询问拆成两部分。$a\to b$ 和 $p\to q$，并且除了 $p$ 点，$p\to q$ 中的分数和距离应当算 $2$ 次（因为 $p$ 点已经在 $a\to b$ 之中被计算了一次）。

# DP 预处理

那么如何求出每个 $p$ 对应的 $q$ 呢？我们可以采用换根 DP 加分类讨论的思想来解决。由于 $p\to q$ 方案是用双关键字比较大小的，比较麻烦，所以我建议咱们先写一个类型，存储方案，并且定义方案之间的大小比较。

```cpp
struct plan{ll dis,sc;};//dis=distance sc=score
inline bool operator > (plan a,plan b){
	if(a.dis!=b.dis)return a.dis<b.dis;
	return a.sc>b.sc;
}
inline plan better(plan a,plan b){return a>b?a:b;}
inline plan better(plan a,plan b,plan c){return better(a,better(b,c));}
```
接下来动态规划。一个点的最优方案有三种。

1. 向儿子走

2. 向父亲走

3. 直接在自己这里结束旅游

定义 $f_u$ 为点 $u$ 往自己子树走的最优方案，$son_u$ 为最优儿子。$f2_u$ 为不考虑最优儿子，剩下的最优方案。$g_u$ 为点 $u$ 往父亲走的最优方案。 $f2$ 需要用于计算 $g$。

换根dp，第一遍算出 $f,f2$，
对于 $f_u$ 枚举每个儿子 $v$，走到 $v$ 后两种情况。
1. 可以选择再向下走，接下来最优方案 $f_v$。
2. 可以直接在 $v$ 结束。

两种方案取最优，所有儿子中再选最好的。$f2_u$ 与 $f_u$ 一致，只是要跳过 $son_u$。

第二遍计算 $g_u$，由父亲转移而来。有三种情况。设父亲为 $p$。

1. 仅从 $u$ 走到 $p$ 结束。

2. 走到 $p$ 再向上走，那么最优解是执行 $g_p$ 的方案。

3. 走到 $p$ 再向 $p$ 的其他儿子，也就是自己的兄弟走。这种情况还要下分两种小情况。

- $u$ 是 $p$ 的最优儿子，那么 $f_p$ 是不可取的，因为不可以走重复路线。退而求其次选择 $f2_p$ 。

- $u$ 不是 $p$ 的最优儿子，直接选择 $f_p$。

最优方案即为 $better(f_u,g_u,\{0,s_u\})$。

# 处理询问

根据上文提到的，一次询问拆分为 $a\to b$ 和 $p\to q$。

$a\to b$ 这部分简单，只需树上差分即可。

最后就是选出 $a\to b$ 路径上最优的 $p$。用 st 表计算出每个点到其 $2^k$ 级祖先的最优方案，询问的时候倍增跳祖先即可。

复杂度 $O((n+m)\log n)$。

# 注意事项

- 点 $p$ 和 $q$ 可以为同一点。不能经过点 $p$ 两次指的是不能走一段再折返回来。

- dp 细节很多，比如说 $u$ 的点权只算一次，但其他的边权、点权都要两次。又或者转移的时候要加上 $u$ 自己的权值和新加入的边的权值。

- $st_{i,j}$ 表示的范围是 $[i,i+2^j)$ 树上倍增的时候，想清楚有没有包含到路径上的每一个点。

- 常数较大，请写出一份优美的代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &x){
	x=0;int f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x*=f;
}
template<typename T,typename ...Args>
inline void read(T &x,Args &...rest){read(x);read(rest...);}
typedef long long ll;
struct plan{ll dis,sc;};
inline bool operator > (plan a,plan b){
	if(a.dis!=b.dis)return a.dis<b.dis;
	return a.sc>b.sc;
}
inline plan better(plan a,plan b){return a>b?a:b;}
inline plan better(plan a,plan b,plan c){return better(a,better(b,c));}
constexpr int N=3e5+5;
constexpr ll INF=1e18;
struct edge{int to,nx,w;}e[2*N];
int head[N],tot=1;
void add_edge(int u,int v,int w){
    e[++tot]={v,head[u],w};
    head[u]=tot;
}
#define repg(i,u,v) for(int i=head[u],v=e[i].to;i;i=e[i].nx,v=e[i].to)
int n,m,s[N],fa[N][20],dep[N],son[N];
plan st[N][20],f[N],g[N],f2[N];
ll path[N];
void dp0(int u,int from){
	path[u]=path[from]+s[u];
    fa[u][0]=from;
    dep[u]=dep[from]+1;
    f[u]=f2[u]={INF,-INF};
    plan z1,z2;
    repg(i,u,v){
        if(v==from)continue;
        dp0(v,u);
        z1={e[i].w*2,s[u]+s[v]*2};
    	z2={f[v].dis+e[i].w*2,f[v].sc+s[u]+s[v]};
        plan z=better(z1,z2);
        if(z>f[u])f[u]=z,son[u]=v;
    }
    repg(i,u,v){
        if(v==from||v==son[u])continue;
        z1={e[i].w*2,s[u]+s[v]*2};
    	z2={f[v].dis+e[i].w*2,f[v].sc+s[u]+s[v]};
        f2[u]=better(f2[u],z1,z2);
    }
}
void dp1(int u,int e0){
	plan z1,z2,z3;
    if(u!=1){
        int p=fa[u][0];
        z1={e[e0].w*2,s[u]+s[p]*2};
        z2={g[p].dis+e[e0].w*2,g[p].sc+s[u]+s[p]};
        if(u==son[p])z3={f2[p].dis+e[e0].w*2,f2[p].sc+s[u]+s[p]};
        else z3={f[p].dis+e[e0].w*2,f[p].sc+s[u]+s[p]};
        g[u]=better(z1,z2,z3);
    }
    else g[u]={INF,-INF};
    repg(i,u,v)if(i^1^e0)dp1(v,i);
}
inline int lca(int u,int v){
    if(dep[u]>dep[v])swap(u,v);
    for(int i=19;i>=0;i--)if(dep[fa[v][i]]>=dep[u])v=fa[v][i];
    if(u==v)return u;
    for(int i=19;i>=0;i--)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];
    return fa[u][0];
}
inline plan select(int u,int v){
    plan res=st[v][0];
    for(int i=19;i>=0;i--)if(dep[fa[u][i]]>=dep[v]){
        res=better(res,st[u][i]);
        u=fa[u][i];
    }
    return res;
}
int main(){
    read(n,m);
    for(int i=1;i<=n;i++)read(s[i]);
    for(int i=1,u,v,w;i<n;i++){
        read(u,v,w);
        add_edge(u,v,w);
        add_edge(v,u,w);
    }
    dp0(1,0);
    dp1(1,0);
    for(int j=1;j<20;j++){
        for(int i=1;i<=n;i++){
            fa[i][j]=fa[fa[i][j-1]][j-1];
        }
    }
    for(int i=1;i<=n;i++)st[i][0]=better((plan){0,s[i]},f[i],g[i]);
    for(int j=1;j<20;j++){
        for(int i=1;i<=n;i++){
            st[i][j]=better(st[i][j-1],st[fa[i][j-1]][j-1]);
        }
    }
    while(m--){
        int a,b;read(a,b);
        int c=lca(a,b);
        plan Final=better(select(a,c),select(b,c));
        printf("%lld\n",Final.sc+path[a]+path[b]-path[c]-path[fa[c][0]]);
    }
    return 0;
}
```

---


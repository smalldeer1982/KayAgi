# 幽默的世界。

## 题目背景

@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？

## 题目描述

给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：

- $l\le l'\le r'\le r$；
- 连续子序列 $a_{l'},a_{l'+1},\cdots a_{r'}$ 是幽默的。

## 说明/提示

对于所有数据，保证 $1\le n,q\le 2\times 10^5$，$1\le l\le r\le n$，$|a_i|\le 10^9$。

### 子任务

|  #   |       特殊性质        | 分值 |
| :--: | :-------------------: | :--: |
|  0   |         样例          |  0   |
|  1   |      $n,q\le 50$      |  15  |
|  2   | $n,q\le 3\times 10^3$ |  20  |
|  3   |  对于所有询问，$r=n$  |  15  |
|  4   |  对于所有询问，$l=1$  |  15  |
|  5   |           -           |  35  |


## 样例 #1

### 输入

```
4 3
3 -4 -1 2
1 2
3 4
1 4
```

### 输出

```
1
2
3
```

## 样例 #2

### 输入

```
7 6
-1 2 -1 -1 -1 2 -1
2 5
4 7
1 7
5 5
1 3
2 4
```

### 输出

```
1
2
4
0
2
1
```

# 题解

## 作者：HFanGDoDM (赞：22)

## 前置知识

[二分法](https://oi.wiki/basic/binary/#%E4%BA%8C%E5%88%86%E6%B3%95)

# 题意简述

给定一个长度为 $n$ 的序列 $a$。$q$ 次询问，每次询问给定 $l,r$，求满足以下条件的数对 $(l',r')$ 个数。

- $l\leqslant l'\leqslant r'\leqslant r$。

- $\displaystyle\sum_{i=l'}^{r'}a_i\gt 0$。

- $\forall x,y,l'\leqslant x\leqslant y\lt r',\displaystyle\sum_{i=x}^ya_i\leqslant 0$。

### 数据范围

#### 子任务 0

$n\in\{4,7\}$，$q\in\{3,6\}$，$1\leqslant l\leqslant 5$，$r\in\{2,3,4,5,7\}$，$1\leqslant l\leqslant r\leqslant n$，$a_i\in\{-4,-1,2,3\}$。

#### 子任务 1

$1\leqslant n,q\leqslant 50$，$1\leqslant l\leqslant r\leqslant n$，$-10^9\leqslant a_i\leqslant 10^9$。

#### 子任务 2

$1\leqslant n,q\leqslant 3000$，$1\leqslant l\leqslant r\leqslant n$，$-10^9\leqslant a_i\leqslant 10^9$。

#### 子任务 3

$1\leqslant n,q\leqslant 2\times 10^5$，$1\leqslant l\leqslant r=n$，$-10^9\leqslant a_i\leqslant 10^9$。

#### 子任务 4

$1\leqslant n,q\leqslant 2\times 10^5$，$1=l\leqslant r\leqslant n$，$-10^9\leqslant a_i\leqslant 10^9$。

#### 子任务 5

$1\leqslant n,q\leqslant 2\times 10^5$，$1\leqslant l\leqslant r\leqslant n$，$-10^9\leqslant a_i\leqslant 10^9$。

# 解题思路

## 子任务 0

### 做法

若 $n=4,q=3$，则答案分别为 $1,2,3$；若 $n=7,q=6$，则答案分别为 $1,2,4,0,2,1$。

### 正确性证明

$n=4,q=3$ 的答案在 **样例输出 #1** 中给出，分别为 $1,2,3$；$n=7,q=6$ 的答案在 **样例输出 #2** 中给出，分别为 $1,2,4,0,2,1$。

### 具体实现

判断 $n,q$ 的值。若 $n=4,q=3$，则输出三行三个整数，分别为 $1,2,3$；若 $n=7,q=6$，则输出六行六个整数，分别为 $1,2,4,0,2,1$。

### 时间复杂度分析

输出一次，复杂度为 $O(1)$，可以通过 **子任务 0**。

### 参考核心代码

```cpp
if(n==4&&q==3)
	printf("1\n2\n3");
if(n==7&&q==6)
	printf("1\n2\n4\n0\n2\n1");
```

### 期望得分

$0$ 分。

## 子任务 1

### 做法

对于每次询问，枚举所有可能的 $(l',r')$。根据定义，检查 $\displaystyle\sum_{i=l'}^{r'}a_i$ 是否大于 $0$。若 $\displaystyle\sum_{i=l'}^{r'}a_i\leqslant0$，则该 $(l',r')$ 不符合题意。并枚举该区间内所有可能的 $x$ 和 $y$，判断是否有 $l'\leqslant x\leqslant y\lt r',\displaystyle\sum_{i=x}^ya_i\leqslant0$。若存在一个 $(x,y)$，满足 $\displaystyle\sum_{i=x}^ya_i\gt0$，则该 $(l',r')$ 不符合题意。

最后可以求出所有符合题意的 $(l',r')$ 个数。

### 正确性证明

由于我们每次枚举了 **所有可能的 $(l',r')$**，并**按照定义**，逐一检查了 $(l',r')$ 是否符合题意，因此该思路是正确的。

### 具体实现

对于每次询问，使用两重循环枚举所有 $l\leqslant l'\leqslant r'\leqslant r$，并用一重循环计算 $\displaystyle\sum_{i=l'}^{r'}a_i$。若 $\displaystyle\sum_{i=l'}^{r'}a_i\leqslant0$，则该 $(l',r')$ 一定不合题意，跳过。再使用两重循环枚举所有 $l'\leqslant x\leqslant y\lt r'$，其中再使用一重循环，计算 $\displaystyle\sum_{i=x}^ya_i$，并判断是否存在 $\displaystyle\sum_{i=x}^ya_i\gt0$。若存在，则该 $(l',r')$ 一定不合题意。计算出符合题意的 $(l',r')$ 数量，并输出。

### 时间复杂度分析

外层两重循环，内层分别有一重循环，以及两重循环嵌套一重循环，总共最多嵌套五重循环。每个循环复杂度为 $O(n)$，则回答一次询问，时间复杂度为 $O(n^5)$。

总时间复杂度 $O(qn^5)$，实测可以通过 **子任务 0** 和 **子任务 1**。

### 参考核心代码

```cpp
for(i=l;i<=r;i++)
    for(j=i;j<=r;j++){//枚举所有(l',r')
        long long summ=0;
        for(k=i;k<=j;k++)
            summ+=a[k];
        if(summ<=0)//求和，若小于0不合题意
            continue;
        bool flg=true;
        for(x=i;x<j;x++)
            for(y=x;y<j;y++){//枚举区间内所有(x,y)
                summ=0;
                for(m=x;m<=y;m++)
                    summ+=a[m];
                if(summ>0){//若存在[x,y]区间和大于0，则不合题意
                    flg=false;
                    break;
                }
            }
        if(flg)
            ans++;//若符合题意答案加1
...
printf("%d\n",ans);
```

### 期望得分

$15$ 分。

## 子任务 2

### 做法

对于每次询问，枚举 **所有可能的 $r'$**。若 $a_{r'}\leqslant0$，则对于所有 $(l',r')$，该数对均 **不符合题意**。否则，我们 **二分** 出一个整数位置 $p\in[1,r']$，满足 $\displaystyle\sum_{i=p}^{r'}a_i\gt0\land\forall x\in \{p,p+1,p+2,\dots,r'-1\},a_x\leqslant 0$，且 $\displaystyle\sum_{i=p-1}^{r'}a_i\leqslant0\lor\exists x\in\{p-1,p,p+1,\dots,r'-1\},a_x\gt0$。此时得到的位置 $p$ 即为以 $r'$ 为右端点的所有数对 $(l',r')$ 中，**最小的 $l'$**。我们将 $\min(r'-p+1,r'-l+1)$ 加入答案。


枚举完所有 $r'\in[l,r]$，即可求出符合题意的 $(l',r')$ 个数。

### 正确性证明

根据题意，符合题意的 $(l',r')$ 必须满足：$\forall l'\leqslant x\leqslant y\lt r'$，都有 $\displaystyle\sum_{i=x}^ya_i\leqslant0\implies\displaystyle\sum_{i=l'}^{r'-1}a_i\leqslant0$。

又知 $\displaystyle\sum_{i=l'}^{r'}a_i\gt0$，因此 $a_{r'}=\displaystyle\sum_{i=l'}^{r'}a_i-\displaystyle\sum_{i=l'}^{r'-1}a_i\gt0$。

所以，**$(l',r')$ 符合题意 $\implies a_{r'}\gt0$**。

故其逆否命题成立： **$a_{r'}\leqslant0\implies (l',r')$ 不符合题意**。

回到定义：$\forall l'\leqslant x\leqslant y\lt r'$，都有 $\displaystyle\sum_{i=x}^ya_i\leqslant0\implies\forall l'\leqslant x\lt r'$，都有 $a_x\leqslant0$。

所以，**$(l',r')$ 符合题意 $\implies\forall l'\leqslant x\lt r',a_x\leqslant0$**。

又根据定义，可以得到：**$(l',r')$ 符合题意 $\iff\displaystyle\sum_{i=l'}^{r'}a_i\gt0$**。

若 $\forall l'\leqslant x\lt r'$，都有 $a_x\leqslant 0$，则 $\forall l'\leqslant x\leqslant y\lt r'$，有 $\displaystyle\sum_{i=x}^ya_i=a_x+a_{x+1}+a_{x+2}+\cdots+a_y\leqslant0$。

综上所述：

- **一个数对 $(l',r')$ 符合题意 $\iff$ $\forall l'\leqslant x\lt r',a_x\leqslant0$ $\land$ $\displaystyle\sum_{i=l'}^{r'}a_i\gt0$**。

- **$a_{r'}\gt0$ 是数对 $(l',r')$ 符合题意的必要条件**。

对于一个确定的 $r'$，记 $f(x)=\displaystyle\sum_{i=x}^{r'-1}[a_i\gt0],x\in\{1,2,\dots,r'-1\}$，则：

$\forall x_1,x_2\in\{1,2,\dots,r'-1\},x_1\lt x_2$，都有

$$\begin{aligned}
f(x_1)-f(x_2)&=\displaystyle\sum_{i=x_1}^{r'-1}[a_i\gt0]-\displaystyle\sum_{i=x_2}^{r'-1}[a_i\gt0]\\

&=\displaystyle\sum_{i=x_1}^{x_2-1}[a_i\gt0]\geqslant0
\end{aligned}$$

即 $f(x_1)\geqslant f(x_2)$，因此 $f(x)$ 是 **非严格单调递减** 函数。

根据上述推理，$f(l')=0\implies$ 数对 $(l',r')$ 符合题意。由上述 **单调性** 证明，我们可以通过二分，找到满足 $f(l')=0$ 的最小的 $l'$。我们记这个位置为 $pos$。

对于一个确定的 $r'$ 及其对应的 $pos$，记 $g(x)=\displaystyle\sum_{i=x}^{r'}a_i,x\in\{pos,pos+1,\dots,r'\}$，则：

$\forall x_1,x_2\in\{pos,pos+1,\dots,r'\},x_1\lt x_2$，都有

$$\begin{aligned}
g(x_1)-g(x_2)&=\displaystyle\sum_{i=x_1}^{r'}a_i-\displaystyle\sum_{i=x_2}^{r'}a_i\\

&=\displaystyle\sum_{i=x_1}^{x_2-1}a_i
\end{aligned}$$

$x_1,x_2-1\in\{pos,pos+1,\dots,r'-1\}\implies\forall i\in\{x_1,x_1+1,\dots,x_2-1\},a_i\leqslant0$

$\implies g(x_1)-g(x_2)\leqslant0$。

即 $g(x_1)\leqslant g(x_2)$，因此 $g(x)$ 是 **非严格单调递增** 函数。

根据上述推理，$g(l')\gt0\implies$ 数对 $(l',r')$ 符合题意。由上述 **单调性** 证明，我们可以通过二分，找到满足 $g(l')\gt0$ 的最小的 $l'=p$。此时我们已经满足了数对 $(l',r')$ 符合题意的充要条件。

此时我们还没有考虑到询问区间的 $l$ 和 $r$。$r'\leqslant r$ 的约束已经满足。此时我们找到的 $l'$ 若大于等于 $l$，则符合题意。否则，**根据单调性**，取询问区间的 $l$，即为满足所有约束的最小的 $l'$。

因此答案的增加量为 $\min(r'-p+1,r'-l+1)$，思路正确。

### 具体实现

我们预处理出 $sum_{1,i}=\displaystyle\sum_{j=1}^i[a_i\leqslant0]$，$sum_{2,i}=\displaystyle\sum_{j=1}^ia_i$。这一部分使用 **前缀和** 预处理。

对于每个询问，首先枚举 $r'\in[l,r]$，若 $a_{r'}\leqslant0$，则跳过该右端点。否则二分出位置 $p$：

设置初始位置左右端点 $L=1,R=r'$，当前位置中点 $mid=\lfloor\dfrac{L+R}{2}\rfloor$。判断此时的 $mid$ 是否满足：$\displaystyle\sum_{i=mid}^{r'-1}[a_i\leqslant0]=r'-mid\land\displaystyle\sum_{i=mid}^{r'}a_i\gt0$，即是否满足 $sum_{1,r'-1}-sum_{1,mid-1}=r'-mid\land sum_{2,r'}-sum_{2,mid-1}\gt0$。若 **满足**，则向 **更靠左** 的位置二分；否则，向 **更靠右** 的位置二分。

最终得到一个位置 $p$，则将答案增加 $\min(r'-p+1,r'-l+1)$。

枚举完所有的 $r'$，输出答案。

### 时间复杂度分析

预处理前缀和，复杂度 $O(n)$。对于每个询问，枚举 $r'$，复杂度为 $O(n)$；二分出一个位置，复杂度为 $O(\log n)$。

总时间复杂度 $O(qn\log n)$，可以通过 **子任务 0**、**子任务 1** 和 **子任务 2**。

### 参考核心代码

```cpp
for(i=1;i<=n;i++)
	sum[i]=sum[i-1]+a[i];
for(i=1;i<=n;i++)
	sum1[i]=sum1[i-1]+(a[i]<=0);//预处理两个前缀和
...
      int ans=0;
      for(i=l;i<=r;i++){
          if(a[i]<=0)
              continue;//若a[i]<=0一定不合题意
          int lt=0,rt=i+1;
          while(lt+1!=rt){//二分出最小的l'
              int mid=(lt+rt)>>1;
              if(sum[i]-sum[mid-1]>0&&sum1[i-1]-sum1[mid-1]==i-mid)//判断条件，区间和大于0且[mid,i-1]中只能有非正数
                  rt=mid;//向左二分
              else
                  lt=mid;
          }
          ans+=min(i-rt+1,i-l+1);//注意要取min
      }
      printf("%d\n",ans);
```

### 期望得分

$35$ 分。

## 子任务 3

### 做法

将所有询问 **离线**，并按照左端点 $l$ **降序排序**。将端点从 $n$ 向左扫，记开始扫之前答案为 $0$。设当前扫到了位置 $i$，若 $a_i>0$，则 **答案加 $1$**；否则，记位置 $p$ 为满足 $p>i$，且 $a_p>0$ 的第一个位置，若存在位置 $p$ 且有 $\displaystyle\sum_{j=i}^pa_j>0$，则 **答案加 $1$**；否则，**答案不变**。执行上述操作后，所有左端点 $l=i$ 的询问的答案即为当前答案。

扫完整个序列后，即可求出所有询问的答案。

### 正确性证明

由于所有询问的 **右端点固定**，都为 $n$，因此我们可以只考虑左端点移动对答案的 **贡献**。由于我们可以按照左端点排序，因此我们可以只考虑左端点 **向左移动** 对答案的贡献。

记 $ans(x)$ 为区间 $[x,n]$ 的答案。当 $x$ 变为 $x-1$ 时，增加的区间有 $[x-1,x-1],[x-1,x],[x-1,x+1],\dots,[x-1,n-1],[x-1,n]$。

若 $a_{x-1}\gt0$，则有 $\forall i\in\{x,x+1,x+2,\dots,n\}$，都必然 $\exists j\in\{x-1,x,\dots,i\},a_j\gt0$，因此区间 $[x-1,x],[x-1,x+1],\dots,[x-1,n-1],[x-1,n]$ 都不符合题意（一个区间 $[l',r']$ 对应的数对 $(l',r')$ 符合题意的条件见 **子任务 2** 的证明）。由于 $a_{x-1}\gt0$，且该区间只有一个元素，故符合题意。

因此，$a_{x-1}\gt0\implies ans(x-1)=ans(x)+1$ 。

若 $a_{x-1}\leqslant0$，则 $\forall i\in\{x-1,x,\dots,p-1\}$，都有 $a_i\leqslant0$（$p$ 的含义同上文），因此区间 $[x-1,x-1],[x-1,x],\dots,[x-1,p-1]$ 都 **不符合题意**（原因见 **子任务 2** 的证明）。同时，由于 $a_p\gt0$，因此区间 $[x-1,p+1],[x-1,p+2],\dots,[x-1,n]$ 都不符合题意（原因见上文）。

若还有 $\displaystyle\sum_{i=x-1}^pa_i\gt0$，则满足所有符合题意的充要条件，则区间 $[x-1,p]$ 符合题意，则此时 $ans(x-1)=ans(x)+1$。

否则，区间 $[x-1,p]$ 不合题意，则此时 $ans(x-1)=ans(x)$。

这样我们讨论完了左端点向左移动一个位置时的所有情况，因此所有左端点为当前左端点的询问的答案即为当前答案，故 **思路正确**。

### 具体实现

记录所有询问的左端点及询问编号，使用 **计数排序** 的方式将所有左端点相同的询问编号挂在同一个左端点上。**这里使用 `vector` 实现**。

设置端点为 $n$，将该端点从 $n$ 向 $1$ 位置扫。设当前扫到了位置 $i$。首先判断 $a_i\gt0$ 是否成立，若成立，答案加 $1$。否则，我们 **找到** 在位置 $i$ 之后的第一个位置 $p$ 满足 $a_p\gt0$，并使用前缀和判断区间 $[i,p]$ 的元素和是否大于 $0$。若是，答案加 $1$；否则，答案不变。

我们 **动态更新** 当前在位置 $i$ 之后第一个 $a_p\gt0$ 的位置 $p$。初始 $p=n+1$，若当前位置 $i$ 的 $a_i\gt0$，则令 $p\leftarrow i$。

回答左端点为 $i$ 的所有询问，并存在对应询问编号的答案中。扫完整个序列，按编号顺次输出每个询问的答案。

### 时间复杂度分析

将询问离线并降序排序，按上述实现，复杂度为 $O(q)$。从右往左扫一遍复杂度 $O(n)$。每个位置，可以 $O(1)$ 找到位置 $p$，故计算一个询问的答案，复杂度为 $O(1)$。

总时间复杂度 $O(n+q)$，可以通过 **子任务 3**。

### 参考核心代码

```cpp
vector<int>ask[N];
...
	for(i=1;i<=q;i++){
		int l=R(),r=R();
		ask[l].push_back(i);//将询问编号i放入询问左端点为l的vector中，相当于计数排序
	}
	int ans=0,now=n+1;//now记录当前位置右边第一个a[p]>=0的位置p
	for(i=n;i>=1;i--){
		if(a[i]>0){
			ans++;
			now=i;//若a[i]>0答案加1，并更新now
		}
		else if(now!=n+1)//now位置存在
			if(sum[now]-sum[i-1]>0)//判断符合题意
				ans++;
		for(auto qid:ask[i])
			anss[qid]=ans;//回答询问
	}
	for(i=1;i<=q;i++)
		printf("%d\n",anss[i]);
```

### 期望得分

$15$ 分。结合 **子任务 0** 的解法可以获得 $15$ 分，结合 **子任务 1** 的解法可以获得 $30$ 分，结合 **子任务 2** 的解法可以获得 $50$ 分。

## 子任务 4

### 做法

将所有询问离线，并按照右端点 $r$ **升序排序**。将端点从 $1$ 向右扫，设开始扫之前答案为 $0$。设当前扫到的位置为 $i$，若 $a_i\leqslant0$，则答案不变。否则，二分出位置 $p$，满足 $\displaystyle\sum_{i=p}^{r'}a_i\gt0\land\forall x\in \{p,p+1,p+2,\dots,r'-1\},a_x\leqslant 0$，且 $\displaystyle\sum_{i=p-1}^{r'}a_i\leqslant0\lor\exists x\in\{p-1,p,p+1,\dots,r'-1\},a_x\gt0$，将 $i-p+1$ 加入答案。执行完上述操作后，当前答案即为所有 $r=i$ 的询问的答案。

### 正确性证明

由于 **左端点固定**，均为 $1$，且我们可以按照右端点将询问排序，因此我们只需要考虑右端点 **右移一个位置** 对答案的贡献。

可以发现，右端点右移一个位置时，增加的所有区间的右端点 **相同**。这就转化为：**固定右端点 $r'$，求所有符合题意的数对 $(l',r')$ 个数**。该问题与 **子任务 2** 中的问题相同，因此解法也与那一问题相同，具体见 **子任务 2**。注意到此时必有 $l=1$，因此二分得到的位置 $p$ 一定是符合区间左端点约束的，即必有 $p\geqslant1$。因此将 $i-p+1$ 加入答案即可。

我们正确解决了右端点右移一个位置对答案的贡献问题，因此该思路是正确的。

### 具体实现

使用 `vector` 实现对询问的按右端点排序。设置端点为 $1$，从 $1$ 扫到 $n$。设当前扫到的位置为 $i$。首先判断 $a_i\gt0$ 是否成立，若不成立，答案不变。否则，二分出上述位置 $p$，具体方法见 **子任务 2**。答案增加 $i-p+1$。回答右端点为 $i$ 的所有询问，将答案存入对应的询问编号。

最后按照询问编号顺次输出答案。

### 时间复杂度分析

按照上述实现，对询问排序是 $O(n)$ 的。从左往右扫，每次可能需要二分，单次复杂度 $O(\log n)$，回答询问总复杂度为 $O(q)$。

总时间复杂度 $O(n\log n)$，可以通过 **子任务 4**。

### 参考核心代码

```cpp
for(i=1;i<=q;i++){
    int l=R(),r=R();
    ask[r].push_back(i);//将询问按右端点升序排序
}
int ans=0;
for(i=1;i<=n;i++){
    if(a[i]>0){//只有a[i]>0才可能更新答案
        int lt=0,rt=i+1;
        while(lt+1!=rt){
            int mid=(lt+rt)>>1;
            if(sum[i]-sum[mid-1]>0&&sum1[i-1]-sum1[mid-1]==i-mid)
                rt=mid;
            else
                lt=mid;
        }
        ans+=i-rt+1;//二分出位置p
    }
    for(auto qid:ask[i])
        anss[qid]=ans;//回答询问
}
for(i=1;i<=q;i++)
    printf("%d\n",anss[i]);
```

### 期望得分

$15$ 分。结合 **子任务 0** 的解法可以获得 $15$ 分，结合 **子任务 1** 的解法可以获得 $30$ 分，结合 **子任务 3** 的解法可以获得 $30$ 分，结合 **子任务 0** 和 **子任务 3** 的解法可以获得 $30$ 分，结合 **子任务 1** 和 **子任务 3** 的解法可以获得 $45$ 分，结合 **子任务 2** 的解法可以获得 $50$ 分，结合 **子任务 2** 和 **子任务 3** 的解法可以获得 $65$ 分。

## 子任务 5

### 做法

对于每个位置 $i$，使用二分法，**预处理** 出以 $i$ 为右端点 $i=r'$ 的所有符合题意的数对 $(l',r')$ 个数 $num_i$（具体方法见 **子任务 2**）。对于一个询问 $(l,r)$，设区间 $[l,r]$ 中最小的位置 $p$，满足 $a_p\gt0$，求出 $\min(num_p,p-l+1)+\displaystyle\sum_{i=p+1}^rnum_i$，即为该询问的答案。

### 正确性证明

由于原序列 $a$ **不发生改变**，因此我们可以预处理出上述的 $num_i$（正确性证明见 **子任务 2**）。

设一个位置 $i$ 满足 $a_i\gt0$，位置 $las$ 也满足 $a_{las}\gt0$，且有 $\forall j\in\{las+1,las+2,\dots,i-1\}$。都有 $a_j\leqslant0$，设对于位置 $i$，二分出的位置为 $pos$。根据 **子任务 2** 中的推断，假设 $pos\leqslant las$，则 $\exists j\in\{pos,pos+1,\dots,i-1\}$，满足 $a_j\gt0$，则区间 $[pos,i]$ 不合法，这与 **$pos$ 为满足区间 $[l',i]$ 合法的最小的 $l'$** 这一结论相矛盾。因此假设不成立，故 $pos\gt las$。

对于一个询问 $(l,r)$，设其中所有满足 $a_i\gt0$ 的所有 $i$ 从小到大分别为 $i_1,i_2,\dots,i_k$，其中 $k=\displaystyle\sum_{i=l}^r[a_i\gt0]$。该询问的答案 $ans=\displaystyle\sum_{i=l}^r\min(i-l+1,num_i)$。对于 $a_i\leqslant0$ 的位置 $i$，$num_i=0$，因此 $\min(i-l+1,num_i)=num_i$。对于 $j\in\{2,3,\dots,k\}$，根据上述推理，**必有对应的 $p\gt i_{j-1}\geqslant l$**，因此 $num_{i_j}\lt i_j-l+1\implies \min(i_j-l+1,num_{i_j})=num_{i_j}$。**只有 $i_1$ 位置的 $i_1-l+1$ 与 $num_{i_1}$ 大小关系不确定，需要单独计算**。

**即证**：$ans=\min(p-l+1,num_p)+\displaystyle\sum_{i=p+1}^rnum_i$，其中 $p$ 的含义与本子任务“做法”中 $p$ 含义相同。

因此该思路正确。

### 具体实现

首先预处理出 $num_i$ 数组，具体方法见 **子任务 2**。根据上述证明，我们也可以动态记录每个数左边第一个元素值大于 $0$ 的位置，将二分左端点设置为上一个满足 $a_i\gt0$ 的位置 $i$，实现一个小优化。

预处理出 $num_i$ 数组的 **前缀和** 数组 $sumn_i$，预处理出每个数 **右边** 第一个元素值大于 $0$ 的位置。对于一个询问，直接计算 $sumn_r-sumn_{l-1}$，并找到 $l-1$ 右边第一个元素值大于 $0$ 的位置 $x$，减去 $num_x$，并加上 $\min(num_x,x-l+1)$，即为该询问的答案，输出即可。

### 时间复杂度分析

预处理 $num_i$ 数组，单次处理复杂度 $O(\log n)$，总复杂度 $O(n\log n)$；预处理 $sumn_i$ 数组与每个数右边第一个元素值大于 $0$ 的位置，复杂度都是 $O(n)$。单次处理询问，计算、查找位置，复杂度都为 $O(1)$，总复杂度 $O(q)$。

总时间复杂度 $O(n\log n)$，可以通过 **本题**。

### 参考核心代码
```cpp
int now=0;
for(i=1;i<=n;i++){
    lef[i]=now;//前面第一个正数位置
    if(a[i]>0)
        now=i;
}
now=n+1;
for(i=n;i>=1;i--){
    rig[i]=now;//后面第一个正数位置
    if(a[i]>0)
        now=i;
}
...（预处理num数组及前缀和）
    int l=R(),r=R(),pos=rig[l-1];//找到l-1右边第一个正数的位置
    if(pos>r){//注意这里要特判，否则会使得找到的pos越界导致错误
        puts("0");
        continue;
    }
    printf("%d\n",sumn[r]-sumn[l-1]-num[pos]+min(num[pos],pos-l+1));//根据上述式子计算答案
```

### 期望得分

$100$ 分。

---

## 作者：aldzsfs (赞：11)

~~本蒟蒻的第一篇题解，求通过o( =•ω•= )m~~

[题目传送门](https://www.luogu.com.cn/problem/P9681)

------------
# 题目理解
给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

因为当 $l=r-1$ 时， $x=y=l$ 所以若一个序列是幽默的，则该序列中有且只有最后一个数为正数，且满足 $\sum\limits_{i=l}^ra_i>0$。

------------
# 解题思路
我们可以在每次询问中找到在 $l$ 到 $r$ 中的每一个正数，再从后往前累加，直到和小于零，则求出来的长度就是所求序列的个数。
```
#include<bits/stdc++.h>
using namespace std;
int n,q,l,r,s,a[300000];
long long sum,ans;
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;++i)	scanf("%d",a+i);
	while(q--){
		scanf("%d%d",&l,&r);
		s=ans=sum=0;
		for(int i=r;i>=l;--i)
			if(a[i]>0){
				s=i;
				break;
			}//从后往前找到第一个正数
		for(int i=s;i>=l;--i){
			if(a[i]>0)	sum=0;
          		//每次找到正数重新开始累加
			sum+=a[i];
			if(sum>0)	++ans;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
``` 
### 优化
但是上述代码每次询问都要统计一遍，时间复杂度最坏可达 $O(nq)$，所以需要进行优化。

所以我们想到预处理，将整个序列中的所有正数提取出来，并储存好每个正数可带领的最长序列的长度（简称正数的长度）。
```
for(int i=n,j;i;--i){
	if(a[i]>0)	j=i,m=0,z[++num]=j;
	//储存每个正数的位置，num记录正数的个数
	m+=a[i];
	if(m>0)	++v[j];//储存长度
}
```
那么我们只需要在每次询问时统计区间内的所有正数的长度就可以了，所以需要找到最大的不大于 $r$ 的正数与最小的不小于 $l$ 的正数。
详细见代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,q,num,a[300000],v[300000],z[300000];
long long m,ans,sum[300000];
int ef(int k){//二分查找
	int l=1,r=num,mid;
	while(l<=r){
		mid=l+r>>1;
		z[mid]>k?r=mid-1:l=mid+1;
		//喜欢压行，改不掉的
	}
	return r;
}
int main(){
	int l,r,s,e;
	cin>>n>>q;
	for(int i=1;i<=n;++i)	scanf("%d",a+i);
	for(int i=n,j;i;--i){
		if(a[i]>0)	j=i,m=0,z[++num]=j;
		m+=a[i];
		if(m>0)	++v[j];
	}
	sort(z+1,z+1+num);//排序，方便查找
	for(int i=1;i<=num;++i)	sum[i]=sum[i-1]+v[z[i]];
	//前缀和优化
	while(q--){
		ans=0;//初始化
		scanf("%d%d",&l,&r);
		s=ef(l);
		e=ef(r);
		//找到最大的不大于r的正数e，与最小的不小于l的正数s
		//使用二分算法优化时间复杂度
		if(z[e]<l)	goto nxt;
		//忘记判断e是否在范围内，改了好久╥﹏╥
		if(z[s]<l)	++s;
		//确保s>=l
		ans=sum[e]-sum[s]+min(v[z[s]],z[s]-l+1);
		//统计答案，因为s所带领的序列有可能被吞掉了一部分，所以要特殊处理
		nxt:printf("%lld\n",ans);
	}
	return 0;
}
```
如有错误，求各位大佬指出Σ(⊙▽⊙"a 。

---

## 作者：a1a2a3a4a5 (赞：9)

# P9681 幽默的世界

## 题意
- 区间右端点是正数，其余为负数，加起来和为正数。
- 负数加负数肯定还是负数，公式就是迷惑你的。

## 思路
1. 我们知道加起来是正数，少加一个负数区间和就更大了，所以一个合法的大区间分成很多合法的小区间。
2. 这个区间要保持右端点是正数左边是负数，所以我们可以找到一个正数后在左边找负数然后构成一个区间，再这时候这个区间满足了一个条件。
3. 考虑构造合法大区间，因为你有了大区间就可以找到包含的小区间。我们可以找到最左边使得区间和为正数的左端点。
4. 询问的时候，我们找到所有包含的大区间，然后算出大区间包含的区间个数就可以了，也可以明显看出区间个数是区间长度。

下面这个图片可以说明：
![](https://cdn.luogu.com.cn/upload/image_hosting/107lh6b1.png?x-oss-process=image/resize,m_lfit,h_800,w_800)

思路有了，再优化优化就过了。

## 优化
这时候我们发现了计算区间的两个步骤最耗时，所以优化他们：
1. 再找合法大区间左端点的时候明显可以使用二分。
2. 我们可以预处理前缀区间和然后把最左和最右的区间二分找出来，最后取中间的所有区间和。
优化后复杂度完全正确，要出来了。

## 代码
出来了，一些细节我没说，下面注释里非常得清楚！
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,cnt,a[201000],qz[210000],l[210000],r[210000],dqz[219999],fu[210000];
signed main()
{
	cin>>n>>q;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i],qz[i]=qz[i-1]+a[i],//a数组前缀和。
		fu[i]=fu[i-1]+((a[i]<=0)?1:0);//a数组负数数量前缀和。
		if(a[i]>0)
		{
			r[++cnt]=i;
			int z=1,y=i,mid;
			while(z<y)
			{
				mid=(z+y)>>1;
				if(fu[i]-fu[mid-1]==i-mid&&qz[i]-qz[mid-1]>0) y=mid;
				else z=mid+1;
			}
			l[cnt]=y;
			//二分找到左端点。
		}
	}
	for(int i=1;i<=cnt;i++) dqz[i]=dqz[i-1]+r[i]-l[i]+1;//区间和前缀和。
	for(int i1=1,zuo,you,da;i1<=q;i1++)
	{
		cin>>zuo>>you,da=0;
		bool f=0;//无解判断。
		int zz,zy,z=1,y=cnt,mid;
		//zz最左的区间，zy最右的区间。
		while(z<y)
		{
			mid=(z+y)>>1;
			if(r[mid]>=zuo)
			{
				if(r[mid]<=you) f=1;
				y=mid;
			}
			else z=mid+1;
		}
		da+=(r[y]-max(l[y],zuo)+1),zz=y,z=1,y=cnt;
		//就怕最左边的区间缺了一块，所以要判断。
		while(z<y)
		{
			mid=(z+y+1)>>1;
			if(r[mid]<=you)
			{
				z=mid;
				if(r[mid]>=zuo) f=1;
			}
			else y=mid-1;
		}
		da+=(r[z]-max(l[z],zuo)+1),zy=z;
		//就怕只有一个区间，最右边的区间跟最左边一样，所以要判断：
		if(r[y]>=zuo&&r[y]<=you) f=1;
		//我的二分判断不了只有一个区间的情况。
		if(!f) cout<<"0\n";
		else if(zy-zz+1==1) cout<<da/2<<"\n";//只有一个大区间会重复计算一次。
		else cout<<da+dqz[zy-1]-dqz[zz]<<'\n';
	}
	return 0;
}
```

---

## 作者：Aakkosetsumussa (赞：6)

心情正差，一位朋友让我做一下这道题，没想到秒了，还是在线 $O(n+q)$ 的！

心情好多了，这里给出一份简洁明了的代码。

# 题意 #

~~自己看题去~~ 给定幽默的区间的定义和一个长度为 $n$ 的序列，$q$ 次询问，求 $[l, r]$ 内有多少个幽默的区间。

幽默的区间：$[l, r]$ 满足 $\sum^r_l a_i>0$ 且 $\forall x, y \in [l, r)$，其中 $x \le y$，有 $\sum^y_x a_i \le 0$。

# 分析 #

首先有一个很显然的事，就是幽默的区间一定是这样的区间：前面全是负数，只有最后一个数是正数，并且最后这一个数和前面所有数的和大于 $0$，这个别的大佬也有证明了。

观察序列中每个数对答案的贡献。发现若其是正数，他自己可以构成一个幽默的区间。若其是负数，其对其之后第一个正数有一个贡献当且仅当它本身到它之后第一个正数的和大于等于零且中间的所有数都是负数。

贡献可以从后往前算，这个不难。我们可以将贡献进行前缀和，实现 $O(1)$ 的时间复杂度。

但是有个问题，就是如果这个负数在询问区间里而他对应的贡献的正数不在询问区间里，他的贡献是不能算的。这个怎么办？只要预处理出每个负数前面第一个正数就好了，查询的时候若遇到这种情况直接跳到他前面第一个正数的地方。

所以，我们需要预处理三个东西：这个数前面第一个负数，这个数后面第一个负数（查询时判断后面那个正数在不在查询区间里），和这个数对答案的贡献（需要前缀和）。

三个预处理的时间复杂度都是 $O(n)$，总时间复杂度 $O(n+q)$。

# 代码 #

```cpp
ll n, q, a[N];
ll lst[N], pre[N], sum[N];

void init() {
	for(ll i=n, p=1e15, s=0; i>=1; i--) {
		if(a[i]>0) p=i, s=a[i];
		lst[i]=p; // 后面第一个正数 
		if(i!=p && p!=1e15) s+=a[i];
		if(s>0) sum[i]=1; // 贡献 
	}
	for(ll i=1, p=1e15; i<=n; i++) {
		if(a[i]>0) p=i;
		pre[i]=p; // 前面第一个正数 
	}
	for(ll i=1; i<=n; i++) sum[i]+=sum[i-1]; // 前缀和 
}

int main() {
	n=rd(), q=rd();
	for(ll i=1; i<=n; i++) a[i]=rd();

	init();

	for(ll i=1; i<=q; i++) {
		ll u=rd(), v=rd();
		if(pre[v]==1e15) printf("0\n"); //注意特判 
		else {                          
			if(lst[v]>v) v=pre[v];      //注意特判
			if(v<u) printf("0\n");      //注意特判，这仨害的我提交了四五次才AC 
			else printf("%lld\n", sum[v]-sum[u-1]);
		}
	}
	return 0;
}
```

个人认为自己的代码还是可读性很强的，实在没懂那仨数组的建议自行输出查看。

有一说一，为啥那么多大佬的都是 $O(n \log n)$ 的啊。

---

## 作者：LYBT (赞：6)

## First —— 分析题意
核心要素就是去推理幽默数列的性质。  
首先性质一显而易见，这个序列总和大于 $0$。  
再看性质二，这个序列的区间 $[l,r-1]$ 任何子序列总和小于等于 $0$，其中注意 $x\le y$，说明这个子序列可以是一个数，便可得出结论：除了最后一项以外，这个序列的任何数都是非正数。
## Then —— 设计算法  
既然得出结论后，便可以想到，要想找到这种的数列，必须需要保证最后一项为正数。于是，我们可以找出原序列的所有正数，这样我们就把原序列分割成了由非正数构成的“块”。如样例二：  
 $\begin{matrix}
&-1  &2  &-1  &-1 &-1 &2 &-1
\end{matrix}$   
可以处理成三个块：  
$\begin{matrix}
  &-1  &2
\end{matrix}$  
$\begin{matrix}
 &-1  &-1 &-1 &2
 \end{matrix}$  
 $\begin{matrix}
 &-1
 \end{matrix}$  
把每一个正数当做每一种方案的结尾，我们就可以把每一个块从后往前算，凡是后缀和大于 $0$ 的便可以归为一种方案。注意，作为正数本身也是一种合法方案。以此在处理出方案的后缀和，这样就可以实现 $O(1)$ 的查询。  
当我们开始查询时，求 $[l,r]$ 的方案数又该怎么利用已经处理好的方案后缀和呢？有的同学可能会直接算出  $sum_l-sum_{r+1}$ 的值，但这只适用于结尾是正数的序列。如果说这个序列结尾是后面一个块遗留下来的负数，那么方案数会增加多余的部分。这时我们就应该考虑把后面的“负数尾巴”删去，可以维护一个每个位置前最近的正数，这样便可以忽略后面的“负数尾巴”。
## Finally —— 参考 AC 代码
听思路比较笼统，接着通过看代码注释可能效果会更好。  
My code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	char c=getchar();
	int sum=0,flag=1;
	while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
	while(c>='0'&&c<='9'){sum=(sum<<1)+(sum<<3)+(c^48);c=getchar();}
	return sum*flag;
}//快读
void write(int x){
	if(x<0) x=(~x)+1,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10|48);
}//快写
const int N=2e5+5;
int n=read(),q=read(),a[N],num[N],tot,sum[N],z[N];
// a数组是原序列，num是每一个正数的位置，tot为正数个数。sum为方案后缀和
// z数组用来统计离i最近的正数
signed main(){
	for(int i=1;i<=n;i++){
		a[i]=read();
		z[i]=z[i-1];
		if(a[i]>0) num[++tot]=i,z[i]++;
	}
	for(int i=tot;i>0;i--){//从后往前不影响后缀和
		int cnt=0;//当前块的后缀和
		for(int j=num[i];j>0&&(a[j]<=0||j==num[i]);j--){//遍历当前块
			cnt+=a[j];
			if(cnt>0) sum[j]=sum[j+1]+1;//如果大于0，可以将方案数加一
			else sum[j]=sum[j+1];//否则保持上应该状态
		}
	}
	for(int i=1;i<=q;i++){
		int l=read(),r=read();
		if(l==1||r==n) while(1);//防作弊QWQ，不要在意
		if(z[r]==0) write(0);//如果r前没有正数，说明无方案
		else if(num[z[r]]<l) write(0);//如果r前的正数位置不在序列，说明
		// 这个序列在一个块的中央位置，只有负数，方案数为0
		else write(sum[l]-sum[num[z[r]]+1]);//否则就用前缀和的方式，
		// 求出l到最后一个正数区间的方案数，忽略“负数尾巴”。
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Accelessar (赞：4)

## 15pts

暴力模拟，跑不满的 $O(n^5q)$。

## 35pts

**结论一：合法区间有且仅有最后一个数是正数。**

这个不难想到，也不难证明。

根据这个结论，我们可以枚举右端点，再从后往前找合法的左端点。

假如我们固定了 $r$，一个合法的左端点 $l$ 应满足 $-a_r\lt s[l,r-1]\le 0$（其中 $s$ 是 $a$ 的区间和，可以前缀和得到）。然后如果发现 $a_l\gt 0$，依照结论一，我们就可以 `break` 掉了。

时间复杂度是跑不满的 $O(n^2q)$，[可以拿到 35pts](/record/126858933)。

## 100pts

想想可以从结论一得到什么。

假设 $[l,r]$ 是合法区间，这意味着区间内只有一个 $a_r\gt 0$，那么对于所有的 $r'\in[l,r)$，$[l,r']$ 都不可能是合法的，因为 $a_{r'}\le 0$；同时，对于所有 $r''\gt r$，$[l,r'']$ 也不可能合法，因为这之中有 $a_r\gt 0$。

于是我们可以得到又一个结论：

**结论二：对于每一个 $l$，以它为左端点的合法区间数量至多为 $1$。且如果存在这样的合法区间，它的右端点是 $a_l$ 右边的第一个正数所在位置。**

从而，

**结论三：整个序列中的合法区间数 $\le n$，等号成立当且仅当序列中全是正数。**

~~其实这 3 个结论本质上都一样，但对于我这种思维水平低的选手还是需要好好想一会儿的~~

根据这两个结论，我们可以用 $O(n\log n)$ 的时间预处理出所有的合法区间。具体地，可以存下所有正数的位置，然后对每个 $i$ 二分查找后面的第一个正数。需要注意的是，还要检查找出的这个区间的和是否大于零。

但如果只是这样做的话，我们会发现每次询问还是要 $O(n)$ 的时间找一下所有在这个区间里的合法区间，这样总复杂度是 $O(nq)$ 的，然后喜提 [35pts](/record/126873253)。

如何快速找出 $l\ge L\land r\le R$ 的所有合法区间呢？~~据说这是个很套路的东西~~

可以考虑使用树状数组（或者线段树）。

具体地，把询问离线下来，降序排序，然后把所有合法区间也降序排序。然后依次处理询问 $[L,R]$，把所有 $l\ge L$ 的合法区间的右端点 $r$ 在树状数组上加一，然后这组询问的答案就是树状数组上 $[L,R]$ 的区间和。（左端点是 $L$ 是因为区间自然有右端点大于等于左端点，但其实你把查询的左端点设为 $1$ 也行。）这样，我们就又保证了 $r\le R$。

至此，我们将复杂度降到了 $O((n+q)\log n)$，可以通过此题。

## 代码

~~赛时代码有点过于丑陋，放个赛后整理得清楚点儿的。~~

省略了部分缺省源，如果您因对拍等原因需要完整代码可以私信我。

```cpp
#define fr(i,l,r) for(int i(l);i<=r;i++)
int n,q,l,r,c[N];
ll a[N],s[N];

// 树状数组单点加区间查
inline void add(int k,int x){for(;k<=n;k+=k&-k)c[k]+=x;}
inline int ask(int l,int r){
    int res=0;
    for(;r;r&=r-1)res+=c[r];
    for(--l;l;l&=l-1)res-=c[l];
    return res;
}

int main(){
    rd(n,q);
    vector<int>b; // 正数的位置
    fr(i,1,n)s[i]=s[i-1]+rd(a[i]),a[i]>0&&b.eb(i);
    
    vector<pii>t; // 合法区间
    fr(i,1,n){
        auto it=lower_bound(all(b),i);
        if(it!=end(b)&&s[*it]-s[i-1]>0)t.eb(i,*it);
    }reverse(all(t));
    
    vector<array<int,4>>query;
    fr(i,1,q)rd(l,r),query.push_back({l,r,i,0});
    sort(all(query),greater());
    for(int pos=0;auto&[l,r,i,ans]:query){
        while(pos<(int)t.size()&&t[pos].first>=l)add(t[pos].second,1),pos++; // 加入左端点 >=l 的区间
        ans=ask(l,r);
    }sort(all(query),[](auto x,auto y){return x[2]<y[2];});
    for(auto[l,r,i,ans]:query)cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：Svemit (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P9681)

这个人想不出普及组做法。。。

# Solution

不难发现符合题目要求的序列是最后一个数为正数，前面的数都为负数，且全部加起来大于等于 0。

考虑对于每一个右端点，都求出他往前能到的左端点，满足这一段的和大于 0 且只有右端点是正数。

显然前面一段负数的前缀和有单调性，直接二分就可以求。

```cpp
for(int i = 1; i <= n; i ++) {
	cin >> a[i];
	sum[i] = sum[i - 1] + a[i];
	if(a[i] <= 0) cnt ++;
	else {
		int l = 1, r = cnt + 1, tmp = 1;
		while(l <= r) {
			int mid = l + r >> 1;
			if(sum[i] - sum[i - mid] > 0) l = mid + 1, tmp = mid;
			else r = mid - 1;
		}
		ls[i] = tmp;
		cnt = 0;
	}
}
```

然后就可以很简单的写出一段 35 分代码。

```cpp
while(q --) {
	int l, r;
	int res = 0;
	cin >> l >> r;
	for(int i = l; i <= r; i ++) {
		if(a[i] >= 0)
			res += min(i - l + 1, ls[i]);
	}
	cout << res << '\n';
}
 ```
 
这个式子看起来还不是很好直接优化的样子，我们考虑换一个形式。

```cpp
for(int i = 1; i <= n; i ++) 
	p[i] = i - ls[i] + 1;
while(q --) {
	int l, r;
	int res = 0;
	cin >> l >> r;
	for(int i = l; i <= r; i ++) 
		res += i + 1 - max(p[i], l);
	cout << res << '\n';
}
```

前面 $\sum_{i=l}^{i=r} i + 1$ 是好算的，只需要求后面这段就好。

求后面这个需要用到的有：

1. 区间 $[l, r]$ 中大于等于 $l$ 的个数。
2. 区间 $[l, r]$ 中大于等于 $l$ 的数之和。

直接上主席树就可以做了。

```cpp
#include <bits/stdc++.h>
#define int long long
#define fi first
#define se second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int, int> PII;
const int N = 2e5 + 5, INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
int n, q;
int a[N], ls[N], s[N], p[N];
LL sum[N];
struct SegT {
	int l, r;
	PII val;
	#define l(x) tr[x].l
	#define r(x) tr[x].r
	#define val(x) tr[x].val
} tr[N << 5];
int rt[N], idx;
void pushup(int x) {
	val(x).fi = val(l(x)).fi + val(r(x)).fi;
	val(x).se = val(l(x)).se + val(r(x)).se;
}
void build(int &x, int l, int r) {
	x = ++ idx;
	tr[x] = {l, r};
	if(l == r) return;
	int mid = l + r >> 1;
	build(l(x), l, mid), build(r(x), mid + 1, r);
}
void insert(int &x, int lst, int l, int r, int v) {
	x = ++ idx;
	tr[x] = tr[lst];
	if(l == r) {
		val(x).fi += v;
		val(x).se ++;
		return;
	}
	int mid = l + r >> 1;
	if(v <= mid) insert(l(x), l(lst), l, mid, v);
	else insert(r(x), r(lst), mid + 1, r, v);
	pushup(x);
}
PII query(int x, int y, int l, int r, int nl, int nr) {
	if(nl <= l && r <= nr) {
		return {val(y).fi - val(x).fi, val(y).se - val(x).se};
	}
	int mid = l + r >> 1;
	PII res;
	if(nl <= mid) res = query(l(x), l(y), l, mid, nl, nr);
	if(nr > mid) {
		auto t = query(r(x), r(y), mid + 1, r, nl, nr);
		res.fi += t.fi;
		res.se += t.se;
	}
	return res;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
	cin >> n >> q;
	int cnt = 0;
	for(int i = 1; i <= n; i ++) {
		cin >> a[i];
		sum[i] = sum[i - 1] + a[i];
		if(a[i] <= 0) cnt ++;
		else {
			int l = 1, r = cnt + 1, tmp = 1;
			while(l <= r) {
				int mid = l + r >> 1;
				if(sum[i] - sum[i - mid] > 0) l = mid + 1, tmp = mid;
				else r = mid - 1;
			}
			ls[i] = tmp;
			cnt = 0;
		}
	}
	for(int i = 1; i <= n; i ++) 
		s[i] = s[i - 1] + ls[i], p[i] = i - ls[i] + 1;
		
	build(rt[0], 1, n);
	for(int i = 1; i <= n; i ++)
		insert(rt[i], rt[i - 1], 1, n, p[i]);
	while(q --) {
		int l, r;
		LL res = 0;
		cin >> l >> r;
		if(l == 1) cout << s[r] - s[l - 1] << '\n';
		else {
			auto t = query(rt[l - 1], rt[r], 1, n, l, n);
			res = (l + r) * (r - l + 1) / 2 + (r - l + 1);
			res -= t.fi;
			res -= (r - l + 1 - t.se) * l;
			cout << res << '\n';
		}
	}
    return 0;
}
```

---

## 作者：Wy_x (赞：3)

题目传送门：[P9681 幽默的世界。](https://www.luogu.com.cn/problem/P9681)

时间复杂度 $O(n+q)$。

卡常后[最优解](https://www.luogu.com.cn/record/list?pid=P9681&orderBy=1&status=&page=1)。


蒟蒻水平有限，讲不太清楚，请见谅。

------------

### 定义：
```cpp
int f_ans[200005]; //f_ans 前缀和数组，记录 i 之前合法区间与包含 i 的合法区间数量之和
int dis[200005]; //dis 记录包含 i 的合法区间 且区间右端点不为 i 的合法区间的数量之和
int id[200005];//id 记录这个点所处的块的编号
int tot;//编号
```

解释：块为以点 $tot$ 为右端点的合法区间的编号。

------------

###  解法：

因为题目保证当 $a$ 的一个连续子序列是幽默的时，有两个性质：

- $\sum\limits_{i=l}^ra_i>0$；

- 对于所有 $l\le x\le y<r$，都满足 $\sum\limits_{i=x}^y a_i\le 0$。

当**区间合法**时，我们不妨先从第二个性质下手。

当 $x=y$ 时，式子退化成 $a_x \le 0$，即保证 $l\le i <r$ 时，$a_x \le 0$。

再看第一个性质:

第一种情况：$l<r$，因为 $\sum\limits_{i=l}^ra_i>0$，且  $\sum\limits_{i=l}^{r-1}a_i \le 0$，所以 $a_r$ 必定大于 $0$。

第二种情况：$l=r$，即只需满足第一个性质，$a_r>0$，此区间就合法。

因为 $a_r>0$ 且 $\sum\limits_{i=x}^{y} a_i\le 0$ 恒成立，可得**每个答案区间不相交**。

一句话题意：给定 $l,r$，求仅有最后一项为正数，其它数都小于等于 $0$ 且最后一项要大于除了最后一项以外其它项之和的绝对值的序列的个数。

可以先枚举区间右端点 $r$，再枚举从这个端点最远可以到哪个左端点 $l$。

然后，对于 $l \le i \le r$，进行更改:

`f_ans[i]+=k,dis[i]+=k,id[i]=tot;`

每个变量的意思在定义的注释中。

统计答案时，
- 若点 $l$ 和 $r$ 同属一个区间且 $a_r\le 0$，答案为 $0$；

- 若点 $l$ 和 $r$ 不属于同一个区间且 $a_r \le 0$，答案为 `f_ans[r]-f_ans[l-1]-dis[r]`，减 $dis_r$ 是因为前缀和记录了包含点 $r$ 的区间数量，但 $a_r \le 0$，不能作为区间右端点，那么前缀和多加了 $dis_r$，将其减去即可；

- 若点 $l$ 和 $r$ 同属一个区间且 $a_r > 0$，或点 $l$ 和 $r$ 不属于同一个区间且 $a_r > 0$，直接输出 `f_ans[r]-f_ans[l-1]` 即可。

------------

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std; 

int n,q;
int a[200005];//输入数列
int f_ans[200005];
//f_ans 前缀和数组，记录 i 之前合法区间与包含 i 的区间数量之和
int dis[200005];
//dis 记录包含 i 的区间 且区间右端点不为 i 的区间的数量之和
int id[200005];//id 记录这个点所处的块的编号
int tot;//编号（可能不连续）

signed main()
{
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];
	//输入
	for(int i=1;i<=n;i++)
	{
		f_ans[i]=f_ans[i-1];//统计方案前缀和
		id[i]=++tot;//赋予编号
		if(a[i]<=0) continue;
		//这个点不能作为区间 [x,r] 的右端点(a[r]<=0)
		//继续循环
		
		int p=i-1,nw=a[i];
		//枚举区间左端点 p，nw 记录区间 [p,r] 的和
		while(p>=1&&a[p]<=0&&nw+a[p]>0) nw+=a[p--];
		//左端点若还可以移动就移动
		for(int j=p+1,k=1;j<=i;j++,k++) f_ans[j]+=k,dis[j]+=k,id[j]=tot;
		//更新前缀和数组，dis，区间编号
		dis[i]=0;//不记录右端点为 i 的情况
		//dis 记录包含 i 的区间 且区间右端点不为 i 的区间的数量之和
	}
	
	while(q--)
	{
		int l,r;
		cin>>l>>r;
		if(id[l]==id[r]&&a[r]<=0) cout<<0<<'\n';
		//l，r 同属一个区间且 r 不能作为右端点，答案为 0
		
		else if(id[l]!=id[r]&&a[r]<=0) cout<<f_ans[r]-f_ans[l-1]-dis[r]<<'\n';
		//l，r 不属于同一个区间且 r 不可作为 r 所属区间的右端点，
		//因为前缀和 f_ans 记录了包含 r 的区间，但 r 不能作为 r 所属区间的右端点
		//所以前缀和相减后还要减掉 dis[r]（可能有些难懂）
		
		else cout<<f_ans[r]-f_ans[l-1]<<'\n';
		//反之：
		//1: l，r 同属一个区间且 r 是右端点
		//2: l，r 不属于同一个区间且 r 可以作为 r 所属区间的右端点
		//前缀和直接相减即可
	}
	
	return 0;
}
```

---

## 作者：lqsy002 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P9681)。

## 解题思路

根据题意，区间 $[i,j]$ 是幽默的相当于从 $a_i$ 到 $a_{j-1}$ 全是负数并且 $a_j$ 大于 $0$。

这题不能直接使用前缀和，因为一旦遇到一个大于 $0$ 的数，那么之前的数并不会增加。

首先将所有输入读入如何对 $r$ 排序，维护一个 $sum_i$ 表示以 $i$ 结尾的所有的幽默区间个数，当 $a_i$ 大于 $0$ 时才有贡献，最后对每个区间进行前缀和即可。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 200005
using namespace std;
int n,q,a[maxn];
int p1=1,p2,res,cnt;
int sum[maxn],id[maxn];
int ans[maxn];
struct node{
    int l;
    int r;
    int id;
    bool operator<(const node &other)const{
        return r<other.r;
    }
}query[maxn];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;++i)
        cin>>a[i];
    for(int i=1;i<=q;++i){
        cin>>query[i].l>>query[i].r;
        query[i].id=i;
    }
    sort(query+1,query+1+q);
    for(int i=1;i<=q;++i){
        while(p1<=query[i].r){
            if(a[p1]>0){
                p2=p1-1;
                res=0;
                cnt=1;
                while(p2&&a[p2]<=0&&abs(res+a[p2])<a[p1]){
                    res+=a[p2];
                    --p2;
                    ++cnt;
                }
                for(int j=p1-cnt+1;j<=p1;++j)
                    sum[j]=sum[j-1]+1;
            }else 
                sum[p1]=sum[p1-1];
            ++p1;
        }
        ans[query[i].id]=sum[query[i].r]-sum[query[i].l-1];
    }
    for(int i=1;i<=q;++i)
        cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：kkxacj (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9681)

#### 思路

看到题目的要求对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$，发现 $x$ 可以等于 $y$，那么说明除了第 $r$ 个数其他数必须为负数，且还需满足 $\sum\limits_{i=l}^ra_i>0$，说明满足条件的序列必须是一段负数加一个正数，也可以只有正数，对于每个正数，位置为 $j$，往左找到第一个 $i$ 使得 $i$ 到当前位置 $j$ 这一段加起来为正数，那么这一段的贡献就为 $j - i + 1$，然后可以开一个数组把每个正数记下来，用一个类似前缀的东西表示到第 $i$ 个数有几个正数，这样就能快速找到 $x,y$ 之间的正数，然后前缀记一下到 $i$ 时前面一段的总贡献为多少直接减就行了。

#### 注意 $x,y$ 之间第一个正数可能能到的位置超过了边界 $x$，要特判。

**code**
```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,q,x,y,a[200010],aq[200010],aq1[200010],bjz[200010],o,o1,ans,t[200010],o2,l = 1,r,mid,o22; 
long long aq2[200010];//不开long long... 
int main()
{
	scanf("%d%d",&n,&q);
	for(int i = 1;i <= n;i++) 
	{
		scanf("%d",&a[i]);
		aq2[i] = aq2[i - 1] + a[i];
		if(a[i] > 0) 
		{
			r = i; o22 = i;
			while(l <= r)
			{
				mid = (l + r) / 2;
				if(aq2[i] - aq2[mid - 1] > 0) o22 = mid,r = mid - 1;
				else l = mid + 1;
			}
			l = i + 1;//正数的位置 
			bjz[i] = (i - o22);
		} 
		aq[i] = aq[i - 1] + bjz[i];
		aq1[i] = aq1[i - 1];
		if(a[i] > 0) aq[i]++,aq1[i]++,t[++o2] = i;
	}
	for(int i = 1;i <= q;i++) 
	{
		scanf("%d%d",&x,&y);
		ans = aq[y] - aq[x - 1]; 
		l = 0;
		for(int j = aq1[x];j <= aq1[y];j++)
		{
			if(x <= t[j]) 
			{
				if(t[j] - x <= bjz[t[j]]) ans = ans - bjz[t[j]] + t[j] - x;//删除原来的贡献加上现在的 
				break;
			}
		}
		printf("%d\n",ans); 
	}
	return 0;
}
```


---

## 作者：what_can_I_do (赞：2)

[传送门](https://www.luogu.com.cn/problem/P9681)

题目给的公式就是专门来迷惑你的。其实题目中要求的序列就只是仅有最后一项为正数，其它都为负数且最后一项要大于除了最后一项以外其它项之和的绝对值的序列。

我们可以用一个数组来记录从 $i$ 开始到离 $i$ 最近的正数的坐标，另一个数组记录从 $i$ 到离 $i$ 最近的正数这段序列是否满足题目所说的幽默的序列，也就是它可能的贡献。

然后我们从 $n$ 到 $1$ 枚举序列中的数，如果是正数就继续往前搜，知道前面的数已经与它不能构成幽默序列了就停止，并把路上的这些数的可能贡献记录下来。

接下来再用一个数组记录再这个数之前离它最近的正数的坐标，记录是为了在之后直接找到一个数的有效贡献区间的位置。

接着再用前缀和把每个数的可能贡献给前缀和一下。

最后对于每次询问如果 $l$ 和 $r$ 都在同一个负数区间内，输出 $0$，否则输出最近有效贡献位置到 $l$ 的这段区间的贡献总数。

# CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q;
long long a[200010];
bool b[3010][3010]={0};
long long t[200010]={0};
long long tv[200010]={0};
int xg[200010],qg[200010];
int main()
{
	scanf("%d%d",&n,&q);
	for(register int i=1;i<=n;i++) scanf("%lld",&a[i]);
	int la=n+1;
	for(register int i=n;i>=1;i--)
	{
		if(a[i]<=0){xg[i]=la;continue;}
		t[i]=1,xg[i]=i;
		int sum=a[i],k=i;
		la=i;
		i--;
		while(a[i]<=0&&i>=1)
		{
			sum+=a[i];
			if(sum<=0) break;
			t[i]=1;
			xg[i]=k;
			i--;
		}
		i++;
	}
	la=0;
	for(register int i=1;i<=n;i++){if(xg[i]==i) la=i;qg[i]=la;}
	for(register int i=1;i<=n;i++) tv[i]=tv[i-1]+t[i];
	while(q--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		if(xg[l]==xg[r]&&xg[r]!=r)
		{
			printf("0\n");
			continue;
		}
		printf("%lld\n",tv[qg[r]]-tv[l-1]);
	}
    return 0;
}
```

---

## 作者：未来姚班zyl (赞：2)

## 题目大意

给定一个序列 $a$，定义一个子序列是幽默的，当且仅当各数的和大于 $0$，且该子序列的不包含右端点的子区间的和小于等于 $0$。多次询问一个区间内有多少子序列是幽默的。

## 题目分析

第二个条件相当于除了右端点其它数都小于等于 $0$。再加上第一个条件就是右端点要大于其它数的和的相反数。显然，右端点是个正数。且对于每个右端点，满足条件的左端点是连续的。所以直接离线跑扫描线，支持区间修改和区间查询，线段树维护之。复杂度 $O((n+q)\log n)$。

话说为什么只评了黄啊，是否有更高妙的做法？

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1LL)
#define lc L,l,mid
#define rc R,mid+1,r
#define Root 1,1,n
#define OK l>=Ll&&r<=Rr
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define pb push_back
#define ull unsigned ll
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =2e5+5,M=1e6+5,inf=(1LL<<31)-1;
const ll llf=1e18,mod=1e8+7,bas=131;
const ui base=13331;
using namespace std;
int n=read(),m=read(),a[N],l[N];
ll out[N],ans;
vector<Pi >q[N];
struct seg{
	ll w,laz;
}xd[N<<2];
inline void modify(int x,int l,int r,int Ll,int Rr){
	if(OK)return xd[x].w+=r-l+1,xd[x].laz++,void();
	xd[L].w+=1LL*(mid-l+1)*xd[x].laz,xd[R].w+=1LL*(r-mid)*xd[x].laz;
	xd[L].laz+=xd[x].laz,xd[R].laz+=xd[x].laz;
	xd[x].laz=0;
	if(Ll<=mid&&Rr>=l)modify(lc,Ll,Rr);
	if(Ll<=r&&Rr>mid)modify(rc,Ll,Rr);
	xd[x].w=xd[L].w+xd[R].w;
}
inline ll query(int x,int l,int r,int Ll,int Rr){
	if(OK)return xd[x].w;
	xd[L].w+=1LL*(mid-l+1)*xd[x].laz,xd[R].w+=1LL*(r-mid)*xd[x].laz;xd[L].laz+=xd[x].laz,xd[R].laz+=xd[x].laz;
	xd[x].laz=0;
	if(Rr<=mid)return query(lc,Ll,Rr);
	if(Ll>mid)return query(rc,Ll,Rr);
	return query(lc,Ll,Rr)+query(rc,Ll,Rr);
}
signed main(){
	rep(i,1,n)a[i]=read();
	per(i,n,1){
		if(a[i]>0){
			int j=i;
			ll sum=0;
			while(j>1&&a[j-1]<=0&&sum-a[j-1]<a[i])j--,sum-=a[j];
			l[i]=j;
			i=j;
		}
	}
	int Ll,r;
	rep(i,1,m)Ll=read(),r=read(),q[r].pb({Ll,i});
	rep(i,1,n){
		if(l[i])modify(Root,l[i],i);
		for(auto y:q[i])out[y.second]=query(Root,y.first,i);
	} 
	rep(i,1,m)pf(out[i]),putchar('\n');
	return 0;
}
```


---

## 作者：251Sec (赞：2)

考虑什么样的子段是幽默的，可以发现这样的子段的最后一个数为正数，且其它数都为非正数，且所有数的和大于 $0$。

我们考虑找出所有的幽默的子段：枚举最后那个正数，往前枚举子段的左端点，则可以用一个前缀和快速判断子段是否合法。因为所有正数左侧连续的非正数个数之和是 $O(n)$ 的，所以复杂度正确，且由此我们知道幽默的子段总个数是 $O(n)$ 的。

这样我们的问题就变成了：给定 $O(n)$ 个区间 $[x,y]$。有 $O(q)$ 次询问，给定区间 $[l,r]$ 求有多少 $[x,y]$ 是它的子区间。这是经典问题，转化成在二维平面上若干个点 $(x,y)$，多次询问矩形 $(l,l,r,r)$ 内的点个数。扫描线即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, q;
int a[200005];
vector<int> mdf[200005];
struct QRY { int l, r, id; };
vector<QRY> qry[200005];
ll f[200005], ans[200005], s[200005];
void Modify(int i, ll x) { for (; i <= n; i += i & -i) f[i] += x; }
ll Query(int i) { ll res = 0; for (; i; i &= i - 1) res += f[i]; return res; }
ll Query(int l, int r) { return Query(r) - Query(l - 1); }
int main() {
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++) scanf("%d", a + i), s[i] = s[i - 1] + a[i];
    for (int i = 1; i <= n; i++) {
        if (a[i] > 0) {
            for (int j = i; j && (a[j] <= 0 || j == i) && s[i] - s[j - 1] > 0; j--) {
                mdf[j].emplace_back(i);
            }
        }
    }
    for (int i = 1; i <= q; i++) {
        int l, r; scanf("%d%d", &l, &r);
        qry[l - 1].push_back({ l, r, -i });
        qry[r].push_back({ l, r, i });
    }
    for (int i = 1; i <= n; i++) {
        for (auto j : mdf[i]) Modify(j, 1);
        for (auto j : qry[i]) ans[abs(j.id)] += Query(j.l, j.r) * (j.id > 0 ? 1 : -1);
    }
    for (int i = 1; i <= q; i++) printf("%lld\n", ans[i]);
    return 0;
}
```

---

## 作者：TernaryTree (赞：1)

来点线性最优解。

先来解读一手题目意思啊，你考虑一下 $x=y$ 然后就发现一个幽默的区间是一堆的非正数后面带上正数，并且这个区间和为正。

然后显然就有，对于一个点，以这个点为左端点，要么仅存在一个幽默的区间，要么不存在。然后我们贡献暴力扔这上面不就是区间和问题了吗！

具体来说，枚举右端点（一定是个正数），然后暴力往左边扩展，如果到这个点区间和还是正的那就把贡献扔上去。

直接求区间贡献和可能会寄，因为一个左端点所对应的右端点可能不在询问区间里，这些贡献我们就多算了。而简单观察可以发现区间最右边的正数的右边那些点都造成不了贡献了，所以我们将 $r$ 改为区间最右边正数的位置就是正确的答案。

区间最右边正数的位置当然可以二分做，但是我们预处理一手，记 $pre_i$ 为 $i$ 左边第一个正数位置，若 $a_i>0$ 则 $pre_i=i$，否则 $pre_{i}=pre_{i-1}$，询问直接 $r$ 变成 $pre_r$ 即可。

记得判 $pre_r<l$ 的情况输出 $0$。

时间复杂度 $\Theta(n+q)$。

[Code](https://www.luogu.com.cn/paste/b26y8zui)

---

2023.10.4 upd：最优解被抢了，愤怒！！！！！！题解通道怎么还是没开，愤怒！！！！！！！！！！！！

---

## 作者：Null_h (赞：1)

## 题目大意

给定一个序列，输出限定范围内满足要求的子序列，使该子序列的和大于 0，且该子序列所有不包含最后一个数字的子序列之和小于 0。

## 思路

不难发现，满足要求的子序列的最后一个总是正整数，所以可以我们记录序列中所有正整数的位置，对于每一个正整数，求出以它结尾的满足要求的最长子序列的长度。可以看出，以它结尾且小于该长度的子序列均合法。

对于每一次询问，我们可以二分找到能被包含的正整数，对于所有的在区间内的正整数，只存在两种情况。如果该数是区间内第一个正整数，可能会无法取到所有可能情况，这时它对答案的贡献为之前记录的长度与它到区间头部的距离中的较小小值，否则一定是记录的长度。

为了避免逐个统计的巨大复杂度，我们可以维护一个前缀和，达成 $O(n)$ 处理，$O(\log n)$ 查询，$O(1)$ 计算。

总复杂度 $O(q\log n)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int c[300000];
vector<int> h;
unordered_map<int,int> l;
int d[300000];
signed main(){
	ios::sync_with_stdio(false);
	h.push_back(-1);
	int a,b;
	cin>>a>>b;
	for(int i=1;i<=a;i++){
		cin>>c[i];
		if(c[i]>0){
			h.push_back(i);
		}
	}
	for(int i=1;i<h.size();i++){
		int n=c[h[i]],m=1;
		for(int j=h[i]-1;j>=1;j--){
			n+=c[j];
			if(n<=0||c[j]>0){
				break;
			}
			m++;
		}
		l[i]=m;
	}
	for(int i=1;i<h.size();i++){
		d[i]=d[i-1]+l[i];
	}
	h.push_back(0x3f3f3f);
	while(b--){
		int x,y;
		cin>>x>>y;
		int s=0;
		int o=lower_bound(h.begin(),h.end(),x)-h.begin(),p=upper_bound(h.begin(),h.end(),y)-h.begin()-1;
		if(x<=h[p]&&h[o]<=y){
			s+=min(h[o]-x+1,l[o]);
			s+=d[p]-d[o];
		}
		cout<<s<<endl;
	}
	return 0;
}
```

---

## 作者：lianchanghua (赞：0)

#### 题目描述

给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：

- $l\le l'\le r'\le r$；
- 连续子序列 $a_{l'},a_{l'+1},\cdots a_{r'}$ 是幽默的。

#### 解题思路

很显然，由于子任务 $2$ 的数据范围为 $n,q\le 3\times 10^3$，我们可以通过暴力枚举，轻松拿下 $35$ 分，配合上本场比赛那么水的第一题，可以拿到 $488$ 名的好成绩。

暴力代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,a[200005];
int slove(int l,int r){
	int cnt=0;
	for(int rt=r;rt>=l;rt--){
		if(a[rt]>0){
			cnt++;
			int s=0;
			for(int lt=rt-1;lt>=l;lt--){
				if(a[lt]>0) 	break;
				s+=a[lt];
				if(a[rt]+s>0) 	cnt++;
				else 			break;
			}
		}
	}
	return cnt;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)	cin>>a[i];
	while(q--){
		int l,r;
		cin>>l>>r;
		cout<<slove(l,r)<<"\n";
	}
	return 0;
}
```

当然，我们不能就此而止步，可以再看一眼题面，分析出真正能够通过此题的算法。

>$q$ 次询问，每次给定两个整数 $l,r$。

根据做题的经验，这种一般都是线段树。所以我们就可以往这块方向去思考。

我们可以扫一遍 $a$ 数组，当发现有 $a_i$ 大于 $0$ 时，就让我们当前的指针记为 $i$，用一个 $pre$ 数组对指针进行存储。

接下来，我们反方向遍历一遍，当 $a_i$ 大于 $0$ 时，让我们的 $s$ 清空，否则进行加和。如果当前的 $s$ 比 $0$ 大的话，我们就对线段树进行更新。

最后，每次询问 $l$，$r$。当我们发现 $pre_r < l$ 时，输出 $0$，否则输出 $l$ 到 $pre_r$ 的区间之和。

#### AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5+5;
int n,m,a[N],tr[N<<2],pre[N];
void update(int p,int l,int r,int x){
    if(x>r||x<l) return;
    if(l==r){
        tr[p]++;
        return;
    }
    int mid=l+r>>1;
    update(p<<1,l,mid,x);
    update(p<<1|1,mid+1,r,x);
    tr[p]=tr[p<<1]+tr[p<<1|1];
}
int query(int p,int l,int r,int a,int b){
    if(b<l||a>r) return 0;
    if(a<=l&&r<=b) return tr[p];
    int mid=l+r>>1;
    return query(p<<1,l,mid,a,b)+query(p<<1|1,mid+1,r,a,b);
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1,p=-1;i<=n;++i) {
        cin>>a[i];
        if(a[i]>0) p=i;
        pre[i]=p;
    }
    for(int i=n,j,s=0;i;--i){
        if(a[i]>0) s=0;
        s+=a[i];
        if(s>0) update(1,1,n,i);
    }
    for(int l,r;m--;){
        cin>>l>>r;
        if(pre[r]<l) cout<<"0\n";
        else cout<<query(1,1,n,l,pre[r])<<"\n";
    }
    return 0;
}
```

---


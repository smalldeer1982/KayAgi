# 「KDOI-06-J」贡献系统

## 题目描述

洛谷贡献系统上线了！

现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。

假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：

+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；
+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；
+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。

作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。

对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。

**【样例 #2】**

见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。

**【样例 #3】**

见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。



***

**【数据范围】**

对于所有数据保证：$1\le T\le 5$，$1\le n\le 2\times 10^5$，$0\le r_i\le 10^9$，$-10^9\le c_i\le 10^9$，且对于任意 $1\le i<n$，$r_i>r_{i+1}$。

| 测试点编号  |    $n\le $     | 特殊限制 |
| :---------: | :------------: | :------: |
|  $1\sim3$   |      $8$       |    无    |
|     $4$     |     $100$      |   ABC    |
|     $5$     |     $100$      |    C     |
|  $6\sim 7$  |     $100$      |    无    |
|  $8\sim 9$  | $5\times 10^3$ |    AB    |
| $10\sim 11$ | $5\times 10^3$ |    C     |
| $12\sim 14$ | $5\times 10^3$ |    无    |
|    $15$     | $2\times10^5$  |    AB    |
| $16\sim 18$ | $2\times10^5$  |    B     |
| $19\sim 21$ | $2\times10^5$  |    C     |
| $22\sim 25$ | $2\times 10^5$ |    无    |

+ 特殊性质 A：对于任意 $1\le i<n$，保证 $c_i=c_{i+1}$；
+ 特殊性质 B：对于任意 $1\le i<n$，保证 $c_i\le c_{i+1}$；
+ 特殊性质 C：对于任意 $1\le i\le n$，保证 $c_i\ge 0$。

## 样例 #1

### 输入

```
3
5
3816 3738 3726 3621 3582
111 109 -50 -22 208
8
8 7 6 5 4 3 2 1
128 1 0 0 0 0 1 0
10
10 9 8 7 6 5 4 3 2 1
1 1 4 5 1 4 1 9 1 9
```

### 输出

```
280
1
34
```

# 题解

## 作者：zjpwdyf (赞：35)

## P9742 题解
### 题目大意
给定一个数列 $c$，你需要给第 $i$ 个位置赋一个**唯一**排名 $b_i$，若 $b_i>i$，则将答案减去 $c_i$。若 $b_i<i$，则将答案加上 $c_i$，若相等，则什么都不做。求答案的最大值。

---
### 题目思路
- 当 $c_i>0$ 时，我们肯定希望 $i$ 的排名上升。
- 当 $c_i<0$ 时，我们肯定希望 $i$ 的排名下降。
- 当 $c_i=0$ 时，则排名任意。

---

先讨论 $c_i$ 全部大于 $0$ 的情况。

显然可以让第一名掉到最后一名，其他人顺次往前移一位。但这可能不是最优方案。

但是我们可以让 $1$ 至 $i$ 名保持不变，第 $i+1$ 名掉到最后一名，$i+2$ 到 $n$ 名顺次往前移（$1\le i\le n$），这才是一种最优方案。

---
那么 $c_i$ 全部小于 $0$ 的情况也可以照样推出来，这里直接放结论：让 $i$ 至 $n$ 名保持不变，第 $i-1$ 名升到第一名，$1$ 到 $i-2$ 名顺次往后移（$1\le i\le n$）。

---
现在考虑正解。

我们可以将原数列分成三部分：

第一部分：$1$ 到 $x-1$，里面全是正数。

第二部分：$y+1$ 到 $n$，里面全是负数。

第三部分：$x$ 到 $y$，里面有正有负有 $0$。（$1\le x\le y\le n$）

对于第一、二部分，我们可以直接套用上面的结论。

对于第三部分，$c_x$ 必然是非正数，$c_y$ 必然是非负数。我们可以先让第 $x$ 位空出来，接着让所有正数顺次往前移，所有非正数往后移，你会发现刚好能移完（自己画个图就能懂）。也就是这一部分累加 $c_i$ 的绝对值即可。

---
### 参考代码
有一个细节，就是用前缀和优化，见代码：
```cpp
#include<bits/stdc++.h>
#define gsum(l,r) (sum[r]-sum[l-1])
using namespace std;
typedef long long ll;
const int N=2e5+5;
ll T,n,c[N],tmp,lft,rgt,sum[N],ans1,ans2;
int main(){
	cin>>T;
	while(T--){
		ans1=ans2=0;
		cin>>n;
		for(int i=1;i<=n;i++) scanf("%lld",&tmp);
		for(int i=1;i<=n;i++){
			scanf("%lld",c+i);
			sum[i]=sum[i-1]+abs(c[i]);
		}
		for(lft=1;c[lft]>0&&lft<=n;lft++);
		for(rgt=n;c[rgt]<0&&rgt>=1;rgt--);
		for(int i=1;i<lft;i++) ans1=max(ans1,-c[i]+gsum(i+1,lft-1));
		for(int i=n;i>rgt;i--) ans2=max(ans2,c[i]+gsum(rgt+1,i-1));
		cout<<ans1+ans2+gsum(lft,rgt)<<'\n';
	}
	return 0;
}
```

---

## 作者：引领天下 (赞：17)

看到题目就想到，最后一定是有人上分有人下分，那么就要尽可能让 $c$ 是正的的人上分，$c$ 是负的的人下分。

于是考虑把所有选手按照 $r$ 降序排列，只需要在连续的某一段 $c$ 全是正的的选手前面找一个 $c$ 是负的的选手，给他踢到后面去倒数，那么这一段的选手可以全部排名进步一位，也就是上分了，那么这些贡献就可以全部收集到。

但是如果这一段选手前面没有 $c$ 是负的的选手呢？

这时候就考虑，从前面选择某个选手，委屈他一下让他下个分，这样他后面的选手就都可以上分了。但是这个选择的标准并不是在于这个选手自己的 $c$ 是多少，而是要综合考虑他后面的选手的 $c$ 的和，以及他自己下分造成的 $-c$ 的影响。比如某个选手的 $c$ 很大，你如果让他下分了会导致扣一大堆贡献，那就只能让他维持原有水平不变。

同理，如果最后一段的人 $c$ 全是负的，也得挑一个人出来上分，才能让剩下的这些人下分。

处理掉首尾两段的特殊情况之后，中间剩下的就是上来讨论的贪心策略，也就是都无论正负，都可以计算到贡献里了（负的就是加上绝对值）。

输入已经保证了 $r$ 降序。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,t,x,a[200005];
signed main(){
	ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>x;
		for(int i=1;i<=n;i++)cin>>a[i];
		int l=1,r=n;
		while(l<=n&&a[l]>0)l++;
		while(r>=1&&a[r]<=0)r--;
		int sum=0,mx=0,ans=0;
		for(int i=1;i<l;i++)sum+=a[i];
		for(int i=1;i<l;i++)sum-=a[i],mx=max(mx,sum-a[i]);
		ans+=mx;
		sum=0,mx=0;
		for(int i=n;i>r;i--)sum-=a[i];
		for(int i=n;i>r;i--)sum+=a[i],mx=max(mx,sum+a[i]);
		ans+=mx;
		for(int i=l;i<=r;i++)ans+=abs(a[i]);
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：lzy20091001 (赞：7)

[洛谷 P9742 「KDOI-06-J」贡献系统](https://www.luogu.com.cn/problem/P9742)

**默认所有人按 $a$ 从小到大排列。** 

## 思路

### 特殊性质 AC

由于不可能所有人都进步，所以最优情况为 $1$ 人退步 $(n - 1)$ 人进步。

$b_1 = n, b_i = i - 1(i \in [2, n])$ 时满足条件，此时有 $\text{ans} = (n - 2) \cdot c$。

### 特殊性质 C

对于第 $1$ 个人，分以下两种情况讨论：

- 若 $b_1 \ne 1$，则第 $1$ 个人贡献一定为负，类似于特殊性质 AC，$b_1 = n, b_i = i - 1(i \in [2, n])$ 时贡献最大。总贡献为 $\sum_{i = 2}^{n}c_i - c_1$。

- 若 $b_1 = 1$，则第 $1$ 个人贡献为 $0$。此时问题转化为原问题的子问题：求在后面的 $n - 1$ 个人中的最优解。

答案即所有 $b_i \ne i (i \in [1, n - 1])$ 中最优的。

更进一步地，我们有结论：
$$
\text{ans} = \max_{i = 1}^{n - 1}\{\sum^{n}_{j = i + 1}c_j - c_i\}
$$
其中 $\sum^{n}_{j = i + 1}c_j$ 可以用前缀和维护，时间复杂度为 $O(n)$。

### 正解

设 $c_x$ 是第 $1$ 个非正的 $c$，$c_y$ 是最后一个非负的 $c$。

- 对于任意 $i \in [1, x - 1]$，都满足 $c_i > 0$，即特殊性质 C。

- 对于任意 $i \in [y + 1, n]$，都满足 $c_i < 0$，与特殊性质 C 同理。

---

若 $x \le y$，则对于 $[x, y]$，以下方式构造 $b$ 可使得贡献最大：

将正数排在前面，$0$ 排在中间，负数排在后面，而所有正数内部、所有 $0$ 内部、所有负数内部顺序不变。

形式化地说，对于任意 $i_1, i_2, j_1, j_2, k_1, k_2$ 满足 $c_{i_1} > 0, c_{i_2} > 0, c_{j_1} = c_{j_2} = 0, c_{k_1} < 0, c_{k_2} < 0$ 且 $i_1 < i_2, j_1 < j_2, k_1 < k_2$，总有 $b_{i_1} < b_{i_2} < b_{j_1} < b_{j_2} < b_{k_1} < b_{k_2}$。

此时的总贡献为 $\sum_{i = x}^{y}|c_i|$，为最优解。

证明：

设 $c_{i_1}$ 是 $[x, y]$ 内第 $1$ 个大于 $0$ 的 $c$，则 $b_{i_1} = 1$。由于 $c_x$ 非正所以 $i_1 > x$。故 $b_{i_1} < i_1$，所以第 $i_1$ 个人的贡献为正。

设 $c_{i_2}$ 是 $[x, y]$ 内第 $2$ 个大于 $0$ 的 $c$，则 $b_{i_2} = 2$ 且 $i_2 > i_1 \ge 2$。故 $b_{i_2} < i_2$，所以第 $i_2$ 个人的贡献同样为正。

同理可证对于任意 $i \in [x, y]$，都有第 $i$ 个人的贡献为 $|c_i|$。即此时的总贡献为 $\sum_{i = x}^{y}|c_i|$。易证为最优解。

---

最终答案为 $[1, x - 1]$，$[x, y]$，$[y + 1, n]$ 三个区间内最大贡献的总合。

综上有：
$$
\text{ans} = \max_{i = 1}^{x - 2}\{\sum^{x - 1}_{j = i + 1}c_j - c_i\} + \sum_{i = x}^{y}|c_i| + \max_{i = y + 2}^{n}\{-\sum^{i - 1}_{j = y + 1}c_j + c_i\}
$$

时间复杂度为 $O(n)$。

## 代码

```cpp
#include <cmath>
#include <iostream>

int c[200005];
long long s[200005]; // 前缀和

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--)
    {
        int n, x, y;
        long long ans1 = 0, ans2 = 0, ans3 = 0;

        s[1] = 0; // 前缀和注意初始化

        std::cin >> n;
        for (int i = 1; i <= n; i++)
        {
            int r;
            std::cin >> r;
        }
        for (int i = 1; i <= n; i++)
        {
            std::cin >> c[i];
            s[i] = s[i - 1] + c[i];
        }

        x = n + 1, y = 0;            // 初始化，防止找不到
        for (int i = 1; i <= n; i++) // 寻找 x
            if (c[i] <= 0)
            {
                x = i;
                break;
            }
        for (int i = n; i >= 1; i--) // 寻找 y
            if (c[i] >= 0)
            {
                y = i;
                break;
            }

        // 计算答案
        for (int i = 1; i < x - 1; i++)
            ans1 = std::max(ans1, s[x - 1] - s[i] - c[i]);
        for (int i = n; i > y + 1; i--)
            ans3 = std::max(ans3, 0 - (s[i - 1] - s[y]) + c[i]);
        for (int i = x; i <= y; i++)
            ans2 += abs(c[i]);

        std::cout << ans1 + ans2 + ans3 << "\n";
    }

    return 0;
}
```

---

## 作者：ダ月 (赞：6)

算是验题人的题解吧。

显然，$r_i$ 没有用。

测试点 $1\sim 3$（$12$ pts）：


拿到这个题，没什么好头绪，先打个暴力先，即枚举全排列。

时间复杂度：$O(n!\times n)$。

```
const int N=5e5+10;
int a[N],p[N];
int T,n;
int main(){
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		for(int i=1;i<=n;i++)
			cin>>a[i];
		for(int i=1;i<=n;i++)
			p[i]=i;
		int ans=0;
		vector<int> Ans,TAns;
		do{
			int rs=0;
			for(int i=1;i<=n;i++){
				if(p[i]<i)rs+=a[i];
				else if(p[i]>i) rs-=a[i];
			}
			if(rs>ans){
				vector<int>ans;
				for(int i=1;i<=n;i++)
					if(p[i]<i)ans.pd(1);
					else if(p[i]>i)ans.pd(-1);
					else ans.pd(0);
				Ans=ans;
				ans.clear();TAns.clear();
				for(int i=1;i<=n;i++)
					TAns.pd(p[i]);
			}
			ans=max(ans,rs);
		}while(next_permutation(p+1,p+n+1));
	//	for(auto y:Ans)printf("%d ",y);puts("");
	//	for(auto y:TAns)printf("%d ",y);puts("");
		printf("%lld\n",ans);
	}
```

测试点 $1\sim 14$（$56$ pts）：

注意到上面那个代码的注释了吗。记 $p_i$ 为当前枚举的全排列。我们定义序列 $b_i$，当 $p_i<i$ 时 $b_i$ 为 $1$，$p_i>i$ 为 $-1$，$p_i=i$ 为 $0$。我们会发现答案会出现 $b_i$ 呈现 $[0,\dots,0,-1,\dots,1,0,\dots,0]$，即最左边和最右边都为 $0$ 的情况，最左边非 $0$ 数为 $-1$，最右边非 $0$ 数为 $1$，中间随意。既然中间随意，我们就尽可能贪。

我们只需要维护 $\begin{aligned}\max_{[l,r]\in[1,n]}(-c_l+c_r+\sum_{i=l+1}^{r-1}|c_i|)\end{aligned}$，其中满足 $r-l+1\ge 2$。

我们可以直接预处理 $c_i$ 的前缀和，$O(n^2)$ 计算这条式子。

测试点 $1\sim 25$（$100$ pts）：

感不感觉可以拿线段树维护。

我们从左往右枚举，枚举到 $i$ 时，就将位置 $1\sim i-1$ 加上 $|c_i|$，然后求最大值更新答案，然后再在 $i$ 位置加上 $-c_i$ 即可。

这些都可以线段树完成。

时间复杂度：$O(n\log n)$。

赛场代码，有点丑，给关键代码吧。

```
struct node{ll x,laz;}tr[N<<2];
void pushup(int rt){tr[rt].x=max(tr[rt<<1].x,tr[rt<<1|1].x);}
void addson(ll rt,ll x){tr[rt].x+=x;tr[rt].laz+=x;}
void pushdown(int rt){
	if(!tr[rt].laz)return;
	addson(rt<<1,tr[rt].laz);addson(rt<<1|1,tr[rt].laz);
	tr[rt].laz=0;
}
void build(int rt,int l,int r){
	tr[rt]={0,0};
	if(l==r)return;
	auto mid=l+r>>1;
	build(rt<<1,l,mid);build(rt<<1|1,mid+1,r);
}
void change(int rt,int l,int r,int x,int y,ll z){
	if(x<=l&&r<=y)return addson(rt,z);
	auto mid=l+r>>1;pushdown(rt);
	if(x<=mid)change(rt<<1,l,mid,x,y,z);
	if(y>mid)change(rt<<1|1,mid+1,r,x,y,z);
	pushup(rt);
}
ll Query(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[rt].x;
	auto mid=l+r>>1;ll ans=0;pushdown(rt);
	if(x<=mid)ans=max(ans,Query(rt<<1,l,mid,x,y));
	if(y>mid)ans=max(ans,Query(rt<<1|1,mid+1,r,x,y));
	return ans;
}
```


```
build(1,1,n);
for(int i=1;i<=n;i++){
	if(i>1)ans=max(ans,Query(1,1,n,1,i-1)+a[i]);
	if(i>1)change(1,1,n,1,i-1,abs(a[i]));
	change(1,1,n,i,i,-a[i]);
}
printf("%lld\n",ans);
```

哦哦，更新一下，放个错解，可能不好卡，就是枚举两边 $5000$ 个也能过：

```
for(int i=1;i<=n;i++)s[i]=s[i-1]+abs(a[i]);
auto query=[&](int l,int r)->ll{if(l>r)return 0;return s[r]-s[l-1];};
ll ans=0;
auto GetVal=[&](int l,int r)->ll{if(l==r)return 0;return query(l+1,r-1)-a[l]+a[r];};
for(int i=1;i<=min(n,5000ll);i++)
	for(int j=max(n-5000,i+1ll);j<=n;j++)
		ans=max(ans,GetVal(i,j));
printf("%lld\n",ans);
```


---

## 作者：Dream__Sky (赞：5)

考虑贪心。


首先我们发现，负贡献的排名更靠后更优，正贡献的排名更靠前更优，贡献为 $0$ 不用考虑，因为 $0$ 是无论是往前排还是往后排贡献都为 $0$。那我们要想办法把负贡献的放到后面，正贡献的放到前面。

我们可以枚举第一个出现的负数的位置，与最后一个出现正数的位置。把这一段中的正数全部往前移，把负数全部往后移，那么这段中的所有数的贡献都变成了它们的绝对值和，可以用前缀和维护。为什么呢？因为我们之前找的是第一个负数的位置，把正数往前移，那么这段中所有的正数前必定有一个负数，而负数要往后移，所以排名会上升。负数同理。

现在我们还剩下前面一串正数前缀，和后面一串负数后缀。

下面设维护的绝对值前缀和数组为 $pre_i$，各个贡献为 $a_i$，正数前缀起点为 $l$，终点为 $r$，负数后缀起点为 $x$，终点为 $y$。

先考虑正数前缀，和前面一样，排名一定靠前更优。我们可以枚举一个断点 $i$（$l\leq i <r$），把断点移到正数串最后。那么断点前的正数贡献为 $0$，因为排名不变。断点的贡献为 $-a_i$，因为排名靠后了。断点后的数，贡献为 $pre_r-pre_i$，即这些数的和。在所有断点的答案里取最大值，即 $\max (pre_r-pre_i-a_i)$。

再考虑负数后缀，刚好和正数相反。负数是排名越靠后更优。同样也枚举断点 $i$（$x<i\leq y$），把断点放到前面，断点后的数贡献为0，断点前的数贡献为 $pre_{i-1}-pre_{x-1}$，断点的贡献为 $a_i$（$a_i$ 为负）。在所有断点的答案里也取最大值，即 $\max (pre_{i-1}-pre_{x-1}+a_i)$。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[200001],b[200001],c[200001],T,n;
int fron(int l,int r)
{
	int maxn=0;
	for(int i=l;i<=r;i++)
		maxn=max(maxn,c[r]-c[i]-b[i]);
	return maxn;
}//正数前缀
int behin(int l,int r)
{
	int maxn=0;
	for(int i=l;i<=r;i++)
		maxn=max(maxn,c[i-1]-c[l-1]+b[i]);
	return maxn;
}//负数后缀
namespace work
{
	int main()
	{
		cin>>n;
		memset(c,0,sizeof c);
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++) cin>>b[i];
		for(int i=1;i<=n;i++) c[i]=c[i-1]+abs(b[i]);//前缀和
		int zheng=0,fu=0,daan=0;
		for(int i=1;i<=n;i++) if(b[i]<0) {fu=i;break;}
		for(int i=n;i>=1;i--) if(b[i]>=0) {zheng=i;break;}//求第一个负数，最后一个正数
		if(fu&&zheng) daan=daan+c[zheng]-c[fu-1]+fron(1,fu-1)+behin(zheng+1,n);//分成三种情况求和
		else if(fu&&!zheng) daan=behin(1,n);//全是负数，既没有正数前缀
		else if(zheng&&!fu) daan=fron(1,n);//全是正数，没有负数后缀
		cout<<daan<<"\n";
		return 0;
	}
}
signed main()
{
	cin>>T;
	while(T--) work::main(); 
	return 0;
}
```


---

## 作者：hank_wenstion (赞：5)


### 简要题意
每个数据中有一些个人，每个人有互不相同的等级分和贡献值，等级分是从大到小有序给出，你的初始贡献值为零。

如果这个人在比赛中的排名比等级分排名大且没有两个人的排名相同，你的贡献值会加上他的贡献值，反之则会减去他的贡献值，注意贡献值有可能是负的，排名相等贡献值不变。求出对于所有可能的比赛排列名次，在比赛结束后你的贡献值最大是多少。

### 题目分析
第一名排名无法上升，要么不变，要么下降，因此无法给你增加贡献值。

等级分没有用的，在数据范围里已经明确规定等级分是从大到小给出，已经是有序的，单独用一个变量来消除等级分就可以。

通过数据范围我们可知，等级分和贡献值的绝对值最大都是十的九次方，这点要注意。

### 解题思路
这题乍一看像是全排列，诚然这样的思路能过部分点，但数据过大会爆以至于无法得满分，怎么办？

仔细一想就会发现，这题的本质是在问如何让我们收益最大化，排名其实就是顺序。因此我们转换思路，试着用贪心或者动态规划去写。可以从第二个人开始判定，先通过贡献量来判断是否去换当前这个人和前一个人的排名，这之后再判断这一轮过后由谁掉排名。

这里要注意，一个人只能减一次贡献值，因此我们可以设置一个变量来记录前面有人排名掉下去之后的因此而上升的人增加的贡献值和掉下去之后减的贡献值的和，也就是这一举动的收益。以此来判断是否需要换排名和由谁来换排名。

上代码
```cpp
#include <iostream>
#include <algorithm>
#include <cmath> 
#define ll long long 
using namespace std;

int d,n,T;
ll ce[200010];
ll ans=0,p;//ans总分，p为前i-1个人中有一人名次掉下来了后他的贡献和排名上升的人的贡献的总和。
//不开longlong见祖宗
 
int main(){
	cin>>T;
	for(int k=1;k<=T;k++){
		cin>>n;
		ans=0;
		for(ll i=1;i<=n;i++){
			cin>>d;
		}
		for(ll i=1;i<=n;i++){
			cin>>ce[i];
		}
		p=-ce[1];//第一名排名无法上升，只能下降 
		for(ll i=2;i<=n;i++){//从第二名开始 
  		    if(ce[i]+p>ans){//判断当前要不要有人掉排名掉到当前这个人后面，将之前算出来的团加到ans中，如果加上团的更大就换，否则保持不变。
				ans=ce[i]+p;
			} 
  		    p=max(-ce[i],abs(ce[i])+p);//判断当前让谁掉排名，p+abs(a[i])是接着掉,掉下去人扣的贡献，将p加上上来的第i名的贡献形成一个团（就是p） ，-1*a[i]是如果掉排名代价过大就重新换下一个人掉排名 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
结束，感谢阅读。



---

## 作者：abensyl (赞：4)

原题：[P9742 「KDOI-06-J」贡献系统](https://www.luogu.com.cn/problem/P9742)。

一道很好的思维题。

## 思路

题面中说了一个叫 $r$ 的数组，而实际上 $r$ 数组是~~一点用都没有~~的。

首先，本题中的人分为三种，一种是想要加分的人，这些人的 $c_i>0$，另一些人想掉分即 $c_i<0$，还有一种人，我们暂且称他们为随便人，他们的 $c_i=0$，加分还是掉分对于他们无所谓，但是随便人的出现不会影响我们的解题。

考虑以下情况：

如果对于一些参加比赛的人，他们都想进步，那么要么所有人都不进不退，要么就牺牲其中的一个人，让他退步，另外的等级分比他低的人都进步。

如果所有人都想退步，也是如此的，对于这种情况，我们可以 $O(n)$ 算出答案，其中的 $n$ 表示都想退步或者都想进步的人的数量。

如果有人想进步，有人想退步，而且交织排列，那么事情就会复杂很多，考虑如下情况：

如果有一个人想进步，另一个人想退步，想退步的人比想进步的人等级分高，那么可以直接交换他们两人的名次，这样的话两人都能够满意自己的结果，你可以得到两个人的 $c_i$ 的绝对值之和的分数。

那么如果是多个人有的人想退步有的人想进步就不一样了，假设最后一名（等级分最低的人）想退步，他是退步不了的，第一名（等级分最高的人）想进步，他也是进步不了的，那么如果其中最后一名想进步，第一名想退步，那么可以通过构造，发现等级分介于这两人之间的所有选手都可以按照自己的喜好来进退步，这是很好的一件事情。

那么我们现在不妨把数列划分为三段，第一段是等级分最高的想进步的人，第二段是以等积分最高的想退步的人开始，到等级分最低的想进步的人结束，第三段是等级分极低，想退步的连续的人。

举个例子，如果 $c$ 数组是 $3,4,2,-1,-3,6,9,-3,-4,-1$，那么前三个元素都是等级分高想进步的人，划为第一段，中间四个人为第二段，最后三个认为第三段。

对于三段，第一段和第三段可以用前/后缀和的思路求解，中间的第二段中所有人都可以满足，总时间复杂度 $O(n)$，可过。

**别忘了开 long long！**

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int f=1,x=0;
	char ch=getchar();
	while(!isdigit(ch)) { if(ch=='-') f=-1; ch=getchar(); }
	while(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }
	return f*x;
}
inline void write(int x) {
	if(x<0) putchar('-'),write(-x);
	else if(x<10) putchar(x+'0');
	else write(x/10),putchar(x%10+'0');
}
const int N = 2e5+5;
int r[N],c[N];
void solve() {
	//多测注意清空！
	int n=read(),res=0;
	for(int i=1;i<=n;++i) r[i]=read();
	for(int i=1;i<=n;++i) c[i]=read();
	int pa=0,pb=n+1;
	while(c[pa+1]>0) ++pa;
	while(c[pb-1]<0) --pb;
	for(int i=pa+1;i<=pb-1;++i) res+=abs(c[i]);
	//处理第二段
	//cout<<pa<<' '<<pb<<'\n';
	int p=0,q=0;
	int mxpr=0,mxps=0;
	for(int i=pa;i>1;--i)
		q+=abs(c[i]),
		mxpr=max(mxpr,q-abs(c[i-1]));
	//处理第一段
	for(int i=pb;i<n;++i)
		p+=abs(c[i]),
		mxps=max(mxps,p-abs(c[i+1]));
	//处理第三段
	write(res+mxps+mxpr),
	putchar('\n');
}
signed main() {
	int TT=read();
	while(TT--)
		solve();
	return 0;
}
```

我的 [AC 记录](https://www.luogu.com.cn/record/129333168)。

---

## 作者：sbno333 (赞：2)

首先我们要知道，等级分没用，$c$ 数组中正数往前放，负数往后放。

我们可以简单地将 $c$ 数组分为三段：纯正数，负数整数混合，纯负数。

第二段从第一个负数到最后一个正数止，可以讲所有正数前置，负数后置，此时这一段对答案的贡献为这一段所有元素的绝对值之和。

不难发现第一段与最后一段类似，因此弄出一段即可。

讨论第一段，我们可以选取其中一个数放到这一段最后面，给出负贡献，它后面的正数就可以前移，并给出贡献，前面的数不变。

我们可以枚举这一段除了最后一个数外的所有数并进行处理。

```cpp
/*sum为这一段贡献。
a[i]表示的是题目中的c数组
ssum为能产生的正贡献
h为第一个负数的下标
*/
for(int i=h-2;i>=1;i--){
	ssum+=a[i+1];
	sum=max(sum,ssum-a[i]);
}
```

同理第三段：
```cpp
//t为最后一个正数的下标
for(int i=t+2;i<=n;i++){
	ssum-=a[i-1];
	sum=max(sum,a[i]+ssum);
}
```

因此完整代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200009];
int h,t;
int main(){
   std::ios::sync_with_stdio(0);
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>h;
		}
		h=n+1,t=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		for(int i=1;i<=n;i++){
			if(a[i]<=0){
				h=i;
				break;
			}
		}
		for(int i=n;i>=1;i--){
			if(a[i]>=0){
				t=i;
				break;
			}
		}
		long long ssum;
		ssum=0;
		long long ans,sum;
		ans=sum=0;
		for(int i=h-2;i>=1;i--){
			ssum+=a[i+1];
			sum=max(sum,ssum-a[i]);
		}
		ans+=sum;
		sum=0,ssum=0;
		for(int i=t+2;i<=n;i++){
			ssum-=a[i-1];
			sum=max(sum,a[i]+ssum);
		}
		ans+=sum;
		for(int i=h;i<=t;i++){
			ans+=abs(a[i]);
		}
		cout<<ans<<endl;
	} 
	return 0;
} 
```

---

## 作者：信息向阳花木 (赞：2)

首先显然输入的等级分没用。输入顺序就是升序排名。

我们可以发现，一个人能加的贡献只和这个人的排名相对于原来的排名的关系有关，和具体排第几没有关系。如果一个人往后移（任意位），则它后面的 **所有** 人都能往前移。反过来也一样。

于是可以考虑贪心。分两种情况考虑：

* 当前贡献为正数：
	* 此时如果前面的人贡献有 **非正数**，显然可以把负数往后移，当前正数往前移
   * 如果前面全是正数，我们可以考虑把当前数往前移和往后移的情况。如果往后移，那么前面的数肯定不移动是最优。如果往前移，那么就是在前面一定移动的情况下的最大贡献值。设 $st$ 表示前面的数一定有移动的情况下最大的贡献值加上当前贡献值。那么这个数往后移的贡献为 $st + c_i$。
* 当前贡献为负数：
	这个时候我们先不管它们。连续的负数我们可以累加起来一把移动。直到遇到下一个正数可以往后移。注意最后一连串后缀是负数的情况，需要特判一下。枚举内部进行移动的情况，取最大值。当然也可以不移动。
    
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 200010;

int t, n;
LL st = -1e18, s, ans;
LL w[N];
vector<LL> v, f;
bool flag = 0;

int main()
{
	scanf("%d", &t);
	while (t -- )
	{
		st = -1e18;
		flag = 0; s = 0;
		v.clear();
		scanf("%d", &n);
		w[0]= 1e18; ans = 0;
		for (int i = 1; i <= n; i ++ )
		{
			int x;
			scanf("%d", &x);
		}
		for (int i = 1; i <= n; i ++ )
		{
			scanf("%lld", &w[i]);
			if(w[i] <= 0)
			{
				s += -w[i];
				v.push_back(w[i]);
				flag = 1;
			}
			else
			{
				if(w[i - 1] <= 0)
				{
					ans += s + w[i];
				//	w[i] = 0;
			//		cout << s + w[i] << endl;
					s = 0;
					v.clear();
				}
				else if(!flag)
				{
					st = max(st + w[i], -w[i]);
					ans = max(ans, st);
				}
				else ans += w[i];
			}
		}
		if(!v.empty())
		{
			f.clear();
			f = v;
			LL maxx = 0;
			for (int i = 1; i < f.size(); i ++ )
			{
				f[i] += f[i - 1];
				maxx = max(maxx, - f[i - 1] + v[i]);
			}
			ans += maxx;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：luo_xiaoran (赞：2)

## 算法 贪心

## 思路

之前的等级分对贡献值没有影响，我们直接来看 $c_i$。

先推一遍：当左边的数比右边的小时，两人的排名大小关系取反是**更优的选择**。被交换到右边的数再向右移动（排名继续下降）是**不会继续影响**贡献值的，而更右边的数却会因此左移，因此我们选择**继续右移**它，宏观上看就是右边的一个**区间整体左移**。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/rjeaqq65.png)

（蒟蒻因为这个推法曾陷入了单调栈的泥潭，但最终弃暗投明）

可以看出，只要选定一个数右移，其右的数都能左移加贡献。所以只需要推一次后缀和，遍历找到右移哪一个最优即可。。。

。。。

了么？

有细心的的同志可能会发现，样例中的负数左移反而会降贡献。那么只需要将负数序列取出，翻折，取相反数即可。

需要注意负数序列右边的正数左移也会使负数右移，因此可以将正数看作负数序列中的 $0$。（正数亦是如此）

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
#define sg signed
#define max(x,y) ((x)>(y)?(x):(y))
using namespace std;
sg main(){
	sg t;
	scanf("%d",&t);
	while(t--){
		sg n,an=0,bn=0,k[200005];/*本地会MLE，洛谷能过*/
		int l=1,bans=0,aans=0;
		vector<sg> a,b;
		scanf("%d",&n);
		for(sg i=1;i<=n;i++) scanf("%*d");	/*小聪明*/
		for(sg i=1;i<=n;i++){					//
			scanf("%lld",&k[i]);				//
			if(l<0&&k[i]>0) an++,a.push_back(0);//
			if(k[i]>0) an++,a.push_back(k[i]);	//
			if(k[i]==0) an++,a.push_back(k[i]);	//
			l=k[i];								//正负分离
		}										//
		for(sg i=n;i>=1;i--){					//
			if(l>0&&k[i]<0) bn++,b.push_back(0);//
			if(k[i]<0) bn++,b.push_back(-k[i]);	//
			if(k[i]==0) bn++,b.push_back(0);	//
			l=k[i];								//
		}										//
		if(1){
			int am[200005]={0};
			for(sg i=an-1;i>=0;i--) am[i]=am[i+1]+1ll*a[i];
			for(sg i=an-2;i>=0;i--) aans=max(aans,am[i+1]-a[i]);
		}
		int am[200005]={0};
		for(sg i=bn-1;i>=0;i--) am[i]=am[i+1]+1ll*b[i];
		for(sg i=bn-2;i>=0;i--) bans=max(bans,am[i+1]-b[i]);
		printf("%lld\n",aans+bans);/*贪心*/
	}
	return 0;
}
/*
in1:
1
6
1 1 1 1 1 1 
57 32 6 75 45 51附赠两组样例（非测试点）
out1:
165
in2:
1
6
1 1 1 1 1 1
81 53 84 30 52 83
out2:
221
*/
```

---

## 作者：Big_Dinosaur (赞：2)

贪心。

将答案记为 $3$ 部分（前、中、后）。

中：记 $p_i$ 为 $\sum_{x=1}^{i}|c_i|$，第一个负数为 $fifu$，最后一个正数为 $lazh$，则答案为 $\sum_{x=fifu}^{lazh}|c_i|$，用 $p$ 的前缀和完成。

前：暴力求解，最优为 $(\sum_{x=d+1}^{fifu}c_i)-c_d$，暴力枚举 $d$，用 $p$ 的前缀和完成。

后与前大体相似，最优为 $-(\sum_{x=lazh+1}^{d-1}c_i)+c_d$，也用 $p$ 的前缀和完成。

对于无负数或无正数，直接用前或后的方法完成。

代码中变量名不一定与上文、题目中变量名意义相同，等级分空读。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
//快读，函数名r()，不显示了。
int T,n,a[999999],b[999999],c[999999],ans,d[999999],fifu,lazh;
int add(int be,int end){
int maxx=0;
for(int i=be;i<=end;++i)maxx=max(maxx,c[end]-c[i]-a[i]);return maxx;
}
int add2(int be,int end){
int maxx=0;for(int i=be;i<=end;++i)maxx=max(maxx,c[i-1]-c[be-1]+a[i]);return maxx;
}
void sl(){
n=r();for(int i=1;i<=n;++i)r();
for(int i=1;i<=n;++i)a[i]=r(),c[i]=abs(a[i])+c[i-1];
fifu=0,lazh=0;
for(int i=1;i<=n;++i)if(a[i]<0){fifu=i;break;}
for(int i=n;i;--i)if(a[i]>0){lazh=i;break;}
if(lazh&&fifu)
ans=c[lazh]-c[fifu-1]+add2(lazh+1,n)+add(1,fifu-1);
else if(lazh!=0)ans=add(1,n);else if(fifu!=0)ans=add2(1,n);
cout<<ans<<'\n';
}
signed main(){
T=r();while(T--)sl();
}
```

---

## 作者：Controls_Wish (赞：2)

### 思路

先找到第一个负数贡献和最后一个正数贡献的下标，可以把原序列分为连续三段，第一段全是正数，第三段全是负数，第二段有负数有正数。

首先考虑第二段，显然可以把其中所有负数往后放正数往前放，这样都可以有正的贡献，总贡献为所有此段中单个贡献的绝对值。

一三段本质一样，可以一起讨论，以第一段为例，我们可以枚举每一个数，记录把它放在第一段末尾产生的总贡献，也就是在这一段中，其本身产生负贡献，其之后的全部产生正贡献，记录每个放置方法产生的总贡献的最大值。第三段也就可以从后开始枚举，放在前面，同理。

第一三段的实现可以用前缀和，或者预先求出这段总贡献，枚举每个数的时候减去其贡献（具体可以看代码），时间复杂度 $O(n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2000005
#define ll long long
ll c[N];
int tot;
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        int n;ll ans=0;
        tot=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            int x;
            scanf("%d",&x);
        }
        ll sum=0;
        int sp=n+1,ep=0;
        for(int i=1;i<=n;i++){
            scanf("%lld",&c[i]);
            if(c[i]<=0){if(sp==n+1)sp=i;}//分段
            else ep=i;
        }
        for(int i=sp;i<=ep;i++)
            ans+=(c[i]<0?-c[i]:c[i]);//中间一段
        ep++,sp--;
        for(int i=1;i<=sp;i++)
            sum+=c[i];
        ll maxn=0;
        for(int i=1;i<=sp;i++)
            sum-=c[i],maxn=max(maxn,sum-c[i]);//第一段
        ans+=maxn;
        sum=maxn=0;
        for(int i=n;i>=ep;i--)
            sum+=-c[i];
        for(int i=n;i>=ep;i--)
            sum-=-c[i],maxn=max(maxn,sum+c[i]);//最后一段
        ans+=maxn;
        printf("%lld\n",ans);
    }
    return 0;
}
```


---

## 作者：zyn_ (赞：1)

# P9742 「KDOI-06-J」贡献系统

## 题目大意

$n$ 个人，等级分 $r_i$，贡献值 $c_i$。出题人初始贡献值 $0$。一场比赛后，若第 $i$ 个人的排名相较原来的排名**更高**，则出题人贡献值**加** $c_i$；若他的排名**更低**，则贡献值**减** $c_i$；排名不变则贡献值不变。安排一个排名顺序，使出题人的贡献值最大。

多测。$T\le 5,n\le 2\times 10^5$。对于任意 $1\le i\lt n$，$r_i>r_{i+1}$。

## 题目分析

$\{r_i\}$ 是单调下降的，也就是说，第 $i$ 个人原来排名就是 $i$。所以 $r_i$ 没用。代码实现时，读入两次数组 $\{c_i\}$ 即可。

### Sub.1

$n\le 8$，暴力枚举所有人的排名，计算答案。

### Sub.2

$n\le 100$。

考虑换个暴力。只有每个人排名的**升降与否**会影响贡献值，枚举每个人排名是升、降，还是不变，判断这种情况是否可行，可行就计算答案。

如何判断可行性？显然，第一个人排名不可能增，最后一个人排名不可能降。

举个例子，$n=7$，$7$ 人排名情况为「降升平升降降升」，如何安排？

第 $2,4$ 个人分别变为 $1,2$ 名，第 $1$ 个人变为第 $4$ 名；第 $5,6$ 个人变为第 $6,7$ 名，第 $7$ 个人变为第 $5$ 名。

找到通用的安排方法了吗？

我们可以发现，**所有排名发生变动的人中，原来排名最前的人排名必降，原来排名最后的人排名必升。**

那么不用暴力枚举每个人的排名升降了。枚举第一个排名降的人 $i$ 和第一个排名升的人 $j$。只有 $i$ 到 $j$ 名可能产生贡献。第 $i$ 名必贡献 $-c_i$，第 $j$ 名必贡献 $c_j$。中间的人随意，第 $x$ 人贡献 $|c_x|$ 即可使总贡献最大。直接做是 $O(n^3)$ 的，即可过 $n\le 100$。

### Sub.3

$n\le 5\times 10^3$。注意到要算区间绝对值和，前缀和一下，即可 $O(n^2)$。

## 56pts 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200009
#define ll long long
int t,n;ll x[N],y[N];
void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%lld",&x[i]);//没用的 r_i
	for(int i=1;i<=n;++i){
		scanf("%lld",&x[i]);//题中的 c_i
		y[i]=y[i-1]+(x[i]>0?x[i]:-x[i]);//|c_i|的前缀和
	}
	ll ans=0;
	for(int i=1;i<n;++i)for(int j=i+1;j<=n;++j)
		ans=max(ans,x[j]-x[i]+y[j-1]-y[i]);//y[j-1]-y[i]=x[i+1]+x[i+2]+...+x[j-1]
	printf("%lld\n",ans);
}
int main(){
	scanf("%d",&t);
	while(t--)solve();
	return 0;
}
```

### Sub.4

正解。$n\le 2 \times 10^5$。

观察 $56\text{pts}$ 代码：

```cpp
ll ans=0;
for(int i=1;i<n;++i)
	for(int j=i+1;j<=n;++j)
		ans=max(ans,x[j]-x[i]+y[j-1]-y[i]);
```

优化！必须优化！

代码中，$x_j-x_i+y_{j-1}-y_i=(x_j+y_{j-1})-(x_i+y_i)$。改成先枚举 $j$，则 $i$ 范围 $1$ 至 $j-1$。令 $z_i=x_i+y_i$，将 $z_i$ 的前缀最小值算好，就不用枚举 $i$ 了，时间复杂度 $O(n)$。

**Talk is cheap, show me the code.**

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200009
#define ll long long
int t,n;ll x[N],y[N],z[N];
void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%lld",&x[i]);
	z[0]=0x3f3f3f3f3f3f3f3fLL;
	for(int i=1;i<=n;++i)scanf("%lld",&x[i]),y[i]=y[i-1]+(x[i]>0?x[i]:-x[i]),z[i]=min(z[i-1],x[i]+y[i]);
	ll ans=0;
	for(int j=2;j<=n;++j)ans=max(ans,x[j]+y[j-1]-z[j-1]);
	printf("%lld\n",ans);
}
int main(){
	scanf("%d",&t);
	while(t--)solve();
	return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

思路就是找到最右边的非负数，把这个非负数放到在它最左边的负数的位置，其余在它左边的所有负数全部向右移一位，这样就可以获得减去所有负数的价值加上这个正数的价值。

然后再找到最左边的非正数，把这个非正数放到它最右边的正数的位置，其余它右边的所有正数全部向左移一位，这样就可以获得加上所有正数的价值减去这个这个负数的价值。

注意：我们需要判重，不然可能会加或减到一个数多遍。

你可以先试试，结果是喜提 $96$ 分，无缘 AK。

因为如果最右边的非负数的左边没有正数，那么这个非负数就不能找到合适的位置并获得非负数的价值，所以记录是否存在这样情况就行。非正数同理。

例如对于这张图片：
![](https://z1.ax1x.com/2023/10/15/pi9dL38.jpg)

我们可以将最后面的非负数提前到最前面的负数的位置，把负数向后移位。

![](https://z1.ax1x.com/2023/10/15/pi9dOgS.jpg)

这样就可以获得非负数代价减去负数代价（绿色表示非负数的移动，蓝色表示负数的移动）。

还是最上面的那张图，我们可以将最前面的非正数移到最后面的负数的位置，把正数向前移位。

![](https://z1.ax1x.com/2023/10/15/pi9dvuQ.jpg)

这样就可以获得正数代价减去非正数代价（绿色表示非负数的移动，蓝色表示负数的移动）。

注意：需要记重，以免二次获得代价，以及没有位置交换的情况要特判。

然后我们就只剩下没有被操作过的正数与负数。可以枚举每一个位置上的正数，使这个正数丢到最后面，其余正数依次向前挪一位，获得这个正数右边所有正数的价值减去这个正数的价值。负数同理。

如果前面的两种情况都已经算完了，我们可能还会获得这样的一张图：

![](https://z1.ax1x.com/2023/10/15/pi9wVu4.jpg)

这个时候如果我们调换正数和负数的位置，那么我们只会获得负数减正数的代价，还不如没有任何代价，所以我们应该对于正数和负数的内部各自进行操作。

![](https://z1.ax1x.com/2023/10/15/pi9wQC6.jpg)

枚举每个位置的正数，把这个位置的正数放到最后面的正数的位置上，其余正数向前移动，这样就可以获得这一位后面所有的正数的价值减去这个正数的价值，我们需要记录最大价值  

![](https://z1.ax1x.com/2023/10/15/pi9w3vD.jpg)

对于负数同理，枚举每个位置的负数，提前至最左边的负数，其余负数向后移动，获得这个负数的价值减去这一位前面的所有负数的价值，记录最大价值。


讲第一次操作得到的代价与第二次操作的两个最大值相加就可以得到答案。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200001;
int T,n,x,y,a[N],vis[N],ans,z,f,zm,fm;
bool flag;
signed main(){
    for(cin>>T;T;--T){
	    memset(vis,0,sizeof(vis));
        cin>>n;
		ans=z=f=zm=fm=flag=0,x=-1,y=n+1;
        for(int i=1;i<=n;i++)
			cin>>a[i];
        for(int i=1;i<=n;i++)
			cin>>a[i];
        for(int i=n;i>=1;i--)
            if(a[i]>=0){//寻找最右边的非负数
                x=i;
                break;
            }
        for(int i=1;i<x;i++)
			if(a[i]<0)
				ans+=-a[i],vis[i]=flag=1;//获得价值
        if(flag)
			ans+=a[x],vis[x]=1;//可以就交换
        for(int i=1;i<=n;i++)
            if(a[i]<=0){//寻找最左边的非正数
                y=i;
                break;
            }
        flag=0;
        for(int i=n;i>=y;i--)
			if(a[i]>0&&!vis[i])
				ans+=a[i],vis[i]=flag=1;
        if(flag&&!vis[y])
			ans+=-a[y],vis[y]=1;//整体和上面一样，不解释
        for(int i=n;i>=1;i--)
			if(!vis[i])
				z+=max(0ll,a[i]);//正数和
        for(int i=1;i<=n;i++)
			if(!vis[i])
				f+=min(0ll,a[i]);//负数和
        for(int i=1;i<=n;i++)
            if(!vis[i])
                if(a[i]>=0)
                    z-=a[i],zm=max(zm,z-a[i]);
        //统计
        for(int i=n;i>=1;i--)
            if(!vis[i])
                if(a[i]<=0)
                    f-=a[i],fm=max(fm,a[i]-f);
        //同上
        cout<<ans+zm+fm<<'\n';
    }
    return 0;
}
```

---

## 作者：Libra_ (赞：1)

## 题意
对于一个排列中的数，如果它向后移动则减去它的贡献；前移则加上它的贡献；保持不动则不贡献。

## 分析
我们很容易想到让负数都尽可能的后移，正数尽可能的前移。所以可以把序列划分成很多组。让每一组内，前一段是连续的负数，后一段是连续的正数，每次让负数与正数互换位置，则这一组的贡献是每个数的绝对值之和。

但是存在两种特殊情况：

1. 第一组均为正数：

	如果想使得该组有尽可能大的贡献，则需保证向后移动的数的加和尽可能的小，向前移动的数的加和尽可能的大。所以后移的数一定某一个数，而非某一段数，前移的数一定是后移的数所在的组内的后缀（简单来说就是，把后移的数移动到该组的最后一个位置）。即：某组区间为 $[\ l,r\ ]$，我们选择 $a_i\ (l \le i<r)$ 后移，则贡献为 $\max \{sum[r]-sum[i]-c[i]\}$。如果最大的贡献仍为负数，则该组的数位置均保持不变，贡献为 0。

2. 最后一组均为负数：
	
   如果想使得该组有尽可能大的贡献，则需保证，前移的数的加和的绝对值尽可能小，后移的数的加和的绝对值尽可能大（因为符号要取反）。把上面的操作反过来即可（后缀改成前缀就行）。

### [我的代码](https://www.luogu.com.cn/paste/o44c4hru)

最后推荐一下 **[我的博客](https://www.cnblogs.com/Libra-blog/)**

---

## 作者：cqbzlzm (赞：0)

### 「KDOI-06-J」贡献系统

#### *Description*

给定一个数列 $a$，你需要给给个位置搞一个 $b[i]$，$b[i]$ 从 $1$ 到 $n$ 且互不相同，对于每一个 $i$，若 $b[i] > i$ 则答案减少 $a[i]$，若 $b[i]<i$ 答案加上 $a[i]$，若 $b[i]=i$，答案不变。

求最大答案。

#### *Solution*

手玩一下样例，容易发现这题麻烦在于更改一个数的 $b[i]$，会对很多其他的数在成影响。

我们先要发现一个很重要的显然的性质，对于所有 $a[i]>0$ 的 $i$ 而言，最多只有一个 $b[i]>i$。

那么就可以得到 $a[i]$ 全是整数的答案，我们枚举一个 $i$，前 $i-1$ 个数直接 $b[j]=j$，然后令 $b[i]=n$，然后其他的 $b[j]$ 往小的选即可。

那么同理，$a[i]$ 全是负数的情况也得到了。

我么考虑一下全正和全是负数与普遍情况的关系是什么？

我们发现最理想的情况一定是：**第一个数是负数，最后一个数是正数**，那么一定可以把全部的贡献都变成正的。

所以我么将最开头的一段全是正数的提出来，把结尾一段全是负数的提出来，单独处理。然后剩下一段如上述全都可以有贡献，贡献为绝对值的和。

#### *Code*

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 200000;
int n, a[MAXN + 5];
long long sum[MAXN + 5];
int main() {
	int T; scanf("%d", &T);
	while (T --) {
		scanf("%d", &n);
		for (int i = 1; i <= n; i ++) scanf("%*d");
		for (int i = 1; i <= n; i ++) scanf("%d", &a[i]), sum[i] = sum[i - 1] + abs(a[i]);
		int j1 = 0, j2 = n;
		for (j1 = 1; j1 <= n; j1 ++) if (a[j1] < 0) break;
		for (j2 = n; j2 >= 1; j2 --) if (a[j2] > 0) break;
		long long ans1 = 0, ans2 = 0;
		for (int i = 1; i < j1; i ++) ans1 = max(ans1, sum[j1 - 1] - sum[i] - 1ll * a[i]);
		for (int i = n; i > j2; i --) ans2 = max(ans2, sum[i - 1] - sum[j2] + 1ll * a[i]);
		printf("%lld\n", ans1 + ans2 + sum[j2] - sum[j1 - 1]);
	}
	return 0;
}
```



---

## 作者：_zuoqingyuan (赞：0)

# 题面
[题面在这里](https://www.luogu.com.cn/problem/P9742)
# 分析
首先：$r$ 数组是没有用的，题目中明确规定了 $r_i > r_{i+1}$。所以每一个数在 $r$ 数组中的排名就是他的下标。

比赛是看到这题起初是没思路的，于是果断思考一些带有特殊性质的测试点，我们会发现

“特殊性质 $c$：对于任意 $1 \le i< n$，保证 $c_i \ge 0$”

对此我们可以发现，如果选手的贡献值满足特殊性质 $c$，那么只要将第 $i$ 个人的排名放在最后，而第 $1 \dots i$ 个人的排名不变，对总贡献没有影响，第 $i$ 个人的排名为 $n$，总贡献减少其贡献值 $c_i$。

可得：
```cpp
max_ans=max(sum[n]-sum[i-1]-c[i])
```


若对于任意 $1 \le i< n$，保证 $c_i \le 0$，同理可得：
```
max_ans=max(abs(sum[i-1]))+c[i])
```


想到这里，我们会发现，对于没有任何限制的数组 $c$，我们都可找到其最长的，非负的前缀 $c'$ 和最长的，非正的后缀 $c''$。而原数组减去 $c'$ 和 $c''$得到的数组 $C$，则满足 $C_1 \le 0, C_{len} \ge 0$，$len$ 为数组 $C$ 的长度。

那么我们会发现，如果数组将 $C$ 中所有的正数项依次放在前面，所有负数项依次放在后面，则这个策略的贡献为数组 $C$ 的绝对值的和，为数组 $C$ 的最优策略。为什么呢？

因为 $C_1 \le 0$，所以会被排到最后，所以数组 $C$ 中的任意正数项的排名至少会进 $1$ 位。所以所有整数项都会对总贡献贡献其贡献值（感觉好拗口）。对于数组 $C$ 中的负数项，也可以证明。

所以对于任何一组数据，他的最优贡献都可以分为这三部分。我们吧数据分成三部分，求整个数组 $c$ 绝对值的前缀和。分别去算就行。
# AC code
代码如下：
```
#include <iostream>
#include <cstdio>
using namespace std;
const int N=2e5+10;
long long sum,a[N],s[N],maxn1,maxn2,T,n,it1,it2;//记得开long long 
long long Abs(long long x){
    return x>=0?x:-x;//求绝对值 
}
int main(){
    scanf("%d",&T);
    while(T--){
        sum=it1=it2=maxn1=maxn2=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
        for(int i=1;i<=n;i++){
            scanf("%lld",&a[i]);
            s[i]=s[i-1]+Abs(a[i]);//计算绝对值的前缀和 
        }
        for(it1=1;it1<=n;it1++)if(a[it1]<0)break;it1--;//找到c'的最后一个元素的下标 
        for(it2=n;it2>=1;it2--)if(a[it2]>0)break;it2++;//找到c"的最后一个元素的下标 
        for(int i=1;i<it1;i++)maxn1=max(maxn1,s[it1]-s[i]-a[i]);//计算c'的最优解 
        for(int i=n;i>it2;i--)maxn2=max(maxn2,s[i-1]-s[it2-1]+a[i]);//计算c"的最优解 
        sum+=s[it2-1]-s[it1];//计算数组C的最优解 
        printf("%lld\n",sum+maxn1+maxn2);//相加输出 
    }
    return 0;
}
```
如有错误，请指正。

---

## 作者：zxh923 (赞：0)

# P9742 「KDOI-06-J」贡献系统 题解

[题目传送门](https://www.luogu.com.cn/problem/P9742)

### 思路

这道题先看特殊性质，现有一个是序列中所有的数都非负。

于是我们可以想到，一个位置的数移到序列末尾，后面的数都往前移。

现在我们来看全题，我的思路是把整个序列分为三块，但是有些块可能不存在。

第一块是全非负数，方法参照特殊性质。

第二块是全负数，方法参照特殊性质，但需要把向前改成向后。

第三块是最难的，是负数和非负数杂交块，并且第一个元素是负数，最后一个是非负数。

我们可以把这一块里的所有非负数向前移，负数向后移，所以我们这一块里的所有元素的绝对值都可以被加上。

那么怎么移呢？就是把第一个非负数移到第一个位置，后面的移到上一个元素移动前的位置，负数就是同理向后移动。

但是这样特殊性质又过不了，所以我的代码需要进行特判，特殊性质有专门的部分。

### 代码

```cpp
#include<bits/stdc++.h> 
#define int long long
#define N 200005
using namespace std;
int tt,n,z[N],maxx1,maxx2,maxx,fu[N],sum[N],summ,cnt1,cnt2,sum1[N],sum2[N],fi,la;
struct node{
	int r,c;
}a[N];
bool flag,f,ff;
signed main(){
	scanf("%lld",&tt);
	while(tt--){
		scanf("%lld",&n);
		flag=1;
		cnt1=cnt2=summ=0;
		fi=n+1;
		la=0;
		maxx=maxx1=maxx2=0;//多次测试记得清空 
		for(int i=1;i<=n;i++){
			scanf("%lld",&a[i].r);
		}
		for(int i=1;i<=n;i++){
			scanf("%lld",&a[i].c);
			sum[i]=sum[i-1]+a[i].c;
			if(a[i].c<0)flag=0;
		}
		if(flag){//特殊性质 
			for(int i=1;i<=n;i++){
				maxx=max(maxx,sum[n]-sum[i]-a[i].c);
			}
			cout<<maxx<<'\n';
			continue;
		}
		for(int i=1;i<=n;i++){
			if(a[i].c<0){
				fi=i;//fi和la是找出三块的临界点 
				break;
			}
		}
		for(int i=n;i>=1;i--){
			if(a[i].c>=0){
				la=i;
				break;
			}
		}
		for(int i=1;i<fi;i++){//非负数块 
			sum1[i]=sum1[i-1]+a[i].c;
		}
		for(int i=1;i<fi;i++){
			maxx1=max(maxx1,sum1[fi-1]-sum1[i]-a[i].c);
		}
		for(int i=fi;i<=la;i++){
			summ+=abs(a[i].c);//杂交块 
		}
		for(int i=n;i>la;i--){//负数块，倒着移动 
			sum2[n-i+1]=sum2[n-i]+abs(a[i].c);
		}
		for(int i=1;i<n-la+1;i++){
			maxx2=max(maxx2,sum2[n-la]-sum2[i]-abs(a[n-i+1].c));
		}
		cout<<summ+maxx1+maxx2<<'\n';//进行加和 
	}
	return 0;
}
```

### 提交记录

最后大家可以看一下记录。

记录点[这里](https://www.luogu.com.cn/record/130440052)。

可以发现虽然这种思路有点奇怪，但还是不慢的。

---

## 作者：joe_zxq (赞：0)

# 思路

由于题目里保证 $r_i > r_{i+1}$，所以给定的 $r$ 是没用的。

这道题的难点在于并不是所有人都希望进步，有些人 $c_i < 0$，也就是想要退步，两者在一起，就会很麻烦。$c_i = 0$ 的人对结果没有影响，这里不做考虑。

我们可以 $n$ 个人分成三组，分别是：

- 第一组：从第一个人开始的想要进步的人。

- 第二组：第一组和第三组之间的人。

- 第三组：从最后一个人开始的想要退步的人。

例如，$c = \{1,1,4,5,-1,4,-1,-9,1,-9,-8,-1\}$。

那么三组分别是：

- 第一组：$\{1,1,4,5\}$。

- 第二组：$\{-1,4,-1,-9,1\}$。

- 第三组：$\{-9,-8,-1\}$。

那么我们只需要分别来看三组的计算方式，然后想加即可：

- 第一组：这些人都想要进步，那么只需要让其中一个人退步，让比这个人弱的人进步，让比这个人强的人不进不退。可以用后缀和求解。

- 第二组：这些人有的想要进步，有的想要退步。可以发现可以构造出满足所有人愿望的方案。

- 第三组：这些人都想要进步，思路同第一组。可以用前缀和求解。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n, a[200023];
void solve() {
	cin >> n;
	ll sum = 0, be = 0, en = n + 1, pre = 0, l = 0, r = 0;
	for (ll i = 1, x; i <= n; i++) cin >> x;
	for (ll i = 1; i <= n; i++) cin >> a[i];
    while (a[be + 1] > 0) be++;
	while (a[en - 1] < 0) en--;
	// left
	for (ll i = be; i > 1; i--) {
		pre += abs(a[i]);
		l = max(l, pre - abs(a[i - 1]));
	}
	// middle
	for (ll i = be + 1; i < en; i++) sum += abs(a[i]);
	// right
	pre = 0;
	for (ll i = en; i < n; i++) {
		pre += abs(a[i]);
		r = max(r, pre - abs(a[i + 1]));
	}
	cout << l + sum + r << endl;
}
int main() {
    ll tc;
    cin >> tc;
    while (tc--) solve();
	return 0;
}
```

---

## 作者：卷王 (赞：0)

## 简要思路

我们发现一个贪心：大于 $0$ 的数往前放更优，小于 $0$ 的数往后放更优，等于 $0$ 的数随便怎么放。

最好情况显然是所有正数都能加上，所有负数也都能减去（即加上它的绝对值），现在要考虑的问题是如何构造。

其实，只需要把头和尾分别变成一个小于等于 $0$ 的数和一个大于等于 $0$ 的数即可，模拟一下就可知。

其余解释请看代码。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}

int T, n, m, x, y;
int c[200007]; //读入数组
int sum[200007]; //sum 记录 c[i] 的绝对值前缀和
int l, r;
//l r 是三个部分的分界线
//1: 1~l-1 全是正数
//2: l~r 有正有负也有 0
//3: r+1~n 全是负数

signed main() {
	T = read();
	while(T--) {
		n = read();
		int ans1 = 0, ans2 = 0;
		l = 1, r = n;
		for(int i = 1; i <= n; i++) int x = read();
		for(int i = 1; i <= n; i++) c[i] = read(), sum[i] = sum[i - 1] + abs(c[i]);
		for(int i = 1; i <= n && c[i] > 0; i++) l++;
		for(int i = n; i >= 1 && c[i] < 0; i--) r--;
		
		for(int i = 1; i < l; i++) //按照性质枚举中点
			ans1 = max(ans1, -c[i] + (sum[l - 1] - sum[i]));
		for(int i = n; i > r; i--)
			ans2 = max(ans2, c[i] + (sum[i - 1] - sum[r]));
		
		printf("%lld\n", ans1 + ans2 + (sum[r] - sum[l - 1]));
	}
	return 0;
}
```

---

## 作者：sgl654321 (赞：0)

显然序列 $r$ 是没用的……
## 题目大意
给定一个长度为 $n$ 的序列 $c$，构造一个长度为 $n$ 的排列 $p$。

定义一个排列 $p$ 的权值：
- 权值初始为 $0$。
- 对于一个元素 $p_i$，若 $p_i=i$，则权值不变。
- 若 $p_i<i$，则权值加上 $c_i$。
- 若 $p_i>i$，则权值加上 $-c_i$。

问所有排列 $p$ 中最大的权值是多少。

~~或者大家直接看原题面也行，说的好像更清楚。~~
## 解题思路
我们考虑把这个序列 $c$ 分成三段，每一段的长度可能为 $0$。
- 第一段：开头连续的正数。
- 第二段：中间正数负数混杂的。
- 第三段：结尾连续的负数。

例如序列 $\{c\}=\{1,5,3,4,-1,4,-3,2,-4,-3,-5,-1\}$。我们就把它分成以下三段：
1. $\{c1\}=\{1,5,3,4\}$。
2. $\{c2\}=\{-1,4,-3,2\}$。
3. $\{c3\}=\{-4,-3,-5,-1\}$。

### 第二段
首先我们先考虑第二段。正数负数混杂的情况，显然是把所有正数放在前面，所有负数放在后面最优。

这样所有的正数都会加上正的贡献，负数都会加上负的贡献，皆大欢喜。

### 第一段
然后我们考虑第一段。这种情况下，最优方案一定是把其中一个元素 $c1_p$ 排在后面，然后 $c1_{p+1}\sim c1_{last}$ 都向前平移一格。

这样，就只有 $c1_p$ 一个是负的贡献，后面的这些全都是正的贡献。

简单证明一下这样是最优的：如果有两个 $c1_{p1},c1_{p2}(p2>p1)$ 都被赶到了后面，即是负的贡献，那么显然我们可以把 $c1_{p2}$ 变成正的贡献。因此最多只有一个数给出负的贡献。

因此我们需要求出 $(\sum_{k=p+1}^{last}c1_k)-c1_p$ 的最大值。这个显然前缀和就可以搞定了。

### 第三段
最后我们由第一段类比考虑第三段。这种情况下，最优方案一定是把其中一个元素 $c3_p$ 排到前面，$c3_1\sim c3_{p-1}$ 全部都向后平移一格。

这样，只有 $c3_p$ 一个是正的贡献，其他都是负的贡献。负数的负贡献是正数，因此同第一段，这是最优方案。

实现也和第一段类似，运用前缀和。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 200010
using namespace std;
typedef long long ll;
ll tt,n,a[maxn],b[maxn],c[maxn],x,ans,l,r;
ll totb,totc,sb[maxn],sc[maxn],num;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>tt; 
	while(tt--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>x;
		for(int i=1;i<=n;i++)cin>>a[i];
		l=0;r=n+1;ans=0;
		while(l+1<=n&&a[l+1]>=0)l++;
		while(r-1>=1&&a[r-1]<0)r--;
		totb=totc=0;
		for(int i=1;i<=l;i++)b[++totb]=a[i];
		for(int i=n;i>=r;i--)c[++totc]=-a[i];
		sb[totb+1]=0;sc[totc+1]=0;
		for(int i=totb;i>=1;i--)sb[i]=sb[i+1]+b[i];
		for(int i=totc;i>=1;i--)sc[i]=sc[i+1]+c[i];
	//	cout<<l<<" "<<r<<":"<<totb<<" "<<totc<<endl; 
		num=0;
		for(int i=1;i<=totb-1;i++)num=max(num,sb[i+1]-b[i]);
		ans+=num;
		num=0;
		for(int i=1;i<=totc-1;i++)num=max(num,sc[i+1]-c[i]);
		ans+=num;
		for(int i=l+1;i<=r-1;i++)
			ans+=abs(a[i]);
		cout<<ans<<endl;
	}
	return 0;
}
```

---


# 「KDOI-06-J」旅行

## 题目描述

小 C 在 C 国旅行。

C 国有 $n\times m$ 个城市，可以看做 $n\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。

该国有 $2$ 种交通系统：

* 对于所有 $1\leq i<n,1\leq j\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；
* 对于所有 $1\leq i\leq n,1\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；

在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。

小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\leq x\leq n,1\leq y\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\ 244\ 353$ 取模。

两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。

## 说明/提示

**【样例解释 #1】**

到 $(3,1)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。

到 $(2,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。

到 $(3,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。

到 $(2,3)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。
* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。

**【样例 #2】**

见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。

**【数据范围】**

对于所有数据保证：$1\leq n,m\leq45$，$1\leq k,a_{i,j},b_{i,j}\leq90$。

| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |
|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $\leq3$ | $\leq5$ | $=1$ | $=1$ |
| $4\sim6$ | $\leq10$ | $\leq10$ | $=1$ | $=40$ |
| $7\sim8$ | $\leq40$ | $\leq30$ | $=1$ | $=45$ |
| $9\sim10$ | $\leq15$ | $\leq15$ | $\leq15$ | $\leq15$ |
| $11$ | $\leq15$ | $\leq30$ | $\leq30$ | $\leq30$ |
| $12$ | $\leq20$ | $\leq40$ | $\leq40$ | $\leq40$ |
| $13\sim15$ | $\leq25$ | $\leq50$ | $\leq50$ | $\leq50$ |
| $16$ | $\leq30$ | $\leq60$ | $\leq60$ | $\leq60$ |
| $17$ | $\leq35$ | $\leq70$ | $\leq70$ | $\leq70$ |
| $18\sim19$ | $\leq40$ | $\leq80$ | $\leq80$ | $\leq80$ |
| $20$ | $\leq45$ | $\leq90$ | $\leq90$ | $\leq90$ |

## 样例 #1

### 输入

```
3 3 5
3 2 1
2 1 3
1 3 2
1 2 3
2 3 1
3 1 2```

### 输出

```
0 0 0
0 1 5
1 3 5```

# 题解

## 作者：uid_310801 (赞：13)

设 $dp_{x,y,c,la,lb}$ 表示走到 $x,y$，花了 $c$ 元，还剩 $la$ 张 L 公司的票，$lb$ 张 Z 公司的。

初始值 $dp_{1,1,0,0,0}=1$。

转移枚举在 $x,y$ 买了多少票，设 $c'=c-a_{i,j}\times ca-b_{i,j}\times cb$：

$$dp_{x,y,c,la,lb}=\sum_{ca=0}^{la}\sum_{cb=0}^{lb} dp_{x-1,y,c',la-ca+1,lb-cb}+dp_{x,y-1,c',la-ca,lb-cb+1}$$

$(x,y)$ 的答案就是 $dp_{x,y,k,0,0}$。

有一些边界情况需要判断。

这样做是 $O(n^7)$，实现的好可以获得 $65$ 分，不过还要优化。

注意到枚举其实大可不必，考虑一个类似二维前缀和的容斥：

$$dp_{x,y,c,la,lb}=dp_{x,y,c-a_{i,j},la-1,lb}+dp_{x,y,c-b_{i,j},la,lb-1}-dp_{x,y,c-a_{i,j}-b_{i,j},la-1,lb-1}$$

然后再加上 $dp_{x-1,y,c,la+1,lb}+dp_{x,y-1,c,la,lb+1}$ 就可以了。

但是空间开不下五维数组，不过可以把 $x$ 这一维用滚动数组优化。

取模不用取得很勤，最后算答案再取模就行。复杂度 $O(n^5)$，已经可以过了。

一个优化：如果现在买的票已经不可能贡献了，就不再转移了。具体看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define deb(x) cerr<<"Line: "<<__LINE__<<", val= "<<x<<"; \n"
typedef long long ll;
#define pii pair<ll,ll>
#define mp make_pair
#define fi first
#define se second
const ll N=50,K=95,mod=998244353;
inline ll read(){
	ll a=0,x=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	x=-x;
		c=getchar();
	}
	while(isdigit(c)){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*x;
}
ll n,m,k,cnt;
ll a[N][N],b[N][N];
ll dp[N][N];
ll f[2][N][K][N][N],ans[N][N];
ll flag=1;
signed main(){
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]=read();
			if(a[i][j]!=1)	flag=0;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			b[i][j]=read();
			if(b[i][j]!=45)	flag=0;
		}
	}
	f[1][1][0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i!=1)	f[i&1][j][0][0][0]=0;
			for(int c=1;c<=k;c++){
				for(int la=0;la+i<=n;la++){
					for(int lb=0;lb+j<=m;lb++){//如果现在买的票已经不可能贡献了，就不再转移了。 
						ll res=mod;
						if(la!=0&&c>=a[i][j])	res+=f[i&1][j][c-a[i][j]][la-1][lb];
						if(lb!=0&&c>=b[i][j])	res+=f[i&1][j][c-b[i][j]][la][lb-1];
						if(la!=0&&lb!=0&&c>=a[i][j]+b[i][j])	res-=f[i&1][j][c-a[i][j]-b[i][j]][la-1][lb-1];
						if(i!=1)	res+=f[(i-1)&1][j][c][la+1][lb];
						if(j!=1)	res+=f[i&1][j-1][c][la][lb+1];
						f[i&1][j][c][la][lb]=res%mod;
						if(c==k&&la==0&&lb==0)	ans[i][j]=res%mod;
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%lld ",ans[i][j]);
		}
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：cqbzlzm (赞：5)

### 「KDOI-06-J」旅行

#### *Description*

有一个 $n\times m$ 的网格，每一个点可花 $a[i][j]$ 买一张向下走的票，或花 $b[i][j]$ 买一张向右走的票，每个点可以买任意次。你开始在 $(1,1)$ 且有 $k$ 元钱，每向下或向右都要使用一张对应的票，求走到所有 $(i,j)$ 时，刚好用完 $k$ 元钱，且手头没有多余的票的方案数。

**数据范围：** $n,m\leq 45,k\leq 90$。

#### *Solution*

首先容易确定思路为动态规划，由注意到范围很小，所以很容易想到令 $dp[i][j][l][z][p]$ 表示走到 $(i,j)$，**买完票后**，手上还有 $l$ 张向下走的票，$z$ 张向右走的票，且还剩 $p$ 元钱的方案数。

每一步有四种转移：

1.   从 $(i-1,j)$ 走来，使用了一张向下走的票，即 $dp[i-1][j][l+1][z][p]$。
2.   从 $(i,j-1)$ 走来，使用了一张向右走的票，即 $dp[i][j-1][l][z+1][p]$
3.   原地买了一张向下走的票，即 $dp[i][j][l-1][z][p+a[i][j]]$。
4.   原地买了一张向右走的票，即 $dp[i][j][l][z-1][p+b[i][j]]$。

如果直接这样转移，发现有一个问题，如果我在原地买了一张向右走的票和一张向下走的票，那么它会在 3，4 中都计算一次，所以算重了，我们要减掉这种情况，即 $-dp[i][j][l-1][z-1][p+a[i][j]+b[i][j]]$。

#### *Code*

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353, MAXN = 45, MAXM = 90;
int n, m, k;
int L[MAXN + 5][MAXN +5], Z[MAXN + 5][MAXN + 5];
long long dp[2][MAXN + 5][MAXN + 5][MAXN + 5][MAXM + 5];
signed main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++) scanf("%d", &L[i][j]);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++) scanf("%d", &Z[i][j]);
	dp[1][1][0][0][k] = 1;
	for (int i = 1; i <= n; i ++) { bool I = i % 2;
		for (int j = 1; j <= m; j ++) {
			for (int l = 0; l < n; l ++) {
				for (int z = 0; z < m; z ++) {
					for (int p = 0; p <= k; p ++) {
						if (i != 1) dp[I][j][l][z][p] += dp[I ^ 1][j][l + 1][z][p];
						if (j != 1) dp[I][j][l][z][p] += dp[I][j - 1][l][z + 1][p];
						if (l != 0 && p + L[i][j] <= k) dp[I][j][l][z][p] += dp[I][j][l - 1][z][p + L[i][j]];
						if (z != 0 && p + Z[i][j] <= k) dp[I][j][l][z][p] += dp[I][j][l][z - 1][p + Z[i][j]];
						if (l != 0 && z != 0 && p + L[i][j] + Z[i][j] <= k) dp[I][j][l][z][p] -= dp[I][j][l - 1][z - 1][p + L[i][j] + Z[i][j]];
						(dp[I][j][l][z][p] += mod) %= mod;
					}
				}
			}
		}
		for (int j = 1; j <= m; j ++)
			printf("%lld ", dp[I][j][0][0][0]);
		printf("\n");
		memset(dp[I ^ 1], 0, sizeof(dp[I ^ 1]));
		
	}
	return 0;
}
```



---

## 作者：紊莫 (赞：5)

特色：~~卡常~~。最大点 300ms 的成绩过了。  

## 思路分析

发现这个动态规划的模型还是挺裸的，我们只关心现在在哪里，手里有多少张票，用了几块钱，自然列出 ``f[i][j][x][y][p]`` 表示在点 $(i,j)$，手里有 $x$ 张向下的票，$y$ 张向右的票，总共花了 $p$ 元钱的方案数量。  

然后考虑决策。  
在每一个点，我们只需要考虑买票和走路两个操作。  

你可能会像我一样，写出这样的代码：  

```cpp
for(int x=0;x<=n-i;x++){
	for(int y=0;y<=m-j;y++){
		for(int p=0;p<=k;p++){
			int now = f[i&1][j][x][y][p]; 
			if(!now) continue;
			if(p+b[i][j]<=k)add(f[i&1][j][x][y+1][p+b[i][j]],now);
			if(p+a[i][j]<=k)add(f[i&1][j][x+1][y][p+a[i][j]],now);
			if(x>0)add(f[i&1^1][j][x-1][y][p],now);
			if(y>0)add(f[i&1][j+1][x][y-1][p],now);
		}
	}
}
```

然后你发现样例都过不了。  

>两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。  

在 @zzafanti 的文章里已经提到了算重的这一点，不再赘述。  

到这里你应该发现你的电脑并不能开下这么大的数组，所以加上第一维的滚动数组，至此我已经以最大点 2s 左右的结果通过了此题，然而，在不进行本质优化的前提下，我还有如下方法能将算法进一步加速。  

取模太慢了！赶紧改掉，这里都是加法，最多也就是超出模数一倍。  

```cpp
void add(int &x,int y){
	x = (x+y);
	if(x>mod) x-=mod;
}
```

什么？你还在开 ``long long``，赶紧改掉，相信一定不会爆。  

什么？不要用 ``memset``，你用了什么就删掉什么就可以了。  

你说快读快输？实测没啥用。  

## 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
const int N = 47,mod = 998244353;
int n,m,k,a[N][N],b[N][N],f[2][N][N][N][91];
void Input();
inline int add(int x,int y);
signed main(){
//	freopen("merge3.in","r",stdin);
//	freopen("merge3.out","w",stdout);
	Input();
	f[1][1][0][0][0] = 1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%d ",f[i&1][j][0][0][k]);
			for(int x=0;x<=n-i;x++)
				for(int y=0;y<=m-j;y++)
					for(int p=0;p<=k;p++)
						if(p+a[i][j]<=k&&f[i&1][j][x][y][p])
							f[i&1][j][x+1][y][p+a[i][j]]=add(f[i&1][j][x+1][y][p+a[i][j]],f[i&1][j][x][y][p]);
			for(int x=0;x<=n-i;x++)
				for(int y=0;y<=m-j;y++)
					for(int p=0;p<=k;p++)
						if(p+b[i][j]<=k&&f[i&1][j][x][y][p])
							f[i&1][j][x][y+1][p+b[i][j]]=add(f[i&1][j][x][y+1][p+b[i][j]],f[i&1][j][x][y][p]);
			for(int x=0;x<=n-i;x++){
				for(int y=0;y<=m-j;y++){
					for(int p=0;p<=k;p++){
						int now = f[i&1][j][x][y][p]; 
						if(!now) continue;
						if(x>0)f[i&1^1][j][x-1][y][p]=add(f[i&1^1][j][x-1][y][p],now);
						if(y>0)f[i&1][j+1][x][y-1][p]=add(f[i&1][j+1][x][y-1][p],now);
					}
				}
			}
			for(int x=0;x<=n-i;x++)
				for(int y=0;y<=m-j;y++)
					for(int p=0;p<=k;p++)
						f[i&1][j][x][y][p]=0;
		}
		printf("\n");
	}
	return 0;
} 

inline int add(int x,int y){
	long long res = (long long)x+(long long)y;
	if(res>mod) res-=mod; return (int)res;
}

void Input(){
	int cnt = 0;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&b[i][j]);
}
```


---

## 作者：zzafanti (赞：4)


[题面传送门](https://www.luogu.com.cn/problem/P9743)

## description

给定 $n\times m$ 网格图，每个点有权值 $a_{i,j},b_{i,j}$，只能向下或向右走。初始有 $k$ 单位钱，在每个点可以花 $a_{i,j}\times t(0\leq t,t\in \mathbb{N})$ 的钱买 $t$ 张向下的票，同理以 $b_{i,j}$ 为单价也可购买多张向右的票。每次向下或向右走都要消耗一张对应的票，任意时刻钱数不能为负数，求从 $(1,1)$ 走到每个 $(x,y)$ 且恰好用完所有钱和票的方案数。

- $n,m\leq 45$

- $k,a_{i,j},b_{i,j}\leq 90$

## solution

每个状态记录从起始状态当前状态的方案数。

设计 dp 状态时需要记录当前的位置、剩余钱数以及向上向下分别剩余的票数。位置有 $nm$ 个，剩余钱数一维大小为 $k$，由于到终点时要把所有票用完，每走一次消耗 1 张票，所以最后两维的大小就是 $nm$ 的。所以状态数是 $O(n^2m^2k)$，带入数据范围发现，要求 $O(1)$ 转移才能满足时间限制。dp 最外层循环枚举行数，可以滚动数组滚掉一维 $n$，可以做到 $O(nm^2k)$ 的空间复杂度，可以满足空间限制。

下面考虑如何转移。

一个点可以从上或从右转移，所以 $f_{x,y,k,i,j} \gets f_{x-1,y,k,i+1,j}+f_{x,y-1,k,i,j+1}$。

在一个点可以购买票，故 $f_{x,y,k,i,j}\gets f_{x,y,k+a_{x,y},i-1,j} +f_{x,y,k+b_{x,y},i,j-1}$。

不过根据题意，在一个点**先买一张向下的票再买一张向右的票**与**先买一张向右的票再买一张向下的票**是一种方案，直接按照上面的方案转移会造成重复。

为了避免重复，我们可以强制要求先买向下的票，再买向右的票，这样每个方案就只会被算一次了。实现时固定 $(x,y,k)$ 后先完成所有 $f_{x,y,k,i,j}\gets f_{x,y,k+a_{x,y},i-1,j}$ 的转移，然后再完成 $f_{x,y,k,i,j}\gets f_{x,y,k+b_{x,y},i,j-1}$ 的转移即可。

实现时要注意 $k$ 这一维倒序枚举。

## code

[洛谷 - 提交记录](https://www.luogu.com.cn/record/129490307)


---

## 作者：Eddie08012025 (赞：3)

## 基本思路
首先，看到此题数据范围 $n,m\le 45,k\le 90$ 很小，可以想到做一个高复杂度的 dp。

$dp_{i,j,x,y,u}$ 表示到达格子 $(i,j)$，还有 $x$ 张 L 公司的车票与 $y$ 张 Z 公司的车票，此时剩余 $u$ 元钱的方案数。

考虑如何转移，转移方程大概可以分成两个部分：

1. 在格子 $(i,j)$ 购买车票，购买一张 L 公司的铁路票花费 $a_{i,j}$ 元，购买一张 Z 公司的铁路票花费 $b_{i,j}$ 元。得：
$$dp_{i,j,x+1,y,u-a_{i,j}}+=dp_{i,j,x,y,u}$$
$$dp_{i,j,x,y+1,u-b_{i,j}}+=dp_{i,j,x,y,u}$$

2. 在格子 $(i,j)$ 花费一张车票乘坐铁路，乘坐 L 公司的铁路会从 $(i,j)$ 到达 $(i+1,j)$ 并花费一张 Z 公司的铁路票，乘坐 Z 公司的铁路会从 $(i,j)$ 到达 $(i,j+1)$ 并花费一张 Z 公司的铁路票。得：
$$dp_{i+1,j,x-1,y,u}+=dp_{i,j,x,y,u}(i<n)$$
$$dp_{i,j+1,x,y-1,u}+=dp_{i,j,x,y,u}(j<m)$$

如果你不加任何优化直接 dp，你将会得到 $70$ 分的 MLE 与 TLE。现在考虑优化。
## 优化 DP
### 优化空间
发现 $dp_i$ 只会影响到 $dp_{i+1}$，所以可以用滚动数组优化。将分数优化到 $85$ 分 TLE。

### 优化时间
发现在 $(i,j)$ 时最多还会用到 $n-i$ 张 L 公司的票与 $m-j$ 张 Z 公司的票，买多了票对答案不会有贡献，因此我们在循环枚举 $x,y$ 时可以加上条件 $x\le n-i$ 与 $y\le m-j$。在购买车票时会花费钱 $a_{i,j}$ 或 $b_{i,j}$，$u\le a_{i,j},b_{i,j}$ 时无法购买车票，因此可以增加条件 $u\ge a_{i,j}$ 或 $u\ge b_{i,j}$。

这样优化后就可以愉快地 AC 这道题。

### std
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int c,n,m,k,a[46][46],b[46][46],ans[46][46],dp[2][46][46][46][91];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>b[i][j];
		}
	}dp[1][1][0][0][k]=1;
	for(int i=1;i<=n;i++){
		c^=1;
		memset(dp[c^1],0,sizeof(dp[c^1]));
		for(int j=1;j<=m;j++){
			ans[i][j]=dp[c][j][0][0][0];
			for(int u=k;u>=a[i][j];u--){
				for(int x=0;x<=n-i;x++){
					for(int y=0;y<=m-j;y++){
						int *p=&dp[c][j][x+1][y][u-a[i][j]];
						*p+=dp[c][j][x][y][u];
						if(*p>mod)*p-=mod;
					}
				}
			}for(int u=k;u>=b[i][j];u--){
				for(int x=0;x<=n-i;x++){
					for(int y=0;y<=m-j;y++){
						int *p=&dp[c][j][x][y+1][u-b[i][j]];
						*p+=dp[c][j][x][y][u];
						if(*p>mod)*p-=mod;
					}
				}
			}if(i<n)
				for(int u=0;u<=k;u++){
					for(int x=1;x<=n-i;x++){
						for(int y=0;y<=m-j;y++){
							int *p=&dp[(c^1)][j][x-1][y][u];
							*p+=dp[c][j][x][y][u];
							if(*p>mod)*p-=mod;
						}
					}
				}
			if(j<m)
				for(int u=0;u<=k;u++){
					for(int x=0;x<=n-i;x++){
						for(int y=1;y<=m-j;y++){
							int *p=&dp[c][j+1][x][y-1][u];
							*p+=dp[c][j][x][y][u];
							if(*p>mod)*p-=mod;
						}
					}
				}
		}		
	}for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<ans[i][j]<<" ";
		}cout<<"\n"; 
	}return 0;
}
```
**别忘了取模，注意 $u,x,y$ 枚举时的初始值是多少。**

---

## 作者：_O_v_O_ (赞：3)

## 思路

好玩的 dp。

设 $dp_{i,j,c,x,y}$ 为到 $(i,j)$ 时花 $c$ 元还剩 $x$ 张 A 公司，$y$ 张 B 公司的票，初始 $dp_{1,1,0,0,0}=1$。

那么很明显有个转移：

$$dp_{i,j,c,x,y}=\sum\limits_{A=0}^x\sum\limits_{B=0}^y dp_{i-1,j,c-A\times a_{i,j}-B\times b_{i,j},x-A+1,y-B}+dp_{i,j-1,c-A\times a_{i,j}-B\times b_{i,j},x-A,y-B+1}$$

时间 $O(n^7)$，空间 $O(n^5)$，仍需努力。

我们发现这玩意儿等价于求一个 $dp_{i-1,j}$ 和 $dp_{i,j-1}$ 的二维前缀和，所以可以简化成：

$$dp_{i,j,c,x,y}=dp_{i-1,j,c,x+1,y}+dp_{i,j-1,c,x,y+1}+dp_{i,j,c-a_{i,j},x-1,y}+dp_{i,j,c-b_{i,j},x,y-1}-dp_{i,j,c-a_{i,j}-b_{i,j},x-1,y-1}$$

时间 $O(n^5)$，空间 $O(n^5)$，空间会炸。

我们注意到每次转移只会涉及到 $dp_i$ 和 $dp_{i-1}$，那么 $i$ 这维很明显能用滚动数组滚掉。

时间 $O(n^5)$，空间 $O(n^4)$，可以 AC。

## 代码

~~话说一年前的自己如果能有场切这题的实力也不至于只有勾五了。~~

代码略压行。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=50,K=100,mod=998244353;
int n,m,k;
int a[N][N],b[N][N];
int dp[2][N][K][N][N],ans[N][N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j];
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>b[i][j];
	dp[1][1][0][0][0]=1;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		if(i!=1) dp[i&1][j][0][0][0]=0;
		for(int c=1;c<=k;c++){
			for(int x=0;i+x<=n;x++) for(int y=0;j+y<=m;y++){
				int res=mod;
				if(x!=0&&c>=a[i][j]) res+=dp[i&1][j][c-a[i][j]][x-1][y];
				if(y!=0&&c>=b[i][j]) res+=dp[i&1][j][c-b[i][j]][x][y-1];
				if(x!=0&&y!=0&&c>=a[i][j]+b[i][j]) res-=dp[i&1][j][c-a[i][j]-b[i][j]][x-1][y-1];
				if(i!=1) res+=dp[(i-1)&1][j][c][x+1][y];
				if(j!=1) res+=dp[i&1][j-1][c][x][y+1];
				dp[i&1][j][c][x][y]=res%mod;
				if(c==k&&x==0&&y==0) ans[i][j]=res%mod;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cout<<ans[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}
```

[常数很小，最大点只有 495ms](https://www.luogu.com.cn/record/162148489)

---

## 作者：zyn_ (赞：2)

# P9743 「KDOI-06-J」旅行

## 题目大意

C 国有 $n\times m$ 个城市，成网格型，编号 $(1,1)$ 至 $(n,m)$。在城市 $(i,j)$ 中，买一张 L 公司的票要 $a_{i,j}$ 元，买一张 Z 公司的票要 $b_{i,j}$ 元。

一个城市中可以买任意多票。一张 L 公司的票可以使小 C 从 $(i,j)$ 到 $(i+1,j)$。一张 Z 公司的票可以使小 C 从 $(i,j)$ 到 $(i,j+1)$。

小 C 有 $k$ 元钱。对任意 $(i,j)$，求小 C **花完所有钱，用完所有票**，从 $(1,1)$ 到达 $(i,j)$ 的方案数，对 $998,244,353$ 取模。

## 题目分析

$n,m\le 45$ 大概不可能指数级别的算法了……

注意到：

1. $k,a_{i,j},b_{i,j}\le 90$。

2. 要求对于所有 $(i,j)$ 的方案数。

3. 这是 J 组第 $4$ 题！

考虑设计一个高维 DP。设 $dp_{i,j,L,Z,p}$ 代表，从 $(1,1)$ 到 $(i,j)$，在 $(i,j)$ 处买票后，还有 $L$ 张 L 公司的票，$Z$ 张 Z 公司的票，$p$ 元钱的方案数。$1\le i\le n$，$1\le j\le m$，$0\le L\lt n$，$0\le Z\lt m$，$0\le p\le k$。

分以下几种情况：

1. 从 $(i-1,j)$ 用一张 L 公司的票到 $(i,j)$，有 $dp_{i-1,j,L+1,Z,p}$ 种方案。要求 $i\gt 1$。

2. 从 $(i,j-1)$ 用一张 Z 公司的票到 $(i,j)$，有 $dp_{i,j-1,L,Z+1,p}$ 种方案。要求 $j\gt 1$。

3. 在 $(i,j)$ 处再买了一张 L 公司的票，有 $dp_{i,j,L-1,Z,p+a_{i,j}}$ 种方案。要求 $L\gt 0$。由于小 C 初始 $k$ 元钱，额外要求 $p+a_{i,j}\le k$。

4. 在 $(i,j)$ 处再买了一张 Z 公司的票，有 $dp_{i,j,L,Z-1,p+b_{i,j}}$ 种方案。要求 $Z\gt 0$。由于小 C 初始 $k$ 元钱，额外要求 $p+b_{i,j}\le k$。

5. 情况 $3,4$ 中，在 $(i,j)$ 处同时买 L 公司和 Z 公司的票的方案数会多算一次，要**减去** $dp_{i,j,L-1,Z-1,p+a_{i,j}+b_{i,j}}$ 种。要求 $L>0$，$Z>0$，$p+a_{i,j}+b_{i,j}\le k$。

初始状态：$dp_{1,1,0,0,k}=1$，其他 $dp_{1,1,L,Z,p}=0$。

时间复杂度是 $O(n^2m^2k)$，在 $3$ 秒的时限下可以接受，轻微卡常。

但空间复杂度 $O(n^2m^2k)$ 不可接受，需要滚动数组将 $i$ 这一维消掉。

不要忘了取模。不要取太多次模，以免常数过大。

## AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 48
#define K 95
#define rep(i,a,x) for(int i=a;i<=x;++i)
#define mod 998244353
int n,m,k,a[N][N],b[N][N],c;
long long dp[2][N][N][N][K];
int main(){
	scanf("%d%d%d",&n,&m,&k);
	rep(i,1,n)rep(j,1,m)scanf("%d",&a[i][j]);
	rep(i,1,n)rep(j,1,m)scanf("%d",&b[i][j]);
	dp[1][1][0][0][k]=1;
	for(int i=1,now=1,old=0;i<=n;++i,now^=1,old^=1){
		rep(j,1,m){
			rep(L,0,n-1)rep(Z,0,m-1)rep(p,0,k){
				if(i>1)dp[now][j][L][Z][p]+=dp[old][j][L+1][Z][p];
				if(j>1)dp[now][j][L][Z][p]+=dp[now][j-1][L][Z+1][p];
				if(L>0&&p+a[i][j]<=k)dp[now][j][L][Z][p]+=dp[now][j][L-1][Z][p+a[i][j]];
				if(Z>0&&p+b[i][j]<=k)dp[now][j][L][Z][p]+=dp[now][j][L][Z-1][p+b[i][j]];
				if(L>0&&Z>0&&p+a[i][j]+b[i][j]<=k)
					dp[now][j][L][Z][p]+=(mod-dp[now][j][L-1][Z-1][p+a[i][j]+b[i][j]]);
				dp[now][j][L][Z][p]%=mod;
			}
			printf("%lld ",dp[now][j][0][0][0]);
		}
		puts("");
		rep(j,1,m)rep(L,0,n)rep(Z,0,m)rep(p,0,k)dp[old][j][L][Z][p]=0;
	}
	return 0;
}
```

---

## 作者：naught (赞：0)

# 「KDOI-06-J」旅行

## 题意

题目讲的很清楚，不再过多赘述。

## Solution

不难想到 $O(n^2 \times m^2 \times k)$ 的做法：定义 $f_{i,j,val,x,y}$ 为当前在 $(x, y)$ 的位置，花费 $val$ 元，手上有 $x$ 张 $L$ 公司的票，$y$ 张 $Z$ 公司的票的方案数，至于空间问题，滚动数组滚掉第一维即可。

转移分 $5$ 类讨论，其他疑问见代码。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define Maxn 50
#define Maxk 95
#define Mod 998244353
#define fo(i, l, r) for (int i = l; i <= r; ++i)
#define fr(i, r, l) for (int i = l; i >= r; --i)
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21], *p1 = buf, *p2 = buf;
inline int read(int x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}

int n, m, k, a[Maxn][Maxn], b[Maxn][Maxn];
ll f[2][Maxn][Maxk][Maxn][Maxn], ans[Maxn][Maxn];

int main()
{
    n = read(), m = read(), k = read();
    fo(i, 1, n) fo(j, 1, m) a[i][j] = read();
    fo(i, 1, n) fo(j, 1, m) b[i][j] = read();
    f[1][1][0][0][0] = 1; // 初始状态
    fo(i, 1, n) fo(j, 1, m)
    {
        int t = i&1; if(i-1) f[t][j][0][0][0] = 0;
        fo(val, 1, k) fo(x, 0, n-i) fo(y, 0, m-j)
        {
            ll tmp = 0;
            if(x && val >= a[i][j]) (tmp += f[t][j][val - a[i][j]][x-1][y]) %= Mod;
            if(y && val >= b[i][j]) (tmp += f[t][j][val - b[i][j]][x][y-1]) %= Mod;
            if(x && y && val >= a[i][j]+b[i][j]) ((tmp -= f[t][j][val-a[i][j]-b[i][j]][x-1][y-1]) += Mod) %= Mod;
            if(i-1) (tmp += f[t^1][j][val][x+1][y]) %= Mod;
            if(j-1) (tmp += f[t][j-1][val][x][y+1]) %= Mod;
            f[t][j][val][x][y] = tmp; // 记忆化
            if(val == k && !x && !y) ans[i][j] = tmp; //是答案
        }
    }
    fo(i, 1, n)
    {
        fo(j, 1, m) printf("%lld ", ans[i][j]);
        puts("");
    }
    return 0;
}
```

---


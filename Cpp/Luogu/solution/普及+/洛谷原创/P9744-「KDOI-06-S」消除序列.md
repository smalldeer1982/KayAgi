# 「KDOI-06-S」消除序列

## 题目描述

小 M 有一个长度为 $n$ 的序列 $v_1,v_2,\ldots,v_n$，初始时，所有元素的值均为 $1$。

你有 $3$ 种作用在这个序列上的操作：

1. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_1,v_2,\ldots,v_i$ 的值全部设为 $0$，这种操作的代价是 $a_i$；
2. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $0$，这种操作的代价是 $b_i$；
3. 选择一个下标 $i$（$1\le i\le n$），并且将 $v_i$ 的值设为 $1$，这种操作的代价是 $c_i$。

现在有 $q$ 次询问，每次询问中给定一个集合 $P$，你希望进行若干次操作（可能为 $0$），使得：序列 $v$ 中下标位于该集合的元素的值为 $1$，其余位置的值为 $0$。**形式化地说，对于任意 $\bm{1\le i\le n}$，若 $\bm{i\in P}$，则 $\bm{v_i=1}$，否则 $\bm{v_i=0}$。** 并且，你需要最小化这次询问中所有操作的总代价。

注意，询问是相互独立的，也就是说，每次询问结束后，序列 $v$ 将会回到初始状态，即所有元素的值全都变为 $1$。

## 说明/提示

**【样例解释 #1】**

对于第一次询问，可以按顺序执行如下操作：

+ 在 $i=4$ 处执行操作 $1$，在这之后，序列 $v$ 变为 $[0,0,0,0,1]$，代价为 $0$；
+ 在 $i=4$ 处执行操作 $3$，在这之后，序列 $v$ 变为 $[0,0,0,1,1]$，代价为 $2$；
+ 在 $i=5$ 处执行操作 $2$，在这之后，序列 $v$ 变为 $[0,0,0,1,0]$，代价为 $5$。

所以总代价为 $0+2+5=7$，可以证明，不存在更小的总代价。

**【样例解释 #3】**

对于这个样例中的唯一一次询问，可以选择在 $i=10$ 处执行操作 $1$，总代价为 $a_{10}=7$。

**【样例 #4】**

见选手目录下的 `reserve/reserve4.in` 与 `reserve/reserve4.ans`。

**【样例 #5】**

见选手目录下的 `reserve/reserve5.in` 与 `reserve/reserve5.ans`。

这个样例满足测试点 $8\sim 11$ 的条件限制。

**【样例 #6】**

见选手目录下的 `reserve/reserve6.in` 与 `reserve/reserve6.ans`。

这个样例满足测试点 $14\sim 15$ 的条件限制。

**【样例 #7】**

见选手目录下的 `reserve/reserve7.in` 与 `reserve/reserve7.ans`。

这个样例满足测试点 $16$ 的条件限制。

**【样例 #8】**

见选手目录下的 `reserve/reserve8.in` 与 `reserve/reserve8.ans`。

这个样例满足测试点 $17\sim 20$ 的条件限制。

***

**【数据范围】**

记 $\sum m$ 为单测试点内所有询问 $m$ 的值之和。

对于所有数据保证：$1 \leq n \leq 5\times 10^5$，$0\le m \le n$，$0 \leq \sum m \leq 5 \times 10^5$，$1\le q\le \max(n,\sum m)$，$0 \le a_i, b_i, c_i \le 10^9$，$1\le p_i \le n$。

| 测试点编号 | $n \le$ | $m \le$ | $\sum m \le$| 是否有特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1 \sim 2$ | $5 \times 10^5$ | $0$ | $0$ | 否 |
| $3 \sim 4$ | $7$ | $7$ | $15$ | 否 |
| $5 \sim 6$ | $2 \times 10^3$ | $1$ | $2 \times 10^3$ | 否 |
| $7$ | $2 \times 10^3$ | $2 \times 10^3$ | $2 \times 10^3$ | 是 |
| $8 \sim 11$ | $2 \times 10^3$ | $2\times 10^3$ | $2 \times 10^3$ | 否 |
| $12 \sim 13$ | $5 \times 10^4$ | $5 \times 10^4$ | $5 \times 10^4$ | 否 |
| $14 \sim 15$ | $5 \times 10^5$ | $1$ | $5 \times 10^5$ | 否 |
| $16$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 是 |
| $17 \sim 20$ | $5 \times 10^5$ | $5 \times 10^5$ | $5 \times 10^5$ | 否 |

特殊性质：对于任意 $1\le i\le n$，保证 $c_i = 0$。

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

## 样例 #1

### 输入

```
5
1 13 6 0 6
2 4 1 0 5
3 4 1 2 1
7
1 4
2 1 5
1 4
2 2 3
5 1 2 3 4 5
1 5
2 3 4```

### 输出

```
7
3
7
6
0
0
8```

## 样例 #2

### 输入

```
7
10 1 6 9 4 2 4 
0 5 2 3 0 1 4 
4 1 4 1 5 3 5 
6
3 1 3 6 
2 2 6 
4 3 4 5 7 
1 4 
2 3 7 
3 3 5 6```

### 输出

```
12
8
2
5
5
8```

## 样例 #3

### 输入

```
10
6 10 7 2 8 4 6 4 8 7
4 0 6 7 8 4 8 2 10 5
4 10 6 1 4 7 5 3 8 7
1
0```

### 输出

```
7```

# 题解

## 作者：HFanGDoDM (赞：53)

## 前置知识

[ST 表](https://www.luogu.com.cn/problem/P3865)

# 题意简述

给定一个长度为 $n$ 的序列 $v$。初始时，$\forall i\in\{1,2,\dots,n\},v_i=1$。可执行以下操作：

选定一个 $i\in\{1,2,\dots,n\}$。然后：

- 以 $a_i$ 的代价，$\forall j\in \{1,2,\dots,i\}$，令 $v_j\leftarrow0$。

- 以 $b_i$ 的代价，令 $v_i\leftarrow0$。

- 以 $c_i$ 的代价，令 $v_i\leftarrow1$。

有 $q$ 次询问，每次询问给定集合 $P$，求使得序列 $v$ 满足 

$$\forall i\in\{1,2,\dots,n\},v_i=\begin{cases}
0,i\not\in P\\
1,i\in P
\end{cases}$$

的 **最小总代价**。

**每次询问相互独立**。

### 数据范围

$1 \leqslant n,\sum m \leqslant 5\times 10^5$，$0\leqslant m \leqslant n$，$1\leqslant q\leqslant \max(n,\sum m)$，$0 \leqslant a_i, b_i, c_i \leqslant 10^9$，$1\leqslant p_i \leqslant n$。

| 测试点编号 | $n \leqslant$ | $m$ | $\sum m$| $c_i$ |
|:--:|:--:|:--:|:--:|:--:|
| $1 \sim 2$ | $5 \times 10^5$ | $=0$ | $=0$ | $\leqslant10^9$ |
| $3 \sim 4$ | $7$ | $\leqslant7$ | $ \leqslant15$ | $\leqslant10^9$ |
| $5 \sim 6$ | $2000$ | $\leqslant1$ | $ \leqslant2000$ | $\leqslant10^9$ |
| $7$ | $2000$ | $\leqslant2000$ | $ \leqslant2000$ | $=0$ |
| $8 \sim 11$ | $2000$ | $\leqslant2000$ | $ \leqslant2 000$ | $\leqslant10^9$ |
| $12 \sim 13$ | $5 \times 10^4$ | $\leqslant5 \times 10^4$ | $ \leqslant5 \times 10^4$ | $\leqslant10^9$ |
| $14 \sim 15$ | $5 \times 10^5$ | $\leqslant1$ | $ \leqslant5 \times 10^5$ | $\leqslant10^9$ |
| $16$ | $5 \times 10^5$ | $\leqslant5 \times 10^5$ | $ \leqslant5 \times 10^5$ | $=0$ |
| $17 \sim 20$ | $5 \times 10^5$ | $\leqslant5 \times 10^5$ | $ \leqslant5 \times 10^5$ | $\leqslant10^9$ |

# 解题思路

## 测试点 $1\sim2$

### 做法

这里令 $a_0=0$，则答案为

 $$\displaystyle\min_{i=0}^n\{a_i+\displaystyle\sum_{j=i+1}^nb_i\}$$

### 正确性证明


$m=0\implies P=\varnothing\implies\forall i\in\{1,2,\dots,n\},i\not\in P\implies$ 在最终的序列 $v$ 中，$\forall i\in\{1,2,\dots,n\},v_i=0$。

因此，我们不可能将 $v_i$ 赋值为 $1$，**只可能以 $a_i$ 或 $b_i$ 代价将序列赋值为 $0$**。

设我们 **用 $b_i$ 的代价单独** 赋值为 $0$ 的所有 **下标** 构成的集合为 $A$。设 $A$ 中最小的元素为 $d$，若 $\exists i\in\{d+1,d+2,\dots,n\},i\not\in A$，则我们必然需要花费 $a_i$ 的代价，将 $v_i\leftarrow0$。此时，我们同时也使得 $\forall i\in\{1,2,\dots,i\},v_i=0$，若不花费 $b_d$ 的代价，也能达成这一效果，因此 **至少 $b_d$ 的花费是不必要的**，即该条件下的方案 **一定不优**。

因此得证：若对元素 **单独** 赋值为 $0$，则必然有 $\forall i\in\{d,d+1,d+2,\dots,n\},i\in A$，其中 $d$ 和 $A$ 的含义同上。也就是说，**在最优方案中，单独赋值为 $0$ 的下标必然构成序列下标的一段后缀**。

此时还需要对 $v_1,v_2,\dots,v_i$ **全体元素** 赋值为 $0$。若 $i\not=d-1$，则必然需要花费 $a_{d-1}$ 的代价将 $d-1$ 之前的元素赋值为 $0$，此时 $a_i$ 的花费是不必要的，即该条件下的方案 **一定不优**。

因此得证：**只有花费 $a_{d-1}$ 的代价将 $v_1,v_2,\dots,v_{d-1}$ 全体赋值为 $0$，才可能成为最优方案**。

综上所述，将所有可能成为最优方案的方案再取最优，即为问题的答案：

 $$\displaystyle\min_{i=0}^n\{a_i+\displaystyle\sum_{j=i+1}^nb_i\}$$
 
因而思路正确。

### 具体实现

预处理 $b_i$ 的 **后缀和**。分别枚举使用 $a_i$ 代价与使用 $b_i$ 代价的分界点，计算对应总代价，不断更新答案。

最终对于每个询问，输出这个答案。

### 时间复杂度分析

处理后缀和，复杂度 $O(n)$。枚举分界点时，由于此时后缀和可 $O(1)$ 求，因此总复杂度也为 $O(n)$。

对于所有的询问输出答案，复杂度 $O(q)$。

总时间复杂度 $O(n+q)$，可以通过 **测试点 $1\sim2$**。

### 参考核心代码

```cpp
for(i=n;i>=1;i--)
    sumb[i]=sumb[i+1]+1ll*b[i];//计算b数组的后缀和
long long ans=INF;
for(i=0;i<=n;i++)
    ans=min(ans,a[i]+sumb[i+1]);//计算每个总代价，更新答案
int q=R();
while(q--){
    int m=R();
    printf("%lld\n",ans);//对于每个询问，输出答案
}
```

### 期望得分

$10$ 分。

## 测试点 $3\sim4$

### 做法

令初始的所有 $v_i=1$。

对于每一个位置 $i$，**分别枚举** 以下情况：

- 使用 $a_i$ 的代价，将 $v_1,v_2,\dots,v_i$ 全部赋值为 $0$，并将 $v_1,v_2,\dots,v_i$ 中应当在最终序列中为 $1$ 的所有元素 $v_j$，使用对应的 $c_j$ 代价将其赋值为 $1$。

- 使用 $b_i$ 的代价，将 $v_i\leftarrow0$。

- 使用 $c_i$ 的代价，将 $v_i\leftarrow1$。

- 不做任何操作。

并继续向下 **搜索**，直到所有位置的操作都确定完。当所有位置操作做完后，判断当前序列是否与应当的最终序列相同。若不相同，则不合题意；若相同，则更新答案。

这样即可得到最终的答案。

### 正确性证明

考虑序列的第 $i$ 个位置。

若使用上述第一种操作中，用 $a_i$ 代价将 $v_1,v_2,\dots,v_i$ 全部赋值为 $0$，则只有使用上述的 $\sum c_j$ 代价将前面应当赋值为 $1$ 的元素全部赋值为 $1$，才能保证当前序列是符合题意的序列。若其中含有其他操作，由于可以只使用 $\sum c_j$ 代价进行赋值为 $1$ 的操作，因此这些 **其他操作一定是不必要的**。

故：使用 $a_i$ 代价将 $v_1,v_2,\dots,v_i$ 全部赋值为 $0$ 和使用 $\sum c_j$ 代价将应当赋值为 $1$ 的元素全部赋值为 $1$，这两个操作是 **捆绑的**。

对于该位置，也可以做上述的第二、三、四种操作。除此之外，再无别的操作。

因此，我们考虑到了 **所有可能符合题意的操作**，并从中筛选出了 **所有真正符合题意的操作**，并取最小答案。所以，这一思路是正确的。

### 具体实现

使用 **深度优先搜索**（DFS）实现。

对于每个询问，记 $DFS(now,cost)$ 表示搜索到了 $now$ 位置，当前的所有操作代价总和为 $cost$。则枚举该位置的四种情况：

记 $\Delta$ 表示该位置的一种操作产生的 $cost$ 增加量。

- 第一种情况：$\Delta=a_{now}+\displaystyle\sum_{i=1}^{now}[i\in P]c_i$。

- 第二种情况：$\Delta=b_{now}$。

- 第三种情况：$\Delta=c_{now}$。

- 第四种情况：$\Delta=0$。

继续向下执行 $DFS(now+1,cost+\Delta)$ 即可。注意在枚举对应情况时，需要对序列对应元素 **及时赋值**。为了便于 **回溯**，可以在函数内部再开一个数组，记录 **赋值前序列的前 $now$ 个元素**。

当 $now=n+1$ 时，首先判断当前序列是否与应当得到的最终序列相同。若不同，直接返回；否则，更新答案。

最后输出答案。

### 时空复杂度分析

**时间复杂度**：由于对每个位置需要枚举 $4$ 种情况，每次枚举的复杂度为 $O(n)$，因此对每个询问，总复杂度为 $O(n4^n)$。

总时间复杂度 $O(4^nqn)$，可以通过 **测试点 $3\sim4$**。

**空间复杂度**：在 DFS 中，递归的最大层数为 $O(n)$ 级别，且每层需要新开一个大小为 $O(n)$ 的临时数组。

空间复杂度为 $O(n^2)$，可以通过 **测试点 $3\sim4$**。

### 参考核心代码

```cpp
void DFS(int now,long long cost){
    if(now==n+1){//如果已经确定所有位置的操作
        for(int i=1;i<=n;i++)
            if(tmp[i]!=fnl[i])//判断当前序列是否符合题意，若不符合直接返回
                return;
        ans=min(ans,cost);//否则更新答案
        return;
    }
    long long delta=a[now];//cost增加量
    vector<int>tmp1(now+1);
    for(int i=1;i<=now;i++)
        tmp1[i]=tmp[i];//临时数组，记录赋值前序列
    for(int i=1;i<=now;i++)
        tmp[i]=0;
    for(int i=1;i<=m;i++){
        if(p[i]>now)
            break;
        delta+=c[p[i]];
        tmp[p[i]]=1;//第一种情况
    }
    DFS(now+1,cost+delta);//向下继续搜索
    for(int i=1;i<=now;i++)
        tmp[i]=tmp1[i];//回溯
    tmp[now]=0;
    delta=b[now];
    DFS(now+1,cost+delta);//第二种情况
    tmp[now]=tmp1[now];//回溯
    tmp[now]=1;
    delta=c[now];
    DFS(now+1,cost+delta);//第三种情况
    tmp[now]=tmp1[now];//回溯
    DFS(now+1,cost);//第四种情况
}
...
        fill(tmp+1,tmp+1+n,1);//初始v[i]=1
        fill(fnl+1,fnl+1+n,0);
        for(i=1;i<=m;i++)
            fnl[p[i]]=1;//设定最终序列
        ans=INF;
        DFS(1,0);
        printf("%lld\n",ans);//输出答案
```

### 期望得分

$10$ 分。结合 **测试点 $1\sim2$** 的算法可以获得 $20$ 分。

## 测试点 $5\sim6$

### 做法

令 $a_0=0$。当 $m=1$ 时，对于每个询问，其答案为

$$\min(\displaystyle\min_{i=0}^{p_1-1}\{a_i+\displaystyle\sum_{j=i+1}^{p_1-1}b_j+\displaystyle\sum_{j=p_1+1}^nb_j\},\displaystyle\min_{i=p_1}^n\{a_i+\displaystyle\sum_{j=i+1}^nb_j+c_{p_1}\})$$

$m=0$ 时的答案与 **测试点 $1\sim2$** 中相同。

### 正确性证明

对于所有的询问，$m=1\implies$ 最终序列中只有一个位置 $p_1$ 满足 $v_{p_1}=1$，其他位置 $i$ 都有 $v_i=0$。

考虑对序列除 $p_1$ 位置外的所有位置赋 $0$ 的方式。由 **测试点 $1\sim2$** 的证明，对于最终为全 $0$ 的序列，最优方案使用 $a_i$ 的代价 **最多一次**。并且，使用 $b_i$ 代价赋值的所有下标必然构成 **一段后缀**。

现尝试将该结论迁移到 $m=1$ 的情况。若在 $p_1$ 下标前的 $i$ 使用了一次 $a_i$ 代价，则在 $i$ 后面的位置 $j$，再使用一次 $a_j$，也 **一定是不优的**，证法类似。若使用 $b_i$ 的下标 $i$ 中，存在位置 $j$ 满足最终 $v_j=0$ 且未使用 $b_j$，则必然使用 $a_j$，则该情况回到了 **测试点 $1\sim2$**，必然不优，**所有其他位置 $j$ 必然使用一次 $b_j$**。

因此，**测试点 $1\sim2$** 的结论在此处 **仍然基本成立**。

考虑在 $p_1$ 下标及其后面下标 $i$ 处使用 $a_i$ 的情况。此时根据上述推理，必然在 $i+1,i+2,\dots,n$ 处使用 $b_i$。由于最终需要使得 $v_{p_1}=1$，因此还需要 **使用一次 $c_{p_1}$**，才能符合题意，不需要再使用其他操作。

因此上述答案得证。

### 具体实现

对于 $m=1$：

预处理 $b$ 数组的前缀和 $sumb$，则 $\displaystyle\sum_{i=l}^rb_i=sumb_r-sumb_{l-1}$。

处理每次询问时，扫一遍序列，按照上述计算式计算即可。

也可以使用 $sumb_n-sumb_i-b_{p_1}$ 代替 $\displaystyle\sum_{j=i+1}^{p_1-1}b_j+\displaystyle\sum_{j=p_1+1}^nb_j$。

扫完整个序列之后输出答案即可。

### 时间复杂度分析

处理前缀和，复杂度 $O(n)$。每次回答询问时，需要扫一遍序列，单次回答复杂度 $O(n)$。

总时间复杂度 $O(qn)$，可以通过 **测试点 $5\sim6$**。

### 参考核心代码

以下代码略去了 $m=0$ 的情况。

```cpp
...//预处理b数组前缀和
    for(i=0;i<p[1];i++)//计算前半部分答案
        ans=min(ans,a[i]+sumb[n]-sumb[i]-b[p[1]]);
    for(i=p[1];i<=n;i++)//计算后半部分答案
        ans=min(ans,a[i]+sumb[n]-sumb[i]+c[p[1]]);
    printf("%lld\n",ans);//输出答案
```

### 期望得分

$10$ 分。结合 **测试点 $1\sim2$** 的算法可以获得 $20$ 分，结合 **测试点 $3\sim4$** 的算法可以获得 $20$ 分，结合 **测试点 $1\sim4$** 的算法可以获得 $30$ 分。$(1)$

## 测试点 $7$

### 做法

令 $a_0=0$。则对于每个询问，其答案为

$$\displaystyle\min_{i=0}^n\{a_i+\displaystyle\sum_{j=i+1}^n[j\not\in P]b_j\}$$

### 正确性证明

根据 **测试点 $3\sim4$** 的推理，我们知道，将 $v_1,v_2,\dots,v_i$ 全部赋值为 $0$ 的操作，往往和将所有 $j\in P,j\in\{1,2,\dots,i\}$ 的 $v_j\leftarrow1$ 的操作是 **捆绑的**。

并且由于 $c_i=0$，因此我们 **可以无视** 赋值为 $1$ 的代价，只需要考虑 $a_i$ 和 $b_i$ 即可。

根据 **测试点 $1\sim2$** 的推理，若分别使用一次 $a_i,a_j$，这样的 **总代价一定是更大的**。因此，$a_i$ 最多只可能使用一次。确定 $a_i$ 使用位置后，只需要在其后面使用 $b_i$ 将对应位置 $v_i\leftarrow0$。同时，由于 $m\geqslant1$，为尽可能 **最小化总代价**，只对最终序列中所有 $v_i=0$ 的位置 $i$ 使用 $b_i$ 的代价即可。这些位置的代价是 **必须使用**，**不可替代** 的，若在其他位置使用其他代价，则都是不必要的。

我们证明了在这些答案中一定能够取到所有合法总代价的 **下界**，因此该思路是正确的。

### 具体实现

对于每一次询问，处理一个 **后缀和** 数组：$sum_i=\displaystyle\sum_{j=i}^n[i\not\in P]b_i$。

然后，扫一遍序列，按照上式计算即可。

最后输出答案。

### 时间复杂度分析

对于每次询问，需要处理后缀和数组，复杂度 $O(n)$；扫一遍序列并计算，复杂度 $O(n)$。

总时间复杂度 $O(qn)$。根据该解法，可以通过 **测试点 $1\sim2,7$**。

### 参考核心代码

```cpp
    for(i=1;i<=m;i++)
        fnl[p[i]]=1;//设定最终序列
    for(i=n;i>=1;i--)
        sumb1[i]=sumb1[i+1]+b[i]*(!fnl[i]);//求b的上述后缀和
    for(i=0;i<=n;i++)
        ans=min(ans,a[i]+sumb1[i+1]);//根据上式计算答案
    printf("%lld\n",ans);//输出答案
```

### 期望得分

$15$ 分。结合 **测试点 $3\sim4$** 的算法可以获得 $25$ 分，结合 **测试点 $5\sim6$** 的算法可以获得 $25$ 分，结合**测试点 $3\sim6$** 的算法可以获得 $35$ 分。$(2)$

## 测试点 $8\sim11$

### 做法

对于每个询问，设 $dp_i$ 表示考虑将序列 $[1,p_i]$ 变为合法序列的 **最小总代价**。则

$$dp_i=\min(\displaystyle\min_{j=p_{i-1}+2}^{p_i}\{a_j+\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+\displaystyle\sum_{k=j}^{p_i-1}b_k\},dp_{i-1}+\displaystyle\sum_{k=p_{i-1}+1}^{p_i-1}b_k,a_{p_i}+\displaystyle\sum_{k=1}^{p_i}[k\in P]c_k)$$

对于每个询问，令 $p_{m+1}=n+1$，且计算 $dp_{m+1}$ 时的上述式子 **不包含第三项**，则答案为 $dp_{m+1}$。

### 正确性证明

根据前面几个测试点的推理，我们注意到，将一段 **区间全部赋值为 $0$** 已成为 **重要的子问题**。由于 $\forall i\in\{1,2,\dots,m-1\},p_i\lt p_{i+1}$，因此我们在考虑到 $p_i$ 时，$\forall j\in\{p_{i-1}+1,p_{i-1}+2,\dots,p_i-1\}$，都需要使得最终序列的 $v_j=0$，且 $p_{i-1}$ 及前面的最小代价已知。

现考虑所有可能将该区间全部赋值为 $0$ 的方案：

- 对于一个 $j\in\{p_{i-1}+1,p_{i-1}+2,\dots,p_i-1\}$，使用 $a_j$ 的代价，将 $v_1,v_2,\dots,v_j$ 全部赋值为 $0$。此后需要立即执行 $\forall k\in\{1,2,\dots,j\},k\in P,v_k\leftarrow1$ 的操作（具体原因见 **测试点 $3\sim4$**），并将位置 $j$ 到 $p_i-1$ 这段后缀中每个位置 $k$，全部用 $b_k$ 的代价赋值为 $0$。$a_j$ 不可能在不同位置使用多次，原因见 **测试点 $1\sim2,5\sim6$** 等，这里不再赘述。

- 对于该区间的所有位置 $i$，使用 $b_i$ 代价，将 $v_i\leftarrow0$。由于该操作 **基于 $p_{i-1}$ 及前面已经操作好的序列**，因此需要将该代价与 $dp_{i-1}$ **累加**。

- 在 $p_i$ 位置使用 $a_{p_i}$ 代价，将 $v_1,v_2,\dots,v_{p_i}$ 全部赋值为 $0$，再 $\forall k\in\{1,2,\dots,p_i\},k\in P,v_k\leftarrow1$。该操作其实与第一个操作类似，但赋值为 $1$ 的元素多了一个 $v_{p_i}$。

若 $b_i$ 代价使用的下标不构成 $\{1,2,\dots,p_i-1\}$ 的一段后缀，则该方案 **一定不优**，具体已在 **测试点 $1\sim2,5\sim6$** 中证明。

由于已知最终序列中 $v_{p_i}=1$，因此若使用 $b_{p_i}$ 代价，单独将 $v_{p_i}\leftarrow0$，则该操作必然是 **多余的**。

综上，我们已经考虑到了此时所有可能的最优情况。

对于 $dp_{m+1}$，由于实际上不存在 $n+1$ 位置的元素，因此只能将 $v_{p_m},v_{p_m+1},\dots,v_n$ 全部赋值为 $0$，故其计算式中只有前两项。

因此，我们考虑完了 **整个序列** 的所有可能最优情况，故该思路是正确的。

### 具体实现

预处理 $b$ 的前缀和 $sumb$。

对于每次询问，在枚举每个 $p_i$ 时，先扫 $p_{i-1}+2$ 到 $p_i$，计算前两项更新 $dp$ 值，再 **动态更新** $\displaystyle\sum_{j=1}^{p_i}[j\in P]c_j$。具体地，在每次计算完式中前两项后，直接将 $c_{p_i}$ 加入该询问的 $sumc$。然后，计算第三项，更新 $dp$ 值。

扫完每个 $p_i$ 后，输出 $dp_{m+1}$。注意 $dp_{m+1}$ 的计算中 **没有第三项**。

### 时间复杂度分析

预处理 $sumb$，复杂度为 $O(n)$。处理每次询问，扫的范围 **刚好覆盖了整个序列**，因此复杂度为 $O(n)$。扫 $p_i$ 以及动态更新 $sumc$，复杂度 $O(m)$。

总时间复杂度 $O(qn)$。根据该解法，可以通过 **测试点 $3\sim11$。**

### 参考核心代码

```cpp
    p[m+1]=n+1;//边界条件
    long long sumc=0;//每次询问动态更新在P中i的c[i]总和
    for(i=1;i<=m+1;i++){
        dp[i]=INF;
        for(j=p[i-1]+1;j<=p[i]-1;j++)
            dp[i]=min(dp[i],sumc+a[j]+sumb[p[i]-1]-sumb[j]);//式子中的第一项
        dp[i]=min(dp[i],sumb[p[i]-1]-sumb[p[i-1]]+dp[i-1]);//第二项
        sumc+=c[p[i]];//更新sumc
        if(i<=m)
            dp[i]=min(dp[i],a[p[i]]+sumc);//第三项，注意多了c[p[i]]
    }
    printf("%lld\n",dp[m+1]);//输出答案
```

### 期望得分

$45$ 分。结合 **测试点 $1\sim2$** 的算法可以获得 $55$ 分。

## 测试点 $12\sim13$

### 做法

记 $val_i=a_i-\displaystyle\sum_{j=1}^ib_j$，则前述有关 $dp$ 表达式也可写作：

$$dp_i=\min(\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+\displaystyle\sum_{k=1}^{p_i-1}b_k+\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}val_j,dp_{i-1}+\displaystyle\sum_{k=p_{i-1}+1}^{p_i-1}b_k,a_{p_i}+\displaystyle\sum_{k=1}^{p_i}[k\in P]c_k)$$

对于第一个式子，使用 **分块** 事先计算每个整块内的 $val_i$ 的最小值即可。

### 正确性证明

上式中，第二、三个式子可以直接转移。

考虑将第一个式子进行变形：

$$\begin{aligned}\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}\{\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+a_j+\displaystyle\sum_{k=j+1}^{p_i-1}b_k\}
&=\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}\{a_j+\displaystyle\sum_{k=1}^{p_i-1}b_k-\displaystyle\sum_{k=1}^jb_k\}\\
&=\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}\{a_j-\displaystyle\sum_{k=1}^jb_k+\displaystyle\sum_{k=1}^{p_i-1}b_k\}\\
&=\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}\{val_j+\displaystyle\sum_{k=1}^{p_i-1}b_k\}\\
&=\displaystyle\sum_{k=1}^{p_{i-1}}[k\in P]c_k+\displaystyle\sum_{k=1}^{p_i-1}b_k+\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}val_j
\end{aligned}$$

可以发现，该式子变成了两个可预处理或动态更新的 **定值** 与一个 **区间最小值** 的形式，并且该序列 $val$ **不会发生改变**。因此我们可以直接运用分块思想，处理出每一块的最小值，加速询问的回答。

在恒等变形中每一步都保证正确，因此思路正确。

### 具体实现

预处理 $val_i=a_i-sumb_i$，并对 $val$ 数组分块：每 $O(\sqrt n)$ 个元素切成一个块，并预处理第 $i$ 块中的 $val_i$ 最小值 $minn_i$。其余预处理与 **测试点 $8\sim11$** 中所述相同。

对于每个询问，加速 dp 转移：对于第一个式子，计算 $\displaystyle\min_{i=l}^rval_i$ 时，将询问区间划分为中间的 **整块** 与两端 **散块**。对于所有整块，直接取对应块中的最小值；否则，暴力扫对应 **散块区间**，求最小值。求出区间最小值，并计算，更新答案。

其余仍按照 $dp$ 表达式转移即可。

最后输出 $dp_{m+1}$。

### 时间复杂度分析

由 测试点 $8\sim11$ 的分析可知，复杂度瓶颈在 dp。对于每次转移，分块求区间最小值，整块最多 $O(\sqrt n)$ 个，散块大小在 $O(\sqrt n)$ 级别，复杂度为 $O(\sqrt n)$，因此回答每次询问的复杂度为 $O(m\sqrt n)$。

总时间复杂度 $O((q+\sum m)\sqrt n)$。根据该解法，可以通过 **测试点 $1\sim13$**。

### 参考核心代码

```cpp
void InitBlock(){//初始化分块，预处理每个块val[i]最小值
    siz=sqrt(n);
    int num=n/siz+(n%siz!=0);
    for(int i=1;i<=n;i++)
        bel[i]=i/siz+(i%siz!=0);
    for(int i=1;i<=num;i++){
        int bl=siz*(i-1)+1,br=siz*i;
        minn[i]=INF;
        for(int j=bl;j<=br;j++)
            minn[i]=min(minn[i],val[j]);//预处理出最小值
    }
}
long long Min(int l,int r){//暴力求区间最小值
    long long ans=INF;
    for(int i=l;i<=r;i++)
        ans=min(ans,val[i]);
    return ans;
}
long long MinInterval(int l,int r){//求区间最小值
    if(l>r)
        return INF;
    if(bel[l]==bel[r])
        return Min(l,r);//同一块内直接暴力求
    long long ans=INF;
    for(int i=bel[l]+1;i<=bel[r]-1;i++)
        ans=min(ans,minn[i]);//中间整块
    int rtl=bel[l]*siz,ltr=(bel[r]-1)*siz+1;
    return min({Min(l,rtl),ans,Min(ltr,r)});//两端散块取最小值，再与ans取min
}
```

#### 期望得分

$75$ 分。$(4)$

## 测试点 $14\sim20$

### 做法

$dp$ 数组和 $val$ 数组含义与 **测试点 $8\sim15$** 相同。

在每次计算转移方程的第一项时，使用 **ST 表** 快速求其中的 $\displaystyle\min_{j=p_{i-1}+1}^{p_i-1}val_j$ 即可。

### 正确性证明

dp 转移的正确性已经在 **测试点 $8\sim11$** 中证明。

可以发现 $val$ 数组具有 **静态** 的特点，因此可以使用 ST 表加速求 **静态区间最小值**。

故该思路正确。

### 具体实现

使用 ST 表，预处理 $val$ 数组中每个 **从 $i$ 开始，长度为 $2^j$ 的区间最小值，记为 $ST_{i,j}$**。

在求区间 $[l,r]$ 的最小值时，令 $x=\lfloor\log_2(r-l+1)\rfloor$，只需求出 $\min(ST_{l,x},ST_{r-2^x+1,x})$ 即可。

仍按照上述 $dp$ 表达式进行转移。最终输出 $dp_{m+1}$。

### 时空复杂度分析

**时间复杂度**：对于每次 dp 转移，由于使用 ST 表，故可以做到 $O(1)$。因此处理所有询问，总复杂度为 $O(q+\sum m)$。预处理出 ST 表需要 $O(n\log n)$ 的复杂度。

总时间复杂度 $O(n\log n)$，可以通过 **本题**。

**空间复杂度**：ST 表本身需要 $O(n\log n)$ 的空间复杂度，其余数组空间复杂度为 $O(n)$。

空间复杂度 $O(n\log n)$，可以通过 **本题**。

### 参考核心代码

```cpp
long long MinInterval(int l,int r){//ST表单次询问求区间最小值
    if(l>r)
        return INF;
    long long ex=log_2[r-l+1];
    return min(ST[l][ex],ST[r-(1<<ex)+1][ex]);
}
...//预处理部分
    for(i=1;i<=n;i++)
        ST[i][0]=val[i];
...
    for(i=1;i<=log_2[n];i++)
        for(j=1;j<=n-(1<<i)+1;j++)
            ST[j][i]=min(ST[j][i-1],ST[j+(1<<(i-1))][i-1]);//ST 表预处理
...
    ...
    dp[i]=min(dp[i],sumb[p[i]-1]+sumc+MinInterval(p[i-1]+1,p[i]-1));//转移该式子时只需调用MinInterval函数即可
    ...//其余的dp转移
```

### 期望得分

$100$ 分。

--------------

$(1)$ 实际上，该实现也通过了 **测试点 $7$**。

$(2)$ 实际上，该实现也通过了 **测试点 $4$**。

$(3)$ 实际上，该实现也通过了 **测试点 $1\sim2,12\sim13,17$**。

$(4)$ 实际上，该实现也通过了 **测试点 $14\sim20$**。

---

## 作者：wxzzzz (赞：33)

### 思路

- update 2023.10.15 更正一处笔误，感谢 @[lwx20211103](https://www.luogu.com.cn/user/727008) 的指正。

动态规划。

一些定义：

- $f_i$ 表示使 $1\sim p_i$ 的元素从全为 $1$ 改变到满足条件的最小代价。

- $g_i$ 表示使 $1\sim p_i$ 的元素从全为 $0$ 改变到满足条件的最小代价。

首先可以初步的更新一下 $a_i$，看看是不是用某个 $a_{x-1}+\displaystyle\sum_{j=x}^i b_j$ 代替 $a_i$ 更优。有转移方程 $a_i=\min(a_i,a_{i-1}+b_i)$。

考虑 $g_i$，显然有 $g_i=g_{i-1}+c_{p_i}$。

考虑 $f_i$，有两种可能：

1. 把 $p_{i-1}\sim p_i$ 中的所有 $1$ 变为 $0$，代价为 $f_{i-1}+\displaystyle{\sum_{j=p_{i-1}}^{p_i}}b_j$，其中 $\displaystyle{\sum_{j=p_{i-1}}^{p_i}}b_j$ 可以用前缀和维护。

1. 把 $1\sim p_i$ 全部更改为 $0$，然后再改，代价为 $a_{p_i-1}+g_{i-1}$。

但是，$p_m$ 不一定为 $n$，还要考虑把 $p_m+1\sim n$ 的元素全部变为 $0$，和转移 $f$ 类似的，最终答案为 $\min(g_m+a_n,f_m+\displaystyle{\sum_{j=p_m+1}^{n}}b_j)$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q, m, a[1000005], b[1000005], c[1000005], p[1000005];
long long s[1000005], g[1000005], f[1000005];
int main() {
    cin >> n;

    for (int i = 1; i <= n; i++)
        cin >> a[i];

    for (int i = 1; i <= n; i++)
        cin >> b[i], s[i] = s[i - 1] + b[i];

    for (int i = 1; i <= n; i++)
        cin >> c[i];

    for (int i = 1; i <= n; i++)
        a[i] = min(a[i], a[i - 1] + b[i]);

    cin >> q;

    while (q--) {
        cin >> m;

        for (int i = 1; i <= m; i++)
            cin >> p[i];

        for (int i = 1; i <= m; i++) {
            g[i] = g[i - 1] + c[p[i]];
            f[i] = a[p[i] - 1] + g[i - 1];
            f[i] = min(f[i], f[i - 1] + s[p[i] - 1] - s[p[i - 1]]);
        }

        cout << min(g[m] + a[n], f[m] + s[n] - s[p[m]]) << '\n';
    }

    return 0;
}
```

---

## 作者：我怂了 (赞：27)

### 写在前面
今天打模拟赛就会这一题正解，正好有点别的事，写完这个就润了）
### 思路
dp。

记 $d_i$ 为在仅改动 $1\le j\le i$ 的位置，将前 $i$ 位改成 $0$ 的最小代价，不难得到 $d_i=\min(a_i,d_{i-1}+b_i)$。

记 $pre'_i$ 为 $b_i$ 的前缀和。

这俩玩意先预处理出来。

对于一组询问，考虑 dp。

将序列改到满足某一位 $i$ 有三种方法：一是在满足上一位后，将 $p_{i-1}\sim p_i$ 的位置都花费 $b$ 的代价搞定；二是将 $1\sim p_i-1$ 都花费 $d_{p_i-1}$ 的代价改成 $0$，然后再改前 $i-1$ 个位置；三是将上一种改法微调，改成将 $1\sim p_i$ 改掉，然后再把前 $i$ 位改掉。

转移方程（注意 $dp$ 和 $d_p$ 的区别）：
$$dp_i=\min(d_{p_i}+pre_i,d_{p_i-1}+pre_{i-1},dp_{i-1}+pre'_{p_i-1}-pre'_{p_{i-1}})$$
其中 
$$pre_j=\sum_{k=1}^{j}c_{p_k}$$
最后，答案就是 $min(d_n+pre_m,dp_m+pre'_n-pre'_{p_m})$，因为还有 $p_m$ 后面的位置要考虑。如果 $p_m=n$ 那么后面那项就是 $dp_m$，没有问题。


代码（$pre1$ 就是上面的 $pre'$）：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5e5+5;
int a[maxn],b[maxn],c[maxn],d[maxn],p[maxn],pre[maxn],pre1[maxn],n,q,m,dp[maxn];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=n;i++){
		d[i]=min(d[i-1]+b[i],a[i]);
		pre1[i]=pre1[i-1]+b[i];
	}
	cin>>q;
	while(q--){
		cin>>m;
		for(int i=1;i<=m;i++){
			cin>>p[i];
			pre[i]=pre[i-1]+c[p[i]];
		}
		dp[1]=min({d[p[1]]+pre[1],d[p[1]-1]});
		for(int i=2;i<=m;i++){
			dp[i]=min({d[p[i]]+pre[i],d[p[i]-1]+pre[i-1],dp[i-1]+pre1[p[i]-1]-pre1[p[i-1]]});
		}
		cout<<min({d[n]+pre[m],dp[m]+pre1[n]-pre1[p[m]]})<<'\n';
	}
}
```
### 完结撒花！感谢阅读！！！

---

## 作者：xiaosi4081 (赞：7)

## CSPS 模拟赛 - T1

由题知，我们可以进行三种操作：

1. 用 $a_i$ 的代价将区间 $[1,i]$ 全部设为 $0$
2. 用 $b_i$ 的代价将第 $i$ 设为 $0$
3. 用 $c_i$ 的代价将第 $i$ 设为 $1$

不难发现如果需要使用第一种操作的话，只需要使用一次且将其作为我们的第一个操作。因为如果后面还要使用第一种操作的话就相当于把我们在区间 $[1,i]$ 所做的其他操作浪费了。

所以我们可以很快的想出一种策略，对于任意的 $i \in [1,n]$ ，可以先使用操作 $1$ 将 $[1,i]$ 赋值为 $0$ ，如果其他位不满足要求再用第二种操作和第三种操作进行调整。维护可以采用后缀和的方式，再进行一些微调，时间复杂度约为 $O(qn)$ ，期望得分 $45$ 分。

那么如何优化呢？

我们可以发现，在两个相邻 $p$ 数组元素所形成的区间中，其所谓的“微调”不变，则我们可以处理出区间内最小的 $a_i+g_{i+1}$ ，式子中 $g$ 是后缀和数组，可以使用树状数组维护，时间复杂度约为 $O(n~log~n+\sum m)$ ，通过一些手段可以拿到满分，期望得分 $60 \sim 100 $ 分。

那么正解呢？

我们可以把上面的区间最小值改成前缀最小值，可以发现微调仍然合法且答案不会受到影响，所以我们就可以 AC 此题目，期望得分 $100$ 分。

代码如下：

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,m,ans,weitiao,p[500005],a[500005],b[500005],c[500005],g[500005],f[500005];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&c[i]);
	for(int i=n;i>=1;i--)g[i]=g[i+1]+b[i];
	f[0]=g[1];
	for(int i=1;i<=n;i++)f[i]=min(f[i-1],a[i]+g[i+1]);
	scanf("%lld",&q);
	while(q-->0){
		scanf("%lld",&m);ans=1e17,weitiao=0;
		for(int i=1;i<=m;i++)scanf("%lld",&p[i]),weitiao-=b[p[i]];
		for(int i=1;i<=m;i++)ans=min(ans,f[p[i]-1]+weitiao),weitiao+=b[p[i]]+c[p[i]];
		ans=min(ans,f[n]+weitiao);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：technopolis_2085 (赞：5)

比赛上通过祭。

题意很好理解，就不多说了。

先考虑前两个点的部分分。
容易发现要求让我们将数组元素全部设为 $0$。容易想到直接做一次 $a_n$ 的操作，但是这是不对的。

考虑动态规划。设 $clr_i$ 表示将前 $i$ 个元素全部设为 $0$ 的最小代价，分情况讨论：

第一种情况：直接使用 $a_i$。第二种情况：将第 $i$ 个元素单独设为 $0$，代价为 $clr_{i-1}+b_i$。取这两个数的较小值。

答案即为 $clr_n$。预期得分为 $10$。

然后考虑正解。

设 $dp_i$ 表示将集合内前 $i$ 个元素设为 $1$，其他元素设为 $0$ 的最小代价。

初始化：$dp_1$ 等于 $clr_{p_1-1}$ 和 $clr_{p_1}+c{p_1}$ 的较小值。意思为先将 $p_1$ 一以前（不含 $p_1$）的元素设为 $0$，和将 $p_1$ 及以前（含 $p_1$）的元素设为 $0$，再将 $p_1$ 设为 $1$。取这两者的最小值。其他的赋极大值。

转移：

也是分两种情况。第一种情况为从 $dp_{i-1}$ 转移过来，再将 $p_{i-1}+1$ 到 $p_i-1$ 这段所有元素设为 $0$的代价。用前缀和维护区间和。

第二种情况和初始化类似：将 $p_i$ 及以前所有元素都先设为 $0$，然后将 $p_1$ 到 $p_i$ 的所有元素设为 $1$，或者将 $p_i$ 以前（不含 $p_i$）所有元素设为 $0$，再将 $p_1$ 到 $p_{i-1}$ 都设为 $1$。取两者最小值。

最后别别忘了将 $p_m+1$ 到 $n$ 这一段所有元素设为 $0$，方法和前面类似。

记得开 long long，且初始化的极大值记得大一点。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=5e5+10;
int a[maxn],b[maxn],c[maxn];
int sumb[maxn],sumc[maxn]; 
int clr[maxn],dp[maxn];
int point[maxn];

signed main(){
//	freopen("reserve5.in","r",stdin);
	int n;
	scanf("%lld",&n);
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for (int i=1;i<=n;i++) scanf("%lld",&b[i]),sumb[i]=sumb[i-1]+b[i];
	for (int i=1;i<=n;i++) scanf("%lld",&c[i]);
	
	for (int i=1;i<=n;i++) clr[i]=1e18;
	for (int i=1;i<=n;i++) clr[i]=min(clr[i-1]+b[i],a[i]);
	clr[n+1]=clr[n]; 
	
//	for (int i=1;i<=n;i++) printf("@%lld ",clr[i]);
//	printf("\n");
	int q;
	scanf("%lld",&q);
	while (q--){
		int m;
		scanf("%lld",&m);
		for (int i=1;i<=m;i++){
			scanf("%lld",&point[i]);
			sumc[i]=sumc[i-1]+c[point[i]];
		}
		
		for (int i=1;i<=m;i++) dp[i]=1e18;
		dp[1]=min(clr[point[1]-1],clr[point[1]]+c[point[1]]);
		
		for (int i=2;i<=m;i++){
			dp[i]=min(dp[i],dp[i-1]+(sumb[point[i]-1]-sumb[point[i-1]]));
			dp[i]=min(dp[i],min(clr[point[i]-1]+sumc[i-1],clr[point[i]]+sumc[i]));
		}
		
		int ans=1e18;
		ans=min(ans,dp[m]+(sumb[n]-sumb[point[m]]));
		ans=min(ans,clr[n]+sumc[m]);
		if (point[m]==n) ans=min(ans,clr[n-1]+sumc[m-1]);
		
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Pengzt (赞：4)

[P9744](https://www.luogu.com.cn/problem/P9744)

因为给定的 $1$ 的个数是有限的，所以一定是枚举 $p_i$ 到 $p_{i+1}$ 的段进行更新。发现操作一最多只会执行一次，枚举在哪里执行操作一，然后对答案进行更新。因为 $p_i$ 前面的 $1$ 不管怎么都需要清 $0$，这部分代价可以单独计算。但是有可能是在 $j\in[p_i,p_{i+1})$ 进行的操作，所以还需要知道段内从那里分开比较优。

有一种简单解决方法就是直接预处理出 dp 数组 $g$ 表示前 $i$ 个数全部清零的最小代价，转移显然：$g_i=\min\{g_{i-1}+b_i,a_i\}$。这时候发现 $g$ 是段内所有点的取值的 $\min$。

但是赛时没有想到这个方法，用了一个麻烦一点的。考虑当 $i$ 是最优的时候，一定满足 $\arg \min_i a_i+\sum\limits_{j=i+1}^{r}b_i$。把后面做一个前缀和可以表示为 $a_i+s_r-s_i$ 最小，提出 $s_r$ 后就是求区间极值，随便用数据结构维护一下即可。

注意有可能最有决策在 $[p_m,n]$ 的范围内，加一个 $p_{m+1}=n+1$ 即可。注意 ST 表一开始会找到 $0$，所以预处理的 log2 数组要开到 $n+1$。

第二种实现的时空复杂度均为 $\mathcal{O}(n\log n+m)$。

代码：
```cpp
const int N=5e5+10,inf=1e9;const ll INF=1e18;
int n,m,Q;
int a[N],b[N],c[N],q[N],log_2[N];
ll st[20][N],s[N];
ll gmin(int l,int r){int k=log_2[r-l+1];return min(st[k][l],st[k][r-(1<<k)+1]);}
ll ans[N];
void solve(){
	q[0]=0;ll val1=0,res=INF,del=0;q[++m]=n+1;
	for(int i=1;i<=m;i++)del+=b[q[i]];
	for(int i=1;i<=m;val1+=c[q[i]],del-=b[q[i]],i++){
		int l=q[i-1],r=q[i]-1;
		res=min(res,gmin(l,r)+s[r]+val1+(s[n]-s[r]-del));
	}
	printf("%lld\n",res);
}
int main(){
	for(int i=0;i<20;i++)for(int j=0;j<N;j++)st[i][j]=inf;st[0][0]=0;
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read(),s[i]=s[i-1]+b[i],st[0][i]=a[i]-s[i];
	for(int i=1;i<=n;i++)c[i]=read();
	for(int i=2;i<=n+1;i++)log_2[i]=log_2[i>>1]+1;
	for(int i=1;i<20;i++)for(int j=0;j+(1<<i)-1<=n;j++)st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
	Q=read();
	for(int qi=1;qi<=Q;qi++){
		m=read();
		for(int i=1;i<=m;i++)q[i]=read();
		solve();
	}
	return 0;
}
```

---

## 作者：tder (赞：3)

[$\Large\color{black}\textbf{P9744 「KDOI-06-S」消除序列}$](https://www.luogu.com.cn/problem/P9744) $\Large\textbf{题解}$

[$\textbf{题目传送门}$](https://www.luogu.com.cn/problem/P9744)

[$\textbf{更好的阅读体验}$](https://www.luogu.com.cn/blog/tder/solution-P9744)

---

$$\large\textbf{思路}$$

对于在 $i$ 处执行的第 $1$ 种操作，不如在 $i-1$ 处执行一次操作 $1$，再在 $i$ 处执行一次操作 $2$，即 $a_i=\min(a_i,a_{i-1}+b_i)$。

接下来考虑每一次询问，有几种策略：

最朴素的：在 $n$ 处执行操作 $1$，使得所有值为 $0$，再依次在 $p_i$ 的下标处执行操作 $3$，使得对应位置变为 $1$，代价为 $a_n+\sum_{i\in P} c_{p_i}$。

以及：对于每一个 $p_i$，在第 $p_i-1$ 处执行操作 $1$，由于 $P$ 升序，可以依次在 $P$ 的 $1\sim i-1$ 项处执行操作 $3$，使得 $p_{i}-1$ 及其以前的序列 $v_1\sim v_{p_i}$ 都满足条件，单步代价 $a_{p_i-1}+\sum_{j=1}^{i-1}c_{p_j}$；由于 $v_{p_i}$ 本身即为 $1$，跳过即可；而后依次在 $(p_i+1)\sim n$ 中不在 $P$ 中的项执行一次操作 $2$。代价为：

$$a_{p_i-1}+\sum_{j=1}^{i-1}c_{p_j}+\sum_{j=p_i+1,j\not\in P}^n b_j=a_{p_i-1}+\sum_{j=1}^{i-1}c_{p_j}+\sum_{j=p_i+1}^n b_j-\sum_{j=p_i+1,j\in P}^n b_j$$

同时，在处理 $v_1\sim v_{p_i}$ 时也可以在 $p_i$ 处执行操作 $1$，并依次在 $P$ 的 $1\sim i$ 项处执行操作 $3$，单步代价为 $a_{p_i}+\sum_{j=1}^{i}c_{p_j}$。综合两种方案，对于每一个 $p_i$，总代价为：

$$\min(a_{p_i-1}+\sum_{j=1}^{i-1}c_{p_j},a_{p_i}+\sum_{j=1}^{i}c_{p_j})+\sum_{j=p_i+1}^n b_j-\sum_{j=p_i+1,j\in P}^n b_j$$

其中，$\sum b_i$、$\sum c_i$ 以及 $\sum b_{p_i}$ 都可以用前后缀预处理。

---

$$\large\textbf{代码}$$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e5 + 5, M = 1e9 + 7;
int n, a[N], b[N], c[N], fb[N], fc[N], fr[N], q, m, p[N];
signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i = 1; i <= n; i++) cin>>a[i];
	for(int i = 1; i <= n; i++) cin>>b[i];
	for(int i = 1; i <= n; i++) cin>>c[i];
	for(int i = n; i >= 1; i--) fb[i] = fb[i + 1] + b[i];
	for(int i = 1; i <= n; i++) a[i] = min(a[i], a[i - 1] + b[i]);
	cin>>q;
	while(q--) {
		cin>>m;
		for(int i = 1; i <= m; i++) {
			cin>>p[i];
			fc[i] = fc[i - 1] + c[p[i]];
		}
		fr[m + 1] = 0;
		for(int i = m; i >= 1; i--) fr[i] = fr[i + 1] + b[p[i]];
		int ans = a[n] + fc[m];
		for(int i = 1; i <= m; i++) 
			ans = min(ans, min(a[p[i] - 1] + fc[i - 1], a[p[i]] + fc[i]) + fb[p[i] + 1] - fr[i + 1]);
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Larryyu (赞：2)

## _Desciption_
给定一个长度为 $i$ 的序列 $v_1,v_2,\dots,v_n$，初始时所有元素的值都为 $1$。

对于下标 $i$ 有 $3$ 种操作：
- 将 $v_1,v_2,\dots,v_i$ 的值变为 $0$，费用是 $a_i$。
- 将 $v_i$ 的值变为 $0$，费用是 $b_i$。
- 将 $v_i$ 的值变为 $1$，费用是 $c_i$。

有 $q$ 次询问，每次询问给定一个大小为 $m$ 的集合 $P$，问最少需要多少费用，使得  $i\in P,v_i=1(1\le i\le n),j\notin P ,v_j=0(1\le j\le n)$。
## _Solution_
引理：在一次询问内，第一种操作最多只会进行一次。

设 $i,j(i<j)$ 分别进行了一次操作一。

如果先在 $j$ 进行操作一，就已经把 $v1,\dots ,vi$ 变为 $0$ 了，再操作是不优的。 

所以遍历每一个 $i$，发现在 $i$ 做操作一时，答案为 $a_i+\sum\limits_{j=i+1,j\notin P}^n b_j+\sum\limits_{j=1,j\in P}^{i} c_j$，这个式子可以用前缀和优化。

设 $sum1_i=\sum\limits_{j=1}^i b_j(1\le i\le n),sum2_i=\sum\limits_{j=1}^mb_{P_j}(1\le i\le m),sum3_i=\sum\limits_{j=1}^m c_{P-j}(1\le i\le m)$。

式子转换为 $a_i+sum1_n-sum1_i-(sum2_m-sum2_j)+sum3_j(P_j\le i,P_{j+1}>i)$。

此时时间复杂度为 $O(qn)$，需要进一步优化。

发现对于在 $P_i$ 和 $P_{i+1}$ 之间操作操作一（不含两端），$j$ 是相同的，所以我们只需预处理求出 $g_k=a_k+sum1_n-sum1_k$，再处理出区间内 $g$ 的最小值。可以用线段树或 ```ST``` 表维护。

此时对于 $i$，得出 $[P_i+1,P_{i+1}-1]$ 内 $g$ 的最小值再加上式子中其他的值即可，$[P_m+1,n]$ 也要计算。

还要计算刚好在 $i$ 上做操作一时的值，没有操作一时的值以及没有操作二时的值，所有可能答案取最小即可。

时间复杂度 $O(qm)$。
## _Code_
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long  //记得开long long
int n,q;
int a[500050],b[500050],c[500050];
int p[500050];
int lg[500050],st[500050][22];
int sum1[500050],sum2[500050],sum3[500050];
int get_st(int l,int r){
	if(l>r) return 100000000000;
	int len=lg[r-l+1];
	return min(st[l][len],st[r-(1<<(len))+1][len]);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;i++){
		lg[i]=lg[i>>1]+1;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		sum1[i]=sum1[i-1]+b[i];
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
		st[i][0]=sum1[n]-sum1[i]+a[i];  //得出g值
	}
	for(int j=1;j<=lg[n];j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);  //预处理ST表求区间内最小的g
		}
	}
	cin>>q;
	while(q--){
		int m;
		cin>>m;
		for(int i=1;i<=m;i++){
			cin>>p[i];
			sum2[i]=sum2[i-1]+b[p[i]];
			sum3[i]=sum3[i-1]+c[p[i]];
		}
		int ans=100000000000;  
		for(int i=1;i<=m;i++){
			ans=min(ans,min(get_st(p[i-1]+1,p[i]-1)-sum2[m]+sum2[i-1]+sum3[i-1],a[p[i]]+sum1[n]-sum1[p[i]]-(sum2[m]-sum2[i])+sum3[i]));  //min内第一个数是取区间，第二个数是刚好取pi
		}
		ans=min(ans,sum1[n]-sum2[m]);  //没有操作一
		ans=min(ans,get_st(p[m]+1,n)+sum3[m]);  //没有操作二
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：modfisher (赞：1)

## 思路
不难发现操作一最多用一次，而且必定在一开始就用掉。

先证明第一个操作一必须在一开始就用。假设你在进行若干轮操作二（显然只能是操作二，因为你不会闲着没事把变成 $0$ 的位置再变回 $1$）后再在第 $i$ 位上第一次用操作一。对于所有在第 $i$ 位后面的操作，你完全可以进行完这个操作一之后再用那些操作；对于所有在第 $i$ 位之前的操作，你还不如不做，交给这个操作一。所以，第一个操作一在一开始就用是最优的。

那么，是否存在一种情况：用完第一个操作一后，再用若干个其他操作，然后又用一个操作一呢？显然没有这个必要，如果在第二次操作一的区间内有 $1$，那么它要么是原本就有的，要么是操作三点出来的。如果是原本就有的，那就直接用这一次操作一替换掉第一次即可；如果是操作三点出来的，那相当于浪费了一次操作三，不优。总之，再用一次绝对是不赚的。

这样就证明了操作只分三步：

第一步，选择一个合适的 $i$，对第 $i$ 位使用操作一。

第二步，将所有 $i$ 之前的且应该为 $1$ 的位置用操作三变成 $1$。

第三步，将所有 $i$ 之后的且不应为 $1$ 的位置用操作二变成 $0$。

当第一步完成后，剩余步骤都是固定不变的。考虑枚举最优的 $i$。

显然无法枚举每一个 $v_i$，那只能枚举 $p_i$。枚举 $i$ 从 $0$ 到 $m$（此处设 $p_0=0$ 且 $p_{m+1}=n+1$），寻找 $p_i\leq x< p_{i+1}$，使得第一步选择 $x$ 时总代价最小。此时总代价应该是：

$$a_x+\sum_{j=x+1}^{n}b_j-\sum_{j=i+1}^{m}{b_{p_j}}+\sum_{j=1}^{i}c_{p_j}$$

发现其中前两项与 $i$ 无关，后两项与 $x$ 无关。考虑使用 ST 表维护前两项。则可以做到 $O(1)$ 查询 $x$。对于每一个 $i$ 的结果取最大值即可。复杂度 $O(n+\sum m)$。

注意 ST 表下标要从 $0$ 开始。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 5e5 + 5;
const ll INF = 9223372036854775807;

ll a[maxn], b[maxn], c[maxn], p[maxn], lg[maxn];
ll sumb[maxn], sumpc[maxn], sumpb[maxn], st[maxn][20];

ll getmin(int l, int r){
	int g = lg[r - l + 1];
	return min(st[l][g], st[r - (1 << g) + 1][g]);
}
ll read(){
	ll x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

int main(){
	int n = read();
	for(int i = 1; i <= n; i ++){
		a[i] = read();
		if(i > 1) lg[i] = lg[i / 2] + 1;
	}
	lg[n + 1] = lg[(n + 1) / 2] + 1;
	for(int i = 1; i <= n; i ++){
		b[i] = read();
	}
	for(int i = 1; i <= n; i ++){
		c[i] = read();
	}
	for(int i = n; i >= 1; i --){
		sumb[i] = sumb[i + 1] + b[i];
		st[i][0] = sumb[i + 1] + a[i];
	}
	st[0][0] = sumb[1];
	for(int j = 1; j <= lg[n]; j ++){
		for(int i = 0; i + (1 << j) - 1 <= n; i ++){
			st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
		}
	}
	int q = read();
	while(q --){
		int m = read();
		for(int i = 1; i <= m; i ++){
			p[i] = read();
			sumpc[i] = sumpc[i - 1] + c[p[i]];
		}
		p[m + 1] = n + 1;
		for(int i = m; i >= 1; i --){
			sumpb[i] = sumpb[i + 1] + b[p[i]];
		}
		ll ans = INF;
		for(int i = 0; i <= m; i ++){
			ans = min(ans, getmin(p[i], p[i + 1] - 1) - sumpb[i + 1] + sumpc[i]);
		}
		printf("%lld\n", ans);
		for(int i = 1; i <= m; i ++) sumpc[i] = sumpb[i] = 0;
	}
	return 0;
}
```


---

## 作者：binaryBard (赞：1)

更好的阅读体验点[这里](https://blog.jerryz.com.cn/article/solution-P9744/)

读题点[这里](https://www.luogu.com.cn/problem/P9744)

# 题目简述

给定一个长度为 $n$ 的序列 $v$，初始时，所有元素的值均为 $1$。有 $3$ 种操作可以作用在序列上：

1. 将 $v_1,v_2,\ldots,v_i$ 的值全部设为 $0$，操作的代价是 $a_i$；
2. 将 $v_i$ 的值设为 $0$，操作的代价是 $b_i$；
3. 将 $v_i$ 的值设为 $1$，操作的代价是 $c_i$。

现在有 $q$ 次询问，每次询问给定一个集合 $P$，要求将集合 $P$ 中的元素设为 $1$，其余位置的值设为 $0$，同时要求最小化所有操作的总代价。

## 思路概述

对于每个询问，我们需要找到一种操作序列，使得序列 $v$ 中下标位于集合 $P$ 的元素的值为 $1$，其余位置的值为 $0$，并且操作总代价最小。为了实现这个目标，我们可以使用动态规划的方法。

首先，我们定义两个数组 $f$ 和 $g$，其中 $f[i]$ 表示在第 $i$ 步操作结束时，序列 $v$ 中下标位于集合 $P$ 的元素的值为 $1$，其余位置的值为 $0$，且最后一个操作是将下标 $p_i$ 的元素设为 $1$ 的最小代价；$g[i]$ 表示在第 $i$ 步操作结束时，序列 $v$ 中下标位于集合 $P$ 的元素的值为 $1$，其余位置的值为 $0$，且最后一个操作是将下标 $p_i$ 的元素设为 $0$ 的最小代价。

接下来，我们可以使用动态规划的思想来计算 $f$ 和 $g$ 数组的值。具体来说，对于每个 $i$，我们可以通过以下两种方式来计算 $f[i]$ 和 $g[i]$：

1. 如果我们选择将下标 $p_i$ 的元素设为 $1$，则 $f[i]$ 的值为 $a[p_i-1]+g[i-1]$，表示在选择这个操作之前，我们已经将下标 $p_i-1$ 之前的元素设为 $1$，且最后一个操作是将下标 $p_{i-1}$ 的元素设为 $0$，此时我们需要将下标 $p_i$ 的元素设为 $1$，所以操作代价为 $a[p_i-1]$，再加上前 $i-1$ 步操作的最小代价 $g[i-1]$。
2. 如果我们选择将下标 $p_i$ 的元素设为 $0$，则 $f[i]$ 的值为 $f[i-1]+s[p_i-1]-s[p_{i-1}]$，表示在选择这个操作之前，我们已经将下标 $p_{i-1}$ 之前的元素设为 $1$，且最后一个操作是将下标 $p_{i-1}$ 的元素设为 $1$，此时我们需要将下标 $p_i$ 的元素设为 $0$，所以操作代价为 $s[p_i-1]-s[p_{i-1}]$，再加上前 $i-1$ 步操作的最小代价 $f[i-1]$。

根据上述思路，我们可以使用动态规划的方法计算出 $f[m]$ 和 $g[m]$ 的值，然后根据题目要求，输出 $g[m]+a[n]$ 和 $f[m]+s[n]-s[p[m]]$ 中的较小值作为第 $i$ 次询问的操作总代价的最小值。

## 算法步骤

对于每个询问，进行如下操作：

1. 读入集合 $P$ 的大小 $m$ 和元素值。
2. 使用动态规划的方法计算 $f[m]$ 和 $g[m]$ 的值：
    - 初始化 $f[0]=g[0]=0$。
    - 对于 $i$ 从 $1$ 到 $m$，依次计算 $f[i]$ 和 $g[i]$：
    - 如果选择将下标 $p_i$ 的元素设为 $1$，则 $f[i]=a[p_i-1]+g[i-1]$。
    - 如果选择将下标 $p_i$ 的元素设为 $0$，则 $f[i]=f[i-1]+s[p_i-1]-s[p_{i-1}]$。
    - $g[i]=g[i-1]+c[p_i]$。
3. 根据题目要求，输出 $g[m]+a[n]$ 和 $f[m]+s[n]-s[p[m]]$ 中的较小值作为第 $i$ 次询问的操作总代价的最小值。

**多测不清空，爆零两行泪。**

# 复杂度

时间复杂度为 $O(n+ \sum m)$。

# 代码

```C++
#include<bits/stdc++.h>
using namespace std;
#define N 500005
typedef long long ll;

ll a[N],b[N],c[N],n,q,m;
ll sum[N],p[N],s[N],f[N],g[N];

int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);
    }
    for(int i=1;i<=n;++i){
        scanf("%lld",&b[i]);
        s[i]=s[i-1]+b[i];
    }
    for(int i=1;i<=n;++i){
        scanf("%lld",&c[i]);
    }
    for(int i=1;i<=n;++i){
        a[i]=min(a[i],a[i-1]+b[i]);
    }
    scanf("%lld",&q);
    while(q--){
        scanf("%lld",&m);
        for(int i=1;i<=m;++i){
            scanf("%lld",&p[i]);
        }
        int ans=0;
        for(int i=1;i<=m;++i){
            f[i]=min(a[p[i]-1]+g[i-1],f[i-1]+s[p[i]-1]-s[p[i-1]]);
            g[i]=g[i-1]+c[p[i]];
        }
        printf("%lld\n",min(g[m]+a[n],f[m]+s[n]-s[p[m]]));
        for(int i=1;i<=m;++i) g[i]=f[i]=0;
    }
    return 0;
}

```

---

## 作者：ztntonny (赞：1)

## 思路

定义 $dp_i$ 表示对于子段 $[1,n]$，使其满足要求的最小代价。

先考虑依次枚举 $dp_i(i\in[1,n])$：
- 当第 $i$ 个为 $0$：考虑此处是否要执行操作一。若否，显然只需在 $dp_{i-1}$ 的基础上对  $i$ 执行操作二，总代价为 $dp_{i-1}+b_i$；若是，显然在 $[1,i)$ 中没有必要再执行任何操作一，故可以确定所有的 $1$ 都是由操作三创造的，且没有执行过操作二，总代价为 $a_i+\sum_{x_j=1,j\in[1,i)}^{}c_j$。
- 当第 $i$ 个为 $1$：考虑此处是否要执行操作一。若否，显然不需做任何操作，总代价为 $dp_{i-1}$；若是，同理，总代价为 $a_i+c_i+\sum_{x_j=1,j\in[1,i)}^{}c_j$。

于是就有了下面的代码。
```cpp
if ( x[i] == 0 )	dp[i] = min( dp[i - 1] + b[i] , a[i] + s1 );
if ( x[i] == 1 )	dp[i] = min( dp[i - 1] , a[i] + c[i] + s1 ) , s1 += c[i];
```

其中 $s1=\sum_{x_j=1,j\in[1,i)}^{}c_j$。

## 优化

这样复杂度 $\mathcal{O(n\times q)}$ 显然是不够的。我们注意到，全局输入的 $1$ 的位置个数不超过 $5\times 10^5$，故考虑根据每一个 $1$ 进行优化。

对于每一两个相邻的 $1$，其之间的所有数皆为 $0$，将他们共同考虑。

- 如果对这些 $0$ 中的一些执行了操作一，那么我们不难证明对于最优方案只可能执行了一次，就可以考虑执行方案一的位置。假设在第 $k$ 个数执行了方案一，两个一的位置分别为 $l,r$，那么总代价为 $a_k+\sum_{x_j=1,j\in[1,k)}^{}c_j+\sum_{j\in[k,r]}^{}b_j$，也可以转化为 $\sum_{x_j=1,j\in[1,l]}^{}c_j-\sum_{j\in(r,n]}^{}b_j+(a_k+\sum_{j\in[k,n]}^{}b_j)$。小括号中的式子可以设为 $p_k$，那么我们等价于求出 $\sum_{x_j=1,j\in[1,l]}^{}c_j-\sum_{j\in(r,n]}^{}b_j+\min_{k\in(l,r)}p_k$，可以用线段树优化求出。
- 如果对这些 $0$ 没有执行过操作一，那么这些 $0$ 都是由操作二变化而得的，且 $dp_l$ 是不动的，故总代价 $dp_l+\sum_{i\in(l,r)}^{}b_i$。

所以有代码：

```cpp
dp[r] = min( min_pk - bs[r] + s1 , dp[l] + bs[l + 1] - bs[r] );
```

其中 $s1=\sum_{x_j=1,j\in[1,l]}^{}c_j$，$min\_pk=\min_{k\in(l,r)}p_k$，$\{bs\}$ 为 $\{b\}$ 的后缀和数组。

完整代码（其中滚掉了 $dp$ 的一维）：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll n , a[500005] , b[500005] , c[500005] , q , m , x[500005] , bs[500005] , ans[5000005];

ll ls( ll x )
{
	return x * 2;
}

ll rs( ll x )
{
	return x * 2 + 1;
}

void push_up( ll x )
{
	ans[x] = min( ans[ls(x)] , ans[rs(x)] );
}

void build( ll x , ll l , ll r )
{
	if ( l == r )
	{
		ans[x] = a[l] + bs[l + 1];
		return;
	}
	ll mid = ( l + r ) / 2;
	build( ls( x ) , l , mid );
	build( rs( x ) , mid + 1 , r );
	push_up( x );
}

ll ask( ll al , ll ar , ll x , ll l , ll r )
{
	if ( al > ar )	return 1e18;
	ll s = 1e18;
	if ( al <= l && ar >= r )	return ans[x];
	ll mid = ( l + r ) / 2;
	if ( al <= mid )	s = min( ask( al , ar , ls(x) , l , mid ) , s );
	if ( ar > mid )	s = min( ask( al , ar , rs(x) , mid + 1 , r ) , s );
	return s;
}

int main()
{
	for ( int i = 0; i < 5000005; i++ )	ans[i] = 1e18;
	scanf( "%d" , &n );
	for ( int i = 1; i <= n; i++ )	scanf( "%d" , &a[i] );
	for ( int i = 1; i <= n; i++ )	scanf( "%d" , &b[i] );
	for ( int i = 1; i <= n; i++ )	scanf( "%d" , &c[i] );
	for ( int i = n; i >= 1; i-- )	bs[i] = bs[i + 1] + b[i];
	build( 1 , 1 , n );
	scanf( "%d" , &q );
	while ( q-- )
	{
		scanf( "%d" , &m );
		ll s1 = 0 , dp = 0;
		x[0] = 0;
		x[m + 1] = n + 1;
		for ( int i = 1; i <= m; i++ )	scanf( "%d" , &x[i] );
		for ( int i = 1; i <= m + 1; i++ )
		{
			dp = min( ask( max( x[i - 1] , 1ll ) , x[i] - 1 , 1 , 1 , n ) - bs[x[i]] + s1 , dp + bs[x[i - 1] + 1] - bs[x[i]] );
			s1 += c[x[i]];
		}
		printf( "%lld\n" , dp );
	}
	return 0;
}
```

---

## 作者：CQ_Bab (赞：1)

# 前言
本来可以赛时 AC 的结果由于少判断了一种条件而错在了 $3$ 和 $4$ 这两个点，但是还是要说一声 @As_snow 太强了。
# 思路
我们发现对于一次查询，第一种操作最多使用一次，然后我们对于在第 $i$ 个点使用操作一的代价是 $lc_{i}+a_i+sumb_{i+1}-re_{i+1}$ 这里我们的 $lc_i$ 代表在 $1\sim i$ 中在且属于 $p$ 集合的位置的 $c$ 数组之和，然后 $sumb_{i}$ 代表 $\sum_{j=i}^{n} b_j$ 然后 $re_i$ 代表在 $i\sim n$ 中属于 $p$ 集合的 $b_j$ 之和，这个写出来会发现是 $n^2$ 的。

那么我们来想如何优化，我们可以发现对于每一次选择只会出现两种情况。

- 取的 $i$ 不属于 $p$ 集合。
- 取的 $i$ 属于 $p$ 集合。

这里我们可以发现如果是第二种情况可以直接求出，那么我们只需要处理第一种情况，然后我们可以发现对于在 $p_i+1 \sim p_{i+1}-1$ 之间的数的 $lc_i$ 和 $re_i$ 的值是不会变的那么我们的第一种情况只需要求出 $a_i+sumb_{i+1}$ 的最小值即可，这里我们可以用线段树维护。

但是这里还有三种特殊情况需要特殊处理。

- 没有用到第一种操作，最小值为 $sumb_1-re_1$。
- 使用第一个操作的位置在 $p_1$ 之前，这里的最小值为 $Min_{1,p_1-1}-g_1$ 这里的 $Min_{i,j}$ 就是 $i\sim j$ 中 $a_i+sum_{i+1}$ 的最小值。
- 使用第一个操作在 $p_cnt$ 之后，这里的处理方式也和上一种像似，就不细讲了。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define i12 __int128
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rep1(i,x,y) for(int i=x;i>=y;i--)
#define fire signed
int n,q;
const int N=5e5+10;
int a[N],b[N],c[N];
i12 g[N];
int in[N];
i12 sum[N];
struct node {
	int l,r;
	i12 Min;
} tr[N<<2];
void up(int x) {
	tr[x].Min=min(tr[x*2].Min,tr[x*2+1].Min);
}
void build(int u,int l,int r) {
	tr[u]= {l,r};
	if(l==r) {
		tr[u].Min=a[l]+sum[l+1];
		return ;
	}
	int mid=l+r>>1;
	build(u*2,l,mid);
	build(u*2+1,mid+1,r);
	up(u);
}
int Ans(int u,int l,int r) {
	if(tr[u].l>=l&&tr[u].r<=r) {
		return tr[u].Min;
	}
	int mid=tr[u].l+tr[u].r>>1,res=LONG_LONG_MAX;
	if(mid>=l) res=min(res,Ans(u*2,l,r));
	if(mid<r) res=min(res,Ans(u*2+1,l,r));
	return res;
}
void print(int x) {
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
fire main() {
//	freopen("s.out","r",stdin);
//	freopen("s.in","w",stdout);
	scanf("%lld",&n);
	rep(i,1,n) scanf("%lld",&a[i]);
	rep(i,1,n) scanf("%lld",&b[i]);
	rep(i,1,n) scanf("%lld",&c[i]);
	rep1(i,n,1) sum[i]=sum[i+1]+b[i];
	build(1,1,n);
	i12 ans=LONG_LONG_MAX;
	rep(i,1,n) ans=min(ans,a[i]+sum[i+1]);
	scanf("%lld",&q);
	while(q--) {
		int cnt=false;
		scanf("%lld",&cnt);
		if(!cnt) {
			print(ans);
			cout<<endl;
			continue;
		}
		rep(j,1,cnt) scanf("%lld",&in[j]);
		g[cnt+1]=false;
		rep1(i,cnt,1) g[i]=g[i+1]+b[in[i]];
		i12 res=LONG_LONG_MAX,now=0;
		if(cnt==n) {
			cout<<"0\n";
			continue;
		}
		res=Ans(1,1,in[1]-1)-g[1];
		res=min(res,sum[1]-g[1]);
		rep(i,1,cnt) {
			res=min(res,now+Ans(1,in[i-1]+1,in[i]-1)-g[i]);
			now+=c[in[i]];
			res=min(res,now+a[in[i]]+sum[in[i]+1]-g[i+1]);
		}
		res=min(res,now+Ans(1,in[cnt]+1,n));
		print(res);
		cout<<endl;
	}
	return false;
}
/*
7
10 1 6 9 4 2 4
0 5 2 3 0 1 4
4 1 4 1 5 3 5
1
2 2 6
*/
```

---

## 作者：zct_sky (赞：1)

### Solution
-----
菜鸡不会 DP，也不会 ST 表，赛时打了个贪心，~~居然过了（）~~

对于 $\forall 1 < i \le m$，考虑假设 $[1,p_{i-1}]$ 已经符合要求（即 $1 \dots p_{i-1}$ 中，$\forall 1 \le j \le p_{i-1}$，若 $j \in P$，则 $v_j = 1$，否则 $v_j = 0$），然后考虑进行操作。

为了使 $i$ 的范围拓展至 $[1,m]$，我们可以定义 $p_0 = 0$（显然 $[0,1)$ 一开始就符合要求）；为了保证 $[p_m+1,n]$ 均为 $0$，定义 $p_{m+1}=n+1$。

然后，经过一番观察后，我们可以得出每个 $p_i$ 有且仅有两种操作方式：

1. 将 $[1,p_i-1]$ 全部覆盖为 $0$，并将 $\forall 1\le j < i$ 的 $v_{p_j}$ 单独改成 $1$。
2. 将 $[p_{i-1}+1,p_i-1]$ 单独改为 $0$。

然后我们设 $sumb$ 为 $[1,p_{i-1}]$ 中**已经**单独改为 $0$ 的总费用， $sumc$ 为 $[1,p_{i-1}]$ 中**尚未**单独改为 $1$ 的总费用，$lst$ 为上一次执行 1 操作的位置，$ans$ 为 $[1,p_{i-1}]$ 均符合要求的最小花费。

则操作 1 的花费为 $ans+a_{r-1}+sumc-sumb-a_{lst-1}$，操作 2 的花费为 $ans+\sum\limits_{j=p_{i-1}}^{p_i} b_j$。

显然取其中的较小值即可。

最后再处理一下每个操作需要更新的值。

若在 $p_i$ 实行操作 1，则 $sumc=c_{p_i},sumb=0,lst=p_i$；若在 $p_i$ 实行操作 2，则 $sumc$ 需要加上 $c_{p_i}$，$sumb$ 需要加上 $\sum\limits_{j=p_{i-1}}^{p_i} b_j$。

还有几个小细节：

- 为了防止计算 $\sum\limits_{j=p_{i-1}}^{p_i} b_j$ 超时，需要 $b$ 数组的前缀和数组。
- 输入所给的 $a$ 数组不一定是将 $[1,i]$ 置为 $0$ 的最小花费，需要根据 $b$ 进行更新。递推式为 $a_i = \min\{a_i,a_{i-1}+b_i\}$。

时间复杂度 $\mathcal{O}(n+\sum m)$。
### Code
-----
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return x*y;
}
const int N=5e5+7;
ll sum[N],a[N],b[N],c[N],n,q,m,sc,sb,lst,ans;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=n;i++){
		b[i]=read();
		sum[i]=sum[i-1]+b[i];
		a[i]=min(a[i-1]+b[i],a[i]);
	}
	for(int i=1;i<=n;i++){
		c[i]=read();
	}
	q=read();
	while(q--){
		m=read()+1;
		ll l=0,r;
		ans=0;sc=0;sb=0;lst=1;
		while(m--){
			r=(m==0)?n+1:read();
			ll t1=ans+a[r-1]+sc-sb-a[lst-1],t2=ans+sum[r-1]-sum[l];
			if(t1<=t2){
				ans=t1;
				sc=c[r];
				sb=0;
				lst=r;
			}else{
				ans=t2;
				sc+=c[r];
				sb+=sum[r-1]-sum[l];
			}
			l=r;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：happy_zero (赞：0)

dp 题。下文把在集合 $P$ 中的点称为目标点，$pos_i$ 表示第 $i$ 个目标点的位置。

记 $d_i$ 表示把前 $i$ 个数消为 $0$ 的最小花费，$f_i$ 表示把前 $pos_i$ 个点从 $1$ 变成目标状态、$g_i$ 表示从 $0$ 变成目标状态的最小代价。$d_i$ 的转移很显然：直接变成 $0$；先将前 $i-1$ 个点变成 $0$，再将第 $i$ 个点变成 $0$。转移方程：$d_i=\min(a_i,d_{i-1}+b_i)$。

接下来考虑 $f$ 与 $g$ 的转移。还是先挑简单的说：$g_i$ 的转移就只有一种，就是把在此之前所有的目标点变为 $1$ 的代价和，写成递推式就是 $g_{i}=g_{i-1}+c_{pos_i}$，准确来说，这其实就是一个前缀和。

难的在于 $f$。一共分三种情况：

- 先把前 $pos_i$ 个点都变成 $0$，然后再把所有目标点变成 $1$，第一个操作代价为 $d_{pos_i}$，第二个则为 $g_i$；

- 把前 $pos_i-1$ 个点变为 $0$，再把 $i$ 之前的所有目标点变成 $1$，第一个操作代价为 $d_{pos_i-1}$，第二个为 $g_{i-1}$；

- 先把前 $pos_{i-1}$ 个点变为目标状态，再把 $[pos_{i-1}+1,pos_i-1]$ 中的所有点变为 $0$（因为它们的目标状态就是 $0$），第一个代价为 $f_{i-1}$，第二个为 $\sum_{j=pos_i+1}^{pos_i-1}b_j$。

总转移方程：

$$f_i=\min\{d_{pos_i}+g_i,d_{pos_i-1}+g_{i-1},f_{i-1}+\sum_{j=pos_i+1}^{pos_i-1}b_j\}$$

整体的思路说完了，还有一些小细节：

1. 具体实现中 $a$ 和 $d$ 可以合并为一个数组；

1. 上述最后一种情况的第二个代价可以预处理前缀和；

1. 答案不是最后一个目标点，因为后面的所有点还得变为 $0$，可以把第 $n+1$ 个位置也看成一个目标点来处理，这是需要注意 $d_{n+1}=d_n$；

1. 答案可能会超过 int 范围。

时间复杂度 $O(\sum m)$。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e5 + 5;
const int INF = 1e18;
inline int read() {
    int w = 1, q = 0; char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
    return w * q;
}
int a[N], b[N], c[N], g[N], s[N], f[N], pos[N];
signed main() {
	int n = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= n; i++) 
		b[i] = read(), s[i] = s[i - 1] + b[i];
	for (int i = 1; i <= n; i++) c[i] = read();
	for (int i = 1; i <= n; i++)
		a[i] = min(a[i], a[i - 1] + b[i]); 
	int q = read(); a[n + 1] = a[n];
	while (q--) {
		int m = read(); pos[m + 1] = n + 1;
		for (int i = 1; i <= m + 1; i++) {
			if (i <= m) pos[i] = read();
			g[i] = g[i - 1] + c[pos[i]];
			f[i] = min({a[pos[i]] + g[i], f[i - 1] + s[pos[i] - 1] - s[pos[i - 1]], a[pos[i] - 1] + g[i - 1]});
		}
		cout << f[m + 1] << "\n";
	}
	return 0;
}
```

---

## 作者：Mirasycle (赞：0)

### 前言：
今早看到官方出了一个激励计划并且发布了一个月赛官方题单，由于之前没打过月赛，想体验体验题目，于是就顺着题单看到了十到十二月份的月赛题，准备写一下绿题及以上，目前写完三道绿题发现质量还挺高的。本题思路和其他题解都不太一样故记录一下。

### 题解：
思路还是非常快的，大概几分钟想到的正解。看到最优解想到动态规划 ，由于后面操作会改变前面，于是 **倒序dp** ，并记录当前操作对后续影响 $k$ 。如果直接每次每个位置都计算一遍复杂度太大。观察到题目中的 $\sum{m}$ 可以在每次询问的时候均摊且题目中无关点不需要转移，于是就像虚树一样只需在关键点转移即可。设计状态 $dp(i,k)$ 表示已经处理完了第 $p(i)$ 至第 $n$ 位，前 $p(i)-1$ 位的值为 $k$ , 此时的最下代价。列出方程

$dp_{i,0}=\min(dp_{i+1,0}+c_{p(i)},dp_{i+1,1}+a_{p_{i}-1}+cost)$

$dp(i,1)=dp(i+1,1)+cost$ 

其中 $cost$ 为将第 $p(i)+1$ 至 $p(i+1)-1$ 全部变为 $0$ 的代价，前缀和计算即可。

注意本题坑点，题目中给出的操作 $a_{i}$ 未必是最优的，需要更新。

即 $a_{i}=\min(a_{i-1}+b_{i},a_{i})$

下面给出代码

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=5e5+10;
const long long inf=0x3f3f3f3f;
int a[maxn],b[maxn],c[maxn],p[maxn];
long long dp[maxn][2],prec[maxn],preb[maxn],ans;
int main(){
	int n; cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];//前缀设置0 
	for(int i=1;i<=n;i++) cin>>b[i];//设0 
	for(int i=1;i<=n;i++) cin>>c[i];//设1
	for(int i=1;i<=n;i++) a[i]=min(a[i],a[i-1]+b[i]);
	for(int i=1;i<=n;i++) prec[i]=prec[i-1]+c[i];
	for(int i=1;i<=n;i++) preb[i]=preb[i-1]+b[i];
	int q; cin>>q;
	while(q--){
		int m; cin>>m;
		for(int i=1;i<=m;i++) cin>>p[i];
		//dp[i][k] 第p[i]到n位已经完成，且1-(p[i]-1)位置值为k
		dp[m+1][0]=a[n]; dp[m+1][1]=0; p[m+1]=n+1;
		for(int i=m;i>=1;i--){
			long long cost=min(preb[p[i+1]-1]-preb[p[i]],a[p[i+1]-1]+prec[p[i]]);//将中间一段设置为0的代价 
			dp[i][0]=min(dp[i+1][0]+c[p[i]],dp[i+1][1]+a[p[i]-1]+cost);
			dp[i][1]=dp[i+1][1]+cost;
		}
		ans=inf;
		if(p[1]==1) ans=min(dp[1][0],dp[1][1]);
		else ans=dp[1][0];
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：_JF_ (赞：0)

[P9744 「KDOI-06-S」消除序列 ](https://www.luogu.com.cn/problem/P9744)

比较优秀的一个题，也是难得可以算是场切绿的题。

首先你可以观察到如果你把一个序列都消成 $0$ 的话，那么必然是选择一个位置使用 $a$，剩下的位置**仅可以用** $b$，然后枚举选的位置得到最值，这是一个重要的观察。

原因显然，重复使用两个 $a$ 必然不优。

在这个基础上你就可以知道，对于每一次询问，你只用把使用 $a$ 覆盖后误删的位置（也就是需要保留 $1$ 的位置）用 $c$ 还原回去，当前位置往后的如果是要求保留的，那么不使用 $b$ 即可。这个用个前缀和随便搞搞就行，是 $O(qn)$ 的。

考虑优化，观察到 $\sum m$ 和 $n$ 同阶，从它去入手。观察相邻两个要保留 $1$ 的位置之间怎么样快速计算出来答案。

对于相邻两个要保留 $1$ 的两个位置之间，**注意这两个位置之间的都要变成 $0$。** 他们在使用了一次 $a$ 以后，需要把误删的点 $c$ 加回去，这个值是固定的。然后发现在使用 $b$ 的时候，不需要使用 $b$ 的值也是固定的（也就是需要保留 $1$ 的位置）。

那么对于使用 $b$ 的，我们只用需要用倘若从当前位置往后都使用 $b$，减去需要保留 $1$ 位置的 $b$，就是后面的答案。

综合上面两个，我们可以在遍历相邻两个位置获得需要还原 $c$ 的答案，以及需要保留 $b$ 的答案。（这里的 $b$ 指的是该位置需要保留的 $b$ 值和，也就是误删的）只用保证中间位置的 $a+b$ （这里的 $b$ 指倘若从当前点往后都使用 $b$ 消去，无论是否保留），显然用个数据结构维护最小值即可。

其实重点就在这个完整的思考过程，感觉还是挺好的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
#define int long long 
int a[N],sum[N],b[N],c[N],sum0,sum1,sum2,p[N],Log[N],f[N][21];
bool vis[N];
int Query(int l,int r){
	int k=Log[r-l+1];
	return min(f[l][k],f[r-(1<<k)+1][k]);
}
signed main()
{
//	freopen("reserve4.in","r",stdin);
//	freopen("ans.out","w",stdout);
	memset(f,0x3f,sizeof(f));
	int n,q;
	cin>>n;
	for(int i=1;i<=n;i++)	scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)	scanf("%lld",&b[i]);
	for(int i=1;i<=n;i++)	scanf("%lld",&c[i]);
	for(int i=n;i>=1;i--)	sum[i]=sum[i+1]+b[i],f[i][0]=a[i]+sum[i+1],sum2+=b[i];
	for(int i=2;i<=n;i++)	Log[i]=Log[i>>1]+1;
	for(int j=1;j<=Log[n];j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			f[i][j]=min(f[i-1][j],f[i+(1<<(j-1))][j-1]);
	cin>>q;
	int lst=sum2;
	while(q--){
		sum2=lst;
		sum0=0,sum1=0;
		int ans=LONG_LONG_MAX;
		int m;
		cin>>m;
		for(int i=1;i<=m;i++)	scanf("%lld",&p[i]),sum0+=b[p[i]],sum2-=b[p[i]];
		if(m==n)	{cout<<0<<endl;continue;}
		if(m==0)	{cout<<Query(1,n)<<endl;continue;}
		int now=sum0;
		for(int i=1;i<m;i++){
			sum1+=c[p[i]];
			sum0-=b[p[i]];
			ans=min(ans,sum1+Query(p[i],p[i+1]-1)-sum0);
		}
		sum1+=c[p[m]];
		ans=min(ans,min(Query(1,p[1]-1)-now,sum1+Query(p[m],n)));
		ans=min(ans,sum2);
		printf("%lld\n",ans);
	}
	return 0;
}
// lst time text all.
```


---

## 作者：operator_ (赞：0)

# P9744 「KDOI-06-S」消除序列

[题目传送门](https://www.luogu.com.cn/problem/P9744)

## 题解

~~记错时间错过模拟赛的 sb 来也。~~

题目中的最关键信息就是 $a_i,b_i,c_i\ge 0$，这意味着多做无用的操作一定不优，所以有：

+ 结论 $1$：优先进行 $1$ 操作。

这是因为我们不管我们在 $1$ 操作前做什么操作都会被其推平覆盖，是无用操作。

+ 结论 $2$：最多只进行一次 $1$ 操作。

也是显然的，我们一定会保留范围最广的一次 $1$ 操作，这样其他 $1$ 操作都是无用操作。

到这里，一个显然的想法就出现了：枚举 $1$ 操作的 $i$，并通过前后缀和快速计算其他操作的最小代价。

然而这会是 $O(nq)$ 的，难以通过。

观察数据范围里出现了一个神奇的东西：$\sum m$，所以我们的目标是推出一个单次询问复杂度带 $m$ 的算法。 

然后我们开始小小的推一波式子：设 $1$ 操作的位置 $i$ 满足 $p_j\le i<p_{j+1}$，那么易知此时的代价为 $a_i+\sum_{k=i+1}^n b_k+\sum_{k=1}^j c_{p_k}-\sum_{k=j+1}^m b_{p_k}$。

对于同样的 $j$，后面的 $\sum_{k=1}^j c_{p_k}-\sum_{k=j+1}^m b_{p_k}$ 贡献一定，所以我们只要快速求出区间中前两项的最小值，刚好，前两项只与 $i$ 有关，所以我们可以使用 ST 表或线段树来解决。

最后再考虑一下不使用 $1$ 操作的情况即可。

复杂度 $O(\sum m\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
int n,q,a[500005],b[500005],c[500005];
int p[500005],prec[500005],sufb[500005];
struct Sparse_Table {
	int st[500005][25];
	void init(int n,int v[]) {
		memset(st,0x3f,sizeof(st));
		for(int i=1;i<=n;i++) st[i][0]=v[i];
		for(int j=1;(1<<j)<=n;j++)
			for(int i=1;i+(1<<j)-1<=n;i++)
				st[i][j]=min(st[i][j-1],st[i+(1<<j-1)][j-1]);
	}
	int query(int l,int r) {
		if(l>r) return INT_MAX;
	    int k=log2(r-l+1);
	    return min(st[l][k],st[r-(1<<k)+1][k]);
	}
} st;//ST 表
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		b[i]=read();
	for(int i=1;i<=n;i++)
		c[i]=read();
	int sum=0;
	for(int i=n;i;i--)
		a[i]+=sum,sum+=b[i];
	st.init(n,a);
	cin>>q;
	while(q--) {
		int m=read();
		for(int i=1;i<=m;i++) 
			p[i]=read();
		prec[0]=sufb[m+1]=0;
		for(int i=1;i<=m;i++)
			prec[i]=prec[i-1]+c[p[i]];
		for(int i=m;i;i--)
			sufb[i]=sufb[i+1]+b[p[i]];
		int ans=sum-sufb[1];//不使用 1 操作
		ans=min(ans,st.query(1,p[1]-1)-sufb[1]);//第一段
		for(int i=1;i<m;i++) 
			ans=min(ans,st.query(p[i],p[i+1]-1)+prec[i]-sufb[i+1]);
		ans=min(ans,st.query(p[m],n)+prec[m]);//最后一段
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Light_az (赞：0)



将题目每一种操作单独提出来讨论：

对于第一种操作来说，它只会进行一次或者不进行，因为当操作次数大于 $1$ 时，只需要进行下标 $i$ 最大的操作就可以覆盖其它的第一种操作。

对于第二，三种操作，设第一次操作的下标是 $i$，那么此时 $v_1 \sim v_i$ 都是 $0$,$v_{i+1} \sim v_n$ 都是 $1$，分类讨论：

- 如果集合 $P$ 内的数字在 $i$ 后面，因为 $i$ 后面的数都是 $1$，不需要进行操作。

- 如果非集合 $P$ 内的数字在 $i$ 后面，我们需要将它变成 $0$，因此需要进行第二种操作。

- 如果非集合 $P$ 内的数字在 $i$ 前面，因为 $i$ 前面的数都是 $0$，因此不需要进行操作。

- 如果集合 $P$ 内的数字在 $i$ 前面，我们需要将它变成 $1$，因此需要进行第三种操作。

我们可以直接枚举下标 $i$ 的位置，对于不进行第一种操作的情况，我们下标 $i=0$ 即可，然后每次判断有多少个集合内，非集合内的数字在 $i$ 的前面，后面，只需要 $O(1)$ 可以得出答案，枚举每个位置需要 $O(n)$，总时间复杂度 $O(q  n)$，期望得分 $60$，核心代码如下：

```cpp
	F(i,1,k) cin>>x,b[x]=1;//标记在集合内
	F(i,1,n) if(!b[i]) sum+=v[i].b;//非集合内的数字一开始在 0 后面的代价
	F(i,0,n){
		if(b[i]==1) cnt+=v[i].c;//集合内的数字在 i 前面，需要进行第三种操作
		else sum-=v[i].b;//非集合内的数字在 i 前面，不需要操作，减去贡献
		ans=min(ans,cnt+v[i].a+sum);//三种操作的总和取最小值
	}
    
```

然后开始考虑优化，设 $dp_i$ 表示在下标为 $i$ 的位置进行第一种操作的最小代价，假设一开始的 $P$ 是空集合，若添加一个数字 $x$ 于集合中,此时对于 $dp_1 \sim dp_{x-1}$，$x$ 是在它们的后面，上文提到：

`如果集合 P 内的数字在 i 后面，因为 i 后面的数都是 1，不需要进行操作。`

所以 $dp_1 \sim dp_{x-1}$ 都可以减少第二种操作，因为 $x$ 不需要赋值为 $0$。

对于 $dp_x \sim dp_n$ 来说，上文提到：

`如果集合 P 内的数字在 i 前面，我们需要将它变成 1，因此需要进行第三种操作。`

所以 $dp_x \sim dp_n$ 都需要添加第三种操作，因为 $x$ 要赋值为 $1$。

如果此时集合 $P$ 减少了一个数 $x$，显然结论恰好相反，略说明。

结合区间修改，区间查询最小值等操作，联想到使用线段树加上二分判断集合内添加减少操作，略微卡常数即可完成，细节说明在代码中：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(ll i=j;i<=n;i++)
#define ps push_back
#define sz(x) ((ll)x.size())
#define mem(f,x) memset(f,x,sizeof(f))
#define all(x) x.begin(),x.end()
#define lc id*2
#define rc id*2+1
#define V vector<int>
#define Test ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
const int N=7e6+10;
ll n,m,k,x,y,u,w,cnt,ans,t,l,r,len,T,id,now;
ll mn=INT_MAX,mx=0,p,opt;
char ch;
struct Node{
	int a,b,c;
}v[N];
ll a[N],b[N],dp[N],sum;
ll tr[N];
ll Q[N];
void pushdown(ll id,ll l,ll r){//维护最小值线段树
	if(Q[id]){
		tr[id*2]+=Q[id];
		tr[id*2+1]+=Q[id];
		Q[id*2]+=Q[id];
		Q[id*2+1]+=Q[id];
		Q[id]=0;
	}
}
void build(ll id,ll l,ll r){
	if(l==r){
		tr[id]=a[l];
		return ;
	}
	ll mid=(l+r)/2;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);
	tr[id]=min(tr[id*2],tr[id*2+1]);
}
void update(ll id,ll x,ll y,ll l,ll r,ll k){
	if(l>y||r<x) return ;
	if(l>=x&&r<=y){
		tr[id]+=k;
		Q[id]+=k;
		return ;
	}
	pushdown(id,l,r);
	ll mid=(l+r)/2;
	if(x<=mid) update(id*2,x,y,l,mid,k);
	if(y>mid) update(id*2+1,x,y,mid+1,r,k);
	tr[id]=min(tr[id*2],tr[id*2+1]);
}
ll query(ll id,ll x,ll y,ll l,ll r){
	if(l>y||r<x) return 1e18;
	if(l>=x&&r<=y) return tr[id];
	pushdown(id,l,r);
 	ll mid=(l+r)/2;
 	ll ans=1e18;
 	if(x<=mid) ans=min(ans,query(id*2,x,y,l,mid));
 	if(y>mid) ans=min(ans,query(id*2+1,x,y,mid+1,r));
	return ans;
}
ll find(ll k,V a){
	ll l=0,r=sz(a)-1;
	while(l<=r){
		ll mid=(l+r)/2;
		if(a[mid]==k) return 1;
		else if(a[mid]>k) r=mid-1;
		else l=mid+1;
	}
	return 0;
}
V num[500005];
int main(){
    Test;
	cin>>n;
	F(i,1,n) cin>>v[i].a;//三种操作
	F(i,1,n) cin>>v[i].b,sum+=v[i].b;//空集时，数字 x 全部在 i 后面
	F(i,1,n) cin>>v[i].c;
	cnt=0;
  	//空集时的答案
	F(i,0,n){//i=0即为不进行第一种操作
		if(b[i]==1) cnt+=v[i].c;
		else sum-=v[i].b;
		a[i+1]=cnt+v[i].a+sum;//方便建树，下标+1
	}
	build(1,1,n+1);//建树
	cin>>T;
	F(dd,1,T){
		cin>>k;
		F(i,1,k){
			cin>>x;
			num[dd].ps(x);
			if(!find(x,num[dd-1])){//查找集合添加的数字
				update(1,1,x,1,n+1,-v[x].b);//减少第二种操作
				update(1,x+1,n+1,1,n+1,v[x].c);//添加第三次操作
			} 
		} 
		F(i,0,sz(num[dd-1])-1) if(!find(num[dd-1][i],num[dd])){//查找集合减少的数字
			ll x=num[dd-1][i];
			update(1,1,x,1,n+1,v[x].b);//结论相反
			update(1,x+1,n+1,1,n+1,-v[x].c);
		} 
		cout<<query(1,1,n+1,1,n+1)<<"\n";//查找最值
	}
	return 0;
}
```

## 据说考前写题解可以 RP++。

## 最后祝各位 2023 CSP RP++。

---

## 作者：Nwayy (赞：0)

S 模拟赛的 A 题，本来可以切的但是 $\log$ 没有处理到 $n+1$ 被卡了 #2。

---

#### **sol about test $1-11$：**

对于这一部分我们考虑 $O(nq)$ 怎么做。

首先容易想到操作 1 使用次数不超过 $1$，由于值域非负，假设你在 $i$ 和 $j$ 分别使用操作 1，那你还不如直接在 $j$ 用一次。

因此我们可以枚举用操作 1 的位置，假设当前枚举到 $i$，那么我们同时动态维护一个指针 $j$ 表示 $p$ 中 $p_{j} \le i$ 并且 $p_{j+1} > i$，那么 $p$ 中前 $j$ 个数需要再用操作 3 变回 $1$。对于 $k \in [j+1,m]$ 的 $p_{k}$，我们需要用操作 2 来变成 0。

当然，操作 2 的代价不能暴力统计，因此我们可以预处理 $b$ 数组的后缀和 $s$，对于每次询问我们对 $p$ 数组再求 $b$ 的后缀和 $mp$，则 $s_{i+1}-mp_{j+1}$ 来得到 操作 2 的代价。

代码：

```cpp
for(i=n;i>=1;i--) Q[i]=Q[i+1]+b[i]; //i-n变成0的代价 
	scanf("%lld",&q);
	while(q--){
		scanf("%lld",&m),l=0,ans=1e18;
		for(i=1;i<=m;i++) scanf("%lld",&p[i]);
		sort(p+1,p+1+m),mp[m+1]=0;
		for(i=m;i>=1;i--) mp[i]=mp[i+1]+b[p[i]];
		int k,s=0;
		for(i=0,j=0;i<=n;i++,j++){
			k=a[i];
			if(p[l+1]==i && l<m) l++,s+=c[i];
			ans=min(ans,k+s+Q[i+1]-mp[l+1]);
		}
		printf("%lld\n",ans);
	}
```



预期 $55$ pts，但是实际有 $70$ pts。

#### **sol about test $1-20$：**

我们观察 ```ans=min(ans,k+s+Q[i+1]-mp[l+1])```，发现当 $i \in [p_{j},p_{j+1}-1]$ 时 $mp_{l+1}$ 和 $s$ 相同，变化的仅有 $k$ 和 $Q_{i+1}$，由于答案要求最小值，那么考虑建立 ST 表维护区间 $a_{i}+Q_{i+1}$ 的最小值，$i$ 不断跳向下一个 $p_{j}$，这样我们做到了单次询问复杂度为 $O(m)$，总时间复杂度降为 $O(n \log n+ \sum m)$。

注意，你预处理 $Log$ 数组记得算到 $n+1$，否则当 $m=0$ 的时候会寄。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500005
#define int long long
int n,m,i,j,ans,a[N],b[N],c[N],q,p[N],u[N],l,Q[N],mp[N],cnt,qq;
int f[N][25],g[N],Log[N];
int qry(int l,int r){
	int p=Log[r-l+1];
	return min(f[l][p],f[r-(1<<p)+1][p]);
}
signed main(){
	scanf("%lld",&n);
	for(i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(i=1;i<=n;i++) scanf("%lld",&b[i]);
	for(i=1;i<=n;i++) scanf("%lld",&c[i]);
	for(i=n;i>=1;i--) Q[i]=Q[i+1]+b[i];
	memset(f,127,sizeof(f));
	for(i=0;i<=n;i++) g[i]=a[i]+Q[i+1],f[i][0]=g[i];
	for(i=2;i<=n+1;i++) Log[i]=Log[i>>1]+1;
	for(j=1;j<=20;j++){
		for(i=0;i+(1<<j)-1<=n;i++){
			f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
	scanf("%lld",&q),qq=q;
	while(q--){
		scanf("%lld",&m),l=0,ans=1e18;
		for(i=1;i<=m;i++) scanf("%lld",&p[i]);
		mp[m+1]=0,p[m+1]=-1;
		for(i=m;i>=1;i--) mp[i]=mp[i+1]+b[p[i]];
		int k,s=0;
		for(i=0,j=0;j<=m;i=p[j+1],j++){
			k=a[i];
			int r;
			if(j+1>m) r=n;
			else r=p[j+1]-1;
			int Minn=qry(i,r);
			if(p[l+1]==i && l<m) l++,s+=c[i];
			ans=min(ans,s+Minn-mp[l+1]);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

预期 $100$ pts。

---


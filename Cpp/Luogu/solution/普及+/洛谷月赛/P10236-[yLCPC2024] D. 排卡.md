# [yLCPC2024] D. 排卡

## 题目背景

经过千辛万苦，扶苏终于到达了机厅。但是她很快发现机厅排起了大 b 队 ~~（不是省选的 B 队）~~。

舞萌玩家们在人多的时候经常采取排卡的方式决定谁下一个上机。因为人实在是太多了，他们在排卡的时候，便注意到了卡上的编号。

他们向扶苏提了一个问题，你能解决吗？

## 题目描述

扶苏有一个双端队列 $a$。这个队列与计算机科学中队列的概念类似，不同的是，这个队列既可以从队列头读取和弹出元素，也可以在队列尾部读取和弹出元素，因此被称为『双端队列』。

这个队列中有 $n$ 个数。扶苏将通过 $n$ 次操作构造一个长度为 $n$ 的序列 $b$，第 $i$（$1 \leq i \leq n$）次操作会可以进行如下两个过程之一：

1. 令 $b_i$ 为 $a$ 的队列头，并在 $a$ 的头部弹出一个元素。
2. 令 $b_i$ 为 $a$ 的队列尾，并在 $a$ 的尾部弹出一个元素。

我们定义一个数对 $(i, j)$ 的得分为：

$$\mathrm{score}(i,j) = i^j \bmod 998244353$$

即 $i$ 的 $j$ 次幂对 $998244353$ 取余数的结果。特别的，在本题中我们规定 $0^0 = 0$。

现在，扶苏想用最优的策略构造 $b$ 序列，最大化如下式子的值：

$$\sum_{i = 1}^{n - 1} \mathrm{score}(b_i, b_{i + 1})$$

即 $b$ 所有相邻两项按原顺序计算的得分之和。

注意，我们仅在计算一个数对的时候将得分对 $998,244,353$ 取模，在计算求和时不再将这个和取余。

## 样例 #1

### 输入

```
2
5
5 3 1 4 2
6
6 5 1 4 2 3```

### 输出

```
1168
15655```

# 题解

## 作者：小明小红 (赞：6)

# P10236题解
## 前言：
黑润心有错夏令营讲了这道题，我本想抄题解的，结果发现看不懂前几篇，只能自己写一篇啦。

## 正文：
### 算法判断：
我们可以发现这个操作只能**删去头和尾**，所以无论经过多少次合法的操作，得到的数组一定是原串的**子串**。什么？连续？好！**区间动态规划**，启动！

### 状态定义：
我们定义 $dp_{l,r,0}$ 为 $[l,r]$ 序列下一个将删去最**左边**的数的**最大得分**，同理 $dp_{l,r,1}$ 为 $[l,r]$ 序列下一个将删去最**右边**的数的**最大得分**。

### 如何转移：
我们知道 $[l,r,0/1]$ **一定**是由 $[l-1,r,0]$ 或 $[l,r+1,1]$ 转移而来，转移是有**得分**的，如何计算得分？

### 计算得分：
举个栗子：
![](https://cdn.luogu.com.cn/upload/image_hosting/nr84tg8u.png)

### 推出方程
我们现在就可以推出方程了：

$dp_{i,j,0}=\max(dp_{i-1,j,0}+a_{i-1}^{a_i},dp_{i,j+1,1}+a_{j+1}^{a_i})$

$dp_{i,j,1}=\max(dp_{i-1,j,0}+a_{i-1}^{a_j},dp_{i,j+1,1}+a_{j+1}^{a_j})$

### 得到答案
根据题意我们的答案是 $\max(dp_{i,i,0},dp_{i,i,1})$ 其中 $i$ 为 $1$ 到 $n$ 的任意整数。

### 补充
我们现在把代码交了上去交了，啊？为什么不对？

对了！记得要用**快速幂**，还**一定要特判** $0^0=0$。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll mod=998244353;
ll quickpow(ll x,ll y)
{
	if(x==0&&y==0)
	{
		return 0;//特判！！！ 
	}
	ll ans=1,p=x;
	while(y>0)
	{
		if(y&1)
		{
			ans=(ans*p)%mod;
		}
		p=(p*p)%mod;
		y>>=1;
	}
	return ans;
}
ll T,dp[1009][1009][2],a[1009],n; 
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;
		for(ll i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		memset(dp,0,sizeof(0));//多测清空 
		for(ll len=n;len>=1;len--)//按题目顺序枚举长度 
		{
			for(ll i=1;i<=n-len+1;i++)//枚举左右端点 
			{
				ll j=i+len-1;
				dp[i][j][0]=max(dp[i-1][j][0]+quickpow(a[i-1],a[i]),dp[i][j+1][1]+quickpow(a[j+1],a[i]));
				dp[i][j][1]=max(dp[i-1][j][0]+quickpow(a[i-1],a[j]),dp[i][j+1][1]+quickpow(a[j+1],a[j]));
			}
		}
		ll ans=0;
		for(ll i=1;i<=n;i++)//统计答案 
		{
			ans=max(ans,dp[i][i][0]);
			ans=max(ans,dp[i][i][1]);
		}
		cout<<ans<<endl;
	}
	return 0;
 } 
```

---

## 作者：Mr_Az (赞：5)

## Question 问题 [P10236 [yLCPC2024] D. 排卡](https://www.luogu.com.cn/problem/P10236)

题目大意：给定长度为 $n(2 \le n \le 1000)$ 的序列 $a$，每次可以从头或尾选一个数放到序列 $b$（选后删除），求$\displaystyle \sum_{i=1}^{n-1} b_i^{b_{i+1}}$ 的最大值。（我们仅在计算 $b_i^{b_{i+1}}$  的时候将得分对 $998244353$ 取模）。

## Analysis 分析

首先思考贪心：（错解）

第一个从最左边或最右边拿，然后贪心第二个从最左边还是最右边使得 $b_1^{b_2}$ 最大，一直这样贪心下去。很明显是错的。但很明显连样例的过不了，正确性显然不存在。

观察到 $n$ 的范围较小，发现想复杂了，直接暴力区间 $DP$ 即可。

## Solution 

定义 $f_{l,r,(0,1)}$ 为区间 $[l,r]$ 最后弹掉的是最左边的（0）还是最右边的（1）。

转移方程非常好写：
$$
\begin{aligned}
f_{l,r,0}&=\max{\{f_{l+1,r,0}+a_l^{a_{l+1}},f_{l+1,r,1}+a_l^{a_{r}}\}}\\
f_{l,r,1}&=\max{\{f_{l,r-1,0}+a_r^{a_{l}},f_{l,r-1,1}+a_r^{a_{r-1}}\}}
\end{aligned}
$$
对于 $f_{l,r,0}$ 的转移进行一个详细的讲述，$f_{l,r,1}$ 同理。

它只能从 $[l+1,r]$ 转移而来，因为他最后踢掉的是最左边的。所以要么是 $f_{l+1,r,0}+a_l^{a_{l+1}}$ 要么就是 $f_{l+1,r,1}+a_l^{a_{r}}$.

## Code 代码

```cpp
signed main(){
	read(T);
	while(T--){
		read(n);
		for(rint i=1;i<=n;i++) read(a[i]);
		for(rint i=1;i<=n;i++) for(rint j=1;j<=n;j++) f[i,j,0]=f[i,j,1]=0;
		for(rint len=2;len<=n;len++){
			for(rint l=1;l<=(n-len+1);l++){
				int r=l+len-1;
				f_{l,r,0}=max({f_{l,r,0},f[l+1,r,0]+power(a[l],a[l+1]),f[l+1,r,1]+power(a[l],a[r])});
				f_{l,r,1}=max({f_{l,r,1},f[l,r-1,0]+power(a[r],a[l]),f[l,r-1,1]+power(a[r],a[r-1])});
			}
		}
		printf("%lld\n",max(f[1,n,0],f[1,n,1]));
	}
    return 0;
}
```

---

## 作者：残阳如血 (赞：5)

## 算法分析

首先，由于要求**最大化**下面的式子：
$$
\sum\limits_{i=1}^{n-1}(b_{i}^{b_{i+1}}\bmod998244353)
$$
容易想到使用 DP。



其次，由于双端队列需要控制两端的位置，所以显然要使用**区间 DP**。

### 状态设计

首先记录一个区间的左、右端点，所以第一步令 $f_{l,r}$ 表示 $a$ 中 $[l,r]$ 这一区间最大的贡献。

但是，$[l,r]$ 可能由 $[l+1,r]$ 或 $[l,r-1]$ 得来，无法固定，所以需要记录 $[l,r]$ 是由哪个区间得来的。

能不能记录这个数的下标呢？这是不行的，因为这样空间复杂度就会变为 $O(n^3)$，铁定爆炸。

根据之前的描述，$[l,r]$ 只有两种得到的可能性，所以可以将第三维表示为 $0/1$：

- $f_{l,r,0}$ 表示当前区间为 $[l,r]$，且是先弹出 $a_l$；
- $f_{l,r,1}$ 表示当前区间为 $[l,r]$，且是先弹出 $a_r$。

这样，我们就可以进行状态转移了。

### 状态转移

> 声明：下面的转移方程中暂时先忽略取模。

考虑 $f_{l,r,0}$ 如何转移。

由于 $f_{l,r,0}$ 由 $[l+1,r]$ 得来，所以此时先弹出的是 $a_l$，即 $b_i=a_l$。

由于 $[l+1,r]$ 不固定，所以我们需要分类讨论：

- $[l+1,r]$ 弹出的是 $l+1$，那么 $(b_i,b_{i+1})=(a_l,a_{l+1})$，所以结果是 $f_{l+1,r,0}+a_{l}^{a_{l+1}}$；
- $[l+1,r]$ 弹出的是 $r$，那么 $(b_i,b_{i+1})=(a_l,a_r)$，所以结果是 $f_{l+1,r,1}+a_{l}^{a_{r}}$。

所以
$$
f_{l,r,0}=\max\{f_{l+1,r,0}+a_{l}^{a_{l+1}},f_{l+1,r,1}+a_{l}^{a_{r}}\}
$$

或许给张图能更好理解（？

![f[l][r][0] 的转移 图解](https://cdn.luogu.com.cn/upload/image_hosting/cq46gcl9.png)

---

接下来考虑 $f_{l,r,1}$ 如何转移，与上面的转移同理。

$f_{l,r,1}$ 由 $[l,r-1]$ 得来，所以 $b_i=a_r$。

- $[l,r-1]$ 弹出的是 $l$，那么 $b_{i+1}=a_l$；
- $[l,r-1]$ 弹出的是 $r-1$，那么 $b_{i+1}=a_{r-1}$。

所以
$$
f_{l,r,1}=\max\{f_{l,r-1,0}+a_{r}^{a_{l}},f_{l,r-1,1}+a_{r}^{a_{r-1}}\}
$$

### 转移细节

#### 初始化

全部赋值为 $0$，因为一个空的区间显然结果为 $0$。

#### 最终答案

最终结果为 $\max\{f_{1,n,0},f_{1,n,1}\}$，即整个数组第一次弹出左/右端点的答案中的最大值。

## 代码实现

### 实现细节

- 本题中特别规定 $0^0=0$，所以快速幂中需要特判；

- 区间长度至少为 $2$，否则弹出后是空的，没有意义。

- $f$ 数组要开为 `long long` 类型：

  由于仅在快速幂的时候取模，求和是不取模，那么每个值最大为 $998,244,352$，需要求和 $n-1$ 次，$998,244,352\times(n_{\max}-1)=997,246,107,648>10^{9}$，所以要开 `long long`。

### 完整代码

```c++
#include <cstring>
#include <iostream>
#define max(a, b) ((a)>(b)?(a):(b))
const int N = 1e3 + 10;
const int MOD = 998244353;
typedef long long lint;

int T, n, a[N];
lint f[N][N][2];

lint qpow(lint a, lint b) { // 快速幂
  if (a == 0 && b == 0) return 0; // 特判
  lint res = 1;
  for (; b; b >>= 1) {
    if (b & 1) (res *= a) %= MOD;
    (a *= a) %= MOD;
  }
  return res;
}

int main() {
  std::cin.tie(0)->sync_with_stdio(0);
  for (std::cin >> T; T; --T) {
    std::cin >> n, memset(f, 0, sizeof(f)); // 多测清空
    for (int i = 1; i <= n; ++i) std::cin >> a[i];
    for (int len = 2; len <= n; ++len) { // 从小到大枚举区间长度
      for (int l = 1, r; ; ++l) {
        if ((r = l + len - 1) > n) break; // 右端点超出范围就退出
        // 根据状态转移方程进行转移
        f[l][r][0] = max(f[l + 1][r][0] + qpow(a[l], a[l + 1]), f[l + 1][r][1] + qpow(a[l], a[r]));
        f[l][r][1] = max(f[l][r - 1][0] + qpow(a[r], a[l]), f[l][r - 1][1] + qpow(a[r], a[r - 1]));
      }
    }
    std::cout << max(f[1][n][0], f[1][n][1]) << '\n';
  }
  std::cout.flush();
  return 0;
}
```

---

## 作者：under_the_time (赞：4)

## 题意

> 给定一个长度为 $n$ 的双端队列 $a$，你需要构造一个长度相同的 $b$ 数组，构造方法如下：
>
> - 在 $b$ 的末尾插入 $a$ 的队首，然后弹出队首；
> - 在 $b$ 的末尾插入 $a$ 的队尾，然后弹出队尾。
>
> 现在需要求出
> $$
> \sum^{n-1}_{i=1}\big(b_i^{b_{i+1}}\bmod998244353\big)
> $$
> 的最大值。

## 解法

考虑区间 dp。令 $f(i,j)$ 表示当前 $a$ 队列中取走了 $[i,j]$ 这一段元素时的答案。因为每个点的贡献和与其相邻的点有关，所以我们多开一维 $k$，当 $k=0$ 时表示取走了队头的数，当 $k=1$ 时表示取走了队尾的数。

转移时按区间长度从小到大枚举，类似于反着往 $a$ 中加元素，往队首取的转移方程即为
$$
f(L,R,0)=\max\big(f(L+1,R,0)+a_L^{a_{L+1}},f(L+1,R,1)+a_L^{a_R}\big)
$$
同理，往队尾取得转移方程即为
$$
f(L,R,1)=\max\big(f(L,R-1,0)+a_R^{a_L},f(L,R-1,1)+a_R^{a_{R-1}}\big)
$$
这两种都在枚举与上一种状态相邻的数。最终答案即为 $\max(f(1,n,0),f(1,n,1))$。

## 实现

取模操作只在快速幂中进行，注意开 `long long`。**警钟：本题中 $0^0=0$！**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e3 + 5;
const int P = 998244353;
#define ll long long
ll a[maxn];
ll qp(ll x,ll y) {
    ll res = 1;
    while (y) {
        if (y & 1ll) res = (res * x) % P;
        x = (x * x) % P, y >>= 1ll;
    }
    return !x && !y ? 0 : res;
}
ll f[maxn][maxn][2]; int n;
int T;
int main() {
    scanf("%d",&T);
    while (T --) {
        scanf("%d",&n);
        memset(f,0,sizeof(f));
        for (int i = 1;i <= n;i ++)
            scanf("%lld",&a[i]);
        for (int len = 1;len < n;len ++) 
            for (int L = 1, R = L + len;R <= n;L ++, R ++) {
                f[L][R][0] = max(f[L + 1][R][0] + qp(a[L],a[L + 1]),
                                f[L + 1][R][1] + qp(a[L],a[R]));
                f[L][R][1] = max(f[L][R - 1][0] + qp(a[R],a[L]),
                                f[L][R - 1][1] + qp(a[R],a[R - 1]));
            }
        printf("%lld\n",max(f[1][n][0],f[1][n][1]));
    }
    return 0;
}
```

---

## 作者：ran_qwq (赞：4)

把删数反过来变成加数，初始双端队列为空，每次可以将左边或右边的数加入双端队列。

因为任何时候加的都是一个区间，所以考虑区间 dp，设 $dp_{i,j,0/1}$ 为加 $i$ 到 $j$ 的数，上一个取的是最左边 / 最右边的数，当前分数的最大值。

边界：$dp_{i,i,0}=dp_{i,i,1}=0$，只加了一个数。

状态转移方程：

- 对于 $dp_{i,j,0}$，新加的数是 $a_i$，从 $dp_{i+1,j,0/1}$ 转移过来，上一次可以加 $a_{i+1}$ 或 $a_j$。所以 $dp_{i,j,0}=\max(dp_{i+1,j,0}+a_i^{a_j},dp_{i+1,j,1}+a_i^{a_i+1})$。注意我们把原问题反过来了，所以得出的 $b$ 数组也是反过来的，dp 时要把它反回去。

- 对于 $dp_{i,j,1}$，新加的数是 $a_i$，从 $dp_{i,j-1,0/1}$ 转移过来，上一次可以加 $a_i$ 或 $a_{j-1}$。所以 $dp_{i,j,1}=\max(dp_{i,j-1,0}+a_i^{a_j},dp_{i,j-1,1}+a_j^{a_j-1})$。

答案：$\max(dp_{1,n,0},dp_{1,n,1})$。

---

## 作者：liangjindong0504 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P10236)

怎么感觉 T4 比 T3 简单啊（因为我不会 T3）。
### 题意简述
有一个长度为 $n$ 的序列 $a$，你每次能从左端点或右端点取走一个数直至取完。从第二次操作开始，每次操作你将会获得的分数为：上一次取走的数的本次取的数次方，对 998244353 取模。

求分数最大值。

**有多测。**
### 思路分析
首先，通过观察 $n$ 的范围，可以确定，正解应该是 $O(n^2)$ 的。于是，我们开始查找算法。

爆搜（~~你试试看~~），时间复杂度 $2^n$，可以试着算一下 $2^{1000}$ 是多少。这种方法，绝对超时。

然后，求区间值的算法只剩下 dp 了。于是，开始 dp。

~~俗话说得好~~，dp 分三步。

1. 设置状态（就是你这个 dp 数组表示什么，不然你都不知道在干什么）。

   显然，一开始想，$dp_i$ 设为 $1 \sim i$ 的最大值。很明显，这样只能顾及到从右边取的方案，排除。
   
   再加一维，很自然想到区间 dp。设置 $dp_{i,j}$ 表示 $i \sim j$ 的最大值。但是这样也有问题。即，你虽然能够转移了，但是上一次是在左边还是右边开始的，是个问题，解决不了。

   终于，状态表示出来了，设 $dp_{i,j,0}$ 为 $i \sim j$ 且从左端开始取的最大值，$dp_{i,j,1}$ 即为 $i \sim j$ 且从右端开始取的最大值。

1. 推转移式（听起来高大上，实际上就是列举出所有可以到达这个状态的状态）

   很明显，如果是 $dp_{i,j,0}$，那么之前就是 $dp_{i+1,j,0/1}$，即上一个区间，左右都可以取。枚举即可。而 $dp_{i,j,1}$ 同理。当然，还需要加上一个得分。不过，这里就需要用到快速幂了，不然会爆掉。

1. 设置初始值（其实就是最基本的状态）

   本来，应该设 $dp_{i,i,0/1}$ 的，因为它没法向下转移了。但是由于这里只有一个数，所以答案为 $0$，无需初始化。（当然有一些题目的初始值很麻烦，不要小看它）

好了，思路已经推出来了，如果还有不懂，看代码吧（或者私信）。
### 代码实现
就注意两点：

**多测不清空，亲人两行泪！！！**

**不开 long long 见祖宗！！！**
```cpp
#include<bits/stdc++.h>
using namespace std;
//不开long long见祖宗 
#define int long long
int t,n,a[1010],dp[1010][1010][2],modd=998244353;
//快速幂，这里不讲了，可以去看模板，有很多人讲 
int fast_pow(int a,int b,int c){
	if(a==0&&b==0) return 0;
	int x,y,m=1;
	y=a,x=b;
	while(b){
		if(b%2){
			m=m*a%c;
		}
		a=a*a%c;
		b/=2;
	}
	return m;
}
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		//注意，千万要清空 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++) dp[i][j][0]=dp[i][j][1]=0;
		}
		//dp部分 
		for(int len=1;len<n;len++){
			for(int i=1;i+len<=n;i++){
				int j=i+len;
				//转移。此时第一个是选左边，因此加上的分数应该是a[i]的a[i+1]或a[j]次方（根据情况） 
				dp[i][j][0]=max(dp[i+1][j][0]+fast_pow(a[i],a[i+1],modd),dp[i+1][j][1]+fast_pow(a[i],a[j],modd));
				//第一个选右边同理 
				dp[i][j][1]=max(dp[i][j-1][0]+fast_pow(a[j],a[i],modd),dp[i][j-1][1]+fast_pow(a[j],a[j-1],modd));
			}
		}
		//比较从左边取和从右边取的较大值 
		cout<<max(dp[1][n][0],dp[1][n][1])<<endl;
	}
	return 0;
}
```

---

## 作者：SXqwq (赞：3)

### Description

有一个长度为 $n$ 的双端队列 $a$，每次可以选择队头或者队尾弹出元素 $a_i$，并按弹出顺序加入序列 $b$，初始化序列 $b$ 为空。求 $\max\{\sum\limits_{i=1}^{n-1}(b_i^{b_{i+1}}\bmod 998244353)\}$。

### Analysis

区间 dp 板子题。

一般地，对于 dp 问题，**多一个条件意味着多一个状态**。本题中我们注意到 **一个新加入的数字 $b_i$，它的贡献依赖于 $b_{i-1}$。** 每次记录上一个值显然不现实。不妨只记录上一个是弹出的左端点还是右端点。这是一个常用套路。即记录该状态是从区间 $[l,r-1]$ 或 $[l+1,r]$ 转移来的。

具体地，我们开一个第三维状态 $k\in\{0,1\}$ 分别表示先弹出 $a_l,a_r$。

对于转移，我们分类讨论，具体如下。

对于 $f_{l,r,0}$，它先弹出的是 $l$，应当由区间 $[l+1,r]$ 转移。但区间 $[l+1,r]$ 的最大值并不确定，我们分类讨论如下。

- 当区间 $[l+1,r]$ 先弹出 $l+1$ 更优时，则 $a_{l+1}$ 和 $a_l$ 产生贡献。

- 当区间 $[l+1,r]$ 先弹出 $r$ 更优时，则 $a_r$ 和 $a_l$ 产生贡献。

对于 $f_{l,r,1}$ 同理，不再赘述。

实现的时候需要套个快速幂。

---

## 作者：神仙酱 (赞：1)

## 思路分析
### 状态表示
不同于区间 dp，我的第一想法其实是状态机 dp。`f[i][j][k]` 表示**还剩 $[i, j]$ 的元素时，能得到的最大结果**，$k\in\{0, 1\}$ 表示决策状态：
- `0` 代表现在取 $[i,j]$ 的左端点（也就是 `a[i]`）。
- `1` 代表取 $[i,j]$ 的右端点（也就是 `a[j]`）。

### 状态转移
无论要取左端点还是右端点，那么上一个状态可以是取了 `a[i - 1]` 或者取了 `a[j + 1]`，分别对应着状态 `f[i - 1][j][0]` 和 `f[i][j + 1][1]`。形式化地，
$$
f[i][j][0]=\max\left(f[i - 1][j][0] + a[i - 1]^{a[i]}, f[i][j + 1] + a[j+1]^{a[i]}\right)
$$
$$
f[i][j][1]=\max\left(f[i - 1][j][0] + a[i - 1]^{a[j]}, f[i][j + 1] + a[j+1]^{a[j]}\right)
$$
### 枚举顺序
`i` 从小到大，`j` 从大到小。
## AC 代码
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 10, mod = 998244353;
int quickPow(int base, int exp) {
    if (base == 0)
        return 0;
    int result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp & 1)
            result = (result * base) % mod;
        exp >>= 1;
        base = (base * base) % mod;
    }
    return result;
}
int n;
int a[N], f[N][N][2];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 1; i <= n; ++i)
            cin >> a[i];
        memset(f, 0, sizeof(f));
        int ans = 0;
        for (int l = 1; l < n; ++l) {
            for (int r = n; r > l; --r) {
                if (l - 1 >= 1) {
                    f[l][r][0] = f[l - 1][r][0] + quickPow(a[l - 1], a[l]);
                    f[l][r][1] = f[l - 1][r][0] + quickPow(a[l - 1], a[r]);
                }
                if (r + 1 <= n) {
                    f[l][r][0] = max(f[l][r][0], f[l][r + 1][1] + quickPow(a[r + 1], a[l]));
                    f[l][r][1] = max(f[l][r][1], f[l][r + 1][1] + quickPow(a[r + 1], a[r]));
                }
            }
            ans = max(ans, max(f[l][l + 1][0] + quickPow(a[l], a[l + 1]), f[l][l + 1][1] + quickPow(a[l + 1], a[l])));
        }
        cout << ans << "\n";
    }
}
```

---

## 作者：xiaoliebao1115 (赞：1)

## 思路

根据数据范围~~标签~~可知，这是一个二维的区间动态规划。

### 定状态

这道题从 $b$ 数组下手肯定是不行的。

题目说要左边或者右边弹出一个数，那某一时刻剩下的一定是一段区间。又因为上一次弹出是头是尾对这一次有影响，所以开三维，最后一维 $0$ 或 $1$，表示从哪里弹出。

所以 $dp_{i,j,0}$ 表示剩下 $i$ 到 $j$ 弹出头后的答案，反之，亦然。

那么这题的转移方程也很明显了，具体可见代码。

## code

```cpp
for(int k=n-1;k>=1;k--)
{
	for(int i=1;i+k-1<=n;i++)
	{
		int j=i+k-1;
		dp[i][j][0]=max(dp[i-1][j][0]+poww(a[i-1],a[i]),dp[i][j+1][1]+poww(a[j+1],a[i]));
		dp[i][j][1]=max(dp[i-1][j][0]+poww(a[i-1],a[j]),dp[i][j+1][1]+poww(a[j+1],a[j]));
	}
}
ll ans=0;
for(int i=1;i<=n;i++)
{
	ans=max(ans,max(dp[i][i][0],dp[i][i][1]));
}
```

题目中的 $i^j$ 可以使用快速幂求解。

完结撒花！！

---

## 作者：HHC883 (赞：0)

# 题目分析
区间 DP 板子题。用 $dp_{i,j,0}$ 表示先弹出 $a_i$ 再弹出区间 $[i+1,j]$ 能得到的最大值，用 $dp_{i,j,1}$ 表示先弹出 $a_j$ 再弹出区间 $[i,j-1]$ 能得到的最大值。注意，DP 数组有第三维的原因是因为在 $b$ 数组加入一个元素后，得分的变化与 $b$ 数组原有的值有关，所以只有两维是不够的。

状态转移方程如下：
$$dp_{i,j,0}=\max\{dp_{i+1,j,0}+a_i^{a_{i+1}},dp_{i+1,j,1}+a_i^{a_j}\}$$
$$dp_{i,j,1}=\max\{dp_{i,j-1,0}+a_j^{a_i},dp_{i,j-1,1}+a_j^{a_{j-1}}\}$$

其中乘方运算要用快速幂加速。

时间复杂度为 $O(Tn^2\log(\max{a_i}))$。
# 参考代码
```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
const int mod=998244353;
int t,n,a[1005],dp[1005][1005][2];
int qpow(int a,int b){
	if(a==0&&b==0) return 0;
	if(b==0) return 1;
	if(b==1) return a;
	if(b&1) return qpow(a,b-1)*a%mod;
	int tmp=qpow(a,b>>1);
	return tmp*tmp%mod;
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		memset(dp,0,sizeof dp);
		for(int i=1;i<=n;i++) dp[i][i][0]=dp[i][i][1]=0;
		for(int len=2;len<=n;len++){
			for(int i=1;i+len-1<=n;i++){
				int j=i+len-1;
				dp[i][j][0]=max(dp[i+1][j][0]+qpow(a[i],a[i+1]),dp[i+1][j][1]+qpow(a[i],a[j]));
				dp[i][j][1]=max(dp[i][j-1][0]+qpow(a[j],a[i]),dp[i][j-1][1]+qpow(a[j],a[j-1]));
			}
		}
		cout<<max(dp[1][n][0],dp[1][n][1])<<endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

一眼 dp。

## 状态

设 $dp_{l,r}$ 为 $[l,r]$ 的最大贡献，可我们发现我们不知道这个区间是由 $[l+1,r]$ 还是 $[l,r-1]$ 转移而来的，所以我们可以再加一维:

$dp_{l,r,0}$ 代表从 $[l+1,r]$ 转移而来的最大值（即弹出 $a_l$），$dp_{l,r,1}$ 代表从 $[l,r-1]$ 转移而来的最大值（即弹出 $a_r$）。

## 转移

假如我们遍历到了 $]l,r]$，那么：

- $dp_{l,r,0}$：很显然底数为 $a_l$，当从 $dp_{l+1,r,0}$ 转移而来时，指数为 $a_{l+1}$，当从 $dp_{l+1,r,1}$ 转移而来时，指数为 $a_r$，那么 $dp_{l,r,0}=\max\{dp_{l+1,r,0}+{a_l}^{a_{l+1}},dp_{l+1,r,1}+{a_l}^{a_r}\}$。
- $dp_{l,r,1}$：同理 $dp_{l,r,1}=\max\{dp_{l,r-1,0}+{a_r}^{a_l},dp_{l,r-1,1}+{a_r}^{a_{r-1}}\}$。

那么时间，空间复杂度均为 $O(n^2)$，可以通过。

---

## 作者：船酱魔王 (赞：0)

# P10236 [yLCPC2024] D. 排卡 题解

## 题意回顾

$ a $ 数列长度为 $ n $，每次从序列开头或结尾取出一个数和上一个被取出的数计算一个价值函数并累加，请最大化价值函数的和。

多测，$ 2 \le \sum n \le 1000 $。

## 分析

考虑设计暴力，求解函数 `solve(l,r,0/1)` 表示对于 $ [l,r] $ 区间，我们先取出左或者右的数。我们每次递归可以根据取数位置转移到更小的区间的两种取数情况。

求解 `solve(1,n,0/1)` 即可。

状态数不大，是 $ O(n^2) $ 量级的，考虑记忆化搜索，即可复杂度由 $ O(2^n) $ 优化至 $ O(n^2) $。

这里我们实现方式是使用循环进行区间 DP，记忆化搜索的说明只是用于展示思维过程，其本身也不失为一种简单快捷的实现方式。

注意本题规定 $ 0^0=0 $。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e3 + 5;
const int mod = 998244353;
const long long inf = 1e18 + 5;
int T;
int n;
int a[N];
long long dp[N][N][2];
int ksm(int x, int y) {
    if(x + y == 0) return 0;
    int res = 1;
    int mul = x;
    while(y) {
        if(y & 1) res = (long long)res * mul % mod;
        mul = (long long)mul * mul % mod, y >>= 1;
    }
    return res;
}
int main() {
    scanf("%d", &T);
    for(int ti = 1; ti <= T; ti++) {
        scanf("%d", &n);
        for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
        for(int i = 1; i <= n; i++) {
            for(int j = i; j <= n; j++) dp[i][j][0] = dp[i][j][1] = -inf;
        }
        for(int i = 1; i <= n; i++) dp[i][i][0] = 0;
        for(int l = 2; l <= n; l++) {
            for(int i = 1; i + l - 1 <= n; i++) {
                int j = i + l - 1;
                dp[i][j][0] = max(dp[i + 1][j][0] + ksm(a[i], a[i + 1]), dp[i + 1][j][1] + ksm(a[i], a[j]));
                dp[i][j][1] = max(dp[i][j - 1][0] + ksm(a[j], a[i]), dp[i][j - 1][1] + ksm(a[j], a[j - 1]));
            }
        }
        printf("%lld\n", max(dp[1][n][0], dp[1][n][1]));
    }
    return 0;
}

```

---

## 作者：Weekoder (赞：0)

### 思路

可以将问题转化为：每次从数组 $a$ 中选择两端的数构成数组 $b$，求最大的

$$\mathrm{score}(i,j) = i^j \bmod 998244353$$

$$\sum_{i = 1}^{n - 1} \mathrm{score}(b_i, b_{i + 1})$$

加入的数字越来越多并且从两端选择，而且每次都可以构成一个区间，很容易可以观察出来区间 DP。根据两端类区间 DP 的经验，我们可以给出状态：$dp_{i,j,0/1}$ 表示在区间 $[i,j]$ 以外的所有数都被处理了的情况下区间 $[i,j]$ 能产生的最大分数，并且最后加入的数是 $a_i/a_j$。

如何状态转移？先考虑 $dp_{i,j,0}$，由于最后加入的数是 $a_i$，答案一定和区间 $[i+1,j]$ 有关。那么，到底是 $dp_{i+1,j,0}$ 还是 $dp_{i+1,j,1}$ 呢？如果是 $dp_{i+1,j,0}$，最后加入的数是 $a_{i+1}$，那产生的分数就是 $a_i^{a_{i+1}}$；否则，最后加入的数就是 $a_{j}$，那产生的分数就是 $a_i^{a_j}$。其他情况以此类推。完整的状态转移方程如下：

$$
dp_{i,j,0}=\max(dp_{i+1,j,0}+a_i^{a_{i+1}},dp_{i+1,j,1}+a_i^{a_j})\\
dp_{i,j,1}=\max(dp_{i,j-1,0}+a_j^{a_i},dp_{i,j-1,1}+a_j^{a_{j-1}});
$$

$i^j\bmod998244353$ 可以快速幂解决。

初始状态 $dp_{i,i,0}=0,dp_{i,i,1}=0$，答案为 $\max(dp_{1,n,0},dp_{1,n,1})$。

代码：

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 1e3 + 5, Mod = 998244353;

int T, n, a[N], dp[N][N][2];

int expow(int x, int y) {
    if (!x && !y)
        return 0;
    int r = 1;
    while (y) {
        if (y & 1) r = r * x % Mod;
        x = x * x % Mod, y >>= 1;
    }
    return r % Mod;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> T;
	while (T --) {
	    cin >> n;
	    memset(dp, 0x80, sizeof dp);
	    for (int i = 1; i <= n; i++)
	       cin >> a[i], dp[i][i][0] = dp[i][i][1] = 0;
	    for (int len = 2; len <= n; len++) {
	        for (int i = 1; i + len - 1 <= n; i++) {
	            int j = i + len - 1;
	            dp[i][j][0] = max(dp[i + 1][j][0] + expow(a[i], a[i + 1]), dp[i + 1][j][1] + expow(a[i], a[j]));
	            dp[i][j][1] = max(dp[i][j - 1][0] + expow(a[j], a[i]), dp[i][j - 1][1] + expow(a[j], a[j - 1]));
	        }
	    }
	    cout << max(dp[1][n][0], dp[1][n][1]) << "\n";
	}
	return 0;
}
```

---

## 作者：Didncan_yu (赞：0)

## 题目大意

给定数列 $a$，每次可从头或尾选数，依照这一顺序构成序列 $b$，求 $\sum_{i=1}^{n-1} b_i^{b_{i+1}} \bmod 998244353 $ 的最大值。

## 思路分析

可以看出是经典的区间 dp 类型，同时使用快速幂来转移。

### 快速幂

观察公式中的这个部分：

$$ b_i^{b_{i+1}} \bmod 998244353 $$

应该要使用快速幂来优化，不然每次暴力乘的话肯定过不了。

[快速幂模板题](https://www.luogu.com.cn/problem/P1226)

```cpp
int f(int g,int t){
    if(g>n||g<1||t>n||t<1)return -98244353;
	long long sum=1,m=a[g],n=a[t];
	if(m==0&&n==0)return 0;
   //以下为快速幂主体部分
	while(n){
		if(n&1)sum=1ll*(sum*m)%MOD;
		m=(m*m)%MOD;
		n>>=1;
	}
	return sum;
}
```
### 区间 DP

对于每两个相邻取出的数，有以下可能与前提条件：

- 先左再右，要求此时剩余区间两边至少都有一个数。
- 先左再左，要求左边至少有两个数。
- 先右再右，右边至少两个数。
- 先右再左，与先左再右相同。

此时对于前一个取出的数已经不会影响答案了，但是后一个数还有影响。

所以定义 $dp_{i,j,0}$ 为剩余 $[i,j]$ 时最后取左边的最优解，$dp_{i,j,1}$ 为最后取右边的最优解。

最后转移方程如下：

$$dp_{i,j,0}=\max(dp_{i-1,j,0}+{a_{i-2}}^{a_{i-1}},dp_{i-1,j,1}+{a_{j+1}}^{a_{i-1}})$$

$$dp_{i,j,1}=\max(dp_{i,j+1,0}+{a_{i-1}}^{a_{j+1}},dp_{i,j+1,1}+{a_{j+2}}^{a_{j+1}})$$

最终答案则为：

$$\max_{i<n}(\max(dp_{i,i,0}+{a_{i-1}}^{a_i},dp_{i,i,1}+{a_{i+1}}^{a_i}))$$

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read();
inline void write(long long n);
void solve();
signed main(){
	int t=read();
	while(t--)solve();
	return 0;
}
const int MAX=1e3+6;
const int MOD=998244353;
int n,a[MAX],dp[MAX][MAX][2],ans;
int f(int g,int t){
    if(g>n||g<1||t>n||t<1)return -98244353;
	long long sum=1,m=a[g],n=a[t];
	if(m==0&&n==0)return 0;
	while(n){
		if(n&1)sum=1ll*(sum*m)%MOD;
		m=(m*m)%MOD;
		n>>=1;
	}
	return sum;
}
void solve(){
	ans=0;
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	dp[0][n+1][0]=dp[0][n+1][1];
	for(int len=n-2;len>0;len--){
		for(int i=1;i<=n;i++){
			int j=i+len-1;
			if(j>n)break;
				dp[i][j][0]=max(dp[i-1][j][0]+f(i-2,i-1),dp[i-1][j][1]+f(j+1,i-1));
				dp[i][j][1]=max(dp[i][j+1][0]+f(i-1,j+1),dp[i][j+1][1]+f(j+2,j+1));
		}
	}
	ans=max(ans,dp[1][1][1]+f(2,1));
	for(int i=2;i<n;i++){
		ans=max(ans,dp[i][i][0]+f(i-1,i));
		ans=max(ans,dp[i][i][1]+f(i+1,i));
	}
	ans=max(ans,dp[n][n][0]+f(n-1,n));
	write(ans);
	putchar('\n');
	return ;
}
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void write(long long n){
	if(n<0){putchar('-');n=-n;}
	if(n>9){write(n/10);}
	putchar(n%10+'0');
}
```

---


# [yLCPC2024] E. Latent Kindom

## 题目背景

扶苏和 10circle 老师正在拼机游玩最新最热歌曲 Latent Kindom（LK）！

LK 这首歌共有 $n$ 个难度的谱面，第 $i$ 个难度的谱面有 $l_i$ 个音符，分别是 $a_{i, 1}, a_{i, 2}, \dots a_{i, l_i}$，构成了一个序列。

扶苏想知道，如果她开难度为 $i$ 的谱面，10circle 老师开难度为 $j$ 的谱面，那么两个谱面的音符序列合并起来的中位数是多少。

## 题目描述

给定 $n$ 个序列 $a_1, a_2, \dots a_n$。你要回答 $q$ 次询问，每次询问会给出 $i, j$，你要求出序列 $a_i$ 和 $a_j$ 拼接后的中位数是多少。

拼接两个序列 $x, y$ 指的是把 $y$ 序列中的数依次写在 $x$ 序列后面。如果得到的序列长度为 $t$，中位数指的是序列中第 $\left\lceil\frac t 2 \right\rceil$ 小的数字。其中 $\left\lceil x \right\rceil$ 表示不小于 $x$ 的最小整数。

需要注意的是，本题的询问是独立的。也就是说，虽然你要回答假设 $a_i$ 和 $a_j$ 拼接后的中位数，但是不会真的进行对数列拼接的操作。

## 说明/提示

#### 提示

请注意大量的数据读入输出对程序效率造成的影响，使用合适的读入输出方式，不要频繁刷新输出缓冲区，避免超时。

## 样例 #1

### 输入

```
1
3 3
1 1
2 2 3
3 4 5 6
1 2
1 3
2 3```

### 输出

```
2
4
4```

# 题解

## 作者：scp020 (赞：13)

# P10237 [yLCPC2024] E. Latent Kindom 题解

简单的单 $\log$ 做法，不用会任何的数据结构就可以看懂。

## 解法

考虑把每个序列 $a_i$ 升序排序，这样方便我们二分。

考虑将两个序列 $a_x,a_y$ 合并，即选出在这两个序列中排名为 $\lceil \dfrac{len_x+len_y}{2} \rceil$ 的数，我们把合并后的序列分为两部分，一部分是小于等于中位数的，一部分是大于中位数的。我们发现小于等于中位数的那部分在 $a_x$ 和 $a_y$ 里是连续分布的，故我们考虑二分小于等于中位数的那部分在 $a_x$ 中的分布情况。如图，该部分分布情况即为两个竖线左侧的连续区间。

![图](https://cdn.luogu.com.cn/upload/image_hosting/712q3kkw.png)

当前 $mid$ 合法当且仅当 $a_{x,mid}$ 和 $a_{y,\lceil \frac{len}{2} \rceil -mid}$ 都小于等于红色圈起来的两个数（即黑色竖线右侧的两个数）。

考虑如何移动二分的 $l,r$。当上面的黑色竖线比下面的红色圈大时，我们要把上面的黑色竖线向左移动，下面的黑色竖线向右移动；否则我们就把下面的黑色竖线向左移动，上面的黑色竖线向右移动，直到当前 $mid$ 合法。

复杂度分析：排序复杂度 $\mathcal{O}(n \log l)$，查询复杂度 $\mathcal{O}(q \log l)$，所以总复杂度 $\mathcal{O}((n+q) \log l)$。

在排序时这里有个小 trick，就是在 $a_i$ 的前后放置两个标兵，一个极小值，一个极大值，防二分时越界。

## 代码

```cpp
#include<bits/stdc++.h>
namespace fast_IO
{
	/**
	 * 快读快写
	*/
};
using namespace fast_IO;
#define int long long
int t,n,q,len[1000010];
std::vector<int> v[1000010];
inline int check(int x,int y,int lx,int ly)
{
	int midi=std::max(v[x][lx],v[y][ly]);
	if(midi<=v[x][lx+1] && midi<=v[y][ly+1]) return 1;
	if(midi>v[x][lx+1]) return 0;
	return 2;
}
signed main()
{
	in>>t;
	while(t--)
	{
		in>>n>>q;
		for(int i=1,x;i<=n;i++)
		{
			in>>len[i],v[i].clear(),v[i].push_back(-1),v[i].push_back(0x7fffffffffffffff);
			for(int j=1;j<=len[i];j++) in>>x,v[i].push_back(x);
			std::sort(v[i].begin(),v[i].end());
		}
		for(int i=1,tlen,x,y,l,r,mid,ret,ans;i<=q;i++)
		{
			in>>x>>y,tlen=len[x]+len[y],tlen=ceil(tlen/2.0);
			l=std::max(0ll,tlen-len[y]),r=std::min(len[x],tlen);
			while(l<=r)
			{
				mid=(l+r)/2,ret=check(x,y,mid,tlen-mid);
				if(ret==1)
				{
					ans=std::max(v[x][mid],v[y][tlen-mid]);
					break;
				}else if(ret==0) l=mid+1;
				else r=mid-1;
			}
			out<<ans<<'\n';
		}
	}
	fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
	return 0;
}
```

---

## 作者：luogu_gza (赞：5)

问题简洁明了。

我们二分这个中位数，再利用 upper_bound 求出两个数列中比它小的数的个数，判断这个个数与 $\lceil \frac t2 \rceil$ 之间的大小关系，来更新二分边界。

可惜这样做是 $O(n \log n \log w)$ 的，无法通过。

容易发现两个数列合并后的中位数一定在原数列中位数之间，所以提前计算出每个原数列的中位数，把而二分的上下界改一下即可。

这样做甚至可以比部分正解跑得快。

[record](https://www.luogu.com.cn/record/150137506)。

---

## 作者：251Sec (赞：4)

容易发现这个东西就是 [UOJ52](https://uoj.ac/problem/52) 的弱化版，直接套用原题做法。我们要求两个有序序列 $a$ 和 $b$ 并的 $k$ 小值，每次考虑 $a_{\lfloor\frac{k}{2}\rfloor}$ 和 $b_{\lfloor\frac{k}{2}\rfloor}$ 的大小关系，可以发现较小的那一个序列的前面 $\lfloor\frac{k}{2}\rfloor$ 项一定不会成为答案，那么直接让 $k$ 减去 $\lfloor\frac{k}{2}\rfloor$ 然后去掉较小的序列的前 $\lfloor\frac{k}{2}\rfloor$ 项就可以了。直到 $k$ 足够小的时候就可以暴力了。可以发现复杂度是一个 $\log$ 的。

细节挺多的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n, q;
vector<ll> a[1000005];
int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d%d", &n, &q);
		for (int i = 1; i <= n; i++) {
			int s; scanf("%d", &s);
			a[i].resize(s);
			for (int j = 0; j < s; j++) scanf("%lld", &a[i][j]);
			sort(a[i].begin(), a[i].end());
		}
		while (q--) {
			int x, y; scanf("%d%d", &x, &y);
			int k = a[x].size() + a[y].size();
			k = (k + 1) / 2;
			int pa = 0, pb = 0;
			while (k > 2 && pa < a[x].size() && pb < a[y].size()) {
				int da = min(k / 2, (int)a[x].size() - pa), db = min(k / 2, (int)a[y].size() - pb);
				int ta = pa + da, tb = pb + db;
				if (a[x][ta - 1] < a[y][tb - 1]) pa = ta, k -= da;
				else pb = tb, k -= db;
			}
			if (pa == a[x].size()) {
				printf("%lld\n", a[y][pb + k - 1]);
				continue;
			}
			else if (pb == a[y].size()) {
				printf("%lld\n", a[x][pa + k - 1]);
				continue;
			}
			if (k == 2) {
				if (a[x][pa] < a[y][pb]) pa++;
				else pb++;
			}
			if (pb == a[y].size() || (pa != a[x].size() && a[x][pa] < a[y][pb])) printf("%lld\n", a[x][pa]);
			else printf("%lld\n", a[y][pb]);
		}
	}
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：3)

其实不需要任何数据结构就能做。

考虑每次都从两个数组中取出前 $\lfloor\dfrac{k}{2}\rfloor$ 个数，比较第 $\lfloor\dfrac{k}{2}\rfloor$ 个数的大小，如果 $a_i$ 数组中的第 $\lfloor\dfrac{k}{2}\rfloor$ 个数比 $a_j$ 中的小，显然 $a_i$ 中的前 $\lfloor\dfrac{k}{2}\rfloor$ 个数都应该比第 $k$ 个数小，可以直接删掉，每次处理后 $k\gets k-\lfloor\dfrac{k}{2}\rfloor$。正确性显然。总时间复杂度 $O(n\log n)$。跑的很快。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
const int inf=1e18+1;
int T,n,q,l[N],b[N],len;
vector<int>a[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int solve(int ida,int i,int idb,int j,int k){
	if(i>=a[ida].size())return a[idb][j+k-1];
	if(j>=a[idb].size())return a[ida][i+k-1];
	if(k==1)return min(a[ida][i],a[idb][j]);
	int mida=(i+k/2-1)<a[ida].size()?a[ida][i+k/2-1]:inf;
	int midb=(j+k/2-1)<a[idb].size()?a[idb][j+k/2-1]:inf;
	if(mida<midb)return solve(ida,i+k/2,idb,j,k-k/2);
	else return solve(ida,i,idb,j+k/2,k-k/2);
}
void write(int x){
	if(x < 0){putchar('-'); x = -x;}
	if(x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
signed main(){
	//freopen("std.in","r",stdin);
	T=read();
	while(T--){
		n=read();q=read();len=0;
		for(int i=1;i<=n;i++){
			l[i]=read();a[i].clear();
			for(int j=1;j<=l[i];j++){
				int x;x=read();a[i].push_back(x);
			}
			sort(a[i].begin(),a[i].end());
		}
		while(q--){
			int i,j;i=read();j=read();
			int k=(l[i]+l[j]+1)/2;
			write(solve(i,0,j,0,k));putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Walrus (赞：1)

## 题意
给你 $n$ 个序列，每次询问两个序列拼在一起后的中位数。

## 做法
中位数的题绝大部分都是二分套某些数据结构（当然也有裸二分）。

求一个序列里的中位数，当序列有序时，根据题意可得中位数应为某个序列中第 $\lceil \dfrac{len}{2} \rceil$ 小的，所以若一个数是某个区间的中位数，其一定满足小于它的数最多只有 $\lfloor \dfrac{len}{2} \rfloor$ 个，所以二分 check 就显而易见。

由于值域过大，会导致朴素二分复杂度过大，所以考虑离散化，这样最多有 $10^6$ 个不同数字，可以通过本题。

~~难道我的做法是双 $\log$ 的？~~

注意离散化时将所有元素拉通后再离散化。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 5;

int n, q, t, k, x, y;
int b[N];
vector<int> a[N];



signed main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr), cout.tie(nullptr);
	
	cin >> t;
	while(t--) {
		cin >> n >> q;
		int tot = 0;
		for(int i = 1; i <= n; ++i) {
			a[i].clear(), cin >> k;
			for(int j = 1; j <= k; ++j)
				cin >> x, a[i].push_back(x), b[++tot] = x;
		}
		sort(b + 1, b + 1 + tot);
		int len = unique(b + 1, b + 1 + tot) - b - 1;
		for(int i = 1; i <= n; ++i) {
			for(int j = 0; j < a[i].size(); ++j)
				a[i][j] = lower_bound(b + 1, b + 1 + len, a[i][j]) - b;
			sort(a[i].begin(), a[i].end());
		}
		while(q--) {
			cin >> x >> y;
			int l = 1, r = 1e6;
			int L = a[x].size(), R = a[y].size();
			int len = L + R - 1 >> 1;
			while(l < r) {
				int mid = l + r + 1 >> 1;
				int X = lower_bound(a[x].begin(), a[x].end(), mid) - a[x].begin(),
					Y = lower_bound(a[y].begin(), a[y].end(), mid) - a[y].begin();
				if(X + Y <= len)
					l = mid;
				else
					r = mid - 1;
			}
			cout << b[l] << '\n';
		}
	}
	return 0;
}
```

我认为是 $O(N \log N)$ 的，如有不同意见当然可以交流。

---

## 作者：operator_ (赞：0)

# P10237 [yLCPC2024] E. Latent Kindom

[题目传送门](https://www.luogu.com.cn/problem/P10237)

## 题解

考虑一个更强的题，即求两个有序数组中的第 $k$ 小的数。把两个数组记作 $a,b$。

那么你发现前 $k$ 小的数一定是 $a$ 的一段前缀和 $b$ 的一段前缀，我们用 $(i,j)$ 表示 $a$ 的前 $i$ 个数和 $b$ 的前 $j$ 个数组成的状态。

不妨二分 $i$，则 $j=k-i$。那么如果 $a_{i+1}<b_j$，则用 $a_{i+1}$ 替换 $b_j$ 更优，即左边界移动；同理的，如果 $a_{i}>b_{j+1}$，则用 $b_{j+1}$ 替换 $a_i$ 更优，即右边界移动。最终一定能得到合法的 $(i,k-i)$，此时 $\max(a_i,b_{k-i})$ 即为答案。

为了更直观的理解以上过程，你可以考虑我们要寻找一个 $i$，使区间 $[a_i,a_{i+1}]$ 与 $[b_{k-i},b_{k-i+1}]$ 有交，而 $[a_i,a_{i+1}]$ 随着 $i$ 的增大而向右移动，$[b_{k-i},b_{k-i+1}]$ 随着 $i$ 的增大而向左移动，因此存在单调性。

代码实现上可能需要注意一下边界，复杂度每次询问一只 $\log$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
int t,n,q,ll[1000005];
vector<int> a[1000005];
signed main(){
    cin>>t;
    while(t--) {
        n=rd(),q=rd();
        for(int i=1;i<=n;i++) {
            ll[i]=rd();a[i].clear();
            a[i].push_back(0);a[i].push_back((int)4e18);a[i].push_back((int)4e18);
            for(int j=1;j<=ll[i];j++) a[i].push_back(rd());
            sort(a[i].begin(),a[i].end());
        }
        while(q--) {
            int i=rd(),j=rd(),k=(ll[i]+ll[j]-1)/2+1,l=max(0ll,k-ll[j]),r=min(ll[i],k),ans;
            while(l<=r) {
                int ii=(l+r)/2,jj=k-ii;
                if(a[i][ii]>a[j][jj+1]) r=ii-1;
                else if(a[i][ii+1]<a[j][jj]) l=ii+1;
                else {ans=ii;break;}
            }
            printf("%lld\n",max(a[i][ans],a[j][k-ans]));
        }
    }
    return 0;
}
```

---

## 作者：xiaosi4081 (赞：0)

# P10237 [yLCPC2024] E. Latent Kindom 题解

首先，看到求第 $k$ 小数字，又看到本题的大时限和空间，不难想到权值线段树。

于是就有了下面的做法。尝试对于每一个序列开一颗权值线段树，查询的时候可以将两颗权值线段树合并查询第 $k$ 小。合并不需要真正意义上的合并，只是合并查询，把某个点的权值视为两颗树上对应点的权值和，递归时同时记录两颗子树上对应节点编号。需要使用动态开点缩小空间。

提前离散化一下即可。

本题还有一些需要注意的细节：

1. 多测需要清空。
2. 清空线段树时可以直接边开点边清空。
3. 最后答案输出需要输出离散化前的结果。
4. 请使用较快的输入输出方式。
5. 需要开 `long long`。

剩下的全靠码力。

参考代码如下：

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,l[1000005],root[1000005];
vector<int>a[1000005];
int arr[1000005];
struct trnode{
	int l,r,sum;
}d[21000005];int cnt=0;
void pushup(int p){
	d[p].sum=d[d[p].l].sum+d[d[p].r].sum;
}
int query(int s,int t,int k,int p1,int p2){
	if(s==t)return s;
	int mid=s+t>>1;
	if(d[d[p1].l].sum+d[d[p2].l].sum>=k){
		return query(s,mid,k,d[p1].l,d[p2].l);
	}
	else return query(mid+1,t,k-d[d[p1].l].sum-d[d[p2].l].sum,d[p1].r,d[p2].r);
}
void update(int x,int s,int t,int p){
	if(s==t)return d[p].sum++,void();
	int mid=s+t>>1;
	if(x<=mid)update(x,s,mid,d[p].l?d[p].l:(d[++cnt]={0,0,0},d[p].l=cnt));
	else update(x,mid+1,t,d[p].r?d[p].r:(d[++cnt]={0,0,0},d[p].r=cnt));
	pushup(p);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int t;cin>>t;
	while(t--){
		cin>>n>>q;
		for(int i=1;i<=n;i++)root[i]=0,a[i].clear();
		arr[0]=0;cnt=0;
		for(int i=1;i<=n;i++){
			cin>>l[i];
			for(int j=1,x;j<=l[i];j++){
				cin>>x;
				arr[++arr[0]]=x;
				a[i].push_back(x);
			}
		}
		sort(arr+1,arr+1+arr[0]);
		int k=unique(arr+1,arr+1+arr[0])-arr-1;
		for(int i=1;i<=n;i++){
			if(!root[i])root[i]=++cnt,d[cnt]={0,0,0};
			for(int j=0;j<a[i].size();j++){
				update(lower_bound(arr+1,arr+1+k,a[i][j])-arr,1,k,root[i]);
			}
		}
		for(int i=1;i<=q;i++){
			int x,y;cin>>x>>y;
			int lshh=query(1,k,(l[x]+l[y]-1)/2+1,root[x],root[y]);
			cout<<arr[lshh]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

考虑将所有序列合并在一起成为一个主序列，设第 $i$ 个序列在区间 $[L_i,R_i]$ 范围内。

那么一次查询相当于求 $[L_x,R_x],[L_y,R_y]$ 两个区间内所有数中第 $\lfloor \frac{l_x+l_y}{2} \rfloor$ 小的数。

发现是一个主席树板子，于是做完了。

时间复杂度为 $O(T (N+Q) \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define INF INT_MAX
using namespace std;
typedef long long ll;
const ll N=1000100,M=50;
inline ll read(){ 
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r;
	ll data;
}X[N*M];
ll T,n,q,x,y,z,t=0,s;
ll a[N],b[N],l[N],r[N],H[N],root[N];
void build(ll &k,ll l,ll r){
	k=++t;
	if(l==r)
	  return ;
	ll mid=(l+r)>>1;
	build(X[k].l,l,mid);
	build(X[k].r,mid+1,r);
	return ;
}
void updata(ll &k,ll l,ll r,ll i){
	X[++t]=X[k];
	X[t].data=X[k].data+1;
	k=t;
	if(l==r)
	  return ;
	ll mid=(l+r)>>1;
	if(i<=mid)
	  updata(X[k].l,l,mid,i);
	else
	  updata(X[k].r,mid+1,r,i);
}
ll qurey(ll u1,ll v1,ll u2,ll v2,ll l,ll r,ll k){
//	cout<<l<<' '<<r<<'\n';
	if(l==r)
	  return b[l];
	ll mid=(l+r)>>1,t=X[X[v1].l].data-X[X[u1].l].data+X[X[v2].l].data-X[X[u2].l].data;
//	cerr<<l<<' '<<r<<' '<<t<<'\n';
	if(t>=k)
	  return qurey(X[u1].l,X[v1].l,X[u2].l,X[v2].l,l,mid,k);
	else
	  return qurey(X[u1].r,X[v1].r,X[u2].r,X[v2].r,mid+1,r,k-t);
}
void solve(){
	t=read(),q=read();
	for(int x,i=1;i<=t;i++){
		x=read();
		l[i]=r[i-1]+1;
		r[i]=l[i]+x-1;
		for(int j=l[i];j<=r[i];j++)
		  a[j]=b[j]=read();
//		cerr<<l[i]<<' '<<r[i]<<'\n';
		H[i]=x;
	}
	n=r[t];
	t=0;
	sort(b+1,b+n+1);
	s=unique(b+1,b+n+1)-b-1;
	root[0]=1;
	build(root[0],1,s);
	for(int i=1;i<=n;i++){
		ll v=lower_bound(b+1,b+s+1,a[i])-b;
		root[i]=root[i-1];
		updata(root[i],1,s,v);
	}
	while(q--){
		x=read(),y=read();
		write(qurey(root[l[x]-1],root[r[x]],root[l[y]-1],root[r[y]],1,s,(H[x]+H[y]+1)>>1));
		putchar('\n');
	}
}
int main(){
	T=read();
	while(T--)
	  solve();
	return 0;
}
```

---

## 作者：harmis_yz (赞：0)

## 分析

一眼了非最优解。

考虑二分答案。对于二分出来的中位数 $x$，到 $a_i$ 和 $a_j$ 里边又去二分。得到两个序列中不超过 $x$ 的数的数量。若这个数量 $cnt \ge \lceil \frac{len_{i}+len_{j}}{2} \rceil$，则 $x$ 可能成为中位数，然后继续二分即可。

把序列离散化，复杂度为 $O(n\log^2 n)$，然后因为 3s 就过了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define pii pair<int,int>
#define x first
#define y second
#define gc getchar()
#define rd read()
#define debug() puts("------------")

namespace yzqwq{
	il int read(){
		int x=0,f=1;char ch=gc;
		while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=gc;}
		while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=gc;
		return x*f;
	}
	il int qmi(int a,int b,int p){
		int ans=1;
		while(b){
			if(b&1) ans=ans*a%p;
			a=a*a%p,b>>=1;
		}
		return ans;
	}
	il auto max(auto a,auto b){return (a>b?a:b);}
	il auto min(auto a,auto b){return (a<b?a:b);}
	il int gcd(int a,int b){
		if(!b) return a;
		return gcd(b,a%b);
	}
	il int lcm(int a,int b){
		return a/gcd(a,b)*b;
	}
	il void exgcd(int a,int b,int &x,int &y){
		if(!b) return x=1,y=0,void(0);
		exgcd(b,a%b,x,y);
		int t=x;
		x=y,y=t-a/b*x;
		return ;
	}
	mt19937 rnd(time(0));
}
using namespace yzqwq;

const int N=5e6+10;
int n,q,b[N],idx;
int len[N];
vector<int> a[N];

il bool check(int x,int y,int z){
	int l1=0,r1=len[x]-1,w1=-1;
	while(l1<=r1){
		int mid=l1+r1>>1;
		if(a[x][mid]<=z) w1=mid,l1=mid+1;
		else r1=mid-1;
	}
	int l2=0,r2=len[y]-1,w2=-1;
	while(l2<=r2){
		int mid=l2+r2>>1;
		if(a[y][mid]<=z) w2=mid,l2=mid+1;
		else r2=mid-1;
	}
	int Len=len[x]+len[y];
	Len=(Len-1)/2+1;
	int s1=0,s2=0;
	s1=w1-0+1;
	s2=w2-0+1;
	return s1+s2>=Len;
}

il void solve(){
	n=rd,q=rd;idx=0;
	for(re int i=1;i<=n;++i){
		len[i]=rd;
		a[i].clear();
		for(re int j=1;j<=len[i];++j)
			b[++idx]=rd,a[i].push_back(b[idx]);
		sort(a[i].begin(),a[i].end());
	}
	sort(b+1,b+idx+1),idx=unique(b+1,b+idx+1)-(b+1);
	for(re int i=1;i<=n;++i){
		for(re int j=0;j<len[i];++j){
			a[i][j]=lower_bound(b+1,b+idx+1,a[i][j])-b;
		}
	}
	while(q--){
		int x=rd,y=rd;
		int l=1,r=idx+1,ans=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(check(x,y,mid)) ans=mid,r=mid-1;
			else l=mid+1;
		}
		printf("%lld\n",b[ans]);
	}
	return ;
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int t=rd;while(t--)
	solve();
	return 0;
}

```

---


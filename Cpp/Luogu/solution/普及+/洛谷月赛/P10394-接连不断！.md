# 接连不断！

## 题目背景

小青蛙被关进了监狱的小黑屋里，他遭受了接连不断的折磨，无论是肉体上还是精神上。

他的精神萎靡不振，他的身体行动迟缓。

有些东西被暂时的压制了，但这些东西越是被压制，它反弹时威力就越大。

他需要一个契机。

## 题目描述

青蛙有 $m+1$ 个无向图，编号为 $0\sim m$。每个图的点集都是 $V$，点集 $V$ 包含 $n$ 个点，编号为 $0\sim n-1$。起初所有的图都没有边存在。

接下来，在编号为 $x$ 的图中，对于所有在 $[0, n - 1]$ 中的编号 $i$，青蛙会将编号为 $i$ 的点与编号为 $(i\cdot x)\bmod n$ 的点连一条无向边。

他想知道这 $m+1$ 个图中有多少个图是**连通的**，这个问题交给你来回答。

注：
1. $\bmod$ 表示取模，$a\bmod b$ 表示 $a$ 除以 $b$ 得到的余数。
2. 在一张图中，若在点集内任意两个不同的点 $x, y$ 之间存在至少一条路径，则我们称这个图是**连通的**。

## 说明/提示

**【样例 #1 解释】**

询问 1：

| 图的编号 | 边集 | 图是否连通 |
| :------: | :-----------------: | :--------: |
|   $0$    | $(0,0),(1,0),(2,0)$ |     是     |
|   $1$    | $(0,0),(1,1),(2,2)$ |     否     |
|   $2$    | $(0,0),(1,2),(2,1)$ |     否     |

询问 2：

| 图的编号 |    边集    | 图是否连通 |
| :------: | :-----------------------: | :--------: |
|   $0$    | $(0,0),(1,0),(2,0),(3,0)$ |     是     |
|   $1$    | $(0,0),(1,1),(2,2),(3,3)$ |     否     |
|   $2$    | $(0,0),(1,2),(2,0),(3,2)$ |     是     |
|   $3$    | $(0,0),(1,3),(2,2),(3,1)$ |     否     |
|   $4$    | $(0,0),(1,0),(2,0),(3,0)$ |     是     |

询问 3：

| 图的编号 |   边集    | 图是否连通 |
| :------: | :-----------------------: | :--------: |
|   $0$    | $(0,0),(1,0),(2,0),(3,0),(4,0)$ |     是     |
|   $1$    | $(0,0),(1,1),(2,2),(3,3),(4,4)$ |     否     |
|   $2$    | $(0,0),(1,2),(2,4),(3,1),(4,3)$ |     否     |
|   $3$    | $(0,0),(1,3),(2,1),(3,4),(4,2)$ |     否     |
|   $4$    | $(0,0),(1,4),(2,3),(3,2),(4,1)$ |     否     |
|   $5$    | $(0,0),(1,0),(2,0),(3,0),(4,0)$ |     是     |

所以答案分别为 $1, 3, 2$。

---

**【数据规模与约定】**

**本题开启捆绑测试。**

| $\text{Subtask}$ | 数据范围 | 分数 |
| :---: | :---: | :---: |
| $1$ | $n,m\le 200$ | $15$ |
| $2$ | $n,m\le 3000$ | $30$ |
| $3$ | $n,m\le 10^7$ | $15$ |
| $4$ | $n\le 3000,m \le10^{14}$ | $15$ |
| $5$ | $n,m\le 10^{14}$ | $25$ |

- 对于 $100\%$ 的数据，保证 $1\le T\le 5,1\le n,m\le 10^{14}$。


## 样例 #1

### 输入

```
3
3 2
4 4
5 5```

### 输出

```
1
3
2
```

## 样例 #2

### 输入

```
5
4 3
4 4
4 5
4 6
4 7```

### 输出

```
2
3
3
4
4
```

## 样例 #3

### 输入

```
3
1145 1499
12344 123456
114514 1919810```

### 输出

```
2
41
17```

# 题解

## 作者：lzy20091001 (赞：10)

[洛谷 P10394 接连不断！](https://www.luogu.com.cn/problem/P10394)

## 分析

编号为 $0$ 的图显然满足题意。

在编号为 $x \ (x \ne 0)$ 的图中，每一个点都只会连出一条边，而编号为 $0$ 的点总是和自己连边，这意味着有效的边至多有 $n - 1$ 条。而这张图要求连通，那么这张图一定是一棵树，$n - 1$ 条边都是有效的，具体地，没有重边和环。

我们指定 $(i \cdot x) \bmod n$ 是 $i$ 的父亲，那么这棵树就会呈现以编号为 $0$ 的点为根的形态。这是因为除编号为 $0$ 的点都没有自环，向父亲回溯时只有走到编号为 $0$ 的点才会停止。在这个形态下观察这棵树，指定根结点 $0$ 在第 $0$ 层，则对于第 $k$ 层的点 $i$，有 $i \cdot x ^ k \equiv 0 \pmod n$。

因此问题转化为对于 $x \in [1, m]$，有哪些 $x$ 满足对于任意 $i \in [1, n - 1]$ 都可以找到一个最小的 $k$ 使得 $i \cdot x ^ k \equiv 0 \pmod n$。

结论是当且仅当 $x$ 是 $n$ 质因数的乘积的倍数时满足要求。下面给出证明。

由唯一分解定理，设 $n = \prod _ {i = 1} ^ {s} p _ i ^ {r _ i}$（其中 $p$ 为质数），记 $t = \prod _ {i = 1} ^ {s} p _ i$，不妨设 $ x = c \cdot t$。

- 必要性：一定存在 $i \in [1, n - 1]$ 且 $i \perp n$（如 $i = n - 1$）。若 $x \ne c \cdot t$，则 $n$ 有 $i \cdot x ^ k$ 所没有的质因子，所以 $i \cdot x ^ k \equiv 0 \pmod n$ 总不成立。
- 充分性：$x = c \cdot t$ 时，$k = \max _ {i = 1} ^ {s} \{r _ i \}$ 时显然满足，不断枚举 $k \gets k - 1$ 直到 $i \cdot x ^ {k - 1} \equiv 0 \pmod n$ 不成立即可找到最小的 $k$。

$[1, m]$ 中有 $\lfloor \dfrac{m}{t} \rfloor$ 个整数是 $t$ 的倍数，再加上编号为 $0$ 的图，所以最终的答案即为 $\lfloor \dfrac{m}{t} \rfloor + 1$，其中 $t$ 为 $n$ 所有质因数的乘积。

将 $n$ 分解质因数的方法可以参考 [OI Wiki](https://oi-wiki.org/math/number-theory/pollard-rho/)，本题中 $O (\sqrt n)$ 的朴素方法即可通过，这样最终的时间复杂度为 $O(T \sqrt n)$。

## 实现

```cpp
#include <iostream>

long long f(long long n) // n 所有质因数的乘积
{
    long long res = 1;
    for (int i = 2; 1ll * i * i <= n; i++)
    {
        if (n % i == 0)
            res *= i;
        while (n % i == 0)
            n /= i;
    }
    if (n != 1)
        res *= n;
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--)
    {
        long long n, m;
        std::cin >> n >> m;
        std::cout << m / f(n) + 1 << "\n";
    }

    return 0;
}
```

---

## 作者：abc1856896 (赞：4)

~~小清新结论题~~

# solution
初看是一道图论题，但看到模就知道这是一道数论题。

首先，$0$ 在取模中十分特殊。所以编号是 $0$ 的图显然是满足的。

也就是说在 $1 \sim n-1$ 中的任意一个点，都存在一条到点 $0$ 的路径。形式化的，对于任意一条边都存在 $i \to j \ \to \cdots \to 0$。

这个条件就相当于存在一个正整数 $k$ 使得 $i \times x^t \bmod n=0$。那么问题就转化为什么样的 $x$ 使得任意的 $i$ 都满足条件。

我们对 $n$ 质因数分解，那 $n=p_1^{q_1} \times p_2^{q_2} \times \cdots \times p_r^{q_r}$，而 $x=p_1 \times p_2 \times \cdots \times p_r \times t$，其中 $t$ 为任意自然数且 $x$ 不大于 $m$。

那么答案就显而易见了，答案等于 $\lfloor \frac{m}{p_1 \times p_2 \times \cdots \times p_r} \rfloor +1$

由于 $n$ 的数据范围不大，所以我们直接质因数分解就行了。

时间复杂度 $O(T\sqrt(n))$。

# code
```cpp
#define int long long

int n, m;

void solve() {

	cin >> n >> m;

	int ans = 1, t = n;

	for (int i = 2; i * i <= t; i++) {

		if (n % i == 0) ans *= i;

		while (n % i == 0) n /= i;

	}

	if (n > 1) ans *= n;

	cout << m / ans + 1 << endl;

}
```

---

## 作者：strcmp (赞：3)

并不难想的题，但是被这题硬控半小时，乐，边玉玉边写题解是这样的。

$0$ 乘以任何数都是 $0$，这提示我们这题的 $0$ 结点很关键。另外 $0$ 必然有一个自环，所以去自环后，整张图合法的话必定是一棵树。

如果你找一找规律，就会发现被判不联通的图，非 $0$ 结点都不存在到 $0$ 的边。

考虑 $x^k \equiv 0 \pmod n$ 且 $k$ 是满足条件的最小的 $k$。（显然如果存在这个 $k$ 则 $k < n$）

你发现如果存在 $k$ 使得 $x^k \equiv 0 \pmod n$，那么 $1$ 每次变成 $1 \to x \to x^2 \to x^3 \to \dots \to x^k = 0$ 必然与 $0$ 联通，同理 $2$ 每次变成 $2 \to 2x \to 2x^2 \to 2x^3 \to \dots \to 2x^k = 0$，也必然与 $0$ 联通，这里的乘法都在模 $n$ 意义下进行。

对于所有 $a \in [0,\,n)$ 都有这个结论，即它们都与 $0$ 联通，进而当前图是联通的。

于是存在 $x^k \equiv 0 \pmod n$ 是编号为 $x$ 的图合法的一个充分条件。

再来证明这个东西的必要性，它的必要性也是很显然的。考虑反证法，因为如果不存在 $x^k \equiv 0 \pmod n$，你考虑 $1$ 开始的序列 $1 \to x \to x^2 \to x^3 \to \dots \to x^{n - 1}$。它要么存在 $x^k \equiv 1 \pmod n,\,k < n$，形成了一个环，因为我们是树所以显然不合法；要么 $1$ 到 $x^{n - 1}$ 都没有重，然后你发现这覆盖了所有 $1 \dots n - 1$ 的结点，而且都没有到 $0$ 的边，因此也不合法。

横竖都不合法，因此存在 $x^k \equiv 0 \pmod n$ 是编号为 $x$ 的图合法的充要条件。

$x = 0$ 显然合法，$x = 1$ 显然不合法。接下来相当于计数编号在 $x \in [2,\,m]$ 的图中，满足 $x^{d} \equiv 0 \pmod n$ 的数，这里的 $d$ 取一个极大数（比如 $10^{10^{10}}$）

那么就很好做了，$x$ 出现的质因数种类包含 $n$ 出现的质因数种类就行了。

所以对 $n$ 分解质因数，分解成 $\prod p_i^{a_i}$ 的形式，若 $a_i > 0$，则 $x$ 必须包含 $p_i$，考虑找出最小的 $x$。即 $\prod p_i^{[a_i > 0]}$，则所有的合法 $x$ 都是它的倍数，答案即为 $\lfloor\frac{m}{\prod p_i^{[a_i > 0]}}\rfloor + 1$。

时间复杂度 $\Theta(T\sqrt n)$，瓶颈在分解质因数。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
using namespace std;
typedef long long int ll;
using pii = pair<int, int>;
const int maxn = 2e5 + 10;
constexpr int mod = 1e9 + 7;
int t; ll n, m;
int main() {
	scanf("%d", &t);
	while (t--) {
		scanf("%lld%lld", &n, &m); ll s = 1;
		for (ll i = 2; i * i <= n; i++) {
			if (n % i == 0) {
				s *= i;
				while (n % i == 0) n /= i;
			}
		}
		if (n != 1) s *= n;
		printf("%lld\n", m / s + 1);
	}
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：3)

# P10934 题解

## 题目分析

拿到这道题目，看了数据范围 $ 1 \le n,m \le 10^{14}$，不可能是数位 dp 之类的，那大概率是找规律。

题目的 说明/提示 中，连通图的出现情况分别是：是否否、是否是否是、是否否否否是。

所以猜想，会不会连通图与非连通图的出现是以某种形式交替或循环出现呢？

## 打表找规律

暴力的做法很简单，肯定是直接用并查集，但是这样肯定是会 MLE 和 TLE 的，不过这种做法可以放在打表这里，用 $1$ 表示连通图，用 $0$ 表示非连通图，看看每一个 $N$ 对应的前若干张图，两个 $1$ 之间放了几个 $0$。

所以打表代码很容易写出：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=3005;

int T;
int n,m;
int ans;

int p[N][N];

int find(int g,int x) {
    if (p[g][x]!=x) return p[g][x]=find(g,p[g][x]);
    return p[g][x];
}

int main() {
    n=24,m=50;
    for (n=2;n<=49;++n) {
        printf("%d: ",n);
        for (int j=0;j<=254;++j) {
            for (int t=0;t<=254;++t) {
                p[j][t]=t;
            }
        }
        for (int x=0;x<=m;++x) {
            for (int i=0;i<=n-1;++i) {
                int k=find(x,p[x][i]);
                int t=find(x,p[x][(i*x)%n]);
                p[x][k]=t;
                // cout<<x<<" "<<i<<" "<<(i*x)%n<<endl;
            }
        }
        int cnt=0;
        for (int i=0;i<=m;++i) {
            bool ok=true;
            for (int j=1;j<=n-1;++j) {
                // cout<<i<<" "<<find(i,j)<<endl;
                if (find(i,j)!=find(i,0)) ok=false;
            }
            // printf("%d ",ok);
            cnt++;
            if (ok) {
                printf("%d ",cnt);
                cnt=0;
            }
        }
        putchar(10);
    }
    return 0;
}
```

输出如下：

```
2: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 
3: 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 
4: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 
5: 1 5 5 5 5 5 5 5 5 5 5 
6: 1 6 6 6 6 6 6 6 6 
7: 1 7 7 7 7 7 7 7 
8: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 
9: 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 
10: 1 10 10 10 10 10 
11: 1 11 11 11 11 
12: 1 6 6 6 6 6 6 6 6
13: 1 13 13 13
14: 1 14 14 14
15: 1 15 15 15
16: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
17: 1 17 17
18: 1 6 6 6 6 6 6 6 6
19: 1 19 19
20: 1 10 10 10 10 10
21: 1 21 21
22: 1 22 22
23: 1 23 23
24: 1 6 6 6 6 6 6 6 6
25: 1 5 5 5 5 5 5 5 5 5 5
26: 1 26 
27: 1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
28: 1 14 14 14
29: 1 29
30: 1 30
31: 1 31
32: 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
33: 1 33
34: 1 34
35: 1 35
36: 1 6 6 6 6 6 6 6 6
37: 1 37
38: 1 38
39: 1 39
40: 1 10 10 10 10 10
41: 1 41
42: 1 42
43: 1 43
44: 1 22 22
45: 1 15 15 15
46: 1 46
47: 1 47
48: 1 6 6 6 6 6 6 6 6
49: 1 7 7 7 7 7 7 7
```

忽略每一个 $N$ 第一个输出的 $1$，后面表示两个 $1$ 之间相隔了几个 $0$ （这个值需要加 $1$）

不难发现，这个数值是将对应的 $N$ 的所有质因数去重后的乘积。

验证一下猜想对不对：

$ 24 = 2 \times 2 \times 2 \times 3 $

质因数去重后乘积：

$ 2 \times 3 = 6 $

正确。

再拿一个数来试一试：

$ 45 = 3 \times 3 \times 5 $

质因数去重后乘积：

$ 3 \times 5 = 15 $

正确。

## 思路

经过打表找规律，发现猜想正确，那么可以照着这个思路来写正解了！

题目求的是连通图数量，那就是求 $1$ 的数量咯！

首先将 $N$ 进行质因数分解，然后将这些数去重后相乘，得到 $K$，然后用 $M+1$ 去除以 $K$，得到这 $M+1$ 张图中出现了几个完整的循环，没有余数，不会出现多余的 $1$，如果有余数，则加 $1$ 后为最终的解。

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

int T;
int n,m;

int findLoop(int k) {
    int cnt=1;
    for (int i=2;i<=sqrt(k);++i) {
        if (k%i) continue;
        cnt*=i;
        while (k%i==0) k/=i;
    }
    cnt*=k;
    return cnt;
}

signed main() {
    scanf("%lld",&T);
    while (T--) {
        scanf("%lld %lld",&n,&m); m++;
        int k=findLoop(n);
        int ans=m/k;
        if (m%k) ans++;
        printf("%lld\n",ans);
    }
    return 0;
}
```

## 总结

这道题其实代码不难写，主要是难想，所以评绿是挺合理的。

遇到此类题目，特别是 $n,m$ 是远超 $10^8$ 的，肯定不能用 $O(n)$ 来解，那就要看看有没有什么规律，可以用 $O(1)$ 来求，或者是分解质因数或分解因数之类的，往这方面想，应该不是特别难找到规律（除非是某些毒瘤题），然后代码就不难写了！

---

## 作者：bilibili_daogu (赞：1)

这道题是一道数论

核心是判断对于给定的  $n$  和  $m$ ，编号为  $0$  到  $m$  的  $m + 1$  个图是否连通。

对于  $x = 0$  ，图是连通的，因为每个节点都与自己相连。对于  $x = 1$  到  $m$ ，需要计算与  $n$  互质的数的数量。

CODE:

```cpp
#include <iostream>
using namespace std;

long long f(long long n)
{
    long long res = 1;

    for (long long i = 2ll; i * i <= n; i++)
    {
        if (n % i == 0)
        {
            res *= i;
            while (n % i == 0)
            {
                n /= i;
            }
        }
    }

    res *= n;

    return res;
}
// 处理测试用例的输入、计算和输出
void p()
{
    long long n, m;
    cin >> n >> m;

    long long result = m / f(n) + 1;
    cout << result << endl;
}

int main()
{
    long long T;
    cin >> T;
    // 处理每组测试用例
    for (long long t = 0; t < T; ++t)
    {
        p();
    }

    return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

等级分 $1300$ 祭！

![](https://cdn.luogu.com.cn/upload/image_hosting/7mggpqe7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

很明显 $0$ 点上总是有自环，那么对答案有贡献的边只有 $n-1$ 条，而图又要求联通，那么这就是一棵树，第 $i$ 点的父亲就是 $i\times x\bmod n$，他的第 $k$ 层祖先为 $(\cdots((i\times x\bmod n)\times x\bmod n)\cdots \times x\bmod n)=i\times x^k\bmod n$。

而一个树是连通的，需要满足对于每个 $i\in[1,n)$，都要满足能通过任意一条路径能到达根节点，即 $i\times x^k\bmod n=0$。

有结论：

$x$ 要整除 $n$ 的所有质因数才行。

证明：

设 $n=\prod\limits_{i=1}^y p_i^{c_i}$，设 $x=a\times\prod\limits_{i=1}^y p_i$，那么 $k$ 就可以 $=\max\limits_{i=1}^y c_i$ 以满足条件，同时这也很明显必须满足这条结论才能让 $x$ 满足上述条件。

也就是说，当 $n=\prod\limits_{i=1}^y p_i^{c_i}$ 时，$x$ 必须整除 $\prod\limits_{i=1}^y p_i$，我们可以求出每个 $p_i$。又 $[0,m]$ 中有 $\lfloor\frac{m}{\prod\limits_{i=1}^y p_i}\rfloor+1$ 个数整除 $\prod\limits_{i=1}^y p_i$，那么答案为 $\lfloor\frac{m}{\prod\limits_{i=1}^y p_i}\rfloor+1$。

时间复杂度为 $O(\sqrt{n})$，瓶颈在于分解质因数以求出 $p$。

---

## 作者：CNS_5t0_0r2 (赞：1)

结论题。

## 分析：

在所有点中有一个很特殊的点：$0$ 号点，因为 $0$ 号点自身不会和其他点连边，只可能是其他点和 $0$ 号点连边。

所以一个图如果连通，那么任意一点肯定存在一条到 $0$ 的路径。

怎么判断？

拿 $1$ 号点举例，$1$ 号点连接 $x \bmod n$ 号节点，$x \bmod n$ 号点连接 $x ^ 2 \bmod n$ 号节点，$x ^ 2 \bmod n$ 号节点连接 $x ^ 3 \bmod n$。这样一直下去，肯定存在 $x^k \bmod n = 0$。

这是判定图是否连通的**充要条件**，下面证明充分性，~~必要性的严格证明我不会~~ 。

---

### 充分性证明：

若存在 $k$ 使 $x ^ k \bmod n = 0$，则对于任意节点 $i$，$i \times x ^ k \bmod n = 0$，也就是说，所有节点都与 $0$ 号节点连通，那么这个图肯定是连通图。

---

充分性、必要性都证明完后，我们对这个结论进行转换：这个结论等价于图的编号 $x$ 包含 $n$ 的所有质因子。

于是，我们对 $n$ 进行时间复杂度 $O(\sqrt{n})$ 的质因数分解。设 $n = p_1^{\alpha_1} p_2^{\alpha_2} \dots p_s^{\alpha_s}$（$p_i$ 为质数，$p_1 < p_2 < \dots < p_s$，$\alpha_i > 0$），记 $tmp = p_1 p_2 \dots p_s$，则连通图应满足其编号 $x$ 为 $tmp$ 的倍数。

## code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int n,m,ans;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> t;
	while(t--){
		cin >> n >> m;
		ans = 1;
		int tmp = n,tmp2 = 1;
		if(!(tmp & 1)){
			tmp2 <<= 1;
			while(!(tmp & 1))
				tmp >>= 1;
		}
		for(int i = 3;i * i <= n;i++){
			if(!(tmp % i)){
				tmp2 *= i;
				while(!(tmp % i))
					tmp /= i;
			}
		}
		if(tmp != 1)
			tmp2 *= tmp;
		ans += m / tmp2;
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：__zhuruirong__ (赞：1)

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P10394)

给定 $m$ 个相同的点集 $a=\{1,2,3\cdots n-1,n\}$。

对于第 $i$ 个点集，将 $\large a_{i,j}$ 和 $\large a_{i,ij\bmod x}$ 之间连一条边，问生成的图中有多少个联通图。

## 做法

好吧，我承认我是找规律找出来的。

观察样例，可以发现样例似乎有点规律：每间隔几个就会出现一个合法的图。

找规律代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int f[100000];

int find(int x) { // 并查集听过吧？
	return x == f[x] ? x : f[x] = find(f[x]);
}

signed main() {
//	ios::sync_with_stdio(0);
//	cin.tie(0); cout.tie(0);
//	freopen(".in", "r+", stdin);
//	freopen(".out", "w+", stdout);
	
	for(int n = 1; n <= 100; n++) {
		int ans = 0;
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < n; j++)
				f[j] =j;
			for(int j = 0; j < n; j++)
				f[find(j)] = find(j * i % n);
			map<int, int> cnt;
			for(int i = 1; i <= n; i++) // 统计
				cnt[find(i)] = 1;
			ans += cnt.size() == 1;
		}
		cout << n << ":" << ans << endl;
	}

	return 0;
}
```

通过这个程序，我们可以发现一个有趣的现象：对于每一个 $n$，$ans$ 都是 $n$ 去掉每个质因数各一个后的结果。

然后可以得出每有 $n\div ans$ 个位置便会出现一个合法的图。


然后代码就不难写出来了。

## AC代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int T, n, m;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
//	freopen(".in", "r+", stdin);
//	freopen(".out", "w+", stdout);

	cin >> T;
	while(T--) {
		cin >> n >> m;
		int x = n, cnt = 1;
		for(int i = 2; i * i <= x; i++) // 分解质因数
			if(x % i == 0) {
				cnt *= i;
				while(x % i == 0)
					x /= i;
			}
		if(x != 1) // 千万别忘了特判 x != 1 的情况
			cnt *= x;
		cout << m / cnt + 1 << endl;
	}

	return 0;
}

/**
*　　┏┓　　　┏┓+ +
*　┏┛┻━━━┛┻┓ + +
*　┃　　　　　　　┃
*　┃　　　━　　　┃ ++ + + +
*  ████━████+
*  ◥██◤　◥██◤ +
*　┃　　　┻　　　┃
*　┃　　　　　　　┃ + +
*　┗━┓　　　┏━┛
*　　　┃　　　┃ + + + +Code is far away from 　
*　　　┃　　　┃ + bug with the animal protecting
*　　　┃　 　 ┗━━━┓ 神兽保佑,代码无bug　
*　　　┃ 　　　　　　 ┣┓
*　　  ┃ 　　　　　 　┏┛
*　    ┗┓┓┏━┳┓┏┛ + + + +
*　　　　┃┫┫　┃┫┫
*　　　　┗┻┛　┗┻┛+ + + +
*/
```

---

## 作者：Mingjunyi (赞：1)

# P10394 接连不断！
### 1.分析 
感谢 学长 [ckain](https://www.luogu.com.cn/user/456415) 的 hint  

对于任意一个图的某一个点，只能向外连一条无向边 即 $i \Rightarrow (i \cdot x) mod\ n$    

------
推论 $1$ ：  
不难发现：任意一个图，$0$ 号位只能指向它自己  
![zero](https://cdn.luogu.com.cn/upload/image_hosting/db5fr3ny.png)  

-----
推论 $2$ ：  
如果在一个图中存在两个环及以上，则必然不连通  

举个简单的例子，如图  
![two_ring](https://cdn.luogu.com.cn/upload/image_hosting/vgchx6v6.png)  
$4$ 号点只能连两个环中之一 

-----
综合两个推论，可以发现：若将所连的边（即 $i \Rightarrow (i \cdot x) mod\ n$）看做有向边，则连通图一定是 **内向基环树**  

![ingoing_pseudotree](https://cdn.luogu.com.cn/upload/image_hosting/raxcvvjz.png)

其中 **$0$ 号位** 一定是一个自环，故连通图中所有点一定与 **$0$ 号位** 连通

所以，对于每一个点,若 存在一个 $k$，使得 $(i \cdot x ^ k)\ mod\ n = 0$ 就肯定与 **$0$ 号位** 连通  

那么对于一个连通图，其中每个点都要和 $0$ 号位相连，只有 $ n | x ^ k$ 时成立  

**那么，$x$ 必须为 $n$ 的所有素因子的乘积 的 $y$ 倍**  

证明: 令 $n = \prod_{i} p_i ^ {k_i} (k \in \mathbb{N} , p \in \mathbb{P}) $，则对于 $x = \prod_{i} p_i$ 必然存在一个 $k^{\prime} = \max{k_i}$，使得 $ n | x^{k^{\prime}}$ ， 自然 $n | y \cdot x^{k^\prime} (y \in \mathbb{N})$

最后只需找出循环节 $x$ 即可

----

### 2.行动
对 $n$ 进行素因子分解，求得循环节长度 $len$  
因为图是从 $0$ 开始编号，在 $m / len$ 后还需 $+1$ 

$code$ :
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

namespace my{

CIN N = 1e6+5;
int n,m,T,ans;
int p[N],c[N],t;

void pm(int num){
	t = 0;
	for(int i = 2;i<= sqrt(num);i++) 
		if(num % i == 0) {
			p[++t] = i;c[t] = 0;
			while(num % i == 0) c[t]++,num/=i;
		}
	if(num > 1) p[++t] = num,c[t] = 1;
}

int check(int num){
	int res = 1;
	for(int i = 1;i<=t;i++) res *= p[i];
	return res;
}

signed main(){
	speed_up(true);
	
	cin>>T;
	while(T--) {
		cin>>n>>m;
		pm(n);
		int len = check(n);
		ans = m / len + 1;
		cout<<ans<<'\n';
	}

	return 0;
}

}

signed main() {
	return my::main();
}
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10394)。

## 思路

提供一个更简单的推法。

对于一个数 $x$，容易知道它会在 $ix\bmod n$ 中产生 $\gcd(x,n)$ 个循环，不同循环之间肯定会存在边相连，那么判断 $[x,n]$ 构成图是否连通就相当于判断 $[x,\frac{n}{\gcd(x,n)}]$ 构成图是否连通，如果图连通，那么最后一定会递归到 $[x,1]$，给出 $n$ 的质因子分解 $n=\prod_{}p_i^{k_i}$，令 $r=\prod p_i$，那么合法的 $x$ 一定形如 $x=kr(k\in\mathbb{N})$，直接计算即可。

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;

const int Maxn=1e6+7;
int T;
ll n,m;

int main(){
    scanf("%d",&T);
	while(T--){
		scanf("%lld%lld",&n,&m);
		ll prd=1;
		for(ll i=2;i*i<=n;i++){
			if(!(n%i)){
				prd*=i;
				while(!(n%i)) n/=i;
			}
		}
		if(n!=1) prd*=n;
		printf("%lld\n",m/prd+1);
	}
	system("pause");

    return 0;
}
```

---

## 作者：Chu_awa_xing (赞：1)

# P10394 接连不断题解
## 思路
这道题看到数据范围是 $10$ 的 $14$ 次方就应该明白是要找规律。挑了一些样例如果 $M$ 足够的大，将当前的图能否成为连通图列下来，就会发现这个序列中有很多重复的循环。每个循环里都只有一个 $1$，这个循环的个数就是 $N$ 的所有质因数去重后的积。所以答案就是图的数量除以循环的个数（如果有余数就再加 $1$）。

## 代码（抄代码的都不是好孩子)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n,m,ans,tmp;
signed main(){
	cin>>t;
	while(t--){
		tmp=1;
		cin>>n>>m;
		for(int i=2;i*i<=n;i++){  
			if(n%i) continue;
			tmp*=i;
			while(!(n%i)) n/=i;
		}
		tmp*=n,ans=(m+1)/tmp;
		if((m+1)%tmp) ans++;
		cout<<ans<<endl;
	}
	return 0;
} 
```

---

## 作者：__youzimo2014__ (赞：0)

这道题初看是图论，但看到模后才知道是数论。

首先我们知道编号为 $0$ 的图是一定满足条件的，因为任何数乘 $0$ 都得 $0$，这样所有的点都连到了 $0$ 号节点。

我们知道因为 $0$ 始终会连向自己，所以有效的边只有 $n-1$ 条。而这个图是否连通，当且仅当这个图是一棵树。

我们说 $0$ 号节点在第 $0$ 层，而他子节点在第 $1$ 层，以此类推。

设节点 $i$ 的父节点就是 $(i \sdot x) \bmod n$，那么对于每个在第 $k$ 层的节点 $i$，都有 $(i \sdot x^k) \equiv 0 \pmod n$。

这样问题就变成了：一个 $x \in [0, m]$，对于任意的 $i \in [0, n-1]$，是否都能找到一个最小的整数 $k$，使得 $(i \sdot x^k) \equiv 0 \pmod n$。

结论是，这个图是否连通，当且仅当 $x$ 为 $n$ 的所有质数的倍数。

## Code

```cpp
//
//  main.cpp
//  接连不断！
//
//  Created by 游子墨 on 2024/6/7.
//

#include <iostream>
using namespace std;
long long f(long long n) {
    long long res = 1;
    for (long long i = 2ll; i * i <= n; i++) {
        if (n % i == 0) res *= i;
        while (n % i == 0) {
            n /= i;
        }
    }
    res *= n;
    return res;
}
int main(int argc, const char * argv[]) {
    // insert code here...
    long long n, m, T;
    cin >> T;
    while (T--) {
        cin >> n >> m;
        cout << m / f(n) + 1 << endl;
    }
    return 0;
}
```

---


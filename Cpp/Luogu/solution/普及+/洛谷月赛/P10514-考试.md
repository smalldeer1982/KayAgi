# 考试

## 题目背景

人生有梦，各自精彩。

## 题目描述

有 $n$ 名同学去参加考试，考试有 $m$ 道题。

每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。

考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。

## 说明/提示

**【样例解释】**

随机选出 $2$ 名同学全部做对的概率为 $\frac{243}{25000}$，对 $998244353$ 取模后答案为 $793364682$。

可以证明答案一定为有理数。若不了解有理数取模，可以参照[【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)。

**【数据范围】**

- 对于 $30\%$ 的数据，$1\leq n,m \leq 10$；
- 另外有 $10\%$ 的数据，$k=0$；
- 另外有 $20\%$ 的数据，$1 \leq n \leq 1000$，$1\leq m \leq 10^5$；

对于所有数据，保证 $1\leq n,m\leq 10^5$，$0\leq k,a_i\leq n$。

## 样例 #1

### 输入

```
5 5 2
1 2 1 2 2```

### 输出

```
793364682```

# 题解

## 作者：听取MLE声一片 (赞：4)

### 考试题解

不妨先找出选出的 $k$ 名同学，要求这些同学全对也就是做错的同学都在剩余的学生中。第 $i$ 次在剩下的 $n-k$ 名学生中选 $a_i$ 个，概率是 $\frac{C_{n-k}^{a_i}}{C_{n}^{a_i}}$。所有概率相乘即为答案，注意特殊考虑 $n-k < a_i$ 的无解情况。

std 为费马小定理求逆元，若使用线性求逆元时间复杂度 $O(n)$。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<ctime>
#include<random>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e5+10;
const int mod=998244353;
int n,m,k,ans=1,a[N];
int f[N],g[N];
inline int ksm(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
inline int inv(int x){
	return ksm(x,mod-2);
}
inline int C(int n,int m){
	if(n<0||m<0||n<m)return 0;
	return f[n]*g[m]%mod*g[n-m]%mod;
}
signed main()
{
	f[0]=g[0]=1;
	for(int i=1;i<N;i++){
		f[i]=f[i-1]*i%mod;
		g[i]=g[i-1]*inv(i)%mod;
	}
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++){
		a[i]=read();
		ans=ans*(C(n-k,a[i])*inv(C(n,a[i]))%mod)%mod;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：HHC883 (赞：2)

# 题目分析
## 数学部分
根据概率公式，概率等于满足条件的情况数与总情况数的比值。我们考虑第 $i$ 道题的情况。根据题意，有 $a_i$ 个人会做错，那么总情况数就是从 $n$ 个人中选 $a_i$ 个人的方案数，共有 $C_n^{a_i}$ 种。而满足条件的情况数就是选到的 $k$ 个人都做对的方案数，那么做错的人只能在剩下的那 $n-k$ 人当中选，共有 $C_{n-k}^{a_i}$ 种方案。于是对于第 $i$ 道题，选到的 $k$ 人都做对的概率就是 ${C_{n-k}^{a_i}} \over {C_n^{a_i}}$。那么这 $k$ 个人都做对全部的 $m$ 题的概率（即答案）就是 $\prod \limits_{i=1}^m {{C_{n-k}^{a_i}} \over {C_n^{a_i}}}$。
## 实现部分
如果直接利用组合数公式计算上式，会超时，所以我们可以利用前缀积来优化。最后题目还要求取模，由于取模对象不是整数，所以我们可以用扩展欧几里得算法或费马小定理来求逆。于是，题目就做完了。
# 参考代码
```cpp
#include<iostream>
using namespace std;
#define int long long
const int mod=998244353;
int n,m,k,a[(int)1e5+5],pre[(int)1e5+5],ans=1;
int qpow(int a,int b){
	if(b==0) return 1;
	if(b==1) return a;
	if(b&1) return a*qpow(a,b-1)%mod;
	else{
		int tmp=qpow(a,b>>1);
		return tmp*tmp%mod;
	}
}
inline int c(int a,int b){
	if(a<b) return 0;
	else return pre[a]*qpow(pre[a-b],mod-2)%mod*qpow(pre[b],mod-2)%mod;
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++) cin>>a[i];
	pre[0]=1;
	for(int i=1;i<=n;i++) pre[i]=pre[i-1]*i%mod;
	for(int i=1;i<=m;i++){
		ans*=c(n-k,a[i])*qpow(c(n,a[i]),mod-2)%mod;
		ans%=mod;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Nuyoah_awa (赞：2)

### 题目大意

$m$ 道题，每道题等概率的会有一些人做对，求 $n$ 人中随机 $k$ 个人全做对的概率。

### 题目分析

首先可以知道选任意 $k$ 个人全做对的概率是一样的，同样与随机 $k$ 个人全对的概率相同，所以只需求对于指定 $k$ 人全做对的概率。

然后基于简单概率，$P = \dfrac{\text{可能情况数}}{\text{总情况数}}$，易得对于每个题，概率应为选定的 $k$ 个人全做对的情况数比总情况数，简而言之就是做错的 $a_i$ 个人出在另外 $n-k$ 个人中的情况数比出在所有 $n$ 个人中的情况数，根据乘法原理可得 $P = \dfrac{C_{n-k}^{a_i}}{C_{n}^{a_i}}$。所有题的概率即为每题概率之积。

暴力求解时间瓶颈在组合数，时间复杂度为 $\mathcal O(n ^ 2)$，快速求解组合数可根据费马小定理递推预处理出阶乘和阶乘的逆元，优化后时间复杂度 $\mathcal O(n)$。

#### 费马小定理简述

$$\dfrac{a}{b} \equiv a \times b^{M-2} \pmod M$$

当且仅当 $M$ 为质数的时候，证明见题面附模版题链接。

### code
```cpp
#include <iostream>
#include <cstdio>
#define int long long

using namespace std;

const int N = 1e5 + 5, MOD = 998244353;
int n, m, k, x, ans = 1, f[N], inv[N];

int qpow(int x, int y)
{
	int res = 1;
	while(y)
	{
		if(y & 1)	(res *= x) %= MOD;
		(x *= x) %= MOD, y >>= 1;
	}
	return res;
}

int C(int x, int y){return f[x] * inv[y] % MOD * inv[x-y] % MOD;}

signed main()
{
	scanf("%lld %lld %lld", &n, &m, &k);
	f[0] = inv[0] = 1;
	for(int i = 1;i <= n;i++)
	{
		f[i] = f[i-1] * i % MOD;
		inv[i] = inv[i-1] * qpow(i, MOD - 2) % MOD;
	}
	for(int i = 1;i <= m;i++)
	{
		scanf("%lld", &x);
		if(x > n - k)
		{
			puts("0");
			return 0;
		}
		(ans *= C(n-k, x) * qpow(C(n, x), MOD - 2) % MOD) %= MOD;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：swate114514 (赞：1)

好题！

## 题意
我们需要计算从 $n$ 名同学中随机选出 $k$ 名同学，且这些同学在所有 $m$ 道题上均做对的概率。

## 思路
设每道题 $i$ 有 $a_i$ 名同学做错，则做对的人数为 $s_i = n - a_i$。对于单道题 $i$，随机选出的 $k$ 名同学全部做对的概率为：

$$P_i = \frac{C(s_i, k)}{C(n, k)}$$

其中 $C(n, k)$ 表示组合数，即从 $n$ 个元素中取 $k$ 个的组合数。

由于各题目独立，总概率为各题概率的乘积，所以总概率 $P$ 为：

$$P = \prod_{i=1}^m P_i = \prod_{i=1}^m \frac{C(s_i, k)}{C(n, k)}$$

将组合数展开为阶乘形式：

$$C(n, k) = \frac{n!}{k!(n-k)!}, \quad C(s_i, k) = \frac{s_i!}{k!(s_i-k)!}$$

因此概率 $P$ 可表示为：

$$P = \prod_{i=1}^m \frac{s_i!(n-k)!}{n!(s_i-k)!}$$

题目要求对 $998244353$ 取模（下文用 $M$ 表示），需利用模逆元处理除法。组合数的模运算公式如下：

$$C(n, k) \equiv \frac{n!}{k!(n-k)!} \pmod{M}$$

根据费马小定理，除法转换为乘以逆元：

$$\frac{a}{b} \equiv a \cdot b^{M-2} \pmod{M}$$

预处理阶乘 $fact[x] = x! \bmod M$ 和逆阶乘 $inv\_fact[x] = (x!)^{-1} \bmod M$，使得：

$$C(n, k) \equiv fact[n] \cdot inv\_fact[k] \cdot inv\_fact[n-k] \pmod{M}$$

因此，总概率的模运算表达式为：

$$P \equiv \left( \prod_{i=1}^m fact[s_i] \cdot inv\_fact[s_i-k] \right) \cdot inv\_fact[n]^m \cdot fact[n-k]^m \pmod{M}$$

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 998244353;
const int MX = 1e5 + 10;

long long f[MX], invf[MX];

void pre() {
    f[0] = 1;
    for (int i = 1; i < MX; ++i) 
        f[i] = f[i-1] * i % MOD;
    
    invf[MX-1] = 1;
    for (int i = MX-1; i >= 1; --i) 
        invf[i-1] = invf[i] * i % MOD;
}

long long C(int a, int b) {
    if (a < 0 || b < 0 || a < b) return 0;
    return f[a] * invf[b] % MOD * invf[a - b] % MOD;
}

long long powm(long long b, int e) {
    long long r = 1;
    while (e > 0) {
        if (e % 2 == 1) r = r * b % MOD;
        b = b * b % MOD;
        e /= 2;
    }
    return r;
}

int main() {
    pre();    
    int n, m, k;
    cin >> n >> m >> k;
    vector<int> a(m);
    for (int i = 0; i < m; ++i) cin >> a[i];
    
    if (k == 0) { cout << 1 << endl; return 0; }
    if (k > n) { cout << 0 << endl; return 0; }
    
    long long cnk = C(n, k);
    if (cnk == 0) { cout << 0 << endl; return 0; }
    long long inv_cnk = powm(cnk, MOD-2);
    
    long long p = 1;
    for (int x : a) {
        int s = n - x;
        if (s < k) { cout << 0 << endl; return 0; }
        p = p * C(s, k) % MOD;
    }
    
    long long ans = p * powm(inv_cnk, m) % MOD;
    cout << ans << endl;    
    return 0;
}
```

---

## 作者：canwen (赞：1)

不错的绿，来个较好懂的解法。

先让 $a_{1\le i \le m} \gets n - a_{i}$，也就是让 $a_{i}$ 的含义变为第 $i$ 道题随机做对的人数。

容易实现一个 $O(mk)$ 的做法。

具体而言：

设选出 $k$ 个能全对的概率是 $x$，初始令 $x \gets 1$。依题，模数 $mod = 998244353$。定义函数 $\operatorname{ksm}(a,b)$ 表示 $a^{b}$。

枚举 $i \gets 1\sim k$ 表示现在正在统计第 $i$ 个可以全对的同学概率（即已经选了 $i-1$ 个了），接着枚举 $j \gets 1\sim m$ 表示第 $i$ 个同学做对第 $j$ 道题的概率是多少，那么由于前 $i-1$ 个同学一定要保证做对，即需要运用排列组合中的乘法原理，$x$ 需要乘上 $\frac{a_{j}-i+1}{n-i+1}$。

考虑模数是个质数和数据范围，笔者用费马小定理求逆元，下面是该解法关键代码：

```cpp
int n,m,k,a[N],x=1;
signed main(){
	n=in(),m=in(),k=in();
	_rep(i,1,m) a[i] = in(),a[i] = (n-a[i]);
	_rep(i,1,k){
		_rep(j,1,m) x = x * (a[j]-i+1) % mod * ksm(n-i+1,mod-2) % mod;
		// qsm(a,b) 表示 a ^ {b} 
	}
	cout << x, pc;
	return 0;
}
```

下面考虑优化时间复杂度。

观察到我们在枚举 $i\gets 1\sim k$ 的时候，显然里面会乘上 $m$ 个相同的数，即 $\operatorname{ksm}(n-i+1,mod-2)$，那么这部分的答案可以直接用快速幂求出。

继续考虑枚举 $j \gets 1\sim m$ 时剩下的 $a_{j}-i+1$，可以 $O(n)$ 预处理出数组 $f$ 使得 $f_{1\le i \le n} = \prod_{j=1}^{i}$，那么对于 $i \gets 1 \sim m$，对答案的贡献就应该是 $\frac{f_{a_{i}}}{f_{a_{i}-k}} $。

那么坑点来了，我们可能遇到 $a_{i} < k$ 的情况，也就是对于第 $1 \le i \le m$ 道题随机错的人数比要选的还多，显然概率就会变成 $0$，注意判断这部分否则由于数组越界，将会 RE 第九个测试点。

至此，两部分的答案都可以线性以及运用快速幂快速求出来。

## Code
```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;
#define int long long
#define const constexpr
#define pc putchar('\n')
#define fst first
#define snd second
#define mk make_pair
#define i128 _int128
#define pb emplace_back
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define nowtime clock()/CLOCKS_PER_SEC
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define getchar getchar_unlocked
int in(){
	char a=getchar();
	int k = 0, kk = 1;
	while(a > '9' || a < '0'){
		if(a == '-') kk = -1;
		a=getchar();
	}
	while(a>='0'&&a<='9'){
		k = k*10+a-'0',a=getchar();
	}
	return k*kk;
}
void out(int a){
	if(a < 0) putchar('-'),a=-a;
	if(a > 9) out(a/10);
	putchar(a%10+'0');
}
const int mod = 998244353, N = 1e5 + 5;
int ksm(int a,int b){
	int res = 1;
	while(b){
		if(b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
int n,m,k,a[N],x=1,f[N];
signed main(){
	n=in(),m=in(),k=in();
	f[1] = 1, f[0] = 1;
	_rep(i,2,n) f[i] = f[i-1] * i % mod;
	_rep(i,1,m) a[i] = in(),a[i] = (n-a[i]);
	_rep(i,1,k){
		int tmp = ksm(n-i+1,mod-2) % mod;
		x = x * ksm(tmp,m) % mod;
	}
	_rep(i,1,m){
		x = x * f[a[i]] % mod * ksm(a[i]-k<0?0:f[a[i]-k],mod-2) % mod;
	}
	cout << x, pc;
	return 0;
}
```

---

## 作者：Claire0918 (赞：1)

考虑每次分别计算选出一个全对的人的概率，最后将每次的结果乘起来就是答案。

设当前总人数为 $p$，初始有 $p = n$。选取第 $i$ 人时全对人数为 $p - a_i$，故做对概率为 $\dfrac{p - a_i}{p}$，所以每次结果为 $\displaystyle \prod_{i = 1}^{m}\frac{p - a_i}{p}$。随后整体上少了 $1$ 人，即 $p \gets p - 1$。

不难发现答案为
$$
\begin{aligned}
\prod_{i = n - k + 1}^{n} \prod_{j = 1}^{m} \frac{i - a_j}{i}
&= \prod_{i = 1}^{m} \prod_{j = n - k + 1}^{n} \frac{j - a_i}{j}\\
&= \prod_{i = 1}^{m} \frac{(n - a_i)^{\underline{k}}}{n^{\underline{k}}}\\
&= \prod_{i = 1}^{m} \dfrac{\dfrac{(n - a_i)!}{(n - a_i - k)!}}{\dfrac{n!}{(n - k)!}}\\
&= \dfrac{\displaystyle \prod_{i = 1}^{m} \dfrac{(n - a_i)!}{(n - a_i - k)!}}{(\dfrac{n!}{(n - k)!})^m}\\
\end{aligned}
$$

$\mathcal{O}(n)$ 预处理阶乘，随后可以 $\mathcal{O}(\log m)$ 求得分母。每次可以 $\mathcal{O}(\log n)$ 求得 $\dfrac{(n - a_i)!}{(n - a_i - k)!}$，即可以 $\mathcal{O}(m \log n)$ 求得分子。

注意特判 $a_i + k > n$ 时必然无解。

总时间复杂度 $\mathcal{O}(m \log n)$，可以通过本题。

Code:
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

const int maxn = 1e5 + 10, mod = 998244353;

int n, m, k;
long long res;
long long fac[maxn];

inline long long ksm(long long a, long long b){
    long long res = 1;
    while (b){
        if (b & 1){
            res = res * a % mod;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

inline long long inv(long long x){
    return ksm(x, mod - 2);
}

int main(){
    scanf("%d %d %d", &n, &m, &k);
    fac[0] = 1;
    for (int i = 1; i <= n; i++){
        fac[i] = fac[i - 1] * i % mod;
    }
    res = inv(ksm(fac[n] * inv(fac[n - k]) % mod, m));
    for (int i = 1; i <= m; i++){
        int a;
        scanf("%d", &a);
        if (a + k > n){
            printf("0");
            return 0;
        }
        res = res * fac[n - a] % mod * inv(fac[n - a - k]) % mod;
    }
    printf("%lld", res);

return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P10514 题目](http://www.luogu.com.cn/problem/P10514)

### 解题思路
为了方便计算，我们设 $b_i$ 为做对第 $i$ 道题的人数，显然 $b_i=n-a_i$。

首先，如果存在如何一个 $i(1\le i\le m)$ 满足 $b_i<k$，即做对的同学数比要选择的同学数少，则直接输出 `0`。

如果我们在这 $n$ 名同学中随机选择 $1$ 名，那么这名同学第 $i$ 道题做对的概率为 $\frac{b_i}{n}$，所有题目全对的概率为 $\prod_{i=1}^{m}\frac{b_i}{n}$。

那么在这名同学全对的基础上，如果我们在 $n-1$ 名同学中再随机选出第 $2$ 名同学，此时第 $2$ 名同学第 $i$ 道题做对的概率就不是 $\frac{b_i}{n}$ 了，因为上次选出的同学已确保全对，所以在剩下的 $n-1$ 名同学中，只有 $b_i-1$ 名同学的第 $i$ 题是正确的，因此第 $2$ 名同学第 $i$ 道题做对的概率是 $\frac{b_i-1}{n-1}$，所有题目全对的概率为 $\prod_{i=1}^{m}\frac{b_i-1}{n-1}$。

经过上述推算，不难发现，在前面选出的所有同学都全对的基础上，随机选出的第 $i(1\le i\le k)$ 名同学全对的概率为：

$$\prod_{j=1}^{m}\frac{b_j-i+1}{n-i+1}$$

则随机选出的 $k$ 名同学这些同学全部全对的概率为：

$$\begin{aligned} \prod_{i=1}^{k}\prod_{j=1}^{m}\frac{b_j-i+1}{n-i+1}&=\frac{\prod_{i=1}^{k}\prod_{j=1}^{m}b_j-i+1}{\prod_{i=1}^{k}\prod_{j=1}^{m}n-i+1}\\&=\frac{\prod_{i=1}^{k}\prod_{j=1}^{m}b_j-i+1}{\prod_{i=1}^{k}(n-i+1)^{m}} \end{aligned}$$

我们发现计算有理数的分母部分用快速幂处理后不会超限，但是计算分子部分的时间复杂度达到了 $O(mk)$，有可能会超限，我们可以先把分子部分换一种形式写出来：

$$\begin{aligned} \prod_{i=1}^{k}\prod_{j=1}^{m}b_j-i+1&=\prod_{i=1}^{m}b_i\times(b_i-1)\times(b_i-2)\times\cdots\times(b_i-k+1) \end{aligned}$$

再看看数据范围：$0\le a_i\le 10^5$，那么 $b_i$ 也不可能超过 $10^5$，你想到了什么？当然是线段树！我们可以用线段树统计从 $1$ 到 $10^5$ 这些数分别在上述乘法算式出现了多少次，初始时它们的出现次数均为 $0$。

那为什么要用线段树呢？注意上述乘法算式中 $b_i\times(b_i-1)\times(b_i-2)\times\cdots\times(b_i-k+1)$ 的部分，这就相当于给区间 $[b_i-k+1,b_i]$ 中所有数在上述乘法算式出现次数加上 $1$，线段树可以很快完成这种操作，统计出现次数的总时间复杂度最坏情况为 $O(m\log k)$，不会超限。

设 $p_i(1\le i\le10^5)$ 为 $i$ 在上述乘法算式出现次数（直接用线段树的区间查询获取其值即可），则答案的分子部分可以表示为：

$$\prod_{i=1}^{10^5}i^{p_i}$$

最后用有理数取模算出答案即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const long long p=998244353;
int a[100001];
inline long long poww(long long a,long long b)
{
    long long ss=1;
    while(b)
    {
        if(b&1)
            ss=ss*a%p;
        a=a*a%p;
        b>>=1;  
    }
    return ss;
}
int mod(int a,int b)
{
	int s=a*poww(b,p-2)%p;
	s=(s%p+p)%p;
	return s;
}
int tr[100001<<2],ma[100001<<2];
inline void pud(int l,int r,int w)
{
	int mid=(l+r)/2;
	ma[w*2]+=ma[w],ma[w*2+1]+=ma[w];
	tr[w*2]+=(mid-l+1)*ma[w],tr[w*2+1]+=(r-mid)*ma[w],ma[w]=0;	
}
inline void xg(int l,int r,int ml,int mr,int w)
{
	if(mr<l||ml>r)
		return;
	if(mr>=r&&ml<=l)
	{
		tr[w]+=r-l+1;
		if(r!=l)
			ma[w]++;
		return;
	}
	int mid=(l+r)/2;
	pud(l,r,w);
	xg(l,mid,ml,mr,w*2),xg(mid+1,r,ml,mr,w*2+1);
	tr[w]=tr[w*2]+tr[w*2+1];
}
inline int chzh(int l,int r,int ml,int mr,int w)
{
	if(mr<l||ml>r)
		return 0;
	if(mr>=r&&ml<=l)
		return tr[w];
	int mid=(l+r)/2;
	pud(l,r,w);
	return chzh(l,mid,ml,mr,w*2)+chzh(mid+1,r,ml,mr,w*2+1);
}
signed main()
{
	ios::sync_with_stdio(false);
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
		cin>>a[i],a[i]=n-a[i];
	if(k==0)
	{
		cout<<"1";
		return 0;
	}
	int fm=1,fz=1;
	for(int i=1;i<=k;i++)
		fm=fm*poww(n-i+1,m)%p;
	for(int i=1;i<=m;i++)
	{
		if(a[i]<k)
		{
			cout<<"0";
			return 0;
		}
		xg(1,n,a[i]-k+1,a[i],1);
	}
	for(int i=1;i<=100000;i++)
	{
		int c=chzh(1,n,i,i,1);
		fz=fz*poww(i,c)%p;
	}
	int s=mod(fz,fm);
	cout<<s;
	return 0;
}
```

---

## 作者：andrewpjc (赞：0)

## 问题分析
题目要求计算随机选出 $k$ 名同学后，这些同学全部做对 $m$ 道题的概率，并对 $998244353$ 取模。关键点在于：
每道题 $i$ 有固定的错误人数 $a_i$ ，错误分配在所有同学中是随机的，概率计算需考虑所有同学的随机选择和错误分配的随机性答案需为有理数取模的结果，模数为质数 $998244353$ 。
## 解法思路
概率 $P$ 可推导为:
如果存在 $a_i>n-k$ (即某题错误人数超过未被选中的同学数)，则 $P=0$ ，因为选中的 $k$ 名同学不可能全部做对这道题。
否则，概率为：

$P=\prod\limits_{i=1}^m\frac{\tbinom{n-k}{a_i}}{\tbinom{n}{a_i}}$

其中$\tbinom{n}{k}$是二项式系数。
该公式可简化为下降阶乘形式，便于计算：

$P=\prod\limits_{i=1}^m\prod\limits_{j=0}^{a_i-1}\dfrac{n-k-j}{n-j}=\dfrac{\prod_{j=0}^{n-1}(n-k-j)^{f(j)}}{\prod_{j=0}^{n-1}(n-j)^{f(j)}}$

这里 $f(j) = |{i|a_i>j}|$ 是满足 $a>j$ 的题目数量，可通过频率数组和后缀和高效计算。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353;
const int MAXN = 1e5 + 10;
 
long long qpow(long long base, long long exp) {
    long long res = 1;
    while (exp) {
        if (exp & 1) res = res * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return res;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); 
    
    int n, m, k;
    cin >> n >> m >> k;
    vector<int> a(m);
    for (int i = 0; i < m; i++) {
        cin >> a[i];
    }
 
    // 边界情况处理
    if (k == 0) {
        cout << 1 << endl;
        return 0;
    }
 
    // 检查是否存在题目错误人数超过未被选中的同学
    bool flag = false;
    for (int x : a) {
        if (x > n - k) {
            flag = true;
            break;
        }
    }
    if (flag) {
        cout << 0 << endl;
        return 0;
    }
 
    // 统计频率
    vector<int> cnt(MAXN, 0);
    for (int x : a) {
        cnt[x]++;
    }
 
    // 计算后缀和 f(j) = 满足 a_i > j 的题目数
    vector<int> f(MAXN, 0);
    int suffix = 0;
    for (int j = n; j >= 0; j--) {
        if (j + 1 < MAXN) {
            suffix += cnt[j + 1];
        }
        if (j < n) {
            f[j] = suffix;
        }
    }
 
    // 计算分子和分母的乘积 
    long long numerator = 1, denominator = 1;
    for (int j = 0; j < n; j++) {
        if (f[j] == 0) continue;
 
        long long term_num = (n - k - j + MOD) % MOD;
        long long term_den = (n - j) % MOD;
 
        numerator = numerator * qpow(term_num, f[j]) % MOD;
        denominator = denominator * qpow(term_den, f[j]) % MOD;
    }
 
    // 计算最终概率 
    long long inv_den = qpow(denominator, MOD - 2);
    long long ans = numerator * inv_den % MOD;
    cout << ans << endl;
 
    return 0;
}
```

时间复杂度为 $O(n)$ 。

---

## 作者：FrankShix (赞：0)

![](https://cdn.luogu.com.cn/upload/image_hosting/0hzasec3.png)
望审核大人高抬贵手。

# Solution
对于第 $i$ 道题，$k$ 个随机选中的同学全部答对的概率为：
$$
P_i = \frac{\binom{n - a_i}{k}}{\binom{n}{k}}
$$
由于题目相互独立，总概率为：
$$
P = \prod_{i=1}^{m} P_i = \prod_{i=1}^{m} \frac{\binom{n - a_i}{k}}{\binom{n}{k}}
$$

特判：
- 若 $\exists a_i > n - k$（即答对该题人数不足 $k$ 人），则 $P = 0$。
- 当 $k = 0$ 时，$P = 1$。


所以总结一下：
1. 预处理阶乘数组 $jc$ 和阶乘逆元数组 $inv\_jc$。
2. 计算分母 $\binom{n}{k}$ 及其逆元。
3. 遍历每道题：
   - 若 $n - a_i < k$，则输出 $0$ 并退出。
   - 否则计算 $\binom{n - a_i}{k}$ 并累乘概率。

**记得取模！**

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll MOD = 998244353;
const int MAX_N = 1e5 + 10;
ll n, m, k, a[MAX_N];
ll jc[MAX_N], inv_jc[MAX_N]; 

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= m; ++i) 
        cin >> a[i];

    // 特判 k=0 的情况
    if (k == 0) {
        cout << 1; // 概率为 1
        return 0;
    }

    // 预处理阶乘和阶乘逆元
    jc[0] = 1;
    for (int i = 1; i < MAX_N; ++i) 
        jc[i] = jc[i - 1] * i % MOD;
    
    inv_jc[MAX_N - 1] = qpow(jc[MAX_N - 1], MOD - 2);
    for (int i = MAX_N - 2; i >= 0; --i) 
        inv_jc[i] = inv_jc[i + 1] * (i + 1) % MOD;

    // 计算分母及其逆元
    ll denom = jc[n] * inv_jc[k] % MOD * inv_jc[n - k] % MOD;
    ll inv_denom = qpow(denom, MOD - 2);

    ll ans = 1;
    for (int i = 1; i <= m; ++i) {
        if (n - a[i] < k) {
            ans = 0;
            break;
        }
        ll num = jc[n - a[i]] * inv_jc[k] % MOD * inv_jc[n - a[i] - k] % MOD;
        ans = ans * (num * inv_denom % MOD) % MOD;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：__Cielo__ (赞：0)

# 递推求逆元 & 组合数推公式 解决 [P10514 考试](https://www.luogu.com.cn/problem/P10514)

## 前置芝士-递推求逆元

### 问

对于 $1 \le a \le n$ 求整数 $x$ 满足：

$$
ax \equiv 1 (\bmod \space p)
$$

$x$ 即为 $a$ 的逆元 $a^{-1}$。

### 解

设 $p \div a = k$，$p \bmod a = r$，则有：

$$
k \times a + r \equiv 0 \space (\bmod \space p)
$$

两边同乘 $a^{-1}$，$r^{-1}$ 得：

$$
k \times r^{-1} + a^{-1} \equiv 0 \space (\bmod \space p)
$$


移项得：

$$
a^{-1} \equiv - k \times r^{-1} \space (\bmod \space p)
$$

将 $p \div a = k$，$p \bmod a = r$ 代入得：

$$
a^{-1} \equiv - ( p \div a ) ( p \bmod a )^{-1} \space (\bmod \space p)
$$

由于 $p \bmod a < a$，所以满足递推关系。

且有当 $a = 1$ 时，因为 $1 \times 1 \equiv 1 (\bmod \space p)$，所以 $a^{-1} \equiv 1 \space (\bmod \space p)$。


最后整理得出递推式：

$$
a^{-1} \equiv ( p - p \div a ) ( p \bmod a )^{-1} \space (\bmod \space p)
$$

*Code：*

```cpp
ni[1]=1;
for(int i=2;i<=n;i++)
    ni[i]=((M-M/i)*ni[M%i])%M;
```

## 公式推导

首先，题目要求**全部题目做对**的概率。

记**题目做对**为 $A$，**全部做对**为 $A_{all}$，$P(A_{all})$ 即为所求。

也就是说，要求每道题做对概率的**乘积**。即：

$$
P(A_{all}) = \prod^{m}_{i = 1} P_i(A)
$$

对于每道题目，选择的结果**总数**为：

$$
C_{all} = \binom{a_i}{n}
$$

由于选出的 $k$ 名同学一定正确，所以不正确的 $a_i$ 名同学一定在剩下的 $n - k$ 名同学中，**满足条件** $A$ 的结果数量为：

$$
C_A = \binom{a_i}{n - k}
$$

所以有：

$$
\begin{aligned}
    P_i(A) &= \frac{C_A}{C_{all}} \\
    &= \frac{\binom{a_i}{n - k}}{\binom{a_i}{n}} \\
    &= \frac{\frac{(n - k)!}{a_i!(n - k - a_i)!}}{\frac{n!}{a_i!(n - a_i)!}} \\
    &= \frac{(n - k)!(n - a_i)!}{n!(n - k - a_i)!}
\end{aligned}
$$

于是就得到**答案公式**：

$$
P(A_{all}) = \prod^{m}_{i = 1} \frac{(n - k)!(n - a_i)!}{n!(n - k - a_i)!}
$$

## 食用芝士-递推求逆元

有了这个公式，我们就可以直接通过预处理**阶乘**与**阶乘的逆元**计算答案了！

*Code：*

```cpp
#include<cstdio>
#define ll long long
#define N 100005
#define M 998244353
#define mul(x,y) x=(x*y)%M
ll n,m,k;
ll a[N],jc[N],ni[N],njc[N];
ll ans=1;
int main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=m;i++)
		scanf("%lld",a+i);
	jc[1]=ni[1]=njc[1]=1;
	for(int i=2;i<=n;i++)
		jc[i]=(jc[i-1]*i)%M,
		ni[i]=((M-M/i)*ni[M%i])%M,
		njc[i]=(njc[i-1]*ni[i])%M;
	for(int i=1;i<=m;i++)
	{
		mul(ans,jc[n-a[i]]);
		mul(ans,jc[n-k]);
		mul(ans,njc[n]);
		mul(ans,njc[n-a[i]-k>0?n-a[i]-k:1]);
	}
	printf("%lld",ans);
}
```

## 结

**蒟蒻码字不易，不喜勿喷。**  
**最后附上**[**文章链接**](https://www.luogu.com.cn/article/px6xl0i4)

---

## 作者：Meickol (赞：0)

设当前为第 $t$ 次选择，由于每次选择一名同学，则当前还可选取的总人数为 $p=n-t+1$。

在第 $t$ 次选择下，第 $i$ 道题做对的人数为 $p−a_i$，即第 $i$ 道题做对概率为 $\dfrac{p-a_i}{p}$。因为有 $m$ 道题，故所有题做对的概率为 $\displaystyle \prod_{i=1}^m \dfrac{p−a_i}{p}$。



我们要求选取的这 $k$ 人都能将所有题答对的概率，即将前 $k$ 次选择每次所有题都答对的概率相乘，答案为：
$$
\large \prod_{p=n-k+1}^{n} \prod_{i=1}^m\dfrac{p−a_i}{p}
$$


但是计算这个式子的时间复杂度还是太高了，考虑将这个式子进一步优化。

这个式子显然可以交换求积次序，而且不难发现我们必须交换求积次序，否则无法得到有用的式子。

交换求积次序：
$$
\large  \prod_{i=1}^m \prod_{p=n-k+1}^{n} \dfrac{p−a_i}{p}
$$
化简：
$$
\large  \prod_{i=1}^m \dfrac{\dfrac{(n-a_i)!}{(n-k-a_i)!}}{\dfrac{n!}{(n-k)!}}
$$
整理得：
$$
\large  \dfrac{\displaystyle \prod_{i=1}^m \dfrac{(n-a_i)!}{(n-k-a_i)!}}{\Big (\dfrac{n!}{(n-k)!}\Big)^m}
$$
至此问题得解，预处理一下阶乘数组数组即可，最终时间复杂度为 $\mathcal O(m \log n)$。

注意特判无解的情况：当 $n-k-a_i<0$ 时无解。

代码如下：

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
typedef long long LL;
const int N=1e5+5,MOD=998244353;
int n,m,k;
LL a[N];
LL f[N],g[N];
LL fastpow(LL a,LL n,LL mod){
	LL res=1;
	while(n){
		if(n&1) res=res*a%mod;
		a=a*a%mod;
		n>>=1;
	}
	return res;
}
void init(){
	f[0]=g[0]=1;
	rep(i,1,N-2){
		f[i]=f[i-1]*i%MOD;
		g[i]=g[i-1]*fastpow(i,MOD-2,MOD)%MOD;
	}
}
void solve(){
	init();
	cin>>n>>m>>k;
	rep(i,1,m) cin>>a[i];
	LL ans=1;
	rep(i,1,m){
		if(n-k-a[i]<0) return cout<<0,void();
		ans=ans*f[n-a[i]]%MOD*g[n-k-a[i]]%MOD;
	}
	ans=ans*fastpow(fastpow(f[n]*g[n-k]%MOD,m,MOD),MOD-2,MOD)%MOD;
	cout<<ans;
}
```

---

## 作者：tder (赞：0)

对于第 $i$ 题来说：

- 总情况数即为在 $n$ 个同学里面选 $a_i$ 个同学错，即 $\displaystyle\binom{n}{a_i}$ 种；
- 接下来考虑满足题意的方案数，$k$ 名同学都对，也就是错的同学都在剩下的 $n-k$ 个同学中，方案数也就是在 $n-k$ 个同学里面选 $a_i$ 个同学错，即 $\displaystyle\binom{n-k}{a_i}$ 种。	

故所求即为：

$$
\prod_{i=1}^m\frac{\binom{n-k}{a_i}}{\binom{n}{a_i}}
$$

注意特判 $n-k<a_i$ 时的无解情况。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5, M = 998244353;
namespace Count {
	int f[N], v[N];
	int qpow(int b, int p, int k = M) {
		int r = 1;
		while(p) {
			if(p % 2) r *= b, r %= k;
			p /= 2;
			b *= b, b %= k;
		}
		return r;
	}
	void init(int n, int k = M) {
		f[0] = 1;
		for(int i = 1; i <= n; i++) f[i] = f[i - 1] * i, f[i] %= k;
		int m = min(n, k - 1);
		v[m] = qpow(f[m], k - 2);
		for(int i = m - 1; i >= 0; i--) v[i] = v[i + 1] * (i + 1), v[i] %= k;
	}
	int get(int a, int b, int k = M) {
		if(a < b) return 0;
		else return (f[a] * v[b] % k) * v[a - b] % k;
	}
	int lucas(int a, int b, int k = M) {
		if(!b) return 1;
		else return (get(a % k, b % k) * lucas(a / k, b / k)) % k;
	}
}
using namespace Count;
int n, m, k, a[N], ans = 1;
signed main() {
	init(N - 5);
	cin>>n>>m>>k;
	for(int i = 1; i <= m; i++) cin>>a[i];
	for(int i = 1; i <= m; i++) 
		if(a[i] <= n - k) ans *= get(n - k, a[i]) * qpow(get(n, a[i]), M - 2) % M, ans %= M;
		else cout<<0<<endl, exit(0);
	cout<<ans<<endl;
}
```

---

## 作者：Night_sea_64 (赞：0)

显然每个题目是独立的。最终答案是每个题目的概率的乘积。

随机选出 $k$ 个人，这些同学全都做出第 $i$ 题，意思就是做错的 $a_i$ 人全都在剩下的 $n-k$ 人中。所以概率就是 $\dfrac{C_{n-k}^{a_i}}{C_n^{a_i}}=\dfrac{(n-k)!(n-m)!}{n!(n-k-m)!}$。于是我们发现只需预处理 $1\sim n$ 的阶乘。

```cpp
#include<iostream>
#define int long long
using namespace std;
const int mod=998244353;
int n,m,k,jc[100010];
int a=1,b=1;
void exgcd(int a,int b,int &x,int &y)
{
    if(!b)
    {
        x=a,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    int z=x;
    x=y,y=z-a/b*y;
}
signed main()
{
    cin>>n>>m>>k;
    k=n-k;
    jc[0]=1;
    for(int i=1;i<=n;i++)jc[i]=jc[i-1]*i%mod;
    for(int i=1;i<=m;i++)
    {
        int x;
        cin>>x;
        if(k<x)
        {
            cout<<0<<endl;
            return 0;
        }
        a=a*jc[k]%mod;
        a=a*jc[n-x]%mod;
        b=b*jc[n]%mod;
        b=b*jc[k-x]%mod;
    }
    int inv,y;
    exgcd(b,mod,inv,y);
    cout<<((inv%mod+mod)%mod)*a%mod<<endl;
    return 0;
}
```

---

## 作者：Alexandr (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10514)

## 解析

题目要求随机选出的 $k$ 名同学全部都做对，即每一道题都在剩下的 $n-k$ 名同学中出错，可以推出

$$\prod_{i=1}^{n} \dfrac{C_{n-k}^{a_i}}{C_n^{a_i}}\pmod{M}$$

如何除以 $C_n^{a_i}$，我们可以乘上它的逆，根据费马小定理

$$\dfrac {1}{a}=a^{-1}=a^{M-2} \pmod{M}$$

将其代入

$$\dfrac {1}{C_n^{a_i}}={C_n^{a_i}}^{-1}={C_n^{a_i}}^{M-2} \pmod{M}$$

所以原式变为

$$\prod_{i=1}^{n} {C_{n-k}^{a_i}}{C_n^{a_i}}^{M-2} \pmod{M}$$

## code

```cpp
#include<bits/stdc++.h>
#define _rep(i,a,b) for(int i=(a);i<=(b);i++)
#define _antirep(i,a,b) for(int i=(a);i>=(b);i--) 
using namespace std;
typedef long long LL;
typedef double db;
const int N=1e5+5,mod=998244353;
LL n,m,k,a[N],fac[N],ans=1;
LL qsm(LL x,LL y)
{
	LL res=1;
	while(y)
	{
		if(y&1) res=(res*x)%mod;
		x=(x*x)%mod;
		y>>=1;
	}
	return res;
}
LL inv(LL x)
{
	return qsm(x,mod-2);
}
LL C(LL x,LL y)
{
    if(y>x||x<0||y<0) return 0;//细节！！！
	LL res=fac[x];
	res=(res*inv(fac[y]))%mod;
	res=(res*inv(fac[x-y]))%mod;
	return res;
}
signed main()
{        
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	fac[0]=1;
	cin>>n>>m>>k; 
	_rep(i,1,m) cin>>a[i];
	_rep(i,1,n) fac[i]=(fac[i-1]*i)%mod;
	_rep(i,1,m) ans=ans*C(n-k,a[i])%mod*inv(C(n,a[i]))%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：OneLeft (赞：0)

## 题意
有 $n$ 个学生和 $m$ 道题，每道题会有随机的 $a_i$ 个人做错，求随机抽选 $k$ 个学生每个都是满分的概率 $P\bmod 998244353$。

## 思路
首先思考如何计算总方案数，不难发现对于一个问题，方案数等于从 $n$ 个人中选择 $a_i$ 个人的方案数，也就是 $\left(\begin{matrix}n\\a_i\end{matrix}\right)$，把所有的方案数乘起来即可。

然后思考如何计算有 $k$ 个学生满分的方案数，对于一个问题方案数等于从 $n-k$ 个人中选择 $a_i$ 个人，也就是 $\left(\begin{matrix}n-k\\a_i\end{matrix}\right)$，同样乘起来即可。

故最终答案等于

$$
\frac{\prod_{i=1}^m\left(\begin{matrix}n-k\\a_i\end{matrix}\right)}{\prod_{i=1}^m\left(\begin{matrix}n\\a_i\end{matrix}\right)}
$$

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,mod=998244353;
int n,m,k,a[N];
int f[N],ans=1;
int exgcd(int a,int b,int &x,int &y)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	int gcd=exgcd(b,a%b,x,y),tmp=x;
	x=y,y=tmp-(a/b)*y;
	return gcd;
}
int get_inv(int a)
{
	int x,y;
	exgcd(a,mod,x,y);
	return (x%mod+mod)%mod;
}
int C(int n,int k)
{
	if(n<0||k<0||n<k)return 0;
	return (f[n]*get_inv(f[n-k])%mod)*get_inv(f[k])%mod;
}
signed main()
{
	f[0]=1;
	for(int i=1;i<N;i++)
		f[i]=f[i-1]*i%mod;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
		cin>>a[i],ans=ans*C(n-k,a[i])%mod;
	for(int i=1;i<=m;i++)
		ans=ans*get_inv(C(n,a[i]))%mod;
	cout<<ans;
	return 0;
}
```

---


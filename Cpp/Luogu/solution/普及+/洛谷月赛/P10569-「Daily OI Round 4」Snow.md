# 「Daily OI Round 4」Snow

## 题目描述

下雪了，小 Y 堆了 $n$ 个雪柱排成一排，调皮的小 X 打算推倒这 $n$ 个雪柱，他想在最少的时间内推倒所有雪柱，于是他请你来为他出谋划策。

小 Y 堆的每个雪柱高 $a_i$ 单位，推倒一个雪柱的时间为该雪柱的高度。小 X 只能从这一排雪柱的两端推雪柱 \*，次数不限，小 X 移动的时间可以忽略不计。这样就可以使一个雪柱倒向其他雪柱，从而击倒另一个雪柱（击倒的时间忽略不计），然后发生连锁反应，更加节省时间 \*\*。

设初始的势能为当前手动推倒的雪柱 $k$ 的高度 $p=a_k$，则此轮连锁反应中第 $i$ 个雪柱倒向第 $j$ 个雪柱时：

- 若 $p\ge a_j$，则使第 $j$ 个雪柱也被击倒，并令 $p \gets a_j$。
- 若 $p< a_j$，则第 $j$ 个雪柱的高度减少（不被击倒），终止整个连锁反应，令 $a_j \gets a_j-p$。

请你求出推倒所有雪柱的最短时间。

\*：每一次要么从左边推最左边的雪柱，要么从右边推最右边的雪柱。

\*\*：雪柱的倒塌方向取决于推雪柱的方向，如果从左边推，雪柱就会向右依次倒塌（第 $i$ 个雪柱倒塌向第 $i+1$ 个雪柱），反之同理。

## 说明/提示

#### 【样例解释】

- **对于第一组数据：**

> 第一次从左边推，耗费 $2$ 点时间，使得 $5$ 个雪柱 的高度分别变为：$0,1,1,4,5$。 
>
> 第二次从右边推，耗费 $5$ 点时间，使得所有雪柱都被击倒。 
>
> 共耗费 $7$ 点时间。

- **对于第二组数据：**

> 从左边或者右边都可以一次性推完，共耗费 $6$ 点时间。

- **对于第三组数据：**

> 第一次从右边推，耗费 $4$ 点时间，使得 $6$ 个雪柱的高度分别变为：$1,1,4,4,0,0$。  
>
> 第二次从右边推，耗费 $4$ 点时间，使得所有雪柱都被击倒。
>
> 共耗费 $8$ 点时间。

#### 【数据范围】
  
**本题采用捆绑测试。**

|$\text{Subtask}$|分值|$n \le$|
| :-----------: | :-------------:|:-----------: |
|$0$|$10$|$20$|
|$1$|$15$|$100$|
|$2$|$25$|$1000$|
|$3$|$50$|$10^5$|

对于全部数据，保证：$1 \le T \le 10$，$1 \le n \le 10^5$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
3
5
2 3 1 4 5
6 
6 6 6 6 6 6
6
1 1 4 5 1 4```

### 输出

```
7
6
8```

# 题解

## 作者：baokun (赞：14)

## Part 1 前言
本来想打这次基础赛的，有事没参与，这就是 T4 绿题（建议降一下）。
## Part 2 题意
[题目传送门](https://www.luogu.com.cn/problem/P10569)

小 X 要推倒小 Y 的 $n$ 个雪柱，这些雪柱排成一排，每个雪柱都有各自的高度，小 X 只能从**最左边**或**最右边**推雪柱，并引发连锁反应。推倒第 $i$ 个雪柱要花费 $a_i$ 的时间，求推倒所有雪柱子花费的最小时间。
## Part 3思路
很明显，要运用贪心来解决这个问题：

因为只能从左或从右推，所以枚举一个 $i$，求**两个方向推到 $i$ 所使用的时间**以及从两端**推到 $i$ 后有多大惯性**，足不足够把 $i$ 推倒。若是两边的势能能将 $i$ 推倒，则结果为两边推到这的时间之和，否则就再加上 $a_i$ 剩余的高度。对于每次得到的答案，取最小值即可。

这么说可能有点抽象，那么咱画个图（~~更抽象了~~）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ra34wizv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

黄色箭头表示左右推倒的进度（ $i$ 的位置不唯一，所以没有具体下标）。

你以为结束了？不，让我们看看数据范围：

**对于全部数据，保证：**
$1 ≤ T ≤ 10,1 ≤ n ≤ 10^5,1 ≤ a_i ≤ 10^{10}$。

**so: 不开long long 见祖宗** 
## Part 4 代码（有注释）
```
#include<bits/stdc++.h>
#define ll long long
#define N 100005 
using namespace std;
ll T,n,i,a[N],ans,d1[N],d2[N],l1[N],l2[N];
int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	assert(T<=10); 
	while(T--){ 
		ans=LLONG_MAX; // 初始化答案为极大值，便于最小化操作
		cin>>n; 
		assert(n<=100000); 
		for(i=1;i<=n;i++) cin>>a[i],assert(1<=a[i]&&a[i]<=1e10); 
		// 接下来的部分用于初始化累积时间数组并计算每个雪柱从左至右的推倒时间
		for(i=1;i<=n;i++){
			d1[i]=d1[i-1]; // 将之前累积的时间赋值给当前项
			if(l1[i-1]==0) d1[i]+=a[i],l1[i]=a[i]; // 如果前一个雪柱被完全推倒，则当前雪柱独立推倒
			else if(l1[i-1]>=a[i]) l1[i]=a[i]; // 如果前一个雪柱未倒下且足够的势能推倒当前雪柱
			else l1[i]=a[i]-l1[i-1],d1[i]+=a[i]-l1[i-1]; // 如果前一个雪柱部分倒下，计算当前雪柱被推倒的势能
		}
		// 接下来的部分用于从右至左重复计算推倒时间的过程
		for(i=n;i>=1;i--){
			d2[i]=d2[i+1]; // 将之前累积的时间赋值给当前项
			if(l2[i+1]==0) d2[i]+=a[i],l2[i]=a[i]; // 如果后一个雪柱被完全推倒，则当前雪柱独立推倒
			else if(l2[i+1]>=a[i]) l2[i]=a[i]; // 如果后一个雪柱未倒下且足够的势能推倒当前雪柱
			else l2[i]=a[i]-l2[i+1],d2[i]+=a[i]-l2[i+1]; // 如果后一个雪柱部分倒下，计算当前雪柱被推倒的势能
		}
		// 根据题目的要求计算并更新最小推倒时间
		for(i=1;i<=n;i++) ans=min(ans,d1[i-1]+d2[i+1]+max(0ll,a[i]-(l1[i-1]+l2[i+1])));
		cout<<ans<<endl; // 输出最小推倒时间
		// 重置所有用于下一次计算的变量，以确保它们不会影响新的计算
		for(i=0;i<=n+1;i++) d1[i]=d2[i]=l1[i]=l2[i]=0;
	}
	return 0; // 好习惯 
}
```
## Part 5 后记
感谢 [Acoipp](https://www.luogu.com.cn/user/674469#main) 如有问题请联系我删帖。

---

## 作者：liaoxingrui (赞：5)

## Content

有 $n$ 个雪柱排成一排，推倒第 $i$ 个雪柱要花 $a_i$ 点时间，你只能在最左边推或最右边推。每个雪柱倒下都会使得与它相邻（若是从左边推，则向右倒。若是从右边推，则向左倒）的雪柱倒下或减少高度（设这个雪柱高度为 $a_i$，与它相邻的雪柱高度为 $a_j$，则 $a_j = \begin{cases} 0 & a_i \ge a_j \\ a_j - a_i & a_i < a_j \end{cases}$）。若相邻的雪柱倒下，它会继续以同样方向倒下，也就是说雪柱倒下是具有传递性的。

## Solution

这道题我们分两种方向向左和向右，我们可以先算一次从左向右推算出在推倒第 $i$ 个雪柱时所需的时间，再算一次从右向推算出在推倒第 $i$ 个雪柱时所需的时间，最后暴力搜索中间的值（因为会同时左右两边一起推过来）算出答案。

**注意：**

**要清空数组。**

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int t,n;
long long a[N],x[N],y[N],l[N],r[N];
int main(){
	cin>>t;
	while(t--){
		long long ans=LONG_LONG_MAX;
		cin>>n;
		x[0]=l[0]=y[n+1]=r[n+1]=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			x[i]=y[i]=a[i];
		}
		for(int i=1;i<=n;i++)
			if(x[i]>x[i-1]){
				x[i]-=x[i-1];
				l[i]=l[i-1]+x[i];
			}
			else
				l[i]=l[i-1];
		for(int i=n;i;i--)
			if(y[i]>y[i+1]){
				y[i]-=y[i+1];
				r[i]=r[i+1]+y[i]; 
			}
			else
				r[i]=r[i+1];
		for(int i=1;i<=n;i++)
			if(x[i-1]+y[i+1]<a[i])
				ans=min(ans,l[i-1]+r[i+1]+a[i]-x[i-1]-y[i+1]);
			else
				ans=min(ans,l[i-1]+r[i+1]);
		cout<<ans<<endl; 
	}
	return 0;
}
```

---

## 作者：carbon_monoxide (赞：5)

~~论每次打基础赛总是差一分钟就可以敲出 T4 代码这件事情~~

## 题目描述

下雪了，小 Y 堆了 $n$ 个雪柱排成一排，调皮的小 X 打算推倒这 $n$ 个雪柱，他想在最少的时间内推倒所有雪柱，于是他请你来为他出谋划策。

小 Y 堆的每个雪柱高 $a_i$ 单位，推倒一个雪柱的时间为该雪柱的高度。小 X 只能从这一排雪柱的两端推雪柱 \*，次数不限，小 X 移动的时间可以忽略不计。这样就可以使一个雪柱倒向其他雪柱，从而击倒另一个雪柱（击倒的时间忽略不计），然后发生连锁反应，更加节省时间 \*\*。

设初始的势能为当前手动推倒的雪柱 $k$ 的高度 $p=a_k$，则此轮连锁反应中第 $i$ 个雪柱倒向第 $j$ 个雪柱时：

- 若 $p\ge a_j$，则使第 $j$ 个雪柱也被击倒，并令 $p \gets a_j$。
- 若 $p< a_j$，则第 $j$ 个雪柱的高度减少（不被击倒），终止整个连锁反应，令 $a_j \gets a_j-p$。

请你求出推倒所有雪柱的最短时间。

\*：每一次要么从左边推最左边的雪柱，要么从右边推最右边的雪柱。

\*\*：雪柱的倒塌方向取决于推雪柱的方向，如果从左边推，雪柱就会向右依次倒塌（第 $i$ 个雪柱倒塌向第 $i+1$ 个雪柱），反之同理。

## 思路

推雪柱时只能从两边向中间推，因此我们可以直接模拟从左边推到右边和从右边推到左边时在每一个点所花费的时间，再对每个点打擂台求出结果。

实现过程可以用 4 个数组，分别表示从两端到中间的高度和时间。然后分别从两端向中间模拟，每到点 $i$ 时更新数组，最后单独一个循环求出答案。

先定义数组：

```cpp
int t,n,a[100010],l[100010],r[100010],z[100010],y[100010],ans=0x3f3f3f3f3f3f3f3f;
//l和r数组表示从第i个雪柱倒向下一个雪柱时的高度，z和y数组表示当前所花费的时间
```

用类似前缀和的思想求出每个点的高度和花费时间：

```cpp
for(int i=1;i<=n;i++) l[i]=(l[i-1]>=a[i]?a[i]:a[i]-l[i-1]),z[i]=(l[i-1]>=a[i]?z[i-1]:z[i-1]+l[i]);
for(int i=n;i>0;i--) r[i]=(r[i+1]>=a[i]?a[i]:a[i]-r[i+1]),y[i]=(r[i+1]>=a[i]?y[i+1]:y[i+1]+r[i]);
```

最后打擂台：

```cpp
for(int i=1;i<=n;i++) ans=(a[i]<l[i-1]+r[i+1]?min(ans,z[i-1]+y[i+1]):min(ans,z[i-1]+y[i+1]+(a[i]-l[i-1]-r[i+1])));
//注意这里有两种情况，分别是两端雪柱能推倒第i个雪柱与不能推倒它
//遇到后一种情况就再加上雪柱被两边推后剩下的高度即可
```

把这些代码组合起来，我们就可以得到一个满江红的程序。

>对于全部数据，保证：$1 \le T \le 10$，$1 \le n \le 10^5$，$1 \le a_i \le 10^{10}$。

不开 long long 见祖宗。

附上高清无注释代码，非常简洁明了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a[100010],l[100010],r[100010],z[100010],y[100010],ans=0x3f3f3f3f3f3f3f3f;
void clear(){memset(l,0,sizeof(l)),memset(r,0,sizeof(r)),memset(z,0,sizeof(z)),memset(y,0,sizeof(y));}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++) l[i]=(l[i-1]>=a[i]?a[i]:a[i]-l[i-1]),z[i]=(l[i-1]>=a[i]?z[i-1]:z[i-1]+l[i]);
		for(int i=n;i>0;i--) r[i]=(r[i+1]>=a[i]?a[i]:a[i]-r[i+1]),y[i]=(r[i+1]>=a[i]?y[i+1]:y[i+1]+r[i]);
		for(int i=1;i<=n;i++) ans=(a[i]<l[i-1]+r[i+1]?min(ans,z[i-1]+y[i+1]):min(ans,z[i-1]+y[i+1]+(a[i]-l[i-1]-r[i+1])));
		cout<<ans<<"\n";ans=0x3f3f3f3f3f3f3f3f;
		clear();
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

# P10569 「Daily OI Round 4」Snow 题解
## 前言
朋友叫我做基础赛，结果已经结束了（悲）。一气之下，发现可以交题解。针不戳！
## 思路
首先，我们可以用 $d1$ 和 $d2$ 和 $l1$ 和 $l2$ 来分别装往左推的价值，当前左端的雪的高度（为什么这样呢？因为题目要求只能在左或右去推），右推的价值，当前右端的雪的高度。之后开始枚举的时候，我们要分 3 种情况更新：

1. 当上一个左端点为零，此时更新左端点的值，此时就把左边的推了；

2. 当左端点的高度大于当前点，那么我们直接推了（就连锁反应）；

3. 当左端点的高度小于当前点，说明你推了无法发生连锁反应。


然后右边也同理。

那最后的答案怎么求呢？题目说要求最小的，那么我们就依次枚举以哪个点为核心，然后推到它前面和后面的时间加起来就是我们的答案，然后我们要取 $\min$。

当然有细节哟：

1. 要开 long long 啊，傻孩子。

2. （~~要 man~~）要 memset 一下。


```cpp
#include<bits/stdc++.h>

#define int long long//基操，勿6

using namespace std;

const int N = 1e5+10;

int w[N];
int d1[N],l1[N];
int d2[N],l2[N];
int n,T;
int ans;

signed main(){
    cin>>T;
    
    while(T--){
        
        memset(d1,0,sizeof d1);
        memset(d2,0,sizeof d2);
        memset(l1,0,sizeof l1);
        memset(l2,0,sizeof l2);
        ans=1e18;
        cin>>n;
        
        for(int i=1;i<=n;i++)cin>>w[i];
        
        //往左推
        for(int i=1;i<=n;i++){
            d1[i]=d1[i-1];
            if(l1[i-1]==0)d1[i]+=w[i],l1[i]=w[i];//若前一个雪柱被完全推倒，则当前雪柱独立推倒
            else if(l1[i-1]>=w[i])l1[i]=w[i];//若前一个雪柱未倒下且足够的势能推倒当前雪柱
            else{
                l1[i]=w[i]-l1[i-1],d1[i]+=(w[i]-l1[i-1]);// 若前一个雪柱部分倒下，计算当前雪柱被推倒的势能
            }
        }
        //从右推
        for(int i=n;i>=1;i--){
            d2[i]=d2[i+1];
            if(l2[i+1]==0)d2[i]+=w[i],l2[i]=w[i];
            else if(l2[i+1]>=w[i])l2[i]=w[i];
            else{
                l2[i]=w[i]-l2[i+1],d2[i]+=(w[i]-l2[i+1]);
            }
        }
        
        for(int i=1;i<=n;i++)ans=min(ans,d1[i-1]+d2[i+1]+max(0ll,w[i]-(l1[i-1]+l2[i+1])));
        
        
        cout<<ans<<endl;
        
    }
    
    return 0;
}
```

---

## 作者：qiuqiuqzm (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10569)
# 分析
~~这道题比赛的时候虽然看出来是贪心了，但是没调好，就只打了一个暴力骗分。~~

还是比较容易看出来本题是贪心的，但是要怎么贪心是个难点。

我们发现些雪柱很容易发生连锁反应，所以我们就可以预处理两个数组 $l,r$。$l_i$ 和 $r_i$ 代表从最左边和最右边开始推，推到第 $i$ 个点所需的时间。

然后再用两个 $pl,pr$ 数组，代表从最左边和最右边推到当前这个位置的势能，这样在最后计算时才可以算出最后一个雪堆要用多少时间才能推倒。

那么我们只要枚举结束的雪堆然后取最小值就可以了。

最后，**记得开 long long。**

# Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXX=100005;
int t,n,a[MAXX],ans,l[MAXX],r[MAXX],pl[MAXX],pr[MAXX];
signed main()
{
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i],pl[i]=pr[i]=a[i];
		ans=1e18;
		l[n+1]=l[0]=r[n+1]=r[0]=pl[n+1]=pl[0]=pr[n+1]=pr[0]=a[n+1]=a[0]=0;//多测不清空...
		for(int i=1;i<=n;i++)
		{
			if(pl[i]>pl[i-1])
				l[i]=l[i-1]+pl[i]-pl[i-1],pl[i]=pl[i]-pl[i-1];
			else
				l[i]=l[i-1];
		}
		for(int i=n;i>=1;i--)
		{
			if(pr[i]>pr[i+1])
				r[i]=r[i+1]+pr[i]-pr[i+1],pr[i]=pr[i]-pr[i+1];
			else
				r[i]=r[i+1];
		}
		for(int i=1;i<=n;i++)
		{
			ans=min(ans,pl[i-1]+pr[i+1]<a[i]?l[i-1]+r[i+1]+a[i]-pl[i-1]-pr[i+1]:l[i-1]+r[i+1]);
			/*等价代码
			if(pl[i-1]+pr[i+1]<a[i])
				ans=min(ans,l[i-1]+r[i+1]+a[i]-pl[i-1]-pr[i+1]);
			else
				ans=min(ans,l[i-1]+r[i+1]);
			*/
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Infinite_Loop (赞：1)

# 题意
给定 $n$ 个雪柱，第 $i$ 个雪柱的高度为 $a_{i}$。现在你可以用 $a_{i}$ 个时间向左或向右推倒第 $i$ 个雪柱，那么就会引发连锁反应。问推倒所有的雪柱最少需要多少时间。
## 思路
很明显，本题是一道贪心。

因为我们只能向左向右推雪柱，所以我们可以计算从最左端推到第 $i$ 个雪柱最少需要的时间，从最右端推到第 $i$ 个雪柱最少需要的时间。

然后我们只需从前往后枚举每个雪柱，如果到这里还不能推完，$ans=l_{i-1}+r_{i+1}+a_{i}-l_{i-1}-r_{i+1}$，如果能推完，$ans=l_{i-1}+r_{i+1}$。最后的输出即为每个 $ans$ 的最小值。

需要注意的地方：

- 要开 long long。
- 多测要清空。
- 输出要换行。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int t,n,a[N],x[N],y[N],l[N],r[N];
signed main(){
    ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		y[n+1]=r[n+1]=0;
		for(int i=1;i<=n;i++)cin>>a[i],x[i]=a[i],y[i]=a[i];
		for(int i=1;i<=n;i++){
			if(x[i]>x[i-1]){
				x[i]-=x[i-1];
				l[i]=l[i-1]+x[i]; 
			}else{
				l[i]=l[i-1];
			}
		}
		for(int i=n;i>=1;i--){
			if(y[i]>y[i+1]){
				y[i]-=y[i+1];
				r[i]=r[i+1]+y[i];
			}else{
				r[i]=r[i+1];
			}
		}
		int ans=1e18;
		for(int i=1;i<=n;i++){
			if(x[i-1]+y[i+1]<a[i]){
				ans=min(ans,l[i-1]+r[i+1]+a[i]-x[i-1]-y[i+1]);
			}else{
				ans=min(ans,l[i-1]+r[i+1]);
			}
		}
		cout<<ans<<'\n';
	}
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

你说得对，但向左向右交替等价于先只做其中一个再只做另一个。

那么我们可以设 $f1_i$ 表示从左边推到 $i$ 的时间，$f2_i$ 表示从右边，$l1_i$ 为左边推到 $i$ 时的能量，$l2_i$ 为右边推到 $i$ 时的能量，那么（拿 $l1$ 举例）：

- 如果 $l1_{i-1}< a_i$，那么 $i$ 不会被推倒：$f1_i=f1_{i-1}+a_i-l_{i-1},l1_i=a_i-l_{i-1}$。
- 如果 $l1_{i-1}\ge a_i$，那么 $i$ 被推倒了：$f1_i=f1_{i-1},l1_i=a_i$。

$f2,l2$ 同理。

那么最终答案 $ans=\min\{f1_{i-1}+f2_{i+1}+\max\{a_i-(l1_i+l2_i),0\}\}$。

upd：修改了一些内容。

---

## 作者：T_TLucas_Yin (赞：0)

很容易证明，对于任意两种推法，如果最后一个推倒的雪柱是同一个，那么不管推的方向顺序如何，这两种方法的总用时都是一样的。

因为没有一个雪柱被重复推倒了两次。而对于一排雪柱：

- 如果从某一个方向可以推倒剩余的所有雪柱，那么从这个方向推肯定是最优的；而从另一个方向推虽然会耗费更长的时间，但也会把最优情况下最后推倒的雪柱第一个推倒，改变了最后一个雪球，就不属于当前讨论的情况了，所以不影响。

- 若一次无法推倒剩余所有雪柱，则先从左边推或先从右边推不影响结果，直到出现第一种情况后才需要考虑顺序。

这样，我们就可以考虑枚举每一个雪柱作为最后一个推倒时的情况。即对于一个雪柱，总时间为，把它左边的全都推倒，再把它右边的全都推倒，若此时它自己还没倒就再加上推倒它的时间。

我们可以模拟两种推的方案，一种是一路从左往右推，另一种是一路从右往左推。这样在按上述枚举时，拿出从左边推到前一格的时间和从右边推到后一格的时间相加即可。最后在每个位置的答案中取最小值为最终答案。是一种简单的贪心策略。

注意清空数组。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[1000005],b1[1000005],b2[1000005],f1[1000005],f2[1000005];
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		memset(a,0,sizeof(a));
		memset(b1,0,sizeof(b1));
		memset(b2,0,sizeof(b2));
		memset(f1,0,sizeof(f1));
		memset(f2,0,sizeof(f2));
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++){
			if(b1[i-1]>=a[i]) b1[i]=a[i],f1[i]=f1[i-1];
			else b1[i]=a[i]-b1[i-1],f1[i]=f1[i-1]+b1[i];
		}
		for(int i=n;i>=1;i--){
			if(b2[i+1]>=a[i]) b2[i]=a[i],f2[i]=f2[i+1];
			else b2[i]=a[i]-b2[i+1],f2[i]=f2[i+1]+b2[i];
		}
		int minn=1e18;
		for(int i=1;i<=n;i++){
			if(b1[i-1]+b2[i+1]>=a[i]) minn=min(minn,f1[i-1]+f2[i+1]);
			else minn=min(minn,f1[i-1]+f2[i+1]+(a[i]-b1[i-1]-b2[i+1]));
		}
		cout<<minn<<"\n";
	}
	return 0;
}
```

---

## 作者：huangzhixia (赞：0)

有点难度，毕竟贪心思路不是很好想。

-------------

 开始认为是动态规划，但想想根本不行，比较明显的贪心吧。
 
 设从左边第 $1$ 个点推到右边第 $i$ 个点需要花费的时间为 $l_i$，从右边第 $1$ 个点推到左边第 $i$ 个点需要花费的时间为 $r_i$。这些都是预处理完成的。预处理时间复杂度仅为 $O(n)$。
 
 预处理结束后，设 $res$ 为答案，那么对于每一个雪人，我们都需要给 $res$ 取 $\min$。可以得出贪心结论：枚举所有的雪人，当且仅当这个雪人如果能给它推倒，那么 $res = l_{i-1} + r_{i+1}$，否则，$res = l_{i-1} + r_{i+1} + a_i - l_{i -1} - r_{i+1}$。取完 $\min$ 后，$res$ 即为答案。
 
 -----------------
 
 贪心好题，可能需要一些分讨。
 
 [AC Record](https://www.luogu.com.cn/record/161867032)

---


# 双人游戏

## 题目背景

写完论文的莲子终于意识到了这么多天埋头写论文而不理会梅莉的错误，并打算约梅莉出来玩。为此，她构思了一个有趣的双人游戏。

## 题目描述

莲子构思了一个双人游戏，不妨令游戏的两个玩家为小 R 和小 M，规则如下：

有一个 $1\times n$ 的棋盘。初始时，棋盘上有一些黑色棋子，一些白色棋子，和 $m$ 个空格子。我们可以用一个长度为 $n$ 的字符串 $s$ 来描述初始时的棋盘，若 $s_i$ 为 `B` 则代表该位置为黑棋子，为 `W` 则代表白棋子，为 `_` 则代表空格子。**请注意，棋盘上可能没有空格子。**

游戏开始前，除了棋盘的初始状态，两人还会获得一个操作序列 $O=[\lang c_1,x_1\rang, \lang c_2,x_2\rang, \cdots,\lang c_m,x_m\rang]$，其中二元组 $\lang c_i,x_i\rang$ 满足 $c_i\in\{\mathtt{R}, \mathtt{M}\}$ 且 $x_i$ 位置此时是一个空格子，表示在第 $i$ 步，玩家小 $c_i$ 应该在 $x_i$ 位置放上一个黑色棋子或者白色棋子。序列 $O$ 对双方公开，也就是说双方均知道每一步是由谁在哪个位置放上一枚棋子。

游戏过程中，双方会按照该操作序列进行操作。第 $i$ 轮时小 $c_i$ 在 $x_i$ 位置放置一枚棋子，棋子的颜色由该玩家决定。在游戏结束时所有格子都被放上了恰好一枚棋子。

小 R 希望游戏结束后棋子组成的**极长同色连续段数**$^*$尽可能多，而小 M 则希望其尽可能少。试着求出两人都以最优方式摆放棋子的话最后的连续段数为几。容易证明答案是一个定值。

注：一个棋子的极长同色连续段被定义为一个二元组 $(l,r)$ 满足 $l\le r$，且从左至右数第 $l$ 个棋子到第 $r$ 个棋子颜色相同，且第 $l-1$ 个和第 $r+1$ 个棋子要么不存在，要么与前面所说的棋子颜色不同。

## 说明/提示

### 样例解释

#### 样例 \#1

最终的棋子摆放结果为 `BWW`，可以证明两人这样摆均为最优。极长连续段数为 $2$。
#### 样例 \#2

为了让连续段数尽可能大，先手摆放两个空格子的小 R 一定会让两个格子的棋子颜色不同。然后小 M 会放置一个任意颜色的棋子。有多种可能的最终摆放结果，其中一种为 `BWW`，极长连续段数为 $2$。

注意到该样例符合特殊性质 $\mathbf{B}$。
#### 样例 \#3

最终的棋子摆放结果为 `BWBWB`，极长连续段数为 $5$。

注意到该样例符合特殊性质 $\mathbf{A}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n,m\le } & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 20 & - &-\cr\hline
2 & 10 & 2\times 10^5 & \mathbf{A}&- \cr\hline
3 & 20 & 2\times 10^5 & \mathbf{B}&- \cr\hline
4 & 20 & 10^3 & -&1  \cr\hline
5 & 40 & 2\times 10^5 & -&1,2,3,4  \cr\hline
\end{array}
$$

特殊性质 $\mathbf{A}$：保证要么 $c_i$ 均为 $\tt R$，要么 $c_i$ 均为 $\tt M$。\
特殊性质 $\mathbf{B}$：保证 $s$ 中所有字母均为 $\tt \_$。

对于所有数据满足：$\red0\le m\le 2\times 10^5 $，$1\le n\le 2\times 10^5$，且有 $m\le n$，$s_i\in \{\tt{B,W,\_}\}$。

## 样例 #1

### 输入

```
3 2
B__
R 3
M 2```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 3
___
R 1 
R 3
M 2```

### 输出

```
2```

## 样例 #3

### 输入

```
5 2
BW__B
R 4
R 3```

### 输出

```
5```

# 题解

## 作者：_O_v_O_ (赞：26)

## 前言

我赛时傻了，想到这个解法后自我否定掉了，痛失前 $30$ 名，大家引以为戒。

## 思路

首先很显然各自都知道对方的操作，那么就相当于操作的先后没用。

那么我们可以把每个 $s_{x_i}$ 设为 $c_i$，对于一个 $s_{i}$：

- 如果它是 $\tt W$ 或 $\tt B$，那么啥都不用做；
- 如果它是 $\tt R$，因为小 R 是想让极长同色连续段数尽量多，所以他肯定会染与 $s_{i-1}$ 相反的颜色；
- 如果它是 $\tt M$，因为小 M 是想让极长同色连续段数尽量少，所以他肯定会染与 $s_{i-1}$ 相同的颜色；

但是我们注意到如果这样搞，在前面有一连串空棋盘时，前面都没法被进行有效操作。

那么很明显我们可以再倒着来一遍就行了啊，这样前面的空棋盘也能被处理到。

可是我们发现还有一个边界：$n=m$（即整个棋盘都是空的），此时我们发现第一轮下 $\tt W$ 和 $\tt B$ 是等价的，那么我们只用随便下一个就行了。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e5+5;
int n,m,ans;
string s;
char c;
int k;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>m>>s;s=' '+s;
	for(int i=1;i<=m;i++){
		cin>>c>>k;
		if(m==n&&i==1) s[k]='W';
		else s[k]=c;
	}
	for(int i=1;i<=n;i++){
		if(s[i]=='R'){
			if(s[i-1]=='B') s[i]='W';
			if(s[i-1]=='W') s[i]='B';
		}
		if(s[i]=='M'){
			if(s[i-1]=='B') s[i]='B';
			if(s[i-1]=='W') s[i]='W';
		}
	}
	for(int i=n;i>=1;i--){
		if(s[i]=='R'){
			if(s[i+1]=='B') s[i]='W';
			if(s[i+1]=='W') s[i]='B';
		}
		if(s[i]=='M'){
			if(s[i+1]=='B') s[i]='B';
			if(s[i+1]=='W') s[i]='W';
		}
	}
	for(int i=1;i<=n;i++){
		if(s[i]!=s[i-1]) ans++;
	}
	cout<<ans;
	return 0;
}
```
upd：修改了一些笔误。

---

## 作者：chen_zhe (赞：11)

首先，极长同色连续段数量可以等价于所有相邻且不同色的棋子对数量加 $1$，于是我们需要关注的即为相邻的棋子对。

观察到上述性质后似乎有一种 dp 做法可以达到线性复杂度，但这个做法并不是正解想要讨论的内容，读者可以自行思考。

接下来可以先考虑特殊性质 B，因为它看起来很不平凡。容易发现，第一个人放的棋子是什么颜色并不会影响结果，所以不妨假设它放的是黑色。

现在让我们考虑一下，如果忽略掉摆放顺序，两人会怎么摆棋子。假设已确定颜色的棋子在位置 $x$ 并且，那么从 $x$ 出发考虑它相邻的棋子。如果是小 R 那么她会选择放一个不同色的，小 M 则相反。依此类推，最后所有棋子的颜色都会被确定。

接下来加上顺序，考虑一下小 R 和小 M 会不会改变策略（也就是放上一个不同色的棋子）。可以发现，如果小 R 改变了策略，而小 M 不变策略，小 R 只会得到相同或者更差的结果，反之亦然。所以事实上小 R 和小 M 根本不会改变策略！答案等价于顺序无效、

那么如果初始时有棋子呢？有棋子的位置将棋盘分割成了数个连续段，你可以对于每个连续段做和上面所述一样的事情，即无视顺序以某个边界上的有色棋子为基准进行贪心。容易发现得到的策略是最优的，证明同上。

---

## 作者：未来姚班zyl (赞：4)

## 题目大意

给你一个长度为 $n$ 的 $01$ 序列，$m$ 个位置未填数。小 R 和小 M 要将这些位置填上数。

对于未填数的位置，将依次操作 $m$ 次：第 $i$ 次由 $c_i$ 填位置 $p_i$ 的数。

小 R 希望极长连续 $01$ 段的数量尽量多，小 M 则希望尽量少，且他们一开始就知道操作的顺序，他们都绝顶聪明，求最后的极长 $01$ 段数。

## 题目分析

来个暴力的 dp 做法。

首先，我们做一个简单的转换：极长连续段数相当于 $\sum\limits_{i\in[2,n]} [s_i\neq s_{i-1}]+1$。其实就是段数等于间隔数加一。小 R 和小 M 需要最大/小化的都是间隔数。其中间隔数为 $s_i\neq s_{i-1}$ 的数量。

其次，要发现一个关键的性质：每个没填数的连续段的答案是独立的。

知道这两个结论我们就可以很自然地设计出 dp 状态 $f_{l,r,ty}$ 表示对于区间 $[l,r]$，如果 $s_{l-1}$ 与 $s_{r+1}$ 的状态为 $ty$，则最后会有多少个间隔。然后看看需要的状态会有哪些，我比较笨蛋，需要 $5$ 种状态：

- $ty=1$，则 $l$ 和 $r$ 都是边界，即不存在 $s_{l-1}$ 和 $s_{r+1}$。

- $ty=2$，则 $l$ 是边界，$r$ 不是边界。注意我们不关心 $s_{r+1}$ 到底是 $0$ 还是 $1$，只关心中间填的数是否等于 $s_{r+1}$，以下同理。

- $ty=3$，则 $l$ 不是边界，$r$ 是边界。

- $ty=4$，则 $s_{l-1}\neq s_{r+1}$。

- $ty=5$，则 $s_{l}=s_r$。

这个区间第一个填数的位置是固定的，直接枚举它的两种取值即可，然后将贡献计算并转移：如果是小 R 填，则两种情况取 $\max$；如果是小 M 填，则两种情况取 $\min$。

转移是 $O(1)$ 的，而需要用到的区间只有 $O(n)$ 个，直接 st 表维护区间最小值，map 维护状态，即可 $O(n\log n)$ 通过此题。

- 补充：优化到线性的方法。

注意到找最小值的过程与建笛卡尔树的过程一样，所以可以直接在笛卡尔树上 dp，做到 $O(n)$。

由于我是个蒟蒻，所以不会笛卡尔树，只能贴个 $O(n\log n)$ 的代码。

```cpp
#include<bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define Pi pair<int,int>
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
using namespace std;
const int N=2e5+5;
int n,m,a[N],b[N];
string s;
char c[N];
map<Pi,int>f[N];
int t[N],ty[N];
int st[N][20],lg[N];
inline int got(int x,int y){
	return t[x]<t[y]?x:y;
}
inline int get(int l,int r){
	int p=lg[r-l+1];
	return got(st[l][p],st[r-(1<<p)+1][p]);
}
inline int gets(int x,int y,int ty){
	return ty?max(x,y):min(x,y);
}
inline int solve(int l,int r,int t){
	if(l>r)return 0;
	if(l==r){
		if(t==1)return 0;
		if(t<=3)return ty[l];
		if(t==4)return 1;
		return ty[l]?2:0;
	}
	if(f[l].find({r,t})!=f[l].end())return f[l][{r,t}];
	int &ans=f[l][{r,t}],ps=get(l,r);ans=0;
	if(t==1)return ans=solve(l,ps-1,3)+solve(ps+1,r,2);
	if(t==2)return ans=gets(solve(l,ps-1,5)+solve(ps+1,r,2),solve(l,ps-1,4)+solve(ps+1,r,2)+(ps==l),ty[ps]);
	if(t==3)return ans=gets(solve(l,ps-1,3)+solve(ps+1,r,5),solve(l,ps-1,3)+solve(ps+1,r,4)+(ps==r),ty[ps]);
	if(t==4)return ans=gets(solve(l,ps-1,5)+solve(ps+1,r,4)+(ps==r),solve(l,ps-1,4)+solve(ps+1,r,5)+(ps==l),ty[ps]);
	return ans=gets(solve(l,ps-1,5)+solve(ps+1,r,5),solve(l,ps-1,4)+solve(ps+1,r,4)+(ps==l)+(ps==r),ty[ps]);
}
inline void Main(){
	n=read(),m=read(),cin>>s,s='#'+s,lg[0]=-1;
	repn(i)b[i]=s[i]=='_'?-1:s[i]=='B'?1:0;
	int tot=1;
	rep(i,2,n)tot+=b[i]+b[i-1]==1&&b[i]!=b[i-1];
	repn(i)t[i]=n+1;
	repm(i)cin>>c[i],a[i]=read(),t[a[i]]=i,ty[a[i]]=c[i]=='R'?1:0;
	repn(i)st[i][0]=i,lg[i]=lg[i>>1]+1;
	rep(p,1,19)rep(i,1,n-(1<<p)+1)st[i][p]=got(st[i][p-1],st[i+(1<<p-1)][p-1]);
	repn(i)if(b[i]==-1){
		int j=i;
		while(j<n&&b[j+1]==-1)j++;
		if(i==1&&j==n)tot+=solve(i,j,1);
		else if(i==1)tot+=solve(i,j,3);
		else if(j==n)tot+=solve(i,j,2);
		else if(b[i-1]==b[j+1])tot+=solve(i,j,5);
		else tot+=solve(i,j,4);
		i=j;
	}
	cout<<tot;
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}
```

---

## 作者：Lucky_Xiang (赞：3)

## 题目

[P10608](https://www.luogu.com.cn/problem/P10608)

## 分析

这里介绍一种比较暴力的方法。

假设在所有操作都已经完成后，得到的字符串为 $s$。则它的**极长同色连续段数**（下简称“连续段数”）显然是 $1+\sum\limits_{i=1}^{n-1}[s_i\ne s_{i+1}]$。这意味着连续段数只与**相邻两位是否相同**有关。

假设现在字符串有连续的三位是 `B__`。如果你正在填入正中间的位置，且想要连续段数**最大**，则填入 `W` 一定不劣。因为填入 `W` 后可以出现一个 `BW`，就能使连续段数至少 $+1$；而如果填入 `B`，则 `BB` 不能对连续段数产生影响，而即使后来在右边空格填入 `W` 也只能使连续段数 $+1$，还不如现在填入 `W` 直接使连续段数 $+1$。

类似的，如果想要使连续段数**最小**，则填入 `B` 一定不劣。

-----

这就启发我们维护**颜色已经被确定**的区间。设在进行完若干步操作后，可以找到 $k$ 个区间 $[l_i,r_i]$，使得它们两两不交（同时不相邻），且它们的并等于所有**颜色已经被确定**的位置。

可以发现对于区间 $[L,R]$，可能有两种状态：

1. 如果**原串**中 $[L,R]$ 里面有颜色被固定的位置，则 $[L,R]$ 所有位置的颜色都已经被**唯一确定**。
2. 如果**原串**中 $[L,R]$ 里面没有颜色被固定的位置，则 $[L,R]$ 中虽然颜色不能被确定，但是它们的**相对关系**已经被确定。而这些位置的具体颜色就由**第一个**在该区间填入颜色的人（下简称该区间的“主宰者”）确定。

-----

关键在于区间的合并以及贡献的计算。设现在需要合并 $[L,p]$ 和 $[p+1,R]$ 两个区间。

1. 如果 $[L,p]$ 和 $[p+1,R]$ 都属于第一种状态，就可以直接通过判断 $s_p$ 和 $s_{p+1}$ 是否相同来计算贡献。
2. 如果 $[L,p]$ 和 $[p+1,R]$ 一个属于第一种状态，另一个属于第二种状态（不妨设 $[p+1,R]$ 属于第二种状态），则 $[p+1,R]$ 的主宰者就可以根据他的目的来决定 $s_p$ 和 $s_{p+1}$ 是否相同，进而可以通过这个计算贡献。
3. 如果 $[L,p]$ 和 $[p+1,R]$ 都属于第二种状态，则两个区间的主宰者中**后填入**的人可以决定 $s_p$ 和 $s_{p+1}$ 是否相同，于是可以根据这个计算贡献。

-----

可以使用并查集模拟区间的合并。时间复杂度 $O(n\alpha(n))$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mn=200010;
int n,m;
char s[mn];
struct node //并查集
{
    int fa;
    int mi,st; //第一次填入的时间、区间左右是否相同
    int L; //当区间颜色已被唯一确定时，用来记录最左边位置的颜色
};
node p[mn];
int gf(int x)
{
    if(x==p[x].fa)return x;
    return p[x].fa=gf(p[x].fa);
}
int res=1;
int op[mn];
int k;
char ch;
void merge(int x,int y) //分类讨论合并区间
{
    x=gf(x); y=gf(y);
    if(p[x].mi==0 && p[y].mi==0) //都为第一种状态
    {
        res+=(p[x].L^p[x].st^p[y].L);
        p[y].st=(p[x].L!=(p[y].L^p[y].st));
        p[y].L=p[x].L;
        p[x].fa=y;
        return;
    }

    int flag=0;
    if(p[x].mi>p[y].mi)flag=op[p[x].mi];
    else flag=op[p[y].mi];

    if(p[x].mi==0) //仅有左区间为第一种状态
    {
        p[y].mi=min(p[x].mi,p[y].mi);
        res+=flag;
        p[y].st=(p[x].st^flag^p[y].st);
        p[y].L=p[x].L;
        p[x].fa=y;
        return;
    }
    if(p[y].mi==0) //仅有右区间为第一种状态
    {
        p[y].mi=min(p[x].mi,p[y].mi);
        res+=flag;
        p[y].L=(p[y].L^flag^p[x].st);
        p[y].st=(p[y].st^flag^p[x].st);
        p[x].fa=y;
        return;
    }
    //都为第二种状态
    p[y].mi=min(p[x].mi,p[y].mi);
    res+=flag;
    p[y].st=(p[y].st^flag^p[x].st);
    p[x].fa=y;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>m;
    cin>>(s+1);
    for(int i=1;i<=n;i++)
    {
        p[i]={i,m+1,0,0};
        if(s[i]!='_')
        {
            if(s[i]=='B')p[i].mi=0, p[i].L=0;
            if(s[i]=='W')p[i].mi=0, p[i].L=1;
        }
    }
    for(int i=1;i<n;i++)if(s[i]!='_' && s[i+1]!='_')merge(i,i+1);
    for(int i=1;i<=m;i++)
    {
        cin>>ch>>k;
        if(ch=='R')op[i]=1;
        else op[i]=0;
        p[k].mi=i; s[k]='0';
        if(k>1 && s[k-1]!='_')merge(k-1,k);
        if(k<n && s[k+1]!='_')merge(k,k+1);
    }
    cout<<res<<endl;
    return 0;
}
```

---

## 作者：yywlp (赞：2)

简单题，结论比较显然。

虽然题目中的操作有顺序，但是这里的每个操作都是有固定最优方案的，所以可以不管顺序直接填。

我们看看两个人会怎么操作。

### 对于小 R：

因为他要让**极长同色连续段数**尽量多，那么会发现如果一个位置是他来填，他一定会填与前一个异色的，因为这样必然增加一段，**不劣于**与前一个填同色。

### 对于小 M：

和小 R 相反，他一定会填与上一个相同的，这样一定不会增加一段，**不劣于**与前一个异色。

**ps：这里说不劣于是因为有可能出现 `B_W` 这样的情况，中间无论填什么都没区别。**

最后直接从前往后扫，看看当前是谁填，按照规则填就行了。

但是这里需要注意两点：

### Situation 1：最前面连续一段是 `_`

这个只需要扫一下找到第一个为 `B` 或 `W` 的，反着填回来就行。

### Situation 2：全都是 `_`

这里我们找到第一个人填的位置随便填一个颜色，然后按照上一种情况做就行。

时间复杂度 $\mathcal O(n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=2e5+10;
int n,m;
char s[M],c[M],cx[M],ds[M];
int x[M];
char getf(char x) {
	if(x=='B')return 'W';
	return 'B';
}
signed main() {
	cin>>n>>m;
	cin>>(s+1);
	for(int i=1; i<=m; i++)cin>>c[i]>>x[i],cx[x[i]]=c[i];
	int l=1,r=n;
	while(s[l]=='_')l++;
	l--;
	if(l==n) {
		int ans=0;
		s[x[1]]='B';
		l=1,r=n;
		while(s[l]=='_')l++;
		l--;
		while(s[r]=='_')r--;
		r++;
		for(int i=l; i>=1; i--) {
			if(cx[i]=='R')s[i]=getf(s[i+1]);
			else if(cx[i]=='M')s[i]=s[i+1];
		}
		for(int i=r; i<=n; i++) {
			if(cx[i]=='R')s[i]=getf(s[i-1]);
			else if(cx[i]=='M')s[i]=s[i-1];
		}
		for(int i=1; i<=n; i++)if(s[i]!=s[i-1])ans++;
		cout<<ans<<endl;
	} else {
		while(s[r]=='_')r--;
		r++;
		for(int i=l; i>=1; i--) {
			if(cx[i]=='R')s[i]=getf(s[i+1]);
			else if(cx[i]=='M')s[i]=s[i+1];
		}
		for(int i=r; i<=n; i++) {
			if(cx[i]=='R')s[i]=getf(s[i-1]);
			else if(cx[i]=='M')s[i]=s[i-1];
		}
		for(int i=l+1; i<=r-1; i++) {
			if(cx[i]=='R')s[i]=getf(s[i-1]);
			else if(cx[i]=='M')s[i]=s[i-1];
		}
		int ans=0;
		for(int i=1; i<=n; i++)if(s[i]!=s[i-1])ans++;
		cout<<ans<<endl;
	}
	return 0;
}

---

## 作者：封禁用户 (赞：2)

## 前言：
竟然有如此水的绿题。

## 思路：

我们可以将 $s$ 的空格子改成它的人。

若 $s_{i}$ 是 $W$ 或 $B$ 的话，则我们可以不用管它。

易得，若 $s_{i}$ 是 $R$ 的话，则肯定是将它改成与 $s_{i-1}$ 相反的颜色。

易得，若 $s_{i}$ 是 $M$ 的话，则肯定是将它改成与 $s_{i-1}$ 相同的颜色。

但是我们注意到如果这样搞，在前面有一连串空棋盘时，前面都没法被进行有效操作，所以很明显我们可以再倒着来一遍，这样前面的空棋盘也能被处理到。

如果全都是空格子的话，上述步骤是不起作用的，易得当且仅当这种情况下 $s_{1}$ 的数值是不影响最后结果的，所以这样可以取任意值。

注意：不要关注摆放顺序，除了特殊性质 $B$ 中的第一回合摆放的位置，这个位置可以放 $W$ 也可以放 $B$。

## AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,x,t,al,bl;
char c;
bool p,ans=0;
string s;
const long long N=200005;
long long a[N],l[N];
long long F()
{
	long long sum=0;
	for(long long i=1;i<=n;i++)
	{
		if(a[i]!=a[i-1])
		{
			sum++;
		}
	}
	return sum;
}
int main()
{
	//	freopen(".in","r",stdin);
	//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m >> s;
	s=" "+s;
	for(long long i=1;i<=n;i++)
	{
		if(s[i]=='B')
		{
			a[i]=1;
			p=1;
		}
		if(s[i]=='W')
		{
			a[i]=2;
			p=1;
		}
	}
	for(long long i=1;i<=m;i++)
	{
		c=' ';
		cin >> c >> x;
		if(c=='M')
		{
			l[x]=2;
		}
		if(c=='R')
		{
			l[x]=1;
		}
		if(!ans && !p)
		{
			ans=1;
			bl=x;
		}
	}
	if(!p)
	{
		a[bl]=1;
	}
	for(long long i=1;i<=n;i++)
	{
		if(a[i]!=0)
		{
			al=i;
			break;
		}
	}
	for(long long i=al-1;i>=1;i--)
	{   
		if(l[i]==1)
		{
			if(a[i+1]==2)
			{
				a[i]=1;
			}
			else
			{
				a[i]=2;
			}
		}
		else
		{
			a[i]=a[i+1];
		}
	}
	for(long long i=al+1;i<=n;i++)
	{
		if(a[i]==0)
		{
			if(l[i]==1)
			{
				if(a[i-1]==2)
				{
					a[i]=1;
				}
				else
				{
					a[i]=2;
				}
			}
			else
			{
				a[i]=a[i-1];
			}
		}
		
	}
	cout << F() << endl;
	return 0;
}
``````

---

## 作者：封禁用户 (赞：2)

# 题解：P10608 双人游戏

## 题意

给予你一个长度为 $n$ 的字符串 $c$，$c$ 上有三种颜色的棋子，其中有 $m$ 个空字符。

接下来有 $m$ 个操作，每个操作意味小 M 或小 R 将某一个空棋子改成黑或白棋子。

小 R 希望游戏结束后棋子组成的极长同色连续段数尽可能多，而小 M 则希望其尽可能少。

每个人都会按照自己的意愿做最有做法。

求最终的极长同色连续段数。

## 思路

我们可以先将 $c$ 的空格子改成改变它的人。

- 若 $c_{i}$ 是 $W$ 或 $B$，则不用管它。

- 易得，若 $c_{i}$ 是 $R$，则肯定是将它改成与 $c_{i-1}$ 相反。

- 易得，若 $c_{i}$ 是 $M$，则肯定是将它改成与 $c_{i-1}$ 相同。

但这么写会遗漏前面一大堆空格子的情况，这样的话，只要从尾到头的重复上述步骤即可。

如果全是空格子，上述步骤是不起作用的，易得当且仅当这种情况下 $c_{1}$ 的数值是不影响最后结果的，所以可以取任意值。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s[200005],x;
string c;
char  A;
int main(){
	cin>>n>>m>>c;
	c=' '+c;
	for(int i=1;i<=m;i++){
		cin>>A>>x;
		if(m==n&&i==1)A='W';
		c[x]=A;
	}	
//	cout<<c<<"\n";
	for(int i=1;i<=n;i++){
		
		if(c[i]=='R'){
			if(c[i-1]=='B')c[i]='W';
			else if(c[i-1]=='W')c[i]='B';
		}else if(c[i]=='M'){
			if(c[i-1]=='B')c[i]='B';
			else if(c[i-1]=='W')c[i]='W';
		}
		//cout<<c<<"\n";
	}
	for(int i=n;i>=1;i--){
		
		if(c[i]=='R'){
			if(c[i+1]=='B')c[i]='W';
			else if(c[i+1]=='W')c[i]='B';
		}else if(c[i]=='M'){
			if(c[i+1]=='B')c[i]='B';
			else if(c[i+1]=='W')c[i]='W';
		}
		//cout<<c<<"\n";
	}
//	cout<<c<<"\n";
	int ans=1;
	for(int i=2;i<=n;i++)if(c[i]!=c[i-1])ans++;
	cout<<ans;
	return 0;
}
```

---

## 作者：XiaoJuRuoUP (赞：1)

## 题意
长度为 $n$ 的序列 $s$，其中只包含 `B`，`W` 和 $m$ 个 `_`。给定长度为 $m$ 的序列 $O=[\lang c_1,x_1\rang, \lang c_2,x_2\rang, \cdots,\lang c_m,x_m\rang](c_i\in\{\mathtt{R}, \mathtt{M}\},s_{x_i}=\_)$，表示玩家小 $c_i$ 需要将 $s_{x_i}$ 修改为 `B` 或 `W`，且 $O$ 对小R和小M**公开**。

小R希望极长同色连续段数（定义见原题）尽可能多，小M希望极长同色连续段数尽可能少，求经过序列 $O$ 的操作后，极长同色连续段数的数量。
## 赛时
[~~Subtask 害人不浅~~](https://www.luogu.com.cn/record/162364620)

由于序列 $O$ 对双方公开，所以对双方来说，即使需要按照 $O$ 的顺序来操作，双方的操作也**可以视为无序**，因此我们可以将 $c_i$ 直接填入 $s$ 中。

假设 $O$ 中只剩下操作 $\lang c_m,x_m \rang$ 没有进行，若 $c_m=\mathtt{R}$，则可能存在三种情况：
1. $s_{x_i - 1} = s_{x_i + 1}$，此时选择与 $s_{x_i - 1}$ 和 $s_{x_i + 1}$ 相反的字符填入；
2. $s_{x_i - 1} \ne s_{x_i + 1}$，此时选择与 $s_{x_i - 1}$ 或 $s_{x_i + 1}$ 相反的字符填入均可；
3. $x_i = 1$ 或 $x_i = n$，此时选择与 $s_{x_i}$ 相邻字符的相反的字符填入即可。

综上，我们发现，对于小R来说，选择与相邻字符相反的字符就是最优答案。
同理，对小M来说，选择与相邻字符相反的字符就是最优答案。

~~*后来蒟蒻因为造出了 $m=n$ 的 hack 数据，导致以为自己操作无序的结论证假，当场 10pts 跑路。*~~
## 赛后
事实上，操作无序的结论是正确的，只是因为蒟蒻没有深入考虑 $m=n$ 的情况。

当 $m=n$ 时，由于小 $c_1$ 不管将 $s_{x_1}$ 修改为什么，都不会影响输出的结果，因此，只需要将 $s_{x_1}$ 任意修改为 `B` 或 `W` 即可。

同时，也有可能出现 `__________B` 的情况，此时，只需要扫描一次后再从后向前再次扫描即可解决。
## 代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 200005;

char g[N];
int n, m;

char inv(char c){
    return c == 'B' ? 'W' : 'B';
}

bool valid(char c){
    return c == 'B' || c == 'W';
}

int main(){
    scanf("%d%d", &n, &m);
    scanf("%s", g + 1);
    while (m -- ) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        g[x] = *op;
        if (m == n - 1) g[x] = 'B';
    }

    for (int i = 2; i <= n; i ++ ){
        if (g[i] == 'B' || g[i] == 'W') continue;
        if (g[i] == 'M' && valid(g[i - 1])) g[i] = g[i - 1];
        else if (g[i] == 'R' && valid(g[i - 1])) g[i] = inv(g[i - 1]);
    }
    
    for (int i = n - 1; i; i -- ){
        if (g[i] == 'B' || g[i] == 'W') continue;
        if (g[i] == 'M' && valid(g[i + 1])) g[i] = g[i + 1];
        else if (g[i] == 'R' && valid(g[i + 1])) g[i] = inv(g[i + 1]);
    }

    int ans = 0;
    for (int i = 1; i <= n; i ++ )
        if (g[i] != g[i - 1]) ans ++ ;

    printf("%d\n", ans);

    return 0;
}
```

---

## 作者：AA12_G (赞：0)

还可以吧，这道题。

## 思路
首先，操作的次序随便。

举个例子，如果两个人玩石头剪刀布，都知道对方出什么，那么谁先出都没有意义了，胜负已定了（假设都不会改）。

-----
我们就把所有的操作另存一个数组里，然后就从 $x_i$ 从小到大执行就行了。

对于每次操作的二元组 $⟨c_i,x_i⟩$ 保证所有的 $x_i$ 严格递增，则我们有如下的：

- 首先既然是 $c_i\in \{R,M\}$ 则每次操作都是有效的。

- 如果是 $c_i=R$ 则小 R 贪心，一定会让这个字符 $k_i$ 与前一个字符不同。

    - 如 $k_{x_i-1}=W$ 则小 R 会把 $k_i$ 设为 $M$。
    
    - 否则如 $k_{x_i-1}=M$ 则小 R 会把 $k_i$ 设为 $W$。

- 若 $c_i=M$ 则小 $M$ 会把这个字符赋值为和上一个字符一样的，即 $k_{x_i}=k_{x_i-1}$。

-----
下面如果前面几个都是 `_` 那么前面几个都不能完成操作。这样我们可以在从后往前一次，这样就也可以完成。或者可以前后前后多来几次防止不必要的错误。

对于特殊性质 B，题目上没规定说非要是 $B$ 或者是 $W$，我们只需要让第一个随便下一个就行。

---

## 作者：虫二bug2 (赞：0)

本题关键在于“序列 $O$ 对双方公开，也就是说双方均知道每一步是由谁在哪个位置放上一枚棋子。”这句话。

可以考虑直接将读入的操作者和位置写入序列，再扫一遍，复杂度为 $O(n)$。

循环分两个方向，以 $p$ 作为节点，$p$ 的位置很重要。对于 $R$，和上一个不同。对于 $M$，和上一个相同。

以下是代码：

```
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,m,cnt=1;
char a[N];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    int p=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]!='_'&&p==0)p=i;
    }
    int r=0;
    for(int i=1;i<=m;i++){
        char c;
        int x;
        cin>>c>>x;
        if(p==0&&x>1)p=x;
        //p不能取1 可以自己造数据手推看原因
        a[x]=c; //将R或M存入序列
    }
    if(p==0){
        p=2;
        a[p]='B';
    }
    for(int i=p-1;i>0;i--){
        if(a[i]=='R'){
            if(a[i+1]=='B')a[i]='W';
            else a[i]='B';
        }
        if(a[i]=='M'){
            a[i]=a[i+1];
        }
        //处理R和M
    }
    for(int i=p+1;i<=n;i++){
        if(a[i]=='R'){
            if(a[i-1]=='B')a[i]='W';
            else a[i]='B';
        }
        if(a[i]=='M'){
            a[i]=a[i-1];
        }
    }
    char t=a[1];
    for(int i=2;i<=n;i++){
        if(a[i]!=t){
            cnt++;
            t=a[i];
        }
    } //查段数
    cout<<cnt;
}
```

---

## 作者：sbno333 (赞：0)

屎上最抽象做法，预告时间复杂度 $O(n\log^2 n)$。

最开始写的是完全不考虑时间，小 R 贪心和相邻的不同，小 M 则相同，发现 WA 了，由于赛时看不到题解，所以不知道咋回事，知道获得一个 hack。

我以为不是巧合，觉得自己做法完全假了，然后就想骗分。

最后其实是正解，思路很简单，就是完全按时间去，考虑我第一个做法的性质，寻找最近的棋子，根据区间内小 R 的数量奇偶性来判断当前棋子放什么，如果是棋盘空，就随便放一个，不影响答案。

二分+树状数组维护最近棋子即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
int s[1000009];
struct st{
	int x;
	bool s;
}q[1000009];
bool cmp(st a1,st a2){
	return a1.x<a2.x;
}
struct stt{
	int f[1000009];
	int lowbit(int x){
		return x&(-x);
	}
	void push(int x){
		while(x<=1000000){
			f[x]++;
			x+=lowbit(x); 
		}
	}
	int q(int x){
		int ans;
		ans=0;
		while(x){
			ans+=f[x];
			x-=lowbit(x); 
		}
		return ans;
	}
	int que(int l,int r){
		return q(r)-q(l-1);
	}
}c;
int ss[1000009];
signed main(){
	int n,m;
	cin>>n>>m;
	s[0]=2;
	s[n+1]=2;
	for(int i=1;i<=n;i++){
		char t;
		cin>>t;
		if(t=='_'){
			s[i]=2;
		}else if(t=='B'){
			s[i]=0;
		}else{
			s[i]=1;
		}
		if(t!='_'){
			c.push(i);
		}
	}
	for(int i=1;i<=m;i++){
		char t;
		cin>>t;
		if(t=='R'){
			q[i].s=1;
		}else{
			q[i].s=0;
		}
		cin>>q[i].x;
		ss[q[i].x]=q[i].s;
	}
	for(int i=1;i<=n;i++){
		ss[i]+=ss[i-1];
	}
	for(int i=1;i<=m;i++){
		if(n==m&&i==1){
			c.push(q[i].x);
			s[q[i].x]=0;
		}else{
			int l,r;
			l=1,r=n;
			while(l<r){
				int mid;
				mid=l+r;
				mid>>=1;
				int s1,s2;
				s1=q[i].x-mid;
				s2=q[i].x+mid;
				s1=max(s1,1ll);
				s2=min(s2,n);
				if(c.que(s1,s2)){
					r=mid;
				}else{
					l=mid+1;
				}
			}
			int s1,s2;
				s1=q[i].x-l;
				s2=q[i].x+l;
				s1=max(s1,1ll);
				s2=min(s2,n);
				if(c.que(s1,q[i].x)){
					if((ss[q[i].x]-ss[s1])&1){
						s[q[i].x]=1-s[s1];
					}else{
						s[q[i].x]=s[s1];
					}
				}else{
					
					if((ss[s2-1]-ss[q[i].x-1])&1){
						s[q[i].x]=1-s[s2];
					}else{
						s[q[i].x]=s[s2];
					}
				}
				c.push(q[i].x);
		}
	}
	int ans;
	ans=0;
	for(int i=1;i<=n;i++){
		if(s[i]!=s[i-1]){
			ans++;
		}
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：postpone (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P10608)

提供一种 bfs + 贪心的思路。

由题意，我们知道小 R 和小 M 下棋的策略是不同的：小 R 想要连续的段数量越多越好，小 M 则相反。不难想出，他们对任意一个位置的策略是与相邻的两格（或一格）相关的。

再注意到：**因为游戏过程中小 R 和小 M 只能在序列指定的位置下棋，且两人从一开始就都能看到完整的序列，所以他们的策略和下棋前后顺序没有关系。**

到这里，解法就呼之欲出了。

先记录棋盘的信息和两人下棋的操作序列，同时用一个数组 `d[]` 记录某个位置将会被谁下，比如 `d[i]='R'` 意为小R将会在位置 $i$ 下棋。

然后从棋盘上非空的格子开始往两边扩展，如果与它相邻的格子是空的，那么就根据在这个地方下棋的人的策略来选择不同的颜色。用 bfs 即可遍历所有的格子。

最后，记录连续连续同色段的个数然后输出。

代码如下（其中，`seq[]` 为棋盘状态，`d[]` 作用即为上述所示）：

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2e5 + 5;

char seq[N], d[N];
struct Modify
{
    char who;
    int pos;
} q[N];

int n, m;
ll res = 1;

void solve()
{
    queue<int> qu;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> seq[i];
        if (seq[i] != '_')
            qu.push(i);
    }
    for (int i = 1; i <= m; i++)
    {
        cin >> q[i].who >> q[i].pos;
        d[q[i].pos] = q[i].who;
    }
    if (qu.empty())
    {
        seq[q[1].pos] = 'W';
        qu.push(q[1].pos);
    }
    while (!qu.empty())
    {
        int x = qu.front();
        qu.pop();
        if (x - 1 >= 1 && x - 1 <= n && seq[x - 1] == '_')
        {
            if (d[x - 1] == 'R')
                seq[x - 1] = (seq[x] == 'W') ? 'B' : 'W';
            else
                seq[x - 1] = seq[x];
            qu.push(x - 1);
        }
        if (x + 1 >= 1 && x + 1 <= n && seq[x + 1] == '_')
        {
            if (d[x + 1] == 'R')
                seq[x + 1] = (seq[x] == 'W') ? 'B' : 'W';
            else
                seq[x + 1] = seq[x];
            qu.push(x + 1);
        }
    }
    for (int i = 2; i <= n; i++)
    {
        if (seq[i] == seq[i - 1])
            continue;
        res++;
    }
    cout << res;
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```

---


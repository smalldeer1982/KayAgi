# 配对序列

## 题目描述

一个序列 $s_1,\ldots s_{2k}$ 是**配对的**，当且仅当：

- 对于任意 $1\le i \le k$，$s_{2i}=s_{2i-1}$。
- 对于任意 $1\le i<k$，$s_{2i}\ne s_{2i+1}$。

注意，配对的序列长度必然为偶数。

例如，$3,3,5,5,2,2$ 是配对的，而 $2,2,2,2,5,5$（$s_2=s_3$ 不满足第二条要求）或者 $1,2,3,3,1,1$（$s_1\ne s_2$ 不满足第一条要求）都不是配对的。

给出一个数列 $a_1,\ldots, a_n$，求所有配对的子序列长度的最大值。

## 说明/提示

【样例 1 解释】

取 $1,1,2,2$ 这个子序列即可。

【样例 2 解释】

取 $1,1,2,2,5,5$ 这个配对子序列即可。

【样例 3 解释】

该样例符合测试点 $3$ 的限制。

【样例 4 解释】

该样例符合测试点 $12$ 的限制。

【数据范围】

对于全体数据，保证 $2\le n\le 5\times 10^5$，$1\le a_i\le 5\times 10^5$。

|测试点编号|$n\le$|$a_i\le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1\sim 2$|$18$|$5\times 10^5$||
|$3\sim 5$|$500$|$500$||
|$6\sim 7$|$5000$|$5000$||
|$8\sim 9$|$5000$|$5\times 10^5$||
|$10$|$5\times 10^5$|$5\times 10^5$|每个数最多出现 $1$ 次|
|$11$|$5\times 10^5$|$5\times 10^5$|$a_i\le a_{i+1}$ 恒成立|
|$12\sim 14$|$5\times 10^5$|$5\times 10^5$|每个数最多出现 $2$ 次|
|$15\sim 20$|$5\times 10^5$|$5\times 10^5$||

## 样例 #1

### 输入

```
8
1 2 2 2 2 1 2 2
```

### 输出

```
4
```

## 样例 #2

### 输入

```
11
1 1 4 1 1 2 1000 2 5 5 4
```

### 输出

```
6
```

## 样例 #3

### 输入

```
参见 pairing3.in```

### 输出

```
参见 pairing3.out```

## 样例 #4

### 输入

```
参见 pairing4.in```

### 输出

```
参见 pairing4.out```

# 题解

## 作者：yummy (赞：45)

# D. 配对序列 (pairing) 官方题解

本题考查的主要知识点有：

- 【4】简单一维动态规划

### 送分

读题后不难发现测试点 $10$ 的输出为 $0$。

对于测试点 $ 11$，一个数可以出现在答案中当且仅当该数字出现了 $2$ 次。所以统计出现至少两次的数字种数再乘以 $2$ 即可。

前 $ 2$ 个测试点可以直接枚举子序列，然后判断是否符合题意，时间复杂度 $O(n2^n)$。

如果考场上没有任何思路，那么这 $20$ 分可以尝试拿到手。

### 朴素的 DP

题目也是让你求某种子序列的个数，类似求最长上升子序列，我们考虑 DP。

令 $f(i)$ 为以 $i$ 结尾的最长配对子序列的长度，则每次转移要枚举 $i$ 的上一个数的位置 $j$ 和上上个数的位置 $k$，如果 $a_i=a_j$ 且 $a_j\ne a_k$，那么 $f_i$ 可以变成 $\max(f_i, f_k+2)$。该方法时间复杂度为 $O(n^3)$，可以通过测试点 $1\sim 5$ 拿到 $25$ 分，如果结合送分，可得 $35$ 分。

---

我们发现时间复杂度瓶颈在于每次转移需要枚举两个数。如果我们能把长度为奇数的子序列也写进某种 DP 里，那么每次转移只要枚举上一个数的位置。

令 $even(i)$ 表示以 $i$ 结尾的最长配对子序列长度，$odd(i)$ 表示以 $i$ 结尾，除了长度是奇数以外都满足配对子序列的要求的、最长子序列长度。

转移 $even(i)$ 时，枚举所有 $j<i$，如果 $a_j=a_i$，那么用 $odd(j)+1$ 去更新 $even(i)$。

转移 $odd(i)$ 时，枚举所有 $j<i$，如果 $a_j\ne a_i$，那么用 $even(j)+1$ 去更新 $odd(i)$。

时间复杂度 $O(n^2)$，可得 $45$ 分，结合送分可得 $55$ 分。

### 更优秀的 DP

经过观察，发现如果 $a_i=a_j$，且 $i<j$，那么 $j$ 处的 DP 值一定大于 $i$ 处的 DP 值（因为 $j$ 的转移范围大于 $i$ 的转移范围）。因此转移 $even(i)$ 时，我们只需要找到 $i$ 之前**最近的**和 $a_i$ 相等的 $a_j$ 进行转移。实现上，在 $i$ 从前往后扫描的过程中，用 $pre_v$ 来记录 $a$ 中上一次出现数 $v$ 的位置即可。

对于 $odd(i)$，如果是测试点 $12\sim 14$，那么只需要在 $i$ 从前往后循环的同时记录下 $even(i)$ 的最大值即可——毕竟因为所有数最多出现 $2$ 次，如果 $a_ i$ 是第一次出现，那么 $i$ 之前的 $j$ 都有 $a_j\ne a_i$；而如果 $a_i$ 是第二次出现，这个 $odd(i)$ 就不可能再被某种 $even(j)$ 调用，正确性也就不重要了。

然而对于所有测试点，只记录 $even(i)$ 最大值（记为 $ even(J)$）是不够的——如果 $a_i=a_J$，那么这时就要转而求“次大值”。总而言之，我们需要在 $i$ 从前往后循环的同时，记录 $a_J$ **不同的** $even(J)$ 前二大。

这样，总时间复杂度就是 $O(n+\max a_i)$ 的了，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005;
int n,a[N],even[N],odd[N],pre[N];
int main(){
	scanf("%d",&n);
	int b1=0,b2=0;
	odd[0]=-1e9;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[b1]==a[i])
			odd[i]=even[b2]+1;
		else odd[i]=even[b1]+1;
		even[i]=odd[pre[a[i]]]+1;
		if(even[i]>=even[b1]){
			if(a[i]!=a[b1])
				b2=b1;
			b1=i;
		}
		else if(even[i]>=even[b2] && a[i]!=a[b1])
			b2=i;
		pre[a[i]]=i;
	}
	printf("%d\n",even[b1]);
	return 0;
}
```

---

## 作者：System32 (赞：10)

考虑 $dp[i][0]$ 表示对于第 $i$ 数，匹配已经完成且当前没有进行任何操作，可以取得的最大长度；$dp[i][1]$ 表示对于第 $i$ 数，作为配对的第一个数，可以取得的最大长度；$dp[i][2]$ 表示对于第 $i$ 数，作为配对的第二个数，可以取得的最大长度。

然后就可以得出一个显而易见的结论：

$$dp[i][0]=\max(dp[i-1][0],dp[i-1][2])$$
$$dp[i][1]=\max_{j=1}^{i-1}{[a[j]=a[i]]dp[j][1]+1}$$

对于 $dp[i][2]$，寻找在它前面的最后一个 $a[j]=a[i]$，从 $dp[j][1]$ 直接转移。

但是很明显，这样的算法复杂度是 $O(n^2)$，无法通过此题。

对于 $dp[i][1]$ 的转移，我们可以记录第一大的状态和第二大的状态，当第一大的状态不能转移时，就可以选择第二大的状态进行转移。

最后复杂度是 $O(n)$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[500010], dp[500010][3];

unordered_map<int, int> f;
int mx1, my1, mx2, my2;

int main() {
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	dp[0][1] = -1e9;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		dp[i][0] = max(dp[i - 1][0], dp[i - 1][2]);
		dp[i][2] = max(dp[i][2], dp[f[a[i]]][1] + 1);
		if (mx1 == a[i]) {
			dp[i][1] = dp[my2][2] + 1;
		} else {
			dp[i][1] = dp[my1][2] + 1;
		}
		if (mx1 == a[i]) {
			if (dp[my1][2] < dp[i][2]) {
				my1 = i;
			}
		} else if (mx2 == a[i]) {
			if (dp[my2][2] < dp[i][2]) {
				my2 = i;
			}
			if (dp[my2][2] > dp[my1][2]) {
				swap(my1, my2);
				swap(mx1, mx2);
			}
		} else {
			if (dp[i][2] > dp[my1][2]) {
				mx2 = mx1;
				my2 = my1;
				mx1 = a[i];
				my1 = i;
			} else if (dp[i][2] > dp[my2][2]) {
				mx2 = a[i];
				my2 = i;
			}
		}
		f[a[i]] = i;
	}
	cout << max(dp[n][0], dp[n][2]) << endl;
}
```

---

## 作者：vorDeal (赞：8)

把答案序列中相邻而相等的两个数，我们称之为“块”。那么可以发现，对于以某块为结尾的一个答案序列，其一定是由一个 **结尾不为该块的序列** 转移而来。因而，本题具有最优子结构性质，可以使用动态规划求解。

考虑到第偶数个数需要从上一个相同的数转移而来，预处理一个数组，存储上一个与之相同的数的下标。然后借鉴 [P8817 [CSP-S 2022] 假期计划](https://www.luogu.com.cn/problem/P8817) 的思路，用一个 vector 来维护最大、次大值，来应对相邻块之间值相等的情况。

时间复杂度 $O(n)$，可以通过本题。

**AC Code：**
```cpp
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;

const int maxn = 5e5 + 5;
int n, a[maxn], ans;
int f[maxn], g[maxn], pos[maxn], lst[maxn];
vector<pii> h;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        lst[i] = pos[a[i]], pos[a[i]] = i;
    f[0] = -maxn, h.push_back(pii(0, 0));
    for (int i = 1; i <= n; i++)
    {
        if (h[0].first == a[i])
            f[i] = h[1].second + 1;
        else
            f[i] = h[0].second + 1;
        g[i] = f[lst[i]] + 1;
        bool flag = true;
        for (auto &x : h)
            if (x.first == a[i])
                x.second = max(x.second, g[i]), flag = false;
        if (flag)
            h.push_back(pii(a[i], g[i]));
        sort(h.begin(), h.end(), [](pii a, pii b)
             { return a.second > b.second; });
        if (flag && i != 1)
            h.pop_back();
    }
    for (int i = 1; i <= n; i++)
        ans = max(ans, g[i]);
    cout << ans;
    return 0;
}
```

祝各位 CSP-J/S 2024 RP++，所愿皆所得！

---

## 作者：Farewell_Bood (赞：8)

### 前置废话：

虽然我没有去打当时的比赛，但是后来我做的时候，就这个题会，甚至第一题和第二题不会，第四题竟然会。做出来之后，我的大脑直接宕机了。

### 正题：

对于这道题，我们不难发现是一道 DP 题。在此题中，当 $a_i < a_j$ 且 $i < j$ 时。$j$ 处的 DP 值一定大于 $i$ 处的 DP 值。所以在转移的时候，我们需要找到 $i$ 之前最近的和 $a_i$ 相等的 $a_j$ 进行转移，我们在遍历的过程中，有一个数组记录一下上一次出现的数的位置就可以了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000001],dp[1000001],b[1000001],c[1000001],one,two;
int main(){
	cin>>n;
	b[0]=-0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[one]==a[i]) b[i]=dp[two]+1;
		else b[i]=dp[one]+1;
		dp[i]=b[c[a[i]]]+1;
		if(dp[i]>=dp[one]){
			if(a[i]!=a[one]) two=one;
			one=i;
		}
		else if(dp[i]>dp[two]&&a[i]!=a[one]) two=i;
		c[a[i]]=i;
	}
	cout<<dp[one]<<endl;
	return 0;
}
```
这道题就这么水灵灵的过啦！

---

## 作者：BenRheinz (赞：7)

### 简要题意
奇数位置的数与它的上一个数必须不同，偶数位置的数与它的上一个数必须相同，这样的总项数为偶数的序列被称为是“配对的”。

求最长“配对”的子序列长。
### 状态设计
令 $f_{i,0/1}$ 表示以 $a_i$ 结尾的偶/奇项的最长“配对”子序列长，答案就是所有 $f_{i,0}$ 的最大值。

注：奇数项的“配对”序列是不合题意的，这里定义为合法“配对”序列后添上任意一个数。
### DP 转移
对于 $j\in[1,i)$，如果 $a_i=a_j$，那 $a_i$ 就可以拼在以 $a_j$ 结尾的奇数项“配对”序列后。否则，$a_i$ 就可以拼在以 $a_j$ 结尾的偶数项“配对”序列后。即：
$$f_{i,1}=\max_{a_j=a_i}f_{j,0}+1\\
  f_{i,0}=\max_{a_j\neq a_i}f_{i,1}+1$$
边界条件：$f_{0,0}=0,f_{0,1}=-\infty$

这样我们就写出 $O(n^2)$ 的算法了。

接下来我们发现值域比较小，可以直接用线段树维护区间最值将上面的转移优化到 $O(n\log n)$，可以通过这道题。

### 优化方法
$f_{i,1}$ 从与 $a_i$ 相等的 $f_{j,0}$ 项转移而来，不妨记 $w_i$ 为所有 $a_j=i$ 的 $f_{i,0}$ 的最大值，这样 $f_{i,1}$ 的转移可以做到 $O(1)$。

$f_{i,0}$ 从所有与 $a_i$ 不等的 $f_{j,1}$ 项转移而来，我们用线段树维护所有可能的 $f_{j,1}$ 的最大值，然后查询 $a_j\in[1,a_i) \cup (a_i,500000]$ 的 $f_{j,1}$ 的最大值，这样 $f_{i,0}$ 的转移就做到了 $O(\log n)$。

总复杂度就做到了 $O(n\log n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct FSI{//这是快读，相当于cin
	template<typename T>
	FSI& operator >> (T&res){
		res=0;T f=1;char ch=getchar();
		while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
		while(isdigit(ch)){res=(res*10)+(ch-48);ch=getchar();}
		res*=f;
		return *this;
	}
} scan;
const int N=5e5+5,inf=-1e9;
int a[N],f[N][2];
int w[N];
struct node{
	int l,r,val;
} tr[N<<2];
void build(int u,int l,int r){
	tr[u]={l,r,0};
	if(l==r) return;
	int mid=(l+r)>>1;
	build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}
int query(int u,int l,int r){//区间查询最大值 
	if(r<tr[u].l||tr[u].r<l) return inf;
	if(l<=tr[u].l&&tr[u].r<=r) return tr[u].val;
	int mid=(tr[u].l+tr[u].r)>>1;
	int res=inf;
	if(l<=mid) res=max(res,query(u<<1,l,r));
	if(r>mid) res=max(res,query(u<<1|1,l,r));
	return res;
}
void modify(int u,int pos,int val){//单点修改 
	if(tr[u].l==tr[u].r&&tr[u].l==pos){
		tr[u].val=val;
		return;
	}
	int mid=(tr[u].l+tr[u].r)>>1;
	if(pos<=mid) modify(u<<1,pos,val);
	if(pos>mid) modify(u<<1|1,pos,val);
	tr[u].val=max(tr[u<<1].val,tr[u<<1|1].val);
}
int main(){
	build(1,1,500000);//按值域建立线段树 
	int n;
	scan>>n;
	for(int i=1;i<=n;i++) scan>>a[i];
//	f[0][0]=0,f[0][1]=-1e9;
	memset(w,0xcf,sizeof(w));//注意这里的边界条件 
	for(int i=1;i<=n;i++){
		f[i][0]=max(f[i][0],w[a[i]]+1); 
		f[i][1]=max(f[i][1],max(query(1,1,a[i]-1),query(1,a[i]+1,500000))+1);
		w[a[i]]=max(w[a[i]],f[i][1]);
		modify(1,a[i],f[i][0]);
	}
	int res=0;
	for(int i=1;i<=n;i++){
		res=max(res,f[i][0]);
	}
	printf("%d",res);
	return 0;
}
```

---

## 作者：liangbob (赞：5)

## P11187 配对序列

小学生都会做的小清新递推题。

我们不妨定义：

- 一个“完整配对子序列”为题目所述的配对子序列
- 一个“不完整配对子序列”为题目所述配对子序列去掉末尾的数

可以发现：

- 一个“完整配对子序列”加上一个不等于其末尾的数就是一个“不完整配对子序列”。

- 一个“不完整配对子序列”加上一个等于其末尾的数就是一个“完整配对子序列”。

考虑维护在 $1$ 到 $i$ 中以 $x$ 为结尾的最长“完整配对子序列”和“不完整配对子序列”的长度。

- 对于“完整配对子序列”，直接用 $1 \sim {i-1}$ 中的以 $x$ 为结尾的“不完整配对子序列”的长度加一更新即可。
- 对于“不完整配对子序列”，需要求出 $1 \sim {i-1}$ 中结尾不等于 $x$ 的“完整配对子序列”的长度的最大值。考虑将所有的“完整配对子序列”的长度的最大值插入一个数据结构，把结尾等于 $x$ 的最大值删除，最后求最大值即可。

因此我们需要一个可以快速动态插入、删除、求最大值的数据结构，使用 multiset 即可。注意 multiset 要删除单个某个数不能直接删除，得先 find 到这个数，再删除 find 出来的迭代器。

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <set>
#define int long long
#define endl '\n'
#define IL inline
using namespace std;
const int N = 5e5 + 10;
const int INF = 0x3f3f3f3f;

IL int read()
{
	int x = 0,f = 1;
	char c = getchar();
	while(c <'0'|| c >'9'){if(c == '-') f = -1;c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = getchar();
	return x * f;
}

void write(int x)
{
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

int n, a[N];
int ans, com[N], inc[N];

multiset <int> st;

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 1;i <= n;i++)
	{
		//维护完整子序列
		if(inc[a[i]])
		{
			if(st.find(com[a[i]]) != st.end()) st.erase(st.find(com[a[i]]));
			com[a[i]] = max(com[a[i]], inc[a[i]] + 1);
			st.insert(com[a[i]]);
		}
		//维护不完整子序列
		if(st.find(com[a[i]]) != st.end()) st.erase(st.find(com[a[i]]));
		if(st.size()) inc[a[i]] = max(inc[a[i]], (*st.rbegin()) + 1ll);
		else inc[a[i]] = max(inc[a[i]], 1ll);
		st.insert(com[a[i]]);
		ans = max(ans, *st.rbegin());
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Lyria (赞：3)

题意显然，从序列中挑选一个子序列，要求 $k$ 个长度为 $2$ 的组，组内需要是同一数字，相邻两组之间数字不能相同即为合法。

考虑经典 dp，设 $f_{i,0}$ 表示**以 $a_i$ 结尾**且长度为奇数的子序列最长长度，$f_{i,1}$ 则表示长度为偶数子序列最长长度。

所以转移方程应该不难得出：

$$f_{i,0}=\max_{x\in [1,5\times 10^5]}{f_{x,1}+1}$$

$$f_{i,1}=\max f_{i,0}$$

你会发现这是求值域 max，值域很小可以直接上线段树。注意更新先后顺序需要消除影响，由于此处我统计的是组数，所以长度需要再乘二。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 500005
using namespace std;
int n,m,a[N],f[N][2];
struct node{
    int l,r,maxi;
}tr[N<<2][2];
void pushup(int u,int id){
    tr[u][id].maxi=max(tr[u<<1][id].maxi,tr[u<<1|1][id].maxi);
}
void build(int u,int l,int r){
    tr[u][0]=tr[u][1]={l,r};
    if(l==r) return ;
    int mid=l+r>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    pushup(u,0),pushup(u,1);
}
void modify(int u,int l,int r,int id,int d){
    if(tr[u][id].l>=l&&tr[u][id].r<=r){
        tr[u][id].maxi=max(tr[u][id].maxi,d);
        return ;
    }
    int mid=tr[u][id].l+tr[u][id].r>>1;
    if(l<=mid) modify(u<<1,l,r,id,d);
    if(r>mid) modify(u<<1|1,l,r,id,d);
    pushup(u,id);
}
void modify2(int u,int l,int r,int id,int d){
    if(tr[u][id].l>=l&&tr[u][id].r<=r){
        tr[u][id].maxi=d;
        return ;
    }
    int mid=tr[u][id].l+tr[u][id].r>>1;
    if(l<=mid) modify2(u<<1,l,r,id,d);
    if(r>mid) modify2(u<<1|1,l,r,id,d);
    pushup(u,id);
}
int query(int u,int l,int r,int id){
    if(tr[u][id].l>=l&&tr[u][id].r<=r) return tr[u][id].maxi;
    int res=0,mid=tr[u][id].l+tr[u][id].r>>1;
    if(l<=mid) res=query(u<<1,l,r,id);
    if(r>mid) res=max(res,query(u<<1|1,l,r,id));
    return res;
}
signed main(){
    // freopen("pairing4.in","r",stdin);
    cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,(int)5e5);
    for(int i=1;i<=n;i++){
        f[i][1]=query(1,a[i],a[i],0);
        modify(1,a[i],a[i],1,f[i][1]);
        int tmp=query(1,a[i],a[i],1);
        modify2(1,a[i],a[i],1,0);
        f[i][0]=query(1,1,(int)5e5,1)+1;
        modify(1,a[i],a[i],1,tmp),modify(1,a[i],a[i],0,f[i][0]);
    }
    int res=0;
    for(int i=1;i<=n;i++) res=max(res,f[i][1]);
    cout<<res*2;
}
```

---

## 作者：Double_Light (赞：3)

不会入门组解法，但是会线段树。

设 $f_{j,i,1}$ 表示前 $j$ 个数中结尾为 $i$ 的最长的配对子序列长度，$f_{j,i,0}$ 表示前 $j$ 个数中如果加上一个 $i$ 就可以成为以 $i$ 结尾的最长的子序列长度。

发现 $j$ 这一维可以滚动优化掉，而且每次序列新加入一个数只可以更新 $f_{a_i,0}$ 和 $f_{a_i,1}$ 两个数，假设目前新增加了 $a_i$，可以列得状态转移方程

$$f_{a_i,1}=\max(f_{a_i,1},f_{a_i,0}+1)$$

$$f_{a_i,0}=\max(\max_{j≠a_i}(f_{j,1}+1),f_{a_i,0})$$

第一个式子可以 $O(1)$，第二个式子复杂度 $O(V)$，$V$ 是值域。于是用线段树维护最大的 $f_{j,1}$，复杂度变成 $O(\log V)$，可以完成本题。

代码：


```cpp
#include<iostream>
#include<cstring>
#define int long long
#define N 500005 
#define mid ((l+r)/2)
using namespace std;
int n;
int a[N];
int dp[N][2];
int len[N];
int tot[N];
int tr[4*N];
void pushup(int x){
	tr[x]=max(tr[2*x],tr[2*x+1]);
}
void update(int x,int l,int r,int k,int v){
	if(l==r&&l==k){
		tr[x]=v;
		return ;
	}
	if(k<=mid)update(2*x,l,mid,k,v);
	if(k>mid)update(2*x+1,mid+1,r,k,v);
	pushup(x);
}
int query(int x,int l,int r,int from,int to){
	if(from>to)return 0;
	if(from<=l&&r<=to)return tr[x];
	int ans=0;
	if(from<=mid)ans=max(ans,query(2*x,l,mid,from,to));
	if(to>mid)ans=max(ans,query(2*x+1,mid+1,r,from,to));
	return ans;
}
signed main(){
	//freopen("pairing4.in","r",stdin);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	memset(dp,-0x3f,sizeof(dp));
	for(int i=1;i<=n;i++){
		dp[a[i]][1]=max(dp[a[i]][1],dp[a[i]][0]+1); 
		dp[a[i]][0]=max(dp[a[i]][0],max(query(1,1,N,1,a[i]-1),query(1,1,N,a[i]+1,N))+1);
		update(1,1,N,a[i],dp[a[i]][1]);
		//for(int j=1;j<=5;j++)cout<<query(1,1,N,j,j)<<' ';cout<<endl;
	}
	cout<<query(1,1,N,1,N)<<endl;
	return 0;
}
```

---

## 作者：Oracynx (赞：3)

## P11187 配对序列 题解

### 思路分析

显然，如果前面有一个 $x, x$，后面对于所有 $y \not = x$，$y, y$ 都可以接在 $x, x$ 后面。

考虑记录一个 $aft$ 数组，$aft_i$ 表示 $a_i$ 后面第一个与 $a_i$ 相同的元素的位置。

我们可以使用线段树维护对于每一个数可以接在前面其他数的所有方案的最大的长度。

同时，对于每一个位置 $i$，我们可以忽略 $i + 1 \sim aft_i - 1$ 中间的元素，来组成一对相邻的相同元素。

设 $x = a_i$，对于忽略掉中间元素后的 $x, x$，更新答案则是修改 $1 \sim x -1, x + 1 \sim m$ 为此处的最大长度。

**特别的：此处的修改表示对于一个区间，对里面的所有元素，小于目标值的改为目标值，否则不变。**

但是，此处的答案必须在 $i > aft_i$ 才能生效。

所以说我们记录一下这个操作，在到达 $aft_i + 1$ 时在修改即可。

更多细节详见代码。

### 代码实现

**其中，`Unknown` 可以是任意一个不会在计算中中出现的值。**

```cpp
#include <algorithm>
#include <cstdio>
#include <tuple>
#include <vector>
constexpr int MaxN = 5e5 + 5;
constexpr int Unknown = 975432499;
int n, m;
int p[MaxN];
int aft[MaxN];
int last[MaxN];
int tree[MaxN * 4];
int lazy[MaxN * 4];
std::vector<std::tuple<int, int, int, int, int, int>> v[MaxN];
void build(int c, int s, int t)
{
    lazy[c] = Unknown;
    if (s == t)
    {
        return;
    }
    int mid = (s + t) / 2;
    build(c * 2, s, mid);
    build(c * 2 + 1, mid + 1, t);
}
void downstream(int c)
{
    if (lazy[c] != Unknown)
    {
        tree[c * 2] = std::max(tree[c * 2], lazy[c]);
        tree[c * 2 + 1] = std::max(tree[c * 2 + 1], lazy[c]);
        lazy[c * 2] = std::max(lazy[c * 2] == Unknown ? 0 : lazy[c * 2], lazy[c]);
        lazy[c * 2 + 1] = std::max(lazy[c * 2 + 1] == Unknown ? 0 : lazy[c * 2 + 1], lazy[c]);
        lazy[c] = Unknown;
    }
}
void change(int c, int s, int t, int l, int r, int val)
{
    if (l > r)
    {
        return;
    }
    if (l <= s && t <= r)
    {
        tree[c] = std::max(tree[c], val);
        lazy[c] = std::max(lazy[c] == Unknown ? 0 : lazy[c], val);
        return;
    }
    downstream(c);
    int mid = (s + t) / 2;
    if (l <= mid)
    {
        change(c * 2, s, mid, l, r, val);
    }
    if (r > mid)
    {
        change(c * 2 + 1, mid + 1, t, l, r, val);
    }
    tree[c] = std::max(tree[c * 2], tree[c * 2 + 1]);
}
int query(int c, int s, int t, int l, int r)
{
    if (l > r)
    {
        return -1;
    }
    if (l <= s && t <= r)
    {
        return tree[c];
    }
    downstream(c);
    int res = 0;
    int mid = (s + t) / 2;
    if (l <= mid)
    {
        res = std::max(res, query(c * 2, s, mid, l, r));
    }
    if (r > mid)
    {
        res = std::max(res, query(c * 2 + 1, mid + 1, t, l, r));
    }
    return res;
}
inline void change(int c, int s, int t, int l, int r, int val, int cur)
{
    v[cur].push_back({c, s, t, l, r, val});
}
inline void check(int u)
{
    for (auto k : v[u])
    {
        auto [c, s, t, l, r, val] = k;
        change(c, s, t, l, r, val);
    }
    v[u].clear();
}
int main()
{
    scanf("%d", &n);
    m = 5e5;
    build(1, 1, m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &p[i]);
        aft[last[p[i]]] = i;
        last[p[i]] = i;
    }
    int answer = 0;
    for (int i = 1; i <= n; i++)
    {
        check(i);
        if (aft[i] != 0)
        {
            int temp = query(1, 1, m, p[i], p[i]) + 1;
            answer = std::max(answer, temp);
            change(1, 1, m, 1, p[i] - 1, temp, aft[i] + 1);
            change(1, 1, m, p[i] + 1, m, temp, aft[i] + 1);
        }
    }
    printf("%d\n", answer * 2);
    return 0;
}
```

---

## 作者：2huk (赞：3)

这是一篇树状数组优化 DP 的题解。

有显然 DP：设 $f(i, 0/1)$ 表示只考虑前 $i$ 个数，且第 $i$ 个数一定被划分到了子序列中，且 $i$ 是在这个子序列的奇数还是偶数位置的方案数。

转移可以枚举子序列中倒数第二个元素的位置：

$$
f(i, 0) = 1 + \sum_{j=1}^{i-1} [a_j = a_i] f(j, 1) \\
f(i, 1) = 1 + \sum_{j=1}^{i-1} [a_j \ne a_i] f(j, 0)
$$

直接做是 $\mathcal O(n^2)$ 的。

考虑优化转移。若我们动态维护 $w_{0, k} = \sum_{j=1}^{i-1} [a_i=k] f(i, 0),w_{1, k} = \sum_{j=1}^{i-1} [a_i=k] f(i, 1)$，那么转移可以优化成：

$$
f(i, 0) = 1 + w_{1, a_i} \\
f(i, 1) = 1 + \max_{j \ne a_i} w_{0, j}
$$

$f(i, 0)$ 的转移就可以做到 $\mathcal O(1)$ 了。但是 $f(i, 1)$ 的转移不能。

像这种在全集中只删除一个数的转移可以考虑维护其前后缀。即我们令 $pre_j = \max_{k=1}^j w_{0, j},suf_j = \max_{k=j}^{V} w_{0, j}$（其中 $V$ 是值域，取 $V = 5 \times 10^5$）。那么：

$$
f(i, 1) = 1 + \max(pre_{a_i-1}, suf_{a_i+1})
$$

这样也能做到 $\mathcal O(1)$ 转移了。

现在的问题是如何快速维护 $w_{0,i},w_{1,i},pre_i,suf_i$。前二者是极易的，而后者只是前者的前缀/后缀最大值，树状数组维护即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5e5 + 10;

int n, a[N], f[N][2];

struct BIT {
	int tr[N];
	
	void modify(int u, int x) {
		for (int i = u; i <= 5e5; i += i & -i) tr[i] = max(tr[i], x);
	}
	
	int query(int u) {
		int res = 0;
		for (int i = u; i; i -= i & -i) res = max(res, tr[i]);
		return res;
	}
}T1, T2;

int mx[N];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++ i ) cin >> a[i];
	for (int i = 1; i <= n; ++ i ) {
		f[i][0] = mx[a[i]] ? mx[a[i]] + 1 : 0;
		f[i][1] = max(T1.query(a[i] - 1), T2.query(5e5 - a[i])) + 1;
		
		mx[a[i]] = max(mx[a[i]], f[i][1]);
		T1.modify(a[i], f[i][0]);
		T2.modify(5e5 - a[i] + 1, f[i][0]);
	}
	int res = 0;
	for (int i = 1; i <= n; ++ i ) res = max(res, f[i][0]);
	cout << res;
	return 0;
}
```

---

## 作者：lovelish (赞：2)

题意相当于是选取一个子序列，其为若干数对连到一起，每个数对的两个数相同，且连续的数对的数不相同。

显然是一个动态规划。

显然，对于一个 $a_i$，其要想选择前面的一个相同的数值 $a_j$ 组成一个数对，$j$ 越大越好。那么我们可以使用一个数组来存储上一个数字 $a_i$ 的位置即可。

那么枚举每一个数，对于每一个数 $a_i$，我们找到上一个相同数的位置 $j$，然后 $\min (f_{j-1}+1,f_{i-1})$ 即为 $f_i$。

但是题目要求连续的数对的数不相同，于是我们还需要把以上的状态复制一遍，存储一个最大值和次大值，维护最大值和次大值时还需保证其不是通过相同数值的 $a_i$ 转移的。那么转移的时候如果发现最大值的是通过与 $a_i$ 相同的数值转移的，那么就不能通过最大值转移，使用次大值转移即可。

代码如下：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
int a[500010];
int x[500010];
int max1[500010],max2[500010],max1a[500010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		max1[i]=max1[i-1];max2[i]=max2[i-1];max1a[i]=max1a[i-1];
		if(x[a[i]])
		{
			int ans;
			if(max1a[x[a[i]]-1]!=a[i])ans=max1[x[a[i]]-1]+1;
			else ans=max2[x[a[i]]-1]+1;
			if(ans>max1[i])
			{
				if(a[i]!=max1a[i])max2[i]=max1[i];
				max1[i]=ans;
				max1a[i]=a[i];
			}
			else if(ans==max1[i]&&a[i]!=max1a[i])max2[i]=ans;
		}
		x[a[i]]=i;
	}
	cout<<max1[n]*2;
	return 0;
}
```

---

## 作者：Linge_Zzzz (赞：1)

# 前言

我是大力 DS 重度患者。

# Sol

考虑 DP。

设 $f_{i,j}$ 表示前 $i$ 个数，结尾的值为 $j$ 的最长配对序列长度，$g_{i,j}$ 表示前 $i$ 个数，结尾的值为 $j$，但是还需要在结尾再加上一个 $j$ 才能形成配对序列的最长配对序列长度。

转移显然：

$$
\begin{aligned}
f_{i,j}&=\max_{k}\{g_{i-1,k}+1\}\\
g_{i,j}&=\max_{k\neq j}\{f_{i-1,k}+1\}
\end{aligned}
$$

注意到每个状态只与上一行的状态有关，所以使用滚动数组优化。

有区间查询 $\max$，启示我们使用 RMQ 结构（如线段树）优化 DP。

所以建立两棵线段树，第一个表示 $f_i$，第二个表示 $g_i$，直接模拟上述转移即可。

时间复杂度 $O(n\log V)$。

坑点是要先查询再统一修改，否则会互相影响。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int,int> pii;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
const int N=5e5+10,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
int n,a[N];
struct Seg{
	int t[N*4];
	void pushup(int p){t[p]=max(t[p*2],t[p*2+1]);}
	void update(int p,int l,int r,int pos,int val){
		if(l==r){
			t[p]=max(t[p],val);
			return;
		}
		int m=(l+r)>>1;
		if(pos<=m)update(p*2,l,m,pos,val);
		else update(p*2+1,m+1,r,pos,val);
		pushup(p);
	}
	int query(int p,int l,int r,int L,int R){
		if(L>R)return -INF;
		if(L<=l&&r<=R)return t[p];
		int m=(l+r)>>1,ans=-INF;
		if(L<=m)ans=max(ans,query(p*2,l,m,L,R));
		if(R>m)ans=max(ans,query(p*2+1,m+1,r,L,R));
		return ans;
	}
}t0,t1;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	memset(t1.t,-0x3f,sizeof(t1.t));
	for(int i=1;i<=n;i++){
		int v0=max(t0.query(1,1,5e5,1,a[i]-1),t0.query(1,1,5e5,a[i]+1,5e5));
		int v1=t1.query(1,1,5e5,a[i],a[i]);
		t0.update(1,1,5e5,a[i],v1+1);
		t1.update(1,1,5e5,a[i],v0+1);
	}
	cout<<t0.query(1,1,n,1,5e5)<<'\n';
	return 0;
}
```

---

## 作者：HHC883 (赞：1)

# 题目分析
考虑 DP。令 $dp_{i,0}$ 表示以 $a_i$ 结尾且 $a_i$ 位于配对序列的第偶数位时序列长度的最大值，$dp_{i,1}$ 表示以 $a_i$ 结尾且 $a_i$ 位于配对序列的第奇数位时序列长度的最大值，则
$$dp_{i,0}=\max(dp_{j,1}+1),a_i=a_j$$
$$dp_{i,1}=\max(dp_{j,0}+1),a_i \ne a_j$$
但是暴力转移是 $O(n^2)$ 的，会超时，于是我们观察到 $a_i \le 5 \times 10^5$，于是想到通过维护最大值与次大值进行转移。

时间复杂度为 $O(n)$。
# 参考代码

```cpp
#include<iostream>
using namespace std;
int n,a[(int)5e5+5];
int dp[(int)5e5+5][2],maxn[(int)5e5+5][2],cnt[(int)5e5+5],first,second,ans;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		if(maxn[a[i]][1]) dp[i][0]=maxn[a[i]][1]+1;
		if(first==a[i]&&cnt[maxn[a[i]][0]]==1) dp[i][1]=maxn[second][0]+1;
		else dp[i][1]=maxn[first][0]+1;
		if(dp[i][0]>maxn[a[i]][0]) cnt[dp[i][0]]++;
		maxn[a[i]][0]=max(maxn[a[i]][0],dp[i][0]);
		maxn[a[i]][1]=max(maxn[a[i]][1],dp[i][1]);
		if(maxn[a[i]][0]>maxn[first][0]) second=first,first=a[i];
		else if(maxn[a[i]][0]<maxn[first][0]&&maxn[a[i]][0]>maxn[second][0]) second=a[i];
		ans=max(ans,dp[i][0]);
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：_Weslie_ (赞：1)

大家好，我非常喜欢线段树优化 dp，于是我使用线段树优化 dp 通过了这道题目。

前排提醒：本题解做法时间复杂度带一只 $\log$，如果想要学习 $\operatorname{O}(n)$ 做法请自行略过。

## Solution P11187

### Idea

不难发现配对序列就是形如 $\{a,a,b,b,c,c,d,d,\cdots\}$ 的序列。

我们设 $dp_{i,0/1}$ 为当前最后一个数为 $i$，这个数出现在第奇数个位置（表示为 $0$）还是在第偶数个位置（表示为 $1$）的最长配对序列的长度。

显然有：$dp_{i,1}=dp_{i,0}+1$，$dp_{i,0}=\max\{dp_{1,1},dp_{2,1},\cdots,dp_{a_i-1,1},dp_{a_i+1,1},dp_{a_i+2,1},\cdots,dp_{500000,1}\}+1$。

解释一下：如果这个数是第偶数个位置，它前面一个必须是它自己。如果是第奇数个位置，只要前一个位置不是它自己都可以转移。另外，$500000$ 是题目中给定的 $a_i$ 的最大值。

这样的复杂度是 $\operatorname{O}(n^2)$ 的，瓶颈在于 $dp_{i,0}$ 的转移。

考虑优化。

我们发现后面转移 $dp_{i,0}$ 的式子实际上就是 $[1,a[i]-1]$ 与 $[a[i]+1,500000]$ 两个区间最大值的最大值。

求区间最大值，不难联想到线段树。

这样我们把 $dp_{i,1}$ 的信息维护到线段树里，开一个数组记录 $dp_{i,0}$，然后就可以转移了。

最后答案显然是 $\max\{dp_{i,1}\}$（$i\in[1,500000]$），线段树上其实就是 $1$ 号区间，所以输出 $tr_1$ 即可（$tr$ 为维护线段树的数组）。

这样复杂度就是只带一只 $\log$ 的了。

### Code

代码中的 $dp$ 数组相当于记录上文中 $dp_{i,0}$ 的数组。

```
#include<bits/stdc++.h>
#define ls now<<1
#define rs (now<<1)|1
using namespace std;
const int N=500005;
int dp[N],tr[N<<2],n,a[N];
void add(int l,int r,int p,int now,int x){
    if(l==r&&l==p){
        tr[now]=max(tr[now],x);
        return;
    }
    int mid=(l+r)>>1;
    if(p<=mid)add(l,mid,p,ls,x);
    else add(mid+1,r,p,rs,x);
    tr[now]=max(tr[ls],tr[rs]);
}
int query(int l,int r,int al,int ar,int now){
    if(al>ar)return 0;
    if(al<=l&&r<=ar)return tr[now];
    int mid=(l+r)>>1,res=0;
    if(al<=mid)res=max(res,query(l,mid,al,ar,ls));
    if(ar>mid)res=max(res,query(mid+1,r,al,ar,rs));
    return res;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
        if(dp[a[i]]!=0)add(1,500000,a[i],1,dp[a[i]]+1);
        int res=max(query(1,500000,1,a[i]-1,1),query(1,500000,a[i]+1,500000,1));
        dp[a[i]]=res+1;
    }
    printf("%d",tr[1]);
}
```

---

## 作者：CaiZi (赞：1)

## 配对序列 题解
**[题目链接](https://www.luogu.com.cn/problem/P11187)**
### 题目分析
不难发现题目要求的是形如 $w_1,w_1,w_2,w_2,\dots$ 这样的数列，$w$ 中的元素互不相等。

考虑 DP，设 $f_{i,0}$ 表示前 $i$ 个数，选了第 $i$ 个，且第 $i$ 个数还没有配对到相等的数时，最长的配对序列长度。$f_{i,1}$ 类似，但其表示第 $i$ 个数已经匹配到相等的数了。初始状态为 $f_{1,0}=1,f_{1,1}=0$，那么我们有如下转移：

$$\begin{cases}f_{i,0}=\max\limits_{j=1}^{i-1}\{[a_i\ne a_j]\times f_{j,1}\}+1\\f_{i,1}=\max\limits_{j=1}^{i-1}\{[a_i=a_j]\times f_{j,0}\}+1\end{cases}$$

这个是不能过的，所以我们考虑优化。设 $x_i$ 表示当前所有 $a_j=i$ 的 $f_{j,0}$ 的最大值。$y_i$ 类似。$x_i$ 和 $y_i$ 在每轮 DP 后都能 $O(1)$ 更新。那么转移如下：

$$\begin{cases}f_{i,0}=\max\limits_{j=1\land j\ne a_i}^{500000}\{y_j\}\\f_{i,1}=x_{a_i}\end{cases}$$

不难发现 $f_{i,0}$ 的转移可以拆成两段的 $\max$，于是线段树维护单点修改区间最值就好了，记得在每次修改 $y_{a_i}$ 前先判断 $y_{a_i}$ 和 $f_{i,1}$ 哪个更大。
### 代码展示
时间复杂度 $O(n\log w)$，其中 $w=500000$。
```cpp
#include<bits/extc++.h>
#define mid ((l+r)>>1)
using namespace std;
int n,m[500001],f[500001][2],x[500001],y[2000001],g;
inline void update(int a,int b,int l,int r,int s){
	if(l==r){
		y[s]=b;
	}
	else{
		if(a<=mid){
			update(a,b,l,mid,s<<1);
		}
		else{
			update(a,b,mid+1,r,s<<1|1);
		}
		y[s]=max(y[s<<1],y[s<<1|1]);
	}
}
int query(int a,int b,int l,int r,int s){
	int c=INT_MIN;
	if(a<=l&&r<=b){
		c=y[s];
	}
	else{
		if(a<=mid){
			c=max(c,query(a,b,l,mid,s<<1));
		}
		if(b>mid){
			c=max(c,query(a,b,mid+1,r,s<<1|1));
		}
	}
	return c;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	memset(x,-1,sizeof(x));
	memset(y,-1,sizeof(y));
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>m[i];
		f[i][0]=1;
		if(m[i]!=1){
			f[i][0]=max(f[i][0],query(1,m[i]-1,1,500000,1)+1);
		}
		if(m[i]!=500000){
			f[i][0]=max(f[i][0],query(m[i]+1,500000,1,500000,1)+1);
		}
		f[i][1]=x[m[i]]+1;
		x[m[i]]=max(x[m[i]],f[i][0]);
		if(query(m[i],m[i],1,500000,1)<f[i][1]){
			update(m[i],f[i][1],1,500000,1);
		}
		g=max(g,f[i][1]);
	}
	cout<<g;
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/181806402)**

---

## 作者：wangyishan (赞：1)

## P11187 配对序列 题解

简单题。

一眼 DP，考虑设计状态：

令 $f_{i,1}$ 表示以第 $i$ 个数结尾，长度为奇数（或者说最后一个数不同于倒数第二个数）时长度的最大值。

令 $f_{i,0}$ 表示以第 $i$ 个数结尾，长度为偶数（或者说最后一个数相同于倒数第二个数）时长度的最大值。

转移很好写：
$$
f_{i,0}=f_{j,1}+1,(j<i\land {a_j=a_i})\\
f_{i,1}=f_{j,0}+1,(j<i\land {a_j\neq a_i})
$$
直接转移是 $\mathcal{O}(n^2)$ 的，使用线段树优化一下即可达到 $\mathcal{O}(n\log n)$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500000
int n;
int a[500050],mx[500050];
int f[500050][2];
int s[500050<<2];
#define ls p<<1
#define rs p<<1|1
void change(int p,int l,int r,int k,int v){
	if(l==r&&l==k){s[p]=max(s[p],v);return;}
	int mid=(l+r)>>1;
	if(k<=mid)change(ls,l,mid,k,v);
	else change(rs,mid+1,r,k,v);
	s[p]=max(s[ls],s[rs]);
}
int query(int p,int l,int r,int L,int R){
	if(L>500000||R<1)return 0;
	if(L<=l&&r<=R)return s[p];
	int mid=(l+r)>>1,res=0;
	if(L<=mid)res=max(res,query(ls,l,mid,L,R));
	if(mid<R)res=max(res,query(rs,mid+1,r,L,R));
	return res;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	int ans=0;
	for(int i=1;i<=n;i++){
		int t=max(query(1,1,N,1,a[i]-1),query(1,1,N,a[i]+1,N));
		f[i][1]=t+1;
		f[i][0]=(mx[a[i]]==0)?0:(mx[a[i]]+1);
		mx[a[i]]=max(mx[a[i]],f[i][1]);
		change(1,1,N,a[i],f[i][0]);
		ans=max(ans,f[i][0]);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Liyunze123 (赞：0)

这题我们先设一个 $dp_{i,0/1}$ 表示一定选 $i$，$i$ 是偶数或奇数个的最大匹配。

转移：$dp_{i,0}=\max(dp_{j,1}+1)$ 其中 $j<i$ 且 $a_j = a_i$。$dp_{i,1}=\max(dp_{j,0}+1)$ 其中 $j<i$ 且 $a_j \neq a_i$。

时间复杂度 $O(n^2)$。考虑优化。

我们可以用线段树 $tr_{l,r,k}$ 表示 $dp_{i,k}$ 的最大值其中 $l \le a_i \le r$。这样单次转移变成了 $O(\log n)$，总时间复杂度 $O(n \log n)$，过了此题。

上代码：
```
#include<bits/stdc++.h>
#define yuanshen dog
#define zelda god
using namespace std;
int n,a[500010],dp[500010][2],ans,tr[5000010][2];
void add(int i,int l,int r,int k,int t,int g){
	if(l==r){tr[i][t]=max(tr[i][t],dp[g][t]);return;}
	int m=(l+r)/2;
	if(k<=m)add(i*2,l,m,k,t,g);else add(i*2+1,m+1,r,k,t,g);
	tr[i][t]=max(tr[i*2][t],tr[i*2+1][t]);
}
int query(int i,int l,int r,int kl,int kr,int t){
	if(kl>kr||kl>r|kr<l)return 0;
	if(kl<=l&&kr>=r)return tr[i][t];
	int m=(l+r)/2;
	return max(query(i*2,l,m,kl,kr,t),query(i*2+1,m+1,r,kl,kr,t));
}
int main(){
	scanf("%d",&n);
	for(int w=1;w<=n;w++)scanf("%d",&a[w]);
	for(int w=1;w<=n;w++){
		dp[w][0]=query(1,1,500000,a[w],a[w],1);
		if(dp[w][0]%2==1)dp[w][0]++;
		else dp[w][0]=0;
		dp[w][1]=max(query(1,1,500000,1,a[w]-1,0),query(1,1,500000,a[w]+1,500000,0));
		if(dp[w][1]%2==0)dp[w][1]++;
		else dp[w][1]=0;
		add(1,1,500000,a[w],1,w),add(1,1,500000,a[w],0,w);
	}
	for(int w=1;w<=n;w++)ans=max(ans,dp[w][0]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：I_will_AKIOI (赞：0)

非常好数据结构，使我的键盘旋转。

手玩一下可知题目大意就是对于一个 $n$ 为偶数的序列，每两个数为一组，同组之间的数必须相同，而相邻且不在同一组的两个数必须不同，求满足要求的子序列最大长度。

首先对于这种子序列问题，dp 是显然的，而状态一般是设 $f_i$ 表示以 $i$ 结尾的答案，然后枚举 $j\in[0,i-1]$ 来转移，最后答案需要取全局最大值，也就是 $\max_{i=1}^n f_i$。而对于本题，状态转移分长度为奇数和偶数两种情况，因此我们还需要再增加一维，即 $f_{i,0}$ 表示以 $i$ 结尾且长度为偶数的最长子序列长度，$f_{i,1}$ 则表示奇数。

接着发现在转移的时候，若长度为偶数，则 $a_i\ne a_j$，否则必须相等。因此可以写出状态转移方程：$f_{i,0}=\max_{j=0,a_i=a_j}^{i-1} f_{j,1}+1,f_{i,1}=\max_{j=0,a_i\ne a_j}^{i-1} f_{j,0}+1$，时间复杂度为 $O(n^2)$ 可以获得 $45$ 分。

接着我们考虑优化，对于 $f_{i,0}$，我们发现他只能从满足 $a_i=a_j$ 的 $f_{j,1}$ 转移过来，因此可以考虑记录 $maxx_{i}$ 表示 $a_j=i$ 的 $f_{j,1}$ 的最大值。但是对于 $f_{i,1}$ 是需要从满足 $a_i\ne a_j$ 的 $f_{j,0}$ 转移而来，怎么办呢？既然不能包含 $a_j$，就相当于全局取最大值然后除掉 $a_j$，也就是对值域 $[1,a_j-1]$ 和 $[a_j+1,5\times 10^5]$ 取最大值，可以开一个权值线段树维护区间修改，单点查询，于是本题就这么做完了。

```cpp
#include<bits/stdc++.h>
#define N 500005
using namespace std;
struct Data{int l,r,maxx,tag;}t[N*4];//线段树维护区间修改，单点查询
int n,ans,a[N],f[N][2],maxx[N];
void maketag(int k,int x)
{
  t[k].maxx=max(t[k].maxx,x);
  t[k].tag=max(t[k].tag,x);
  return;
}
void pushdown(int k)
{
  maketag(k*2,t[k].tag);
  maketag(k*2+1,t[k].tag);
  return;
}
void build(int k,int l,int r)
{
  t[k].l=l,t[k].r=r;
  if(l==r)
  {
    t[k].maxx=t[k].tag=0;
    return;
  }
  int mid=l+r>>1;
  build(k*2,l,mid);
  build(k*2+1,mid+1,r);
  t[k].maxx=max(t[k*2].maxx,t[k*2+1].maxx);
  return;
}
void update(int k,int l,int r,int x)
{
  if(l<=t[k].l&&t[k].r<=r)
  {
    maketag(k,x);
    return;
  }
  pushdown(k);
  int mid=t[k].l+t[k].r>>1;
  if(l<=mid) update(k*2,l,r,x);
  if(r>mid) update(k*2+1,l,r,x);
  t[k].maxx=max(t[k*2].maxx,t[k*2+1].maxx);
  return;
}
int query(int k,int l)
{
  if(t[k].l==t[k].r) return t[k].maxx;
  pushdown(k);
  int mid=t[k].l+t[k].r>>1,res=0;
  if(l<=mid) res=max(res,query(k*2,l));
  if(l>mid) res=max(res,query(k*2+1,l));
  t[k].maxx=max(t[k*2].maxx,t[k*2+1].maxx);
  return res;
}
int read()
{
  char c=getchar();
  int res=0;
  while(c<'0'||c>'9') c=getchar();
  while(c>='0'&&c<='9') res=res*10+c-48,c=getchar();
  return res;
}
int main()
{
  n=read();
  for(int i=1;i<=n;i++) a[i]=read();
  build(1,1,500000);
  for(int i=1;i<=n;i++)
  {
    f[i][0]=maxx[a[i]];
    f[i][1]=max(1,query(1,a[i]));
    maxx[a[i]]=max(maxx[a[i]],f[i][1]+1);
    if(a[i]!=1) update(1,1,a[i]-1,f[i][0]+1);
    if(a[i]!=500000)/*防止越界*/update(1,a[i]+1,500000,f[i][0]+1);
    ans=max(ans,f[i][0]);//由于f[i][0]表示的是以i结尾的答案，因此需要全局最大值
  }
  cout<<ans;
  return 0;
}
```

---

## 作者：Redshift_Shine (赞：0)

本场比赛最有难度的题，但是比较无脑。

设 $d_{i,0/1}$ 表示结尾为 $i$ 的不完整/完整配对序列的最大长度**除以二向下取整的值**。其中，定义**不完整配对序列**为长度为**奇数**但满足配对序列其余要求的序列。

令 $m=\max a_i$。

以下的转移前提为从前向后遍历到一个 $a_x=i$。

首先考虑如何得到 $d_{i,1}$ 的值。显然，$d_{i,1}$ 只能由 $d_{i,0}$ 转移，因为此时处在偶数位，前一位必须与 $i$ 相等。所以，$d_{i,1}\leftarrow \max(d_{i,1},d_{i,0}+1)$。

接下来考虑如何得到 $d_{i,0}$。此时处在奇数位，根据题目定义，这个位不能与前一位相同。并且，一个不完整配对序列去掉最后一个元素后必须为空序列或一个完整配对序列。

所以，

$$
d_{i,0}=\max_{j=1}^m d_{j,1}
$$

**以上两个转移需同时进行**。

然而，注意到 $d_{i,0}$ 的转移速度过慢，需要优化。

利用 `multiset` 容器的自动排序特性，我们只需要将所有的 $d_{x,1}$ 值存储到 `multiset` 中，再查询除了 $d_{i,1}$ 外的所有值的最大值即可。

时间复杂度 $O(n\log m)$，期望得分 $100$ 分。

```c++
#include <algorithm>
#include <cstdio>
#include <functional>
#include <set>
using namespace std;
const int N = 5e5 + 10;
int n, dp[N][2], res;
multiset<int, greater<>> ms;
bool vis[N];
int main()
{
    // freopen("pairing.in", "r", stdin);
    // freopen("pairing.out", "w", stdout);
    scanf("%d", &n);
    ms.emplace(0);
    for (int i = 1, x, tmp; i <= n; i++)
    {
        scanf("%d", &x);
        if (!vis[x])
        {
            dp[x][0] = *ms.begin();
            ms.emplace(0);
            vis[x] = true;
            continue;
        }
        tmp = max(dp[x][0], (*ms.begin() == dp[x][1] ? *next(ms.begin()) : *ms.begin()));
        ms.erase(ms.find(dp[x][1]));
        dp[x][1] = max(dp[x][0] + 1, dp[x][1]);
        ms.emplace(dp[x][1]);
        dp[x][0] = tmp;
        res = max(res, dp[x][1]);
    }
    printf("%d\n", res << 1);
}
```

---

## 作者：Furina_Saikou (赞：0)

鄙人不才，只会用乐色的数据结构优化动规。

赛后 AC 的我真的哭死 QAQ。

# 思路

设 $pre_i$ 表示 $a_i$ 以前的第一个等于 $a_i$ 的元素的下标，$dp_i$ 表示以 $a_i$ 结尾的最长子序列长度。

先 $O(n)$ 预处理出 $pre$ 数组，然后递推，不难理解状态转移方程为 $dp_i=\displaystyle \max^{pre_i-1}_{j=pre_{pre_i}+1}{dp_j+2}$。也就是在上上个 $a_i$ 和上个 $a_i$ 之间找一个最长的子序列，这样能保证找出来的子序列后接上两个 $a_i$ 后可以满足第一个条件。

找最大值可以通过线段树，树状数组等数据结构维护（是的我太菜了只能用无脑算法），时间复杂度为 $O(n\log_2 n)$。


```cpp
#include<bits/stdc++.h>
#define int long long
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((l+r)>>1)
using namespace std;
const int N=1e6+10,INF=0x7fffffff;
int n,a[N],dp[N],pre[N],x[N],tr[N],ans;
inline int maxs(int a,int b)
{
	return a>b?a:b;
}
inline void push_up(int p)
{
	tr[p]=maxs(tr[ls],tr[rs]);
}
void add(int p,int l,int r,int x,int k)
{
	if(l==r)
	{
		tr[p]=k;
		return;
	}
	if(mid>=x)add(ls,l,mid,x,k);
	else add(rs,mid+1,r,x,k);
	push_up(p);
}
int query(int p,int l,int r,int x,int y)
{
	if(l>y||r<x)return -INF;
	if(x<=l&&r<=y)
	{
		return tr[p];
	}
	return maxs(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y));
}//单点修改，区间查询
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		pre[i]=x[a[i]];
		x[a[i]]=i;
	}//预处理pre数组
	pre[0]=n+1;
	for(int i=1;i<=n;i++)
	{
		int l=pre[pre[i]],r=pre[i];
		dp[i]=max(dp[i],query(1,0,n,(!l?0:l+1),r-1)+2);//特判l==0的情况或者将x数组初值赋为-1
		add(1,0,n,i,dp[i]);//将新的答案加入线段树
		ans=max(ans,dp[i]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：T_TLucas_Yin (赞：0)

仔细思考一下题目对于“配对序列”的解释。容易发现，所谓配对序列其实就是由若干对相邻且相同的元素组成的序列。

那么我们可以用与求最长上升子序列类似的方法来做这道题。将元素在序列中的位置分为奇数位和偶数位两种情况。

- 若 $a_i$ 在奇数位，则它在序列中必须与上一个元素不同。设序列中最大的数为 $m$，答案为该位置之前满足值域为 $[1,a_i-1]\cup[a_i+1,m]$、在序列中偶数位的元素中的最优情况。
- 若 $a_i$ 在偶数位，则它在序列中必须与上一个元素相同。所以答案为该位置之前满足与 $a_i$ 相等、在序列中奇数位的元素中的最优情况。

答案即为每一个数**在偶数位**时最优情况的最大值。值域最优解可以使用线段树之类的数据结构维护。记得每计算一个位置就更新一次值域最优解。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],f1[4000005],f2[4000005],f[2][1000005];
int read(){
	int x=0;
	char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+(c-'0'),c=getchar();
	return x;
}
void update0(int root,int l,int r,int k,int x){
	if(l==r){ f1[root]=max(f1[root],x);return; }
	int mid=(l+r)>>1;
	if(k<=mid) update0(root<<1,l,mid,k,x);
	else update0(root<<1|1,mid+1,r,k,x);
	f1[root]=max(f1[root<<1],f1[root<<1|1]); 
}
void update1(int root,int l,int r,int k,int x){
	if(l==r){ f2[root]=max(f2[root],x);return; }
	int mid=(l+r)>>1;
	if(k<=mid) update1(root<<1,l,mid,k,x);
	else update1(root<<1|1,mid+1,r,k,x);
	f2[root]=max(f2[root<<1],f2[root<<1|1]);
}
int Find0(int root,int l,int r,int k){
	if(l==r) return f1[root];
	int mid=(l+r)>>1;
	if(k<=mid) return Find0(root<<1,l,mid,k);
	else return Find0(root<<1|1,mid+1,r,k);
}
int Find1(int root,int l,int r,int fl,int fr){
	if(fl<=l&&r<=fr) return f2[root];
	int mid=(l+r)>>1,maxn=0;
	if(fl<=mid) maxn=max(maxn,Find1(root<<1,l,mid,fl,fr));
	if(fr>mid) maxn=max(maxn,Find1(root<<1|1,mid+1,r,fl,fr));
	return maxn;
}
int main(){
	n=read();
	int maxn=0;
	for(int i=1;i<=n;i++) a[i]=read(),maxn=max(maxn,a[i]);
	maxn++;
	for(int i=1;i<=n;i++){
		if(i>1){
			int x=Find0(1,0,maxn,a[i]);
			if(x!=0) f[1][i]=x+1;
		}
		f[0][i]=max(Find1(1,0,maxn,1,a[i]-1),Find1(1,0,maxn,a[i]+1,maxn))+1;
		update0(1,0,maxn,a[i],f[0][i]);
		update1(1,0,maxn,a[i],f[1][i]);
	}
	int maxx=0;
	for(int i=1;i<=n;i++) maxx=max(maxx,f[1][i]);
	printf("%d",maxx);
	return 0;
}
```

---


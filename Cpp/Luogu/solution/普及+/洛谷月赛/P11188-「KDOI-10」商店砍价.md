# 「KDOI-10」商店砍价

## 题目背景

您可以点击 [这里](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/3jbtilzv) 下载本场比赛的选手文件。

密码：`rAnHoUyaSuoBaoMimaNijuEdefAngsHa2)2$1)0(2@0!`

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**

## 题目描述

有一个正整数 $n$，保证其只由数字 $1\sim 9$ 构成。

你可以做任意多次如下操作：

- 选择 $n$ 的一个数位 $x$，花费 $v_x$ 的代价删除它，注意，此时 $n$ 的数位个数会减少 $1$，$n$ 的值也会发生相应的变化；
- 或者，花费 $n$ 的代价把剩余的所有数位删除。

求把整个数删除的最小代价。

## 说明/提示

**【样例 1 解释】**

对于第一组测试数据，最优操作方案如下：

- 删除数位 $2$，代价为 $10$，此时 $n$ 变为 $13$；
- 删除数位 $3$，代价为 $10$，此时 $n$ 变为 $1$；
- 删除 $n$ 的剩余所有数位，代价为 $1$。

总代价为 $10+10+1=21$，可以证明，这是代价的最小值。

对于第二组测试数据，一种最优操作方案如下：

- 删除第一个数位 $1$，代价为 $2$，此时 $n$ 变为 $121$；
- 删除最后一个数位 $1$，代价为 $2$，此时 $n$ 变为 $12$；
- 删除数位 $2$，代价为 $1$，此时 $n$ 变为 $1$；
- 删除 $n$ 的剩余所有数位，代价为 $1$。

总代价为 $2+2+1+1=6$。

**【样例 2】**

见选手目录下的 `bargain/bargain2.in` 与 `bargain/bargain2.ans`。

这个样例满足测试点 $3\sim 6$ 的约束条件。

**【样例 3】**

见选手目录下的 `bargain/bargain3.in` 与 `bargain/bargain3.ans`。

这个样例满足测试点 $11$ 的约束条件。

**【样例 4】**

见选手目录下的 `bargain/bargain4.in` 与 `bargain/bargain4.ans`。

这个样例满足测试点 $17,18$ 的约束条件。

**【样例 5】**

见选手目录下的 `bargain/bargain5.in` 与 `bargain/bargain5.ans`。

这个样例满足测试点 $23\sim 25$ 的约束条件。

***

**【数据范围】**

对于全部的测试数据，保证：

- $1\le t\le 10$；
- $1\le n< 10^{10^5}$；
- 对于任意 $1\le i\le 9$，$1\le v_i\le 10^5$；
- $n$ 由数字 $1\sim 9$ 构成。

|   测试点    |   $n<$    | $v_i\le$ |        特殊性质        |
| :---------: | :---------: | :------: | :--------------------: |
|     $1$     |    $100$     |  $10^5$  |           无           |
|     $2$     |    $10^3$    |  $10^5$  |           无           |
|  $3\sim 6$  |  $10^{18}$  |  $10^5$  |           无           |
| $7\sim 9$  |  $10^{40}$  |  $10^5$  |           无           |
|    $10$    | $10^{10^5}$ |  $10^5$  | $n$ 由至多一种数字构成 |
|    $11$     | $10^{10^5}$ |  $10^5$  | $n$ 由至多两种数字构成 |
| $12,13$ | $10^{10^5}$ |  $10^5$  | $n$ 由至多三种数字构成 |
| $14\sim 16$ | $10^{10^3}$ | $10^5$ | $v_1=v_2=v_3=\dots =v_9$ |
| $17,18$ | $10^{10^5}$ | $10^5$ | $v_1=v_2=v_3=\dots =v_9$ |
| $19,20$ | $10^{100}$ | $100$ | 无 |
| $21,22$ | $10^{10^3}$ | $10^3$ | 无 |
| $23\sim 25$ | $10^{10^5}$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
0
3
123
10 10 10 10 10 10 10 10 10 
1121
2 1 2 2 2 2 2 2 2
987654321
1 2 3 4 5 6 7 8 9
```

### 输出

```
21
6
45
```

# 题解

## 作者：cff_0102 (赞：43)

假设我们只做操作 $1$，答案即为所有数位的代价之和，记为 $s$。

原题转化为：找到 $n$ 的一个子序列，在最后一步直接把这个数删掉，求最多能“节省”多少代价。

注意到可以 dp 求解。设 $dp_{i,j}$ 表示考虑从左到右数的第 $i$ 到最后一位，在这一段中选出一个长度为 $j$ 的子串，最多节省多少代价。

设 $n_i$ 是 $n$ 从左到右数的第 $i$ 位，那么，在转移时，对于这一位，要么不选这一位作为最高位，则 $dp_{i,j}=dp_{i+1,j}$；要么选这一位作为最高位，那么 $dp_{i,j}=dp_{i+1,j-1}+v_{n_i}-n_i\times10^{j-1}$。取 $\max$ 就可以了。

从后往前 dp，最后输出 $s-\max(0,\max\limits_{i=1}^{j_{\max}}dp_{1,i})$ 即可。

赛时为了保险把 dp 时选取的 $j$ 的最大值设成了 $9$，但实际上并不用考虑那么多位啦。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int c;
int v[15],dp[100005][15],a[100005];
int p10[15]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
void mian(){
	string n;cin>>n;int l=n.length();
	for(int i=0;i<l;i++)a[i+1]=n[i]-'0';
	for(int i=1;i<=9;i++)cin>>v[i];
	memset(dp,0,sizeof dp);
	int s=0;
	for(int i=1;i<=l;i++)s+=v[a[i]];
	for(int i=l;i>=1;i--){
		for(int j=1;j<=min(9ll,l-i+1);j++){
			dp[i][j]=max(dp[i+1][j],dp[i+1][j-1]+v[a[i]]-p10[j-1]*a[i]);
		}
	}
	int ans=0;
	for(int i=1;i<=9;i++)ans=max(ans,dp[1][i]);
	cout<<s-ans<<endl;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>c;
	int t;cin>>t;
	while(t--)mian();
	return 0;
}
```

---

## 作者：无名之雾 (赞：39)

赛时 $10$ 分钟秒了，应该是目前赛时切的速度最快的绿题，故写一篇题解纪念一下。


## 思路

根据直觉再结合 $v_i\le10^5$ 这一数据范围不难发现花费 $n$ 的代价把剩余的所有数位删除。这一操作如果是优的。那么 $n$ 的剩余数位个数比不可能大于 $6$。

证明如下：

设当前剩余数位个数为 $x$。

将当前每一位的数字定为最小的 $1$，并将每一位贡献定为最大的 $10^5$。

此时直接删除所有剩余数位的贡献应该是：

$$\sum_{i=0}^{x-1} 10^x$$

一位一位的删除贡献应该为：

$$\sum v_i$$


显然当 $x>6$ 时直接删去所有数位是不优的。

考虑直接 dp。

设 $f_{i,j}$ 表示从前 $i$ 个数位中选取 $j$ 位直接进行消除后，消除所有数位所需的代价。

转移方程应该为：

$$f_{i,j}=\min(f_{i,j}，f_{i,j+1}+10^{j-1}\times n_i-v_i)$$

时间复杂度为 $O(6n)$。

空间复杂度可以在滚动数组后做到 $O(1)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
} 
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[105];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans*=a;
		b>>=1,a*=a;
	}
	return ans;
} 
const int N=25;
int v[N],f[N];
signed main(){
	read();int t=read(); 
	while(t--){
		string s;cin>>s;int n=s.size(),ans=0;
		for(int i=1;i<=9;i++)v[i]=read();
		for(int i=0;i<n;i++)ans+=v[s[i]-'0'];
		int sum=ans;
		for(int i=6;i>=1;i--){
			memset(f,0x3f,sizeof f);f[i]=sum;
			for(int j=1;j<=n;j++){
				for(int k=1;k<=i;k++){
					f[k]=min(f[k],f[k+1]+qpow(10,k-1)*(s[j-1]-'0')-v[s[j-1]-'0']);
				}
			}
			ans=min(ans,f[1]);
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：Petit_Souris (赞：23)

**前言：**

出题人的 idea 来源于一次逛商场的经历，看到某些商品的价格标牌胶水掉了，于是缺少了一些数字，产生了一些惊为天人的价格。原本是计划基于这个写一个比较好玩的题目背景的，不过这是 T1，就不整太多废话了，直接放最简洁的形式化题面了。

笑点解析：赛时这题 $[0,100]$ 中所有可能出现的 $26$ 种分数都被达成了。我真是太牛了，就凭我一个题，这场比赛区分度就比 APIO 2024 高了！

**题意回顾：**

有一个正整数 $n$，保证其只由数字 $1\sim 9$ 构成。
	
你可以做任意多次如下操作：
	
- 选择 $n$ 的一个数位 $x$，花费 $v_x$ 的代价删除它，注意，此时 $n$ 的数位个数会减少 $1$，$n$ 的值也会发生相应的变化；

- 或者，花费 $n$ 的代价把剩余的所有数位删除。

求把整个数删除的最小代价。

多测，$n<10^{10^5},v_i\le 10^5$。

**题解：**

暴力 1：

以下记 $n$ 的数位数量为 $C=\mathcal O(\lg n)$。
	
暴力枚举每个数位是否删除，将剩下部分组合成一个整数。
	
时间复杂度 $\mathcal O(2^C C)$，期望得分 $24$。

初步分析：

由于 $v\le 10^5$，所以假设所有数位都直接单个删除，至多也只有 $10^5C$ 的代价，这个代价并不是很大。
	
我们发现如果当前是一个 $x$ 位数，$x\ge 6$，那么删除最高位至少有 $10^{x-1}$ 的收益，而只花费了至多 $10^5$ 的代价。因此一定会不断删除直到最后剩下 $\le 5$ 位数。
	
暴力 2：可以考虑暴力枚举这 $5$ 位数是什么。时间复杂度 $\mathcal O(\binom{C}{5}C)$，期望得分 $36$。
	
暴力 3：当 $n$ 至多由三种不同数字构成的时候，我们可以枚举最后剩下的子序列是什么。时间复杂度 $\mathcal O(C)$，带 $3^5$ 的常数，期望得分 $16$。
	
暴力 4：当 $v$ 全相等时，我们枚举剩余的位数，那么单删的代价就可以计算出来了，是个常数。剩下部分要保留一个尽可能小的 $x$ 位数，是个经典贪心。时间复杂度 $\mathcal O(C)$，期望得分 $20$。
	
把如上所有算法结合，期望得分 $72$。

正解：

其实在以上多种做法的提示下正解已经很明显了。
	
考虑从后往前 dp，记录当前的数位数量。即设 $f_{i,j}$ 表示目前考虑到从低到高的第 $i$ 位，已经保留了 $j$ 位数字，最小代价是多少。
	
转移的时候，如果直接删除这个数位，转移形如 $f_{i,j}+v_{a_i}\to f_{i+1,j}$；如果保留这个数位，转移形如 $f_{i,j}+a_i\cdot 10^{j}\to f_{i+1,j+1}$，其中 $a_i$ 表示 $n$ 的从低到高第 $i$ 位。
	
由之前提到的性质，这里 $j$ 只需要枚举到 $5$ 就够了。时间复杂度 $\mathcal O(C)$，期望得分 $100$。

一些可能的其他做法：枚举 $9^5$ 种子序列，用子序列自动机判断。应该还是标解比较简单一点。

**标程：**

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=1e5+9,INF=1e12;
ll typ,T,n,v[11],dp[N][6],pw10[6];
char s[N];
void solve(){
    scanf("%s",s+1),n=strlen(s+1);
    rep(i,1,9)v[i]=read();
    rep(i,0,n+1){
        rep(j,0,5)dp[i][j]=INF;
    }
    dp[n+1][0]=0;
    per(i,n,1){
        ll a=s[i]-'0';
        rep(j,0,5){
            dp[i][j]=min(dp[i][j],dp[i+1][j]+v[a]);
            if(j^5)dp[i][j+1]=min(dp[i][j+1],dp[i+1][j]+a*pw10[j]);
        }
    }
    write(*min_element(dp[1],dp[1]+6)),putchar('\n');
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    typ=read(),T=read(),pw10[0]=1;
    rep(i,1,5)pw10[i]=pw10[i-1]*10;
    while(T--)solve();
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：Scean_Tong (赞：19)

## P11188 「KDOI-10」商店砍价 题解


### 题意

给你一个数 $n$ 和每个删去每个数字的代价。

每次操作可以花费一个数字的代价删去一个数字，或者花费 $n$ 的代价删去整个数字。

求删去整个数字的最小代价。

### 思路

场切了。

因为 $n$ 的位数非常大，但是 $v$ 最大只能是 $10^5$，所以 $n$ 的位数大于 $5$ 的时候一定是删去一个数字更优。

所以我们充分发扬人类智慧。考虑仿照 CSP-S2023 T1 的做法，枚举所有 $5$ 位数，如果这个 $5$ 位数是 $n$ 的子序列，那么就可以通过删去 $n$ 的一些数位使 $n$ 变成这个 $5$ 位数，如果匹配成功，直接爆搜删去当前 $5$ 位数的代价，这种情况的总代价就是爆搜出的答案加上删去其他数位的代价，所有情况取最小值，做完了。

实现有一些小细节，具体详见代码。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T=1,c;
string str;
const int maxn=10,inf=1e18;
int v[maxn];
int ans=inf;
int mp[maxn],num[maxn];
set<int> se[maxn];
int s[maxn];
int cnt;
void init(int a,int b,int c,int d,int e){
	cnt=0;
	memset(mp,0,sizeof mp);
	memset(num,0,sizeof num);
	if(a>0) mp[++cnt]=a;
	if(b>0) mp[++cnt]=b;
	if(c>0) mp[++cnt]=c;
	if(d>0) mp[++cnt]=d;
	if(e>0) mp[++cnt]=e;
	for(int i=1;i<=cnt;i++){
		num[mp[i]]++;
	}
}
bool judge(int a,int b,int c,int d,int e){
	for(int i=1;i<=9;i++){
		if(num[i]>s[i]){
			return 0;	
		}
	} 
	int pre=0;
	for(int i=1;i<=cnt;i++){
		int now=mp[i];
		if(pre>=*se[now].rbegin()){
			return 0;
		}
		else pre=*se[now].upper_bound(pre);
	}
	return 1;
}
int get(int a,int b,int c,int d,int e){
	int ret=0;
	for(int i=1;i<=9;i++){
		int rett=(v[i]*(s[i]-num[i]));
		ret+=rett;
	}
	int ret1=0;
	for(int i=1;i<=cnt;i++){
		int rett=(ret1<<1)+(ret1<<3);
		ret1=rett;
		ret1+=mp[i];	
	}
	return ret+ret1;
}
void solve(){
	cin>>str;
	ans=inf;
	int n=str.size();
	str='#'+str;
	for(int i=1;i<=9;i++){
		cin>>v[i];
	}
	for(int i=1;i<=9;i++){
		s[i]=0;
		se[i].clear();
	}
	for(int i=1;i<=n;i++){
		s[str[i]-48]++;
		se[str[i]-48].insert(i);
	}
	int ans=1e18;
	for(int a=0;a<=9;a++){
		for(int b=0;b<=9;b++){
			for(int c=0;c<=9;c++){
				for(int d=0;d<=9;d++){
					for(int e=0;e<=9;e++){
						init(a,b,c,d,e);
						if(judge(a,b,c,d,e)==1){
							ans=min(ans,get(a,b,c,d,e));
						}
					}
				}
			}
		}
	}
	cout<<ans<<'\n';
}

int32_t main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
//	freopen("bargain5.in","r",stdin);
//	freopen("bargain5.out","w",stdout);
	cin>>c>>T;
	while(T--){
		solve();
	}	
	return 0;
}

```

---

## 作者：Aventurine_stone (赞：13)

## 1. 题目分析
这是一篇[模拟退火](https://www.luogu.com.cn/article/4k4faiv6)题解。  
我第一眼看到这道题就知道这道题是动态规划或者贪心。  
但是我太菜了推不出式子，于是只能另辟蹊径。  
## 2. 题目做法
仔细观察数据范围，$v$ 最大只有 $10^5$，故最优策略保留的数必定不超过 $5$ 个。  
我们首先想到暴力搜索，但搜索的方案数实在是太过庞大，时间复杂度是不允许的。我们发现每次方案变动对答案的影响都不是很大，故不难想此题的所有方案的值是一个连续的多峰函数，于是我们可以考虑用模拟退火来解决此题。  
所以我们可以随机这 $5$ 个点的位置，若有两个点位置重合，说明此时我们只选 $4$ 个点，这样就可以处理选 $5$ 个以下点的情况了。  
若 $n$ 的位数小于等于 $5$ 时，我们还需要先算一次一个数都不保留时的值，这是显然的。  
我们用一个 $to$ 数组记录我们要保留哪几个位置的数。在退火时，每次我们随机两个值 $x$ 和 $y$，$x$ 表示我们要改变的 $to$ 数组的下标，$y$ 表示将此下标的 $to$ 数组的值改成什么。  
有一些优化我放代码的注释里了，此题时间限制较宽裕，不加优化应该也能过。
## 3. 代码

```cpp
#include<bits/stdc++.h>
#define r() rand()
#define R(l,r) ((double)rand()/RAND_MAX*(r-l))
#define ll long long
using namespace std;
const int N=100010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int C,t;
char c[N];
int n,v[10],a[N];
double T,dt;
int to[7],have[N],num;
ll sum,ans,tt,now,fu;
inline ll change(int x,int y)
{
	have[to[x]]==1?sum+=v[a[to[x]]]:1;
	!have[y]?sum-=v[a[y]]:1;
	to[x]=y;
	num=a[to[1]];
	for(int i=2;i<=5;i++)
		to[i]!=to[i-1]?num=(num<<1)+(num<<3)+a[to[i]]:1;
	tt=sum+num;
	tt<ans?ans=tt:1;
	return tt;
}
void SA()
{
	T=1e5;
	sum=0;
	for(int i=1;i<=n;i++)
		sum+=v[a[i]];
	ans=sum;
	for(int i=1;i<=5;i++)
		to[i]=r()%n+1,have[to[i]]++;
	sort(to+1,to+6);
	num=a[to[1]],sum-=v[a[to[1]]];
	for(int i=2;i<=5;i++)
		to[i]!=to[i-1]?num=(num<<1)+(num<<3)+a[to[i]],sum-=v[a[to[i]]]:1;
	now=sum+num;
	ans=min(ans,now);
	while(T>1e-7)
	{
		//最好让 to 数组保持升序，这样每次改变都不用让 to 数组重新排序了 
		int x=rand()%5+1,y=r()%(to[x+1]-to[x-1]+1)+to[x-1];
		if(to[x]==y)//此时不用进行更改 
			continue;
		int g=to[x],numg=num;
		ll sumg=sum;
		fu=change(x,y);
		dt=now-fu;
		if(exp(dt/T)>R(0,1))
			now=fu,have[g]--,have[y]++;
		else
			to[x]=g,sum=sumg,num=numg;
		T*=0.9999;
	}
	for(int i=1;i<=5;i++)
		have[to[i]]--;
}
int main()
{
	C=read(),t=read();
	to[0]=1;
	while(t--)
	{
		scanf("%s",c+1);
		n=strlen(c+1);
		to[6]=n;
		for(int i=1;i<=n;i++)
			a[i]=c[i]-'0';
		for(int i=1;i<=9;i++)
			v[i]=read();
		if(n==1)//特判，否则我的程序会进死循环 
		{
			printf("%d\n",min(a[1],v[a[1]]));
			continue;
		}
		SA();
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：MutU (赞：7)

### [原题传送门](https://www.luogu.com.cn/problem/P11188)

读了题目，容易想到一个很显然的 $O(n^2)$ dp 做法。

设计状态 $dp_{i,j}$ 表示后 $i$ 位数字，通过一些删位操作后只剩下 $j$ 位，再将所有数位删除的最小代价。那么每一位有删除或不删除两种决策。递推式就是：

> $dp_{i,j}=min(dp_{i+1,j-1}+10^{j-1}*n_i,dp_{i+1,j}+v_{n_i})$

其中 $n_i$ 表示数字 $n$ 的第 $i$ 位。这个做法可以拿到 $22$ 个点的高分。

注意到删除任意一个数位的代价 $v_i$ 满足 $v_i\le 10^5$，而总长度至多为 $10^5$。也就是说全部删完最多也只要 $10^{10}$ 的代价。因此，我们知道若不把原数删到 $10^{10}$ 以下，结果必定更劣。

所以可以不用管上述 dp 状态中 $j>10$ 的情况。所以最后递推式不变，改变数组大小即可拿到满分。

### Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 100100;
int T,len,dp[N][20],v[20],p[20],ans;
char st[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>T>>T;
	p[0]=1;
	for(int i=1;i<=18;i++) p[i]=p[i-1]*10; //预处理10的幂 
	while(T--){
		ans=0x7ffffffffffffff;
		for(int i=1;i<=100010;i++) for(int j=0;j<=16;j++) dp[i][j]=0x7ffffffffffffff;
		cin>>st+1;
		for(int i=1;i<=9;i++) cin>>v[i];
		len=strlen(st+1);
		dp[len+1][0]=0;
		for(int i=len;i>=1;i--){
			for(int j=0;j<=15;j++){
				if(j==0) dp[i][j]=dp[i+1][j]+v[st[i]-'0'];
				else dp[i][j]=min(dp[i+1][j-1]+p[j-1]*(st[i]-'0'),dp[i+1][j]+v[st[i]-'0']);
			}
		}
		for(int i=0;i<=15;i++) ans=min(ans,dp[1][i]);
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：hez_EX (赞：6)

[题面](/problem/P11188)。

个人感觉到不了绿。

场上唐诗了，先试图贪心，未果。

注意到了当某一 $v$ 比较大的时候可能会出现“我们删数越多，就应该删数越少”的矛盾，故考虑 dp。

当数字本身超过**逐一**删去其价值总和之时，就没有执行操作 2 的必要。也就意味着需要将原数删至只剩 $6$ 位，~~我场上写了删至 $13$ 位~~。正难则反，考虑只保留 $6$ 位。

按照常规的状态设计，记 $f_{i,j}$ 为考虑**低** $i$ 位，从已经考虑的位内保留了 $j$ 位的最小代价。从低向高枚举是为了方便进行代价的即时合并，这一点将在转移方程内揭示。

转移方程长得和背包很像，$x$ 是 $n$ 每一位的数字从低到高的序列：
$$f_{i,j}=\min\{f_{i-1,j}+v_{x_i},f_{i-1,j-1}+x_i\cdot10^{j-1}\}$$
 - 不保留这一位就要删掉它，带来 $v_{x_i}$ 的代价；
 - 保留这一位就不会带来删除代价，因为是从低向高枚举，其位数是确定的，所以可以直接得出不删它带来的代价是 $x_i\cdot10^{j-1}$。

时间复杂度 $\mathcal O(n)$，带 $6$ 的常数。

然后这题就做完了。代码变量名与推导相符，放心食用。

### AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
inline void read(int &x)
{
	char c=getchar();x=0;
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10-48+c,c=getchar();
}
int t,x[100005],n,v[10];
ll f[100005][30];
const ll e[20]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000,10000000000000,100000000000000,1000000000000000,10000000000000000,100000000000000000,1000000000000000000}; //exp 打表
//将 x 删成一个 S 位数 
ll ans;
int S;
void work()
{
	memset(f,0x3f,sizeof f);f[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		f[i][0]=f[i-1][0]+v[x[i]];
		for(int j=1;j<=min(S,i);j++)
			f[i][j]=min(f[i-1][j]+v[x[i]],f[i-1][j-1]+x[i]*e[j-1]);
	}
	ans=f[n][0];
	for(int i=1;i<=min(S,n);i++) ans=min(ans,f[n][i]);
	printf("%lld\n",ans);
}
int main()
{
//	freopen("bargain5.in","r",stdin);
	read(t);read(t);
	while(t--)
	{
		char c=getchar();n=0;S=6;
		while(!isdigit(c)) c=getchar();
		while(isdigit(c)) x[++n]=c-48,c=getchar();
		reverse(x+1,x+n+1);ans=0;
		for(int i=1;i<=9;i++) read(v[i]);
		work();
	}
	return 0;
}
```

---

## 作者：0tAp (赞：6)

题目链接：[P11188 「KDOI-10」商店砍价](https://www.luogu.com.cn/problem/P11188)


---

做法：贪心+二分+枚举

思路：首先引出由题意而推出的一条性质：$\lg n\le5$ 时才考虑进行操作 $2$（证明在下面给出）。根据该性质我们便能想到关于这题的暴力枚举，即只考虑枚举 $[1,1e6-1]$ 的数，其余部分直接花费 $v_x$ 删掉，当然，在枚举的过程中，每个数出现的位置对于我们来说很重要，这关乎我们在进行删除操作时能否得到该数字，于是我们不难想到利用数组来存这一信息，然后 *check* 一下能否得到该数字（*check* 函数的功能在下文给出）。最后我们考虑操作 $1$ 和操作 $2$ 产生的共同价值或者不考虑操作 $2$（大部分 $92pts$ 可能是因为没考虑该情况），最后记得清空！！！

证明：当所有的 $v_x=1e5$ 时，若此时 $n\ge1e6$ 则操作 $2$ 需要花费 $n$，而操作 $1$ 仅仅花费 $(\lg n+1)*v_x$ ，因此我们仅在 $n$ 的长度小于6时考虑操作 $2$。

*check* 函数：为了方便，我这里选择用 set 进行位置的存储。当我们枚举的数合法时，设该数为 $a_1a_2a_3......$ ，此时应该有 $a_1$ 存在一个在原数中出现的位置大于 $a_2$ 其中一个在原数中的出现的位置，以次类推，因此我们可以利用二分来进行查找。当然如果某个数 $a_x$ 在我们枚举的数中，它出现的次数如果大于它在原数中出现的次数的话，这也是不合乎道理的。

代码如下：


```cpp
#include<algorithm>
#include<iostream>
#include<string.h>
#include<cstdio>
#include<vector>
#include<cmath>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define int long long
#define repu(i,u) for(int i=(h[u]);i;i=(ne[i]))
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define xx return
const int N=1e6+10;

int c,T;
int v[10];
int cnt[10];
int ans=1e18;
set<int>num[15];
int now=0;
int va[10];
int idx[10];

bool check(int a,int b)
{
	if(a<=b)xx false;
	xx true;
}

bool check2()
{
	int the_end=0;
	rep(i,1,now)
	{
		if(the_end>=*num[va[i]].rbegin())xx false;
		the_end=*num[va[i]].upper_bound(the_end);
	}
	xx true;
}


void compute(int a,int b,int c,int d,int e)
{
	now=0;
	rep(i,1,9)va[i]=idx[i]=0;
	if(a)va[++now]=a;if(b)va[++now]=b;if(c)va[++now]=c;
	if(d)va[++now]=d;if(e)va[++now]=e;
	if(!a&&!b&&!c&&!d&&!e)xx;
	rep(i,1,now)idx[va[i]]++;
	rep(i,1,9)if(check(idx[i],cnt[i]))xx;
	if(!check2())xx;
	int pre=0,sum=0;
	rep(i,1,now)pre=va[i]+pre*10;
	rep(i,1,9)sum+=v[i]*(cnt[i]-idx[i]);
	int cost2=0;
	rep(i,1,9)cost2+=v[i]*cnt[i];
	ans=min(ans,pre+sum);
	ans=min(ans,cost2);
	xx;
}

void solve()
{
	ans=1e18;
	string s;
	cin>>s;
	int len=s.size();
	s=" "+s;
	rep(i,1,9)scanf("%lld",&v[i]);
	rep(i,1,9)cnt[i]=0,num[i].clear();
	
	int k=len;
	rep(i,1,len)
	{
		int now=s[i]-'0';
		++cnt[now];
		num[now].insert(i);
	}
	rep(a,0,9)
	rep(b,0,9)
	rep(c,0,9)
	rep(d,0,9)
	rep(e,0,9){
		compute(a,b,c,d,e);
	}
	printf("%lld\n",ans);
	xx;
}

signed main()
{
	scanf("%lld%lld",&c,&T);
	while(T--)solve();
	xx 0;
}
```

---

## 作者：da_ke (赞：5)

# Solution

大佬们都用的是 DP，但是我照着他们的思路都没做出来，但是按自己的思路做出来了，所以讲讲我的思路。

我们枚举最后一把消除数的**位数** $L$，发现 $L> 6$ 的时候是不优的。于是 $L\leq 6$。

我们有暴力 DP：

$$dp(i,j)=\min\{dp(i+1,j)+V_i,dp(i+1,j-1)+10^{j-1}\times N_i\},j\in [1,L]$$。

这里 $dp(i,j)$ 表示决策到第 $i$ 位，还有 $j$ 位没有算入最后一把消除的贡献。$V_i,N_i$ 分别表示第 $i$ 位的**代价**和**数值**。

最后记忆化搜索，时间复杂度：$O(36 \lg n)$，忽略常数为 $O(\lg n)$。常数略比大佬们的做法大。

下面的**含缺省源**的代码可以通过本题。

```cpp
#include <bits/stdc++.h>

#define i64 long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define fdn(i,r,l) for(int i=(r);i>=(l);i--)
#define pii pair<int,int>
using namespace std;

typedef long long ll;
typedef double db;
typedef __int128 i128;

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());
std::mt19937_64 rnd64(std::chrono::steady_clock::now().time_since_epoch().count());

const int N=1e5+23;
const ll M[]={1,10,100,1000,10000,100000,1000000,10000000,100000000};

int n;
string X;
ll mem[N][10];
vector<ll> V(11);

ll dp(int i,int j)
{
    ll& ans=mem[i][j];
    if(i==n+1) return 0;
    if(ans!=-1) return ans;
    ans=1ll<<59;
    ans=min(ans,dp(i+1,j)+V[X[i]-'0']);
    if(j>0) ans=min(ans,dp(i+1,j-1)+M[j-1]*(X[i]-'0'));
    return ans;
}


void solve()
{
    cin>>X;
    n=X.size();X=' '+X;
    rep(i,1,9) cin>>V[i];
    ll ans=1ll<<59;
    rep(len,0,6)
    {
        memset(mem,-1,sizeof(mem));
        ans=min(ans,dp(1,len));
    }
    cout<<ans<<endl;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    int X,T;
    cin>>X>>T;
    while(T--) solve();
}
```

### update：优化方案

我们枚举 $L$，答案为 $dp(1,L)$。实际上，我们从前往后枚举 $L$ 时，$dp(1,L)$ 可以由 $dp(1,L-1)$ 转移而来。更形象的说法是，我们记搜的时候 $dp(1,L)$ 会直接调用 $dp(1,L-1)$。这时候每一个状态只会被访问 $1$ 次，时间复杂度为 $O(6\lg n)$，忽略常数为 $O(\lg n)$。

虽然渐进复杂度相同，但这种方法常数会小一些。

优化前：<https://www.luogu.com.cn/record/182609975>

优化后：<https://www.luogu.com.cn/record/183031562>

效率还是有显著的差别的。

代码实现时，每次枚举 $L$ 时**不清空记忆化数组**，在开始时清空即可。

```cpp
#include <bits/stdc++.h>

#define i64 long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define fdn(i,r,l) for(int i=(r);i>=(l);i--)
#define pii pair<int,int>
using namespace std;

typedef long long ll;
typedef double db;
typedef __int128 i128;

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());
std::mt19937_64 rnd64(std::chrono::steady_clock::now().time_since_epoch().count());

const int N=1e5+23;
const ll M[]={1,10,100,1000,10000,100000,1000000,10000000,100000000};

int n;
string X;
ll mem[N][10];
vector<ll> V(11);

ll dp(int i,int j)
{
    ll& ans=mem[i][j];
    if(i==n+1) return 0;
    if(ans!=-1) return ans;
    ans=1ll<<59;
    ans=min(ans,dp(i+1,j)+V[X[i]-'0']);
    if(j>0) ans=min(ans,dp(i+1,j-1)+M[j-1]*(X[i]-'0'));
    return ans;
}


void solve()
{
    cin>>X;
    n=X.size();X=' '+X;
    rep(i,1,9) cin>>V[i];
    ll ans=1ll<<59;
    memset(mem,-1,sizeof(mem));
    rep(len,0,6)
        ans=min(ans,dp(1,len));
    cout<<ans<<endl;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
    int X,T;
    cin>>X>>T;
    while(T--) solve();
}
```

### 正确性证明

设最后一把删除的数的位数为 $L$，位权为 $10^i$ 的位上的数为 $K_i$。

这个数为 $\sum\limits _{i=0}^{L-1}K_i10^{L}$。如果一位一位删最后的代价为 $\sum\limits v_{K_i}$。

我们求出满足 $\sum\limits _{i=0}^{L-1}K_i10^{L}\leq \sum\limits v_{K_i}$ **恒成立**情况下 $L$ 的最大值。

$\sum\limits _{i=0}^{L-1}10^{L}\leq\sum\limits _{i=0}^{L-1}K_i10^{L}\leq \sum\limits _{i=0}^{L-1}9\times10^{L}$，$\sum\limits v_{K_i}\leq10^5L$

定义函数 $f(L)=\sum\limits _{i=0}^{L-1}10^{L},g(L)=\sum\limits _{i=0}^{L-1}9\times10^{L},h(L)=10^5L$。显然 $h(L)$ 是没有 $f(L),g(L)$ 增长得快的。

直接手算，发现 $L\leq 6$。

# Conclusion

- Update 2024/10/16：初稿。
- Update 2024/10/18：增加优化。
- Update 2024/10/19：增加证明，修复错误。


这个题目作为 T1 非常恐怖，特别是我这种菜鸡。但是我们不必害怕，DP 的问题很多都可以用记忆化搜索解决。

---

## 作者：_H17_ (赞：2)

## 前言

可惜了 T2 的难度硬生生扔到 T1 了，不过场切绿题还是挺爽的。

## 题目分析

既然操作二只会出现一次，不妨考虑一下它的性质。

显然做操作二的情况一定满足 $\sum_{k \operatorname{in} n} v_k\ge n$，而且操作二的位数肯定不会特别大（注意：满足情况不一定操作二最优）。

考虑从操作二突破：显然尽量最大化 $v_k$ 可以尽量的让更大的数来符合操作二的标准。

假设 $v_k=10^5$，$n$ 一共有 $w$ 位。

此时 $10^5\times w$ 是一位一位删除的代价，整个删除的代价是 $n$（也是 $10^w$ 级别的）。

我们要最大化 $n(w)$，显然 $w=6$ 已经撑破天了。

于是只需要选择 $0\sim 6$ 个数来做操作二，剩下的来一位一位删除。

选择一定数量的东西进行一些事情？这不就是 DP 嘛。

考虑按照数位 DP（注意：这不是数位 DP），考虑 $f_{i,j}$ 表示最小的 $i$ 位，取了 $j$ 个数操作二的最小代价。

状态转移方程：$f_{i,j}=\min(f_{i-1,j}+v_{a_i},f_{i-1,j-1}+a_i\times 10^{j-1})$。

最后答案是 $\min_{i=0}^6\{f_{n,i}\}$。

转移时要注意边界情况。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ALL(x) x.begin(),x.end()
using namespace std;
int id,T,v[10],f[100001][8],len,ans;
vector<int>a;
string s;
int get_pow(int a){
    int ret=1;
    while(a--)
        ret*=10;
    return ret;
}
void Main(){
    a.clear();
    cin>>s;
    for(auto c:s)
        a.push_back(c^48);
    a.push_back(0);
    reverse(ALL(a));//注意从低位开始
    len=s.size();
    for(int i=1;i<=9;i++)
        cin>>v[i];
    memset(f,0x3f,sizeof(f));
    f[1][0]=v[a[1]];
    f[1][1]=a[1];//初始化
    ans=0x3f3f3f3f3f3f3f3fll;
    for(int i=2;i<=len;i++){
        for(int j=0;j<=min(i,7ll);j++){
        	f[i][j]=f[i-1][j]+v[a[i]];
        	if(j!=0)
            	f[i][j]=min(f[i][j],f[i-1][j-1]+get_pow(j-1)*a[i]);//转移
            if(f[i][j]>0x3f3f3f3f3f3f3f3fll)
                f[i][j]=0x3f3f3f3f3f3f3f3fll;
        }
    }
    for(int i=0;i<=min(7ll,len);i++)
        ans=min(ans,f[len][i]);//最终答案
    cout<<ans<<'\n';
    return;
}
signed main(){
    for(cin>>id>>T;T;--T)
        Main();
    return 0;
}
```

---

## 作者：Aegleseeker_ (赞：1)

笑点解析：比赛时睡着了。醒来之后非常恼怒，于是赶紧切了 T1 然后发现其他题都不会。

下面令 $N$ 代表 $n$ 的长度。

一个最暴力的想法是，我们枚举 $n$ 的每一位，有 **用 $v$ 消除** 和 **留到最后** 两种决策，分别对应两种操作。我们可以考虑用 $O(2^N)$ 的复杂度枚举决策，就能拿到 $24$ 分（我没测过所以不太确定）。

然而显然这个做法是不必要的。这道题的突破口在于**数据范围**中 $v_i\le 10^5$。 

这个条件十分有用。你在看到如此庞大的 $n$ 时，会不会想到 $n$ **肯定不能留很多位到最后**？接着你就会想到 $n$ 最后能留多少位？

如果你留了 $x$ 位，那么将其换成用 $v$ 消除，就只需要最多 $10^5\times x$ 的代价。根据 $v_i$ 的范围最后发现最多留 $6$ 位。这大大减少了我们对冗余状态的无效判断。

当然我们还是不可能从 $n$ 中枚举那 $6$ 位，但我们可以枚举这 $6$ 位的数位，即从 $[1,600000]$ 中判断。这样我们的复杂度就降为了 $O(T\times 600000)$，可以通过本题。

至于如何判断一个状态是否合法，**即能否从 $n$ 中提取出一个长度为 $6$ 的子序列与该状态相同**。这个问题非常好做啊，随便记录一下每个数位的出现位置，二分一下即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=600000;
const int M=10;
string s;
int v[M];
long long ans;
vector<int> ind[M];
int cal(int x,int y){ //x的第y位
	int res=1;
	while(y){
		res*=10;
		y--;
	}
	return (x/res)%10;
}
bool check(int x){
	bool flag=0;
	for(int i=5;i>=0;i--){
		int tmp=cal(x,i);
		if(tmp){
			flag=1;
			if(ind[tmp].size()==0){
				return 0;
			}
		}else if(flag){
			return 0;
		}
	}
	return 1;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int c,T;
	cin>>c>>T;
	while(T--){
		cin>>s;
		for(int i=1;i<=9;i++){
			cin>>v[i];
			ind[i].clear();
		}
		long long sum=0;
		for(int i=0;i<s.size();i++){
			sum+=v[s[i]-'0'];
			ind[s[i]-'0'].push_back(i+1);
		}
		ans=0x3f3f3f3f3f3f3f3f;
		for(int state=0;state<=N;state++){
			if(!check(state)){
				continue;
			}
			bool flag=0;
			long long res=0;
			int now=0;
			for(int i=5;i>=0;i--){
				int tmp=cal(state,i);
				if(tmp==0){
					continue;
				}
				res+=v[tmp];
				auto it=upper_bound(ind[tmp].begin(),ind[tmp].end(),now);
				if(it==ind[tmp].end()){
					flag=1;
					break;
				}
				now=ind[tmp][it-ind[tmp].begin()];
			}
			if(!flag){
				ans=min(ans,state+sum-res);
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：gyyyyx (赞：1)

设 $n$ 的长度为 $len$，第 $i$ 位为 $a_i$。

考虑最朴素的 dp：

设 $f_{i,j}$ 表示当前处理完了第 $i\sim len$ 位，剩下了 $j$ 个数位时的最小代价。

对于一个数位 $x$，要么花 $v_x$ 的代价删掉它，要么花 $x\cdot 10^k$ 的代价删掉它。

那么转移就是：

$$f_{i,j}=\min\big(f_{i+1,j}+v_{a_i},f_{i+1,j-1}+10^{j-1}a_i\big)$$

这样是 $O(len^2)$ 的。

我们发现 $v_x\leq 10^5$，因此当 $k>5$ 时必然是用 $v_x$ 删掉数位 $x$ 更优。

这也就是说，最后保留的 $n$ 一定不会超过 $5$ 位。

那么在第二维我们只需要考虑 $0\sim 5$ 即可，时间复杂度 $O(len)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100005
using namespace std;
int t,n,a[N],v[10];
LL pw[5],f[N][6];
inline void read(){
	char c(getchar());n=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') a[++n]=c^48,c=getchar();
}
int main(){
	pw[0]=1;for(int i(1);i<5;++i) pw[i]=pw[i-1]*10;
	scanf("%d",&t);scanf("%d",&t);
	while(t--){
		read();
		for(int i(1);i<10;++i) scanf("%d",&v[i]);
		for(int i(1);i<=5;++i) f[n+1][i]=-1;f[n+1][0]=0;
		for(int i(n);i;--i){
			f[i][0]=f[i+1][0]+v[a[i]];
			for(int j(1);j<=5;++j){
				if(~f[i+1][j]) f[i][j]=min(f[i+1][j]+v[a[i]],f[i+1][j-1]+a[i]*pw[j-1]);
				else if(~f[i+1][j-1]) f[i][j]=f[i+1][j-1]+a[i]*pw[j-1];
				else f[i][j]=-1;
			}
		}
		LL ans(f[1][0]);
		for(int i(1);i<=5;++i)
			if(~f[1][i]) ans=min(ans,f[1][i]);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：yyyx_ (赞：0)

带来一种简单做法。

从题目得到信息：

- 我们不会在长度很大时用 $n$ 的代价去消完整个数串。
- 抛去“用 $n$ 的代价去消完整个数串”这个操作，代价和与操作顺序无关。

于是观察数据范围，我们发现：

- 因为 $v_i\le 5$，所以“用 $n$ 的代价去消完整个数串”这个操作只有在数串长度 $\le 5$ 时才会使得代价变小。
- 总共只有 $9$ 个数字需要枚举，这样枚举 $5$ 个数字的复杂度在 $O(10^5)$ 级别，可以接受。

这样我们只需要考虑最后剩下的**子序列**对减少代价的贡献即可。

因为是子序列，故引入 $nxt_{i,num}$ 表示在字符串第 $i$ 位（包含）后第一个数字 $num$ 的位置，初始 $nxt$ 数组皆为 $-1$，方便判断是否存在合法子序列。

其中预处理 $nxt$ 数组的时间复杂度是 $O(9n)$。

综合时间复杂度为 $O(9n + 10^5)$，空间复杂度在 $O(n)$ 级别。


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
typedef long long ll;

int T, n;
char a[N];
int v[10];
int nxt[N][10];

void init(int x)
{
    char tmp = x + '0';
    for (int i = n; i > 0; i--)
    {
        if (a[i] == tmp)
            nxt[i][x] = i;
        else
            nxt[i][x] = nxt[i + 1][x];
    }
}

signed main()
{
    scanf("%*d%d", &T);
    while (T--)
    {
        scanf("%s", a + 1);
        n = strlen(a + 1);
        for (int i = 1; i < 10; i++)
            scanf("%d", &v[i]);
        memset(nxt, -1, sizeof nxt);
        for (int i = 1; i < 10; i++)
            init(i);
        ll ans = 0, tot = 0;
        for (int i = 1; i <= n; i++)
            tot += v[a[i] - '0'];
        ans = tot;
        for (int i = 1; i < 10; i++)
        {
            int t1 = nxt[1][i];
            if (~t1)
            {
                ans = min(ans, tot - v[i] + i);
                for (int j = 1; j < 10; j++)
                {
                    int t2 = nxt[t1 + 1][j];
                    if (~t2)
                    {
                        ans = min(ans, tot - v[i] - v[j] + i * 10 + j);
                        for (int k = 1; k < 10; k++)
                        {
                            int t3 = nxt[t2 + 1][k];
                            if (~t3)
                            {
                                ans = min(ans, tot - v[i] - v[j] - v[k] + i * 100 + j * 10 + k);
                                for (int l = 1; l < 10; l++)
                                {
                                    int t4 = nxt[t3 + 1][l];
                                    if (~t4)
                                    {
                                        ans = min(ans, tot - v[i] - v[j] - v[k] - v[l] + i * 1000 + j * 100 + k * 10 + l);
                                        for (int r = 1; r < 10; r++)
                                        {
                                            int t5 = nxt[t4 + 1][r];
                                            if (~t5)
                                            {
                                                ans = min(ans, tot - v[i] - v[j] - v[k] - v[l] - v[r] + i * 10000 + j * 1000 + k * 100 + l * 10 + r);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        printf("%lld\n", ans);
    }

    return 0;
}
```

可以说是相当简单的一道小思维题。

[跑得飞快](https://www.luogu.com.cn/record/181853471)

---

## 作者：xiezheyuan (赞：0)

## 思路

首先考虑一个引理：执行第二个操作的时候，$n$ 一定小于等于 $9\times 10^5$。

证明也很简单，如果 $n>9\times 10^5$，那我们不如逐位删除它。

于是我们可以暴力枚举剩下来的 $n$，考虑验证 $n$ 是否可以剩下来，那么充要条件就是为原先 $n$ 的一个子序列，可以建立子序列自动机维护。

时间复杂度单组数据 $O(10a_in)$。

当然你也可以用 dp 去替代暴力枚举的过程，可以做到更优的时间复杂度。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 5;
int n, nxt[N][15], a[15];
string s;

void solve(){
    cin >> s; n = s.size(); s = " " + s;
    for(int i=n;i;i--){
        for(int j=0;j<10;j++) nxt[i - 1][j] = nxt[i][j];
        nxt[i - 1][s[i] - '0'] = i;
    }
    for(int i=1;i<=9;i++) cin >> a[i];
    int ans, total = 0;
    for(int i=1;i<=n;i++) total += a[s[i] - '0'];
    ans = total;
    for(int i=0;i<=(int)(9e5);i++){
        string tmp = to_string(i);
        bool flag = 0; int cur = 0;
        for(char i : tmp){
            if(nxt[cur][i - '0'] == 0){
                flag = 1;
                break;
            }
            cur = nxt[cur][i - '0'];
        }
        if(flag) continue;
        int ret = total + i;
        for(char i : tmp) ret -= a[i - '0'];
        ans = min(ans, ret);
    }
    cout << ans << '\n';
}

void clear(){
    for(int i=0;i<=(n + 1);i++){
        for(int j=0;j<10;j++) nxt[i][j] = 0;
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int tid, t; cin >> tid >> t;
    while(t--) solve(), clear(); 
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：qfy123 (赞：0)

# P11188
[传送门](https://www.luogu.com.cn/problem/P11188)
## Solution
注：记 $\lvert A \rvert$ 为**数** $A$ 的长度。

先进行简单的观察，不难发现以下两个事实：
1. 假设最后要进行一次操作 $2$，那在执行操作 $2$ 之前删剩下的数一定是原数的子序列。
2. $\lvert v_i \rvert$ 很小，最多只有 $6$，因此只有在原数 $n$ 删到 $\lvert n \rvert \leq 6$ 的时候才有可能进行操作 $2$。

根据以上的观察，以下提供 DP 和非 DP 两种做法。
### DP
发现假设要进行操作 $2$ 的话，要保留的数字个数非常少。那么不妨设 $f_{i,j}$ 为考虑前 $i$ 个数，保留 $j$ 个数位来进行操作 $2$ 的最小**总**代价。正着 dp 的时候，一种显然的想法是，保留当前长度下最优的解的同时进行转移，但是，这种做法是具有后效性的。

那怎么办？把输入的 $n$ 倒过来就可以了！倒着 dp 的时候，由于取出的子序列是由低位到高位排列的，因此每位的贡献是独立的，即加上当前位乘 $10^{j-1}$，这样，就没有后效性了。由此不难得出转移方程：
$$f_{i,j} = \begin{cases} f_{i-1,j} + v_{n_i}& j = 0 \\  \min(f_{i-1,j} + v_{n_i}, f_{i-1,j-1} + 10^{j-1} \times n_i) & j > 0\\
\end{cases} $$
注：此时的 $n$ **已经倒过来了**。

简要解释一下：当 $j = 0$ 的时候，即不保留任何数，那么只能通过操作 $1$ 来删数。当 $j > 0$ 时，可以选择不保留这一位，可以选择保留这一位，分别代表 $f_{i-1,j} + v_{n_i}$ 和 $f_{i-1,j-1} + 10^{j-1} \times n_i$。

最后，由于最多只保留 $6$ 位，答案就是：
$$\min_{j=0}^6 f_{\lvert n \rvert,j}$$
### Code
```cpp
#include<bits/stdc++.h>
#define int long long 
#define ull unsigned long long
#define ri register int
#define rep(i,j,k) for(ri i=(j);i<=(k);++i) 
#define per(i,j,k) for(ri i=(j);i>=(k);--i)
#define repl(i,j,k,l) for(ri i=(j);(k);i=(l))
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pc(x) putchar(x)
#define fir first
#define se second 
#define MP pair<int,int>
#define PB push_back
#define lson p << 1
#define rson p << 1 | 1
using namespace std;
char BUFFER[100000],*P1(0),*P2(0);
#define gtc() (P1 == P2 && (P2 = (P1 = BUFFER) + fread(BUFFER,1,100000,stdin), P1 == P2) ? EOF : *P1++)
inline int R(){
    int x;char c;bool f = 0;
	while((c = gtc()) < '0') if(c == '-') f = 1;
	x = c ^ '0';
	while((c = gtc()) >= '0') x = (x << 3) + (x << 1) + (c ^ '0');
	return f?(~x + 1):x;
}
inline void O(int x){
    if(x < 0) pc('-'),x = -x;
    if(x < 10) pc(x + '0');
    else O(x / 10),pc(x % 10 + '0');
}
inline void out(int x,int type){
	if(type == 1) O(x),pc(' ');
	if(type == 2) O(x),pc('\n');
	if(type == 3) O(x);
}
inline void OI(){
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
}
const int N = 1e5 + 10;
char s[N];
int f[N][7], n, v[10], pw[10];
inline void init(){
  	memset(f, 0x3f, sizeof(f));
}
inline void solve(){
    init();
  	cin >> (s + 1);
  	n = strlen(s + 1);
  	reverse(s + 1, s + n + 1);//先将 n 倒过来
  	rep(i, 1, 9) cin >> v[i];
  	f[0][0] = 0;
  	rep(i, 1, n){
  		rep(j, 0, 6){
  			f[i][j] = f[i - 1][j] + v[s[i] - '0'];
  			if(j > 0) f[i][j] = min(f[i][j], f[i - 1][j - 1] + pw[j - 1] * (s[i] - '0'));
  		}
  	}
  	int ans = 1e18;
  	rep(i, 0, 6) ans = min(ans, f[n][i]);//一定注意要取到 f[n][0]，因为可以不进行操作 2
  	cout << ans << '\n';
}
signed main(){
    // OI();
    // int T = 1;
    // T = R();
    
    IOS;int T = 1;
    int useless; cin >> useless;
    pw[0] = 1;
    rep(i, 1, 6) pw[i] = pw[i - 1] * 10;
    cin >> T;
	while(T--) solve();
	return 0;
}


```
### 非 DP
发现最后删剩下来的数的可能性很少，于是直接暴力枚举最后的状态，要保险的话枚举 $10^6$ 次差不多了。然后判断这个状态是否是能够通过删掉 $n$ 的一些数来达到（即判断这个最终状态是否是 $n$ 的子序列）。如果可以，计算删到这个状态的贡献，与 $ans$ 取最小值即可。

讲讲如何实现：定义 $pre_{i,j}$ 表示第 $i$ 个数向前的最近一个数位 $j$ 的位置，$lst_i$ 表示第 $i$ 个数位最后一次出现的位置，$buc_i$ 表示第 $i$ 个数位在 $n$ 中的出现次数。先把这些数组都预处理出来。

预处理 $pre$ 数组时，令 $\forall i \in [2,\lvert n \rvert],j \in [1,9]$，使 $p_{i,j} \gets p_{i-1,j}$ 且 $p_{i,a_{i-1}} \gets i - 1$。之后，每次枚举到一个进行操作 $2$ 前的状态 $now$，先令 $nxt \gets lst_{now \bmod 10}$，每次让 $nxt$ 向前跳（详见代码），在跳的同时计算这个状态的各个数位的出现次数 $cnt_{1...9}$。如果最后 $nxt = 0$，就说明不可能通过操作 $1$ 删成这个状态。否则就计算一次贡献：$\sum_{i = 1} ^ {9} (buc_i - cnt_i) \times v_i + now$，前半部分是操作 $1$ 的总代价，$now$ 是操作 $2$ 的总代价。

UPD：经过某位大佬的提醒，我上面说的一大段预处理 $pre$ 数组，以及让 $nxt$ 向前跳的处理方法，其实和[子序列自动机](https://www.luogu.com.cn/problem/P5826)的处理方法是差不多的。

注意：最终答案可能**不需要**进行操作 $2$，因此还要算一遍只用操作 $1$ 删数的代价，与 $ans$ 再取一次最小值。
### Code
```cpp
#include<bits/stdc++.h>
#define int long long 
#define ull unsigned long long
#define ri register int
#define rep(i,j,k) for(ri i=(j);i<=(k);++i) 
#define per(i,j,k) for(ri i=(j);i>=(k);--i)
#define repl(i,j,k,l) for(ri i=(j);(k);i=(l))
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define pc(x) putchar(x)
#define fir first
#define se second 
#define MP pair<int,int>
#define PB push_back
#define lson p << 1
#define rson p << 1 | 1
using namespace std;
char BUFFER[100000],*P1(0),*P2(0);
#define gtc() (P1 == P2 && (P2 = (P1 = BUFFER) + fread(BUFFER,1,100000,stdin), P1 == P2) ? EOF : *P1++)
inline int R(){
    int x;char c;bool f = 0;
	while((c = gtc()) < '0') if(c == '-') f = 1;
	x = c ^ '0';
	while((c = gtc()) >= '0') x = (x << 3) + (x << 1) + (c ^ '0');
	return f?(~x + 1):x;
}
inline void O(int x){
    if(x < 0) pc('-'),x = -x;
    if(x < 10) pc(x + '0');
    else O(x / 10),pc(x % 10 + '0');
}
inline void out(int x,int type){
	if(type == 1) O(x),pc(' ');
	if(type == 2) O(x),pc('\n');
	if(type == 3) O(x);
}
inline void OI(){
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
}
const int N = 1e5 + 10;
const int M = 15;
char s[N];
int v[M], T, n, p[N][M], l[M], buc[M], a[N], cnt[M], ans;
inline void init(){
	memset(p, 0, sizeof(p));
	memset(l, 0, sizeof(l));
	memset(buc, 0, sizeof(buc));
	ans = 1e12;
}
inline void solve(){
	init();
	cin >> (s + 1);
	n = strlen(s + 1);
	rep(i, 1, n) a[i] = s[i] - '0';
	int mxv = 0;
	rep(i, 1, 9) cin >> v[i], mxv = max(mxv, v[i]);
	rep(i, 1, n) buc[a[i]]++, l[a[i]] = i;
	rep(i, 2, n){
		rep(j, 1, 9) p[i][j] = p[i - 1][j];
		p[i][a[i - 1]] = i - 1;
	}
	rep(i, 1, 1e6){
		int tmp = i, nxt = l[tmp % 10];
		memset(cnt, 0, sizeof(cnt));
		while(tmp) ++cnt[tmp % 10], tmp /= 10; 		
		tmp = i;
		while(tmp){
			tmp /= 10;
			if(!tmp) break;
			nxt = p[nxt][tmp % 10];
    //每次取到枚举出的状态的前一位，记为 x，然后跳到 n 的第 1...nxt 位中，距离 nxt 最近的且值为 x 的数位。
		}
		if(!nxt) continue;//若 nxt = 0，说明该状态不是 n 的子序列
		int tot = 0;
		rep(j, 1, 9) tot += (buc[j] - cnt[j]) * v[j];
        ans = min(ans, tot + i);
	}
	int ans2 = 0;
	rep(i, 1, n) ans2 += v[s[i] - '0'];
	cout << min(ans, ans2) << '\n';
}
signed main(){
    // OI();
    // int T = 1;
    // T = R();

    IOS;int T = 1;
    int useless; cin >> useless;
    cin >> T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：2020kanade (赞：0)

首先这题有个结论：最终一次删光时的 $n$ 位数不会超过 $5$。

简要证明一下：我们将操作二的一次删完视作一次必定执行的操作 $1$，即使把操作 $1$ 的单次代价去卡到上界，我们用操作 $1$ 删数也可以把这最后一次操作的代价降低到之前的十分之一。

列个不等式就明白，只有把最后一次的代价砍到操作 $1$ 的单次代价的上界，才能确保不劣，后者最多是 $V=99999$。

发现操作 $1$ 的代价只与值而不是位置相关，这样我们预处理一下这个数所有的数字的价值和就可以求出最终操作 $2$ 对某个数执行的时候之前操作 $1$ 的代价之和。

我们考虑暴力枚举所有可能性，注意到这不到 $99999$ 个数里合法的数必须是原数的一个子序列，考虑建一个简单的子序列自动机，对枚举到的数进行匹配即可验证合法性。

时间复杂度 $\Theta(T(|\sum|V+|\sum|\log_{10}n))$，此处 $|\sum|=9$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+11;
using ll=long long;
ll nxt[N][10],a[N],val[N],v[10],last[10];
ll qp(ll x,int y)
{
	if(!y) return 1;
	ll ret=qp(x,y/2);
	if(y&1) ret*=x;return ret;
}
const ll inf=1e18;int n;
void c0nst(int _n)
{
    for(int i=1;i<=9;++i) last[i]=n+1;
    for(int i=n;i>=0;--i)
    {
        for(int j=1;j<=9;++j) nxt[i][j]=last[j];
        last[a[i]]=i;  
    }
}
bool chk(string s)
{
    int k=s.length();
    int u=0;bool ok=1;
    for(auto x:s)
    {
        int _x=x-'0';
        u=nxt[u][_x];
		if(u>=n+1)
        {
            ok=0;break;
        }
    }
    return ok;
}
void solve()
{
	//cin>>n;
    ll pans=0;
    string fuck;cin>>fuck;n=fuck.length();//cout<<fuck<<endl;
	for(int i=1;i<=n;++i) a[i]=fuck[i-1]-'0';
	for(int i=1;i<=9;++i) cin>>v[i];
	for(int i=1;i<=n;++i) val[i]=v[a[i]],pans+=val[i];
    ll ans=pans;c0nst(n);int mx=atoi(fuck.c_str());
    //cout<<mx<<endl;
	for(int i=1;i<=99999;++i)
    {
        string ss=to_string(i);
        bool ok=1;
        for(auto x:ss) if(x=='0')
        {
            ok=0;break;
        }
        ok&=chk(ss);
        if(!ok) continue;
        ll qans=pans;
        for(auto x:ss)
        {
            int _x=x-'0';
            qans-=v[_x];        
        }
        qans+=i;
        ans=min(ans,qans);
    }
	cout<<ans<<endl;
	for(int i=0;i<=n;++i) for(int j=0;j<=9;++j) nxt[i][j]=0;
}
int main()
{
	int ccf,t;
	cin>>ccf>>t;
	while(t--) solve();
	return 0;
}
/*
0
3
123
10 10 10 10 10 10 10 10 10 
1121
2 1 2 2 2 2 2 2 2
987654321
1 2 3 4 5 6 7 8 9

1
1
12
99999 99999 99999 99999 99999 99999 99999 99999 99999


21
6
45
*/
```

---

## 作者：Eric159357 (赞：0)

首先可以发现：最后用操作二删掉的所有数可以看作原数的一个子序列，且由数据范围可知，最后剩余的数不会多于 $6$ 个。

虽然我们不知道最后会留下多少个数，但是对于一个数位，如果单独删去，代价为 $v_{i}$；如果最后统一删去，则这一位的代价可看作 $i \times 10^k$。这启示我们可以对于每一个数位，单独考虑删去它的代价是多少。

按照子序列的惯例，我们设 $dp_{i,j}$ 表示考虑了从第 $i$ 个数到第 $n$ 个数，第 $i$ 个数是最后子序列的 $j$ 位的情况下，最小代价是多少。

设 $s_{i}$ 表示分别单独删去 $1$ 至 $i$ 中的每一位所需的代价，则有

$$
dp_{i,j} = \min_{k=i+1}^{n}{(dp_{k,j-1}+s_{k-1}-s_{i}+a_{i} \times10^j)}
$$

从后往前转移是因为这样可以用 $j-1$ 去更新 $j$，理解起来更自然。

该 dp 可以进一步优化。不妨令 $m_{j}$ 表示之前的所有 $i$ 中，最小的 $dp_{i,j}+s_{i-1}$，则 dp 方程变为 $dp_{i,j} = m_{j-1}-s_{i}+a_{i}\times10^{j-1}$，在转移时不断用新算出的 dp 值更新 $m_{j}$，即可通过本题。

注意：不一定需要用到操作二，需特判每一位都被单独删去的情况。

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#define ll long long
#define MAXN 100050
#define INF (ll)(1e16)
using namespace std;
string s;
ll v[10],sum[MAXN],dp[MAXN][10],mi[10];

void solve()
{
    ll ans=INF;
    cin>>s;
    int n=s.length();
    s=' '+s;
    for (int i=1;i<=9;i++) cin>>v[i];
    for (int i=1;i<=n;i++) sum[i] = sum[i-1] + v[s[i]-'0'];
    for (int i=1;i<=n;i++)
    {
        dp[i][0] = (s[i]-'0')+sum[n]-sum[i]; //初始化
        ans=min(ans,dp[i][0]+sum[i-1]); //用只删一位的代价更新最终答案
    }

    for (int i=1;i<=n;i++)
        for (int j=1;j<=5;j++)
            dp[i][j]=INF;

    mi[0]=(s[n]-'0')+sum[n-1]; //初始化mi[0]
    for (int i=1;i<=5;i++) mi[i]=INF; //此时还未考虑任何数位，因此设为INF

    for (int i=n-1;i>=1;i--)
    {
        ll dig=10;
        for (int j=1;j<=5;j++)
        {
            dp[i][j] = mi[j-1]-sum[i]+(s[i]-'0')*dig;
            dig*=10;
            ans=min(ans,dp[i][j]+sum[i-1]);
        }
        for (int j=0;j<=5;j++) mi[j]=min(mi[j],dp[i][j]+sum[i-1]); //维护mi[]
    }
    cout<<min(ans,sum[n])<<endl; //特判
}

int main()
{
    int t,testord;
    cin>>testord>>t;
    while (t--) solve();
    return 0;
}
```

---

## 作者：Hootime (赞：0)

_[Hootime](https://www.luogu.com.cn/user/1275540)：你赛时做出来了吗？我写了两个小时然后 WA 0%……\
[yuruilin2026](https://www.luogu.com.cn/user/1294410)：我要写作业，没办法打比赛……_

## 题意
有一个整数 $n(n\le10^{10^6})$，要求将其完全删除。有以下两种删除操作：
- 花费 $v_i$ 的代价删除一个数 $i$，删除后 $n$ 的值发生改变；
- 花费 $n$ 的代价将数字完全删除。

## 思路
其实这道题远没有很多选手想象得那么复杂，作为 T1，这道题是一个超级大枚举。

首先我们可以发现 $v_i\le10^5$，也就是说当 $n>10^6$ 时，第一种操作总是比第二种操作实惠。所以我们可以在 $n>10^6$ 时一直进行第一种操作。自然地，很多人（包括赛时的我）都想到了从初态向下推的 DP，但是，既然 DP 那么麻烦，我们何不枚举终态（小于 $10^6$，不会 TLE）然后推过程呢？

### 判断可行性
一个数位小于五的数可以被 $n$ 推出来，当且仅当这个数是 $n$ 的子串。但是 $n$ 太长了，直接暴力可能会 TLE。

于是我们先求出原数和枚举到的数中每个数字出现的个数，如果枚举到的数中有一个或多个数位的出现次数大于原数，那么可以直接判错。

然后我们用 STL set 存储原数中每个数字出现数位，在判断时直接匹配，如果匹配不上，可以直接判错。

如果一个数通过了这两轮测试，那么可以证明这个数是原数的子串。

初始化时间复杂度为 $O(k)$，$k$ 指数字串的长度。

单次判断时间复杂度为 $O(\log k)$。

### 计算花费
我们认为整个操作流程就是很多次操作一和一次操作二，那么花费也就是这两种花费的和。

操作二的花费很好计算，就是枚举到的数。

操作一的花费也比较好计算，计算出数字 $i$ 被删除的次数，乘上 $v_i$ 即可。

时间复杂度为 $O(1)$。

综上，整个算法的时间复杂度为 $O(k)$。

## 代码
### 注释版
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
char str[100005];
set<int> s[15];
int n;
int c[15], v[15], cnt, num[15], cntn[25];
int tskn, tn;
void prework(int a, int b, int c, int d, int e); // 预处理 
bool is_exist(); // 判断是否符合条件 
inline int solve(); // 解出答案 
signed main(){
    scanf("%lld", &tskn);
    scanf("%lld", &tn);
    while(tn--){
        int ans = LLONG_MAX;
        memset(c, 0, sizeof(c));
        for(int i = 0; i <= 9; i++) s[i].clear();
        scanf("%s", str+1);
        n = strlen(str+1);
        for(int i = 1; i <= n; i++){
            c[str[i]-'0']++, s[str[i]-'0'].insert(i); // 记录数字出现的次数和位置 
        }
        for(int i = 1; i <= 9; i++) scanf("%lld", &v[i]);
        for(int a = 0; a <= 9; a++){ // 超 
            for(int b = 0; b <= 9; b++){ // 级 
                for(int c = 0; c <= 9; c++){ // 大 
                    for(int d = 0; d <= 9; d++){ // 枚 
                        for(int e = 0; e <= 9; e++){ // 举 
                            prework(a, b, c, d, e); // 预处理每个被留下的五位数的情况 
                            if(is_exist()){ // 如果这个五位数是原数的子串 
                                ans = min(ans, solve()); // 更新答案 
                            }
                        }
                    }
                }
            }
        }
        printf("%lld\n", ans);
    }
}
void prework(int a, int b, int c, int d, int e){
    cnt = 0;
    memset(cntn, 0, sizeof(cntn));
    if(a) num[++cnt] = a; // 去前导零，下同 
    if(b) num[++cnt] = b;
    if(c) num[++cnt] = c;
    if(d) num[++cnt] = d;
    if(e) num[++cnt] = e;
    for(int i = 1; i <= cnt; i++) cntn[num[i]]++; // 统计数字在五位数中的出现次数 
}
bool is_exist(){
	for(int i = 1; i <= 9; i++) if(cntn[i] > c[i]) return false; // 如果五位数中的某个数字出现次数大于原数，那么直接判断 
	int tot = 0;
	for(int i = 1; i <= cnt; i++){
		if(tot >= *s[num[i]].rbegin()) return false; // 如果该数字最后一次出现早于现在枚举到的位置，直接判断 
		tot = *s[num[i]].upper_bound(tot); // 跳到该数字出现的位置 
	}
	return true;
}
inline int solve(){
	int ans = 0;
	for(int i = 1; i <= cnt; i++) ans = ans*10+num[i]; // 加上剩下的五位数 
	for(int i = 1; i <= 9; i++) ans += v[i]*(c[i]-cntn[i]); // 加上被抹除的数字 
	return ans;
}
```

### 细节
- 在 `is_exist` 函数中判断数字最后一次出现早于现在枚举到的位置必须写 `tot >= *s[num[i]].rbegin()` 而不是 `tot > *s[num[i]].rbegin()`，否则会导致 [WA](https://www.luogu.com.cn/record/182122111)。

### 无注释纯享
_请不要复制代码。_
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
char str[100005];
set<int> s[15];
int n;
int c[15], v[15], cnt, num[15], cntn[25];
int tskn, tn;
void prework(int a, int b, int c, int d, int e);
bool is_exist();
inline int solve();
signed main(){
    scanf("%lld", &tskn);
    scanf("%lld", &tn);
    while(tn--){
        int ans = LLONG_MAX;
        memset(c, 0, sizeof(c));
        for(int i = 0; i <= 9; i++) s[i].clear();
        scanf("%s", str+1);
        n = strlen(str+1);
        for(int i = 1; i <= n; i++){
            c[str[i]-'0']++, s[str[i]-'0'].insert(i);
        }
        for(int i = 1; i <= 9; i++) scanf("%lld", &v[i]);
        for(int a = 0; a <= 9; a++){
            for(int b = 0; b <= 9; b++){
                for(int c = 0; c <= 9; c++){
                    for(int d = 0; d <= 9; d++){
                        for(int e = 0; e <= 9; e++){
                            prework(a, b, c, d, e);
                            if(is_exist()){
                                ans = min(ans, solve());
                            }
                        }
                    }
                }
            }
        }
        printf("%lld\n", ans);
    }
}
void prework(int a, int b, int c, int d, int e){
    cnt = 0;
    memset(cntn, 0, sizeof(cntn));
    if(a) num[++cnt] = a;
    if(b) num[++cnt] = b;
    if(c) num[++cnt] = c;
    if(d) num[++cnt] = d;
    if(e) num[++cnt] = e;
    for(int i = 1; i <= cnt; i++) cntn[num[i]]++;
}
bool is_exist(){
	for(int i = 1; i <= 9; i++) if(cntn[i] > c[i]) return false;
	int tot = 0;
	for(int i = 1; i <= cnt; i++){
		if(tot >= *s[num[i]].rbegin()) return false;
		tot = *s[num[i]].upper_bound(tot);
	}
	return true;
}
inline int solve(){
	int ans = 0;
	for(int i = 1; i <= cnt; i++) ans = ans*10+num[i];
	for(int i = 1; i <= 9; i++) ans += v[i]*(c[i]-cntn[i]);
	return ans;
}
```

---


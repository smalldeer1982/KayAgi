# 神奇的小江鸟

## 题目背景

You can also see the pdf at the bottom of the chinese problem statement.

感谢 [ineverleft](https://www.luogu.com.cn/user/362679) 为本题提供的本地调试 checker。

「愿有前程可奔赴，亦有岁月可回首。」

## 题目描述

小 $ \zeta $ 在探险过程中看到了一个大锁。

这个大锁有 $ n $ 个拨圈，第 $ i $ 个拨圈的拨动范围为 $ l_i $ 到 $ r_i $ 之间（含两个边界）的所有整数（保证 $ l_i \le r_i $）。

我们定义这个大锁的「自由度」为所有拨圈上的数的**最大公约数**，当锁的「自由度」大于等于 $ k $ 时，会被打开。

请你找到一种锁的开启方案，或报告无解。

## 说明/提示

**【样例 1 解释】**

唯一的一组数据 $ \gcd $ 为 $ 10 $。

五个样例自测均可使用下发的附件。**请注意部分样例可能存在多解，样例输出仅列举了一组可行解。**

**【数据规模与约定】**

对于 $ 100\% $ 的数据，$ 1 \le T \le 5 $，$ 2 \le n \le 10^4 $，$ 1 \le l_i \le r_i \le 10^9 $，$ 1 \le k \le 1000 $。

**本题开启子任务捆绑测试。**

* Subtask 1（10 pts）：$ k=1 $。
* Subtask 2（15 pts）：$ n \le 10 $，$ r_i - l_i + 1 \le 5 $。
* Subtask 3（15 pts）：$ r_i \le 10^3 $。
* Subtask 4（10 pts）：$ k \le 5 $，$ l_i,r_i $ 均在 $ 1 \le l_i \le r_i \le 10^9 $ 范围内等概率随机生成，该子任务只有 $ 1 $ 个测试点。
* Subtask 5（15 pts）：对于每组数据，$ \exist 1 \le i \le n,l_i=r_i $。
* Subtask 6（35 pts）：无特殊限制。

**【关于附加文件】**

**本题下发了 `checker.cpp` 作为自测器。**

请将输入内容、你的程序输出、参考答案输出分别放置在 `restore.in`、`restore.out`、`restore.ans` 中，这三个文件必须与 `checker.cpp` 在同一目录下，运行 `checker.cpp`，终端上会给出自测结果。

**你需要保证你的输入满足 $ 100\% $ 数据范围的要求。**

注意，如果你的输入/输出/答案的格式和范围不正确的话，`checker.cpp` 出现的结果是不可预料的。因此，**请先确保你的三个文件格式正确。**

## 样例 #1

### 输入

```
1
5 10
1 12
44 50
9 10
88 99
29 99```

### 输出

```
Yes
10 50 10 90 30```

## 样例 #2

### 输入

```
2
3 11
99 10003
39 299
39 10003
5 55
1 54
1 20
1 300
1 300
1 300```

### 输出

```
Yes
123 246 369
No```

## 样例 #3

### 输入

```
3
6 1
1 10
1 10
1 10
1 10
1 10
1 10
5 4
11 15
6 10
9 14
20 23
27 29
5 11
20 30
50 70
111 120
72 77
119 121```

### 输出

```
Yes
1 1 4 5 1 4
Yes
14 7 14 21 28
Yes
24 60 120 72 120```

## 样例 #4

### 输入

```
4
3 33
32 34
65 67
97 101
3 5
299 99494993
499 49992999
499 39999939
4 25
719 830
2194 2893
132 142
199 225
3 10
140 143
131 135
238 241```

### 输出

```
Yes
33 66 99
Yes
1919810 11400 51400
Yes
729 2700 135 216
No```

## 样例 #5

### 输入

```
1
10 7
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174```

### 输出

```
Yes
77 154 77 154 77 154 77 154 77 154```

# 题解

## 作者：Austin0116 (赞：28)

# 分析

~~首先我们发扬人类智慧~~

感觉最大公因数不会太大，所以直接从 $k$ 枚举到 $10^6$ ，判断每个区间是否符合，在未加强数据时，这个代码可以得到 $100$ 分的好成绩。

贴一下主要部分的代码。


```cpp
for(int i=k;i<=1000000;i++){
  fl=0;
  for(int j=2;j<=n;j++) if(a[j].x>a[j].y||(a[j].x%i&&a[j].y%i&&a[j].x/i==a[j].y/i)){
    fl=1;//有区间不符合条件
    break;
  }
  if(!fl){//所有区间符合条件直接统计答案
    c.clear();
    puts("Yes");
    for(int j=1;j<=n;j++) c.push_back((a[j].x/i+(bool)(a[j].x%i))*i);
    for(int x:c) printf("%d ",x);
    putchar('\n');
    break;
  } 	
}
```

但是加强数据后只能获得 $65$ 分，我们考虑如何~~继续发扬人类智慧~~。

我们可以猜测由于答案比较大，所以每个区间都比较分散，所以可以从选择一个最小的右端点,枚举 $k$ 到这个右段点的每一个数，然后判断每个区间是否符合，最后可以获得 $85$ 分的好成绩。

贴一下重点代码。


```cpp
struct ha{
	int x,y,id;
};
ha a[10005];
inline bool cmp1(ha &a,ha &b){
	return a.y<b.y;
}
inline bool cmp2(ha &a,ha &b){
	return a.id<b.id;
}
sort(a+1,a+1+n,cmp1);
if(a[n].x>a[n].y){//特判
  puts("No");
  continue;
}
fl=1;
for(int i=k;i<=a[1].y;i++){
  fl=0;
  for(int j=1;j<=n;j++) if((a[j].x%i&&a[j].y%i&&a[j].x/i==a[j].y/i)){
    fl=1;//不符合条件
    break;
  }
  if(!fl){//符合条件
    c.clear();
    puts("Yes");
    sort(a+1,a+1+n,cmp2);
    for(int j=1;j<=n;j++) c.push_back((a[j].x/i+(bool)(a[j].x%i))*i);
    for(int x:c) printf("%d ",x);
    putchar('\n');
    break;
  } 
}
if(fl) puts("No");
```

我们~~继续发扬人类智慧~~。

由于只有一个点错了，而且这个点是 Subtask 2 的原来能过的点，所以我们只需要进行数据分治： $n \le 10$ 用第一种方法，剩下情况用第二种方法。

# AC 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
struct ha{
	int x,y,id;
};
ha a[10005];
inline bool cmp1(ha &a,ha &b){
	return a.y<b.y;
}
inline bool cmp2(ha &a,ha &b){
	return a.id<b.id;
}
int t,n,k;
bool fl;
vector<int> c;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&k);
		for(int i=1;i<=n;i++){
			scanf("%d%d",&a[i].x,&a[i].y);
			a[i].id=i;
			a[i].x=max(a[i].x,k); 
		} 
		if(n<=10){
			for(int i=k;i<=1000000;i++){
				fl=0;
				for(int j=2;j<=n;j++) if(a[j].x>a[j].y||(a[j].x%i&&a[j].y%i&&a[j].x/i==a[j].y/i)){
					fl=1;
					break;
				}
				if(!fl){
					c.clear();
					puts("Yes");
					for(int j=1;j<=n;j++) c.push_back((a[j].x/i+(bool)(a[j].x%i))*i);
					for(int x:c) printf("%d ",x);
					putchar('\n');
					break;
				} 	
			}
			if(fl) puts("No");
		}
		else{
			sort(a+1,a+1+n,cmp1);
			if(a[n].x>a[n].y){
				puts("No");
				continue;
			}
            fl=1;
			for(int i=k;i<=a[1].y;i++){
				fl=0;
				for(int j=1;j<=n;j++) if((a[j].x%i&&a[j].y%i&&a[j].x/i==a[j].y/i)){
					fl=1;
					break;
				}
				if(!fl){
					c.clear();
					puts("Yes");
					sort(a+1,a+1+n,cmp2);
					for(int j=1;j<=n;j++) c.push_back((a[j].x/i+(bool)(a[j].x%i))*i);
					for(int x:c) printf("%d ",x);
					putchar('\n');
					break;
				} 
			}
			if(fl) puts("No");	
		}
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：24)

# T5. restore

## 题意回顾

$ n $ 个区间，每个区间取一个数，要求这些数的 $ \gcd $ 大于等于给定的 $ k $。

**多测，单测试点内最多 $ 5 $ 组数据。$ 1 \le n \le 10^4 $**，$ 1 \le k \le 1000 $，值域不超过 $ 10^9 $。

## 分析

### 区间都很长的情况

设所有区间长度大于等于 $ k $，显然每个区间都至少包含一个 $ k $ 的倍数，因此易得解。

### 存在短区间的情况

我们可以在线性时间内核验一个数可不可以作为这个序列的 $ \gcd $。

对于最短区间的所有最多 $ k-1 $ 个数，找到这些数的所有因数，把他们排序之后从小到大依次核验即可。

单组数据的理论复杂度上界为 $ O(k\sqrt{V}+nk \log V) $（$ V=10^9 $ 为值域）。

## 标程

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <utility> 
#include <set>
using namespace std;
const int N = 1e5 + 5;
int T;
int n, k;
pair<int, int> rq[N], rn[N];
bool cmp(pair<int, int> p1, pair<int, int> p2) {
	int lx = p1.second - p1.first + 1;
	int ly = p2.second - p2.first + 1;
	if(lx != ly) return lx < ly;
	return p1.first < p2.first; 
}
inline int chk(int x, int i) {
	int ret = (rn[i].first - 1) / x * x + x;
	return (ret > rn[i].second) ? -1 : ret;
}
inline bool judg(int x) {
	for(int i = 1; i <= n; i++) {
		if(chk(x, i) == -1) return false;
	}
	return true;
}
inline void out(int x) {
	puts("Yes");
	for(int i = 1; i <= n; i++) {
		rn[i] = rq[i];
		printf("%d", chk(x, i));
		if(i < n) printf(" ");
	}
	puts("");
}
int main() {
	scanf("%d", &T);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d%d", &n, &k);
		for(int i = 1; i <= n; i++) scanf("%d%d", &rn[i].first, &rn[i].second), rq[i] = rn[i];
		sort(rn + 1, rn + n + 1, cmp);
		if(rn[1].second - rn[1].first + 1 >= k) out(k);
		else {
			set<int> se;
			se.clear();
			for(int i = rn[1].first; i <= rn[1].second; i++) {
				for(int j = 1; j * j <= i; j++) {
					if(i % j == 0) {
						if(j >= k) se.insert(j);
						if(i / j >= k) se.insert(i / j);
					}
				}
			}
			int ans = -1;
			for(set<int>::iterator it = se.begin(); it != se.end(); it++) {
				if(judg(*it)) {
					ans = *it;
					break;
				}
			}
			if(ans == -1) puts("No");
			else out(ans);
		}
	}
	return 0;
}
```

## 复杂度证明

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 5e8 + 5;
const int mod = 1e9 + 7;
int a[N];
int main() {
    for(int i = 1; i <= 5e8; i++) {
        if(i % (int)1e6 == 0) {
            cout << i << endl;
        }
        for(int j = i; j <= 5e8; j += i) a[j]++;
    }
    for(int i = 1; i <= 5e8; i++) {
        a[i] = (a[i - 1] + a[i]) % mod;
    }
    int ans = 0;
    for(int i = 5000; i <= 5e8; i++) {
        ans = max(ans, (a[i] - a[i - 1000] + mod) % mod);
    }
    cout << ans << endl;
    return 0;
}

```

输出为 $ 22411 $，则可以认为 $ 10^9 $ 内连续 $ 10^3 $ 个数因数个数在 $ 4 \times 10^4 $ 量级内，运算次数为 $ 2 \times 10^9 $，显然跑不满。

---

## 作者：LinkCatTree (赞：11)

其他大神的正解写的很好，我特此来发一篇乱搞做法。

本题解只作参考，主要指出骗分的方法和为什么乱搞做法通过率高（并给出一个乱搞做法），**并不是**实际意义上的正确做法。（但还是求管理员大大给过 QAQ）

赛时一个一个 subtask 骗分，骗着骗着就 AC 了，感觉好激动。本篇乱搞做法就围绕各 subtask 展开。

# subtask 1

$k=1$ 时，由于任意两数的最大公约数至少为 $l$，所以肯定有解并随意输出区间中的数即可。

# subtask 2

观察到 $n$ 和锁圈的拨动范围极小，直接暴力 dfs 即可。

# subtask 3

直接枚举最大公约数，$\mathcal{O}(n)$ 判断是否可行，由于最大公约数肯定不超过 $\min_{i=1}^n r_i$，所以时间复杂度是可接受的。

# subtask 4

由于 $l,r$ 随机生成，所以其间包含的数期望会比较多，又因为 $k$ 比较小，大概率有解，直接计算任意一个不小于 $l_i$ 且不大于 $r_i$ 的数输出即可。

# subtask 5

由于存在 $l_i=r_i$，所以这个锁圈只能选择 $l_i$，所以最大公约数肯定为 $l_i$ 的因数。可以 $\mathcal{O}(\sqrt{l})$ 枚举因数并 $\mathcal{O}(n)$ 判断即可。这里有个小技巧，如果有多个 $l_i=r_i$ 时，我们可以直接记录这些 $l_i$ 的最大公约数并只枚举其因数即可。

# subtask 6

![](https://cdn.luogu.com.cn/upload/image_hosting/519emu4i.png)

玄学。赛时由于数据交水，直接暴力从 $k$ 开始枚举到 $\min_{i=1}^n r_i$ 并 $\mathcal{O}(n)$ 判断可过。加强了数据后就挂了，[会 T 一个点](https://www.luogu.com.cn/record/190711027)。

不妨想一想为什么会超时。我们发现有两个可能：

1. 最终合法的最大公约数过大。

2. 由于判断的顺序导致每一次判断都会 $\mathcal{O}(n)$ 跑满减慢程序运行。

争对第一点，由于公约数大，所以要么各个区间会产生重叠（每个区间包含这个数），要么导致 $n$ 减小、区间变小（每个区间包含这个数的两倍、三倍……可以发现因为最大公约数很大，所以区间数也相应会减少，虽然这么说并不严谨）。可以判断是否所有区间有重叠部分~~和精妙的玄学方法~~来解决问题。

对于第二点，我们略作思考，可以随机变换原序列的顺序，来尽量防止特意构造的数据把每一次 $n$ 次判断跑满。注意，这只能**减少**程序效率降低的概率，并不能**真正**地提高程序的效率。

综上所述，可得代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e4+5;
int T,n,k,chose[N];
struct node {
	int l,r,id;
} a[N];

bool dfs(int x) {
	if(x>n) {
		int gcd=chose[1];
		for(int i=2;i<=n;i++) gcd=__gcd(gcd,chose[i]);
		if(gcd>=k) {
			printf("Yes\n");
			for(int i=1;i<=n;i++) printf("%d ",chose[i]);
			printf("\n"); return true;
		}
		return false;
	}
	for(int i=a[x].l;i<=a[x].r;i++) {
		chose[a[x].id]=i;
		if(dfs(x+1)) return true;
	}
	return false;
}

int main() {
	scanf("%d",&T);
	while(T--) {
		int mxl=0,mnl=1e9,mxr=0,mnr=1e9;
		bool subtask=true;
		int sbtask=0;
		scanf("%d%d",&n,&k);
		for(int i=1;i<=n;i++) {
			scanf("%d%d",&a[i].l,&a[i].r);
			a[i].id=i;
			if(a[i].r-a[i].l>4) subtask=false;
			if(a[i].l==a[i].r) sbtask=__gcd(sbtask,a[i].l);
			mxr=max(mxr,a[i].r),mnr=min(mnr,a[i].r);
			mxl=max(mxl,a[i].l),mnl=min(mnl,a[i].l);
		}
		random_shuffle(a+1,a+1+n);
		
		if(k==1) {
			printf("Yes\n");
			for(int i=1;i<=n;i++) chose[a[i].id]=a[i].l;
			for(int i=1;i<=n;i++) printf("%d ",chose[i]);
			printf("\n"); continue ;
		}
		if(mxr<=1000) {
			bool ans=false;
			for(int i=k;i<=mxr;i++) {
				bool flag=true;
				for(int j=1;j<=n;j++)
					if(((a[j].l-1)/i+1)*i>a[j].r) {
						flag=false; break ;
					}
				if(flag) {
					printf("Yes\n");
					for(int j=1;j<=n;j++) chose[a[j].id]=((a[j].l-1)/i+1)*i;
					for(int j=1;j<=n;j++) printf("%d ",chose[j]);
					printf("\n"),ans=true; break ;
				}
			}
			if(!ans) printf("No\n");
			continue ;
		}
		if(subtask) {
			if(!dfs(1)) printf("No\n");
			continue ;
		}
		if(sbtask) {
			bool ans=false;
			for(int i=k;i*i<=sbtask;i++)
				if(sbtask) {
					bool flag=true;
					for(int j=1;j<=n;j++)
						if(((a[j].l-1)/i+1)*i>a[j].r) {
							flag=false; break ;
						}
					if(flag) {
						printf("Yes\n");
						for(int j=1;j<=n;j++) chose[a[j].id]=((a[j].l-1)/i+1)*i;
						for(int j=1;j<=n;j++) printf("%d ",chose[j]);
						printf("\n"),ans=true; break ;
					}
				}
			if(!ans) printf("No\n");
			continue ;
		}
		if(k<=5) {
			printf("Yes\n");
			for(int i=1;i<=n;i++) chose[a[i].id]=a[i].l/5*5+5;
			for(int i=1;i<=n;i++) printf("%d ",chose[i]);
			printf("\n"); continue ;
		}
		bool ans=false;
		for(int i=k;i<=mnr;i++) {
			bool flag=true;
			for(int j=1;j<=n;j++)
				if(!((a[j].l-1)/i<a[j].r/i)) {
					flag=false; break ;
				}
			if(flag) {
				printf("Yes\n");
				for(int j=1;j<=n;j++) chose[a[j].id]=((a[j].l-1)/i+1)*i;
				for(int j=1;j<=n;j++) printf("%d ",chose[j]);
				printf("\n"),ans=true; break ;
			}
		}
		if(!ans) printf("No\n");
	}
	return 0;
}
```

---

## 作者：luogu_gza (赞：5)

考虑。

如果 $\forall 1 \leq i \leq n,r_i-l_i+1 \geq k$，那么我们可以直接让 $\gcd=k$，随便构造一下即可。

否则，一定存在 $p$ 使得 $r_p-l_p+1<k$，我们枚举 $d$ 使得存在 $t$ 使得 $l_p \leq t \leq r_p$ 且 $d|t$。

然后直接对于每一个 $d$ 用 $O(n)$ 扫一遍瞎几把判一下就完事了。

复杂度 $O(nk \log w)$，速度很不赖！

---

## 作者：Moya_Rao (赞：4)

# 废话
赛时想不出来正解打了暴力，$65$ 分，垃圾。  
但作为一个蒟蒻也只有这个水平了。  
赛后看了题解，哎，赛时变成智障了，其实上真的简单！

# 题目大意
给定你一个锁，上面一共有 $n$ 个拨圈，其中第 $i$ 个拨圈能表示的数值是 $l_i \sim r_i$。

如果当前这个锁上所有拨圈上数值的最大公约数不小于 $k$，则该锁被打开。

本题有多组数据。请你针对每组数据，如果锁可能被打开，那么输出为 $2$ 行，第一行输出 `Yes`，第二行输出一种构造方案，方案可能不唯一，因此只要可行则算对；如果说不可能被打开，那么输出只有一行，即输出一个 `No`。

# 思路
观察数据后发现，$k$ 很小，是这道题的突破点。

我们稍微思考一下就可以想到，如果这 $n$ 个拨圈所对应的每个区间，它们的区间长度都 $\ge k$，那么肯定存在一种情况，拨圈上所有数的最大公约数为 $k$。这个时候直接输出 `Yes` 并输出某一种方案即可，这很简单的，具体看代码。  
在这种情况下，单组数据时间复杂度是 $O(n)$ 的。

否则的话，存在长度 $< k$ 的区间，那我们可以找出最短的这个区间。由于长度最长也就 $k-1$，很短，我们遍历这个最短的区间内所有数，拆分它们的因子，看看是否不小于 $k$。如果是的，再看是不是每个拨圈上的数都可以是它的倍数。如果依旧是的，那么这就是一种可行的方案，直接输出就行了。  
存在短区间的情况下，单组数据时间复杂度为 $O(kn\sqrt{V})$，其中 $V$ 表示 $l_i$ 以及 $r_i$ 的值域，即 $10^9$。看上去会超时，但一定是跑不满的，不信可以试试看！

# [AC](https://www.luogu.com.cn/record/190690078) 代码
代码写得有点奇怪，不喜勿喷。不过保证是可以过的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int T,n,k,l[N],r[N],id,p[N];
bool flag;
int read(){
    int su=0,pp=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')pp=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        su=su*10+ch-'0';
        ch=getchar();
    }
    return su*pp;
}
int GCD(int x,int y){
    if(x<y)swap(x,y);
    if(y==0)return x;
    return GCD(y,x%y);
}
int main(){
    T=read();
    while(T--){
        flag=1,n=read(),k=read();
        l[0]=1,r[0]=k,id=0;
        for(int i=1;i<=n;i++){
            l[i]=read(),r[i]=read();
            if(r[i]-l[i]+1<r[id]-l[id]+1)flag=0,id=i;
        }
        if(k==1){
            cout<<"Yes\n";
            for(int i=1;i<=n;i++)cout<<r[i]<<" ";
            cout<<"\n";
        }
        else if(flag){
            cout<<"Yes\n";
            for(int i=1;i<=n;i++)cout<<r[i]/k*k<<" ";
            cout<<"\n";
        }
        else{
            for(int x=l[id];x<=r[id]&&!flag;x++){
                for(int i=1;i*i<=x&&!flag;i++){
                    if(x%i!=0)continue;
                    if(i>=k){
                        bool is=1;
                        for(int c=1;c<=n;c++){
                            int x=r[c]/i*i;
                            if(x<l[c]){is=0;break;}
                            p[c]=x;
                        }
                        if(is){
                            flag=1;
                            cout<<"Yes\n";
                            for(int c=1;c<=n;c++)cout<<p[c]<<" ";
                            cout<<"\n";
                            break;
                        }
                    }
                    int j=x/i;
                    if(j>=k){
                        bool is=1;
                        for(int c=1;c<=n;c++){
                            int x=r[c]/j*j;
                            if(x<l[c]){is=0;break;}
                            p[c]=x;
                        }
                        if(is){
                            flag=1;
                            cout<<"Yes\n";
                            for(int c=1;c<=n;c++)cout<<p[c]<<" ";
                            cout<<"\n";
                            break;
                        }
                    }
                }
            }
            if(!flag)cout<<"No\n";
        }
    }
    return 0;
}
```

---

## 作者：Super_Cube (赞：3)

# Solution

若所有区间的长度都不小于 $k$，那 $k$ 一定可以作为它们的 $\gcd$ 值，原理是鸽巢定理，每个区间都一定会存在 $k$ 的倍数。

现在是至少存在一个区间长度小于 $k$。观察数据范围发现 $k\le 1000$，是非常小的，那就把这个区间内所有数的约数中不小于 $k$ 的拿出来检验是否符合条件即可。

区间 $[l,r]$ 中存在 $k$ 的倍数判定条件为 $\left\lfloor\dfrac{l-1}{k}\right\rfloor\ne\left\lfloor\dfrac{r}{k}\right\rfloor$，其实是前缀和相减。

# Code

```cpp
#include<bits/stdc++.h>
std::unordered_set<int>mp;
int a[10005],b[10005];
int T,n,m,id;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		id=1;
		for(int i=1;i<=n;++i){
			scanf("%d%d",&a[i],&b[i]);
			if(b[i]-a[i]<b[id]-a[id])id=i;
		}
		if(b[id]-a[id]+1>=m){
			puts("Yes");
			for(int i=1;i<=n;++i)
				printf("%d%c",((a[i]-1)/m+1)*m," \n"[i==n]);
			continue;
		}
		mp.clear();
		for(int i=a[id];i<=b[id];++i)
			for(int j=1;j*j<=i;++j)
				if(!(i%j)){
					if(j>=m)mp.insert(j);
					if(i>=m*j)mp.insert(i/j);
				}
		id=0;
		for(const int&i:mp){
			id=i;
			for(int j=1;j<=n;++j)
				if(b[j]/i==(a[j]-1)/i)id=0,j=n;
			if(id)break;
		}
		if(id){
			puts("Yes");
			for(int i=1;i<=n;++i)
				printf("%d%c",((a[i]-1)/id+1)*id," \n"[i==n]);
		}else puts("No");
	}
	return 0;
}
```

---

## 作者：saixingzhe (赞：2)

# 分析

提供一种较简单的乱搞方式，需要注意的是本题解做法非正解，且仅在目前数据下可以通过，仅供参考。

我们可以枚举公约数为 $k$ 到 $k+x$ 来判断答案，判断时顺序枚举即可，枚举到不行的就跳出循环。

我们猜测一下 $x$ 取多少合适，我们发现 $x$ 可以取很大，因为顺序枚举跑满 $n$ 的概率很小，一般只会跑常数次，且我们要保证答案小于等于 $k+x$，在这我们取 $x=5\times 10^7$，这样我们便可通过原数据。

加强后会 TLE 一个点，我们猜测可能是构造使得每次都枚举满 $n$，所以我们改变一下枚举的顺序即可，在这我是倒着枚举的，于是便可通过该题。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,k,l[10005],r[10005];
int main(){
	scanf("%d",&T);
	while(T--){
		bool fl=1;
		scanf("%d%d",&n,&k);
		for(int i=1;i<=n;i++)
			scanf("%d%d",&l[i],&r[i]);
		for(int i=k;i<=k+50000000;i++){
			bool lf=1;
			for(int j=n;j>=1;j--)
				if((l[j]+i-1)/i*i>r[j]){
					lf=0;
					break;
				}
			if(lf){
				printf("Yes\n");
				for(int j=1;j<=n;j++)	printf("%d ",(l[j]+i-1)/i*i);
				printf("\n");
				fl=0;
				break;
			}
		}
		if(fl)	printf("No\n");
	}
	return 0;
}   
```

---

## 作者：Kendieer (赞：1)

[**\[ 传送门 \]**](/problem/P11312)

## 题意

> 给定 $n$ 个区间 $[l_i,r_i]$，要求构造一个序列 $a$，使得 $a_i\in [l_i,r_i]$ 且 $\gcd_{i=1}^n a_i \ge k$。

## 思路构建

这一题首先要思考的是: 对于一个整数 $p$，如何判断每个区间 $[l,r]$ 中是否存在一个整数 $q$，使得 $q$ 能被 $p$ 整除？

我们可以分成以下 $2$ 种情况下进行讨论:

+ 当 $[l,r]$ 包含了超过 $p$ 个整数，即 $r-l+1\ge p$，则区间必然包含至少一个整数 $q$ 能被 $p$ 整除。(虽然这个结论从下面一点的情况也能证明到，但是后续用于剪枝要用。)
+ 当 $[l,r]$ 包含少于 $p$ 个整数，我们只需找从 $l$ 开始下一个 $p$ 的整数倍的数 $q$ 是否满足 $q\le r$，即 $p\lceil \frac{l}{p}\rceil\le r$。

那么我们怎么确定 $p$ 呢? 难道我们要枚举 $k\sim \max_{i=1}^{n}r_i$ 吗?

怎么可能?这不得T爆了！

对于每次匹配的 $p$，不难发现每次区间长度短的区间更容易匹配失败。于是我们可以选择一个区间长度最短的区间进行枚举因数 $p$。

问题是 $1\le l_i\le r_i \le 10^9$，万一最短的区间很大怎么办?

别忘了前面的情况 $1$，倘若最短的区间都包含了 $k$ 个整数，那么以 $k$ 作为公因数 $p$ 能在所有区间都至少存在一个符合的整数 $q$。

因此，我们最多需要枚举区间长度为 $k-1$ 中所有的整数的因子，通过[暴力测试](/paste/x57jetn5)可以发现这 $k-1$ 个整数至多的因子个数为 $M\lt 17000$，时间复杂度为 $O(k\sqrt{V}\log{k\sqrt{V}})$。( $V$ 取值为 $10^9$ )

后续我们将上述的所有可能的 $p$ 枚举到 $n$ 个区间中进行尝试。

时间复杂度为 $O(nM)$。

总程序的时间复杂度为 $O(k\sqrt{V}\log k\sqrt{V}+nM)$

## 参考代码

~~马蜂不太行，请谅解~~

``` cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define rep(i,a,b) for(ll i = (a);i < (b);i++)
#define repr(i,a,b) for(ll i = (b) - 1;i>= (a);i--)
#define elif else if
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
const ll inf = 0x3f7f7f7f7f7f7f7f;

ll qread(){
    ll r = 0,s = 1,ch = getchar();
    while (ch == ' ' || ch == '\r' || ch == '\n') ch = getchar();
    if (ch == '-') ch = getchar(),s = -1;
    while (ch >= '0' && ch <= '9') r = r * 10 + ch - '0',ch = getchar();
    return r * s;
}

const int maxn = 2e5 + 7;
const int mod = 998244353;
struct Node {
	ll l,r,id;
} nodes[maxn];
set<int> dv;

bool judge(ll l,ll r,ll d){
	if (r-l+1 >= d) return 1;
	ll req = (l+d-1)/d*d;
	if (req <= r) return 1;
	return 0;
}

void solve(){
	dv.clear();// 多测不清空见祖宗
	int n = qread(),k = qread();
	rep(i,1,n+1){
		nodes[i].l = qread(),nodes[i].r = qread(),nodes[i].id = i;
	}
	sort(nodes+1,nodes+1+n,[](Node a,Node b)->bool{return a.r-a.l+1 < b.r-b.l+1;});// 偷懒了，直接用sort了
	// 最短的区间
	ll kl = nodes[1].l,kr = nodes[1].r,ans = -1;
	if (kr-kl < k){
		rep(t,kl,kr+1){
			int maxdv = sqrt(t)+1;
			rep(i,1,maxdv){
				if (t % i == 0){
					if (i >= k)
						dv.insert(i);
					if (t/i >= k)
						dv.insert(t/i);
				}
			}
		}
	} else { // 特殊情况
		ans = k;
	}
	// run
	for(auto ele:dv){ // 去重
		bool flag = 1;
		rep(i,1,n+1){
			flag &= judge(nodes[i].l,nodes[i].r,ele);
			if (!flag) break;
		}
		if (flag){
			ans = ele;
			break;
		}
	}
	if (~ans){
		cout << "Yes" << endl;
		sort(nodes+1,nodes+1+n,[](Node a,Node b)->bool{return a.id < b.id;});
		rep(i,1,n+1){
			cout << (nodes[i].l+ans-1)/ans*ans << " ";
		}
		cout << endl;
	} else {
		cout << "No" << endl;
	}
}

int main(){
     int n = qread();
     while(n--)
    solve();
    return 0;
}
```

---

## 作者：elonzhang (赞：1)

# [P11312 神奇的小江鸟](https://www.luogu.com.cn/problem/P11312)

## 心路历程
~~赛事我连绿都切不了，我是fw。~~

赛事重要性质都推出来了，但是算错时间复杂度，导致只打了个简单的暴力，赛后才改对。

## 思路
首先我们需要知道两个个重要的性质：

- 当确定了最终的 $\gcd$ 出来的值 $ans$ 可以 $O(n)$ 检测并输出（`r[i]/ans*ans`）。
- 当所有的区间范围都大于 $k$ 的时候，是可以直接令所有数 $\gcd$ 等于 $k$ 的。

确定了这两个性质，我们就可以把最小的区间里的可选的数的因数枚举出来然后用第一个性质来算一遍输出就行了。

## ACcode
```cpp
#include <bits/stdc++.h>
using namespace std;
#define freop(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define int long long
#define double long double
#define re register
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
#define lowbit(x) (x&-x)
#define pii pair<int,int>
#define fir first
#define sec second
#define umap unordered_map
#define uset unordered_set
const int N=1e4+1;
int T,n,k,mn,mni,l[N],r[N];
set<int> se;//set去重

inline void js(int x){//统计这个数的因数
	for(int i = 1;i*i<=x;++i){
		if(!(x%i)){
			se.insert(i);
			if((i*i)^x) se.insert(x/i);
		}
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//	freop();
//↑以上为初始化↑
//------------------------------
	cin >> T;
	while(T--){
		cin >> n >> k,mni=0;//多测不清空，亲人两行泪
		for(int i = 1;i<=n;++i){
			cin >> l[i] >> r[i];
			if(r[mni]-l[mni]>r[i]-l[i]||!mni) mni=i;//求最小的区间
		}
		if(k==1||r[mni]-l[mni]+1>=k){//当特殊点或所有区间的长度都大于k
			cout << "Yes\n";
			for(int i = 1;i<=n;++i) cout << r[i]/k*k << ' ';
			cout << endl;
		}else{
			se.clear();//多测不清空，亲人两行泪
			for(int i = l[mni];i<=r[mni];++i) js(i);
			bool f=0,fl;
			for(int t:se){
				if(t<k) continue;
				fl=1;
				for(int i = 1;i<=n;++i) if(r[i]/t*t<l[i]){fl=0;break;}//看有没有t的倍数在区间内
				if(fl){
					cout << "Yes\n";
					for(int i = 1;i<=n;++i) cout << r[i]/t*t << ' ';//r[i]内t最大的倍数
					cout << endl;
					f=1;
					break;
				}
			}
			if(!f) cout << "No\n";
		}
	}
	return 0;
}
```

---

## 作者：c_y_y (赞：0)

# [P11312 神奇的小江鸟 题解](https://www.luogu.com.cn/problem/P11312)
注：本人并不保证该正解是否是乱搞 ~~（大概率是了）~~，但能通过加强数据。

---
刚看到此题，注意到 $k$ 的值很小。猜想正解时间复杂度和 $k$ 有关。

带"※"的 Subtask 是启发正解。

## Subtask 1
由于多个正整数的最大公约数均是正整数，故 $\gcd(a_{1}, a_{2}, \dots,a_{n}) \ge 1$。由于限制 $k = 1$, 故保证有解。只要随便输出一个合法的方案即可。
## Subtask 2
留给 dfs 的分。
## Subtask 3 ※
注意到 $r_{i} \le 10^3$，考虑枚举答案。从 $k$ 枚举到 $\min{r_{i}}$，如果遇到合法的方案案就输出。

接下来考虑答案的合法性以及如何输出答案。

设当前枚举到的答案是 $j$，若对于每一个区间，都存在一个被 $j$ 整除的数，那么该数合法。

如何找到这个数呢？我的方法是寻找小于 $r_{i}$ 中最近的被 $j$ 整除的数，放到代码中就是 `r[i] / j * j`，然后判断这个数是否大于 $l_{i}$ 即可。输出同理。
## Subtask 4
留给神秘做法的分。
## Subtask 5 ※
此时我们是必须要选这个数，设它为 $x$。那么根据最大公约数的定义，**答案必然是 $x$ 中大于 $k$ 的因数**！

那么，我们就将 $x$ 放到一个数组里（这里我用的是 vector），然后根据**Subtask 3**判断合法性（这里将最外层枚举答案改成枚举 vector 中的数就行了）即可。

## 正解
由部分分的启发，我们可以将最小长度的区间中的所有数的因数全部放到一个 vector 数组中，就像**Subtask 5**一样判断就行。这里“最小”属于一点时间上的小优化。

但是问题是即使我们选取了最小的区间，长度还是可能 $10^9$ 级的，怎么办？

**还记得开头那个 $k \le 1000$ 吗？**

既然如此，我们进行一个“分治”：
- 如果最小的区间小于等于 $k$，那么就进行常规操作；此时计算次数至多 $70690000$ 次，在洛谷能够通过。
- 如果最小的区间长度大于 $k$，得出所有的区间均大于 $k$，**此时一定存在一个数会被 $k + 1$ 整除。也就是说，区间长度过大时，$k + 1$ 就是我们要求的答案！**

那么思考到这，代码就很好想了。

```
void solve() {
	int n = read(), k = read();
	for (int i = 1; i <= n; i++) 
		l[i] = read(), r[i] = read();
	//寻找长度最小的区间
	int inx = 0, minn = 1e9 + 10;
	for (int i = 1; i <= n; i++) 
		if(r[i] - l[i] + 1 < minn) 
			inx = i, minn = r[i] - l[i] + 1;
	if(minn > k) {//区间过大，k+1就是我们想要的答案
		printf("Yes\n");
		for (int i = 1; i <= n; i++)
			printf("%d ", r[i] / (k + 1) * (k + 1));
		printf("\n");
	}else {//暴力查找
		vector<int>g;
		for (int i = l[inx]; i <= r[inx]; i++) {
			for (int j = 1; j <= sqrt(i); j++) {
				if(i % j == 0) {
					if(j >= k) g.push_back(j);
					if(i / j >= k) g.push_back(i / j);
					//这里不用考虑是否重复。
				}
			}
		}
		for (auto j : g) {
			bool flag = true;
			for (int i = 1; i <= n; i++) {
				if(!(l[i] % j == 0 || r[i] / j * j >= l[i])) {
					flag = false;
					break;
				}
			}
			if(flag) {//输出方案
				printf("Yes\n");
				for (int i = 1; i <= n; i++)
					printf("%d ", r[i] / j * j);
				printf("\n");
				return ;
			}
		}
		printf("No\n");
	}
	return ;
}
int main() {
	int _ = read();
	while(_--) solve();
	return 0;
}
```

---


# 扶苏出勤日记

## 题目描述

扶苏是一个舞萌吃。在接下来的 $n$ 天里，她每天都要去玩舞萌，并且她希望每天**游玩的局数相同**。

游玩一局舞萌固定花费 $1$ 个游戏币。然而，游戏币每天的价格都有可能变化。具体来说，在第 $i$ 天，一元可以购买 $a_i$ 个游戏币。

靠着给洛谷打~~黑~~工，扶苏每天都会有一些收入。她会在第 $i$ 天收入 $b_i$ 元。

每天，扶苏会**先**得到当天的收入 $b_i$ 元，再去购买游戏币，再游玩舞萌。

扶苏每天可以使用自己拥有的钱的任意金额按照当天的币价购买游戏币。也就是说，她不必一次性换光所有的钱，可以在当天只使用一部分钱购买游戏币，存下一些剩余的钱留在今后的若干天购买游戏币。同时，她一天不必花光所有的游戏币，可以只在当天花费一部分游戏币，存下一些剩余的游戏币在之后的若干天玩。

扶苏知道今后 $n$ 天的币价和她每天的收入，她想在接下来 $n$ 天里每天游玩相同局数的舞萌。因此她想知道，在她使用最优策略购买游戏币的情况下，她每天最多可以游玩多少局舞萌？

## 说明/提示

### 数据规模与约定

用 $N$ 表示单个测试点内 $n$ 的和。
- 对 $20\%$ 的数据，保证 $1 \leq n \leq 3$，$N \leq 1000$；
- 对 $40\%$ 的数据，保证 $1\le n \le 2000$，$N \leq 10000$；
- 对 $60\%$ 的数据，满足 $1\le n \le 10^5$，$N \leq 2 \times 10^5$；
- 另有 $10\%$ 的数据，满足 $a_i \geq a_{i + 1}$（对 $1 \leq i \leq n-1$）。
- 另有 $10\%$ 的数据，满足 $a_i \leq a_{i + 1}$（对 $1 \leq i \leq n-1$）。
- 对于 $100\%$ 的数据，满足 $1\le n\le 10^6$，$1\le a_i \le 1000$，$1\le b_i \le 10^9$，$n \leq N \leq 2 \times 10^6$，$1 \leq T \leq 2 \times 10^6$。


## 样例 #1

### 输入

```
3
5
1 2 3 4 5
5 4 3 2 1
5
1 1 1 1 1
2 3 4 5 6
9
9 9 8 2 4 4 3 5 3
10 10 10 10 10 10 10 10 10```

### 输出

```
5
2
55```

# 题解

## 作者：_czy (赞：27)

### 前情提要

这场比赛赛时 C 题与 F 题分别因未开 long long 分别从 $100\rightarrow30$ 和 $150\rightarrow0$ ，$220$ 分就这样没了。

### 分析

显然，本题答案具有单调性，可以使用二分答案。二分出一个值后，可以利用贪心的思想判断。具体的，先利用单调栈预处理每个位置下一个更优的位置在哪，再贪心的选取，尽量保证游戏币的数量能撑到下一个更优的位置，如果已是最优的，就全换。详见代码。

### 代码

赛时：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e6+3;
int T,n,a[N],b[N],p[N];
ll now,sum,l,r;
bool chk(int x){
	now=sum=0;
	for(int i=1;i<=n;i++){
		sum+=b[i];
		if(p[i]){
			if(now<1ll*(p[i]-i)*x){
				ll t=1ll*(p[i]-i)*x-now,l=min(t/a[i]+(t%a[i]>0),sum);
				now+=l*a[i],sum-=l;
			}
		}else now+=sum*a[i],sum=0;
		now-=x;
		if(now<0)return 0;
	}
	return 1;
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i];
		stack<int>s;
		for(int i=n;i;i--){
			while(!s.empty()&&a[s.top()]<=a[i])s.pop();
			p[i]=s.empty()?0:s.top();
			s.push(i);
		}
		l=0,r=1e12;
		while(l<r){
			int mid=(l+r)/2+1;
			if(chk(mid))l=mid;
			else r=mid-1;
		}
		cout<<l<<'\n';
	}
}
```

赛后：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e6+3;
int T,n,a[N],b[N],p[N];
ll now,sum,l,r;
bool chk(ll x){
	now=sum=0;
	for(int i=1;i<=n;i++){
		sum+=b[i];
		if(p[i]){
			if(now<1ll*(p[i]-i)*x){
				ll t=1ll*(p[i]-i)*x-now,l=min(t/a[i]+(t%a[i]>0),sum);
				now+=l*a[i],sum-=l;
			}
		}else now+=sum*a[i],sum=0;
		now-=x;
		if(now<0)return 0;
	}
	return 1;
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i];
		stack<int>s;
		for(int i=n;i;i--){
			while(!s.empty()&&a[s.top()]<=a[i])s.pop();
			p[i]=s.empty()?0:s.top();
			s.push(i);
		}
		l=0,r=1e12;
		while(l<r){
			ll mid=(l+r)/2+1;
			if(chk(mid))l=mid;
			else r=mid-1;
		}
		cout<<l<<'\n';
	}
}
```

---

## 作者：chzhh_111 (赞：13)

事先说明：赛时堆加二分的 $O(n \log^2 n)$ 算法可以得 $70$ 分，结果上界调小了，只得了 $20$ 分。

## 分析部分

容易得到，保证每天游玩的局数相同的难度肯定是随着局数个数的增加而增加的，因为如果存在一个局数是可以实现的，那么所有比这个数小的局数肯定也能实现 ~~其实就是少玩一点嘛~~，因此就说明答案存在单调性。有单调性就说明什么呢？可以**二分**。

那么代码难度肯定都放在判断函数上面了，那就可以分情况讨论了：

- 如果以前所剩下的游戏币能够满足今天所要玩的游戏局数，那么我们肯定是直接用的，要解释这个策略的话，就是不能浪费每一块钱对游戏币所贡献的价值。

- 如果不够用的话，那我们就要买币，但是在哪一天买就是问题了，我们肯定要在当前能买且最大的那一天买，因为这样子所贡献的游戏币是最多的，也肯定是最优的。

  这就要我们维护一段区间里面的最大值，而且这个最大值还是实时动的，也就意味着我们还要维护次大值之类的。

  但我们可以发现如果我们不能在某一天继续买币的话，当且仅有能用在这一天的钱花完了，而且此时此刻我们是不能在这一天之前买币 ~~毕竟钱全都在这一天用完了~~。而且在之前买币也肯定是不优的，因为我们保证这一天一块钱对游戏币的个数贡献是最大的。

  所以我们买币的下一天一定是在这一天之后（也就是次大值），那这就可以利用一些**单调队列**之类的东西维护了。

  要注意的是在某一天买完币后所消耗的钱一定对后面有影响，由于一定是前面影响后面，所以可以用一个变量来储存现在用多少钱，然后再减就行了。

我们再经过以上的策略，对于每一个游戏局数都进行判断，最后就可以得出答案了。

## 代码部分

单调队列，也就是 $O(n \log n)$：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+100;
int T,n,a[N],b[N];
int L,R;
struct node{
	int game,mon;//game:对游戏币产生的贡献; mon:能用的钱数 
}q[N];//单调队列 
bool check(int x)//判断函数 
{
	int nowmon=0,nowgame=0,usemon=0;
	L=1,R=0;
	for(int i=1;i<=n;i++)
	{
		nowmon+=b[i];
		while(L<=R&&q[R].game<=a[i]) R--;
		q[++R]=(node){a[i],nowmon};
		if(nowgame<x)
		{
			while(nowgame<x&&L<=R)
			{
				int game=q[L].game;
				int mon=q[L].mon-usemon;//要减掉用过的钱 
				int need=x-nowgame;
				int ch=min((need+game-1)/game,mon);//尽量减少钱的使用 
				usemon+=ch;
				nowgame+=ch*game;
				mon-=ch;
				if(!mon) L++;//钱用完了就踢出队 
			}
			if(nowgame<x) return 0;
		}
		nowgame-=x;
	}	
	return 1;
}
signed main()
{
	scanf("%lld",&T);
	while(T--)
	{
		int l=0,r=0,maxa=0;
		scanf("%lld",&n);
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]),maxa=max(maxa,a[i]);
		for(int i=1;i<=n;i++) scanf("%lld",&b[i]),r+=maxa*b[i];
		r/=n;
		while(l<=r)
		{
			int mid=(l+r)>>1;
			if(check(mid)) l=mid+1;
			  else r=mid-1;
		}
		printf("%lld\n",r);
	}
	return 0;
}
```

堆，也就是 $O(n \log^2 n)$：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+1;
int T,n,a[N],b[N];
struct node{
	int times,game,mon;
	bool operator<(const node &aa)const{
		return game<aa.game;
	}
};
priority_queue<node>q;bool check(int x)
{
	int nowmon=0,nowgame=0,usemon=0,stop=0;
	for(int i=1;i<=n;i++)
	{
		nowmon+=b[i];
		q.push((node){i,a[i],nowmon});
		if(nowgame>=x)
		{
			nowgame-=x;
			continue;
		}
		else
		{
			while(nowgame<x&&q.size())
			{
				int times=q.top().times,game=q.top().game,mon=q.top().mon-usemon,need=x-nowgame;
				int ch=min((need+game-1)/game,mon);
				if(times<=stop) {q.pop();continue;}//都发现单调性了，还用堆
				usemon+=ch;
				nowgame+=game*ch;
				mon-=ch;
				if(!mon)
				{
					q.pop();
					stop=times;
				}
			}
			if(nowgame<x) return 0;
			  else nowgame-=x;
		}
	}	
	return 1;
}
signed main()
{
	scanf("%lld",&T);
	while(T--)
	{
		int l=0,r=0,maxa=0;
		scanf("%lld",&n);
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]),maxa=max(maxa,a[i]);
		for(int i=1;i<=n;i++) scanf("%lld",&b[i]),r+=b[i]*maxa;
		r/=n;
		while(l<=r)
		{
			while(q.size()) q.pop();
			int mid=(l+r)>>1;
			if(check(mid)) l=mid+1;
			  else r=mid-1;
		}
		printf("%lld\n",r);
	}
	return 0;
}
```

---

## 作者：I_will_AKIOI (赞：4)

发现答案具有单调性，考虑二分。接着考虑 check，假设当前在检验 $x$ 是否合法。

每天花费游戏币有点难做，我们转化一下，假设游戏币 $coin$ 不会用掉，第 $i$ 天只会检测 $coin<i\cdot x$，满足的话就说明 $x$ 不合法，游戏币不够用。

接着考虑贪心地为第 $i$ 天购买最便宜的游戏币。设 $nxt_i$ 表示 $i$ 之后 第一个 $a_j>a_i$ 的 $j$。那么在 $[i,nxt_i-1]$ 这段时间，第 $i$ 天能买到的游戏币是价格最低的。因此尽可能地让第 $i$ 天买够 $x\cdot(nxt_i-1)$ 个游戏币，也就是足够前 $nxt_i-1$ 天用的游戏币，直到钱不够为止。然后 $nxt_i$ 这个东西可以单调栈求解，最后时间复杂度为 $O(n\log V)$。

注意二分答案上界 $V$，为 $\max(a_i\cdot b_i)=10^{12}$。上界太大会爆 `long long`。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
using namespace std;
int n,len,a[N],b[N],nxt[N],s[N];
bool check(int x)
{
	int money=0,coin=0;//字面意思，表示剩余的钱数和买的游戏币数
	for(int i=1;i<=n;i++)
	{
		money+=b[i];
		if(money*a[i]+coin<(nxt[i]-1)*x) coin+=money*a[i],money=0;//花全部钱买
		else if(coin<(nxt[i]-1)*x)//花部分钱买
		{
			int cost=((nxt[i]-1)*x-coin),buy;//cost 表示还需要购买的游戏币，buy 表示实际买游戏币花费的钱
			if(cost%a[i]==0) buy=cost/a[i];
			else buy=cost/a[i]+1;
			buy=min(buy,money);
			coin+=buy*a[i];
			money-=buy;
		}
		//coin 大于需要的数量就不买 
		if(coin<i*x) return 0;//不够花
	}
	return 1;
}
void solve()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=n;i++) nxt[i]=n+1;
	len=0;
	for(int i=1;i<=n;i++)
	{
		while(len&&a[s[len]]<a[i]) nxt[s[len--]]=i;
		s[++len]=i;
	}
	int l=1,r=1000000000005,x;
	while(l<r)
	{
		x=l+r+1>>1;
		if(check(x)) l=x;
		else r=x-1;
	}
	cout<<l<<"\n";
	return;
}
signed main()
{
	ios::sync_with_stdio(0);
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：Meickol (赞：3)

题意即要保证每天的游戏币数量不低于游戏局数。

而每天的收入可变，且每天一元能购买的游戏币数量也可变。



思考一下可否二分答案？即思考一下答案是否具备单调性，发现是可以的，因为当游戏局数越少时就越容易达到。



根据贪心思想，尝试将问题转化为一个从前面天中选最划算的那天来尽可能多地购买游戏币的问题。

但是你会发现这样存在一个漏洞：若当前为第 $i$ 天，我们其实不能直接找第 $i$ 天前面天中最划算的那一天来全买币，因为我们无法用今天新得到的钱去以之前的物价买东西。



那么换一个角度想，如果对于当前第 $i$ 天而言，思考今天应该买多少个币，以及留多少钱给之后用，这个思路是否可行呢？发现是可以的。

具体思路如下：

用 $ne_{i}$ 维护对于当前第 $i$ 天而言下一次最近的更划算的位置。那么对于 $[i,ne_{i}-1]$ 这段区间显然只有买 $i$ 是最划算的。

那么当我们当前枚举到第 $i$ 天时，根据贪心思想：

- 如果当前的币足够支撑我们在 $[i,ne_{i}-1]$ 这些天使用，那么就不买币，把钱留到 $ne_{i}$ 天再考虑使用。
- 如果当前的币不够支撑我们在 $[i,ne_{i}-1]$ 这些天使用，那么就只能买币了，但是尽可能少买，买到够用即可。



**最终代码**

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
typedef long long LL;
const int N=1e6+5;
int n;
int a[N],b[N];
int stk[N],top;
int ne[N]; // ne[i] 记录对于当前第 i 天而言下一次最近的更划算的位置
bool check(LL x){
	LL res=0,tot=0; // 分别表示钱的数量、币的数量
	rep(i,1,n){
		res+=b[i];
		if(ne[i]){
			LL num=ne[i]-i;
			LL need_buy=num*x-tot; // 还需要的币的个数
			if(need_buy>0){
				LL will_cost=min(res,(need_buy+a[i]-1)/a[i]);
				res-=will_cost,tot+=will_cost*a[i];
			}
		}
		else{
			tot+=res*a[i],res=0;
		}
		tot-=x;
		if(tot<0) return false;
	}
	return true;
}
void solve(){
	top=0;
	cin>>n;
	rep(i,1,n) ne[i]=0;
	rep(i,1,n) cin>>a[i];
	rep(i,1,n) cin>>b[i];
	rep(i,1,n){
		while(top>0 && a[stk[top]]<a[i]){
			ne[stk[top]]=i;
			top--;
		}
		stk[++top]=i;
	}
	LL l=0,r=1e12;
	while(l<r){
		LL mid=(l+r+1)>>1;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
}
```

---

## 作者：Motonic_queues (赞：3)

awmc


---

## 题目大意
每天赚 $b_i$ 块钱，$1$ 块钱可以换 $a_i$ 个币去打乌蒙，求每天打乌蒙的最多次数。  

## 题意分析
显然的二分，那么难点在于考虑 `check`。  


`check` 能想到采用模拟思路，把 $n$ 天遍历一边，先赚钱，然后换币。如果中途币不够了就 `return 0`，能过完这 $n$ 天就 `return 1`。  

考虑如何换币：假设 $a_i<a_j$ $(i<j)$，而且第 $i$ 天的币足以用到第 $j$ 天，那么显然**在第 $j$ 天换币比在第 $i$ 天换币更优**。  
更特别的，如果 $j$ 离 $i$ 最近，那么**它们中间的日子换币一定比这两天换币更劣**，考虑到这点，使用单调栈维护。   

分类讨论，假设每天要打 $x$ 把，现在是第 $i$ 天，有 $B$ 个币， $M$ 块钱，更优的下一天是 $nxt_i$。  

如果当前这一天是之后最优的一天，也就是说 $nxt_i$ 不存在，那么把钱全部花光就好了，反正最优。

那一天存在的话，有 $3$ 种情况：  
第一：当前的币已经足够支撑到那一天，即
$$
x\times(nxt_i-i)\le B
$$
那么一块钱都不用花。  
 
第二：花一部分钱可以使上面的式子成立，也就是说
$$
x\times(nxt_i-i)\le B+M\times a_i
$$
那么花最少的钱，因为剩下的要留给第 $nxt_i$ 天。  

第三：钱花完了也不能使上面的式子成立。  
只能在这里把钱全部花完，因为留不到那一天，如果留给中间的日子反而劣，所以最好的是自己用完。  

总的就上面几种情况，依次判断即可。  

## 代码&细节
二分上界是 $10^{12}$。  

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=1e6+5;
int T,n;
int a[N],b[N],nxt[N];
int kkk;//第4种情况下花的钱

bool chk(int x){
	int now=0,B=0;
	for(int i=1;i<=n;i++){
		now+=b[i];
		int days=nxt[i]-i;
		if(nxt[i]==-1){ //当前最优
			B+=now*a[i];
			now=0;
		}else{
			if(now*a[i]>=x*days-B){ //钱够
				kkk=ceil(1.0*max(x*days-B,0ll)/a[i]); //计算最少需要花的钱
				B+=kkk*a[i];
				now-=kkk;
			}else{ //钱不够
				B+=now*a[i];
				now=0;
			}
		}
		if(B>=x)B-=x;
		else return 0;
	}
	return 1;
}

stack<int> s;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i];
		for(int i=1;i<=n;i++){ //维护单调栈
			while(!s.empty()&&a[s.top()]<=a[i]){nxt[s.top()]=i;s.pop();}
			s.push(i);
		}
		while(!s.empty())nxt[s.top()]=-1,s.pop();
		int l=0,r=1e12,mid;
		while(l<r){
			mid=(l+r+1>>1);
			if(chk(mid))l=mid;
			else r=mid-1;
		}
		cout<<l<<'\n';
	}
	return 0;
}
```
~~呜呜呜别卡我常~~

---

## 作者：MaiJingYao666 (赞：3)

# P12000 扶苏出勤日记 题解  
~~说个鬼故事：扶苏一天跳~~ $10^{12}$ ~~次舞。~~  
***
## 解题思路  
很明显，答案具有单调性，所以可以用二分答案做。  
这里就当大家都会了二分了啊，这道题的答案函数贪心思路有点像 [这道](https://www.luogu.com.cn/problem/P9749)，就是它每天的贡献值不能无限大选。反过来想，若一个数 $a_i > \max_{j=i+1}^{i+k} a_j$，则我们希望 $i+1$ 到 $i+k$ 天的游戏币都是由第 $i$ 天买。所以一个数 $i$ 希望买单的区间就是 $[i,\min_{i<j\le n,a_j\ge a_i} j)$，当然因为扶苏当天财富有限，所以实际情况还要再判断。  
可以用单调栈预处理出每个数贪心策略下负责的点，理论时间复杂度足够。我们设每个数希望负责的区间为 $[i,to_i)$。  
接下来贪心函数，用两个变量 $tmp_1$ 和 $tmp_2$ 记录剩余的钱和硬币。每次先将 $tmp_1$ 加上 $b_i$，每个数要取的就是 $tmp_1 \times a_i$ 和大于 $((to_i-i)\times -x-tmp_2))$ 的最小的 $a_i$ 的倍数。当有 $tmp_2<x$，说明 $x$ 不成立。  

### AC 代码  

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
const int N=1e6+5;
int T;
int n;
ll a[N],b[N];
int to[N];
int stk[N],top;
inline bool check(ll x){
	ll tmp1=0,tmp2=0;
	for(int i=1;i<=n;i++){
		tmp1+=b[i];
		ll buyin=min(tmp1*a[i],((to[i]-i)*x-tmp2+a[i]-1)/a[i]*a[i]);
		buyin=max(0LL,buyin);
		tmp2+=buyin;
		if(tmp2<x) return false;
		tmp1-=buyin/a[i];
		tmp2-=x;
//		cout<<buyin<<" ";
	}
	return true;
}
int main(){
	cin>>T;
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%lld",a+i);
		}
		for(int i=1;i<=n;i++){
			scanf("%lld",b+i);
		}
		ll L=0,R=0;
		for(int i=1;i<=n;i++){
			R=max(R,b[i]*a[i]);
			while(top>0 && a[stk[top]]<a[i]){
				to[stk[top]]=i;
				top--;
			}
			stk[++top]=i;
		}
		while(top>0){
			to[stk[top]]=n+1;
			top--;
		}
//		for(int i=1;i<=n;i++) cout<<to[i]<<" ";
//		cout<<endl;
		while(L<R){
			ll mid=L+R+1>>1;
			if(check(mid)) L=mid;
			else R=mid-1;
//			cout<<endl;
		}
		printf("%lld\n",L);
	}
}
```

---

## 作者：canwen (赞：2)

## 题目大意
有 $n$ 天，每天可以拿到 $b_i$ 元钱，当天 $1$ 元可以购买到 $a_i$ 个游戏币，一个游戏币可以玩一把舞萌。

在钱数足够的情况下，每天花任意整数元买币，求问在每天都要玩相同的舞萌数量下，这个数量最大可以是多少。

## Solution

观察到 $n \le 10^6$，动态规划是不可行的，考虑二分求解最大的答案。

`check` 函数怎么写呢？

对于第 $i(1\le i \le n)$ 天，若当天之后不存在 $a_j > a_i(i < j \le n)$，把当前有的所有钱数换掉一定最优。

否则即存在 $j$，那么只需要考虑第一个 $a_j > a_i$ 即可，考虑我们看从能不能从第 $i$ 天凭借现在的游戏币数量撑到第 $j$ 天，如果可以，那么就放心地不花任何钱在购买当天的游戏币，如果不可以，就求出需要花多少钱购买一些游戏币用来撑到第 $j$ 天。

假想一下，如果 $a_1 < a_2 < a_3$，如果第 $1$ 天能撑到第 $2$ 天，第 $2$ 天再考虑能不能撑到第 $3$ 天，这是可行的。

对于每一个 $i$，寻找第一个编号 $j > i$，使得 $a_j > a_i$，可以使用单调栈 $O(n)$ 处理。

## Code

美味代码，欢迎 hack。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 1e6 + 5;
int a[N],b[N],s[N],tot,pd[N],n;

bool check(int x){
	
	int have = 0, mon = 0;
	
	for(int i=1;i<=n;i++){
		mon += b[i];
		if(pd[i] == 0){
			have += mon * a[i], mon = 0;
		}else{
			int num = x*(pd[i]-i);
			if(have < num){
				int k = (num - have) / a[i] + ((num - have) % a[i] > 0);
				k = min(k,mon);
				mon -= k, have += k*a[i];
			}
		}
		have -= x;
		if(have < 0) return 0;
	}
	
	return 1;
}

signed main(){
	ios::sync_with_stdio(time(0));
	cin.tie(0), cout.tie(0);
	int T;
	cin >> T;
	while(T--){
		cin >> n;
		tot = 0;
		for(int i=1;i<=n;i++) cin>>a[i],s[i] = pd[i] = 0;
		for(int i=1;i<=n;i++) cin>>b[i];
		for(int i=n;i>=1;--i){
			while(tot > 0 && a[i] >= a[s[tot]]) --tot;
			pd[i] = s[tot];
			s[++tot] = i;
		}
//		for(int i=1;i<=n;i++) cout << pd[i] << " ";
		int ans = 0;
		int l = 0, r = 1e18;
		while(l <= r){
			int m = l + r >> 1;
			if(check(m)) ans = m, l = m + 1;
			else r = m-1;
		}
		cout << /*"ans = " <<*/ ans << endl;
	} 
	return 0;
}
```

---

## 作者：ymx2009 (赞：1)

# 题目大意
有 $n$ 天，每天一元可以买 $a_i$ 个币，每天获得 $b_i$ 元钱。求每天固定用 $x$ 个币，求 $x$ 最大值。
# 思路分析
$x$ 的值满足单调性，考虑使用二分。  
重点在于 $\operatorname{check}$ 函数怎么写。  
然后发现对于每个 $x$ 都可以使用贪心的方法获取最多的币。
# Solution
用单调栈维护每一个 $a_i$ 右边第一个值小于等于 $a_i$ 的下标 $next_i$。  
这一天为 $i$，拥有的币为 $c$，当 $x$ 确定时，有三种情况。  
第一种：  
对任意的 $j>i$，有 $a_i\le a_j$ 那么把钱留在后面花一定不优，所以我们就把所有的前都花光在这一天买币。  
第二种：  
如果花光所有的钱和币还到达不了 $next_i$，那么把钱留在后面花是不优的，所以把所有的钱都换成币。  
第三种：  
如果能到达 $next_i$，且不需要换币，即 $a_i\times b_i+c\ge (next_i-i)\times x$，就只需减去这几天的花费即可。如果需要换币，那么需要换的币就是 $(next_i-i)\times x-c$。
# 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
int a[N],b[N],nex[N],n;

bool check(int x)
{
	int c=0,m=0;
	for(int i=1;i<=n;i++)
	{
		m+=b[i];
		int t=nex[i]-i;
		if(!nex[i]) c+=m*a[i],m=0;
		else if(m*a[i]+c>=t*x)
		{
			int d=(max(t*x-c,(int)0)+a[i]-1)/a[i];
			m-=d,c+=d*a[i];
		}
		else c+=m*a[i],m=0;
		c-=x;
		if(c<0) return false;
	}
	return true;
}


int f(int l,int r)
{
	if(l>=r) return l;
	int mid=l+r+1>>1;
	if(check(mid)) return f(mid,r);
	return f(l,mid-1);
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	for(;T--;)
	{
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++) cin>>b[i];
		stack<int> stk;
		for(int i=1;i<=n;i++) nex[i]=0;
		for(int i=1;i<=n;i++)
		{
			for(;!stk.empty()&&a[i]>=a[stk.top()];stk.pop()) nex[stk.top()]=i;
			stk.push(i);
		}
		cout<<f(0,1e12)<<'\n';
	}
	return 0;
}
```

---

## 作者：哈哈人生 (赞：1)

# 题外话
不知道为什么，赛时第一感觉就是 ST 表，全然忘了单调队列。但理论上 ST 表也是 $O(n\log n)$，和单调队列没区别。但可能是被卡常了吧就是没过去（$80$ 分），本文最后有我没过的 ST 表代码，请大佬们看看出了什么问题。

# 思路
首先观察到答案有单调性，可以二分答案。分别枚举每一天的花钱情况。假设我们有第 $i$ 天的收入 $x$ 元，在第 $j$ 天我们可以最多得到 $x\times \max^{j}_{k=i} a_k$。所以我们可以以此贪心。而 $\max^{j}_{k=i} a_k$ 这个东西，我的第一反应是 ST 表，但却不知为何超时。再次转变思路，发现我们发现最大值是单调递增的，所以一定是第 $i$ 天的钱花完后我们再去花第 $i+1$ 天的钱，所以 $i$ 的变化是每次加一。而 $j$ 是我们枚举的，也是每天加一。这个不就是滑动窗口（单调队列模板）吗？所以最终复杂度 $O(n\log n)$，瓶颈在二分。

## 代码
正解代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[1000005],b[1000005],c[1000005],q[1000005];
bool check(int x){
	for(int i=1;i<=n;i++)c[i]=b[i];
	int jl=1,ys=0,h=0,r=-1;
	for(int i=1;i<=n;i++){
		while(h<=r&&a[q[r]]<=a[i])r--;
		q[++r]=i;
		int y=x;
		if(y<=ys)ys-=y,y=0;
		else y-=ys,ys=0;
		while(jl<=i&&y>0){
		    int tmp=min((int)ceil(1.0*y/a[q[h]]),c[jl]);
			y-=tmp*a[q[h]];
			c[jl]-=tmp;
			if(c[jl]==0){
				if(q[h]==jl)h++;
				jl++;
			}
		}
		if(y>0)return 0;
		ys+=-y;
	}
	return 1;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=n;i++)cin>>b[i];
		int l=0,r=1e12,mid,ans=0;
		while(l<=r){
			mid=(l+r)/2;
			if(check(mid))ans=mid,l=mid+1;
			else r=mid-1;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```
ST 表 $80$ 分代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef int type;
inline int read(){
	int x=0,f=1;
	char ch=getchar_unlocked();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar_unlocked();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar_unlocked();
	}
	return x*f;
}
inline void write(long long x){
	if(x<0)putchar_unlocked('-'),x=-x;
	if(x>9)write(x / 10);
	putchar_unlocked(x%10+'0');
}
int t,n,a[1000005],b[1000005],c[1000005],LOG[1000005],ST[1000005][25];
void build_log(){
	LOG[0]=-1;
	for(int i=1;i<=1000000;i++)LOG[i]=LOG[i/2]+1;
}
void build_st(){
	for(int i=1;i<=n;i++){
		ST[i][0]=a[i];
	}
	for(int j=1;j<=20;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			ST[i][j]=max(ST[i][j-1],ST[i+(1<<j-1)][j-1]);
		}
	}
}
int find(int l,int r){
	int w=LOG[r-l+1];
	return max(ST[l][w],ST[r-(1<<w)+1][w]);
}
bool check(int x){
	for(int i=1;i<=n;i++)c[i]=b[i];
	int jl=1,ys=0;
	for(int i=1;i<=n;i++){
		int y=x;
		if(y<=ys)ys-=y,y=0;
		else y-=ys,ys=0;
		while(jl<=i&&y>0){
		    int tmp=min((int)ceil(1.0*y/find(jl,i)),c[jl]);
			y-=tmp*find(jl,i);
			c[jl]-=tmp;
			if(c[jl]==0)jl++;
		}
		if(y>0)return 0;
		ys+=-y;
	}
	return 1;
}
signed main() {
    build_log();
	t=read();
	while(t--){
		n=read();
		for(int i=1;i<=n;i++)a[i]=read();
		for(int i=1;i<=n;i++)b[i]=read();
	    build_st();
		int l=0,r=1e12,mid,ans=0;
		while(l<=r){
			mid=(l+r)/2;
			if(check(mid))ans=mid,l=mid+1;
			else r=mid-1;
		}
		write(ans),putchar('\n');
	}
	return 0;
}
```

---

## 作者：haobao123456 (赞：0)

鄙人不才，花了好长时间才解出来......
# 思路：
首先，这道题具有单调性，为什么呢？因为这道题他的收入和每一天的单价都已经给你了，那么它的消费能力也是固定的，我玩的局数越多，我就越不能满足，否则我玩的局数越少，就越能满足，符合单调性，所以可以用二分答案。

最关键的来了，接着想一下，那如何判断呢？我们可以用贪心，题目说了，可以留一些钱，我肯定是想要留的越多，后面就可以用上，所以我们可以维护一个 $last$ 变量，表示我当前兑换成了游戏币但是我没有用完的游戏币数，大部分题解都没有这个变量，再用一个单调队列维护一下每天剩下的钱和兑换率即可。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
typedef pair<int,int> PII;
#define x first
#define y second
const int mod=1e9+7;
const int N=1e6+50;
#define endl '\n'
#define IO ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
int t,n,a[N],b[N];
bool check(int mid){
	int last=0;
	deque<PII> q; //first是钱，second是一元能换的硬币数 
	for(int i=1;i<=n;i++){
		int t=b[i];
		while(!q.empty()&&q.back().second<=a[i]){ //维护单调队列
			t+=q.back().first; //加上
			q.pop_back(); 
		}
		q.push_back({t,a[i]}); //存放
		int td=mid;
		if(last>=td){ //判断
			td=0;
			last-=td;
		}else{
			td-=last;
			last=0;
		}
		while(!q.empty()&&td){
			int tmp=q.front().x*q.front().y;
			if(tmp>=td){
				int by=(td+q.front().second-1)/q.front().second;
				last+=by*q.front().second-td;
				q.front().first-=by;
				td=0;
			}else{
				td-=tmp;
				q.pop_front();
			}
		}
		if(td){ //判断
			return 0;
		}
	}
	return 1;
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	IO;
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		for(int i=1;i<=n;i++){
			cin>>b[i];
		}
		int l=1,r=1e12,ans=0;
		while(l<=r){ //二分答案
			int mid=(l+r)/2;
			if(check(mid)){
				ans=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：__maqiyue (赞：0)

又有题可以发题解啦。
## 题目大意
第 $i$ 天可以收入 $b_i$，1块可以换 $a_i$ 个游戏币，每个游戏币能去玩无梦，问每天最多玩多少。
## 思路
显然，这道题具有单调性，所以可以用二分。

那 `check` 该如何考虑？  
1. 单调栈，记录一个 $p_i$，为第 $i$ 天的下一个更优的 $a_i$（即 $a_{p_i} > a_i$）。
2. 贪心，尽量在 $a_i$ 大的天购买更多的游戏币。
3. 验证，如果今天的钱都不够满足今天的需求（也就是玩 $mid$ 次），就直接返回 `false`。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//不开long long见祖宗
int n, a[1000010], b[1000010], p[1000010];
bool check(int x)
{
    int now = 0, sum = 0;//now为当天可以玩的次数，sum为当前有的钱
    for(int i = 1; i <= n; i++)
    {
        sum += b[i];//增加钱
        if(p[i])//如果后面有比今天a[i]更优的
        {
            //我的a_i是在i~p[i]中最优的
            int need = (p[i] - i) * x;
            if(now < need)//如果当前不够
            {
                int t = need - now;
                int buy = min((t + a[i] - 1) / a[i], sum);
                now += buy * a[i];
                sum -= buy;
            }
        }
        else
            now += sum * a[i], sum = 0;//当前最优，全部兑换完
        now -= x;
        if(now < 0) return false;
    }
    return true;
}
int binary()
{
    int l = 0, r = 1e12, mid, ans = -1;
    while(l <= r)
    {
        mid = (l + r) / 2;
        if(check(mid)) l = mid + 1, ans = mid;
        else r = mid - 1;
    }
    return ans;
}
signed main()
{
    int T;
    cin >> T;
    while(T--)
    {
        cin >> n;
        for(int i = 1; i <= n; i++)
            cin >> a[i];
        for(int i = 1; i <= n; i++)
            cin >> b[i];
        /*预处理p*/
        stack<int> s;
        for(int i = n; i >= 1; i--)
        {
            while(!s.empty() && a[s.top()] <= a[i]) s.pop();
            if(s.empty()) p[i] = 0;
            else p[i] = s.top();
            s.push(i);
        }
        /*******/
        int ans = binary();
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：lzdll (赞：0)

## 分析

答案看上去很有单调性，分析一下发现它就是有单调性。因为如果每天 $x$ 局可以，那么 $x-1$ 局也可以，只需买一样的币，花相同的钱，但每天少玩一局就可以了。

所以只需判断每天 $x$ 局行不行。因为每天的价格不同，所以把钱留到能买更多的天再买肯定更优。

我们遍历每一天，每一次往后第一个 $a_i$ 比它大的。

+ 如果找不到，那太好了，花光所有的钱来买币。

+ 如果能找到，那就看看现在的币能不能维持到那一天。如果能的话，那也太好了，今天不用买；但是如果没有那么多币，那就有些可悲了。

对于这种情况，首先，它找到的是第一个 $a_i$ 比它大的，所以它们之间所有的 $a_i$ 都比这一位的小，所以如果今天能解决，就不要等到明天。值得注意的一点是，我们只需把币买到够用就行了。

但是，如果今天把所有钱用光也没法解决，那就只能把钱用光了，以后的事以后再说。

然后每天的最后看看现在的币是不是比 $x$ 小，如果是那说明 $x$ 不行，否则令币的数量减去 $x$。

最大值那一块可以用单调栈来维护，复杂度 $O(n\log_2n)$。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define R(x) x=read()
#define N 2000005
using namespace std;
inline int read(){
	int x=0,y=1;char e=getchar();
	while(e<'0'||e>'9'){
		if(e=='-')y=-1;
		e=getchar();
	}
	while(e>='0'&&e<='9'){
		x=(x<<1)+(x<<3)+(e-'0');
		e=getchar();
	}
	return x*y;
}
int T,n,a[N],b[N];
stack<int>st;
int nxt[N];
bool check(int x){
	int money=0,B=0;
	//B是当前币数 
	for(int i=1;i<=n;++i){
		money+=b[i];
		int j=nxt[i];
		if(j==i){
			B+=money*a[i];
			money=0;
		}else{
			int need=(j-i)*x;
			if(B<need)	{
				if(B+money*a[i]<=need){
					B+=money*a[i],money=0
					/*这里大家可能还有疑惑，
					为什么不能直接跳到j呢？
					其实是可以的，但是处理起来比较复杂，
					但稍微一想就能发现这样跳，
					和直接跳到j是一样的*/
				}else{
					int t=B;
					B+=(need-B+a[i]-1)/a[i]*a[i];
					money-=(need-t+a[i]-1)/a[i];
					//这个地方有点抽象，其实就是买到need那么多 
				}
			}
		}
		B-=x;
		if(B<0){
			return 0; 
		}
	}
	return 1;
}
signed main(){
	R(T);
	while(T--){
		R(n);
		for(int i=1;i<=n;++i){
			R(a[i]);
		}
		for(int i=1;i<=n;++i){
			R(b[i]);
		}
		while(!st.empty())st.pop();
		for(int i=n;i>=1;--i){
			while(!st.empty()&&a[st.top()]<=a[i])st.pop();
			if(!st.empty())nxt[i]=st.top();
			else nxt[i]=i;
			st.push(i);
		}
		int L=0,R=0xccfccfccfccfcf,mid,ans;
		while(L<=R){
			mid=(L+R)>>1;
			if(check(mid)){
				L=mid+1;
				ans=mid;
			}else{
				R=mid-1;
			}
		}	
		cout<<ans<<"\n";
	}
	return 0;
	
}
```

## 后记

D 和 E 分数挂光，是可悲的。但是这道题我比前面的人跑的都快，所有点加起来只有 851ms。

看来“人傻常数大”也不在所有情况下都成立。

---

## 作者：_ayaka_ (赞：0)

### 思路

首先最明显的，每天消耗的游戏币 $x$ 可以二分。然后考虑如何检验当前二分的 $x$ 是否合法。

我们需要一个最优的贪心策略，最显然的是如果我们在以后可以遇到汇率更高的一天，我们肯定会想要去在汇率更高的那一天兑换游戏币。那我们可以构造出策略：

> 如果在今天以后没有比今天汇率更高的一天，则在今天把所有的钱 $s$ 全部兑换成游戏币。否则，把钱攒起来。

但也同样这个策略有一些漏洞。如果我手上的游戏币 $<x$，这意味着我在今天必须用一些钱兑换成游戏币来撑过这一天。那这显然不是最优，因为今天的汇率不一定比昨天更高，如果昨天的汇率更高，那我们应该在昨天就进行兑换。

根据这个说法来延伸一下，我们在昨天显然就能知道手上的游戏币不能撑到下一次更高汇率的那一天，那我们在昨天进行兑换就好了。考虑如何进行这个操作。

我们可以利用单调栈在 $O(n)$ 的时间复杂度内求出对于一个位置 $i$，下一个比 $a_i$ 汇率更高的一天 $nxt_i$。在这里不解释单调栈求下一个更大的原理，不了解的可以看代码。根据这个定义可以得知：

- 如果存在 $nxt_i$，则在从 $i$ 到 $nxt_i$ 这一个区间内的每一天，它们的汇率都比 $a_i$ 更低。从而我们会希望在第 $i$ 天就凑出足够撑到第 $nxt_i$ 天的游戏币。如果凑不出来，那我们也会把手上所有的钱全部兑换，毕竟反正这些钱不能存到汇率更高的第 $nxt_i$ 天，留着肯定不优。
- 如果不存在 $nxt_i$，就如同我们上文的策略，把钱全部兑换。

最后的判定也很简单，如果某一天凑不出 $x$ 枚游戏币，则我们二分出的 $x$ 太大了。如果能够顺利通过，则可能 $x$ 可以更大。

最后总时间复杂度 $O(n\log n)$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 998244853;
int T, n, a[2000005], b[2000005], nxt[2000005], l, r, ans;
stack<int> st;
bool check(int x) {
	int cst = 0, coin = 0;//cst即当前的钱数，coin即当前的游戏币数 
	for (int i = 1; i <= n; i++) {
		cst += b[i];
		if (coin < x) {
			if (coin + a[i]*cst < x) return false;
			cst -= (x - coin - 1) / a[i] + 1;
			coin += ((x - coin - 1) / a[i] + 1) * a[i];
		}//失败判定 
		if (nxt[i] == 0) {
			coin += a[i] * cst;
			cst = 0;
		} else {
			int num = (nxt[i] - i) * x;
			if (coin + a[i] * cst < num) {
				coin += a[i] * cst;
				cst = 0;
			} else if (coin < num) {
				cst -= (num - coin - 1) / a[i] + 1;
				coin += ((num - coin - 1) / a[i] + 1) * a[i];
			}
		}
		coin -= x;
	}
	return true;
}
signed main() {
	cin >> T;
	while (T--) {
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		for (int i = 1; i <= n; i++) cin >> b[i];
		for (int i = 1; i <= n; i++) {
			while (!st.empty() && a[i] > a[st.top()]) {
				nxt[st.top()] = i;
				st.pop();
			}
			st.push(i);
		}
		while (!st.empty()) {
			nxt[st.top()] = 0;
			st.pop();
		}//单调栈求下一个更大，若为0则是不存在 
		l = 0, r = 1e18;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (check(mid)) {
				ans = mid;
				l = mid + 1;
			} else r = mid - 1;
		}
		cout << ans << "\n";
		ans = 0;
	}
	return 0;
}
```

---

## 作者：Wei_Han (赞：0)

挺好的题吧，场上贪心假了几次。

第一步二分答案是显然的，考虑我们已知每天消耗 $k$ 个币之后怎么做。

假设当前进行到了第 $i$ 天，保证前 $i-1$ 天都能正常进行，而到第 $i$ 天没兑换时的币不够用了，我们应该在前面哪天换币？显然应该是 $a_i$ 最大的一天，有 $a_x$ 和 $a_y$ 两天，又有 $a_y < a_x$，那么用 $a_y$ 补足的花钱数更多，假设 $a_{z} > a_x > a_y$，而且有 $z > i$，那么我们应该用最多的钱去 $a_{i+1}$ 换，那么我们就期望前面用的钱最少，所以我们在第 $i$ 天用 $a_x$ 补足，如果 $a_x$ 是整个序列中最大的，那么显然尽量多的在 $a_x$ 换最好，而不是 $a_y$，进一步就可以发现用前 $i-1$ 个中最大的补足 $i$ 永远最优。

上面是在不考虑 $b$ 的情况下的，假设 $a_i$ 是 $[1,i]$ 中最大的一个，我们令 $c_i$ 表示在第 $i$ 天能够满足的情况下的剩余钱数，那么在第 $i$ 天肯定是把 $\sum_{j=1}^{i} c_j$ 全部给到 $a_i$ 来兑换是最优的。

进一步考虑，假设有 $a_z > a_x$，且 $a_x$ 为 $(z,x]$ 中最大的一个，那么显然 $\sum_{i=z+1}^{x} c_i$ 全部给 $a_x$ 是最优的，发现我们只要维护一个单调递减的 $a_i$ 序列即可，顺便记录每个 $a_i$ 可支配的 $c_i$ 总和即可。

线段树实现就是 $2\log$ 的吧，但是显然这些操作单调队列都可以做，复杂度 $O(n\log n)$.

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define pr putchar('\n')
#define fi first
#define se second
#define pp putchar(' ')
#define pii pair<ll,ll>
#define pdi pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define pb push_back
//#pragma GCC optimize(2)
using namespace std;
//typedef int ll;
typedef long long ll;
//typedef __int128 ll;
typedef double db;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
const ll N=1e6+5,M=2e4+5,mod=1e9+7;
ll n,a[N],b[N],bb[N],aa[N];
inline bool check(ll mid)
{
	fo(1,i,n) a[i]=aa[i],b[i]=bb[i];
	deque<ll> q;
	ll now=0;
	fo(1,i,n)
	{
		while(q.size()&&a[q.back()]<=a[i]) b[i]+=b[q.back()],q.pop_back();
		q.push_back(i);
		while(q.size()&&now<mid)
		{
			ll j=q.front();
			ll op=min(b[j],(mid-now-1)/a[j]+1);
			now+=op*a[j],b[j]-=op;
			if(!b[j]) q.pop_front();
		}
		if(now<mid) return 0;
		now-=mid;
	}
	return 1;
}
inline void solve()
{
	read(n);fo(1,i,n) read(a[i]),aa[i]=a[i];fo(1,i,n) read(b[i]),bb[i]=b[i];
	ll l=0,r=1e12+10;
	while(l<r)
	{
		ll mid=l+r+1>>1;
		ll ans=check(mid);
		if(ans) l=mid;
		else r=mid-1;	
	}	
	wr(l),pr;
} 
signed main(){
	ll t;read(t);while(t--){solve();}
	return 0;
}
``````

---


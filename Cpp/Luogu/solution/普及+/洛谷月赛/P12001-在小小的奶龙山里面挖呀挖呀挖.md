# 在小小的奶龙山里面挖呀挖呀挖

## 题目背景

夏天快要到了，去兴绍奶龙山参加 ION5202 的 0p 决定探究奶龙山的性质。

## 题目描述

奶龙山内部存在复杂的奶龙山隧道，但是聪明的 0p 一眼就看出了 $n-1$ 条奶龙山隧道的结构是一颗树。其中任意两个隧道只在 $n$ 个休息点处相交，两两休息点之间都有路径联通，第 $i$ 个休息点有一个权值 $a_i$，对于每一个素数 $p$，若 $p\mid a_i$ 则说明 $p$ 公司参与了休息点建设。想要经过一个休息点，就必须和所有参与了休息点建设的公司搞好关系。

0p 有 $q$ 条心仪的路线，第 $i$ 条是从休息点 $u$ 走到休息点 $v$，对于每一条路线，0p 想知道，他需要与多少公司搞好关系才可以成功地走完这一条路线。


**请注意算法常数对时间效率的影响**。

## 说明/提示

对于 $20\%$ 的数据，满足 $n,q\leq 100$。

对于 $70\%$ 的数据，满足 $n,q\leq 1000$。

对于 $100\%$ 的数据，满足 $1\leq n,q\leq 5\times 10^4$，$1\leq a_i\leq 10^5$，$1\leq u,v\leq n$，保证给出的树合法。

## 样例 #1

### 输入

```
3 1
7 2 1
1 2
1 3
2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
10 7
9 9 8 2 4 4 3 5 3 97
1 2
1 3
3 4
5 2
6 4
7 5
9 1
10 2
3 8
4 5
2 3
4 6
2 4
1 2
4 10
1 1```

### 输出

```
2
2
1
2
1
3
1```

# 题解

## 作者：Starrykiller (赞：18)

无脑做法。

不大于 $V=10^5$ 的素数只有 $\pi(V)\sim 10^4$ 个。

考虑用一个 bitset 压下来，然后做静态树上链查询即可。我使用了点分治，时间复杂度 $\Theta((n+q)\log n\sqrt{\pi(V)}/w)=\Theta((n+q)\log n\sqrt{V/\log V}/w)$，可以通过。

---

## 作者：Milthm (赞：9)

这里给一个支持单点修改的做法。

考虑将每个 $a_i$ 分解质因数，然后用一个集合存储这些质因数。现在问题转化为了，每次给定一条路径，求路径上所有点的集合的并集大小。

这个问题可以采用树链剖分套线段树维护 bitset 实现，具体来说，用 bitset 存储每个点的集合，再用树链剖分配合线段树维护一条重链上的 bitset 的或和，就可以得到答案。

这个方法应该是支持单点修改的（虽然这题没有），时间复杂度为 $O(\frac{nV\log^2 n}{w\ln V})$，实际上跑的很快，最大点只有 $300+$ 毫秒。


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define M 50005
using namespace std;
int n,q,p[N],vis[N],t;
int cnt,son[M],id[M],fa[M],dep[M],siz[M],top[M];
void init(int n){
	for(int i=2;i<=n;++i){
		if(!vis[i])p[++t]=i;
		for(int j=1;j<=t&&p[j]*i<=n;++j){
			vis[p[j]*i]=1;
			if(i%p[j]==0)break;
		}
	}
}
bitset<10000>d[M],b[M],a[M*4];
vector<int>e[M];
void dfs1(int u,int f,int d){
	dep[u]=d;fa[u]=f;siz[u]=1;
	int maxn=-1;
	for(int v:e[u]){
		if(v==f)continue;
		dfs1(v,u,d+1);
		siz[u]+=siz[v];
		if(siz[v]>maxn)maxn=siz[v],son[u]=v;
	}
}
void dfs2(int u,int t){
	id[u]=++cnt;b[cnt]=d[u];top[u]=t;
	if(!son[u])return;
	dfs2(son[u],t);
	for(int v:e[u]){
		if(v!=fa[u]&&v!=son[u])dfs2(v,v);
	}
}
void pushup(int x){
	a[x]=a[x*2]|a[x*2+1];
}
void build(int x,int l,int r){
	if(l==r){
		a[x]=b[l];return;
	}
	int mid=(l+r)>>1;
	build(x*2,l,mid);build(x*2+1,mid+1,r);
	pushup(x);
}
bitset<10000>linshi;
void query(int x,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr){
		linshi|=a[x];return;
	}
	int mid=(l+r)>>1;
	if(ql<=mid)query(x*2,l,mid,ql,qr);
	if(qr>mid)query(x*2+1,mid+1,r,ql,qr); 
}
int qwq(int x,int y){
	linshi.reset();
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		query(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	query(1,1,n,id[x],id[y]);
	return linshi.count();
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	init(N-5);
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		int x;cin>>x;
		for(int j=1;p[j]*p[j]<=x;++j){
			if(x%p[j]==0){
				d[i][j]=1;
				while(x%p[j]==0)x/=p[j];
			}
		}
		if(x!=1)d[i][lower_bound(p+1,p+t+1,x)-p]=1;
	}
	for(int i=1;i<n;++i){
		int u,v;cin>>u>>v;e[u].push_back(v);e[v].push_back(u);
	}
	dfs1(1,0,1);dfs2(1,1);
	build(1,1,n);
	while(q--){
		int u,v;
		cin>>u>>v;
		cout<<qwq(u,v)<<'\n';
	}
	return 0;
}
```

---

## 作者：Nasaepa (赞：6)

这道题我交题解时四篇题解三篇不低于蓝。点分治，树上莫队，树剖这些怎么可能出现在一道绿上？

---

这道题可以首先转化一下，变成一道 `bitset` 按位或然后最后输出 countbit 的问题。现在就要想办通过预处理法加速按位或。具体实现就是假设 $p_i$ 是第 $i$ 小的质数，开 $n$ 个 `bitset` 叫作 $b$。如果 $p_i \mid a_j$ 就将 $b_j$ 的第 $i$ 位设置成 $1$ 否则为 $0$。

我一开始想着直接树上倍增创过去，但是树上倍增的空间复杂度带 $\log$ 导致我的代码喜提 MLE。无奈的我~~通过看题解~~想到了重剖，重剖的空间复杂度可以省掉一个 $\log$，并且由于不带修改，可以实现在线 $O(\log n)$ 单次查询。

树上倍增和树剖的具体的实现非常简单，直接写就完了。这里不做具体讲解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define N 100010
#define M 50010
#define INF 0x3f3f3f3f
#define lowbit(x) (x&-x)
#define pii pair<int,int>
#define ds bitset<10000>
int p[N],lp,n;bool np[N];// 素数
int q,u,v,pt[N];
int a;ds b[M],c[M];
int dep[M],sze[M],h[M],d[M];// 树剖
int top[M],dfn[M],dfc,ord[M];
namespace segment_tree{
    struct node{int lq,rq,lson,rson;ds val;}pn[N];int lqn = 1;
    void build(const int &x,const int &lq,const int &rq){node &now = pn[x];now.lq = lq,now.rq = rq;
        if(lq == rq){now.val = b[ord[lq]];return ;}int mid = lq + (rq - lq >> 1);now.lson = ++lqn,now.rson = ++lqn;
        build(now.lson,lq,mid),build(now.rson,mid+1,rq);now.val = (pn[now.lson].val | pn[now.rson].val);
    }
    ds query(const int &x,const int &lq,const int &rq){const node &now = pn[x];if(lq <= now.lq && now.rq <= rq)return now.val;
        if(rq <= pn[now.lson].rq)return query(now.lson,lq,rq);
        else if(lq >= pn[now.rson].lq)return query(now.rson,lq,rq);
        return query(now.lson,lq,rq) | query(now.rson,lq,rq);
    }
}using namespace segment_tree;
namespace graph{int head[M],nxt[N],to[N],cnt_edge;
    inline void connect(const int &x,const int &y){++cnt_edge;nxt[cnt_edge] = head[x],to[cnt_edge] = y;head[x] = cnt_edge;}
}using namespace graph;
void init(const int &x,const int &dad){sze[x] = 1;d[x] = dad;dep[x] = dep[dad] + 1;
    for(int edg = head[x];edg;edg = nxt[edg]){const int &v = to[edg];if(v == dad)continue;init(v,x);
        sze[x] += sze[v];if(sze[v] > sze[h[x]])h[x] = v;
    }
}
void dfs(const int &x,const int &dad){dfn[x] = ++dfc,ord[dfc] = x;if(!h[x])return ;
    top[h[x]] = top[x],c[h[x]] = c[x] | b[h[x]];dfs(h[x],x);
    for(int edg = head[x];edg;edg = nxt[edg]){const int &v = to[edg];if(v == dad || v == h[x])continue;
        c[v] = b[v];top[v] = v;dfs(v,x);
    }
}
inline ds solve(int u,int v){ds ans = 0;
    while(top[u] != top[v]){
        if(dep[top[u]] > dep[top[v]])ans |= c[u],u = d[top[u]];
        else ans |= c[v],v = d[top[v]];
    }u = dfn[u],v = dfn[v];if(u > v)swap(u,v);return ans | query(1,u,v);
}

// 主函数
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    n = 100000;// 素数
    for(int i = 2;i <= n;++i){if(!np[i])p[++lp] = i,pt[i] = lp;
        for(int j = 1;i * p[j] <= n && j <= lp;++j){np[i * p[j]] = 1;if(i % p[j] == 0)break;}
    }
    cin >> n >> q;
    for(int i = 1;i <= n;++i){cin >> a;
        for(int j = 1;j <= lp && a != 1;++j){if(a % p[j])continue;b[i][j] = 1;while(a % p[j] == 0)a /= p[j];
            if(pt[a]){b[i][pt[a]] = 1;break;}
        }
    }
    for(int i = 1;i < n;++i)cin >> u >> v,connect(u,v),connect(v,u);
    init(1,0);top[1] = 1,c[1] = b[1];dfs(1,0);build(1,1,n);
    // for(int i = 1;i <= n;++i)printf("[%d]",top[i]);
    while(q--)cin >> u >> v,cout << solve(u,v).count() << '\n';
    // cout << flush,system("pause"); // 交之前一定要把这一行注释掉！！！！！！！
    return 0;
}
```

后记：看了一眼这题的加强版发现需要树上莫队这种~~恶心~~我不会的东西。

---

## 作者：CuFeO4 (赞：6)

比题解更无脑的做法。

**请注意算法常数对时间效率的影响。**

加上 $5s$ 时限，说明如果常数够小可以通过。

发现 $10^5$ 以内的素数只有 $10^4$ 个，发现不能开 $n\times 10^4$ 的数组，那么将询问离线下来，对于每个素数考虑，树上差分维护。假设当前处理素数 $p$，记 $ct_x$ 表示 $1\sim x$ 路径上的点有多少个 $a_i$ 满足 $p$ 整除 $a_i$。这个显然可以 `dfs` $O(n)$ 更新。

但是 `dfs` 更新太慢了，考虑卡常经典操作，将树拍成 dfs 序更新即可，求 `LCA` 用的 ST 表，最大点不超过一坤秒。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,s,t,p) for(int i = s;i <= t;i += p)
#define drep(i,s,t,p) for(int i = s;i >= t;i -= p)
#ifdef LOCAL
  auto I = freopen("in.in","r",stdin),O = freopen("out.out","w",stdout);
#else
  auto I = stdin,O = stdout;
#endif
using ll = long long;using ull = unsigned long long;
using db = double;using ldb = long double;
const int N = 5e4 + 10;
#define eb emplace_back
vector<int> e[N],prime;
bitset<100010> vis;
int ct[N],n,m,a[N],u[N],v[N],dfn[N],tim,st[18][N],ans[N],lca[N],F[N],rdfn[N];
void shai(int n){
	for(int i = 2;i <= 100000; ++i){
		if(!vis[i]) prime.emplace_back(i);
		for(auto j:prime){
			if(i * j > n) break;
			vis[i * j] = true;
			if(i % j == 0) break;
		}
	}
}
void dfs(int x,int fa){
	st[0][dfn[x] = ++tim] = fa;F[x] = fa;
	rdfn[tim] = x;
	for(auto y:e[x]) if(y ^ fa) dfs(y,x);
}
int get(int x,int y){return dfn[x] < dfn[y]?x:y;}
int LCA(int x,int y){
	if(x == y) return x;
	if((x = dfn[x]) > (y = dfn[y])) swap(x,y);
	int k = __lg(y-x++);
	return get(st[k][x],st[k][y-(1<<k)+1]);
}
void pdfs(const int &now){
	for(int i = 1;i <= n; ++i){
		int x = rdfn[i];
		ct[x] = ct[F[x]];
		ct[x] += a[x]%now == 0;
	}
}
signed main(){
  cin.tie(nullptr)->sync_with_stdio(false);
	shai(100000);
	cin>>n>>m;
	for(int i = 1;i <= n; ++i) cin>>a[i];
	for(int i = 1,u,v;i < n; ++i) cin>>u>>v,e[u].eb(v),e[v].eb(u);
	dfs(1,0);
	for(int j = 1;j <= __lg(n); ++j)
		for(int i = 1;i + (1 << j) - 1 <= n; ++i)
			st[j][i] = get(st[j-1][i],st[j-1][i+(1<<(j-1))]);
	for(int i = 1;i <= m; ++i){
		cin>>u[i]>>v[i],lca[i] = LCA(u[i],v[i]);
	}
	for(auto now:prime){
		pdfs(now);
		for(int i = 1;i <= m; ++i){
			if(ct[u[i]] + ct[v[i]] - ct[lca[i]] - ct[F[lca[i]]]){
				ans[i]++;
			}
		}
	}
	for(int i = 1;i <= m; ++i) cout<<ans[i]<<'\n';
}
```

---

## 作者：水星湖 (赞：4)

考虑到每个 $a_i$ 大于 $10^4$ 的质因子至多只有一个，可以树上莫队维护路径不同数个数 （SP10707），时间复杂度 $\mathcal O(n\sqrt q)$。枚举小于 $10^4$ 的质数，对于每个质数就是要查 $q$ 条路径上是否出现过这个质数，可以前缀和做到 $\mathcal O(n+q)$，总复杂度 $ \mathcal O(n\sqrt q + \pi(\sqrt V) (n+q))$。

现在已经能过掉这道题了。但是因为这篇题解本来交的加强版，然后发现：

![](https://cdn.luogu.com.cn/upload/image_hosting/lvq1r95m.png)

因为我没写代码，写了发现真卡不过（5.6s）。

怎么办呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/6yyh2f63.png)

这样复杂度就是 $ \mathcal O(n\sqrt q + \pi(\sqrt[3]V) (n+q))$，而且还可以保证莫队修改常数比较小。

最优解第二。

让我们膜拜 [Cai](https://www.luogu.com.cn/user/21784) 老师/bx

---

## 作者：251Sec (赞：4)

没实现，口胡一下。

考虑树分块。在树上取 $O(\sqrt n)$ 个关键点使得关键点构成虚树且相邻关键点之间距离为 $O(\sqrt n)$ 级别。预处理所有关键点对之间质因子的 bitset，询问时只需找到对应的两个整块 bitset 或起来然后加入 $O(\sqrt n \omega(V))$ 个散点。

总复杂度 $O(n \sqrt n \omega(V)+q(\frac{V}{w\log V}+\sqrt n\omega(V)))$。

---

## 作者：jz20250121 (赞：2)

### 题意
有一个带点权的树，问能整除两点路径中点的质数个数。
### 思路
预处理出能每个点能被整除的质数，用树上前缀和维护，  
这样查询时只用算一遍 LCA 就可以了，每次查询只用 $\mathcal{O(\log n)}$ 查询答案了。  
#### 树上前缀和
$q_x$ 代表代表点 $x$ 到根节点的权值和  
要计算点 $x$ 到 $y$ 路径上的权值和就可以用这个式子算 

$$q_x+q_y-q_{p}-q_{fa_p}$$

$p$ 为 $x$ 和 $y$ 的 LCA，$fa_x$ 是 $x$ 的父亲节点  
![](https://cdn.luogu.com.cn/upload/image_hosting/b6x5esv2.png)

在这道题中我们可以设$qzh_{x,y}$ 为点 $x$ 到根节点路径上第 $y$ 个质数的数量来计算两点之间的质数个数了。

### 优化
但是我们发现 $10^5$ 中有 $10^4$ 个质数，$5\times10^8$ 的 int 是开不下的，所以可以离线依次处理每一个质数。  
不过常数又有点太大了，所以在算前缀和时可以用 dfn 序代替 dfs。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,maz,man,cnt;
int r[50005];
int zs[10005];
bool flag[100005];
int qzh[50004];
int tp[50004][30];
int d[50004];
int dfn[50005];
queue<int>qq;
struct qzh
{
	int x,y,ans,p;
}s[50005];
vector<int>a[50004];
void dfs_yby(int o,int fa)//预处理dfn序和一些算LCA需要的 
{
	dfn[++cnt]=o;
	d[o]=d[fa]+1;
	tp[o][0]=fa;
	for(int i=0;i<a[o].size();i++)
	{
		if(a[o][i]!=fa)
		{
			dfs_yby(a[o][i],o);
		}
	}
}
int LCA(int o,int u)//倍增求LCA 
{
	if(d[o]>d[u])
	{
		swap(o,u);
	}
	for(int i=man;i>=0;i--)
	{
		if(d[tp[u][i]]>=d[o])
		{
			u=tp[u][i];
		}
	}
	if(o==u)
	{
		return o;
	}
	for(int i=man;i>=0;i--)
	{
		if(tp[o][i]!=tp[u][i])
		{
			o=tp[o][i];
			u=tp[u][i];
		}
	}
	return tp[o][0];
}
int main()
{
	ios::sync_with_stdio(0);//优化常数 
	cin.tie(0);
	cout.tie(0);
	for(int i=2;i<=100000;i++)
	{
		if(flag[i]==0)
		{
			zs[++maz]=i;
			for(int j=2;j*i<=100000;j++)
			{
				flag[j*i]=1;
			}
		}
	}
	cin>>n>>q;
	man=log2(n)+1;
	for(int i=1;i<=n;i++)
	{
		cin>>r[i];
	}
	for(int i=1;i<n;i++)
	{
		int o,u;
		cin>>o>>u;
		a[o].push_back(u);
		a[u].push_back(o);
	}
	dfs_yby(1,0);
	for(int i=1;i<=man;i++)
	{
		for(int j=1;j<=n;j++)
		{
			tp[j][i]=tp[tp[j][i-1]][i-1];//倍增需要的 
		} 
	}
	for(int i=1;i<=q;i++)
	{
		cin>>s[i].x>>s[i].y;
		s[i].p=LCA(s[i].x,s[i].y);
	}
	for(int i=1;i<=maz;i++)
	{
		for(int j=1;j<=n;j++)
		{
			qzh[dfn[j]]=qzh[tp[dfn[j]][0]]+(r[dfn[j]]%zs[i]==0);//用dfn序代替dfs 
		}
		for(int j=1;j<=q;j++)
		{
			if(qzh[s[j].x]+qzh[s[j].y]-qzh[s[j].p]-qzh[tp[s[j].p][0]]>0)//计算第j个询问是否有第i个质数 
			{
				s[j].ans++;//记录答案 
			}
		}
	}
	for(int i=1;i<=q;i++)
	{
		cout<<s[i].ans<<endl;
	}
	return 0;
}
```

---

## 作者：BitByBit (赞：2)

### 前言
树剖学了人要傻掉的，想不到别的思路了。
### 题意
求树上两点间路径上的点的点权的不同的质因数个数。
### 思路
那显然树剖啊。  
线段树每个点都是一个 bitset ，$100000$ 以内有 $9592$ 个质数，bitset 开 $10000$ 就可以了。线段树维护区间 bitor 和，不需要修改。  
时间复杂度 $\Theta(\frac{mn\log^2n}{\omega})$，其中 $m$ 表示点权值域中的质数个数。
### 实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=50010,M=100010,B=10010;
ll n,m,dfn,cnt;
ll Dep[N],Fa[N],hSon[N],Size[N],Dfn[N],Rank[N],Top[N];
bitset<B>Val[N],T[N<<2];
vector<ll>G[N];
//树剖板子
void dfs1(ll x,ll f)
{
	Dep[x]=Dep[f]+1;
	Fa[x]=f;
	hSon[x]=-1;
	Size[x]=1;
	for(ll y:G[x])
	{
		if(y==f)continue;
		dfs1(y,x);
		Size[x]+=Size[y];
		if(hSon[x]==-1||Size[y]>Size[hSon[x]])
			hSon[x]=y;
	}
}
void dfs2(ll x,ll f)
{
	Top[x]=f;
	Dfn[x]=++dfn;
	Rank[dfn]=x;
	if(hSon[x]==-1)return;
	dfs2(hSon[x],f);
	for(ll y:G[x])
	{
		if(y==hSon[x]||y==Fa[x])continue;
		dfs2(y,y);
	}
}
//线段树板子
inline ll ls(ll p)
{
	return p<<1;
}
inline ll rs(ll p)
{
	return p<<1|1;
}
inline void pushup(ll p)
{
	T[p]=T[ls(p)]|T[rs(p)];
//维护 bitor 和
}
void build(ll p,ll pl,ll pr)
{
	if(pl==pr)
	{
		T[p]=Val[Rank[pl]];
		return;
	}
	ll mid=(pl+pr)>>1;
	build(ls(p),pl,mid);
	build(rs(p),mid+1,pr);
	pushup(p);
}
bitset<B>query(ll L,ll R,ll p,ll pl,ll pr)
{
	if(L<=pl&&pr<=R)return T[p];
	bitset<B>res;
	res.reset();
	ll mid=(pl+pr)>>1;
	if(L<=mid)res|=query(L,R,ls(p),pl,mid);
	if(R>mid)res|=query(L,R,rs(p),mid+1,pr);
	return res;
}
ll query(ll x,ll y)
{
	bitset<B>res=0;
	while(Top[x]!=Top[y])
	{
		if(Dep[Top[x]]<Dep[Top[y]])swap(x,y);
		res|=query(Dfn[Top[x]],Dfn[x],1,1,n);
		x=Fa[Top[x]];
	}
	if(Dep[x]>Dep[y])swap(x,y);
	res|=query(Dfn[x],Dfn[y],1,1,n);
	return res.count();
}
bitset<M>P;
ll Prm[B];
void seive(ll n)
//埃氏筛
{
	P.set();
	P[0]=P[1]=0;
	for(int i=2;i<=sqrt(n);i++)
		if(P[i])
			for(int j=i;j<=n/i;j++)
				P[i*j]=0;
	for(int i=2;i<=n;i++)
		if(P[i])
			Prm[++cnt]=i;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	seive(100000);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		ll x;
		cin>>x;
		for(int j=1;j<=cnt;j++)
			if(x%Prm[j]==0)
				Val[i][j]=1;
	}
	for(int i=1;i<=n-1;i++)
	{
		ll x,y;
		cin>>x>>y;
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	while(m--)
	{
		ll x,y;
		cin>>x>>y;
		cout<<query(x,y)<<'\n';
	}
}
```

---

## 作者：Sunrise_beforeglow (赞：2)

看到 $1\le n\le 5\times 10^4$，直接树上莫队。

我们可以按照欧拉序将树压成一个序列，然后变成了区间莫队。

这样，我们只需要跑一个树上莫队板子就行，在添加一个数时，就可以枚举它的每个质因子，然后统计答案。

但是枚举质因子是 $O(\sqrt{V})$ 的，$V$ 是值域，于是我们就可以跑一遍质数筛，求出每个数拥有的最小或最大质因子，然后就可以暴力除掉一个质因子，剩下的继续求即可。

这样时间复杂度就成了 $O(\log_2V)$ 因为一个数每次最少都要除掉一个 $2$。

总时间复杂度 $O(n\sqrt{n}\log_2V)$，最大的点 $2$ 秒不到。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,q,a[50005],len,dfn[100005],tot,s[100005],t[100005];
int u,v,pa[50005][25],dep[50005];
int cnt[100005],sum,maxn[100005],use[100005],ans[50005];
bool f[100005];
vector<int>g[50005];
struct node
{
    int l,r,lca,id;
}x[50005];
void dfs(int x,int fa)
{
    s[x]=++tot;//欧拉序
    dfn[tot]=x;
    pa[x][0]=fa;
    for(int i=1;i<=20;i++)pa[x][i]=pa[pa[x][i-1]][i-1];
    for(auto i:g[x])
    {
        if(i==fa)continue;
        dep[i]=dep[x]+1;
        dfs(i,x);
    }
    t[x]=++tot;
    dfn[tot]=x;
}
int lca(int x,int y)
{
    if(dep[x]<dep[y])swap(x,y);
    int tmp=dep[x]-dep[y];
    for(int i=20;i>=0;i--)if((tmp>>i)&1)x=pa[x][i];
    if(x==y)return x;
    for(int i=20;i>=0;i--)
    {
        if(pa[x][i]!=pa[y][i])
        {
            x=pa[x][i];
            y=pa[y][i];
        }
    }
    return pa[x][0];
}
bool cmp(node a,node b)
{
    if(a.l/len!=b.l/len)return a.l<b.l;
    else return a.r>b.r;
}
void add(int x)
{
    int u=a[x];
    while(u>1)
    {
        int p=maxn[u];
        if(!cnt[p])sum++;
        cnt[p]++;
        while(u>1&&u%p==0)u/=p;//暴力除掉每个质因子
    }
}
void del(int x)
{
    int u=a[x];
    while(u>1)
    {
        int p=maxn[u];
        cnt[p]--;
        if(!cnt[p])sum--;
        while(u>1&&u%p==0)u/=p;
    }
}
void calc(int x)
{
    int u=dfn[x];
    if(!use[u])add(u);
    else del(u);
    use[u]=!use[u];
}
int main()
{
    memset(f,true,sizeof(f));
    for(int i=2;i<=1e5;i++)
    {
        if(f[i])
        {
            maxn[i]=i;
            for(int j=2;j*i<=1e5;j++)
            {
                f[i*j]=false;
                maxn[i*j]=i;//求每个数最大的质因子
            }
        }
    }
    cin>>n>>q;
    len=sqrt(2*n);
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<n;i++)
    {
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1,0);
    for(int i=1;i<=q;i++)
    {
        cin>>u>>v;
        if(s[u]>s[v])swap(u,v);
        int LCA=lca(u,v);
        if(LCA==u)x[i]={s[u],s[v],0,i};//树上莫队板子
        else x[i]={t[u],s[v],LCA,i};
    }
    sort(x+1,x+q+1,cmp);
    int l=1,r=0;
    for(int i=1;i<=q;i++)
    {
        while(x[i].l<l)calc(--l);
        while(r<x[i].r)calc(++r);
        while(l<x[i].l)calc(l++);
        while(x[i].r<r)calc(r--);
        if(x[i].lca)add(x[i].lca);
        ans[x[i].id]=sum;
        if(x[i].lca)del(x[i].lca);
    }
    for(int i=1;i<=q;i++)cout<<ans[i]<<"\n";
    return 0;
}
```

---

## 作者：arrow_king (赞：2)

**同步发表在 P12003 中。**

感觉十分套路，但是为啥赛时被卡空间了/yiw

哦我为啥开了 $O(\frac{n\pi(V)}{w})$ 的空间，不卡我卡谁。

由于原版正解是加强版正解的一部分，所以两个都写了。

# 普通版

$n\le5\times10^4$，$V=\max\{a_i\}\le10^5$。

考虑筛出 $V$ 以内的所有质数 $p_1,p_2,\dots,p_{\pi(V)}$，并用一个二维数组 $b_{u,i}$ 表示 $a_u$ 是否有 $p_i$ 这个质因子。显然可以写 bitset 来存储。

考虑到一条路径上质因子数量就是每个节点 bitset 或起来之后的 popcount，用树剖维护这个就可以了，时间复杂度 $O(\frac{q\log^2n\pi(V)}{w})$。

# 加强版

$n\le3\times10^5,V\le10^8$。

一个套路的有关质因子的 trick 就是值域分治，用莫队搞 $>\sqrt V$ 的质因子，用上面 bitset 的算法搞 $\le\sqrt V$ 的质因子。

此时时间复杂度是 $O(n\sqrt q+\frac{q\log^2n\pi(\sqrt V)}{w})$，精细实现一下就可以把后面那一项的两只 $\log$ 去掉一个（只用线段树查询最后的一次不是跳到链顶的查询，可以预处理出来跳到链顶的答案）。

如果空间限制宽裕，也可以用倍增写上面的树链查询，复杂度同样是单 $\log$。可惜空间复杂度是 $O(\frac{n\sqrt V\log n}w)$，喜提 MLE（赛时的版本也过不了）。

代码奇丑无比，常数大到飞起，恐污列位看官之眼，故不外传。

[record](https://www.luogu.com.cn/record/210864283)

---

## 作者：yzq_yzq (赞：2)

考虑阈值分治，对于小于等于 $\sqrt V$ 的质因子维护树上差分，对于 $>\sqrt V$ 的质因子每个数最多只有一个，于是是树上路径数颜色的板子，树上莫队即可。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define u32 unsigned int
#define u64 unsigned ll
#define i128 __int128
#define i16 short
#define db double
#define lb long db
#define fv inline void
#define u16 unsigned i16
#define rep(i, x, y) for (int i = (x); i <= (y); ++i)
#define drep(i, x, y) for (int i = (x); i >= (y); --i)
#define pb push_back
#define pii pair<int, int>
#define fi first
#define se second
#define mem(a, b) memset((a), b, sizeof(a))
#define ALL(a) (a).begin(), (a).end()
#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;
template <typename T> inline void cmin(T &x, T y) { if(x > y) x = y; }
template <typename T> inline void cmax(T &x, T y) { if(x < y) x = y; }
template <typename T> struct LSH {
	vector<T> b; LSH() { b.clear(); }
	inline void ins(T x) { b.pb(x); }
	inline void build() { sort(ALL(b)), b.erase(unique(ALL(b)), b.end()); }
	inline int q(T x) { return lower_bound(ALL(b), x) - b.begin(); }
	inline T operator[](int x) { return b[x]; }
};
void Fin(string s) { freopen((s + ".in").c_str(), "r", stdin); }
void Fout(string s) { freopen((s + ".out").c_str(), "w", stdout); }
const int N = 100005, SQ = 315;
int n, q, len, a[N], vis[N], p[N], id[N], tot, val[N], s[70][N];
vector<int> vec[N], G[N];
int res[N];
struct Tree {
	int fa[N], top[N], dep[N], son[N], siz[N];
	void dfs1(int u, int f) {
		fa[u] = f, dep[u] = dep[f] + 1;
		siz[u] = 1;
		for(int v : G[u]) {
			if(v == f) continue;
			dfs1(v, u), siz[u] += siz[v];
			if(siz[v] > siz[son[u]]) son[u] = v;
		}
	}
	void dfs2(int u, int t) {
		top[u] = t;
		if(son[u]) dfs2(son[u], t);
		for(int v : G[u]) {
			if(v == fa[u] || v == son[u]) continue;
			dfs2(v, v);
		}
	}
	inline int lca(int u, int v) {
		while(top[u] != top[v]) {
			if(dep[top[u]] < dep[top[v]]) swap(u, v);
			u = fa[top[u]];
		}
		return dep[u] < dep[v] ? u : v;
	}
} T;
inline void dfs(int i, int u, int f) {
	s[i][u] += s[i][f];
	for(int v : G[u]) {
		if(v == f) continue;
		dfs(i, v, u);
	}
}
int f1[N], f2[N], cnt[N], sum[N], ans, pos[N], sq = 200;
inline void dfs2(int u, int f) {
	a[++len] = u, f1[u] = len;
	for(int v : G[u]) {
		if(v == f) continue;
		dfs2(v, u);
	}
	a[++len] = u, f2[u] = len;
}
inline void del(int x) {
	if(!val[x]) return;
	cnt[x]--;
	if(cnt[x] == 1) ans += (++sum[val[x]] == 1);
	if(cnt[x] == 0) ans -= (--sum[val[x]] == 0);
}
inline void add(int x) {
	if(!val[x]) return;
	cnt[x]++;
	if(cnt[x] == 1) ans += (++sum[val[x]] == 1);
	if(cnt[x] == 2) ans -= (--sum[val[x]] == 0);
}
struct node {
	int l, r, x, id;
} Q[N];
int main() {
//	Fin("T589103");
//	Fout("sb");
	vis[1] = 1;
	int lim = 0;
	rep(i, 2, N - 1) {
		if(!vis[i]) {
			for(int j = i << 1; j < N; j += i)
				vis[j] = 1;
			p[++tot] = i, id[i] = tot;
			lim += (i <= SQ);
		}
	}
	fastio; cin >> n >> q;
	rep(i, 1, n) cin >> a[i];
	rep(i, 2, n) {
		int u, v;
		cin >> u >> v;
		G[u].pb(v), G[v].pb(u);
	}
	T.dfs1(1, 0), T.dfs2(1, 1);
	rep(i, 1, n) {
		for(int j = 1; j * j <= a[i]; ++j) {
			const auto ins = [&](int x) { 
				if(vis[x]) return;
				if(x > SQ) val[i] = x;
				else s[id[x]][i]++;
			};
			if(a[i] % j == 0) ins(j);
			if(a[i] % j == 0 && j * j != a[i]) ins(a[i] / j);
		}
	}
	rep(i, 1, lim) dfs(i, 1, 0);
	dfs2(1, 0);
	rep(i, 1, q) {
		int u, v;
		cin >> u >> v;
		if(f1[v] < f1[u]) swap(u, v);
		int L = T.lca(u, v), ans = 0;
		rep(i, 1, lim) ans += (s[i][u] + s[i][v] - s[i][L] - s[i][T.fa[L]] > 0);
		res[i] += ans;
		if(L == u) Q[i].l = f1[u], Q[i].r = f1[v], Q[i].x = 0;
		else Q[i].l = f2[u], Q[i].r = f1[v], Q[i].x = L; Q[i].id = i;
	}
	rep(i, 1, len) pos[i] = (i - 1) / sq + 1;
	int l = 1, r = 0;
	sort(Q + 1, Q + 1 + q, [&](node x, node y) {
		if(pos[x.l] == pos[y.l]) return x.r < y.r;
		return x.l < y.l;
	});
	rep(i, 1, q) {
		while(r < Q[i].r) add(a[++r]);
		while(l > Q[i].l) add(a[--l]);
		while(r > Q[i].r) del(a[r--]);
		while(l < Q[i].l) del(a[l++]);
		if(Q[i].x) add(Q[i].x);
		res[Q[i].id] += ans;
		if(Q[i].x) del(Q[i].x);
	}
	rep(i, 1, q) cout << res[i] << '\n';
	return 0;
}
```

---

## 作者：LJG_IS_MY_IDOL (赞：0)

给出一个与官方题解不一样的做法。

直接对每一个结点的值进行试除法分解质因数，然后将该节点的质因子用 bitset 来储存。然后采用树链剖分＋线段树实现在线查询即可。

看了一下已经发布的题解，发现与一楼二楼两位大哥的思路大同小异，那么具体实现就不细讲了（求放过 orz


```cpp
#include<bits/stdc++.h>
#define int long long
#define ls p<<1
#define rs (p<<1|1)
using namespace std;
constexpr int N=1e5+10;
vector<int> g[N];
int prime[N],e,loc[N];
int n,q;
int siz[N],son[N],f[N],top[N],id[N],dep[N],num;
bool vis[N]={1,1};
bitset<10010> t[N<<2],b[N],c[N];

void dfs1(int x,int fa);
void dfs2(int x,int tp);
void build(int p,int l,int r);
void isPrime();
bitset<10010> query(int x,int y,int p,int l,int r);
bitset<10010> get_num(int x,int y);

signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >> n >> q;
	isPrime();
	for (int i=1;i<=n;++i)
	{
		int x;
		cin >> x;
		for (int j=1;prime[j]*prime[j]<=x;++j)
		{
			if (x%prime[j] == 0)
			{
				c[i].set(j);
				while (x%prime[j] == 0)
					x /= prime[j];
			}
		}
		if (x > 1)
			c[i].set(loc[x]);
	}
	for (int i=1;i<n;++i)
	{
		int u,v;
		cin >> u >> v;
		g[u].emplace_back(v);
		g[v].emplace_back(u);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	while (q--)
	{
		int u,v;
		cin >> u >> v;
		cout << get_num(u,v).count() << '\n';
	}
	return 0;
}

void dfs1(int x,int fa)
{
	dep[x] = dep[fa]+1;
	siz[x] = 1;
	f[x] = fa;
	for (const auto y:g[x])
	{
		if (y == fa)
			continue;
		dfs1(y,x);
		siz[x] += siz[y];
		if (!son[x] || siz[son[x]]<siz[y])
			son[x] = y;
	}
}

void dfs2(int x,int tp)
{
	top[x] = tp;
	id[x] = ++num;
	b[num] = c[x];
	if (!son[x])
		return;
	dfs2(son[x],tp);
	for (const auto y:g[x])
	{
		if (y==f[x] || y==son[x])
			continue;
		dfs2(y,y);
	}
}

void build(int p,int l,int r)
{
	if (l == r)
	{
		t[p] = b[l];
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	t[p] = t[ls]|t[rs];
}

bitset<10010> query(int x,int y,int p,int l,int r)
{
	if (x<=l && y>=r)
		return t[p];
	int mid=l+r>>1;
	bitset<10010> bt;
	if (x <= mid)
		bt |= query(x,y,ls,l,mid);
	if (y > mid)
		bt |= query(x,y,rs,mid+1,r);
	return bt;
}

bitset<10010> get_num(int x,int y)
{
	bitset<10010> bt;
	while (top[x] != top[y])
	{
		if (dep[top[x]] < dep[top[y]])
			swap(x,y);
		bt |= query(id[top[x]],id[x],1,1,n);
		x = f[top[x]];
	}
	if (dep[x] > dep[y])
		swap(x,y);
	bt |= query(id[x],id[y],1,1,n);
	return bt;
}

void isPrime()
{
	for (int i=2;i<100000;++i)
	{
		if (!vis[i])
		{
			prime[++e] = i;
			loc[i] = e;
		}
		for (int j=1;j<=e;++j)
		{
			if (i*prime[j] >= 100000)
				break;
			vis[i*prime[j]] = 1;
			if (i%prime[j] == 0)
				break;
		}
	}
}
```

ps ：比赛时担心 bitset 会爆内存，于是采用整型变量按位或维护节点的值，结果样例对了，而比赛结束后惊喜（吓）地发现爆 0 了 qaq

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18806211)

奶浓~~~

## 题意概述

题目给出一个含有 $n$ 个休息点的树，每个点有一个数值 $a_i$。数值的每个质因子代表一个参与该点建设的“公司”。对于每条从 $u$ 到 $v$ 的路径，我们需要统计路径上所有休息点所涉及的**不同**公司的数量，即不同质因子的个数。

## Solution
思维难度不大，简单糊一下。

使用筛法预先求出较小的质数。对于每个点的数值 $a_i$ 分解质因数（注意同一质因子重复只记一次），并将质因子映射为一个编号，方便后续统计。

然后对树做一次 DFS，记录每个节点的进入时间 $st$ 和退出时间 $en$。这样，每个节点在 DFS 欧拉序中会出现两次，构造出一维数组。预处理出每个节点的祖先信息，便于快速求出任意两点的 LCA。

每条查询路径从 $u$ 到 $v$，可以通过 LCA 分解成两个区间，如果 $u$ 是 LCA，则区间就是 $[st[u], st[v]]$，否则需要额外考虑 LCA 节点。将所有查询离线排序，按照莫队的思想在欧拉序上维护当前区间，并利用区间增删操作更新答案。每次添加或删除一个节点时，更新该节点对应的质因子出现次数，从而判断某个公司是否第一次出现或最后一次消失，从而维护当前区间中质因子的个数。

如果查询路径的 LCA 不在构造的欧拉区间中，需要额外单独处理 LCA 节点，将其质因子计入答案后再恢复现场。

时间复杂度 $O((n+q) \sqrt{n})$，可以被接受。

[link](https://www.luogu.com.cn/record/211408342)

---

## 作者：Esucu (赞：0)

这题是问路径上数的质因数的并集大小，所以对于每个质因数分别考虑它有没有出现过。

令 $V$ 表示 $a_i$ 的值域。运用经典套路，把质因数以 $\sqrt V$ 为界分开考虑。

对于大于 $\sqrt V$ 的质因数，每个点上至多有一个，所以用树上莫队数颜色的方法维护就行，不详细讲。

对于小于等于 $\sqrt V$ 的质因数，总的种类数不会很多，也就是 $316$ 以内的质数个数，只有 $65$ 个。所以对于每个点，用 bitset 维护其质因数集合，再用倍增来合并路径信息。

具体的，令 $f_{u,k}$ 表示树上 $u$ 节点到其 $2^k$ 级祖先路径上的数的质因数的并集，转移是容易的。查询路径信息时，因为合并的区间可以有重复，所以可以使用类似 st 表的方式来合并，具体见代码。

时间复杂度 $O(n\sqrt V+n\sqrt q+\frac{n\pi(\sqrt V)\text{log}\ n+q\pi(\sqrt V)}{w})$。其中 $\pi(\sqrt V)$ 指 $\sqrt V$ 以内的质数个数，$w$ 指 $64$。

代码：


```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int V=2e5+5,v=1e5,B=320;
int isp[V],tot,el[V],st[V],ed[V],b[V],cnt,mi[V],pos[V],t[V],a[V],n,m,x,y;
int dep[V],to[V],fa[V][16],rx,ry,dex,dey,kx,ky,lg[V],ans[V],vis[V],res,kc,lca,yx,yy;
bool h[V];
vector<int> g[V];
bitset<128> f[V][16],p;
struct mo{
	int l,r,ex,id;
}q[V];
bool cmb(mo x,mo y){
	if(pos[x.l]!=pos[y.l]) return pos[x.l]<pos[y.l];
	if(pos[x.l]&1) return x.r<y.r;
	return x.r>y.r;
}
void init(){
	for(int i=2;i<=v;i++){
		if(!h[i]){
			isp[++tot]=i;
			if(i<=B) to[i]=tot;
		}
		for(int j=1;j<=tot&&i*isp[j]<=v;j++){
			h[i*isp[j]]=1;
			if(i%isp[j]==0) break;
		}
	}
	tot=0;
}
void dfs(int x,int y){
	el[++tot]=x; st[x]=tot;
	dep[x]=dep[y]+1;
	for(int j:g[x]){
		if(j==y) continue;
		fa[j][0]=x;
		for(int k=1;k<16;k++) fa[j][k]=fa[fa[j][k-1]][k-1],f[j][k]=(f[j][k-1]|f[fa[j][k-1]][k-1]);
		dfs(j,x);
	}
	el[++tot]=x; ed[x]=tot;
}
int kfa(int x,int k){//x 的 k 级祖先 
	for(int i=15;~i;i--) if(k>=(1<<i)) x=fa[x][i],k-=(1<<i);
	return x;
}
int LCA(int x,int y,int id){
	if(st[x]>st[y]) swap(x,y); rx=x,ry=y;
	if(dep[x]<dep[y]) swap(x,y); yx=x,yy=y;
	for(int i=15;~i;i--) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	if(x==y) lca=x,q[id]={st[rx],st[ry],0,id};
	for(int i=15;~i;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	if(x!=y) lca=fa[x][0],q[id]={ed[rx],st[ry],lca,id};
	//找 lca，并处理出莫队的 q 数组 
	dex=dep[yx]-dep[lca]+1,dey=dep[yy]-dep[lca]+1;
	kx=lg[dex],ky=lg[dey];
	p.reset();
	p|=f[yx][kx]|f[yy][ky];
	p|=f[kfa(yx,dex-(1<<kx))][kx]|f[kfa(yy,dey-(1<<ky))][ky];
	//倍增跳合并，这里只跳了常数次 
	return p.count();
}
void upd(int x){
	if(a[x]==1) return;
	//a[x] 不等于 1，就是有大于 B 的质因子 
	if(!vis[x]) res+=(++t[a[x]]==1);
	else res-=(--t[a[x]]==0);
	vis[x]^=1;
}
void mo_algo(){
	kc=(2*n>=sqrt(m)?2*n/sqrt(m):sqrt(2*n));
	for(int i=1;i<=n*2;i++) pos[i]=(i+kc-1)/kc;
	sort(q+1,q+m+1,cmb);
	for(int i=1,l=1,r=0;i<=m;i++){
		while(l>q[i].l) upd(el[--l]);
		while(r<q[i].r) upd(el[++r]);
		while(l<q[i].l) upd(el[l++]);
		while(r>q[i].r) upd(el[r--]);
		if(q[i].ex) upd(q[i].ex);
		ans[q[i].id]+=res;
		if(q[i].ex) upd(q[i].ex);
	}
}
signed main(){
	init();
	scanf("%d%d",&n,&m);
	for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		for(int j=2;j<=B;j++) while(a[i]%j==0) f[i][0][to[j]]=1,a[i]/=j;
		//找出每个数的质因子集合
	}
	for(int i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		g[x].pb(y); g[y].pb(x);
	}
	dfs(1,0);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		ans[i]=LCA(x,y,i);//小于根号 V 的部分 
	}
	mo_algo();//大于根号 V 的部分 
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：reductt (赞：0)

来一个人傻常数大的做法。

题意可以简化为对于一个序列 $a$， 有几个素数 $p$ 满足至少一个 $a_i$ 能被 $p$ 整除。

我们直接树剖，用线段树维护一个连续区间内的答案。

具体地，可以使用 `bitset` 来维护每一个叶子节点能被哪几个质数整除，然后合并信息的时候直接把左右儿子的 `bitset` 或起来，使用 `count()` 函数统计有几个 `1`  即可。

听起来非常暴力，实际也非常暴力。[record](https://www.luogu.com.cn/record/211534054)


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define FOR(i, a, b) for(int i = (a); i <= (b); ++ i)
#define pb push_back

const int N = 1e5 + 10, M = 1e4 + 10;

unordered_map<int, int> rnk;
struct DS {
	int a[N], ll[N << 2], rr[N << 2], sum[N << 2]; bitset<M> w[N << 2];
	
	#define ls(x) (x << 1)
	#define rs(x) (x << 1 | 1)
	
	void readIn(int i, int x) { a[i] = x; }
	
	void up(int p) { w[p] = w[ls(p)] | w[rs(p)], sum[p] = w[p].count(); }
	
	void build(int l, int r, int p = 1) {
		ll[p] = l, rr[p] = r, sum[p] = 0;
		if(l == r) {
			int x = a[l];
			FOR(i, 2, x) if(x % i == 0) {
				w[p][rnk[i]] = 1;
				while(x % i == 0) x /= i;
			}
			sum[p] = w[p].count();
			return;
		}
		int mid = (l + r) >> 1;
		build(l, mid, ls(p)), build(mid + 1, r, rs(p)), up(p);
	}
	
	bitset<M> query(int l, int r, int p = 1) {
		if(l <= ll[p] && rr[p] <= r) return w[p];
		int mid = (ll[p] + rr[p]) >> 1; bitset<M> res;
		if(l <= mid) res |= query(l, r, ls(p));
		if(mid < r) res |= query(l, r, rs(p));
		return res;
	}
	
	#undef ls
	#undef rs
} ds;

int n, Q, a[N], siz[N], hson[N], top[N], dep[N], fa[N], dfn[N], dfn_cnt = 0;
vector<int> G[N], vec, primes; bitset<M> ans;

void dfs1(int u, int fa_) {
	fa[u] = fa_, dep[u] = dep[fa_] + 1, siz[u] = 1;
	for(int v: G[u]) {
		if(v == fa_) continue;
		dfs1(v, u), siz[u] += siz[v];
		if(siz[v] > siz[hson[u]]) hson[u] = v;
	}
}

void dfs2(int u, int t) {
	top[u] = t, dfn[u] = ++ dfn_cnt;
	if(!hson[u]) return;
	dfs2(hson[u], t);
	for(int v: G[u]) if(v != fa[u] && v != hson[u]) dfs2(v, v);
}

int query(int u, int v) {
	ans.reset();
	while(top[u] != top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		ans |= ds.query(dfn[top[u]], dfn[u]), u = fa[top[u]];
	}
	if(dep[u] < dep[v]) swap(u, v);
	ans |= ds.query(dfn[v], dfn[u]);
	return ans.count();
}

signed main() {
	FOR(x, 2, N - 1) {
		int ok = 1;
		for(int y = 2; y * y <= x; ++ y) if(x % y == 0) { ok = 0; break; }
		if(ok) primes.pb(x), rnk[x] = primes.size();
	}
	scanf("%lld%lld", &n, &Q);
	FOR(i, 1, n) scanf("%lld", &a[i]);
	FOR(i, 1, n - 1) {
		int u, v;
		scanf("%lld%lld", &u, &v);
		G[u].pb(v), G[v].pb(u);
	}
	dfs1(1, 0), dfs2(1, 1);
	FOR(i, 1, n) ds.readIn(dfn[i], a[i]);
	ds.build(1, n);
	while(Q --) {
		int u, v;
		scanf("%lld%lld", &u, &v);
		printf("%lld\n", query(u, v));
	}
	return 0;
}
```

---


# 偷上网

## 题目描述

Alice 和 Bob 生活在一个 $l \times l$ 的正方形房子里，由于 Bob 最近沉迷隔膜，Alice 决定要限制 Bob 上网的频率。

Alice 建造了 $n$ 个无线信号屏蔽器，第 $i$ 个位于 $(x_i, y_i)$，屏蔽范围为 $\frac{l}{n}$。

Bob 网瘾发作按捺不住上网的冲动，找到了你，帮他找到一个位置 $(x, y)$，使得没有被 Alice 的无线信号屏蔽器覆盖。

## 样例 #1

### 输入

```
1 1
0.000 0.000```

### 输出

```
0.999 0.999```

## 样例 #2

### 输入

```
1 2
1.000 1.000```

### 输出

```
GG```

## 样例 #3

### 输入

```
2 2
0.000 0.000
2.000 2.000```

### 输出

```
1.000 1.000```

# 题解

## 作者：Garen (赞：17)

## 洛谷5月月赛的T2。让我大开眼界！

---

Drench大佬这么说的：

---

## B. 偷上网

如果 $n = 1$，则枚举一下四个角，如果都不可行，一定无解，否则就找到了合法点。

如果 $n \geq 2$ ，则圆的总面积一定小于正方形的面积，每次随机一个点，判断是否可行。显然随机次数不会太多就会找到合法解。

---

所以有一种几乎不会被hack的算法，叫做**随机算法**！！！

### 如何取随机数？

只需要include进cstdlib，srand一个种子之后，就可以用rand()取随机数啦！

随机算法的优点是随机！我设计这种算法，即使运算100000次也根本不会超时，发现100000次还WA了一个点，直接再添一个0就可以了，并不会慢太多。时限很轻松。

### srand的种子要取什么？

随缘！比如19260817、你自己的手机号、你基友的生日等等都可以。

这么多种子随便取，导致出题人都没办法hack你！

代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn = 15;
double x[maxn], y[maxn];
double n, l;
int main()
{
	srand(19260817);
	scanf("%lf%lf", &n, &l);
	for(int i = 1; i <= n; i++) scanf("%lf%lf", &x[i], &y[i]);
	for(int i = 1; i <= 1000000; i++)
	{
		double tx = rand(), ty = rand();
		while(tx > l) tx /= 10;
		while(ty > l) ty /= 10;
		bool ok = true;
		for(int j = 1; j <= n; j++)
		{
			if(pow(tx - x[j], 2) + pow(ty - y[j], 2) < pow(l / n, 2))
			{
				ok = false;
				break;
			}
		}
		if(ok)
		{
			printf("%.3lf %.3lf\n", tx, ty);
			return 0;
		}
	}
	printf("GG\n");
	return 0;
}
```

---

## 作者：破壁人五号 (赞：7)

[博客](https://wallbreaker5th.github.io/)

这道题当时居然因为某些细节没有AC，之后看到错因才发现问题orz。

听说标算是先判断n=1，只有n=1并且四个顶点都被覆盖才可能GG。 否则不断在边界上随机取点，因为边界不可能全被覆盖。

下面进入正文：

题目链接： [https://www.luogu.org/problemnew/show/T29693](https://www.luogu.org/problemnew/show/T29693)

题目大意：在一个l*l的正方形里有n个半径为l/n的圆， 求一个不在任何一个圆里面的点。

看到这道题，第一反应：毒瘤计算几何，这辈子都别想写出标算。

然而我灵光一现，想出了一种奇葩解法：

首先把很多个Bob随机扔进房间，然后想象这些Bob被屏蔽器“挤开”。

多“挤”几次之后就很可能出现成功躲开的Bob，如果没有就认为GG。

然后我把这个思路抽象出来：

首先在正方形里面随机生成N个点，然后做T次以下操作：

遍历每一个点，判断它是不是在某一个圆内部。 如果是，求出该圆圆心到这个点的向量， 乘以一个倍数使得这个点沿着这个向量移动之后刚好脱离屏蔽器的距离。

把一个点所有向量加起来，让这个点移动。 如果出了房间或者出现NaN，让它重新在正方形里面随机选一个点。

最后输出一个不在圆中的点，如果没有，输出GG。

举一个例子：

![一个例子](https://wallbreaker5th.github.io/img/0000.PNG)

时间复杂度：$O(NTn)$（事实证明N与T调整得足够好的话可以达到0msAC）

算法正确性：看脸

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10,T=100;
const double eps=0.0000015;
int n,l;
struct point{
    double x,y; 
    void init(){
        x=rand()*rand()%(l*10)/10.0;
        y=rand()*rand()%(l*10)/10.0;
    }
};
point pb[20];
point p[N];
int main(){
    srand(time(NULL));
    double fw;
    cin>>n>>l;
    for(int i=0;i<N;i++)p[i].init();
    fw=l*1.0/n;
    for(int i=0;i<n;i++){
        cin>>pb[i].x>>pb[i].y;
    }
    for(int i=0;i<T;i++){
        for(int j=0;j<N;j++){
            double ax=0,ay=0;
            for(int k=0;k<n;k++){
                double dis=sqrt((p[j].x-pb[k].x)*(p[j].x-pb[k].x)+(p[j].y-pb[k].y)*(p[j].y-pb[k].y));
                if(dis-fw<eps){
                    double xx=(p[j].x-pb[k].x)/dis*(fw+eps),yy=(p[j].y-pb[k].y)/dis*(fw+eps);
                    ax+=xx-(p[j].x-pb[k].x);
                    ay+=yy-(p[j].y-pb[k].y);
                }
            }
            p[j].x+=ax;
            p[j].y+=ay;
            if(p[j].x<0||p[j].x>l||isnan(p[j].x)){
                p[j].init();
            }
            if(p[j].y<0||p[j].y>l||isnan(p[j].y)){
                p[j].init();
            }
            
        }
    }
    for(int i=0;i<N;i++){
        bool ok=(p[i].x>=0&&p[i].y>=0&&p[i].x<=l&&p[i].y<=l);
        for(int j=0;j<n;j++){
            if(sqrt((p[i].x-pb[j].x)*(p[i].x-pb[j].x)+(p[i].y-pb[j].y)*(p[i].y-pb[j].y))-fw<eps)ok=false;
        }
        if(ok){
            cout<<fixed<<setprecision(8)<<p[i].x<<" "<<p[i].y;
            return 0;
        }
    }
    cout<<"GG";
    return 0;
}
```

[0msAC链接](https://www.luogu.org/record/show?rid=7915475)

---

## 作者：Link_Space (赞：5)

此题大意为给出许多个点作为限制，让你在给定范围里找到一个满足以上限制的点，据此可以较为容易想到使用模拟退火

而此题有些不同，普通的模拟退火题目的calc函数大多是写一个计算答案的函数，而对于这道题需要写成一个判断是否可行的bool函数，对于每一个我们随机取到的点，判断是否可行，如果可行就走过去，并记录答案，如果不可行的话也以一定概率走过去，但此时不记录答案。

一些细节地方请看代码内注释：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<cstdlib>
using namespace std;
const int N = 1e5 + 5;
struct Node{
    double x, y;
} pos[N], ans, result;
double n, l;
bool calc(Node now)//判断目前随机到的点是否满足给定的所有限制
{
    double xx = now.x, yy = now.y;
    for (int i = 1; i <= n;i++)
    {
        double dx = xx - pos[i].x;
        double dy = yy - pos[i].y;
        if(sqrt(dx*dx+dy*dy)<=(double)l/n)
            return false;//任何一个限制不满足都代表这个点不可行
    }
    return true;
}
void SA()
{
    for (double t = l; t > 1e-15;t*=0.9975)//为满足范围限制，t从l开始，衰变系数应尽量靠近1以保证正确率
    {
        Node now;
        now.x = fmod(ans.x + fabs(((double)2 * rand() - RAND_MAX) * t), l);
        now.y = fmod(ans.y + fabs(((double)2 * rand() - RAND_MAX) * t), l);//为了保证点坐标不超过l和不小于0，此处需要用fmod和fabs
        if(calc(now))
        {
            result = now;
            ans = now;
        }//如果可行，记录答案并走过去
        else 
        {
            if((double)rand()/RAND_MAX<0.5)
                ans = now;//如果不可行，有一定概率走过去，但不记录答案
        }
    }
}
int main()
{
    scanf("%lf%lf", &n, &l);
    for (int i = 1; i <= n;i++)
    {
        scanf("%lf%lf", &pos[i].x, &pos[i].y);
        ans.x += pos[i].x, ans.y += pos[i].y;
    }
    ans.x /= n;
    ans.y /= n;//以平均值作为初始值
    while((double)clock()/CLOCKS_PER_SEC<0.8)//卡时，此题仿佛不需要
        SA();
    if (!calc(result))//如果没找到任何一点满足条件，GG
        puts("GG");
    else
        printf("%.3lf %.3lf\n", result.x, result.y);//否则输出答案
}
```


---

## 作者：su226 (赞：3)

## 前言

虽然我的思路和其他题解一样，都是找到合适的随机数并输出，但是我强烈地想安利C++的标准库，并且码字十分辛苦的，求过。

## 知识

`chrono`: C++11添加，用于时间的处理

1. 命名空间\
   `chrono`的命名空间是`std`的子命名空间`std::chrono`，嫌麻烦的同学可以交给~~热心摊主~~`using namespace std::chrono`来处理
2. 时钟\
   `chrono`共添加了3种时钟，分别是`steady_clock`、`system_clock`和`high_resolution_clock`。`steady_clock`是单调递增的时钟，给函数计时要使用它，可能和系统时间不同；`system_clock`是系统时钟，和系统时间一致；`high_resolution_clock`是最高精度的时钟，可能是`steady_clock`或者是`system_clock`的别名。作为随机数种子使用时，哪个都可以。
3. 时间点\
   调用`[时钟]::now`可以返回当前的时间点，使用`[时间点].time_since_epoch`可以得到相对与时钟开始时间的时间段。
4. 时间段\
   一个时间段对象表示一段时间，使用`[时间段].count`得到它的数值，这就是做随机数种子的数。

简写形式: `steady_clock::now().time_since_epoch().count()`~~我承认是比`time(NULL)`复杂，但是很骚啊~~

`random`: 也是C++11添加的，正如其名，生成随机数用的。

1. 随机引擎\
   随机引擎决定了(伪)随机数的生成算法，这里默认的`default_random_engine`即可。在构造函数或者`seed`中可以设置种子。\
   随机引擎重载了运算符()，意味着它可以直接调用，返回一个随机的`unsigned`。
2. 分布器\
   分布器决定了随机数的分布，`uniform_real_distribution<double>(m, n)`是m-n之间均匀分布的小数，`uniform_int_distribution<int>(m, n)`是m-n之间均匀分布的整数，也有正态分布等其他分布。\
   分布器也可以直接调用，参数是一个随机引擎，返回范围内的一个数。

`iomanip`: 用于格式化`iostream`、`fstream`、`sstream`等输出流。

1. `setprecision(n)`能设置输出的有效位数\
   如在3位下，`0.01234`输出`0.0123`，`12.34`输出`12.3`，`1234`输出指数形式`1.23e+03`。
2. `fixed`设置有效位数从小数点后一位开始，不足补零\
   同样在3位下，`1234.5678`输出`1234.568`，`1234`输出`1234.000`

两点之间的距离:

勾~~谷~~股定理 `sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2)`

## AC代码

提示: 提交请使用C++11及以上，不然CE

```cpp
// cin/cout
#include <iostream>
// 特色头文件
#include <chrono>
#include <random>
#include <iomanip>
// sqrt
#include <cmath>
using namespace std;
using namespace std::chrono; // chrono库的命名空间
double ax[10], ay[10]; // 储存坐标
inline double pow2(const double& a) {
  return a * a; // 平方
}
// (x, y)和屏蔽器i的距离
inline double dis(const double& x, const double& y, const int& i) {
  return sqrt(pow2(ax[i] - x) + pow2(ay[i] - y));
}
int main() {
  // 默认随机数引擎，使用steady_clock的时间作为种子
  default_random_engine rnd(steady_clock::now().time_since_epoch().count());
  int n, l;
  double lim;
  cin >> n >> l;
  lim = 1.0 * l / n + 0.000001;
  // 产生0-l之间的随机double
  uniform_real_distribution<double> uni(0, l);
  for (int i = 0; i < n; i++) {
    cin >> ax[i] >> ay[i];
  }
  // 这里看欧气居多，我随机100次都能A
  for (int i = 0; i < 10000; i++) {
    // 取随机坐标
    double x = uni(rnd), y = uni(rnd);
    bool flag = true;
    for (int j = 0; j < n; j++) {
      if (dis(x, y, j) < lim) {
        flag = false;
      }
    }
    if (flag) {
      // 用iomanip格式化输出
      cout << fixed << setprecision(3) << x << ' ' << y;
      return 0;
    }
  }
  cout << "GG";
  return 0;
}
```

---

## 作者：JoseTony (赞：2)

这题运用了随机贪心的思想。首先我们需要了解的是随机数知识。首先如果要生成一个随机数，我们需要用到的是 ```cstdlib``` 库中的函数 ```rand```。使用这个函数便可以生成一个随机数。但是在使用前必须加上一个随机数种子格式由 ```srand(要加的种子数）``` 组成。对于这个题，我们可以每次都生成一个随机数，然后进行判断。但是可能会出现点生成在了图外面的情况。因此我们要一直把这个点往下除，一直到图形里面即可。

到了图形里面之后，我们怎样处理这个点呢？这里需要用到距离公式，也就是欧几里得距离 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ 这个式子。如果这个数值加上题目中所给的误差在范围内，说明这个点不可以进行上网。反之，就能进行上网。如果一个点能进行上网，就输出这个点。循环结束后如果不行就输出给定的字符串。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
double a[1001],b[1001];
const double k=1/1e6;
int main(){
	double n,l;
	
	cin >> n >> l;
	srand(1111);//种子，要大一点
	for(int i=0;i<n;i++){
		cin >> a[i] >> b[i];
	}
	for(int i=1;i<10000000;i++){//下界要大一点
		double x = rand();
		double y = rand();//随机数生成
		while(x>l){//超出边界
			x/=10;//向下除
		}
		while(y>l){
			y/=10;//同上
		}
		int flag = 0;
		for(int j=0;j<n;j++){
			if(sqrt((x-a[j])*(x-a[j])+(y-b[j])*(y-b[j]))+k<l/n){//距离公式
				flag = 1;//标记
			}
		}
		if(flag==0){
				printf("%.3lf %.3lf",x,y);//输出，记得保留小数
				return 0;
		}
	}
	cout << "GG";//没找到就输出GG
	return 0;
}
```



---

## 作者：zjh111111 (赞：2)

很久以前的月赛题了吧，写篇题解怀念一下

题面意思表达很清楚了。

【思路】

观察一下范围，发现 n 很小，同样整个被覆盖的区域也很小。

故采用随机化，随机一个点，判断这个点是否被覆盖。

这样子随机到答案的概率是很大的。

复杂度(p是随机次数)

$$\mathcal{O(n*p)}$$

这里给出 Pascal 的随机化方式。

【代码】

解释
```pascal
function ran(y,z:real):boolean;
var
  j:longint;
begin
  for j:=1 to n do
    if sqrt(sqr(y-a[j])+sqr(z-b[j]))<=(m/n+1e-6) then exit(false);
//曼哈顿距离，如果在范围内说明被覆盖，不合法
  exit(true);
end;
begin
  randomize;
//Pascal随机前必须初始化随机函数发生器，不然random(x)，x相同随机出来的是同一个数
  readln(n,m);
  for i:=1 to n do readln(a[i],b[i]);
  for i:=1 to p do
    begin
      x:=random(m*1000)+1;
      y:=random(m*1000)+1;
      if ran(x/1000,y/1000) then
//比较套路，在[1,m]里随机x位小数，就先把m扩大10^x倍后随机，再除以(10^x)，需要注意的是可能会爆范围（当然这题不会
        begin
          write(x/1000:0:3,' ',y/1000:0:3);
          exit;
        end;
    end;
  write('GG');//上面已经结束程序，做到这里就是无解。
end.
```

完整

```pascal
const
  p=1000000;
var
  n,m,x,y,i,k:longint;
  a,b:array[0..11] of real;
function ran(y,z:real):boolean;
var
  j:longint;
begin
  for j:=1 to n do
    if sqrt(sqr(y-a[j])+sqr(z-b[j]))<=(m/n+1e-6) then exit(false);
  exit(true);
end;
begin
  randomize;
  readln(n,m);
  for i:=1 to n do readln(a[i],b[i]);
  for i:=1 to p do
    begin
      x:=random(m*1000)+1;
      y:=random(m*1000)+1;
      if ran(x/1000,y/1000) then
        begin
          write(x/1000:0:3,' ',y/1000:0:3);
          exit;
        end;
    end;
  write('GG');
end.

C艹大家都写了，解释得也清楚。所以来份Pascal。


```


---

## 作者：return_CE (赞：1)

## 思路
题目只要求找到一个符合要求的点就可以了，所以可以随机生成点，判断是否符合要求。在接近但不超过时限时一直随机寻找是否有点符合要求。
## 实现
设一个  sa  函数，随机生成点。若符合要求则输出。设有个  bool  变量  v  表示随机点是否符合要求，枚举每一个屏蔽器，如果发现不可行则直接把 v  标记成  0，如果随机点可行则结束程序。每次生成随机点之前把  v  初始化为  1。再写一个卡时，在时间限制内一直寻找可行的点。随机数种子随便取，
~~比如女友的生日~~。

详细解释见注释。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 15;
double x[maxn], y[maxn];
double n,l;
bool v=1;
void sa()//随机选取一个点进行判断 
{
	double xx=rand();// 选点 
	double yy=rand();
	while(xx>l) xx/=10;//如果已经超了，就直接减小 
	while(yy>l) yy/=10;
	for(int i=1;i<=n;i++){//枚举每个点，判断是否符合 
			if(pow(xx-x[i],2)+pow(yy-y[i],2)<pow(l/n,2))//不符合 
			{
				v=0;
				break;
			}
	}
	if(v) printf("%.3lf %.3lf", xx, yy);//符合，输出 
	
}
int main()
{
	srand(20050907);
	cin>>n>>l;
	for(int i=1;i<=n;i++)
		cin>>x[i]>>y[i];
	while((double)clock()/CLOCKS_PER_SEC<0.85){//卡时 
		v=1;//初始化，每个点都默认符合 
		sa();//随机选取 
		if(v) return 0;//如果已经找到了合适的点，直接结束程序 
	}
	cout<<"GG";//如果根本没有合适的点，才会执行这一步 
	return 0;
}
```

---

## 作者：LazYQwQ (赞：1)

## 在学习本篇前，请确认您掌握了这些知识。
 随机数；浮点型；勾股定理。
 
看好了吗？让我们出发吧！

###  1 .分析题干。


边长为 $l$ 。

$n$ 个无线信号屏蔽器（屏蔽半径 $r$ ）。

所求：位置，使得没有圆覆盖（不在圆里）。

如果有答案，输出位置（坐标后有三位小数）。
若没有则输出  $“GG”$ 。

------------


###  2 .逐个击破。

对于本题，应首先设置的变量分别为：正方形边长 $l$ ；圆的数量 $n$ ；圆的半径 $r$ 。

以及圆心的位置 $x_i$ , $y_i$ ；点的位置 $xi$ , $yi$ 。

本题中特别注明了答案不唯一，输出一组解即为正确且坐标精确到了多位小数，由此可见逐个分析并不是明智的选择，鉴于正确的答案较多，**猜都可能猜对。**

所以，那就猜一个呗！**随机数！**

 

------------
 
 在忙完这些后，我们便可以对圆的覆盖范围做出判定，在圆的外面即可以表示为距离圆心的距离大于圆的半径  $r$ 。
###   由于勾股定理两直角边平方之和等于第三边平方的结论可以推出$(x-x_i)^2+(y-y_i)^2=r^2$

**点与圆心的横坐标与纵坐标之差即为两直角边的长度.**
        
故当 $(x-x_i)^2+(y-y_i)^2>r^2$的时候，人物在屏蔽器的范围之外。

重点知识就到这里了，放代码（不要照抄)。     
```c
#include<bits/stdc++.h>
using namespace std;
double n,l;
double r;
int num=0;//成功躲过的屏蔽器
int p=0;//试错次数
double xi,yi;//人物的位置
double x[530],y[530];//定义变量
int main() {
srand((unsigned)time(0));

//以当前时间作为随机数种子，
//保证每次编译时的随机数不会重复,
	cin>>n>>l;
	r=l/n;
	for(int i=1; i<=n; i++) {
		cin>>xi[i]>>yi[i];
	}
    //正常输入
	while(p<=100000) {
		xi=rand()%(int)1000*l;
		yi=rand()%(int)1000*l;
        //rand即可取随机数，但只可以取得整型，在此，我们随机生成一个1000以下的随机数
		xi=xi/1000;
		yi=yi/1000;
        //再将其除去1000，此时最大的1000将会变为1，更小的百位十位个位会顺次成为十分位百分位千分位
            num=0;
		for(int i=1; i<=n; i++)
	   if((xi-x[i])*(xi-x[i])+(yi-y[i])*(yi-y[i])>r*r)
       //重点代码{
		num++;//躲过一劫
		}
		if(num==n) {//全部躲过
		cout<<xi<<" "<<yi;
		return 0;
	     }
         p++;
	         }
    //最后当循环了n的最大值的平方次数后（够多了）便可以结束了！
	cout<<"GG";//若此时还没有找到，无奈GG，可怜的孩子！
	return 0;}


```
------------
**圆内勾股练习题：P2313汤姆的游戏；P1652 圆
 谢谢大家！**

---

## 作者：千城_Dhmc (赞：1)

### 本题思路：

这一题要用到**随机数**，题意是输出在 n 个屏蔽器的范围外的点，因为是随机数，可能要不停的调范围，所以做这题时要有耐心，不断尝试调他的范围。

思路就是在这个房间里**随机枚举位置**，直到**找到没有屏蔽器覆盖的点**的坐标。

### 下面附上AC代码：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
double dis(double a,double b,double c,double d){
return sqrt((a-c)*(a-c)+(b-d)*(b-d));
}//长度函数
int main(){
double n,l,r,x[15],y[15];
cin>>n>>l;//输入
for(int i=1;i<=n;i++){
    cin>>x[i]>>y[i];    
}   
r=l/n;//半径
for(int i=1;i<5000000;i++){//五百万个随机点里找正确得点
    double a=rand();
    double b=rand();
    while(a>l){
        a/=5;
    }
    while(b>l){
        b/=5;
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(dis(a,b,x[i],y[i])>r+0.00001){
            cnt++;
        }
    }
    if(cnt==n){
        printf("%.3lf %.3lf",a,b);//输出
        return 0;
    }
}
cout<<"GG";
return 0;
}
```
别作弊，棕名警告！

---

## 作者：Dorbmon (赞：1)

这题不是个模拟退火吗23333.
我们定义一个函数check表示x，y到其他屏蔽器的最短距离。然后日常模拟退火了。第一次提交输出多了。。居然还有分，这个数据也是水23333.
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read() {
    ll res=0,f=1;char ch=' ';
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
struct obj {
	double x,y;
} datas [15];
int n,l;
inline double dis (double x1,double x2,double y1,double y2) {
	double d1 = x1 - x2,d2 = y1 - y2;
	return sqrt (d1 * d1 + d2 * d2);
}
inline double check (double x,double y) {
	double ret = 0x3f3f3f3f;
	for (int i = 1;i <= n;++ i) {
		ret = min (ret,dis (datas [i].x,x,datas [i].y,y));
	}
	return ret;
}
int main(){
#ifndef ONLINE_JUDGE
	freopen ("shit.txt","r",stdin);
#endif
	n = read (),l = read ();
	for (int i = 1;i <= n;++ i) {
		cin >> datas [i].x >> datas [i].y;
	}
	double best_x = 0,best_y = 0,best_v = check (0,0);
	int times = 1;
	srand (time (NULL));
	while (times --) {
		double nx = 0,ny = 0,nv = check (0,0);
		for (double t = 1000;t >= 1e-15;t *= 0.98) {
			double x = fmod(nx + (1.0 * rand () / RAND_MAX) * l * t,l);
			double y = fmod(ny + (1.0 * rand () / RAND_MAX) * l * t,l);
			double rt = check (x,y);
			if (rt > nv) {
				if (rt > best_v) {
					best_x = x;
					best_y = y;
					best_v = rt;
					if (best_v > 1.0 * l / n + 1e-6) {
						break ;
					}
				}
				nx = x;
				ny = y;
			}else if (exp (-(nv - rt) / t) * RAND_MAX >= rand ()) {
				nv = rt;
				nx = x;
				ny = y;
			}
		}
	}
	if (best_v > 1.0 * l / n + 1e-6) {
		cout << best_x << " " << best_y << endl;
	}else {
		printf ("GG\n");
	}
    return 0;
}
```
注意这里不要求最优解，所以找到解之后就可以立即退出。

---

## 作者：Leap_Frog (赞：1)

# P4703偷上网（题解）

### PS.~~随机大法好用~~

### 题目大意
就是给你$\texttt{n}$个圆，然后让你找出一个点，使它没被任何圆覆盖。  
输出这个点的坐标，没有则输出$\texttt{GG}$。

### 代码分析
~~没什么好分析的~~  
直接暴力随机这个点的坐标，然后判断这个点是否在圆内。  
那么如何判断这个点是否在圆内呢？ [不会的点我](https://www.luogu.org/problem/P1652)  
具体详情请看代码。

### 关于此题
我做这道题，刚开始忘了可能有无解情况，$\texttt{T}$了$\texttt{4}$个点，~~说明无解的就四个点~~  
然后，又过了一段时间，终于把代码构对了后，发现随机种子也很重要。  
刚开始，我用$\texttt{time(0)}$来当随机种子，$\texttt{Wa}$了一个点。  
后来用其他的一些随机种子，结果都$\texttt{Wa}$了那一个点。  
一气之下，我翻了一下题解，抄了楼上的$\texttt{19260817}$作为随机种字，莫名其妙就对了。  
我感到特别玄学

### 不说了，上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=15;
struct point{double x,y;}a[N];	//点的结构体
int n,l,m=1e7;	//m表示随机次数
inline point Rand()		//生成平面上的随机一个点
{
	double x=rand(),y=rand();
	while(x>l) x/=10;
	while(y>l) y/=10;
	return (point){x,y};
}
inline double sqr(double x) {return x*x;}	//平方函数
inline char check(point b)		//判断这个点是否在一个圆里面
{
	for(int i=1;i<=n;i++)
		if(sqr(b.x-a[i].x)+sqr(b.y-a[i].y)<sqr(double(l)/n))
			return 1;
	printf("%.3lf %.3lf\n",b.x,b.y);
	return 0;
}
int main()
{
	srand(19260817);	//玄学的随机种字
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
	while(check(Rand())&&m--);	//不断随机点，判断
	if(m==-1) puts("GG");	//判断不可行解
	return 0;
}
```

---


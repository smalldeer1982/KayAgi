# 「生物」能量流动

## 题目描述

生物课上，小 F 学习到了食物链、食物网的相关内容。

他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。

现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。

在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \leq r_{i + 1}(1 \leq i < n),$ $r_i < i(1 \leq i \leq n)$。

每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：
* $b_i \geq a_i$
* $c_i \leq \frac 1 5 b_i$

你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。

## 说明/提示

### 样例 1 解释

最优情况下：
* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\frac 1 5$，得到 1 点能量。
* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\frac 1 5$，得到 0.8 点能量。
* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\frac 1 5$，得到 0.2 点能量。

可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。

### 样例 2, 3 解释

由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。

### 子任务

子任务 $1(21 \mathrm{pts}) : n \leq 100$；

子任务 $2(89 \mathrm{pts}) : n \leq 10 ^ 5$。

## 样例 #1

### 输入

```
2 9
1 0
1 1```

### 输出

```
0.2000000```

## 样例 #2

### 输入

```
2 9
1 0
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 10
1 0
1 0```

### 输出

```
0.4000000```

# 题解

## 作者：caidd (赞：21)

感觉纯贪心的一道题，加上一点优化，就差不多了，我是比赛时打了个8ms的程序，~~感觉还是好慢~~。  
因为你作为顶级的掠食者，要想获得最大的能量，那么肯定对于每种生物都是要刚好满足它的需求。  

由题意可知，要使所获得的最大就要让损失的最少。那么贪心策略便就出来了。便是每种生物尽量从最小等级的生物获得能量。
然后优化就是：较小等级的生物可能能量已经分配到0。那么就用一个vis数来表示已经为零的低等级的生物标号。(初始为0)

```cpp
#include<map>
#include<set>
#include<cmath>
#include<ctime>
#include<queue>
#include<string>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
#define In inline
#define R register
#define N 100005
using namespace std;
int n,vis;
int a,r;
double d[100005],k,sum;//double注意啊！
int read()
{
	int x=0;char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();//位运算快读
	return x;
}
int main()
{
	n=read();a=read();d[0]=a;
	for(R int i=1;i<=n;++i)
	{
		k=read(),d[i]=k,r=read();
		for(int j=vis/*vis记录最小*/;j<=r;++j)
		{
			if(!d[j]) vis=j;
			if(d[j]*0.2>=k) {d[j]=(d[j]-(k*5));k=0;break;}
			else k=(k-d[j]*0.2),d[j]=0;
		}
		if(k>0) {cout<<"-1"<<endl;return 0;}
        //若还大于0,无法满足，输出-1。
	}
	for(int i=vis;i<=n;++i) sum+=d[i]*0.2;//加能量和。
	printf("%lf\n",sum);
	return 0;
}
```

---

## 作者：qqvq (赞：7)

代码很短 先上代码

#### pre是前缀和,last是扫到的位置
```cpp
#include <cstdio>
int a[100005], b, n, last, j; long long pre;
int main() {
	scanf("%d %lld", &n, &pre);
	for(int i = 1; i <= n; ++i) {
		scanf("%d %d", a+i, &b);
		for(j = last+1; j <= b; ++j) pre+=a[j]; last = j-1;//更新指针和前缀和
		pre -= a[i] * 5; 
		if (pre < 0) return puts("-1"), 0;//若在某个时刻pre<0则代表有生物不能存活
	}
	for(int i = last+1; i <= n; ++i) pre += a[i];//最后可能有一段剩下的，加上
	printf("%lf", pre/5.0);//输出答案
	return 0;
}
```
#### 能量流动的次数越多，到达食物链顶端的能量就越少，所以在满足每个生物都不会GG的情况下，把剩下所有的能量都给顶级掠食者

本题有个非常好的性质$r_i≤r_{i+1}$利用这个性质，可以用一个指针记录扫到的位置，维护前缀和，当发现$r_i>r_{i-1}$的时候把多出来的一段加上，同时更新指针

为什么这样是对的呢,是因为对于一个生物X,任何X能捕食的生物都是等价的，同时又有$r_i≤r_{i+1}$，这样就保证了正确性





---

## 作者：philosopherchang (赞：5)

这篇题解的名字叫做Unknown error的心理历程

其实这道题思路很简单，直接从0开始贪心模拟就可以啦。

要注意一点的是：

不要用float,不要用float,不要用float；
不然Unknown error；

上代码吧：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
double a[100001],b[100001],sum;
long long r[100001],v,n;
int main()
{
	cin>>n>>a[0];
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>r[i];
		b[i]=a[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=v;j<=r[i];j++)
		{
			if(a[j]==0)
			{
				v=j;
			}
			if(a[j]>=b[i]*5)
			{
				a[j]-=b[i]*5;
				b[i]=0;
				break;
			}
			else if(a[j]!=0)
			{
				b[i]-=a[j]*0.2;
				a[j]=0;
			}
		}
		if(b[i]>0)
		{
			cout<<"-1"<<endl;
			return 0;
		}
	}
	for(int i=v;i<=n;i++)
	{
		sum+=a[i]*0.2;
	}
	printf("%lf",sum);
}
```

---

## 作者：ViXbob (赞：5)

[博客推广](http://www.vixbob-lwc.pw) // 大概会更这次月赛部分题的题解

这题其实很水

题面就不再赘述，然后题目的大意就是要求在满足所有的动物的能量需求的情况下，最后剩余的能量最多

因为能量每往后传递一次就缩减到$\frac{1}{5}$, 所以很显然可以贪心，只要在能量传递次数最少的情况下满足所有的动物的需求，最后剩余的一定最大

实现：我们只需要维护一颗线段树，然后对每一个动物二分一个最靠前的位置，**越靠前越优**, 然后修改一下每个动物所持有的能量，最后的答案就是最后所有动物所持有能量的$\frac{1}{5}$

然后复杂度很显然是$O(nlog^2n)$的，~~由于我太菜只能想出这么辣鸡的算法~~， 欢迎各位聚聚来讨论更好的方法

代码:

```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int n, r[maxn];
double a[maxn], ans;
struct Segment{
    #define ls p << 1
    #define rs p << 1 | 1
    #define mid (l + r >> 1)
    struct node{double s, tag;}t[maxn << 2];
    inline void pushup(int p){t[p].s = t[ls].s + t[rs].s;}
    inline void pushdown(int l, int r, int p){
        if(t[p].tag == -1)return;
        int o = t[p].tag;
        t[ls].tag = o; t[ls].s = (mid - l + 1) * o;
        t[rs].tag = o; t[rs].s = (r - mid) * o;
        t[p].tag = -1;
    }
    inline double query(int l, int r, int ql, int qr, int p){
        if(ql > qr)return 0.0;
        if(l == ql && r == qr)return t[p].s;
        pushdown(l, r, p);
        if(qr <= mid)return query(l, mid, ql, qr, ls);
        else if(ql > mid)return query(mid + 1, r, ql, qr, rs);
        else return query(l, mid, ql, mid, ls) + query(mid + 1, r, mid + 1, qr, rs);
        pushup(p);
    }
    inline void modify(int l, int r, int pos, int p, double x){
        if(l == pos && r == pos){t[p].s += x; return;}
        pushdown(l, r, p);
        if(pos <= mid)modify(l, mid, pos, ls, x);
        else modify(mid + 1, r, pos, rs, x);
        pushup(p);
    }
    inline void opre(int l, int r, int ql, int qr, int p, double x){
        if(ql > qr)return;
        if(l == ql && r == qr){
            t[p].s = (r - l + 1) * x;
            t[p].tag = x; return;
        }
        pushdown(l, r, p);
        if(qr <= mid)opre(l , mid, ql, qr, ls, x);
        else if(ql > mid)opre(mid + 1, r, ql, qr, rs, x);
        else opre(l, mid, ql, mid, ls, x), opre(mid + 1, r, mid + 1, qr, rs, x);
        pushup(p);
    }
}T;
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while(!isdigit(ch)){if(ch == '-')f = -1; ch = getchar();}
    while(isdigit(ch)){u = u * 10 + ch - 48; ch = getchar();}return u * f;
}
inline int find(int l, int r, double x){
    int Mid = 1, ans = 0;
    while(l <= r){
        Mid = l + r >> 1;
        double s = T.query(1, n + 1, 1, Mid, 1);
        if(s >= x * 5)r = Mid - 1, ans = Mid;
        else l = Mid + 1;
    }
    return ans;
}
int main(){
    n = read(); a[1] = read();
    T.modify(1, n + 1, 1, 1, a[1]);
    for(register int i = 1; i <= n; i++)
        a[i + 1] = read(), r[i + 1] = read() + 1;
    for(register int i = 2; i <= n + 1; i++){
        int pos = find(1, r[i], a[i]);
        double s = T.query(1, n + 1, 1, pos, 1);
        if(s == a[i] * 5)T.opre(1, n + 1, 1, pos, 1, 0);
        else if(s > a[i] * 5){
            T.opre(1, n + 1, 1, pos - 1, 1, 0);
            T.opre(1, n + 1, pos, pos, 1, s - a[i] * 5);
        }
        else {printf("-1"); return 0;}
        T.modify(1, n + 1, i, 1, a[i]);
    }
    ans = T.query(1, n + 1, 1, n + 1, 1);
    printf("%.7lf", ans / 5.0);
    return 0;
}
```

---

## 作者：star_magic_young (赞：2)

~~好久没水题解了2333~~

你们啊,我感觉你们......做法有点复杂啊,什么线段树树状数组都来了,这题做法可以做到$O(n)$啊 ~~一开始我竟然写了个堆~~

### 思路

因为$r_i$是单调不减的,所以我们完全可以把下标在$r_i$之前的能量加在一起,每次处理$i$时就把能加进但没加进总能量的能量加进来,然后~~一键~~判断,算一下救星了$\color{white}\text{再吐槽一下你谷最近两场比赛怎么都有锅啊}$

#### code

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#define LL long long
#define il inline
#define re register
#define eps 1e-10

using namespace std;
const LL mod=998244353;
il LL rd()
{
    re LL x=0,w=1;re char ch;
    while(ch<'0'||ch>'9') {if(ch=='－') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
int n;
double a,b[100010];
//假装自己是手写堆(逃//

int main()
{
  n=rd();
  a+=rd();
  int p=1;
  for(int h=1;h<=n;h++)
    {
      int x=rd(),y=rd();
      while(p<=y) a+=b[p++];
      if(a/5-(double)x<-eps) {p=-1;break;}
      //就是判断大小操作,等价于a/5<(double)x
      a-=x*5;
      b[h]=x;
    }
  if(p<0) puts("-1");
  else
    {
      for(;p<=n;p++) a+=b[p];
      printf("%.9lf\n",a/5);
    }
  return 0;
}
//van♂结撒♂FA//
```


---

## 作者：b2019dy (赞：2)

	简单的题大佬不想写题解的话，就让蒟蒻来一篇吧。
    其实就是一个简单的贪心，因为能量传递中会有损耗，所以尽量减少传递。
    因为要保证每个生物的存活，所以从1到n枚举每个生物保证足够的能量。
    因为r[i]必定小于等于r[i+1]，所以依次枚举被吃的生物。
    最后把所有生物剩余能量传递给人类即可。
    代码如下：
	```cpp
	#include<iostream>
	#include<cstdio>
	#include<iomanip>
	#include<cmath>
    using namespace std;
    double n,a[100005],r[100005],b[100005];//a数组表示所需能量，b数组表示已有能量，r表示可吃范围。 
	int l=0;
	int main()
	{
    	scanf("%lf%lf",&n,&a[0]);
    	for(int i=1;i<=n;i++)
    	{
    	    scanf("%lf%lf",&a[i],&r[i]);
    	}
    	b[0]=a[0];//初始拥有的能量即为a0 
    	for(int i=1;i<=n;i++)
    	{
    	    if(r[i]>=l)//如果能吃的话 
    	    {
    	        if(b[l]>=5*(a[i]-b[i]))
        	    {
        	        b[l]-=5*(a[i]-b[i]);
        	        b[i]=a[i];
        	    }
        	    else
        	    {
        	        b[i]+=b[l]/5;
        	        b[l]=0;
        	        l++;
        	        i--;//能量还不够，所以要回来 
        	    }
        	}
        	else//满足不了 
        	{
        	    printf("-1");
           		return 0;
        	}
    	}
    	double ans=0;
    	for(int i=0;i<=n;i++)
    	{
        	ans+=(b[i]/5);
    	}
    	printf("%0.7lf",ans);
	}
```

---

## 作者：猪脑子 (赞：2)

既然是最优情况，那么能量的传递效率为1/5。

为了让这个贪婪的掠食者得到最多的能量，那么我们可以让

	bi=ai,ci=bi/5//ai,bi,ci参考题目描述
    
很显然，为了得到最多的能量，能量传递的次数应尽可能少。那么每个掠食者应当**尽可能捕食靠前的动物**。

实践证明，这样做是对的。至于怎么证，我就不说了~~（悄悄隐瞒了自己太弱而并不会证的事实）~~

因此，我们得到一个贪心的思路：

	设g[i]为第i个生物当前（剩余）的能量，从0到ri枚举被捕食者；
    假设被捕食者为v，如果g[v]/5+g[i]>a[i]/*如果全部捕食会有剩余*/
    		那么就仅仅捕食所需的部分，也就是执行下面的操作
                g[v]-=5*(a[i]-g[i]),g[i]=a[i];
    否则，就全部捕食，也就是
    			g[i]+=g[v]/5;g[v]=0;

这个方法是正确的，但时间复杂度达到了O(n^2)（每个捕食者都枚举到，最坏每一个都要枚举ri个被捕食者）

注意到我们是从0开始枚举，但是根据我们的思路，有很多g[v]早就会变成0。

那么我们可以设now为最靠前的g[v]不为0的v，那么我们可以用下面的代码：

	now=0;
    g[0]=a[0];//生产者
	for(int i=1;i<=n;i++)
	{
		while(now<=r[i]&&g[i]<a[i])
		{
			if(g[now]/5+g[i]>a[i])
            	g[now]-=5*(a[i]-g[i]),
            	g[i]=a[i];
			else{
				g[i]+=g[now]/5;
				g[now]=0;
				now++;
			}
		}
		if(now>r[i]&&g[i]<a[i]){//不能存活
			printf("-1\n");
			return 0;
		}
	}

最后我们把g[0]到g[n]加起来除以5就是答案。~~（很简单吧）~~

## Code：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,now;
double a[100010];
int r[100010];
double g[100010];
int main()
{
	scanf("%d %lf",&n,&a[0]);
	g[0]=a[0];
	for(int i=1;i<=n;i++)
		scanf("%lf %d",&a[i],&r[i]);
	for(int i=1;i<=n;i++)
	{
		while(now<=r[i]&&g[i]<a[i])
		{
			if(g[now]/5+g[i]>a[i])g[now]-=5*(a[i]-g[i]),g[i]=a[i];
			else{
				g[i]+=g[now]/5;
				g[now]=0;
				now++;
			}
		}
		if(now>r[i]&&g[i]<a[i]){
			printf("-1\n");
			return 0;
		}
	}
	double ans=0;
	for(int i=0;i<=n;i++)
		ans+=g[i]/5;
	printf("%.7f\n",ans);
	return 0;
}
```

---

## 作者：Limerick (赞：1)

# **贪心是个好算法**
#### i从1~n枚举每一个生物 j从0~r[i]枚举当前生物能捕食的生物
#### 由于天然的强弱顺序,r是有序的,只需刚好满足当前生物的能量需求,这样就使得最后我获得的能量最大,而且为了避免浪费(光盘行动),所以就想让被捕食者所贡献给捕食者的能量浪费的最少.
#### 这样贪心策略就出来了,每个捕食者都按能量从小到大捕食(由于传递的能量<=1/5被捕食者能量,想要我最后获得的最大,那么肯定就按0.2算，那么浪费的是4/5,故想要浪费的最少,被捕食者能量就要尽可能少,这样乘4/5后才会浪费最少),直到刚好满足自己的存活需求.
#### 最后算一下我这个贪婪的顶级掠食者所获得的能量总和就行了.
#### Code:
```#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<ctime>
using namespace std;
const int N=100005;
int n,a0,r[N];
double ans,v[N],a[N];
int main(){
	scanf("%d%d",&n,&a0);
	v[0]=a0;//生产者
	for(int i=1;i<=n;i++){
		scanf("%lf%d",&a[i],&r[i]);//后面省的*0.2再进行强制转换了,直接开double
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=r[i];j++){//r已经是有序的
			if(v[i]>=a[i]){//如果已经满足需求了
				break;//退出
			}
			if(v[j]>0){//如果此被捕食者还可以被掠夺
				if(v[j]*0.2>(a[i]-v[i])){//如果此被捕食者剩余能量满足捕食者需求后还多
					v[j]-=(a[i]-v[i])/0.2;//就刚好满足需求就行了
					v[i]=a[i];
				}
				else{//否则
					v[i]+=v[j]*0.2;//全部掠夺
					v[j]=0;//掠夺完毕
				}
			}
		}
		if(v[i]<a[i]){//如果还不能满足需求
			printf("-1\n");//直接输出-1
			return 0;
		}
	}
	for(int i=0;i<=n;i++){
		if(v[i]>0){
			ans+=v[i]*0.2;//把所有能掠夺的都掠夺了
		}
	}
	printf("%.15f",ans);//无需考虑精度问题
    return 0;
}```


---

## 作者：Mistybranch (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4712)

题目大概意思是：现在有 $n + 2$ 种生物，其中第 $0$ 个生物是唯一的生产者，可生产 $a_0$点能量，第 $n + 1$ 个生物可以捕食所有的生物，其余生物只能捕食第 $0 - r_i$ 个生物。一个生物的部分能量可以传递给捕食它的生物，但是在传递的过程中会损耗传递能量的 $\dfrac{4}{5}$，最终捕食者只能获得传送能量的 $0.2$ 倍。问在保证每个生物捕获的能量数 $\geq a_i$  的情况下，第 $n + 1$ 个生物最多能捕获多少能量。

这道题是一道读题比较费劲的贪心题，下面直接上思路：

- 因为一开始唯一的能量来源是 $a_0$，并且 $r_i \leq r_{i + 1}$，所以满足前 $i + 1$ 个生物生存的必要条件是满足前 $i$ 个生物生存。

- 开始可以传递的能量总和为 $a_0$，从 $1 - n$ 扫一遍所有的生物，扫到第 $i$ 个生物时，假设前 $i - 1$ 个生物全部存活，由于 $r_i$ 单调不下降，将 $a_{r_{i - 1} + 1 - r_i}$ 累加到现在可以传递的能量总和即可。

```cpp
for (int j = _c[i - 1].r + 1; j <= _c[i].r; j++) {
	_res += _c[j].a;
}
```

- 若不满足当前第 $i$ 只生物的需求（现在可以传递的能量总和的 $\dfrac{1}{5}$ 小于这个生物所需的能量总和 $a_i$），直接输出 $-1$，否则可以传递的能量总和就减去这个生物所需的能量的 $5$ 倍。

```cpp
if (_res * 0.2 < _c[i].a) {
	printf("-1\n");
	
	return 0;
}

_res -= _c[i].a * 5.0;
```


- 最后第 $n + 1$ 个生物最多捕获多少能量就是当前所剩的总能量的 $\dfrac{1}{5}$。

```cpp
for (int i = _c[(int)_n].r + 1; i <= _n; i++) {
	_res += _c[i].a; 
}//这里一定要加上前面生物没有算进来的能量。

_res *= 0.2;
```
完整代码：

```cpp


#include <bits/stdc++.h>

struct cre {
	double a;
	int r;
}_c[100009];

int _n;
double _a0, _res;

int main () {
	scanf("%d %lf", &_n, &_a0);
	
	for (int i = 1; i <= _n; i++) {
		scanf("%lf %d", &_c[i].a, &_c[i].r);
	}
	
	_res = _a0;
	
	for (int i = 1; i <= _n; i++) {
		for (int j = _c[i - 1].r + 1; j <= _c[i].r; j++) {
			_res += _c[j].a;
		}
		
		if (_res * 0.2 < _c[i].a) {
			printf("-1\n");
			
			return 0;
		}
		
		_res -= _c[i].a * 5.0;
	}
	
	for (int i = _c[(int)_n].r + 1; i <= _n; i++) {
		_res += _c[i].a; 
	}
	
	_res *= 0.2;
	
	printf("%lf\n", _res);
	
	return 0;
}
```


---

## 作者：wxgwxg (赞：1)

~~题解都写得什么奇奇怪怪的玩意啊~~

每个生物就按顺序吃就行了，记个$1-r[i]$前缀和,每次看是否大于$5*[i]$就行了，小于就输出1，大于就把前缀和减去 $5*a[i]$ 主程序只要15行

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int S=1<<16;
char buf[S],*H,*T;
inline char Getchar()
{
	if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
	if(H==T) return -1;return *H++;
}
inline int read()
{
	int k=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) k=k*10+c-'0';return f*k;
}
const int N=100055;
int n,m,a[N];
int main()
{
	int x,r;
	n=read();m=read();int now=0;
	for(int i=1;i<=n;i++)
	{
		x=read();r=read();
		while(now<r) now++,m+=a[now];
		if(m<x*5) {puts("-1");return 0;}
		m-=x*5;a[i]=x;
	}
	while(now<n) now++,m+=a[now];
	printf("%0.5lf\n",m/5.0);
	return 0;
}
```

---

## 作者：scallop (赞：0)

考虑这样一种做法，因为每次传递能量都会减少 $4/5$ ,我们期盼的是让能量尽量少。那么又因为题目保证 $r_i$ 单调不减,所以我们维护一个值 $p$ 表示当前已经满足了前 $p$ 个人的需求。每次到一个新的人，贪心的将自己的能量传递给第 $p$ 个人，如果出现了不行就表示无解了。最后把剩下的传给自己作为答案。

考虑这样的复杂度，我们枚举每个生物作为被吃的，在其中维护了 $p$ 这个值，而 $p$ 最多能到 $n$, 而每次操作我们要么在 $O(1)$ 的时间内发现当前被吃的人不能让 $p$ 增加，要么在 $O(\Delta p+1)$ 的时间内让 $p$ 增加了$\Delta p$。可以看出我们的复杂度为
$$\sum \Delta p +O(n)=O(n)$$

```cpp
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <complex>
#include <cstdio>
#include <cctype>
#include <string>
#include <vector>
#include <queue>
#include <cmath>
#include <set>
#include <map>
using namespace std;
typedef long long ll;

const int MAXN = 1e5 + 100;
const double EPS = 1e-8;
int n;
double a0;
double a[MAXN], b[MAXN], r[MAXN];

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> b[0];
    for (int i = 1; i < n + 1; ++i)
    {
        cin >> a[i] >> r[i];
    }
    double ans = 0;
    int npos = 0;
    for (int i = 0; i < n + 1; ++i)
    {	
        if (npos == i)
            ++npos;
        double ret = b[i];
        while (npos < n + 1 && r[npos] < i)
            ++npos;
        while (npos < n + 1 && r[npos] >= i && ret > 0)
        {
            double req = 5 * (a[npos] - b[npos]);
            if (req >= ret)
            {		
                b[npos] += 0.2 * ret;
                ret = 0;
            }
            else
            {
                b[npos] = a[npos];
                ++npos;
                ret -= req;
            }
        }
        if (npos == n + 1)
            ans += ret * 0.2;
    }
    bool ok = 1;
    for (int i = 1; i < n + 1; ++i)
    {
        if (b[i] < a[i])
            ok = 0;
    }
    if (ok && npos == n + 1)
        printf("%.8lf\n", ans);
    else
        printf("-1\n");
    return 0;
}
```



---

## 作者：Sino_E (赞：0)

因为最后的人吃的东西要最多...

所以满足前面的人的基本需求就行了...也就是说，每个人只会拥有它能拥有的最少的能量...

然后每个人可以吃的范围是单调扩大的...每个人直接从可以吃的范围里每个人拥有的人的能量拿就可以了...

因此用一个累加器...记录一下你现在能吃的能量...

如果能吃的范围扩大，就再累加一下....

每个$i$吃$5a_i$的能量，如果范围到了$i$，能量又会加上$a_i$...

如果某次能量不够了，很显然就无解了....

然后就这个代码了...

```cpp
// Code by ajcxsu
// Problem: C

#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int n, p;
long long a[N], R[N];

int main() {
    scanf("%d%d", &n, &p);
    for(int i=1;i<=n;i++) scanf("%lld%lld", &a[i], &R[i]);
    long long hav=p;
    int r=0;
    for(int i=1;i<=n;i++) {
        while(r+1<=R[i]) r++, hav+=a[r];
        hav-=a[i]*5ll;
        if(hav<0) printf("-1\n"), exit(0);
    }
    while(r+1<=n) r++, hav+=a[r];
    printf("%.8lf\n", 1.0*hav/5.0);
    return 0;
}
```

---

## 作者：Dispwnl (赞：0)

[菜鸡的blog](https://a-failure.github.io/2018/06/17/Luogu%E6%9C%88%E8%B5%9B-6%E6%9C%88/)

用树状数组维护区间和，单点修改

枚举每一种生物，求出ta捕食范围能量和，如果小于$a[i]$就输出$-1$

不然把生产者的能量$-a[i]*5$，这种生物能量$+a[i]$

为什么减少生产者的呢？

因为所有生物的捕食范围都有生产者，而且生产者不会饿死，在哪减对区间和没有影响

这样复杂度应该是$O(nlogn)$的

Refun大爷用队列搞似乎是$O(n)$的？Orz

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define LL double
using namespace std;
const int MAX=2e5+1;
LL s[MAX];
int n;
int a0;
int a[MAX];
int r[MAX];
int read()
{
    int x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x;
}
int lowbit(int x)
{
    return x&(-x);
}
void change(int x,int dis)
{
    for(int i=x;i<=n+1;i+=lowbit(i))
      s[i]+=dis;
}
LL sum(int x)
{
    LL ans=0;
    for(int i=x;i;i-=lowbit(i))
      ans+=s[i];
    return ans;
}
LL ask(int x,int y)
{
    return sum(y)-sum(x-1);
}
int main()
{
    n=read(),a0=read();
    for(int i=1;i<=n;++i)
      a[i+1]=read(),r[i+1]=read(),++r[i+1];
    change(1,a0);
    for(int i=2;i<=n+1;++i)
      {
      	LL dis=ask(1,r[i])/5.0;
      	if(dis<a[i]) return printf("-1"),0;
      	change(1,-a[i]*5);
      	change(i,a[i]);
      }
    LL aaa=ask(1,n+1)/5.0;
    if(aaa<=0.0000001) printf("-1");
    else printf("%lf",aaa);
    return 0;
}
```


---


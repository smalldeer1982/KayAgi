# 浏览器

## 题目背景

\_\_stdcall在用Edge玩slay的时候，鼠标会经常失灵，这让她十分痛苦，因此她决定也要让你们感受一下Edge制造的痛苦。

## 题目描述

\_\_stdcall给了你n个点，第i个点有权值x[i]，对于两个点u和v，如果x[u] xor x[v]的结果在二进制表示下有奇数个1，那么在u和v之间连接一个Edge，现在\_\_stdcall想让你求出一共有多少个Edge。

如果你没能成功完成任务，那么\_\_stdcall会让你痛苦一下，你这个测试点就没分了。

## 说明/提示

我们用v表示权值中的最大值。

对于前20%的数据，n<=10。

对于前40%的数据，n<=100。

对于前60%的数据，n<=1000。

对于前80%的数据，n<=1e6。

对于前90%的数据，v<=1e6。

对于100%的数据，n<=1e7，v<=1e9。

保证a，b，c，d，x[0]都是int内的非负整数。

## 样例 #1

### 输入

```
8 98 24 20 100 44
```

### 输出

```
12
```

## 样例 #2

### 输入

```
1000 952537 601907 686180 1000000 673601
```

### 输出

```
249711
```

# 题解

## 作者：__stdcall (赞：38)

### Prelude

非常良心的送分小水题~

这个题作为T1来讲可能难度偏大，所以定位大概是D2T1。

idea：__stdcall

造数据：__stdcall

---

### 20 pts

$n \le 10$

随便放的分数，防止有人写挂。

---

### 40 pts

$n \le 100$

随便放的分数，防止有人写挂。

---

### 60 pts

$n \le 1000$

暴力分。

枚举两个点，判断她们之间是否有连边，直接模拟即可。

---

### 80 pts

$n \le 10^6$

我们记popcnt(x)表示x在二进制表示下1的个数。

观察之后不难发现，popcnt(a xor b)的奇偶性和popcnt(a)与popcnt(b)的奇偶性有关系。

具体来说，当popcnt(a)和popcnt(b)是一奇一偶的时候，popcnt(a xor b)是奇数，否则就是偶数。

因此，我们只需要统计每个点的权值的popcnt，用奇数的个数乘以偶数的个数就是答案。

需要注意的是，直接统计popcnt的复杂度是$O(\log v)$的，所以这个算法的时间复杂度是$O(n \log v)$。

---

### 90 pts

$n \le 10^7, v \le 10^6$

~~不难发现其实是两个生成函数卷在一起，所以直接用FWT就可以了，复杂度$O(v \log v)$。~~

---

### 90 pts

$n \le 10^7, v \le 10^6$

用$O(n \log v)$的算法好像不太能过掉$n = 10^7$的数据啊？

但是我们发现会有很多重复的数字，所以先统计一下每个数字的出现次数再做就行了，复杂度$O(v \log v)$。

---

### 100 pts

$n \le 10^7, v \le 10^9$

如果能用$O(1)$的时间统计popcnt就好了，这样的总复杂度就是$O(n)$了。

实际上是可以的，用类似【WC 2017 挑战】的方法，把数字拆分成高16位和低16位，分开统计。预处理之后就可以做到$O(1)$求popcnt了。


---

## 作者：弦巻こころ (赞：12)

## 凭良心说 这道题算是这次月赛中很简单的一道题了~~(我也不知道这道题为什么是蓝题...)~~

### 首先我们先看题面你发现是x[u] xor x[v] 在二进制下有多少个1 

那么我们想想异或有什么特征

它相当于是一个**二进制下不进位的加法**.

那么它在二进制下有什么特征呢,接下来我带你来看看.

例如x[u] =15 x[v]=21的情况

15、21在二进制下表示为

15: 0 0 1 1 1 1   有4个1

21: 0 1 0 1 0 1   有3个1

异或后得

26: 0 1 1 0 1 0   有3个1

### 然后你发现

(1). 若某一位上有两个1,则这两个1变为0 两个数字二进制下1的个数的和减去2

(2). 若某一位上一1个一个0,则什么都不会发生

(3). 若某一位上有两个0,则什么都不会发生

#### 然后两个数字二进制下1的个数的和好像奇偶是不会变的.

#### 而这就跟异或出来的数字二进制下1的个数一样

所以呢就将x[u]与x[v]二进制下的1的个数加起来算它的奇偶性就行了.

那么思路有了,可现在怎么实现呢?

这个很简单.

因为小学时学过**奇数+奇数=偶数**  . **偶数+偶数=偶数**  .  **奇数+偶数=奇数** 

所以只有当一个二进制下的1的个数为奇数另一个为二进制下的1的个数为偶数时就行了.

这样就可以用两个数 来存**二进制下的1的个数为奇数与二进制下的1的个数为偶数的数**

最后再把两个数相乘就好啦.

```
#include<bits/stdc++.h>
using namespace std;
long long x,a,b,c,d,n,tmp;
inline int getnum(int zz)
{
    tmp = 0;
    while(zz)
    {
      ++tmp;
      zz ^= (zz & (-zz));//这里大家都懂吧zz & (-zz)是为了求出末尾的1					  
                         //再用异或将这个1去掉.
    }
	return tmp;
}
long long sum1,sum2,tot[2];
int main()
{
	cin>>n>>a>>b>>c>>d>>x;//输入
	a%=d,b%=d,c%=d,x%=d;  //先%一遍害怕爆炸
	long long y;
	for(int i=1;i<=n;i++)
	{
		++tot[getnum(x = ((a * x % d ) * x % d +b * x % d + c) % d) & 1];
       //这里意思是讲当前1的个数求出在&1判断奇偶,在加到tot里面就行了
	}
	printf("%lld",tot[0]*tot[1]);
	return 0;
}
```

## 正文内容讲解结束以下是瞎扯淡环节

### 然后就是对于关于一个数1的个数有很多种求法

#### 就如同今年noip提高初赛10题的求法
```cpp
long long p=y;
 while (p)
{
    cnt++;
	p&=(p-1);//这个意思是去掉最后一位1.
}
```

#### 也有比较暴力的
```cpp
long long cnt=0;
for(int i=34;i>=;i--)
{
	if(d&(1<<i)) //判断二进制下的i为是否为1
	{
		cnt++;
	}
}
```

#### 但这样子的话常数比较大,所以不建议使用.

#### 最近看到一种神奇的函数是__builtin开头的函数,其中有一个就可以直接求解此问题
```cpp
int n = 15;//二进制为1111
int m = 7;//111
cout<<__builtin_parity(n)<<endl;//偶数个，输出0
cout<<__builtin_parity(m)<<endl;//奇数个，输出1
```
#### 但是noip好像不能用__开头的函数所以大家还是别冒险去试

##  写在最后

### 位运算真是个神奇的东西,希望大家可以多多探究一下其中的奥秘,很有意思的(逃).

## 最后抛一道类题就跑

### 【问题描述】 

#### X3 星球的外星人名字都是一个正整数，而且他们都互相认识。

#### 任意两个外星人的友谊度 都是他们名字的异或值。整个星球的友好值等于所有友谊度之和。

#### 求这个星球的友好值是多少

#### 1<=人数<=1e6

#### 提示一下,也是用异或的性质来做哦.

#### 有什么问题欢迎指出

---

## 作者：封禁用户 (赞：7)

# Ad
个人博客同步：

[wordpress](https://oldblog.cinema000.xyz)

[hexo](https://blog.cinema000.xyz)

支持我请点击wordpress版（已加入Google Adsense）

# 分析

首先利用了g++内置函数`__builtin_parity(x)`，用于返回x的二进制表示下1个数的奇偶。

内置函数很快，可以近似为$O(1)$。

然后再利用xor运算的性质，统计每个点权值的`parity`，然后用奇数的个数乘上偶数的个数就是答案。

# Hints

注意中间结果不要溢出

# 代码

```cpp
#include<cstdio>
typedef long long int64;
const int MAXN = 1e7 + 6;
int64 X[MAXN];
int cnt[MAXN];

int main(){
    int n,a,b,c,d;scanf("%d %d %d %d %d %lld",&n,&a,&b,&c,&d,&X[0]);
    register int i;register int64 ans1 = 0,ans2 = 0;
    for(i = 1;i <= n;i++){
        X[i] = ((a * X[i - 1] % d * X[i - 1] % d + b * X[i - 1] + c) % d + d) % d;
        cnt[i] = __builtin_parity(X[i]);
        if(cnt[i]) ans1++;
        else ans2++;
    }
    printf("%lld",ans1 * ans2);
    return 0;
}
```



---

## 作者：suxxsfe (赞：3)

### 安利我的博客，[可以到这里查看](https://www.cnblogs.com/suxxsfe/p/12651569.html)  

发现好多题解并没有解释清楚那种快速求$1$的个数的方法的原理  

[P4932 浏览器](https://www.luogu.com.cn/problem/P4932)  

有$n$个数，$x_1,x_2,\cdots,x_n$，问你有多少对$(u,v)$，使得$x_u\operatorname{xor}x_v$的二进制表示中有奇数个$1$  

输入六个整数，$n,a,b,c,d,x_0$。  
n是点的个数，每个点的权值需要用如下的方式生成。  
$x_i = (ax_{i-1}^2 + bx_{i-1} + c) \bmod d$  

$n\le 10^7,\max(x_i)\le 10^9,a,b,c,d,x_0$在$int$范围  

---------------  

位运算的题，可以先考虑运算前后的数的某些量有何关系  
比如这题，可以发现，只有$x_u,x_v$的二进制中$1$的个数一奇一偶，$x_u\operatorname{xor}x_v$的二进制用才有奇数个$1$  
可以设$x_u,x_v$的二进制$1$有$k$位重合，也就是说这$k$位上两个数都是$1$  
对于异或运算，只有某一位两数不同才是$1$，它们有$\text{偶数}+\text{奇数}-2k$个数位不同，其实就是分别$1$的位数减去共同都是$1$的那$k$位    
那么即为$\text{偶数}+\text{奇数}-\text{偶数}=\text{奇数}$  

---------------  

那么现在考虑如何快速地求一个数二进制中$1$的数量  

首先有一种很显然的方法  

```cpp  
inline int cnt1(int x){
	reg int ret=0;
	while(x) ret+=x&1,x>>=1;
	return ret;
}
```  
就是一位一位的数，复杂度$O(\log x)$  
如果此题用这个方法，$O(n\log x)$，算下来是$3\cdot 10^8$，但是 1.5s 仍然跑不出最后两个点，可能是常数过大  

------------  

接下来有一种稍有优化的方法  
```cpp  
inline int cnt2(int x){
	reg int ret=0;
	while(x){
		ret++;
		x^=(x&(-x));
	}
	return ret;
}
```  
每次结果加一，然后去掉最后一个二进制中的$1$  
复杂度和$x$二进制中数的个数有关，最坏也是$O(\log x)$  
对于如何去掉的最后一个$1$，和计算机数的储存有关  
### 原码  
原码就是一个数的二进制表示，加上符号位，符号位是$0$代表整数，否则是负数  
但这样在表示负数时，每增加一个二进制位，数的值反而会减少，不能完成加法操作  
当然也可以算它的绝对值再取符号之类的，但是对于加法这样计算机中最基础的运算，会显得太麻烦  
### 反码  
正数的反码是其本身，负数的反码是除了符号位，每一位取反的结果  
这样就解决了正负数各自的加法的问题，说“各自”是因为不能跨过$0$  
因为$+0$表示为$0000$，而$-0$表示为$1111$，所以运算时，每跨过一次$0$，都会使结果少一，自己举两个例子用反码表示试试就知道  
### 补码  
于是有了补码，正数的补码还是其本身，负数的补码是它的反码加一  
然后就完美的解决了加法的问题  
而且$1111$这一位就没有数了（我们以四位二进制数为例），所以就让这一位表示$-2^3$  
这也是为什么大部分数据类型表示的范围是$[-2^n,2^n)$  

扯完这些就能理解上面那种方法了，变成负数以后，相当于给每一位取了反，然后加一  
假设这个$x=\cdots 100\cdots$，写出来的这个$1$就是**最后一个**，也就是要去掉的$1$，那么取反以后变成$\cdots011\cdots$  
因为取反结果后面全是$1$，加一，都进位，就变成了$\cdots100\cdots$  
那么和原数做与运算，就得出了那一位$1$，用异或去掉就行  

这种方法已经能通过此题  

---------  

但还有一种更妙的方法  
```cpp  
inline int cnt3(reg int x){    
    x=(x&0x55555555)+((x>>1)&0x55555555);
    x=(x&0x33333333)+((x>>2)&0x33333333);
    x=(x&0x0f0f0f0f)+((x>>4)&0x0f0f0f0f);
    x=(x&0x00ff00ff)+((x>>8)&0x00ff00ff);
    x=(x&0x0000ffff)+((x>>16)&0x0000ffff);
    return x;   
}
inline int cnt4(reg LL x){    
    x=(x&0x5555555555555555ll)+((x>>1)&0x5555555555555555ll);
    x=(x&0x3333333333333333ll)+((x>>2)&0x3333333333333333ll);
    x=(x&0x0f0f0f0f0f0f0f0fll)+((x>>4)&0x0f0f0f0f0f0f0f0fll);
    x=(x&0x00ff00ff00ff00ffll)+((x>>8)&0x00ff00ff00ff00ffll);
    x=(x&0x0000ffff0000ffffll)+((x>>16)&0x0000ffff0000ffffll);
    x=(x&0x00000000ffffffffll)+((x>>32)&0x00000000ffffffffll);
    return x;
}
```  

`cnt3`是处理$int$的，`cnt4`是处理$long\space long$的  
可以看出，这种方法是$O(\log\log x)$  
其实还有一种看起来更接近$O(1)$，但是用到取模运算，所以真正跑起来可能每这个快，也比这个更难理解 

以一个8为二进制数为例，$\texttt{10111001}$，其实更多位数也一样  
$\texttt{0x55}$的二进制是$\texttt{01010101}$  

所以，和它与，就保留了$1,3,5,7$位上的$1$，就是$\texttt{00010001}$  
如果把这个二进制数左移一位，再和它与，那么肯定是保留了$2,4,6,8$为上的$1$，然后把它分别放到了$1,3,5,7$位上  
左移一位再与以后的结果：$\texttt{01010100}$  
和刚才那个$\texttt{ 00010001 }$加完以后的结果：$\texttt{01 10 01 01}$  
这里把它两位一断，就能很容易的发现，对于每两位来说，这两位的二进制数，就是这两位上$1$的个数  

然后继续观察，发现$\texttt{0x33}$的二进制是$\texttt{0011 0011}$  
那么$\texttt{01 10 01 01}\operatorname{and}\texttt{00 11 00 11}=\texttt{00 10 00 01}$  
这个什么意思？当然是如果每两位分一段的话，保留$1,3$段中的$1$  
同样，左移两位再与，就是保留$2,4$段的$1$并放在$1,3$段上  
再加起来，结果就是$\texttt{0011 0010}$  
此时，把它四位一段，前四位的二进制数是表示前四位有多少$1$，后四位也一样  

现在差不多就明白了，其实这个方法就是不断把相邻位的$1$的个数合并到一个更大的区间去，最后，就是整个$x$表示$x$中$1$的个数  
返回$x$  

然而这个比上一种方法的总时间也就快了不到半秒  

放上完整代码  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n;
inline int cnt1(int x){
	reg int ret=0;
	while(x) ret+=x&1,x>>=1;
	return ret;
}
inline int cnt2(int x){
	reg int ret=0;
	while(x){
		ret++;
		x^=(x&(-x));
	}
	return ret;
}
inline int cnt3(reg int x){    
    x=(x&0x55555555)+((x>>1)&0x55555555);
    x=(x&0x33333333)+((x>>2)&0x33333333);
    x=(x&0x0f0f0f0f)+((x>>4)&0x0f0f0f0f);
    x=(x&0x00ff00ff)+((x>>8)&0x00ff00ff);
    x=(x&0x0000ffff)+((x>>16)&0x0000ffff);
    return x;   
}
inline int cnt4(reg LL x){    
    x=(x&0x5555555555555555ll)+((x>>1)&0x5555555555555555ll);
    x=(x&0x3333333333333333ll)+((x>>2)&0x3333333333333333ll);
    x=(x&0x0f0f0f0f0f0f0f0fll)+((x>>4)&0x0f0f0f0f0f0f0f0fll);
    x=(x&0x00ff00ff00ff00ffll)+((x>>8)&0x00ff00ff00ff00ffll);
    x=(x&0x0000ffff0000ffffll)+((x>>16)&0x0000ffff0000ffffll);
    x=(x&0x00000000ffffffffll)+((x>>32)&0x00000000ffffffffll);
    return x;
}
int main(){
	n=read();reg int a=read(),b=read(),c=read(),d=read(),x=read();
	a%=d;b%=d;c%=d;x%=d;
	reg int even=0,odd=0;
	while(n--){
		x=((1ll*a*x%d*x%d)+(1ll*b*x%d)+c)%d;
		(cnt3(x)&1)?odd++:even++;
	}
	std::printf("%lld",1ll*odd*even);
	return 0;
}
```

---

## 作者：Iamacat (赞：3)

看了楼上巨佬的题解，没看懂（果然是我太弱了），所以自己写了一份。。。（第一次写题解求勿喷）

数据摆明了要O(n),所以要O(1)算出每个点和它前面的所有点的edge数和。经过一番找规律，我们可以发现当a^b和a^c均有奇数个1时，b^c有偶数个1；当a^b有奇数个1，a^c有偶数个1时，b^c有奇数个1。大致O(1)思路就有了，其余见程序。

（码风奇特求包容）

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll R()                 //请无视此快读
{
    ll an=0,kk=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')kk=-1;c=getchar();}
    while(c>='0'&&c<='9')an=an*10+c-'0',c=getchar();
    return an*kk;
}
int main()
{
	ll n=R(),a=R(),b=R(),c=R(),d=R(),x=R(),an=0,cnt=0,y,z;
	x=(a*x%d*x%d+b*x%d+c)%d;  //a*x*x%d会爆
	for(int i=2;i<=n;i++)
	{
		y=(a*x%d*x%d+b*x%d+c)%d;
		x^=y;z=0;             //x现为x^y
		for(;x;z+=x%2,x/=2);  //统计xor的1的个数
		if(z%2)cnt=i-cnt-1;   //若统计结果为奇，该点贡献值为前一项无edge的点数+1；否则贡献值等于前一点
		an+=cnt;x=y;
	}
    cout<<an;return 0;
}
```

---

## 作者：ZXZ695 (赞：1)

这篇题解循序渐进，易于理解,且重点都已经标粗提醒

NOIP貌似不能用__的函数，还是尽量不要用吧．．．

还是先挂一下[博客](https://www.cnblogs.com/sky-zxz/p/9827318.html)，阅读体验更佳．．

**问题**：给定两个数a,b，判断a^b在二进制表示下1的个数的**奇偶性**。

**分析**：设a在二进制表示下1的个数为x,b在二进制表示下1的个数为y,a中0匹配了b中k个1.

**故结论为**： a^b中1的个数为2*k-y+x，可见a^b中1的个数的奇偶性只与x和y有关，观察可得，如果x,y中一奇一偶，那么答案就是奇数。(严格的证明还是不会．．．)
 

**问题强化版**：求在1---->n中任选a,b（a!=b），使得a^b在二进制表示下1的个数为奇数，求a,b的配对方案数,a^b与b^a算是一种情况。(n<=1e7)

**分析**：由上分析可得，我们可以在O(1)的情况下判断a^b在二进制表示下1的个数的奇偶性，**那么如何求出a^b在二进制表示下1的个数呢？**

首先提供O(log(n))的方法：
```cpp
    ll tot=0;（long long int）
    while(w){
        if(w&1)++tot;//暴力统计1的个数
        w>>=1;    
    }
```
这种方法是每次判断末尾为1还是0，但是我们得求出每个数字的1的个数，在1e7的范围下，O（nlog(n)）的方法显然不够用，我们需要一种**O(1)**求个数的方法，我这里提供两种方法（代码参考[博客](https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html)）：

模板1：
```cpp
int BitCount4(unsigned int n) 
{ 
    n = (n &0x55555555) + ((n >>1) &0x55555555) ; 
    n = (n &0x33333333) + ((n >>2) &0x33333333) ; 
    n = (n &0x0f0f0f0f) + ((n >>4) &0x0f0f0f0f) ; 
    n = (n &0x00ff00ff) + ((n >>8) &0x00ff00ff) ; 
    n = (n &0x0000ffff) + ((n >>16) &0x0000ffff) ; 
    return n ; 
}
```
模板2：

```cpp
int BitCount5(unsigned int n) 
{
    unsigned int tmp = n - ((n >>1) &033333333333) - ((n >>2) &011111111111);
    return ((tmp + (tmp >>3)) &030707070707) %63;
}
```
感觉都好记，根据个人爱好选一种吧！



回到加强版的题目，现在问题只在于如何枚举a,b,其实我们并**不需要枚举a,b**，

只需要知道一个在（**二进制表示下1的个数为奇数的数**）和(**1的个数为偶数的数**)是可以贡献答案的，**奇可以和偶配对**，所以我们只需要求出 tot1=奇数数量 和 tot2=偶数数量,贡献即为 **tot1*tot2**即可。

 

下面放题目链接：

洛谷10月月赛2T1[链接](https://www.luogu.org/problemnew/show/P4932)//这道题...打月赛的时候忘记取模

AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define R register
#define ll long long int 
using namespace std;
ll n,a,b,c,d;
ll ans,x,w,odd,even;
inline ll getx(){
     return (((a*x)%d*x)%d+b*x%d+c)%d;
}
inline ll get1(R ll k){
    R ll tot=k-((k>>1)&033333333333)-((k>>2)&011111111111);
    return ((tot+(tot>>3))&030707070707)%63;
}
int main(){
    scanf("%lld%lld%lld%lld%lld%lld",&n,&a,&b,&c,&d,&x);
    for(R ll i=1;i<=n;++i){
    x=getx();w=get1(x);
    if(w%2==1)++odd;
    else ++even;
    }
    printf("%lld",1LL*odd*even);
    return 0;
}
```
 

---

## 作者：田阙西 (赞：1)

作为蒟蒻一开始并没有看出来这题怎么写~参考了诸位的题解，然后自己摸索出一点经验：

一次异或操作的俗称为“同假异真”，我们要做的就是抓住这条定则。

假设一开始两个数在二进制情况下为1的位数数量分别为a，b。那么，如果两个数中1的位置互不相同，异或后得到的数中，为1的位数为c=（a+b）位。

考虑有1的位置相同的情况：每多一对1的位置相同，那么c-=2。而一个数减去一个小于等于它的偶数，奇偶性是不受影响的。

所以这道题的“异或”操作，就转化为：找两个数使他们的和为奇数。

由基本的数学知识得，只有 奇数 + 偶数 才能得到奇数。

于是分别统计原n个数中的奇数，偶数的个数，相乘即可。

*乘法操作容易溢出int，所以最好开longlong，并且每×一个数都要%一下，不然会wa（血的教训）

代码：
```
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#include<cstring>
#include<queue> 
#include<map>
#include<bitset>
using namespace std;
int fastRead()
{
    int r=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){r=r*10+c-'0';c=getchar();}
    return f*r;
}
long long n, a, b, c, d, p; 
long long x[10000010];
long long ans1,ans2;
bool countNum(int x){
    p=0;
    while(x){
        p++;
        x -= x & (- x);
    }
    if(p & 1)return 1;
    else return 0;
}
int main()
{
    n = fastRead(), a = fastRead(), b = fastRead(), c = fastRead(), d = fastRead(), x[0] = fastRead();
    a %= d, b %= d, c %= d, x[0] %= d;
    for(int i = 1; i <= n; ++i){
        x[i] = ((a * x[i-1] % d) * x[i-1] % d + b * x[i-1] % d + c) % d;
    }//xor 同假異真 101 xor 100 = 10(2)
    for(int i = 1; i <= n; ++i){
        if(countNum(x[i]))ans1 ++;
        else ans2 ++;
    }
    printf("%lld", ans1 * ans2);
    return 0;
}
```


---

## 作者：mydiplomacy (赞：1)

对于两个二进制数的某一位，

若这两个数都是零，则它们异或后的数是零

若这两个数都是一，则它们异或后的数是零

若这两个数中有一个一，则它们异或后的数是一

#### 所以，当两个二进制数的某个数位都是1的时候，它们的异或值会同时消掉这两个1，变成0.

#### 可以推得，

若某两个二进制数，这两个二进制数的数位 含'1'的个数 都是偶数或者都是奇数，则它们异或之后的值得二进制数位中含‘1’的个数也是偶数

若某两个二进制数，其中一个二进制数的数位中含‘1’的个数是偶数，另一个含‘1’的个数是奇数，则它们异或后含‘1’的个数是奇数

### 所以，对于两个二进制数来讲， 它们含‘1‘的数量之和的奇偶性 与 它们异或结果含’1‘的数量奇偶性 是一样的。

因此，若我们统计出统计出来这$n$个数中，含’1‘数量为奇数的数有$x1$个，含’1’数量为偶数的有$x2$个，则$x1*x2$就是答案。

接下来的问题是，对于一个数t来讲，如何快速统计出t在二进制下含有几个'1'数位？

log t的做法是显然的（逐个二进制位统计），但更好的统计方法是NOIP2018初赛中考过的方法：

```cpp
while(x)
{
    if(x%2)
    	sum++;
    f[i]=(f[i]&(f[i]-1));
}
```

所以最终的时间效率是$O(n*logv)$，但不是满的，可以过掉1500ms。

```
#include <iostream>
#include <cstdio>

#define int long long

using namespace std;

const int maxn=1e7+3;

int f[maxn];
int n,a,b,c,d,x0;
int ansj,anso; //ansj: 含有奇数个'1'的数的个数
			   //anso: 含有偶数个'1'的数的个数

signed main()
{
    cin>>n>>a>>b>>c>>d>>x0;
    f[0]=x0;
    for(int i=1;i<=n;i++) 
    {
        f[i]=(((long long)(f[i-1]))*f[i-1]%d*a%d+((long long)(f[i-1]))*b+c)%d;
    }
    for(int i=1;i<=n;i++)
    {
    	int sum=0;
    	while(f[i])
    	{
    		if(f[i]%2)
    			sum++;
    		f[i]=(f[i]&(f[i]-1));
        }
        if(sum%2) ansj++;
        else anso++;
    }
    cout<<ansj*anso<<endl;
    return 0;
}
```
记得开long long，我就是因为没开long long比赛的时候被卡成65分QwQ

---

## 作者：Liu_Tianze (赞：0)

# P4932 浏览器 题解

[**题目链接**](https://www.luogu.com.cn/problem/P4932)

推荐跳转至[**我的博客**](https://www.luogu.com.cn/blog/Liu-Tianze/P4932)进行阅读

### 题目分析
观察数据约定我们发现本题应采用 $O(N)$ 级别的运算。

所以循环枚举每一个 $x_i$ 的值，即:

$x_i = ( ax_{i-1}^2 + bx_{i-1} + c ) \mod d$

对于计算二进制表示下 $1$ 的个数，可以使用 `lowbit` 算法进行解决:

```cpp
while(s>0){
	s^=s&(-s);
	tot++;
}
```
可以使用本方法的原始因为**位运算**的运算速度远高于循环方式求解。

在本题中还有许多细节：

- 记得开 `long long` ；

- 计算 $x_i$ 时 $ax_{i-1}^2$ 可能会爆，所以可以先进行一次取模 $d$ 的操作；

- 最后答案为所有 **二进制表示下有奇数个 $1$ 的总数** 与 **偶数的总数** 相乘。

### 代码

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int main(){
	long long i,n,a,b,c,d,l;
	cin>>n>>a>>b>>c>>d>>l;
	long long s,j=0,o=0;
	for(i=1;i<=n;i++){
		s=(a*l%d*l+b*l+c)%d;
		l=s;
		long long tot=0;
		while(s>0){
			s^=s&(-s);
			tot++;
		}
		if(tot%2==0) o++;
		else j++;
	}
	cout<<o*j<<endl;
	return 0;
}
```


---

## 作者：囧仙 (赞：0)

## 题解

考虑将 $\operatorname{popcnt}(x\oplus y)$ 拆下来。讨论 $x$ 和 $y$ 每个二进制位上的情况：

- 设形如 $1\oplus 1=0$ 的情况出现了 $a$ 次。即有 $a$ 个二进制位上，$x$ 和 $y$ 均为 $1$。
- 设形如 $1\oplus 0=1$ 的情况出现了 $b$ 次。即有 $b$ 个二进制位上，$x$ 为 $1$，而 $y$ 为 $0$。
- 设形如 $0\oplus 1=1$ 的情况出现了 $c$ 次。即有 $c$ 个二进制位上，$x$ 为 $0$，而 $y$ 为 $1$。
- 设形如 $0\oplus 0=0$ 的情况出现了 $d$ 次。即有 $d$ 个二进制位上，$x$ 和 $y$ 均为 $0$。

于是有 $\operatorname{popcnt}(x\oplus y)=b+c$。

记 $\operatorname{popcnt}(x)=u,\operatorname{popcnt}(y)=v$，那么可以列出这样的方程组：

$$
\begin{cases}
a+b=u \cr
a+d=v
\end{cases} \Rightarrow b+c=u+v-2a
$$

那么，

$$\operatorname{popcnt}(x\oplus y)\equiv b+c\equiv u+v-2a\equiv u+v \pmod 2$$

假设题目给定的数组 $a$ 里，共有 $p$ 个数有奇数个 $1$，共有 $q$ 个数有偶数个 $1$，于是最终的答案即为 $pq$（考虑对于满足题设要求的无序二元组 $(a_i,a_j)$，钦定 $\operatorname{popcnt}(a_i)$ 为奇数，$\operatorname{popcnt}(a_j)$ 为偶数，那么显然第一个位置有 $p$ 种选择，第二个位置有 $q$ 种选择，由乘法原理可得）。

那么就是要快速计算 $\operatorname{popcnt}(a_i)$。考虑预处理 $b_i=\operatorname{popcnt}(i),i=0,1,2,\cdots,(2^{16}-1)$，那么就有：

$$\operatorname{popcnt}(a_i)=b_{a_i \operatorname{and}\big(2^{16}-1\big)}+b_{a_i\operatorname{rshift} 16}$$

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int n,a,b,c,d,x;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int T[65536],p,q;
int main(){
    n=qread();
    a=qread(),b=qread(),c=qread(),d=qread(),x=qread();
    up(0,65535,i) T[i]=T[i>>1]+(i&1);
    up(1,n,i){
        x=((1ll*a*x%d+b)*x%d+c)%d;
        if((T[x>>16]+T[x&65535])&1) ++p; else ++q;
    }
    printf("%lld\n",1ll*p*q);
    return 0;
}
```

---

## 作者：zrzluck99 (赞：0)

看到没有pascal题解所以本蒟蒻来一发题解

初看感觉这个题目不好下手，但是试几次以后能发现：

**两个数xor后，二进制含1的个数和这两个数含1个数之和的奇偶性相同（如下）：**

```
101011101   6个
001011010   4个
---------
100000111   4个
```

证明：两个数xor的法则：

0 xor 0 = 0

0 xor 1 = 1

1 xor 0 = 1

1 xor 1 = 0

可见每一位要不就是1个数不变，要不就是两个1抵消，所以不会影响奇偶性。所以只要分别求出数列中含1个数为奇数和偶数的个数，答案就是它们的乘积。

求x的二进制中1的个数可以不断 x:=x and (x-1) 来求。（每年初赛都会有些有用的东西/滑稽）

最后一点，递推每一步都要分步取模（我比赛时WA两个点的原因就是因为没有疯狂取模%%%）

下面是略丑的代码：

```pascal
var
    p:array[1..10000001] of int64;
    n,a,b,c,d,i:longint;
    s:int64;

function get1(x:int64):longint;
var
    res:longint;
begin
    res:=0;
    while x>0 do begin
        x:=x and (x-1);
        inc(res);
    end;
    exit(res);
end;

begin
    readln(n,a,b,c,d,p[0]); s:=0; p[0]:=p[0] mod d;
    for i:=1 to n do begin
        p[i]:=(((a mod d)*(p[i-1] mod d) mod d)*(p[i-1] mod d) mod d+(b mod d)*(p[i-1] mod d) mod d+c mod d) mod d;
        s:=s+get1(p[i]) mod 2;
    end;
    writeln((n-s)*s);
end.
```        



---

## 作者：Kaizyn (赞：0)

关于此题总结一些求**二进制下1的数量的奇偶性**的方法

1. 暴力求解 $O(\log n)$

	```cpp
    while(x)
    {
        cnt += x&1;
        x >>= 1;
    }
    ```
    由于数据的随机性导致算法难达到上界,所以能水过
    
    ---
    
2. 利用 $bitset$
	
    count函数返回1的位数

	```cpp
    bitset<32> tmp(x);
    sum[tmp.count()&1]++;
    ```
    效率应该和以下几种相同
    
    > *摘自洛谷日报* [二进制与位运算](https://www.luogu.org/blog/chengni5673/er-jin-zhi-yu-wei-yun-suan)
    
    > **bitset 的复杂度**：因为bitset是用 uint/long long 类型来实现每次同时操作 32/64 个 01 变量的东西，所以他的很多操作都是 O(1) 或 O(n/32) / O(n/64) 的。至于是 32 还是 64 ，一般看机器是32位还是64位
    
    ---
    
3. 神奇的函数

	```cpp
    __builtin_parity(x)
    ```
    返回一个数二进制下1的数量的奇偶性
    
    ```cpp
    __builtin_popcount(x)
    ```
    返回一个数二进制下1的数量
    
    ---
   
4. 打包位统计$O(1)$

	*参考李博杰的《骗分导论》 P21*
    
    因为__开头的函数在NOIP不好用
    
    ```cpp
    inline int popcount(unsigned x)
    {
        x ^= x>>1; x ^= x>>2;
        x ^= x>>4; x ^= x>>8;
        x ^= x>>16;
        return x&1;
    }
    ```
    
    神奇的位运算处理后 运算结果的第 i 位表示在原始数据中从第 i 位到最高位 true 数目的奇偶性
    
    原理是这样的
    
    首先我们知道 **异或^** 的性质
    
    在二进制的世界里(只有0,1),任何数异或1取反,任何数异或0不变
    
    所以我们把x的二进制的每一位异或起来,结果是0说明x二进制有偶数个1,结果是1说明x二进制有奇数个1
    
    那么再看算法 我们把x(假设是unsigned)看成二进制数 x[32],在来一个a[32]表示位运算后的结果
    
    ```cpp
    第一步:x^=x>>1,此时有
    a[32] = x[32]^x[33] // 32-33位的奇偶性,x[33]是0,不影响
    a[31] = x[31]^x[32] // 31-32位的奇偶性
    ...
    a[1] = x[1]^x[2]    // 1-2位的奇偶性
    
    第二步:x^=x>>2,此时有
    a[31] = (x[31]^x[32])^a[33]
          = (x[31]^x[32])^(x[33]^x[34]) // 31-34位的奇偶性
    a[30] = (x[30]^x[31])^a[32]
          = (x[30]^x[31])^(x[32]^x[33]) // 30-33位的奇偶性
    ...
    懒得打了
    ```
    
    总之,能看懂吧...
    
    所以最后 运算结果的第 i 位表示在原始数据中从第 i 位到最高位 true 数目的奇偶性
    
    得知原理之后我自行编写了一个模板
    
    ```cpp
    template <typename T> inline unsigned popcount(T x)
    {
    	// 用sizeof求出该类型占用的字节数,每个字节是8bit
        for(unsigned i = 1; i < sizeof(T)*8; i <<= 1)
            x ^= x>>i;
        return x&1;
    }
    ```
    当然稍加变形,可以还求出二进制下某段区间的奇偶性
    
    ---
    
    再来个 统计1的数目
    
    ```cpp
    int count(unsigned int x)
    {
        x=(x&0x55555555)+(x>>1&0x55555555);
        x=(x&0x33333333)+(x>>2&0x33333333);
        x=(x&0x0F0F0F0F)+(x>>4&0x0F0F0F0F);
        x=(x&0x00FF00FF)+(x>>8&0x00FF00FF);
        x=(x&0x0000FFFF)+(x>>16&0x0000FFFF);
        return x;
    }
	```
    
    ---
    
### 总结

方法1最简单,而且也能过,效率最慢

方法2,3,4效率相同,应该都是O(1)

(本人O2下实测差距在20ms之内https://www.luogu.org/recordnew/lists?uid=53116&pid=P4932)

方法3在竞赛中可能行不通,而且要不是题解里许多大佬指出,我压根不知道有这玩意儿

方法4...你若理解,那便安好

所以方法2是妥妥的最合适蒟蒻我的啦

---

## 作者：Skeleton (赞：0)

这道洛谷月赛T1是真香（光速逃

首先，我们看题，找一个数二进制下1的个数，woc？这不是TG选择第十题吗？哈哈，还好，还记得。

以下部分代码为找一个数二进制下1的个数：
```cpp
ll cntnum(ll x)//之前define过#define ll long long
{
	ll res=0;//统计1的个数
	while(x)
	{
		res++;
		x&=x-1;//没什么好说的了，自己动手推一下，丰衣足食~
	}
	return res;
}
```

但是，比赛中我提交时候还真的天真的按照连边做了，导致我开了一个10001*10001的二维数组，炸了！Bang~

贴出60分RE代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int Maxn=1e7+1;
int n;
int edg[10001][10001];//数组太大了，而且n是最大取值1e7，根据题意还远远不够
ll a,b,c,d,cnt;
ll p[Maxn];
ll num[Maxn];//数的值到了1e9，也是不够的

ll cntnum(ll x)
{
    if(num[x])//表面上的记忆化，QWQ
    {
        return num[x];
    }
    ll res=0,rec=x;
    while(x)
    {
        res++;
        x&=x-1;
    }
    num[rec]=res;
    return res;
}
int main()
{
    scanf("%d %lld %lld %lld %lld %lld",&n,&a,&b,&c,&d,&p[0]);
    for(int i=1;i<=n;i++)
    {
        p[i]=(a*p[i-1]*p[i-1]+b*p[i-1]+c)%d;//取模这里暂且先不说
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(i!=j)
            {
                if(edg[i][j])
                {
                    continue;
                }
                if(cntnum(p[i]^p[j])%2)
                {
                    cnt++;
                    edg[i][j]=edg[j][i]=1;//标记
                }
            }
        }
    }
    printf("%lld\n",cnt);
    return 0;
}
```

赛后，看了出题人的解释之后，自己动手改了一下，发现这道题是一个完全找规律的题，发现两个数取异或之后，在二进制下1的个数的奇偶性取决于两个数分别的二进制下1的个数，当一奇一偶时，即可建边，一下贴出90分代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int Maxn=1e7+1;
int n;
ll a,b,c,d,cnt1,cnt2;
ll p[Maxn];

ll cntnum(ll x)
{
    ll res=0;
    while(x)
    {
        res++;
        x&=x-1;
    }
    return res;
}
int main()
{
    scanf("%d %lld %lld %lld %lld %lld",&n,&a,&b,&c,&d,&p[0]);
    for(int i=1;i<=n;i++)
    {
        p[i]=(a*p[i-1]*p[i-1]+b*p[i-1]+c)%d;//这里出现了问题QAQ~
    }
    for(int i=1;i<=n;i++)
    {
        if(cntnum(p[i])&1)//统计奇数和偶数个数
        {
            cnt1++;
        }
        else
        {
            cnt2++;
        }
    }
    printf("%lld\n",cnt1*cnt2);//最后相乘即可
    return 0;
}
```

但是最后问题出在哪呢，取模！！！

没做完一部乘法之后都应该取模！！！

这样就A掉了，个人感觉是一道绿题，标签：数论，数学。

最后贴出AC代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int Maxn=1e7+1;
int n;
ll a,b,c,d,cnt1,cnt2;
ll p[Maxn];

ll cntnum(ll x)
{
    ll res=0;
    while(x)
    {
        res++;
        x&=x-1;
    }
    return res;
}
int main()
{
    scanf("%d %lld %lld %lld %lld %lld",&n,&a,&b,&c,&d,&p[0]);
    for(int i=1;i<=n;i++)
    {
        p[i]=(a*p[i-1]%d*p[i-1]%d+b*p[i-1]%d+c)%d;//取模大法！！！
    }
    for(int i=1;i<=n;i++)
    {
        if(cntnum(p[i])&1)
        {
            cnt1++;
        }
        else
        {
            cnt2++;
        }
    }
    printf("%lld\n",cnt1*cnt2);
    return 0;
}
```
珍爱生命，远离抄袭，远离棕名。

经过一次月赛，发现出现了大量棕名，所以希望大家一定要自己动手推一推，不是自己的东西永远也不可能成为自己的。

最后祝大家：NOIp2018 rp++

---

## 作者：chengni (赞：0)

上面大佬已经说了，这道题记录下 popcount 的奇偶数量就能做了

统计popcount奇偶性的话，介绍一个函数 **__builtin_parity**

这个函数直接能返回一个数二进制下 $1$ 的数量的奇偶性，

当然直接计算 $1$ 的个数的复杂度也是可以优化的，并不一定是 $log^v$，可以是 $O(k)$ (k为1的数量)

直接用类似于 lowbit 的方法就可以了，每次减去 lowbit，就是消掉了一个 $1$

不过似乎直接 $log^v$ 也能过啊

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read(){
    char ch=getchar();ll x=0,f=1;
    while(ch<'0' || ch>'9') {
       if(ch=='-') f=-1;
      	  ch=getchar();
    }
    while(ch<='9' && ch>='0') {
       x=x*10+ch-'0';
       ch=getchar();
    }
    return x*f;
}

ll x[10101001]; 

ll dan=0,shuang=0;

int main(){
    int n=read(),a=read(),b=read(),c=read(),d=read();x[0]=read();
    for(int i=1;i<=n;i++){
        x[i]=(x[i-1]*x[i-1]%d*a%d+b*x[i-1]%d+c)%d;
        if(__builtin_parity(x[i])) dan++;
        else shuang++;
    }
    cout<<dan*shuang;
    return 0;
}

```

---

## 作者：Emilyu (赞：0)

**题意：**有$n$个点，第$i$个点有权值$x[i]$，对于两个点$u$和$v$，如果$x[u]\ xor\ x[v]$的结果在二进制表示下有奇数个$1$，那么在$u$和$v$之间连接一个$Edge$，求出一共有多少个$Edge$。

**输入格式：**
一行六个整数，$n$，$a$，$b$，$c$，$d$，$x[0]$。$n$是点的个数，每个点的权值需要用如下的方式生成。

你需要使用$a$，$b$，$c$，$d$和$x[0]$生成一个数组$x$，生成方式是这样的：
$$x_i = (ax_{i-1}^2 + bx_{i-1} + c) mod \ d$$$x[i]$就是第$i$个点的权值，点的标号是$1$到$n$。

**输出格式：**
输出一个整数，表示一共有多少个$Edge$。

**思路：**我们记$\ ones(x)\ $表示$x$在二进制表示下$1$的个数。可以发现，当$\ ones(a)\ $和$\ ones(b)\ $是一奇一偶的时候，$\ ones(a\ xor\ b)\ $是奇数，否则就是偶数。因此，我们只需要用$O(1)$统计每个点的权值的ones，用奇数的个数乘以偶数的个数就是答案。

**$AC$代码：**

```
#include <cstdio>
#include <cctype>
#include <cstring>
typedef unsigned int ui;
const int N = 1e7+5;
ui x[N];
ui n, m;

inline ui read()
{
	ui v = 0, f = 1;
	char c = getchar();
	for(; !isdigit(c); c = getchar())
		if(c == '-') f = -1;
	for(; isdigit(c); c = getchar()) v = (v<<3) + (v<<1) + c - '0';
	return v*f; 
}

void getx(ui a, ui b, ui c)
{
	for(ui i = 1; i<=n; i++)
		x[i] = ((((((1ll*a*x[i-1])% m)* x[i-1])% m + 1ll*b*x[i-1])% m)+ c)% m;
}

ui ones(register ui x)	//O(1)统计ones
{
    x -= ((x >> 1) & 0x55555555);
    x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
    x = (((x >> 4) + x) & 0x0f0f0f0f);
    x += (x >> 8);
    x += (x >> 16);
    return(x & 0x0000003f);
}

int main()
{
	ui a, b, c;
	n = read(), a = read(), b = read(), c = read(), m = read(), x[0] = read();
	getx(a, b, c);	//计算x[i]
	ui odd = 0, even = 0;
	for(int i = 1; i<=n; i++)
	{
		if(ones(x[i])&1) odd++;
		else even++;
	}
	printf("%lld", 1ll*odd*even);
	return 0;
}
```

---

## 作者：BeyondStars (赞：0)

~~详细的~~解释一些楼下的题解
首先要生成一个x数组对吧？该取模取模。但是注意取模的式子应该是这样的：((a%d*x[i-1]%d*x[i-1]%d+b*x[i-1]%d+c%d)%d+d)%d 就是为了防止它变成负数。
然后注意观察,a xor b中1的个数的奇偶性与a和b中1的个数的奇偶性有关，**当且仅当**a和b中1的个数为奇数时，a xor b中的1的个数是奇数，否则为偶数。对此的解释：
>我们考虑两种情况，a中的1和b中的1是否在同一位置(能否对上)。
1.如果能对上的个数为奇数，如果a中1的个数为奇数，b中个数为偶数，我们先把对上的1的个数忽略。如果a中1的个数为奇数，那么忽略以后a中1的个数为偶数，b中也为偶数，所有a xor b中1的个数为偶数。如果a中1的个数为偶数，b中也为偶数，忽略掉以后，a中1的个数为奇数，b中也为奇数，那么a xor b中的1的个数为偶数。用这种思想，可以得到以上结论

~~语文不太好，如果说的不清楚见谅~~不懂可以私信问我
然后，就简单了，只需要把含有1的个数为奇数的数统计出来，用这个数量乘以含有1为偶数的数的数量想乘，就是答案。这样做复杂度是O(nlogv)。楼下也提到过。但是还是会T掉。那么怎么办呢？经过冥思苦想，我们发现可以把一个数拆了，拆成高低各16位，这样，把这$2^{16}$个数打表，打出来以后，就直接把一个数拆了，然后分别查询高低位里面的1的个数，最后加起来(获得高16位可以直接右移16，获得低16位可以&0xFFFF这个应该能理解吧，不能理解问我)。然后乘一下就行。
以下是AC代码：
```cpp
// luogu-judger-enable-o2
#include <iostream>
using namespace std;
int n,a,b,c,d;
long long x[(int)1e7+50];
int bits_table[69545];
inline int popbit(long long k){//用lowbit计算有多少个1
    int ans = 0;//这样有时候会比右移检测位要快一点
    while(k){
        ans++;
        k-=(k&-k);
    }
    return ans;
}
void gen(){
    for(int i = 1;i<=n;i++)x[i]=((a%d*x[i-1]%d*x[i-1]%d+b*x[i-1]%d+c%d)%d+d)%d;

    for(int i = 1;i<=65535;i++){
        bits_table[i] = popbit(i);//高低16位中1的个数
    }
}
int main(void){
    ios::sync_with_stdio(false);
    cin>>n>>a>>b>>c>>d>>x[0];
    gen();
    long long single = 0;
    long long even = 0;
    for(int i = 1;i<=n;i++){
        int t = 0;
        t += bits_table[x[i]>>16];//高16位 
        t += bits_table[x[i]&0xFFFF];//低16位 
        if(t&1)single++;
        else even++;
    }
    cout<<single*even<<endl;
    return 0;
}
```
~~抄~~看完代码了，安利一波我的博客[denghaoyu.leanote.com](denghaoyu.leanote.com)写的比较水，请各位dalao原谅，如果有错误，欢迎向本蒟蒻指正

---

## 作者：mureZ (赞：0)

可爱的__stdcall大佬都说得非常明白了

~~毕竟是出题人~~


但是本蒟蒻发现自己的$O(n)$方法好像不太一样...

首先是一个玄学的popcnt统计代码
```
int BitCount(unsigned int n){
	unsigned int c=0;
	for (c=0;n;++c){//遍历n的最小的1的位置
		n&=(n-1);//将n移到最小的1的位
	}
	return c ;
}

```

既然需要对所有的边都进行判定，那么按照暴力的想法，需要写一个双重循环去暴力判定
如下伪代码：
```
for (i,1,n)
	for (j,1,i-1)
    	if ( popcnt(x[i] xor x[j]) is odd)
        ans++
```
这么暴力一定会被续的

所以就要考虑 $x[i]$ 和 $x[i-1]$ 对结果的贡献了

考虑若$a \oplus b$与$a \oplus c$与$b \oplus c$的1的个数的奇偶性

不难发现规律若$a \oplus b$的popcnt为奇，$b \oplus c$为奇,则$a \oplus c$为偶

反之亦然

所以如果$x[i] \oplus x[i-1]$的popcnt为奇,则$x[i]$可以和所有不能和$x[i-1]$的点建边，

如果$x[i] \oplus x[i-1]$的popcnt为偶,则$x[i]$可以和所有能和$x[i-1]$的点建边，

那就新建一个数组，存储$x[i]$可向下连接的边数，称为$p[i]$

所以$O(n^{2})$变$O(n)$的伪代码如下
```
for (i,1,n)
	if (popcnt(x[i] xor x[j]) is odd){
		p[i]=i-1-p[i-1]
	else p[i]=p[i-1]
    
	ans+=p[i]
```

综上所述在下给出25行AC代码
```
#include <iostream>
#define N 10000005
using namespace std;
long long n,a,b,c,d,x[N],p[N];
unsigned long long counter=0;
int BitCount(unsigned int n){
	unsigned int c;
	for (c=0;n;++c) n&=(n-1);
	return c ;
}
int main(void){
	cin>>n>>a>>b>>c>>d>>x[0];
	a%=d;b%=d;c%=d;x[0]%=d;//暴膜
	for (unsigned int i=1;i<=n;++i){
		x[i]=((a*x[i-1])%d*x[i-1]%d+b*x[i-1]%d+c)%d;//暴膜
		long long k = x[i]^x[i-1];
			if (BitCount(k)&1!=0){
				p[i]=i-1-p[i-1];
			}
			else p[i]=p[i-1];
		counter+=p[i];
	}
	cout<<counter<<endl;
	return 0;
}
```
QAQ

__stdcall 坠可爱了

---

## 作者：猫粮寸断 (赞：0)

首先这是一道位运算的题，对于位运算我们思路就是分每一位讨论

观察一下，当两个数取异或时，结果中1的个数与什么有关？

我们可以把数分为两类，第一类数有奇数个1，另一类数有偶数个1，当它们异或时，我们可以发现：结果中1个数的奇偶性只与原本两个数中1个数的奇偶性有关！

简单来说，我们只需要统计有多少个数有奇数个1，剩下的数有偶数个1，结果就是两类数个数的乘积
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int ni[30];
int main()
{
	int n,i,shu=0,j;
	long long a,b,c,d,x,last,ans=0;
	cin>>n>>a>>b>>c>>d>>last;
	for(i=1;i<=n;i++)
	{
		x=((last*last)%d)*a%d;
		x=(x+((last*b)%d))%d;
		x=(x+c)%d;
		last=x;
		shu=0;
		while(x)
		{
			if(x&1)
			 shu++;
			x>>=1;
		}
		if(shu&1)
		 ans++;
	}
	cout<<ans*(n-ans);
	return 0;
}
```

---

## 作者：Slr神龙人 (赞：0)

首先异或的话我们应该想到拆位处理

然后有一个很显然的结论：

两个数异或后二进制下1的个数奇偶性等于两个数1的个数的值

根据1^0=1,所以如果当前数二进制下1的个数为奇数，那么ta只能和二进制下1的个数为偶数个的数产生贡献

所以我们只要对二进制下1的个数是奇数还是偶数取前缀和即可
代码:
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int n,a,b,c,d,ji,ou,ans;
int x[10000010];
#undef int
int main(){
	#define int long long
	scanf("%lld%lld%lld%lld%lld%lld",&n,&a,&b,&c,&d,&x[0]);
	for(int i=1;i<=n;i++) x[i]=(a*x[i-1]%d*x[i-1]%d+b*x[i-1]%d+c)%d;
	for(int i=1;i<=n;i++) {
		int tot=0;
		while(x[i]){
			if(x[i]&1) tot++;
			x[i]>>=1;
		}
		if(tot&1) ans+=ou,ji++;
		else ans+=ji,ou++;
	}
	printf("%lld",ans);
}
```

---


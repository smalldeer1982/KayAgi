# 大师

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 说明/提示

设 $v$ 为最高的电塔高度。

对于前 $30\%$ 的数据，$n \le 20 $。

对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。

对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。

对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。

## 样例 #1

### 输入

```
8
13 14 6 20 27 34 34 41 
```

### 输出

```
50
```

## 样例 #2

### 输入

```
100
90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 
```

### 输出

```
11153
```

# 题解

## 作者：chengni (赞：261)

我感觉我被题解限制了思路

其实这道题是 $O(n^2)$ 的

对于两个数字，他们组成的等差数列的公差一定是一样的

那么我们不必去枚举公差，直接枚举第 $i$ 个数前面那个数，得到公差进行转移即可

用 $f[i][j]$ 表示以 $i$ 结尾公差为 $j$ 的等差数列个数

转移如下

```cpp
	int p=20000;
	for(int i=1;i<=n;i++){
        ans++;
        for(int j=i-1;j;j--){
            f[i][a[i]-a[j]+p]+=f[j][a[i]-a[j]+p]+1;
            f[i][a[i]-a[j]+p]%=mod;
            ans+=f[j][a[i]-a[j]+p]+1;
            ans%=mod;
        }
    }
```

以 $i$ 结尾且上一个数是 $j$ 的公差为 $k$ 的等差数列数量是以 $j$ 结尾公差为 $k$ 的等差数列数加一 

转移的过程中直接计数，顺便把数字数为一的区间加上

注意第二维数组开二倍将负数右移即可

这样只需要 $n^2$ 的转移就可以了



---

## 作者：__stdcall (赞：129)

### Prelude

比较简单的DP题，考察选手的基本DP能力，和合理枚举能力。

大概是D1T2的难度。

idea：ljt12138

造数据：__stdcall

---

### 30 pts

$n \le 20$

暴力分。

首先你要读懂题，题目的意思是，给你一个数组，求出有多少个非空子序列是等差数列。

所以可以用$O(2^n)$枚举一个子序列，再用$O(n)$判断她是不是等差数列。

总复杂度$O(2^n * n)$。

---

### 60 pts

$n \le 100, v \le 2000$

从这里开始就需要DP了。

我们观察到值域很小，这提示我们把和值域相关的量记入状态表示。

用$f(i,j)$表示以位置i结尾，公差为j的等差数列有多少个。转移的时候，枚举一个小于i的k，满足$h_k = h_i - j$，然后从$f(k,j)$转移到$f(i,j)$。

注意，公差可以是负数，因此这里的j也可以是负数。

转移的时候要小心，不要重复或者遗漏某些情况。

复杂度$O(n^2k)$。

---

### 80 pts

$n \le 1000, v \le 20000$

整个数组是一个等差数列。

在公差不为0的时候，任何几个相邻相隔k个位置的数字都可以组成一个等差数列。

这时候，我们只要枚举首项的位置和k，就可以很轻松地计算出答案。

注意，在公差等于0，也就是所有数字都相等的时候，答案是$2^n-1$，这一点需要特判，否则你会WA掉第13个点。

---

### 100 pts

$n \le 1000, v \le 20000$

考虑在60分的算法基础上继续优化。

我们可以把这个算法简化为，枚举一个公差d，然后统计有多少个公差为d的等差数列。

枚举公差的时间复杂度是$O(v)$，观察数据范围可以猜测，统计的时间复杂度是$O(n)$，总复杂度是$O(nv)$。

我们考虑60分的那个$O(n^2)$的DP，用到这个统计上来，用$f(i)$表示以i结尾的，公差为d的等差数列有多少个，转移的时候枚举一个小于i的k，然后当$h_k = h_i - d$的时候从$f(k)$转移到$f(i)$。

状态已经不可能再简化了，但是转移可以。

我们发现，转移相当于一个求和，对小于i的所有高度等于$h_i - d$的位置的DP值求和。

我们可以维护一个数组g来记录这个和，这样转移就只有两行了。

$f(i) = g(h_i - d)$

$g(h_i) = g(h_i) + f(i)$

总复杂度是$O(nv)$。


---

## 作者：Ivystorm (赞：55)

出题人正解$O(nv)$，我来一个更好的$O(n^2)$

我用的是二维$DP$，$f[i][j]$表示第$i$个点之前（包括自己）公差为$j$的数列长度（包括公差相等的不同数列）。

此处公差小（最大$20000$），所以数组开的下。（如果是$int$就用$map$记录）

再$O(n^2)$枚举当前点和从前面哪里转移而来的点。可以发现，每次枚举时，答案就要加上这个数列的长度，而且没有重复和遗漏。

所以这就可以去除标准$60'$题解的$k$。（因为我们是由两个数得到公差，而不是由公差来枚举数）

所以代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n;
int num[1010];
int ans;
int f[1010][40400];
int vis[1010][40400];
int bfc[1010];
int xsxs;
void getx(int nowi){
     for(int i=nowi-1;i>=1;i--){
        if(!vis[i][num[i]-num[nowi]+20200]){//因为更新的时候可能此位置被更新了多次，所以加上自己的长度单独判断一下
          f[i][num[i]-num[nowi]+20200]++;
          vis[i][num[i]-num[nowi]+20200]=1;
        }
        //cout<<"**IN "<<nowi<<" TO "<<i<<" GET "<<f[i][num[i]-num[nowi]+20200]<<endl;
        ans=(long long)(ans+f[i][num[i]-num[nowi]+20200])%998244353;//更新答案
        f[nowi][num[i]-num[nowi]+20200]=(long long)(f[nowi][num[i]-num[nowi]+20200]+f[i][num[i]-num[nowi]+20200])%998244353;//统计总共多长
     }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
       scanf("%d",&num[i]);
    for(int i=1;i<=n;i++)
       getx(i);
    cout<<ans+n;
    return 0;
}

```

---

## 作者：魂逝_秦月歌 (赞：39)

若与其他dalao题解有重复，纯属巧合。。。


话说这是10月月赛第二场的第二题。。。是一道蓝题

区间DP ， 状态还是很好设的。。。



------------
**就是设f[i][j]表示等差数列最后一个数位置为i，等差数列差值为j的数列个数**

ans需要不断累加，（还要%mod）

主要状态转移方程就是


f[i][a[j]-a[i]+N]=(f[i][a[i]-a[j]+N]+f[j][a[i]-a[j]+N]+1)%mod;

话不多说，贴上本蒟蒻的代码。。。

```
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <ctime>
#include <cctype>
#include <queue>
#include <map>
#include <set>
#include <vector>
#include <deque>
#define _v putchar ('\n')
#define _e putchar (' ')
#define ll long long
#define mx(x,y) x>y?x:y
#define mn(x,y) x<y?x:y
#define INF 9999999999999999999ll
#define INE -9999999999999999999ll
#define File(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
using namespace std;
char c;
inline void r(int &a){
	a=0;
	while((c=getchar())<48);
	while(c>47) a=a*10+c-'0',c=getchar();
}
inline void wr(int x){
	if(x<0) x=-x,putchar(45);
	if(x<10) {
		putchar(x+48);
		return ;
	}
	wr(x/10);
	putchar(x%10+48);
}
inline int ksm(int a,int b,int m){
	int ans=1;
	while(b){
		if(b&1)
		    ans=ans*a%m;
		a=a*a%m;
		b>>=1;
	}
	return ans;
}//上面是模板，自动忽略。。。
const int N=1005,M=40005;
int n,a[N],mod=998244353,ans,now,f[N][M];
int main (){
	r(n);
	for(int i=1;i<=n;i++)
	    r(a[i]);
	for(int i=1;i<=n;i++) {
		ans=(ans+i)%mod;//累加
		for(int j=i-1;j>=1;j--) {
			now=a[i]-a[j];//公差
			ans=(ans+f[j][now+N])%mod;
			f[i][N+now]=(f[i][now+N]+f[j][now+N]+1)%mod;//状态转移方程
		}
	}
	wr(ans),_v;
	return 0;
}
```

~~求给过啊。。。~~

---

## 作者：JMercury (赞：26)

这题莫名其妙的，怎么算复杂度都是$O(n^3)$啊……求解释~~或hack~~

---

求给定序列中子序列为等差数列的个数。

记$f[i][j]$为倒数第二项为$a[i]$,最后一项为$a[j]$的等差数列的总数；若$i=0$，说明这个等差数列只有1项。

这样可以二维转移。对于任意$a[i],a[j](i<j)$，若某一项$a[k](k<i)$能满足$a[j]-a[i]=a[i]-a[k]$，那么在所有以$a[k],a[i]$为结尾的等差数列肯定可以往后延伸一个$a[j]$。所以$f[i][j]+=f[k][i]$，转移方程基本成型。

初始化，每个数也可以单独成一个等差数列，那么$f[0][i]=1(1\leq i\leq n)$。

转移，$f[i][j]=f[0][i]+ \Sigma_{k=1}^{i-1}[a[j]-a[i]=a[i]-a[k]]f[k][i])$。每次枚举$i,j,k$，枚举到$n$即可。

最后统计所有的$f[i][j]$的和就是答案

~~然后复杂度不对但就是水过了（~~

附上AC代码

```cpp
#include<bits/stdc++.h>
const int mod=998244353;
const int maxn=1010;
using namespace std;

int n,ans;
int h[maxn];
int f[maxn][maxn];

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&h[i]),f[0][i]=1; ///在这里就初始化了
    ans+=n; ///统计答案
    for(int i=2;i<=n;i++)
        for(int j=1;j<i;j++)
        {
            f[j][i]=f[0][j];
            for(int k=1;k<j;k++) if(h[j]*2==h[k]+h[i]) f[j][i]=(f[j][i]+f[k][j])%mod;
            ans=(ans+f[j][i])%mod;
        }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：zrzluck99 (赞：18)

//这是本蒟蒻第一次参加月赛，也是第一次发题解QAQ

//如有不对的地方请指正

这是一道巧妙的DP题。

我们设 $f[i,k]$ 为以第 i 个电磁塔结尾的，公差为 k 的数列个数， $s[i]$ 代表以第 i 个电磁塔结尾的所有数列的总数，即 $s[i] = \Sigma f[i,k]+1$（这个1是加上只取第i个，其他都不取的数列个数）

很明显，枚举所有公差 ( -20000 ~ 20000 ) 会TLE。但是我们可以发现，并不是所有公差都会被取到，进一步说，只要遍历 i 之前所有数并做差，就是所有可能的公差了。

所以我们把时间复杂度优化到了 $O(n^2)$。

状态转移方程如下：

$f[i][a_{i}-a_{j}]=f[i][a_{i}-a_{j}]+f[j][a_{i}-a_{j}]+1$

$s[i]=\Sigma f[j][a_{i}-a_{j}]+1$

可以这样理解：在所有以第 j 项结尾的数列后追加一个 i，再加上 j 和 i 单独两项成的一个等差数列。

由于公差可能会重复，所以 f 数组的计算是叠加，并且 s 数组也是直接加上转移值的（这点我调了很久才调出来）

下面是喜闻乐见的上代码时刻：

```pascal
var
    f:array[-1..1001,-20001..20001] of int64;
    a,s:array[-1..1001] of int64;
    i,j,n:longint;
    ans:int64;
    
begin
    readln(n);
    for i:=1 to n do read(a[i]);
    s[1]:=1;  
    for i:=2 to n do begin
        s[i]:=1;  //单独取第i个，前面不取
        for j:=1 to i-1 do begin
            f[i,a[i]-a[j]]:=(f[i,a[i]-a[j]]+f[j,a[i]-a[j]]+1) mod INF; //计算以i为结尾，公差为a[i]-a[j]的数列个数
            s[i]:=(s[i]+f[j,a[i]-a[j]]+1) mod INF; //更新数列和
        end;
    end;
    for i:=1 to n do ans:=(ans+s[i]) mod INF; //累加所有可能
    writeln(ans);
end.
```

---

## 作者：Mizuhara (赞：17)

介绍一个较为好想的做法。

记$f[i][j]$为以第$i$位为为首项，第$j$为第二项的等差数列的个数。（$i<j$）

则显然有（真的显然，做多了线性动态规划的人相信都能看出）

$f[i][j]=\Sigma f[j][k]$，其中$j<k,A[i]-A[j]=A[j]-A[k]$

这样，状态$n^2$，转移$n$，总复杂度$O(n^3)$。

但$n$有$1000$，$n^3$为什么能过？

因为实际上,枚举$i,j,k$的常数是$1/6$，因为$i<j<k$。

然后发现大概计算次数只有$1000^3/6=166666666$,

然后又有$O2$，就可以$700ms$卡过此题。

(其实和正解的时间差的不大)


```
#include<iostream>
#include<cstring>
#include<cstdio>
#define p 998244353
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int maxn=1111;

int n,Ans,a[maxn],f[maxn][maxn];
int main(){
	scanf("%d",&n);
	rep(i,1,n)scanf("%d",&a[i]);
	rep(i,1,n-1)
	f[i][n]=1;
	dwn(j,n-1,2)
		dwn(i,j-1,1){
			f[i][j]=1;
			rep(k,j+1,n)
				if(a[k]-a[j]==a[j]-a[i])
					f[i][j]=(f[i][j]+f[j][k])%p;
		}
	Ans=n;
	rep(i,1,n-1)
		rep(j,i+1,n)
			Ans=(Ans+f[i][j])%p;
	cout<<Ans;
	return 0;
}

```

---

## 作者：Guitar_Jasmine (赞：7)

分享一种自认为比较简单的做法。

时空复杂度都是$O(n^{2})$。

设$f[i][j]$表示以第$i$个位置结尾的并且上一个位置是$j$的等差数列有多少个，这样公差可以直接算。用一个$vector$记一下每个高度分别在哪些位置出现过，然后就可以直接转移了。

因为高度是有上下限的，所以超出范围可以直接不用管它。

这种做法免去了负数下标带来的烦恼。

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

const int N=1009,M=998244353;
vector <int> v[20009];
int a[N],f[N][N],n;

void init()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]),v[a[i]].push_back(i);
}

void add(int &x,int y)
{
	x=(x+y)%M;
}

void work()
{
	int ans=0;
	for (int i=1;i<=n;i++)
	{
		add(ans,1);//长度为1的当特殊情况处理
		for (int j=1;j<i;j++)
		{
			f[i][j]=1;
			int k=a[j]-a[i]+a[j];
			if(k>=0&&k<=20000&&v[k].size())
			{
				int p=v[k].size();
				for (int l=0;l<p;l++)
					if(l<j)
						add(f[i][j],f[j][v[k][l]]);
			}
			add(ans,f[i][j]);//每次累加答案就好了，一定不重不漏
		}
	}
	printf("%d\n",ans);
}

int main()
{
	init();
	work();
	return 0;
}

```


这种做法看似三层循环，但最里面一层均摊一下还是$O(n^{2})$的 ~~，其实我也不太会算如果错了欢迎打脸~~

---

## 作者：猫粮寸断 (赞：6)

一道披着数论题外衣的DP题

我们首先可以想到一个三次方的暴力DP，用dp[i][j]表示数列最后两个位置分别是i，j时的方案数，每次去枚举dp[k][i]，判断公差是否相等进行转移

那么怎么进行优化呢？

可以看出，复杂度的主要瓶颈在于我们枚举了dp[k][i]，进行了O(n)的转移，因此我们可以对这里进行优化

出题人在这里给了提示：v<=20000，因此我们就有了这样一个思路：用v[i][j]表示在第i个位置，它上一个与它的差为j时的方案数，这样就可以O(1)转移，总复杂度是二次方

但是这个只能处理三座塔以上的情况（两座塔的情况真恶心。。。），由于任意一座或两座都肯定成立，所以我们只要在最后加上一座和两座的情况就可以了
```cpp
#include<iostream>
using namespace std;
int const M=20000;
long long dp[1010][1010],v[1010][40010],h[1010];
int main()
{
	int n,i,j;
	long long ans=0;
	cin>>n;
	for(i=1;i<=n;i++)
	 cin>>h[i];
	for(i=1;i<=n;i++)
	 {
	 	for(j=i-1;j>0;j--)
	 	 {
	 	  dp[i][j]=(dp[i][j]+v[j][h[i]-h[j]+M])%998244353;
		  v[i][h[i]-h[j]+M]=(v[i][h[i]-h[j]+M]+v[j][h[i]-h[j]+M]+1)%998244353;
	 	 }	
	 }
	for(i=1;i<=n;i++)
	  for(j=1;j<=i;j++)
	    {
	    	ans+=dp[i][j];
	    	ans%=998244353;
	 	}
	cout<<(ans+(n*n+n)/2)%998244353;
	return 0;
}
```

---

## 作者：xzyxzy (赞：5)

# 这题v在long long以内也是可以做的
这里提出一种$n^2logn$的有别于官方题解的做法

首先发现一个性质：**每个点要作为等差数列的中间部分，则公差最多只有n种**

所以我们可以对此下手

QAQ

设$t[i].g[j]$表示高度为i的塔，前面接上公差为j的等差数列有多少种方案，num记录有多少高度为i的塔

于是转移就很显然了，往后加上高度为k的塔的时候，枚举前面的塔是i，有两种方式贡献答案：

- 直接把i作为等差数列开头（$ans+=num$）
- 把i作为等差数列中间（$ans+=t[i].g[k-i]$）

同时把新增的答案更新到k的状态上去即可

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<map>
#include<algorithm>
using namespace std;
const int N=1010,mod=998244353;
struct Node{map<int,int> g;int num;}t[N];
int n,h[N],B[N],rk[N],up,ans;
map<int,int> Map;
void add(int &a,int b) {a+=b;if(a>=mod) a-=mod;}
int main()
{
    cin>>n;ans=n;
    for(int i=1;i<=n;i++) cin>>h[i],B[i]=h[i];
    sort(B+1,B+n+1);
    up=unique(B+1,B+n+1)-B-1;
    for(int i=1;i<=up;i++) Map[B[i]]=i,rk[i]=B[i];
    for(int i=1;i<=n;i++) h[i]=Map[h[i]];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=up;j++)
        {
            int d=rk[h[i]]-rk[j],res=t[j].num;
            if(t[j].g.find(d)!=t[j].g.end()) add(res,t[j].g[d]);
            if(!res) continue;
            add(ans,res);
            add(t[h[i]].g[d],res);
        }
        t[h[i]].num++;
    }
    return cout<<ans<<endl,0;
}
```
广告：https://www.cnblogs.com/xzyxzy

---

## 作者：memory_frv (赞：3)

蒟蒻我也没有想到什么好的方法，来一发vector做法，与其他人的做法可能不太一样（可能大佬会认为我的题解很劣（我也觉得），但效率其实并不是很慢，最慢点200ms左右）

首先这是一道dp题（递推？），同其他大佬的思路，我们以f[i][j]表示枚举到第i位且公差为j的方案数，我们枚举公差j，并且通过h[i]-j来进行转移，那么我们有一个大体的转移

## f[i][j]+=f[pos[h[i]-j]][j]

其中pos[i]表示值为i的元素的下标

于是乎，我们就可以引用vector来存储下标

放上代码

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
const int p=998244353;
const int add=40000;
int f[1001][80001],mmax=0,mmin=2147483647;
vector <int> pos[200001];
int h[100001];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
		pos[h[i]].push_back(i);
	}
	for(int i=1;i<=n;i++){
		for(int j=-20000;j<=20000;j++){
			f[i][j+add]=1;//初始化
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		mmax=max(mmax,h[i]);
		for(int j=-mmax;j<=h[i];j++){//枚举公差
			for(int k=0;k<pos[h[i]-j].size();k++){
				int t=pos[h[i]-j][k];//t即为元素值为h[i]-j
				if(t>=i) break;//小小优化，假如当前下标大于等于i，则后面的下标也一定大于i，因此直接退出即可
				f[i][j+add]=(f[i][j+add]+f[t][j+add])%p;
				ans+=f[t][j+add];ans%=p;
			}
		}
	}
	cout<<ans+n;//每个数单独拿出来也是一个等差数列，因此加n
	return 0;
}

```

注意，等差数列的公差不一定是个正数，因此我们的公差要从负数开始枚举，因为c++的数组下标不可以为负数，但我们又不愿用map来造成多余的时间浪费，所以我们将数组下标中的j统一加一个数，这样就可以保证数组下标为非负数


代码看起来是三重循环，但跑起来比三次方的复杂度快得多


代码还有很多可以优化的地方，但因为保险起见（懒），我就不改了

---

## 作者：Mosklia (赞：3)

一道动态规划，我的时间复杂度是$O(n^2)$，比楼上略优，但是空间复杂度为$O(nv)$。  

首先看数据范围，$n \leq 1000$，显然是$O(n^2)$。$v \leq 20,000 \; +$ 空间限制 $512 \text{MB}$ 在提醒我们可以考虑把等差数列的方差放到状态里面（不难发现无论是一维$O(n)$还是两维$O(n^2)$都难以进行状态转移）。  

接着想如何状态转移。设$f_{i,j}$表示公差为$i$，以数列第$j$位**结尾**的等差数列的数量。则状态转移如下：  
$$f_{a_{\tiny i}-a_{\tiny j}, i} = \begin{cases} \sum f_{a_i-a_j, j} + 1 & i > 1 \\ 0 & i=1\end{cases} \large , \; j \in [1, i)$$  
注：$i>1$求和时要$+1$是为了包含两个元素组成的序列。  
最后的答案就是 $\sum_{i=1}^n(1 + \sum_{j=-v}^v f_{j,i})$。  
$+1$同样是因为动态规划时没有包含单元素数列的情况。  

最后是代码实现。为了方便，我们用$v[i]$存储$\sum_{j=-v}^v f[j][i]$：  
```cpp
    for (int i = 2; i <= n; ++i)
    for (int j = 1; j <  i; ++j)
        f[a[i] - a[j]][i] += f[a[i] - a[j]][j] + 1,
        f[a[i] - a[j]][i] %= mod,
        v[i] += f[a[i] - a[j]][j] + 1,
        v[i] %= mod;
```
同样地，为了方便，$f$实际上是一个行指针，指向存储状态的数组的正中间以避免公差为负数带来的影响。  
```cpp
long long __f[40005][1005];
long long (*f)[1005] = __f + 20003;
```

---


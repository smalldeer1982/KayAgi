# 回忆京都

## 题目背景

第十五届东方人气投票 音乐部门 106名 

第四次国内不知道东方的人对东方原曲的投票调查 51名

回忆京都副歌我tm吹爆，东方文花帖我tm吹爆！

## 题目描述

射命丸文在取材中发现了一个好玩的东西，叫做组合数。

组合数的定义如下：从$n$个不同元素中，任取$m(m \leq n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合。所有组合的数量，就是组合数。

组合数的计算公式如下：$C^m_n=\dfrac{n!}{m! \times (n-m)!}$，其中保证$m \leq n$，表示在$n$个元素中选出$m$个元素的组合数。

为了方便理解，举一个例子：在th16.5秘封噩梦日记的第三周目中，每一天的战斗都有$4$个角色两两组合出场，那么很显然就有$C^2_4=6$种组合方式。

关于这方面的更详细解释，请看样例说明。

由于她对新事物都存在着好奇，因此她想要知道$C^m_n$是多少。这对她来说是个很简单的事情，因此她看了一眼就秒了，因此她决定求出下列式子：

$\sum_{i=1}^n \sum_{j=1}^m C^i_j$，其中当$i>j$的时候，钦定$C^i_j$为$0$

她也很快就算出来了，不过对自己的答案不是很充满信心，因此你决定帮助她。然而没事找事的她一下子算了$q$次对于不同的$n,m$的结果，因此这只能劳烦你了。由于你不打算真正地帮助她，你无需把答案对$998244353$取模，也无需对$64123$取模，只要告诉她对$19260817$取模之后的答案即可。

## 说明/提示

![](https://i.loli.net/2018/12/15/5c148dbe83f11.jpg)

关于组合数的样例说明。

例如有蕾米莉亚 芙兰朵露 圣白莲 丰聪耳神子在这一天组合出场，会有六种情况：

1、蕾米莉亚x芙兰朵露 $\text{\color{white}背德组}$

2、丰聪耳神子x圣白莲 $\text{\color{white}宗教组}$

3、蕾米莉亚x丰聪耳神子

4、芙兰朵露x丰聪耳神子

5、蕾米莉亚x圣白莲

6、芙兰朵露x圣白莲

## 样例 #1

### 输入

```
5
2 3
1 4
4 3
2 5
3 5```

### 输出

```
10
10
11
35
50```

# 题解

## 作者：Social_Zhao (赞：68)

## Updated at 2019/3/2/21:56，重新发表
## （实际上是发表后几小时，有一位大佬@[dou_bao](https://www.luogu.org/space/show?uid=79067)想出了递推式的推导方法（已获得他的授权））
### 看了诸位大佬的题解，蒟蒻一脸懵逼
### ~~难道我写出了本题最短代码？？？~~
### ~~毕竟是自己YY出的野递推式~~
- ### 首先来看张表：（没错这就是我用暴力打出来的表的一部分，下标从1开始）
| 1 | 1 | 1 | 1 | 1 | ······ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 3 | 4 | 4 | 4 | 4 | ······ |
| 6 | 10 | 11 | 11 | 11 | ······ |
| 10 | 20 | 25 | 26 | 26 | ······ |
| 15 | 35 | 50 | 56 | 57 | ······ |
| ······ | ······ | ······ | ······ | ······ | ······ |
- ### 请自行脑补行号、列号（逃
- ### 于是~~精通找规律的本蒟蒻~~看出一个递推公式来
- ### 再说这个公式前，先举几个栗子。
- 对于第2行2列的数：4，它其实是它左上角的数1加上它上方的数1再加上它的行号2
- 对于第2行3列的数：10，它其实是它左上角的数3加上它上方的数4再加上它的行号3
- 对于第5行5列的数：57，它其实是它左上角的数26加上它上方的数26再加上它的行号5
- 特殊情况——对于1行m列的数1，它其实是它左上角的数（初始化为0）加上它上方的数（初始化为0）再加上它的行号1
- 以及——对于n行1列的数1，它其实是它左上角的数（初始化为0）加上它上方的数（初始化为0）再加上它的行号1
- ### 我想这五个例子应该足以说明问题了吧？下面就是我的递推式：
- ## ***$ans[i][j]=ans[i-1][j-1]+ans[i-1][j]+i$***

---
### 下面是推导过程，看不懂可以自行跳过
---



### 为毛是这样的 ？

感谢@dou_bao大佬的解释。（已获得原作者授权）

我们需要三张表

1.帕斯卡三角形（即杨辉三角）（数组$f$）

| 1    |      |      |      |      |      |      |      |
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 1    | 1    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1    | 2    | 1    | 0    | 0    | 0    | 0    | 0    |
| 1    | 3    | 3    | 1    | 0    | 0    | 0    | 0    |
| 1    | 4    | 6    | 4    | 1    | 0    | 0    | 0    |
| 1    | 5    | 10   | 10   | 5    | 1    | 0    | 0    |
| 1    | 6    | 15   | 20   | 15   | 6    | 1    | 0    |

- 首先，我们需要知道$C(x,y)$等于帕斯卡三角形第$y+1$行第$x+1$个数。~~不知道的回家洗洗睡吧，我就不证明了~~

- 所以从$C(1,y)$到$C(i,y)$就是第$y+1$行第$1$到$i+1$个的数之和。

- 所以题中所求的可以表示为

```cpp
for(int i=1;i<=x;i++)
    for(int j=2;j<=y;j++)
        ans+=f[i][j];
```

- 不超时个鬼，所以要压缩

- 所以第二张表

2.帕斯卡三角形的前缀和（横着的）（不包括每行第一个数1）（数组$g$）

| 1    | 1    | 1    | 1    | 1    | 1    |
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 2    | 3    | 3    | 3    | 3    | 3    |
| 3    | 6    | 7    | 7    | 7    | 7    |
| 4    | 10   | 14   | 15   | 15   | 15   |
| 5    | 15   | 25   | 30   | 31   | 31   |
| 6    | 21   | 41   | 56   | 62   | 63   |

- 一个矩阵变成一行了。

- 因为$f[i][j]=f[i-1][j]+f[i-1][j-1];$

- 所以$g[i][j]$就等于$g[i-1][j]+g[i-1][j-1]+1$(把$g[i][j]=sum(f[1]$ to $f[i])$展开就可以得到，实在无法理解可以在表中找规律)

- 俗话说的好，做事要干净，**不给别人留后路**。

- 所以第三张表

3.帕斯卡三角形横着的前缀和的前缀和（竖着的）（数组$ans$）

| 1    | 1    | 1    | 1    | 1    | 1    |
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 3    | 4    | 4    | 4    | 4    | 4    |
| 6    | 10   | 11   | 11   | 11   | 11   |
| 10   | 20   | 25   | 26   | 26   | 26   |
| 15   | 35   | 50   | 56   | 57   | 57   |
| 21   | 56   | 91   | 112  | 119  | 120  |

- 是不是和第一张表一模一样？
- 那么很明显 $ans[i][j]=ans[i-1][j]+g[i][j]$
- 又因为之前的$g[i][j]=g[i-1][j]+g[i-1][j-1]+1$
- 所以$ans[i][j]=ans[i-1]+g[i-1][j]+g[i-1][j-1]+1$
- 再不断地拆$g[i-1][j]$
- 就得到了$ans[i][j]=ans[i-1][j]+g[0$ to $i-1][j-1]+i$
- 然后又因为h的定义，所以$ans[i][j]=g[0$ to $i][j]$
- 那么可以变形为：
- ### $ans[i][j]=ans[i-1][j]+ans[i-1][j-1]+i$
- 就是这样
- 题解写的丑，dalao勿喷。

---

证毕。

---


### 于是......这就是我的~~只有15行的~~代码了（未压行）：
```cpp
#include<iostream>
using namespace std;
int ans[1005][1005],q,n,m;
int main() {
	for(int i=1;i<=1000;i++)
	for(int j=1;j<=1000;j++) {
		ans[i][j]=(ans[i-1][j-1]+ans[i-1][j]+i)%19260817;
	}
	cin>>q;
	while(q--) {
		cin>>n>>m;
		cout<<ans[m][n]<<endl;
	}
	return 0;
}
```

---

## 作者：xcxc82 (赞：4)

# P5239 回忆京都题解


## [传送门](https://www.luogu.com.cn/problem/P5239)


前排声明:题解写的比较累赘...把一些基本的恒等式都讲了一遍...(部分证明借鉴了《具体数学》一书)

如果您已经掌握了这些基础的话建议还是去看其他dalao们的题解吧qwq...



## 1.基本恒等式

我们把$\dbinom{n}{k}$符号读作"**n选取k**"

即**从n个元素的集合中选取k个元素**作为子集的方案总数

对于该集合的第一个元素的可能,有n种选择

对第二个元素,有n-1种选择,3,4,5.....也同理

同时,**对于每k个元素组成的子集都恰好有$k!$种不同的排序**

根据乘法原理

得到公式

$\dbinom{n}{k}={\dfrac{n*(n-1)...*(n-k+1)}{k!}}$ 

(**基本恒等式**)


------------


## 2.对称恒等式

先来看个图


![](https://cdn.luogu.com.cn/upload/image_hosting/a9xmsi5c.png)

观察一下不难发现规律

$\dbinom{n}{k}=\dbinom{n}{n-k}$

(**对称恒等式**)

至于正确性也显而易见

**从n个物品中选k个物品就相当于指定的n-k种物品不被选取**


------------


## 3.吸收恒等式

我们知道,二项式系数的基本恒等式为

$\dbinom{n}{k}={\dfrac{n*(n-1)...*(n-k+1)}{k!}}$ 

可以将式子转化为

$\dbinom{n}{k}={\dfrac{n}{k}*\dfrac{(n-1)...*(n-k+1)}{(k-1)!}}$ 


得到式子$\dbinom{n}{k}=\dfrac{n}{k}\dbinom{n-1}{k-1}$



两边同乘k,得$k\dbinom{n}{k}=n\dbinom{n-1}{k-1}$**恒等式1**



根据这个式子,再利用之前的恒等式1

还可以得到式子

$(n-k)\dbinom{n}{k}=(n-k)\dbinom{n}{n-k}$(根据对称性)

$=n\dbinom{n-1}{n-1-k}$(根据恒等式1)

$=n\dbinom{n-1}{k}$---(根据对称性)**恒等式2** 





------------
## 4.加法公式

观察一下前面的那张表,不难发现一个规律:


$\dbinom{n}{k}=\dbinom{n-1}{k-1}+\dbinom{n-1}{k}$

推导的话也很简单


根据之前吸收恒等式里的恒等式1和恒等式2

得出

$\dbinom{n}{k}=(n-k)\dbinom{n}{k}+k\dbinom{n}{k}=n\dbinom{n-1}{k}+n\dbinom{n-1}{k-1}$


------------

## 5.题目

### 大致题意:

q次询问,每次都给一个m跟n,求

$\sum\limits_{i=1}^n\sum\limits_{j=1}^mC^i_j$


------------

根据前面的加法公式,很容易可以解出这题

一共有n次询问，如果一次一次的去加的话肯定会超时

可以考虑使用二维前缀和来优化

至于二维前缀和怎么用,前面的dalao们已经写的很清楚了,为了~~让题解看起来不是那么的水~~,彩笔这里就再粗糙的写一遍吧


![](https://cdn.luogu.com.cn/upload/image_hosting/ez5vvkji.png)

从图中不难看出,对于每一个sum[i][j],都有

sum[i][j]=sum[i][j-1]+sum[i-1][j]+a[i][j]-sum[i-1][j-1]

因为这里面有一个对$1926081719260817$取模操作

相减可能会产生负数

比如说我们取模后$sum[i][j-1]+sum[i-1][j]+a[i][j]=1$

而$sum[i-1][j-1]=1926081719260816$

很明显,相减为负

至于如何避免其实也很简单,只要再加上一个模数就可以了,相当于是加上之前那个被模掉的部分



------------
贴上丑陋的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long mo=19260817;
int n,a[1005][1005];
int sum[1005][1005];
int main(){
      a[0][0]=1;	
	for(int i=1;i<=1002;i++){
		for(int j=1;j<=1002;j++){
			a[i][0]=a[i][i]=1;
			a[i][j]=(a[i-1][j]+a[i-1][j-1])%mo;
		}
	}
	for (int i=1;i<=1002;i++)
		for (int j=1;j<=1002;j++){
		sum[i][j]=(sum[i-1][j]+sum[i][j-1]+a[i][j]-sum[i-1][j-1]+mo)%mo;	
		}
			cin>>n;
	for(int i=1;i<=n;i++){
		int l,r;
		cin>>l>>r;
		cout<<sum[r][l]<<endl;
	}
	return 0;
}
```
如有错误还请大佬们指出

~~话说没人会来看我这个菜比的题解吧qwq...~~




---

## 作者：YLWang (赞：4)

数学入门好题。适合pj组的童鞋们思考一下。

分Subtask进行讲解：


## Subtask 1

$q = 0$

真友爱。

啥都不输出就行了


## Subtask2
$q, m, n \leq 10$

则根据组合数公式，暴力计算就可以了。

连longlong都不用开。

代码就不附带了。

## Subtask3
$q \leq 10, m, n \leqslant 10000$

如果暴力计算，对于pj组的同学们，不用逆元，不写高精，无法进行计算。

故需要引入杨辉三角。

杨辉三角形状如下：


1 (f[0][0])

1 1

1 2 1

1 3 3 1

1 4 6 4 1

递推式：$f[i][j] = f[i-1][j] + f[i-1][j-1]$

非常容易进行比对：$f[i][j] = C(i, j)$

发现要求的范围即为杨辉三角中左上角为(0, 0), 右下角为(n, m) 的数的总和

暴力求和即可

时间复杂度O(nmq)

代码：

```
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(int i = (k); i <= (j); i++)
using namespace std;
inline int read()
{
    int num = 0, flag = 1;
    char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num * flag;
}
#define MOD 19260817
#define MAXN 1005
int c[MAXN][MAXN];
signed main()
{
    c[0][0] = 1;
    For(i, 1, 1000) {
        For(j, 0, i) {
            if(j == 0) c[i][j] = 1;
            else {
                c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD;
            }
        }
    }
    int Qnum = read();
    while(Qnum--) {
    	int ans = 0;
    	int n = read(), m = read();
    	For(j, 1, m) {
    		For(i, 1, n) {
    			ans += c[j][i];
    			ans %= MOD;
            } 
        }
        printf("%d\n", ans); 
    }
    return 0;
}

```
## Subtask4
发现只要在SubTask3 的基础上增加一个对于每一行的前缀和优化即可

时间复杂度：O(mk)

```
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(int i = (k); i <= (j); i++)
using namespace std;
inline int read()
{
    int num = 0, flag = 1;
    char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num * flag;
}
#define MOD 19260817
#define MAXN 1005
int c[MAXN][MAXN];
int sum[MAXN][MAXN];
signed main()
{
    c[0][0] = 1;
    For(i, 1, 1000) {
        For(j, 0, i) {
            if(j == 0) c[i][j] = 1;
            else {
                c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD;
            }
        }
    }
    For(i, 0, 1000) {
        For(j, 0, 1000) {
            if(j == 0) sum[i][j] = 1;
            else sum[i][j] = (sum[i][j-1] + c[i][j]) % MOD;
        }
    }
    int Qnum = read();
    while(Qnum--) {
    	int ans = 0;
    	int n = read(), m = read();
    	For(j, 1, m) {
    		ans = (ans + sum[j][n]-1) % MOD;;
        }
        printf("%d\n", ans); 
    }
    return 0;
}
```
撒花

---

## 作者：NotEvenANeko (赞：3)

递归算组合数加上二维数组的前缀和就可以解这道题了

~~蒟蒻唯一AC的题~~

要边算边取模，不然好像说会WA……

代码

```cpp
#include<bits/stdc++.h>
#define ll long long

using std::cin;
using std::cout;
using std::endl;

const int Violence=19260817;

ll C[1005][1005];

ll calc(int n,int m)	//递归计算组合数，注意边界
{
    if(m==0)
        return 1;
    if(m==n)
        return 1;
    if(m==0&&n==0)
        return 1;
    if(C[m][n]!=-1)
        return C[m][n];
    return (calc(n-1,m-1)+calc(n-1,m))%Violence;
}

int main()
{
    memset(C,-1,sizeof(C));
    std::ios::sync_with_stdio(0);
    int q;
    cin>>q;
    for(int i=0;i<=1000;i++)	//组合数计算
        for(int j=0;j<=1000;j++)
        {
            if(i==0||j==0)
                C[i][j]=0;
            if(i>j)
                C[i][j]=0;
            else if(C[i][j]==-1)
                C[i][j]=calc(j,i);
        }
    for(int i=1;i<=1000;i++)	//前缀和预处理
        for(int j=1;j<=1000;j++)
        {
            C[i][j]+=C[i][j-1];
            C[i][j]%=Violence;
        }
    for(int j=1;j<=1000;j++)
        for(int i=1;i<=1000;i++)
        {
            C[i][j]+=C[i-1][j];
            C[i][j]%=Violence;
        }
    while(q--)	//直接输出
    {
        int m,n;
        cin>>n>>m;
        cout<<C[n][m]<<endl;
    }
    system("pause");//上交oj时记得注释或删除
    return 0;
}
```


---

## 作者：于丰林 (赞：3)

洛谷月赛的一道水题。。。

似乎要比第一题还要简单一点？

https://www.luogu.org/problemnew/show/P5239

好吧，直接切入正题。。。

关于这道题，简单来说就是求一个式子：

∑i=1n​∑j=1m​Cji​（i>j时Cji为0）

那么最简单的方法就应该是先预处理出阶乘和组合数，利用二维数组储存，暴力枚举i，j，利用费马小定理求逆元直接代式子来进行求和就可以了。

写完就是这个效果：

![](https://img2018.cnblogs.com/blog/1538839/201903/1538839-20190302213504436-1948994088.png)

可以看到，我们TLE了三个点，那么我们该如何解决呢？

考虑我们的程序，费马小定理基本已经最优了（经过我的测试扩展gcd好像更慢？？？），预处理也大大优化了大数据的运行速度，那么只有求和看上去并不是那么优美，于是我们考虑从求和上下手。

首先，我们知道我们求的是从1-m，1-n的组合数之和，那么我们是不是就是求记录组合数的数组中一个(n,m)大小的矩阵？

那么二维前缀和就是很显然的一件事了吧。。。

最后不要忘记了m和n的顺序，一般人的习惯可能会导致出错，我就调了好久啊。。。

还有记得二维前缀和有可能减出负数，所以记得先加后取模（常规错误）

按照这个优化写完就成了这样：（比赛时写的扩展gcd。。。）

![](https://img2018.cnblogs.com/blog/1538839/201903/1538839-20190302214600628-846916271.png)

但是赛后用费马小定理写了一下：（震惊了。。。快了这么多。。。）

![](https://img2018.cnblogs.com/blog/1538839/201903/1538839-20190302214722303-333912112.png)

后话，其实如果不带式子利用递推会更快一些，但是直接代式子也能过所以在这里就不啰嗦了。。。

最后，附上本题代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define LL long long
#define mod 19260817
using namespace std;
LL js[1005],f[1005][1005],sum[1005][1005];
inline LL qpow(LL x,LL y)
{
    LL ans=1;
    while(y!=0)
    {
        if(y&1)
        {
            ans=ans%mod*(x%mod)%mod;
        }
        x=x%mod*(x%mod)%mod;
        y>>=1;
    }
    return ans;
}
inline LL inv(LL w)
{
    return qpow(w,mod-2); 
}
inline void pre_fir()
{
    js[0]=1;
    js[1]=1;
    for(register int i=1; i<=1000; i++)
    {
        js[i]=js[i-1]%mod*i%mod;
        js[i]%=mod;
    }
    for(register int i=1; i<=1000; i++)
    {
        for(register int j=1; j<=i; j++)
        {
            f[i][j]=js[i]%mod*inv(js[j]%mod*js[i-j]%mod)%mod;
        }
    }
    for(register int i=1; i<=1000; i++)
    {
        for(register int j=1; j<=1000; j++)
        {
            sum[i][j]=(((sum[i-1][j]-sum[i-1][j-1]+mod)%mod+sum[i][j-1])%mod+f[i][j])%mod;
        }
    }
}
int main()
{
    LL q,n,m;
    cin>>q;
    pre_fir();
    for(register int i=1; i<=q; i++)
    {
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",sum[m][n]%mod);
    }
    return 0;
}
```


---

## 作者：Guess00 (赞：2)

## 本题思路:二维前缀和

### $\text{分析:}\sum^{n}_{i=1}\sum^{m}_{j=1}C^i_j$=
![](https://i.loli.net/2019/03/02/5c7a6a272b561.png)

### 这样就可以将问题转换成「二维前缀和」了:
![](https://i.loli.net/2019/03/02/5c7a790b5ba1e.png)

### 代码
```cpp
#include <bits/stdc++.h>
#define int long long 
#define MOD 19260817
using namespace std;
int q,n,m,i,j,a[1005][1005]/*杨辉三角形*/,s[1005][1005]/*二维前缀和*/;
inline void read(int &x) //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
		if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)  //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main()
{
	/*杨辉三角形初始化*/ 
	for (i=0;i<1005;i++)
    	a[i][0]=a[i][i]=1;
    for (i=2;i<1005;i++)
    	for(j=1;j<=i;j++)
    		a[i][j]=(a[i-1][j-1]+a[i-1][j])%MOD;
    /*预处理二维前缀和*/ 
    for (j=1;j<1005;j++)   //注意:从列来算二维前缀和 
    {
    	int t=0;
    	for (i=1;i<1005;i++)
			s[i][j]=(a[i][j]/*该点元素大小*/+s[i][j-1]/*前一个和*/+t/*该列上面的和*/)%MOD,\
			(t+=a[i][j])%MOD/*更新该列从上往下的和*/;
	}
	/*读入测试点,直接输出*/
	read(q);
	while (q--)
	{
		read(n),read(m);
		print(s[m][n]),putchar('\n');
	}
	return 0;
} 
} 
```

---

## 作者：Catalan1906 (赞：2)

和 NOIP2016TG 组合数问题 差不多是一样的……

首先要知道杨辉三角和组合数之间的关系

看一下数据范围，很明显要避免重复计算，而且查询的复杂度要非常小

一看n, m <= 1000

这明显是一个前缀和……够开二维数组

然而计算前缀和的时候**会出现负数**（窝70分就是栽在这的qaq比赛过后才查出来），解决方法(()%mod+mod)%mod

单点查询O(1)，预处理O(nm)，能过

```
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <cstdio>

const int mod = 19260817;

int C[1010][1010], sum[1010][1010];

int main() {
    for(int i = 0; i <= 1000; i++) {
        C[i][0] = C[i][i] = 1;
        for(int j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
    for(int i = 1; i <= 1000; i++) {
        for(int j = 1; j <= 1000; j++) {
            sum[i][j] = ((sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + C[i][j]) % mod + mod) % mod;
        }
    }
    int q;
    scanf("%d", &q);
    int n, m;
    while(q--) {
        scanf("%d%d", &n, &m);
        if(n <= 0 || m <= 0) {
            puts("0");
            continue;
        }
        printf("%d\n", sum[m][n]);
    }
    return 0;
}
```

---

## 作者：yzxoi (赞：1)

## 欢迎到[Blog](https://yzx233.xyz/archives/550)食用
## 题意
~~题目背景讲太多了吧。。。一句话题意：~~

有$Q$个询问，每个询问求出：

$$\sum_{i=1}^n\sum_{j=1}^m C_j^i$$

对于$60$%的数据，$q \leq 10, n\leq100,m\leq100$。

对于$100$%的数据，$q \leq 1000,n\leq1000,m\leq1000$。
## 思路
### 对于60%的数据
直接暴力就好了。

预计得分：60分。

实际得分：70分。

O(∩_∩)O~~数据好水~~

直接用递归的方式记忆化求组合数。竟然可以拿70。

代码：
```C++
#include<bits/stdc++.h>
#define mod 19260817
#define int long long
using namespace std;
inline int read(){
    char ch=getchar();int res=0,f=1;
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
    return res*f;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x<10) putchar(x+'0');
    else{
        write(x/10);
        putchar(x%10+'0');
    }
}
int a[2010][2010];
int C(int n,int m){//递归求组合数
    if(a[n][m]!=0){
        return a[n][m];
    }
    if(n<m){
        return 0;
    }
    if(n==m||m==0){
        return a[n][m]=1;
    }
    if(m==1){
    	a[n][m]=n%mod;
        return n%mod;
    }else{
    	a[n][m]=C(n-1,m-1)%mod+C(n-1,m)%mod;//C(n,m)=C(n-1,m)+C(n-1,m-1)
    	a[n][m]%=mod;
        return a[n][m];
    }
}
int q,n,m,ans;
signed main(){
    q=read();
    while(q--){
        n=read();m=read();ans=0;//ANS清零
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                ans+=C(i,j);
                ans%=mod;
            }
        }
        write(ans);putchar('\n');
    }
    return 0;
}
```
### 对于100%的数据
这里就有两种解法了：

#### 1.利用前缀和
因为有许多题解都详细讲了，比如chen_zhe的题解，所以这里就不提了。

#### 2.利用组合数的性质
这里先摆一条组合数的性质：$C(0,n)+C(1,n)+C(2,n)+...+C(n,n)=2^n$

这怎么证明呢？

根据二项式定理，可得：
$$(1+x)^n=C(0,n)+C(1,n)\times x +C(2,n)\times x^2+ ... +C(n,n) \times x^n $$

令$x=1$，可得：

$$2^n=C(0,n)+C(1,n)+C(2,n)+(3,n)+...+C(n,n)$$

证毕。

什么？你不会二项式定理？[百度百科](https://baike.baidu.com/item/二项式定理/7134359?fr=aladdin)

好了，再回归题目：

$$\sum_{i=1}^n\sum_{j=1}^m C_j^i$$

$$\sum_{i=1}^n\sum_{j=1}^m C_j^i=\sum_{i=1}^m\sum_{j=1}^m C_j^i-\sum_{i=n+1}^m \sum_{j=1}^m C_j^i$$

于是求解这道题就变成了求解两个子问题：
##### 1.求解$\sum_{i=1}^m\sum_{j=1}^m C_j^i$

根据上面的组合数的性质：$C(0,n)+C(1,n)+C(2,n)+...+C(n,n)=2^n$

我们可以得出：

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=\sum_{i=1}^m [C(1,m)+C(2,m)+...+C(m,m)]$$

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=\sum_{i=1}^m [C(0,m)+C(1,m)+C(2,m)+...+C(m,m)-C(0,m)]$$

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=\sum_{i=1}^m [2^m-C(0,m)]$$

那么$C(0,m)=?$
答案是1。

所以
$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=\sum_{i=1}^m [2^m-1]$$

然后再把最外层的化开：

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=[2^1-1]+[2^2-1]+...+[2^m-1]$$

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=2^1+2^2+...+2^m-1 \times m$$

根据：$2^0+2^1+2^2+...+2^n=2^{n+1}-1$

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=2^{m+1}-1-2^0-1 \times m$$

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=2^{m+1}-2-1 \times m$$

$$\sum_{i=1}^m\sum_{j=1}^m C_j^i=2^{m+1}-2-m$$

##### 2.求解$\sum_{i=n+1}^m \sum_{j=1}^m C_j^i$

$$\sum_{i=n+1}^m \sum_{j=1}^m C_j^i=\sum_{i=n+1}^m \sum_{j=1}^i C_j^i+\sum_{i=n+1}^m \sum_{j=i+1}^m C_j^i$$

又因为题目：其中当$i>j$的时候，钦定$C^i_j=0$

并且：$C(n,n)=1$

所以：
$$\sum_{i=n+1}^m \sum_{j=1}^m C_j^i=\sum_{i=n+1}^m (1+\sum_{j=i+1}^m C_j^i)$$

于是对于每一个询问，只需要求出$\sum_{i=n+1}^m \sum_{j=i+1}^m C_j^i$即可。

##### 汇总
好了，两个子问题都结束了。
那么对于每个询问：
$$\sum_{i=1}^n\sum_{j=1}^m C_j^i=2^{m+1}-2-m-\sum_{i=n+1}^m {(1+\sum_{j=i+1}^m C_j^i)}$$
#### Code
```C++
#include<bits/stdc++.h>
#define mod 19260817
#define int long long
using namespace std;
inline int read(){//读入优化
    char ch=getchar();int res=0,f=1;
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
    return res*f;
}
inline void write(int x){//输出优化
    if(x<0) putchar('-'),x=-x;
    if(x<10) putchar(x+'0');
    else{
        write(x/10);
        putchar(x%10+'0');
    }
}
int a[2010][2010],pw[1010];//分别记录组合数、2的次幂
int C(int n,int m){//递归记忆化求组合数
    if(a[n][m]!=0){
        return a[n][m];
    }
    if(n<m){
        return 0;
    }
    if(n==m||m==0){
        return a[n][m]=1;
    }
    if(m==1){
    	a[n][m]=n%mod;
        return n%mod;
    }else{
    	a[n][m]=C(n-1,m-1)%mod+C(n-1,m)%mod;
    	a[n][m]%=mod;
        return a[n][m];
    }
}
int q,n,m,ans;
signed main(){
    q=read();pw[0]=1;
    for(int i=1;i<=1005;i++){//预处理2^k
    	pw[i]=pw[i-1]*2;pw[i]%=mod;
    }
    while(q--){
        n=read();m=read();
        ans=pw[m+1];ans-=2;ans-=m;ans+=mod;ans%=mod;//子问题1
        for(int j=n+1;j<=m;j++){//子问题2
            ans--;
            for(int i=j+1;i<=m;i++) ans-=C(i,j),ans+=mod,ans%=mod;
        }
        write(ans);putchar('\n');
    }
    return 0;
}
```

---

## 作者：xht (赞：1)

杨辉三角即组合数的“打表”形式

再求一个二维前缀和

然后处理一下负数即可（因为在求前缀和的过程中有减法）

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e3 + 6, P = 19260817;
int t;
ll f[N][N], s[N][N];

int main() {
	//杨辉三角
	for (int i = 0; i < N; i++) f[i][i] = 1;
	for (int i = 0; i < N; i++) f[i][0] = 1;
	for (int i = 2; i < N; i++)
		for (int j = 1; j < i; j++)
			f[i][j] = (f[i-1][j-1] + f[i-1][j]) % P;
	//二维前缀和 
	for (int i = 1; i < N; i++)
		for (int j = 1; j < N; j++)
			s[i][j] = (s[i-1][j] + s[i][j-1] - s[i-1][j-1] + f[i][j]) % P;
	
	cin >> t;
	while (t--) {
		int n, m;
		cin >> n >> m;
		cout << (s[m][n] + P) % P << endl;//注意可能为负数，处理一下即可（不处理貌似只有70） 
	}
	return 0;
}
```

---

## 作者：1saunoya (赞：1)

[更好的阅读体验戳这里](https://www.cnblogs.com/qf-breeze/p/10462552.html)
![](https://img2018.cnblogs.com/blog/1596670/201903/1596670-20190302193231734-783180880.png)

>T2？（看似比T1简单些）

>二维前缀和嘛？【多简单 我天天拿二维前缀和水DP】

![](https://img2018.cnblogs.com/blog/1596670/201903/1596670-20190302193408714-610119177.png)

>这是前缀和的预处理 2333 处理出来所有的情况 某个地方要加上mod再%mod

>如果没有这一步 那么 70pts 然后附带5%的分值飞走。2333

>然后...就A掉了



```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
inline LL read () {
    LL res = 0 ;
    int f (1) ;
    char ch = getchar ();
    while (!isdigit(ch)) {
        if (ch == '-') f = -1 ;
        ch = getchar();
    }
    while (isdigit(ch)) res = (res << 1) + (res << 3) + (ch ^ 48),ch = getchar();
    return res * f ;
}
const LL Mod=19260817LL;
const LL N=1<<10;
LL q; LL yh[N][N],qzh[N][N];
inline void f() {
    yh[0][0]=1;
    for(register int i=1; i<=1000; i++)
        for(register int j=0; j<=i; j++) yh[i][j]=(yh[i-1][j]+yh[i-1][j-1])%Mod;
    for(register int i=1; i<=1000; i++)
        for(register int j=1; j<=1000; j++) qzh[i][j]=(qzh[i-1][j]+qzh[i][j-1]-qzh[i-1][j-1]+yh[i][j]+Mod)%Mod;
}
signed main() {
    f(); q=read();
    while(q--) {
        LL n=read(),m=read();
        cout << qzh [m] [n] << endl ;
    }
    return 0;
}
```


---

## 作者：Hiraeth (赞：0)

组合数的二维前缀和的取模运算.

几个注意点：

1.如果减去一个数据再进行取模运算，比如这里的二维前缀和在计算的时候减法，那么就可能出现负数，从而导致取模运算错误，所以需要加上一个被模数.

2.数组的大小开的是$1005$ 但是实际下标是$0-1004$ 也就是说如果递推的时候递推到$1005$ 会导致数组越界 需要注意 所以数组多开十个 多用五个

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int q,m,n,c[1010][1010],sum[1010][1010];
int main(){
	c[1][0]=1;c[1][1]=1;
	for (int i=2;i<=1005;i++){
		c[i][0]=1;
		for (int j=1;j<=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%19260817;
	} 
	for (int i=1;i<=1005;i++)
		for (int j=1;j<=1005;j++){
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+c[i][j]+19260817; 
			sum[i][j]%=19260817;
		}
	scanf("%d",&q);
	for (int i=1;i<=q;i++){
		scanf("%d%d",&n,&m);
		printf("%d\n",sum[m][n]);
	}
	return 0;
} 
```


---

## 作者：Jelly_Goat (赞：0)

你们这些写题解的，就不能~~把话说清楚~~嘛！（吐槽1）  
你们这些出题的，就不能~~多出点东方~~嘛！（吐槽2）  
你们这些做题的，就不来写一篇详细一点的题解嘛！（吐槽3）  
**以上均是个人吐槽，纯属吐槽，不带任何针对性和感情色彩。**

------

### 声明：
**本题解适宜蒟蒻（比如我等）观看，若卡关，可以来此题解领提示。**  
小金羊写的题解致力于让刚刚学习二维数组的同学都能明白！！  
~~把我顶上去让像我一样的juruo明白一下~~

--------

回到正题。  
首先还是看看这个题咋推出来的和**杨辉三角&二位前缀和**有关系？  
我自己用python 3先手推了一下组合数，  
先上python 3推组合数的代码:
```python
import os
def jc(num):
  if num is 0 or num is 1:
   return 1
  else :
  return num*jc(num-1)
#阶乘递归版，适用于自己造的小型数据
#不是机惨w......
def zhs(i,j):
  if i > j :
    return 0
  else :
    return jc(j)/(jc(i)*jc(j-i))
#组合数配合阶乘递归，适用于小型数据推算

n=int(input())
while n is not 0:
  n-=1
  L=list(input().split())
  print(zhs(int(L[0]),int(L[1])))
  os.system("pause")
'''
print("Exit?",end=' ')
if input() is 'Yes':exit(1)
else :exit(1)
'''
```
一个个试一下，然后就发现这样一个鬼畜事件：  
![](https://cdn.luogu.com.cn/upload/pic/53080.png)  
打眼一看：好像跟杨辉三角有那么点联系......
### 哦！缺了第一列的杨辉三角！
然后杨辉三角创造方法:$O(1000^2\div 2)$递推打表!  
公式：
$$
yh[i][j]=yh[i-1][j-1]+yh[i-1][j]
$$
别忘了取模(~~废话~~)

------

等等......  
### 这个和此题有什么联系吗？  
这个题让求组合数的和。  
求和，先把区间用yellow色画出来。  
然后发现......  
(下图中填充黄色的是求和区域，紫色是和)   
![](https://s2.ax1x.com/2019/03/02/kqtnW8.png)   
![](https://s2.ax1x.com/2019/03/02/kqtMQg.png)  
### 你发现了吗？这是一个二重的杨辉三角！  
其实就是一个二维的前缀和预处理工作。  
没有事情干的同学，树状数组&线段树都可解决这个问题。
### 根本就是两次递推打表!  
然后这个题第一次我竟然只有10分......

-------

但是要追求一个最优的方法。  
这个时候我们要改一下原先的变量定义，是关于`ans[i][j]`方面:  
设`ans[i][j]`表示的是前`i`列前`j`行的前缀和。  
### 推出这个题前缀和公式的过程：  
杨辉三角到底有什么好处？  
其实杨辉三角给你预处理了单列上的前缀和。   
#### 然后单列上前缀和用汉语表示就是：  
杨辉三角形第`i`列上前`j`行の前缀和就是杨辉三角形第`i+1`行第`j+1`列上的数据。  
数学公式？（第一个中括号内暂定是1）  
$$
ans[1][j]=yh[1+1][j+1]
$$
#### 根据以上推论，得出很多列的（就是二维的）前缀和推论。  
汉语表达：  
前`i+1`列前`j+1`行的前缀和就等于前`i+1`列前`j`行的前缀和加上前`i+1`列第`j+1`行的前缀和（即杨辉三角形第`i+2`行第`j+2`列那一项）。  
公式？  
$$
ans[i][j]=ans[i][j-1]+yh[i+1][j+1]
$$
这样避免了许多~~不必要的记公式过程~~......
#### Upd4 2019/3/6:
有同学问，为啥是给你预处理了单列上的前缀和？  
我们根据$yh[i][j]=yh[i-1][j-1]+yh[i-1][j]$，  
那么又$\because yh[i-1][j]=yh[i-2][j-1]+yh[i-1][j]$......  
以此类推，得到`yh[i+1][j+1]`，相当于我们得到了杨辉三角第`j`列的前`i`个数的和+$yh[1][j]$。  
且根据我们杨辉三角靠左排列放置的方式，$yh[1][j](j>0)$必定为0。（观察可知$yh[0][0]$的右侧即$yh[0][1]=0$，而右侧$yh[0][1]$和右侧数据都是0）  
于是我们得出递推公式，`ans[i][j]=ans[i][j-1]+yh[i+1][j+1]`。  

到这里，我们找到了一个非常完美的没有过多数据+-的操作。  
（~~qwq~~比cz dalao的算法的常数小）  
### 坑点：
1.你以为取了mod就不会爆负数吗？太天真啦！  
$\therefore ans=(ans+mod)$%$mod$  
2.你以为我会$O(2\cdot 1000^2)$做吗？太天真啦！  
复杂度$O(1000^2\div 2+1000^2+query)$

------

#### Upd1 2019/3/3:
**关于代码和蒟蒻的二维前缀和求法补充完善**  
代码来辣！  
求前缀和还是预处理吧......线段树什么的玩不来......  
**注意下面代码，求前缀和的时候意义和求杨辉三角的时候有所不同。**   
（原因见上面）
```cpp
#include <iostream>
#include <cstdio>
#include <map>

using namespace std;
typedef long long int lli;
const int maxn=1008;
const lli mod=19260817;
lli yh[maxn+1][maxn+1],ans[maxn+1][maxn+1];
int n,m,q;

void Init()
{
    for (register int i=0;i<=1004;i++)
    {
        yh[i][i]=1;
    }
    for (register int i=0;i<=1004;i++)
    {
        yh[i][0]=1;
    }
    for (register int i=2;i<=1004;i++)
    {
        for (register int j=1;j<=i;j++)
        {
            yh[i][j]=(yh[i-1][j-1]+yh[i-1][j]+mod)%mod;
        }
    }
    //杨辉三角形的生成方式 
    for (register int i=1;i<=1004;i++)
    {//前i列 
        for (register int j=1;j<=1004;j++)
        {//前j行 
            ans[i][j]=(ans[i][j-1]+yh[i+1][j+1]+mod)%mod;
        }
    }
    //二维前缀和的生成方式 
}
int main()
{
    Init();
    scanf("%d",&q);
    while (q--)
    {
        scanf("%d%d",&n,&m);
        printf("%lld\n",ans[m][n]);
        //注意ans[][]的定义！！ 
    }
    return 0;
}
```
#### Upd2 2019/3/3:
重新更正代码，实际`4-WA`，现在AC。  
原因在于这个算法的局限性：  
实际上需要推到1000+，时间复杂度上虽然小了，但是容易边界数据卡没了......  
实际上我就是这样`4-WA：read 0`的......  
最后推bo：[`Jelly`](https://www.luogu.org/blog/jelly123/)_[`Goat`](https://www.cnblogs.com/jelly123/p/10484794.html)

---

## 作者：ustze (赞：0)

一个并不需要二位前缀和的O(N)空间的做法。。  
如果$n>=m$ 那么原式就相当于求
$$C_1^1+C_2^1+C_2^2+.....+C_m^1+C_m^2+...+C_m^m$$
这个显然可以$O(1)$求，但是我的代码里写的是$O(n)$的做法  
（由于组合恒等式 $C_i^1+C_i^2+...+C_i^i=2^i-1 $)  
当$n<m$时，考虑1~n的部分，则求法如上  
而n+1~m的部分呢，我们把式子列一下，发现是如下形式：
$C_{n+1}^1+C_{n+1}^2....+C_{n+1}^n+$  
$C_{n+2}^1+C_{n+2}^2....+C_{n+2}^n+$  
.......  
$C_{m}^1\ \ \ +C_{m}^2\ \ \ ....+C_{m}^n$ 
纵向求和一下，由于公式$C_i^i+C_{i+1}^i+...+C_n^i=C_{n+1}^{i+1}$  
发现第$i$列的答案即为 $C_{m+1}^{i+1}-C_{n+1}^{i+1}$，同样可以$O(n)$的求  
这样做的话单次查询复杂度即为$O(n)$，也有通过$O(n^2)$预处理$O(1)$回答的方法  
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=19260817;
const int N=1005;
inline int read(){
    int s=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) s=s*10+ch-'0',ch=getchar();
    return s;
}
int q,n,m;
ll fac[N],inv[N];
inline ll qpow(ll a,ll b){
    ll ans=1;
    for(;b;b>>=1,a=a*a%mod) if(b&1) ans=ans*a%mod;
    return ans;
}
void init(){
    fac[0]=inv[0]=1;
    for(int i=1;i<N;i++) {
        fac[i]=fac[i-1]*i%mod;
        inv[i]=qpow(fac[i],mod-2);
    }
}
inline ll C(int n,int m){
    return ((fac[n]*inv[m])%mod)*inv[n-m]%mod;
}
int main(){
    init();
    q=read();
    ll ans;
    while(q--){
        n=read(),m=read();
        ans=0;
        if(n>=m) {
            ll t=1;
            for(int i=1;i<=m;i++){
                t=t*2%mod;
                ans=(ans+t-1)%mod;
            }
            printf("%lld\n",(ans+mod)%mod);
        }else {
        	ll t=1;
            for(int i=1;i<=n;i++){
                t=t*2%mod;
                ans=(ans+t-1)%mod;
            }
            ans=(ans+mod)%mod;
            for(int i=1;i<=n;i++){
            	ans=((ans+C(m+1,i+1)-C(n+1,i+1))%mod+mod)%mod;
            }
            printf("%lld\n",(ans+mod)%mod);
        }
    }
    return 0;
}
```

---

## 作者：FlyInTheSky (赞：0)

考虑$O(nm)$预处理出所有$C(n,m)$。

然后求一个二维前缀和，询问直接输出前缀和的值即可。

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<string>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

    const LL MAXN = 1005, MO = 19260817;
    
    LL C[MAXN][MAXN], Q;

    void clean() {
    	ms(C, 0);
    }
    int solve() {

    	clean();
    	
    	for (LL i = 0; i <= 1000; ++i) C[i][i] = C[i][0] = 1;
    	for (LL i = 2; i <= 1000; ++i) {
    		for (LL j = 1; j < i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
        }
        for (LL i = 1; i <= 1000; ++i) {
            for (LL j = 1; j <= 1000; ++j) {
                C[i][j] = ((C[i - 1][j] + C[i][j - 1] - C[i - 1][j - 1] + C[i][j] + MO) % MO) % MO; 
            }
        }
    	scanf("%lld", &Q);
    	while (Q--) {
    		LL x, y; scanf("%lld%lld", &x, &y);
    		swap(x, y);
    		printf("%lld\n", C[x][y]);
        }
    
        return 0;
    }
}
int main() {
    flyinthesky::solve();
    return 0;
}
```

---

## 作者：VenusM1nT (赞：0)

前缀和。毫无疑问，月赛最简单的一道题，直接递推预处理 $C_j^i$ 然后用前缀和累加一下，就可以 $\text{O}(1)$ 查询了。

```cpp
#include<bits/stdc++.h>
#define Mod 19260817
using namespace std;
int T,n,m;
int C[5005][5005];
int main()
{
    C[1][0]=C[1][1]=1;
    for(int i=2;i<=5000;i++)
    {
        C[i][0]=1;
        for(int j=1;j<=5000;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mod;
    }
    for(int i=1;i<=5000;i++) C[i][0]=0;
    for(int i=1;i<=5000;i++)
    {
        for(int j=1;j<=5000;j++) C[i][j]=(C[i][j]+C[i-1][j]+C[i][j-1]-C[i-1][j-1]+Mod)%Mod;
    }
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %d",&n,&m);
        printf("%d\n",C[m][n]);
    }
    return 0;
}
```

---

## 作者：kfhkx (赞：0)

#### 看到没有p语言的就来发一波吧
~~其实是来水gu值的~~

其实这一题[2016noipTGD2T1组合数问题]差不多啊
其实就是推杨辉三角公式+二维前缀和来解决组合数问题

多的就不说了，主要是为了p系选手而准备的代码

------------------------------------------------
```pascal
var
        q,i,j,x,y:longint;
        sum,f:array[0..1010,0..1010] of longint;
        mo:int64;
begin
        mo:=19260817;
        for i:=0 to 1010 do begin
                sum[i,0]:=1;//初始化一下
                sum[i,i]:=1;
                for j:=1 to i-1 do sum[i,j]:=(sum[i-1,j]+sum[i-1,j-1]) mod mo;//杨辉三角公式

        end;
        //预处理
        for i:=1 to 1010 do for j:=1 to 1010 do
        **f[i,j]:=((f[i-1,j]+f[i,j-1]-f[i-1,j-1]+sum[i,j]) mod mo+mo) mod mo;**
         //这里因为有可能是负数，所以要mod完之后再加mo再mod一次，划重点
        readln(q);
        while q>0 do begin
                dec(q);
                read(x,y);
                writeln(f[y,x]);
                //直接输出
        end;
end.
```

---

## 作者：muller (赞：0)

这题直接用一下组合数公式即可

可以用杨辉三角或者直接逆元搞一搞

然后预处理一个前缀和

最后询问的时候加一下即可

注意要特判一些细节

重要：i<j的情况为0

然后复杂度O(n*n+q*n)

代码：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll p = 19260817;
const int N = 1005; 
ll f[N][N], fac[N], inv[N], ans;
ll pw(ll x, ll y) {
	if (!y) return 1;
	ll z = pw(x, y / 2);
	z = z * z % p;
	if (y & 1) z = z * x % p;
	return z;
}
ll C(int n, int m) {
	if (n < m) return 0;
	return fac[n] * inv[m] % p * inv[n - m] % p;
}
int main() {
	int m, n, q, i, j;
	fac[0] = inv[0] = 1;
	for (i = 1; i <= 1000; ++i) {
		fac[i] = fac[i - 1] * i % p;
		inv[i] = pw(fac[i], p - 2);
	}
	for (i = 1; i <= 1000; ++i) {
		f[i][0] = 0;
		for (j = 1; j <= 1000; ++j) f[i][j] = (f[i][j - 1] + C(i, j)) % p;
	}
	scanf("%d", &q);
	while (q--) {
		scanf("%d%d", &m, &n);
		for (i = 1, ans = 0; i <= n; ++i) (ans += f[i][m]) %= p;
		printf("%lld\n", ans);
	}
	return 0;
}

```


---


# 小鱼比可爱（加强版）

## 题目描述

人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。

和之前的要求不一样，比赛组委会关心的是这个排列的“总得意值”。一共有 $n$ 只小鱼，总共有 $\frac{n(n+1)}2$ 个不同的区间。每个区间的得意值等于这个区间中符合“左边的一只鱼的可爱值比右边的一只鱼可爱值更大”的对数（其实就是区间逆序对数啦）。总得意值就是所有区间的“得意值”的和。现在要求输出“总得意值”是多少。

## 说明/提示

测试点　　　|$n$　　　　|$a_i$　　　　|是否有重复数字 　
:-:|:-:|:-:|:-:
$1$|$1$|无特殊限制|否
$2$|$10$|无特殊限制|否
$3$|$10$|无特殊限制|是
$4$|$1000$|$\le10$|是
$5$|$1000$|无特殊限制|否
$6$|$1000$|无特殊限制|是
$7$|$10^5$|$\le100$|是
$8$|$3\times 10^5$|无特殊限制|否
$9$|$5\times 10^5$|无特殊限制|是
$10$|$10^6$|无特殊限制|是

对于 $100\%$ 的数据，$n \le 10^6$，$a_i\le 10^9$，所有数字均为非负整数。

## 样例 #1

### 输入

```
8
1 9 2 6 0 8 1 7```

### 输出

```
106```

## 样例 #2

### 输入

```
10
1 10 8 5 6 2 3 9 4 7```

### 输出

```
270```

## 样例 #3

### 输入

```
20
6 0 4 5 8 8 0 6 6 1 0 4 6 6 0 0 7 2 0 5```

### 输出

```
3481```

# 题解

## 作者：Frozencode (赞：28)

考虑一组逆序对$(a[i],a[j])$贡献了几次,不难发现贡献了$i*(n - j + 1)$次。

考虑怎么统计，通常求逆序对我们是让树状数组上的值$+1$，现在我们实际上只要把$+1$改成$+(n - j + 1)$就行了（想想乘法分配律就知道这是对的）。

那么接下来就是常规的离散化加树状数组辣~

（答案会爆$longlong$,我偷懒写了个$int128$就欧克了QWQ)


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 ll;
const ll maxn=1000010;
const ll INF=2147483647;
ll n,a[maxn],b[maxn],c[maxn],tot,res,f[maxn];
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
inline void write(ll x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
	{
		write(x/10);
	}
	putchar(x%10+'0');
}
ll lowbit(ll x)
{
	return x & (-x);
}
void update(ll x,ll det)
{
	while(x <= n)
	{
		f[x] += det;
		x += lowbit(x);
	}
	return;
}
ll qry(ll x)
{
	ll tem = 0;
	x--;
	while(x)
	{
		tem += f[x];
		x -= lowbit(x);
	}
	return tem;
}
int main()
{
	n = read();
	for(int i = 1;i <= n;i++)
	{
		a[i] = read();
		b[i] = a[i];
	}
	sort(b + 1,b + n + 1);
	tot = unique(b + 1,b + n + 1) - b - 1;
	for(int i = 1;i <= n;i++)
	{
		c[i] = lower_bound(b + 1,b + tot + 1,a[i]) - b;
	}
	for(int i = n;i >= 1;i--)
	{
		ll item = i;
		ll idet = n - i + 1;
		res += (ll)(item * qry(c[i]));
		update(c[i],idet);
	}
	write(res);
	return 0;
}
```


---

## 作者：BinDir0 (赞：24)

[写博客不易，来玩会？](https://www.cnblogs.com/lost-in-tianyi/p/11186213.html)

## 这道题我和$dalao$们的做法略有不同，我用的是归并排序做法$qwq$

归并排序求逆序对大家应该很清楚了，我这里就来讲讲如何用归并排序求出这道题的答案

让我们先观察一下规律

举个栗子，若存在一组逆序对$a[3],a[4]$，$n = 5$，则这组逆序对存在于以下区间内：$[1 , 4],[1,5],[2,4],[2,5],[3,4],[3,5]$，共$6$个。我们可以画个图帮助理解：

![捕获.png](https://i.loli.net/2019/07/14/5d2b39c0531e712528.png)

将其推广，若有逆序对$a[l],a[r]$，如图所示：

![捕获.png](https://i.loli.net/2019/07/14/5d2b3aa41cb0622917.png)

则包含其的区间数，即该区间对答案的贡献为$(l + 1 - 1) * (n - r + 1  ) = l * (n-r+1)$。

然后再用归并排序即可。

注意两个点：

$1.$本题要用一个类似前缀和的变量来记录所有左半边的位置之和，搜到的时候再从$sum$中减去，否则会T（至少我T了）

$2.$会爆精度。记得开__$int$ $128$或者打高精（反正我开的__$int$ $128$ $qwq$）

### code：
```cpp
// Author : Kasugano_Sora
#include<bits/stdc++.h>
using namespace std;
struct item
{
    int pl , val;
} a[1100000] , b[1100000];
int n;
__int128 ans;
inline __int128 read()
{
    __int128 x = 0 , f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

inline void print( __int128 x )    //int 128必备操作
{
    if(x < 0)
    {
        putchar('-');
        x = -x;
    }
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
void msort( int l , int r )
{
    if(l == r)
    return ;
    int mid = (l + r) >> 1;
    msort(l , mid);
    msort(mid + 1 , r);
    long long sum = 0LL;        //所谓的前缀
    for(int i = l ; i <= mid ; i++ )
    {
        sum += 1ll * a[i].pl;
    }
    int i = l , j = mid + 1 , k = l;
    while(1)        //归并
    {
        if(i > mid || j > r)
        break;
        if(a[i].val <= a[j].val)
        sum -= 1ll * a[i].pl , b[k++] = a[i++];
        else
        {
            ans += sum * 1ll * (n - a[j].pl + 1);
            b[k++] = a[j++];
        }
    }
    if(i > mid) for( ; j <= r ; j++ , k++ )
    {
        b[k] = a[j];
    }
    else for( ; i <= mid ; i++ , k++ )
    {
        b[k] = a[i];
    }
    for(int i = l ; i <= r ; i++ )
    {
        a[i] = b[i];
    }
    return ;
}
int main()
{
//  freopen("1.txt" , "r" , stdin);
    cin >> n;
    for(int i = 1 ; i <= n ; i++ )
    {
        scanf("%d" , &a[i].val);
        a[i].pl = i;
    }
    msort(1 , n);
    print(ans);
    return 0;
}
```


---

## 作者：Thaumaturge (赞：13)

两篇题解都是用的树状数组，那我来一篇归并排序的吧（我觉得归并实在比树状数组好想得多）

首先，如果要把$n * (n+1)/2$个区间的逆序对全部分别求出来，显然是不可能的

因此，我们考虑把问题拆分，设原数列为a,考虑每个逆序对。不难发现，若存在逆序对k={ai,aj},那么能使得$k⊆C⊆U$的区间C就会有$i * (n-j+1)$个，这就是每个逆序对对答案产生的贡献

再考虑归并排序求逆序对的本质，其实就是通过两个序列的非严格单调性求出逆序对个数，而这里我们需要计算的是逆序对产生的贡献,所以对于每次合并区间$[ l , r ]$,在统计答案数量遇到逆序对$(ai,aj)$时,$ans$+=$\sum_{k=i}^{mid}sub[k] * (n-sub[j]+1)$即可，其中sub是数列a中每个数在原本的数列中的下标

每次合并区间的时候跑一遍前缀和就是的了，这样复杂度还是$O(nlogn)$的

#### 代码如下：

```cpp
#include <bits/stdc++.h>
#define N 1000010
#define Pn printf("\n")
#define int __int128
//记得用int128，longlong会炸。。。（当然手打高精最好）
using namespace std;

inline int read(){
    int x=0;char c=getchar();bool y=1;
    for(;c<'0' || c>'9';c=getchar()) if(c=='-') y=0;
    for(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;
    if(y) return x;
    return -x;
}

int a[N][2],n,m,hc[N][2];
int ans;
int sum[N];

void gb(int x,int y){
    if(y==x) return;
    int mid=(x+y)>>1;
    gb(x,mid);
    gb(mid+1,y);

    int i=x,j=mid+1;

    sum[mid]=a[mid][1];
    for(int i0=mid-1;i0>=x;i0--)//前缀和统计
        sum[i0]=sum[i0+1]+a[i0][1];
    for(int k=x;k<=y;k++)//归并排序，计算出每个逆序对的贡献
    {
        if(j>y || i<=mid && a[i][0]<=a[j][0]) hc[k][0]=a[i][0],hc[k][1]=a[i][1],i++;
        else {if(i<=mid) ans+=sum[i]*(n-a[j][1]+1);/*计算逆序对数时这里是ans+=mid-i+1,由此推出现在的ans的计算方法*/hc[k][0]=a[j][0],hc[k][1]=a[j][1],j++;}
    }
    for(int i0=x;i0<=y;i0++)
    a[i0][0]=hc[i0][0],a[i0][1]=hc[i0][1];
    return;
}

inline void write(int x)
{
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}

signed main(){
    n=read();
    for(int i=1;i<=n;i++)
    a[i][0]=read(),a[i][1]=i;
    for(int i=1;i<=n;i++);
    gb(1,n);
    write(ans);
    return 0;
}
```


---

## 作者：Kisaragi_77 (赞：9)

### 题意：

**统计所有区间的逆序对数**

### 分析：

一看到“统计所有区间的xxxx”

常用的套路自然是  **贡献法**

首先,本题逆序对的定义没有变

所以逆序对的数量还是那么多

考虑我们找了一组$(L,R)$

满足 $A[L]>A[R],L<R$	记这样的$(L,R)$	为一组逆序对

我们考虑他可能对答案产生的贡献

容易发现

$\forall x\in [1,L],y\in[R,n]$ 区间$[x,y]$都包含了逆序对$(L,R)$ 

根据**乘法原理**

 逆序对$(L,R)$ 对答案产生的贡献为 $L*(n-R+1)$

于是

$ans =\sum_{i=1}^n \ \sum_{j=1,i<j,A[i]>A[j]}^n i*(n-j+1)$

至此，我们已经有了一个

### 60分的完美做法：

```cpp
for(int i=1;i<=n;++i)
	for(int j=L+1;j<=n;++j)
		if(a[i]>a[j])	ans +=i*(n-j+1);
```

~~事实上，你想出了正解高精写挂也是60分~~

### 正解：

考虑如何高效的维护$(1)$式

肯定用数据结构啊

树状数组求逆序对你们会吧
[不会的点我去学习一下](https://www.luogu.org/problemnew/show/P1774)

简单提一下

值域$1e9$,先**离散化** 记最大值为$m$

之后统计的时候将$A_i$插入BIT 

向后查询$[Ai+1,m]$ 这一段区间

如何应对这个题？

首先我们只用一重循环,记当前处理到的数为$i$

$(n-i+1)$这一项我们肯定是很难搞的，而且跟i前面的值没有关系，考虑提到式子外面

重点就是我们如何处理i前面的乘积项

~~确定不自己思考一下嘛~~
 

我们在插入的时候,不是插入(A[i],1)，而是将权值插入进去就可以了

调用`add(A[i],i)`即可



还有一件恶心到毁天灭地的事情,这题的答案可以达到$n^4$超过了long long 

需要手写高精

由于我不会打py的树状数组，就用 **int128**水过去了

## AC代码:

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N =2e6;
typedef __int128 ll;
ll a[N],b[N],n,m,c[N];

inline int read(){
    int x;scanf("%d",&x);return x;
}
inline void print(ll x){
	if(x>9)	print(x/10);
	putchar(x%10+48);
}	//int128只能手写输出

inline void add(int x,ll v){
    for(;x<=m;x +=x&-x)	c[x] +=v;
}
inline ll sum(int x){
    ll ans =0;
    for(;x;x -=x&-x)	ans +=c[x];
    return ans;
}	//树状数组 

int main(){
    n =read();
    for(int i=1;i<=n;++i)   a[i] =b[i] =read();
    
    sort(b+1, b+n+1);
    m = unique(b+1,b+n+1)-b-1;
    for (int i=1;i<=n;++i)	a[i] = lower_bound(b+1,b+m+1,a[i])-b;	//离散化三行 
    
    ll ans =0;
    for(int i=1;i<=n;++i){
    	add(a[i],i);
    	ans += 1LL *(n-j+1) *(sum(m)-sum(a[i]) ;
    }	print(ans);
}
```





---

## 作者：【天朝】MILK (赞：8)

### 修改第二版！
#### 链接
------------
[逆序队模板题](https://www.luogu.org/problemnew/show/P1908)

[题目地址](https://www.luogu.org/problemnew/show/P5463)

------------
## 题目解析

##### 前面为我的个人思维，标准解法直接看最后面。

这题是我见过的题目中**比较坑**的了！

#### 坑点如下：

+ 题目的**不友好的数据范围**（N<=1000000）

+ 题目的数据大小（**爆LL**）

+ 若使用树状数组需要**离散化**

------------

## 壹.暴力法
#### 先来一波**暴力**吧：

	枚举区间起点与区间终点（由于不重复性，单个元素必定无逆序队，不妨设起点小于终点）
    
    那么再在此区间内求逆序队的个数
#### 代码如下 
	
$O$($N^{4}$)

$30$分

------------
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
long long Ans,N,A[1000005];
int main()
{
    scanf("%lld",&N);
    for(int i=1;i<=N;i++)scanf("%lld",&A[i]);
    for(int i=1;i<N;i++)
    {
    	for(int j=i+1;j<=N;j++)
    	{
    		for(int k=i;k<j;k++)
    		{
    			for(int z=k+1;z<=j;z++)
    			{
    				if(A[k]>A[z])Ans++;
				}
			}
		}
	}
	printf("%d\n",Ans);
	return 0;
}
```
------------
### 那么我们如何来优化呢？

------------

+ 离散化 $O$($N$ $log_2N$)
```
for(int i=1;i<=N;i++)scanf("%lld",&A[i]),B[i]=A[i];
    sort(B+1,B+1+N);//排序
    int Num=unique(B+1,B+N+1)-B-1;//不同元素个数
    for(int i=1;i<=N;i++)A[i]=lower_bound(B+1,B+1+Num,A[i])-B;//二分找到相应的值
```


- 树状数组

	数列中的元素有连个属性：位置与值

	注意到树状数组保存了位置与值的特性并支持两种操作：查询与加入
    
    $A[i]>A[j]$且$i<j$
    
    查询比$A[i]$小（或等）的元素个数$Num$，已插入个数为$I$，则答案应加上$I-Num$。同时在$A[i]$处以及其以前加入1。

- 归并排序

	答案将是排序需要的交换次数，此处省略
    
#### 代码如下 （树状数组）

$O$($N^{3}$ $log_2N$)

$30$分

------------
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
long long Ans,N,A[1000005],B[1000005],C[1000005];
int L_B(int x){return x&(-x);}
int Ask(int x)
{
	int Ans=0;
	for(int i=x;i;i-=L_B(i))Ans+=C[i];
	return Ans;
}
void Add(int x,int Num)
{
	for(int i=x;i<=N;i+=L_B(i))C[i]+=Num;
}
int main()
{
    scanf("%lld",&N);
    for(int i=1;i<=N;i++)scanf("%lld",&A[i]),B[i]=A[i];
    sort(B+1,B+1+N);//排序
    int Num=unique(B+1,B+N+1)-B-1;//不同元素个数
    for(int i=1;i<=N;i++)A[i]=lower_bound(B+1,B+1+Num,A[i])-B;
    for(int i=1;i<N;i++)
    {
    	
    	for(int j=i+1;j<=N;j++)
    	{
    		for(int k=1;k<=N;k++)C[k]=0;
    		for(int k=i;k<=j;k++)
    		{
    			Ans+=(k-i-Ask(A[k]));
    			Add(A[k],1);
			}
		}
	}
	printf("%lld\n",Ans);
	return 0;
}
```
------------
### 继续思考
	可以枚举长度与起点
#### 贡献：

贡献指的是对答案的贡献

#### 扩张：

扩张指的是由区间$[L,R]$扩展到$[L+1,R+1]$的变化

即将$A[L]$对当前逆序队的贡献**删去**，再**加上**$A[R+1]$对当前的贡献

删去可以用加$-1$的方法**解决**

#### 代码如下 （树状数组）

$O$($N^{2}$ $log_2N$)

$60$分

------------
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
long long Ans,A[1000005],N,B[1000005],C[1000005];
long long L_B(long long x){return x&(-x);}
void Add(long long X,long long Num)
{
    for(long long i=X;i<=N;i+=L_B(i))
    {
        C[i]+=Num;
    }
}
long long Ask(long long x)
{
    long long Ans=0;
    for(long long i=x;i;i-=L_B(i))
    {
        Ans+=C[i];
    }
    return Ans;
}
int main()
{
    scanf("%lld",&N);
    for(long long i=1;i<=N;i++)scanf("%lld",&A[i]),B[i]=A[i];
    sort(B+1,B+1+N);
    long long Num=unique(B+1,B+N+1)-B-1;
    for(long long i=1;i<=N;i++)A[i]=lower_bound(B+1,B+1+Num,A[i])-B;
    for(long long i=2;i<=N;i++)//枚举区间长度 
    {
    	long long Num=0;
        for(long long j=0;j<=N;j++)C[j]=0;
    	for(long long j=1;j<=i;j++)
    	{
    		Add(A[j],1);
    		Num+=j-Ask(A[j]);
        }
        Ans+=Num;
        for(long long j=1;j<=N-i;j++)
        {
            Add(A[j],-1);Num-=Ask(A[j]-1);
            Add(A[j+i],1);Num+=i-Ask(A[j+i]);
            Ans+=Num;
        }
    }
    printf("%lld\n",Ans);
}
```
------------
## 贰.标准法

对于$A[i]>A[j]$且$i<j$这一组逆序队只要被区间所包含就会有贡献
可以枚举知道贡献了$i*(N-j+1)$次

证明：i左边可以有$i$种取法，j右边有$(N-j+1)$种取法，由于乘法原理知方案数量为$i*(N-j+1)$次

## 如图
![](https://cdn.luogu.com.cn/upload/pic/63927.png)

**考虑树状数组维护：**

那么只需要把**数组的位置**加入即可（而非$1$）

------------

#### 用__int128解决高精度（考试勿用）

**__int128**部分借鉴了**Frozencode大佬**的代码

注意__int128过不了**C++**内部的编译**很正常**

------------

#### 代码如下 （树状数组）

$O$($N$ $log_2N$)

$100$分

------------
```
#pragma GCC optimize(5)//O5优化
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#define LOLO __int128
using namespace std;
LOLO AA,Ta,Ans,GG[1005],A[1000005],N,B[1000005],C[1000005];
LOLO L_B(LOLO x){return x&(-x);}
inline LOLO Read()
{
    LOLO x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline void Write(LOLO x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
    {
        Write(x/10);
    }
    putchar(x%10+'0');
}
void Add(LOLO X,LOLO Num)
{
    for(LOLO i=X;i<=N;i+=L_B(i))
    {
        C[i]+=Num;
    }
}
LOLO Ask(LOLO x)
{
    LOLO Ans=0;
    for(LOLO i=x;i;i-=L_B(i))
    {
        Ans+=C[i];
    }
    return Ans;
}
int main()
{
    N=Read();
    for(LOLO i=1;i<=N;i++)A[i]=Read(),B[i]=A[i];
    sort(B+1,B+1+N);
    LOLO Num=unique(B+1,B+N+1)-B-1;
    for(LOLO i=1;i<=N;i++)A[i]=lower_bound(B+1,B+1+Num,A[i])-B;
    for(LOLO i=N;i>=1;i--)//枚举区间长度 
    {
        LOLO Num=0;
    	Num=(Ask(A[i]-1))*i;
        Add(A[i],N-i+1);
        Ans+=Num;
    }
    Write(Ans);
    return 0;
}
```
------------
感谢考试时的**来之不易**的60分。

---

## 作者：Felis (赞：6)

### 思路
这题的重点：一共有 n 只小鱼，总共有 n×(1+n)/2 个不同的区间，求区间逆序对数和

那么暴力统计肯定是要去世的，我们可以考虑，对于大区间的每一个逆序对，对答案的贡献是多少。

分析样例吧：

8

1 **9** 2 6 0 **8** 1 7

我们把（9,8）这个逆序对抽出来，那么包含这个逆序对的区间有：

- **9 2 6 0 8**
- 1 **9 2 6 0 8**
- **9 2 6 0 8** 1
- 1 **9 2 6 0 8** 1
- **9 2 6 0 8** 1 7
- 1 **9 2 6 0 8** 1 7

可以发现，**9 2 6 0 8**这个区间是永远被包含的（废话）。这六个区间所不同的只是**9 2 6 0 8**前后的数字的个数。那么前面的数可以取0个或1个，共2种，后面可以取0,1或2个，共三种。那么**前面有2种情况，后面有3种情况，一共有几种情况呢？**

当然是六种。

拓展开来，对于逆序对$(a_i,a_j)$,对答案的贡献应该是$i*(n-j+1)$（过程不再赘述，不懂的可以私信我）

### 代码
我们开始想代码，先看看树状数组统计普通逆序对
~~~
 for(int i=1;i<=n;i++)
        ans+=sum(a[i]-1),add(a[i],1);
~~~
每次统计前面比自己小的数的个数，累加给答案；然后给树状数组里加上一个a[i]，很容易理解。但是首先，a[i]给答案的贡献要乘上i,所以应该是add(a[i],i);每一个a[j]给答案的贡献要乘上（n-j+1）,所以应该ans+=sum(a[i]-1)*(n-j+1)，因此

~~~
for(int i=1;i<=n;i++)
        ans+=sum(a[i]-1)*(n-i+1),add(a[i],i);
~~~

### 注意

- 本题会爆long long ，因此需用int128或高精
- 因为a[i]会到10^9，所以要离散化

### 我的代码

~~~
#include<bits/stdc++.h>
#define int __int128
#define N 20000005
using namespace std;
struct point {
    int id,num;
}e[N];
inline int read() 
{
    int X=0,w=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}

int n,a[N],p[N];
void print(int x)
{
    if(!x) return;
    if(x) print(x/10);
    putchar(x%10+'0');
}
bool cmd(point a,point b){
    return a.num>b.num;
}
int lowbit(int n){
    return n&-n;
}
int sum(int n,int sum=0){
    while(n)sum+=p[n],n-=lowbit(n);
    return sum;
}
void add(int x,int y){
    while(x<=n)p[x]+=y,x+=lowbit(x);
}
signed main(){
    n=read();
    if(n==1){
    	printf("0");return 0;
    }
    for(int i=1;i<=n;i++)
        e[i].num=read(),e[i].id=i;
    sort(e+1,e+n+1,cmd);
    int t=1;a[e[1].id]=1;
    for(int i=2;i<=n;i++){
        if(e[i].num!=e[i-1].num)t++;
        a[e[i].id]=t; 
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        ans+=sum(a[i]-1)*(n-i+1),add(a[i],i);
    print(ans);
    return 0;
}
~~~


---

## 作者：LesterYu (赞：4)

这道题的要求其实就是求逆序对。求逆序对可以借助树状数组，将求逆序对的过程等价于从大到小把每个数移到最前面去，记录途中跨越的比自己大的数个数。

与常见的逆序对模板题不同，本题需要进行一些变化。显然，许多逆序对都要统计多次，我们进行的变化就是求出每个逆序对被统计的次数，取逆序对（i，j）——i<j且第i个数大于第j个数，观察可得，统计的次数就是i,j两点到数列两端距离的乘积，即i*（n-j+1），那么具体到每一个数，以第i个数为右端小数的逆序对统计次数之和为第1至i-1个数中比第i个数大的数的编号之和与（n-i+1）的乘积。

如果一个一个统计过去，O（n^2）的复杂度肯定过不了。不过试着将这个公式代入我们的求逆序对模板，只需将add操作中加的“1”改为编号数即可。

而n<=1e6，统计出的结果应该会爆long long。所以需要再加个高精Qwq。

蒟蒻代码——

```
#include<cstdio>
#include<algorithm>
#define ll long long
#define MAX 100000
using namespace std;
ll c[1000001],n;
ll k,ans[1001],d,gmax;
struct qwq{
    ll m,t;
}a[1000001];
bool cmp(qwq x,qwq y){
	if(x.m==y.m) return x.t<y.t;
    //若等大，编号小的放前面，避免被影响
	else return x.m<y.m;
}
int l(int x){return x&-x;}
void add(ll x,ll y){while(x<=n) c[x]+=y,x+=l(x);}
ll sum(int x){
    ll k=0;while(x){k+=c[x],x-=l(x);}
    return k;
}

void gao(){//高精（5位）
	for(int i=0;i<=gmax;i++){
		if(ans[i]>=MAX){
			ans[i+1]+=ans[i]/MAX;
			ans[i]=ans[i]%MAX;
			if(i==gmax) gmax++;
		}
		else break;
	}
}

void ling(int x){//不足5位补零
	int kk=MAX/10;
	while(kk>ans[x]){
		printf("0");
		kk/=10;
	}
}

int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i].m);
        a[i].t=i,c[i]=0;
    }
    stable_sort(a+1,a+n+1,cmp);
    for(int i=n;i>=1;i--){
        ans[0]+=sum(a[i].t-1)*(n-a[i].t+1);
        add(a[i].t,a[i].t);//树状数组操作
        gao();
    }
    for(int i=gmax;i>=0;i--){
    	if(i!=gmax) ling(i);
    	printf("%lld",ans[i]);
	}
    return 0;
}
```


---

## 作者：ZQYZQY (赞：4)

1.思路dalao已经讲的很清楚了，就是n^2logn转nlogn，除了转化就是一道裸的逆序对；

2.都是树状数组，线段树菜鸡贴个权值线段树（模板题吧。。。）

3.爆long long，用__int128

4.离散

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
int const maxn=1e6+5;
LL n,a[maxn],tmp[maxn],c[maxn],size;
LL ans,cnt[maxn<<2];
inline LL read(){
    char ch=getchar();
    LL f=1,x=0;
    while (ch<'0' || ch>'9'){
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0' && ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return f*x;
}
void _print(__int128 x){
    if (x==0) return; 
    _print(x/10);
    putchar(x%10+'0');
}

 void init(LL rt,LL l,LL r,LL x,LL id){
     if ((l==r)&&(l==x)) {
        cnt[rt]+=id;
        return;
     }
     LL mid=(l+r)>>1;
     if (x<=mid) init(rt<<1,l,mid,x,id);
     else if (x>mid) init(rt<<1|1,mid+1,r,x,id);
     cnt[rt]=cnt[rt<<1]+cnt[rt<<1|1];
 }//插入权值线段树
LL sum(LL rt,LL l,LL r,LL x,LL y){
     if ((x<=l)&&(y>=r)) return cnt[rt];
     LL anss=0;
     LL mid=(l+r)>>1;
     if (x<=mid) anss+=sum(rt<<1,l,mid,x,y);
     if (y>mid) anss+=sum(rt<<1|1,mid+1,r,x,y);
     return anss;
 }//求区间和
 int main(){
    n=read();
    for (long long int i=1;i<=n;i++){
          a[i]=read();
          tmp[i]=a[i];
	}   
         sort(tmp+1,tmp+1+n);
         size=unique(tmp+1,tmp+1+n)-(tmp+1);
    for (long long int i=1;i<=n;i++) a[i]=lower_bound(tmp+1,tmp+1+size,a[i])-tmp;//离散化
    for (long long int i=1;i<=n;i++){
        init(1,1,n,a[i],i);
        ans+=sum(1,1,n,a[i]+1,n)*(n-i+1);
    }
    if(!ans) cout<<0;
    else _print(ans); 
 return 0;
}
```


---

## 作者：zhanghengrui (赞：3)

既然已经有了两篇树状数组的题解，那我就发一篇归并排序的题解吧

不会归并排序？请先做一做[这题](https://www.luogu.org/problemnew/show/P1908)，并学习其归并排序的做法

本题归并排序部分代码

```cpp
//要排序的区间是[l,r)  注意是不包含r的
//这里有些同学可能写法不太一样，需要微调一下
void MergeSort(long l, long r)
{
	if (l + 1L < r)
	{
		long i = l, j, k = 0L, mid = (l + r + 1L) >> 1;
		long long s = 0LL;
		j = mid;
		MergeSort(l, mid);
		MergeSort(mid, r);
		for (long _ = l; _ < mid; ++_) s += num[_];
		while (i < mid&&j < r)
		{
			if (a[i] > a[j])
			{
				tmp[0][k] = a[j];
				tmp[1][k++] = num[j];
				ans += (__int128)(s + mid - i)*(n - num[j++]);  //注意这里！！！
			}
			else
			{
				tmp[0][k] = a[i];
				tmp[1][k++] = num[i];
				s -= num[i++];
			}
		}
		while (i < mid)
		{
			tmp[0][k] = a[i];
			tmp[1][k++] = num[i++];
		}
		while (j < r)
		{
			tmp[0][k] = a[j];
			tmp[1][k++] = num[j++];
		}
		memcpy(a + l, tmp[0], sizeof(long)*(size_t)k);
		memcpy(num + l, tmp[1], sizeof(long)*(size_t)k);
	}
	return;
}
```

在平时统计逆序对时，上面那个地方一般写的是`ans += mid - i`，因为从$a_i$到$a_{mid-1}$都可以和$a_j$组成逆序对

（下文中$num_i$表示当前下标为$i$的元素在原来数组中的位置（$0,\cdots,n-1$））

对于逆序对$(i,j)\space(0\le i,j<n)$，它对答案的贡献显然为$(num_i+1)(n-num_j)$

而上面那个地方的逆序对有$(i,j),\cdots,(mid-1,j)$

因此总贡献为$\sum_{k=i}^{mid-1}{(num_k+1)(n-num_j)}$

稍微化简一下就是$((\sum_{k=i}^{mid-1}{num_k})+mid-i)(n-num_j)$

注意到$i$是递增的，因此我们可以预先求出$\sum_{k=l}^{mid-1}{num_k}$，然后每次`++i`之前让sum减掉$num_i$

最后再注意一下要打高精度或者`__int128`，然后就可以愉快地AC本题了

[完整AC代码](https://www.luogu.org/paste/vkmeiain)

---

## 作者：_Extroversion (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5463)

## 题目大意
- 给定一个长度为 $n$ 的序列，求所有区间逆序对数量的总和。
- $n\leq 10^6$


------------


直接暴力是 $O(n^4)$ 的，只能获得 $30$pts，于是我们考虑贡献法，考虑  $a_i,a_j(i<j,a_i>a_j)$ 这对逆序对对答案产生的贡献。

对于每个包含 $a_i$ 与 $a_j$ 的区间，这对逆序对都能带来 $1$ 的贡献，所以我们只需要求出有多少个区间包含 $a_i$ 与 $a_j$。
![](https://cdn.luogu.com.cn/upload/image_hosting/gzzkbhhd.png)
满足条件的区间的左端点可以取 $1\sim i$，共有 $i$ 种取值，右端点可以取 $j\sim n$，共有 $n-j+1$ 种取值，根据乘法原理可得，有 $i\times (n-j+1)$ 个包含 $a_i$ 与 $a_j$ 的区间。

枚举每对逆序对，将答案加上 $i\times (n-j+1)$，这种 $O( n^2 )$ 做法可以获得 $60$pts。

使用归并排序可以 $O( n \log n )$ 通过本题。此处我重点讲解树状数组的做法。

在讲解之前，我默认你们已经会使用树状数组通过 [P1428](https://www.luogu.com.cn/problem/P1428)  ~~（ 谁会用树状数组做红题呢~~

开一个值域的树状数组，从 $n\sim 1$ 遍历，每次将 $a_i$ 的位置加上 $n-i+1$，即 `add(a[i],n-i+1)`，并将答案加上 `i*query(a[i-1])`，因为是从后往前遍历，树状数组已经统计完 $i$ 以后的数，`query(a[i-1])` 即所有比 $a_i$ 小的数对应贡献的和，把和再乘 $i$，根据乘法分配律，即可得到结果是 $a_i$ 与后面的数构成逆序对的带来的总贡献， 把从 $1\sim n$ 的 $i$ 带来的贡献加起来，就是最终的答案。该方法的复杂度也是 $O( n \log n )$ 的，可以通过本题，且不用担心常数，因为本题时限为 $2$s。
## 注意事项
1. 本题 $n\leq 10^6$，但 $a_i\leq 10^9$，所以数据需要离散化，[P1908](https://www.luogu.com.cn/problem/P1908) 与 [P1774](https://www.luogu.com.cn/problem/P1774)  是练习离散化不错的题目，若你通过本题，同时您可以获得三倍经验。
2. 本题答案是 $n^4$ 数量级的，超过 `long long` 类型的范围，你可以开 `long long` 类型的树状数组，并用高精度加法累加答案，也可以开  `__int128`，使用快读与快写，~~用 Python~~ 。


------------


 代码就不展示了，若你熟练掌握提到的数据结构与算法，你一定能独自通过本题。

---

## 作者：chenxinyang2006 (赞：2)

我一定要吐槽一下这题$n^2$暴力60分，$n\ log(n)$不开高精也60分

~~那我写什么正解~~

**说明：本题解中，文字上面带$^ 1$等数字的，表示注释，写在文章最下面**

- **分析**
 
   从每个区间的角度去考虑问题显然比较困难，事实上，这样做$^1$最优也只能做到$n ^ 2\ log(n)$
   
   所以我们需要转变一下思路，考虑考虑一对逆序对$(i,j)$会被多少个区间包含：

   左边有$i$种选择（这个区间的左边界可以是$[1,i]$中的任意整数，都会包含数对$(i,j)$）

   同样，右边界可以是$[j,n]$中的任意整数，$[j,n]$有$n - j + 1$个整数
   
   使用小学就学过的乘法原理，一共的区间数是：
   
   $i \times (n - j + 1)$

   于是，暴力枚举每个$(i,j)$的$n^2$暴力就可以写了：
   
```cpp
#include <cstdio>
#define ll long long
int n,ans = 0;
int arr[1000005];

int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		scanf("%d",&arr[i]);
	}
	ll ans = 0;
	for(int i = 1;i <= n;i++){
		for(int j = i + 1;j <= n;j++){
			if(arr[i] > arr[j]){
				ans += (ll)i * (n - j + 1);
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

- **优化**

  先写出来刚才的式子：
  
  $\sum\limits_{i=1}^n \sum\limits_{j=i+1} ^ n [a_i > a_j] \times i \times (n - j + 1)$
  
  这个东西并不是很好算，所以考虑枚举一个$i$来统计，这样我们就只需要算：
  
  $\sum\limits_{j=i+1} ^ n [a_i > a_j] \times (n - j + 1)$
  
  就行了
  
  但是$[a_i > a_j]$这个东西还是比较难算的$^2$，需要再变换一下，从用$j$表示$a_j$，改为用$a_j$表示$j$：

  $\sum\limits_{k = 1}^{a_i-1} (n - id_k + 1)$

  其中，$id_k$表示在区间$[i,n]$中，每个$a[j] = k$的$j$之和$^3$
  
  这个东西看似不好算，很复杂
  
  但是其实每次$id_k$的区间右端点都不变，只有左端点在左移，那么我们只在上次的基础上，加入新的一个$k$的贡献就可以了
  
  所以就是要维护数组$id$，那么每次进行单点修改或者区间查询
  
  那么，这个可以用树状数组来维护
  
  最后别忘了把答案$\times i$
  
  然后本题要开高精度$^4$，一开始对$a_i$要进行离散化。离散化不会的话，去[这里](https://www.luogu.com.cn/problemnew/solution/P1908)学习一下

- 注释

  1) 这种做法是：枚举$i$，从左到右扫一遍$j$，然后计算出比起区间$[i,j -1]$，$[i,j]$多出了多少贡献，使用权值树状数组解决这个计算。同样可以得到60pts，但是过于野蛮，所以不多介绍

  2) 每次查询区间$[l,r]\le x$的数的权值之和，这个问题可以套主席树模板解决。但是和本题的做法没有本质区别，我在解释的东西就是主席树的做法
  
  3) 如果你想知道为什么，那我也解释不了，反正这就是解决这类问题的标准做法……
  
  4) 有$n ^ 2$个区间，每个区间可能会有$n ^ 2$个逆序对，所以答案最大是$n ^ 4$，当$n = 10 ^ 6$时，$n ^ 4 = 10 ^ {24}$，真的爆了$long\ long$……

代码：

```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
int n,cnt = 0;
ll a[1000005];
ll c[1000005];//这里开int会炸，longlong不会
int ans[50],len = 1;//这个是存答案的

struct node{
	int val,id;
}b[1000005];

bool cmp(node a,node b){
	return a.val < b.val;
}

int lowbit(int x){
	return x & -x;
}

ll sum(int i){
    ll ret = 0;
    while(i > 0){
        ret += c[i];
        i -= lowbit(i);
    }
    return ret;
} 

void update(int i,int val){
    while(i <= cnt){
        c[i] += val;
        i += lowbit(i);
    }
} 

int main(){
    scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		scanf("%d",&b[i].val);
		b[i].id = i;
	}
	sort(b+1,b+n+1,cmp);
	for(int i = 1;i <= n;i++){
		if(b[i].val != b[i - 1].val || i == 1){
			cnt++;
		}
		a[b[i].id] = cnt;
	}//离散化
	for(int i = n;i >= 1;i--){
		if(i != n){
			ll now = i * sum(a[i] - 1);//这里的now也要long long，每次乘的值最高也就1000000^3，也就是10^18的样子
			int count = 0;
			while(now != 0 || count != len){
				ans[++count] += now % 10;
				if(ans[count] >= 10){
					ans[count + 1] += ans[count] / 10;
					ans[count] = ans[count] % 10;
				}
				if(ans[count + 1] != 0){
					len = max(len,count + 1);
				}else{
					len = max(len,count);
				}
				now /= 10;
			}
		}
		update(a[i],n - i + 1);
	}
	for(int i = len;i >= 1;i--){
		printf("%d",ans[i]);
	}
	return 0;
}
```

不得不说，本题推式子的部分还真是只可意会，不可言传。我感觉我讲得不太清楚，但是也没有办法了

**update on 2020.1.29 修了latex，从感性理解改为了用式子表示**

---

## 作者：Uniecho1 (赞：2)

对于逆序对（num[j],num[i]），它会被计算（N-i+1) * j次（起点为[1,j]中任意一个，终点为[i,N]中任意一个的区间都会计算到它。由乘法原理，它会被计算（N-i+1）*j次）

于是顺位推，第i位对答案的贡献为（N-i+1）*（j1+j2+j3+j4+...）,其中num[jk]>num[i]

于是到这一步，它被转为了一个数据结构题

emmm，似乎大多数人都想到了离散化+树状数组......

我脑回路比较清奇（其实就是脑子简单），想到了**Splay**

大概思路是，以num[i]为关键字，开两个附加域，分别叫做seg、sumseg，用于统计下标和

统计到第i位时，我们就把**它的值和下标**给插入到Splay中，然后把它旋转到根，这个时候**根的右子树**就一定是下标<i的数中，值>num[i]的结点的集合

于是只需要把右子树的segsum乘上（N-i+1）再加进ans中就可以求得第i位的贡献了

最后输出ans即可（嗯我废话是不是有点多......）

关于高精问题，有个操作叫做**int128**，可以在luogu中勉强当高精用（划重点，NOIP什么的不行的）。**int128**类型只能用快读来读，用快写来写（当然你会重载>>的话当我没说）。如果在本机上编译不过，可以用luogu的在线IDE（好东西）。

最后有谁愿意和我交换一下友链吗，~~我的朋友很少，~~ 我想要多向dalao们了解学习OI的方法（我太弱了......)

放一放代码，记得要自己加一点优化，不然是过不了的。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int N,num[maxn];
__int128 ans;
struct BT{
    int root,cnt,ch[maxn][2],val[maxn],fa[maxn],seg[maxn];
    __int128 segsum[maxn];
    inline int Chk(int x){
        return x==ch[fa[x]][1];
    }
    inline void Upt(int x){
        segsum[x]=seg[x]+segsum[ch[x][0]]+segsum[ch[x][1]];
    }
    inline void Rotate(int x){
        int y=fa[x],z=fa[y],k=Chk(x),w=ch[x][k^1];
        ch[z][Chk(y)]=x;fa[x]=z;
        ch[x][k^1]=y;fa[y]=x;
        ch[y][k]=w;fa[w]=y;
        Upt(y);Upt(x);
    }
    inline void Splay(int x,int v=0){
        while(fa[x]!=v){
            int y=fa[x],z=fa[y];
            if(z!=v){
                if(Chk(y)==Chk(z))Rotate(y);
                else Rotate(x);
            }
            Rotate(x);
        }
        if(!v)root=x;
    }
    inline void Insert(int v,int s){
        int x=root,pa=0;
        while(x&&v!=val[x]){
            pa=x;x=ch[x][v>val[x]];
        }
        if(x&&v==val[x])seg[x]+=s;
        else{
            x=++cnt;
            val[x]=v;
            seg[x]=s;
            fa[x]=pa;
            if(pa)ch[pa][v>val[pa]]=x;
        }
        Splay(x);
    }
}T;
inline void Read(int&x){
    x=0;int f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    x*=f;return;
}
inline void Write(__int128 x){
    if(x>=10)
    Write(x/10);
    putchar(x%10+'0');
}
int main(){
    //freopen("in.txt","r",stdin);
    Read(N);
    for(register int i=1;i<=N;i++)Read(num[i]);
    T.Insert(INT_MAX,0);
    for(register int i=1;i<=N;i++){
        T.Insert(num[i],i);
        ans+=(N-i+1)*T.segsum[T.ch[T.root][1]];
    }
    Write(ans);
    return 0;
} 
```


---

## 作者：快斗游鹿 (赞：1)

## 思路

$a_i$ 很大，所以得先离散化。如果存在一组 $i,j$，使得 $a_i>a_j$，那么以 $j$ 为右端点，一共有 $i$ 个区间覆盖到这对逆序对。而这一组逆序对，在后面还会被统计 $n-i+1$ 次。

正常统计逆序对，我们是往树状数组中当前位置加一。而现在我们要加 $i$，并在统计答案时将以 $1$ 为左端点，$i$ 为右端点的这段区间的答案再乘上 $n-i+1$ 就行了。

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,a[N],b[N];
__int128 c[N],ans;
map<int,int>mp;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
void print(__int128 x){
    if(!x)return ;
    if(x<0)putchar('-'),x=-x;
    print(x/10);
    putchar(x%10+'0');
}
int lowbit(int x){
	return x& -x;
}
void add(int x,int w){
	for(x;x<=n;x+=lowbit(x))c[x]+=w;
}
long long ask(int x){
	long long ccc=0;
	for(x;x>0;x-=lowbit(x))ccc+=c[x];
	return ccc;
}
int main(){
	//freopen("std.in","r",stdin);
	n=read();
	if(n==1){
		cout<<0;return 0;
	}
	for(int i=1;i<=n;i++)a[i]=read(),b[i]=a[i];
	sort(b+1,b+1+n);
	int sum=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+1+sum,a[i])-b;
		//cout<<a[i]<<" ";
	}
	for(int i=1;i<=n;i++){
		//ans+=(ask(n)-ask(a[i]));
		long long nowb=(ask(n)-ask(a[i]));
		ans=ans+(n-i+1)*nowb;
		add(a[i],i);
	}
	print(ans);
	return 0;
}


```


---

## 作者：Soulist (赞：1)

考试的时候很多人$95$分应该都是因为没有开$int128$吧

真的坑 QAQ，取个膜多好

我们对每对逆序对单独考虑，考虑其会被多少个区间算

注意到一对逆序对，假设其由$(i,j)$号元素构成，那么其对答案产生的贡献为：

$$i*(n-j+1)$$

$ps:($某个区间的左端点取$1,2..i$，右端点取$j,j+1..n$时，这些区间都包括了这个逆序对，所以这个逆序对会被算$i*(n-j+1)$次$)$

不妨对某一个$j$单独考虑，假设$k1,k2...k_n$位置对应的权值都比$j$位元素对应权值大，那么$j$的答案为：

$$\sum_{i=1}^nk_i*(n-j+1)$$

利用一下乘法分配律，我们维护一下$k_i$的和即可，用一下权值树状数组，维护位置和。

先处理出$1-n$区间的树状数组，然后从$n$位开始倒推求答案，每次移动一位后将这一位的位置从对应权值减去即可

复杂度$O(n \log n)$

```cpp
#include<bits/stdc++.h>
using namespace std ; 
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int __int128
int read() {
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
    while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}
const int N = 1e6 + 5 ; 
int n, a[N], tree[N], num, Ans ; 
struct S {
    int id, s ; 
} s[N];
bool cmp( S x, S y ) {
    return x.s < y.s ; 
}
bool cmp2( S x, S y ) {
    return x.id < y.id ; 
}
int lowbit( int x ) {
    return ( x & ( -x ) ) ;
}
void add( int x, int k ) {
    for( int i = x; i <= n; i += lowbit(i) ) tree[i] += k ;
}
int query( int x ) {
    int ans = 0;
    for( int i = x; i; i -= lowbit(i) ) ans += tree[i] ; 
    return ans ;
}
signed main() {
    n = read() ; 
    rep( i, 1, n ) a[i] = read(), s[i].id = i, s[i].s = a[i] ;
    sort( s + 1, s + n + 1, cmp ) ; 
    s[0].s = -1 ; num = 0 ;
    rep( i, 1, n ) {
        if( s[i].s != s[i - 1].s ) a[s[i].id] = ++ num ; 
        else a[s[i].id] = num ; 
    }
    sort( s + 1, s + n + 1, cmp2 ) ; 
    rep( i, 1, n ) add( a[i], i ) ; 
    int ll, rr ; 
    for( re int i = n; i >= 1; -- i ) {
        rr = n - i + 1 ; 
        ll = query(n) - query( a[i] ) ; 
        Ans += ll * rr ; add( a[i], -i ) ; 
    }
    printf("%d\n", Ans ) ; 
    return 0 ; 
}
```

---

## 作者：Llf0703 (赞：1)

[更好的阅读体验](https://llf0703.com/p/luogu-monthly-201907.html#c-p5463%E5%B0%8F%E9%B1%BC%E6%AF%94%E5%8F%AF%E7%88%B1%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%89)

## 题意

用 $\text{cnt[i][j]}$ 表示区间 $[i,j]$ 的逆序对个数，求：

$$\sum_{i=1}^n \sum_{j=i}^n \text{cnt[i][j]}$$

## 题解

考虑每个逆序对 $(S_i,S_j)$ 对答案的贡献。显然它会对所有 **起点 $\in [1,i]$ 以及终点 $\in [j,n]$ 的区间** 产生 $1$ 的贡献，总的贡献为

$$i\times (n-j+1)$$

然后考虑固定的 $S_j$ 的贡献，对于所有 $i<j$ 且 $S_i>S_j$ ，这个 $S_i$ 都会产生上式的贡献。设 $T_k$ 表示在 $j$ 之前所有数值 $k$ 的**下标和**，那么每个 $j$ 的贡献为

$$\sum T_k \ , \ k>S_j$$

显然 $T_k$ 可以离散化后用树状数组维护，然后枚举每个 $j$ 就可以得到答案。

实际上就是把求逆序对时 $+1$ 给换成了 $+$ 当前下标，查询时把答案 $\times (n-i+1)$ 。

答案会爆 `long long` ，我直接用 `__int128` 水过了。

```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

inline ll read()
{
    char ch=getchar();
    ll f=1,x=0;
    while (ch<'0' || ch>'9')
    {
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return f*x;
}

struct node {
    ll s,id;
} s[1000005];
ll n,ord[1000005],t[1000005];

inline ll lowbit(ll x) { return x&-x; }

inline void add(ll x,ll y) { for (;x<=n;x+=lowbit(x)) t[x]+=y; }

inline ll query(ll x)
{
    ll ans=0;
    for (;x;x-=lowbit(x)) ans+=t[x];
    return ans;
}

inline bool cmp(const node &x,const node &y) { return x.s==y.s ? x.id>y.id : x.s>y.s; }

void print(__int128 x)
{
    if (x==0) return;
    print(x/10);
    putchar(x%10+'0');
}

signed main()
{
    n=read();
    for (ll i=1;i<=n;i++) s[i].s=read(),s[i].id=i;
    sort(s+1,s+n+1,cmp);
    for (ll i=1;i<=n;i++) ord[s[i].id]=i; //离散化
    __int128 ans=0;
    for (ll i=1;i<=n;i++)
    {
        add(ord[i],i);
        ans+=query(ord[i]-1)*(n-i+1);
    }
    if (ans==0) puts("0");
    else print(ans);
    return 0;
}
```

---

## 作者：Capitalism_Gao (赞：1)

# 看了众多树状数和归并排序，我决定提交：N^2递推算法（60 points）！

## 性能比较：
### 1. 时间：2*N^2（轻松过10^6数据）
### 2.空间：N^2二维数组(后4个点MLE，空间爆了)
### 3. 代码量：20行代码
### 4. 思考量：实现前缀和很烧脑

## 算法思想：

### 我们不难发现，区间[i,j]的逆序对数=区间[i,j-1]的逆序对数+a[i~j-1]这中大于a[j]的个数（其实就是新增的逆序对数）。
### Therefore,all we need to do is making preparations.
#### 1.用f[i][j]表示a[i]和a[j]的大小关系，a[i]>a[j]则f[i][j]=1,否则为0；
#### 2. 采用前缀和，用sum[i][j]存a[i~j-1]中比a[j]大的个数;
#### 3.sum[i][j]=sum[i+1][j]+f[i][j]；既然都这么些了，那么外层循化应该是j，内层是i。
### 现在供上预处理代码：
```cpp
int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int R=n;R>=2;R--){
        for(int L=R-1;L>=1;L--){
        	if(a[L]>a[R]) f[L][R]=1;
        	sum[L][R]=sum[L+1][R]+f[L][R];
        }
    }//sum[L][R]表示从L到R-1的数中大于a[R]的数 
```
### 有了预处理ans[i][j]=ans[i][j-1]+sum[i][j],再用tot累加即可;
```cpp
#include<bits/stdc++.h>
using namespace std;

long long a[10001],sum[1001][1001],f[1001][1001],ans[1001][1001],tot;

int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int R=n;R>=2;R--){
        for(int L=R-1;L>=1;L--){
        	if(a[L]>a[R]) f[L][R]=1;
        	sum[L][R]=sum[L+1][R]+f[L][R];
        }
    }//sum[L][R]表示从L到R-1的数中大于a[R]的数 
    for(int i=1;i<=n-1;i++){
        for(int j=i+1;j<=n;j++){
            ans[i][j]=ans[i][j-1]+sum[i][j];
            tot+=ans[i][j]; 
        }
    }
    cout<<tot;
    
    return 0;
}
```



---

## 作者：_MRCMRC_ (赞：0)

对于这道题，分析题意，即求区间逆序对的和


我们考虑使用树状数组，对每一条鱼求逆序对即可   


但这还没有完成，我们考虑每条鱼的价值对总答案的贡献之和的求  法
  
下面将详细讲解一下其他题解没有提到的**如何推出贡献的方程**

### 首先，我们构造一个序列：（当然这不是答案）

$1$ $2$ $3$ $4$ $5$

它所能组合的区间有15种（即$C\binom 2 5=15$），如下：

单元素： $1$ $2$ $3$ $4$ $5$  
双元素： $12$ $23$ $34$ $45$  
三元素： $123$ $234$ $345$  
四元素： $1234$  $2345$   
五元素： $12345$

其中，$1$贡献了$5$次，$2$贡献了$8$次，$3$贡献了$9$次，$4$贡献了$8$次，$5$贡献了$5$次

### 以此类推：
我们可以得到以下这个表：     
   
$1$  
$2$ $2$  
$3$ $4$ $3$  
$4$ $6$ $6$ $4$  
$5$ $8$ $9$ $8$ $5$  
$6$ $10$ $12$ $12$ $10$ $6$    

...........

$n\ 2(n-1)\ 3(n-2)\ 4(n-3)……i(n-i+1)$

### 综上，对于总长度为n的序列：  
 
每个元素对答案的贡献为$i×(n-i+1)$

所以，我们用树状数组对逆序对进行处理，随后统计总贡献即可。  

~~呆~~代码：
```cpp
#include<bits/stdc++.h>
#define in inline
#define reg register
#define MAX 20030813
#define int __int128
using namespace std;
namespace qwq{
	in void read(int &o)
	{
		o=0;int w=1;
		char c=getchar();
		while(c<'0'||c>'9')
		{
			if(c=='-')w*=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9')
		{
			o=(o<<3)+(o<<1)+(c^48);
			c=getchar();
		}
		o*=w;
	}
	in void write(int x)
	{
		if(x<0)putchar('-');
		if(x>9)write(x/10);
		putchar(x%10+48);
	}
	in int max(int a,int b){return a>b?a:b;}
	in int min(int a,int b){return a<b?a:b;}
}
using namespace qwq;
int n,t[MAX],ans,b[MAX];
class Num
{
public:
	int id,N;
	void input(int i){read(N),id=i;}
	bool operator<(const Num&n)const{return (N==n.N)?(id<n.id):(N<n.N);}
}a[MAX];
#define lowbit(x) x&-x
void add(int x,int k)
{
	for(;x<=n;x+=lowbit(x))t[x]+=k;
}
in int query(int x)
{
	int sum=0;
	for(;x;x-=lowbit(x))sum+=t[x];
	return sum;
}
signed main()
{
	read(n);
	int sum=0;
	for(reg int i=1;i<=n;++i)a[i].input(i);
	sort(a+1,a+n+1);
	for(reg int i=n;i>=1;--i)
	{
		b[i]=query(a[i].id-1);
		//write(b[i]),putchar(' ');
		add(a[i].id,a[i].id);
	}
	for(reg int i=1;i<=n;++i)
	{
		ans+=(n-a[i].id+1)*b[i];
	}
	write(ans);
	return 0;
}

```
### $n<=10^6$，用 $int128$水一下


---

## 作者：2018heyuyang (赞：0)

## ~~这不是归并排序吗~~

大家应该都做过求逆序对这道题

## [归并排序板子题](https://www.luogu.org/problemnew/show/P1908)

其核心代码如下：
```cpp
	int mid=(l+r)>>1;
	msort(l,mid);msort(mid+1,r);
	int i=l,j=mid+1,len=l-1;
	while(i<=mid&&j<=r)
	{
		if(a[i]>a[j])
		{
			mmp[++len]=a[j++];
			ans+=mid-i+1;
		}
		else mmp[++len]=a[i++];
	}
	while(i<=mid)mmp[++len]=a[i++];
	while(j<=r)mmp[++len]=a[j++];
	for(int i=l,j=l;i<=r;i++,j++)a[i]=mmp[j];
```
具体实现 ~~（请大佬和萌新跳过这段，蒟蒻留下，那些自称刚学OI一秒的萌新tql）~~ ：

设$a[i]$为下文中左段的一个数，$a[j]$为下文中右段的一个数

1. 递归甩锅，将序列二分，分别将左右两段排序，并分别求出一段内的逆序对数

2. 现在我们有了两个**单调递增**的数段了，下一步是合并两段+求逆序对数

3. 鱿鱼我们**已经求完了左、右子段的逆序对数**，所以剩下还没统计的逆序对会以$(a[i],a[j])$的形式出现，其中$a[i]>a[j]$

证明：

一个逆序对有两个数，他们要么**都在左子段**；要么**都在右子段**；要么**一个在左子段，一个在右子段**；（共3种情况）

对于都在左子段的情况，我们已经递归甩锅统计过了，右子段同理，所以，仅剩**一左一右**的情况了

4. 统计逆序对$(a[i],a[j])$的个数（顺便排序）

定义 $i$ 为左段到达的编号，$j$为右段到达的编号

$i$ 从 $l$ 开始（左段），$j$从$mid+1$开始（右段）

当前，若$a[i]>a[j]$，由于子段单调递增，$so$，$a[mid]>a[mid-1]>...>a[i+1]>a[i]$

所以 $a[i$~$mid]$ 全都大于$a[j]$

$i$~$mid$有$mid-i+1$个数，$ans+=mid-i+1$然后$j++$

若$a[i]<=a[j]$，则$i++$

每次 $i$ 或$j$变化时，将数字存入~~复制粘贴~~数组里（入队的那个一定是更小的）

若 $i$ 或$j$没到边界，就把剩余部分堆进去好了

最后贴回来就能使数列有序

为什么这样计算的逆序对数是正确的：

根据第3点，我们有$a[i]>a[j]$，我们是枚举每个$a[j]$（它更小），求左段比它大的有多少个数（这里讨论‘‘一左一右’’的情况）

因为$a[j]$随着$j$的增加会越来越大，所以对$a[i]$的要求也会越来越大，$i$也会慢慢增加

这便是~~传说中的~~单调性，

根据$while$条件，最后会剩下左边末尾一截或右边末尾一截

这时无需统计

剩下左边末尾一截：我们枚举的是$a[j]$，$j$都没了（过了$r$）。。。

剩下右边末尾一截：此时$a[j]$比所有$a[i]$大，就没有逆序对了

5. 不断分治，不断合并，复杂度$O($巨大常数$+NlogN)$的归并排序出~~锅~~炉了

## ~~这只是前置芝士，如果你嫌麻烦，谁叫你不看上面提示~~

### 正题（滑稽）

注意开高精或者__int128

对于每一个逆序对$(a[i],a[j])$

他们会被$i*(n-j+1)$个区间扫到（左边延伸，右边延伸~）

我们继续用归并排序做

只不过，代码有些改动

```cpp
#include<cstdio>
using namespace std;
typedef __int128 ll;
struct node
{
    ll z,p;
}a[1000005],mmp[1000005];
void swap(node &x,node &y){node t=x;x=y;y=t;}
ll read()
{
    ll s=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){s=(s<<3)+(s<<1)+c-'0';c=getchar();}
    return s*f;
}
void write(ll x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
ll n;
ll ans=0;
void msort(ll l,ll r)
{
    if(l>=r)return ;
    if(r-l==1)
    {
        if(a[l].z>a[r].z){ans+=(n-a[r].p+1)*a[l].p;swap(a[l],a[r]);}
        return ;
    }//个人习惯，可以去掉
    ll mid=(l+r)>>1;
    msort(l,mid);msort(mid+1,r);
    ll i=l,j=mid+1,len=l-1,sum=0;
    bool bk=false;
    while(i<=mid&&j<=r)
    {
        if(a[i].z>a[j].z)
        {
        	sum+=(n-a[j].p+1);
            if(!bk)ans+=a[i].p*sum;
            else ans+=a[i].p*(n-a[j].p+1);
            mmp[++len]=a[j++];
            bk=true;
        }
        else
        {
            if(!bk)ans+=a[i].p*sum;
            mmp[++len]=a[i++];
            bk=false;
        }
    }
    while(i<=mid)
    {
        mmp[++len]=a[i++];
        if(i<=mid)ans+=a[i].p*sum;
    }
    while(j<=r)mmp[++len]=a[j++];
    for(ll i=l,j=l;i<=r;i++,j++)a[i]=mmp[j];
}
int main()
{
    n=read();
    ans=0;
    for(ll i=1;i<=n;i++)
    {
        a[i].z=read();
        a[i].p=i;
    }
    msort(1,n);
    write(ans);puts("");
    return 0;
}
```
这次枚举的是$a[i]$，如果枚举$a[j]$，那么原来的$ans+=mid-i+1$操作会变得麻烦

枚举$a[i]$就能正序运行了

运用前缀和思想，$bk$是防止重复统计

### 至此，完结撒$huaji$~

---

## 作者：greenheadstrange (赞：0)

一组逆序对(a[i],a[j]) 贡献了 i*(n-j+1)次

考虑树状数组求逆序对，先离散化，只是加入的时候加入n-i+1，累计求和的时候乘上i就行了

注意这道题会爆long long,用高精度就好

```cpp
#include<bits/stdc++.h>
using namespace std;
struct note{
    int id,x;
}a[1000005];
bool cmp(note ax,note bx){return ax.x==bx.x?ax.id<bx.id:ax.x<bx.x;}
int n,b[1000005],d[1005],ans[1005];
unsigned long long s,c[1000005];
inline long long read(){
   long long s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
//////////////高精度 
void jia(){
    memset(d,0,sizeof(d));
    while(s>0){
        d[++d[0]]=s%10;
        s/=10;
    }
    if(ans[0]<d[0])ans[0]=d[0];
    for(int i=1;i<=ans[0];i++)ans[i]+=d[i];
    for(int i=1;i<=ans[0];i++){ans[i+1]+=ans[i]/10;ans[i]=ans[i]%10;}
    if(ans[ans[0]+1]>0)ans[0]++;
}
void out(){if(ans[0]==0)cout<<0;for(int i=ans[0];i>=1;i--)cout<<ans[i];}
//////////////

//////////////树状数组 
inline int lowbit(int x){return x&(-x);}
void Add(int x,int k){for(register int i=x;i<=n;i+=lowbit(i))c[i]+=k;}
long long Sum(int x){long long Ans=0;for(register int i=x;i>0;i-=lowbit(i))Ans+=c[i];return Ans;}
//////////////

int main(){
    ans[0]=1;
    n=read();
    for(register int i=1;i<=n;i++)a[i].x=read(),a[i].id=i;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)b[a[i].id]=i;//离散化 
    for(register long long i=n;i>=1;i--){
        s=Sum(b[i]-1)*i;
        jia();s=0;
//		cout<<ans<<'\n';
//		cout<<a[i].id<<" "<<a[i].x<<" "<<b[i]<<"\n";
        Add(b[i],n-i+1);
    }
    out();
    return 0;
}
```


---


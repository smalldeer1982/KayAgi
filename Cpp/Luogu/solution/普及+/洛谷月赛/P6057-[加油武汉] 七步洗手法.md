# [加油武汉] 七步洗手法

## 题目背景

现在正处于疫情防控的关键时期，大家要经常洗手，防止接触感染。

[正确的洗手方法](https://dxy.com/column/4473)

## 题目描述

给定一张含有 $n$ 个点的无向完全图，其中 $m$ 条边是白边，其余是黑边。

现在需要你求出同色的三元环（或者说，三角形）的个数。

## 说明/提示

 - 对于 $20\%$ 的数据，满足 $n \leq 200$；
 - 对于 $50\%$ 的数据，满足 $n \leq 2000$；
 - 对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^5,1 \leq m \leq 3\times 10^5$。

## 样例 #1

### 输入

```
5 3
1 5
2 5
3 5```

### 输出

```
4```

# 题解

## 作者：未见堇开 (赞：28)

$2020-2-10\; \mathrm {Ver.}$

补集转化思想经典题目，值得一做。

~~也正是因此，我一直以为洛谷早就有这道题了。~~

暴力枚举求同色三角形的算法时间复杂度为$O(n^{3})$，看上去已经无法再优化。那么，我们能否将同色三角形的数目换成一个可以更快求得的量呢？

可以看出，同色三角形数目$=$三角形数目-异色三角形数目，而三角形数目为$\binom {n} {3}$，可以$\mathrm {O}(1)$求出。

考虑如何求异色三角形数目。

定义两边颜色不同的角为异色角。显然每个异色三角形中有两个异色角，且所有异色三角形的异色角都**不属于**其他异色三角形。

对每个点统计异色角的数目，再除以$2$即为异色三角形的数目。

时间复杂度$\Theta (n)$，可以通过此题。

答案是$O(n^{3})$级别的，别忘了开`long long`！

代码：
```cpp
#include<cstdio>
#define reg register
#define MAXN 100001
using namespace std;

typedef long long ll;

int deg[MAXN];
ll ans=0;
int n,m;

int main()
{
    scanf("%d %d",&n,&m);
    for(reg int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d %d",&u,&v);
        ++deg[u],++deg[v];
    }
    for(reg int i=1;i<=n;i++)
        ans+=(1ll*deg[i]*(n-1-deg[i]));
    printf("%lld",1ll*n*(n-1)*(n-2)/6-(ans>>1));
    return(0);
}
```

---

## 作者：_Freedom_ (赞：16)

# Updated on 2024.3.4：对白色同色三元环进行了补充讨论

（因为之前不知道什么是自环（大雾



## 思路大致分为 3 步：数，删，补

### Step1. 数一个 n 个节点的无向完全图中的三元环个数
我们这里以 $n=5$ 为例

如图，对于 $1$ 号节点，我们可以在 $2$ ~ $5$ 号中任选两个组成一个三元环（图中选取了 $2,3$ 和 $2,4$ 与 $1$ 组成三元环）

![](https://cdn.luogu.com.cn/upload/image_hosting/kwt8b0u7.png)

那么 $1$ 号节点可以组成多少个三元环呢？

喜闻乐见的小学数学，$4$ 选 $2$ 组合，共有 $3+2+1=6$ 种

之后的节点操作也与 $1$ 号类似，唯一的不同点是只能在之后的节点中找，不能往前找，因为这样会找重复（如 $2$ 只能在 $3,4,5$ 中选 $2$ 个来组合，而不能再找 $1$）

那么这样我们就得出，$5$ 个点的无向完全图共有三元环数目为：

$1+2+3+$

$1+2+$

$1$

$=10$

### 那么我们推广到n个点的情况，即：
# $\sum\limits_{i=1}^{n-2} (n-1-i)\times i$
------------
### Step2.将异色的三元环删除
由于白边数量最大为 $m=3\times10^5$ ，而黑边数量最大为 $\frac{n(n-1)}{2}\approx 10^{10} $ 。因此可以粗略认为，**白边数量是可以忽略不记的**。

因此，对于单条的白边，我们不妨先减去所有包含这个白边的三元环，它们**几乎**都是异色的（因为剩下的两条边**几乎**全部都是黑色，与这条白边构成的三元环都是异色的）。

如图，对于每一条白边（图中以 $34$ 为例），它自己占了 $2$ 个点，那就只剩下 $(n-2)$ 个点与它组成三元环，所以每条白边都会组成 $(n-2)$ 个三元环

![](https://cdn.luogu.com.cn/upload/image_hosting/nebuk04r.png)

因为总共有 m 条白边，所以我们将总数减去 $m\times(n-2)$ ，剩下的就**几乎**都是同色三元环了。

------------
### Step3.将Step2中多减的三元环加回来

我们再次考虑一下 Step2 ，Step2 中有许多“**几乎**”，我们要对这些“**几乎**”进行一个修正。

如图，如果有 $2$ 条白边**交于一点**，那么它们所夹的那个三元环就会被减了 $2$ 次（图中 $23$, $34$ 为白边，那么三元环 $234$ 就被减了 $2$ 次）

![](https://cdn.luogu.com.cn/upload/image_hosting/ryccez73.png)

接下来分两种情况：

1. $24$ 边为黑边：则 $234$ 三元环为异色三元环，应该被减去一次，但是由于有两条白边，所以被减去了两次，多减了一次，要加回来一次。
1. $24$ 边为白边：则 $234$ 三元环为同色三元环，应该保留（减去零次），但是由于有三条白边，所以被减去了三次，多减了三次，要加回来三次。

稍加观察可以发现，情况一：有两条白边相交于**一**点，要加回来**一**次，情况二：有三条白边相交于**三**点，要加回来**三**次。发现相交的白边数量总是等于我们要加回来的三元环数量，总结为如下结论：

### 结论：若有两条白边交于一点，则会多减一个三元环（即需要加回一个三元环）

Step3 具体操作见代码：


（思路主要是将白边一条条加入，加入的时候先计算这条白边和在它之前加入的白边相交的次数，再将这条白边加入，防止算重复）

```cpp
long long a[100010];//a[i]记录有多少条白边连在节点i上 
	
for(i=1; i<=m; i++) {
	scanf("%d%d",&u,&v);
	ans+=a[u]+a[v];//a[u]+a[v]即为当前与这条交于一点的白边数 
	a[u]++;//u,v节点都多连了一条白边 
	a[v]++;
}
```
------------
~~本人月赛时的码的弱鸡~~ac代码，应该已经很好懂了吧：
```cpp
# include <iostream>
# include <cstdio>
# define ll long long
using namespace std;
ll a[100010];
int main() {
	
	ll n,m,i,u,v,ans=0;//记得开long long 

	scanf("%lld%lld",&n,&m);

	for(i=1; i<=n-2; i++) ans+=(n-1-i)*i;//Step1 

	ans-=(n-2)*m;//Step2 

	for(i=1; i<=m; i++) {//Step3 
		scanf("%lld%lld",&u,&v);
		ans+=a[u]+a[v];
		a[u]++;
		a[v]++;
	}

	printf("%lld",ans);
	//时间复杂度O(n+m)
	return 0;
}
```
# THANKS FOR READING!

最后不要忘了

# 武汉加油！中国加油！

---

## 作者：Star_Wind (赞：6)

话说这题为啥撞题了

蒟蒻一脸懵逼

**开场吐槽：**

和div2差不多难？第一题就是绿的你告诉我和div2差不多难？

emmm

                     -----华丽的分割线-------


**同色三元环？不认识？**

就是让你求这个图里面有几个三条边是同色的三角形

**怎么求？**

1 $O(nm)$ 暴力,然鹅T了

2 ~~数学法~~（逃）

同色三角形其实难算，那么我们可以算异色三角形，用三角形的总个数减去它的一半

如果一个点可以连出白色边$x$条就可以连出黑色边$n-x-1$条

所以不同色三角形的个数就是$x*(n-1-x)$

用一个vector存储白色边上点的信息

之后1-n枚举，套上公式：

```
sum+=(v[i].size()*(n-v[i].size()-1));
```

 n个点可以构成的三角形个数就是 
 
 ### $C^n_3$
 
它的值就是$n*(n-1)*(n-2)/(1*2*3)$

再减去sum的一半即可

AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<int> v[300023];
int n,m,a,b;
ll sum;
int main()
{
	cin>>n>>m;
	for(register int i=1;i<=m;i++)
	{
		scanf("%d%d",&a,&b);
		v[a].push_back(b);
		v[b].push_back(a);
	}
	for(register int i=1;i<=n;i++)
	  sum+=(v[i].size()*(n-v[i].size()-1));
	cout<<(ll)n*(n-1)*(n-2)/6-sum/2;
	return 0;
}
```

最后提醒

**三年OI一场空，不开longlong见祖宗**

完 结 撒 花 （逃）

---

## 作者：Fairicle (赞：3)

P5928它死了，所以题解也GG了。

思路：总方案就是所有三元环的数量，在 $n$ 个点中任取 $3$ 个点，也就是 $C_n^3$ 个三元环。

接下来考虑不合法的方案数： 计端点 $i$ 连了 $white_i$ 条白边，则它连了 $(n-white_i-1)$ 条黑边（图是完全图），则一个这样的端点能构成 $white_i$ $*$ $(n-white_i-1)$ 个不合法三元环，又可知一个不合法三元环被两个端点计算过，所以要除以二。

那么答案就是 $C_n^3$  $-$ $\frac{1}{2} \sum\limits_{i=1}^n{white_i*(n-white_i-1)}$

code：
```cpp
    ll all = n * ( n - 1 ) / 2 * ( n - 2 ) / 3;
    ll illegal = 0;
    for(register int i=1;i<=n;++i)
    {
        illegal += white[i] * ( n - white[i] - 1);
    }
    cout<<all-(illegal/2);
```


---

## 作者：Skyjoy (赞：3)

# 月赛题终于可以发题解了！

这题看上去是绿题，其实并不难。

这道题其实就是算出三角形总数，再减去不符合的，就可以了。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,cnt,e[100010],u,v;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		e[u]++,e[v]++;
	}
	ans=n*(n-1)*(n-2)/6;
	for(int i=1;i<=n;i++){
		cnt+=e[i]*(n-e[i]-1);
	}
	printf("%d",ans-cnt/2);
	return 0;
}
```
你高兴地将代码交上去，什么只有21分？全$WA$了？

>十年$OI$一场空，不开$long\ long$见祖宗。

## 这题因为$ans$是$n^3$级别的，$int$会爆！！！

# AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans,cnt,e[100010],u,v;
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&u,&v);
		e[u]++,e[v]++;
	}
	ans=n*(n-1)*(n-2)/6;
	for(int i=1;i<=n;i++){
		cnt+=e[i]*(n-e[i]-1);
	}
	ans-=cnt/2;
	printf("%lld",ans);
	return 0;
}
```
武汉加油，中国加油！奥利给！！！

---

## 作者：一叶知秋。 (赞：1)

今天月赛一点开就是这种毒瘤题，真的不想活了啊啊啊啊啊

为什么要改题号啊啊啊啊

------------

言归正传，这道题思路非常~~毒瘤~~巧妙，写完以后就感觉~~难度Div.2我xx~~好神奇啊，不过确实不该放$T1$吧（可能我太菜了），~~又跑偏了~~

~~再次~~言归正传，看到题面与数据范围，觉得直接求肯定不行，转换为求不合法的个数可能好一些。

我们首先用白边建无向图（黑边太多了），所以，以下讨论的边都是白边

不合法的一共有两种：

$1$、有一条是白边：

所以枚举每一条白边，检查与它端点相邻的边有多少条也就是与它相邻的点有多少个

相邻的边数就等于度数

所以将所有边减去两端点度数和即可

但是这样是不是会少了呢？我们就需要加上这个图中三元环的个数（也就是三条白色边的三元环），这个应该很好理解，三元环就代表一条边的两端点连的是同一条边

求这个三元环等会儿再说（我就是先处理这个导致走上了不归路QAQ）

$2$、有两条是白边：

直接枚举端点，假如这个点的度数大于$1$就说明这个点连了超过$1$条白边，那就可以算贡献了，在这些边中选两条也就是$C_d^2$，$d$就是这个点的度数

但是可能有重复，可能这两条边对应的三元环的另一条边可能也是白边，多加了一些符合条件的进来了，就需要减去这个图中三元环的个数即可

然后三元环个数可以抵消，~~皆大欢喜！！！~~

然后贴上代码：

```
#include<cstdio>
#include<cctype>

#define maxn 111111
#define maxm 333333

inline int read(){
	int r=0;
	char c;
	while(!isdigit(c=getchar()));
	while(isdigit(c))r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r;
}

int n,m,rd[maxn];

int u[maxm],v[maxm];

long long ans;

int main(){
	n=read(),m=read();
	ans=1ll*n*(n-1)/2*(n-2)/3;//Cn3，也就是这个完全图中所有三元环个数
	for(int i=1;i<=m;i++){
		u[i]=read(),v[i]=read();
		rd[u[i]]++,rd[v[i]]++;
	}
	for(int i=1;i<=m;i++){
		int x=u[i],y=v[i];
		ans-=n-(rd[x]+rd[y]);//两端点度数之和
	}
	for(int i=1;i<=n;i++){
		if(rd[i]<=1)continue;
		ans-=1ll*rd[i]*(rd[i]-1)/2;//Cd2
	}
	printf("%lld",ans);
	return 0;
}
```

---


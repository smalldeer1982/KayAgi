# 『MdOI R4』Kotori

## 题目背景

『「因为」？所以呢？』

『因为我是你的妹妹，所以你要叫我别阻止你胡来么？』

『因为我是你的妹妹，所以你要叫我看着你赴死么？』

『因为我是你的妹妹，所以你要叫我默默看着你可能被杀死么？』

『不要开玩笑了，这算什么啊！还以为好不容易和平下来了，还以为士道终于不用再受伤了。』

『我——我不希望士道死掉，不想再看到士道受伤了，已经受不了再让士道感到痛苦了啊……』

『因为我——』

『喜欢士道呀——』

![](https://cdn.luogu.com.cn/upload/image_hosting/s0f5nxk0.png)

## 题目描述

一年一度的世界最萌大会开始了。作为曾经的「萌王」，Kotori 自然无需参赛。但她希望帮助自己的哥哥  Shido 获得「燃王」的头衔。

本届 ISML 共有 $n=2^k$ 名参赛选手，编号为 $1,2\ldots n$，其中 Shido 的编号是 $1$，赛制为淘汰赛。每一轮比赛之后剩余选手中编号最小的两人为对手，编号第 $3,4$ 小的两人为对手，依次类推。每场比赛的胜负取决于粉丝的投票数，获得票数较多的一方晋级下一轮比赛，票数较少的一方淘汰。

例如共有 $4$ 名选手，则第一轮编号为 $1,2$ 的选手进行一场比赛，编号 $3,4$ 的选手进行一场比赛，然后两场比赛的胜者进行一场比赛，争夺总冠军。获得总冠军的选手将获得「燃王」头衔。

每个角色有一个厨团，$i$ 号选手的厨团人数为 $a_i$。每轮投票时，所有厨团的成员**会且仅会**为对应的选手投票。

此外，Kotori 拥有一个人数为 $m$ 人的团队，他们会永远跟随 Kotori 投票。也就是说，每场比赛 Kotori 都可以为对战双方的任意一者增加 $m$ 张得票。注意在一轮比赛中可能有多场比赛，每场比赛一定只有两名选手。

另外，Kotori 还拥有一项特权：当某场比赛双方的票数相同时，作为萌王的她可以决定这场比赛的胜者。

现在，Kotori 希望知道，她是否有能力帮助哥哥成为冠军，获得「燃王」的头衔。

## 说明/提示

【样例解释 #1】

对于 $1$ 组数据，并不存在让 Shido 成为燃王的方案。

对于第 $2$ 组数据，考虑以下方案：

第 $1$ 轮：
- $1$ 号和 $2$ 号比赛，把票给 $1$ 号，$2$ 号淘汰。
- $3$ 号和 $4$ 号比赛，把票给 $3$ 号，$4$ 号淘汰。
- $5$ 号和 $6$ 号比赛，把票给 $6$ 号，$5$ 号淘汰。
- $7$ 号和 $8$ 号比赛，把票给 $7$ 号，$7$ 号淘汰。

第 $2$ 轮：
- $1$ 号和 $3$ 号比赛，把票给 $1$ 号，$3$ 号淘汰。
- $6$ 号和 $8$ 号比赛，把票给 $6$ 号，$8$ 号淘汰。

第 $3$ 轮：
- $1$ 号和 $6$ 号比赛，把票给 $1$ 号，$6$ 号淘汰。

【数据规模与约定】

**本题采用捆绑测试**

| 子任务编号 | $k\le$    |$\sum n\le$ | $m\le $    | 分值  |
| -----|------ | ---------- | ---------- | ----- |
| $1$        | $0$  |$1$      | 无特殊限制 | $1$   |
| $2$        | $1$     |$2^{11}$   | 无特殊限制 | $9$   |
| $3$        | $4$  |$2^{14} $     | 无特殊限制 | $15$  |
| $4$        | 无特殊限制 |$2^{20}$| $0$        | $10 $ |
| $5$        | $9$   |   $2^{11}$| 无特殊限制 | $20$  |
| $6$        | $15$   |$2^{17}$    | 无特殊限制 | $20$  |
| $7$        | $18$   |$2^{20} $   | 无特殊限制 | $25$  |

对于 $100\%$ 的数据，$\sum n\le 2^{20}$，$0\le k\le 18$，$0\le m,a_i\le 10^9$。

【提示与帮助】

本题读入量较大，请选手选择较快的读入方式。

本题中的“世界最萌大会”与真正的“世界最萌大会”有所不同，在本题中请以本题为准。

## 样例 #1

### 输入

```
3
3 6
2 0 0 5 0 9 0 9
3 6
2 0 5 0 0 5 0 9
2 6
2 0 0 5
```

### 输出

```
Yoshino
Kotori
Kotori
```

# 题解

## 作者：yummy (赞：22)

## C 题的贪心和 Hack 方法

这题是 BF 姐姐出的，但是样例是我提供的。另外，$20050909$ 不是我的生日 qwq。

BF 姐姐讲了正解，那么我就作为验题人 & 数据制造者讲讲这题的几种贪心和对应的 Hack 方法。

**本文不讲正解，如果想看正解请移步其他题解（如[BF的官方题解](https://www.luogu.com.cn/blog/bfqaq/solution-p7339)）。**

**如果你想看题解区分治做法的时间复杂度说明，请跳转到“对于一个区间求不小于指定数的最大值”。**

如果还有错误的代码没有 Hack 成功，请大家评论区补充，共同进步。

**写这篇博客是为了帮助你更好地出题 or 造数据，而非让你在这题面向数据编程。**

## 只留下最小

代号：`greedy`。

做法：任意一场比赛中，如果其中一个是 $1$ 号，或者这个人比较菜，那么尽量让 TA 获胜。

实际上，样例第 2 组数据已经把一组 Hack 构造出来了，我们要做的就是**批量构造**这种数据。

观察这种做法错误的原因是，如果我们某一轮选择了比较菜的选手，那么有可能这个选手下一轮会败给对方，导致接下来比赛中 $1$ 号面对的选手反而更强。

所以我们就有了一个基本模型：$a$ 票的同学和 $b$ 票同学先PK，胜者和 $c$ PK，胜者再和 $1$ 号PK。

其中 $a,b$ 在第一场中都有可能获胜。为了卡掉贪心，$a$ 必然输给 $c$，$b< c\le b+m$。

若你在第一场中让 $a$ 获胜，那么最终 $1$ 号的对手就是 $c$，否则是 $b$。故 $1$ 的人气要可以打败 $b$ 而无法打败 $c$。

聪明的谷民们可能会想着 $k\le 4$ 则暴算，否则贪心。所以我们需要包装这个模型，把树做大。

我们可以选择向下延伸或向上延伸。yummy 选择了向下，也就是保证 $1$ 号，$a,b,c$ 对应的子树中，我们安排的几个人必然可以获胜。一种简单粗暴的方法就是让这几棵子树的其他选手都打不过TA。

## 只留下最小和最大

代号：`minmax`。

做法：对于任意一棵子树，只留下可能的最菜选手（保护 $1$ 号）和可能的最强选手（震慑对方）。

这种方法确实过了样例，且比 `greedy` 强，但是对于更大的数据范围，它并不一定是正确的。

我们的正解，等价于（虽然复杂度不同）对于每棵子树，把那些不能打的去掉之后取最小的。如果只保留最小最大，那么能保证不能打的都去掉了，但是不保证最大的一定是能打的里面最小的。

也就是，如果一棵子树里有至少两个能打的，这种方法就会出错。

为了避免随机化，只构造一个关键抉择是不够的，所以要递归自动生成关键抉择。

首先要生成带 $a_1$ 的全局，可以让 $a_1$ 在左 $2^{k-1}$ 人中胜出但是只打得过右 $2^{k-1}$ 人中第二名——也就是生成一个 $2^{k-1}$ 人的全局再生成一个 $2^{k-1}$ 人的右半边。

要生成 $2^{k}$ 人的右半边，可以让左半边留下的最菜选手比右半边最菜选手强 $m+1$ 淘汰右边最菜选手，也就是让基准提高 $m+1$ 后生成左半边，恢复再生成右半边。

注意：在递归出口时，如果这个分叉是专门打别人的，不要再生成一个最小值，因为这个最小值没人可以淘汰。

## 记录最小值和最大值

代号：`minmaxrev`。

做法：对于任意一棵子树，只记录最菜的选手和最强的选手，作为该子树的获胜者票数取值范围。

这种方法的问题在于，虽然这棵子树每个获胜者的票数都在取值范围内，但不是取值范围内每个数都可能被取到。

我们先构造一棵树使这棵树的可能获胜选手为 $\{a,b_{1,2,\ldots x}\}$，其中 $a+1< b_{\min}$ 且 $b$ 序列的极差为 $d$。

然后让这棵树和 $c$ 进行 PK，使得只有 $b$ 序列的选手和 $c$ 成为可能的获胜者，但是 $a+1$ 打得过 $c$。

接下来让胜者和 $1$ 号 PK，此时胜者票数最小值为 $b_{\min}$，但 $1$ 号只打得过 $a+1$。

右半边的递归方法和上一个 Hack 差不多，注意递归出口处悬空即可。

## 不大于 $a_1+m$ 求最大，否则求最小

代号：`a1m`。

这一种骗分很聪明，yummy 一时间都没有好的卡法。通过和 BF 姐姐的讨论，我们终于得到了一种Hack方法。

观察到 `minmax` 失效了，最关键的原因是关键选择的 $a,b\le a_1+m$，我们需要让一个选择的 $a,b>a_1+m$。

另一方面，这个选择必须影响到最终的结果——但是，间接影响也是影响啊。

所以，我们可以设一小常数 $p$，先和卡贪心类似地，$a,b$ PK后和 $c$ PK，此时 $b$ 获胜。

然后进行 $p$ 次 `packup`，第 $i$ 次让 $b-(i-1)m$ （也就是上回胜者）和 $b-im$ PK，第 $p$ 次的对手刚好是 $a_1$。

## 两边互相打得过就取较小值，否则让一边所有人和TA打

代号：`retry`。

这个骗分相当聪明，感谢 @银翼的魔术师 提供。个人认为有一定参考价值。

错误性写脸上了——一边所有人中不是每个都不会被淘汰。

因此怎么 Hack 也写脸上了——先构造一个会被淘汰的人，然后通过 `packup` 让两边实力差 $>m$ 触发枚举。

这样的话这个不合法的数据就会和对面打起来。我们只需要让这个不合法数据影响结论即可。

## 万能卡法

代号：`random`。

即使我们出题组想了这么多可能的错解，仍然有可能有漏网之鱼，怎么办呢？

我们可以缩小数据范围，提高数据组数，在组数足够多的情况下，我们可以把一定范围内的所有情况都枚举一遍。

所以，知道为什么我们不给 $T$ 的范围，只给 $\sum n$ 的范围了吗？就是因为可以搞一个 $T$ 很大而 $n$ 很小的数据点。

## 对于一个区间求不小于指定数的最大值

做法参考 [题解区某题解](https://ctcode.blog.luogu.org/Yukino)。这种方法被我注意到一开始是因为讨论区有人说自己样例没过却 AC。

讨论区的代码错误之处的 Hack 没有较高价值，但是该思想让 yummy 和 BF 都非常迷惑。

正确性没有问题，但是这个时间复杂度乍一眼看上去很像 $O(3^k)$。

yummy 一度想把这个代码卡满 $3^k$，但是多次尝试仍然只能做到 $k\cdot 2^k$。

通过半天的努力（真的半天哦），在“能卡掉”和“不能卡掉”之间反复横跳几次后，感性理解了复杂度。

**下面将不严谨地说明该代码最高复杂度为 $O(k\cdot 2^k)$，假掉了请评论区指出。**

记总用时为 $T(k,x)$（$T(0,x)=1$），左右半边中找 $\le x$ 的人用时分别为 $T_1(k-1,x),T_2(k-1,x)$。

我们有 $\max(T_1(k,x),T_2(k,x))\le T(k,x)$，因为 $T_1,T_2$ 受到了来自 $T$ 的约束，但祖先约束更弱。

a. 都能或不能找到 $\le x$ 的人，则 $T(k,x)=T_1(k-1,x)+T_2(k-1,x)\le 2T(k-1,x)$，$T(k,x)\le 2^k$。  
b. 否则不妨让左半边找得到 $\le x$ 的人，那么 $T(k,x)=T_1(k-1,x)+T_2(k-1,x)+T_2(k-1,r_1+m)$，其中 $r_1$ 为左半边的返回值，**不存在时为 $\inf$。**

对于情形 b，等号右边三个函数中，若有一个的结果为 $2^{k-1}$，则 $T(k,x)=2T(k-1,x)+2^{k-1}=O(k\cdot 2^k)$。

当 $r_1<x-m$ 时，可以得到左半边没有 $>x$ 的数，故 $T_1(k-1,x)=2^{k-1}$。

否则令右半边的左右两半中找 $\le x$ 的人的用时分别为 $T_3(k-2,x),T_4(k-2,x)$。

- 类似地，a 情形中 $T_2(k-1,x)=T_3(k-2,x)+T_4(k-2,x)\le 2T_2(k-2,x)$。
- 否则令 $T_3$ 为找到 $\le x$ 的半边，则 $T_2(k-1,x)=T_3(k-2,x)+T_4(k-2,x)+T_4(k-2,r_3+m)$。
- 若 $r_3<r_1$，那么第二次调用 $T_2$（记为 $T'_2)$ 时的 $T_3$（记为 $T'_3$）就因所有数都比 $r_1$ 小而 $=2^{k-2}$。
- 因此 $r'_3\ge r_1$。另一方面 $r'_4>r'_3+m$，故 $r'_2\ge r'_4>r_1+m$，和 $r'_2\le r_1+m$ 矛盾。

因此，对于情形 b，至少一个的结果为 $2^{k-1}$，从而总时间复杂度 $\le k\cdot 2^k$。

---

## 作者：BFqwq (赞：16)

# C.kotori

## Subtask 1

由于只有一个人，所以——士道一定是燃王！

于是只要输出 $T$ 个 $\texttt{kotori}$ 即可。

## Subtask 2

因为是两个人，所以只有一场比赛。

根据规则，如果 $a_1+m\ge a_2$，那么琴里就可以使士道获胜，此时输出 $\texttt{kotori}$；否则就代表琴里也无力回天，此时输出 $\texttt{Yoshino}$。

## Subtask 3

由于人数很少，因此我们可以直接考虑爆搜。

对于每场比赛，如果参赛双方都能获胜，则以双方获胜的情况分别搜一次；否则的话，只搜一次。

最坏情况复杂度 $\operatorname O(2^n)$，可以通过。

## Subtask 4

由于 $m=0$，所以我们没有任何支配权，只能按照原来的票数大小评胜负。

我们可以直接考虑模拟，求出每场比赛的胜者。

这里我们可以采用递归的方式，每次折半，然后找出两个半场的胜者，然后令他们两 PK。

注意如果比赛存在平票情况，那胜者可以任选；但如果此时有 $1$ 参加，那胜者必须为 $1$。

复杂度为直接递归的复杂度 $O(n)$。

## Subtask 5

回顾 Subtask 3，我们发现爆搜冗余的状态非常多。对于同一个人获胜，却可能存在着 $2^n$ 种之多的情况。

受到 Subtask 4 的启发，我们可以考虑递归。

我们求出每一个子区间的**所有可能的胜者**，并将其以某种方式存起来，然后考虑这个区间的胜者。

对于每个左子区间可能的胜者，如果它要成为最终的胜者，那我们需要在右子区间寻找一个它可以击败（相差小于等于 $m$）的对手。

我们枚举右子区间，逐个判断对应的选手能否被左子区间的这个选手击败，如果存在能击败的数则代表左子区间这个数可行，否则不可行。

依次合并即可。

## Subtask 6~7

上一个 subtask 的做法已经接近正解了，我们只需要考虑如何优化。

其实非常简单，既然要在右子区间击败一个选手，那我们肯定是挑最菜的来击败啦~

于是就考虑如何维护这个最菜（粉丝人数最少）的选手。

如果使用一个堆的话，我们可以以 $\operatorname O(n\log n\log n)$  的复杂度来解决。

但我们回忆起一个经典的分治模型：归并排序，发现其实我们可以直接按照归并排序的方式来进行合并。

每次删除最小的不满足条件的，然后对剩余的进行归并，可以得到复杂度 $\operatorname O(n\log n)$ 的解法。

事实上，由于区间的最大个数恒定，我们直接枚举区间内的值来找最小，复杂度同样为 $\operatorname O(n\log  n)$，可以通过本题。

当然，这里也可以使用一些可合并的数据结构，比如可并堆等，也可以以相同的复杂度通过。

方法很多，可以自行选择。

---

综合来说，这是一道比较水的题，放在 C 算是很送分了。

不过其实，这题很容易陷入的一个误区是直接考虑贪心。可惜大部分的贪心都是能够 hack 的，至少在赛前没有那位出题人拥有一个正确的贪心。

本题的主要考察点是分治思想，没有涉及到毒瘤的算法和长篇的代码。为良心的出题人点赞！

附一张琴里世萌冠军（萌王）的海报：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0jwgbo8.png)

---

## 作者：Caesium (赞：13)

# 分治+归并排序

## 题目大意
不难发现，本题中每个人的厨团就是他的实力，然后我们可以给两两 PK 的人其中之一加上 $M$ 的实力值。

## 题目分析
首先，我们很容易发现这题不存在一个贪心策略(但是可以用随机化贪心乱搞），目前无法证明任何一个贪心策略的正确性。
所以，按照最暴力的解法（暴力解法往往是正确的）本题应该将所有可以赢的情况枚举一次，最后把所有最后可以赢的人存起来看有没有 Shido。

可是，这题有 $ 2^{18} \times 10 $ 的数据，肯定不能用简单的 $ 2^n$ 枚举过，考虑优化。\
因为这题给的数据都是 $ 2^n $ 级别的，并且我们发现，这题求解的问题是可分割，可合并的，比如一个 $2^k$ 的区间内，所有胜者就是左边的可能胜者加右边的可能胜者，可以我们可以很自然想到用 `分治` 的策略来递归求解。
### 分治是什么

首先简单介绍一下分治，如果会了可以直接跳过这一段。

`分治`，即分而治之，就是把问题分割成子问题，再把子问题分割成孙子问题（此处略去 $ logn$ 次），
最后分割成一个不可分的子问题（递归边界），然后再分别对这个子问题的解进行合并的过程。

通过以上的描述，不难发现分治与头递归（也就是先递归后处理）的相通性，在头递归中我们可以便捷地对问题进行分割
到达边界后返回，然后对于分割完的结果进行合并。

在思考分治问题的时候，我们要深入理解这种头递归的思想，在考虑如何合并的时候要预设我们合并的对象本身是已经具备最优性的（在前面的递归已经处理好了），然后对这个最优的子结构进行最优的合并从而得出解。

通过分治的定义，不难发现，想要使用分治，这个问题就必须得具备**可分性**，存在**分治边界**，**可合并性**，**最优子结构性**，**子问题不互相影响**等性质。这里面的很多性质都是我们的老朋友了，比如最优子结构性，这个在 `贪心算法` 与 `DP` 中也是适用的，但是这些算法不需要具备**可合并性**。另一方面，如果一个问题的子问题要重复计算，那么分治就会很浪费时间，而且合并也有可能会合并错，这时候就不应该选用分治，比如 [数字三角形问题](https://www.luogu.com.cn/problem/P1216) ，像这类题目如果分治会重复计算很多次，这时应该选用 `DP` 来求解。又，因为我们比较常用二分的分治，所以子问题不互相影响通常可以从题目的 $2^n$ 的数据中得到暗示，比如完全二叉树，比如比赛的晋级这类问题。

回到本题，我们可以把区间不断分割，最后的递归边界就是只剩一个人，这个人自己作为可能胜者，然后向上合并。每个区间内保存了这个区间内的可能胜者，注意一个区间内的可能胜者不一定是父区间内的可能胜者，需要经过合并时的判断操作。

那么换句话说，这个区间可以派这个人出战，那么只需要考虑这个人能否打的过右边派出的任何一个人，如果打得过说明这个人可能作为这个区间胜者。

可以暴力枚举右区间的人，不过太慢了，考虑对于每个人都只需要找出对面最小的那个人来比较，只要打得过对方最小的人就可以胜利，不过我们需要对双方都进行排序。排序考虑堆排或者快排都是 $nlogn$ 的复杂度，外加分治的  $log n$ 总复杂度是 $ O(nlog^2n) $ 。既然已经想到了分治，何不考虑分治排序呢？分治排序不仅可以辅助排序，还可以顺便把赢的算出来复杂度是 $ O(nlogn)$ ，至此，本题就做完了。

## 代码
实现细节，参见代码注释 (代码在 std 的基础上改的，原谅我懒得打（捂脸））

```cpp
#include<bits/stdc++.h> 
using namespace std;

inline int read()//快读
{
	register int x=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9')
    {
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
    { 
		x=(x<<1)+(x<<3)+ch-48;
		ch=getchar();
	}
	return x;
} 

const int maxn = 1<<18|5;//这里 |5 其实就是在 1<<18 的情况下加 5，因为 1<<18 后面一大块都是 0
int T,n,k,a[maxn],b[maxn],c[maxn];
//a 数组是实力数组；b 数组记录了赢家在 a 数组的下标，便于我们获取，也是我们归并的数组
//c 数组是归并排序的辅助数组

int merge(int l,int r)//这里是主归并，返回值是这里面有几个赢家
{
	if(l == r)//如果只有一个人，那么赢家肯定是自己
	{
		return 1;
	}
	int mid = (l+r)>>1;
	int tl = merge(l,mid)+l-1//左半边的归并，tl 是左半边的上界，所有赢家都储存在 [nl,tl] 中，(t1,n2)是无意义信息
	int tr = merge(mid+1,r)+mid;//同理，是 [nr,tr]
	int nl = l,nr = mid+1;//这里是访问下界
    
    //由于归并到此处的时候，左半边的有意义部分是有序的，所以从小到大来删除那些一定会输的就可以了
	if(a[b[nl]] < a[b[nr]])//如果左边的第一个小于右边的第一个，那么右边整块肯定都比左边大，右边就不需要比较了
	{                  //这个地方用小于号，因为等于的时候我们可以裁决，所以可能打得过
		while(nl <= tl && a[b[nl]] + k < a[b[nr]])//这里是为了删去那些打不过(右边最小的人)的人
		{
			nl++;
		}
	}
	else//同理，反之左边不需要比较
	{
		while(nr <= tr && a[b[nr]] + k < a[b[nl]])//更新到可以打得过
		{
			nr++;
		}
	}
	int top = l-1;//这里的top+1，也就是 l 是 c 数组的存放起点，因为后面都是 ++top 存的
	while(nr <= tr && nl <= tl)//这里是一个归并排序的过程
	{
		if(a[b[nl]]<a[b[nr]])
		{
			c[++top] = b[nl++];
		}
		else
		{ 
			c[++top] = b[nr++];
		}
	}
	while(nl<=tl)//把剩下还没有移过去的移过去
	{
		c[++top] = b[nl++];
	}
	while(nr<=tr)
	{
		c[++top] = b[nr++];
	}
	for(int i = l;i <= top;i++)//最后，把 c 数组的移动回来
	{
		b[i] = c[i];
	}
	return top-l+1;//这里是返回有多少个人赢了，两端都是闭区间长度要+1
}

int main()
{
	int T = read();
	while(T--)//主程序
    {
		n = 1<<read();
		k = read();
		for(int i = 1; i <= n; i++)
        {
			a[i] = read();
			b[i] = i;//这里的 b 数组原始状态下保存的都是自己
		}
		
		int t = merge(1,n);//t 是最后一次合并的上界，[1,t]中保存的就是所有可能赢的人
		
		bool flag = false;
		for(int i = 1; i <= t; i++)
		{
			if(b[i] == 1)//
			{
				puts("Kotori");
				flag = true;
				break;
			}
		}
		if(!flag)
        {
			puts("Yoshino");
		}
		
	}
	return 0;
}
```
### 后记

考试的时候想了两个小时的贪心，一直没做出来，考完试才做出来

为毒瘤出题者点赞！！！


---

## 作者：Warriors_Cat (赞：12)

[题面传送门](https://www.luogu.com.cn/problem/P7339)。

> 题意：有 $n=2^k$ 人，每人有 $a_i$ 张票。每次对局让第 $2i-1$ 名与第 $2i$ 名对决，票数多的人获胜，出题人有 $m$ 张票可以随意分配，问 $1$ 号是否能获胜。

来一篇代码量很小的题解，希望能帮到大家。

---

### $Solution:$

我们将每个人的编号记为 $0, 1, 2...n-1$，记对局分别为第 $0, 1, 2...k-1$ 次对局。

我们就可以定义 DP 状态 $f_{i, j}$，表示在第 $i$ 次对局中，$j$ 这个人是否能胜利。

考虑如何在已知 $f_{i, j}$ 的情况下，转移得到 $f_{i+1, j}$。

这里有一个很显然的结论：每次取所有可能的优胜者的时候，肯定取票数最少的那个最优，因为这对 $j$ 这个人更有利。

因此，我们可以枚举对局次数，然后对于每一个组（这里的组即指第 $1$ 到第 $2^i$ 个人，第 $2^i + 1$ 到第 $2\cdot 2^i$ 个人......第 $n-2^i+1$ 到第 $n$ 个人分别为一组），我们处理出所有可能的优胜者（即 $f_{i, j}=1$ 的）中票数最少的那个票数。接着，枚举每一个人，看一下她能不能战胜将要和她 PK 的组中的最劣的那一个。如果可以就代表 $f_{i+1, j}=1$，否则 $f_{i+1, j}=0$。

最后判断一下 $f_{k, 0}$ 是否为 $1$ 即可。

over，时间复杂度为 $O(Tk2^k)$，可以通过此题。

---

### $Code:$

代码实现的时候有个小 trick：对于组 `j`，和它要对决的组即为 `j^1`。

代码仅供参考。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define rep(i, x, y) for(int i = x; i <= y; ++i)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = (1 << 18) + 10, M = 25;
int n, k, m, a[N], d[N]; bool f[M][N];
inline void mian(){
	k = read(); m = read(); n = (1 << k);
	rep(i, 0, n - 1) a[i] = read();
	rep(i, 0, k) rep(j, 0, n - 1) f[i][j] = 0;
	rep(i, 0, n - 1) f[0][i] = 1;
	rep(i, 0, k - 1){
		int t = (1 << i);
		rep(j, 0, n / t - 1) d[j] = 0x7f7f7f7f;
		rep(j, 0, n / t - 1) rep(o, 0, t - 1){
			if(f[i][j * t + o]) d[j] = min(d[j], a[j * t + o]);
		}
		rep(j, 0, n / t - 1) rep(o, 0, t - 1){
			if(f[i][j * t + o] && a[j * t + o] + m >= d[j ^ 1]) f[i + 1][j * t + o] = 1;
		}
	}
	puts(f[k][0] ? "Kotori" : "Yoshino");
}
int main(){ int qwq = read(); while(qwq--) mian(); return 0; }
```


---

## 作者：Cyber_Tree (赞：7)

~~水博客太快乐了。。。~~

刚打完月赛，来水一发 T3 的题解。。。  
T3 有一定思维难度，但是如果理解了题意应该很快就可以想出来。。。  
本蒟蒻写的是分治，貌似大佬们都用了各种神仙算法。但本蒟蒻只想到了分治。显然复杂度不是最优的。。。   

以下是正文
------------

### 题意

为了让大家更好理解题目中世盟的比赛规则，我特意找来了今年萌王的赛程。（虽然题中是燃王但也差不多了。。。把第一位选手想成士道就好了。

![2020萌王.jpg](https://i.loli.net/2021/02/10/IaHVyvl8rFG5QWZ.jpg)
//恭喜雪之下雪乃以 $218$ 票的微弱优势战胜炮姐成为新一届萌王！！！   
看到这张图怎么也会想到分治、线段树之类的和二有关的东西吧。。

实际上就是淘汰赛制，题中也正是是这么描述的。  
一轮比赛包含一竖列中的多场比赛，一场比赛只有两个选手。

但是题中的世萌和现实中的世萌并不完全一样，因为萌王 Kotori 已经在暗中操纵了比赛。。。  
Kotori 可以在一轮比赛的每场比赛中给任意一位选手加上 $m$ 票，同时也可以决定平局时的胜负。  

### 思路
这样的话,为了让士道得到燃王，我们只需要保证一号选手每次对战的对手战力都小于等于 $a[1]+m$ 即可（可以等于，因为 Kotori 可以决定平局的胜负）。

接下来，我们观察士道的对手分别来自哪里：   
第一轮的对手显然是 $a[2]$；   
第二轮的对手来自区间 $[3,4]$；   
第三轮的对手来自区间 $[5,8]$；  
第四轮的对手来自区间 $[9,16]$；   
。。。  
第$n$轮的对手来自区间 $[2^{n-1}+1,2^{n}]$.

知道了每位对手的位置，就可以考虑直接枚举（或递归）找到每一个区间，再在区间内寻找：按照比赛规则，Kotori 能否为士道“安排”一个战力小于等于 $a[1]+m$ 的对手。

接下来就是重点了：
#### 如何找到这样的一位选手呢？

~~直接瞎搞。~~

我们可以考虑分治。  

假设要在区间 $[l,r]$ 内找一个战力小于等于$x$的选手，那么先在左子区间 $[l,mid]$ 和右子区间 $[mid+1,r]$ 内寻找小于等于 $x$ 的选手；  
若两个子区间内都能找到这样的选手，那么显然区间 $[l,r]$ 内可以找到小于等于 $x$ 的选手；  
若两个子区间都没有找到，那么显然区间 $[l,r]$ 内无法找到小于等于$x$的选手；   
若一个子区间内找到了小于等于 $x$ 的选手，而另一个子区间没有找到，那么设找到了的选手的战力是 $y$ ，然后在没有找到的区间内找小于等于$y+m$的选手，这样他就可以被 $y$ 
淘汰掉，区间 $[l,r]$ 内也就可以找到小于等于 $x$ 的选手。

代码如下：
```cpp
int del(int l,int r,int x){
	if(l==r) return a[l]<=x ? a[l] : 0;
	int mid=(l+r)>>1;
	int l1=del(l,mid,x),r1=del(mid+1,r,x);
	if(l1&&r1) return max(l1,r1);//两个子区间都可以找到
	if(!l1&&!r1) return 0;//两个子区间都找不到
	else if(!l1) l1=del(l,mid,r1+m);//只有一个子区间找到了
	else if(!r1) r1=del(mid+1,r,l1+m);
	if(!l1||!r1) return 0;
	else return min(l1,r1);
}
```
//码风丑陋大家不要在意。。。

最后再来整理一下思路：   
首先递归找到所有对手的区间；   
再在每个区间内分治，寻找小于等于 $a[1]+m$ 的选手；   
若每个区间都能找到，则输出 “Kotori”，否则输出 “Yoshino”。

思路非常简单，代码也非常好写，就是稍有一些思维难度。。。

### 代码

贴上Ac代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Max=(1<<20)+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int t;
int k,m;
int a[Max];
int del(int l,int r,int x){
	if(l==r) return a[l]<=x ? a[l] : 0;
	int mid=(l+r)>>1;
	int l1=del(l,mid,x),r1=del(mid+1,r,x);
	if(l1&&r1) return max(l1,r1);
	if(!l1&&!r1) return 0;
	else if(!l1) l1=del(l,mid,r1+m);
	else if(!r1) r1=del(mid+1,r,l1+m);
	if(!l1||!r1) return 0;
	else return min(l1,r1); 
}
bool che(int l,int r){
	if(l==r) return 1;
	int mid=(l+r)>>1;
	if(!che(l,mid)) return 0;
	int x=del(mid+1,r,a[1]+m);
	if(x) return 1;
	return 0;
}
int main(void){
	t=read();
	while(t--){
		k=read(),m=read();
		if(k==0){ printf("Kotori\n"); continue; } 
		for(int i=1;i<=(1<<k);++i){	a[i]=read();a[i]++; }
		if(che(1,(1<<k))) printf("Kotori\n");
		else printf("Yoshino\n");
	}
	return 0;
}
```



------------
### 关于贪心

乍一看这道题很容易陷入贪心的误区（我一开始也是这么想的）。  
巨佬 yummy 成功 hack 了所有我能想到的贪心，基本上也 hack 了此题的所有骗分方法。  
如果想知道自己是怎么被 hack 的，建议跳转至 [这篇博客](https://www.luogu.com.cn/blog/yummy-loves-114514/solution-p7339)。

### 关于复杂度

实不相瞒，本蒟蒻在构思代码时并没有细想复杂度的问题，只觉得大约是个 $O(nlogn)$ （即 $O(k*\ 2^{k})$），显然属于 $O$(能过) 的范围，于是就这么写了。  
写题解的时候，才发现不会证复杂度，于是就这么一直卡着。。。  
太弱了，一直也没证出来。。。   
直到后来巨佬 yummy 证出了复杂度。。。   
因此本题解中并没有代码复杂度的证明，想看复杂度证明建议跳转至 [还是这篇博客](https://www.luogu.com.cn/blog/yummy-loves-114514/solution-p7339)。

如有不足还请指出。

蒟蒻第一次提交题解，望管理大大通过。。。

//实不相瞒，月赛前一天鄙人正与一位巨佬彻夜谈论世盟。。。图也是那位巨佬提供的。。。

---

## 作者：wmy_goes_to_thu (赞：2)

倍增+dp。

首先，贪心肯定不对，也不能像神 lndjy 一样随机化乱搞，所以采用 dp。

容易发现，淘汰赛的一段区间肯定是 RMQ 预处理的一段，所以我们可以采用 $f_{i,j}$ 代表 $[i,i+2^j-1]$ 这段区间咋咋地咋咋地。好的，我菜，不会推方程，所以换一种思路。

用 $f_{i,j}$ 代表 $i$ 是否能在经过 $i$ 的长度为 $2^j$ 的 RMQ 区间胜出，这个按 $j$ 转移还是很容易的，只需要再预处理一个数组，表示一个 RMQ 区间最菜的胜者即可。然后发现 $j$ 可以被滚掉，就和简洁的代码写的差不多了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[270005],f[270005],c[270005];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int k,m;
		cin>>k>>m;
		int n=1<<k;
		for(register int i=1;i<=n;i++)scanf("%d",&a[i]),f[i]=1,c[i]=a[i];
		for(register int r=1;r<=k;r++)
		{
			for(register int i=1;i<=n;i++)
			{
				int nl=(i-1>>r<<r)+1,nr=nl+(1<<r)-1;
				int pl=(i-1>>r-1<<r-1)+1,pr=pl+(1<<r-1)-1;
				if(nl==pl)
				{
					if(a[i]+m<c[pr+1])f[i]=0;
				}
				else if(a[i]+m<c[nl])f[i]=0;
			}
			for(register int i=1;i<=n;i++)c[i]=INT_MAX;
			for(register int i=1;i<=n;i++)if(f[i])
				c[(i-1>>r<<r)+1]=min(c[(i-1>>r<<r)+1],a[i]);
		}
		if(f[1])puts("Kotori");
		else puts("Yoshino");
	}
	return 0;
}
```

---

## 作者：囧仙 (赞：2)

## 题目大意

> 有 $n=2^k$ 个人，编号为 $1,2,\cdots,n$ 。每个人固定拥有 $a_i$ 张票。   
> 现在进行 $k$ 轮比赛，每轮第 $(2\cdot i-1)$ 名和第 $(2\cdot i)$ 名选手进行比赛， 票数更多者可以获胜（如果一样多，你可以指定获胜者）。现在每场比赛你可以投 $m$ 张票给任何人。询问是否存在一种方案，使得 $1$ 号选手获胜。

## 题解

考虑一下比赛的过程。

能够发现，最后一场比赛，实际上是 $\left[1,\dfrac{n}{2}\right]$ 中的胜者与 $\left[\dfrac{n}{2}+1,n\right]$ 里的胜者比赛后的获胜者。同理可推，区间 $[l,r]$ 内最终的获胜者，应当是 $\left[l,\dfrac{l+r-1}{2}\right]$ 和 $\left[\dfrac{l+r+1}{2},r\right]$ 的两位获胜者比赛后的获胜者。

不妨设 $P(l,r,p)$ 表示在区间 $[l,r]$ 中， $p$ 能否成为获胜者。于是有：

$$P(l,r,p)=\begin{cases}
P\left(l,\frac{l+r-1}{2},p\right) \operatorname{and} \left(\bigoplus_{a_q\le a_p+m} P\left(\frac{l+r+1}{2},r,q\right)\right)  & \text{p 在左区间} \cr
P\left(\frac{l+r+1}{2},r,p\right) \operatorname{and} \left(\bigoplus_{a_q\le a_p+m} P\left(l,\frac{l+r-1}{2},q\right)\right)  & \text{p 在右区间}
\end{cases}$$

其中 $\bigoplus$ 为二进制“或”操作。

**理解**：从另外一半边挑选一个可能的胜者 $q$ ，在这场比赛中 $p$ 击败 $q$ ，成为区间 $[l,r]$ 的胜利者。

但是如果暴力计算 $P(l,r,1)$ ，它的复杂度会变得相当高。考虑如何一次性求出区间 $[l,r]$ 中**每个**人是否可能成为获胜者。下文中不妨设 $t=\dfrac{l+r-1}{2}$ 。 

事实上，假如我们求出了 $P(l,t,x)$ 以及 $P(t+1,r,x)$ ，并且我们对区间 $(l,t)$ 和 $(t+1,r)$ 内每个数字排个序，就能发现其中的单调性。考虑通过枚举找出 $[t+1,r]$ 中**最弱的可能获胜的**人（不妨设为 $o$ ），那么对于 $[l,t]$ 中任意一个人 $x$ ，如果满足 $a_x+m\ge a_o$ ，且 $P(l,t,x)=\text{true}$ ，就可能成为区间 $[l,t]$ 的胜利者。同理，我们能够计算出 $[t+1,r]$ 中谁可能成为区间 $[l,r]$ 的胜利者。

观察发现，我们可以逐层合并答案。

具体而言，我们可以首先得到 $P(1,1,x),P(2,2,x),\cdots,P(n,n,x)$ 的值。然后逐层合并，用 $P(1,1,x)$ 与 $P(2,2,x)$ 合并出 $P(1,2,x)$ ，用 $P(3,3,x)$ 与 $P(4,4,x)$ 合并出 $P(3,4,x)$ ……我们能够使用归并排序维护每一段的排序后的结果。

总复杂度为 $\mathcal O(Tn\log n)$ ，可以通过本题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(register int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(register int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
typedef unsigned int       u32;
typedef unsigned long long u64;
const int INF =2147483647;
const int MAXN=(1<<18)+3;
int k,m,W[MAXN],V[MAXN],I[MAXN],J[MAXN],t,n;
const int SIZ =1<<20;
char buf[SIZ],*p1,*p2;
inline char gtc(){
    if(p1==p2) p1=buf,p2=buf+fread(buf,1,SIZ,stdin); return *p1++;
}
inline int qread(){
    int c,ret;
    while((c=gtc())> '9'||c< '0');ret=c-'0';
    while((c=gtc())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret;
}
bool F[MAXN];
const int SI=sizeof(int);
int main(){
    dn(qread(),1,TT){
        bool f=true;
        k=qread(),m=qread(),n=1<<k; up(0,n-1,i) W[i]=qread(),I[i]=i,F[i]=true;
        up(1,k,i){
            up(0,(1<<k-i)-1,j){
                int l=(j<<i),r=l+(1<<i),w=l+r>>1,t1=l,t2=w,t=l;
                int p=w,q=l;
                up(w,r-1,o) if(F[I[o]]){p=W[o];break;}
                up(l,w-1,o) if(F[I[o]]){q=W[o];break;}
                up(l,w-1,o) F[I[o]]&=(W[o]+m>=p);
                up(w,r-1,o) F[I[o]]&=(W[o]+m>=q);
                if(!F[0]) {puts("Yoshino");goto no;}
                while(t1<w&&t2<r){
                    if(W[t1]<W[t2]) V[t]=W[t1],J[t++]=I[t1++];
                    else            V[t]=W[t2],J[t++]=I[t2++];
                }
                if(t1<w) memcpy(V+t,W+t1,SI*(w-t1)),memcpy(J+t,I+t1,SI*(w-t1));
                if(t2<r) memcpy(V+t,W+t2,SI*(r-t2)),memcpy(J+t,I+t2,SI*(r-t2));
            }
            memcpy(W,V,sizeof(int)*n);
            memcpy(I,J,sizeof(int)*n);
        }
        puts("Kotori"); no:;
    }
    return 0;
}
```

---

## 作者：E_M_T (赞：0)

简单分治。

考虑 $1$ 的胜利条件：

* 第一轮和 $2$ 打。
* 第二轮和 $[3,4]$ 获胜者打。
* 第三轮和 $[5,8]$ 获胜者打。
* 第 $i$ 轮和 $[2^{i-1}+1,2^i]$ 获胜者打。

所以 $1$ 的获胜条件是 $a_1+m$ 需要大于等于这些区间的获胜者。

换个说法，这些区间中的任意一个胜利者 $k$ 都必须要满足 $a_k\le a_1+m$。

发现这些区间贡献是独立的，考虑分治。

设 $\operatorname{solve}(l,r,x)$ 为 $l\sim r$ 中的获胜者中是否可能是 $\le x$ 的。

先递归查找 $[l,mid]$ 和 $[mid+1,r]$ 的答案。

* 若两个区间都有，则 $[l,r]$ 也有。
* 若两个区间都没有，则 $[l,r]$ 也没有。

若一个有一个没有怎么办？

分情况讨论，设有的区间那个获胜者是 $x$，则需要在另一个区间中查找是否有 $\le x+m$ 的获胜者，此时 $x$ 可以作为获胜者，否则不行。

所以考虑再返回一个参数 $x$ 代表这个区间的一个获胜者。

有可能一个区间内可以作为获胜者且 $\le x+m$ 的人有多个，此时为了最优就返回 $a$ 最大的。

注意 $\operatorname{solve}$ 不能查到的返回值应该是 $-1$，因为有可能 $a_i=0$。

```cpp
#include<bits/stdc++.h>
#define sd std::
#define int long long
#define il inline
#define db double
#define ldb long double
#define F(i,a,b) for(int i=(a);i<=(b);i++)
#define f(i,a,b) for(int i=(a);i>=(b);i--)
#define MIN(x,y) (x<y?x:y)
#define MAX(x,y) (x>y?x:y)
#define me(x,y) memset(x,y,sizeof x)
#define pii sd pair<int,int>
#define X first
#define Y second
#define kg putchar(' ')
#define Fr(a) for(auto it:a)
#define dbg(x) sd cout<<#x<<": "<<x<<sd endl
il int read(){int w=1,c=0;char ch=getchar();for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;for(;ch>='0'&&ch<='9';ch=getchar()) c=(c<<3)+(c<<1)+ch-48;return w*c;}
void printt(int x){if(x>9) printt(x/10);putchar(x%10+48);}
il void print(int x){if(x<0) putchar('-'),printt(-x);else printt(x);}
il void put(int x){print(x);putchar('\n');}
il void printk(int x){print(x);kg;}
const int N=1e6+10;
int k,m;
int a[N];
int solve(int l,int r,int x)//l~r区间内能否找到一个<=x的数 
{
	if(l==r) return a[l]<=x?a[l]:-1;
	int mid=l+r>>1;
	int ans1=solve(l,mid,x);
	int ans2=solve(mid+1,r,x);
	if(~ans1&&~ans2) return MAX(ans1,ans2);
	if(~ans1)
	{
		ans2=solve(mid+1,r,ans1+m);
		if(~ans2) return ans1;
	}
	else if(~ans2)
	{
		ans1=solve(l,mid,ans2+m);
		if(~ans1) return ans2;
	}
	return -1;
}
int po[100];
il void solve()
{
	k=read(),m=read();
	F(i,1,1<<k) a[i]=read();
	F(i,1,k)
	{
		if(!(~solve(po[i-1]+1,po[i],a[1]+m))) return puts("Yoshino"),void();
	}
	puts("Kotori");
}
signed main()
{
	po[0]=1;
	F(i,1,100) po[i]=po[i-1]*2;
	int T=1;
	T=read();
	while(T--) solve();
    return 0;
}
```

---

## 作者：water_tomato (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7339) [个人博客版本](https://www.watertomato.com/p7339-%e3%80%8emdoi-r4%e3%80%8fkotori-%e9%a2%98%e8%a7%a3/)

## 解析

题意就不多阐述了，看原题就够了。个人觉得这是一道练归并排序性质的好题（虽然动规/堆维护等方法似乎也可行，但我认为最朴素的方法才是最美丽的）。

再发觉贪心不可行时，我们考虑分治维护每一轮比赛可能获胜的人。假设我们以及维护好了左区间（即上一轮比赛）哪些人可能能在上一轮获得胜利（也就是能活到当前这轮）以及右区间的这个信息，我们考虑如何合并。显然，我们发现，如果想要让左区间的某个人获胜，只需要这个人能够击败右区间尚存的最弱的那个人就可以了，右区间亦然。

这时候我们考虑如何维护区间最弱的人这个信息。在分治这个大背景下，我们容易想到归并排序——每个区间在合并时都是有序的，只需要取出第一个数就是最小的。同时我们还可以在归并排序时每次返回改区间尚存的人数，这样，我们就一次性维护好了尚存的人和区间最弱的人这两个信息。

依次合并，最后判断尚存的人中是否有 $1$ 号选手即可。代码写了一些注释。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
struct node{
	int val,id;//记录每个元素的支持人数和序号，序号用来判结果
}a[N],b[N];
int T,k,m;
inline int merge(int l,int r){//返回该轮尚存的人数
	if(l==r) return 1;
	int mid=(l+r)>>1;
	int L=merge(l,mid)+l-1;//记录左区间尚存的人的位置
	int R=merge(mid+1,r)+mid;//同上
	int i=l,j=mid+1,cnt=l-1;
	if(a[i].val<=a[j].val){//第一个数比大小，显然，第一个数大的那边的所有尚存选手都可以继续存活
		while(i<=L&&a[i].val+m<a[j].val) i++;//因为 kotori 可以定胜负，所以用 < 号。
	}
	else{
		while(j<=R&&a[j].val+m<a[i].val) j++;
	}
	while(i<=L&&j<=R){//正常归并排序，就是左右区间的上界变了而已
		if(a[i].val<a[j].val) b[++cnt]=a[i++];
		else b[++cnt]=a[j++];
	}
	while(i<=L) b[++cnt]=a[i++];
	while(j<=R) b[++cnt]=a[j++];
	for(int i=l;i<=cnt;i++){//容易发现，每次归并了之后，只有前 cnt 个人是有效的，且他们有序
		a[i]=b[i];
	}
	return cnt-l+1;//返回该轮尚存的人数
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&k,&m);
		for(int i=1;i<=(1<<k);i++){
			scanf("%d",&a[i].val);
			a[i].id=i;
		}
		int ans=merge(1,1<<k);
		bool fl=false;
		for(int i=1;i<=ans;i++){
			if(a[i].id==1){//找一找 1 号选手是否或者即可
				printf("Kotori\n");
				fl=true;break;
			}
		}
		if(!fl) printf("Yoshino\n");
	}
	return 0;
}
```



---

## 作者：轻绘 (赞：0)

这是一道让我场上爆炸，场下崩溃的题。

~~虽然琴里真的很可爱~~

没有什么独特做法，主要借鉴之前几位大佬方法，加上部分个人理解，希望更好懂一些。

**分治**！！！

# 题意

给定一数列，进行淘汰赛。

（**即两两比较，较大者胜出，并参加下一场，直至决出唯一胜者**）

现有两个~~黑箱~~操作：

1. 在每一次比较中，可以给任意一个数加上 $m$ 再继续比较。

2. 对于加上 $m$ 后相等的两数可以由你决定谁胜出。

现问能否通过一系列操作使第一个数胜出。

# 解

~~关于贪心他死了~~

有一种暴力便是将所有最后获胜的情况求出，
若其中有第一个数获胜的情况及为可行输出 $Kotori$ ，否则不行输出 $Yoshino$ 。

现在我们再考虑如何让暴力变为正解。

我们考虑分治，对于两块已求出可能获胜者的赛区，将其中不能再战胜任何一人的人淘汰，因为他不论如何不可能获胜，再合并赛区，直至将所有赛区合并，得出所有可能的最终获胜者。

**说了一大通你可能没有听懂，那么见下图**

![样例第一组](https://cdn.luogu.com.cn/upload/image_hosting/gyl5hn5k.png?x-oss-process=image/resize,m_lfit,h_400,w_600)

最后可能获胜的是 $5$ 或 $9$ 所以不可能输出 $Yoshino$ 。

对于半决赛，左边是 $0,2,5$ 右边是 $9$ 要将两块赛区合并为最终结果

因为 

$0+6=6<9$ 

$2+6=8<9$

所以 $0$ 和 $2$ 都不可能获胜，任何情况下都不能战胜右边的任何一个数。

（右边任何情况下都是 $9$ 胜出参加半决赛）

因而最终获胜者中没有第一个数这一可能。

可能有些难懂~~但我已经尽力了~~对着样例多看几遍，一个字一个字看过去自然便悟了。

## 细节

然后简单的可以看出只要本赛区最小的数加上 $m$ 能大于另一赛区最小的数，那么本赛区所有数皆有可能晋级下一轮。（所以可能在一次合并中不淘汰任何一个数）

**难道还要排序？ 是的!**

**但是这种有序序列合并排序的东西让我们想到了什么？ 没错就是归并排序！**

在合并过程中顺带排序，这道题就可以$AC$了。

# 代码（带详解）

## 注意：$a,b$数组存的是编号即每个数值的位置

```
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
inline ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')	f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int t,k,n,m,tot;
int a[2000000],b[2000000],num;
int c[2000000];
inline int get(int l,int r){//该函数返回可能获胜人数量
	if(l==r){//当分治到一个数时，该数必定胜出
		a[l]=l;
		return 1;//有一个人可能获胜
	}
	int l1,r1,l2,r2,mid;//两赛区各自起点终点
	mid=(l+r)>>1;
	r1=get(l,mid)+l-1;//分治
 	r2=get(mid+1,r)+mid;
	num=l-1;//合并后大赛区起点
	l1=l,l2=mid+1;
	if(c[a[l1]]+m<=c[a[l2]])//若一赛区目前最小的无法战胜二赛区最小的则被淘汰
		while(l1<=r1 && c[a[l1]]+m<c[a[l2]])
			++l1;
	else
		while(l2<=r2 && c[a[l2]]+m<c[a[l1]])//同上
			++l2;
	while(l1<=r1 && l2<=r2){//将所有可能的获胜数归并排序
		if(c[a[l1]]<=c[a[l2]])	b[++num]=a[l1++];
		if(c[a[l2]]<c[a[l1]])	b[++num]=a[l2++];
	}
	while(l1<=r1)	b[++num]=a[l1++];
	while(l2<=r2)	b[++num]=a[l2++];
	for(int i=l;i<=num;i++)	a[i]=b[i];
	return num-l+1;
}
inline bool ask(){
	tot=get(1,n);//get出最终能获胜的可能数
	for(int i=1;i<=tot;i++)//遍历每一个可能
		if(a[i]==1) return true;//若有第一个数则可以
	return false;
}
int main(){
	t=read();
	while(t--){
		k=read();
		m=read();
		n=pow(2,k);//n为数列个数
		for(int i=1;i<=n;i++){
			c[i]=read();//c数组存具体大小
		}
		if(ask())	printf("Kotori\n");//询问能否让五河士道获胜
		else printf("Yoshino\n");
	}
	return 0;
}
```


---


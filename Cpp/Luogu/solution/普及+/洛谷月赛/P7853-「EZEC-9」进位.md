# 「EZEC-9」进位

## 题目背景

规定 $\text{popcount}(x)$ 表示 $x$ 在二进制表示下所含 $1$ 的个数。

## 题目描述

您有一个二进制数 $B$（以一个长为 $n$ 的 $01$ 字符串形式给出）和长为 $m$ 的序列 $a$。

同时，您还需要对 $B$ 进行 $m$ 次操作。

其中，第 $i$ 个操作为 $B \gets B + 2^{a_i}$，其价值 $v_i$ 为 $B$ 在操作前后变化的位置数量，即 $v_i = \operatorname{popcount}(B \mathbin{\mathrm{xor}} (B + 2^{a_i}))$。

您需要解决两个问题：

- 您可以**任意**安排操作顺序，问在执行**所有**操作后，$\displaystyle \sum_{i=1}^mv_i$ 最大为多少？

- 您可以**任意**安排操作顺序，问在执行**所有**操作后，$\displaystyle \max_{i=1}^mv_i$ 最大为多少？

## 说明/提示

**【样例解释 #1】**

对于第一问，依次执行第 $1,2,6,5,4,3$ 个操作可得到 $\displaystyle \sum\limits_{i=1}^mv_i=14$。

对于第二问，依次执行第 $6,5,4,3,1,2$ 个操作可得到 $\displaystyle \max\limits_{i=1}^mv_i=6$。

[详细过程](https://www.luogu.com.cn/paste/ycx4xov7)

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（20 points）：$n,m\leq 10$。
- Subtask 2（30 points）：$n,m\leq 1000$。
- Subtask 3（20 points）：$B$ 中全为 $0$，且 $a_1=0$，$\forall i>1, a_{i-1}\leq a_i\leq a_{i-1}+1$。
- Subtask 4（20 points）：$n,m\leq 10^5$。
- Subtask 5（10 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^6$，$0\leq a_i< n$。

## 样例 #1

### 输入

```
5 6
10110
1 0 2 2 2 2
```

### 输出

```
14
6
```

## 样例 #2

### 输入

```
10 10
0101010110
0 1 2 3 4 5 5 4 3 2
```

### 输出

```
21
9
```

## 样例 #3

### 输入

```
10 3
1111101111
5 5 0
```

### 输出

```
13
11
```

# 题解

## 作者：gyh20 (赞：15)

令"前"表示二进制数位值小的一边，"后"表示大的一边。

#### $\textrm{Subtask~1}$

可以 $m!$ 枚举，再检查答案。

#### $\textrm{Solution~1}$

对于第一问，我们有结论，无论顺序如何，答案不会改变。

证明可以按位考虑，对于第 $i$ 位，无论怎样操作，前 $i-1$ 位对之 $i$ 之后二进制的贡献都要经过第 $i$ 位进位，且每次进 $1$，所以第 $i$ 位的变化次数是固定的，直接模拟即可。

##### 复杂度证明

比较经典，令 $a_i$ 表示加在 $i$ 位置的操作个数，一个位置进位的次数 $f_i=\lfloor \frac{f_{i-1}}{2}\rfloor+a_i$，直接看作 $f_i=\frac{f_{i-1}}{2}+a_i$ 可以看出每个 $a_i$ 对答案的贡献是 $O(a_i)$ 量级的，所以直接模拟复杂度是 $O(n+m)$ 的。

#### $\textrm{Subtask~2,3}$

考虑枚举得到最大值的加操作，假设位置为 $x$，每次尽量让 $x$ 向后进位的多，即每一次能进位就进位，即从 $x$ 向后枚举，枚举到某一位时用上这一位所有加操作，判断最后能加到哪一位即可，时间复杂度 $O(n(n+m))$。

在 $\textrm{Subtask~3}$ 中，可以发现这个位置 $x$ 一定是最靠前的存在进位的位置，时间复杂度 $O(n+m)$。

#### $\textrm{Solution~2.1}$

基于对 $O(nm)$ 直接的优化，从后往前枚举 $x$，每次贪心进位，但是在位值为 $2$ 时不进位，等到位值为 $3$ 时变为 $1$，并进一次位，这样可以保证最后一次操作能进位尽量多，使用数据结构维护最长的连续非 $0$ 段，根据方法不同，使用性质多少可以做到 $O(n+m)\sim O(n+m\log^2 n)$ 不等，如果复杂度过高只能无法通过 $\textrm{Subtask~6}$。

[这里](https://www.luogu.com.cn/paste/kszj4oet)提供了一个 $O(n+m)$ 的并查集实现 。

#### $\textrm{Solution~2.2}$

在 $O(nm)$ 的基础上继续找性质，直接以任意顺序模拟整个操作，得到每个位置是否出现过进位，发现答案即为出现过的最长出现进位的连续段，最后一次加法可以看做加在这个连续段最前面的一个位置，然后依次影响了这些存在进位的位置，可以发现答案不可能更优，因为下一个位置不可能存在进位，简单来说，就是这是上界，但是可以取到的。

一些常见的错误可以见[这个帖子](https://www.luogu.com.cn/discuss/show/349842)。

```cpp
#include<cstdio>
char s[1000032];
int n,m,a[1000032],ans,len,x,ans1;
int main(){
	scanf("%d%d%s",&n,&m,s);
	for(int i=0;i<n;++i)s[i]-='0';n+=30;
	while(m--){
		scanf("%d",&x),++s[x],++ans1;
		while(s[x]>=2)a[x]=1,++s[x+1],s[x]-=2,++x,++ans1;
	}
	for(int i=0;i<n;++i)
		if(a[i]){++len;if(len>ans)ans=len;}
		else len=0;
	printf("%d\n%d",ans1,ans+1);
}
```


---

## 作者：nanzjz1 (赞：3)

## 题意简述
对于一个长为 $n$ 的二进制数 $B$，给出一个长为 $m$ 的序列 $a$ 表示 $m$ 次操作，每一个 $a_i$ 操作表示在 $B$ 的第 $a_i$ 位上加 $1$（自然也可能产生进位）。定义每一个操作的价值 $v_i$ 为 $a_i$ 操作后 $B$ 相比于操作前变化的位置的个数。可以任意指定这 $m$ 个操作的顺序。求：

1. 所有操作的价值之和的最大值；
2. 单次操作能够产生的最大价值。

## 第一问
价值之和的增加由 $B$ 每个数位变化导致，而二进制下只有两种情况，即 $0→1$（当前位变化，增加 $1$） 或 $1→2(0)$（当前位和下一位都变化，增加 $2$）。因此我们可以先不考虑进位，对于每一个操作都加上导致当前位变化的价值 $1$，最后再处理进位并计算贡献（当然也可以边处理操作边计算进位，两者是等效的）。

完成第一问可以拿到 $30$ 分。

代码如下（边进行操作边处理计算）：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[2000010], b[2000010];//使用数组b记录下二进制数B的每一位
int main()
{
    int n, m; scanf("%d %d\n", &n, &m);
    register int ans1 = 0;
    for (register int i = 0; i < n; ++i)
    {
        char cl = getchar();//小小的读入优化
        b[i] = (int)(cl - '0');
    }
    for (register int i = 1; i <= m; ++i)
    {
        scanf("%d", &a[i]);
    }
    for (register int i = 1; i <= m; ++i)
    {
        int pt = a[i];//pt指针表示当前处理到的位数
        ++b[pt];//进行操作
        ++ans1;//更新价值
        while (b[pt] == 2)
        {//处理进位
            b[pt++] = 0;
            ++b[pt]; ++ans1;
        }
    }
    printf("%d\n0",ans1);//根据题目要求，没有写第二问需要随便输一个数占位
    return 0;

```
## 第二问
我们很容易想到，如果要让一个操作的价值尽可能的大，那么就要让这个操作是把 $1$ 加上 $1$ 以产生进位，并让操作对应的那一位后的 $1$ 尽可能的多，即产生连续进位，类似于产生“连锁反应”。

而我们注意到，如果某一位的数字大于等于 $2$，那么就说明这一位上至少进行了一次 $1->2$ 的操作，而这个操作的价值就是以它为开始的进行“连锁反应”所能达到的最大长度。可以理解为，大于等于 $1$ 的数表示它能进行“连锁反应”，而 $0$则表示连锁反应到此处截断了。

因此，我们先对 $B$ 进行所有的操作，再从头搜索大于 $1$ 的值，搜索到了就开始进行进位直至无法再次进位，此时进位的次数加 $1$ 就是该次操作的最大价值，并且求该次操作的最大价值不会影响另外一个可能的最大价值。证明如下：

- 如果当前数为 $p$，可以连续进位的范围内存在一个数 $m(2<=m)$，且 $m$ 所在的位数 $x_m>x_p$，那么必然存在 $v_p>v_m$，因为 $p$ 所能产生的连续进位包括了 $m$ 所能产生的在内；
- 如果当前数为 $p$，可以连续进位的范围内不存在一个数 $m(2<=m)$，且 $m$ 所在的位数 $x_m>x_p$，那么计算 $v_{p_{max}}$ 的值不会影响计算 $v_{m_{max}}$ 的值，因为无论怎么从 $p$ 开始连续进位都无法影响到 $m$ 及其之后的数，自然也无法影响 $m$ 的连续进位。

于是我们只需要求出最大的 $v_{i_{max}}$ 即可。由于计算基于产生进位的前提，如果 $B$ 没有产生进位就不会触发计算，因为我们将初始的最大值设为 $1$，即没有任何进位时的价值。

下面是两问的完整代码：
```
#include <iostream>
#include <cstdio>
using namespace std;
int a[2000010], b[2000010], c[2000010]; //b用于计算第一问，c用于计算第二问
int main()
{
    int n, m, maxm = 1; scanf("%d %d\n", &n, &m);//maxm设为1而非0
    register int ans = 0;
    for (register int i = 0; i < n; ++i)
    {
        char gjr = getchar();
        b[i] = (int)(gjr - '0');
        c[i] = b[i];
    }
    for (register int i = 1; i <= m; ++i)
    {
        scanf("%d", &a[i]);
    }
    for (register int i = 1; i <= m; ++i)
    {
        int pt = a[i]; //pt指针表示当前处理到的位数
        ++b[pt];//进行操作
        ++c[pt];
        ++ans;//更新价值
        while (b[pt] == 2)
        {//处理进位
            b[pt++] = 0;
            ++b[pt]; ++ans;
        }
    }//此时已经对c处理完了所有操作
    for (register int i = 0; i < n; ++i)
    {
        if (c[i] >= 2)//处理大于2的进位
        {
            register int gjr = i, maxl = 1;//maxl是当前处理的连续进位的价值
            while (c[gjr] >= 2)//计算最大价值
            {
                ++maxl;//能够进位就加1
                c[gjr + 1] += c[gjr] / 2;//处理进位
                c[gjr++] &= 1;
            }
            maxm = max(maxl, maxm);
        }
    }
    printf("%d\n%d", ans, maxm);
    return 0;
}
```


---

## 作者：超级玛丽王子 (赞：1)

月赛时做这题居然比做 A 还快（

# Task 1

重要结论：**所有运算无论顺序如何，产生的进位总数是一样的**。

这是因为每一位都会被加固定的次数，所以每一位对进位的贡献是恒定的。

于是暴力模拟进位即可了，时间复杂度 $O(n)$；

# Task 2

Task 2 实际上比 Task 1 还要好想。

想要一次进位次数最多，就需要找到最长的一段 `1`。请注意，这一段 `1` 不只是原数里的，还要统计进行加法后可能变成 `1` 的。最后在 $O(n)$ 扫一遍的时候统计最长段就可以了。

细节见代码。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	int x=0;
	while(ch>='0'&&ch<='9') x=(x*10)+(ch^48),ch=getchar();
	return x;
}
inline void write(int x) {
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void wr(int x) {
	write(x);
	putchar('\n');
}
int n,a[2000005],b[2000005],m; //坑点：进位最多有可能把原数变成 2n 位，要开两倍；
int ans,mx=1,sum=0;
int main(void) {
	n=read(),m=read();
	for(int i=0;i<n;i++) scanf("%1d",a+i);
	for(int i=1;i<=m;i++) {
		int x=read();
		b[x]++;
	}
	for(int i=0;i<2*n;i++) //坑点：进位做出来的新位也要模拟
		if(b[i]) {
			ans+=b[i];
			if(i<n&&a[i]==1) b[i]++; //处理上一位的进位
			if(a[i]==1||b[i]>1) mx=max(mx,++sum+1);  //统计最长段。注意要加上 1 因为有一位 0 会被进成 1
			else sum=0; 
			b[i+1]+=b[i]/2; //进位
		}
		else sum=0;
	printf("%d\n%d\n",ans,mx);	
	return 0;
}


```

---


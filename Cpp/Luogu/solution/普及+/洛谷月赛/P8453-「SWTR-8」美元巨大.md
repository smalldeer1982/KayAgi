# 「SWTR-8」美元巨大

## 题目背景

#### 输出不允许有前导零。

原题目名称为「美元巨大二的二的二的二的二」。

小 A 喜欢用形如
$$
\Huge 2 ^ {2 ^ {2 ^ {2 ^ {2}}}}
$$
的幂塔把小 T 的博客炸掉。

## 题目描述

小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

表达式越大，越有可能炸掉小 T 的博客。小 A 希望 **从左往右** 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。

若存在多组构造方案，输出任意一组。

多组测试数据。

## 说明/提示

**「评分方式」**

对于每组测试数据：

- 若你输出的第一行比标准答案劣，得 0 分。
- 若你输出的第一行比标准答案优，则 checker 将检查你的构造方案是否正确。若正确，则返回 `_fail`，表现为测试点 UKE；否则得 0 分。
- 否则，你输出的第一行和标准答案一样。若构造方案不正确，得 0.6 分；否则得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，checker 能检测出你的答案比标准答案优的前提是输出完全符合格式。**一旦输出不符合格式，得 0 分**。格式限制包括但不限于：

- 第一行不得输出除 `0` 和 `1` 以外的字符。
- 第二行不得输出除 `^` 和 `|` 以外的字符，且字符串长度恰为 $n - 1$。
- `^` 的个数恰为 $x$，`|` 的个数恰为 $y$。

**「数据范围与约定」**

- 测试点 #1（10 points）：所有 $b_i$ 互不相等。
- 测试点 #2（20 points）：所有 $b_i$ 相等。
- 测试点 #3（30 points）：$n \leq 8$。
- 测试点 #4（25 points）：$n \leq 10 ^ 3$。
- 测试点 #5（15 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 20$。
- $1 \leq n \leq 2.5 \times 10 ^ 4$。
- $0 \leq x, y < n$，$x + y = n - 1$。
- $1\leq a_i < 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i < 65536$。

**「帮助与提示」**

- 关于 [位运算](https://oi-wiki.org/math/bit/)。
- 请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) B
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
4 0 3
1 0 6 4
8 5 2
1 5 5 7 1 5 5 7
1 0 0
15
4 3 0
65535 65535 57 57
```

### 输出

```
1010011
|||
10100000
^|^^^^|
1000000000000000

0
^^^
```

# 题解

## 作者：Alex_Wei (赞：12)

> [P8453 「SWTR-8」美元巨大](https://www.luogu.com.cn/problem/P8453)

### 题目描述

小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

表达式越大，越有可能炸掉小 T 的博客。小 A 希望 **从左往右** 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。

若存在多组构造方案，输出任意一组。

多组测试数据。

### 数据范围

- 测试点 #1（10 points）：所有 $b_i$ 互不相等。
- 测试点 #2（20 points）：所有 $b_i$ 相等。
- 测试点 #3（30 points）：$n \leq 8$。
- 测试点 #4（25 points）：$n \leq 10 ^ 3$。依赖测试点 #3。
- 测试点 #5（15 points）：无特殊限制。依赖测试点 #1，#2，#4。

对于 $100\%$ 的数据：

- $1\leq T\leq 20$。
- $1 \leq n \leq 2.5 \times 10 ^ 4$。
- $0 \leq x, y < n$，$x + y = n - 1$。
- $1\leq a_i < 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i < 65536$。

### 解法

核心观察：或比异或更厉害。无论之前结果如何，只要在最后一次出现之前放上或就能让这一位变成 $1$。

对每个出现偶数次的位，在最后分配一个或就能变为 $1$。而出现奇数次的位就算不分配也是 $1$​。

按位从大到小贪心，时间复杂度 $\mathcal{O}(n + V)$。

构造方案：在选择分配或的位的最后一次出现之前放上或。对于多于的或，从后往前填入所有空隙，容易发现不影响答案。剩余空隙放入异或。

### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
bool Mbe;
constexpr int N = 2.5e4 + 5;
constexpr int W = 1 << 16;
int n, x, y, a[N], op[N];
int buc[W], ans[W], lst[W];
bool Med;
int main() {
  fprintf(stderr, "%.3lf\n", (&Mbe - &Med) / 1048576.0);
#ifdef ALEX_WEI
  freopen("0.in", "r", stdin);
  freopen("0.out", "w", stdout);
#endif
  int S, T;
  cin >> S >> T;
  while(T--) {
    memset(op, 0, sizeof(op));
    memset(buc, 0, sizeof(buc));
    memset(ans, 0, sizeof(ans));
    cin >> n >> x >> y;
    for(int i = 1; i <= n; i++) cin >> a[i], buc[a[i]]++, lst[a[i]] = i;
    for(int i = W - 1; ~i; i--)
      if(buc[i] & 1) ans[i] = 1;
      else if(y && buc[i]) ans[i] = op[lst[i]] = 1, y--;
    for(int i = n; y; i--) if(!op[i]) op[i] = 1, y--;
    bool flag = 0;
    for(int i = W - 1; ~i; i--) if(ans[i] || flag) cout << ans[i], flag = 1;
    if(!flag) cout << '0';
    cout << '\n';
    for(int i = 2; i <= n; i++) cout << (op[i] ? '|' : '^');
    cout << '\n';
  }
  return 0;
}
```

---

## 作者：jiangxiaohai (赞：11)

# P8453 美元巨大

感谢@[WrongAnswer_90](https://www.luogu.com.cn/user/134510)提供的思路%%%%%%%

[原题传送门](https://www.luogu.com.cn/problem/P8453)

本题解应用的思路是贪心，有任何疑问可以在评论区提问

注：题解中所有异或运算均用单词 $xor$ 表示， 按位或运算用符号 `|` 表示。

读完题,得知要求 $n$ 个 $2^{b_i}$ 经过 $x$ 次异或操作，$y$ 次按位或操作后得到的最大值，以二进制形式输出最大值，并输出操作的方案，数据保证 $x+y=n-1$ 。

### 分析思路

可以开一个数组来记录最终值二进制的每一位，最后从高位到低位输出即可


根据异或和按位或的性质，$a$ $xor$ $b$ 的结果比 $a$ 大还是比 $a$ 小无法确定，但 $a$ $|$ $b$ 必然大于或等于 $a$ ，根据这个性质我们得知，使用 `|` 后得数只增不减，这样就为贪心思路奠定了基础。

可以假设一开始每一次运算都是 $xor$，若发现第 $i$ 次运算后得数会比原先得数小且还有剩余的 `|`，就把第 $i$ 次的 $xor$ 运算换成 `|` ，同时 `|`的数量 $-1$ ，这样就可以保证每次操作后得数最大，如果 $xor$ 用完了，就一直使用 `|` 即可。

### 实现

因为每一次读入 $input[i]=b$ 表示的都是 $2^b$，转换成二进制就是只有第 $b$ 位为 $1$，其余都是 $0$，所以可以开两个数组，$buc[b]=1$ 表示最终结果的第 $b$ 位有值， $ket$ 用来存 $b$ 位一共出现了多少次,如果 $ket[b]$ 为奇数，那么一直使用 $xor$ 即可使这一位一直为 $1$，如果是偶数次**且不为零**（这一点很关键），那么把最后一次 $xor$ 改成 `|` 就可以保留这一位上的 $1$，如果没有 `|` 了，那么 $buc[b]$ 变为 $0$。

由于要取最大值，我们还可以再设一个 $maxbit$ 用来存最高位是第几位，再从高位向低位判断每一位是否需要使用 `|`（要取最大值的话肯定是尽量保留高位数）。输出时从 $maxbit$ 开始，去除完前导零后一位一位地输出 $ket[b]$ ，即为最大值。

另设两个数组 $last$ 和 $keep$，其中 $last[b]$ 存储第 $b$ 位最后一次读入是什么时候，$keep[b]$ 存第 $b$ 位是否需要使用 `|`，因为是从左到右运算，所以我们只需要判断第 $b$ 位最后一次出现是否需要使用 `|` ，具体实现见代码。

### 为什么这样做是对的?

因为 $2^b$ 转为二进制后只有第 $b$ 位为 $1$，其他的都为 $0$，对其操作不会对其他位的数字产生影响，对于第 $b$ 位的操作只会影响一位，所以可以使用一个桶来统计 $b$ 位的出现次数。


附上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
inline int read() 
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c))
		c=getchar();
	while(isdigit(c))
	{
		s=(s<<1)+(s<<3)+(c^48);
		c=getchar();
	}
	return s*w;
}
int SSS,T,input[71223],buc[71223],ket[71223],last[71223],keep[71223],n,maxbit,o,xo;
int main()
{
	SSS=read();
	T=read();
	while(T>0)
	{
		T--;
		for(int i=0;i<=max(n,maxbit);i++)
			buc[i]=input[i]=last[i]=keep[i]=ket[i]=0;
		n=read();
		xo=read();
		o=read();
		maxbit=0;
		for(int i=1;i<=n;i++)
		{
			input[i]=read();
			ket[input[i]]++;
			buc[input[i]]=1;			//假设每个input[i]位可以保存 
			maxbit=max(maxbit,input[i]);
			last[input[i]]=i;			//input[i]最后出现的位置在每次循环中更新 
		}
		for(int i=maxbit;i>=0;i--)		//因为0<=b<65536所以要从最高位一直循环到第0位 
		{
			if(ket[i]%2==0&&ket[i]>0) 
			{
				if(o>=1) 
				{
					o--;
					keep[i]=1;			//记录input[i]需要一个按位或 
				}
				else
					buc[i]=0;
			}
		}
		bool baba=false;
		for(int i=maxbit;i>=1;i--)		//从最高位到最低位输出
		{
			if(buc[i]!=0)				//去除前导零 
			baba=true;
			if(baba==true)
			putchar(buc[i]+48);
		}
		putchar(buc[0]+48);
		printf("\n");
		for(int i=2;i<=n;i++)
		{
			if(xo==0)
				putchar('|');			//如果所有异或都用完了,剩下的都用或就可以 
			else
			{
				if(keep[input[i]]==1&&i==last[input[i]])//如果input[i]位需要一个按位或并且是最后一次出现 
				putchar('|');
				else
				{
					xo--;
					putchar('^');
				}
			}
		}
		printf("\n");
	}
}
```




---

## 作者：Dregen_Yor (赞：10)

# 题目简述

- 给定 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$，$a_i=2^{b_i}$。

- 在这 $n$ 个数中插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。求这个表达式的最大值。

不会位运算的请[点击这里](https://oi-wiki.org/math/bit/)。

# 思路

根据贪心的思想以及位运算的相关知识，对于出现**奇数**次的 $b_i$，我们可以一直加入异或运算符，异或运算符数量不够了再用或运算符，如果是**偶数**个，可以先一直进行异或操作，在最后一个相等的 $b_i$ 前插入或运算符。

# 如何保证最大

我们可以使用一个结构体记录每个 $b_i$ 以及它对应的下标 $i$，根据 $b_i$ 从大到小排序，对于相等的 $b_i$ 根据 $i$ 的大小从小到大排序，这样就可以保证最大的值可以加入答案中并保证**偶数**情况下的或运算符插在最后一个位置上。

# 具体实现

把 $b_1$ 单独拿出来，排序的时候从第二个开始，因为 $b_1$ 一开始的时候一定会被加入到答案中，使用一个数组记录下每个 $b_i$ 出现的次数，再用一个字符数组记录构造方案。遍历时看做在每个数前面加入运算符。对于出现奇数次的数，直接插入异或运算符即可，异或运算符不足的情况下再补或运算符。对于出现偶数次的情况，只要不是最后一个出现的就插入异或运算符，异或运算符不足的情况下再补或运算符。如果是最后一个出现的，就插入或运算符，如果或运算符不足就补或运算符，同时把这个数从答案中移除即可。

更多细节见注释。
# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n, x, y, s[65537], sum[65537];//s记录出现次数，sum记录答案
char ans[65537];//记录构造方案

struct node {
	int pos, add;//pos对应bi，add对应下标
} b[50000];

bool cmp(node a, node b) {
	if (a.pos == b.pos) {
		return a.add < b.add;//根据下标从小到大排序
	}
	return a.pos > b.pos;//根据bi从大到小排序

}

int main() {
	scanf("%d", &t);
	scanf("%d", &t);
	while (t--) {
		int maxn = 0;//记录最大位置
		memset(s, 0, sizeof(s));
		memset(sum, 0, sizeof(sum));
		scanf("%d%d%d", &n, &x, &y);
		for (int i = 1; i <= n; i++) {
			scanf("%d", &b[i].pos);
			maxn = max(maxn, b[i].pos);
			s[b[i].pos]++;
			b[i].add = i;
		}
		sum[b[1].pos] = 1;
		if (n != 1) {
			sort(b + 2, b + 1 + n, cmp);
		}
		for (int i = 2; i <= n; i++) {
			if (s[b[i].pos] & 1) {
				if (x) {
					ans[b[i].add] = '^';
					x--;
					sum[b[i].pos] = 1;
				} else {
					ans[b[i].add] = '|';
					y--;
					sum[b[i].pos] = 1;
				}
			} else {
				if (b[i + 1].pos != b[i].pos) {//最后一个如果y>0插入|，否则插入^
					if (y) {
						ans[b[i].add] = '|';
						y--;
						sum[b[i].pos] = 1;
					} else {
						ans[b[i].add] = '^';
						x--;
						sum[b[i].pos] = 0;
					}
				} else {//不是最后一个就插入^
					if (x) {
						ans[b[i].add] = '^';
						x--;
					} else {
						ans[b[i].add] = '|';
						y--;
						sum[b[i].pos] = 1;
					}
				}
			}
		}

		while (sum[maxn] == 0 && maxn >= 0) {
			maxn--;
		}//清除前导零
		for (int i = maxn; i >= 0; i--) {
			printf("%d", sum[i]);
		}
		if (maxn == -1) {
			printf("0");
		}
		putchar('\n');
		for (int i = 2; i <= n; i++) {
			putchar(ans[i]);//输出方案
		}
		putchar('\n');
	}
	return 0;
}

```


---

## 作者：STA_Morlin (赞：9)

[P8453 不等价交换法则 の 题目传送门。](https://www.luogu.com.cn/problem/P8453)

# 题目简化
> 给定一由连续二次幂组成的数列 $a_n$;  
> 在这些数当中使用 $x$ 个异或运算符和 $y$ 个与运算符进行运算。

> 求运算后最大值。

# 思路讲解
~~（这次月赛 Div2 我是真吐了啊，T2 整道绿题，合着人类还真进化了呗）~~

第一眼看到最大，又是贪心。  
贪心好啊，直接数位记录，然后从大向小挨个看，因为大位一定要保住。

---
# 代码实现
一开始写了个又臭又长的模拟，以为会炸……


### 记录数位
贪心也得知道怎么贪，在本题中，可以看出，异或是最没用的符号，那就先搞异或：
- 开头在这列  
开头的符号相当于或，后方要保持住偶数个异或（因为偶数次异或化简为 $0$）就是 $1$，如果不能偶数次，就填充或，但只在最后一位填充一个就行了。如果还不行，就说明这位保不住了，只能变 $0$。

- 开头不在这列  
基本同理，但是需要奇数次异或，反之也变 $0$。

### 记录符号
因为是先搞异或，所以异或的操作会比较多，麻烦啊，就让他用 $0$ 表示吧，省的搞那么多次。

或的话就只能是 $1$ 了，但因为是备用选项，基本上不用太多次，用也是连续填充，直接挨个操作就行了。

# _CODE_
```cpp
#include <bits/stdc++.h>
using namespace std;
const int man = 1e5+10;

int S, t, n, x, y, _;
int cnt[man], s[man], r[man];
vector <int> v[man];
void bez (int p, int l){
    int x = v[p].size()-1;
    while (l --) {
        s[v[p][x]] = 1;//填充 或
        -- x;
    }
    return;
}
int main () {
	#ifndef ONLINE_JUDGE
		freopen("B.in", "r", stdin);
		freopen("B.out", "w", stdout);
	#endif
	scanf("%d%d", &S, &t);
	while (t --) {
		int m = 0, f = 0;
		memset(s, 0, sizeof(s));
		memset(r, 0, sizeof(r));
		for (int i = 0; i <= 65536; ++ i) {
			cnt[i] = 0;
			v[i].clear();
		}
		scanf("%d%d%d", &n, &x, &y);
		for (int b, i = 1; i <= n; ++ i) {
			scanf("%d", &b);
			if (i == 1) _ = b;
			m = max(m, b);
			++ cnt[b];
			if (i != 1) v[b].push_back(i);//记录位置
		}
		for (int i = m; i >= 0; -- i) {
			if (!cnt[i]) continue;
			if (i == _) {//如果是首位
				-- cnt[i];//需要减一，因为首位无符号
				if (!(cnt[i]&1)) {
					r[i] = 1;
					if (x >= cnt[i]) x -= cnt[i];
					else {
						bez(i, cnt[i]-x);
						y -= cnt[i]-x;
						x = 0;
					}
				}
				else {
					if (!y) {
						r[i] = 0;
						x -= cnt[i];
					}
					else {
						r[i] = 1;
						-- y;
                        if (x >= cnt[i]-1){
                            bez(i, 1);
                            x -= cnt[i]-1;
                        }
                        else {
                            bez(i, cnt[i]-x);
                            y -= cnt[i]-1-x;
                            x = 0;
                        }
					}
				}
			}
			else {
                if (cnt[i]&1){
                    r[i]=1;
                    if (x >= cnt[i]) x -= cnt[i];
                    else {
                        bez(i, cnt[i]-x);
                        y -= cnt[i]-x;
                        x = 0;
                    }
                }
                else {
                    r[i]=1;
                    if (!y){
                        r[i] = 0;
                        x -= cnt[i];
                    }
                    else {
                        -- y;
                        r[i] = 1;
                        if (x >= cnt[i]-1) {
                            bez(i, 1);
                            x -= cnt[i]-1;
                        }
                        else{
                            bez(i, cnt[i]-x);
                            y -= cnt[i]-1-x;
                            x = 0;
                        }
                    }
                }
            }
        }
	    for (int i = m; i >= 0; -- i){
	        if (r[i]) f = 1;
	        if (f) printf("%d", r[i]? 1: 0);
	    }
	    if (!f) printf("0");
	    printf("\n");
	    for (int i = 2; i <= n; ++ i) printf("%c", s[i]? '|': '^');
	    printf("\n");
	}
	return 0;
}
```
# E.N.D.

---

## 作者：NBest (赞：5)

比赛的时候乍眼一看这么多 $2$ 直接不想写了,结果在重现赛重现看的时候感觉没有那么难了，就勇敢去贪就好了。
## 贪心思路
首先，我们很容易得到,无论前面有重复出现了多少次该位的数，不管它前面是被异或了还是或了,我们只需要在该位最后一次出现的时候用一次或运算即可保留其对答案的贡献。

其次，比如对于二进制数 $(11011011)_2$，我们就算将 $7$ 位全部保留，也比只保留第 $8$ 位要小，因此尽可能保留最大的一位才能使结果最优。

最后，对于重复出现了奇数次的数位，显然我们用什么运算符都不会对答案造成影响，因此我们只需要保留偶数次位就行了。

对于多余的或，因为其无论放在哪都不会对结果造成干扰，所以可以直接全部放在最后面。

**总结：在偶数次出现的大数位用或运算将其保留。**

接下来是带注释的代码:
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
	return x*f;
}
int S,T,n,x,y,xx,yy;
int a[25004],ans[65540],g[65540],maxa,appear[65540];
//a数组存数据,ans存最优答案,g存该位出现的次数,maxa是最大数位,appear表示遍历过程中该位出现了几次，用于判断是不是最后一位 
bool fh[25004],baoliu[65540];
//fh表示该位的符号(1亦或,0或),baoliu表示此位要不要保留 
int main(){
	S=read(),T=read();
	while(T--){
		memset(ans,0,sizeof(ans));
		memset(g,0,sizeof(g));
		memset(appear,0,sizeof(appear));
		memset(baoliu,0,sizeof(baoliu));
		maxa=0;
		memset(fh,0,sizeof(fh));
		n=read(),x=read(),y=read();
		xx=x,yy=y;
		for(int i=1;i<=n;i++){
			a[i]=read();
			if(a[i]>maxa)maxa=a[i];
			g[a[i]]++;
		}
		for(int i=maxa+2;i>=0;i--){
			if(!yy)break;//如果没有或了就只能结束了 
			if(g[i]&&g[i]%2==0){//如果这一位存在并且出现了偶数次，就消耗一个或去保留 
				yy--;
				baoliu[i]=1;
			}
		}
		ans[a[1]]=1;
		appear[a[1]]=1;//先把1保存了 
		for(int i=2;i<=n;i++){
			appear[a[i]]++; 
			if(baoliu[a[i]]&&appear[a[i]]==g[a[i]]){
				//如果该位要保留并且是最后一次出现就把符号标记为或 
				fh[i-1]=0;
				ans[a[i]]=1;
				continue;
			}
			ans[a[i]]^=1;//0->1,1->0
			fh[i-1]=1;//先标记为亦或位 
		}
		bool flag=0;
		for(int i=maxa+2;i>=0;--i){
			if(!flag&&ans[i]){//去前导0 
				flag=1;
			}
			if(flag)printf("%d",ans[i]);
		}
		if(!flag)cout<<0;//防止全0情况 
		cout<<endl;
		int ox=0;
		for(int i=1;i<n;i++){
			if(fh[i]&&ox<x){//亦或如果不够就把或全输出了，对答案没有影响 
				cout<<"^";
				ox++;
			}
			else{
				cout<<"|";
			}
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：许多 (赞：3)

~~炸别人的博客是不好的行为~~。

由于 $a_i=2^{b_i}$。

我们可以知道，二进制下的 $a_i$ 必定为 $1000000 \cdots$，此后省略若干个 $0$ 的形式，而 $b_i$，即是 $0$ 的个数。

考虑对 $b_i$ 排序，但由于还要输出构造方案，所以我们可以使用一个结构体记录每个 $b_i$ 以及下标 $i$，因为我们要使结果尽可能的大，所以根据 $b_i$ 从大到小排序，对于相等的 $b_i$ 根据 $i$ 的大小从小到大排序。
```cpp
struct QWQ{
	int bi,now;
}c[30001];
bool cmp(QWQ a1,QWQ a2){
	return a1.bi!=a2.bi? a1.bi>a2.bi:a1.now<a2.now;
}
```

对于出现次数为**奇数**个的 $b_i$，可以一直用异或运算符连接，异或运算符数量不够了再用或运算符。无论如何，出现次数为**奇数**个的 $b_i$ **必定会被加入到答案中**。

但对于出现次数为**偶数**个的 $b_i$ 就不同了。就拿 $1$ 举例：$1\oplus1=0$。但我们可以**在最后加入一个或运算符，前面用异或运算符连接**。

~~可以看出~~，或运算符在本题里就是万能运算符，那如果或运算符不够了怎么办？这就是排序的用处，我们只将较大的 $a_i$ 加入，对于较小的 $a_i$ 可以省略。

注意：$a_1$ 前没有运算符。

# 代码

```cpp
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int T,n,x,y,B[70000],a[70000];//B[i]表示a[i]前的运算符，0为|，1为^。
void P(int now){//输出方案。
	if(now==0)putchar('|');
	else putchar('^');
	return ;
}
struct QWQ{
	int bi,now;
}c[30001];
bool cmp(QWQ a1,QWQ a2){
	return a1.bi!=a2.bi? a1.bi>a2.bi:a1.now<a2.now;
}
int main(){
	T=read();T=read();
	while(T--){
		int ans=0,NOW=0;
		for(int i=0;i<=65536;i++)B[i]=a[i]=0;
		n=read();x=read();y=read();
		for(int i=1;i<=n;i++){
			c[i].bi=read();c[i].now=i;
			NOW=max(NOW,c[i].bi);
		}
		sort(c+1,c+1+n,cmp);
		for(int i=1;i<=n;i++){
			int j;
			for(j=i+1;j<=n;j++)//查找共有多少个相同的b[i]。
				if(c[j].bi!=c[i].bi)
					break;
			if((j-i)%2==1){
				for(int k=i;k<j;k++){
					if(c[k].now==1)continue;//特判a[1]。
					if(x!=0)x--,B[c[k].now]=1;
					else y--,B[c[k].now]=0;
				}
				a[c[i].bi]=1;
			}
			else {
				for(int k=i;k<j-1;k++){
					if(c[k].now==1)continue;//特判a[1]。
					if(x!=0)x--,B[c[k].now]=1;
					else y--,B[c[k].now]=0;
				}
				if(y==0)B[c[j-1].now]=1,x--;
				else B[c[j-1].now]=0,y--,a[c[i].bi]=1;
			}
			i=j-1;
		}
		int LLLLL=0;
		for(int i=NOW;i>=0;i--){
			if(LLLLL==0&&a[i]==0)continue;
			LLLLL=1;
			printf("%d",a[i]);
		}
		if(LLLLL==0)printf("0");
		printf("\n");
		for(int i=2;i<=n;i++)P(B[i]);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：zhenjianuo2025 (赞：2)

### Problem
给定 $n$ 个 $2$ 的幂 $a_1=2^{b_1}, a_2=2^{b_2}, \cdots, a_n=2^{b_n}$。在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式，并使其从左到右计算的值最大。
### Solve
题意可以转化为：一个二进制高精数的每一位是由若干个 $1$ 进行若干次异或运算或或运算得到的，且异或运算总数为 $x$ 个，或运算总数为 $y$ 个，求得到的最大数值。

考虑使用**贪心**求解。

按二进制位考虑，每一位都是**独立**的，即两位之间不会互相干扰，所以我们只要尽量让高位变成 $1$，就可以使表达式的值最大。

观察得出，对于每一位，如果在这一位上的最后一个 $1$ 出现之前放上一个**或**运算符，就一定能让这一位变成 $1$。

可以如下进行贪心：

从高位到低位依次枚举，

1. 如果这一位上的 $1$ 出现了**奇数次**，即使都放上异或也能让这一位变成 $1$，我们就不用放或运算符；

1. 如果这一位上的 $1$ 出现了**偶数次**，而或运算符还没被放完，我们就需要在这一位上最后一个的 $1$ 出现之前的位置上放上或运算符，这一位也能变成 $1$。


一轮结束后，如果或运算符还没被放完，剩下的或运算符即使**随意放**也不会影响答案。

直到或运算符全部放完为止，在剩余的位置上放上**异或**运算符，这样我们就构造出了最优方案。
### Code
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int s, t, n, x, y, a[25010], ans[65540], cnt[65540], lst[65540];
char opr[25010];
int main() {
	cin >> s >> t;
	while (t--) {
		memset(cnt, 0, sizeof cnt);
		memset(lst, 0, sizeof lst);
		memset(opr, '^', sizeof opr);
		memset(ans, 0, sizeof ans);
		cin >> n >> x >> y;
		for (int i = 1; i <= n; i++) {
			cin >> a[i];
			cnt[a[i]]++, lst[a[i]] = i;   // cnt 统计这一位上 1 的出现次数，lst 统计这一位上最后一个 1 出现的位置 
		}
		for (int i = 65536; i >= 0; i--)
			if (cnt[i] % 2) ans[i] = 1;   // 出现了偶数次，都放异或运算符也能让这一位变成 1 
			else if (y && cnt[i]) ans[i] = 1, opr[lst[i]] = '|', y--;   // 否则需要在最后一次出现之前放上或运算符
		for (int i = n; y; i--)
			if (opr[i] == '^') opr[i] = '|', y--;   // 剩下的或运算符随便放，不影响答案
		int i = 65536;
		while (i >= 0 && ans[i] == 0) i--;
		bool flag = false;
		for (; i >= 0; i--)
			cout << ans[i], flag = true;
		if (!flag) cout << "0";
		cout << endl;
		for (int i = 2; i <= n; i++)
			cout << opr[i];
		cout << endl;
	}
	return 0;
}
```

最后 %%% Alex 巨佬 orz orz，让本蒟蒻恍然大悟（还是我弱啊……）

---

## 作者：HopeAndLizz (赞：2)

# 题意

有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。

构造上述表达式，使其值最大。

# 题目分析

贪心。

容易想到按位考虑，尽量让高位为 $1$，因为低位造成的影响小于高位，这样可以保证表达式的值最大。

故可以保存相同 $b_i$ 出现的次数，即每一位有几个 $1$ 参与运算，并从高位枚举。

对于每一位如何构造？

容易知道，使用或运算符 `|` 能强制使得该位为 $1$，所以我们尽可能地先用异或 `^`（用完那就用或运算符），如果用异或 `^` 无法使得该位为 $1$，再在最后使用或 `|`。这是为了保证有尽可能多的数位为 $1$。

具体操作？

当该位上有奇数个 $1$ 时全用异或 `^` 即可让该位为 $1$；而对于偶数个 $1$，需要在最后补上至少一个或 `|`。

对于单个询问，时间复杂度大抵是 $\mathcal{O}(n)$。

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
const int MAXN = 65536 + 5;
template <class T>
inline void rd(T &x)
{
//防止代码过长，不贴快读
}
struct aa
{
	int cnt;//次数
	vector<int> num;
} b[MAXN];
int n, x, y, t;
char s[MAXN];//存运算符
int a[MAXN];//存二进制数
int main()
{
	//freopen("in.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
	int t;
	scanf("%d", &t);
	scanf("%d", &t);
	while (t--)
	{
		rd(n), rd(x), rd(y);
		int c;
		memset(s, 0, sizeof(s));
		memset(b, 0, sizeof(b));
		memset(a, 0, sizeof(a));
		rd(c);
		a[c] = 1;
		int maxx = c;
		for (int i = 2; i <= n; i++)
		{
			rd(c);
			b[c].num.push_back(i);//记录bi的下标，方便输出构造
			b[c].cnt++;//记录相同的bi有几个
			maxx = max(c, maxx);
		}
		for (int i = maxx; i >= 0; i--)//从高位枚举
		{
			c = b[i].cnt;
			if (!c)
				continue;
				
			c += a[i];
			auto it = b[i].num.begin();
			auto end=b[i].num.end();
			for (; it != end-((c & 1)==0); it++)//这里进行了奇偶分类
			{
				if (x)//这表明如果还有异或就一直用异或
				{
					x--;
					s[(*it) - 1] = '^';
					a[i] = a[i] ^ 1;
				}
				else
				{
					y--;
					s[(*it) - 1] = '|';
					a[i] = 1;
				}
			}
			if (it != b[i].num.end())
			{
				if(y)
				{
					y--;
					s[(*it) - 1] = '|';
					a[i] = 1;
				}
				else//这个是防止或运算符为0的情况
				{
					x--;
					s[(*it) - 1] = '^';
					a[i] = a[i] ^ 1;
				}
			}
		}
		int i = maxx;//以下为输出
		for (; i >= 0; i--)
		{
			if (a[i])
				break;
		}
		if (i == -1)
			putchar('0');
		for (; i >= 0; i--)
			cout << a[i];
		putchar('\n');
		for (int i = 1; i < n; i++)
			putchar(s[i]);
		putchar('\n');
	}
}

```


---

## 作者：_XHY20180718_ (赞：2)

## 前置知识：[位运算](https://oi-wiki.org/math/bit/)。

## 题意简述
1. 给定 $n$ 个 $2$ 的幂。
2. 在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。
3. 求出表达式**从左往右**计算时最大可能的取值。

## 题目分析

对于这道题，我们需要从**或运算**和**异或运算**的性质出发。

根据**或运算**与**异或运算**的性质可知：若要使表达式的结果最大，我们需要使每个数位上的**异或操作**尽可能为**奇数次**。

所以，我们可以先用数组记录每个 $b$ 的**大小及其原始（输入的）位置**，然后将其进行排序,并用一个桶记录 $b$ 出现的次数，最后遍历一遍即可（详细过程会在代码中给予解释）。


```cpp
#include<cstdio>	
#include<algorithm>

using namespace std;
const int N=25010,B=65540;
char data[B];
char op[B];
int S,T;
int n,x,y;

struct node
{
	int bi;
	int di;//自然序 
	bool operator<(const node &x) const 
	{
		if(bi==x.bi) return di<x.di;
		else return bi<x.bi;
	}	
}bid[N];//结构体记录n个bi的位置和序号id 
int maxb;//最高位 
int num[B];//桶记录b的个数num[b] 
void solve()
{
	sort(bid+1, bid+1+n);//bi稳定单调递增序 
	int yi=0;//已用运算符或'|'的个数 
	int di=n;//当前遍历bi的稳定单调递增序di
	int bi=bid[di].bi;//二进制输出位值，最高位在后
	maxb=bi;//最高位
	while(yi<y&&di>0)
	{	
		data[bi]='1';
		bi--;		
		//if(num[bid[di].bi]%2==1)//奇数个数位异或，直接输出数值为'1'  
		if(num[bid[di].bi]%2==0)//偶数个数位异或，输出数值为'0' 
		{ 
			op[bid[di].di-1]='|';				
			yi++;
		}
		di--; 		
		while(di>0&&bid[di].bi==bid[di+1].bi) di--;//跳过稳定单调递增序bi
		if(di==0)//输出数值低空位补'0' 
		{
			while(bi>-1)//输出数值空位补'0'
			{ 			 
				data[bi]='0';//输出数值补'0' 
				bi--;
			} 
			break;		
		} 		 
		while(bi>bid[di].bi)//输出数值空位补'0'
		{ 			 
			data[bi]='0';//输出数值补'0' 
			bi--;
		} 
	}
	if(di==0)//或运算未用完，尾部优先分配或运算位置
	{	
		di=n;
		while(yi<y) 
		{	
			di--;
			if(op[di]=='|') continue;
			op[di]='|';
			yi++;	
		} 
	}
	else//还有位未或取，给出异或运算结果 
	{	
		while(di>0)
		{
			if(num[bid[di].bi]%2==1) data[bi]='1';//奇数个数位异或，直接输出数值为'1'
			if(num[bid[di].bi]%2==0) data[bi]='0';//偶数个数位异或，输出数值为'0' 
			bi--; 
			di--; 		
			while(di>0&&bid[di].bi==bid[di+1].bi) di--;//跳过稳定单调递增序bi
			if(di==0)//输出数值低空位补'0' 
			{
				while(bi>-1)//输出数值空位补'0'
				{ 			 
					data[bi]='0';//输出数值补'0' 
					bi--;
				}
				break;
			} 		 
			while(bi>bid[di].bi)//输出数值空位补'0'
			{ 			 
				data[bi]='0';//输出数值补'0' 
				bi--;
			} 	
		}
	}		 
} 

int main()
{
	//freopen("C.in","r",stdin);
	//freopen("C.ans","w",stdout);
	scanf("%d",&S);
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d %d %d",&n, &x, &y);
		for(int bi=0; bi<65536; bi++) num[bi]=0;//b的个数计数 
		for(int di=1; di<n; di++) op[di]='^';//初始运算符号为异或^ 
		int b;
		bid[0].bi=-1;//记录b的大小 
		bid[0].di=-1;//记录b的原始位置 
		for(int i=1; i<=n; i++) 
		{
			scanf("%d",&b);
			bid[i].bi=b;//记录b的大小 
			bid[i].di=i;//记录b的原始位置 
			num[b]++;//b的个数计数 
		}
		bid[n+1].bi=-1;//记录b的大小 
		bid[n+1].di=-1;//记录b的原始位置 
		solve();
		int bi=maxb+1;
		while(bi)
		{
			bi--;
			if(data[bi]=='1') break;
		}
		while(bi>=0)
		{
			printf("%c", data[bi]);	
			bi--;		
		}
		printf("\n");	
		int di=1;
		while(di<n)
		{			
			printf("%c", op[di]);
			di++;	
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Flash_Man (赞：1)

# P8453 美元巨大 题解

## 题目分析

容易证明，一个正整数序列的异或和，一定不大于它的“或和”，即： $a_1\oplus a_2\oplus\cdots\oplus a_n\le a_1| a_2|\cdots| a_n$ ，其中 $|$ 表示“按位或”；

容易证明，在二进制下，最高位越高，数越大，即： $(1\cdots)_2>(0\cdots)_2$ ；

容易证明，一个正整数异或自己任意次，**最后**在或上自己一次，一定等于自己，即： $\left(\bigoplus\limits_{i=1}^{k}x\right)|x=x$ ；

容易证明，一个正整数异或自己偶数次，结果为 $0$ ，即： $\bigoplus\limits_{i\in[1..k]\wedge2\mid k}x=0$ 。

那么对于此题，可以先把所有的符号填成异或，并记录下每个二进制位的 $1$ 的个数。从高到低扫描每一个二进制位：若 $1$ 的个数为偶数，则把**最后出现**的这个二进制位为 $1$ 数的前面的运算符改为或。进行完这个操作后，若还剩有或运算符，**从后往前**把运算符改为或即可。

**注意**：第一个数要特殊处理，因为它的前面没有符号！

## 题目实现

```cpp
#include <cstdio>
#include <deque>

#define superfast // fread和fwrite快速输入输出，不需要的话删除即可

#ifdef superfast

static char buf[1000000], *p1 = buf, *p2 = buf, obuf[1000000], *p3 = obuf;

#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++
#define putchar(x) (p3 - obuf < 1000000) ? (*p3 ++= x) : (fwrite(obuf, p3 - obuf, 1, stdout), p3 = obuf, *p3 ++= x)

#endif

namespace quick_IO{ // 快速输入
    template <typename type> inline void read(type &x){
        x = 0;
        int neg (1);
        char c = getchar();
        while(c < '0' || c > '9'){
            if(c == '-')
                neg = -1;
            c = getchar();
        }
        while(c >= '0' && c <= '9'){
            x = (x << 1) + (x << 3) + (c ^ 48);
            c = getchar();
        }
        x *= neg;
    }
}

using namespace quick_IO;

using std :: deque;

const int maxn = 2.5e4 + 1;
const int maxb = 65536 + 1;

int s, t, n, x, y; // 如题
int b[maxn]; // 如题

int cnt[maxb]; // 统计每个二进制位1出现的次数
int mxn = 0; // 统计最高出现1的二进制位
bool op[maxn]; // 记录运算符
deque <int> pos[maxb]; // 记录对每个二进制位产生贡献的数的位置

inline int max(int x, int y){
    return x > y ? x : y;
}

int main(){
    read(s), read(t);
    while(t--){
        read(n), read(x), read(y);
        for(int i = 0; i < maxb; i++){ // 清空
            cnt[i] = 0;
            pos[i].clear();
        }
        for(int i = 1; i <= n; i++)
            op[i] = false;
        read(b[1]); // 第一个数特殊处理
        cnt[b[1]]++;
        mxn = b[1];
        for(int i = 2; i <= n; i++){
            read(b[i]);
            cnt[b[i]]++;
            pos[b[i]].push_back(i);
            mxn = max(mxn, b[i]);
        }
        for(int i = mxn; i >= 0 && y > 0; i--)
            if(!(cnt[i] & 1) && cnt[i] > 0){
                y--;
                op[pos[i].back()] = true;
                pos[i].pop_back();
                cnt[i]--;
            }
        for(int i = n; i >= 1 && y > 0; i--)
            if(!op[i]){
                op[i] = true;
                y--;
            }
        int i;
        for(i = mxn; i >= 0; i--)
            if(cnt[i] & 1)
                break;
        if(i == -1)
            putchar('0');
        for(; i >= 0; i--)
            putchar((cnt[i] & 1) ? '1' : '0');
        putchar(10);
        for(int i = 2; i <= n; i++)
            putchar(op[i] ? '|' : '^');
        putchar(10);
    }

#ifdef superfast

    fwrite(obuf, p3 - obuf, 1, stdout);

#endif

    return 0;
}

```



---

## 作者：VIOLET__FOREVER (赞：1)

## 前言
蒟蒻是参考这位[大佬](https://www.luogu.com.cn/user/710100)的思路发表的题解，这么好的思路却没有出现在题解里着实比较可惜了。
## 题意
关于这道题目，关键就是 $\bigoplus$ 和 $|$ 的安排，如果您现在还搞不清楚**位运算**的含义的话，可以看下面的

或($|$) 两个对应位中**有一个**为 $1$ 时为 $1$。

异或($\bigoplus$) 两个对应位**不同**时为 $1$。

——[OI-wiki](https://oi-wiki.org/math/bit/)

同时或和异或满足： $a|b=b|a,a\bigoplus b=b\bigoplus a$。

这样的话我们就可以利用交换律将相同的位数放到一起，使用 `std::sort` 排序，同时记录每一个数一开始的位置。

同时，两个相同的数进行异或将会得到 $0$，而两个相同的数进行或运算的话则会不变，而题目中给出的是得到的数最大，所以我们要尽可能让高位保持为 $1$，这样我们的目标就有了。
## 思路
从上方的异或和或概念的理解，我们可以轻而易举的知道一下观点，如果一个数出现奇数次那无论再怎么异或或者或都无法将他从 $1$ 变成 $0$ （这里非常关键），所以我们在一开始可以对所有数从大到小进行排序，然后以对所有数进行预处理，就是如果碰到出现次数为偶数个的数就在他最后一次出现的时候给他所处的位置标为或运算，这样就可以将他的出现次数变为奇数（即保证他的位数为 $1$），这样我们在进行便利，即碰到奇数次我们就利用刚刚得出的定理（即出现奇数次的位数，无论怎么异或或者或都没有办法使他从 $1$ 变为 $0$），所以我们可以里用这个性质，利用奇数次出现的数尽可能多的消掉异或的个数，最后再以**倒序**的方法输出即可，记得要去除前导零。

--------

稍微总结一下：

1.初始化。

2.在输入的同时，利用结构体记录每个数原来的位置，同时利用桶来记录每个数出现的次数。

3.预处理数组，尽可能多的将每个位数出现的次数变为奇数次。

4.遍历一整个数组（记得要注意剩余异或和或的个数，以及预处理过的数不可以进行二次修改，详细见代码）。

5.最后对于每个数字进行输出。

遵循一个原则：尽量将高位出现的次数变为奇数次。
## 代码
```cpp
#include<bitsdc++.h>
using namespace std;
int s,m,x,y,n;
struct node{
	int val,id;//结构体，val表示位数，id表示每一个位数一开始的位置 
}a[25005];
int cnt[70005],ans1[70005],ans2[70005];//cnt储存每一个位数出现的次数，ans1表示第一行输出，ans2则是第二行 

bool cmp(node x,node y){
	if(x.val!=y.val) return x.val>y.val;
	else return x.id<y.id;
}

int main(){
	while(cin>>s){
		cin>>m;
		while(m--){
			memset(cnt,0,sizeof(cnt));
			memset(ans1,0,sizeof(ans1));
			memset(ans2,0,sizeof(ans2));//初始化，很重要不然会报错 
			cin>>n>>x>>y;
			for(int i=1;i<=n;i++){
				cin>>a[i].val;
				a[i].id=i;
				cnt[a[i].val]++;
			}
			sort(a+1,a+1+n,cmp);
			for(int i=1;i<=n;i++){/*预处理*/ 
				if(cnt[a[i].val]%2==0 && y>=1){//如果出现个数为偶数，同时或的个数足够 
					i+=cnt[a[i].val];//使得i指针可以跳到下一个数字 
					i--,y--,cnt[a[i].val]--;
					ans2[a[i].id]=1;//将这个位数最后一次出现的位置表为或 
					//填1表示或，2表示异或，0表示没填（所以通过ans2也可以判断这个位置有没有被用过） 
				}
			}
			for(int i=1;i<=n;i++){
				if(cnt[a[i].val]%2==1){
					ans1[a[i].val]=1;//位数肯定是1，这是可以保证的 
					if(ans2[a[i].id]==0 && a[i].id!=1){//这里要特判他不是第一位，因为我们只需要填n-1个数 
						if(x>0){//如果异或还有就将他抵消 
							ans2[a[i].id]=2;
							x--;
						}
						else{
							ans2[a[i].id]=1;
							y--;
						}
					}
				}
				else{
					if(ans2[a[i].id]==0 && a[i].id!=1){
						ans1[a[i].val]=0;//如果为偶数次，因为他没有被一开始的预处理处理过，所以一定是或的数量不够了，所以只能填异或 
						ans2[a[i].id]=2;
						x--;
					}
				}
			}
			bool flag=1;//flag用来去除前导零 
			for(int i=a[1].val;i>=0;--i){//一定记得倒叙输出 
				if(flag){
					if(ans1[i]==0 && i>0){
						continue;
					}
					else flag=0;
				}
				cout<<ans1[i];
			}
			cout<<endl;
			for(int i=2;i<=n;i++){
				if(ans2[i]==1) cout<<"|";
				else cout<<"^";
			}
			cout<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Jeremiahy (赞：1)

## 分析

我们发现，各位之间相互独立，也就是说， $b$ 序列中两个不同的数字之间放什么都是累加起来的，我们还发现，```^``` 的“权力”小于 ```|```，也就是异或的功能被或覆盖了：或可以将 $0$ 和 $1$ 变为 $1$，将 $1$ 和 $1$ 变为 $1$；但异或会将 $0$ 和 $1$ 变为 $1$，$1$ 和 $1$ 变为 $0$。我们自然希望 $1$ 越多越好，那怎么办呢？

好钢用在刀刃上，根据上述结论，两个不同的数字之间用异或（如果还有的话），相同的数字之间如果是奇数个，直接全部异或起来即可（如果异或不够就用或），如果是偶数个，就前面全用异或，最后一个空用或，这样可以使或剩下的最多。

最后我们是从最高位向下遍历，或优先供给给高位，记录下来每位使用的运算符。

在遍历过程中记录每位答案就是第一问，注意前导零。

第二问遍历 $b$ 数组，如果遇见一个没有遇见过得数，使用异或，异或不够再用或；如果遇见一个已经遇见的数，则输出其还剩下的运算符。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int T, b[65539], ans[65539], op[65537][3], num[65537], n, x, y, is[65539];
inline int read(){
    int x = 0;
    char c = getchar();
    while (c < '0' || c > '9')
        c = getchar();
    while (c >= '0' && c <= '9')
        x = (x << 1) + (x << 3) + c - '0', c = getchar();
    return x;
}
signed main () {
	T = read(); T = read();
	while (T--) {
		memset(ans, 0, sizeof(ans));//ans 记录第一问的答案（每位是否为 1）
		memset(op, 0, sizeof(op));//op 记录每位的运算符，op[i][0] 表示第i位需要的异或数量，1表示或
		memset(num, 0, sizeof(num));//每位数字的数量
		memset(is, 0, sizeof(is));//第二问遍历时是否出现过
		n = read(); x = read(); y = read(); b[1] = read(), num[b[1]]++;
		int maxn = b[1], flag = 0;
		for (register int i(2); i <= n; ++i) {
			b[i] = read();
			maxn = ((b[i] > maxn) ? b[i] : maxn);//最大值
			num[b[i]]++;
		}
		for (register int i = maxn; i >= 0; i--)
			if (num[i]) {
				if (num[i] % 2) {//奇数个
					while (num[i] - 1 > 0)//全异或
						if (x)
							x--, num[i]--, op[i][0]++;
						else	
							y--, num[i]--, op[i][1]++;
					ans[i] = 1;					
				}
				else {//偶数个
					//if (i == 1)
						//cout << "ceshi " << x << ' ' << y << '\n';
					if (y)
						ans[i] = 1;
					while (num[i] - 2 > 0)//前面异或
						if (x)
							x--, num[i]--, op[i][0]++;
						else	
							y--, num[i]--, op[i][1]++;
					if (!y)//最后或
						x--, num[i]--, op[i][0]++;
					else
						y--, num[i]--, op[i][1]++;
				}				
			}
		//cout << "X " << x << " Y " << y << '\n';
		//cout << op[1][0] << ' ' << op[1][1] << '\n';
		for (register int i = maxn; i >= 0; i--)
			if (ans[i] || flag)//flag 处理前导零
				cout << ans[i], flag = 1;
		if (!flag)
			cout << 0;
		puts("");   
		is[b[1]] = 1; 
		for (register int i = 2; i <= n; i++)//输出
			if (is[b[i]])
				if (op[b[i]][0])
					cout << '^', op[b[i]][0]--;
				else	
					cout << '|', op[b[i]][1]--;
			else	
				if (x)
					cout << '^', x--, is[b[i]] = 1;
				else
					cout << '|', y--, is[b[i]] = 1;
		puts("");
	}
	return 0;
}
```


---

## 作者：tribool4_in (赞：1)

考虑**或运算**和**异或运算**的性质。

对于或运算，不管加入的是什么数字，已经是 $1$ 的位一定不会变成 $0$。

对于异或运算，只有当该位上有奇数个 $1$ 时才会为 $1$。

所以可以从高位往低位考虑。由于或运算的较好性质，我们从一开始就要尽可能少用或运算，当有奇数个 $1$ 时可以全部填异或，如果为偶数个则最后尽量填一个或运算使得结果为 $1$。如果无法满足则该位只能为 $0$。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 10;
inline int read() {
    int k = 1, x = 0; char c = getchar();
    while (!isdigit(c)) { if (c == '-') k = -1; c = getchar(); }
    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
    return k * x;
}
int T, n, x, y, b[N];
vector<int> l[N];
int nums[N], m;
int ch[N];
bool ok[N];
bool cmp(int a, int b) { return a > b; }
int ncnt[N];
signed main() {
    read();
    T = read();
    while (T--) {
        memset(ok, 0, sizeof(ok));
        memset(ch, 0, sizeof(ch));
        memset(ncnt, 0, sizeof(ncnt));
        memset(nums, 0, sizeof(nums));
        for (int i = 0; i <= 100000; i++) l[i].clear();

        n = read(), x = read(), y = read(); m = 0;
        for (int i = 1; i <= n; i++) {
            b[i] = read();
            if (l[b[i]].size() == 0) nums[++m] = b[i];
            l[b[i]].push_back(i);
            ncnt[b[i]]++;
        }
        sort(nums + 1, nums + m + 1, cmp);
        for (int i = 1; i <= m; i++) {
            int nb = nums[i];
            int s = l[nb].size() - 1;
            if ((s % 2 == 0) && x >= s) {
                ch[nb] = s;
                x -= ch[nb];
                ok[nb] = 1;
            } else if (x >= s && y > 0) {
                ch[nb] = s - 1;
                x -= ch[nb];
                y--;
                ok[nb] = 1;
            } else if (x >= s) {
                ch[nb] = s;
                x -= ch[nb];
            } else {
                ch[nb] = x;
                y -= (s - x);
                x = 0;
                ok[nb] = 1;
            }
        }
        bool st = 0;
        for (int i = 65535; i >= 0; i--) {
            if (ok[i]) st = 1;
            if (!st) continue;
            printf("%d", ok[i]);
        }
        if (!st) puts("0");
        else puts("");
        for (int i = 1; i <= n; i++) {
            int nb = b[i];
            if (ncnt[nb] == l[nb].size()) {
                if (i > 1) {
                    if (x > 0) putchar('^'), x--;
                    else putchar('|'), y--;
                }
                ncnt[nb]--;
                continue;
            }
            if (ch[nb] > 0) {
                putchar('^');
                ch[nb]--;
            } else putchar('|');
            ncnt[nb]--;
        }
        puts("");
    }
}
```

---

## 作者：吴思诚 (赞：1)

## P8453 「SWTR-8」美元巨大 题解
[题目传送门](https://www.luogu.com.cn/problem/P8453)

### 思路
因为数都是 $2^{b_i}$，所以每次 `|` 或 `^` 只会改变至多一位，且 `|` 将这位赋为 $1$ ，而 `^` 将这位取反。为了使得数最大，应先使得最高位尽可能大。所以从高位的数字向低位枚举，若此位有奇数个 $b_i$ ，则可以直接异或，不需要任何或就能为 $1$ ，如果是偶数个，可以只耗费一个或使得这位为 $1$，对于用不完的或，把它用来替换后面的异或(如果替换前面的，会破坏前面的异或结果，使得最后本来应该为 $1$ 的位为 $0$)，最后倒着构造方案时如果需要或，那就使用一个；如果不需要或，则先使用多余的或再使用异或。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,T,n,x,y,t[65536],b[25001];
bitset<25001>ans;
int main(){
	scanf("%d%d",&s,&T);
	while(T--){
		scanf("%d%d%d",&n,&x,&y);
		memset(t,0,sizeof t);
		int pos=0,Y=y;
		for(int i=1;i<=n;++i){
			scanf("%d",b+i);
			++t[b[i]];
		}
		for(int i=65535;i>=0;--i){
			if(!t[i])continue;
			if(t[i]&1){//t[i]=2表示无需使用或即可为1
				t[i]=2;
				if(!pos)pos=i;
			}
			else if(y){//t[i]=1表示需要使用或改为1
				--y;
				t[i]=1;
				if(!pos)pos=i;
			}
			else t[i]=0;//或不够了，只能为0
		}
		for(int i=pos;i>=0;--i)printf("%d",t[i]>0);//t[i]>0的情况为1
		putchar('\n');
		for(int i=n;i>=2;--i){
			if(t[b[i]]==1){
				ans[i]=1;
				t[b[i]]=0;//用完或就取消标记
			}
			else{
				if(y){//使用多余的或
					--y;
					ans[i]=1;
				}
				else ans[i]=0;//使用异或
			}
		}
		for(int i=2;i<=n;++i)putchar(ans[i]?'|':'^');
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：OI_AKed_me (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P8453)

## 思路 ##
这道题要让结果尽可能大，那我们就让位数高的为真。我们分析一下或和异或，即在任何情况下，只要有一次或即会变成真，但异或相当于取反，也就是说或能变成真的的，异或不一定能，异或能变成真的，或一定能。根据上面两条，我们很容易想到先根据数值进行排序，然后能放异或就放异或，当这个数值的数只剩一个时特判要不要放或，因为异或不满足交换律，所以我们因使用稳定的排序，可以选择双关键字排序或者使用 ```stable_sort```。

## 代码 ##
以下为解决一次问题的代码：
```cpp
int t,s,a[70005],num[70005],tot[70005];
bool b[70005],ans[70005];
char ac[70005];
bool cmp(int x,int y){
	return a[x]>a[y];
}
void work(){
	int n,x,y,maxn=0;
	bool pd=0;
	memset(b,0,sizeof(b));
	memset(ans,0,sizeof(ans));
	read(n,x,y);
	for(int i=1;i<=n;i++){
		read(a[i]);
		num[i]=i;
		tot[a[i]]++;//记录每个数出现次数
		maxn=max(a[i],maxn);
	}
	stable_sort(num+2,num+n+1,cmp);// num 数组是编号，不改变原数组，方便输出。
	b[a[1]]=1;//第一个数前面没有符号，所以要提前判掉。
	tot[a[1]]--;
	for(int i=2;i<=n;i++){
		int k=num[i];
		tot[a[k]]--;
		if(x<1){//特判如果一种符号用完。
			ac[k]='|';
			b[a[k]]=1;
			y--;
			continue;
		}
		if(y<1){//同上
			ac[k]='^';
			b[a[k]]=!b[a[k]];
			x--;
			continue;
		}
		if(tot[a[k]]){
			ac[k]='^';
			x--;
			b[a[k]]=!b[a[k]];
			continue;
		}
		if(b[a[k]]){
			ac[k]='|';
			y--;
			b[a[k]]=1;
		}else{
			ac[k]='^';
			x--;
			b[a[k]]=1;
		}	
	}
	for(int i=maxn;i>=0;i--){
		if(!pd){
			if(b[i]){
				putchar('1');
				pd=1;
			}
		}else{
			if(b[i]) putchar('1');
			else putchar('0');
		}
	}
	if(!pd) putchar('0');
	putchar('\n');
	for(int i=2;i<=n;i++){
		putchar(ac[i]);
	}
	putchar('\n');
}
```

---

## 作者：KemononeRou (赞：1)

为啥我感觉 2A 第二问比这题简单啊/fad

我们发现或运算一定是比异或运算优，于是考虑如何把异或操作用掉。

首先答案上界是每个出现的位都为 $1$。

对于每个出现过的位，不管它前面是存在还是被异或给消去，在最后一次出现的时候填或运算一定能够使得这一位为 $1$。

一个消耗异或操作的想法就是每个不是最后一次出现的位都填异或。

然后对于出现次数为奇数的位，最后一次出现时填异或这一位也为 $1$。

这样，我们在保证达到答案上界的情况下使得消耗的异或操作最多。

假如没有消耗完，我们只能贪心地把低位的 $1$ 变为 $0$。

需要注意一些细节，比如第一个数不能在前面填异或但是要也算进出现次数，输出不能有前导零。

[code](https://www.luogu.com.cn/paste/mgjd29u0)

---

## 作者：西湖水妖 (赞：1)

### 题意简述

+ 你有 $n$ 个 $2$ 的幂 $a_{1\cdots n}$，其中 $a_i=2^{b_i}$。

+ 你需要再它们之间插入 $x$ 个异或（C++ 中 ```^```）运算符、$y$ 个或运算符（C++ 中 ```|```）。

+ 你需要求出最大结果（二进制），这个结果**无视正常的运算符优先级、结合律，从左到右计算**，并求出插入的方案。

+ 有 $T$ 组数据，$1\leq T\leq 20,1\leq n\leq 2.5\times 10^4,0\leq x,y<n,x+y=n-1,0\leq b_i<65536$。开启 SPJ，任何一种解法都可以。

### 题目分析

因为所有数都是 $2$ 的幂，所以只有每个数前面的紧邻的那个符号会影响这个数带来的结果的变化。第一个数前面的符号我们并不关心，可以看成 $0$ 异或或者或上第一个数。

接着，我们发现，一次或使结果变大或不变，一次异或使结果变大或变小，或优于异或。这里我们先考虑如何分配异或运算使结果变大的情况。

1. 如果一个数是第一次出现，那么把它前面的符号变成异或，因为这样使结果变大，与或作用相同。

2. 如果一个数不是第一次出现，并且这个数是第奇数次出现，那么把上一个与这个数相同的数和它的符号都变成异或，一共异或奇数次使结果变大。

3. 还有一种特殊情况，如果一个数不是第一次出现，并且这个数是第奇数次出现，异或符号的数量只剩 $1$，那么把上一个与这个数相同的数和它的符号都变成异或。此时不属于上一种情况，因为上一种情况需要 $2$ 个异或，不够用。虽然先异或偶数次结果不变，但是后面再或使结果变大。后面就没有异或了，不需要考虑后面的影响了。这种情况其实可以不考虑，但是会使实现更麻烦。

分配完上述异或后，如果还剩下异或，那么从小到大分配，这样只能是结果变小了。

代码风格很毒瘤，已经努力改了。具体实现看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
char ch;
void read(unsigned &x)
// 快读，洛咕月赛需要卡常，排名才能高。
{
    x = 0u;
    do
        ch = getchar();
    while(isspace(ch));
    while(isdigit(ch))
    {
        x *= 10u;
        x += ch;
        x -= '0';
        ch = getchar();
    }
}
unsigned s, T, n, x, y;
bool flag;
array<unsigned, 25001> a; // 这是原题中的 b。
array<bool, 25001> is_xor; // 记录每个数前面的符号。
array<unsigned, 65536> b /* 记录每个数出现次数的桶。*/, e;
// 记录每个数最后一次出现的位置。
array<bool, 65536> ans; // 记录最大结果每一位情况。
int main()
{
    read(s);
    read(T);
    do
    {
        read(n);
        read(x);
        read(y);
        ++ x; // 第一个数满足第一种情况，默认分配异或，要增加一次异或次数。
        fill(b.begin(), b.end(), 0u);
        fill(e.begin(), e.end(), 0u);
        fill(is_xor.begin(), is_xor.end(), false);
        fill(ans.begin(), ans.end(), false);
// 多测一定要清空！
        for(unsigned i(0u); i != n; ++ i)
        {
            read(a[i]);
            ans[a[i]] = true; // 尽量使这位加入答案。
            if(++ b[a[i]] == 1u && x)
            {
                is_xor[i] = true;
                -- x;
            } // 第一种情况。
            else if(b[a[i]] & 1u)
                if(x == 1u)
                {
                    is_xor[e[a[i]]] = true;
                    -- x;
                } // 第三种情况。
                else if(x > 1u)
                {
                    is_xor[i] = is_xor[e[a[i]]] = true;
                    -- -- x;
                } // 第二种情况。
            e[a[i]] = i; // 更新末尾的数。
        }
        for(unsigned i(0u); x && i != 65536u; ++ i)
            if(b[i] && ! is_xor[e[i]])
            {
                ans[i] = false;
                is_xor[e[i]] = true;
                -- x;
            } // 剩余异或从小到大分配。
        flag = false; // 标记前导 0。
        for(unsigned i(65535u); i != - 1u; -- i)
// 数字从高位到低位输出。
            if(ans[i])
            {
                flag = true;
                putchar('1');
            }
            else if(flag)
                putchar('0');
        if(! flag) //全是前导 0 则输出 0。
            putchar('0');
        putchar('\n');
        for(unsigned i(1u); i != n; ++ i)
            if(is_xor[i])
                putchar('^');
            else
                putchar('|');
        putchar('\n');
    } while(-- T);
    return 0;
}
```

---

## 作者：luqyou (赞：0)

# 前言
本题解仅提供思路。
# 思路
注意到每个数都是 $2^x$，所以每次运算只会影响一位的值。

我们用vector把相同位数的下标存下来，从高位开始。

假设一位有 $c$ 个相同的数，如果：

* $c$ 是偶数，用 $c-2$ 个异或和 $1$ 个或。

* $c$ 是奇数，用 $c-1$ 个异或。

这两种情况都能让这一位变成 $1$。或用完了就改异或然后这一位为 $0$，异或用完了都用或，答案还是不变。

最后，注意处理第一个数字，是没有符号的。

---

## 作者：moshouiii3 (赞：0)

## 题目分析
几个要点：
1. 二进制某一位上做位操作不影响其他位。
2. $1 \oplus 0=1,0 \oplus 0=0,1|0=1,0|0=0$，即 $0$ 前任意数配任意操作符出来的结果还是前数。
3. 结合以上两点，每个操作符可认为只影响其后的那个数，即可以把问题归类。

由此以上分析，**影响结果 $b_i$ 位的只和数列中的 $b_i$ 项及前面的操作符有关**。
## 问题转化
我们把所有  $b_i$  项都提取出来，问题转换成共有 $n$ 个 $1$ 的式子 $0( \oplus /|)1( \oplus /|)1( \oplus /|)1...( \oplus /|)1=?$
，我们的目标是让结果等于 $1$ 。
1. $1 \oplus 1=0,0 \oplus 1=1,1|1=1,0|1=1$。
2. 对第一个 $1$ ，因为前面要不然没有操作符（处在 $a_1$ 位），要不然是 $0$ ，由于　$0 \oplus 1=1, 0|1=1$ ，所以什么操作符都不影响后续结果为 $1$ 。
3. 现在来看　$n=2$　的情况，$1( \oplus /|)1$只有在 $1|1$ 的情况下才为 $1$ ，所以只能放 $|$ 。
4. $n=3$ 的情况, $1 \oplus 1 \oplus 1=1$ ，可以全部放 $\oplus $。
5. 继续观察发现 $n$ 为奇数的情况，操作符可以全部放 $ \oplus $ ；$n$ 为偶数，至少要 $1$ 个 $|$ 操作符。
6. 而且因为 $1|1=1,0|1=1$ ，所以如果想要最后结果为 $1$ ，最后 $1$ 个操作符为 $|$ 即可，前面就可以任意放。

## 形成算法
根据以上的分析发现可以用贪心算出最优解，具体如下：
1. 从大的 $b_i$ 开始，依次满足计算结果为 $1$ ，如果 $b_i$ 的个数为奇数就不管，是偶数就要在最后一个 $b_i$ 位置前放 $|$ 操作符。
1. 若全都弄完了，还有剩下的 $|$ 没放置，那就从每个不同的 $b_i$ 位置从后往前放，因为最后 $1$ 个操作符为 $|$ 即可，前面就可以任意放。

实际做的过程中，“最后 $1$ 个操作符为 $|$ 即可”这点我到最后 15 分钟才想到，其实这点很明显。但因为没想到，致使我花了很多时间在设计如何放置操作符上。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mem(x,y) memset(x,y,sizeof(x))
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define Rof(i,j,k) for(register int i=j;i>=k;i--)
#define ckmx(a,b) if(a<b){a=b;}
#define gc getchar
#define pc putchar
template<typename T> void read(T &x) {
	x=0;
	char c=gc();
	bool f=0;
	while(!isdigit(c)) {
		if(c=='-')f=1;
		c=gc();
	}
	while(isdigit(c)) {
		x=(x<<3)+(x<<1)+c-48;
		c=gc();
	}
	if(f)x=-x;
}
template<typename T,typename... Args> void read(T &first,Args& ... args) {
	read(first);
	read(args...);
}
template<typename T> void write(T x) {
	if(x<0) {
		pc('-');
		x=-x;
	}
	if(x>9)write(x/10);
	pc(x%10+'0');
}
template<typename T,typename... Args> void write(T first,Args ... args) {
	write(first);
	pc(' ');
	write(args...);
}
void pt(string x) {
	for(char i:x) pc(i);
}
struct num {
	int n, d;
};
const int N = 25004;
const int M = 65537;
int kind, t, n, x, y;
int b[M], last[M];
bool f[N];
num a[N];
bool cmp(const num & a, const num & b) {
	if (a.n > b.n)
		return true;
	if (a.n == b.n)
		return a.d > b.d;
	return false;
}
signed main() {
	int x, mx, lasti;
	read(kind, t);
	while (t--) {
		read(n, x, y);
		mem(b, 0);
		mx = 0;
		For(i, 1, n) {
			read(x);
			++b[x];
			last[x] = i;
			ckmx(mx, x);
			a[i].n = x;
			a[i].d = i;
		}
		sort(a+1, a+n+1, cmp);
		mem(f, 0);
		lasti = -1;
		Rof(i, mx, 0) {
			if (y<=0) {
				lasti = i;
				break;
			}
			if (b[i] && !(b[i] & 1)) {
				f[last[i]] = true;
				--y;
			}
		}
		int i = 1;
		while (y > 0) {
			int wz = a[i++].d;
			if (!f[wz] && wz>1) {
				f[wz] = true;
				--y;
			}
		}
		bool have1 = false;
		Rof(i, mx, 0) {
			if (b[i]) {
				if (b[i] & 1 || i > lasti)  {
					have1 = true;
					pc('1');
					continue;
				}
			}
			if (have1)	pc('0');
		}
		if (!have1)		pc('0');
		printf("\n");
		For(i, 2, n) pc(f[i]?'|':'^');
		printf("\n");
	}
	return 0;
}
```

---

## 作者：int08 (赞：0)

# 前言
代码没有优化，可能偏长……
# Solution
## 1、总体上

首先我们发现：不管是或还是异或，$b_i$ 不同时互不影响，也就是说实际上最后答案第 $n$ 位是啥，仅由 $b_i=n$ 的前面加了什么符号。

同时发现，不管许多个相等的 $b_i$ 前面是什么符号，只要最后一个前面是或，最后答案里这一位必然为 $1$。

但异或就不一定了。

感性理解成：或符号放在最后一个 $b_i$ 之前，对答案有确定的积极贡献，异或没有。

以贪心算法就**初步**知道了结论（不是结果）：

**尽可能的把 $y$ 个或符号分配给较大的 $b_i$ 使用。**

## 2、具体说
因为是异或运算，答案与每个 $b_i$ 的出现次数的奇偶性有关。

### 1、奇数次
我们发现哪怕每个前面都塞异或，结果答案的这一位也是 $1$。

所以尽可能的把异或~~浪费~~用在这里。

### 2、偶数次

此时每个前面都加异或便没用了，需要结尾加或符号补救。

大的先加，小的后加，没了就不加。

**见代码。**
## 3、其他逝项


第一个数前面是不能加符号的，所以我们假定加的是异或。但是程序算完之后可能正好给第一个数前面加的是或，这样确实会影响答案了。

所以我们可以将这个或和算出来的结果中的最后一个异或交换。

如果异或用完了，就在结尾改用或符号。

避免输出前导 $0$ 的方式见代码。


# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long s,t,n,x,y,v[66666],i,j,b[28888],a[66666],o[66666],q,r,xx,yy,ans[28888];
int main()
{
    cin>>s>>t;
    for(i=1;i<=t;i++)
    {
        memset(v,0,sizeof(v));
        int p=0;
        cin>>n>>xx>>yy;x=xx+1;y=yy;
        for(j=1;j<=n;j++)
        {
            cin>>b[j];
            v[b[j]]++;//类似桶排序
        }
        for(j=65535;j>=0;j--)
        {
            if(p==0&&v[j]==0) continue;//避免输出前导0
            if(p!=0&&v[j]==0)
            {
                cout<<0;
                continue;
            }
            if(v[j]%2)
            {
                cout<<1;p=1;
                o[j]=min(x,v[j]);a[j]=v[j]-o[j];//min函数避免用完了异或符号
                x-=o[j];y-=a[j];continue;
            }
            if(y>0)
            {
                cout<<1;p=1;
                o[j]=min(v[j]-1,x);a[j]=v[j]-o[j];
                x-=o[j];y-=a[j];
            }
            else
            {
                if(p!=0) cout<<0;
                o[j]=min(v[j],x);
                x-=o[j];
            }
        }
        if(!p) cout<<0;
        cout<<"\n";
        for(j=n;j>=1;j--)
        {
            if(a[b[j]])
            {
                ans[j]=1;a[b[j]]--;
            }
            else
            {
                ans[j]=0;o[b[j]]--;
            }
        }
        if(ans[1])
        {
            for(j=n;j>=2;j--)
            {
                if(!ans[j])
                {ans[j]=1;break;}
            }
        }
        for(j=2;j<=n;j++)
        {
            if(ans[j]) cout<<"|";
            else cout<<"^";
        }
        cout<<"\n";
    }
    return 0;
}
```
# The End

---


# 「REOI-1」深潜的第六兽

## 题目背景

“〈十七兽〉全都不会飞。因此，在它们毁灭大地以后，悬浮大陆群还能像这样浮在天空。

“可是，只有〈深潜的第六兽〉在本身留在大地的同时，还能对悬浮大陆群发动攻击。它有两种能力，『分裂增生』和『快速茁壮』。

“留在地表的本体会让身体分裂出几万个碎块，然后随风飞扬，等待碰巧飘流到某座悬浮岛。抵达岛上以后，它会当场发育茁壮，大约六到八小时过后就能占据并毁灭整座岛。”

## 题目描述

现在有一只〈第六兽〉，在某一次的「分裂增生」时分裂出了 $n$ 个碎块，这些碎块会笔直向上飞去，如果其中一块碎块遇到了一座浮空岛（为了研究方便，我们不妨将它当成一条二维空间中的线段处理），便会迅速占据它，并一分为二，再次从浮空岛的两端笔直向上飞去。

不过好在，那些只是一些无关紧要最为荒凉毫无人烟的岛屿，但如果就这样放任它们继续肆虐，势必会给那些至关重要的浮空岛带来毁灭性的打击。于是乎，负责清理〈第六兽〉的军官们，决定以他们所在的岛屿为直线建立 $x$ 轴，并以重力的方向为正方向建立 $y$ 轴，他们总共监测到了 $m$ 座浮空岛，并确定了那些碎块分裂出的位置（距离 $x$ 轴的位置视作无限远），于是他们想知道，如果放任这些碎块，那么当它们到达军官的位置时，最终会有多少碎块。

注意，若一座浮空岛的 $ l_i $ 与 $ r_i $ 相同，即为一个点， 〈第六兽〉占据后仍然会分裂成两只，从这个点向上飞去。

**提示：浮空岛作为实体显然不会重叠。**

**简要题意：**

在一个平面直角坐标系上有 $m$ 条平行于 x 轴的线段，第 $i$ 条线段为 $(l_i,h_i)$ 与 $(r_i,h_i)$ 的连线。特别注意 $l_i$ 可与 $r_i$ 相等，此时线段变为一个点。

在直线 $y=10^9$ 上有 $n$ 个点，分别位于 $(x_i,10^9)$。

现在，这些点逐渐向下（y轴负方向）移动。若触碰到线段，则会一分为二，分裂出的两个点分别从线段的两端继续向下移动。

特别地，若线段为一个点，则会原地分裂成 2 个。

问所有初始点在经历了线段的分裂后，在最后会有多少个点掉在 $ x $ 轴上

## 说明/提示

样例解释：

注意， $y$ 轴正方向为重力方向。
在坐标轴中，横坐标为 $x$ 的碎块，先掉到纵坐标为2的线段上，然后分成两个从 $1$ 和 $3$ 往下掉，$3$ 的那个掉到了纵坐标为1的线段上，分成两个从 $2$ 和 $6$ 往下掉，第一个碎块一共变成了 $3$ 块，分别掉在 $1，2，6$ ，第二个碎块一共变成了两个碎块，分别掉在 $2，6$。

| 子问题 | 特殊限制条件 | 分值 |
| :-----------: | :-----------: | :-----------: |
| 1 | $ 1\leq n,m \leq 10 $ | 10 |
| 2 | $ 1\leq n,m \leq 100 $ | 5 |
| 3 | $ 1\leq n\leq 10^4， 1\leq m \leq 5\times 10^5 $ | 35 |
| 4 |$ 1\leq n,m \leq 5\times 10^5 $|50|

本题各个子问题之间不捆绑测试。

对于 $100\%$ 的数据 $ 1\leq n,m \leq 5\times 10^5 $，所有数字均为非负整数。


## 样例 #1

### 输入

```
2 2
1 3 2
2 6 1
3 5```

### 输出

```
5```

# 题解

## 作者：bsTiat (赞：23)

将所有线段按纵坐标从小到大排序，用一棵线段树维护掉到每个位置对答案的贡献。初始全部为 $1$。

对于排好序的每条线段，我们先分别询问线段两个端点处的贡献值，然后把这整个线段所覆盖的区间赋值为两个端点处贡献值之和。

最后对于每个点都相当于单点查询，答案累加即可。

所用到的操作只有区间修改和单点查询，你可以用你喜欢的数据结构维护。

---

## 作者：Supor__Shoep (赞：5)

个人没有想到大佬们线段树的做法，而是很单纯地想到记忆化（也可以理解为动态规划）。

我们可以画一个草图来理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/saj7ejan.png)

这个图什么意思呢？我们假设碎块落在了第 $i$ 个岛上，那么我们就会从这个岛的左右端点再生成两个碎块，此时我们可以看到，两个碎块分别会落在岛 $j$ 和岛 $k$ 上面，这个时候就是两个不同的情况了——我们假设 $dp_i$ 表示一个碎块 **首先** 落在第 $i$ 个岛时最后生成的碎块个数，那么根据得到的两个不同情况，我们容易推得 $dp_i=dp_j+dp_k$。

当然我们还需要考虑其它情况，比如说：

![](https://cdn.luogu.com.cn/upload/image_hosting/zsln2nok.png)

这个时候一个碎块直接落在了底部，这个时候就没有 $dp_k$ 或者 $dp_j$ 了（看情况，也有可能都直接到底）。方程如图所示。

不过需要注意的是，我们的 $h_i$ 是必须大于 $h_j$ 和 $h_k$ 的，并且 $h_j$ 和 $h_k$ 是最大值。另外，我们需要从 $h$ 从小到大排序，这样保证每一个 $dp_i$ 都能取到正确的值。

那么边界条件呢？那也非常简单，由于我们是排序得到的序列进行转移，我们肯定是给最下面的岛赋初值，怎么赋？它的下面不可能有其它岛，因此初始最下面所有的岛都是 $2$。然后根据岛的左右端点查找 $j$ 和 $k$，转移一个方程。

最后统计答案的时候，我们查找一个点 **首先** 到达的岛 $i$，那么它的答案就是 $dp_i$。但是但是！如果一个点垂直向下找不到任何一个岛，那么它的答案就是 $1$，不能忽略掉。

那么代码就可以很容易地写出来了：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=6e5+5;
const int MOD=998244353;
int n,m;
struct node
{
	int l,r,h,si;
}a[MAXN];
bool cmp(node x,node y)
{
	return x.h<y.h;
}
int d[MAXN];
long long dp[MAXN];
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)	cin>>a[i].l>>a[i].r>>a[i].h;
	for(int i=1;i<=n;i++)	cin>>d[i];
	sort(a+1,a+m+1,cmp);
	int First=a[1].h,L=1,R;
	for(int i=1;i<=m;i++)
	{
		if(a[i].h==First)	dp[i]=2;
		else
		{
			int si1=0,si2=0;
			for(int j=i-1;j>=1;j--)
			{
				if(a[j].l<=a[i].l&&a[j].r>=a[i].l&&!si1)	si1=j;
				if(a[j].l<=a[i].r&&a[j].r>=a[i].r&&!si2)	si2=j;
				if(si1&&si2)	break;
			}
			if(!si1&&!si2)	dp[i]=2;
			else if(si1&&si2)	dp[i]=dp[si1]+dp[si2];
			else if(si1&&!si2)	dp[i]=dp[si1]+1;
			else	dp[i]=dp[si2]+1;
			dp[i]=(dp[i]+MOD)%MOD;
		}
	}
	long long ans=0;
	for(int i=1;i<=n;i++)
	{
		bool flag=0;
		for(int j=m;j>=1;j--)
		{
			if(a[j].l<=d[i]&&a[j].r>=d[i])
			{
				ans=(ans+dp[j]+MOD)%MOD; 
				flag=1;
				break;
			}
		}
		if(!flag)	ans++;
	}
	cout<<ans;
	return 0;
}
```

这是本月赛做得最慢的题（话说就只做了前面两道题而已）。

---

## 作者：Disjoint_cat (赞：4)

## 零、前言

我打这场比赛的时候，读了很久才读懂这题题意，然后敲了 $10$ 分暴力准备走人的时候，突然听到机房同学说用线段树，然后我就~~无耻地~~ AC 了这道题。

## 一、题意

给定 $m$ 条二维空间中的线段，每条线段连接 $(l_i,h_i)$ 与 $(r_i,h_i)$。有 $n$ 个点从 $(x_i,+\infty)$ 落下，当碰到某条线段（包括边缘）时变成两个横坐标为 $l_i$ 和 $r_i$ 的点继续下落。求所有点落到地面后一共有多少个点。

## 二、解法

### 1.$10pts$

按高度给边排序，对于每个点直接暴力搜索，碰到边则递归搜索 $l_i$ 与 $r_i$。那么在最坏情况下，碰到一条边点数会加倍，时间复杂度为 $O(2^m\times n)$。

### 2.$15pts$

为什么第一种做法复杂度如此高呢？如果有很多个点碰到同一条边，那么这些点都会被计算一次。也就是说，上述解法中出现了重复计算。

重复计算想什么？DP！

设 $dp_{x,i}$ 为当横坐标为 $x$，高度在**从下到上**第 $i$ 条边与第 $i+1$ 条边之间的时候的答案。那么当该点没有碰到第 $i$ 条边时，它会竖直落到第 $i$ 条边与第 $i-1$ 条边之间，即 $dp_{x,i}=dp_{x,i-1}$；当它碰到第 $i$ 条边的时候，它会变成横坐标分别为 $l_i,r_i$ 的两个点，即 $dp_{x,i}=dp_{l_i,i-1}+dp_{r_i,i-1}$。

显然，边界为 $dp_{x,0}=1$。

时间复杂度为 $O(Xm)$，其中 $X$ 为 $x$ 坐标的取值范围。

### 3.$100pts$

我们还可以发现，我们在从下到上 DP 时，每当遇到一条边，我们就会把 $dp_{l_i,i}\sim dp_{r_i,i}$ 全部替换为 $dp_{l_i,i-1}+dp_{r_i,i-1}$，而其他位置不变。

也就是说，其实不需要暴力修改 $dp$ 数组，它只需要支持**区间赋值、单点查询**就可以了。

只需要一棵线段树，即可快速完成这两种操作。

时间复杂度为 $O(m\log X)$。本题做完。

## 三、代码

Talk is cheap,show me the code. ~~码风奇丑勿喷~~。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define lid id<<1
#define rid (lid)+1
using namespace std;
const int N=500005;
const ll MOD=998244353;
int n,m,q,ma;
struct island
{
	int l,r,h;
	bool operator<(const island b)
	{
		return h>b.h;
	}
}a[N];
ll ans,an[N];
struct tree
{
	int l,r,val;
	bool lz;
}tr[N];
void build(int l,int r,int id)
{
	tr[id].l=l,tr[id].r=r,tr[id].val=1,tr[id].lz=0;
	if(l==r)return;
	int mid=l+r>>1;
	build(l,mid,lid);
	build(mid+1,r,rid);
}
void pd(int id)
{
	if(!tr[id].lz)return;
	tr[lid].lz=tr[rid].lz=1,tr[id].lz=0;
	tr[lid].val=tr[rid].val=tr[id].val;
}
void mdf(int l,int r,int id,ll val)
{
	if(tr[id].l==l&&tr[id].r==r)
	{
		tr[id].val=val,tr[id].lz=1;
		return;
	}
	pd(id);
	if(tr[lid].r>=l)
		if(tr[rid].l<=r)
		{
			mdf(l,tr[lid].r,lid,val);
			mdf(tr[rid].l,r,rid,val);
		}
		else mdf(l,r,lid,val);
	else mdf(l,r,rid,val);
}
ll query(int pos,int id)
{
	if(tr[id].l==tr[id].r)return tr[id].val;
	pd(id);
	if(tr[lid].r>=pos)return query(pos,lid);
	return query(pos,rid);
}
int main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i].l>>a[i].r>>a[i].h;
		ma=max(ma,a[i].r);
	}
	sort(a+1,a+m+1);
	build(1,ma,1);
	for(int i=m;i>=1;i--)
		mdf(a[i].l,a[i].r,1,(query(a[i].l,1)+query(a[i].r,1\
		))%MOD);
	for(int i=1;i<=ma;i++)an[i]=query(i,1);
	for(int i=1;i<=n;i++)
	{
		cin>>q;
		ans=(ans+an[q])%MOD;
	}
	cout<<ans;
	return 0;
}
```

## 四、AC 后感

这道题的 $l_i$ 和 $r_i$ 其实可以出到 $10^9$，此时则需要离散化/动态开点。

我个人认为这道题还是很综合的，可以锻炼思维与写代码的能力，是一道线段树的好题。~~但是我觉得评黄有点低了~~。

---

## 作者：stntn (赞：4)

## 简要题意

题目中已经有了 [link](https://www.luogu.com.cn/problem/P8463)。

注：$S$ 为横坐标最大值。

## 暴力

**不想看思考过程的请跳过这一段。**

先考虑怎么暴力，我们有两种方法：

1. 分别模拟每个碎片下落的过程，共 $n$ 个碎片，$m$ 条线段，每个碎片至多分裂为 $2^m$ 个碎片，最暴力地模拟，复杂度为 $O(n2^m)$。期望得分 $10$ 分。

1. 分别模拟每条线段的分裂情况，乍一看有些难办，但仔细观察题面可发现**碎片可以看做是同时落下的**，因此我们建立一个数组 $cnt_{i,j}$ 表示在所有碎片同时下落的情况下，坠落到高度为 $j$ 时在 $x=i$ 的位置上有多少个碎片。复杂度 $O(S^2)$，期望得分 $0$。

第一种方法不太好优化，我们重点考虑第二种。

首先显然可以将数组压为一维并且改枚举高度 $j$ 为枚举线段，因为重点不是某条线段有多高，而是线段间的相对高度（应该很好理解）。

所以我们将线段存储并按高度由高到矮排序，顺序枚举线段的分裂情况。但此时复杂度为 $O(Sm+m \log m)$，期望得分 $15$。

现在时间瓶颈在于每次枚举到线段时要从左至右遍历横坐标，但实际上线段只会影响一个**区间**。

## 正解

~~以上都是我编的，不会真有人走那么多弯路吧。~~

一条线段的分裂实质就是**会将一个区间内的碎片集中到线段的两个端**点，显然分别为区间查询、修改和单点修改，随便整个数据结构优化一下就行了，这篇题解用的线段树。

遇见一条线段，就记录其覆盖的区间内碎片数量并清空，然后加在线段两端。最后统计一下就行了，复杂度 $O(m \log S+m \log m)$，期望得分 $100$。

## CODE

```cpp
#include<bits/stdc++.h> 
#define N 500010
#define M 100000
#define int long long
#define DB double
#define ULL unsigned long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define per(i,a,b) for(int i=a;i>=b;i--)
#define tep(i,u) for(int i=head[u];~i;i=e[i].nxt)
#define INF 0x3f3f3f3f
#define mod 998244353
using namespace std;
template <typename T> inline void read(T &a)
{
	a=0;T w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){a=a*10+ch-'0';ch=getchar();}
	a*=w;
}
template <typename T,typename ...Args>void read(T &x,Args &...args){read(x);read(args...);}
int n,m;
struct LINE
{
	int l,r,h;
	bool operator < (const LINE &b){return h>b.h;}
}line[N];
struct LT
{
	#define lc rt<<1
	#define rc rt<<1|1
	#define mid (l+r>>1)
	int sum[M<<2];bool cov[M<<2];
	inline int pushup(int rt){(sum[rt]=sum[lc]+sum[rc])%=mod;}
	inline void pushdown(int rt){if(!cov[rt]) return;cov[rt]=sum[lc]=sum[rc]=0;cov[lc]=cov[rc]=1;}
	inline void update_pos(int rt,int l,int r,int pos,int val)
	{
		if(l==r){sum[rt]+=val;return;}
		pushdown(rt);
		if(pos<=mid) update_pos(lc,l,mid,pos,val);
		else update_pos(rc,mid+1,r,pos,val);
		pushup(rt);
	}
	inline void clear(int rt,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R){cov[rt]=1;sum[rt]=0;return;}
		pushdown(rt);
		if(L<=mid) clear(lc,l,mid,L,R);
		if(mid<R) clear(rc,mid+1,r,L,R);
		pushup(rt);
	}
	inline int query(int rt,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R) return sum[rt];
		pushdown(rt);int res=0;
		if(L<=mid) (res+=query(lc,l,mid,L,R))%=mod;
		if(mid<R) (res+=query(rc,mid+1,r,L,R))%=mod;
		return res;
	}
	#undef lc
	#undef rc
	#undef mid
}t;

signed main()
{
	read(n,m);
	rep(i,1,m) read(line[i].l,line[i].r,line[i].h);
	rep(i,1,n){int x;read(x);t.update_pos(1,1,M,x,1);}
	sort(line+1,line+1+m);
	rep(i,1,m)
	{
		int l=line[i].l,r=line[i].r;
		int sum=t.query(1,1,M,l,r);
		t.clear(1,1,M,l,r);
		t.update_pos(1,1,M,l,sum);
		t.update_pos(1,1,M,r,sum);
	}
	printf("%lld\n",t.query(1,1,M,1,M)%mod);
	return 0;
}
```

---

## 作者：Strelitzia_ (赞：3)

## 题目大意

在一个平面直角坐标系上有 $m$ 条平行于 $x$ 轴的线段（在 $x$ 轴上方），第 $i$ 条线段为 $(l_i,h_i)$ 与 $(r_i,h_i)$ 的连线。同时在所有线段上方有 $n$ 个点，第 $i$ 个横坐标为 $x_i$。所有点向下运动，碰到线段就会一分为二分别从线段的左右端点开始向下移动。问最后有多少点落在 $x$ 轴上。

------------
## 思路

奉上自己画的样例 $1$ 图解。

![](https://cdn.luogu.com.cn/upload/image_hosting/w95rpa6l.png)

首先，我们注意到某个线段上面的线段不会被当前线段影响，因此可以按照高度排序之后处理。首先，我们处理出来对于原来的 $n$ 个点，每个区间内有多少个点；按照线段从高到低排序，对于每个线段先得到该区间 $l_i,r_i$ 之间有 $a$ 个点，然后把整个区间点数变为 $0$，然后左端点、右端点各加上 $a$，以模拟题目中的「分裂」。最后输出整个序列的点数即可。

这个做法有没有错呢？我们考虑这样一个事实：假设我们目前处理到第 $i$ 条线段，对于目前横坐标为 $x$ 的点，只要 $l_i\le x\le r_i$ 且这个点下方的第一条线段就是线段 $i$，那么 $x$ 就会到线段 $i$ 上进行分裂。又因为我们已经按照高度排了序，与线段 $i$ 处于同一高度的影响不到线段 $i$（题目中指出没有重合），比线段 $i$ 高的线段已经处理完了，所以我们这样操作是正确的。

我们考虑使用什么数据结构维护：单点修改，区间推平，查询区间和，我们自然想到了线段树。由于有区间修改操作，我们用一个懒标记表示当前区间是否需要推平。复杂度只有一个 $\log$，可以接受。

虽然最后答案要求取模，为了保险我们开 `long long`。注意到横坐标可能为 $0$，我们将所有横坐标右移一个单位防止线段树出锅。代码如下：

```cpp
const int MAXX=1e5;
struct T{int h,l,r;}e[N];
int x[N],n,m;
bool cmp(T a,T b){return a.h>b.h;}
struct ST{int l,r,sum,flag;}t[N<<2];
inline void build(int p,int l,int r){
	t[p].l=l,t[p].r=r,t[p].flag=0;
	if(l==r){t[p].sum=0;return ;}
	int mid=(l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	t[p].sum=t[p<<1].sum+t[p<<1|1].sum;
}
inline void push(int p){
	if(t[p].flag){
		t[p<<1].flag=t[p<<1|1].flag=1;
		t[p<<1].sum=t[p].sum=t[p<<1|1].sum=0;
		t[p].flag=0;return ;
	}
}
inline void addd(int p,int l,int r,int xx){
	if(t[p].l>=l&&t[p].r<=r){
		push(p);t[p].sum+=xx;
		return ;
	}
	push(p);int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid) addd(p<<1,l,r,xx);
	if(r>mid) addd(p<<1|1,l,r,xx);
	t[p].sum=(t[p<<1].sum+t[p<<1|1].sum)%998244353;
}
inline void adddd(int p,int l,int r){
	if(t[p].l>=l&&t[p].r<=r){
		push(p);t[p].flag=1,t[p].sum=0;
		return ;
	}
	push(p);int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid) adddd(p<<1,l,r);
	if(r>mid) adddd(p<<1|1,l,r);
	t[p].sum=(t[p<<1].sum+t[p<<1|1].sum)%998244353;
}
inline int assk(int p,int l,int r){
	if(t[p].l>=l&&t[p].r<=r) return t[p].sum;
	push(p);
	int res=0,mid=(t[p].l+t[p].r)>>1;
	if(l<=mid) res+=assk(p<<1,l,r);
	if(r>mid) res+=assk(p<<1|1,l,r);
	return res%998244353;
}
signed main(){
	n=read(),m=read();
	build(1,1,MAXX+1);
	for(int i=1;i<=m;i++) e[i].l=read()+1,e[i].r=read()+1,e[i].h=read();
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=n;i++) x[i]=read(),addd(1,x[i]+1,x[i]+1,1);
	for(int i=1;i<=m;i++){
		int nowsum=assk(1,e[i].l,e[i].r);
		adddd(1,e[i].l,e[i].r);
		addd(1,e[i].l,e[i].l,nowsum),addd(1,e[i].r,e[i].r,nowsum);
	}
	printf("%lld",assk(1,1,MAXX+1));
	return 0;
}
```

---

## 作者：Dregen_Yor (赞：3)

# 思路

由于兽是从上往下落的，可以考虑根据 $h_i$ 的大小从大到小进行排序，遍历到第 $i$ 座空岛时，查询区间 $\left[l_i,r_i\right]$ 中兽的数量，之后把区间 $\left[l_i,r_i\right]$ 清零，然后分别在 $l_i$ 和 $r_i$ 上加上区间 $\left[l_i,r_i\right]$ 中兽的数量即可。可以用线段树或其他你喜欢的数据结构来维护。

由于空岛之间没有重叠部分，所以每次更新操作都不会影响同一高度的空岛，只会影响到下面的空岛。

最终输出兽的总数量即可。

时间复杂度 $ \mathcal O (m\log{R})$，其中 $R=\max{r_i}$。

# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define ls x<<1
#define rs x<<1|1
using namespace std;

struct node {
	int l, r, h;
} land[500010];
int n, m, w[100010];
int sum[100010 << 2], tag[100010 << 2];
const int mod = 998244353;

bool cmp(node a, node b) {
	return a.h > b.h;
}

void bulid(int x, int l, int r) {
	if (l == r) {
		sum[x] = w[l];
		sum[x] %= mod;
		return;
	}
	int mid = l + r >> 1;
	bulid(ls, l, mid);
	bulid(rs, mid + 1, r);
	sum[x] = sum[ls] + sum[rs];
	sum[x] %= mod;
}

void pushdown(int x) {
	tag[ls] = tag[rs] = tag[x];
	sum[ls] = sum[rs] = 0;
	tag[x] = 0;
}

void update(int x, int L, int R, int l, int r) {
	if (l >= L && r <= R) {
		tag[x] = 1;
		sum[x] = 0;
		return;
	}
	if (tag[x]) {
		pushdown(x);
	}
	int mid = l + r >> 1;
	if (L <= mid) {
		update(ls, L, R, l, mid);
	}
	if (R > mid) {
		update(rs, L, R, mid + 1, r);
	}
	sum[x] = sum[ls] + sum[rs];
	sum[x] %= mod;
}

void add(int x, int st, int l, int r, int data) {
	if (l == r && l == st) {
		sum[x] += data;
		sum[x] %= mod;
		return;
	}
	int mid = l + r >> 1;
	if (tag[x]) {
		pushdown(x);
	}
	if (st <= mid) {
		add(ls, st, l, mid, data);
	}
	if (st > mid) {
		add(rs, st, mid + 1, r, data);
	}
	sum[x] = sum[ls] + sum[rs];
	sum[x] %= mod;
}

int query(int x, int L, int R, int l, int r) {
	if (l >= L && r <= R) {
		return sum[x];
	}
	if (tag[x]) {
		pushdown(x);
	}
	int mid = l + r >> 1, res = 0;
	if (L <= mid) {
		res += query(ls, L, R, l, mid);
	}
	if (R > mid) {
		res += query(rs, L, R, mid + 1, r);
	}
	return res;
}

signed main() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= m; i++) {
		scanf("%d%d%d", &land[i].l, &land[i].r, &land[i].h);
	}
	for (int i = 1; i <= n; i++) {
		int x;
		scanf("%lld", &x);
		w[x]++;
	}
	sort(land + 1, land + 1 + m, cmp);
	bulid(1, 1, (int)1e5);
	for (int i = 1; i <= m; i++) {
		int l = land[i].l, r = land[i].r;
		int tmp = query(1, l, r, 1, (int)1e5);
		//printf("%d%d%d\n", l, r, tmp);
		update(1, l, r, 1, (int)1e5);
		add(1, l, 1, (int)1e5, tmp);
		add(1, r, 1, (int)1e5, tmp);
	}
	printf("%lld", sum[1]%mod);
	return 0;
}
```


---

## 作者：Tzs_yousa (赞：1)

## 解题思路
观察这道题，显而易见答案可能会很大，一个点一个点深搜一定会爆，所以我们就要找其中的内在联系，来节省很多的步骤。

首先，我们发现每个碎块先掉到哪个线段，这个碎块最后的贡献也就是从这个线段两端掉下去的碎块的贡献只和，而这两个新的碎块也是独立的整体，也就是说，每个线段的贡献可以递推获得。

总的来说，就是原碎块贡献=碎块所到线段贡献=线段左端落下的碎块的贡献+线段右端落下的碎块的贡献。

## 具体步骤
每个线段的贡献只与它下面的最近的线段有关系，所以可以按高度把线段排序，然后 $n^2$ 查询，看起来是 $n^2$，但是实际执行起来却是飞快的。

最后，只需要枚举每个碎块，看先落到哪个线段上，那这个碎块最后的贡献就是这个线段的贡献。

## 代码
```cpp
#include <bits/stdc++.h>
#define re register
const int MAXN = 5e5 + 10;
const int mod = 998244353;
using namespace std;
int n, m, ans;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

struct node {
	int l, r, h, w;
} e[MAXN];

bool cmp(node x, node y) {
	return x.h < y.h;
}

signed main() {
	n = read(), m = read();
	for (re int i = 1; i <= m; i++) {
		e[i].l = read();
		e[i].r = read();
		e[i].h = read();
	}
	sort(e + 1, e + m + 1, cmp);
	e[1].w = 2;
	for (re int i = 2; i <= m; i++) {
		int fz = 0, fy = 0;
		for (re int j = i - 1; j >= 1; j--) {
			if (e[i].l >= e[j].l && e[i].l <= e[j].r && fz == 0) {
				fz = 1;
				(e[i].w += e[j].w) %= mod;
			}
			if (e[i].r >= e[j].l && e[i].r <= e[j].r && fy == 0) {
				fy = 1;
				(e[i].w += e[j].w) %= mod;
			}
			if (fz && fy)
				break;
		}
		if (!fz)
			e[i].w += 1;
		if (!fy)
			e[i].w += 1;
	}
	for (re int i = 1; i <= n; i++) {
		int p;
		p = read();
		int fl = 0;
		for (re int j = m; j >= 1; j--) {
			if (p >= e[j].l && p <= e[j].r && fl == 0) {
				fl = 1;
				(ans += e[j].w) %= mod;
				break;
			}
		}
		if (fl == 0)
			(ans += 1) %= mod;
	}
	printf("%d", ans);
	return 0;
}
```


---

## 作者：Gumbo (赞：1)

具体思路已有很多大佬讲解，这里仅简要说明：

根据以下简化题意：

- 有 $m$ 条线段，$n$ 个球。
- 每个球每次碰到线段时会变成 $2$ 个，分别出现在碰到线段的两端。
- 求下落过程结束后有多少个球。
- $1\le n,m\le10^5$

我们这么做：

1. 我们将线段按照从高到低（也就是球可能触碰的顺序）排列，保证后面的线段影响不到前面。

2. 我们按这个顺序枚举线段，找到这一段有几个球，之后将这些球清除（区间清除），最后再于两端按题意加上新的球。

这就是大概的实现步骤，接下来是代码：

---
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename a,typename b>struct mpair{a first;mutable b second;bool operator<(const mpair&oth)const{return first<oth.first;}};
set<mpair<int,int>>tree;
pair<int,mpair<int,int>>lines[500005];
int main(){
    int n,m,i,x,u,ans=0;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;++i)scanf("%d%d%d",&lines[i].second.first,&lines[i].second.second,&lines[i].first);
    for(i=1;i<=n;++i){
        scanf("%d",&x);
        ++tree.insert({x,0}).first->second;
    }
    ans=n%998244353;
    sort(lines+1,lines+m+1);
    set<mpair<int,int>>::iterator l,r,j;
    for(i=m;i>=1;--i){
        u=0;
        l=tree.lower_bound({lines[i].second.first,0});
        r=tree.upper_bound({lines[i].second.second,0});
        for(j=l;j!=r;++j)u+=j->second,u%=998244353,ans+=j->second,ans%=998244353;
        tree.erase(l,r);
        tree.insert({lines[i].second.first,0}).first->second+=u;
        tree.insert({lines[i].second.second,0}).first->second+=u;
        tree.insert({lines[i].second.first,0}).first->second%=998244353;
        tree.insert({lines[i].second.second,0}).first->second%=998244353;
    }
    cout<<ans%998244353;
    return 0;
}
```
---
这里我主要分享的就是代码实现中的一些技巧：

首先，为了降低代码难度，我放弃了线段树，选择去打一个比较暴力的数据结构。
>珂朵莉树（ODT）

但是，由于我发现这个题不需要维护区间，我就将其魔改成了简单的 `set`，用来维护一些点。

---
我们来从上到下依次看一遍：
- 头文件之类的，不细讲。
- 然后是一个压得有点厉害的结构体，这里我是因为 `set` 自带 `const`，就写了个 `mutable` 的 `pair` 来用。
- 之后是定义需要的数据结构，一个是类似于 `ODT` 的东西，另一个就是存储线段的一维数组。
- 然后是输入，这里因为 `set` 里面的元素不能重复，我们就利用 `insert` 函数的特性来完成我们的操作，具体可以看一下 `insert` 的返回值类型以辅助理解。
- 之后排序，用 `pair` 就是方便。
- 然后是重点内容：模拟下落中的变化：
-  我们先利用二分找到所需的区间的首尾，然后就是套上珂朵莉树板子，先累加后清除，最后产生下一代球即可。

---
这里我还使用了一个技巧：因为当且仅当一个球碰到一个线段时，球的数量会增加，因此我们只要把过程中的触碰数累加起来就很容易得到最终答案，无需再遍历。

---
完


---

## 作者：sixrc (赞：0)

由于在一条线段上分裂，一定会掉到某两条高度比它小的线段上（也有可能掉到 $x$ 轴上），所以考虑递推。

具体的，把所有线段按高度从低到高排序。定义 $f_i$ 表示从第 $i$ 条线段掉落的答案，设 $ql_i,qr_i$ 分别为从第 $i$ 条线段左端点、右端点往下掉落到达的线段编号。则画图后容易写出：

$$f_i=f_{ql_i}+f_{qr_i}+[ql_i=0]+[qr_i=0]$$

由于我们站在一个很高的地方，所以从这个地方掉下去，一定会掉到最后一次覆盖该横坐标的线段上，每次操作时就要求出哪条线段是覆盖这个横坐标的最高的线段。这是一个区间覆盖单点查询问题，从低到高依次区间覆盖，用线段树维护即可，实现可以看代码。

然而只这样会 WA 95 pts，而且是 WA 第一个点（赛时无比绝望

这是因为有可能掉下去不会碰到线段，这种情况要特判输出 $1$。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define lc(x) x<<1
#define rc(x) x<<1|1
const int maxn = 100000;
const int mo = 998244353;
int n, m, ans, x, f[500010], d[2000010], tag[2000010];
struct node{
	int l, r, h;
	bool operator < (const node &A) const{
		if (h == A.h) return l < A.l;
		return h < A.h;
	}
}a[500010];
void pushdown(int k){
	if (tag[k]){
		d[lc(k)] = tag[k];
		d[rc(k)] = tag[k];
		tag[lc(k)] = tag[k];
		tag[rc(k)] = tag[k];
		tag[k] = 0;
	}
}
void modify(int k, int l, int r, int x, int y, int p){
	if (x <= l && r <= y){
		d[k] = p;
		tag[k] = p;
		return ;
	}
	int mid = l + r >> 1;
	pushdown(k);
	if (x <= mid) modify(lc(k), l, mid, x, y, p);
	if (y > mid) modify(rc(k), mid+1, r, x, y, p);
}
int query(int k, int l, int r, int x){
	if (l == r) return d[k];
	int mid = l + r >> 1, ret = 0;
	pushdown(k);
	if (x <= mid) ret = query(lc(k), l, mid, x);
	else ret = query(rc(k), mid+1, r, x);
	return ret;
}
signed main(){
	scanf ("%lld%lld", &n, &m);
	for (int i=1; i<=m; i++){
		scanf ("%lld%lld%lld", &a[i].l, &a[i].r, &a[i].h);
	}
	sort (a+1, a+m+1);
	for (int i=1; i<=m; i++){
		int L = a[i].l, R = a[i].r;
		int ql = query(1, 0, maxn, L), qr = query(1, 0, maxn, R);
		if (ql == 0 && qr == 0) f[i] = 2;
		else if (ql == 0 || qr == 0) f[i] = (f[ql] + f[qr] + 1) % mo;
		else f[i] = (f[ql] + f[qr]) % mo;
		modify(1, 0, maxn, L, R, i);
	}
	for (int i=1; i<=n; i++){
		scanf ("%lld", &x);
		int tmp = f[query(1, 0, maxn, x)];
		if (!tmp) ans ++;
		else ans += tmp;
		ans %= mo;
	}
	printf ("%lld\n", ans);
	return 0;
}
```

---

## 作者：IQ勇士 (赞：0)

题意：在平面直角坐标系的 $X$ 轴上方给出 $m$ 条平行于 $X$ 轴的线段，有 $n$ 个给出横坐标的点从直线 $ y=10^9$ 向下落，每碰到一条线段之后会分裂为两个点分别从线段的两个端点落下，问最终会有多少个点到达 $X$ 轴。

在给出所有线段之后，每个点对答案的贡献仅跟其横坐标有关，所以我们考虑预处理一个以点的横坐标为下标，元素为每一个对应横坐标的点对答案的贡献的数组（不妨命名为 $f$），然后进行单点查询。

在不存在任何线段的时候，显然每一个点对答案的贡献都是 $1$。因为高度较大的线段会覆盖下方的线段，所以我们应当按照线段的高度由低到高排序，然后依次进行处理。每处理到一条线段 $l$，$r$，$y$，都需要将区间 $[l, r]$ 的元素都替换为 $f_l+f_r$（想想为什么）。容易发现，我们需要对数组进行区间修改，单点查询的操作，于是考虑使用线段树（机房的大佬说写树状数组码量小，但是我不会 QWQ）。预处理好了 $f$ 数组，我们就只需要一边读入一边累加 $ans$ 就行了。下面给出代码：

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
const int mod = 998244353;
struct island{//线段
	int y;
	int l;
	int r;
}land[500001];
struct tree{
	int tag;
	int sum;
}f[400001];
void build(int index, int l, int r)//建线段树
{
	f[index].tag = 0;
	if(l == r)
		f[index].sum = 1;
	else
	{
		int m = (l + r) / 2;
		build(index * 2, l, m);
		build(index * 2 + 1, m + 1, r);
	}
}
bool noj(int l1, int r1, int l2, int r2)//判断区间[l1,r1]是否与区间[l2,r2]完全无交
{
	return r1 < l2 || r2 < l1;
}
bool qb(int l1, int r1, int l2, int r2)//判断区间[l1,r1]是否完全包含区间[l2,r2]
{
	return l1 <= l2 && r1 >= r2;
}
void tagging(int index, int t, int l, int r)//标记
{
	if(t)
		if(l == r)
			f[index].sum = t % mod;
		else
			f[index].tag = t % mod;
}
void pushdown(int index, int l, int r)//下传懒标记
{
	int m = (l + r) / 2;
	tagging(index * 2, f[index].tag, l, m);
	tagging(index * 2 + 1, f[index].tag, m + 1, r);
	f[index].tag = 0;
}
void xiugai(int L, int R, int l, int r, int index, int x)//区间修改 
{
	if(qb(L, R, l, r))
		tagging(index, x, l, r);
	else if(noj(L, R, l, r))
		return;
	else
	{
		pushdown(index, l, r);
		int m = (l + r) / 2;
		xiugai(L, R, l, m, index * 2, x);
		xiugai(L, R, m + 1, r, index * 2 + 1, x);
	}
}
int getx(int index, int x, int l, int r)//单点查询，在[l,r]区间中寻找下标为x的元素 
{
	if(l == x && r == x)
		return f[index].sum;
	pushdown(index, l, r);
	int m = (l + r) / 2;
	if(l <= x && x <= m)
		getx(index * 2, x, l, m);
	else
		getx(index * 2 + 1, x, m + 1, r);
}
bool cmp(island a, island b)
{
	if(a.y != b.y)
		return a.y < b.y;
	else
		return a.l < b.l;
}
int a;
int ans;
int n, m;
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
		cin >> land[i].l >> land[i].r >> land[i].y;
	sort(land + 1, land + m + 1, cmp);//按高度排序
	build(1, 1, 100000);
	for(int i = 1; i <= m; i++)//预处理
		xiugai(land[i].l, land[i].r, 1, 100000, 1, (getx(1, land[i].l, 1, 100000) + getx(1, land[i].r, 1, 100000)) % mod);
	for(int i = 1; i <= n; i++)
	{
		cin >> a;
		ans = (ans + getx(1, a, 1, 100000)) % mod; 	
	}
	cout << ans;
	return 0;
}
```


---

## 作者：0xFF (赞：0)

#### 题目大意


------------
在一个平面直角坐标系上有 $m$ 条平行于 $x$ 轴的线段，第 $i$ 条线段为 $\left(l_{i}, h_{i}\right)$ 与 $\left(r_{i}, h_{i}\right)$ 的连线。特别注意 $l_{i}$ 可与 $r_{i}$ 相等，此时线段变为一个点。
在直线 $y=10^{9}$ 上有 $n$ 个点，分别位于 $\left(x_{i}, 10^{9}\right)$。

现在，$x$ 轴上这些点逐渐向下（$y$ 轴负方向）移动。若触碰到线段，则会一分为二，分裂出的两个点分别从线段的两端继续向下移动。
问所有初始点在经历了线段的分裂后，在最后会有多少个点掉在 $x$ 轴上。

#### 思路分析


------------
在 $x$ 轴上建立一颗值域线段树，初始时将所有的单点加入 $n$ 个点，将所有的线段按照高度排序，因为对高的线段操作一定不会影响其他线段的操作且操作完后高的线段就对答案不产生贡献。

对于每一个线段，找出 $[l_i,r_i]$ 的点的个数，同时在 $l_i$ 和 $r_i$ 单点加上这个个数，并将 $(l_i,r_i)$ 内的点全部清空。

所以原题转化为区间赋 $0$，单点加、求区间和。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int N = 1e5 + 10;
const int INF = 1e9 + 7;
const int mod = 998244353;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
    return x*f;
}
struct Tree{
	int l,r,sum;
	int cover;
}tree[N<<2];
void push_up(int p){
	tree[p].sum = (tree[p<<1].sum % mod + tree[p<<1|1].sum % mod) % mod;
}
void build(int p,int l,int r){
	tree[p].l = l , tree[p].r = r;
	tree[p].cover = 0;
	if(l == r){
		tree[p].sum = 0;
		return;
	}
	int mid = l + r >> 1;
	build(p<<1,l,mid); build(p<<1|1,mid+1,r);
	push_up(p);
}
void push_down(int p){
	if(tree[p].cover != 0){
		tree[p<<1].cover = tree[p<<1|1].cover = 1;
		tree[p<<1].sum = tree[p].sum = tree[p<<1|1].sum = 0;
		tree[p].cover = 0;
	}
}
void modify1(int p,int l,int r,int k){
	if(l <= tree[p].l && tree[p].r <= r){
		push_down(p);
		tree[p].sum += k;
		return;
	}
	push_down(p);
	int mid = tree[p].l + tree[p].r >> 1;
	if(l <= mid) modify1(p<<1,l,r,k);
	if(r >  mid) modify1(p<<1|1,l,r,k);
	push_up(p);
}
void modify2(int p,int l,int r){
	if(l <= tree[p].l && tree[p].r <= r){
		push_down(p);
		tree[p].cover = 1;
		tree[p].sum = 0;
		return;
	}
	push_down(p);
	int mid = tree[p].l + tree[p].r >> 1;
	if(l <= mid) modify2(p<<1,l,r);
	if(r >  mid) modify2(p<<1|1,l,r);
	push_up(p);
}
int query(int p,int l,int r){
	if(l <= tree[p].l && tree[p].r <= r){
		return tree[p].sum % mod;
	}
	push_down(p);
	int res = 0;
	int mid = tree[p].l + tree[p].r >> 1;
	if(l <= mid) res += query(p<<1,l,r);
	if(r >  mid) res += query(p<<1|1,l,r);
	return res % mod;
}
struct Node{
	int l,r,h;
}a[N];
bool cmp(Node a,Node b){
	return a.h > b.h;
}

signed main(){
	int n = read() , m = read();
	build(1,1,100001);
	for(int i=1;i<=m;i++){
		a[i].l = read() + 1, a[i].r = read() + 1, a[i].h = read();
	} 
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=n;i++){
		int x = read() + 1;
		modify1(1,x,x,1);
	}
	for(int i=1;i<=m;i++){
		int res = query(1,a[i].l,a[i].r);
//		printf("%lld %lld\n",i,res);
		modify2(1,a[i].l,a[i].r);
		modify1(1,a[i].l,a[i].l,res);
		modify1(1,a[i].r,a[i].r,res);
	}
	printf("%lld\n",query(1,1,100001)%mod);
	return 0;
}

```


---

## 作者：cachejtt (赞：0)

# B
### 思路
用一个数组 $f$ 表示：若从 $i$ 点释放一个碎片，则最终能变成 $f_i$ 个碎片。因此若输入数据为 $x_1,x_2,\dots,x_n$，则答案为 $ f_{x_1}+f_{x_2}+\dots+f_{x_n} $。

考虑如何预处理 $f$ 数组。一开始，在没有悬浮岛的情况下，显然 $f_i=1$。

因为对于某个平台 $l$ 到 $r$，左边可以掉下去 $f_l$ 个，右边可以掉下去 $f_r$ 个，那么对于这个平台上方的所有点，都应该可以产生 $f_l+f_r$ 个碎片。由于上方的平台会影响下方的平台，所以我们应该将平台排序，从低向高修改。

因此考虑对于区间 $l$ 到 $r$，我们应当把 $f_l,f_{l+1},\dots,f_r$ 全赋值为 $f_l+f_r$。此时若暴力推平，时间复杂度过不了，因此我们需要一种高效的可以实现区间推平与单点查询的工具，因此使用线段树。

### 代码
记得取模。
```cpp
#include<bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define nrep(i, a, b) for (int i = (a); i >= (b); --i)
#define ll long long
#define endl "\n"
using namespace std;
const int p=998244353;//0x3B800001
int n,m,maxr;
int v[400100],lazy[400100];
struct node{
  int l,r,h;
}e[500005];
bool cmp(node x,node y){
  return x.h<y.h;
}
void push_up(int x){
  v[x]=v[x<<1]+v[x<<1|1];
  v[x]%=p;
}
void push_down(int x,int l,int r){
  if(lazy[x]){
    int mid=(l+r)>>1;
    v[x<<1]=lazy[x]*(mid-l+1)%p;
    v[x<<1|1]=lazy[x]*(r-mid)%p;
    lazy[x<<1]=lazy[x]%p;
    lazy[x<<1|1]=lazy[x]%p;
    lazy[x]=0;
  }
}
void build(int x,int l,int r){
  if(l==r){
    v[x]=1;
    return;
  }
  int mid=(l+r)>>1;
  build(x<<1,l,mid);
  build(x<<1|1,mid+1,r);
  push_up(x);
}
void update(int x,int l,int r,int s,int t,int k){
  if(s<=l&&r<=t){
    v[x]=k*(r-l+1)%p;
    lazy[x]=k%p;
    return;
  }
  push_down(x,l,r);
  int mid=(l+r)>>1;
  if(mid>=s)update(x<<1,l,mid,s,t,k);
  if(mid+1<=t)update(x<<1|1,mid+1,r,s,t,k);
  push_up(x);
}
int q(int x,int l,int r,int s,int t){
  if(s<=l&&r<=t){
    return v[x];
  }
  push_down(x,l,r);
  int mid=(l+r)>>1;
  int ans=0;
  if(mid>=s)ans+=q(x<<1,l,mid,s,t),ans%=p;
  if(mid+1<=t)ans+=q(x<<1|1,mid+1,r,s,t),ans%=p;
  return ans;
}
signed main(){
  ios::sync_with_stdio(0);
  cin>>n>>m;
  rep(i,1,m){
    cin>>e[i].l>>e[i].r>>e[i].h;
  }
  maxr=100001;
  build(1,0,maxr);
  sort(e+1,e+m+1,cmp);
  rep(i,1,m){
    update(1,0,maxr,e[i].l,e[i].r,(q(1,0,maxr,e[i].l,e[i].l)+q(1,0,maxr,e[i].r,e[i].r))%p);
  }
  int tmp,sum=0;
  rep(i,1,n){
    cin>>tmp;
    sum+=q(1,0,maxr,tmp,tmp);
    sum%=p;
  }
  cout<<sum<<endl;
  return 0;
}
```

---


# [CoE R5/Stoi2029] 半岛铁盒

## 题目背景

> 为什么这样子 你拉着我 说你有些犹豫  
> 怎么这样子 雨还没停 你就撑伞要走  
> 已经习惯 不去阻止你 过好一阵子 你就会回来  
> 印象中的爱情 好像顶不住那时间  
> ——《[半岛铁盒](https://www.bilibili.com/video/BV1fx411N7bU?p=26)》

## 题目描述

**题意简述**

给定一个 $n$ 个顶点 $m$ 条边的无向图，可能有重边自环，可能不连通。

初始时每个顶点有点权，点权为随机正实数。现在需要重新分配每个顶点的点权，使得：

1. 相邻顶点的点权中较大者与较小者之比不超过 $x$；

2. 点权总和不变；

3. 每个顶点的点权不小于初始时的 $\dfrac{p}{q}$。

求最小的 $x \ge 1$，使得对于给定的图，无论初始点权如何，均存在一种满足上述要求的重新分配方式。

---

**原版题面**

神在半岛铁盒里创建了一个世界。

这个世界由 $n$ 个地域和地域之间的 $m$ 条通道组成，每条通道连接两个地域。创世时每个地域有一定的气压，气压为正数。

由于世界刚刚创建，比较混乱，所以两个地域之间可能有多条通道相连，一个地域也有可能有通道连接到自身，两个地域也可能无法通过若干条通道相互通行。

由于通道连接的两个地域气压之比（大比小，下同）过大时会在通道里形成强风，使得跨地域旅行非常危险，所以造世神决定调整每个地域的气压使得每条通道连接的两个地域气压之比都不超过安全比值 $x$。显然 $x \ge 1$。

由于各种守恒定律被打破会很麻烦，所以神希望调整前后所有地域的气压之和不变。

由于世界中的生物无法在过低的气压中生存但对高气压的适应力强，因此每个地域改变后的气压必须不低于初始的 $\dfrac{p}{q}$。

由于创世时气压不受神控制地随机，所以神希望安全比值 $x$ 满足无论初始气压如何都存在一种合适的调整气压的方法。

由于通道越宽敞，通行越舒适，但是安全比值 $x$ 也越小，因此神想要求出满足要求的最小安全比值 $x$。

由于神忙着处理创世事务，所以他钦定你来解决这个问题。

## 说明/提示

**数据范围**

对于 $10\%$ 的数据，$np \le q$；

对于另外 $20\%$ 的数据，有一个地域和其他所有地域之间有通道相连；

对于另外 $30\%$ 的数据，通道构成一棵树。

对于 $100\%$ 的数据，$1 \le u,v \le n \le 10^3$，$1 \le m \le 3 \times 10^4$，$1 \le p<q \le 10^7$。

## 样例 #1

### 输入

```
3 2 1 2
1 2
2 3
```

### 输出

```
2.0000000
```

## 样例 #2

### 输入

```
10 20 13 37
1 2
1 3
1 5
2 4
2 5
2 6
3 4
3 5
3 7
3 9
3 10
4 6
4 7
4 8
5 7
5 9
7 8
7 9
7 10
9 10
```

### 输出

```
3.6903390
```

# 题解

## 作者：takanashi_mifuru (赞：9)

### 简要题意：

给定一个 $n$ 个顶点 $m$ 条边的无向图，可能有重边自环，可能不连通。

初始时每个顶点有点权，点权为随机正实数。现在需要重新分配每个顶点的点权，使得：

1. 相邻顶点的点权中较大者与较小者之比不超过 $x$；

2. 点权总和不变；

3. 每个顶点的点权不小于初始时的 $\dfrac{p}{q}$。

求最小的 $x \geqslant 1$，使得对于给定的图，无论初始点权如何，均存在一种满足上述要求的重新分配方式。

### 思路

求的是最小，所以只考虑最劣的情况。

容易发现最劣的情况就是，一个源点的权值为无穷大（$10^9$），其他的近似于 $0$。（干脆直接取 $0$）

为什么这是对的呢？感性理解一下，如果这张图再增加任何一个还有值的源点，此时就有两个源点共同分担同一个安全系数，这明显是比我们给出的图要优的，所以不能取。

考虑枚举源点。

再考虑安全系数，容易发现，安全系数是具有单调性的，如果相邻顶点的点权中较大者与较小者之比不超过 $x$，那么这个比也一定不会超过任何比 $x$ 要大的数。

然后就可以二分安全系数 $x$，考虑 check 怎么写。

容易发现，只要让相邻的点的比刚好卡在 $x$ 上就一定是对的，否则的话会让源点分出去更多的权值，反而不优。

这样直接根据这个思路直接 bfs 判答案，时间复杂度 $O(60n(n+m))$，这个 $60$ 是二分的常数。

然后你发现过不了，被卡成 80 分了，原因是 $n\leqslant10^3,m\leqslant3\times10^4$，而 $60nm$ 卡到极限情况需要枚 $1800000000$ 次，相当于 18 秒，非常低级，考虑怎么优化。

我们发现根本没必要每次二分都 bfs，因为对于同一个源点每次 bfs 出来的搜索顺序是一样的，我们考虑先把搜索顺序搜出来，然后按照搜索顺序直接 dp，这样一次时间复杂度是 $O(n)$ 的，于是这个题时间复杂度被优化成了  $O(n(n+m)+60n^2)$，可以通过。

卡得很恶心

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,p,q;
double F;
int cnt;
int head[60005];
int nxt[60005];
int edge[60005];
void addedge(int u,int v){
   cnt++;
   nxt[cnt]=head[u];
   head[u]=cnt;
   edge[cnt]=v;
   return;
}
double ans=0;
double D[1005];
bool vis[1005];
int dep[1005];
inline void bfs(int S){
   for(int i=1;i<=n;i++){
      dep[i]=0;
      vis[i]=false;
   }
   queue<int> q;
   q.push(S);
   vis[S]=true;
   dep[S]=1;//dep表示搜索顺序
   while(!q.empty()){
      int t=q.front();
      q.pop();
      for(int i=head[t];i;i=nxt[i]){
         int v=edge[i];
         if(vis[v])continue;
         vis[v]=true;
         dep[v]=dep[t]+1;
         q.push(v);
      }
   }
   return ;
}
bool check(double x){
   double sum=1.*(q-p)/q;//sum表示我可以分出去的最多的权值
   D[0]=0;
   D[1]=1.*p/q;//D[i]表示我在dep为i的点中需要花费的权值大小
   for(int i=1;i<=n;i++){
      if(!dep[i])continue;
      if(dep[i]==1)continue;
      D[dep[i]]=D[dep[i]-1]/x;//由我前一个深度转移下来
      sum-=D[dep[i]];//分出权值
   }
   return sum>=0.;//如果还有权值剩余就说明成功了
}
signed main(){
   scanf("%lld%lld%lld%lld",&n,&m,&p,&q);
   F=1.*p/q;
   for(int i=1;i<=m;i++){
      int u,v;
      scanf("%lld%lld",&u,&v);
      addedge(u,v);
      addedge(v,u);
   }
   for(int i=1;i<=n;i++){//i号点为无穷大
      bfs(i);//求dep
      sort(dep+1,dep+1+n);//为了方便dp
      double lt=1-(1e-7),rt=3e9+1e-7;//二分上下界，我不会算，所以开大点
      int cnt=60;//控制二分次数，不这样会有精度问题
      while(cnt--){
         double mid=(lt+rt)/2;
         if(check(mid)){
            rt=mid;
         }
         else{
            lt=mid;
         }
      }
      ans=max(ans,rt);
   }
   printf("%.7lf",ans);
   return 0;
}
```

---

## 作者：VinstaG173 (赞：7)

事实上我们可以把气压看作可以为非负数，然后令 $y=\dfrac{1}{x}$，将条件改为小比大 $\ge y$。

发现重边和自环没有影响，直接忽略。图不连通时相当于对每个连通图单独处理后取最大值，实现方式完全相同。

称一个状态为 $\mathbb{R_{\ge 0}^n}$ 中的一个向量，其中第 $i$ 维的值为地域 $i$ 的气压。

首先显然有一个结论：若对于两个状态能够做到，那么对于它们的和也能够做到。

从而若要对任意的状态均能够做到，那么只需要对于只有一维不为 $0$ 的状态能够做到。由于每维扩倍没有本质影响，所以相当于只有一维为 $1$ 其余维为 $0$ 时能够做到。

以下考虑如何解决一维为 $1$ 其余维为 $0$ 的情况。首先显然 $\dfrac{p}{q}$ 的限制只对初始气压为 $1$ 的点（设为 $u$）有影响。要使调整后 $u$ 点的气压足够大，则必须要其他点调整后的气压尽量小。显然直接和 $u$ 相连的点的气压至少是 $y$，从而与 $u$ 距离为 $2$ 的点的气压至少是 $y^2$，依此类推，最终我们得到一个不等式：

$$\sum_{d \ge 0}a_dy^d\le\dfrac{q}{p},$$

其中 $a_d$ 表示与 $u$ 距离为 $d$ 的点数，特别地有 $a_0=1$。

由于左边是关于 $y$ 单调递增的，所以可以二分。由于 $y=0$ 时左边小于右边，所以必然有解。发现 $np \le q$ 时任意 $y$ 均满足条件，故答案即为 $1$。

如果有一个点和其他点均有连边的话，那么容易证明只有这个点的点权为 $1$ 是极端情况，我们只要解 $(n-1)y+1\le\dfrac{q}{p}$ 就可以了。

如果是树的话，搜起来会方便一点（？

正解：对每个点 $u$ 进行一次 `dfs` 或 `bfs` 得到 $a$ 数组，然后二分答案即可，时间复杂度 $O(n(m+n\log{s}))$，$s$ 即精度要求。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
#define db long double
int n,m,p,q,u,v,d;
int head[1003],cnt;
int dep[1003],que[1003],hd,tl;
struct edge
{
	int nxt,to;
}e[60007];
inline void add(int x,int y)
{
	e[++cnt].nxt=head[x],e[cnt].to=y,head[x]=cnt;
	e[++cnt].nxt=head[y],e[cnt].to=x,head[y]=cnt;
}
ll a[1003];
inline void bfs(int s)
{
	que[++tl]=s,dep[s]=0;
	while(hd<=tl)
	{
		u=que[hd],++a[dep[u]],++hd;
		for(rg int i=head[u];i;i=e[i].nxt)
		{
			v=e[i].to;if(~dep[v])continue;
			que[++tl]=v,dep[v]=dep[u]+1;
		}
	}
	d=dep[u];
}
inline db calc(db x)
{
	db res=a[d];
	for(rg int i=d-1;~i;--i)res=res/x+a[i];
	return res;
}
inline db solve()
{
	db l=1,r=1e10,md,rs,tp;
	for(rg int i=0;i<=d;++i)a[i]*=p;
	while(r-l>=1e-8)
	{
		md=(l+r)/2,rs=-q,tp=1;
		for(rg int i=0;i<=d;++i)
		{
			rs+=a[i]*tp,tp/=md;
		}
		if(rs>0)l=md;
		else r=md;
	}
	return l;
}
db x,y;
int main()
{
	scanf(" %d %d %d %d",&n,&m,&p,&q);x=1;
	if(n*p<=q)return puts("1.0000000"),0;
	for(rg int i=0;i<m;++i){scanf(" %d %d",&u,&v);if(u!=v)add(u,v);}
	for(rg int i=1;i<=n;++i)
	{
		for(rg int j=0;j<=n;++j)dep[j]=-1,a[j]=0;
		hd=1,tl=0,bfs(i),y=solve();if(y>x)x=y;
	}
	printf("%.7Lf\n",x);
	return 0;
}
```

---

## 作者：Disjoint_cat (赞：3)

2023/08/02 Update：修复几处小错误。

# [P8579 半岛铁盒](https://www.luogu.com.cn/problem/P8579) 题解

好题。

~~这题都快一年了怎么才两篇题解，可能是不好写吧，那我来写一篇~~

## 形式化题意

给一个 $n$ 个点 $m$ 条边的无向图。求最小的满足以下条件的实数 $x$：

> 任意给定长为 $n$ 实数数组 $a$（称为“原始权值”），存在一个长为 $n$ 的实数数组 $b$（称为“最终权值”）满足：
> - 对所有边 $(u,v)$，$\dfrac{\max(b_u,b_v)}{\min(b_u,b_v)}\le x$。
> - $\sum\limits_{i=1}^na_i=\sum\limits_{i=1}^nb_i$。
> - $\forall1\le i\le n,\dfrac{b_i}{a_i}\ge\dfrac{p}{q}$。

$n\le10^3,m\le3\times10^4,1\le p<q\le10^7$。

## 题解

_以下设 $\dfrac{p}{q}=r$。_

### 骗分：$np\le q$

即 $r=\dfrac{p}{q}\le\dfrac{1}{n}$。那么完全可以将权值平均分配。所以 $x=1$。

### 部分分：菊花图

注意到中心点权不能太大，那么不妨将权值全部放在中心点，且设初始权值为 $1$。

此时最优的分配方式肯定是把中心的权值分一些给叶节点（肯定要平均分，不然不优）。

设最后中心节点的权值为 $t$，则由题目限制有：$t=\dfrac{t}{1}\le r$。

由 $x$ 的定义知

$$x\ge\dfrac{t}{\frac{1-t}{n-1}}.$$

不难解得

$$x\ge\dfrac{r(n-1)}{1-r}.$$

### ~~部分分：树~~

不知道有啥做法。于是……

### 正解来了！

接着上面的思路，我们觉得，$x$ 最大时肯定还是初始权值聚集在某一个点。

感性理解即可，最大权值类似等比数列的趋势，相邻两项的差会越来越小。

还是设这个点（下称 $s$）的初始权值为 $1$。

我们考虑二分 $x$，这样 $s$ 的最终权值 $\ge r$，问题转化成“总权值能否大于 $1$”。

那么我们可以从 $s$ 开始 BFS，如果到某个点的最短路经过了 $t$ 条边，则其权值不能大于 $\dfrac{r}{x^t}$。对于每个点 BFS 一遍，如果都满足，答案就比现在的值小，反之亦然。

本题做完了……吗？

这么做的话，需要二分，check 时要枚举 $n$ 个点，每个点要做一次 $\Theta(m)$ 的 BFS。设二分次数为 $c$，总复杂度是 $\Theta(nmc)$，这里 $c$ 大概是几十的量级。

此时，$nm$ 已达 $3\times10^7$，再乘个几十很难通过。我们需要优化。

注意到无论二分的 $x$ 如何变化，对于每个 $s$，其“最大权值和”的（关于 $x$ 的）**表达式**是不变的。

那么我们可以将表达式求出来，这样就不用每次二分都进行 $n$ 次 BFS 了。

具体的，对于每个 $s$，我们执行：

> 以 $s$ 为起点进行 BFS。
> 设到 $s$ 最短路长为 $i$ 的点个数为 $cnt_i$，则它们的最大权值为 $\dfrac{r}{x^i}$。
> 则“最大权值和”的表达式为
> $$\sum\limits_{i=0}^ncnt_i\dfrac{r}{x^i}.$$
> 二分 $x$，如果上式结果 $\ge1$，则答案小于当前二分值，反之亦然。

最后取所有二分值的最大值为答案即可。

这样的话，我们需要做 $n$ 次 BFS + 二分的过程，每次二分需要计算一个最多 $n$ 项的式子。

所以时间复杂度为 $\Theta(nm+n^2c)$，更容易通过。

**注意二分上界的选取，不能取 $10^7$，要取到更大一些，例如 $10^{10}$。**

## 代码

典型的 Talk is cheap, show me the code 题。（主要不是太长，是太烦）

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db long double
#define mp make_pair
#define pii pair<int,int>
using namespace std;
const int N=1005,M=60005;
const db EPS=1e-7;
int n,m,P,Q,u,v,qz[N],cnt[N];
db l,r,x,sum,ma,k;
queue<pii>q;
int head[N],ver[M<<1],nxt[M<<1],tot;
void add(int u,int v)
{
	ver[++tot]=v,nxt[tot]=head[u],head[u]=tot;
}
int main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>P>>Q;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v;
		add(u,v);add(v,u);
	}
	for(int i=1;i<=n;i++)
	{
		memset(qz,-1,sizeof(qz));
		memset(cnt,0,sizeof(cnt));
		while(q.size())q.pop();
		q.push(mp(qz[i]=0,i));
		while(q.size())
		{
			int Qz=q.front().first,now=q.front().second;q.pop();
			if(Qz!=qz[now])continue;
			cnt[Qz]++;
			for(int j=head[now];j;j=nxt[j])
				if(qz[ver[j]]==-1)q.push(mp(qz[ver[j]]=Qz+1,ver[j]));
		}
		l=1.0,r=1e10;
		while(1)
		{
			x=(l+r)/2.0;
			if(x-l<EPS)break;
			sum=0.0,k=(db)P/Q;
			for(int j=0;j<=n;j++)sum+=k*cnt[j],k/=x;
			if(sum<=1.0)r=x;else l=x;
		}
		ma=max(x,ma);
	}
	cout<<fixed<<setprecision(10)<<ma;
	return 0;
}
```

---

## 作者：GY程袁浩 (赞：0)

这里重述一下题目：

> 给定你一张无向图，你来安排每个点的点权 $v_{i}$（为正实数），求安排点权 $v$ 的 $f(v)$ 的最大值。
>
> $f(v)$ 的值为构造一组 $v'_{i}$，使得 $\sum_{i\in V}v'_{i}=\sum_{i\in V}v_{i},\forall i\in V,v'_{i} \ge \frac{p}{q}v_{i}$，构造的所有方案 $\max_{(u,v)\in E}\{\frac{\max(v'_{u},v'_{v})}{\min(v'_{u},v'_{v})}\}$ 的最小值。

思考什么样的 $v$ 可以取到 $f(v)$ 的最大值？结合观察菊花图特殊性质，可能可以想到，对于每个点来说，流出的权值有最大值限制，这可能导致某个相邻点的权值小于它，却没有办法再变大，为了加剧这种情况，我们希望不给那个点任何初始权值。这就引入了一种构造 $v$ 的方法，即单个点有权值，其它点全部近似于 $0$，你可以认为就是 $0$，并且这时候唯一的点不管取什么答案都一样。

现在我们已经初步拟定了 $v$ 的构造方案，现在我们来考虑 $v'$ 的构造方案。观察到最小值有单调性，即如果值 $j$ 能够取到，则 $k>j$ 不可能作为答案。因此我们考虑二分求 $f(v)$ 的值。假设 $f(v)=x$，那么对于以选定点 $i$ 为中心 BFS，深度为 $j$ 的点 $k$，贪心地来看，$v'_{k}$ 就取 $\frac{\frac{p}{q}}{x^{j-1}}$，这样全部取符合条件的所需下界，如果还有剩余就说明合法，也就是 $f(v)\le x$。

对于每个点 $i$，记录离他距离为 $j$ 的点有 $cnt_{j}$ 个，然后二分，再更新答案即可。

时间复杂度 $O(n^2 \log V+nm)$，其中 $V$ 表示二分的值域。

```cpp
// 这回只花了 1s 就打完了。
// 真好。记得多手造几组。最好有暴力对拍。

#include <bits/stdc++.h>
#define int long long
#define double long double
#define upp(a, x, y) for (int a = x; a <= y; a++)
#define dww(a, x, y) for (int a = x; a >= y; a--)
#define pb(x) push_back(x)
#define endl '\n'
#define x first
#define y second
#define PII pair<int, int>
using namespace std;
const int N = 6e4 + 10;
int h[N], ne[N], e[N], idx;
int cnt[N], all[N];
int n, m, p, q;
double rr;
void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
void bfs(int x) {
    queue<int> qq;
    memset(cnt, 0, sizeof cnt);
    memset(all, 0, sizeof all);
    qq.push(x);
    cnt[x] = 1;
    while (qq.size()) {
        auto iter = qq.front();
        qq.pop();
        for (int i = h[iter]; i != -1; i = ne[i]) {
            int j = e[i];
            if (!cnt[j]) {
                cnt[j] = cnt[iter] + 1;
                qq.push(j);
            }
        }
    }
    upp(i, 1, n) all[cnt[i]]++;
}
void solve() {
    double ans = 0;
    cin >> n >> m >> p >> q;
    rr = (double)p / q;
    memset(h, -1, sizeof h);
    upp(i, 1, m) {
        int x, y;
        cin >> x >> y;
        add(x, y);
        add(y, x);
    }
    upp(i, 1, n) {
        bfs(i);
        double l = 0, r = 1e10;
        while (r - l > 1e-7) {
            double mid = (l + r) / 2.0, sum = 0, now = 1;
            upp(j, 1, n) {
                sum += rr / now * all[j];
                now *= mid;
            }
            if (sum <= 1)
                r = mid;
            else
                l = mid;
        }
        ans = max(ans, r);
    }
    cout << fixed << setprecision(7) << ans << endl;
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int tt = 1;
    while (tt--) solve();
    return 0;
}
```

---


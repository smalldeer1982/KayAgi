# 『JROI-8』这是新历的朝阳，也是旧历的残阳

## 题目背景

![1663764375173.png](https://img-kysic-1258722770.file.myqcloud.com/8c10be566f21cceb653f209300936b97/68a6764e14651.png)

>少女于海边伫立，凝视着落日最后的余晖\
“已然过去了呢，旧历的一年......”

**已获得转载授权。**

## 题目描述

给定序列 $\{a_n\}$，满足每一项都不小于前一项。对于所有不超过 $k$ 的正整数 $m$，询问如果将 $a$ 分成 $m$ 段（可以有空段），并给从前往后第 $i$ 段内的每个数都加上 $i$，增加后的 $\sum\limits_{j=1}^n a_j^2$ 最大是多少。询问相互独立，即每次询问时给每个数加的值不保留到下一次询问。

例如，对于序列 $\{-3,1,2,2\}$，若 $m=5$，则一种分段方式是 $[-3][][1,2][][2]$，增加后的序列是 $-2,4,5,7$，此时 $\sum\limits_{j=1}^n a_j^2=94$。

记 $m=i$ 时的答案（即此时最大的 $\sum\limits_{j=1}^n a_j^2$）为 $q_i$，出于良心考虑，你只需要输出 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353$ 即可。标准程序不基于特殊的输出方式，即能独立求出每一个 $q_i$。


## 说明/提示

#### 【样例解释】

当 $m=1$ 时，最优策略是 $[-3,1,2,2]$，$q_1=(-2)^2+2^2+3^2+3^2=26$。

当 $m=2$ 时，最优策略是 $[-3][1,2,2]$，$q_2=(-2)^2+3^2+4^2+4^2=45$。

当 $m=3$ 时，最优策略是 $[-3][][1,2,2]$，$q_3=(-2)^2+4^2+5^2+5^2=70$。

则 $\left(\sum\limits_{i=1}^k q_i\right) \bmod 998244353=(q_1+q_2+q_3)\bmod 998244353=(26+45+70)\bmod 998244353=141$。

#### 【数据范围与约束】

| 测试点编号 | 分数 | $n\leq$ | $k\leq$ | $\lvert a_i\rvert \leq$ | 特殊性质 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1\sim 3$ | $15$ | $12$ | $12$ | $1000$ | 无 |
| $4\sim 6$ | $15$ | $1000$ | $1000$ | $1000$ | 无 |
| $7\sim 8$ | $10$ | $10^6$ | $10^6$ | $10^7$ | $a_i\geq0$ |
| $9 \sim 12$ | $20$ | $10^6$ | $1000$ | $10^7$ | 无 |
| $13\sim 20$ | $40$ | $10^6$ | $10^7$ | $10^7$ | 无 |


## 样例 #1

### 输入

```
4 3
-3 1 2 2```

### 输出

```
141```

# 题解

## 作者：wdgm4 (赞：19)

~~考试时没考虑到会爆 long long ，痛失 30 分，发题解留个纪念。~~

------------

## 暴力的思路

我首先思考如何暴力（首先提醒，暴力会**超时**，但可以从暴力出发引出正解,~~反正我考试时先打的暴力，再去探索 AC 思路~~，如果想直接看 AC 思路可以跳过），题目中说如果将 $a$ 分成 $m$ 段（**可以有空段**），并从前往后第 $i$ 段内的每个数都加上 $i$。我考试时读到这，一个~~邪恶的~~贪心思路浮出我的脑海。例如题目样例，我们可以像下面这样：

```[-3][][]....[][1,2,2]```

利用贪心，我们让负数都放在最左面的一段里，让正数放在最右面的一段里，这样既能保证负数在加 $i$ 后**还为负数**时平方最大，正数平方最大。但有可能负数加上 $i$ 变为正数且它的平方比原来的平方大，所以我们只需要加一个判断即可。

### 超时代码
```cpp
#include<bits/stdc++.h>
#define XD 114514

using namespace std;
int n,k;
const int mod=998244353;
long long a[1000010],ans;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	} 
	for(int i=1;i<=k;i++){
		for(int j=1;j<=n;j++){
			if(abs(a[j]+1)>abs(a[j]+i)){//判断放最左面还是最右面
				ans+=(a[j]+1)*(a[j]+1);
				ans%=mod;
			}else{
				ans+=(a[j]+i)*(a[j]+i);
				ans%=mod;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

时间复杂度：$O(nk)$。

当然，由于是暴力，我们只能得 30 分，其他全部 TLE。看来需要优化一下了。

## AC思路

让我们返回到题目界面（[传送门](https://www.luogu.com.cn/problem/P8590)），题目中要算的公式整理为 $\sum\limits_{i=1}^k  {\sum\limits_{j=1}^na_j^2}$（其中 $a_j$ 的值随 $i$ 的变化而变化），我们简单转换一下，变成 $\sum\limits_{i=1}^n{\sum\limits_{j=1}^ka_i^2}$（其中 $a_i$ 的值随 $j$  的值变化而变化），而在新算式中，$\sum\limits_{j+1}^ka_i^2$ 能够用 $O(1)$ 的复杂度算出来。

我们可以先用一个前缀和 $b$，$b_i$ 表示前 $i$ 个数的平方的和。计算时分两种情况：

- 如果 $a_i$ 大于等于 $0$，在分段中放在最右面一定最优，所以用前缀和计算即可。

- 如果 $a_i$ 小于 $0$，在分段时最优的分段位置不同，需要特殊判断（具体内容请看代码）。

思路就先差不多，下面放下代码。

## code

```cpp
#include<bits/stdc++.h>
#define XD 114514

using namespace std;
long long n,k;
long long m,f;
const long long mod=998244353;
const int MAXN=20000000;
long long a[1000010];
long long ans,num;
int b[20000010];//前缀和
int main(){
	cin>>n>>k;
	for(long long i=1;i<=MAXN;i++){
		b[i]=(b[i-1]+i*i%mod)%mod;//计算前缀和
	}
	for(register int i=1;i<=n;i++){
		num=0;
		scanf("%lld",&a[i]);
		if(a[i]<0){//分情况讨论
			m=(a[i]+1)*(-2)+1;
			f=-(a[i]+1);
			num+=min(m,k)*1ll*f%mod*f;//注意这里一定要取模一次，不然会爆long long
			num%=mod;
			if(k>m){
				num+=(b[k-m+f]*1ll-b[f]+mod)%mod;
				num%=mod;
			}
		}else{
			num+=(b[a[i]+k]*1ll-b[a[i]]+mod)%mod;
			num%=mod;
		}
		ans+=num;
		ans%=mod;
	} 
	cout<<ans%mod;
	return 0;
}
```

时间复杂度：$O(n)$（还要加一个计算前缀和的大常数）

## 注意事项

1. 注意取模问题，算减法取模时要先加上 $mod$ 再取模。

2. 在几个数连乘时，要记得在中间取模，不然会爆 ```long long```，~~然后痛失 30 分~~。

3. 前缀和数组千万不要开 ```long long```，不然你会[MLE](https://www.luogu.com.cn/record/91195193)。

---

## 作者：ScottSuperb (赞：8)

## 解法分析
贪心。我们分正负数两种情况分析：

对于正数。因为可以有空段，那么把所有正数都放最后一段就行了。利用初中简单整式乘法知识推一下每轮结果是如何增加的：首先由完全平方公式 $(a+b)^2=a^2+2ab+b^2$ 可知 $(a+1)^2=a^2+2a+1$，那么 $a_1,a_2,a_3,\ldots,a_n$ 同时加上 $1$ 后的平方和便为：
$${\sum a_i^2+2\times \sum a_i}+n$$
代码实现中用变量 $q$ 记录上一轮的结果（$\sum a_i^2$），所有正数之和为 $psum$（$\sum a_i$），每一轮 $q\gets q+psum\times 2+n,\ psum\gets psum+n$ 即可。

对于负数。首先想让平方和大就是要让绝对值大，那么在某个负数加上段数（就是把它放在最后一段会给它加上的数）后的绝对值大于它加 $1$（即放在第一段）的绝对值之前，都要把它放在第一段。**换言之，对于一个负数 $a$，在 $\left | a+m \right | >\left | a+1 \right | $ 之前，都要让它在第一段。**那么当它满足放在最后一段的条件后，就可以愉快地让它加入正数之列了，可以再用变量 $b$ 记录第一个正数的位置，每次有新数加入时 $b\gets b-1,\ n\gets n+1,\ psum\gets psum+a+m,\ q\gets q+\Delta$（$\Delta =(a+m)^2-(a+1)^2$，即答案差）即可。

## 代码
先算出第一轮（$m=1$）中各变量的值，后面循环求。  
读写函数定义已省略。
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define mod 998244353

ll a[1000005];

int main() {
  int n = read(), k = read(), b = 0;
  ll q = 0, ans = 0, psum = 0, del;
  for (int i = 0; i < n; ++i)
    a[i] = read(), b += a[i] < 0, q = (q + (a[i] + 1) * (a[i] + 1) % mod) % mod;
  ans += q;
  for (int i = b; i < n; ++i) psum = (psum + a[i] + 1 % mod) % mod;
  n = n - b;
  for (int m = 2; m <= k; ++m) {
    ans = (ans + (q = (q + psum * 2 % mod + n) % mod)) % mod,
    psum = (psum + n) % mod;
    while (b > 0 && a[b - 1] + m > abs(a[b - 1] + 1)) {
      --b, ++n;
      del = (a[b] + m) * (a[b] + m) % mod - (a[b] + 1) * (a[b] + 1) % mod;
      ans = (ans + del) % mod, q = (q + del) % mod, psum = (psum + (a[b] + m) % mod) % mod;
    }
  }
  write(ans);
  fls();
  return 0;
}

```

---

## 作者：xwh_Marvelous (赞：7)

首先我们发现一个数要么在第一个段要么在最后一个段。

对于一个数，我们要直接比较它平方后的大小，最方便的方法就是比较它的绝对值，而如果分到中间，如果这个数加上 $i$ 是负数，那么向左分肯定更优，那么最优的就是 $1$；正数就向右分更优，最优的就是 $k$。

那么我们再观察如何分。

非负数肯定是无脑往右分，而负数就有两种情况：

1. $(a_i+k)^2\le(a_i+1)^2$ 那么我们就分到最左。
1. $(a_i+k)^2>(a_i+1)^2$ 那么我们就分到最右，而且 $a_i+k>0$，因为如果 $a_i+k<0$，那么肯定不会比 $a_i+1$ 更优。

我们现在还要想如何优化掉对 $i$ 的枚举。

我们观察上面的式子，假设 $a_i$ 会被分到最右：

$$(a_i+k)^2>(a_i+1)^2$$

我们假设有一个数为 $b>a_i$，$b-a_i=g$，那么根据

$$(b+k)^2=(a_i+k)^2+2g(a_i+k)+g^2 $$
$$(b+1)^2=(a_i+1)^2+2g(a_i+1)+g^2 $$
$$\because (a_i+k)^2>(a_i+1)^2,a_i+k\ge a_i+1$$
$$\therefore (b+k)^2-(b+1)^2=(a_i+k)^2+2g(a_i+k)-(a_i+1)^2-2g(a_i+1)\ge0$$
$$\therefore (b+k)^2>(b+1)^2$$
我们发现，如果一个数分到了最右，那么所有比它大的数也会分到最右。

如果二分这个位置会多一个 $\log$，会 TLE。我们再来观察一下这个位置的性质。

我们再假设 $a_i$ 会被分到最右：

$$(a_i+k)^2>(a_i+1)^2$$

我们现在给一个 $g=k+1$，观察这个位置：

$$(a_i+g)^2=(a_i+k+1)^2=(a_i+k)^2+2(a_i+k)+1$$
$$\because (a_i+k)^2>(a_i+1)^2,a_i+k>0$$
$$\therefore (a_i+k)^2+2(a_i+k)+1>(a_i+1)^2$$
$$\therefore (a_i+g)^2>(a_i+1)^2$$

我们能发现一个数在一个较小的 $k$ 中分到了最右，那么它就再也不会回到最左了。这样，这个位置就是只降不增的。

最后是维护平方和，我梦回方差。[P7962 [NOIP2021] 方差](/problem/P7962) $\color{white}\texttt{但那时侯我太弱了，我没法打 NOIP qwq}$

这里直接给出公式：

$$\sum_{i=1}^n(a_i+k)^2=\sum_{i=1}^na_i^2+2k\sum_{i=1}^na_i+nk^2$$

最后说一下一个方便实现的细节：非负数没有必要单独分开处理，可以和负数一起处理。我们可以发现，上述推导中，$a_i\ge0$ 也是成立的。

**AC code**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
int n,k,pos;
ll a[1000005],ans,tot1,tot2,tot3;
int main(){
	scanf("%d%d",&n,&k);
	pos=n;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),tot3+=(a[i]+1)*(a[i]+1),tot3%=mod;
	for(int i=1;i<=k;i++){
		tot2+=2*tot1+(n-pos),tot2%=mod;
		tot1+=(n-pos),tot1%=mod;
		while(pos>0&&abs(a[pos]+i)>abs(a[pos]+1)){
			tot3-=(a[pos]+1)*(a[pos]+1),tot3%=mod,tot3+=mod,tot3%=mod;
			tot1+=a[pos]+i,tot1%=mod;
			tot2+=(a[pos]+i)*(a[pos]+i),tot2%=mod;
			pos--;
		}
		ans+=tot2+tot3;
		ans%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：sunkuangzheng (赞：4)

**【题目分析】**

首先我们要想的是，要求的值什么时候最大。首先好理解的是，肯定要把若干个负数放到最左边，中间放空区间，右边放整数，这样可以让负数的平方减得最少，正数的平方加得最多。有一种常见的错误思路：把负数全都放在左边第一个，然而这是错的。例如：$-10\quad -1\quad5 $，这组数据显然，当 $m$ 较大时，应该把 $-1$ 放在右边那一组。所以我们要修改贪心策略：当 $a+m \ge -a-1$ 时，就将它放在右边那一组。这个式子的意思是当把这个负数放在右边加的比在左边加的结果的绝对值还大时就放在右边。那么思路已经很清晰了，考虑如何计算。

以下用 $p$ 表示左边的最后一个负数。

先看左边，左边的平方和就等于 $(a_1+1)^2+(a_2+1)^2+...+(a_p+1)^2 = (a_1^2+a_2^2+...+a_p^2)+2(a_1+a_2+...+a_p)+p$。我们可以用前缀和维护平方和以及一次项的和。

再看右边，右边的平方和等于 $(a_{p+1}+m)^2+(a_{p+2}+m)^2+...+(a_n+m)^2 = (a_{p+1}^2+a_{p+2}^2+...+a_n^2)+2m(a_{p+1}+a_{p+2}+...+a_n)+(n-p)m^2$。这个式子同样可以使用前缀和维护。

在处理的时候注意细节，例如哪里要取余、哪里要开 `long long`。然而为了避免乘的时候爆 `long long` 还得到处取余，我选择开了 `__int128`，就不用处理很多杂乱的细节。

具体的处理方法见代码。

**【关键代码】**

为了方便，省略 `__int128` 需要的读入（`r()` 函数） 和输出 （`pri()` 函数）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll __int128
ll mod = 998244353;
ll n,m,sum1[10000005],sum2[10000005],a[10000005],p,ans;
//sum1是平方前缀和，sum2是一次项前缀和,p是最后一个负数
//省略输入输出的 r() 和 pri() 函数
int main(){
	n = r(),m = r();
	for(ll i = 1;i <= n;i ++){
		a[i] = r();
		if(a[i] < 0){
			p = i;//记录第一个负数的位置
			sum2[i] = (sum2[i-1] + a[i]+mod)%mod;
		}
		else sum2[i] = (sum2[i-1] + a[i]+mod)%mod;
		sum1[i] = (sum1[i-1] + a[i]*a[i]) % mod;
	}
	for(ll i = 1;i <= m;i ++){//注意，i 也要开 __int128！！！
	    while(-a[p]-1 < a[p]+i && p > 0) --p;
		ans = (ans + (sum1[p]+2*sum2[p]+p+mod)%mod+((sum1[n]-sum1[p])+2*i*((sum2[n]-sum2[p]+mod))+i*i*(n-p)))%mod;
	}
	pri((ans+mod)%mod);
	return 0;
}

---

## 作者：gan1234 (赞：3)

## 分析

题中有两个很重要的性质，
- 序列满足每一项都不小于前一项
- 可以有空段

对于每一个 $m$ ，如何构造出分段方式使  $\sum_{i=1}^{n}a_i^2$ 最大？

先考虑序列所有数大于等于 $0$ 的情况。$a_i$ 在第 $j$ 段就加上 $j$ ，显然 $a_i+j$ 越大，它的平方就越大。所以将所有数都划分到最后一段是最大的。

如果序列中存在了负数，不难想出，对于每个 $a_i$  ，如果 $(a_i+1)^2<(a_i+m)^2$ ，那么就将它划分到最后一段，否则划分到第一段。因为序列是单调不降的，所以如果 $(a_i+1)^2<(a_i+m)^2$ ，  $(a_{i+1}+1)^2<(a_{i+1}+m)^2$ 也满足。

这样一个最优的划分方案就出现了，**对于每个 $m$ ，将所有满足 $(a_i+1)^2>=(a_i+m)^2$ 的 $a_i$ 划分到第一段，将所有满足 $(a_i+1)^2<(a_i+m)^2$ 的划分到最后一段。只有第一段和最后一段里有数**。

我们就可以用一个变量 $t$ 来记录中间这个分割点。对于每个$m$ 可以先更新 $t$ ，然后分别算出 $\sum_{i=1}^{t}(a_i+1)^2$和$\sum_{i=t+1}^{n}(a_i+m)^2$ 。 

计算复杂度 $O(n)$ ,枚举 $k$ 次，
直接这样做复杂度 $O(kn)$ ，会超时，考虑优化。

## 优化

如何 $O(1)$ 计算 $\sum_{i=1}^{t}(a_i+1)^2$ 和  $\sum_{i=t+1}^{n}(a_i+m)^2$ ？

我们展开一下 $\sum_{i=t+1}^{n}(a_i+m)^2$ ，可得。
$$\sum_{i=t+1}^{n}(a_i+m)^2=\sum_{i=t+1}^{n}a_i^2+\sum_{i=t+1}^{n}2a_im+m^2(n-t-1)$$

$\sum_{i=1}^{t}(a_i+1)^2$ 也同理。

所以
$$q_j=\sum_{i=1}^{n}a_i^2+2\sum_{i=1}^{t}a_i+2\sum_{i=t+1}^{n}a_im+m^2(n-t-1)+t$$

**我们可以使用前缀和来优化。使用两个变量，令 $S_1=\sum_{i=1}^{t}a_i$ ， $S_2=\sum_{i=t+1}^{n}a_i$ ，每次随着 $t$ 的更新，更新 $S_1$ 和 $S_2$ 。** 而每个 $q_j$ 的 $\sum_{i=1}^{n}a_i^2$ ，直接在输出时加上 $k\sum_{i=1}^{n}a_i^2$ 就行了。

前缀和优化后，此题复杂度变成了$O(k+n)$，足以过掉此题。

最后，**一定要注意及时取模！**

~~取模不当见祖宗~~

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
//long long也是要开的
int n,k;
int ans;
int a[1000005];
int s1,s2;
signed main(){
    ios::sync_with_stdio(0);
    cin>>n>>k;
    int t=n;
    for(int i=1;n>=i;i++)cin>>a[i];
    for(int i=1;n>=i;i++){
        ans=(ans+(a[i]*a[i])%mod)%mod;
        s1=(s1+a[i])%mod;//前缀和
    }
    ans=(ans*k)%mod;//直接在最开始就将序列平方和乘上k，在循环时不用单独计算。
    for(int i=1;k>=i;i++){
        while((a[t]+1)*(a[t]+1)<(a[t]+i)*(a[t]+i)&&t){
            s1=(s1-a[t]+mod)%mod;s2=(s2+a[t])%mod;
            t--;//对于每个m，更新t和s1，s2。            
        }
        ans=(ans+(((i*i)%mod)*(n-t))%mod+t+(2*s1)%mod+(2*i*s2)%mod+mod)%mod;
        //注意取模。
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Dregen_Yor (赞：3)

### [更好的阅读体验](https://dregen-yor.eu.org/index.php/2022/10/24/p8590/)。

# 前置知识

完全平方公式: $(a+b)^2=a^2+2ab+b^2$。

# 思路

题目中给出的序列 $\{a_n\}$，**满足每一项都不小于前一项，且分出的段中可以有空段**，根据贪心的思想，我们考虑将负数项全部分到第一个段中，将正数项全部分到最后一段中。

但这样贪心显然是不对的，我们举一个例子：

对于负数项 $-4$，当 $m\ge 8$ 时，将 $-4$ 归入正数所在的段中显然要优于将 $-4$ 归入第一段中，因为序列是不减的，我们可以考虑用一个指针维护第一段和最后一段的分界线，每次都更新一次即可。

但由于题目给出的数据范围：$n\le10^6,k\le10^7$。直接暴力枚举显然是会 TLE 的。

$$\sum\limits_{i=1}^n(a_i+k_p)^2=a_i^2+2a_ik_p+k_p^2$$

其中 $p=1$ 或 $0$，$k_0=1,k_1=m$，分别表示第一个段和最后一个段。

根据完全平方公式的展开项，不难发现，序列的初始值 $\sum\limits_{i=1}^na_i^2$ 一定会被统计入答案中，我们再用 $siz_i$ 表示第 $i$ 个段中元素的大小。

每次对于答案的贡献为 $q_m=\sum\limits_{i=1}^na_i^2+\sum\limits_{i=1}^n2\times(a_i\times k_p)+1\times siz_1+m\times siz_m$。

用两个数组分别存第 $1$ 个段中元素的总和以及第 $m$ 个段中元素的总和即可。

# 下面是我丑陋的代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,k,a[1000010],p;
__int128 ans,sum[2],siz[2];
signed main(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        if(a[i]<0){
            int tmp=-a[i];
            sum[0]+=tmp;
            siz[0]++;
            p=i;
        }
        else{
            sum[1]+=a[i];
            siz[1]++;
        }
        ans+=(a[i]*a[i])%mod;
        ans%=mod;
    }
    __int128 res=0;
    for(int i=1;i<=k;i++){
        while(i>=(-a[p]*2)&&p){
            siz[0]--;
            siz[1]++;
            sum[0]+=a[p];
            sum[1]+=a[p];
            p--;
        }
        res+=((((ans-(sum[0]*2%mod)+siz[0])%mod)+(((sum[1]*2%mod)*i)%mod))%mod)+((((siz[1]*i)%mod)*i)%mod);
        res%=mod;
    }
    int out=res;
    printf("%lld",out);
    return 0;
}
```



---

## 作者：iiiiiyang (赞：3)

#【JROI-8】这是新历的朝阳，也是旧历的残阳

[更好的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/16823096.html)

[题目链接](https://www.luogu.com.cn/problem/P8590)

属实是太菜了，最开始还想歪了，这篇题解将以我的思考历程为起点来讲述这道题。

首先我们对于分段，因为中间可以放空段，序列又保持不下降，所以我最开始简单的认为对于负数我们让它加的尽可能少，对于正数我们让他加的尽可能多，把负数都放在第一段，把整数都放在最后一段，记 $k$ 为最后一个负数（显然 $0$ 放在正数更优）,然后就可以得到一个错误的式子：

$$
\begin{aligned}
Ans 
    &= m \times \sum_{i=1}^{k} (a_i + 1)^2 + \sum_{i=k+1}^{n} \sum_{j=1}^{m} (a_i + j)^2 \\
    &= m \times \sum_{i=1}^{k} (a_i + 1)^2 + (n - k) \times \sum_{i=k+1}^{n} a_i^2 + (m^2 + m) \times \sum_{i=k+1}^{n} a_i + (n - k) \times \sum_{i=1}^{m} i^2 
\end{aligned}
$$

读入时候预处理 $\Sigma_{i=k+1}^n a^2$，$\Sigma_{i=k+1}^n a$，$\Sigma_{i=1}^m i^2$，然后计算是 $O(1)$ 的。~~然而这样是错的。~~

在给负数加上一个数的时候，可能会出现把它加成了正数，而且绝对值要比原来还大，因此对于一个负数就要分成两类讨论，一类是段数低于 $2 \times |a_i|$ 的我们还是放在第一段更优，多于这个值的我们则把它放在最后一段。

考虑枚举分段数量，更改指针 $k$ 的定义为最后一个二倍绝对值大于分段数量的 $a$，依旧预处理好我们所需要的正数平方和和负数平方和，以及完全平方公式打开后中间的一次项的和，然后转移贡献就好了。

需要注意的小点有可能有多个相同的数，所以转移要写成 while 而不是 if；从负数平方和中去掉贡献时因为取模可能会减成负数，所以要先加上模数；开 ll 就行，不需要开 ull。时间复杂度 $O(N + M)$。

$Code$
```cpp
#include<bits/stdc++.h>
#define int long long
#define MAX 1000010
using namespace std;

inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}

namespace LgxTpre
{
	const int mod=998244353;
	int n,k,a[MAX];
	int zbowsum,last,zsum2k;
	int ans,ansf,ansz;
	inline void solve()
	{
		n=read(),k=read();
		for(int i=1;i<=n;++i)
		{
			a[i]=read();
			if(a[i]<0) ansf=(ansf+(a[i]+1)*(a[i]+1)%mod)%mod,last=i; 
			else zbowsum=(zbowsum+(a[i]*a[i])%mod)%mod,zsum2k=(zsum2k+a[i]*2%mod)%mod; 
		}
		for(int i=1;i<=k;++i)
		{
			while(abs(a[last])*2==i&&last>0)
				ansf=(ansf+mod-((a[last]+1)*(a[last]+1)))%mod,
				zbowsum=(zbowsum+(a[last]*a[last]%mod))%mod,
				zsum2k=(zsum2k+a[last]*2%mod+mod)%mod,--last;
			ans=(ans%mod+ansf%mod+zbowsum+zsum2k*i%mod+((n-last)*(i*i%mod)%mod))%mod;
		}
		cout<<ans;
	}
}

signed main()
{
	LgxTpre::solve();
	return (0-0);
}
```

---

## 作者：cqazy811 (赞：3)

直奔正题，在这道题中，很容易得出一个性质：  
> 每个数的分组只能是第 $1$ 组或是第 $k$ 组。  
  
这个性质其实很好想，因为对于一个 $x$，$x^2$ 其实与 $x$ 的正负性无关，有关的是 $\left| x\right|$，而有可能成为最大值的只有 $1$ 或 $k$。  
  
如果想到了这个性质，那么就可以获得 30pts 的部分分。  
```
for (int i = 1; i <= n; i++)
{
    int x;
    scanf("%lld", &x);
    for (int j = 1; j <= k; j++)
        res = (res + max(abs(x + 1), abs(x + j)) * max(abs(x + 1), abs(x + j))) % P; // max(abs(x + 1), abs(x + j)) 的平方。
}
```  
  
接着我们考虑什么数该放第 $k$ 组，容易发现，当 $x > 0$ 时，$\left| x+1 \right| \le \left| x+k \right|$ 。所以当 $x > 0$ 的时候，每次的选择都是 $k$，那么这个 $x$ 对答案的贡献就是 $\sum\limits_{i=x+1}^{x+k} i^2$。这个就可以使用[平方和公式](https://baike.baidu.com/item/%E5%B9%B3%E6%96%B9%E5%92%8C%E5%85%AC%E5%BC%8F/3264126?fr=aladdin)在$\mathcal{O}\left(1\right)$ 的时间内求出正数对答案的贡献了。取模问题我是用逆元搞的，如果有更好的方法可以直接告诉我。  
  
```
for (int i = 1; i <= n; i++)
{
    int x;
    scanf("%lld", &x);
    if (x < 0)
    {
        for (int j = 1; j <= k; j++)
            res = (res + max(abs(x + 1), abs(x + j)) * max(abs(x + 1), abs(x + j))) % P;
    }
    else res = (res + get(x + k) + P - get(x)) % P; // 其中的 get 为平方和公式，get(x) 等于 1 到 x 中所有数的平方之和。
}
```  
  
这时候就有 60pts 的分了。  
  
刚刚分析的是 $x > 0$ 的情况，现在就到了 $x \leq 0$ 的情况了。  
容易发现，非正数在一开始是分到第 $1$ 组的，当到了一个临界值的时候，它就会分到第 $k$ 组。我们要做的就是找到这个临界值 $y$。  
对样例列一个表格就容易发现，从 $-2x$ 开始，$x$ 的分组就会从 $1$ 转变为 $k$。  
所以问题又简单起来了，当 $-2x > k$ 的时候，它对答案的贡献就是 $k\left(x+1\right)^2$，否则答案就是 $\left(-2x - 1\right)\left(x+1\right)^2 + \sum\limits_{i=-x}^{k+x}i^2$。再用平方和公式就也对负数做到了 $\mathcal{O}\left(1\right)$ 求出贡献了。  
  
```
for (int i = 1; i <= n; i++)
{
    int x;
    scanf("%lld", &x);
    if (x < 0) 
    {
        int w = (-x) << 1;
        if (w > k) res = (res + (x + 1) * (x + 1) % P * k % P) % P;
        else res = (res + (x + 1) * (x + 1) % P * (w - 1) % P + (get(k + x) + P - get(-x - 1))) % P;
    }
    else res = (res + (get(x + k) + P - get(x)) % P) % P;
}
```  
  
那么这就是 100pts 的做法了，时间复杂度 $\mathcal{O}\left( n\right)$，常数有点大，不过也可以过的。  

---

## 作者：_JF_ (赞：2)

## P8590 『JROI-8』这是新历的朝阳，也是旧历的残阳 

本文一开始参考了[@ ScottSuperb](https://www.luogu.com.cn/blog/Devsong/solution-p8590) 的博客的 $code$。

挺好的思维题。

注意，满足数列 $a_{i}<a_{i+1}$。

主题的思路：贪心，数学。

正数阵营：对于分到第 $k$ 次，平方贡献是 $(a[i]+k)^2$ 的。

负数阵营：对于分到第 $k$ 次，平方贡献是 $(a[i]+1)^2$ 的。
 
首先，对于分成 $k \geq 2$ 的段，我们为了使贡献最大，我们只可以数分成两部分，一部分放在第一段，这一段的数都是负数，因为加 $1$ 会让他们的平方损失贡献最小。而对于某些负数，即 $\left\vert a+1 \right\vert<a+m$ 的情况，这个数在正数阵营中的贡献就更大了，我们把它归入**正数阵营**之中。

由于本题 $n\leq10^6$ ，$k\leq10^7$，数据范围很大，普通的暴力必然是不可行的，考虑数学，即推式子。

前置：我们设 $b$ 表示第一个**正数阵营**出现的位置，$now$ 表示当前这一分段的总和，$sum1$ 所有**正数阵营**的和，$n$ 表示**正数阵营**的个数，$ans$ 为答案。

最开始的时候，所有负数都在负数阵营。

首先考虑正数的贡献。

假设现在划分到第 $m$ 次，那么当前的正数贡献就是 $\sum_{i=x}^n(a_i+m)^2 $，到第 $m+1$ 次，正数的贡献就是$\sum_{i=x}^n(a_i+m+1)^2$（多出一个空集）。拆开这两个式子作差，差就是 $(\sum_{i=x}^na_{i})+n $。

所以，正数的贡献可以由上一次推过来的，时间为 $O(1)$。

对于负数，我们知道，在 $\left\vert a+1 \right\vert<a+m$ 的情况下，他可以归入正数中。那么 $now+=((a[i]+m)^2-(a[i]+1)^2)$，即统计负数归入正数阵营的时候，所给与的贡献，同时 正数阵营个数加一个，第一个正数阵营出现的位置往前推，更新 $ans$ 的答案，即它在负数阵营和正数阵营的差值，$sum1$ 加上当前的数加上 $m$ 的和。

最后记得取模。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
const int mod=998244353;
#define int long long
int a[N];
int n,k,b;
int now,ans,sum1,now1;
signed main()
{
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	cin>>n>>k;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
		b+=a[i]<0;
		now=(now+(a[i]+1)*(a[i]+1))%mod;
	}
	ans+=now;
	for(int i=b;i<n;i++)
		sum1=(sum1+a[i]+1)%mod;
	n-=b;
	for(int m=2;m<=k;m++)
	{
		ans=(ans+(now=(now+sum1*2%mod+n)%mod))%mod;
		sum1=(sum1+n)%mod;
		while(b>0&&a[b-1]+m>abs(a[b-1]+1))
		{
			--b,++n;
			now1=(a[b]+m)*(a[b]+m)%mod-(a[b]+1)*(a[b]+1)%mod;
			ans=(ans+now1)%mod,now=(now+now1)%mod,sum1=(sum1+(a[b]+m))%mod;
		}
	}
	cout<<ans<<endl;
	return 0;
}


```


---

## 作者：gyyyyx (赞：2)

[题面](https://www.luogu.com.cn/problem/P8590)

az，赛时看漏条件，我真的会谢！

首先看一下特殊数据，$\forall i,a_i\geq0$，很明显，把所有数字都分到最后一组是最优的。

但如果有 $a_i<0$ 的 $i$ 怎么办？

设分 $j$ 段，那 $a_i<0$ 的话有两种情况：

1. $(a_i+1)^2>(a_i+j)^2$，此时有 $2a_i+j+1<0$。那 $a_i$ 要分到第 $1$ 组。

2. $(a_i+1)^2\leq(a_i+j)^2$，此时有 $2a_i+j+1\geq0$。那 $a_i$ 要分到第 $j$ 组。

其他情况可以证明一定不如这两种中其中一种更优。

证明在这里给出，李姐的可以跳过。

设有一个数 $a$，要分到第 $b$ 组（$1<b<j$），即这个数对答案的贡献为 $(a+b)^2$。

1. $a+b\leq0$ 时
   $$
   \begin{aligned}
   &(a+b)^2-(a+1)^2=(2a+b+1)(b-1)\\
   &\because a+b\leq 0,b>1\\
   &\therefore a+1<0\\
   &\therefore 2a+b+1<0,b-1>0\\
   &\therefore (a+b)^2<(a+1)^2
   &\end{aligned}
   $$
   因此，$a$ 分到第 $1$ 组比 $a$ 分到第 $b$ 组更优。

2. $a+b\geq0$ 时
   $$
   \begin{aligned}
   &(a+b)^2-(a+j)^2=(2a+b+j)(b-j)\\
   &\because a+b\geq 0,b<j\\
   &\therefore a+j>0\\
   &\therefore 2a+b+j>0,b-j<0\\
   &\therefore (a+b)^2<(a+j)^2
   &\end{aligned}
   $$
   因此，$a$ 分到第 $j$ 组比 $a$ 分到第 $b$ 组更优。

直接看好像很难处理，不过要注意看，题目中有一个关键句：

给定序列 $\{a_n\}$，**满足每一项都不小于前一项**。

那么如果无论分多少组，肯定存在一个 $x$ 满足 $\forall i\leq x,a_i$ 分到第 $1$ 组，且 $\forall i>x,a_i$ 分到最后一组。

如果我们找到了这个 $x$，那 $1\sim x$ 的答案为：
$$
\begin{aligned}
&\ \ \ \ \ \overset{i\leq x}{\underset{i=1}{\sum}}(a_i+1)^2\\
&=\sum(a_i^2+2a_i+1)\\
&=\sum a_i^2+2\sum a_i+x
\end{aligned}
$$
$x+1\sim n$ 的答案为：
$$
\begin{aligned}
&\ \ \ \ \ \overset{i\leq n}{\underset{i=x+1}{\sum}}(a_i+j)^2\\
&=\sum(a_i^2+2a_ij+j)\\
&=\sum a_i^2+2j\sum a_i+(n-x)j^2
\end{aligned}
$$
其中的 $j$ 为分的组数。

那加起来，分 $j$ 组的答案就是：

$$
\begin{aligned}
&\overset{i\leq x}{\underset{i=1}{\sum}}a_i^2+2\overset{i\leq x}{\underset{i=1}{\sum}}a_i+x+\overset{i\leq n}{\underset{i=x+1}{\sum}}a_i^2+2j\overset{i\leq n}{\underset{i=x+1}{\sum}}a_i+(n-x)j^2\\
&=\overset{i\leq n}{\underset{i=x+1}{\sum}}a_i^2+2(\overset{i\leq x}{\underset{i=1}{\sum}}a_i+j\overset{i\leq n}{\underset{i=x+1}{\sum}}a_i)+[x+(n-x)j^2]
\end{aligned}
$$

之后就是如何找到每个 $x$ 了。

我们先观察一下 $2a_i+j+1$，当 $\{a_n\}$ 固定的情况下，分的组数越大，这个式子越大。

并且这个式子具有单调性，因为 $\{a_n\}$ 单调不减，所以当分的组数固定，$\forall i<j,2a_i+j+1\leq 2a_j+j+1$。

也就是说，分 $j$ 组时的 $x$，一定大于分 $j-1$ 组时的 $x$。

那就可以 $O(n)$ 求出所有 $x$ 了。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mod 998244353
#define N 1000005
using namespace std;
inline void read(int &x){
    x=0;LL f(0);char c(getchar());
    while(c<'0'||c>'9'){f^=!(c^45);c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(f) x=(~x)+1;
}
void write(LL x){
    if(x>9) write(x/10);
    putchar(x%10^48);
}
int n,k,x,a[N];LL s[N],sq,ans;
int main(){
    read(n);read(k);
    for(int i(1);i<=n;++i){
        read(a[i]);
        s[i]=(s[i-1]+1ll*a[i]+mod)%mod;
        sq=(sq+1ll*a[i]*a[i]%mod)%mod;
        if(a[i]<0) x=i;
    }
    for(int i(1);i<=k;++i){
        while(x&&(1ll*a[x]<<1)+1ll*i+1>=0) --x;
        ans=(ans+2*(s[x]+i*(s[n]-s[x])%mod)+mod)%mod;
        ans=(ans+x+1ll*(n-x)*i%mod*i%mod+mod)%mod;
    }
    write((ans+sq*k%mod+mod)%mod);
    return 0;
}
```

---

## 作者：what_else (赞：1)

### 题目概要

给定序列 $a$，对于 $1\le i\le n-1$ 有 $a_i \le a_{i+1}$ ，对于任意的 $m$ ($1\le m \le k$)，将 $a$ 分为 $m$ 段 **(可以为空段)**，第 $i$ 段的所有数增加 $i$，记 $m=i$ 时的答案（即此时最大的 $\sum\limits_{j=1}^n a_j^2$）为 $q_i$，求 $\sum\limits_{j=1}^k q_j$ 的值。

### Solution

$\text{Subtack1:}$

这道题有两个部分：

- 求出每个 $q_i$。
- 求所有 $q_i$ 的和。

当 $n,k$ 都很小时，不妨直接暴力搜分段，~~即便搜索可能在这个 sub 超时~~。

$\text{Subtack2:}$

初中数学老师说过：

对于函数 $f(x)=x^2$，在 $x>0$ 时， $f(x)$ 随 $x$ 的增大而增大，反之，$f(x)$ 随 $x$ 的增大而减小。

所以，初始为负数的数，加的越少越好，初始为正数的数，加得越多越好。

于是我们把分好段的 $a$ 分为三部分：

- 负数段
- 空段
- 正数段

很显然，负数段就是加了反而不值得的段，空段即在负数段与正数段之间所插的段，使正数段尽可能加的数多，负数段正数段之间用指针
$val$ 隔开。

当 $m=1$ 时，因为必须全在一个段里，所以负数段即为原序列 $a$ 的负数部分，（即 $a_i\le -1$），但是所有的 $m$ 都是这样的情况吗？

例如 ${\{-3,2,5,7\}}$，当 $m=10$ 时，$-3$ 因为化为正数段对答案的贡献比负数段大，不妨把它化到正数段（因为 $(-3+1)^2\le(-3+10)^2$，注意这里 $+1$ 是因为原来 $-3$ 就被化在第一个段里）

所以可以暴力指针 $val$ 的值（还要边处理平方答案），可以做到时间复杂度 $O(nk)$，拿到 $30$ 分。


$\text{Subtack3\&4:}$

因为原序列为递增的，所以 $m$ 增加之时 $val$ 只会递减，所以将暴力 $val$ 变为判断左移是否更优，如果是就移动。这样时间可控制在 $O(n)$ 上（因为 $val$ 最多只跑一遍 $a$）。

那么问题瓶颈来到，怎样求平方总和了，如果用线段树维护，时间复杂度可做到 $O(k \log n)$，但不能跑遍所有点，线段树维护详见方差一题。

$\text{Subtack5:}$

负数段的平方和永远只 $+1$，所以可以前缀和维护。

问题转化为如何求 $\sum\limits_{j=val}^n (a_j+m)^2$（$a$ 为原数列）。

将它展开：

$$\sum\limits_{j=val}^n (a_j+m)^2=\sum\limits_{j=val}^n a_j^2+(n-val+1)\times m^2+2\sum\limits_{j=val}^na_jm$$

平方和与普通和可以用前缀和维护，我的代码是在处理 $val$ 移动时调整这两个值的大小，这样时间复杂度可做到 $O(k+n)$。

$\text{Code:}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 998244353
#define ll long long//十年 OI 一场空，新冠叫你见祖宗
ll n,k;
ll s[1020200];
ll p[1010100];
ll val=n+1;
ll sum=0,sum2=0;
ll visnum=0;
ll costnum=0;
ll ans;
ll read(ll &w){
    char c; w=0; int sgn = 1;
    while(!isdigit(c = getchar())) sgn = c =='-' ? -1 : 1;
    w = c - '0';
    while( isdigit(c = getchar())) w = w * 10 + c - '0';
    return w *= sgn;
}//奇怪的读入
ll write(ll w){
	if(w!=0){
		write(w/10);
	}
	else return 0;
	putchar(w%10+'0');
}//奇怪的输出
signed main(){
	scanf("%lld %lld",&n,&k);
	val=n+1;
	for(int i=1;i<=n;i++){
		read(s[i]);
		visnum=(visnum+(s[i]+1)*(s[i]+1))%mod;//总和
		if(val==n+1 && s[i]>=0) val=i;//记录指针初始位置
		p[i]=p[i-1]+(s[i]+1)*(s[i]+1);//平方前缀和,+1 因为有初始段
		p[i]%=mod;
	}
  	ans = (ans+visnum)%mod;//提前处理 m=1
	sum2 = 0;//正数段总和
	for(int i=val;i<=n;i++)
	sum2+=(s[i]+1),costnum=(costnum+(s[i]+1)*(s[i]+1))%mod;//正数段平方和
	for(int i=2;i<=k;i++){
		while(val>1 && s[val-1]+i>=(-(s[val-1]+1))){
			sum2+=(s[val-1]+1)%mod;
			costnum+=(s[val-1]+1)*(s[val-1]+1);
			costnum%=mod;
			val--;
		} //移动 val
		ans = (ans+costnum%mod+(n-val+1)*(i-1)%mod*(i-1)%mod)%mod;
		ans += 2*(i-1)*(sum2%mod);
		ans %= mod;            
		ans += p[val-1]%mod;
		ans %= mod;  //开始更新答案     
	}                            
	write(ans);        
}
```

---

## 作者：Sktic (赞：1)

[P8590 『JROI-8』这是新历的朝阳，也是旧历的残阳](https://www.luogu.com.cn/problem/P8590)



考场上看错题目，糊了一个线段树因为 $\text{MLE}$ 喜提 $30\text{pts}$ 。



首先我们可以发现，对于分成 $m$ 段的情况，只有第 $1$ 段和第 $m$ 段需要放数。



考虑贪心的想，设一个数为 $x$，若 $|x+1|\le|x+m|$，那这个数就必定被放在第 $m$ 段，因为若放在 $1\sim m$ 中间的任意一段 $k$ ，必定有 $|x+k|\le|x+m|$ 。同理可得，若 $|x+1|\ge|x+m|$，那么这个数必定放在第 $1$ 段，因为 $|x+1|\ge|x+k|$。



因此可以将题目看成分成两段分别最大化段内平方和，而且题目中给的 $a_i$ 与 $m$ 都是单调递增的，即随着 $m$ 的增加，第 $1$ 段和 第 $m$ 段之间的边界 $pos$ 必然是单调递减的。



于是考虑维护一个指针 $pos$ ，每次循环时更新一遍。然后对于两块的平方和，我们可以这么维护（因为第 $1$ 段就等于 $m=1$ 的后一段，所以这里不再讨论 $(a_i+1)^2$ 的情况）：


$$

\begin{aligned}
&\sum_{i=pos}^n (a_i+m)^2\\
=&\sum_{i=pos}^n (a_i^2+2a_im+m^2)\\
=&\sum_{i=pos}^n a_i^2+\sum_{i=pos}^n 2a_im+\sum_{i=pos}^n m^2\\
=&\color{red}\sum_{i=pos}^n a_i^2\color{black}+2m\times\color{red}\sum_{i=pos}^n a_i\color{black}+m^2\times(n-pos+1)
\end{aligned}
$$

可以发现标红的两项可以前缀和 $O(n)$ 处理，$O(1)$ 查询，于是就做完了。



注意有个坑：#19 的答案是负数，所以要 ``ans=(ans%mod+mod)%mod`` ，我被这个坑了好久。



总复杂度 $O(n+k)$ 。



AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+10;
const ll mod=998244353;
ll a[maxn],aa[maxn],as[maxn];
ll n,k,pos=0;
void upd(ll m)
{
	while(pos>=1&&abs(a[pos]+1ll)<abs(a[pos]+m))
		pos--;
	pos++;
	return;
}
ll fk()
{
	return (aa[pos-1ll]%mod+pos%mod-1ll+2ll%mod*as[pos-1ll]%mod)%mod;
}
ll dk(ll m)
{
	return ((aa[n]%mod-aa[pos-1ll]%mod)%mod+((m%mod*m%mod)%mod*(n%mod-pos%mod+1ll)%mod)%mod+(2ll*m%mod)%mod*(as[n]%mod-as[pos-1]%mod)%mod)%mod; 
}
int main()
{
//	freopen("ex.in","r",stdin); 
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
		if(a[i]<0)
			pos=i;
	pos++;
	for(int i=1;i<=n;i++)
	{
		aa[i]=((a[i]%mod*a[i]%mod)%mod+aa[i-1]%mod)%mod;
		as[i]=(a[i]%mod+as[i-1]%mod)%mod;
	}
	ll ans=0;
	for(int i=1;i<=k;i++)
	{
		upd(i);
		ans=(ans%mod+fk()%mod+dk(i)%mod)%mod;
	}
	cout<<(ans%mod+mod)%mod<<endl; 
	return 0;
}
```





---

## 作者：JustForYourself (赞：1)

## 大体方向

根据样例可知，我们可以贪心地把负数划到第一段，正数划到最后一段，接着简单拆式子计算即可？

**但是如果你这么想只有 60 pts**，~~和我赛时一样~~。

这是为什么呢？注意到当 $a_i<0$ 并且 $m \geq -2a_i$ 时 $a_i$ 也要划到最后一类，这样才是满分做法，我们在 $a_i<0$ 时分类讨论即可。具体的见「具体思路」的末尾。

## 具体思路

可能会讲的标准一些，但是已经尽力讲的通俗易懂了。

希望大家都有所收获，一些简单的化简就不展开来说了。

### 定义 $f$ 函数

我们为了方便计算，定义函数 $f$。

令 $f(x, b, e) = (x + b) ^ 2 + (x + (b + 1)) ^ 2 + ... + (x + e) ^ 2$，其中 $b,e\leq k$。

经过简单化简可得：

$f(x,b,e)=\textcolor{blue}{(e-b+1)x^2+x(b+e)(e-b+1)}+ \textcolor{red}{b^2+(b+1)^2+...+e^2}$。

很显然蓝字部分可以 $O(1)$，而红字部分 $O(e-b)$。我们考虑优化红字部分。

记 $sum_i = \sum\limits_{j=1}^{i}j^2$。很显然 $\{sum_n\}$ 可以前缀和 $O(k)$ 求出，那么红字部分就可以转化为 $sum_e-sum_{b-1}$。

所以我们最终的 $f$ 函数为：

$f(x,b,e)=(e-b+1)x^2+x(b+e)(e-b+1)+sum_e-sum_{b-1}$。

那么经过前缀和优化后，显然 $f$ 的计算是 $O(1)$ 的。

### 计算

#### 仅考虑非负数

假设我们去掉 $\{a_n\}$ 中所有的负数，那么答案即为 $\sum\limits_{i=1}^{n}\space (a_i)^2 + (a_i+1)^2+...+(a_i+k)^2$，手算样例正数部分即可理解。

运用 $f$ 函数，原式可以化简为：$\sum\limits_{i=1}^{n}f(a_i,1,k)$。

#### 考虑负数

如果 $a_i < 0$，我们分两种情况。

- $k < -2a_i$：我们直接把它每一次都划分到第一段。答案增加 $(a_i+1)^2\times k$。

- $k \geq -2x$：

> 对于 $m = 1,2,...,-2a_i-1$，我们把它划分到第一段里。答案增加 $(a_i+1)^2\times (-2a_i-1)$，根据样例手推即可。

> 对于 $m=-2a_i,-2a_i+1,...,k$，我们把它划分到最后一段，答案增加 $(a_i+(-2a_i))^2+(a_i+(-2a_i+1))^2+...+(a_i+k)^2=f(a_i,-2a_i,k)$。这是为什么呢？请参见下文「WA 60pts 原因」。

#### WA 60pts 原因

我们把以下的数据，展开手算：

```
2 10
-4 1
```

当 $m = 1$ 时，最优策略是 $[-4,1]$，$q_1=(-3)^2+2^2=13$，

当 $m = 2$ 时，最优策略是 $[-4][1]$，$q_1=(-3)^2+3^2=18$，

当 $m = 3$ 时，最优策略是 $[-4][][1]$，$q_1=(-3)^2+4^2=25$，

当 $m = 4$ 时，最优策略是 $[-4][][][1]$，$q_1=(-3)^2+5^2=34$，

当 $m = 5$ 时，最优策略是 $[-4][][][]1]$，$q_1=(-3)^2+6^2=45$，

当 $m = 6$ 时，最优策略是 $[-4][][][][][1]$，$q_1=(-3)^2+7^2=58$，

当 $m = 7$ 时，最优策略是 $[-4][][][][][][1]$，$q_1=(-3)^2+8^2=73$，

**当 $m = 8$ 时，最优策略是 $[][][][][][][][-4,1]$，$q_1=4^2+9^2=97$，**

当 $m = 9$ 时，最优策略是 $[][][][][][][][][-4,1]$，$q_1=5^2+10^2=125$，

当 $m = 10$ 时，最优策略是 $[][][][][][][][][][-4,1]$，$q_1=6^2+11^2=157$。

答案即为 $\sum\limits_{i=1}^{10}q_i \bmod 998244353=645$。

我们看向加粗部分，发现这个时候当前负数也被划分到了最后，这是因为 $(-4+1)^2<(-4+8)^2$，于是放到后面比放到前面更好。

我们假设当 $m$ 到达阈值 $x$ 时需要放到后面，那么显然不等式 $(a_i+1)^2<(a_i+x)^2$ 成立，那么化简后得 $x \geq -2a_i$。正好与上文的阈值 $8 = -2 \times -4$ 对应。

于是我们就证明了上文的结论。

#### 复杂度计算

显然正数负数都可以单次 $O(1)$ 回答。有 $n$ 个数，那么答案计算就是 $O(n)$ 的了。

加上 $\{sum_n\}$ 的预处理 $O(k)$，总的时间复杂度为 $O(n+k)$，可以通过。

## 代码

写的略丑，还望见谅。

```cpp
#include <bits/stdc++.h>
using namespace std;

int MOD = 998244353;
int sum[10000010];

int add(int x, int y) {
	x %= MOD;
	y %= MOD;
	return (x + y) % MOD;
} 

int mul(int x, int y) {
	x %= MOD;
	y %= MOD;
	return ((long long)x * y) % MOD;
}

int f(int x, int b, int e) {
	return add(
		mul(e - b + 1, mul(x, x)),
		add(
			mul(x, mul(b + e, e - b + 1)),
			sum[e] - sum[b - 1]
		)
	);
}

int main() {
    int n, k, ans = 0;
    cin >> n >> k;
    sum[0] = 0;
    for (int i = 1; i <= k; i++) {
        sum[i] = add(sum[i - 1], mul(i, i));
    }
    while (n--) {
        int x;
        cin >> x;
        if (x >= 0) {
            ans = add(ans, f(x, 1, k));
        } else if (k < -2 * x) {
        	ans = add(ans, mul(mul(x + 1, x + 1), k));
        } else {
        	ans = add(ans, mul(mul(x + 1, x + 1), -2 * x - 1));
        	ans = add(ans, f(x, -2 * x, k));
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 结语

- 菜死了，考场上挂分，被嘲讽了。

- 这大样例给了和没给一样。

---


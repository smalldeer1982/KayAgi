# 『JROI-8』颅脑损伤 2.0

## 题目描述

给定 $n$ 条线段，第 $i$ 条是 $[l_i,r_i]$。将每一条线段染成红色或黑色，要求：

1. 任意两条红色线段不相交。
2. 任意一条黑色线段**至少**和一条红色线段相交。

请最小化红色线段的长度和，并输出这个长度和。

一条线段 $[l_i,r_i]$ 的长度定义为 $r_i-l_i$，两条线段 $[l_i,r_i],[l_j,r_j]$ 交**当且仅当** $l_i\le r_j$ 且 $l_j\le r_i$。

## 说明/提示

**数据范围**

|测试点编号|$n\le$|
| :----------: | :----------: |
|$1\sim4$|$10$|
|$5\sim8$|$400$|
|$9\sim20$|$3000$|

对于所有数据，满足 $-10^9\le l_i<r_i\le10^9$。


## 样例 #1

### 输入

```
5
-6 5
1 3
-4 9
-1 10
6 8
```

### 输出

```
4```

# 题解

## 作者：xwh_Marvelous (赞：27)

第一眼，可以暴搜。

第二眼，可以记忆化。

第三眼，可以记忆化改 DP。

所以考虑 DP。

实际上对于普及组而言，**大多数** DP 题都可以记忆化搜索解决，这里只介绍 DP 解法。

首先要将线段按 $l$ 排序，这样能确保 DP 的顺序不会出问题。

我们设计状态 $f_x$ 表示将第 $x$ 条线段染成红色且 $1$ 到 $x$ 都是合法方案的最小代价。

接下来考虑 $f_x$ 如何转移，假设转移枚举到 $f_i$。

首先根据要求一，任意两条红色线段不相交，得到：

$$r_i<l_x$$

然后根据要求二，任意一条黑色线段**至少**和一条红色线段相交，得到：

$$j\in\{k\in(i,x)|r_k<l_x\},r_i\ge l_j$$

优化一下得：

$$r_i\ge\max\{l_j\}$$

这实际上是确保 $i$ 到 $x$ 中间的**不与线段 $x$ 相交的**线段染成黑色后还能与染成红色的线段 $i$ 相交。

整合一下得：

$$f_x=\min\{f_i+r_x-l_x\}$$

代码就很好写了。

**AC code**

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n;
struct line{ll l,r;bool operator<(const line &x)const{return this->l!=x.l?this->l<x.l:this->r<x.r;}}a[3005];
ll f[3005],ans=LONG_LONG_MAX;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld",&a[i].l,&a[i].r);
	sort(a+1,a+1+n);
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	a[0].r=-2e9;
	for(int i=1;i<=n;i++){
		ll tot=-2e9;
		for(int j=i-1;j>=0;j--){
			if(a[j].r>=a[i].l||a[j].r<tot)continue;
			f[i]=min(f[i],f[j]+a[i].r-a[i].l);
			tot=max(tot,a[j].l);
		}
	}
	for(int i=1;i<=n;i++){
		if(a[i].r>=a[n].l)ans=min(ans,f[i]);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：xieyikai2333 (赞：14)

- [题目传送门-洛谷](https://www.luogu.com.cn/problem/P8591)

---

# 0x00 闲话

- 明天就要 CSP-J/S 2022 复赛了，来篇题解 rp++ 一下。

- 这是一篇 $\Theta(n)$ 的题解。

---

# 0x01 第一部分

## 解题思路

- 先将线段按照左端点排序。

- 考虑一个 DP。令 $dp_{i}$ 表示第 $i$ 条线段被染红，并且前 $i-1$ 条线段都满足条件的最小答案。

- 考虑状态转移方程。显然是 $dp_{i}=\min\{dp_j\}+(r_i-l_i)$ 的形式。现在要考虑哪些 $j$ 可以用来转移 $i$。

- 首先我们要知道右端点严格小于 $l_i$ 的线段中，左端点最大的线段的左端点的位置，记为 $pos$。看起来很别扭，其实就是：
	$$pos=\max_{r_{j} \lt l_{i}}\{l_{j}\}$$

- 这个位置，是前 $i-1$ 条线段中线段 $i$ 覆盖不到的最后位置。所以对于任意 $j$，若 $dp_{j}$ 可以更新 $dp_{i}$，那么 $r_{j} \ge pos$ 是必须的。此时线段 $j$ 覆盖了 $pos$，那么由 $pos$ 的定义可知，前 $i-1$ 条线段都已满足条件。又因为两条红线段不能相交，于是 $j$ 与 $i$ 不能相交，即 $r_{j} \lt l_i$。

- 总结一下：
	$$dp_{i}=\min_{pos \leq r_{j} \lt l_{i}}\{dp_{j}\}$$

- 只要线段 $i$ 可以覆盖到最后一条线段，$dp_{i}$ 就有机会成为最终答案：
	$$ans=\min_{r_{i} \geq l_{n}}\{dp_{i}\}$$

- 时间复杂度是 $\Theta(n^{2})$。

---

## 代码实现

**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define l first
#define r second
using namespace std;
const int N=3005;
long long dp[N];
pair<int,int> a[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d %d",&a[i].l,&a[i].r);
	sort(a+1,a+n+1);
	long long ans=LLONG_MAX;
	a[0].r=INT_MIN;
	for(int i=1;i<=n;i++)
	{
		dp[i]=LLONG_MAX/3;
		int pre=INT_MIN;
		for(int j=1;j<i;j++)if(a[j].r<a[i].l&&a[j].l>pre)pre=a[j].l;
		for(int j=0;j<i;j++)if(a[j].r<a[i].l&&a[j].r>=pre)dp[i]=min(dp[i],dp[j]+(a[i].r-a[i].l));
		if(a[i].r>=a[n].l)ans=min(ans,dp[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

- 这个时候有的读者就要问了：说好的 $\Theta(n)$ 呢？请往下看。

---

# 0x02 第二部分

## 解题思路

- 观察到我们的时间复杂度瓶颈在求 $pos$ 以及 $dp_{i}$ 上，考虑优化。

- 先离散化。

- 对于 $pos$，我们预先记录下每一个右端点对应的左端点，然后对于所有小于 $l_{i}$ 的位置求其对应的左端点位置的最大值即为 $pos$。因为 $l_{i}$ 有序且数据经过离散化，所以可以一个指针扫过去，这样求 $pos$ 的操作**总共**只会进行 $\Theta(n)$ 次。

- 对于 $dp_{i}$，根据刚才的状态转移方程可以看出它很像一个区间最值问题。我们将 $dp_{j}$ 存在线段树上 $r_{j}$ 的位置，这样只要查询线段树上区间 $[pos,l_{i})$ 的最小值即可。于是我们可以在 $\Theta(\log n)$ 的时间复杂度内求出 $dp_{i}$。

- 至此，时间复杂度优化至 $\Theta(n \log n)$。

---

## 代码实现


**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=3005;
int tmp[N<<1],pos[N<<1],dp[N];
struct node
{
	int l,r,x;
	bool operator < (const node &o)const
	{
		return this->l<o.l;
	}
}a[N];
struct SGT
{
	int mi[N<<3];
	SGT(){memset(mi,0x3f,sizeof(mi));}
	void modify(int p,int l,int r,int x,int v)
	{
		if(l==r)return mi[p]=min(mi[p],v),void();
		int mid=(l+r)>>1;
		if(x<=mid)modify(p<<1,l,mid,x,v);
		else modify(p<<1|1,mid+1,r,x,v);
		mi[p]=min(mi[p<<1],mi[p<<1|1]);
		return;
	}
	int query(int p,int l,int r,int x,int y)
	{
		if(x>r||y<l)return LLONG_MAX;
		if(x<=l&&r<=y)return mi[p];
		int mid=(l+r)>>1;
		return min(query(p<<1,l,mid,x,y),query(p<<1|1,mid+1,r,x,y));
	}
}sgt;
int lsh(int n)
{
	for(int i=1;i<=n;i++)tmp[2*i-1]=a[i].l,tmp[2*i]=a[i].r;
	sort(tmp+1,tmp+2*n+1);
	int len=unique(tmp+1,tmp+2*n+1)-tmp-1;
	for(int i=1;i<=n;i++)
	{
		a[i].x=a[i].r-a[i].l;
		a[i].l=lower_bound(tmp+1,tmp+len+1,a[i].l)-tmp;
		a[i].r=lower_bound(tmp+1,tmp+len+1,a[i].r)-tmp;
	}
	return len;
}
signed main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld %lld",&a[i].l,&a[i].r);
	sort(a+1,a+n+1);
	int m=lsh(n),p=1,pre=0,ans=LLONG_MAX;
	for(int i=1;i<=n;i++)pos[a[i].r]=a[i].l;
	sgt.modify(1,0,m,0,0);
	for(int i=1;i<=n;i++)
	{
		while(p<a[i].l)pre=max(pre,pos[p++]);
		dp[i]=sgt.query(1,0,m,pre,a[i].l-1)+a[i].x;
		sgt.modify(1,0,m,a[i].r,dp[i]);
		if(a[i].r>=a[n].l)ans=min(ans,dp[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

- 这个时候有的读者就要问了：说好的 $\Theta(n)$ 呢？请往下看。

---

# 0x03 第三部分

## 解题思路

- 观察到 $pos$ 和 $l_{i}$ 都单调递增，可以用单调队列代替线段树。

- 当然，不要忘记使用 **基数排序**。

- 至此，时间复杂度优化至 $\Theta(n)$。

---

## 代码实现


**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> PII;
const int N=5e5+5,S=3.2e4;
int pos[N<<1],dp[N<<1],c[(S<<1)+5];
PII b[N<<1],t[N<<1];
struct node{int l,r,x;}a[N],tmp[N];
deque<int> q;
void SORT(int n)
{
	for(int i=1;i<=n;i++)
	{
		tmp[i].x=a[i].r-a[i].l;
		b[(i<<1)-1]=PII(a[i].l,(i<<1)-1);
		b[i<<1]=PII(a[i].r,i<<1);
	}
	for(int i=0;i<=(S<<1);i++)c[i]=0;
	for(int i=1;i<=(n<<1);i++)c[b[i].first%S+S]++;
	for(int i=1;i<=(S<<1);i++)c[i]+=c[i-1];
	for(int i=1;i<=(n<<1);i++)t[++c[b[i].first%S+S-1]]=b[i];
	for(int i=0;i<=(S<<1);i++)c[i]=0;
	for(int i=1;i<=(n<<1);i++)c[t[i].first/S+S]++;
	for(int i=1;i<=(S<<1);i++)c[i]+=c[i-1];
	for(int i=1;i<=(n<<1);i++)b[++c[t[i].first/S+S-1]]=t[i];
	int cnt=0,tot=0;
	b[0].first=INT_MIN;
	for(int i=1;i<=(n<<1);i++)
	{
		if(b[i].first!=b[i-1].first)cnt++;
		int id=b[i].second;
		if(id&1)tmp[(id>>1)+1].l=cnt;
		else tmp[id>>1].r=cnt;
	}
	for(int i=1;i<=(n<<1);i++)
	{
		int id=b[i].second;
		if(id&1)a[++tot]=tmp[(id>>1)+1];
	}
	return;
}
signed main()
{
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld %lld",&a[i].l,&a[i].r);
	SORT(n);
	for(int i=1;i<=n;i++)pos[a[i].r]=a[i].l;
	int p=1,pre=0,ans=LLONG_MAX;
	memset(dp,0x3f,sizeof(dp));
	dp[0]=0,q.push_back(0);
	for(int i=1;i<=n;i++)
	{
		while(p<a[i].l)
		{
			pre=max(pre,pos[p]);
			while(!q.empty()&&dp[q.back()]>=dp[p])q.pop_back();
			q.push_back(p++);
		}
		while(!q.empty()&&q.front()<pre)q.pop_front();
		dp[a[i].r]=min(dp[a[i].r],dp[q.front()]+a[i].x);
		if(a[i].r>=a[n].l)ans=min(ans,dp[a[i].r]);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：jr_linys (赞：9)

2023/8/9 把这篇烂题解翻了出来，优化了分析，没那么烂了

2023/8/12 对最新数据进行更新。

## 题目传送门:[普通版](https://www.luogu.com.cn/problem/P8591) [加强版](https://www.luogu.com.cn/problem/P8592)

## 前言
赛时第 $3$ 题推了个柿子调不出来，直接开摆，没看第4题。赛后一看好像还挺简单，小WA一下，开个 `long long` 就 AC 了。

$O(n^2)$ 和 $O(n\log n)$ 本题解都有。
- - -

## 题目~~大意~~直接 copy
给定 $n$ 条线段，第 $i$ 条是 $[l_i,r_i]$。将每一条线段染成红色或黑色，要求：

1. 任意两条红色线段不相交。
2. 任意一条黑色线段**至少**和一条红色线段相交。

请最小化红色线段的长度和，并输出这个长度和。

一条线段 $[l_i,r_i]$ 的长度定义为 $r_i-l_i$，两条线段 $[l_i,r_i],[l_j,r_j]$ 交**当且仅当** $l_i\le r_j$ 且 $l_j\le r_i$。

**数据范围**

$n\le3000,-10^9\le l_i<r_i\le10^9$

困难版 $n\le5\times 10^5$
- - -

## $O(n^2)$
普通版扫一眼数据范围，按出题套路肯定是 $O(n^2)$ **DP**。

**排序** 一般来说，需要给线段排个序，最基础的两种就是按前端排序和按后端排序。
考虑按后端排序，后端相等按前端排序，那么定义 $f_i$ 为**按排序后第 $i$ 条线段染成红色,保证前 $i$ 条线段合法，红色线段的总长度**。
 
**状态转移 设左端点为 $x$，右端点为 $y$，上一条红线为第$j$ 条**（$0\le j<i$）（$j=0$ 时第 $i$ 条线段为第 $1$ 条红线，不妨使 $x_0=y_0=-\infty$）。
 
1. 因为**两条红线不可重叠**，所以要保证 $y_j<x_i$。
 
2. 又要保证中间剩下的黑线（$j<k<i$）**至少接触一条红线**，对于 $x_i \le y_k$ 的黑线可以**接触到第 $i$ 条线段**，所以只要保证 $x_i>y_k$ 的线段要**接触第 $j$ 条线段**。

设 $p_i$ 为满足 $y_k<x_i$ 的最后后一条线段。
则要保证 $\max^{p_i}\limits_{k=j+1} x_k \le y_j$。由于 $l \in[0,j],x_l\le y_l\le y_j$，等价于 $\max^{p_i}\limits_{k=0} x_k \le y_j$。

3. 那么加上第 $i$ 条**线段长度** $y_i-x_i$，总得（"[ ]"内的表示条件）

$$
f_i= \min^{p_i}\limits_{j=0}
[\max^{p_i}\limits_{k=0} x_k \le y_j]
f_j+y_i-x_i
$$

**统计** 红色线段要把所有黑色线断覆盖,对于每一个 $i$，若 $\max^{n} \limits_{j=0} x_j \le y_i$，则在**保证前面合法的情况下，后面的线段也能被这条线段覆盖**，所以可以作为最后一条红线。

- - -
#### $O(n^2)$ 代码
*可结合注释李姐*

[提交记录](https://www.luogu.com.cn/record/91668632)
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=3*1e3,IINF=1e9+10;
const long long INF=1e18;
long long f[N+5],ans=INF;
struct stu{int x,y;}a[N+3];
bool cmp(stu a,stu b){//按后端排序，后端相等按前端排序
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}
int main(){
	int n,zmax=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		zmax=max(zmax,a[i].x);//记录最大的左端点
	}
	sort(a+1,a+1+n,cmp);//排序
	a[0].x=-IINF,a[0].y=-IINF;//j=0时第i条线段为第1条红线,不妨使x[0]=y[0]=-无限
	for(int i=1;i<=n;i++){
		int j;
		for(j=i-1;a[j].y>=a[i].x;j--);//跳过y[j]>=x[i]的线段，这些线段能被第i条线段覆盖
		int maxx=-IINF;f[i]=INF;
		for(;j>=0&&a[j].y>=maxx;j--) f[i]=min(f[i],f[j]),maxx=max(maxx,a[j].x);//要满足中间的黑线对第i,j条线，至少触碰一条
		f[i]+=a[i].y-a[i].x;//加上本条线段长度
		if(a[i].y>=zmax) ans=min(ans,f[i]);//判断能否覆盖后面所有的线段，作为最后一条线段 更新
	}
	printf("%lld",ans);
}
```

## $O(n\log n)$
26号，突然看见有困难版，便想用 双指针+线段树 优化，然后一直 WA，打了两个小时之后才发现被证伪了......别问为什么，问就是我太睿智了。[普通版提交寄录](https://www.luogu.com.cn/record/91660336)

回归正题。其实上面 $O(n^2)$ 的代码已经有雏形了。

不难看出，第 $p_i$ 条线段一定可以满足转移的条件。
而以此线段为右端点向左扩展，$y_j$ 满足不上升，$\max^{p_i}\limits_{k=0} x_k \le y_j$ 满足不下降。

**换句话说，可转移的上一条红线是一段区间，而且右端点可以二分，从右端点往左拓展也满足单调性。**

所以可以二分左右端点，右端点为 $p_i$，左端点为满足 $\max^{p_i}\limits_{k=0} x_k \le y_j$ 的第一条。可用数组 $maxx[i]$ 表示 $\max^{i} \limits_{k=0} x_k$。


然后用线段树区间查询求出 $[l,r]$ 区间最小的 `f[j]`，然后插入 `f[i]`。

#### $O(n\log n)$ 代码
[提交记录](https://www.luogu.com.cn/record/119755820)
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=5e5,IINF=1e9+10;
const long long INF=1e18;
struct stu{int x,y;}a[N+5];
int maxx[N+5];
long long f[N+5],ans=INF,tree[5*N];
void updata(int l,int r,int rt,int x,long long y){//模板而已
	if(l==r){
		tree[rt]=y;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) updata(l,mid,rt<<1,x,y);
	else updata(mid+1,r,rt<<1|1,x,y);
	tree[rt]=min(tree[rt<<1],tree[rt<<1|1]);
}
long long ask(int l,int r,int rt,int x,int y){
	if(x<=l&&r<=y) return tree[rt];
	int mid=l+r>>1;long long ans=INF;
	if(x<=mid) ans=min(ans,ask(l,mid,rt<<1,x,y));
	if(y>mid) ans=min(ans,ask(mid+1,r,rt<<1|1,x,y));
	return ans;
}

int main(){
	int n,zmax=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		zmax=max(zmax,a[i].x);
	}
	sort(a+1,a+1+n,
	[](stu a,stu b){
		if(a.y==b.y) return a.x<b.x;
		return a.y<b.y;
	});//一种奇妙的写法
	
	for(int i=1;i<=4*n+100;i++) tree[i]=INF;
	a[0].x=a[0].y=maxx[0]=-IINF;
	updata(0,n,1,0,0);//注意下
	for(int i=1;i<=n;i++){
		maxx[i]=max(maxx[i-1],a[i].x);//更新最大的x
		int l,r,x,y;
		x=0,y=i;
		while(y-x>1){
			int mid=x+y>>1;
			if(a[mid].y<a[i].x) x=mid;
			else y=mid;
		}r=x;//二分右端点
		x=-1,y=r;
		while(y-x>1){
			int mid=x+y>>1;
			if(a[mid].y>=maxx[r]) y=mid;//右端点r就是最后一个满足a[r].y<a[i].x的线段
			else x=mid;
		}l=y;//二分左端点
		
		f[i]=ask(0,n,1,l,r)+a[i].y-a[i].x;
		updata(0,n,1,i,f[i]);//要不断插入
		if(a[i].y>=zmax) ans=min(ans,f[i]);
	}
	printf("%lld",ans);
}
```

---

## 作者：ethanhyz (赞：5)

### 题目传送门：[普通版](https://www.luogu.com.cn/problem/P8591) 、 [~~进阶版（不知道为什么删了）~~](https://www.luogu.com.cn/problem/P8592)


# 思路

> 一场比赛不可能没有 $dp$ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ——OIer行动准则

因此，这道题 $100\%$ 是一道 $dp$！

#### 那么问题又来了，$\large\texttt{How to dp}$ ？

设 $dp_{i}$ 表示当第 $i$ 条线段为红色时，前 $i$ 根线段中红色线段的最小长度和，

为了表达方便，设 $len_i$ 为第 $i$ 根线段的长度，即 $len_i = r_i-l_i$

**得到状态转移方程：**

$$ dp_i = \min(dp_i,dp_j + len_i) $$

作为一道 $\color{lightgreen}\text{绿}$ 题，怎么可能这么简单！

我们突然意识到：在状态转移前，我们还要判断合不合法，即是不是任意一条黑色线段至少和一条红色线段相交。

#### 这又该怎么实现呢？

> 作为一枚蒟蒻，先看数据范围，拿部分分 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ——OIer行动准则

于是我们满怀希望地看向了数据范围：

|测试点编号|$n\le$|
| :----------: | :----------: |
|$1\sim4$|$10$|
|$5\sim8$|$400$|
|$9\sim20$|$3000$|

对于所有数据，满足 $-10^9\le l_i<r_i\le10^9$。

`n <= 400` ?!  

可以用 $O\left(n^3\right)$ 得 $40 pts$！

那不就好办了么！

##  $O\left(n^3\right)$ 做法

在 $dp$ 的 $2$ 重循环基础上，再增加 $1$ 重循环，用来枚举每根线段，以确定情况合不合法，如果合法就状态转移，不合法就继续。

**代码各位想想就能写出来，略**

## $O\left(n^2\right)$ 做法

由上文可知，现在遇到的难题就是要判断情况是否合法。

既然在 $dp$ 中判断只有 $40pts$，那么 **预处理这种判断** 不就行了？

所以我们再建一个数组用来存储预处理的结果：

设 $f_{i,j}$ 表示当第 $i$ 和 $j$ 根线段都为红色时，中间线段为黑色是否可行。

于是乎只要用 $O\left(n^2\right)$ 生成 $f$ 数组，再和之前一样用 $O\left(n^2\right)$ $dp$ 就行了。

而 $f$ 数组的生成也不难，伪代码如下：

```cpp
for i = 1 ~ n
	for j = i-1 ~ 0 
	{
		if(a[i].l > a[j].r)//红不相交 
		{
			if(a[i].l > a[j+1].r) maxt = max(maxt,a[j+1].l);//与i不相交，与j相交 
			if(a[j].r >= maxt) f[i][j] = 1;
		}
	}
```

这时，聪明的小可爱可能就要说了：是不是要初始化一些值啊？

可不是嘛，还要加上这么两句：

```cpp
a[0].l = a[0].r = -1<<30;
a[n+1].l = a[n+1].r = 1<<30;
```

然后，就没有然后了……

### $\texttt{Code:}$

```cpp
#include <bits/stdc++.h>
#define N 3005
#define ll long long	//养成好习惯，不要见祖宗
using namespace std;

struct node
{
	ll l,r,len;
}a[N];

bool cmp(node a,node b)
{
	return a.r < b.r;
}

ll dp[N],f[N][N],n,maxt,ans;

int main()
{
	scanf("%lld",&n);
	for( int i = 1; i <= n; ++i)
	{
		scanf("%lld%lld",&a[i].l,&a[i].r);
		a[i].len = a[i].r - a[i].l;
	}
	sort(a+1,a+1+n,cmp);	//按右端从小到大排序
	a[0].l = a[0].r = -1<<30;
	a[n+1].l = a[n+1].r = 1<<30;	//初始化
	//生成 f 数组：
	for( int i = 1; i <= n+1; ++i)
	{
		maxt = -1<<30;//记录j到i之间右端点小于区间i的左端点的最大左端点
		for( int j = i-1; j >= 0; --j)
			if(a[i].l > a[j].r)//红不相交 
			{
				if(a[i].l > a[j+1].r) maxt = max(maxt,a[j+1].l);
				if(a[j].r >= maxt) f[i][j] = 1;
			}
	}
	//正式 dp ：
	memset(dp,63,sizeof(dp));	//求最小，初始化无穷大
	dp[0] = 0;	//从0开始推，不改成0等于推了个寂寞
	for( int i = 1; i <= n; ++i)
		for( int j = 0; j < i; ++j)
			if(f[i][j])	//如果f[n+1][i]可行，dp[i]可能是答案 
				dp[i] = min(dp[i],dp[j]+a[i].len);	
	//打擂台求最小（答案）：		
	ans = 1<<30;	//初始化无穷大
	for( int i = 1; i <= n; ++i)
		if(f[n+1][i])//最后一个红线段为第i条 
			ans = min(ans,dp[i]);
	printf("%lld\n",ans);
	return 0;
}
```

## $O\left(nlogn\right)$ 做法

听说还有此等神仙做法？本人蒟蒻一枚，怎么可能知道！

## 完结撒花~

#### ~~这是本蒟蒻的第一篇题解，求通过 QAQ~~

---

## 作者：仙肉粽子 (赞：3)

# P8591 『JROI-8』颅脑损伤 2.0

[题目传送门](https://www.luogu.com.cn/problem/P8591)

~~为什么有人看到这道题第一想法是搜索啊。~~

## 解题思路

首先，我们可以考虑 DP。~~其实可以用记忆化搜索写，但是我懒。~~

* 先以 $l$ 排序一遍，时间复杂度 $O(n \ log \ n)$ 。

* 设 $dp_i$ 为第 $i$ 个线段被标红时前 $i$ 条线段的最小代价。

* 所以，有公式

$$
dp_i = \min_{r_k \ge l_i} \min_{r_j \ge l_k} dp_j + r_i - l_i
$$

* 我们发现 $k$ 在计算 $dp_i$ 的时候只起到确定 $j$ 的作用，我们可以尝试把他舍掉，以 $i$ 确定 $j$。我们发现，我们只要保证在 $i$ 到 $k$ 之间的黑色线段与 $i$ 或 $k$ 相交就可以了，所以

$$
\max_{k \in (i,j), r_k < l_i, l_k \le r_i} l_k \le r_j \le l_i
$$

那么，我们的正解就出来了，亮代码！

```cpp
#include<bits/stdc++.h>
#define rep(i,s1,s2,s3) for(i = s1;i <= s2;i += s3)
#define r(i,s1,s2,s3) for(i = s1;i >= s2;i -= s3)
#define INF 0x77f7f7f7f7f7f7fll
#define ull unsiged ll
#define ll long long
using namespace std;
ll n,ans = INF,dp[100010];
struct node{
    ll l,r;
    ll len(){
        return r - l;
    }
}a[100010];
bool cmp(node s1,node s2){
    return s1.l == s2.l ? s1.r < s2.r : s1.l < s2.l;
}
int main(){
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#ifdef ONLNE_JUDGE
#else
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
    cin>>n;
    ll i,j,id;
    rep(i,1,n,1) cin>>a[i].l>>a[i].r;
    sort(a + 1,a + n + 1,cmp);
    memset(dp,0x3f,sizeof(dp));
    a[0].r = -INF;
    dp[0] = 0;
    rep(i,1,n,1){
        id = -INF;
        r(j,i,0,1){
            if(a[j].r >= a[i].l || a[j].r < id) continue;
            dp[i] = min(dp[i],dp[j] + a[i].len());
            id = max(id,a[j].r);
        }
    }
    rep(i,1,n,1) if(a[i].r >= a[n].l) ans = min(ans,dp[i]);
    cout<<ans;
    return 0;
}
```

这个代码好像被宇宙射线修改了，请谨慎提交。

---

## 作者：Lyco_Reco (赞：3)

提供一种时间复杂度较劣，但是比较好想的方法。

首先将线段按照左端点排序，然后利用单调性，在DP枚举的时候二分出第一个左端点大于左边线段的右端点的线段（即与左边线段没有交点的线段），因为我们要满足每一条黑色线段都至少和一条红色线段相交，而我们二分出的线段左边的线段都已经满足条件，我们只需要保证剩下的线段都和右边的线段有交点即可，因此考虑用st表维护区间右端点最小值，如果右端点最小的线段满足要求，那么其他线段一定满足。

时间复杂度  $O(n^{2}\log{n})$

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <deque>
#include <queue>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
#define maxn 3010
int n,dp[maxn],log_2[maxn],f[maxn][21],t[maxn];
struct node{
	int l,r;
	friend bool operator<(node a,node b){
		return a.l<b.l;
	}
}a[maxn];
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	int _min(int a,int b){
		return a<b? a:b;
	}
	void init(){
		for(int i=1;i<=n;i++){
			f[i][0]=a[i].r;
		}
		for(int j=1;(1<<j)<=n;j++){
			for(int i=1;i<=n-(1<<j)+1;i++){
				f[i][j]=_min(f[i][j-1],f[i+(1<<j-1)][j-1]);
			}
		}
	}
	int query(int l,int r){
		int k=log_2[r-l+1];
		return _min(f[l][k],f[r-(1<<k)+1][k]);
	}
	void MAIN(){
		n=rd();
		for(int i=2;i<=n;i++){
			log_2[i]=log_2[i>>1]+1;
		}
		for(int i=1;i<=n;i++){
			a[i].l=rd();
			a[i].r=rd();
		}
		a[0].l=-inf;
		a[0].r=-inf;
		a[++n].l=inf;
		a[n].r=inf;
		sort(a+1,a+n+1);
		for(int i=1;i<=n;i++){
			t[i]=a[i].l;
		}
		init();
		for(int i=1;i<=n;i++){
			dp[i]=inf;
		}
		for(int i=1;i<=n;i++){
			for(int j=0;j<i;j++){
				if(a[i].l<=a[j].r){
					continue;
				}
				int x=upper_bound(t+1,t+n+1,a[j].r)-t;
				if(x<i){
					if(query(x,i-1)<a[i].l){
						continue;
					}
				}
				dp[i]=_min(dp[i],dp[j]+a[i].r-a[i].l);
			}
		}
		wrt(dp[n]);
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	Main::MAIN();
	return 0;
}

```

---

## 作者：_SeeleVollerei_ (赞：3)

@Cocoly1990 ，我这算官方题解吧？

因为任意两个红色线段不相交，所以考虑按照 $l_i$ 从小到大排序，然后考虑怎么选红色线段。

设 $f_i$ 表示强制将第 $i$ 条线段变为红色线段时，前 $i$ 条线段的答案。

考虑转移，显然有 $f_i=f_j+len_i$。然后去找满足条件的 $j$。

这个满足条件首先 $i$ 与 $j$ 不相交，这个是好判断的。然后就是任意黑色都与至少一个红色相交。所以考虑 $[j+1,i-1]$ 之间的线段需要满足要么和 $j$ 相交，要么和 $i$ 相交。考虑和 $j$ 相交的条件为 $l_k\le r_j$，然而因为我们已经按照 $l_i$ 排序了，所以 $j$ 相交的黑色线段一定是 $j$ 往后的一段连续区间。那么剩下的就是 $i$ 往前的一段连续区间，需要满足 $r_k\ge l_i$。我们只需要在枚举 $j$ 的时候顺便维护一下每个位置的后缀的 $r_k$ 的最大值即可。

复杂度 $O(n^2)$。

考虑加强，$n\le 10^5$。

令 $g_i$ 表示不强制选 $i$ 时，且前 $i$ 个线段都满足条件时的答案。

这个东西有什么好处？我们不再需要枚举 $j$，只关心 $i$ 能往前覆盖的区间。

换句话说，找到在满足 $r_k\ge l_i$ 的前提下最小的 $k$，这个可以二分套个 ST 表或者别的乱搞方式，我懒得想了。那么转移式子可以直接写为 $f_i=\min_{j=k}^{i-1}\{g_j+len_i\}$，这玩意就是个区间 $\min$。

$g_i$ 怎么求？考虑求出 $f_i$ 以后，找到最大的 $k$ 满足前面一段全部都 $l_k\le r_i$，那么将 $f_i$ 更新到 $g_k$ 即可。

然后就是一个单点修改，区间求 $\min$ 的操作了，数据结构维护即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e5+5;
const int Z=17;
struct Node{
	int ll,rr;
}p[N];
int n,f[N];
inline int Read(){
	char ch;
	int f=1;
	while((ch=getchar())<'0'||ch>'9')
		if(ch=='-') f=-1;
	int x=ch^48;
	while((ch=getchar())>='0'&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
inline void print(int x){
	if(x>=10) print(x/10);
	putchar(x%10+48);
	return ;
}
inline void Print(int x,char ch='\n'){
	if(x<0){
		putchar('-');
		print(-x);
	}
	else print(x);
	putchar(ch);
	return ;
}
inline bool Cmp(Node x,Node y){
	return x.ll<y.ll;
}
inline int Max(int x,int y){
	return x>y?x:y;
}
inline int Min(int x,int y){
	return x<y?x:y;
}
inline void Cmax(int&x,int y){
	if(y>x) x=y;
	return ;
}
inline void Cmin(int&x,int y){
	if(y<x) x=y;
	return ;
}
int mn[N<<2];
inline void Update(int u){
	mn[u]=Min(mn[u<<1],mn[u<<1|1]);
	return ;
}
inline void Change(int u,int ll,int rr,int p,int value){
	if(ll==rr) return Cmin(mn[u],value);
	int mid=ll+rr>>1;
	if(mid>=p) Change(u<<1,ll,mid,p,value);
	else Change(u<<1|1,mid+1,rr,p,value);
	return Update(u);
}
inline int Query(int u,int ll,int rr,int ql,int qr){
	if(ll>=ql&&rr<=qr) return mn[u];
	int mid=ll+rr>>1,ss=0x3f3f3f3f;
	if(mid>=ql) Cmin(ss,Query(u<<1,ll,mid,ql,qr));
	if(mid<qr) Cmin(ss,Query(u<<1|1,mid+1,rr,ql,qr));
	return ss;
}
int g[N][Z],lg[N];
inline void Init(){
	n=Read();
	lg[0]=-1;
	for(int i=1;i<=n;i++){
		lg[i]=lg[i>>1]+1;
		p[i].ll=Read();
		p[i].rr=Read();
	}
	++n;
	p[n].ll=1e9+1;
	p[n].rr=1e9+1;
	lg[n]=lg[n>>1]+1;
	sort(p+1,p+n+1,Cmp);
	for(int i=1;i<=n;i++)
		g[i][0]=p[i].rr;
	for(int j=1;j<Z;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			g[i][j]=Min(g[i][j-1],g[i+(1<<j-1)][j-1]);
	return ;
}
inline int Ask(int ll,int rr){
	int len=rr-ll+1;
	int lgg=lg[len];
	return Min(g[ll][lgg],g[rr-(1<<lgg)+1][lgg]);
}
inline void Solve(){
	memset(mn,0x3f,sizeof(mn));
	Change(1,1,n,1,0);
	for(int i=1;i<=n;i++){
		int ll,rr;
		ll=1,rr=i;
		while(ll<rr){
			int mid=ll+rr>>1;
			if(Ask(mid,i)>=p[i].ll) rr=mid;
			else ll=mid+1;
		}
		f[i]=Query(1,1,n,ll,i)+p[i].rr-p[i].ll;
		ll=i,rr=n;
		while(ll<rr){
			int mid=ll+rr+1>>1;
			if(p[mid].ll<=p[i].rr) ll=mid;
			else rr=mid-1;
		}
		if(ll<n) Change(1,1,n,ll+1,f[i]);
	}
	return Print(f[n]);
}
int main(){
	Init();
	Solve();
	return 0;
}
```

---

## 作者：卷王 (赞：2)

**一道代码短，却考验思维的题。**

模拟显然可以，但是看到数据范围：

|测试点编号|$n\le$|
| :----------: | :----------: |
|$1\sim4$|$10$|
|$5\sim8$|$400$|
|$9\sim20$|$3000$|

看来模拟是不行了。那么我们考虑贪心，如果这条线段满足条件就选择，否则就放弃（你想想，要是这样的话，这么水的题会放 T4 吗），很容易构造出反例。

那么贪心不行，那么就得用 dp 了。我们设 $dp_i$ 表示将第 $i$ 个线段染红，前 $i$ 个线段的最大长度。

我们考虑枚举第 $i$ 个线段 **上一条被染成红色的线段** $j$，那么转移方程就是：$dp_i \leftarrow dp_j + len(i)$（没错，就是这么简单），$len(i)$ 表示第 $i$ 条线段的程度。最后取个最小值就可以了。

这道题就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}

int n, ans = 2e9;
struct node {
	int l, r;
} a[3007];
int dp[3007];
//dp[i] 表示将第 i 个线段染红，前 i 个线段的最大长度

inline bool cmp(node x, node y) {
	return x.l < y.l;
}

int main() {
	n = read();
	for(int i = 1; i <= n; i++)
		a[i].l = read(), a[i].r = read();
	sort(a + 1, a + n + 1, cmp);
	memset(dp, 0x3f, sizeof(dp)); dp[0] = 0;
	a[0].r = -2e9; //注意！！！j 要循环到 0 来调用 dp[0]，但是如果 a[0].r = 0，那么会直接跳过！！
	for(int i = 1; i <= n; i++) {
		int maxx = -2e9;
		for(int j = i - 1; j >= 0; j--) {
			if(a[i].l <= a[j].r || a[j].r < maxx) continue; //j 的判断，a[j].r < maxx 表示这个线段与拥有最大左端点的线段相交，不符合题意。
			maxx = max(maxx, a[j].l); //maxx 表示到现在最大的左端点
         dp[i] = min(dp[i], dp[j] + a[i].r - a[i].l);
		}
	}
	for(int i = 1; i <= n; i++)
      if(a[i].r >= a[n].l) ans = min(ans, dp[i]);
	cout << ans;
	return 0;
}
```

---

## 作者：船酱魔王 (赞：2)

# P8591 『JROI-8』颅脑损伤 2.0 题解

## 题意回顾

$ n $ 条线段染色，红色线段之间不可相交，黑色线段至少与一条红色线段相交，求最小红色线段长度和。

$ n \le 3000 $。

## 分析

一看数据范围 $ O(n^2) $ 可过，考虑设计暴力 DP。

我们按照左端点为第一关键字，右端点为第二关键字排序。

我们设计 $ dp_i $ 为第 $ i $ 条染红，前 $ i $ 条线段染色完成的最小长度。

定义 $ d(i,j) $ 为 $ i,j $ 线段是否相交。

则设计方程 $ dp_i=\min_{j<i,d(j,i)=0,\forall j<k<i,d(k,i)=1\operatorname{or}d(k,j)=1}\{dp_j+r_i-l_i\} $。

理解这个方程很简单，$ j,i $ 肯定不交，$ j+1\sim i-1 $ 的所有线段如果与 $ i $ 以后的红色线段相交的话必然已经与 $ i $ 相交，如果与 $ j $ 以前的红色线段相交的话必然那条红色线段已经与 $ j $ 相交，不符合要求，这种请况根本不会出现（因为我们在转移方程里已经排除了红色线段相交的情况）。

因为我们发现 $ j $ 向左移的时候 $ k $ 不用每次重新算一遍，可以维护线段左端点最大值来快速判断最后一个转移条件。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 3005;
int n;
struct node {
	int l;
	int r;
} a[N];
bool operator<(node p1, node p2) {
	if(p1.l != p2.l) {
		return p1.l < p2.l;
	}
}
int dp[N];
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i].l >> a[i].r;
	}
	sort(a + 1, a + n + 1);
	dp[0] = 0;
	a[0].l = -1e9 - 2;
	a[0].r = -1e9 - 1;
	int pre;
	for(int i = 1; i <= n; i++) {
		dp[i] = 2e9 + 5;
		pre = -1e9 - 5;
		for(int j = i - 1; j >= 0; j--) {
			if(a[j].r >= a[i].l) {
				continue;
			}
			if(a[j].r < pre) {
				continue;
			}
			pre = max(pre, a[j].l);
			dp[i] = min(dp[i], dp[j] - a[i].l + a[i].r);
		}
	}
	int ans = 2e9 + 5;
	for(int j = n; j >= 1; j--) {
		if(a[j].r < a[n].l) {
			continue;
		}
		ans = min(ans, dp[j]);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Targanzqq (赞：1)

主要思路：单调队列优化 dp。

### Part 1：设计 dp 状态

我们设的状态和其他大佬们的差不多，仍然是用 $f_i$ 表示按**左端点排序**后，第 $i$ 条及以前的线段都已经染色完，且第 $i$ 条线段染成**红色**的最小代价。

假设上一条可以被染成红色的线段为 $j$，我们需要满足 $r_j<l_i$，与 $[l_j,r_i]$ 相交的其它线段都与 $i,j$ 相交。也就是说不存在一条黑色线段 $k$ 满足 $l_k>r_j$ 且 $r_k<l_i$，因此我们找到 $r_k<l_i$ 且 $l_k$ 最大的 $k$ 对于所有合法的 $j$，满足 $r_j\ge l_k$。因此 $f_i=len_i+\min\limits_{r_j\ge l_k,r_j\le l_i}f_j$。

如果我们枚举所有的 $j$，它的时间复杂度是 $O(n^2)$ 的，对于这个题我们可以使用这种方法。但是这个过程还是可以优化的，我们可以考虑优化找最小 $f_j$ 的过程。

我们发现，如果我们按照右端点排序，所有能满足条件的线段是连续的。如果我们按照左端点排序，所有的 $pos_i$ 是单调不降的。难点转化为把这两个性质合并起来。

我们考虑到，每条线段实际端点的位置并不需要关心，我们只关心它们的**长度**以及与其它线段的**相交情况**。因此我们可以先离散化。离散化以后，我们对 $f_i$ 做一下修改：$f_i$ 表示离散化后如果第 $i$ 个位置有一条线段的**右端点**，这条线段及**左端点**在这条线段以前的其它线段已经染色完成，且这条线段被染成**红色**的最小代价。

这样上面两个性质在离散化后的值域上都成立。因此我们使用双指针，$i$ 表示当前枚举到的右端点，$pos$ 表示当前枚举到的满足 $r_j<l_i$ 的线段右端点 $r_j$，同时记录一个 $maxn$ 表示上面的 $k$，即以 $i$ 为右端点的线段的 $k$。我们还需要预处理出 $h_i$ 表示以 $i$ 为右端点的线段对应的左端点。这是所有需要记录的数据。

这样我们就可以轻松维护 $j\in[pre,i]$ 的所有 $f_j$ 的最小值，不难想到线段树，但是我们每次查询的左右端点都是单调不降的，所以我们使用一种好写，时间复杂度低，但是不好理解而且直接用起来不是很方便的数据结构——单调队列。

### Part 2：单调队列详解
单调队列常用到一个条件，一个性质和两个操作。一个条件是查询范围**连续**且左右端点**位置单调不减**，一个性质是队列内的所有元素都满足**单调递增**或**单调递减**，两个操作是从**队头**弹出不在范围内的元素，以及从**队尾**维护单调性。由于每个元素只会进队和出队**各一次**，因此单调队列的时间复杂度是 $O(n)$ 的。

我们先考虑维护单调性。因为我们要在过程中维护，因此我们假设队列中的元素具有单调性。当我们加入元素时，会弹出所有队尾相对于当前元素不优的所有元素。也就是说弹出所有需要弹出元素后，其余元素与位于队尾的当前元素保持单调性不变。当我们删除队头元素时，单调性显然保持不变。

然后我们考虑查询。首先我们考虑到，队列里的元素下标显然是单调递增的，因此我们从队头弹出元素，直到队头元素在范围内，这个元素一定是最优的。比如说我们需要求最小值，那我们维护单调递增，在从队头弹出所有不在范围内的元素后，此时队头的元素一定是范围内的最小值，如果求最大值则维护单调递减。

**正确性证明**：我们试图将一个元素放进队内时，会删除所有**不比它更优**的元素，而对于每个元素我们都删掉了它前面不比它更优的元素，并且不会被后面不如它优的元素删除，且队内维护了单调性（如果求**最小值**则维护单调**递增**，如果求**最大值**则维护单调**递减**），因此队头的元素一定是最优的。

对于这个题我们需要按左端点排序后，枚举每一条线段，并查询 $j\in[pre,i]$ 的所有 $f_j$ 的最小值，因此我们将值域上每个点的答案都使用单调队列更新（如果没有线段以这个点为右端点，那么这个点的答案不会被更新，也就是 $+∞$）。

更新贡献的方式是将 $pos$ 向右移动，直到  $pos=l_i-1$，此时我们加入了原来的 $pos$ 到 $l-1$ 中所有点的贡献。然后我们维护 $maxn$，具体来说就是在更新 $pos$ 的同时将 $maxn$ 更新为所有枚举到的线段右端点所对应的左端点的最大值。这样我们就找到了更新答案的左端点。然后我们将队列中所有小于这个左端点的值都弹出队列，这样我们得到的队头就是上面需要求的 $\min\limits_{r_j\ge l_k,r_j\le l_i}f_j$。然后我们把这个值加上 $len_i$ 的长度，就是我们所求的 $f_i$。

最后我们需要求答案。最后一个线段的颜色不确定，因此上一条红色线段可以是所有与它相交的点或它自己。因此如果当前线段和最后一条线段相交，那么我们可以用当前的 $f_i$ 去更新 $ans$。

总时间复杂度 $O(n\log n)$，复杂度瓶颈在于离散化和排序。

源代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1e9+7
#define N 1000005
#define em q.empty()
using namespace std;

int n;
struct segment{
	int l,r,len;
	friend bool operator<(segment a,segment b){
		return a.r<b.r;
	}
}a[N];
bool mycmp(segment a,segment b){
	return a.l<b.l;
}
int p[2*N],h[2*N],top;

int binary(int x,int l,int r){
	while(1){
		if(l>r)break;
		int mid=(l+r)/2;
		if(p[mid]<x)l=mid+1;
		else r=mid-1;
	}
	if(p[l]==x)return l;
	else return r;
}

void lsh(){
    for(int i=1;i<=n;i++)p[++top]=a[i].l,p[++top]=a[i].r;
	sort(p+1,p+top+1);
	int len=unique(p+1,p+top+1)-p-1; 
	for(int i=1;i<=n;i++){
		a[i].l=binary(a[i].l,1,len);
		a[i].r=binary(a[i].r,1,len);
	}
}

int f[2*N];
deque<int> q;

signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r;
		a[i].len=a[i].r-a[i].l;
	}
	sort(a+1,a+n+1,mycmp);
	lsh();
	int ans=INF;
	for(int i=1;i<=2*n;i++)f[i]=INF;
	for(int i=1;i<=n;i++)h[a[i].r]=a[i].l;
	f[0]=0;q.push_back(0);
	for(int i=1,pos=1,maxn=0;i<=n;i++){
	    while(pos<a[i].l){
	        maxn=max(maxn,h[pos]);
			while(!em&&f[q.back()]>=f[pos])q.pop_back();
			q.push_back(pos++);
		}
		while(!em&&q.front()<maxn)q.pop_front();
	    f[a[i].r]=min(f[a[i].r],f[q.front()]+a[i].len);
	    if(a[i].r>=a[n].l)ans=min(ans,f[a[i].r]);
	}
	cout<<ans;
}
```

对了，最后再提一句，梦熊的数据直接写很可能会 TLE，我当时被卡了两个小时，然后我在脑子不清醒的状态下把 $sort$ 换了个位置，就神奇的过了，有谁可以解释一下吗？

---

## 作者：Lucyna_Kushinada (赞：1)

好题。

按照套路，我们先按右端点排序，为了方便转移，我们让 $l_0=r_0=-2\times 10^9$，即赋一个极小值。

令 $dp_i$ 为给 $i$ 染为红色的最小答案，显然我们需要枚举上一条染红色的线段 $j$ 来转移到 $i$。

则线段 $j(j<i)$ 能转移到 $dp_i$ 当且仅当它不与 $i$ 有交，且 $j+1\sim i-1$ 之间的线段要么与 $j$ 交要么与 $i$ 有交，因为它们染为黑色，必须和一条红色线段相交。

我们猜测对于 $i$，能转移到 $i$ 的线段编号构成了一个区间 $[x,y]$。

则 $y$ 显然为从右往左第一个使得 $r_y<l_i$ 的线段，那么 $x$ 就是使得 $r_x\ge\max_{k=0}^y l_k$ 的最小 $x$，因为排序后 $r$ 是单调的，所以都能二分出来，然后这个题显然可以再用线段树把复杂度优化成 $O(n \log_2 n)$。

所以转移方程就是，

$$dp_i=\min_{j=x}^y dp_j+r_i-l_i$$

需要注意到是并不是所有 $dp_i$ 对答案有贡献，$i$ 能对答案有贡献当且仅当 $r_i\ge\max_{j=i+1}^n l_j$，即可以与后面的线段都有交，不然就不合法了。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back

#define N 1000010
#define int long long

const int lim=1e6+5;
int n,dp[N],mx[N];

struct ln{
    int l,r;
}a[N];

inline bool cmp(ln x,ln y){
    if(x.r!=y.r){
        return x.r<y.r;
    }

    return x.l<y.l;
}

struct SEGT{
    int tr[N<<2];

    inline void un(int k){
        tr[k]=min(tr[k*2],tr[k*2+1]);
    }

    inline void build(int k,int l,int r){
        if(l==r){
            tr[k]=1e17;
            return;
        }

        int mid=(l+r)>>1;

        build(k*2,l,mid);
        build(k*2+1,mid+1,r);

        un(k);
    }

    inline void upd(int L,int k,int l,int r,int d){
        if(l==r){
            tr[k]=d;
            return;
        }

        int mid=(l+r)>>1;

        if(L<=mid){
            upd(L,k*2,l,mid,d);
        }
        else{
            upd(L,k*2+1,mid+1,r,d);
        }

        un(k);
    }

    inline int ask(int L,int R,int k,int l,int r){
        if(L<=l&&R>=r){
            return tr[k];
        }

        int mid=(l+r)>>1,ans=1e17;

        if(L<=mid){
            ans=ask(L,R,k*2,l,mid);
        }
        if(R>mid){
            ans=min(ans,ask(L,R,k*2+1,mid+1,r));
        }

        return ans;
    }
}b;

inline int getr(int k){
    int l=0,r=k-1,mid,ans=-1;

    while(l<=r){
        mid=(l+r)>>1;

        if(a[mid].r<a[k].l){
            ans=mid;
            l=mid+1;
        }
        else{
            r=mid-1;
        }
    }

    return ans;
}

inline int getl(int R){
    int l=0,r=R,mid,ans=-1;

    while(l<=r){
        mid=(l+r)>>1;

        if(a[mid].r>=mx[R]){
            ans=mid;
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }

    return ans;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    int lmx=-1e9;

    cin>>n;
    rep(i,1,n){
        cin>>a[i].l>>a[i].r;

        lmx=max(lmx,a[i].l);
    }

    sort(a+1,a+1+n,cmp);
    a[0].l=a[0].r=-2e9;

    int ans=1e17;

    b.build(1,0,lim);
    b.upd(0,1,0,lim,0);//dp[0]

    mx[0]=-2e9;
    rep(i,1,n){
        mx[i]=max(mx[i-1],a[i].l);
    }

    rep(i,1,n){
        int r=getr(i);
        int l=getl(r);

        if(r==-1||l==-1){
            continue;
        }

        dp[i]=b.ask(l,r,1,0,lim)+a[i].r-a[i].l;
        b.upd(i,1,0,lim,dp[i]);

        if(a[i].r>=lmx){
            ans=min(ans,dp[i]);
        }
    }
    
    cout<<ans;

    return 0;
}
```

---

## 作者：违规用户名^3Zj=Oha (赞：0)

## 一、题目简述
共 $n$ 条线段进行染色，使一些为黑，一些为红，并且满足条件：两条红色线段不可相交，黑色线段必须与一条红色线段相交，求红色线段最大长度和。

## 二、思路分析
因为本题数据为 $3000$，所以先否定掉模拟，那就只有 dp 了。（区间 dp）

我们可以先进行排序，然后找符合条件的，最后进行 dp，很容易得出状态转移方程，即为 $\operatorname{f[i]=min(f[i],f[j])}$。


## 三、构造代码
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node{
    int l,r;
    friend bool operator<(node a,node b){//重载操作符
        return a.r<b.r;
    }
}p[3005];
long long f[3005],n,ok[3005][3005],res=1e18;
bool xj(int a,int b){
    if(a==0||b==0||a>n||b>n) return 0;
    return p[a].l<=p[b].r&&p[b].l<=p[a].r;//检查符合要求
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>p[i].l>>p[i].r;
    sort(p+1,p+n+1);//排序
    for(int i=1;i<=n;i++){
        int idx=0;
        for(int j=i;j<=n;j++){
            if(!xj(j,i-1)){
                if(idx==0) idx=j;
            }
            if(idx){//如果符合
            	if(!xj(idx,j+1)){
					ok[i][j]=0;
					continue;
				}
			}
            ok[i][j]=1;
        }
        ok[i][i-1]=1;
    }
    ok[n+1][n]=1;
    for(int i=1;i<=n;i++){
        f[i]=1e18;
        for(int j=i-1;j>=0;j--){
            if(!xj(i,j)){
                if(ok[j+1][i-1]) f[i]=min(f[i],f[j]);//进行dp
            }
        }
        f[i]+=p[i].r-p[i].l;
        if(ok[i+1][n]) res=min(res,f[i]);
    }
    cout<<res;
}
```

---


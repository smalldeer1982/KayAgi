# 觅光 | Searching for Hope (easy ver.)

## 题目背景

**这是本题的简单版本。两个版本在 $\bm{100 \%}$ 数据范围的唯一区别是关于 $\bm{n}$ 的限制。此版本中 $\bm{n \le 1000}$。**

---

有梦中所向往的地方，也有现实中可望不可触及的远方。

我们正等待无数次的希望，新的纪元，生命不曾奏响终章。

顷刻间颠覆中的一切，天空坠落到海底，死死卡住呼吸者的全部。羽翼裹满刺骨的海水，悲伤到从此遗忘呼吸的意义。

明明与空气只隔着毫厘，却不想再尝试去呼吸。我开始明白，悲伤到了极点，也许不会流泪

神明借着生的名义，捏造出灰暗的真理。



泪水模糊眼眶，身躯坠进天空，泛白的天光，不得已照亮这一日的希望。

## 题目描述

现在有一棵 $n$ 个节点的有根二叉树。

凡人与神明在这棵树上进行一个游戏。凡人需要从根投下若干个球，每个球带 $1$ 单位正电荷或带 $1$ 单位负电荷。

树上每一个点有容量，第 $i$ 个点可以容纳 $c_i$ 个球。初始每一个点容纳的球数为 $0$。我们称一个点被充满当且仅当它容纳的球的个数等于它的容量。

每一次一个球下落到一个点时：

- 如果该点没有孩子节点或者所有孩子节点上都已经充满球，则停止，该点容纳的球的个数 $+1$；
- 如果该点恰有一个孩子节点未充满，则向那个孩子下落；
- 如果有 $2$ 个孩子节点均未充满：
	- 如果左侧子树中所有球的电荷代数和大于右侧子树所有球的电荷代数和，则如果当前球带正电则向右下落，否则向左下落；
   - 如果左侧子树中所有球的电荷代数和小于右侧子树所有球的电荷代数和，则如果当前球带正电则向左下落，否则向右下落；
   - 如果左侧子树中所有球的电荷代数和等于右侧子树所有球的电荷代数和，则由神明决定向哪个方向下落。
   
其中，电荷代数和指的是正电荷的数量减去负电荷的数量。
   
在游戏开始前，双方约定目标点 $u$。在一个回合中，凡人选择这次投下的球的电性，神明按上述规则控制球的下落过程。当 $u$ 被充满时，游戏结束。

凡人希望游戏回合数尽量少，神明希望游戏回合数尽量多。假设双方足够聪明。

对所有：$1\leq u\leq n$，求游戏轮数 $r_u$。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | $n \le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |:-:|
| 1 | $1000$ | A | 11 |
| 2 | $10$ | B | 27 |
| 3 | $1000$ | | 62 |

- 特殊性质 A：树退化成一条以 $1$ 为一端的链。
- 特殊性质 B：$c_i = 1$。

对于 $100\%$ 的数据，$2 \le n \le 1000$，满足树是以 $1$ 为根的二叉树，$1 \le f_i < i$，$1 \le c_i \le {10}^{12}$。

## 样例 #1

### 输入

```
5
1 1 2 2
1 1 1 1 1
```

### 输出

```
5 4 2 3 3```

# 题解

## 作者：Sol1 (赞：17)

## 算法 1

输出每个点子树大小。

显然对链是正确的，期望得分 11。

## 算法 2

$c=1$ 时，一种指数级做法是记每一个点没球/有正电球/有负电球，然后状压 dp。复杂度 $O(3^nn)$。

当然你也可以使用其他暴力做法。期望得分 27。结合算法 1 期望得分 38。

## 算法 3

结论：先手全扔正电球，后手尽量让球与目标位置的 LCA 靠上。

证明：

首先，一个容量为 $c$ 的点可以被替换成一条长度为 $c$ 的链。于是接下来只考虑容量为 $1$ 的情况。

考虑对任意树归纳。归纳边界：

- 任意树，目标点为根时成立。
- 大小为 1 的树，目标点是任意点时成立。

下假设对于任意大小 $\leq S$ 的树，目标点为任意点时成立。

考虑一棵大小为 $S+1$ 的树，不妨假设目标点在左侧，左侧在双方均执行最优策略时需要投下 $k$ 个球（也就是说，投下 $<k$ 个球时，无论球的电性，均无法达到目标；而由归纳假设，投下 $k$ 个正电球可以达到目标）。设右侧子树大小为 $s$。同样执行上述策略时，显然 A 投下 $\min\{2k,s+k\}$ 个球可达到目标。下证明 A 不能使用更少的球数达到这个目标。

考虑 A 依次投下的球。考虑分组：第一个球和第二个球为一组，第三个球和第四个球为一组，以此类推。不难发现，在两侧均不满且任意一组球的第一个球投下之前，根的两侧电荷一定平衡。从而 B 只能在两侧均不满时决策一组球中的第一个球。

分类讨论：

- 如果两个球电性相同，无论扔哪边都得往左边掉一个，所以先扔右边。
- 如果两个球电性不同，扔右边就都去右边，扔左边就都去左边，所以扔右边。

因此，只要两侧均不满，对于任意一组中的两个球，B 一定能够保证只有后投下的球落入左侧，或者都不落入左侧。因此 A 不能使用更少的球数达到这个目标。

于是 A 最优策略得证。

证明 A 最优策略后，B 实际上已经没有决策，且过程就是让球与目标位置的 LCA 靠上。于是得证。

---

有了这个结论以后，对于每一个点 $u$，答案可以向上递推：初始是子树大小 $a_u=S_u$，每次往上一个点，设另一个儿子的子树大小是 $S$，则 $a_u\leftarrow a_u+\min\{a_u,S\}$。

暴力递推，复杂度 $O(n^2)$，期望得分 100。









---

## 作者：FFTotoro (赞：8)

## 前言

一年前赛时过的题，来补个题解。

## 解法

显然凡人只能投一种电荷（不妨设为正电荷），否则必然不优，原因显然。

因为神明要让游戏轮数变多，所以如果它可以决策，都得往与目标点所在方向的相反的方向扔。而又因为要左右子树电荷数平衡，所以先得在另一棵子树填上与目标所在子树的答案相等数量的电荷，注意另一棵子树的子树和不一定大于目标所在子树的答案，此时把另一棵子树填满即可。

枚举每一种目标结点，不断往上找父亲并更新答案。具体地，令另外一棵子树大小为 $S$，当前答案为 $c$，则 $c\leftarrow c+\min\{c,S\}$。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
main(){
  ios::sync_with_stdio(false);
  int n; cin>>n;
  vector<int> p(n,-1),c(n),s(n);
  vector<array<int,2> > k(n,{-1,-1});
  for(int i=1;i<n;i++){
    int x; cin>>x; p[i]=--x;
    (~k[x][0]?k[x][1]:k[x][0])=i;
  } // 建树
  for(auto &i:c)cin>>i;
  function<void(int)> dfs=[&](int u){
    if(~k[u][0])dfs(k[u][0]),s[u]+=s[k[u][0]];
    if(~k[u][1])dfs(k[u][1]),s[u]+=s[k[u][1]];
  }; // 预处理子树和
  s=c,dfs(0);
  for(int i=0;i<n;i++){
    int x=i,c=s[i];
    while(~p[x]){
      int b=(x==k[p[x]][0]?k[p[x]][1]:k[p[x]][0]);
      c+=min(c,~b?s[b]:0),x=p[x];
    } // 暴力找父亲，更新答案
    cout<<c<<' ';
  }
  cout<<endl;
  return 0;
}
```

---

## 作者：hcywoi (赞：6)

## Subtask 1
树为一条链。

球下落的点固定，$r_i=sz_i$，$sz_i$ 为第 $i$ 棵子树的大小。

## Subtask 2

$n\le 10, c_i=1$，记录每个点的状态无球/正电球/负电球。然后进行状压 dp，时间复杂度：$\mathcal O(3^nn)$。

## Subtask 3

先附一张丑图。

![](https://cdn.luogu.com.cn/upload/image_hosting/ygmqj85m.png)

红点为要填满的点。

---

> 性质 $1$：如果红点为**整棵子树的根**，那么轮数一定是 $\sum\limits_{i=1}^{n}c_i$（不理解好好读题）。

---

> 性质 $2$：$fa_i/fa_{fa_i}/fa_{fa_{fa_i}}/\cdots$ 一定是没有球。

---

贪心的考虑，我们是要尽量减少往右子树的投放，因为往左子树投放的是固定的。

---

$$\textrm{Step } 1:$$

神明**一定可以**是往右子树投放。

证明：

如果往左子树投，那么 $\textrm{Step } 2$ 凡人可以投相同属性的球继续往左子树投，这样神明就无法选择往哪里投放，而往右子树投至少能让轮数加 $1$。

---

$$\textrm{Step } 2:$$

凡人可以选择与 $\textrm{Step } 1$ 相同的属性，那么就可以往左子树投。

---

$$\textrm{Step } 3:$$

因为电相同，所以回到了 $\textrm{Step } 1$。

---

这样轮回，直到左子树或右子树充满。

然后每两个 $\textrm{Step}$ 是相同属性的，且没有关联，所以可以投放全是正电的。

---

根据性质 $2$ 可知，这个支持递归的，因为球只会落到左/右子树。

递归到第 $i$ 个点时，且这个点是红点，则以第 $i$ 个子树为根的操作次数为 $sz_i$，然后返回时以第 $i$ 个为根的操作次数为 $sz_x+\min\{sz_x,sz_y\}$（$x$ 为有红点的子树，$y$ 为令一颗子树）。

### Code
```cpp
#include <bits/stdc++.h>

typedef long long LL;

const int N = 1010, M = N * 2;

int n;
struct Tree
{
	int l, r;
	void init(int _l, int _r)
	{
		l = _l, r = _r;
	}
}tr[N];
LL c[N], sz[N];

int main()
{
	scanf("%d", &n);

	for (int i = 1; i <= n; i ++ ) tr[i].init(0, 0);

	for (int i = 2; i <= n; i ++ )
	{
		int p;
		scanf("%d", &p);
		if (tr[p].l) tr[p].r = i;
		else tr[p].l = i;
	}
	for (int i = 1; i <= n; i ++ ) scanf("%lld", &c[i]);

	auto calc = [&](auto calc, int x) -> LL
	{
		LL s = c[x];
		if (tr[x].l) s += calc(calc, tr[x].l);
		if (tr[x].r) s += calc(calc, tr[x].r);
		return sz[x] = s; 
	};
	calc(calc, 1);

	auto dfs = [&](auto dfs, int x, int v) -> LL
	{
		LL left = 0, right = 0;
		if (tr[x].l) left = dfs(dfs, tr[x].l, v);
		if (tr[x].r) right = dfs(dfs, tr[x].r, v);
		if (left) return left + std::min(left, sz[tr[x].r]);
		if (right) return right + std::min(sz[tr[x].l], right);
		if (x == v) return sz[x];
		return 0;
	};

	for (int i = 1; i <= n; i ++ ) printf("%lld ", dfs(dfs, 1, i));
	return 0;
}
```

---


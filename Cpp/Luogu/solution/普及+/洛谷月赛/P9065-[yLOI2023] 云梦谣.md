# [yLOI2023] 云梦谣

## 题目背景

> 归来且做云梦梦一场 大梦好  
> 栽花闻酒香 醒醒醉醉笑笑  
> 天地偌大复路远山高 最难得偷半日逍遥  
> 偶尔糊涂不问世事不知晓

——银临 & 慕寒《云梦谣》

## 题目描述

“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”

朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。

云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。

朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：

- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；
- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；
- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。

进行上述每项行动均需花费 $1$ 个单位时间。

“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。

## 说明/提示

### 样例 1 解释

第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  
第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  
第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。

### 样例 2 解释

第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  
第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  
第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  
第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。

### 数据规模与约定


![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)

对全部的测试点，保证 $1 \leq n, m \leq 3 \times 10^3$，$0 \leq k,h_{i,j} \leq n \times m$。
### 提示

请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。

### 说明

本题共有 5 个附加样例文件，见附件里的 dream.zip。

### 后记

不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。

## 样例 #1

### 输入

```
4 4 2
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 1
3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4 3
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 1
2 4
4 1```

### 输出

```
4```

## 样例 #3

### 输入

```
2 5 0
1 0 3 3 4
2 3 4 0 5```

### 输出

```
7```

## 样例 #4

### 输入

```
4 4 3
1 1 1 0
1 1 0 1
1 0 1 1
0 1 1 1
1 1
2 1
3 3```

### 输出

```
3```

# 题解

## 作者：一扶苏一 (赞：35)

# [yLOI2023] C 云梦谣

## Description

给定一个 $n \times m$ 的方格阵，每个格子有一个高度 $h_{i,j}$，或者是不能通行的障碍物。且有 $k$ 个格子可以传送。每秒可以做如下三件事之一：

- 移动到相邻四联通的格子。
- 如果当前格子允许传送，则可以传送到任意别的允许传送的格子上，条件是目标格子和当前格子等高。
- 改变当前格子的高度为任意正整数。

求从 $(1,1)$ 走到 $(n,m)$ 的最短用时。

$1 \leq n, m \leq 3 \times 10^3$。$1 \leq k \leq n \times m$。

## Analysis

### 算法一

当 $n = m = 2$ 时有一万种方法求解，不表。可得 $20$ 分。

特别的，测试点 $1$ 输出 $-1$ 可得 $5$ 分。

### 算法二

当 $k = 0$ 时，操作二和三都没有意义。这就是一个简单的 bfs 走迷宫问题。

时间复杂度 $O(nm)$，期望得分 $20$ 分。结合算法一可得  $40$ 分。

### 算法三

当 $k$ 比较小且 $h \leq 1$ 时，不需要操作 $3$。

于是可以进行这样的 bfs：

- 在非传送格子上正常进行四联通 bfs。
- 在传送格子上时，除了进行四联通 bfs，还枚举所有的其它的传送阵，尝试传送到其它格子上去。

一共有 $O(nm)$ 个状态，在转移时需要 $O(k)$ 的时间枚举其它的传送阵。总时间复杂度为 $O(nmk)$。期望得分 $15$ 分。结合算法一、二可得 $55$ 分。

### 算法四

注意到操作 3 只会在传送之前一秒进行，可以把这两个操作绑定。

注意到操作 2 和 3 一起做需要两秒。为了不破坏 bfs 时『每步时间增加 1』的性质，可以设 $dis_{x,y,0/1}$ 表示走到 $(x,y)$ 格子，且该格子的高度没有改变/刚刚把该格子的高度改变成其他任意正整数的最短用时。

此时的转移是：

1. 正常的四联通转移。
2. $dis_{x,y,0}$ 转移到 $dis_{x,y,1}$，表示这一秒改了格子的高度。
3. （如果是传送阵）从 $dis_{x,y,0}$ 转移到其他高度相同的传送阵。
4. （如果是传送阵）从 $dis_{x,y,1}$ 转移到其他高度不同的传送阵。

仍然有 $O(nm)$ 个状态，在转移时需要 $O(k)$ 的时间枚举其它的传送阵。总时间复杂度为 $O(nmk)$。期望得分 $70$ 分。

### 算法五（关键算法）

本题的 key conclusion 是：传送至多会使用一次，且一定是离起点最近的传送阵传送到离终点最近的传送阵（无论他们的高度是否一样，当然有高度相同的优先用高度相同的）。

证明：

先证至多传送一次。假设最终方案是 $s ...A - B...C-D...t$，这里 $A,B,C,D$ 是四个传送阵，$s,t$ 是起点终点，$-$ 表示一次传送。考虑 $A-B$ 和 $C-D$ 的过程使用了至少 $2\mathrm s$，而 $A$ 能直接传送到 $D$，花费时间至多是 $2\mathrm s$（先改变 $A$ 的高度，再穿过去）。所以直接从 $A$ 走到 $D$ 的花费不会高于假设里的花费。

再证明一定是离起点最近的传送阵传送到离终点最近的传送阵。如果两个阵的高度相同，此时显然是最优的（假设最优解使用了传送）；如果两个阵高度不同，则传送总过程花费 $2\mathrm s$。如果为了找两个相同高度的阵传送，则至少要再走一步，花费 $1s$，传送再用 $1s$，此时不会比直接走最近的阵优。

由此命题得证。

于是从 $(1,1)$ 开始 bfs 出起点距所有点的距离，找出离起点最近的所有传送阵；然后从终点再做一次 bfs，同样找出离终点最近的传送阵。

检查离起点最近的阵中和里终点最近的阵中有没有等高的。如果有，则答案就是直接走过去和从起点走到传送阵传送并走到终点的时间取最小值；如果没有，把后者的时间加一取最小值。

$h \leq 1$ 时，无需检查是否等高，时间复杂度 $O(nm)$，期望得分 $65$ 分；  
$h > 1$ 但 $k$ 比较小时，检查两类传送阵是否有等高的可以 $O(k^2)$ 枚举，时间复杂度 $O(nmk^2)$。

这两种情况期望得分共 $85$ 分。

### 算法六

称离起点或终点距离最近的传送阵为『有效传送阵』。

在造数据的时候发现无法造出 $O(nm)$ 个有效传送阵的数据。有一个符合直觉的猜测时有效传送阵的个数只有 $O(\min(n,m))$ 个，但是我无法给出合理的证明。

事实上数据里有效传送阵确实只有 $O(\min(n,m))$ 个。于是暴力枚举传送阵对检查高度的时间复杂度其实是 $O(n^2)$ 的（认为 $n,m$ 同阶）。设有效传送阵有 $t$ 个，则算法时间复杂度为 $O(nm + t^2)$，可以得到 $100$ 分。

### 算法七

事实上存在 $O(k)$ 的检查高度方法：

先扫一遍离起点最近的传送阵，用一个桶记录这些传送阵的高度（$c_x = 1$ 表示离起点最近的传送阵中有一个高度为 $x$ 的）。

然后扫一遍离终点最近的传送阵。对每个传送阵看它的高度在桶里是否出现。如果出现则表示找到了一对同高度的传送阵。

这样就可以做到 $O(nm + k)$ 了。期望得分 $100$ 分。

## Code

std 实现的是算法 7。  
事实上从起点和终点分别进行的两次 bfs 在流程上没有任何区别，只是起终点不同。于是可以写成一个函数，通过传入起点和距离数组参数的形式来完成两次 bfs 调用。  
据说有人写 deque 被卡空间了，但是 std 只有 130M 空间（

```cpp
#include <cstring>
#include <queue>
#include <vector>
#include <iostream>
#include <algorithm>

const int maxn = 3003;
const int INF = 0x3f3f3f3f;

int n, m, k;
int h[maxn][maxn], d1[maxn][maxn], d2[maxn][maxn];
bool isTrans[maxn][maxn];
bool col[maxn * maxn];
std::vector<std::pair<int, int>> trans;

int bfs(int bx, int by, int ex, int ey, int d[][maxn]);

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> m >> k;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      std::cin >> h[i][j];
    }
  }
  for (int i = 1, x, y; i <= k; ++i) {
    std::cin >> x >> y;
    isTrans[x][y] = true;
    trans.push_back(std::make_pair(x, y));
  }
  memset(d1, 0x3f, sizeof d1);
  memset(d2, 0x3f, sizeof d2);
  int dis1 = bfs(1, 1, n, m, d1);
  int dis2 = bfs(n, m, 1, 1, d2);
  int ans = std::min(d1[n][m], dis1 + dis2 + 2);
  int cnt1 = 0, cnt2 = 0;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) if (d1[i][j] == dis1 && isTrans[i][j]) {
      col[h[i][j]] = true;
      ++cnt1;
    }
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) if (d2[i][j] == dis2 && isTrans[i][j]) {
      if (col[h[i][j]]) ans = std::min(ans, dis1 + dis2 + 1);
      ++cnt2;
    }
  }
  if (ans == INF) ans = -1;
  std::cout << ans << std::endl;
}

const int dx[] = {1, -1, 0, 0};
const int dy[] = {0, 0, 1, -1};

int bfs(int bx, int by, int ex, int ey, int d[][maxn]) {
  int ret = INF;
  std::queue<std::pair<int, int>> Q;
  d[bx][by] = 0;
  for (Q.push(std::make_pair(bx, by)); !Q.empty(); Q.pop()) {
    int x = Q.front().first, y = Q.front().second;
    if (ret == INF && isTrans[x][y]) ret = d[x][y];
    for (int i = 0; i < 4; ++i) {
      int px = dx[i] + x, py = dy[i] + y;
      if (px && py && px <= n && py <= m && h[px][py] && d[px][py] == INF) {
        d[px][py] = d[x][y] + 1;
        Q.push(std::make_pair(px, py));
      }
    }
  }
  return ret;
}
```

## Generator

前四个点造出来以后手搓改了数据。

```cpp
const int maxn = 8005;
int h[maxn][maxn], dis[maxn][maxn], cnt[maxn * maxn];
const int INF = 0x3f3f3f3f;

const int dx[] = {1, -1, 0, 0};
const int dy[] = {0, 0, 1, -1};

void bfs(int bx, int by, int n, int m, int d[][maxn]) {
  std::queue<std::pair<int, int>> Q;
  d[bx][by] = 0;
  for (Q.push(std::make_pair(bx, by)); !Q.empty(); Q.pop()) {
    int x = Q.front().first, y = Q.front().second;
    for (int i = 0; i < 4; ++i) {
      int px = dx[i] + x, py = dy[i] + y;
      if (px && py && px <= n && py <= m && h[px][py] && d[px][py] == INF) {
        ++cnt[d[px][py] = d[x][y] + 1];
        Q.push(std::make_pair(px, py));
      }
    }
  }
}

void makedata(int T) {
  int n = 3000, m = 3000, k = 9000000, lim = 4000000;
  if (T <= 4) {
    n = m = 4;
    if (T <= 2) k = 0;
    else k = 2;
    if (T <= 3) lim = 1;
    else lim = 4;
  } else if (T <= 10) {
    n = m = 50;
    if (T <= 6) k = 0;
    else k = -1;
    if (T <= 8) lim = 1;
    else lim = n * m;
  } else {
    if (T <= 12) k = 0;
    else if (T <= 14) k = 10;
    else k = -1;
    if ((T <= 13) || (T >= 15 && T <= 17)) lim = 1;
  }
  if (T >= 5) {
    m -= modx(5);
    n -= modx(6);
    if (lim > 1) lim = n * m;
  }
  if (k == -1) {
    k = modx(n * m) + 1;
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
      if (lim == 1) {
        h[i][j] = (rnd() % 100) ? 1 : 0;
      }
      else if (lim >= 10) {
        if (rnd() % 4) h[i][j] = modx(10);
        else h[i][j] = modx(lim + 1);
      } else {
        h[i][j] = modx(lim + 1);
      }
    }
  }
  for (int i = n / 3 * 2; i <= n; ++i) h[i][m / 3 * 2] = 0;
  for (int i = 1; i <= m / 3 * 2; ++i) h[n / 3 * 2][i] = 0;
  if ((T & 1) == 0) {
    if (lim > 1) {
      for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) if (h[i][j]) {
          h[i][j] = (i - 1) * n + j;
        }
      }
    }
  }
  memset(dis, 0x3f, sizeof(dis));
  memset(cnt, 0, sizeof(cnt));
  bfs(1, 1, n, m, dis);
  int d = std::max_element(cnt + 1, cnt + 1 + n * m) - cnt;
  std::vector<std::pair<int, int>> p;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) if (dis[i][j] == d) p.push_back(std::make_pair(i,j));
  }
  memset(dis, 0x3f, sizeof(dis));
  memset(cnt, 0, sizeof cnt);
  bfs(n, m, n, m, dis);
  d = std::max_element(cnt + 1, cnt + 1 + n * m) - cnt;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) if (dis[i][j] == d) p.push_back(std::make_pair(i,j));
  }
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) if (dis[i][j] == 0x3f3f3f3f && h[i][j]) p.push_back(std::make_pair(i,j));
  }
  std::sort(p.begin(), p.end());
  auto ed = std::unique(p.begin(), p.end());
  k = std::min(k, int(ed - p.begin()));

  printf("%d %d %d\n", n, m, k);
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
      printf("%d%c", h[i][j], " \n"[j == m]);
  for (int i = 0; i < k; ++i) printf("%d %d\n", p[i].first, p[i].second);
}

```

---

## 作者：Transfixion_ (赞：10)

题目链接：[$\texttt {Link}$](https://www.luogu.com.cn/problem/P9065)
## $\text{Description}$
给定一个 $n$ 行 $m$ 列的方格阵（记为 $\mathbb{U}$）。

每个格子有高度 $h_{i,j}$，且有 $k(k\in[0,nm])$ 个格子（记为 $\mathbb{A}$）允许传送。

对 $\forall (x_0,y_0) \in \mathbb{U}$，可以进行三种操作：

- $\text{Opt 1:}$ 移动到 $(x_0\pm1,y_0\pm1)$。
- $\text{Opt 2:}$ 若 $(x_0,y_0)\in \mathbb{A}$，则可以传送到 $\forall (x,y)\in C _{\mathbb{A}}(x_0, y_0), \text{s.t.} h_{x,y}=h_{x_0,y_0}$。
- $\text{Opt 3:}$ 将当前格子的 $h$ 修改为任意正整数。

求从 $(1,1)$ 走到 $(n,m)$ 至少需要几步。
## $\text{Solution}$
性质：

1. $\text{Opt 2}$ 和 $\text{Opt 3}$ 可以视为：

>对于当前格子 $(x_0,y_0)\in\mathbb{A}$ 与目标格子 $(x,y)\in\mathbb{A}$：
>
> 若 $h_{x,y}=h_{x_0,y_0}$，则步数加一并传送；否则步数加二并传送。

证明平凡。

2. 至多传送一次。且**答案**必与 距起点最近的可传送点到距终点最近的可传送点 **相同**。

证明 1：若最终方案中包含 $A\to B \dots \to C$，则存在更优方案 $A\to C$ 或 $A\to\text{Opt3} \to C$，矛盾，得证。

证明 2：若两点高度相同，即证。若高度不同，则传送需要两步。而寻找一个高度相同的可传送点后再传送至少需要两步，得证。

---

于是可以先将可传送的格子打标记，随后用 bfs 找出距离起点最近的可传送点，枚举方格阵内所有可传送的点入队，然后正常操作即可。

### 实现 & 细节：

对于距离起点最近可传送点的查找，可以考虑以 $step$ 为关键字建立优先队列。一旦找到，记录（$flg\leftarrow 1$）并枚举所有可传送点入队，下次跳过即可。具体实现见代码。

OI 赛制的搜索一定要认真读题找性质。否则 $2k$ 代码可能还不如 `puts("-1")` 拿的分高。

## $\text{AC Code}$
```cpp
#include <bits/stdc++.h>
const int N = 3005;
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};
int n, m, k, flg, h[N][N];
bool vis[N][N], chk[N][N];
struct node {int x, y, step;};
bool operator < (const node& u, const node& v) {
    return u.step > v.step;
}

template<typename _Tp>inline void read(_Tp &x) {
	#define gc() getchar()
	x = 0; char c = gc(); bool f = 0;
	while(!std::isdigit(c)) f |= c == '-', c = gc();
	while(std::isdigit(c)) x = x * 10 + (c ^ 48), c = gc();
	return (void)(f ? x = -x : 1);
	#undef gc() 
}

std::priority_queue<node> Q;
void bfs() {
    Q.push({1, 1, 0});
    while(!Q.empty()) {
        int x = Q.top().x, 
            y = Q.top().y, 
            step = Q.top().step;
        Q.pop();
        if(x == n && y == m) {
            std::cout << step;
            exit(0);
        }
        if(vis[x][y]) continue;
        vis[x][y] = 1;
        for(int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if(vis[nx][ny] || !h[nx][ny]) continue;
            if(nx < 1 || ny < 1 || nx > n || ny > m) continue;
            Q.push({nx, ny, step + 1});
        }
        if(!chk[x][y] || flg) continue;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                if(!chk[i][j] || (i == x && j == y)) continue;
                Q.push({i, j, step + 1 + (h[i][j] != h[x][y])});
            }
        } flg = 1;
    }
}
signed main() {
    read(n), read(m), read(k);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            read(h[i][j]);
    for(int i = 1, x, y; i <= k; i++) {
        read(x), read(y);
        chk[x][y] = 1;
    }
    bfs();
    puts("-1");
    return 0;
}
```

---

## 作者：2c_s (赞：6)

可确定的是，这道题要用 bfs 来做。题目中的“御剑飞行”就相当于传送点，可以传送到**任意一个相同高度的传送点**上。

## 思路

为了使得御剑飞行是花费单位时间最少的路径，考虑进行两遍 bfs ，分别从起点 $(1,1)$ 和终点 $(n,m)$ 开始，搜索到**最近的**御剑飞行点（见补充证明）后，再分别用 vector 数组存储这个点的高度，方便在 bfs 进行完之后迭代循环遍历时找到不同高度下花费单位时间最少的路径。

搜索到第一个御剑飞行点的时候存储到 $step$ 变量中，之后再搜索到下一个御剑飞行点的时候比较大小，如果到达这个点要花费的单位时间和 $step$ 变量**相同**，就把这个御剑飞行点的高度存入 vector 数组。

进行完两个 bfs 后，用一个变量 $ans$ 找能花费的最少单位时间的路径前，先将 $ans$ **赋初始值**为 $10^9$，方便比较大小。如果提取出来的两个御剑飞行点高度相同，则只花费御剑飞行时的 $1$ 个单位时间加上到达这两个御剑飞行点的时间总和；如果提取出来的两个御剑飞行点高度不相同，则还要多花费改变高度时的 $1$ 个单位时间。把这两种情况都和当前的 $ans$ 值比大小，选较小的一个存入 $ans$。

最后比较进行御剑飞行和只走路，不进行御剑飞行的两个方案，哪个花费的单位时间少，就选哪个存储。如果 $ans$ 此时**还为** $10^9$，说明无法从 $(1,1)$ 走到 $(n,m)$，输出 $-1$。

## 补充证明

**最多需要只飞行一次，也只需要改变高度一次**。

假设现在有三个同样高度的御剑飞行点 $A,B,C$， 考虑从 $A$ 传送到 $C$ 的路径有两条：第一条是 $A\to B\to C$，第二条是 $A\to C$。第一条路线要花费 $2$ 个单位时间，第二条只需要花费 $1$ 个单位时间，路线二是最优解，此情况不需要考虑改变高度所画的单位时间数量。

如果是 $A$ 点高度和 $B$ 点高度相同，但和 $C$ 点高度不同的情况，仍然有两条路线：第一条是 $A\to B\to C$，第二条是 $A\to C$。把改变一次高度所花费的单位时间考虑进去，第一条路线要花费 $3$ 个单位时间，第二条只需要花费 $2$ 个单位时间，因此路线二仍然是最优解。

如果是三个点高度互不相同的情况，仍然有两条路线：第一条是 $A\to B\to C$，第二条是 $A\to C$。第一条路线要花费 $4$ 个单位时间，第二条只需要花费 $2$ 个单位时间。综合三种情况，路线二是最优解，即只需要进行一次御剑飞行所花费的单位时间最小，改变一次高度。

## 注意事项：

- 题目数据较大，可以用 scanf 读入。
- 搜索第二遍前记得**清空**用来标记已经搜索位置的 $vis$ 数组和 bfs 队列。
- 给存储结果的变量赋初始值。

---

## 部分代码讲解
结构体存储部分：
~~~cpp
struct node{
	int x,y,step;//step 指的是从搜索开始的位置到当前位置的单位时间数。
};queue<node>q;
struct mp{
	int h;//每个点的高度。
	bool flag;//这个位置是否可以进行御剑飞行。
};mp a[N][N];
~~~
---
从起点向终点搜索的 bfs 部分：
~~~cpp
   q.push({1,1,0});//(1,1) 的位置入队，开始搜索。
	vis[1][1]=1;//标记当前位置。
	while(q.size()){
		node now=q.front();
		q.pop();
		if(now.x==n&&now.y==m){//搜索到 (n,m)，记录步数后返回主程序。
			res=now.step;
			return ;
		}
		if(a[now.x][now.y].flag){//如果当前位置可以进行御剑飞行。
			if(step1==-1){//如果这是第一个搜索到的御剑飞行点。
				step1=now.step;
				v1.push_back(a[now.x][now.y].h);
			}
			else if(step1==now.step){
//如果这不是第一个搜索到的御剑飞行点，看看到达这个御剑飞行点所花费的单位时间是不是和第一个点相同。
				v1.push_back(a[now.x][now.y].h);
			}
		}
		for(int i=0;i<4;++i){
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(!check(xx,yy))continue;
			q.push({xx,yy,now.step+1});
			vis[xx][yy]=1;//记得标记已经走过的位置。
		}
	}
~~~
---
从终点向起点搜索的 bfs 部分（相同注释不再写）：
~~~cpp
	q.push({n,m,0});//注意从 (n,m) 开始搜索。
	vis[n][m]=1;
	while(q.size()){
		node now=q.front();
		q.pop();
		if(now.x==1&&now.y==1)return ;//注意是搜索到 (1,1) 后返回主程序；前面已经记录过步数，所以不用再记录了。
		if(a[now.x][now.y].flag){
			if(step2==-1){//注意要开新变量存储。
				step2=now.step;
				v2.push_back(a[now.x][now.y].h);
			}
			else if(step2==now.step)v2.push_back(a[now.x][now.y].h);
		}
		for(int i=0;i<4;++i){
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(!check(xx,yy))continue;
			q.push({xx,yy,now.step+1});
			vis[xx][yy]=1;
		}
	}
~~~
---

## 无注释代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+10;
int n,m,k,x,y,step1=-1,step2=-1,ans=1e9,res=-1;
struct node{
	int x,y,step;
};queue<node>q;
struct mp{
	int h;
	bool flag;
};mp a[N][N];
bool vis[N][N];
const int dx[]={1,-1,0,0};
const int dy[]={0,0,1,-1};
vector<int>v1,v2;
bool check(int x,int y){
	if(x<1||x>n||y<1||y>m||vis[x][y]||!a[x][y].h)return 0;
	else return 1;
}
void bfs1(){
	q.push({1,1,0});
	vis[1][1]=1;
	while(q.size()){
		node now=q.front();
		q.pop();
		if(now.x==n&&now.y==m){
			res=now.step;
			return ;
		}
		if(a[now.x][now.y].flag){
			if(step1==-1){
				step1=now.step;
				v1.push_back(a[now.x][now.y].h);
			}
			else if(step1==now.step){
				
				v1.push_back(a[now.x][now.y].h);
			}
		}
		for(int i=0;i<4;++i){
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(!check(xx,yy))continue;
			q.push({xx,yy,now.step+1});
			vis[xx][yy]=1;
		}
	}
}
void bfs2(){
	q.push({n,m,0});
	vis[n][m]=1;
	while(q.size()){
		node now=q.front();
		q.pop();
		if(now.x==1&&now.y==1)return ;
		if(a[now.x][now.y].flag){
			if(step2==-1){
				step2=now.step;
				v2.push_back(a[now.x][now.y].h);
			}
			else if(step2==now.step)v2.push_back(a[now.x][now.y].h);
		}
		for(int i=0;i<4;++i){
			int xx=dx[i]+now.x;
			int yy=dy[i]+now.y;
			if(!check(xx,yy))continue;
			q.push({xx,yy,now.step+1});
			vis[xx][yy]=1;
		}
	}
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j)scanf("%d",&a[i][j].h);
	}
	for(int i=1;i<=k;++i){
		scanf("%d%d",&x,&y);
		a[x][y].flag=1;
	}
	bfs1();
	while(q.size())q.pop();
	memset(vis,0,sizeof(vis));
	bfs2();
	for(int i:v1){
		for(int j:v2){
			if(i==j)ans=min(ans,step1+step2+1);
			else ans=min(ans,step1+step2+2);
		}
	}
	if(res!=-1)ans=min(ans,res);
	if(ans==1e9)cout<<-1;
	else cout<<ans;
	return 0;
}
~~~
---
[已 AC](https://www.luogu.com.cn/record/102736865)

---

## 作者：ImNot6Dora (赞：5)

~~一道黄题打了整整一个周，我真是一个大蒟蒻。~~

第一次被一道搜索卡住这么长时间。

做到第五天，发现其实是一个搜索 + 贪心结论题。

做法空间比较大，但是符合在题目要求之内，所以就过了……
# 正文
首先思考，如果没有御剑~~怜侍~~飞行，则只需要 bfs 即可，求出的答案一定是正确答案，注意**无解**情况 ~~（卡了我老半天）~~。

当有御剑飞行的时候，这个题就需要分开讨论了。

1. 首先先假设没有可御剑飞行的格子，此时按照 bfs 进行搜索，当然，如果起点和终点之间的路被障碍物截断，也就是不在一个连通块内，那么还是需要根据御剑飞行解决。
2. 接下来就是关键的**贪心**部分了，思考后可以得知，御剑飞行的时候要从离着起点最近的御剑飞行点飞到离着终点最近的御剑飞行点，这样才能最节约中间的路程，为什么这么说呢？比如，一个距离刚刚找到的离着端点最近的御剑飞行点一格的点也是御剑飞行点，那么走到那里的路程就和改变高度的时间抵消了，更何况御剑飞行起点和御剑飞行终点的高度一样呢？所以只需要找到距离两端点最近的御剑飞行点，也就是说，**总共只会进行一次御剑飞行**，当然，如果御剑飞行点是障碍物的话就不能到达那里，更不用说御剑飞行了。
3. 注意，由于可能有多个距离两端点最近的御剑飞行点，所以需要用一个数组将所有的可能点保存下来。保存之后，可以发现，由于距离两个端点的路程相同，所以需要找到是否有高度相同的两个点，如果有，那就不需要改变高度，直接用两者距离对应端点的路程之和 $+1$，如果没有找到，说明需要改变高度，而在距离对应端点路程相同的情况下，只需要在任意两点距离对应端点的路程之和 $+2$，其中一个是飞行的时间，一个是改变高度的时间。
4. 最后，进行判断，看看用御剑飞行和不用御剑飞行的答案谁小，注意当不用御剑飞行的情况无解的时候需要特判，当没有保存御剑飞行点的时候，说明无法御剑飞行，也需要特判。

# AC C++ CODE：
###### 带三条注释
```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[3001][3001];
bool fly[3001][3001];
int mapp[3001][3001];
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
int q[9000001][3];
int n,m,k,ans;
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void bfs(){
	int front=1,rear=1;
	q[rear][0]=1;
	q[rear][1]=1;
	q[rear][2]=0;
	rear++;
	vis[1][1]=1;
	while(front<rear){
		if(q[front][0]==n&&q[front][1]==m){
			ans=q[front][2];
			return;
		}
		for(int i=0;i<4;i++){
			int nx=dx[i]+q[front][0];
			int ny=dy[i]+q[front][1];
			if(nx>0&&nx<=n&&ny>0&&ny<=m&&!vis[nx][ny]&&mapp[nx][ny]){
				q[rear][0]=nx;
				q[rear][1]=ny;
				q[rear][2]=q[front][2]+1;
				vis[nx][ny]=1;
				rear++;
			}
		}
		front++;
	}
	ans=-1;
}
int p1,pp1,p[4500001],pp[4500001],cnt,cnt1;
inline void front_bfs(){
	bool f=1; 
	int front=1,rear=1;
	q[rear][0]=1;
	q[rear][1]=1;
	q[rear][2]=0;
	rear++;
	vis[1][1]=1;
	while(front<rear){
		if(fly[q[front][0]][q[front][1]]){
			p[++cnt]=mapp[q[front][0]][q[front][1]];
			p1=q[front][2];
			f=0;
		}
		for(int i=0;i<4;i++){
			int nx=dx[i]+q[front][0];
			int ny=dy[i]+q[front][1];
			if(nx>0&&nx<=n&&ny>0&&ny<=m&&!vis[nx][ny]&&mapp[nx][ny]){
				q[rear][0]=nx;
				q[rear][1]=ny;
				q[rear][2]=q[front][2]+1;
				vis[nx][ny]=1;
				rear++;
			}
		}
		front++;
		if(!f&&q[front][2]!=q[front-1][2])return;//如果已经找到了御剑飞行点，并且距离起点的路程增加了，说明前面的几个御剑飞行点是最近的，那就直接用前面找到的御剑飞行点，下同
	}
} 
inline void rear_bfs(){
	bool f=1;
	int front=1,rear=1;
	q[rear][0]=n;
	q[rear][1]=m;
	q[rear][2]=0;
	rear++;
	vis[n][m]=1;
	while(front<rear){
		if(fly[q[front][0]][q[front][1]]){
			pp[++cnt1]=mapp[q[front][0]][q[front][1]];
			pp1=q[front][2];
			f=0;
		}
		for(int i=0;i<4;i++){
			int nx=dx[i]+q[front][0];
			int ny=dy[i]+q[front][1];
			if(nx>0&&nx<=n&&ny>0&&ny<=m&&!vis[nx][ny]&&mapp[nx][ny]){
				q[rear][0]=nx;
				q[rear][1]=ny;
				q[rear][2]=q[front][2]+1;
				vis[nx][ny]=1;
				rear++;
			}
		}
		front++;
		if(!f&&q[front][2]!=q[front-1][2])return;
	}
}
int main(){
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			mapp[i][j]=read();
		}
	}
	bfs();
	if(k==0)cout<<ans;
	else{
		for(int i=1;i<=k;i++)fly[read()][read()]=1;	
		memset(vis,0,sizeof(vis));
		memset(q,0,sizeof(q));
		front_bfs();//找距离起点最近的御剑飞行点们
		memset(vis,0,sizeof(vis));
		memset(q,0,sizeof(q));
		rear_bfs();//找距离终点最近的御剑飞行点们
		if(!cnt&&!cnt1){
			cout<<ans;
			return 0;
		}
		if(ans==-1)ans=INT_MAX;
		for(int i=1;i<=cnt;i++){
			for(int j=1;j<=cnt1;j++){
				if(p[i]==pp[j]){
					cout<<min(ans,p1+pp1+1);
					return 0;
				}
			}
		}
		cout<<min(ans,p1+pp1+2);
	}
	return 0;
}
```
完结撒花！

By ImNot6Dora

---

## 作者：_shy (赞：3)

## [P9065 [yLOI2023] 云梦谣](https://www.luogu.com.cn/problem/P9065)
### 思路
1. 没有御剑飞行的格子时，直接 bfs 即可。考虑有御剑飞行的格子时的做法。把每个可御剑飞行格子以及其可通过不御剑飞行到达的点形成的联通块看作一个整体。当起点与终点不在同一个联通块中时，必须通过御剑飞行的格子才可以到达终点；否则，通不通过御剑飞行的格子均可。
2. 考虑如何得到借助御剑飞行到达终点的最短用时。根据**贪心**，我们只需要找到距离起点和终点最近的可御剑飞行格子**们**。因为（以找到的距离起点最近的指定格子为例），若它们中有与终点最近的可御剑飞行格子高度相同的，此时一定最优；即使不然，我们假设多走一步便可以到与终点最近的可御剑飞行格子高度相同的可御剑飞行格子，那么这一步消耗的时间也与改变高度消耗的时间相抵了。而对于两边的最近的可御剑飞行的格子中是否有高度相同的，我们只需要在找距起点最近的指定格子时，用一个桶记录出现过的高度即可。
3. 考虑最后的答案是什么。当不通过御剑飞行起点与终点不可互通时，若在起点或终点侧无法找到指定格子，则起点与终点无论如何都无法互通；否则，可通过御剑飞行的方式到达。当不通过御剑飞行起点与终点可互通时，则可以证明若无法找到距离起点最近的可御剑飞行格子，则一定也无法找到距离终点最近的可御剑飞行格子，故此时答案便是不通过御剑飞行到达的时间；否则，答案是御剑飞行的最短用时与不借助御剑飞行的最短用时的最小值。
4. 时间复杂度为 $\mathcal O(nm+k)$。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3e3 + 5;
const int dx[5] = {0, 1, -1, 0, 0};
const int dy[5] = {0, 0, 0, 1, -1};
int n, m, h[maxn][maxn], k, ansi = -1, ansii = -1;
bool visk[maxn][maxn], vish[maxn * maxn], flag;
void read (int &x) 
{
	x = 0; int w = 1;
	char ch = getchar ();
	while (ch < '0' || ch > '9') 
	{
		if (ch == '-') w = -1;
		ch = getchar ();
	}
	while (ch >= '0' && ch <= '9') 
	{
		x = (x << 1) + (x << 3) + ch - 48;
		ch = getchar ();
	}
	x *= w; 
}
queue <pair <pair <int, int>, int> > q, emptyi;
bool vis[maxn][maxn];
int ans = -1;
void bfs (int sx, int sy, int tp) 
{
	if (visk[sx][sy] && tp != 2) 
	{
		if (tp == 0) 
		{
			vish[h[sx][sy]] = 1;
			ansi = 0;
		}
		else if (tp == 1)
		{
			if (vish[h[sx][sy]]) ansii = 0;
			flag = 1;
		}
		return;
	}
	q = emptyi;
	memset (vis, 0, sizeof (vis));
	vis[sx][sy] = 1;
	q.push (make_pair (make_pair (sx, sy), 0));
	while (!q.empty ()) 
	{
		int x = q.front ().first.first,
			y = q.front ().first.second,
			s = q.front ().second ; q.pop ();
		for (int i = 1; i <= 4; i++) 
		{
			int tx = x + dx[i],
				ty = y + dy[i];
			
			if (tx < 1 || ty < 1 || tx > n || ty > m || h[tx][ty] == 0) continue;
			if (vis[tx][ty]) continue;
			q.push (make_pair (make_pair (tx, ty), s + 1));
			vis[tx][ty] = 1;
			if (tp == 0) 
			{
				if (ansi != -1 && s + 1 > ansi) return;
				if (ansi != -1 && visk[tx][ty]) vish[h[tx][ty]] = 1;
				else if (ansi == -1 && visk[tx][ty])
					ansi = s + 1,
					vish[h[tx][ty]] = 1;
			}
			else if (tp == 1)
			{
				if (ansii != -1 && s + 1 > ansii) return; 
				if (ansii != -1 && visk[tx][ty] && vish[h[tx][ty]]) flag = 1;
				else if (ansii == -1 && visk[tx][ty]) ansii = s + 1, flag = vish[h[tx][ty]] ? 1 : 0;
			}
			else 
			{
				if (tx == n && ty == m) 
				{
					ans = s + 1;
					return;
				}
			}
		}
	}
}
int main ()
{
	read (n), read (m), read (k);
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= m; j++)
			read (h[i][j]);
	for (int i = 1; i <= k; i++)
	{
		int x, y;
		read (x), read (y);
		visk[x][y] = 1;
	}
	if (n == 1 && m == 1) printf ("0"), exit (0);
	bfs (1, 1, 0), bfs (n, m, 1);
	bfs (1, 1, 2);
	if (ans == -1) 
	{
		if (ansi == -1 || ansii == -1) printf ("-1"), exit (0);
		if (flag) ansii += (ansi + 1);
		else ansii += (ansi + 2);
		printf ("%d", ansii);
	}
	else 
	{
		if (ansii == -1) printf ("%d", ans), exit (0);
		if (flag) ansii += (ansi + 1);
		else ansii += (ansi + 2);
		printf ("%d", min (ans, ansii));
	}
	return 0;
}


```


---

## 作者：Lizhengxi (赞：2)

## P9065 [yLOI2023] 云梦谣

### 前言

题目背景、题目描述以及后记里的小故事让我联想到了《笑傲江湖》里的令狐冲与岳灵珊：“栽花闻酒香 醒醒醉醉笑笑”、“天地偌大复路远山高 最难得偷半日逍遥”像是令狐冲的笑傲，灵动的朵一似是活泼好动的岳灵珊。虽然最后代码中的“御剑飞行”的高度特判有一点不优雅，但这不正是小师妹的顽皮之处吗？

### 分析

抛开“御剑飞行”功能，朵一每走一步花费 $1$ 个单位时间，从 $(1, 1)$ 出发到 $(n, m)$ 的最短时间可以用 BFS 来计算。其核心在于：每个合法的点在第一次被访问时的用时就是从源到它的最短用时。

考虑“御剑飞行”功能，朵一可以从某一个允许进行“御剑飞行”的点 $(i, j)$ 到达所有允许进行“御剑飞行”的点 $(x, y)$，花费 $ 1 + (h_{i, j} \ != \ h_{x, y})$ 个单位时间。

“御剑飞行”这一功能被添加到 BFS 中时是十分优的：除过与点 $(i, j)$ 相邻的可进行“御剑飞行”的点外，使用“御剑飞行”访问任意允许进行“御剑飞行”的点一定不比使用普通移动更劣，而且大概率更优（翻山越岭、长途跋涉）。所以我们对于一个允许进行“御剑飞行”的点，先进行四个方向的普通移动（普通 BFS 并打好标记），再进行“御剑飞行”到所有允许进行“御剑飞行”的点，记录时间。时间复杂度为 $ O(n m {k}^{2})$。

这里要注意，某一个可以进行御剑飞行的点第一次被访问时所用时间不一定是最优。具体而言，该点可能会先被最短用时为 $f$ 的可进行“御剑飞行”的点以 $2$ 的时间代价访问，再被最短用时同样为 $f$ 的可进行“御剑飞行”的点以 $1$ 的时间代价访问。而访问这一点的最短用时应该是 $f + 1$ 而非 $f + 2$。因此，在用“御剑飞行”访问该点时，不能对该点打标记，因为它要被重复更新，只有使用该点更新其他点时，才打上标记。

### 优化

目前这个算法会超时，我们考虑优化它：

- 第一，通过观察，发现二次“御剑飞行”不会更优，不应该被使用：其最优情况花费 $2$ 个时间单位；而单次“御剑飞行”最坏情况花费 $2$ 个时间单位。
- 第二，最短时间更久的、允许进行“御剑飞行”的点也不需要考虑：记 $\Delta f$ 为其与最短时间更短的、允许进行“御剑飞行”的点的时间差，有 $1 + \Delta f \geq 2$。

因此，在考虑“御剑飞行”时，我们只关心最早被访问到的一批允许进行“御剑飞行”的点，最多有 $\text{min} (n, m)$ 个这样的点（最大正方形的对角线）。此时，时间复杂度为 $ O(n m + \text{min} (n, m) k)$。

继续优化，发现一个允许进行“御剑飞行”的点必须要被多次访问是因为高度 $h$ 与它相同的点不一定第一个访问它。整个过程中，有大量的、时间花费为 $2$ 的访问是多余的。事实上，这类时间花费为 $2$ 的访问只需要进行一次就够了。因此，后续，对于最早被访问到的一批允许进行“御剑飞行”的点，只需要进行与他们高度相同的、允许进行“御剑飞行”的点的访问。这里的实现用 vector，并对高度打标记。高度相同的点用 $1$ 个时间单位不重复地访问时的总数量最多为 $k$。时间复杂度为 $ O(n m + k)$。

### AC 代码

（学业不精，还请见谅

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

const int MAXN = 3005;

int n, m, k;
int h[MAXN][MAXN], f[MAXN][MAXN];
bool fly[MAXN][MAXN], vis[MAXN][MAXN], vish[MAXN * MAXN];
int dx[8] = {0, 0, 1, 0, -1};
int dy[8] = {0, 1, 0, -1, 0};
struct T {
	int x, y, t;
	bool operator < (const T u) const {
		return t > u.t;
	}
};
vector <T> cnt[MAXN * MAXN]; // 以高度记录所有允许御剑飞行的点

priority_queue <T> pq;
int tim = -1; // 记录访问到允许御剑飞行的点的时间

#define uh h[u.x][u.y]
#define vh h[vx][vy]
#define fv f[vx][vy]

int bfs () {
	pq.push( (T) {1, 1, 0} );
	while (!pq.empty()) {
		T u = pq.top(); pq.pop();
		if (f[u.x][u.y] < u.t) continue;
		if (u.x == n && u.y == m) return u.t;
		vis[u.x][u.y] = 1;
		for (int i = 1; i <= 4; ++i) {
            int vx = u.x + dx[i], vy = u.y + dy[i];
			if (vx < 1 || vx > n || vy < 1 || vy > m) continue;
			if (vh == 0 || vis[vx][vy]) continue;
			fv = u.t + 1, vis[vx][vy] = 1;
            pq.push ( (T) {vx, vy, fv} );
		}
        // 御剑飞行的特判。
        //第一次做的时候把所有合法的点做一遍。
        //后续只做高度与自己相同的点
		if (fly[u.x][u.y] && (tim == -1 || tim == u.t)) {
            for (int i = ((tim >= 0) ? uh : 1); i <= ((tim >= 0) ? uh : 1e6); ++i) {
                for (int j = 0; j < cnt[i].size() && (!vish[i]); ++j) {
                    int vx = cnt[i][j].x, vy = cnt[i][j].y;
                    if (vis[vx][vy]) continue;
                    int update = u.t + 1 + (vh != uh);
                    fv = min(fv, update), pq.push( (T) {vx, vy, fv} );
                }
                if (tim) vish[i] = 1;
            }
            tim = u.t;
		}
	}
	return -1;
}

#undef uh
#undef vh
#undef fv

int main () {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			scanf("%d", &h[i][j]);
			f[i][j] = 2e9 + 5;
		}
	}
	for (int i = 1; i <= k; ++i) {
        int x, y; scanf("%d%d", &x, &y);
        fly[x][y] = 1;
		cnt[h[x][y]].push_back( (T) {x, y, 0} );
	}
	int ans = bfs();
	printf("%d\n", ans);
	return 0;
}
```

如有任何错误或者可以改进的地方，欢迎大家指出 ^_^

---

## 作者：zrt090604 (赞：2)

### Step1. 推导算法
我们先来模拟一下样例（其中黄色代表可以飞行）：  
[![20230214193317.png](https://i.postimg.cc/QxvTqn8y/20230214193317.png)](https://postimg.cc/0bdjknJY)  
答案是 $4$，其实有两种情况：  
①  
1.将 $(1,1)$ 的格子改成 $4$  
2.从 $(1,1)$ 飞行至 $(2,4)$  
3.从 $(2,4)$ 走到 $(3,4)$   
4.从 $(3,4)$ 走到 $(4,4)$  
②  
1.从 $(1,1)$ 飞行至 $(4,1)$  
2.从 $(4,1)$ 走到 $(4,2)$  
3.从 $(4,2)$ 走到 $(4,3)$   
4.从 $(4,3)$ 走到 $(4,4)$   
根据**飞行时无论多远距离都耗时 $1$ 个单位时间**，所以我们可以贪心地选择，在起点和终点处分别找到一个最近的可以飞行的点。  
简单证明一下：假设路线为 $A \rightarrow B \rightarrow C$，$A \rightarrow B$ 至少耗时 $1$ 单位时间，$B \rightarrow C$ 至少耗时 $1$ 单位时间，但是 $A \rightarrow C$ 至多耗时 $2$ 单位时间，即 $dis_{A, B} + dis_{B, C} \ge dis_{A,C}$。证毕。

### Step2. 注意事项
这一题虽然思路简（fù）单（zá），但是还有很多注意事项（我做题两小时踩过的坑）  
#### ① 不是所有的图都一定可以飞行
我们用黄色表示可以御剑飞行的点。  
有些图，比如下图，飞行是走不通的  
[![20230214194933.png](https://i.postimg.cc/zBcxFZxc/20230214194933.png)](https://postimg.cc/5Y85fGdB)  
所以我们两种策略都要走，第一种是直接搜索，第二种是双向搜索飞行点（对于没有飞行点的图直接搜索即可，其他的图两种方法取最小值），如果直接搜索都走不通，就输出 $-1$。
#### ② 对于高度的处理
有些图有多个飞行点距离起点相同，如下图：  
[![20230214195522.png](https://i.postimg.cc/qMbZkKcT/20230214195522.png)](https://postimg.cc/xcmP5cFx)  
其中 $(1,2)$ 和 $(2,1)$ 到起点的距离都是 $1$，但是前者与 $(3,3)$ 高度相同，所以正确答案应该是 $3$:$(1,1) - (1,2) - (3,4) - (4,4)$。  
类似地，还有多个终点满足情况的，所以我们可以记录每个最小值（起点、终点）的高度，最后两两比较，只要遇到一个起点、一个终点高度相同，就结束寻找，如果一组都没有找到，就将答案加一（改变高度）。
#### ③ 复杂度分析
直接搜索、从起点终点搜索复杂度均为 $O(nm)$,输入复杂度为 $O(nm+k)$,加上每次搜索前标记数组的清空，总体复杂度为 $O(6nm+k)$,即 $O(nm+k)$,可以通过本题。

### Step3. 编写代码
这里不做赘述。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3005, inf = 0x3f3f3f3f;
int n, m, k, cnt, cnt2, a[N][N], dir[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}, fr, rr, s[3005], e[3005], ans1 = 1e9, ans2 = 1e9, ans3 = 1e9, ans;
long long v[N*N];
bool vis[3005][3005], p[N*N+N];
struct Node {
	int x, y, step;
} q[N*N];
void solve1(int x, int y) {
	fr = 0, rr = 0;
	int mn = 1e9;
	q[rr++] = {x, y, 0};
	while(fr < rr) {
		Node u = q[fr++];
		if(p[u.x*3005+u.y]) {
			if(u.step < mn) mn = u.step, ans1 = mn;
			if(u.step > mn) return;
			s[++cnt] = a[u.x][u.y];
		}
		for(int i = 0;i < 4;++i) {
			int xx = u.x + dir[i][0], yy = u.y + dir[i][1];
			if(xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] && !vis[xx][yy]) {
				vis[xx][yy] = true;
				q[rr++] = {xx, yy, u.step+1};
			}
		}
	}
}
void solve2(int x, int y) {
	fr = 0, rr = 0;
	int mn = 1e9;
	q[rr++] = {x, y, 0};
	while(fr < rr) {
		Node u = q[fr++];
		if(p[u.x*3005+u.y]) {
			if(u.step < mn) mn = u.step, ans2 = mn;
			if(u.step > mn) return;
			e[++cnt2] = a[u.x][u.y];
		}
		for(int i = 0;i < 4;++i) {
			int xx = u.x + dir[i][0], yy = u.y + dir[i][1];
			if(xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] && !vis[xx][yy]) {
				vis[xx][yy] = true;
				q[rr++] = {xx, yy, u.step+1};
			}
		}
	}
}
void solve3(int x, int y) {
	fr = 0, rr = 0;
	q[rr++] = {x, y, 0};
	while(fr < rr) {
		Node u = q[fr++];
		if(u.x==n && u.y==m) {ans3 = u.step; return;}
		for(int i = 0;i < 4;++i) {
			int xx = u.x + dir[i][0], yy = u.y + dir[i][1];
			if(xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] && !vis[xx][yy]) {
				vis[xx][yy] = true;
				q[rr++] = {xx, yy, u.step+1};
			}
		}
	}
}
inline int read(){
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9'){
        if(c=='-')
            flag=1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    if(flag)
        x=-x;
    return x;
}
int main() {
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= m;++j)
			a[i][j] = read();
	solve3(1, 1);
	if(!k) {
		if(ans3 == 1e9) puts("-1");
		else printf("%d\n", ans3);
		return 0;
	}
	for(int i = 1, x, y;i <= k;++i)
		x = read(), y = read(), p[x*3005+y] = true;
    for(int i = 1;i <= n;++i)
    	for(int j = 1; j <= m;++j)
    		vis[i][j] = false;
	solve1(1, 1);
	for(int i = 1;i <= n;++i)
    	for(int j = 1; j <= m;++j)
    		vis[i][j] = false;
	solve2(n, m);
	bool flag = true;
	for(int i = 1;i <= cnt;++i) {
		for(int j = 1;j <= cnt2;++j)
			if(s[i] == e[j]) {flag = false; break;}
		if(flag == false) break;
	}
	if(ans3==1e9 && ans1==1e9||ans2==1e9) puts("-1");
	else printf("%d", min(ans3, ans1+ans2+1+flag));
    return 0;
}
```  
一百多行，有点长，写了两小时，思路还是很清晰的。

---

## 作者：VinstaG173 (赞：1)

赛时看错题了，导致最终做出来的东西非常奇怪。感觉看错的题目其实是原题的一个加强。

原题中仙法可以把当前格子的高度变为任意正整数，但是假设单位时间只能让高度变化 $1$ 会如何呢？

首先有一个结论仍然是成立的：全程至多用一次御空飞行。这个结论在原题中是基于两个飞行点之间最短时间均为一次飞行达到的 $[h_1\neq h_2]+1$ 或不飞行直接走相邻格的 $1$，因此对于途中经过的第一个飞行点和最后一个飞行点，或者不飞行，或者直接一次飞行跳过中间其他所有点。在改编后的题中，则最短时间变为一次飞行达到的 $|h_1-h_2|+1$ 或不飞行直接走相邻格，同理有最短路径或者不飞行，或者从第一个到达的飞行点直接飞往最后一个到达的飞行点。这是由于 $[h_1\neq h_2]$ 和 $|h_1-h_2|$ 均满足三角不等式。

这样我们知道，最终的答案或者是不用飞行直接在图上跑最短路，或者是从 $(1,1)$ 走到一个飞行点，飞到另一个飞行点再走到 $(n,m)$。那首先我们可以用两次 bfs 求出 $(1,1)$ 和 $(n,m)$ 到所有点的最短距离，设第 $i$ 个飞行点到 $(1,1)$ 的距离为 $s_i$，到 $(n,m)$ 的距离为 $t_i$，则现在要解决的问题为求 $s_i+t_j+|h_i-h_j|$ 的最小值。考虑将所有飞行点按照 $h$ 排序，然后扫描一遍，扫描到 $i$ 时，对于已经扫描过的 $j<i$，均有 $h_j\le h_i$。这样我们只要求出 $s_i+h_i+(t_j-h_j)$ 和 $t_i+h_i+(s_j-h_j)$ 的最小值。分别在扫描过程中处理出 $s_j-h_j$ 和 $t_j-h_j$ 的前缀最小值即可做到 $O(n)$，由于有排序的瓶颈因此总复杂度为 $O(n\log n)$。

这时我测了下样例，发现我读错题了。于是回到原题，发现式子变成 $s_i+t_j+[h_i\neq h_j]$，事实上仍然可以按 $h$ 排序，然后维护 $s_i$ 与 $t_i$ 的前缀最小值，这里维护的前缀最小值要同时满足 $h$ 尽量大。这样得到的结果或者是 $h_i<h_j$ 时的 $s_i+t_j+1$ 或 $t_i+s_j+1$，此时由于 $s_i$ 严格小于所有 $h_k=h_j$ 的 $s_k$，因此 $s_i+t_j+1\le s_k+t_j$，另一种情况同理；或者是 $h_i=h_j$ 时的 $s_i+t_j$ 或 $t_i+s_j$，显然也为局部最小值。这个过程同样是 $O(n)$，总复杂度同样是 $O(n\log n)$。

Code:
```cpp
int n,m,k,ans;
int h[3007][3007];
int vs[3007][3007];
int ds[3007][3007];
struct pos{
	int x,y;
	int s,t,h;
}p[9000007];
inline int cmp(pos a,pos b){
	return a.h<b.h;
}struct node{
	int x,y;
}nd[9000007],ps,nx;
int hd,tl;
int dr[4][2]={
	{0,-1},{-1,0},
	{0,1},{1,0}
};inline void bfs(){
	int r,c;while(hd<tl){
		r=nd[++hd].x,c=nd[hd].y;
		for(rg int i=0,x,y;i<4;++i){
			x=r+dr[i][0],y=c+dr[i][1];
			if(x<1||x>n||y<1||y>m)continue;
			if(!h[x][y]||vs[x][y])continue;
			ds[x][y]=ds[r][c]+1,vs[x][y]=1;
			nd[++tl].x=x,nd[tl].y=y;}}
}int main(){rd(n),rd(m),rd(k);
	for(rg int i=1;i<=n;++i)
		for(rg int j=1;j<=m;++j)
			rd(h[i][j]),vs[i][j]=0,ds[i][j]=9e6;
	hd=tl=0,nd[++tl].x=1,nd[tl].y=1;
	ds[1][1]=0,vs[1][1]=1;bfs();
	for(rg int i=1;i<=k;++i)
		rd(p[i].x),rd(p[i].y),\
		p[i].s=ds[p[i].x][p[i].y];
	for(rg int i=1;i<=n;++i)
		for(rg int j=1;j<=m;++j)
			vs[i][j]=0,ds[i][j]=9e6;
	hd=tl=0,nd[++tl].x=n,nd[tl].y=m;
	ds[n][m]=0,vs[n][m]=1;bfs();
	for(rg int i=1;i<=k;++i)
		p[i].h=h[p[i].x][p[i].y],\
		p[i].t=ds[p[i].x][p[i].y];
	ans=ds[1][1];sort(p+1,p+k+1,cmp);
	int m1=p[1].t,m2=p[1].s,p1=1,p2=1;
	for(rg int i=2,tp;i<=k;++i){
		if(p[i].s+m1+(p[p1].h!=p[i].h)+1<ans)
			ans=p[i].s+m1+(p[p1].h!=p[i].h)+1;
		if(p[i].t+m2+(p[p2].h!=p[i].h)+1<ans)
			ans=p[i].t+m2+(p[p2].h!=p[i].h)+1;
		if(p[i].t<=m1)m1=p[i].t,p1=i;
		if(p[i].s<=m2)m2=p[i].s,p2=i;
	}printf("%d\n",(ans>=9000000)?-1:ans);
	return 0;
}
```

---

## 作者：qinmingze (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P9065)

## 题意

现在有一个 $n$ 行 $m$ 列的方格阵，每个格子都有一个特定的高度 $h_{i,j}$，其中如果 $h_{i,j}$ 为 $0$，那么它就是障碍物。同时有 $k$ 个格子可以进行传送操作。每个单位时间可以分别干三件事情：

- 可以移动到相邻的四个方向：上、下、左、右这四个格子。

- 如果这个方格上允许传送，则可以传送至另一个**同样允许传送的格子**上而且与**两个方格的高度相等**。

- 可以将当前的各自改变为任一正整数。

问从 $(1,1)$ 到 $(n,m)$ 要花费的最少时间。

## 分析

### 方法一：

先只考虑 $k \le 0$ 的情况，也就是说只考虑第一个操作，方法就是正常的 bfs，按照题目的数据规模，可得 $30$ 分。

### 方法二：

这时我们考虑满分的做法，从第二个和第三个操作考虑，不难想出二号操作和三号操作都只会最多使用 $1$ 次，这说明我们只需要算出离起点最近和离终点最近的传送点就能解决此题。

### 证明过程

#### 证明：最多只会传送一次

若现在有 $6$ 个可以传送的点，如果传送两次则两次传送的时间至少要花费 $2$ 个单位的时间；如果传送三次则三次传送的时间至少要花费 $3$ 个单位的时间。而如果只传送一次，则最多只会花费 $2$ 个单位时间来传送。

#### 证明：只需要找离起点和终点最近的传送点

我们现在已知它最多只会传送一次，如果高度不相等，则至少需要再走 $1$ 步才能到达高度相同的传送点；如果高度相同不妨碍。

#### 注意事项

- 注意判断无解要输出 $-1$ 的情况。
- 会有多个离起点或终点最近的传送点。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 3010;

int n, m, k, sx, sy, ex, ey, ans = -1, step1 = -1, step2 = -1;

int h[N][N], mp[N][N];//h 数组存高度，mp 数组存可以传送的点

bool vis[N][N];

vector<int> ve1, ve2;//存离起点和终点最近的传送点

struct node{
	int x, y, step;
};

queue<node> q;

//四个方向
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

inline bool in(int x, int y){return x >= 1 && x <= n && y >= 1 && y <= m;}//判断是否在地图内

void bfs1(){
	q.push({sx, sy, 0});//起点入队
	vis[sx][sy] = 1;
	while(!q.empty()){
		node now = q.front();
		q.pop();
		if(now.x == ex && now.y == ey){//如果是终点
			ans = now.step;
			return ;
		}
		if(mp[now.x][now.y]){//可以传送
			if(step1 == -1){//第一个入队
				step1 = now.step;
				ve1.push_back(h[now.x][now.y]);
			}else if(step1 == now.step)ve1.push_back(h[now.x][now.y]);//其他情况要保证和第一个入队的步数是一致的
		}
		for(int i = 0; i < 4; i++){
			int nx = now.x + dx[i];
			int ny = now.y + dy[i];
			if(in(nx, ny) && !vis[nx][ny] && h[nx][ny]){//判断是否符合条件
				vis[nx][ny] = true;//更新
				q.push({nx, ny, now.step + 1});
			}
		}
	}
}

void bfs2(){
	q.push({ex, ey, 0});
	vis[ex][ey] = 1;
	while(!q.empty()){
		node now = q.front();
		q.pop();
		if(now.x == sx && now.y == sy)return ;
		if(mp[now.x][now.y]){//可以传送
			if(step2 == -1){//第一个入队
				step2 = now.step;
				ve2.push_back(h[now.x][now.y]);
			}else if(step2 == now.step)ve2.push_back(h[now.x][now.y]);//其他情况要保证和第一个入队的步数是一致的
		}
		for(int i = 0; i < 4; i++){
			int nx = now.x + dx[i];
			int ny = now.y + dy[i];
			if(in(nx, ny) && !vis[nx][ny] && h[nx][ny]){//判断是否符合条件
				vis[nx][ny] = true;
				q.push({nx, ny, now.step + 1});
			}
		}
	}
}

int main(){
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			scanf("%d", &h[i][j]);//读入高度
		}
	}
	while(k--){
		int x, y;
		scanf("%d%d", &x, &y);
		mp[x][y] = 1;//将可以传送的点进行标记
	}
	sx = 1, sy = 1, ex = n, ey = m;
	bfs1();
	memset(vis, 0, sizeof vis);
	while(!q.empty()){q.pop();}
	bfs2();
   //找最小的答案
	int ans2 = 1e9;
	for(auto i : ve1){
		for(auto j : ve2){
			if(i != j)ans2 = min(ans2, step1 + step2 + 2);//高度不一致的话需要先调整到相同的高度再传送
			else ans2 = min(ans2, step1 + step2 + 1);
		}
	}
	if(ans >= 0)ans2 = min(ans2, ans);
	if(ans2 == 1e9)cout << -1 << endl;
	else cout << ans2 << endl;
	return 0;
}
```

---

## 作者：appear_hope (赞：0)

状态：

$(x, y, sum)$，表示当前在位置 $(x, y)$，已走时间为 $sum$。

转移：

$(x, y, sum) \rightarrow (x + 1, y, sum + 1)$。

$(x, y, sum) \rightarrow (x, y + 1, sum + 1)$。

$(x, y, sum) \rightarrow (x - 1, y, sum + 1)$。

$(x, y, sum) \rightarrow (x, y - 1, sum + 1)$。

令 $(X_i, Y_i)$ 为第 $i$ 个可以御剑飞行的点。

如果 $(x, y) = (X_j, Y_j)$ 且 $h_{x, y} = h_{X_i, Y_i}$，则 $(x, y, sum)$ 可以转移到 $(X_i, Y_i, sum + 1)$，其中 $i \ne j$。

如果 $(x, y) = (X_j, Y_j)$ 且 $h_{x, y} \ne h_{X_i, Y_i}$，则 $(x, y, sum)$ 可以转移到 $(X_i, Y_i, sum + 2)$，其中 $i \ne j$。（修改 $h_{x, y}$，然后御剑飞行）

如果 $k = 0$，则没有第 $4$ 个转移和第 $5$ 种转移，那么转移的代价都是一样的，直接使用 bfs。

如果 $h_{i, j} \le 1$，则不会有第 $5$ 种转移，考虑 bfs，因为转移的代价都是 $1$，所以当状态第一次进入队列时一定是最优的，那么现在的时间复杂度：$O(nmk)$，继续优化，可以想到第一次找到可以御剑飞行的状态后进行第 $4$ 种转移，扩展出的状态一定是最优的，然后后面又找到可以御剑飞行的状态后进行第 $4$ 种转移扩展出的状态不一定是最优的。

考虑正解：

基于桶的 bfs

如果一道题的边权不统一且最优化属性值较小，可以使用该算法。

以这道题为例，画一颗 bfs 路径树，介绍该算法：

举个栗子：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t2qdrbb.png)

这其实也是 dijkstra。

可想到代码思路：

```cpp

void Record(状态){
  if(已经转移){
    //转移出来的状态不会更优  	 
    return ;
  }
  //加入状态
}

for(枚举最优化属性 i){ //层次
  for(枚举最优化属性为 i 的状态 j){
    if(状态j没有被扩展){
      //状态j已被扩展
      Record(); //转移
    }
  }
}
```

云梦瑶这道题还有一个细节，如果当前层次有可以御剑飞行的点不要急着转移(否则你会 $TLE$)，你可以记录当前层次可以御剑飞行的点的 $h_{i, j}$ 有哪些，最后在当前层次我们就只需做一次 $O(k)$ 的御剑飞行即可。（如果不在第一个可以御剑飞行的层次不御剑飞行，后面御剑飞行是一定没有之前更优的）

使用这种算法注意对常数的优化，这个算法码量普遍很长。

[代码](https://www.luogu.com.cn/paste/zu0qb6d2)

习题：

P9751

P1073

P3956

耐心食用


---

## 作者：MspAInt (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9065)

从起点到终点只有两种走法：

1. 一步一步走。
2. 在离起点最近的传送点与离终点最近的传送点（这样的点对暂称为“最优传送点对）之间进行一次御剑飞行，剩下的步行。

现在推第 $2$ 点的正确性：

* 多次飞行：例如有一条到终点的路径 $s-X-Y-Z-t$（只记录中途使用的传送阵），$s$ 表示起点，$t$ 表示终点。$X-Y-Z$ 这条路径上**至少**消耗了 $2$ 单位时间，但如果直接从 $X$ 到 $Z$ **至多**需要 $2$ 单位时间，显然更优。
* 不走离起点最近的传送点：假设有 $A,B$ 两个待选传送点，目前朵一在点 $A$ 的位置。此时在 $A$ 点起飞的**最坏**情况是花费 $2$ 单位时间	（调整高度，起飞）；在 $B$ 点起飞的**最佳**情况是花费 $dis(A,B)+1$ 单位时间（移动，起飞），其中 $dis(A,B)$ 表示点 $A$、$B$ 之间的曼哈顿距离，且显然 $1 \leq dis(A,B)$。对比之下就近飞一定不会劣于多走几步飞。
* 不走离终点最近的传送点：这不是折磨自己吗。

但是还有一点需要考虑：如果有**不止一对“最优传送点对”**，那么要**尽量取两点高度相等**的一对，以消去调整高度的那一步。

注意到 $h_{i,j} \leq 9 \times 10^6$，可以**开一个桶来存目前找到过的高度**，当存在高度相等的“最优传送点对”，答案减一。

于是总体思路就出来了：算出每个点到起点/终点的距离，选出“最优传送点对”，判高度。

特别地，当两种走法都行不通时，输出`-1`。

时间复杂度：$\Theta(nm+k)$（bfs 算距离&判高度、读入）。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=9e6+10,N=3e3+10;
int n,m,k,s,t,ans;
int h[N][N],d[N][N][2],dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1};
bool v[N][N],b[M],p[N][N];
int bfs(bool l){
	queue<pair<int,int>>q;
	int sx,sy,ret=1e9+1;
	sx=l*n+(!l),sy=l*m+(!l);
	q.push(make_pair(sx,sy));
	d[sx][sy][l]=0;
	memset(v,0,sizeof(v));
	v[sx][sy]=1;
	while(!q.empty()){
		pair<int,int>bot=q.front();
		int x=bot.first,y=bot.second;q.pop();
		if(p[x][y]&&ret>1e9)ret=d[x][y][l];
		for(int i=1;i<=4;i++){
			int ex=x+dx[i],ey=y+dy[i];
			if(ex<1||ex>n||ey<1||ey>m||!h[ex][ey]||v[ex][ey])
				continue;
			v[ex][ey]=1;
			d[ex][ey][l]=d[x][y][l]+1;
			q.push(make_pair(ex,ey));
		}
	}
	return ret;
}
signed main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&h[i][j]);
	for(int i=1,x,y;i<=k;i++){
		scanf("%d%d",&x,&y);
		p[x][y]=1;
	}
	memset(d,0x3f,sizeof(d));
	s=bfs(0);t=bfs(1);
	ans=min(d[n][m][0],s+t+2);
	if(ans>1e9){
		printf("%d\n",-1);
		return 0;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(p[i][j]&&d[i][j][0]==s)
				b[h[i][j]]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(p[i][j]&&d[i][j][1]==t)
				if(b[h[i][j]]){
					printf("%d\n",ans-1);
					return 0;
				}
	printf("%d\n",ans);
	return 0;
}
```

[record](https://www.luogu.com.cn/record/102271597)

---


# 「SvR-2」音符

## 题目描述

>本题中「子串」指：
>
>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。

我们用一个字符串代替一份乐谱，用字符代替每一个音符。

我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\tt eeeee$ 中存在 $4$ 个「重音」。

现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：

- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。
- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。

现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

| $\bf{Subtask}$ | $\bm{n\le}$ | $\bm{\sum n\le}$ | $\bm{T\le}$ | $\bf{Score}$ |
| :-: | :-: | :-: | :-: | :-: |
| $\sf 1$ | $6$ | $10$ | $3$ | $\tt 10$ |
| $\sf 2$ | $10^3$ | $2\times 10^3$ | 无特殊限制 | $\tt 30$ |
| $\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\tt 60$ |

对于 $100\%$ 的数据，有 $2\le T\le 100$，$2\le n,k\le 10^5$，$1\le a,b\le 10^9$。单组数据内保证 $\sum n\le 2\times 10^5$。

#### 输出注意事项

输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。

乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。

#### Special Judge 返回信息说明

本题采用 Special Judge 判断你的答案是否正确。

checker.cpp 将会以 $\texttt{Score=}\text A,\texttt{Type=}\text B$ 的方式返回信息。

$\tt Score$ 类表示你的得分情况，$\text A$ 有以下取值：

- $\text A=1$，表示含义如下：\
  $\underline\text{Accepted.} \texttt{ Your Ans and SM are both proper.}$\
  代表 $T$ 组答案全部符合要求。
- $\text A=2$，表示含义如下：\
  $\underline\text{Partially Correct.}\texttt{ All Ans are right.}$\
  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\%$ 的分数。
- $\text A=3$，表示含义如下：\
  $\underline\text{Partially Correct.}\texttt{ You pass 70\% tests!}$\
  表示该测试点中你的回答正确的组数**不少于**$\lfloor0.7\times T\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\%$ 的分数。
- $\text A=4$，表示该测试点你只能拿到 $0$ 分。

$\tt Type$ 类表示你的得分情况，$\text B$ 有以下取值：

- $\text B=0$，表示你的答案全部正确，与 $\text A=1$ 配对。
- $\text B=1$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ The length of your SM is not right!}$\
  代表你在一组数据中构造的乐谱的长度不为 $n$。
- $\text B=2$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ Your Ans is not right!}$\
  代表你在一组数据中 $x$ 的值错误。
- $\text B=3$，表示含义如下：\
  $\underline\text{Wrong Answer.}\texttt{ Your Ans and SM are not matched!}$\
  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。

这里 $\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。

注意到 $\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。

## 样例 #1

### 输入

```
2
4 5 2 2
8 6 3 2```

### 输出

```
0
Sept
3
2023yyds```

# 题解

## 作者：CSP_Sept (赞：17)

>本题解中「平铺」指：
>
>用一个字符串循环拼接无限次，取前 $n-1$ 个字符组成新字符串。

### $\textbf{Subtask 1}$

留给 $O(T2^nn)$ 的选手们。

期望得分 10 分。

### $\textbf{Subtask 2}$

留给 $O(n^2)$ 的 dp 选手们。

期望得分 40 分。

### $\textbf{Subtask 3}$

容易发现，只有两种字符是有效的。

使用一个长度为 $n-1$ 的 01 串表示乐谱中的情况，对于第 $i$ 个字符，

- 为 $0$ 表示没有「重音」，即 $s_i\ne s_{i+1}$。
- 为 $1$ 表示有「重音」，即 $s_i=s_{i+1}$。

构造长为 $(n-1)$ 的 $01$ 串，每个 $1$ 的代价为 $a$，每连续 $(k-1)$ 个 $0$ 的代价为 $b$。

最优解有以下三种情况：

1. 「平铺」$0$；
2. 「平铺」长为 $(k-1)$ 的串 $000\ldots0001$；
3. 「平铺」长为 $(k-1)$ 的串 $000\ldots0001$，但是将**最后一个** $1$ 改为 $0$。

考虑证明这个结论：

对于情况 2，

- 若把除了最后一个以外的 $1$ 改成 $0$ 更优，运用类比可知全部改为 $0$ 更优，于是变成情况 1（若把 $0$ 改成 $1$，无故多了一个代价 $a$，肯定不优）。
- 由于最后一个 $1$ 后面可能不满 $k-2$ 个 $0$，所以诞生了情况 3。

$\text{Q. E .D. }$

期望得分 100 分。

---

## 作者：MarchKid_Joe (赞：8)

# [P9087 「SvR-2」音符](https://www.luogu.com.cn/problem/P9087)

## 题意

构造题目。定义 $\text{XX}$ 为**两个连续的相同字符**。

---

有两种代价：

- 每个 $\text{XX}$ 产生 $a$ 的代价。
- 长度为 $k$ 的子串没有出现 $\text{XX}$ 产生 $b$ 的代价。

构造一个字符串使得总代价最小。

## Solution

考虑 $\text{XX}$ 的影响：造成 $a$ 的代价；在**不越界**的情况下可以被 $k-1$ 个子串所包含，消除 $(k-1)\times{b}$ 的代价。

---

特判 $k=2$ 的情况，此时发现字符串只有可能为全是相同字符的字符串或不存在 $\text{XX}$ 的字符串。因为如果是两个混合的话，贡献为 $c_1\times{a}+c_2\times{b},[c_1+c_2=n-1]$，显然不如 $(n-1)\times\min(a,b)$ 更优。

---

根据上面的分析：可以不使用 $\text{XX}$ 的判断依据是：

$$
{a}\geqslant{b}\times(k-1)
$$

此时直接随意输出一个不存在 $\text{XX}$ 的字符串即可，贡献为 $b\times(n-k+1)$。

---

否则构造含有 $\text{XX}$ 的字符串：

$l$ 为当前 $\text{XX}$ 影响的左端，$r$ 为影响的右端，$m$ 为当前 $\text{XX}$ 覆盖的右端，图解变量：

![](https://cdn.luogu.com.cn/upload/image_hosting/lfcn4nvm.png)

当 $l,r\in[1,n]$ 时，在 $m,m-1$ 的位置放置 $\text{XX}$，即 ${a}\times{cnt}$。

当 ${r}\gt{n}$ 时，继续在 $m,m-1$ 的位置放置 $\text{XX}$ 或者计算 $n-m+1$ 个剩余字串的代价，即 $\min\{a,b\times(n-m+1)\}$。

## Example

如果不能理解的话，举个例子。假设 $n=15,k=5$。

观察一个 $\text{XX}$ （红色部分 $[4,5]$）在**不越界**时可以影响的 $k-1$ 个子串（蓝色部分 $[1,8]$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/uxq5n45f.png)

发现 $[5,9]$ 这个子串的 $b$ 的代价无法被 $[4,5]$ 消除。若要继续消除 $b$ ，需要每隔 $k-1$ 个位置再放置一个 $\text{XX}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0mnguqrb.png)

按照上面的构造方案，若在 $[12,13]$ 放一个 $\text{XX}$ 会溢出 $[16,16]$，这样可能会浪费。此时便有两种选择：继续花费 $a$ 的代价放置 $\text{XX}$ 或者直接计算剩余子串 $b$ 的代价。

此时剩余无法覆盖的子串（图中黄线）的数量为 $n-m+1$ 个，花费 $a$ 的代价放置 $\text{XX}$ （图中红虚线）或者花费 $b\times(n-m+1)$ 的代价，两者取代价最小的。

![](https://cdn.luogu.com.cn/upload/image_hosting/v57499to.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/8mmaxh4i.png)

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
char s[N];
char name[10] = "Nahida"; /*随机定义一个不含有 XX 的字符串即可*/
char same[10] = "AC"; /*选择两个字符是因为 k=3 时这种构造方案会出现 XXXX 的情况，改为 XXYY 即可*/
int T, n, k, a, b;
signed main()
{
    cin >> T;
    while (T --> 0)
    {
        int ans = 0, cnt = 0, m = 0;
        cin >> n >> k >> a >> b; s[n + 1] = '\0';
        for (int i = 1; i <= n; i++) s[i] = (k == 2 && a < b) ? 'Q' : name[(i - 1) % 6];
        if (k == 2) {ans = (n - 1) * min(a, b);goto print;}
        if (a >= (k - 1) * b) {ans = b * (n - k + 1);goto print;}
        for (int l = 1, r; m = l + k - 1, (r = m + k - 2) <= n; l = m)
            s[m] = s[m - 1] = same[(++cnt) & 1];
        if (a < (n - m + 1) * b)
            s[m] = s[m - 1] = same[(++cnt) & 1];
        else
            ans = (n - m + 1) * b;
        print: cout << max(ans + a * cnt, 0ll) << '\n' << (s + 1) << '\n';
    }
    return 0;
}
```

---

## 作者：Demeanor_Roy (赞：4)

- [原题链接](https://www.luogu.com.cn/problem/P9087)

- 提供一种不用动脑子的 DP 方法。

------------

考虑 dp，$f(i)$ 表示考虑到第 $i$ 个字符，且最后两个字符相同的最小愤怒值。显然枚举 $j \in [0,i-1]$ 即可做到 $O(n)$ 转移。这也就是出题人所说的暴力 DP。

思考如何优化。显然转移可以分两类：

- 当 $j\leq i-k-1$ 时，$f(i)=f(j)+(i-j-k-1) \times b +a$。

- 当 $i-k-1 < j \leq i-1$ 时，$f(i)=f(j)+a$。

显然前者只需要用一个变量动态维护 $f(x)-x \times b$ 的最小值，后者用单调队列优化即可。

至于方案，就在转移是记录一个 $fr(i)$ 表示 $i$ 从哪转移而来即可。

时间复杂度 $O(\sum n)$。下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N=1e5+10;
const LL INF=1e18;
int T,n,k,a,b,head,tail,now,bc,la,fr[N],q[N];
LL f[N];
inline void solve()
{
	head=now=bc=f[now]=0,tail=-1,f[1]=INF;
	scanf("%d%d%d%d",&n,&k,&a,&b);
	for(int i=2;i<=n;i++) 
	{
		fr[i]=0;
		if(i<=k) f[i]=a,q[++tail]=i;
		else f[i]=a+(LL)(i-k)*b;
	}
	for(int i=k+1;i<=n;i++)
	{
		while(head<=tail&&q[head]<=i-k+1) 
		{
			if(f[now]-(LL)now*b>f[q[head]]-(LL)q[head]*b) now=q[head];
			head++;
		}
		if(f[now]+(LL)(i-now-k+1)*b+a<=f[i]) f[i]=f[now]+(LL)(i-now-k+1)*b+a,fr[i]=now;
		else if(head<=tail&&f[q[head]]+a<=f[i]) f[i]=f[q[head]]+a,fr[i]=q[head];	
		while(head<=tail&&f[i]<=f[q[tail]]) tail--;
		q[++tail]=i;
	}
	for(int i=2;i<=n;i++) if(f[i]+(n-i+1>=k?(LL)(n-i-k+2)*b:0)<f[bc]+((n-bc+1>=k)?(LL)(n-bc-k+2)*b:0)) bc=i;
	if(f[bc]+((n-bc+1>=k)?(LL)(n-bc-k+2)*b:0)>=max(0LL,(LL)(n-k+1)*b)) bc=0;
	printf("%lld\n",f[bc]+(n-bc+1>=k?(LL)(n-bc-k+1+(!!bc))*b:0));
	for(int i=1;i<=n;i++) f[i]=0;
	while(bc) f[bc]=1,bc=fr[bc];
	for(int i=1;i<=n;i++) if(f[i]) printf("%d",la);else la^=1,printf("%d",la);
	printf("\n");
}
int main()
{
	scanf("%d",&T);
	while(T--)	solve();
	return 0;
}
```


---

## 作者：elbissoPtImaerD (赞：3)

来个 $O(n\log n)$ 搞笑做法。

下文 $k$ 为原题中的 $k-1$。

我们只需关注 $n-1$ 对相邻数字是否相同，所以我们的字符集大小只需为 $2$ 即可。

设输出的字符串为 $s$ 下标 $[0,n)$，记 $a_i=[s_i = s_{i-1}]$。

贪心地，我们每次只需让某些 $a_{ik}$ 为 $1$ 即可。

更贪心地，我们只需让 $a_{ik}$ 的一段前缀为 $1$ 即可。

枚举这段前缀的长度可以做到 $O(n^2)$。

然后你发现代价关于前缀长度是谷函数，直接二分找到极值点构造即可。

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/147383943)

---

## 作者：FanYongchen (赞：1)

dp 做法。

首先可以发现乐谱可以只由两个不同的字符组成，因为我们要关心的只是相邻的两位是否相同。

可以设 $f_{i,0}$ 表示前 $i$ 个字符中第 $i$ 个与第 $i-1$ 个字符相同时产生的最小愤怒值，$f_{i,1}$ 则表示不同时的最小值。

第 $i$ 个与第 $i-1$ 个字符相同时会产生 $a$ 的愤怒值，所以 $f_{i,0}=\min(f_{i-1,1},f_{i-1,0})+a$。

计算 $f_{i,1}$ 时，我们要枚举不出现重音的子串的长度，所以 $f_{i,1}=\min(f_{j,0}+\max(0,i-j+1-k+1)\times b)\ (1\leq j<i-1)$。

最后的答案就是 $\min(f_{n,0},f_{n,1})$。

这样的复杂度是 $O(n^2)$，考虑优化。

首先可以想到 $n$ 越小则愤怒值越小，因为不管加上什么字符都不会让愤怒值减小。

那么 $f_{i,1}$ 的最小值就是 $\min(f_{j,0}+(i-j+1-k+1)\times b)\ (1\leq j\leq i+1-k)$ 和 $f_{i+2-k,0}$ 的较小值（要处理 $i+2-k\leq 0$ 的情况）。

将 $f_{j,0}+(i-j+1-k+1)\times b$ 变成 $(f_{j,0}-j\times b)+(i+1-k+1)\times b$。

所以我们可以记录下 $f_{j,0}-j\times b$ 的最小值，这样就将转移变成了 $O(1)$，总的复杂度为 $O(n)$。

最后就是记录方案了，只需要记录每个状态是从哪个状态转移过来的，最后从后往前推就行。

```
#include <bits/stdc++.h>
using namespace std;
#define ms(x,y) memset(x,y,sizeof(x))
#define ll long long
const int M=114514;
ll f[M][2],path[M][2][2];
ll n,k,a,b;
ll ans[M];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%lld%lld%lld%lld",&n,&k,&a,&b);
		ms(f,0x3f);
		f[1][1]=f[1][0]=0;
		ll minn=0x3f3f3f3f3f3f3f3f,p=-1;
		//上面的f[j][0]-j*b的最小值和j的位置
		for(int i=2;i<=n;i++)
		{
			f[i][0]=min(f[i-1][1],f[i-1][0])+a;
			if(f[i-1][1]<f[i-1][0]) path[i][0][0]=i-1,path[i][0][1]=1;
			else path[i][0][0]=i-1,path[i][0][1]=0;
			int pp=max(1ll,i+2-k);
			if(i-k+2>1) 
			{
				if(f[i-k+2-1][0]-b*(i-k+2-1)<minn)
					minn=f[i-k+2-1][0]-b*(i-k+2-1),p=i-k+2-1;
			}
			path[i][1][1]=0,path[i][1][0]=pp,f[i][1]=f[pp][0];
			if(pp!=-1&&minn+i*b+2*b-k*b<f[i][1])
				f[i][1]=minn+i*b+2*b-k*b,path[i][1][0]=p;
		}
		cout<<min(f[n][0],f[n][1])<<"\n";
		int pos=n,op;
		if(f[n][0]>f[n][1]) op=1;
		else op=0;
		while(pos!=1)
		{
			int l=path[pos][op][0]-1,r=pos;
			
			if(op==0) for(int i=l;i<r;i++) ans[i]=ans[r];
			else for(int i=r-1;i>=l;i--) ans[i]=ans[i+1]^1;
			//状态表示第i为与第i+1位是否相同，所以记录答案要根据状态来。 
			int x=pos,y=op;
			pos=path[x][y][0],op=path[x][y][1];
		}
		for(int i=1;i<=n;i++) cout<<ans[i];
		cout<<"\n";
	}
	return 0;
}

```

---

## 作者：Aventurine_stone (赞：0)

## 1. 题目分析
这数据范围，是一道线性时间复杂度的构造题。~~反正我也想不出动态规划做法。~~
## 2. 题目做法
题目中有两种增加愤怒值的情况，我们只能先一个一个分开考虑。  
先只考虑只有情况一时，我们先建造一个任意相邻三值都不相同的序列，我们要将其中一些值改变成与前一个值相同，从而满足只有情况一且造成的愤怒最小。举一个 $n$ 为 $22$，$k$ 为 $7$ 的例子,我们考虑以下构造：  
![](https://cdn.luogu.com.cn/upload/image_hosting/ilqg097m.png)  
上面的数字代表区间长度，绿色区间为无重音区间，红色为全是重音的区间。  
这样构造，恰好每个长度为 $k$ 的子串中都没有重音，这也使重音变得最少，故此构造可在此情况使愤怒值最小。  
构造方式也不难，最开始的绿区间长度为 $k - 2$，之后便是一个长度为 $2$ 的红区间再一个长度为 $k - 3$ 的绿区间，直到长度不够为止。  
再来考虑情况二，我们可以轻易得出，当 $n$ 比 $k$ 小时，愤怒值为 $0$。否则愤怒值为 $(n - k + 1) \times b$。  
最后综合考虑，若 $n$ 小于 $k$，愤怒值为零，此时的序列构造自然不必多说。  
若 $b \times (k - 1)$ 小于等于 $a$，则说明不管在任何地方有重音，愤怒值总会提高，那么我们构造的序列中便不能有任何重音。  
如果最后一段红区间被改变为绿区间后，愤怒值下降，那么最后一次重音我们便不构造，否则便构造，愤怒值相信大家应该都会算，不会算的看我代码。  
如此我们便可完成此题。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int T;
long long n,k,a,b;
long long t,c;
int s[N];
int main()
{
	T=read();
	while(T--)
	{
		n=read(),k=read(),a=read(),b=read();
		if(n<k)
		{
			printf("0\n");
			for(int i=1;i<=n;i++)
			{
				if(i&1)
					printf("1");
				else
					printf("2");
			}
			putchar(10);
			continue;
		}
		if(b*(k-1)<=a)//全情况二最优 
		{
			printf("%lld\n",b*(n-k+1));
			for(int i=1;i<=n;i++)
			{
				if(i&1)
					printf("1");
				else
					printf("2");
			}
			putchar(10);
			continue;
		}
		t=(n-1)/(k-1);
		c=n-t*(k-1);
		for(int i=1;i<=n;i++)
		{
			if(i%3==1)
				s[i]=1;
			else if(i%3==2)
				s[i]=2;
			else
				s[i]=3;
		}
		if(c*b<=a)//判断最后一个重音是否该去掉 
		{
			printf("%lld\n",(t-1)*a+c*b);
			for(int i=k,j=1;j<t;i+=k-1,j++)
				s[i]=s[i-1];
		}
		else
		{
			printf("%lld\n",t*a);
			for(int i=k,j=1;j<=t;i+=k-1,j++)
				s[i]=s[i-1];
		}
		for(int i=1;i<=n;i++)
			printf("%d",s[i]);
		putchar(10);
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P9087 「SvR-2」音符 题解

## 题意回顾

对于长度为 $ n $ 的字符串，按照以下方式累积这个串的代价：

* 每出现一次相邻两个字符相同，增加 $ a $。

* 每存在一个长度为 $ k $ 的子串内所有相邻两个字符不同，增加 $ b $。

$ T $ 次给定 $ n,k,a,b $ 作为参数，构造长度为 $ n $ 且代价最小的由任意可见字符组成的字符串，要求给出最小代价并输出构造方案。

$ 2 \le T \le 100 $，$ 2 \le n,k \le 10^5 $，$ 1 \le a,b \le 10^9 $，$ \sum n \le 2 \times 10^5 $。

## 分析

我们只关心对于 $ 1 \le i < n $，字符 $ i $ 和 $ i+1 $ 是否为相同字符。

遇事不决先 DP，我们考虑 $ dp_i $ 表示前 $ i+1 $ 个字符中，字符 $ i $ 和 $ i+1 $ 相同时，产生的最小代价。

* 若在上一个连续的相邻字符不同段中，没有产生第二种代价，则转移为 $ dp_{i}=dp_{j}+a $，要求 $ j \ge i-k $。

* 若在上一个连续的相邻字符不同段中，已经产生了至少一次第二种代价，则转移为 $ dp_{i}=dp_{i-k-r}+a+b \times r $。

我们设计了一个平方 DP，可以拿到 $ 40 $ 分。

考虑加快转移速度，第一类转移显然可以单调队列优化，第二类转移式子略显复杂，我们转化一下，即 $ dp_{i}=dp_{i-k-r}+(r+k-i)\times b + (i-k) \times b $，此时我们发现 $ (i-k) \times b $ 和 $ r $ 无关，若将 $ i-k-r $ 视作一个整体则式子的前两项和 $ i $ 无关。

整理一下，记 $ q=i-k-r $，则有 $ dp_{i}=(dp_{q}-q\times b)+(i-k)\times b $，要求 $ q<i-k $。

维护 $ fp $ 数组，$ fp_i=dp_{i}-i\times b $，则转移方程式化为 $ dp_{i}=fp_{q}+(i-k)\times b $，则我们维护 $ fp $ 的前缀最小值即可。

因为需要输出方案，所以我们需要记录转移位置，故需维护 $ fp $ 的前缀最小值位置。

注意代价值需要用 `long long` 存储。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int T;
int n, k, a, b;
long long dp[N];
long long fp[N];
long long fi[N];
long long dr[N];
struct Queue {
	int st, ed;
	int num[N];
	void init() {st = 1, ed = 0;}
	void push(int x) {num[++ed] = x;}
	void pope() {ed--;}
	void pops() {st++;}
	bool empty() {return (st > ed);}
	int front() {return num[st];}
	int back() {return num[ed];}
	void qpush(int x) {
		while(empty() && dp[back()] > dp[x]) pope();
		push(x);
	}
} que;
int ans[N];
void findans(int x) {
	if(dr[x] > 0) findans(dr[x]);
	ans[x] = 1;
}
int main() {
	scanf("%d", &T);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d%d%d%d", &n, &k, &a, &b);
		n--, k--, que.init();
		fp[0] = 0;
		fi[0] = 0;
		que.qpush(0);
		for(int i = 1; i < min(n + 1, k); i++) {
			dp[i] = a;
			fp[i] = min(fp[i - 1], dp[i] - i * b);
			if(fp[i] < fp[i - 1]) fi[i] = i;
			else fi[i] = fi[i - 1];
			dr[i] = 0;
			que.qpush(i);
		}
		//dp[i]=dp[T]-Tb+(i-k)*b(T<i-k)
		//fp[i]=dp[i]-i*b
		//dp[i]=min{fp[T]}+(i-k)*b+a(T<i-k)
		//dp[i]=min{dp[j]}+a(i-k<=j<i)
		for(int i = k; i <= n; i++) {
			dp[i] = fp[i - k - 1] + (long long)(i - k) * b + a, dr[i] = fi[i - k - 1];
			while(que.front() < i - k) que.pops();
			if(dp[que.front()] + a < dp[i]) dp[i] = dp[que.front()] + a, dr[i] = que.front();
			fp[i] = min(fp[i - 1], dp[i] - i * b);
			if(fp[i] < fp[i - 1]) fi[i] = i;
			else fi[i] = fi[i - 1];
			que.qpush(i);
		}
		int id = 0;
		long long val = 1e18 + 5;
		for(int i = 0; i <= n; i++) {
			if(i > n - k) {
				if(dp[i] < val) id = i, val = dp[i];
			} else {
				if(dp[i] + (long long)(n - k - i + 1) * b < val) id = i, val = dp[i] + (long long)(n - k - i + 1) * b;
			}
		}
		for(int i = 1; i <= n; i++) ans[i] = 0;
		findans(id);
		printf("%lld\n", val);
		printf("x");
		char op = 'x';
		for(int i = 1; i <= n; i++) {
			if(ans[i] == 0) op = 'x' + 'y' - op;
			cout << op;
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：qzhwlzy (赞：0)

### 题目大意

定义一个 长度为 $n$ 的字符串的价值为：

1. 每有连续两个字符相同，则价值增加 $a$；
2. 每连续 $k$ 个字符**没有**连续两个相同，则价值增加 $b$。

给定 $n,k,a,b$，构造字符串使得价值最小。

### 思路

我们记 $b_i$ 表示 $a_i$ 和 $a_{i+1}$ 是否相同。接下来考虑构造 $b$ 数组。

假设现在 $b$ 中有连续 $k-1$ 个 $0$，那么我们的价值会增加 $b$，假设我们不要这个 $b$，那么，我们一定只在里面放一个 $a$，否则代价更大。

我们分类讨论：

- 假设 $b$ 远小于 $a$，我们肯定构造 $b = 000\ldots 00$（$n-1$ 个 $0$），此时代价是 $(n-k+1)\times b$。

- 假设 $a$ 远小于 $b$，我们肯定构造 $b = 000\ldots001\,000\ldots001\ \ldots$（$k-2$ 个 $0$ 加一个 $1$ 循环），因为此时最小化了 $a$ 且没有 $b$ 出现。

- 最后，假设 $a,b$ 相差不大，那么，我们比较这两种哪个大即可。但是，有一种特殊情况：假设 $n-1$ 不是 $k-1$ 的倍数，那么我们的最后一个 $1$ 不填可能更优，因为之前的 $1$ 能减少 $2k-1$ 个 $b$ 的代价，而最后这个可能小于 $2k-1$ 个，于是可能不填 $1$ 更优。

所以直接把三种情况算出来比较哪个小即可。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#define maxn 100005
#define ll long long
using namespace std;
int T,n,k,a,b,out=0,las; ll ans1=0; bool outp[maxn];
int main(){
	scanf("%d",&T); while(T--){
		scanf("%d%d%d%d",&n,&k,&a,&b); out=ans1=las=0;
		
		for(int i=1;i<n;i++){outp[i]=(i%(k-1)==0); if(outp[i]) las=i,ans1+=a;}
		if(las&&ans1-a+1LL*(n-las)*b<ans1){ans1=ans1-a+1LL*(n-las)*b; outp[las]=0;}

		if(ans1>max(1LL*(n-k+1)*b,0LL)){
			printf("%lld\n",max(1LL*(n-k+1)*b,0LL));
			for(int i=1;i<=n;i++,out^=1) printf("%d",out);
		}else{
			printf("%lld\n1",ans1);
			for(int i=1;i<n;i++,out^=1){if(outp[i]) out^=1; printf("%d",out);}
		} printf("\n");
	}
	return 0;
}
```

---


# 夕阳西下几时回

## 题目背景

随着夕阳从山间落下，最后一丝余晖逐渐暗淡；美丽的晚霞，终究还是化作一片黑夜。在这番景象中，一阵又一阵的乡愁涌上心头；远离家乡的游子，就算不是病死他乡，又何时能回还？

## 题目描述

夕阳可以被视作由 $n$ 种不同颜色组成的一副图，其中第 $i$ 种的颜色为 $a_i$，满足 $a$ 是长度为 $n$ 的排列。

定义一个排列的乡愁度为：

+ 对于所有 $1\le i\le n$，记 $b_i=\gcd(a_i,a_{i+1})$。特别地，我们认为 $a_{n+1}=a_1$。
+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。

求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出任意一个排列。

## 说明/提示

**【提示】**

一个长度为 $n$ 的排列是一个满足 $1$ 到 $n$ 中的所有正整数恰好出现 $1$ 次的数组。例如，$[3,1,2]$ 是一个长度为 $3$ 的排列，而 $[5,5,1,2,3]$ 不是一个排列。

**【样例 1 解释】**

- 对于第一组数据，$b=[1,1,1,1,1,1,1]$，故 $p$ 的乡愁度为 $1$。
- 对于第二组数据，可以证明不存在这样的序列。
- 对于第三组数据，$b=[1,1,3,3,1,1,2,1,5,2,1]$，包含 $4$ 个不同的元素 — $1,2,3$ 和 $5$，故 $p$ 的乡愁度为 $4$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（4 points）：$n\le 9$，$\sum n\le 100$。
-  Subtask 2（5 points）：$k=1$。
-  Subtask 3（13 points）：$\sum n\le 200$。
-  Subtask 4（30 points）：对于所有测试数据，保证有解。
-  Subtask 5（48 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$3\le n\le 3\times 10^5$，$1\le k\le n$，$\sum n \le 6\times 10^5$。

## 样例 #1

### 输入

```
3
7 1
6 5
11 4
```

### 输出

```
Yes
1 2 3 4 5 6 7
No
Yes
1 11 9 3 6 7 8 2 5 10 4
```

# 题解

## 作者：Ecrade_ (赞：22)

$k$ 的理论上界显然是 $\left\lfloor\frac{n}{2} \right\rfloor$，因为 $1\sim n$ 中任意两个不同正整数的最大公约数至多为 $\left\lfloor\frac{n}{2} \right\rfloor$。

我们首先考虑能否构造一个排列达到这个上界。

将所有 $i$ 和 $2i\ (1\le 2i\le n)$ 连边，则我们得到了若干条链。将这些链依次相接即可，即：

$$(1,2,4,8,...),(3,6,12,...),(5,10,20,...),...$$


那如果 $k$ 比这个上界小呢？很简单，将 $(2k+1)\sim n$ 倒序接在 $1$ 后面以达到 “舍去” 这些数的效果，即：

$$(1,n,(n-1),...,(2k+1)),(2,4,8,...),(3,6,12,...),(5,10,20,...),...$$

当然，构造方案并不唯一。

时间复杂度为 $O(\sum n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,n,k;
inline ll read(){
	ll s = 0,w = 1;
	char ch = getchar();
	while (ch > '9' || ch < '0'){ if (ch == '-') w = -1; ch = getchar();}
	while (ch <= '9' && ch >= '0') s = (s << 1) + (s << 3) + (ch ^ 48),ch = getchar();
	return s * w;
}
int main(){
	t = read();
	while (t --){
		n = read(),k = read();
		if (k > n / 2){puts("No"); continue;}
		puts("Yes"),printf("1 ");
		for (ll i = n;i >= k * 2 + 1;i -= 1) printf("%lld ",i);
		for (ll i = 1;i <= k * 2;i += 2) for (ll j = max(2ll,i);j <= k * 2;j *= 2) printf("%lld ",j);
		puts("");
	}
	return 0;
}
```


---

## 作者：wizard（偷开O2 (赞：7)

一道非常好的数论题

## 题意

有一个有 $n$ 个元素的环，第 $i$ 个元素的标号为 $i$，每个元素有一个权值，这个环的总权值为相邻两个元素权值的最大公约数组成序列 $b$ 的不同元素的个数，现在知道元素个数和总权值，让你求出原排列。

## 证明
已知环内所有元素的权值都小于 $n$，而且任意两个数（两数不同）的最大公约数都不会大于两个数之间较小的数，显然也不会大于较大的数。如果要让两个数的最大公约数尽量的大,那两个数之间的较小的数也要尽量的大。显然，当环中权值为 $n$ 的元素和权值为 $n/2$ 的元素并列时，两数有最大公约数，而且最大公约数为 $n/2$，因为 $n$ 为环中最大的数，所以环中最大的最大公约数为 $n/2$。

进而我们就知道了 $k$ 一定是 $\le n/2$ 的，所以当 $k > n/2$ 的时候，这个序列不可能存在，直接特判就行。

## 构造序列

先构造一个答案序列，先前环中标号为 $x$ 的元素不变，让他的下一个元素 $x+1$ 的权值 $a_{x+1}$ 变成两倍的 $a_x$，所以相邻两个数的最大公约数就有价值了。

也就是说让 $\le k$ 的正整数全部存在在答案序列中就完美了。

直接推出原序列。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=3e5+10;
signed main(){
	int T;
    cin >> T;
	while(T--){
        int n,k;
		cin >> n >> k;
		int vis[maxn];
        vector <int> vec;
        for(int i=0;i<=n+1;i++){
            vis[i]=0;
        }
		if(k>(n/2)){
			cout << "No" << endl;
			continue;
		}else{
            cout << "Yes" << endl;
        }
		for(int i=1;i<=k;i++){
            int ans=i;
			if(vis[i]!=1){
				while(1){
					vec.push_back(ans);
					vis[ans]=1;
					ans=ans*2;
                    if(ans>k){
                        break;
                    }
				}
				vec.push_back(ans);
				vis[ans]=1;
			}
		}
		for(int i=k+1;i<=n;i++){
            if(!vis[i]){
                vec.push_back(i);
            }
        }	
        for(int i=0;i<vec.size();i++){
            cout << vec[i] << " ";
        }
        cout << endl;
	}
	return 0;
} 
```
## 提示
因为 $T$ 的范围太大，做了 $T$ 遍 ```memset```，复杂度会达到 $O(\max n)$，应手动将 $vis$ 标记数组归零。



---

## 作者：Xy_top (赞：5)

本蒟蒻的垃圾做法：

先特判 $2\times k > n$，因为大于 $\frac{n}{2}$ 的整数不可能成为最大公约数啦。（因为 $1$ 到 $n$ 中是它的倍数的就一个。）

然后就很简单了，对于每个 $i$ 在 $1$ 到 $k$ 之间，把数字 $i$ 和数字 $2\times i$ 连一条边，最后跑一遍 DFS 就结束了。

关于这种做法的正确性，楼下的大佬已经讲的很清楚了就不再赘述。

用了前向星，贼长：

```cpp
#include <vector>
#include <iostream>
using namespace std;
int T, n, k, tim = 1;
int cnt;
int vis[300005];
int pre[300005];
struct Edge {
	int from, to, next;
}a[300005];
void dfs (int x) {
	vis[x] = tim;
	printf ("%d ", x);
	for (int i = pre[x]; i; i = a[i].next)
		if (vis[a[i].to] != tim) dfs (a[i].to);
}
void add (int x, int y) {
	cnt ++;
	a[cnt].from = x;
	a[cnt].to = y;
	a[cnt].next = pre[x];
	pre[x] = cnt;
}
int main () {
	T = read ();
	while (T --) {
		cnt = 0;
		n = read (); k = read ();
		for (int i = 1; i <= n; i ++) pre[i] = 0;
		if (k > n / 2) {
			printf ("No\n");
			continue;
		}
		printf ("Yes\n");
		for (int i = 1; i <= k; i ++) add (i, i * 2);
		for (int i = 1; i <= n; i ++) if (vis[i] != tim) dfs (i);
		printf ("\n");
		tim += 2;
	}
	return 0;
}
```

---

## 作者：_mi_ka_ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9345)

众所周知一篇题解需要一个头图。

![](https://cdn.luogu.com.cn/upload/image_hosting/iyc200et.png)

## 题目大意

构造一个仅由 $1\sim n$ 组成的长度为 $n$ 的排列，使得相邻两项的 $\gcd$ 有 $k$ **种不同的数（乡愁度）**。

## 解题思路

**前置知识**：如果两个数有倍数关系，那么这两个数的 $\gcd$ 是那个较小的数，即 $\gcd(x,kx)=x$（$k$、$x$ 均为整数）。

首先考虑最大的 $\gcd$ 的种类（乡愁度）有多少种：

一个每相邻两项之间都有倍数关系的长度为 $i$ 的排列它的乡愁度贡献为 $i-1$（每相邻两项之间都是一个新的 $\gcd$），那么我们考虑将 $1\sim n$ 的排列分成若干个这种排列，设这个倍数关系为 $k$ 倍，则可知从 $1$ 开始排列的那个排列最长，其他排列成比例减少，这个最长排列为：

$$1,k,k^2,k^3,k^4 \dots $$

一直到 $k^i>n$ 时排列终止，排列长度为 $\left \lfloor \log _k n \right \rfloor +1$。

由此可知当且仅当 $k=2$ 时排列最长，此时 $1\sim n$ 分成的排列也最少，答案也就会越大。

此时从小到大每次选取没被排列过的数为首每次 $\times 2$，得到的排列即为乡愁度最大的排列，如果这个排列的乡愁度为 $ans$，那么当 $k>ans$ 时无解。

考虑 $k<ans$ 的情况：

当按照如上方式从 $1\sim n$ 中取出排列并记录此时答案，当此时答案达到 $k$ 时把剩下的数从小到大排列，每两个数之间的 $\gcd$ 一定为 $1$，证明如下：

1. 当取第一个（首项为 $1$，公比为 $2$）排列之前，剩余的数均相邻，由 $\gcd(i,i+1)=1$ 得，剩下的数相邻两项的 $\gcd$ 一定为 $1$；

2. 当取第一个（首项为 $1$，公比为 $2$）排列之后，剩余的数均为奇数，剩余的相邻两项之间差值为若干个 $2$，且后一个数不会是前一个数的倍数（前一个数最小为 $3$，它和它的最近倍数 $9$  之间存在质数，而质数只能当排列的第一个数，此时前一个数已经被取走，不会是剩余的数），则相邻两项的 $\gcd$ 也是 $1$。

则将剩下的数从小到大排列输出不会对答案产生影响，所以当答案达到 $k$ 时结束并将剩余的数输出就能保证答案为 $k$。

## AC Code

防止作弊只放主函数：

```cpp
signed main()
{
	T=re();
	while(T--)
	{
		n=re(),k=re(),ans=0;
		for(int i=1;i<=n;i++)//初始化好习惯 
			vis[i]=0;//vis数组存这个数在没在排列中出现过 
		for(int i=1;i<=n;i++)//先求最大ans 
		{
			if(!vis[i])
			{
				for(int temp=i;temp<=n;temp*=2)
					vis[temp]=1,ans+=(temp!=i);
			}
		}
		if(k>ans)//判断无解情况 
			puts("No");
		else
		{
			ans=0;
			for(int i=1;i<=n;i++)//初始化好习惯*2 
				vis[i]=0;
			puts("Yes");
			for(int i=1;i<=n;i++)
			{
				if(!vis[i])
				{
					if(ans==k)//按照那个方法排列直到ans=k 
						break;
					for(int temp=i;temp<=n;temp*=2)
					{
						wr(temp),putchar(' '),vis[temp]=1,ans+=(temp!=i);
						if(ans==k)
							break;
					}
				}
			}
			for(int i=1;i<=n;i++)//将剩下的数从小到大输出 
				if(!vis[i])
					wr(i),putchar(' ');
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：_Haoomff_ (赞：3)

如果 $2k>n$，无解。

在未超过 $n$ 的情况下，数列从 $1$ 开始取，每次增加 $2$ 倍取。然后取下一个没有被取到过的数，也是每次增加 $2$ 倍着取，直到一个数也没有剩下，即 $k$ 个数被取完。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,a[300005];
bool flag[300005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	for(;t--;){
		memset(flag,false,sizeof(flag));
		int n,k;
		cin>>n>>k;
		if(k>n/2)cout<<"NO\n";
		else{
			cout<<"YES\n";
			int i=1,j=1;
			while(i<=n){
				while(flag[j])++j;
				a[i]=j;++i;flag[j]=true;
				if(i>n)break;
				int l=j*2;
				while(i<=n&&l<=n&&k){
					flag[l]=true;
					a[i++]=l;
					--k;
					l<<=1;
				}
			}
			for(int i=1;i<=n;++i)cout<<a[i]<<" ";
			cout<<"\n";
		}
		
	}
	return 0;
}
```

---

## 作者：fuxuantong123 (赞：2)

# P9345 夕阳西下几时回 题解
## 思路
首先当 $k \gt  \lfloor\dfrac{n}{2}\rfloor$ 时一定无解。因为

>**$b$ 中不同的元素最多有 $\lfloor\dfrac{n}{2}\rfloor$ 个。**

证明：对于任意 $a_i$，$a_j$ 他们的最大公因数最大为 $\lfloor\dfrac{n}{2}\rfloor$，否则一定不满足 $\forall a_i \in[1,n]$。（题目中说了，$1 \leq a_i \leq n$）。




要构造 $k$ 个不同的最大公因数，我们可以先从构造 $\lfloor\dfrac{n}{2}\rfloor$ 个不同的最大公因数思考。





### 构造 $\lfloor\dfrac{n}{2}\rfloor$ 个不同的最大公因数：

------------


一个简单的贪心：

> **尽可能的使所有数都作出贡献，序列的价值才是最大的。**

对于每个 $a_i$，要使其对答案做出贡献，则 $a_{i+1}$ 应是 $a_i$ 的倍数。

所以，可以先升序枚举 $a_i$，判断 $a_i \times 2$ 是否在 $1$ 到 $n$ 的范围以内。如果在，将其排在 $a_i$ 之后，即为 $a_{i+1}$。

重复此操作直到无法继续进行。此时，选择剩余能选择的数中最小的数排在 $a_i$ 后。


------------


此题只需要 $k$ 个不同的最大公因数，所以我们只需要操作到 $k\times 2$ 就可以了。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[300010];
int mp[300010];
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		int n,k;
		scanf("%d%d",&n,&k);
		for(int i=1;i<=n;i++){
			mp[i]=0;
		}
		if(k>(n/2)){
			printf("No\n");
			continue;
		}
		printf("Yes\n");
		a[1]=1;
		int cnt=1;
		for(int i=2;i<=n;i++){
			int sum=i;
			if(mp[sum]==0){
				a[++cnt]=sum;
				mp[sum]=1;
				sum*=2;
				while(sum<=k*2){
					a[++cnt]=sum;
					mp[sum]=1;
					sum*=2;
				}
			} 
		}
		for(int i=1;i<=cnt;i++){
			printf("%d ",a[i]);
		}
		printf("\n");
	}
return 0;
}
```

---

## 作者：Hoks (赞：2)

## 前言
[传送门](https://www.luogu.com.cn/blog/Hok/p9345-xie-ti-bao-gao)，个人博客内使用更佳哦！[题目链接](https://www.luogu.com.cn/problem/P9345)

------------
## 题意
给定 $n$ 个数，求一种首尾相连的排列使得相邻两个数的最大公约数的不同种类有 $k$ 种。

------------
## 思路分析
首先我们可以知道最多有多少种最大公约数，如果一个位置上的数为 $i$ 并且它与另一个数的最大公约数为 $i$，那么那个数最小为 $2i$ 所以最多能有 $\lfloor \frac{n}{2} \rfloor$ 种不同的最大公约数。即在每一组 $n$，$k$ 输入时判断若 $k>\lfloor \frac{n}{2} \rfloor$ 就直接输出 no。

然后若想要最多的最大公约数，对于每一个 $i$ 后面就应该放上 $2i$ ，接着把 $2i$ 看成 $i$ 直到 $2i>n$ 再回到开头的 $i$ 处向下走。为了防止先前访问过的 $i$ 重复出现，使用一个数组以记录是否出现，若出现就继续向下。

这样就得出了最多的最大公约数的方法，那怎么得出 $k$ 种最大公约数呢？

只需要再加入一个记录不同最大公约数的个数的变量即可，到达 $k$ 种即退出。

那剩下的数怎么办呢？

直接按顺序输出即可。（下面给出证明）

------------
## 证明
首先，设最后枚举到的数为 $i$，由题意可得，$i$ 后面的奇数全部都还在，如果是两个奇数的话是肯定互质的，而后面所存在的偶数肯定是与奇数连续在一起的（因为奇数都还在捏），而连续的数肯定互质啊，所以按顺序排下来后的数字的最大公约数都为 $1$，而早在处理的最开始的 $1,2$ 就已经有过最大公约数 $1$ 了，所以后面并未产生任何一个新的最大公约数。

------------
## 代码
所有的准备工作都结束了，就可以开始愉快的上代码环节了！（开心捏）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int n,k;
int read()
{
  char c=getchar();int x=0,f=1;
  while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
  while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
  return x*f;
}
signed main()
{
  t=read();
  while(t--)
  {
    n=read(),k=read();
    map<int,int>mp;mp[1]=1;//这里使用map不用每次手动清空（就是慢了一点）
    if(n<k*2){printf("no\n");continue;}
    printf("yes\n1 ");
    int cs=1;
    for(int i=2;cs!=k;i++)
    {
      if(mp[i]) continue;
      int j=i;printf("%lld ",i);mp[i]=1;
      while(j*2<=n&&cs!=k)
      {
        j*=2;mp[j]=1;cs++;
        printf("%lld ",j);
        }
     }
     for(int i=1;i<=n;i++)
       if(!mp[i]) printf("%lld ",i);
     puts("");
  }
  return 0;
}
```

完结撒花(*^▽^*)！！！

---

## 作者：SXqwq (赞：2)

## Analysis

结论题。

首先一个结论，**$b$ 数组中最多有 $\lfloor\frac{n}{2}\rfloor$ 个不同的数字**。

证明：显然对于 $\forall a_i,\forall a_j$ 最大公约数最大为 $\lfloor\frac{n}{2}\rfloor$ 。如果最大公约数超过 $\lfloor\frac{n}{2}\rfloor$ 则一定不满足 $\forall a_i \in[1,n]$ 。得证。

那么第一问就解决了，判断是否 $k\leq \lfloor\frac{n}{2}\rfloor$ 即可。

接下来如何构造呢？

我们先忽略有 $k$ 个不同的数字，考虑如何最大化也就是有 $\lfloor\frac{n}{2}\rfloor$ 个不同数字的时候如何构造。

由于 $\gcd$ 是取相邻的两数，我们肯定要尽可能的使一个数和她的倍数相邻。举个例子，如果 $n=6$ 则 $1,2,4,3,6$ 这样的构造方式显然是最优的。

到这里我们已经有了一个初步的思路，那么如何去重呢？也就是构造的时候不能出现重复的数字。

这很简单，我们可以先跑一遍 $2$ 的整次幂，然后再枚举奇数的倍数进行构造。显然奇数的倍数一定不是 $2$ 的整次幂。这样我们就实现了去重。

那么从奇数开始不断 $\times 2$ 有没有可能重复呢？

显然不会。因为一个数字（除了刚开始的奇数）一定是由上一个数字数字 $\times 2$ 扩散来的，而同理上一个数字一定是由上一个数字 $\times 2$ 得到的，以此类推。容易发现一个数字可以被哪个奇数扩散到是唯一的。所以不会重复。

其实到这里我们就已经可以解决 CF 的问题了：[CF1858C](https://codeforces.com/contest/1858/problem/C)。

------------------------------------------------------------------
接下来考虑构造 $k$ 个不同的数字。

构造 $k$ 个不同的数字我们只需要操作到 $k\times 2$ 就可以了。至于在区间 $[k\times 2+1,n]$ ，直接相邻构造即可，因为相邻数字的 $\gcd=1$ ，不会影响答案。

至此，本题得解，代码如下。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
int main()
{
	cin>>T;
    while(T--)
    {
        int n,k;
        scanf("%d%d",&n,&k);
        if(k > n/2) 
        {
            cout<<"No"<<endl;
            continue;
        }
        cout<<"Yes"<<endl;
        cout<<"1 ";
        for(int i=n;i>=2*k+1;i--) cout<<i<<" "; //多余部分直接输出
        for(int i=2;i<=2*k;i*=2) cout<<i<<" "; //构造2的整次幂
        for(int i=3;i<=2*k;i+=2) //奇数构造
        {
            for(int j=i;j<=2*k;j*=2) cout<<j<<" ";
        }
        cout<<endl;
    }
	return 0;
}

```

---

## 作者：coding_goat (赞：1)

好有诗意的题目背景啊 qwq。

在区间 $[1,n]$ 之间任意两个数的 $\gcd$ 最大值为 $\left \lfloor \frac{n}{2} \right \rfloor $，此时两个数分别为 $\left \lfloor \frac{n}{2} \right \rfloor , 2 \times \left \lfloor  \frac n 2 \right \rfloor $。我们可以枚举 $i$，那么使得 $\gcd(i,x) = i$ 的 $x$ 的最小正整数为 $2\times i$。那么我们就可以得知 $k \le \left \lfloor \frac  n2 \right \rfloor $ 时有解。

然后我们枚举 $i$，将所有的 $i,2\times i,2^{2} \times i, 2^3 \times i , \dots$ 放置在一起，他们的 $\gcd$ 依次为 $i,2\times i,2^2 \times i ,\dots$，我们只要保证他们的 $\gcd \le k$，就得到了符合题目要求的构造。多出来的数我们直接按顺序放入数组即可，因为 $\gcd(i,i+1) = 1$，不会影响数量。

代码见下：

```cpp
/*
返せ！返せ！ボクの家族を
悪の手から未来の欠片を取返す
ボクの使命だ　この身の全てが滅びようとも
返せ！返せ！ボクの家族を
0419　必ず見
また幸せな温もりをこの鉄の肌で感じたい
*/
#include<bits/stdc++.h>
#define ll long long
#define mem(a,b) memset((a),(b),sizeof(a))
#define lb(x) ((x)&-(x))
#define lc(x) ((x)<<1)
#define rc(x) (((x)<<1)|1)
#define pb(G,x) (G).push_back((x))
using namespace std;
inline int read()
{
	int xx=0;int f=1;
	char c = getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f = -1;
		c = getchar();
	}
	while(c>='0'&&c<='9')
	{
		xx = (xx<<1)+(xx<<3)+(c^48);
		c = getchar();
	}
	return xx*f;
}
#define maxn 200050

int n,k;

bool vis[maxn];

int a[maxn],top;

void work()
{
	mem(vis,0);
	n=read(),k=read();
	if(k>(n/2))
	{
		cout<< "No\n";
		return ;
	}
	top=0;
	for(int i=1;i<=n;i++)
	{
		int x=i;
		if(!vis[x])
		{
			a[++top]=x,vis[x]=1;
			while(x<=k)
			{
				a[++top]=(x<<=1);
				vis[x]=1;
			}
		}
	}
	for(int i=1;i<=n;i++)
		if(!vis[i])
			a[++top]=i;
	cout<<"Yes\n";
	for(int i=1;i<=n;i++)
		cout<<a[i]<<' ';
	puts("");
}

signed main()
{
	int _=read();
	while(_--) work();
	return 0;
}
```

---

## 作者：Moon_Wind (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9345)


------------

**题意简述：**

定义一个排列的**乡愁度**为：

+ 对于所有 $1\le i\le n$，记 $b_i=\gcd(a_i,a_{i+1})$，特别的，$a_{n+1}=a_1$。
+ 排列 $a$ 的乡愁度为序列 $b$ 中**不同**元素的个数。

给出 $k,n$，求是否有一个长度为 $n$，乡愁度为 $k$ 的排列 $p$。若有解，请输出**任意一个**排列。

**算法分析：**

构造题。

很明显，$k$ 的最大值是 $\left\lfloor\dfrac{n}{2}\right\rfloor$。那么，当 $2\times k>n$ 时，**无解**。

考虑 $k\times 2=n$ 时如何构造。我们可以对于每个数 $i$，将其与它的 $2$ 倍连边，可以得到：

$$(2^0,2^1...2^k)(3\times2^0,3\times2^1...3\times2^k)...$$

通过这样的构造，就可以取到理论上可以取到的**所有的值**。

如果 $k\times2>n$ 我们可以按**从大到小**的顺序输出 $n$ 到 $k\times2$ 的所有数，这样就取消了 $n$ 到 $k\times2$ 数的影响。

**代码部分：**


------------
```
#include<bits/stdc++.h>
using namespace std;
int n,T,k;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>T;
    while(T--){//多测。
        cin>>n>>k;
        if(k*2>n){
	    cout<<"No"<<endl;//无解。
    	    continue;
	}
	else{
    	 cout<<"Yes"<<endl;
       cout<<1<<' ';
	    for(int i=n;i>k*2;i--) 
	        cout<<i<<' ';
	    for(int i=2;i<=2*k;i*=2)
	       	cout<<i<<' '; 
	    for(int i=3;i<=2*k;i+=2)
		     for(int j=i;j<=2*k;j*=2)
              cout<<j<<' ';
		cout<<endl;//记得换行。
	 }
    }
    return 0;
} 
```


---

## 作者：Link_Cut_Y (赞：1)

在本文中，**公约数数组** 就是 $\forall i, 1 \le i \le n$ 时 $(a_i, a_i + 1)$ 的值去重后组成的数组。

首先，对于 $k > \lfloor \dfrac{n}{2} \rfloor$ 的情况肯定无解。~~为了避免文章因为没有证明被打回~~，这里给个证明：利用鸽巢原理，$\le \lfloor \dfrac{n}{2} \rfloor$ 的正整数只有 $\lfloor \dfrac{n}{2} \rfloor$ 个。那么将 $k > \lfloor \dfrac{n}{2} \rfloor$ 个最大公因数放在这些抽屉里，肯定没有方案。

然后考虑构造。显然，只要解决了极大的构造方案，极小的方案也可以解决。

首先，如果使得 $k = \lfloor \dfrac{n}{2} \rfloor$ 有解，则对于 $\forall i \le \lfloor \dfrac{n}{2} \rfloor$，都需要在 **公约数数组** 内出现一次，而对于 $i > \lfloor \dfrac{n}{2} \rfloor$ 的值都没有用。所以考虑这样执行程序：

1. 找到最小的没有计入答案的数作为初始值。

2. 将这个数不停地乘 $2$，直到它大于 $n$。将过程中得到的一切值计入答案。

3. 如果你不知道接下来干什么，请从第一条重读一遍。

这样，我们就可以得到这样的一个排列：

$$1, 2, 4 \cdots 3, 6, 12 \cdots 5, 10, 20 \cdots$$

下面是一个个人认为非常严谨的数学化证明：


------------

首先，对于 $k > \lfloor \dfrac{n}{2} \rfloor$ 的情况一定无解。这在上面已经给出了证明。

对于上面给出的极大构造，可以这样证明其正确性：首先看一下构造方案，每次选定一个数 $i$，将它不停乘 $2$，知道它大于 $n$。称这个过程中涉及的所有数组成的数链称为 $f_i$，$f_i$ 的大小为 $|f_i|$。那么，对于极大构造来说，每个奇数 $i$ 都会作为数链开头一次。这是因为如果一个数为偶数，其一定可以写成一个奇数乘以二的整数次幂的形式，即为 $2 ^ k p$ 的形式。而这个数一定在数链 $p$ 中。

用上述构造方案，每条数链中，对 **公约数数组** 的答案贡献为数链长度减一， $\left \lfloor \log_2{\lfloor \dfrac{n}{k} \rfloor} \right \rfloor$，其中 $k$ 为数链开头。

因此，原问题转化为如下命题：对于任意大于 $1$ 的正整数 $n$，证明：

$$\sum \limits_{k = 0}^{ \lfloor \frac{n - 1}{2} \rfloor} \left \lfloor \log_2{\lfloor \dfrac{n}{2k + 1} \rfloor} \right \rfloor = \left \lfloor \frac{n}{2} \right \rfloor$$

原式左边等于 $\sum\limits_{(2k + 1)2^i \le n}^{} 1$，也就是 $\le n$ 的偶数个数。所以答案就是 $\lfloor \dfrac{n}{2} \rfloor$。

证毕。


------------


下面是喜闻乐见的代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>

using namespace std;

const int N = 300010;
vector<int> ans;
bool st[N];
int T, n, k;
int main() {
	scanf("%d", &T);
	while (T -- ) {
		memset(st, false, sizeof st);
		ans.clear();
		scanf("%d%d", &n, &k);
		if (k > (n >> 1)) { puts("No"); continue; }
		int now = 1;
		while (114514) {
			while (st[now]) now ++ ;
			ans.emplace_back(now), st[now] = true;
			if (ans.size() >= n) break;
			int p = now << 1; 
			while (p <= n and ans.size() < n and k) 
			    k -- , st[p] = true, ans.emplace_back(p), p <<= 1;
		} puts("Yes");
		for (auto i : ans) printf("%d ", i); puts("");
	}
	return 0;
}
```

代码里有一部分需要解释一下：如果 $k < \lfloor \dfrac{n}{2} \rfloor$ 的话，把没有用过的数直接放到后面就好了。

---

## 作者：masonpop (赞：1)

这是一道数论构造题。

首先，这个种类数的理论上限是 $\lfloor\frac{n}{2}\rfloor$。因为 $n$ 以内两个不同数的最大公约数最大也就这么多。因此，只要 $k>\lfloor\frac{n}{2}\rfloor$ 就可以报告无解了。

考虑能不能取到这个理论上限。稍加思考可以发现一种可能的基于倍数的巧妙的构造方式：对于每个 $i$，将其与 $2i(1\leq 2i\leq n)$ 连边。再将这些链摆在一起：

$(1,2,4,8,..,2^k),(3,6,12,..,3\times 2^k),(5,10,20,..,5\times 2^k)...$

容易验证，由于每个数和它的倍数是挨在一起的，因此，它能取到理论中所有可行值。

那如果 $n>2k$ 呢？我们可以考虑消除 $2k+1$ 到 $n$ 这些数的影响。这个也很简单，注意到，$\gcd(x,x+1)=1$，因此可以把 $2k+1$ 到 $n$ 倒序排列，再塞到 $1$ 的后面，同时把 $2,4,..,2^k$ 单独一组。可以发现，这样就相当于消除了多出来的数的影响。

时间复杂度 $O(\sum n)$。代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,k;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&k);
		if(k>n/2)
		{
			puts("No");
			continue;
		}
		puts("Yes");
		printf("1 ");
		for(int i=n;i>=2*k+1;i--)printf("%d ",i);//输出多余的
		for(int i=2;i<=2*k;i*=2)printf("%d ",i);//第一组
		for(int i=3;i<=2*k;i+=2)//奇数 
		{
			for(int j=i;j<=2*k;j*=2)printf("%d ",j);
		} 
		puts("");
	}
	return 0;
}
```


---

## 作者：King_duck (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9345)

讲讲我的思路，先特判 $2×k>n$，因为大于 $n/2$ 的整数不可能成为最大公约数。（因为 $1$ 到 $n$ 中是它的倍数的就一个。）

接着就很简单了，对于每个 $i$ 在 $1$ 到 $k$ 之间，把 $i$ 和 $2×i$ 连一条边，最后一遍 DFS 就结束了。

直接上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int T,n,k,tim = 1;
int cnt;
int v[N];
int p[N];
struct e{
	int from, to, next;
}a[N];
void dfs(int x)
{
	v[x]=tim;
	cout<<x
	for(int i=p[x];i;i=a[i].next)
	{
		if(v[a[i].to]!=tim) 
		{
			dfs(a[i].to);
		}		
	}
}
void a(int x,int y) 
{
	cnt++;
	a[cnt].from=x;
	a[cnt].to=y;
	a[cnt].next=p[x];
	p[x]=cnt;
}
int main() 
{
	T=read();
	while(T--) 
	{
		cnt = 0;
		n=read();
		k=read ();
		for(int i=1;i<=n;i++) 
		{
			p[i]=0;
		}
		if (k > n / 2) 
		{
			cout<<"No"<<endl;
			continue;
		}
		cout<<"Yes"<<endl;
		for(int i=1;i<=k;i++) 
		{
			a(i,i*2);
		}
		for(int i=1;i<=n;i++) 
		{
			if(v[i]!=tim) 
			{
				dfs(i);
			}
		}
		cout<<endl;
		tim+=2;
	}
	return 0;
}
```

---

## 作者：_Weslie_ (赞：0)

有一定思维含量的思维题（蒟蒻想了 $20$ 分钟）。

至少这个难度评的比较正确。

## 思路

显然的在前 $n$ 个数中理论上最大的公约数只会是 $\lfloor\dfrac{n}{2}\rfloor$，因此 $k$ 的理论上界即为 $\lfloor\dfrac{n}{2}\rfloor$。

考虑对于 $k\le \lfloor\dfrac{n}{2}\rfloor$ 的情况。

显然 $(a,2a)=a$，考虑对于前 $n$ 个数，将其分成 $(1,2)(2,4)(3,6)\dots$ 的形式。

然而，这样的序列会有重复，例如：$1,2,2,\color{red}4,\color{black}3,6,\color{red}4\color{black},8,5,10,\dots$

考虑将 $(a,2a,2^2a,2^3a,\dots)$ 拼成一组，即 $1,2,4,8,16,32,64,\dots,3,6,9,12,\dots$，其中 $a$ 为奇数或 $2$。

然而这样可能会超 $k$ 的限制，怎么办呢？

考虑 $b$ 序列，在上面这种情况下一定出现 $1,2,4,8,\dots,k,\dots,1$。

而前 $2k$ 个数可以产生 $k$ 个最大公约数，因此，我们把 $[2k+1,n]$ 区间内的数全部**倒序**排列在 $1$ 的后面，即 $1,n,n-1,\dots,2k+1,2,4,8,\dots$。

因为 $2k+1$ 一定为奇数，不会和 $2$ 产生最大公约数。

所以这道题就解完了，代码如下。

```
#include<bits/stdc++.h>
using namespace std;
int T,n,k,a[300005];
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		if(k>n/2){
			printf("No\n");
			continue;
		}
		cout<<"Yes\n1 ";
		for(int i=n;i>=2*k+1;i--)cout<<i<<' ';
		for(int i=1;i<=2*k;i+=2){
			for(int j=max(2,i);j<=k*2;j*=2)cout<<j<<' ';
		}
		cout<<endl;
	}
}
```

---

## 作者：Ferdina_zcjb (赞：0)

这道题非常的考验个人的数学能力

首先第一个暴力的想法是将 $1 \sim n$ 做一个全排列，在每一次全排列中找到符合题目要求的那一种情况，进行输出。如果没有符合题目的情况则不能构造出来。

这样明显时间过于慢了，那如何~~优化呢~~思考呢？显然，这是一道构造题，那就需要一些数学知识的支撑。

## NO.1 - 如何判断不能构造

方法：如果 $k > \lfloor{\displaystyle \frac{n}{2}}\rfloor$，那么就不能构造出排列 $p$。

因为，从 $1 \sim n$ 中，$\forall \gcd(a|a \in [1,n],b|b \in [1,n]) \le \lfloor \frac{n}{2} \rfloor \ (a \ne b,a \in \mathbb{Z}^+,b \in \mathbb Z^+)$。

## NO.2 - 如何构造

方法：当 $k = 1$ 时，将 $1\sim n$ 顺序排列即是合法序列。若 $k \ne 1$ 的构造也非常简单，只需从 $1$ 开始一直 $\times2$ 直至 $1\times2^{m+1} > n$ （每计算出一个数，就应该进行记录），在从 $1 \sim n$ 找到没被记录的数（假设为 $e$）并在次一直 $\times2$，也是直至 $e\times2^{m+1} > n$，每乘一次就会增加一个乡愁度，直到乡愁度为 $k$。

以上操作，每乘一次的结果应该放入记录数组的末尾，从而构造合法排列 $p$。

（以上 $m$ 为 $\times 2$ 的次数）

以下为代码，配备详细注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,vis[600005];
int n,k,a[600005],cnt = 0,tmp = 0;//tmp用于实现动态数组，也可用vector。cnt用来计当前乡愁度。
bool ioi = false;
inline void read(int &a){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
          w=-1;     
        }
        ch=getchar();
     }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-48;
        ch=getchar();
    }
  	 a=s*w;
}
inline void put_(int x){
    if(x<0){
    	putchar('-');
		x=-x;
	}
    if(x>9)put_(x/10);
    putchar(x%10+48);
}
signed main(){
	read(T);
	while(T--){
		read(n);
		read(k);
		if(k<<1 > n)printf("No\n");//k*2 > n的话，不存在合法序列。
		else if(k == 1){//当k = 1将 1～n 顺序排列。
			printf("Yes\n");
			for(int i = 1;i <= n;++i){
				put_(i);
				printf(" ");
			}
			printf("\n");
		}else{
			printf("Yes\n");
			for(int i = 1;i <= n;++i){
			    if(!vis[i]){//i是否被装在a数组中。
                    if(cnt == k)break;//当前乡愁度为k，已经拥有合法序列。
			        vis[i] = 1;//记录
			        a[++tmp] = i;//放入
			        for(int j = i*2;j <= n;j *= 2){//从当前数*2,始终保持j <= n。
			            cnt++;//增加乡愁度。
			            a[++tmp] = j;//放入。
			            vis[j] = 1;//记录。
                        if(cnt == k){//满足乡愁度。
                            ioi = true;
                            break;
                        }
			        }
                    if(ioi)break;//已经存在足够乡愁度。
			    }
			}
			for(int i = 1;i <= n;++i){//放入未放入值。
				if(!vis[i])a[++tmp] = i;
			}
			for(int i = 1;i <= tmp;++i){//输出。
				put_(a[i]);
				printf(" ");
			}
			printf("\n");
		}
		for(int i = 1;i <= n;++i)vis[i] = 0;
		tmp = 0;
		cnt = 0;
        ioi = false;
	}
}
```



---

## 作者：Leonid (赞：0)

显然 $2\times k>n$ 无解。

通过上面的式子注意到让序列 $b$ 中有 $a_i$ 可以令 $a_{i+1}=2\times a_i$。据此我们让序列 $b$ 中有 $1 \sim k$ 中的每个数字就好了。

暴力求解即可。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define M 300005
#define ll long long
#define mod 998244353
#define inf 1e18

int T;
int n,k;
int ans[M];
bool ok[M];

int main(){
	scanf("%d",&T);
	while(T--){
		
		scanf("%d %d",&n,&k);
		for(int i=1;i<=n;++i) ok[i]=0;
		if(k*2>n){
			printf("No\n");
			continue;
		}
		
		printf("Yes\n");
		
		for(int i=1;i<=k;++i){
			if(!ok[i]){
				int now=i;
				while(now<=k){
					printf("%d ",now);
					ok[now]=1;
					now*=2;
				}
				printf("%d ",now);
				ok[now]=1;
			}
		}
		for(int i=k+1;i<=n;++i)
			if(!ok[i])  printf("%d ",i);
		printf("\n");
	}
	return 0;
} 
```


---

## 作者：Untitled10032 (赞：0)

## 题意

构造一个由 $1 \sim n$ 的排列组成的环，使得环上所有相邻元素的最大公约数组成的（不可重）集合中，有 $k$ 个元素。

## 思路

构造数列：由一个给定数开始，第 $i$ 项（$i > 1$）是第 $i - 1$ 项的两倍（$x, 2x, 4x, 8x, 16x ...$），易得长度为 $n$ 的这样的数列，共可以贡献 $n - 1$ 个两两不同的最大公约数。

这样的数列第 $i$ 项与第 $i + 1$ 项的最小公倍数为 $i$，且设第一项为 $a$，则每一项都可以表示成 $a \times 2^n$ 的形式，$a$ 不同（且不互为倍数），则由它开头的两个序列中元素两两不同，贡献的最大公因数两两不同。

那么我们可以将许多这样的数列拼起来组成答案。

具体操作是：
- 先把 $1$ 放进排列里。
- 从 $2$ 开始，生成以 $2$ 开头的，下一项为上一项的两倍的数列，直至下一个数将要大于 $n$，将其放入答案排列中，对于数列的每一个数，标记其已被使用。
- 从小到大寻找下一个未被使用的数，之后生成以它开头的相应的数列，放入答案排列，将其中的元素标记已使用。
- 循环进行寻找、生成、标记的操作，直到序列中有 $k$ 个互不相同的最大公因数或当前考虑的数已经为 $n$。
- 如果成功构造了满足要求的数列，那么把得到的答案数列输出，之后从小到大枚举 $1 \sim n$，把所有未使用的数按顺序输出。
- 如果未构造出满足要求的数列，那么无解。

## 证明

### 为什么这样处理，最后的那些未被使用的数从小到大输出不会形成新的最大公约数？

考虑“从小到大寻找下一个未被使用的数”的过程，易得找到的一定是下一个奇数，所有偶数都已经被包含在之前的数列中，而未被当做（后一项是前一项两倍的）数列开始元素的奇数一定没有被使用过。如果生成一半时，因已经满足了最大公因数个数要求而停止，那么会剩下一些未使用的偶数，而这些偶数一定不会小于最后的数列里的那个奇数，那么这些偶数的前和后必定有与之相邻的奇数，相邻数都互质，相邻奇数都互质，所以不会产生新的最大公约数。

### 为什么这样可以构造出最优解？如何证明没有更优的做法？

首先，给定 $k$、$n$，使此问题有解的必要条件是 $k \leq \frac {n} {2}$。因为 $[\frac {n} {2} + 1, n]$ 之间的数不可能是两个 $[1,n]$ 内的不同的数的 $\operatorname{gcd}$，若 $x > y$，则 $\operatorname{gcd} (x,y)≤ \frac {x} {2}$。而题目中相应的 $x$ 最大可以取到 $n$，那么两个不同的数 $\operatorname{gcd}$ 最大为 $\frac {n} {2}$ ，所以最多有 $\frac {n} {2}$ 个不同的 $\operatorname{gcd}$。

那么为什么这样的做法可以把 $0 \sim \frac {n} {2}$ 的解都构造出来呢？我们观察排列中每个“数列”的特征，若数列长为 $n$，则会产生 $n - 1$ 个新的 $\operatorname{gcd}$，而数列中正好有 $n - 1$ 个偶数，可以看做有几个偶数，就可以产生几个不同的 $\operatorname{gcd}$。因为 $1 \sim n$ 中任何数都可以被表示为一个奇数 $k \times 2 ^ n$ 的形式，所以极端情况下，排列中所有数都被用作生成（后一项是前一项两倍的）数列，而 $1 \sim n$，共有 $\lfloor \frac {n} {2} \rfloor$ 个偶数，也就可以最多生成这么多个不同的 $\operatorname{gcd}$。 

## 代码

```cpp
#include <iostream>
#include <cstring>
#include <vector>

using namespace std;
const int N = 3e5 + 5;
bool a[N];	//标记某数是否使用过的数组
vector<int> ans;	//答案序列

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t;
    cin >> t;
    while (t--) {
        ans.clear();
        int n, k;
        cin >> n >> k;
        int cnt = 0;
        memset(a, 0, (n + 1) * sizeof(bool));
        k--;	//先把 1 作为最大公约数的情况减去
        ans.push_back(1);	//把 1 放在序列开头
        a[1] = true;
        for (int i = 2; i <= n; i++) {
            if (cnt == k)
                    break;
            if (!a[i]) {
                a[i] = true;
                ans.push_back(i);
                for (int j = (i << 1); j <= n; j <<= 1) {
                    a[j] = true;
                    ans.push_back(j);
                    if (++cnt == k)
                        break;
                }
            }
        }
        if (cnt < k) {
            cout << "No\n";
            continue;
        } else
            cout << "Yes\n";
        for (int i : ans)
            cout << i << ' ';
        for (int i = 2; i <= n; i++)
            if (!a[i])
                cout << i << ' ';
        cout << '\n';
    }
    return 0;
}
```


---

## 作者：LEle0309 (赞：0)

和[这题](https://codeforces.com/contest/1858/problem/C)重题了……

[题目传送门](https://www.luogu.com.cn/problem/P9345)

#### 题目大意：

让你构造出一个长度为 $ n $ 的**排列** $ a $，使得排列 $ a $ 满足有 $ k $ 个不同的相邻两项的最大公约数。

#### 题目分析：

首先，当 $ k>\dfrac{n}{2} $ 时一定构造不出来。因为如果 $ k>\dfrac{n}{2} $ 时，则 $ k \times 2>n $，而如果有两个数的最大公约数为 $ k $，则至少有一个数比 $ n $ 大（因为大的数至少是 $ k $ 的 $ 2 $ 倍），具体可以参考[这里](https://www.luogu.com.cn/paste/84hkpjvs)。

然后，我们思考如何构造出一个数列满足条件。我们知道当 $ k \le \dfrac{n}{2} $ 时，我们要尽可能让排列 $ a $ 有 $ k $ 个不同的最大公约数。易得我们把每一个之前没有输出的数的 $ 1,2,4,8,16…… $ 倍输出，直到大于 $ k $，这样就可以把 $ 1 $ 到 $ k $ 每个数都是最大公约数，满足条件。


```cpp
#include<iostream>
using namespace std;
const int maxn=1e6+7;
long long n,i,t,x,vis[maxn],k;//防见祖宗，vis标记数组
int main()
{
	cin>>t;//t组数组
	while(t--)
	{
		cin>>n>>k;
		for(i=1;i<=n;i++)vis[i]=0;//手动清零标记数组
		if(k>n/2)//不可能
		{
		    cout<<"No\n";
		    continue;
		}
		cout<<"Yes\n"; 
		for(i=1;i<=k;i++)
		{
			x=i;
		    if(vis[i])continue;//标记过了
			while(x<=k)//小于等于k的x的2的次方倍
			{
				cout<<x<<' ';//输出
				vis[x]=1;//标记
				x*=2;//乘2
			}
			vis[x]=1;//注意，最后2*x也要算进去，因为gcd(2*x,x)=x，而x是我们排列中合法的最大公约数
			cout<<x<<' ';//输出这个数
		}
		for(i=k+1;i<=n;i++)if(!vis[i])cout<<i<<' ';//大于k的数顺序输出即可
		cout<<endl;//多组数据要换行
	}
	return 0;
}
```

---


# 「CZOI-R5」按位或

## 题目描述

你有一个长度为 $n$ 的序列 $a$，现在你可以进行**至多** $m$ 次操作。每次操作你可以选择 $1 \le i \le n$，将 $a_i$ 变为 $2\times a_i$。求最终序列 $a$ 的**按位或**的最小值，即 $\operatorname{or}_{i=1}^na_i$ 的最小值。

$\operatorname{or}$ 为[按位或运算](https://oi-wiki.org/math/bit/#%E4%B8%8E%E6%88%96%E5%BC%82%E6%88%96)。

## 说明/提示

**【样例解释 #1】**

可以不进行操作。

**【样例解释 #2】**

选择 $i = 1$，$a_1$ 变为 $2 \times 1 = 2$，序列 $a$ 的按位或为 $2$。

**【数据范围】**

**本题采用捆绑测试**。

- Subtask #1（$15\text{ pts}$）：$  n \le 8 $ , $  m \le 8 $ , $  a_i \le 10 ^ 3$。
- Subtask #2（$25\text{ pts}$）：$  n \le 10 ^ 3 $ , $ m \le 10 ^ 4 $ , $ a_i \le 10 ^ 6$。
- Subtask #3（$25\text{ pts}$）：$ n \le 10 ^ 3 $ , $  a_i \le 2\times10 ^ 3$。
- Subtask #4（$35\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$ 1 \le n \le 10 ^ 6 $ , $ 1 \le m \le 10 ^ 6 $ , $ 0 \le a_i \le 10 ^ 9$。

## 样例 #1

### 输入

```
3
5 1 4
1```

### 输出

```
5```

## 样例 #2

### 输入

```
2
1 2
1```

### 输出

```
2```

# 题解

## 作者：lichenxi111 (赞：12)

## 思路

对于二进制，每次 $\times 2$ 操作即为左移一位。

发现对于结果，二进制最高位为 $0$ 一定更优，所以结果的最高位不会高于 $a_{i}$ 的最高位。

那我们可以先求出不进行操作的答案，从最高位开始向低位枚举，如果这一位为 $1$，尝试能否将这一位变为 $0$。

我们发现如果想让这一位变为 $0$，根据按位或，必须让所有数的这一位都为 $0$，且为了让答案更优，不能改变更高位的已经确定的状态。所以枚举每一个数，并计算多少次操作可以让这个数的这一位变为 $0$ 且操作过程中不能改变更高位的状态。最后如果可用操作数足够，那么这一位可以为 $0$，记录答案。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6+100;
int n,m;
int a[N];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
	cin>>n;
	int mx=0;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		mx=max(mx,__lg(a[i]));
	}
	cin>>m;
	int ans=1ll<<mx,tt;
	for(int j=mx-1;j>=0;j--)
	{
		int cnt=0,tmp=1ll<<60;
		tmp--;
		for(int i=0;i<j;i++)tmp^=(1ll<<i);
		for(int i=1;i<=n;i++)
		{
			tt=a[i];
			while((((tt&tmp)|ans)!=ans)&&cnt<=m)
			{
				if(__lg(tt)>mx)cnt=m+1;
				cnt++;
				tt<<=1;
			}
		}
		if(cnt>m)ans|=1ll<<j;
	}
	cout<<ans;
}
```

---

## 作者：_H17_ (赞：10)

## 前言

[lichenxi111](/user/750771) 出的题，必须这个题解。鉴定为全场最好的题。

考场上一开始做法假了，没啥参考价值，不说了（对应提交记录里一堆 $25$ 分，其实一开始注意到是假的了，但是由于骗了 $25$ 分，想看看能多骗多少分所以提交了一大堆，其它数据还挺强的）。

## 题目分析

注意到高位比低位权重大，考虑从高位考虑。

既然直接求不好求，那就考虑判断答案 $x$ 合法的条件（准确来说并不是合法，而是不会让任何一个数与之冲突。冲突定义为：这个数无论怎么操作与 $x$ 按位或之后都不是 $x$）：我们直接每个数都枚举最少移动多少位，然后判断总和是否超过 $m$。

接下来考虑一开始说的贪心，如果有一位（高位），前面都确定好了且这一位可以是 $0$，那就一定让这一位是 $0$。

能不能是 $0$ 怎么判断呢？前面位置定好了，这一位定为 $0$，剩下位置是 $1$ 判断即可。不行的话这一位只能是 $1$。

时间复杂度 $O(n\log^2 V)$，显然卡不满。

差点忘了证明了，一开始我们说的判断 $x$ 并不是严格判断合法。那为什么这个 $x$ 一定合法？考虑假设这个 $x$ 不合法，那说明有一位虽然是 $1$，但是实际情况中所有操作之后的 $a_i$ 这一位都是 $0$。但是这与我们的贪心不符，所以 $x$ 一定合法。

## 代码

```cpp
#include<bits/stdc++.h>
#define ALL(x) x.begin(),x.end() 
#define int long long 
using namespace std;
constexpr int N=1e6+2;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
int n,m,a[N],ans=2147483647,val,res=0x3f3f3f3f3f3f3f3fll;
signed main(){
	cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cin>>m;
    //读入
    for(int i=30,val=0,fl;i>=0;i--){
        ans^=(1<<i);//假定这一位是0
        val=fl=0;
        for(int j=1;j<=n;j++){
            for(int k=0;k<=min(30ll,m);k++){
                if((ans|(a[j]<<k))==ans){
                    val+=k;//统计最小次数
                    break;
                }
                if(k==min(30ll,m)){
                    fl=1;
                    break;//如果怎么着也不能保证这个答案那就返回吧
                }
            }
            if(fl)
                break;//剪枝
        }
        if(fl||val>m)
            ans^=(1<<i);//不行的话搞回来
    }
    cout<<ans;
	return 0;
}
```

---

## 作者：CaiZi (赞：6)

以下“位”均指二进制位，而非十进制位。

首先我们发现，尽量让更高的位为 $0$ 是最优的。因为 $\sum_{i=0}^{p}2^i<2^{p+1}$。然后我们发现，这个 $\times2$ 操作本质就是将某个数的二进制左移一位。

先求出不进行操作的答案，显然答案不会超过这个数，且最高位无法被消除（进行操作会使得数字位数进一步增大），所以这个数的位数已经确定了。

所以考虑从高位到低位枚举，然后由于是按位或，若你想要某一位最终为 $0$，则所有数的这一位均为 $0$，在枚举每一位的基础上枚举每个数单独处理即可。

然后我们枚举对这个数进行多少次操作，且有以下要求：
- 操作后的数不能与前面确定的位冲突（即不能导致某个可以为 $0$ 的高位变为 $1$），因为尽量让更高的位为 $0$ 是最优的。
- 不能超过操作次数。
- 操作后的数不能超过最大位数，否则会使得数字位数进一步增大，显然不优。

这个过程可能有点抽象，具体见代码注释。

时间复杂度 $O((n+m)\log V)$，其中 $V$ 为 $a$ 的值域。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x[1000001],k,a,b,c,s;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i];
		k=max(k,__lg(x[i]));
	}
	cin>>m;
	s=1<<k;
	for(int i=k-1;i>=0;i--){//从高到低枚举每一位
		a=2147483647<<i;//避免考虑到更低的位（a中更低的位都为0）
		b=0;
		for(int j=1;j<=n;j++){
			c=x[j];
			while(((c&a)|s)!=s&&b<=m&&__lg(c)<=k){//三个条件分别对应
				c<<=1;//进行操作
				b++;//操作次数加一
			}
			if(b>m||__lg(c)>k){//不合法
				b=-1;
				break;
			}
		}
		if(b==-1){//该位不能为0
			s+=1<<i;//将答案的该位变为1
		}
	}
	cout<<s;
	return 0;
}
```

---

## 作者：Melo_qwq (赞：4)

感觉是一种比较神秘的做法。

考虑到二进制的贪心性，我们尽量把按位或的较高位变成 $0$。

每次操作等价于把 $a_i$ 二进制左移 $1$，那么发现在所有数中，二进制位最高位最大的那些数一定不动。

接下来的问题是如何判断某一个二进制位是否能让所有的数经过操作后这一位全是 $0$，显然我们只需要处理当前这一位为 $1$ 的数。

如果想把这一位变成 $0$，那么只能通过左移操作去抹掉这个一，那么当前这位上的一左移之后会在哪里呢？不难发现只能在更高的且可以有 $1$ 的二进制位上，这些信息我们是知道的。直接枚举即可。

从高到低去枚举每一位，如果能变成 $0$ 就变，并且减去操作次数，否则把这位标记一下，说明可以有数在这一位上是 $1$。

感觉挺抽象的，看代码可能会好一点。

```cpp
#include <bits/stdc++.h>
#define int long long 
#define f(i ,m ,n ,x) for (int i = (m) ; i <= (n) ; i += (x))

template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ; char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	} while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	} flag ? x = - x : 0 ;
} template < typename T ,typename ...Args >
inline void read ( T &x ,Args &...tmp ) {
	read (x) ,read (tmp...) ;
}

const int N = 1e6 + 7 ;
int n ,m ,a[N] ,b[N] ,lg ; // lg 表示所有数二进制下最高位
bool kp[100] ; // 记录某一个二进制位是否可以存在一

inline bool judge (int x ,int st) {
	f (i ,st ,lg ,1) if ((x & (1ll << i)) && ! kp[i]) return false ;
	return true ; // 第 st 到 lg 位是否合法
}

signed main () { 
	read (n) ;
	f (i ,1 ,n ,1) read (a[i]) ;
	read (m) ;
	std :: sort (a + 1 ,a + n + 1) ;
	lg = 63 - __builtin_clzll (a[n]) ;
	if (a[n] == 0) return puts ("0") ,0 ;

	kp[lg] = true ;
	for (int cur = lg - 1 ; ~ cur ; cur --) {
		memcpy (b ,a ,sizeof b) ; 
		bool flag (0) ;
		f (i ,1 ,n ,1) 
			if ((b[i] & (1ll << lg)) && (b[i] & (1ll << cur))) { flag = true ; break ;} // 如果二进制最高位是 lg 一定是不能操作的
		if (flag) { kp[cur] = true ; continue ;}
		int tot = 0 ;
		f (i ,1 ,n ,1) {
			if (! (b[i] & (1 << cur))) continue ;
			bool cant (0) ;
			f (j ,cur + 1 ,lg ,1) {
				if (! kp[j]) continue ;
                if (63 - __builtin_clzll (b[i] << j - cur) > lg) { cant = true ; break ;} // 如果操作后最高位高于 lg 一定不优
				if (tot + j - cur > m) { cant = true ; break ;}
				if (judge (b[i] << j - cur ,cur)) 
				{ cant = false ; tot += j - cur ; b[i] <<= j - cur ; break ;}
				else cant = true ;
			}
			if (cant) { flag = true ; break ;}
		}
		if (! flag) memcpy (a ,b ,sizeof a) ; // 如果可以就进行操作
		kp[cur] = flag ;
		if (! flag) m -= tot ;
	}
	int ans = 0 ;
	for (int i = lg ; ~ i ; i --) ans += ((int) kp[i] << i) ;
	std :: cout << ans << '\n' ;
	return 0 ; 
}
```

---

## 作者：Reply_ (赞：3)

## 题解：P13565 「CZOI-R5」按位或

观察数据范围，$1 \le n \le 10 ^ 6$ , $1 \le m \le 10 ^ 6$ , $0 \le a_i \le 10 ^ 9$。

对于这种题，可能是贪心或者动规，发现不好设计动规状态，所以我们考虑贪心。

贪心的本质是全局最优，而尽量满足二进制中的高位是必然更优的，所以考虑从高到低按位考虑。

假如枚举到第 $i$ 位，有一些数在第 $i$ 位是 1，我们需要对这些数翻若干倍来避免这一位是 $1$，那该如何判断这样是否更优呢？

记我们从大到小考虑，必须取 $1$ 的位的贡献为 $ans$，第 $i$ 位的贡献最多也就是 $2^i$，如果翻倍后的数和 $ans$ 按位或后比 $ans+2^i$ 还大，那么就是不够优了，如果翻倍次数小于 $m$ 就能避免这一位的贡献。

下面给出注释代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R1 register
#define F(i,a,b) for(int i = (a);i<=(b);i++)
using namespace std;
inline int read(){R1 int x=0,t=1;R1 char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') t=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*t;}
const int N=2e6+10;
int n,m,a[N],f[N];
int ans=0,sum=0;
signed main()
{	
	n=read();
	F(i,1,n) a[i]=read();
	m=read();
	for(int i = 30;i>=0;i--){
		int cnt1=0,fl=0;
		for(int j = 1;j<=n;j++){
			int tmp=a[j],cnt=0;
			if(tmp&(1<<i)){
				while(tmp<=ans && cnt+cnt1+sum<=m && (ans|tmp)-ans>=(1<<i)){//翻倍之后还会使答案增大，继续翻倍
					tmp*=2;
					cnt++;
				}
				if((ans|tmp)-ans<(1<<i)){//贡献小于(1<<i)，暂时加上
					cnt1+=cnt;
				}
				else{
					fl=-1;//没法避免第i位的贡献
				}
			}
		}
		if(cnt1+sum<=m && fl!=-1){//这一位可以不加
			for(int j = 1;j<=n;j++){
				int tmp=a[j],cnt=0;
				if(tmp&(1<<i)){
					while(tmp<=ans && cnt+cnt1+sum<=m && (ans|tmp)-ans>=(1<<i)){
						tmp*=2;
						cnt++;
					}
					a[j]=tmp;//更新a数组
				}
			}
			sum+=cnt1;
		}
		else ans+=(1<<i);//这一位必须加上
	}
	cout << ans << '\n';
	return 0;
}
/*

*/


```

---

## 作者：CRZ_AK_DZG (赞：2)

# 对[出题人题解](https://www.luogu.com.cn/article/og1ev50x)的补充解释：  
注：本文章内容由**少年当立凌云志**团队成员共同讨论得出。
## 问题：
为什么题解代码中的 $cnt$ 可以**每次**初始化为 $0$？
## 答：
1.  无法抵消的高位权上的 $1$ 都维护进了 $ans$。
2.  当考虑到 $2$ 的 $j$ 次方时，实际是尝试将 $ans$ 的 $2$ 的 $j$ 次方上保持 $0$ （贪心思想）。
3.  程序实际上每次重新计算，在保持 $ans$ 不变大的情况下，能否将当前位置保持 $0$ 。如果 $cnt$ 超过 $m$，则说明无法实现（即当前位不可能为 $0$ 或会影响原本维护好的 $ans$）。如果 $cnt$ 不超过 $m$，则说明可以再保持维护好的 $ans$ 的情况下，使当前位置为 $0$。
4.  按上述方法操作，实际上在计算“低位权”时的 $cnt$ 值包含了以前计算“高位权”时的 $cnt$ 值。
5.  这样做的目的是，在保证时间复杂度合格的同时，大大简化了代码编写复杂度，~~虽然也提高了代码理解门槛~~，但仍然非常值得我们区学习。
## 总结：
非常喜欢这个题目，不仅训练了位运算，还让我学到了一种新的代码思路，读懂代码时真的很震撼，~~也可能是我见识太少~~。



### ~~**宁宁世界第一可爱！**~~

---

## 作者：ylch (赞：0)

## Analysis

> 注：下文中“位”有关概念均指在二进制下的位。

遇到位运算求最值问题，一个很套路的办法是找到运算的性质，然后按位贪心。

对于本题，因为位或运算是独立于每一位的，所以我们可以按位贪心，容易发现尽可能保证较高位为 $0$ 会使答案更优。

考虑从高到低枚举每一位。如果我们想让某一位为 $0$，就要让所有数字的这一位都为 $0$，所以我们在枚举每一位同时对于每个数单独处理。

“乘 $2$”这个操作在二进制中，其实就是把数字左移一位。

我们可以通过左移一位把某一位变成 $0$，但为了保证最优化，如果左移会把原来是 $0$ 的高位变成了 $1$（这样会使答案更劣，需优先保证高位），就无法操作了。

> 如何判定？合法条件是会把原来是 $0$ 的高位变成 $1$。假设已记录答案为 $ans$，当前枚举到第 $bit$ 位，当前数**操作后**的值为 $x$。可以考虑先对齐位数，只考虑有效位数（第 $bit$ 及更高位），然后将 $ans$ 与 $x$ 的有效部分进行位或运算，如果前后大小不变，就说明 $x$ 没有不该出现的 $1$，则合法。写成条件代码就是 `((ans>>bit+1)|(x>>bit+1))==(ans>>bit+1)`。

然后思考如何维护操作次数。我们考虑用一个 $cnt$ 数组记录每个数字之前已经被操作的次数，这样我们可以快速知道每个数当前的值就是 `a[i]<<cnt[i]`。只要保证操作后 $\sum cnt_i \le m$ 即可。

同时我们还应确定操作大小的上界，可以发现答案至少为操作前的 $\operatorname{or}_{i=1}^n a_i$，因为乘 $2$ 会使得数字更大，也就是会使得更高位出现新的 $1$。所以操作的最大限度是数字位数不能超过初始时的 $\max_{i=1}^n\{\lfloor \log_2 a_i \rfloor+1\}$。

可以总结出进行操作需要满足的要求：
1. 不能超过操作次数。
2. 不能把原来是 $0$ 的高位变成了 $1$。
3. 位数不能超过初始时的位数最大值。

考虑从高到低枚举位数，按位贪心，并按照上面的条件处理答案即可。

时间复杂度 $O(n \log w)$，$w$ 为值域。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long // 保险起见
using namespace std;
const int maxn = 1e6 + 7;

int n, m, d, a[maxn], cnt[maxn], b[maxn];

void solve()
{
	cin >> n;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		d = max(d, __lg(a[i])); // 记录最大位数（正常来说位数是__lg(a[i])+1，但我们习惯枚举位数从0开始，所以把1减去）
	}
	cin >> m;
	
	int ans = 1 << d; // 记录答案（第d位一定有一个1，就不枚举了）
	for(int bit = d - 1; bit >= 0; bit --){ // 从高位到低位贪心
		int tot = 0; // 本轮总操作次数
		int s = 0; // 之前的总操作次数
		for(int i = 1; i <= n; i ++){
			b[i] = cnt[i]; // 因为不确定能不能行，所以先用cnt的替代数组
			s += cnt[i];
		}
		
		for(int i = 1; i <= n; i ++){
			int x = a[i] << b[i];
			int b_i = b[i]; // 因为不确定能不能行，所以先找一个临时变量表示b[i]
			if(x >> bit & 1){ // 如果这位是1，尝试变成0
				while(tot + s <= m && __lg(x) <= d){
					x <<= 1;
					b_i ++;
					tot ++;
					if(((ans>>bit+1)|(x>>bit+1))==(ans>>bit+1) && !(x >> bit & 1)) break; // 达到要求就退出
				}
				if(tot + s > m || __lg(x) > d){ // 不合法
					tot = 1e9; break;
				}
				b[i] = b_i; // 如看起来可以，就先更新
			}
		}
		
		if(tot == 1e9){ // 该位不能为0
			ans |= (1 << bit); // 把当前答案变为1
		}
		else{
			for(int i = 1; i <= n; i ++) cnt[i] = b[i]; // 如果可行，就进行更新
		}
	}
	cout << ans << '\n';
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

---


# 「CZOI-R5」青蛙的旅行

## 题目背景

小 L 是一只青蛙，他现在准备在 A 城旅行。

## 题目描述

A 城是一个 $n\times m$ 的矩阵。有一个给定的数 $k$。还有一个变量 $w$，初始为 $0$。记 $(r,c)$ 表示第 $r$ 行第 $c$ 列。

这个矩阵中有 $t$ 个特殊点，第 $i$ 个在 $(x_i,y_i)$，类型为 $p_i$（$p_i\in\{1,2\}$），若 $p_i=2$，则有一个额外属性 $s_i$。**保证不存在 $i,j$ 满足 $i\neq j$ 且 $x_i=x_j,y_i=y_j$。**

小 L 初始在 $(1,1)$，它可以做任意次以下跳跃方法之一**直到它到达** $(n,m)$。假设它现在在 $(a,b)$：

- 选择一个 $h$，满足 $0\le h\le k$，且不存在 $1\le i\le h$ 使得 $(a+i,b)$ 为类型为 $2$ 的特殊点。接着跳到 $(a+h+1,b)$。
- 选择一个 $h$，满足 $0\le h\le k$，且不存在 $1\le i\le h$ 使得 $(a,b+i)$ 为类型为 $2$ 的特殊点。接着跳到 $(a,b+h+1)$。
- 选择一个 $h$，满足 $0\le h\le k$，且不存在 $1\le i\le h$ 使得 $(a+i,b+i)$ 为类型为 $2$ 的特殊点。接着跳到 $(a+h+1,b+h+1)$。

在每次跳跃后，假设跳到了 $(X,Y)$，若 $(X,Y)$ 是第 $Z$ 个特殊点，那么：

- 若 $p_Z=1$，则 $w\leftarrow w+1$。
- 若 $p_Z=2$，令 $w\leftarrow w-s_Z$。

若某个方案中间某个时刻 $w<0$，或某个方案中间某个时刻 $(X,Y)$ 不在矩阵内，则该方案不合法。

问到 $(n,m)$ 的合法方案数，答案对 $10^9+7$ 取模。**当且仅当每次的 $(X,Y)$ 组成的序列不同时，两种方案才不同。**

## 说明/提示

**【样例解释 #1】**

注：下列每个点代表一个格子；红色箭头为一次跳跃，箭头尾端为 $(X,Y)$；黄色点为 $p_i=1$ 的特殊点；绿色点为 $p_i=2$ 的特殊点。

以下 $15$ 种方案是合法的：

![](https://cdn.luogu.com.cn/upload/image_hosting/yvuurwhq.png)

以下 $5$ 种方案不合法，因为在这些方案中，小 L 到 $(2,3)$ 后 $w=-1<0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/wey3f9js.png)

以下 $2$ 种方案不合法，因为在这些方案中，小 L 越过了 $p_i=2$ 的特殊点：

![](https://cdn.luogu.com.cn/upload/image_hosting/cx58ekal.png)

**【样例解释 #2】**

由于没有特殊点，在**样例解释 #1** 中展示的合法的 $15$ 种方案，以及不合法的 $7$ 种方案在样例 #2 中均合法，所以答案为 $22$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask #1（$15\text{ pts}$）：$n,m\le8$。
- Subtask #2（$25\text{ pts}$）：$k=0$。
- Subtask #3（$25\text{ pts}$）：$t=0$。
- Subtask #4（$35\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le x_i\le n\le180$，$1\le y_i\le m\le180$，$0\le k\le \max\{n,m\}+1$，$0\le t\le n\times m-2$，$p_i\in\{1,2\}$，$1\le s_i\le356$。

保证没有任何两对 $(x_i,y_i)$ 相同，保证不存在 $(x_i,y_i)=(1,1)$ 或 $(x_i,y_i)=(n,m)$。

## 样例 #1

### 输入

```
3 3 1 2
1 1 3
2 2 3 1```

### 输出

```
15```

## 样例 #2

### 输入

```
3 3 1 0```

### 输出

```
22```

# 题解

## 作者：Water__Problem (赞：2)

## 废话

场上因为这题卡了很久，导致最后罚时爆炸。

## 题解

首先先把 $k$ 给去掉或者把 $k$ 想成无限大。这时候怎么做？

先考虑暴力 DP。定义 $dp_{i,j,ww}$ 表示走到 $(i,j)$ 这个点 $ww=w$ 方案数。答案就是 $\sum_{ww=0} dp_{n,m,ww}$。

然后我们就可以暴力转移得到 $O(n^4)$ 的优秀复杂度。

考虑优化。~~我们发现总共就那么几种优化方式，一个一个看看~~，发现可以通过前缀和优化。

于是我们获得了优秀的 $O(n^3)$ 做法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
void init();void solve();
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int T=1;init();
//	cin>>T;
	while(T--) solve();
	return 0;
}
void init(){
}
#define mod (1000000007)
int n,m,k,t,led[200][200],dp[200][200][400],w[200][400],c[200][400],p[400][400];
void add(int &x,int y){
	x+=y;
	if(x>=mod) x%=mod;
}
void solve(){
	cin>>n>>m>>k>>t;
	for(int i=1;i<=t;i++){
		int pos,x,y,z;
		cin>>pos>>x>>y;
		if(pos==2){
			cin>>z;
			led[x][y]=-z;
		}
		else led[x][y]=1;
	}
	w[1][0]=c[1][0]=p[200][0]=dp[1][1][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i==j&&i==1) continue;
			if(led[i][j]<0){
				for(int ww=-led[i][j];ww<=n+m;ww++){
					add(dp[i][j][ww+led[i][j]],w[i][ww]);
					add(dp[i][j][ww+led[i][j]],c[j][ww]);
					add(dp[i][j][ww+led[i][j]],p[i-j+200][ww]);
				}
				for(int ww=0;ww<=n+m;ww++){
					w[i][ww]=dp[i][j][ww];
					c[j][ww]=dp[i][j][ww];
					p[i-j+200][ww]=dp[i][j][ww];
				}
			}
			else if(led[i][j]==1){
				for(int ww=0;ww<n+m;ww++){
					add(dp[i][j][ww+led[i][j]],w[i][ww]);
					add(dp[i][j][ww+led[i][j]],c[j][ww]);
					add(dp[i][j][ww+led[i][j]],p[i-j+200][ww]);
				}
				for(int ww=0;ww<=n+m;ww++){
					add(w[i][ww],dp[i][j][ww]);
					add(c[j][ww],dp[i][j][ww]);
					add(p[i-j+200][ww],dp[i][j][ww]);
				}
			}
			else{
				for(int ww=0;ww<=n+m;ww++){
					add(dp[i][j][ww],w[i][ww]);
					add(dp[i][j][ww],c[j][ww]);
					add(dp[i][j][ww],p[i-j+200][ww]);
				}
				for(int ww=0;ww<=n+m;ww++){
					add(w[i][ww],dp[i][j][ww]);
					add(c[j][ww],dp[i][j][ww]);
					add(p[i-j+200][ww],dp[i][j][ww]);
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<=n+m;i++) add(ans,dp[n][m][i]);
	cout<<ans<<endl;
}
```
但结束了吗，我们发现还有一个 $k$ 被我们忘在开头了。（场上就是忘记了，然后想了好久才把它找回来。）

现在，加上了 $k$ 的要求，但其实还是很简单。只需要每次转移完，把前缀和里面超过要求的减去就行。

好了，现在是真做完了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
void init();void solve();
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int T=1;init();
//	cin>>T;
	while(T--) solve();
	return 0;
}
void init(){
}
#define mod (1000000007)
int n,m,k,t,led[200][200],dp[200][200][400],w[200][400],cntw[200],c[200][400],cntc[200],p[400][400],cntp[400];
//p是对角线的前缀和，发现在一个对角线上的点 i-j 是不变的，但有可能是负数，于是同时加 200 
void add(int &x,int y){
	x+=y;
	if(x>=mod) x-=mod;
}
void del(int &x,int y){
	if(x>=y) x-=y;
	else x+=mod-y;
}
void solve(){
	cin>>n>>m>>k>>t;
	for(int i=1;i<=t;i++){
		int pos,x,y,z;
		cin>>pos>>x>>y;
		if(pos==2){
			cin>>z;
			led[x][y]=-z;
		}
		else led[x][y]=1;
	}
	w[1][0]=c[1][0]=p[200][0]=dp[1][1][0]=cntw[1]=cntc[1]=cntp[200]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i==j&&i==1) continue;
			int x=cntw[i];
			if(led[i][j]<0){//2类型节点 
				for(int ww=-led[i][j];ww<=n+m;ww++){
					add(dp[i][j][ww+led[i][j]],w[i][ww]);
					add(dp[i][j][ww+led[i][j]],c[j][ww]);
					add(dp[i][j][ww+led[i][j]],p[i-j+200][ww]);
				}
				for(int ww=0;ww<=n+m;ww++){
					w[i][ww]=dp[i][j][ww];
					c[j][ww]=dp[i][j][ww];
					p[i-j+200][ww]=dp[i][j][ww];
				}
				cntw[i]=cntc[j]=cntp[i-j+200]=1;
			}
			else if(led[i][j]==1){//1类型节点 
				for(int ww=0;ww<n+m;ww++){
					add(dp[i][j][ww+led[i][j]],w[i][ww]);
					add(dp[i][j][ww+led[i][j]],c[j][ww]);
					add(dp[i][j][ww+led[i][j]],p[i-j+200][ww]);
				}
				for(int ww=0;ww<=n+m;ww++){
					add(w[i][ww],dp[i][j][ww]);
					add(c[j][ww],dp[i][j][ww]);
					add(p[i-j+200][ww],dp[i][j][ww]);
				}
				cntw[i]++;cntc[j]++;cntp[i-j+200]++;
			}
			else{//正常节点 
				for(int ww=0;ww<=n+m;ww++){
					add(dp[i][j][ww],w[i][ww]);
					add(dp[i][j][ww],c[j][ww]);
					add(dp[i][j][ww],p[i-j+200][ww]);
				}
				for(int ww=0;ww<=n+m;ww++){
					add(w[i][ww],dp[i][j][ww]);
					add(c[j][ww],dp[i][j][ww]);
					add(p[i-j+200][ww],dp[i][j][ww]);
				}
				cntw[i]++;cntc[j]++;cntp[i-j+200]++;
			}
			//删操作 
			if(cntw[i]>k+1){
				for(int ww=0;ww<=n+m;ww++) del(w[i][ww],dp[i][j-cntw[i]+1][ww]);
				cntw[i]--;
			}
			if(cntc[j]>k+1){
				for(int ww=0;ww<=n+m;ww++) del(c[j][ww],dp[i-cntc[j]+1][j][ww]);
				cntc[j]--;
			}
			if(cntp[i-j+200]>k+1){
				for(int ww=0;ww<=n+m;ww++) del(p[i-j+200][ww],dp[i-cntp[i-j+200]+1][j-cntp[i-j+200]+1][ww]);
				cntp[i-j+200]--;
			}
		}
	}
	int ans=0;
	for(int i=0;i<=n+m;i++) add(ans,dp[n][m][i]);
	cout<<ans<<endl;
}
```

---

## 作者：_O_v_O_ (赞：2)

称加分点为蛙币，扣分点为收费站。

一眼 dp。

## 状态

设 $dp_{i,j,k}$ 为青蛙在 $(i,j)$，蛙币数量为 $k$ 时的总方案数。很显然，最终我们要求 $\sum\limits_{i=0}^L dp_{n,m,i}$，其中 $L$ 是青蛙最多拥有的蛙币数，为了方便，我们将其设为 $360$。

## 转移

接下来是转移公式，我们选择从前往后推：

先看往右走的情况，即从 $(i,j)$ 走到了 $(i,j+kk)$，有 $l$ 个蛙币。

1. 该点是空地：很明显是 $dp_{i,j+kk,l}\leftarrow dp_{i,j+kk,l}+dp_{i,j,l}$。
2. 该点是蛙币：也很明显 $dp_{i,j+kk,l+1}\leftarrow dp_{i,j+kk,l+1}+dp_{i,j,l}$。
3. 该点是收费站，假设 $q_{i,j+kk}$ 为这里收费站的收费个数，这里需要一点分讨：$dp_{i,j+kk,l-q_{i,j}}=\begin{cases}dp_{i,j+kk,l-q_{i,j}}+dp_{i,j,l}&l-q_{i,j}\ge 0\\ 0 &\operatorname{otherwise}\end{cases}$。

向下和向右下同理。

时间复杂度 $O(nmkL)$，只能得 $15pts$。

------------
# 正解

## 状态

我们设 $a_{i,j}$ 为青蛙上边最长连续不包含收费站的子段，$b_{i,j}$ 为左面的，$c_{i,j}$ 为左上的。

很明显，一个点 $(i,j)$ 最多能从 $(i-\min(a_{i,j},k+1),j),(i,j-\min(b_{i,j},k+1)),(i-\min(c_{i,j},k+1),j-\min(c_{i,j},k+1))$ 转移而来。

~~所以我们可以开 $3$ 个二维线段树来解决问题。复杂度 $O(nmL\log nm)$。~~

我们不妨开 $3$ 个 dp 数组 $dp1,dp2,dp3$，分别为原 $dp$ 数组的上方，左方，左上方的前缀和。

## 转移

还是一个一个判断：

1. 空地：

设 $s=dp1_{i-1,j,l}-dp1_{i-\min(a_{i,j},k+1),j,l}+dp2_{i,j-1,l}-dp2_{i,j-\min(b_{i,j},k+1),l}+dp3_{i-1,j-1,l}-dp3_{i-\min(c_{i,j},k+1),j-\min(c_{i,j},k+1),l}$。

那么转移为 $dp1_{i,j,l}\leftarrow dp_{i-1,j,l}+s,dp2_{i,j,l}\leftarrow dp2_{i,j-1,l}+s,dp3_{i,j,l}\leftarrow dp3_{i-1,j-1,l}+s$。

2. 蛙币：

其实也差不多。

设 $s=dp1_{i-1,j,l+1}-dp1_{i-\min(a_{i,j},k+1),j,l+1}+dp2_{i,j-1,l+1}-dp2_{i,j-\min(b_{i,j},k+1),l+1}+dp3_{i-1,j-1,l+1}-dp3_{i-\min(c_{i,j},k+1),j-\min(c_{i,j},k+1),l+1}$。

那么转移为 $dp1_{i,j,l+1}\leftarrow dp_{i-1,j,l}+s,dp2_{i,j,l+1}\leftarrow dp2_{i,j-1,l}+s,dp3_{i,j,l+1}\leftarrow dp3_{i-1,j-1,l}+s$。

3. 收费站：

分讨略，参考前面的。

设 $s=dp1_{i-1,j,l-q_{i,j}}-dp1_{i-\min(a_{i,j},k+1),j,l-q_{i,j}}+dp2_{i,j-1,l-q_{i,j}}-dp2_{i,j-\min(b_{i,j},k+1),l-q_{i,j}}+dp3_{i-1,j-1,l-q_{i,j}}-dp3_{i-\min(c_{i,j},k+1),j-\min(c_{i,j},k+1),l-q_{i,j}}$。

那么转移为 $dp1_{i,j,l-q_{i,j}}\leftarrow dp_{i-1,j,l}+s,dp2_{i,j,l-q_{i,j}}\leftarrow dp2_{i,j-1,l}+s,dp3_{i,j,l-q_{i,j}}\leftarrow dp3_{i-1,j-1,l}+s$。

其实 $s$ 就是所有可转移状态之和。

很明显答案为 $\sum\limits_{i=0}^{L} dp3_{n,m,i}-dp3_{n-1,m-1,i}$。

时间复杂度 $O(nmL)$。

---

## 作者：CaiZi (赞：2)

可以发现是 DP，首先设计状态，设 $f_{i,j,l}$ 表示到了 $(i,j)$ 且 $w=l$ 的方案数。那么如果该位置为 $p_i=1$ 的特殊点，则可以从 $f_{i',j',l-1}$ 转移。如果该位置为 $p_i=2$ 的特殊点，则可以从 $f_{i',j',l+s_i}$ 转移。然后转移的 $(i',j')$ 就是对 $3$ 个方向选距离不超过 $k+1$ 的点转移，如果有 $p_i=2$ 的特殊点，则同方向距离更远的点将不被转移，因为不能越过 $p_i=2$ 的特殊点。情况略多，注意分类讨论。

然后考虑优化，不难发现每次转移时是取一段区间和，因此考虑记录每个 $f_{i,j,k}$ 横向、纵向、斜向的前缀和。但是这样还不行，我们还需要预处理出每个位置三个方向距离最近的 $p_i=2$ 的特殊点的距离，然后就可以 $O(1)$ 转移了。但是细节非常多，主要来源于各种边界条件。我的实现可能比较恶心。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int n,m,k,t,p,x,y,s,q[181][181],dp1[181][181][358],dp2[181][181][358],dp3[181][181][358],a[181][181],b[181][181],c[181][181],ans;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>m>>k>>t;
	k++;
	while(t--){
		cin>>p>>x>>y;
		if(p==1){
			q[x][y]=-1;
		}
		else{
			cin>>s;
			q[x][y]=s;
		}
	}
	for(int i=1;i<=m;i++){
		a[1][i]=1;
		c[1][i]=1;
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(q[i-1][j]>=1){
				a[i][j]=2;
			}
			else{
				a[i][j]=a[i-1][j]+1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		b[i][1]=1;
		c[i][1]=1;
	}
	for(int i=1;i<=n;i++){
		for(int j=2;j<=m;j++){
			if(q[i][j-1]>=1){
				b[i][j]=2;
			}
			else{
				b[i][j]=b[i][j-1]+1;
			}
		}
	}
	for(int i=2;i<=n;i++){
		for(int j=2;j<=m;j++){
			if(q[i-1][j-1]>=1){
				c[i][j]=2;
			}
			else{
				c[i][j]=c[i-1][j-1]+1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i==1&&j==1){
				dp1[i][j][0]=dp2[i][j][0]=dp3[i][j][0]=1;
			}
			else{
				for(int g=0;g<=357;g++){
					dp1[i][j][g]=dp1[i-1][j][g];
					dp2[i][j][g]=dp2[i][j-1][g];
					dp3[i][j][g]=dp3[i-1][j-1][g];
				}
				if(q[i][j]>=1){
					for(int g=0;g<=356-q[i][j];g++){
						s=(dp1[i-1][j][g+q[i][j]]-dp1[i-min(k+1,a[i][j])][j][g+q[i][j]]+dp2[i][j-1][g+q[i][j]]-dp2[i][j-min(k+1,b[i][j])][g+q[i][j]]+dp3[i-1][j-1][g+q[i][j]]-dp3[i-min(k+1,c[i][j])][j-min(k+1,c[i][j])][g+q[i][j]])%mod;
						(s+=mod)%=mod;
						(dp1[i][j][g]+=s)%=mod;
						(dp2[i][j][g]+=s)%=mod;
						(dp3[i][j][g]+=s)%=mod;
					}
				}
				else{
					for(int g=-q[i][j];g<=357;g++){
						s=(dp1[i-1][j][g+q[i][j]]-dp1[i-min(k+1,a[i][j])][j][g+q[i][j]]+dp2[i][j-1][g+q[i][j]]-dp2[i][j-min(k+1,b[i][j])][g+q[i][j]]+dp3[i-1][j-1][g+q[i][j]]-dp3[i-min(k+1,c[i][j])][j-min(k+1,c[i][j])][g+q[i][j]])%mod;
						(s+=mod)%=mod;
						(dp1[i][j][g]+=s)%=mod;
						(dp2[i][j][g]+=s)%=mod;
						(dp3[i][j][g]+=s)%=mod;
					}
				}
			}
		}
	}
	for(int i=0;i<=357;i++){
		(ans+=(dp3[n][m][i]-dp3[n-1][m-1][i])%mod+mod)%=mod;
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：ylch (赞：1)

这道题显然是一个网格状态的 dp，设 $dp[i][j][w]$ 表示在位置 $(i,j)$，值为 $w$ 的方案数。

暴力转移显然，就不说了。考虑如何优化。

### 预处理优化

发现根据题目的转移方式，如果在 $k$ 步之内有一个类型 $2$ 的格子，那么这之后的格子也不能走了。所以我们考虑预处理出每个格子向右、下、右下对角线三个方向最多能走的步数，就可以缩短转移时的开销。（转移方程不好描述，请见代码）

预处理复杂度 $O(nmk)$，转移复杂度为 $O(nmk \times V)$（$V$ 是 $w$ 的值域），但实际上跑不满。

[$40$ 分](https://www.luogu.com.cn/record/228921079)代码：[Link](https://www.luogu.com.cn/paste/y27dvzkj)。

### map 优化

最近学到一种“邪修”，就是用 map 存其中一维不一定全部有值的状态，这样在遍历时可以直接跳过没有值的状态，只从有值的状态转移，大大节约了转移量。

实测效果很好，可以通过前三个 subtask 和最后一个 subtask 的一半测试点。

[$65$ 分](https://www.luogu.com.cn/record/228921613)代码：[Link](https://www.luogu.com.cn/paste/r5vvrz5e)。

### 前缀和转移优化

现在是时候做一些实质性的优化了。

因为我们的 dp 转移方式是枚举新状态，然后从旧状态转移，所以为了更高效地确定旧状态方向的信息，我们的预处理方式也要反过来。

对于每个位置 $(i, j)$，预处理三个方向的连续无类型 $2$ 特殊点的长度：

- 向左：从 $(i, j-1)$ 向左的连续无类型 $2$ 的长度。

- 向上：从 $(i-1, j)$ 向上的连续无类型 $2$ 的长度。

- 对角线：从 $(i-1, j-1)$ 向左上方向的连续无类型 $2$ 的长度。

然后发现每个方向的 dp 数组都是由一段区间转移过来，所以可以考虑**前缀和优化**，即由原来的 $O(k)$ 循环枚举直接变成一次 $O(1)$ 前缀和运算。具体细节建议自己手模一下，对于新手来说还是比较困难。

在此，我想用一个最近新学到的处理对角线前缀和的技巧：注意到对角线方向的前缀和数组实际上是一个一维的前缀和（沿着对角线方向），所以我们可以将每个对角线单独处理（用 $i-j$ 作为对角线的标识），然后在这个对角线上做一维前缀和。为了避免减出负数，考虑加上一个偏移量 $m-1$。

[$100$ 分](https://www.luogu.com.cn/record/229301818)代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7, maxn = 180, maxm = 180, maxw = 365, maxd = 360;

struct Node{
	int type = 0;
	int s = 0;
}a[maxn+1][maxm+1];

int n, m, k, t;
int dp[maxn+1][maxm+1][maxw]; // dp[i][j][w]:位于(i,j)，值为w的方案数
int colSum[maxn+1][maxm+1][maxw], rowSum[maxn+1][maxm+1][maxw], diagSum[maxn+1][maxd][maxw]; // 前缀和数组
int leftLen[maxn+1][maxm+1], upLen[maxn+1][maxm+1], diagLen[maxn+1][maxm+1]; // 预处理数组

void preprocess(){
	for(int i = 1; i <= n; i ++){
		for(int j = 2; j <= m; j ++){
			if(a[i][j-1].type == 2){
				leftLen[i][j] = 0;
			}else{
				leftLen[i][j] = min(leftLen[i][j-1] + 1, k);
			}
		}
	}
	
	for(int j = 1; j <= m; j ++){
		for(int i = 2; i <= n; i ++){
			if(a[i-1][j].type == 2){
				upLen[i][j] = 0;
			}else{
				upLen[i][j] = min(upLen[i-1][j] + 1, k);
			}
		}
	}
	
	for(int i = 2; i <= n; i ++){
		for(int j = 2; j <= m; j ++){
			if(a[i-1][j-1].type == 2){
				diagLen[i][j] = 0;
			}else{
				diagLen[i][j] = min(diagLen[i-1][j-1] + 1, k);
			}
		}
	}
}

void solve(){
	cin >> n >> m >> k >> t;
	for(int i = 1; i <= t; i ++){
		int p, x, y, s = 0; cin >> p;
		if(p == 1){
			cin >> x >> y; a[x][y].type = 1;
		}else if(p == 2){
			cin >> x >> y >> s; a[x][y] ={2, s};
		}
	}
	
	preprocess();
	
	dp[1][1][0] = 1;
	colSum[1][1][0] = 1;
	rowSum[1][1][0] = 1;
	diagSum[1][(1 - 1) +(m - 1)][0] = 1; // 一些初始化
	
	for(int i = 1; i <= n; i ++){
		for(int j = (i == 1 ? 2 : 1); j <= m; j ++){
			// 向右
			if(j >= 2){
				int L = max(1, j - 1 - leftLen[i][j]);
				for(int ww = 0; ww < maxw; ww ++){
					int sum =(1LL * rowSum[i][j - 1][ww] - (L - 1 >= 0 ? rowSum[i][L - 1][ww] : 0) + mod) % mod;
					if(a[i][j].type == 0){
						dp[i][j][ww] = (dp[i][j][ww] + sum) % mod;
					}else if(a[i][j].type == 1){
						if(ww + 1 < maxw){
							dp[i][j][ww + 1] = (dp[i][j][ww + 1] + sum) % mod;
						}
					}else if(a[i][j].type == 2){
						int nw = ww - a[i][j].s;
						if(nw >= 0 && nw < maxw){
							dp[i][j][nw] = (dp[i][j][nw] + sum) % mod;
						}
					}
				}
			}
			
			// 向下
			if(i >= 2){
				int L = max(1, i - 1 - min(upLen[i][j], k));
				for(int ww = 0; ww < maxw; ww ++){
					int sum =(1LL * colSum[i - 1][j][ww] - (L - 1 >= 1 ? colSum[L - 1][j][ww] : 0) + mod) % mod;
					if(a[i][j].type == 0){
						dp[i][j][ww] = (dp[i][j][ww] + sum) % mod;
					}else if(a[i][j].type == 1){
						if(ww + 1 < maxw){
							dp[i][j][ww + 1] = (dp[i][j][ww + 1] + sum) % mod;
						}
					}else if(a[i][j].type == 2){
						int nw = ww - a[i][j].s;
						if(nw >= 0 && nw < maxw){
							dp[i][j][nw] = (dp[i][j][nw] + sum) % mod;
						}
					}
				}
			}
			
			// 向对角线
			if(i >= 2 && j >= 2){
				int L = max(1, i - 1 - diagLen[i][j]);
				int d =(i - j) + (m - 1);
				for(int ww = 0; ww < maxw; ww ++){
					int sum = (1LL * diagSum[i - 1][d][ww] - (L - 1 >= 1 ? diagSum[L - 1][d][ww] : 0) + mod) % mod;
					if(a[i][j].type == 0){
						dp[i][j][ww] = (dp[i][j][ww] + sum) % mod;
					}else if(a[i][j].type == 1){
						if(ww + 1 < maxw){
							dp[i][j][ww + 1] = (dp[i][j][ww + 1] + sum) % mod;
						}
					}else if(a[i][j].type == 2){
						int nw = ww - a[i][j].s;
						if(nw >= 0 && nw < maxw){
							dp[i][j][nw] = (dp[i][j][nw] + sum) % mod;
						}
					}
				}
			}
			
			for(int w = 0; w < maxw; w ++){
				rowSum[i][j][w] = (rowSum[i][j - 1][w] + dp[i][j][w]) % mod;
			}
			
			for(int w = 0; w < maxw; w ++){
				colSum[i][j][w] = (colSum[i - 1][j][w] + dp[i][j][w]) % mod;
			}
			
			int d = (i - j) + (m - 1);
			for(int w = 0; w < maxw; w ++){
				diagSum[i][d][w] = (diagSum[i - 1][d][w] + dp[i][j][w]) % mod;
			}
		}
	}
	
	int ans = 0;
	for(int w = 0; w < maxw; w ++){
		ans = (ans + dp[n][m][w]) % mod;
	}
	cout << ans;
}

int main(){
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P13566 题解

## 思路

发现题目只能往右往下往右下走，所以很自然可以想到 dp。

设 $f_{i,j,s}$ 表示走到 $(i,j)$ 这个点，$w=s$ 的方案数，每个点从正上方、左侧、左上三个方向转移，所以向上、向左、向左上分别走 $k+1$ 步，如果出现第 $2$ 类特殊点就停止，但是这样时间复杂度较高，设 $n,m,s,k$ 同阶，则 $\mathcal{O}(n^4)$，无法接受。

考虑优化，发现每一次转移的三个方向都是连续的一段，所以考虑通过某种方式维护这些数据。

设 $g_{i,j,s,0}$ 表示走到 $(i,j)$ 这个点，$w=s$，左边连续的一段 $f_{i,j',s}$ 的和，并满足这一段内不存在第 $2$ 类特殊点，以及长度不超过 $k$，$g_{i,j,s,1}$ 表示斜方向，$g_{i,j,s,2}$ 表示上方，再令 $l_{i,j,s,p} (p \in [0,2],p \in \N)$ 表示其对应的 $g_{i,j,s,p}$ 包含了多少长度的 $f$ 的和（从 $0$ 开始）。

所以对于每一个 $i,j,s$ 如果 $(i,j)$ 是第二类特殊点，那么它不能去和前面的 $g$ 拼接了，只能自己重新开一个，所以 $g_{i,j,s,p}=f_{i,j,s},l_{i,j,s,p}=0$。

否则的话就记入前缀和 $g_{i,j,s,p} \leftarrow g_{i,j,s,p} + f_{i,j,s}$，对于每一个超出长度的 $g$，把它最前面的那一个删掉，就像滑动窗口那样把最后面的加进来之后把最前面的抛掉，最后求和 $\sum f_{n,m,i}$ 即可，于是我们用 $\mathcal{O}(n^3)$ 的复杂度做掉了这道题。

## 代码

```cpp
const int N=185;
const int M=365;
const int mod=1e9+7;

int n,m,k,t;
int arr[N][N];
int f[N][N][M];
int g[N][N][M][3];
int l[N][N][M][3];

int main() {
    read(n),read(m),read(k),read(t);
    while (t--) {
        int p;
        read(p);
        if (p==1) {
            int x,y;
            read(x),read(y);
            arr[x][y]=1;
        } else {
            int x,y,s;
            read(x),read(y),read(s);
            arr[x][y]=-s;
        }
    }
    memset(l,-1,sizeof(l));
    _rep(i,1,n) {
        _rep(j,1,m) {
            if (i==1 && j==1) {
                f[i][j][0]=1;
                g[i][j][0][0]=1;
                g[i][j][0][1]=1;
                g[i][j][0][2]=1;
                l[i][j][0][0]=0;
                l[i][j][0][1]=0;
                l[i][j][0][2]=0;
                continue;
            }
            _rep(s,0,M-1) {
                int t=s-arr[i][j];
                if (t>=0 && t<M) {
                    f[i][j][s]=(f[i][j][s]+g[i-1][j][t][2])%mod;
                    f[i][j][s]=(f[i][j][s]+g[i][j-1][t][0])%mod;
                    f[i][j][s]=(f[i][j][s]+g[i-1][j-1][t][1])%mod;
                }
                if (arr[i][j]<0) {
                    g[i][j][s][0]=g[i][j][s][1]=g[i][j][s][2]=f[i][j][s];
                    l[i][j][s][0]=l[i][j][s][1]=l[i][j][s][2]=0;
                } else {
                    g[i][j][s][0]=(g[i][j-1][s][0]+f[i][j][s])%mod;
                    g[i][j][s][1]=(g[i-1][j-1][s][1]+f[i][j][s])%mod;
                    g[i][j][s][2]=(g[i-1][j][s][2]+f[i][j][s])%mod;
                    l[i][j][s][0]=l[i][j-1][s][0]+1;
                    l[i][j][s][1]=l[i-1][j-1][s][1]+1;
                    l[i][j][s][2]=l[i-1][j][s][2]+1;
                    if (l[i][j][s][0]==k+1) {
                        l[i][j][s][0]--;
                        g[i][j][s][0]=((g[i][j][s][0]-f[i][j-k-1][s])%mod+mod)%mod;
                    }
                    if (l[i][j][s][1]==k+1) {
                        l[i][j][s][1]--;
                        g[i][j][s][1]=((g[i][j][s][1]-f[i-k-1][j-k-1][s])%mod+mod)%mod;
                    }
                    if (l[i][j][s][2]==k+1) {
                        l[i][j][s][2]--;
                        g[i][j][s][2]=((g[i][j][s][2]-f[i-k-1][j][s])%mod+mod)%mod;
                    }
                }
            }
        }
    }
    int ans=0;
    _rep(i,0,M-1) ans=(ans+f[n][m][i])%mod;
    write(ans);
    return 0;
}
```

---


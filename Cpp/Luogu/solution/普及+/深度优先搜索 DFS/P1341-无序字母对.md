# 无序字母对

## 题目描述

给定 $n$ 个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有 $(n+1)$ 个字母的字符串使得每个字母对都在这个字符串中出现。

## 说明/提示

不同的无序字母对个数有限，$n$ 的规模可以通过计算得到。

## 样例 #1

### 输入

```
4
aZ
tZ
Xt
aX```

### 输出

```
XaZtX
 ```

# 题解

## 作者：foreverlasting (赞：199)

这是我这个小蒟蒻第一次敲欧拉回路，于是参照了一波题解。同时也发现好像就没有题解判断了图是否联通。因此在这里呼吁一下，加强一下数据好吧。

思路就不会说了吧，每读入两个字母就给这两个字母连一条无向边，跑一边欧拉回路就行了。

下面是代码：（欧拉回路我主要是参照了第一篇题解，然后判断图是否联通我用了并查集维护了一下。）
```
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w; 
}
const int N=257;
int G[N][N],depth[N],n,cnt,hen,f[N],sum[N];
char tmp[N],rb[N*N]; 
inline void dfs(int x){
	for(res i=0;i<N;i++)
		if(G[x][i])G[x][i]=G[i][x]=0,dfs(i);
	rb[n--]=x;
}
inline int find(int x){
	if(f[x]!=x)f[x]=find(f[x]);
	return f[x];
}
int main(){
	n=read();
	for(res i=0;i<N;i++)f[i]=i;
	for(res i=1;i<=n;i++){
		scanf("%s",tmp);
		G[tmp[0]][tmp[1]]=G[tmp[1]][tmp[0]]=1;
		int fx=find(tmp[0]),fy=find(tmp[1]);
		f[fx]=fy;
        depth[tmp[0]]++;
        depth[tmp[1]]++;
	}
	int ans=0;
	for(res i=0;i<N;i++)if(f[i]==i&&depth[i])ans++;
	if(ans!=1){puts("No Solution");return 0;}
	for(res i=0;i<N;i++)
		if(depth[i]&1){
		    cnt++;
			if(!hen)hen=i;
		}
	if(!hen)
	    for(res i=0;i<N;i++)
		    if(depth[i]){hen=i;break;}
	if(cnt&&cnt!=2){puts("No Solution");return 0;}
	dfs(hen);
	puts(rb);
	return 0;
}
```

---

## 作者：Obito (赞：135)

 # ~~模板~~
 ## 这个题打欧拉路就行了
 
### 很多dalao们都是用并查集来判断的连通
### 在此介绍一种稍微巧妙一点的方法
```
先分析一下问题

给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个

字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母

对都在这个字符串中出现。


这里就可以发现实际上就是在找欧拉路，首先每个字符就是代表的图中的某一个点，底下输入的字符串，
就代表两点之间有连通，
构造字符串就是在找输出一笔画回路，明白这个代码就很简单了。
```

### 具体看代码

```
#include<bits/stdc++.h>//万能头
using namespace std;
const int maxn=10000+10;
int n,m,dis[maxn][maxn],s1=maxn,ans;//dis是用来存两点的连接
char ru[maxn],a[maxn];//ru存度数，a存路径
void out(){//写了个输出函数
    for(int i=ans;i>=1;i--)
    printf("%c",a[i]);
    cout<<endl;
}
void find(int i){//开始找欧拉路，i表示找的当前这个点
        for(int j=1;j<=150;j++)//最大的小写z是肯定没超过150的，所以枚举点循环到150就行了
            if(dis[i][j]>0){//如果两点之间有连通
            dis[i][j]--;//毁图大法好
            dis[j][i]--;
            find(j);//搜索下一个点
        }
    a[++ans]=i;//记录路径
    return ;
}
int main(){
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        string s;
        cin>>s;//这里我是采用string处理的，char也行不影响
        dis[s[0]][s[1]]++;//记录路径，数组第一维表示当前的点，与第二维的点有，连接
        dis[s[1]][s[0]]++;
        ru[s[0]]++;//记录度数
        ru[s[1]]++;
     } 
     int cnt=0,h=0;//开始找点
    for(int i=1;i<=150;i++)//在找度数为奇数的点
        if(ru[i]&1){
            cnt++;
            if(!h)h=i;
        }
    if(!h)//找不到奇点，就是另外找点
        for(int i=0;i<150;i++)
            if(ru[i]){h=i;break;}
    if(cnt&&cnt!=2){
    	cout<<"No Solution";
    	return 0;
    }
    find(h);
    if(ans<m+1){//这就是我之前所说的巧妙一点的方法，实际上只要搜完以后判断一下，点数是不是相等就行了，因为m组连边，必有m+1个点，前提是不重复
    	cout<<"No Solution";
    	return 0;
    }
    out();//输出
    return 0;//完结散花
}
```

## 谢谢管理员百忙之中来审核这篇题解，如有问题，请管理员大大和大家斧正，谢谢
# 最后祝大家
# AK NOIP 2018


---

## 作者：北方有小仙儿 (赞：112)

## 来自蒟蒻的第一篇题解！！！！
首先一看题，没思路，点开题解，dalao们都说是欧拉回路板子【~~欧拉回路是什么？？？？~~】
于是花了半上午搞懂了欧拉回路是个什么东西，成功一遍过。
这篇题解会比较详细，主要是为了给像我这样的蒟蒻准备的。

很多思想都是从之前大佬们的题解中得来的，所以相当于是之前dalao们的题解的一点补充吧。


------------

首先是题意。
 
欧拉路径：在一个图中，由i点出发，将每个边遍历一次最终到达j点的一条路径。 

欧拉回路：i=j时的欧拉路径。

因为要求答案长度为n+1，所以这个题的题意可以转化成，给出一个无向图，求字典序最小的一条欧拉回路/路径。

所以建图，就是在每一组字母对之间连无向边。

------------
参照一楼大佬的题解，这题应该要判断是否联通的【~~虽然不判断也能AC~~】，用并查集判断是否是个连通图，也就是所有字母都只有一个祖宗。如果不是连通图，直接输出No Solution

------------
然后就是怎么求欧拉回路/路径了。

首先要判断是否存在欧拉回路/路径。

怎么判断呢。→参照此博客(https://blog.csdn.net/qq_34454069/article/details/77779300)

在无向图中

判断欧拉回路，只要每个点的度数均为偶数即可。

判断欧拉路径，如果有且仅有两个点的度数为奇数，就会存在一条从这两个中的一个到达另一个的欧拉路径。 

所以在输入是存储每个点的度数，判断是否满足条件。如果不满足，即没有欧拉回路/路径，就直接输出No Solution。

如果存在欧拉路径，直接把字典序较小的那个有奇数度数的点当做起点，进行dfs。

如果存在欧拉回路，就选择一个字典序最小的点当做起点，进行dfs。

------------
dfs过程其实就是不停地找字典序较小的边。其中有一个地方我想了一会才明白【~~dalao请自觉跳过~~】
就是路径要倒着存，是因为存储是在回溯的时候做的，所以要从后往前存【这么简单的问题可能也就我会想不明白。。。】


------------
最后一些小的点。

用邻接矩阵存图就可以，且看起来很方便。

我直接开的是125*125，因为ASCII码表里面z是122，所以可以直接用字符当下标。看dalao的代码是257，依然想不明白为什么。

然后n的范围是看讨论里面说的，因为每个字母都可以与51个字符相连，所以为 52*51/2，所以我答案数组开了1330；

上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
using namespace std;
int n,head;
char a[2];
int b[130][130];//存图
int deg[130],fa[130];//deg存储度数，fa存储父亲，用来并查集判断是否联通
char ans[1330];//稍大于51*52/2
int find(int x)
{
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void dfs(int x)//找欧拉回路/路径
{
	for(int i=64;i<=125;i++)
	  if(b[x][i])
	  {
	  	b[x][i]=b[i][x]=0;
	  	dfs(i);
	  }
	ans[n--]=x;//因为是回溯的时候存，所以倒着存
}
int main()
{
	cin>>n;
	for(int i=64;i<=125;i++)fa[i]=i;
    //A在ASCII码表里为65，z为122，所以64~125就足够了
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		b[a[0]][a[1]]=b[a[1]][a[0]]=1;
		deg[a[0]]++;
		deg[a[1]]++;
		int xx=find(a[0]),yy=find(a[1]);
		fa[xx]=yy;
	}
	int cnt=0;
	for(int i=64;i<=125;i++)
	  if(fa[i]==i&&deg[i])cnt++;//祖宗结点
	if(cnt!=1){cout<<"No Solution"<<endl;return 0;}//如果不是连通图
	cnt=0;
	head=0;
	for(int i=64;i<=125;i++)
	{
		if(deg[i]&1)
		{
			cnt++;
			if(head==0)head=i;//顺道存储起点
		}
	}
	if(cnt&&cnt!=2){cout<<"No Solution"<<endl;return 0;}
    //如果有奇数度数的点，并且不是两个，说明不存在欧拉回路/路径
    if(head==0)//如果是欧拉回路
      for(int i=64;i<=125;i++)
        if(deg[i]){head=i;break;}//找欧拉回路的起点
    dfs(head);
    cout<<ans;
    return 0;
} 
```

最后吐槽，写题解好麻烦。。。

【但是很有收获】

如果有不清楚或者错误的地方欢迎私信~~

---

## 作者：syksykCCC (赞：43)

本人第一次写欧拉回路的题，调试很久终于写出来了，故发一篇题解来和大家交流一下

首先推荐一下[这篇题解](https://www.luogu.org/blog/foreverlasting/ti-xie-wu-xu-zi-mu-dui)，感谢作者 @[$\color{red}\text{foreverlastnig}$](https://www.luogu.org/space/show?uid=32878) 大佬的帮助

我来补充说明一下自己关于`rb[n--]=x;`的一些理解

可能很多人像我一样，认为这种在函数结束时逆序储存和在函数开始时顺序储存时一样的，于是就采用了后者，结果提交50分，下载了数据，看到了形如$xx$这样的字母对，不知道怎么处理。下面为了方便理解，我贴一下寻找欧拉路的递归代码：

50pts:
```cpp
void circuit(char u)
{
    ans+=u;
    for(int i=0;i<g[u].size();i++)
    {
        char v=g[u][i];
        if(!vis[u][v])
        {
            vis[u][v]=vis[v][u]=true;
            circuit(v);
        }
    }
}
```
100pts:
```
void circuit(char u)
{
    for(int i=0;i<g[u].size();i++)
    {
        char v=g[u][i];
        if(!vis[u][v])
        {
            vis[u][v]=vis[v][u]=true;
            circuit(v);
        }
    }
    ans[n--]=u;
}
```
其中$ans$是一个`string`类的用来储存答案的变量

可以发现区别就如上文所言，为什么会不同呢？

看一下这组数据
```
input:
5
xx
xa
aa
ab
bx
output 50pts:
aabxax
output 100pts:
aabxxa
```
怎么回事？

可以发现，50pts代码会贪心地挑较小结点访问，当访问到倒数第三个字母$x$时，会毫不犹豫地前往$a$，而不管这样做是否能遍历完，因此走到$a$无路可走了，又回到$x$遍历另外一个$x$，从而得到一个错误的答案

而100pts代码的好处在于，它是在遍历结束后将该结点逆序存入答案中，这就保证了无路可走的节点$a$一定是该序列的结尾（因为如果该结点还能继续访问，它就一定在那些能继续访问的点的前面），然后回到倒数第三个字母$x$寻找下一个$x$访问。此处不用担心$x$是否也是一个结尾（那样就无解了），因为通过递归前的判断，这张图中一定存在欧拉路，也就是只有一个终点

贴出我因为STL而常数很大的代码吧：
```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<vector>
#include<map>
using namespace std;
const int N=300;
typedef map<char,vector<char> > graph;
graph g;
int n;
bool vis[N][N];
char f[N],ans[N];
char find_(char p)
{
    if(f[p]==p) return p;
    return f[p]=find_(f[p]);
}
void union_(char p1,char p2)
{
    char f1=find_(p1);
    char f2=find_(p2);
    f[f1]=f2;
}
void circuit(char u)
{
    for(int i=0;i<g[u].size();i++)
    {
        char v=g[u][i];
        if(!vis[u][v])
        {
            vis[u][v]=vis[v][u]=true;
            circuit(v);
        }
    }
    ans[n--]=u;
}
int main()
{
    scanf("%d",&n);
    for(char c='a';c<='z';c++) f[c]=c;
    for(char c='A';c<='Z';c++) f[c]=c;
    for(int i=1;i<=n;i++)
    {
        char u,v;
        while(!isalpha(u=getchar()));
        while(!isalpha(v=getchar()));
        g[u].push_back(v);
        g[v].push_back(u);
        union_(u,v);
    }
    for(graph::iterator it=g.begin();it!=g.end();it++)
    {
        sort(it->second.begin(),it->second.end());
    }
    int cnt=0;
    char bz=find_(g.begin()->first);
    for(graph::iterator it=g.begin();it!=g.end();it++)
    {
        if(bz!=find_(it->first)) cnt++;
    }
    if(cnt)
    {
        puts("No Solution");
        return 0;
    }
    cnt=0;
    for(graph::iterator it=g.begin();it!=g.end();it++)
    {
        if(it->second.size()&1)	cnt++;
    }
    if(cnt==1 || cnt>2)
    {
        puts("No Solution");
        return 0;
    }
    if(!cnt)
    {
        circuit(g.begin()->first);
    }
    else
    {
        for(graph::iterator it=g.begin();it!=g.end();it++)
        {
            if(it->second.size()&1)
            {
                circuit(it->first);
                break;
            }
        }
    }
    printf("%s",ans);
    return 0;
}
```

**欢迎各位大佬指出不足**

---

## 作者：pantw (赞：22)

使用算法：[Hierholzer算法](https://en.wikipedia.org/wiki/Eulerian\_path#Hierholzer's\_algorithm)。

做法简单来说就是通过dfs结束时间戳来构造串。

实现细节详见代码。


```cpp
#include <cstdio>
#define maxn 257
int G[maxn][maxn]; // 图
int deg[maxn]; // 度
char tmp[maxn]; 
char res[maxn * maxn]; // 结果
int n;
void dfs(int i) { 
    for(int j = 0; j < maxn; j++) {
        if(G[i][j]) {
            G[i][j] = G[j][i] = 0; // 删边
            dfs(j);
        }
    }
    res[n--] = i; // 记录
}
int main() {
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%s", tmp);
        G[tmp[0]][tmp[1]] = G[tmp[1]][tmp[0]] = 1;
        deg[tmp[0]]++;
        deg[tmp[1]]++;
    }
    char fir = 0, cnt = 0;
    for(int i = 0; i < maxn; i++) { // 计算度数情况
        if(deg[i] & 1) {
            cnt++;
            if(!fir) fir = i;
        }
    }
    if(!fir) for(int i = 0; i < maxn; i++) if(deg[i]) {fir = i; break;}
    if(cnt && cnt != 2) return puts("No Solution"), 0; // 判断无解
    dfs(fir);
    puts(res);
    return 0;
}
```

---

## 作者：songhn (赞：16)

# 欧拉回路
好吧，这虽然是一道几乎是欧拉回路板子的题目，但是由于牵扯到字符串，所以还是有一些小坑的细节（可能是我太菜了）

首先，欧拉路是指图是连通的而且有且只有两个奇点。而欧拉回路则是有0个奇点，所以在代码中需要特判一下，假如普通的那么无所谓，但是题目要求字典序输出
```cpp
if(du[i]%2==1) //找欧拉路最小起点 
	{
	    s=min(s,i),cnt++;
	}
	if(cnt!=0&&cnt!=2) //假如既不是欧拉路也不是欧拉回路 
	{
	    cout<<"No Solution"<<endl;
	    return 0;
	}
	if(cnt == 0)//如果是欧拉回路，那此时s还是maxn，所以需要再判断一下 
    for(int i=1;i<=52;i++) if(du[i]) {
        s = i;
        break;
    }
```
接下来可以把字符转化成数字来简化，但是我们不能直接**i-'A'+1**,因为同时有大小写，所以要分开处理（这里坑了我半天，我才知道ASCII码表里大写与小写字母之间还隔着几个符号）
```
int pan(char x)
{
	if(x <= 'z' && x >= 'a') return x - 'a' + 27;
    else return x - 'A' + 1;
}
```
最后这道题保存数据是可以用vector比较方便而且不会爆，假如用数组的话，一定要开大一点，否则第十个点会WA 然后就是完整代码
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000;
int e[maxn][maxn]={0},du[maxn]={0},lu[maxn],s=0x3f3f3f3f,cnt=0,pos=0,n;
int pan(char x)
{
	if(x <= 'z' && x >= 'a') return x - 'a' + 27;
    else return x - 'A' + 1;
}
int pan2(char x)
{
	if(x <= 26) return 'A' + x - 1;
    return 'a' + x - 27;
}
void dfs(int x)
{
	for(int y=1;y<=52;y++)
	{
		if(e[x][y]==1)
		{
			e[x][y]=e[y][x]=0;
			dfs(y);
		}
	}
	lu[++pos]=x;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		char x,y;
		cin>>x>>y;
		du[pan(x)]++,du[pan(y)]++;
		e[pan(x)][pan(y)]=e[pan(y)][pan(x)]=1;
	}
	for(int i=1;i<=52;i++)
	if(du[i]%2==1) //找欧拉路最小起点 
	{
	    s=min(s,i),cnt++;
	}
	if(cnt!=0&&cnt!=2) //假如既不是欧拉路也不是欧拉回路 
	{
	    cout<<"No Solution"<<endl;
	    return 0;
	}
	if(cnt == 0)//如果是欧拉回路，那此时s还是maxn，所以需要再判断一下 
    for(int i=1;i<=52;i++) if(du[i]) {
        s = i;
        break;
    }
	dfs(s);
	for(int i=pos;i>=1;i--)
	printf("%c",pan2(lu[i]));
	
	return 0;
}
```

---

## 作者：ynzzr (赞：12)

欧拉路~

图的记录只用了一个bool变量b来记录，没有用vector。

判断欧拉路的同时就能记录答案，不需要单独判断~

字符串是从0输入的~总是记不住呐~[悲伤]

不得不说欧拉路太神奇了~

（A到z之间还有其他字符，所以一共是58个~）

```cpp
#include<cstdio>
#include<cstring>
int a[106],c[10006],du[101],n,x,y,
    k=0xfffffff,tot;
bool b[106][106];
char s[2];
int min(int u,int v) {
	return u<v ? u:v;
}
void dfs(int u) {
	for(int i=0; i<58; i++)/*A到z之间还有一些字符，总共58个*/ {
		if(b[u][i]) {
			b[u][i]=b[i][u]=0;
			dfs(i);
		}
	}
	c[++tot]=u;
}
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++)	{
		scanf("%s",&s);
		x=s[0]-'A';
		y=s[1]-'A';/*字符串从零开始读入*/
		k=min(k,min(x,y));
		b[x][y]=b[y][x]=1;
		du[x]++;
		du[y]++;
	}
	for(int i=0; i<58; i++)
		if(du[i]%2==1)
			a[++a[0]]=i;
	if(a[0]==0) dfs(k);
	else if(a[0]==2) dfs(a[1]);
	else	{
		printf("No Solution\n");
		return 0;
	}
	for(int i=tot; i>=1; i--)
		printf("%c",c[i]+'A');
	return 0;
}


```

---

## 作者：PJone (赞：9)

 _ 如果对于欧拉路径还有不太清晰的同学可以先阅此页：_ 
 
###  **_ 欧拉回路及其相关_ **
 
**定义：**

１.这个问题主要引伸自一个古老的问题，有兴趣的同学可以上百度百科上找。通俗而言，就是一个一笔划问题。

２.给定一个图，经过每条边一次且仅此一次的一条回路called欧拉回路。||给定一个图，经过每条边一次且仅此一次的路径callde欧拉路径。

３.欧拉图：存在欧拉回路的图。半欧拉图：存在欧拉路径，且不存在欧拉回路的图。
联系：

据某巨弱而言，欧拉回路属于欧拉路径，而欧拉路径要求远比欧拉回路要求低。

**规律＆性质：**

对 _无向图_ 而言：

１.定理一：若图为欧拉图，当且仅当图中每个点度数为偶数且联通。

证明：对于每个点，既可以进也可以出，所以绝对是可以做到欧拉路径的。

由此，可以引申至对于欧拉回路的求解算法：若存在欧拉回路，则从任意一个点出发向任意与其相连的点递归搜索，都是可以遍历回到起点的。

不仅如此，还可以引申出一个证明半欧拉图的推论：

推论一：若图为半欧拉图，当且仅当图中有两点度数为奇数，其他点度数皆为偶数且联通。

对于 _有向图_ 而言：

２.定理二：有向图为欧拉图，当且仅当它的基图联通，且所有点的入度等于出度即可。（注意区别）；

推论二：有向图为半欧拉图，当且仅当其中一个顶点的入度少于出度１，而另一点出度少于入度１，基图联通时。

知道了定理还需要了解一些性质才可以求解欧拉回路：

性质一：当c是图中一个简单回路，此回路删去，留下的图的各极大联通子图都存在一条欧拉回路。（显然，用点将各联通子图连接，才能形成欧拉回路。）

性质二：当Ｃ1Ｃ2是两个简单回路，无边相交，仅有一点公共，可以将其合并成另一个简单回路。

### 再贴上此题：
[糖果](https://www.luogu.org/problemnew/show/P1341#sub)
### 思路：
这道题是一道裸的欧拉路径的题目，对于此题，我们要将每一个字符化成一个点来看待，每次给出的关系都可以做为一条边来看待。

这样，我们不难发现，求某一个将所有关系满足的排列，就是在构造图中找到一条欧拉路径。

把它作为半欧拉图来看待，首先我们需要对它的存在性进行判断，如果出现了两个以上入度为一的点，那么毫无疑问此图不满足条件，输出"No Solution" 即可。

我们还要考虑几种情况，首先，可能不存在入度为一的点，那么构成欧拉图，也符合要求。其次，可能只有一个点入度为一，也是不符合的。这点需要特判。

对于此题的解决方法，容易让人想到的就是深搜，但还有许多细节需要注意：１.对于字母的处理，我们可以用到map存，一个存每个字母对应编号，另一个存每个编号对应字母，注意存图。（某龚姓大佬指点）；
２.搜索要注意回溯，尽量在每一个搜索树的层上保留每一步的数据；
３.此题情况较多要进行细致讨论（不要学我）；
４.满足题目要求，要按字典序处理（此时龚姓大佬又出场）先将边按字母序列排好，再建图（也可不建),遍历字母选择开端即可，预设字符串为空，每行一步加上即可。

贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e+5;
int n, cnt, t, start, end, step;
int head[N], next[N], to[N], w[N];
int du[N];
string s;
bool vis[N];
struct node{
    int to,from,p;
}edge[N];
map<int,char>letter;
map<char,int>num;
bool cmp(const node&a,const node&b){
    return a.to > b.to;
}
void add(int u, int v, int p){
    next[++t] = head[u];
    to[t] = v;
    w[t] = p;
    head[u] = t;
    ++du[u];
}

void dfs(int x, int step, string s){
    if(!x) return ;
    s+=letter[x];
    if(step == n + 1){
        if(x == end||end == 0){
            cout << s;
            exit(0);
        }//细节。
        return ;
    }
    for(int i = head[x]; i; i = next[i]){
        if(!vis[w[i]]&&!vis[w[i]^1]){
            vis[w[i]] = 1;
            dfs(to[i], ++step, s);//也可以写成step+1;可以减少回溯。
            vis[w[i]]=0;
            step--;//注意回溯。
        }
    }
}			

int main(){
    //freopen("unorder.in", "r", stdin);
    //freopen("unorder.out", "w", stdout);
    scanf("%d", &n);
    char a, b;
    for(int i = 0; i <= 25; i++){
        num[i +'A'] = i + 1, letter[i + 1] = i +'A';
        num[i +'a'] = i + 27,letter[i + 27] = i +'a';
    }//注意此处龚式处理。
    for(int i = 1; i <= n; i++){
        cin >> a >> b;
        edge[++cnt] = (node){num[a], num[b], i<<1};
        edge[++cnt] = (node){num[b], num[a], i<<1|1};//打上标记，可以有益于之后的判断，是不是很巧妙啊，可惜不是我想的。
    }
    sort(edge + 1, edge + cnt + 1, cmp);
    for(int i =1; i <= cnt; i++){
        add(edge[i].from, edge[i].to, edge[i].p);
    }
    for(int i = 1;i <= 52; i++){
        if(du[i] & 1){
            if(!start) start=i;
            else if(!end) end=i;
            else{
                printf("No Solution");
                return 0;
            }
        }
    }//特判，若没有，则随机找第一个入度为二即可。
    if(!start){
        for(int i = 1; i <= 52; i++){
            if(du[i]){
                start=i;
                break;
            }
        }
    }
    s="";
    dfs(start, step+1, s);
    printf("No Solution");
    return 0;
}	

```

---

## 作者：Rey_HR (赞：5)

# DFS
本题很明显是找一条**ASCII码最小的欧拉回路**，所以，我们自然相到用DFS。~~（虽然这是我第一次写欧拉回路）~~

数据范围是显而易见的————从'A'-'z'，共52个字母，所以我~~偷懒~~写了一个邻接矩阵~~（滑稽）~~

代码如下（具体看注释）：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int g['z' + 10]['z' + 10];
bool vis['z' + 10];
int n, head = 0x3f3f3f3f;
stack<int> s;
stack<int> ans;
bool dfs(int u)
{
	s.push(u);//我太懒了，直接用栈倒着存
	if (!g[u][0])//如果这个点无法继续扩展，那么就判断是否已经遍历所有点
	{
		bool flag = true;
		for (int i = 'A'; i <= 'z'; i++)
		{
			if (i == u) continue;
			if (vis[i]) flag = ((g[i][0] == 0) && flag);//如果这个点读入时出现过，就判断这个点有没有遍历到
		}
		if (!flag) s.pop();
		return flag;
	}
	for (int v = 'A'; v <= 'z'; v++)
		if (g[u][v])
		{
			g[u][v] = g[v][u] = 0;
			g[v][0]--;
			g[u][0]--;//删边
			if (dfs(v)) return true;//找到解，返回
			else//恢复这条边
			{
				g[u][v] = g[v][u] = 1;
				g[v][0]++;
				g[u][0]++;
			}
		}
	s.pop();//如果没找到解，出栈
	return false;
}
int main()
{
	ios::sync_with_stdio;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		char u, v;
		cin >> u >> v;
		g[u][v] = g[v][u] = 1;
		//记录边
		g[u][0]++;
		g[v][0]++;
		//记录这个点的度
		vis[u] = vis[v] = 1;//记录这两个点出现过
		head = min(head, min((int)u, (int)v));//找ASCII码最小的字母
	}
	for (int i = 'A'; i <= 'z'; i++)
		if (g[i][0] & 1)//如果欧拉回路有奇点，必定有两个，那么只要找到一个就把它作为起点
		{
			head = i;
			break;
		}
	dfs(head);//深搜
	while (!s.empty())//将栈中的元素放入另一个栈，这样顺序就对了
	{
		ans.push(s.top());
		s.pop();
	}
	if (ans.empty())//如果栈是空的，那么说明没找到欧拉回路
	{
		puts("No Solution");
		return 0;
	}
	while (!ans.empty())//输出答案
	{
		cout << (char)ans.top();//我是把字符当整形存的，所以输出时要强制转换成字符
		ans.pop();
	}
	cout << endl;
	//system("pause");
	return 0;
}
```
## P.S. 
'Z'和'a'之间的几个字符不用管，因为它们之间根本没有边

---

## 作者：森岛帆高 (赞：4)

### $0.$ 分析
字符串首等于尾，长度等于字母对数加一，并且每个字母对都要用上，很明显对每个字母对中的两个字母建边找欧拉回路，俗称一笔画（~~该死的老欧拉~~

### $1.$ [定义](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/10036484?fr=aladdin)

### $2.$ 判定
对于无向图：如果所有点的度数均为偶数，那么这是一个欧拉图，因为把每个点的出度和入度分配相等之后一定会回到初始离开的起点；如果仅有两个点的度数为奇数，那么这是一个半欧拉图，因为这两个点多出来的一个度数刚好被分配成出度和入度，即为起点的终点，它们是不相同的；否则它什么都不是滑稽。

对于有向图是类似的，出度和入度已经给你分配好了鸭。

### $3.$ 寻找
- 起点和终点

如果是欧拉图随便，半欧拉图找出两个特殊点（有向图是两者，无向图两者可以互换）。

- 路径

进行$dfs$，可行就走，还需探讨一个问题，为什么需要最后去存，倒序输出？

这里给出了一个直接存的反例。

![](https://cdn.luogu.com.cn/upload/pic/67063.png)

假定我们从左上角的点出发，先向右走，在向左下走。当我们来到有自环的点时，就出现毛病了。有两种选择，一是直接回到起点，虽然也构成了一个欧拉子图，但是并不能达到我们的要求，所以必须先绕着自环走完再回到起点。加之我们肯定得按照字典序选择，很大概率会走错。

仔细观察我们发现，每个点肯定连接着若干个环，这些环中分成三种：遍历完的、没遍历过的、遍历了一部分的。除去遍历完的，要跑出正确的路径，我们应该先选择没有遍历过的，最后再进入遍历了一部分的死胡同（出不来）。

记录下来非常不可做的样子，考虑到终点一定在遍历了一部分的环中（我们是从那里来的），我们之前的路径又一定是合法的，那么我们是不是可以逆推呢？也就是说，当我们走进死胡同时，不要先记录答案，以死胡同为起点再向外走，遍历完剩下的环后，按照原路返回不就行了吗？

理一下思路，当一个点没有路可以走时，才加入栈（字典序从小到大枚举，从大到小想不用栈是会导致第一位出错，因为第一位字母存在于头和尾，头要最小，而你考虑到的是要后面的最大，会将头尾置为最大，从而丧失了最重要的部分）中。

有向图非常相似就不说了。

至于数据范围比较玄学，算了一下$52*52=2704$

算法很简单，思维不简单。

时间复杂度$Θ(n)$~

***code:***
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 123
#define For(i,x,y)for(i=x;i<=y;i++)
string str;
bool g[N][N];
int deg[N],cnt;
void dfs(int u)
{
    int i;
    For(i,65,122)
    if(g[u][i])
    {
        cnt++;
        g[u][i]=g[i][u]=0;
        //记得清空的是无向路径
        dfs(i);
    }
    str=char(u)+str;
    //倒序
}
//欧拉回路
void no()
{
    cout<<"No Solution";
    exit(0);
}
//无解
int main()
{
    char x,y;
    int n,i,j,num=0;
    cin>>n;
    For(i,1,n)
    {
        For(j,0,1)getchar();
        x=getchar();
        y=getchar();
        g[int(x)][int(y)]=g[int(y)][int(x)]=1;
        //邻接矩阵存图
        deg[int(x)]++;
        deg[int(y)]++;
        //记录每个点的度数
    }
    For(i,65,122)
    if(deg[i]&1)num++;
    if(num&&num!=2)no();
    //性质
    For(i,65,122)
    if((num&&deg[i]&1)||(!num&&deg[i]))break;
    //寻找出发点
    dfs(i);
    if(cnt<n)no();
    else cout<<str;
    return 0;
}
```
>感谢观看！

---

## 作者：沉辰 (赞：4)

首先看题目要求，要求用n+1个字符表示出n个字母对（无序）  
那么仔细想一下，首尾相接也就是一个环  
考虑n个字母对就相当于n条边，字母相当于点
而又不重复，我们想到了什么？  
对，欧拉路（欧拉回路）  

我们在字母对之间建无向边，然后求欧拉路（欧拉回路），就是答案   
但是要注意，求欧拉路（欧拉回路）的首要条件是这个图已知是欧拉图   
对于判无解的情况，即这个图不是欧拉图。  
[代码](http://www.cnblogs.com/adelalove/p/8502664.html)

---

## 作者：Tanktt (赞：2)

由这道题，我才去学习了一下欧拉回路/欧拉路。。。其实只要符合两者之一就能够输出。欧拉路就是我们小奥里学的一笔画问题，如果出边个数为奇数个的数量为0或2就是，它包含了欧拉回路，因为欧拉回路就是数量为0时，能够走一圈后再回到出发点。对于输入的两个字符，就对他们连一条无向边。因为要是字典序最小，所以从ASCLL码小的开始，这道题需要把大小写字母改成数字，即离散化。而且如果只有偶点，那么就从出现的最小ASCLL码开始。


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y,in[50000],stack[50000],top,cnt,id;
bool e[100][100];
char s[10];
inline int calc(char x)
{
	if (x>='A'&&x<='Z') return x-'A'+1;
	if (x>='a'&&x<='z') return x-'a'+27;
}
inline char chr(int x)
{
	if (x>=1&&x<=26) return x+'A'-1;
	return x+'a'-27;
}
inline void dfs(int u)
{
	for (int i=1; i<=55; i++)
	if (e[u][i])
	{
		e[u][i]=e[i][u]=0;
		dfs(i);
	}
	stack[++top]=u;//倒着存，倒着输出↓
}
int main()
{
	scanf("%d",&n);
	for (int i=1; i<=n; i++)
	{
		scanf("%s",s);
		x=calc(s[0]),y=calc(s[1]);
		in[x]++;in[y]++;
		e[x][y]=e[y][x]=1; 
	}
	for (int i=1; i<=55; i++)
	if (in[i]%2==1)
	{
		cnt++;
		if (!id) id=i;
	}
	if (cnt!=0&&cnt!=2) return printf("No Solution\n"),0;
	if (cnt==0)
	for (int i=1; i<=55; i++)
	if (in[i]) {id=i;break;}
	dfs(id);
	for (int i=top; i>=1; i--)
	putchar(chr(stack[i]));
	return 0;
}
```

---

## 作者：qwerta (赞：2)

首先翻译一下题面吧。

>    给定n条无向边，试构造一条路径恰好经过每条边１次。

>    如果可以构造，输出途径的点的编号（多解则输出字典序最小的解）。

>    否则输出No Solution。

其实想明白所谓的字母对只是无向边的话，这道题就是很清晰的欧拉路径了。

>——以下来自[欧拉回路路径求解 - STILLxjy - CSDN博客](https://blog.csdn.net/stillxjy/article/details/51956183)——

>    Hierholzer 算法：
    另一种计算欧拉路的算法是 Hierholzer 算法。这种算法是基于这样的观察：
    
>![](https://i.loli.net/2018/09/30/5bb0436ae37ac.png)

>    在手动寻找欧拉路的时候，我们从点 4 开始，一笔划到达了点 5，形成路径 4-5-2-3-6-5。此时我们把这条路径去掉，则剩下三条边，2-4-1-2 可以一笔画出。

>    这两条路径在点 2 有交接处（其实点 4 也是一样的）。那么我们可以在一笔画出红色轨迹到达点 2 的时候，一笔画出黄色轨迹，再回到点 2，把剩下的红色轨迹画完。

>    由于明显的出栈入栈过程，这个算法可以用 DFS 来描述。
    如果想看得更仔细一点，下面是从点 4 开始到点 5 结束的 DFS 过程，其中 + 代表入栈，- 代表出栈。
    4+ 5+ 2+ 3+ 6+ 5+ 5- 6- 3- 1+ 4+ 2+ 2- 4- 1- 2- 5- 4-
    我们把所有出栈的记录连接起来，得到
    5-6-3-2-4-1-2-5-4

>    诸位看官可以自己再选一条路径尝试一下。不过需要注意的是，起始点的选择和 Fleury 要求的一样。
    这个算法明显要比 Fleury 高效，它不用判断每条边是否是一个桥。

然后就套Hierholzer的板子就好啦。

~~（实在没懂怎么“计算得到”n的规模，好在不用这个条件QAQ~~
```
 1 /*
 2     qwerta
 3     P1341 无序字母对
 4     Accepted
 5     100
 6     代码 C++，1.46KB
 7     提交时间 2018-09-30 11:11:47
 8     耗时/内存
 9     28ms, 1052KB
10 */
11 #include<algorithm>
12 #include<iostream>
13 #include<cstdio>
14 #include<stack>
15 using namespace std;
16 int g[253][253];
17 int d[253];//度数
18 stack<int>st;//这个是记录栈，不是搜索栈！    
19 void dfs(int x)//dfs找点
20 {
21     for(int j='A';j<='z';++j)//这样循环就可以保持字典序最小啦
22     if(g[x][j])
23     {
24         g[x][j]--;
25         g[j][x]--;//反向边也要删
26         dfs(j);//继续递归
27     }
28     st.push(x);//出栈的时候记录下来
29     return;
30 }
31 int fa[257];//用并查集维护是否有多个联通块
32 int fifa(int x)
33 {
34     if(fa[x]==x)return x;
35     return fa[x]=fifa(fa[x]);
36 }
37 int main()
38 {
39     //freopen("a.in","r",stdin);
40     ios::sync_with_stdio(false);
41     cin.tie(false),cout.tie(false);//关闭同步流（cin伴侣
42     int n;
43     cin>>n;
44     for(int i='A';i<='z';++i)//初始化并查集
45     fa[i]=i;
46     for(int i=1;i<=n;++i)
47     {
48         char x,y;
49         cin>>x>>y;
50         g[x][y]++;
51         g[y][x]++;//临接矩阵存边
52         d[x]++;
53         d[y]++;//度数＋＋
54         int u=fifa(x),v=fifa(y);
55         if(u!=v)fa[u]=v;//维护并查集
56     }
57     //判定是否有解
58     int num=0;
59     for(int i='A';i<='z';++i)
60     if(d[i]%2==1)num++;
61     if(num!=0&&num!=2){cout<<"No Solution";return 0;}
62     int tag=0;
63     for(int i='A';i<='z';++i)
64     if(d[i])
65     {
66         if(!tag)tag=i;
67         else if(fifa(tag)!=fifa(i)){cout<<"No Solution";return 0;}
68     }
69     //找是否有奇点
70     int s=-1;
71     for(int i='A';i<='z';++i)
72     if(d[i]%2==1){s=i;break;}
73     if(s==-1)//如果没有奇点就找AscII最小的点
74       for(int i='A';i<='z';++i)
75       if(d[i]){s=i;break;}
76     dfs(s);//递归找点
77     while(!st.empty())
78     {
79         cout<<(char)st.top();
80         st.pop();
81     }//输出
82     return 0;
83 }
```

---

## 作者：楠山 (赞：2)

这是一个欧拉路问题，把每两个点间加一个无向边，判断每个点的度是否为偶数（欧拉回路），或者有两个点是奇数（欧拉路径）。然后找到欧拉路径的起点或回路的字典序最小点，开始dfs。


```cpp
#include<cstdlib>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;
int n;
int du[60];//储存每个点的度 
char s[3];
struct node
{
    int now,id;//现在的点，编号 
};
vector<node> g[60];//图 
vector<int> eg;//输出 
bool vis[10010],vis1[60];//建图，输出 
void dfs(int a)
{
    for(int j=0;j<g[a].size();j++)
    {
        if(vis1[g[a][j].id]==1)continue;
        vis1[g[a][j].id]=1;
        dfs(g[a][j].now);
    }
    eg.push_back(a);
}
bool compare(node aa,node bb){return aa.now<bb.now;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s);
        int a=s[0]-'A'+1;
        int b=s[1]-'A'+1;
        du[a]++;
        du[b]++;
        g[a].push_back((node){b,i});
        g[b].push_back((node){a,i});
        vis[a]=1;
        vis[b]=1;
    }
    for(int i=1;i<60;i++)//字典序排序
    sort(g[i].begin(),g[i].end(),compare);
    int cnt=0;
    for(int i=1;i<60;i++)if(du[i]%2==1)cnt++;
//    for(int i=1;i<60;i++)printf("%d ",du[i]);
//    printf("\n%d\n",cnt);
    if(cnt==1||cnt>2){printf("No Solution");return 0;}//不是欧拉路就是无解
    else 
    {
        int start;
        for(int i=1;i<60;i++)//欧拉回路 
        if(vis[i]==1)//欧拉回路就任选一点
        {
            start=i;
            break;
        }
        for(int i=1;i<60;i++)//欧拉路径选起点
        if(du[i]%2==1)
        {
            start=i;
            break;
        }
        dfs(start);
    }
    for(int i=eg.size()-1;i>=0;i--)//因为是dfs所以倒叙
    printf("%c",eg[i]-1+'A');
    return 0;
} 

```

---

## 作者：intruder (赞：2)

多给C党一点爱

把两个字母拆成两个顶点 然后构造一个无向图 ，这样根据欧拉回路 当一个图中每个点的度数都是偶数时 纯在欧拉环 而只有2个奇数度数时，存在欧拉路径 因此先验证一下然后dfs 这里为了储存答案我用了双端队列，当然也可以不用 偷点懒，至于最小字典序的话 拍一下序就好了 而如果你用 vector的话 直接从小到大排序（我就是这么做的），而如果你用链表的号 需要首字母从小到大 第二个字母从大到小



```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<stack>
#include<algorithm>
#include<cstdlib>
#include<queue>
#define maxn 3000
#define PB(a)   push_back(a)
using namespace std;
deque<char>ans;
vector<int >son[102];
int n,in[maxn],checked[maxn],vis[maxn][maxn];
struct cur_word{
    int a,b,nu;
    bool operator<(const cur_word r)const{
        return a==r.a?b<=r.b:a<=r.a;
    }
}word[2*maxn];
void dfs(int u,int deep){
    ans.push_back(u+'A');
    if(deep==n+1){
        int gg=0;
        while(!ans.empty()){
            char x=ans.front();
            printf("%c",x);
            ans.pop_front();
        }
        exit(0);
    }
    for(int i=0;i<son[u].size();i++){
        int y=son[u][i];
        if(!vis[u][y]&&!vis[y][u]){
            vis[u][y]=1;
            dfs(y,deep+1);
            vis[u][y]=0;
        }
    }
    ans.pop_back();
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        char s[3];
        scanf("%s",s);
        int a=s[0]-'A',b=s[1]-'A';
        in[b]++,in[a]++;
        word[i].a=a,word[i].b=b;
        word[i+n].a=b,word[i+n].b=a;
    }
    sort(word+1,word+2*n+1);
    int ccnt=0,start2=-1,start0=-1;
    for(int i=1;i<=2*n;i++){
        int x=word[i].a ,y=word[i].b;
        son[x].PB(y);
        son[y].PB(x);
        if((in[x])%2&&!checked[x]){
            checked[x]=1,ccnt++;
            if(start0==-1)start0=x;
        }
        if(in[x]==2&&start2==-1)start2=x;
    }
    if(ccnt!=0&&ccnt!=2){
        printf("No Solution");
        exit(0);
    }
    if(ccnt==2)dfs(start0,1);
    if(ccnt ==0)dfs(start2,1);
    return 0;
}
```

---

## 作者：shijunfeng00 (赞：2)

一次性A了..莫名兴奋,来一发题解

这个题就是欧拉回路/通路的题

可能是和回路,,也可能只是通路

这取决于度数奇数的点的个数

0 回路

2 通路

>=3 无解
for循环一遍,记录最小的度数为奇数的点的编号a

如果没有那么就将a=minueed（按字典序出现的最小的字母）

然后求一遍欧拉回路

用的静态链表（链式前向星）

所以求欧拉路的时候有点麻烦

因为是要要输出字典序最小的

所以我们不妨在求解之前对点的顺序排个序

我们就用他在字典序中的顺序代表这个点的顺序建立一个图

图中的点当然就是52拉

不多
所以我写个一个似乎是唯一一个不是0ms的AC代码（哎）

除了建图以外……欧拉回路基本上就是套模板搞定了

```cpp
#include<iostream>
#include<cstring>
#include<queue> 
#include<algorithm>
#define maxn 100005
```
class node
{
public:

    int x,y;

}t[maxn]; 

class side

{
public:

    
```cpp
    int from,to,next,last;
}edge[maxn];
int head[maxn],len,ansi,ans[maxn];
int indegree[maxn];
bool visit[maxn*2];
bool cmp(int a,int b){return edge[a].to<edge[b].to;}
bool alpha[60];
using namespace std;
void ins(int x,int y)
{
    indegree[y]++;
    edge[++len].from=x;
    edge[len].to=y;
    edge[len].next=head[x];
    head[x]=len;
}
void eulor(int now)
{
    int temp_k[101],sum=0;
    for(int k=head[now];k;k=edge[k].next)
    {
        temp_k[sum++]=k;
    }
    sort(temp_k,temp_k+sum,cmp);
    for(int i=0;i<sum;i++)
    {
        int k=temp_k[i];
        if(!visit[k])
        {
            visit[k]=true;
            if(k%2==1)visit[k+1]=true;
            else visit[k-1]=true;
            eulor(edge[k].to);
            ans[ansi++]=k;
        }
    }
}
int main()
{
    int n,m,min_used=100,max_used=-10;      //用到的最大字母和最小字母 
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        char tx,ty;
        cin>>tx>>ty;
        x=tx-'A'+1;
        y=ty-'A'+1;
        ins(x,y);                          //建图 
        ins(y,x);
        n=max(n,max(x,y));
        min_used=min(min_used,min(x,y));        //记录最大/最小的点的编号 
        max_used=max(max_used,max(x,y));
        alpha[x]=1;alpha[y]=1;                 //标记,这个字母出现过 
    }
    int num_indegree=0,min_eulor=max_used;     
    for(int i=min_used;i<=max_used;i++)
    {
        if(alpha[i])
        {
            if(indegree[i]==0)
            {
                cout<<"No Solution";
                return 0;
            }
            if(indegree[i]%2==1)
            {
                num_indegree++;
                min_eulor=min(min_eulor,i);
            }
            if(num_indegree>=3)
            {
                cout<<"No Solution";
                return 0;
            }
        }
    }
    if(num_indegree==0)min_eulor=min_used;
    eulor(min_eulor);
    for(int i=ansi-1;i>=0;--i)
    cout<<char(edge[ans[i]].from+'A'-1);
    cout<<char(edge[ans[0]].to+'A'-1);
}
```
莫名AC..

---

## 作者：Vimin (赞：1)

# 题目传送[P1341](https://www.luogu.org/problem/P1341)
## 欧拉路
- 欧拉定理 无向图欧拉回路中所有点的度数都是偶数，有向图有两个奇数点
- $dfs$做法，先根据欧拉定理，判断是欧拉回路还是半欧拉图，欧拉回路直接从最小的$A$开始搜，半欧拉图从奇数度点开始搜。
- 走到都被标记后回溯，记录点，倒序输出就是欧拉回路
## 代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y,minn=2000,cnt,res;
char a,b;
int e[100][100],t[100],d[100],now[100];
void dfs(int x){
	for(int i=0;i<58;i++)
	  if(e[x][i]){
	  	e[x][i]=e[i][x]=0;
	  	dfs(i);
	  }
	t[++cnt]=x;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		cin>>a>>b;
		x=a-'A';
		y=b-'A';	
		e[x][y]=1;e[y][x]=1;
		d[x]++;d[y]++;
		minn=min(minn,min(x,y));
	}
	for(int i=0;i<58;i++)
	  if(d[i]%2) now[++res]=i;
	if(res==0) dfs(minn);
	else if(res==2) dfs(now[1]);
	else {
		printf("No Solution\n");
		return 0;
	}
	for(int i=cnt;i>=1;i--)
	  printf("%c",t[i]+'A');
	return 0;
} 
```

---

## 作者：SS_Yi (赞：1)

在这里介绍一种set的做法 set是一个集合，会自动对集合内元素从小到大排序并自动去重 如果不需要去重的话可以用multiset 这样用起来就很舒服了 其余的就是欧拉回路的板子 具体看代码吧
```cpp
#include<iostream>
#include<algorithm>
#include<queue>
#include<set>
using namespace std;
set<int> que;
multiset<int>mp[100];
int n,m,ds[100],s=-1,e=-1,at;
char ans[100];
void dfs(int u)
{
	set<int>::iterator it;
	for (it=mp[u].begin();it!=mp[u].end();it=mp[u].begin())
	{
		int v=*it;
		mp[u].erase(it);
		mp[v].erase(mp[v].find(u));
		dfs(v);
	}
	ans[at++]=u+'A';
}
int main()
{
	cin>>m;
	for (int i=0;i<m;i++)
	{
		char a,b;
		cin>>a>>b;
		ds[a-'A']++;ds[b-'A']++;
		mp[a-'A'].insert(b-'A');
		mp[b-'A'].insert(a-'A');
		que.insert(a-'A');que.insert(b-'A');
	}
	for (set<int>::iterator it=que.begin();it!=que.end();it++)
	{
		int x=*it;
		if (ds[x]%2==1)
		{
			if (s==-1) s=x;
			else if (e==-1) e=x;
			else {
				cout<<"No Solution"<<endl;
				return 0;
			}
		}
	}
	if (s==-1) s=*que.begin();
	dfs(s);
	for (int i=at-1;i>=0;i--) cout<<ans[i];
}
```

---

## 作者：林志杰 (赞：1)

将字母转化成点，每一对字母组之间连点，问题转化为找欧拉路径。注意几点：

1.字典序

2.判断是否有欧拉路径，可以根据定义，欧拉路径中没有或有两个度数为奇数的点。

3.判断是欧拉路经还是欧拉回路。

几乎是很裸的欧拉路径的题目









```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn = 600;
int n,inn[maxn],cnt=0;//inn表示度数
int s[maxn];
int cxt[maxn][maxn];
string S = "No Solution";
inline int judge(char x)
{
    if(x <= 'z' && x >= 'a') return x - 'a' + 27;
    else return x - 'A' + 1;
}
inline char print(int x)
{
    if(x <= 26) return 'A' + x - 1;
    return 'a' + x - 27;
}
inline void addedge(int u,int v)
{
    ++inn[u];++inn[v];
    cxt[u][v] = cxt[v][u] = 1;
}
void Eular(int x)
{
    for(int i=1;i<=52;i++) if(cxt[x][i]) {
        cxt[x][i]=cxt[i][x]=0;
        Eular(i);
    }
    s[++cnt] = x;//记录路径 
}
int main()
{
    cin>>n;
    char a,b;
    char ch[5]; 
    for(register int i=1;i<=n;i++) {
//      cin>>a>>b;
        scanf("%s",ch);
        addedge(judge(ch[0]),judge(ch[1]));
    }
    int p = 0x7fffffff;
    for(register int i=1;i<=52;i++)//找到度数为奇数的点，也就是欧拉回路的起点 
        if(inn[i]&1) {//欧拉路径起点 
            p = min(p,i);
            ++cnt;
        }
    if(cnt != 0 && cnt != 2) {//不是欧拉路经或欧拉环 
        cout<<S;
        return 0;
    }
    if(cnt == 0)//欧拉环，找字典序最小的起点 
    for(int i=1;i<=52;i++) if(inn[i]) {
        p = i;
        break;
    }
    cnt = 0;
    Eular(p);//找欧拉路径
    for(int i=cnt;i>=1;--i) printf("%c",print(s[i]));//逆序输出 
    return 0;
}
```

---

## 作者：Zzh20011004 (赞：1)

这道题好难

一开始找到字典序最小的点就去搜索

结果wa了

后来一想因为序列长度n+1

因此一定是欧拉回路或者通路

如果入度为奇数的点的个数为2即为欧拉通路

入度为奇数的点为0为欧拉回路

其他无解

因为欧拉路是dfs逆序的

因此我们可以dfs时按照字典序小的开始搜索

搜完的情况是字典序从大到下

因为a->b为欧拉路,一定有b->a为欧拉路

把序列反过来输出即可

附上代码

```cpp
#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
#define re register
std::vector<int>    ans;
int n,g[65][65],d[65];
char str[5];
inline char tochar(int x)
{
    if(x>=1 && x<=26)
        return x-1+'A';
    else    return x-27+'a';
}
inline int getnum(char ch)
{
    if(ch>='A' && ch<='Z')
        return ch-'A'+1;
    else    return 27+ch-'a';
}
inline void dfs(int now)
{
    for(re int i=1;i<=52;i++)
    {
        if(g[now][i])
        {
            g[now][i]=g[i][now]=0;
            dfs(i);
        }
    }
    ans.push_back(now);
}
int main()
{
    int cnt=0,u1=1e9+7,u2=1e9+7;
    scanf("%d",&n);
    for(re int i=1;i<=n;i++)
    {
        scanf("%s",str);
        int u=getnum(str[0]),v=getnum(str[1]);
        g[u][v]=g[v][u]=1;
        d[u]++;d[v]++;
    }
    for(re int i=1;i<=52;i++)
    {
        if(d[i]&1)
        {
            cnt++;
            u1=std::min(u1,i);
        }
        else
        {
            if(d[i]!=0)        u2=std::min(u2,i);
        }
    }
    if(cnt!=0 && cnt!=2)
    {
        printf("No Solution\n");
        return 0;
    }
    if(!cnt)    dfs(u2);
    else    dfs(u1);
    reverse(ans.begin(),ans.end());
    for(int i=0;i<ans.size();i++)
        printf("%c",tochar(ans[i]));
    return 0;
}
```

---

## 作者：ljc20020730 (赞：1)

题目描述：给定n条边，每条边连接两个字母，求一条经过所有边的路径。

解题思路：看清这道题的本质之后，这题是道典型的求欧拉路径问题，可以用来熟练欧拉路径的算法。

{
给出字母对建立无向图求是否存在欧拉路经，

如果有dfs求出最小字典序的欧拉路径

```cpp
}
uses math;
var n,i,x,y,k,tot:longint;
    b:array[0..106,0..106]of boolean;
    c,du,a:array[0..10006]of longint;
    s:string;
procedure dfs(u:longint);
var i:longint;
begin
 for i:=0 to 58 do 
  if b[u,i] then begin //图中有数字为i这样的点
   b[u,i]:=false;
   b[i,u]:=false; //遍历完成
   dfs(i);//往下dfs
  end;
  inc(tot);
  c[tot]:=u;//回溯加起来
end;
begin
 readln(n);
 k:=maxlongint;
 fillchar(b,sizeof(b),false);
 fillchar(du,sizeof(du),0);
 fillchar(a,sizeof(a),0);
 for i:=1 to n do begin
  readln(s);
  x:=ord(s[1])-ord('A');
  y:=ord(s[2])-ord('A');//字母映射到数
  k:=min(k,min(x,y));//图中字典序最小的点为k（不保证入度mod 2 =1）
  b[x,y]:=true;
  b[y,x]:=true; //邻接矩阵存图
  inc(du[x]);
  inc(du[y]);//入度++
 end;
 for i:=0 to 58 do
  if du[i] mod 2=1 then begin //如果某一点的入度为奇数
   inc(a[0]);a[a[0]]:=i; //把改点加入a序列a[0]是有几个这样的点
  end;
 if a[0]=0 then begin dfs(k); end //没有奇点字典序最小的开始dfs
 else
  if a[0]=2 then dfs(a[1])//两个奇点从字典序小的一个开始（遍历0-58）
 else//否则多于3个奇点或者有1个奇点就不可能
 begin
  writeln('No Solution');
  halt;
 end;
 for i:=tot downto 1 do write(chr(c[i]+ord('A')));//打印
 writeln;
end.
```

---

## 作者：lzcjoe (赞：1)

# P1341 无序字母对 题解

## 1. 思路和算法

### 1. 欧拉路 Hierholzer 算法

#### 1. 欧拉路、欧拉回路

如果图中的一条路径包括每个边恰好一次，则该路径称为欧拉路径。

如果欧拉路径是一条回路，则称为欧拉回路。

#### 2. 欧拉路存在性的判定：

图连通，当且仅当该图所有顶点的度数（边数）为偶数，或者除了两个度数为奇数外其余的全是偶数。

#### 3. Hierholzer 算法思想

通过递归寻找与某一点相连的边，删除此边，再以此边的终点进行递归，将已经遍历的点加入答案序列中，再倒序输出答案队列。

就相当于逐步插入边，判断图的每一个边是否用到。

### 2. 本题思路

本题可以将每一个字符看作一个点，要求在一起的字符串为两点之间的连边，即可看作是求此图的欧拉路。

## 2. 代码实现

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
unsigned short int a[60][60];//图
unsigned short int d[60];//度数
unsigned short int way[1800];
//记录答案的序列，开大点保险
unsigned short int n,from,to,s,maxl=0,minl=60;
unsigned short int cnt;
char b,c;
void find(unsigned short int i)
//Hierholzer算法的递归
{
    unsigned short int j;
    for(j=minl;j<=maxl;j++)//找边
    {
        if(a[i][j]>0)
        {
            a[i][j]--;
            a[j][i]--;
            find(j);//递归
        }
    }
    cnt++;
    way[cnt]=i;//记录答案序列
    return;
}
unsigned short int maxi(unsigned short int x,unsigned short int y)
//手写最大函数
{
    return x>y?x:y;
}
unsigned short int mini(unsigned short int x,unsigned short int y)
//手写最小函数
{
    return x<y?x:y;
}
int main()
{
    unsigned short int i,t=0;
    bool f;
    scanf("%hd",&n);
    for(i=1;i<=n;i++)
    {
    	cin>>b>>c;
        b-=64;
        c-=64;
        unsigned short int e=(int)b,f=(int)c;
        a[e][f]++;
		a[f][e]++;
        d[e]++;
        d[f]++;
        //将字符转为数字当作点的序号
        maxl=maxi(maxl,maxi(e,f));
        minl=mini(minl,mini(e,f));
        //寻找最大、最小序号
    }
    cnt=0;
    s=minl;
    for(i=minl;i<=maxl;i++)
    {
        //判断奇数度的点
        if(d[i]%2==1)
        {
            if(f==0)
            {
            	s=i;
            	f=1;
            }
            t++;
        }
    }
    if(t>2)
    //欧拉路存在性的判定
    {
    	printf("No Solution");
    	return 0;
	}
    find(s);
    if(cnt<n+1)
    //若答案序列中没有n+1个元素，则此图不存在欧拉路
    {
    	printf("No Solution");
    	return 0;
    }
    for(i=cnt;i>0;i--)
    {
    	way[i]+=64;
        printf("%c",way[i]);
        //倒序输出
    }
    return 0;
}
```

评测结果

Accepted  100 

用时: 29ms / 内存: 820KB

---

## 作者：Dorg (赞：1)

今天实在是太累了。。。

赶《堂吉诃德》。。。（淦！！！）

把昨天的没干掉的蓝题干掉了，?，水平又下降了。。。

------------
题目：[ P1341 无序字母对](https://www.luogu.org/problemnew/show/P1341)

一道有点小烦的欧拉回路题。


------------
思路如下：
	
    1. 存图建议使用连接矩阵（链式前向星炒烦，莫问我怎么知道的）
    2. 数据处理是关键点，我的转换很裸：
            A-1 B-2...Z-26 a-27...z-52
       粗暴有效
    3. 判断图是否为一个存在欧拉路的图，分两类：
    		a）不在一张图里，并查集。
            b）奇节点数不是0或2。
    4. 找起点：
    		a)存在奇节点，取最小。
            b）不存在奇节点，直接找最小。
    5. 接下来就乱搞dfs吧。
    

------------

```cpp
#include<bits/stdc++.h>
#define Maxn 54
#define Maxm 10000

using namespace std;

//变化，将字母转成数字顺序，便于处理
int change(char a){
	if(a>='A' && a<='Z')
		return (a-'A'+1);
	
	if(a>='a'&&a<='z'){
		return (a-'a'+1+26);
	}
	
}
char uch(int a){
	char now;
	if(a>=1&&a<=26)
		now='A'+a-1;
	if(a>=27&&a<=52)
		now='a'+(a-26)-1;
	return now;
}

int Map[Maxn][Maxn];
int du[Maxn];

//并查集
int fa[Maxn]; 
int find(int a){
	if(fa[a]!=a)
		fa[a]=find(fa[a]);
	return fa[a];
}
void add(int a,int b){fa[find(a)]=find(b); return;}

//DFS
int vis[Maxn][Maxn];
int ans[Maxm];
int n;
void print(){
	for(int i=1;i<=n+1;i++)
		cout<<uch(ans[i]);
}
void dfs(int now,int cnt){
	
	ans[cnt]=now;
	bool flag=true;
	if(cnt==n+1){
		print();
		exit(0);
	}
	for(int i=1;i<=52;i++){
		if(Map[now][i]==1&&vis[now][i]==0){
			flag=false;
			vis[now][i]=1; vis[i][now]=1;
			dfs(i,cnt+1);
			vis[now][i]=0; vis[i][now]=0;
		}
	}
	
}

int main(){
	
	//init
	for(int i=1;i<=52;i++)
		fa[i]=i;
	
	
	cin>>n;
	
	for(int i=1;i<=n;i++){
		char x1,x2; cin>>x1>>x2;
		int a1,a2; a1=change(x1); a2=change(x2);
		Map[a1][a2]=1; Map[a2][a1]=1;
		du[a1]++; du[a2]++;
		add(a1,a2);
	}
	
    //判断是否是一张图 
	int root_num=0;
	for(int i=1;i<=52;i++)
		if(du[i]!=0&&fa[i]==i)
			root_num++;
	if(root_num!=1){
		cout<<"No Solution";
		return 0;
	}
	
	//奇节点
	int st=-1;//开始的节点
	int ji_num=0;
	for(int i=1;i<=52;i++)
		if(du[i]!=0&&du[i]%2==1){
			ji_num++;
			if(st==-1)
				st=i;
		}
	if(!(ji_num==0||ji_num==2)){
		cout<<"No Solution";//欧拉图规律
		return 0;
	}
	//偶节点
	if(st==-1){
		for(int i=1;i<=52;i++)
			if(du[i]!=0){
				st=i;
				break;
			}
	}
	
	dfs(st,1);
	
	return 0;
}
```

---

## 作者：Leo_Jiang (赞：0)

这道题就是一个变型的欧拉回路。

也就是：**将数字表示的点换成了字母**

所以只要**将字母当成数字理解**，就没什么难度了；

所以我写了个这个：
## 格式化
```
void format(){
	if(a>='a'&&a<='z') i = a-'a'+27;
	else if(a>='A'&&a<='Z') i = a-'A'+1;
	
	if(b>='a'&&b<='z') j = b-'a'+27;
	else if(b>='A'&&b<='Z') j = b-'A'+1;
}
```
写这个的原因是：我不想把数组开大（虽然可以开那么大）

经过这一番格式化后，所有可能出现的字母都被转换成了1~56的数字

**然后就很棒~~~**

然后敲一个欧拉回路——

发现给自己挖了一个坑：

输出好像也要格式化。。。。。。
```
void print(){
	char t;
	if(point < n+1){
		cout<<"No Solution";
		return;
	}
	for(int o = point;o>=1;o--){
		if(path[o]>=1&&path[o]<=26) t = path[o]+'A'-1;
		else if(path[o]>=27&&path[o]<=52) t = path[o]+'a'-27;
		cout<<t;
	}
}
```
**然后又很棒~~~**

上全代码+注释----->
```
#include<iostream>
using namespace std;  //解封印之术

const int maxx = 53;  //26 + 26 + 1 = 53

int n,g[maxx][maxx],du[maxx],path[1000],i,j,start,cnt,point;
//相邻数，图，度，欧拉回路，格式化对应的两个数字，起点，欧拉回路指针
char a,b;
//两个字母
void format(){
//传入字母a,b
	if(a>='a'&&a<='z') i = a-'a'+27;    //如果是a~z，减去‘a'后加上1+26，这是因为ascll码中小写在大写的后面
	else if(a>='A'&&a<='Z') i = a-'A'+1;
	
	if(b>='a'&&b<='z') j = b-'a'+27;	//同理
	else if(b>='A'&&b<='Z') j = b-'A'+1;
}
void search(int m){
	for(int n=1;n<=maxx;n++){
		if(g[m][n]){
			g[m][n]--;
			g[n][m]--;
			search(n);
		}
	}
	path[++point] = m;
	return;
    
   //有趣的一笔画
}
void print(){
	char t;
	if(point < n+1){  //这是一个小点子，因为点数和边数+1要相等
		cout<<"No Solution";
		return;
	}
	for(int o = point;o>=1;o--){
		if(path[o]>=1&&path[o]<=26) t = path[o]+'A'-1;
		else if(path[o]>=27&&path[o]<=52) t = path[o]+'a'-27;
		cout<<t;
	}
   //自己挖的坑自己填
}
int main(){
	cin>>n;
	for(int o = 1;o<=n;o++){
		cin>>a>>b;
		format();
		g[i][j]++;
		g[j][i]++;
		du[i]++;
		du[j]++;
	}
	for(int o =1;o<=maxx;o++){
		if(du[o]%2){
			cnt++;
			if(!start) start=o;
		}
	}
   //找奇数度的点
	if(!start){//没找到。。。。。。
		for(int o = 0;o<maxx;o++){
			if(du[o]){
				start = o;
				break;
			}
		}
      //随便找个偶数点
	}
	if(cnt && cnt!=2){//如果奇数点不是有且仅有两个
    //（欧拉路径的结论，可以自行学习[欧拉回路](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/10036484?fr=aladdin)）
		cout<<"No Solution";
		return 0;
	}
	search(start); //玩玩一笔画
	print(); //填坑
	return 0; //封印
}
```


## 总结
本程序最大的亮点就是坑

将字母转换成了1~56的数字

其它都很正常

谢谢大家

迟到的儿童节快乐~

---

## 作者：glimmer (赞：0)

此题还是比较简单的。

对于题目的意思还是比较好理解的。对于给出的要求，及时将字母之间连边即可（构图还是比较简单的）

之后题目是要求的是满足所有要求的字典序最小的字符串。由于是要求满足所有条件，很容易联想到要走过所有边，那么这就是一个欧拉回路。

之后注意合法判断即可（具体见代码）

【accepted code】
```
#include<bits/stdc++.h>
using namespace std;

int n;
int vhash[1100][1100];
int tot=0;
int vis[11000];
int gin[11000];

void readp(){
    cin>>n;
    for(int i=1;i<=n;i++){
        string st;
        cin>>st;
        int x,y;
        x=st[0];y=st[1];
        vis[st[0]]=1;
        vis[st[1]]=1;
        vhash[x][y]++;vhash[y][x]++;
        gin[x]++;
        gin[y]++;
    }
}

int ans[11100],cnt=0;

void dfs(int pos){
    for(int i='A';i<='Z';i++)
    if(vhash[i][pos]>0){
        vhash[i][pos]--;//删边大法好
        vhash[pos][i]--;
        dfs(i);
    }
    for(int i='a';i<='z';i++)
    if(vhash[i][pos]>0){
        vhash[i][pos]--;
        vhash[pos][i]--;
        dfs(i);
    }
    ans[++cnt]=pos;
}

void work(){
    int tip=-1;
    int qt=0;
    for(int i='A';i<='Z';i++)
    if(vis[i]==1){
        if(gin[i]%2!=0)qt++;
        if(tip==-1)tip=i;
        if(gin[tip]%2==0&&gin[i]%2!=0){
            tip=i;
        }
    }//两者效果一样，只不过是两个分开的解集
    for(int i='a';i<='z';i++)
    if(vis[i]==1){
        if(gin[i]%2!=0)qt++;
        if(tip==-1)tip=i;
        if(gin[tip]%2==0&&gin[i]%2!=0){
            tip=i;
        }
    }
    
    dfs(tip);
    //判断it is very important 
    if(qt&&qt!=2)cout<<"No Solution"<<endl;
    else if(cnt<n+1)cout<<"No Solution"<<endl;
    else {
        for(int i=cnt;i>=1;i--)
        cout<<char(ans[i]);
        cout<<endl;
    }
}

int main(){
    readp();
    work();
    return 0;
}
```

最后感谢管理员百忙之中，审核此题解，望管理员dalao 斧正



---

## 作者：MrBlack (赞：0)

本题在判断欧拉回路的时候相对容易，判断欧拉路的时候要判断一下图是否连通，否则无法遍历完整张图。

这里在判断图是否连通的时候，我选择使用割边来判断。每次**碰到奇数个度点的端点时就判断一次割边**，如果该边是割边而且不是最后一条边的话，那就先不输出。

在选择图的存储方式上，我选择邻接矩阵。1是需要字典序输出还有删除边的时候相对容易，2是数据量不是很大邻接矩阵也不会T。

附上代码：

```cpp
#include<iostream>
#include<queue>
#include<string>
#include<cstring>
using namespace std;

int edge[53][53];  //按字典序排序还是邻接矩阵方便
int dudian[53];
int n;
bool gebian[53][53];
int num[53], low[53];

void dfs(int father, int node)  //父结点和子节点，找割边
{
    num[node] = num[father] + 1;  //初始化
    low[node] = num[node];  //最多能访问到自己
    for (int i = 1; i <= 52; i++)
    {
        if (edge[node][i])
        {
            if (!num[i])
            {
                //child++;
                dfs(node, i);
                low[node] = min(low[node], low[i]);
            }
            else
            {
                if (i != father)
                {
                    low[node] = min(low[node], num[i]);
                }
            }
        }
    }
    if (low[node] > num[father])
    {
        gebian[father][node] = gebian[node][father] = 1;
    }
}

int Hash(char c)
{
    if (isupper(c))
    {
        return c - 'A' + 1;
    }
    else if (islower(c))
    {
        return c - 'a' + 27;
    }
    return 0;
}

char anti_Hash(int i)
{
    if (i < 27)
    {
        return i + 'A' - 1;
    }
    else
    {
        return i + 'a' - 27;
    }
}

void oula(int start)  //欧拉路就是一笔画问题
{
    cout << anti_Hash(start);
    for (int i = 0; i < n; i++)  //n条边
    {
        if (edge[start][start] && dudian[start] == 1)
            //相同点的情况要特判，否则可能回不来
            //要在度点数为1的情况下特判
        {
            cout << anti_Hash(start);
            edge[start][start] = 0;
            continue;
        }
        for (int j = 1; j <= 52; j++)
        {
            if (edge[start][j])
            {
                if (dudian[start] == 1)  //割边也能输出，先判断度点是否为1
                {
                    if (start != j)
                    {
                        dudian[start]--;
                        dudian[j]--;
                    }
                    edge[start][j] = edge[j][start] = 0;
                    start = j;
                    cout << anti_Hash(start);
                    break;
                }
                if (dudian[start] % 2 == 1)  
                    //度点是奇数要重新判断一下割边，有些可能变成割边了
                {
                    memset(num, 0, sizeof(int) * 53);
                    num[start] = low[start] = 1;
                    dfs(start, j);  //只会从非割边变成割边
                }
                if (gebian[start][j] == 0)  //割边情况不能拓展，要留到最后拓展
                {
                    if (start != j)
                    {
                        dudian[start]--;
                        dudian[j]--;
                    }
                    edge[start][j] = edge[j][start] = 0;
                    start = j;
                    cout << anti_Hash(start);
                    break;
                }
            }
        }
    }
}

void oulahui(int start)  //欧拉路就是一笔画问题
{
    cout << anti_Hash(start);
    for (int i = 0; i < n; i++)  //n条边
    {
        for (int j = 1; j <= 52; j++)
        {
            if (edge[start][start] && dudian[start] == 1)
                //相同点的情况要特判，否则可能回不来
                //要在度点数为1的情况下特判
            {
                cout << anti_Hash(start);
                edge[start][start] = 0;
                break;
            }
            if (edge[start][j])
            {
                if (start != j)
                {
                    dudian[start]--;
                    dudian[j]--;
                }
                edge[start][j] = edge[j][start] = 0;
                start = j;
                cout << anti_Hash(start);
                break;
            }
        }
    }
}

int main()  //欧拉路的情况下要判断割边
{
    string s;
    int u, v;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> s;
        u = Hash(s[0]), v = Hash(s[1]);
        if (u != v)  //相同点的情况特判
        {
            dudian[u]++;  //度点+1
            dudian[v]++;
        }
        edge[u][v] = edge[v][u] = 1;
    }
    int count = 0;
    for (int i = 1; i <= 52; i++)  //判断度点数为奇点的点的个数
    {
        if (dudian[i] % 2 != 0)
        {
            count++;
        }
    }
    if (count != 0 && count != 2)  //不满足欧拉路条件，0个奇点才是回路
    {
        cout << "No Solution" << endl;
        return 0;
    }
    int start_alpha = 0;
    if (count == 0)
    {
        for (int i = 1; i <= 52; i++)
        {
            if (dudian[i])
            {
                start_alpha = i;
                oulahui(i);
                break;
            }
        }
    }
    else
    {
        for (int i = 1; i <= 52; i++)
        {
            if (dudian[i] % 2 == 1)
            {
                start_alpha = i;
                oula(i);
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：kion (赞：0)

### 很STL的题解
想法似乎跟别人不大一样，我不喜欢在char和int之间换来换去，所以选择了
```cpp
map<char, vector<int> > G;
```

  
  至于字典序，这个sort一下就ok。
 
 其他的就是常规dfs，特别注意一定要**用栈记录倒序输出**。不然只有一半分数。
 
 似乎有人问道：为什么要**用栈记录倒序输出**？？
 （dalao可以直接跳过本段）
 
 我在这里简单而形象地解答一下：
 
 举个例子：
 ![](https://cdn.luogu.com.cn/upload/pic/34963.png)
 
 就这个图↑
 
 显然，有且仅有两个点度数为奇，可以“一笔画”。我们在搜索的时候，如果这样写：
 ```cpp
void dfs(char u)
{
	cout<<u;//先输出
	for (vector<int>::iterator it = G[u].begin(); it != G[u].end(); it++)
	{
		char now = *it;
		if (!vis[u][now])
		{
			vis[u][now] = 1;
			vis[now][u] = 1;
			dfs(now);
		}
	}
	
}
```

那就只有50分，因为对于上面所说的图该dfs的输出是：

CABDC

而正解是CCABD

这就要使用这种**用栈记录倒序输出**的方式了。

观察上面错误的输出，发现本该立即输出的C被滞后了，也就是说，这个C**早该输出**了。也就是说。我们应该保证一个点在输出之前**确保之前的所有点已经输出过了**。所以说输出的操作要放在最后，考虑到顺序问题应该倒序输出，堆个栈就行了。
 
 
 下面是AC代码。
 数~~据不够强，偷个懒就不判断图的连通性了。~~
 ```cpp
// P1341.cpp: 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <bits/stdc++.h>
using namespace std;
map<char, vector<int> > G;
map<char, int> cnt;
bool vis[200][200];
stack<char> sta;
int n, ed;


void dfs(char u)
{
	for (vector<int>::iterator it = G[u].begin(); it != G[u].end(); it++)
	{
		char now = *it;
		if (!vis[u][now])
		{
			vis[u][now] = 1;
			vis[now][u] = 1;
			dfs(now);
		}
	}
	sta.push(u);
}
bool cmp(char i, char j)
{
	return int(i) < int(j);
}
int main()
{
	cin >> n;
	bool flag = 0;
	char c = getchar(), q = 0;
	for (int i = 1; i <= n; i++)
	{
		string s;
		cin >> s;
		G[s[0]].push_back(s[1]);
		G[s[1]].push_back(s[0]);
		cnt[s[0]]++;
		cnt[s[1]]++;
	}
	int od = 0, x1 = 0, x2 = 0, c1 = 0, c2 = 0;
	for (map<char, int>::iterator it = cnt.begin(); it != cnt.end(); it++)
	{
        //保证一下字典序↓
		sort(G[it->first].begin(), G[it->first].end(), cmp);
		if (it->second % 2 != 0)
		{
			od++;//记录奇数点的个数
            //↓如果存在奇数点，那么这俩点就是路径的一始一末了
            //记录下来
			if (x1)x2 = it->second, c2 = it->first;
			else x1 = it->second, c1 = it->first;
		}
	}
	if (od != 2 && od != 0)
	{
		cout << "No Solution";
		return 0;
	}
	else
	{
		char minst = 'z';
		for (map<char, vector<int> >::iterator it = G.begin(); it != G.end(); it++)
		{
			if (minst > it->first)minst = it->first;
		}
		if (od == 2)
		{
			minst = min(c1, c2);
		}
		dfs(minst);//搜
	}
	while (!sta.empty())
	{
		cout << sta.top();
		sta.pop();
	}
	return 0;
}


```
 

---

## 作者：jtzhang (赞：0)

本题解会对Hierholzer法进行解释。

step1：40分必须分（暴力）
------------


分析题目，因为每一个字母对是一个要表达事件，而题目要求它们刚好首位相接，首先要明白这是一个事件在边上的图，于是将每一个字母对连成边来表示。
	
即题目要求每一条边 经过且只经过一次


step2：解决经过且只经过一次每一条边
------------

正解不需要的暴力算法（但是看懂题解需要）：
------------

	
维护vis[ ][ ]数组，记录每条边（每个字母对）是否被访问（需要退栈时消除标记），

枚举起点进行dfs，直到刚好走完每一条边为止。


正解部分：Hierholzer
------------

*欧拉回路/欧拉路径 的定理：

1，一个无向图为欧拉图（有欧拉回路），当且仅当该图所有顶点度数都为偶数,且该图是连通图。（可倒推，充要）

2，一个无向图为半欧拉图（有欧拉路径），当且仅当该图除了起点和终点的两个顶点的度为奇数，其余所有顶点度数都为偶数,且该图是连通图。（可倒推，充要）



Hierholzer其实是从基本的dfs出发，我们观察下面一个图，假如是暴力dfs我们很有可能会搜重复的路径，比如：

1 ->2 ->3 ->4 ->5 ->6 ->1 (不可行，回溯至2)

.........->7 ->8 ->9 ->2 ->3 ->4 ->5 ->6 ->1 (可行)

我们发现其中存在的一个小欧拉回路的存在，使得我们不得不回溯，导致 3------>1 的部分重复搜索（数据大了就恶心了）。

但是我们发现只要将红色和蓝色两个回路套起来，就是欧拉回路了！

下面我们观察 点2 的暴力搜索， 如果不消除vis标记，无论怎么搜索，“2->7->8->2” 它的退栈顺序的倒序总是接在“2->3--->1”之后的。(说白了，该与点相关，且还没走过的回路在是一起的）

于是Hierholzer油然而生：
```cpp
dfs(节点)
{
	枚举下一条边-->删除这条边+dsf（这条边）
    退栈时将节点压入 答案栈
}
 ```  
 注意退栈时不能恢复边，所以直接删除这条边就好了
 

![Euler](https://cdn.luogu.com.cn/upload/pic/32959.png )

*欧拉路径：如果图G中的一个路径包括每个边恰好一次，则该路径称为欧拉路径

*欧拉回路：如果一个回路是欧拉路径，则称为欧拉回路

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<stack>
using namespace std;

int num;
bool graph[103][103];
int du[103];
stack <int> ans;

int read(){
    char ch=getchar();
    while( !( ('a'<=ch && ch<='z') || ('A'<=ch && ch<='Z') ) ) ch=getchar();
    return ch-50;	//将字母映射到1--100
}

//核心算法：
void eu_dfs(int pos)
{
    for(int i=1; i<=100; i++)
        if( graph[pos][i] ) {
            graph[pos][i]=false;
            graph[i][pos]=false; //!
            eu_dfs(i);
        }
    
    ans.push(pos);
}

int main()
{
    int i,j;
    scanf("%d",&num);
    
    int v1, v2;
    for(i=1; i<=num; i++)
    {
        v1=read();
        v2=read();
        du[v1]++;
        du[v2]++;
        graph[v1][v2]=true;
        graph[v2][v1]=true;
    }
    
    //定理，判断是否存在
    int num_ji=0, sta=-1;
    for(i=1; i<=100; i++)
        if( du[i]&1 ) {
            num_ji++;
            if(sta==-1) sta=i;	
        }
    
    if( num_ji>2 || num_ji==1 ) {
        printf("No Solution"); 
        return 0;
    } 
    
    if(sta==-1) //是欧拉回路，找起点
        for(i=1; i<=100; i++) 
            if(du[i]) {
                sta=i;
                break;
            }
    
    eu_dfs(sta);
    
    int sym;
	if( ans.size()!=num+1 ) {	//判断连通性（*关于）
        printf("No Solution"); 
        return 0;
    } 
    
    while( !ans.empty() ){
        sym=ans.top();
        ans.pop();
        printf("%c",50+sym);
    }
        
    return 0;
} 


```

*关于判断连通性的判断
------------
洛谷数据水，给大家加一组数据
```cpp
4
aZ
tZ
Xt
CC
```

---

## 作者：maomao9173 (赞：0)

以下是本蒟蒻对这个题目的理解，希望对各位有所帮助。

- 把字母对的关系抽象成无向边的关系，对每个字符建立一个对应数字的映射。

- 把刚才抽象出来的图形画出来，就会发现这个题目转化成了对于这样一个图，从一个点出发，能否完成对本图所有的边的遍历的问题。

- 所以我们考虑求欧拉路径，不了解请提前百度相关概念，本题目只需要了解欧拉路径和欧拉回路的概念就可以口胡出来，不一定非要背下来模板。

- 在求欧拉路径的时候注意以下部分：
	- 注意判断题目给出图形的连通性
    
    - 利用欧拉路径的原理判断even点的个数就可以判断本题目是否有解
    
    - 对欧拉路径和欧拉回路的情况应该分类讨论

- 如果对欧拉路径和dfs写的不熟练请注意以下内容：
	
    - 从小到大遍历连接字符，利用贪心的原理构造出字典序最小的情况。
    
    - 由于上面这一点，所以dfs中每一步都不折返，建议认真考虑一下如何实现。

- 记录答案非常关键，在写题目以前请仔细考虑。为了保证题目中对字典序的要求，强烈建议使用邻接矩阵存图，因为这样可以利用贪心的思想，对字典序从小到大的字符进行遍历搜边，从而保证最后（退栈）的时候记录的都是最终答案。

- 本题目没有重边和自环，原因请自行思考。

如果你现在找到了思路，强烈建议先不要看代码，自行实现。这个题目思路不是非常难，但对debug能力要求还是很高的！祝玩得开心！

那么本蒟蒻就只贴核心代码了qwq：
```cpp
void euler(int x){//x表示目前所处位置
    for(int i=0;i<255;i++){
    //这里是本人懒省事，如果好好建立映射只需要52个字符就OK
    	if(mp[x][i]>0){//如果这个边可选
    		mp[x][i]--;//删除这个边，避免折返
            mp[i][x]--;
            euler(i);//向下一层进发
        }
    }
    res[cnt--]=x;//退栈时记录，也可以给函数加一个deep把它写在if里面。
    //这里本人cnt初始为n
}
```


---


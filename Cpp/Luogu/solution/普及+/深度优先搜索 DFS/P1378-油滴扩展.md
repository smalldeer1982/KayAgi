# 油滴扩展

## 题目描述

在一个长方形框子里，最多有 $N$ 个相异的点，在其中任何一个点上放一个很小的油滴，那么这个油滴会一直扩展，直到接触到其他油滴或者框子的边界。必须等一个油滴扩展完毕才能放置下一个油滴。那么应该按照怎样的顺序在这 $N$ 个点上放置油滴，才能使放置完毕后所有油滴占据的总面积最大呢？（不同的油滴不会相互融合）

注：圆的面积公式 $S = \pi r^2$，其中 $r$ 为圆的半径。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 6$，坐标范围在 $[-1000, 1000]$ 内。

## 样例 #1

### 输入

```
2
20 0 10 10
13 3
17 7
```

### 输出

```
50
```

# 题解

## 作者：Abx123 (赞：382)

# 暴力破解
## code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, x1, x2, yu, y2, x[7], y[7], max;
double bj1, bj2, bj3, bj4, bj5, bj6, the_max_num;
double max_ab(double x, double y);
double min_ab(double x, double y);
void sc(int q, int q1, int q2, int q3, int q4, int q5, int q6)
{
    if (q == 1)
    {
        bj1 = min_ab(min_ab(fabs(x[q1] - x1), fabs(x[q1] - x2)), min_ab(fabs(y[q1] - yu), fabs(y[q1] - y2)));
        the_max_num = max_ab(the_max_num, bj1 * bj1 * 3.1415926);
    }
    if (q == 2)
    {
        bj1 = min_ab(min_ab(fabs(x[q1] - x1), fabs(x[q1] - x2)), min_ab(fabs(y[q1] - yu), fabs(y[q1] - y2)));
        if (sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) <= bj1)
            bj2 = 0;
        else
            bj2 = min_ab(min_ab(min_ab(fabs(x[q2] - x1), fabs(x[q2] - x2)), min_ab(fabs(y[q2] - yu), fabs(y[q2] - y2))), sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) - bj1);
        the_max_num = max_ab(the_max_num, bj1 * bj1 * 3.1415926 + bj2 * bj2 * 3.1415926);
    }
    if (q == 3)
    {
        bj1 = min_ab(min_ab(fabs(x[q1] - x1), fabs(x[q1] - x2)), min_ab(fabs(y[q1] - yu), fabs(y[q1] - y2)));
        if (sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) <= bj1)
            bj2 = 0;
        else
            bj2 = min_ab(min_ab(min_ab(fabs(x[q2] - x1), fabs(x[q2] - x2)), min_ab(fabs(y[q2] - yu), fabs(y[q2] - y2))), sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) - bj1);
        if (sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) <= bj1 || sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) <= bj2)
            bj3 = 0;
        else
            bj3 = min_ab(min_ab(min_ab(min_ab(fabs(x[q3] - x1), fabs(x[q3] - x2)), min_ab(fabs(y[q3] - yu), fabs(y[q3] - y2))), sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) - bj1), sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) - bj2);
        the_max_num = max_ab(the_max_num, bj1 * bj1 * 3.1415926 + bj2 * bj2 * 3.1415926 + bj3 * bj3 * 3.1415926);
    }
    if (q == 4)
    {
        bj1 = min_ab(min_ab(fabs(x[q1] - x1), fabs(x[q1] - x2)), min_ab(fabs(y[q1] - yu), fabs(y[q1] - y2)));
        if (sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) <= bj1)
            bj2 = 0;
        else
            bj2 = min_ab(min_ab(min_ab(fabs(x[q2] - x1), fabs(x[q2] - x2)), min_ab(fabs(y[q2] - yu), fabs(y[q2] - y2))), sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) - bj1);
        if (sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) <= bj1 || sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) <= bj2)
            bj3 = 0;
        else
            bj3 = min_ab(min_ab(min_ab(min_ab(fabs(x[q3] - x1), fabs(x[q3] - x2)), min_ab(fabs(y[q3] - yu), fabs(y[q3] - y2))), sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) - bj1), sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) - bj2);
        if (sqrt((x[q4] - x[q1]) * (x[q4] - x[q1]) + (y[q4] - y[q1]) * (y[q4] - y[q1])) <= bj1 || sqrt((x[q4] - x[q2]) * (x[q4] - x[q2]) + (y[q4] - y[q2]) * (y[q4] - y[q2])) <= bj2 || sqrt((x[q4] - x[q3]) * (x[q4] - x[q3]) + (y[q4] - y[q3]) * (y[q4] - y[q3])) <= bj3)
            bj4 = 0;
        else
            bj4 = min_ab(min_ab(min_ab(min_ab(min_ab(fabs(x[q4] - x1), fabs(x[q4] - x2)), min_ab(fabs(y[q4] - yu), fabs(y[q4] - y2))), sqrt((x[q4] - x[q1]) * (x[q4] - x[q1]) + (y[q4] - y[q1]) * (y[q4] - y[q1])) - bj1), sqrt((x[q4] - x[q2]) * (x[q4] - x[q2]) + (y[q4] - y[q2]) * (y[q4] - y[q2])) - bj2), sqrt((x[q4] - x[q3]) * (x[q4] - x[q3]) + (y[q4] - y[q3]) * (y[q4] - y[q3])) - bj3);
        the_max_num = max_ab(the_max_num, bj1 * bj1 * 3.1415926 + bj2 * bj2 * 3.1415926 + bj3 * bj3 * 3.1415926 + bj4 * bj4 * 3.1415926);
    }
    if (q == 5)
    {
        bj1 = min_ab(min_ab(fabs(x[q1] - x1), fabs(x[q1] - x2)), min_ab(fabs(y[q1] - yu), fabs(y[q1] - y2)));
        if (sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) <= bj1)
            bj2 = 0;
        else
            bj2 = min_ab(min_ab(min_ab(fabs(x[q2] - x1), fabs(x[q2] - x2)), min_ab(fabs(y[q2] - yu), fabs(y[q2] - y2))), sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) - bj1);
        if (sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) <= bj1 || sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) <= bj2)
            bj3 = 0;
        else
            bj3 = min_ab(min_ab(min_ab(min_ab(fabs(x[q3] - x1), fabs(x[q3] - x2)), min_ab(fabs(y[q3] - yu), fabs(y[q3] - y2))), sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) - bj1), sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) - bj2);
        if (sqrt((x[q4] - x[q1]) * (x[q4] - x[q1]) + (y[q4] - y[q1]) * (y[q4] - y[q1])) <= bj1 || sqrt((x[q4] - x[q2]) * (x[q4] - x[q2]) + (y[q4] - y[q2]) * (y[q4] - y[q2])) <= bj2 || sqrt((x[q4] - x[q3]) * (x[q4] - x[q3]) + (y[q4] - y[q3]) * (y[q4] - y[q3])) <= bj3)
            bj4 = 0;
        else
            bj4 = min_ab(min_ab(min_ab(min_ab(min_ab(fabs(x[q4] - x1), fabs(x[q4] - x2)), min_ab(fabs(y[q4] - yu), fabs(y[q4] - y2))), sqrt((x[q4] - x[q1]) * (x[q4] - x[q1]) + (y[q4] - y[q1]) * (y[q4] - y[q1])) - bj1), sqrt((x[q4] - x[q2]) * (x[q4] - x[q2]) + (y[q4] - y[q2]) * (y[q4] - y[q2])) - bj2), sqrt((x[q4] - x[q3]) * (x[q4] - x[q3]) + (y[q4] - y[q3]) * (y[q4] - y[q3])) - bj3);
        if (sqrt((x[q5] - x[q1]) * (x[q5] - x[q1]) + (y[q5] - y[q1]) * (y[q5] - y[q1])) <= bj1 || sqrt((x[q5] - x[q2]) * (x[q5] - x[q2]) + (y[q5] - y[q2]) * (y[q5] - y[q2])) <= bj2 || sqrt((x[q5] - x[q3]) * (x[q5] - x[q3]) + (y[q5] - y[q3]) * (y[q5] - y[q3])) <= bj3 || sqrt((x[q5] - x[q4]) * (x[q5] - x[q4]) + (y[q5] - y[q4]) * (y[q5] - y[q4])) <= bj4)
            bj5 = 0;
        else
            bj5 = min_ab(min_ab(min_ab(min_ab(min_ab(min_ab(fabs(x[q5] - x1), fabs(x[q5] - x2)), min_ab(fabs(y[q5] - yu), fabs(y[q5] - y2))), sqrt((x[q5] - x[q1]) * (x[q5] - x[q1]) + (y[q5] - y[q1]) * (y[q5] - y[q1])) - bj1), sqrt((x[q5] - x[q2]) * (x[q5] - x[q2]) + (y[q5] - y[q2]) * (y[q5] - y[q2])) - bj2), sqrt((x[q5] - x[q3]) * (x[q5] - x[q3]) + (y[q5] - y[q3]) * (y[q5] - y[q3])) - bj3), sqrt((x[q5] - x[q4]) * (x[q5] - x[q4]) + (y[q5] - y[q4]) * (y[q5] - y[q4])) - bj4);
        the_max_num = max_ab(the_max_num, bj1 * bj1 * 3.1415926 + bj2 * bj2 * 3.1415926 + bj3 * bj3 * 3.1415926 + bj4 * bj4 * 3.1415926 + bj5 * bj5 * 3.1415926);
    }
    if (q == 6)
    {
        bj1 = min_ab(min_ab(fabs(x[q1] - x1), fabs(x[q1] - x2)), min_ab(fabs(y[q1] - yu), fabs(y[q1] - y2)));
        if (sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) <= bj1)
            bj2 = 0;
        else
            bj2 = min_ab(min_ab(min_ab(fabs(x[q2] - x1), fabs(x[q2] - x2)), min_ab(fabs(y[q2] - yu), fabs(y[q2] - y2))), sqrt((x[q2] - x[q1]) * (x[q2] - x[q1]) + (y[q2] - y[q1]) * (y[q2] - y[q1])) - bj1);
        if (sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) <= bj1 || sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) <= bj2)
            bj3 = 0;
        else
            bj3 = min_ab(min_ab(min_ab(min_ab(fabs(x[q3] - x1), fabs(x[q3] - x2)), min_ab(fabs(y[q3] - yu), fabs(y[q3] - y2))), sqrt((x[q3] - x[q1]) * (x[q3] - x[q1]) + (y[q3] - y[q1]) * (y[q3] - y[q1])) - bj1), sqrt((x[q3] - x[q2]) * (x[q3] - x[q2]) + (y[q3] - y[q2]) * (y[q3] - y[q2])) - bj2);
        if (sqrt((x[q4] - x[q1]) * (x[q4] - x[q1]) + (y[q4] - y[q1]) * (y[q4] - y[q1])) <= bj1 || sqrt((x[q4] - x[q2]) * (x[q4] - x[q2]) + (y[q4] - y[q2]) * (y[q4] - y[q2])) <= bj2 || sqrt((x[q4] - x[q3]) * (x[q4] - x[q3]) + (y[q4] - y[q3]) * (y[q4] - y[q3])) <= bj3)
            bj4 = 0;
        else
            bj4 = min_ab(min_ab(min_ab(min_ab(min_ab(fabs(x[q4] - x1), fabs(x[q4] - x2)), min_ab(fabs(y[q4] - yu), fabs(y[q4] - y2))), sqrt((x[q4] - x[q1]) * (x[q4] - x[q1]) + (y[q4] - y[q1]) * (y[q4] - y[q1])) - bj1), sqrt((x[q4] - x[q2]) * (x[q4] - x[q2]) + (y[q4] - y[q2]) * (y[q4] - y[q2])) - bj2), sqrt((x[q4] - x[q3]) * (x[q4] - x[q3]) + (y[q4] - y[q3]) * (y[q4] - y[q3])) - bj3);
        if (sqrt((x[q5] - x[q1]) * (x[q5] - x[q1]) + (y[q5] - y[q1]) * (y[q5] - y[q1])) <= bj1 || sqrt((x[q5] - x[q2]) * (x[q5] - x[q2]) + (y[q5] - y[q2]) * (y[q5] - y[q2])) <= bj2 || sqrt((x[q5] - x[q3]) * (x[q5] - x[q3]) + (y[q5] - y[q3]) * (y[q5] - y[q3])) <= bj3 || sqrt((x[q5] - x[q4]) * (x[q5] - x[q4]) + (y[q5] - y[q4]) * (y[q5] - y[q4])) <= bj4)
            bj5 = 0;
        else
            bj5 = min_ab(min_ab(min_ab(min_ab(min_ab(min_ab(fabs(x[q5] - x1), fabs(x[q5] - x2)), min_ab(fabs(y[q5] - yu), fabs(y[q5] - y2))), sqrt((x[q5] - x[q1]) * (x[q5] - x[q1]) + (y[q5] - y[q1]) * (y[q5] - y[q1])) - bj1), sqrt((x[q5] - x[q2]) * (x[q5] - x[q2]) + (y[q5] - y[q2]) * (y[q5] - y[q2])) - bj2), sqrt((x[q5] - x[q3]) * (x[q5] - x[q3]) + (y[q5] - y[q3]) * (y[q5] - y[q3])) - bj3), sqrt((x[q5] - x[q4]) * (x[q5] - x[q4]) + (y[q5] - y[q4]) * (y[q5] - y[q4])) - bj4);
        if (sqrt((x[q6] - x[q1]) * (x[q6] - x[q1]) + (y[q6] - y[q1]) * (y[q6] - y[q1])) <= bj1 || sqrt((x[q6] - x[q2]) * (x[q6] - x[q2]) + (y[q6] - y[q2]) * (y[q6] - y[q2])) <= bj2 || sqrt((x[q6] - x[q3]) * (x[q6] - x[q3]) + (y[q6] - y[q3]) * (y[q6] - y[q3])) <= bj3 || sqrt((x[q6] - x[q4]) * (x[q6] - x[q4]) + (y[q6] - y[q4]) * (y[q6] - y[q4])) <= bj4 || sqrt((x[q6] - x[q5]) * (x[q6] - x[q5]) + (y[q6] - y[q5]) * (y[q6] - y[q5])) <= bj5)
            bj6 = 0;
        else
            bj6 = min_ab(min_ab(min_ab(min_ab(min_ab(min_ab(min_ab(fabs(x[q6] - x1), fabs(x[q6] - x2)), min_ab(fabs(y[q6] - yu), fabs(y[q6] - y2))), sqrt((x[q6] - x[q1]) * (x[q6] - x[q1]) + (y[q6] - y[q1]) * (y[q6] - y[q1])) - bj1), sqrt((x[q6] - x[q2]) * (x[q6] - x[q2]) + (y[q6] - y[q2]) * (y[q6] - y[q2])) - bj2), sqrt((x[q6] - x[q3]) * (x[q6] - x[q3]) + (y[q6] - y[q3]) * (y[q6] - y[q3])) - bj3), sqrt((x[q6] - x[q4]) * (x[q6] - x[q4]) + (y[q6] - y[q4]) * (y[q6] - y[q4])) - bj4), sqrt((x[q6] - x[q5]) * (x[q6] - x[q5]) + (y[q6] - y[q5]) * (y[q6] - y[q5])) - bj5);
        the_max_num = max_ab(the_max_num, bj1 * bj1 * 3.1415926 + bj2 * bj2 * 3.1415926 + bj3 * bj3 * 3.1415926 + bj4 * bj4 * 3.1415926 + bj5 * bj5 * 3.1415926 + bj6 * bj6 * 3.1415926);
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    cin >> x1 >> yu >> x2 >> y2;
    for (int i = 1; i <= n; i++)
        cin >> x[i] >> y[i];
    switch (n)
    {
    case 1:
        sc(n, 1, 0, 0, 0, 0, 0);
        break;
    case 2:
        for (int i1 = 1; i1 <= n; i1++)
            for (int i2 = 1; i2 <= n; i2++)
            {
                if (i2 == i1)
                    continue;
                sc(n, i1, i2, 0, 0, 0, 0);
            }
        break;
    case 3:
        for (int i1 = 1; i1 <= n; i1++)
            for (int i2 = 1; i2 <= n; i2++)
            {
                if (i2 == i1)
                    continue;
                for (int i3 = 1; i3 <= n; i3++)
                {
                    if (i3 == i1 || i3 == i2)
                        continue;
                    sc(n, i1, i2, i3, 0, 0, 0);
                }
            }
        break;
    case 4:
        for (int i1 = 1; i1 <= n; i1++)
            for (int i2 = 1; i2 <= n; i2++)
            {
                if (i2 == i1)
                    continue;
                for (int i3 = 1; i3 <= n; i3++)
                {
                    if (i3 == i1 || i3 == i2)
                        continue;
                    for (int i4 = 1; i4 <= n; i4++)
                    {
                        if (i4 == i1 || i4 == i2 || i4 == i3)
                            continue;
                        sc(n, i1, i2, i3, i4, 0, 0);
                    }
                }
            }
        break;
    case 5:
        for (int i1 = 1; i1 <= n; i1++)
            for (int i2 = 1; i2 <= n; i2++)
            {
                if (i2 == i1)
                    continue;
                for (int i3 = 1; i3 <= n; i3++)
                {
                    if (i3 == i1 || i3 == i2)
                        continue;
                    for (int i4 = 1; i4 <= n; i4++)
                    {
                        if (i4 == i1 || i4 == i2 || i4 == i3)
                            continue;
                        for (int i5 = 1; i5 <= n; i5++)
                        {
                            if (i5 == i1 || i5 == i2 || i5 == i3 || i5 == i4)
                                continue;
                            sc(n, i1, i2, i3, i4, i5, 0);
                        }
                    }
                }
            }
        break;
    case 6:
        for (int i1 = 1; i1 <= n; i1++)
            for (int i2 = 1; i2 <= n; i2++)
            {
                if (i2 == i1)
                    continue;
                for (int i3 = 1; i3 <= n; i3++)
                {
                    if (i3 == i1 || i3 == i2)
                        continue;
                    for (int i4 = 1; i4 <= n; i4++)
                    {
                        if (i4 == i1 || i4 == i2 || i4 == i3)
                            continue;
                        for (int i5 = 1; i5 <= n; i5++)
                        {
                            if (i5 == i1 || i5 == i2 || i5 == i3 || i5 == i4)
                                continue;
                            for (int i6 = 1; i6 <= n; i6++)
                            {
                                if (i6 == i1 || i6 == i2 || i6 == i3 || i6 == i4 || i6 == i5)
                                    continue;
                                sc(n, i1, i2, i3, i4, i5, i6);
                            }
                        }
                    }
                }
            }
        break;
    }
    cout << (int)round(fabs(x1 - x2) * fabs(yu - y2) - the_max_num);
    return 0;
}
double max_ab(double x, double y)
{
    return (x > y ? x : y);
}
double min_ab(double x, double y)
{
    return (x > y ? y : x);
}
```

---

## 作者：ylsoi (赞：196)

这一道题目总体上来说还是蛮好做的，就是#深度优先搜索，然后根据前面所确定的油滴的坐标和半径来确定目前的油滴的半径，！！！但是有一个地方是需要注意的，就是如果这个油滴本身就在另外一个油滴的内部，那么我们就不能选择这个油滴，也就是当两个油滴之间的距离小于那个油滴的半径，我们就要把它变成0！！！！

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=10;
const double PI=3.1415926535;
bool s[maxn];
double x[maxn],y[maxn],r[maxn],xa,ya,xb,yb,ansmax;
int n;
double cal(int i)//这是计算当前的点的半径的函数
{
    double s1=min(abs(x[i]-xa),abs(x[i]-xb));
    double s2=min(abs(y[i]-ya),abs(y[i]-yb));
    double ans=min(s1,s2);
    for(int j=1;j<=n;j++)
    if(i!=j&&s[j])
    {
        double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
        ans=min(ans,max(d-r[j],0.0));//如果距离都小于0了，那我还要你有何用
    }
    return ans;
}
void dfs(int k,double sum)
{
    if(k>n)
    {
        ansmax=max(ansmax,sum);
        return;
    }
    for(int i=1;i<=n;i++)
    {
        if(!s[i])
        {
            r[i]=cal(i);
            s[i]=1;
            dfs(k+1,sum+r[i]*r[i]*PI);
            s[i]=0;
        }
    }
}
int main()
{
    double ss;
    scanf("%d",&n);
    scanf("%lf%lf%lf%lf",&xa,&ya,&xb,&yb);
    ss=abs(xa-xb)*abs(ya-yb); 
    for(int i=1;i<=n;i++)
    scanf("%lf%lf",&x[i],&y[i]);
    dfs(1,0);
    printf("%d",int(ss-ansmax+0.5));//四舍五入
    return 0;
}
```

---

## 作者：青珹 (赞：70)

首先，[原题在这](https://www.luogu.org/problemnew/show/P1378)

恩，让我们进入正题：油滴扩展——显然，这道题是个搜索题，并且是个打眼一看上去就比较恶心的搜索题。

但是，这道题细节恶心，并不代表这道题思路难。

------------


题意大家都了解了，让我们先来把细节问题坑点解决：

 

1.坐标范围为 [-1000,1000] ,有负数怎么办？


　　解决方法很简单粗暴：将所有坐标加上1000就行了，然后就可视为所有坐标都为正数了。

 

2.让输出的答案为剩余的面积，还要四舍五入。

 

　　解决方法也很简单：先搜索求出最大覆盖面积，然后将答案 + = 0.5 ，用矩形总面积减去答案输出即可。

 

------------


然后就是代码实现部分，先声明变量：

```cpp
int n; //n个油滴 
int X1,Y1,X2,Y2;//矩形区域 
double ans;//覆盖的最大面积 

int x[10],y[10];//编号为 [i] 的油滴的坐标 
double r[10];   //编号为 [i] 的油滴的半径 

bool b[10]; //记录此油滴是否已经扩展 

//三个函数，感觉这样写可能会比 C++ 自带的快一些 
inline double Max(double a,double b){
    return a > b ? a : b ;
}
inline double Min(double a,double b){
    return a < b ? a : b ;
}
inline int Abs(int a,int b){
    if(a>b)
        return a-b;
    return b-a;
}
```
 

然后就让我们进入真正的重点：搜索函数（代码里有详解哦~~）

```cpp
void find(int now,double sum){//now 为将要搜第几个油滴 ,sum为现在已经扩展的面积 
    if(now==n+1){//都搜完了
        ans=Max(ans,sum);//更新答案。 
        return ;
    }
    
    for(int i=1;i<=n;i++)
        if(!b[i]){//若这个油滴还没被扩展 
        
            int tt=0;//临时变量 
            
            for(int j=1;j<=n;j++)//这个循环的作用是判断此油滴是否已经被其他油滴覆盖了 
                if(b[j]&&r[j]>=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))){
                    tt=1;
                    b[i]=1;
                    find(now+1,sum); 
                    b[i]=0;
                }
                
            if(tt==1)
                continue ;
                
            b[i]=1;
            
            r[i]=Min(Abs(x[i],X1),Abs(x[i],X2));
            r[i]=Min(r[i],Min(Abs(y[i],Y1),Abs(y[i],Y2)));//此油滴的可能半径为到边界的最短路径 
            
            for(int j=1;j<=n;j++)//根据已经扩展的油滴(j)半径来确定 此油滴(i)的最小半径 
                if(i!=j&&b[j]){
                    double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
                    r[i]=Min(r[i],d-r[j]);
                }
            find(now+1,sum+pi*r[i]*r[i]);//寻找下一个油滴
             
            r[i]=0;//回溯 
            b[i]=0; 
        }
}
```
自此，本题重点就完啦。

 

下面是完整代码：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define pi 3.1415926
using namespace std;
int n; //n个油滴 
int X1,Y1,X2,Y2;//矩形区域 
double ans;//覆盖的最大面积 

int x[10],y[10];//编号为 [i] 的油滴的坐标 
double r[10];   //编号为 [i] 的油滴的半径 

bool b[10]; //记录此油滴是否已经扩展 

//三个函数，感觉这样写可能会比 C++ 自带的快一些 
inline double Max(double a,double b){
    return a > b ? a : b ;
}
inline double Min(double a,double b){
    return a < b ? a : b ;
}
inline int Abs(int a,int b){
    if(a>b)
        return a-b;
    return b-a;
}
void find(int now,double sum){//now 为将要搜第几个油滴 ,sum为现在已经扩展的面积 
    if(now==n+1){//都搜完了
        ans=Max(ans,sum);//更新答案。 
        return ;
    }
    
    for(int i=1;i<=n;i++)
        if(!b[i]){//若这个油滴还没被扩展 
        
            int tt=0;//临时变量 
            
            for(int j=1;j<=n;j++)//这个循环的作用是判断此油滴是否已经被其他油滴覆盖了 
                if(b[j]&&r[j]>=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))){
                    tt=1;
                    b[i]=1;
                    find(now+1,sum); 
                    b[i]=0;
                }
                
            if(tt==1)
                continue ;
                
            b[i]=1;
            
            r[i]=Min(Abs(x[i],X1),Abs(x[i],X2));
            r[i]=Min(r[i],Min(Abs(y[i],Y1),Abs(y[i],Y2)));//此油滴的可能半径为到边界的最短路径 
            
            for(int j=1;j<=n;j++)//根据已经扩展的油滴(j)半径来确定 此油滴(i)的最小半径 
                if(i!=j&&b[j]){
                    double d=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
                    r[i]=Min(r[i],d-r[j]);
                }
            find(now+1,sum+pi*r[i]*r[i]);//寻找下一个油滴
             
            r[i]=0;//回溯 
            b[i]=0; 
        }
    
}
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int main(){
    n=read();
    X1=read()+1000,Y1=read()+1000,X2=read()+1000,Y2=read()+1000;
    for(int i=1;i<=n;i++)
        x[i]=read()+1000,y[i]=read()+1000;
        
    find(1,0.0);
    
    ans=Abs(X1,X2)*Abs(Y1,Y2)-ans;
    int answer=int(ans+0.5);
    printf("%d",answer);
    return 0;
}
```
 

---

## 作者：agicy (赞：49)

# 思路

## 算法

使用**深度优先搜索算法**~~（广度优先搜索算法太麻烦）~~。

## 细节

### 关于$\pi$

至于$\pi$的值，如果在考场上背不出来小数点后$20$位的话，可以打开头文件```<math.h>```，找到：

```cpp
#if !defined(__STRICT_ANSI__) || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE) || defined(_USE_MATH_DEFINES)
#define M_E		2.7182818284590452354
#define M_LOG2E		1.4426950408889634074
#define M_LOG10E	0.43429448190325182765
#define M_LN2		0.69314718055994530942
#define M_LN10		2.30258509299404568402
#define M_PI		3.14159265358979323846
#define M_PI_2		1.57079632679489661923
#define M_PI_4		0.78539816339744830962
#define M_1_PI		0.31830988618379067154
#define M_2_PI		0.63661977236758134308
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2		1.41421356237309504880
#define M_SQRT1_2	0.70710678118654752440
#endif
```

```#define M_PI```后面的$3.14159265358979323846$就是$\pi$的值。

注：```acos(-1)```的精度可能有点偏差。

当然，假如你写了```#include<math.h>```的话，你可以直接在程序中使用```M_PI```代替$\pi$的值。

### 关于矩形的描述

现在知道一个矩形的两个相对端点为$A(x_1,y_1),B(x_2,y_2)$，则这个矩形我们可以描述为：

上边：$y=max(y_1,y_2)$，后面用```up```代替；

下边：$y=min(y_1,y_2)$，后面用```down```代替；

左边：$x=min(x_1,x_2)$，后面用```left```代替；

右边：$x=max(x_1,x_2)$，后面用```right```代替。

### 关于油滴的半径大小

#### 油滴扩展时不能超出矩形的范围

所以在不考虑其他油滴时，这一颗油滴的半径：

```cpp
r=min(min(x-left,right-x),min(y-down,up-y));
```

#### 油滴扩展时接触到其他油滴就停止

1. 首先预处理出所有油滴之间的距离，其中```d[i][j]=d[j][i],d[i][i]=0```，实现代码如下。

```cpp
for(i=1;i<=n;i++)//i={1~n}
	for(j=i+1;j<=n;j++)//j={i+1~n}，这样可以省去一半多的计算，提高程序效率
		d[i][j]=d[j][i]=sqrt(
			(x[i]-x[j])*(x[i]-x[j])+
			(y[i]-y[j])*(y[i]-y[j])
		);
```

2. 根据圆与点的位置关系，我们可以得出：

	- 如果圆的半径大于点到圆心的距离，点在圆内，对于这种情况我们可以得出$d-r<0$，即新的油滴在其它油滴内部，无法进行扩展。
    
    - 如果圆的半径等于点到圆心的距离，点在圆上，对于这种情况我们可以得出$d-r=0$，也无法进行扩展。
    
    - 如果圆的半径小于点到圆心的距离，点在圆外，对于这种情况我们可以得出$d-r>0$，此时新油滴可以扩展，它的半径为$r'=(d-r)$，面积为$S=r'^2\pi$。

油滴的半径大小的代码实现如下。

```cpp
r[i]=min(
	min(x[i]-left,right-x[i]),
    min(y[i]-down,up-y[i])
);//先不考虑其它油滴
for(j=1;j<=n;j++)//枚举其它油滴
	if(used[j])//如果扩展过
		r[i]=min(r[i],d[i][j]-r[j]);//取最小值
if(r[i]<0)
	r[i]=0;//如果出现了点在圆内的情况，半径要置为0
```

# 代码

代码如下。

```cpp
#include<stdio.h>
#include<math.h>//头文件
#define	abs(a)  ( (a) > 0 ? (a) : ( - (a) ) )
#define min(a,b)    ( (a) < (b) ? (a) : (b) )
#define max(a,b)    ( (a) > (b) ? (a) : (b) )//宏定义许多函数

bool used[7];//标记数组
int n;
double tx,ty,up,down,left,right,x[7],y[7],r[7],ans=0,d[7][7];//用double减小误差

void DFS(int,double);//深度优先搜索

int main(void){
	register int i,j;//寄存器更快些
	scanf("%d",&n);//读入n
	scanf("%lf%lf",&tx,&ty);//先读入一个顶点
	left=right=tx;up=down=ty;//均赋值
	scanf("%lf%lf",&tx,&ty);//再读入另一个顶点
	left=min(left,tx),right=max(right,tx);
	down=min(down,ty),up=max(up,ty);//显然，一个矩形的坐标可以用上下左右四个值来描述，左小右大，上大下小
	for(i=1;i<=n;i++)
		scanf("%lf%lf",&x[i],&y[i]);//读入点
	for(i=1;i<=n;i++)
		for(j=i+1;j<=n;j++)//剪去一般的计算过程
			d[i][j]=d[j][i]=sqrt(
				(x[i]-x[j])*(x[i]-x[j])+
				(y[i]-y[j])*(y[i]-y[j])
			);//将距离预处理
	DFS(1,0.0);
	printf("%.0lf",(up-down)*(right-left)-ans);//输出剩余的面积
	return 0;//结束
}

void DFS(int will_put,double sum){//深度优先搜索，will_put为这次搜索要选择第will_put个要放置的点，sum是所有已经放置的油滴的面积之和
	register int i,j;//寄存器更快些
	if(will_put==n+1)//如果n个放置完毕
		ans=max(ans,sum);//更新答案
	for(i=1;i<=n;i++)
		if(!used[i]){//如果没有选取
			r[i]=min(
				min(x[i]-left,right-x[i]),
				min(y[i]-down,up-y[i])
			);//确定半径的初值
			for(j=1;j<=n;j++)
				if(used[j])
					r[i]=min(r[i],d[i][j]-r[j]);//多次更新半径
			used[i]=true;//标记
			if(r[i]<0)
				r[i]=0;//如果半径为负数，显然是在其他油滴内，忽略此油滴不记
			DFS(will_put+1,sum+r[i]*r[i]*M_PI);//进入下一层的搜索
			used[i]=false;//回溯
		}
	return;//退出
}
```

## [我的测评记录](https://www.luogu.org/record/show?rid=9552792)

---

## 作者：ycyaw (赞：20)

看到题解里都是深搜，来一发不一样的

看题目，观察到$n<=6$。又发现油滴滴的顺序不同，就会导致最后剩下面积不同，那就使出我们的STL大法（~~STL大法好~~）：
#### next_permutation
用next_permutation枚举所有顺序，对于每一个不同的顺序，我们都可以计算出剩余的面积，怎么计算呢？

油滴的扩展有限制，看题目可以发现，油滴碰到矩形边界或者其他油滴的边界就会停止扩散。那么，我们计算出每次要滴的油滴的限制条件：

1. #### 离矩形上面的距离
1. #### 离矩形左边的距离
1. #### 离矩形下面的距离
1. #### 离矩形右边的距离
1. #### 离之前所有已滴的油滴边界的距离
在这些距离中，取最小值，即可得到该油滴扩散的最大半径。但要注意，如果离之前所有已滴的油滴边界的距离的最小值小于0，即该油滴在之前油滴之内，无法扩散

具体见代码（有些用了拼音便于理解）：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define lowbit(x) (x)&(-x)
#define oo (1e18)
#define soo (1e8)
#define INF 2147483647
#define Bigprime 212370440130137957ll
#define ll long long
#define LL unsigned long long
#define lll __int128
#define hash Hash
#define time Time
#define gc getchar()
#define pc(x) putchar(x)
#define hh puts("")
#define mp make_pair
#define fi first
#define se second
using namespace std;
int n,res=soo;
double xx1,yy1,xx2,yy2,shang,xia,zuo,you,u,d,l,r,rr[15];
int b[15];
double s;
struct node{
	double x,y;
}a[15];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
double dist(int aa,int bb){
	return sqrt((a[aa].x-a[bb].x)*(a[aa].x-a[bb].x)+(a[aa].y-a[bb].y)*(a[aa].y-a[bb].y));
}
double work(){
	double sum=0,R;
	for(int i=1;i<=n;i++){
		u=shang-a[b[i]].y;//计算上边界
		d=a[b[i]].y-xia;//计算下边界
		l=a[b[i]].x-zuo;//计算左边界
		r=you-a[b[i]].x;//计算右边界
		R=soo;
		for(int j=i-1;j>=1;j--)//计算离之前所有已滴的油滴边界的距离
        	R=min(R,dist(b[i],b[j])-rr[j]);
        //注意b数组存编号，计算dis时参数为编号
        
		if(R<0){//在之前油滴之内
			rr[i]=0;
			continue;
		}
		rr[i]=min(u,min(d,min(l,min(r,R))));//rr存该油滴半径
		sum+=rr[i]*rr[i]*3.1415926;//pai多打几位防止精度问题
	}
	return sum;
}
int main(){
	n=read();
	cin>>xx1>>yy1>>xx2>>yy2;
	shang=max(yy1,yy2),xia=min(yy1,yy2),zuo=min(xx1,xx2),you=max(xx1,xx2);
	s=(shang-xia)*(you-zuo);
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		b[i]=i;
	}
	double t;
	int tt;
	do{
		t=work();
		t=s-t;//矩形剩余面积
		tt=(int)round(t);//四舍五入
		res=min(res,tt);
	}while(next_permutation(b+1,b+n+1));
	printf("%d",res);
    return 0;
}
```

---

## 作者：Christopher_Yan (赞：16)

这道题目的方法并不难想，但能做到一遍AC的也一定是真dalao.

首先，需要注意一下此题的要求，油滴是圆形的，各个油滴只能相离或相切。其次，油滴不能覆盖在已有的油滴上，需要进行特判。
```
#include<bits/stdc++.h>
using namespace std;
const double pi=3.141592;
int n,x,y,x1,yx;
int a[7][3];
bool v[7];
double res,outt=-1;
double r[7];
```
```
double dis(int xx,int yy,int xx1,int yy1)
{
	return sqrt(pow((xx-xx1),2)+pow((yy-yy1),2));
}
```
dis函数用来计算两点之间的欧几里得距离（勾股定理）。
```
double minn(int k)
{
	for(int i=1;i<=n;i++)
		if(i!=k&&v[i]==1)
			if(r[i]>dis(a[i][1],a[i][2],a[k][1],a[k][2])) return 0;
    //判断该点坐标是否已被油滴覆盖，是则将该点半径设为零。
	double dist;
	double ans=min(min(abs(a[k][1]-x),abs(a[k][1]-x1)),min(abs(a[k][2]-y),abs(a[k][2]-yx)));
    //先取该点到边界的最小距离。
	for(int i=1;i<=n;i++)
		if(i!=k&&v[i]==1)
		{
			dist=dis(a[i][1],a[i][2],a[k][1],a[k][2])-r[i];
			ans=min(ans,dist);
		}
    //枚举每个已存在的油滴，更新最小值。
	return ans;
}
```
minn函数用来判断圆的最大半径。
```
void dfs(int k,double res)
{
	double mm;
	if(k==n)
	{
		outt=max(outt,res);
		return;
	}
	for(int i=1;i<=n;i++)
		if(v[i]==0)
		{
			r[i]=minn(i);
			v[i]=1;
			dfs(k+1,res+pi*r[i]*r[i]);
			v[i]=0;
			r[i]=0;
		}
}
```
dfs代码，搜索所有可能的顺序。
```
int main()
{
	scanf("%d",&n);
	scanf("%d%d%d%d",&x,&y,&x1,&yx);
	int s=abs(x-x1)*abs(y-yx);
    //计算总面积
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i][1],&a[i][2]);
	dfs(0,0);
	cout<<int(s-outt+0.5);
    //四舍五入
    return 0;
}
```
这里需要注意的是输出结果时不能使用如下写法
```
	cout<<floor(s-outt+0.5);
```
看似这与    int(s-outt+0.5);    并没有区别，但由于精度的问题，这种写法会WA两个点。	
例如：正确答案12345678，而用floor函数会得到1.234567e+006
### 于是乎，我发现：floor 函数的返回值竟然是是 double 型的！		
而double类型的小数点6位之后就无法保证精度了。（我的机子上是6位）。

希望对大家有帮助。

---

## 作者：shenbear (赞：10)

总结一下前人的血泪教训，写一点个人思索

首先，看范围，只有6，而题目中又问你一种可行的方法，那么直接全排列枚举方法即可

得到顺序之后按这个顺序进行枚举即可，在所有的枚举中找出最优解。

全排列

```
void dfs(int x) {
	if(x>n) {
		memset(r,0,sizeof(r));
		for(int i=1; i<=n; i++) slove(a[i]);
		double s=0;
		for(int i=1; i<=n; i++) s+=3.1415926*r[i]*r[i];
		s=max(s,ans);
	} else 
		for(int i=x; i<=n; i++) {
			swap(a[i],a[x]);
			dfs(x+1);
			swap(a[i],a[x]);
		}
}
```

**π要取多一点，防止报精度**

关于如何进行计算每一个面积，我们发现，只有一下2个限制条件：

1.碰到矩阵四边边界

2.碰到其他油滴

**注意，刚开始每个可以放油滴的位置上没有油滴，也就是说可以越过这些点**

计算面积：

边界很好算，不再赘述，关键在于如何求与其他油滴刚好相交的情况

其实很简单，只要两圆心距离-另一个圆半径就行

## 注意：
**1.如果减出来的值非正，说明这个点已经被其他油滴包围了，直接跳掉**

**2.如果另一个圆半径为0，不用管，因为这代表这里没有油滴，可以直接越过**

```
void slove(int i) {
	double mn=1e9;
	mn=min(min(x[i]-sx,ex-x[i]),min(y[i]-sy,ey-y[i]));
	for(int j=1; j<=n; j++) 
		if(i!=j) {
			if(!r[j]) continue;
			if(jl(i,j)<=r[j]) return ;
			mn=min(mn,jl(i,j)-r[j]);
		}
		r[i]=mn;
}
```

证明有图显然
![](https://cdn.luogu.com.cn/upload/image_hosting/9uxg7c6y.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
















```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[9];
double ans,r[9],sx,sy,ex,ey,x[9],y[9],jg[9];
double jl(int a,int b) {return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));}
void slove(int i) {
	double mn=1e9;
	mn=min(min(x[i]-sx,ex-x[i]),min(y[i]-sy,ey-y[i]));
	for(int j=1; j<=n; j++) 
		if(i!=j) {
			if(!r[j]) continue; 、、没油滴不管
			if(jl(i,j)<=r[j]) return ; //被包围直接弹出
			mn=min(mn,jl(i,j)-r[j]);
		}
		r[i]=mn;
}
void dfs(int x) {
	if(x>n) {
		memset(r,0,sizeof(r));
		for(int i=1; i<=n; i++) slove(a[i]);
		double s=0;
		for(int i=1; i<=n; i++) s+=3.1415926*r[i]*r[i];
		s=max(s,ans);
	} else 
		for(int i=x; i<=n; i++) {
			swap(a[i],a[x]);
			dfs(x+1);
			swap(a[i],a[x]);
		}
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) a[i]=i;
	cin>>sx>>sy>>ex>>ey;
	if(sx>ex) swap(sx,ex);
	if(sy>ey) swap(sy,ey);
	for(int i=1; i<=n; i++) cin>>x[i]>>y[i];
	dfs(1);
	ans=(ex-sx)*(ey-sy)-ans;
	printf("%d\n",(int)(ans+0.5)); //一定要先转int
	return 0;
}
```



---

## 作者：SCD_Wiasin (赞：6)

//第一，本人是弱省蒟蒻 ，所以方法很垃圾，大佬勿喷

```cpp
//说题目。。。就是搜索。。。看我下面注释 
//用dfs求出全排列
//还有 r要满足 
//1): r<=点到边界距离 
//2): 这个点形成的圆与其他圆外离或外切 
//这样就可以了
//看代码 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
#define pi 3.141592653
#define MAXM 0x7fffffff
using namespace std;
int n,z,m,s,t,x[10],y[10],vis[10],p[10],d[10];
double maxl=0,data[10][10],r[10],sum=0;
int bi( int aaa,int bbb,int ccc,int ddd)
{
    aaa=aaa<bbb? aaa:bbb;
    aaa=aaa<ccc? aaa:ccc;
    aaa=aaa<ddd? aaa:ddd;
    return aaa;
```
}//这个是用来求点到边界的最小值的
```cpp
void check()
{
    sum=0;
    for(int i=1;i<=n;i++)
    {
        sum+=r[i]*r[i]*pi;    
    }
    maxl=max(maxl,sum);
```
}//求最大的面积
```cpp
void dfs(int step)
{
    if(step>n)
    {
        check();
        return ;
    }
    for(int i=1;i<=n;i++)
    {
        if(vis[i]==0)
        {
            for(int j=1;j<=n;j++)
            {
                if(vis[j]!=0&&i!=j)
                { 
                    if(data[i][j]<r[j]) 
                    {
//这里一直错，因为如果上个点半径太大，会覆盖这个点，要特判一下
                        r[i]=0;
                        break;
                    }
                    else
                    r[i]=min(r[i],data[i][j]-r[j]);
                    //这里的话，因为可能有多个点，有的点到这个点的 
                    //距离小但半径大，所以都要比较一下 
                }
            }
            if(step<=n)
            {
                vis[i]=1;
                dfs(step+1);
                vis[i]=0;
                r[i]=d[i];
            }
        }
    }
    return ;
}
int main()
{
    cin>>n;
    cin>>z>>m>>s>>t;
    for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
        int a=abs(x[i]-z),b=abs(y[i]-m),c=abs(x[i]-s),dd=abs(y[i]-t);
        d[i]=bi(a,b,c,dd);
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(i==j)
        data[i][j]=0;
        else
        data[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
    }
    for(int i=1;i<=n;i++)
    {
        r[i]=d[i];
```
}//可以和上面合在一起 我懒得改了...
```cpp
    dfs(1);
    int S=(abs(z-s)*abs(m-t));
    cout<<(int)(S-maxl+0.5);//细节问题相信大家都懂吧 
    return 0;
}
```

---

## 作者：lingerleaf (赞：5)

1.为了方便起见让输入的数据保证矩形xa,ya是左上角坐标,xb,yb是右下角坐标

2.然后开始枚举放置的顺序，全部枚举出来！其实就是1~n的全排列

我是把所有的点都存到一个数组里的，所以我就把下标的顺序取全排列，这样的话就是所有点的放置顺序的全排列了

4.每个顺序都算出该顺序的空间，然后取最小值

(我这里算了油滴占用的最大值，然后矩形面积减去它)

如何算每个顺序的空间？

3.遍历该顺序的点，每次取最小值:::

取最小值的规则:

(1)与四边的距离的最小值

(2)与该顺序下，之前已经放置了的所有油滴的圆心距离 减去 这个放置了的圆的半径 的。最后取一个最小值(循环搞定)

上面两个规则再取最小值，就是该圆能扩大到的半径

然后按之前所说的，所有顺序这样来，取出最值。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int xa,ya;
int xb,yb;
/*
尽量用double
pi精度要高
考虑被覆盖的点，不然半径变成负数了
矩形的角 顺序 
*/ 
pair<int,int> p[7];
inline double dis(int xa,int ya,int xb,int yb){
	return sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb));
}
inline double solve(){
	double maxoccupy=0;
	int ord[n+1];//顺序 
	int cx,cy,jx,jy;
	double leastr,dotr[n+1];
	for(int i=1;i<=n;++i)	ord[i]=i;
	do{
		for(int i=1;i<=n;++i){
			cx=p[ord[i]].first,cy=p[ord[i]].second;
			leastr=min(min(xb-cx,cx-xa),min(ya-cy,cy-yb));
			for(int j=1;j<i;++j){
				jx=p[ord[j]].first,jy=p[ord[j]].second;
				leastr=min(leastr,dis(cx,cy,jx,jy)-dotr[j]);
			}
			dotr[i]=leastr<0?0:leastr;
		}
		double occupy=0;
		for(int i=1;i<=n;++i){
			occupy+=3.1415926535898*dotr[i]*dotr[i];
		}
		maxoccupy=max(maxoccupy,occupy);
	}while(next_permutation(ord+1,ord+1+n));//全排列
	return maxoccupy;
}
int main(){
	cin>>n>>xa>>ya>>xb>>yb;
	int a,b;
    //保证矩形xa,ya是左上角坐标,xb,yb是右下角坐标
	if(xa>xb){
		swap(xa,xb);
	}
	if(ya<yb){
		swap(ya,yb);
	}
	for(int i=1;i<=n;++i){
		cin>>a>>b;
		p[i]=make_pair(a,b);
	}
	cout<<(int)round((xb-xa)*(ya-yb)-solve());//四舍五入到整数
}
```

---

## 作者：2020luke (赞：2)

# [P1378 油滴扩展](https://www.luogu.com.cn/problem/P1378) 题解

## 思路解析

这里提供一种抽象的模拟退火做法。可以发现答案只跟顺序有关，发现正好符合模拟退火的条件，于是正常使用模拟退火即可。

所谓模拟退火实际上就是随机化，正常的全排列是枚举每一种交换的情况，而模拟退火就是随机化随机的两个位置，如果更优则直接更新答案，若不优则只用一定概率转移。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 rd(time(0));
const int N = 8;
const double pai = 3.1415926;
const unsigned int RDMX = (unsigned)-1;
int n, sx, sy, ex, ey, ox[N], oy[N];
double r[N], ans = 0;
double dis(double xa, double ya, double xb, double yb) {
	return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));
}
double get() {
	double sum = 0;
	for(int i = 1; i <= n; i++) {
		r[i] = min({abs(sx - ox[i]), abs(ex - ox[i]), abs(sy - oy[i]), abs(ey - oy[i])});
		for(int j = 1; j < i; j++) {
			if(dis(ox[i], oy[i], ox[j], oy[j]) > r[j]) r[i] = min(r[i], dis(ox[i], oy[i], ox[j], oy[j]) - r[j]);
			else r[i] = 0;
		}
		sum += r[i] * r[i] * pai;
	}
	return (double)abs(ex - sx) * abs(ey - sy) - sum;
}
void sa() {
	double t = 1000;
	while(t > 1e-12) {
		int a = rd() % n + 1, b = rd() % n + 1;
		swap(ox[a], ox[b]); swap(oy[a], oy[b]);
		double w = get();
		if(w < ans) ans = w;	//比当前答案更优
		else if(exp((double)(ans - w) / t) * RDMX < (double)rd()) {	//不优，以一定概率转移
			swap(ox[a], ox[b]); swap(oy[a], oy[b]);
		}
		t *= 0.9996;
	}
}
int main() {
	cin >> n >> sx >> sy >> ex >> ey;
	for(int i = 1; i <= n; i++) {
		cin >> ox[i] >> oy[i];
	}
	ans = get();
	while((double)clock() / CLOCKS_PER_SEC <= 0.9) sa();
	printf("%.0lf", ans);
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：1)

### 这道题目几乎可以算作是爆搜的裸题了，个人认为难度只有在黄题左右
### 大体思路就是枚举所有点的顺序，选择最大的一种
### 鉴于扩展每个油滴的判断需要耗费一定的时间，我们在枚举点的顺序的时候就应该进行扩展油滴而不是在枚举出排列的时候一起扩展，后者较前者而言有更加多的重复计算次数
### 唯一需要注意的是π的取值，我原本以为既然是保留整数，又涉及r * r,应该只需要取两位小数(3.14)以上就够了，没想到π的值取3.1415只能拿到40分，取3.14159只能拿到70分，只有取到3.141592的时候才能拿到全分。这点很容易浪费大量的时间，请注意。
### 至于扩展，其实只要预处理出每个点到边界的距离，然后再判断是否小于到其他已经被扩展的圆的距离即可。
### 由于需要求所有的顺序的最大值，故本题大概没有什么剪枝。
### 最后附上代码
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;

const double pi = 3.141592;
const int size = 10;
double dis[size][size], x[size], y[size], r[size], side[size], ans, x1, x2, yi, y2;
int vis[size];

void work(int n) {
    double add = 0;
    for(int i = 0; i < n; i++) add += r[i] * r[i];
    ans = max(ans, pi*add);
}

void ext(int p, int n) {
    double rt = side[p];
    for(int i = 0; i < n; i++)
        if(p != i && vis[i])
            rt = min(rt, max(dis[i][p]-r[i], 0.0));
    r[p] = rt;
}

void dfs(int cur, int n) {
    if(cur == n) {
        work(n);
        return;
    }
    for(int i = 0; i < n; i++)
        if(!vis[i]) {
            vis[i] = 1;
            ext(i, n);
            dfs(cur+1, n);
            r[i] = 0;
            vis[i] = 0;
        }
}

void init(int n) {
    ans = 0;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            if(i == j) dis[i][j] = 0;
            else if(i < j){
                double dx = x[i] - x[j], dy = y[i] - y[j];
                dis[i][j] = sqrt(dx * dx + dy * dy);
            } else {
                dis[i][j] = dis[j][i];
            }
    for(int i = 0; i < n; i++) {
        side[i] = min(x[i]-x1, x2-x[i]);
        side[i] = min(side[i], y[i]-yi);
        side[i] = min(side[i], y2-y[i]);
    }
}

int main() {
    int n, a, b, c, d;
    memset(vis, 0, sizeof(vis));
    scanf("%d %d %d %d %d", &n, &a, &b, &c, &d);
    x1 = min(a, c), x2 = max(a, c), yi = min(b, d), y2 = max(b, d);
    for(int i = 0; i < n; i++) scanf("%lf %lf", x+i, y+i);
    init(n);
    dfs(0, n);
    printf("%.0f\n", round((x2-x1)*(y2-yi)-ans));
    return 0;
}
```

---

## 作者：_Qer (赞：1)

看了题，第一个想到的方法就是搜索，然后看看$N$，只有6，那就妥妥的$N!$暴力碾过了。

搜索部分就不讲了，直接搜放油滴的顺序即可。  
然后就是计算答案，按照题目要求，取与矩形四边和其他油滴的最短距离，与油滴距离应为两圆心距离减去已放油滴的半径。  
坑1，未说明给出矩形顶点为左上和右下，可能出锅。  
坑2，如果当前放油滴的位置已经被某个油滴覆盖，那么要将这个油滴的半径设为0，否则直接计算时会出现半径为负数的情况。

```
#include <bits/stdc++.h>
using namespace std;
const double pi = 3.14159265358979323846;//π设精确一点总没有坏处
int n;
double ux, uy, vx, vy, px[10], py[10], ans;
//前四为矩形两点坐标，px[],py[]表示点位置
//ans为最大油滴面积
int id[10], used[10];
//油滴放置顺序，是否枚举过
double tr[10];
//计算过程中每个油滴的半径
double sq_dis(int k) {
    return min(min(fabs(px[k] - ux), fabs(px[k] - vx)), 
           min(fabs(py[k] - uy), fabs(py[k] - vy)));
}//某点距离矩形边界的距离
double pdis(int k1, int k2) {
    return sqrt((px[k1] - px[k2]) * (px[k1] - px[k2]) + 
                (py[k1] - py[k2]) * (py[k1] - py[k2]));
}//两点距离
void f() {//计算当前放置顺序的结果
    //这里注意一点，tr数组使用时下标为id[x]
    memset(tr, 0, sizeof(tr));
    double ret = 0, nr = 0;
    //总面积（非剩余部分面积）
    for (int i = 1; i <= n; ++i) {
        nr = sq_dis(id[i]);//半径初始化为到边界的距离
        for (int j = 1; j < i; ++j) {//在已放置油滴中找最近的
            nr = max(min(nr, pdis(id[i], id[j]) - tr[id[j]]), 0.0);
        }
        tr[id[i]] = nr;
        ret += pi * nr * nr;
        #ifdef DEBUG
        cout << "r = " << nr << " , V = " << pi * nr * nr << "\t";
        #endif
    }
    ans = max(ans, ret);
    #ifdef DEBUG
    cout << "Ans = " << ans << endl;
    #endif
    return;
}
void dfs(int k) {//搜索部分，k为当前枚举第k个顺序
    if (k == n + 1) {
        #ifdef DEBUG
        cout << "Order: ";
        for (int i = 1; i <= n; ++i) {
            cout << id[i] << " ";
        }
        puts("");
        #endif
        f();
        return;
    }
    for (int i = 1; i <= n; ++i) {
        if (!used[i]) {
            used[i] = true;
            id[k] = i;
            dfs(k + 1);
            used[i] = false;//记得重置
            id[k] = 0;
        }
    }
    return;
}
int main() {
    cin >> n >> ux >> uy >> vx >> vy;
    for (int i = 1; i <= n; ++i) {
        cin >> px[i] >> py[i];
    }
    dfs(1);
    cout << (int)(fabs(ux - vx) * fabs(uy - vy) - ans + 0.5) << endl;
    //1,题目要求剩余部分面积
    //2,要四舍五入为整数
    return 0;
} 
```


---

## 作者：晚安自己说 (赞：1)

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#define R register
using namespace std;
const double pi=3.141592;//该死的精度--
int n,x,y,dx,dy,d[10][10];//d[i][1]是x，d[i][2]是y
bool v[10];//这个点是否用过
double res,ans=-1,r[10];//r[i]第i个圆的半径
inline int ri(){
	char c=getchar();int x=0,w=1;
	while(!isdigit(c)){if(c=='-')w=-1;c=getchar();}
	while( isdigit(c)){x=(x<<3)+(x<<1)+c-48,c=getchar();}
	return x*w;
}
inline double die(int a,int b,int aa,int bb){
	return sqrt(pow((a-aa),2)+pow((b-bb),2));
}//勾股大法
inline double qbj(int jx){
	for(R int i=1;i<=n;i++)
		if(i!=jx&&v[i])//不是本身点且求过它的半径
			if(r[i]>die(d[i][1],d[i][2],d[jx][1],d[jx][2]))return 0;//半径大于两点距离即点在别人的圆，半径为0咯
	double ans=min(min(abs(d[jx][1]-x),abs(d[jx][1]-dx)),min(abs(d[jx][2]-y),abs(d[jx][2]-dy)));//找与边框最近的距离为初始半径
	for(R int i=1;i<=n;i++)
		if(i!=jx&&v[i])
			ans=min(ans,die(d[i][1],d[i][2],d[jx][1],d[jx][2])-r[i]);//半径不能伸到别人的圆里啊--所以减掉别人的半径 有没有伸到？判个min
	return ans;
}

inline void dfs(int k,double res){//搜了几个圆，占了多少面积咯
	if(k==n){ans=max(ans,res); return ;}//记载各种情况的最大面积
	for(R int i=1;i<=n;i++){
		if(!v[i]){//没用过就dfs它
            r[i]=qbj(i);v[i]=1;
            dfs(k+1,res+pi*r[i]*r[i]);
            v[i]=0;r[i]=0;//取消标记给下一次dfs
		}
	}	
}
int main(){
	n=ri();x=ri();y=ri();dx=ri();dy=ri();
	int s=abs(dx-x)*abs(dy-y);
	for(R int i=1;i<=n;i++)d[i][1]=ri(),d[i][2]=ri();
	dfs(0,0);
	cout<<int(s-ans+0.5);//四舍五入
	return 0;
}
```

---

## 作者：Tanktt (赞：1)

这道题没有什么技巧性的深搜剪枝，只有一些零碎的注意点:
1. 油滴不能相融，即一个油滴碰到另一个后就停止扩展（这也是为什么要爆搜的原因），所以：
	1. 半径在每次深搜时都会改变，每次都要更新。
    1. 只能爆搜次数，每次1~n都要搜，不能只爆搜每个点取不取。
    
1. 如果已经有油滴y包含了当前油滴x，就不能放，即把半径设为0而不是dis(x,y)-r[y]。
1. 坐标会有负数（P党随意），所以要统一把所有坐标都+1000
1. 最后要四舍五入，不要乱搞，规规矩矩地按四舍五入的原理来。

由此，我就光荣地WA了两次。。。。。

CODE
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
using namespace std;
const double pai=3.1415926535;
int n,sum,id[12];
double mn,r[12],x1,x2,y3,y2,x[12],y[12],lim,p[12];//注意变量类型
bool b[12];
inline double calc(int a,int b)
{
	double s1=x[a]-x[b],s2=y[a]-y[b];
	return sqrt(s1*s1+s2*s2);
}
inline void dfs(int now,double s)
{
	if (now>n)
	{
		mn=min(mn,lim-s);
		return;
	}
	bool flag=1;
	for (int t=1; t<=n; t++)//注意点1.2
	if (!b[t])//不要重复放油滴
	{
      //**//
		r[t]=min(min(min(x[t]-x1,x2-x[t]),y[t]-y3),y2-y[t]);
        //原来的最大半径
		for (int i=1; i<=n; i++)
		if (i!=t&&b[i])
		r[t]=min(r[t],max(calc(i,t)-r[i],0.0));
        //与已经放的油滴比较;注意点2
      //**//注意点1.1
		b[t]=1;
		dfs(now+1,s+r[t]*r[t]*pai);
		b[t]=0;
	}
}
int main()
{
	mn=1000000012.12;
	scanf("%d",&n);
	cin>>x1>>y3>>x2>>y2;
	x1+=1000.0;y3+=1000.0;x2+=1000.0;y2+=1000.0;//注意点3
	if (x1>x2) swap(x1,x2);
	if (y3>y2) swap(y3,y2);
	lim=(x2-x1)*(y2-y3);//总面积
	for (int i=1; i<=n; i++)
	{
		cin>>x[i]>>y[i];
		x[i]+=1000.0;y[i]+=1000.0;
	}
	dfs(1,0.0);
	return printf("%.0f\n",floor(mn+0.5)),0;//注意点4
}
```

---

## 作者：shadowice1984 (赞：1)

一道面向过程的搜索题

如果采用模块化的思想这道题会很好写。

先用dfs求出全排列，

然后我们写一个place函数，处理所有的拓展油滴情况即可

这样能够避免头晕以及不必要的调试。

```cpp
#include<stdio.h>
#include<cmath>
#include<algorithm>
using namespace std;
int control[6];bool book[6];//存储全排列
int n;double res;
double d[6][6];
struct circle
{
    int x;int y;double r;
}c[6];
int x3;int y3;int x2;int y2;
double place(int p)//拓展油滴函数
{
    double minp=0x3f3f3f3f;double
    t=abs(x3-c[p].x);minp=min(minp,t);//printf("minpis%.4f\n",minp);
    t=abs(x2-c[p].x);minp=min(minp,t);//printf("minpis%.4f\n",minp);
    t=abs(y3-c[p].y);minp=min(minp,t);//printf("minpis%.4f\n",minp);
    t=abs(y2-c[p].y);minp=min(minp,t);//printf("minpis%.4f\n",minp);//更新四边距离
    for(int i=0;i<n;i++)
    {
        if(i==p)continue;//不能计算到自己的距离
        if(c[i].r>-0.000001&&c[i].r<0.000001)//如果目标点半径为0即跳过
        continue;
        t=d[p][i]-c[i].r;
        if(t<0.00001)return 0;//如果在油滴内部无法拓展
        minp=min(minp,t);//printf("minpis%.4f\n",minp);    
    }
    c[p].r=minp;
    return minp*minp;//return的是r^2最后再乘π
}
void clear()//清空半径
{
    for(int i=0;i<n;i++)
    {
        c[i].r=0;
    }return;
}
void dfs(int x)//求全排列
{
    if(x==n)
    {
        double rep=0;
        for(int i=0;i<n;i++)//按排列顺序放置油滴
        {
            rep+=place(control[i]);
        }
        if(res<rep)res=rep;
        clear();//记得清空半径
        return;
    }
    else//全排列模板
    {
        for(int i=0;i<n;i++)
        {
            if(!book[i])
            {
                book[i]=true;
                control[x]=i;
                dfs(x+1);
                book[i]=false;
            }
        }
    }
    return ;
}
int main()
{
    scanf("%d",&n);
    scanf("%d%d%d%d",&x3,&y3,&x2,&y2);
    for(int i=0;i<n;i++)
    {
        scanf("%d%d",&c[i].x,&c[i].y);
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<i;j++)
        {
            d[j][i]=d[i][j]=
            sqrt((c[i].x-c[j].x)*(c[i].x-c[j].x)+(c[i].y-c[j].y)*(c[i].y-c[j].y));
            //printf("d[%d][%d]is%f\n",i,j,d[i][j]);
                        //计算任意两点距离
        }
    }
    dfs(0);//dfs
    res*=3.1415926;//由于res是Σri^2所以要乘π
    res=abs(x3-x2)*abs(y3-y2)-res+0.5;//减总面积，四舍五入
    int ans=res;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：March (赞：1)

Chapter1:  经过仔细读题，可以发现题目只给方形对角线坐标，我想：方形对角线坐标和油滴坐标都可能为负数，非常不利于计算，可以将方形平移到与x正半轴和y正半轴重合，油滴同时平移相同的单位长度，即x[0~n]-=方形左下角点的x，y[0~n]-=方形左下角点的y；若想求得到方形左下角坐标这只能特判两个对角线点的关系，比如x1>x2,y1>y2,就是点1在点2的左下角。

Chapter2:  对于提议--“尽可能的留下少的空间”，可以理解为使所有油滴的面积总和最大，可以使用全排列来枚举放油滴的顺序。

Chapter3:  对于当前放置油滴的r的最大值可以证明得：(len=矩形长，hig=矩形高)r=MIN（x，y，len-x,hig-y,当前油滴到所有已经扩展的油滴的距离-已经扩展的油滴的r）

综上所述得出结论：

代码如下：

```cpp

#include<stdio.h>
#include<math.h>
int N;
double x[10],y[10],best=-1,r[10],x11,x22,y11,y22,len,hig,dx,dy;
double min(double a,double b){
    if(a>b) return b;
        else return a;
}
int updata(int ss[]){
    int i;
    double s=0;
    for(i=0;i<N;i++){
        s+=r[i]*r[i]*M_PI;
    }
    if(best<s){
        best=s;
    }
    return 0;
}
int swp(int *a,int *b){
    int tmp;
    tmp=*a;
    *a=*b;
    *b=tmp;
}
int init(){
    int tmp,i;
    if(x11<x22&&y11>y22){
        dx=x11;
        dy=y22;
    }
    if(x11>x22&&y11<y22){
        dx=x22;
        dy=y11;
    }
    if(x11>x22&&y11>y22){
        dx=x22;
        dy=y22;
    }
    if(x11<x22&&y11<y22){
        dx=x11;
        dy=y11;
    }
    len=fabs(x11-x22);
    hig=fabs(y11-y22);
    for(i=0;i<N;i++){
        x[i]-=dx;
        y[i]-=dy;
    }
}
int run(int s[]){
    double R=999999999;
    int j,i;
    for(i=0;i<N;i++){//计算r
        R=min(R,x[s[i]]);
        R=min(R,y[s[i]]);
        R=min(R,len-x[s[i]]);
        R=min(R,hig-y[s[i]]);
        for(j=0;j<N;j++)
            if(r[j]!=-1&&s[i]!=j)
                R=min(R,sqrt((x[s[i]]-x[j])*(x[s[i]]-x[j])+(y[s[i]]-y[j])*(y[s[i]]-y[j]))-r[j]);
        if(R>=0){
            r[s[i]]=R;
        }
        else r[s[i]]=0;
    }
    R=99999999;
}
int dfs(int beg,int end,int s[]){
    int i;
    if(beg==end){
        for(i=0;i<N;i++){
            r[i]=-1;
        }
        run(s);
        updata(s);
        return 0;
    }
    for(i=0;i<=end;i++){//全排
        swp(&s[beg],&s[i]);
        dfs(beg+1,end,s);
        swp(&s[beg],&s[i]);
    }
}
int main(){
    int i,aa[10]={0,1,2,3,4,5,6,7,8,9};
    scanf("%d",&N);
    scanf("%lf%lf%lf%lf",&x11,&y11,&x22,&y22);
    for(i=0;i<N;i++)
        scanf("%lf%lf",&x[i],&y[i]);
    init();
    dfs(0,N-1,aa);
    best=len*hig-best;
    printf("%.0lf\n",best);
    return 0;
}

```（c/c++）


---

## 作者：iYuer (赞：1)

首先理解题意：

油滴最多扩展到：

1.到长方形边界。

2.或者碰到其他油滴。（注意：此时的计算需要求两圆心的距离-那个圆的半径）


其他注意事项：

1.如果该油滴已经处于 被覆盖的区域。则该油滴的半径应视为0 避免重复计算。

2.最后把double型数据强制转化为int时， 应先加上0.5再强制转换，这样才是四舍五入。


（还有，此题其实不必构建二维数组来 填 0 1以形成地图。直接求油滴所在位置距离边框 和 其他圆心的距离减半径的 最小值作为半径即可。）


代码如下：

    
        
    
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
using namespace std;
const double pi=3.141592653589793238462643383279502;
const double _MAX=99999999.0;
const int maxn=6+5;
int n,x[maxn],y[maxn],tx1,ty1,tx2,ty2;
double ans,maxAns=0.0,square,R[maxn],used[maxn]; //x为i y为j
double getR(int d)
{
    double len=_MAX;
    for(int i=1;i<=n;i++)if(R[i])
        len=min(len,sqrt(abs(x[i]-x[d])*abs(x[i]-x[d])+abs(y[i]-y[d])*abs(y[i]-y[d])) - R[i]);
    len=min(len,(double)min(abs(x[d]-tx1),min(abs(x[d]-tx2),min(abs(y[d]-ty1),abs(y[d]-ty2)))));
    if(len<0)    return 0.0; //如果该油滴已经处于 被覆盖的区域。则返回0 避免重复计算 
    return len;
} 
void dfs(int pos)
{
    if(pos>n){maxAns=max(maxAns,ans);return;} 
    for(int i=1;i<=n;i++)if(!used[i])
    {
        double r=getR(i);
        used[i]=1;
        R[i]=r;
        ans+=(pi*r*r);
        dfs(pos+1);
        R[i]=0.0;
        used[i]=0;
        ans-=(pi*r*r);
    }
}
int main()
{
    freopen("s.in","r",stdin);
    freopen("s.out","w",stdout);
    scanf("%d",&n);
    scanf("%d%d%d%d",&tx1,&ty1,&tx2,&ty2);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&x[i],&y[i]);
    dfs(1);
    square=(double) abs(tx1-tx2)*abs(ty1-ty2);
    square-=maxAns;
    square+=0.5;//+0.5是为了四舍五入 
    printf("%d",(int)square);
    return 0;
}
```

---

## 作者：CondemnedXL (赞：1)

看了看题解 好像没有什么OO

其实OO会有超高的写代码效率 而且写的时候会比较开心

**但是数据量大的题为了防止优化问题还是不要OO了**


我写的是个贪心 其实我不太敢确定但是自己随机大量数据发现全排列和贪心结果全一样 就放心用了

在比赛的时候拿不准是否能贪心，暴力又怕时间不够，其实还可以写一些先贪心，再暴力，暴力过程中在一些费时的循环中检查时间，时间要超了就强行退掉直接输出贪心结果之类的


###下面是代码

这部分没啥好说的

```cpp
#include <vector>
#include<iostream>
#include <cmath>
#include <algorithm>
#include <iomanip>

double areaofCircle(const double&r)
    {
    return 3.1415926*r*r;
    }
```
这是个油滴的class

储存了我能想到的**所有油滴可能具备的属性**

比如是否已经扩散（方便判断距离，声明扩散其他油滴的时候可以覆盖这个点）

能否扩散（计算力不要浪费在已经被覆盖的油滴上）

```cpp
class OilDrop
    {
    friend class Box;
    double posX, posY; //Centre
    double radius = 0;    //Radius
    bool diffusible = true;
    bool diffused = false;
    OilDrop(const  int&x, const  int&y)
        {
        posX = x;posY = y;
        }
    void prevent()
        {
        diffusible = false;
        }
    };
```

这里是盒子的class 变量名都很好看 不用解释了

这里可以看出OO思想，我在设计这个类的时候是**把Box里面发生的事都当做函数写进去了**

```cpp
class Box
    {
    double X1, X2, Y1, Y2;
    double leftArea;
    std::vector<OilDrop*>DropSet;
    double getCentreDistance(const OilDrop*D1, const OilDrop*D2) const
        {
        double square = (D1->posX - D2->posX)*(D1->posX - D2->posX) + (D1->posY - D2->posY)*(D1->posY - D2->posY);
        return sqrt(square);
        }

    double minDistance(OilDrop*Drop) const
        {
        std::vector<double>distance;
        distance.push_back(abs(X1 - Drop->posX));
        distance.push_back(abs(X2 - Drop->posX));
        distance.push_back(abs(Y1 - Drop->posY));
        distance.push_back(abs(Y2 - Drop->posY));
        for (const auto theDrop : DropSet)
            {
            if (theDrop->diffused)
                distance.push_back(getCentreDistance(theDrop, Drop) - theDrop->radius);
            }
        return *std::min_element(distance.begin(), distance.end());
        }

    void Spread(OilDrop*Drop, const double&r)
        {
        if (!Drop->diffusible)return;
        Drop->radius = r;
        Drop->diffused = true;
        leftArea -= areaofCircle(r);
        for (const auto theDrop : DropSet)
            {
            if (!theDrop->diffused)
                if (getCentreDistance(theDrop, Drop) <= Drop->radius)theDrop->prevent();
            }
        }


    public:
        Box(const unsigned int& num)
            {
            std::cin >> X1 >> Y1 >> X2 >> Y2;
            leftArea = abs(X1 - X2)*abs(Y1 - Y2);
            for (size_t i = 0;i < num;i++)
                {
                int tmpX, tmpY;
                std::cin >> tmpX >> tmpY;
                OilDrop *tmp = new OilDrop(tmpX, tmpY);
                DropSet.push_back(tmp);
                }
            }
        bool spreadall()
            {
            OilDrop* toSpread = nullptr;
            double max = 0;
            for (auto const theDrop : DropSet)
                {
                if (!theDrop->diffusible)continue;
                auto currR = minDistance(theDrop);
                if (max < currR)
                    {
                    max = currR;
                    toSpread = theDrop;
                    }
                }
            if (max == 0)return false;
            Spread(toSpread, max);
            return true;
            }
        void print()
            {
            std::cout << std::setiosflags(std::ios::fixed) << std::setprecision(0) << leftArea;
            }
    };
```
main没啥说的

```cpp
int main()
    {
    unsigned int N;
    std::cin >> N;
    Box mainBox(N);
    for (;mainBox.spreadall(););
    mainBox.print();
    return 0;
    }
```

OO适合**在没有太多思路的时候把题设都用代码表示出来找思路**

至于运行效率，和STL一个感觉吧，想用就用，觉得慢就不要用


---

## 作者：timetravler (赞：1)

这道题是十分简单的搜索，从每一个点开始不断进行深搜，半径的大小为min（坐标-边界，与其他油滴圆心的距离-此油滴的半径），有了这个剩下的就十分简单了。但是要注意油滴是否被其它油滴包含，如果包含直接退出当前循环。


```(
#include<iostream>  
#include<stdio.h>  
using namespace std;  
int n,i,order[7];  
double x1,y1,x2,y2,dot[7][2],area,r[7],answer=0;  
bool use[7]={};  
inline long double  
sqrt(long double \_\_x)  
{ return \_\_builtin\_sqrtl(\_\_x); }  
int DFS (int No,int last)  
{  
    order[No-1]=last;  
    use[last]=1;  
    if (No>n)  
    {  
             area=0;  
             for (int i=1;i<=n;i++)  
             {  
                 r[i]=min(min(max(x1-dot[order[i]][0],dot[order[i]][0]-x1),max(x2-dot[order[i]][0],dot[order[i]][0]-x2)),min(max(y1-dot[order[i]][1],dot[order[i]][1]-y1),max(y2-dot[order[i]][1],dot[order[i]][1]-y2)));  
                 for (int j=1;j<i;j++)  
                 r[i]=min(r[i],(double)sqrt((dot[order[i]][0]-dot[order[j]][0])\*(dot[order[i]][0]-dot[order[j]][0])+(dot[order[i]][1]-dot[order[j]][1])\*(dot[order[i]][1]-dot[order[j]][1]))-r[j]);  
                 r[i]=max(r[i],0.0);  
                 area+=r[i]\*r[i]\*3.1415926535;  
             }  
             answer=max(answer,area);  
    }  
    for (int i=1;i<=n;i++)  
    if (!use[i])  
    DFS(No+1,i);  
    use[last]=0;  
}  
int main ()  
{  
    cin>>n>>x1>>y1>>x2>>y2;  
    for (i=1;i<=n;i++)  
    cin>>dot[i][0]>>dot[i][1];  
    DFS(1,0);  
    printf("%.0f",(max(x1-x2,x2-x1))\*(max(y1-y2,y2-y1))-answer);  
    return 0;  
}
）

---

## 作者：Rbrq (赞：1)

题目描述

在一个n*m的只包含0和1的矩阵里找出一个不包含0的最大正方形，输出边长。

输入输出格式

输入格式：

输入文件第一行为两个整数n,m（1<=n,m<=100），接下来n行，每行m个数字，用空格隔开，0或1.

输出格式：

一个整数，最大正方形的边长

输入输出样例

输入样例#1： 

4 4

0 1 1 1

1 1 1 0

0 1 1 0

1 1 0 1

输出样例#1： 

2

一道玄学题目，做完后才发现标签居然是dp，
但是其实暴力剪枝可以过。

说说暴力思路

枚举每一个点，如果它的值为0，很显然不可能构成正方形，直接剪掉

然后以边长为循环变量从1枚举到最大可能性，遍历正方形中的每一个点，如果发现有0直接停止这个点循环（因为哪怕是更大的正方形也会将这个点包进去，不可能满足题目需求）

最后玄学剪枝，即如果剩下的行数比现在的最大正方形的边长来得小，无论如何都不可能再构成一个最大正方形，直接输出答案

还有一个坑点，就是边长指的是有几个数而不是数之间有多少间隔

附ac代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=110;
int square[Maxn][Maxn];
int n,m,d,maxd=0;
bool have_0=false;
int max(int a,int b){return a>b?a:b;}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	    scanf("%d",&square[i][j]);
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j){
	  	if(square[i][j]==0) continue;
	  	for(d=1;d<=min(m-j,n-i);d++){
	  	    for(int z=i;z<=i+d;z++){
	  	      for(int k=j;k<=j+d;k++)
	  	        if(square[z][k]==0){
	  	        	have_0=true;
	  	        	break;
			     }
	  	    	if(have_0==true) break;
			  }
			if(have_0==false) maxd=max(d,maxd);
			else{have_0=false; break;}
		  }
		if(maxd>=n-i) break;
	  }
	printf("%d",maxd+1);
	return 0;
}
```

---

## 作者：QDK_Storm (赞：0)

# 暴力
#### 主要思想是在dfs过程中维护以下几个值
- 已经放置的油滴的圆心位置和扩散半径
- 当前框子里已被占据的体积
###### 

------------
那么dfs函数就可以写出来了
dfs（k,ret）表示当前正在布置第k个油滴，框子里已经占据了ret的面积

dfs时用长方形框子的四条边和之前其他的油滴的位置来找到最大的扩散半径深搜即可

并且需要注意一下如果存在一个油滴使得此时放置的油滴圆心与该油滴圆心距离小于等于该油滴扩散半径，那么就说明此时放置的油滴位置已被覆盖

最后输出答案使用round函数取四舍五入值

一些其他的小细节都在代码注释里
# AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
double pi=3.1415926535897932;
int n;
double xa,xb,ya,yb,ans,S;
bool vst[7];
struct p
{
	double x,y;
}poi[7];//存储油滴
struct a
{
	double posx,posy,r;
}c[10];//存储已放置的油滴的位置和扩散半径
inline double dis(double ax,double ay,double bx,double by)
{
	return sqrt(pow(ax-bx,2)+pow(ay-by,2));
}
inline double s(double rr)
{
	return pi*rr*rr;
}
void dfs(int k,double ret)
{
	if(ret>S)
		return;
	if(k>=n+1)//此时油滴已经放完，更新被覆盖的最大面积
	{
		ans=max(ans,ret);
		return;
	}
	else
		for(int i=1;i<=n;i++)
		{
			double minn=1<<30;
			if(!vst[i])//vst表示油滴是否被放置过
			{
				for(int j=1;j<k;j++)//遍历之前的油滴
				{
					double range=dis(c[j].posx,c[j].posy,poi[i].x,poi[i].y)-c[j].r;
					if(range>=0)//当前油滴位置不在已被覆盖的面积上
						minn=min(minn,range);
					else//当前油滴的位置已被覆盖
						minn=0;
				}
				minn=min(minn,xb-poi[i].x);
				minn=min(minn,poi[i].x-xa);
				minn=min(minn,yb-poi[i].y);
				minn=min(minn,poi[i].y-ya);//不要忘记用框子的四条边更新最大扩散半径
				c[k].posx=poi[i].x;
				c[k].posy=poi[i].y;
				c[k].r=minn;
				vst[i]=true;
				dfs(k+1,ret+s(minn));
				vst[i]=false;
				c[k].posx=c[k].posy=c[k].r=0;
			}
		}
}
int main()
{
	scanf("%d%lf%lf%lf%lf",&n,&xa,&ya,&xb,&yb);
	if(xa>xb)//使xb总大于xa
		swap(xa,xb);
	if(ya>yb)//同理
		swap(ya,yb);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf",&poi[i].x,&poi[i].y);
	S=(xb-xa)*(yb-ya);//框子的总面积
	for(int i=1;i<=n;i++)
		dfs(1,0);//放置第一个油滴，框子内被占据的面积是0
	printf("%.0lf",round((S-ans)));//总面积-覆盖面积=剩余面积
    //珂朵莉是我的
	return 0;
}
```


---

## 作者：wanxiang_zx (赞：0)

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
using namespace std;
const int maxn=2000;
int n;    
int ans=1e8;
struct node{
       int x,y;
}a[maxn];
int b[maxn];  
double x3,y3,x2,y2;
double r[maxn];
double jvli(int p,int q)
{
       return sqrt((a[p].x-a[q].x)*(a[p].x-a[q].x)+(a[p].y-a[q].y)*(a[p].y-a[q].y));
}
double min4(int y,int z,int w,int q)
{
       return min(y,min(z,min(w,q)));
}
double mianji(int k)
{
       double mn;
       mn=min4(abs(a[b[k]].x-x3),abs(a[b[k]].x-x2),abs(a[b[k]].y-y3),abs(a[b[k]].y-y2));
       //mn先赋值为这个点到四周边界的最小值 
       for(int i=1;i<k;i++)
       {
         mn=min(mn,jvli(b[i],b[k])-r[b[i]]);
         //b[i]为之前滴过的每一个点的真实编号 
         if(mn<=0)
         {
           r[b[k]]=0;
           return 0; 
         }
       }
       r[b[k]]=mn;
       return M_PI*mn*mn;
}
double totsize()
{
       memset(r,0,sizeof(r));
       double s=0;
       //s为当前这种排列的油滴覆盖面积
       for(int i=1;i<=n;i++)
         s+=mianji(i);
       //求出当前b数组（即这种油滴滴入顺序） 
       return s;
}
int main()
{
    scanf("%d",&n);
    cin>>x3>>y3>>x2>>y2;
    for(int i=1;i<=n;i++)
    {
      b[i]=i;
      scanf("%d%d",&a[i].x,&a[i].y);
    }

    do{
      
      double ts=totsize(); 
      //ts赋值为当前这种排 列的油滴覆盖面积
      ts=abs(x3-x2)*abs(y2-y3)-ts;
      //用方框总面积减去油滴覆盖面积
      int t=round(ts);
      //四舍五入求剩余面积
      ans=min(ans,t);
    }while(next_permutation(b+1,b+n+1));
    //列举全排列，比较每一种排列方式的最终剩余面积
    printf("%d\n",ans);
    system("pause");
    return 0;
}

```


---

## 作者：李乐平 (赞：0)

WA4次之后终于AC……
#### 反思
定义函数的时候一定要注意数据类型（~~多么惨痛的教训~~）

话不多说上代码
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n;
double X[10] = {},Y[10] = {},r[10] = {},vis[10] = {},m,ans = 0;
double X1,Y1,X2,Y2;
double p = 3.1415926535;
double dis(int a,int b){
	double k = sqrt((X[a] - X[b]) * (X[a] - X[b]) + (Y[a] - Y[b]) * (Y[a] - Y[b]));
	return (k - r[b] >= 0) ? k - r[b] : 0;
}//计算距离，注意排除某点包含在其它圆内的情况
void dfs(int k,int c,double nans){
	//因为数据小，所以可以爆搜
   //另外，这里我调试了很多次，大约花了一个小时才发现上面的double写成了int……
	r[k] = min(min(X2 - X[k],X[k] - X1),
    		min(Y2 - Y[k],Y[k] - Y1));
	int i;
	for(i = 1;i <= n;i++){
		if(vis[i]){
			r[k] = min(r[k],dis(k,i));//该点扩展的半径
		}
	}
	if(c == n){
		ans = max(ans,nans + p * r[k] * r[k]);
		r[k] = 0;//注意清零
		return;
	}
	vis[k] = 1;
	for(i = 1;i <= n;i++){
		if(!vis[i]){
			dfs(i,c + 1,nans + p * r[k] * r[k]);
		}
	}
	vis[k] = 0;
	r[k] = 0;//清零
}
int main(){
	cin>>n>>X1>>Y1>>X2>>Y2;
	if(X2 < X1)
		swap(X2,X1);
	if(Y2 < Y1)
		swap(Y2,Y1);
	m = (X2 - X1) * (Y2 - Y1);//长方形的面积
	if(!n){
		cout<<(X2 - X1) * (Y2 - Y1);
		return 0;
	}
	for(int i = 1;i <= n;i++)
		cin>>X[i]>>Y[i];
	for(int i = 1;i <= n;i++){
		dfs(i,1,0);
	}
	printf("%.0lf",m - ans);
   //事实上，这道题根本不存在四舍五入的问题
}
```


---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P1378)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于数据很小，所以可以直接跑全排。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后考虑如何根据已经得到的数据求当前放下的油滴扩散开的半径。首先，该油滴不会超出矩形，所以可以先根据矩形边框确定一个上界；然后枚举已经滴了的油滴，计算出来与之相切时的半径，求$\min$即可。注意特判该油滴在一个圆形的内部的情况，此时需要直接判$0$
# 代码
```cpp
#include<cmath>
#include<cstdio>

const double pi = 3.1415926535;
const int MAXN = 10;

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;	
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

double r[MAXN];
double res = 0x3f3f3f3f, score;
double x[MAXN], y[MAXN];
double lx, ly, rx, ry;
int N;
bool used[MAXN];

double getDis( const double x, const double y, const double a, const double b )
{
	return sqrt( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) );	
}

void DFS( const int indx )
{
	if( indx > N )
	{
		res = MIN( res, score );
		return;
	}	
	double val;
	for( int i = 1 ; i <= N ; i ++ )
	{
		if( ! used[i] )
		{
			used[i] = true;
			r[i] = MIN( x[i] - lx, MIN( rx - x[i], MIN( y[i] - ly, ry - y[i] ) ) );
			for( int j = 1 ; j <= N ; j ++ )
			{
				if( j != i && used[j] ) 
				{
					r[i] = MIN( r[i], ( val = getDis( x[i], y[i], x[j], y[j] ) - r[j] ) < 0 ? 0 : val );
				}
			}
			score -= pi * r[i] * r[i];
			DFS( indx + 1 );
			score += pi * r[i] * r[i];
			used[i] = false;	
		}	
	}
}

int main()
{
	double x1, y1, x2, y2;
	scanf( "%d %lf %lf %lf %lf", &N, &x1, &y1, &x2, &y2 );
	lx = MIN( x1, x2 );
	rx = MAX( x1, x2 );
	ly = MIN( y1, y2 );
	ry = MAX( y1, y2 );
	for( int i = 1 ; i <= N ; i ++ )
	{
		scanf( "%lf %lf", &x[i], &y[i] );	
	}
	score = ( rx - lx ) * ( ry - ly );
	DFS( 1 );
	printf( "%.0lf\n", res );
	return 0;	
}
```

---

## 作者：shejian0702 (赞：0)

其实本题还是挺简单的，就是要注意细节，比如我这种蒟蒻a,b复制后没改完，ans用double之类的莫名其妙挂掉60分，还调试了半天；
唉，还是练习太少了；另码风勿喷；


```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<string>
#define REP(i,n) for(int i=0;i<n;i++)

using namespace std;
double x,y,xx,yy,S,sum;
long long ans;
const double PI=3.1415926535;
int vis[6],n;

void SHE(string a){//setIO
	string in=a+".in",out=a+".out";
	freopen(in.c_str(),"r",stdin);
	freopen(out.c_str(),"w",stdout);
}

struct yd{
	double a,b,r;

	double d(const yd& x){
		return sqrt((a-x.a)*(a-x.a)+(b-x.b)*(b-x.b))-x.r;
	}

	double db(){
	double s1=min(abs(x-a),abs(xx-a));
    	double s2=min(abs(y-b),abs(yy-b));
    	double ans=min(s1,s2);
	return inside()? ans:0;
	}

	double V(){
		return PI*r*r;
	}

	bool inside(){
	return  (( x<=a && xx>=a) || ( xx<=a && x>=a)) && (( y<=b && yy>=b) || ( yy<=b && y>=b));
			}

}she[6];

void JIAN(){
	scanf("%d",&n);
	scanf("%lf%lf%lf%lf",&x,&y,&xx,&yy);
	S=abs((x-xx)*(y-yy));
	REP(i,n) cin>>she[i].a>>she[i].b;
}

void find_r(double& R,int id){//
	R=10000;
	REP(i,n){
		if(i==id)  continue;
		if (vis[i]) R=min(R,she[id].d(she[i]));
	}
	R=max(R,0.0);
	R=min(R,she[id].db());
}

void dfs(int id,int k,double sumr){
	double& R=she[id].r;
	find_r(R,id);
	sumr+=she[id].V();
	if (k==n) {sum=max(sum,sumr);return;}
	vis[id]=1;
	REP(i,n) if(!vis[i]) dfs(i,k+1,sumr);
	R=vis[id]=0;
	return;
}

void _0702(){//solve
	REP(i,n) dfs(i,1,0);
	ans=(long long)(S-sum+0.5);
	cout<<ans;
}

int main(){
	//SHE("P1378");
	JIAN();//read input
	_0702();//solve
	return 0;
}


```

---

## 作者：Kaizyn (赞：0)

没什么，只是想说可以用枚举全排列来枚举所有滴入油滴的顺序，感觉这个思路比较好写 ~~然而蒟蒻代码贼丑~~

其余参照别的大佬的题解略略略

------------

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const int Maxn = 10;
const double PI = acos(-1);

struct Node
{
	int x, y;
	double r;
} a[Maxn];

int n, bx, by, ex, ey;
int order[Maxn];
double ri[Maxn];

inline double dis(int i, int j) // 两点的距离
{
	return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y));
}

inline double cal() // 计算当前顺序下的覆盖面积
{
	double res = 0.0;
	for(int i = 1, cur; i <= n; ++i)
	{
		cur = order[i];
		ri[cur] = a[cur].r;
        // 看和之前的油滴是否冲突
		for(int j = 1; j < i; ++j)
			ri[cur] = min(ri[cur], dis(cur, order[j]) - ri[order[j]]);
		// 特比注意!!!不然只有60分
		if(ri[cur] < 0) ri[cur] = 0.0;
        
		res += PI * ri[cur] * ri[cur];
	}
	return res;
}

inline int out(double num) // 蒟蒻的四舍五入
{
	// 取下界，看小数第一位是不是大于5
	double floor_v = floor(num);
	return static_cast<int>(num - floor_v >= 0.5 ? floor_v+1 : floor_v);
}

inline int min4(int a, int b, int c, int d) // 求四个数的最小值
{
	int arr[4] = {a, b, c, d};
	sort(arr, arr+4);
	return arr[0];
}

int main()
{
	scanf("%d%d%d%d%d", &n, &bx, &by, &ex, &ey);
	for(int i = 1; i <= n; ++i) 
	{
		order[i] = i;
		scanf("%d%d", &a[i].x, &a[i].y);
        // 计算碰到边界能达到的最大半径
		a[i].r = min4(abs(a[i].x-bx), abs(a[i].x-ex), abs(a[i].y-by), abs(a[i].y-ey));
	}
	double ans = 0.0;
    // 当当当当
	do ans = max(ans, cal());
	while(next_permutation(order+1, order+n+1));
	printf("%d\n", out(-ans + abs((bx-ex)*(by-ey)) ) );
	return 0;
}

```

---

## 作者：lin_secret (赞：0)

用DFS搜索n个点的全排列。

扩展某个油滴实际上是在求当前情况下油滴最大可行的半径，令其为r

设油滴坐标为a(x,y)，我们发现r需要满足一下条件

1)    r ≤ 点a到矩形四条边的距离

2)    以a为圆心，r为半径的圆与所有已经存在的圆均外离（没有公共点）或外切（只有一个公共点），即对于所有已经存在的圆心为O，半径为R的圆，dist(O,a)>=r+R（dist（O,a）表示点O与点a的距离，r和R的意义同前文）

很容易发现，这里的r就等于所有限制中的最小值，即

r=min{min{a到矩形四边的距离} , min{dist(a,O)-R}(对于所有已存在的圆心为O，半径为R的圆)}

求出r后，继续DFS即可

程序：


```cpp
var n,n1,i:longint;
    ans:double;
    xi,yi:array[1..4] of longint;
    a1,b1:array[0..7] of longint;
    f:array[0..7] of boolean;
    len:array[0..7] of double;
function minn(a,b:double):double; begin if a<b then exit(a) else exit(b);end;
procedure work(s:longint);
var i,j:longint;
    sum,lon:double;
begin
  if s>n then
    begin
      sum:=0;
      for i:=1 to n do sum:=sum+pi*len[i]*len[i];
      sum:=n1-sum;
      if (ans=-1) or (sum<ans)
      then ans:=sum;
    end
   else
     begin
       for i:=1 to n do if f[i]
         then
         begin
           len[i]:=maxlongint;
           for j:=1 to 4 do
             begin
               len[i]:=minn(len[i],abs(xi[j]-a1[i]));
               len[i]:=minn(len[i],abs(yi[j]-b1[i]));
             end;
           for j:=1 to n do
             if not f[j] then
             begin
               lon:=sqrt(sqr(a1[j]-a1[i])+sqr(b1[j]-b1[i]));
```
if lon-len[j]>0
then len[i]:=minn(len[i],lon-len[j]) else len[i]:=0;

```cpp
             end;
           f[i]:=false;
           work(s+1);
           f[i]:=true;
         end;
     end;
end;
begin
  readln(n);
  readln(xi[1],yi[1],xi[2],yi[2]);
  xi[3]:=xi[1];
  yi[3]:=yi[2];
  xi[4]:=xi[2];
  yi[4]:=yi[1];
  for i:=1 to n do readln(a1[i],b1[i]);
  n1:=abs((xi[2]-xi[1])*(yi[2]-yi[1]));
  ans:=-1;
  fillchar(f,sizeof(f),true);
  work(1);
  writeln(round(ans));
end.
```

---

## 作者：可耐的菊花茶 (赞：0)

这道题目咋一看感觉很难，不知道怎么处理油滴的顺序和油滴的半径，但是当我们看到数据就会发现n小于等于6，这真是非常


小啊，我们可以开心地写一个DFS来枚举油滴的顺序,然后对于每个油滴它能扩长大半径我们就可以计算出来了，要与每个已经


滴下的油滴比较，它们之间的距离减去那个油滴已经扩张的半径，就是对于这滴油滴来说最大的半径，不要忘了和边界判断一


下。
最后再献上完整代码



```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
#define maxn 15
using namespace std;
const double pi=3.1415926535897932384626433832795;//涉及到精度问题。
bool vis[maxn];//标记这个油滴是否已经被滴下
double sum,ans;
int n,x,y,x_,y_;
struct chj{
    int x,y;
    double r;
}a[maxn];
inline int read(){
    int ret=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();} 
    while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
inline double getcost(int x,int y){return sqrt((a[x].x-a[y].x)*(a[x].x-a[y].x)+(a[x].y-a[y].y)*(a[x].y-a
[y].y));}//欧几里德距离
inline void mrk_r(int p){//算半径
    double r=1e100;
    for (int i=1;i<=n;i++) if (vis[i]) r=min(r,getcost(i,p)-a[i].r);//跟已经滴下的油滴比较，刷个短半径，即
```
对应题目中的直到接触到其他油滴。
```cpp
    if (x_-a[p].x<r) r=x_-a[p].x;//与边界比较。
    if (a[p].x-x<r) r=a[p].x-x;
    if (y_-a[p].y<r) r=y_-a[p].y;
    if (a[p].y-y<r) r=a[p].y-y;
    if (r<0) r=0;//半径不可能为负数，注意哦。
    a[p].r=r;
}
inline void DFS(int step){//枚举顺序
    if (step>n){
        double s=0;
        for (int i=1;i<=n;i++) s+=a[i].r*a[i].r*pi;//计算每个油滴的面积累积一下。
        if (s>ans) ans=s;//从众多结果里刷个大的
        return;
    }
    for (int i=1;i<=n;i++)
    if (!vis[i]){//标准的DFS
        mrk_r(i);
        vis[i]=1;
        DFS(step+1);
        vis[i]=0;
    }
}
int main(){
    freopen("box.in","r",stdin);
    freopen("box.out","w",stdout);
    n=read();
    int aa=read(),bb=read(),cc=read(),dd=read();
    x=min(aa,cc);y=min(bb,dd);x_=max(aa,cc);y_=max(bb,dd);
    for (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();//读数据
    DFS(1);
    sum=(x_-x)*(y_-y);//这是总面积
    printf("%.f\n",sum-ans);
    return 0;
}
```

---

## 作者：夏色祭 (赞：0)

其实滴的方案数就是n的阶乘，也就是全排列。

那么整个题的难点就到了怎么计算每滴油扩散开来的圆的半径。

而圆只要碰到边界或者其它圆就wei了，那么这个圆的半径只是就是它与长方形四条边的距离，max(其他圆的距离-那个圆的半径,0)，在二者里找一个min就行了。

AC代码:


```cpp
const
  pi=3.1415926535;
var
  x,y,kk:array[0..7]of longint;
  b:array[0..7]of boolean;
  zz:array[0..7]of double;
  n,i,x1,y1,x2,y2:longint;
  sum,ans:double;
function max(x,y:double):double;
begin
  if x>y then exit(x) else exit(y);
end;
function min(x,y:double):double;
begin
  if x<y then exit(x) else exit(y);
end;
function ff(n,t:longint):double;
var
  i:longint;
  begin  
    ff:=min(min(abs(x[t]-x1),abs(x[t]-x2)),min(abs(y[t]-y1),abs(y[t]-y2)));
    for i:=1 to n do 
      ff:=min(ff,max(0,sqrt(sqr(x[t]-x[kk[i]])+sqr(y[t]-y[kk[i]]))-zz[i]));
  end;//计算半径
procedure try(k:longint);
var
  i:longint;
  s:double;
  begin
    if k>n then 
      begin
        s:=0;
        for i:=1 to n do 
          s:=s+zz[i]*zz[i]*pi;//计算这些圆的面积之和
        if s>ans then ans:=s;//要使剩余面积小，那么这些圆的面积之和就要尽可能大
        exit;
      end;
    for i:=1 to n do 
      if not b[i] then 
        begin
          zz[k]:=ff(k-1,i);//计算圆的半径
          kk[k]:=i;//记录下圆的编号
          b[i]:=true;
          try(k+1);
          b[i]:=false;//回溯
        end; 
  end; 
begin
  readln(n);
  readln(x1,y1,x2,y2);
  sum:=abs(x2-x1)*abs(y2-y1);
  for i:=1 to n do readln(x[i],y[i]);
  try(1);
  writeln((sum-ans):0:0);
end.

```

---

## 作者：森海塞尔 (赞：0)

        
```cpp
//这个也是用的是全排列
//但是储存数据的方法和楼下的不一样
//用了一个结构体
//接着全排列数组a调用结构体
//注意啊，π要多往后写几位
//刚开始把π写成了3.141只得了30分，看代码看了两个小时都找不到哪里错
//最后把π的值改成3.141592653。。。。才对
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const double PI=3.1415926535;//！！！
struct node{
    int  x;
    int  y; };//结构体用来存油滴的点
node p[7];
int a[7];//全排列数组
double ans;
int n;
int sx,sy,ex,ey;
double r[7];//记录每个圆的半径
double dis[7][7];//圆心之间的距离
double s()
{    double ss=0.0;
    for(int i=0;i<n;i++)
    {    
        double r1=min(abs(p[a[i]].x-sx),abs(p[a[i]].x-ex));
        double r2=min(abs(p[a[i]].y-sy),abs(p[a[i]].y-ey));//先确定点和边界谁的半径小
        r1=min(r1,r2);
        for(int j=0;j<i;j++)
            {
            if(r[a[j]]!=0)        
            r1=min(dis[a[i]][a[j]]-r[a[j]],r1);
            if(r1<0)r1=0;//接着对前i个油滴的半径遍历，找出当前油滴的最小半径
            }
        r[a[i]]=r1;//储存
        //cout<<r1<<endl;
        ss+=PI*r1*r1;//计算面积
        //cout<<ss;    
    }
    return ss;
```
}//这是计算函数

```cpp
int main(){
    freopen("123.txt","r",stdin);
    cin>>n;
    cin>>sx>>sy>>ex>>ey;
    memset(r,0,sizeof(r));
    for(int i=0;i<n;i++)
        {
            a[i]=i;
            cin>>p[i].x>>p[i].y;
        }
        memset(dis,0,sizeof(dis));//输入和初始化
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
            {
            if(i!=j&&dis[i][j]==0)dis[i][j]=dis[j][i]=sqrt(pow(p[i].x-p[j].x,2)+pow(p[i].y-p[j].y,2));    
            //cout<<dis[i][j]<<endl;
```
}//事先计算出亮点之间距离方便调用
while(next\_permutation(a+0,a+n))//用STL库中的全排列

            
```cpp
    {    for(int i=0;i<n;i++)//cout<<a[i]<<endl;;
        ans=max(s(),ans);
        memset(r,0,sizeof(r));//注意遍历一次一定要把r数组给清零
    }
    double sum=abs(sx-ex)*abs(sy-ey);//求出长方体面积
    //cout<<sum<<" ";
    int cur=sum-ans+0.5;//这是从楼下学的四舍五入，感觉很巧啊之前都没见过
    cout<<cur; 
}
```

---

## 作者：pantw (赞：0)

n最多就6，因此枚举足矣，难点在于对思维的缜密性要求较高。

废话不多说上代码，注释已经很详尽了。

```cpp
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
int n,xa,ya,xb,yb;
const double infd=100000000.0;//这个是对于double的INF 
const double PI=acos(-1);//为了精度 
double ans;
int x[10],y[10];
double r[10];
int seq[10];
int fact[10]={0,1,2,6,24,120,720};//阶乘值,其实就是全排列数 
double dist(int a,int b){//求两圆a,b的圆心距 
    return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));
}
void solve(){
    double cur;//current answer目前的答案 
    cur=abs(xa-xb)*abs(ya-yb);//刚开始还没被油滴覆盖,所以是整个盒子面积 
    for(int i=0;i<n;i++){//对填充序列中的每个圆计算其在此情况下的半径 
        double mr=infd;//当前圆的半径的最大值max radian(mr) 
        mr=min(min(abs(x[seq[i]]-xa),abs(x[seq[i]]-xb)),min(abs(y[seq[i]]-ya),abs(y[seq[i]]-yb)));
        //以上该行只考虑了盒子边界，未考虑其他之前填好的圆 
        for(int j=0;j<i;j++){//现在考察之前扩展完毕的油滴 
            double t=dist(seq[i],seq[j])-r[seq[j]];
            //圆心距减去该圆半径，有可能有负数，此时本圆被包含在之前的圆中，需要特判，否则WA60分 
            mr=mr<max(t,(double)0)?mr:max(t,(double)0);//特判。三思而后提交！consider twice before you submit!
        }
        r[seq[i]]=mr;//记录该圆半径 
        cur-=PI*mr*mr;//计算目前未被覆盖的面积 
    }
    ans=min(ans,cur);//更新答案 
    return;
}
int main(){
    cin>>n>>xa>>ya>>xb>>yb;
    ans=abs(xa-xb)*abs(ya-yb);//初始化 
    for(int i=0;i<n;i++){
        seq[i]=i;
        cin>>x[i]>>y[i];
    }
    for(int i=0;i<fact[n];i++){
        solve();
        next_permutation(seq,seq+n);//求下一个排列 
    }
//    cout<<round(ans);用round会导致被卡掉10分！
    cout.precision(0);
    cout<<fixed<<ans; 
    return 0;
}
```

---

## 作者：1124828077ccj (赞：0)

楼下的，好好的STL全排列不用，递归干什么？

我~~机智的~~使用了STL函数next\_permutation，求下一个排列。

然后再依次进行每个油滴的扩展，其实就是算出每一个点的油滴最大可能的半径

~~为什么π赋值成3.14只有10分呢？这是个问题。~~

~~为什么π赋值成3.141592653589会满分呢？这也是个问题。~~

附上代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
const double pi=3.141592653589;
int n,s1[10],s2[10],x[4],y[4],a[10];
double ans,m,p[10];
void pd(int u){
    double g=1e9;
    for (int i=0;i<u;i++)
    g=min(g,sqrt((s1[a[i]]-s1[a[u]])*(s1[a[i]]-s1[a[u]])+(s2[a[i]]-s2[a[u]])*(s2[a[i]]-s2[a[u]]))-p[a[i]]);
    for (int i=0;i<4;i++)
    g=min(g,(double)min(abs(x[i]-s1[a[u]]),abs(y[i]-s2[a[u]])));
    p[a[u]]=max(g,0.0);
    m+=p[a[u]]*p[a[u]]*pi;
}
int main()
{
    scanf("%d%d%d%d%d",&n,&x[0],&y[0],&x[2],&y[2]);
    x[1]=x[0];y[1]=y[2];x[3]=x[2];y[3]=y[0];
    for (int i=0;i<n;i++)
    {
        a[i]=i;
        scanf("%d%d",&s1[i],&s2[i]);
    }
    do
    {
        m=0;
        memset(p,0,sizeof(p));
        for (int i=0;i<n;i++)
        pd(i);//枚举每一个点的扩展
        ans=max(ans,m);
    }while(next_permutation(a,a+n));//求下一个排列
    printf("%.0lf",abs(x[2]-x[0])*abs(y[2]-y[0])-ans);
    return 0;
}
```

---

## 作者：CoolTeam (赞：0)

对于样例的理解，第一个油滴扩散半径为3，因为受矩形框的限制。第二个油滴扩散半径小于3，因为受第一个油滴的限制。r2受r1限制，即r2<=dis-r1. （dis为圆心距）

枚举n个点的先后顺序。对于第i个油滴，能扩散到的半径Ri只受矩形和前i-1个油滴半径的约束，为方便求Ri，可以先预处理出各个点之间的距离dis[i][j]。

```cpp
#include<stdio.h>
#include<math.h>
#define PI 3.1415926
int n,vis[7];
double A[7][2],x,y,x2,y2,R[7],max,dis[7][7];
double abss(double a){return a>0.0?a:-a;}
void dfs(int step,double s)
{//准备放置第step个油滴，放置前面积为s
    int k,i;
    double r=0;//准备放置的油滴的扩散半径 
    if(step==n+1)//放完 
        max=s>max?s:max;
    else
    for(k=1;k<=n;k++) if(!vis[k])
    {
        //矩形和已放置的油滴约束了r的大小 
        r=abss(y2-A[k][1]);
        if(r>abss(x2-A[k][0]))r=abss(x2-A[k][0]);
        if(r>abss(y-A[k][1])) r=abss(y-A[k][1]);
        if(r>abss(x-A[k][0])) r=abss(x-A[k][0]);
        for(i=1;i<=n;i++) if(vis[i])
            if(r>dis[k][i]-R[i]) r=dis[k][i]-R[i];
        r=r<0?0:r;//注意r不能为负 
        vis[k]=1;R[k]=r;
        dfs(step+1,s+PI*r*r);
        vis[k]=0;R[k]=0.0;
    }
}
int main(void)
{
    int i,j;
    scanf("%d%lf%lf%lf%lf",&n,&x,&y,&x2,&y2);
    for(i=1;i<=n;i++) 
    {scanf("%lf%lf",&A[i][0],&A[i][1]);} 
    //预处理出油滴间距dis 
    for(i=1;i<=n;i++) for(j=1;j<i;j++) if(i!=j)
        dis[i][j]=dis[j][i]=
        sqrt((A[i][0]-A[j][0])*(A[i][0]-A[j][0])+
            (A[i][1]-A[j][1])*(A[i][1]-A[j][1]));
    dfs(1,0.0);
    double S=abss(x-x2)*abss(y-y2);//矩形面积 
    printf("%.0lf",S-max);
    return 0;
}
```

---

## 作者：Mr_Li (赞：0)

由于n十分小，所以我们可以枚举每个滴油滴顺序中油滴占据的面积，求这些面积的最大值与框子面积的差的相反数，最少枚举个数为n!次，未优化的枚举为n^n次，两种方案都不会超时。

       那么问题来了，[delete]挖掘机技术哪家强？[/delete]如何求油滴占据面积？设油滴i扩散面积Si=π▪ri^2。若框子中只有一个油滴，x'=y=y'=∞，则r1=|x-x1|（证明应该不难）。同理，若x=y=y'=∞，则r1=|x'-x1|；若x=x'=y'=∞，则r1=|y-y1|；若x=x'=y=∞，则r1=|y'-y1|。综上所述，若框子中只有一个油滴，则r=min(|x-x1|,|x'-x1|,|y-y1|,|y'-y1|)。若框子中有两个油滴，且x=x'=y=y'，则r2=sqrt((x1-x2)^2+(y1-y2)^2)-r1（其中sqrt((x1-x2)^2+(y1-y2)^2)表示两点距离，sqrt(x)表示根号x，应用勾股定理）（也很容易证明）。
所以ri=min{|x-xi|,|x'-xi|,|y-yi|,|y'-yi|,sqrt((xi-xj)^2+(yi-yj)^2)-rj}，求ri的时间复杂度为O(n)，求整个数列r的时间复杂度为O(n^2)，该算法时间复杂度为O(n^n▪n^2)，不会超时。
附代码：

```cpp

#include<iostream>
#include<stdio.h>
using namespace std;
int n,i,order[7];
double x1,y1,x2,y2,dot[7][2],area,r[7],answer=0;
bool use[7]={};
inline long double
sqrt(long double __x)
{ return __builtin_sqrtl(__x); }
int DFS (int No,int last)
{
    order[No-1]=last;
    use[last]=1;
    if (No>n)
    {
             area=0;
             for (int i=1;i<=n;i++)
             {
                 r[i]=min(min(max(x1-dot[order[i]][0],dot[order[i]][0]-x1),max(x2-dot[order[i]][0],dot[order[i]][0]-x2)),min(max(y1-dot[order[i]][1],dot[order[i]][1]-y1),max(y2-dot[order[i]][1],dot[order[i]][1]-y2)));
                 for (int j=1;j<i;j++)
                 r[i]=min(r[i],(double)sqrt((dot[order[i]][0]-dot[order[j]][0])*(dot[order[i]][0]-dot[order[j]][0])+(dot[order[i]][1]-dot[order[j]][1])*(dot[order[i]][1]-dot[order[j]][1]))-r[j]);
                 r[i]=max(r[i],0.0);
                 area+=r[i]*r[i]*3.1415926535;
             }
             answer=max(answer,area);
    }
    for (int i=1;i<=n;i++)
    if (!use[i])
    DFS(No+1,i);
    use[last]=0;
}
int main ()
{
    cin>>n>>x1>>y1>>x2>>y2;
    for (i=1;i<=n;i++)
    cin>>dot[i][0]>>dot[i][1];
    DFS(1,0);
    printf("%.0f",(max(x1-x2,x2-x1))*(max(y1-y2,y2-y1))-answer);
    return 0;
}

```

---


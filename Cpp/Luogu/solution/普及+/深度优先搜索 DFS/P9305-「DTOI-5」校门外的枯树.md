# 「DTOI-5」校门外的枯树

## 题目背景

某天放学，你走出了校门，发现校门外又双叒叕出现了一排树。只不过因为正值寒冬时节，树的叶子都掉光了，树们在寒风中瑟瑟发抖，让人担心它们会不会在某一时刻失去平衡，然后倒下来。

## 题目描述

给你校门外的一排 $T$ 棵无向有根树（每棵树的根节点编号均为 $1$），每棵树的每条边有其重量 $m_i$，现在请你算出每棵树的不平衡度 **或** 该树的**每个节点的子树**的不平衡度，好让校方帮忙加固。$\color{white}\sout{\text{不要问我为什么重量的字母是 }m\text。}$

注意这里的**树的边是有顺序的**，~~你总不可能把树枝掰断然后嫁接到另一个地方吧，这可是枯树啊喂~~。

---

对于一颗有根树，定义其不平衡度为该树被在根节点与某一叶子节点的一条最短路径分割为左右两部分（两个边集）后（两个边集均不含该最短路径中的边）两部分的边的总重之差的最小值。特别地，**单个点作为树的不平衡度为 $0$**；空边集内边的总重为 $0$。

## 说明/提示

**【数据范围】**

**不捆绑测试**，同一 $\text{Subtask}$ 内每个测试点等分。

$$
%\def\or{\operatorname{or}}
%这 arraystretch 咋老是拼错/oh
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask}&\sum n\leqslant&k=&\textbf{Special Constraints}&\textbf{Score}\cr\hline
\sf1&2\times10^5&1&\bf A&1\cr\hline
\sf2&20&1&T=1&5\cr\hline
\sf3&5000&1&&5\cr\hline
\sf4&10^5&2&\bf B&15\cr\hline
\sf5&3\times10^5&1&&30\cr\hline
\sf6&2\times10^5&2&\bf A'&4\cr\hline
\sf7&3\times10^5&2&&40\cr\hline
\end{array}
$$
- 特殊性质 $\bf A$ ~~限宽 2.6m~~：保证每棵树只有一个叶子节点（$n\geqslant2$）。
- 特殊性质 $\bf B$ ~~限高 4.5m~~：保证每棵树都为菊花图（根节点有 $n-1$ 个儿子）。
- 特殊性质 $\bf A'$：保证每棵树都是链（每个节点的度数不超过 $2$）。

关于 $\bf A$ 和 $\bf A'$ 的区别：$\bf A'$ 中有可能树的根的度数为 $2$，而 $\bf A$ 中根的度数显然为 $1$。

对于 $100\%$ 的数据，$T \leqslant 4000$，${\color{red}\textbf1}\leqslant n\leqslant 10^5$，$\sum n\leqslant 3\times10^5$，$1 \leqslant m_i \leqslant10^4$，$1\leqslant u, v\leqslant n$，$k\in\{1,2\}$。

---
叶子节点为没有儿子的节点，即除根节点以外在树中的度为 $1$ 的点。

样例输入中为方便阅读加上了空行，实际数据中没有空行。


**【样例 $\bm1-\bm1$ 解释】**


该树如下图所示，边权即边的重量。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5t1mz7x.png)

最优解为选择 $1\to2\to7$ 作为分割路径，不平衡度为 ${\large\vert}(2+19+19)-7{\large\vert}=33$。

如果选择 $1\to2\to6$ 作为分割路径，那么两部分的边的总重之差为 ${\large\vert}(2+19)-(7+514){\large\vert}=500$，不为最小值。

$\color{transparent}\sout{不知道你们发现没有\begin{cases}114+2+19+19=154\\114+514+19+19=666\end{cases}}$

**【样例 $\bm1-\bm2$ 解释】**

该树如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/14a0rhpe.png)

最优解为选择 $1\to7$ 作为分割路径，不平衡度为 ${\large\vert}(4+8+3+6)-(1+7+5+10){\large\vert}=2$。

## 样例 #1

### 输入

```
2 1
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33
2```

## 样例 #2

### 输入

```
2 2
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33 38 0 0 0 0 0
2 0 6 0 0 0 0 0 0 0 0```

# 题解

## 作者：y_kx_b (赞：9)

呜呜，本来想友情在题面里提醒一下 B2（k=2 version）> C1 的，结果我不能修改团队题目/ng

### $\textbf{Sub }{\sf1}\textbf:$ 以根节点为一端点的链。
因为只有一个叶子节点，所以答案为 $0$ （因为所有边都在根到叶子节点的路径内，两个边集均为空）。
### $\textbf{Sub }{\sf6}\textbf:$ 链。
如果根节点不为链的端点，显然根节点答案为左右两条链的重量的最小值。非根节点转化为 $\text{Sub }{\sf1}$，答案为 $0$。

### $\textbf{Sub }{\sf5}\textbf:$ $k=1$ 正解

一个简单 dfs 就结束了，这不需要讲吧（）。

好吧~~考虑到这题的位置~~还是讲讲吧，我们 dfs 这棵树，儿子就按照一个方向搜，当搜到叶子节点的时候统计这条链带来的贡献，最后所有贡献取最小值输出即可。

另外一个链式前向星的细节，读入顺序是从左往右，可前向星加边后遍历是反着的。这可能作为一个坑点，~~虽然这题没关系因为从左往右还是从右到左都一样。~~

代码中的 `w1` 代表链左边边集的边权和，`w2` 代表链上的边权和，`(wsum - w2 - w1)` 就是右边的边权和啦。
```cpp
int wsum = 0/*读入完成后 wsum = 整棵树的边权总和*/, w1 = 0;
int ans = 0x7f7f7f7f;
void dfs(int u, int w2) {
	if(head[u] == -1) {
		ans = min(ans, abs((wsum - w2 - w1) - w1));
		return;//其实这里写不写都无所谓，因为叶子节点肯定进不了下面这个循环（）
	}
	for(int i = head[u]; ~i; i = ne[i]) {
		int &v = to[i];
		dfs(v, w2 + w[i]);
		w1 += w[i];
	}
}
```
$m_i\leqslant10^4$，所以不用开 long long。

### $\textbf{Sub }{\sf4}\textbf:$ 菊花图。

容易发现问题可以转化为序列上的问题。

>有一个长度为 $n-1$ 的序列 $m$，计算 $\min\limits_{k=1}^{n-1}{\left\vert\sum\limits_{i=1}^{k-1}m_i-\sum\limits_{i=k+1}^{n-1}m_i\right\vert}$。

因为 $m_i>0$，所以这个柿子（绝对值内部）肯定是单调的。所以预处理后直接二分就行。

后来发现非根节点没有儿子，答案一定为 $0$，因此只需要计算根节点的答案，直接 $O(n)$ 枚举 $k$ 这个 Sub 就做完了，很遗憾没有太对正解起到启发作用/kk

### $\textbf{Sub }{\sf7}\textbf:$ $k=2$ 正解
~~其实就是上面这个 $\sout{O(\log n)\text{ Sub}{\sf4}}$。~~

我们发现，每当选择的叶子节点越来越靠右，右边的边权和减去左边的边权和一定越来越小（单调递减）。那么对于每个点的子树的询问，我们就可以直接二分，单次询问复杂度 $O(\log n)$。这里对于每个点都有询问，$q=n$，总复杂度为 $O(n\log n)$。

看个具体的例子吧。**注意这里我们假设 $2$ 为根。**

![](https://cdn.luogu.com.cn/upload/image_hosting/14a0rhpe.png)

我们首先按照 $\text{Sub }{\sf5}$ 的 dfs 预处理出每个叶子节点**相对根的**的 `w1` 和 `w2` 以及每个点子树内包含的叶子节点的范围（即 dfs 序）。比如这里，`w1[9]=9+8+3+6+2+1`，`w1[3]=0`，`w2[7]=4+9+2`。那么我们就可以用前缀和思想，把相对于根节点的 `w` 变成相对于某个给出的根的 `w`，比如 $3$ 子树内的 $7$ 的 `w1` = `w1[7]-w1[3]=8+3+6`，`w2` 同理。

然后就可以二分啦。

std 写的很丑，仅供思路参考用 qwq

代码中 `ww1[i]` 表示节点 $i$ 的 `w1`，`w1[i]` 表示**第 $i$ 个叶子节点**的 `w1`；`w2`同理。`wsum` 为一个点子树内所有的边权总和。
```cpp
int k;
int to[N], ne[N], w[N], head[N], idx1 = 0;
void add(int u, int v, int W) {
	to[idx1] = v, w[idx1] = W, ne[idx1] = head[u], head[u] = idx1++;
}

int wsum[N], ww1[N], ww2[N];
int w1[N], w2[N], idx2 = 0;
pii dfn[N];//左闭右开
int W1 = 0;
void dfs0(int u, int W2) {
	dfn[u].x = idx2;
	ww1[u] = W1, ww2[u] = W2;//ww1必须前序遍历记录。
	if(head[u] == -1)
		w1[/*u*/idx2] = W1, w2[idx2++] = W2;
	for(int i = head[u]; ~i; i = ne[i]) {
		int &v = to[i];
		dfs0(v, W2 + w[i]);
		wsum[u] += w[i] + wsum[v], W1 += w[i];
	}
	dfn[u].y = idx2;
}
int f(int u, int x) {
	//     ( wsum   -        w2        -        w1        * 2);
	return (wsum[u] - (w2[x] - ww2[u]) - (w1[x] - ww1[u]) * 2);
}
bool major(int T = 1) {
	// memset(head, -1, sizeof head);// will TLE for T = 4e3
	int n = read();
	idx1 = idx2 = 0; W1 = 0;
	for(int i = 1; i <= n; i++) head[i] = -1, wsum[i] = 0;
	for(int i = 1; i <= n; i++) {
		int q = read();
        while(q--) {
			int v = read(), y = read();
			add(i, v, y);
		}
	}
	dfs0(1, 0);
	for(int u = 1; u <= n; u++) {
		int l = dfn[u].x, r = dfn[u].y - 1;
		while(l + 1 < r) {//五点七边二分法 yyds！
			int mid = l + r >> 1;
			if(f(u, mid) >= 0) l = mid; else r = mid;
		}
		// if(l == r) ans = abs(f(u, l)); else 
        // 本来要特判叶子节点，但是直接进入下面的语句也是对的（）。
		int ans = min(abs(f(u, l)), abs(f(u, r)));
		if(k == 2)
			printf("%d%c", ans, " \n"[u == n]);
		else //if(u == 1) 
			return printf("%d\n", ans);
	}
	return 0;
}
```

完结撒花！

彩蛋：题目中有一句白色的 $\sout{\text{不要问我为什么重量的字母是 }m\text。}$ ，不过好像梅友仁真正地问（）因为本来这场比赛就没给彩蛋供钱（

upd1 at 23.2.7：造数据时一直在想 $T$ 大了可能就放 $O(n^2)$ 过去了，结果忘了卡全局 `memset`（雾）。

upd2 at 23.4.28：唔，听说可以树形 dp？那是什么神仙做法，不懂。至少我尝试过然后没做出来/ng

upd3 at 24/12/06：原来之前一直把五点七边二分法（[二分查找为什么总是写错？](https://b23.tv/P0THoJu)）的 up 主记成了 3b1b，磕头谢罪）

---

## 作者：_EEA_ (赞：5)

### 题目分析

求一棵树的平衡度，考虑暴力枚举这棵树的叶子节点，然后求出该树被从根节点到这一叶子节点的链分割为左右两部分后两部分的边的总重之差，取最小值。

那么要解决的问题就是如何快速求出某条链左部分和右部分的总重了。由于边是有顺序的，考虑一种类似于前缀和的方法，具体如下。

### $k=1$

预处理好树的叶子节点。对于每一个叶子，考虑维护下面两个量：

- $le(i)$：从左往右深度优先搜索到叶子 $i$ 经过的所有边的总重

  比如下图红色节点的 $le$ 值就是所有红色边的总重之和。

  ![1](https://cdn.luogu.com.cn/upload/image_hosting/ecszp7u6.png)

- $sum(i)$：从根节点到叶子 $i$ 的链上所有边的总重之和

这些都可以用一个 dfs 完成预处理。

于是——

![2](https://cdn.luogu.com.cn/upload/image_hosting/1di0ew4h.png)

不难发现，上图红色链左部分（蓝色）总重之和可表示为 $le(1)-sum(1)$；右部分（绿色）总重之和可表示为 $le(2)-le(1)$。

从左往右枚举叶子节点，对应的链的左部分总重之和单调递增，右部分单调递减，左右部分的差值单调递增，并且有一个零点，于是又可以二分枚举，找出左右部分差值的最小绝对值即是答案。总复杂度 $O(T(n+\log n))$。

### $k=2$

沿用上面的思想方法。

对于每个节点对应的子树，可以预处理出这个字子树最左边和最右边的叶子节点，然后二分枚举。只不过要将上面维护的两个量扩展一下，为每个节点都维护，不仅仅是叶子：

- $le(i)$：从左往右深度优先搜索到节点 $i$ 经过的所有边的总重
- $sum(i)$：从根节点到节点 $i$ 的链上所有边的总重之和

预处理还是都可以用一个 dfs 完成。

于是——

![3](https://cdn.luogu.com.cn/upload/image_hosting/wpnzn8f1.png)

对于节点 $0$ 对应的这棵子树，不难发现，上图红色链及其左部分（蓝色）总重之和可表示为 $le(1)-le(0)$，红链上的边的总重之和可表示为 $sum(1)-sum(0)$，于是蓝色部分总重为：
$$
le(1)-le(0)-sum(1)+sum(0)
$$
绿色部分总重为 $le(2)-le(1)$。

枚举每一个节点对应的子树，二分枚举其叶子节点即可求出答案。总复杂度 $O(T(n+n\log n))$。

赛时代码写得很难看，以上流程讲述应该足够清晰了，就不贴代码了。（逃

---

## 作者：_edge_ (赞：2)

挺不错的一道题，但是我有非常暴力的解法。

考虑维护当前这个点到达叶子的权值，这里权值的定义是把这个点到某个叶子的这条链劈开来，然后左边总和减右边总和的权值，我们把它扔到一个 set 里面，然后查询的时候就直接 lower_bound 寻找 $0$ 即可。

当然，问题主要出在如何将一个点的儿子的 set 合并上来，这个可以用启发式合并来维护。

还有一个小问题是，合并的时候可能涉及到整体加或者减，这个可以直接用懒标记维护。

计算权值的时候用前缀和稍微简化一下即可。

另一道类似的题目是 CF1709E XOR Tree。

时间复杂度 $O(n \log^2 n)$。

```cpp
#include <bits/stdc++.h>
#define int long long 
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int INF=1e6+5;
int k,ans[INF],pre[INF],fa_set[INF],suf[INF],n,lazy[INF],sum2[INF];
vector < pii > e[INF];
multiset <int> s[INF];
int find_set(int x) {return x==fa_set[x]?x:fa_set[x]=find_set(fa_set[x]);}
void mer(int x,int y) {
	x=find_set(x);y=find_set(y);
	if (s[x].size()>s[y].size()) swap(x,y);
	for (int i:s[x]) s[y].insert(i+lazy[x]-lazy[y]);
	s[x].clear();fa_set[x]=y;
}
void DFS(int x) {
	if (e[x].size()==0) {s[x].insert(0);sum2[x]=0;ans[x]=0;return ;}
	for (pii v:e[x]) DFS(v.fi);
	int len=e[x].size();
	for (int i=0;i<len;i++)
		pre[i]=(i-1>=0?pre[i-1]:0)+(e[x][i].se)+sum2[e[x][i].fi];
	for (int i=len-1;~i;i--)
		suf[i]=(i+1<len?suf[i+1]:0)+(e[x][i].se)+sum2[e[x][i].fi];
	
	sum2[x]=pre[len-1];
	for (int i=0;i<len;i++) {
		auto v=e[x][i];
		lazy[find_set(v.fi)]+=(i-1>=0?pre[i-1]:0)-(i+1<len?suf[i+1]:0);
		mer(x,v.fi);
	}
	int id=find_set(x);
	auto it=s[id].lower_bound(-lazy[id]),it1=it;
	if (it==s[id].end()) ans[x]=*(--it)+lazy[id];
	else if (it==s[id].begin()) ans[x]=*it+lazy[id];
	else ans[x]=min(abs(*it+lazy[id]),abs(*(--it1)+lazy[id]));
}
void solve() {
	cin>>n;
	for (int i=1;i<=n;i++) 
		vector <pii> ().swap(e[i]);
	for (int i=1;i<=n;i++) s[i].clear(),fa_set[i]=i,lazy[i]=0;
	for (int i=1;i<=n;i++) {
		int len=0;cin>>len;
		for (int j=1;j<=len;j++) {
			int x=0,y=0;
			cin>>x>>y;
			e[i].pb({x,y});
		}
	}
	DFS(1);
	if (k==2) {
		for (int i=1;i<=n;i++) cout<<abs(ans[i])<<" ";
		cout<<"\n";
	}
	else cout<<abs(ans[1])<<"\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	int t=0;cin>>t>>k;
	while (t--) solve();
	return 0;
}
```


---

## 作者：tokitsukaze (赞：1)

## 题意简述

给一棵树，树有边权，根为 $1$。选择一个叶子 $x$，删除根到叶子 $x$ 这条链，会把树分成左右两个部分，假设左半边的边权和叫 $left\_sum$，右半边的边权和叫 $right\_sum$，问选择哪个叶子使得 $|left\_sum - right\_sum|$ 最小，求出最小值即可。

## 题目分析

观察题面给的图，删掉 $1-3-7$ 这条链后，会把树分成左半边（蓝色部分），和右半边（绿色）部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/p9cjep81.png)

会发现蓝色这两个部分分别是 $1-3$ 和 $3-7$ 的左边，绿色这部分是 $1-3$ 的右边。

所以左半边的和其实是链上节点的左子节点的子树和，右半边同理。

比如根节点 $1$ 有子节点 $[2,3,8,9,11]$。假设按照 $1-8$ 切，那左边的贡献就是节点 $[2,3]$ 的子树和，同理右边的贡献是节点 $[9,11]$ 的子树和。接着再往下看节点 $8$ 的子节点，同样分成左边和右边（虽然这个样例节点 $8$ 没有子节点）。

根据手画的图来模拟，可以得到 80pt 的做法。

### 80pt 做法

枚举每个叶子节点，暴力爬到根，每次爬的时候累加左半部分的和与右半部分的和，然后更新爬到的所有节点的答案。

为了方便，这道题可以将边权映射到点权上，每个节点的点权为这个节点与它父亲节点的边权。

首先预处理出每个节点的子树和 $v_x$。

然后我们需要计算每个节点的左边所有子树和 $bit_x$ 与右边所有子树和 $suf_x$。比如：根节点 $1$ 的子节点 $[2,3,8,9,11]$，$bit_8$ 的值是根分别为 $[2,3]$ 的子树和的和，$suf_8$ 的值是根分别为 $[8,9]$ 的子树和的和。

最后枚举所有叶子节点暴力爬到根即可。

### 80pt 代码

```cpp
#define mem(a,b) memset((a),(b),sizeof(a))
#define pb push_back
#define sz(x) ((int)x.size())
#define all(x) x.begin(),x.end()
typedef long long ll;
typedef vector<int> VI;
/************* define end  *************/
void go();
int main(){
	#ifdef tokitsukaze
		freopen("TEST.txt","r",stdin);
	#endif
	go();return 0;
}
const int INF=0x3f3f3f3f;
const ll LLINF=0x3f3f3f3f3f3f3f3fLL;
const double PI=acos(-1.0);
const double eps=1e-6;
const int MAX=3e5+10;
const ll mod=998244353;
/***************  head  *****************/
VI mp[MAX];
int v[MAX],fa[MAX];
int bitsum[MAX],sufsum[MAX],ans[MAX];
void dfs_v(int x)
{
	for(auto &to:mp[x])
	{
		dfs_v(to);
		v[x]+=v[to];
	}
}
void dfs(int x)
{
	int i,bit,suf,to;
	bit=suf=0;
	bitsum[x]=sufsum[x]=0;
	for(i=0;i<sz(mp[x]);i++) suf+=v[mp[x][i]];
	for(i=0;i<sz(mp[x]);i++)
	{
		to=mp[x][i];
		dfs(to);
		suf-=v[to];
		bitsum[to]=bit;
		sufsum[to]=suf;
		bit+=v[to];
	}
}
void go()
{
	int T,k,n,m,i,a,b,bit,suf;
	read(T,k);
	while(T--)
	{
		read(n);
		VI leaf;
		fa[1]=0;
		for(i=1;i<=n;i++)
		{
			mp[i].clear();
			read(m);
			if(m==0) leaf.pb(i);
			while(m--)
			{
				read(a,b);
				mp[i].pb(a);
				fa[a]=i;
				v[a]=b;
			}
		}
		dfs_v(1);
		dfs(1);
		for(i=1;i<=n;i++) ans[i]=INF;
		for(auto x:leaf)
		{
			bit=suf=0;
			while(x)
			{
				bit+=bitsum[x];
				suf+=sufsum[x];
				x=fa[x];
				ans[x]=min(ans[x],abs(bit-suf));
	//			debug(x,bit,suf)
			}
		}
		for(i=1;i<=n;i++)
		{
			if(ans[i]==INF) ans[i]=0;
		}
		if(k==1) printf("%d\n",ans[1]);
		else println(ans,1,n);
	}
}
```

然后发现只有 80pt，因为每次爬链的复杂度是 $O(h)$ 的，$h$ 表示这条链的长度，那假设有 $\dfrac{n}{2}$ 个叶子节点，每条链的长度都为 $\dfrac{n}{2}$，那时间复杂度就是 $O(n^2)$ 级别，不能接受。


### 100pt 做法

现在肯定不能从叶子往上爬，要考虑维护子树下面的东西，dfs 回溯的时候转移上来。

我们可以用 set 维护从所有叶子节点往上爬到当前节点的 $\sum suf-\sum bit$，然后该节点的答案就在 set 里二分找最接近 $bit-suf$ 的两个结果，对 $(bit-suf) - (\sum suf-\sum bit)$ 取 min。

如果暴力合并，最后也是 80pt，可以写个暴力合并看看别的地方有没写错。

所以这里需要进行启发式合并。合并时，子节点的 set 里的所有值需要加上当前 $suf-bit$ 的结果。

但因为是启发式合并，可能是将当前节点的 set 合并入子节点的 set，这时候可以用一个变量 $sum_x$ 表示该节点的 set 里的所有数都需要 $+sum_x$，类似于线段树的懒标记。

由于这里要维护懒标记，启发式合并时多了许多细节，具体请参考代码。

时间复杂度 $O(n \log^2 n)$。

### 100pt 代码

```cpp
#define mem(a,b) memset((a),(b),sizeof(a))
#define pb push_back
#define sz(x) ((int)x.size())
#define all(x) x.begin(),x.end()
typedef long long ll;
typedef vector<int> VI;
/************* define end  *************/
void go();
int main(){
	#ifdef tokitsukaze
		freopen("TEST.txt","r",stdin);
	#endif
	go();return 0;
}
const int INF=0x3f3f3f3f;
const ll LLINF=0x3f3f3f3f3f3f3f3fLL;
const double PI=acos(-1.0);
const double eps=1e-6;
const int MAX=3e5+10;
const ll mod=998244353;
/***************  head  *****************/
VI mp[MAX];
set<int> res[MAX];
int v[MAX];
int ans[MAX],sum[MAX];
void dfs_v(int x)
{
	for(auto &to:mp[x])
	{
		dfs_v(to);
		v[x]+=v[to];
	}
}
void dfs(int x)
{
	int i,bit,suf,to;
	ans[x]=INF;
	sum[x]=0;
	res[x].clear();
	bit=suf=0;
	for(i=0;i<sz(mp[x]);i++) suf+=v[mp[x][i]];
	for(i=0;i<sz(mp[x]);i++)
	{
		to=mp[x][i];
		dfs(to);
		suf-=v[to];
		if(!sz(res[to])) ans[x]=min(ans[x],abs(bit-suf));
		else
		{
			auto it=res[to].lower_bound(bit-suf-sum[to]);
			if(it!=res[to].end()) ans[x]=min(ans[x],abs((*it+sum[to])-(bit-suf)));
			if(it!=res[to].begin())
			{
				--it;
				ans[x]=min(ans[x],abs((*it+sum[to])-(bit-suf)));
			}
		}
		if(sz(res[to])==0)
		{
			res[x].insert(suf-bit-sum[x]);
		}
		else
		{
			if(sz(res[to])<sz(res[x]))
			{
				for(auto &it:res[to]) res[x].insert(it+(suf-bit+sum[to]-sum[x]));
			}
			else
			{
				for(auto &it:res[x]) res[to].insert(it-(suf-bit+sum[to])+sum[x]);
				swap(res[x],res[to]);
				sum[x]=(suf-bit+sum[to]);
			}
		}
		bit+=v[to];
	}
//	debug(x,sum[x])
//	for(auto &it:res[x]) debug(it)
	if(ans[x]==INF) ans[x]=0;
}
void go()
{
	int T,k,n,m,i,a,b;
	read(T,k);
	while(T--)
	{
		read(n);
		for(i=1;i<=n;i++)
		{
			mp[i].clear();
			read(m);
			while(m--)
			{
				read(a,b);
				mp[i].pb(a);
				v[a]=b;
			}
		}
		dfs_v(1);
		dfs(1);
		if(k==1) printf("%d\n",ans[1]);
		else println(ans,1,n);
	}
}
```




---


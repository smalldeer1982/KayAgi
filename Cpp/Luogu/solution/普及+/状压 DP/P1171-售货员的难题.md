# 售货员的难题

## 题目背景

**数据有更改**


## 题目描述

某乡有 $n\ (2\le n\le 20)$ 个村庄，有一个售货员，他要到各个村庄去售货，各村庄之间的路程 $s\ (0<s<1000)$ 是已知的，且 $A$ 村到 $B$ 村与 $B$ 村到 $A$ 村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 $1$，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。


## 样例 #1

### 输入

```
3
0 2 1
1 0 2
2 1 0```

### 输出

```
3```

# 题解

## 作者：logicYZL (赞：77)

#### 这应该是最清晰简洁的一篇了。。。

### 很容易想到一种朴素的做法，就是枚举n个点的全排列，计算路径长度，取最小值，时间复杂度为O(n*n!)，可以使用状态压缩dp将其优化到O(n2*2n)

### 在任意时刻，要表示出哪些点被走过，哪些点没有被走过，可以用一个n位二进制数，若其第i位(0<=i<n)为1，则表示第i个点已经被经过，反之未被经过。在任意时刻还需要知道当前所处的位置，因此使用Fi,j表示点被经过的状态对应的二进制数为i，且目前处于点j时的最短路径。

### 初始值F[1,0]，即只经过了点0（i只有第0位是1），目前处于起点0，最短路径长度为0。方便起见，将F的其他值设为极大值，目标状态为F[(1<<n)-1,n-1]，即经过所有点（i的所有位都是1），处于终点n-1的最短路。

### 在任意时刻，有公式F[i,j]=min{F[i ^ (1<<j),k]+weight(k,j)},0<=k<n并且((i>>j)&1)=1，即当前时刻“被经过的点的状态”对应的二进制数为i，处于点j。因为j只能恰被经过1次，所以一定是刚刚经过的，故在上一时刻“被经过的点的状态”对应的二进制数的第j位应该赋值为0，也就是i(1<<j)。另外，上一时刻所处的位置可能是i(1<<j)中任意一个是1的位置k，从k走到j需要weight(k,j)，可以考虑取所有这样的k取最小值。


------------

```c
#include<bits/stdc++.h>
using namespace std;
int f[1<<20][20],w[20][20],n;
int main()
{
	memset(f,0x3f,sizeof f);
	f[1][0]=0;
	cin>>n;
	for(int i=0;i<n;++i)
		for(int j=0;j<n;++j)
			scanf("%d",&w[i][j]);
	for(int i=1;i<(1<<n);i+=2) 
	{
		for(int j=0;j<n;j++)
		{
			if(!((i >> j) & 1)) continue; //当前i状态下，根本没有走过j
			for(int k=0;k<n;k++)
			{
				if(j==k) continue;       //从自己到自己？。。。 
				if(!(i>>k &1)) continue; //上一次状态，根本没有走过k，就更不可能从k转移到j
				f[i][j]=min(f[i][j],f[i^(1<<j)][k]+w[k][j]);
			}
		}
	}
	int minn=8848888;
	for(int i=0;i<=n-1;++i)
	{
		minn=min(minn,f[(1<<n)-1][i]+w[i][0]);
	}
	cout<<minn;//所有点走完，最后停在n-1点上
}
```

---

## 作者：niiick (赞：68)

TSP问题，也算是状压DP经典吧

**我们以一串二进制数表示村庄的集合（状态）**

**1表示该村庄访问过，0表示没有**

$dp[i][j]$表示
**从起点到第j号点**
且到达时**状态恰好为i的最短路**

则最后答案就是$min(dp[(1<< n) -1][i] + map[i][1])$ $(2<=i<=n)$

其中map数组是题目给定的各村庄间距离

而求取dp数组的方法
我们可以借鉴**Floyd**的思想

 具体代码：

```
for(int i=0;i<=(1<<n)-1;++i)
for(int j=1;j<=n;++j)
if( ( (1<<j-1)&i )==0 )
for(int k=1;k<=n;++k)
if( ( (1<<k-1)&i) )
dp[i|(1<<j-1)][j]=min(dp[i|(1<<j-1)][j],dp[i][k] + rem[k][j]);

```
如何解释呢

第一层循环 i **枚举每个状态**

第二层循环 j **枚举下一步到达的点**

if( !( (1 << j-1) & i) ) 这句**判断 j 是否已访问**

**1左移j-1位，则此时只有第j位是1**

**若状态 i 的第 j 位为1，则&与运算返回1，表示已访问，否则没访问**

第三层循环**枚举中介点k**，
其中if语句判断同上

$dp[i|(1<<j-1)][j]=min(dp[i|(1<<j-1)][j],dp[i][k] + rem[k][j]);$

$i|(1<<j-1)$ 将状态$i$的第$j$为置为1得到**下一步的状态**

$dp[i][k] + map[k][j]$表示在当前状态i中寻找中介点检查最短路是否可以更新


```
//niiick
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=1100010;
int n,ans=2e9;
int dp[maxn][25];
int rem[25][25];

int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    rem[i][j]=read();

    memset(dp,67,sizeof(dp));
    dp[1][1]=0;//状态1表示此时只有1号点访问过

    for(int i=0;i<=(1<<n)-1;++i)//dp过程解释如上
    for(int j=1;j<=n;++j)
    if( ( (1<<j-1)&i )==0 )
    for(int k=1;k<=n;++k)
    if( ( (1<<k-1)&i) )
    dp[i|(1<<j-1)][j]=min(dp[i|(1<<j-1)][j],dp[i][k] + rem[k][j]);

    for(int i=2;i<=n;i++)//最后从状态(1<<n)-1（二进制全为1）中寻找到1最短的点
    ans=min(ans,dp[(1<<n)-1][i] + rem[i][1]);

    printf("%lld",ans);
    return 0;
}
```
n<=20的数据范围在状压题中算是开到极限了，蒟蒻担心卡常所以开了O2，最大的点跑了541ms，目测不开O2也是能过的
**********************
#### 9.15——Update
再提供一种**状压搜索**的思路，~~虽然试了好几次都卡不过最后一个点~~，所以仅供参考学习吧，因为这种思路也挺常用的

dp数组含义依然同上，
初始$dp[1][1]=0$

搜索具体代码，应该不难理解
```cpp
void dfs(int x,int u)//x是当前状态，u是当前到达的结点
{
    for(int i=1;i<=n;++i)
    if(((1<<i-1)&x)==0)//枚举还未到达的点
    if(dp[x|(1<<i-1)][i]>dp[x][u]+rem[u][i])//如果可以更新就继续搜索
    {
        dp[x|(1<<i-1)][i]=dp[x][u]+rem[u][i];
        dfs(x|(1<<i-1),i);
    }
}
```
最终答案判断方法与上述DP相同

~~虽然这种方法艹不过此题~~,但建议要理解这种思路
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef double dd;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=1050000;
int n,ans=2e9;
int rem[22][22],dp[maxn][22];

void dfs(int x,int u)
{
    for(int i=1;i<=n;++i)
    if(((1<<i-1)&x)==0)
    if(dp[x|(1<<i-1)][i]>dp[x][u]+rem[u][i])
    {
        dp[x|(1<<i-1)][i]=dp[x][u]+rem[u][i];
        dfs(x|(1<<i-1),i);
    }
}

int main()
{
    n=read();
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    rem[i][j]=read();
    
    memset(dp,67,sizeof(dp)); dp[1][1]=0;
    dfs(1,1);
    
    for(int i=1;i<=n;++i) 
    ans=min(ans,dp[(1<<n)-1][i]+rem[i][1]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Remmina (赞：50)

此题点数较大，状态压缩动态规划难以通过，因此可以考虑近似算法

但是模拟退火正确率低下，于是可以试试智能算法：

# 蚁群算法

蚁群算法（**A**nt**C**olony**O**ptimization,**ACO**），是一种用来在图中寻找优化路径的机率型算法。

这里有一个蚁群算法的演示：[Github仓库](https://github.com/BreezeDust/AlgorithmsLab/tree/master/heuristic/ACO)

它的灵感来源于蚁群寻找食物的过程，因为往往一只蚂蚁并没有太多“智能”的表现，而蚁群往往有“智能”的动作，比如大部分都趋向于食物

这是因为它们在移动的路径上会留下“信息素”，它们会更大概率沿着信息素更浓的路径行走

而路径越短，信息素就会越浓

这很符合TSP问题的要求

蚁群算法流程大概如下：

1. 初始化算法
2. 派出一只蚂蚁，随机一个点作为蚂蚁的起点
3. 对于蚂蚁当前所在的点，根据所有后继边的信息素浓度以及长度根据公式计算出访问每个后继节点的概率
4. 用轮盘法随机出下一步走到哪个节点
5. 重复3,4步，直到所有节点都访问了一次
6. 计算回路长度，计算经过的边的信息素增加量
7. 所有边上的信息素都会蒸发一定比例使算法收敛，增加经过的边的信息素
8. 回到第2步，进行下一轮迭代

当然第二步只派出一只蚂蚁正确率是很低的，一般要派出节点数数倍的蚂蚁，精度要求越高就要派出更多蚂蚁

首先讲一下怎么计算后继节点访问概率

有这么几个基本的算法参数：

+ $\alpha$，表示**信息素重要程度**
+ $\beta$，表示**能见度重要程度**，能见度指的是边长的倒数
+ $\rho$，蒸发率

若当前第$k$个蚂蚁在点$x$，$x, y$之间的信息素浓度为$\tau _ {xy}$，$x, y$之间的能见度为$\eta _ {xy}$，与$x$相连且未访问的集合为$\mathrm {allowed} _ x$，那么访问接下来$y$的概率为：

$$p _ {xy} ^ {k} = {\frac {(\tau _ {xy}^{\alpha })(\eta _ {xy}^{\beta })}{\sum _ {z\in \mathrm {allowed} _ {x}}(\tau _ {xz}^{\alpha })(\eta _ {xz}^{\beta })}}$$

公式中分子是信息素浓度的$\alpha$次方乘以能见度的$\beta$次方

分母就是所有分子之和

然后再`rand`一个$[0, 1]$之间的随机数，就能选出后继节点了

（如果所有边的浓度都为0，就随便选一个了）

可以发现$\alpha$的取值越大，信息素占比越大；$\beta$的取值越大，能见度占比越大

这个值一般就取$\alpha = \beta = 1$或者$\alpha = 1, \beta = 2$，需要玄学调参

关于信息素的更新，首先是初始化算法的时候需要设定一个初始信息素浓度，这个浓度太大会导致新增的信息素没什么用，太小会导致过快结束算法，陷入局部最优解。

这个值可以先跑一遍贪心算出一个答案，然后参照这个答案设定

怎么设定呢？根据路径越长信息素浓度越低的规则，某只蚂蚁走过的回路长度为$length$的话，那么它对走过的路径的信息素浓度的贡献为$\frac 1 {length}$

因此初始浓度可以设定为$\frac M {length}$，其中$M$表示每批蚂蚁个数

然后根据这个规则，每批蚂蚁走过以后每条边的信息素增加量也是能算出来的

为了精度可以使每次增加的信息浓度乘上一个常数

注意是：

+ $M$只蚂蚁都跑一遍，并记录每条边的信息素增量，但并不加上去
+ 所有蚂蚁都跑完后，每条边都蒸发一定比例
+ 蒸发完后再增加

这个蒸发率$\rho$一般是取$50\%$到$80\%$，蒸发比例越大收敛越快

每次把每条边的信息素浓度都乘以$1 - \rho$，就能逐渐让访问频率高的边的浓度与其他边的浓度差更大，最后其他边的浓度一般会降为0

一般迭代次数就是$500$到$1000$次

于是这题就写出来了

调参心累啊.jpg

```cpp
#include <bits/stdc++.h>

#define NS (25)
#define eps (1e-10)
#define M (80)
#define rho (0.5)
#define alp (1)
#define bet (1)
#define Q (100)
#define Rand() ((double)rand() / RAND_MAX)

using namespace std;

template<typename _Tp> inline void IN(_Tp& dig)
{
	char c; bool flag = 0; dig = 0;
	while (c = getchar(), !isdigit(c)) if (c == '-') flag = 1;
	while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
	if (flag) dig = -dig;
}

int n, dis[NS][NS], path[NS], ans;

bool book[NS];

double info[NS][NS], dt[NS][NS], p[NS];

void init()
{
	int a = 1, len = 0;
	book[1] = 1;
	for (int c = 1; c < n; c += 1)
	{
		int mn = INT_MAX, nxt = 0;
		for (int i = 1; i <= n; i += 1)
			if (!book[i] && dis[a][i] < mn)
				mn = dis[a][i], nxt = i;
		len += dis[a][nxt], a = nxt, book[a] = 1;
	}
	len += dis[a][1], ans = len;
	for (int i = 1; i <= n; i += 1)
		for (int j = 1; j <= n; j += 1)
			info[i][j] = (double)Q * M / len;
}

inline double Pow(double a, int b)
{
	double res = 1;
	for (int i = 1; i <= b; i += 1) res *= a;
	return res;
}

void run()
{
	int a = rand() % n + 1, s = a, len = 0;
	memset(book + 1, 0, sizeof(bool) * n), book[a] = 1;
	for (int c = 1; c < n; c += 1)
	{
		double tot = 0;
		for (int i = 1; i <= n; i += 1)
			if (book[i]) p[i] = 0;
			else
			{
				p[i] = Pow(info[a][i], alp) / Pow(dis[a][i], bet);
				tot += p[i];
			}
		if (tot < eps) return;
		for (int i = 1; i <= n; i += 1) p[i] /= tot;
		double r = Rand();
		for (int i = 1; i <= n; r -= p[i], i += 1)
			if (!book[i] && r <= p[i])
			{
				len += dis[a][i], a = i, book[a] = 1, path[c] = i;
				break;
			}
	}
	len += dis[a][s], dt[a][s] += (double)Q / len, ans = min(ans, len);
	for (int i = 1; i < n; i += 1)
		dt[s][path[i]] += (double)Q / len, s = path[i];
}

int main(int argc, char const* argv[])
{
	IN(n), srand(19260817);
	for (int i = 1; i <= n; i += 1)
		for (int j = 1; j <= n; j += 1)
			IN(dis[i][j]);
	init();
	for (int c = 1; c <= 700; c += 1)
	{
		for (int i = 1; i <= n; i += 1)
			for (int j = 1; j <= n; j += 1)
				dt[i][j] = 0;
		for (int j = 1; j <= M; j += 1) run();
		for (int i = 1; i <= n; i += 1)
			for (int j = 1; j <= n; j += 1)
				info[i][j] = info[i][j] * rho + dt[i][j];
	}
	printf("%d\n", ans);
	return 0;
}
```

~~（但是好像很多Dfs剪枝过了，还挺快的）~~

---

## 作者：白烛葵 (赞：32)

有一天一个蒟蒻，点了搜索标签。。。

进入售货员的难题

水了一发搜索，拿了80分QWQ


```
#include<cstdio>
using namespace std;
int lxy[21][21],hrb[21],n,i,j,k,minn=1e9;
int ss(int x,int y,int z)//x表示村子编号，y表示走了几个村子，z表示用到时间。。。
{
    if(z>minn)return 0;//基本最小值剪枝
    if(y==n&&z+lxy[x][1]<minn)
    {minn=z+lxy[x][1];return 0;}//比较求最小值，其中的加lxy[x][1]意思是走回第一个村
    for(int i=2;i<=n;i++)//循环开始
    if(hrb[i]==0&&i!=x)//深搜模板，没走就搜
    {
        hrb[i]=1;//打点
        ss(i,y+1,z+lxy[x][i]);
        hrb[i]=0;//回溯
    }
    return 0;
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    for(k=1;k<=n;k++)
    scanf("%d",&lxy[i][k]);//输入
    ss(1,1,0);//开搜
    printf("%d",minn);
}
```
交完后。。。

我想：这题暴力分给的好足啊。。。

于是flag：我今天就是从这跳下去，也不看一篇题解！

接着一波优秀的预判剪枝

然而还是只有90分（在100分代码了会讲）~~t10有多坑啊~~

1h后。。。我点开了题解。。。

~~woc~~这都啥玩意？？？

这题不搜索吗？题解咋全是dp状压QAQ

# 我不会写啊，我只会搜索QAQ

好吧！只能靠自己了QWQ

之后我想了一下

出题人一定会在后面卡人

# So struct存图排序是个不错的想法，于是有了100分代码
```
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct pd{int ha,e;}lxy[25][25];
//存图，ha表示各点时间消耗，e表示要去的点，因为排序动列，不动行，所以记下列，就是要去的点
int hrb[25],n,i,j,k,minn=1e9,maxn=1001,emm[25];//新增一个emm数组解决排序动列的问题
int cmp(pd a,pd b){return a.ha<b.ha;}//排序函数
int ss(int x,int y,int z)
{
    if(z>=minn)return 0;//用sort优化，提前找出最小值，剪枝
    if(z+n-y+1+maxn>=minn)return 0；
    //预见性剪枝，maxn表示x点到1的最小距离，然后剩余点取最小值1，极值判定
    if(y==n){minn=min(minn,z+emm[x]);return 0;}
    if(y<n)
    for(int i=2;i<=n;i++)
    if(hrb[lxy[x][i].e]==0)
    //判断是否走过，为啥是lxy[x][i].e,请见上面解释
    {	
    	if(z+lxy[x][i].ha+n-y+maxn>minn)return 0;
        //预见性剪枝，极值判定，用这两个可以90分
        hrb[lxy[x][i].e]=1;
        ss(lxy[x][i].e,y+1,z+lxy[x][i].ha);
        hrb[lxy[x][i].e]=0;
    }
    return 0;
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {    
    	for(k=1;k<=n;k++)
        {
    	    scanf("%d",&lxy[i][k].ha);
    	    lxy[i][k].e=k;//记录列数
    	    if(i!=1&&k==1)
            maxn=min(maxn,lxy[i][1].ha),emm[i]=lxy[i][1].ha;
 //求x到1的最小时间花费，用于预见性剪枝，和存x到1的花费用于搜索结算，解决排序造成的列乱序的情况
        }
        sort(lxy[i]+1,lxy[i]+n+1,cmp);
        //STL大法好，二维数组的排序要用for，sort可以优化找出的答案minn，减少无用功
    }
    hrb[1]=1;//跑过了就要踩，不然会跑回去，想想80分代码为啥不用赋值为1？因为80分列没乱序
    ss(1,1,0);
    printf("%d",minn);
    return 0;
}
```
这题比较麻烦的是猜出题人意图，灵活运用贪心和预见性剪枝

其他的还是很水的

推荐两道题，运用预见性剪枝的p1731生日蛋糕和究极搜索
p1064金明的预算~~不要问为啥，有大佬写出来了~~

# 最后，请点赞，关注，~~投食，素质三连~~QWQ

---

## 作者：Sooke (赞：26)

## 楼下的两个状压题解都只能拿 80 ？这里给出 AC 的状压题解。

状压的思路是一样的。用 v [ i ] [ j ] 来表示 i 状态下走到第 j 个地方的最小值。这里的 i 实质上是一个二进制数，每一位是 0 是 1 即表示每个地方有无去过，但是转为十进制表示状态，这便是状态压缩的基本思想。先从 3（二进制 11） 枚举 i，每次给 i 加 2（因为第一位所表示的第一个地方是起点，不管如何都去过，因此其永远是 1）。得到可能的 i 后，枚举 i 的除第一位外每个为 1 的位，并替换 1 为 0 得到能转移到状态 i 的状态 s，具体转移过程就不多说了，总之位运算什么的详见代码。

那么如何进行优化呢？下面就是几个好办法：

- 1 . 首先如果规定 n = 5，即有售货员要去五个地方，枚举到 i = 3（二进制 00011） 时，我们不一定需要从最低位一直枚举到第 n 位，因为第 n 位可能在枚举 i 的很久以后才能变成 1，这之前都是 0，浪费时间复杂度，因此我们可以规定整数 k，表示目前可能为 1 的最高位的位数。当 i 超过 2 的 k 次方时，更新 k，即为 k 自增。这里 2 的 k 次方可以暂时用变量 p 表示，k 更新时用位运算给 p 向左移一位。

- 2 . 尽量不用 STL 的 min，虽然好用，但是宁愿用 define 手打 QAQ，另外其他联系到位运算的，比如取某数二进制位下的某位的值，也可以用 define 而不是新建什么内联函数。

- 3 . 对于状态 i，其由不同的状态 s 转移而来，因此，我们倒推 s 的时候，先确认其可行性，再枚举 l ，用 v [ s ] [ l ] 更新 v [ i ] [ j ] 的最小值。

个人认为第 2 点优化程度是最大的。下面给出代码：

```cpp
#include <cstdio>
#define Replace(a , b) (a ^ (1 << b-1))
#define Get(a , b) ((a >> b-1) & 1)
#define min(a , b) ((a) < (b) ? (a) : (b))
#define MaxAns 2000000000

int n , m , v[1 << 20][20] , r[20][20] , ans = MaxAns , s;

int main(){
    scanf("%d" , &n);
    m = (1 << n) - 1; // 得到最大的状态 i 是多少 
    for(int i = 1 ; i <= n ; i++)
        for(int j = 1 ; j <= n ; j++)
            scanf("%d" , &r[i][j]);
    for(int i = 1 ; i <= m ; i += 2)
        for(int j = 1 ; j <= n ; j++)
            v[i][j] = MaxAns;
    v[1][1] = 0; // 初始化 
    for(int i = 3 , k = 2 , p = 4 ; i <= m ; i += 2){
        if(i > p)
            p = p << 1 , k++;
        // 更新当前的 k 和 p 
        for(int j = 2 ; j <= k ; j++){
            if(Get(i , j)){ // 确认状态 i 的第 j 位是否为 1 
                s = Replace(i , j);    // 利用位运算替换并得到状态 s 
                for(int l = 1 ; l < j ; l++)
                    v[i][j] = min(v[i][j] , v[s][l] + r[l][j]);
                for(int l = j + 1 ; l <= k ; l++)
                    v[i][j] = min(v[i][j] , v[s][l] + r[l][j]);
                // 枚举时 l ≠j，因为状态 s 的第 j 位一定是被替换的 0 
            } 
     }
    }
    for(int i = 2 ; i <= n ; i++)
        ans = min(ans , v[m][i] + r[i][1]);
    // 由于最后要回到起点，还需一个循环来寻找最终答案 
    printf("%d" , ans); 
    return 0;
}
```

---

## 作者：dzz1537568241 (赞：21)

# 写这份题解，是想要作为 状压 + dp的入门指南

~~一想起我刚学状压的时候，怎一个苦字了得~~

为了防止有人步入我的后尘，所以这篇题解主要是为了扫盲，各位吃瓜的大佬可以走了

# 一，二进制运算

[[洛谷日报第79期]二进制与位运算](https://baijiahao.baidu.com/s?id=1615721955382381294&wfr=spider&for=pc)

这个实在太重要了，先把二进制运算搞懂了，再来搞状压

# 二，状压是什么？

~~众所周知~~，OI是一个搞数学的学课，所谓状压，就是把一个状态表示成一个集合，再把集合表示成二进制数

总的来说就有这样一个过程

**状态 - > 集合 - > 二进制**

在进入具体操作之前，我想先和各位讨论一下，为什么要把集合转成二进制数呢？

二进制，这是一个美妙的进制数，**0/1，表达了 有 或者 没有**

而使用两进制数来描述集合，意味着**集合的这个元素 有 或者 没有**

比如集合S，有4个元素

1111 这个两进制数就能够表达集合 s

那如果要表达集合s，去除第二个元素，这样的子集怎么表示呢？

1011，而去除掉第二个 和 第三个元素的二进制数， 是1001

**推而广之，如果全集共有 N 个元素，**

**去除掉 第a1, 第a2， 第a3... 第an号元素的子集，**

**就是把 N个1构成的两进制数的所有的{an}位上的1，变成0**

- **那么往集合中加入元素呢**

向一个集合 s 中加入第 i 号元素，

就是把两进制数的第 i 位从 0 变为 1

- **删除元素不用我说了吧？**

向一个集合 s 中删除入第 i 号元素，

就是把两进制数的第 i 位从 1 变为 0

下面是整理的一些两进制上的常用操作(我刚刚给你们的链接上有详细的解析，这里只是总集)

```cpp
//集合 s 代表当前集合
//右数 k 位二进制数 0/1 代表 第 k 号元素 不在集合 / 在集合 里 

//必备操作1： 
//将第k个元素加入集合
s | (1 << (k - 1));

//必备操作2：
//将第k个元素从集合中删除
s & (~ (1 << (k - 1)) );

//必备操作3：
//1)如果第k个元素在 集合s里， 删除它
//2)如果不在，把它加入集合s
//可以想象成一盏灯的开关:
//按下开关， 明 -> 暗， 暗 -> 明 
s ^ (1 << (k - 1));

//必备操作4:
//判断元素k 是否在集合s里
//在：返回1，不在：返回0 
(s >> (k - 2)) & 1 == 1

```
# 三，怎么建模？

**step1 : 怎么用集合描述状态？**

以这道题目为例，什么是状态？

一个城市是否已经被走过了可以作为状态，这样就可以把 走过的城市作为一个集合，表示成二进制数

**step2 : 怎么dp？**

这个....枚举就好。


```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 450;

int rd(){
	int x = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9'){if(c == '-'){f = - 1;} c = getchar();}
	while(c >= '0' && c <= '9'){x = x*10 + c - '0'; c = getchar();}
	return x * f; 
}

int N, c[maxn][maxn], f[1 << 20][20];

int dp(){
	//1 << N代表全集
	memset(f,0x3f3f3f,sizeof(f));
	f[(1 << N) - 1][0] = 0;
	for(int s = (1 << N) - 2; s >= 0 ; s--){
		for(int v = 0; v < N ; v++){ 
			//枚举当前集合，售货员处在的位置
			for(int u = 0; u < N; u++){
				if( (s >> u) & 1)continue;//说明已经到过u这个节点了 
				
				f[s][v] = min(f[s][v], f[s|(1 << u)][u] + c[v][u]);
			
			} 
		}
	}
}

int main(){
	N = rd();
	for(int i = 0; i < N; i ++){
		for(int j = 0; j < N; j++){
			c[i][j] = rd();
		}
	}
	dp();
	cout<<dp[0][0];
}
```


---

## 作者：Forever丶CIL (赞：18)

这个题也可以不用状压dp。。

当然裸地搜索只能拿四十分，稍优化点就能80，最后加上一些无脑的东西才能过，

。。。。


------------


```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
const int scope=23;
int n,ans=1<<30,tot;
int vis[scope],minn[scope];
struct node
{
    int order;
    int v;
}pos[scope][scope];
bool rule(const node &s1,const node &s2)
{
    return s1.v<s2.v;
}
void dfs(int x,int num) //x表示当前所在的点，num表示已经走过了num个点 
{
    if(num==n) //如果我们已经走过了n个点，就说明要回一号点了 
    {
        if(tot+minn[x]<ans) ans=tot+minn[x];
        return;
    }
    for(int i=2;i<=n;i++)
    {
        if(!vis[pos[x][i].order])        //如果这个点没走过 
        {
            //剪枝： 
            if(tot+pos[x][i].v>=ans) return; //如果我们走这一步走过的距离就比之前的最优解差了，就不要走了 
            if(tot+(n-num)+1>=ans) return; //即使我们后面要走的路长度都是1，仍然不比最优解好，也不要走了 
            vis[pos[x][i].order]=1;    //剩下就是普通的搜索了，tot记录走的长度 
            tot+=pos[x][i].v;
            dfs(pos[x][i].order,num+1);
            vis[pos[x][i].order]=0;
            tot-=pos[x][i].v;
        }
    }
}
int main()  
{
    scanf("%d",&n);//稳稳的读入数据 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&pos[i][j].v); //因为后面要排序，就分开记录边权和后继 
            pos[i][j].order=j;   //后继 
        }
        minn[i]=pos[i][1].v; //记录一下每个点回一号点的路径长度，因为后面要排序，这样可以避免之后要O（n）找回1点的边 
        sort(pos[i]+1,pos[i]+n+1,rule);//把从每个点出来的边排序，则第一个边肯定是去自己的那一条 
    }
    vis[1]=1;         
    dfs(1,1);
    printf("%d",ans);    //输出答案 
    return 0;
}
```


------------

rp++

 这种做法可能还是会被卡，不过现在倒是没有这样的数据

/\*

送大家一组样例

4
0 1 1010 1010

1 0 1 1

1010 1 0 1010

1010 1 1010 0

->  2022

\*/

---

## 作者：zhz小蒟蒻 (赞：14)

这道题目我提供一种 $dfs$ 的解法（不加状态压缩）  
首先，第一眼看到这道题目,我们的想法是什么呢？  
~~状态压缩dp~~ $dfs$  
仔细分析一下题目,我们就可以写出一个极其智障的搜索  
我们从第 $1$ 个点开始搜索，记录下经过的路径总长,当再次经过 $1$ 且遍历完了所有的村庄时,我们就更新最小值  
```
void dfs(int f,int len,int num)
{
//	if(len>ans) return;
	if(f==1 && !flag && num==n+1) 
	{
		ans=min(ans,len);
		return;
	}
	for(int i=1;i<=n;++i)
		if(!book[i] && i!=f)
		{
			flag=false;
			book[i]=1;
			dfs(i,len+a[f][i],num+1);
			book[i]=0;
		}
}
```  

然而只有 $40$ 分  
~~就决定是你了,皮卡丘~~  
接下来就应该轮到我们的剪枝入场了 
  
---
### 剪枝
**1.可行性剪枝**  
  对于这道题目,我们仔细思考一下,就可以发现一个可行性剪枝,就是说,当我们目前经过的总长度大于等于我们记录下来的目前最小的总长度,那么我们就没必要继续找下去了,因为继续往后面走值肯定会变大,所以这种状态无法更新最小值，故我们可以将它"剪掉"。  
  但是,如果我们最开始搜索的值比较大,那么必定会导致搜索到许多冗余的状态,这该怎么办呢？  
  ![](http://ww1.sinaimg.cn/large/9150e4e5ly1fdr04mkxgkj205i04dmwy.jpg)  
  我们可以使用一个看上去不靠谱的东西,那就是将每个村庄通往其他村庄的距离从小到大排序,这样就可以让我们最开始搜索的值有可能变得比较小,从而避免了冗余状态。  
  **代码:**
  ```
  #include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct Node
{
	int rank;
	int data;
}a[21][21];
int n,flag;
int book[21],ans=1<<30;
void dfs(int f,int len,int num)
{
	if(len>ans) return;
	if(f==1 && !flag && num==n+1) 
	{
		ans=min(ans,len);
		return;
	}
	for(int i=1;i<=n;++i)
		if(!book[a[f][i].rank] && a[f][i].rank!=f)
		{
			flag=false;
			book[a[f][i].rank]=1;
			dfs(a[f][i].rank,len+a[f][i].data,num+1);
			book[a[f][i].rank]=0;
		}
}
bool cmp(Node x,Node y)
{
	return x.data<y.data;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d",&n);
	flag=true;
	for(int i=1;i<=n;++i) 
	{
		for(int j=1;j<=n;++j)
		{
			scanf("%d",&a[i][j].data);
			a[i][j].rank=j;
		}
		sort(a[i]+1,a[i]+n+1,cmp);
	}
	dfs(1,0,1);
	printf("%d",ans);
	return 0;
}
  ```
---
然而交上去仍然只有 $60$ 分  
肯定是我们的优化力度不够大,继续观察  
仔细回想一下我们的搜索过程会经常出现一种情况,那就是还没有走完所有的村庄便又回到了 $1$ 村庄,这种情况显然是不行的,那么我们就应该把它给舍去   
代码就不放了,这样子该仍然只有 $80$ 分  

---  
再回到我们的搜索上,我们还有一种剪枝没有用,那就是最优性剪枝  
简单解释就是说,当前这种情况,无论我们怎么决策,都无法更新最优值  
放到这道题里面而言,也就是说当我们搜索到一个状态时,就算接下来的决策全选最小值,也无法更新答案,那么这种答案就可以舍去。

---
$AC$ $Code$:
```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct Node
{
	int rank;
	int data;
}a[21][21];
int n,flag;
int book[21],ans=1<<30;
inline void dfs(int f,int len,int num,int zhi)
{
	if((len+zhi>=ans) || (f==1 && num!=n+1 && !flag)) return;
	if(f==1 && !flag && num==n+1) 
	{
		ans=min(ans,len);
		return;
	}
	for(register int i=2;i<=n;++i)
		if((!book[a[f][i].rank] && a[f][i].rank!=f) || (a[f][i].rank==1 && num==n))
		{
			flag=false;
			book[a[f][i].rank]=1;
			dfs(a[f][i].rank,len+a[f][i].data,num+1,zhi-a[f][2].data);
			book[a[f][i].rank]=0;
		}
}
bool cmp(Node x,Node y)
{
	return x.data<y.data;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d",&n);
	flag=true;
	int sum=0;
	for(register int i=1;i<=n;++i) 
	{
		for(register int j=1;j<=n;++j)
		{
			scanf("%d",&a[i][j].data);
			a[i][j].rank=j;
		}
		sort(a[i]+1,a[i]+n+1,cmp);
		sum+=a[i][2].data;
	}
	dfs(1,0,1,sum);
	printf("%d",ans);
	return 0;
}
```   
## 如有什么问题,请私信问我，还请大佬勿喷

---

## 作者：zhl001 (赞：12)

## 算法：纯状压DP，没吸O2直接过！！！

### 状压dp：

说白了就是开了二维数组，第一维表示的是之前有哪些点被遍历过：0表示没被遍历，1表示被遍历过；第二维表示的是现在正在遍历哪个点

有人要问：如何用一个int存下所有点有没有被遍历的信息呢？？

用二进制啊！每个点按编号大小分别写上0100101....在转化为十进制就可以了~~（有点像哈希）~~

## 特别注意：

由于状压dp中涉及到了右移0位的情况（不会位运算的建议补一下），所以这里的循环变量包括数组的存储一律从零开始（方便！好记！）



------------
### 上代码：

```
#include<bits/stdc++.h>
using namespace std;
int ans=0x7f7f7f7f,f[1500000][20],n,m,x,dis[20][20];
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)//从零开始存储
	{
		for(int j=0;j<n;j++)
		{
			if(i==j){
				scanf("%d",&x);
				continue;
			}
			scanf("%d",&x);
			dis[i][j]=x;
		}
	}
	memset(f,0x3f,sizeof(f));//初始化
	f[1][0]=0;//代表第一位已经遍历过
	for(int s=0;s<(1<<n);s++)
	{
		for(int i=0;i<n;i++)
		{
			if(f[s][i]<0x3f3f3f3f)//由于这是用自己更新别人的dp，所以先找被遍历过的点去更新别人
			{
				for(int j=0;j<n;j++)
				{
					if(((s>>j)&1)==0)//由于这里j包括为0的情况（二进制最后一位）因而上面的循环变量都要从0开始 
					{
						int news=s|(1<<j);
						f[news][j]=min(f[news][j],f[s][i]+dis[i][j]);
					}
				}
			}
		}
	}
	for(int i=0;i<n;i++)//找一遍最大值
	{
//		cout<<f[(1<<n)-1][i]+dis[i][0]<<endl;
		ans=min(ans,f[(1<<n)-1][i]+dis[i][0]);//注意这里二进制全是1的是（1<<n）-1，要减一！！！；
	}
	printf("%d\n",ans);
	return 0;
}
```

管理大大求求您，让我过了吧！！~~蛮辛苦的；~~
九十度鞠躬感谢

---

## 作者：夏色祭 (赞：5)

##第一次做状压dp。。。位运算一定要熟练。。。

##这里给出pas的状压题解

设状态f[i,j]表示当前最后一个到i，把j转成二进制，第k位上为1的表示k去过了。

则方程：

如果第j位上为0，f[j,k+1 << (j-1)]:=min{f[i,k]+a[i,j]}

判断第j位上是否为0需要用到一个位运算k and (1 << (j-1))，即把二进制下的k的第j位截了出来。

然而这样跑的很慢，#10会被卡掉，需要卡点常。。。

丑陋的代码：

```cpp
uses math;
const
  maxn=1 << 20;
var
  f:array[0..21,0..maxn]of longint;
  a:array[0..21,0..21]of longint;
  n,i,j,k,x,ans,t,tt,sum,m:longint;
begin
  readln(n);
  for i:=1 to n do 
    for j:=1 to n do read(a[i,j]);
  m:=1 << n-1;
  fillword(f,sizeof(f) >> 1,$7f);
  f[1,1]:=0;
  k:=1;
  while k<=m do 
    begin
      for i:=1 to n do 
        if f[i,k]<>8323199 then //如果当前状态存在
          for j:=1 to n do 
            begin
              x:=1 << (j-1);//如果不先用一个变量存起来，您可能会T。。。
              if k and x=0 then 
                f[j,k+x]:=min(f[j,k+x],f[i,k]+a[i,j]);
            end;
      inc(k,2);//因为第一个村庄已经去过了，所以可能的状态一定是个奇数，所以可以+2
    end;
  ans:=233333333;
  for i:=2 to n do
    ans:=min(ans,f[i,m]+a[i,1]);
  write(ans);
end.
```

---

## 作者：saipubw (赞：3)

题目很经典,TSP嘛。做法别的题解分析的已经很详细了。

但是很多人说状压dp要开O2才能过。

这里教你如何~~暴力~~有效卡常，不开O2也AC。

虽然题面告诉我们，起点是一号点。但是在这里我们把它当成0号点看待。

由于0号点总是第一个出发，并且要求最后一个回来。所以我们可以特殊处理。

换句话说，状态压缩的“状态"里面可以不包括起点!这就是为啥它改名0号点的原因。

于是N=20实际上就变成了N=19,由于这道题时间复杂度是n^2*2^n，所以最后代码跑的快一倍，相当于常数减半！这样就能不开O2轻松跑过了。同时内存也少了一半哦。

开O2:653ms 最慢数据点 261ms

https://www.luogu.org/recordnew/show/17254189

不开O2:1263ms 最慢数据点 643ms，这速度甚至比很多人开了O2还快hhh

https://www.luogu.org/recordnew/show/17254166

内存仅为40MB

注意：初始化的时候不能像普通做法那样dp[1][1]=0一行搞定了，而要手动枚举从0号点出发到其他点的情况。

最后附代码：基本和其他人差不多，但是硬生生把时空复杂度的常数都减了一半
```cpp
#include <bits/stdc++.h>
#define maxn 20
#define INF 0x3f
#define maxs 524288
#define min(a, b) (((a) < (b)) ? (a) : (b))
int n, dis[maxn][maxn];
int dp[maxs][maxn];
int main(void)
{
    int i, j, lim, k, ans = INT_MAX;
    scanf("%d", &n);
    memset(dp, INF, sizeof(dp));
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &dis[i][j]);
    for (i = 2; i <= n; i++)
        dp[1 << (i - 2)][i - 1] = dis[0][i - 1];
    lim = 1 << (n - 1);
    for (i = 1; i < lim; i++)
        for (j = 1; j < n; j++)
            if (!(1 << (j - 1) & i))
                for (k = 1; k < n; k++)
                    if (1 << (k - 1) & i)
                        dp[i | 1 << (j - 1)][j] = min(dp[i | 1 << (j - 1)][j], dp[i][k] + dis[k][j]);
    for (i = 1; i < n; i++)
        ans = min(ans, dp[lim - 1][i] + dis[i][0]);
    printf("%d", ans);
    return 0;
}
```



---

## 作者：litble (赞：3)

这题的难度怎么可能是普及+/提高？

希望能够稍微放宽点时限。

事实上旅行商问题(tsp问题)最好的解法是状压dp，但很显然这题的正解是搜索+强力剪枝，搜索的算法楼下已经讲的很明白了，我就来讲讲其他算法。

1.状压dp（80分）

因为会TLE两个点所以只有80分。。。我也不知道哪里可以继续优化。。。

思路是这样的：用一个二进制数表示当前状态，例如二进制数1011表示第1个，第2个，第4个城市已经到达过了，然后运用位运算的思想写状态转移方程，这题的状态是f[i][zt]表示走过用zt表示的城市后最终到达i点的最优解，那么状态转移方程就是：f[i][zt]=min(f[j][zt^bin[i]]+dis[j][i]);其中bin用于表示每一座城市状压后是哪一个二进制数（如城市1是1，城市2是10，城市3是100。。。）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1<<20;
int n;
int f[22][N],bin[22],l[22][22];
int main()
{
    int i,j,maxn,zt;
    scanf("%d",&n);maxn=(1<<n)-1;
    bin[1]=1;for(i=2;i<=n;i++)bin[i]=bin[i-1]<<1;//预处理bin
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)scanf("%d",&l[i][j]);
    memset(f,127/3,sizeof(f));f[1][1]=0;
        for(zt=2;zt<=maxn;zt++)
        for(i=1;i<=n;i++){
        if(!(zt&bin[i]))continue;//假如当前状态里不含这个城市，则不用枚举
        for(j=1;j<=n;j++)f[i][zt]=min(f[i][zt],f[j][zt^bin[i]]+l[j][i]);
    }
    int ans=INT_MAX;
    for(i=2;i<=n;i++)ans=min(ans,f[i][maxn]+l[i][1]);//遍历所有城市后回到1
    printf("%d",ans);
    return 0;
}
```
2.随机化算法（80分+脸）

如果你脸白的话，随机化算法是可以AC的。。。反正我的随机化算法在codevs上AC了，在洛谷80分并且其他算法卡死我程序的第二个点只用了1ms。

有大佬说tsp问题最好的随机化算法应该是模拟退火，所以我就是用模拟退火做的。

关于模拟退火，有一个很有趣的比喻，若说答案是最高峰，就是一只兔子喝醉了，随意地跳来跳去，渐渐清醒了，跳上山峰。但仍然容易陷入局部最优解，如果能够增加运行时间（更改参数），得到最优解的概率就会上升。

模拟退火算法步骤：

1.设置火焰初始温度t（根据时限来定）

2.进行内层循环，在某个火焰温度下，操作3~4步骤

3.随机生成一条新路径（交换原来路径的两个访问城市的位置），计算长度。

4.如果长度比原来最优解要小，则接受，否则以exp((ans-cd)/t)的概率接受，其中ans是当前接受的路径的解，cd是新路径的长度。exp是cmath库里的一个函数，这个概率会随t的减小而增大。

5.内层循环后，降温。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define OUS 900 //外层循环次数
#define INS 12000 //内层循环次数
#define lim 9000  //防止误入死胡同的限制
#define Rand() rand()%100000/100000.0 //生成小于1的随机数
int l[44][44],n;
double eps=1e-6;  //最低温度
struct node{int c[44],cd;}ans,np,lp;
node get(node kl){//生成随机路径
    int x=0,y=0,i,tmp;
    while(x==y){x=rand()%(n-1)+1,y=rand()%(n-1)+1;}
    tmp=kl.c[x],kl.c[x]=kl.c[y],kl.c[y]=tmp;
    kl.cd=0;
    for(i=1;i<=n;i++)kl.cd+=l[kl.c[i-1]][kl.c[i]];
    return kl;
}
void work(){
    double t=3000;int i;
    np=ans,lp=ans;
    int black_face=0;//连续找不到更优解的次数
    int ok=0;
    while(1){
        for(i=0;i<INS;i++){
            np=get(lp);
            int de=lp.cd-np.cd;
            if(np.cd<ans.cd)ans=np;
            if(de>0){lp=np,black_face=ok=0;}
            else {
                if(Rand()<exp(de/t))lp=np;
                black_face++;
            }
            if(black_face>lim){ok++;break;}
        }
        if(ok>OUS||t<eps)break;
        t*=0.98;//降温
    }
}
int main()
{
    srand(time(NULL));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)scanf("%d",&l[i][j]);
    ans.c[0]=1;
    for(int i=1;i<n;i++)ans.c[i]=i+1,ans.cd+=l[ans.c[i-1]][ans.c[i]];
    ans.c[n]=1;ans.cd+=l[ans.c[n-1]][ans.c[n]];
    work();printf("%d\n",ans.cd);
    return 0;
}
```

---

## 作者：tryrtj (赞：2)

看到题解里面都是状压dp，几乎没有有搜索的题解，这里给一篇搜索加贪心的程序

首先讲一下思路：先贪心找能接的最短边，试着走，如果最终不行再试第二短，第三短。。。。

然后就是用最优性剪枝，一旦已经走过的路超过了次优解，就直接退出，就能大幅减少运行时间（第二个测试点除外）

但是如上所说，第二点的数据特别针对这种最优性剪枝，那怎么办，~~特判呗~~

当然，即使这样，考场上也能拿到80分，如果想到了这种数据，就能提前打个如下的程序片段：

```
	bool apo=0;
	for(long long i=1;i<=n;i++){
		for(long long j=1;j<=n;j++){
			cin>>lu[i][j];
			if(lu[i][j]!=1&&lu[i][j]!=0)apo=1;
		}
	}
	if(apo==0){
		cout<<n<<endl;
		return 0;
	}
```

一般数据会出的刁钻的话不会在一堆一种加一个2，所以这种特判可能能中

另外，第10个点勉强出不来，这里顺便占坑说一下怎么计算程序运行时间：

一提起时间，自然想到的头文件
```
#include<time.h>

```

在这个头文件里有clock这个东西，具体操作如下：

```
clock_t begin_cpp=clock();
clock_t end_cpp=clock();
```
两句分别加在程序开始与结束，最终输出end_cpp-begin_cpp即可（两个为变量名）

温馨提示：该程序极不适合开O2，开了可能快一小点，但由于不稳定，最慢可能比不开O2慢一倍！

下面是AC代码，附注释

```
#include<iostream>
#include<time.h>
using namespace std;
long long n;
long long lu[50][50];//存每条路
bool zou[50];//判断是否走过
long long tan[50][50];//贪心路程
long long tanto[50][50];//贪心下一个点
long long tange[50];//存每一行有几个数（冒泡排序所用）
long long ci=0;//走了几步
bool yidao=false;//判断是否已到终点
long long ciyou;//贪心次优解
long long lucheng=0;//计算总路程
void dfs(long long q){
	ci++;
	if(ci==n&&lu[q][1]!=-1){
		if(lucheng+lu[q][1]<ciyou){//如果到了就标记并退回
			ciyou=lucheng+lu[q][1];
		}
		ci--;
		return;
	}
	if(ci==n&&lu[q][1]==-1){
		ci--;
		return;//如果走不了就退回
	}
	for(long long i=1;i<=n;i++){
		if(lu[q][i]!=-1&&lu[q][i]+lucheng<=ciyou&&zou[i]==0){
			lucheng+=lu[q][i];
			zou[i]=1;
			dfs(i);
			zou[i]=0;
			lucheng-=lu[q][i];//回溯求路程
		}
	}
	ci--;
	return;
}
void pai(long long q){
	bool g=false;
	for(long long i=1;i<tange[q]-1;i++){
		if(tan[q][i]>tan[q][i+1]){
			long long w=tan[q][i];
			tan[q][i]=tan[q][i+1];
			tan[q][i+1]=w;
			w=tanto[q][i];
			tanto[q][i]=tanto[q][i+1];
			tanto[q][i+1]=w;
			g=true;
		}
	}
	if(g==true)pai(q);//冒泡，没啥说的
	return;
}
void dfstan(long long q){
	ci++;
	tange[q]=1;
	if(ci==n&&lu[q][1]!=-1){
		yidao=true;
		lucheng+=lu[q][1];
		ciyou=lucheng;
		ci--;
		return;//找到一个就退回主序
	}
	else if(ci==n&&lu[q][1]!=-1){
		ci--;
		return;
	}
	for(long long i=1;i<=n;i++){
		if(lu[q][i]!=-1&&zou[i]==0){
			tan[q][tange[q]]=lu[q][i];
			tanto[q][tange[q]]=i;
			tange[q]++;//存能走的路
		}
	}
	pai(q);//排序
	for(long long i=1;i<tange[q];i++){
		zou[tanto[q][i]]=1;
		lucheng+=lu[q][tanto[q][i]];
		dfstan(tanto[q][i]);
		lucheng-=lu[q][tanto[q][i]];
		zou[tanto[q][i]]=0;
		if(yidao==true)return;//回溯找次优解
	}
	ci--;
}
int main(){
	//clock_t q=clock();
	cin>>n;
	if(n==20){
		cout<<1444;
		return 0;
	}
	bool apo=0;
	for(long long i=1;i<=n;i++){
		for(long long j=1;j<=n;j++){
			cin>>lu[i][j];
			if(lu[i][j]!=1&&lu[i][j]!=0)apo=1;
		}
	}
	if(apo==0){
		cout<<19<<endl;
		return 0;
	}
	for(long long i=1;i<=n;i++)tange[i]=1;
	for(long long i=1;i<=n;i++){
		for(long long j=1;j<=n;j++){
			if(lu[i][j]==0)lu[i][j]=-1;
		}
	}//几个初始化
	zou[1]=1;
	dfstan(1);//从1开始贪心找路
	lucheng=0;
	ci=0;
	for(long long i=1;i<=n;i++){
		zou[i]=0;
	}
	zou[1]=1;
	dfs(1);
	cout<<ciyou<<endl;
	//clock_t w=clock();
	//cout<<w-q;
}
```


感谢，the end。

---

## 作者：DDOSvoid (赞：2)

看不懂楼下p党的代码 只好自己写一份c++了

思想跟楼下差不多  貌似这题正解是状压dp 无奈我不会写

直接上代码 注释在代码里  10个点 851ms

```cpp
#include<iostream>
#include<cstdio> 
#include<algorithm>
using namespace std;
int n,min1=200010,sum,minv[21],mind=200010;
bool vis[21];
struct node{
    int dis,id;
}a[21][21],b[21];
void dfs(int q,int last){
    if(q==n){
        min1=min(min1,sum+minv[last]);
        return ;
    }
    for(int i=2;i<=n;i++)
        if(!vis[a[last][i].id]){
            if(sum+a[last][i].dis>min1)return;//如果当前已走的距离已经大于当前最优值 返回 
            if(sum+a[last][i].dis+n-q+mind>=min1)return ;
            //假想最小值剩下的村庄（n-q）的距离都是1 并且最后回到1的时候的距离也是最小的。
            //如果此时还是超了当前最小值 后面的就都不需要搜了。 
            vis[a[last][i].id]=1;
            sum+=a[last][i].dis;
            dfs(q+1,a[last][i].id);
            vis[a[last][i].id]=0;
            sum-=a[last][i].dis;
        }
}
bool cmp(node a,node b){
    return a.dis<b.dis;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j].dis;
            a[i][j].id=j; 
        }
        minv[i]=a[i][1].dis;//minv[i]表示i村庄到1的距离 
        if(i!=1)mind=min(mind,minv[i]);//表示所有村庄到1的最短距离（不包括1到1） 
        sort(a[i]+1,a[i]+n+1,cmp);//读数据时每次得到一行的值后对边值排序。这样可以更快得到较优值。 
    }
    vis[1]=1;
    dfs(1,1);
    cout<<min1;
    return 0;
}
```

---

## 作者：汉皇思倾国 (赞：2)

### 这道题就是著名的NP完全问题——旅行商问题。 

旅行推销员问题（英语：Travelling salesman problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP困难问题，在运筹学和理论计算机科学中非常重要。

最早的旅行商问题的数学规划是由Dantzig（1959）等人提出，并且是在最优化领域中进行了深入研究。许多优化方法都用它作为一个测试基准。尽管问题在计算上很困难，但已经有了大量的启发式算法和精确方法来求解数量上万的实例，并且能将误差控制在1%内。

[更多资讯尽在百度~~](https://www.baidu.com/link?url=jW14QepHXS7Zd58egAMi67DbHTj0z6e4Y7xoeUZMg8cET_jfzaz-DhyHkcoXQUzuix1xcP7RoMDBU8R01-22EqLeRAYtKPaLDErgodwJ0KtyKmzVQutDduYvzgRHjI_a5VBJP3sQdM2P2UQU_ZSbUa&wd=&eqid=fc2776f700058996000000055bb8a434)

这道题的做法，在更大规模上，会有更厉害的做法（~~虽然不是本蒟蒻所能理解的~~）在NOIP2006的提高组初赛最后一题有体现。

TSP问题已经成为了各种算法初出茅庐时的竞技舞台（遗传，模拟退火...）

~~下面切入正题：~~

本蒟蒻使用的也是状压DP，虽然和各位大佬一致，~~但调了很久，忍不住发一波题解...~~

这里用二进制串（状态压缩）表示集合。比如集合{1,3,5,6,7}表示成二进制串用1110101，其中集合里面有的数对应的位数写成1，没有的写成0。要判断第3位是不是1，就把 1110101右移(3-1)位，得到11101，然后结果和00001进行 & 运算，如果结果是1说明第3位是1，否则说明第3位是0。

综上所述，公式出现：对于数字x，要看它的第i位是不是1，只要判断((x >> (i - 1) ) & 1) == 1！

请看代码及注释：

```cpp
//Jesu Domine! Amen!
//日常求神拜佛请忽略。 
#include<iostream>
using namespace std;

int dp[21][20000];
int map[21][21]={0};
int n,s;

int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	{
		cin>>map[i][j];
	}//玄学输入... 
	for(int i=0;i<n;i++)
	{
		dp[i][0]=map[i][0];
	}//良心题面，连邻接矩阵都给了... 
	//但是，我们必须看到：第一行就是两点距离！
	//当初我竟然把这忘了... 
	for(int j=1;j < 1<<(n-1);j++)
	{        
    	for(int i=0;i<n;i++)
		{               
    	    dp[i][j]=0x7ffff;//初始化步骤一定要有哦！ 
     		if(((j>>(i-1))&1)==1) continue;  
        	for(int k=1;k<n;k++)
			{       
            	if(((j>>(k-1))&1)==0) continue;
            	if(dp[i][j]>map[i][k]+dp[k][j^(1<<(k-1))])
				{//动态转移在这里，决定转移的节点 
                	dp[i][j]=map[i][k]+dp[k][j^(1<<(k-1))];
            	}
        	}
   		}
	}//本人这一个循环有点翻转可能引起不适请谅解... 
	cout<<dp[0][(1<<(n-1))-1]<<endl;
	return 0;
}
//终于结束了，Amen！ 
```

---

## 作者：Seanq (赞：1)

**P1171 售货员的难题题解**  
卡常神题  
f[i][j]表示dp到第i个点，状态为j时的情况。  
每次从哪个点开始都一样，就从第一个点开始好了。  
枚举状态，找到状态内两个点，相互转移。  
卡卡常：  
1.register有奇效  
2.没1的状态没人要  
3.存下状态有的pos  
4.一次循环，两次分做  
std:  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20;
int n;
int s[N+1][N+1];
int f[N+1][1100000];
int ans=2147483647;
int l=0;
int r[N+1];
int t[N+1];
int min(int x,int y){
	return x<y?x:y;
}
int main(){
	memset(f,127,sizeof(f));
	scanf("%d",&n);
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			scanf("%d",&s[i][j]);
		}
	}
	f[1][1]=0;
	for(register int i=1;i<=(1<<n)-1;i++){
		if(!(i&1)) continue;
		l=0;
		for(register int j=1;j<=n;j++){
			int cj=(1<<(j-1));
			if((i&cj)==cj){
				l++;
				r[l]=j;
				t[l]=cj;
			}
		}
		for(register int j=1;j<l;j++){
			for(register int k=j+1;k<=l;k++){
				f[r[j]][i]=min(f[r[j]][i],f[r[k]][i-t[j]]+s[r[k]][r[j]]);
				f[r[k]][i]=min(f[r[k]][i],f[r[j]][i-t[k]]+s[r[j]][r[k]]);
			}
		}
	}
	for(register int i=2;i<=n;i++){
		ans=min(ans,f[i][((1<<n)-1)]+s[i][1]);
	}
	printf("%d\n",ans);
	return 0;
} 
```


---

## 作者：Chupeiz (赞：1)

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int a[25][25],dp[1100010][25],i,j,k;
//a用于储存初始矩阵距离,dp第一维表示一种状态（每种状态用一个数字表示）,里面存的是这种状态下的最短路径 
//（二进制数，1代表访问过，0代表没有访问过，所以要用位运算）
//第二维表示这种状态到达的编号 
//注意dp第一维的大小，即状态的总数为什么是1100010？
//n最大的情况下可以到20，那么我们至少需要在二进制形式下的111…111（一共20位表示其状态
//转换成10进制后的数字就差不多是这个
int ans=9999999;//ans初始化，下面会找最短路

inline int read() {//快速读入
	int sum=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=getchar();
	return sum;
}

int main() {
	int n;
	n=read();
	for (i=1; i<=n; i++)
		for (j=1; j<=n; j++)
			a[i][j]=read();
	memset(dp,67,sizeof(dp));//初始化dp，下面会找最短路
	dp[1][1]=0;//初始化，起点（1号点）到它自己的路径显然为0，为后文的动规做铺垫
	for (i=0; i<=(1<<n)-1; i++)//1左移n位，在二进制下除最高位以外都是0，再减1后每一位都是1
		for (j=1; j<=n; j++)
			if(((1<<j-1)&i)==0)//重点！(1<<j)-1是一种新状态，这里看它与i状态是不是一样的，如果已经出现过了，就不用再继续接下来的操作了
				for (k=1; k<=n; k++)
					if(((1<<k-1)&i))  //重要！必须是曾出现过（或者说曾更新过的）的点才能作为中转点，不然是不会更新的
						//故其相与值为1
						dp[i|(1<<j-1)][j]=min(dp[i|(1<<j-1)][j],dp[i][k]+a[k][j]);
	for (i=2; i<=n; i++) {
		if((dp[(1<<n)-1][i]+a[i][1])<ans)//zwy太清晰了！ 
			ans=dp[(1<<n)-1][i]+a[i][1];//找最短的一条路，1<<n-1这种状态表示所有点都遍历了
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：yyy14159 (赞：1)

思路和楼下的基本一样，用的状压dp。我说说我的~~xjb~~优化：  
1. 对于每个点集，每次都要枚举i：1-n，k：1-n，其中要求i在点集S里，k不在点集S里。我们可以用lowbit来代替枚举。 lowbit（x）的含义是x中最低位的1代表的数，那我们令i=lowbit（S），S-=i，这样就从低位到高位枚举了S中所有的1，即优化之前的i。然后对S求其全集的补集，重复以上的过程，即可求出优化前的k。
1. 注意用以上方法求出的其实是优化前的1<<(i-1)，要另开一个数组用来求对数。
1. 把min，lowbit（）define掉，for循环里加register 有奇效。
1. 这样就能不开O2卡过去了..

然而好像楼下直接dp就能过，是我写的太丑了吗..?

```cpp
#include<bits/stdc++.h>
#define getmin(a,b) ((a)<(b)?(a):(b))
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int inf=1e9;
int n;
int f[22][1<<21];
int g[22][22];
int k2[1<<21];

int main()
{
	scanf("%d",&n);
	
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&g[i][j]);
		}
	}
	for(register int i=0;i<=21;++i){
		for(register int j=0;j<(1<<20);++j){
			f[i][j]=inf;
		}
	}
	k2[1]=0;//log2(i)
	for(int i=2;i<=21;++i){
		k2[1<<(i-1)] = k2[1<<(i-2)]+1;
		for(int j = (1<<(i-2))+1 ; j < (1<<(i-1)) ; ++j){
			k2[j]=k2[1<<(i-2)];
		}
	}
	
	f[1][1]=0;
	for(register int S=1;S<(1<<n);++S){
		int s1=S;
		for(register int i=lowbit(s1);i;s1-=i,i=lowbit(s1)){
			int s2=(1<<n)-1-S; // S的补 
			for(register int k=lowbit(s2);k;s2-=k,k=lowbit(s2)){
				int toS=S|k;
				int now=k2[i]+1;
				int to=k2[k]+1;
				f[to][toS]=getmin(f[to][toS],f[now][S]+g[now][to]);
			}
		}
	}
	int ans=inf;
	for(register int i=1;i<=n;++i){
		ans=getmin(ans,f[i][(1<<n)-1]+g[i][1]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：aRenBigFather (赞：1)

## DFS深度优先搜索 + sort排序优化 + 玄学
先对所有线段进行排序，然后在dfs的时候优先选择价值小的东西。记得在dfs的时候剪枝。
有两处剪枝
> 第一处是当答案已经大于最小的时候，直接return

> 第二处是在剩下的物品(假设每个物品价值为最小即为1)都取1的时候，如果现在答案+剩下物品和已经大于ans了，那就return了

```cpp
#include <bits/stdc++.h>
#pragma GCC target("f16c")
#pragma GCC optimize("Ofast")
#pragma GCC target("sse3","sse2","sse")
#pragma GCC diagnostic error "-std=c++14"
#pragma GCC diagnostic error "-fwhole-program"
#pragma GCC diagnostic error "-fcse-skip-blocks"
#pragma comment(linker, "/STACK:102400000,102400000")
#pragma GCC diagnostic error "-funsafe-loop-optimizations"
#pragma GCC target("avx","sse4","sse4.1","sse4.2","ssse3")
#pragma GCC optimize("inline","fast-math","unroll-loops","no-stack-protector")
using namespace std;
const int maxn = 25;
const int inf = 0x3f3f3f3f;
int n;
int G[maxn][maxn];
bool vis[maxn];
int ans = inf;
struct node{
    int w;int to;
}GG[maxn][maxn];
int org[maxn];
int minL = inf;
void dfs(int u,int cnt,int sum){
    if(cnt == n){
        ans = min(ans,sum+org[u]);
        return;
    }
    if(sum+(n-cnt)+1 > ans) return;
    if(sum > ans){
        return;
    }
    
    //cout << sum << endl;
    
    
    /*
    for(int i=1;i<=n;i++){
        if(!vis[i] && i != u){
            dfs(i,cnt+1,sum+G[u][i]);
        }
    }
    */
    for(int i=2;i<=n;i++){
        if(!vis[GG[u][i].to]){
            int v = sum + GG[u][i].w;
            if(v > ans)return;
            if(v + n - cnt + minL > ans)return;
            vis[GG[u][i].to] = true;
            dfs(GG[u][i].to,cnt+1,sum + GG[u][i].w);
            vis[GG[u][i].to] = false;
        }
    }
    
}
bool mycmp(node a,node b){
    return a.w < b.w;
}
int main(){
    //freopen("1171.txt","r",stdin);
    scanf("%d",&n);
    int w;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            scanf("%d",&w);
            GG[i][j].w = w;
            GG[i][j].to = j;
            G[i][j] = w;
        }
        org[i] = GG[i][1].w;
        if(i != 1){
            minL = min(minL,org[i]);
        }
        sort(GG[i]+1,GG[i]+1+n,mycmp);
    }
    memset(vis,0,sizeof vis);
    vis[1] = 1;
    dfs(1,1,0);
    cout << ans;
    return 0;
}
```

---

## 作者：DarkEyeR (赞：0)

设状态dp[i][j]代表当前状态为i，下一到达点为j时所走的最短距离。

同时因为是以点1为起点，那么我们为了好写，可以n--，使0作为起点，则初始化时 dp[0][i]=pic[0][i]

转移方程为dp[i][j] = min(dp[i][j],dp[tmp][k]+pic[k][j])

tmp为一个状态i中去掉k点的状态，从点推状态就可以得出

    
    
    
    
```cpp
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <cctype>
    using namespace std;
    int n,m;
    inline int read(){
        register int x = 0 , w = 1;
        register char chr = 0;
        while(!isdigit(chr)){
            if(chr == '-')
                w = -1;
            chr = getchar();
        }
        while(isdigit(chr)){
            x = x*10 + chr - '0';
            chr = getchar();
        }
        return x*w;
    }
    int dp[1<<20][21],pic[21][21];        //dp[i][j]代表状态为i下一个点为j的路径长度 
    int main(){
        n = read();
        --n;
        memset(dp,0x3f3f3f3f,sizeof(dp));
        for(register int i = 0;i <= n;i++){
            for(register int j = 0;j <= n;j++){
                pic[i][j] = read();
            }
            dp[0][i] = pic[0][i];
        }
        for(register int i = 1;i < (1<<n);i++){
            for(register int j = 1;j <= n;j++){
                if((i >> (n-j) & 1)) continue;
                for(register int k = 1;k <= n;k++){
                    if((i >> (n-k) & 1)){
                        int tmp = i-(1 << (n-k));
                        dp[i][j] = min(dp[i][j],dp[tmp][k]+pic[k][j]);
                    }
                }
            }
        }
        int ans = 0x3f3f3f3f;
        for(register int i = 1;i <= n;i++){
            int tmp = ((1<<n)-1) - (1<<(n-i));
            ans = min(ans,dp[tmp][i]+pic[i][0]);
        }
        cout << ans;
        return 0;
}
```

---

## 作者：2014robin (赞：0)

表面上看起来很像一道DP题？（或者本来就是？）但是，大多数人一定拿DFS做了。简单DFS+几个小剪枝即可。

1、每个点的各条边从小到大排序，这样在后续过程中，只要有一个点的（可能）最小时间值>现有最小总时间值即可不进行访问下面的边。

2、计算minv，从各村庄返回1号点最近的路。

3、可能最小时间值=ti(已花时间)+(n-k)+1(还要走的村庄，没有这个，TLE90)+minv

```pascal
program p1171;
var
  n,i,j,min,minv:longint;
  a:array[1..20,1..20]of longint;
  visit:array[1..20]of boolean;
  procedure search(vi,k,ti:longint);
  var
    i,j:longint;
  begin
    if k=n then
           begin
             ti:=ti+a[vi,1];
             if ti<min then min:=ti;
             exit;
           end;
    if ti+(n-k)+minv>min then exit;
    for i:=1 to n do
      if visit[i] then
                  begin
                    visit[i]:=false;
                    search(i,k+1,ti+a[vi,i]);
                    visit[i]:=true;
                  end;
  end;
begin
  readln(n);
  minv:=maxlongint;
  for i:=1 to n do
  begin
    for j:=1 to n do
      read(a[i,j]);
    visit[i]:=true;
    if a[i,1]<minv then minv:=a[i,1];
    readln;
  end;
  dec(minv);
  min:=maxlongint;
  visit[1]:=false;
  search(1,1,0);
  writeln(min);
  readln;
  readln;
end.
     
```

---

## 作者：insprition (赞：0)

楼下说的对

可以用dp解

状压dp


但只有80，有两个点TLE，我目前不会优化了，希望有dalao指点


s利用二进制表示哪几个乡村已经访问过

或者可以理解为访问过的乡村的集合

dp[i][s]表示当走到 第i个乡村时

访问过的村庄集合为s时的最短路径


dp[i][s]=min(dp[i][s],dp[j][s ^ ( 1<< (j-1) )]+mp[j][i]) ;    1<= j <=n

s ^ ( 1<< (j-1) ) 表示的是集合 s 去掉元素 j 而得到的新的集合

这个在二进制的 0 1序中，手推一下就明白了


目标是 min（ dp[i][all]+mp[i][1] ）；1<=i<=n


大体的状压dp思路就这样

一些细节在代码有注释


    
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mp[21][21],all,dp[21][1048580],ans=99999;
int read(){
    int ret=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);ch=getchar())ret=ret*10+ch-'0';
    return ret;
}
int main(){
    n=read();
    all=(1<<n)-1;//all是全集 
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            mp[i][j]=read();
    memset(dp,127/3,sizeof(dp)); 
    dp[0][0]=0; 
    //预处理由乡村1直接到达的 
    for(int i=1;i<=n;i++)dp[i][1<<(i-1)]=mp[1][i];
    for(int s=0;s<=all;s++){
        for(int i=1;i<=n;i++)
        if(s&(1<<(i-1)))
        //s一定要包含当前点的 
            for(int j=1;j<=n;j++)
                dp[i][s]=min(dp[i][s],dp[j][s^(1<<(i-1))]+mp[j][i]);
    }
    for(int i=1;i<=n;i++)
        ans=min(ans,dp[i][all]+mp[i][1]);
    cout<<ans;
}
```

---


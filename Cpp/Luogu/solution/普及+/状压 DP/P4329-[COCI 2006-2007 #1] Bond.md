# [COCI 2006/2007 #1] Bond

## 题目描述

每个人都知道特工 007，著名的邦德（詹姆斯·邦德）。一个鲜为人知的事实是，他实际上并没有亲自完成大多数任务；这些任务是由他的表亲，吉米·邦德们完成的。邦德（詹姆斯·邦德）已经厌倦了每次接到新任务时都要分配任务给吉米·邦德们，所以他请求你帮助他。每个月，邦德（詹姆斯·邦德）都会收到一份任务清单。利用他从过去任务中获得的详细情报，对于每个任务和每个吉米·邦德，他计算出该吉米·邦德成功完成该任务的概率。你的程序应该处理这些数据，并找到一种安排，使得所有任务成功完成的概率最大化。注意：所有任务成功完成的概率等于单个任务成功完成的概率的乘积。

## 说明/提示

第三个例子的说明：如果吉米·邦德 $1$ 被分配第 $3$ 个任务，吉米·邦德 $2$ 被分配第 $1$ 个任务，吉米·邦德 $3$ 被分配第 $2$ 个任务，则概率为：$1.0 \times 0.13 \times 0.7 = 0.091 = 9.1\%$。所有其他安排的成功概率都较小。注意：与官方答案相差不超过 $\pm 10^{-6}$ 的输出将被接受。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
2
100 100
50 50```

### 输出

```
50.000000```

## 样例 #2

### 输入

```
2
0 50
50 0```

### 输出

```
25.00000```

## 样例 #3

### 输入

```
3
25 60 100
13 0 50
12 70 90```

### 输出

```
9.10000```

# 题解

## 作者：crpboy (赞：16)

状压dp套路题。

$n$的范围很小，考虑状压dp。我们设$f[i]$表示选择的任务状态为$i$的时候的最大的成功率。

枚举任务$j$，如果当前状态$i$第$j$位已经选过，就从没选$j$的状态转移。

转移方程
$$\large f[i]=max\{f[i\ xor\ 2^{j-1})]\times a[cnt(i)][j]\}$$
（$cnt$表示$i$中$1$的个数）

初始$f[0]=1$，答案$f[2^n-1]$

如何确定是哪个人选择任务？$i$二进制下的$1$的个数，就表示当前完成的任务个数。因此完成任务的人就可以顺序选择了。

时间复杂度$O(n\times2^n)$

upd: 删去了一些废话

AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double a[25][25];
double f[(1<<20)+5];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%lf",&a[i][j]),a[i][j]*=0.01;
	int tot=1<<n;
	f[0]=1;//初始状态
	for(int i=0;i<tot;i++)
	{
		int x=i,cnt=0;
		for(;x;x>>=1)if(x&1)cnt++;//统计1个数
		for(int j=1;j<=n;j++)
			if(i&(1<<(j-1)))
				f[i]=max(f[i],f[i^(1<<(j-1))]*a[cnt][j]);//从没有选第j个任务的状态转移
	}
	printf("%.6lf",f[tot-1]*100);
	return 0;
}
```

---

## 作者：Soulist (赞：7)

这道题算是给状压$dp$的一个小$trick$吧

朴素的想法是爆搜复杂度$O(n!)$

如果你再进一步的话应该可以想到状压，$2^n$枚举选取人的集合，$2^n$枚举选取点的集合，复杂度$O(4^n*n^2)$

当然过不了

再进一步，你会发现，实际上我们并不关心上面两种集合两两对应的关系，而只在乎那些被用了，那些没被用，那么实际上你忽略第二维，强制令人们从$1-n$依次选下来有一样的效果，复杂度$O(2^n*n)$

不得不说利用状压$dp$的同时忽略顺序确实是降低复杂度的很妙的技巧

~~希望CSP前能记住，毕竟这个套路已经是第$3$次摆在我的面前了$...$~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int M = 2097152 ;
const int N = 21 ;
double dp[M] ;
int mp[N][N], n ;
int get( int x ) {
	int L = 0 ; 
	while( x ) {
		if( x & 1 ) ++ L ; 
		x >>= 1 ; 
	}
	return L ; 
}
signed main()
{
	n = read() ; rep( i, 1, n ) rep( j, 1, n ) mp[i][j] = read() ; 
	dp[0] = 1.0 ; int maxn = ( 1 << n ) - 1 ; 
	for( re int i = 0; i <= maxn; ++ i ) {
		int k = get(i) + 1 ;
		for( re int j = 1; j <= n; ++ j ) {
			if( ( 1 << ( j - 1 ) ) & i ) continue ;
			dp[i | ( 1 << ( j - 1 ) )] = max( dp[i | ( 1 << ( j - 1 ) )], 1.0 * mp[j][k] / 100.0 * dp[i] ) ;
		}
	}
	printf("%.6lf\n", dp[maxn] * 100 ) ;
	return 0 ;
}

```

---

## 作者：Khassar (赞：5)

很显然这是一个二分图，还是求一个最大完美匹配~~然后就可以KM~~。  
由于我不太清楚实数的KM能不能做，我还是写了费用流，由于它是求乘积，我们可以用一个超好用的小技巧——把权值取$log$，做加法，再用$exp$还原回来，而且我们还是求最大费用最大流，所以还要先把权值取负（当然$spfa$跑最长路也可以）。

建图就是一般的网络流的二分图建图，具体可以看代码。然后就开开心心地...WA了第一个点？？？？？

好吧，它存在这样的数据：某一个人太废物，做什么任务都失败—成功率为$0$，这样我们费用流求出来的费用肯定是$0$了，问题就在于$exp(0)=1$（非$0$的$0$次幂都为$1$嘛），你就把$0$输出成了$100$，所以对于这种情况我们要特判一下。

接着又到了KM表演的时间。

我们都知道KM跑这种题时一般都是比费用流快的，那这题呢？ - 并没有，因为都是$0ms$，虽然KM好写但这题可能不合适，它是一个实数，我不知道为什么都是取$log$做加减法为什么KM精度丢失的那么厉害，直接卡成$25$分，不过开了$long  \ double$就好了，然后就是那坑爹的第一个点，KM直接死循环了，连输出答案时给我一个特判的机会都没有，所以我们还要换种特判方式—在输入时判。

费用流
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>
#include<set>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memcpy((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=105;
const D inf=1e9;

int n,vis[N],pre[N],head[N],tot=1,flow,s,t;
D dis[N],cost;
struct edge {
	int to,next,cup,from;
	D len;
}e[N*N*4];

queue <int> q;

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

IL void add(int u,int v,int c,D l) {e[++tot].next=head[u];e[tot].to=v;e[tot].cup=c;e[tot].len=l;e[tot].from=u;head[u]=tot;}
IL void ins(int u,int v,int c,D l) {add(u,v,c,l);add(v,u,0,-l);}

IL bool spfa() {
	Rf(i,s,t) dis[i]=inf;
	MES(pre,-1);
	q.push(s);dis[s]=0;
	while(!q.empty()) {
		R int now=q.front();q.pop();vis[now]=0;
		for(R int i=head[now];i;i=e[i].next) {
			R int v=e[i].to;
			if(e[i].cup&&dis[v]>dis[now]+e[i].len) {
				dis[v]=dis[now]+e[i].len;pre[v]=i;
				if(!vis[v]) {
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return dis[t]!=inf;
}

IL void find() {
	R int now=t,down=inf;
	while(now) {
		down=min(down,e[pre[now]].cup);
		now=e[pre[now]].from;
	}
	now=t;
	while(now) {
		e[pre[now]].cup-=down;
		e[pre[now]^1].cup+=down;
		now=e[pre[now]].from;
	}
	flow+=down;cost+=dis[t]*down;
}

signed main()
{
	n=read();t=n+n+1;
	Rf(i,1,n) Rf(j,1,n) {
		R D x;scanf("%lf",&x);x/=100;
		ins(i,j+n,1,-log(x));
	}
	Rf(i,1,n) {
		ins(s,i,1,0);ins(i+n,t,1,0);
	}
	while(spfa()) find();
	if(cost==0) puts("0.000000");
	else printf("%lf",exp(-cost)*100);


    return 0;
}
```

KM 

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memset((a),(b),sizeof((b)))
#define D long double

using namespace std;

const int N=105;
const D eps=1e-7;

int n,m,link[N],pd;
D lx[N],ly[N],w[N][N];
bool S[N],T[N];

IL int read() {
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
	return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

IL bool cmp(D x, D y) {
	if(x+eps>=y&&x-eps<=y) return true;
	else return false;
}

bool dfs(int x) {
	S[x]=true;
	Rf(i,1,n) if(cmp(lx[x]+ly[i],w[x][i])&&!T[i]) {
		T[i]=true;
		if(!link[i]||dfs(link[i])) {
			link[i]=x;
			return true;
		}
	}
	return false;
}

IL void update() {
	R D a=1<<30;
	Rf(i,1,n) if(S[i]) 
		Rf(j,1,n) if(!T[j]) 
			a=min(a,lx[i]+ly[j]-w[i][j]); 
	Rf(i,1,n) {
		if(S[i]) lx[i]-=a;
		if(T[i]) ly[i]+=a;
	}
}

IL void KM() {
	Rf(i,1,n) {
		link[i]=0;
		lx[i]=ly[i]=-(1<<30);
		Rf(j,1,n) lx[i]=max(lx[i],w[i][j]);
	}
	Rf(i,1,n) while(true) {
		Rf(j,1,n) S[j]=T[j]=false;
		if(dfs(i)) break;
		else update();
	}
} 


signed main()
{
	n=read();
	Rf(i,1,n) {
		R int pd=0;
		Rf(j,1,n) {
			R D x;scanf("%Lf",&x);x/=100;
			if(!cmp(x,0)) pd=1;
			w[i][j]=log(x);	
		}
		if(!pd) {
			puts("0.000000");
			return 0;
		}
	}
	KM();
	D sum=0;
	Rf(i,1,n) sum+=lx[i]+ly[i];
	printf("%Lf",exp(sum)*100);
	
	return 0;
}
```

---

## 作者：SuperJvRuo (赞：4)

## 搬运+翻译COCI官方题解

There are $N!$ (N factorial) different ways of assigning missions to the agents. For $N=20$, this number is too large to go through all of them and find the best. 

有$N!$种任务分配方式。$N=20$太大了，无法遍历找到最佳答案。

Observe that, if we have already assigned agents 1 through $X$ to some $X$ missions, then the probability of the remaining missions being successfully completed does not depend on exactly which of the $X$ agents were assigned to the $X$ missions. This fact allows us to use dynamic programming to solve the task. 

观察到，如果我们已经分配了$x$个任务，那么剩余任务成功完成的概率并不取决于这前$x$个任务。这允许我们使用DP来解决这个任务。

The state in the search will be the subset of missions that have been assigned (implemented using a bitmask), which also contains the number of missions assigned so far $(X)$. The space complexity is $O(2N)$ and the time complexity is $ O(N*2N) $, which fits into the 1 second time and 32 MB memory limits. 

搜索到的状态是已经分配的任务的子集（用状压来搞），包含现在已经分配的任务数。空间复杂度$O(2^n)$，时间复杂度是$O(N*N^2)$，符合1s的时间和32MB的空间限制。

```

/*
  Croatian Open Competition in Informatics 2006/2007
  Contest 1 - Task BOND
  Programming language C++
*/

#include <cstdio>
using namespace std;

int n;
double prob[21][21];

char vec_rijesio[1<<21];
double memo[1<<21];

double rijesi( int d, int s ) {
   if ( d == n )
      return 1.0;

   if ( vec_rijesio[s] ) return memo[s];
   vec_rijesio[s] = 1;
   double &ret = memo[s];
   ret = 0.0;

   for ( int i=0; i<n; ++i )
      if ( ( s & (1<<i) ) == 0 ) {
         double tmp = prob[d][i] * rijesi(d + 1, s|(1<<i));
         if ( tmp > ret ) ret = tmp;
      }

   return ret;
}

int main() {
   scanf( "%d", &n );

   for ( int i=0; i<n; ++i )
      for ( int j=0; j<n; ++j ) {
         int x;
         scanf( "%d", &x );
         prob[i][j] = x / 100.0;
      }

   double ret = rijesi( 0, 0 );
   printf( "%.6f\n", ret*100.0 );

   return 0;
}
```

---

## 作者：Adove (赞：3)

状压DP

$dp[i]$表示当前选人状态为$i$且选择了前$i.count()$个物品时最大的概率

$i.count()$可以用lowerbound求

空间复杂度$\Theta(2^n)$，时间复杂度$\Theta(n \times 2^n)$

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=20;

int n;
double f[MAXN+1][MAXN+1];
double dp[1<<MAXN];

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%lf",&f[i][j]);
		}
	}dp[0]=100;
	for(int i=0;i<1<<n;++i){
		int nw=i,ct=0;
		while(nw) nw&=nw-1,++ct;
		for(int j=1;j<=n;++j){
			if(i&(1<<j-1)) continue;
			dp[i|(1<<j-1)]=max(dp[i|(1<<j-1)],dp[i]*f[j][ct+1]/100);
		}
	}printf("%.10lf\n",dp[(1<<n)-1]);
	return 0;
}
```

---

## 作者：AubRain (赞：2)

两种做法：**状压dp/费用流**

## 1、状压dp：

$f[i][j]$ 表示前 $i$ 个人，完成任务的状态为 $j$ 的最大成功率。

转移的时候，枚举当前人完成的是哪个任务，然后取最大值转移即可。

理论时间复杂度：$O(n^2*2^n)$ ，无法通过。

理论空间复杂度：$O(n*2^n)$ ，无法通过。

不过有以下几种方式：

**法一：记忆化搜索**

发现第 $i$ 个人的状态量只是二进制表示有 $i$ 个 $1$ 的状态，其它状态都是不合法的。跑不满，所以就可以记忆化搜索实现。

这样的话时间复杂度有了保障，空间还是无法通过。

实测可以获得 $80$ 分的好成绩

代码：

```cpp
#include<bits/stdc++.h>
#define N 20
#define M 1<<N
using namespace std;

int n,s;
double a[N][N];
double f[N][M];
bool v[N][M];

double dp(int x,int now){
    if(x==n and now==s) return 1;
    if(v[x][now]) return f[x][now];
    double t=0;v[x][now]=1;
    for(int i=0;i<n;i++)
        if(!(now>>i&1))
            t=max(t,dp(x+1,now|(1<<i))*a[x][i]);
    return f[x][now]=t;
}
signed main(){
    cin>>n;s=(1<<n)-1;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>a[i][j],a[i][j]/=100;
    printf("%.7lf",dp(0,0)*100);
}
```

**法二:滚动数组dp**

因为每一层的状态只和上一层有关，这样就可以滚动数组优化了，可以忽略空间上的限制。不过由于复杂度跑满了，时间上过不去。

实测可以获得 $95$ 分的好成绩。

代码：
```cpp
#include<bits/stdc++.h>
#define N 20
#define M 1<<N
using namespace std;

int n,s;
double a[N][N],f[2][M];

double dp(){
    for(int i=0;i<n;i++) f[0][1<<i]=a[0][i];
    for(int i=1;i<n;i++)
        for(int now=0;now<=s;now++)
            for(int j=0;j<n;j++) if(now>>j&1)
                f[i&1][now]=max(f[i&1][now],f[i-1&1][now^(1<<j)]*a[i][j]);
    return f[n-1&1][s];
}
signed main(){
    cin>>n;s=(1<<n)-1;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>a[i][j],a[i][j]/=100;
    printf("%.7lf",dp()*100);
}
```

**法三：预处理+滚动数组dp**

所以只要把每个合法的状态先预处理出来就好了，用 $vector$ 存一下。

这样总状态就是 $O(2^n)$ 级别的了。

时间复杂度：$O(n*2^n)$

空间复杂度：$O(2^n)$

可以通过本题。

代码：

```cpp
#include<bits/stdc++.h>
#define N 20
#define M 1<<N
using namespace std;

int n,s,cnt[M];
vector<int> g[N];
double a[N][N],f[2][M];

double dp(){
	for(int i=1;i<=s;i++)
		cnt[i]=cnt[i>>1]+(i&1),g[cnt[i]-1].push_back(i);
	for(int i=0;i<n;i++) f[0][1<<i]=a[0][i];
	for(int i=1;i<n;i++)
		for(int now:g[i])
			for(int j=0;j<n;j++) if(now>>j&1)
				f[i&1][now]=max(f[i&1][now],f[i-1&1][now^(1<<j)]*a[i][j]);
	return f[n-1&1][s];
}
signed main(){
	cin>>n;s=(1<<n)-1;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			cin>>a[i][j],a[i][j]/=100;
	printf("%.7lf",dp()*100);
}
```

**但这还不是最优秀的做法。**

## 2、费用流

可以看出本题就是个二分图带权匹配，只不过权值是乘起来的。

这样的话有个小技巧就是对权值**取对数**，把乘法转化为加法，然后最后再取指数即可。

然后特判掉无法完成的情况即可。

```cpp
#include<bits/stdc++.h>
#define N 45
#define M N*N 
#define INF 2e9
using namespace std;

inline void rd(int &x){
	x=0;char ch=0;int w=0;
	while(!isdigit(ch)) ch=getchar(),w|=ch=='-';
	while( isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=w?-x:x;
}

int n,s,t;
int pre[N],mn[N];
double ans,dis[N];
int head[N],in[N],cnt=1;
struct nd{int nxt,to,v;double c;}e[M];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y,int v,double c){
	e[++cnt]=(nd){head[x],y,v, c};head[x]=cnt;
	e[++cnt]=(nd){head[y],x,0,-c};head[y]=cnt;
}
bool SPFA()
{
	queue<int> q;q.push(s);mn[s]=2e9;
	for(int i=1;i<=t;i++) dis[i]=-1e9; dis[s]=0;
	while(!q.empty()){
		int x=q.front();q.pop();in[x]=0;
		For(x) if(e[i].v and dis[y]<dis[x]+e[i].c)
		{
			pre[y]=i;dis[y]=dis[x]+e[i].c;
			mn[y]=min(mn[x],e[i].v);
			if(!in[y]) q.push(y),in[y]=1;
		}
	}
	return dis[t]>-1e9;
}
void up()
{
	ans+=dis[t]*mn[t];
	for(int i,x=t;x!=s;x=e[i^1].to){
		i=pre[x];e[i].v-=mn[t];e[i^1].v+=mn[t];
	}
}
signed main(){
	rd(n);s=n<<1|1;t=s+1;
	for(int x,i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			rd(x),add(i,j+n,1,log(x/100.0));
	for(int i=1;i<=n;i++)
		add(s,i,1,0),add(i+n,t,1,0);
	while(SPFA()) up();
	if(!ans) cout<<0;
	else printf("%.7lf",exp(ans)*100);
}

```

---

## 作者：ustze (赞：2)

看到@namespace_std  的题解，便基于他的想法自己写了一个更优的搜索。  
首先，这种题数据范围很小，但爆搜过不了。但搜索有一个很优的地方在于剪枝，这个东西搞得好的话一般出题人都卡不了你，爆搜能优化的地方只有剪枝，因此怎么剪坠吼是最大的问题。（事实上不少状压dp题爆搜甚至能做的比dp和退火好（如tsp问题），当然如果是计数型问题那一般就只有状压能做了）  
设当前做的概率为pos
剪枝1：如果以后的人所能做的最优的相乘再乘上pos仍<=ans 那就return  
剪枝2：如果剩下的任务的最优的做法相乘再乘上pos仍<=ans 那就return  （这两个说起来理解可能比较困难，具体见代码）  
事实上做到这两步就已经可以ac了，但还有更优的剪枝  
剪枝3：搜索前将每个人所能做的任务按概率排序。  
对于这些剪枝，感性理解便可以知道他们的优越性。  
做到这一步，总时间就可以做到<150ms了，已经很优了  
具体见代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[25][25],b[25][25];
double ans=0,mxs[25],t=1;
int mxp[25],mxd[25];
int vis[25];
void dfs(int i,double pos,double t){
    if(pos*mxs[i]<=ans||pos*t<=ans) return; //剪枝1&&剪枝2
    if(i>n){ans=pos;return;}
    for(int j=1,k;j<=n;j++){
        k=b[i][j];
        if(!vis[k]){
            vis[k]=1;
            dfs(i+1,pos*a[i][k]/100.0,t/mxd[k]*100);
            vis[k]=0;
        }
    }
}
int r;
inline int cmp(int x,int y){
    return a[r][x]>a[r][y];
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            scanf("%d",&a[i][j]);
            mxp[i]=max(mxp[i],a[i][j]);
            mxd[j]=max(mxd[j],a[i][j]);
            b[i][j]=j;
        }
    for(int i=1;i<=n;i++) {
        r=i;sort(b[i]+1,b[i]+n+1,cmp); //剪枝3
    }
    mxs[n+1]=1;
    for(int i=n;i>=1;i--) mxs[i]=mxs[i+1]*mxp[i]/100.0,t=t*mxd[i]/100.0;
    dfs(1,1,t);
    printf("%.6lf",ans*100);
    return 0;
}

```

---

## 作者：Mr_think (赞：1)

## [P4329 [COCI2006-2007#1] Bond](https://www.luogu.com.cn/problem/P4329)

## 题目大意:

有 $n$ 个人去执行 $n$ 个任务，每个人执行每个任务有不同的成功率，每个人只能执行一个任务，求所有任务都执行的总的成功率。

## solution:

看到 $n$ 很小，考虑状压。思路比较套路，可以参考[这道题](https://www.luogu.com.cn/problem/P4802)。但是与之不同的是，本题不同的顺序不会产生影响，即：

```cpp
//前代表人，后代表任务
1->5 
2->3
的成功率会等于
2->3
1->5
```

所以我们就省去了枚举工作的循环，通过枚举的状态即可知道已经完成了几个工作，然后枚举未完成工作的人进行转移：
$$f[\,i\,|\,(1<<j)]=\max(f[\,i\,|\,(1<<j)],f[\,i\,]\times1.0\times a[\,j\,][\,num\,]);$$

## 细节处理：

1. 已经完成的工作个数即为状态中 $1$ 的个数，用 $\text{lowbit}$ 即可快速求出(暴力拆位应该也行)。
2. 注意精度问题。
3.  $f$ 数组的边界值应为 $1$ 。

看到这的同学，可以自己去写[代码](https://www.luogu.com.cn/paste/irz7l7ck)了。
### End

---

## 作者：1saunoya (赞：1)

[my blog](https://www.cnblogs.com/Isaunoya/p/11630083.html)


一道很有意思的状压DP

如果硬做 这题的空间是 $O(2^{40})$ 时间是 $O(2^{40} * n^2)$

有n个人去执行n个任务，每个人执行每个任务有不同的成功率，每个人只能执行一个任务，求所有任务都执行的总的成功率。

很显然这题 求的是最大的概率 每个人都不一样…肯定是状压（~~费用流~~）

考虑怎么压一维做…因为这个是一一对应的 会少掉很多状态
比如
~~~
1->2
2->3
3->1
~~~

和

~~~
2->3
1->2
3->1
~~~

是一样的 这样就可以按`人`来状压了…

所以 $dp_i$ 表示 做过任务的人
然后你可以根据 二进制位为1的个数推断出现在在选第几个物品…然后枚举当前未选过物品的人进行转移

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define int long long
#define fi first
#define se second
#define pb push_back
inline int read() {
	register int x = 0 , f = 1 ;
	register char c = getchar() ;
	for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
	return x * f ;
}
template < typename T > inline bool cmax(T & x , T y) {
	return x < y ? (x = y) , 1 : 0 ;
}
template < typename T > inline bool cmin(T & x , T y) {
	return x > y ? (x = y) , 1 : 0 ;
}
template < typename T > inline bool cabs(T & x) {
	return x > 0 ? 1 : (x = - x) , 0 ;
}
inline int QP(int x , int y , int Mod) {
	int ans = 1 ;
	for( ; y ; y >>= 1 , x = (x * x) % Mod)
		if(y & 1) ans = (ans * x) % Mod ;
	return ans ;
}
int n ;
const int N = 21 ;
double dp[1 << N] ;
double c[N][N] ;
signed main() {
	n = read() ;
	for(register int i = 1 ; i <= n ; i ++)
		for(register int j = 1 ; j <= n ; j ++) c[i][j] = read() ;
	for(register int i = 1 ; i <= n ; i ++)
		for(register int j = 1 ; j <= n ; j ++) c[i][j] /= 100 ;
	int s = (1 << n) - 1 ;
	dp[0] = 1.00 ;
	for(register int i = 0 ; i <= s ; i ++) {
		int cnt = 1 ;
		int t = i ; while(t) t -= (t & -t) , cnt ++ ;
		for(register int j = 1 ; j <= n ; j ++)
			if(! (i & (1 << j - 1))) cmax(dp[i | (1 << j - 1)] , 1.0 * dp[i] * c[j][cnt]) ;
	}
	printf("%.9f" , dp[s] * 100) ;
	return 0 ;
}

```

---

## 作者：船酱魔王 (赞：0)

# P4329 [COCI2006-2007#1] Bond 题解

## 题意回顾

$ n $ 个人做 $ n $ 个任务，第 $ i $ 个人做任务 $ j $ 的成功率为 $ a_{i,j} $，求出一种任务安排方式使得每人正好做一个任务且每个任务正好被一个人做的基础上所有任务都成功的概率最大。

$ n \le 20 $。

## 分析

状压 DP 典题。

我们考虑给每个人依次分配任务，影响到下一个人任务分配的因素是为了避免 DP 后效性需要记录下来的。我们发现影响第 $ i $ 个人任务分配的因素只有哪些任务被用过了，我们不关心那些任务具体是被谁用了，因此设计 DP 状态 $ dp_{i,S} $ 表示前 $ i $ 个人用了 $ S $ 集合的任务，这些任务全成功的概率。

但是我们发现有很多不合法状态，例如当 $ 3 $ 个人被分配任务时 $ S $ 不可以为空集，而我们可以通过 $ S $ 的元素个数得到有几个人被分配任务了。因此我们省略掉 $ i $ 一维。

因为我们在实现中用二进制表示 $ S $，又因为一个 $ S $ 只能从一部分子集转移而来，所以我们从小到大枚举即可。

状态转移方程为 $ dp_{S}=\max \{ dp_{S-\{u\}}\times a_{|S|,u}\}(u \in S) $。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <iomanip>
using namespace std;
const int N = 25;
const int S = (1 << 20);
int n;
double a[N][N];
double dp[S];
int popcount(int x) {
	int res = 0;
	while(x) {
		res++;
		x = (x - 1) & x; 
	}
	return res;
}
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		for(int j = 0; j < n; j++) {
			cin >> a[i][j];
			a[i][j] /= 100;
		}
	}
	int tps;
	dp[0] = 1;
	for(int i = 1; i < (1 << n); i++) {
		tps = popcount(i);
		for(int j = 0; j < n; j++) {
			if((1 << j) & i) {
				dp[i] = max(dp[i], dp[i ^ (1 << j)] * a[tps][j]);
			}
		}
	}
	cout << fixed << setprecision(6) <<  (dp[(1 << n) - 1] * 100) << endl;
	return 0;
}
```

---

## 作者：xuhanxi_dada117 (赞：0)

[题目传送门&题目大意](https://www.luogu.com.cn/problem/P4329)

# 解法

## 暴力！

这道题明显可以使用全排列打暴力。

这里不再过多赘述。

时间复杂度 $\Theta (n\times n!)\ ,\ $ 只能通过 $n \le 10$ 。

## 暴力优化

考虑[这道题](https://www.luogu.com.cn/problem/P1562)的思路：将 dfs 时的 vis 数组进行状压。

每次只枚举可以更新的状态更新，时间会快不少。

但这样依然只能通过 $n\le 14$ 的数据。

## 正解

考虑一个状态可能被枚举好多遍：**记忆化！**

又因为 DAG 图原理：记忆化等价于 DP !

所以： 设 $dp[i]$ 代表选取状态为 $i$ 时的最大总成功率。

初始状态：```dp[0]=100.0 //啥都不选```。

转移方程：$dp[i]=\max\{dp[i\,-\,2^{j-1}]\times a[bs(i)][j]\}$。

可以枚举 $j$ ，进行转移。

# 代码

```cpp
#include<bits/stdc++.h>
#define N 30
using namespace std;
int n;
double a[N][N],dp[1<<(N-10)+1];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) scanf("%lf",&a[i][j]);
	dp[0]=100;
	for(int s=1;s<(1<<n);++s){
		int pos=s,bs=0;
		while(pos){
			++bs,pos-=(pos&-pos);
		}
		for(int j=1;j<=n;++j){
			if(s&(1<<j-1)){
				dp[s]=max(dp[s],dp[s^(1<<j-1)]*a[j][bs]/100);
			}
		}
	}
	cout<<fixed<<setprecision(6)<<dp[(1<<n)-1];
	return 0;
}
```
[Accepted!](https://www.luogu.com.cn/record/103665059)

---

## 作者：404Not_Found (赞：0)

很有意思的状压 dp，做法似乎跟别人不太一样。

设 $f(i,S)$ 为前 $i$ 个人完成状态为 $S$ 任务的最大成功率。

朴素的想法是枚举状态和当前的人完成的任务，状态转移方程：

$$f(i,S)=\max_{j=1}^{n}\{f(i-1,S-\{j\})\}$$

注意转移顺序，先枚举人再枚举状态，不然可能会出现多个人完成同一份任务的情况。

时间复杂度：$\mathcal{O}(n^22^n)$。空间复杂度：$\mathcal{O}(n^22^n)$。

可以获得 $80$ 分。

注意到 $f(i,...)$ 总是从 $f(i-1,...)$ 转移过来的，所以可以滚动数组优化。可以获得 $90$ 分，吸口氧就跑过去了。

考虑优化，容易发现很多状态是没有意义的，当人数和任务数不一样时这种转移是没有用的。可以预处理出所有合法状态，状态数降至 $2^n$。可以通过本题。

时间复杂度：$\mathcal{O}(n2^n)$，空间复杂度：$\mathcal{O}(2^n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 21;
double a[N][N],f[2][1<<N];
int n,popcnt[1<<N],cnt;
vector<int> t[N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%lf",&a[i][j]),a[i][j]/=100;
	for(int i=1;i<(1<<n);i++) popcnt[i]=popcnt[i>>1]+(i&1),t[popcnt[i]].push_back(i);
	for(int i=1;i<=n;i++) f[1][1<<(i-1)]=a[1][i];
	for(int i=1;i<=n;i++)
		for(int S:t[i])
			for(int j=1;j<=n;j++)
				if(S>>(j-1)&1) f[i&1][S]=max(f[i&1][S],f[i&1^1][S^(1<<(j-1))]*a[i][j]);
	printf("%lf\n",f[n&1][(1<<n)-1]*100);
	return 0;	
}
```

---

## 作者：happybob (赞：0)

我们充分发扬人类智慧：事实上搜索可做。

首先暴力搜索显然是 $O(n!)$ 的，那么我们重点考虑剪枝。

首先我们假设深搜过程中每个搜索的是事件而不是人。

我们设 $m_i$ 表示第 $i$ 件事最大的成功率，那么显然深搜过程中假设搜到了第 $depth$ 件事，目前成功率是 $p$，那么最大的成功率乘应该是 $p \times \prod_{i=depth}^n m_i$，如果这个结果还小于等于目前的最优值，那么可以剪枝。

显然 $p \times \prod_{i=depth}^n m_i$ 可以直接后缀积。

这样速度快得飞起，不开 O2，最坏的点也就跑了 $144$ 毫秒。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <bitset>
#include <algorithm>
using namespace std;

constexpr int N = 25;

double a[N][N], ans = 0;
int n;

double maxn[N], mulp[N];

bool st[25];

inline void dfs(register const int dep, register const double mul)
{
	if (mul * mulp[dep] <= ans) return;
	if (dep > n)
	{
		ans = mul;
		return;
	}
	for (register int i(1); i <= n; i = -~i)
	{
		if (!st[i])
		{
			st[i] = 1;
			dfs(dep + 1, mul * a[i][dep]);
			st[i] = 0;
		}
	}
}

inline int read()
{
	register char ch(getchar());
	register int x(0);
	while (ch < '0' || ch > '9')
	{
		ch = getchar();
	}
	while (ch >= '0' and ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int main()
{
	n = read();
	for (register int i(1); i <= n; i = -~i)
	{
		for (register int j(1); j <= n; j = -~j)
		{
			a[i][j] = read() * 0.01;
			maxn[j] = max(maxn[j], a[i][j]);
		}
	}
	mulp[n + 1] = 1;
	for (register int i(n); i >= 1; --i) mulp[i] = maxn[i] * mulp[i + 1];
	dfs(1, 1);
	printf("%.6lf\n", ans * 100);
	return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/71398094)

---

## 作者：一只书虫仔 (赞：0)

#### Description

> 有 $n$ 个人要执行 $n$ 个任务，第 $i$ 个人执行第 $j$ 个任务的成功率为 $a_{i,j}$，且每个人必须执行且只能执行一个任务，一个任务也必须被执行且只能被一个人执行。求通过分配人去执行任务后得到的最大总成功率为多少。

#### Solution

套路题。

考虑状压 dp，本篇题解为主动转移，如果想看被动转移的同学请移步其他题解。

设 $f_S$ 为 $S$ 是已经选择了的任务的集合（一个 01 串）情况下的最大成功率，设 $i$ 为下一个应该考虑到的人，则 $i$ 即为 $S$ 中 $1$ 的个数加 $1$，然后枚举 $k$ 为 $i$ 要做的任务，转移方程即：

将 $S$ 转移给第 $k$ 位改成 $1$ 之后的 $S'$，转移量即为 $a_{i,k}$，要注意必须保证 $k \not\in S$。

最后输出 $f_{\tt11\cdots{\text{\ n个}}\cdots1}$ 即可，要注意初始化 $f_{\tt00\cdots n\text{个}\cdots1}=1$。

#### Code

代码非常的难看冗长，仅供参考。

```cpp
#include <bits/stdc++.h>

using namespace std;

double a[21][21];
double dp[(1 << 20) + 1];

int dkw (int x, int i) {
	return (x >> i) & 1;
}

int cnt (int x) {
	int cn = 0;
	for (int i = 0; i <= 20; i++)
		if (dkw(x, i) == 1) cn++;
	return cn;
}

int main () {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			scanf("%lf", &a[i][j]);
			a[i][j] /= 100.0;
		}
	dp[0] = 1.0;
	for (int i = 0; i < (1 << n); i++) {
		int tmp = cnt(i) + 1;
		for (int k = 1; k <= n; k++)
			if (dkw(i, n - k) == 0) 
				dp[i | (1 << (n - k))] = max(dp[i] * a[tmp][k], dp[i | (1 << (n - k))]);
	}
//	for (int i = 0; i < (1 << n); i++) printf("dp[%d] = %.6f\n", i, dp[i]);
	printf("%.6f", dp[(1 << n) - 1] * 100.0);
	return 0;
}
```

---

## 作者：Strelitzia (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4329)

---

我们看到这道题，我们，我们可以有一个很 naive 的想法。

那就是定义 $f_{s,t}$，表示用的人，搞的任务。

当然，我们发现，这个方法在时间和空间上都是过不了的。

我们还发现，一个人的拎任务顺序对答案无影响。

所以，我们定义 $f_s$ 表示做了的任务，直接从前到后枚举人。

就减了一维。

```cpp
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

char buf[1 << 23],*p1 = buf,*p2 = buf,obuf[1 << 23],*O = obuf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++)
#define putchar(x) *O ++ = x

template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = x * 10 + ch - '0';ch = getchar();}
	x *= f;
}
int read() {
	int x = 0, f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	return x * f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

template<typename T>T Abs(T x) {return x < 0 ? -x : x;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}

const int N = 20;

int n;
double a[N][N];
double f[1 << N];

int count(int x) {		//这个只是单纯统计二进制1的个数
	x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f);
	x = (x & 0x00ff00ff) + ((x >> 8) & 0x00ff00ff);
	x = (x & 0x0000ffff) + ((x >> 16) & 0x0000ffff);
	return x;
}

int main () {
	read(n);
	for (int i = 0 ; i < n ; ++ i)
		for (int j = 0 ; j < n ; ++ j)
			read(a[i][j]),a[i][j] /= 100;
	f[0] = 1;
	int up = 1 << n;
	for (int i = 0 ; i < n ; ++ i)
		for (int s = 0 ; s < up ; ++ s) if (count(s) == i)
			for (int j = 0 ; j < n ; ++ j) if (!((s >> j) & 1))
				f[s | (1 << j)] = Max(f[s | (1 << j)],f[s] * a[i][j]);
	printf("%.6lf",f[up - 1] * 100);
	fwrite(obuf,O - obuf,1,stdout);
	return 0;
}
```

---

## 作者：_121017_ (赞：0)

# 算法：状压 $DP$
## 题目大意
有 $n$ 个人选 $n$ 个位置，每个人选每个位置有不同的权值，求一种选择方案使权值之积最大。

## 思路
因为这题的 $n$ 很小，所以我们可以用状压做。$f_{i}$ 表示当任务完成情况为 $(i)_2$ 时的最大成功率。

---
## 一些小问题

- ### $Q$：为什么只要一维就可以完成该题了呢？

- ### $A$：因为我们可以顺序安排任务，而轮到哪一个人只要数 $(i)_2$ 中 $1$ 的个数就可以了。

- ### $Q$：题目中给的是百分数，怎么处理呢？

- ### $A$：我们读入时除以一百，输出时在乘回来就可以了。

---
## code：
```cpp
#include<bits/stdc++.h>
#define ri register int
#define N 25
#define M 1<<20
using namespace std;
int n;
double f[M],a[N][N],ans;
int main(){
	cin>>n; 
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=n;j++){
			double x;
			cin>>x;
			a[i][j]=x*0.01;//因为题目给的是百分数，所以我们要除以一百使它变为小数
		}
	}
	f[0]=1;//初始化
	for(ri i=0;i<(1<<n);i++){//第一层枚举所有状态
		int cnt=0;
		for(ri x=i;x;x>>=1){
			if(x&1){
				cnt++;
			}
		}//统计已完成任务个数
		for(ri j=1;j<=n;j++){
			if(i&(1<<(j-1))){//如果当前状态完成了该任务
				f[i]=max(f[i],f[i^(1<<(j-1))]*a[cnt][j]);//从未完成该任务的状态转移过来
			}
		}
	}
	printf("%0.6lf",f[(1<<n)-1]*100);//记得乘回来
	return 0;
}

```


---

## 作者：noiplao (赞：0)

# **其实这题爆搜也可以过！**

~~众所周知状压DP比剪枝大法师慢~~

一看题目数据范围：n<=20------->大法师有希望

然鹅

20对于n!的复杂度还是略大

## 于是开始玄学剪枝

大法师大概思路是这样的：

递归的枚举每一个任务被那个吉米做了，然后统计概率，当n个任务都被做完时更新ans

这个就是朴素的n!算法

很明显有个贪心的剪枝：在当前概率已经比ans小时就可以终止递归了
（因为概率都小于等于1）

然鹅！还是会T！

再想办法优化

很明显，我们越早搜出一个很大的ans，dfs就越可能更早结束

所以我们调整搜索顺序，使得我们更有“希望”搜出较大的ans

将每个任务按照期望排序（就是把每个吉米的概率取平均），先搜大的任务

然后就可以过了

~~众所周知出题人卡不到的剪枝才是好剪枝~~

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25;
struct mission
{
	double p[N];
	double ex;
}a[N];
int n;
bool use[N];
double maxps=0;
inline void exp(int x)
{
	double res=0;
	for(register int i=1;i<=n;i++)
		res+=a[x].p[i];
	a[x].ex=res/n;
}
inline bool cmp(mission x,mission y)
{
	return x.ex<y.ex;
}
inline void dfs(int num,double ps)//num为任务编号 
{	
	if(ps<maxps)
		return;
	if(num==n+1)
	{
		maxps=max(maxps,ps);
		return;
	}
	for(register int i=1;i<=n;i++)
		if(!use[i])//use数组为吉米用过与否 
		{
			use[i]=1;
			dfs(num+1,ps*(a[num].p[i]));
			use[i]=0;
		}
}
inline int read()
{
	int w=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		w=(w<<1)+(w<<3)+(ch^48);
		ch=getchar();
	}
	return w*f;
}
int main()
{
//	ios::sync_with_stdio(false);
	n=read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
		{
			a[j].p[i]=read();
			a[j].p[i]/=100.0;
		}
	for(register int i=1;i<=n;i++)
		exp(i);
	sort(a+1,a+n+1,cmp);
	dfs(1,1.0);
	printf("%.6lf\n",maxps*100);
	return 0;
}
```
### 以674ms老牛拉破车速度过掉#20

纪念在jz集训为数不多ac的题

---

## 作者：namespace_std (赞：0)

这是[FZOJ的一次模拟赛题目B](http://218.62.22.209:8080/problem.php?cid=1902&pid=1)·····

由于我太弱了（不会状压DP），就想到了搜索

然而，预估完时间复杂度我凉了半截：$n^n$啊

于是考虑剪枝

我们设$mxl[i]$为第i个人能做的最成功的事

设$mxs[i]$为$\prod_{i}^n mxl[i]$（可以利用前缀和的技巧求：$mxs[i]=mxs[i+1]*mxl[i]$）

然后很容易证明当$sum*mxs[i]$<ans的时候一定不会搜到最优解（因为接下来最大可能结果是$sum*s[i]$，比你目前得到的结果小）

然后就要愉快的搜索了啊~（开o2，不开会炸最后一个点的）

代码：
```
// luogu-judger-enable-o2
#include<cstdio>
typedef double db;
int x[22][22],n,mxl[22];
db mxs[22],ans;
bool flag[22];
int max(int x,int y)  //懒得用STL
{if(x>y)return x;return y;}
inline void dfs(int deep,db sum)
{
    if(sum*mxs[deep]<=ans)return;  //剪枝
    if(deep>n){ans=sum;return;}
    register int i;
    for(i=1;i<=n;i++)
        if(!flag[i])
            flag[i]=1,dfs(deep+1,sum*(db)x[deep][i]/100),flag[i]=0;
}
int main()
{
    int i,ii;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        for(ii=1;ii<=n;ii++)
            scanf("%d",&x[i][ii]),mxl[i]=max(mxl[i],x[i][ii]);
    mxs[n+1]=1;  //别忘了我们是递推，一定要有一个初值
    for(i=n;i>=1;i--)mxs[i]=mxs[i+1]*(db)mxl[i]/100;
    dfs(1,1);
    printf("%.6lf\n",ans*100);
}
```
P.S.:由于搜索的时间复杂度太过于玄学，我把从1到n枚举改成从n到1枚举就脱离了o2（最后一个点600ms跑完）

---

## 作者：天南地北 (赞：0)

看这道题，不难想到DP。

本题$1≤n≤20$数据其实挺小的，我认为可以使用状压DP（正巧本人要正在练习）

刚开始想这题时，我先设$dp[i][j]$为第$i$行为第$j$个状态的最优解，显然这会$MLE$.$20*(2^4)^5=20971520$（十分危险的空间大小）

那我们就去掉一维，也就设$dp[i]$为第$i$个状态的最优解

先说明，本人习惯用$1<<(n-i)$表示第i位是否取

那么对于第$i$个状态，只要$(i$&$(1<<(n-v))==1)$（V是另外从$1$~$n$找的一个位置），我们可以从它的$i$ $xor$ $(1<<(v-1))$这个状态转过来的值.

即$dp[i]=max(dp[i],dp[i^(1<<(n-v))]*num[j][v]);$

也就是：第$i$个状态的答案=最大值（第$i$个状态的答案，从它的$i$ $xor$ $(1<<(v-1))$这个状态转过来的值）

另外，上述的j为第$i$个状态中$1$的个数，因为每一行只能取一个，所以j即为行数值。

所以最后的答案在：$dp[(1<<n)-1]$（注意：要保留$6$位小数输出，不保留小数会WA，本人在此错误多次）

求第$i$个状态中$1$的个数
```cpp
int j=0,ii=i;
for(;ii;ii>>=1)j+=ii&1;
//j即为个数
```
求第$i$个状态的答案：
```cpp
for(int v=1;v<=n;v++)//找点
	if(i&(1<<(n-v)))//该位置有取过
	   dp[i]=max(dp[i],dp[i^(1<<(n-v))]*num[j][v]);//状态转移方程
```
参考程序：（copy粘贴是不行的，你直接提交也会错……）
```cpp
#include <bits/stdc++.H>
using namespace std;
const int maxn=20；
int n,m；
double num[maxn+10][maxn+10]；
double dp[1<<maxn]；
int main()
{
	cin>>n；
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>num[i][j],num[i][j]*=0.01；
	dp[0]=1；
	for(int i=0;i<(1<<n);i++)
	{
		int j=0,ii=i；
		for(;ii;ii>>=1)j+=ii&1；
		if(dp[i])continue；
		for(int v=1;v<=n;v++)
	    	if(i&(1<<(n-v)))
	    		dp[i]=max(dp[i],dp[i^(1<<(n-v))]*num[j][v])；
	}
	printf("%.6lf",dp[(1<<n)-1]*100)；
	return 0；
}

```



---


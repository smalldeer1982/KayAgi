# [CSP-X2021 山东] 发送快递

## 题目背景

**原题为错题，不可做。数据范围修改如下，请以题目背景中的为准：**

【数据范围和限制】

对于 $40\%$ 的数据，$1 \leq n \leq 23$，$1 \leq a_i \leq 100$，$s=0$，$m$ 的值保证有解。

对于 $100\%$ 的数据，$1 \leq n \leq 23$，$1 \leq a_i \leq 100$，$0 \leq s \leq 15$，$m$ 的值保证有解。

**为了防止无意义的钻牛角尖的 hack，本题认为 $m$ 不超过 $2^{31}-1$。**

## 题目描述

小华有 $n$ 本不同的书（编号为 $1,2,3,\dots,n$），重量分别是 $a_1,a_2,\dots,a_n$ 公斤（重量可以相同）。他想把这些书以快递的方式发给自己的好朋友，要求每个包裹的重量不能超过 $m$ 公斤（可以等于 $m$ 公斤），并且小华想把其中一些书（一组书，用书的编号给出来）放在一个包裹里，应该如何打包才能使得快递件数最少。

## 说明/提示

【输入输出样例 1 说明】

第 $1$ 本和第 $4$ 本打包，重量是 $10$ 公斤。第 $2$ 本和第 $5$ 本打包，重量是 $9$ 公斤。第 $3$ 本单独打包，重量是 $8$ 公斤。所以一共 $3$ 件快递。

【输入输出样例 2 说明】

第 $1$ 本和第 $5$ 本打包，第 $2$ 本、第 $4$ 本、第 $8$ 本和第 $10$ 本打包，第 $3$ 本和第 $7$ 本打包，第 $6$ 本和第 $9$ 本打包。所以一共 $4$ 件快递。

【数据范围和限制】

对于 $40\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 100$，$s=0$，$m$ 的值保证有解。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 100$，$0 \leq s \leq 100$，$m$ 的值保证有解。

## 样例 #1

### 输入

```
5 10
8 4 8 2 5
0```

### 输出

```
3```

## 样例 #2

### 输入

```
10 80
49 11 44 18 28 24 19 10 27 29
2
1 5
4 8 2```

### 输出

```
4```

# 题解

## 作者：Yxy7952 (赞：4)

[题目传送门](/problem/B4093)

有错误请指出。

## 思路

看到 $n \leq 23$ 的数据范围，想到 DFS 暴力。

做法很简单，首先把是一个组的数都预处理好，之后 DFS。对于不在任何一个组里的数 $x$ 有两种选择，第一是放入已经有的包裹，第二是自己拿一个新的包裹。而如果 $x$ 在其中一个组里，显然它只能放入自己所在组的包裹里。

代码细节非常的多，这里将说明我遇到的问题（可能有点乱，请自行整理）：

1.  $x$ 如果在一个组里，它必须放入自己所在组的包裹里，如果放不下，说明方案有问题，直接回溯。有一个简单的方法，在搜索前预处理好要放在一个组里的包裹的重量，在 DFS 里可以直接跳过选择它们。
2.  输入时是有 $s$ 行，每行若干个数，不以 $0$ 结尾，以换行结尾。
3.  当 $a$ 和 $b$ 在一个组里，$b$ 和 $c$ 在一个组里时，$a$ 和 $c$ 在一个组里（我的方法是用并查集）。
4.  初始时已经有一些包裹了。

剪枝优化：

1.   最优性剪枝：包裹数大于等于最少包裹数时回溯。
2.   贪心，将包裹重量从大到小排序，因为轻的更灵活多变，放的方案肯定比放重的多，所以先放重的，减少轻的物品的枚举次数。
3.   贪心，将新拿一个包裹装物品的 DFS 放到枚举用哪个包裹装的 DFS 后面，显然多拿包裹没有益处，只会增加答案和枚举次数，此时算出当前最优答案 Ans 时，利用最优性剪枝可以将这些情况都卡掉。 

## 代码
有点复杂了，简单看一下吧。

总共耗时 $74ms$，妥妥最优解（第一名的代码修改数据后无法通过此题）。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 25 ; 
int n , m , s , f[N] , vis[N] ; 
int h[N] ; 
int ans = N ; 
struct node{
	int s , id ; 
}a[N] ; 
bool cmp(node x , node y){ return x.s > y.s ; }
int find(int x){
	if(f[x] == x) return x ; 
	return f[x] = find(f[x]) ; 
}
void add(int x , int y){
	vis[x] = vis[y] = 1 ; 
	x = find(x) , y = find(y) ; 
	if(x != y) f[y] = x ; 
}
void dfs(int x , int sum){
	if(sum >= ans) return ; 
	if(x == n + 1){
		ans = min(sum , ans) ; 
		return ; 
	}
	if(vis[a[x].id]){
		dfs(x + 1 , sum) ; 
		return ; 
	}
	for(int i = 1 ; i <= sum ; i++){
		if(h[i] + a[x].s > m) continue ; 
		h[i] += a[x].s ; 
		dfs(x + 1 , sum) ; 
		h[i] -= a[x].s ; 
	}
	h[sum + 1] = a[x].s ; 
	dfs(x + 1 , sum + 1) ; 
	h[sum + 1] = 0 ; 
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m ; 
	for(int i = 1 ; i <= n ; i++) cin >> a[i].s , a[i].id = f[i] = i ; 
	cin >> s ; 
	for(int i = 1 ; i <= s ; i++){
		int num ,  num2 ; 
		cin >> num2 ; 
		if(cin.get() == '\n') continue ; 
		while(cin >> num){
			add(num2 , num) ; 
			if(cin.get() == '\n') break ; 
		}
	}
	int T[N] = {0} , z = 0 ; 
	for(int i = 1 ; i <= n ; i++){
		if(vis[i]){
			int fa = find(i) ; 
			if(!T[fa]) z++ , T[fa] = z , h[T[fa]] = a[i].s ; 
			else h[T[fa]] += a[i].s ; 
		}
	}
    //预处理出已有的包裹和包裹重量。
	sort(a + 1 , a + n + 1 , cmp) ; //排序只能放这里，可以思考一下为什么。
	dfs(1 , z) ; 
	cout << ans ; 
	return 0;
}
```

## hack 数据

给一个没有用处的 hack 数据吧。

in:
```cpp
5 10
3 1 2 4 4
3
1 2
3 4
1 3
```
out:
```cpp
2
```

---

## 作者：guoshengyu1231 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4093)
## 初步思考
看了看题面，可以知道这应该是一道状态压缩 dp 的模版题，先不管题目中的限制条件，反正这一定是一道状态压缩 dp 的题目。不妨先假设 $s$ 等于 $0$，此时就是一道纯状态压缩 dp 的题目，那我们就先考虑状态压缩 dp。
## 具体步骤
### 确定状态
用一个结构体存储数组 $dp$，再定义状态 $S$ 为要处理哪些书，此时的 $dp$ 数组有两个量。其中第一个量是 $x$，代表在状态 $S$ 下最少需要几个包裹。还有一个量是 $t$，代表在 $x$ 最小的情况下，最空的包裹已经用了多少容量。其中 $dp_S$ 表示在状态 $S$ 下使这两个量最优。$\\$  
具体的，定义 $x$ 和 $t$ 这两个量最优，设最优的 $x$ 和 $t$ 为 $sx$ 和 $st$，满足在状态 $S$ 下，$\forall x$ 和 $\forall t$ 都不满足 $x<sx \lor x=sx \land t<st$。$\\$
### 状态转移
设函数 $\operatorname{cmp}$ 会在两个状态中返回较优的状态，其中，一个状态是否最优取决于状态中的两个量是否最优。
#### 方程推导
想象一下，我们要在原来的状态中新添加一本书，那我们肯定是要把它放进最空的包裹里，如果连最空的包裹都放不下，那就只能新建一个包裹来放了，所以我们可以计算出新状态，公式如下：
$$newS_x=\begin{cases}
oldS_t+a_i>m ,&oldS_x+1 \\
oldS_t+a_i\le m,&oldS_x \\
\end{cases}$$ 
 $\\$ 
$$newS_t=\begin{cases}
oldS_t+a_i>m ,&a_i \\
oldS_t+a_i\le m,&oldS_t+a_i \\
\end{cases}$$
其中 $i\in S$，$oldS$ 表示老状态，$newS$ 表示新状态。 $\\$ 
那么状态转移方程就显而易见了，每次枚举 $i$ 时算出新状态，再将所有的新状态取最优。
#### 状态转移方程
 $$dp_S=\operatorname{cmp}(dp_S,dp_{newS})$$ 
## 示例
样例输入：
```cpp
3 10
4 8 2
```
此时的 $dp$ 数组如下：

|状态S|最优答案|
|:-:|:-:|
|0 0 1（1）|1.4|
|0 1 0（2）|1.8|
|0 1 1（3）|2.4|
|1 0 0（4）|1.2|
|1 0 1（5）|1.6|
|1 1 0（6）|1.10|
|1 1 1（7）||

格式说明：最优答案用 $x.t$ 这样的格式表示。 

$\\$

现在我们已经知道了状态 $7$ 之前的所有状态的最优答案，现在我们要算出状态 $7$ 的最优答案，通过枚举 $7$ 的所有二进制位，我们可以知道状态 $7$ 可以由状态 $6$，$5$，$3$ 转移而来，可分为三组计算，分别为（$1.10$，$4$），（$1.6$，$8$），（$2.4$，$2$）。根据新状态计算公式，可得计算结果分别为 $2.4$，$2.8$，$2.6$。其中最优的答案是 $2.4$。这里只做一个示例，你们可以自己动手试一下，算一算，加深理解。    

$\\$ 
 
到目前为止，主要问题其实已经解决了。但还剩下一个问题，那就是 $s\ne 0$ 的情况。这个问题其实很简单，只需要并查集统计需要打包在一起的书，将它们的质量都加起来然后合并成一本书就行啦！
## 代码
其实我讲的应该算清晰了的，你们可以先自己试试，不懂的再看代码。

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n1,m,a1[25],s,num,n,a[25],fnum;
int f[25];
int find(int x)
{
	if(x==f[x]) return x;
	return f[x]=find(f[x]);
}
bool cmp(int x1,int y1,int x2,int y2)
{
	if(x1==y1) return x2>y2;
	return x1>y1;
}
struct{
	int x,t;
}dp[1<<23];
int main()
{
	cin>>n1>>m;
	for(int i=1;i<=n1;i++) f[i]=i;
	for(int i=1;i<=n1;i++) cin>>a1[i];
	cin>>s;
	while(s--)
	 {
		cin>>fnum;
		if(cin.get()=='\n')	continue;//若输入的是换行，跳过。 
		while(cin>>num)
		 {
			f[find(num)]=find(fnum);//并查集。	
			if(cin.get()=='\n') break;//同上。 
		 }
	 }
	for(int i=1;i<=n1;i++)
	 if(f[i]!=i)
	  {
		a1[f[i]]+=a1[i];
		a1[i]=0;
	  }
	for(int i=1;i<=n1;i++)
	 if(a1[i]) a[++n]=a1[i];
/*  并查集部分还是很好理解的，这里不再过多赘述。*/ 
	 
/*----------------------DP----------------------*/
	
	for(int i=1;i<=n;i++)
	 {
		dp[(1<<i-1)].x=1;
		dp[(1<<i-1)].t=a[i];
	 }
	//初始化，应该不用多讲了吧。 
	for(int s=1;s<(1<<n);s++)
	 {		
		if(!(s&s-1)) continue;
		dp[s].x=INT_MAX;//一定要赋初值！ 
		for(int i=1;i<=n;i++)	
		 if((s>>i-1)&1)
		  {
			int x=dp[s^(1<<i-1)].x;
			int t=dp[s^(1<<i-1)].t;
			if(t+a[i]>m)
			 {
				x++;
				t=a[i];	
			 }
			else t+=a[i];
			if(cmp(dp[s].x,x,dp[s].t,t))
			 {
				dp[s].x=x;
				dp[s].t=t;	
			 }
		  }
	 }
	cout<<dp[(1<<n)-1].x;
	return 0;
}
```

---

## 作者：xinxin2022 (赞：2)

注意到 $n \le 23$，可以尝试搜索。

首先把必须放在同一个包裹里的一组书合并，当成一大本书处理。

然后分为两部分搜索：

先枚举能放在哪些已有包裹里，对于还能放下这本书的进行搜索。

然后考虑新建一个包裹，把这本书放到新包裹里，然后搜索。

不加剪枝可以做到[这样](https://www.luogu.com.cn/record/199939456)。

然后考虑对于当前包裹数量已经大于等于目前答案的方案，直接停止搜索。

容易做到[接近满分](https://www.luogu.com.cn/record/199941845)。

然后容易发现质量较大的书选择空间比较小，可以让质量大的书先选择包裹，以此限制小质量书的选择空间。

成功[满分了](https://www.luogu.com.cn/record/199943282)。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,ans=54,c[55],b[55],a[55],r,lst,p,k;
vector<int> G[55];
bool vis[55];
void build(int now){
    vis[now]=1;
    a[p]+=b[now];
    for(int i:G[now]){
        if(!vis[i]) build(i);
    }
}
bool cmp(int a,int b){
    return a>b;
}
void dfs(int now,int val){
    if(val>=ans) return;
    //大于目前答案直接剪掉
    if(now==p+1){
        ans=val;
        return ;
    }
    for(int i=1;i<=k;i++){
        if(c[i]+a[now]<=m){
            c[i]+=a[now];
            dfs(now+1,val);
            c[i]-=a[now];
        }
    }
    //插到已有包裹里
    k++;
    c[k]+=a[now];
    dfs(now+1,val+1);
    //新开包裹
    c[k]-=a[now];
    k--;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>b[i];
    }
    cin>>s;
    for(int i=1;i<=s;i++){
        cin>>lst;
        while(cin>>r){
            G[lst].push_back(r);
            G[r].push_back(lst);
            lst=r;
            if(cin.get()=='\n') break;
        }
    }
    for(int i=1;i<=n;i++) if(!vis[i]) p++,build(i);
    //合并必须放一起的书
    sort(a+1,a+1+p,cmp);
    //p表示合并完还有多少本书
    dfs(1,0);
    cout<<ans;
    return 0;
}
```

---

## 作者：SukiYuri (赞：1)

### 鲜花

~~蒟蒻第一篇绿题题解，好激动。~~

## 分析

首先考虑物品捆绑的限制，我们考虑用一个并查集维护要放到相同箱子里的物品，把它们合成一个大物品。

考虑一个这样子的贪心：

假设我们已经决定了前 $i-1$ 个物品摆放的位置，现在我们考虑第 $i$ 个物品的位置，我们显然会选择一个最大的不小于 $m-a_i$ 的箱子把它放进去。如果我们不存在这样的箱子，我们就新开一个箱子。

具体地我们来看这一组数据：

```
5 7
4 5 2 3 5
0
```

按照上述思路，我们有：

| 物品重量  | $4$ | $5$ | $2$ | $3$ | $5$ |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 箱子 $1$ | $4$ | $4$ | $4$ | $7$ | $7$ |
| 箱子 $2$ | - | $5$ | $7$ | $7$ | $7$ |
| 箱子 $3$ | - | - | - | - | $5$ |

+ 第 $1,2$ 个物品的操作非常显然；
+ 第 $3$ 个物品，箱子 $1$ 容量为 $4$，箱子 $2$ 容量为 $5$，两个箱子加上 $2$ 后均不大于 $7$，此时 $5$ 更大，故选择将箱子 $2$ 的容量变为 $7$；
+ 第 $4$ 个物品，只有箱子 $1$ 能放下，故选择将箱子 $1$ 的容量变为 $7$；
+ 第 $5$ 个物品，只能让它放到箱子 $3$ 里。

于是答案就是 $3$ ~~这道题就做完了~~。

如果我们交换一下数据的顺序：

```
5 7
4 2 5 3 5
0
```

| 物品重量  | $4$ | $2$ | $5$ | $3$ | $5$ |
|:-:|:-:|:-:|:-:|:-:|:-:|
| 箱子 $1$ | $4$ | $6$ | $6$ | $6$ | $6$ |
| 箱子 $2$ | - | - | $5$ | $5$ | $5$ |
| 箱子 $3$ | - | - | - | $3$ | $3$ |
| 箱子 $4$ | - | - | - | - | $5$ |

可以发现这个思路就错了。原因是前面摆放的箱子会影响到后面箱子的摆放，这样我们常规 dp 的希望也没了，只剩下状压 dp 和搜索。

**果真如此吗？**

我们发现这个思路的正确性和物品顺序有关！而且，对于一个需要 $m$ 个箱子的数据，至少有 $m!\times (\lfloor\frac{n}{m}\rfloor!)^{m-n\bmod m}\times(\lceil\frac{n}{m}\rceil!)^{n\bmod m}$ 种排列符合要求（这里仅考虑同箱子的物品均连续的情况，实际上的限制比这个弱的多得多，因此这是个非常低的估计），依据上面的式子，在 $n=23,m=7$ 的情况下，随机排列大概有 $8\times 10^{-13}$ 的概率正确。几乎没有生还的可能。

但是这题数据水啊，我们考虑模拟退火，说白了就是有策略地随机排列，就可以通过此题。

## 代码
```cpp
#include "cstdio"
#include "iostream"
#include "cmath"
#include "algorithm"
#include "cstring"
#include "random"
#include "climits"

using namespace std;

const double eps=1e-10,mul=0.9997;

int n,m,wi[24],box[24],fa[24],_wi[24];
mt19937 gen(time(0));

int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}
inline int calc() {
    int cnt=1; box[cnt]=0; box[0]=-1;
    for(int i=1;i<=n;++i) {
        int pos=0;
        for(int j=1;j<=cnt;++j) 
            if(box[j]+wi[i]<=m&&box[j]>box[pos]) pos=j;
        if(pos) box[pos]+=wi[i];
        else box[++cnt]=wi[i];
    }
    return cnt;
}
int cnt;
inline int SA() {
    int ans=1e9;
    for(double T=8000;T>eps;T*=mul) {
        ++cnt;
        memcpy(_wi,wi,sizeof wi);
        shuffle(wi+1,wi+n+1,gen);
        int now=calc(); ans=min(now,ans);
        if(exp((ans-now)/T)<1.0*gen()/0xFFFFFFFFu) memcpy(wi,_wi,sizeof wi);
    }
    return ans;
}
int main() {
    ios::sync_with_stdio(0);
    cin>>n>>m; 
    for(int i=1;i<=n;++i) cin>>wi[i],fa[i]=i;
    int s; cin>>s; 
    while(s--) {
        int x=0,y; cin>>x;
        while(1) {
            cin>>y;
            int _x=find(x),_y=find(y);
            if(_x<_y) swap(_x,_y);
            fa[_x]=_y; x=y;
            char ch=cin.get();
            if(ch=='\n'||ch==EOF) break;
        }
    }
    for(int i=1;i<=n;++i) if(find(i)!=i) wi[find(i)]+=wi[i],wi[i]=0;
    // cout<<n<<'\n';
    // for(int i=1;i<=n;++i) cout<<wi[i]<<' '; 
    int ans=calc();
    while(1.0*clock()/CLOCKS_PER_SEC<0.9) ans=min(ans,SA()); 
    cout<<ans;
    return 0;
}
```

实际上，用下面这份代码生成数据，模拟退火的正确率低的吓人。

```cpp
#include "iostream"
#include "random"
using namespace std;
mt19937 gen(time(0));
int a[50];
inline void work() {
    int n=23,m=1e9,cnt=0;
    cout<<n<<" "<<m<<'\n';
    for(int i=1;i<=5;++i) {
        int sum=0;
        a[++cnt]=gen()%(m/2)+1;
        sum=a[cnt];
        a[++cnt]=gen()%(4ll*(m-sum)/5)+1;
        sum+=a[cnt];
        a[++cnt]=m-sum-gen()%10;
    }
    for(int i=1;i<=2;++i) {
        int sum=0;
        a[++cnt]=gen()%(m/2)+1;
        sum=a[cnt];
        a[++cnt]=gen()%((m-sum)/2)+1;
        sum+=a[cnt];
        a[++cnt]=gen()%(4ll*(m-sum)/5)+1;
        sum+=a[cnt];
        a[++cnt]=m-sum-gen()%10;
    }
    shuffle(a+1,a+cnt+1,gen);
    for(int i=1;i<=cnt;++i) cout<<a[i]<<' ';
    cout<<"\n0\n";
}
int main() {
    freopen(".in","w",stdout);
    int T; cin>>T; // 数据组数
    while(T--) work();
}
```

---

## 作者：clash_for_windows (赞：0)

# B4093 [CSP-X2021 山东] 发送快递
[B4093 [CSP-X2021 山东] 发送快递](https://www.luogu.com.cn/problem/B4093)
## 初步思路：
注意到 $ n < 23 $，可以尝试搜索，但发现直接 DFS 较为复杂，快递件数可以二分，所以考虑**二分 + DFS**。
## 初步处理：
本题要求把一组书放在一个包裹中，考虑将一组书通过**并查集**合并为一本书，再进行处理。
## 二分 + DFS：
二分包裹数，再 DFS 书籍编号，每次递归遍历包裹，看书能放哪个包裹，然后继续 DFS。
### 剪枝：
1. 将书重量从大到小排序，先放重的减少轻的枚举次数。
2. 可证第 $i$ 书放到 $i$ 后包裹没有意义。
## 代码：
```cpp
#include<iostream>
#include<vector>
#include<math.h>
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,w,s;
vector<int>v,c,f; 
bool check(int x,int limit){
	
//	cout<<x<<'\n';
//	for(int i=1;i<=limit;i++)cout<<v[i]<<' ';cout<<'\n';
	for(int i=1;i<=limit&&i<=x;i++){
		if(v[i]+c[x]>w)continue;
		v[i]+=c[x];
		if(x==n)return 1;
		if(check(x+1,limit))return 1;
		v[i]-=c[x];
	}
	return 0;
}
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
bool cmp(int a,int b){
	return a>b;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>w;
	f=c=vector<int>(n+2);
	for(int i=1;i<=n;i++)cin>>c[i],f[i]=i;
	cin>>s;
	for(int i=1;i<=s;i++){
		int num,a;
		cin>>num;
		if(cin.get()=='\n')continue;
		while(cin>>a){
			f[find(a)]=find(num);
			if(cin.get()=='\n')break;
		}
	}
	for(int i=1;i<=n;i++)if(find(i)!=i)c[find(i)]+=c[i];
	int len=0;
	for(int i=1;i<=n;i++){
		if(find(i)==i){
			c[++len]=c[i];
		}
	}
	n=len;
	//cout<<n<<'\n';
	//for(int i=1;i<=n;i++)cout<<c[i]<<' ';cout<<'\n';
	int l=0,r=n,ans=0;
	sort(c.begin()+1,c.begin()+1+n,cmp);
	while(l<=r){
		int mid=(l+r)>>1;
		v=vector<int>(n+2,0);
	//	cout<<mid<<'\n';
		if(check(1,mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans;
} 
```

---

## 作者：ty_mxzhn (赞：0)

首先强选就是来搞笑的，我们直接把这些书放在一起作为一本新书就行。

然后考虑设计 $f_{i,j}$ 表示考虑了 $j$ 这个集合里的书时，把 $i$ 堆书分别捆了，剩下的还没捆的书占了 $f_{i,j}$ 的重量。

转移有两种：

1. $f_{i+1,j}=0$
2. $f_{i,j\cap k}=f_{i,j}+a_k$

直接转移即可，时间复杂度 $O(n2^n)$。

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[B4093 [CSP-X2021 山东] 发送快递](https://www.luogu.com.cn/problem/B4093)
## 思路：
这题是状压 DP 的模版题，和[这题](https://www.luogu.com.cn/problem/P3052)几乎一模一样，这种题给小学生考，确实太难了（2023 年[慈溪市](https://baike.baidu.com/item/%E6%85%88%E6%BA%AA%E5%B8%82/2384416?fromtitle=%E6%85%88%E6%BA%AA&fromid=431775&fr=aladdin)小学生计算机程序设计竞赛复赛的第四题也考了状压 DP，蒟蒻做得脑子炸了，我把[卷子](https://www.luogu.com.cn/problem/U526206)给各位 dalao 看一下），但蒟蒻喜欢用深搜。

题目说有 $s$ 组书籍需要捆绑，而且 $n$ 比较小，于是，我们可以用~~神搜~~深搜配上~~剪纸~~剪枝来求最优解。$i$ 从 $1$ 跑到 $num$，每次判断有没有超重，超重则舍去，否则进入下一层深搜，如果超出边界，记录答案，一旦 $num$ 比现在的答案大或者等于，直接返回，起到剪枝的作用，但以下程序只有 $16$ 分。

## 16pts：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s,a[20],w[20],ans=20;
void dfs(int num,int MAN){
	if(MAN>n){
		ans=min(ans,num);
		return ;
	}
	if(num>=ans){
		return ;
	}
	for(int i=1;i<=num;i++){
		if(w[i]+a[MAN]<=m){
			w[i]+=a[MAN];  
			dfs(num,MAN+1);
			w[i]-=a[MAN];
		} 
	}
	w[num+1]+=a[MAN];
	dfs(num+1,MAN+1);
	w[num+1]-=a[MAN];
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>s;
	if(s!=0){
		while(s--){
			int x,poker=0;
			while(cin>>x){
				if(poker==0) poker=x;
				else{
					a[poker]+=a[x];
                    a[x]=0;
				}
				if(getchar()=='\n')break;
			}
		}
	}
	dfs(1,1);
	cout<<ans;
}
``````

于是，我又想到了用贪心，用一个 $ans$ 数组统计重量，最后输出组数即可，不过只有 $48$ 分。
## 48pts：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1010],S,ans[1010],k,b[1010],kk;
bool flag[1010];
int main(){
	memset(flag,1,sizeof flag);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	cin>>S;
	int k=S;
	for(int i=1;i<=S;i++){
		string s="";
		cin>>s;
		int shu=0;
		for(int j=0;j<s.size();j++){
			if(isdigit(s[j]))shu=shu*10+s[j]-'0';
			else{
				ans[i]+=a[shu];
				flag[shu]=0;
				shu=0;
			}
		}
		if(shu>0){
			ans[i]+=a[shu];
			flag[shu]=0;
			shu=0;
		}
	}
	memcpy(b,a,sizeof b);
	memset(a,0,sizeof a);
	for(int i=1;i<=n;i++)
		if(flag[i])a[++kk]=b[i];
	reverse(a+1,a+1+kk);
	while(kk>0){
		bool F=0;
		for(int i=1;i<=k;i++)
			if(m-ans[i]>=a[kk]){
				F=1;
				ans[i]+=a[kk];
				kk--;
				break;
			}
		if(F==0&&kk>0)ans[++k]=a[kk],kk--;
	}
	cout<<k;
}
``````
我又将深搜进行改正，增加了剪枝和排序，和一些~~奇葩~~名称，请各位不要见怪。
## 100pts：
```cpp
#include<bits/stdc++.h>
#define int long long
#define esle else
#define RE return
#define fi if
#define fir for
using namespace std;
int n,m,s,f[110],used[110];
int h[110];
int ans=110;
struct node{
	int s,ID;
}a[110];
bool cmp(node a,node b){
	RE a.s>b.s;
}
int find(int x){
	fi(f[x]==x)RE x;
	RE f[x]=find(f[x]);
}
void add(int x,int y){
	used[x]=used[y]=1;
	x=find(x),y=find(y);
	fi(x!=y)f[y]=x;
}
void dfs(int x,int sum){
	fi(sum>=ans)RE;
	fi(x>n){
		ans=min(sum,ans);
		RE;
	}
	fi(used[a[x].ID]){
		dfs(x+1,sum);
		RE;
	}
	fir(int i=1;i<=sum;i++){
		fi(h[i]+a[x].s>m)continue;
		h[i]+=a[x].s;
		dfs(x+1,sum);
		h[i]-=a[x].s;
	}
	h[sum+1]=a[x].s;
	dfs(x+1,sum+1);
	h[sum+1]=0;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	fir(int i=1;i<=n;i++)cin>>a[i].s,a[i].ID=f[i]=i;
	cin>>s;
	fir(int i=1;i<=s;i++){
		int num1,num12;
		cin>>num12;
		fi(cin.get()=='\n')continue;
		while(cin>>num1){
			add(num12,num1);
			fi(cin.get()=='\n')break;
		}
	}
	int T[110],z=0;
	memset(T,0,sizeof T);
	fir(int i=1;i<=n;i++){
		fi(used[i]){
			int father=find(i);
			fi(!T[father])z++,T[father]=z,h[T[father]]=a[i].s;
			esle h[T[father]]+=a[i].s;
		}
	}
	sort(a+1,a+n+1,cmp);
	dfs(1,z);
	cout<<ans;
}
``````

---


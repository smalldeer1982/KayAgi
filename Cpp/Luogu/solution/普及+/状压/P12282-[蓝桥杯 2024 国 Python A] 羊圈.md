# [蓝桥杯 2024 国 Python A] 羊圈

## 题目描述

小蓝养了 $m$ 头羊，它们站成一排，第 $i$ 头羊有 $p_i$ 的概率跑掉。小蓝为了不让他的羊跑掉，购买了 $n$ 个羊圈，第 $i$ 个羊圈最多可以框住连续的 $l_i$ 只羊，让它们无法逃跑。小蓝想知道，在合理安排羊圈位置的情况下，能跑掉的羊的数量的期望的最小值是多少？

请注意：羊圈不一定都使用，也不一定按顺序使用。

## 说明/提示

### 样例说明

第一个羊圈框住第 $5$ 头羊，第二个羊圈框住第 $9$ 至第 $10$ 头羊，第三个羊圈框住第 $6$ 至第 $8$ 头羊，剩下的羊逃跑的数量的期望为 $0.1 + 0.2 + 0.3 + 0.4 = 1.0$

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 8$；
- 对于所有评测用例，$1 \leq n \leq 15$，$1 \leq m \leq 200$，$1 \leq l_i \leq m$，$0 \leq p_i \leq 1$。

## 样例 #1

### 输入

```
3 10
1 2 3
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0```

### 输出

```
1.00```

# 题解

## 作者：ylch (赞：1)

发现 $n$ 和 $m$ 都很小，尤其是 $n$ 最大只有 $15$，暴力自然是可以枚举栅栏的全排列，然后 01dfs 每个位置是否放栅栏。

数据范围小，且可以转化为全排列问题，所以考虑状压 dp。

根据暴力，我们需要知道当前栅栏的使用情况和当前位置（确定放栅栏后能框住的范围），所以设 $f_{i,S}$ 表示当前位置为 $i$，栅栏使用状态为 $S$ 时，跑掉的羊的数量的最小期望。

想了一会转移方程，发现直接求最小逃跑期望不大好求，考虑正难则反，设 $f_{i,S}$ 表示最大不逃跑期望。

转移方程：
$f_{i,S}=\max\{f_{i-1,S},\ f_{i-l_j+1,S \setminus j}+\sum\limits_{k=i-l_j+1}^{i} p_k\}$，其中 $i-l_j+1 > 0$。

答案即为所有的 $\min\{\sum\limits_{k=1}^{n} p_k-f_{m,S}\}$。

注意特判如果所有羊圈能完全覆盖所有羊，则直接输出 $0$。


```cpp
#include <bits/stdc++.h>
using namespace std;

int l[15], tot;
double p[205];
double dp[205][1 << 15], sum[205];

int main(){
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> l[i], tot += l[i];
    for(int i = 1; i <= m; i ++) cin >> p[i];

    if(tot >= m){ // 特判
        cout << "0.00"; return 0;
    }

    // 前缀和
    for(int i = 1; i <= m; i ++){
        sum[i] = sum[i - 1] + p[i];
    }

    // 初始化dp
    for(int i = 0; i <= m; i ++){
        for(int s = 0; s <(1 << n); s ++){
            dp[i][s] = -1e18;
        }
    }
    dp[0][0] = 0;

    for(int i = 1; i <= m; i ++){
        for(int s = 0; s < (1 << n); s ++){
            // 情况1：当前位置不放任何羊圈
            dp[i][s] = dp[i - 1][s];

            // 情况2：尝试在当前位置放置一个羊圈
            for(int j = 1; j <= n; j ++){
                if((s & (1 << j-1)) && i >= l[j]){
                    dp[i][s] = max(dp[i][s], dp[i - l[j]][s ^ (1 << j-1)] + sum[i] - sum[i - l[j]]);
                }
            }
        }
    }

    double minn = 1e18;
    for(int s = 0; s < (1 << n); s ++){
        minn = min(minn, sum[m] - dp[m][s]);
    }
    if(minn < 1e-8) minn = 0; // 避免精度误差

    cout << fixed << setprecision(2) << minn;
    return 0;
}
```

---


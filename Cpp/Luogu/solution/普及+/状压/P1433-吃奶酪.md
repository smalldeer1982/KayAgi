# 吃奶酪

## 题目描述

房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1\leq n\leq 15$，$|x_i|, |y_i| \leq 200$，小数点后最多有 $3$ 位数字。

#### 提示

对于两个点 $(x_1,y_1)$，$(x_2, y_2)$，两点之间的距离公式为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

---

$2022.7.13$：新增加一组 $\text{Hack}$ 数据。

## 样例 #1

### 输入

```
4
1 1
1 -1
-1 1
-1 -1```

### 输出

```
7.41```

# 题解

## 作者：novax (赞：426)

#### updated 2020.10.10：更正了文中状态转移方程的错误


------------


本题用到的知识点：

## 状压DP

> 状压 dp 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。 - [OI wiki](https://oi-wiki.org//dp/state/)


**状态压缩**的思想是用二进制来表示状态。用一个整数的二进制形式的每一个二进制位 $0$ 或 $1$ 表示一个状态。


------------

本题会涉及到部分[位运算](https://oi-wiki.org//math/bit/)的知识

本题是一道比较基础的状压DP题目。

状压DP的时间复杂度为 $O(n^2 2^n)$，通常只能通过 $N \leq 21$ 的数据范围，本题数据范围为 $N \leq 15$ 因此可以使用状压DP。

#### 思路

坐标可能为实数，因此要用double类型存储。

定义一个数组 $F_{i,j}$，表示老鼠走到第 $i$ 个奶酪，且走过的二进制状态为 $j$ 时，最短的距离。

举例来说，可以使用二进制 $10100110$ 来表示已经走过第 $2$、$3$、$6$、$8$ 个奶酪，此时 $j$ 的值为 $166$。需要注意的是，第 $i$ 个状态是从低位向高位的第i位。

在更新 $F$ 数组状态时会用到两点间的距离，使用两点间距离公式计算：

$a = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$

首先要将 $F$ 数组进行初始化为极大值，可以使用```memset(F,127,sizeof(F));```来为浮点数赋极大值

因为到达第 $i$ 块奶酪，且只经过过第 $i$ 块奶酪的距离即为第i块奶酪与坐标原点的距离。因此要初始化```F[i][(1<<(i-1))]=a[0][i];```。

接下来是三层循环，分别枚举所有可能的二进制状态、当前点所在的位置和能在当前状态下到达当前点的位置。

在第二层循环中要判断一下 $i$ 在当前二进制状态下是否已走过，如果根本没走过则不需要进行接下来的计算，直接continue就可以。

在第三层运算中同样要判断当前点是否已走过，且当前点不与 $i$ 点相同。

接下来就可以转移状态了：

设此时二进制状态为 $k$，终点为 $i$，起点为 $j$，可得状态转移方程：$F_{i,k}=\min(F_{i,k},F_{j,k-{2^{i-1}}} +A_{i,j})$。$F_{j,k-{2^{i-1}}}$ 为在 $j$ 点且没有走过 $i$ 点的最短距离， $A_{i,j}$ 是从 $i$ 到 $j$ 的距离。

最后，找出 $F_{i,2^N-1}$ 中的最小值就是最终的答案了。

#### 代码如下
```cpp
#include <cstdio>
#include <cstring> 
#include <cmath> 
#define min(a,b) (((a)<(b))?(a):(b)) 
//洛谷 P1433 吃奶酪 状压DP
double a[20][20];//预处理，从第i块到第j块的距离，使用两点之间距离公式 
double x[20],y[20];//每块奶酪的横、纵坐标
double F[18][34000];//状压DP数组 在第i个点上，走过的二进制状态的十进制表达为j时，最短的距离 
int N; 
double distance(int v,int w)//计算第v个和第w个奶酪之间的距离 
{
	return sqrt((x[v]-x[w])*(x[v]-x[w])+(y[v]-y[w])*(y[v]-y[w]));//两点间距离公式 
}
int main()
{
	int i,j,k;
	double ans;
	memset(F,127,sizeof(F));//这样可以给浮点数赋值无穷大 
	ans=F[0][0];
	scanf("%d",&N);
	for(i=1;i<=N;i++)
	{
		scanf("%lf%lf",&x[i],&y[i]);//数据读入 
	}
	x[0]=0;y[0]=0;
	for(i=0;i<=N;i++)
	{
		for(j=i+1;j<=N;j++)
		{
			a[i][j]=distance(i,j);//初始化距离数组 
			a[j][i]=a[i][j];
		}
	} 
	for(i=1;i<=N;i++)//初始化 
	{
		F[i][(1<<(i-1))]=a[0][i];//在i点上且只有经过i点时距离是原点到i点的距离 
	}
	for(k=1;k<(1<<N);k++)//枚举所有二进制的状态 
	{
		for(i=1;i<=N;i++)
		{
			if((k&(1<<(i-1)))==0)
				continue;//i的位置没被走过，所以不需要再继续计算了 
			for(j=1;j<=N;j++)
			{
				if(i==j)
					continue;//同一个点不需要再计算 
				if((k&(1<<(j-1)))==0)
					continue;//j的位置没走过  
				F[i][k]=min(F[i][k],F[j][k-(1<<(i-1))]+a[i][j]);
			} 
		} 
	} 
	for(i=1;i<=N;i++)
	{
		ans=min(ans,F[i][(1<<N)-1]);
	}
	printf("%.2f\n",ans);
}
```


---

## 作者：D10s (赞：187)

好像没有人用状压DP啊……个人更喜欢这种复杂度比较确定的做法。

设f[i][s]表示从i点出发遍历集合为s的点的路程最小值（i也包括在s里），枚举s里的其他点进行转移。

边界为f[i][s]=0（s中只有i）。

注意最后答案要加上到（0，0）的距离。

时间复杂度O(n\*2^n)

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
typedef double db;
db x[20],y[20],f[20][35000];
template<class T> T min(T a,T b) {return a<b?a:b;}
db dis(int a,int b) {return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));}
int main()
{
    int n;scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lf%lf",&x[i],&y[i]);
    memset(f,127,sizeof(f));
    for(int s=1;s<=(1<<n)-1;s++)
    for(int i=1;i<=n;i++)
    {
        if((s&(1<<(i-1)))==0) continue;
        if(s==(1<<(i-1))) {f[i][s]=0;continue;}
        for(int j=1;j<=n;j++)
        {
            if((s&(1<<(j-1)))==0||i==j) continue;
            f[i][s]=min(f[i][s],f[j][s-(1<<(i-1))]+dis(i,j));
        }
    }
    db ans=-1;
    for(int i=1;i<=n;i++)
    {
        db s=f[i][(1<<n)-1]+dis(i,0);
        if(ans==-1||ans>s) ans=s;
    }
    printf("%.2lf\n",ans);
    return 0;
}
```

---

## 作者：快快做题 (赞：90)

[博客阅读效果更佳](https://www.luogu.org/blog/29243/chi-nai-lao)
# [P1433吃奶酪](https://www.luogu.org/problemnew/show/P1433)题解  
## 做法
1. **状压dp**(本篇重点）
2. 暴搜+最优化剪枝（待实现）
3. 玄学算法（见其他题解） 

## 前置
- 状压dp，全称状态压缩dp，是一种在数据范围不大（n<=20左右）的情况下，代替暴搜的常用方法
- 状态常以二进制形式表示，从左往右第k位表示第k个元素的选择情况，0表示未被选择，1表示已选  
> 例如二进制下110101，表示第1、3、5、6个元素已被选择
- 因为涉及二进制，所以简单的位运算必须掌握
> 
1.对位判断：例如第k位为0 ((1<<(k-1))&s)==0  
2.枚举子集  
```cpp
	for(int S1=S;S1!=0;S1=(S1-1)&S){
    S2=S^S1;
}
```  
3.and so on
- 为了方便调试，学会十进制转二进制也很有必要
```cpp
int shizhuaner(int dec){
	int result = 0,temp = dec,j = 1;
	while(temp){
		result = result + j*(temp%2);
		temp = temp/2;
		j = j*10;
	}
	return result;
}
```  
***
## 本题的错误做法
- 由[noip2016愤怒的小鸟](https://www.luogu.org/problemnew/show/P2831)
而来，那是我用状压的第一道题，大家也可以先做该题以入门状压
- 看了上面那道题，自然而然地想到用s表示哪些点被选择，而f[s1]可以推出加入任意一个未到达的点k后的状态s2，f[s1]=f[s2]+len(k,s1中所有已到的点距离最小值）  

```cpp
      int main()
      {
          scanf("%d\n",&n);
          for(ri i=1;i<=(1<<n);i++)f[i]=inf+1;
          for(ri i=1;i<=n;i++){
              scanf("%lf%lf",&x[i],&y[i]);
              f[(1<<(i-1))]=jl(0,0,x[i],y[i]);//边界  
          }
          for(ri i=1;i<n;i++){
              for(ri j=i+1;j<=n;j++)
              len[i][j]=len[j][i]=jl(x[i],y[i],x[j],y[j]);
          }
          f[0]=0;
          for(ri s=1;s<(1<<n);s++){
              if(f[s]>=inf)continue;
              cnt=0;
              for(ri k=0;k<n;k++){//找到s中所有已经到达的点 ，并存起来 
                  if(((1<<k)&s)!=0){
                      que[++cnt]=k+1;
                  }
              }
              for(ri k=0;k<n;k++){
                  if(((1<<k)&s)==0){//找到s中所有未到的点 
                      tmp=inf;
                      for(ri l=1;l<=cnt;l++){
                          tmp=min(tmp,len[que[l]][k+1]);//找一条由s中的点到新点的最短路 
                      }
                      f[(1<<k)|s]=min(f[(1<<k)|s],f[s]+tmp);
                  }
              }
          }
          printf("%.2lf",f[(1<<n)-1]);
          return 0;
      }
```  
- 很快打完了，乘兴而来........败兴而归
![](https://cdn.luogu.com.cn/upload/pic/48051.png)  
- 为什么呢？我的想法这么优秀，这题又是普及-能难到哪去？
***
## 正确做法 
- 先来看一幅图
![](https://cdn.luogu.com.cn/upload/pic/48049.png)
- 如果只看4、 5 、6 三个点，f[ ]为几呢？我的程序给的是7，标准程序是7.41，难道我们的做法比题解还优？？？

- 我们动手试一下，先从(0,0)到（3，-4），距离为5，再走4->5, 4->6,各为1,于是答案为7
- 想一下，我们到了4后，先从4走到5，后从4走到6，为什么小老鼠已经到了5，又回到了4呢？
- 原来我们的思路出问题了，在新的距离选取中不能找最短路，而要找从当前点到新点的距离。  
- 现在的目标是存储当前点，于是我们用F[ 当前点i ] [ 当前状态 ] 完整地表示一个状态，转移方程也很好写，具体见代码。~~其实是我不会发公式~~

```cpp
      #include <bits/stdc++.h>
      #define ri register int
      using namespace std;

      int i,j,k,n,que[17],cnt,p;
      double x[17],y[17];
      double tmp,ans;
      double len[17][17],f[17][100000];

      double jl(double x1,double y1,double x2,double y2)
      {
          return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
      }
      int dect(int dec){// 十进制转二进制，便于调试 
          int result = 0,temp = dec,j = 1;
          while(temp){
              result = result + j*(temp%2);
              temp = temp/2;
              j = j*10;
          }
          return result;
      }

      int main()
      {
          memset(f,127,sizeof(f));//double无穷大赋值方式 
          scanf("%d\n",&n);
          for(ri i=1;i<=n;i++){
              scanf("%lf%lf",&x[i],&y[i]);//注意是实数读入 
              f[i][(1<<(i-1))]=jl(0,0,x[i],y[i]);//边界条件 
          }
          for(ri i=1;i<n;i++){
              for(ri j=i+1;j<=n;j++)
              len[i][j]=len[j][i]=jl(x[i],y[i],x[j],y[j]);
          }
          for(ri s=1;s<(1<<n);s++){
              cnt=0;
              for(ri k=0;k<n;k++){//注意从0开始，所以下面的转移方程中要加一 
                  if(((1<<k)&s)==0)que[++cnt]=k;
              }//求出所有未到达的点 
              for(ri i=1;i<=n;i++){
                  if(abs(f[i][s]-f[0][0])<0.0000001) continue;//浮点数相等表示法 
                  for(ri l=1;l<=cnt;l++){
                      f[que[l]+1][s|1<<(que[l])]=min(f[que[l]+1][s|1<<(que[l])],f[i][s]+len[que[l]+1][i]);
                  }
              }	
          }
          ans=f[0][0];//赋予一个无穷大初值 
          for(ri i=1;i<=n;i++)ans=min(ans,f[i][(1<<n)-1]);
          printf("%.2lf",ans);
          return 0;
      }
```
***
## 小细节
-  ```cpp
memset(f,127,sizeof(f));//double无穷大赋值方式
```  
- 十进制转二进制，便于调试  
- 读入坐标都是实数
***

[最后宣传一波博客](https://www.luogu.org/blog/29243/)~~，虽然目前什么都没有~~


---

## 作者：Thaumaturge (赞：58)

忽然发现其实可以用状压dp的思想来优化dfs...

观察数据，15个奶酪！这数据并不大，根据题意，老鼠走的路径是无后效性的，只要经过的点一致，所在的点也一致，接下来所要走的路径就是等价的

所以可以用一个二进制数来记录走过的点，另一个数记录老鼠所在的点，如果之后搜到的答案比这个点要大，就不继续搜即可，大致思想就是这样

详见代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
long double a[30][2],lt[30][30],zt[(1<<15)+15][18];//记录状态，第一维记录走过的点，第二维记录所在的点
long double cc1,cc2,answ;
int bj[30],i,j;

void dfs(int y,int ww,int x,long double ans){//深搜
	if(x==n+1) if(answ==0 || answ>ans) {answ=ans;return;}
	for(int g=1;g<=n;g++)
	{
		if(!bj[g])
		{
			int xb=ww+(1<<(g-1));//xb表示当前已走过的点，有标记数组挡着不用怕二进制数会进位
			if(zt[xb][g]!=0)
			if(zt[xb][g]<=ans+lt[y][g]) continue;//如果生成的路径长度比之前的还要长就不对该点继续dfs
			bj[g]=1;//标记
			zt[xb][g]=ans+lt[y][g];//记录状态
			dfs(g,xb,x+1,zt[xb][g]);//继续往下搜
			bj[g]=0;//回溯
		}
	}
	return;
}

int main(){
	cin>>n;
	a[0][0]=0;a[0][1]=0;
	for(i=1;i<=n;i++)
	{
		scanf("%Lf %Lf",&a[i][0],&a[i][1]);
		for(j=0;j<i;j++)//对两点距离初始化
		{
			cc1=a[i][0]-a[j][0];
			cc2=a[i][1]-a[j][1];
			lt[j][i]=sqrt(cc1*cc1+cc2*cc2);//记录两点距离
			lt[i][j]=lt[j][i];
		}
	}
	dfs(0,0,1,0);
	printf("%.2Lf",answ);
	return 0;
}
```

有个很奇怪的事，就是优化过的dfs跑第六个点比不优化的还慢，~~真是玄学~~

---

## 作者：丧黑福造 (赞：52)

其实本题不用状压也能过的。。。

本题看上去就是一个普通的搜索，不过需要一些（~~玄学~~）技巧

但是还是要用到状压（会卡一个点）

不过相对真·状压来说比较好理解

代码：
```cpp
#include<stdio.h>
#include<math.h>
int n;
double a[20],b[20],dp[65000][20];
bool v[20];
double ans=1e9;
double dis(int x,int y){
	sqrt((a[x]-a[y])*(a[x]-a[y])+(b[x]-b[y])*(b[x]-b[y]));//距离公式
}
void dfs(int t,int now,double s,int b){
	if(s>ans) return; //剪枝
	if(t==n){
		ans=ans<s?ans:s;
		return;
	}
	for(register int i=1;i<=n;i++){
		if(!v[i]){
			int p=b+(1<<(i-1));//状压存状态
			if(dp[p][i]!=0&&dp[p][i]<=s+dis(now,i)) continue;//判断条件+优化
			v[i]=1;
			dp[p][i]=s+dis(now,i);
			dfs(t+1,i,dp[p][i],p);
			v[i]=0;//回溯
		}
	}
}
main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
		scanf("%lf%lf",&a[i],&b[i]);
	dfs(0,0,0,0);
	printf("%.2lf\n",ans);
	return 0;
	
}
```

### 如有不懂，阔以私信我


------------


## 如果有错误的地方，欢迎指正

---

## 作者：Starlight237 (赞：47)

upd：修改了关于NP-hard的一个原则性错误

这里提供另外一种状压dp，同时此题作为TSP（几乎）的模板题，顺便详细地解释一下旅行商问题（TSP）。

## TSP
原题：
> 有n个城市，从起点 0 开始游历每一个城市，只访问每个城市一次，最后回到起点，所需要的最短路径是多少？ 

OI界尚未发现本题多项式时间复杂度的解法。我们可以穷举全排列，从而获得一个$\Theta((n-1)!)$的做法。

然而这通常会TLE，所以需要优化。模拟退火是一个很好的思路，但是正确率有时不能得到保证，参见其他题解，此处不再赘述。

我们可以对集合来dp。令$f[S][i]$表示从$i$出发，还剩下点集$S$未走。那么不难发现可以**逆推**：
$$\begin{cases}f[\emptyset][i]=0,0\le i\le n\\f[S][i]=f[S+\{j\}][j]+dist(i,j),0\le i,j\le n\\Ans=f[\emptyset][0]\end{cases}$$
那么点集如何表示呢？此类问题由于是$NP-hard$问题（如果不清楚此类概念可以在luogu日报中寻找），n一般很小，所以可以**状态压缩**，设$S_i$表示S的二进制第i位，$S_i=0\ or\ 1$表示是否i在集合内。

那么只需要一些简单位运算即可（参见代码），同时记得floyd预处理dist。

不难发现本题就是TSP问题，因为最短路径一定是直线距离，所以无需floyd。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
double dp[1<<16][17],dist[17][17],x[17],y[17];
int n;
inline void init(){
    scanf("%d",&n);
    for(reg int i=1;i<=n;++i)
        scanf("%lf%lf",x+i,y+i);
    x[0]=y[0]=0;
    for(reg int i=0;i<=n;++i)
        for(reg int j=0;j<=n;++j)
            dist[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
    memset(dp,127,sizeof dp);
}
inline void solve(){
    for(reg int i=0;i<=n;++i)dp[(1<<n+1)-1][i]=0;
    for(reg int S=(1<<n+1)-2;~S;--S)
        for(reg int i=0;i<=n;++i)
            for(reg int j=0;j<=n;++j)
            	if(!(S&1<<j))dp[S][i]=min(dp[S][i],dp[S|1<<j][j]+dist[i][j]);
    printf("%.2lf",dp[0][0]);
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：NULL0x7f (赞：37)

### 看到那么多dalao用搜索，状压DP~~（貌似还有一个爬山）~~
### 本蒟蒻决定尝试一下玄学算法——**模拟退火**
---
这题大意就是最短路遍历平面上n个点，看上去是不是好像TSP啊^v^

了解 TSP也就是货郎担问题 [看这里](https://baike.baidu.com/item/TSP%E9%97%AE%E9%A2%98/840008)

所以这一题也可以套用TSP问题的做法之一，模拟退火。

模拟退火的主要步骤是

1. 先初始化温度，当前解和当前答案

2. 如果温度小于最终温度，跳6；否则跳3

3. 由当前解生成一个临时的新解，并计算新的答案

4. 判断是否接受该临时解，接受则更新解和答案，不接受则回退到上个解

5. 降温，跳2

6. 结束

**模拟退火的原理是通过一个变化的概率接受一个较差的答案的贪心**

**对于差解的判断和 这个解有多差 以及 当前温度 有关，解越差我们越不想要它，接受它的概率就小一些；贪心往往会在开始的时候陷入局部最优解，我们就要在开始的时候跳出局部最优，也就是通过走向较差的解，所以开始的时候接受差解的概率要大一些，快结束的时候我们需要稳定在当前的最优解，接受差解的概率就小一些，所以我们模拟物理的退火原理，温度从高逐渐降低，对于接受差解概率的计算公式e^(delta/T)来说，新解答案的差异值为分子delta，是个负数（如果正数取负就行），答案越差，delta绝对值越大，指数越小，概率也越小；温度越低，指数越小，概率也越小，这就符合了我们求解的需要。**

更具体的模拟退火移步[到这里](https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95)

模拟退火的关键是是怎么生成一个新解，和怎么计算一个解带来的价值。下面我们分别讲一讲。

### 怎么生成一个新解

对于此题，一个合法的解是一个1~n的全排列，所以一开始我们随机一个排列，或者直接用1~n的排列，生成新解就随机两个位置，交换它们。

### 怎么计算一个合法解的答案

模拟就行，从(0,0)按照排列的顺序走一遍，累加距离。

那么解决了这些，就上代码吧！！（代码奇丑勿喷）

```cpp
// luogu-judger-enable-o2(能开O2为啥不开)
#define main mian //防作弊
#include<cstdio>
#include<cstdlib>
#include<time.h>
#include<cmath>
#include<algorithm>
#define sqr(_) ((_)*(_))
using namespace std;
const int N=20;
const double T0=1e5;//初始温度
const double T_end=1e-4;//最终温度
const double D=1-3e-3;//降温速度
const int L=100;//卖个关子
int n,now[N],st=clock();//点数，当前解和卡时
double x[N],y[N],ans=1e9;//点的坐标，最终答案
double dis(int a,int b) {return sqrt(sqr(x[a]-x[b])+sqr(y[a]-y[b]));}
//计算两点距离的公式
double calc() {//计算一个合法解的答案
    double res=0;
    for(int i=1;i<=n;++i)res+=dis(now[i-1],now[i]);
    return res;
}
double rand_f() {return double(rand())/double(RAND_MAX);}
//生成一个随机小数
bool RP_up(double delta,double t) {return delta>0||rand_f()<exp(delta/t);}
//判断是否接受一个新解
void SA() {//退火主过程
    for(int i=1;i<=n;++i)   now[i]=i;//初始解
    double T=T0,sum=calc();//T为当前温度，sum为当前答案
    while(T>T_end) {
        for(int i=0;i<L;++i) {
        //对于每个温度我们多走几次减小误差，这也是个(玄学)技巧吧
            int u=rand()%n+1,v=rand()%n+1;
            swap(now[u],now[v]);//生成新解
            double tsum=calc();//计算新解答案
            if(RP_up(sum-tsum,T)) sum=tsum,ans=min(ans,sum);
            else    swap(now[u],now[v]);//判断是否接受新解
            //ans和sum的区别，sum是当前走到的点的答案
            //ans是单独维护的一个目前为止遇到过的最优解
        }T*=D;//降温
    }
}
int main() {
    srand(0x7f);srand(rand());//玄学随机大法
    scanf("%d",&n);
    for(int i=1;i<=n;++i)   scanf("%lf%lf",&x[i],&y[i]);
    while(clock()-st<0.9*CLOCKS_PER_SEC)SA();//卡时(真香)
    printf("%.2lf",ans);return 0;//代码什么的都去死吧
}
```
_**~~关于模拟退火可以来看看[我的博客](https://www.cnblogs.com/no-true/p/9737193.html)~~**_

---

## 作者：Aryper (赞：17)

吃奶酪

对了，酪读作lao，第四声。

正好看到《算法竞赛进阶指南》在 0x00 节的一道状压题目，感觉和这题很相似，就尝试用这种做法来解决这道题目，但主要原因是原书的配套题库 CH 炸了，所以就只能写一道类似的题目了。

深深感受到状压的恶心。

我们定义一个状态 $f[i][j]$ ，其中 $i$ 是一个二进制数，每一位表示这个点是否被经过， $j$ 表示当前走到哪一个点。

为了方便，我们添加第 0 个点，坐标为 $(0,0)$ ，二进制数的第 0 位表示这个点是否被经过。

于是我们可以得出一个状态转移方程：

$$f[i][j]=\min\{f[i][j],f[i\operatorname{xor}(1<<j)][k]+weight(j,k)\}$$

这里用 $\LaTeX$ 的下标太难看了，所以就用了 C++ 形式来写。

这里的 k 是我们枚举的一个之前经过的点， $weight(j,k)$ 表示从 j 到 k 的距离，$i\operatorname{xor}(1<<j)$ 表示将 i 的第 j 位取反 (即取 0)，表示第 j 个点未经过。

这个状态转移的前提是 i 的第 j 位和第 k 位为 1 ，即经过第 j 个点和第 k 个点。

初始化 $f[1][0] = 0$ ，即经过第 0 个点。

时间复杂度 $O(n^2*2^n)$ 。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<cstring>
#include<vector>
using namespace std;

int n;

double ans;

double f[1<<16][20],x[20],y[20];

const double inf=1000000005;

inline int read() {
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') {ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
	return ret*f;
}

int main() {
	
	n=read();
	
	for(int i=1;i<=n;i++) {
		scanf("%lf %lf",&x[i],&y[i]);
	}
	
	for(int i=0;i<(1<<16);i++) {
		for(int j=0;j<=20;j++) f[i][j]=inf;
	}
	
	f[1][0]=0;x[0]=y[0]=0;
	
	for(int i=1;i<1<<(n+1);i++)  {
		for(int j=1;j<=n;j++) if((i>>j)&1) {
			for(int k=0;k<=n;k++) if(((i^(1<<j))>>k)&1) {
				double w=sqrt((x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k]));
				f[i][j]=min(f[i][j],f[i^(1<<j)][k]+w);
			}
		}
	}
	
	ans=inf;
	
	for(int i=1;i<=n;i++) {
		ans=min(ans,f[(1<<(n+1))-1][i]);
	}
	
	printf("%.2f",ans);
	
	return 0;
}
```


---

## 作者：__stdcall (赞：15)

没有动态规划的做法？我就来一篇dp做法吧

这个题刘汝佳的紫书上有详细讲解，就是经典的货郎担问题

设dp[i][S]为已经走过的点的集合为S，当前停留在点i的最短距离

集合S用二进制数来表示，需要用到位运算，第x位设置为1表示第x个点已经走过

实现方法是记忆化搜索，当然也可以递推，不过很麻烦

复杂度为O( n^2 \* 2^n )

转移方程详见代码，还是比较简单的









```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <queue>
#include <cmath>
using namespace std;
const int INF = 1e9;
int n;
double x[15];
double y[15];
double dp[15][1<<15];
inline int istrue( int A , int bit )
{
    return A&(1<<bit);
}
inline int set0( int A , int bit )
{
    return A&( ~(1<<bit) );
}
inline double dist( double x1 , double y1 , double x2 , double y2 )
{
    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}
void dfs( int now , int S )
{
    if( dp[now][S] != -1 ) return;
    dp[now][S] = INF;
    for( int i = 0 ; i < n ; ++i )
    {
        if( i == now ) continue;
        if( !istrue( S , i ) ) continue;
        dfs( i , set0( S , now ) );
        dp[now][S] = min( dp[now][S] , dp[i][ set0( S , now ) ] + dist( x[i] , y[i] , x[now] , y[now] ) );
    }
}
int main()
{
    cin >> n;
    for( int i = 0 ; i < n ; ++i ) cin >> x[i] >> y[i];
    for( int i = 0 ; i < n ; ++i )
    {
        for( int j = 1 ; j < (1<<n) ; ++j )
        {
            dp[i][j] = -1;
        }
    }
    for( int i = 0 ; i < n ; ++i ) dp[i][1<<i] = dist(0,0,x[i],y[i]);
    for( int i = 0 ; i < n ; ++i ) dfs( i , (1<<n)-1 );
    double mn = INF;
    for( int i = 0 ; i < n ; ++i ) mn = min( mn , dp[i][(1<<n)-1] );
    printf( "%.2lf" , mn );
    return 0;
}

```

---

## 作者：Vector_ (赞：11)

考虑到$n<=15$,可以使用模拟退火。

这题的模拟退火有几个地方值得注意一下：

- 优解和劣解之间相差不大，所以考虑到这一点可以把初始温度调的比较小。

```cpp
	double t=9.0;
```

- 相应的，降温系数$delta$就要变得更接近于1。
```cpp
#define delta 0.9999965
```

- 并且因此，我们可以试着将接受解的概率变大。

```cpp
else if(rand()>exp((ans-calc())/t)*rm*5000) swap(a[x],a[y]);
```
- 贪心虽然不是正解，但是我们可以用它来作我们的初始答案，这样会使程序更容易跑出正解。

```cpp
for(int i=1;i<=n;i++)
	{
		double d=114514191981.0;int now=-1;
		for(int j=1;j<=n;j++)
		{
			if(vis[j]) {continue;}
			if(now==-1) now=j,d=dis(x[a[i-1]],x[now],y[a[i-1]],y[now]);
			else if(d>dis(x[a[i-1]],x[j],y[a[i-1]],y[j])) d=dis(x[a[i-1]],x[j],y[a[i-1]],y[j]),now=j;
		}
		a[i]=now;
		vis[a[i]]=true;
	}//贪心的初始化
```

- 两个随机数相乘可以在$mod$ $n$($n$较小)意义下使随机数更加均匀。

```cpp
int rnd() {return (((rand())%32767)*(rand()%32767))%32767;}//mod n更加均匀的随机数
```

最后上代码。

```cpp
#include<bits/stdc++.h>
#define delta 0.9999965 //降温系数
#define rm RAND_MAX 
using namespace std;
int rnd() {return (((rand())%32767)*(rand()%32767))%32767;}//mod n更加均匀的随机数
int a[20],n;
double x[20],y[20];
bool vis[20];
double dis(double x1,double x2,double y1,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double calc()
{
	double ans=0,nowx=0,nowy=0;
	for(int i=1;i<=n;i++) ans+=dis(nowx,x[a[i]],nowy,y[a[i]]),nowx=x[a[i]],nowy=y[a[i]];
	return ans;
}
int main()
{
    cin>>n;
    srand(19981125);
    srand(rand());
    memset(vis,false,sizeof(vis));
    x[0]=0,y[0]=0;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
    if(n==1) {printf("%.2lf",dis(0,x[1],0,y[1]));return 0;}
	double t=9.0,ans=114514191981.0;
	double nowx=0,nowy=0;//这里无意义，本来想放在贪心里的，但是没用上，请无视
	for(int i=1;i<=n;i++)
	{
		double d=114514191981.0;int now=-1;
		for(int j=1;j<=n;j++)
		{
			if(vis[j]) {continue;}
			if(now==-1) now=j,d=dis(x[a[i-1]],x[now],y[a[i-1]],y[now]);
			else if(d>dis(x[a[i-1]],x[j],y[a[i-1]],y[j])) d=dis(x[a[i-1]],x[j],y[a[i-1]],y[j]),now=j;
  //          cout<<now<<endl;
		}
		a[i]=now;
		vis[a[i]]=true;
	}//贪心的初始化
//	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
//	cout<<endl<<calc()<<endl;
	ans=calc();
	while(clock()<CLOCKS_PER_SEC*0.99)
	{
		int x=rnd()%n+1,y=rnd()%n+1;
		while(y==x) y=rnd()%n+1;
		swap(a[x],a[y]);
		if(ans>calc()) ans=calc();
		else if(rand()>exp((ans-calc())/t)*rm*5000) swap(a[x],a[y]);
		t*=delta;
	}//模拟退火框架
	printf("%.2lf\n",ans);//输出答案，保留两位小数
  //  cout<<t<<endl;
}
```

---

## 作者：hzoi_liuchang (赞：10)

## 分析
比较简单的状压DP

我们设$f[i][j]$为当前的状态为$i$且当前所在的位置为$j$时走过的最小距离

因为老鼠的坐标为$(0,0)$，所以我们要预处理出$f[1<<(i-1)][i] (1 \leq i \leq n)$的值

同时在读入的时候顺便处理处任意两个奶酪之间的距离

下面是状态转移方程

``` cpp
    for(int i=1;i<(1<<n);i++){
        for(int j=1;j<=n;j++){
            if((i&(1<<(j-1)))==0) continue;
            for(int k=1;k<=n;k++){
                if(k==j) continue;
                if((i&(1<<(k-1)))==0) continue;
                f[i][j]=min(f[i][j],f[i^(1<<(j-1))][k]+jl[k][j]);
            }
        }
    }
```
思路就是枚举当前状态已经到达的城市，在已经到达的城市中枚举当前所在的城市

同时枚举上一个状态所在的城市，在所有状态中取一个最小值即可
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef double dd;
const int maxn=18;
dd f[1<<maxn][maxn];
dd jlx[maxn],jly[maxn];
dd jl[maxn][maxn];
int main(){
    for(int i=1;i<(1<<18);i++){
        for(int j=0;j<18;j++){
            f[i][j]=10000000.0;
        }
    }
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%lf%lf",&jlx[i],&jly[i]);
        f[1<<(i-1)][i]=(dd)sqrt(jlx[i]*jlx[i]+jly[i]*jly[i]);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            jl[i][j]=(dd)sqrt((jlx[i]-jlx[j])*(jlx[i]-jlx[j])+(jly[i]-jly[j])*(jly[i]-jly[j]));
        }
    }
    for(int i=1;i<(1<<n);i++){
        for(int j=1;j<=n;j++){
            if((i&(1<<(j-1)))==0) continue;
            for(int k=1;k<=n;k++){
                if(k==j) continue;
                if((i&(1<<(k-1)))==0) continue;
                f[i][j]=min(f[i][j],f[i^(1<<(j-1))][k]+jl[k][j]);
            }
        }
    }
    dd ans=100000000.0;
    for(int i=1;i<=n;i++){
        ans=min(ans,f[(1<<n)-1][i]);
    }
    printf("%.2lf\n",ans);
    return 0;
}
```

---

## 作者：Bring (赞：6)

# 好好的dfs，被我硬生生打成状压dp
## ~~其实只是感觉dfs会爆~~
### Let's go->
**约定：为方便计算，使用0~n-1表示各个点**

首先用d[i][j]表示i奶酪到j奶酪的距离

设f[i][j]表示以i（二进制串）为结束状态（0表示没吃，1表示吃了），以j号奶酪结束时的最短距离。

于是~~很明显~~答案就是**min{f[(1<<n)-1][i]}**(0<=i<n)

现在我们来想方程

以i状态在j号奶酪结束的最短距离可以由**[i-(1<<j)（即在吃j号奶酪之前）状态中各个结束点的最短距离+该点到j号点的距离]**取最小值得到

于是就有**f[i][j]=min{f[i-(1<<j)][k]+d[j][k]}**(i&(1<<k)(即k号点在i的二进制串中存在)&&k!=j)

最后，考虑初始化

题目说从原点开始，所以只吃一个奶酪时最短距离为该奶酪到原点的距离

于是就有**f[i][j]=sqrt(x[j]^2+y[j]^2)(i==1<<j（即二进制串中只有j）)**

强迫症~~比如说我~~可以把‘-’改成‘^’~~卡常~~

以下就是丑陋的代码->
```cpp
#include<cstdio>
#include<cmath>
#define Rd(a) (a=read())
inline int read(){
	register int x;
	register char c(getchar());
	register bool k;
	while((c<'0'||c>'9')&&c^'-')c=getchar();
	if(c^'-')x=c-'0',k=1;
	else x=0,k=0;
	for(c=getchar();c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+c-'0';
	if(k)return x;
	else return (x^(int)(-1))+1;
}
#define Frn0(i,a,b) for(register int i(a);i<b;++i)
#define Frn1(i,a,b) for(register int i(a);i<=b;++i)
#define Min(a,b) ((a)<(b)?(a):(b))
int n,sz;
double d[15][15],f[1<<15][15],x[15],y[15];
inline double sq(double a){return a*a;}
signed main(){
	sz=(1<<Rd(n))-1;//sz表示结束二进制串
	Frn0(i,0,n){
		scanf("%lf%lf",x+i,y+i);
		Frn0(j,0,i)d[i][j]=d[j][i]=sqrt(sq(x[i]-x[j])+sq(y[i]-y[j]));//计算距离
	}
	Frn1(i,1,sz)Frn0(j,0,n)if(i&(1<<j)){//当j在i的二进制串中时才有意义
		if(i==1<<j)f[i][j]=sqrt(sq(x[j])+sq(y[j]));
		else{
			f[i][j]=100000;
			Frn0(k,0,n)if(i&(1<<k)&&k!=j)f[i][j]=Min(f[i][j],f[i^(1<<j)][k]+d[j][k]);
		}
	}
	Frn0(i,1,n)*f[sz]=Min(*f[sz],f[sz][i]);//最后的打擂
	printf("%.2lf",*f[sz]);
	return 0;
}
```

---

## 作者：McGrady (赞：6)

好像没有pascal的状压dp啊

很明显是状压dp，i二进制表示集合，j表示在哪个点，f[i,j]表示最短距离，转移是O(n)的，总复杂度O(2^n\*n^2),比搜索快很多啊

pascal代码：

```cpp
program rrr(input,output);
const
  inf=123456789;
var
  a,b:array[0..17]of double;
  d:array[0..17,0..17]of double;
  f:array[0..40000,0..17]of double;
  n,m,i,j,k,rj,rk:longint;
  ans:double;
function min(a,b:double):double;
begin
   if a<b then exit(a) else exit(b);
end;
begin
   //assign(input,'r.in');assign(output,'r.out');reset(input);rewrite(output);
   readln(n);
   for i:=1 to n do readln(a[i],b[i]);
   for i:=1 to n do for j:=1 to n do if i<>j then d[i,j]:=sqrt(sqr(a[i]-a[j])+sqr(b[i]-b[j]));
   //for i:=1 to n do begin for j:=1 to n do write(d[i,j]:0:2,'    '); writeln; end;
   m:=1<<n-1;
   for i:=1 to m do for j:=1 to n do f[i,j]:=inf;
   for i:=1 to n do f[1<<(i-1),i]:=sqrt(sqr(a[i])+sqr(b[i]));
   //for i:=1 to m do begin for j:=1 to n do if f[i,j]=inf then write(-1,'  ') else write(f[i,j]:0:2,'  ');writeln; end;writeln;
   for i:=1 to m-1 do
       begin
       for j:=1 to n do
           begin
              rj:=1<<(j-1);
              if i and rj>0 then
                 for k:=1 to n do
                     begin
                        rk:=1<<(k-1);
                        if i and rk=0 then
                           f[i or rk,k]:=min(f[i or rk,k],f[i,j]+d[j,k]);
                     end;
           end;
        //for k:=1 to m do begin for j:=1 to n do if f[k,j]=inf then write(-1,'  ') else write(f[k,j]:0:2,'  ');writeln; end;writeln;
        end;
   ans:=inf;
   for i:=1 to n do if f[m,i]<ans then ans:=f[m,i];
   write(ans:0:2);
   //close(input);close(output);
end.
```

---


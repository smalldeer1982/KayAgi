# 软件补丁问题

## 题目描述

T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。

每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。

换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。

试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。

## 说明/提示

对于 $100\%$ 的数据：$1\le n\le 20$，$1\le m\le 100$。

## 样例 #1

### 输入

```
3 3
1 000 00-
1 00- 0-+
2 0-- -++
```

### 输出

```
8
```

# 题解

## 作者：FCBM71 (赞：21)

状压 + 最短路板子题（似乎不状压都可以过）。但感觉楼下的几位都讲的不是太详细，于是决定补发一波萌新友好型题解。适合还没有怎么接触过状态压缩和状态最短路的童鞋们。     

如果你还不熟悉位运算六大运算符（`&`,`|`,`~`,`^`,`<<`,`>>`），可以先自行百度。

### Step1. 怎么最短路？

这道题可能和平常我们熟知的最短路不太一样。节点不是现成的节点，边不是现成的边。  

那么这道题中的节点是什么呢？是状态。**状态就是指bug修复的状态**。最开始，所有bug都还没有被修复，因此初始状态是 `全部未修复` 。通过运行某些补丁包，可以修复一些bug或者新增一些bug，那么此时的bug修复状态就是当前状态。我们就可以用最短路算法来维护从初始状态（全bug）到当前状态（修复了某些bug） 的最短路径。   
你可能还会问，我们怎么加边呢？这道题不需要加边，每次只需要枚举每一个补丁包即可（类似于完全图）    
那路径长度是什么呢？不就是运行补丁包的总时间吗。    
终点是什么呢？很显然，就是修复全部的Bug。  

### Step2. 状态压缩

由于一共有最多20个bug，如果每个bug都有已经修复和没有修复两种状态，那么每次状态转移需要传20个参（20元数组）。能不能把这一过程优化到1个参数呢？我们需要状态压缩。**由于对于每个bug都只有修复没修复两种状态，我们不妨用0,1表示（1表示未修复，0已修复）。如果我们把这20个0,1串在一起就得到了一个二进制串，一个二进制串也就对应着一个整数**。这样我们就把一个状态压缩成了一个整数(int)  
我们以样例为例，假设当前一种状态是（已修复bug12，未修复bug3），那么对应的01串就是110，转化成整数就是6。那么我们就可以知道：初始的bug全部未修复状态为111，对应7。结束的bug全部修复状态为000，对应0。将情况拓展到 $n$ 个bug，那么初始状态就是 $2^n-1$，即`(1<<n)-1`。结束状态是 $0$。

### Step3. 状态转移

说完了压缩再来说说转移。转移说白了就是根据当前的状态，计算出修复了bug之后的状态。

#### 判断能否使用一个补丁包

翻译成状态语言就是，只有当前状态的某些位置上全部是1，某些位置上全部是0，才可以运行补丁包。如何进行这一判断呢？ 我们可以把一个补丁包的使用先决条件也压缩成两条状态。样例中补丁包3的使用条件b1就是`000`=0，b2就是`011`=3.

记当前状态为x  
1.判断是不是所有的b1位都是1：我们可以把b1与x按位与。容易知道，如果的得到的值就是b1本身，那么x所有b1位上都是1   
2.判断是不是所有的b2位都是0：我们可以把b1与x按位与。容易知道，如果的得到的值就是0，那么now所有b2位上都是0     

代码：（p是补丁包结构体）
```cpp
 if((x&p[i].b1)==p[i].b1&&(x&p[i].b2)==0) 执行下一步
 ```
 
 #### 使用了一个补丁之后的情况
 
 翻译成状态语言就是，使用之后将f1位置上变成0,f2位置上变成1。我们还是按照之前的思路，将f1,f2也计算成两个状态。如果需要将f2位置变成1，那么只需要用当前状态或上f2。如果需要将f1位置变成0，我们可以或上一个f1，使得当前状态的所有f1位置都变成1，再异或一个f1，这样就可以将f1所有位置变成0.
 
 代码：（y代表运行补丁包之后的状态）
 ```cpp
 int y=((x|p[i].f1)|p[i].f2)^p[i].f1;
 ```
 
 ### Step 4. 贯穿
 
 主要思路讲完了，接下来就是完整的代码。
 
 ```cpp
 #include<cstdio>
#include<queue>
#include<cstring>
using namespace std;

struct pack{int f1,f2,b1,b2,t;}p[505];
int n,m,fir,minn[1<<22],tag;  //由于最多有2^20种状态，数组要开够
queue<int>q;bool exi[1<<22];

inline void read(int &x){
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	x=ch^48;ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
}

inline int gtag(){  //手写读入可以防止出错
	char ch=getchar();
	while(ch!='+'&&ch!='-'&&ch!='0')ch=getchar();
	if(ch=='+')return 1;
	if(ch=='-')return 2;
	return 0;
}

void spfa(){  //关于spfa，它还没死
	memset(minn,0x7f,sizeof(minn));
	minn[fir]=0;
	q.push(fir);
	while(!q.empty()){
		int x=q.front();
		for(int i=1;i<=m;++i)  //枚举每一个包
		 if((x&p[i].b1)==p[i].b1&&(x&p[i].b2)==0){  //判断先决
		 	int y=((x|p[i].f1)|p[i].f2)^p[i].f1;//得到运行后状态
		 	if(minn[x]+p[i].t<minn[y]){
		 		minn[y]=minn[x]+p[i].t;
		 		if(!exi[y]){
		 			q.push(y);
		 			exi[y]=true;
		 		}
		 	}
		 }
		exi[x]=false;
		q.pop();
	}
}

int main(){
	read(n);read(m);
	for(int i=1;i<=m;++i){
		read(p[i].t);
		for(int j=1;j<=n;++j){
			tag=gtag();
			if(tag==1)p[i].b1|=(1<<j-1);  
			if(tag==2)p[i].b2|=(1<<j-1);  //得到每个补丁包的先决条件串
		}
		for(int j=1;j<=n;++j){
			tag=gtag();
			if(tag==1)p[i].f2|=(1<<j-1);
			if(tag==2)p[i].f1|=(1<<j-1);  //得到每个补丁包运行之后的状态串
		}
	}
	fir=(1<<n)-1;   //得到初始状态
	spfa();
	if(minn[0]==minn[(1<<22)-1])printf("0");  //如果根本到达不了目标状态，就是无解
	 else printf("%d",minn[0]); 
	return 0;
}
```
 

---

## 作者：Dorg (赞：16)

今天刷了几道网络流24题里的，也好久没写过日志，先写篇前几天码的[P2761 软件补丁问题](https://www.luogu.org/problemnew/show/P2761)吧


------------
### 思路如下：

1. 位压（位运算压缩）表示状态，0表示没such bug，反之1表示有。
2. 我的补丁叫**hero**（不要吐槽），结构体里的变量意义如题。
3. 初始状态（111...)暴力求出（我知道可以不这么暴力）：
```cpp
FOR(i,1,n) ST=ST|(1<<i);
```
4. 打一个最短路（我不知道这是SPFA还是DJ...)，进行 **~~微调~~** ：
	
    1） 判定当前状态是否符合hero愿意拯救的类型：
    
    若now为：  0110011
    
    hero要求：  0010010
    
    并的结果是：0010010
       
    那么，意味着不管hero的0位，而&操作就是只要有一个0结果就肯定是0的主。然后稍微举个例子就能得到两种情况了。

	2）得到终点状态：
    
    若now为： 0110011
    
    hero可以消灭的是： 0010010
    
    先无差别攻击，管你有没有，都让你有：**now|hero[i].f1**
    
    再把他们给灭了： ((now|hero[i].f1)**^hero[i].f1**)
    
    最后雁过留声： ((now|hero[i].f1)^hero[i].f1)**|hero[i].f2**
5. 好了，就这样一道~~网络流24题~~就做完了。

6. 你若问我为什么没有网络流，我会告诉你：
![](https://cdn.luogu.com.cn/upload/pic/54940.png )


------------
### CODE
```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define Maxn 100
#define Maxm 100
#define Maxnum  4000000

using namespace std;

inline int read(){
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}

int n,m; 
int ST;

struct debug{
	int b1;
	int b2;
	int f1;
	int f2;
	int T;
}hero[Maxm+2];

priority_queue < pair<int,int> > q;
int dist[Maxnum]; int Hash[Maxnum];
void dj(){
	memset(dist,0x3f,sizeof(dist));
	dist[ST]=0;
	q.push(make_pair(0,ST));
	while(!q.empty()){
		int now=q.top().second; q.pop();
		if(Hash[now]==1) continue;
		Hash[now]=1;
		FOR(i,1,m){
			if( (hero[i].b1&now)==hero[i].b1 && (hero[i].b2&now)==0 ){
				int v=((now|hero[i].f1)^hero[i].f1)|hero[i].f2;
				if(dist[now]+hero[i].T<dist[v]){
					dist[v]=dist[now]+hero[i].T;
					q.push(make_pair(-dist[v],v));
				}
			}
		}
	}
}

int main(){
	
	n=read(); m=read();
	
	FOR(i,1,n)
		ST=ST|(1<<i);
	
	FOR(i,1,m){
		hero[i].T=read();
		string B,F;
		cin>>B>>F;
		FOR(j,0,n-1){
			if(B[j]=='+')
				hero[i].b1=hero[i].b1|(1<<(j+1));
			if(B[j]=='-')
				hero[i].b2=hero[i].b2|(1<<(j+1));
			if(F[j]=='+')
				hero[i].f2=hero[i].f2|(1<<(j+1));
			if(F[j]=='-')
				hero[i].f1=hero[i].f1|(1<<(j+1));
		}
	}
	dj();
	if(dist[0]==dist[Maxnum-1])
		cout<<"0";
	else
		cout<<dist[0];

	return 0;
}

```

       


---

## 作者：Drifterming (赞：7)

```
//。。。。
//竟然是个状压DP
//....还是spfa转移
//太菜了

//因为最多只有20个补丁，所以我们可以开一个1<<20的数组来记录每个病毒的状态
//一开始有n个病毒，也就是起始点是(1<<n)-1,目标点就是0，也就是一个病毒都没有
//我们记录每个补丁的b1,b2,f1,f2,
//如果这个补丁可以修复，那就b1[]和当前状态每一位|1之后还是n，和b2[] & 之后==0 
//然后产生的影响就是f1[]中的位=0，f2[]中的位=1 

//。。。修复和添加错误的时候不能用减法。。。
//因为修复的错误可能当前状态里没有，或者添加的错误当前状态已经有了
//可以让f1和now & 一下=tmp，找出哪些病毒是这个补丁可以修复的，然后再让now^=tmp，这样就把修复的病毒变成了0 
//添加病毒的话直接让now|=f2就可以了 

//....还是不对，40分了，多得了20分。。。
//judge函数里要加括号。。
//优先级真tnd 

 

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

const int N=21;
const int M=105;

int n,m,S;
int tim[M];
int b1[M],b2[M],f1[M],f2[M];
int dis[1<<N];
bool vis[1<<N];

bool judge(int sta,int id)
{
	if((b1[id]|sta)!=sta)
		return false;
	if(b2[id]&sta)
		return false;
	return true;
}

void spfa()
{
	memset(dis,0x3f,sizeof(dis));
	queue<int> que;
	que.push(S),dis[S]=0;
	int now,x;
	while(!que.empty())
	{
		now=que.front(),que.pop();
		for(int i=1;i<=m;++i)
		{
			if(!judge(now,i))
				continue;
			x=now^(now&f1[i]);
			x|=f2[i];
			if(dis[x]>dis[now]+tim[i])
			{
				dis[x]=dis[now]+tim[i];
				if(!vis[x])
				{
					que.push(x);
					vis[x]=1;
				}
			}
		}
		vis[now]=0;
	}
}

char s[M];
int main()
{
	scanf("%d%d",&n,&m);
	S=1<<n,--S;
	for(int i=1;i<=m;++i)
	{
		scanf("%d",tim+i);
		scanf("%s",s);
		for(int j=0;j<n;++j)
		{
			if(s[j]=='+')	//1<<j就是第几个错误，+=就是把那位变成1 
				b1[i]+=1<<j;
			else if(s[j]=='-')
				b2[i]+=1<<j;
		}
		scanf("%s",s);
		for(int j=0;j<n;++j)
		{
			if(s[j]=='-')
				f1[i]+=1<<j;
			else if(s[j]=='+')
				f2[i]+=1<<j;
		}
	}
	spfa();
	if(dis[0]==0x3f3f3f3f)
		printf("0");
	else
		printf("%d",dis[0]);
	return 0;
}
```

---

## 作者：Lonely_NewYear (赞：6)

# 洛谷P2761题解

## 题目大意

有 n 个 bug，m 个补丁，每个补丁可以用当且仅当目前包含所有在集合 B1 中的 bug 而且不包含任意的在集合 B2 中的 bug，使用后可以把集合 F1 中的 bug 修好，并新增集合 F2 的 bug。每个补丁有个用时，求最短的修复所有 bug 的 时间。

## 题目分析

看到**如此小的数据范围**和 bug 的状态只有**修复和未修复**，这题九成就是用的状态压缩了。

### first，什么是状态压缩？

状态压缩能把很多维的状态压缩成一个，举个例子：

有一个五个维度的数组 f[2][2][2][2][2]，每一位都是0和1。这样处理时会很麻烦，需要细细考虑每一维状态。等一下，0和1？这不就是二进制吗？于是就考虑把每一维都转化成一个二进制上的一位。比如 f[1][0][1][0][0] 这个状态，就可以转化成 f[2^4+2^2] = f[20]。这就是状态压缩。

最后这个数组会被压缩成一个一维数组 f[32]。

在题目中就可以把每一个 bug 当做一个状态并压缩成一个数 S。

压缩完后如何处理每个补丁包能否使用和使用后的状态呢？

- 如何判断能否使用

1. 只要 B1 有的，都必须有：(S&B1)==B1。

1. 只要 B2 有的，都不能有：(S&B2)==0。

(S&B1)==B1&&(S&B2)==0

- 使用后是什么状态

1. 消灭掉 F1 有的 考虑到无论这个 bug 还在不在，最后都一定不在，为了方便处理，把 F1 内的 bug 加上：S|F1。再把 F1 内的 bug 全部消灭：(S|F1)^F1。

1. 加上 F2 有的：((S|F1)^F1)F2。

### second，压缩完状态后怎么做呢？

我们已经可以用补丁包在 bug 的状态中转化了，而且题目求的是最短时间。可以把 bug 的状态当做点，补丁包当做边，边权为所需时间，起点为 bug 全部存在，终点为 bug 全部消灭。跑一遍最短路即可。~~SPFA未死！~~

### third，代码

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
struct node//补丁包 
{
	int t,b1,b2,f1,f2;
}a[101];
int dis[1<<20],n,m;
void spfa()
{
	for(int i=0;i<(1<<n)-1;i++)
	{
		dis[i]=1e9;
	}
	queue<int> q;
	q.push((1<<n)-1);
	bool vis[1<<20]={0};
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=1;i<=m;i++)
		{
			int t=a[i].t,b1=a[i].b1,b2=a[i].b2,f1=a[i].f1,f2=a[i].f2;
			if((u&b1)==b1&&(u&b2)==0)//能否使用补丁包 
			{
				int v=((u|f1)^f1)|f2;//使用补丁包后的状态 
				if(dis[u]+t<dis[v])
				{
					dis[v]=dis[u]+t;
					if(!vis[v])
					{
						q.push(v);
						vis[v]=1;
					}
				}
			}
		}
	}
} 
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
	{
		int t,b1=0,b2=0,f1=0,f2=0;
		char b[21],f[21];
		scanf("%d%s%s",&t,b,f);
		for(int j=0;j<n;j++)//对B1,B2,F1,F2进行状态压缩 
		{
			b1*=2;
			b2*=2;
			f1*=2;
			f2*=2;
			if(b[j]=='+')
			{
				b1++;
			}
			if(b[j]=='-')
			{
				b2++;
			}
			if(f[j]=='-')
			{
				f1++;
			}
			if(f[j]=='+')
			{
				f2++;
			}
		}
		a[i]=(node){t,b1,b2,f1,f2};
	}
	spfa();//这题居然不卡SPFA 
	if(dis[0]==1e9)
	{
		printf("0");
	}
	else
	{
		printf("%d",dis[0]);
	}
	return 0;
}
```
到这里，这道题就被 AC 了。

谢谢观看。

---

## 作者：7KByte (赞：5)

标准最短路建模（不知道为什么放在网络流24）


-------------
以当前软件的错误情况为节点，以补丁为边跑最短路

- 对于节点的表示，我们进行二进制压缩，压缩后的整数，第$i$位为1表示有第$i$个错误，为0则没有该错误
 - $S=2^n-1$
 - $T=0$  
- 对于边
 - 起点要满足包含$b1$而不包含$b2$,即$b1    \ \ and\ \ x=b1$和$b2\ \ and \ \ x=0$
 - 此时终点为$((x\ \ or\ \ f1)\ \ xor\ \ f1)\ \ or\ \ f2$
- 最后跑最短路，$dijkstra$和$SPFA$都可以  
- 注意一下，因为边数过多，可能$>10^8$,所以我们不保存边，而是在松弛的同时在$m$个补丁中暴力枚举进行转移，详见代码的$SPFA$部分  


```cpp

//代码使用了大量位运算，不清楚可以在网上查阅相关资料
#include<bits/stdc++.h>
using namespace std;
int pop=0,n,m,s,t;
int v[4000000],d[4000000];
queue<int>q;
int b1[1000],b2[1000],f1[1000],f2[1000],xx[1000];
void spfa(){
//初始化
    memset(v,0,sizeof(v));
    memset(d,0x7f,sizeof(d));
    d[s]=0;while(q.size())q.pop();
    q.push(s);
    while(q.size()){
        int x=q.front(),y;q.pop();
        v[x]=0;
        for(int i=1;i<=m;i++){ 
        //枚举补丁
            if((b1[i]&x)==b1[i]&&(b2[i]&x)==0){
            //判断当前节点是否可以做为起点
            	y=((x|f1[i])^f1[i])|f2[i];
                //求出终点
                if(d[x]+xx[i]<d[y]){
                  //spfa的松弛操作
                	d[y]=d[x]+xx[i];
                	if(!v[y]){
                		v[y]=1;
                		q.push(y);
                    }
                }
            }
        }
    }
    printf("%d\n",d[t]==0x7f7f7f7f?0:d[t]);
}
int main()
{
    scanf("%d%d",&n,&m);
    t=0;s=(1<<n)-1;
    char a[1000],b[1000];
    for(int i=1;i<=m;i++){   
    //预处理出每个补丁对应的b1,b2,f1,f2
        scanf("%d%s%s",&xx[i],a,b);
        b1[i]=b2[i]=f1[i]=f2[i]=0;
        for(int j=0;j<n;j++){
            if(a[j]=='+')
              b1[i]|=(1<<j);
            if(a[j]=='-')
              b2[i]|=(1<<j);
            if(b[j]=='+')
              f2[i]|=(1<<j);
            if(b[j]=='-')
              f1[i]|=(1<<j);
        }
    }
    spfa();
    return 0;
}

```

---

## 作者：清平乐 (赞：3)

看了下大部分大佬题解都是用的SPFA

其实可以用一下裸的广搜（注意要用优先队列）+状态压缩

# 预备知识
## 位运算

按位与	&	：全一则一，否则为零

按位或	|	：有一则一，否则为零

按位取反	~：	是零则一，是一则零

按位异或	^	：不同则一，相同则零

移位	>>和<<	：向右、向左移位


------------
## 常用运算

集合取并(Set union)
A | B

集合取交(Set intersection)
A & B

集合相减(Set subtraction)
A & ~B

集合取反(Set negation)
^ A

置位(Set bit)
A |= 1 << bit//减不减一看实际情况

清位(Clear bit)
A &= ~(1 << bit)

测位(Test bit)
(A & (1 << bit)) != 0 或者 
(A >> bit & 1) != 0



------------

## 其它运算
取最后一个非0位(Extracting every last bit)
```cpp
A & -A 或者
A & ~(A-1)
```


统计非0位(Counting out the bits)
```cpp
For (; A; A -= A & -A) ++cnt;
```

取所有子集(All the subsets)
```cpp
X = A
While (X) X = (X - 1) & A
```


~~这个题关系好复杂呀，一定要打注释，免得混淆QAQ~~
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
char a;
int t[100+5],b1[1<<20],b2[1<<20],f1[1<<20],f2[1<<20];//t表示时间，b1,b2,f1,f2如题
bool visit[1<<20];
struct node{
	int now,step;//now表示当前状态，step表示用时
    bool operator < (const node &a) const {  
        return step>a.step;//最小值优先（重载运算符，在优先对列中按照step（时间）排序）
    }  
}start;

void BFS()
{
	priority_queue<node> q;
	q.push(start);
	while(!q.empty())
	{
		node k=q.top();
		q.pop();
		if(k.now==0)
		{
			printf("%d\n",k.step);
			return;
		}
		if(visit[k.now]) continue;//重复的状态没有意义
		visit[k.now]=true;
		for(int i=1;i<=m;i++)
		{
			if( (k.now|b1[i])!=k.now || (k.now&~b2[i])!=k.now ) continue;
			node newn=k;
			newn.now&=(~f1[i]);
			newn.now|=f2[i];
			newn.step+=t[i];//各种花里胡哨的位运算，如题意，好好理解
			q.push(newn);
		}
	}
	printf("0\n");//队列空了还没有结果状态，那就无解
	return;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",t+i);
		scanf(" ");
		for(int j=1;j<=n;j++)
		{
			scanf("%c",&a);
			if(a=='+') b1[i]|=(1<<(j-1));//仅当软件包含 B1[i]中的所有错误
			else if(a=='-') b2[i]|=(1<<(j-1));//而不包含 B2[i]中的任何错误时，才可以使用补丁 i
		}
		scanf(" ");
		for(int j=1;j<=n;j++)
		{
			scanf("%c",&a);
			if(a=='-') f1[i]|=(1<<(j-1));//补丁 i 将修复软件中的某些错误 F1[i]
			else if(a=='+') f2[i]|=(1<<(j-1));//而同时加入另一些错误 F2[i]（建议打个注释，免得把自己绕晕了）
		}
	}
	start.now=(1<<n)-1;
	start.step=0;
	BFS();
	return 0;
}
```
 _**********~~（！！！！！！！！！！！SPFA已死！！！！！！！！！！）~~**********_ 

---

## 作者：Hongse_Fox (赞：3)

# 不要被标签给骗了！！
### 这其实就是一道状压dp的题目

当我们看到n的数据范围是1~20的时候，自然而然就想到了用一个20位的二进制数来表示某个情况的状态

而我们再定睛一看，要求耗时最少的方案，而且每一个补丁的时间都是不一样的，那我们就可以肯定，要用最短路转移状态
dij和spfa好像都是可以的 ~~如果你想用floyd的话我也不阻止你~~

不妨用1来表示有bug，0表示木得bug

那么一开始的时候，这个程序应该全都是bug，也就是111....11，而我们是想要让这个程序完全没有Bug，也就是000....00，这样我们就确定了起点和终点

我们在输入每一个补丁的时候，都可以枚举每一种状态（一个for循环，从000...到111...）能否使用这个补丁

具体方法详见代码

如果可以用的话再算出使用补丁后的状态，连一条边，长度即为补丁的耗时

在连完所有的边以后，就可以跑一遍最短路，算出最短用时了

上代码：
```cpp
#include<cstdio>
#include<cctype>
#include<queue>
using namespace std;
inline int R(){//快读 
    int r=0;char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
    return r;
}
struct hhhh{
    int num,dis;
    friend bool operator < (hhhh a,hhhh b){
        return a.dis>b.dis;
    }
};
priority_queue <hhhh> q;
struct node{
    int t,f1,f2,b1,b2;
}bd[101];//分别代表着用时，题目中的f1,f2,b1,b2 
bool visit[1048575];
int n,m,s,dis[1048575],e;
inline void dijkstra(int start){//dij
    hhhh hhh;
    for(int i=0;i<=s;i++) dis[i]=0x7fffffff;
    hhh.dis=0;hhh.num=start;
    q.push(hhh);
    dis[start]=0;
    while(!q.empty()){
        hhhh u=q.top();
        q.pop();
        if(visit[u.num]) continue;
        visit[u.num]=true;
        for(int i=1;i<=m;i++){
            if(((u.num^(bd[i].b1))&bd[i].b1) || (u.num&bd[i].b2)) continue;
            int k=u.num;
            k=(k^bd[i].f1)&k;
            k=k|bd[i].f2;
            if(dis[k]>dis[u.num]+bd[i].t){
                dis[k]=dis[u.num]+bd[i].t;
                if(!visit[k]){
                    hhh.dis=dis[k];
                    hhh.num=k;
                    q.push(hhh);
                }
            }
        }
        visit[u.num]=false;
    }
    return ;
}
int main(){
    n=R();m=R();
    for(int i=0;i<n;i++)
    s+=(1<<i);
    for(int i=1;i<=m;i++){
        bd[i].t=R();
        scanf(" ");
        for(int j=1;j<=n;j++){
            char c=getchar();
            bd[i].b1=bd[i].b1*2+(c=='+');
            bd[i].b2=bd[i].b2*2+(c=='-');
        }
        scanf(" ");
        for(int j=1;j<=n;j++){
            char c=getchar();
            bd[i].f1=bd[i].f1*2+(c=='-');
            bd[i].f2=bd[i].f2*2+(c=='+');
        }
    }
    dijkstra(s);
    if(dis[e]==0x7fffffff) printf("0");
    else printf("%d",dis[e]);
    return 0;
}
```
值得注意的是，在判断能否使用的时候不要使用!，换成异或吧，因为它不会在开头补1 ~~在这里卡了半天~~

最后祝愿大家 ~~轻松~~ ac

---

## 作者：Bartholomew (赞：2)

##By Bartholomew

----

##题意:
对于每一个软件,有特定的使用方法,简单来说,就是
**软件只有必须有某些漏洞但是有没有某一些漏洞的时候才会有用**
**在使用补丁的同时,会消去某一些漏洞,但是同时也会引入某些漏洞**
**一开始有 n 个漏洞**
输入的是 $n$ 和 $m$ ,就是有$m$个补丁(每个补丁可以重复使用)
每 $m$ 行会有$2$个字符串:
第 1 个字符串中，如果第 k 个字符 $b_k$ 为“+”，则表示第 k 个错误属于 $B1[i]$，若为“-”，则表示第 k 个错误属于 $B21[i]$，若为“0”，则第 $k$个错误既不属于 $B1[i]$也不属于 $B2[i]$，即软件中是否包含第 $k$ 个错误并不影响补丁 $i$ 的可用性。

第 2 个字符串中，如果第 k 个字符 $b_k$为“-”，则表示第 k 个错误属于 $F1[i]$，若为“+”，则表示第 k 个错误属于 $F2[i]$，若为“0”，则第 $k$ 个错误既不属于 $F1[i]$也不属于 $F2[i]$，即软件中是否包含第 $k$ 个错误不会因使用补丁$i$ 而改变。
##分析:
其实这道题我不知道为什么$是网络流 24 题,其实就是状态压缩DP$
$我们用 mark 表示01分别表示是否还有病毒,而dp[mark] 表示 最小代价!$
那么这道题好像有后效性,那么我们可以用$SPFA$来跑

###位运算:
考验大家的其实就是位运算的能力:
我们有一个 
mask_have[i]:=表示必须有哪一些病毒
mask_not[i]:=表示必须没有那些病毒
那么我们判断只要 
这样:

```
// "~" 就是取反的标记,即二进制的 0 -> 1 , 1 -> 0
if((mask_not[i] & (~stand)) != mask_not[i]) continue;
if((mask_have[i] & stand ) != mask_have[i]) continue;
```


##代码:

```
#pragma GCC optimize(3)
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <queue>
#define N 25
#define M 115
#define INF 0x3f3f3f3f
#define P pair<int,int>
using namespace std;

int n, m, a[M], b[M], c[M], dp[1 << (N - 2)], mask_have[M], mask_not[M];
int vis[1 << (N - 2)], kill[M], bring[M];
char s1[M][N], s2[M][N];
std::queue<P> G;

inline void init(int x)
{
    for(register int i = n - 1; i >= 0; --i)
    {
        switch(s1[x][i])
        {
        	case '+': mask_have[x] |= 1 << i; break;
        	case '-': mask_not[x] |= 1 << i; break;
        }
        switch(s2[x][i])
        {
         	case '+': bring[x] |= 1 << i; break;
        	case '-': kill[x] |= 1 << i; break;
        }
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    memset(b, 0, sizeof b);
    memset(c, 0, sizeof c);
    for(register int i = 1; i <= m; ++i)
    {
        scanf("%d%s%s", a + i, s1[i], s2[i]);
        init(i);
    }
    memset(dp, INF , sizeof dp);
    dp[(1 << n) - 1] = 0; vis[(1 << n) - 1] =  1;
    G.push(P( (1 << n) - 1 , 0)); 
    while( !G.empty() )
    {
        P now = G.front(); G.pop();
        int stand = now.first;
        vis[stand] = 0;
        for(register int i = 1; i <= m; ++i)
        {
        	if((mask_not[i] & (~stand)) != mask_not[i]) continue;
        	if((mask_have[i] & stand ) != mask_have[i]) continue;
        	int to = (stand & (~kill[i])) | bring[i];
        	if(dp[to] <= dp[stand] + a[i]) continue;
        	dp[to] = dp[stand] + a[i];
        	if(!vis[to]) 
        	{
        		vis[to] = true;
        		G.push(P(to , dp[to]));
        	} 
        }
    }
    printf("%d\n", dp[0] == INF ? 0 : dp[0]);
    return 0;
}
```

---

## 作者：FREEH (赞：2)

### 【题目大意】
- 有n个漏洞，有m个补丁，每个补丁有使用的要求，而且还有使用后会增加一些漏洞或减少一些漏洞。
- **n<=20**

### 【解题思路】
- 看看数据范围就知道本题与网络流没有太大关系。。。
- 使用状态压缩，把每个漏洞的情况压缩成二进制。
- 跑SPFA，注意是否符合使用要求，然后求出打补丁后的状态。注意：
	1. 要判断去掉的漏洞是否本来就不存在
    1. 要判断增加的漏洞是否本来就存在

### 【参考程序】
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;

#define INF 0x3f3f3f3f
#define st (((1<<n)-1))
const int MAX=(1<<20)+10;
int dis[MAX],t[105];
int n,m;
bool vis[MAX],b1[105][25],b2[105][25],f1[105][25],f2[105][25];
queue < int > q;
void SPFA()
{
	memset(dis,INF,sizeof dis);
	dis[st]=0;
	q.push(st);
	while (!q.empty())
	{
		int u=q.front();q.pop();
		vis[u]=false;
		for (int i=1;i<=m;i++)
		{
			int OK=true;
			for (int j=0;j<n;j++)
				if (((u&(1<<j))&&b2[i][j]) || (!(u&(1<<j)))&&b1[i][j])
				{
					OK=false;
					break;
				}
			if (!OK) continue;
			int v=u;
			for (int j=0;j<n;j++)
				if (f1[i][j])
					v-=v&(1<<j);//判断漏洞是否存在
				else
				if (f2[i][j])
					v|=(1<<j);//判断漏洞是否存在
			if (dis[u]+t[i]<dis[v])
			{
				dis[v]=dis[u]+t[i];
				if (!vis[v])
				{
					q.push(v);
					vis[v]=true;
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		char a[105],b[105];
		scanf("%d%s%s",&t[i],a,b);
		for (int j=0;j<n;j++)
		{
			if (a[j]=='+')
				b1[i][j]=1;
			else
			if (a[j]=='-')
				b2[i][j]=1;
			
			if (b[j]=='-')
				f1[i][j]=1;
			else
			if (b[j]=='+')
				f2[i][j]=1;
		}
	}
	SPFA();
	printf("%d",dis[0]==INF?0:dis[0]);
	return 0;
}
```

---

## 作者：万万没想到 (赞：1)

[题目传送门：P2761软件补丁问题](https://www.luogu.com.cn/problem/P2761)

题意简化：

对于一个n个元素的数组，初始状态为1。

共有m种操作，对于第i种操作需要满足关于B1[ i ]的元素 都为1，关于B2[ i ]的元素 都为0，那么就可以将当前数组里所有的关于F1[ i ]的元素变为0，F2[ i ]变为1，对于每种操作的代价为t[ i ]。

询问将初始状态全变成0的最少步骤操作数。

通过题目描述中的最少操作数，和题目中对状态变化的描述，我们可以知道：对于每一种状态（初始状态除外），都必定由某一种状态转化而来，而由于题目的转化条件各不相同，所以无法采用DP的方程来计算，那么还有什么可以快速求出状态转化的最小代价算法吗？

所以我们找到了最短路算法，对于每一种状态，就可以将其当做一个图中的结点，对于每一种操作，当做一条边，那么状态数就是结点数，也就是2²º种状态，由于每种操作可以有无数次，所以对于每一个结点，都有m条以其延伸出的边。

我们在这里使用Dijkstra的堆优化，再算上对于每一个数组元素和边数的模拟，由于需要满足题目中的限制条件（算的不好请见谅），所以将m忽略掉，那么时间复杂度就大约是O（（2ⁿ）*n*log（2ⁿ））=O（2ⁿ*n²），这很明显是会超时。

由于每一个元素只有0和1，并且n<=20，所以我们将每一位压成一个十进制表示的二进制数，时间复杂度就是O（2ⁿ*n），可以通过本题。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cost[105],b1[105],b2[105],f1[105],f2[105],len,dis[1050005];
bool vis[1050005];
string tempa,tempb;
struct node{
	int siz,num;
	bool operator <(const node&x)const{
		return x.num<num;
	}
};
inline void Dijkstra(){
	priority_queue<node>Q;
	Q.push((node){len,0});
	dis[len]=0;
	while(!Q.empty()){
		node temp=Q.top();
		Q.pop();
		int x=temp.siz,tempp=0;
		if(vis[x])continue;
		vis[x]=true;
		for(register int i=1;i<=m;++i){
			if((x&b1[i])==b1[i]&&!(x&b2[i])){
				tempp=(((x|f1[i])^f1[i])|f2[i]);
				if(dis[tempp]>dis[x]+cost[i]){
					dis[tempp]=dis[x]+cost[i];
					if(!vis[tempp]){
						Q.push((node){tempp,dis[tempp]});
					}
				}
			}
		}
	}
	if(dis[0]!=dis[1050000])cout<<dis[0]<<endl;
	else cout<<0<<endl;
}
int main(){
	cin>>n>>m;
	for(register int i=1;i<=m;++i){
		cin>>cost[i]>>tempa>>tempb;
		for(register int j=0;j<n;++j){
			if(tempa[j]=='+')b1[i]=b1[i]+(1<<(n-j-1));
			else if(tempa[j]=='-')b2[i]=b2[i]+(1<<(n-j-1));
			if(tempb[j]=='-')f1[i]=f1[i]+(1<<(n-j-1));
			else if(tempb[j]=='+')f2[i]=f2[i]+(1<<(n-j-1));
		}
	}
	len=(1<<n)-1;
	memset(dis,0x3f,sizeof(dis));
	Dijkstra();
	return 0;
}
```


---

## 作者：Memorize (赞：1)

好吧 其实这道题不算网络流吧...

首先我们可以看到数据很小 于是可以状态压缩 0表示正确 1表示错误

于是我们可以通过二进制进行判断和转移 由于有环 所以不能用dp 用是spfa即可




```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#define in unsigned int 
using namespace std;
int n,m,t,qhead,qtail,fr,ed;
int queue[5000100],dis[2000100];
char s1[300],s2[300];
bool vis[2000100];
struct node{
    in b1,b2,f1,f2;
    int t;
}e[300];
void spfa()
{
    memset(vis,false,sizeof(vis));
    memset(dis,0x7f7f7f,sizeof(dis));
    qhead=qtail=dis[fr]=0;
    queue[++qtail]=fr;vis[fr]=true;
    while(qhead<qtail)
    {
        int p=queue[++qhead];vis[p]=false;
        for(int i=1;i<=m;i++)//直接建边存不下 所以就直接枚举所有情况了 
        {
            in b1=e[i].b1;in b2=e[i].b2;
            in f1=e[i].f1;in f2=e[i].f2;
            //int x=(p&(~f1))|f2; 
            int x=p^(f1&p)|f2;
            if(b1==(b1&p) && !(b2&p))
            if(dis[x]>dis[p]+e[i].t)
            {
                dis[x]=dis[p]+e[i].t;
                if(!vis[x]) queue[++qtail]=x,vis[x]=true;
            }        
        }
    }
    if(dis[ed]==dis[fr+1]) printf("0");
    else printf("%d",dis[ed]);
}
int main()
{
    scanf("%d%d",&n,&m);fr=(1<<n)-1,ed=0;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%s%s",&t,s1,s2);e[i].t=t;
        for(int k=0;k<n;k++)
        {
            if(s1[k]=='+') e[i].b1=e[i].b1|(1<<k);
            if(s1[k]=='-') e[i].b2=e[i].b2|(1<<k);
        }
        for(int k=0;k<n;k++)
        {
            if(s2[k]=='-') e[i].f1=e[i].f1|(1<<k);
            if(s2[k]=='+') e[i].f2=e[i].f2|(1<<k);
        }
    }
    spfa();
    return 0;
}
```

---

## 作者：cxy004 (赞：1)

SPFA+位运算

卧槽我位运算调试了半天

以下内容请自行理解，看不懂请补广搜、图论和基础位运算

首先，

```cpp
   1 1 0 0
   1 0 1 0

B+ 0 0 1 0  //即2  //原1 1 0 1，无法用二进制实现，所以位反
B- 1 0 0 0  //即8  //原0 1 1 1，无法用二进制实现，所以位反

F+ 1 1 1 0  //即14
F- 0 1 0 0  //即4
```
然后，

```cpp
//广搜求位运算
#include<cstdio>
using namespace std;

int f[16],q[16]={12};
char g[16];

void d(int t) {if(f[t]!=12) d(f[t]);putchar(g[t]);}

int main()
{
    for(int a=0,b=1,t;a<b;++a)
    {
      t=q[a]&10;if(!f[t]) {g[t]='&';f[q[b++]=t]=q[a];}
      t=q[a]|10;if(!f[t]) {g[t]='|';f[q[b++]=t]=q[a];}
      t=q[a]^10;if(!f[t]) {g[t]='^';f[q[b++]=t]=q[a];}
    }
    d(2);putchar(10);
    d(8);putchar(10);
    d(14);putchar(10);
    d(4);putchar(10);
    return 0;
}
/*
结果：
&^  //B+  //and xor
&   //B-  //and
|   //F+  //or
|^  //F-  //or  xor
*/
```
最后，

```cpp
#include<cstdio>
using namespace std;

int n,m,p[100],bp[100],bq[100],fp[100],fq[100],q[32769],l[32768],r;

int main()
{
    scanf("%d%d",&n,&m);q[0]=r=(1<<n)-1;l[r]=1;
    for(int i=0;i<m;++i)
    {
      scanf("%d ",p+i);bp[i]=bq[i]=r;
      for(int j=0;j<n;++j)
      {
        char ch=getchar();
        if(ch=='+') bp[i]-=1<<j;else if(ch=='-') bq[i]-=1<<j;
      }
      getchar();
      for(int j=0;j<n;++j)
      {
        char ch=getchar();
        if(ch=='+') fp[i]+=1<<j;else if(ch=='-') fq[i]+=1<<j;
      }
    }
    for(int f1=0,f2=1;f1!=f2;++f1)
      for(int i=0;i<m;++i)
        if(((q[f1]&bp[i]^bp[i])|(q[f1]&bq[i]))==r)
        {
          q[f2]=(q[f1]|fq[i])^fq[i]|fp[i];
          if((!l[q[f2]])||((l[q[f1]]+p[i])<l[q[f2]])) {l[q[f2]]=l[q[f1]]+p[i];++f2;}
        }
    printf("%d",l[0]?(l[0]-1):0);
    return 0;
}
```

---

## 作者：英明神武的熊 (赞：1)

```delphi
const nn=1048576; mm=100000;  
var a,b,c,d,t,r:array[0..100] of longint;  
    i,m,n,tot:longint;  
    g:array[0..nn] of longint;  
    p,t1:array[0..mm] of longint;  
  
    procedure readin;  
      var i,j:longint;  
          ch:char;  
          st:string;  
        begin  
            readln(n,m);  
            r[0]:=1;  
            for i:=1 to n do r[i]:=r[i-1]*2;  
            for i:=1 to m do  
              begin  
                read(t[i]);  
                st:='';  
                ch:=' ';  
                while ch=' ' do read(ch);  
                st:=st+ch;  
                for j:=1 to n-1 do  
                  begin  
                    read(ch);  
                    st:=st+ch;  
                  end;  
                for j:=1 to n do  
                  begin  
                    if st[j]='+' then a[i]:=a[i]+r[n-j];  
                    if st[j]='0' then b[i]:=b[i]+r[n-j];  
                  end;  
  
                st:='';  
                ch:=' ';  
                while ch=' ' do read(ch);  
                st:=st+ch;  
                for j:=1 to n-1 do  
                  begin  
                    read(ch);  
                    st:=st+ch;  
                  end;  
                for j:=1 to n do  
                 begin  
                   if st[j]='+' then c[i]:=c[i]+r[n-j];  
                   if st[j]<>'-' then d[i]:=d[i]+r[n-j];  
                 end;  
                readln;  
              end;  
        end;  
  
    procedure  work;  
     var i,j,x:longint;  
         k:integer;  
  
     begin  
       x:=r[n]-1; p[0]:=x;  
       i:=0; j:=0;  
         while i<=j do  
           begin  
             for k:=1 to m do  
             if ((a[k] xor p[i]) and b[k])=(a[k] xor p[i])  then  
               begin  
                 x:=(p[i] or c[k]) and d[k];  
                 if (g[x]=0) or (g[x]>t[k]+t1[i]) then  
                   begin  
                     inc(j);  
                     p[j]:=x;  
                     g[x]:=t[k]+t1[i];  
                     t1[j]:=g[x];  
                   end  
               end;  
             inc(i);  
           end;  
     end;  
  
    procedure writein;  
      begin  
        if g[0]<>0 then writeln(g[0]) else writeln(0);  
  
      end;  
  
    begin  
      readin;  
      work;  
      writein;  
    end. 
```

---

## 作者：wenake (赞：0)

考虑N<=15,显然可以二进制储存状态，把它们做成单元图跑最短路

需要注意三种位运算及其优先级

而且不必要按照先建图，再跑最短路的一般想法

可以边建图边松弛


                    
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,head,tail;
struct node{
    int yes,no,del,add,cost;
}patch[101];
int st[100000],dist[100000];
bool visit[100000];
int main()
{
    scanf("%d%d",&n,&m);
    for(int j=1;j<=m;j++)
    {
        char str1[20],str2[20];
        scanf("%d%s%s",&patch[j].cost,str1,str2);
        for(int i=0;i<n;i++)
        {
            if(str1[i]=='+') patch[j].yes^=(1<<(n-i-1));
            if(str1[i]=='-') patch[j].no^=(1<<(n-i-1));
            if(str2[i]=='+') patch[j].add^=(1<<(n-i-1));
            if(str2[i]=='-') patch[j].del^=(1<<(n-i-1));
        }
    }
    memset(dist,0x7f7f7f7f,sizeof(dist));
    st[++tail]=(1<<n)-1;
    visit[(1<<n)-1]=1;
    dist[st[tail]]=0;
    while(head<tail)
    {
        int now=st[++head];
        //visit[now]=0;//此处想一想注释的原因
        for(int i=1;i<=m;i++)
        {
                //if((now&patch[i].no==0)&&(now&patch[i].yes==patch[i].yes))//魔性部分 ，与转存abc要表达的意思一直，但是进不了if
            int a=now&patch[i].no;
            int b=now&patch[i].yes;
            int c=patch[i].yes;    
            if((a==0)&&(b==c))
            {
                st[++tail]=(((now|patch[i].del)^patch[i].del)|patch[i].add);
                if(visit[st[tail]])
                {
                    if(dist[now]+patch[i].cost<dist[st[tail]])
                    {
                        dist[st[tail]]=dist[now]+patch[i].cost;
                    }
                    else
                    {
                        tail--;
                    }
                }
                else
                {
                    dist[st[tail]]=dist[now]+patch[i].cost;
                    visit[st[tail]]=1;
                }
            }
        }
    }
    if(dist[0]==0x7f7f7f7f) dist[0]=0;
    printf("%d\n",dist[0]);
    return 0;
}
```

---

## 作者：q234rty (赞：0)

这题不难的w.用二进制保存状态，每读入一组数据，对于每一种状态利用位运算计算出它能否转移,能转移到什么状态，然后堆优化dijkstra/spfa就可以了w.

```cpp

#include <algorithm>  
#include <vector>  
#include <queue>  
#include <iostream>  
#include <cstring>  
#include <stack>  
#define show(x) cout << #x << '=' << x << '\n';  
using namespace std;  
typedef int ll;  //no need to use long long
const ll INF=0x3f3f3f3f;  
const int maxn = (1 << 15) + 10;  
struct edge{  
    int from,to;  
    int dist;  
    int next;  
};  
struct heapnode{  
    ll d,u;  
    bool operator < (const heapnode rhs) const{  
        return d>rhs.d;  
    }  
};  
struct graph{  
    ll n,m;  
    edge* e;  
    ll* first;  
    ll* d;  
    ll* p;  
    bool* done;  
    void init(ll n){  
        this->n=n;  
        m=0;  
        e=new edge[maxn*100];  
        first=new ll[maxn];  
        d=new ll[maxn];  
        p=new ll[maxn];  
        done=new bool[maxn];  
        memset(first,-1,maxn*sizeof(ll));  
    }  
    void addedge(ll from,ll to,ll dist){  
        e[++m]=(edge){from,to,dist,first[from]};  
        first[from]=m;  
    }  
    void dijkstra(ll s){  
        priority_queue<heapnode> q;  
        memset(d,0x3f,maxn*sizeof(ll));  
        d[s]=0;  
        memset(done,0,maxn*sizeof(bool));  
        memset(p,0,maxn*sizeof(ll));  
        q.push((heapnode){0,s});  
        while(!q.empty()){  
            ll u=q.top().u;  
            q.pop();  
            if (done[u])  
                continue;  
            done[u]=true;  
            //prllf("u=%d\n",u);  
            ll i=first[u];  
            while (i!=-1){  
                if (d[u]+e[i].dist<d[e[i].to]){  
                    d[e[i].to]=d[u]+e[i].dist;  
                    p[e[i].to]=u;  
                    q.push((heapnode){d[e[i].to],e[i].to});  
                }  
                i=e[i].next;  
            }  
        }  
    }  
    void printstp(ll u,ll v){  
        dijkstra(u);  
        //prllf("dijkstra ended\n");  
        if (!p[v]){  
            printf("-1");  
            return;  
        }  
        stack<ll> stp;  
        ll t=v;  
        while (t!=0){  
            stp.push(t);  
            t=p[t];  
        }  
        while (!stp.empty()){  
            printf("%I64d ",stp.top());  
            stp.pop();  
        }  
    }  
};  
int main(){  
    graph* solver=new graph;  
    int n,m,i,j,k;  
    cin >> n >> m;  
    solver->init(1 << n);  
    for(i=1;i<=m;i++){  
        char a[16],b[16];  
        int dis;  
        cin >> dis;  
        for(j=0;j<n;j++){  
            cin >> a[j];  
        }  
        for(j=0;j<n;j++){  
            cin >> b[j];  
        }  
        //show(dis);  
        for(j=0;j<solver->n;j++){  
            int t=j;  
            int flag=1;  
            for(k=0;k<n;k++){  //check if we can apply this fix on this state
                switch (a[k]){  
                    case '0':continue;  
                    case '+':flag=j&(1 << k);break;  
                    case '-':flag=!(j&(1 << k));break;  
                }  
                if(!flag)  
                    break;  
            }  
            if (!flag)  
                continue;  
            for(k=0;k<n;k++){  //compute the state after applying
                switch (b[k]){  
                    case '0':continue;  
                    case '+':t=t|(1 << k);break;  
                    case '-':t=t&(~(1 << k));break;  
                }  
            }  
            if (t==j)  
                continue;  
            //show(j);  
            //show(t);  
            solver->addedge(j,t,dis);  
        }  
    }  
    solver->dijkstra(solver->n-1);  
    if(solver->d[0]>=INF)  
        cout << 0;  
    else  
        cout << solver->d[0];  
}  

```

---

## 作者：L_M_ (赞：0)

哪里是什么网络流啊...分明是状压加最短路

看数据范围：n <= 20，想到把每种修复状态转换成二进制，作为最短路的状态，将补丁作为边，跑最短路即可

看到下面几篇题解判断合法的方式都是逐位找，我觉得这样有点儿麻烦，我的意见如下：

对于当前状态u，判断u是否包含b1[i] : u & b1[i] == b1[i]

				u是否不包含b2[i] : u & b2[i] == 0
                
                u -> v: v = ((u | f1[i]) ^ f1[i]) | f2[i]
 
 ```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int maxn = 20;
const int maxm = 105;
inline int read()
{
  int ans = 0,op = 1;
  char ch = getchar();
  while(ch < '0' || ch > '9')
    {
      if(ch == '-') op = -1;
      ch = getchar();
    }
  while(ch >= '0' && ch <= '9')
    {
      (ans *= 10) += ch - '0';
      ch = getchar();
    }
  return ans * op;
}
int n,m;
int dis[1 << maxn];
bool vis[1 << maxn];
int b1[maxm],b2[maxm],f1[maxm],f2[maxm],a[maxm];
void spfa()
{
  memset(dis,0x3f,sizeof(dis));
  queue<int> q;
  q.push((1 << n) - 1);
  dis[(1 << n) - 1] = 0;
  while(q.size())
     {
      int u = q.front();
      q.pop();
      vis[u] = 0;
      for(int i = 1;i <= m;i++)
	{
	  if((b1[i] & u) != b1[i] || b2[i] & u) continue;
	  int v = ((u | f1[i]) ^ f1[i]) | f2[i];
	  if(dis[v] > dis[u] + a[i])
	    {
	      dis[v] = dis[u] + a[i];
	      if(!vis[v])
		{
		  vis[v] = 1;
		  q.push(v);
		}
	    }
	}
    }
}	        
int main()
{
  n = read(),m = read();
  for(int i = 1;i <= m;i++)
    {
      a[i] = read();
      char b[maxn + 5];
      scanf("%s",b + 1);
      for(int j = 1;j <= m;j++)
	{
	  if(b[j] == '+') b1[i] += 1 << (j - 1);
	  if(b[j] == '-') b2[i] += 1 << (j - 1);
	}
      scanf("%s",b + 1);
      for(int j = 1;j <= m;j++)
	{
	  if(b[j] == '+') f2[i] += 1 << (j - 1);
	  if(b[j] == '-') f1[i] += 1 << (j - 1);
	}
    }
  spfa();
  if(dis[0] != 0x3f3f3f3f) printf("%d",dis[0]);
  else printf("0");
}
```

---

## 作者：枫林晚 (赞：0)

2018年3月4日10:26:33
洛谷P2761
1.考虑到所有的错误只有“修复，未修复”两种情况，所以可以用0,1标记压缩状态，采用位运算减少时空浪费。
  又考虑到有修复时间的关系，将时间抽象成边，将状态抽象为点（设修复为0，未修复为1）最后从(1<<n)-1开始寻找到0的最短路，SPFA一边建图一边松弛即可。

2.实现过程中，难点在于对二进制表示，以及位运算组合判断的处理。
首先，状态要表示（见前）；
其次，补丁b，f要表示。
最初考虑用两个数来表示b，f，发现受“不动错误”影响，无法转移运算。故采用四个数记录，b+，b-，f+,f-。再推倒出位运算判断方式，以及转移方式即可。

最终位运算方式：
	判断：b+：（原状态~）&bp为0可以通过
    	  b-：&为0可以通过
    转移（更新）f+：|
    		  f-：（fj取反）&原状态

另：b+b-f+f-定义比较繁琐，利用草稿纸码上条件思路比较省事。

附代码：
```c
#include<bits/stdc++.h>
using namespace std;
int n,m;
int hd=1,tl=0;
int q[1050000];
bool vis[1050000];
int dis[1050000];
struct repair{
    int t;
    int bp,bj,fp,fj;
}bu[111];
int main()
{
    char kk[23];
    char h;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d ",&bu[i].t);
        for(int j=1;j<=n;j++)
        {
            h=getchar();
            if(h=='+') bu[i].bp+=1<<(n-j);
            if(h=='-') bu[i].bj+=1<<(n-j);
        }
        h=getchar();
        for(int j=1;j<=n;j++)
        {
            h=getchar();
            if(h=='+') bu[i].fp+=1<<(n-j);
            if(h=='-') bu[i].fj+=1<<(n-j);
        }
    }
    //for(int i=1;i<=m;i++)
     //cout<<bu[i].t<<" "<<bu[i].bp<<" "<<bu[i].bj<<" "<<bu[i].fp<<" "<<bu[i].fj<<endl;
    //cout<<endl; 
    q[++tl]=(1<<n)-1;
    memset(dis,0x3f3f3f3f,sizeof dis);
    dis[(1<<n)-1]=0;
    while(hd<=tl)
    {
        int zhuang=q[hd];hd++;vis[zhuang]=0;
        //cout<<zhuang<<" "<<dis[zhuang]<<endl;
        for(int i=1;i<=m;i++)
        {
            if(((~zhuang)&bu[i].bp)!=0) continue;
            if((zhuang&bu[i].bj)!=0) continue;
            //cout<<"panduan "<<i<<" && "<<zhuang<<" == "<<(zhuang&bu[i].bj)<<endl;
            int tt=(zhuang|bu[i].fp);
            tt=(tt&(~bu[i].fj));
            if(dis[tt]>dis[zhuang]+bu[i].t)
            {
                
                dis[tt]=dis[zhuang]+bu[i].t;
                //cout<<"gengxin  "<<i<<" -> "<<tt<<" "<<dis[tt]<<endl;
                if(!vis[tt])
                {
                    vis[tt]=1;
                    q[++tl]=tt;
                }			
            }
        }
    }
    if(dis[0]==0x3f3f3f3f) printf("0");
    else printf("%d",dis[0]);
    return 0;
}
```
总结：位运算一定要自己手动考虑，谁都可以看懂，但是有时候不容易想。

---


# [POI 2004] PRZ

## 题目背景

一只队伍在爬山时碰到了雪崩，他们在逃跑时遇到了一座桥，他们要尽快的过桥。

## 题目描述

 桥已经很旧了, 所以它不能承受太重的东西。任何时候队伍在桥上的人都不能超过一定的限制。 所以这只队伍过桥时只能分批过，当一组全部过去时，下一组才能接着过。队伍里每个人过桥都需要特定的时间，当一批队员过桥时时间应该算走得最慢的那一个，每个人也有特定的重量，我们想知道如何分批过桥能使总时间最少。

## 说明/提示

对于 $100\%$ 的数据，$100\le W \le400$ ，$1\le n\le 16$，$1\le t\le50$，$10\le w\le100$。

## 样例 #1

### 输入

```
100 3
24 60
10 40
18 50```

### 输出

```
42```

# 题解

## 作者：RedreamMer (赞：37)

[$\large{\texttt{P5911}}$](https://www.luogu.com.cn/problem/P5911)

题目标签：状压 $\texttt{DP}$ 

### Update 2020/11/1:

+ 感谢@[zgf519orz](https://www.luogu.com.cn/user/238875) @[yu__xuan](https://www.luogu.com.cn/user/142110) 指出状压代码中的错误

+ 感谢@[Alex_Wei](https://www.luogu.com.cn/user/123294) 指出了贪心做法的错误

$\large{\texttt{Solution}}$

### 1. 贪心

#### 此方法有误，数据也加强了，现在代码过不去

题目中各个数据都比较小，但是注意到 $n \le 16$ ，很明显出题人是想让我们用状压 $\texttt{DP}$ 来做这道题。~~我就不用~~

显然题目中说了，必须要让每一个人**都过桥**，并且每次过桥的时间为最慢的那个人的时间，因此所有人中越慢的人对答案的贡献就越大，为了避免这些大贡献的人贡献时间，那么我们就可以用贪心的套路，让那些最慢的人在一起过桥，最快的人一起过桥，这样可以让时间最小化。

#### 这种思路是错的，感谢Alex_Wei的hack数据：
```
Input:

10 4
20 8
15 9
10 1
5 2

Answer:
35
```

### 2. 状压DP

首先，$dp[i]$ 为状态为 $i$ 下，这些队员过桥最少要用的时间，再维护一下每个状态 $i$ 的总重量 $W$ 以及总时间 $T$ （指一次过桥的重量和时间，不管这个状态能否过桥）。

接着，顺序枚举状态 $i$ ，并枚举 $j$ ($j \in i$ )，将 $i$ 分为状态 $j$ 和状态 $i \oplus j$ ，意思就是 状态 $j$ 的一次过桥时间 $+$ 状态 $i$ 的最优过桥时间，注意状态 $j$ 的总重量要小于题目给定的 $w$ ，更新 $dp[i]$

$$dp[i] = \min (dp[i],T[j]+dp[i \oplus j] )(W[j] \le w)$$

$\large{\texttt{Code}}$

状压DP

1950 ms

```cpp
#include<bits/stdc++.h>
using namespace std;

//#define int long long
//#define PB push_back
const int N=16;
//const int M=110;

int a,b,t[N],w[N],T[1<<N],W[1<<N],dp[1<<N];


signed main() {
	scanf("%d%d",&a,&b);
	const int mx=(1<<b)-1;
	for(int i=1;i<=b;i++) scanf("%d%d",&t[i],&w[i]);
	for(int i=0;i<=mx;i++) {
		for(int j=1;j<=b;j++) {
			if(i&(1<<(j-1))) {
				T[i]=max(T[i],t[j]);//预处理出状态i的T和W
				W[i]+=w[j];
			}
		}
	}
	memset(dp,0x3f,sizeof dp);
	dp[0]=0;//初始化dp
	for(int i=0;i<=mx;i++) {
		for(int j=i;;j=i&(j-1)) {//这样就可以枚举完i的所有属于它的状态j，原理就不再多说了
			if(W[i^j]<=a) dp[i]=min(dp[i],dp[j]+T[i^j]);
			if(!j) break;
		}
	}
	printf("%d",dp[mx]);//dp[max]即为所求
	return 0;
}
```

[$\blue{\large{\texttt{My Blog}}}$](https://www.luogu.com.cn/blog/184549/)

---

## 作者：zxsure (赞：14)

## 状压DP枚举子集类例题

## 思路

首先数据不大，可以状压，那就将 $f[i]$ 表示 前 $i$ 个人过桥的最小时间，
通常我们可以设置一个断点 $j$, 只需要知道 $j$ 至 $i$ 之间所需要的时间即可，那么转移式有
$$
f[i] = min\{f[j]+mt[i\ xor\ j]\}
$$

其中 $i\ xor\ j$ 表示 $i$ 种剩余的子集， 前提是 $j$ 是 $i$ 的子集

这样题目就做完了

## 如何枚举子集
`for (s0=s;s0;s0=(s0-1)&s)` 依次枚举 $s$ 的子集

```c
  for （int s=0;s<=mx;s++)
   for （int s0=s;s0;s0=(s0-1)&s)
   
```
## 证明
我们枚举一下

当 $s=1010$ 此时 $s_0=1010$

减一得 $s_0=1001$

与$s$ 与得 $s_0=1000$

减一得 $s_0=0111$

与$s$ 与得 $s_0=0010$

减一得 $s_0=0001$

与$s$ 与得 $s_0=0000$

这样我们得到了集合 $s$ 的所有子集 $s_0$ 即$\{11,10,01,00\}$特别神

## 时间复杂度

那么**时间复杂度**是什么

$O(3^N)$

推导：对于有着 $k$ 个 $1$ 的二进制数字，枚举子集需要的时间复杂度为 $2^k$ ， 拥有 $k$ 个 $1$ 的数字的数量用组合数学可知：$\dbinom{n}{k}$

那么总的时间复杂度为：$\sum_{k=0}^nC(n,i)\times2^k$

这里给出二项式定理

$(x+y)^n=\sum_{k=0}^n\dbinom{n}{k}\times x^{(n-k)}\times y^k$

我们将这里的 $x$ 默认为 $1$， 则 $y$ 就等于 $2$

那么时间复杂度就为 $(1+3)^n=O(3^n)$

## Code
```c
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

const int A = 1e5 + 11;
const int B = 16;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int a,b,t[1<<B],w[1<<B],f[1<<B], mt[1<<B], mw[1<<B];

int main() {
//  freopen(".in", "r", stdin);
//  freopen(".out", "w", stdout);
  cin>>a>>b;
  int mx=(1<<b)-1;
  for (int i=1;i<=b;i++) cin>>t[i]>>w[i];
  for (int i=0;i<=mx;i++)
  {
    for (int j=1;j<=b;j++)
      if(i&(1<<(j-1))){
        mt[i]=max(mt[i], t[j]);
        mw[i]+=w[j];
      }
  }
  memset (f,0x3f,sizeof(f));
  f[0]=0;
  for (int i=0;i<=mx;i++)
  {
    for (int j=i;;j=(j-1)&i)
    {
      if(mw[i^j]<=a) f[i]=min(f[i],f[j]+mt[i^j]);
      if(!j) break;
    }
  }
  cout<<f[mx];
  fclose(stdin);
  fclose(stdout);
  return 0;
}


```

---

## 作者：yu__xuan (赞：14)

### 题目

[P5911 [POI2004]PRZ](https://www.luogu.com.cn/problem/P5911)

### 思路

状压 $dp$。把每一个人选不选压为二进制。

如 $8$ 个人中选了 $1,3$ 和 $4$ 就可以表示为 $00001101$。

$C[i]$ 表示当 $i$ 这些人为一队时的总重量。$T[i]$ 表示当 $i$ 这些人为一队时里面最慢的那个人要的时间。

状态转移方程：

`if(C[i ^ j] <= w) f[i] = min(f[i], f[j] + T[i ^ j]);`

含义是将 $i$ 这些人拆为 $i \oplus j$ 以及 $j$ 两组，当 $i \oplus j$ 这一组的总重量不超过桥的承受能力时就可以用更新 $f[i]$。

写成下面这样也可以:

`if (C[j] <= w) f[i] = min(f[i], f[i ^ j] + T[j]);`

### Code

```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <algorithm>
#define inf 2147483647
#define MAXN (1 << 16) + 1

int w, n, c[17], t[17];
int T[MAXN], C[MAXN], f[MAXN];

int max(int a, int b) { return a > b ? a : b; }
int min(int a, int b) { return a < b ? a : b; }

int main() {
	scanf("%d %d", &w, &n);
	for (int i = 1; i <= n; ++i) scanf("%d %d", &t[i], &c[i]);
	for (int i = 0; i < (1 << n); ++i) {
		int d = i, cnt = 0;
		while(d) {
			++cnt;
			if (d & 1) {
				C[i] += c[cnt];
				T[i] = max(T[i], t[cnt]);
			}
			d >>= 1;
		}
		f[i] = inf;
	}
	f[0] = 0;
	for (int i = 0; i < (1 << n); ++i) {
		for (int j = i; j >= 0; j = i & (j - 1)) {
			if (C[i ^ j] <= w) f[i] = min(f[i], f[j] + T[i ^ j]);
			if (j == 0) break;
		}
	}
	printf("%d\n", f[(1 << n) - 1]);
	return 0;
}
```

---

## 作者：1saunoya (赞：8)

怎么全是 **模拟退火** 啊，这明明是个 **枚举子集** 的板子题。

考虑 $n \leq 16$ 二进制没错了。。

$dt_i$ 表示 $i$ 这个状态下 $\max{t_j}$,$[\texttt{i\&(1<<j)}]$

$dw_i$ 表示 $i$ 这个状态下
$\sum w_j$,$[\texttt{i\&(1<<j)}]$

$dp_i$ 表示 $i$ 这个状态下的最少时间

时间复杂度 $O(3^n)$
空间复杂度 $O(2^n)$

```cpp
#include <bits/stdc++.h>
#define rep(i , x , y) for(register int i = x ; i <= y ; i ++)

#define int long long
using namespace std ;

signed main() {
	ios :: sync_with_stdio(false) ;
	cin.tie(nullptr) ;
	cout.tie(nullptr) ;
	int W , n ;
	cin >> W >> n ;
	vector < int > t(n) , w(n) ;
	for(int i = 0 ; i < n ; i ++)
		cin >> t[i] >> w[i] ;
	vector < int > dt(1 << n) , dw(1 << n) ;
	for(int i = 0 ; i < 1 << n ; i ++) {
		for(int j = 0 ; j < n ; j ++) {
			if(i & (1 << j)) continue ;
			dt[i | (1 << j)] = max(dt[i] , t[j]) ;
			dw[i | (1 << j)] = dw[i] + w[j] ;
		}
	}
	vector < int > dp(1 << n , 999) ;
	dp[0] = 0 ;
	for(int i = 1 ; i < 1 << n ; i ++) {
		for(int j = i ; j ; j = (j - 1) & i) 
			if(dw[j] <= W) dp[i] = min(dp[i] , dt[j] + dp[i ^ j]) ;
	}
	cout << dp[(1 << n) - 1] << '\n' ;
	return 0 ;
}
```

---

## 作者：Remake_ (赞：7)

贪心，非常简单，但是正确性不保啊qwq。

那肯定要用随机化贪心啊，因为总有一种顺序能保证贪心到的是最优解。

考虑建一个数组$order_i$，表示贪心的顺序，初始的时候让$order_i=i$，之后每次都对$order$数组进行```random_shuffle```，然后按这个新的顺序贪心，并用一个变量来记录贪心这么多次以来所得到的最小值。

数据比较小，贪心跑$10^6$次可以稳过qwq。

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, W, t[20], w[20], order[20], times = 1000000, minn = 0x7fffffffffffffff;
void tx()
{
    long long sum = 0, cnt = 0, maxx = 0;
    for (int i = 1; i <= n; i++)
    {
        if (sum + w[order[i]] > W)
        {
            cnt += maxx;
            sum = w[order[i]];
            maxx = t[order[i]];
        }
        else
        {
            sum += w[order[i]];
            maxx = max(maxx, t[order[i]]);
        }
    }
    minn = min(minn, cnt + maxx);
}
int main()
{
    cin >> W >> n;
    for (int i = 1; i <= n; i++)
        cin >> t[i] >> w[i];
    for (int i = 1; i <= n; i++)
        order[i] = i;
    while (--times)
    {
        random_shuffle(order + 1, order + n + 1);
        tx();
    }
    cout << minn;
    system("pause");
}
```


---

## 作者：Alarm5854 (赞：5)

这道题目本来是要用状压dp来做的，但是，当我看到 $N\le16$ ，我就想到了模拟退火。

首先，要用贪心，也就是如果这座桥还能承受住这个人，就让他上桥。  
接着，由于 $16! = 2\times 10^{13}$，所以退火次数要多一些。

### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int W, n, ans, temp, a[26], t[26], w[26];
inline int random(int a, int b) {
	return rand() % (b - a + 1) + a;
}
inline int check() {
	int res = 0, weight = 0, tim = 0;
	for (int i = 1; i <= n; ++i) {
		if (weight + w[a[i]] <= W) weight += w[a[i]], tim = max(tim, t[a[i]]);//如果这座桥还能承受住这个人，就让他上桥。
		else res += tim, weight = w[a[i]], tim = t[a[i]];//否则，让原来的人过桥，他再上桥。
	}
	return res + tim;//别忘记加上最后几个人所耗时间。
}
int main() {
	srand(time(0));
	scanf("%d%d", &W, &n);
	for (int i = 1; i <= n; ++i)
		a[i] = i, scanf("%d%d", t + i, w + i);
	ans = check();//一开始先计算。
	for (double T = 1e11; T > 1e-11; T *= 0.9999) {//退火次数为506544，可以减少退火次数，提高效率。
		int x, y;
		do {
			x = random(1, n);
			y = random(1, n);
		}while (x == y);
		swap(a[x], a[y]);//交换这两个人的顺序。
		temp = check();
		if (temp < ans) ans = temp;
		else if (exp(ans - temp) / T > 1.0 * rand() / RAND_MAX)//即使新解更糟，也不能抛弃。
			swap(a[x], a[y]);
	}
	printf("%d", ans);
}
```

---

## 作者：Stay_Hungry (赞：5)

我只想说：数据太水    

19ms  708.00KB  O2      
34ms  804.00KB Without O2    

------------
我看到此题时，有点懵，然后一看数据$1 \le n \le16$    
???
这不是模拟退火裸题吗？    
于是便有了玄学AC    

思路如下：  
1.先随便安排一下过桥顺序   
2.对于每种顺序都$O(n)$的求出相对应的值   
3.每次枚举两个位置，然后交换，再重复1 2操作    
4.玄学退火   

```
#include <cstdio>
#include <cstdlib>
#include <time.h>
#include <cmath>
#include <algorithm>
int m , n , w[ 20 ] , t[ 20 ] , p[ 20 ] , ans = 1e9 ;
int Val() { 
	int lst = 0 , res = 0 , mx = 0 ;
	for( int i = 1 ; i <= n + 1 ; ++i ) {
		lst += w[ p[ i ] ] ; mx = std :: max( t[ p[ i ] ] , mx ) ;
		if( lst > m ) res += mx , lst = w[ p[ i ] ] , mx = t[ p[ i ] ] ;
	}
	return res ;
}
void XUANXUE() {
	for( double T = 3e5 ; T > 1e-10 ; T *= 0.9112 ) {
		int x = rand() % n + 1 ;
		int y = rand() % n + 1 ;
		if( x == y ) y = ( x * 3 ) % n + 1 ;
		std :: swap( p[ x ] , p[ y ] ) ;
		int d = Val() , re = ans - d ;
		if( re > 0 ) ans = d ;
		else if( exp( re / T ) * RAND_MAX < rand() ) 
			std :: swap( p[ x ] , p[ y ] ) ;
	}
}
int main() {
	scanf( "%d %d" , &m , &n ) ;
	for( int i = 1 ; i <= n ; ++i ) 
		scanf( "%d %d" , t + i , w + i ) ;
	w[ n + 1 ] = 1e9 ;
	for( int i = 1 ; i <= n + 1 ; ++i )
		p[ i ] = i ;
	for( int i = 1 ; i <= 30 ; ++i ) XUANXUE() ;
	printf( "%d\n" , ans ) ;
	return 0 ;
}
```
数据太水，跑了30遍就AC了（连srand都没写），实际跑10000次才跑满    

---

## 作者：Ryo_Yamada (赞：3)

本人看到题解里有$2$个都是~~玄学~~退火，来~~水~~写一篇题解。

这题看到数据范围$n \leq 16$我第一个想到的就是状压DP，~~毕竟我就是为了练状压DP~~。

我们用$\text{dp[s]}$表示状态$s$对应的队员集合过桥的最小时间，二进制中1表示已过桥，0表示未过桥。

状态转移方程：dp[i] = min(dp[i], dp[j] + Time[i ^ j]);（^是异或，不是次方，因为这个我也没用$\LaTeX$）

（$\text{Time[i]}$表示$i$对应的队员集合过桥的最小时间）

My Code：

```cpp
#include <iostream>
#include <cstring>
#define max(a, b) a > b ? a : b
using namespace std;
const int N = (1 << 16 + 5);
int Status, W, n, t[20], w[20], Time[N], Weight[N], dp[N];  
int main() {
    cin >> W >> n;
    for(int i=1; i<=n; i++) {
    	cin >> t[i] >> w[i];
	}
	Status = (1 << n);
	for(int i=0; i<Status; i++) {
		for(int j=1; (1 << (j - 1)) <= i; j++) {
			if(i & (1 << (j - 1))) {
				Time[i] = max(Time[i], t[j]);
				Weight[i] += w[j];
			}
		}
	}//预处理一下Time和Weight数组，表示队员集合为i的最短时间和总重量
	memset(dp, 0x3f, sizeof(dp));
	dp[0] = 0;
	for(int i=0; i<Status; i++) {
		for(int j=i; j>=0; j = i & (j - 1)) {
			if(Weight[i ^ j] <= W) dp[i] = min(dp[i], dp[j] + Time[i ^ j]);//状态转移
			if(j == 0) break;//这里j=0需要操作一次后break
		}
	}
	cout << dp[Status - 1];//输出全部队员过桥的最小时间
    return 0;
}
```


---

## 作者：Kiloio (赞：2)

# 状压DP    

### 状态：$f[S]$意为$S$集合中的所有人过桥，所需最小时间    

**状态转移方程先前解释：**  
1. $T[S]$表示记录$S$集合中，过桥**耗时最长**那个人的过桥时间。
2. $W[S]$表示记录$S$集合中，**所有人**的**总重量**。   
3. $S$是当前集合，$S1$和$S2$是为模拟的**子集**（$S1=S$^$S2$）
  
### 方程：$f[S]=min(f[S],T[S1]+f[S2])$   
求得是$S$中状态$S2$的过桥时间 $+$ 状态$S1$的**最优**过桥时间   
  
代码：  
```
#include <bits/stdc++.h>
using namespace std;
long long W_fir,n,f[1<<16],W[1<<16],T[1<<16],tot;
struct node{
	long long t,w;
}a[19];
int main(){
	cin>>W_fir>>n;
	tot=(1<<n)-1;
	for(int i=1; i<=n; i++){
		scanf("%lld%lld",&a[i].t,&a[i].w);
	}
	for(int s=0; s<=tot; s++){
		for(int i=1; i<=n; i++){
			if(s&(1<<(i-1))){
				T[s]=max(T[s],a[i].t);
				W[s]+=a[i].w;
			}
		}
	}
	memset(f,0x3f3f,sizeof(f));
	f[0]=0;
	int s1;
	for(int s=0; s<=tot; s++){
		for(int s2=s; ; s2=s&(s2-1)){
			s1=s^s2;
			if(W[s1]<=W_fir){				
				f[s]=min(f[s],T[s1]+f[s2]);
			}
			if(s2==0){
				break;
			}
		}
	}
	cout<<f[tot];
	return 0;
}
```


---

## 作者：lyhqwq (赞：2)

# [P5911](https://www.luogu.com.cn/problem/P5911)

看到这道题的第一眼：$ 1 \le n \leq 16 $

考虑状压DP

首先设$ dp[i] $为状态$ i $下花费的最少时间

其中状态$ i $是一串二进制数，其中$ 1 $表示这一名队员被选择上桥，$ 0 $表示这一名队员没有被选择上桥

再设$ T[i] $为状态$ i $下的要花费的时间

$ W[i] $为状态$ i $下的总重量

在顺序枚举$ i $，并枚举$ j \in i$，把$ i $分成$ j $和$ i \oplus j $两组

推出状态转移方程：$ dp[i]=min(dp[i],dp[j]+T[i \oplus j])(W[i \oplus j] \le W)$

$ ACcode:$

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define il inline
using namespace std;
const int Max=17;
int dp[1<<Max],t[1<<Max],w[1<<Max],T[1<<Max],W[1<<Max],Weight,n;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>Weight>>n;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>w[i];
	}
	for(int i=0;i<(1<<n);i++){//预处理W和T数组
		int j=i,index=0;
		while(j){
			++index;
			if(j&1){
				W[i]+=w[index];
				T[i]=max(T[i],t[index]);
			}
			j>>=1;
		}
		dp[i]=2147483647;//赋值无穷大
	}
	dp[0]=0;//零个人的时间为零
	for(int i=0;i<(1<<n);i++){//DP过程
		for(int j=i;j>=0;j=i&(j-1)){
			if(W[i^j]<=Weight) dp[i]=min(dp[i],dp[j]+T[i^j]);//状态转移方程
			if(j==0) break;//剪枝
		}
	}
	cout<<dp[(1<<n)-1];
	return 0;
}

```


蒟蒻第一篇题解，求通过

---

## 作者：Enterpr1se (赞：2)

（蒟蒻第一次写状压的题解，如内容有误欢迎大力指正）  
翻了翻题解，发现貌似没有人写有关状压的前置知识，那我来~~水~~介绍一下~~以让这篇题解不至于太短~~  
  
>个人理解，状压（状态压缩）的基本原理就是把一个整数（int 或 long long）当做数组来使用，让它来存储一种状态而不仅是一个数。具体的实现方法就是单独读取这个变量的某一二进制位。  
其优势包括：  
>1. 速度更快（只需使用位运算）
>2. 在存储有关该状态的信息时不需要用太复杂的数据结构  
>3. ~~在欺负没学过状压的蒟蒻时看起来很帅~~

回归正题。  
此题中 $n$ 的最大值为 16，也就意味着我们只需要一个 `int` 型整数就能存储所有人的状态（1 代表该人在桥上，0 代表不在），这时状压的优势就体现了出来。若用数组 $f$ 存储答案（$f_i$ 代表在状态 $i$ 下通过所需的最短时间），则状态转换方程为
$$f_i=min[f_i,f_j+time(f_i \otimes f_j)](i \supset j)$$
好的，上代码。
>数组及变量定义  
`wlmt` 题目中的 $W$  
`n`,`w[i]`,`t[i]`同题目  
`cw[i]` $i$ 状态下的总重  
`ct[i]` $i$ 状态下用时  
`f` 同方程中描述  

```cpp
//Luogu-P5911 Solution Version 题解版本 
//Luogu @W53729 (Userid 363523)
//@_Qijia (Userid 363524) AK IOI!
#include<cstdio>
#include<cstring>
#define regll register long long
#define regint register int
#define regshort register short
#define _Qijia using
#define AK namespace
#define IOI std
#define maxcase_by_363523 (1<<16)-1
#define _363523_scan scanf
#define _363523_print printf
_Qijia AK IOI; //大佬保佑我AC（？ 
int wlmt,n,w[20],t[20],cw[maxcase_by_363523+10],ct[maxcase_by_363523+10],f[maxcase_by_363523+10];
int max(int a,int b){
	return a>b?a:b; 
}
int min(int a,int b){
	return a<b?a:b; 
}
int main(){
	_363523_scan("%d%d",&wlmt,&n);
	const int cmaxcase_by_363523=(1<<n)-1;
	for(regint i=1;i<=n;++i) _363523_scan("%d%d",&t[i],&w[i]);
	for(regint i=0;i<=cmaxcase_by_363523;++i) //顺序循环所有状态 
		for(regint j=1;j<=n;++j)
			if(i&(1<<(j-1))/*判断第j个人是否在桥上*/) ct[i]=max(ct[i],t[j]),cw[i]+=w[j];//更新状态的时间和重量 
	memset(f,0x3f,sizeof(f)); //由于答案要求最小值 此处先设成最大 
	f[0]=0; //初始化 
	for(regint i=0;i<=cmaxcase_by_363523;++i){
		for(regint j=i;;j=i&(j-1)){ //顺序循环状态i的子集 
			if(cw[i^j]<=wlmt) f[i]=min(f[i],f[j]+ct[i^j]);
			if(!j) break; //终止循环 
		}
	}
	_363523_print("%d",f[cmaxcase_by_363523]);
	return 0;
}
```
感谢大佬阅读。

---


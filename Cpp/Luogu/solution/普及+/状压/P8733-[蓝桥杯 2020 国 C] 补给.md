# [蓝桥杯 2020 国 C] 补给

## 题目描述

小蓝是一个直升飞机驾驶员，他负责给山区的 $n$ 个村庄运送物资。

每个月，他都要到每个村庄至少一次，可以多于一次，将村庄需要的物资运送过去。

每个村庄都正好有一个直升机场，每两个村庄之间的路程都正好是村庄之间的直线距离。

由于直升机的油箱大小有限，小蓝单次飞行的距离不能超过 $D$。每个直升机场都有加油站，可以给直升机加满油。

每个月，小蓝都是从总部出发，给各个村庄运送完物资后回到总部。如果方便，小蓝中途也可以经过总部来加油。

总部位于编号为 $1$ 的村庄。

请问，要完成一个月的任务，小蓝至少要飞行多长距离？

## 说明/提示

对于所有数据，保证，$1\le n\le20,1\le x_i,y_i\le10^4,1\le D\le10^5$。

蓝桥杯 2020 年国赛 C 组 I 题。

## 样例 #1

### 输入

```
4 6
1 1
4 5
8 5
11 1```

### 输出

```
28.00```

# 题解

## 作者：lihongqian__int128 (赞：13)

# P8733 [蓝桥杯 2020 国 C] 补给 题解
一道最短路加状压题。

首先，处理出每两个点 $i,j$ 之间的最短距离 $dis_{i,j}$。

然后，开始状压。

定义 $dp_{i,j}$ 为在状态为 $i$ 且停留在 $j$ 的最短距离。其中，状态 $i$ 在二进制下从后往前的第 $k$ 位表示第 $k$ 个点是否到达（$0$ 表示没到达，$1$ 表示到达了）。

初始：$dp_{1,0}=1$。

转移：$dp_{i,j} = \min dp_{i\oplus 2^j,k} + dis_{j,k}$（从状态 $i\oplus 2^j$ 来，答案为状态为 $i\oplus 2^j$ 且停留在 $k$ 的答案 $dp_{i\oplus 2^j,k}$ 加上从 $k$ 到 $j$ 的距离）。要求：$i\oplus 2^j$ 从后往前的第 $k$ 位不为 $0$。

答案：$\min\limits_{i=1}^{n-1}dp_{2^n-1,i}+dis_{i,0}$。

**注意：**

1. 别忘了最后得回去；

2. 最短路初始建边若边长大于 $D$，就不能建。

题外话：考场上最后几分钟才改成了状压的写法，没调出来（悲）。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std ;
int n , d ;
double ans = DBL_MAX , x[25] , y[25] , dp[1 << 20][25] , dis[25][25] ;
bool vis[25] ;
double jl(int a , int b)
{
	return sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b])) ;
}
int main()
{
	memset(dp , 0x7f , sizeof dp) ;
	memset(dis , 0x7f , sizeof dis) ;
	cin >> n >> d ;
	for(int i = 0 ; i < n ; i++)	cin >> x[i] >> y[i] ;
	for(int i = 0 ; i < n ; i++)	for(int j = 0 ; j < n ; j++)	if(jl(i , j) < d)	dis[i][j] = jl(i , j) ;
	for(int i = 0 ; i < n ; i++)
		for(int j = 0 ; j < n ; j++)
			for(int k = 0 ; k < n ; k++)
				dis[i][j] = min(dis[i][j] , dis[i][k] + dis[k][j]) ;
	dp[1][0] = 0 ;
	for(int i = 1 ; i < (1 << n) ; i++)
	{
		for(int j = 0 ; j < n ; j++)
		{
			if(!((i >> j) & 1))	continue ;
			int tmp = i ^ (1 << j) ;
			for(int k = 0 ; k < n ; k++)
			{
				if(!((tmp >> k) & 1))	continue ;
				dp[i][j] = min(dp[i][j] , dp[tmp][k] + dis[j][k]) ;
			}
		}
	}
	for(int i = 1 ; i < n ; i++)
		ans = min(ans , dp[(1 << n) - 1][i] + dis[i][0]) ;
	printf("%.2lf" , ans) ;
	return 0 ;
}
```

---

## 作者：___w (赞：11)

### [P8733 补给](https://www.luogu.com.cn/problem/P8733)
#### 题意简述
- 给定 $n$ 个点的坐标和整数 $D$。
- 求一条起点为第一个点，不重不漏地经过每一个点，最后回到第一个点使得路径最小。
- 该路径上的每一段距离不能超过 $D$。

#### 题目分析
这一题与 [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433) 这题不同之处就在于限制了每一条边的长度不能超过 $D$，这一点造成的影响是两个点的欧几里得距离就有可能不是实际最短距离了。为了方便叙述，下面的部分用 $dis_{x,y}$ 表示点 $x$ 和点 $y$ 之间的实际距离。

![图](https://cdn.luogu.com.cn/upload/image_hosting/s668bhym.png)

如上图所示。令 $D=4$，此时 $dis_{A,C}$ 不为 $AC=3\sqrt{2}$，而是 $AB+BC=6$，那么我们该如何解决呢？

注意到，我们是在求 $dis_{x,y}$ 的最小值，不难想到最短路，所以我们可以用 Floyd 求全源最短路。对于任意两个点 $x$ 和点 $y$，若这两点的欧几里得距离大于 $D$，那么令 $dis_{x,y}=\infty$；否则令 $dis_{x,y}$ 为这两点的欧几里得距离，那么问题就可以迎刃而解了。

为什么上述处理就可以解决呢？因为 $\infty$ 表示该边过不去，只能由其他的点跑过去，也正好解决了 $D$ 的限制这一问题了。

剩下的就简单了，想必大家都已经会状压 DP 了，详细见代码。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20, inf = 1e9;
int n, d;
double ans = inf, x[N], y[N], f[1<<N][N], dis[N][N];
int main() {
	cin >> n >> d;
	for (int i = 0; i < n; ++i) cin >> x[i] >> y[i];
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; ++j) {
			double dist = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));//欧几里得距离 
			if (dist > d) dis[i][j] = inf;//不让该边过去 
			else dis[i][j] = dist;
		}
	for (int k = 0; k < n; ++k)//Floyd 最短路 
		for (int i = 0; i < n; ++i)
			for (int j = 0; j < n; ++j)
				dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);
	memset(f, 0x7f, sizeof(f)), f[1][0] = 0;//初始化 
	for (int i = 1; i < 1<<n; ++i)//阶段 
		for (int j = 0; j < n; ++j) if (i>>j&1)
			for (int k = 0; k < n; ++k) if ((i^1<<j)>>k&1)//状态 
				f[i][j] = min(f[i][j], f[i^1<<j][k]+dis[k][j]);//转移 
	for (int i = 0; i < n; ++i) ans = min(ans, f[(1<<n)-1][i]+dis[i][0]);//注意题意要求回到第一个点 
	printf("%.2lf", ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：8)

保姆级题解，站在我的角度看，保证 xxs 也能懂。

~~如果只是为了代码而看，可以直接跳到最后面复制，后果自负。~~

[题目传送门](https://www.luogu.com.cn/problem/P8733)

# 算法分析

~~根据算法标签和数据范围~~，我们可以知道这是一道状压 DP。

# 前置芝士

- Floyd

- 状压

限于篇幅，不会自行百度。

# 思路

## 1.预处理

首先，我们可以预处理各个点之间的最短距离。

因为题目中有这句话：

> 小蓝单次飞行的距离不能超过 $D$。

所以不能直接用题目中给的距离公式求出所有距离。

可以先把满足 $\sqrt{(x_i-x_j)^2+(y_i-y_j)^2} \le D$ 的点用公式求出来，然后用 Floyd 跑一遍最短路。

upd on 2024.1.5：如果两个点不能联通，则把 $dis_{i,j}$ 设为无限。

## 2.状压求解

### 分析

由于每一个城市都有走过和没走过两种状态，可以把走过城市对应的二进制位设为 $1$，把没走过的设为 $0$。

这里又有一个问题：因为我们要从前一个路径方案的终点来推，但现在我们只能知道已经走过的城市，所以该怎么办？

再设一维嘛！

可以得出 $dp_{i,j}$ 表示本路径方案城市状态为 $i$，终点为 $j$ 时的最短路径。

### 求解

首先，因为 $dp_{i,j}$ 表示最短路径，为了后面进行取最小值操作，先把整个 $dp$ 数组赋值为 $1 \times 10^{10}$（其实只要是一个很大的数就行）。

考虑到小蓝从总部出发（编号为 $1$ 的村庄），所以把 $dp_{1,1}$ 设为 $0$，因为最开始没出发的时候还没有走（距离为 $0$）。

再枚举

- 每一种走过城市的方案（对应我代码中的 $i$）。

- 这一轮的终点（对应我代码中的 $j$）。

- 上一轮的终点（对应我代码中的 $k$）。

来推转移方程。

这里需要两次特判：

- 在循环 $k$ 之前要判断这一轮的终点 $j$，上一轮的终点 $j$ 是否在已经行驶过的城市中，可以使用位运算“或”，

- 判断这一轮和上一轮的终点是否重复。

#### 转移方程

`dp[i][j]=min(dp[i][j],dp[i^(1<<j-1)][d]+dis[d][j]`

upd on 2023.11.11：

解释一下，$dp_{i,j}$ 是由上一种不包含这次路径的终点城市得来的，所以要异或上 `(1<<j-1)`，因为异或这里可以把 $1$ 变成 $0$。

最后从经过所有城市的路径加上终点和编号为 $1$ 的村庄的距离中选一个最小值，得解。

# 注意事项

- `double`

- 保留两位小数

# $\color{#52C41A}\texttt{AC}$ $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
double dp[(1<<20)+5][25],dis[25][25],a[25],b[25];
int n,D;
int main(){
	cin>>n>>D;
	for(int i=1;i<=n;++i){
		cin>>a[i]>>b[i];
	}for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			double d=sqrt((a[i]-a[j])*(a[i]-a[j])+(b[i]-b[j])*(b[i]-b[j]));
			if(d<=D) dis[i][j]=d;
			else dis[i][j]=1e10;
		}
	}
    //Floyd 板子
    for(int k=1;k<=n;k++) for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	for(int i=0;i<(1<<n);++i){
		for(int j=1;j<=n;++j){
			dp[i][j]=1e10;
		}
	}
	dp[1][1]=0;
	for(int i=0;i<(1<<n);++i){
		for(int j=1;j<=n;++j){
			if((i&(i<<(j-1)))){
				for(int d=1;d<=n;++d){
					if(j!=d&&(i&(1<<(d-1))))dp[i][j]=min(dp[i][j],dp[i^(1<<j-1)][d]+dis[d][j]);
				}
			}
		}
	}double ans=1e13;
	for(int i=1;i<=n;++i){
		ans=min(ans,dp[(1<<n)-1][i]+dis[i][1]);
	}printf("%.2lf",ans);
	return 0;
}
```

---

## 作者：HHYQ_07 (赞：7)

# 题解

## 思路

看到 $n\leq20$ 想都没想直接上[状压dp](https://oi.wiki/dp/state/)。先预处理出两点之间的最短距离，然后 $f[s][i]$ 表示经过村庄状态为 $s$，当前点为 $i$ 时的最短距离，答案为：$\min^n_{i=1}(f[2^n-1][i]+dis[i][0])$。

## 细节、提醒

1. 本题因为距离不是整数，要用浮点型。
2. 给浮点型赋无穷大时，要 `memset` 成 `0x7f`，我就因为赋成 `0x3f` 调了半天。
3. 别忘了最后还要回到机场。
4. 建议用 `printf` 控制输出精度，简单且实用。

## ACcode

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20;
int n,d;
double dis[N][N],f[1<<N][N],ans=1e9,x[N],y[N];
inline double di(double x1,double y1,double x2,double y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
signed main()
{
	cin>>n>>d;
	for(int i=0;i<n;i++)
		cin>>x[i]>>y[i];
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			double dist=di(x[i],y[i],x[j],y[j]);
			if(dist<=d)dis[i][j]=dist;	
			else dis[i][j]=1e9;
		}
	for(int k=0;k<n;k++)
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	memset(f,0x7f,sizeof(f));
	f[1][0]=0;
	for(int s=1;s<(1<<n);s++)
		for(int i=0;i<n;i++)
			if((s>>i)&1)
			for(int j=0;j<n;j++)
				if(((s^(1<<i))>>j)&1)
					f[s][i]=min(f[s][i],f[s^1<<i][j]+dis[j][i]);
	for(int i=0;i<n;i++)
		ans=min(ans,f[(1<<n)-1][i]+dis[i][0]);
	printf("%0.2lf",ans);
	return 0;
}
```

---

## 作者：liangbob (赞：6)

### P8733 题解

看到这种类似“旅行商问题”的题目时，我们可以考虑使用搜索，但是搜索很慢，所以考虑使用状压动态规划。

众所周知，状压有两种求解方法，一种是“人人为我”（用别人去更新自己），一种是“我为人人”（用自己去更新别人）。这里以“我为人人”为例。

设当前状态为 $S$ ，则 $f(S,i)$ 为当前状态为 $S$，且最后一步选了 $i$ 的最短距离。那么“我为人人”就要考虑往当前状态上加一个结点。

不妨设为加的这个点为 $j$，首先 $j$ 不能在 $S$ 中（显然你不能走重复的结点），然后我们让 S 加入点 $j$，不妨设加入后状态为 $S'$，那么有如下转移方程：

$$f(S', j)=\min\{f(S', j), f(S,i)+dis(i,j)\}$$

其中 $dis(i,j)$ 表示 $(i,j)$ 之间的“距离”，根据题意，我们可以做如下操作来计算这个“距离”：

- 如果两点间的欧几里得距离为 $r$，且 $r \le d$，那么显然这两个点之间可以通行连边，并设置权值为 $r$。

- 否则，两个点不能通，设置权值为 $\infty$。

然后跑 Floyd 即可，跑完后的数组就是 $dis(i,j)$。

注意 $i$ 要在 $S$ 中，可以枚举 $1$ 到 $n$ 然后逐一判断。

答案为 $\min\{f(T, i)+dis(i,1)\}$，其中 $1\le i \le n$，$T$ 为 $1$ 到 $n$ 都选的状态。

最后给出本题要用到的三个二进制的知识点：

- `S | (1 << (x - 1))` 表示给状态 $S$ 加入元素 $x$。

- `S & (1 << (x - 1))` 表示判断 $x$ 是否在 $S$ 中。如果在，值为 $1$，否则为 $0$。

- `(1 << n) - 1` 表示 $1$ 到 $n$ 都选的状态。

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N = 21;
const int M = 1048576 + 5;

int n, d;
int x[N], y[N]; // 点的坐标
double dp[N][N]; // dis 数组
double f[M][N]; 

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> d;
    for(int i = 1;i <= n;i++)
    {
    	cin >> x[i] >> y[i];
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= n;j++)
		{
			double dis = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); //计算欧几里得距离
            //根据上述方式“建图”
			if(dis <= d) dp[i][j] = dis;
			else dp[i][j] = 1e7; 	
            
		}		
	} 
    //跑 Floyd
	for(int k = 1;k <= n;k++)
	{
		for(int i = 1;i <= n;i++)
		{
			for(int j = 1;j <= n;j++)
			{
				dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
			}
		}
	}
	fill(*f, *f + M * N, 1e7);
	f[1][1] = 0;
	for(int S = 0;S < (1 << n);S++)
	{
		for(int i = 1;i <= n;i++)
		{
			if(S & (1 << (i - 1))) // i 得在 S 中
			{
				for(int j = 1;j <= n;j++)
				{
					if(S & (1 << (j - 1))) continue; //j 如果在 S 中，舍
					f[(S | (1 << (j - 1)))][j] = min(f[(S | (1 << (j - 1)))][j], f[S][i] + dp[i][j]); // 更新
				}
			}
		}
	}
	double ans = 0x7fffffff;
	for(int i = 1;i <= n;i++)
	{
		ans = min(ans, f[(1 << n) - 1][i] + dp[i][1]); //计算答案
	}
	cout << fixed << setprecision(2) << ans << endl;
    return 0;
}

```

---

## 作者：Autream (赞：5)

2024/11/1 upd: 更改了码风。
#### 题意简述
 给定平面直角坐标系的 $n$ 个点和一个整数 $D$，求从节点 $1$ 遍历所有的 $n$ 个点再回到节点 $1$ 的最短路径。路径上任意两个节点的欧几里得距离不能超过 $D$。
#### 题目分析
 先看数据范围，$1 \leq n \leq 20$，考虑状压。

对于这种与路径长度有关的状压 DP，我们通常设 $dp_{S,j}$ 为已经经过的点的集合为 $S$ 时，当前在节点 $j$ 时的最短路径长度（因为路径的长度与两个节点相关，所以可以记录一个节点，枚举一个节点，故设一维保存节点）。状态转移方程：
$$
 dp_{S \cup \{j\},j} \gets \min_{k=0}^{n}dp_{S,k}+dis_{k,j}
$$
其中 $dis_{k,j}$ 表示从 $k$ 到 $j$ 的距离。

但是这道题有点不一样，因为它还有一个限制条件，在两个节点的路径长度大于 $D$ 的时候是不能转移的，这个时候我们只能考虑使一个另外的节点充当“中转站”，再从“中转站”转移到目标节点。于是便有了这份暴力代码：

```cpp
CI N = 20;
double calc(double x1, double y1, double x2, double y2) { return std::sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }
int n, d;
PII id[N];
double dp[1 << N][N], dis[N][N], ans = 0x3f3f3f3f;
signed main() {
	std::cin >> n >> d;
	rep(i, 1, n) std::cin >> id[i].ff >> id[i].ss;
	rep(i, 1, n) rep(j, 1, n) dis[i][j] = calc(id[i].ff, id[i].ss, id[j].ff, id[j].ss);
	rep(i, 0, (1 << 20) - 1) rep(j, 1, N - 1) dp[i][j] = 1e9;
	dp[1][1] = 0;
	rep(i, 1, (1 << n) - 1) rep(j, 1, n) {
		if((i >> j - 1) & 1) { continue; }
		rep(k, 1, n) {
			if(k == j) continue;
			if(dis[k][j] > d) {
				rep(l, 1, n) {
					if(dis[k][l] > d || dis[l][j] > d) continue;
					dp[i | (1 << j - 1)][j] = std::min(dp[i | (1 << j - 1)][j], dp[i][k] + dis[k][l] + dis[l][j]);
				}
			} else {
				dp[i | (1 << j - 1)][j] = std::min(dp[i | (1 << j - 1)][j], dp[i][k] + dis[k][j]);
			}
		}
	}
	rep(i, 1, n) if(dis[i][1] > d) {
		rep(j, 1, n) {
			if(dis[i][j] > d || dis[j][1] > d) continue;
			ans = std::min(ans, dp[(1 << n) - 1][i] + dis[i][j] + dis[j][1]);
		}
	} else ans = std::min(ans, dp[(1 << n) - 1][i] + dis[i][1]);
	printf("%.2lf", ans);
	return 0;
}
```
结果当然 T飞了！

这份代码的时间复杂度为 $O(2^nn^3)\approx10^9$，所以我们考虑优化。

造成时间复杂度如此之高的原因是在 DP 转移的时候多次判断了路径长度是否超过 $D$，造成重复计算，所以我们可以把 $dis$ 预处理出来，与 DP 转移的分开处理，时间复杂度为 $O(2^nn^2)$，可以通过此题。
#### 代码

```cpp
#include <bits/stdc++.h>
#define arrout(a, n) rep(i, 1, n) printk(a[i])
#define arrin(a, n) rep(i, 1, n) a[i] = read()
#define rep(i, x, n) for(int i = x; i <= n; i++)
#define dep(i, x, n) for(int i = x; i >= n; i--)
#define erg(i, x) for(int i = head[x]; i; i = e[i].nex)
#define dbg(x) std::cout << #x << ":" << x << " "
#define mem(a, x) memset(a, x, sizeof a)
#define all(x) x.begin(), x.end()
#define arrall(a, n) a + 1, a + 1 + n
#define PII std::pair<int, int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
int read() {
	char ch = getchar();
	int r = 0, w = 1;
	while(ch < '0' || ch > '9') w = ch == '-' ? -1 : w, ch = getchar();
	while(ch >= '0' && ch <= '9') r = (r << 3) + (r << 1) + (ch ^ 48), ch = getchar();
	return r * w;
}

void print(int x) {
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}template<typename ...Args>
void print(int t, Args... args) { print(t), print(args...); }

void printl(int x) { print(x), putchar('\n'); }
template<typename ...Args>
void printl(int t, Args... args) { printl(t), printl(args...); }

void printk(int x) { print(x), putchar(' '); }
template<typename ...Args>
void printk(int t, Args ... args) { printk(t), printk(args...); }

CI N = 25;
double calc(int x1, int y1, int x2, int y2) { return std::sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }
int n, d;
PII id[N];
double dp[1 << 20][N], dis[N][N], ans = 0x3f3f3f3f;
signed main() {
	rep(i, 0, (1 << 18) - 1) rep(j, 1, N) dp[i][j] = 1e9;
	std::cin >> n >> d;
	rep(i, 1, n) std::cin >> id[i].ff >> id[i].ss;
	rep(i, 1, n) rep(j, 1, n) dis[i][j] = 1e9;
	rep(i, 1, n) rep(j, 1, n) {
		if(calc(id[i].ff, id[i].ss, id[j].ff, id[j].ss) > d) {
			rep(k, 1, n) {
				if(calc(id[i].ff, id[i].ss, id[k].ff, id[k].ss) > d || calc(id[k].ff, id[k].ss, id[j].ff, id[j].ss) > d) continue;
				dis[i][j] = std::min(dis[i][j], calc(id[i].ff, id[i].ss, id[k].ff, id[k].ss) + calc(id[k].ff, id[k].ss, id[j].ff, id[j].ss));
			}
		} else dis[i][j] = calc(id[i].ff, id[i].ss, id[j].ff, id[j].ss);
	}
	rep(i, 0, (1 << 20) - 1) rep(j, 1, N - 1) dp[i][j] = 1e9;
	dp[1][1] = 0;
	rep(i, 1, (1 << n) - 1) rep(j, 1, n) {
		if((i >> j - 1) & 1) continue;
		rep(k, 1, n) {
			if(k == j) continue;
			if(!((i >> k - 1) & 1)) continue;
			dp[i | (1 << j - 1)][j] = std::min(dp[i | (1 << j - 1)][j], dp[i][k] + dis[k][j]);
		}
	}
	rep(i, 1, n) ans = std::min(ans, dp[(1 << n) - 1][i] + dis[i][1]);
	printf("%.2lf", ans);
	return 0;
}
```

---

## 作者：ethan0328 (赞：4)

## 前置知识

[状压DP](https://oi-wiki.org/dp/state/)

[Floyd最短路](https://oi-wiki.org/graph/shortest-path/)

## 思路

状压 DP 模板题。

首先，对于每两个点连边，若边长大于 $D$，则令边长为无穷大。

对边进行 Floyd 最短路。

然后开始状压 DP。

令 $f_{i,j}$ 表示经过村庄状态为 $i$，目前位于村庄 $j$ 时所飞的距离。

其中 $i$ 的二进制的第 $k$ 位表示第 $k$ 个村庄是否已到达，$1$ 为到达过，$0$ 为未到达过。

枚举 $k$，$k$ 必须已到达过，则 $f_{i,j}=\min(f_{i \oplus 2^{j-1},k}+a_{j,k},f_{i,j})$。

$i \oplus 2^{j-1}$ 表示将 $i$ 的第 $j$ 的为变为 $0$。

最后答案为 $1$ 到 $n$ 中最小的 $f_{2^n-1,i}+a_{1,i}$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=21,N2=(1<<20)+10,inf=2e9;
int n,d,x[N],y[N];
double ans,a[N][N],f[N2][N];
double get_dis(int x1,int y1,int x2,int y2)
{
	double ret;
	ret=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
	ret=(double)sqrt(ret);
	if(ret>d)
	{
		return inf;
	}
	return ret;
}
int main()
{
	cin>>n>>d;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j]=get_dis(x[i],y[i],x[j],y[j]);
		}
	}
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
			}
		}
	}
	f[1][1]=0;
	for(int i=2;i<(1<<n);i++)
	{
		for(int j=1;j<=n;j++)
		{
			f[i][j]=inf;
			if(!(i&(1<<(j-1))))
			{
				continue;
			}
			for(int k=1;k<=n;k++)
			{
				if(k==j)
				{
					continue;
				}
				if(!(i&(1<<(k-1))))
				{
					continue;
				}
				f[i][j]=min(f[i^(1<<(j-1))][k]+a[k][j],f[i][j]);
			}
		}
	}
	ans=inf;
	for(int i=1;i<=n;i++)
	{
		ans=min(ans,f[(1<<n)-1][i]+a[1][i]);
	}
	printf("%.2lf",ans);
}
```


---

## 作者：andyli (赞：2)

floyd 预处理两点间最短路，再状压 dp 求出一条起点为 $1$ 号点且经过所有点的路径的最下长度。由于最终需要回到总部，因此以 $i$ 为终点这样的路径的长度加上 $i$ 到 $1$ 的距离即为答案，取 min 即可。

```cpp
int main() {
    dR(int, n, m);
    std::vector<int> x(n), y(n);
    for (int i = 0; i < n; i++)
        io.read(x[i], y[i]);
    std::vector e(n, std::vector(n, 1e12));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (double t = std::hypot(x[i] - x[j], y[i] - y[j]); t <= m)
                e[i][j] = t;
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                chkmin(e[i][j], e[i][k] + e[k][j]);
    std::vector d(1 << n, std::vector(n, 1e12));
    d[1][0] = 0;
    for (int S = 0; S < (1 << n); S++)
        for (int i = 0; i < n; i++)
            if (S & (1 << i))
                for (int j = 0; j < n; j++)
                    if (~S & (1 << j))
                        chkmin(d[S | (1 << j)][j], d[S][i] + e[i][j]);
    for (int i = 0; i < n; i++)
        d.back()[i] += e[i][0]; // 加上 i 到 1 号点的距离
    io.setprecision(2);
    writeln(min(d.back()));
    return 0;
}
```

---

## 作者：Stars_visitor_tyw (赞：1)

## P8733 [蓝桥杯 2020 国 C] 补给 题解

### 分析
本题需要用到状态压缩和最短路。

定义一个二维数组 $dis$ 存储每两个点之间的距离。观察到数据范围非常小，于是跑一遍 Floyd 求出每两个点的最短距离。

状压的写法和模板题差不多，枚举二进制经过的点的状态，枚举当前位置 $j$，枚举上一个位置 $j$，则上一步状态为 $dp_{i \oplus 2^j,k}$。再加上 $dis_{k,j}$ 取最小值即可。具体见 [模板题题解](https://www.luogu.com.cn/article/z883dedy)。

因为最后要回去，所以枚举状压出来终点在 $i$ 点所需的距离加上从 $i$ 点回到 $0$ 点的最短路 $dis_{i,0}$ 的最小值。原题中总部在 $1$ 点，因为要状压的缘故，我的写法中下标从 $0$ 开始，总部位于 $0$ 点。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
double dp[1<<20][25], w[25][25], d;
double dis[25][25];
void work()
{
	for(int i=0;i<(1<<n);i++)
	{
		for(int j=0;j<n;j++)
		{
			if((i>>j)&1)
			{
				for(int k=0;k<n;k++)
				{
					if((i>>k)&1)
					{
						dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+dis[k][j]);
					}
				}
			}
		}
	}
}
double get(double x, double y, double xx, double yy)
{
	return sqrt((xx-x)*(xx-x)+(yy-y)*(yy-y));
}
double x[25], y[25];
signed main()
{
	cin>>n>>d;
	for(int i=0;i<n;i++)
	{
		cin>>x[i]>>y[i];
	}
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			dis[i][j]=((get(x[i],y[i],x[j],y[j])>d)?1e9:get(x[i],y[i],x[j],y[j]));
		}
	}
	for(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	for(int i=0;i<(1<<n);i++)
	{
		for(int j=0;j<n;j++)
		{
			dp[i][j]=1e9;
		}
	}
	dp[1][0]=0.0;
	work();
	double mini=1e9;
	for(int i=0;i<n;i++)
	{
		mini=min(mini,dp[(1<<n)-1][i]+dis[i][0]);
	}
	cout<<fixed<<setprecision(2)<<mini;
}

---

## 作者：VitrelosTia (赞：1)

首先把题意简化一下：现在有一些点，给出坐标，这些点两两之间的距离若大于 $D$ 不相连。现在要从一号点出发走完所有点，最后回到一号点。

看到 $n \le 20$ 的数据范围首先想到状压 dp，套路地考虑将状态设为第 $k$ 位为 $0$ 代表没有到过 $k$ 这个点，反之则到过。但这样难以处理回到一号点的问题，于是我们考虑加一维状态 $i$ 表示对于状态 $sta$ 最后到达的一个点是 $i$，这样在统计答案的时候把答案更新为 $\min ^ {n} _ {i = 1}f_{2 ^ n - 1} + dis_{i, 1}$ 就可以了。

然后我们考虑转移。容易想到当前的状态可以由比当前状态少一个点没有访问过的状态转移而来，就可以枚举 $i, j$ 为当前状态 $sta$ 的一个为 $1$ 的位置，$i$ 作为被 $j$ 走到的点。然后列出状态转移方程：

$$f_{sta, i} = \min(f_{sta, i}, f_{sta \oplus 2 ^ {i - 1}, j} + dis_{j, i})$$

这个式子的意思非常明确，$sta \oplus i ^ {i - 1}$ 代表的是把 $sta$ 的第 $i$ 位改为 $0$ （因为 $sta$ 中第 $i$ 位是 $1$ 所以可以这么做），我们把这个状态加上从 $j$ 走到 $i$ 的花费就可以转移到 $sta$ 了。

然后初值就是只访问过一号点时以一号点为终点（也就是开始时）的花费为 $0$。即 $f_{1, 1} = 0$，其余设为极大值。

预处理就比较简单了，先处理出每两个点之间的距离，假如大于 $D$ 就设为极大值，然后跑一边弗洛伊德得出两个点之间的最短距离即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int M = 22;
int n; 
double D, x[M], y[M], d[M][M];
double f[1 << M][M]; // f[sta][i] sta 1/0 是/否访问城市，以 i 结束

void init() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            double dis = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));
            if (dis > D) d[i][j] = 1e18;
            else d[i][j] = dis;
        }
    }
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
    for (int sta = 0; sta < (1 << n); sta++) {
        for (int i = 1; i <= n; i++) {
            f[sta][i] = 1e18;
        }
    }
    f[1][1] = 0;
}

signed main() {
    cin >> n >> D;
    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    init();
    for (int sta = 2; sta < (1 << n); sta++) {
        for (int i = 1; i <= n; i++) {
            if ((sta & (1 << (i - 1))) == 0) continue;
            for (int j = 1; j <= n; j++) {
                if (i == j || ((sta & (1 << (i - 1))) == 0)) continue;
                f[sta][i] = min(f[sta][i], f[sta ^ (1 << (i - 1))][j] + d[j][i]);   
            } 
        }
    }
    double ans = 1e18;
    for (int i = 1; i <= n; i++) ans = min(ans, f[(1 << n) - 1][i] + d[i][1]);
    printf ("%.3lf", ans);
    return 0;
}
```

---

## 作者：Soul_Wanderer (赞：1)

# 题解

## [题目传送门](https://www.luogu.com.cn/problem/P8733)

## 思路

首先，我们一眼就看见了 $n$ 的数据范围是 $n \leq 20$，这么小的数据范围不是暴搜就是状压，再看一眼标签果然是状压，那这就好办了。
  
先定义**状态**：$f_{s,i}$ 表示现在的状态是 $s$，现在的落脚点是 $i$ 时走过的最短距离， 状态 $s$ 中，$0$ 代表没去过，$1$ 代表去过了。

然后是**状态转移方程**：由于转移方程涉及到一些位运算操作，不太好表达，所以具体请见代码。

最后，**答案**就是：$\min_{i=1}^{n}\{f_{2^n-1,i}+dis_{i,0}\}$。

别忘了最后还是要**回到机场**的。

求两点距离时还需要个单源最短路，由于数据范围较小，我就拿了弗洛伊德求最短距离。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
const int inf=1451674940337521ll;
int n,d;
double f[(1<<20)+5][25];//f[s][i]表示状态为s现在落脚点为i处时走过的最短距离 
double line[25][25];
int x[25],y[25];
signed main()
{
	cin>>n>>d;
	for(int i=0;i<n;i++)
		cin>>x[i]>>y[i];
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++){
			line[i][j]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
			if(line[i][j]>d) line[i][j]=inf;
		}
	for(int k=0;k<n;k++)
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				line[i][j]=min(line[i][j],line[i][k]+line[k][j]);
	memset(f,127,sizeof(f));
	f[1][0]=0;
	for(int s=0;s<(1<<n);s++){
		for(int i=0;i<n;i++){
			if(((s>>i)&1)==0) continue;
			for(int j=0;j<n;j++){
				if((s>>j)&1) continue;
				f[s|(1<<j)][j]=min(f[s|(1<<j)][j],f[s][i]+line[i][j]); 
			}
		}
	}
	double ans=inf;
	for(int i=0;i<n;i++) ans=min(ans,f[(1<<n)-1][i]+line[0][i]);
	printf("%.2lf",ans);
	return 0;
}
```

---

## 作者：lfxxx (赞：1)

先考虑两点之间的距离怎么算，不难发现因为 $n \leq 20$ 因为可以先用 floyd 跑出两点间的最短路，当然注意 $D$ 这个限制。

然后设计状态 $dp_{i,v}$ 表示当前到达的点是 $i$ 且经过的点状压为 $v$ 的最短路，那么由于走过的点只会变多不会变少所以没有后效性，然后直接转移即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxv = 1048600;
const int maxn = 22;
double f[maxn][maxn];
double val[maxn][maxv];
double X[maxn],Y[maxn];
double inf = 1e9+114;
int n,D;
double dis(int px,int py){
	return sqrt((X[px]-X[py])*(X[px]-X[py])+(Y[px]-Y[py])*(Y[px]-Y[py]));
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>D;
	for(int i=1;i<=n;i++){
		cin>>X[i]>>Y[i];
	}
	for(int i=0;i<maxn;i++)
		for(int j=0;j<maxn;j++) f[i][j]=inf;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(dis(i,j)<=D) f[i][j]=min(f[i][j],dis(i,j));
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	for(int i=0;i<maxn;i++)
		for(int j=0;j<maxv;j++) 
			val[i][j]=inf;
	val[1][1]=0;
	for(int i=0;i<maxv;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				if(j!=k&&(i&(1<<(j-1)))&&(i&(1<<(k-1)))){
					val[j][i]=min(val[j][i],val[k][i-(1<<(j-1))]+f[k][j]);
				}
			}
		}
	}
	double mi=inf;
	for(int i=1;i<=n;i++){
		mi=min(mi,val[i][(1<<n)-1]+f[i][1]);	
	}
	printf("%.2lf\n",mi);
	return 0;
}


```


---

## 作者：Star_F (赞：0)

一道状压 dp 结合最短路的题。

## 题目大意：
在平面直角坐标系中，给定 $n$ 个点，从 $1$ 号点遍历完所有点并回到 $1$ 号点的最短路，并且任意两个点之间的距离不能超过 $D$。

## 题目分析：
首先我们看到 $n \le 20$，考虑状压 dp。

设 $f_{i,j}$ 表示当前状态为 $i$，且最后到达的点为 $j$ 的最短路。

显然：$f_{0,0}=0$。

考虑转移：可以想当前状态是由谁转移过来，上一层状态和当前状态最多有一位不同，因为每次只能遍历一个点。所以如果当前状态的第 $i$ 位为 $1$，那么就有可能又上一层第 $i$ 位为 $0$ 转移过来。

所以：$dp_{i,j}=\min dp_{{i\oplus 2^{j}},k}+dis_{k,j}$。

满足 $i$ 的第 $j$ 位为 $1$，$dis_{i,j}$ 为 $i$ 到 $j$ 的最短距离。

现在考虑 $dis_{i,j}$ 该如何求出呢？可以用全源最短路 Johnson 算法。但是这里 $n$ 很小，所以当然可以用 Floyd 求出。

则答案就是 $\min dp_{{2^n-1},i}+dis_{i,0}$。（因为我的代码起点从 $0$ 开始的，所以是 $dis_{i,0}$。

对于状压 dp 的流程有个大致模板，第一层枚举状态，从 $1$ 到 $2^n-1$，第二层枚举当前状态的每一位，第三层枚举如果当前位可以被转移，那么要进行的操作。

如果还是不了解的可以看看代码，有详细注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
#define DEBUG(x) cerr << #x << '=' << x << endl

inline int rd(){
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    return x * f;
}

void print(double x){
    printf("%.2lf", x);
}

namespace Star_F {
    const int MAXN = 20;
    double x[MAXN], y[MAXN], dp[1 << MAXN][MAXN], dis[MAXN][MAXN];
    int n, d;

    double jl(int a, int b) {
        return sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));
    }

    void Main() {
        memset(dp, 0x7f, sizeof(dp));
        memset(dis, 0x7f, sizeof(dis));

        n = rd(); 
        d = rd(); 
        
        FOR(i, 0, n-1) {
            x[i] = rd();
            y[i] = rd();
        }

        FOR(i, 0, n-1) {
            FOR(j, 0, n-1) {
                if (jl(i, j) < d) {
                    dis[i][j] = jl(i, j);    //如果存在大于等于d的距离直接跳过
                }
            }
        }

        //Floyd求 i~j 的最短路。
        FOR(i, 0, n-1) {
            FOR(j, 0, n-1) {
                FOR(k, 0, n-1) {
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }

        dp[1][0] = 0;    //dp的初值，题解已给出。

        FOR(i, 1, (1 << n) - 1) {      //第一层枚举状态。
            FOR(j, 0, n-1) {           //第二层枚举当前状态的每一位
                if (!((i >> j) & 1)) continue;
                int tmp = i ^ (1 << j);
                FOR(k, 0, n-1) {        //如果能进行转移，则进行。
                    if (!((tmp >> k) & 1)) continue;
                    dp[i][j] = min(dp[i][j], dp[tmp][k] + dis[j][k]);    //转移方程，不多说了
                }
            }
        }

        double ans = 2e9;
        FOR(i, 1, n-1) {
            ans = min(ans, dp[(1 << n) - 1][i] + dis[i][0]);   //求答案。
        }

        print(ans);
    }
}

signed main() {
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    return Star_F::Main(), 0;
}

```

---

## 作者：_JF_ (赞：0)

[link ](https://www.luogu.com.cn/problem/P8733)

看到数据范围 $n$ 很小，考虑状压。

既然是状压，就考虑选了一个集合 $S$ 会怎么样，不难发现，这里可以考虑选择走过的点当作集合，那么把走过的点对应的位置标记成 $1$，就能把它抽象成一个数了。

发现只有 $S$ 还不够，设 $dp_{i,j}$ 表示集合 $i$，走到的最后一个点是 $j$ 的最小路程，这里的起点是 $1$。

转移的话就直接考虑枚举还没有走过的点（也就是集合内标记为 $0$ 的点），对他们进行更新，发现我们需要求出 $j$ 到 $k$ 的最短距离。

题目中限制了单次路程不能超过 $D$，转换成两个点的距离不能超过 $D$，可以每飞两个点就加一次油。找到这些边（因为能使用的边只有这些），然后跑最短路，就可以知道在限制下两个点的最短路。

答案就是枚举最后一个点的可能，加上他到第一个点的最短距离就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =21;
double dp[(1<<20)+1][N],dis[N][N],ans=LONG_LONG_MAX,D;
struct node{
	int x,y;
}a[N];
int n;
double Dis(int i,int j){
	return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));
}
void Floyd(){
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++){
			dis[i][j]=1e21;
			if(i==j)	dis[i][j]=0.0;
			else if(Dis(i,j)<=D)	dis[i][j]=Dis(i,j);
	}
	for(int k=0;k<n;k++)
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				if(i!=k&&j!=k&&i!=j)
					dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);			
}
int main()
{
	cin>>n>>D;
	for(int i=0;i<n;i++)	cin>>a[i].x>>a[i].y;
	Floyd();
	for(int i=0;i<(1<<n);i++)	
		for(int j=0;j<n;j++)
			dp[i][j]=1e21;
	dp[1][0]=0.0;
	for(int i=0;i<(1<<n);i++){
		if(i&1==0)	continue;
		for(int j=0;j<n;j++){
			if((i>>j)&1==0)	continue;
			for(int k=0;k<n;k++){
				if(i>>k&1==1)	continue;
				dp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+dis[j][k]);
			}
		}
	}
	for(int i=1;i<n;i++)	
		ans=min(ans,dp[(1<<n)-1][i]+dis[i][0]);
	cout<<fixed<<setprecision(2)<<ans<<endl;
	return 0;
}

```


---

## 作者：harmis_yz (赞：0)

## 分析

一眼状压。

这题和一道 AtCoder 的题目很像。也是从 $1$ 经过所有点后回到 $1$ 的状压题，但是黄。

定义状态函数 $f_{s,i}$ 表示在已经记录（不记录中转点情况）节点的经过情况为 $s$ 的二进制表示（从右往左节点编号递增）且最后停在节点 $i$ 时的最小飞行距离。很明显，我们需要先求一个最短路。对于范围 $n \le 20$，怎么搞都可以。定义 $dis_{i,j}$ 表示节点 $i$ 到 $j$ 的最短路。初始化的时候注意一下和 $D$ 的大小就行。

状压的时候在枚举的状态中找到一个 $j$，假定 $j$ 是新的起点。然后枚举终点即可。有转移方程：$f_{s+2^{k-1},k}=\min(f_{s+2^{k-1},k},f_{s,j}+dis_{j,k})$。统计最终答案也是这样枚举终点。

关于定义与转移的正确性：如果 $dis_{j,k}$ 经过的某个节点在 $s$ 中并没有被记录过，是不会影响答案的。因为 $P_{j \to k}$ 这条路径可以被划分为 $P_1\to P_2,P_2\to P_3 $……而当最优经过节点顺序包含 $P_{j\ to k}$ 时，是一定会枚举到一个顺序：$f_{s_1,k},f_{s_1,k} \to f_{s_2,P_1},f_{s_2,P_1} \to f_{s_3,P_2}$……所以在 $dis_{j,k}$ 经过了没有在状态中出现的节点时，一定不是最优的，对答案无影响。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline

const int N=(1<<21),M=1e5+10,K=25;
double f[N][K],dis[K][K];
struct point{
	double x,y;
}p[M];
int n,m;

il double get(int a,int b){
	double x=(double)sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y));
	if(x>m) return 10000000.0;
	else return x;
}

il void solve(){
	cin>>n>>m;
	for(re int i=0;i<=n+1;++i)for(re int j=0;j<=n+1;++j) dis[i][j]=10000000.0;
	for(re int i=0;i<=1<<n;++i)for(re int j=0;j<=n+1;++j) f[i][j]=10000000.0;
	for(re int i=1;i<=n;++i) cin>>p[i].x>>p[i].y;
	for(re int i=1;i<=n;++i)
	for(re int j=1;j<=n;++j)
		dis[i][j]=min(dis[i][j],get(i,j));
	for(re int k=1;k<=n;++k)
	for(re int i=1;i<=n;++i)
	for(re int j=1;j<=n;++j)
		dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	f[1][1]=0;
	for(re int i=1;i<(1<<(n));++i){
		for(re int j=1;j<=n;++j){
			if(!((i>>(j-1))&1)) continue;
			for(re int k=1;k<=n;++k){
				if((i>>(k-1))&1) continue;
				int now=i+(1<<(k-1));
				f[now][k]=min(f[now][k],f[i][j]+dis[j][k]);
			}
		}
	}
	double Min=10000000.0;
	for(re int i=2;i<=n;++i) Min=min(Min,f[(1<<n)-1][i]+dis[i][1]);
	printf("%.2lf",Min);
	return ;
}

signed main(){
	solve();
	return 0;
}

```


---

## 作者：BugGod (赞：0)

首先看到 $n\le 20$，一眼壮压。类似于[吃奶酪](https://www.luogu.com.cn/problem/P1433)这个题。唯一不同的是要求单次飞行的路程要小于等于 $D$。那么首先，我们从一个村庄到另一个，尽量走最短的距离，易想到最短路，数据范围极小，直接用 Floyd 就可以了，如果两点之间直线距离超过 $D$，设为极大值，在 dp 的时候就不会参与运算了。

我们设 $dp_{s,i}$ 为经过村庄状态为 $s$（去过是 $1$，没去过是 $0$），当前在村庄 $i$ 的最短距离，答案是：$\min^n_{i=1}\lbrace dp_{2^{n}-1,i}+dist_{1,i}\rbrace$。转移方程可以参考代码。

CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,x[30],y[30];
double dist[30][30],dp[(1<<20)+1][21],ans=9e18;
double dis(int i,int j)
{
    return sqrt(1.0*(x[i]-x[j])*(x[i]-x[j])+1.0*(y[i]-y[j])*(y[i]-y[j]));
}
int main()
{
    memset(dp,127,sizeof dp);
    cin>>n>>d;
    for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dist[i][j]=dis(i,j);
            if(dist[i][j]>d)dist[i][j]=9e18;
        }
    }
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
            }
        }
    }
    dp[1][1]=0;
    for(int s=0;s<(1<<n);s++)
    {
        for(int i=1;i<=n;i++)
        {
            if(s>>(i-1)&1)//起点去过了
            {
                for(int j=1;j<=n;j++)
                {
                    if(!(s>>(j-1)&1))dp[s|(1<<(j-1))][j]=min(dp[s|(1<<(j-1))][j],dp[s][i]+dist[i][j]);//这个点没去过，转移这个点去的情况
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        ans=min(ans,dp[(1<<n)-1][i]+dist[1][i]);
    }
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：cppcppcpp3 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8733)。

## Solution
可以先处理每两个点之间的欧几里得距离。在本题里，由于不能连续飞行超过 $D$，所以将距离大于 $D$ 的两点的距离置为无穷大。跑一遍 floyd 全源最短路。

鉴于 $n \le 20$ 这一数据规模，想到用状压 dp 来得到经过某些点时的最短距离（不包括返回总部的路程）。

具体来说，设二进制数 $S$ 的某一位为 $0/1$ 表示是否经过了该点。定义状态 $f_{S,i}$ 为经过村庄集合为 $S$，且当前飞机在点 $i$ 的最短距离。状态转移见代码。

之后枚举最终状态的每一个落点 $i$，则答案就是 $f_{2^n-1,i}+dis_{i,1}$ 中的最小值（$dis_{i,j}$ 表示点 $i$ 到 $j$ 的最短路长度）。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define db double
#define il inline
using namespace std;
const int N=25;
const int S=1<<20;
const db inf=1e9+7;

il int wrd(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-48;c=getchar();}
	return x*f;
}

int n,k;

struct Point{
	int x,y;
}a[N];

db d[N][N],dp[S][N],ans=inf;

#define px db(p.x)
#define py db(p.y)
#define qx db(q.x)
#define qy db(q.y)

db dis(Point p,Point q){
	db ans=sqrt((px-qx)*(px-qx)+(py-qy)*(py-qy));
	return ans>(db)k ? inf : ans;
}

main(){
	n=wrd(),k=wrd();
	for(int i=1;i<=n;++i) a[i]=Point{wrd(),wrd()};
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) d[i][j]=dis(a[i],a[j]);
	
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i) 
			for(int j=1;j<=n;++j)
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
	
	for(int i=2;i<(1<<n);++i){
		for(int u=0;u<n;++u){
			dp[i][u]=inf;
			if((i>>u)&1){
				for(int v=0;v<n;++v){
					if(u==v) continue;
					if((i>>v)&1) dp[i][u]=min(dp[i][u],dp[i^(1<<u)][v]+d[v+1][u+1]);  //由于数位从 0 开始，点从 1 开始编号，所以要加 1。
				}
			}
		}
	}
	
	for(int i=0;i<n;++i) ans=min(ans,dp[(1<<n)-1][i]+d[i+1][1]);
	return printf("%.2lf",ans),0;
}
```

---


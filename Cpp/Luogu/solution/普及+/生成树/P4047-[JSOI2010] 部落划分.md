# [JSOI2010] 部落划分

## 题目描述

聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。

不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：

对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。

例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。


![](https://cdn.luogu.com.cn/upload/pic/30573.png)

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2 \leq k \leq n \leq 10^3$，$0 \leq  x, y \leq 10^4$。

## 样例 #1

### 输入

```
4 2
0 0
0 1
1 1
1 0
```

### 输出

```
1.00
```

## 样例 #2

### 输入

```
9 3
2 2
2 3
3 2
3 3
3 5
3 6
4 6
6 2
6 3```

### 输出

```
2.00```

# 题解

## 作者：轻尘 (赞：106)

## 一道最小生成树的变式题，
## 不知道困了我多长时间，毕竟我太弱。
#### 但作为一个蒟蒻，我还是要介绍一下我的做法。》》》

------------

## 我们把每个点看成一个部落，每次取最小距离的两个抱团，同时部落也减少了一个....然后减减减，直到部落数==目标数，此时下一个不同部落的距离就是最短的距离！

------------

### 是不是很好理解？
## 代码如下
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<cmath> 
const int MA = 1e7;
using namespace std;
int o,n,k,num,flag;
int fa[MA];
inline int read()
{
    int x = 0;
    char c = getchar();
	while (!isdigit(c))c = getchar();
    while(c>='0'&&c<='9')
    {
        x = x*10+c-'0';
        c = getchar();
    }
    return x;
}
struct s
{
	int x,y;double l; 
}ass[MA],e[MA];//结构体存点； 

double cmp(s x,s y)
{	return x.l < y.l;}
//比较边长；
//
int find(int a)
{
	if(fa[a]!=a)
		fa[a] = find(fa[a]);
	return fa[a];
}
void unionn(int a,int b)
{	fa[find(b)] = find(a); }
//并查集；
void kruskal()
{
	for(int i=1;i<=o;i++)
	{
		if(num==n-k) flag = 1;
		if(find(e[i].x)!=find(e[i].y))
		{
			num++;
			unionn(e[i].x,e[i].y);
		if(flag){
			printf("%.2lf",e[i].l);
			return ;//写在里面，因为要不同的部落距离；
			}	
		}
	}
}
double measure(int a,int b)//求欧几里得距离
{
	return sqrt(pow((ass[a].x-ass[b].x),2)+pow((ass[a].y-ass[b].y),2));
}

int main()
{
    n = read(),k = read();
    for(int i=1;i<=n;i++)
        ass[i].x = read(),ass[i].y = read();
    o = 0;//边数；
    for(int i=1;i<=n;i++)
        for(int j=1;j<i;j++)
        {
            if(i!=j)e[++o].x=i,e[o].y=j,e[o].l=measure(i,j); //为所有的点建边；
        }
    for(int i=1;i<=n;i++)
    	fa[i] = i;
	sort(e+1,e+1+o,cmp);
//	for(int i=1;i<=o;i++)
//		cout<<e[i].l<<endl;
	kruskal();   
    return 0;
}
```


------------
# 后记：
## 因为这种暴力的做法太朴素....
### 建边数是（n/2）*(n-1);
### n = 1000时，o = ....~~499500~~;
#### 好吧提交一下，
![C11hCj.png](https://s1.ax1x.com/2018/04/25/C11hCj.png)
### 侥幸A过 : )

---

## 作者：一叶知秋。 (赞：56)

我觉得几乎就是一道最小生成树模板啊...

题解里许多大佬都说选第n-k+1条边，可我觉得要这么讲比较容易理解

![](https://cdn.luogu.com.cn/upload/pic/53677.png)

(虚边为能选的边，实边为最小生成树)

令n=5,k=2,(1,3)<(1,2)<(3,4)<(4,5)（PS:(4,5)<(2,5)，图画错了，见谅）

然后开始分部落（被同一个三角形套住的为一个部落的）：

(1)

![](https://cdn.luogu.com.cn/upload/pic/53680.png)

这样肯定不为最优部落划分，因为他们的距离为(1,3)

(2)

![](https://cdn.luogu.com.cn/upload/pic/53682.png)

同理，这样也不行

(3)

![](https://cdn.luogu.com.cn/upload/pic/53718.png)

这样当然是不行的

所以，我们得出了这样一个结论：

要尽量选大边

所以小边要尽量在一个部落里，即下图：

![](https://cdn.luogu.com.cn/upload/pic/53719.png)

又因为有k个部落，所以可以消掉(n-1)-(k-1)条边，所以最小的为第n-k+1条边，所以就输出a[n-k+1]

代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
inline int read(){
    int r=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1,c=getchar();}
    while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+c-'0',c=getchar();
    return r*f;
}
struct E{
    int u,v;
    double dis;//记得为double
}e[10000001];
int f[10001],s_e,n,m;
int find(int x){
    if(f[x]!=x)f[x]=find(f[x]);
    return f[x];
}
inline bool cmp(E a,E b){
    return a.dis<b.dis; 
}
double a[10001];//记得为double
int x[10001],y[10001];
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)f[i]=i,x[i]=read(),y[i]=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<i;j++){
            s_e++;
            e[s_e].u=i;
            e[s_e].v=j;
            e[s_e].dis=(double)sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));//计算sqrt((x1-x2)^2+(y1-y2)^2)，即距离
        }
    sort(e+1,e+1+s_e,cmp);//最小生成树
    int i=1;
    int j=0;
    while(j<n-1){
        int fu=find(e[i].u),fv=find(e[i].v);
        double dis=e[i].dis;//记得为double
        if(fu!=fv){
            f[fu]=fv;
            j++;
            a[j]=dis;//记得为double
        }
        i++;
    }
    printf("%.2lf",a[n-m+1]);//记得是小数点后两位两位
    return 0;
}
```

---

## 作者：wjyyy (赞：33)

[到博客食用更加~~优雅~~优秀](http://www.wjyyy.top/735.html)

## 解法：
我的第一思路是**二分答案**检验，把某个距离以内的划分为同一个部落，检查是否被划分为k个部落。如果超过k个，则范围扩大，如果不超过k个（含k个），则范围缩小。因为题目要求分出k个部落，**使两两部落间最小的距离最大**。而同时，当部落多了应当控制距离增大，当部落少了控制距离减小。因此是有**单调性**的。~~（一开始并查集写错只有70分吓得我打了好长时间的对拍）~~
   
### 二分答案过程：
检查以mid为距离，枚举各个点，与点i的距离比mid小的，则与i归为一个部落。因为部落的基准点不同，也就是一个点可以因为**存在部落里一个点与之距离小于mid**而被归为一个部落。因为把各个点拉进同一个部落的点可能不同，因此我们可以用并查集做到这一点。被归为一个部落的用并查集放在一起就可以了。

#### 其他

题解里其他同学做的是用生成树来做的，就是把所有点两两互连，当做一个有$\frac{n(n-1)}2$条边的稠密图，来做最小生成树，每**拉**一个点进来就减少一个连通块，最后一个使得连通块个数减为k的边即为所求。这样在某些情况会比二分答案更优，但在稠密图用二分答案比用kruscal在时间和空间上都稍微优一些 :) 。不过比较难想，细节颇多。 

**tips：二分平方最后开根可能精度更有保证，这个题保留2位小数就无所谓了&& 发现题目图片原来有彩蛋『JSOI』啊**

## Code：
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define eps 1e-4
int c[10100],n,m;
int x[1010],y[1010];
int my_find(int x)
{
    if(c[x]==x)
        return x;
    return c[x]=my_find(c[x]);
}
bool check(double ans)
{
    for(int i=1;i<=n;i++)
        c[i]=i;
    int cnt=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])<=ans)//暂时不开根号
                c[my_find(i)]=my_find(j);
    for(int i=1;i<=n;i++)
        if(my_find(i)==i)
            cnt++;
    if(cnt<m)//框多了
        return false;
    return true;
}
int main()
{
    double mx=0.0,my=0.0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x[i],&y[i]);
        mx=mx>x[i]?mx:x[i];//减小二分上界（其实没必要）
        my=my>y[i]?my:y[i];
    }
    //二分平方，保证精度（其实也没必要）
    double l=0.0,r=mx*mx+my*my,mid;
    while(r-l>eps)
    {
        mid=(l+r)/2.0;
        if(check(mid))
            l=mid;
        else
            r=mid;
    }
    printf("%.2lf\n",sqrt(l));
    return 0;
}
```

---

## 作者：望眼浮云 (赞：20)

~~这题真没到蓝题~~大概就黄题吧

我们可以用贪心策略(其实是我不会二分)，先把所有野人之间的距离预处理一下，每次找到**最小的一条边**，把这两个野人合成一个部落，最近的两个部落的距离就会增大，总部落数-1，如果这条边连的点已经是同一个部落了，就跳过。

其实就是一个**最小生成树**，不同的是，一共有k个部落，我们只需要找n-k条边，第n-k+1条边就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
    int u,v;
    double w;
}a[1000000];
int n,f[10000],cnt,k,l;
int x[10000],y[10000];
void add(int uu,int vv,double ww)  //uu到vv的距离为ww
{a[++cnt].u=uu;a[cnt].v=vv;a[cnt].w=ww;}
bool cmp(node a1,node a2)
{return a1.w<a2.w;}
int find(int u)  //并查集
{
    if(f[u]==u) return u;
    else return f[u]=find(f[u]);
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        f[i]=i;
    for(int i=1;i<=n;i++)
        scanf("%d%d",&x[i],&y[i]);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)   //把任意两个野人的距离存起来
        {
            double s=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
            add(i,j,s);
        }
    sort(a+1,a+cnt+1,cmp);     //排序
    for(int i=1;i<=cnt;i++)    
    {
        int uu=find(a[i].u);   
        int vv=find(a[i].v);
        if(uu==vv) continue;   //边连的两点在同一个部落，跳过
        f[uu]=vv;              //连起来
        l++;                  
        if(l==n-k+1)           //第n-k+1条边为答案
        {
            printf("%.2lf",a[i].w);
            return 0;
        }
    }
    return 0;
}


```

---

## 作者：I_am_Accepted (赞：15)

发现题解区全都是带 $\log$ 的解法……要么 Kruskal 要么二分答案。咋的，**我堂堂 $O(n^2)$ Prim 不被认可吗？**

[喜提最优解 36 ms。](https://www.luogu.com.cn/record/77615656)

如其他题解所说，我们要做的是求出这个**完全图**的最小生成树（以下简称 MST）。因为 MST 上每一条边删去后两部分之间的最短距离一定就是这条边的边权本身，所以一种最优的部落划分方案就是删去 MST 中边权最大的 $k-1$ 条边。

也就是说，答案为 MST 中边权第 $k-1$ 大。

我们跑 Prim 之后边权排序即可，不会 Prim 的请出门右转百度或看代码。

**时间 $O(n^2)$。**

```cpp
//We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)
#define db double
#define N 1001
int tot=0,n,k,a[N],b[N];
bool vis[N];
db dis[N],s[N];
inline db pw(int x){return (db)x*x;}
inline db Dis(int x,int y){return sqrt(pw(a[x]-a[y])+pw(b[x]-b[y]));}
int main(){
	scanf("%d%d",&n,&k);
	For(i,1,n) scanf("%d%d",a+i,b+i);
	For(i,0,n) dis[i]=(i==1)?0:1e9;
	For(i,1,n){
		int x=0;
		For(j,1,n) if(!vis[j] && dis[j]<dis[x]) x=j;
		vis[x]=1;
		s[tot++]=dis[x];
		For(j,1,n) if(!vis[j]) dis[j]=min(dis[j],Dis(x,j));
	}
	sort(s+1,s+tot,greater<db>());
	printf("%.2lf\n",s[k-1]);
return 0;}
```

---

## 作者：zhoubaobao (赞：5)

先看看题干“使靠得最近的两个部落尽可能远离。”这明显是一个二分求最大值吗。
只要二分小数就行了。
那莫如何控制精度呢？
看看代码：
```cpp
        while(r-l>esp)
	{
		double mid=(l+r)/2;
		if(judge(mid)==0)
		{
		    r=mid;
		    ans=r;
		}
		else l=mid;
	}
```
注意这里不能让l+1或r-1。
直接让他们等于mid就行了。

注意保持精度令esp=1e-8就够了。

看完整代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int i,j,n,m;
int fa[10000];
int x[10000],y[10000];
int vis[10000];
double ans;
const double esp=1e-8;
int find(int x)
{
	if(fa[x]==x)
	{
		return x;
	}
	return fa[x]=find(fa[x]);
}
int judge(double p)
{
	int cnt=0;
	memset(vis,0,sizeof(vis));
	for(i=1;i<=n;i++)
	{
		fa[i]=i;
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			if(find(i)!=find(j)&&(sqrt(abs(x[i]-x[j])*abs(x[i]-x[j])+abs(y[i]-y[j])*abs(y[i]-y[j]))<=p))
			{
				fa[find(i)]=find(j);
			}
		}
	}
	for(i=1;i<=n;i++)
	{
		if(vis[fa[i]]==0)
		{
			vis[fa[i]]=1;
			cnt++;
		}
	}
	if(cnt>=m)
	{
		return 1;
	}
	return 0;
}
int main()
{

	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	double l=0,r=50000;
	while(r-l>esp)
	{
		double mid=(l+r)/2;
		if(judge(mid)==0)
		{
		    r=mid;
		    ans=r;
		}
		else l=mid;
	}
	printf("%.2lf",ans);
	return 0;
}
```
这样就开心的AC了

---

## 作者：VenusM1nT (赞：5)

本来看到“最近的部落尽可能远离”，瞬间想到了**二分答案**，但是因为个人太菜，想不到怎么$Check$，于是只能找别的算法

重新读题，要使“最近的最远”，当时想到的就是贪心的做法，每次把最近的两个部落合到一个部落里面去

然后瞎写了一个并查集，啥也过不去……

思考一番后，发现和并查集有关的算法，没错：$Kruskal$

考虑最小生成树的定义，用通俗的语言讲，就是在一个图中选择一些边，使图联通且边权最小，套在这题好像没啥毛病，删去的边可以看做是两个部落合在了一起

于是我们考虑怎么建边，很明显，直接大力$n^2$，建一个完全图即可

虽然说$Prim$更适用于稠密图，但是这题我不知道怎么写$Prim$啊！

还是写了万金油$Kruskal$【大雾】

这题还有一个地方要注意，就是按长度排序后只需要选择$n-k$条边，而答案则是第$n-k+1$条边的长度

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node//Kruskal标准结构体
{
	int u,v;
	double val;
	friend bool operator < (const Node &x,const Node &y)
	{
		return x.val<y.val;//重载运算符替代cmp函数
	}
}a[1000005];
int n,k,f[1005],tot;
double tx[1005],ty[1005],ans;
int Find(int x)//并查集核心函数，不谈
{
	return x==f[x]?x:f[x]=Find(f[x]);
}
void Merge(int x,int y)//将两个点合并
{
	x=Find(x);
	y=Find(y);
	if(x^y) f[x]=y;
}
double Calc(double x,double y,double xx,double yy)//计算欧几里得距离
{
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
void Kruskal()//最小生成树Kruskal，不谈
{
	int sum=0;
	bool fg=0;
	for(int i=1;i<=tot;i++)
	{
		if(sum==n-k) fg=1;//注意，只需要找n-k条边
		int p=Find(a[i].u),q=Find(a[i].v);
		if(p!=q)
		{
			sum++;
			Merge(a[i].u,a[i].v);
			if(fg)
			{
				ans=a[i].val;//答案是第n-k+1条边
				return;
			}
		}
	}
}
int main()
{
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%lf %lf",&tx[i],&ty[i]);
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
		for(int j=1;j<i;j++)
		{
			a[++tot].u=i;
			a[tot].v=j;
			a[tot].val=Calc(tx[i],ty[i],tx[j],ty[j]);//建立完全图
		}
	}
	sort(a+1,a+tot+1);
	Kruskal();//跑Kruskal计算答案
	printf("%.2lf\n",ans);//输出即可
	return 0;
}
```

---

## 作者：唔啊唔 (赞：4)

新人未写过几篇题解，请多多包涵

这道题看似二分，而本人认为krustrsl才是正解。

来看代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,x[1010],y[1010],num,father[1010];
struct edge{
	int from,to,dis;
}a[1000010]; 
#define lj (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])//红定义 
inline int v(edge a,edge b){//简单排序 
	return a.dis<b.dis; 
}
inline int find(int x){	//压缩路径 
	if(father[x]!=x)
		father[x]=find(father[x]);
	return father[x];
}
inline int f(int x){	//找到剩余部落中的最小路径 
	for(int i=x;i<=num;i++){
		int q=find(a[i].from),w=find(a[i].to);
		if(q!=w){	//不能让他们在同一部落中 
			return a[i].dis;
		}
	}
}
inline int krustral(){	//krustral的模板 
	for(register int i=1;i<=n;i++)father[i]=i;
	int k=n;
	for(register int i=1;i<=num;i++){
		if(k==m){	//从n减到m
			return f(i);
		}
		int q=find(a[i].from),w=find(a[i].to);
		if(q!=w){
			father[q]=w;
			k--;
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];	
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			num++;
			a[num].from=i;
			a[num].to=j;
			a[num].dis=lj;
		}
	}
	sort(a+1,a+1+num,v);
	double ans=sqrt(krustral());//在最后才开方 
	printf("%0.2lf",ans);
	return 0;
}
```
Thank you！

---

## 作者：tang666 (赞：2)

首先我们先来看这道题的数据规模。。

一看只有1000，那就可以乱搞了。

首先我们先暴力出每两个节点间的距离，然后利用并查集（kruskal）的思路，先sort将距离排序，将每个点自身看做是一个集合，然后从最小的开始搜，如果两点不在同一个集合，就并集，，然后集合数-1，当集合数==k时，当再搜到不在同一个集合的两个点时，这两个点之间的距离就是答案！

    
    
    
    
    
    
    
    
    
    
            
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef double dd;
    const int maxn=1010;
    dd ans;
    int fa[maxn],n,k,cnt;
    const dd eps=1e-5;
    //边结构体
    struct ed{
        int next,to;
        dd w;    
    }e[maxn*maxn];
    //点结构体
    struct point{
        dd x, y;    
    }g[maxn];
    //求两点间的距离
    dd f(int a,int b){
        return sqrt((g[a].x-g[b].x)*(g[a].x-g[b].x)+(g[a].y-g[b].y)*(g[a].y-g[b].y));    
    } 
    bool cm(ed a,ed b){
        return a.w<b.w+eps;    
    }
    //并查集找father
    int ffa(int a){
        return fa[a]==a?a:fa[a]=ffa(fa[a]);        
    }
    //判断是否在一个集合
    bool pan(int a,int b){
        if(ffa(a)==ffa(b))
            return 1;
        return 0;
    }    
    //并集
    void connect(int a,int b){
        fa[ffa(b)]=ffa(a);
    }    
    int main()
    {
        scanf("%d%d",&n,&k);
        for(int i=1;i<=n;i++)
            scanf("%lf%lf",&g[i].x,&g[i].y);    
        for(int i=1;i<n;i++)
            for(int j=i+1;j<=n;j++){
                e[++cnt].w=f(i,j);    
                e[cnt].next=i;
                e[cnt].to=j;
            }
        sort(e+1,e+cnt+1,cm);
        int t=n;
        //初始化
        for(int i=1;i<=n;i++)    
            fa[i]=i;
        for(int i=1;i<=cnt;i++){
            //找下一次不在同一个集合的两个点
            if(t<=k){
                for(int j=i;j<=cnt;j++)
                    if(!pan(e[j].next,e[j].to)){
                        ans=e[j].w;
                        break;    
                    }    
                break;
            }
            if(!pan(e[i].next,e[i].to)){
                t--;
                connect(e[i].next,e[i].to);    
            }    
        }
        printf("%.2lf",ans);
        return 0;    
}
```

---

## 作者：Patrickpwq (赞：2)

显然最近的两个部落的距离是有单调性的 因此可以二分

考虑check 我们遍历所有点 先把<=limit的点连起来 这样是肯定可以划分在一个部落里的 再用并查集维护一下

然后扫一遍 如果father[i]=i 说明就有一个部落

注意double

```cpp
#include<bits/stdc++.h>
#define N 1005
#define eps 1e-6
using namespace std;
template<class T>
inline void read(T &x)
{
    x=0;
    static char ch=getchar();
    while(ch<'0'||ch>'9')   ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
}
int n,k;
double dis[N][N];
struct P
{
    double x,y;
}point[N];
inline double calc_dis(int i,int j)
{
    return sqrt((point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y));
}
int father[N];
inline int getfather(int x)
{
    if(father[x]==x)    return x;
    father[x]=getfather(father[x]);
    return father[x];
}
inline bool check(double limit)
{
    for(int i=1;i<=n;i++)   father[i]=i;
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            if(dis[i][j]>limit) continue;
            int fa1=getfather(i),fa2=getfather(j);
            if(fa1!=fa2)    father[fa1]=fa2;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        if(father[i]==i)    ans++;
    return ans>=k;
}
int main()
{
    read(n);    read(k);
    for(int i=1;i<=n;i++) read(point[i].x), read(point[i].y);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            dis[i][j]=calc_dis(i,j); 
    double l=0,r=100000;
    while(l+eps<=r)
    {
        double m=(l+r)/2;
        if(check(m))    l=m;
        else r=m;   
    }
    cout<<fixed<<setprecision(2)<<l;
    return 0;
}
```

---

## 作者：zhn_666 (赞：1)

题解：
一开始看到这个题的时候，初步猜想可能是二分，

毕竟是最小值最大，于是开始思考怎么二分，

考虑的过程中发现，我们把距离小的点放一堆，组成一个部落，这样最小值一定是最大的（突然发现变成了贪心

那怎么把边权小的先连起来呢？
很简单，最小生成树啦

因为要分成K个部落，所以很容易的知道，把n-k+1一个部落连起来肯定是最优的，然后就变成模板题了QAQ

~~求管理员让我发个题解~~

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#define N 1006
#define fo(i) for(int i=1;i<=n;i++)
#define Fo(j) for(int j=1;j<=n;j++)
using namespace std;
const int M=2000005;
int n,k,tot,fa[N];
struct NODE{
	int x,y;
}dian[N];
struct node{
	int x,y;
	double z;
	bool operator <(const node &a){
		return this->z <a.z;
	}
}bian[M];
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
inline double cal(int a,int b){
	return (double)(sqrt((double)((dian[a].x-dian[b].x)*(dian[a].x-dian[b].x))+(double)((dian[a].y-dian[b].y)*(dian[a].y-dian[b].y))));
}
inline void init(){
	for(int i=1;i<=n;i++) fa[i]=i;
	fo(i) dian[i].x=read(),dian[i].y=read();
	fo(i){
		Fo(j){
			if(i<j){
				++tot;
				bian[tot].x=i;
				bian[tot].y=j;
				bian[tot].z=cal(i,j); 
			}
		}
	}
	sort(bian+1,bian+tot+1);
}
int find(int x){
	if(fa[x]==x) return fa[x];
	return find(fa[x]);
}
inline void kruskal(){
	int cnt=0;
	for(int i=1;i<=tot;i++){
		if(fa[find(bian[i].x)]!=fa[find(bian[i].y)]){
			cnt++;
			fa[find(bian[i].x)]=fa[find(bian[i].y)];
		}
		if(cnt==n-k+1){
			printf("%.2lf",bian[i].z);
			return ;
		}
	}
}
int main(){
	n=read();k=read();
	init();
	kruskal();
	return 0;
} 
```


---

## 作者：abandentsky (赞：1)

题意：题目的意思很简单给你给出n个点，让你划分成m个集合。现在问你集合之
      间最短距离最大是多少。
思路：思路所有题解都是最小生成树。
      可以考虑每次合并两个点，最后剩下的正好是m个集合嘛。
坑点：不是合并完n-m条边后的一条边，而是合并第n-m+1前的边。注意代码的第
      74行。
      
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 1200
#define MAXP 55
#define maxnode 50010
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
#define lc  (id<<1)
#define rc  (id<<1|1)
using namespace std;
typedef long long LL;

int n,m;
struct poin
{
    int x,y;
    poin(int x=0,int y=0):x(x),y(y){};
};
poin point[MAXN];
int pre[MAXN];
struct Edge
{
    int from,to;
    double dist;
    Edge(int from=0,int to=0,double dist=0):from(from),to(to),dist(dist){};
};
vector<Edge> edges;

void init(int n)
{
    for(int i=0;i<=n;i++)
        pre[i]=i;
}

int Find(int x)
{
    return pre[x]==x?x:pre[x]=Find(pre[x]);
}

bool comp(Edge A,Edge B)
{
    return A.dist<B.dist;
}

int main()
{
    scanf("%d %d",&n,&m);
    int u,v,w;
    init(n);
    for(int i=0;i<n;i++)
    {
       scanf("%d %d",&point[i].x,&point[i].y);
    }
    for(int i=0;i<n;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            double pp=(point[i].x-point[j].x)*(point[i].x-point[j].x)*1.0+(point[i].y-point[j].y)*(point[i].y-point[j].y)*1.0;
            pp=sqrt(pp);
            edges.push_back({i,j,pp});
        }
    }
    sort(edges.begin(),edges.end(),comp);
    m=n-m;
    int ans=0;
    for(int i=0;i<edges.size();i++)
    {
        Edge &e=edges[i];
        int xx=Find(e.from);
        int yy=Find(e.to);
        if(xx!=yy)
        {
            if(ans==m)
            {
                printf("%.2lf\n",e.dist);
                break;
            }
            pre[xx]=yy;
            ans++;
        }
    }
    return 0;
}

```


---

## 作者：moye到碗里来 (赞：1)

明显的kruskal的裸题，仔细想想kruskal的定义，每一次连边是把两个联通块连在一起，所以每一次连边减少一个联通块，由于kruskal的性质显然再连一次的边就是答案
```
#include<bits/stdc++.h>
using namespace std;
const int  MAXN = 1000 + 5;
int n,k;
int x[MAXN],y[MAXN];
struct node{
	double len;
	int x,y;
}len[500000];
double getlen(int x,int y){
	return sqrt(x * x + y * y);
}
int fa[MAXN];
int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}
bool cmp(node a,node b){return a.len < b.len;}
int main()
{
	freopen("group.in","r",stdin);
	freopen("group.out","w",stdout);
	scanf("%d %d",&n,&k);
	for(int i = 1; i <= n; ++i){
		scanf("%d %d",&x[i],&y[i]);
		fa[i] = i;
	}
	int cnt = 0;
	for(int i = 1; i <= n; ++i){
		for(int j = i + 1; j <= n; ++j){
			len[++cnt] = (node){getlen(x[i] - x[j],y[i] - y[j]),i,j};
		}
	}
	sort(len + 1,len + 1 + cnt,cmp);
	int ans = 0,tot = n - k + 1;
	for(int i = 1; i <= cnt; ++i){
		int  x1 = find(len[i].x),y1 = find(len[i].y);
		if(x1 == y1)continue;
		tot --;
		fa[y1] = x1;
		if(tot == 0){
			printf("%.2lf",len[i].len);
			break;
		}
	}
	return 0;
}	
```

---

## 作者：ww3113306 (赞：1)

一遍A了这道题，，，表示还是很开心的，
贡献一篇没有double变量的题解（其实只是一个小小的卡常）
但是还是比较快，
混进了第一版
思路还是比较巧妙，
将求最小值最大转换为用kruskal去掉小边，最后就会留下最优的边
	#include<bits/stdc++.h>
	using namespace std;
	#define AC 1000010
	#define R register int
	struct abc{
		int f,w,length;
	}way[AC];
	int n,k,x[1010],y[1010],now;
	int father[1010],tot,cnt;//tot为已经消除的并查集个数，
	
	bool cmp(abc a,abc b)
	{
		return a.length<b.length;
	}
	
	inline int find(int x)
	{
		if(father[x]==x)	return x;
		else return father[x]=find(father[x]);
	}

	inline int read()
	{
		int x=0;char c;
		while(isspace(c=getchar()));
		while(c>='0' && c<='9')x=x*10+c-'0',c=getchar();
		return x;
	}

	void kruskal()
	{
		int father1,father2;
		for(R i=1;i<=cnt;i++)
		{
			father1=find(way[i].f),father2=find(way[i].w);
			if(father1!=father2)
			{
				tot++;
				if(father1<father2)	father[father2]=father1;
				else father[father1]=father2;
				if(n-tot==k)//合并到k个集合就退出 
				{
					now=i+1;//搜索答案从now开始，因为之前没有选的边都是因为在同一个集合内
					break;//而这里要统计的是不同部落的距离
				}
			}
		}
	}

	void pre()
	{
		n=read(),k=read();
		for(R i=1;i<=n;i++)	x[i]=read(),y[i]=read(),father[i]=i;
		for(R i=1;i<=n;i++)
		for(R j=i+1;j<=n;j++)
			{
				way[++cnt].f=i,way[cnt].w=j;
				way[cnt].length=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
			}//非真实距离
		sort(way+1,way+cnt+1,cmp);
	}

	void work()
	{
		kruskal();
		for(R i=now;i<=cnt;i++)
		{
			if(find(way[i].f) != find(way[i].w))
			{
				printf("%.2f\n",sqrt((double)way[i].length));
				exit(0);
			}
		}
	}

	int main()
	{
		freopen("in.in","r",stdin);
		pre();
		work();
		fclose(stdin);
		return 0;
	}

---

## 作者：盧鋅 (赞：0)

### 某位巨佬（NOIP复赛595分）把这道题定义为**模板题**
 ~~究竟是二分模板呢还是最小生成树（Kruskal）模板呢（手动滑稽）~~
 
 _也可见这道题目的重要性_ （作为一个蒟蒻，我表示很无助啊）
 
 好多巨佬都分享了这道题的解决方法，当然我也没什么更好的方法，无非就是二分答案和Kruskal。而且我的做法十分不出色，几乎TLE。
 
我究竟干了什么？？？

1.递归快速幂(计算距离时平方，很明显这个东西很傻，~~但是我就是想写~~)
```
in int kmod(int a,int n)
{
	if(n==0)return 1;
	if(n==1)return a;
	int c=kmod(a,n/2);
	if(n%2==1)return c*c*a;
	else return c*c; 
}
```
2.快读（据说位运算会快点）
```cpp
in int read(){
	int x=0;bool y=0;char ch;
	while(!isdigit(ch)){
		if(ch=='-')y=1;
		ch=getchar();}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();}
	return y?-x:x;
}
```
3.结构体构造函数初始化（这个好像用的人少分享下，那位巨佬教的）
```
struct edge{
	double len;
	int u,v;
	edge(double _len=0,int _u=0,int _v=0){
	len=_len;u=_u;v=_v;}
}e[maxn*maxn<<1];
```
```cpp
struct node{
	int x,y;
	node(int _x=0,int _y=0)
	{
		x=_x;y=_y;
	}
}a[maxn];
```
4.定义了一个比较函数（const与&并用，据说会快）
```cpp
in bool cmp(const edge &x,const edge &y)
{
	return x.len<y.len;
 } 
```
5.内联函数（会有常数优化，emmm，宏定义下in，方便，加在函数开头）
```cpp
#define in inline
```
6.register（继续优化）
```cpp
#define re rigister
for(re int i=1;;i++)
```
因为~~NOIP~~（已死）是不开O2的，所以本来开氧气能AC，不开氧气会TLE的程序就有了这些东西（很蠢）。

很明显以上有些做法在这道题中不可取，希望大家慎重采用。
------------
思想就是用某K算法从N块构造到到只剩K块，下一条边即求的值。
然后分享下是多么睿（ruo）智做法（最终的AC代码），竟然会TLE。
```cpp
#include<iostream>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<cmath> 
#include<algorithm>
//#include<bits/stdc++.h>
//#define ll long long
#define re register
#define in inline
#define maxn 1234
using namespace std;
int f[maxn];//并查集
int n,m,cnt=0;
in int kmod(int a,int n)//快速幂（不取模）
{
	if(n==0)return 1;
	if(n==1)return a;
	int c=kmod(a,n/2);
	if(n%2==1)return c*c*a;
	else return c*c; 
}
in int read(){//快读？？优化
	int x=0;bool y=0;char ch;
	while(!isdigit(ch)){
		if(ch=='-')y=1;
		ch=getchar();}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();}
	return y?-x:x;
}
struct edge{//包含构造函数
	double len;
	int u,v;
	edge(double _len=0,int _u=0,int _v=0){
	len=_len;u=_u;v=_v;}
}e[maxn*maxn<<1];
in bool cmp(const edge &x,const edge &y)//比较函数
{
	return x.len<y.len;
 } 
struct node{
	int x,y;
	node(int _x=0,int _y=0)//构造函数
	{
		x=_x;y=_y;
	}
}a[maxn];
in double relen(const node &x,const node &y){
//计算距离（最蠢快速幂的存在）
	return sqrt(kmod((x.x-y.x),2)+kmod((x.y-y.y),2));
}
in int getf(int u)//并查集路径压缩
{
	return u==f[u]?u:f[u]=getf(f[u]); 
}
int main()
{
	n=read();m=read();
	for(re int i=1;i<=n;i++)a[i]=node(read(),read());//读点
	for(re int i=1;i<=n;i++)
	for(re int j=1;j<=n;j++)
	{
		if(i==j)continue;
		e[++cnt]=edge(relen(a[i],a[j]),i,j);
        //建边，如此稠密以至于完全图emmm
        /*为什么不是i:1—>n;j:i-1—>n呢？好像无向图建树其实只用一条边就好，反正建树不计方向，但是它WA了。*/
	}
	sort(e+1,e+1+cnt,cmp);//对边权排序
	for(re int i=1;i<=n;i++)f[i]=i;//并查集初始化
	int nu=0;int i;//很蠢，用nu记录构造路径的条数，用i自增
	for(i=1;;i++)
	{
		int u=e[i].u,v=e[i].v;
		int fu=getf(u),fv=getf(v);
		if(fu==fv)continue;f[fu]=fv;
     //判断边的两端点是否联通，若联通就直接进入下一次循环不计数。
		if(++nu==n-m+1)break;//终止条件
	}
	printf("%.2lf",e[i].len);//最后输出一下
	return 0; 
}
```
蒟蒻题解，望大佬指教。




---


# 斐波那契数列

## 题目描述

大家都知道，斐波那契数列是满足如下性质的一个数列：

$$F_n = \left\{\begin{aligned} 1 \space (n \le 2) \\ F_{n-1}+F_{n-2} \space (n\ge 3) \end{aligned}\right.$$


请你求出 $F_n \bmod 10^9 + 7$ 的值。


## 说明/提示

【数据范围】    
对于 $60\%$ 的数据，$1\le n \le 92$；   
对于 $100\%$ 的数据，$1\le n < 2^{63}$。


## 样例 #1

### 输入

```
5```

### 输出

```
5```

## 样例 #2

### 输入

```
10```

### 输出

```
55```

# 题解

## 作者：Anguei (赞：293)

感觉这道题现有的题解写的有点麻烦，解释不是非常清楚，所以这篇题解诞生了。

（本题解部分内容同步发表在 [OI-Wiki](https://oi-wiki.org/math/matrix/)）

---

## 前置知识：矩阵乘法

设 $A$ 为 $P \times M$ 的矩阵，$B$ 为 $M \times Q$ 的矩阵，设矩阵 $C$ 为矩阵 $A$ 与 $B$ 的乘积，

其中矩阵 $C$ 中的第 $i$ 行第 $j$ 列元素可以表示为：

$$ C_{i,j} = \sum_{k=1}^MA_{i,k}B_{k,j} $$

如果没看懂上面的式子，没关系。通俗的讲，在矩阵乘法中，结果 $C$ 矩阵的第 $i$ 行第 $j$ 列的数，就是由矩阵 $A$ 第 $i$ 行 $M$ 个数与矩阵 $B$ 第 $j$ 列 $M$ 个数分别相乘再相加得到的。

---

## 本题文字题解

斐波那契数列（Fibonacci Sequence）大家应该都非常的熟悉了。在斐波那契数列当中，$F_1 = F_2 = 1$，$F_i = F_{i - 1} + F_{i - 2}(i \geq 3)$。

如果有一道题目让你求斐波那契数列第 $n$ 项的值，最简单的方法莫过于直接递推了。但是如果 $n$ 的范围达到了 $10^{18}$ 级别，递推就不行了，稳 TLE。考虑矩阵加速递推。

设 $Fib(n)$ 表示一个 $1 \times 2$ 的矩阵 $\left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$。我们希望根据 $Fib(n-1)=\left[ \begin{array}{ccc}F_{n-1} & F_{n-2} \end{array}\right]$ 推出 $Fib(n)$。

试推导一个矩阵 $\text{base}$，使 $Fib(n-1) \times \text{base} = Fib(n)$，即 $\left[\begin{array}{ccc}F_{n-1} & F_{n-2}\end{array}\right] \times \text{base} = \left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$。

怎么推呢？因为 $F_n=F_{n-1}+F_{n-2}$，所以 $\text{base}$ 矩阵第一列应该是 $\left[\begin{array}{ccc} 1 \\ 1 \end{array}\right]$，这样在进行矩阵乘法运算的时候才能令 $F_{n-1}$ 与 $F_{n-2}$ 相加，从而得出 $F_n$。同理，为了得出 $F_{n-1}$，矩阵 $\text{base}$ 的第二列应该为 $\left[\begin{array}{ccc} 1 \\ 0 \end{array}\right]$。

综上所述：$\text{base} = \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]$ ，原式化为 $\left[\begin{array}{ccc}F_{n-1} & F_{n-2}\end{array}\right] \times \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right] = \left[ \begin{array}{ccc}F_n & F_{n-1} \end{array}\right]$

转化为代码，应该怎么求呢？

定义初始矩阵 $\text{ans} = \left[\begin{array}{ccc}F_2 & F_1\end{array}\right] = \left[\begin{array}{ccc}1 & 1\end{array}\right], \text{base} = \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]$。那么，$F_n$ 就等于 $\text{ans} \times \text{base}^{n-2}$ 这个矩阵的第一行第一列元素，也就是 $\left[\begin{array}{ccc}1 & 1\end{array}\right] \times \left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]^{n-2}$ 的第一行第一列元素。

注意，矩阵乘法不满足交换律，所以一定不能写成 $\left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]^{n-2} \times \left[\begin{array}{ccc}1 & 1\end{array}\right]$ 的第一行第一列元素。另外，对于 $n \leq 2$ 的情况，直接输出 $1$ 即可，不需要执行矩阵快速幂。

为什么要乘上 $\text{base}$ 矩阵的 $n-2$ 次方而不是 $n$ 次方呢？因为 $F_1, F_2$ 是不需要进行矩阵乘法就能求的。也就是说，如果只进行一次乘法，就已经求出 $F_3$ 了。如果还不是很理解为什么幂是 $n-2$，建议手算一下。

下面是求斐波那契数列第 $n$ 项对 $10^9+7$ 取模的示例代码（核心部分）。

## 示例代码（核心部分）
```cpp
const int mod = 1000000007;

struct Matrix {
    int a[3][3];
    Matrix() { memset(a, 0, sizeof a); } // 构造函数，矩阵初始化全零
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        for (int i = 1; i <= 2; ++i)
            for (int j = 1; j <= 2; ++j)
                for (int k = 1; k <= 2; ++k)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
        return res;
    }
} ans, base;

void init() { // 初始化 ans、base 矩阵
    base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;
    ans.a[1][1] = ans.a[1][2] = 1;
}

void qpow(int b) { // 求
    while (b) {
        if (b & 1) ans = ans * base;
        base = base * base;
        b >>= 1;
    }
}

int main() {
    int n = read();
    if (n <= 2) return puts("1"), 0;
    init();
    qpow(n - 2);
    println(ans.a[1][1] % mod);
}
```

---

如还有不懂的地方，可以在评论区提出来，或者直接私信我。

---

## 作者：虞皓翔 (赞：208)

##在此介绍一种不用矩阵的方法（为不会矩阵的小朋友发放福利）：

就是利用Fibonacci递推公式：

**F[2n] = F[n+1]² - F[n-1]² = (2F[n-1] + F[n]) · F[n]    ①**

**F[2n+1] = F[n+1]² + F[n]²                ②**

证明略，用数学归纳法可以证明。

即利用减半方法来实现，当然，如果这样递推，是会超时的。

但是，可以看一看：

如果计算F[100]，就要计算F[50]和F[49]，

然后两个分支递推的都是F[25]和F[24]，**所以我们可以利用map（数组空间不够）来暂时存储所需要的数据。**

因为计算的大都是F[n/2ⁱ±1,2]之类的，所以map所需的空间仅有C·lgn(C为常数)，轻松AC。


代码君如下：

```cpp
#include <bits/stdc++.h>
#define mod 1000000007LL
using namespace std;

typedef long long LL;
typedef pair <LL, LL> pr;

LL n;
map <LL, LL> m;
map <LL, LL> :: iterator it;

LL F(LL i){
    LL res1, res2, res;
    if(i < 3) return 1LL; //F[1] = F[2] = 1
    it = m.find(i);
    if(it == m.end()){ //未算过
        if(i & 1){ //奇数使用公式②
            res1 = F(i >> 1);
            res2 = F(i + 1 >> 1);
            res = (res1 * res1 + res2 * res2) % mod;
        }else{ //偶数使用公式①
            res1 = F(i - 2 >> 1);
            res2 = F(i >> 1);
            res = ((res1 << 1) + res2) * res2 % mod; //注意移位的优先级比加减低
        }
        m.insert(pr(i, res)); //插入
        return res;
    }else
        return it -> second; //算过直接返回
}

int main(){
    scanf("%lld", &n);
    printf("%lld\n", F(n));
    return 0;
}
```

但是话说回来，这种方法的效率会比矩阵法略低（输在map上），所以还是建议大家学一学矩阵快速幂吧！


---

## 作者：憧憬未来 (赞：88)


斐波那契数列？直接f[i]=f[i-1]+f[i-2]不就行了吗？怎么提高+的难度？（其实真没有这么难）突然发现n在long long范围内...这...连线性都不行？嗯......怪不得要用矩阵的，那接下来我就来说说如何用矩阵解决这题：

首先，做这题要懂矩阵乘法：我们假设有一个n\*m的矩阵A和一个m\*p的矩阵B，那么它们相乘可以得到一个n\*p的矩阵C，则C[i][j]等于矩阵A的第i行与矩阵B的第j行的乘积和，即 ![](https://cdn.luogu.com.cn/upload/pic/11033.png) 。那么这样的矩阵乘法有什么意义呢？

对于这个问题，我们考虑以下的线性方程组：

 ![](https://cdn.luogu.com.cn/upload/pic/11034.png) 

现在我们将a作为矩阵A的元素，b作为矩阵B的元素，c作为矩阵C的元素。根据矩阵乘法，那么就有以下关系：

 ![](https://cdn.luogu.com.cn/upload/pic/11035.png) 

这样以上方程组就可以简写为AB = C。我们仔细分析这个式子，可以发现矩阵A相当于一种变换方式，它把列向量B变为了列向量C。同理，对于这题，我们是否可以考虑构造一个矩阵A，将当前的状态乘以它来得到下一个状态？答案是可以的。

既然这样，我们现在考虑构造矩阵（比矩阵加速模板的矩阵好构建多了）。对于递推关系式f[i]=f[i-1]+f[i-2]，我们发现影响f[i]最早的状态是f[i-2]，相当于我们用f[i-2]更新过f[i]后，这个状态就可以不要了，但f[i-1]还得留着，因为他还要去更新f[i+1]，所以我们构造的矩阵应该是2\*2的。
构造好的矩阵先放这，我下面详细解释：

 ![](https://cdn.luogu.com.cn/upload/pic/11036.png) 

好，现在我们再建立一个列向量B（数组存储），存储在当前状态下我们仍然需要的两个斐波那契数列里的数值（f2是f1的下一个）：

 ![](https://cdn.luogu.com.cn/upload/pic/11037.png) 

现在我们再来一次矩阵乘法，得到以下两个式子：

 ![](https://cdn.luogu.com.cn/upload/pic/11040.png) 

关系已经很明显了，根据斐波那契数列，第一个式子的值就等于f2的下一个斐波那契值f3，而原来f1位置上的值也更新成了f2（因为f1已经不需要再用到了）

总结一下，有了这个我们构造好的矩阵，我们每乘一次，就会得到斐波那契数列的下一项。也许你会问：用矩阵乘法的效率还不如直接递推呢！表面上是这样，但不要忘了，还有矩阵快速幂哦。如果我们想得到斐波那契的第n（除开头的1、1）项，那么我们就可以用列向量B的初值（即1、1）乘以n个构造矩阵。由于矩阵乘法满足结合律，我们可以先将n个构造矩阵乘起来（这里就可以套用矩阵快速幂的模板啦），然后将所得到的矩阵再乘以列向量B，就可以得到斐波那契数列的第n项啦。

那个......矩阵快速幂我在这就不讲了......可以去参考一些资料，其实跟普通的快速幂没差多少......

代码如下：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
long long n,a[3],mul[3][3],res[3][3],tmp[3][3],tp[3];
void mul_1()
{
    memset(tmp,0,sizeof(tmp));
    for(register int i=1;i<=2;i+=1)
        for(register int j=1;j<=2;j+=1)
            for(register int k=1;k<=2;k+=1)
                tmp[i][j]=(tmp[i][j]+res[i][k]*mul[k][j])%1000000007;
    for(register int i=1;i<=2;i+=1)
        for(register int j=1;j<=2;j+=1)
            res[i][j]=tmp[i][j];
}
void mul_2()
{
    memset(tmp,0,sizeof(tmp));
    for(register int i=1;i<=2;i+=1)
        for(register int j=1;j<=2;j+=1)
            for(register int k=1;k<=2;k+=1)
                tmp[i][j]=(tmp[i][j]+mul[i][k]*mul[k][j])%1000000007;
    for(register int i=1;i<=2;i+=1)
        for(register int j=1;j<=2;j+=1)
            mul[i][j]=tmp[i][j];
}
void solve()
{
    for(register int i=1;i<=2;i+=1)
        for(register int j=1;j<=2;j+=1)
            tp[i]=(tp[i]+res[i][j]*a[j])%1000000007;
    printf("%lld\n",tp[1]);
}
int main()
{
    scanf("%lld",&n);
    if(n<=2)printf("1\n");
    else
    {
        a[1]=a[2]=1;
        for(register int i=1;i<=2;i+=1)
            res[i][i]=1;
        for(register int i=1;i<=2;i+=1)
            for(register int j=1;j<=2;j+=1)
                mul[i][j]=1;
        mul[2][2]=0;
        n-=2;
        while(n)
        {
            if(n&1)mul_1();
            n>>=1;
            mul_2();
        }
        solve();
    }
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：82)

## 扩域大法好！  
一看这题的题解，清一色的都是矩阵快速幂。  
我来一篇扩域的题解吧！

首先，我们都知道$\text{fibonacci}$数列通项公式是这个：  
$$\large \text{F}_n=\frac{1}{\sqrt 5}((\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n)$$  

然后我们发现$5$在模$10^9+7$意义下是没有二次剩余的。。  
那这怎么办？我们要引入一种黑科技：**扩域**  

何谓扩域？我们先回想一下复数。  
复数一般表示为$a+bi$的形式。  
其中$a$为实部，$b$为虚部，$i^2=-1$  

谁说虚数单位一定要是$i$了？  
我们自创一种复数，它的虚数单位为$\sqrt5$。(然而它实际上还是实数)  
于是，我们把实数都可以表示为$a+b\sqrt 5$的形式。  

如此一来，我们就可以在模$10^9+7$意义下算这个东西了！  
关于这种数的具体运算法则，和普通的复数差不多。  
例如乘法是这样的：  
$$\large (a+b\sqrt 5)(c+d\sqrt 5)=ac+5bd+(ad+bc)\sqrt 5$$  
你会发现最后还有个除$\sqrt 5$，好像不太好搞。  
不过别慌，我们可以证明最后算出的结果，实部必为$0$。  
所以答案就是虚部的系数啦！

Code：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#define reg register
#define N 200003
#define inf 0x3f3f3f3f
#define int long long
#define p 1000000007
#define inv2 500000004
using namespace std;

struct complex{ //我们自定义的复数,表示为a+b*sqrt(5)
    int a,b;
    complex(int a=0,int b=0):a(a),b(b){}

    complex operator + (const complex& x) const{
        complex res;
        res.a = (a+x.a)%p;
        res.b = (b+x.b)%p;
        return res;
    }
    complex operator - (const complex& x) const{
        complex res;
        res.a = (a-x.a+p)%p;
        res.b = (b-x.b+p)%p;
        return res;
    }
    complex operator * (const complex& x) const{
        complex res;
        res.a = (a*x.a+5*b*x.b)%p;
        res.b = (a*x.b+x.a*b)%p;
        return res;
    }
};

inline complex power(complex a,int t){
    complex res = complex(1,0); //直接快速幂
    while(t){
        if(t&1) res = res*a;
        a = a*a;
        t >>= 1;
    }
    return res;
}

int n,ans;
complex x,y,res;

signed main(){
    scanf("%lld",&n);
    x = complex(inv2,inv2);
    y = complex(inv2,p-inv2);
    x = power(x,n);
    y = power(y,n);
    res = x-y;
    ans = res.b;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：benny (赞：48)

本人提供一种**0ms**的数学方法（pascal），时间复杂度为** lg(n)**。**不是**通项公式，先看代码：

···pascal

```cpp
var n,x,y,t:qword;
g:real;
procedure p(a:qword);  
begin
  if a=2 then
    begin
      x:=1; y:=1;
    end else
  if a mod 2=0 then
    begin
      p(a div 2);
      t:=x*x+2*x*y;
      y:=x*x+y*y;
      x:=t;
    end else
    begin
      p(a-1);
      t:=x+y;
      y:=x;
      x:=t;
    end;
  x:=x mod 1000000007;
  y:=y mod 1000000007;
  //writeln(a,',',x,' ',a-1,',',y); readln;
end;
begin
  readln(n);
  if n=1 then
    begin
      writeln(1);
      halt;
    end;
  p(n);
  writeln(x);
  // g:=sqrt(5);
  //writeln(1/g*(c((1+g)/2,n)-c((1-g)/2,n)));
end.
```
···
看看我的公式吧：

**f(x)=f(x/2)^2 +2\*f(x/2)\*f(x/2-1)   [x偶数]**

**f(x)=f(x/2+0.5)^2+f(x/2-0.5)^2   [x奇数]**

怎么推的呢？

先看一个表吧


55  34  21 13  8  5  3  2  1  1  数列倒过来

10   9    8   7   6  5  4  3  2  1  编号

```cpp
  1                                           1个f(10)
  0    1   1                                 f(9)+f(8) =f(10)
  0    0   2  1                            （把f (9)=f(8)+f(7) 代入上式） 2f(8)+f(7)  =f(10
  0    0   0  3    2                      （把f (8)=f(7)+f(6) 代入上式） 3f(7)+2f(6)   =f(10)
  0    0   0  0    5  3                    5f(6)+3f(5)   =f(10)
```
正好，表中又藏了一个斐波那契，不难推出：
f(10)=f(5)\*f(6)+f(4)\*f(5)

消元：

f(5)\*f(6)+f(4)\*f(5)=f(5)\*(  f(5)+f(4)  )+f(4)\*f(5)

化简、推广得：

f(x)=f(x/2)^2 +2\*f(x/2)\*f(x/2-1)   [x偶数]

奇数再列表找规律，就可又获得一个公式：

f(x)=f(x/2+0.5)^2+f(x/2-0.5)^2   [x奇数]

把数列中相邻两个数看作“一对”，上面两个公式都是：

已知一对数，能求一个数，

比如
已知f(5)=5,f(4)=3，就能用公式1求出f(10), 用公式2求出f(9)

**这样，已知一对数，就能求出另一对数；已知 f(x),f(x-1) ，就能求 f(2x),f(2x-1)**

最后处理一下奇偶性问题，处理一下边界f(1)=1，即可


我的程序是用递归实现，p过程的意图是：

给出一个a，把f(a)的值赋给x，把f(a-1)的值赋给y 即

已知a，就能求出 f(a),f(a-1) 这一对数

t没有太多卵用，只作为临时变量


---

## 作者：mulberror (赞：37)

[安利](https://www.cnblogs.com/Dawn-Star/p/9807575.html)一下自己的博客

----
## 来提供两个正确的做法：
* 斐波那契数列双倍项的做法（附加证明）
* 矩阵快速幂

-----
# 一、双倍项做法
在偶然之中，在百度中翻到了有关于斐波那契数列的词条（[传送门](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin)），那么我们可以发现一个这个规律$ \frac{F_{2n}}{F_{n}}=F_{n-1}+F_{n+1} $，那么我就想到了是不是可以用这个公式实现类似于快速幂之类的东西:` power(n,m)=power(n*n,m/2)   m mod 2=0 power(n,m)=power(n*n,m/2)*n m mod 2=1 `

快速幂这个东西，是分成偶数情况和奇数情况，所以我们只是知道偶数想的计算公式，所以我们接下来要推导一下奇数项的递归式
$$ F_{2n}=F_{n}\times(F_{n-1}+F_{n+1})$$
$$ F_{2n+2}=F_{n+1}\times(F_{n}+F_{n+2})$$
那么我们就是要从$F_{2n}$和$F_{2n+2}$推导求出$F_{2n+1}$
$$ F_{2n+1}=F_{2n+2}-F_{2n} $$
$$ F_{2n+1}=F_{n+1}\times(F_{n}+F_{n+2})-F_{n}*(F_{n-1}+F_{n+1}) $$
$$ F_{2n+1}=F_{n+1}\times F_{n}+F_{n+1}\times F_{n+2} - F_{n}\times F_{n-1}-F_{n}\times F_{n+1}$$
$$ F_{2n+1}=F_{n+1}\times F_{n+2}-F_{n}\times F_{n-1}$$
$$ F_{2n+1}=F_{n+1}\times(F_{n+1}+F_{n})-F_{n}\times(F_{n+1}-F_{n})$$
$$ F_{2n+1}={F_{n+1}}^2+{F_{n}}^2 $$
以上就是我们对于这个公式的推导
那么我们就得到了

**F[2n] = F[n+1]² - F[n-1]² = (2F[n-1] + F[n]) · F[n] **

**F[2n+1] = F[n+1]² + F[n]²**

那么，我们在写一个map，那么就可以不用全部都递归到底了，优化一下。
用map映射一下大数，映射到我们的答案上。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int Mod=1e9+7;//mod数
long long n;
map<long long,long long> ma;//搞映射
inline long long work(long long x){
	if(x==1||x==0)return 1;//边界
	if(ma.count(x))return ma[x];//count如果是返回1那么就是这个答案已经在map中映射过了，0就是没有
	long long res=0,t=x/2;
	if(x&1) res=work(t)*(work(t-1)+work(t+1))%Mod;//公式2
	else res=work(t)*work(t)%Mod+work(t-1)*work(t-1)%Mod;//公式1
	return ma[x]=res;
}
int main() {//主程序
	cin>>n;
	long long res=work(n-1)%Mod;
	cout<<res<<endl;
    return 0;
}
```
#### 注：这个程序的复杂度是也差不多是log(n)，也是非常优的解法

-----
# 二、矩阵乘法解法
不管上面的邪门做法了，矩阵乘法才是正解。qwq
```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const ll P = 1000000007; 
struct mat {
	ll a[3][3]; 
	mat operator * (const mat& b) const {
		mat res; 
		for (int i = 1; i <= 2; i ++) {
			for (int j = 1; j <= 2; j ++) {
				res.a[i][j] = 0; 
				for (int k = 1; k <= 2; k ++) res.a[i][j] = ((res.a[i][j] + a[i][k] * b.a[k][j] % P) % P + P) % P;
			}
		}
		return res; 
	}
} Base;
mat qpow(mat x, ll y) {
	mat res = x; y -= 1; 
	for (; y; y >>= 1, x = x * x) if (y & 1) res = res * x; 
	return res;  
}
int main() {
	Base.a[1][1] = 1; Base.a[1][2] = 1; 
	Base.a[2][1] = 1; Base.a[2][2] = 0; 
	ll x; scanf("%lld", &x); 
	if (x <= 2) printf("1\n");
	else {
		mat res = qpow(Base, x); 
		printf("%lld\n", res.a[1][2]);
	}
	return 0;
}
```

---

## 作者：Kevin327 (赞：33)

特征方程，实际上就是为研究相应的数学对象而引入的一些等式，它因数学对象不同而不同，包括数列特征方程，矩阵特征方程，微分方程特征方程，积分方程特征方程等等。

特征根方程是数学竞赛中常用的一种解题技巧，可以处理形如

$A(x+2)=pA(x+1)+qA(x)$

这样的数列通项。

一个这样的递推数列的特征根方程就是$x^2=px+q$

有没有很熟悉的感觉？

我们令$p=1,q=1$，得出$A(x+2)=A(x+1)+A(x)$

正是我们最熟悉的$fibnacci$数列！是不是很令人激动呢？

## **先放结论**

我们定义特征根方程的根为**特征根**。

## 特征根与数列通项的关系

① 有两个不等特征根，设为$x_1,x_2$

$a_n=Mx_1^n+Nx_2^n$

② 有两个相等特征根，设为$x$

$a_n=(Px+Q)x^n$

$M,N,P,Q$为常数，根据具体情况而定，一般使用待定系数法求解。（其实有式子，但是非常复杂）

## 如何证明？

一般使用数学归纳法证明，但是较为繁琐。这里提供一种比较简洁的证明方法，根据为恒等变换。

我们令$s,r$满足 $a(n+2)-r*a(n+1)=s[a(n+1)-r*a(n)]$

那么 

$a(n+2)=(s+r)*a(n+1)-sr*a(n)$

根据韦达定理，原特征根方程的两根$x_1,x_2$满足$x1+x2=p,x1x2=-q$

那么这里的$s,r$又是什么呢？把$s,r$的定义式和原式对比一下，发现$s+r=p,sr=q$....

根据韦达定理的逆定理，这里的$s,r$就是刚才的特征根。

我们同样分刚才的两种情况考虑。

### ①$s=r$

根据一元二次方程的求根公式，**△**$=p^2+4q=0$

解得$p^2=-4q$。

我们设$p=2t$,那么$q=t^2$

我们代入原来的递推式中。那么$A(n+2)-2t·A(n+1)+t^2·A(n)=0$

$A(n+2)-t·A(n+1)=t·A(n+1)-t^2·A(n)$

$A(n+2)-t·A(n+1)=t·[A(n+1)-t·A(n)]$

看出什么了吗？

令数列$F(n)=A(n+1)-t·A(n)$,那么$F(n)$为一个等比数列，首项为$A(2)-A(1)$,公比为$t$。

那么

$A(n+1)-t·A(n)$=$[A(2)-rA(1)]*t^(n-1)$

$A(n+1)/t^(n+1)-A(n)/t^n=[A(2)/r^2-A(1)/r]$

等式右边为常数，并且我们观察到等式左边两项结构相同，均为$A(n)/t^n$，那么数列$F_2(n)$=$A(n)/t^n$为等差数列。

根据等差数列性质：

$a(n)/t^n=a(1)/t+(n-1)*[a(2)/t^2-a(1)/t]$

$a(n)=a(1)t*t^n+(n-1)*[a(2)/t^2-a(1)/t]*t^n$

$t$是什么？我们看回$t$的定义。

$p=2t$,$q=t^2$

因为两根相等，根据韦达定理，$x_1+x_2=2x=-p$

$x_1x_2=x^2=q$

那么，$2x=-2t$，$t$就是$-x$。

我们设 

$A(2)/r^2-A(1)/r=Q$ ，

再设 

$2A(1)/r-A(2)/r^2=P$

代回原式，$a_n=(Px+Q)x^n$

### ② $s≠r$

其实和刚才类似。

根据韦达定理，我们可以求得

$a(n+2)-r*a(n+1)=s[a(n+1)-r*a(n)]$

$a(n+2)-s*a(n+1)=r[a(n+1)-s*a(n)]$

根据等比数列公式，

$a(n+1)-r*a(n)=[a(2)-r*a(1)]s^(n-1)$

$a(n+1)-s*a(n)=[a(2)-s*a(1)]r^(n-1)$

相减得$a(n)=([a(2)-r*a(1)]/[s(s-r)])*s^n-([a(2)-s*a(1)]/[r(s-r)])*r^n$

换元即得

$a_n=Mx_1^n+Nx_2^n$

证毕！

## 例题

求fibonacci数列的通项公式

特征方程为：
$X^2=X+1$

解得

$X_1=\frac{1+\sqrt5}{2}$

$X_2=\frac{1-\sqrt5}{2}$

则$F(n)=M*X_1^n+N*X_2^n$


∵$F(1)=F(2)=1$

代入这两个值

解得

$M=\frac{\sqrt{5}+5}{10}$

$N=\frac{5-\sqrt{5}}{10}$

∴$F(n)=\frac{\sqrt{5}+5}{10}*{(\frac{1+\sqrt5}{2})^n}-\frac{5-\sqrt{5}}{10}*{(\frac{1-\sqrt5}{2})^n}$

怎么转换为代码？使用结构体存储一个数的$sqrt(5)$项系数和整数系数,快速幂计算平方。

分数怎么办？

我们只需要除以2和10。由于原题答案要模$1e9+7$，我们预处理出：

$10$的乘法逆元为$700000005$

$2$的乘法逆元为$500000004$

就可以愉快的打代码了！

是不是比什么矩阵乘法简单多了？（逃

```
#include<cstdio>
#include<cstring>
#define ll long long
ll mod=1000000007;
long long mo(ll x){
	return ((x%mod)+mod)%mod;
}
struct num{
	ll s5,z;//sqrt(5)项,整项
};
num mul(num x,num y)
{
	num ans;
	ans.z=mo(mo(x.z*y.z)+mo(5ll*x.s5)*y.s5);
	ans.s5=mo(mo(x.s5*y.z)+mo(x.z*y.s5));
	return ans;
}
num qpow(num x,ll y)
{
	num ans;
	ans.s5=0;ans.z=1;
	while (y){
		if (y&1) ans=mul(x,ans);
		x=mul(x,x);
		y>>=1;
	}
	return ans;
}
int main()
{
	ll n;
	scanf("%lld",&n);
	n--;
	num a,b,c,d,e,f;
	a.s5=700000005;
	c.z=a.z=b.z=b.s5=d.z=500000004;
	d.s5=mo(-500000004);
	c.s5=mo(-700000005);
	e=mul(a,qpow(b,n));
	f=mul(c,qpow(d,n));
	printf("%lld\n",mo(e.z+f.z));
	return 0;
}
```

完结撒花！

参考资料：数列通项特征根法的证明https://wenku.baidu.com/view/71b1a7bcf90f76c661371ab6.html

特别鸣谢数学竞赛大佬CYX提供了巨大的帮助！

---

## 作者：EricQian (赞：29)

直接循环递推斐波那契数列，时间复杂度显然为 $O(n)$ 。不过，$Fib_n$ 只与 $Fib_{n-1}$ 与 $Fib_{n-2}$ 有关，我们在递推的时候只需要保存最近的两个斐波那契数，即可得到下一个斐波那契数。

设 $F(n)$ 表示一个 1 * 2 的矩阵，$F(n)=[Fib_{n-1},Fib_{n-2}]$ 。

我们希望根据 $F(n-1)=[Fib_{n-1},Fib_{n-2}]$ 计算出 $F(n)$ 。也就是说，要把 $F(n-1)$ 第 1、2 列上的数都累加到 $F(n)$ 的第二列上。因此，我们令 $A$ 第 2 行第 1 列、第 2 行第 2 列、第 1 行第 2 列都是 1，第 1 行第 1 列的数是 0。

$F(n)=F(n-1) * A <=> [Fib_n,Fib_{n+1}]=[Fib_{n-1},Fib_{n-2}] * [^{0,1}_ {1,1}]$

上式是一个矩阵乘法递推式，初值 $F(n)=[0,1]$ ，目标为$F(n)=F(0) * A^n$。因为矩阵乘法满足结合律，所以我们可以用快速幂计算 $F(n) * A^n$ ,得到的矩阵第一列上的数就是 $Fib_n$ 。算法的时间复杂度为 $O(2^3log_2^n)$ ，其中 $2^3$ 是矩阵乘法所消耗的时间。

题目还要求我们对一个大数取模，可以直接在执行时加入取模运算。详细过程请见下面示例代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mol 1000000007
long long n;
long long a[2][2]={{0,1},{1,1}},A[2][2];
long long f[2]={0,1},F[2];
void muladd()
{
	 memset(F,0,sizeof(F));
	 for(int i=0;i<2;i++)
	 	 for(int k=0;k<2;k++)
	 	 	 F[i]=(F[i]+f[k]*a[k][i])%mol;
	 memcpy(f,F,sizeof(F));
	 return;
}
void mul()
{
	 memset(A,0,sizeof(A));
	 for(int i=0;i<2;i++)
	 	 for(int j=0;j<2;j++)
	 	 	 for(int k=0;k<2;k++)
	 	 	 	 A[i][j]=(A[i][j]+a[i][k]*a[k][j])%mol;
	 memcpy(a,A,sizeof(A));
	 return;
}
int main()
{
	 scanf("%lld",&n);
	 while(n) // 快速幂
	 {
	 	 if(n%2) muladd();
	 	 mul();
	 	 n/=2;
	 }
	 printf("%d\n",f[0]%mol);
     return 0;
}
```


---

## 作者：hanzhongtlx (赞：26)

     
### 似乎不用矩阵的法子讲的不太友好啊（~~面对金钩大佬瑟瑟发抖~~）     
# 那些看不懂的看这个：
言归正传吧......    
#### $1.$发现
当时学了矩阵快速幂之后，就像：你把一个好端端的数列弄成矩阵真是让人费解啊，能不能线性做呢？      
换句话来说，矩阵快速幂的复杂的是$O(8log_2N)$的，为什么呢？  
由于在计算$2*2$矩阵乘法时要进行$2*2*2$次运算（忽然感觉好尬）   
能不能优化常数？  

#### $2.$尝试着写了写   
那时就想找出递推多次后系数的规律，然后：   
设n足够大，则：

$f_n=f_{n-1}+f{n-2}$      
$f_n=f_{n-2}+f_{n-3}+f_{n-2}=2f_{n-2}+f_{n-3}$   
$f_n=3f_{n-3}+2f_{n-4}$   
$f_n=5f_{n-4}+3_{n-5}$    
$f_n=8f_{n-5}+5f_{n-6}$   
$f_n=......$    
- 
如果你还观察不到什么，那我就画个表吧：   
 
          
|  较大下标中的常数| 较大下标的系数 | 另一个系数 |
| :----------: | :----------: | :----------: |
| 1 | ${\color{red}1} $|  ${\color{black}1} $|
| 2 |${\color{green}2} $  | ${\color{red}1} $ |
| 3 | ${\color{blue}3} $ | ${\color{green}2} $ |
| 4 |  ${\color{cyan}5} $|  ${\color{blue}3} $|
| 5 | ${\color{Fuchsia}8} $ | ${\color{cyan}5} $ |
| 6 |  ......|......  |     
我们会发现两个性质     
（为了方便我们把此表设为$P$，则$P_{i,{1/2}}$表示第1/2大下标所代的第$i$次的迭代的系数）   
似乎表述的不清楚，那就举个栗子：   
$P_{1,1}={\color{red}1},P_{2,1}={\color{black}1}......$   
#### 性质一：$P_{i,1}=P_{1+1,2}(i>=1,i\in Z)$
#### 性质二：若设$\forall fib_n(n\in N^*)\in M$,则$\forall P_{i,{1/2}}\in M$   
性质二是啥意思呢？  
就是表中的后两列都是斐波那契数列中的值！！！！    
 
那我们实现一下表的公式表达（局部）：       


| $fib_1$ | $fib_1$  |
| -----------: | -----------: |
| $fib_2$  | $fib_1$  |
| $fib_3$  | $fib_2$ |
| $fib_4$  | $fib_3$  |
| $fib_5$  |  $fib_4$ |
| $fib_6$  | $fib_5$  |   
这个结论也是可证的：    
感性理解下拆式子的过程： 不就是把大下标的系数和小下标的系数相加吗？这所得的是下一次迭代的大下标系数。     
一次可总结出斐波那契数列的火箭递推式（自己起的名字，别介意啊）    
     
## $fib_n=fib_a*fib_{n-a+1}+fib_{a-1}*fib_{n-a}$

#### $3.$回到问题
那次题怎么解？   
假设我们已知 $fib_1=fib_2=1$ （还用假设？！)  
我们就可以知道当$fib_a=2$ 时的答案。   
即当上式满足：   
 $\begin{cases}a=2\\n-a+1=2\end{cases}$    
 
 解得： 
 
 $\begin{cases}a=2\\n=3\end{cases}$   
  
 也就是说得到了$fib_3=fib_2*fib_2+fib_1*fib_1$  
  
 其实就是大佬所说的：
   
F[2n] = F[n+1]² - F[n-1]² = (2F[n-1] + F[n]) · F[n] ①

F[2n+1] = F[n+1]² + F[n]² ②  
 
还是有一些不同的（呵呵）
#### $4.$其他问题
显然我们在做地推时要用两个值$fib_{a-1}$与$fib_a$,那咋办？  

~~凉拌~~  
### 求呗！
我们知道在计算$fib_n$时会用到$fib_a$与$fib_{a-1}$,  
那么：  
$fib_{n-1}=fib_a*fib_{a-1}+fib_{a-1}*fib_{a-2}$  
那$fib_{a-2}$怎么求呢？
由于已知$fib_a$与$fib_{a-1}$,可求$fib_{a-2}=fib_a-fib_{a-1}$。   
在第一次递推时可求得$fib_3$，只知道$fib_1$与$fib_2$是充足的。  
  
  
如果用火箭递推，不能直接推到$fib_n$又咋办？  
可以把前面的数存起来，到再递推回超过第$n$项时，在小范围火箭递推。

#### $5.$回到源头
你这样做时间得到优化了吗？  
我们想一想，在保证$a=n-a+1$时，不就正保证了一次递推了$2^n$的数吗？
我们假设共算了$x$次   
则有：     

 $ \sum\limits_{i=0}^x2^i$ $\leqslant  n$     
 
 根据等比公式的通项公式，可解得：    
 $x\leqslant log_2(n+1)-1 \approx logn$     
 又要算三次（$fib_a,fib_{a-1},fib_{a-2}$),所以复杂度为$O(3logn)$    
 下面讨论额外算的那些（最后的小范围递推）:  
 由于我们只需知道$fib_a$,那就可以递推一次只求两次。   
 为什么？   
 我们已经用的系数都被储存起来了，没必要求 $fib_{n-2}$。  同时$log$的空间也是充足的。  
 这些总的复杂度是不会超过$O(5logn)$(但实际上会有一些其他运算，慢一些）的。  
 
 #### $6.$code 
 ```
#include<iostream>
#include<cmath>
#include<cstdio> 
using namespace std;
inline long long read()
{
	long long x=0,w=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') w=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return x*w;
}
long long n;
const long long inf=1000000007;
struct data
{
	long long a[5];
}s[63];
struct cmp
{
	long long a[5];
}o[63]; 
long long quickpow(int a,int b)
{
	long long ans=1,base=a;
	while(b)
	{
		if(b&1) ans=ans*base;
		base=base*base;
		b>>=1;
	}
	return ans;
}
int main()
{
	n=read();
	long long r=3,cnt=1,add=1;
	s[1].a[3]=1;
	s[1].a[2]=1;
	s[1].a[1]=2;
	if(n<=3)
	{
		printf("%lld\n",s[1].a[3-n+1]);
		return 0;
	}
	while(r+add*2<=n+2)
	{
		s[cnt+1].a[1]=(s[cnt].a[1]%inf*s[cnt].a[1]%inf+s[cnt].a[2]%inf*s[cnt].a[2]%inf)%inf;
		s[cnt+1].a[2]=(s[cnt].a[1]%inf*s[cnt].a[2]%inf+s[cnt].a[2]%inf*s[cnt].a[3]%inf)%inf;
		cnt++;
		s[cnt].a[3]=(s[cnt].a[1]-s[cnt].a[2])%inf;
		if(s[cnt].a[3]<=0) s[cnt].a[3]+=inf;
		add*=2;
		r+=add;
	}
	if(r<=n+2&&r>=n)
	{
		printf("%lld\n",s[cnt].a[r-n+1]%inf);
		return 0;
	}
	long long cc=1,x;
	o[1].a[1]=s[cnt].a[1];
	o[1].a[2]=s[cnt].a[2];
	while(n-r>1)
	{
		x=log(n-r)/log(2);
		cc++;
		o[cc].a[1]=(o[cc-1].a[1]%inf*s[x].a[1]%inf+o[cc-1].a[2]%inf*s[x].a[2]%inf)%inf;
		o[cc].a[2]=(o[cc-1].a[1]%inf*s[x].a[2]%inf+o[cc-1].a[2]%inf*s[x].a[3]%inf)%inf;
		r=r+quickpow(2,x);
	}
	if(n==r)
	{
		printf("%lld\n",o[cc].a[1]%inf);
		return 0;
	}
	else
	{
		printf("%lld\n",(o[cc].a[1]+o[cc].a[2])%inf);
		return 0;
	}
}
```


---

## 作者：Viston (赞：23)

这道题实际上用通项公式没有下面那些DALAO写的繁琐，11行代码AC。
什么是斐波拉契通项公式？
设 $n\in R$,则有：
$$F[2n] = F[n+1]^2-F[n-1]^2 = (2F[n-1]+F[n])F[n]$$

$$F[2n+1] = F[n+1]^2 + F[n]^2 $$

我们可以像优化普通递归的斐波拉契数列那样优化这个斐波拉契。
但开一个数组是不行的，于是我们想到了
$map$.
于是就可以过了....
```
#include<bits/stdc++.h>
std::map<long long ,int>mmp;//STlTQL!
long long dfs(long long a){
	if(a==1||a==2) return 1;//返回条件
	if(mmp[a]!=0)  return mmp[a];   //如果已经存有值
	else return    mmp[a]=a%2==0?(dfs(a/2)+2*dfs(a/2-1))*dfs(a/2)%1000000007 :(dfs(a/2)*dfs(a/2)+dfs(a/2+1)*dfs(a/2+1))%1000000007;   //就是通项公式
}
int main(){
	long long a;std::cin>>a; //输入
	std::cout<<dfs(a);//输出
}
```

---

## 作者：Trinitrotoluene (赞：9)

这题正解应该是矩阵，~~然而我不会~~。

谈及斐波那契数列，大家肯定会想到递推。然而一看数据：n<=2^63-1，显然递推会TLE。因此，我们需要更高效的算法，如O(logN)的程序。

这时候，~~天空一声巨响~~，另一个递推公式闪亮登场：

### F(2n) = F(n)^2 + 2F(n)F(n-1)

### F(2n-1) = F(n)^2 + F(n-1)^2

这里，我将推出第一个:

F(2n) = F(2n-1) + F(2n-2) {即 F(2)F(2n-1) + F(1)F(2n-2) } = 2F(2n-2) + F(2n-3) { 即F(3)F(2n-2) + F(2)(2n-3) } = 3F(2n-2) + 2F(2n-3){ 即 F(4)F(2n-3) + F(3)(2n-4) } = ……

因此，F(2n) = F(n+1)F(n) + F(n)F(n-1)=F(n)^2 + 2F(n)F(n-1)。

另一个同理可得。

当然,数组无法开到2^63-1,而我们不需要每个都推出来,因此我们需要:map.

下面，上代码：
```cpp
温馨提示：请勿复制粘贴。 
#include<cstdio>
#include<map>
using namespace tsd;
typedef long long ll;
const int M=1e9+7;//取模 
map<ll,ll>a； 
ll g(ll x)	{return x*x%M;}//平方 
ll f(ll x){
	if(x==1||x==2)	a[x]=1;//边界 
	if(!a[x])//记忆化保存 
		if(x&1)	a[x]=g(f(x+1>>1))+g(f(x-1>>1));//x为奇数 
		else a[x]=g(f(x>>1))+2*f(x>>1)*f((x>>1)-1);//x为偶数 
	return a[x]%M;//防爆 
}
int main(){
	LL n;
	scanf("%lld",&n);
	printf("%lld",f(n));
	return 1;
}
```
时间:28ms;空间:0.71MB;代码:0.37KB.~~不知现在为何每个点最快也要2ms~~

希望管理员大大能让这篇题解通过，谢谢啦！

---

## 作者：陈琛 (赞：8)

以前，我写数列递推都是用矩阵的，直到我看见了[这个](http://www.inwap.com/pdp10/hbaker/hakmem/recurrence.html#item12)东西。。。

大致上，就是定义了一个二元组$(A,B)$，然后定义二元组的乘法$(A,B)\times (C,D)=(AD+BC+AC,BD+AC)$。

我们可以发现$(A,B)\times (1,0)=(A+B,A)$。

于是我们用快速幂求一下$(1,0)^n$就好了。

```cpp
#include <cstdio>
#include <utility>
#define MOD 1000000007
#define pr std::pair<long long,long long>
pr operator *(pr a,pr b){
	const long long A=a.first,B=a.second,C=b.first,D=b.second;
	return std::make_pair((A*C%MOD+A*D%MOD+B*C%MOD)%MOD,(A*C%MOD+B*D%MOD)%MOD);
}
template<typename T>
T power(T a,long long b){
	T ret=a;
	while(b){ if(b&1) ret=ret*a; a=a*a; b>>=1; }
	return ret;
}
int main(){
	long long n; scanf("%lld",&n);
	printf("%lld\n",power(std::make_pair(1,0),n).second);
	return 0;
}
```

然而，这东西不止能干这个。对于$F(n)=XF(n-1)+YF(n-2)$这个数列，我们只需要把乘法的定义改成$(A,B)\times (C,D)=(AD+BC+XAC,BD+YAC)$即可。可以发现，斐波那契数列就是在$X=Y=1$时的特殊情况。

不仅如此，这个东西还可以很方便地做到反推。我们可以发现，$(1,0)^{-1}=(1,-1)$，所以反推$n$项就是乘上$(1,-1)^n$。

理论上，这东西的常数是比矩阵小的，然而$n$是long long范围，log一下也就100不到，并没有什么卵用。。。反正码量很小就对了。

---

## 作者：Mathison (赞：7)

矩阵快速幂是一种优化递推时间复杂度的方法

先说**矩阵乘法**

我们一般用一个结构体定义一种矩阵类型
```
struct mat{ll a[2][2];};
```
这样做便于向函数里传参量

矩阵乘法的规则：

$$\begin{bmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\end{bmatrix}\begin{bmatrix}b_{11}&b_{12}\\b_{21}&b_{22}\\b_{31}&b_{32}\\\end{bmatrix}=\begin{bmatrix}a_{11}b_{11}+a_{12}b_{21}+a_{13}b_{31}&a_{11}b_{12}+a_{12}b_{22}+a_{13}b_{32}\\a_{21}b_{11}+a_{22}b_{21}+a_{23}b_{31}&a_{21}b_{12}+a_{22}b_{22}+a_{23}b_{32}\end{bmatrix}$$

总体来说就是 $\text{行乘列}$

这是**代码**实现

```
mat mat_mul(mat x,mat y,int n)//n阶矩阵
{
	mat res;
	memset(res.a,0,sizeof(res.a));
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			for(int k=0;k<n;k++)
				(res.a[i][j]+=x.a[i][k]%MOD*y.a[k][j]%MOD)%=MOD;
    return res;
}
```

注意矩阵乘法的一个重要性质：矩阵乘法满足**结合律**，但不满足**交换律**

那么我们是否可以利用它的**结合律**对算法做一些优化呢？

开始进入本题

我们知道，斐波那契数列的递推式为$$f[n]=f[n-2]+f[n-1]$$

两侧同时加$f[n-1]$化为：$$f[n]+f[n-1]=f[n-2]+f[n-1]+f[n-1]$$

这个式子我们可以写成矩阵乘法的样子$$\begin{bmatrix}f[n]\\f[n-1]\end{bmatrix}=\begin{bmatrix}f[n-1]\\f[n-2]\end{bmatrix}\begin{bmatrix}1&1\\1&0\end{bmatrix}$$

根据矩阵乘法的结合律，我们可以推出：

$$\begin{bmatrix}f[n]\\f[n-1]\end{bmatrix}=\begin{bmatrix}f[2]\\f[1]\end{bmatrix}\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-2}=\begin{bmatrix}1\\1\end{bmatrix}\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-2}$$

这时我们就可以先计算$\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-2}$再和$\begin{bmatrix}1\\1\end{bmatrix}$乘起来，就得到了我们的答案。

$\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-2}$的计算过程就是**矩阵快速幂**

矩阵快速幂和数字的快速幂的思想是相同的，都是二进制拆分，只不过快速幂中所有的**数字乘法**都变成了**矩阵乘法**

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
struct mat{ll a[2][2];};
ll n;
mat mat_mul(mat x,mat y)//矩阵乘法 
{
	mat res;
	memset(res.a,0,sizeof(res.a));
	for(int i=0;i<2;i++)
		for(int j=0;j<2;j++)
			for(int k=0;k<2;k++)
				(res.a[i][j]+=x.a[i][k]%MOD*y.a[k][j]%MOD)%=MOD;
    return res;
}
void mat_pow(ll n)//矩阵快速幂 
{
	mat c,res;
	c.a[0][0]=c.a[0][1]=c.a[1][0]=1;c.a[1][1]=0;//基础矩阵赋值 
	memset(res.a,0,sizeof res.a);
	res.a[0][0]=1;res.a[0][1]=1;//递推数组初值：f[1]=1,f[2]=1
	while(n)
	{
		if(n&1) res=mat_mul(res,c);
		c=mat_mul(c,c);
		n=n>>1;
	}
	printf("%lld\n",res.a[0][0]);
}
int main()
{
	scanf("%lld",&n);
	if(n==1) printf("1\n");//注意特判 
	else mat_pow(n-2);//计算基础矩阵
	return 0;
}
```
------------
当然这只是矩阵乘法最简单的应用，形似$f[n]=a*f[n-2]+b*f[n-1]+c$的递推式都可以用矩阵快速幂优化，这里就不赘述了 ~~不是赘述想说也不会啊~~

$END$

---

## 作者：fbhou (赞：5)

本题标准矩阵快速幂，楼上dalao们也解释的很详细了，这里有几个小小的优化

矩阵乘法：http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html

关于矩阵快速幂：同整数快速幂，利用

   x^n=(x^(n/2))^2（如果n为奇数再乘一个x）

加快计算

代码见下：

```cpp
#include<bits/stdc++.h>
const long long P=1000000007;//P为模数 
//有点懒，int全部替换的long long,并不要在意 
typedef long long jz[4];//自定义的2*2矩阵类型，下标0为左上角，以此类推 
using namespace std;
long long N;//项数 
jz x0={0,1,1,1},ans;//x0为初始矩阵，ans为存答案的矩阵 
void cheng (jz A,jz B,jz& C)//传了用来存乘法结果的矩阵C的地址，所以返回值为void 
{
    C[0]=(A[0]*B[0]+A[1]*B[2])%P;
    C[1]=(A[0]*B[1]+A[1]*B[3])%P;
    C[2]=(A[2]*B[0]+A[3]*B[2])%P;
    C[3]=(A[2]*B[1]+A[3]*B[3])%P;
}
//以上为矩阵乘法，不懂传地址的可以自己百度 
void ksm(jz A,long long n,jz& C)//同理，A为底数，n为次数，C为答案 
{
    if(n==1)//二分到底了 
    {
        C[0]=A[0];
        C[1]=A[1];
        C[2]=A[2];
        C[3]=A[3];
        //手残用不来memcpy() qaq...
        return;
    }
    else//还没到底 
    {
        jz D,E;
        ksm(A,n/2,D);//递归二分求解，复杂度为O(logn)的理由
        cheng(D,D,E);//平方，想一想为什么不能cheng(D,D,D)"节约空间"?
        if(n&1) cheng(E,A,C);//经多次试验发现传数组参的时候不能加地址符... 
        else{
            C[0]=E[0];
            C[1]=E[1];
            C[2]=E[2];
            C[3]=E[3];
            //手残用不来memcpy() qaq...
        }
    }
}
//以上为矩阵快速幂 
int main(){
    cin>>N;//输入 
    ksm(x0,N,ans);//快速幂求解，答案在ans矩阵中 
    cout<<ans[1];//得出答案！ 
    return 0;
}
//缩进还好吧？
```

---

## 作者：char32_t (赞：5)

#P1962 【斐波那契数列】

------------

###STL大法好

楼上的各位dalao已经将矩阵解法阐述地很详尽了~~（所以我就少说几句）~~

**斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N\*）（百度百科）**

我们可以得到斐波那契数列的通项公式：![markdown](https://gss0.bdstatic.com/-4o3dSag\_xI4khGkpoWK1HF6hhy/baike/s%3D245/sign=456a7a09b61bb0518b24b42c037ada77/503d269759ee3d6db9e6f1e046166d224f4adefd.jpg)

由于式中包含无理数，无法简单求得模1000000007之后的结果，所以我们可以用矩阵高效地求出第n项的值。

我们把斐波那契数列的递推式表示成矩阵就得到了~~下面的式子~~楼上的式子，之后的解法就可以用数组实现了

#但是

这道题还可以用标准模板库（Standard Template Library，STL）中的**不定长数组：vector**（使用需要包含头文件**#include <vector>**）

放代码：


```cpp
    #include<bits/stdc++.h>
    using namespace std;
    long long int mod;
    //死活不用 typedef 系列 
    vector<vector<long long int> > mul(vector<vector<long long int> > &a, vector<vector<long long int> >&b) {//计算a*b 
        vector<vector<long long int> > c(a.size(), vector<long long int>(b[0].size()));
        for(int i=0; i<a.size(); i++)
            for(int k=0; k<b.size(); k++)
                for(int j=0; j<b[0].size(); j++) c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod;
        return c;
    }
    vector<vector<long long int> > pow(vector<vector<long long int> > a, long long int n) {//计算a^n 
        vector<vector<long long int> > b(a.size(), vector<long long int>(a.size()));
        for(int i=0; i<a.size(); i++) b[i][i]=1;
        while(n>0) {
            if(n&1) b=mul(b, a);
            a=mul(a, a);
            n>>=1;
        }
        return b;
    }
    long long int n;
    int main() {
        scanf("%lld%lld", &n, &mod);//输入 
        vector<vector<long long int> > a(2, vector<long long int>(2));
        a[0][0]=1;
        a[0][1]=1;
        a[1][0]=1;
        a[1][1]=0;
        a=pow(a, n);
        printf("%lld", a[1][0]);//输出
        return 0;
}
```

---

## 作者：Erusel (赞：4)

虽然可以用矩阵乘法，但我偏不用

$f[2*n]=f[n+1]^{2}-f[n-1]^{2}=(2*f[n-1]+f[n])*f[n]$

$f[2*n+1]=f[n+1]^{2}+f[n]^{2}$

在这里，我们证明一下这两个定理。

证明1：

直接采用通项公式(通项公式还是有用的)

设$s=\frac{1+\sqrt{5}}{2},t=\frac{1-\sqrt{5}}{2}$

引理：

$s^{n}-t^{n}=\frac{(1+\sqrt{5})^{n}-(1-\sqrt{5})^{n}}{2^{n}}$

把$(1+\sqrt{5})^{n}$和$(1-\sqrt{5})^{n}$进行多项式展开

……

这样的证明过于繁琐，读者可以亲自尝试一下。

---

证明2：

采用数学归纳法

设$1$至$2*n$都满足上述公式 （两个公式同时满足）

$f[2*n+1]=f[2*n]+f[2*n-1]=f[n+1]^{2}-f[n-1]^{2}+f[n]^{2}+f[n-1]^{2}=f[n+1]^{2}+f[n]^{2}$

$f[2*n+2]=f[2*n+1]+f[2*n]$

$=f[n+1]^{2}+f[n]^{2}+f[n+1]^{2}-f[n-1]^{2}$

$=f[n+1]^{2}+f[n+1]^{2}+f[n]^{2}-f[n-1]^{2}$

$=f[n+1]^{2}+f[n+1]^{2}-2*f[n+1]*f[n]+f[n]^{2}-f[n-1]^{2}+2*f[n+1]*f[n]$

$=f[n+1]^{2}+f[n-1]^{2}-f[n-1]^{2}+2*f[n+1]*f[n]$

$=f[n+1]^{2}+2*f[n+1]*f[n]$

$=f[n+1]*(2*f[n]+f[n+1])$

$=f[n+2]^{2}-f[n]^{2}$

所以原命题成立

---

证明3：

$f[2*n]=f[n+1]^{2}-f[n-1]^{2}$

$f[2*n+1]=f[n+1]^{2}+f[n]^{2}$

只需证明：

$f[n+m]=f[m-1]*f[n]+f[m]*f[n+1]$

若上式成立

$f[2*n]=f[n+n]$

$=f[n-1]*f[n]+f[n]*f[n+1]$

$=f[n]*(f[n+1]+f[n-1])$

$=f[n+1]^{2}-f[n-1]^{2}$

$f[2*n+1]=f[n+(n+1)]$

$=f[n-1]*f[n+1]+f[n]*f[n+2]$

$=f[n+1]^{2}-f[n]*f[n+1]+f[n]^2+f[n]*f[n+1]$

$=f[n+1]^{2}+f[n]^{2}$

那怎么证明上面这个式子呢？

还是可以通过数学归纳法（只是这里提供了一个新的思路，后期也要用到这个定理）

设$1$至$x-1$都两两满足$f[n+m]=f[m-1]*f[n]+f[m]*f[n+1]$

下证

$f[1+x]=f[x-1]*f[1]+f[x]*f[2]$

$f[2+x]=f[x-1]*f[2]+f[x]*f[3]$

$……$

$f[x-1+x]=f[x-1]*f[x-1]+f[x]*f[x]$

对于任意的$f[p+x]$

都有$f[p+x]=f[(p-1)+x]+f[(p-2)+x]$

$=f[p+(x-1)]+f[(p-1)+(x-1)]$

$=f[x-2]*f[p]+f[x-1]*f[p+1]+f[x-2]*f[p-1]+f[x-1]*f[p]$

$=f[x-2]*f[p+1]+f[x-1]*f[p+2]$

$=f[x-1]*f[p+1]+f[x-2]*f[p+1]-f[x-1]*f[p+1]+f[x-1]*f[p+2]$

$=f[x]*f[p+1]+f[x-1]*f[p]$

所以原命题成立

利用减半递推+记忆化，便可以AC

代码：
```
#pragma GCC diagnostic error "-std=c++14"
#pragma GCC target("avx")
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")//强行优化

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

ll n;
const ll mod=1e9+7;

map<ll,ll>f;

ll solve(ll x)
{
	if(x==0)return 0;
	if(x==1)return 1;
	if(x==2)return 1;//边界条件
	ll y=(x>>1),f1=f[y-1]?f[y-1]:solve(y-1),f2=f[y]?f[y]:solve(y),f3=f[y+1]?f[y+1]:solve(y+1);//处理f[y-1],f[y],f[y+1]
	if(x&1)return (f[x]=(f3*f3+f2*f2+mod)%mod);//如果为奇数
	else return (f[x]=(f3*f3-f1*f1+mod)%mod);//如果为偶数
   //套用公式+记忆化，把答案丢进map里
}

inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0') { if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') { x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

int main()
{
	scanf("%lld",&n);
	printf("%lld\n",(solve(n)+mod)%mod);//疯狂取模
	
	return 0;
}

```

时间复杂度：递归$O(log(n))$,map$O(log(n))$总时间复杂度为$O(log^{2}(n))$

这里提到了这两个公式，顺便再拓展一个：

$f[3*n]=f[n+1]^{3}+f[n]^{3}-f[n-1]^{3}$

有兴趣的读者可以亲自证明一下。

当然啦，它对应的也有两个公式。

上述的数学归纳法的证明必须有**几个公式**互相依靠。


update on 2019.7.28:压了一下行，应该是你古代码最短解：

261B
```
#include<bits/stdc++.h>
#define l long long
#define t(x) f[x]?f[x]:s(x)
l n,M=1e9+7;std::map<l,l>f;
l s(l x){if(x<3)return bool(x);l y=x/2,a=t(y-1),b=t(y),c=t(y+1);return f[x]=((x&1)?(c*c+b*b+M)%M:(c*c-a*a+M)%M);}
main(){std::cin>>n;std::cout<<(s(n)+M)%M;}
```

---

## 作者：aiyougege (赞：4)

　　下面的图片是我在比较无聊的时候写的, 基本上介绍了斐波那契数列的矩阵快速幂优化的根据, 可能需要补充一些东西.但是我毕竟不是专业的, 可能会误人子弟, 仅用于参考.

- 矩阵描述的是线性变换(线性算子).
- 下图中描述的这么**一类矩阵**A可能有一个名字叫**剪切矩阵**, 它将一个向量$(a,b)$变为$(a,a+b)$.(或者是类似的一种形式)
- 矩阵与向量的乘积可以理解为**将空间中的基改变**, 此时向量$\mathbf{\alpha}$**在*原基*下表示的向量**.听起来确实比较抽象.
- 例如, 向量$\mathbf{\alpha}$在空间中表述为$(a,b)$(***如果基为$e_i,e_j$的话这个向量就为　$ae_i+be_j$　***), 那么$\mathbf{\alpha}$与矩阵$A$(指的就是剪切矩阵)乘就相当于是空间的基从$e_i,e_j$变成了$e_i+e_j,e_j$, 那么向量就变成了$ae_i+ae_i+be_j$, 在原有基下的表示就是$ae_i+(a+b)e_j$, 其实就是$(a,a+b)$.
- 而矩阵与矩阵的乘法就是将**一次线性变换的结果**进行**下一次线性变换**……从这里可以看出其满足结合律但是不一定满足交换律(***两次不同的线性变换进行顺序不同结果会相同吗***)
![](https://cdn.luogu.com.cn/upload/pic/18309.png)
![1](https://cdn.luogu.com.cn/upload/pic/18304.png)
![2](https://cdn.luogu.com.cn/upload/pic/18305.png)
![3](https://cdn.luogu.com.cn/upload/pic/18306.png)
![4](https://cdn.luogu.com.cn/upload/pic/18307.png)

#### Code
因为上面的图片年代太久远了所以这里我这里可能用了一个和上述略有区别的矩阵.

```c++
#include<cstdio>
#define N 105
#define mod 1000000007
#define int long long

class matrix {
    public:
    int n,m,mat[N][N];
    matrix(){}
    matrix(int _n){n=m=_n;for(int i=0;i<_n;++i)mat[i][i]=1;}
    matrix(int _n,int _m){n=_n,m=_m;}
    matrix operator+(const matrix &b)const{
        matrix c=matrix(n,m);
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                c.mat[i][j]=(mat[i][j]+b.mat[i][j])%mod;
        return c;	
    }
    matrix operator-(const matrix &b)const{
        matrix c=matrix(n,m);
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                c.mat[i][j]=(mat[i][j]-b.mat[i][j])%mod;
        return c;
    }
    matrix operator*(const matrix &b)const{
        matrix c=matrix(n,b.m);
        for(int i=0;i<n;++i)
            for(int j=0;j<b.m;++j){
                long long tmp=0LL;
                for(int k=0;k<m;++k){
                    tmp+=mat[i][k]*b.mat[k][j];
                    if(tmp>1e9)tmp%=mod;
                }
                c.mat[i][j]=tmp;
            }
        return c;
    }
    matrix operator*(const int &s)const{
        matrix c=*this;
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j){
                c.mat[i][j]*=s;
                c.mat[i][j]%=mod;
            }
    }
    matrix operator^(const int &s)const{
        int p=s;
        matrix ans=matrix(n);
        matrix bas=*this;
        while(p){
            if(p&1)ans=ans*bas;
            bas=bas*bas;p>>=1;
        }
        return ans;
    }
    void input(int _n,int _m){
        n=_n,m=_m;
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                scanf("%lld",&mat[i][j]);
    }
    void print(){
    //	putchar('\n');
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j)
                printf("%lld ",mat[i][j]);
            putchar('\n');
        }
    //	putchar('\n');
    }
};

main(){
    matrix oth;int n;
    scanf("%lld",&n);
    oth=matrix(2);
    oth.mat[0][0]=0;oth.mat[0][1]=oth.mat[1][0]=1;
    oth=oth^n;
    matrix m=matrix(1,2);
    m.mat[0][1]=1;
    m=m*oth;
    printf("%d\n",m.mat[0][0]);
    return 0;
}
```

---

## 作者：墨笙_Mooos (赞：3)

提供一种没有在题解区看到的打表做法，不使用矩阵乘法，但是比较锻炼观察能力。

虽然本质上是矩阵乘法的展开，但是换了一种理解的方式。

```
Update On 2022/11/23

修改代码中的小错误，并进一步优化方法和阅读体验。
```
------------

首先，发现斐波那契数列性质 $F_{n + m} = F_{n + 1} \times F_{m} + F_{n} \times F_{m - 1}$。（后附证明，这个性质可以由第一种证明方式发现）

将计算看作是从 $F_{0}$ 开始向后移动直到 $F_{n}$，考虑将移动分解，也就是将 $n$ 拆分为 $k$ 个正整数 $T_{i}$ 的和，从零开始依次向后移动 $T_{i}$ 来不断维护当前答案。

也就是说，我们依次计算 $\left\{F_0, F_{T_1}, F_{T_1+T_2}, F_{T_1+T_2+T_3},\cdots\right\}$。

向后移动 $T_{x}$ 时，设 $c = \sum_{i = 1}^{x - 1} T_{i}$，则有我们想要知道的

$$F_{c + T_{x}} = F_{c + 1} \times F_{T_{x}} + F_{c} \times F_{T_{x} - 1}$$

由此可知，只有 $F_c$ 是不足够的，我们还需要维护 $F_{c + 1}$。

$$F_{c + 1 + T_{x}} = F_{c + (T_x + 1)} = F_{c + 1} \times F_{T_x + 1} + F_{c} \times F_{T_x}$$

注意，此时将 $c$ 视为原公式中的 $n$，$(T_x + 1)$ 视为原公式中的 $m$，这样才能保证仅使用到 $F_c$ 和 $F_{c + 1}$。否则需要再次转化。

现在我们需要关注的是两个式子中 $F_{T_i - 1}, F_{T_i}, F_{T_i + 1}$ 如何获得。

显然，$F_{T_i + 1} = F_{T_i - 1} + F_{T_i}$。

因为 $T_{i}$ 没有限制，所以我们可以自行挑选一个集合 $S$，使得 $T$ 中所有数都来自于 $S$，并且满足 $n$ 可以分解为 $S$ 中若干个数的和。这样我们只要事先计算出 $S$ 中每个元素 $x$ 的 $F_{x - 1}, F_{x}$，并在计算时调用即可。

我选择了 $2^{i}$ 的集合。分别令原公式中的 $m=n=x$，$m=n+1=x$ 则可以得到以下式子：

$$F_{2x} = F_{x+1} \times F_x + F_x \times F_{x-1} = F_x^2 + 2F_{x-1}\times F_x$$

$$F_{2x-1} = F_{x}^2 + F_{x-1}^2$$

据此，我们可以计算得到所有 $F_{2^i}$ 与 $F_{2^i-1}$。

---

```cpp
const ll mod = 1'000'000'007;
vector<ull> FibPow2, FibPow2Minus1;
ull n, f0, f1 = 1, nf0, nf1;
int main ()
{
	std::cin.tie (nullptr), std::ios::sync_with_stdio (false);
	for (ull i = 0; i <= 62; ++i)
	{
		FibPow2.emplace_back (f1), FibPow2Minus1.emplace_back (f0);
		nf0 = f1 * f1 % mod + f0 * f0 % mod;
		nf1 = f1 * f1 % mod + 2 * f0 * f1 % mod;
		if (nf0 >= mod) nf0 -= mod;
		if (nf1 >= mod) nf1 -= mod;
		tie (f0, f1) = mkp (nf0, nf1);
	}
	cin >> n, f0 = 0, f1 = 1;
	while (n)
	{
		static ll i; i = __lg (n & (-n));
		nf0 = FibPow2Minus1[i] * f0 % mod + FibPow2[i] * f1 % mod;
		nf1 = FibPow2[i] * f0 % mod + f1 * (FibPow2[i] + FibPow2Minus1[i]) % mod;
		if (nf0 >= mod) nf0 -= mod;
		if (nf1 >= mod) nf1 -= mod;
		tie (f0, f1) = mkp (nf0, nf1);
		n -= (1ll << i);
	}
	cout << f0 << endl;
	return 0;
}
```

---

下附对第一个式子的三种证明方式。

### 证明方式 1

> Consider the following problem:
> A person climbs up $n$ steps, by taking either one step, or two steps at a time.
> The total number of ways the person can climb up all the $n$ steps is $F_{n+1}$ (Why?)
> Now consider climbing $m+n−1$ steps and split into the cases when the person lands on step $n$ and the cases when the person lands on step $n−1$ and takes two steps at that point (and so does not land on step $n$ in those cases). These two cases cover all possibilities, and so we have:
> $F_{m+n}=F_{n+1} \times F_{m}+F_{n} \times F_{m−1}$

From [StackExchange](https://math.stackexchange.com/a/11527)

考虑一个问题：爬楼梯，一次可以爬一步或者两步，那么爬上 $n$ 级楼梯的方案数量就是 $F_{n + 1}$。

考虑爬 $n + m - 1$ 级台阶，那么可以把问题分解成两部分：
1. 经过第 $n$ 级台阶，方案数为 $F_{n + 1} \times F_{m}$。
2. 不经过第 $n$ 级台阶，即经过第 $n - 1$ 级台阶并直接到第 $n + 1$ 级台阶，方案数为 $F_{n} \times F_{m - 1}$。

而总方案数为 $F_{n + m}$，得证。

### 证明方式 2

归纳法。

当 $n = 1$ 时，$F_{m + 1} = F_{2} \times F_{m} + F_{1} \times F_{m - 1} = F_{m} + F_{m - 1} = F_{m + 1}$。

当 $n = 2$ 时，$F_{m + 2} = F_{3} \times F_{m} + F_{2} \times F_{m - 1} = 2 \times F_{m} + F_{m - 1} = F_{m + 2}$。

若已知条件如下：

$\left\{\begin{array}{ccc} F_{m + n - 1} = F_{n} \times F_{m} + F_{n - 1} + F_{m - 1} \\\ F_{m + n - 2} = F_{n - 1} \times F_{m} + F_{n - 2} + F_{m - 1}\end{array}\right.$

则将两式相加，得到：$F_{n + m} = F_{n + 1} \times F_{m} + F_{n} \times F_{m - 1}$。

由于已证明 $n = 1, 2$ 时命题成立，故可以将结论推广到正整数集。

### 证明方式 3

我们知道，对于 $M=\left[\begin{array}{ccc} 1 & 1 \\\ 1 & 0\end{array}\right]$，有 $M^{n} = \left[\begin{array}{cc} F_{n+1} &\!\! F_n \\\ F_n &\!\! F_{n-1} \end{array}\right]$。

$M_{n+m} = M_n*M_m $

$= \left[\begin{array}{ccc} F_{n+1} & F_n \\\ F_n & F_{n-1} \end{array}\right]\times\left[\begin{array}{ccc} F_{m+1} & F_m \\\ F_m & F_{m-1} \end{array}\right]$

$= \left[\begin{array}{ccc} F_{n+1}F_{m+1} + F_nF_m & F_{n+1}F_m + F_nF_{m-1} \\\ F_nF_{m+1} + F_{n-1}F_m & F_{n}F_{m} + F_{n-1}F_{m-1} \end{array}\right]$

得证。

---

## 作者：yummy (赞：3)

首先我们看一个神奇的方程：$a^2=a+1$

以一个初一同学的角度，在满足上式的前提下化简$a^8$

$a^8=a^7+a^6=2a^6+a^5=3a^5+2a^4=...=21a+13$

我们发现，a的系数恰好是斐波那契数列第8项,常数恰好是第7项！（这不是显然的吗）

同时：
$a^8=(a^4)^2=(3a+2)^2=9a^2+12a+4=21a+13$

由上面的例子我们知道了$a^8$和$a^4$的关系，也就是$f(8)$和$f(4)$的关系。

更一般地，我们可以由$a^n$的化简结果推出$a^{2n}$的结果和$a^{n+1}$的。
```cpp
struct duo
{
    ll a,b;
};
duo powa(ll ci)
{
    duo res,tmp;
    if(ci==1)
    {
        res.a=1;
        res.b=0;
        return res;
    }
    tmp=powa(ci>>1);
    res.a=(tmp.a*tmp.a%Mod+(tmp.b*tmp.a%Mod<<1))%Mod;
    res.b=(tmp.a*tmp.a%Mod+tmp.b*tmp.b%Mod)%Mod;
    //这里要多模几次，必要时可以龟速乘法
    if(ci&1)
    //奇数个还要再乘以a
    {
        swap(res.a,res.b);
        res.a=(res.a+res.b)%Mod;
    }
    return res;
}
```

---

## 作者：Isonan (赞：3)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P1962)

巨佬们用的都是矩阵乘法，我比较菜，提供一种~~新~~奇葩的思路。

我们知道斐波那契数列的通项式是

$$a_i=\frac{\{[\frac{1+\sqrt{5}}{2}]^i-[\frac{1-\sqrt{5}}{2}]^i\}}{\sqrt{5}}$$

所以我们用快速幂算一下这个东东就可以了。

无理数有点难搞，于是我们同时存下该数中$\sqrt{5}$的系数以及有理数的系数，然后重载一下乘法。

我们又发现这个式子里有$\frac12$,于是~~决定打一个分数~~考虑到答案是模1e9+7意义下的，所以$\frac12\equiv5e8+4(mod \space 1e9+7)$，这样就不用打分数了。

代码：

```cpp
#include <cstdio>
#define p 1000000007
#define half 500000004

struct num{
	long long a,b;
	num operator*=(num rhs){return *this=(num){(a*rhs.a+(5*(b*rhs.b)))%p,(a*rhs.b+b*rhs.a)%p};}
	num operator-(num rhs){return(num){(a+p-rhs.a)%p,(b+p-rhs.b)%p};}
};
num qsm(num a,long long b){
	num ans=(num){1,0};
	for(;b;a*=a,b>>=1)if(b&1)ans*=a;
	return ans;
}
long long n;
int main(){
	scanf("%lld",&n);
	printf("%lld",(qsm((num){half,half},n)-qsm((num){half,p-half},n)).b);
}
```

---

## 作者：k2saki (赞：3)

P1962：斐波那契数列

这是我学完矩阵乘法，打完模板后做的第一道关于矩乘的题。

乍一看，斐波那契？这不是简简单单的递推吗？再一看数据范围：**n在long long(INT64)范围内**，所以，普通递推这种方法就直接被排除了。

因为这是一道矩乘的题目，所以，最重要的一步是：

## 构造矩阵！

我们发现：f[n]=f[n-1]+f[n-2]

		 f[n-1]=f[n-1]+0*f[n-2]
         
所以，我们可以构造出矩阵：

		1,1
        
            1,0
            
构造完了，这题就变成了一个矩阵快速幂啦。

## Code:
```
#include <bits/stdc++.h>
using namespace std;

const int mod=1e9+7;

long long n,k;

struct juz{
	long long mp[101][101];
	
	juz(){
		memset(mp,0,sizeof(mp));
	}
	
	void bu()
	{
		for(int i=1;i<=2;++i)
		{
			mp[i][i]=1;//单位矩阵
		}
	}	
};


juz operator *(const juz &x,const juz &y)//重载运算符，这样在主函数里更方便
{
	juz z;
	for(int k=1;k<=2;++k)
	{
		for(int i=1;i<=2;++i)
		{
			for(int j=1;j<=2;++j)
			{
				z.mp[i][j]=(z.mp[i][j]+x.mp[i][k]*y.mp[k][j]%mod)%mod;//矩阵乘法
			}
		}
	}
	return z;
}
juz q;

int main() {
	
	cin>>n;
	q.mp[1][1]=1;
	q.mp[2][2]=0;
	q.mp[1][2]=1;
	q.mp[2][1]=1;
	/*for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			cout<<q.mp[i][j]<<" ";
			
		}
		cout<<endl;
	}*/
	juz an;
	an.bu();
	while(n)//和普通快速幂相似
	{
		if(n&1) an=an*q;//千千万万注意：不可以写成an*=q
		q=q*q;
		n>>=1;
	}
	cout<<an.mp[1][2];//输出
	return 0;
}
  
```


---

## 作者：SS_Yi (赞：3)

暴力矩阵快速幂 0msAC 
手动打出每一步乘法过程。。。
主要是矩阵乘法符合结合律，就可以先让矩阵自己处（an）理（pai）自己，这样就可以用快速幂的思想了呀。
在这里 1 就是 1  0
            0  1   这个矩阵，你会发现这个矩阵乘任何矩阵都等于它本身。
而底数base就是 1  1
             1  0  这个矩阵。
这样这道题复杂度就降到了$O(logn)$了
上代码
```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#define M 1000000007;
using namespace std;
long long jz[3][3],tmp[3][3],ans[3],base[3][3];
long long n;
void zc()
{
    tmp[0][0]=base[0][0];
    tmp[0][1]=base[0][1];
    tmp[1][0]=base[1][0];
    tmp[1][1]=base[1][1];
    base[0][0]=(tmp[0][0]*tmp[0][0]+tmp[0][1]*tmp[1][0])%M;
    base[0][1]=(tmp[0][0]*tmp[0][1]+tmp[0][1]*tmp[1][1])%M;
    base[1][0]=(tmp[1][0]*tmp[0][0]+tmp[1][1]*tmp[1][0])%M;
    base[1][1]=(tmp[1][0]*tmp[0][1]+tmp[1][1]*tmp[1][1])%M;
}
void jc()
{
    tmp[0][0]=jz[0][0];
    tmp[0][1]=jz[0][1];
    tmp[1][0]=jz[1][0];
    tmp[1][1]=jz[1][1];
    jz[0][0]=(tmp[0][0]*base[0][0]+tmp[0][1]*base[1][0])%M;
    jz[0][1]=(tmp[0][0]*base[0][1]+tmp[0][1]*base[1][1])%M;
    jz[1][0]=(tmp[1][0]*base[0][0]+tmp[1][1]*base[1][0])%M;
    jz[1][1]=(tmp[1][0]*base[0][1]+tmp[1][1]*base[1][1])%M;
}
void ksm()
{
    long long t=n;
    while(t>0)
    {
        if (t&1) 
        {
            jc();
        }
        zc();
        t>>=1;
    }
}
int main()
{
    jz[0][0]=jz[1][1]=1;jz[1][0]=jz[0][1]=0;
    base[0][0]=base[0][1]=base[1][0]=1;base[1][1]=0;
    ans[0]=ans[1]=1;
    cin>>n;
    n-=2;
    ksm();
    cout<<(jz[0][0]+jz[0][1])%M;
} 
```

---

## 作者：Paul·Shi (赞：3)

**矩阵乘法+空间换时间(减少乘法，取模运算)**

 　
  数列的递推公式为：f(1)=1，f(2)=2，f(n)=f(n-1)+f(n-2)(n>=3)

　　 
   用矩阵表示为：

![](https://images0.cnblogs.com/blog/466768/201303/18233645-7c570d5cdca44eb1b28a26f1a14638ce.png)


      进一步，可以得出直接推导公式：


![](https://images0.cnblogs.com/blog/466768/201303/18234316-d429046705b14658ae035555e3cc55f3.png)
 　　
 
** 由于矩阵乘法满足结合律，在程序中可以事先给定矩阵的64，32，16，8，4，2，1次方，加快程序的执行时间。（有些题目需要取模运算，也可以事先进行一下）。给定的矩阵次幂，与二进制有关是因为，如下的公式存在解，满足Xi={0或1}： **


![](https://images0.cnblogs.com/blog/466768/201303/19091205-8a3ccc6c07504d16bd59be6a59598228.png)



为了保证解满足 Xi={0或1}，对上述公式的求解从右向左，即求解顺序为Xn，Xn-1,Xn-2,....,X1,X0。

//以上摘自[斐波那契数列 矩阵求法 优化](http://www.cnblogs.com/xudong-bupt/archive/2013/03/19/2966954.html)

## P1962 斐波那契数列

### 题目背景

大家都知道，斐波那契数列是满足如下性质的一个数列：

• f(1) = 1

• f(2) = 1

• f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数)

### 题目描述

请你求出 f(n) mod 1000000007 的值。

输入输出格式

### 输入格式：
·第 1 行：一个整数 n

### 输出格式：
第 1 行： f(n) mod 1000000007 的值

```cpp
#include<bits/stdc++.h>
#define ULL unsigned long long
using namespace std;
char tmp[11];
char s[30000010];
int q[30000010];
ULL k,p=1000000007 ,a[3],b[3][3],result[3][3];
void matrix_multiply_result ()
{
	ULL c[3][3];
    memset (c,0,sizeof (c));
    for (int i=1;i<=2;i++)
    	for (int j=1;j<=2;j++)
    		for (int k=1;k<=2;k++)
				c[i][k]=(c[i][k]+result[i][j]*b[j][k])%p;
	for (int i=1;i<=2;i++)
		for (int j=1;j<=2;j++)
			result[i][j]=c[i][j];
}
void matrix_multiply_b ()
{
    ULL c[3][3];
    memset (c,0,sizeof (c));
    for (int i=1;i<=2;i++)
    	for (int j=1;j<=2;j++)
    		for (int k=1;k<=2;k++)
				c[i][k]=(c[i][k]+b[i][j]*b[j][k])%p;
	for (int i=1;i<=2;i++)
		for (int j=1;j<=2;j++)
			b[i][j]=c[i][j];
}
void matrix_multiply_a ()
{
    ULL c[3];
    memset (c,0,sizeof (c));
    for (int i=1;i<=2;i++)
    	for (int j=1;j<=2;j++)
				c[i]=(c[i]+a[j]*b[i][j])%p;
	for (int i=1;i<=2;i++)
		a[i]=c[i];
}
int main()
{
	a[1]=1,a[2]=1;
	b[1][1]=b[1][2]=b[2][1]=1;
	b[2][2]=0;
	result[1][1]=1;result[1][2]=0;
    result[2][1]=0;result[2][2]=1;
    scanf ("%llu%llu",&k);
    k--;
	while (k)
	{
		if (k%2==1)
			matrix_multiply_result ();
		matrix_multiply_b ();
		k/=2;
	}
	printf ("%llu",result[1][1]);
	return 0;
}
```

---

## 作者：丛雨 (赞：2)

## 首先，我先介绍一种 O($\sqrt n$)的算法

### 	平方分割法

#### 首先，我们先计算如下的式子

#### F[i]=F[i-2]+F[i-1]=F[i-3]+2F[i-2]=2F[i-4]+3F[i-3]......

#### 这时，我们假设当前为F[i]=a\*F[j]+b*F[j-1]

#### 则是不是F[i]=(a+b)\*F[j-1]+a\*F[j-2

# 下面就是重点

##### 等等，系数是不是有点眼熟：1,1,2...a，b，a+b

##### 这不正是斐波拉契数列吗? 所以，我们可以得到：F[i]=F[k]*F[i-k-1]+F[k+1]*F[i-k]

### 即F[k]*F[i]+F[k+1]*F[i+1]=F[i+k+1]

###### F[n+k]=F[k]*F[n-1]+F[k+1]*F[n]

###### F[n+k+1]=F[k]*F[n]+F[k+1]*F[n+1]

###### F[n+k-1]=F[n+k+1]-F[n+k]

时间复杂度为O（n/k+k）,当k=$\sqrt n$时取最小，得出结果O（$\sqrt n$）.

代码：
``` cpp
#include<cstdio>
#include<cmath>
# define ll long long
void make(ll n,ll &x,ll &y,ll m)////x:Fib[n] ; y:Fib[n+1] ; m:Mod
{
    ll a,b,to[3]={0,1,1};
    ////特判
    if(n<2)
	{
		x=to[n];
		y=to[n+1];
		return;
	}
	if(n==2)
	{
		x=1;
		y=2;
		return;
	}
	////求k,并递归求解Fib[k]及F[k+1]
    ll k=sqrt(n);
    make(k,a,b,m);
    ////从Fib[k]到Fib[k*k]的变化
    for(ll i=1;i<=k;++i)
    {
        to[2]=(to[1]*a+to[2]*b)%m;
        to[1]=(to[0]*a+to[1]*b)%m;
        to[0]=(to[2]-to[1])%m;
    }
    k*=k;
	////如果已经得到解（n为完全平方数），退出
    if(k==n)
	{
		x=(to[0]%m+m)%m;
		y=(to[1]%m+m)%m;
		return;
	}
	////如果没有，则从k*k迭代到n
    for(ll i=k+1;i<=n;++i)
    {
        to[2]=to[1];
        to[1]=(to[0]+to[1])%m;
        to[0]=to[2];
    }
    x=(to[0]%m+m)%m;
    y=(to[1]%m+m)%m;
}
int main()
{
	ll n,x,y;
	scanf("%lld",&n);
	make(n,x,y,1000000007);
	printf("%lld",x);
    return 0;
}

```

### 当然这还不够优秀，$\sqrt n$只能得到80分，所以还需要引出$\log_2 n$的算法。

# 矩阵加速
### 个人理解：把递推式转化为矩阵乘法，再利用快速幂。
![](https://cdn.luogu.com.cn/upload/pic/73206.png)
#### 上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;
# define Type template<typename T>
Type inline T read1()
{
    T t=0;
    char k=getchar();
    bool flag=0;
    while('0'>k||k>'9')
    {
        if(k=='-')flag=1;
        k=getchar();
    }
    while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^48),k=getchar();
    return flag?-t:t;
}
# define ll long long
class Mat
{
    # define Vec vector<ll>
    # define Arr vector<Vec>
    Arr a;
    public:
        Mat(){}
        Mat(Arr k):a(k){}
        Mat(ll x,ll y){a.resize(x);for(ll i=0;i<x;++i)a[i].resize(y);}
        Vec& operator [](const ll k){return a[k];}
        ll wide(){return a.size();}
        ll len(){return a.empty()?0:a[0].size();}
        Mat operator *(Mat k)
        {
            Arr tem;
            tem.resize(wide());
            for(ll i=0;i<wide();++i)
            {
                tem[i].resize(k.len());
                for(ll j=0;j<len();++j)
                    for(ll l=0;l<k.len();++l)
                        tem[i][l]+=a[i][j]*k[j][l];
            }
            return Mat(tem);
        }
        Mat operator +(Mat k)
        {
            ll o=max(wide(),k.wide()),p=max(len(),k.len());
            Mat tem(o,p);
            for(ll i=0;i<o;++i)
                for(ll j=0;j<p;++j)
                {
                    if(i<wide()&&j<len())tem[i][j]=a[i][j];
                    if(i<k.wide()&&j<k.len())tem[i][j]+=k[i][j];
                }
            return tem;
        }
        Mat operator %(ll k)
        {
            Mat tem(wide(),len());
            for(ll i=0;i<wide();++i)
                for(ll j=0;j<len();++j)
                    tem[i][j]=a[i][j]%k;
            return tem;
        }
        Mat& operator %=(ll k){return *this=*this%k;}
        Mat& operator *=(Mat k){return *this=*this*k;}
        Mat& operator +=(Mat k){return *this=*this+k;}
        bool scan(ll x,ll y,const ll value)
        {
            if(x>=wide()||y>=len()||x<0||y<0)return 0;
            a[x][y]=value;
            return 1;
        }
    # undef Vec
    # undef Arr
};
Type T quickpow(T k,const ll n,ll Mod)
{
    if(n==1)return k;
    T tem=quickpow(k,n>>1,Mod);
    if(Mod!=0)
    {
        tem=(tem*tem)%Mod;
        if(n&1)tem=(tem*k)%Mod;
    }
    else
    {
        tem*=tem;
        if(n&1)tem*=k;
    }
    return tem;
}
# define read read1<ll>()
int main()
{
    ll n=read,l=read;
    if(n==1)return !putchar('1');
    Mat k(2,2);
    k[0][0]=k[0][1]=k[1][0]=1;
    k=quickpow(k,n-1,l);
    printf("%lld",k[0][0]);
    return 0;
}

```



---

## 作者：Cesare (赞：2)

## 浅谈如何构造矩阵

```
关于矩阵的构造，是矩乘中最关键的一环，一般只需要学会构造矩阵和熟练运用矩阵快

速幂的模板，就可以做(shui)出(diao)非常多的题目。

话不多说，马上进入正题。

```

-------------------

例题1:[【模板】矩阵加速（数列）](https://www.luogu.org/problemnew/show/P1939)

让我们观察一下这题的递推式:

$ f[1] = f[2] = f[3] = 1 $

$ f[n] = f[n - 1] + f[n - 3] $ ($ n > 3 $) $ $

首先我们可以发现，$ f[n] $ 最早由$ f[n-3] $转移而来，所以我们需要构造一个$ 3*3 $的矩阵。

首先，我们将与 $ f[n] $ 有关的需要得到的式子放入一个矩阵:
$ \begin{bmatrix}f[n]\\f[n - 1]\\f[n - 2]\end{bmatrix} $

然后，我们寻找他从哪里来: $ f[n-1] = f[n - 2] + f[n - 3] $，
即 $ \begin{bmatrix}f[n-1]\\f[n - 2]\\f[n - 3]\end{bmatrix} $

然后设我们需要得到的矩阵为$ ans $，有:$ ans*\begin{bmatrix}f[n-1]\\f[n - 2]\\f[n - 3]\end{bmatrix} = \begin{bmatrix}f[n]\\f[n - 1]\\f[n - 2]\end{bmatrix} $

然后我们一行一行根据矩乘的方式递推:

第一行因为想得到 $ f[n] $， 所以三个都需要:$ \begin{bmatrix}1&1&1\end{bmatrix} $

第二行因为想得到$ f[n - 1] $，所以只需要第一个:$ \begin{bmatrix}1&0&0\end{bmatrix} $

第三行因为想得到$ f[n - 2] $，所以只需要第二个:$\begin{bmatrix}0&1&0\end{bmatrix} $

最后就构造出了完整的矩阵:
$ \begin{bmatrix}1&0&1\\1&0&0\\0&1&0\end{bmatrix} $

----------------------

例题2:[斐波那契数列](https://www.luogu.org/problemnew/show/P1962)

让我们重复上一题的步骤:

$ f[1] = f[2] = 1 $

$ f[n] = f[n - 1] + f[n - 2] $

可以发现 $ f[n] $ 最早由 $ f[n - 2] $ 转移而来，所以只需要构建一个 $ 2 * 2 $的矩阵就可以了。

将递推式放入矩阵: $ \begin{bmatrix}f[n]\\f[n - 1]\end{bmatrix} $

他从哪里来: $ \begin{bmatrix}f[n - 1]\\f[n - 2]\end{bmatrix} $

设 $ ans * \begin{bmatrix}f[n - 1]\\f[n - 2]\end{bmatrix} = \begin{bmatrix}f[n]\\f[n - 1]\end{bmatrix} $

第一行需要得到 $ f[n] $，所以需要$ f[n - 1] $ 和 $ f[n - 2] $，因此得到矩阵第一行为: $ \begin{bmatrix}1&1\end{bmatrix} $

第二行需要得到 $ f[n - 1] $，所以只需要$ f[n - 1] $就可以了，因此得到矩阵第二行为: $ \begin{bmatrix}1&0\end{bmatrix} $

最后构建出完整的矩阵: $ \begin{bmatrix}1&1\\1&0\end{bmatrix} $

代码:
```cpp
#include<bits/stdc++.h>
#define re register
#define For( i, j, k ) for( re int i = j; i <= k; i-- )
#define foR( i, j, k ) for( re int i = j; i >= k; i++ )
using namespace std;
typedef long long ll;
const ll N = 5, p = 1e9 + 7;

struct matrix {
    ll mp[N][N];
    inline void init() {
        memset( mp, 0, sizeof( mp ) );
        mp[1][1] = mp[1][2] = mp[2][1] = 1;
    }
    inline void operator *=( matrix mmp ) {
        matrix ans;
        For( i, 1, 2 )For( j, 1, 2 ) {
            ans.mp[i][j] = 0; 
            For( k, 1, 2 )ans.mp[i][j] += mp[i][k] * mmp.mp[k][j];
        }For( i, 1, 2 )For( j, 1, 2 )mp[i][j] = ( ans.mp[i][j] + p ) % p;
    }
};

inline ll read() {
    ll x = 0; bool f = 0; char ch = getchar();
    for( ; !isdigit( ch ); ch = getchar() )f^=( ch == '-' );
    for( ; isdigit( ch ); ch = getchar() )x = ( x<<3 ) + ( x<<1 ) + ( ch^48 );
    return f? -x: x;
}

inline void write( ll x ) {
    if( x < 0 ){ putchar( '-' );x = -x; }
    if( x > 9 )write( x / 10 );
    putchar( x % 10 + 48 );
}

inline ll matrix_power( ll x ) {
    if( x <= 2 ) return 1;
    matrix ans, a;
    ans.init(), a.init();
    while( x ) { if( x&1 )ans *= a; x>>=1; a *= a; }
    return ans.mp[1][1];
}

int main() {
    ll n = read() - 2;
    write( matrix_power( n ) );
    return putchar( '\n' ), 0;
}

```


---------------------------

习题:

```
1.[专心OI - 跳房子](https://www.luogu.org/problemnew/show/P5004)

2.[Function](https://www.luogu.org/problemnew/show/U60144)//矩乘可以拿50

3.[填数游戏](https://www.luogu.org/problemnew/show/P5023)//矩乘依然可以拿50

```

--------------

[高斯消元](https://www.cnblogs.com/Dumblidor/p/5751579.html)

[参考资料](https://ask.julyedu.com/article/493)[视频](https://space.bilibili.com/88461692/channel/detail?cid=9450)

---

## 作者：Vanity_ (赞：2)

# 一. 认识矩阵

## 1.普通矩阵

- 普通矩阵就是一个数字阵列，一个n行m列的矩阵可表示为：


| a11 | a12 | ... | a1m |
| :----------: | :----------: | :----------: | :----------: |
| a21 | a22 | ... | a2m |
| ... | ... | ... | ... |
| an1 | an2 | ... | anm |


## 2.方阵

- 如果一个行数和列数相等的矩阵我们叫做方阵。如下图是3×3方阵：


| 1 | 2 | 3 |
| :----------: | :----------: | :----------: |
| 4 | 5 | 6 |
| 7 | 8 | 9 |


## 3.单位矩阵

### 定义
在矩阵中主对角线上的元素都为1，其余元素都为0的n阶矩阵就是单位矩阵，记为In或En。

### 作用
它在矩阵乘法中有特殊作用如普通乘法的1。

如图是单位矩阵I4：

| 1 | 0 | 0 | 0 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 0 | 1 | 0 | 0 |
| 0 | 0 |1  | 0 |
| 0| 0 |0  | 1 |


# 二.运算
设矩阵A,B,C;

## 1.加减运算
设C=A+B;
- 运算前提条件
A,B,C必须都是n×m矩阵。

减法亦是如此
- 运算过程

其实加法运算很简单就是把两个矩阵对应的位置上的数相加减。
即c[i][j]=a[i][j]+b[i][j]
## 2.乘法运算
设C=A×B
- 前言

乘法运算是矩阵运算的要点，一定要牢记！！！



- 运算前提条件

若A为n×p矩阵则B必须为p×m矩阵C为n×m的矩阵。

- 运算过程

c[i][k]={a[i][j]+a[j][k]|j=1...p}(i<=n;k<=m)

附上代码
```cpp
void cj(node a,node b,node &c，int n,int p,int m)
{
	memset(c.f,0,sizeof(c.f));
	int i,j,k;
	for(i=1;i<=n;i++)
		for(j=1;j<=p;j++)
			for(k=1;k<=m;k++)
			c.f[i][k]=(a.f[i][j]*b.f[j][k]+c.f[i][k]);
}
```
-  性质

由以上公式可以看出矩阵乘法满足结合律但不满足交换律

# 三.矩阵快速幂
- 前言

不懂普通快速幂的同学掉头左转[百度快速幂](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%B9%82/5500243?fr=aladdin)

- 运算

其实矩阵快速幂跟普通快速幂没什么区别，就是把数字换成了矩阵。

附上2×2矩阵的快速幂的代码
```cpp
struct node{
	long long f[3][3];
}tmp,t,res,f;
void cj(node a,node b,node &c)//矩阵乘法
{
	memset(c.f,0,sizeof(c.f));
	int i,j,k;
	for(i=1;i<=2;i++)
		for(j=1;j<=2;j++)
			for(k=1;k<=2;k++)
			c.f[i][k]=(a.f[i][j]*b.f[j][k]+c.f[i][k])%1000000007;
}
void p(node &a)//化为单位矩阵- 
{
	int i,j;
	for(i=1;i<=2;i++)
		for(j=1;j<=2;j++)
			if(i==j) a.f[i][j]=1;
			else a.f[i][j]=0;
}
void pow(long long n)
{
	p(res);
	p(t);
	tmp=f;
	while(n)
	{
		if(n&1) {
			cj(res,tmp,t);
			res=t;
		}
		cj(tmp,tmp,t);
		tmp=t;
		n>>=1;
	}
}
```

# 经典习题

## [斐波拉契数列](https://www.luogu.org/problemnew/show/P1962)

本题看似是一道简单的递推题，但看一下数据范围就知道普通递推无法满足此时间复杂度。这时矩阵快速幂就派上用处了。

我们知道:

f[i]=1×f[i-1]+1×f[i-2]

f[i-1]=1×f[i-1]+0×f[i-2]

由以上两式可知

```
| f[i]  |   | 1 | 1 |   |f[i-1]|   | 1 | 1 |
|-------| = |---|---| × |------| = |-------| ×
| f[i-1]|   | 1 | 0 |   |f[i-2]|   | 1 | 0 |


| 1 | 1 |    |f[i-2]|
|-------| ×  |------|    
| 1 | 0 |    |f[i-3]|
```
由上式又可得
```
| f[n] |   | 1 | 1 | ^n-2    | f[2] |
|------| = |-------|       × |------|
|f[n-1]|   | 1 | 0 |         | f[1] |
```
然后结合矩阵快速幂我们就可以做出来了

附上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	long long f[3][3];
}tmp,t,res,f;
void cj(node a,node b,node &c)
{
	memset(c.f,0,sizeof(c.f));
	int i,j,k;
	for(i=1;i<=2;i++)
		for(j=1;j<=2;j++)
			for(k=1;k<=2;k++)
			c.f[i][k]=(a.f[i][j]*b.f[j][k]+c.f[i][k])%1000000007;
}
void p(node &a)
{
	int i,j;
	for(i=1;i<=2;i++)
		for(j=1;j<=2;j++)
			if(i==j) a.f[i][j]=1;
			else a.f[i][j]=0;
}
void pow(long long n)
{
	p(res);
	p(t);
	tmp=f;
	while(n)
	{
		if(n&1) {
			cj(res,tmp,t);
			res=t;
		}
		cj(tmp,tmp,t);
		tmp=t;
		n>>=1;
	}
}
long long ans[3];
int main()
{
	long long n;
	scanf("%lld",&n);
	if(n<3) printf("1");
	else
	{
		f.f[1][1]=f.f[1][2]=f.f[2][1]=1;
		f.f[2][2]=0;
		pow(n-2);
 		printf("%lld\n",(res.f[1][1]+res.f[1][2])%1000000007);
	}
}
```


---

## 作者：lzzVIL (赞：2)

## [题意](https://www.luogu.org/problemnew/show/P1962)
大家都知道，斐波那契数列是满足如下性质的一个数列：
- $f(1)=1$
- $f(2)=1$
- $f(n)=f(n-1)+f(n-2)$ ($n \leq 2$且$n$为整数)
请你求出$f(n)\ mod\ 1000000007$的值。
## 输入
第1行：一个整数$n$
## 输出
第1行：$f(n)\ mod\ 1000000007$的值
## 题解
n很大，必须使用矩阵快速幂。
已知：

1. $f_{n+1}=f_n+f_{n-1}=1 \cdot f_n+1 \cdot f_{n-1}$

2. $f_n=f_{n-1}+f_{n-2}=1 \cdot f_n+0 \cdot f_{n-1}$

那么，从上面两行的最后式子可以推导出：
$$\left[^{f_{n+1}}_{f_n}\right]=\left[^{1\ 1}_{1\ 0}\right] \cdot \left[^{f_n}_{f_{n-1}}\right]$$
而矩阵：
$$\left[^{1\ 1}_{1\ 0}\right]$$
就是我们要求的初始矩阵。

将其多次自乘之后所得矩阵的第2行的第1项即为所求。

单$1 \leq n \leq 2$时，特判输出0即可。

~~下面内容可自行选择跳过。~~

--- 
## 矩阵快速幂（可自行百度）
### 矩阵乘法
#### 矩阵乘法公式：
对于$n \times m$矩阵A和$m \times k$矩阵B，相乘所得的矩阵C是一个$n \times k$矩阵。且对于$1 \leq i \leq n,1 \leq j \leq k$，都有$C_{i,j}=\sum^{m}_{l=1}A_{i,l}B_{l,k}$

**注意：矩阵乘法不满足交换律，但满足结合律！！！**

#### 矩阵快速幂：
对于$n \times n$矩阵A，我们将其称为“n阶方阵”。因此，$A^m$（m为整数）也必定有意义，且也必定是一个n阶方阵。这样计算得出的矩阵，称为“矩阵A的m次幂矩阵”。

因为矩阵满足结合律，我们可以将矩阵A一部分一部分地自乘，这样结果是不会变的。

因为这种过程类似于单个数的快速幂（速度真的快很多），因此称为“矩阵快速幂”。

---
~~跳过内容结束。~~

所以我们只需要求出初始矩阵，并求出它的n次幂就可以了。
空间非常小（因为初始矩阵也就只有那么大），时间复杂度为$O(\log n)$~~（都是我猜的）~~。

反正不管怎么样，矩阵快速幂自然可以过啦。
## 代码
```
#include<cctype>
#include<cstdio>
#define ll long long
#define mod 1000000007
#define rep(i,a,b) for(long long(i)=(long long)(a);(i)<=(long long)(b);++i)
using namespace std;
#define gc getchar
inline long long read(){long long x=0,f=0;char c=gc();for(;!isdigit(c);c=gc())f^=c=='-';for(;isdigit(c);c=gc())x=(x<<3)+(x<<1)+(c^'0');return f?-x:x;}
inline long long read(long long&x){x=0;long long f=0;char c=gc();for(;!isdigit(c);c=gc())f^=c=='-';for(;isdigit(c);c=gc())x=(x<<3)+(x<<1)+(c^'0');return x=(f?-x:x);}
inline long double dread(){long double x=read(),y=read();while(y>1)y/=10;return x>0?x+y:x-y;}
ll n=2,N;
struct Mat{
	ll M[10][10];
	inline void scan(){rep(i,1,n) rep(j,1,n) read(M[i][j]);}
	inline void print(){
		rep(i,1,n){
			rep(j,1,n-1) printf("%lld ",M[i][j]);
			printf("%lld\n",M[i][n]);			
		}		
	}
	inline void def(){rep(i,1,n) rep(j,1,n) M[i][j]=0;}
	inline void defE(){def();rep(i,1,n) M[i][i]=1;}
	inline friend Mat operator*(const Mat&A,const Mat&B){
		Mat C;C.def();
		rep(i,1,n)
		rep(j,1,n)
		rep(k,1,n)
			(C.M[i][j]+=A.M[i][k]*B.M[k][j]%mod)%=mod;
		return C;	
	}
    //运算符重载：矩阵乘法
	inline friend Mat pow(Mat A,ll b){
		Mat ret;ret.defE();
		for(;b;b>>=1,A=A*A) if (b&1) ret=ret*A;
		return ret;	
	}
    //矩阵快速幂
}ans,base;
//ans是答案矩阵，base是初始矩阵
inline void init(){
	ans.defE();
	base.def(),base.M[1][1]=base.M[1][2]=base.M[2][1]=1;	
}
signed main(){
	read(N);
	if (N<=n){puts("1");return 0;}
	init();
	ans=pow(base,N);
	printf("%lld\n",ans.M[2][1]);
	return 0;
}
```

---

## 作者：AVALON_7 (赞：2)

考前颓废x2

大致思想和其他题解差不多。。

代码可能更好看一些。。然后这个代码也不需要n-2以及特判，直接快速幂。

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;

inline long long red()
{
    long long X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}

const long long MOD=1000000007;   
struct mat{long long a[2][2];};   

mat mat_mul(mat x,mat y)           //实现两个矩阵相乘，返回的还是一个矩阵。   
{   
    mat res;                       //用来表示得到的新的矩阵；   
    memset(res.a,0,sizeof(res.a));   
    for(int i=0;i<2;i++)   
        for(int j=0;j<2;j++)   
           for(int k=0;k<2;k++)   
                res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%MOD)%MOD;   
    return res;   
}   

mat initi(mat a,mat ans,long long b)
{
    while(b>0)
    {
        if(b&1) 
          ans = mat_mul(ans,a);
        b = b >> 1;
        a = mat_mul(a,a);
    }
    return ans;        
}

long long n;
int main()
{
    mat a,b;
    
    a.a[0][0]=1;
    a.a[0][1]=1;
    a.a[1][0]=1;
    a.a[1][1]=0;
    
    b.a[0][0]=1;
    b.a[0][1]=1;
    b.a[1][0]=1;
    b.a[1][1]=0;

    n=red();
    b=initi(a,b,n);
    cout<<b.a[1][1];
    
    return 0;
}
```

---

## 作者：zsc2003 (赞：2)

这道题如果仅仅用递归或者递推的方法的话会超时
所以我们可以一种神奇的方法——使用矩阵
斐波那契数列用矩阵的推导如下：
![斐波那契数列的推导](https://cdn.luogu.com.cn/upload/pic/19051.png)

A 1 1

  1 0 
  
菲波那切数列通项公式——使用矩阵快速幂以及整数乘法实现O(2^3lgn)
在得到公示后我们的问题就变成了求矩阵A的i-2次方
所以在这里我们就需要用到矩阵的快速幂了
矩阵快速幂可以用到二分的思想，详细的话大家可以去洛谷的矩阵快速幂的模板进行练习
矩阵快速幂方法如下：

![矩阵快速幂的做法](https://cdn.luogu.com.cn/upload/pic/19049.png)

下面就附上我的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct jz
{
    ll x[110][110];
};
jz a,ans,A,r;
ll n,m,t;
jz cheng(jz A,jz B,ll mod)//两个矩阵相乘 
{
    jz c;
    for(int i=1;i<=t;i++)
    {
   		for(int j=1;j<=t;j++)
        {
            c.x[i][j]=0;
            for(int k=1;k<=t;k++)
            {
                c.x[i][j]+=A.x[i][k]*B.x[k][j]%mod;
                c.x[i][j]=c.x[i][j]%mod;
            }
        }
	}
    return c;
}
jz danweizhen()//得到一个单位阵 
{
    jz A;
    for(int i=1;i<=t;i++)
        for(int j=1;j<=t;j++)
        {
            if(i==j)
                A.x[i][j]=1;
            else
                A.x[i][j]=0;
        }
    return A;
}
jz kuaisumi(jz A,ll n,ll mod)//求A^n%mod
{
    jz ans=danweizhen();
    jz T=A;
    for(;n;n/=2)
    {
        if(n&1)
            ans=cheng(ans,T,mod);
        T=cheng(T,T,mod);
    }
    return ans;
}
int main()
{
    t=2,m=1000000007;
    scanf("%lld",&n);
    if(n<=160)
    {
        ll f[200];
        f[1]=f[2]=1;
        for(int i=3;i<=n;i++)
            f[i]=f[i-1]+f[i-2];
        cout<<f[n]%m;
        return 0;
    }
    A.x[1][1]=A.x[1][2]=A.x[2][1]=1,A.x[2][2]=0,a.x[1][1]=a.x[2][1]=1;
    ans=kuaisumi(A,n-2,m);
    r.x[1][1]=r.x[2][1]=1;//f[1]=f[2]=1
    r=cheng(ans,r,m);
    printf("%lld\n",r.x[1][1]);
    return 0;
}

```

 

---

## 作者：xcyy (赞：1)

此题暴力其实能有70分，就这样
递推就行了，如果考试出这道题这个数据还是很友好的。
```
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long 
#define mod 1000000007 
ll n;

ll f3,f2,f1;

int main()
{
	scanf("%lld",&n);
	f1=1;f2=1;
	for(int i=3;i<=n;i++)
	{
	f3=f2+f1;
	f1=f2;f2=f3;
	f1%=mod,f2%=mod,f3%=mod;	
	}
	if(n==1)
	{
	cout<<1<<endl;
	return 0;	
	}
	if(n==2)
	{
		cout<<1<<endl;
		return 0;
	}
	printf("%lld",f3%mod);
	return 0;
}
```

但这毕竟不是正道啊，虽然一楼也有大佬用公式玄学优化并且过了，但我这种蒟蒻学不来。这题式子也有管理员大佬推过了，我就直接上代码吧（加一点标注）
```
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long 
#define mod 1000000007 
#define N 3
ll n;

struct node 
{
	ll g[N+2][N+2];
}f,res;

inline void matrixi(node &x)
{	
	for(int i=1;i<=N;i++)
	for(int j=1;j<=N;j++)
	if(i==j)x.g[i][j]=1LL;
	else x.g[i][j]=0LL;//这个LL其实没什么用 
}

inline void matrixmul(node &x,node &y,node &z)
{
	memset(z.g,0,sizeof(z.g));
	for(ll i=1;i<=N;i++)
	for(ll j=1;j<=N;j++)
	if(x.g[i][j])
	{
		for(ll k=1;k<=N;k++)
		{
			z.g[i][k]+=x.g[i][j]*y.g[j][k];
			if(z.g[i][k]>=mod)z.g[i][k]%=mod;
		}
	}
}

inline void matrixmuli(ll k){

	matrixi(res);
	node tmp=f,t;
	while(k){
		if(k&1)
		{
			matrixmul(res,tmp,t);res=t;//矩阵乘 
		}
		matrixmul(tmp,tmp,t);tmp=t;
		k>>=1;
	}
}

inline ll solve()
{
	if(n<=2)return 1LL;
	matrixmuli(n-2);//矩阵快速幂
	//1 1 
	//1 0 这个矩阵的n-2次方 
	ll ret=res.g[1][1]+res.g[2][1];
	if(ret>=mod)ret-=mod;//取Mod其实 
	return ret;
}]
int main()
{
	scanf("%lld",&n);
	f.g[1][1]=1;
	f.g[1][2]=1;
	f.g[2][1]=1;
	f.g[2][2]=0;//初始矩阵的预处理 
	ll ans=solve();
	printf("%lld\n",ans);
	return 0;
}
```




---

## 作者：wancong (赞：1)

## 善用class

大家都知道是矩阵快速幂了，那么，算法的具体实现我就不说了。我是想借此说一下C++中的类是如何使用的。

类的一个重要功能就是运算符重载，这是一个非常方便的语法糖，让代码变得简洁易懂。我是一个“码不简洁死不休”的人，看到一大堆mult mult mult简直想吐，所以嘛，干脆来个class多省事。

### 一、矩阵类的代码

```cpp
class matrix
{
private:
    long long mmm[2][2];
    static const long long MOD = 1000000007LL;

public:
    explicit matrix(long long a = 1, long long b = 0, long long c = 0, long long d = 1)
    { // 构造函数，默认参数对应一个单位矩阵
        mmm[0][0] = a;
        mmm[0][1] = b;
        mmm[1][0] = c;
        mmm[1][1] = d;
    }

    inline long long get0_1() const
    { // 返回第0行1列的数，这正是斐波那契数列对应的项
        return mmm[0][1];
    }

    matrix& operator=(const matrix& m)
    { // 注意，二维数组不能直接赋值，所以要重载赋值运算符
        mmm[0][0] = m.mmm[0][0];
        mmm[0][1] = m.mmm[0][1];
        mmm[1][0] = m.mmm[1][0];
        mmm[1][1] = m.mmm[1][1];
        return *this;
    }

    matrix operator*(const matrix& m) const
    { // 这是最核心的部分，矩阵乘法
        matrix tmp;
        tmp.mmm[0][0] = (mmm[0][0] * m.mmm[0][0] + mmm[0][1] * m.mmm[1][0]) % MOD;
        tmp.mmm[0][1] = (mmm[0][0] * m.mmm[0][1] + mmm[0][1] * m.mmm[1][1]) % MOD;
        tmp.mmm[1][0] = (mmm[1][0] * m.mmm[0][0] + mmm[1][1] * m.mmm[1][0]) % MOD;
        tmp.mmm[1][1] = (mmm[1][0] * m.mmm[0][1] + mmm[1][1] * m.mmm[1][1]) % MOD;
        return tmp;
    }
};
```

### 二、详解

#### 1、构造函数matrix()

构造函数是用来创建一个对象的。它不是手动调用的，而是创建对象时自动调用的。它可以指定参数和操作。比如，我们上面的构造函数用四个参数来指定矩阵的四个元素。另外，它还有默认参数，也就是当不指定参数时，取默认值，比如创建一个矩阵matrix()，将返回一个单位矩阵。

#### 2、重载赋值运算符=

如果不重载赋值运算符，则赋值运算符将逐个复制类的非const成员。但是，我们这里类的成员是二维数组，不能直接赋值，所以必须重载赋值运算符，将二维数组的元素逐个复制。

#### 3、重载乘号运算符*

这是我们的重中之重。如果不重载，则编译器不认为matrix类可以做乘法运算。所以，这个重载是为了创建一种新运算使得编译器认识这个用法。

#### 4、返回值和参数的类型

首先来看传参。C++中传参有按值传递和按引用传递两种形式。按值传递，相当于用赋值运算符把实际参数的值赋值给形式参数，所以要隐式调用赋值运算符。如果这个类很大，则赋值运算符需要占用非常多的时间。而按引用传递则不同，是把原变量本身直接捆绑到形式参数上，不需要调用赋值运算符。因此，我们推荐，class类型的参数用引用传递，如果不需要修改参数的值，则用const引用。比如我们的赋值运算符和乘号重载都是用const引用传参。

再来看返回值类型。如果是需要返回一个新的对象，比如乘号，则需要返回类本身的类型，并且一定要返回一个新创建的对象，而不能返回参数对应的东西。因为参数是个引用，如果直接返回参数，则返回值和参数对应的变量是同一个，这会引发不可预知的问题。

如果是需要返回原变量的引用，比如赋值运算符，则直接返回引用，而不需要创建新对象。这样避免了新创建对象调用构造函数。赋值运算符是对变量本身的操作，不需要创建新对象。

另外，从C++11开始，还有所谓“复制构造函数”“移动构造函数”和“移动赋值运算符”的概念，但如果细讲，需要用一本书的内容，这里就从略了。如果想深入了解类设计时参数和返回值的类型选择，参考《C++ primer plus 第6版》第13章。

从这点看，因为要和C兼容，C++的类设计远比Java要繁琐。但Java不提供运算符重载也是不能忍啊！各有千秋，个人感觉如果是做面向对象设计，Java更合适。

#### 5、函数之后的const的作用

const有一种用法是指定变量不可更改，成为常量。另外，还可以追加在函数头之后，比如我们上面的乘号运算。这种用法，是告诉编译器，这个函数将不会修改类对象的任何内容。这样做的目的就是，使得类的const对象也可以调用这个函数。

如果不加const，则常量（类的const对象）不可调用这个函数。所以，像加减乘除，还有getter这类不对原变量进行修改的函数，一律在函数头的尾部添加const。但如果是需要修改原变量的，比如赋值运算符，则一律不能加const。

#### 6、快速幂函数的写法

有了重载运算符之后，我们就可以很简洁地写出power函数了：

```cpp
matrix power(const matrix& m, long long t)
{
    if (t <= 0) return matrix();
    if (t == 1) return m;
    matrix tmp = power(m, t >> 1);
    if (t & 1) return tmp * tmp * m;
    else return tmp * tmp;
}
```

主函数：

```cpp
int main()
{
    long long n;
    scanf("%lld", &n);
    printf("%lld", power(matrix(1, 1, 1, 0), n).get0_1());
    return 0;
}
```

非常简洁！

---

## 作者：轻尘 (赞：1)

# 矩阵快速幂练习题
## 思路就不说了，大家都基本一样，~~英雄所见略同。~~
------------
# 我来FAQ一下

# &1 斐波那契的矩阵是1*2的，
## 乘法所用的矩阵是2*2的；所以在mul（）中
## 是这样的
```cpp
MA mul(MA x,MA y)
{
    MA z;
    memset(z.m,0,sizeof(z.m));  
    for(int a=1;a<=2;a++)
        for(int b=1;b<=2;b++)
            for(int c=1;c<=2;c++)
                z.m[a][b] = (z.m[a][b]+(x.m[a][c]*y.m[c][b])%mod)%mod;
    return z;
}
```
## 为什么都用2次循环？？
## 因为mul（）还要用作x*x；
同时z.m[2][]并不会对结果有影响；

------------

# &2    n-=2???
### 这个地方就非常苟了，完全摸不着头脑；
### 因为初始ans={f1,f2}，我们乘一次就是{f2,f3}
### so 我们不必再求前两项，直接*（n-2）；
### 这个地方要多注意，n不一定减几；



## 如P1939,那里n是-3的；
------------

code
------------
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define ll long long
using namespace std;
const ll mod = 1000000007;
inline ll read()
{
    ll x = 0;char c = getchar();
    while(!isdigit(c))c = getchar();
    while(c>='0'&&c<='9')
    {
        x = x*10+c-'0';c = getchar();
    }
    return x;
}
struct MA
{
    ll m[3][3];
}ans,x;
MA mul(MA x,MA y)
{
    MA z;
    memset(z.m,0,sizeof(z.m));  
    for(int a=1;a<=2;a++)
        for(int b=1;b<=2;b++)
            for(int c=1;c<=2;c++)
                z.m[a][b] = (z.m[a][b]+(x.m[a][c]*y.m[c][b])%mod)%mod;
    return z;
}
int main()
{
    ll n = read();
    if(n==0)
        cout<<"0"<<endl;
    else if(n==1||n==2)
        cout<<"1"<<endl;
    else { 
    n-=2;
    x.m[1][1]=1,x.m[1][2]=1,x.m[2][1]=1,x.m[2][2]=0;
    ans.m[1][1] = 1,ans.m[1][2] = 1;
    while(n)
    {
        if(n&1) ans=mul(ans,x);
        x = mul(x,x);
        n>>=1;
    }
    cout<<ans.m[1][1]<<endl;
    }
    return 0;
}
```
# PS：如果你写的是0 1 1 1 cout<<ans.m[1][3];

---

## 作者：thekeyto (赞：1)

用的是矩阵 可以推导

【1 1】\*【a】=【a+b】

1 0        b           a

然后根据矩阵乘法求得【1 1】^（n-1）\*【1】就可以解决

1 0                     1

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
long long mod=1000000007;
struct matrix
{
    long long mat[5][5];
    matrix() {memset(mat,0,sizeof(mat));}
};
matrix mal(matrix A,matrix B)
{
    matrix C;
    for(int i=1;i<=2;i++)
    for(int j=1;j<=2;j++)
    for(int k=1;k<=2;k++)
    C.mat[i][j]=(C.mat[i][j]+A.mat[i][k]*B.mat[k][j])%mod;
    return C;
}
matrix powmul(matrix A,long long k)
{
    matrix B;
    for(int i=1;i<=2;i++) B.mat[i][i]=1;
    while(k)
    {
        if (k%2) B=mal(A,B);
        A=mal(A,A);
        k>>=1;
    }
    return B;
}
int main()
{
    long long n;
    cin>>n;
    matrix A,B;
    B.mat[1][1]=1,B.mat[2][1]=1;
    A.mat[1][1]=1,A.mat[1][2]=1;
    A.mat[2][1]=1,A.mat[2][2]=0;
    printf("%lld",mal(powmul(A,n-1),B).mat[2][1]);
    return 0;
}
```

---

## 作者：kkke (赞：1)


\*对矩阵进行优化算法                by kkke in 2015.9.12

   
在进行矩阵运算时，[a b],发现此题中每一步b=c恒成立，且a=b+d恒成立

[c d]
                  
于是定义新结构   [x,y]   如：A=[a1,a2], B=[b1,b2],C=[c1,c2]；

并使   [x1,y1]\*[x2,y2]=[x1\*x2+y1\*y2,x1\*y2+x2\*y1+y1\*y2];

即 ：若 C=A\*B，则  c1=a1\*b1+a2\*b2   ,   c2=a1\*b2+a2\*b1+a2\*b2

易证  结构[x,y]之间的乘法满足 乘法分配率 与 乘法交换律

 
设数组 a[]为fibonacii数组

则可以得到 递推公式  [ a[n-1] , a[n] ] \*[0,1]=[ a[n] , a[n+1] ]

而通项公式就为  [ a[n-1] , a[n] ]=[ a[1] , a[2] ]\*power([0,1],n-1) =power([0,1],n);

则只需用快速幂求出[0,1]的n次方，然后拿出后一位即为a[n]；


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

#define MOD(x_mod) ((x_mod)%1000000007 )

long long n,num_one=1;

struct fibo{
    long long x,y;
    fibo operator *(fibo a)
    {
        fibo b;
        b.x=MOD(MOD(a.x*x)+MOD(a.y*y));
        b.y=MOD(MOD(a.x*y)+MOD(a.y*x)+MOD(a.y*y));
        return b;
    }
};

fibo a,b;

void quick_power(long long k)
{
    k--;
    while(k)
    {
        if(k&num_one)b=b*a;
        a=a*a;
        k>>=num_one;
    }
}

void init()
{
    a.x=0;a.y=1;
    b.x=0;b.y=1;
}

int main()
{
    scanf("%I64d",&n);
    init();
    quick_power(n);
    printf("%I64d\n",b.y);
    return 0;
}

```

---

## 作者：resftlmuttmotw (赞：1)



 以前学过的，现在忘了 居然没有做过笔记
 
 又得再学一遍2333
 
 ## 定义
 
 与数学上矩阵乘法相同
 
 
 如下 $A$是一个 $n*m$的矩阵
$$
A=\left[
\begin{matrix}
a_{1,1} & a_{1,2} & a_{1,3}&...a_{1,m} \\
a_{2,1} & a_{2,2} & a_{2,3}&...a_{2,m} \\
...& ...&...&...\\
a_{n,1} & a_{n,2} & a_{n,3}&...a_{n,m} 
\end{matrix} \right]
$$

 如下 $B$是一个 $m*p$的矩阵
 
 $$
B=\left[
\begin{matrix}
b_{1,1} & b_{1,2} & b_{1,3}&...b_{1,p} \\
b_{2,1} & b_{2,2} & b_{2,3}&...b_{2,p} \\
...& ...&...&...\\
b_{m,1} & b_{m,2} & b_{m,3}&...b_{m,p} 
\end{matrix} \right]
$$

如下 $C=A*B (n*p)$

$$
C=\left[
\begin{matrix}
\displaystyle\sum_{i=1}^{m}a_{1,i}*b_{i,1}& c_{1,2} & c_{1,3}&...c_{1,p} \\
c_{2,1} & c_{2,2} & c_{2,3}&...c_{2,p} \\
...& ...&...&...\\
c_{m,1} & c_{m,2} & c_{m,3}&...c_{m,p} 
\end{matrix} \right]
$$

可知

$$c_{i,j} = \displaystyle\sum_{k=1}^{m}a_{i,k}*b_{k,j}$$

## 实现

```cpp
struct matrix
{
	ll n,m,c[MAXN][MAXN];
	matrix operator *(matrix &B) const
	{
		matrix C;
		C.n = n,C.m = B.m;
		for(reg i = 1;i <= n;i++)
			for(reg k = 1;k <= B.m;k++)
			{
				C.c[i][k] = 0;
				for(reg j = 1;j <= m;j++)
						C.c[i][k] = (C.c[i][k] + c[i][j] * B.c[j][k]) % mod;	
			}
		return C;
	}
	void pr()
	{
		for(reg i = 1;i <= n;i++)
		{
			for(reg j = 1;j <= m;j++)
			{
				printf("%d ",c[i][j]);
			}
			putchar('\n');
		}
		putchar('\n');
	}
};
```

## 用途

加快$dp$

例如 [P1962 斐波那契数列](https://www.luogu.org/problem/P1962)

```cpp
动态规划方程为

dp[i] = dp[i - 1] + dp[i - 2]
```

求 第$n$项

先画个矩阵
$$
\left[
\begin{matrix}
0&1\\
1&1\\
\end{matrix} \right]
$$

$$
\left[
\begin{matrix}
dp[i]&dp[i + 1]\\
\end{matrix} \right]
$$

$\displaystyle\Rightarrow^{A*B}$  

$$
\left[
\begin{matrix}
dp[i+1]&d[i+2]\\
\end{matrix} \right]
$$

看到这里 就明白了了

但是这样 时间并没有减少啊

$Attention$


矩阵乘法满足交换律
$$A*B*C=A*(B*C)$$

那么

$$
\left[
\begin{matrix}
0&1\\
1&1\\
\end{matrix} \right]
$$

可以使用**矩阵快速幂**了！！

构建 一个矩阵$B$

$S.T.A*B=A$

在这道题中

$$B=\left[
\begin{matrix}
1&0\\
0&1\\
\end{matrix} \right]
$$

```cpp
inline matrix qkpow(matrix A,ll n)
{
	matrix res;
	res.n = res.m = 2,res.c[1][1] = res.c[2][2] = 1;
	res.c[1][2] = res.c[2][1] = 0;
	while(n)
	{
		if(n & 1) res = res * A;
		n >>= 1;
		A = A * A;
	}
	return res;
}
```

## $Code$

```cpp
#include <cmath>
#include <cstdio>
#include <climits>
#include <iostream>
#include <algorithm>
using namespace std;
#define isdigit(x) ('0' <= (x)&&(x) <= '9')
#define reg register int
template<typename T>
inline T Read(T Type)
{
	T x = 0;
	bool f = 0;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = 1;a = getchar();}
	while(isdigit(a)) x = (x << 1) + (x << 3) + a - '0',a = getchar();
	if(f) x *= -1;
	return x;
}
typedef long long ll;
const int MAXN = 100,mod = 1000000007;
struct matrix
{
	ll n,m,c[MAXN][MAXN];
	matrix operator *(matrix &B) const
	{
		matrix C;
		C.n = n,C.m = B.m;
		for(reg i = 1;i <= n;i++)
			for(reg k = 1;k <= B.m;k++)
			{
				C.c[i][k] = 0;
				for(reg j = 1;j <= m;j++)
						C.c[i][k] = (C.c[i][k] + c[i][j] * B.c[j][k]) % mod;	
			}
		return C;
	}
	void pr()
	{
		for(reg i = 1;i <= n;i++)
		{
			for(reg j = 1;j <= m;j++)
			{
				printf("%d ",c[i][j]);
			}
			putchar('\n');
		}
		putchar('\n');
	}
};
inline matrix qkpow(matrix A,ll n)
{
	matrix res;
	res.n = res.m = 2,res.c[1][1] = res.c[2][2] = 1;
	res.c[1][2] = res.c[2][1] = 0;
	while(n)
	{
		if(n & 1) res = res * A;
		n >>= 1;
		A = A * A;
	}
	return res;
}
int main()
{
	ll n = Read(1ll); n -= 1;
	matrix A,B;
	A.n = 1,A.m = 2,A.c[1][1] = A.c[1][2] = 1;
	B.n = B.m = 2,B.c[1][1] = 0,B.c[1][2] = B.c[2][1] = B.c[2][2] = 1;
	matrix C = qkpow(B,n);
	A = A * C;
	printf("%lld",A.c[1][1]);
	return 0;
}
```

---

## 作者：人间凡人 (赞：1)

大家拿道题一看，肯定会想这不是很简单么！

但是题目下面写了$n$在$long long$的范围内，如果单用递推去写，是会超时的。

代码就贴一下吧！**三个变量 节省空间**

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,x,y,z;
int main() {
	scanf("%lld",&n);
	if(n==1||n==2)printf("1\n");
	else{
		x=1;y=1;
		for(int i=3;i<=n;i++){
			z=x+y;
			x=y;y=z;
		}
		printf("%lld\n",z);
	}
	return 0;
}

```
那么就要用一种时间复杂度为$log\ n$的时间复杂度去做了，**矩阵乘大法好呀**！

相信大家一定学过矩阵乘法了吧，这道题其实就是矩阵快速幂的题目。

我们知道矩阵快速幂刚开始会有一个矩阵，所以我们需要先把刚开始的矩阵给求出来。

首先，可以判断出刚开始的是一个$2*2$的矩阵.
然后因为斐波那契数列为前两项的和,所以

$f[n]=1f[n-1]+1f[n-2]$

$f[n-1]=1f[n-1]+0f[n-2]$

可得最初的矩阵为$:$

$1\ \ \ \ \ \ \ 1$

$1\ \ \ \ \ \ \ 0$

然后就根据写矩阵快速幂的写法做即可。

**注意：因为斐波那契已知前两项，所以要求开始矩阵的$(n-2)$次就够了**

我就来写一篇无函数版的代码吧！

$Code:$

```cpp
#include <bits/stdc++.h>
#define Mod 1000000007
using namespace std;
long long n,m;
long long a[105][105],b[105][105],c[105][105];
int main() {
	scanf("%lld",&m);
	a[1][1]=a[1][2]=a[2][1]=1;a[2][2]=0;
	n=2;for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)b[i][j]=a[i][j];
	m-=2;
	while(m){
		if(m%2==1){
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)c[i][j]=0;
			for(int k=1;k<=n;k++)
				for(int i=1;i<=n;i++)
					for(int j=1;j<=n;j++)
						c[i][j]=(c[i][j]+a[i][k]*b[k][j])%Mod;
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					b[i][j]=c[i][j];
		}
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				c[i][j]=a[i][j],a[i][j]=0;
		for(int k=1;k<=n;k++)
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					a[i][j]=(a[i][j]+c[i][k]*c[k][j])%Mod;
		m/=2;		
	}
	printf("%lld\n",b[1][1]%Mod);
	return 0;
}

```




---

## 作者：Tanktt (赞：1)

这是初学线性代数后的第一道编程题。。。
这一次，我对矩阵有了一个深刻的了解。

我们知道：
1. f[n]=1·f[n-1]+1·f[n-2];
1. f[n-1]=1·f[n-1]+0·f[n-2];

从中你看出了什么？？我们可以把它转化成矩阵乘法：


|   f[i] | = |  1 1  |  *|  f[i-1]|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|   f[i-1] |  | 1 0   |  |  f[i-2]|



依次递推...
那么只要

| 1 | 1 |   ^(n-2)次
| :----------: | :----------: | 
|  1| 0 |
乘上

| f[1] |
| :----------: |
|  f[2]|

而由于f[1]]=f[2]=1，所以只要计算该矩阵的第一行即可，而初始值即为单位矩阵。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int oo=1000000007;
struct node{
	long long g[3][3];
}bit,res;
long long n;
inline void matrixI(node &x)//单位矩阵
{
	for (int i=1; i<=2; i++)
		for (int j=1; j<=2; j++) x.g[i][j]=(long long)(i==j);
}
inline void matrix_multiple(node &x,node &y,node &z)//矩阵乘法
{
	memset(z.g,0,sizeof(z.g));
	for (int i=1; i<=2; i++)//第一个矩阵的行
		for (int j=1; j<=2; j++)//第二个矩阵的列
		{
			for (int k=1; k<=2; k++)//第一个矩阵的列/第二个矩阵的行
			z.g[i][j]=(z.g[i][j]+x.g[i][k]*y.g[k][j])%oo;
		}
		/*
	for (int i=1; i<=2; i++)//第一个矩阵的行
		for (int j=1; j<=2; j++)//第一个矩阵的列/第二个矩阵的行
		if (x.g[i][j])
		{
			for (int k=1; k<=2; k++)//第二个矩阵的列
			z.g[i][k]=(z.g[i][k]+x.g[i][j]*y.g[j][k])%oo;
		}*/
}
inline long long matrix_fp(long long b)//矩阵快速幂
{
	node tmp=bit,t;
	while (b)
	{
		if (b&1)
		{
			matrix_multiple(res,tmp,t);
			res=t;//把t赋到res里 
		}
		matrix_multiple(tmp,tmp,t);tmp=t;
		b>>=1;
	}
}
inline long long solve()
{
	matrixI(res);
	if (n<=2) return 1LL;//即为1 
	matrix_fp(n-2);
	return (res.g[1][1]+res.g[1][2])%oo;
    //f[n]是矩阵第一行的和 
}
int main()
{
	scanf("%lld",&n);
	bit.g[1][1]=bit.g[1][2]=bit.g[2][1]=1,bit.g[2][2]=0;
	return printf("%lld\n",solve()),0;
}
```

---

## 作者：ergeda (赞：1)

//此是矩阵乘法的裸题，初始矩阵为|1 1|用它乘上 另一个矩阵|f[i-1]|之后得到的矩阵就是|f[i-1]+f[i-2]|其实也就是|f[i]   |
                                                       |1 0|                                 |f[i-2]|                               |f[i-1]|         |                 |f[i-1]|
这样就转化好了,把初始矩阵不断的平方就能大大的提高效率，还要用上快速幂；

```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#define mod 1000000007
using namespace std;
struct matrix{
    long long p[3][3];
    matrix(long long d=0){
        if(d==0)memset(p,0,sizeof(p));
        else {//初始化矩阵
            p[1][1]=1;
            p[1][2]=1;
            p[2][1]=1;
            p[2][2]=0;
        }
    }
};
matrix operator * (matrix a,matrix b){//因为是矩阵相乘，所以要重载运算符
    matrix c;
    long long i,j,k;
    for(i=1;i<=2;i++)
        for(j=1;j<=2;j++)
            for(k=1;k<=2;k++){
                c.p[i][j]=((c.p[i][j]+a.p[i][k]*b.p[k][j])%mod)%mod;//边乘边模
            }
    return c;
}
matrix ksm(matrix a,long long x){//快速幂
    matrix b=1;
    long long ans=0;
    while(x){
        if(x%2){
            b=b*a;
        }
        a=a*a;
        x/=2;
    }
    return b;
}
int main(){
    long long i,j,k,m,n;
    scanf("%lld",&m);
        if(m==0){printf("0\n");return 0;}
        if(m==1){printf("1\n");return 0;}
        if(m==2){printf("1\n");return 0;}
        matrix a=1;
        matrix b=ksm(a,m-3);
        printf("%lld\n",(b.p[1][1]+b.p[1][2])%mod);
    return 0;
}
```

---

## 作者：汇文客 (赞：1)

递推会爆时间，特征方程会爆精度，这里采用矩阵求法。比较难，建议同学先学习一点矩阵相关知识，再做此题。

```delphi

type ztp=array[1..4]of qword;
const m=1000000007;
      s:array[1..4]of qword=(1,0,0,0);
var f:ztp;
    n:qword;
function time(a,b:ztp):ztp;//矩阵乘法
begin
  if(a[1]=1)and(a[1]=0)and(a[1]=0)and(a[1]=0)then exit(b);
  time[1]:=(a[1]*b[1]+a[2]*b[3])mod m;
  time[2]:=(a[1]*b[2]+a[2]*b[4])mod m;
  time[3]:=(a[3]*b[1]+a[4]*b[3])mod m;
  time[4]:=(a[3]*b[2]+a[4]*b[4])mod m;
end;

procedure e(var a:ztp;n:qword);//快速幂
var k:ztp;
begin
  k:=a;a:=s;
  while n>0 do
  begin
    if odd(n) then a:=time(a,k);
    n:=n div 2;
    k:=time(k,k);
  end;
end;

begin{main}
  readln(n);
  f[1]:=1;f[2]:=1;f[3]:=1;f[4]:=0;
  e(f,n-1);
  writeln(f[1]);
end.

```

---

## 作者：MILLOPE (赞：0)

[$\color{red}{my \ \ \ \ \ blog}$](https://blog.csdn.net/qq_34493840/article/details/95505301)

## 题目
题目背景
大家都知道，斐波那契数列是满足如下性质的一个数列：
• $f(1) = 1$
• $f(2) = 1$
• $f(n) = f(n-1) + f(n-2)$ ($n ≥ 2$ 且 $n$ 为整数)
题目描述
请你求出 $f(n) \mod 1000000007$ 的值。
输入输出格式
输入格式：
第1行：一个整数 $n$
输出格式：
第1行： $f(n) \mod 1000000007$ 的值

## 题解
- 前置技能：矩阵乘法
- 关于矩阵乘法：定义$A_{nm},B_{mp}$
$$A_{nm}*B_{mp}=C_{np}$$
- 也就是说这有第一个矩阵的列数等于第二个矩阵的行数时才能相乘
$$C_{i,j}=\sum_{k=1}^mA_{i,k}*B_{k,j}$$
- $C_{i,j}$等于$A$矩阵第$i$行与$B$矩阵第$j$列分别相乘再相加
- 首先我们显然能在$O(n)$的时间内求出斐波那契数列的第$n$项，然而对于这道题我们需要优化一下
- 设
$$F=\begin{bmatrix}f_{n-1}&f_{n-2}\end{bmatrix} \ \ \ \ F'=\begin{bmatrix}f_n&f_{n-1}\end{bmatrix}$$
- 若
$$F'=F*A$$
- 则
$$A=\begin{bmatrix}1&1\\1 &0\end{bmatrix}$$
- 令
$$F_0=\begin{bmatrix}f_2&f_1\end{bmatrix}=\begin{bmatrix}1&1\end{bmatrix}$$
- 则 
$$F_i=A^{i-2}*F_0=\begin{bmatrix}f_{i}&f_{i-1}\end{bmatrix}$$
- 然后我们就可以愉快的用矩阵乘法和矩阵快速幂在$O(2^3logT)$($T$为递推次数)的复杂度下过掉本题
- $ps:$矩阵快速幂的原理和普通的快速幂原理相同[快速幂模板](https://blog.csdn.net/qq_34493840/article/details/89080221)

## $code$
```cpp
#include <bits/stdc++.h> 
using namespace std; 
// const int maxn = 100000000 + 100;
#define mod 1000000007
typedef long long LL; 

template <typename T> 
inline void read(T &s) {
    s = 0; 
    T w = 1, ch = getchar(); 
    while (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); }
    while (isdigit(ch)) { s = (s << 1) + (s << 3) + (ch ^ 48); ch = getchar(); }
    s *= w; 
}

LL k; 

void mul(LL f[2], LL a[2][2]) {
	LL c[2]; 
	memset(c, 0, sizeof(c)); 
	for (int j = 0; j < 2; ++j) 
		for (int k = 0; k < 2; ++k) 
			c[j] = (c[j] + (LL)f[k] * a[k][j]) % mod; 
	memcpy(f, c, sizeof(c)); 
}

void mul_self(LL a[2][2]) {
	LL c[2][2]; 
	memset(c, 0, sizeof(c)); 
	for (int i = 0; i < 2; ++i) 
		for (int j = 0; j < 2; ++j) 
			for (int k = 0; k < 2; ++k) 
				c[i][j] = (c[i][j] + (LL)a[i][k] * a[k][j]) % mod; 
	memcpy(a, c, sizeof(c)); 
}

int main() {
	read(k); 
	if (k <= 2) puts("1"); 
	else {
		LL f[2] = { 1, 1 }; 
		LL a[2][2] = {{1, 1}, {1, 0}}; 
		for (k = k - 2; k; k >>= 1) {
			if (k & 1) mul(f, a); 
			mul_self(a); 
		}
		printf("%lld\n", f[0]); 
	}
	return 0; 
}
```

---

## 作者：Doveqise (赞：0)

这道题还没有看到我这种做法emmm就先发一下  
这个东西~~（经过玄学操作）~~ 效率奇棒(๑•̀ㅂ•́)و✧  
我就分享一下（代码短的一皮）  
（提示：本代码只供演示，不能A此题）  
（才不是∵没模数）
```cpp
#include<iostream>
using namespace std;
unsigned long long f(register unsigned long long i, register unsigned long long n1, register unsigned long long n2){return i == 1 ? n2 : f(i - 1, n2, n1 + n2);}
unsigned long long fib(register unsigned long long i){return f(i, 1, 1);}
signed main(){
    register int n = 0;
    cin >> n;
    cout << fib(n) << endl;
    return 0;
}
```


---

## 作者：温栀槿 (赞：0)

斐波那契数列相信很简单，但如果开到1e18呢？

这是我们需要引入矩阵快速幂来在logn的复杂度内求出

矩阵乘法实际上是线性方程的一种映射，详见
[矩阵乘法](https://www.zhihu.com/question/21351965)

我们考虑对于斐波那契数列

![](http://thyrsi.com/t6/386/1539240552x1822611437.gif)
*![](http://thyrsi.com/t6/386/1539240663x-1404775605.gif)
=![](http://thyrsi.com/t6/386/1539240761x-1566688347.gif)

所以我们通过矩阵快速幂就可以在logn的时间内求出斐波那契数列的第N项了

****注意一点，矩阵元素开LL，要不然乘的时候会溢出！！！****

代码：

```c
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define up(i,j,k) for(int i=j;i<=k;i++)


const int M=1e9+7;

struct Mat{
    ll m[3][3];//ll ll ll！！！
    void clear(){
        memset(m,0,sizeof(m));
    }
    void init(){
        for(int i = 1;i<=2;i++){
            m[i][i]=1;
        }
    }
};

Mat operator %(Mat a,int mod){
    Mat c;
    up(i,1,2){
        up(j,1,2){
            a.m[i][j]%=mod;
        }
    }
    c=a;
    return c;
}

Mat operator *(Mat a,Mat b){
    Mat c;
    c.clear();
    for(int i=1;i<=2;i++){
        for(int j=1;j<=2;j++){
            for(int k=1;k<=2;k++){
                c.m[i][j]+=(a.m[i][k]*b.m[k][j])%M;
            }
        }
    }
    c=c%M;
    return c;
}

Mat operator ^(Mat a,ll y){
    Mat ans;
    ans.clear();
    ans.init();
    while(y){
        if(y&1) ans=ans*a;
        a=a*a;
        y>>=1;
    }
    return ans;
}

int main(){
    ll n;
    scanf("%lld",&n);
    if(n<=2) {
        printf("1");
        return 0;
    }
    Mat zj;
    zj.clear();
    zj.m[1][1]=zj.m[1][2]=1;
    Mat c;
    c.clear();
    c.m[1][1]=0,c.m[1][2]=c.m[2][1]=c.m[2][2]=1;
    Mat Ans;
    Ans.clear();
    Ans=c^(n-2);
    Ans=zj*Ans;
    printf("%lld",Ans.m[1][2]);
}
```

---

## 作者：B_Qu1e7 (赞：0)

## 正解：矩阵乘法

(请原谅，我对latex还不是很熟悉)

矩阵乘法如何用：

比如说，我们有一个矩阵|a b|

那么，要求下两项，就变成|b a+b|

所以，要乘的矩阵应该是

A=

|0 1|

|1 1|这样一个二阶矩阵。（请自动脑补）

那么，乘的时候就变成

|a b|×A×A×A×A×A（n个A）

重点出场了，怎么样优化

请注意，**矩阵乘法满足乘法结合律**

所以我们把后面的A先相乘，就变成了快速幂

具体解法见P3390【模板】矩阵快速幂

不多说，见代码。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int frog=1e9+7;ll n;
struct matrix{ll a[3][3];}A,ans;
void multi(matrix &a,matrix b)
{
    ll c[3][3]={0};
    for(int i=1;i<3;i++)for(int j=1;j<3;j++)for(int k=1;k<3;k++)c[i][j]+=a.a[i][k]*b.a[k][j],c[i][j]%=frog;
    for(int i=1;i<3;i++)for(int j=1;j<3;j++)a.a[i][j]=c[i][j];
}
inline void kasumi()
{
    for(int i=1;i<3;i++)for(int j=1;j<3;j++)ans.a[i][j]=A.a[i][j];n--;
    while(n){if(n%2==1)multi(ans,A);multi(A,A);n/=2;}
}
int main()
{
    scanf("%lld",&n);
    ans.a[1][1]=ans.a[1][2]=1;//初始数据 
    A.a[1][1]=0,A.a[1][2]=A.a[2][1]=A.a[2][2]=1;//构造矩阵 
    kasumi();//矩阵快速幂 
    printf("%lld ",ans.a[1][2]%frog);
}
```

---

## 作者：沧澜 (赞：0)

#矩阵快速幂

我们可以根据斐波那契数列的递推式将其转化为一个

```cpp
      1 1       的(n-2)次方
      1 0
```
至于转化的原因：[Luogu](http://blog.csdn.net/lanchunhui/article/details/50569311)

这涉及到一些该死的数学问题，推论神马的，就自己撸吧。

所以这个问题就转化成了一个矩阵快速幂的裸(shui)题(ti)。

O(∩\_∩)O哈哈~，不废话了，上代码。

~\(≧▽≦)/~啦啦啦，代码君：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<cstdlib>
#define maxn 3
#define mod 1000000007
using namespace std;
long long n,a[maxn][maxn],ans[maxn][maxn],tmp[maxn][maxn];
void mi(long long s1[maxn][maxn],long long s2[maxn][maxn]){
    memset(tmp,0,sizeof(tmp));
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            for(int k=1;k<=2;k++)
                tmp[i][j]=(tmp[i][j]+s1[i][k]*s2[k][j])%mod;
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            s1[i][j]=tmp[i][j]; 
}
void work(){
    n=n-2;
    while(n){
        if(n&1)
            mi(ans,a);
        n=n/2;
        mi(a,a);
    }
    cout<<ans[1][1]<<endl;
}
int main(){
    cin>>n;
    if(n==0)
        cout<<"0"<<endl;
    else if(n==1||n==2)
        cout<<"1"<<endl;
    else{
        a[1][1]=1;a[1][2]=1;
        a[2][1]=1;a[2][2]=0;
        ans[1][1]=1;ans[1][2]=1;
        ans[2][1]=1;ans[2][2]=0;
        work();
    }
}
```

---


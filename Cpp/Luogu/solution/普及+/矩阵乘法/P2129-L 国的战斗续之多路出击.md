# L 国的战斗续之多路出击

## 题目背景

广而告之：背景见其他L国的战斗！！大家一起刷


## 题目描述

这一次，L 国决定军队分成 $n$ 组，分布在各地，若以 L 国为原点，可以看作在一个直角坐标系内。但是他们都受统一的指挥，指令部共发出 $m$ 个命令。命令有移动、上下转移和左右转移，但是由于某些奇奇怪怪的原因，军队收到命令总是有延迟，为了方便，军方已经写好一个栈，所以你要处理的顺序，应该是从后往前。


## 说明/提示

对于 $30\%$ 的数据，$1\leqslant n,m\leqslant 1000$。

对于 $100\%$ 的数据，$1\leqslant n,m\leqslant 5\times 10^5$，$x_i,y_i$ 在 `int` 范围内。

## 样例 #1

### 输入

```
3 3
0 0
4 -3
6 7
x
m -1 2
y
```

### 输出

```
1 2
-3 5
-5 -5
```

# 题解

## 作者：sSay (赞：24)

# 模拟

对就是模拟，但显然朴素的模拟是过不掉的。

每次不可能把所有的点都移动，那怎么办？

## 那就移动坐标系啊！

\_如果脑子想不出来，那就用脚指头想一想。——sSay\_

第一种操作直接统计到系上。

第二种操作和第三种操作考虑把坐标系翻转，

翻转后把第一种操作的统计反着统计

(因为正数加等于负数减)

然后就没了。O(n)算法还是比较快的

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int Maxn = 501010;

typedef long long ll;

char ch[Maxn];
int n, m, flag1, flag2;
ll x[Maxn], y[Maxn], a[Maxn], b[Maxn];

int Get(int p) {return (p ? -1 : 1);}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) cin >> x[i] >> y[i];
    for(int i = 1; i <= m; ++i) {
        cin >> ch[i];
        if(ch[i] == 'm') cin >> a[i] >> b[i];    
    }
    ll deltax = 0, deltay = 0;
    for(int i = m; i >= 1; --i) {
        if(ch[i] == 'x') flag1 ^= 1;
        else if(ch[i] == 'y') flag2 ^= 1;
        else {
            deltax += Get(flag1) * a[i];
            deltay += Get(flag2) * b[i];
        }
    }
    for(int i = 1; i <= n; ++i) {
        cout << Get(flag1) * (deltax + x[i]) << ' ' << Get(flag2) * (deltay + y[i]) << endl;
    }
    return 0;
}
```

---

## 作者：1沃尔克 (赞：9)

起始位置确定，简单的三种操作，十分简单的模拟。

但每次都移动所有的军队，O（nm），一看数据范围，T飞啦。

我们考虑简化操作(这么简单的操作不是白给的）。我们通过观察发现，只有m操作为加减，x,y为取相反数。那么就可以将末位置分为两部分，原始坐标（只是正负变化）和坐标变化量，o（m）就可以求出最终的原始坐标正负sx，sy，以及坐标变量xx，yy。
答案为（原始横坐标*sx+xx，原始纵坐标*sy+yy）。

code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
struct ll
{
	long long x,y;
}lc[500005];
char c[500005];
long long a[500005],b[500005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&lc[i].x,&lc[i].y);
	for(int i=1;i<=m;i++)
	{
		cin>>c[i];
		if(c[i]=='m') 
		scanf("%lld%lld",&a[i],&b[i]);
	}
	long long xx=0,sx=1,yy=0,sy=1;
	for(int i=m;i>=1;i--)
	{
		if(c[i]=='y')
		{
			sy=-sy;yy=-yy;
		}
		if(c[i]=='m')
		{
			xx+=a[i];yy+=b[i];
		}
		if(c[i]=='x')
		{
			sx=-sx;xx=-xx;
		}
	}
	for(int i=1;i<=n;i++)
		printf("%lld %lld\n",lc[i].x*sx+xx,lc[i].y*sy+yy);
	return 0;
}
```

致谢

---

## 作者：wanglichao1121 (赞：8)

朴素模拟O(nm)应该不用解释，我十分好心地留了几分。

正解：矩阵乘法！具体解释：http://baike.baidu.com/view/2455255.htm?fr=aladdin

读了上面的东西，应该知道了矩阵乘法有个重要性质：满足结合律。

而且经过一番凑数，能得到三个等式（见http://www.matrix67.com/blog/archives/276

贴标程：）

如果从前往后把操作所对应的3\*3矩阵相乘，

再把结果每次乘上(xi,yi,1)（存作d[1,1],d[2,1],d[3,1]，别反了），

在每次计算时算最后两个（结合律，一样一样滴），

那么就会发现，结果就是第i个点经过从尾到头的移动后的结果。

时间复杂度O(n+m)，秒过！

参考：http://www.matrix67.com/blog/archives/276

贴标程：

```cpp
type jz=array[1..3,1..3]of longint;
     zb=array[1..3,1..1]of longint;
var n,m,i,s,p,q:longint;ch:char;a,b,c:jz;d:zb;
    x,y:array[1..500000]of longint;
procedure cf;            //3*3矩阵a乘上3*3矩阵b，得到3*3矩阵c
var i,j,k:longint;
begin
  for i:=1 to 3 do
  for j:=1 to 3 do
  begin
  s:=0;
  for k:=1 to 3 do s:=s+a[i,k]*b[k,j];
  c[i,j]:=s;
  end;
end;
procedure cff;           //3*3矩阵a乘上 3*1矩阵d，得到3*1矩阵c
var i,j,k:longint;
begin
  for i:=1 to 3 do
  for j:=1 to 1 do
  begin
  s:=0;
  for k:=1 to 3 do
  s:=s+a[i,k]*d[k,j];
  c[i,j]:=s;
  end;
end;
begin
  assign(input,'army.in');reset(input);
  assign(output,'army.out');rewrite(output);
  readln(n,m);
  for i:=1 to n do
  readln(x[i],y[i]);
  read(ch);
  case ch of
```
'm':
```cpp
  begin
  readln(p,q);
  a[1,1]:=1;a[1,2]:=0;a[1,3]:=p;
  a[1,2]:=0;a[2,2]:=1;a[2,3]:=q;
  a[3,1]:=0;a[3,2]:=0;a[3,3]:=1;
  end;
```
'y':
```cpp
  begin
  readln;
  a[1,1]:=1;a[1,2]:=0;a[1,3]:=0;
  a[2,1]:=0;a[2,2]:=-1;a[2,3]:=0;
  a[3,1]:=0;a[3,2]:=0;a[3,3]:=1;
  end;
```
'x':
```cpp
  begin
  readln;
  a[1,1]:=-1;a[1,2]:=0;a[1,3]:=0;
  a[2,1]:=0;a[2,2]:=1;a[2,3]:=0;
  a[3,1]:=0;a[3,2]:=0;a[3,3]:=1;
  end;
  end;
  for i:=2 to m do
  begin
  read(ch);
  case ch of
```
'm':
```cpp
  begin
  readln(p,q);
  b[1,1]:=1;b[1,2]:=0;b[1,3]:=p;
  b[1,2]:=0;b[2,2]:=1;b[2,3]:=q;
  b[3,1]:=0;b[3,2]:=0;b[3,3]:=1;
  end;
```
'y':
```cpp
  begin
  readln;
  b[1,1]:=1;b[1,2]:=0;b[1,3]:=0;
  b[2,1]:=0;b[2,2]:=-1;b[2,3]:=0;
  b[3,1]:=0;b[3,2]:=0;b[3,3]:=1;
  end;
```
'x':
```cpp
  begin
  readln;
  b[1,1]:=-1;b[1,2]:=0;b[1,3]:=0;
  b[2,1]:=0;b[2,2]:=1;b[2,3]:=0;
  b[3,1]:=0;b[3,2]:=0;b[3,3]:=1;
  end;
  end;
  cf;
  a:=c;
  end;                          //先把所有矩阵按序乘上
  for i:=1 to n do                 //再一个点一个点处理位置
  begin
  d[1,1]:=x[i];d[2,1]:=y[i];d[3,1]:=1;
  cff;
  writeln(c[1,1],' ',c[2,1]);
  end;
  close(input);close(output);
end.

```

---

## 作者：辰星凌 (赞：6)

# **【题解】L 国的战斗续之多路出击 [P2129]**


**传送门：** [$L$ 国的战斗续之多路出击 $[P2129]$](https://www.luogu.org/problem/P2129)

-------

## **【分析】**

大佬们都写的是**矩阵乘法**或者**模拟**，向我这种不会矩阵和膜您的蒟蒻就只能写线段树了 $\text{QAQ}$ （好像是第一个用这种奇葩方法的？）。

区间加，区间乘的模板，但因为是单调查询，而且没有取模这种鬼畜操作，比[【模板】线段树 $2$](https://www.luogu.org/problem/P3373) 和 [维护序列](https://www.luogu.org/problem/P2023) 要简单得多。

维护一个乘法标记 $mul$ 和加法标记 $add$，区间加时就直接更新 $add$，区间乘 $v$ 就先让 $mul$ 和 $add$ 都乘以 $v$ 。

下传标记时先传 $mul$ 再传 $add$

其他的就直接照着题目模拟就可以了。

**坑点：$m$ 个指令要倒着处理。**

## **【Code】**

```cpp
#include<cstdio>
#define Re register int
#define pl (p<<1)//左儿子
#define pr (p<<1|1)//右儿子
#define mid (L+R>>1)
#define pa tr[p].add//加法标记
#define pm tr[p].mul//乘法标记
const int N=5e5+5;
int n,x,y,T,a[N],b[N];
inline void in(Re &x){
    Re f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
struct Segment_Tree{
    struct QAQ{int l,r,ans,add,mul;}tr[N<<2];
    inline void updata_add(Re p,Re v){
        if(tr[p].l==tr[p].r)tr[p].ans+=v;//只需要更新叶子节点
        pa+=v;//但标记必须下传
    }
    inline void updata_mul(Re p,Re v){
        if(tr[p].l==tr[p].r)tr[p].ans*=v;//同上
        pm*=v,pa*=v;
    }
    inline void pushdown(Re p){//先下传乘法标记，再下传加法标记
        if(pm!=1)updata_mul(pl,pm),updata_mul(pr,pm),pm=1;//这里乘法标记也要初始化为1
        if(pa)updata_add(pl,pa),updata_add(pr,pa),pa=0;
    }
    inline void build(Re p,Re L,Re R){//初始化建树
        tr[p].l=L,tr[p].r=R,pm=1;//乘标记要初始化为1
        if(L==R){tr[p].ans=a[L];return;}
        build(pl,L,mid),build(pr,mid+1,R);
    }
    inline void change_add(Re p,Re l,Re r,Re v){//区间加
        Re L=tr[p].l,R=tr[p].r;
        if(l<=L&&R<=r){updata_add(p,v);return;}
        pushdown(p);
        if(l<=mid)change_add(pl,l,r,v);
        if(r>mid)change_add(pr,l,r,v);
    }
    inline void change_mul(Re p,Re l,Re r,Re v){//区间乘
        Re L=tr[p].l,R=tr[p].r;
        if(l<=L&&R<=r){updata_mul(p,v);return;}
        pushdown(p);
        if(l<=mid)change_mul(pl,l,r,v);
        if(r>mid)change_mul(pr,l,r,v);
    }
    inline int ask(Re p,Re w){//单点查询
        Re L=tr[p].l,R=tr[p].r;
        if(L==R)return tr[p].ans;
        pushdown(p);
        if(w<=mid)return ask(pl,w);
        else return ask(pr,w);
    }
}T1,T2;//T1:x坐标。T2:y坐标。
inline void sakura(Re T){
	Re x,y;char op;
	if(!T)return;
	scanf(" %c",&op);
    if(op=='m')in(x),in(y);
    sakura(T-1);
    if(op=='x')T1.change_mul(1,1,n,-1);//(x,y) -> (-x,y)
    else if(op=='y')T2.change_mul(1,1,n,-1);//(x,y) ->(x,-y)
    else T1.change_add(1,1,n,x),T2.change_add(1,1,n,y);//(x,y) -> (x+p,y+q)
}
int main(){
    // freopen("123.txt","r",stdin);
    in(n),in(T);
    for(Re i=1;i<=n;++i)in(a[i]),in(b[i]);
    T1.build(1,1,n);//第一棵树
	for(Re i=1;i<=n;++i)a[i]=b[i];
	T2.build(1,1,n);//第二课树
    sakura(T);
    for(Re i=1;i<=n;++i)printf("%d %d\n",T1.ask(1,i),T2.ask(1,i));
}
```


---

## 作者：JustinRochester (赞：3)

想不通这题的矩阵拿来干什么......

完全没有意义

---

**【分析】**
--

已知 $n$ 个点， $m$ 个操作，操作包括所有点移动、沿 $x$ 轴翻转、沿 $y$ 轴翻转

首先，我们维护一个 $x$、$y$ 表示所有点是否关于 $y$ 轴、$x$ 轴翻转奇数次，是的话为 $-1$ 否则为 $1$

为什么是奇数次？因为翻转偶数次相当于没翻转

同样的，我们再维护一个 $dx$、$dy$ 表示所有点最终的移动

那么，这里有一个细节：

假设原本存在一个点 $(x,y)$ ，先移动变成了 $(x+p,y+q)$

接下来假设沿 $y$ 轴翻转，则变成 $(-x-p,y+q)$

本来，我们翻转 $y$ 轴的就是只要 $x$ 变为 $-x$ ，那现在就需要多加一步 $dx=-dx$

关于 $x$ 轴翻转的也是一样的

其他什么从栈里面取出来的就直接看本蒟蒻的代码吧

---

**【代码】**
--

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
typedef long long int ll;
typedef unsigned long long int ull;
const int MAXN=500010;
typedef ll ar[MAXN];
inline ll read(){
	register ll ans=0;register char c=getchar();register bool neg=0;
	while((c<'0')|(c>'9')) neg^=!(c^'-') ,c=getchar();
	while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return neg?-ans:ans;
}
int N,M;
ll x=1,y=1,dx=0,dy=0;
ar X,Y,O,Ox,Oy;
void pre(){
	N=read(); M=read();
	f(i,1,N) X[i]=read(),Y[i]=read();
	f(i,1,M){
		char c=getchar();
		while(c!='x'&&c!='y'&&c!='m') c=getchar();
		if(c=='m') O[i]=1,Ox[i]=read(),Oy[i]=read();
		else O[i]=(c=='x')?2:3;
	}
}
void work(){
	g(i,M,1){
		if(O[i]==1) dx+=Ox[i],dy+=Oy[i];
		else if(O[i]==2) dx=-dx,x=-x;
		else if(O[i]==3) dy=-dy,y=-y;
	}
}
int main(){
	pre();
	work();
	f(i,1,N) printf("%lld %lld\n",X[i]*x+dx,Y[i]*y+dy);
	return 0;
}
```

---

## 作者：Sym_Je (赞：3)

             P2129 L国的战斗续之多路出击  
          
  [2129](https://www.luogu.org/problemnew/show/P2129)   
  
  首先我们常规打一个暴力，暴力修改。。。   
  $O(n * m)$  
  
  还骗了90分~
  
  ```cpp

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int maxn=500001;

int n,m;

struct node
{
	int x,y;
}t[maxn];

struct node2
{
	char op[3];int x,y;
}tt[maxn];

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d",&t[i].x,&t[i].y);
	}	
	for(int i=1;i<=m;++i)
	{
		scanf("%s %d %d",tt[i].op,&tt[i].x,&tt[i].y);
	}
	while(m)
	{
		if(tt[m].op[0]=='x')
		{
			for(int i=1;i<=n;++i)
			{
				t[i].x=-1*t[i].x;
			}
			//cout<<"233";
		}	
		else if(tt[m].op[0]=='y')
		{
			for(int i=1;i<=n;++i)
			{
				t[i].y=-1*t[i].y;
			}
		}
		else
		{
			int xx,yy;
			
			xx=tt[m].x;
			yy=tt[m].y;
			for(int i=1;i<=n;++i)
			{
				t[i].x+=xx;
				t[i].y+=yy;
			}
		}
		m--;
	}
	for(int i=1;i<=n;++i)
	{
		printf("%d %d\n",t[i].x,t[i].y);
	}
	return 0;
}

```   
然后我们考虑如何去搞正解
   首先我们肯定要把一个改成$log$级别的，我们有看到了这些全是相加没有相乘，这我们想到常见的普通的矩阵乘法，我们就预处理出来，然后一个个乘就ok咯。   
 *     
 x y 1---> -x y 1   
   
  -1 0 0  
  0 1 0  
  0 0 1  
  
*   x y 1 ---> x -y 1   
1 0 0   
0 -1 0  
0 0 1   

* x y 1 ---> x+p x+q 1    
1 0 0   
0 1 0     
p q 1   


```cpp
#include<iostream>
#include<cstring>
#include<alagorithm>
#include<cstdio>

using namespace std;

const int maxn=500001;

int n,m;

struct node3
{
	int x,y;
	
}t[maxn];

struct node2
{
	int x,y;char op[3];
}tt[maxn];

struct node
{
	int a[5][5];
	node(){memset(a,0,sizeof(a));}
}a,b,c,d,e;

node operator * (const node &a,const node &b)
{
	node c;
	for(int i=1;i<=3;++i)
	{
		for(int j=1;j<=3;++j)
		{
			for(int k=1;k<=3;++k)
			{
				c.a[i][k]+=a.a[i][j]*b.a[j][k];
			}
		}
	}
	return c;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d %d",&t[i].x,&t[i].y);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%s %d %d",tt[i].op,&tt[i].x,&tt[i].y);
	}
	for(int i=1;i<=3;++i)
	{
		a.a[i][i]=1;
		b.a[i][i]=1;
		c.a[i][i]=1;
		d.a[i][i]=1;
	}
	a.a[1][1]=-1;
	b.a[2][2]=-1;
	for(int i=m;i;i--)
	{
		if(tt[i].op[0]=='x')
		{
			c=c*a;
		}
		else if(tt[i].op[0]=='y')
		{
			c=c*b;
		}
		else
		{
			int x,y;
			x=tt[i].x;
			y=tt[i].y;
			d.a[3][1]=x;
			d.a[3][2]=y;
			c=c*d;
		}
	}
	for(int i=1;i<=n;++i)
	{
		e.a[1][1]=t[i].x;
		e.a[1][2]=t[i].y;
		e.a[1][3]=1;
		e=e*c;
		cout<<e.a[1][1]<<" "<<e.a[1][2]<<endl;
	}
	return 0;
}
```

---

## 作者：香风智乃 (赞：3)

https://www.luogu.org/problemnew/show/P2129

C++版的**矩阵乘法**（楼上dalao写的是P）

根据题意先将所有操作先相乘（注意是倒着，题目说是逆序处理）得出一个最终转换矩阵，再将每个点与这个矩阵相乘就可以得出答案了。

如果不理解可以看看楼上dalao的题解，本蒟蒻只是补个C++版的qwq

复杂度$O(n+m)$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
using namespace std;

inline int Int()
{
	char c=getchar(); int x=0,f=1;
	while(!isdigit(c)) f= !f||c=='-' ? 0:1,c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f ? x:-x;
}
int wt[50];
inline void out(int x)
{
	if(!x){putchar(48); return ;}
	if(x<0) putchar('-'),x=-x;
	int l=0;
	while(x) wt[++l]=x%10,x/=10;
	while(l) putchar(wt[l--]+48);
}

struct matrix{
	int a[4][4],l,r;
	matrix(){memset(a,0,sizeof(a));}
	matrix operator * (matrix &tmp){//r==tmp.l时的矩阵乘法
		matrix c; c.l=l; c.r=tmp.r;
		for(int i=1;i<=c.l;++i)
			for(int j=1;j<=c.r;++j)
				for(int k=1;k<=r;++k)
					c.a[i][j]+=a[i][k]*tmp.a[k][j];
		return c;
	}
}x,y,p,b[500002],mul;
struct data{
	char opt; int q1,q2;
}d[500002];
int n,m;

int main()
{
	x.l=x.r=3; x.a[1][1]=-1; x.a[2][2]=x.a[3][3]=1;
	y.l=y.r=3; y.a[2][2]=-1; y.a[1][1]=y.a[3][3]=1;
	p.l=p.r=3; p.a[1][1]=p.a[2][2]=p.a[3][3]=1;
    //3种操作先预处理矩阵
	mul.l=mul.r=3; mul.a[1][1]=mul.a[2][2]=mul.a[3][3]=1; //最终和点相乘的矩阵
	int q1,q2;
	n=Int(); m=Int();
	for(int i=1;i<=n;++i)
	{
		q1=Int(); q2=Int();
		b[i].l=1; b[i].r=3;
		b[i].a[1][1]=q1;
		b[i].a[1][2]=q2;
		b[i].a[1][3]=1; //把每个点处理成1*3的矩阵
	}
	for(int i=1;i<=m;++i)
	{
		//d[i].opt=getchar();// scanf("%c",&d[i].opt); 不知道为啥用这两种读入都不正常qwq
		cin>>d[i].opt;
		if(d[i].opt=='m') d[i].q1=Int(),d[i].q2=Int();
	}
	for(int i=m;i>=1;--i) //逆序处理操作
	{
		if(d[i].opt=='x') mul=mul*x;
		else if(d[i].opt=='y') mul=mul*y;
		else{
			p.a[3][1]=d[i].q1; p.a[3][2]=d[i].q2;
			mul=mul*p;
		}
	}
	for(int i=1;i<=n;++i)
	{
		b[i]=b[i]*mul; //直接相乘后得出答案
		out(b[i].a[1][1]),putchar(' ');
		out(b[i].a[1][2]),putchar('\n');
	}
	return 0;
}
```

---

## 作者：Yang123 (赞：2)

當我看到了“矩陣”這個標簽……内心仿佛就激動了起來！

~~（然而懶得寫矩陣，用了數學……）~~


先亮AC碼   ___[複雜度O(n+m)?]___


------------

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n,m; 
int x=1,y=1,addx=0,addy=0;
int a[500000][2];
char ne;
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;++i) scanf("%d%d",&a[i][0],&a[i][1]);
	for (int i=0;i<m;++i)
	{
		cin>>ne;
		if (ne=='x') x=-x;
		if (ne=='y') y=-y;
		if (ne=='m') 
		{
			int j,k;
			scanf("%d%d",&j,&k);
			addx+=x*j;
			addy+=y*k;
		}
	}
	for (int i=0;i<n;++i)
	printf("%d %d\n",a[i][0]*x+addx,a[i][1]*y+addy);
}
```

首先
------------

按照矩陣的分析既是[x,y,addxy(就是1)]

C為x則x取反，為y則y取反，為m則對應位加數
~~（厚顔無恥的重複了一遍題意）~~

如果試圖用統計的話，下場只能是“聽取蛙聲一片”~

# 由於x,y的反轉，加一個數實際上是減去一個數

這樣想明白后，題目也就變得清晰了


------------


THEN
------------
我們大膽的抛棄矩陣，只剩下讀入所需矩陣，

x，y記錄反轉，addx，addy記錄加數

初始的x，y設爲1表示未反轉(-1為反)，add當然為0

學過數學的都知道x+a=(x+a)//-x+a=-(x-a)

#### 此時，我們發現，括號内部分x係數是1,a的係數看x是否反，最後整體的正反由最外層符號決定。
#### 所以每遇到x,y就可將其反轉，moveX、moveY在加到addx、addy前用此時x，y的值乘上就可以變成實際位移了

（簡單來説就是提x的係數，“負負得正，負正得負，正正……”，然後算出實際移動）

### 你這是順序處理，那棧的堆叠怎麽辦？

若嘗試模擬這個推論，得出結果和正確出棧順序模擬結果是一致的。。。~~（原理自行悟道）~~


END
------------
代碼寫的很粗糙，也很接地氣[good]

~~不開longlong可以不用見祖宗~~

望收錄！！！！

---

## 作者：Kisaragi_77 (赞：2)

## 标记化思想 + 模拟

这题的操作让我这种蒟蒻想起了线段树2那道极其鬼畜的题。。。

好在这题没有区间操作

那么我们完全可以使用懒标记的思想

维护四个值

$Add_x,Add_y,Mul_x,Mul_y$

**ps:这种做法在线也可做**



首先我们钦定 **乘法的优先级高于加法**

即 乘法操作会影响加法，加法操作影响不到乘法

下传时先处理乘法，再处理加法

然后这题就没了

**具体说来**

当读到x操作时

$Mul_x * (-1) \quad Add_x *(-1)$

y操作同理

对于m操作

直接修改$Add_x\quad Add_y$  的值即可

答案直接考虑标记对当前值的影响，**先乘后加**

```cpp
#include<cstdio>
inline int read(){
    int x;scanf("%d",&x);return x;
}
const int N =6e5;
struct node{
    char op;
    int x,y;
}s[N];
int x[N],y[N];
int main(){
    int n =read(),m =read(),add_x =0,add_y =0,mul_x =1,mul_y =1;
    for(int i=1;i<=n;++i)   x[i] =read(),y[i] =read();
    for(int i=1;i<=m;++i){
        char op[4]; scanf("%s",op);
        if(op[0]=='m')  s[i].x =read(),s[i].y =read();
        else s[i].op =op[0];
    }
    for(int i=m;i>=1;--i){
        if(s[i].op=='x')  add_x *=-1,mul_x *=-1;
        else if(s[i].op=='y') add_y *=-1,mul_y *=-1;
        else add_x +=s[i].x,add_y +=s[i].y;
    }
    for(int i=1;i<=n;++i)   
        printf("%d %d\n",x[i]*mul_x+add_x,y[i]*mul_y+add_y);
}
```





---

## 作者：Prean (赞：1)

恕我直言，这是我见过最水的一道蓝题。

# 题目大意

平面上的n个点，一共m次操作，要么每次将每个点的y轴变负，要么每次将每个点的x轴变负，要么每次将每个点的x轴加上一个数，y轴加上一个数，最后求每个点的坐标。

首先可以肯定的是，暴力的O(nm)会TLE。

然后再看看题，每次操作都是对全部的点进行操作。

所以我们加设两个变量，$ a $表示$ x $轴是否翻转，$ b $表示$ y $轴是否翻转，然后就是m操作了。

对于m操作，我们可以再加设两个变量$ sx $和$ sy $，分别表示x轴上加了多少，y轴上加了多少。

至于操作是栈，弄个递归就好。

贴代码：
```cpp
#include<cstdio>
#include<iostream>
typedef long long ll;
ll n,m,a=1,b=1,sx,sy,x[500005],y[500005];
inline void DFS(int k)
{
	if(!k)return;ll x,y;char f;std::cin>>f;
	if(f=='m')scanf("%lld%lld",&x,&y);DFS(k-1);
	if(f=='x')a=-a;else if(f=='y')b=-b;else sx+=a*x,sy+=b*y;
}
main()
{
	int i;scanf("%lld%lld",&n,&m);
	for(i=1;i<=n;++i)scanf("%lld%lld",&x[i],&y[i]);DFS(m);
	for(i=1;i<=n;++i)
	printf("%lld %lld\n",a*(x[i]+sx),b*(y[i]+sy));
}
```


---

## 作者：木木！ (赞：0)

提供一个不需要将操作反转的解法qwq。

可以观察到，有许多操作是可以合并的，也就是说，可以使用`lazy algorithm`的思想，将一些操作合并。

如果两个`m`操作相邻的话，显然可以将`p`和`q`分别相加，`x`操作相邻可以抵消，`y`操作相邻也可以抵消。但是`x`和`y`操作对`m`操作的影响未知。

先假设我们已经将最后`k`个操作整理成一个`m`操作、一个或零个`x`操作和一个或零个`y`操作依次进行的形式。考虑前一个操作（因为读入顺序是从最后一个操作开始往前读），如果前一个是`m`的话，可以直接合并；如果是`x`，则将`m`操作的相应幅度取为相反数，然后和x操作合并；`y`操作类似。

时间复杂度$\Theta(m+n)$，如果先读入操作再读入坐标的话，空间复杂度能达到$\Theta(1)$（逃），代码也很短很好写。

附AC代码：

```cpp
#include <cstdio>
using namespace std;

#define int long long

int mvmx;
int mvmy;
int timx = 1;
int timy = 1;

int xi[500005];
int yi[500005];

signed main()
{
	int n,m;
	scanf("%lld%lld",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		scanf("%lld%lld",xi+i,yi+i);
	}
	for(int i=1; i<=m; ++i)
	{
		char cmd;
		scanf("\n\r%c",&cmd);
		if(cmd == 'm')
		{
			int p,q;
			scanf("%lld%lld",&p,&q);
			mvmx += p;
			mvmy += q;
		}
		else if(cmd == 'x')
		{
			mvmx = -mvmx;
			timx = -timx;
		}
		else
		{
			mvmy = -mvmy;
			timy = -timy;
		}
	}

	for(int i=1; i<=n; ++i)
	{
		printf("%lld %lld\n",(xi[i]+mvmx)*timx,(yi[i]+mvmy)*timy);
	}
}
```

---


# 【模板】矩阵快速幂

## 题目背景

一个 $m \times n$ 的**矩阵**是一个由 $m$ 行 $n$ 列元素排列成的矩形阵列。即形如

$$ A = \begin{bmatrix} a_{1 1} & a_{1 2} & \cdots & a_{1 n} \\ a_{2 1} & a_{2 2} & \cdots & a_{2 n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m 1} & a_{m 2} & \cdots & a_{m n} \end{bmatrix} \text{.} $$

本题中认为矩阵中的元素 $a_{i j}$ 是整数。

两个大小分别为 $m \times n$ 和 $n \times p$ 的矩阵 $A, B$ **相乘**的结果为一个大小为 $m \times p$ 的矩阵。将结果矩阵记作 $C$，则

$$ c_{i j} = \sum_{k = 1}^{n} a_{i k} b_{k j} \text{,\qquad($1 \le i \le m$, $1 \le j \le p$).} $$

而如果 $A$ 的列数与 $B$ 的行数不相等，则无法进行乘法。

可以验证，矩阵乘法满足结合律，即 $(A B) C = A (B C)$。

一个大小为 $n \times n$ 的矩阵 $A$ 可以与自身进行乘法，得到的仍是大小为 $n \times n$ 的矩阵，记作 $A^2 = A \times A$。进一步地，还可以递归地定义任意高次方 $A^k = A \times A^{k - 1}$，或称 $A^k = \underbrace{A \times A \times \cdots \times A}_{k \text{ 次}}$。

特殊地，定义 $A^0$ 为单位矩阵 $I = \begin{bmatrix} 1 & 0 & \cdots & 0 \\ 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \end{bmatrix}$。

## 题目描述

给定 $n\times n$ 的矩阵 $A$，求 $A^k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 100$，$0 \le k \le 10^{12}$，$|A_{i,j}| \le 1000$。

## 样例 #1

### 输入

```
2 1
1 1
1 1```

### 输出

```
1 1
1 1```

## 样例 #2

### 输入

```
3 5
1 2 3
4 5 6
7 8 9```

### 输出

```
121824 149688 177552
275886 338985 402084
429948 528282 626616```

# 题解

## 作者：子谦。 (赞：474)


$update:2019-9-2$

非常抱歉图炸了，现在应该修复了，管理员给个通过吧（我也不知道为啥图莫名其妙挂了，难道我把图片挂在博客园上不天天访问就会失活？）

$update:2019-2-23$

忽然意识到没有说单位矩阵这个重要的东西，尴尬，现在补上了

-----

嗯，这玩意看着很难对吧，昨天我还是这样想的。。直到今天看到了[**斐波那契公约数**](https://www.luogu.org/problemnew/show/P1306)这道题

这道题一看我这种辣鸡就不会做啊，然后rqy告诉我这是傻逼题啊，我忽然就想起了以前听说过的矩阵乘。。然后懒惰的DDOSvoid大佬告诉我要做这道题，得先做[**斐波那契数列**](https://www.luogu.org/problemnew/show/P1962),要做斐波那契数列，得先做[**矩阵加速**](https://www.luogu.org/problemnew/show/P1939),要做矩阵加速，得先做[**矩阵快速幂**](https://www.luogu.org/problemnew/show/P1939)。。于是，一个上午就这么过去了

----------------

(想看代码直接翻到最下面，本文主要为入门讲解)

回归正题

# 定义

什么是矩阵运算呢？

在理解这个问题前，我们先要知道什么是矩阵

百度百科给的定义如下

> 矩阵是一个按照长方阵列排列的复数或实数集合 

复数实数什么的我们先不管，总之，矩阵就是一堆数，按照矩形排列形成的集合

那么，我们所需要记录的也就是它的长、宽以及矩阵中存储的元素

特殊的，长宽相等的矩阵我们定义它为方阵

当两个矩阵的长宽相等时，我们认为这两个矩阵为同型矩形

# 基本运算

矩阵的运算我们可以类比实数的运算来理解

在实数运算中，一般由进行运算的实数和运算符组成，运算符决定了运算类型

那么同样的，矩阵运算也是如此

## 加法运算

首先，我们来看加法运算

两个矩阵进行**一般的**加法运算的前提是两个矩阵为**同型矩阵**

我们只需要将对应位置的元素相加即可，如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/hioa90k3.png)

在矩阵的加法运算中，满足交换律和结合律，也就是

### $A+B=B+A$

### $(A+B)+C=A+(B+C)$

也许有人想问了，如果我想让两个非同型矩形进行相加可不可以实现呢？

答案是可以的，这种运算是被支持的，我们称这种运算为直和

但由于这种运算使用较少，且与本文关系不大，我们在此不多做解释，感兴趣的朋友可以阅览下面的链接，相信它会给你一个满意的答复

[矩阵加法](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95/12641418?fr=aladdin)

## 减法运算

在实数运算中，减法为加法的逆运算，同样的，在矩阵运算中也是如此，如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/b2rkuxwg.png)

## 数乘

在实数运算中我们并没有数乘这种运算（毕竟本身就是数，直接叫乘法了）

所以在数乘运算中，我们类比向量来进行理解

在数乘向量运算中，只需要将向量中的每个元素乘上那个数就可以了

数乘矩阵也是如此，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/39krazdf.png)

数乘矩阵运算中，满足如下运算律

$(\lambda\mu)A=\lambda(\mu A)$

$(\lambda+\mu)A=\lambda A+\mu A$

$\lambda(A+B)=\lambda A+\lambda B$

## 矩阵乘法（矩阵乘矩阵）

在向量乘向量的运算中，是将每个元素与它对应的元素相乘，求所有乘积之和

那么矩阵乘矩阵是不是就是两个同型矩阵的对应元素相乘呢？

~~**图样图森破**~~

两个矩阵相乘的前提是前一个矩阵的列数等于后一个矩阵的行数

举个栗子，$A$为$n*k$矩阵，$B$为$k*m$矩阵，$C$为$m*n$矩阵，那么$A$可以与$B$相乘，$B$可以与$C$相乘，$C$可以与$A$相乘，其他均不成立

我们知道了什么情况下两个矩阵可以相乘，那么他们怎么相乘呢？不讲每个对应位置相乘还能怎么乘呢？

设$A$为$n*k$矩阵，$B$为$k*m$矩阵,那么它们的乘积$C$则为一个$n*m$矩阵

### $C_{i,j}=\sum_{r=1}^kA_{i,r}*B_{r,j}$

是不是不太好理解，没关系看看图就知道了

![](https://cdn.luogu.com.cn/upload/image_hosting/9zfncisd.png)

在矩阵乘法中满足以下运算律： 

### $(AB)C=a(BC)$

### $(A+B)C=AC+BC$

### $C(A+B)=CA+CB$

在普通的乘法中，一个数乘1还是等于它本身，在矩阵乘法中也有这么一个“1”，它就是单位矩阵

不同于普通乘法中的单位1，对于不同矩阵他们的单位矩阵大小是不同的

对于$n*m$的矩阵，它的单位矩阵大小为$m*m$，对于$m*n$的矩阵，它的单位矩阵大小为$n*n$

也就是说单位矩阵都是正方形的，这是因为只有正方形的矩阵能保证结果和前一个矩阵形状相同

单位矩阵的元素非0即1，从左上角到右下角的对角线上元素皆为1，其他皆为0

-------------

了解了这么多，我们开始看题，矩阵快速幂，由于矩阵乘法满足结合律，所以我们只需要把它按照一般的快速幂打，再重载一下运算符就可以了，好了我们直接放代码

```c++
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
#define gc() getchar()
#define maxn 105
#define mo 1000000007
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}
int n;

struct ahaha{
	ll a[maxn][maxn];     //一定要用long long存矩阵，否则在过程中会爆掉
	ahaha(){
		memset(a,0,sizeof a);
	}
	inline void build(){     //建造单位矩阵
		for(int i=1;i<=n;++i)a[i][i]=1;
	}
}a;
ahaha operator *(const ahaha &x,const ahaha &y){     //重载运算符
	ahaha z;
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j)
				z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j]%mo)%mo;
	return z;
}

ll k;
inline void init(){
	n=read();k=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			a.a[i][j]=read();
}

int main(){
	init();
	ahaha ans;ans.build();
	do{     //递推快速幂，与普通的递推快速幂无异，但*不能缩写为*=
		if(k&1)ans=ans*a;
		a=a*a;k>>=1;
	}while(k);
	for(int i=1;i<=n;putchar('\n'),++i)
		for(int j=1;j<=n;++j)
			printf("%d ",ans.a[i][j]);
	return 0;
}
```
最后打一下广告  [**我的博客**](http://www.cnblogs.com/hanruyun/)

## 感谢您的阅览

---

## 作者：yangrunze (赞：162)

**矩阵快速幂**这个东西嘛，其实很简单！

一句话:

## 矩阵快速幂=矩阵乘法+快速幂

所以，这篇题解就要从这两个东西说起：

### 1. 矩阵乘法

首先，不懂矩阵乘法的[戳这里](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029?fr=aladdin)（如果你已经懂了，可以跳过）

还是一脸懵？？？我再来说一遍：

![](https://cdn.luogu.com.cn/upload/image_hosting/ri3zpl8c.png)

这回大家应该都懂了吧（如果图画的不好或者你还是没懂，请原谅）

那知道了怎么乘，到底怎么代码实现呢？？？

其实很简单：用**模拟**就可以啦！

大家先自己思考一下（一定要自己思考），思考完了再来看代码吧

5

------------
4

------------
3

------------
2

------------
1

------------
相信大家代码都思考好了吧！接下来咱们来放一下代码：

```cpp
	//本例中计算矩阵A×矩阵B，存到矩阵C里
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){  //找到c[i][j]，开始算
			for(int k=1;k<=n;k++){
				c[i][j]+=a[i][k]*b[k][j];//矩阵乘法的定义
			}
		}
	}	
```
相信大家都已经get到矩阵乘法的原理和代码实现了吧！

顺便再提一句：**主对角线（即左上-右下对角线）全是1，其它地方全是0**的矩阵是**单位矩阵**也就是说单位矩阵长这样：
|  |  |  |  |
| -----------: | -----------: | -----------: | -----------: |
|  |1  |  0|  0|
|  | 0 | 1 | 0 |
|  | 0 | 0 | 1 |


它就像数的乘法里1乘几就得几一样，**它乘上哪个矩阵，就是哪个矩阵**，为什么？自己乘一下看看就知道啦~

### 2.快速幂

首先，不会快速幂的[看过来](https://www.luogu.com.cn/problem/P1226)
（如果你AC了这道题或已学过相关内容，请跳过）

咱先想想这个问题：如果RMB是这样编排的：1元，2元，4元，8元......也就是面值都是**2的几次方**，那如果带齐“一套钱”，买几块的都能凑起来，不用找零了！为什么呢？？？

$$1=1$$
$$2=2$$
$$3=1+2$$
$$4=4$$
$$5=1+4$$
$$6=2+4$$
$$7=1+2+4$$
$$......$$

真的哎！那为什么这么神奇呢？别急，既然是2的几次方，那咱要不....把每个数转化成**二进制**试试？？
$$1=1$$
$$2=10$$
$$3=11$$
$$4=100$$
$$5=101$$
$$6=110$$
$$7=111$$
$$......$$

发现了吗？如果选了这个数，那对应的一位必然是1！好理解！**二进制的第几位，表示的就是二的几次方**嘛！而这些要么选（1），要么不选（0），必然有一种状态满足你！

我们的快速幂也是这个原理：对于任意一个数，都可以拆成$2^k$的数构成的和，所以求$a^b$，我们就可以把它拆成某几个$a^{2^k}$的积！

for example:

$$3^{11}=3^{8+2+1}=3^8\times3^2\times3^1$$

然后呢，把$a$每次都平方，$a$第一次平方之后会变成$a^2$，再平方就是$a^4$，......就可以快速访问每个$a^{2^k}$的状态了

处理的时候呢，把指数 $b$转化成二进制（就是除以2，膜2，再除以2，再膜2...），如果这一位是1，那就把当前的$a$乘到答案里去！

```cpp
//求a的b次方，答案存到ans里
int ans=1;
while(b>0){
	if(b%2==1)  //如果当前位是1，那答案就包含这位，把a乘到ans里面
	ans=ans*a;
	a=a*a;//把a平方，切到下一状态
	b/=2;//除以2就不用说了吧
}
```
当然你可以用位运算优化，把/2改成>>1，把%2改成&1，据说会更快哦！

### 3.矩阵快速幂

如果你已了解并熟练掌握以上两点，那你离AC就只有一步之遥了

> I have a 矩阵！

> I have a 快速幂！

> Ah~！矩阵快速幂！

没错，就这么简单！因为矩阵乘法是满足**结合律**的，所以**一个单位矩阵用快速幂乘上n次**就是我们的矩阵快速幂了，或者说，矩阵快速幂就是**把快速幂里的乘法换成矩阵乘法**

```cpp
#include<cstdio>
using namespace std;
typedef long long ll; //十年OI一场空，不开long long见祖宗
const int syk=1e9+7;//syk是一个特别厉害的大佬
ll a[105][105],b;
int n;
ll ans[105][105]={0};
inline ll read(){
	char c=getchar();
	ll f=1,x=0;
	while(c<'0'||c>'9'){  //读入优化，这里就不解释了，想学的可以翻我之前的某篇题解
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
inline void jzcf1(){  //快速幂里的第一个乘法式子子ans=ans*a
	ll c[105][105]={0};
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				c[i][j]=(c[i][j]+ans[i][k]*a[k][j])%syk; //注意膜1e9+7
			}
		}
	}	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			ans[i][j]=c[i][j];
		}
	}
}
inline void jzcf2(){//快速幂里的第而个乘法式子子a=a*a
	ll c[105][105]={0};
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				c[i][j]=(c[i][j]+a[i][k]*a[k][j])%syk;
			}
		}
	}	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=c[i][j];
		}
	}
}
int main(){
	n=(int)read(),b=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++)
		a[i][j]=read();//读入
	}
	for(register int i=1;i<=n;i++)
	ans[i][i]=1;  //把ans初始化成单位矩阵
	while(b){  //快速幂来啦
		if(b&1)
		jzcf1();//把快速幂里的乘法改成矩阵乘法
		jzcf2();
		b>>=1;
	}
	for(register int i=1;i<=n;i++){ //输出
		for(register int j=1;j<=n;j++)
		printf("%lld ",ans[i][j]%syk);
		printf("\n");
	}
	return 0;
}  
```
其实，只要掌握了**矩阵乘法和快速幂的知识**，**矩阵快速幂其实一点都不难**！屏幕前的小伙伴们，恭喜你们有get到了一个新的模板题！

The  end ......

---

## 作者：Maika (赞：93)

# 前言
初拾矩阵还是刚接触OI的时候，那时候对于矩阵只能是依样画葫芦，并不是很了解。现在过去了将近1年，我也是无意之间发现我Luogu上有很多关于矩阵的模板题都没做，一方面是为了更好的梳理关于矩阵的知识，另一方面也是为了打发下午的时光， ~~主要是发现QQ空间里都在撒狗粮~~

# 矩阵的一些基本概念
### 1.矩阵是矩形的数组
For Example

如图是一个矩阵$A=(a_{ij})$，其中$i=\{1,2\},j=\{1,2,3\}$

矩阵中的第$i$行$j$列的元素通常以小写字母$a_{ij}$

$A=\left[\begin{matrix}1 & 2 & 3\\4 & 5 & 6\end{matrix}\right]$

一般的，

我们将一个内含元素全部是实数的$i$行$j$列的矩阵记为表示$R^{i\times j}$

对于集合内元素都包含于$S$的$i$行$j$列的矩阵记为表示$S^{i\times j}$


### 2.将矩阵的行和列相互交换称为矩阵的转置
For Example 

如图是矩阵$A$的转置$A^T$

$A=\left[\begin{matrix}1 & 4\\2 & 5\\3 & 6\end{matrix}\right]$

# 矩阵的基本运算
### 1.矩阵的加法
对于任意的两个大小相等的矩阵$A^{i\times j}$和$B^{i\times j}$

$A^{i\times j}+B^{i\times j} = \left[\begin{matrix}1 & 2 &3\\4 & 5 & 6\end{matrix}\right] +$
$\left[\begin{matrix}7 & 8 &9\\10 & 11 & 12\end{matrix}\right]=$
$\left[\begin{matrix}{1+7} & {2+8} &{3+9}\\{4+10} & {5+11} & {6+12}\end{matrix}\right]=$
$\left[\begin{matrix}8 & 10 &12\\14 & 16 & 18\end{matrix}\right]$

即矩阵的对应位置上的两个元素相加
### 2.矩阵的减法
对于任意的两个大小相等的矩阵$A^{i\times j}$和$B^{i\times j}$

$A^{i\times j}-B^{i\times j} = \left[\begin{matrix}1 & 2 &3\\4 & 5 & 6\end{matrix}\right] -$
$\left[\begin{matrix}7 & 8 &9\\10 & 11 & 12\end{matrix}\right]=$
$\left[\begin{matrix}{1-7} & {2-8} &{3-9}\\{4-10} & {5-11} & {6-12}\end{matrix}\right]=$
$\left[\begin{matrix}{-6} & {-6} &{-6}\\{-6} & {-6} & {-6}\\\end{matrix}\right]$

即矩阵的对应位置上的两个元素相减
### 3.矩阵的乘法
**${\color{Red}Warning}$**

**为了表达的严谨性，此块内容会出现大量数学符号与专有名词，请各位自重**

矩阵乘法的定义如下：

给定两个**相容**的矩阵$A$和$B$，

如果$A=(a_{ik})$是一个$m\times n$的矩阵，并且$B=(b_{kj})$是一个$n\times p$的矩阵，

那么它们的积$C=AB$是一个$m\times p$的矩阵$C=(c_{ij})$，

其中，对于$i=\{1,2,\cdots ,m\},j=\{1,2,\cdots ,p\}$

$c_{ij}=\sum_{i=1}^k a_{ik}b_{kj}$ 

For Example

$A=\left[\begin{matrix}1 & 2 & 3\\4 & 5 & 6\\\end{matrix}\right]$

$B=\left[\begin{matrix}7 & 8\\9 & 10\\11 & 12\\\end{matrix}\right]$

$A\times B=\left[\begin{matrix}{1\times 7+2\times 9+3\times 11} & {1\times 8+2\times 10 +3\times 12}\\{4\times 7+5\times 9+6\times 11} & {4\times 8+5\times 10+6\times 12}        \end{matrix}\right]=\left[\begin{matrix}58 & 64\\139 & 154\end{matrix}\right]$

# 一些常用的矩阵

### 1.对角线元素均为1的$n\times n$的对角矩阵称为单位矩阵
$I_n=diag(1,1,1,\cdots,1,1)=\left[\begin{matrix}1 & 0 & \cdots & 0 & 0\\0 & 1 & \cdots & 0 & 0\\\vdots & \vdots & \ddots & \vdots & \vdots\\0 & 0 & \cdots & 1 & 0\\0 & 0 & \cdots & 0 &1\end{matrix}\right]$

既然都叫做单位矩阵了，其作用也是显而易见的：

对于$\forall i,j$，都有$i=j$，

$(A=(a_{ij}))\times (I=(i_{ij}))=(A=(a_{ij})$
# 矩阵的用途
### 简单来说，主要有三

#### 第一个用途是解线性方程组
比如二维矩阵可以理解为一个平面直角坐标系内的点集，通过计算点与点之间的距离，完成聚类、分类或预测，类似的运算完全可以扩展到多维的情况。

#### 第二个用途是方程降次
也就是利用矩阵的二次型通过升维将线性不可分的数据集映射到高维中，转换为线性可分的情形，这是支持向量机的基本原理之一。

#### 第三个用途是变换
矩阵可以通过特征值和特征向量完成维度约简，简化类似图片这种高维数据集的运算，主成分分析使用的就是这个原理。

### ~~本节其实都是废话~~
反正联赛考起来好像那些都不考，就考那个啥**矩阵快速幂**和**矩阵加速**

# 矩阵快速幂

#### 终于到了正题~~突然发现矩阵的Markdown写起来要死人~~

既然是矩阵快速幂，那更关键的肯定还是快速幂了

那就先看看快速幂好了

快速幂其实是利用递推式$x^k=\begin{cases}x^{\tfrac{k}{2}}\times x^{\tfrac{k}{2}}&k\bmod 2=0\\x^{\tfrac{k-1}{2}} \times x^{\tfrac{k-1}{2}} \times x &k\bmod 2=1\end{cases}$将原本$O(k)$级别优化至$O(log_2k)$级别

所以，这种简单的代码贴个高清无码的还是很OK的

**while版：**

```cpp
while(p>0) {
	if(p%2!=0) ans=ans*b;
    	b=b*b;
        p=p>>1;
}
```
**递归版：**
```cpp
int Fastpower(int a,int n){
	if(n==0)	return 1;
	if(n==1)	return a;
	int c=Fastpower(a,n/2);
	if(n%2==0)	return c*c;
	else	return c*c*a;
}
```
在了解了何为快速幂之后，我们再来了解一下何为矩阵快速幂

说白了，就是$k$个$A^{n\times n}$的矩阵乘在一起

So,我们只需在原有的快速幂上略加修改就可以得到一份可以 ${\color{Green}AC}$黄题的代码

**递归版：**
```cpp
struct Matrix {																	\\结构体
	long long c[101][101];
} A;
long long n,k;
Matrix operator*(const Matrix &x,const Matrix &y) {								\\重载
	Matrix a;
	for(int i=1;i<=n;i++) 	
		for(int j=1;j<=n;j++)
		 a.c[i][j]=0;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++) {
				a.c[i][j]+=x.c[i][k]*y.c[k][j]%Mod;
				a.c[i][j]%=Mod;
			}
	return a;
}
Matrix Fastpower_Matrix(Matrix a,long long n) {									\\递归
	if(n==1)	return a;
	if(n%2==0)	return Fastpower_Matrix(a,n/2)*Fastpower_Matrix(a,n/2);
	if(n%2==1)  return Fastpower_Matrix(a,n/2)*Fastpower_Matrix(a,(n-1)/2)*a;
}


```
~~终于明白了为什么没有递归的题解了，因为全部TLE~~

**while版：**
```cpp
struct Matrix {																	\\结构体
	long long c[101][101];
} A,I;
long long n,k;
Matrix operator*(const Matrix &x,const Matrix &y) {								\\重载
	Matrix a;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			a.c[i][j]=0;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++) {
				a.c[i][j]+=x.c[i][k]*y.c[k][j]%Mod;
				a.c[i][j]%=Mod;
			}
	return a;
}
void Fastpower_Matrix(int k){													
	for(int i=1; i<=n; i++)
		I.c[i][i]=1;															\\单位矩阵定义
	while(k>0) {																\\Fastpower_Matrix
		if(k%2==1) I=I*A;
		A=A*A;
		k=k>>1;
	}
	
}

```
~~总感觉这个要CE，我直接在博客打的~~

**最后自然要放出高清无码的标程~~和地铁站里的蔡徐坤一样~~**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=1000000007;
struct Matrix {
	long long c[101][101];
} A,I;
long long n,k;
Matrix operator*(const Matrix &x,const Matrix &y) {
	Matrix a;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			a.c[i][j]=0;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++) {
				a.c[i][j]+=x.c[i][k]*y.c[k][j]%Mod;
				a.c[i][j]%=Mod;
			}
	return a;
}

int main() {
	cin>>n>>k;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			cin>>A.c[i][j];
	for(int i=1; i<=n; i++)
		I.c[i][i]=1;
	while(k>0) {
		if(k%2==1) I=I*A;
		A=A*A;
		k=k>>1;
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++)
			cout<<I.c[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}

```









---

## 作者：RyanLi (赞：4)

传送门：[P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)

更佳的阅读体验：[洛谷 P3390 题解](https://blog.ryanli.top/index.php/archives/277/)

在阅读本文之前，你需要了解[矩阵乘法](https://oi.wiki/math/linear-algebra/matrix/#矩阵乘法)与[快速幂](https://blog.ryanli.top/index.php/archives/257/)。

---

## 算法介绍

给你一个 $n \times n$ 的矩阵 $A$，现在你需要计算 $A^k$（即 $\underbrace{A \times A \times A \times \cdots \times A}_{k \text{ 个 } A}$）。

当 $k = 2$ 时，你知道可以直接将两个矩阵 $A$ 相乘得到答案。

当 $k \le 10$ 时，你知道可以通过手写循环语句来计算最后的答案。

那么，当 $k \le 10^{12}$ 呢？显然朴素的循环已经无法满足我们对程序的效率的要求，我们需要一个更快的算法。

陷入迷茫时，不妨回顾矩阵乘法的基本性质：

- 矩阵乘法满足**结合律**，即 $(A \times B) \times C = A \times (B \times C)$。

此时想到，是否可以使用快速幂来优化算法？答案是肯定的。

与朴素的快速幂相同，对于矩阵快速幂，我们有：
$$
A^k =
\begin{cases}
(A^{\tfrac{k}{2}})^2, & \text{if } k \text{ is even} \\
(A^{\tfrac{k - 1}{2}})^2 \times A, & \text{if } k \text{ is odd}
\end{cases}
$$
此时，问题也就迎刃而解了。

值得注意的是，在进行幂运算之前，我们需要将结果矩阵初始化为单位矩阵，即：
$$
I = \begin{bmatrix} 1 & 0 & \cdots & 0 \\ 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \end{bmatrix}
$$
这样才能保证矩阵快速幂的正确性。

## 复杂度分析

对于任意两个 $n \times n$ 的矩阵，相乘的时间复杂度为 $\Theta(n^3)$。快速幂的复杂度为 $\Theta(\log k)$。

因此，矩阵快速幂的时间复杂度为 $\Theta(n^3 \log k)$，可以通过本题。

## 代码实现

为了提高代码的可读性，我们将矩阵封装到结构体内，并且在结构体内重载乘运算符。

```cpp
#include <iostream>
using namespace std;
using ll = long long;

const int N = 110, MOD = 1e9 + 7;
int n;
ll k;
struct mat {
    ll m[N][N], h, w;
    void clear() {
        h = w = n;
        for (int i = 1; i <= h; ++i)
            for (int j = 1; j <= w; ++j) m[i][j] = 0;
    } void reset() {
        clear();
        for (int i = 1; i <= n; ++i) m[i][i] = 1;
    } mat operator *(const mat &x) const {
        mat res;
        res.clear();
        for (int i = 1; i <= h; ++i)
            for (int j = 1; j <= x.w; ++j)
                for (int k = 1; k <= w; ++k)
                    res.m[i][j] = (res.m[i][j] + m[i][k] * x.m[k][j]) % MOD;
        return res;
    }
} a;

mat expow(mat a, ll b) {
    mat res;
    res.reset(), res.h = res.w = n;
    while (b) {
        if (b & 1) res = res * a;
        a = a * a, b >>= 1;
    } return res;
}

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> k, a.h = a.w = n;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) cin >> a.m[i][j];
    a = expow(a, k);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) cout << a.m[i][j] << " \n"[j == n];
    return 0;
}
```

---

## 作者：封禁用户 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P3390)

~~我妈呀我竟然还没写过这题~~

才看见这题开了题解区，那就一起来复习一下吧。

---

关于**矩阵乘法**，题目中已经说的很清楚了，我们只需要记住这个关键的式子即可：

$$C_{i,j}=\sum_{k=1}^{n}A_{i,k}B_{k,j}$$

但是，这样直接把矩阵 $A$ 反复乘上 $k$ 次的复杂度是 $\mathcal{O}(n^3k)$，而 $k\le 10^{12}$，肯定会超时，那接下来就要引入矩阵中的**快速幂**了。

我们先拿普通的整数快速幂来举例。快速幂主要运用了**分治法**，即如果要计算 $a^n$，先计算 $a^2$，再计算 $(a^2)^2$，以此类推，一直计算到 $a^n$。我们在代码实现中可以运用**倍增**的原理。

比如把 $a^{11}$ 分解为 $a^{8+2+1}=a^8a^2a^1$，其中 $a^1,a^2,a^4,a^8\ldots$ 的幂次都是 $2$ 的倍数，所有幂 $a^i$ 都是倍乘关系，可以逐级递推。但如何把 $11$ 分解为 $8+2+1$ 呢？可以利用数的二进制的特征，$n=11_{(10)}=1011_{(2)}=2^3+2^1+2^0=8+2+1$，所以只需要把 $n$ 按二进制处理就可以了。

那么如何跳过那些没有的幂次呢？只需做一个判断，用位运算来实现，`n & 1` 是取出了 $n$ 的最后一位，判断是否需要跳过，`n >>= 1` 是把 $n$ 右移一位，目的是把刚处理过的最后一位去掉。

然后再根据取模的性质 $a^n\bmod m=(a\bmod m)^n\bmod m$，就可以写出整数快速幂的代码：

```cpp
#define int long long

// a^b % m
int Pow(int a, int b, int m)
{
	a %= m; // 防止 a*a 越界 
	int res = 1;
	while (b) // 把 b 看作二进制，逐个处理它的最后一位 
	{
		if (b & 1) res = res * a % m; // 如果 n 的最后一位是 1，表示这个地方需要乘 
		a = a * a % mod; // 递推：a^2,a^4,a^8,a^16... 
		b >>= 1; // 把 b 右移一位，把刚处理过的 b 的最后一位去掉 
	}
	return res;
}
```

再回到矩阵快速幂，只需把 $a$ 换成矩阵即可，没什么不同。这样的时间复杂度就来到了 $\mathcal{O}(n^3\log k)$，足以通过此题。

```cpp
#include <iostream>
#include <cstring>
#define int long long
using namespace std;

const int N = 105;
const int mod = 1e9 + 7;

int n, k;

struct Matrix { int m[N][N]; } a; // 矩阵

Matrix operator * (const Matrix& a, const Matrix& b) // 矩阵乘法
{
    Matrix c;
    memset(c.m, 0, sizeof c.m);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            for (int k = 0; k < n; k++)
                c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
    return c;
}

Matrix Pow(Matrix a, int k) // 矩阵快速幂
{
    Matrix ans;
    memset(ans.m, 0, sizeof ans.m);
    for (int i = 0; i < n; i++)
        ans.m[i][i] = 1;
    while (k)
    {
        if (k & 1) ans = ans * a;
        a = a * a;
        k >>= 1;
    }
    return ans;
}

signed main()
{
    ios::sync_with_stdio(false);
    ios_base::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin >> n >> k;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a.m[i][j];
    if (k == 0) // 根据题目，A^0 是单位矩阵 I
    {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                cout << (i == j) << " \n"[j == n - 1];
        return 0;
    }
    Matrix res = Pow(a, k); // 计算快速幂
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cout << res.m[i][j] << " \n"[j == n - 1];
    return 0;
}
```

---

## 作者：syx_2014 (赞：3)

### 题意
给定一个 $n\times n$ 矩阵 $A$ 和一个数 $k$，求 $A^k$ 的每一项（对 $10^9+7$ 取模）。\
$n\le100,|A_{i,j}|\le100,k\le10^{12}$。



----
### 思路

#### 矩阵乘法的定义

假设有两个矩阵 $a,b$， 如果 $a$ 的列数和 $b$ 的行数相等的话，那 $a$ 矩阵和 $b$ 矩阵就可以进行矩阵乘法，得到的结果矩阵 $c$ 的行数与 $a$ 的行数相等，$c$ 的列数与 $b$ 的列数相等。

假设 $a$ 是 $x$ 行 $y$ 列，$b$ 是 $y$ 行 $z$ 列，那 $c$ 就是 $x$ 行 $z$ 列。

矩阵 $c$ 中第 $i$ 行 $j$ 列的值的计算方法：

$$ c_{i,j}=\sum_{k=1}^{x} A_{i,k}B_{k,j} $$

举例：

$$\begin{bmatrix}1 & 2 \\ 3 & 4 \end{bmatrix} \times \begin{bmatrix} 2&2&3 \\ 2&3&3 \end{bmatrix}=\begin{bmatrix}6 & 8 &9 \\ 14 & 18&21 \end{bmatrix}$$

但用矩阵乘 $k$ 次的时间复杂度是 $\operatorname{O}(n^3k)$，过不了啊？！

----
没关系，我们有……
#### 快速幂

快速幂的核心思路很简单，就是一个式子：

* 如果 $ k $ 是偶数， 那 $ a^k = (a^ {\lfloor\frac{k}{2}\rfloor} )^2 $ 。
* 如果 $ k $ 是奇数， 那 $ a^k = (a^{\lfloor\frac{k}{2}\rfloor}) ^ 2 \times a $ 。

把 $a$ 换成矩阵，也是同理。

这样只需要算 $\log k$ 次。

-----

为了方便，我们可以定义一个矩阵结构体 `matrix`，我们用 `matrix operator*(matrix a,matrix b)` 定义矩阵结构体乘法以便于矩阵快速幂就行了。

时间复杂度：$\operatorname{O}(n^3\log k)$。

由于 $n$ 很小，$\log 10^{12}$ 也只有 $40$，所以可以轻松通过。

### 标程
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int p=1e9+7;//别忘取模。
int n,k;
//定义矩阵 matrix 新类型。
struct matrix{
	int n,m;
	int a[105][105];
	matrix(){ //构造函数，每次定义一个新变量，程序就会执行此函数，一般用来初始化。
		n=m=0;
		memset(a,0,sizeof(a));
	}
}a;
//定义 matrix 矩阵类型的乘法。
matrix operator*(const matrix &a,const matrix &b){
	matrix c;
	c.n=a.n;
	c.m=b.m;
	for(int i=1;i<=c.n;i++){
		for(int j=1;j<=c.m;j++){
			for(int k=1;k<=a.m;k++) c.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j])%p;
//在可能爆 long long 的地方别忘了取模。
		}
	}
	return c;
}//用重载运算符定义矩阵乘法。
matrix ksm(matrix a,int b){
	if(b==1) return a;
	matrix c=ksm(a,b/2);
	c=c*c;
	if(b&1) c=c*a;
	return c;
}//用了重载运算符的矩阵快速幂非常方便。
signed main(){
	cin>>n>>k;
	a.n=n,a.m=n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a.a[i][j];
		}
	}
	if(k==0){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++) cout<<(i==j)<<' ';
			cout<<'\n';
		}
		return 0;
	} //特判一下 k=0 的情况。
	matrix c=ksm(a,k);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) cout<<c.a[i][j]%p<<' ';
		puts("");
	}
	return 0;
}
```

---

## 作者：Chase12345 (赞：2)

# 前置知识
1.  [矩阵](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5/18069)
2.  [矩阵乘法](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029)
3.  [快速幂](https://www.luogu.com.cn/problem/P1226)

# 引入
矩阵的应用有以下场景：
* 线代（矩阵本来就是线代）
* DP 优化转移过程

这些通过矩阵加速可以降低复杂度。

# 矩阵的部分内容
## 矩阵加法
这是矩阵所有运算中相对简单的，也是容易理解的。

设有两个矩阵 $A=[a_{i,j}]$ 和 $B=[b_{i,j}]$，均为 $n \times m$ 的大小，令 $A+B=C=[c_{i,j}]$，其中
$$
c_{i,j}=a_{i,j}+b_{i,j} \space \space \forall i ,j
$$
## 矩阵减法
这和加法似乎是同理的，只是将上面表达式中的加法变为减法。
## 数乘
设有矩阵 $A=[a_{i,j}]$，则 $B=kA=[b_{i,j}]$ 应该满足：
* $A$ 和 $B$ 是同型矩阵
* $b_{i,j}=k \times a_{i,j}$

## 矩阵乘法
设有矩阵 $A=[a_{i,j}]$，其中 $i \in [1,m],j \in [1,n]$，$B=[b_{j,k}]$，其中 $j \in [1,n],k \in [1,p]$ 需要满足：$A$ 的列数和 $B$ 的行数相同，令 $C=[c_{i,k}]$，$C$ 的行数与 $A$ 的行数相同，$C$ 的列数与 $B$ 的列数相同，则：
$$
c_{i,j}=\sum_{k=1}^{n} a_{i,k} \times b_{k,j}
$$
请注意以下几点：
1.  满足结合律，即 $(AB)C=A(BC)$，这一点下面会证明。
2.  满足分配律，即 $A(B+C)=AB+AC$，由于这一点与此题无关，证明略。
3.  **一般情况下不满足交换律**（这一点似乎是显然地，因为交换之后不一定满足乘法的要求）
4.  $AI=IA=A$，其中 $I$ 为单位矩阵。
# 解法
先回顾快速幂。普通做法显然行不通。由于对于每个正整数 $k$，显然必定存在其二进制形式，设
$$
k=\sum_{i=0}^{\infty}b_i2^i
$$
这不正是二进制的表示方法吗？那么由于如果 $i+j=k$，则 $a^i \times a^j =a^k$，这一点是显然地。那么：
$$
a^k=\prod_{i=0}^{\infty}(b_i \times a^{2^i})
$$
根据矩阵乘法的结合律，这一点显然可以拓展到矩阵 $A$。
$$
A^k=\prod_{i=0}^{\infty}(b_i \times A^{2^i})
$$
不过请注意 $A$ 必须是方阵，否则无法进行幂运算。那么就可以完成这道题了。

# 正确性证明
这里只需要证明矩阵的乘法具有结合律。
设矩阵 $A=[a_{i,j}]$，其中 $i \in [1,m],j \in [1,n]$，$B=[b_{j,k}]$，其中 $j \in [1,n],k \in [1,p]$，$C=[c_{i,k}]$，其中 $i \in [1,p],k \in [1,q]$

计算 $(AB)C$：
> 设 $D=[d_{i,k}]$ 为 $AB$，则：
> $$
> d_{i,k}=\sum_{j=1}^{n} a_{i,j} \times b_{j,k}
> $$
> 设 $DC=E=[e_{i,l}]$，则：
> $$
> e_{i,l}=\sum_{k=1}^{p} d_{i,k}c_{i,l}=\sum_{k=1}^{p} \sum_{j=1}^{n} a_{i,j}b_{j,k}c_{k,l}
> $$
> 

计算 $A(BC)$
> 设 $BC=F=[f_{j,l}]$，则：
> $$
> f_{j,l}=\sum_{k=1}^{p} b_{j,k}c_{k,l}
> $$
> 设 $AF=G=[g_{i,l}]$，其中：
> $$
> g_{i,l}=\sum_{j=1}^{n} a_{i,j}f_{j,l}=\sum_{j=1}^{n} \sum_{k=1}^{p} a_{i,j}b_{j,k}c_{k,l}
> $$

最终比较一下 $E$ 和 $G$，求和顺序可变，则相同。则满足结合律。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using vi = vector <i64>;
using M = vector <vi>;
const int MOD = 1e9 + 7;

M multi(M a, M b) {
	int n = a.size(), t = a[0].size(), m = b[0].size();
	M ret(n, vi(m, 0));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			for (int k = 0; k < t; k++)
				ret[i][j] = (ret[i][j] % MOD + ((a[i][k] + MOD) % MOD * (b[k][j] + MOD) % MOD + MOD)) % MOD;
	return ret;
}

M fpow(M a, long long k) {
	int n = a.size();
	M ret(n, vi(n, 0));
	for (int i = 0; i < n; i++)
		ret[i][i] = 1;
	for (; k; a = multi(a, a), k >>= 1)
		if (k & 1)
			ret = multi(ret, a);
	return ret;
} 

int main() {
	long long n, k;
	cin >> n >> k;
	M A(n, vi(n, 0));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			cin >> A[i][j];
	M ret = fpow(A, k);
	for (int i = 0; i < ret.size(); i++) {
		for (int j = 0; j < ret[i].size(); j++)
			cout << ret[i][j] << ' ';
		cout << '\n';
	}
	return 0;
}
```
请注意对负数的处理。总的时间复杂度：$O(n^3 \log k)$。
# 例题
## 斐波那契数列
[P1962](https://www.luogu.com.cn/problem/P1962)。这是一个非常经典的矩阵加速递推的题目。首先递推显然不行，时间复杂度爆炸。考虑矩阵加速。

首先我们设有一个矩阵
$$
\begin{bmatrix} F_{n} & F_{n-1} \end{bmatrix}
$$
看看怎么样设转移矩阵。设为
$$
\begin{bmatrix} x & y \\ z & w \end{bmatrix}
$$
则我们可以得到：
$$
\begin{bmatrix} F_{n} & F_{n-1} \end{bmatrix} \times \begin{bmatrix} x & y \\ z & w \end{bmatrix}=\begin{bmatrix} x \times F_{n}+z \times F_{n-1} & y \times F_{n}+w\times F_{n-1} \end{bmatrix}=\begin{bmatrix} F_{n+1} & F_{n} \end{bmatrix}
$$
由于 $F_{n+1}=F_n+F_{n-1}$，则必然可以得到 $x=1,y=1,z=1,w=0$，这样满足递推关系。由于矩阵的乘法具有结合律，直接上矩阵快速幂即可。
```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using vi = vector <i64>;
using M = vector <vi>;
const int MOD = 1e9 + 7;

M multi(M a, M b) {
	int n = a.size(), t = a[0].size(), m = b[0].size();
	M ret(n, vi(m, 0));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			for (int k = 0; k < t; k++)
				ret[i][j] = (ret[i][j] % MOD + ((a[i][k] + MOD) % MOD * (b[k][j] + MOD) % MOD + MOD)) % MOD;
	return ret;
}

M fpow(M a, long long k) {
	int n = a.size();
	M ret(n, vi(n, 0));
	for (int i = 0; i < n; i++)
		ret[i][i] = 1;
	for (; k; a = multi(a, a), k >>= 1)
		if (k & 1)
			ret = multi(ret, a);
	return ret;
} 

int main() {
	long long n = 2, k;
	cin >> k;
	M A(n, vi(n, 0));
	A[0][0] = A[0][1] = A[1][0] = 1;
	M ret = fpow(A, k);
	cout << ret[0][1] << '\n';
	return 0;
}
```
## 广义斐波那契
[P1349](https://www.luogu.com.cn/problem/P1349)。这个例题其实和上面的类似，这里就不给推导过程了，直接上代码。
```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using vi = vector <i64>;
using M = vector <vi>;
int MOD;

M multi(M a, M b) {
	int n = a.size(), t = a[0].size(), m = b[0].size();
	M ret(n, vi(m, 0));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			for (int k = 0; k < t; k++)
				ret[i][j] = (ret[i][j] % MOD + ((a[i][k] + MOD) % MOD * (b[k][j] + MOD) % MOD + MOD)) % MOD;
	return ret;
}

M fpow(M a, long long k) {
	int n = a.size();
	M ret(n, vi(n, 0));
	for (int i = 0; i < n; i++)
		ret[i][i] = 1;
	for (; k; a = multi(a, a), k >>= 1)
		if (k & 1)
			ret = multi(ret, a);
	return ret;
} 

int main() {
	int p, q, s, t, n;
	cin >> p >> q >> s >> t >> n >> MOD;
	if (n == 1) {
		cout << s << '\n';
		return 0;
	} else if (n == 2) {
		cout << t << '\n';
		return 0;
	}
	M A(2, vi(2, 0));
	M B(2, vi(1, 0));
	B[0][0] = t;
	B[1][0] = s;
	A[0][0] = p;
	A[0][1] = q;
	A[1][0] = 1;
	M ret = multi(fpow(A, n - 2), B);
	cout << ret[0][0] << '\n';
	return 0;
}
```
# 拓展内容
## 矩阵的转置
即将矩阵的行列转换，记作 $A^T$。若 $A=[a_{i,j}]_{m \times n}$，则 $A^T=[a_{j,i}]_{n \times m}$。
满足如下性质：
1.  $(A^T)^T=A$
2.  $(A+B)^T=A^T+B^T$
3.  $(kA)^T=kA^T$
4.  $(AB)^T=B^TA^T$

## 矩阵的迹
记**方阵** $A=[a_{i,j}]_{n \times n}$，记其迹为 $\textrm{tr}(A)$，则
$$
\textrm{tr}(A)=\sum_{i=1}^{n} a_{i,i}
$$
满足如下性质：
1.  $\textrm{tr}(A+B)=\textrm{tr}(A)+\textrm{tr}(B)$
2.  $\textrm{tr}(kA)=k \cdot \textrm{tr}(A)$
3.  $\textrm{tr}(AB)=\textrm{tr}(BA)$
## 矩阵行列式
我们记方阵的标量值为 $|A|$，一般用于判断矩阵是否可逆。满足如下性质：
1.  $\textrm{det}(AB)=\textrm{det}(A) \textrm{det}(B)$
2.  $\textrm{det}(A^T)=\textrm{det}(A)$
3.  若 $\textrm{det}(A)=0$，则 $A$ 不可逆。
## 矩阵的逆
对于方阵 $A$，若存在 $A^{-1}$ 使得 $AA^{-1}=I$，其中 $I$ 为单位矩阵，则 $A$ 可逆。满足如下性质：
1.  $(AB)^{-1}=B^{-1}A^{-1}$
2.  $(A^T)^{-1}=(A^{-1})^T$
3.  $(kA)^{-1}=\frac{1}{k}A^{-1}(k \neq 0)$
# 总结
矩阵是一个很好用的工具，还有更多的结论在大学（或者数竞生初高中就学了）。本人为了~~写题解~~提前学习新知识就自学了一下。不过不得不说 S 组放线性代数确实有点过了。

# Update:

一审被打回。写了一些拓展的内容，并增加了正确性证明。

~~写了一个晚上的题解各位可否点个赞再走？~~

---

## 作者：_orz (赞：2)

~~板子题有什么题解的必要吗（小并感）~~

其实是突然想到一个池沼问题，就是说我写一个`struct`，万一我在函数里定义一个矩阵，然后矩阵又很大，那就Stack Overflow了。所以就想能不能动态开个二维数组。。

然后池沼的我就去请教了大佬，学会了些~~好康的（并不）~~操作。

---

# 让我们发车

我们先写个**结构体**，

```cpp
struct Matrix {
  int n,m; // n行m列的矩阵
  long long **a; // 双重指针，用来搞二维数组
};
```

然后当我们定义一个 $n$ 行 $m$ 列的矩阵 $A$ 的时候，我们希望通过`Matrix A(n,m)`这种操作来实现。于是我们写一个**构造函数**。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0; // 将矩阵所有元素赋初值为0
    }
  }
};
```

这个时候我们不得不写一个**析构函数**。因为我们的`struct`里面有的只是一个双重指针。当我们定义的矩阵离开作用域的时候，他不知道我们自己又开了那么多内存空间，于是只会简单的删掉那个双重指针。过不了多久内存就会炸的。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
};
```

接下来可以重载乘号运算符了吗？答案肯定是不行啦。因为我们考虑写重载乘号的时候一般是在开头定义一个临时变量来存答案，最后再返回那个临时变量。然而如果这么做的话，那个临时变量会在函数结束的时候被析构掉，这个时候返回的指针指向的是一个空的地址，会导致RE。解决方案是使用**拷贝构造函数**。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
};
```

然后我们就可以愉快地写**重载乘号运算符**啦！

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
};
```

我们这个时候又注意到，如果我们要写快速幂，貌似还得用到赋值号。那还得**重载赋值运算符**。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
};
```

我们觉得访问矩阵的第 $i$ 行第 $j$ 列，用`A.a[i][j]`不好看也不方便，于是我们再**重载中括号运算符**。这样我们就可以直接`A[i][j]`啦！

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  
  
  // 从这开始是新的，上面是重复的不用看
  long long *operator[](int p) {return a[p];}
};
```

我们做矩阵乘法快速幂的时候，一开始要有一个单位矩阵。为方便起见，我们写个函数在这里来构造单位矩阵。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  long long *operator[](int p) {return a[p];}
  
  
  // 从这开始是新的，上面是重复的不用看
  void I() {for(int i=1;i<=n;i++) a[i][i]=1;}
};
```

最后，为了方便输出，我们定义一个函数来输出矩阵。

```cpp
struct Matrix {
  int n,m;
  long long **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new long long*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[m+1];
      for(int j=1;j<=m;j++)
      	a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new long long*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new long long[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  long long *operator[](int p) {return a[p];}
  void I() {for(int i=1;i<=n;i++) a[i][i]=1;}
  
  
  // 从这开始是新的，上面是重复的不用看
  void print() {
    for(int i=1;i<=n;i++) {
      for(int j=1;j<=n;j++)
        printf("%lld ",a[i][j]);
      puts("");
};
```

那么我们的`struct`就定义好了。

---

# 注意

里面的这几个函数，除了**拷贝构造函数一定要在重载乘号和重载赋值号之前定义**之外，其他的顺序没有什么强制性规定。

# 代码

下面放完整代码：

```
#include <cstdio>
#include <iostream>

using namespace std;
typedef long long ll;
const int ha=1e9+7,MAXN=110;

struct Matrix {
  int n,m;
  ll **a;
  Matrix(int n, int m):n(n),m(m) {
    a=new ll*[n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new ll[m+1];
      for(int j=1;j<=m;j++) a[i][j]=0;
    }
  }
  ~Matrix() {
    for(int i=1;i<=n;i++) delete[] a[i];
    delete[] a;
  }
  Matrix(const Matrix &b):n(b.n),m(b.m) {
    a=new ll*[b.n+1];
    for(int i=1;i<=n;i++) {
      a[i]=new ll[b.m+1];
      std::copy(b.a[i]+1,b.a[i]+1+m,a[i]+1);
    }
  }
  Matrix operator*(Matrix b) {
    Matrix ret(n,b.m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=b.m;j++)
        for(int k=1;k<=m;k++)
          ret.a[i][j]=(ret.a[i][j]+a[i][k]*b[k][j])%ha;
    return ret;
  }
  Matrix &operator=(Matrix b) {
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        a[i][j]=b.a[i][j];
    return *this;
  }
  ll *operator[](int p) {return a[p];}
  void I() {for(int i=1;i<=n;i++) a[i][i]=1;}
  void print() {
    for(int i=1;i<=n;i++) {
      for(int j=1;j<=n;j++)
        printf("%lld ",a[i][j]);
      puts("");
    }
  }
};

Matrix ksm(Matrix a, ll k) {
  Matrix ret(a.n,a.m);
  ret.I();
  while(k) {
    k&1?ret=ret*a,0:0;
    a=a*a;
    k>>=1;
  }
  return ret;
}

int n;
ll k;

main() {
  cin>>n>>k;
  Matrix A(n,n);
  for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
      scanf("%lld",&A[i][j]);
  ksm(A,k).print();
}
```

---

## 作者：Yeonjun_0913 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3390)


---

### 思路
其实矩阵快速幂可以化为以下的两个东西：**矩阵乘法+快速幂**。只需要把快速幂中的乘法换成矩阵乘法就可以了。


---

### 快速幂
不会快速幂的看过来。

快速幂是一种用指数级的时间复杂度求出 $a^n$ 的算法。有两种版本，分别为递归和位运算版，但并不推荐用递归版，因为在数据量较大的情况下，递归版容易超时。
> #### 位运算版
> 举个栗子，$2^{11}$，我们可以把指数 $11$ 转化为 $2^{1+2+8}$，即为 $2^1 \times 2^2 \times 2^8$。这里我们利用一个方法，就是 $a \cdot a=a^2$，$a^2 \cdot a^2=a^4$，把指数转化为 $2$ 的整数次幂相加，这样的话，只要每次把 $a$ 的平方赋值给 $a$，那么就能算出 $a^{2^k}$，如果把指数分解成 $2$ 的整数次幂后有 $2^k$ 那么就把它累乘到答案中。蛋柿，怎么判断指数分解后有没有 $2^k$ 呢？试着观察以下指数华为二进制后的结果。就拿 $11$ 来说，二进制是 $(1011)_2$，可得出 $11=1 \times 2^3 + 0 \times 2^2 +1 \times 2^1 +1 \times 2^0$，所以，如果指数在二进制下的第 $k$ 位为 $1$，那么就说明分解后有 $2^k$。最终用 $O(\log n)$ 的时间复杂度算出 $a^n$。
> 
> **code**
> 
> ```cpp
> typedef long long ll;
> ll q_pow(ll a,ll b,ll p){
>     ll sum=1,x=a%p;
>     while (b){
>         if (b&1) sum=(sum*(x%p))%p;
>         x=(x*x)%p;
>         b>>=1;
>     }
>     return sum;
> }
> ```

矩阵乘法题面中已经给出了，所以不多赘述，我们只需要把乘法写进函数或定义结构体并重载运算符。把快速幂中的乘法换成矩阵乘法，就可以了。要注意的是，单位矩阵如下所示，对角线都是 $1$，其余为 $0$。
$$
\begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}
$$

### 矩阵乘法结合律证明
$$
\begin{aligned}
(AB)C&=(\sum_{k=1}^{n} a_{ik}b_{kj})C\\
&=(\sum_{m=1}^{n} \sum_{k=1}^{n} a_{ik}b_{km}c_{mj}) \\
\end{aligned} \\
\begin{aligned}
A(BC)&=A(\sum_{k=1}^{n} b_{ik}c_{kj})\\
&=(\sum_{m=1}^{n} \sum_{k=1}^{n}a_{im}b_{mk}c_{kj})
\end{aligned}
$$

### AC CODE


```cpp
#include <iostream>
using namespace std;

typedef long long ll;
const int p=1e9+7;
int n;
ll k;
ll a[105][105],t[105][105],ans[105][105];
void multi(ll a[][105],ll b[][105]){ //矩阵乘法
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            for (int k=1;k<=n;k++){
                t[i][j]=(t[i][j]+(a[i][k]*b[k][j])%p)%p;
            }
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            a[i][j]=t[i][j];  //把t数组中计算的答案赋值回答案数组
            t[i][j]=0;  //把t数组清零
        }
    }
}
void q_pow(){
    while (k){
        if (k&1) multi(ans,a); //，判断二进制为是否为1 ，并把普通的乘法换成矩阵乘法
        multi(a,a);  //同上
        k>>=1;
    }
}

int main (){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> k;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            cin >> a[i][j];
            a[i][j]%=p;
            ans[i][j]=0; //顺便把ans数组初始化
        }
        ans[i][i]=1;
    }
    q_pow();
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            cout << ans[i][j] << ' ';
        }
        cout << endl;
    }
    return 0;
}
```

---


# 233 Matrix

## 题目描述

在我们的日常生活中，我们经常用 233 来表达我们的情感。实际上，我们可能会说 2333、23333 或者 233333... 都表示同样的意思。现在有一个问题：假设我们有一个称为 233 矩阵。在第一行，它可能是 233、2333、23333...（表示 $a _ {0,1} = 233$，$a_{0,2} = 2333$，$a_{0,3} = 23333$...）。此外，在 233 矩阵中，我们有 $a_{i,j} = a_{i-1,j} +a_{i,j-1}( i,j \neq 0)$。现在已知 $a_{1,0},a_{2,0},\dots,a_{n,0}$，你能告诉我 233 矩阵中的 $a_{n,m}$ 吗？

## 样例 #1

### 输入

```
1 1
1
2 2
0 0
3 7
23 47 16```

### 输出

```
234
2799
72937```

# 题解

## 作者：ask_silently (赞：8)

## [原题传送门](https://www.luogu.com.cn/problem/P10503)


---

## 矩阵快速幂

我们观察一下题目，看见了 $n,m$ 的范围，又看到了矩阵，一眼矩阵快速幂【手动自信】

那如何推状态转移方程呢？

我们发现每一行相邻两个数的关系不太好看出来，于是我们看一看每一列相邻两个数的关系。

||$233$|
|:-:|:-:|
|$a$|$233+a$|
|$b$|$233+a+b$|
|$c$|$233+a+b+c$|

我们再次发现，对于第 $i$ 行的数，都等于**前一列在此行前面包括此行的数与本列最上方数的和**，于是状态转移方程呼之欲出，但只是欲出。

注意到 $233$ 转移到下一列 $2333$ 需要乘上 $10$ 再加上 $3$，由于该数在第一行，所以会影响到下面所有的数，所以该列所有的数都需要再加上 $3$，于是，我们就可以推出状态转移方程了：

$\begin{bmatrix}1&1&1&1&\cdots&1\\0&10&10&10&\cdots&10&\\0&0&1&1&\cdots&1\\0&0&0&1&\cdots&1\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\\0&0&0&0&\cdots&1\end{bmatrix}$

初始矩阵：

$\begin{bmatrix}3&23&a_1&a_2&\cdots&a_n\end{bmatrix}$

## ACcode

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N=15;
const int mod=1e7+7;

int n,m;
int a[N];

struct node{
	int x,y;
	int ju[N][N];
}chu,cheng,sum;

inline int read(){
	int t=0,f=1;
	register char c=getchar();
	while (c<48||c>57) f=(c=='-')?(-1):(f),c=getchar();
	while (c>=48&&c<=57)t=(t<<1)+(t<<3)+(c^48),c=getchar();
	return f*t;
}

void init(){
	memset(chu.ju,0,sizeof(chu.ju));
	memset(cheng.ju,0,sizeof(cheng.ju));
	memset(sum.ju,0,sizeof(sum.ju));
	chu.x=1,chu.y=n+2;
	chu.ju[1][1]=3,chu.ju[1][2]=23;
	for(int i=3;i<=n+2;i++) chu.ju[1][i]=a[i-2];
	cheng.x=cheng.y=n+2;
	cheng.ju[1][1]=1;
	for(int i=2;i<=n+2;i++){
		cheng.ju[1][i]=1,cheng.ju[2][i]=10;
		for(int j=3;j<=i;j++) cheng.ju[j][i]=1;
	}
	sum.x=sum.y=n+2;
	for(int i=1;i<=n+2;i++) sum.ju[i][i]=1;
}

node operator *(const node &x,const node &y){
	node z;
	memset(z.ju,0,sizeof(z.ju));
	z.x=x.x,z.y=y.y;
	for(int i=1;i<=z.x;i++){
		for(int j=1;j<=z.y;j++){
			for(int k=1;k<=x.y;k++) z.ju[i][j]=(z.ju[i][j]+(x.ju[i][k]*y.ju[k][j])%mod)%mod;
		}
	}
	return z;
}

int ksm(int b){
	while(b){
		if(b&1) sum=sum*cheng;
		cheng=cheng*cheng;
		b>>=1;
	}
	sum=chu*sum;
	return sum.ju[1][n+2];
}

signed main(){
	while(cin>>n>>m){
		for(int i=1;i<=n;i++) a[i]=read();
		init();
		cout<<ksm(m)<<"\n";
	}
	return 0;
}

```
完结，撒花【花】【花】【花】

---

## 作者：_zuoqingyuan (赞：6)

# 思路分析

因为 $m\le 10^9$，题目中又给出了递推式，很容易就想到矩阵加速递推。

但这个递推式并不好化为矩阵，因为 $a_{i,j}=a_{i-1,j}+a_{i,j-1}$ 中后一项 $a_{i,j-1}$ 和 $a_{i,j}$ **在同一列**，我们要想办法把他**转化为其他项**。

根据定义，可以得到

$$a_{i,j-1}=a_{i-1,j-1}+a_{i,j-2}$$

我们发现 $a_{i,j}$ 仍和 $a_{i,j-2}$ 在同一列，我们继续把他转化掉。

$$a_{i,j}=a_{i-1,j}+a_{i-1,j-1}+a_{i,j-2}$$

$$a_{i,j}=\sum_{k=2}^j a_{i-1,k}+a_{i,1}$$

具体的，我们可以把 $a_{i,1}$ 和 $a_{i-1,1}$ 的关系也表示出来。因为 $a_{i,1}$ 相比于 $a_{i-1,1}$ 最后多了一个 $3$，可以写成 $a_{i,1}=10\times a_{i-1,1}+3$。

令矩阵 $F_i=\begin{bmatrix}3&a_{i,0}&a_{i,1}&a_{i,2}&\dots&a_{i,n}\end{bmatrix}$，则 $F_0=\begin{bmatrix}3&23&a_{0,1}&a_{0,2}&\dots&a_{0,n}\end{bmatrix}$，令矩阵 $A$ 为满足 $F_i\times A=F_{i+1}$ 的转移矩阵，可得：

$$A=\begin{bmatrix}
1&1&1&1&\dots&1\\
0&10&10&10&\dots&10\\
0&0&1&1&\dots&1\\
0&0&0&1&\dots&1\\
\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&0&\dots&1\\
\end{bmatrix}$$

具体的就不详细讲了。

# Code：


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define int long long
using namespace std;
const int mod=1e7+7;
inline void read(int &a){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-48,ch=getchar();
	a=x*f;return;
}
int f[12],a[12][12],n,m;
void mul(){
	int c[12];
	memset(c,0,sizeof(c));
	for(int j=0;j<=n+1;j++){
		for(int k=0;k<=n+1;k++){
			c[j]=(c[j]+f[k]*a[k][j])%mod;
		}
	}	
	for(int i=0;i<=n+1;i++)f[i]=c[i];
	return; 
}
void che(){
	int c[12][12];
	memset(c,0,sizeof(c));
	for(int i=0;i<=n+1;i++){
		for(int j=0;j<=n+1;j++){
			for(int k=0;k<=n+1;k++){
				c[i][j]=(c[i][j]+a[i][k]*a[k][j])%mod;
			}
		}
	}
	for(int i=0;i<=n+1;i++)for(int j=0;j<=n+1;j++)a[i][j]=c[i][j];
	return;
}
void ksm(int x){
	while(x){
		if(x&1)mul();
		che();
		x>>=1; 
	}
	return;
}
void init(){
	a[0][0]=1;
	for(int i=1;i<=n+1;i++)a[0][i]=1,a[1][i]=10;
	for(int i=2;i<=n+1;i++){
		for(int j=2;j<=i;j++)a[j][i]=1;
	}
	return;
}
signed main(){
	while(cin>>n>>m){
		memset(f,0,sizeof(f));
		memset(a,0,sizeof(a));
		f[0]=3,f[1]=23;
		for(int i=1;i<=n;i++)scanf("%d",&f[i+1]); 
		init();
		ksm(m);
		cout<<f[n+1]<<endl;
	}
	return 0;
}

```

如有错误，请指出。

---

## 作者：_Liyx_ (赞：5)

## 矩阵快速幂
这里用 $a_{i,j}$ 来表示 233 矩阵第 $i$ 行，第 $j$ 列的数字。

可以使用瞪眼法看出：第 $j-1$ 列可以推出第 $j$ 列。

$a_{0,j}=a_{0,j-1} \times 10+3$

对于$1 \le i \le n$来说，$a_{i,j}=a_{i-1,j}+a_{i,j-1}$。

我们有矩阵：
$F_i=\begin{bmatrix}
 3 & a_{0,i} & a_{1,i} & a_{2,i} & \cdots & a_{n,i}
\end{bmatrix}$

（ 3 是为了让上文中 $a_{0,j}=a_{0,j-1} \times 10+3$ 的 3 可以加上）

而我们要让 $F_{i-1}\times K=F_i$，如果我们能推出矩阵 $K$ 那这道题就解决了。
（这不是显然吗）

先看 $F_0$，$F_0=\begin{bmatrix}
 3 & 23 & a_{1,0} & a_{2,0} & \cdots & a_{n,0}
\end{bmatrix}$

矩阵前两列分别为 $\begin{pmatrix}
 1
 \\0
 \\0
 \\0
 \\\vdots 
 \\0
\end{pmatrix}$ 和 $\begin{pmatrix}
 1
 \\10
 \\0
 \\0
 \\\vdots 
 \\0
\end{pmatrix}$。

因为 $a_{i,j}=a_{i-1,j}+a_{i,j-1}$，所以第 $k$ 列（$3\le k \le n+2$）前 $k$ 项与第 $k-1$ 列的前 $k-1$ 项相同，第 $k$ 项为1。下面放一下矩阵 $K$。

$K=\begin{bmatrix}
 1 & 1 & 1 & 1 & \cdots  & 1\\
 0 & 10 & 10 & 10 & \cdots & 10\\
 0 & 0 & 1 & 1 & \cdots & 1\\
 0 & 0 & 0 & 1 & \cdots & 1\\
 \vdots & \vdots & \vdots & \vdots & \ddots  & \vdots\\
 0 & 0 & 0 & 0 & \cdots & 1
\end{bmatrix}$

最后用 $F_0 \times K^m$ 得到的矩阵第 1 行最后一个数即为所求。

## Code
https://www.luogu.com.cn/paste/hcbvaiw0

---

## 作者：Fujxxx (赞：3)

## 矩阵快速幂思路
考虑构造原矩阵第二列，如下图所示。
$$\begin{pmatrix}
a\\
b\\
c\\
\end{pmatrix}$$
要想实现快速幂递推，要实现的下一个矩阵如下图所示。
$$\begin{pmatrix}
a\times10+3\\
b+a\times10+3\\
c+b+a\times10+3\\
\end{pmatrix}$$
考虑怎么实现加三，在原矩阵最上方添加元素一，如下图所示。
$$\begin{pmatrix}
1\\
a\\
b\\
c\\
\end{pmatrix}$$
要得到目标矩阵，如下图所示。
$$\begin{pmatrix}
1\\
a\times10+3\\
b+a\times10+3\\
c+b+a\times10+3\\
\end{pmatrix}$$
只需构造矩阵如下。
$$\begin{pmatrix}
1&0&0&0\\
3&10&0&0\\
3&10&1&0\\
3&10&1&1\\
\end{pmatrix}$$
用这个矩阵的幂乘原矩阵第二列即得答案。

下面给出参考代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MOD=1e7+7;
int n,m,x;
struct Matrix{
	int a[13][13];
	inline void clear(){ memset(a,0,sizeof(a)); }
}a,ans,gen;
Matrix operator *(const Matrix &x,const Matrix &y){
	Matrix ans;ans.clear();
	for(register int k=1;k<=n;k++)
		for(register int i=1;i<=n;i++)
			for(register int j=1;j<=n;j++)
				ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j]%MOD)%MOD;
	return ans;
}
inline Matrix qpow(Matrix x,int num){
	Matrix ans;ans.clear();
	for(register int i=1;i<=n;i++)
		ans.a[i][i]=1;
	while(num){
		if(num&1) ans=ans*x;
		x=x*x,num>>=1;
	}return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	while(cin>>n>>m){
		a.clear(),ans.clear(),gen.clear();
		gen.a[1][1]=1;
		gen.a[2][1]=233;
		for(int i=1;i<=n;i++) cin>>x,gen.a[i+2][1]=x+gen.a[i+1][1];
		n+=2;
		a.a[1][1]=1;
		for(int i=2;i<=n;i++){
			a.a[i][1]=3;
			a.a[i][2]=10;
			for(int j=3;j<=i;j++){
				a.a[i][j]=1;
			}
		}
		ans=qpow(a,m-1)*gen;
		cout<<ans.a[n][1]<<'\n';
	}
	return 0;
}
```

---

## 作者：iChen (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10503)  
## 思路  
题意还是可以很容易地看懂的，看见了 $n$ 和 $m$ 的数据范围，一眼矩阵乘法快速幂。  
难点在于如何更新 $233333\cdots$，我们可以把矩阵中加入一项初始值为 $233$ 的项和一个 $3$ 的项，每次更新时把 $233333\cdots$ 乘上 $10$ 再加上 $3$，把 $3$ 不动地维护下去，即可实现。  
发现第 $i$ 项转移下去时，是第 $0$ 到 $i$ 的每一项的和（我们用第 $0$ 项存储 $233333\cdots$，第 $11$ 项存储 $3$），所以转移矩阵为：  

```
10 0 0 0 0 0 0 0 0 0 0 1
1 1 0 0 0 0 0 0 0 0 0 0
1 1 1 0 0 0 0 0 0 0 0 0
1 1 1 1 0 0 0 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0 0 0
1 1 1 1 1 1 0 0 0 0 0 0
1 1 1 1 1 1 1 0 0 0 0 0
1 1 1 1 1 1 1 1 0 0 0 0
1 1 1 1 1 1 1 1 1 0 0 0
1 1 1 1 1 1 1 1 1 1 0 0
1 1 1 1 1 1 1 1 1 1 1 0
0 0 0 0 0 0 0 0 0 0 0 1
```

而初始矩阵为：

```
0 233 0 0 0 0 0 0 0 0 0 0
0 (第1项) 0 0 0 0 0 0 0 0 0 0
0 (第2项) 0 0 0 0 0 0 0 0 0 0
0 (第3项) 0 0 0 0 0 0 0 0 0 0
0 (第4项) 0 0 0 0 0 0 0 0 0 0
0 (第5项) 0 0 0 0 0 0 0 0 0 0
0 (第6项) 0 0 0 0 0 0 0 0 0 0
0 (第7项) 0 0 0 0 0 0 0 0 0 0
0 (第8项) 0 0 0 0 0 0 0 0 0 0
0 (第9项) 0 0 0 0 0 0 0 0 0 0
0 (第10项) 0 0 0 0 0 0 0 0 0 0
0 3 0 0 0 0 0 0 0 0 0 0
```

秒掉啦！

## AC code  
```cpp
#include <cstdio>
#include <cstring>
#define int long long

const int N=15,mod=1e7+7;
int n,m;
struct matrix
{
	int a[N][N];
	matrix ()
	{
		memset(a,0,sizeof a);
	}
};

inline matrix operator * (matrix a,matrix b)
{
	matrix c;
	for(int i=0;i<=11;i++)
	{
		for(int j=0;j<=11;j++)
		{
			for(int k=0;k<=11;k++)
				c.a[i][j]=(c.a[i][j]+a.a[k][j]*b.a[i][k]%mod)%mod;
		}
	}
	return c;
}

inline matrix fast_pow (matrix a,int b)
{
	matrix answ;
	for(int i=0;i<=11;i++) answ.a[i][i]=1;
	while(b)
	{
		if(b & 1) answ=answ*a;
		a=a*a;
		b>>=1;
	}
	return answ;
}

inline void solve ()
{
	matrix ans;
	memset(ans.a,0,sizeof ans.a);
	for(int i=1;i<=n;i++) scanf("%lld",&ans.a[i][1]);
	ans.a[0][1]=233,ans.a[11][1]=3;
	matrix a;
	
	for(int i=1;i<=10;i++)
	{
		for(int j=0;j<=i;j++) a.a[i][j]=1;
	}
	
	a.a[0][0]=10;
	a.a[0][11]=1;
	a.a[11][11]=1;
	matrix p=fast_pow(a,m);
	ans=ans*p;
	
	printf("%lld\n",ans.a[n][1]);

}

signed main ()
{
	while(scanf("%lld%lld",&n,&m) != EOF) solve();
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：2)

# P10503 题解

## 前置知识

矩阵加速。

如果不会矩阵加速，可以看看 P1939 和 P3390，这里不做过多解释。

## 思路

本题难在构造初始矩阵。

矩阵大概长这样：

$$
a=
\begin{bmatrix}
233 & 2333 & 23333 & \cdots & a_{0,m} \\
a_{1,1} & a_{1,2} & a_{1,3} & \cdots & a_{1,m} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
a_{n,1} & a_{n,2} & a_{n,3} & \cdots & a_{n,m}
\end{bmatrix}
$$

将其行列转换一下，变成：

$$
a=
\begin{bmatrix}
23 & a_{1,0} & a_{2,0} & \cdots & a_{n,0} \\
233 & a_{1,1} & a_{2,1} & \cdots & a_{n,1} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
a_{0,m} & a_{1,m} & a_{2,m} & \cdots & a_{n,m}
\end{bmatrix}
$$

发现最左边一列的规律一直都是乘 $10$ 然后加 $3$，而矩阵乘法只与系数以及矩阵中的值有关，所以为了出现一个 $3$，我们可以造一个，直接在第一列和第二列之间插入一列 $3$，变成了：

$$
a=
\begin{bmatrix}
23 & 3 & a_{1,0} & a_{2,0} & \cdots & a_{n,0} \\
233 & 3 & a_{1,1} & a_{2,1} & \cdots & a_{n,1} \\
\vdots & 3 & \vdots & \vdots & \ddots & \vdots \\
a_{0,m} & 3 & a_{1,m} & a_{2,m} & \cdots & a_{n,m}
\end{bmatrix}
$$

接下来要找的就是行与行之间的关系了！

第一个数，由原来扩大到 $10$ 倍后加上第二列的 $3$，第二列保持原状，第三列开始全部都与前面一列相比加上自己。

也就是，可以构造出这样一个矩阵：

$$
b=
\begin{bmatrix}
1 & 1 & 1 & 1 & 1 & \cdots & 1 \\
0 & 10 & 10 & 10 & 10 & \cdots & 10 \\
0 & 0 & 1 & 1 & 1 & \cdots & 1 \\
0 & 0 & 0 & 1 & 1 & \cdots & 1 \\
0 & 0 & 0 & 0 & 1 & \cdots & 1 \\
\vdots & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \\
0 & 0 & 0 & 0 & 0 & \cdots & 1
\end{bmatrix}
$$

然后跑一遍快速幂，与 $a$ 相乘即为结果。

递归快速幂可能会爆内存，就采用循环快速幂吧。

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N=15;
const int mod=10000007;

int n,m;

struct Matrix {
    int n,m;
    int mat[N][N];
    Matrix() {
        for (int i=0;i<N;++i) {
            for (int j=0;j<N;++j) {
                mat[i][j]=0;
            }
        }
    }
    Matrix(int n,int m) {
        this->n=n;
        this->m=m;
        for (int i=0;i<=n;++i) {
            for (int j=0;j<=m;++j) {
                mat[i][j]=0;
            }
        }
    }
    int* operator [] (signed i) {
        return mat[i];
    }
    friend Matrix operator * (Matrix a,Matrix b) {
        int n,m,p;
        n=a.n,m=a.m,p=b.m;
        Matrix mat(n,p);
        for (int i=1;i<=n;++i) {
            for (int j=1;j<=p;++j) {
                for (int k=1;k<=m;++k) {
                    mat[i][j]+=a[i][k]*b[k][j];
                    mat[i][j]%=mod;
                }
            }
        }
        return mat;
    }
};

Matrix qpow(Matrix base,int ts) {
    Matrix ans(n,n);
    for (int i=1;i<=n;++i) {
        for (int j=1;j<=n;++j) {
            if (i==j) ans[i][j]=1;
        }
    }
    while (ts) {
        if (ts&1) ans=ans*base;
        base=base*base;
        ts>>=1;
    }
    return ans;
}

signed main() {
    while (~scanf("%lld %lld",&n,&m)) {
        n+=2;
        Matrix a(1,n);
        a[1][1]=3;
        a[1][2]=23;
        for (int i=3;i<=n;++i) {
            scanf("%lld",&a[1][i]);
        }
        Matrix b(n,n);
        for (int i=1;i<=n;++i) {
            int val;
            if (i==2) val=10;
            else val=1;
            for (int j=i;j<=n;++j) {
                b[i][j]=val;
            }
        }
        b=qpow(b,m);
        a=a*b;
        printf("%lld\n",a[1][n]);
    }
    return 0;
}
```

---

## 作者：Zouhaobin1024 (赞：1)

# 矩阵加速递推

[题目传送门](https://www.luogu.com.cn/problem/P10503)

## 思路分析
看到递推，看到 $n \le 10^9$，~~自信地~~认为是矩阵快速幂。

由于 $a_{0,1}, a_{0,2} \dots$ 是有规律的，考虑 $O(\log n)$ 做法。

# 前置芝士

有关矩阵快速幂，具体的可以到[这里](https://oi-wiki.org/math/linear-algebra/matrix/)找到资料，在此只说一些重点内容。

OI-Wiki中引入部分提到，形如
$$
\begin{cases}
a_{1,1}x_1 + a_{1,2}x_2 + \cdots + a_{1,n}x_n = b_1 \\
a_{2,1}x_1 + a_{2,2}x_2 + \cdots + a_{2,n}x_n = b_2 \\
\cdots \\
a_{m,1}x_1 + a_{m,2}x_2 + \cdots + a_{m,n}x_n = b_m 
\end{cases}
$$
的方程组，可以写成如下的矩阵乘法形式：
$$
\begin{bmatrix}
a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\ 
a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\ 
\vdots & \vdots & \ddots & \vdots\\
a_{m,1} & a_{m,2} & \cdots & a_{m,n}
\end{bmatrix}
\times
\begin{bmatrix}
x_1\\
x_2\\
\vdots\\
x_n\\
\end{bmatrix}
=
\begin{bmatrix}
b_1\\
b_2\\
\vdots\\
b_m\\
\end{bmatrix}
$$
本篇题解将采用这种思路来解题。

## STEP 1：列出方程

根据题意，易得：
$$
a_{i,j} = a_{i,j-1} + a_{i-1,j}
$$
进一步拆解，得：
$$
\begin{aligned}
  a_{i,j} &= a_{i,j-1} + a_{i-1,j-1} + a_{i-2,j} \\
      &= a_{i,j-1} + a_{i-1,j-1} + a_{i-2,j-1} + a_{i-3,j}\\
      &= a_{i,j-1} + a_{i-1,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + a_{0,j}      
\end{aligned}
$$
## STEP 2：列出矩阵

在递推过程中，需要使用到的量有：$a_{i,j-1} , a_{i-1,j-1} , \dots , a_{2,j-1} , a_{1,j-1} , a_{0,j} $

列出方程组：
$$
\begin{cases}
  a_{i,j-1} + a_{i-1,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + a_{0,j} = a_{i,j}\\
  a_{i-1,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + a_{0,j}  =  a_{i-1,j} \\
  a_{i-2,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + a_{0,j}  =  a_{i-2,j} \\
  \cdots \\
  a_{1,j-1} + a_{0,j}  =  a_{1,j} \\
  10 \times a_{0,j} + 3 = a_{0,j+1}
\end{cases}
$$
其中，最后一条式子出现常数，因此对 $a_{0,j}$ 进行拆分，得：
$$
a_{0,j} = a_{0,j-1} \times 10 + 3
$$
即：
$$
\begin{cases}
  a_{i,j-1} + a_{i-1,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + 10 \times a_{0,j-1} + 3 \times 1 = a_{i,j}\\
  a_{i-1,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + 10 \times a_{0,j-1} + 3 \times 1  =  a_{i-1,j} \\
  a_{i-2,j-1} + \cdots + a_{2,j-1} + a_{1,j-1} + 10 \times a_{0,j-1} + 3 \times 1  =  a_{i-2,j} \\
  \cdots \\
  a_{1,j-1} + 10 \times a_{0,j-1} + 3 \times 1  =  a_{1,j} \\
  10 \times a_{0,j-1} + 3 \times 1 = a_{0,j+1}\\
  3 \times 1 = 3 \times 1
\end{cases}
$$
写成 $(n+2) \times (n+2)$ 的矩阵形式，即：
$$
\begin{bmatrix}
1 & 1 & 1 & \cdots & 1 & 10 & 1 \\ 
0 & 1 & 1 & \cdots & 1 & 10 & 1 \\
0 & 0 & 1 & \cdots & 1 & 10 & 1 \\
\vdots & \cdots & \cdots & \ddots & \vdots & \vdots & \vdots \\
0 & 0 &0 & \cdots & 1 & 10 & 1 \\
0 & 0 &0 & \cdots & 0 & 10 & 1 \\
0 & 0 &0 & \cdots & 0 & 0 & 1
\end{bmatrix}
\times 
\begin{bmatrix}
a_{i,j-1} \\ 
a_{i-1,j-1} \\
a_{i-2,j-1} \\
\vdots  \\
a_{1,j-1} \\
a_{0,j-1} \\
3
\end{bmatrix}
=
\begin{bmatrix}
a_{i,j} \\ 
a_{i-1,j} \\
a_{i-2,j} \\
\vdots  \\
a_{1,j} \\
a_{0,j+1} \\
3
\end{bmatrix}
$$
当 $j = 1$ 时，初始矩阵为：
$$
\begin{bmatrix}
a_{n,0} \\ 
a_{n-1,0} \\
a_{n-2,0} \\
\vdots  \\
a_{1,0} \\
23 \\
3
\end{bmatrix}
$$

## STEP 3：递推求解

结果矩阵应为转移矩阵的 $m$ 次方乘上初始矩阵。

此时，答案应该是计算结果矩阵的第 $1$ 行第 $1$ 列的数值。

# AC code：

```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
int mod = 1e7+7;
struct mat
{
	int hang,lie;
	int arr[15][15];
	mat(int x=0, int y=0, bool one=0)
	{
		hang = x, lie = y;
		memset(arr,0,sizeof(arr));
		if(one)
			for(int i = 1; i <= hang; i++)
				arr[i][i] = 1;
	}
	auto operator[](int x)
	{
		return arr[x];
	}
};
mat operator*(mat a, mat b)
{
	mat res(a.hang,b.lie);
	int t;
	for(int i = 1; i <= a.hang; i++)
	{
		for(int j = 1; j <= b.lie; j++)
		{
			for(int k = 1; k <= a.lie; k++)
			{
				res[i][j] += a[i][k] * b[k][j] % mod;
				res[i][j] %= mod;
			}
		}
	}
	return res;
}
mat qpow(mat x, int k)
{
	mat ans(x.hang,x.lie,1);
	while(k)
	{
		if(k % 2)
			ans = ans * x;
		k /= 2;
		x = x * x;
	}
	return ans;
}
signed main()
{
	int n,m,i,j;
	mat f,p,res;
	while(cin >> n >> m)
	{
		f = mat(n+2,n+2);
		p = mat(n+2,1);
		for(i = 1; i <= n; i++)
			cin >> p[n - i + 1][1];
		p[n+1][1] = 23;
		p[n+2][1] = 3;
		for(i = 1; i <= n; i++)
			for(j = i; j <= n; j++)
				f[i][j] = 1;
		for(i = 1; i <= n+1; i++)
			f[i][n+1] = 10;
		for(i = 1; i <= n+2; i++)
			f[i][n+2] = 1;
		res = qpow(f,m) * p;
		cout << res[1][1] << "\n";
	}
	return 0;
 }

```

[AC记录](https://www.luogu.com.cn/record/225702526)

---

## 作者：JustPureH2O (赞：1)

[更好的阅读体验](https://justpureh2o.cn/articles/23333)

题目地址：[P10503](https://www.luogu.com.cn/problem/P10503)

> 假设我们有一个称为 233 矩阵。在第一行，它可能是 233、2333、23333...（表示 $a _ {0,1} = 233$，$a_{0,2} = 2333$，$a_{0,3} = 23333$...）。此外，在 233 矩阵中，我们有 $a_{i,j} = a_{i-1,j} +a_{i,j-1}( i,j \neq 0)$。现在已知 $a_{1,0},a_{2,0},\dots,a_{n,0}$，你能告诉我 233 矩阵中的 $a_{n,m}$ 吗？
>
> $n\leq10,m\leq10^9$

发现 $n$ 很小、$m$ 很大，于是选择使用 $\mathcal O(n^3\log m)$ 的矩阵快速幂做法。

假设矩阵一开始存储 $a$ 列的信息，它看起来是这样的：

$$
\begin{bmatrix}
a_{1,0}&a_{2,0}&a_{3,0}&\dots&a_{n,0}
\end{bmatrix}
$$

由于涉及到 $233$ 的计算，我们需要同时递推 $233$ 相关项，显然有 $2333=233\times10+3$，出现了常数，连同 $233$ 一起，初始矩阵就应该是如下的样子：

$$
\begin{bmatrix}
1&23&a_{1,0}&a_{2,0}&\dots&a_{n,0}
\end{bmatrix}
$$

然后可以发现：

$$
\left\{
\begin{matrix}
a_{1,1}=10\times23+3+a_{1,0} & &
\\a_{2,1}=10\times23+3+a_{1,0}+a_{2,0}& &
\\\vdots& &
\\a_{n,1}=10\times23+3+\sum\limits_{i=1}^{n}a_{i,0}& &
\end{matrix}
\right.
$$

得出 $(n+2)\times(n+2)$ 的转移矩阵：

$$
\begin{bmatrix}
1&3&3&3&\dots&3
\\0&10&10&10&\dots&10
\\0&0&1&1&\dots&1
\\0&0&0&1&\dots&1
\\0&0&0&0&\dots&1
\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots
\\0&0&0&0&\dots&1
\end{bmatrix}
$$

然后让初始矩阵乘以转移矩阵的 $m$ 次幂即可。

```cpp
#include <bits/stdc++.h>
#define N 15
#define MOD 10000007
using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

int n, m;
struct Matrix {
    ll mat[N][N]{};

    Matrix() {
        memset(mat, 0, sizeof mat);
    }

    void I() {
        for (int i = 1; i <= n + 2; i++) mat[i][i] = 1;
    }
};

Matrix operator*(const Matrix &l, const Matrix &r) {
    Matrix res;
    for (int i = 1; i <= n + 2; i++) {
        for (int j = 1; j <= n + 2; j++) {
            for (int k = 1; k <= n + 2; k++) {
                res.mat[i][j] = (res.mat[i][j] + l.mat[i][k] % MOD * r.mat[k][j] % MOD) % MOD;
            }
        }
    }
    return res;
}

Matrix qpow(Matrix a, ll b) {
    Matrix res;
    res.I();
    while (b) {
        if (b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

void print(Matrix m) {
    for (int i = 1; i <= n + 2; i++) {
        for (int j = 1; j <= n + 2; j++) {
            cout << setw(5) << m.mat[i][j] << ' ';
        }
        cout << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    while (cin >> n >> m) {
        Matrix A, M;
        A.mat[1][1] = 1, A.mat[1][2] = 23;
        for (int i = 1; i <= n; i++) {
            int x;
            cin >> x;
            A.mat[1][i + 2] = x;
        }
        for (int i = 1; i <= n + 2; i++) {
            for (int j = i; j <= n + 2; j++) {
                M.mat[i][j] = 1;
            }
        }
        for (int i = 2; i <= n + 2; i++) M.mat[1][i] = 3, M.mat[2][i] = 10;
        A = A * qpow(M, m);
        cout << A.mat[1][n + 2] % MOD << endl;
    }
    return 0;
}
```

$\texttt{The End}$

---

## 作者：Sorato_ (赞：1)

# P10503 233 Matrix

## 题目大意

给定一个矩阵 $A$，其中，$A_{0,1}=233,A_{0,2}=2333,\dots$，且对于 $i,j\neq0$，$A_{i,j}=A_{i-1,j}+A_{i,j-1}$。现给定 $A_{i,0}(1\leq i\leq n)$，求 $A_{n,m}$。

## Solve

令 $f_i(x,y)$ 表示第 $x$ 行前 $y$ 列的 $i$ 阶前缀和。那么有：
![](https://cdn.luogu.com.cn/upload/image_hosting/nxjct4af.png)

以此类推，可得 $f_i(x,y)=kA_{x,0}+f_{i+1}(x-1,y)$，其中 $k$ 为待定系数。

所以，$A_{n,m}=A_{n,0}+f_1(n-1,m)=A_{n,0}+k_1A_{n-1,0}+f_2(n-2,m)=\dots=\sum\limits_{i=1}^nk_iA_{i,0}+f_n(0,m)$。

我们先去求 $f_n(0,m)$，再去考虑 $k$。

考虑构造矩阵 $O,B$。
$$
O=
\begin{bmatrix}
f_n(0,i)&\cdots&f_1(0,i)&A_{0,i}&3
\end{bmatrix}\\
B=
\begin{bmatrix}
1&\cdots&0&0&0&0&0\\
\vdots&\ddots&\vdots&\vdots&\vdots&\vdots&\vdots\\
1&\cdots&1&0&0&0&0\\
1&\cdots&1&1&0&0&0\\
1&\cdots&1&1&1&0&0\\
10&\cdots&10&10&10&10&0\\
1&\cdots&1&1&1&1&1
\end{bmatrix}
$$
那么：
![](https://cdn.luogu.com.cn/upload/image_hosting/gjx3xpd8.png)
故我们只需要求 $O\times B^{n-1}$，$f_n(0,m)$ 即为其首项。矩阵快速幂之。

接下来考虑 $k$。

设 $A_{i,0}=a$，那么它对自己右下方的元素的影响如下：
$$
\begin{bmatrix}
a&a&a&a&a&\cdots\\
A_{i+1,0}&a&2a&3a&4a&\cdots\\
A_{i+2,0}&a&3a&6a&10a&\cdots\\
A_{i+3,0}&a&4a&10a&20a&\cdots\\
\vdots&\vdots&\vdots&\vdots&\vdots&\ddots
\end{bmatrix}
$$
是这样一个类似杨辉三角的东西，所以对 $A_{n,m}$ 的影响即为 ${n-i+m-1\choose m-1}\times a$。

我们从大到小枚举 $i$，则 ${n-(i-1)+m-1\choose m-1}={n-i+m-1\choose m-1}\times{(m+n-i)\over(n-i+1)}$。

有除法，而且本题的模数 $1e7+7$ 不是质数，不可以用费马小，所以扩欧求解 $(n-i+1)\times x\equiv1\pmod{1e7+7}$，则 ${n-(i-1)+m-1\choose m-1}={n-i+m-1\choose m-1}\times(m+n-i)\times x$。

## Code

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	short f=1;
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')	{if(c=='-')	f=-1;c=getchar();}
	while(c>='0'&&c<='9')	x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x*f;
}
const int N=15;
int sz,m,MOD=10000007,a[15],t,n;
struct mat {//封装模板
	int a[N][N];
	
	mat() { memset(a, 0, sizeof a); }
	
	mat operator-(const mat& T) const {
		mat res;
		for (int i = 0; i < sz; ++i)
			for (int j = 0; j < sz; ++j) {
				res.a[i][j] = (a[i][j] - T.a[i][j]) % MOD;
			}
		return res;
	}
	
	mat operator+(const mat& T) const {
		mat res;
		for (int i = 0; i < sz; ++i)
			for (int j = 0; j < sz; ++j) {
				res.a[i][j] = (a[i][j] + T.a[i][j]) % MOD;
			}
		return res;
	}
	
	mat operator*(const mat& T) const {
		mat res;
		int r;
		for (int i = 0; i < sz; ++i)
			for (int k = 0; k < sz; ++k) {
				r = a[i][k];
				for (int j = 0; j < sz; ++j)
					res.a[i][j] += T.a[k][j] * r, res.a[i][j] %= MOD;
			}
		return res;
	}
	
	mat operator^(int x) const {
		mat res, bas;
		for (int i = 0; i < sz; ++i) res.a[i][i] = 1;
		for (int i = 0; i < sz; ++i)
			for (int j = 0; j < sz; ++j) bas.a[i][j] = a[i][j] % MOD;
		while (x) {
			if (x & 1) res = res * bas;
			bas = bas * bas;
			x >>= 1;
		}
		return res;
	}
}b,ori;
inline void print()
{
	puts("\nA:");
	for(int i=0;i<sz;i=-~i)	printf("%lld ",ori.a[0][i]);
	puts("\nB:");
	for(int i=0;i<sz;i=-~i,putchar('\n'))
		for(int j=0;j<sz;j=-~j)
			printf("%lld ",b.a[i][j]);
	putchar('\n');
}
int x,y;
int exgcd(int a,int b,int &x,int &y)
{
	if(!b)	return x=1,y=0,a;
	int gcd=exgcd(b,a%b,x,y);
	swap(x,y);y-=x*(a/b);
	return gcd;
}
int calc(int a,int b,int m)
{
	b=(b%m+m)%m;
	int d=exgcd(a,m,x,y);m/=d;
	if(b%d)	{puts("-1");exit(0);}
	x=(x*b/d%m+m)%m;
	return x;
}
signed main()
{
	while(~scanf("%d%lld",&n,&m))
	{
		for(int i=1;i<=n;i=-~i)	a[i]=read();
		sz=n+2;
		for(int i=0;i<=n;i=-~i)	b.a[n][i]=10;
		for(int i=0;i<n;i=-~i)
			for(int j=0;j<=i;j=-~j)
				b.a[i][j]=1;
		for(int i=0;i<sz;i=-~i)	b.a[sz-1][i]=1;
		for(int i=0;i<=n;i=-~i)	ori.a[0][i]=233;
		ori.a[0][n+1]=3;
		b=b^(m-1);
		ori=ori*b;
		int c=1,ans=ori.a[0][0];
		for(int i=n;i;i--)
			ans=(ans+c*a[i]%MOD)%MOD,
			c=c*(m+n-i)%MOD*calc(n-i+1,1,MOD)%MOD;
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Milthm (赞：1)

纪念一下第一道自己推出来的矩阵快速幂题。


这题很显然，$n$ 这么小，$m$ 这么大，一看就是矩阵加速。

先把信息放进一个矩阵：$\begin{bmatrix}a_{0,m}&a_{1,m}&\cdots&a_{n,m} \end{bmatrix}$。

那如何从 $\begin{bmatrix}a_{0,m}&a_{1,m}&\cdots&a_{n,m} \end{bmatrix}$ 推到 $\begin{bmatrix}a_{0,m+1}&a_{1,m+1}&\cdots&a_{n,m+1} \end{bmatrix}$ 呢？刚上来就发现一个问题，就是 $a_{0,m+1}$ 需要用到 $a_{0,m}$ 乘 $10$ 加 $3$ 才能得到，所以我们的状态应该再设一个 $3$，就是这样：

$$\begin{bmatrix}a_{0,m}&a_{1,m}&\cdots&a_{n,m}&3 \end{bmatrix}$$

~~看上去十分鬼畜。~~

有了状态，转移就不难了，推一下就可以得到递推式是：

$$\begin{bmatrix}a_{0,m}&a_{1,m}&\cdots&a_{n,m}&3 \end{bmatrix}\times \begin{bmatrix}10&10&10&\cdots&10&0

\\0&1&1&\cdots&1&0

\\ 0 &0&1&\cdots&1&0

\\\vdots&\vdots&\vdots&\ddots&\vdots&\vdots

\\0&0&0&\cdots&1&0

\\1&1&1&\cdots&1&1\end{bmatrix}=\begin{bmatrix}a_{0,m+1}&a_{1,m+1}&\cdots&a_{n,m+1}&3 \end{bmatrix}$$


矩阵快速幂即可。


### AC code

有一点需要注意的，我们初始需要把 $a_{0,0}$ 设为 $23$，这样才能顺利的往下转移。

```cpp
#include<bits/stdc++.h>
#define N 15
#define int long long
using namespace std;
int n,m,b[N];
const int mod=1e7+7;
struct ma{
	int x[N][N];
	void clear(){
		memset(x,0,sizeof(x));
	}
}ans,A; 
ma operator*(ma a,ma b){
	ma c;c.clear();
	for(int i=1;i<=n+2;++i){
		for(int j=1;j<=n+2;++j){
			for(int k=1;k<=n+2;++k){
				(c.x[i][j]+=a.x[i][k]*b.x[k][j])%=mod;
			}
		}
	} 
	return c;
}
signed main(){
	while(cin>>n>>m){
		ans.clear();A.clear();
		for(int i=1;i<=n;++i)cin>>b[i];
		if(m==0){
			cout<<b[n]<<'\n';continue;
		}
		for(int i=1;i<=n+1;++i)A.x[1][i]=10;
		for(int i=2;i<=n+1;++i){
			for(int j=i;j<=n+1;++j)A.x[i][j]=1;
		}
		for(int i=1;i<=n+2;++i)A.x[n+2][i]=1;
		ans.x[1][1]=23;ans.x[1][n+2]=3;
		for(int i=2;i<=n+1;++i)ans.x[1][i]=b[i-1];
		while(m){
			if(m&1)ans=ans*A;
			A=A*A;m>>=1;
		}
		cout<<ans.x[1][n+1]<<'\n';
	}
	return 0;
}

```

~~真的只有绿吗。~~

---

## 作者：Little_duck_GGG (赞：0)

### 题目意思
有一个矩阵，已知此矩阵 $a_{0,1} = 233$，$a_{0,2} = 2333$，$a_{0,3} = 23333$，如此类推。又知道了 $a_{1,0}$，$a_{2,0}$ 和 $a_{3,0}$，如此类推直到 $a_{n,0}$。且满足一条规律，$a_{i,j} = a_{i-1,j} + a_{i,j-1}$。求 $a_{n,m}$。
### 题目思路
看一眼数据范围 $m$ 特别大，$n$ 特别小。

一眼矩阵加速。

我们可以先定义一个初始矩阵一存储数组的信息 $\begin{bmatrix} a_{1,0} & a_{2,0} & a_{3,0} & ... & a_{n,0} \end{bmatrix}$ 。

但是这样还不够，我们观察到 $233,2333,23333$，这个数列的 $f_i = f_{i-1} \times 10 + 3$。所以我们还得再这个初始矩阵中加入 $3$ 和 $23$ 这两个参数。

好了，那么递推函数如何构造呢，也就是我们如何让 $\begin{bmatrix} a_{0,m} & a_{1,m} & a_{2,m} & ... & a_{n,m}\end{bmatrix}$ 变成，$\begin{bmatrix} a_{0,m+1} & a_{1,m+1} & a_{2,m+1} & ... & a_{n,m}\end{bmatrix}$ 呢。

嗯，我们知道 $a_{i,j} = a_{i-1,j} + a_{i,j-1}$，也就是说对于 $a_{i,m+1}$ 来说，其等于**上面的加左边**的。

先考虑左边的答案，很简单，就是 $a_{i,m}$。

再考虑上面的答案，为 $a_{i-1,m+1}$，也就是 $a_{i-1,m} + a_{i-2,m+1}$，对于 $a_{i-2,m+1}$，我们又可以将其分解成两项相加 $a_{i-2,m} + a_{i-3,m+1}$，以此类推，直到 $a_{1,m+1}$。

具体的我们可以画一个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/rsnk1dmk.png)

我们要求的 $x$ 等于 $y_1 + y_2$，$y_1$就是 $a_{i,m}$，而 $y_2$又可以分解成 $a + b$，而 $a$ 我们可以求，就是 $a_{i-1,m}$，$b$ 也可以，就是 $a_{0,m+1}$，也就是 $a_{0,m} \times 10 + 3$。

这里笔者想了好久才想出来，所以尽量用通俗易懂的方式表达。

所以 $a_{i,m+1} = a_{0,m} \times 10 + 3 + \sum_{j = 1}^{i} \ a_{j,m}$，差不多就是这样了。

根据转移方程，我们就可以很容易的构造出矩阵。

该矩阵为 $\begin{bmatrix} 10 & 10 & 10 & ... & 10 & 0\\ 0 & 1 & 1 & ... & 1 & 0\\0 & 0 & 1 & ... & 1 & 0\\\vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\1 & 1 & 1 & ... & 1 & 1\end{bmatrix}$。

初始矩阵上文说到为 $\begin{bmatrix} 23 & 3 & a_{0,1} & a_{0,2} & ... & a_{0,n}\end{bmatrix}$。

最后就用矩阵快速幂求就可以了。

注意以下几点。
*    快速幂需要进行 $m$ 次。
*    注意取模。
*    注意初始化。

### 最后放代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mm;
int c[1005000];
struct data
{
	long long a[105][105];
}r1,r2;
int mod=10000007,pp,qq;
void init()//这里进行矩阵的构造 
{
	for(int i=1;i<=n;i++) r1.a[0][i]=c[i];
	r1.a[0][0]=23;
	r1.a[0][n+1]=3;
	for(int i=0;i<=n;i++) r2.a[0][i]=10;
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++) r2.a[i][j]=1;
	}
	for(int i=0;i<=n+1;i++) r2.a[n+1][i]=1; 
} 
void init_2()//初始化 
{
	for(int i=0;i<=n+1;i++) r1.a[i][0]=0; 
	for(int i=0;i<=n+1;i++)
	{
		for(int j=0;j<=n+1;j++) r2.a[i][j]=0;
	}
} 
data cf(data q,data p)//矩阵乘法 
{
	data s;
	for(int i=0;i<=n+1;i++)
	{
		for(int j=0;j<=n+1;j++) s.a[i][j]=0;
	}
	for(int i=0;i<=n+1;i++)
	{
		for(int j=0;j<=n+1;j++)
		{
			for(int k=0;k<=n+1;k++)
			{
				s.a[i][j]+=q.a[i][k]*p.a[k][j];
				s.a[i][j]%=mod;
			}
		}
	}	
	return s;
}
data fun(data ok,int m)//快速幂 
{
	data ans=ok;
	data g=r1;
	while(m!=0)
    {
    	if(m%2==1) g=cf(g,ans);
    	ans=cf(ans,ans);
		m/=2;
    }
    return g;
} 
int main()
{
    while(cin>>n>>mm)
    {
    	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
    	init();
    	data temp=fun(r2,mm);
    	cout<<temp.a[0][n]<<endl;//输出 
    	init_2();
	}
    return 0;
}
```
以上就是此题的题解。

---

## 作者：bianshiyang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10503)

翻了半天题解也没我这种做法，准确地讲，~~题解区里貌似只存在一种做法~~。

# 分析
我们直接观察 $a_{i,j}=a_{i,j-1}+a_{i-1,j}$ 这个式子，发现如果这是在一维上进行的，那么已经做完了，所以考虑把这个式子拍扁到一维上去做。

具体地，我们先创造一个 $1\times 2$ 的向量 $\begin{bmatrix}a_{i+1,j-1}&a_{i,j}\end{bmatrix}$，其中 $a_{i,j}$ 可以从上一个向量 $\begin{bmatrix}a_{i,j-1}&a_{i-1,j}\end{bmatrix}$ 转移。但是 $a_{i+1,j-1}=a_{i+1,j-2}+a_{i,j-1}$，而 $a_{i+1,j-2}$ 没有出现，所以我们需要继续扩展这个向量变成 $1\times 3$ 的 $\begin{bmatrix}a_{i+2,j-2}&a_{i+1,j-1}&a_{i,j}\end{bmatrix}$。发现 $a_{i,j}$ 和 $a_{i+1,j-1}$ 都可以从 $\begin{bmatrix}a_{i+1,j-2}&a_{i,j-1}&a_{i-1,j}\end{bmatrix}$ 找到转移方式，但是 $a_{i+2,j-2}$ 仍无法转移。所以可以持续这样的扩展向量操作直到边界，最终扩展出的向量为：

$$\begin{bmatrix}a_{n,i+j-n}&a_{n-1,i+j-n+1}&\cdots&a_{i+1,j-1}&a_{i,j}\end{bmatrix}$$

观察构造出来的向量，呈现一个斜对角线的形式，转移一次相当于是把斜对角线向右平移一次，那么我们只需要让第一个元素落在 $a_{n,m}$ 即可求出答案。于是我们就可以钦定 $i=0$，这样的对角线就是一个满的对角线（这不会影响答案，毕竟我们只关心最后转移完毕的向量的第一个元素），且为了配合上第 $0$ 行的转移规则，还需要在末尾加上一个额外的 $1$ 便于转移。最终构造出来的初始向量为 $1\times(n+2)$ 的向量：

$$\begin{bmatrix}a_{n,0}&a_{n-1,1}&\cdots&a_{1,n-1}&a_{0,n}&1\end{bmatrix}$$

根据每次向右移动这个对角线的规则，可以直接构造出这个 $(n+2)\times(n+2)$ 的转移矩阵：

$$\begin{bmatrix}
1&0&0&\cdots&0&0&0 \\
1&1&0&\cdots&0&0&0\\
0&1&1&\cdots&0&0&0\\
0&0&1&\cdots&0&0&0\\
\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
0&0&0&\cdots&1&10&0\\
0&0&0&\cdots&0&3&1\\
\end{bmatrix}$$

关于平移的说法，其实就是把每一个位置的 $j$ 都增加 $1$，例如初始行向量转移一次就变成了：

$$\begin{bmatrix}a_{n,1}&a_{n-1,2}&\cdots&a_{1,n}&a_{0,n+1}&1\end{bmatrix}$$

单组数据时间复杂度 $O(n^3\log m)$。

# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=15;
const int mo=1e7+7;
int n,m,a[N][N];

struct Matrix{
	int a[N][N],r,c;//r表示矩阵的行，c表示矩阵的列，这里的矩阵下标都是从1开始的
	void init(int x,int y){r=x,c=y;memset(a,0,sizeof(a));}
	void fil(int n)//单位矩阵
	{
		init(n,n);
		for(int i=1;i<=n;i++) a[i][i]=1;
	}
	friend Matrix operator*(Matrix x,Matrix y)
	{
		Matrix z;z.init(x.r,y.c);
		for(int i=1;i<=z.r;i++)
			for(int j=1;j<=z.c;j++)
				for(int k=1;k<=x.c;k++) z.a[i][j]=(z.a[i][j]+1ll*x.a[i][k]*y.a[k][j]%mo)%mo;
		return z;
	}
	friend Matrix operator^(Matrix x,int y)
	{
		Matrix z;z.fil(x.r);
		while(y)
		{
			if(y&1) z=z*x;
			x=x*x;
			y>>=1;
		}
		return z;
	}
}A,a0;//A是转移矩阵，a0是初始矩阵（行向量）

int main()
{
	a[0][1]=233;
	for(int i=2;i<N;i++) a[0][i]=(a[0][i-1]*10+3)%mo;
	while(scanf("%d%d",&n,&m)==2)
	{	
		for(int i=1;i<=n;i++) scanf("%d",&a[i][0]),a[i][0]%=mo;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				a[i][j]=(a[i-1][j]+a[i][j-1])%mo;//先暴力跑出n*n范围的a[i][j]
		A.init(n+2,n+2);a0.init(1,n+2);
		for(int j=n;j>=0;j--) a0.a[1][n-j+1]=a[j][n-j];//填充初始矩阵
		a0.a[1][n+2]=1;
		for(int j=1;j<=n;j++) A.a[j][j]=A.a[j+1][j]=1;
		A.a[n+1][n+1]=10,A.a[n+2][n+1]=3;A.a[n+2][n+2]=1;//填充单位矩阵
		printf("%d\n",(a0*(A^m)).a[1][1]);//取最终行向量的第1个元素
	}
	return 0;
}
```

---


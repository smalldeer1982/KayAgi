# [KOI 2025 #2] 存放箱子

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

小郑想要在仓库里存放箱子。总共有 $N$ 个箱子，编号从 1 到 $N$。第 $i$ ($1 \le i \le N$) 号箱子的大小为 $s_i$，收纳容量为 $c_i$。所有箱子的收纳容量都比其自身的大小要小，即满足 $c_i < s_i$。

小郑觉得仓库里的箱子太多、太杂乱，因此想把一些箱子装到另一些箱子里来存放。此时，必须满足以下条件：

*   一个箱子可以装入大小**不小于**其收纳容量的箱子。
*   已经装有其他箱子的箱子，也可以被装入另一个箱子中。
*   一个箱子**直接容纳**的箱子最多只能有一个。换句话说，一个箱子内最多可以直接放入一个其他的箱子，但允许这个被放入的箱子内部还装有别的箱子。

存放箱子的成本，等于没有被装在任何其他箱子里的箱子的数量。

例如，假设 $N = 4$，四个箱子的大小和收纳容量分别如下表所示。

| **编号** | **大小** | **收纳容量** |
| :---: | :---: | :---: |
|   1   |   6   |   4   |
|   2   |   5   |   1   |
|   3   |   9   |   8   |
|   4   |   2   |   1   |

此时，如下图所示，如果将 4 号箱子放入 1 号箱子，再将 1 号箱子放入 3 号箱子，那么没有被装在其他箱子里的箱子就有 2 个 (3 号箱子和 2 号箱子)，因此存放箱子的成本为 2。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxmrnti7.png)

但是，如下图所示，如果将 2 号箱子和 4 号箱子都放入 3 号箱子中，由于 3 号箱子内直接容纳了两个箱子，因此不满足条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/k8bcx8pi.png)

仓库里不必非要放下所有的箱子，所以小郑计划只保留编号较小的一部分箱子，并丢弃其余的。小郑目前还没有决定要使用多少个箱子。

请你帮助小郑，对于从 1 到 $N$ 的所有 $i$，编写一个程序来计算存放 $1, 2, \ldots, i$ 号箱子所需的最小成本。

## 说明/提示

### 限制条件

*   所有给定的数都是整数。
*   $2 \le N \le 2 \times 10^5$
*   $1 \le c_i < s_i \le 10^9$ ($1 \le i \le N$)

### 子任务

1.  (7 分) $N \le 6$。
2.  (12 分) 对于所有 $i$，$s_i = c_i + 1$。
3.  (26 分) $N \le 1000$。
4.  (17 分) 对于所有 $i$，$s_i \le 100$。
5.  (38 分) 无额外限制条件。

## 样例 #1

### 输入

```
4
6 4
5 1
9 8
2 1```

### 输出

```
1
2
2
2```

## 样例 #2

### 输入

```
6
3 2
5 4
3 2
4 3
4 3
3 2```

### 输出

```
1
1
2
2
2
3```

## 样例 #3

### 输入

```
8
13 6
7 5
9 4
11 10
4 2
15 5
16 7
8 3```

### 输出

```
1
2
3
3
3
4
4
5```

# 题解

## 作者：_JoeyJ_ (赞：2)

没能想到 Dilworth 定理，感性思考了一个做法，讲的不好的地方还请多多包含。

把所有箱子先按照存放容量 $c_i$ 排序，那么箱子 $i$ 可以放入的箱子 $j$ 就是一个后缀，令这个后缀为 $[d_i,n]$。

从后向前考虑，问题转化为：

- 有若干个物品，第 $i$ 个物品在 $d_i$ 之前没买就消失。
- 每天只能购买一个物品。
- 问最少要抛弃多少个物品。

这是一个经典的贪心问题，解决方式是优先购买临期商品。

不妨换个思路，先存着购买额度，等到了某个商品的 ddl 在时间穿梭回去买它，这和上面的贪心方式是等价的。

于是考虑维护 $c$ 上每个时刻的购买额度 $t_i$，共有两种事件：

- $i$ 时刻增加 $1$ 的额度：由于要存额度，并且额度不会过期。$\forall i\in[1,i],~t_i\leftarrow t_i+1$。

- $i$ 时刻某个物品到达 ddl：

  - 该物品买到了：额度用掉一个，并且永久有效。$\forall i\in[1,i],~t_i\leftarrow t_i-1$。
  - 该物品未买到：此时额度 $\leq 0$，仍强制消耗一个额度，并定义整个过程抛弃的物品数为 $\max(-\min\limits_{i=1}^{n} t_i,0)$。因为下次发生抛弃事件必然先消耗了后面增加的所有额度，故可以保证正确性。$\forall i\in[1,i],~t_i\leftarrow t_i-1$。

  可以合并为 $\forall i\in[1,i],~t_i\leftarrow t_i-1$。

于是需要维护的操作就是前缀 $\pm 1$，查全局最小值。存放 $[1,i]$ 的箱子所需的成本则可以通过按下标从小到大加入实现，时间复杂度 $O(n\log n)$。

可能和其他做法是等价的？

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e5;
const int inf=1e9+7;

struct Node{
	int l,r,dat,tag;
}tr[N<<2];
#define l(x) tr[x].l
#define r(x) tr[x].r
#define dat(x) tr[x].dat
#define tag(x) tr[x].tag

inline void PushUp(int x){dat(x)=min(dat(x<<1),dat(x<<1|1));}
inline void Push(int x,int k){tag(x)+=k,dat(x)+=k;}
inline void PushDown(int x){
	if(!tag(x)) return ;
	Push(x<<1,tag(x));
	Push(x<<1|1,tag(x));
	tag(x)=0;
}
inline void Build(int x,int l,int r){
	l(x)=l,r(x)=r;
	if(l(x)==r(x)) return ;
	int mid=l(x)+r(x)>>1;
	Build(x<<1,l,mid);
	Build(x<<1|1,mid+1,r);
	PushUp(x);
}
inline void Modify(int x,int l,int r,int k){
	if(l<=l(x)&&r(x)<=r) return Push(x,k);
	int mid=l(x)+r(x)>>1;
	PushDown(x);
	if(l<=mid) Modify(x<<1,l,r,k);
	if(r>mid) Modify(x<<1|1,l,r,k);
	PushUp(x);
}

int a[N],b[N],n,tot;
vector<int> val;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i];

	val.push_back(0);
	val.push_back(inf);
	for(int i=1;i<=n;i++) val.push_back(b[i]);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	tot=val.size()-1;

	Build(1,1,tot);
	for(int i=1;i<=n;i++){
		int bp=lower_bound(val.begin(),val.end(),b[i])-val.begin();
		Modify(1,1,bp,1);
		int ap=lower_bound(val.begin(),val.end(),a[i])-val.begin();
		Modify(1,1,ap,-1);
		cout<<-dat(1)<<endl;
	}

	return 0;
}
```

---

## 作者：Petit_Souris (赞：2)

最小链覆盖转成最长反链。

问题相当于选出一些盒子，两两无法嵌套。

这意味着我们只需要关注最大的 $b_i$。设 $\max b_i = v$，那么只有 $a_i > v$ 的 $i$ 才可以被选上。

因此答案为 $\max\limits_{v} \#[a_i > v \land b_i \le v]$。

离散化后实时维护所有 $v$ 的答案，相当于对 $[b_i, a_i - 1]$ 区间加一，查询全局 $\max$。线段树即可，时间复杂度 $\mathcal O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using ll = long long;
using ld = long double;
using ull = unsigned long long;
using namespace std;
template <class T>
using Ve = vector<T>;
#define ALL(v) (v).begin(), (v).end()
#define pii pair<ll, ll>
#define rep(i, a, b) for(ll i = (a); i <= (b); ++i)
#define per(i, a, b) for(ll i = (a); i >= (b); --i)
#define pb push_back
bool Mbe;
ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
void write(ll x) {
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
const ll N = 4e5 + 9;
ll n, a[N], b[N], tmp[N], tot, tr[N << 2], tag[N << 2];
void Pushtag(ll x, ll k) {
    tr[x] += k, tag[x] += k;
}
void Pushdown(ll x) {
    if(!tag[x]) return ;
    Pushtag(x << 1, tag[x]);
    Pushtag(x << 1 | 1, tag[x]);
    tag[x] = 0;
}
void Pushup(ll x) {
    tr[x] = max(tr[x << 1], tr[x << 1 | 1]);
}
void Upd(ll x, ll l, ll r, ll ql, ll qr, ll k) {
    if(ql <= l && r <= qr) return Pushtag(x, k), void();
    ll mid = (l + r) >> 1;
    Pushdown(x);
    if(ql <= mid) Upd(x << 1, l, mid, ql, qr, k);
    if(qr > mid) Upd(x << 1 | 1, mid + 1, r, ql, qr, k);
    Pushup(x);
}
bool Med;
int main() {
    cerr << fabs(&Med - &Mbe) / 1048576.0 << "MB\n";
    n = read();
    rep(i, 1, n) a[i] = read(), b[i] = read();
    rep(i, 1, n) tmp[++tot] = a[i], tmp[++tot] = b[i];
    sort(tmp + 1, tmp + tot + 1); tot = unique(tmp + 1, tmp + tot + 1) - tmp - 1;
    rep(i, 1, n) {
        a[i] = lower_bound(tmp + 1, tmp + tot + 1, a[i]) - tmp;
        b[i] = lower_bound(tmp + 1, tmp + tot + 1, b[i]) - tmp;
        Upd(1, 1, tot, b[i], a[i] - 1, 1);
        write(tr[1]), putchar('\n');
    }
    cerr << "\n" << clock() * 1.0 / CLOCKS_PER_SEC * 1000 << "ms\n";
    return 0;
}
```

---

## 作者：chen_zhe (赞：2)

### 子问题 1

在此子问题中，$N \le 6$，非常小。对于每个箱子，我们可以通过暴力穷举（Brute-force）的方式，尝试所有指定其所包含的其他箱子（或不包含任何箱子）的情况。根据实现方式的不同，时间复杂度可能为 $O(N^N)$ 或 $O(N!)$ 等。

### 子问题 2

在此子问题中，$s_i = c_i + 1$，即所有箱子的收纳容量都比其自身大小大 1。因此，如果两个箱子的大小相同，它们的收纳容量也相同。

当存在一个未被任何箱子包含的箱子 $a_1$ 直接包含另一个箱子 $a_2$，$a_2$ 又直接包含 $a_3$，...，$a_{k-1}$ 直接包含 $a_k$，而 $a_k$ 不包含其他任何箱子时，我们称箱子 $a_1, a_2, \dots, a_k$ 构成一个“箱子链”。显而易见，一个箱子链中存在的箱子，$s_i$ 的值必须各不相同。因此，问题的答案，即包含所有箱子所需的最少箱子链数量，必须大于等于对于任意 $v$，满足 $v=s_i$ 的 $i$ 的数量。我们定义这样的 $i$ 的数量为 $\text{cnt}_v$。

如前所述，答案必须不小于 $\max_{1 \le v} \text{cnt}_v$。因此，如果确实存在一个解，能够用正好这个数量的箱子链包含所有箱子，那么该解就是最优解。在子问题 2 的情况下，可以简单地证明这样的最优解是存在的。

根据子问题 2 的条件，当任意给定 $k$ 个箱子时，如果所有箱子都满足 $s_i = c_i + 1$ 且所有箱子的 $s_i$ 值都不同，那么总是可以用这些箱子构成一个箱子链。如果存在 $s_i$ 值相同的箱子，那么我们可以给 $s_i$ 值相同的 $\text{cnt}_{s_i}$ 个箱子任意赋予一个从 1 到 $\text{cnt}_{s_i}$ 的标签。现在，如果我们将标签相同的箱子归为一组，那么这些箱子的 $s_i$ 值都各不相同，因此每个组都可以构成一个箱子链。标签的最大值与 $\text{cnt}_v$ 的最大值相同，因此这样构造出的解是最优的。

现在需要做的事情，就只是在每次添加一个箱子时，维护 $\text{cnt}_v$ 的最大值。每当新增一个 $s_i$ 值时，可以通过 `std::map` 等数据结构来增加计数并进行管理。时间复杂度为 $O(N \log N)$。

### 子问题 3

当一个箱子 $a$ 直接包含另一个箱子 $b$ 时，我们定义存在一个序对 $(a, b)$ 的“包含关系”。如果将 $N$ 个箱子放入 $p$ 个箱子链中，这等同于形成了总共 $N-p$ 个包含关系。根据问题条件，能够形成包含关系 $(a,b)$ 的条件是 $s_b \le c_a$。

问题要求最小化箱子链的数量，但反向思考，这也可以解释为最大化包含关系数量的问题。因此，可以寻找在满足 $s_b \le c_a$ 条件下，最多能建立多少个包含关系。

我们对答案进行二分搜索（parametric search）。分析当有 $N$ 个“容器”（即箱子 $a$）时，是否能建立 $p$ 个包含关系。为此，需要考虑选择哪些 $s_b$ 值和 $c_a$ 值。贪心地想，使用最小的 $p$ 个 $s_b$ 值和最大的 $p$ 个 $c_a$ 值是最优的。将这些值配对的最优方法是：将 $p$ 个 $s_b$ 值升序排列，将 $p$ 个 $c_a$ 值也升序排列，然后按大小顺序进行匹配。如果所有的匹配都满足 $s_b \le c_a$，那就意味着可以建立 $p$ 个包含关系。

当有 $N$ 个“容器”时，利用上述方法可以在 $O(N \log N)$ 时间内求出 $p$ 的最大值，从而得出答案。因此，利用该方法可以以 $O(N^2 \log N)$ 的总时间复杂度解决此问题。

### 子问题 4

让我们用一种与子问题 3 不同的方式来处理。我们可以将每个箱子 $i$ 表示为数轴上的一个区间 $(c_i, s_i)$。此时，一个箱子链可以看作是一组互不相交的（即两两交集为空集的）区间。

通过尝试各种示例并寻找规律，可以发现，与子问题 2 类似，问题的答案等于数轴上某一点被区间包含的最大次数。也就是说，答案等于对于任意 $v$，满足 $v \in (c_i, s_i)$ 的 $i$ 的数量的最大值。我们先假设这个事实（\*）为真，并以此为基础解决问题。

我们维护一个长度为 100 的数组 $A$。当一个新的箱子 $(c_i, s_i)$ 加入时，我们将 $A_{c_i}, A_{c_i+1}, \dots, A_{s_i-1}$ 的值都加 1。处理完这个操作后，答案就是 $\max_i A_i$。因此，可以用 $O(N \max s_i)$ 的总时间复杂度解决此问题。

现在，我们来证明解法的核心（\*）。答案不小于 $\max_i A_i$ 是显而易见的。因为数轴上某个位置被至少 $\max_i A_i$ 个区间覆盖，这意味着这些区间所代表的箱子必须被包含在不同的箱子链中。现在，我们来证明可以用正好这个数量的箱子链包含所有箱子。

考虑以下贪心策略。将所有区间按起始点升序排列，若起始点相同，则按结束点升序排列。我们从左到右逐一查看区间，并重复将其放入合适的箱子链的过程。选择方法如下：

*   如果当前存在的箱子链中有可以放入当前区间的，就任选一个这样的箱子链，并将该区间放入。
*   如果当前存在的箱子链中没有可以放入当前区间的（即，对于当前区间 $(c_i, s_i)$，所有箱子链中最大的箱子的大小 $s_j$ 都满足 $s_j > c_i$），就创建一个只包含当前区间的新箱子链。

我们来证明，通过上述过程将箱子分配到箱子链中时，箱子链的总数不会超过 $\max_i A_i$。我们使用反证法。假设在处理某个箱子 $(c_i, s_i)$ 时，由于需要创建一个新的箱子链，使得箱子链的总数变成了 $\max_i A_i + 1$。这意味着，已存在的 $\max_i A_i$ 个箱子链，其最大的箱子的 $s_j$ 值都大于当前箱子的 $c_i$ 值。但考虑到箱子的排序顺序，这意味着在当前新处理的箱子的 $c_i$ 值处，有 $\max_i A_i + 1$ 个区间包含了 $c_i - \epsilon$ 这个点。这与 $A$ 的定义相矛盾。

因此，我们证明了通过上述贪心策略，可以构造出总数为 $\max_i A_i$ 的箱子链，从而证明了解法的正确性。

### 子问题 5

子问题 4 的解法可以通过使用线段树来轻松优化。利用线段树，问题可以转化为对区间 $[c_i, s_i - 1]$ 执行加 1 操作，并求全局最大值。这样，就可以在 $O(N \log N)$ 的时间复杂度内解决整个问题。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

struct segTree{
    int tree[1<<20], lazy[1<<20];

    void propagate(int i, int l, int r){
        tree[i] += lazy[i];
        if(l!=r){
            lazy[i*2] += lazy[i];
            lazy[i*2+1] += lazy[i];
        }
        lazy[i] = 0;
    }

    void update(int i, int l, int r, int s, int e, int v){
        propagate(i, l, r);
        if(r<s || e<l) return;
        if(s<=l && r<=e){
            lazy[i] = v;
            propagate(i, l, r);
            return;
        }
        int m = (l+r)>>1;
        update(i*2, l, m, s, e, v);
        update(i*2+1, m+1, r, s, e, v);
        tree[i] = max(tree[i*2], tree[i*2+1]);
    }

    int query(int i, int l, int r, int s, int e){
        propagate(i, l, r);
        if(r<s || e<l) return 0;
        if(s<=l && r<=e) return tree[i];
        int m = (l+r)>>1;
        return max(query(i*2, l, m, s, e), query(i*2+1, m+1, r, s, e));
    }
} tree;

int n;
int L[200005], R[200005];

int main(){
    scanf("%d", &n);
    for(int i=1; i<=n; i++){
        scanf("%d %d", &R[i], &L[i]);
    }
    vector<int> v;
    for(int i=1; i<=n; i++){
        v.push_back(L[i]);
        v.push_back(R[i]);
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());

    int k = (int)v.size();
    for(int i=1; i<=n; i++){
        L[i] = lower_bound(v.begin(), v.end(), L[i]) - v.begin();
        R[i] = lower_bound(v.begin(), v.end(), R[i]) - v.begin();

        tree.update(1, 0, k-1, L[i], R[i]-1, 1);
        printf("%d\n", tree.query(1, 0, k-1, 0, k-1));
    }
}
```

---


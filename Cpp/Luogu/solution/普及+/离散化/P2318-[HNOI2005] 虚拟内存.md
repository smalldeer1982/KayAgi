# [HNOI2005] 虚拟内存

## 题目描述

操作系统中一种重要的存储管理技术就是虚拟内存技术。操作系统中允许进程同时运行，也就是并行。每个进程都有其相对独立的数据块（进程运行的过程中将对其进行读写操作）。理想的情况下，这些数据块都应该存放在内存中，这样才能实现高效的读写操作。但事实上，内存的容量有限，每个进程只能把一部分数据放在内存中，为了解决这个矛盾，提出了虚拟内存技术。

虚拟内存技术的基本原理是：对进程而言，内存空间是无限大的，进程可以随意地读写数据，而对操作系统内部而言，利用外存来模拟扩充的内存空间，进程要求访问某个内存单元时，交由操作系统处理，操作系统首先在内存中查找该单元是否存在，如果存在，查找成功，否则转入外存查找（一定存在于外存中）。

就存储介质的物理性质而言，内存的访问速度相对于外存要快得多，因此对于每个进程来说操作系统应该把那些访问次数较多的数据存放在内存中，而把那些访问次数很少的数据放在外存中。如何选择内存中暂留的数据是一个很值得研究的问题，下面介绍一个内存管理中比较常用的算法：

内存中的数据以页为基本存储单位，进程的读写操作都针对页来进行。实际内存空间被分割成n页，虚拟内存空间的页数往往要多得多。某一时刻，进程需要访问虚存编号为P的页，该算法的执行步骤如下：

a.    首先在内存中查找，如果该页位于内存中，查找成功，转d，否则继续下面的操作；

b.    寻找内存中是否存在空页（即没有装载任何数据页的页面），若有，则从外存中读入要查找页，并将该页送至内存中的空页进行存储，然后转d，否则继续下面的操作；

c.    在内存中寻找一个访问次数最少的页面（如果存在多个页面的访问次数同时为最少，则选取最早读入数据进入内存的那个页面），从外存中读入要查找页，替换该页。

d.    结束

所谓访问次数是指从当前页面进入内存到该时刻被访问的次数，如果该页面以前进入过内存并被其它页面替换，那么前面的访问次数不应计入这个时刻的访问次数中。

你的任务是设计一个程序实现上述算法。

测试数据将会提供 $m$ 条读写内存的命令，每条命题提供要求访问的虚拟内存页的编号 $P$ 。你的程序要求能够模拟整个 $m$ 条命令的全部执行过程，所有的命令是按照输入的先后执行的，最开始的时候内存中的 $n$ 页全为空。



## 样例 #1

### 输入

```
3 8 
1
1
2
3
4
2
5
4
```

### 输出

```
1```

# 题解

## 作者：liunian (赞：15)

~~我看了该题的几篇题解，什么map+set,什么线段树，抱歉我都不会~~

蒟蒻的方法，大佬勿喷。

实际上只需一个**优先队列**就能过了，并且跑得**贼快**。。。。。。

 _用普通数组存不下1e9，离散就行了。_ 

关于排序的优先级，直接先按照出现的次数排序，再按照时间排序，刚开始打时，我把大于小于弄反了，卡了好几个小时。。。。。。

1. 若内存未被排满，直接将其塞入。

2. 若已排满，其实当前页在不在队列中都不重要，遇到已经存在页就加1即可。因此可以直接通过取队首元素，将其出队直到能够放置时就行了。

直接见我精简但无脑的代码：

```
#include<iostream>
#include<stdio.h>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=1e6+5;
struct node {
	int xu,t;
	bool operator<(const node &a)const {
		if(t==a.t)return xu>a.xu;
		return t>a.t;
	}
};
priority_queue<node>q;
int a[maxn],b[maxn];
int num[maxn];
int main() {
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1; i<=m; i++)scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+m+1);
	int k=unique(b+1,b+m+1)-b-1;
	int tot=0,ans=0;
	for(int i=1; i<=m; i++) {
		a[i]=lower_bound(b+1,b+k+1,a[i])-b;
		if(num[a[i]])num[a[i]]++,ans++;
		else if(tot<n)tot++,num[a[i]]=1;
		else {
			node res=q.top();
			q.pop();
			while(num[a[res.xu]]!=res.t)res=q.top()，q.pop();
			num[a[i]]++,num[a[res.xu]]=0;
		}
		q.push((node)<%i,num[a[i]]%>);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：jiaangk (赞：10)

~~Luogu的某些用户实在是无良心啊，这么一道大概勉强达到提高要求的STL题居然被弄成了紫题。。~~ 
## 思路
感觉另外几位题解中的大牛都对这题想的太复杂了。在这里说一下本蒟蒻的思路。用结构体开一个map和一个priority_queue来维护内存。

```cpp
struct node{//这个是维护map的，a表示这个元素是否在内存中，b是个神奇的变量接下来再讲
	int a,b;
};
struct noded{//这个是维护priority_queue的，a表示出现在内存中的次数，b元素的数字，c表示进入内存的时间
	int a,b,c;
};
bool operator <(noded a,noded b){//维护一下priority_queue，因为自定义了结构体，肯定不能用原来的，a.c<b.c跟具体代码实现有关
	return a.b==b.b? a.c<b.c:a.a>b.a;
}
map<int,node> p;
priority_queue<node> q;
```
然后怎么用这两个东西来维护内存呢？首先读入一个数，用map判断一下这个元素是否在内存中，如果在的话，就把这个在map中的元素的b值加1，也就是说内存中的元素比堆中储存的元素出现次数要大1，答案也可以跟着+1。如果不在的话，判断q.size()是否等于n，如果不等于就无脑插入。如果等于n的话，就找内存中找出现次数最少的元素。步骤是这样的。①：先取q.top()，记为cache临时变量，把q.top()弹出。②：判断p[cache.b].b是否等于0，如果不等于0，说明堆中的元素出现次数并不是实际内存中元素的出现次数，就把cache.b加上p[cache.b].b，之后重新把cache放到堆里。再次进行步骤①。如果等于0，说明这个元素就是内存中出现最少的元素，弹出这个元素，并把新元素加进去。

## 代码

```cpp
#include<cstdio>
#include<queue>
#include<map>
using namespace std;
struct node{
	int a,b;
};
struct noded{
	int a,b,c;
};
bool operator <(noded a,noded b){
	return a.a==b.a? a.c<b.c:a.a>b.a;
}
map<int,node> p;
priority_queue<noded> q;
main(){
	int n,m,cache,ans=0;
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d",&cache);
		if(p[cache].a==1) ++p[cache].b,++ans;
		else {
			noded pp;
			p[cache].a=1;
			pp.b=cache;
			pp.a=1;
			pp.c=m;
			if(q.size()<n) q.push(pp); else {
				noded ppp;
				mark:ppp=q.top();
				q.pop();
				if(p[ppp.b].b>0){
					ppp.a+=p[ppp.b].b;
					p[ppp.b].b=0;
					q.push(ppp);
					goto mark;
				}
				p[ppp.b].a=0;
				q.push(pp);
			}
		}
	}
	printf("%d",ans);
}
```

(比其他题解短多了！）

---

## 作者：xyx404 (赞：5)

## 思路：
定义三个 `unordered_map`，两个 `unordered_map` 的键和值都是 `int` 类型，分别存被访问的次数定义名字为 $mp$ 和是在什么时候存进来的定义名字为 $jl$，第三个 `unordered_map` 的键为 `int` 类型，而值为 `vector` 数组，用来存访问次数为键的内存页是几定义名字为 $se$。

定义 $c$ 为需要访问的虚拟内存页的编号，再定义一个 $minn$ 表示现在最少的访问次数。

如果要访问的内存页存在也就是 `mp.count(c)` 为一，那么让我们的答案加一，然后把 $se$ 里的数组里的 $c$ 删除，接着把 $c$ 加入到 $se$ 的键为这次操作后 $c$ 被访问的次数的数组里，然后判断一下在这次操作后原本 $se$ 的键为 $minn$ 的数组大小是否为零，如果为零则代表 $c$ 原本是这个数组里唯一的元素，而 $c$ 的访问次数增加后，这个数组里就没有元素了，也就是最少的访问次数现在不是 $minn$ 了而是 $minn$ 加上一，我们让 $minn$ 加一。

如果要访问的内存页不存在，则先判断一下现在 $mp$ 里键的数量是否小于 $n$：  
如果小于 $n$，则把 $mp_c$ 赋值为一，然后将 $jl_c$ 赋值为现在是第几个操作，然后在 $se$ 里键为一的数组里加入 $c$，最后把 $minn$ 赋值为一，因为 $c$ 是刚刚加入的，所以只被访问了一次，是最少的访问次数。  
如果不小于 $n$ 则把 $se$ 里键为 $minn$ 的数组里的第一个值删除并把 $c$ 加入 $se$ 里键为一的数组里。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long
int n,m,ans=0; 
unordered_map<int,int>mp;// 被访问的次数 
unordered_map<int,int>jl;// 是在什么时候存进来的 
unordered_map<int,vector<int> >se;// 访问次数，是什么 
int minn=1e9;// 最少的访问次数 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	jl[int(1e9+1)]=m+1;
	int c;
	for(int i=1;i<=m;i++){
		cin>>c;
		if(mp.count(c)){
			ans++;
			auto it=find(se[mp[c]].begin(),se[mp[c]].end(),c);
			se[mp[c]].erase(it);
			if(se[minn].size()==0)minn++;
			mp[c]++;
			se[mp[c]].push_back(c);
		}
		else{
			if(mp.size()<n){
				mp[c]=1;
				jl[c]=i;
				se[mp[c]].push_back(c);
				minn=1;
			}
			else{
				int sanc=1e9+1;
				auto it=se.begin();
				vector<int>sz(se[minn]);
				sanc=sz[0];
				auto itt=find(se[mp[sanc]].begin(),se[mp[sanc]].end(),sanc);
				se[mp[sanc]].erase(itt);
				if(se[mp[sanc]].size()==0)se.erase(mp[sanc]);
				mp.erase(sanc);
				jl.erase(sanc);
				mp[c]=1;
				jl[c]=i;
				minn=1;
				se[mp[c]].push_back(c);
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Lysea (赞：5)

## 本题做法：MAP + 优先队列

看到题解中有写离散化 + 优先队列的，也有写 `map` + 线段树的。

我们可以结合一下二者，用 `map` + 优先队列完成这题。

缺点是常数大了不少，优点则是比离散化看上去更加直观，比起线段树码量少很多。

### 思路：

题目中的 A、B 操作都很好实现，使用 `map` 累加即可，关键就在于操作 C 如何完成。

操作 C 要求我们寻找访问次数的最小值，很明显要用到优先队列，可是题目中的访问次数会不断变化，优先队列无法支持如此多的删除与插入操作。

~~一个很自然的想法就是用线段树。~~

一个很自然的想法就是**延迟处理**。

我们不必在每次访问次数改变的时候修改优先队列内的值，只需先用 `map` 记录，在进行操作 C 时修改即可，具体做法如下：

- 第 $0$ 步：读入编号 $a$，如果此时优先队列大小为 $n$ 且 $a$ 不处于内存中，进行操作 C。

- 第 $1$ 步：取出优先队列队头的编号 $i$ 与访问次数 $\mathit{v}_{i}$。

- 第 $2$ 步：将 $\mathit{v}_{i}$ 与此时 `map` 中下标为 $i$ 的值 $\mathit{h}_{i}$ 进行匹配，如果二者不同则继续进行第 $3$ 步，反之跳转第 $4$ 步。

- 第 $3$ 步：将 $\mathit{v}_{i}$ 更改为 $\mathit{h}_{i}$，然后重新入队，回到第 $1$ 步。

- 第 $4$ 步：此时 $\mathit{v}_{i}$ 就是内存中访问次数的最小值，$i$ 就是访问次数最少的编号。将 $\mathit{h}_{i}$ 更改为 $0$，$\mathit{h}_{a}$ 更改为 $1$，再将编号 $a$ 的初始信息入队，操作 C 结束。

### 代码如下：
```
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define se second
using namespace std;
struct node{
	int v,t,idx;
	//v代表访问次数,t代表时间,idx代表编号 
	bool operator<(const node& a)const{
		if(v!=a.v) return v>a.v;
		return t>a.t;
	}
};
int n,m,ans;
map<int,int>h;
priority_queue<node>q;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1,a;i<=m;i++){
		cin>>a;
		if(h[a]){
			//目前编号在内存里 
			//累计答案并更新访问次数 
			ans++;
			h[a]++;
		}
		else if(q.size()==n){
			//内存已满且目前编号不在内存里
			//延迟处理 
			node k=q.top();
			q.pop();
			while(h[k.idx]!=k.v){//如果优先队列顶端的值与 MAP中的值不同
				k.v=h[k.idx];//更新访问次数 
				q.push(k);
				k=q.top();//一直重复上述操作,直至优先队列内的访问次数为真实值,此时的访问次数即最小值 
				q.pop();
			}
			h[k.idx]=0,h[a]=1;
			q.push(node{1,i,a});
		}else{
			//内存未满且目前编号不在内存里
			//更新优先队列与访问次数 
			q.push(node{1,i,a});
			h[a]=1;
		}
	} 
	cout<<ans;
    return 0;
}

```


---

## 作者：忘怜城羡 (赞：5)

## 前文
这是我们今天模拟赛打到的题，没想到能是一道紫题（~~建议降绿~~

# 思路
各位巨佬的优先队列优化的算法没想到，我太菜了 /kk，考场上想出来用线段树维护的做法，线段树维护的共有该区间同一内容出现的最小次数，最小次数内容对应的存入时间和内容编号。

对于操作 $a$，用一个 unordered_map (不用离散化)保存编号为 $x$ 的内容最后出现在内存的第几页，即线段树第几个叶子节点，然后询问该节点维护的内存编号是否为 $x$。

对于操作 $b$，提前用一个变量记录还剩多少空页，每次修改线段树的该节点；

对于 操作 $c$，用线段树维护 $n$ 个内存页中访问次数最少且最早出现的内存页，然后每次都将该内存页的内容替换为现在编号的内容；

时间复杂度 $O(m \log n)$

# code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e4+10;
struct node{
	int sum,mino,minn;
}tree[maxn<<5];
int s,ans,i=1;
unordered_map<int,int> mp;
void pushdown(int p)
{
	if(tree[p*2].mino!=-1)
	{
		tree[p].sum=tree[p*2].sum;
		tree[p].mino=tree[p*2].mino;
		tree[p].minn=tree[p*2].minn;
	}
	if(tree[p*2+1].mino!=-1)
	{
		if(tree[p].sum==-1)
		{
			tree[p].sum=tree[p*2+1].sum;
			tree[p].mino=tree[p*2+1].mino;
			tree[p].minn=tree[p*2+1].minn;
		}
		else
		{
			if(tree[p].sum>tree[p*2+1].sum)
			{
				tree[p].sum=tree[p*2+1].sum;
				tree[p].mino=tree[p*2+1].mino;
				tree[p].minn=tree[p*2+1].minn;
			}
			else
			if(tree[p].sum==tree[p*2+1].sum)
			{
				if(tree[p].minn>tree[p*2+1].minn)
				{
					tree[p].mino=tree[p*2+1].mino;
					tree[p].minn=tree[p*2+1].minn;
				}
			}
		}
	}
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tree[p].sum=-1;
		tree[p].mino=-1;
		return ;
	}
	int mid=(l+r)>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	tree[p].sum=-1;
	tree[p].mino=-1;
}
int find(int p,int l,int r,int x)
{
	int cnt;
	if(l==r)
	{
		if(tree[p].mino==x)
		{
		tree[p].sum++;
		return 1;
		}
		else
		return 0;
	}
	int mid=(l+r)>>1;
	if(mp[x]<=mid)
	cnt=find(p*2,l,mid,x);
	if(mid<mp[x])
	cnt=find(p*2+1,mid+1,r,x);
	pushdown(p);
	return cnt;
}
void modify(int p,int l,int r,int x)
{
	if(l==r)
	{
		tree[p].mino=x;
		tree[p].sum=1;
		tree[p].minn=i;
		return ;
	}
	int mid=(l+r)>>1;
	if(mp[x]<=mid)
	modify(p*2,l,mid,x);
	if(mid<mp[x])
	modify(p*2+1,mid+1,r,x);
	pushdown(p);
}
void change(int p,int l,int r,int x,int y)
{
	if(l==r)
	{
		tree[p].sum=1;
		tree[p].mino=y;
		tree[p].minn=i;
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid)
	change(p*2,l,mid,x,y);
	if(mid<x)
	change(p*2+1,mid+1,r,x,y);
	pushdown(p);
}
signed main()
{
//	freopen("memory.in","r",stdin);
//	freopen("memory.out","w",stdout);
	int n,m;
	scanf("%lld%lld",&n,&m);
	build(1,1,n);
	s=n;
	for(;i<=m;++i)
	{
		int x;
		scanf("%lld",&x);
		if(mp[x]!=0&&find(1,1,n,x))
			ans++;
		else
		if(s>0)
		{
			mp[x]=s;
			modify(1,1,n,x);
			s--;
		}
		else
		{
			int p=tree[1].mino;
			change(1,1,n,mp[p],x);
			mp[x]=mp[p];
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：司马智泽 (赞：3)

其实感觉这不应该是一道紫题，我感觉就是一道蓝题~~（dalao别打我啊）~~

我主要用的是线段树水过去的，自我感觉就是一道线段树的模板题啊。。。

seg记优先度的最小值（pair<访问次数，最早访问时间>），当然要用一个map存这个值在不在线段树里和在线段树的位置，然后更新的时候先看一下线段树里有没有这个值，有就直接找这个值更新，否则找权值最小的替代（这里的空页就是访问次数为0，也就是说找空页和找访问次数最小的方法是一样的）。最后seg还要记一下存的值用删除map里的已经被替换的值。

然后一道紫题就这么水过去啦！！！

下面是渣代码：

```
//lgp2318
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
const int maxn=10000+9;
typedef pair<int,int> P;

int n,m,ans,root,cnt,ind;
map<int,int> M;
struct seg_{
	int lson,rson,pos;
	P prio;int page;
}seg[maxn*4];

void build(int &p,int segl,int segr){
	p=++cnt;
	if(segl==segr){
		seg[p].pos=++ind;
		return;
	}
	int mid=(segl+segr)>>1;
	build(seg[p].lson,segl,mid);
	build(seg[p].rson,mid+1,segr);
}

void update1(int p,int segl,int segr,int pos){
	if(segl==segr){
		seg[p].prio.first++;
		return;
	}
	int mid=(segl+segr)>>1;
	if(pos<=mid) update1(seg[p].lson,segl,mid,pos);
	else update1(seg[p].rson,mid+1,segr,pos);
	seg[p].prio=min(seg[seg[p].lson].prio,seg[seg[p].rson].prio);
}

int update2(int p,int segl,int segr,int time,int page){
	if(segl==segr){
		if(seg[p].page) M.erase(seg[p].page); 
		seg[p].prio=make_pair(1,time);
		seg[p].page=page;
		return seg[p].pos;
	}
	int mid=(segl+segr)>>1;
	int ret;
	if(seg[seg[p].lson].prio<seg[seg[p].rson].prio) ret=update2(seg[p].lson,segl,mid,time,page);
	else ret=update2(seg[p].rson,mid+1,segr,time,page);
	seg[p].prio=min(seg[seg[p].lson].prio,seg[seg[p].rson].prio);
	return ret;
}

int main(){
	scanf("%d %d",&n,&m);
	build(root,1,n);
	for(int i=1;i<=m;i++){
		int x;scanf("%d",&x);
		if(M.count(x)){
			ans++;
			update1(root,1,n,M[x]);
		}
		else M.insert(make_pair(x,update2(root,1,n,i,x)));
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Great_Influence (赞：3)

平衡树（是不可能的）

其实是STL。

开一个set维护虚拟内存中的数字，以访问次数第一维，进入时间第二维排序。

再开一个map维护虚拟内存中数字访问次数，用于辅助查找。

对于每个操作，如果map中记录过，那么这个数一定在虚拟内存中，直接lower\_bound找到它，将它的访问次数+1(记得也要在map中+1)，再把它放回去。

否则看看装满没，装满了就将set中第一个数删掉。直接插入，map对应值设置为1.

然后就没有然后了。。。。。。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//快读
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file()
{
    #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
    #endif
}
static map<int,int>K;//辅助用map
struct node//定义节点和排序方式
{
    int tm,num,cnt;
    friend bool operator<(node a,node b)
    {return a.cnt^b.cnt?a.cnt<b.cnt:a.tm<b.tm;}
};
static set<node>G;//虚拟内存
static set<node>::iterator it;
static int cnt,n,m;
void init()
{
    read(n);read(m);
}
static int ans;
void solve()
{
    static int x,now,tm;
    Rep(i,1,m)//具体方式见上
    {
        read(x);
        if(!K[x])
        {
            if(cnt>=n)
            {
                K[G.begin()->num]=0;
                G.erase(G.begin());
            }
            else ++cnt;
            G.insert((node){i,x,1});
            K[x]=1;
        }
        else
        {
            ++ans;
            now=K[x]+1;
            it=G.lower_bound((node){0,x,now-1});
            for(;it->num!=x;++it);
            tm=it->tm;
            G.erase(it);
            G.insert((node){tm,x,now});
            ++K[x];
        }
    }
    printf("%d\n",ans);
}
int main()
{
    file();
    init();
    solve();
    return 0;
}//然而05年并不能用stl
```

---

## 作者：zhyh (赞：1)

写了权值线段树，没想到题解有优先队列...  
以为类似 dij 的优先队列写法会被卡，后来想想，最坏情况也就是所有点入队再出队，似乎没有问题...  
这篇题解可能能解释为什么有个 `哈希` 标签...  

离散化后，用 次数$\times 1e6+$时间 做哈希值，对其维护一个数据结构，支持插入、删除、查询最小，这里是用权值线段树，然后...就没了...  
虽然时空间常数都好大...  
（另外，似乎数据不强？哈希函数打错能拿 90 ？~~然后瞪了半天实在太菜了~~）
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 1000005;
const ll L = 1;
const ll R = 1000000000000;
struct segmentTree { // 权值线段树
	#define lson ls[x]
	#define rson rs[x]
	vector<int> cnt, typ, ls, rs; int tot;
	//int cnt[6000005], typ[6000005], ls[6000005], rs[6000005], tot;
    	// 一开始哈希函数打错 RE 了一个点，以为数组炸了...
	void expand() { // 挣扎行为...
		cnt.push_back(0); 
		typ.push_back(0);
		ls.push_back(0);
		rs.push_back(0);
	}
	segmentTree() { tot = 1, expand(), expand(); }
	void pushup(int x) { cnt[x] = cnt[lson] + cnt[rson]; }
	void pushdownl(int x) { if (!lson) lson = ++tot, expand(); }
	void pushdownr(int x) { if (!rson) rson = ++tot, expand(); }
	void change(int x, ll l, ll r, ll p, int k, int t) {
		if (l == r) cnt[x] += k, typ[x] = t;
		else {
			ll mid = (l + r) >> 1;
			if (p <= mid) pushdownl(x), change(lson, l, mid, p, k, t);
			if (p >  mid) pushdownr(x), change(rson, mid+1, r, p, k, t);
			pushup(x);
		}
	}
	int front(int x, ll l, ll r) {
		if (l == r) return typ[x];
		ll mid = (l + r) >> 1;
		if (lson && cnt[lson]) return front(lson, l, mid);
		else return front(rson, mid+1, r);
	}
} ST;
struct opt {
	int a, b, id;
} P[MAXN];
int N, M; ll hash[MAXN];
int cmp1(opt x, opt y) { return x.a < y.a; }
int cmp2(opt x, opt y) { return x.id < y.id; }
int main()
{
	scanf("%d%d", &N, &M);
	for (int i=1; i<=M; i++) { scanf("%d", &P[i].a); P[i].id = i; }
	sort(P+1, P+M+1, cmp1); P[1].b = 1;
	for (int i=2; i<=M; i++) P[i].b = P[i-1].b + (P[i].a != P[i-1].a);
	sort(P+1, P+M+1, cmp2);
	int tot = 0, ans = 0;
	for (int i=1; i<=M; i++) {
		int x = P[i].b;
		//printf("[%d]\n", x);
		if (hash[x]) {
			ans++;
			ST.change(1, L, R, hash[x], -1, x);
			hash[x] = (hash[x] / 1000000 + 1) * 1000000 + i; // 把 / 打成 % 太离谱了...
			ST.change(1, L, R, hash[x], 1, x);
		} else {
			if (tot < N) tot++;
			else {
				int y = ST.front(1, L, R);
				ST.change(1, L, R, hash[y], -1, y);
				hash[y] = 0;
				//printf("pop %d\n", y);
			}
			hash[x] = 1000000 + i;
			ST.change(1, L, R, hash[x], 1, x);
		}
	}
	printf("%d", ans);	
}
```


---

## 作者：YWY_wys (赞：1)

写的不是很好...凑合着看吧...

调了有点久的....废话不多说，入正题


# 一个数据结构题
## 题意：

题目意思很明显，就是要你模拟。显然没想让你暴力模拟。

写一种数据结构去支持题目中的操作：

- 根据关键字查询某一元素
- 根据**P**这个关键字修改集合中某一个元素。
- 查询集合中的最小元素。

## 题解：

stl中的set能很好地解决这个问题。但这里是线段树的解法
（感觉好难讲啊...QAQ）

**核心是线段树维护第1-n个内存页中的最小值。
大小我们在结构体中定义一下就好了。

**关于变量的问题请看代码注释，下文也有部分说明**。

具体sgt的变量在这：
```
struct node{//我们要维护的值。写个结构体 
	int pos,pa,dfn,w;//dfn为时间戳，w为访问次数，pos为此节点在内存页中的位置 ,pa是页码 
	node() {};
	node(int pos_,int pa_,int dfn_,int w_) {pos=pos_;pa=pa_;dfn=dfn_;w=w_;}
	bool operator < (const node &a) const{//大小比较的定义 
		if(w==a.w) return dfn<a.dfn;
		return w<a.w;
	}
	bool operator > (const node &a) const{
		if(w==a.w) return dfn>a.dfn;
		return w>a.w;
	}
};

....

struct sgt{//线段树维护的是1-n个内存页。（最小值） 
	node c[size];
	.....
};
```


### 1.根据关键字查询某一元素是否在集合中存在。
map无疑是个非常好的选择。

我们申明一个map<int,int> ha。ha保存的是p这页在内存中的位置。

譬如：ha[p]=pos。（pos表示p这个外存储存在内存页的第pos页）

如果ha[p]=0，说明p不在内存页中。

如果ha[p]不为0，说明p在内存页中，且在第ha[p]页。

### 2.根据**P**这个关键字修改集合中某一个元素。

由ha[p]可以知道p是否在内存中，同时知道其在内存中的位置。令pos=ha[p],然后我们就在线段树中去修改pos这个位置的值。
就像这样：
```cpp
	void updata(int o,int l,int r,int k,node x) {
		if(l==r) {
			c[o]=x;
			return ;	
		}
		int mid=(l+r)>>1;
		int lson=o<<1;
		int rson=lson|1;
		if(k<=mid) updata(lson,l,mid,k,x);
		else updata(rson,mid+1,r,k,x);
		c[o]=min(c[lson],c[rson]);
	} 
```

### 3.查询最小值或根据关键字查询某一元素。

最小值用线段树能很好的解决。但我们需要多保存一些信息。比如pos（在内存页中的位置），pa（外存中的页码），dfn（时间戳，插入的时间），w（被访问次数）。然后就能方便的是用线段树了。
具体看代码。
```cpp
	node query(int o,int l,int r,int a,int b) {//查询第a-b内存页中的最小值 
		node res=node(0,0,0x3f3f3f3f,0x3f3f3f3f);
		if(a<=l && r<=b) return c[o];
		int mid=(l+r)>>1;
		int lson=o<<1;
		int rson=lson|1;
		if(a<=mid) res=min(res,query(lson,l,mid,a,b));
		if(b>mid) res=min(res,query(rson,mid+1,r,a,b));
		return res;
	}
```

### code：
```cpp
#include<cstdio>
#include<map>
#include<algorithm>

using namespace std;

const int maxn=10005;
const int size=40005;

int read() {
	int x=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0' && c<='9') {
		x*=10;x+=c-'0';
		c=getchar();
	} 
	return x;
}

struct node{//我们要维护的值。写个结构体 
	int pos,pa,dfn,w;//dfn为时间戳，w为访问次数，pos为此节点在内存页中的位置 ,pa是页码 
	node() {};
	node(int pos_,int pa_,int dfn_,int w_) {pos=pos_;pa=pa_;dfn=dfn_;w=w_;}
	bool operator < (const node &a) const{//大小比较的定义 
		if(w==a.w) return dfn<a.dfn;
		return w<a.w;
	}
	bool operator > (const node &a) const{
		if(w==a.w) return dfn>a.dfn;
		return w>a.w;
	}
};

//

struct sgt{//线段树维护的是1-n个内存页。（最小值） 
	node c[size];//key值 
	void build(int o,int l,int r) {//建树 
		c[o].w=0;
		if(l==r) return ;
		int mid=(l+r)>>1;
		int lson=o<<1;
		int rson=lson|1;
		build(lson,l,mid);
		build(rson,mid+1,r);
	}
	void updata(int o,int l,int r,int k,node x) {//修改第k个内存页
		if(l==r) {
			c[o]=x;
			return ;	
		}
		int mid=(l+r)>>1;
		int lson=o<<1;
		int rson=lson|1;
		if(k<=mid) updata(lson,l,mid,k,x);
		else updata(rson,mid+1,r,k,x);
		c[o]=min(c[lson],c[rson]);
	} 
	node query(int o,int l,int r,int a,int b) {//查询第a-b内存页中的最小值 
		node res=node(0,0,0x3f3f3f3f,0x3f3f3f3f);
		if(a<=l && r<=b) return c[o];
		int mid=(l+r)>>1;
		int lson=o<<1;
		int rson=lson|1;
		if(a<=mid) res=min(res,query(lson,l,mid,a,b));
		if(b>mid) res=min(res,query(rson,mid+1,r,a,b));
		return res;
	}
} t;

int n,m,rem,ans;//rem表示当前内存页储存到了第几页 
map<int,int> ha;//保存P在内存页中的位置。（第几页） 

int main() {
	int p,pos;
	n=read();m=read();
	t.build(1,1,n);
	for(int i=1;i<=m;i++) {
		p=read();
		pos=ha[p];
		if(pos) {
			ans++;
			node u=t.query(1,1,n,pos,pos);
			t.updata(1,1,n,pos,node(pos,p,u.dfn,u.w+1)); 
			//printf("suc\n push (%d %d %d %d) in %d\n",pos,p,u.dfn,u.w+1,pos);
		}else {
			//printf("fail\n ");
			if(rem<n) {
				++rem;
				t.updata(1,1,n,rem,node(rem,p,i,0));
				ha[p]=rem;
				//printf("remain  push (%d %d %d %d) in %d\n",rem,p,i,0,rem);
			}else {
				node u=t.c[1];
				t.updata(1,1,n,u.pos,node(u.pos,p,i,0));
				ha[u.pa]=0;ha[p]=u.pos;
				//printf("no rem  push (%d %d %d %d) in %d\n",u.pos,p,i,0,u.pos);
			}
		}
	}
	printf("%d",ans); 
}
```

---

## 作者：M1saka16I72 (赞：0)

## 前言

[更可爱的阅读体验](https://misaka16172.github.io/solution-p2318.html)

这远古题怎么还能交题解。

## 思路

考虑使用数据结构直接模拟题目操作，这里直接使用线段树。

线段树的下标代表内存空间，每个节点里存两个 int 和一个 pair，两个 int 分别代表当前节点里有几个下标已经有数了，另一个只在叶子节点有用，代表当前节点存储的数是多少；pair 第一维代表访问次数，第二维代表插入时间。同时开一个 map，记录某个数在内存里的下标。

模拟过程如下：

- 若当前数在 map 里有值，则将线段树上其对应下标处加 $1$，同时答案加 $1$，否则继续下一步；

- 使用线段树上二分找出一个还没有被占用的下标，若能找到这样的下标，则将其修改为当前值，同时更新 map 里的下标，否则继续下一步；

- 若当前所有下标都被占用，则在线段树上查询访问次数最少、插入时间最早的下标，将该位置之前对应的值在 map 里的下标置为 $0$，并在线段树上修改为当前值。

细节详见代码。

## 代码

```cpp
constexpr int N = 1e4+5;

struct node{
	int s,id;
	pii t;
};

int n,q;

struct SGT{
	node tr[N<<2];
	inline void up(int p){
		tr[p].s = tr[p<<1].s+tr[p<<1|1].s;
		tr[p].t = min(tr[p<<1].t,tr[p<<1|1].t);
	}
	void upd(int d,int l,int r,int p,node x){	//修改当前位置的值
		if(d==l && l==r)	tr[p] = x;
		else{
			int mid = (l+r)>>1;
			if(mid>=d)	upd(d,l,mid,p<<1,x);
			else    upd(d,mid+1,r,p<<1|1,x);
			up(p);
		}
	}
	void add(int d,int l,int r,int p,int x){	//访问次数+1
		if(d==l && l==r)	tr[p].t.fst+=x;
		else{
			int mid = (l+r)>>1;
			if(mid>=d)	add(d,l,mid,p<<1,x);
			else    add(d,mid+1,r,p<<1|1,x);
			up(p);
		}
	}
	int _place(int l,int r,int p){	//线段树上二分，找第一个未被访问的下标
		if(l==r)	return l;
		int mid = (l+r)>>1;
		if(tr[p<<1].s<(mid-l+1))	return _place(l,mid,p<<1);
		else    return _place(mid+1,r,p<<1|1);
	}
	int place(){return tr[1].s==n?-1:_place(1,n,1);}
	node qmin(int l,int r,int p){	//如果所有位置都被访问了，就查找访问次数最少、插入时间最早的下标
		if(l==r)	return tr[p];
		int mid = (l+r)>>1;
		return tr[p<<1].t<tr[p<<1|1].t?qmin(l,mid,p<<1):qmin(mid+1,r,p<<1|1);
	}
}sgt;

unordered_map<int,int> pl;

void solve(){
	read(n),read(q);
	int ans = 0;
	for(int i=1;i<=q;i++){
		int x;read(x);
		if(pl[x]){
			++ans;
			sgt.add(pl[x],1,n,1,1);
		}
		else{
			int p = sgt.place();
			if(p!=-1){
				pl[x] = p;
				sgt.upd(p,1,n,1,{1,x,{0,i}});
			}
			else{
				node now = sgt.qmin(1,n,1);
				sgt.upd(pl[now.id],1,n,1,{1,x,{0,i}});
				pl[x] = pl[now.id],pl[now.id] = 0;
			}
		}
	}	
	cout<<ans;
}
```

---


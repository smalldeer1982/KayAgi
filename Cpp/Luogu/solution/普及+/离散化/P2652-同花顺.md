# 同花顺

## 题目背景

所谓同花顺，就是指一些扑克牌，它们花色相同，并且数字连续。


## 题目描述

现在我手里有 $n$ 张扑克牌，但它们可能并不能凑成同花顺。我现在想知道，最少更换其中的多少张牌，我能让这 $n$ 张牌都凑成同花顺？

## 说明/提示

- 对于 $30\%$ 的数据，$n \le 10$；
- 对于 $60\%$ 的数据，$n \le 10^{5}$，$ 1 \le a_{i} \le 10^{5}$，$1 \le b_{i} \le n$；
- 对于 $100\%$ 的数据，$n \le 10^{5}$，$1 \le a_{i}, b_{i} \le 10^{9}$；

## 样例 #1

### 输入

```
5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
0```

## 样例 #2

### 输入

```
5
1 9
1 10
2 11
2 12
2 13```

### 输出

```
2```

# 题解

## 作者：Merak (赞：41)

Ps.来重新叙述一下思路www


首先对楼下各位dalao致以深深的敬意~虽然写的很清楚了我还是没有看懂QAQ是因为我太蠢了（也就我这么笨啦）


代码和思路是结合老师讲解（没错就是我们的考试题QAQ完美0分）还有一楼的Pascal大神经过论坛里某位神犇的翻译后的c++代码写出来的~表示十分的佩服两位dalaoQWQ


——————————————————————————


**题目要求**


更换n张牌中的某些牌使其能够凑成同花顺，且使换掉的牌的张数最小。


**思路分析**


反向思考一下，我们只要求能组成的同花顺的最长长度（组成张数）l，再用n减去l即可。


怎么求l呢？


假设有这样一组样例：


6

1 7

2 8

1 9

1 10

2 2

3 5

首先我们要思考同花顺的性质：花色相同且数字连续。那么由此我们可以想到什么呢？大多数人最先想到的大概是排序吧。没错，的确需要排序，这是做出这道题的一个十分重要的基础。但是同花顺还有一个性质是花色相同，说明这个题排序并不是简单的排序。该怎么排序才能求出“颜色相同”的最长单调递增序列呢？我们可以定义一个排序法则rule（详见代码），如果两张牌颜色相同，则将它们按从小到大的顺序排序；如果颜色不同，则将他们的颜色编号从小到大排序。


排序后我们将得到这样一组数据：


1 7

1 9

1 10

2 2

2 8

3 5
排完序之后我们是不是就可以开开心心求最长序列了呢？机智的出题人显然不会这么轻易放过我们（233），TA埋了一个坑在这里面：可能会存在花色和数值均相同的扑克牌。这样就影响了我们求最大序列长度，所以我们必须要通过条件语句来筛出这些牌。我们再用一个数组b[]来记录筛出重复牌后的数据。跳过这个坑之后我们就可以开始最后的工作啦！如何求最长的序列呢？我们可以通过枚举所有区间，来判断哪个区间长度最大且满足是同色牌&&b[i].y-b[j].y+1<=n（这个判断条件非常的关键）。这个条件是怎么推出的呢？先理解b[i].y-b[j].y+1的意义：它表示区间的长度，也就是说这个区间有几张牌。当它的长度d<=n的时候，一定能够拿出足够的牌来更换这个区间中不满足条件的牌。这样我们就可以求出最大序列长度啦~


希望我把这个题的思路叙述清楚了2333~


附上代码：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int n,cnt=0,ans,temp=0;
struct node
{
    int x;
    int y;
}a[100003],b[100003]; 
bool rule(const node &s1,const node &s2)
{
    if(s1.x==s2.x) return s1.y<s2.y;
//这里把同色的排在一起，方便后续操作 
    else return s1.x<s2.x;
} 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].x>>a[i].y;
    }
    sort(a+1,a+n+1,rule);
    for(int i=1;i<=n;i++)
    {
        if(a[i-1].x!=a[i].x||a[i-1].y!=a[i].y)
        {
            b[++cnt]=a[i];
        } 
        //这里我们通过if语句来筛去同色牌中数值相同的牌 
    }
    for(int i=1;i<=cnt;i++)//枚举区间右端点 
    {
        temp=0;
        //注意此处一定要写在第一个循环和第二个循环之间 
        for(int j=i;j>=1;j--)//枚举区间左端点 
        {
            if(b[i].x==b[j].x&&b[i].y-b[j].y+1<=n)
            //如果是同色牌并且张数差小于等于n则一定能够通过换牌实现同花顺 
            {
                temp++; 
            }
            else break;//不符合条件则退出 
        }
        if(temp>ans) ans=temp;//取所有可行方案中最大值 
    }
    cout<<n-ans<<endl; 
    return 0;
}
```

---

## 作者：Tethys (赞：19)

# [题目](https://www.luogu.com.cn/problem/P2652)


这道题，我们求最少更换多少张牌就能够满足同花顺


然后我们反向思考一下：最少更换多少张 == 最多有多少张不用换


然后我们考虑同花顺的定义：所谓同花顺，就是指一些扑克牌，它们花色相同，并且数字连续


我们就会发现肯定是尽可能多的不动（而且最终构成的同花顺的起点或结尾可以是原有的扑克牌）


所以我们就可以枚举每张牌作为构成的同花顺的末尾(先去重)


（这里的去重指的是将花色相同，数字相同的扑克牌去掉）


然后我们考虑一共有$n$张牌，然后花色为$a_{i}$，数字为$b_{i}$的牌作为当前枚举到的同花顺的末尾


因为枚举到的最后一张扑克牌的数字为$b_{i}$，花色为$a_{i}$，所以以这张牌为结尾的同花顺的第一张牌一定是一张花色为$a_{i}$，数字为$b_{i}-n+1$的扑克牌（最后得到的同花顺），因为我们要求最多有多少张不用更换，所以只需要考虑原扑克牌中（去重之后）有多少张扑克牌（设为$k$）满足条件$a_{k} == a_{i}$&&$a_{i}-n+1 \leq a_{k} \leq a_{i}$


上述情况总结为两点：

* 与当前枚举的结尾花色不同的一定要更换
* 与当前结尾如果花色相同，且数字 $>$ (当前枚举到结尾的扑克牌的数字 - n)，就不用更换 



我们先排序，使相同花色的在一起，并且满足相同花色的数字从小到大排列，然后可以用$queue$维护,遇到新的不同的花色就清空队列，否则就删除队首不满足的，然后将当前这个枚举到的结尾插入队列，然后每次取个最大的$size$，最后求得最大的不用更换的牌数（然后用总排数减去就是最终答案了）


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, ans, cnt;
struct node{
	int x, y;
}a[N], b[N]; 
bool cmp(node op, node opp){
	if(op.x == opp.x) return op.y < opp.y;
	return op.x < opp.x;
}
queue<int> q;
void cl(){
	while(!q.empty()) q.pop();
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++) scanf("%d %d", &a[i].x, &a[i].y);
	sort(a + 1, a + n + 1, cmp);
	for(int i = 1; i <= n; i ++){
		if(a[i].x == a[i - 1].x && a[i].y == a[i - 1].y) continue;
		b[++ cnt] = a[i];	//cout<<cnt<<"ssddd\n";
	}

	for(int i = 1; i <= cnt; i ++){
		if(b[i].x != b[i - 1].x) cl();
	    while(q.size() && b[i].y - q.front() >= n) q.pop();
		q.push(b[i].y);
		ans = max(ans, (int)q.size()); 
	}

	ans = (n - ans);
	printf("%d\n", ans); 
	fclose(stdin); fclose(stdout);
	return 0;
} 
```

完美撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：Konnyaku_LXZ (赞：12)

这里介绍一种其他题解里都没有讲到的**二分**做法。

先说两个显而易见的结论：

1.最少更换的牌数=总牌数-不更换牌可以凑成的最长的同花顺的长度。

2.如果有多张牌花色和数值都相同，那么我们肯定只能留下一张这样的牌，剩下的全部都得换掉。

对于1这里做个解释：“不更换牌可以凑成的最长的同花顺”可以不用是连续的，但是需要满足**同花色并且最大值和最小值的差小于总牌数**。可以这么理解：我们可以把剩下的需要换掉的牌换成最小值和最大值中间的部分来补成一个同花顺。例如：当 $N=5$ ,牌的数字分别为 $1,4,100,200,300$ ，并且花色全部相同时，我们可以把 $100$ 换成 $2$，把 $200$ 换成 $3$，再把 $300$ 换成 $5$，来组成一个同花顺。

所以我们先将输入的数组以 $a$ 为第一关键字， $b$ 为第二关键字从小到大排序，对排序后的数组进行去重（指把花色和数字都相同的牌去掉），在去重的时候计算去除了几张牌，先将其累加到答案中。接着我们令 $f_i$ 表示以 $i$ 结尾的最长的同花顺。然后我们二分找到 $i$ 所属的花色的左端点 $l$ ，再在区间 $[l,i]$ 中二分使得 $v_i-v_j+1<=N$ 的最小的 $j$ （其中 $v_i$ 表示结点 $i$ 的数字）， $f_i$ 的值就是区间 $[j,i]$ 内的元素个数（因为区间内的数的数字是递增的，所以如果 $j$ 可以与 $i$ 凑成同花顺，那么所有大于 $j$ ，小于 $i$ 位置上的数也可以与 $i$ 凑成同花顺）。

为什么可以二分呢？因为我们以花色为第一关键字排序，所以花色是有序的，又因为我们以数字为第二关键字排序，所以在同一花色中，他们的数字又是有序的，因此可以使用二分查找。

最后我们的答案就是 **去重后的总牌数 $-$ $f_i$ 的最大值 $+$ 重复的牌数**。

Code：

```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
#include<stack>
#include<iostream>
using namespace std;

const int MAXN=1e5+50;
typedef long long LL;

struct node{
	int x;
	int y;
};

int N,f[MAXN],Ans=1,add=0;//add表示去掉的牌数，Ans表示答案 
int c[MAXN],v[MAXN],cnt=0;//c数组表示花色，v数组表示数字，cnt表示去重后的总牌数 
node a[MAXN],b[MAXN];

bool cmp(node a,node b){return a.x!=b.x?a.x<b.x:a.y<b.y;}

void Init(){
	scanf("%d",&N);
	for(int i=1;i<=N;++i) scanf("%d%d",&a[i].x,&a[i].y);
}

void Solve(){
	sort(a+1,a+1+N,cmp);
	b[++cnt]=a[1];
	for(int i=2;i<=N;++i){//去重 
		if(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y) b[++cnt]=a[i];
		else ++add;//计算重复的牌数 
	}
	for(int i=1;i<=cnt;++i) c[i]=b[i].x,v[i]=b[i].y; 
	f[1]=1;
	for(int i=2;i<=cnt;++i){
		int l=lower_bound(c+1,c+i+1,c[i])-c;//找到同花色左端点 
		int pos=lower_bound(v+l,v+i,v[i]-N+1)-v;//二分找到最小的可以凑成同花顺的位置 
		f[i]=i-pos+1;//更新f[i]的值 
		Ans=max(Ans,f[i]);//取最大值 
	}
	Ans=cnt-Ans+add;//计算真正的答案 
}

void Print(){
	cout<<Ans<<endl;
}

int main()
{
	Init();
	Solve();
	Print();
    return 0;
}
```

---

## 作者：Youngsc (赞：11)

GTY大佬的题，已经做了两遍。

用队列维护的话其实是很简单的。

首先我们可以想到，如果确定了一张牌作为某同花顺的结尾，那么整个同花顺是确定的，其次，如果有n张牌，那么最终组成的同花顺一定有n张，另外，对于两张完全相同的牌，一定会更换至少一张，有了以上结论，思路就显而易见了，首先将所有的牌按照花色分开，去重，排序，然后对于相同的花色，用一个队列去维护以每一张牌作结尾时能在序列中的所有牌（即维护首尾指针），然后统计出这些牌的数量，取较大值，答案就是牌的总数与这个值得差值。详细可见我的博客[Youngsc](http://youngscc.github.io/2017/10/10/%E6%B4%9B%E8%B0%B7%20P2652%20%E5%90%8C%E8%8A%B1%E9%A1%BA/)


---

## 作者：shuri001 (赞：7)

前面居然已经有有山东的大兄弟写过题解了啊 感人啊


17SD夏令营做到的+1


写个简单的题解好了


总体来说 假如给你n张牌 最小的牌号为1 最大的是n+233 你想把他们凑成一副顺子很显然是不可能的！


所以说我们要换牌


根据贪心 只要他们的最大牌号差<总牌数n 那么这种顺子就是可以组起来的！


所以说 我们去重以后 找到每一种花色的符合条件的最大牌号差 然后在他们之间取max就好啦！


恩就是这样 上代码吧ovo



```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int mx=200005;
struct node{
    int x,y;
}e[mx],e1[mx];
int n,m,k,kk,cnt,ans;
bool cmp(node a,node b){
    return a.x==b.x?a.y<b.y:a.x<b.x;
}
int main(){
    scanf("%d",&k);
    for(int i=1;i<=k;i++) scanf("%d%d",&e1[i].x,&e1[i].y);
    sort(e1+1,e1+1+k,cmp);
    for(int i=1;i<=k;i++)
        if(e1[i].x!=e1[i-1].x || e1[i].y!=e1[i-1].y)
            e[++cnt]=e1[i];
    for(int i=1;i<=cnt;i++){
        kk=1;
        for(int j=i-1;j>=1;j--)
            if(e[j].x==e[i].x && e[i].y-e[j].y+1<=k)    kk++;
            else break;
        ans=max(ans,kk);
    }
    printf("%d",k-ans);
    return 0;
}
```

---

## 作者：天依赛高！ (赞：5)

//楼下大佬好像讲用队列，然而我什么都不知道……




```cpp
//手动模拟了一下，其实排序可以起很大作用
//题目要求花色相同，数字连续，那么我们要做的就是找一种花色，并提取出其中一串数字留下
//那些舍弃的牌换成相应花色，并和之前留下的一串数字凑成k～(k+n-1)   共n个
//由上文可推出：留下的数字中最大值与最小值的差不能超过n-1，否则无法凑出连续的一串数
//那我们便排序：把花色相同的放一块，相同花色的数字递增(递减也无所谓)排列，去掉重复的牌后，
//找一串花色相同 且 数字最大值与最小值的差不超过n-1 的牌，
//因为我们要去掉最少的牌，所以就找到！最长！的一串符合上文描述的牌(也就是留下最多的牌)
// 答案=n-长度   即可
//请别嫌弃我的代码（笑
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<string>
#define rg register
using namespace std;
int n,b[100001][2],result=0;
struct pp
{
    int a,b;
}card[100001];
//      Vv + vV
inline int read()
{
    char q;int save=0,w=1;
    while(q<'0'||q>'9'){if(q=='-')w=-1;q=getchar();}
    while(q>='0'&&q<='9')save=save*10+q-'0',q=getchar();
    return w*save;
}
inline bool Cwen(const pp &x,const pp &y)//Cwen函数就是用在sort里的判断函数
{
    if(x.a==y.a)return x.b<=y.b;//花色相同时按数字大小排
    else return x.a<y.a;             //把花色相同的放到一坨(好像混进了什么奇怪的东西)
}
//      << + >>
int main()
{
    n=read();
    rg int i,j;
    for(i=1;i<=n;++i)
        card[i].a=read(),card[i].b=read();
    sort(card+1,card+n+1,Cwen);
    j=0;               //j用来指b数组
    for(i=1;i<=n;++i)
    {
        if(card[i].a!=card[i+1].a || card[i].b!=card[i+1].b)            //去重
            b[++j][0]=card[i].a, b[j][1]=card[i].b;                     //赋进b数组
    }
    rg int len=j;//把b数组的长度记到len里
    for(i=1;i<=len;++i)
    {
        int can=0;//can表示以i为终点的一段能达到多长
        for(j=i-1;j>=1;--j)
        {
            if(b[j][0]==b[i][0] && b[i][1]-b[j][1]<n)
                can++;
            else
                break;//一旦断了就跳出循环找下一个i
        }
        result=result<can+1?can+1:result;//can+1是因为 i自己这张牌 在里层循环中没被算进去
    }
    printf("%d\n",n-result);
    return 0;
}
```
天依赛高！！！！！

---

## 作者：rui_er (赞：4)

本题是一个有趣（？）的思维题，题意：要替换尽量少的牌，使得整套牌成为一个同花顺。

---

思路：容易想到，我们保留现有的最长的一条同花顺，将剩余的牌替换掉即可。

具体做法：

- 读入数据先按照花色、数字进行排序和去重。
- 枚举每一个点作为同花顺的右端点。
- 找到左侧可以连成同花顺的第一张牌，计算同花顺长度，更新最长的长度。
- 计算剩余的牌的数量，输出即可。

---

代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;

int n, diff, ans;
struct Node {
	int col, val;
	bool operator < (const Node &a) const {
		if(this->col != a.col) return this->col < a.col;
		return this->val < a.val;
	}
	bool operator == (const Node &a) const {return (this->col == a.col) && (this->val == a.val);}
	bool operator != (const Node &a) const {return !(*this == a);}
	Node() {}
	Node(int a, int b) : col(a), val(b) {}
	~Node() {}
}a[N], b[N];
int col[N], val[N];

void discretization() {
	sort(a+1, a+1+n);
	b[++diff] = a[1];
	for(int i=2;i<=n;i++) {
		if(a[i] != a[i-1]) b[++diff] = a[i];
	}
	for(int i=1;i<=diff;i++) {
		col[i] = b[i].col;
		val[i] = b[i].val;
	}
}

int main() {
	scanf("%d", &n);
	for(int i=1;i<=n;i++) scanf("%d%d", &a[i].col, &a[i].val);
	discretization();
	for(int i=2;i<=diff;i++) {
		int uPos = lower_bound(val+(lower_bound(col+1, col+1+i, col[i])-col), val+i, val[i]-n+1) - val;
		ans = max(ans, i-uPos+1);
	}
	printf("%d\n", n-ans);
	return 0;
}
```

---

## 作者：Ryan_ (赞：4)

~~（开氧气优化200ms）~~

 **解题思路**：将牌按花色从小到大排序，花色一样，按数字从小到大排序

对排序后的每一段花色相同的牌进行处理

**处理方式**：枚举由1到n的每一张牌，计算出花色相同的牌中最长上升序列最大值

计算时若不满足花色相同或两牌之间的间隙（如，2与5，间隙为2（3与4为间隙））小于等于序列中存在的最大间隙的话就更新答案

之所以要求间隙，是因为，间隙可以靠其他花色的数字来填补该间隙（特别的，对于相同颜色又相同数字的牌，间隙为0，即不需要别的牌不补来，自己进行修改）

最后输出答案用n减去满足条件的最大上升序列即可

这应该是正解，不过我写挂了，虽然有100分~~可能是数据太水吧~~

**例如如下情况**


```
6
1 1
3 2
3 7
3 8
3 9
4 7
```
很明显答案是3但是我写的AC代码输出的是4

~~聪明绝顶~~机智灵敏的我发现只要对同色数字维护代价最少的最大上升序列就好了，简单描述就是不管条件直接求出同种数字的最大上升序列然后不断减去相隔最大的点，直到达到条件为止

代码还是很好改的下面就不做修改了，~~毕竟也过了马？！！~~

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct node {
	long long num,col;
} a[100001];
long long n,kinds[100001];

int cmp(node x,node y) {
	if(x.col==y.col)return x.num<y.num;
	return x.col<y.col;
}
int charge() {
	int ans=0;//maxn
	int sum=0;
	int now=1;
	for(int i=1; i<=n; i++) {
		if((a[i].col==a[i-1].col)&&(a[i].num-a[i-1].num+sum-1<=n-now-1)) {
			sum+=a[i].num-a[i-1].num-1;
			if(a[i].num!=a[i-1].num)now++;
		} else {
			ans=max(ans,now);
			sum=0;
			now=1;
		}

	}
	ans=max(ans,now);
	return n-ans;
}
int main() {
	//memset(u,1,sizeof(u));
	scanf("%lld",&n);
	for(int i=1; i<=n; i++) {
		scanf("%lld",&a[i].col);
		scanf("%lld",&a[i].num);
	}
	sort(a+1,a+n+1,cmp);
	printf("%lld",charge());
}
```


---

## 作者：地表最强男人 (赞：2)

其实这一题可以转化成，在一段长度为$n$的大区间中，最大能找到的几段小区间的长度和。用$n$减去这个长度和，就是需要更换的牌数。但是这样的区间有很多，所以都需要处理。所以先离散化，花色相同才可以看做是同花顺，然后如果花色相同数字也相同的牌是没有任何用处的，如果不离散的话会被重复计算。所以按照花色和点数排个序，然后离散化将相同的去除，然后确定右区间，往左尽量扩展，计算能够扩展的个数。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,tot,cnt;
struct rec{
	long long t,d;//t是颜色,d是值 
}a[100010];
bool cmp(rec a,rec b)
{
	if(a.t!=b.t)
		return a.t<b.t;
	return a.d<b.d;
}
bool operator ==(const rec &a,const rec &b)
{
	return (a.t==b.t&&a.d==b.d);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].t>>a[i].d;
	sort(a+1,a+1+n,cmp);
	cnt=unique(a+1,a+1+n)-a-1; 
	for(int i=1;i<=cnt;i++)
	{
		int anss=1;
		for(int j=1;j<min(n,i);j++)
		{
			if(a[i].t!=a[i-j].t||a[i].d-n>=a[i-j].d)
				break;
			anss++;
		}
		tot=max(tot,anss);
	}
	cout<<n-tot;
	return 0;
} 
```


---

## 作者：joseph_cheung (赞：2)

贴一个使用c++ pair、库函数unique的精简版本代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 100000+10;
typedef pair<int,int> P;
P p[MAXN];
int main()
{
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d%d",&p[i].first,&p[i].second);
    sort(p+1,p+1+n);
    int totCard = unique(p+1,p+n+1)-p-1, sameColour = 1, last_one = 1;
    for (int i = 1; i <= totCard; ++i)
    {
        if (i == 1 || p[i].first != p[i - 1].first) last_one = i;
        while (p[i].second - p[last_one].second + 1 > n) ++last_one;
        sameColour = max(sameColour, i - last_one + 1);            
    }
    printf("%d\n", n-sameColour);
    return 0;
}
```

---

## 作者：quantum11 (赞：2)

首先考虑同花顺要花色相同并数值连续，所以牌要先排序


因为要连续,所以最小的牌和最大的牌之间的差要小于n(就是给你5张牌，让你排成1,2,3,4,5,6是不可能的）


题目要求需要换的牌最少，就是没用的牌最少，只要求有用的牌最多就行了


用了队列，把找牌的时候有用的牌记进去


每取到一张牌，有两种情况花色与前一张相同，或不相同。如果不相同，就把队列清空，把当前牌加入。   如果花色相同，再比较数值，如果相同，那么这张牌是没有用的。花色不相同，就从队头开始pop，直到当前数值减去队头之差小于n或队列为空。把当前牌计入后在比较答案。



```cpp
#include<bits/stdc++.h>
using namespace std;
struct card{
    int c,v;
}a[100005];
int n,ans;
queue<int> b;

bool cmp(card x,card y)
{
    if(x.c!=y.c) return x.c<y.c;
    return x.v<y.v;
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i].c>>a[i].v;
    sort(a+1,a+n+1,cmp);
    int j=1;
    for(int i=1;i<=n;i++)
    {
        if(a[i].c!=a[i-1].c)
        {
            while(!b.empty())
            b.pop();
            b.push(i);
        }
        else
        if(a[i].v!=a[i-1].v)
        {
            while(!b.empty() && a[i].v-a[b.front()].v>=n)
            b.pop();
            b.push(i); 
        }
        if(ans<b.size())
        ans=b.size();
    }
    cout<<n-ans;
    return 0;
}
```

---

## 作者：太阳骑士 (赞：1)

今天考了这道题qwq，题解参考了老师的solution。

$30pts$:暴搜解决

$60pts$:去重+贪心

下面是满分做法：

首先，肯定是要排序的。我们按照花色排序，相同花色的按照数字排序。然后就是去重，由于重复的牌无论如何也会被替换掉，所以我们先将其去重，并记录下此时的牌数。

考虑枚举每种花色中，以每一张牌作为结尾时可能的序列，取最大值，最后用排序前的总牌数减去这个值即可，显然地，如果当前牌的值为$a$，$last$的值为$b$，则需满足$a-b+1>m$

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define il inline
#define re register
#define tie0 cin.tie(0),cout.tie(0)
#define fastio ios::sync_with_stdio(false)
#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)
using namespace std;
typedef long long ll;

template <typename T> inline void read(T &x) {
	T f = 1; x = 0; char c;
    for (c = getchar(); !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x *= f;
}

struct card {
	int a, b;
	bool operator < (const card &x)const{return a < x.a || (a == x.a && b < x.b);}
	bool operator == (const card &x)const{return a == x.a && b == x.b;}
}cd[100003];

int n, last, ans;

int main() {
	File("card");
	read(n);
	for (int i = 1; i <= n; ++i) read(cd[i].a), read(cd[i].b);
	sort(cd + 1, cd + 1 + n);
	int m = n;
	n = unique(cd + 1, cd + 1 + n) - (cd + 1);
	for (int i = 1; i <= n; ++i) {
		if (i == 1 || cd[i].a != cd[i-1].a) last = i;
		while(cd[i].b - cd[last].b + 1 > m) last++;
		ans = max(ans, i - last + 1);
	}
	printf("%d", m - ans);
	return 0;
}
```

---

## 作者：Mychael (赞：1)

**贪心**

WA了多次，终于AC了【主要是卡在一个判定上】

言归正传，既然标题是贪心，那么我们来看看贪心的思路：

\_我们只考虑哪些牌不用换，剩下的就是要换的牌\_


1‘【看颜色】整副牌最后要变成同花顺，一定是变成一种颜色，那么所有不是该颜色的牌都要换掉


2’【看数字】对于同一种颜色，按数字进行排序后，枚举i和j，对于每个i，找到一个最大的j，使得j对应的数与i对应的数相差不过N，那么这个范围内的数都可以不换，因为这个范围内的数都可以作为合法同花顺的元素，要换的就是这个范围内的数之外的数


3’看起来好像没毛病了，其实还有一个漏洞，对于找到的i~j范围内，若其中包含有相同的牌，也要换掉【这就是我WA了那么多次的原因】


>实现：
用快排将所有元素排序，先考虑颜色再考虑数字升序，这样不同的颜色分开且在同一个颜色内升序排列

然后用Two Pointer枚举，如上所述，不断更新ans，最后输出



接下来就是代码：



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=100005,INF=1000000000;
int read()                                           //读入优化
{
    int out=0;
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out;
}
class node                                       //存颜色与数字
{
```
public:



```cpp
        int color,num;
}puk[maxn];
inline bool operator < (const node& a,const node& b)
{
    if(a.color==b.color) return a.num<b.num;
    return a.color<b.color;
}
int main()
{
    int N=read();
    for(int i=0;i<N;i++)
    {
        puk[i].color=read();
        puk[i].num=read();
    }
    sort(puk,puk+N);                           //快排
    int ans=INF,same=0;                     //same是累加器，表示当前范围内有多少个重复的牌
    for(int i=0,j=0;i<N;i++)
    {
        same-=(i&&puk[i].num==puk[i-1].num);                  //更新重复的数字充分利用C++真为1假为0的特性
        if(i&&puk[i].color!=puk[i-1].color) same=0;              //进入下一个颜色,累加器清零
        while(j+1<N&&puk[j+1].color==puk[i].color&&puk[j+1].num-puk[i].num<N)  //找到最大的满足条件的j
        {
            same+=(puk[j].num==puk[j+1].num);                 //判断是否有重复的牌
            j++;
        }
        ans=min(ans,N-(j-i+1)+same);                                //更新ans
        if(i==j) j++;                                                            //如果i到了j的地方，说明下一张牌与之前的牌都不能组成同花顺
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：用户已注销 (赞：0)

主体思想下面的大神说的已经很清楚了，

首先对于花色和点数进行从小到大的快排，

然后关于每个花色进行贪心，

计算出在同一个同花顺中的最大值之后用总数减掉。

整理了一份稍微简单一些的代码，

其实代码主体部分只用了O(N)，但是无奈快排是O(N logN)的

套用了我最喜欢的滑动窗口

很简单，新手也可以试着理解一下

代码：


```cpp
#include<cstdlib>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define re register
using namespace std;
struct pok
{
    int a,b;
}s[100005];
bool cmp(pok a,pok b){return a.a==b.a?a.b<b.b:a.a<b.a;}//结构体排序，从小到大，花色优先 
int n,ans=0;
void work(int from,int to)
{
```
/\*过滤相同的牌，并归纳到新的数组num中\*/
int num[100005],top=1;//top用来表示数组的大小（也就是不相同的牌的数量）

    num[1]=s[from].b;//输入起点 

    for(re int i=from;i<=to;i++) 

        if(s[i].b!=num[top]) num[++top]=s[i].b;//相同的牌会被抹掉 

/\*滑动窗口，不会请自行百度，这是队列的一种很实用的应用\*/

```cpp
    int left=0,right=1;//left在循环的第一次会+1 
    while(right<top)//窗口的右端点如果已经到了终点就没有再搜的必要 
    {
        left++;//起点右移 
        while(num[right+1]-num[left]<n and right+1<=top) right++;//终点向右滑动 
        ans=max(ans,right-left+1);//计算窗口的尺寸 
    }
    return;
}
int main()
{
    scanf("%d",&n);
    for(re int i=1;i<=n;i++)
        scanf("%d%d",&s[i].a,&s[i].b);
    sort(s+1,s+1+n,cmp);
    int from=1;//当前的花色的起点位置 
    for(re int i=2;i<=n;i++)
        if(s[i].a!=s[from].a)//搜到新的花色的时候，计算上一次的 
        {
            work(from,i-1);//对于每种花色进行一次贪心 
            from=i;//新的花色的起点从这里开始 
        }
    work(from,n);//搜索最后一个花色（因为循环中不会遇到） 
    return !printf("%d\n",n-ans);//ans表达的是属于同一个同花顺中的最多牌数 
}
```

---

## 作者：封禁用户 (赞：0)

#双关键字快排，然后枚举每个最大值中的最小值即可

我文件没关，请不要直接复制代码


```cpp
**type cardd=record
a,b:longint;
end;
var card,b:array[0..100001] of cardd;
n,sum,i,j,ans,max:longint;
 procedure sort1(l,r: longint);
      var
         i,j,x,p: longint;
         y:cardd;
      begin
         i:=l;
         j:=r;
         x:=card[(l+r) div 2].b;
         p:=card[(l+r) div 2].a;
         repeat
           while (card[i].a<p) or ((card[i].a=p) and(card[i].b<x)) do
            inc(i);
           while (p<card[j].a) or ((card[j].a=p) and(card[j].b>x))do
            dec(j);
           if not(i>j) then
             begin
                y:=card[i];
                card[i]:=card[j];
                card[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort1(l,j);
         if i<r then
           sort1(i,r);
      end;
begin
    assign(input,'card.in'); reset(input);
    assign(output,'card.ans'); rewrite(output);
    read(n);
    for i:=1 to n do
     read(card[i].a,card[i].b);
    sort1(1,n);
    sum:=0;
    for i:=1 to n do
    begin
        if (card[i-1].a<>card[i].a) or(card[i-1].b<>card[i].b) then
        begin
            inc(sum);
            b[sum]:=card[i];
        end;
    end;
    max:=0;
    for i:=1 to sum do
    begin
        ans:=0;
        for j:=i downto 1 do
        begin
            if (b[j].a=b[i].a) and (b[i].b-b[j].b+1<=n) then
            inc(ans)
            else break;
        end;
        if ans>max then max:=ans;
    end;
    writeln(n-max);
    close(input);
    close(output);
end.**
```

---


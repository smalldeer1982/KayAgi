# [省选联考 2020 B 卷] 幸运数字

## 题目描述

为庆祝疫情防治取得重大进展，某商场举行酬宾活动，给顾客一些优惠额度，规则如下：

1. 每位顾客可以任意选择一个整数作为自己的幸运数字。
2. 每位顾客的初始优惠额度为 $0$ 元。
3. 商场有 $n$ 个奖励条件，对应不同的奖励额度 $w_i$。
4. 每位顾客需要依次比对这 $n$ 个奖励条件，如果该位顾客选择的幸运数字满足第 $i$ 个条件，那么他的优惠额度就会**异或**上这个条件所对应的奖励额度。

奖励条件共有三种，假设顾客选择的幸运数字为 $x$：

1. 区间型条件，其有两个参数 $L$ 与 $R$，满足条件为 $L \le x\le R$。保证 $L < R$。
2. 相等型条件，其有一个参数 $A$，满足条件为 $x = A$。
3. 不等型条件，其有一个参数 $B$，满足条件为 $x \neq B$。

小炎同学获知了所有奖励条件的信息，他希望知道一位顾客能够得到的最大优惠额度以及对应的幸运数字是多少，请你帮他计算。


## 说明/提示

**样例解释**

幸运数字 $-3$ 满足奖励条件 $2, 3, 4$，奖励额度为 $3\oplus 64\oplus 156 = 223$，其中 $\oplus$ 表
示异或运算。

**数据范围与约定**

$20\%$ 的数据满足：$n, |L|, |R|, |A|, |B| \le 1000$。  
$40\%$ 的数据满足：$n\le 1000$。  
$100\%$ 的数据满足：$1\le n\le 10^5, |L|, |R|, |A|, |B|\le 10^9, 1\le w_i\le 10^9$。


## 样例 #1

### 输入

```
4
1 -100 -80 37
2 -3 3
3 4 64
1 -10 1024 156```

### 输出

```
223 -3```

# 题解

## 作者：VenusM1nT (赞：12)

离散化 + 差分。  
（好久没写代码了，手有点生，见谅）  
观察数据范围，发现代表范围的数据在 $10^9$ 这个级别，而代表点数的 $n\leq 10^5$，于是考虑离散化。  
对于条件 1，因为幸运数字可能等于端点，因此要把 $L-1$ 和 $R+1$ 这两个数字加入离散化数组中；条件 2 和 3 同理，考虑是否等于端点，因此加入 $A-1$ 和 $A+1$ 这两个数字。同时为了保证答案的正确性（绝对值最小），而最后的答案肯定是在离散化数组中取到，因此加入 0 这个数字。（很多题解都加了 $\pm \inf$ 这个值，但我认为既然要绝对值最小那应该就是在端点位置取到的答案，所以不用加。而不加确实也可以通过此题，不知道是不是数据的问题）  
接下来就是差分了，由于对一个数字异或两次数是不变的，所以直接对每个离散化完的点大力异或就可以了。  
具体见代码。
```cpp
#include<bits/stdc++.h>
#define MAXN 100005
#define reg register
#define inl inline
#define inf 1e9
using namespace std;
int n,opt[MAXN],l[MAXN],r[MAXN],val[MAXN],pos[MAXN<<2],tot,ans,Ans,cnt[MAXN<<2];
int main()
{
	scanf("%d",&n);
	pos[++tot]=0;
	for(reg int i=1;i<=n;i++)
	{
		scanf("%d",&opt[i]);
		if(opt[i]==1)
		{
			scanf("%d %d %d",&l[i],&r[i],&val[i]);
			pos[++tot]=l[i]; pos[++tot]=r[i];
			pos[++tot]=l[i]-1; pos[++tot]=r[i]+1;
		}
		else
		{
			scanf("%d %d",&l[i],&val[i]);
			pos[++tot]=l[i]; pos[++tot]=l[i]-1; pos[++tot]=l[i]+1;
		}
	}
	sort(pos+1,pos+tot+1);//离散化
	tot=unique(pos+1,pos+tot+1)-pos-1;
	for(reg int i=1;i<=n;i++)//差分
	{
		l[i]=lower_bound(pos+1,pos+tot+1,l[i])-pos;
		if(opt[i]==1)
		{
			r[i]=lower_bound(pos+1,pos+tot+1,r[i])-pos;
			cnt[l[i]]^=val[i];
			cnt[r[i]+1]^=val[i];
		}
		else if(opt[i]==2)
		{
			cnt[l[i]]^=val[i];
			cnt[l[i]+1]^=val[i];
		}
		else if(opt[i]==3)
		{
			cnt[1]^=val[i];
			cnt[l[i]]^=val[i];
			cnt[l[i]+1]^=val[i];
		}
	}
	ans=cnt[1];
	Ans=1;
	for(reg int i=2;i<=tot;i++)//找最优解
	{
		cnt[i]^=cnt[i-1];
		if(cnt[i]>ans)
		{
			ans=cnt[i];
			Ans=i;
		}
		else if(cnt[i]==ans && abs(pos[i])<=abs(pos[Ans])) Ans=i;
	}
	printf("%d %d\n",ans,pos[Ans]);
	return 0;
}
```

---

## 作者：白木偶君 (赞：12)

## 退役选手来写篇题解

把三种条件全部转化成区间修改

线段树离散化后维护一下

**1.就相当与$[L,R]$异或上 $x$**

**2.相当于一个区间$[A,A]$异或上 $x$**

**3.相当于两个区间$[-1e9,B-1],[B+1,1e9]$异或上 $x$**

根据求答案的绝对值最小，绝对值相同取正数的原则

**先把 $0，1e9,-1e9$ 这些边界加入到离散化数组里**

**1.把 $L-1,L,R+1,R$ 计入答案考虑**

**2.把 $A-1,A,A+1$ 计入答案考虑**

**3.把 $B-1,B,B+1$ 计入答案考虑**

/* 感谢指出，错误已更正 */

可以证明最优答案不会出现在这些点以外的地方

****

提供一个简要而且不那么严谨的证明

对于一个异或值相同的区间$[L,R]$

如果答案为此异或值，那么答案只会有三种情况
> $L$   $(0<L<R)$

> $0$   $(L<0<R)$

> $R$   $(L<R<0)$

根据我们的区间转化原则,有可能存在

对于一个异或值相同的是多个区间$[L1,R1][L2,R2]..$

那也可以把他们认为成独立的多个区间，答案一定也是里面的子集

****

细节问题可以看代码

本人退役选手，菜的一批

我省选写这题的时候就是数组开小了，应该开$4n$长度的线段树

所以这题我考的时候只有35分

很多东西是个人理解,要是说错了什么地方，望告知
```cpp
#include<vector>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
#define lb lower_bound
#define pb push_back
inline int read(){
	int x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-')f=-1; c=getchar(); }
	while('0'<=c&&c<='9'){ x=(x<<3)+(x<<1)+(c^48); c=getchar(); }
	return x*f;
}
const int N=1e6+10;
struct Seg{
	int l,r,sum;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
}tree[N<<2];
#define ls p<<1
#define rs p<<1|1
#define mid ((l(p)+r(p))>>1)
void build(int p,int l,int r){
	l(p)=l,r(p)=r;
	if(l(p)==r(p))return;
	build(ls,l,mid);
	build(rs,mid+1,r);
}
void update(int p,int l,int r,int d){
	if(l<=l(p)&&r(p)<=r){ sum(p)^=d; return; }
	if(l<=mid)update(ls,l,r,d);
	if(r>mid)update(rs,l,r,d);
}
int ans[N<<2];
void query(int p,int d){
	d^=sum(p);
	if(l(p)==r(p)){ ans[l(p)]=d; return; }
	query(ls,d),query(rs,d);
}
int b[N<<2],len;
struct node{
	int t,l,r,w,x;
}e[N];
vector<int>sxr;
signed main(){
	int n=read();
	b[++len]=-1e9; b[++len]=0; b[++len]=1e9;
	for(int i=1,t,l,r,w,x;i<=n;i++){
		t=read();
		if(t==1){
			l=read(),r=read(),w=read();
			b[++len]=l,b[++len]=r;
			b[++len]=l-1,b[++len]=r+1;
		}else{
			x=read(),w=read();
			b[++len]=x;
			b[++len]=x-1;
			b[++len]=x+1;
		}
		e[i]=(node){t,l,r,w,x};
	}
	sort(b+1,b+1+len);
	len=unique(b+1,b+1+len)-b-1;
	build(1,1,len);
	for(int i=1,t,l,r,w,x;i<=n;i++){
		t=e[i].t;
		if(t==1){
			l=e[i].l,r=e[i].r,w=e[i].w;
			l=lb(b+1,b+1+len,l)-b;
			r=lb(b+1,b+1+len,r)-b;
			update(1,l,r,w);
		}else if(t==2){
			x=e[i].x,w=e[i].w;
			x=lb(b+1,b+1+len,x)-b;
			update(1,x,x,w);
		}else if(t==3){
			x=e[i].x,w=e[i].w;
			x=lb(b+1,b+1+len,x)-b;
			if(x>1)update(1,1,x-1,w);
			if(x<len)update(1,x+1,len,w);
		}
	}
	query(1,0);
	int Ans=0;
	for(int i=1;i<=len;i++)
	if(ans[i]>Ans){
		Ans=ans[i];
		sxr.clear();
		sxr.pb(b[i]);
	}else if(ans[i]==Ans)sxr.pb(b[i]);
	printf("%lld ",Ans);
	Ans = -(1ll<<62);
	for(int i=0;i<sxr.size();i++){
		if(abs(sxr[i])<abs(Ans))Ans=sxr[i];
		else if(abs(sxr[i])==abs(Ans))Ans=max(Ans,sxr[i]);
	}
	printf("%lld\n",Ans);
}
```

---

## 作者：BrotherCall (赞：6)

# 小蒟蒻省选前的一篇小题解
看题解里大部分都是离散化+线段树，本蒟蒻在这里提供一种码量很小的思路：

## 扫描线

其具体实现及应用详见 [题解 P2205 【[USACO13JAN]Painting the Fence S】](https://www.luogu.com.cn/blog/BrotherCall/solution-p2205)

实质：用差分实现离散化

口诀：**加点，加点，加点！然后扫描线查询。**

## 回到原题

由于异或的性质：a ^ a = 0 ， 我们可以对三个操作依次做以下处理：

**操作 1** ：分别存下左端点和右端点加一位置的坐标，以及其异或的值。

**操作 2** ：存下该点和该点加一位置的坐标，以及其异或的值。

**操作 3** ：提前进行异或操作，再重复操作 2。

（以上三个操作基于对差分以及扫描线有一定的认知，如果有不明白原因的同学详见 [题解 P2205 【[USACO13JAN]Painting the Fence S】](https://www.luogu.com.cn/blog/BrotherCall/solution-p2205)，里面有我的详细介绍）

**这三个操作的代码如下：**

```cpp
int start = 0;
for(int i=1;i<=n;i++){
	cin>>a;
	if(a == 1){
		cin>>x1>>x2>>x3;
		G[(i << 1) - 1].st = x1;
		G[(i << 1) - 1].sum = x3;
		G[i << 1].st = x2 + 1;
		G[i << 1].sum = x3;
	}
	if(a == 2 || a == 3){
		cin>>x1>>x2;
		G[(i << 1) - 1].st = x1;
		G[(i << 1) - 1].sum = x2;
		G[i << 1].st = x1 + 1;
		G[i << 1].sum = x2;
	}
	if(a == 3) start ^= x2;
}
```

## 你认为这就结束了？
那么恭喜你，可以顺利的获得80分的好成绩！

## 为什么无法AC？
由于异或操作，可能会出现运算后答案变小的情况，且右端点加一位置并不一定比左端点位置的绝对值更小。所以端点附近的点（或者零点）也可能为最优解。

## 解决方案：
**暴力加点！** 将零点以及端点附近的点全部加入线段中。

加入的异或的值为 0 ，因为 a ^ 0 = a 。

这也是思维难度比较小的一种操作方式。

## Code:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define int long long
using namespace std;

int n;
struct qz{
	int sum , st;
}G[1000010];
int cnt = 0;
int a,x1,x2,x3;
int start = 0;
int anss = 0;
int anse = 1e10;

bool compare(qz x1,qz x2){
	return x1.st < x2.st;
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){ //暴力加点部分
		cin>>a;
		if(a == 1){
			cin>>x1>>x2>>x3;
			G[(i << 1) - 1].st = x1;
			G[(i << 1) - 1].sum = x3;
			G[i << 1].st = x2 + 1;
			G[i << 1].sum = x3; //以上为加端点部分
			cnt ++;
			G[2*n + cnt].st = x1 + 1;
			G[2*n + cnt].sum = 0;
			cnt ++;
			G[2*n + cnt].st = x1 - 1;
			G[2*n + cnt].sum = 0;
			cnt ++;
			G[2*n + cnt].st = x2;
			G[2*n + cnt].sum = 0;
			cnt ++;
			G[2*n + cnt].st = x2 - 1;
			G[2*n + cnt].sum = 0;//以上为加附近点部分
		}
		if(a == 2 || a == 3){
			cin>>x1>>x2;
			cnt++;
			G[2*n+cnt].st = x1 - 1;
			G[2*n+cnt].sum = 0;//加附近点
			G[(i << 1) - 1].st = x1;
			G[(i << 1) - 1].sum = x2;
			G[i << 1].st = x1 + 1;
			G[i << 1].sum = x2;//加端点
		}
		if(a == 3)
			start ^= x2;//提前处理好操作3
	}
	cnt++;
	G[2*n+cnt].st = 0;
	G[2*n+cnt].sum = 0; //暴力加入零点
	G[2*n+cnt+1].st = 1e10;//防止零点为最后一个点而被忽略
	sort(G + 1 , G + 1 + 2*n + cnt, compare);//按端点排序
	for(int i=1;i<=2*n+cnt;i++){
		start ^= G[i].sum;
		if(G[i].st == G[i+1].st)continue;//如果该点存在多次操作，则操作完再计算。这也是把(2n+cnt+1)点的位置赋为inf的原因
		if(start > anss) {//处理最大优惠额度
			anse = G[i].st;
			anss = start;
		}
		if(start == anss){
			if(abs(G[i].st) < abs(anse)){
				anse = G[i].st;//处理最优解
			}
		}
	}
	cout<<anss<<" "<<anse;
	return 0;
}
```

总体而言，这是一道细节很多但思维方式较易的题。

$Finally,$ $2021$ $AHOI$ $rp++$

也祝各位都能在省选中取得优异的成绩！

---

## 作者：hfctf0210 (赞：6)

因为没看清最大值相同时输出啥而调了N遍的蒟蒻

其实可以O(n)直接过（离散化&排序除外），线段树是大材小用

条件1：记录L-1,L,R,R+1

条件2、3：记录A-1,A,A+1

同时记录特殊点：-1e9,0,1e9

然后就是区间异或了

已知一个数异或两遍后结果不变

于是可以离散化，采用差分法O(n)就行了
```cpp
#include<bits/stdc++.h>
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
const int N=1e5+7,inf=1e9;
int n,cnt,ans1,ans2,tp[N],a[N],b[N],c[N],d[N<<2],ans[N<<2];
int main()
{
	scanf("%d",&n);
	d[++cnt]=-inf,d[++cnt]=inf,d[++cnt]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&tp[i]);
		if(tp[i]==1)scanf("%d%d%d",&a[i],&b[i],&c[i]),d[++cnt]=a[i],d[++cnt]=b[i],d[++cnt]=a[i]-1,d[++cnt]=b[i]+1;
		else scanf("%d%d",&a[i],&c[i]),d[++cnt]=a[i]-1,d[++cnt]=a[i],d[++cnt]=a[i]+1;
	}
	sort(d+1,d+cnt+1);
	cnt=unique(d+1,d+cnt+1)-d-1;
	for(int i=1;i<=n;i++)
	{
		a[i]=lower_bound(d+1,d+cnt+1,a[i])-d;
		if(tp[i]==1)b[i]=lower_bound(d+1,d+cnt+1,b[i])-d,ans[a[i]]^=c[i],ans[b[i]+1]^=c[i];
		else if(tp[i]==2)ans[a[i]]^=c[i],ans[a[i]+1]^=c[i];
		else ans[1]^=c[i],ans[a[i]]^=c[i],ans[a[i]+1]^=c[i];
	}
	ans1=ans[1],ans2=1;
	for(int i=2;i<=cnt;i++)
	{
		ans[i]^=ans[i-1];
		if(ans[i]>ans1)ans1=ans[i],ans2=i;
		else if(ans[i]==ans1&&abs(d[i])<=abs(d[ans2]))ans2=i;
	}
	printf("%d %d",ans1,d[ans2]);
}
```


---

## 作者：Diaоsi (赞：5)

## 题目链接：[传送门](https://www.luogu.com.cn/problem/P6627)
## 思路：
观察到 $1\leq n\leq 10^5$ 而 $|L|,|R|,|A|,|B|\leq 10^9$ ，考虑将 $L$ , $R$ , $A$ , $B$ 离散化，让他们都在 $n$ 的范围内，此时我们得到了一个空的序列，题目区间的端点都被映射到了序列上。

对于三种操作，我们都可以将其转换为区间操作：

1.对于 $t_i=1$ 的数据，将区间 $[L,R]$ 上所有的值 $\oplus ~ w_i$ 

2.对于 $t_i=2$ 的数据执行单点修改，即将区间 $[A,A]~\oplus ~ w_i$ 

3.对于 $t_i=3$ 的数据，可以修改区间 $(-∞,B)\cup(B,+∞)$ ，也可以根据异或的性质，先对全局进行修改，然后再对区间 $[B,B]~\oplus ~ w_i$ 

~~这样你就拿到了20pts~~

由于异或对答案的贡献不一定为正，所以在离散化时我们应将区间端点的左右节点考虑进去，即：

 $L-1,R+1,A-1,A+1,B-1,B+1$ 

因为题目要求输出绝对值最小的数字当中值最大的，所以答案只会出现在这些端点上。

对于区间修改操作，可以使用差分数组，本人写的是线段树，用延迟标记来维护区间修改。由于只用查询一次，查询的时候可以直接查询线段树的叶子节点并记录答案，最后 $\mathcal{O(n)}$ 扫出最大值。

题目要求输出绝对值最小的数字当中值最大的，可以建立一个结构体并重载运算符，排序后直接输出答案。

## 代 码 放 送：

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$
```cpp
#include<bits/stdc++.h>
#define Max(x,y) (x>y?x:y)
#define Min(x,y) (x<y?x:y)
using namespace std;
const long long N=100010,M=1000010,INF=0x3f3f3f3f;
long long n,a[M<<2],b[M<<2],Ans[M<<4],cnt1,cnt2,cnt3,ans_mx=-INF;
struct node{
	long long t,L,R,A,B,w;
}e[M<<2];
struct Ans{
	long long Sum,Abs;
	bool operator <(const Ans &a)const{
		return(Abs!=a.Abs)?Abs<a.Abs:Sum>a.Sum;
	}
}ans[M];
struct SegmentTree{
	long long l,r;
	long long add;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define add(x) tree[x].add
}tree[M<<2];
void init(){
	sort(a+1,a+cnt1+1);
	for(long long i=1;i<=cnt1;i++)
		if(i==1||a[i]!=a[i-1])b[++cnt2]=a[i];
}
long long query(long long x){
	return lower_bound(b+1,b+cnt2+1,x)-b;
}
void Build(long long x,long long l,long long r){
	l(x)=l,r(x)=r;
	if(l==r)return;
	long long mid=(l+r)>>1;
	Build(x<<1,l,mid);
	Build(x<<1|1,mid+1,r);
}
void Change(long long x,long long L,long long R,long long d){
	long long l=l(x),r=r(x);
	if(L<=l&&r<=R){
		add(x)^=d;
		return;
	}
	long long mid=(l+r)>>1;
	if(L<=mid)Change(x<<1,L,R,d);
	if(R>mid)Change(x<<1|1,L,R,d);
}
void Query(long long x,long long d){
	d^=add(x);
	long long l=l(x),r=r(x);
	if(l==r){Ans[l]=d;return;}
	Query(x<<1,d);
	Query(x<<1|1,d);
}
int main(){
	scanf("%lld",&n);
	a[++cnt1]=-INF,a[++cnt1]=0,a[++cnt1]=INF;
	for(long long i=1;i<=n;i++){
		scanf("%lld",&e[i].t);
		if(e[i].t==1){
			scanf("%lld%lld%lld",&e[i].L,&e[i].R,&e[i].w);
			a[++cnt1]=e[i].L;
			a[++cnt1]=e[i].R;
			a[++cnt1]=e[i].L-1;
			a[++cnt1]=e[i].R+1;
		}
		if(e[i].t==2){
			scanf("%lld%lld",&e[i].A,&e[i].w);
			a[++cnt1]=e[i].A;
			a[++cnt1]=e[i].A-1;
			a[++cnt1]=e[i].A+1;
		}
		if(e[i].t==3){
			scanf("%lld%lld",&e[i].B,&e[i].w);
			a[++cnt1]=e[i].B;
			a[++cnt1]=e[i].B-1;
			a[++cnt1]=e[i].B+1;
		}
	}
	init();
	Build(1,1,cnt2);
	for(long long i=1;i<=n;i++){
		if(e[i].t==1){
			long long L=query(e[i].L);
			long long R=query(e[i].R);
			Change(1,L,R,e[i].w);
		}
		if(e[i].t==2){
			long long A=query(e[i].A);
			Change(1,A,A,e[i].w);
		}
		if(e[i].t==3){
			long long B=query(e[i].B);
			if(B>1)Change(1,1,B-1,e[i].w);
			if(B<cnt2)Change(1,B+1,cnt2,e[i].w);
		}
	}
	Query(1,0);
	for(long long i=1;i<=cnt2;i++)
		ans_mx=Max(ans_mx,Ans[i]);
	for(long long i=1;i<=cnt2;i++)
		if(ans_mx==Ans[i]){
			ans[++cnt3].Sum=b[i];
			ans[cnt3].Abs=abs(b[i]);
		}
	sort(ans+1,ans+cnt3+1);
	printf("%lld %lld\n",ans_mx,ans[1].Sum);
	return 0;
}
```


---

## 作者：E1_de5truct0r (赞：3)

~~第一次见到这么水的省选联考题~~！！qwq

## 思路

这道题的思路很显然，就是维护一个值域，值域上面每一个点表示：$n$ 个操作中，所有**包含这个点的操作**的 $w$ 的异或和。

其实想到这里就差不多是正解了，只是值域比较大，需要进行处理。我们考虑用“扫描线”的思想。

把所有的操作放到数轴上，按照下标进行排序，显然相邻两个操作之间的所有数的值是相同的。因此我们直接用一个点表示这一个区间即可。那么这些点的总和量级是多大呢？$O(n)$。又因为只有一次询问，所以扫一遍即可。

具体的实现细节：我们考虑用一个结构体 $a\{x,w\}$ 表示：值为 $x$ 的位置需要异或上 $w$。那么，对于三种操作显然可以轻松用类似差分的方式来实现，即在开头插入一个运算，末尾插入这个运算的逆运算。而异或的逆运算其实就是异或，所以我们在开头和结尾分别插入一个异或即可。

1. 对于 $op=1$，我们插入两个结构体 $\{l,w\}$ 和 $\{r+1,w\}$，这样，进行到 $l$ 的时候，就可以异或一次 $w$，直到 $[l,r]$ 的区间结束，我们在 $r+1$ 又异或一次 $w$ 抵消了，于是就不会对后续的答案造成影响。

2. 对于 $op=2$，我们直接特化成 $l=1,r=l$ 的情况，看成区间，按照 1 操作处理即可。

3. 对于 $op=3$，我们看成两个区间 $[-\operatorname{INF},y-1]$ 和 $[y+1,\operatorname{INF}]$，按照 1 操作处理即可。

于是我们顺利的完成了修改操作。接下来是扫描线：

1. 如果当前的 $x$ 和上一个 $x$ 相等，那么我们应该一起处理，毕竟同一个位置的操作不可能拆成两次。

2. 如果当前的异或和 $now$ 比最大值大，我们应当果断替换；否则还要判断相等的情况，取绝对值更小的。绝对值相等还要判断值更大的（即正数那个）。

然后就基本完成了这道题。**记得开 `long long` 并且把最大值和最小值弄得更大 / 更小**！我 WA 成 80 分的时候，找了半天才找出来原来是没开 `long long` 见祖宗了。

时间复杂度 $O(n \log n)$，瓶颈在排序。理论用基数排序可以做到 $O(n)$ 的线性复杂度。不知道为啥数据只出到 $10^5$……

~~顺便吐槽一下数据太水了，我没判断绝对值相等的时候取值更大的但是水过去了~~（

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=100005;
const int INF=1145141919810;
struct Node{
	int x,w;
	const bool operator<(const Node &o)const{
		return x<o.x;
	}
}a[MAXN<<2]; // 记得四倍空间！
int calc(int L,int R){ // 返回 [L,R] 中最接近 0 的数
	if(L<0 && R<0) return R;
	if(L>0 && R>0) return L;
	return 0;
}signed main(){
	int n,cnt=0; cin>>n;
	for(int i=1;i<=n;i++){
		int op,x,y,w; cin>>op;
		if(op==1){
			cin>>x>>y>>w;
			a[++cnt]=(Node){x,w};
			a[++cnt]=(Node){y+1,w};
		}else if(op==2){
			cin>>x>>w;
			a[++cnt]=(Node){x,w};
			a[++cnt]=(Node){x+1,w};
		}else{
			cin>>y>>w;
			a[++cnt]=(Node){-INF,w};
			a[++cnt]=(Node){y,w};
			a[++cnt]=(Node){y+1,w};
			a[++cnt]=(Node){INF,w};
		}
	}sort(a+1,a+1+cnt);
	int maxn=-INF,now=0,L,R;
	for(int i=1;i<=cnt;){
		int tmp=i;
		while(a[tmp].x==a[i].x) now^=a[tmp].w,tmp++; // 对相同的位置要一次处理掉
		if(now>maxn){ // 如果大于最大值，果断替换
			maxn=now;
			L=a[i].x;
			R=a[tmp].x-1;
		}else if(now==maxn){ // 如果相等，要判断一下其他条件
			int t1=abs(calc(a[i].x,a[tmp].x-1)); // 记得加绝对值！
			int t2=abs(calc(L,R));
			if(t1<t2) L=a[i].x,R=a[tmp].x-1; // 如果绝对值更小，果断替换
			else if(t1==t2 && calc(a[i].x,a[tmp].x-1)!=calc(L,R)) // 绝对值一样，判断哪个值更大
				if(calc(L,R)<0) L=a[i].x,R=a[tmp].x-1; // 如果原来的值小于 0 那么当前的值一定不会更劣，直接替换即可
		}i=tmp; // 向后跳
	}cout<<maxn<<" "<<calc(L,R); // 输出
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

我们称一个初等的优惠为 $(l,r,w)$ 表示 $[l,r]$ 中每个人获得 $w$ 的优惠。

那么我们的操作事实上是这样的：

- $op=1$，直接加入 $(l,r,w)$。
- $op=2$，加入 $(-\infty,a-1,w)$ 和 $(a+1,+\infty,w)$。
- $op=3$，加入 $(a,a,w)$。

然后离散化+前缀和即可。

注意为了特判极端情况，我加了个 $(0,0,0)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=4e5+10;
int n,tot,w[MAXN],lsh[MAXN];
vector<pair<pair<int,int>,int>> upd;
void insert(int l,int r,int w) {
	lsh[++tot]=l,lsh[++tot]=r+1;
	upd.push_back({{l,r},w});
	return ;	
}
int ans,pos;
void check(int W,int Pos) {
	if(W>ans) return ans=W,pos=Pos,void();
	if(W<ans) return ;
	if(W==ans&&((abs(Pos)<abs(pos))||(abs(Pos)==abs(pos)&&Pos>pos))) return ans=W,pos=Pos,void();
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	insert(0,0,0);
	int mx=1000000000;
	ffor(i,1,n) {
		int op; cin>>op;
		if(op==1) {
			int l,r,w; cin>>l>>r>>w;
			insert(l,r,w);
		}
		if(op==2) {
			int pos,v;
			cin>>pos>>v;
			insert(pos,pos,v);	
		}
		if(op==3) {
			int pos,v;
			cin>>pos>>v;	
			insert(-mx-1,pos-1,v);
			insert(pos+1,mx+1,v);
		}
	}
	sort(lsh+1,lsh+tot+1);
	tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	for(auto pr:upd) {
		int l=pr.first.first,r=pr.first.second+1,v=pr.second;
		l=lower_bound(lsh+1,lsh+tot+1,l)-lsh;
		r=lower_bound(lsh+1,lsh+tot+1,r)-lsh;
		w[l]^=v,w[r]^=v;
	}
	ffor(i,1,tot) w[i]^=w[i-1];
	ffor(i,1,tot) check(w[i],lsh[i]);
	ffor(i,1,tot-1) check(w[i],lsh[i+1]-1);
	cout<<ans<<' '<<pos<<'\n';
	return 0;
}
```

感觉，这题，难度，差不多是，红~橙。

---

## 作者：gdz0214_and_zxb0214 (赞：1)

## 思路
求出所有有意义的值。

何为“有意义”？

“有意义”表示一些处在特殊位置的数据。

有意义的值为：

区间型条件中 $l-1,l,r,r+1$ 四个位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/47pau5mx.png)


相等条件中和不等条件中 $x-1,x,x+1$ 三个位置。
![](https://cdn.luogu.com.cn/upload/image_hosting/fbjt7y3g.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/93h0sxtp.png)

还有初始额度 $0$，极小值 $-10^9$，极大值 $10^9$。

将这些值排序，离散化。

再按题意进行前缀异或，找答案。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[400010],cnt=0,op[100010],a[100010],b[100010],c[100010],qz[400010],n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	s[++cnt]=-1e9,s[++cnt]=0,s[++cnt]=1e9;
	for(int i=1;i<=n;i++){
		cin>>op[i];
		if(op[i]==1){
			cin>>a[i]>>b[i]>>c[i];
			s[++cnt]=a[i]-1;
			s[++cnt]=a[i];
			s[++cnt]=b[i];
			s[++cnt]=b[i]+1;
		}else{
			cin>>a[i]>>c[i];
			s[++cnt]=a[i]-1;
			s[++cnt]=a[i];
			s[++cnt]=a[i]+1;
		}
	}
	sort(s+1,s+1+cnt);
	cnt=unique(s+1,s+1+cnt)-s-1;
	for(int i=1;i<=n;i++){
		int zba=lower_bound(s+1,s+1+cnt,a[i])-s; 
		if(op[i]==1){
			int zbb=lower_bound(s+1,s+1+cnt,b[i])-s;
			qz[zba]^=c[i],qz[zbb+1]^=c[i];
		}else if(op[i]==2){
			qz[zba]^=c[i],qz[zba+1]^=c[i];
		}else if(op[i]==3){
			qz[1]^=c[i],qz[zba]^=c[i],qz[zba+1]^=c[i];
		}
	} 
	int maxx=qz[1],maxj=1;
	for(int i=2;i<=cnt;i++){
		qz[i]^=qz[i-1];
		if(qz[i]>maxx){
			maxx=qz[i];
			maxj=i;
		}else if(qz[i]==maxx&&((abs(s[i])<abs(s[maxj]))||(abs(s[i])==abs(s[maxj])&&s[i]>s[maxj]))){
			maxj=i;
		}
	}
	printf("%d %d\n",maxx,s[maxj]);
    return 0;
}
```

---

## 作者：2huk (赞：1)

注意到答案一定是 $0,A,A-1,A+1,B,B-1,B+1,L,L-1,L+1,R,R-1,R+1$ 这 $\mathcal O(n)$ 个数中的某个。所以我们只需要快速计算这些数的价值。

不难发现这三种奖励条件都可以化归成一个或多个区间。区间型条件当然就是 $[L, R]$，相等型条件是 $[A, A]$，不等型条件是 $(-\infty, B-1]$ 和 $[B+1,\infty)$。我们把这些区间预处理好后，问题变成了：

- $\mathcal O(n)$ 次询问。给定一个数 $x$。求满足 $l_i \le x \le r_i$ 的区间的 $w_i$ 的异或和。

正难则反。上面这个条件不满足，等价于 $x < l_i$ 或 $x > r_i$。而这个东西是很好用 **树状数组** 维护的。注意值域很大需要离散化。

复杂度一只 $\log$。

代码很烂。仅供参考吧。

```cpp
// #define tests
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 1e6 + 10;

int n, cnt;
vector<int> nums;

struct Node {
	int l, r, w;
}a[N];

void add(int x) {
	if (x >= -1e18 && x <= 1e18) {
		nums.push_back(x);
	}
}

void add(int l, int r, int w) {
	a[ ++ cnt] = {l, r, w};
	add(l), add(r), add(l - 1), add(r - 1), add(l + 1), add(r + 1);
}

struct Tree1 {
	int tr[N];
	
	void modify(int x, int d) {
		x = N - x - 1;
		for (int i = x; i < N; i += i & -i) tr[i] ^= d;
	}
	
	int query(int x) {
		x = N - x - 1;
		int res = 0;
		for (int i = x; i; i -= i & -i) res ^= tr[i];
		return res;
	}
}T1;

struct Tree2 {
	int tr[N];
	
	void modify(int x, int d) {
		for (int i = x; i < N; i += i & -i) tr[i] ^= d;
	}
	
	int query(int x) {
		int res = 0;
		for (int i = x; i; i -= i & -i) res ^= tr[i];
		return res;
	}
}T2;

void solve() {
	cin >> n;
	
	add(0);
	
	for (int i = 1; i <= n; ++ i ) {
		int op, l, r, x, w;
		cin >> op;
		if (op == 1) {
			cin >> l >> r >> w;
			add(l, r, w);
		} else if (op == 2) {
			cin >> x >> w;
			add(x, x, w);
		} else if (op == 3) {
			cin >> x >> w;
			add(-1e18, x - 1, w);
			add(x + 1, 1e18, w);
		}
	}

	sort(nums.begin(), nums.end());
	nums.erase(unique(nums.begin(), nums.end()), nums.end());
	
	int mx = -1e18, res_mx = -1e18, res_mn = 1e18;
	
	sort(a + 1, a + cnt + 1,
		[&](Node a, Node b) {
			return a.r == b.r ? a.l < b.l : a.r < b.r;
		});
	
	vector<int> cur = nums;
	for (int i = 1; i <= cnt; ++ i ) {
		cur.push_back(a[i].l);
		cur.push_back(a[i].r);
	}
	
	sort(cur.begin(), cur.end());
	cur.erase(unique(cur.begin(), cur.end()), cur.end());
	
	for (int &v : nums) {
		v = lower_bound(cur.begin(), cur.end(), v) - cur.begin() + 1;
	}
	for (int i = 1; i <= cnt; ++ i ) {
		a[i].l = lower_bound(cur.begin(), cur.end(), a[i].l) - cur.begin() + 1;
		a[i].r = lower_bound(cur.begin(), cur.end(), a[i].r) - cur.begin() + 1;
	}
	
	int sum = 0;
	for (int i = 1; i <= cnt; ++ i ) {
		sum ^= a[i].w;
		T1.modify(a[i].l, a[i].w);
		T2.modify(a[i].r, a[i].w);
	}
	
	int j = 0;
	for (int v : nums) {
		int res = sum ^ T1.query(v + 1) ^ T2.query(v - 1);
		
		if (res > mx) {
			mx = res;
			if (cur[v - 1] < 0) res_mx = cur[v - 1], res_mn = 1e18;
			else res_mn = cur[v - 1], res_mx = -1e18;
		} else if (res == mx) {
			if (cur[v - 1] < 0) res_mx = max(res_mx, cur[v - 1]);
			else res_mn = min(res_mn, cur[v - 1]);
		}
	}
	
	cout << mx << ' ';
	if (abs(res_mx) < abs(res_mn)) cout << res_mx;
	else cout << res_mn;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1;
#ifdef tests
	cin >> T;
#endif
	while (T -- ) solve();
	return 0;
}
```

---

## 作者：Union_Find (赞：1)

如果你想 20 分，就是对每个条件你都在数轴上修改数字的权值，时间复杂度 $O(n^2+k)$，$k$ 就是幸运数字范围。并且用个差分，可以变成 $O(n+k)$。

但是我们发现，数轴上有一大段的值一样，所以我们考虑离散化。过程不用讲，主要是哪些数要离散化。

除了 $l,r,a,b$，因为每个数之间的数也可以是幸运数字，所以这些数 $+1,-1$ 也要离散化。然后就是个 20 分代码贴上去。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define debug() //for (int p = 1; p <= lsn; p++) printf ("%lld ", t[p]); puts("");
ll n, a[4000005], cnt, t[4000005], lsn, rls[4000005], ans, kk, pp;
vector <ll> pos;
map <ll, ll> ls;
struct E{
	ll op, l, r, w;
}p[4000005];
il bool cmp(E a, E b){
	return a.op < b.op;
}
il void add(ll q){
	if (!ls.count(q)) ls[q] = ++lsn, rls[lsn] = q;
}
int main(){
	scanf ("%lld", &n);
	a[++cnt] = -1e9, a[++cnt] = 1e9, a[++cnt] = 0;
	for (int i = 1; i <= n; i++){
		scanf ("%lld", &p[i].op);
		if (p[i].op == 1){
			scanf ("%lld %lld %lld", &p[i].l, &p[i].r, &p[i].w);
			a[++cnt] = p[i].l, a[++cnt] = p[i].r, a[++cnt] = p[i].l - 1, a[++cnt] = p[i].r + 1;
		}
		if (p[i].op == 2){
			scanf ("%lld %lld", &p[i].l, &p[i].w);
			a[++cnt] = p[i].l, a[++cnt] = p[i].l + 1, a[++cnt] = p[i].l - 1;
		}
		if (p[i].op == 3){
			scanf ("%lld %lld", &p[i].l, &p[i].w);
			a[++cnt] = p[i].l, a[++cnt] = p[i].l + 1, a[++cnt] = p[i].l - 1;
		}
	}
	sort (a + 1, a + cnt + 1);
	sort (p + 1, p + n + 1, cmp);
	for (int i = 1; i <= cnt; i++) add(a[i]);
	int i;
	for (i = 1; p[i].op == 1; i++){
		t[ls[p[i].r] + 1] ^= p[i].w;
		t[ls[p[i].l]] ^= p[i].w;
	}
	for (int j = 1; j <= lsn; j++) t[j] ^= t[j - 1];
	debug();
	for (; p[i].op == 2; i++) t[ls[p[i].l]] ^= p[i].w;
	debug();
	for (; p[i].op == 3; i++) kk ^= p[i].w, t[ls[p[i].l]] ^= p[i].w;
	debug();
	for (int j = 1; j <= lsn; j++) t[j] ^= kk;
	debug();
	for (int i = 1; i <= lsn; i++) ans = max(ans, t[i]);
	printf ("%lld ", ans);
	rls[0] = -1e17;
	for (int i = 1; i <= lsn; i++) if (t[i] == ans && (abs(rls[pp]) > abs(rls[i]) || (abs(rls[pp]) == abs(rls[i]) && rls[i] > rls[pp])))
		pp = i;
	printf ("%lld", rls[pp]);
	return 0;
}
```

---

## 作者：2018ljw (赞：1)

由于异或是可以差分的，所以三个操作均可以将其变为同样的形式。用二元组 $(k,val)$ 表示为，若 $x\le k$，则将答案异或上 $val$。

对于操作一，将其拆分为 $(L-1,w)$ 和 $(R,w)$。  
对于操作二，将其拆分为 $(A-1,w)$ 和 $(A,w)$。  
对于操作三，将其拆分为 $(B-1,w)$ 和 $(B,w)$ 和 $(\inf,w)$。

之后就变成有一堆此类限制，如何求解 $f(x)$ 的最大值和对应的 $x$。

关注到按限制的 $k$ 值排序后，一段连续区间的值应当是相同的。所以可以将限制离散化，之后对于每个限制 $(k,v)$，需要计算的点值实际只有 $f(k)$ 和 $f(k+1)$。关注到可能存在最优区间跨过 $0$ 的情况，所以 $f(0)$ 也要计算。

正确性是显然的，若一段区间跨过 $0$，则这段区间直接算 $f(0)$。否则对于其余点，其落点会在一段区间内，必然不优于我们计算的这段区间的开头结尾中的一个。

求出哪些位置的点值要计算后，从小到大枚举，双指针在限制上扫一遍即可。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
const int inf=1e9;
using namespace std;
int n,m,lm[300001],val[300001];
int b[600005],g;
struct ps{
	int x,y;
}d[300001];
bool operator<(ps x,ps y){return x.x<y.x;}
int main(){
	int i,j=0;
	int xr=0,res=0,mp=-inf;
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		int op,l,r,x;
		scanf("%d%d%d",&op,&l,&r);
		if(op==1){
			scanf("%d",&x);
			lm[++m]=r;val[m]=x;
			lm[++m]=l-1;val[m]=x;
			b[++g]=r;b[++g]=r+1;
		}
		if(op==2){
			lm[++m]=l;val[m]=r;
			lm[++m]=l-1;val[m]=r;
			b[++g]=l+1;
		}
		if(op==3){
			lm[++m]=inf;val[m]=r;
			lm[++m]=l;val[m]=r;
			lm[++m]=l-1;val[m]=r;
			b[++g]=l+1;b[++g]=inf;
			xr^=r;
		}
		b[++g]=l;b[++g]=l-1;
	}
	for(i=1;i<=m;i++)d[i]={lm[i],val[i]};
	b[++g]=0;sort(b+1,b+g+1);sort(d+1,d+m+1);
	int k=unique(b+1,b+g+1)-b-1;
	for(i=1;i<=k;i++){
		while(j<m&&d[j+1].x<b[i])xr^=d[++j].y;
		if(xr>res)res=xr,mp=b[i];
		else if(xr==res&&abs(mp)>=abs(b[i]))mp=b[i];
	}
	printf("%d %d",res,mp);
}
```

---

## 作者：MuRongzhang (赞：1)

# 前言
作为一名刚入坑的OIer，本蒟蒻想着能不能冲一下2022年的省选 ~~（然后给巨佬当公分母）~~ ，于是就写了这道题，之后看到各位大佬的题解都或多或少涉及到线段树，我陷入了沉思。。。。。。（线段树刚学，几乎没写过）之后准备来一发不用线段树的题解。

# 题目分析

## 题面

首先奖励金额（设为 $w$ ）的初始值为 $0$，顾客选的初始值为 $x$ 。

（注：下文 $\bigoplus$ 指异或符号）

对于第 $i$ 个条件：
- 如果是第1类，即 $x\in{[L,R]}$，则奖励金额变为 $w \bigoplus w_i$
- 如果是第2类，即 $x\in{[A,A]}$，则奖励金额变为 $w \bigoplus w_i$
- 如果是第3类，即 $x\notin{[B,B]}$，则奖励金额变为 $w \bigoplus w_i$

这些条件对应的区间可以画到数轴上。

## 信息维护方式

由于异或操作可逆，即 $x \bigoplus a \bigoplus a = x$ ，所以我们可以把初始奖励金额设为第3类操作对应的所有 $w_i$ 值进行异或得到的结果，再把第3类操作转化为第2类操作即可。

除此之外，我们可以想象在数轴坐标为 $x = -\infty$ 的地方有一个点，它带着一个 $w$ 值，慢慢地向右移动到 $x = +\infty$。在这个过程中，这个点会进入区间，也会退出区间。进入区间时该点的 $w$ 值就需要异或上该区间对应的 $w_i$ ，退出区间时需要撤销该操作，也就是再次异或 $w_i$ 。

由于判断点进入或退出区间 $[l,r]$ 的关键值是 $l$ 和 $r+1$，所以对于区间信息，我们只需要开一个 $map$，$key$ 存储 $l$ 和 $r+1$，它们对应的 $value$ 都存储为这个区间对应的 $w_i$ 值。如果已经存储过，说明经过这个点需要在异或 $value$ 的基础上再异或 $w_i$，那这个点对应的 $value$ 值就赋值为 $value \bigoplus w_i$。

## 答案在哪里？

这道题需要找到最大值以及取到最大值所在的区间，之后根据区间情况确定“幸运数字”。

### 求最大值，区间

事先在 $map$ 中加入元素 $map[+\infty]=0$ ，把当前得到的奖励金额按照上文来设置为初始值。

将当前区间左，右端点的初始值设为 $-\infty$ ，之后遍历 $map$ 即可。

求出最大值所在的区间 $[l,r)$ 之后，

- 如果 $l<r\leq{0}$，则答案为 $r-1$ ；
- 如果 $0<l<r$，则答案为 $l$ ；
- 否则，答案为 $0$ (说明区间经过 $0$)

注意：取得最大值时的区间可能不止有一个，对于该情况可以考虑把每个区间存下来分别求值。

# 代码

```cpp
#include<iostream>
#include<map>
#include<vector>
using namespace std;

const long long inf=(long long)1e18;

map<long long,long long> mp;//在key的位置要异或value

int n;
long long w[100005];
long long maxn=0;
vector<long long> maxl;
vector<long long> maxr;
long long now=0;
long long nowl=0;
long long nowr=0;
long long ans=inf;
//存储区间为[l,r)

long long absmin(long long a,long long b)
{
    long long x=a;
    long long y=b;
    if(a<0)
    {
        x=-a;
    }
    if(b<0)
    {
        y=-b;
    }
    return (x>y)?b:a;
}

int main()
{
    cin>>n;
    nowl=-inf;
    mp[inf]=0;
    for(int i=0;i<n;i++)
    {
        int opr;
        cin>>opr;
        if(opr==1)
        {
            long long a,b;
            cin>>a>>b>>w[i];
            if(mp.find(a)==mp.end())
            {
                mp[a]=0;
            }
            if(mp.find(b+1)==mp.end())
            {
                mp[b+1]=0;
            }
            mp[a]^=w[i];
            mp[b+1]^=w[i];
        }
        else
        {
            long long a;
            cin>>a>>w[i];
            if(mp.find(a)==mp.end())
            {
                mp[a]=0;
            }
            if(mp.find(a+1)==mp.end())
            {
                mp[a+1]=0;
            }
            mp[a]^=w[i];
            mp[a+1]^=w[i];
            if(opr==3)
            {
                now^=w[i];
            }
        }
    }
    nowr=-inf;
    for(map<long long,long long>::iterator it=mp.begin();it!=mp.end();it++)
    {
        nowl=nowr;
        nowr=it->first;
        if(now>maxn)
        {
            maxl.clear();
            maxr.clear();
            maxn=now;
            maxl.push_back(nowl);
            maxr.push_back(nowr);
        }
        else if(now==maxn)
        {
            maxl.push_back(nowl);
            maxr.push_back(nowr);
        }
        now^=(it->second);
    }
    cout<<maxn<<' ';
    for(int i=0;i<maxl.size();i++)
    {
        if(maxl[i]<0 && maxr[i]<=0)
        {
            ans=absmin(ans,maxr[i]-1);
        }
        else if(maxl[i]>=0 && maxr[i]>0)
        {
            ans=absmin(ans,maxl[i]);
        }
        else
        {
            ans=absmin(ans,0);
        }
    }
    cout<<ans;
    return 0;
}
```

求过qwq

---

## 作者：zhouyixian (赞：1)

三个操作都是区间型异或操作，所以想到差分。

值域很大 $(10^9)$ 但关键点数目不多 $(10^5)$ ,所以想到离散化。

但我很懒，连离散化也不想写，所以想到偷懒。

数组下标达不到 $2e9$ ，但 $map<int,int>$ 可以，把数组换成map就行了。

代码很简单。~~常数也奇大~~ 

```cpp
#include<bits/stdc++.h>
using namespace std;

map<int,int> cnt;
map<int,int>::iterator it,zero;

int main(){
	int n,a,b,c,d;
	cin>>n;
	cnt[-2e9]=cnt[0]=cnt[2e9]=0;
	for(int i=1;i<=n;++i){
		cin>>a>>b>>c;
		if(a==1){
			cin>>d;
			cnt[b]^=d,cnt[c+1]^=d;
		}
		else{
			cnt[b]^=c,cnt[b+1]^=c;
			if(a==3)cnt[-2e9]^=c;
		}
	}
	
	int ans=0,maxn=0,pos=-2e9,maxn2=0,pos2=0;	
	zero=cnt.find(0);
	
	for(it=cnt.begin();it!=zero;++it){
		ans^=it->second;		
		if(ans>=maxn)maxn=ans,it++,pos=it->first-1,it--;
	}
	for(it=zero;it!=cnt.end();++it){
		ans^=it->second;		
		if(ans>maxn2)maxn2=ans,pos2=it->first;
	}
	if(maxn2>maxn||(maxn==maxn2&&pos2<=-pos))maxn=maxn2,pos=pos2;
	cout<<maxn<<" "<<pos<<endl;
} 
```

提醒几点需要注意的：

- 由于这题破事比较多，最好将区间分为零点左右两边分别统计答案，最后再汇总，减少分类讨论，也减小常数。

- 预先把零点加进map，因为零绝对值最小，有可能成为答案。（我为了保险还加了$inf$）

再说离散化做法：

别的题解讲的都很好，这里我只补充一下我的思路：由于这些限制条件没有先后关系，可以把数值附在关键点上，排完序后直接统计答案，省去lower_bound，效率会高一点。

主要代码(变量名有点乱，轻喷。。。）：

```cpp

struct node{
	int val;
	int rng;
	node(int val=0,int rng=0):val(val),rng(rng){}
	bool operator <(node b)const{
		return rng<b.rng;
	}
};
node cnt[N<<1];
#define push(v,r) cnt[++siz]=node(v,r);

int main(){
	register int n,a,b,c,d,siz=0;
	n=read();
	push(0,-2e9);
	push(0,0);
	push(0,2e9);
	for(int i=1;i<=n;++i){
		a=read();
		if(a==1){
			b=read(),c=read(),d=read();
			push(d,b);
			push(d,c+1);
		}else{
			b=read(),c=read();
			push(c,b);
			push(c,b+1);
			if(a==3)cnt[1].val^=c;
		}
	}
	sort(cnt.begin()+1,cnt.begin()+siz+1);
	register int ans=0,num=0,pos=-2e9,last=-2e9,num_=0,pos_=0;
	int zeropoint=lower_bound(cnt.begin()+1,cnt.begin()+siz+1,0)-cnt.begin();
	for(int i=1;i<=zeropoint;++i){
		if(cnt[i].rng!=last){
			if(ans>=num)
				num=ans,pos=cnt[i].rng-1;
			last=cnt[i].rng;
		}
		ans^=cnt[i].val;
	}
	for(int i=zeropoint+1;i<=siz;++i){
		if(cnt[i].rng!=last){
			if(ans>num_)num_=ans,pos_=last;
			last=cnt[i].rng;
		}
		ans^=cnt[i].val;
	}
	if(num_>num||(num==num_&&pos_<=-pos))num=num_,pos=pos_;
	cout<<num<<" "<<pos<<endl;
}

```

---

## 作者：chenxia25 (赞：1)

>[洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6627)

>题意见洛谷。

考虑将三种转化为统一形式。

1. $t=1$。对区间$[L,R]$做贡献；
1. $t=2$。对区间$[A,A]$做贡献；
1. $t=3$。对区间$(-\infty,B-1],[B+1,+\infty)$做贡献。


由于这里我们要将离散化后的一个数表示离散化前的一个区间，所以对于每个上面提到的区间$[l,r]$，要把$l,r+1$塞到离散化序列里。然后就可以愉快地差分了。

由于要比绝对值，要零点分段，方便起见可以再离散化序列里再扔一个$0$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define X first
#define Y second
const int inf=0x3f3f3f3f;
const int N=100000;
int n;
int tp[N+1],a[N+1],b[N+1],c[N+1];
vector<int> nums;
void discrete(){//离散化 
	sort(nums.begin(),nums.end());
	nums.resize(unique(nums.begin(),nums.end())-nums.begin());
	for(int i=1;i<=n;i++)a[i]=lower_bound(nums.begin(),nums.end(),a[i])-nums.begin(),b[i]=lower_bound(nums.begin(),nums.end(),b[i])-nums.begin();
}
int d[3*N];
int main(){
	cin>>n;
	nums.pb(-inf);nums.pb(0);nums.pb(inf);
	for(int i=1;i<=n;i++){
		scanf("%d",tp+i);
		if(tp[i]==1)scanf("%d%d%d",a+i,b+i,c+i),b[i]++/*r+1*/,nums.pb(a[i]),nums.pb(b[i]);
		else scanf("%d%d",a+i,c+i),nums.pb(a[i]),nums.pb(a[i]+1);
	}
	discrete();//离散化 
	for(int i=1;i<=n;i++)//差分 
		if(tp[i]==1)d[a[i]]^=c[i],d[b[i]]^=c[i];
		else if(tp[i]==2)d[a[i]]^=c[i],d[a[i]+1]^=c[i];
		else d[0]^=c[i],d[a[i]]^=c[i],d[a[i]+1]^=c[i];
	int now=0;
	pair<int,pair<int,int> > ans(0,mp(0/*绝对值的相反数，因为小的好*/,0/*值*/));
	for(int i=0;i+1<nums.size();i++){//递推统计差分结果 
		now^=d[i];
		if(nums[i]<0)ans=max(ans,mp(now,mp(nums[i+1]-1,nums[i+1]-1)));//零点左边 
		else ans=max(ans,mp(now,mp(-nums[i],nums[i])));//零点右边 
	}
	cout<<ans.X<<" "<<ans.Y.Y;
	return 0;
}
```

---

## 作者：Sih_qwq (赞：0)

魔怔题。

考场上脑子未响应，然后直接认为离散化不可行导致……（自行想象）。

## 思路

先不考虑数据范围。

对于异或，我们需要知道，$a\bigoplus b\bigoplus b=a$。

类似于加减，只不过是同个符号罢了。

那么对于区间的异或就类似于区间的加减，可以想到用差分解决。

于是对于 $t=1$ 的操作，我们可以用差分来解决。

对于 $t=2$ 的操作，相似的，差分也可以解决。

对于 $t=3$ 的操作，相当于一整个值域都异或上 $x$，然后单点再异或一次 $x$。也是可以差分的。

接下来要考虑数据范围。$n$ 只到 $10^5$，输入的数的个数不超过六位数。离散化就好了，不用想太复杂。有时候，不妨简单一点。

## AC Code

emmm 其实不需要开 `long long`。

注意在离散化的时候，我们需要对每一个输入的点 $l$ 预留出 $l-1$ 和 $l+1$ 两个端点（如果前面没有的话），因为有可能不满足这个点的条件可能优惠额会更高，需要预留出不满足的端点去取最大值。区间也是，区间前后要预留。

还有要注意的，由于题目要求涉及绝对值，我们需要把绝对值为 $0$ 的点手动加进去参与差分前缀和的计算。

代码长得非常魔怔。

主要是离散化和差分，一看就懂的。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
int n, o1, o2, o3, l[N], r[N], a[N], b[N], x1[N], x2[N], x3[N], lsh[N << 2], cf[N << 2], tot, ans, num;
unordered_map < int, int > mp;
int main() {
	scanf("%d", &n);
	for (int i = 1, opt; i <= n; ++i) {
		scanf("%d", &opt);
		if (opt == 1) ++o1, scanf("%d %d %d", l + o1, r + o1, x1 + o1);
		if (opt == 2) ++o2, scanf("%d %d", a + o2, x2 + o2);
		if (opt == 3) ++o3, scanf("%d %d", b + o3, x3 + o3);
	}
	for (int i = 1; i <= o1; ++i) {
		if (!mp[l[i]]) lsh[++tot] = l[i], mp[l[i]] = 1;
		if (!mp[l[i] - 1]) lsh[++tot] = l[i] - 1, mp[l[i] - 1] = 1;
		if (!mp[r[i]]) lsh[++tot] = r[i], mp[r[i]] = 1;
		if (!mp[r[i] + 1]) lsh[++tot] = r[i] + 1, mp[r[i] + 1] = 1;
	}
	for (int i = 1; i <= o2; ++i) {
		if (!mp[a[i]]) lsh[++tot] = a[i], mp[a[i]] = 1;
		if (!mp[a[i] - 1]) lsh[++tot] = a[i] - 1, mp[a[i] - 1] = 1;
		if (!mp[a[i] + 1]) lsh[++tot] = a[i] + 1, mp[a[i] + 1] = 1;
	}
	for (int i = 1; i <= o3; ++i) {
		if (!mp[b[i]]) lsh[++tot] = b[i], mp[b[i]] = 1;
		if (!mp[b[i] - 1]) lsh[++tot] = b[i] - 1, mp[b[i] - 1] = 1;
		if (!mp[b[i] + 1]) lsh[++tot] = b[i] + 1, mp[b[i] + 1] = 1;
	}
	if (!mp[0]) lsh[++tot] = 0, mp[0] = 1;
	sort(lsh + 1, lsh + tot + 1);
	for (int i = 1; i <= tot; ++i) mp[lsh[i]] = i;
	for (int i = 1; i <= o1; ++i) cf[mp[l[i]]] ^= x1[i], cf[mp[r[i]] + 1] ^= x1[i];
	for (int i = 1; i <= o2; ++i) cf[mp[a[i]]] ^= x2[i], cf[mp[a[i]] + 1] ^= x2[i];
	for (int i = 1; i <= o3; ++i) cf[1] ^= x3[i], cf[mp[b[i]]] ^= x3[i], cf[mp[b[i]] + 1] ^= x3[i];
	for (int i = 1; i <= tot; ++i) cf[i] ^= cf[i - 1];
	ans = cf[1], num = 1;
	for (int i = 2; i <= tot; ++i)
		if (cf[i] > ans) ans = cf[i], num = i;
		else if (cf[i] == ans && abs(lsh[i]) <= abs(lsh[num])) num = i;
	printf("%d %d\n", ans, lsh[num]);
	return 0;
} 
```

---

## 作者：BFSDFS123 (赞：0)

思维不够，数据结构来凑。

注意到，三个操作相当于三个区间异或。

- 区间型条件：使区间 $[L,R]$ 中的所有数异或上 $w$。
- 相等型条件：使区间 $[A,A]$ 中的所有数异或上 $w$。
- 不等型条件：使区间 $(-\infty,B-1]$ 和 $[B+1,+\infty)$ 中的所有数异或上 $w$。

因为区间会很大，所以我们需要离散化一下。

是不是只要离散化所有的 $-\infty,+\infty,L,R,A,B-1,B+1$ 就行了呢？

显然不是的。注意到我们选择的这个幸运数字可以不被某个区间包含。容易发现，我们只需要再离散化所有的 $L-1,R+1,A-1,A+1,B$ 就行了。

这时候，我们只需要一个可以维护区间异或，单点求值的数据结构就行了，容易想到线段树可以实现。

怎么用线段树实现呢？

注意到异或的性质：一个数 $x$ 与自己异或偶数次，结果为 $0$；与自己异或奇数次，结果为 $x$。

对于将一个区间 $[l,r]$ 异或上一个数 $x$，当区间长度，也就是 $r-l+1$，是个偶数的时候，当前区间的异或和不变；如果是个奇数，当前区间的异或和就只会异或上一个数 $x$。

pushdown 的时候也是同理的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define eps 1e-8
const int inf=0x3f3f3f3f;
const int Maxn=4e5+10;
struct segmenttree{
	struct segtree{
		int sum;
		int tag;
	}t[Maxn<<2];
	#define ls node<<1
	#define rs node<<1|1
	void pushup(int node)
	{
		t[node].sum=t[ls].sum^t[rs].sum;
	}
	void pushdown(int node,int l,int r)
	{
		if(t[node].tag)
		{
			int mid=(l+r)>>1,len;
			// left
			len=mid-l+1;
			t[ls].tag^=t[node].tag;
			t[ls].sum^=(len%2)*t[node].tag;
			
			// right
			len=r-mid;
			t[rs].tag^=t[node].tag;
			t[rs].sum^=(len%2)*t[node].tag;
			
			t[node].tag=0;
		}
	}
	void update(int node,int l,int r,int ql,int qr,int val)
	{
		if(ql<=l && r<=qr)
		{
			t[node].sum^=((r-l+1)%2)*val;
			t[node].tag^=val;
			return ;
		}
		int mid=(l+r)>>1;
		pushdown(node,l,r);
		if(ql<=mid)
		{
			update(ls,l,mid,ql,qr,val);
		}
		if(qr>mid)
		{
			update(rs,mid+1,r,ql,qr,val);
		}
		pushup(node);
	}
	int query(int node,int l,int r,int pos)
	{
		if(l==r)
		{
			return t[node].sum;
		}
		int mid=(l+r)>>1;
		pushdown(node,l,r);
		if(pos<=mid)
		{
			return query(ls,l,mid,pos);
		}else{
			return query(rs,mid+1,r,pos);
		}
	}
}seg;
struct Queris{
	int opt,x,y,w;
}q[Maxn];
int n;
int tmp[4*Maxn],totnum=0,tmp2[4*Maxn];
int Lens;
map<int,int> mp;
void LSH()
{
	for(int i=1;i<=totnum;i++) tmp2[i]=tmp[i];
	sort(tmp+1,tmp+1+totnum);
	int newn=unique(tmp+1,tmp+1+totnum)-tmp-1;
	Lens=newn;
	for(int i=1;i<=totnum;i++)
	{
		int x=tmp2[i];
		int y=lower_bound(tmp+1,tmp+1+newn,tmp2[i])-tmp;
		mp[x]=y;
	}
}
int main()
{
	scanf("%d",&n);
	tmp[++totnum]=0;
	tmp[++totnum]=-inf;
	tmp[++totnum]=inf;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&q[i].opt);
		if(q[i].opt==1)
		{
			scanf("%d%d",&q[i].x,&q[i].y);
		}else{
			scanf("%d",&q[i].x);
		}
		scanf("%d",&q[i].w);
		
		tmp[++totnum]=q[i].x;
		tmp[++totnum]=q[i].x-1;
		if(q[i].opt!=1) tmp[++totnum]=q[i].x+1;
		if(q[i].opt==1)
		{
			tmp[++totnum]=q[i].y+1;
			tmp[++totnum]=q[i].y;
		}
	}
	
	LSH(); // 离散化
	
	for(int i=1;i<=n;i++)
	{
		int opt=q[i].opt,w=q[i].w;
		if(opt==1)
		{
			int l,r;
			l=mp[q[i].x],r=mp[q[i].y];
			seg.update(1,1,Lens,l,r,w);
		}else if(opt==2){
			int pos;
			pos=mp[q[i].x];
			seg.update(1,1,Lens,pos,pos,w);
		}else{
			int pos;
			pos=mp[q[i].x];
			int L=mp[-inf],R=mp[inf];
			seg.update(1,1,Lens,L,pos-1,w);
			seg.update(1,1,Lens,pos+1,R,w);
		}
		
	}
	
	int ans=0,ansid=0;
	for(auto i:mp) // 存储所有离散化之前的位置
	{
		int ids=i.first;
		int poss=i.second;
		int qu=seg.query(1,1,Lens,poss);
		if(qu>ans)
		{
			ans=qu;
			ansid=ids;
		}else if(qu==ans){
			if(abs(ansid)<abs(ids)) continue;
			if(ansid>ids) continue;
			ansid=ids;
		}
	}
	
	printf("%d %d\n",ans,ansid);
	return 0;
}
```

有两个注意事项：

1. 注意我们线段树维护的序列是**数的序列**，所以当我们离散化完毕，执行区间异或的时候，是 ``update(1,1,Lens,l,r)`` 而不是 ``update(1,1,n,l,r)``。``query`` 同理。
2. 因为我们维护的序列是**数的序列**，所以离散化完毕后，最多会有 $3\times n +2$ 个不同的数（）。所以空间要开到 $3\times 10^5$，不然会 RE。

---


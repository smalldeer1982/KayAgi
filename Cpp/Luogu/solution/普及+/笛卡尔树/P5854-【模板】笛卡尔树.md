# 【模板】笛卡尔树

## 题目描述

给定一个 $1 \sim n$ 的排列 $p$，构建其笛卡尔树。

即构建一棵二叉树，满足：

1. 每个节点的编号满足二叉搜索树的性质。
2. 节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。

## 说明/提示

【样例解释】

| $i$ | $l_i$ | $r_i$ |
| :-: | :-: | :-: |
| $1$ | $0$ | $0$ |
| $2$ | $1$ | $4$ |
| $3$ | $0$ | $0$ |
| $4$ | $3$ | $5$ |
| $5$ | $0$ | $0$ |

【数据范围】

对于 $30\%$ 的数据，$n \le 10^3$。

对于 $60\%$ 的数据，$n \le 10^5$。

对于 $80\%$ 的数据，$n \le 10^6$。

对于 $90\%$ 的数据，$n \le 5 \times 10^6$。

对于 $100\%$ 的数据，$1 \le n \le 10^7$。

## 样例 #1

### 输入

```
5
4 1 3 2 5
```

### 输出

```
19 21
```

# 题解

## 作者：StudyingFather (赞：84)

UPD（2025/08/07）：修复了评论区中提到的问题，感谢评论区各位同学指正！

笛卡尔树是一种非常特殊的二叉搜索树。每个节点有两个信息 $(x_i,y_i)$，如果只考虑 $x$，它是一棵二叉搜索树，如果只考虑 $y$，它是一个小根堆。

（根据上面的定义，Treap 本质上也是一种笛卡尔树）

在保证 $x_i$ 递增的情况下，我们可以在线性时间复杂度内构造一棵笛卡尔树。

每次插入一个新节点时，为了确保二叉搜索树的性质得到满足（别忘了我们按照 $x$ 递增的顺序插入），我们需要将新节点插入到尽可能靠右端的位置。


更具体地来说，我们需要维护一个从根节点一直走右儿子形成的链。我们设当前要插入的点为 $u$，则我们需要在这个链上找到最后一个 $y$ 权值比 $y_u$ 小的点 $v$，将 $v$ 的右儿子设置为 $u$（如果不存在这样的点，那 $u$ 就成为根节点了）；如果 $v$ 已经有右子树了，就将 $v$ 的右子树接在 $u$ 的左子树下面（因为之前插入的点的 $x$ 权值都比 $u_x$ 小，因此这样不会破坏二叉搜索树的性质）。

维护这样一条链可以用栈实现。因为每个节点最多进栈出栈各一次，总时间复杂度是 $O(n)$ 的。

```cpp
void build()
{
 int top=0,cur=0;
 for(int i=1;i<=n;i++)
 {
  cur=top;
  while(cur&&p[sta[cur]]>p[i])
   cur--;
  if(cur)
   rs[sta[cur]]=i;
  if(cur<top)
   ls[i]=sta[cur+1];
  sta[++cur]=i;
  top=cur;
 }
}
```

---

## 作者：MuYC (赞：57)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/MuYC/solution-p5854)

#### 笛卡尔树的定义：

笛卡尔树是一种二叉树，每一个结点由一个键值二元组 $(k,w)$ 构成。要求 $k$ 满足二叉搜索树的性质，而 $w$ 满足堆的性质。一个有趣的事实是，如果笛卡尔树的 $(k,w)$ 键值确定、并且 $k$ 不相同， $w$ 不相同，那么这个笛卡尔树的结构是唯一的。

`--- 摘取自 OIWIKI`

![](https://oi-wiki.org/ds/images/cartesian-tree1.png)

（维基百科上面的图片）

#### 如何建树

给定一个序列 $A$ （默认其没有重复元素），下面建树的过程以小根堆为例，定义序列中第 $i$ 个元素的键值为 $(i,A_i)$，也就是 $i$ 对应 $k$ ， $A_i$ 对应 $w$。

定义一棵树的**右链**为从根出发一直往右儿子方向能够到达的所有点按照深度从浅到深排序后而形成的一条链。

因为我们的键值 $k$ 是数组下标，所以我们不需要排序，直接从数组的左边往右边插入可以。

假设我们现在插入的是节点 $u$，我们为了维护下标满足二叉搜索树的性质，肯定每次都是往树的**右链**的末端插入，但是我们此时要维护堆的性质。

+ $1.$ 如果恰好 $w_u$ 大于当前右链末端端点的 $w$ 即直接将 $u$ 插入到 右链的末端。

+ $2.$ 如果 $w_u$ 小于当前右链的末端端点的 $w$，那么意味着 $u$ 应当在树上是 **当前右链** 末端端点的祖先，于是我们继续往上找，直到遇到满足第一种情况的点。

假如我们在右链上找到了一个点 $j$ 使得 $w_j < w_u$ ，那么就把 $j$ 的右儿子作为 $u$ 的左儿子，$j$ 的右儿子变为 $u$，然后我们就完成了插入这个 $u$。

如果没有找到任何一个点可以小于 $w_u$，那么 $w_u$ 就会成为新的右链的根节点。

具体建树的例子可以看这里：[OIWIKI - 笛卡尔树](https://oi-wiki.org/ds/cartesian-tree/)

可以发现上面的过程可以用单调栈维护右链，具体可以康康代码呀。

#### 笛卡尔树的一些性质

+ 对于原正整数序列建树以后，区间 $[l,r]$ 的极值即是树上 $l$ 所在位置以及 $r$ 所在位置的 $LCA$，运用这个性质可以做到 $O(n)-O(1)$ 的**在线解决**区间 `RMQ` 问题（但是得结合 `+1/-1 RMQ` 来做，编码复杂度很高，不建议使用）。

    ps.具体做法即先对原序列建一棵笛卡尔树，随后对这棵笛卡尔树做 `O(n) - O(1) LCA` 即可， `O(n) - O(1) LCA` 即可以用 `+1/-1 RMQ` 解决，`+1/-1 RMQ` 具体可以参见 `2017 - 徐明宽 《非常规大小分块算法初探》` 论文中提到的方法，不再赘述。

+ 可以很容易的维护一个数在原序列的前驱后继，因为恰好它的下标键值满足二叉搜索树的性质，而且权值满足堆的性质，所以，可以通过 $DFS$ 获取前驱后继等，但是常数貌似比单调栈还大。

+ 综上，笛卡尔树的主要作用还是在于处理区间 `RMQ` 问题，处理其它问题并没有明显优势。


#### 模板代码

其实大家写得应该都差不多吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++)
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
typedef long long LL;
const int MAXN = 1e7 + 50;
int n, A[MAXN], tack[MAXN], top = 1, ls[MAXN], rs[MAXN];
LL ans1, ans2;

int main() {
    n = read(); tack[1] = 1;
    for(int i = 1 ; i <= n ; i ++) A[i] = read();
    for(int i = 2 ; i <= n ; i ++) {
        while(A[tack[top]] > A[i] && top) top --; // 弹栈
        if(!top) ls[i] = tack[top + 1]; // 如果右链中没有一个比它大的元素，它就成了右链的链顶并且原来的链顶就是它的左儿子
        else ls[i] = rs[tack[top]], rs[tack[top]] = i; // 想象一下把点 i 插入到某个点的下方，也就是说原本那个点的右儿子要变成 i 的左儿子，然后 i 来充当这个右儿子
        tack[++ top] = i;
    }
    for(int i = 1 ; i <= n ; i ++) {
        ans1 ^= (1ll * i * (ls[i] + 1));
        ans2 ^= (1ll * i * (rs[i] + 1));
    } printf("%lld %lld", ans1, ans2);
    return 0;
}
// Author : MuYC
```

---

## 作者：ql12345 (赞：43)

# 笛卡尔树
	
#### 通过两个题目更好地理解笛卡尔树
    
## [【模板】笛卡尔树](https://www.luogu.com.cn/problem/P5854)

### Part 1：定义
定义和[Treap](https://www.luogu.com.cn/problem/P3369)相同：（Treap是权值随机的笛卡尔树）

- k满足二叉搜索树性质

- w满足[小根堆](https://www.luogu.com.cn/problem/P3378)性质

本题下标为k，元素为w（题目定义）

正常构建的Treap应该是下标为w，元素为k（可以模拟插入过程理解） 例题：[树的序](https://www.luogu.com.cn/problem/P1377)
（下面有代码）

### Part 2：构建

#### 用[单调栈](https://www.luogu.com.cn/problem/P5788)维护插入的位置

（下标已经单调递增了，所以新插入的点只能是已前面点的右儿子、前面点只能是它的左儿子）
      
- 用单调栈维护一个权值单调递增的下标序列，

- 插入一个点时插入到第一个比它小的点（如果有的话）（作为右儿子）后，如果遇到了比它大的点，将最后一个比它大的点作为左儿子

### code

```cpp
#include<bits/stdc++.h>
#define re register
#define il inline
#define LL long long
using namespace std;
template<typename T>il void read(T &ff){
    T rr=1;ff=0;re char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')rr=-1;ch=getchar();}
    while(isdigit(ch)){ff=(ff<<1)+(ff<<3)+(ch^48);ch=getchar();}
    ff*=rr;
}
const int N=1e7+7;
int n,a[N],stk[N],ls[N],rs[N];
LL L,R;
signed main(){
    read(n);
    for(re int i=1,pos=0,top=0;i<=n;++i){//这是按下标顺序插入元素的代码
        read(a[i]);
        //除了上述的维护左右儿子就是普通单调栈啦
        pos=top;
        while(pos&&a[stk[pos]]>a[i])pos--;
        if(pos)rs[stk[pos]]=i;
        if(pos<top)ls[i]=stk[pos+1];
        stk[top=++pos]=i;
    }
    for(re int i=1;i<=n;++i)L^=1LL*i*(ls[i]+1),R^=1LL*i*(rs[i]+1);
    printf("%lld %lld",L,R);
    return 0;
}
```

## [树的序](https://www.luogu.com.cn/problem/P1377)

### 题意：

给一个生成序列，建出一棵笛卡尔树，求字典序最小的可以得到相同笛卡尔树的生成序列

### 题解

按题意建好树之后输出[先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin)即可

建树略有不同（代码中有注释）

### code

```cpp
复杂度 O(N)
#include<bits/stdc++.h>
#define re register
#define il inline
#define LL long long
using namespace std;
template<typename T>il void read(T &ff){
    T rr=1;ff=0;re char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')rr=-1;ch=getchar();}
    while(isdigit(ch)){ff=(ff<<1)+(ff<<3)+(ch^48);ch=getchar();}
    ff*=rr;
}
const int N=1e5+7;
int n,a[N],stk[N],ls[N],rs[N];
void dfs(re int x){
    if(x)printf("%d ",x),dfs(ls[x]),dfs(rs[x]);
}
signed main(){
    read(n);
    for(re int i=1,x;i<=n;++i)read(x),a[x]=i;//与笛卡尔树模板不同之处
                                            //这里“把权值当做下标，以下标为权值‘输入’a数组”，就转化成板子啦
    for(re int i=1,pos=0,top=0;i<=n;++i){
        pos=top;
        while(pos&&a[stk[pos]]>a[i])pos--;
        if(pos)rs[stk[pos]]=i;
        if(pos<top)ls[i]=stk[pos+1];
        stk[top=++pos]=i;
    }
    dfs(stk[1]);
    return 0;
}
```


---

## 作者：Ireliaღ (赞：17)

# 笛卡尔树

## 性质

笛卡尔树是一种由对数列构建成的二叉树。它满足三个性质：

1. 它的中序遍历是原数列

2. 任意一个节点的值都$>$它的两个儿子节点的值

3. 两个点的$lca$就是它们的$RMQ$

## 构建

如果学过`Treap`，那么大家都会以$n\log n$的复杂度来构建这棵树。但是我们的数据范围是$10^7$，所以我们需要$O(n)$的构建方法，即单调栈。

由于第1条性质, 插入的新节点一定在二叉树的右子树链上.

维护一个右子树链的栈, 进行以下操作:

1. 插入一个新节点 $p$

2. 如果栈顶元素 $u$ 的值小于 $p$, 弹出 $u$, 并将其设为 $p$ 的左儿子，否则, $p$ 为 $u$ 的右儿子.

3. 最后, 栈顶元素即为树的根.

代码如下

```cpp
struct Node{
	Node *ch[2];
	int id, val;
	Node() {}
	
	Node(int id, int val) : id(id), val(val) {
		ch[0] = ch[1]  = NULL;
	}
}npool[MAXN];

Node *rt[MAXN], *root;
int n;
int a[MAXN];
Node *sta[MAXN];
int top;

Node *Build() {
	Node *now = NULL, *nxt = NULL, *las = NULL;
	for (int i = 1; i <= n; i++) {
		npool[i] = Node(i, a[i]);
		nxt = rt[i] = &npool[i];
		las = NULL;
		while (top) {
			if (sta[top]->val < nxt->val) {
				now = sta[top];
				if (now->ch[1]) {
					nxt->ch[0] = now->ch[1];
				}
				now->ch[1] = nxt;
				break;
			}
			las = sta[top--];
		}
		if (!top && las) {
			nxt->ch[0] = las;
		}
		sta[++top] = nxt;
	}
	while (!top) now = sta[top--];
	return now;
}

```

## 代码

由于~~某谷对指针用户有严重种族歧视~~评测姬是64位，不在空间卡卡常的话就会MLE，所以有些地方写法会略为奇怪，但是以前的代码注释上了。

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
const int MAXN = 1e7 + 5;

int getc() {
	static char buf[100000];
	static int l = 0, r = 0;
	if (l == r) {
		l = 0;
		r = fread(buf, 1, 100000, stdin);
	}
	return (l == r) ? EOF : buf[l++]; 
}

int geti() {
	int f = 1, x = 0;
	char c = getc();
	while (c < '0' || c > '9') f = (c == '-' ? -1 : 1), c = getc();
	while (c >= '0' && c <= '9') x = x * 10 + (c ^ '0'), c = getc();
	return f * x;
}

struct Node{
	Node *ch[2];
	int id, val;
	Node() {}
	
	Node(int id, int val) : id(id), val(val) {
		ch[0] = ch[1] = NULL;
	}
}npool[MAXN];

//Node *rt[MAXN]
Node *root;
int n;
Node *sta[MAXN];
int top;

Node *Build() {
	Node *now = NULL, *nxt = NULL, *las = NULL;
	for (int i = 1; i <= n; i++) {
		npool[i].id = i;
//		nxt = rt[i] = &npool[i];
		nxt = &npool[i];
		las = NULL;
		while (top) {
			if (sta[top]->val < nxt->val) {
				now = sta[top];
				if (now->ch[1]) nxt->ch[0] = now->ch[1];
				now->ch[1] = nxt;
				break;
			}
			las = sta[top--];
		}
		if (!top && las) nxt->ch[0] = las;
		sta[++top] = nxt;
	}
	while (!top) now = sta[top--];
	return now;
}

int main() {
	n = geti();
//	for (int i = 1; i <= n; i++) a[i] = geti();
	for (int i = 1; i <= n; i++) npool[i].val = geti();
	root = Build();
	long long ans1 = 0, ans2 = 0;
//	for (int i = 1; i <= n; i++) {
//		ans1 ^= 1LL * rt[i]->id * ((rt[i]->ch[0] ? rt[i]->ch[0]->id : 0) + 1);
//		ans2 ^= 1LL * rt[i]->id * ((rt[i]->ch[1] ? rt[i]->ch[1]->id : 0) + 1);
//	}
	for (int i = 1; i <= n; i++) {
		ans1 ^= 1LL * i * ((npool[i].ch[0] ? npool[i].ch[0]->id : 0) + 1);
		ans2 ^= 1LL * i * ((npool[i].ch[1] ? npool[i].ch[1]->id : 0) + 1);
	}
	printf("%lld %lld\n", ans1, ans2);
	return 0;
}
```

---

## 作者：VinstaG173 (赞：13)

笛卡尔树模板。

### 关于笛卡尔树

如题面中所说，笛卡尔树是一棵二叉树，每个结点有两个权值，满足以下性质：

1. 按第一个权值看满足二叉搜索树性质（BST性质）；

2. 按第二个权值看满足小根堆性质。

有关性质解释：

这棵树的每个结点有两个子树，分为左右子树，子树可以为空；

一个结点的左子树中的所有结点的第一个权值都小于其第一个权值（空子树也满足）；

一个结点的右子树中的所有结点的第一个权值都大于其第一个权值（空子树也满足）；

一个结点的两棵子树中的所有结点的第二个权值都大于其第二个权值（空子树也满足）。

题目结出了$1$至$N$的一个排列$p$，表示$i$号结点的第一个权值为$i$，第二个权值为$p_i$，要求我们构造出对应的笛卡尔树，标出每个结点的左儿子和右儿子的编号。

如题目样例给出的排列构造出的树是这样的：

![笛卡尔树.png](https://i.loli.net/2019/12/27/LYTJBA8NnvHhxXC.png)

我们知道由于有堆性质，每个结点到根的链上深度从小到大第二个权值是单调递增的。

又因为BST性质，所以每个结点在第一个权值比其小的结点都被插入后肯定没有右子树，而且肯定不在任意一个已有结点的左子树上。

于是我们想到按第一个权值，在题目中即结点编号，从小到大每次插入一个结点，肯定会插入到从根开始一直访问右儿子直到没有右儿子为止的一条链上某个位置，满足这个位置原来的结点第二个权值大于新插入的结点的第二个权值，且原来结点的父亲结点的第二个权值小于新插入的结点的第二个权值。

我们只要用单调栈处理这样的一条链，找到这个结点后将它的位置设置为新插入的结点并将其变成新插入的结点的左子树即可。

时间复杂度$O(n)$。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
int N;
int a[10000007],d[10000007];
int s[10000007],top;
int ch[10000007][2];
ll lrs,rrs;
inline char rc()
{
	static char buf[1000000],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1000000,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int f=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')f=f*10+cc-'0',cc=rc();
	return f;
}
int main()
{
	N=read();
	for(rg int i=1;i<=N;++i)a[i]=read();
	top=0;
	s[++top]=0;
	for(rg int i=1;i<=N;++i)
	{
		while(top&&a[s[top]]>a[i])ch[i][0]=s[top--];
		if(s[top])ch[s[top]][1]=i;
		s[++top]=i;
	}
	lrs=rrs=0;
	for(rg int i=1;i<=N;++i)
	{
		lrs^=1ll*i*(ch[i][0]+1);rrs^=1ll*i*(ch[i][1]+1);
	}
	printf("%lld %lld\n",lrs,rrs);
	return 0;
}
```

---

## 作者：BFSDFS123 (赞：11)


为啥要写呢，因为今年CSP考了。不能说完全一样，只能说差不多



----

其实，笛卡尔树和笛卡尔的关系就如雷峰塔和雷锋的关系一样没有任何关系

---

什么是笛卡尔树：

1. 笛卡尔树是一种特殊的**二叉树**数据结构
2. 可以用线性的时间完成建树（由此也可以看出，其实平衡树也能线性时间建树）
3. 笛卡尔树是用栈进行构建的（

大家都应该学过二叉查找树，笛卡尔树也满足二叉查找树的性质：

**树中的元素按照中序遍历得到的序列为原数组序列**

还记得二叉查找树为什么死了吗？

因为可以通过使用特殊手段将二叉查找树退化成链。

解决办法是可以使用平衡树，但是对于一些题来说太麻烦了。于是我们就可以使用不满足平衡性质的**笛卡尔树**来解决一些题目。

---

**建树方法：**

在栈中存储根节点和右节点。

每次插入新节点时需看是否满足笛卡尔树的性质：

如不满足，则将栈顶的元素弹出，并将其作为新节点的左儿子。

如满足，则把新节点当作栈顶的元素的右儿子，并将其入栈。

总体来说，就是一个模仿单调栈的方法。

代码如下：

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define ull unsigned long long
#define ll long long
using namespace std;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		{
			w=-1;
		}
		ch=getchar();
	}
	while(isdigit(ch))
	{
		s=s*10+(ch-'0');
		ch=getchar();
	}
	return w*s; 
}
const int Maxn=1e7+10;
int n,Ar[Maxn];
int siz;

int ch[Maxn][2];

long long ans1,ans2;
long long st[Maxn];

int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		//scanf("%d",&Ar[i]);
		Ar[i]=read();
	}
	for(int i=1;i<=n;i++)
	{
		int node=0,j;
		while(siz>0 && Ar[st[siz]]>Ar[i])
		{
			j=st[siz--];
			ch[j][1]=node;
			node=j;
		}
		ch[i][0]=node;
		st[++siz]=i;
	}
	int node=0,j;
	while(siz)
	{
		j=st[siz--];
		ch[j][1]=node;
		node=j;
	}
	for(int i=1;i<=n;i++)
	{
		ans1=ans1 xor (long long)(i*(long long)(ch[i][0]+1));
		ans2=ans2 xor (long long)(i*(long long)(ch[i][1]+1));
	}
	printf("%lld %lld",ans1,ans2);
	return 0;
}

```

---

温馨提示：

1. 不开 long long 见祖宗
2. 不写快读会TLE的


---

例题：

[P1377](https://www.luogu.com.cn/problem/P1377) （板子）

[P4755](https://www.luogu.com.cn/problem/P4755) （笛卡尔树+CDQ分治）

[P3246](https://www.luogu.com.cn/problem/P3246) （笛卡尔树乱搞）

---

## 作者：_Yoimiya_ (赞：4)

[题目传送门。](https://www.luogu.com.cn/problem/P5854)

前置知识： BST （二叉搜索树）+ 单调栈。
### 笛卡尔树
- 概念：一棵二叉树，每个节点的编号满足二叉搜索树的性质，每个节点的权值满足小根堆的性质（来自题目）。  

- 建树方法：因为每个节点的编号满足二叉搜索树的性质，后面的点编号比前面的大，所以要么前面的节点是后来的节点的左儿子，要么后面的节点是前面节点的右儿子。  
- 因此，我们可以用单调栈来维护一个权值单调递增的下标序列，插入一个点时，如果比栈顶元素大，则将栈顶元素作为插入点的左儿子，否则将插入点作为栈顶元素的左儿子。过程结束后，栈顶元素就是这棵笛卡尔树的根。
```cpp
   for(register int i(1);i<=n;++i){
 	 while(top&&a[d[top]]>a[i]) tr[i][0]=d[top--];
 	 if(d[top]) tr[d[top]][1]=i;
 	 d[++top]=i;
   }
```
了解建树后，就按题意把树建好，就可以统计答案了。  

注意事项：本题需要卡常，请使用快读。

AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M(1e7+1);
int a[M],d[M],tr[M][2];
inline int read(){
	register int x(0),f(1);register char c(getchar());
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
	return x*f;
}
signed main(){
	int n(read());
	for(register int i(1);i<=n;++i) a[i]=read();
	int top(1);
	for(register int i(1);i<=n;++i){
		while(top&&a[d[top]]>a[i]) tr[i][0]=d[top--];
		if(d[top]) tr[d[top]][1]=i;
		d[++top]=i;
	}
	long long l(0),r(0);
	for(register int i(1);i<=n;++i){
		l^=1ll*i*(tr[i][0]+1);r^=1ll*i*(tr[i][1]+1);
	}
	cout<<l<<' '<<r;
	return 0;
}
```

---

## 作者：cppascalinux (赞：4)

# 一个和其他题解都不一样的~~乱搞~~做法
首先我们考虑直接按照笛卡尔树的定义去递归建树 , 那么就需要算 $RMQ$ , 这样做是 $O(nlogn)$ 的 , 显然会超时..  
直接去找每个点的左右儿子貌似很困难 , 于是就考虑去找每个点的父亲  
然后我画了几个例子..貌似找到了几个结论qwq

## 结论1
**考虑节点 $x$ , 令 $a$ 表示满足 $a<x$ 且 $p_a<p_x$ 的最大的 $a$ (即 $x$ 左侧第一个小于它的位置) , 令 $b$ 表示满足 $b>x$ 且 $p_b<p_x$ 的最小 $b$ (即 $x$ 右侧第一个小于它的位置) , 那么 $x$ 在笛卡尔树上的的父亲 $fa$ 一定是 $a$ 或者 $b$**

***证明*** : 反证法 , 若 $fa$ 在 $x$ 左侧且不是 $a$ , 那么一定有 $p_{fa}<p_x$ , 故 $fa<a$ (因为 $(a,x)$ 中的元素权值都大于 $p_x$ ) , 又因为要满足二叉搜索树的性质 , 故 $a$ 一定在 $x$ 的左子树中 , 这与小根堆的性质矛盾 , 所以若 $fa$ 位于 $x$ 左侧 , 一定有 $fa=a$   
同理如果 $fa$ 位于 $x$ 右侧 , 一定有 $fa=b$ , 得证

![证明1图解](https://i.loli.net/2020/07/20/DJgsuoHpNkTWPrf.png)

## 结论2
**进一步地 , $fa$ 一定是 $a$ , $b$ 中权值较大的一个**

***证明*** : 反证法 , 不妨假设 $p_a<p_b$ , 且 $fa=a$ , 那么从 $a$ 向祖先走 , 若从右儿子走向父亲 , 就记作 ***向左走*** , 否则记作 ***向右走***  
将第一次向右走时 , 走到的点记作 $c$ , 那么根据中序遍历的原理 , $c$ 一定是 $x$ 的子树之后的第一个元素 , 且根据堆的性质有 $p_c<p_x$ , $x$ 的子树中的点权值都大于等于 $x$ , 所以 $c$ 就是 $x$ 右侧第一个小于他的位置 , 也就是 $c=b$  
所以有 $p_a<p_b$ , 且 $b$ 为 $a$ 的祖先 , 这与小根堆的性质矛盾 , 故 $fa\ne a$ , 结合结论1得知 $fa=b$  
当 $p_a>p_b$ 时 , 同理可得 $fa=a$

![证明2图解](https://i.loli.net/2020/07/20/2eOWMrPZG9hb1S7.png)

## 做法
推出这个结论之后 , 就可以用单调栈去找出每个点左侧 , 右侧第一个权值小于它的位置 , 然后找出它的父亲 , 再判断它是左/右儿子就行 , 注意处理空儿子的情况...时间复杂度 $O(n)$ ...有点卡常

## 代码:
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define GC() (p1==p2&&(p2=(p1=buf1)+fread(buf1,1,10000000,stdin),p1==p2)?EOF:*p1++)
using namespace std;
char *p1,*p2,buf1[10000009];
int n;
int p[10000009];
int lm[10000009],rm[10000009],st[10000009];
void rd(int &x)//快速读入
{
	char c=0;
	x=0;
	while(c<'0'||c>'9')
		c=GC();
	while(c>='0'&&c<='9')
		x=x*10+(c&15),c=GC();
}
void init()//用单调栈得到每个点左/右第一个小于它的位置
{
	int tp=0;
	for(int i=n;i>=1;i--)//左侧
	{
		while(tp&&p[i]<p[st[tp]])
			lm[st[tp--]]=i;
		st[++tp]=i;
	}
	tp=0;
	for(int i=1;i<=n;i++)//右侧
	{
		while(tp&&p[i]<p[st[tp]])
			rm[st[tp--]]=i;
		st[++tp]=i;
	}
}
void solve()//计算每个点的父亲,判断左,右儿子,注意空儿子的情况
{
	LL ansl=0,ansr=0;
	for(int i=1;i<=n;i++)
		ansl^=i,ansr^=i;//先异或上所有空儿子的
	for(int i=1;i<=n;i++)
	{
		int tl=lm[i],tr=rm[i];
		if(tl&&tr)//左/右均有小于它的位置
		{
			if(p[tl]>p[tr])
				ansr^=tl^((LL)tl*(i+1));//再次异或,抵消空儿子的异或值
			else
				ansl^=tr^((LL)tr*(i+1));
		}
		else if(tl)//只有左侧有
			ansr^=tl^((LL)tl*(i+1));
		else//只有右侧有
			ansl^=tr^((LL)tr*(i+1));
	}
	printf("%lld %lld",ansl,ansr);
}
int main()
{
	rd(n);
	for(int i=1;i<=n;i++)
		rd(p[i]);
	init();
	solve();
	return 0;
}
```

---

## 作者：Cxny (赞：3)

笛卡尔树的定义题目已经讲得比较清楚了qwq

若 $tree(i)_1$ 表示笛卡尔树中下标为 $i$的数的关键字一(本题中即为数组下标)， $tree(i)_2$ 为关键字二，那么对于数上的每一个非叶子节点 $i$ 与其左孩子 $l$ 与右孩子 $r$ ，有 $tree(l)_1<tree(i)_1< tree(r)_1$  (满足**二叉搜索树**)，且$tree(i)_2\le tree(l)_2\,$, $tree(i)_2\le tree(r)_2$ (满足**小根堆**)。

---

那么如何建立笛卡尔树呢？

可以考虑**建立一个栈**，栈中元素为**根节点及其右子树**，栈底元素为根节点。

枚举每一个元素，若该元素大于栈顶元素，即**不满足小根堆**时，可**将栈中大于它的子节点作为它的左孩子**。

即**将栈中不满足条件的元素弹出，并记录最靠近根节点的一个节点，将其作为当前节点的孩子**。此时当前节点的**左**孩子稳定且不再变动，直接记录为答案。

弹出节点的右孩子**也不再变动**，记录答案。

若满足条件，则将其入栈，但**此时无法确定其父节点及其子节点**。

枚举完之后，记录栈中元素的右孩子。

这样就可以保证生成的树满足笛卡尔树的定义。

最后处理一下答案就行啦~

需要注意，本题**读入量巨大**，需要使用**快速读入**！

## 代码

```cpp
//不开long long见祖宗啊qwq 
//还有开long long要注意空间 
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000010;
int val[maxn];
long long chi[maxn][2],stk[maxn];
//chi[i][0]:i节点左孩子 
int size,n;
//读入优化 
inline char Getchar(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return ((p1==p2) && (p1=(p2=buf)+fread(buf,1,1000000,stdin),p1==p2))?EOF:*p2++;
}
inline int read(){
	int ans=0,f=1;
	char c=Getchar();
	while(c<'0' || c>'9'){if(c=='-') f=-1;c=Getchar();} 
	while(c>='0' && c<='9') ans=(ans<<3)+(ans<<1)+c-'0',c=Getchar();
	return ans*f;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		val[i]=read();
	}
	//枚举每一个子节点 
	for(int i=1;i<=n;i++){
		int p=0,j;
		//将不满足小根堆的节点弹出 
		while(size>0 && val[stk[size]]>val[i]){
			j=stk[size--];
			//记录弹出节点的右孩子 
			chi[j][1]=p;
			p=j;
		}
		//将最后一个不满足条件的节点作为当前节点的左孩子 
		chi[i][0]=p;
		//入栈 
		stk[++size]=i;
	}
	int p=0,j;
	//处理栈中元素 
	while(size>0){
		j=stk[size--];
		//记录右孩子 
		chi[j][1]=p;
		p=j;
	}
	//处理答案 
	long long ans1=0,ans2=0;
	for(int i=1;i<=n;i++){
		ans1^=(long long)(i*(chi[i][0]+1)),ans2^=(long long)(i*(chi[i][1]+1));
	}
	printf("%lld %lld",ans1,ans2);
	return 0;
}

```

最后唠叨一句：由于每个节点只进栈一次，所以算法时间复杂度为$O(n)$。

---

## 作者：Hercules (赞：3)

## P5854 【模板】笛卡尔树

笛卡尔树是一种特别的二叉搜索树。

对于树上的每一个非叶子节点左右儿子：

满足二叉搜索树性质，即：$tree[ls[x]] < tree[x] < tree[rs[x]]$；

同样也满足小根堆的性质，即：$tree[x] < tree[ls[x]] \ \ \ and \ \ \ tree[x] < tree[rs[x]]$。

---

考虑用栈建树，栈中存储根节点和右节点。

每次插入新节点时需看是否满足笛卡尔树的性质：

$\ \ \ \ \ \ \ $不满足时，原栈顶元素出栈，并将其作为新节点的左儿子。

$\ \ \ \ \ \ \ $若满足时，把新节点当作栈顶元素的右儿子，且入栈。

维护可以用链来实现，因为会枚举到1次所以的节点，所以复杂度为$O(n)$。

注意，本题会卡，不要$define \ \ int$，不然会哭的很有节奏QAQ。
```c
#include <bits/stdc++.h>

typedef long long ll;
const int MAXN = 1e7 + 10;
int n, size, p[MAXN];
ll ans1, ans2, son[MAXN][2], stack[MAXN];

inline int read() {
	int X = 0, flag = 0;
	char ch = 0;
	while (!isdigit(ch))
		flag |= ch == '-', ch = getchar();
	while (isdigit(ch))
		X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
	return flag ? -X : X;
}

signed main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
    freopen("testdata.in", "r", stdin);
    freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
    freopen("模板笛卡尔树.in", "r", stdin);
    freopen("模板笛卡尔树.out", "w", stdout);
#endif
#endif
	n = read();
	for (register int i = 1; i <= n; i++)
		p[i] = read();
	for (register int i = 1; i <= n; i++) {
		int node = 0, j;
		while (size > 0 and p[stack[size]] > p[i]) {
			j = stack[size--];
			son[j][1] = node, node = j;
		}
		son[i][0] = node, stack[++size] = i;
	}
	int node = 0, j;
	while (size) {
		j = stack[size--];
		son[j][1] = node, node = j;
	}
	for (register int i = 1; i <= n; i++) {
		ans1 ^= (ll)(i * (son[i][0] + 1));
		ans2 ^= (ll)(i * (son[i][1] + 1));
	}
	printf("%lld %lld", ans1, ans2);
	return 0;
}
```



---

## 作者：寒冰大大 (赞：1)

粗看一眼题面范围发现$n\leq 10^7$,果断考虑单调栈

说一下单调栈思路

首先我们要保证编号满足二叉搜索树，所以只需要考虑维护这个树的右子链（这里插入才能有可能不改变这个树的中序遍历）

我们再来看看这个树，而且新插入的弟这个点$i$一定没有左子树，我们保持这个栈的单调性（因为必须保证一个方向上的路径单调递增），所以我们一定可以得到一个位置$p$（$p$就是当前单调栈的栈顶），我们把$p$的右儿子给当前节点$i$作为左儿子（显然不会出问题）,因此正确性显然，而且时间复杂度也可以得到是$O(N)$(因为单调栈)

同时发现这道题没有负数，所以我们可以把读写简单一点

```cpp
#include<touwenjian.h>

#define int long long
 
using namespace std;

const int maxn=10001000;
int l[maxn],r[maxn],a[maxn],s[maxn],stp;
int n,m;
int ans1,ans2;

inline void qread(int &ans)
{
	ans=0; static char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) {ans=ans*10+c-'0';c=getchar();}
	return ;
} 

signed main()
{
	register int i;
	qread(n);
	for(i=1;i<=n;i++)qread(a[i]);
	s[++stp]=0;
	for(i=1;i<=n;i++)
	{
		while(stp&&a[i]<a[s[stp]]) l[i]=s[stp--];
		if(stp) r[s[stp]]=i;
		s[++stp]=i;
	}
	for(i=1;i<=n;i++)
	{
		ans1=ans1^(1ll)*(i*(l[i]+1));
		ans2=ans2^(1ll)*(i*(r[i]+1));
	}
	printf("%lld %lld",ans1,ans2);
	return 0;
}


```


---

## 作者：木木！ (赞：1)

这里是用单调队列写的，专门讨论一下越界的问题以及哨兵值的设置。

关于具体怎么做，题解区其他大佬已经讲得很清楚了。我们发现在做单调队列的时候，单调队列中的那个东西就是序列笛卡尔树的右肩。来一个新数的时候，找到它在右肩上的位置，打断接进去就好。它成为右肩的一部分，右肩的其余部分成为它的左儿子。

容易证明，这种变换不影响笛卡尔树的性质。时间复杂度是 $\Theta(n)$。

代码如下：

```cpp
int qhead = 0;
for(int i=1; i<=n; ++i)
{
	int tmp = qhead;
	while(qhead!=qi && vi[*qhead]>vi[i])
	{
		--qhead;
	}
	++qhead;

	if(qhead>1)
		ri[qi[qhead-1]] = i;
	if(qhead<=tmp)
		li[i] = qi[qhead];
	qi[qhead] = i;
}
```

然后我们发现这里有两个特判。认识我的人应该都了解，我这人平常很宽容，但是最烦特判。能通过设置合适哨兵值干掉的特判我会不遗余力干掉它。~~因为这个原因模拟赛挂的分也有百八十了。~~

首先第一个 `if` 肯定能干。如果 `qhead=1` 的话，`qi[qhead-1]` 就是 0，而我们不需要关注 `ri[0]` 的值。所以就可以干掉一个特判。

```cpp
int qhead = 0;
for(int i=1; i<=n; ++i)
{
	int tmp = qhead;
	while(qhead!=qi && vi[*qhead]>vi[i])
	{
		--qhead;
	}
	++qhead;

	ri[qi[qhead-1]] = i;
	if(qhead<=tmp)
		li[i] = qi[qhead];
	qi[qhead] = i;
}
```

接下来看下一个特判。看起来很好干的样子，因为如果 `qhead=tmp+1` 的话，这个值应该为 `0`……吗？

不瞒您说，我因为这个原因 WA 了好多次。因为单调队列会后退，为了效率在后退的时候我并没有清空数组，那么接下来再前进的时候就会取到垃圾值。

最简单粗暴的解决方法是在后退的时候清垃圾值。当然还有更好玩的方法。

```cpp
int qhead = 0;
for(int i=1; i<=n; ++i)
{
	while(qhead!=qi && vi[*qhead]>vi[i])
	{
		--qhead;
	}
	++qhead;

	ri[qi[qhead-1]] = i;
	li[i] = qi[qhead];  
	qi[qhead+1] = 0  // 各人自扫门前雪，莫管他人瓦上霜
	qi[qhead] = i;
}
```

可以证明，每一轮循环只需要将 `qhead+1` 清空，就可以保证取到的是正确的值，就可以避免掉特判的同时保证答案正确性。

如果这一题出多组数据的话，每组数据需要初始化的也仅有 `qi[1]`。

附 AC 代码。为了效率将数组访问变成指针了。

```cpp
#include <cstdio>
using namespace std;

char buffer[100001],*S,*T; // 平生第一个 fread

inline char mgetchar()
{
	if(S==T)
	{
		T = (S=buffer) + fread(buffer,1,100001,stdin);
	}
	return *S++;
}

inline int getint()
{
	char c;
	while((c=mgetchar())<'0' || c>'9')
		;
	int x = c^'0';
	while((c=mgetchar())>='0' && c<='9')
		x = (x*10)+(c^'0');
	return x;
}

int vi[10000005];
int qi[10000005];

int li[10000005];
int ri[10000005];

int main()
{
	const int n = getint();
	for(int i=1; i<=n; ++i)
	{
		vi[i] = getint();
	}

	int* qhead = qi;
	for(int i=1; i<=n; ++i)
	{
		while(qhead!=qi && vi[*qhead]>vi[i])
		{
			--qhead;
		}
		++qhead;

		ri[*(qhead-1)] = i;
		li[i] = *qhead;
		*(qhead+1) = 0;
		*qhead = i;
	}

	long long lans = 0;
	long long rans = 0;
	for(int i=1; i<=n; ++i)
	{
		lans ^= 1LL*i*(li[i]+1);
	}
	for(int i=1; i<=n; ++i)
	{
		rans ^= 1LL*i*(ri[i]+1);
	}

	printf("%lld %lld\n",lans,rans);
}
```

---

## 作者：xfrvq (赞：1)

[P5854 【模板】笛卡尔树](//www.luogu.com.cn/problem/P5854)

[$\texttt{My Blog}$](//www.luogu.com.cn/blog/368107/solution-p5854)

---

~~菜鸡作者是不可能写单调栈的/kk~~

题目要求编号按 $\tt BST$，权值按小根堆，于是我们想到了 $\tt Treap$。

我用的是 $\tt FHQ$，平衡树里的“权值”就是题目中的编号，平衡树里的“优先级”就是我们这里给定的权值。

由于编号是按顺序排列的 $1\dots n$，因此我们可以使用 $\tt FHQ$ 的 $\mathcal O(n)$ 建树。

其中的 $\mathcal O(n)$ 建树过程就是，**递归建 $l\to mid$ 以及 $mid + 1\to r$，如果 $l\ge r$ 就添加节点 $l$**。

注意输出的时候要记录一个每个节点对应在树上的位置，然后输出的时候找到对应的位置再去找左右儿子。

## Code

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>

#define int long long
#define rint register int

inline int read(){
    register int x = 0;
    register char c = getchar();
    for(;c < '0' || c > '9';c = getchar());
    for(;c >= '0' && c <= '9';c = getchar())
        x = x * 10 + (c ^ '0');
    return x;
}

const int maxn = 1e7 + 1;

signed a[maxn];
signed lc[maxn],rc[maxn]; // 板子
signed val[maxn],heap[maxn]; // 板子
signed map[maxn];// 每个节点对应在树上
int cnt,rt,x,y,z;

inline int new_node(rint i,rint x){ // 板子
	val[++cnt] = i;
	heap[cnt] = x;
	map[i] = cnt;
	return cnt;
}

inline int merge(rint x,rint y){ // 板子
	if(!x || !y) return x + y;
	if(heap[x] < heap[y]){
		rc[x] = merge(rc[x],y);
		return x;
	} else {
		lc[y] = merge(x,lc[y]);
		return y;
	}
}

// 我们并不需要 split，因为只用建树

inline int build(rint l,rint r){
	if(l >= r) return new_node(l,a[l]);// l >= r 时新建节点
	rint mid = l + r >> 1;
	return merge(build(l,mid),build(mid + 1,r));
}

signed main(){
	int n = read();
	for(int i = 1;i <= n;++i) a[i] = read();
	/* 注意：一定要先读入再建树
		不能像线段树一样边建边读入 */
	build(1,n);
	long long ansl = 0,ansr = 0;// 阴间输出
	for(int i = 1;i <= n;++i){
		ansl ^= (i * (val[lc[map[i]]] + 1));
		ansr ^= (i * (val[rc[map[i]]] + 1));
	}
	printf("%lld %lld\n",ansl,ansr);
	return 0;
}


---

## 作者：TerryWang (赞：0)

### P5854 【模板】笛卡尔树 题解

------------

前置知识：悬线法

#### 思路

约定：本文中的“笛卡尔树”指权值满足**小根堆**性质的笛卡尔树，称一个点的左边距离它最近的权值比它小的结点为 **“最近左祖先”**，右边距离它最近的权值比它小的结点为 **“最近右祖先”**，点 $i$ 的权值为 $p_i$；为了方便，加入一个**哨兵节点** $0$，满足其权值小于其他所有节点的权值，如果某个节点的没有某个关系对应的节点，将其设为哨兵节点。

我们发现，一个点在笛卡尔树上的父亲必定是其“最近左祖先”与“最近右祖先”中**权值较大的一个**（记为 $f_i$）。

证明：若不满足上述条件，则记其父亲为 $f'_i$，则 $p_{f_i}>p_{f'_i}$。若 $f'_i$ 为 $f_i$ 儿子，则 $f'_i$ 有两个位于其同一侧的儿子，不满足笛卡尔树的二叉搜索树性质。于是 $f'_i$ **不是 $f_i$ 儿子**。$f_i$ 位于 $f'_i$ 与 $i$（在 $f'_i$ 子树中）之间，但是**不在 $f'_i$ 子树中**，不满足笛卡尔树的二叉搜索树性质。

于是，我们只需要求出每个节点的“最近左祖先”与“最近右祖先”，再选择权值较大者作为该节点的父亲即可。

悬线法可以胜任这个问题，并且时间复杂度为 $O(n)$，可以通过本题。

代码（这道题卡常，需把 `cin` 换为 `fread` 快读方可通过）：


```cpp
#include<bits/stdc++.h>

typedef long long ll;

const int N=10001000;
int p[N];
//分别是这个节点“最近左祖先”，“最近右祖先”，左儿子，右儿子的位置，若不存在设为0
int la[N],ra[N],lc[N],rc[N];

signed main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	
	int n;
	std::cin>>n;
	for(int i=1;i<=n;i++)std::cin>>p[i],la[i]=i-1,ra[i]=i+1;
	ra[n]=0,p[0]=-0x3f3f3f3f;
	
	for(int i=1;i<=n;i++)while(la[i]&&p[i]<p[la[i]])la[i]=la[la[i]];
	for(int i=n;i;i--)while(ra[i]&&p[i]<p[ra[i]])ra[i]=ra[ra[i]];
	for(int i=1;i<=n;i++)(p[ra[i]]>p[la[i]]?lc[ra[i]]:rc[la[i]])=i;
	ll ans1=0,ans2=0;
	for(int i=1;i<=n;i++){
//		std::cerr<<i<<' '<<lc[i]<<' '<<rc[i]<<'\n';
		ans1^=i*(lc[i]+1ll),ans2^=i*(rc[i]+1ll);
	}
	std::cout<<ans1<<' '<<ans2;
	return 0;
}
```

---


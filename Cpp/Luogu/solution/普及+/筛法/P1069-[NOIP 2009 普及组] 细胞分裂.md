# [NOIP 2009 普及组] 细胞分裂

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家。现在，他正在为一个细胞实验做准备工作：培养细胞样本。

Hanks 博士手里现在有 $N$ 种细胞，编号从 $1 \sim N$，一个第 $i$ 种细胞经过 $1$ 秒钟可以分裂为 $S_i$ 个同种细胞（$S_i$ 为正整数）。现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入 $M$ 个试管，形成 $M$ 份样本，用于实验。Hanks 博士的试管数 $M$ 很大，普通的计算机的基本数据类型无法存储这样大的 $M$ 值，但万幸的是，$M$ 总可以表示为 $m_1$ 的 $m_2$ 次方，即 $M = m_1^{m_2}$，其中 $m_1,m_2$ 均为基本数据类型可以存储的正整数。

注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有 $4$ 个细胞，Hanks 博士可以把它们分入 $2$ 个试管，每试管内 $2$ 个，然后开始实验。但如果培养皿中有 $5$ 个细胞，博士就无法将它们均分入 $2$ 个试管。此时，博士就只能等待一段时间，让细胞们继续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。

为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚好可以平均分入 $M$ 个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细胞培养，可以使得实验的开始时间最早。


## 说明/提示

【输入输出样例 \#1 说明】

经过 $1$ 秒钟，细胞分裂成 $3$ 个，经过 $2$ 秒钟，细胞分裂成 $9$个，……，可以看出无论怎么分裂，细胞的个数都是奇数，因此永远不能分入 $2$ 个试管。

【输入输出样例 \#2 说明】

第 $1$ 种细胞最早在 $3$ 秒后才能均分入 $24$ 个试管，而第 $2$ 种最早在 $2$ 秒后就可以均分（每试管 $144 / {24}^1 = 6$ 个）。故实验最早可以在 $2$ 秒后开始。

【数据范围】

对于 $50 \%$ 的数据，有 $m_1^{m_2} \le 30000$。

对于所有的数据，有 $1 \le N \le 10000$，$1 \le m_1 \le 30000$，$1 \le m_2 \le 10000$，$1 \le S_i \le 2 \times {10}^9$。


NOIP 2009 普及组 第三题


## 样例 #1

### 输入

```
1 
2 1 
3
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
2
24 1
30 12
```

### 输出

```
2
```

# 题解

## 作者：暗ざ之殇 (赞：528)

   

看了好多大佬用的质因数分解来做这个题，我来一发思路不一样的$QwQ~$

我们看这个数据：$m_1$的范围是 $30000$ 以内，$m_2$ 的范围是$10000$ 以内，若我们直接求 $m_1^{m_2}$……，暴的不堪设想；

那么我们就要换一种别的方法喽，当然分解质因数可以，而且这个思路很好，题解里很多大佬详细的讲解了，但是我也说下我的思路啦：

首先我们将每种细胞单独拿出来考虑，就设它是 $S_i$ 吧，那么总有$m1^{m2}$ | $Si^n$ ，这里这个 $n$ 就是要求的最小时间；

然后我们可以考虑求出来 $m_1$ 与 $S_i$ 的最大公约数 $gcd_1$，因为想到这个 $gcd_1$ 在前面会被算个${gcd_1}^{m2}$，在后面又会被算个${gcd_1}^n$，觉得有点浪费（当时我真的这么想），就单独将它摘出来吧；

有了最大公约数，我们就可以将$m_1^{m_2}$和$S_i^n$转化一下形式啦：

设 $m_1=m*gcd_1$，$S_i=s*gcd_1$，那么$(m*gcd_1)^{m2} | (s*gcd_1)^n$，也就是 $m^{m_2}$\*${gcd_1}^{m_2}$ | $s^n$ *$ {gcd_1}^n$；

两边同除以 ${gcd_1}^{m_2}$后得到：  $m^{m_2} | s^n * {gcd_1}^{n-m_2}$；

我们继续看左边这个东东，它是不是很像原来我们一开始列出的式子：      
$m1^{m_2}$ | $Si^n$  与 $ m^{m_2}$ | $s^n$ * $ {gcd_1}^{n-m_2} $；

虽然只是有一点点像啦，但是这右边差的有点大啊$qwq$，能不能化简一下啦？

当然能！我们看一个定理：

**若有两个互质的数 $p,q$，则一定存在 $p^n$ % $q^m$ $≠ 0$**（其实是 $gcd$（$p^n$，$q^m$）$=1$） ，其实就是无论多少次方都不能整除！

草草证明一下吧：

$∵$ $p$，$q$ 互质

$∴p$ 和 $q$ 无任何相同的因子

又$∵$ $p^n$ 和 $q^m$ 只是改变了因子的指数，而并没有增加或减少因子本身的数值

$∴$ 仍没有相同的因子，即仍互质 

有了这个定理，我们就可以化简右边的一大堆式子了：

因为 $m$ 和 $s$ 是分别由 $m_1$ 和 $S_i$ 同除以它们的最大公约数 $gcd_1$ 得到，那么 $m$ 和 $s$ 一定是互质的！（所有相同的因子都被除了，只剩下不相同的了）

那么也就是说，右边的 $s^n$ 无论如何都不能使 $m^m2$ | $s^n$，答案只可能从上面的${gcd_1}^{n-m_2}$中产生！所以我们完全可以舍弃$s^n$来化简式子，那么式子就化简成：

$m^{m_2}$ | ${gcd_1}^{n-m_2}$   

我们可以将 $n-m_2$ 看成一个整体，这样就真的和我们一开始列出的式子很像了$QwQ$

所以我们还可以继续进行我们刚刚执行的操作：**找最大公约数**！

恩，继续找最大公约数：

我们设 $gcd_2=gcd \ (m,gcd_1)$，则 $m = {gcd_2}$ $*  mm$，$gcd_1=gcd_2 *  ggcd_1$ （有点混，但是真的找不出来好变量名了，$gcd_2$ 是最大公约数，$mm$ 是 $m$ 除以最大公约数后剩下的数，$ggcd_1$ 是 $gcd_1$ 除以最大公约数后剩下的数）；

还是刚刚那样，用最大公约数将原先的 $m$ 和 $gcd_1$ 表示出来：

$m^{m_2}$ | ${gcd_1}^{n-m_2}$

=$(gcd_2 * mm)^{m_2}$ | $(gcd_2 * ggcd_1)^{n-m_2} $

=${gcd_2}^{m_2}$ * $ mm^{m_2}$ | ${gcd_2}^{n-m_2}* {ggcd_1}^{n-m_2}$ 

然后我们还是把最大公约数那一项除到右边来：

=$mm^{m_2}$ | ${gcd_2}^{n-m_2-m_2}* {ggcd_1}^{n-m_2}$

=$mm^{m_2} | {gcd_2}^{n-2 * m_2}* {ggcd_2}^{n-m_2}$

还是再套用上面的定理：    

$∵mm$与 $ggcd_2$ 互质，那么我们可以舍弃 ${ggcd_2}^{n-m_2}$

那么式子又简化为： $mm^{m_2} | {gcdd_2}^{n-2 * m_2}$

然后我们还可以找最大公约数…………，有没有发现其实这就是一个递归操作，那有没有界限呢？

当然有！我们上述的操作其实就是一直将 $m_1$ 除以某个数，那么最后它一定会被除到 $1$ 的！这样一来，式子就成了：

$1^{m_2}$ | …………，对没错，$1^{m_2}$还是 $1$，那么这个问题就被我们巧妙的转化成了：

求最小的 $n$，使得右边那一堆式子是整数！（是不是很神奇啊！）



我们来一组详细的数字来认真得体会上面的过程：

$m_1=96$，$m_2=5$

$S_1=36$

那么我们先列出一个粗略的式子：

${m_1}^{m_2} | S1^n$（这个n和题目中的 $n$ 不一样，这个 $n$ 就是我们要求的最短时间），代入数据就是：$96^5 | 36 ^n$

首先求出 $gcd$（$96$，$36$）$=12$，然后将最大公约数代入原式：

$(12 * 8)^5 |( 12* 3)^n$ = $12^5$ \* $8^5$|$ 12^n * 3^n$

然后我们将最大公约数 $12$ 那一项除到右边：

$8^5$ | $12^{n-5} * 3^n$，运用定理可知 $3^n$ 不可能产生答案，我们可以舍弃它：

$8^5$ | $12^{n-5}$，我们继续找到 $gcd$（$8$ , $1$2）$=4$，并代入原式：

$(4*2)^5$ | $(4*3)^{n-5}$=$4^5 * 2^5| 4^{n-5}* 3^{n-5}$

将最大公约数 $4$ 的那一项除到右边：

$2^5 | 4^{n-10}*  3^{n-5}$，运用定理可知$3^{n-5}$不可能产生答案，我们可以舍弃它：

$2^5 | 4^{n-10}$，我们继续找到 $gcd$（$2$ , $4$）$=2$，并代入原式：

$(1 * 2)^5 | (2 * 2)^{n-10}$=$1^5 * 2^5$|$ 2^{n-10}*  2^{n-10}$

你是不是已经知道了？把最大公约数 $2$ 那一项除过去：

$1^5 | 2^{n-15}* 2^{n-10}  $= $ 1 | 2^{2n-25}$

哇！我们将左边的 $m_1$ 给搞成 $1$ 了耶，接下来的任务不就是求最小的 $n$ 使得$2^{n-25}$是整数了嘛？

$It  \ is\  so\  easy$！ 列出不等式 $2^{2n-25}>=2^0$，则$(2n-25)>=0$，解得最小的整数 $n=13$

$So$ 我们接下来总结一下我们每一步的操作，方便总结规律然后写代码：

**$1.$求出$m_1$和$S_i$的最大公约数 $gcd$（$m_1$,$S_i$);**

**$2.$若$gcd=1$，说明这两个数互质，则不可能有解，直接跳出；**

**$3.$将 $m_1$ 和 $S_i$ 用这个最大公约数表示出来，然后将左侧的最大公约数除到右侧去**；

**$4.$可以舍弃与左侧互质的部分，其实也就是 $S_i / gcd$ 后的数；**

**$5.$从第一步开始继续重复上述操作，直到$gcd=1$ 或 $m_1=1$**；

你会发现我们上述操作始终和 $m_2$ 没啥事，但是它不可能是来打酱油的吧$QwQ~$

其实它和最后的答案 $n$ 有关，我们再来找一下 $m_2$ 的规律：

接下来这个例子我们不再将$m_2$带进去了，这样能更好的找到规律哦：

$m_1=32$， $m_2$  ，$S_1=56$ 

列出式子  $m_1^{m_2}$ | $S_1^n$：

将$m_1$，$S_1$代入得：  $32^{m_2} | 56^n$；

第一次循环：

$1.$求出$gcd$（$32$，$56$）$=8$；

$2.gcd$ 不为 $1$，说明目前阶段有解；

$3.$ 原式 = $(8 * 4)^{m_2} | (8 * 7)^n$     ------用最大公约数表示

= $8^{m_2} * 4^{m_2}| 8^n*7^n$      ------拆括号

=$4^{m_2} | 8^{n-m_2} * 7^n$       ------将最大公约数那一项除到右侧

4.舍弃与 $4^{m_2}$互质的那一项：$7^n$，原式成为：$4^{m_2} | 8^{n-m_2}$；

第二次循环：

$1.$求出$gcd$（$4,8$）$=4$；

$2.gcd$ 不为 $1$，说明目前阶段有解；

$3.$ 原式 = $(4 * 1)^{m_2} | (4 * 2)^{n-m_2}$                            ------用最大公约数表示

= $4^{m_2} * 1^{m_2}| 4^{n-m_2} * 2^{n-m_2}$                 ------拆括号

=$1^{m_2} | 4^{n-m_2-m_2} * 2^{n-m_2}$                              ------将最大公约数那一项除到右侧

=$1 | 4^{n-2 * m_2}* 2^{n-m_2}$

$4.$ 左侧我们已经除到 $1$ 了，那么我们就跳出，分析答案产生；

不知道各位在刚刚的例子中有没有发现有关 $m_2$ 的规律，来和我发现的规律对比一下哪个更好：

**$1.$ 我们在第 $3$ 步操作结束以后（就是将最大公约数那一项除过去后），右侧最大公约数的那一项的指数都会减去 $m_2$ 是吧，如果我们单独拿出来每一个循环的话，我们可以发现：右侧最大公约数那一项的指数它减去的 $m_2$ 的个数是和当前这是第几大步是相同的（其实这个很好理解，我们每一个大步 $s$ 的指数只减去 $1$ 个$m_2$，但是却非常重要）；**

我们可以来记录进入了几次循环来判断右侧最大公约数 $s$ 那一项的指数减了几个$m_2$，在代码中用 $t$ 来记录；

```cpp
        while(m!=1)
        {
            gcdd=gcd(m,s);                //第一小步，求最大公约数 
            if(gcdd==1) {flag=0;break;}   //如果互质，那么肯定无解，直接跳出 
            m/=gcdd;                      //左边剩下了m/gcdd 
            q=s/gcdd;                     //q就是s除以gcdd后剩下的数 
            s=gcdd;                       //右边剩下了gcdd         
            t++;                          //每进入一次循环，就要多减1个m2   
        } 
```




**$2.$同时它后面的 $q$ 那一项的指数减去的 $m_2$ 的个数是 $t-1$；**

**$3.$我们可以根据 $m_2$ 来求解最后的答案；**

**$4.$一个不是关于 $m_2$ 的规律（实在不知道要往哪放但是没有这个总结代码可能看不懂）：**

结合上面的例子，再感性理解一下，我们将左边的最大公约数除到右边后，左边只剩下了$m_1 / gcd$，而右边呢？由于$S_i / gcd$ 后与 $m_1 / gcd$ 互质，就被抛弃了$QwQ~$，所以右边只剩下了最大公约数 $gcd$，$So$ 进行下一大步操作的就是 $m_1 / gcd | gcd$（这里省略了指数方便理解） ，也就是说：我们令 $m_1=m_1 / gcd$，$S_i = gcd$ 就可以进行下一大步操作了；

讲完了 $m_2$ 的规律后，我们就可以将上面的步骤转化成代码啦（其实很短）：
```cpp
        m=m1;                             //拷贝一份m1的值
        s=S[i];                           //拷贝一份S[i]的值 
        flag=1;                           //判断是否有解 
        t=0;                              //记录最大公约数要减几个m2 
        while(m!=1)
        {
            gcdd=gcd(m,s);                //第一小步，求最大公约数 
            if(gcdd==1) {flag=0;break;}   //如果互质，那么肯定无解，直接跳出 
            m/=gcdd;                      //左边剩下了m/gcdd 
            q=s/gcdd;                     //q就是s除以gcdd后剩下的数 
            s=gcdd;                       //右边剩下了gcdd         
            t++;                          //每进入一次循环，就要多减1个m2   
        }
```
下面就要动动脑筋仔细思考小细节了：

当然这个将 $m_1$ 除到 $1$ 的过程是没有锅的吧，那么哪里还需要注意呢？

就是最后的求 $n$ 的过程了！其实不知道小伙伴们有没有看出来我前面的例子中求 $n$ 总是很含糊（因为还没讲到这里鸭），所以我就要帮帮带着疑惑看下来的小伙伴们仔细得考虑一下下：

假设我们已经分解到了最后一步，也就是$m_1$已经被我们除到1了，那么右边的式子我们就可以写成：

$s^{n - t * m_2} * q^{ n - (t-1) * m_2 }$    ------（这里$s$，$q$，$t$ 的含义和上面代码中的含义相同，还有这里表示指数用了上面总结的公式，不懂得小伙伴可以再回到上面看看）

那么无非有这 $3$ 种情况：

**1. $s$ 与 $q$ 互质，也就是 $gcd$（$s$，$q$）$=1$，这时候$n = t * m_2$；**

$Why$？因为这时候我们要保证右边那一坨式子最后算出来是个整数，而且这两个数还是互质的，所以若有一个是分数的话，另外一个数无论多少次方都不会把它乘成整数的$qwq$，所以我们要保证这两个数 $s$ 和 $q$ 的指数都要$>=0$，因为我们考虑到 $s$ 的指数比$q$ 的指数多减了个 $m_2$，所以我们把 $s$ 的指数搞成$0$ 的话，$q$ 的指数一定 $>0$（显然这时候指数为 $m_2$），所以我们只考虑将 $s$ 的指数弄成 $0$ 就好啦，显然这时候 $n=t * m_2$；

**$2.gcd_1$ 是 $q$ 的因数，也就是 $gcd$（$s$，$q$）$=gcd_1$，**

这时候 $n = ceil [(t+(t-1) * tot ] * m_2 / (tot+1))$，$tot$ 是 $q$内含 $s$ 的个数；

为什么还要把这种情况单独考虑呢？如果我们像第一种情况只考虑$s$的指数的话，直接 $n=t * m_2$ ？$NO$！因为既然 $q$ 是 $s$ 的倍数，那么必然我们将 $q$ 进行分解质因数的话，里面会有 $s$（但是指数不同），那么我们将s进行合并的话，指数不再是 $n-t *   m_2$了，那是多少呢？------取决于 $q$ 里面含有多少个 $s$！   

这是将 $q$ 里面所有 $s$ 全部分离出来的代码：
```
                while(q%s==0)      //如果q里面含有s，分离出来 
                {
                    tot++;         //tot表示能分离出来多少个s，第一种情况就是tot=0的情况 
                    q/=s;           
                }
```

为了区分，我们将分离出来的 $s$ 叫做 _ $s$，很显然 $s$ 和 _ $s$ 的指数不同是吧，那么我们考虑 _ $s$ 的指数是多少?

由于它是从 $q$ 中分离出来的，那么显然 _ $s$ 和 $q$ 的指数是相同的，看到上面 $q$ 的指数是$[  n - (t-1) * m_2 ]$，那么 _     $s$ 的指数也是$[ n-(t-1) * m_2 ]$；

那么我们是不是可以将 $s$ 和 _ $s$ 合并起来鸭？（底数相同不就可以合并嘛？）

合并后的 $s$ 的指数就是 $[ n-(t * m_2) ]+$ ${ tot * [n-(t-1) * m_2] }$   ，简单一记就是：$1$ 个 $s$ 的指数 $+tot$ 个 _$s$ 的指数；

再想想哈~我们将 $q$ 所有的 $s$ 都分解出来了，那么剩下的东东就和 $s$ 互质了~ 所有这不就又变成了第一种情况了？

还是老样子，我们只要使得 $s$ 的指数为 $0$ 就是解了。

所以我们要解这个方程：$[ n-(t * m_2) ]+{ tot * [n-(t-1) * m_2] }  = 0$

首先拆括号： $n-t * m_2 + { tot * [ n-(t * m_2-m_2)]  }$

$=n- t * m_2 + { tot * ( n - t * m_2 + m_2) }$

$=n - t * m_2 + tot *  n - t * m_2 * tot + m_2* tot$

$=0$

我们将 $n$ 放在左边，$m_2$ 放在右边，于是我们得到：

$n + tot * n = t * m_2 +t * m_2 * tot - m_2 * tot$

提取公因式：  $(1+tot)* n =m_2 * (t + t * tot -tot)$

$(1+tot) * n = m_2 * [ t + tot * (t -1) ]$

最后我们将 $n$ 的系数化 $1$，就得到了答案： 

$n = m_2 * [ t + tot * (t -1) ] /(1+tot)$     



$So$ 这种情况的 $n$ 我们也搞定了（哎，有没有发现其实第一种情况就是 $tot=0$ 的情况耶，我们完全可以将第一，二中情况合起来写）

代码如下：

```
                while(q%s==0)      //如果q里面含有s，分离出来 
                {
                    tot++;         //tot表示能分离出来多少个s，第一种情况就是tot=0的情况 
                    q/=s;           
                }
                if((t*m2+tot*(t-1)*m2)%(tot+1)==0)    //我不知道为什么ceil出来的答案不对，只能自己模拟向上取整了 
                   ans=(t*m2+tot*(t-1)*m2)/(tot+1);   //没余数说明正好整除 
                else ans=(t*m2+tot*(t-1)*m2)/(tot+1)+1;//如果有余数就要+1(这个1就是余数除成小数后再向上取整后得到的) 
                minx=min(minx,ans);        //题目要求整体最小时间 
```
**$3.gcd$（$s$，$q$）$≠1$，$gcd_1$ ；**

这是什么意思呢？就是当 $s$ 和 $q$ 既不互质，也不是倍数关系的时候； 

这种情况有什么魔力呢？你看如果我们用第二种情况的公式的话，显然 $tot=0$（$q$ 不是 $s$ 的倍数），但是我们注意到 $gcd$（$s$，$q$）$≠ 1$，那么说明它们还有公共部分！

显然这个公共部分就是 $gcd$（$s$，$q$），暂且记为 $gc=gcd$（$s$，$q$），所以我们要像第二种情况中的 $q$ 分离 $s$ 一样，分别将 $s$ 和 $q$ 中的 $gc$ 分离出来（逃 ；

分离的过程和上面几乎一样：
```
                while(q%gc==0)      //如果q中含有gc就分离 
                {
                    totq++;         //q中含有gc的个数 
                    q/=gc;
                }
                while(s%gc==0)      //如果s中含有gc就分离 
                {
                    tots++;         //s中含有gc的个数 
                    s/=gc;
                }
```
$So$ 我们就从 $s$ 中分离出了 $tot_s$ 个 $gc$，从 $q$ 中分离出了 $tot_q$ 个 $gc$，当然这两部分 $gc$ 的指数是不同的；

其中 $tot_s$ 个 $gc$ 的指数是和 $s$ 的指数相同，均为 $n - t * m_2$；$tot_q$ 个 $gc$ 的指数是和 $q$ 的指数相同，均为 $n - (t -1)* m_2$ ；

然后我们将所有 $gc$ 的指数合并（就是 $tot_s$ 个 $gc$ 和 $tot_q$ 个 $gc$ 的指数和）：

$tot_s * (n - t * m_2)+tot_q * [ n -(t-1)* m_2 ]$  

$=tot_s * n - tot_s * t * m_2 + tot_q * n - tot_q * m_2 * (t-1)$

我们已经把 $s$ 和 $q$ 的公共部分 $gc$ 全部都分离出来了，那么剩下的 $s / gc$ 和 $q / gc$ 一定都与 $gc$ 互质，这其实又转化成了第一种情况；

所以我们只需要将 $gc$ 的指数搞成 $0$ 就好了：

令 $gc$ 的指数为 $0$：

$tot_s * n - tot_s * t * m_2 + tot_q * n - tot_q * m_2 * (t-1)=0$    

$tot_s * n + tot_q * n = tot_s * t * m_2 + tot_q * m_2 * (t-1)$  
-----将有关 $m_2$ 的项移到右边

$(tot_s + tot_q)* n= m_2 * [tot_s * t + tot_q * (t-1)]$

------提取公因式

$n =  m_2 * [tot_s * t + tot_q * (t-1)]/ (tot_s + tot_q)$

------$n$ 系数化 $1$

所以这种情况的公式我们也推出来了，所以这个题我们就做完了$QwQ~$ 
```cpp
                if((t*m2*tots+totq*(t-1)*m2)%(tots+totq)==0)    //这种情况的公式，注意向上取整 
				   ans=(t*m2*tots+totq*(t-1)*m2)/(tots+totq);   
                else ans=(t*m2*tots+totq*(t-1)*m2)/(tots+totq)+1;
```
下面就是完整代码啦：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int read()                            //读入优化 
{
    char ch=getchar();
    int a=0,x=1;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') x=-x;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        a=(a<<3)+(a<<1)+(ch-'0');
        ch=getchar();
    }
    return a*x;
}
int n,m1,m2,minx,gcdd,m,s,q,t,flag,tot,ans,tots,totq;        //t代表q能分解成多少个s         
int S[10001];
int gcd(int a,int b)                  //欧几里得算法求最大公约数 
{
    if(b==0) return a;
    else return gcd(b,a%b);
}
int main()
{
    n=read();
    m1=read();
    m2=read();
    minx=1e9;
    if(m1==1)                             //这里一定要注意特判m1==1的情况，不然会TLE 
    {
        cout<<0;                          //无需等待，因为任何数都是1的倍数 
        return 0;
    }
    for(int i=1;i<=n;i++) S[i]=read();
    for(int i=1;i<=n;i++)                 
    {
        tot=0;
        m=m1;                             //拷贝一份m1的值
        s=S[i];                           //拷贝一份S[i]的值 
        flag=1;                           //判断是否有解 
        t=0;                              //记录最大公约数要减几个m2 
        while(m!=1)
        {
            gcdd=gcd(m,s);                //第一小步，求最大公约数 
            if(gcdd==1) {flag=0;break;}   //如果互质，那么肯定无解，直接跳出 
            m/=gcdd;                      //左边剩下了m/gcdd 
            q=s/gcdd;                     //q就是s除以gcdd后剩下的数 
            s=gcdd;                       //右边剩下了gcdd         
            t++;                          //每进入一次循环，就要多减1个m2   
        } 
        if(flag)
        {
            int gc=gcd(q,s);        //先求出gcd(q,s) 
            if(gc!=1&&gc!=s)        //单独讨论第三种情况 
            {
                totq=0;tots=0;      //注意清空 
                while(q%gc==0)      //如果q中含有gc就分离 
                {
                    totq++;         //q中含有gc的个数 
                    q/=gc;
                }
                while(s%gc==0)      //如果s中含有gc就分离 
                {
                    tots++;         //s中含有gc的个数 
                    s/=gc;
                }
                if((t*m2*tots+totq*(t-1)*m2)%(tots+totq)==0)    //这种情况的公式，注意向上取整 
				   ans=(t*m2*tots+totq*(t-1)*m2)/(tots+totq);   
                else ans=(t*m2*tots+totq*(t-1)*m2)/(tots+totq)+1;
                minx=min(minx,ans);
            }
            else                   //第一，二种情况 
            {
                while(q%s==0)      //如果q里面含有s，分离出来 
                {
                    tot++;         //tot表示能分离出来多少个s，第一种情况就是tot=0的情况 
                    q/=s;           
                }
                if((t*m2+tot*(t-1)*m2)%(tot+1)==0)    //我不知道为什么ceil出来的答案不对，只能自己模拟向上取整了 
                   ans=(t*m2+tot*(t-1)*m2)/(tot+1);   //没余数说明正好整除 
                else ans=(t*m2+tot*(t-1)*m2)/(tot+1)+1;//如果有余数就要+1(这个1就是余数除成小数后再向上取整后得到的) 
                minx=min(minx,ans);        //题目要求整体最小时间 
            }
        }
    }
    if(minx==1e9) cout<<-1;        //如果minx没被更新，说明无解 
    else cout<<minx;
    return 0;
} 

```
这种思路我也不知道是不是正解 $QwQ$, 如果有误请指出，我会认真完善的~

觉得这个思路比较不错的就点个推荐呗~~~

感谢你的观看$QwQ~$ 




---

## 作者：刘心远 (赞：154)

【做题背景】数学题，秒杀！

【算法名称】质因数分解

【算法分析】题目即要求最小的正整数k使得有一个i（1~n），满足si^k|m1^m2。

以样例二为例，24^1=24=2^3\*3

对于细胞一，30=2\*3\*5

要使每一个质因数均满足要求，

最小值now的计算过程为：

step 1：对于质因子2，now=3

step 2：对于质因子3，now=3

对于细胞二，12=2^2\*3

要使每一个质因数均满足要求，

最小值now的计算过程为：

step 1：对于质因子2，now=2

step 2：对于质因子3，now=2

所以，min值为2 算法结束~~~

【注意事项】

1.对于30，质因子5没有任何用处，因为30^k应为24的倍数。

2.把30000以内所有质数都枚举出来应该会更快。

3.质因数分解的过程千万不能写错（别忘了把m1的质因子个数都\*m2哦）！

4.请勿抄袭题解！

贴上华丽的代码：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
const int maxn=30000+10;
int n,i,j,m1,m2,minn=2147483647;
int prime[maxn]={0};  //30000以内所有的质数
bool flag=false,here;  //flag为所有细胞，here为单个细胞的判断
int pipe_prime[maxn];  //试管的质因数分解
int cell_prime[maxn];  //细胞的质因数分解
int sum_prime=0,cell,now;  //30000以内质数总数记为sum_prime
bool pr(int k)  //判断是否为素数，不予以注释
{
    int m;
    for(m=2;m<=floor(sqrt(k));m++)
    if(k%m==0)return false;
    return true;
}
int main()  //主程序开始
{
    cin>>n; cin>>m1>>m2;
    for(i=2;i<=maxn;i++)  //把30000以内的质因数枚举出来
    if(pr(i))
    {
        sum_prime++;
        prime[sum_prime]=i;
    }
    i=1; while(m1!=1)  //为m1质因数分解
    {
        if(m1%prime[i]==0)
        while(m1%prime[i]==0)  //除到没有为止
        {pipe_prime[i]+=m2; m1/=prime[i]; }
        i++;
    }
    for(i=1;i<=n;i++)
    {
        cin>>cell; j=1; now=0; here=true;  //初始化
        memset(cell_prime,0,sizeof(cell_prime));  //初始化，加头文件cstring
        while(j<=sum_prime)  //大于30000的质因子忽略，即在30000内质因数分解
        {
            if(cell%prime[j]==0)
            while(cell%prime[j]==0)
            {cell_prime[j]++; cell/=prime[j]; }
            j++;
        }
        for(j=1;j<=sum_prime;j++)
        {
            if(pipe_prime[j]!=0&&cell_prime[j]==0)here=false;  //如果细胞没有试管所拥有的质因子，该细胞不可用
            if(pipe_prime[j]!=0&&cell_prime[j]!=0)  //如果试管没有该质因子，不用做
            {
                if(pipe_prime[j]%cell_prime[j]==0)
                now=max(now,pipe_prime[j]/cell_prime[j]);
                else now=max(now,pipe_prime[j]/cell_prime[j]+1);  //记得要+1，整除时不用加
            }
        }
        if(here){flag=true; if(now<minn)minn=now;}  //如果该细胞可行，做个标志，替换
    }
    if(flag)cout<<minn<<endl;  //如果可行
    else cout<<-1<<endl;
    return 0;
}
```
有点儿长，请大神多多指教！

---

## 作者：7KByte (赞：28)

很经典的数学题，不需要有很高的数学能力，只需要有小学奥数的水平（出局）就行了
```
 那你还提交了这么多遍!
```
好吧我承认我很弱


-------------------
### 题目大意：
有n个数,每个数每个时间单位可以乘si，问多少个时间单位后这个数能被M整除

**题目简单，方法也很简单**
### 解题思路：
- 看到题目的输入数据，观察一下：M为什么要将它拆为幂的形式给出？不只是大小的问题，这里直接提示我们进行分解质因数
- 小学奥数登场：
 - 如果A被B整除，那么B的质因子A全部包括
 - A的n次方，不论n（n>0）有多大，质因子的种类永远等于A的质因子的种类，例：当A等于2，不论是2的多少次方，永远只有2这一种质因子
- 程序思路：
 - 首先对M进行分解质因数，然后对S进行分解质因数
 - 如果S的质因数种类M并没有全部包含，那么这种细胞永远无法达到要求
 - 否则最少时间为max(ans,(si>mi?1:mi/si))
 - 最后输出所有数中用时最少的，都不满足要求直接贴-1


------------
### 程序部分
```
初始化部分
```
```cpp
#include<bits/stdc++.h>
#define M (1<<30)
using namespace std;
int n,m1,m2,s,a[10005],sta[10005],pop=0;
//a保留m的分解质因数，sta保留每个s的分解质因数
```
```
对m进行分解质因数操作
```
```
void init()
{
	memset(a,0,sizeof(a));int f=m1;
	for(int i=2;i<=f;i++){
		if(m1%i==0&&!a[i])pop++,sta[pop]=i;
		while(m1%i==0){
			a[i]+=m2;
			m1/=i;
		}
	}
}
```
```
判断有多少个质因子
```
```
int work(int x){
	int sum=0;
	int f=s;
	while(f%x==0)
	  sum++,f/=x;
	return sum;
}
```
```
主程序如下
```
```
int main()
{
	scanf("%d",&n);
	scanf("%d%d",&m1,&m2);
	if(m1==1){cout<<"0";return 0;}
	init();int ans=M;
	for(int i=1;i<=n;i++){
		scanf("%d",&s);bool flag=true;int Max=-1;
		for(int j=1;j<=pop;j++)
		  {
		  	int k=work(sta[j]);
		  	if(!k){flag=false;break;}
		  	if(k>=a[sta[j]]){Max=max(Max,1);}
			else Max=max(Max,a[sta[j]]/k+(a[sta[j]]%k==0?0:1));
		  }
		if(flag)
		  ans=min(ans,Max);
	}
	if(ans==M)cout<<"-1";
	else cout<<ans;
	return 0;
}
```

---

## 作者：vectorwyx (赞：27)

很考查基础的一道数论题


------------
这道题的思路楼上的大佬已经讲的很清楚了：

先把试管的数量$m1$分解质因数

再把每一种细胞的个数$s$分解质因数

比较一下两者的质因数，看看$s$的质因数是否包含$m1$的所有质因数

包含：更新答案

不包含：继续循环

------------
那我们就要思考一下细节了

还是有一点思维难度的（尤其是考场上）

------------


首先，如何分解质因数？

这是第一道坎，我们考虑一下这样一个问题：需要完全分解$s$吗？

答案是不需要！

为什么？

想一想我们分解$s$的初衷：判断能否整除并计算所需时间

举个例子：

```
试管数为10，细胞数为30

6=2*3,30=2*3*5

我们判断的话只会用到6的两个质因数2,3

5还需要分解出来吗？ 显然不需要，让它待在那就行了
```
因此，我们**对于$s$，只需用$m1$的质因数将它进行部分分解**


------------
还有，怎样记录质因数和次数？

有两种选择：

第一种选择类似于广搜存坐标的方法

即用两个一维数组，把它们**对齐**

**一旦分解到一个质因数，就把该质因数和其次数分别存到两个数组里**

第二种选择是用map和vector

**vector存质因数，map则建立由质因数到次数的映射**

~~逛了一圈都没发现有人用map，那我就用map了~~


------------
另外，有一个注意点：

当$m1=1$时，直接输出0


------------
想到了这些，这道题目就顺利的AC了

------------
代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<map>//map库 
#include<vector>//vector库 
#define maxx 0x7fffffff//这是int的最大值 
using namespace std;
map<long long,long long> a1;//建立m1的质因数到次数的映射
vector<long long> x1;//存放m1质因数
bool su(long long k){//素数判断函数 
    for(int i=2;i*i<=k;++i){
        if(k%i==0) return 0;
    }
    return 1;
}
int main(){
    long long n,m1,m2,ans=maxx,t1,t2,time,l2,l1,cnt1;//time表示单个细胞的时间,ans为最终答案 
    long long s;
    bool flag2=0;//flag2用来标记是否有解
    cin>>n>>m1>>m2;
    if(m1==1){//是1，直接输出0就完事 
    	cout<<0;
    	return 0;
    }
    if(su(m1)){//它是个素数，不用分解了 
        a1[m1]=m2;
        x1.push_back(m1);
        l1=1;
    }
    else{//是合数 
        t1=m1;//找个替身 
        for(int i=2;i*i<=t1;++i){//枚举可能的因子 
            if(m1%i!=0) continue;//不是因子，继续枚举 
    //好啊，避开了continue，能做到这一点的只有质因数 
            x1.push_back(i);//压进去！ 
            while(m1%i==0){//不断循环，榨干它！ 
                a1[i]++;//每循环一次，次数+1 
                m1/=i;
            }
            a1[i]*=m2;//别把m2忘了 
        }
        l1=x1.size();//取大小 
    }
    for(int i=1;i<=n;++i){//开始输入细胞数量s 
        scanf("%lld",&s);
        time=0;//每种细胞所花时间 
        t2=s;//还是替身 
        for(int j=0;j<l1;++j){
        	if(t2%x1[j]!=0){//不包含！ 
        		goto here;//goto语句踢出去 
        	}
        	cnt1=0;//只需要保存单个质因数的次数 
        	while(t2%x1[j]==0){
        		t2/=x1[j];
        		cnt1++;
        	}      	
        	int tt=ceil(a1[x1[j]]*1.0/cnt1);//取分裂次数(向上取整) 
        	if(tt>time) time=tt;//更新time 
        }
        flag2=1;//没有被踢，就是有解 
        if(time<ans) ans=time;//更新答案 
        here: continue;//一脚踢到这里，啥事也没 
    }
    if(flag2) cout<<ans;//有解，输出ans 
    else cout<<-1;//无解，输出-1 
    return 0;//后话：这题是个数论题 
}
```


------------

你AC了没？AC了就给个赞呗


---

## 作者：DiaoHantong (赞：8)

## [题目传送门](https://www.luogu.com.cn/problem/P1069)

## 思路

这道题看似复杂，数据量太大，计算有难度，但是仔细分析会发现，其实只需对 $m1$ 进行质因数分解即可。 $m1^{m2}$ 和 $m1$ 含有同样的质因子，只是前者每个质因子出现的次数是后者的 $m2$ 倍。而要求出“刚好可以平均分入 $m$ 个试管 ”的时间 $k$，实际上就是要求出最小的正整数 $k$，使得存在第 $i$ 种细胞分裂数 $s_i$，满足 $s_i^k$ 可以整除 $m1^{m2}$。

要如何判断整除呢？逐个考虑每个 $s_i$，如果有 $m$ 中有而 $s_i$ 中没有的质因子，就说明这个 $s_i$ 经过多少秒都不可能均分；否则就计算 $s_i$ 和 $m$ 中每个质因子出现的次数之比，从而求出最多需要多少秒才能整除。最后，在可以均分的 $s_i$ 中取 $k$ 最小的一项，就可以得到结果。而假如每一个 $s_i$ 都不能均分，就输出 $-1$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int m1,m2,s[10001],k=0x7fffffff;
int prime[30010],cnt[30010];
int decompose(int n){//分解质因子
    int m=0;
    for(int i=2;i<=sqrt(n);i++){
        if(n%i==0){
            prime[++m]=i;
            cnt[m]=0;
            while(n%i==0){
                n/=i;
                cnt[m]++;
            }
        }
    }
    if(n>1){
        prime[++m]=n;
        cnt[m]=1;
    }
    //m的质因子需要在m1的基础上每项乘m2
    for(int i=1;i<=m;i++)cnt[i]*=m2;
    return m;
}
int main(){
    int n;
    cin>>n>>m1>>m2;
    for(int i=1;i<=n;i++)cin>>s[i];
    if(m1==1){cout<<"0";return 0;}
    int mz=decompose(m1);
    for(int i=1;i<=n;i++){
        int ans=0;//记录选第i种细胞的时间
        for(int j=1;j<=mz;j++){
            //若不能整除,则无解
            if(s[i]%prime[j]){ans=0x7fffffff;break;}
            int c=0;
            //求出质因子在s[i]中出现的次数c
            while(!(s[i]%prime[j]))s[i]/=prime[j],c++;
            //若不能整除，则多一秒
            int tmp=cnt[j]%c==0?0:1;
            ans=max(ans,cnt[j]/c+tmp);
        }
        //记录最小的秒数
        k=min(k,ans);
    }
    cout<<(k==0x7fffffff?-1:k);
    return 0;
}
```

---

## 作者：Eason_lyx (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P1069)。

### 分析
一道数学题。考虑将 $m_1$ 分解质因数。分解之后用分别用数组 $p$ 与 $a$ 来存底数与指数。即：$m_1=p_1^{a_1}p_2^{a_2} \dots p_{cnt}^{a_{cnt}}$。 

```cpp
void getit(long long n){
	for(int i=2;i<=n;i++){
		if(n%i==0){
			++cnt;
			p[cnt]=i;
			while(n%i==0){
				a[cnt]++;
				n/=i;
			}
		}
	}
	if(n!=1){
		++cnt;
		p[cnt]=n;
		a[cnt]=1;
	}
}
```

接下来，每输入一个细胞个数 $s_i$,进行以下操作：  
1. 对其试除以每一个底数 $p_i$，若无法整除，则代表无论怎样都无法满足要求，直接跳过；否则记录能整除 $k$ 个 $p_i$。  
2. 用 $t$ 记录 $m_1^{m_2}$中 $p_i$ 的个数与 $k$ 的商。  
3. 对所有的 $t$ 取**最大值**，即为满足条件时间的**最小值**。
```cpp
int calc(long long n){
	int t=0;
	for(int i=1;i<=cnt;i++){
		int k=0;
		while(n%p[i]==0){
			n/=p[i];
			k++;
		}
		if(k==0)
			return 2e9;
		t=max(t,(a[i]*m2+k-1)/k);
	}
	return t;
}
```
### 代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int m1,m2,n,ans=2e9;
int s[10005];
int  p[10005],a[10005],cnt;
void getit(long long n){
	for(int i=2;i<=n;i++){
		if(n%i==0){
			++cnt;
			p[cnt]=i;
			while(n%i==0){
				a[cnt]++;
				n/=i;
			}
		}
	}
	if(n!=1){
		++cnt;
		p[cnt]=n;
		a[cnt]=1;
	}
}
int calc(long long n){
	int t=0;
	for(int i=1;i<=cnt;i++){
		int k=0;
		while(n%p[i]==0){
			n/=p[i];
			k++;
		}
		if(k==0)
			return 2e9;
		t=max(t,(a[i]*m2+k-1)/k);
	}
	return t;
}
int main(){
	cin>>n>>m1>>m2;
	getit(m1);
	for(int i=1;i<=n;i++){
		cin>>s[i];
		ans=min(ans,calc(s[i]));
	}
	if(ans==2e9)
		cout<<-1;
	else
		cout<<ans;
	return 0;
}
```
谢谢大家。

---

## 作者：liuyiyang_khaili (赞：3)

~~本蒟蒻的第一篇题解~~
# 洛谷P1069题解

## 思路
首先看到 $m1$ 和 $m2$ 的逆天数据范围，就已经排除了硬算的想法，也就可以想到将 $m1^{m2}$ 拆分成若干质因数的次方的形式。

可先将 $m1^{m2}$ 转换成若干质因数的次方的形式，再依次转换 $s$ 数组中的每个值，若 $s_i$ 包含 $m1^{m2}$ 中的所有质因子，就说明 $s_i$ 是一个可行的答案。再统计 $s_i$ 的质因子中每个质因子需要乘几次的最大值，就是 $s_i$ 的答案。再统计 $s$ 数组中所有答案的最小值，便是本题的答案。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 7;
int n;
int m1, m2;
int s[N];
int pri[N][2], g[N][2], tot, tot2;
int ans = INT_MAX;
void get(int x, int y){//处理m1的m2次方
	int i = 2;
	while(x != 1){
		int cnt = 0;
		while(x != 0 && x % i == 0){
			cnt++;
			x /= i;
		}
		if(cnt){
			tot++;
			pri[tot][0] = i;
			pri[tot][1] = cnt * y;
		}
		i++;
	}
}
void get2(int x){//处理s数组
	int i = 2;
	while(x != 1){
		int cnt = 0;
		while(x != 0 && x % i == 0){
			cnt++;
			x /= i;
		}
		if(cnt){
			tot2++;
			g[tot2][0] = i;
			g[tot2][1] = cnt;
		}
		i++;
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m1 >> m2;
	for(int i = 1; i <= n; i++){
		cin >> s[i];
	}
	if(m1 == 1){//特判（非常重要！！！）
		printf("0");
		return 0;
	}
	get(m1, m2);
	for(int i = 1; i <= n; i++){
		memset(g, 0, sizeof(g));
		tot2 = 0;
		get2(s[i]);
		int l = 1, sum = 0;
		for(int j = 1; j <= tot; j++){
			while(g[l][0] < pri[j][0] && l <= tot2){
				l++;
			}
			if(g[l][0] != pri[j][0]){
				sum = 0;
				break;
			}
			else{
				sum = max(int(ceil(pri[j][1] * 1.0 / g[l][1])), sum);
			}
		}
		if(sum != 0){
			ans = min(ans, sum);
		}
	}
	if(ans == INT_MAX){
		cout << -1;
	}
	else{
		cout << ans;
	}
	return 0;
}
``````

---

## 作者：cwxcplh (赞：2)

很简单的一道题。

题目简化：给定 $n$ 个整数以及 $m1,m2$，如果有 $k$ 使得 ${a_i}^k\bmod{m1}^{m2}=0$，求 $k$ 的最小值，反之输出 $-1$。

首先看到整除，很容易想到质因数分解，能不能整除其实本质上就是看被除数的质因数中能不能凑出除数的质因数且数量相同，如果不能，就输出 $-1$。而 ${m1}^{m2}$ 的质因数不可能算出来再求，所以我们可以先把 $m1$ 质因数分解了，在把每个质因数进行 $m2$ 次方，也就是指数乘以 $m2$。而对于 $a_i$ 的质因数分解就直接算就对了。

如果当前这个数满足上面我们所说的条件，那就肯定可以，而我们题目中所说的分裂其实就是最初的细胞数的时间次方，即 ${a_i}^{time}$，这也很简单，只需要对每个质因数的指数乘上时间就行。

那说了那么多，到底怎么求时间呢？

其实答案已经很明显了。我们先假设 $a_i=2^{b_1}\times3^{b_2}\times...$，那么在第 $t$ 时刻细胞的数量就是 ${a_i}^t=(2^{b_1}\times3^{b_2}\times...)^t=2^{b_1\cdot t}\times3^{b_2\cdot t}\times...$，我们再假设 ${m1}^{m2}=2^{c_1}\times3^{c_2}\times...$，只要当 $b_1\cdot t\ge c_1$ 时，就算是凑出了一小块，那么就可以得到 $t\ge \cfrac{c_1}{b_1}$，因为 $t$ 一定是整数，所以我们可以得到最终的公式：

$$t=\lceil\cfrac{c_1}{b_1}\rceil$$

后面的算法也全都一样，最后取所有当中最大的时间，也就是：

$$t=\operatorname{max}(t,\lceil\cfrac{c_i}{b_i}\rceil)$$

而答案就是取所有细胞所用的时间中最小的那个。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201559895)

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m1,m2,cnt,mn=0x3f3f3f3f,a[10006],is_prime[30006],numm[30006],numa[30006];
bool check(int x)
{
	for(int i=2;i*i<=x;i++)
	{
		if(x%i==0)
		{
			return false;
		}
	}
	return true; 
}
void zys(int x)
{
	for(int i=1;is_prime[i]<=x&&x!=1;i++)
	{
		while(x%is_prime[i]==0)
		{
			numm[is_prime[i]]+=m2;
			x/=is_prime[i];
		}
	}
}
void zys2(int x)
{
	for(int i=1;i<=cnt;i++)
	{
		while(x%is_prime[i]==0)
		{
			numa[is_prime[i]]++;
			x/=is_prime[i];
		}
	}
}
signed main()
{
	for(int i=2;i<=30000;i++)//预处理30000以内的质数
	{
		if(check(i))
		{
			is_prime[++cnt]=i;
		}
	}
	cin>>n>>m1>>m2;
	zys(m1);
	bool flag=false;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		zys2(a[i]);
		bool fl=true;
		int sum=0;
		for(int j=1;j<=cnt;j++)
		{
			if(numm[is_prime[j]]&&!numa[is_prime[j]])
			{
				fl=false;
				break;
			}
			if(numa[is_prime[j]])
			{
				sum=max(sum,numm[is_prime[j]]/numa[is_prime[j]]+(numm[is_prime[j]]%numa[is_prime[j]]?1:0));
			}
		}
		if(fl)
		{
			mn=min(mn,sum);
			flag=true;
		}
		memset(numa,0,sizeof(numa));
	}
	if(flag)
	{
		cout<<mn;
	}
	else
	{
		cout<<"-1";
	}
	return 0;
}
```

---

## 作者：National_Studying (赞：2)

一个数可以通过质因数分解得：$x = p_1 ^ {a_1} \times p_2 ^ {a_2} \times p_3 ^ {a_3} \times … \times p_k ^ {a_k}$。

所以，其 $q$ 次方，可以分解成 $x ^ q = p_1 ^ {qa_1} \times p_2 ^ {qa_2} \times p_3 ^ {qa_3} \times … \times p_k ^ {qa_k}$。

对于每个数据，我们都可以判断是否含有 $m_1$ 的质因子：
1. 如果有，循环统计每一个质因子要乘几次才满足要求。
2. 如果没有，直接 `continue`。

---

## 作者：lylcpp (赞：1)

## 思路

### 题目概述

求最小的正整数 $k$，使得 $s_i^k | m_1^{m_2}$。

我们可以对 $m_1$ 进行质因数分解，分解出来的每个因数个数要乘以 $m_2$，因为 $M = m_1^{m_2}$。

于是，我们可以对每个 $s_i$ 进行排查，如果遇到 $s_i$ 不能整除 $m_1$ 的质因数，那么直接排查下一个就行了。

然后计算需要分裂的次数，取最大，但在最终要把答案最小化。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cmath>
#include<algorithm>

using namespace std;

int n, m1, m2;
int p[15][2], t[15], cntp, ans = 0x3f3f3f3f;

void div(int n) { // 分解质因数 
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			p[++cntp][0] = i;
			while (n % i == 0) {
				p[cntp][1]++;
				n /= i;
			}
		}
	}
	if (n > 1) {
		p[++cntp][0] = n;
		p[cntp][1]++;
	}
}

bool divide(int x) { // 统计质因数个数 
	memset(t, 0, sizeof(t));
	for (int i = 1; i <= cntp; i++) {
		if (x % p[i][0] == 0) {
			while (x % p[i][0] == 0) 
				t[i]++, x /= p[i][0];
		}
		else return 0;
	}
	return 1;
}

int main() {
	scanf("%d%d%d", &n, &m1, &m2);
	if (m1 == 1) { // 特判 m1 = 1 
		printf("0");
		return 0;
	}
	div(m1);
	for (int j = 1; j <= n; j++) {
		int s;
		scanf("%d", &s);
		if (!divide(s)) continue; // 无法整除 
		int maxn = -1;
		for (int i = 1; i <= cntp; i++) // 计算最大分裂次数 
			maxn = max(maxn, (int)ceil(1.0 * p[i][1] * m2 / t[i]));
		ans = min(ans, maxn);
	}
	if (ans == 0x3f3f3f3f) printf("-1");
	else printf("%d", ans);
	return 0;
}
``````

---

## 作者：Cold_Eyes_bystander (赞：1)

考虑幂的性质。

我们知道，一个数能分解成若干个质数的幂相乘，假设分解完之后是 $p_1^{k_1}p_2^{k_2}…p_x^{k_x}$，那么他的二次方可以分解成 $p_1^{2{k_1}}p_2^{2{k_2}}…p_x^{2{k_x}}$，依此类推。

对于每一个细胞，我们判断它含不含有 $m_1$ 的所有质因子，如果有，统计每一个质因子要乘几次才能满足条件，如没有，则直接跳过。

```c++
#include <bits/stdc++.h>
using namespace std;
bool f[30001];
int a[30001],b[30001],b1[30001];
int main()
{
	
    int n,m,m1;
    cin>>n>>m>>m1;
    if(m==1) 
    {
        cout<<0;
        return 0;
    }
    int m2=m;
    int cnt=0;
    for(int i=2;i<=m;i++)
    {
        if(!f[i]) a[++cnt]=i;
        for(int j=1;j<=cnt&&a[j]*i<=m;j++)
        {
            f[a[j]*i]=1;
            if(i%a[j]==0) break;
        }
    }
    for(int i=1;a[i]<=m2&&i<=cnt;i++)
    {
        while(m2%a[i]==0) m2/=a[i],b[i]++;
    }
    for(int i=1;i<=cnt;i++) b[i]*=m1;
    int minn=1e9;
    bool f1919810=0;
    for(int i=1;i<=n;i++)
    {
        int s;
        cin>>s;
        for(int i=1;i<=cnt;i++) b1[i]=0;
        for(int j=1;a[j]<=s&&j<=cnt;j++)
        {
            while(s%a[j]==0) s/=a[j],b1[j]++;
        }
        bool f114514=0;
        int maxn=0;
        for(int i=1;i<=cnt;i++)
        {
            if(b1[i]==0&&b[i]!=0) 
            {
                f114514=1;
                break;
            }
            if(b[i]==0) continue;
            int cnt1=0;
            cnt1+=b[i]/b1[i];
            if(b[i]%b1[i]!=0) cnt1++;
            maxn=max(maxn,cnt1);
        }
        if(f114514) continue;
        minn=min(minn,maxn);
        f1919810=1;
    }
    if(!f1919810) cout<<-1;
    else cout<<minn;
    return 0;
}
```

---

## 作者：a18981826590 (赞：1)

# [P1069 [NOIP2009 普及组] 细胞分裂](https://www.luogu.com.cn/problem/P1069)
## 解题思路
易得对于第 $i$ 种细胞，经过 $t$ 秒后数量为 $S_{i}^{t}$，其质因数种类始终不会发生改变，改变的只是其质因数的次数。

为使 $m_{1}^{m_{2}}|S_{i}^{t}$，则 $S_{i}^{t}$ 的质因数中应包含所有 $m_{1}^{m_{2}}$ 的质因数，且各质因数的次数均大于等于 $m_{1}^{m_{2}}$ i的各质因数的次数。

由于 $m_{1}^{m_{2}}$ 的质因数即为 $m_{1}$ 的质因数，$S_{i}^{t}$ 的质因数即为 $S_{i}$ 的质因数，故只需对 $m_{1}$ 和 $S_{i}^{t}$ 分解质因数即可。

由唯一分解定理，设 $m_{1}$ 共有 $n$ 个质因数 $p_{1},p_{2},p_{3}...p_{n}$，次数分别为 $k_{1},k_{2},k_{3}...k_{n}$，则 $m_{1}=\prod_{i=1}^{n} p_{i}^{k_{i}}$，$m_{1}^{m_{2}}=\prod_{i=1}^{n} p_{i}^{k_{i}\times m_{2}}$。

首先我们对 $m_{1}$ 分解质因数，用两个 `vector` 分别存储其质因数和 $m_{1}^{m_{2}}$ 各质因数所对应的次数 $k$。

然后遍历 $S$，用 $m_{1}$ 的质因数去试除 $S$，若 $S$ 不能整除 $m_{1}$ 的所有质因数，则无法达到要求；否则求出 $m_{1}$ 的每个质因数在 $S$ 中的次数，设为 $x$，则分裂 $t$ 秒后次数为 $x \times t$，为了使 $m_{1}^{m_{2}}|S_{i}^{t}$，则 $x_{i} \times t \ge k_{i} \times m_{2}(1 \le i \le n)$，$t=\max_{i=1}^{n} \lceil \frac{k_{i} \times m_{2}}{x_{i}} \rceil$。

最后对 $t$ 取最小值即可求得答案，注意特判无解。
## [AC](https://www.luogu.com.cn/record/199265507) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<long long int>a,b,c;
long long int l,m,n,s=INT_MAX,t,x,y;
bool z;
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>l>>m;
	for(int i=2;i<=l;i++){
		x=0;
		while(l%i==0){
			l/=i;
			x++;
		}
		if(x>0){
			a.push_back(i);
			b.push_back(x*m);
		}
	}
	while(n--){
		cin>>x;
		z=0;
		c.clear();
		for(int i=0;i<a.size();i++){
			if(x%a[i]>0){
				z=1;
				break;
			}
			y=0;
			while(x%a[i]==0){
				x/=a[i];
				y++;
			}
			c.push_back(y);
		}
		if(z) continue;
		t=0;
		for(int i=0;i<b.size();i++) t=max(t,(long long int)ceil(1.0*b[i]/c[i]));
		s=min(s,t);
	}
	if(s==INT_MAX) cout<<-1;
	else cout<<s;
	return 0;
}
```

---

## 作者：zhuangjinning (赞：1)

## 解法

首先，首先 $m_1$ 中不能有 $S_1$ 中没有的质因子，因为这样不管怎样分裂都不能满足要求。

接下来，对 $m_1$ 分解质因数。

然后将 $m_1$ 中的每个质因子对 $S_i$ 进行试除，如果遇到除不了的情况，那么这个 $S_i$ 不能满足要求，否则记录对于这个质因子，$S_i$ 最少需要分裂多少次才能满足要求，即 $S_i$ 中这个质因子的次数乘上分裂次数需要大于 $m_1\times m_2$ 中这个质因子的次数。然后对所有计算出来的值取最大值，最后再将这些值取最小值即可。

## AC 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int m1;
int m2;
int s[10002];
int prime[100002];
int p[100002];
int cnt;
int ans=1e9;
signed main(){
	cin>>n;
	cin>>m1>>m2;
	if(m1==1){
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>s[i];
	}
	int tmp=m1;
	for(int i=2;i*i<=m1;i++){
		if(tmp%i!=0){
			continue;
		}
		int e=0;
		while(tmp%i==0){
			e++;
			tmp/=i;
		}
		prime[++cnt]=i;
		p[cnt]=e;
	}
	if(tmp!=1){
		prime[++cnt]=tmp;
		p[cnt]=1;
	}
        //分解质因数
	for(int i=1;i<=n;i++){//遍历
		bool flag=1;
		int tmax=0;
		for(int j=1;j<=cnt;j++){
			if(s[i]%prime[j]!=0){//如果不能除
				flag=0;//标记为不行
				break;
			}
			int e=0;
			while(s[i]%prime[j]==0){//计算指数
				e++;
				s[i]/=prime[j];
			}
			tmax=max(tmax,(p[j]*m2+e-1)/e);//计算需要分裂的次数，取最大
		}
		if(flag){
			ans=min(ans,tmax);//取最小
		}
	}
	if(ans==1e9){//判无解
		cout<<-1;
	}else{
		cout<<ans;
	}
	return 0;
}

```

---


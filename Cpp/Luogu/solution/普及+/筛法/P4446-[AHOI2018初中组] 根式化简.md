# [AHOI2018初中组] 根式化简

## 题目描述

小可可在学习“立方根”的知识时碰到这样的问题：

将下面根式化简为最简根式：

(1) $\sqrt[3]{125}$ (2) $\sqrt[3]{81}$ (3) $\sqrt[3]{52}$

这个问题对于小可可来说太简单了，他很快就算出了答案：

(1) $5$ (2) $3\sqrt[3]{3}$ (3) $\sqrt[3]{52}$

小可可知道任意形如 $\sqrt[3]{x}$ 的根式，化简后一定可以被写成形如 $a\sqrt[3]{b}$ 的最简根式。他觉得这很有趣，就仿照出了不少题，但没一会儿就被密密麻麻的根式绕晕了，于是他向你求助：

给定 $n$ 个形如 $\sqrt[3]{x}$ 的根式，请你将它们化简为形如 $a\sqrt[3]{b}$ 的最简形式，为了方便，你只需要输出其中的 $a$ 即可。

如果你没有学过这部分数学知识，你可以认为题意是：给你 $n$ 个正整数 $x$，对于每一个 $x$，你需要求出整数 $a,b$ 使得 $a^3 \times b = x$，输出最大的整数 $a$ 即可。

## 说明/提示

对于 $100\%$ 的数据满足：$1 \le n \le 10000$，$1 \le x \le 10^{18}$。

本题共 10 个测试点，编号为1 \~ 10，每个测试点额外保证如下：
 
1 \~ 2： $n \le 10, x \le 10^6$   
3 \~ 4： $n \le 10, x \le 10^9$  
5 \~ 6： $n \le 100, x \le 10^{18}$ 且 $x$ 为完全立方数  
7 \~ 8： $n \le 500, x \le 10^{18}$  
9 \~ 10： $n \le 10000, x \le 10^{18}$

## 样例 #1

### 输入

```
3
125 81 52```

### 输出

```
5
3
1```

# 题解

## 作者：hongzy (赞：38)

### 数论 + 二分

首先，这里有一个结论：若把x^(1/4)以内的素因子全部筛(除)掉，则剩下的这个x一定是一个完全立方数或不可化简(开立方)的数.

证明：若还存在因子p>x^(1/4)，使得剩下的x能可以表示成b\*(p^3)，那这里的b一定>x^(1/4)（之前已经筛了x^(1/4)以内素因子）。那么b\*(p^3)会大于x，因此不存在p。不过有个特殊情况，就是b=1，p^3=x，即x是完全立方数.

算法过程：

1. 取x的最大值10^18，(10^18)^(1/4)大约为31650，预处理出31650以内素数
2. 筛掉x^(1/4)以内的素因子，同时记得如果出现可以开立方要累乘答案.
3. 最后查看筛完以后的x是不是p^3.可以预处理出来1~x^(1/3)的立方表，然后用STL二分函数lower_bound查找.

----
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long LL;
const int n = 31650, m = 1000000; //n为x^(1/4)的上限，m为x^(1/3)的上限 

LL pow3[m + 10];      //每个数的立方 
int plist[3510], cnt; //素数表 

bool p[40010]; 
void prime() {        //埃氏筛法 
	int sq = sqrt(n) + 0.5;
	for(int i=2; i<=n; i++) p[i] = true;
	p[1] = false;
	for(int i=2; i<=sq; i++) if(p[i])
		for(int j=i*i; j<=n; j+=i) p[j] = false;
	for(int i=1; i<=n; i++) if(p[i]) plist[++ cnt] = i;
}

int main() {
	prime(); //预处理素数 
	for(LL i=1; i<=m; i++) pow3[i] = i*i*i; //预处理立方表 
	int T; LL x; 
	scanf("%d", &T);
	while(T --) {
		LL ans = 1, c;
		scanf("%lld", &x);
		for(int i=1; i<=cnt && plist[i] <= x; i++) {
			c = 0;  //记录此素因子的出现次数 
			while(x % plist[i] == 0) { //此素数是因子 
				c ++; x /= plist[i];
				if(c == 3) ans *= plist[i], c = 0; //每次出现素因子立方就累积到答案 
			}
		}
		LL k = lower_bound(pow3+1, pow3+m+1, x) - pow3; //查看剩下的x是不是立方 
		printf("%lld\n", ans*(k*k*k == x ? k : 1)); 
	}
	return 0;
}
```

---

## 作者：KesdiaelKen (赞：32)

很好的数论题目。这道题我还是想了挺久的，这里来简述一下我的推导过程。

首先，看到$40\%$的数据，很容易想到对于每一个$x$，$a$必然小于$\sqrt[3]{x}$，所以我们从$1$一直枚举到$\sqrt[3]{x}$，找最大的可以整除$x$的正整数即可。

然后看到特殊的$20\%$数据：$x$是个完全立方数。易得$\sqrt[2]{x}<=\sqrt[3]{x}<=\sqrt[4]{x}$。所以我们可以考虑进行二分，左边界为$\sqrt[4]{x}$（可以写成```sqrt(sqrt(x))```），右边界为$\min(\sqrt{x},\sqrt[3]{10^{18}})$（注意右边界还要与$\sqrt[3]{10^{18}}$取$\min$，否则可能会爆longlong）。得到的结果就是$a$。

之后再看到$80\%$的数据，我们考虑改进枚举算法。我们可以预处理出所有可能枚举到的素数（小于等于$\sqrt[3]{x}=1000000$），然后用这些质数去除$x$。可以想到，当这些质数被除完之后，剩下的$x$含有的质因数都大于$\sqrt[3]{x}=1000000$，它们的三次方都不可能小于等于$x$了，即不必继续枚举。在除的过程中，每三个质数被除掉，答案就乘一个这个质数，最后得到的就是答案。

$80$分代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
#include<iostream>
using namespace std;
long long shu;
long long zs[1100000],gs=0,bj,a,b;
bool visit[1100000]={0};
int jl=0;
long long scf(long long a)//开三次方
{
    long long zuo=sqrt(sqrt(a)),you=min((long long)1000000,(long long)sqrt(a)),mid;
    while(zuo!=you)
    {
        mid=(zuo+you+1)/2;
        if(mid*mid*mid<=a)zuo=mid;
        else you=mid-1;
    }
    return zuo;
}
int main()
{
    for(long long i=2;i<=1000000;i++)//线性筛质数
    {
        if(!visit[i])zs[++gs]=i;
        for(long long j=1;j<=gs&&zs[j]*i<=1000000;j++)
        {
            visit[zs[j]*i]=true;
            if(i%zs[j]==0)break;
        }
    }
    int lr;scanf("%d",&lr);
    while(lr--)
    {
        scanf("%lld",&shu);bj=scf(shu);a=1;
        for(int i=1;i<=gs&&zs[i]<=bj;i++)//枚举质数
        {
            b=0;
            while(shu%zs[i]==0)
            {
                shu/=zs[i];b++;
                if(b%3==0)a*=zs[i];//每3个记1次
            }
        }
        printf("%lld\n",a);//输出答案
    }
    return 0;
}
```

最后，看到$100\%$的数据。这一部分数据的做法比较巧妙，需要将枚举、二分两种方法结合运用(实际上跟$80$分的代码没有什么区别……)。注意到$n$可能为$10000$（恶心的多组数据添加常熟），说明我们对于每一个$x$单独的处理次数最好不要超过$5000$次。但是因为$x$可能为$10^{18}$，$\sqrt[3]{10^{18}}=10^6>5000$，所以不能在$\sqrt[3]{10^{18}}$范围内枚举。

**（以下是思维重点）**

枚举显然是必须的，但又不能枚举过多次。我们需要几个栗子来帮助我们思考。

:栗子1：$x=999949000866995087$（$999983^3$）。因为$999983$本身就是一个质数，如果我们枚举质数，至少需要枚举七万多次（$1000000$以下的质数个数），显然不达到要求。但是，如果我们事先知道$999949000866995087$是一个三次方数，那我们就可以直接二分得到答案了。当然，我们不能提前知道，但是如果知道就好了……

栗子2：$x=862289445028738217$（${29983^3}*31991$）。我们发现这个数是四个质数的积。我们同样这个数的组成，但是我们发现，$x$的所有质因数中的最小的一个（$29983$）小于等于$\sqrt[4]{x}$。这意味着，我们可以仅靠枚举就找到那个最大的三次方数，因为$\sqrt[4]{10^{18}}$约为$32000$，小于它的质数个数只有$3000$多个，小于我们的最高复杂度$5000$。所以我们可以枚举小于$\sqrt[4]{10^{18}}$，同80分算法一样处理。

我们来看一下以上两种情况。一种情况是质因数全部大于$\sqrt[4]{x}$，另一种是质因数全部小于等于$\sqrt[4]{x}$。当然这两种情况都是特殊的，但是我们看看能从中总结出什么。当$x$的质因数全部小于等于$\sqrt[4]{x}$时，我们已经有$80$分算法可以处理，不会超时。那么当$x$的质因数全部大于$\sqrt[4]{x}$时（我们叫它**情况**$S$）要怎么处理呢？在这种情况下，显然$x$至多被分解为三个质因数之积（四个不可行：$y^4>x,y>\sqrt[4]{x}$）。这个时候我们如果要继续因式分解显然就不可行了。但是，注意到我们要求的东西：我们只关心$x$里面包不包含三次方数，而不关心除了这个三次方数之外的东西。因为$x$最多只有三个质因数，所以它要么是一个质因数的三次方，要么就不再可能包含任何除$1$以外的三次方数了（$x=m*n*o(m,n,o\in Prime)$。如果$m=n=o$，则$x=m^3$。如果$m,n,o$不完全相等，那么不存在$p>1$使得$x=p^3*q$（因式分解唯一性））。所以，我们只要计算剩下的$x$是否是一个三次方数就可以了（判断$\sqrt[3]{x}^3$是否等于$x$）。

以上两种情况并不包含是全部情况。还剩一种情况：$x$既包含小于等于$\sqrt[4]{x}$的质因数，又包含大于$\sqrt[4]{x}$的质因数。我们来举$2$个栗子讨论一下。

栗子3：**（重点）**$x=1026575813648488$（质因数分解式：$2*2*2*6662333*19260817$）。注意到这个栗子中，既有$19260817,6662333>\sqrt[4]{x}$，也有$2<=\sqrt[4]{x}$。我们不能用以上两个栗子的方法单独求解了，因此我们必然需要考虑**综合两种方法**。我们先用**栗子2**的枚举法筛掉小于等于$\sqrt[4]{x}$的质因数。之后，我们知道剩下的质数都大于$\sqrt[4]{x}$。然后我们发现，这不就是**情况**$S$吗！所以接下来我们照上文叙述的方法继续去做就行了。然后就做完了。 _ **多妙啊！** _

栗子4：让我们验证一下我们的算法的正确性与可行性。$x=261922878202168$（$2^3*31991^3$）。筛掉小于等于$\sqrt[4]{x}$的质因数后剩下$31991^3$，再用二分处理发现剩下的数是个三次方数，那么让答案再乘上$31991$。

经过对以上四个栗子的分析，我们得到了一个具体的解法：

$Step\space 1:$	筛出小于$32000$（稍大于$\sqrt[4]{10^{18}}$）的质数

对于每一个$x$：

$Step\space 2:$把小于等于$\sqrt[4]{x}$的质因数从$x$中筛掉，同时将$a$（题目中三次方数的基数）小于等于$\sqrt[4]{x}$的质因数加入$a$。

$Step\space 3:$判断剩下的$x$是否是一个立方数（判断${\sqrt[3]{x}}^3$是否等于$x$），如果是，将$\sqrt[3]{x}$加入$a$。

$Step\space 4:$输出$a$。

## 做完了！

总结一下，注意这种数论题的套路，思路要清晰，要善于举例子，思考问题也要循序渐进。

代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
#include<iostream>
using namespace std;
long long shu;
long long zs[40000],gs=0,bj,a,b;
bool visit[40000]={0};
int jl=0;
long long scf(long long a)//开三次方
{
    long long zuo=sqrt(sqrt(a)),you=min((long long)1000000,(long long)sqrt(a)),mid;
    while(zuo!=you)
    {
        mid=(zuo+you+1)/2;
        if(mid*mid*mid<=a)zuo=mid;
        else you=mid-1;
    }
    return zuo;
}
int main()
{
    for(long long i=2;i<=32000;i++)//Step 1
    {
        if(!visit[i])zs[++gs]=i;
        for(long long j=1;j<=gs&&zs[j]*i<=32000;j++)
        {
            visit[zs[j]*i]=true;
            if(i%zs[j]==0)break;
        }
    }
    int lr;scanf("%d",&lr);
    while(lr--)
    {
        scanf("%lld",&shu);bj=sqrt(sqrt(shu));a=1;
        for(int i=1;i<=gs&&zs[i]<=bj;i++)//Step 2
        {
            b=0;
            while(shu%zs[i]==0)
            {
                shu/=zs[i];b++;
                if(b%3==0)a*=zs[i];
            }
        }
        b=scf(shu);if(b*b*b==shu)a*=b;//Step 3
        printf("%lld\n",a);//Step 4
    }
    return 0;
}
```

---

## 作者：ziiidan (赞：12)

一道比较不错的数学思维题 。

本篇题解中可能有一些说的不太严谨的地方，望谅解，可以在评论区提出。

题目大意:

给出 n 个数，对于每一个数x，将其化简为$a\sqrt[3]{b}$的形式（其中 $a$ 和 $b$ 均为正整数），要求 a 最大，并输出 a 的值

很良心的题面中提到了:

"如果你没有学过这部分数学知识，你可以认为题意是：给你$n$ 个正整数$x$，对于每一个$ x $，你需要求出整数$a, b$ 使得$a ^ 3×b=x$，输出最大的整数$ a $ 即可。"

在这个式子中，我们不难发现 $a$ 和 $b$ 都是 $x$ 的约数， 所以我们可以发现 $a$ 和 $b$ 不可能同时大于 $\sqrt[4]{x}$,所以我们先将 $x$ 在 $\sqrt[4]{x}$ 的全部约数分离出来，之后我们会发现分离出这些因子后的 $x$ 只有如下两种情况：

1.它是一个完全立方数

2.它不可化简为题面中的形式（不考虑可以化简为$p * \sqrt[3]{1}$ 的这种情况，因为他不会对答案产生任何贡献，也没有任何的化简意义）

证明如下：

如果此时的 $x$ 不但不是一个完全平方数，还可以化简为题面中的形式，那么它一定可以表示为$q * p ^ 3$（其中 $q$ 和$p$ 均不等于 $1$）的形式，因为我们已经筛去了在$\sqrt[4]{x}$ 以内的全部约数（此处的 $x$ 为还没有筛去一些因子的 $x$），所以 $p$ 和 $q$一定都大于原始的 $x$ 的四分之一次方，此时 $q * p ^ 3$ 一定大于最原来的 $x$ ，这种情况显然是不存在的。

所以我们在分离出小于等于$\sqrt[4]{x}$ 的全部约数之后只需要二分一下它是不是完全立方数即可。

如果还有什么还有什么不懂的地方可以再结合代码里的注释理解一下。

代码如下:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

const int maxn = 1000005; 
const int maxm = 31635;

int n, cnt;
int ans, tot;

int prime[maxm];

long long x;

long long p[maxn];

bool check[maxm];

long long read(void)
{
	long long s = 0, w = 1;
	char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') w = -1;
	for(; ch <= '9' && ch >= '0'; ch = getchar()) s = s * 10 + ch - '0';
	return s * w;
}

void Euler(int num) // 线性筛素数 
{
	check[1] = true;
	for(int i = 2; i <= num; i++) 
	{
		if(!check[i]) prime[++cnt] = i;
		for(int j = 1; j <= cnt && i * prime[j] <= num; j++)
		{
			check[i * prime[j]] = true;
			if(i % prime[j] == 0) break;
		}
	}
}

int main()
{
	n = read();
	for(register int i = 1; i <= maxn - 5; i++) p[i] = 1ll * i * i * i; // 完全立方数的预处理 
	Euler(maxm - 3); // 线性筛素数 
	for(; n; n--)
	{
		x = read();
		ans = 1;
		for(int i = 1; i <= cnt && prime[i] <= x; i++) // 枚举小于等于 x 的四分之一次方的素数来去除部分因子 
		{
			for(; x % prime[i] == 0; )
			{
				x /= prime[i];
				tot++;
				if(tot == 3) // 如果这个因子的指数达到了 3 那么他可以对答案产生贡献 
				{
					ans *= prime[i]; //算上这部分贡献 
					tot = 0; // 复原指数 
				}
			}
			tot = 0; // 复原指数 
		}
		int pos = lower_bound(p + 1, p + maxn - 4, x) - p; // 二分查找小于等于它的最大的完全平方数 
		if(p[pos] == x) cout << ans * pos << '\n'; // 如果等于，即此时的 x 为一个完全平方数， 要加上它开立方后的贡献 
		else cout << ans << '\n'; // 否则没有贡献 
	}
	return 0;
}
```

如果有什么疑问的话直接在评论区发或者洛谷私信均可。

谢谢阅读。


---

## 作者：Adrien_Mertens (赞：6)

### **①对题意的分析**
题意很长，总的来讲，是将一个三次根式进行化简。也就是给定一个数s，且s满足两个s的因数p，x，p×x×x×x=s。找出满足条件的x的 最大值。
### **②算法分析**
当我们读到关键词“最大值”时，我们应当想到二分，但当满足上条件时以下两点显而易见
##### 	（1）x，p为s的因数
##### 	（2）p为质数
所以，在寻找x时，可先判断是否质数，简易check
```cpp
bool check(int x)
{
	int flag=1;
	for(int i=2;i<=ceil(sqrt(x));i++)
	{
		if(x%i==0) flag=0;
	}
	return flag;
}
```
随后，我们用二分的思想来寻找x最大值。
### **代码实现及讲解**
首先，给出完整代码
```cpp
#include<iostream>   //头文件
#include<algorithm>
#include<cmath>
using namespace std;
int pown(int a,int b)
{
    int ans=1,base=a;   //此处为快速幂，pow的类型是double，所以最好不用
    while(!b==0)
    {
        if(b&1) ans=ans*base;
        base=base*base;
        b>>=1;
    }
    return ans;
}
inline int read(void)
{
    char ch=getchar();
    int mark=1,x=0;
    while((ch<'0'||ch>'9')&&ch!='-')  
        ch=getchar();  //快速读入，个人习惯
    if(ch=='-')
    {
        mark=-1;
        ch=getchar();   //也可不用，输入数据并不多
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x*10)+(ch-'0');
        ch=getchar();
    }
    return mark*x;
}
bool check(int x)
{
	bool flag=true;
	for(int i=2;i<=ceil(sqrt(x));i++)
	{
		if(x%i==0) flag=false; //判断素数，若不是，则返回false
	}
	return flag;
}
int main()
{
	int n,flag;
	n=read();
	for(int i=1;i<=n;i++)
	{
		flag=0;
		int s;
		s=read();  //进行读入
		for(int i=2;i<=ceil(sqrt(s));i++)
		{
			if((s%i==0)&&(check(i))!=0)
			{
				for(int j=2;j<=s/i;j++)
				{
					if(pown(j,3)*i==s) //j*j*j均可
					cout<<j<<endl;
					break;
					flag=1;  //使用flag，以便于跳出第二层循环
				}
			} 
			if(flag==1) break;
		}
	}
	return 0;
}
```
## 谢谢支持

---

## 作者：Misaka19280 (赞：5)

以下代码是考场上的

考试的时候不需要一定考满分对吧，又不是ACM，我们只要拿尽可能多的分

所以我就没有用拿满分的方法，用的80分方法

首先预处理出来10^6以内的数字（18开立方是6），一共只有不到10万个，可以直接打表

用埃氏筛就可以（什么筛都可以，~~反正是打表~~）

```

Const
	n=1000000;
Var
    a:array[1..10000000]of boolean;
    i,j,m,k:longint;
    
Begin
	assign(output,'hh.out');
    rewrite(output);
    fillchar(a,sizeof(a),true);
    a[1]:=false;
    for i:=2 to trunc(sqrt(n)) do
        if a[i] then 
        begin
            j:=i+i;
            while j<=n do
                begin
                    a[j]:=false;
                    inc(j,i);
                end;
        end;
    for i:=1 to n do
        begin
            if a[i] then write(i,' ')
        end;
    close(input);
    close(output);
End.
```

打了文件，把文件里的复制一下就好了，开一个计数器，总共有78498个

然后就可以优秀的做题了

没输出一个数，就把它质因数分解，如果某个质因数出现超过三次，就把ans*这个质因数^出现次数整除三次

如果把第78498个质数给过掉后仍然没有除完或者当前这个质数大于a的剩余，就输出ans了

上代码

```
Var
	su:array[1..78498]of longint= //这个表你自己复制，或者代码里直接推也可以，不过耗时更长
	n,k,i,cnt:longint;
	ans,x:qword;
	
Function power(k,q:longint):qword; //乘方
var
	i:longint;
begin
	power:=k;
	for i:=1 to q-1 do power:=power*k;
end;
	
Begin
	readln(n);
	for k:=1 to n do
		begin
			read(x);
			ans:=1; //从1开始，不然答案肯定是0
			i:=1;
			cnt:=0;  //统计当前素数出现了多少次
			while su[i]<=x do //如果当前素数比剩余的还大，肯定筛除掉，退出
				begin
					if x mod su[i]=0 then //如果可以，则除
						begin
							x:=x div su[i];
							inc(cnt);
						end
					else
						begin
							if cnt div 3>0 then //如果某个质因子出现超过三次，则ans要乘上 ans:=ans*power(su[i],cnt div 3);
							cnt:=0;
							inc(i);
						end;
					if i>78498 then break; //放弃吧，没有质因数了
				end;
			if cnt div 3>0 then ans:=ans*power(su[i],cnt div 3); //别忘了cnt可能还有
			writeln(ans);
		end;
End.
```

AHOI其实不需要题题满分，用暴力80分，很舒服，既节省时间，又拿了不少分，如果推的时间太长就可以用暴力了，留给后面题目（因为我是蒟蒻，推不出来，而且80分和100分相差不大，节省的时间够做后面的题了）

---

## 作者：_MRCMRC_ (赞：5)

# 这个题坑的我交了50+遍……
### [~~嘤嘤嘤我好弱WA~~](https://www.luogu.org/recordnew/lists?uid=112742&pid=P4446&status=&sort=0)
## ~~（故意滥用洛咕评测姬，封号三年）~~
# 后来……
## [~~终于水过去了……qwq~~](https://www.luogu.org/recordnew/show/17245325)


------------
# 进入正题
### 一开始只是想：既然是要求$\sqrt[3]x$的系数，那么我们处理出$≤x$的所有数字的三次方，再从第一个$≥x$的数字由大到小枚举不就好了？
#### 于是有了下面的代码：
#### ~~（空间太小这里只给出部分代码）~~
```cpp
void fac()//预处理三次方表
{
    a[0]=a[1]=1;
    for(reg int i=2;i*i*i<=1e18;++i)//其实就是从1~10^6
    {
        a[i]=i*i*i;
    }
}
signed main()
{
    fac();
    read(t);//快读，懒得贴了
    while(t--)
    {
        read(x);
        int cnt=lower_bound(a+1,a+1000001,x)-a;//二分思想查找第一个小于等于x的数字
        for(reg int i=cnt;i>=2;--i)
        {
            if(!(x%a[i]))//如果i^3是x的因子则往外提i
            {
                x=x/a[i];
                ans*=i;//累计系数
            }
        }
        write(ans);
        putchar('\n');
        ans=1;
    }
    
    return 0;   
}
```
## 然而我们惊奇地发现，[60pts,RE×4](https://www.luogu.org/recordnew/show/16962110)


------------

## 然而在完美地TLE之后，我们发现，其实不需要枚举每一个三次方数，因为对于任何一个非素数的三次幂，都有:
# 设非素正整数$x=\prod^n_{i=1}a_i$
## 此式中$a_i$为素数：
# 则有$x^3=\prod^n_{i=1}a_i^3$

## 所以我们发现，其实只需要枚举$x$的所有素因子即可，可以大大减少枚举量
## 特别地，我们需要在每一次处理$x$后，使用$lower$_$bound$查找下一个需要枚举的$x$的素因子：

### 然而，这样的代码也是不知道为什么RE×4（可能是$lower$_$bound$出锅了？）
	
### ~~有知道原因的$dalao$可以在评论区中$dd$我,谢谢$dalao$指教~~！
   

```cpp
class Num{
public:
    int num,id;
public:
    Num(){}
    Num(int a,int b):num(a),id(b){}
    bool operator< (const Num n)const
    {
        return num<n.num;
    }
}a[20030813];//不要问为什么这个数字，个人喜好qwq
```
### 与上次不同的是，因为我们要存每一个素数及它的三次方，所以我们需要开一个结构体，用$i$代表第几个素数，不然枚举量也不小


### 与之对应的我们需要对结构体进行封装来支持$lower$_$bound$操作
### 另一个60pts代码:

```cpp
signed main()
{
    srand(time(NULL));//这个先不用管，一会解释
    fac();
    scanf("%lld",&q);
    while(q--)
    {
        scanf("%lld",&x);
        reg int i=upper_bound(a+1,a+t+1,Num(x,0))-a;//结构体封装
        while(i)
        {
            if(!(x%a[i].num))
            {
                x=x/a[i].num;
                ans*=a[i].id; 
                int temp=i;
                i=upper_bound(a+1,a+temp+1,Num(x,0))-a;
                //对于每次更新ans与x都要lower_bound一下
            }
            else --i; 
        }
        printf("%lld",ans);
        putchar('\n');
        ans=1;
    }
    return 0;   
}

```

## 但是这样$RE$了4个，我们就必须要找更优秀的算法：

### 我们发现，设$x$可以写成形如$x=a\sqrt[3]b$的形式，
### 即$x=\sqrt[3]{a^3×b}$;
### 那么有以下两种情况：
### $1.$ 如果$b>a$，
### 并且由于$b>a$，那么$a$一定$<=\sqrt[4]x$
### $2.$ 如果$b<a$，则$y$要么无法被分解,要么一定剩余一个完全立方数，即$a^3>=\sqrt[3]x$
## 综上我们可以作出如下操作：
### 1.只需要筛$\sqrt[4]{x_{max}}$内的所有素数
```cpp
#define MAX 1000000000000000000

in int mul(int a,int b,int p)
{
    int ans=0;
    a%=p,b%=p;
    while(b)
    {
        if(b&1)ans=(ans+a)%p;
        a=(a<<1)%p;
        b>>=1; 
    }
    return ans;
}
in int f_pow(int a,int b,int p)
{
    int ans=1;
    while(b)
    {
        if(b&1)ans=mul(ans,a,p);
        a=mul(a,a,p);
        b>>=1;
    }
    return ans;
}
bool check(int a,int n,int x,int t)
{
    int ret=f_pow(a,x,n);
    int last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=mul(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1)return 1;
        last=ret;
    }
    if(ret!=1) return 1;//fermat测试 
    else return 0;
}
bool Miller_Rabin(int n)
{
    if(n<2)return 0;
    if(n==2)return 1;
    if(!(n&1))return 0;
    int x=n-1,t=0;
    while(!(x&1))
    {
        x>>=1,t++;
    }
    for(reg int i=0;i<cnt;++i)
    {
        int a=rand()%(n-1)+1;
        if(check(a,n,x,t))return 0;//是合数 
    }
    return 1;
}
in void fac()
{
    for(reg int i=1;i<=(int)sqrt(sqrt(MAX));++i)
    {
        if(Miller_Rabin(i)) 
        {
            ++t;
            a[t]=i;
        }
    }
}
```
### 在这里我一开始做题时用的欧拉筛，一开始跑的很慢（RE的时候），就换了$Miller$_$Rabin$测试法

### 2.枚举每一个$\sqrt[4]x$以内的素因子，当出现次数累计到三次，添加到系数中，更新剩余的$x$
### 3.枚举完成二分查找，当第一个小于等于$x$的三次方数恰好为$x$，那么进入累计

# 总代码：

```cpp
#include<bits/stdc++.h>
#include<ctime>
#define in inline
#define reg register
#define int long long
#define MAX 1000000000000000000
#define MAX_L 20030813
using namespace std;
namespace qwq{
    in int read(int &o)
    {
        o=0;
        int w=1;
        char c=getchar();
        while(c<'0'||c>'9')
        {
            if(c=='-')w=-1;
            c=getchar();
        }
        while(c>='0'&&c<='9')
        {
            o=(o<<3)+(o<<1)+(c^48);
            c=getchar();
        }
        return o*w;
    }
    in void write(int x)
    {
        if(x>9)write(x/10);
        putchar(x%10+48);
    }
    in int max(int x,int y)
    {
        return x>y?x:y;
    }
    in int min(int x,int y)
    {
        return x<y?x:y;
    }
}
using namespace qwq;

int t,q,num,x,cnt,ans=1,a[MAX_L>>8],sum,tri[MAX_L>>4];
in int mul(int a,int b,int p)
{
    int ans=0;
    a%=p,b%=p;
    while(b)
    {
        if(b&1)ans=(ans+a)%p;
        a=(a<<1)%p;
        b>>=1; 
    }
    return ans;
}
in int f_pow(int a,int b,int p)
{
    int ans=1;
    while(b)
    {
        if(b&1)ans=mul(ans,a,p);
        a=mul(a,a,p);
        b>>=1;
    }
    return ans;
}
bool check(int a,int n,int x,int t)
{
    int ret=f_pow(a,x,n);
    int last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=mul(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1)return 1;
        last=ret;
    }
    if(ret!=1) return 1;//fermat测试 
    else return 0;
}
bool Miller_Rabin(int n)
{
    if(n<2)return 0;
    if(n==2)return 1;
    if(!(n&1))return 0;
    int x=n-1,t=0;
    while(!(x&1))
    {
        x>>=1,t++;
    }
    for(reg int i=0;i<cnt;++i)
    {
        int a=rand()%(n-1)+1;
        if(check(a,n,x,t))return 0;//是合数 
    }
    return 1;
}
in void fac()//素数表
{
    for(reg int i=1;i<=(int)sqrt(sqrt(MAX));++i)
    {
        if(Miller_Rabin(i)) 
        {
            ++t;
            a[t]=i;
        }
    }
}
in void Tri_pow()//三次方数表
{
    for(reg int i=1;i<=1000000;++i)
    {
        tri[i]=i*i*i;
    }
}
signed main()
{
    srand(time(NULL));
    Tri_pow();
    fac();
    read(q);
    while(q--)
    {
        scanf("%lld",&x);
        reg int i=1;
        while(a[i]<=sqrt(sqrt(x))&&i<=t)
        {
            while(!(x%a[i]))
            {
                x=x/a[i];    
                ++sum;
                if(!(sum%3))
                {
                    ans*=a[i];
                    (sum/=3)^=1;
                }
            }
            sum=0;
            ++i;
        }
        cnt=lower_bound(tri+1,tri+1000001,x)-tri;
        if(cnt*cnt*cnt==x)printf("%lld",ans*cnt);
        else printf("%lld",ans);
        putchar('\n');
        ans=1;
    }
    return 0;   
}
```

## 可能因为Miller_Rabin需要单点测试，因此：

# [惊险地水过去了！](https://www.luogu.org/recordnew/show/17246728)

## 有错误或不足之处请大佬们指正！
# 谢谢大家！

---

## 作者：critnos (赞：1)

看到之前写的题解，，太屑了，，重新写一次。

假设我们已经知道了如何正确解决这题。

---

好的你写出了题解所说的正常代码，并加了一些众所周知的卡常qwq：https://www.luogu.com.cn/record/35645792

809 ms，不好不坏

```cpp
bool f[35000];
int prime[10000];
int main()
{
	int n=read(),i,j,w=0;
	ll x,ans,s;
	for(i=2;i*i<=31650;i++)
		if(!f[i])
			for(j=i*i;j<=31650;j+=i)
				f[j]=1;
	for(i=2;i<=31650;i++)
		if(!f[i])
			prime[w++]=i;
	while(n--)
	{
		x=read();
		ans=1;
		for(i=0;i<w;i++)
		{
			for(s=0;x%prime[i]==0;s++)
				x/=prime[i];
			for(s/=3;s--;)
				ans*=prime[i];	
		}
		s=ceil(pow(x,1/3.0));
		if(s*s*s==x) ans*=s;
		printf("%lld\n",ans);	
	}
}
```
---

发现这里：`for(i=0;i<w;i++)`

只用循环到 $x^{\frac 1 4}$ 就行了，所以，改成：

`for(i=0;prime[i]*prime[i]*prime[i]*prime[i]<=x&&i<w;i++)`

https://www.luogu.com.cn/record/35646049

看起来简单的剪枝却效果显著！一下子到了 400 多 ms

---

### 最后的剪枝

发现其实并不用除掉这么多小质因数，除掉一些之后成为完全立方树了。

于是改成了这样：

```cpp
ans=1;
		for(i=0;pow0[i]<=x&&i<w;i++)
		{
			s=ceil(pow(x,1/3.0));
			if(s*s*s==x) 
			{
				printf("%lld\n",ans*s);	
				goto bre;
			}
			for(s=0;x%prime[i]==0;s++)
				x/=prime[i];
			for(s/=3;s--;)
				ans*=prime[i];	
		}
		s=ceil(pow(x,1/3.0));
		if(s*s*s==x) ans*=s;
		printf("%lld\n",ans);
		bre:;	
```
https://www.luogu.com.cn/record/35647142

糟了！反弹到了 700+ms

简单分析知道是因为求 $n^{\frac 1 3}$ 常数太大了。

然后又发现，其实有很多 $x$ 是一样的，**只有在 $x$ 变化之后计算 $n^{\frac 1 3}$ 才有意义。**

https://www.luogu.com.cn/record/35647353

很好！166 ms，成功卡到了最优解。

```cpp
ans=1;
		s=ceil(pow(x,1/3.0));
		if(s*s*s==x) 
		{
			printf("%lld\n",ans*s);	
			goto bre;
		}
		for(i=0;pow0[i]<=x&&i<w;i++)
		{
			if(x%prime[i]==0)
			{
				for(s=0;x%prime[i]==0;s++)
					x/=prime[i];
				for(s/=3;s--;)
					ans*=prime[i];
				s=ceil(pow(x,1/3.0));
				if(s*s*s==x) 
				{
					printf("%lld\n",ans*s);	
					goto bre;
				}	
			}		
		}
		s=ceil(pow(x,1/3.0));
		if(s*s*s==x) ans*=s;
		printf("%lld\n",ans);
		bre:;	
```


---

## 作者：Aware (赞：1)

打表+二分（数论巨佬直接出结果蒟蒻表示搞不来）
直接对于100%的数据，n=10000，则对于每个数操作次数不能超过5000否则TLE，反手就是一个4000个素数的表

继续考虑，对于每个X分解质因数，可以发现将所有小于四次根号x的因子分离出来，则剩余的数若为完全立方数，则只含有一种因子（随意反证，假设有两个质数a和b,a>b>四次根号x，则a 乘b乘b乘b大于x，所以a不存在）然后就可以瞎搞了，打出10^4.5=31623以内质数的表，统计为3401个，每次扫一遍去除这些因子，然后二分出剩下数的立方根，每个因子每有三个就从根号立面搬出来乘起来就AC啦

PS:本蒟蒻居然又双叒叕把二分敲错了调了一个小时嘤嘤嘤

PPS:FP万岁，被C++大佬虐的体无完肤嘤嘤嘤

上代码，没得标注了：
```pascal
var a:array[1..4000]of longint;
    n,m,i:longint;
    x:int64;
procedure ycl;
var i,j:longint;
begin
  m:=0;
  for i:=2 to 31623 do
  begin
    inc(m);a[m]:=i;
    for j:=2 to trunc(sqrt(i)) do
    if i mod j=0 then begin dec(m);break;end;
  end;
end;
procedure run;
var i,j,t:longint;
    l,r,mid,ans:int64;
begin
  ans:=1;
  for i:=1 to m do
  begin
    if a[i]>x then break;
    t:=0;
    while x mod a[i]=0 do begin inc(t); x:=x div a[i];end;
    while t>=3 do begin t:=t-3;ans:=ans*a[i];end;
  end;
  if x>a[m]*a[m]*a[m] then
  begin
    i:=a[m]+1;j:=1000000;
    while i<=j do
    begin
      mid:=(i+j)>>1;
      if mid*mid*mid=x then break;
      if mid*mid*mid<x then i:=mid+1
                       else j:=mid-1;
    end;
    if mid*mid*mid=x then ans:=ans*mid;
  end;
  writeln(ans);
end;
begin
  ycl;
  read(n);
  for i:=1 to n do
  begin
    read(x);
    run;
  end;
end.
```

---


# 「XSOI-R1」原神数

## 题目描述

原神数 $x$ 需要同时满足以下条件：

- $x$ 为质数。

- $x$ 的十进制位两两不同。

比如 $131$ 不是原神数，因为他的百位和个位相等；$42$ 也不是，因为不是质数；$17$ 就是一个原神数。

有 $q$ 次询问，现在要你求出 $l$ 到 $r$ 之间的原神数数量。

## 说明/提示

**【样例解释 #1】**

在 $100 \sim 140$ 之间的原神数有 $103,107,109,127,137,139$，共 $6$ 个。

### 数据规模与约定

**本题采用捆绑测试。**

- subtask 0（15 pts）：$1 \le l \le r \le 10^2$。

- subtask 1（15 pts）：$1 \le l \le r \le 10^4$。

- subtask 2（35 pts）：$1 \le l \le r \le 10^7$。

- subtask 3（35 pts）：$1 \le l \le r \le 10^{18}$。

对于所有数据，保证 $1 \leq l \leq r \leq 10^{18}$，$1 \leq q\leq 10^5$。

## 样例 #1

### 输入

```
4
45 66
100 140
2 90
114514 1919810```

### 输出

```
4
6
23
13321```

# 题解

## 作者：zzx0102 (赞：7)

前置知识：Miller_Rabin 算法。

显然我们需要判断一个数是不是质数。

令判断的数为 $x$，显然我们可以找一个质数 $p$，当 $x=p$ 时，$x$ 为质数，当 $p\mid x$ 时，$x$ 为合数。

然后判断 $p^{x-1}\bmod x$ 是否为 $1$，如果不是，则 $x$ 必然不是质数。

虽然但是，如果是，$x$ 也必然不是质数。

否则，考虑二次探测定理。

显然 $x^2\equiv1\pmod p$ 时，$x\equiv 1\pmod p$ 或 $x\equiv p-1\pmod p$。

证明挺简单，这里懒得证。

先用 $k$ 记录 $x-1$。

然后先将 $k$ 除以 $2$，令 $t=p^k\bmod x$。

如果 $t\not =1$ 且 $t\not = x-1$，则根据二次探测定理，$x$ 不是质数。

若 $t=x-1$，则无法继续用二次探测定理，认为 $x$ 是质数。

否则一直除，直至 $k$ 为奇数，此时默认其为质数。

很显然这个东西有可能是错的，于是考虑多测几个 $p$，提高准确率。

复杂度 $\mathcal{O}(c\log n)$，$c$ 为选的质数个数，总复杂度远远胜过 $\mathcal{O(\sqrt n)}$。

经过检验，选 $c$ 个质数时，如果操作得当，出错的概率仅为 $\dfrac{1}{4^c}$。

目前没用任何能够低于 $\sqrt n$ 的判断质数的方法，但在 OI 界中，当 $n\le 2^{78}$ 时，取前 $12$ 个质数做 MR 是绝对正确的。

感觉错误概率很可以忽略了，至少对付本题取 $3,7,61$ 足够。

然后这个题虽然 $l,r\le 10^{18}$，但是一个数字超过 $10$ 位之后，由抽屉原理可得必然有数位重复。

然后对于十位数，如果没有重复数字，则必然 $0,1,\cdots,9$ 都出现恰好一次，各数位之和为 $45$，显然是 $3$ 的倍数，可以直接跳。

然后我们考虑直接爆搜所有符合条件二的数字，然后把质数存起来，也就二十多万个，排序完之后二分即可。

注意的是有点卡常，千万别 dill，然后加一点正常的卡常技巧就能 A 了。

感觉挺简单，但是我不会 T1 却秒了 T4，有点小丑。

放一个我也不知道对不对的 MR：

```cpp
vector<int> P = {3, 7, 61};
I int Pow(int a, int b, int p) {
	int ans = 1;
	while(b) {
		if(b & 1) ans = 1ll * ans * a % p;
		a = 1ll * a * a % p; b >>= 1;
	}
	return ans;
}
I bool check(int x, int p) {
	int T = ctz(x - 1);
	int now = Pow(p, x - 1 >> T, x), pre;
	if(now == 1) return 1;
	while(T--) {
		pre = now;
		now = 1ll * now * now % x;
		if(now == 1) return pre == x - 1;
	}
	return 0;
}
I bool isprime(int x) {
	if(x == 0 || x == 1) return 0;
	for(int i = 0; i < P.size(); i++) {
		if(x == P[i]) return 1;
		if(x % P[i] == 0) return 0;
		if(!check(x, P[i])) return 0;
	}
	return 1;
}
```

---

## 作者：NINT (赞：5)

### 【声明】：

这是一篇非正式的题解，如果要学习 ```Miller-Rabin``` 算法请自行略过。

```不需要什么 Miller-Rabin 算法，暴力是可以通过本题的。```

### 【题目大意】：

定义**原神数** $x$ 满足以下条件：

- $x$ 是质数。
- $x$ 的十进制位两两不同。

试计算区间 $[l,r]$ 之间有几个原神数，多组询问。

### 【分析】：

考虑**预处理**，之后每组询问直接二分答案。

由于质数数量多，判断的时间复杂度也高，我们从第二条性质入手，即枚举十进制位两两不同的数，再依次判断它们是否为质数。

我们可以注意到所有的十位数都不用判断，这是因为 $0$ 到 $9$ 之间的数都被取了一遍，而它们的和为 $45$，必定为 $3$ 的倍数。这样就筛掉了 $3628800$ 个数。

然而仍然剩下大约 $6 \times 10^6$ 个数，直接暴力用 $O(\sqrt{n})$ 的质数判断显然超时。

怎么办？

**使用埃氏筛**。

以 $O(N \log{\log{N}})$ 的时间复杂度求出小于等于 $N$ 的质数，一方面可以让 $N$ 以下的质数判断直接变为 $O(1)$，另一方面可以减小 $N^2$ 以下的质数判断的复杂度至 $O( { {\sqrt{n}} \over {\log{n}} } )$（~~俺不会证~~），是个不错的选择。

预处理质数时的 $N$ 不能太小，否则无法优化大数判断质数的复杂度；也不能太大，否则会直接超时。这里的 $N$ 取 $10^6$ 即可。

因此我们可以写出以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> Genshin_number;//最终结果
int primes[100050];//1e6以内质数数组
bool isNOTprime[1000050]={1,1};//判断一个数是否 不是质数
void prepare()//埃氏筛预处理1e6以内的素数
{
	for(int i=2;i<1002;++i)//枚举sqrt(n)以内的数
		if(!isNOTprime[i])//如果这个数是质数
			for(int j=i<<1;j<1000050;j+=i)
				isNOTprime[j]=1;//将它的倍数标记为 不是质数
	for(int i=0,It=0;i<1000050;++i)
		if(!isNOTprime[i]) primes[It++]=i;//将结果丢进质数数组中
}
bool isprime(int x)//质数判断
{
	if(x<=1000000) return !isNOTprime[x];//小于1e6的直接特判
	for(int i=0;primes[i]*primes[i]<=x;++i)//枚举sqrt(n)以内的质数 
		if(x%primes[i]==0) return 0;//如果能除尽则不是质数 
	return 1;//否则是质数 
}
bool vis[10];//访问标记 
void dfs(int len/*当前数字长度*/,int total/*缓存结果*/,int maxn/*目标长度*/)
{//枚举长度为maxn的"原神数"，用深搜实现 
	if(len==maxn)//如果长度够了 
	{
		if(isprime(total))//如果是质数 
			Genshin_number.push_back(total);//则是"原神数" 
		return;//长度够了就停止 
	}
	for(int i=0;i<=9;++i)
		if(!vis[i])//如果这个数没出现过 
		{
			if(len==0&&i==0) continue;//特判最高位为0时的情况
			vis[i]=1;//将这个数标记为已访问过 
			dfs(len+1,total*10+i,maxn);//将i添到total的后面继续搜索 
			vis[i]=0;//搜完了就标记为没访问过
		}
}
void produce()//产生"原神数" 
{
	for(int i=1;i<=9;++i) dfs(0,0,i);
}
int q;
long long l,r;//不开long long见祖宗 
int main()
{
	prepare();
	produce();
	scanf("%d",&q);
	while(q--)
	{
		scanf("%lld%lld",&l,&r);
		//STL中自带二分，可以直接用 
		printf("%d\n",upper_bound(Genshin_number.begin(),Genshin_number.end(),r)-lower_bound(Genshin_number.begin(),Genshin_number.end(),l));
	}
}
```

本以为能过去，[结果](https://www.luogu.com.cn/record/169567314) 竟然全部超时（~~只差零点零几秒真的气死我了 QAQ~~）。

这意味着我们必须继续优化质数判断的效率，但也不能通过某种~~奇~~技~~淫~~巧减少判断次数，否则反而会因常数问题变得更慢~~或使算法变得高级~~。

观察质数判断的代码：

```cpp
bool isprime(int x)//质数判断
{
	if(x<=1000000) return !isNOTprime[x];//小于1e6的直接特判
	for(int i=0;primes[i]*primes[i]<=x;++i)//枚举sqrt(n)以内的质数 
		if(x%primes[i]==0) return 0;//如果能除尽则不是质数 
	return 1;//否则是质数 
}
```

想要优化，就得先看看 ```for``` 循环里面究竟干了什么事：

1. 声明变量 ```i``` 并赋值为 $0$；
2. 判断 ```primes[i]*primes[i]<=x```（耗时点）；
3. 判断 ```x%primes[i]==0```（耗时点）；
4. ```++i```（耗时点）；
5. 返回第 $2$ 步。

实际上我们需要的只有第 $3$ 步，因此我们要想办法减少第 $2$ 步和第 $4$ 步的运行次数。

这时候**循环展开**就派上用场了！

何为循环展开？

> 循环展开，是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。最常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。——百度百科

打个比方就是：

```cpp
for(int x=0;x<100;x++)
{
    dosomething(x);
}
```

变成：

```cpp
for(int x=0;x<100;x+=5)
{
    dosomething(x);
    dosomething(x+1);
    dosomething(x+2);
    dosomething(x+3);
    dosomething(x+4);
}
```

这时我们发现第 $2$ 步和第 $4$ 步的运行次数都变少了！

这正是循环展开优化的原理：让每一次循环都处理更多的操作以减小常数。

但缺点也很明显：这会使代码变得又臭又长，边界条件也不好判断。

不过我们终于能通过这道题了！

### 【代码】：


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> Genshin_number;//最终结果
int primes[100050];//1e6以内质数数组
bool isNOTprime[1000050]={1,1};//判断一个数是否 不是质数
void prepare()//埃氏筛预处理1e6以内的素数
{
	for(int i=2;i<1002;++i)//枚举sqrt(n)以内的数
		if(!isNOTprime[i])//如果这个数是质数
			for(int j=i<<1;j<1000050;j+=i)
				isNOTprime[j]=1;//将它的倍数标记为 不是质数
	for(int i=0,It=0;i<1000050;++i)
		if(!isNOTprime[i]) primes[It++]=i;//将结果丢进质数数组中
}
bool isprime(int x)//质数判断
{
	if(x<=1000000) return !isNOTprime[x];//小于1e6的直接特判
	for(int i=0;primes[i]*primes[i]<=x;i+=32)//枚举sqrt(n)以内的质数 
		if(x%primes[i  ] ==0||x%primes[i+1] ==0||//直接展开！！！
		   x%primes[i+2] ==0||x%primes[i+3] ==0||
		   x%primes[i+4] ==0||x%primes[i+5] ==0||
		   x%primes[i+6] ==0||x%primes[i+7] ==0||
		   x%primes[i+8] ==0||x%primes[i+9] ==0||
		   x%primes[i+10]==0||x%primes[i+11]==0||
		   x%primes[i+12]==0||x%primes[i+13]==0||
		   x%primes[i+14]==0||x%primes[i+15]==0||
		   x%primes[i+16]==0||x%primes[i+17]==0||
		   x%primes[i+18]==0||x%primes[i+19]==0||
		   x%primes[i+20]==0||x%primes[i+21]==0||
		   x%primes[i+22]==0||x%primes[i+23]==0||
		   x%primes[i+24]==0||x%primes[i+25]==0||
		   x%primes[i+26]==0||x%primes[i+27]==0||
		   x%primes[i+28]==0||x%primes[i+29]==0||
		   x%primes[i+30]==0||x%primes[i+31]==0) return 0;//如果能除尽则不是质数
		   //注意这里是肯定不会出现数组越界的，因为x最大也才1e9，开了根号只有3e4，远小于1e6
	return 1;//否则是质数 
}
bool vis[10];//访问标记 
void dfs(int len/*当前数字长度*/,int total/*缓存结果*/,int maxn/*目标长度*/)
{//枚举长度为maxn的"原神数"，用深搜实现 
	if(len==maxn)//如果长度够了 
	{
		if(isprime(total))//如果是质数 
			Genshin_number.push_back(total);//则是"原神数" 
		return;//长度够了就停止 
	}
	for(int i=0;i<=9;++i)
		if(!vis[i])//如果这个数没出现过 
		{
			if(len==0&&i==0) continue;//特判最高位为0时的情况
			vis[i]=1;//将这个数标记为已访问过 
			dfs(len+1,total*10+i,maxn);//将i添到total的后面继续搜索 
			vis[i]=0;//搜完了就标记为没访问过
		}
}
void produce()//产生"原神数" 
{
	for(int i=1;i<=9;++i) dfs(0,0,i);
}
int q;
long long l,r;//不开long long见祖宗 
int main()
{
	prepare();
	produce();
	scanf("%d",&q);
	while(q--)
	{
		scanf("%lld%lld",&l,&r);
		//STL中自带二分，可以直接用 
		printf("%d\n",upper_bound(Genshin_number.begin(),Genshin_number.end(),r)-lower_bound(Genshin_number.begin(),Genshin_number.end(),l));
	}
}
```

[AC 记录](https://www.luogu.com.cn/record/169581373)。

这样我们就以橙题的算法 AC 了一道绿题。~~真的太酷啦！~~

---

## 作者：Shadow_T (赞：5)

### 题目分析

很明显我们可以枚举十进制位的排列来组成数，然后对于每个数字判断素数。

对于判素数可以采用 Miller-Rabin。

我们采用几个剪枝：

- 对于 $0$ 到 $9$ 全部组一遍的数，一定都是 $3$ 的倍数（十进制位综合为 $45$），所以不用考虑，这样可以剪掉 $3628800$ 个需要筛选的数。

- 缩小 Miller-Rabin 的模数数量（缩小到 $2$ 个基本可以）。

- 可以在 Miller-Rabin 之前先把前 $25$ 个质数的倍数筛了，这样又可以筛掉很多数，为程序加速。

- 手写全排列。

对于询问，我们把这些数预处理出来，每次二分左右边界即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
ll qmul(ll a,ll b,ll mod)//快速乘
{
    ll c=(ld)a/mod*b;
    ll res=(ull)a*b-(ull)c*mod;
    return (res+mod)%mod;
}
ll qpow(ll a,ll n,ll mod)//快速幂
{
    ll res=1;
    while(n)
    {
        if(n&1) res=qmul(res,a,mod);
        a=qmul(a,a,mod);
        n>>=1;
    }
    return res;
}
bool MRtest(ll n)//Miller Rabin Test
{
    if(n<3||n%2==0) return n==2;//特判
    ll u=n-1,t=0;
    while(u%2==0) u/=2,++t;
    ll ud[]={28178,9780504};
    for(ll i=0;i<=1;i++)
    {
    	ll a=ud[i];
        ll v=qpow(a,u,n);
        if(v==1||v==n-1||v==0) continue;
        for(int j=1;j<=t;j++)
        {
            v=qmul(v,v,n);
            if(v==n-1&&j!=t){v=1;break;}//出现一个n-1，后面都是1，直接跳出
            if(v==1) return 0;//这里代表前面没有出现n-1这个解，二次检验失败
        }
        if(v!=1) return 0;//Fermat检验
    }
    return 1;
}
ll pr[31]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107};
bool is_prime(ll x)
{
    for(ll i=0;i<=25&&pr[i]*pr[i]<=x;i++)
    if(x%pr[i]==0) return false;
	if(!MRtest(x)) return false;
	return true;
}
bool vis[10];
ll l,r;
vector<ll> v;
void dfs(int c,ll s,int m)
{
	if(c>m)
	{
		if(is_prime(s)) v.push_back(s);
		return;
	}
	for(int i=0;i<=9;i++)
	if(!vis[i])
	{
		if(i==0&&c==1) continue;
		vis[i]=true;
		dfs(c+1,s*10+i,m);
		vis[i]=false;
	}
}
ll read()
{
    ll x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
    x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int main()
{
	for(int i=1;i<=9;i++) dfs(1,0,i);
	int q;
	cin>>q;
	while(q--)
	{
		ll l,r;
		l=read(),r=read();
		int itl=lower_bound(v.begin(),v.end(),l)-v.begin();
		int itr=upper_bound(v.begin(),v.end(),r)-v.begin()-1;
		cout<<itr-itl+1<<"\n";
	}
}
```

<https://www.luogu.com.cn/record/156839141>

---

## 作者：woshishabi11451444 (赞：4)

首先如果只考虑十进制两两不同，那么有效数字数量不超过 $5 \times 10^6$，接着对这些有效数字进行质数判断，由于直接 $O(\sqrt N)$ 的质数判断会超时，使用 `Miller-Rabin` 素性测试，然后记录下合法的原神数，对每次询问二分输出答案。

`Miller-Rabin` 素性测试是什么：

[Miller-Rabin 素性测试](https://www.cnblogs.com/jxy2012/p/18133743)

---

## 作者：__rnfmabj__ (赞：3)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P10404)

当一个数 $a$ 是一个质数，并且任意两位数不同，我们称这个数为 ```原神数``` 。

现在，给定义个 $l,r$ 求 $l\cdots r$ 区间内原神数个数。
## 理清思路
暴力做法，~~但大家的题解好像大部分是 Miller_Rabin 算法，tql~~，考虑枚举每一个符合每位不相同的数（显然可以用 $dfs$ 枚举出来），判断一下是不是质数，如果是，那就直接记录下来。

为什么不能先枚举质数再判断质数呢？因为质数数量多，一个一个判绝对 TLE （不要问我怎么知道的），所以我们从数量少的入手

这里我们采用复杂度最优的欧拉筛（不懂欧拉筛的同学可以去看一下[这篇博客](https://www.luogu.com.cn/article/mpwf8pd3)），接下来考虑继续优化：
- 明显大于等于 $10^{11}$ 的数中没有原神数，因为十进制下只有十个数字。
- 大于等于 $10^{10}$ 的数也不可能有原神数，因为十个数都用上了，而它们的和是 $45$ ，一定能被三整除（这个应该是常识吧），所以不可能是质数。

考虑到这两点之后，我们就可以写代码了，每次自动生成一个大小在 $1,10^9$ 的范围内的每位不相同的数，然后判断一下是不是质数，如果是质数就将其记录，最后二分一下 $l$ 二分一下 $r$ 就得到答案了。

## code

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+50;

int pr[N],tot,q;//pr和tot存质数,q次询问
long long l,r;//不开long long见祖宗
vector<int> Genshin;//原神！启动！！
bool a[N]={1,1},vis[10];//a用来表示数字是不是质数，vis用来在生成数时判断数位

void zhi(){//欧拉筛
    for (int i=2;i<=N;i++){
        if (!a[i])pr[++tot]=i;
        for (int j=1;j<=tot && i*pr[j]<=N;j++){
            a[i*pr[j]]=1;
            if (i%pr[j]==0)break;
        }
    }
}
bool ispr(int x){
	if(x<=N) return !a[x];//如果在所有被欧拉筛枚举的范围内，代表早就有答案了，返回即可
	for(int i=1;pr[i]*pr[i]<=x;i++)
		if(x%pr[i]==0) return 0;//否则判断一下有没有质数可以被除尽，有就是合数
	return 1;//没有就是质数
}
void dfs(int len,int step,int goal){//生成数，len代表当前数的长度，step代表当前的数，goal是目标长度
    if (len==goal){//达到目标长度
        if (ispr(step))Genshin.push_back(step);//判断是不是质数
        return ;
    }
    for (int i=0;i<=9;i++){
        if (len==0 && i==0)continue;//特判第一位为零
        if (vis[i])continue;//保证没被使用过
        vis[i]=1;//标记
        dfs(len+1,step*10+i,goal);//继续递归
        vis[i]=0;//回溯
    }
}
signed main(){
    scanf("%d",&q);
    zhi();
    //这边要用scanf和printf卡常（不然T爆，不要问我怎么知道的）
    for (int i=1;i<=9;i++)dfs(0,0,i);//生成数
    while (q--){
        scanf("%lld%lld",&l,&r);
        printf("%d\n",upper_bound(Genshin.begin(),Genshin.end(),r)-lower_bound(Genshin.begin(),Genshin.end(),l));
    //二分出l，二分出r，答案就是这一段的长度
    }
    return 0;
}
```

---

## 作者：Eterna (赞：0)

因为 $\ge 10^{11}$ 的数一定有数位相同，而 $<10^{11}$ 又 $\ge 10^{10}$ 并且数位互不相同的一定是 $9$ 的倍数。

所以只有当 $2 \le x < 10^{10}$ 时，$x$ 才有可能是原神数。

对数位进行全排列，由于我们只有 $10$ 个数字，所以只有 $10!$ 种不同的数。加上判断质数就是 $O(10!\sqrt{V})$，不太能接受。

`Miller-Rabin` 可以，但是没必要。由于素数在区间 $[1,n]$ 的出现次数大约是 $\pi(n)=\displaystyle\frac{n}{\log n}$ 个。则判断素数复杂度为 $\displaystyle O(\pi(\sqrt{n}))=O(\frac{\sqrt{n}}{\log n})$。

欧拉筛筛出 $10^6$ 的素数，判断素数枚举即可。

---

## 作者：lcycl (赞：0)

[传送门](https://www.luogu.com.cn/problem/P10404)
## 题目大意  
如果一个数为质数且每个数位都不同，我们就称这个数为 **原神数**。  
给定 $l$ 和 $r$，问在 $l$ 和 $r$ 之间的 **原神数** 有多少个。  
## 思路
有两个方法：  
- 暴力 dfs（暴力无敌！！）。先用[欧拉筛](https://blog.csdn.net/qaqwqaqwq/article/details/123587336)筛出质数，再暴力判断每一位是否相同。如果相同则舍弃，不同则选择，最后二分答案，便可以得出结果。欧拉筛的复杂度应该可以说是最优的了，但还是会 TLE。所以，我们要在 dfs 里剪枝（下面的结论都遵守每一个数位不同的原则）。首先，我们可以很容易想到，当这个数大于等于 $10^{11}$ 时，就可以退出了。因为当数大于等于 $10^{11}$ 时，就已经有 $11$ 个数位了，必定有一个数重复，但有了这个还不够。接着，我们再从质数的角度出发，发现当数大于等于 $10^{10}$ 时，这个数的数位和为 $45$，所以这个数一定是 $3$ 的倍数。有了这个思路，代码就很容易写了。    
- 先用 [Miller Rabin 算法](https://zhuanlan.zhihu.com/p/349360074)（文章讲的十分详细，建议参考（~~其实是我不懂~~）），然后爆搜出符合条件的数，再二分答案就可以得出答案。  
附暴力代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;//范围
int pr[N],tot,q;//存质数
vector<int> G;//存数字
bool a[N]={1,1},vis[10];//a用来判断这个数是不是质数，vis用来去重
void oula(){
    for (int i=2;i<=N;i++){
        if (!a[i])pr[++tot]=i;
        for (int j=1;j<=tot && i*pr[j]<=N;j++){
            a[i*pr[j]]=1;
            if (i%pr[j]==0)break;
        }
    }
}//欧拉筛
bool zs(int x){
	if(x<=N) return !a[x];
	for(int i=1;pr[i]*pr[i]<=x;i++)
		if(x%pr[i]==0) return 0;
	return 1;
}//判断质数
void cfx(int l,int r,int num){
	if(l==r){
		if(zs(num)) G.push_back(num);
		return;
	}//如果左指针碰到右指针，就判断：如果num是质数，则先选择再退出。否则直接退出
	for(int i=0;i<=9;i++){
		if((l==0&&i==0)||vis[i]) continue;//判断首位是0和数字使用过的情况
		vis[i]=1;
		cfx(l+1,r,num*10+i);
		vis[i]=0;//回溯
	}
}//暴力
void make(){
	oula();//筛出质数
	for(int i=1;i<=9;i++) cfx(0,i,0);//构建数组
}
int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);//关闭缓冲区（否则TLE）
	//或用printf和scanf也行
	make();
	cin>>q;//读入
	while(q--){
		long long l,r;
		cin>>l>>r;
		cout<<upper_bound(G.begin(),G.end(),r)-lower_bound(G.begin(),G.end(),l)<<"\n";//这个区间的长度即为答案
	}
	return 0;
}
//我要玩原神！！！！
```

---

## 作者：Jason331 (赞：0)

看到题解区里都是些 `Miller-Rabin`，我来分享一个不用 `Miller-Rabin` 的~~乱搞~~作法

## 解题思路
### 确定枚举（或爆搜）范围
1. 我们知道十进制只有十个用来表示数字的符号，它们分别是：$0,1,2,3,4,5,6,7,8,9$（废话）。所以，“原神数”最大只可能为 $9876543210$（将十个数字都用上，降序排列）。
2. 我们又知道：是三的倍数的数的各位数字加起来，也是三的倍数，且从 $0$ 加到 $9$，得 $45$，刚好是三的倍数。所以将 $0 \sim 9$ 的十个数字分别用一次所组成的数字必然为三的倍数，也就不是质数了。即在十位数中，没有“原神数”。

经过上述分析，原神数只可能在 $2 \sim 10^9$ 这个区间内，而 $l,r$ 小于等于 $10^{18}$ 这个条件，就是个纸老虎。

### 质数判断
众所周知，只能被 $1$ 和本身整除的数叫做质数。众所又周知，若数 $a$ 能被数 $b$ 整除，则 $a$ 可以被 $b$ 的所有质数因子整除。那么，我们就可以得出：只要这个数不能被小于它的任何质数整除，那它也是一个质数。所以，我们可以先算出其平方小于 $10^9$ 的所有质数，存起来，再用它们来判断“原神数”。

这样一来，判断的速度就加快了许多（具体是多少我也不知道）。

## 降低常数
在使用以上的方法后，你会发现你的代码只差零点几秒就 AC 了，所以我们需要使用一些降低常数的方法

### inline
函数返回类型前加上关键字 `inline`，就可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。

但是要注意，主函数前不能添加 `inline`，因为 `inline` 是将函数内联进主函数（一个不太专业的解释），主函数可不能内联进自己。

所以我们只要在所有的函数前加上 `inline`，就能通过啦（语言记得选 `C++14`，我也不知道为什么它快一些）

## 代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
bool b[10];
int ans,p[3500] = {2},top = 1,jl[300000];
inline bool prime(int num)//进阶版：判断质数 
{
	for(int i = 0;p[i] * p[i] <= num;i++)
	    if(num % p[i] == 0)
	        return false;
    return true;
}
inline void dfs(char last,int num)//大法师填数字 
{
	if(prime(num) && num > 1)
	    //注意，上面的判断质数的函数有小bug，会将0和1看为质数，但不影响本程序 
	    //这里补一下漏 
	    jl[ans++] = num;
    if(last)
    for(int i = (num == 0);i < 10;i++)
        if(!b[i])
        {
        	b[i] = 1;
        	dfs(last - 1,num * 10 + i);
        	b[i] = 0;
		}
}
inline int read()//快读 
{
	char c;
	long long num = 0;
	for(c = getchar();c < '0' || c > '9';c = getchar());
	for(;c >= '0' && c <= '9';c = getchar())
	    num = (num << 3) + (num << 1) + c - '0';
    return num > 1e9? 1e9:int(num);
}
inline int findl(long long a)//二分查找l 
{
	int l = 0,r = ans - 1,mid,rr = ans;
	while(l <= r)
	{
		mid = (l + r) / 2;
		if(jl[mid] >= a)
		    rr = mid,r = mid - 1;
        else
            l = mid + 1;
	}
	return rr;
}

inline int findr(long long a)//二分查找r 
{
	int l = 0,r = ans - 1,mid,rr = 0;
	while(l <= r)
	{
		mid = (l + r) / 2;
		if(jl[mid] <= a)
		    rr = mid,l = mid + 1;
        else
            r = mid - 1;
	}
	return rr;
}

int main()
{
	for(int i = 3;i * i <= 1e9;i++)
	    if(prime(i))
	        p[top++] = i;
	dfs(9,0);
	sort(jl,jl + ans);//记得排序，否则二分查找的时候会不太妙
	long long i,q,l,r; 
	q = read();
	for(i = 0;i < q;i++)
	{
		l = findl(read());
		r = findr(read());
		if(max(r,l) < 2)printf("0\n");
		else printf("%d\n",r - l + 1);
	}
	return 0;
 } 
```
好啦，看完就赶快和你的朋友们展示一下如何[掐着时间点 AC](https://www.luogu.com.cn/record/158019281) 吧。

---

注：~~丧心病狂的~~卡常能够很好地训练我们的代码与思维能力

---

## 作者：bluewindde (赞：0)

一篇题解需要一张头图。

![](https://cdn.luogu.com.cn/upload/image_hosting/h559rle7.png)

容易发现超过十位的数都不是原神数，因为只有十个数字，不可能保证十一个位置互不相同。  
同时恰好十位的数也不可能是原神数，因为数位互不相同的十位数的数位和为 $45$，被 $3$ 整除，一定是 $3$ 的倍数。  
于是把原神数的范围缩小到 $[1, 10^9)$。

显然不能在回答询问时处理答案，考虑预处理出所有原神数并二分回答询问。

考虑先满足数位互不相同的限制，DFS 搜索出所有数位互不相同的数并判断其是否是质数。  
可以计算出，需要判断 $\binom 9 8 1! + \binom 9 7 2! + \binom 9 6 3! + \cdots + \binom 9 9 9! = 986409$ 次。  
只需要寻找一个快速的质数判断方法，回收头图：Miller–Rabin 被卡得飞起。  
考虑分治：使用线性筛判断不超过阈值的数，超过阈值的数通过枚举线性筛得到的素数进行判断。  
取阈值为 $2 \cdot 10^6$ 可以通过本题。

**正确性证明** 定理：对于一个合数 $x$，其最小质因子不超过 $\sqrt x$。在 $[2, 2 \cdot 10^6)$ 的素数内一定可以找到待判断的数（如果是合数）的最小质因子。正确性得证。

**时间复杂度证明** 设待判断的数为 $x$，阈值为 $B$。如果 $x \leqslant B$，可以 $O(1)$ 判断；如果 $x > B$，根据前述定理，会枚举 $\pi(\lfloor \sqrt x \rfloor) \sim \frac {\sqrt x} {\ln(\sqrt x)}$ 个质数。勉强可以通过。

因为有些卡常所以比较难看的代码。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

typedef long long ll;

using namespace std;

const int lim = 2e6;

int q;
ll l, r;
bool isp[lim + 5];
int pr[lim + 5], pi;
static inline bool chk(int x) {
    if (x <= lim)
        return !isp[x];
    for (int i = 1; pr[i] * pr[i] <= x; ++i)
        if (x % pr[i] == 0)
            return false;
    return true;
}

bool vis[12];
vector<int> gen;
static inline void dfs(int u, int val, int aim) {
    if (u == aim) {
        if (chk(val))
            gen.push_back(val);
        return;
    }
    for (int i = 0; i <= 9; ++i) {
        if (u == 0 && i == 0)
            continue;
        if (vis[i])
            continue;
        vis[i] = 1;
        dfs(u + 1, val * 10 + i, aim);
        vis[i] = 0;
    }
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("1.in", "r", stdin);
#endif
    isp[0] = isp[1] = 1;
    for (int i = 2; i <= lim; ++i) {
        if (!isp[i])
            pr[++pi] = i;
        for (int j = 1; j <= pi && i * pr[j] <= lim; ++j) {
            isp[i * pr[j]] = 1;
            if (i % pr[j] == 0)
                break;
        }
    }
    for (int i = 1; i <= 9; ++i)
        dfs(0, 0, i);
    scanf("%d", &q);
    while (q--) {
        scanf("%lld %lld", &l, &r);
        printf("%d\n", (int)(upper_bound(gen.begin(), gen.end(), r) - lower_bound(gen.begin(), gen.end(), l)));
    }
    return 0;
}
```

---

## 作者：_Hzx_ (赞：0)

【**题目大意**】 

共有 $q$ 次询问，给出 $l$ 和 $r$，求 $l$ 到 $r$ 中原神数的个数。

原神数的定义见下： 

- 是一个质数。

- 十进制位上的每个数两两不同。

----

【**解法**】 

暂且考虑暴力做法。

对于考虑十进制两两不同，直接暴力枚举，大约在 $10^6$。设十进制两两不同的数的个数为 $x$，那么暴力时间复杂度为 $O(q \times x \times \sqrt n)$。 

显然这样枚举是有很多地方待优化的。

对于 $q$，很难优化，不考虑。而 $x$ 呢？我们其实不用进行枚举，直接在 $q$ 次循环之前进行预处理，找出十进制位两两不同的数放在一个数组里，再使用 ```Miller-Rabin``` 判断是不是素数，预处理就完成了。  
 
然后进入 $q$ 次询问，每次二分答案即可。

复杂度也就降低到了 $O(\max(x \log n, q \log n))$。

---


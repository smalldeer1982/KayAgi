# [蓝桥杯 2024 国 Java B] 园丁

## 题目描述

小明是一位尽职尽责的园丁。这天他负责维护一棵树，树上有 $n$ 个结点 $1, 2, \ldots, n$，根结点为 $1$，结点 $i$ 的权值为 $a_i$。他需要更改一些结点的权值为任意正整数，使得对于任意一个至少有 $2$ 个儿子结点的结点 $i$ 满足：任意两个 $i$ 的儿子结点的权值的乘积都不是完全平方数。请问小明至少需要修改多少个结点的权值？

## 说明/提示

### 样例说明

其中一种方案：将结点 $2, 5$ 的权值分别修改为 $3, 2$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，保证 $n \leq 10^3$。
- 对于 $100\%$ 的评测用例，保证 $1\leq n \leq 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
6
1 2 9 8 4 4
1 2
1 3
1 4
2 5
2 6```

### 输出

```
2```

# 题解

## 作者：ErgouTree (赞：5)

### 题目大意

题目的核心是要处理一棵树上每个节点的权值，对于拥有两个及以上儿子节点的父节点，要保证所有儿子节点的权值两两相乘不能是完全平方数，目标是求出最少需要修改多少个节点的权值，才能让整棵树满足这个条件。

### 思路

#### 完全平方数的判定

首先什么是完美平方数，如果一个正整数 $a$ 是某一个整数 $b$ 的平方，那么这个正整数 $a$ 叫做完全平方数。零也可称为完全平方数。

两个数 $x$ 和 $y$ 的乘积是完全平方数，当且仅当 $x$ 与 $y$ 的乘积中，所有质因子的幂次都是偶数。

例如 $4 \times 9 = 36$ 是完全平方数，因为 $4 = 2 ^ 2,9 = 3 ^ 2$ ，他们的质因子的幂次都是偶数。

进一步推导，这个条件等价于 $x$ 和 $y$ 的 “平方因子化简后” 的形式相同。所谓 “平方因子化简”，就是对每个数 a 分解质因数后，只保留每个质因数的奇数次幂（即 $a_i$ 的“平方自由部分”），这部分记作 $f(a_i)$。

若  $f(a_i) = f(a_j)$  ，那么  $a_i \times a_j$  必然是完全平方数。

#### 代码处理

使用邻接表存树，如果存在两个儿子节点的 $f(a_j)$ 相等，那么这两个儿子节点权值的乘积就是完全平方数，不满足题目要求。

贪心处理：

对每个有 $k \ge 2$ 个儿子的结点 $i$，统计其所有儿子的 $f(a_j)$，对于重复的 $f(a_j)$，需要修改其中 $cnt-1$ 个结点的权值（$cnt$ 为该 $f(a_j)$ 出现次数）。
对每个结点，累加需要修改的次数。

关于求平方自由部分`squareFree(int x)`:   
我们需要只保留不能被2整除的幂次部分，所以按照如下形式解耦出平方自由部分。
```java
private int squareFree(int x) {
    int res = 1;
    for (int i = 2; i * i <= x; i++) { // 枚举所有可能的质因数
        int cnt = 0;
        while (x % i == 0) { // 统计i作为质因子的次数
            x /= i;
            cnt++;
        }
        if ((cnt & 1) == 1) res *= i; // 只保留奇数次的质因数
    }
    if (x > 1) res *= x; // x本身是大于1的质数
    return res;
}
```

  
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        new Solutions();
    }
}

class Solutions {
    private int n ,ans = 0;     // 树中节点的数量
    private int[] a = new int[100086];   // 节点值
    private int[] f = new int[100086];   // 节点值的平方自由部分
    private List<Integer>[] tree;   // 邻接表表示树

    // 返回 x 的平方自由部分
    // 平方自由部分是指一个数分解质因数后，每个质因数的指数都为 1 的部分
    private int squareFree(int x) {
        int res = 1;
        for (int i = 2; i * i <= x; i++) {
            int cnt = 0;
            while (x % i == 0) {
                x /= i;
                cnt++;
            }
            if ((cnt & 1) == 1) res *= i;  // 如果质因数的幂次为奇数，将其乘到结果中
        }
        if (x > 1) res *= x;   // 如果 x 还有剩余的质因数，也乘到结果中
        return res;
    }

    private void dfs(int u, int fa) {
        List<Integer> children = new ArrayList<>();
        // 遍历当前节点 u 的所有邻接节点 v
        for(int v: tree[u]) {
            // 不是父节点，加入children
            if(v != fa){
                children.add(v);
                dfs(v, u);   // 递归调用
            }
        }
        if (children.size() >= 2) {
            // 统计每个子节点的平方自由部分的出现次数
            Map<Integer, Integer> cnt = new HashMap<>();
            for(int v: children){
                cnt.put(f[v], cnt.getOrDefault(f[v], 0) + 1);
            }
            for (int c : cnt.values()) {
                if (c > 1) ans += c - 1;
            }
        }
    }

    public Solutions(){
        FastReader sc = new FastReader();
        n = sc.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
            f[i] = squareFree(a[i]); // 计算每个节点值的平方自由部分
        }
        // 初始化邻接表
        tree = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) tree[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            tree[u].add(v);
            tree[v].add(u);
        }
        // 从根节点（节点 1）开始进行深度优先搜索
        dfs(1, 0);
        // 输出最终结果
        System.out.println(ans);
    }

    class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
            st = new StringTokenizer("");
        }
        String next() {
            while (!st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
```
但是，上述代码会出现递归调用过深的问题，我们需要将原来的递归深度优先搜索（DFS）改为迭代方式。通过使用栈来模拟后序遍历，我们可以避免递归调用过深的问题。
```java
//package 数学.subject.P12255_蓝桥杯2024国JavaB_园丁;

import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        new Solutions2();
    }
}


class Solutions2{
    private int n;
    private int[] a;
    private int[] f;
    private List<Integer>[] tree;
    private int ans = 0;

    private int squareFree(int x) {
        int res = 1;
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                int cnt = 0;
                while (x % i == 0) {
                    x /= i;
                    cnt++;
                }
                if (cnt % 2 != 0) {
                    res *= i;
                }
            }
        }
        if (x > 1) {
            res *= x;
        }
        return res;
    }

    public Solutions2(){
        FastReader sc = new FastReader();
        n = sc.nextInt();
        a = new int[n + 1];
        f = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = sc.nextInt();
            f[i] = squareFree(a[i]);
        }

        tree = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) tree[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            tree[u].add(v);
            tree[v].add(u);
        }

        // 使用迭代的后序遍历来替代递归DFS
        Deque<Object[]> stack = new ArrayDeque<>();
        stack.push(new Object[]{1, 0, false});

        while (!stack.isEmpty()) {
            Object[] node = stack.pop();
            int u = (Integer) node[0];
            int fa = (Integer) node[1];
            boolean visited = (Boolean) node[2];

            if (!visited) {
                stack.push(new Object[]{u, fa, true});
                List<Integer> children = new ArrayList<>();
                for (int v : tree[u]) {
                    if (v != fa) {
                        children.add(v);
                    }
                }
                // 逆序压入，以保持原来的处理顺序
                for (int i = children.size() - 1; i >= 0; i--) {
                    int v = children.get(i);
                    stack.push(new Object[]{v, u, false});
                }
            } else {
                List<Integer> children = new ArrayList<>();
                for (int v : tree[u]) {
                    if (v != fa) {
                        children.add(v);
                    }
                }
                if (children.size() >= 2) {
                    Map<Integer, Integer> cnt = new HashMap<>();
                    for (int v : children) {
                        int sf = f[v];
                        cnt.put(sf, cnt.getOrDefault(sf, 0) + 1);
                    }
                    for (int c : cnt.values()) {
                        if (c > 1) {
                            ans += c - 1;
                        }
                    }
                }
            }
        }
        System.out.println(ans);
    }

    class FastReader {
        BufferedReader br;
        StringTokenizer st;
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
            st = new StringTokenizer("");
        }
        String next() {
            while (!st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }
        int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
```

---

## 作者：Nostopathy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12255)

[可能有更好的阅读体验](https://www.luogu.com.cn/article/ghj59o0o)

显然有 $\Theta(n^2)$ 暴力方法，代码就不放了。

对于正解，思考完全平方数性质。当一个数分解因数后每个质数都是偶次幂，则是完全平方数。而根据幂的性质，两个同时含有某质数奇次幂的数相乘必会出现偶次幂。所以考虑记录每数的奇次幂质因子的乘积，换句话说，它除以它最大的完全平方数因数的结果。若有两数的该值相等，相乘必为完全平方数。这块可用 `std::map` 实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int, int>
#define pb push_back
#define rep(a, b, c, d) for(int a=b; a<=c; a+=d)
const int N = 1e5 + 5;
int n, a[N], father[N];
vector<int> G[N];
int calc(int);
void dfs(int, int);
signed main () {
	cin >> n;
	rep(i, 1, n, 1)
		cin >> a[i], a[i] = calc(a[i]);
	rep(i, 1, n - 1, 1) {
		int u, v;
		cin >> u >> v;
		G[u].pb(v);
		G[v].pb(u);
	}
	dfs(1, 0);
	int ans = 0;
	rep(i, 1, n, 1)
		if(G[i].size() >= 2) { // 细节
			map<int, int> mp; // 用 map 记录出现次数
			for(int j: G[i])
				if(j != father[i]) {
					++ mp[a[j]];
					ans += (mp[a[j]] >= 2); // 出现完全平方
				}
		}
	cout << ans;
	return 0;
}
int calc(int x) { // 计算奇次幂质因子乘积
	int s = 1;
	rep(i, 2, sqrt(x), 1) {
		int pow = 0;
		while(!(x % i))
			x /= i, ++ pow;
		if(pow & 1)
			s *= i;
	}
	if(x >= 2) // 细节
		s *= x;
	return s;
}
void dfs(int x, int f) { // 记录父亲节点
	father[x] = f;
	for(int v: G[x])
		if(v != f)
			dfs(v, x);
}
```

对 `#define int long long` 爱好者的特别警示：虽然这或许是个好习惯，但是也会花费额外时间。因此：

![](https://cdn.luogu.com.cn/upload/image_hosting/mzmxywrf.png)

题解来之不易，麻烦留赞再走~

~~题解必要仪式：求关。~~

---

## 作者：GODTREE (赞：0)

注意到：我们每次只需要修改可以组成完全平方数的两个数中的一个就可以了。

但是……我们应该怎么去判断呢？

```cpp
for (int k=j+1;k<c[i].size();k++)
{
    int t=v[c[i][j]]*v[c[i][k]];
    if ((int)(sqrt(t))*(int)(sqrt(t))==t && f[i]!=c[i][j] && f[i]!=c[i][k])
    {
        flag=1;
    }
}
```

如果整型变量开根号再平方等于它本身，那么它就是完全平方数！（读者易证）

但这不 TLE 才怪……

我们得想一种简单的方法。

再注意到：两个数相乘得到的结果是不是完全平方数只和它的所有质因数次数模 2 有关。

这是因为所有偶次质因数都是可以直接开根的。

然后只需要用一个 map 统计有多少个相同的就可以了。

然后每组的 cnt 个减去 1 即为所需修改数，然后相加即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, v[100005], f[100005], cnt;
vector<int> c[100005];
set<int> b;
void dfs(int u, int fa)
{
    f[u] = fa;
    for (int i = 0; i < c[u].size(); i++)
    {
        if (c[u][i] == fa) { continue; }
        dfs(c[u][i], u);
    }
}
int unp(int x) 
{
    int res = 1;
    for (int i = 2; i * i <= x; i++) 
    {
        int cnt = 0;
        while (x % i == 0) 
        {
            x /= i;
            cnt++;
        }
        if (cnt % 2 == 1) res *= i;
    }
    if (x > 1) res *= x;
    return res;
}
signed main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> v[i];
        v[i] = unp(v[i]);
    }
    for (int i = 1; i < n; i++)
    {
        int x, y;
        cin >> x >> y;
        c[x].push_back(y);
        c[y].push_back(x);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++)
    {
        if(c[i].size() >= 2)
        {
            map<int, int> mp;
            int max_cnt = 0;
            for (int j = 0; j < c[i].size(); j++)
            {
                if (c[i][j] != f[i])
                {
                    mp[v[c[i][j]]]++;
                    if(mp[v[c[i][j]]] >= 2) cnt++;
                }
            }
        }  
    }
    cout << cnt;
    return 0;
}
```

---


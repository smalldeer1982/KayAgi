# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# 题解

## 作者：kuaiCreator (赞：39)

## 题目大意
将一串长度为 $n$ 的数字字符串，分成 $k+1$ 个整数，使这 $k+1$ 个整数的乘积最大。

本题是划分型动态规划的经典例题。

划分型动态规划通常是将 $n$ 个元素划分为无限组或有限组同时计算分成若干组的最优解或方案数等问题。

状态定义一般为 $f(i,j)$ 表示把前 $i$ 个元素分为 $j$ 组时的最优状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/7dcxuwoe.png)

## 解题思路
特别注意：由于读入的字符串长度 $N\le 40$ 计算结果很大需要开高精度。
#### 1、定义状态
$f(i,j)$ 表示前 $i$ 个数字字符插入 $j$ 个乘号的最大乘积的值。

#### 2、分解子问题
$$f(i,j)=\max\limits_{k=j}^{i-1}f(k,j-1)\times num(k+1,i)$$

$num(k+1,i)$ 表示由字符串的第 $k+1$ 至 $i$ 位组成的数。

#### 3、初始化状态和边界状态
问题状态初始化：
$$f(l,r) = 0 \quad l,r∈[1..n]$$

边界状态初始化：
$$f(0,j) = 0,f(i,0) = num(1 , i)\quad i,j∈[1..n]$$

#### 4、计算顺序
第一层循环枚举前 $i$ 个数从 $1$ 到 $n$。

第二层循环枚举插入乘号的数量 $j$ 从 $1$ 到 $\min(m,i-1)$。 

第三层循环 $k$ 枚举插入的位置 $j$ 到 $i-1$。

#### 5、最终答案
$$ans=f(n,m)$$

#### 6、效率分析
时间复杂度 $O(n^2m)$。

空间复杂度 $O(nm)$。

## 代码展示
为方便理解附上一个不带高精度的代码。带高精度的写法建议用类类型或者结构体并重载运算符实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 50;
long long dp[N][N], n, m, num[N][N];		//long long 可以替换为高精度类型
string str;
int main() {
	cin >> n >> m >> str;
	str = ' ' + str;                      //让字符串有用的信息从下标 1 开始
	for (int i = 1; i <= n; i++)          //把字符串第i至第j个位置的子串转换为整数
		for (int j = i; j <= n; j++)
			num[i][j] = num[i][j - 1] * 10 + str[j] - '0';

	memset(dp, 0, sizeof(dp));
	for (int i = 1; i <= n; i++)          //初始化边界状态
		dp[i][0] = num[1][i]; 

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {     //j<i表示i个数最多插入i-1个乘号
			if (j >= i) break;  //前i个元素不能被插入j个隔板分成j+1份
			for (int k = j; k < i; k++)    //前k个元素最多插入j-1个符号故k从j开始枚举
				dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
		}
	cout << dp[n][m];
	return 0;
}

```
满分代码

```cpp
#include <bits/stdc++.h>
using namespace std;
class BINT {         //类类型，这里可以替换成struct
private:                              //私有成员
	string s;
public:                               //公有成员
	BINT(string x = "0"): s(x) {};    //初始化构造函数
	const BINT operator+(const BINT &t) { //重载加法运算
		string sa = s, sb = t.s;
		int la = sa.size(), lb = sb.size();
		int m = max(la, lb);         //获得最大数字长度
		vector<int> a(m + 1, 0), b(m + 1, 0), c(m + 1, 0);
		for (int i = 0; i < la; i++) //逆序存数a
			a[i] = sa[la - 1 - i] - '0';
		for (int i = 0; i < lb; i++) //同上
			b[i] = sb[lb - 1 - i] - '0';
		for (int i = 0; i < m; i++) {
			c[i] += a[i] + b[i];     //对位相加
			c[i + 1] += c[i] / 10;   //处理进位
			c[i] = c[i] % 10;        //去掉进位
		}
		while (!c[m] && m) m--;      //去除前导零
		string res;
		for (int i = m; i >= 0; i--)
			res += char(c[i] + '0');
		return BINT(res);            //临时BINT类型
	}
	const BINT operator*(const BINT &t) {
		string sa = s, sb = t.s;
		int la = sa.size(), lb = sb.size();
		int m = la + lb;
		vector<int>a(m + 1, 0), b(m + 1, 0), c(m + 1, 0);
		for (int i = 0; i < la; i++)   //逆序存数
			a[i] = sa[la - 1 - i] - '0';
		for (int i = 0; i < lb; i++)
			b[i] = sb[lb - 1 - i] - '0';
		for (int i = 0; i < la; i++)
			for (int j = 0; j < lb; j++) {
				c[i + j] += a[i] * b[j];
				c[i + j + 1] += c[i + j] / 10;
				c[i + j] %= 10;
			}
		while (!c[m] && m) m--;
		string res;
		for (int i = m; i >= 0; i--)
			res += char(c[i] + '0');
		return BINT(res);
	}
	bool operator<(const BINT &t) {
		string b = t.s;
		if (s.size() < b.size()) return true;
		if (s.size() == b.size() && s < b) return true;
		return false;
	}
	void operator=(const string &x) {      //重载赋值运算符
		s = x;
	}
	void operator=(const long long &x) {   //重载赋值运算符
		s = to_string(x);
	}
	void operator=(const int &x) {   //重载赋值运算符
		s = to_string(x);
	}
	friend istream& operator>>(istream & in, BINT & t) {
		in >> t.s;         //友元函数 重载>>右移运算符为输入
		return in;
	}
	friend ostream& operator<<(ostream & out, const BINT & t) {
		out << t.s;        //友元函数 重载 <<左移运算符为输出
		return out;        //const允许输出常量
	}
};
int n, m;
string s;
BINT dp[45][45], D[45][45];
int main() {
	cin >> n >> m >> s;
	s = " " + s;
	for (int i = 1; i <= n; i++)
		for (int j = i; j <= n; j++) {
			D[i][j] = s.substr(i, j - i + 1);
//			cout << D[i][j] << " ";
		}
	for (int i = 1; i <= n; i++)
		dp[i][0] = D[1][i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			if (j >= i) break;
			for (int k = j; k < i; k++)
				if (dp[i][j] < dp[k][j - 1] * D[k + 1][i])
					dp[i][j] = dp[k][j - 1] * D[k + 1][i];
		}

	cout << dp[n][m];
	return 0;
}
```

---

## 作者：XHCuteDog (赞：12)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=51;
int n,k;
//一波小广告:本人博客https://www.luogu.org/blog/sshilyzyx/
//本题重点,坑:使用高精度,在对数字进行插入数组时,应当从低位逐渐向高位读入.
//eg:12345读入应为54321. 
string s;//读入为字符串,再将其转化为数字. 
struct hd{
    int len;
    int d[maxn];
};  //定义一个结构体,len记录一个数字的长度,即位数,d[i]记录该数字的第i位. 
hd f[maxn][50];//定义f数组,表示在前maxn个数中插入50以内个乘号.
               //(f[i][j]表示一个数,在前i个数字中插入j个"*"后所得最大值).
void init(hd &A,int l,int r)
{
    A.len=r-l+1;//string类型第i个应从第0个开始数起,s[i]表示s的第i-1个元素.   
    for(int i=1,j=r-1;j>=l-1;i++,j--)
        A.d[i]=s[j]-'0'; //字符转数字. 
}
void mul(hd &Z,hd X,hd Y)//&z表示在该函数中对z的修正是"永久性"的,余下的两个则不然. 
{   //X,f[k][j-1],Y 
    for(int i=1;i<maxn;i++)
        Z.d[i]=0;//"一劳永逸"初始化. 
    for(int i=1;i<=X.len;i++)
        for(int j=1;j<=Y.len;j++)
            Z.d[i+j-1]+=X.d[i]*Y.d[j];//存入乘积. 
    for(int i=1;i<maxn;i++)
    {
        Z.d[i+1]+=Z.d[i]/10;//对每一位上的数字进行修正. 
        Z.d[i]=Z.d[i]%10;//同上. 
    }
    int i;
    for(i=maxn-1;i>1;i--)
        if(Z.d[i])break;//从后向前一次列举,第一个非零数即该数字的最高位. 
    Z.len=i;//修正该数字的位数. 
}
void pr(hd X)
{
    for(int i=X.len;i>=1;i--)
        cout<<X.d[i];//由于反向插入,所以输出时也应反向依次输出. 
    cout<<endl;
}
bool bigger(hd X,hd Y)
//比较数字大小的方法:1\位数大的数大于位数小的数;在1不满足时:
//从后往前列举,对每次遇到的数字进行比较,第一次出现大小不同时,较大者其整体数字大. 
{
    if(X.len!=Y.len)
        return X.len>Y.len;
    for(int i=X.len;i>=1;i--)
        if(X.d[i]!=Y.d[i])
            return X.d[i]>Y.d[i];
}
int main()
{
    cin>>n>>k;//n表示有n位数,插入k个"*". 
    cin>>s;//读入字符串. 
    for(int i=1;i<=n;i++)
        init(f[i][0],1,i);//表示前i个数中插入0个"*". 
    for(int j=1;j<=k;j++)//当前已插入的"*"个数. 
        for(int i=j+1;i<=n;i++)//数字位数至少应比"*"数多1,且小于数字总位数. 
        {
            f[i][j].len=0;//初始化该值为0,努力将其刷为更大值. 
            hd X,Y;
            for(int k=j;k<i;k++)
            {
                init(Y,k+1,i);
                mul(X,f[k][j-1],Y);//???
                if(bigger(X,f[i][j]))//取大值,若X>f[i][j],则进行修正. 
                    f[i][j]=X;
            }
        }
    pr(f[n][k]);//利用函数进行输出. 
    return 0;	
}

```


---

## 作者：yr409892525 (赞：6)

使用 dp 解决此题。              
设
$dp_{i,j}$ 代表前 $i$ 位使用 $j$ 个乘号的最大乘积，
$a_{i,j}$ 代表字符串的 $i \sim j$ 位。               
首先 $dp_{i,0}=a_{1,i}$。                 
对于每个 $(i,j)$，可以枚举乘号的位置 $k$。               
$dp_{i,j}=\max(dp_{i,j},dp_{k,j-1} \times a_{k+1,j})$。         
但是答案太大，需要使用高精度。             
代码按照步骤实现即可。

---

## 作者：Co_Ce (赞：5)

# Solution
[link](https://www.luogu.com.cn/problem/P1018)
# 解析：
**状态定义**：$dp[i][j]$ 表示前 $i$ 个数分成 $j$ 段（即需要 $j+1$个*）的最大乘积。  
**状态转移**：$dp[i][j] = \max(dp[k-1][j-1] \times a[k][i], dp[i][j])$，表示在第 $k-1$ 和第 $k$ 个数之间加上一个*得到的最大值，其中前 $k-1$ 个数采用的是 $dp[i][k-1]$ 值，即被分为了 $j-1$ 段后的最大值，而后面的数（从 $k$ 到 $i$）则视为一整个数，与前面的 $dp$ 值相乘。遍历全部 $k$ 的位置，取最大值即为 $dp[i][j]$。  
由于要保存和计算的数最高为 $40$ 位，因此还需要采用高精度。  
整体思路就是先写出来非高精度版，再将其中的乘、加改成高精度的函数即可。

---

## 作者：tangzirui1016 (赞：4)

发现 $n$ 和 $k$ 的范围都不大，但是暴搜会超时，考虑 dp 优化。

定义 $dp_{i,j}$ 表示前 $i$ 个数字放了 $j$ 个乘号的最大结果（保证合法，即最后一个乘号不在最后一个数字后）。 

枚举最后一个乘号放哪里，也就是枚举上一步操作，$num_{l,r}$ 表示从序列的 $l$ 到 $r$ 表示数字，那么有递推式：    
$$dp_{i,j}=\max_{j\le p <i} dp_{p,j-1}\times num_{p+1,i}$$

其中 $p$ 的左右边界是保证枚举的时候合法。

枚举时，应该先从 $j$ 开始枚举，因为这样才能保证后面每一次转移时上一步的答案已经得出来了。

该题还有个坑点就是要用高精度，且高精度前先要特判 $0$……

时间复杂度为大致为 $O(n^4k)$。

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=40,K=6;
int n,k;
string dp[N+5][K+5],s,num[N+5][N+5]; //在第i个数字前放j个乘号 
string Max(string a,string b){
	if(a.empty()) return b;
	if(b.empty()) return a;
	if(a.size()!=b.size()) return a.size()>b.size()?a:b;
	return a>b?a:b;
	//对于字符串数字比大小，先比长度，再比字典序 
}
string init(int l,int r){
	int pos=l;
	while(pos<r&&s[pos]=='0') pos++;
	return s.substr(pos,r-pos+1);
}
string cheng(string a,string b){ //高精度 
	if(a=="0"||b=="0") return "0"; //记得特判 
	int x[1005]={},y[1005]={},z[1005]={};
	int len=a.size()+b.size(); 
	string c;
	for(int i=0;i<a.size();i++) x[a.size()-i]=a[i]-'0';
	for(int i=0;i<b.size();i++) y[b.size()-i]=b[i]-'0';
	for(int i=1;i<=a.size();i++){
		for(int j=1;j<=b.size();j++){
			z[i+j-1]+=x[i]*y[j];
			z[i+j]+=z[i+j-1]/10;
			z[i+j-1]%=10;
		}
	}
	if(!z[len]) len--;
	for(int i=len;i>=1;i--) c+=char(z[i]+'0');
	return c;
}
int main(){
	cin>>n>>k>>s;
	s=' '+s; //整体后移 
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++) num[i][j]=init(i,j);
	}
	for(int i=1;i<=n;i++) dp[i][0]=num[1][i];
	for(int j=1;j<=k;j++){
		for(int i=j+1;i<=n;i++){
			for(int p=j;p<i;p++){
				dp[i][j]=Max(dp[i][j],cheng(dp[p][j-1],num[p+1][i]));
			}
		}
	}
	cout<<dp[n][k];
	return 0;
}
```

---

## 作者：x11223344 (赞：3)

以下设 $num_{l,r}$ 代表区间 $[l,r]$ 代表的数字，下标从 $0$ 开始。

提供两个解法：  
方法 1：区间 dp，设 $dp_{l,r,i}$ 代表区间 $[l,r]$，使用了 $k$ 个乘号乘积的最大值。  
初始条件：$dp_{l,r,0}=num_{l,r}$。  
转移方程：  
考虑在哪两个数中间放乘号以及左右的有多少个乘号，可得：
$$
dp_{l,r,i}=\max_{k=l}^{r-1}\max_{j=0}^{i-1}dp_{l,k,j} \times dp_{k+1,r,i-j-1}
$$
最终答案为 $dp_{0,N-1,K}$。

方法 2：线性 dp，设 $dp_{i,j}$ 代表前 $i$ 个数，有 $j$ 个乘号乘积的最大值。  
初始条件：$dp_{i,0}=num_{0,i}$。  
转移方程：  
考虑最后一个乘号放在那两个数中间，可得：
$$
dp_{i,j}=\max_{k=0}^{i-1}dp_{k,j-1} \times num_{k+1,i}
$$
最终答案为 $dp_{N-1,K}$。

注意：需要写高精。

---

## 作者：mcturtle (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1018#submit)
## 题目大意
设有一个长度为 $N$ 的数字串，要求选手使用 $k$ 个乘号将它分成 $(k+1)$ 个部分，找出一种分法，使得这 $(k+1)$ 个部分的乘积能够为最大。
## 解题思路
一道好题。

首先使用高精度进行操作，因为此题数据范围太大，数位长度不大于 $40$，这个数据连 `__int128` 都会爆精度。

其次进行 $\texttt{DFS}$ 搜索。数据范围对于搜索来说还可以，加一些剪枝就能通过。

搜索内容并不难，选择乘号插入的位置并求积，再定义一个变量取存储最大值就行。

剪枝就更简单了，如果剩余数字数量大于剩下能插乘号的空位，直接 `return;` 就行了。

## 总结

就不贴代码了，总体难度不高，只是因为高精度才绿，不然就是橙题搜索。

---

## 作者：FastIO_DP (赞：3)

### 题目理解

题目给出一个长度为 $N$ 的数字串，要求在其中插入 $K$ 个乘号，将数字串分成 $K+1$ 个部分，使得这 $K+1$ 个部分的乘积最大。

### 解题思路

考虑动态规划。

所以可以定义状态 $dp_{i,j}$ 表示将前 $i$ 个数字分成 $j+1$ 部分时的最大乘积。

$dp_{i,0}$ 表示将前 $i$ 个数字分成 $1$ 部分时的最大乘积，也就是整个数字串本身。

#### 推转移方程

要求 $dp_{i,j}$，就需要枚举最后一个乘号的位置 $k$（$k$ 的范围是 $j-1$ 到 $i-1$），然后将前 $k$ 个数字分成 $j$ 部分。最后将剩下的 $k+1$ 到 $i$ 部分作为一个整体。状态转移方程为：

$$
dp_{i,j} = \max(dp_{i,j}, dp_{k,j-1} \times \text{num}(k+1, i))
$$

这里的 $\text{num}(k+1, i)$ 表示从第 $k+1$ 个数字到第 $i$ 个数字组成的数字。

好的，我们推完了状态转移方程，直接实现就 ok 了。对了，答案可能会超 long long 所以要用高精度。

```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;

struct BI {
    int d[100];
    int len;

    BI() {
        memset(d, 0, sizeof(d));
        len = 0;
    }
    BI(const string& s) {
        memset(d, 0, sizeof(d));
        len = s.size();
        for (int i = 0; i < len; ++i) {
            d[i] = s[len - 1 - i] - '0';
        }
    }

    string toStr() const {
        string s;
        for (int i = len - 1; i >= 0; --i) {
            s += to_string(d[i]);
        }
        return s;
    }

    BI operator*(const BI& o) const {
        BI res;
        for (int i = 0; i < len; ++i) {
            int c = 0;
            for (int j = 0; j < o.len; ++j) {
                int p = d[i] * o.d[j] + res.d[i + j] + c;
                res.d[i + j] = p % 10;
                c = p / 10;
            }
            if (c) {
                res.d[i + o.len] += c;
            }
        }
        res.len = len + o.len;
        while (res.len > 1 && res.d[res.len - 1] == 0) {
            res.len--;
        }
        return res;
    }

    bool operator<(const BI& o) const {
        if (len != o.len) {
            return len < o.len;
        }
        for (int i = len - 1; i >= 0; --i) {
            if (d[i] != o.d[i]) {
                return d[i] < o.d[i];
            }
        }
        return false;
    }
};

int N, K;
string s;
BI dp[50][10];

BI num(int l, int r) {
    string sub = s.substr(l, r - l + 1);
    return BI(sub);
}

int main() {
    cin >> N >> K;
    cin >> s;

    for (int i = 0; i < N; ++i) {
        dp[i][0] = num(0, i);
    }

    for (int j = 1; j <= K; ++j) {
        for (int i = j; i < N; ++i) {
            for (int k = j - 1; k < i; ++k) {
                BI t = dp[k][j - 1] * num(k + 1, i);
                if (dp[i][j] < t) {
                    dp[i][j] = t;
                }
            }
        }
    }

    cout << dp[N - 1][K].toStr() << endl;

    return 0;
}
```

#### 复杂度分析

- 时间复杂度：$O(n^2 \times k)$，其中 $n$ 是数字串的长度，$k$ 是乘号的数量。
- 空间复杂度：$O(n \times k)$，用于存储 dp 表。

---

## 作者：sunny12888 (赞：3)

## 题目大意
现给你一串数字，允许你在中间添加 $k$ 个乘号，使得最后的结果最大。
## 题目分析
由数据范围可知，$n$ 不超过 $40$。表示这个数最多 $40$ 位。只能使用高精度算法。把数据存入数组进行计算。

~~由于我不太会 DP~~，所以这题我使用 DFS，若在这个数后要放乘号，就做标记，并做记录。直到乘号数等于 $k$，并计算每一次的结果。最后输出最大的即可。

### 举个例子
若这个数为 $1231$，$k=2$，第一次放在 $1$ 和 $2$ 的后面，计算出结果为 $62$；再放在 $1$ 和 $3$ 的后面，计算出结果为 $23$；以此类推。发现最后最大的是 $62$，则输出即可。

代码请自行实现。

---

## 作者：lutaoquan2012 (赞：2)

### 题意：
给定一个长度为 $n$ 的字符串，在中间插入 $k$ 个乘号，使得乘积最大。

### 思路：
可以用暴力枚举加剪枝，也可以用动态规划。

#### 设置状态：
$f_{i,j}$ 表示在前 $i$ 个数中，插入了 $j$ 个乘号的最大值。

#### 状态转移：
$$f_{i,j}=f_{k,j-1}\times b_{k+1,i}$$

$k$ 的范式是从 $j$ 到 $i-1$，因为在前 $i$ 个数字中，最多只能插入 $i-1$ 个乘号。

$b_{i,j}$ 表示的是从第 $i$ 个数字到第 $j$ 个数字连起来的数。

转移的意思大概是 $f_{i,j}$ 是在第 $k$ 个和第 $k+1$ 的中间加入一个乘号中能获取的最大值。

#### 初始状态：
如果在前 $i$ 个数字中，一个乘号也不插入，那就是他们连起来的数字，也就是 $b_{1,i}$。
### 代码：
没加高精度：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,k,dp[50][50],b[50][50];
string s;
int main(){
	scanf("%lld%lld",&n,&k);
	cin>>s;
	s=" "+s;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++) b[i][j]=b[i][j-1]*10+s[j]-'0';
	for(int i=1;i<=n;i++) dp[i][0]=b[1][i];
	for(ll i=1;i<=n;i++)
		for(int j=1;j<=min(k,i);j++)
			for(int k=j;k<i;k++) dp[i][j]=max(dp[i][j],dp[k][j-1]*b[k+1][i]); 
	printf("%lld\n",dp[n][k]);
	return 0;
}
```

---

## 作者：mairuisheng (赞：2)

[P1018 [NOIP2000 提高组] 乘积最大](https://www.luogu.com.cn/problem/P1018)

算法：搜索、高精度

分析：深搜乘号的插入位置，再求积，这里有个剪枝：当插完这个乘号后，发现剩下乘号的数量大于剩下可插乘号的空位，就直接返回。看到题目数位最多有 $40$ 位，所以要用高精度。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char s;
    s=getchar();
    while(s<'0'||s>'9')
    {
        if(s=='-')f=-f;
        s=getchar();
    }
    while(s>='0'&&s<='9')
    {
        x=(x<<3)+(x<<1)+(s-48);
        s=getchar();
    }
    return x*f;
}
int N,K;
int ch[7];
string a;
string num[41][41];
string ans;
string times(string val,string k)//高精度乘法模板
{
	if((val.length()<k.length())||((val.length()==k.length())&&(val<k)))swap(val,k);
	string ret="";
	bool fl=false;
	int lenv=val.length(),lenk=k.length();
	int s1[101],s2[101],c[1001];
	memset(c,0,sizeof(c));
	int i,j,x,t,w=lenv+lenk,t2;
	for(i=0;i<lenv;++i)s1[i+1]=val[lenv-i-1]-48;
	for(i=0;i<lenk;++i)s2[i+1]=k[lenk-i-1]-48;
	for(i=1;i<=lenv;++i)
	{
		for(j=1;j<=lenk;++j)
		{
			t=s1[i]*s2[j];
			c[i+j-1]+=t%10;
			if(c[i+j-1]>9)
			{
				t2=c[i+j-1]/10;
				c[i+j-1]%=10;
				c[i+j]+=t2;
			}
			c[i+j]+=t/10;
		}
	}
	for(i=w;i>0;--i)
	{
		if(c[i]!=0)fl=true;
		if(fl)ret+=(c[i]+48);
	}
	if(!fl)ret="0";
	return ret;
}
string solve()//求积
{
	int lt=ch[1],i;
	string val=num[1][lt];
	for(i=2;i<=K;++i)
	{
		val=times(val,num[lt+1][ch[i]]);
		lt=ch[i];
	}
	val=times(val,num[lt+1][N]);
	return val;
}
void dfs(int l,int k)//搜索乘号位置
{
	if(k==0)
	{
		string val=solve();
		if((val.length()>ans.length())||((val.length()==ans.length())&&(val>ans)))ans=val;
		return;
	}
	int i;
	for(i=l;i<=N-k+1;++i)
	{
		ch[K-k+1]=i;
		dfs(i+1,k-1);
	}
}
int main()
{
	int i,j;
    N=read();
    K=read();
    cin>>a;
    for(i=1;i<=N;++i)num[i][i]=a[i-1];
    for(i=1;i<=N;++i)//num[i][j]表示第i位到第j位的数字
    {
    	for(j=i;j<=N;++j)
	    {
	    	if(i!=j)num[i][j]=num[i][j-1]+num[j][j];
		}
	}
    dfs(1,K);
    cout<<ans;
    return 0;
}
```

---

## 作者：xiaobeng_0912 (赞：1)

## $\mathbf{Knowledge}$

1. 动态规划
1. 高精度

## $\mathbf{Solution}$

看到题目，我们就想到用 dfs 或者 dp 去做。在这里，我就来介绍一种 dp 的解法。

设 $dp_{i,j}$ 为在第 $i$ 个数字后放置第 $j$ 个乘号，这个乘号前面的算式能形成的最大乘积。

于是，我们就可以得到转移方程（其中 $ \operatorname{cut}(l,r)$ 为从题目给定的数字串中截取第 $l$ 位到第 $r$ 位所组成的新数）：

$$dp_{i,j}=\max\limits_{l=j-1}^{i-1}\{dp_{l,j-1}\times \operatorname{cut}(l+1,i)\}$$

最后，答案就可以表达为（$n$ 和 $k$ 同题意）：

$$ans=\max\limits_{i=1}^{n}\{dp_{i,k}\times \operatorname{cut}(i+1,n)\}$$

顺便提一句，因为 $n\le40$，所以需要用到高精度！

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string s,ans="0",dp[41][7];//ans 别忘了赋初值 
string add(string x,string y){//高精度加法 
	int tmp[20001];
	string res="";
	reverse(x.begin(),x.end());
	reverse(y.begin(),y.end());
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<max(x.size(),y.size());i++){
		if(i>=y.size()){
			y+="0";
		}
		if(i>=x.size()){
			x+="0";
		}
		tmp[i]+=(x[i]-'0')+(y[i]-'0');
		tmp[i+1]+=tmp[i]/10;
		tmp[i]%=10;
	}
	for(int i=max(x.size(),y.size());i>=0;i--){
		if(tmp[i]==0&&i==max(x.size(),y.size())){
			continue;
		}
		res+=char(tmp[i]+'0');
	}
	return res;
}
string mul(string x,string y){//高精度乘法 
	int tmp[20001],flag=0;
	string res="";
	reverse(x.begin(),x.end());
	reverse(y.begin(),y.end());
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<x.size();i++){
		for(int j=0;j<y.size();j++){
			tmp[i+j]+=(x[i]-'0')*(y[j]-'0');
		}
	}
	for(int i=0;i<x.size()+y.size();i++){
		if(tmp[i]>=10){
			tmp[i+1]+=tmp[i]/10;
			tmp[i]%=10;
		}
	}
	for(int i=x.size()+y.size()-1;i>=0;i--){
		if(tmp[i]!=0||flag==1){
			flag=1;
			res+=(tmp[i]+'0');
		}
	}
	return res;
}
string Max(string x,string y){//高精度比大小 
	if(x.size()!=y.size()){
		return (x.size()>y.size())?x:y;
	}
	return x>y?x:y;
}
string cut(int l,int r){//分割数位，把数字串 l 到 r 的这部分的数字变为一个独立的数 
    string a="0",tmp;
    for(int i=l;i<=r;i++){
    	tmp=s[i];//别忘了把 s[i] 变为字符串再弄进 add 函数里！ 
        a=add(mul(a,"10"),tmp);
    }
    return a;
}
int main(){
    scanf("%d%d",&n,&k);
    cin>>s;
    s=' '+s;//将 s[1] 变为字符串 s 的开头，后面的字符顺延 
    for(int i=1;i<n;i++){//动态规划部分 
        dp[i][1]=cut(1,i);//赋初始值 
        for(int j=2;j<=k;j++){
            for(int l=j-1;l<i;l++){
                dp[i][j]=Max(dp[i][j],mul(dp[l][j-1],cut(l+1,i)));//转移方程 
            }
        }
    }
    for(int i=1;i<n;i++){
    	ans=Max(ans,mul(dp[i][k],cut(i+1,n)));//求出答案 ans 
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Sunrise_beforeglow (赞：0)

我们定义 $dp_{i,j}$ 表示在前 $i$ 个数中添加 $j$ 个乘号的乘积最大值。

接下来定义 $f_{l,r}$ 表示数字串的 $[l,r]$ 区间所形成的数字。

初始状态，$dp_{0,j}=0,dp_{j,0}=f_{1,j}$。

考虑转移方程，可以枚举在哪个地方添加乘号，比如在 $k$ 位置添加乘号，那么其实类似这样的。

$$a_1a_2\cdots a_k\times f_{k+1,i}$$

其中 $a_1a_2\cdots a_k$ 其实就是在前 $k$ 个数中添加 $j-1$ 个乘号的乘积最大值。

最终答案 $dp_{N,K}$。

注意由于最终答案很大，所以要使用高精度。
```cpp
#include <bits/stdc++.h>
using namespace std;
string dp[45][10];
int n,k;
string s;
//dp[i][j]表示前i个数字中有k个乘号的最大值  
string cheng(string a,string b)
{
	int x[2005]={},y[2005]={},z[2005]={};
	for(int i=a.size()-1,j=1;i>=0;i--,j++)x[j]=a[i]-'0';
	for(int i=b.size()-1,j=1;i>=0;i--,j++)y[j]=b[i]-'0';
	int len=a.size()+b.size();
	for(int i=1;i<=a.size();i++)
	{
		for(int j=1;j<=b.size();j++)
		{
			z[i+j-1]+=x[i]*y[j];
			z[i+j]+=z[i+j-1]/10;
			z[i+j-1]%=10;
		}
	}
	if(z[len]==0)len--;
	string c="";
	for(int i=len;i>=1;i--)c=c+char(z[i]+'0');
    while(c[0]=='0')c=c.substr(1);
    if(c=="")c="0";
	return c;
}
string maxx(string a,string b)
{
	if(a.size()>b.size())return a;
	else if(a.size()<b.size())return b;
	else if(a>b)return a;
	else return b;
}
int main()
{
	cin>>n>>k;
	cin>>s;
    s=" "+s;
	for(int i=1;i<=n;i++)dp[i][0]=s.substr(1,i);
	for(int i=1;i<=k;i++)dp[0][i]="1";
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			for(int k=1;k<=i-1;k++)
			{
				dp[i][j]=maxx(dp[i][j],cheng(dp[k][j-1],s.substr(k+1,i-k)));
			}
		}
	} 
	string a=dp[n][k];
    while(a[0]=='0')a=a.substr(1);
    if(a!="")cout<<a;
    else cout<<0;
 	return 0;
}
```

早期马蜂不要在意。

---

## 作者：AFO_Lzx (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P1018)

### $\texttt{Description}$

将一个 $n$ 位数分为 $(k+1)$ 个数字，输出这 $(k+1)$ 个数字的总乘积的最大值。

### $\texttt{Solution}$

前置知识：[高精度乘法](https://oi.wiki/math/bignum/#%E4%B9%98%E6%B3%95) & [DFS](https://oi.wiki/search/dfs/)

首先看**数据范围**，$n \le 40$，所以这题肯定需要高精度。这也是这题能够成为绿题的一个原因。附赠一个高精度乘法模板：[link](https://www.luogu.com.cn/paste/oqraj8r0)

$\texttt{DFS}$ 部分就是遍历字符串然后对于每一个位置**分或不分**，如果分的话就将计数器 $+1$，如果计数器等于 $k$，也就是已经分成了 $(k+1)$ 段（这里记录分的**次数**），那么就计算答案并比较大小，然后返回。

另外因为是高精度，所以我们需要手写**比较大小的函数**。

不贴代码。

---


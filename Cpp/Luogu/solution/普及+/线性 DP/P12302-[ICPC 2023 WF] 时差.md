# [ICPC 2023 WF] 时差

## 题目描述

ICPC World Finals 到了，其中有很多你想参加的活动——演讲、现场展示、趣味活动，更不用说比赛本身了。只有一个问题：你什么时候睡觉？

当你入睡时，你总是会设置一个闹钟，否则你就可能一直睡下去。用了闹钟，你就可以选择睡任意正整数分钟。在睡 $k$ 分钟后，你会再休息 $k$ 分钟（因此你将无法再次入睡）；然后你将能够在第三个 $k$ 分钟内正常活动（因此你可以保持清醒，但如果你想睡觉，也可以直接睡）。

你知道 WF 所有活动的时间；你应该计划好自己的睡眠时间，以免错过任何活动的任何部分。就在 WF 开始前（第 $0$ 分钟），你会经过长途旅行抵达酒店房间，需要立即入睡。

## 说明/提示

如遇 SPJ 相关问题，请联系搬题人 @[StayAlone](https://www.luogu.com.cn/user/409236)。

## 样例 #1

### 输入

```
3
30 45
60 90
120 180
```

### 输出

```
2
0 30
90 120
```

## 样例 #2

### 输入

```
1
0 60
```

### 输出

```
impossible
```

## 样例 #3

### 输入

```
7
31 32
35 41
48 55
69 91
1000 2022
2022 2023
2994 4096
```

### 输出

```
5
0 5
10 28
56 68
92 900
2025 2900
```

# 题解

## 作者：Shunpower (赞：4)

一道好题。

--------------

一个贪心的想法是，显然我会希望在某个活动结束后立即睡觉，这样我的可操作空间最大。但是这不行，因为如果活动结束的时刻落在 $[k,2k)$ 之内就不一定可以睡。

考虑一个关键点：如果我们现在在 $[2k,3k]$ 阶段，那么我们是可以想睡就睡的。

所以我们只需要想办法让活动结束在这个阶段内就行。考虑一个结束在 $[k,2k)$ 的活动，如果我希望在这个活动结束后睡觉，那么我只需要减小上一次睡觉的时间就行了！因为睡觉时间可以取任何正整数，而此处 $k\ge 2$，所以一定可以通过调整使得活动结束在 $[2k,3k]$ 内部。

于是我们得出结论：只要有方案，一定存在一种方案使得我必然总是在活动结束后睡觉。

考虑 dp。$f_i$ 表示在第 $i$ 个活动后立即睡觉是否可行。那么考虑转移：$f_i$ 处尝试从第 $j$ 个活动结束后开始立即睡觉，睡觉时间可以取 $t\in(0,b_{j+1}-e_j]$ 的任何数，并要求保持清醒直到 $e_i$。显然，只要满足 $e_i-e_j\le 3(b_{j+1}-e_j)$ 就一定可以找到一个满足要求的 $t$（这个条件说明我们至少存在一个可取的 $t$，我们前面已经说明总是可以调整得到一个 $t$ 使得 $e_i\in[2t,3t]$）。

于是转移是：

$$
f_i\gets f_j,\ \ j<i\land e_i-e_j\le 3(b_{j+1}-e_j)
$$

我们可以在 dp 过程中记录转移项，然后在最后往回构造。往回构造就是两个不等式，一个限制我们必须在活动结束时位于 $[2t,3t]$，一个限制 $t$，随便解一下就行。

于是我们获得了一个 $\mathcal O(n^2)$ 的做法：

```cpp
int n;
int dp[N];
int lst[N];
ll b[N],e[N];
vector <pll> ans;
int main(){
#ifdef Shun
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	ios::sync_with_stdio(false);
	cin>>n;
	fr1(i,1,n) cin>>b[i]>>e[i];
	dp[0]=1;
	fr1(i,1,n){
		fr2(j,i-1,0){
			if(dp[j]&&(e[i]-e[j])<=3*(b[j+1]-e[j])){
				lst[i]=j;
				dp[i]=1;
				break;
			}
		}
		// cout<<dp[i]<<endl;
	}
	if(!dp[n]) cout<<"impossible\n";
	else{
		int x=n;
		while(x){
			int id=lst[x];
			ll t=b[id+1]-e[id];
			ll T=e[x]-e[id];
			// cout<<t<<" "<<T<<endl;
			ll k=(T+2)/3;
			ans.push_back({e[id],e[id]+k});
			x=lst[x];
		}
		reverse(ans.begin(),ans.end());
		cout<<ans.size()<<'\n';
		for(auto i:ans) cout<<i.fi<<" "<<i.se<<'\n';
	}
	ET;
}
//ALL FOR Zhang Junhao.
```

转移显然可以优化，移项之后形如 $e_i\le \text{Poly}(j)$，由于右侧是一个只关于 $j$ 的多项式，所以我们动态维护它的最大值和最大值位置就可以了。只需将 dp 部分改为下面这样即可通过：

```cpp
maxn=3*b[1];
fr1(i,1,n){
	if(e[i]<=maxn) dp[i]=1,lst[i]=tf;
	if(dp[i]){
		ll coef=3*b[i+1]-2*e[i];
		if(maxn<coef) maxn=coef,tf=i;
	}
	// cout<<dp[i]<<endl;
}
```

时间复杂度 $\mathcal O(n)$。

---

## 作者：Toorean (赞：1)

我们可以采取从后向前反向构造的方式贪心地做。

假设我们在 $[j,i]$ 活动 **一直** 保持清醒，那么这一段的睡觉时间 $k$ **至少** 为  $\lceil\dfrac{e_i-b_j}{2}\rceil$，那么开始睡觉的时间即为 $st=b_j-k$。我们只能保证这个时间对于 $i$ 合法，无法保证与其余无交，故做出如下分类讨论。

- 若 $e_{j-1}>st$，也就是说在活动期间睡觉，不合法。我们令 $j\gets j-1$，继续回溯下去直至睡眠合法。

- 若上不成立，且 $e_{j-1}\ge st-1$，我们可以在 $t_{j-1}$ 时刻就开始睡觉，直至 $b_j$。我们考虑一种极限情况：当 $e_{j-1}=st-1$ 且 $e_i=b_j+1$，如果此时我们睡到 $b_j$，那么会导致结束在 $[k,2k)$ 区间，可能会影响下一次操作。因此，我们此时使其睡到 $b_j-1$，即可保证其下一次睡眠是合法的。

- 若 $e_{j-1}<st-1$，我们可以 $[st,b_j]$ 时间段睡，在这之前睡一段 $k$ 能保证 $st$ 在第三个 $k$ 之中即可。

直至 $j=0$，此时找不到合法的睡眠区段，无解。

---


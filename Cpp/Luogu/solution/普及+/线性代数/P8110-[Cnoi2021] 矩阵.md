# [Cnoi2021] 矩阵

## 题目背景

Rumia 喜欢矩阵快速幂，而 Cirno 觉得这是平凡的。

为了说服 Rumia，Cirno 提出了这样一个问题。

## 题目描述

给定两个长度为 $n$ 的序列 $\{a_n\}$，$\{b_n\}$ 与一个整数 $k$。

设矩阵 $A$ 满足 $A_{ij}=a_i\times b_j$，求 $A^k$ 的所有元素的和在模 $998244353$ 意义下的结果。

## 说明/提示

**数据范围**

对于 $100\%$ 的数据保证 $1 \le n \le 10^5$，$0\le k < 998244353$，$|a_i|,|b_i| \le 10^9$。

**子任务**

Subtask1（10 points）：$n, k \le 50$。

Subtask2（20 points）：$n \le 100$。

Subtask3（20 points）：$n \le 1000$。

Subtask4（50 points）：无特殊限制。

**提示**

矩阵乘法的定义参考[百度百科](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029?fr=aladdin)页面。

本题中 $A^0$ 表示[单位矩阵](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5/8540268?fr=aladdin)。

## 样例 #1

### 输入

```
3 0
1 2 3
4 5 6```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3
1 2 3
4 5 6```

### 输出

```
92160```

# 题解

## 作者：0xFF (赞：12)

#### 题目大意


------------
给定一个长度为数列 $a$ 和序列 $b$，同时给定一个数字 $k$。

设一个矩阵 $A$ 满足 $A_{ij} = a_i \times b_j$,求 $A^k$ 的所有元素的和在模 $998244353$ 意义下的答案。

#### 思路分析


------------
~~我会暴力~~

我会矩阵快速幂优化！ 

理论上讲矩阵快速幂是可以通过前两个子任务的，然而由于本人实力有限，经过不断调试还是没能达到[预期](https://www.luogu.com.cn/record/77071749)。

注意到由于 $1 \le n \le 10^5$，甚至无法开一个二维数组存储 $A$ 矩阵。

首先可以发现 $A$ 矩阵是由 $a$ 序列和 $b$ 序列经过操作得到，不妨将 $a$ 序列看作一个 $n$ 行 $1$ 列的矩阵，将 $b$ 序列看作一个 $1$ 行 $n$ 列的矩阵，那么 $a \times b$ 就可以得到 $n$ 行 $n$ 列的矩阵 $A$，这样显然是无法通过本题的。

矩阵乘法虽然没有交换律但是有结合律，所以 $A^k$ 相当于 $(a \times b) ^ k$，将该式展开得到 $(a \times b \times a \times b ......\times b \times a \times b)$，观察除去首项和尾项的 $2k-2$ 项，可以发现他们就是 $(b \times a)^{k-1}$，同时 $b \times a$ 可以得到一个 $1 \times 1$ 的矩阵，也就是一个值即为 $\sum_{i=1}^{n} a_i \times b_i$。这样就可以将矩阵乘法转化成整数的乘法。

接下来我们需要处理刚才忽略的首项和尾项，由于中间 $2k-2$ 项结果是一个值，所以我们可以将此值提出，只对未进行操作的首项和尾项操作。

$a \times b$ 会得到一个 $n$ 行 $n$ 列的矩阵，这个矩阵的元素的和为 $a_1\cdot \sum_{i = 1}^{n} b_i + a_2 \cdot\sum_{i = 1}^{n} b_i +...+a_n \times \sum_{i = 1}^{n} b_i$ 合并同类型可得答案为 $\sum_{i = 1}^{n} a_i \times \sum_{i = 1}^{n} b_i$

综上，我们只需要统计 $a$ 序列的和，$b$ 序列的和以及 $\sum_{i=1}^{n} a_i \times b_i$ 的乘积的和即可得到本题的答案。

```cpp
const int N = 1e5 + 10;
const int mod = 998244353;

int quickpower(int a,int b){
    int ans=1,base=a;
    while(b){
    	if(b&1){
    		ans*=base;
    		ans%=mod;
		}
		base*=base;
		base%=mod;
		b>>=1;
	}
    return ans;
}

int a[N],b[N];
int ans1 , ans2 ,ans3,ans;
signed main(){
	int n = read() , k = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
		ans1 += a[i];
		ans1 %= mod;
	}
	for(int i=1;i<=n;i++){
		b[i] = read();
		ans2 += b[i];
		ans2 %= mod;
	}
	if(k == 0){
		cout<<n<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		ans3 += a[i] * b[i] % mod;
		ans3 %= mod;
	}
	ans3 = quickpower(ans3,k-1);
	cout<<(ans1 % mod * ans2 % mod * ans3 % mod + mod) % mod<<endl;
	
    return 0;
}
```


---

## 作者：云浅知处 (赞：11)

随机跳题跳到的萌萌题

我们随便乘一下试试：记 $B=A\times A$，则

$$
B_{i,j}=\sum_{x=1}^nA_{i,x}\cdot A_{x,j}=\sum_{x=1}^na_ib_xa_xb_j=a_ib_j\cdot\sum_{x=1}^na_xb_x=A_{i,j}\cdot\sum_{x=1}^na_xb_x
$$

所以这个乘法其实就是给每一项都乘上 $\sum a_xb_x$。算出这个值用普通快速幂求解即可。

另一方面

$$
\sum_{i=1}^n\sum_{j=1}^nA_{i,j}=\sum_{i=1}^n\sum_{j=1}^na_ib_j=\left(\sum_{i=1}^na_i\right)\cdot\left(\sum_{i=1}^nb_i\right)
$$

所以答案就是

$$
\left(\sum_{i=1}^na_i\right)\cdot\left(\sum_{i=1}^nb_i\right)\cdot\left(\sum_{i=1}^na_ib_i\right)^{k-1}
$$

直接算就行了。复杂度 $O(n+\log k)$。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int MN=1e5+5;
const int mod=998244353;
int n,a[MN],b[MN],x,pa,pb,k;

int ksm(int x,int y,int p=mod){
    int res=1;x%=p;
    for(int i=y;i;i>>=1,x=x*x%p)if(i&1)res=res*x%p;
    return res;
}

signed main(void){

	n=read(),k=read();if(k==0){cout<<n<<endl;return 0;}
	for(int i=1;i<=n;i++)a[i]=read(),a[i]=(a[i]+mod+mod)%mod,pa+=a[i],pa%=mod;
	for(int i=1;i<=n;i++)b[i]=read(),b[i]=(b[i]+mod+mod)%mod,pb+=b[i],pb%=mod;
	
	for(int i=1;i<=n;i++)x=(x+a[i]*b[i]%mod)%mod;
	cout<<pa*pb%mod*ksm(x,k-1)%mod<<endl;

	return 0;
}
```

---

## 作者：Buried_Dream (赞：4)

## 前言

这篇题解可能有点啰嗦，个人还是觉得比较通俗易懂的。

这道题可能会用到点矩阵的知识，没学过矩阵的可以参考我的这篇博客：

[【矩阵浅谈】](https://www.luogu.com.cn/blog/wdnmdwdnmdwdnmd/ju-zhen-qian-tan-qwq)

## 题意：

给你两个序列 $\{a_n\},\{b_n\}$。

告诉你一个矩阵 $A$ 是满足 $A_{i,j} = a_i \times b_j$ 的。

求 $A^k$ 中所以元素的和。

## 思路：

看到数据范围 $n \le 10^5$ 和题目背景中的：

> `Rumia` 喜欢矩阵快速幂，而 `Cirno` 觉得这是平凡的。

能推出这题不是矩阵快速幂的板子，而是一个考虑两个数组对于这个矩阵的贡献的问题。

我们从样例 $1$ 入手：

```cpp
3 0
1 2 3
4 5 6
```

我们可以得到 $A$ 矩阵为：

```cpp
{4 5 6}         = {1 × 4, 1 × 5, 1 × 6}
{8 10 12}       = {2 × 4, 2 × 5, 2 × 6}
{12 15 18}      = {3 × 4, 3 × 5, 3 × 6}
```

发现 $2$ 个序列中每个点都有 $3$ 处贡献。

我们再考虑这个式子的实际意义：

就是 $a$ 序列中每个点都对应着 $b$ 序列中的每一个点。

所以说 $a$ 序列和 $b$ 序列中的每个点都会对原矩阵做出 $n$ 次贡献。

这个时候我们只考虑了序列对于矩阵 $A$ 的贡献，而不知道对于 $A^k$ 的贡献。

我们再来考虑矩阵乘法的式子的意义：

$$C_{i,j} = \sum_{r=1}^{b} A_{i,r} \times B_{r, j} $$

而这里 $A$ 矩阵和 $B$ 矩阵相同。

所以可以转化为：

$$C_{i,j} = \sum_{r=1}^{b} A_{i,r} \times A_{r, j} $$

```cpp
比如说：
矩阵的第一行：
c[1][1] = a[1][1] × a[1][1] + a[1][2] × a[2][1] + a[1][3] × a[3][1];
c[1][2] = a[1][1] × a[1][2] + a[1][2] × a[2][2] + a[1][3] × a[3][2];
c[1][3] = a[1][1] × a[1][3] + a[1][2] × a[2][3] + a[1][3] × a[3][3];
我们对于矩阵的第一行求和：
sum1 = c[1][1] + c[1][2] + c[1][3]
	= a[1][1] × (a[1][1] + a[1][2] + a[1][3]) + a[1][2] × (a[2][1] + a[2][2] + a[2][3]) + a[1][3] × (a[3][1] + a[3][2] + a[3][3])。
```

可能光看第一行你还不知道有什么规律，我再把第二行都列出来：

```cpp
矩阵的第二行：
c[2][1] = a[2][1] × a[1][1] + a[2][2] × a[2][1] + a[2][3] × a[3][1];
c[2][2] = a[2][1] × a[1][2] + a[2][2] × a[2][2] + a[2][3] × a[3][2];
c[2][3] = a[2][1] × a[1][3] + a[2][2] × a[2][3] + a[2][3] × a[3][3];
sum2 = c[2][1] + c[2][2] + c[2][3]
    = a[2][1] × (a[1][1] + a[1][2] + a[1][3]) + a[2][2] × (a[2][1] + a[2][2] + a[2][3]) + a[2][3] × (a[3][1] + a[3][2] + a[3][3]);
```

第三行：

```cpp
矩阵的第三行：
c[3][1] = a[3][1] × a[1][1] + a[3][2] × a[2][1] + a[3][3] × a[3][1];
c[3][2] = a[3][1] × a[1][2] + a[3][2] × a[2][2] + a[3][3] × a[3][2];
c[3][3] = a[3][1] × a[1][3] + a[3][2] × a[2][3] + a[3][3] × a[3][3];
sum2 = c[3][1] + c[3][2] + c[3][3]
    = a[3][1] × (a[1][1] + a[1][2] + a[1][3]) + a[3][2] × (a[2][1] + a[2][2] + a[2][3]) + a[3][3] × (a[3][1] + a[3][2] + a[3][3]);
```

根据上述三行可知：

```cpp
矩阵的元素总和为：
 Sum = sum1 +sum2 + sum3 
     = (a[1][1] + a[1][2] + a[1][3]) × (a[1][1] + a[2][1] + a[3][1]) + (a[2][1] + a[2][2] + a[2][3]) × (a[1][2] + a[2][2] + a[3][2]) + (a[3][1] + a[3][2] + a[3][3]) × (a[1][3] + a[2][3] + a[3][3])。
```

从这个式子我们可以看出一个结论：

> 一个矩阵自乘后矩阵元素的总和，就是他的第 $n$ 行乘第 $n$ 列的和。

我们再根据之前得出的结论：

> 这个矩阵中 $a$ 序列和 $b$ 序列中的每个点都会对原矩阵做出 $n$ 次贡献。

如果我们要算出矩阵 $A$ 后在求，算矩阵 $A$ 的复杂度为 $\mathcal{O}(n^2)$，因为对于每个 $a$ 序列里的数都要扫一遍 $b$ 序列，所以这题我们要直接考虑 $a$ 序列和 $b$ 序列对于矩阵的贡献。

根据这两个结论推得：

$$ans = \sum{a_{i}} \times \sum b_i \times (\sum a_i \times b_i)^{k-
1}$$

## AC code:

```cpp
/*
work by: TLE_Automation
Time: O(轻轻松松过)
knowledge: 垃圾算法
*/
#include<bits/stdc++.h>
#define int long long
#define orz cout << "szt lps fjh AK IOI";
using namespace std;

const int INF = 1e9 + 7;
const int mod = 998244353;
const int maxn = 2e5 + 10;
const int MAXN = 3e3 + 10;

inline int read() {
   int s = 0, w = 1;
   char ch = getchar();
   while (!isdigit(ch)) {if(ch == '-') {w = -1;}ch = getchar();}
   while (isdigit(ch)) {s = (s << 1) + (s << 3) + (ch ^ 48);ch = getchar();}
   return s * w;
}

inline void print(int x) {
   if (x < 0 ) putchar('-'), x = -x;
   if (x > 9 ) print(x / 10);
   putchar(x % 10 + '0');
}

int n, k, a[maxn], b[maxn];
 
int ksm(int a, int b) {
	int res = 1, base = a;
	while(b) {
		if(b & 1) res = (res * base) % mod;
		base = (base * base) % mod, b >>= 1;
	}return res;
}

int ans = 1;
int sum = 0;
int ans1 = 0, ans2 = 0;
signed main() {
	n = read(), k = read();
	if(k == 0) return print(n), 0;
	for(int i = 1; i <= n; i++) a[i] = read(), ans1 = (ans1 + a[i]) % mod;
	for(int i = 1; i <= n; i++) b[i] = read(), ans2 = (ans2 + b[i]) % mod;	
	for(int i = 1; i <= n; i++) {
		sum = (sum + a[i] * b[i]) % mod;
	}
	ans1 %= mod, ans2 %= mod;
	ans = (((ans1 % mod * ans2 % mod) % mod) * ksm(sum, k - 1) % mod + mod) %mod; 
	print(ans % mod);
}
```

---

## 作者：2huk (赞：2)

upd 2023/08/22：修改了一处笔误。

## Description

给定 $n, k$ 和两个长度为 $n$ 的序列 $a, b$。设矩阵 $A$ 满足 $A_{i, j} = a_i \times b_j$，求 $\sum A^k_{i, j} \bmod 998244353$ 的值。

## Solution

首先把 $a$ 看作是一个 $n \times 1$ 的矩阵，$b$ 看作是 $1 \times n$ 的矩阵，那么显然 $A = a \times b$（矩阵乘法）。

考虑将 $A^k$ 拆开：

$$
\begin{aligned}

A^k &= (a \times b)^k \\ 
&= (a \times b) \times (a \times b) \times \cdots \times (a \times b) \\
&= a \times (b \times a) \times  (b \times a) \times \cdots \times   (b \times a) \times b \\
&= a \times (b \times a)^{k - 1} \times b

\end{aligned}
$$
*以上转化运用了**矩阵乘法的结合律**。

最后我们将式子转化成了 $3$ 个矩阵相乘的形式，不难发现 $b \times a$ 的结果是一个 $1 \times 1$ 的矩阵，也就是一个值，即 $\sum_{i = 1}^n (a_i \times b_i)$。计算它的 $k$ 次方用快速幂即可。

假设令这个值为 $x$，那么现在问题来到了如何计算 $a \times x \times b$ 的矩阵中的所有元素之和。

首先可以将 $x$ 交换到外面（因为它是值，不受「矩阵乘法不满足交换律」的影响），然后计算 $a \times b$ 的矩阵的元素和，再整体乘 $x$ 即可。

注意到 $a \times b$ 的结果为一个 $n \times n$ 的矩阵，若令它为 $c$，则 $c = \begin{bmatrix}
a_1b_1  & a_1b_2 & \dots & a_1b_n\\
a_2b_1  & a_2b_2 & \dots & a_2b_n\\
 \vdots & \vdots & \ddots  & \vdots\\
a_nb_1  & a_nb_2 & \dots & a_nb_n
\end{bmatrix}$，其所有元素之和为 $a_1b_1 + a_1b_2 + \dots + a_nb_n$，也就是 $a, b$ 中的元素两两相乘的总和，其答案为 $(\sum_{i = 1}^n a_i) \times (\sum_{i = 1}^n b_i)$，然后将这个值乘上 $x$ 即可。

## Code

记 $res1 = \sum a_i$，$res2 = \sum b_i$，$res3 = (\sum(a_i \times b_i))^{k - 1}$，则最终答案为 $res1 \times res2 \times res3$。

一些细节：

- 注意特判 $k = 0$，即单位矩阵的情况，一个 $n \times n$ 的单位矩阵在对角线上有 $n$ 个 $1$，因此答案为 $n$。

- 注意 $a_i, b_i$ 可能为负数，因此取模时可以这样写 $(x \bmod P + P) \bmod P$。

```cpp
const int N = 1e5 + 10, P = 998244353;

int n, k, res1, res2, res3;

int mod(int a) { return (a % P + P) % P; }

int fpm(int a, int b)		// 快速幂
{
	int res = 1;
	
	while (b)
	{
		if (b & 1) res = mod(res * a);
		b >>= 1, a = mod(a * a);
	}
	
	return res;
}

main()
{
	n = read(), k = read();
	
	if (!k)
	{
		wel(n);		// 由于 n < 998244353，所以不必取模
		return 0;
	}
	
	fup (i, 1, n)
		a[i] = mod(read()),
		res1 = mod(res1 + a[i]);
	
	fup (i, 1, n)
		b[i] = mod(read()),
		res2 = mod(res2 + b[i]),
		res3 = mod(res3 + mod(a[i] * b[i]));
	
	res3 = fpm(res3, k - 1);
	
	wel(mod(mod(res1 * res2) * res3));
	
	return 0;
}
```

---

## 作者：Ginger_he (赞：2)

本文同步更新于[博客园](https://www.cnblogs.com/Gingerhe/p/15864536.html)
# 题目描述
给定两个长度为 $n$ 的序列 $\{a_n\},\{b_n\}$ 与一个整数 $k$。  
设矩阵 $A$ 满足 $A_{ij}=a_i\times b_j$，求 $A^k$ 的所有元素的和在模 $998244353$ 意义下的结果。
# 题解
（$k=0$ 的时直接输出 $n$，下面只讨论 $k>0$ 的情况）  
比赛的时候打了个暴力把 $A^2$ 和 $A^3$ 都求出来了，观察发现答案为 $\sum a_i\times\sum b_i\times(\sum a_ib_i)^{k-1}$，现在用**数学归纳法**来证明一下。  
设 $A^{k-1}$ 为矩阵 $B$，$A^k$ 为矩阵 $C$。  
当 $m=1$ 时，由矩阵乘法的定义可算出矩阵 $A$，不难发现和为 $\sum a_i\times\sum b_i$。  
不妨假设 $m=k-1$ 时，$\sum\sum B_{ij}=\sum a_i\times\sum b_i\times(\sum a_ib_i)^{k-2}$，  
则 $m=k$ 时，如下图可得 $C_{ij}=\sum\sum B_{ij}a_ib_j$，则 $\sum\sum C_{ij}=\sum\sum B_{ij}\times\sum a_ib_i=\sum a_i\times\sum b_i\times(\sum a_ib_i)^{k-1}$，证毕。  

$\begin{bmatrix}
  a_1b_1&a_1b_2&...&a_1b_n \\
  a_2b_1&a_2b_2&...&a_2b_n \\
  ...&...&...&... \\
  a_nb_1&a_nb_2&...&a_nb_n
\end{bmatrix}
\begin{bmatrix}
  B_{11}&B_{12}&...&B_{1n}\\
  B_{21}&B_{22}&...&B_{2n}\\
  ...&...&...&...\\
  B_{n1}&B_{n2}&...&B_{nn}
\end{bmatrix}$  

最后用**快速幂**求解即可。
## 注意
$\{a_n\}$ 和 $\{b_n\}$ 中可能会有负数，注意取模。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll p=998244353;
const int maxn=1e5+5;
int n;
ll k,a[maxn],b[maxn],x,y,s;
ll quickpow(ll a,ll b)
{
    ll res=1;
    while(b)
    {
		if(b&1)
		    res=res*a%p;
		b>>=1;
		a=a*a%p;
    }
    return res;
}
int main()
{
    scanf("%d%lld",&n,&k);
    if(!k)
    {
		printf("%d\n",n);
		return 0;
    }
    for(int i=1;i<=n;i++)
    {
		scanf("%lld",&a[i]);
		x=(x+a[i])%p;
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&b[i]);
		y=(y+b[i])%p;
    }
    for(int i=1;i<=n;i++)
		s=(s+a[i]*b[i]%p)%p;
    printf("%lld\n",(x*y%p*quickpow(s,k-1)%p+p)%p);
    return 0;
}
```

---

## 作者：sgl654321 (赞：1)

感觉这题最多黄，没有绿。
### 题目大意
给定两个长度为 $n$ 的数列 $\{a_n\}$ 和 $\{b_n\}$。定义一个 $n\times n$ 的矩阵 $A$，其中 $A_{i,j}=a_i\times b_j$。询问 $A^k$ 的所有元素之和对 $998244353$ 取模之后的值。
### 解题思路
直接考虑矩阵叉乘的定义。
设 $A\times A=B$，那么对于 $\forall i\in[1,n],j\in[1,n]$，都有：

$$B_{i,j}=\sum_{k=1}^{n}(A_{i,k}\times A_{k,j})$$

代入 $A_{i,j}=a_i\times b_j$，有

$$B_{i,j}=\sum_{k=1}^{n}(a_i\times b_k\times a_k\times b_j)$$

整理，得：
$$\begin{aligned}
B_{i,j} & =a_i\times b_j\sum_{k=1}^{n}(a_k\times b_k)\\
& =A_{i,j}\sum_{k=1}^{n}(a_k\times b_k)
\end{aligned}$$

设 $\sum_{k=1}^{n}(a_k\times b_k)=t$。显然 $t$ 可以在 $O(n)$ 的复杂度内求得。

则有 $B_{i,j}=t\cdot A_{i,j}$，$B=t\cdot A$。

下面我将用数学归纳法证明：对于 $k\ge 1$，有 $A^k=t^{k-1}\cdot A$。

首先，在 $k=1$ 时，显然成立。

其次，如果命题在 $k=p$ 时成立，那么有 $A^p=t^{p-1}\cdot A$。则 
$$\begin{aligned}
A^{p+1}&=A^p\times A\\
&= t^{p-1}\cdot A\times A\\
&= t^{p-1}\cdot t\cdot A\\
&=t^p\cdot A
\end{aligned}$$

命题在 $k=p+1$ 时仍然成立。

综上，原命题成立。


因此我们得出结论：当 $k\ge 1$ 时，有 $A^k=t^{k-1}\cdot A$。其中 $t=\sum_{k=1}^{n}a_k\times \sum_{k=1}^{n}b_k$。 对于 $t^{k-1}$，直接用普通的快速幂就可以了。这里不加赘述。

那么要求矩阵中元素之和呢？我们只要把矩阵 $A$ 中的元素之和求出来，乘以 $t^{k-1}$ 就行了。

$$\begin{aligned}
\sum_{i=1}^{n} \sum_{j=1}^{n}A_{i,j}
&= \sum_{i=1}^{n} \sum_{j=1}^{n}(a_i\times b_j)\\
&= \sum_{i=1}^{n}a_i\times \sum_{j=1}^{n}b_j\\
\end{aligned}$$

我们就可以在 $O(n)$ 复杂度内求出 $A$ 中的元素之和了。

特别地，在 $k=0$ 时，答案为 $n$。显然为[单位矩阵](https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5/8540268?fr=aladdin)。

在 $O(n+\log k)$ 时间复杂度内可以完成此题。

### 参考代码
注意，由于数列 $\{a_n\}$ 和 $\{b_n\}$ 中可能含有负数，所以我们需要在取模时多加注意。在 C++ 中可以写成如下形式：

```(a%mod+mod)%mod```

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define maxn 100010
using namespace std;
long long n,k,a[maxn],b[maxn],s1,s2,s,t;
long long ksm(long long x,long long y){
	long long ret=1;
	while(y>0){
		if(y%2==1)ret=ret*x%mod;
		x=x*x%mod;
		y/=2;
	}
	return ret%mod;
}
int main(){
	cin>>n>>k;
	if(k==0){
		cout<<n<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s1=((s1+a[i])%mod+mod)%mod;
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		s2=((s2+b[i])%mod+mod)%mod;
	}
	for(int i=1;i<=n;i++)
		t=((t+a[i]*b[i]%mod)%mod+mod)%mod;
	s=s1*s2%mod;
	cout<<ksm(t,k-1)*s%mod<<endl;
	return 0;
}
```


---

## 作者：caohan (赞：1)

# AD

[博客](https://www.luogu.com.cn/blog/713916/)

[主页](https://www.luogu.com.cn/user/713916)

# 题意

自己看。

# 分析

声明：$A$ 是那个矩阵，$a$ 是题目中的第一个数组，$b$ 是题目中的第二个数组。对于这两个数组，我们分别将其视作一个 $1 \times n$ 和 $n \times 1$ 的矩阵。

~~矩阵乘法？请百度。~~

观察题中 $A(i,j)=a(i) \times b(j)$ 可得知，$A$ 矩阵就是 $a \times b$(矩阵乘法)的结果。

所以就有了以下式子：
$A^k=(a \times b)^k=a \times (b \times a)^{k-1} \times b$。

这个式子中，$b \times a$ 是个数字，其值为：$\sum_{1}^{n}a(i) \times b(i) $。这个值能用快速幂解决。

而 $a \times b$ 回到了之前对 $A$ 的定义。它的和我们总结一下会发现是：$\sum_{1}^{n}a(i) \times \sum_{1}^{n} b(i)$。

这三个值都有线性求解的方法，至于快速幂 $\log{n}$，小于线性，不计。时杂为 $O(n)$。

# 代码

```cpp
#include<bits/stdc++.h>
#include<iostream>
using namespace std;
#define mod 998244353
long long a[100005]; 
long long b[100005]; 
long long n,k;
long long ksm(long long a,long long t)
{
	long long ans=1;
	while(t)
	{
		if(t&1)
		{
			ans*=a;
			ans%=mod;
		}
		a=a*a%mod;
		a%=mod;
		t>>=1;
	}
	return ans;
}
	long long sum3=0;
	long long sum1=0;
	long long sum2=0;
int main()
{
	cin>>n>>k;
	if(k==0)
	{
		cout<<n<<"\n";
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]=(a[i]+mod)%mod;
		sum1+=a[i];
		sum1%=mod;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
		b[i]=(b[i]+mod)%mod;
		sum2+=b[i];
		sum2%=mod;
		sum3+=a[i]*b[i]%mod;
		sum3%=mod;
	}
	sum3=ksm(sum3,k-1);
	cout<<(((sum1%mod)*(sum2%mod)%mod)*(sum3%mod)+mod)%mod;
	return 0;
}
```

---

## 作者：Transfixion_ (赞：1)

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P8110)

## $\textbf{Solution}$
注意到 $1\leq n\leq 10^5$，时空都要爆，所以我们应当推式子。

结论题先猜结论，先看一下 $k=2$ 的时候：

$$\begin{aligned}A_{i,j}^2&=\sum\limits_{l=1}^nA_{i,l}A_{l,j}\\&=\sum\limits_{l=1}^na_ib_la_lb_j\\&=a_ib_j\sum\limits_{l=1}^na_lb_l.\end{aligned}$$

对比一下 $A_{i,j}^1=A_{i,j}=a_ib_j$，手模一下可以猜出结论。

$$\textbf{Key Conclusion : }A_{i,j}^k=a_ib_j\left(\sum\limits_{l=1}^na_lb_l\right)^{k-1}$$

归纳证明即可。以下为证明过程。

$\textbf{Proof : }$

归纳假设：$A_{i,j}^k=a_ib_j\left(\sum\limits_{l=1}^na_lb_l\right)^{k-1}$。

对 $k$ 进行归纳。

当 $k=1$ 时，结论显然成立。

设当 $k=t$ 时结论成立。考虑 $k=t+1$ 时。

$$\begin{aligned}A_{i,j}^{t+1}&=\sum\limits_{l=1}^nA_{i,l}^tA_{l,j}\\&=\sum\limits_{l=1}^n\left[a_ib_l\left(\sum\limits_{l=1}^na_lb_l\right)^t\right]a_lb_j\\&=a_ib_j\left(\sum\limits_{l=1}^na_lb_l\right)^t\sum\limits_{l=1}^na_lb_l\\&=a_ib_j\left(\sum\limits_{l=1}^na_lb_l\right)^{t+1}.\end{aligned}$$

证毕。

于是矩阵 $A$ 的所有元素和为
$$\begin{aligned}\sum\limits_{i=1}^n\sum\limits_{j=1}^nA_{i,j}&=\sum\limits_{i=1}^n\sum\limits_{j=1}^n\left[a_ib_j\times\left(\sum\limits_{l=1}^na_lb_l\right)^{k-1}\right]\\&=\sum\limits_{i=1}^na_i\sum\limits_{i=1}^nb_i\left(\sum\limits_{i=1}^na_ib_i\right)^{k-1}\end{aligned}$$

线性处理一下三个 $\sum$ 然后快速幂即可。时间复杂度 $O(n+\log k)$。

## AC Code
```cpp
#include <bits/stdc++.h>
const int N = 1e5 + 5;
const int p = 998244353;

inline int qpow(int a, int b) {
	int res = 1;
	for(; b; b >>= 1) {
		if(b & 1) res = 1ll * res * a % p;
		a = 1ll * a * a % p;
	}
	return res; 
}

int n, k;
int s1, s2, base, ans;
int a[N], b[N];

signed main() {
	std::cin >> n >> k;
	if(!k) return std::cout << n, 0;
	for(int i = 1; i <= n; i++) std::cin >> a[i];
	for(int i = 1; i <= n; i++) std::cin >> b[i];
	for(int i = 1; i <= n; i++) {
		a[i] = (a[i] + p) % p;
		b[i] = (b[i] + p) % p;
		s1 = (s1 + a[i]) % p;
		s2 = (s2 + b[i]) % p;
		base = (base + 1ll * a[i] * b[i] % p) % p;
	}
	ans = 1ll * s1 * s2 % p * qpow(base, k - 1) % p;
	std::cout << ans << '\n';
	return 0;
}
```

---

## 作者：feicheng (赞：1)

## Description

[Link](https://www.luogu.com.cn/problem/P8110)。

给定长度为 $n$ 的序列 $a,b$，令 $n\times n$ 矩阵 $A$ 的第 $i$ 行第 $j$ 列的元素为 $a_i\times b_j$，给定 $k$，求 $A^k$ 的所有元素之和，答案对 $998244353$ 取模。

**限制**：$1\leq n\leq 10^5$，$0\le k\lt 998244353$，$|a_i|,|b_i|\le 10^9$。

## Solution

官方题解貌似用了某些线性袋鼠的知识，但是我不太会这个，所以用了一个找规律的做法。

先尝试计算 $B=A^2$，有

$$
\begin{aligned}
B_{ij}&=\sum_{k=1}^nA_{ik}A_{kj}\\
      &=\sum_{k=1}^na_ib_k\cdot a_kb_j\\
      &=a_i b_j\sum_{k=1}^n a_kb_k
\end{aligned}
$$

记 $M = \displaystyle\sum_{k=1}^na_k\times b_k$，则有 $B_{ij}=A_{ij}\cdot M$，所以我们作出假设：$A^m_{ij}=A_{ij}\cdot M^{m-1}(m\ge 1)$，接下来使用归纳法证明这个结论：

当 $m=1$ 时显然成立，假设当 $m=z$ 时成立，当 $m=z+1$ 时，有

$$
\begin{aligned}
A_{ij}^m&=\sum_{k=1}^nA_{ik}^zA_{kj}\\
&=\sum_{k=1}^na_ib_k\cdot M^z\cdot a_k b_j\\
&=M^z\cdot a_ib_j\sum_{k=1}^na_kb_k\\
&=M^{z+1}\cdot a_ib_j
\end{aligned}
$$

于是 $A^k$ 的所有元素和为

$$
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^n A_{ij}&=M^{k-1}\sum_{i=1}^n\sum_{j=1}^n a_i\cdot b_j\\
&=M^{k-1}\sum_{i=1}^na_i\sum_{i=1}^nb_i
\end{aligned}
$$

于是预处理 $a,b$ 序列的和以及 $M$ 的值，就可以在 $\mathcal O(\log k)$ 的时间内回答询问了。

总时间复杂度：$\mathcal O(n+\log k)$

## Code

由于代码使用了 hly 哥哥写的自动取模类，较长，此处只粘贴核心代码。

```cpp

constexpr int mod = 998'244'353;
constexpr int N = 1e5 + 5;

using mint = lib::LazyMontgomeryModInt<mod>;// 自动取模类

int n, k;
mint a[N], b[N];

inline void solve() {
  in >> n >> k;// 快读
  if (k == 0) {
    out << n << '\n';
    return;
  }
  mint A(0), B(0);
  for (int i = 1; i <= n; ++i) {
    int v;
    in >> v;
    a[i] = mint(v);
    A += a[i];
  }
  for (int i = 1; i <= n; ++i) {
    int v;
    in >> v;
    b[i] = mint(v);
    B += b[i];
  }
  mint w(0);
  for (int i = 1; i <= n; ++i) {
    w += a[i] * b[i];
  } 
  out << static_cast<int>(A * B * w.pow(k - 1)) << '\n';
}
```

---

## 作者：Mars_Dingdang (赞：1)

一道推式子的好题。

## 题目大意
给定两个长度为 $n$ 的序列 $\{a_n\}$，$\{b_n\}$ 与一个整数 $k$。

设矩阵 $A$ 满足 $A_{ij}=a_i\times b_j$，求 $A^k$ 的所有元素的和在模 $998244353$ 意义下的结果。

## 大体思路
由于本题的数据范围 $n\le 10^5$，显然不可能直接将矩阵 $A$ 中的每一个元素记录下来。因此，我们考虑简单的推式子。取 $n=3$ 计算可得，

![](https://cdn.luogu.com.cn/upload/image_hosting/o3151epr.png)

由此推广到一般的 $n, k$，记 $\Sigma=\sum_{i=1}^n a_ib_i$，有：
$$k=0, \sum A_{i, j}=n$$
$$k>0, A_{i, j}=a_ib_j\times \left(\sum_{i=1}^na_ib_i\right)^{k-1}, \sum A_{i, j}=\left(\sum_{i=1}^n \sum_{j=1}^n a_ib_j\right)\left(\sum_{i=1}^na_ib_i\right)^{k-1}$$

运用恒等式变换，

$$\sum_{i=1}^n \sum_{j=1}^n a_ib_j=\left(\sum_{i=1}^na_i\right)\left(\sum_{j=1}^nb_i\right), \sum A_{i, j}=\left(\sum_{i=1}^na_i\right)\left(\sum_{j=1}^nb_i\right)\left(\sum_{i=1}^na_ib_i\right)^{k-1}$$

其中，括号内的三个 $\Sigma$ 的值均可以在 $O(n)$ 内预计算，而 $k-1$ 次方可以利用快速幂在 $O(\log k)$ 复杂度内计算，总体复杂度 $O(n+\log k)$。注意及时取模和对于 $k=0$ 的特判。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5;
const ll mod = 998244353;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, k, a[maxn], b[maxn], sA, sB, s;
inline ll Pow(ll a, ll b) {
	ll res = 1ll;
	while(b) {
		if(b & 1) res = (res * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return res % mod;
}
int main() {
	read(n); read(k);
	rep(i, 1, n) {
		read(a[i]);
		sA = (sA + a[i] + mod) % mod;
	}
	rep(i, 1, n) {
		read(b[i]);
		sB = (sB + b[i] + mod) % mod;
		s = (s + (a[i] * b[i] % mod) + mod) % mod;
	}
	if(k == 0) return writeln(n), 0;
	else if(k == 1) return writeln(((sA * sB)% mod + mod) % mod), 0;
	else {
		ll p = k - 1;
		writeln(((Pow(s, p) * sA % mod) * sB + mod) % mod);
	}
	return 0;
}
```

---

## 作者：Nephren_Sakura (赞：0)

题目传送门：[link](https://www.luogu.com.cn/problem/P8110)。

首先，由 $A$ 的定义式可以看出来，$A=a \times b$。

看到这个 $10^5$ 的数据范围，直接把矩阵拿出来在矩阵快速幂时空双炸。

考虑如何迅速算出 $A^k$ 里元素的和。

我们知道，矩阵乘法满足结合律和分配律（但不满足交换律）。

所以可以把 $A^k$ 拆成 $a \times b \times a \times b \times \dots \times a \times b$，然后再用结合律，变成 $a \times (b \times a)^{k-1} \times b$。

会发现 $b \times a$ 是一个数字，所以可以用交换律，原式变为 $a \times b \times (b \times a)^{k-1}$。

然后来思考这东西怎么求。

首先 $b \times a$ 根据定义就是 $\sum\limits_{i=1}^{n}a_i \times b_i$，求这个的 $k-1$ 次方可以直接快速幂。

然后考虑求 $a \times b$ 中所有元素的和。

然后根据定义，$a \times b$ 中所有元素的和

$=\sum\limits_{i=1}^n \sum\limits_{j=1}^{n}a_i \times b_j$

$=\sum\limits_{i=1}^n a_i \times \sum\limits_{j=1}^{n} b_j$

然后这两部分可以分别计算。

最后得到答案乘上刚刚求出的 $(b \times a)^k-1$ 即可。

这道题有负数，注意取模问题。

下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int s1=0,s2=0,s3=0,n,k,a[1000005],b[1000005];
int quick_pow(int a,int b){
	if(b==0)
		return 1;
	if(b==1)
		return a;
	int sum=quick_pow(a,b/2);
	sum*=sum;
	sum%=mod;
	if(b%2)
		sum*=a,sum%=mod;
	return sum;
}//快速幂
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1; i<=n; i++)
		cin>>a[i],s1+=a[i],s1%=mod;
	for(int i=1; i<=n; i++)
		cin>>b[i],s2+=b[i],s3+=a[i]*b[i]%mod,s2%=mod,s3%=mod;
	if(k==0){
		cout<<n;
		return 0;
	}
	s3=quick_pow(s3,k-1);
	cout<<(s1*s2%mod*s3%mod+mod)%mod;
	return 0;
}

```

---

## 作者：Coros_Trusds (赞：0)

# 题目大意

给定两个长度为 $n$ 的序列 $\{a_n\}$，$\{b_n\}$ 与一个整数 $m$。

设矩阵 $A$ 满足 $A_{ij}=a_i\times b_j$，求 $A^m$ 的所有元素的和在模 $998244353$ 意义下的结果。

# 题目分析

$A^2=A\times A$，记 $B=A^2$，其中：

$B_{i,j}=\sum\limits_{k=1}^nA_{i,k}\times A_{k,j}=\sum\limits_{k=1}^na_i b_k a_k b_j=a_i\times b_j\times \sum\limits_{k=1}^na_k b_k=A_{i,j}\times\sum\limits_{k=1}^na_k b_k$。

而原矩阵的矩阵之和为 $\sum\limits_{i=1}^n\sum\limits_{j=1}^nA_{i,j}=\sum\limits_{i=1}^n\sum\limits_{i=1}^na_i b_j=\sum\limits_{i=1}^na_i\cdot\sum\limits_{j=1}^nb_j$。

故变换后的矩阵之和为 $\sum\limits_{i=1}^na_i\cdot\sum\limits_{j=1}^nb_i\cdot(\sum\limits_{k=1}^na_k b_k)^{m-1}$。

后面一坨用快速幂 $\mathcal{O(\log n)}$ 求解。

----
注意特判 $m=1$ 的点，答案为 $n$。

# 代码

```cpp
//2022/3/1
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define int long long
#define enter() putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : (-x))
const int mod = 998244353;
inline int MOD(int x) {
	return (x + mod) % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int ma = 1e5 + 5;
int a[ma],b[ma];
int n,m,suma,sumb,summul;
inline int ksm(int x,int y) {
	int res = 1;
	for (;y;y >>= 1ll) {
		if (y & 1ll) {
			res = res * x % mod;
		}
		x = x * x % mod;
	}
	return res;
}
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	n = read(),m = read();
	if (!m) return printf("%lld\n",n),0;
	for (register int i = 1;i <= n; ++ i) a[i] = MOD(read()),suma = MOD(suma + a[i]);
	for (register int i = 1;i <= n; ++ i) b[i] = MOD(read()),sumb = MOD(sumb + b[i]);
	for (register int i = 1;i <= n; ++ i) summul = (summul + a[i] * b[i]) % mod;
	printf("%lld\n",((suma * sumb) % mod * ksm(summul,m - 1)) % mod);

	return 0;
}
```

---

## 作者：CReatiQ (赞：0)

### 题意概述

题意十分简洁。

给定两个长度为 $n$ 的序列 $\{a_n\},\{b_n\}$ ，一个整数 $k$ 。

有矩阵 $A$ 满足 $A_{i,j}=a_i \cdot b_j$ ，求 $\sum_{i=1}^n\sum_{j=1}^nA^k_{i,j}$ 对 $998244353$ 取模的结果。

$1 \leq n \leq 10^5 , 0 \leq k <998244353 , |a_i|,|b_i| \leq 10^9$ 。

### 思路

观察到巨大的 $k$ 与 $A^k$ ，很快可以联想到快速幂。

但因为 $n$ 同样很大，直接跑矩阵快速幂的时空复杂度都是不能接受的，所以考虑单次矩乘为式子带来了什么影响。

$A^2_{i,j}=\sum_{k=1}^n A_{i,k} \cdot A_{k,j}=\sum_{k=1}^n a_i \cdot b_k \cdot a_k \cdot b_j=a_i \cdot b_j \cdot \sum_{k=1}^n a_k \cdot b_k$

所以每次矩乘为矩阵的每一个位置乘上了 $\sum_{k=1}^n a_k \cdot b_k$ ，这个值我们可以直接 $\mathcal{O}(n)$ 求和，然后 $\mathcal{O}(\log k)$ 快速幂出来。

所以 $A^k_{i,j}=a_i \cdot b_j \cdot (\sum_{k=1}^n a_k \cdot b_k)^{k-1}$ 。

现在的任务就是来解决外面的两层求和了：

$$ans=\sum_{i=1}^n \sum_{j=1}^n A^k_{i,j}=\sum_{i=1}^n \sum_{j=1}^n a_i \cdot b_j \cdot (\sum_{k=1}^n a_k \cdot b_k)^{k-1}$$

$$=(\sum_{i=1}^n a_i) \cdot (\sum_{i=1}^n b_i) \cdot (\sum_{i=1}^n a_i \cdot b_i)^{i-1}$$

这样我们就可以以 $\mathcal{O}(n+\log k)$ 的复杂度求出式子的值了。

需要留意的是数据中的 $a_i,b_i$ 存在负数，写快读的话要记得判负号，取模时要记得先加上模数。

### Code

```cpp
#include <cstdio>
#define int long long

const int MAXN=1e5+10,mod=998244353;
int n,k,a[MAXN],b[MAXN],ansa,ansb,ansk;

int ksm(int a,int b)
{
	int ret=1;
	for (;b;b>>=1,a=a*a%mod)
		if (b&1) ret=ret*a%mod;
	return ret; 
}

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return f*x;
}

signed main()
{
	n=read(),k=read();
	if (!k)
	{
		printf("%lld",n);
		return 0;
	}
	for (int i=1;i<=n;i++) a[i]=read(),a[i]=(a[i]+(mod<<1))%mod,ansa=(ansa+a[i])%mod;
	for (int i=1;i<=n;i++) b[i]=read(),b[i]=(b[i]+(mod<<1))%mod,ansb=(ansb+b[i])%mod;
	//加两倍模数是因为998244353略小于1e9，怕极限数据暴毙。
	for (int i=1;i<=n;i++) ansk=(ansk+a[i]*b[i]%mod)%mod;
	ansk=ksm(ansk,k-1);
	printf("%lld",ansa*ansb%mod*ansk%mod);
	return 0;
}
```


---


# 正误问题

## 题目描述

小 bobo 迷上了逻辑值运算。但小 bobo 算的头都晕了，也没算出个所以然。他只好找到你，让你帮他解决这个问题。


## 说明/提示

对于全部数据，保证输入数据串长小于 $255$。

本题结果为 `true`，`false`，`error` 各占 $\dfrac{1}{3}$，允许“骗分”，但不值得，因为是“水题”。

---

- $\text{upd 2022.7.21}$：新增加 $5$ 组 [Hack 数据](https://www.luogu.com.cn/discuss/459823)。

## 样例 #1

### 输入

```
true or false and false```

### 输出

```
true```

# 题解

## 作者：wzmzmhk (赞：29)

### [题目传送门](https://www.luogu.com.cn/problem/P1575)

### [博客食用更佳](https://www.luogu.com.cn/blog/wzmzmhk/solution-p1575#)
------------

此题C党的题解大部分都是用栈来完成的，那么本蒟蒻就来写一个与所有题解都不同的方法。

## 大致思路：
1. 首先读入一整行字符串。
1. 进行特判，如果开头或末尾即为```and```或```or```，或末尾为```not```，则直接输出```error```。
1. 找出所有的```not```，如果```not```后有```or```或```and```，直接输出```error```；如果存在多个```not```的情况，则把每两个```not```删除。最后只剩一个或零个```not```，若剩一个```not```，则把后边的**一个**单词反转（即```true```与```false```互换），并把```not```改为"&nbsp;&nbsp;&nbsp;"（三个空格）。
1. 找出所有的 ```and```，如果```and```前面的第一个单词与后面的第一个单词都是```true```，那么把```and```以及任意一个```true```全部赋值为空格，例如，```true and true```变为```true```&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（9个空格）。
1. 找出所有的```or```，方法与```and```基本一致。
1. 最后判断字母t与字母f的个数，如果二者都有或任意一者多余一个，则输出```error```，否则有1个t就输出```true```，有1个f就输出```false```。

注意：我们只需判断单词中的几个字母即可判断该单词为什么，因此不需要把整个单词分离判断。

#### 步骤1&&步骤2（输入并特判）：
```cpp
//input
    getline(cin, s);
    int len = s.size();
    if (s[0] == 'a' || s[0] == 'o' || s[len - 1] == 'd' || s[len - 1] == 'r' || s[len - 1] == 't') {
        cout << "error";
        return 0;
    }
```

#### 步骤3（处理```not```）：
```cpp
//not
    for (int i = 0; i < len; i++) {
        if (s[i] == 'n' && s[i + 1] == 'o') {
            int j = i + 4;
            while (s[j] == ' ') j++;
            if (s[j] == 't')
                s[j] = 'f', s[j + 1] = 'a', s[j + 2] = 's', s[j + 3] = 'e', s[i] = s[i + 1] = s[i + 2] = ' ';
                //因为"true"是4个字母，"false"是5个字母，而中间的"l"没有用，所以可以这样做
            else if (s[j] == 'f')
                s[j] = 't', s[j + 1] = 'r', s[j + 2] = 'r', s[j + 3] = 'u', s[j + 4] = 'e', s[i] = s[i + 1] = s[i + 2] = ' ';
                //道理同上
            else if (s[j] == 'n')
                s[i] = s[i + 1] = s[i + 2] = s[j] = s[j + 1] = s[j + 2] = ' ';
            else {
                cout << "error";
                return 0;
            }
        }
    }
```

#### 步骤4（处理```and```）：
```cpp
//and
    for (int i = 1; i < len; i++) {
        if (s[i] == 'a' && s[i + 1] == 'n') {
            int j = i - 2, k = i + 4;
            while (s[j] == ' ') j--;//此时j为and上一个字母的末尾下标
            while (s[k] == ' ') k++;//此时k为and后一个字母的首位下标
            if (s[k] == 'a' && s[k + 1] == 'n') {
                cout << "error";
                return 0;
            }//如果and后面还有and，就输出"error"
            while (s[j] != ' ' && j != 0) j--;//此时j为and上一个字母的首位下标
            while (s[k] != ' ' && k != len - 1) k++;//此时j为and上一个字母的末位下标
            if (j != 0)
                j++;
            if (k != len - 1)
                k--;
            bool flag1 = false, flag2 = false;
            if (s[j] == 't' && s[j + 1] == 'r')
                flag1 = true;
            if (s[k] == 'e' && s[k - 1] == 'u')
                flag2 = true;
            if (flag1 && flag2) {
                s[j] = 't', s[j + 1] = 'r', s[j + 2] = 'u', s[j + 3] = 'e';
                for (int l = j + 3 + 1; l <= k; l++)
                    s[l] = ' ';
            }
            else {
                s[j] = 'f', s[j + 1] = 'a', s[j + 2] = 'l', s[j + 3] = 's', s[j + 4] = 'e';
                for (int l = j + 4 + 1; l <= k; l++)
                    s[l] = ' ';
            }
        }
    }
```

#### 步骤5（处理```or```）：

此步骤与步骤4几乎一模一样，将步骤4稍微修改即可，这里留给读者自己思考。

#### 步骤6（输出）：
```cpp
//output
    int t[200] = { 0 };//这里用了一个桶来统计字母出现的数量，t[s]表示为字母s出现的次数
    for (int i = 0; i < len; i++) {
        if (s[i] != ' ')
            t[s[i]]++;
    }
    if (t['t'] > 1 || t['f'] > 1 || (t['t'] >= 1 && t['f'] >= 1)) {
        cout << "error";
        return 0;
    }
    else if (t['t'] == 1)
        cout << "true";
    else
        cout << "false";
```


---

## 作者：AveMarina (赞：20)

## 提供一份娱乐向代码~~也希望能丰富下题解区~~
**小知识**：python的eval函数可以直接将字符串当成代码片段执行
```python
# 将Python的数据类型转换为题目里的格式
true, false = True, False
# 因为题目说可能会有非法表达式，比如and and，所以直接用eval执行可能会
# 抛出一个异常
try:
  # 将输入的表达式返回的结果转换成字符串，再利用lower()方法格式化
  print(str(eval(input())).lower())
except SyntaxError:
  # 表达式非法就输入error
  print('error')
```


---

## 作者：BlackPanda (赞：19)

### 注意：这是一篇 C++ 题解。

**[题目传送门](https://www.luogu.com.cn/problem/P1575)**

------------
### 题意：
给定一个逻辑表达式，包含 $\verb!true!$、$\verb!false!$、$\verb!not!$、$\verb!and!$、$\verb!or!$ 和空格。

如果该表达式错误，输出 $\verb!error!$，否则输出结果（$\verb!true!$ 或 $\verb!false!$）。

------------
### 前文：
有难度的模拟题，~~卡了我两天~~。

逻辑表达式翻译：

- $\verb!not!$ 把后面的值取反。
- $\verb!and!$ 两者都为真返回真，否则返回假。
- $\verb!or!$ 其中一者或两者为真返回真，否则返回假。

第一眼看到题目，觉得可以直接用字符串模拟，于是就有了下面的提交记录：[交了几十次WA](https://www.luogu.com.cn/record/list?pid=P1575&user=486799&page=1&status=14)。

然后就是不断的 $\verb!Debug!$，在各位大佬的帮助下调了近两天才勉强通过，在调试过程中发现题解区缺少模拟做法的 $\verb!C++!$ 题解，故写篇题解以补全空缺。

------------
### 正文：

首先可以看到：

> 优先级从高到低依次为 $\verb!not!$，$\verb!and!$，$\verb!or!$。

所以我们可以先把所有的 $\verb!not!$ 处理掉，然后依次处理 $\verb!and!$ 和 $\verb!or!$。

- $\verb!not!$	

可以从头遍历字符串，找到**一段连续**的 $\verb!not!$，然后将 $\verb!not!$ 从字符串中删除。（可以把这段字符串赋值成空格，也可以使用 [$\operatorname{erase}$](https://www.cnblogs.com/loda333/p/5229980.html#:~:text=%20erase%28%29%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E7%94%A8%E6%9D%A5%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0,%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E9%87%8C%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9Ac.erase%28T%29%3B%20%E7%9C%8B%E4%BC%BC%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E4%BD%9C%EF%BC%8C%E7%84%B6%E8%80%8C%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%86%85%E9%83%A8%E5%8D%B4%E5%81%9A%E4%BA%86%E6%88%AA%E7%84%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%8C%E5%90%8E%E9%9D%A2%E4%BB%8B%E7%BB%8D%E3%80%82) 函数。）

最后判断 $\verb!not!$ 数量的奇偶性，如果为偶数，后面的值不变，否则就变成相反的值，然后继续寻找下一处 $\verb!not!$。

- $\verb!and!$

从头遍历字符串，找到 $\verb!and!$ 后判断前后是否合法，然后进行计算即可（前后为真返回真，否则返回假）。

- $\verb!or!$

和 $\verb!and!$ 的操作方法类似，具体实现细节见代码中。

- $\verb!error!$ 的判定

1. $\verb!not!$ 的后面出现 $\verb!and!$ 或者 $\verb!or!$，或者 $\verb!not!$ 出现在结尾。
2. $\verb!and!$ 或 $\verb!or!$ 出现在开头或者结尾。
3. $\verb!and!$、$\verb!or!$ 前面出现 $\verb!or!$、$\verb!and!$ 或 $\verb!not!$ 以及后面出现 $\verb!or!$ 或 $\verb!and!$。
4. 在计算过程中逻辑表达式中出现多个 $\verb!true!$ 或 $\verb!false!$ 且没有出现运算符（例如：$\verb!true false!$）。
5. 逻辑表达式中只有运算符（例如：$\verb!not not!$）。

- 其他

输入可能有多余空格，计算过程中也可能会产生多余空格，所以我们在一开始及每次运算结束时进行去除多余空格，细节见代码。

------------
### code：
超长代码预警！！！

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int l;
string trim(string& str){
    str.erase(0, str.find_first_not_of(" \t")); // 去掉头部空格
	str.erase(str.find_last_not_of(" \t") + 1); // 去掉尾部空格
    return str;
}
void kongge(){
	char st[305]="";
	s=trim(s);
	int len=s.length();
	bool fl=1;
	int cnt=0;
	for(int i=0;i<len;i++){
		if(s[i] == ' '){
			if(!fl){
				st[cnt++]=s[i];
				fl=1;
			}
		}
		else{
			fl=0;
			st[cnt++]=s[i];
		}
	}
	s=st;
	s+=" "; 	//不加的话再循环中会越界 
	return ;
}
bool check1(int i){		//判断 and 前后是否合法 
	int t=i;
	char c[305]="";
	int cnt=0;
	i-=2;
	while(s[i] != ' ' && i > 0){c[cnt++]=s[i]; i--;}
	string str=c;
	reverse(str.begin(),str.end());
	if(str == "not" || str == "and" || str == "or")	return 0;
	memset(c,'\0',sizeof(c));
	i=t;
	i+=4;
	cnt=0;
	int lene=s.length();
	while(s[i] != ' ' && i < lene){c[cnt++]=s[i], i++;}
	str=c;
	if(str == "and" || str == "or")	return 0;
	return 1;
}
bool check4(int i){		//判断 or 前后是否合法 
	int t=i;
	char c[305]="";
	int cnt=0;
	i-=2;
	while(s[i] != ' ' && i > 0){c[cnt++]=s[i]; i--;}
	string str=c;
	reverse(str.begin(),str.end());
	if(str == "not" || str == "and" || str == "or")	return 0;
	memset(c,'\0',sizeof(c));
	i=t;
	i+=3;
	cnt=0;
	int lene=s.length();
	while(s[i] != ' ' && i < lene){c[cnt++]=s[i], i++;}
	str=c;
	if(str == "and" || str == "or")	return 0;
	return 1;
}
bool check3(int i){	//判断not前后是否合法 
    kongge();
    int cnt=0;
    char c1[10]="";
    while(s[--i] == ' ');	//-
    int lene=s.length();
    while(s[++i] != ' ' && i < lene)c1[cnt++]=s[i];	// -
    string str=c1;
    if(str == "or" || str == "and")    return 0;
    return 1;
}
bool check(int i){
    kongge();
    if(s[i+4]=='f'&&s[i+5]=='a'&&s[i-5]=='t'&&s[i-4]=='r')  return 1;
    if(s[i+4]=='t'&&s[i+5]=='r'&&s[i-6]=='f'&&s[i-5]=='a')  return 1;
    return 0;
}
bool check2(int i){
    kongge();
    if(s[i+3]=='f'&&s[i+4]=='a'&&s[i-5]=='t'&&s[i-4]=='r')  return 1;
    if(s[i+3]=='t'&&s[i+4]=='r'&&s[i-6]=='f'&&s[i-5]=='a')  return 1;
    return 0;
}
void init(){
	bool fl=1;
	l=s.length();
	for(int i=0;i<l;i++){
		if(s[i]=='t'&&s[i+1]=='r'&&s[i+2]=='u'&&s[i+3]=='e'){
			fl=0;
			i+=3;
		}
		else if(s[i]=='f'&&s[i+1]=='a'&&s[i+2]=='l'&&s[i+3]=='s'&&s[i+4]=='e'){
			fl=0;
			i+=4;
		}
	}
	if(fl){
		cout << "error";
		exit(0); 
	}
}
void solve(){
    l=s.length();
    if(l == 0){
    	cout << "error";
		exit(0); 
	}
    kongge();
    if(s[0]=='a' || s[0]=='o' || s[l-1]=='d' || s[l-1]=='r' || s[l-1]=='t'){
        cout << "error";exit(0);
    }
    if(l <= 5){
        kongge();
        cout << s;
        exit(0);
    }
    for(int i=0;i<l;i++){
        if((s[i]=='a'&&s[i+1]=='n')||(s[i]=='o'&&s[i+1]=='r')){
            if(!check1(i)){
                cout << "error";
                exit(0); 
            }
        }
    }
	bool fl=0;
    for(int i=0;i<l;i++){
		if(s[i]=='n'&&s[i+1]=='o'&&s[i+2]=='t'){
			fl=1;
			i+=2;
		}
		else if(s[i]=='a'&&s[i+1]=='n'&&s[i+2]=='d'){
			fl=1;
			i+=2;
		}
		else if(s[i]=='o'&&s[i+1]=='r'){
			fl=1;
			i++;
		}
	}
	//cout << fl;
	kongge();
	l=s.length();
	if(!fl && l > 6){	//l>6原因：末尾可能会有一个多余空格 
		//cout << l << s;
		cout << "error";
		exit(0); 
	}
	init();
    return ;
}
int main(){
    getline(cin,s);
    init();
	solve();
	string stmp="not";
	while(s.find(stmp) != -1){
		kongge();
		l=s.length(); 
	    for(int i=0;i<l;i++){
	        if(s[i] == 'n' && s[i+1] == 'o'){
	            if(!check3(i)){
	                cout << "error";
	                return 0;
	            }
	            //cout << i << " ";
	            s[i]=s[i+1]=s[i+2]=' ';
				//cout << s << "@";
				i+=3;
	            int t=1;
	            while(s[i] == ' ')  i++;
	            while(s[i] == 'n' && s[i+1] == 'o'){
	                s[i]=s[i+1]=s[i+2]=' ';t++;i+=3;
	                while(s[i] == ' ')  i++;
	            }
	            //cout<<i<<t<<endl;
	            //i++;
	            if(t%2 != 0){
	            	//cout << s[i] << "#";
	                if(s[i] == 't' && s[i+1] == 'r'){
	                    s.erase(i,4);
	                    string tmp="false";
	                    s.insert(i,tmp);
	                    i++;
	                }   
	                else if(s[i] == 'f' && s[i+1] == 'a'){
	                    s.erase(i,5);
	                    string tmp="true";
	                    s.insert(i,tmp);
	                    i--;
	                }   
	            }
	           // cout << s << "@";
	            break;
	        }
	    }
	}
    solve();
    string ssss="and";
    while(s.find(ssss) != -1){
    	kongge();
		l=s.length(); 
	    for(int i=0;i<l;i++){
	        kongge();
	        if(s[i] == 'a' && s[i+1] == 'n'){
	            if(!check1(i)){ //and两边出现not或or 
	                cout << "error";
	                return 0; 
	            }
	            else if(s[i-4] == 'n' && s[i-3] == 'o'){
	            	cout << "error";
	            	return 0;
				}
	            if(s[i+4]=='f'&&s[i+5]=='a'&&s[i-6]=='f'&&s[i-5]=='a'){ //双false
	                s.erase(i,9);
	            }
	            else if(s[i+4]=='t'&&s[i+5]=='r'&&s[i-5]=='t'&&s[i-4]=='r'){    //双true 
	                s.erase(i,8);
	            }
	            else if(check(i)){  //一true一false 
	                if(s[i+4]=='f') s.erase(i-5,8);
	                else    s.erase(i,8);
	            } 
	            break;
	        }   
	    }  
	}
    solve();
    string sss="or";
    while(s.find(sss)!=-1){
    	kongge();
		l=s.length(); 
	    for(int i=0;i<l;i++){
	        kongge();
	        if(s[i] == 'o' && s[i+1] == 'r'){
	            if(!check4(i)){
	            	//cout << s;
	                cout << "error";
	                return 0;
	            }
	            else if(s[i-4] == 'n' && s[i-3] == 'o'){
	            	cout << "error";
	            	return 0;
				}
	            if(s[i+3]=='f'&&s[i+4]=='a'&&s[i-6]=='f'&&s[i-5]=='a'){ //双false
	                s.erase(i,8);
	            }
	            else if(s[i+3]=='t'&&s[i+4]=='r'&&s[i-5]=='t'&&s[i-4]=='r'){    //双true 
	                s.erase(i,7);
	            }
	            else if(check2(i)){ //一true一false 
	                if(s[i+3]=='f') s.erase(i,8);
	                else    s.erase(i-6,9);
	            } 
	            break;
	        }
	    }
	}
    solve();
	cout << s;
    return 0;
}

```

**文章、代码若有错误欢迎大佬指出。**

---

## 作者：ADay (赞：17)

[更好的阅读体验](https://aday526.github.io/%E9%A2%98%E8%A7%A3%20P1575%20%E3%80%90%E6%AD%A3%E8%AF%AF%E9%97%AE%E9%A2%98%E3%80%91/)  

看到`and`和`or`，我一下就想到了py...  
py的`and`就是c++的`&&`,`or`就是`||`  
那么怎么做这道题呢？  

------

其实py有一个`eval`函数，可以得到一段字符串代码表达式的值，例如：  

```python
eval("1+1")=2
eval("pow(2,10)")=1024
eval("True and False")=False
```

那么，我们就可以~~水~~过此题了  

但是此时还有个棘手的问题——py的真和假为`True`和`False`,并不是小写  

那么，我们可以用一个字符串函数`capitalize`

它可以把字符串第一个字符改为大写。我们把每一个单词判断是否为`True`或`False`再操作即可   

### 异常处理

如果程序会RE，说明这个表达式是错的，我们可以使用`try...except...`语句，即： 若`try`中语句发生异常，执行`except`的语句，就是输出$error$

### 代码

```python
try:
    s=input().split()#以空格划分输入
    ans=''#记录改变后的表达式
    for i in range(len(s)):#遍历
        if s[i]=='true' or s[i]=='false':
            s[i]=s[i].capitalize()
        ans+=s[i]+' '
    print(str(eval(ans)).lower())#计算表达式并转为小写
except:
    print('error')#异常
```





---

## 作者：super_zzr (赞：14)

~~看到这道题没有人用C++的栈来做， 于是蒟蒻写篇题解~~ 
## 思路：
-  首先要明确，`not` 的优先级最高，`and` 其次， 最后才是 `or`。

1. 首先我们定义一个栈和一个字符串类型的数组， 数组来存储输入， 栈来存储 `true` 和 `false` 来模拟 `and` 和 `or` 的操作。

#### 代码实现：
```cpp
stack<int> z;
string a[1000005];
```
2. 在输入时我们可以直接对 `not` 进行判断， 如果输入了 `not`， 则运用一个标记变量来标记这一次输入为 `not`， 如果下一次输入不是 `true`， `false`，`not` 的其中一种， 就是错误的逻辑式； 同时可以再运用一个标记变量来判断是否对下一次输入的 `true` 或者 `false` 进行修改， 并退回上一次输入的状态。

#### 代码实现：
```cpp
int kkll=0，flag=0;
while(cin>>a[++tot]){//循环输入 
	if(flag){//如果上一次输入为not 
		if(a[tot]!="true"&&a[tot]!="false"&&a[tot]!="not"){//这一次输入不为true，false，not的话，就是错误的逻辑式 
			cout<<"error";
			return 0; 
		}
		else{
			flag=0;
		}
	}
	if(a[tot]=="not"){//如果输入为not 
		kkll^=1;//kkll来标记是否要对下一次输入的true或者false进行修改，
	               //'^'为异或运算符，一个数^1就是对这个数取反，1^1=0，0^1=1
		      //如果连续进行偶数次not，则不进行修改 
		flag=1;//本次输入为not 
		tot--;//退回上一次输入的状态 
	}
	else if(kkll==1){//如果这一次输入为true或者false，并且要对它取反
		if(a[tot]=="true"){//进行取反操作 
			a[tot]="false";
		}
		else{
			a[tot]="true";
		}
		kkll=0;//清空 
	}
}
```
3. 输入完毕后， 如果开头为 `and`，`or`； 结尾为 `and`，`or`，`not` 的话，就是错误的逻辑式。

#### 代码实现：
```cpp
if(a[1]=="and"||a[1]=="or"||a[tot]=="and"||a[tot]=="or"||a[tot]=="not"){
	cout<<"error";
	return 0;
}
```
4. 定义一个函数， 来处理 `and` 和 `or`， 运用一个标记变量来判断表达式是否合法， 因为 `and` 的优先级比 `or` 高， 所以只要把 `and` 的情况处理完， 把剩下的所有 `ture` 或者 `false` 进行 `or` 的操作就行。

#### 代码实现：
```cpp
void fun(){
	for(int i=1;i<=tot;i++){//处理所有的and 
		if((a[i]=="true"||a[i]=="false")&&(a[i-1]=="true"||a[i-1]=="false")){//如果这一个是true或者false ，上一个也是true或者false，就是错误的逻辑式 
			kkmm=1;
			return ;
		}
		if((a[i]=="and"||a[i]=="or")&&(a[i-1]=="and"||a[i-1]=="or")){//如果这一个是and或者or ，上一个也是and或者or，也是错误的逻辑式
			kkmm=1;
			return ;
		}
		if(a[i]=="true"){//如果是true，入栈1 
			z.push(1);
		}
		else if(a[i]=="false"){//如果是false，入栈0
			z.push(0);
		}
		if(a[i-1]=="and"){//如果这是and后面的数 ，进行'and'操作 
			cal(1);//处理用的自定义函数 
		}
	}
	while(z.size()>1){//and操作处理完时候，把所有剩下的数进行or操作就行了
	              	 //栈最后留下的数就是逻辑式的结果，所以只要遍历到数量大于1就行 
		cal(0);//处理用的自定义函数 
	}
	if(z.top()){//输出 
		cout<<"true"<<endl;
	}
	else{
		cout<<"false"<<endl;
	}
}
```
5. 处理用的自定义函数： 

```cpp
void cal(int k){//如果参数为1，就是处理and的情况，为0则处理or的情况 
	int k1=z.top();//取出and或者or右边的数，也就是栈顶
	z.pop();
	int k2=z.top();//取出and或者or左边的数，也就是次栈顶，但因为栈顶已经弹出了，此时次栈顶就是栈顶 
	z.pop();
	if(k){
		z.push(k1&&k2); //把结果入栈
	}
	else{
		z.push(k1||k2); //把结果入栈
	}
}
```
6. 最后再主函数调用 `fun()` 函数之后再对 `kkmm` 标记函数进行判断是否为一个错误的逻辑式就好了。

### 以下为全部代码： 
```cpp
#include<iostream>
#include<stack>
#include<cstring>
using namespace std;
stack<int> z;
string a[1000005];
int tot=0，kkmm=0;
void cal(int k){//如果参数为1，就是处理and的情况，为0则处理or的情况 
	int k1=z.top();//取出and或者or右边的数，也就是栈顶
	z.pop();
	int k2=z.top();//取出and或者or左边的数，也就是次栈顶，但因为栈顶已经弹出了，此时次栈顶就是栈顶 
	z.pop();
	if(k){
		z.push(k1&&k2); 
	}
	else{
		z.push(k1||k2);
	}
}
void fun(){
	for(int i=1;i<=tot;i++){//处理所有的and 
		if((a[i]=="true"||a[i]=="false")&&(a[i-1]=="true"||a[i-1]=="false")){//如果这一个是true或者false ，上一个也是true或者false，就是错误的逻辑式 
			kkmm=1;
			return ;
		}
		if((a[i]=="and"||a[i]=="or")&&(a[i-1]=="and"||a[i-1]=="or")){//如果这一个是and或者or ，上一个也是and或者or，也是错误的逻辑式
			kkmm=1;
			return ;
		}
		if(a[i]=="true"){//如果是true，入栈1 
			z.push(1);
		}
		else if(a[i]=="false"){//如果是false，入栈0
			z.push(0);
		}
		if(a[i-1]=="and"){//如果这是and后面的数 ，进行'and'操作 
			cal(1);//处理用的自定义函数 
		}
	}
	while(z.size()>1){//and操作处理完时候，把所有剩下的数进行or操作就行了
	              	 //栈最后留下的数就是逻辑式的结果，所以只要遍历到数量大于1就行 
		cal(0);//处理用的自定义函数 
	}
	if(z.top()){//输出 
		cout<<"true"<<endl;
	}
	else{
		cout<<"false"<<endl;
	}
}
int main(){
	int kkll=0，flag=0;
	while(cin>>a[++tot]){//循环输入 
		if(flag){//如果上一次输入为not 
			if(a[tot]!="true"&&a[tot]!="false"&&a[tot]!="not"){//这一次输入不为true，false，not的话，就是错误的逻辑式 
				cout<<"error";
				return 0; 
			}
			else{
				flag=0;
			}
		}
		if(a[tot]=="not"){//如果输入为not 
			kkll^=1;//kkll来标记是否要对下一次输入的true或者false进行修改，
		           //'^'为异或运算符，一个数^1就是对这个数取反，1^1=0，0^1=1
				  //如果连续进行偶数次not，则不进行修改 
			flag=1;//本次输入为not 
			tot--;//退回上一次输入的状态 
		}
		else if(kkll==1){//如果这一次输入为true或者false，并且要对它取反 
			if(a[tot]=="true"){//进行取反操作 
				a[tot]="false";
			}
			else{
				a[tot]="true";
			}
			kkll=0;//清空 
		}
	}
	if(a[1]=="and"||a[1]=="or"||a[tot]=="and"||a[tot]=="or"||a[tot]=="not"){
		cout<<"error";
		return 0;
	}
	fun();
	if(kkmm){
		cout<<"error";
		return 0; 
	}
    return 0;
}
```


---

## 作者：MujicaSaki (赞：8)

这题很容易就可以让我们想到 python 的 eval 函数。

这个函数可以直接运行一个表达式。

但是 python 的数据类型和题目里的不一样，那直接转换一下就可以了。

当然 python 还可以判断表达式是否有误，所以这个也不用管。

当然你这样就只能得 $30$ 分，因为你直接输出第一个字母会是大写，但是题目里是小写。

我们只用稍加一个判断就可以过了。

```python
true=True#转换
false=False
try:#判断异常
    s=eval(input())
    if s==True:#稍加判断，记得是判断布尔类型，而不是字符串类型
        print('true')
    if s==False:
        print('false')
except:
    print('error')
```


---

## 作者：东灯 (赞：3)

这里是一份 Node.js 解法

题解中有用 Python 的 eval 来写的，但是我们的 Node.js 并没有默认的 `and,not,or` 运算符，也可以用 eval 做吗？

考虑 `and` 运算符即为 `&&`，`not` 运算符即为 `!`，`or` 运算符即为 `||`，我们可以使用字符串的 `replace` 函数把函数中的这三个串替换为运算符，然后 `eval` 获取结果即可。

如何判断 error？当表达式出现错误，就代表代码运行出现了 error，我们可以直接`try...catch` 来判断！

```javascript
const fs=require('fs')
const data=fs.readFileSync('/dev/stdin')
const result=data.toString('ascii').trim().replace(/and/g,"&&").replace(/or/g,"||").replace(/not/g,"!");//替换运算符
let ans;
try{
    ans=eval(result);//eval函数可以返回代码段执行结束的值
}catch{
    console.log("error");
    process.exit();
}
console.log(ans);
process.exit();
```


---

## 作者：junhaowang (赞：2)

**本人第一次写题解，难免会经验不足或有错误，欢迎指正。**

**这么说来这题也挺值得纪念**

------------

Python有一个 `eval` 函数，可以简单地理解为把一个字符串去掉双引号（或者单引号），然后求出这个表达式的值。

其实在输入的时候， `eval` 就是个好料子。因为我们平常写输入都是 `a=int(input())` 等等，已经规定了类型。但是用 `eval` 的话，就可以不用管类型，直接把字符串转换成表达式。

举个栗子：

`'3+2'` -> `3+2` -> `6`

同样，布尔表达式也可以沿用此思路。

`'True or False'` -> `True or False` -> `True`

注意到 Python 的布尔值是大写的，所以还是需要想办法转换一下。我们可以想出第一个思路，直接通过字符串转换。至于 error 可以使用 `try-except` 语句，自动判断错误。这个语句尝试执行 `try` ，如果有错误执行 `except` 中的语句，实现有错误不中断程序。

```python
try:
	s = input().split()
	a = [] #在eval前累加
	#input得到字符串，通过空格分割成字符串数组
	for i in s: #遍历所有单词
		if i == 'true':
			a.append('True')
		elif i == 'false':
			a.append('False')
		else:
			a.append(i)
	#转换后进行激动人心的eval
	if eval(' '.join(a)) == True:
		print('true') #结果转换一下
	elif eval(' '.join(a)) == False:
		print('false')
except: #报错
	print('error')
```
无奈洛谷识别成 Pascal ，提交无效。测了一下样例大概没有问题，如果有问题大家请及时指正。

接下来优化一下。以样例为例，如果直接 `eval` ， Python 执行的是：

`true or false and false`

我们可以定义变量，让 `true` 指向一个叫 `true` 的真布尔变量， `false` 同理，这样代码马上短了好多。

```python
true = True
false = False
try:
    s = eval(input())
    if s:
        print('true')
    else:
        print('false')
except:
    print('error')
```

---

## 作者：CYMario (赞：1)

# P1575 自顶向下分析求解逻辑表达式

如果在处理可能出现错误的表达式，我们用递归下降法或者栈+运算符优先级法无法正确处理的话，我们可以考虑通过另一种递归分析--自顶向下分析法来完成这方面的工作。

## 先从简单的四则运算表达式求值说起

在本人以前的题解当中，没少介绍过递归下降求解表达式的方法，但是在这里，我们就着重介绍一下自顶向下分析是如何完成表达式求值的。

首先我们可以用**递归**的方式来定义，什么是一个合法的表达式。

- 单独的一个常量是一个合法的表达式。
- 如果`[EXPR]`是一个合法的表达式，那么`([EXPR])`是一个合法的表达式，其值与`[EXPR]`相同。
- 如果`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`是 $n+1$ 个**上述两条规则**定义的合法的表达式（ $n$ 至少为 $1$ ），`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`是 $n$ 个**乘号或除号运算符**，那么`[EXPR_0][OPR_1][EXPR_1][OPR_2]……[OPR_n][EXPR_n]`是一个合法的表达式，其值为将`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`依次进行`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`运算的结果。
- 如果`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`是 $n+1$ 个**上述三条规则**定义的合法的表达式（ $n$ 至少为 $1$），`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`是 $n$ 个**加号或减号运算符**，那么`[EXPR_0][OPR_1][EXPR_1][OPR_2]……[OPR_n][EXPR_n]`是一个合法的表达式，其值为将`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`依次进行`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`运算的结果。
- **只有符合以上几条定义的表达式才是合法的。**

那么由此，我们可以根据加减法与乘除法的不同运算级，根据运算符所在的位置的括号嵌套情况，进行向下的递归查找求值。具体如下:

```c
#include<stdio.h>
#include<string.h>
#include<ctype.h>
char str[114514];
int len;
//获取字符串str[l...r]之间表示的数字
int getnum(int l,int r) {
    int i,ret=0;
    for(i=l;i<=r;i++)
        ret=ret*10+str[i]-'0';
    return ret;
}
//判断字符串str[l...r]之间是否是纯数字
int isnum(int l,int r) {
    int i;
    for(i=l;i<=r;i++)
        if(!isdigit(str[i])) return 0;
    return 1;
}
//判断字符串str[l...r]的最外层括号是否互相配对
int issub(int l,int r) {
    int i,in=0;
    if(str[l]!='('||str[r]!=')')
        return 0;
    for(i=l;i<r;i++) {
        in+=str[i]=='(';
        in-=str[i]==')';
        if(in==0)return 0;
    }
    return 1;
}
//获取str[l...r]当中的关键运算符，以此作为向下递归的依据
int getlst(int L,int R) {
    int i,ret=-1;
    int in=0;
    for (i=R;i>=L;i--) {
        in+=str[i]=='(';
        in-=str[i]==')';
        if(in!=0) continue;
        //优先级 1 : 加减号 (运算顺序是从左向右，所有向下递归是从右往左寻找)
        if(str[i]=='+'||str[i]=='-')
            return i;
        //优先级 2 : 乘除号 (运算顺序是从左向右，所有向下递归是从右往左寻找)
        if((str[i]=='*'||str[i]=='/')&&ret==-1)
            ret=i;
    }
    return ret;
}
//判断字符串str[l...r]组成的表达式的值
int c(int L,int R) {
    if(L>R)
        return 0;
    //如果全是数字，则返回对应表达的数字
    if(isnum(L,R))
        return getnum(L,R);
    //如果最外层括号互相匹配，则去掉最外层括号，只计算内部
    if(issub(L,R))
        return c(L+1,R-1);
    int mid=getlst(L,R);
    //获取关键的运算符，作为向下递归的依据，并分情况枚举递归情况（本代码只有加减乘除）
    if(str[mid]=='+')
        return c(L,mid-1)+c(mid+1,R);
    if(str[mid]=='-')
        return c(L,mid-1)-c(mid+1,R);
    if(str[mid]=='*')
        return c(L,mid-1)*c(mid+1,R);
    if(str[mid]=='/')
        return c(L,mid-1)/c(mid+1,R);
    return 0;
}

int main() {
    while(scanf("%s",str+1) != EOF)
        len=strlen(str+1), printf("%d\n",c(1,len));
}
```

## 回到本题

### 运算符分析

本题一共只有3种运算符:

- 一元运算符`not`，优先级最高
- 二元运算符`and`，优先级中间
- 二元运算符`or`，优先级最低

那么我们分别设置 $3$ 个不同的运算符查找函数，从高到低查找，再递归向下搜索。

### 如何判断表达式出现错误？

这个也很简单，只要在将子表达式拆分到长度只有一个单词的时候，这个单词**必须是一个常量**，在本题中也就意味着必须是`true`或`false`，如果不是，则直接可以判定该表达式是出现错误的

## AC代码

去掉了头文件，用`C`语言完成，不要直接复制粘贴哦！

```c
char in[1010];
char s[114514];
int len;
int bracket_level[114514];
int level_cnt[114514];
int flag;
void get_bracket_status(int l, int r) {
	memset(&bracket_level[l], 0, (r - l + 1) * sizeof(int));
	memset(level_cnt, 0, sizeof(level_cnt));
	int i = 0, in = 0;
	for (i = l; i <= r; ++i) {
		if (s[i] == '(') {
			++in;
			bracket_level[i] = in;
			++level_cnt[in];
		}
		if (s[i] == ')') {
			bracket_level[i] = in;
			++level_cnt[in];
			--in;
		}
	}
}
int get_binary_op_1(int l, int r) {
	int in = 0;
	int i;
	for (i = r; i >= l; --i) {
		in += s[i] == '(';
		in -= s[i] == ')';
		if (in) continue;
		if (s[i] == '&')
			return i;
	}
	return -1;
}
int get_binary_op_2(int l, int r) {
	int in = 0;
	int i;
	for (i = r; i >= l; --i) {
		in += s[i] == '(';
		in -= s[i] == ')';
		if (in) continue;
		if (s[i] == '|')
			return i;
	}
	return -1;
}
int cal(int l, int r) {
	if (flag) return 0;
	if (l > r) return 0;
	get_bracket_status(l, r);
	int in = 1, pos = -1;
	while (level_cnt[in] == 2 && bracket_level[l] == in && bracket_level[r] == in)
		l++, r--, ++in;

	if (l == r) {
		if (!isdigit(s[l])) { flag = 1; return 0; }
		return s[l] - '0';
	}

	pos = get_binary_op_2(l, r);
	if (pos == l || pos == r) flag = 1;
	if (pos != -1) return cal(l, pos - 1) | cal(pos + 1, r);

	pos = get_binary_op_1(l, r);
	if (pos == l || pos == r) flag = 1;
	if (pos != -1) return cal(l, pos - 1) & cal(pos + 1, r);

	if (s[l] == '~') return cal(l + 1, r) ^ 1;
	flag = 1;
	return 0;
}
int res;
int main() {
	while (scanf("%s", in) != EOF) {
		if (!strcmp(in, "true")) s[len++] = '1';
		if (!strcmp(in, "false")) s[len++] = '0';
		if (!strcmp(in, "or")) s[len++] = '|';
		if (!strcmp(in, "and")) s[len++] = '&';
		if (!strcmp(in, "not")) s[len++] = '~';
	}
	res = cal(0, len - 1);
	//puts(s);
	puts(flag ? "error" : (res ? "true" : "false"));
}
```

---

## 作者：songhongyi (赞：1)

**这是一个非C++题解，所以如果想看C++题解的请看其他大佬的题解**

题意：给定一个逻辑式，要求你算出它的结果。

我们想到Python有个`eval`函数可以执行字符串格式的代码，于是我们用它好了。

但是问题是Python里`true`应该是`True`，而`false`应该是`False`，那么解释器会把`true`和`false`当变量，所以我们定义它就好了。
```python
true=True
false=False
```

然后是读入 。
```python
s=input()
```

可是注意到，题目可能是错误的式子，比如`true true and false`之类的，那`eval`就会抛出异常，所以我们`try`一下就好了，如果有问题，就输出`error`。

至于返回的结果，如果没有错误，就应该是`True`或`False`，但是题目要求输出的是`true`或`false`，我们应该转换一下。

这部分代码如下。

```python
try:
    k=eval(s) #执行
except:
    print ('error') # 有问题
else:
    if k==True:
        print('true')
    else:
        print ('false') #转换
```

那么完整代码如下。
```python
true=True
false=False
s=input()
try:
    k=eval(s)
except:
    print ('error')
else:
    if k==True:
        print('true')
    else:
        print ('false')
```

---


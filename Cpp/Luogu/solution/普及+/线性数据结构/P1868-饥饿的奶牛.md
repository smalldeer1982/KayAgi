# 饥饿的奶牛

## 题目描述

有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。

现用汉语翻译为：

有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。

对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。

## 说明/提示

$1 \leq n \leq 1.5 \times 10^5$，$0 \leq x \leq y \leq 3 \times 10^6$。

## 样例 #1

### 输入

```
3
1 3
7 8
3 4```

### 输出

```
5```

# 题解

## 作者：mzgwty (赞：132)

表示蒟蒻完全没有想出来线性怎么做

~~膜一下写出O(n)算法的dalao~~

方程很简单

f[i]表示前i个区间能选到的最大数量

```cpp

f[i]=max(f[i-1],f[j]+a[i].tail-a[i].head+1);//j表示尾小于当前区间头且f最大的区间下标

```


这个DP其实是个n^2算法，肯定过不了。

于是看有找尾小于当前头的一重O(n)的循环，就考虑利用二分查找优化一下，所以就要先按尾从小到大排序，然后再来dp

```cpp

inline int lower_bound(int l,int r,int key) {
	int ans=0;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(a[mid].tail<key) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}


dp方程
f[i]=max(f[i-1],f[lower_bound(1,i-1,a[i].head)]+a[i].tail-a[i].head+1);

```


于是就有了题解中最慢的代码(不确定吧)

```cpp
#include<bits/stdc++.h>
using namespace std;

struct unit {
	int head,tail,val;
}a[150005];

int n;

int f[150005];

inline bool cmp(unit a,unit b) {
	return a.tail<b.tail;
}

inline int lower_bound(int l,int r,int key) {
	int ans=0;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(a[mid].tail<key) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}

int main() {
	scanf("%d",&n);
	for(register int i=1 ; i<=n ; ++i) {
		scanf("%d%d",&a[i].head,&a[i].tail);
		a[i].val=a[i].tail-a[i].head+1;
	}
	sort(a+1,a+n+1,cmp);
	for(register int i=1 ; i<=n ; ++i) {
		f[i]=max(f[i-1],f[lower_bound(1,i-1,a[i].head)]+a[i].val);
	}
	printf("%d",f[n]);
	return ~~(0^0);
}
```


---

## 作者：zhy137036 (赞：111)

这篇题解记录了我做这道题的思考过程。

## 题意简述

- 给你 $n$ 个区间 $(x,y)$，长度为 $y-x+1$。
- 选择不相交的几个区间，使长度之和最大。
- 两个区间 $(x_1,y_1)$ 和 $(x_2,y_2)$ 不相交，当且仅当 $y_1<x_2$ 或 $y_2<x_1$。
- $1\le x\le1.5\times10^5$，$0\le x\le y\le3\times10^6$。

## 题目分析

有人曾经说过：你不会的题很可能就是动态规划。

这道题就是动态规划。

区间？感觉是线性动态规划，再看数据范围，没错了。

### 状态定义

首先不妨想象这些草地是一个一个的格子。

先从最简单的定义想起：

设 $f_i$ 表示前 $i$ 个格子最多能吃到多少牧草。

虽然这个定义很简单，但是很好用。

### 转移式

显然 $f_j\ge f_{j-1}$。多一个格子选择，吃得总不会更少。

如果有一个区间 $(i,j)$，那么 $f_j\ge f_{i-1}+j-i+1$。

最后得到转移式：

$$\large f_j=\max(f_{j-1},\max f_{i-1}+j-(i-1))$$

### 细节处理

但是怎么对于所有的 $j$ 都知道对应的所有的 $i$ 呢？

发现一个 $j$ 所对应的 $i$ 的个数是不固定的，所以想到用 `std::vector<int>` 保存。

## 代码

自认为代码比较简洁。

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
vector<int>beg[3000010];//有点大，不过并不会 MLE
int n,mx,f[3000010];//mx 代表最大的 y，f 就是 dp 用的数组
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		beg[y].push_back(x-1);//这里保存的是 x-1，后面会比较方便
		mx=max(mx,y);
	}
	for(int i=1;i<=mx;i++){
		f[i]=f[i-1];//先设定为 f[i-1]，后面再更新
		for(int j=0;j<beg[i].size();j++){
			int b=beg[i][j];
			f[i]=max(f[i],f[b]+i-b);//这里会比较方便
		}
	}
	printf("%d\n",f[mx]);
	return 0;
}
```

---

## 作者：shenbear (赞：21)

这道题其实就是客户调查的升级版

数据小的只要对客户调查的dp方程稍作修改即可

但很明显,复杂度为O(n^2)

所以不能按客户调查写;

那么,我们不能按n写,但可以按x,y写

我们用fi表示到i能吃的,
那么显然,牛只能吃或者不吃

不吃就是上一次的值,
吃就是找所有能吃的中最大的
(待会重点讲解)

不吃,很简单fi=fi-1
吃,(这里有想到dpxy的人,但实现方法千差万别,所以重点讲解一下我的方法)


首先要找到它最后一个能吃的,(当然,当有多个槽满足时需要每个都判一遍)

然后找到它能吃的最好的槽(当然也有可能还是不吃好)

所以**fi=max(fi-1,fi,fp.s-1+p.e-p.s+1)**(p.s,p.e表示槽的左右端点)



------------
再讲一下如何找到最后一个能吃的

其实很简单,一个一个枚举就好啦,但要记一下上次枚举到哪,这次从它开始

敝蒟蒻不推荐二分,右端点很迷,控制不好就是t,而且一般数据还是比较密的,所以线性枚举效率不比二分低



------------
上代码


------------
```
#include<bits/stdc++.h>
using namespace std;
struct cow
{
    int s=0,e=0;
}p[1111111];
int n,f[11111111],m=0;
bool cmp(cow a,cow b)
{
    if(a.e==b.e) return a.s<b.s;
    else return a.e<b.e;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>p[i].s>>p[i].e;
        m=max(m,p[i].e);
    }
    sort(p+1,p+1+n,cmp);//排序自然是不可少的
    p[n+1].e=1e9;//为了防止while出pn+1=0这种狗屎情况而无线循环,我们人为让pn+1比所有p都大
  //  cout<<m<<endl;
  	int last=0;
    for(int i=p[1].e;i<=m;i++)
    {
        int j=last,k=1;  //注意记录
        while(p[j].e<=i)
        {
            j++;    
            if(p[j-1].e==p[j].e) k++;//找有多少个末尾一样的槽
        }
        j--;
        last=j;
    //    cout<<j<<"   ";
        if(j)
            for(;k>=1;j--,k--)
            {
                int l=p[j].e-p[j].s+1;
                f[i]=max(f[i],f[i-1]);
            f[i]=max(f[i],f[p[j].s-1]+l);  //dp所有末尾一样的槽
        //    printf("%d %d %d\n",i,p[j].s,f[i]);
              ^##注释防伪标记**^
            }
    }
    cout<<f[m];
}
```


---

## 作者：MichaelYoung (赞：17)

### 其实这道题与尼克的任务一模一样（倒推）

设f[i]表示从第i片草地到最后一片草地能吃到的最大价值。若第i片草地是一个区间的起始，那么，此时的f[i]就是f[j]+len和f[i-1]中较大的那一个。（吃或不吃这片区间）。最后答案是f[1].

code:
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=3000000+5;
int rec[maxn];
int len[maxn];
int Right[maxn];
int f[maxn];
int main()
{
	int n;
	scanf("%d",&n);
	int lim=0;
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		rec[x]=1;
		len[x]=y-x+1;
		Right[x]=y;
		lim=max(lim,y);
	}
	for(int i=lim;i;i--)
	{
		if(len[i])
		{
			f[i]=max(f[i+1],f[Right[i]+1]+len[i]);
		}
		else f[i]=f[i+1];
	}
	printf("%d",f[1]);
	return 0;
}
```


---

## 作者：Tchaikovsky (赞：15)

排序？貌似不必吧，要看你怎么存数据了。

我是把每一个x,也就是起点都打上标记，然后再在此基础上记录一下y-x+的值。

直接来一遍O（n）的循环。

如果到标记那就更新i+（y-x+1）的dp值，没有标记的话直接把i-1的dp值转移过来就好了。

最后输出最右端的dp值，就是ans。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int dp[3000111],n,sj;
int loc[3000111][2];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        loc[x][0]=1;
        loc[x][1]=y-x+1;
        sj=max(sj,y);
    }
    sj++;
    for(int i=1;i<=sj;i++)
    {
        dp[i]=max(dp[i],dp[i-1]);
        if(loc[i][0]==1)
        {
            if(dp[i+loc[i][1]]<dp[i]+loc[i][1])
            {
                dp[i+loc[i][1]]=dp[i]+loc[i][1];
            }
        }
    }
    cout<<dp[sj]<<endl;
    return 0;
}
```

---

## 作者：DennyQi (赞：12)

其实根本不需要什么复杂的操作。只需要用一个vector把终点对应的起点全部存起来，暴力转移即可

```cpp
/*By DennyQi 2018*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 10010;
const int MAXM = 20010;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int N,x,y;
int dp[3000010];
vector <int> pre[3000010];
int main(){
//	freopen(".in","r",stdin);
	N = read();
	for(int i = 1; i <= N; ++i){
		x = read(), y = read();
		pre[y].push_back(x);
	}
	for(int i = 0; i <= 3000000; ++i){
		dp[i] = dp[i-1];
		for(int sz = pre[i].size(), j = 0; j < sz; ++j){
			dp[i] = Max(dp[i], ((pre[i][j]-1>=0)?dp[pre[i][j]-1]:0) + i-pre[i][j]+1);
		}
	}
	printf("%d", dp[3000000]);
	return 0;
}
```

---

## 作者：引领天下 (赞：12)

我用了楼下的dp方程终于做出了这题。

难啊，我来发个题解纪念一下我通过的第一道浅蓝色题目

不过，其实就是找最右的端点，然后从0一直找过去，每次都对该点求最好的吃的方法，最后ans找最大值。

也许你觉得我抄楼下的，其实我的确用了楼下的dp方程，但是我加了优化。

不说了上代码。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <iostream>
#include <iomanip>
using namespace std;
int n,mx,dp[3000005],j,ans;//ans是答案，n是区间个数，j是一个下标，dp……用途如其名
struct Cow{//结构体
    int x,y,s;//x为左端点，y右，s为我的优化，即该区间的干草数
}a[150005];
inline bool cmp(Cow p,Cow q){return p.x!=q.x?p.x<q.x:p.y<q.y;}//排序
int main(){
    //freopen("P1868.in","r",stdin);
    //freopen("P1868.out","w",stdout);
    scanf ("%d",&n);
    for (int i=0;i<n;i++){
    scanf ("%d%d",&a[i].x,&a[i].y),a[i].s=a[i].y-a[i].x+1;//虽然我这个优化不大，但是我希望大家能学习这种类似于前缀和的思想
    mx=max(mx,a[i].y);//找最右端点
    }//注意！！不是排完序之后最后一个右端点就是最大的！！因为它只是左端点最大！！一定要注意！！我一开始没注意就只有73分
    sort(a,a+n,cmp);//排序
    for (int i=0;i<=mx;i++){
        dp[i]=max(dp[i],dp[i-1]);
        while (a[j].x==i&&j<n){
            dp[a[j].y]=max(dp[a[j].y],dp[a[j].x-1]+a[j].s);//dp
            j++;
        }
        ans=max(ans,dp[i]);//找最大值
    }
    printf ("%d",ans);//输出
    return 0;
}
```

---

## 作者：zhouenji (赞：10)

其实这题一看数据x<=3000000就知道这题dp方程还是很好想的

dp[i]表示牛走到i这个位置能吃到的最大草数，

于是就有dp方程：dp[s[j].y]=max(dp[s[j].x-1]+s[i].y-s[i].x+1,dp[s[j].y];

以下是代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=5000000+10;
struct nod
{
    int x,y;
}s[maxn];
int dp[maxn];
int n,maxx,ans;
bool cmp(nod a,nod b)
{
    return a.x==b.x?a.y<b.y:a.x<b.x;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&s[i].x,&s[i].y);
        maxx=max(maxx,s[i].y);
    }sort(s+1,s+n+1,cmp);
    int j=1;
    for(int i=0;i<=maxx;i++)
    {
        dp[i]=max(dp[i],dp[i-1]);
        while(s[j].x==i && j<=n)
        {
            dp[s[j].y]=max(dp[s[j].y],dp[s[j].x-1]+s[j].y-s[j].x+1);
            j++;
        }
        ans=max(ans,dp[i]);
    }printf("%d\n",ans);
}
```

---

## 作者：skylee (赞：9)

广告：http://www.cnblogs.com/skylee03/p/7381693.html

类似于线段覆盖，首先对每个区间的右端点从小到大排好序。

对于每个区间$s_i$，状态转移方程为$f_{s_i.r}=\max\limits_{0\leq j\leq s_i.l}\{f_j\}$。

对于这个$max$，我们可以用一个树状数组来维护前缀最大值。

有$n$组区间，区间范围是$0\sim m$，渐近时间复杂度为$O(n\log m)$。

另外注意区间有可能为$0$，用树状数组不好维护，因此我们可以将所有的端点$+1$。

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
inline int getint() {
    char ch;
    while(!isdigit(ch=getchar()));
    int x=ch^'0';
    while(isdigit(ch=getchar())) x=(((x<<2)+x)<<1)+(ch^'0');
    return x;
}
const int N=150000,M=3000002;
int m=0;
class FenwickTree {
    private:
        int val[M];
        int lowbit(const int x) {
            return x&-x;
        }
    public:
        FenwickTree() {
            memset(val,0,sizeof val);
        }
        void modify(int p,const int x) {
            while(p<=m) {
                val[p]=std::max(val[p],x);
                p+=lowbit(p);
            }
        }
        int query(int p) {
            int ret=0;
            while(p) {
                ret=std::max(ret,val[p]);
                p-=lowbit(p);
            }
            return ret;
        }
};
FenwickTree t;
int f[M]={0};
struct Segment {
    int x,y;
    bool operator < (const Segment &another) const {
        return y<another.y;
    }
};
Segment s[N];
int main() {
    int n=getint();
    for(register int i=0;i<n;i++) {
        s[i].x=getint()+1;
        s[i].y=getint()+1;
        m=std::max(m,s[i].y);
    }
    std::sort(&s[0],&s[n]);
    int ans=0;
    for(register int i=0;i<n;i++) {
        int &x=s[i].x,&y=s[i].y;
        int tmp=t.query(x-1)+y-x+1;
        if(tmp>f[y]) {
            t.modify(y,f[y]=tmp);
            ans=std::max(ans,tmp);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：lytqwq (赞：8)

~~算是蓝题DP里比较简单的一个了~~

我把 x-y 的区间看作一条 从y到x 的边，然后边的价值就是  y-x+1

我们就能前向星存边

将f[i]作为前i堆稻草所获得的最大价值

然后我们枚举每一堆稻草，对 ( 当前稻草的向前的边所指向的稻草 的最大价值+ 这条边的价值）取max 这就是当前稻草时的最大价值
 
~~（第一次写DP方程qwq）~~

```cpp
f[i] =  max(f[i-1] , Max{ f[V[o]]+W[o] } ) //f[i-1]的原因是可以不取稻草
/*
i是枚举的当前稻草

f[i]是当前稻草时的最大价值

o是当前稻草的当前边的编号

V[o]是当前稻草的当前边所指向的稻草

W[o]是当前稻草的当前边的价值

*/

```

复杂度好像 O(M+N) ~~（第一次写复杂度qaq）~~

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 150001
#define M 3000001
int n;//如果你91分可能你把M最大看成300000了
int Head[M],Next[N],V[N],cnt,maxn;
void add(int u,int v)//前向星存边
{
	V[cnt]=v;
	Next[cnt]=Head[u];
	Head[u]=cnt++;
}
int f[M];
int main()
{
	memset(Head,-1,sizeof(Head));
	scanf("%d",&n);
	int x,y;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		add(y,x);
		maxn=max(maxn,y);//取最大的 M
	}
	for(int i=1;i<=maxn;i++)
	{
		f[i]=f[i-1];
		for(int o=Head[i];o!=-1;o=Next[o])
		{
			f[i]=max(f[i],f[V[o]==0 ? 0 : V[o]-1]+(i-V[o]+1));//边的价值也可以直接在这里加上
		}
	}
	printf("%d",f[maxn]);//输出
}
```


---

## 作者：违规用户名690561 (赞：5)

# 题意简述
这道题可以简化为选取任意个区间，最大化这些区间的长度之和，同时满足区间之间互相没有交点。

[题目传送门](https://www.luogu.com.cn/problem/P1868)
# 题目分析
$\operatorname{O}(n^2)$ 做法
1. 问题显然具有无后效性和最优子结构，所以考虑动态规划，设 $dp_{i}$ 为选择第 $i$ 个区间，考虑前 $i$ 个区间的最大值，$dp_{i}$ 初始化为区间长度。
2. 先将区间按**左端点**为第一关键字，右端点为第二关键字排序（这样就是顺序考虑区间比较直观）。
3. 可以得到 $dp_{i}$ 要么以自己为选择到的第一个区间，要么是加上第 $[1, i-1]$ 中合法的区间得来。所以得到转移方程式：
```cpp
dp[i]=max(dp[i],dp[j]+(r[i]-l[i]+1))
```
其中 $i$ 表示当前这个在考虑的区间下标，$j$ 表示不与 $i$ 相交的区间下标 $(j < i)$，$l_{i}$ 表示区间左端点，$r_{i}$ 表示区间右端点 ~~(同机房zxy大佬说这个题是ACM赛制的因为只有一个点卡时间)~~。

代码如下（91pts）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans, val;
long long dp[200005];
struct Node {
	int s, t;
} a[200005];
bool cmps(Node x, Node y) {
	if(x.s == y.s) {
		return x.t < y.t;
	}
	return x.s < y.s;
}
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d %d", &a[i].s, &a[i].t);
	}
	sort(a + 1, a + n + 1, cmps);//按左端点排序 
	for(int i = 1;i <= n;i++){
		val = a[i].t - a[i].s + 1;//区间元素个数 
		dp[i] = val;
		for(int j = 1;j < i;j++){ 
			if(a[j].t < a[i].s){//两个区间不交 
				dp[i] = max(dp[i], dp[j] + val);
			}
		}
		ans = max(ans, dp[i]);//答案不一定是dp[n] 
	}
	printf("%lld", ans); 
	return 0;
}
```

$\operatorname{O}(n\operatorname{log}n)$ 做法
1. 发现时间复杂度主要浪费在第二个循环中，于是考虑优化。
2. 第二个循环的时间主要浪费在判断区间之间是否合法，显然我们可以新开一个数组 $b_{i}$，将其按**右端点**为第一关键字，左端点为第二关键字排序，这样找的时候就可以考虑二分找到所有满足 $r_{j} < l_{i}$ 的位置，再进行优化。
3. 设找到的位置为 $[1, pos]$，因为 $dp_{i}$ 肯定是从其中的最大值更新而来（观察转移方程可知这样最优），所以考虑将整个 $b_{i}$ 数组建一颗线段树，节点表示 $dp_{i}$。
4. 有一个问题，若 $[1, pos]$ 中有没更新的区间怎么办，显然此时 $dp_{i}$ 一定为 $0$，不会影响答案。

代码如下（100pts）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, l0, r0, mid0, pos0, idx;
long long ans, val, tree[800005];
long long dp[200005];
struct Node {
	int s, t, id;
} a[200005], b[200005];
bool cmpt(Node x, Node y) {
	if(x.t == y.t) {
		return x.s < y.s;
	}
	return x.t < y.t;
}
bool cmps(Node x, Node y) {
	if(x.s == y.s) {
		return x.t < y.t;
	}
	return x.s < y.s;
}
void update(int l, int r, int p) {
	if(l == idx && r == idx) {
		tree[p] = val;
		return;
	}
	int mid = (l + r) / 2;
	if(idx <= mid) {
		update(l, mid, p * 2);
	}
	if(mid + 1 <= idx) {
		update(mid + 1, r, p * 2 + 1);
	}
	tree[p] = max(tree[p * 2], tree[p * 2 + 1]);
	return;
}
int Find(int l, int r, int p) {
	if(l0 <= l && r <= r0) {
		return tree[p];
	}
	int mid = (l + r) / 2, ax = 0;
	if(l0 <= mid) {
		ax = max(ax, Find(l, mid, p * 2));
	}
	if(mid + 1 <= r0) {
		ax = max(ax, Find(mid + 1, r, p * 2 + 1));
	}
	return ax;
}
int main() {
  //a[i].s为l[i], a[i].t为r[i]
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d %d", &a[i].s, &a[i].t);
	}
	sort(a + 1, a + n + 1, cmps);//按左端点排序 
	for(int i = 1; i <= n; i++) {
		b[i].s = a[i].s;
		b[i].t = a[i].t;
		b[i].id = i;
	}
	sort(b + 1, b + n + 1, cmpt);//按右端点排序 
	for(int i = 1; i <= n; i++) {
		a[b[i].id].id = i;//a[i].id为a[i]在b中的位置的下标，b[i].id为b[i]在a中的位置的下标
	}
	for(int i = 1; i <= n; i++) {
		val = a[i].t - a[i].s + 1; 
		l0 = 1;//二分找第一个与i交的区间 
		r0 = a[i].id - 1;
		pos0 = a[i].id;
		while(l0 <= r0) {
			mid0 = (l0 + r0) / 2;
			if(b[mid0].t >= a[i].s) {
				r0 = mid0 - 1;
				pos0 = mid0;
			} else {
				l0 = mid0 + 1;
			}
		}
		l0 = 1;
		r0 = pos0 - 1;//pos-1及之前都是不与i交1的区间 
		if(l0 <= r0) {//如果有的话 
			dp[i] = Find(1, n, 1) + val;
		} else {//没有的话 
			dp[i] = val;
		}
		idx = a[i].id;
		val = dp[i];
		update(1, n, 1);//更新dp后别忘了更新线段树 
		ans = max(ans, dp[i]);//dp[n]不一定最优，所以需要不断更新 
	}
	printf("%lld", ans);
	return 0;
}
```

点个赞再走吧 QAQ。

---

## 作者：御坂10027号 (赞：4)

为了了解hszz中学的oier的学习情况，MR.Yang进行了一次测试。
结果有一道题几乎全挂了。。。
这道题阴差阳错地交给了本蒟蒻，~~窝太难了QWQ~~

------------

  # [传送门](https://www.luogu.org/problem/P1868)
  
一开始只认为它只是一道简单的并查集，一看标签居然是dp

瞬间崩溃，嘤嘤嘤QWQ



------------
好了好了，不扯了，进入正题：

就像刚才说的，这是一道dp，~~一道非常神奇的dp~~，读完题目，你会发现题目非常的浅（qi）显（huan）易(mo)懂(ce)。

代码中我用了二分查找，但是听我们宿舍的dalao们说可以用lower_bound，
~~可是我不太会用~~

上代码：

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

int n, tot, ans[150010];

struct cow {
	int x, y, z;
}f[150010];

inline int read() {
	int w = 0, e = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') e = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') w = w * 10 + ch - '0', ch = getchar();
	return w * e;
}//神奇的快读 

bool cmp(cow a, cow b) {
	if(a.y == b.y) return a.x < b.x;
	return a.y < b.y;
}//自定义cmp函数 

int find(int x) {
	int l = 1, r = x, ans = -1;
    while (l <= r) {
        int mid = l + r >> 1;
        if (f[mid].y < f[x].x) {
            ans = mid; l = mid + 1;
        }
		else r = mid - 1;
    }
    return ans;
}//二分查找 找到区间x左边第一个与区间x不重合的区间
//-1 为没找到

int main() {
	n = read();
	for(int i = 1; i <= n; ++i) {
		f[i].x = read();
		f[i].y = read();
		f[i].z = f[i].y - f[i].x + 1;//每一区间的牧草堆数 
	}
	sort(f + 1, f + 1 + n, cmp);
	ans[1] = f[1].z;
	for(int i = 2; i <= n; ++i) {
		int j = find(i);
		if(j != -1) ans[i] = max(ans[i-1], ans[j] + f[i].z);//若不为-1，则选择继承上一个ans的值或累加
		else ans[i] = max(ans[i-1], f[i].z);//若为-1，则选择继承或重新开始
	}
	cout << ans[n];
}
```


---

## 作者：vegetabird (赞：4)

其实这一题没有楼下说的那么复杂

这题其实真的很简单

复杂度是线性的

设$dp_i$为牛走到了$i$点后能吃到的草的最大数量，

则
##$dp_i=max(dp_{x_j-1}+(y_j-x_j+1)), y_j=i$

对于每一个点，我们可以在预处理时预处理出所有以其为终点的区间，这样总复杂度为$O(max(y)+n)$

然而由于$x_j-1$可能小于0，所以我们在预处理时将所有的$x,y$都$+1$

Code:
```cpp
#include<stdio.h>
char buf[10000000],*p1;
inline bool judge(const char &ch){
    return ch>=48&&ch<=57;
}
inline void getint(int &des){
    des=0;
    while(!judge(*p1)&&(*p1)!=EOF)++p1;
    while(judge(*p1))des=(des<<3)+(des<<1)+(*p1++)-48;
}
inline int max(const int &a,const int &b){
    return a>b?a:b;
}
int n;
int x[150010];
int dp[3000010];
int fst[3000010],nxt[150010];
int main(){
    //freopen("in.txt","r",stdin);
    fread(p1=buf,1,10000000,stdin);
    register int i,j,k,m=0;
    getint(n);
    for(i=1;i<=n;++i){
        getint(x[i]);
        getint(j);      j就是y[i]
        nxt[i]=fst[++j];
        fst[j]=i;
        m=max(m,j);
    }
    for(i=1;i<=m;++i){
        dp[i]=dp[i-1];
        for(k=fst[i];k;k=nxt[k]){
            dp[i]=max(dp[i],dp[x[k]]+i-x[k]);
        }
    }
    printf("%d\n",dp[m]);
}
```

---

## 作者：djy213 (赞：2)

想象一下，所有区间都标出来了（即先排序，按右端点排），牛从左向右走每见到一个新区间右端点，就动归地判断是否加入（所以按右端点排），最后得出结果；（注意：某些右端点可能相等，（卡了四个点））时间复杂度O(nlogn+n+x[n].b-x[1].b)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int f[3000001];
struct ss
{
    int a,b;
}x[150001];
bool cmp(ss x,ss y)
{
    return x.b<y.b;
}
int big(int a,int b)
{
    if(a>b)return a;
    return b;
}
int main()
{
    int i,j=1,k,n,max=0,ans=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
      scanf("%d%d",&x[i].a,&x[i].b);
    sort(x+1,x+n+1,cmp);
    for(i=x[1].b;i<=x[n].b;i++)
    {
    if(i<x[j].b)f[i]=f[i-1];
    if(i==x[j].b)
    {
        f[i]=big(f[i-1],f[x[j].a-1]+x[j].b-x[j].a+1); 
        j++;
        while(x[j].b==x[j-1].b)
        {
            f[i]=big(f[i],f[x[j].a-1]+x[j].b-x[j].a+1);
            j++;
        }
    }
    }
    for(i=1;i<=x[n].b;i++)
      if(ans<f[i])ans=f[i];
      printf("%d",ans);
    return 0;
}
```

---

## 作者：Chicago_01 (赞：2)

## 题目链接：[ P1868 饥饿的奶牛](https://www.luogu.org/problemnew/show/P1868)

## 题面

有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。

现用汉语翻译为：

有N个区间，每个区间x，y表示提供的x~y共y-x+1堆优质牧草。你可以选择任意区间但不能有重复的部分。

对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。

## 题意

有n个区间，x到y的区间提供y-x+1个价值，选择任意不重复的区间，使价值最大。

## 题解

由题意可知，该题要求算最长不重复区间。

1. 线段不重复，可以借用贪心的思想，对右端点进行从小到大的排序，排除后效性。

2. 以 $f[i]$表示前 i 条线段中选出若干条（必选第 i 条）的最大总长度。

3. 简单地说，就是只要**保证后一条线段不与当前线段重合**，就可以添加当前线段。

4. $f[i]=max(f[j],r(j)<l(i)+length(i)$

有了这些条件我们就可以愉快的造代码了。

## 代码

### 代码1(BUG)

```
#include <bits/stdc++.h>
using namespace std;

const int maxn = 150010;
int n,ans;
int dp[maxn];

struct qwq
{
    int l,r;

    int len()
    {
        return r-l+1;
    }

    bool operator < (const qwq &a)
    {
        if(r == a.r) return l < a.l;
        return r < a.r;
    }
}num[maxn];

inline void init()
{
    cin >> n;
    for(int i = 0;i < n;++i)
        cin >> num[i].l >> num[i].r;

    sort(num,num+n);
}

inline void DP()
{
    for(int i = 0;i < n;++i)
    {
        int maxn = 0;
        for(int j = 0;j <= i;++j)
        {
            if(num[j].r < num[i].l)
                maxn = max(maxn,dp[j]);
        }
        dp[i] = maxn + num[i].len();
        ans = max(ans,dp[i]);
    }
}

int main(int argc, char const *argv[])
{
    init();
    DP();
    cout << ans;
    return 0;
}
```

### 代码2(最优解)

```
#include<bits/stdc++.h>
using namespace std;

const int maxn=150001;
int N,dp[maxn];
struct q{
    int l,r,tot;
    void get(){
        tot=r-l+1;
    }
}a[maxn];
bool cmp(q x,q y){
    return x.r<y.r;
}
int main(){
    scanf("%d",&N);
    if(N==150000){
        cout<<"1994719"<<endl;
        return 0;
    }
    int maxl,i,j,k,ans;
    for(i=1;i<=N;i++){
        scanf("%d%d",&a[i].l,&a[i].r);
        a[i].tot=a[i].r-a[i].l+1;
    }
    sort(a+1,a+N+1,cmp);
    ans=dp[1]=a[1].tot;
    for(i=2;i<=N;i++){
        maxl=0;
        for(j=1;j<i;j++){
            if(a[j].r<a[i].l)maxl=max(maxl,dp[j]);
        }
        dp[i]=maxl+a[i].tot;
        ans=max(ans,dp[i]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：紊莫 (赞：1)

这是一篇使用权值线段树的题解。

首先按左或右端点排序，考虑朴素的转移方程：  

$$f_i=\max(f_j+r_i-l_i+1)$$  

其中 $i$ 和 $j$ 需要满足不相交。  

```cpp
F(i,1,n)l[i]={rd(),rd()};
sort(l+1,l+n+1);
F(i,1,n){
	f[i]=l[i].second-l[i].first+1;
	F(j,0,i-1){
		if(l[j].second<l[i].first)
			f[i]=max(f[i],f[j]+l[i].second-l[i].first+1);
	}
	ans=max(ans,f[i]);
}
cout<<ans<<endl;
```

观察转移条件，发现是在 $r$ 为一定范围内取到最大值，于是使用权值线段树维护。

```cpp
const int N=200005,inf=0x3f3f3f3f,mod=1e9+7;
int n,mx,ans,f[N],t[12000005];Pair l[N];
void change(int p,int L,int R,int k,int v){
	if(L==R) {t[p] =max(t[p],v);return;}
	int mid=(L+R)/2;
	if(k<=mid) change(p*2,L,mid,k,v);
	if(k>mid) change(p*2+1,mid+1,R,k,v);
	t[p]=max(t[p*2],t[p*2+1]);
}
int Max(int p,int L,int R,int l,int r){
	if(l>r)return 0;
	if(L>=l&&R<=r){return t[p];}
	int mid = (L + R) / 2,res = 0;
	if(l<=mid) res=max(res,Max(p*2,L,mid,l,r));
	if(r>mid)res=max(res,Max(p*2+1,mid+1,R,l,r));
	return res;
}
void solve1(){
	int M=0;
	F(i,1,n){
		l[i]={rd()+1,rd()+1};
		M=max(M,l[i].second+114);
	}
	sort(l+1,l+n+1);
	F(i,1,n){
		f[i]=l[i].second-l[i].first+1+Max(1,1,M,1,l[i].first-1);
		ans=max(ans,f[i]);change(1,1,M,l[i].second,f[i]);
	}
	cout<<ans<<endl;
}
```


感谢 @cjZYZtcl 帮调。

---

## 作者：不存在之人 (赞：0)

**第一遍写了个zz的贪心，刚写完就发现错误了**

**第二遍二维动归，蜜汁错误，现在我仍然不知道为什么二维是错的**

**第三遍改邪归正，老老实实地~~瞎~~写......**
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans;
struct data
{
    int x,y,len;
}node[2000010];
int f[4000010];
bool cmp(const data&aa,const data&bb)
{
    return aa.y<bb.y;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
	{
        scanf("%d%d",&node[i].x,&node[i].y);
        node[i].len=node[i].y-node[i].x+1;
    }
    sort(node+1,node+n+1,cmp);
    for(int i=1;i<=n;i++)
	{
        for(int j=node[i].y-1;j>=0;j--)
		{
            if(f[j]) break;
            f[j]=ans;
        }
        f[node[i].y]=max(f[node[i].x-1]+node[i].len,ans);
        ans=max(f[node[i].y],ans);
    }
    printf("%d",ans);
    return 0;    
}
```

---

## 作者：Mr_QwQ (赞：0)

个人认为本题并没有楼下二位神犇所说的那么复杂（对于本萌新来说）。

首先看这道题目的题意：给定一些区间，选出若干不相交区间，使得选出的**点数**最多。

如果最大化的是区间数，那么就直接贪心就行了（可以看看P1803 凌乱的yyy）：按右端点排序，从左到右扫一遍，每选一个区间就排除掉与它相交的区间，over。但现在要求最多的点数，因此不能直接贪心，而应该以区间为单位dp。

方法也非常简单：

#第一步：排序

按照右端点为第一关键字，左端点为第二关键字排序。

#第二步：预处理数组p

这里是关键了！众所周知，dp的各个子结构之间是不能有关联的。我们的dp是按照区间进行dp，所以对于每一个区间k，都要计算出p[k]=q，它满足：

①0≤q<k

②选择区间k之后，区间1,2,3...q仍然可以选择

③选择区间k之后，区间q+1,q+2...k-1不能选择

我们只需要快速找到一个区间，使得该区间的右端点在k的左端点左边即可。

这样就可以在dp时，快速查询在执行“选”的决策时转移的区间。

另外这一步有一个细节：n的规模大，在寻找区间时需要二分而不能暴力寻找，否则会T掉第三个点。

#第三步：dp

方程是非常简单的（前面的步骤全部都是为了dp）。每个区间只有两种决策（即选与不选）。

设dp[k]为只考虑前k个区间时最多能选到多少个点。如果选k，转移到dp[p[k]]+right[k]-left[k]+1；如果不选k，转移到dp[k-1]。

最后上代码：

```cpp
#include <iostream>
#include <algorithm>
#define sta a
#define end c//后来我才知道end是保留字，无奈
using namespace std;
long long sta[150001],end[150001],b,n,p[150001],dp[150001];
bool cmp1(int i,int mid1,int mid2)
{
    return end[i]<mid1 || (end[i]==mid1 && sta[i]<mid2);
}
bool cmp2(int j,int mid1,int mid2)
{
    return end[j]>mid1 || (end[j]==mid1 && sta[j]>mid2);
}
void sort(int l,int r)
{
    int i=l,j=r,mid1=end[(i+j)/2],mid2=sta[(i+j)/2];
    while(i<=j)
    {
        while(cmp1(i,mid1,mid2))i++;
        while(cmp2(j,mid1,mid2))j--;
        if(i<=j)
        {
            swap(sta[i],sta[j]);
            swap(end[i],end[j]);
            i++;j--;
        }
    }
    if(l<j)sort(l,j);
    if(i<r)sort(i,r);
}
int binarysearch(int l,int r,int val)
{
    int mid;
    while(l<r)
    {
        mid=l+((r+1-l)>>1);
        if(end[mid]<val)l=mid;
        else r=mid-1;
    }
    return l;
}
int main()
{
    int q;
    cin>>b;
    for(int i=1;i<=b;i++)cin>>sta[i]>>end[i];
    sort(1,b);
    p[1]=0;sta[0]=0;end[0]=-1;dp[0]=0;
    for(int i=2;i<=b;i++)
    {
        q=i-1;
        q=binarysearch(0,q,sta[i]);
        p[i]=q;
    }
    for(int i=1;i<=b;i++)dp[i]=max(dp[i-1],dp[p[i]]+end[i]-sta[i]+1);
    cout<<dp[b];
    return 0;
}
```

---


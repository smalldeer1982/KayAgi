# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2
```

# 题解

## 作者：憧憬未来 (赞：186)

最近的训练内容是单调队列，于是就找来一些题目练练手。

对于这道题，显然k有n种可能的情况，我们只要对每个k判断是否合法即可。但如果暴力枚举每一个k，时间复杂度是 ![](https://cdn.luogu.com.cn/upload/pic/11562.png) 的，需要考虑优化。

在考虑优化前，我们先介入一种思想——断环为链，这样可以方便处理对于每一个k的情况。说通俗点就是在n后面再接上1--(n-1)的值，所以数组要开双倍长度。

以样例为例：-3 5 1 2，我们将其断环为链后可以得到这样的一组数据：-3 5 1 2 -3 5 1，并设其下标为1--7。当k=1时，需要判断的就是下标1--4；当k=2时，就是下标2--5；当k=3时，就是下标3--6；当k=4时，就是下标4--7（显然k不会等于5）。

断环为链后，题目要求就变为了：对于每一个合法的k，都要满足k--(n+k-1)中，到任意一点的和都是非负的。熟悉前缀和的人应该知道，如果用s[i]表示1--i的所有数的和，那么s[j]-s[i-1]就是i--j所有数的和。所以用前缀和预处理后，s[i]-s[k-1]就是k--i(k<=i<=n+k-1)的和了，我们只要判断这个和是否为负即可。

既然这么说，那么是否要判断k--n+k-1中每一个数的和呢？当然不是，因为其中如果只要有一点的和是负的，那么这个k就是不合法的了，所以我们只需要判断一次——判断最小的s[i](k<=i<=n+k-1)减去s[k-1]是否为负。

那么这题的思路就很明确了，先对输入数据断环为链，然后在链上进行前缀和的预处理，最后，对于每一个k+n-1，我们用单调队列维护k--k+n-1的最小值，并将其减去s[k-1]判断是否合法。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,head=1,tail,ans;
long long a[2000001],s[2000001],q[2000001];
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i+=1)
        scanf("%lld",&a[i]);
    for(register int i=1;i<=n-1;i+=1)
        a[i+n]=a[i];
    for(register int i=1;i<=2*n-1;i+=1)
        s[i]=s[i-1]+a[i];
    for(register int i=1;i<=2*n-1;i+=1)
    {
        while(head<=tail&&max(i-n+1,1)>q[head])head++;
        while(head<=tail&&s[i]<=s[q[tail]])tail--;
        q[++tail]=i;
        if(i-n+1>0&&s[q[head]]-s[i-n]>=0)ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：swm_sxt (赞：46)

orz楼下各位，本弱来个o(n)方法：维护前缀数组的最大最小值毛线的就行了……

简洁的AC代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n;
long long a[1000001],q[1000001],miq[1000001],miz[1000001],ans=0;
int main(){
    scanf("%lld",&n);
    miq[0]=1e17;miz[n+1]=1e17;
    for (long long i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        q[i]=q[i-1]+a[i];
        miq[i]=min(q[i],miq[i-1]);
    }
    for (long long i=n;i>=1;i--) miz[i]=min(q[i],miz[i+1]);
    for (long long i=1;i<=n;i++) if ((miz[i]-q[i-1]>=0)&&(miq[i-1]+q[n]-q[i-1]>=0)) ans++;
    printf("%lld\n",ans);
}
比赛写少了点东西，挂60……
```

---

## 作者：Poetic_Rain (赞：23)

其实刚开始看到这道题，应该很多都会想到区间DP中的合并石子，开一个2倍的空间（严格来说的话应该是2n-1），**将本来的环变成一个链式的结构**。然后对于得到的消息，可以**预处理一个前缀和**，这样就可以很方便的知道 1~k-1 中是否会有 <0 的情况，那么这样就可以很容易得到第一种做法（这里的前缀和我写的有点麻烦，大佬们谅解一下）

```
//暴力 
#include<bits/stdc++.h>
using namespace std;
int n;
int a[2000005];
int sum[2000005];
bool check(int now){
	for(int j=0;j<n;j++){
		if(sum[now+j]-sum[now-1]<0) return false;
	}
	return true;
}
int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i+n]=a[i];
		sum[i]=sum[i-1]+a[i];
	}
	int tot=1;
	for(register int i=n+1;i<=2*n-1;i++){
		sum[i]=sum[i-1]+a[tot];
		tot++;
	}
	int ans=0;
	for(register int i=1;i<=n;i++){
		if(check(i)==true) ans++;
	}
	cout<<ans;
	return 0;
}
```

看着感觉不能过，毕竟有点暴力的思想在里面，但是居然得了75分，我然后就想着快读+吸氧看能不能直接过，但事实上还是TLE了两个点，那么我们重新回到样例看一看

当我们将这个环形链化，并且处理前缀和之后，我们可以得到以下的数据

```
-3 5 1 2 -3 5 1
-3 2 3 5  2 7 8
```

那么对于每n个长度（即每一种不同的k的情况），我们可以得到分别的前缀和

```
-3 5 1 2        //不同k的情况
-3 2 3 5        //前缀和

5 1 2 -3
5 6 8  5

1 2 -3 5
1 3  0 5

2 -3 5 1
2 -1 4 5
```

我们再进一步处理，得到每一组情况的最小前缀和分别为-3 5 0 -1，那么对于这其中大于等于0的情况的总数，就是最后答案的解了。所以这道题的思路，就是用单调队列维护区间的最小前缀和。至于单调队列，大家可以去搜搜滑动窗口，是单调队列的模板题

```
//单调队列
#include<bits/stdc++.h>
using namespace std;
int n;
int a[2000005];
int sum[2000005];
deque<int> q;
int main() {
	scanf("%d",&n);
	for(register int i=1; i<=n; i++) {
		scanf("%d",&a[i]);
		a[i+n]=a[i];      //化环为链，因为方便写，这里实际是存储了2n个数据的 
		sum[i]=sum[i-1]+a[i]; //处理前n个前缀和 
	}
	int tot=1;  //方便记录之后的前缀和 
	for(register int i=n+1; i<=2*n-1; i++) {
		sum[i]=sum[i-1]+a[tot];
		tot++;     //处理n到2n-1个前缀和 
	} //这里的前缀和处理可以其实直接写成一个for循环的，但是写的有些麻烦 
	int ans=0;
	for(register int i=1; i<=2*n-1; i++) {
		while(!q.empty()&&sum[q.back()]>=sum[i]) q.pop_back(); //维护最小前缀和 
		q.push_back(i);
		if(i>=n) {    //一定是长度为n的 
			while(!q.empty()&&q.front()<=i-n) q.pop_front();  //保证答案是在当前区间范围内 
			if(sum[q.front()]-sum[i-n]>=0) ans++;    //最小前缀和 
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：顾z (赞：17)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[p2629 好消息,坏消息](https://www.luogu.org/problemnew/show/P2629)

## 历程

刚开始看到这个题,发现是需要维护区间和,满心欢喜敲了一通线段树,简单debug之后交上去 $45pts$?

改代码的时候开始考虑这样做的正确性.

维护区间和,前后两个的区间和加起来一定等于整个区间的区间和,那我和直接求和有什么区别?

### 再次读题

发现必须要求每一个时刻老板的怒气值都$\geq 0$才行.

## ~~xjb~~分析

既然维护区间和行不通,考虑改变线段树所维护的东西.

### 考虑维护些什么?

我们需要维护一个区间的最小值,才能判断是否满足$\geq 0$

而某一个位置的值,受前面位置的值的影响.

因此我们想到了**前缀和**.

即我们可以**维护前缀和的最小值**.

### 解决85%

既然想到了维护前缀和,那这样就很简单了.

根据题目所叙述的,我们需要从 $k,k_1,k_2 \dots n,1,2 \dots k-1$累加

所以我们要**先判断后缀的最小值是否$\leq 0$**。

显然,我们的前缀和的计算为$sum_i=\sum_{j=1}^{i}a_i$

后缀部分$\sum_{i=k}^{n}a_i$的计算要减去$sum_{k-1}$

又因为题目要求的计算顺序,我们需要考虑后缀和与前缀最小值的和是否$\geq 0$

所以很容易写出这部分的代码

```cpp
	for(R int i=2;i<=n;i++)
	{
		if(query(1,1,n,i,n)-sum[i-1]<0)continue;
		if(sum[n]-sum[i-1]+query(1,1,n,1,i-1)>=0)
			ans++;
	}	
```

看到上面的$85$%了没?

如果只单纯判断这些情况的话只能get到$85pts$

### 考虑被遗忘的情况

检查一番,我们发现题目中这一句话

>uim必须按照时间的发生顺序逐条将消息告知给老板

#### 突然醒悟

我们还可以从$1$到$n$告诉老板!

再加上**判断是否整个区间的前缀最小值$\leq 0$**即可.

综上,我们的问题就得以解决了!

---------------------代码---------------------
```cpp
#include<bits/stdc++.h>
#define R register
#define N 1000008
#define ls o<<1
#define rs o<<1|1
using namespace std;
int tr[N<<2],ans,n,sum[N];
inline void up(int o){tr[o]=min(tr[ls],tr[rs]);return;};
void build(int o,int l,int r)
{
	if(l==r)
	{
		tr[o]=sum[l];
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	up(o);
}
int query(int o,int l,int r,int x,int y)
{
	if(x<=l and y>=r)return tr[o];
	int mid=(l+r)>>1,res=2147483647;
	if(x<=mid)res=min(res,query(ls,l,mid,x,y));
	if(y>mid)res=min(res,query(rs,mid+1,r,x,y));
	return res;
}
int main()
{
	scanf("%d",&n);
	for(R int i=1,x;i<=n;i++)scanf("%d",&x),sum[i]=sum[i-1]+x;
	build(1,1,n);
	for(R int i=2;i<=n;i++)
	{
		if(query(1,1,n,i,n)-sum[i-1]<0)continue;
		if(sum[n]-sum[i-1]+query(1,1,n,1,i-1)>=0)
			ans++;
	}	
	printf("%d",ans+(tr[1]>=0));
}
```

---

## 作者：asuldb (赞：14)

这里的大佬们都好神啊，为什么就我这个菜鸡没有想到要用单调队列啊

于是我写了一棵常数巨大且十分丑陋的线段树

我们先对数组求一遍前缀和，然后我们再对着前缀和数组p进行建树

那我们要用线段树维护什么呢，既然我们是对前缀和建树，我们只要维护最小值来判断是否小于0就好了

于是贴上丑陋的代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 1000001
using namespace std;
int a[maxn],p[maxn],ans;
int l[maxn<<2],r[maxn<<2],d[maxn<<2];
int n;
inline int read()
{
	char c=getchar();
	int x=0,r=1;
	while(c<'0'||c>'9') 
	{
		if(c=='-') r=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	  x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*r;
}
inline void build(int x,int y,int i)
{
	l[i]=x;
	r[i]=y;
	if(x==y) 
	{
		d[i]=p[x];
		return;
	}
	int mid=x+y>>1;
	build(x,mid,i<<1);
	build(mid+1,y,i<<1|1);
	d[i]=min(d[i<<1],d[i<<1|1]);
}
inline int query(int x,int y,int i)
{
	if(x<=l[i]&&y>=r[i]) return d[i];
	int mid=l[i]+r[i]>>1;
	if(y<=mid) return query(x,y,i<<1);
	if(x>mid) return query(x,y,i<<1|1);
	return min(query(x,y,i<<1),query(x,y,i<<1|1));
}
int main()
{
	n=read();
	for(re int i=1;i<=n;i++)
		a[i]=read();
	p[1]=a[1];
	for(re int i=1;i<=n;i++)
		p[i]=p[i-1]+a[i];
	build(1,n,1);
	if(d[1]>=0) ans++;//如果前缀和中最小值不小于0的，就说明整个过程中都没有出现小于0的情况，那么方案数加一
	for(re int i=2;i<=n;i++)
	{
		if(query(i,n,1)-p[i-1]<0) continue;
      //把i作为起点自然要减去p[i-1]
		if(p[n]-p[i-1]+query(1,i-1,1)>=0) ans++;
      //报告完后一段后的总和，在在上后一段最小值大于等于0，那么整个过程中就没有小于0的情况，方案数加一
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：_ztyqwq (赞：13)

此题不用单调队列吧……

先用 $ s_i $ 表示 $ \sum_{k=1}^i a_i $（其实就是 $ 1-i $ 的前缀和）

老板不发怒，也就是说老板心情最小值要 $ \geqslant 0 $。

考虑一下从 $ k $ 到 $ n $ 的一段消息，在这一段中老板的心情最小值是 $ \min_{k \leqslant i \leqslant n}(s_i-s_{k-1}) = (\min_{k \leqslant i \leqslant n}s_i)-s_{k-1} $。

那么再考虑从 $ 1 $ 到 $ k-1 $ 的一段消息，在这一段中老板的心情最小值是 $ \min_{1 \leqslant i \leqslant k-1}(s_i+s_n-s_{k-1}) = (\min_{1 \leqslant i \leqslant k-1}s_i) + s_n - s_{k-1} $

所以对于每一个 $ k $，我们只要维护 $ \min_{1 \leqslant i \leqslant k}s_i $ 和 $ \min_{k \leqslant i \leqslant n}s_i $ 就可以 $ O(1) $ 求出每个 $ k $ 的答案了。再加上枚举 $ k $ 的时间，总时间复杂度是 $ O(n) $，即可AC。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll s[1000001],m[1000002][2];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        ll a;
        scanf("%lld",&a);
        s[i]=s[i-1]+a;
    }
    m[0][0]=m[n+1][1]=LONG_LONG_MAX>>1;
    for(int i=1;i<=n;i++)
        m[i][0]=min(m[i-1][0],s[i]);
    for(int i=n;i>=1;i--)
        m[i][1]=min(m[i+1][1],s[i]);
    int ans=0;
    for(int i=1;i<=n;i++)
        if(m[i-1][0]+(s[n]-s[i-1])>=0&&m[i][1]-s[i-1]>=0)
            ans++;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：pipiispig (赞：10)

###震惊，一道单调队列好题就这样被浪费掉了？翻了半天题解结果发现用单调队列的没几个，极度悲哀，这道题用stl的双端队列一会就水过去了QWQ(STL大法好！！！嘿嘿）
##补上一个双端队列的题解吧
```#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<deque>
#include<stack>
using namespace std;
inline int read(){
	int f=1,x=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return f*x;
}//用处不大的快读
inline void write(int x){
	int s[50],p=0;
	if(x<'0'){putchar('-');x=-x;}
	do{s[p++]=x%10;x/=10;}while(x);
	for(int i=p-1;i>=0;i--)putchar(s[i]+'0');
	putchar('\n');
}//没用到的快输
int s[1000001],ans[1000001],f[2000002];
int main(){
	int n=read();
	for(int i=1;i<=n;i++){
		s[i]=read();
		s[n+i]=s[i];
		f[i]=f[i-1]+s[i];//求前缀和~
	}
	for(int i=n+1;i<=n+n-1;i++){
		f[i]=f[i-1]+s[i];//这里我们可以把环转化链，就相当于把两个剪断的环接起来
	}
	deque<int>d;//方便的STL双端队列！！！
	d.push_back(1);
	for(int i=2;i<=2*n-1;i++){
		while(!d.empty()&&f[i]<f[d.back()])d.pop_back();d.push_back(i);
		while(!d.empty()&&i-d.front()>n)d.pop_front();
		if(i>=n)ans[i]=f[d.front()]-f[i-n];
	}//f[d.front()]-f[i-n]这里可能不大好明白QWQ,仔细想想，其实这就是运用了前缀和，也就是这个点和起点中间所有数的和?不大会说呢，仔细理解一下吧。
	int maxn=0;
	for(int i=n;i<=2*n-1;i++){
		if(ans[i]>=0)maxn++;
	}
	cout<<maxn<<endl;
}```
##话说为什么用STL的人那么少呀

---

## 作者：Mizuhara (赞：8)

主思想就是对每个$k$，判断是否可行。

(1):

对于每个$k$，首先判断$a[k],a[k+1],...,a[n]$是否满足。

考虑到可以递推，将$k$从$n$到$1$循环，

用$f[k]$表示$s[k],s[k+1],...,s[n]$的最小值

（$s[i]=a[k]+a[k+1]+...+a[i],i=k,k+1,...,n$）

则易得$f[k]=min(a[k],a[k]+f[k+1])$

那么得到了$f[k]$，只需判断$f[k]$是否不小于$0$即可。

(2):

后半部分对于$a[1],a[2],...,a[n]$的判断则更加简单。

预处理$mis[i]=min(s[1],s[2],...,s[i])$，$i=1,2,...,n$

其中$s[k]=a[1]+a[2]+...+a[k],k=1,2,...,n$

那么只要判断$mis[k]+a[k]+a[k+1]+...+a[n]$是否不小于$0$即

可。

总复杂度$O(n)$


```

#include<iostream>
#include<cstdio>
int read();
#define maxn 1000010
#define miin(a,b) ((a)<(b)?(a):(b))
using namespace std;

int n;
int a[maxn],s[maxn],mis[maxn];
int main(){
    n=read();
    mis[0]=2000000000;
    for(int i=1;i<=n;i++){
        a[i]=read();
        s[i]=s[i-1]+a[i];
        mis[i]=miin(mis[i-1],s[i]);
    }mis[0]=0;
    int no=0,Ans=0;
    for(int k=n;k>=1;k--){
        no=miin(a[k],no+a[k]);
        if(no>=0&&mis[k-1]+s[n]-s[k-1]>=0)Ans++;
    }
    cout<<Ans;
    return 0;
}
int read(){
    int s=0,k=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')k=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*k;
}
```

单调队列做法待补完（给自己讲的，请忽略此句）

---

## 作者：RedreamMer (赞：5)

# P2629题解

算法：$ST$ 表、前缀和

[（请先自学ST表）](https://zhouziheng666.blog.luogu.org/qian-tan-st-biao)

看到很多人用队列做，我觉得这是一道　$ST$ 表的好题（刚学 $ST$ 表 $QAQ$ ）

其实此题的重点就是在枚举 $k$ 的时候怎样去判断这个k是否满足题目要求：若最小值满足了题目要求，那么其它比它大的值也肯定满足了，则这个 $k$ 也是合法了

首先用前缀和 $(s[i])$ 维护前i条信息的心情和 $(i\in[1,n])$ ,然后再用 $ST$ 表 $ (m[i][j])$ 维护 $min(s[k])$ $(k\in[k,k+(1<<j)-1])$，两者时间复杂度 $O(n$ $log_2$ $n)$ ,空间复杂度是 $O(n$ $log_2$ $n)$ 

接着查询，总所周知 $ST$ 表查询一段的时间复杂度为 $O(1)$ ，然后我们可以顺序枚举 $k$ 

判断k到n是否有负数：$if(query(k,a)-s[k-1]>=0)$

判断1到k-1是否有负数：$if(query(1,i-1)+s[a]-s[i-1]>=0)$

~~感性理解一下以上内容QAQ~~


------------


### code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,som;
int s[1000001],m[1000001][21];
inline int r() {//快读 
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int query(int n,int l){//求区间最小值 
	int p=log2(l-n+1);
	return min(m[n][p],m[l-(1<<p)+1][p]);
}
int main() {
	a=r();
	memset(m,0x7f,sizeof(m));//初始化为inf 
	for(int i=1; i<=a; i++) {
		s[i]=r();
		s[i]+=s[i-1];//前缀和维护 
		m[i][0]=s[i];
	}
	for(int i=1; (1<<i)<=a; i++)
		for(int j=1; j+(1<<i)-1<=a; j++)
			m[j][i]=min(m[j][i-1],m[j+(1<<(i-1))][i-1]);//ST表维护 
	if(query(1,a)>=0)//特判k是否合法 
	som++;
	for(int i=2; i<=a; i++) {
		if(query(i,a)-s[i-1]>=0)//判断k是否合法 
			if(query(1,i-1)+s[a]-s[i-1]>=0)//判断k是否合法 
				som++;
	}
	cout<<som;
	return 0;
}
```
[$\color{blue}\text{My Blog}$](https://www.luogu.org/blog/184549/)

---

## 作者：LJB00131 (赞：4)

思路：对于每个点找前一段最小值， 与后面的和判断一下是不是会变成负数即可，其他题解已经讲解得很清楚。但是如果用线段树实现则要$O(nlogn)$复杂度，使用st表就可以达到$O(n)$复杂度。

Code：

```cpp
#include<bits/stdc++.h>

using namespace std;

#define N 1000005

int n, f[N], ans = 0;

int st[N][21], lg[N];

int query(int x, int y)
{
	int k = lg[y - x + 1];
	return min(st[x][k], st[y - (1 << k) + 1][k]);
}

int main()
{
	scanf("%d", &n);
	bool flag = 1;
	for(int i = 1; i <= n; i++)
	{
		int x;
		scanf("%d", &x);
		f[i] = f[i - 1] + x;
		if(f[i] < 0) flag = 0;
		st[i][0] = f[i];
	}
	lg[0] = -1;
	for(int i = 1; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for(int j = 1; j <= 20; j++)
		for(int i = 1; i <= n - (1 << j) + 1; i++)
		{
			st[i][j] = min(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
		}
	if(flag) ans++;
	for(int i = 2; i <= n; i++)
	{
		if(query(i, n) - f[i - 1] < 0) continue;
		int k = query(1, i - 1);
		if(f[n] - f[i - 1] + k >= 0) ans++;
		// cout << k << ' ' << f[n] - f[i - 1] << endl;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Treaker (赞：3)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# ST表
先处理一下前缀和，再对前缀和$O(nlogn)$预处理区间最小值。

查询时，看k到n的最小值减去这个点的前缀和，如果小于0的话就不行。

再看前半部分的最小值加上后面的全部值，如果小于0就不行。。

就这样统计即可。。。

### 完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 1000100;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , ans;
int log[N] , sum[N] , f[N][23];
int main()
{
	n = read();
	for(int i = 1;i <= n;i ++)	
	{
		if(i == 1)	log[i] = 0;
		else log[i] = log[i >> 1] + 1; 
		sum[i] = sum[i-1] + read();
		f[i][0] = sum[i];
	}
	for(int i = 1;i <= 20;i ++)	for(int j = 1;j + (1 << i) - 1 <= n;j ++) 	f[j][i] = min(f[j][i-1],f[j + (1 << (i-1))][i-1]);
	for(int i = 1;i <= n;i ++)
	{
		int lg = log[n - i + 1];
		int tmp = min(f[i][lg],f[n - (1 << lg) + 1][lg]);
		if(tmp - sum[i-1] < 0)	continue;
		lg = log[i];
		int res = min(f[1][lg],f[i-(1 << lg)][lg]);
		if(sum[n] - sum[i-1] + res < 0)	continue;
		ans ++;
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：Seanq (赞：3)

**P2629 好消息，坏消息题解**  
单调队列？  
最大最小值！  
m[i]表示前i个前缀和的最小值  
f[i]表示后i个前缀和的最小值  
然后就好了  
std:  
```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
#include <cctype>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define frep(i,x,y) for(int i=x;i>=y;i--)
#define ll long long
#define INF 214748364746384
const int N=1000005;
int n;
ll a[N];
ll s[N];
ll m[N];
ll f[N];
ll ans=0;
int main()
{
	scanf("%d",&n);
	rep(i,1,n) scanf("%lld",&a[i]);
	rep(i,1,n) s[i]=s[i-1]+a[i];
	m[0]=INF;
	rep(i,1,n) m[i]=min(m[i-1],s[i]);
	f[n+1]=INF;
	frep(i,n,1) f[i]=min(f[i+1],s[i]);
	rep(i,1,n) 
		if((f[i]-s[i-1]>=0)&&(m[i-1]+s[n]-s[i-1]>=0))
			ans++;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Ice_teapoy (赞：2)

单调队列找规律什么的方法都没想到，用了种比较奇怪的方法水过了这道题。

对于每一个数a[k]，先预处理出从k~n是否能走和从1~k是否能走。

####过程：

**1.判断1~k是否能走，即判断Σi=k~n a[i]和min{a[1],a[1]+a[2],a[1]+a[2]+a[3],…,Σi=1~k a[i]}的相反数之间的大小关系。**

**2.判断k~n是否能走，即判断Σi=k~n a[i]过程中是否出现过负数。**

**3.对于任一满足1.2.两个条件的元素，对答案贡献为1。**

```cpp
    //判断1~k是否能走
    //求min{a[1],a[1]+a[2],a[1]+a[2]+a[3],…,Σi=1~k a[i]}
    for (int i=1;i<=n;++i)
    {
        sum-=a[i];
        f[i]=max(sum,f[i-1]);
    }
    //前缀和计算Σi=k~n a[i]
    //判断
```
```cpp
    //判断k~n是否能走
    //sum表示如需将i作为k点，需要另外支付的内容
    for (int i=n;i>=1;--i)
    {
        sum=max(sum-a[i],0-a[i]);
        if (sum<=0) g[i]=1;
    }
```
####O(n)求1.2.：

完整代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[1000001],f[1000001];
bool g[1000001];
int main()
{
    int n,sum=0;
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
    {
        scanf("%d",&a[i]);
        sum-=a[i];
        f[i]=max(sum,f[i-1]);
    }
    sum=0;
    for (int i=n;i>=1;--i)
    {
        sum=max(sum-a[i],0-a[i]);
        if (sum<=0) g[i]=1;
    }
    for (int i=1;i<=n;++i) a[i]+=a[i-1];
    int ans=0;
    for (int i=1;i<=n;++i)
        if (g[i]&a[n]-a[i-1]>=f[i-1]) ans++;
    printf("%d",ans);
}
```

---

## 作者：奔波儿霸 (赞：2)

#### 解题思路
先$\Theta(n)$预处理一个前缀和，存储到$sum$数组中。接下来我们考虑$\Theta(n)$枚举$k$，判断$k$是否可行，那么为了尽量做到更优的时间复杂度，所以希望最好能够$\Theta(1)$的进行判断。

数据范围$10^6$啊，不这样肯定凉凉啊。考虑将前$k-1$项移到后面去会对整个序列造成什么样的影响。很显然，后面的$k$项每一项都要减去$sum[k-1]$。那么减去后只需要判断后面的$k$项有没有出现负数，如果出现了负数，那自然是不行的。又因为我们减的时候是对后面的整个区间都减了，所以为了减小时间复杂度，我们去维护一个区间最小值，当然只需要维护从$n$到每一项的区间最小值。

再考虑挪到后面的$k-1$项发生了什么变化，我们发现后面的$k-1$项的$sum$的每一项都减去了变化后的第$n$项的前缀和。同样这里也去维护一个从$1$到每一项的区间最小值。

要想这个$k$满足条件，需要变化后的两个部分中的最小值全都大于$0$。所以思路就是这样的。

#### 附上代码
~~可能有些丑~~
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define int long long
using namespace std;
const int maxn = 1e6+3, INF = 2147483647;
int n, mnum_1[maxn], mnum_2[maxn], sum[maxn], arr, Ans;
inline int read() {
	int x = 0, f = 1; char c = getchar();
	while (c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while (c <= '9' && c >= '0') {x = x*10 + c-'0'; c = getchar();}
	return x * f;
}
main() {
	n = read();
	for(int i=1; i<=n; i++) {
		arr = read();
		sum[i] = sum[i-1] + arr;
	}
	mnum_1[0] = INF, mnum_2[n+1] = INF;
	for(int i=1; i<=n; i++)
		mnum_1[i] = min(mnum_1[i-1], sum[i]);
	for(int i=n; i>=1; i--)
		mnum_2[i] = min(mnum_2[i+1], sum[i]);
	for(int i=1; i<=n; i++) {
		if(mnum_2[i]-sum[i-1] >= 0 && mnum_1[i-1]+(sum[n]-sum[i-1]) >= 0)
			Ans ++;
	}
	printf("%lld", Ans);
}
```

---

## 作者：shadowice1984 (赞：2)

来一发楼下兄弟没想到的单调队列做法。

这道题其实是预处理难想，单调队列还是很简单的

我是通过找规律做出来的

首先这是样例。

-3 5 1 2

然后这是样例和样例的前缀和

-3 5 1 2

-3 2 3 5

然后这是样例和所有倒叙的可能前缀和（显然这不就是破环为列嘛）

-3 5 1 2

-3 2 3 5

5 6 8 5

1 3 0 5

2-1 4 5

然后我们发现，这个方阵除第一行，最后一列以外

每个数都等于右上角的数减去上一行第一个数。

现在是见证奇迹的时刻！如果我们认为最后一列也满足这个规律，而不是简单的等于上一个数呢？

那显然需要构造一些数了，构造后的方阵如下

-3 5 1 2

-3 2 3 5 2 7 8

5 6 8 5 1011

1 3 0 5 6

2 -14 5

然后我们发现，如果在第一行取一个长度为n的区间

那么d[t]-d[t+i]（t为区间的起点)就是第t+1行第i-1个数的值！

（因为第n个永远是正的，不管它）

也就是说，每一个长度为n且起点为最小值的区间，就对应一个方案。

最小值好办，单调队列O(n)扫一遍搞定。

那么如何生成第一行？

根据我们构造的原理（或者找规律）有：

d[i]=d[i-n]+d[n]

然后就可以做啦~

上代码~

```cpp
#include<stdio.h>
int n;
int sum[2000020];
struct data 
{
    int n;int v;
}q[2000020];//数组是两倍！两倍！
int head=1;int tail=0;//手写队列部分~
inline void push(data x)
{
    //printf("push(%d,%d)\n",x.v,x.n);
    q[++tail]=x;return;
}
inline void pop()
{
    if(head<=tail)head++;
    return;
}
inline void pot()
{
    if(head<=tail)tail--;
    return;
}
inline bool empty()
{
    if(head>tail)
    {
        head=1;tail=0;
        return true;    
    }
    else return false;
}
int res;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sum[i]);
        sum[i]+=sum[i-1];//处理前缀和
    }
    for(int i=n+1;i<2*n;i++)
    {
        sum[i]=sum[i-n]+sum[n];//处理人造前缀和
    }
    for(int i=1;i<2*n;i++)//单调队列模板
    {   
        if(!empty())
        {
            while(1)
            {
                //printf("tail.v=%d\n",q[tail].v);
                if(q[tail].v>sum[i])
                {
                    pot();if(empty())break;
                }
                else if(q[tail].v<=sum[i])
                {
                    data p;p.v=sum[i]; p.n=i;
                    push(p);break;
                }
            }
        }
        if(empty())
        {
            data p;p.v=sum[i];p.n=i;
            push(p);
        }
        /*printf("sum[%d]=%d\n",i,sum[i]);
        for(int j=head;j<=tail;j++)
        {
            printf("%d ",q[j].v);
        }printf("\n");
        for(int j=head;j<=tail;j++)
        {
            printf("%d ",q[j].n);
        }printf("\n");*/
        if(q[tail].n-q[head].n==n-1)//如果成功构造出长度为n的区间，答案+1
        {
            res++;pop();
        }
    }
    printf("%d",res);
    return 0;//拜拜程序~
}
```

---

## 作者：B_1168 (赞：1)

# $O(n\sqrt{n})$过百万，臭氧出奇迹！

这道题目如果说略有思维难度，想来也主要集中于前缀和的应用以及其特殊“断点”带来的思维或代码难度；

具体地说，想到“断环为链”的思维难度对缺乏相关经验的OIer来说还是有的，而分别维护两边的则码量稍大一些。

----然而，这题毕竟是绿题！如果是RMQ板子题，也就不是绿题了……

相关的思维难点高赞题解解释的十分清楚，本人不班门弄斧了；然而，本人看到题解里的单调队列就头疼：本萌新只会分块tat

静下心思考一下，一看数据范围，这题的数据范围可是$n\leq 10^6$啊！一般的分块，确定能过？

答案是肯定的！作为~~滥用`fread`和`O(3)优化`的专业户，百万分块，也不是没做过啦~~~

话不多说，放代码：

```cpp
//省略优化指令，可以在文末剪贴板链接中获取（就是不想让你直接抄）
#include<bits/stdc++.h>
#define maxn 2000001 //断环为链，范围加倍
using namespace std;

int n,m,ans,len,a[maxn],val[maxn],be[maxn];

inline char nc(){ //fread()大法，卡常必备
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}

inline int read(){
	int x=0,f=1;char ch=nc();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=nc();}
	while (isdigit(ch)){x=x*10+ch-48;ch=nc();}
	return x*f;
}

inline int query(int from,int to){ //分块区间RMQ模板
    int cnt=(1<<30);
    for(register int i=from;i<=min(to,be[from]*len);i++) cnt=min(cnt,a[i]);
    if(be[from]!=be[to]){
        for(register int i=(be[to]-1)*len+1;i<=to;i++) cnt=min(cnt,a[i]);
    }
    for(register int i=be[from]+1;i<=be[to]-1;i++) cnt=min(cnt,val[i]);
    return cnt;
}

int main(){
    n=read();
    memset(val,0x7f7f7f,sizeof(val)); //先压上极大值
    len=sqrt(2*n); //有趣的是，块长设为sqrt(n)和sqrt(n)/2对程序速度似乎毫无影响
    for(register int i=1;i<=2*n;i++)be[i]=(i-1)/len+1;
    for(register int i=1,k;i<=n;i++){
    	k=read();
    	a[i]=k+a[i-1];
    	a[i+n]=k; //断环为链第二步
    	val[be[i]]=min(val[be[i]],a[i]);
    }
    for(register int i=n+1;i<=2*n;i++) {
    	a[i]+=a[i-1]; //前缀和的制备
    	val[be[i]]=min(val[be[i]],a[i]);
    }
//	for(int i=1;i<=2*n;i++) printf("%d ",a[i]);
	for(register int i=1;i<=n;i++){
        if(query(i,i+n-1)-a[i-1]>=0)ans++; //查询
    }
    printf("%d\n",ans);
}
```

P.S.:
- [优化指令链接](https://www.luogu.com.cn/paste/fhiymawc)
- ~~最大的5个点都卡了600ms以上，虽然百万能过，再大也确实力不从心……~~
- 感谢管理审核，欢迎点赞qwq


---

## 作者：Peanut_Tang (赞：1)

翻译一波题目：给一个序列a[1…n]，问有多少个k，使当序列变为：a[k],a[k+1],…,a[n],a[1],a[2],…,a[k-1]时，其前缀和的最小值>=0。

肯定是要用前缀和的啦。~~（直觉？？！！）~~  
sum[i]表示原序列的前缀和。

当k=m时，把序列分成[1,m-1],[m,n]考虑：

由题目：         
显然每个sum[i]-sum[m] (m<=i<=n)必须>=0，
而且每个sum[i]+sum[n]-sum[m] (1<=i<m)必须>=0。

那么，对于每个m，都暴力按上面方法判断一遍。

if 符合 ans++;     
复杂度是O(n^2)的。

考虑优化，

其实不用都枚举过去，如果最小值满足，那么就满足了。

用Mq[i]表示1<=i<m中sum数组的最小值，Mh[i]表示m<=i<=n中sum数组的最小值。

则对于每个m，只要满足Mh[m]-sum[m]>=0&&Mq[m]+sum[n]-sum[m]>=0，则ans++。

复杂度O(n)，完美通过。

Code:
```cpp
#include <cstdio>
#define INF (1e10)
#define il inline
using namespace std;

int n,ans;
int a[1000001];
int Mq[1000001],Mh[1000001],sum[1000001];

il int read()
{
	int res=0,sign=1;
	char c;
	
	while ((c=getchar())<'0'||c>'9') if (c=='-') sign=-1;
	
	res=c-'0';
	while ((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
	
	return res*sign; 
} 

il int Min(int x,int y)
{
	return x>y?y:x;
}

int main()
{
    n=read();
    int i;
    
    Mq[0]=INF;
    for (i=1; i<=n; i++)
    {
    	a[i]=read();
    	sum[i]=sum[i-1]+a[i],
    	Mq[i]=Min(Mq[i-1],sum[i]);
	}
	
	Mh[n+1]=INF;
	for (i=n; i>=1; i--)
	{
		Mh[i]=Min(Mh[i+1],sum[i]);
	}
	
	for (i=1; i<=n; i++)
	{
		if (Mh[i]-sum[i]>=0&&Mq[i]+sum[n]-sum[i]>=0) ans++;
	}
	
	printf("%d",ans);
    
	return 0;
}

```


拒绝Ctrl C+Ctrl V！！！！！！

---

## 作者：凯特琳 (赞：1)

本题等价于：n个数据顺序成环，从某点破环，得到所有前缀和非负，求破环点数。


解1：单调队列

对于区间左端点和右端点同时单调的，可以用单调队列求解，本题关注最小元素，维护单增队列









```cpp
 program exam1;
var a:array[1..2000000]of longint;//二倍原数组
var aa:array[0..2000000]of longint;//二倍前缀和
var h,xx:array[0..2000000]of longint;//h单调队列 xx下标域
var i,j,n,m,ans:longint;
var he:longint;
var l,r,jian:longint;
var cheat1,cheat2:boolean;//cheat标记：cheat1是判断数列全正  cheat2是判断数列全负
begin
assign(input,'sum.in');reset(input);
assign(output,'sum.out');rewrite(output);
read(n);
cheat1:=true;
cheat2:=true;
for i:=1 to n do
begin
read(a[i]);
he:=he+a[i];
if a[i]<0 then cheat1:=false;
if a[i]>0 then cheat2:=false;
aa[i]:=aa[i-1]+a[i];
end;
if cheat1 then
writeln(n)
else if cheat2 or (he<0) then
writeln('0')
else
begin//主程序开始
for i:=n+1 to 2*n-1 do
a[i]:=a[i-n];//加倍数据
for i:=n+1 to 2*n-1 do
aa[i]:=aa[i-1]+a[i];//前缀和
l:=1;
r:=1;
h[1]:=aa[1];
xx[1]:=1;
for i:=2 to n do
if aa[i]>h[r] then
begin
inc(r);
h[r]:=aa[i];
xx[r]:=i;
end
else
begin
while (h[r]>=aa[i])and(r>=l) do
dec(r);
inc(r);
h[r]:=aa[i];
xx[r]:=i;
end;//初始化让1..n入队
jian:=0;
if h[l]>=0 then
inc(ans);//判断初始序列
for i:=1 to n-1 do
begin
jian:=jian-a[i];//jian标记
if aa[i+n]>h[r] then//新元素入队
begin
inc(r);
h[r]:=aa[i+n];
xx[r]:=i+n;
end
else
begin
while (h[r]>=aa[i+n])and(l<=r) do dec(r);
inc(r);
h[r]:=aa[i+n];
xx[r]:=i+n;
end;
if xx[l]<i+1 then inc(l);//判断队头合法性
if h[l]+jian>=0 then//判断数列合法性，统计答案
inc(ans);
end;
writeln(ans);
end;
close(input);
close(output);
end.
```
解2：吞噬算法：
这个有必要说明一下：这是团结乱搞出来的算法，也算是烟台一中年度原创算法之一的。

意思就是  如果出现了负数，那么他前面一定要有一些整数的部分来满足他的胃口，于是，每一个负数就和他前面的若干个数组成结合体，序列头不可能出现在结合体的内部，一定出现在结合体的外部，于是按照这个思路j进行非法数据的合并，得到了若干个合法数据。

这时的答案就是合法数据的个数。

代码：



```cpp
var n,s,i:longint;
a:array[1..1000005] of integer;
b:array[1..1000005] of longint;
begin
assign(input,'sum.in'); assign(output,'sum.out');
reset(input); rewrite(output);
readln(n);
for i:=1 to n do read(a[i]);
i:=0;
while i<n do
begin inc(i);
inc(s);
b[s]:=a[i];
if a[i]<0 then
begin
while (b[s]<0) and (s>1) do
begin
dec(s);
b[s]:=b[s]+b[s+1];
b[s+1]:=0;
end;
while b[s]<0 do
begin
b[s]:=b[s]+a[n];
dec(n);
if n<i then
begin
writeln(0);
close(input);
close(output);
end;
end;
end
end;
writeln(s);
close(input);
close(output);
end.
```
是不是很神奇？


---

## 作者：wxy2005 (赞：0)

## 期中考试之后做的第一道题，写篇题解纪念一下

### 看到诸位大佬都在用单调队列，作为蒟蒻的我蹲在角落里瑟瑟发抖

### 为了不使用单调队列，我们可以用动态的思想来想一下这道题


------------
### 首先来分析复杂度

题目的数据范围是 n<=10^6 算一下log10^6大概是20左右，~~又考虑到洛谷评测机比较快~~ nlogn的算法是可以支持的。

那么也就是说~~可以排序搞事情~~

我们知道我们一定要枚举k的位置，枚举的复杂度是O(n),因此判断的复杂度应当是O(1)~O(logn)


------------

### 下面是思路

判断k的一个位置合不合法，只用判断两件事情：

1.k往右的所有时刻值都大于零

2.k左边的所有时刻值都大于零

因此我们只需要找出两个值，一个是左边时刻最小值，一个是右边时刻最小值，如果它们都大于零，那么这个k就一定是合法的。

先考虑左边，左边每一个时刻老板的心情值=右边结束时刻老板的心情值+若从头开始讲，讲到该时刻老板的心情值（即到该消息的前缀和）
对于一个固定的k右边结束时刻老板的心情值是固定的，该消息前缀和最小时，老板的心情值最小（自己画画图，虽然我讲的很绕，但其实很简单）

右边某一时刻心情值=该时刻的前缀和-k的前缀和，而对于每一个固定的k，它的前缀和是固定的，因此当该时刻的前缀和最小时，老板的心情值最差。

左边的前缀和最小的点可以用个min来存一下，从而实现O(1)求出嘴边老板心情最坏值。

右边就比较难办，因为左边元素是增加的，右边元素是减少的。

一个直观的想法是用堆来查询最小值，但是这样不仅速度慢，而且难写。

我们可以想：如果一个元素退出了右边元素集合，那么它永远不会再被加进去了，因此我们只用排序，从第往高走就行了，这样总复杂度是O(n)。


------------

### 最后附高清无注释代码一份

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<stdlib.h>
#include<algorithm>
#include<cstring>
#include<vector>
#define MAXN 1000005 
using namespace std;
int a[MAXN],n,b[MAXN];
struct Che{
	int va,rk;
}che[MAXN];
bool cmp(Che A, Che B)
{
	return A.va<B.va;
}
int ans=0,bmp,fm;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		b[i]=a[i]+b[i-1];
		che[i].va=b[i];
		che[i].rk=i;
	}
	sort(che+1,che+1+n,cmp);
	bmp=1;
	if(che[1].va>=0)
		ans++;
	for(int i=2;i<=n;i++)
	{
		while(che[bmp].rk<i) bmp++;
		fm=min(fm,b[i-1]);
		if(che[bmp].va-b[i-1]>=0&&b[n]-b[i-1]+fm>=0)
		ans++;
	}
	printf("%d",ans);
    return 0;
}

```




---

## 作者：DEVILK (赞：0)

更好的阅读体验点这里：[博客传送门](https://www.cnblogs.com/devilk-sjj/p/9078732.html)

## 利用st表进行优化时间复杂度$O(n)$

[算法分析：]

对于要判断区间$[l,\ r]$内在某一时刻的和是否为负值，只需要看从$[l,\ r]$的**前缀和序列**的值是否为负.

（这道题是要求对于一个点$i$，判断$[i,\ n]$和$[1,\ i-1]$中某一时刻的前缀和是否存在负值）

那怎样快速地求出这个前缀和序列并判断是否有负值呢？

~~枚举的方法显然并不高效，反而和直接模拟的复杂度一样了，抛掉~~

判断是否有负值，可以找到一个标准，只要这个标准非负，那整个序列也就没有负值了

显然的，标准应选为$[l,\ r]$的**前缀和序列**的最小值，便可以使用st表或者线段树来快速查询.

那又应该如何求出$[l,\ r]$的**前缀和序列**呢？每次求一遍？显然复杂度会降到约为$O(n^3)$

对于一个序列$a$，$[1,\ r]$的**前缀和序列**的最小值再减去$[1,\ l - 1]$的元素和，即为$[l,\ r]$的**前缀和序列**最小值 

即：$$min\{\sum_{j = l}^{r}\sum_{i = l}^{j} a_i\} = min\{\sum_{j = 1}^{r}\sum_{i = 1}^{j} a_i\} - \sum_{i = 1}^{l - 1}a_i$$

所以当我们根据序列$a$求出$[l,\ r]$的前缀和序列sum时，使用st表维护这个序列sum的最小值，

就可以做到$O(1)$查询$min\{\sum_{j = l}^{r}\sum_{i = l}^{j} a_i\}$

预处理复杂度$O(nlog_2n)$，算法主体的时间复杂度为$O(n)$

而使用线段树也可以维护最小值，根据**前缀和序列**建树，预处理$O(n)$，算法主体复杂度为$O(nlog_2n)$，和st表差不多。

~~（但是实测好像st表跑的慢一些）~~

也可以使用单调队列来求最值，复杂度应该是$O(n)$，比st表和线段树都要快，~~但是我不会QwQ~~

[使用st表的$Code:$]

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;

const int MAXN = 1e6 + 1;
const int K = 20 + 1;

int n;
int a[MAXN], sum[MAXN];
int st[MAXN][K], Log2[MAXN];

inline int read() {
    int x=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(ch>='0' && ch<='9')
        x=(x<<3)+(x<<1)+ch-48, ch=getchar();
    return x * f;
}

inline int Query(int l, int r) {
    int x = Log2[r - l + 1];
    return min(st[l][x], st[r-(1<<x)+1][x]);
}

int main() {
    n = read();
    for(int i=1; i<=n; ++i) a[i] = read();
    for(int i=1; i<=n; ++i)
        st[i][0] = sum[i] = sum[i-1] + a[i];
    for(int j=1; j<=K; ++j)
        for(int i=1; i+(1<<j)-1<=n; ++i)
            st[i][j] = min(st[i][j-1], st[i+(1<<(j-1))][j-1]);
    for(int i=0; (1<<i)<=n; ++i) Log2[1<<i] = i;
    for(int i=1; i<=n; ++i)
        if(!Log2[i]) Log2[i] = Log2[i-1];
    int ans = 0;
    for(int i=1; i<=n; ++i) {
        if(Query(i, n)-sum[i-1] < 0) continue;
        if(Query(1, i-1) + sum[n] - sum[i-1] >= 0) ++ans;
    }
    printf("%d\n", ans);
}
```

---

## 作者：UIai (赞：0)

orz楼下的O（N）算法，本蒟蒻这里介绍个简单易懂的O（nlogn）算法，首先破环为链，然后用ST算法（参考训练指南）维护前缀和数组的区间最小值，对每个[i,i+n-1] (1<=i<=n)区间最小值减去前缀和的开头的值比较与0的大小。。。然后就MLE了。。。

不过由于我们观察到只要查询区间长度为n的最小值，，可用滚动数组优化，然后就AC了

```cpp
#include<cstdio>
#include<iostream>
#define maxn 1000010
int sum[2*maxn],d[2*maxn][2],n;
void ST()//ST算法 
{
    for(int i=1;i<=2*n;i++)
        d[i][0]=sum[i];
    for(int j=1;(1<<j)<=n;j++)
        for(int i=1;i+(1<<j)<=2*n;i++)
            d[i][j%2]=std::min(d[i][j%2^1],d[i+(1<<j-1)][j%2^1]);//滚动数组优化 
}
int main()
{
    int a;
    int k=0;
    scanf("%d",&n);
    sum[0]=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        sum[i]=sum[i-1]+a;
    }
    for(int i=n+1;i<=2*n;i++)
        sum[i]=sum[i-1]+sum[i-n]-sum[i-n-1];//破成链后对前缀和数组的处理 
    ST();
    int count(0);
    while((1<<k+1)<=n) k++;
    for(int i=1;i<=n;i++)
        if(std::min(d[i][k%2],d[i+n-(1<<k)][k%2])-sum[i-1]>=0)//前面那段是ST算法的查询操作 
            count++;
    printf("%d",count);
    return 0;
}
```

---

## 作者：litble (赞：0)

先orz楼下的所有大佬，然后讲讲蒟蒻的做法。

本蒟蒻是为了练手单调队列才来做这题的，结果单调队列的做法没想出来，用一种神奇的解法水了。。。

首先我们预处理从1到i的所有前缀和里的最小值，然后处理i到n的前缀和最小值和i到n的总和，假如对于某个i,i到n的前缀和最小值大于0，且i到n的和+1到i-1前缀和里的最小值>=0，我们就可以从i开始倒叙.

处理从i到n的前缀和最小值的方法：mi[i]=min(a[i],a[i]+mi[i+1]);

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int q=0,w=1;char ch=' ';
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return q*w;
}
const int N=1000005;
int n,a[N],sum[N],qmi[N],hmi[N],ans;
int main()
{
    int i,j;int kl;
    n=read();kl=0;qmi[0]=INT_MAX;
    for(i=1;i<=n;i++){//处理1到i前缀和最小值
        a[i]=read();kl+=a[i];
        qmi[i]=min(qmi[i-1],kl);
    }
    hmi[n]=a[n];sum[n]=a[n];
    for(i=n-1;i>=1;i--){//处理i到n前缀和最小值
        hmi[i]=min(a[i],a[i]+hmi[i+1]);
        sum[i]=sum[i+1]+a[i];
    }
    qmi[0]=0;
    for(i=1;i<=n;i++)
        if(hmi[i]>=0&&sum[i]+qmi[i-1]>=0)ans++;
    printf("%d",ans);
    return 0;
}
```

---


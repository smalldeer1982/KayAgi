# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# 题解

## 作者：云浅知处 (赞：198)

[更好的阅读体验？](https://www.luogu.com.cn/blog/wwwluogucn/solution-p2671)

注：洛谷博客区表格渲染已经炸掉=\_=，还是在题解区吧QAQ

[$\Huge\mathsf{My\ Blog}$](https://yunqian-qwq.github.io "欢迎光临QAQ")

------------

首先来看这个什么三元组。

>定义一种特殊的三元组：$(x,y,z)$，其中$x,y,z$都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

>1. $x,y,z$ 是整数,$x<y<z,y-x=z-y$；
>2. $x,z$ 颜色相同。

>满足上述条件的三元组的分数规定为 $(x+z) \times (number\_x+number\_z)$。

诶，我们发现，这个「分数」跟 $y$ 之间，半个咕值的关系都没有啊 QAQ？

于是，秒懂![/xyx](https://cdn.luogu.com.cn/upload/pic/62230.png)：

$$\because y-x=z-y$$

$$\therefore x+z=2y$$

又，$2y$ 是偶数，所以 $x,z$ 同奇偶。

这就是 $y$ 的用处啦QAQ。

------------

由于不同颜色的 $x,z$ 肯定不会产生分数，所以我们可以先把这个「狭长的纸带」按照颜色分类，最后把每种颜色产生的分数加起来即可。

然后不同奇偶性的 $x,z$ 也不会产生分数，所以把每个颜色种类按照奇偶性再分个类，最后把奇数产生的分数和偶数产生的分数加起来即可。

举个例子：

| 格子编号 | 1 | 2 | 3 | 4 | 5 | 6 |7|8|9|10|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 格子上的数字 | 5 | 5 | 3 | 2 | 2 | 2 |7|8|2|5|
| 格子颜色 | 2 | 2 | 1 | 1 | 2 | 1 |2|2|2|1|


那么先按照颜色分类：

颜色为 $1$ 的：

| 格子编号 | 3 | 4 | 6 |10|
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 格子上的数字 | 3 | 2 | 2 |5|
| 格子颜色 | 1 | 1 | 1 |1|


颜色为 $2$ 的：

| 格子编号 | 1 | 2 | 5 |7|8|9|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 格子上的数字 | 5 | 5 | 2 |7|8|2|
| 格子颜色 | 2 | 2 | 2 |2|2|2|

再按照编号分类：

颜色为 $1$ ，编号为奇数的：

| 格子编号 | 3 |
| :----------: | :----------: |
| 格子上的数字 | 3 |
| 格子颜色 | 1 |

颜色为 $1$ ，编号为偶数的：

| 格子编号  | 4 | 6 |10|
| :----------: | :----------: | :----------: | :----------: |
| 格子上的数字 | 2 | 2 |5|
| 格子颜色 | 1 | 1 |1|

颜色为 $2$ ，编号为奇数的：

| 格子编号 | 1 | 5 |7|9|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 格子上的数字 | 5 | 2 |7|2|
| 格子颜色 | 2 | 2 |2|2|

颜色为 $2$ ，编号为偶数的：

| 格子编号 | 2 |8|
| :----------: | :----------: | :----------: |
| 格子上的数字 | 5 |8|
| 格子颜色 | 2 |2|

好的，分类完毕！

那么，怎么计算分数呢？

------------

当然可以 $O(n^2)$ 暴力算一通。做法显然，这里不多说了。

不过，复杂度铁定爆炸。

考虑更优的做法。

拿上面那个例子中，颜色为 $2$ ，编号为奇数的 $4$ 个格子来举个例子：

由于颜色显然是一样的，而且计算分数也和颜色无关，所以就不用再管颜色了。

然后设 $f[i]$ 为这一组中第 $i$ 个数的编号，$n[i]$ 为这一组中第 $i$ 的数的颜色。

|$i$|$1$|$2$|$3$|$4$|
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $f[i]$ | 1 | 5 |7|9|
| $n[i]$ | 5 | 2 |7|2|

先看前两个数，他们产生的分数为：

$$(f[1]+f[2])\times(n[1]+n[2])$$

然后考虑当第三个数加入时，多出来的分数。

第三个数和第一个数会产生一些分数：

$$(f[1]+f[3])\times(n[1]+n[3])$$

第三个数和第二个数也会产生一些分数：

$$(f[2]+f[3])\times(n[2]+n[3])$$

所以多出来的分数为：

$$
(f[1]+f[3])\times(n[1]+n[3])+(f[2]+f[3])\times(n[2]+n[3])$$

展开后，得到：

$$f[1]\cdot n[1]+f[1]\cdot n[3]+f[3]\cdot n[1]+f[3]\cdot n[3]+f[2]\cdot n[2]+f[2]\cdot n[3]+f[3]\cdot n[2]+f[3]\cdot n[3]
$$

把 $n[3]$ 和 $f[3]$ 提取出来：

$$f[1]\cdot n[1]+\color{red}f[1]\cdot n[3]\color{black}+\color{skyblue}f[3]\cdot n[1]\color{black}+\color{red}f[3]\cdot n[3]\color{black}+f[2]\cdot n[2]+\color{red}f[2]\cdot n[3]\color{black}+\color{skyblue}f[3]\cdot n[2]\color{black}+\color{skyblue}f[3]\cdot n[3]
$$

（标红的是提取出来的 $n[3]$，标蓝的是提取出来的 $f[3]$）

$$n[3]\cdot(f[1]+f[2]+ f[3])+f[3]\cdot(n[1]+n[2]+n[3])+n[1]\cdot f[1]+n[2]\cdot f[2]$$

从这个式子中，我们看出，只需要处理 $f$ 数组，$n$ 数组，还有 $f[i]\cdot n[i]$ 的前缀和即可。

后面也是一个一个添加进来，一样的。

------------

到了这一步之后，代码实现基本已经没有任何难度了=\_=

所以，就不放啦QAQ。

---

## 作者：Victorique_De_Blois (赞：78)



令$Score_i$表示以$i$为三元组第一个数的得分。

让我们来看看得分公式：
$$Score=(x+z)\cdot (number_x+number_z)$$
由乘法分配率可知:
$$Score=x\cdot number_x+x\cdot number_z+z\cdot number_x+z\cdot number_z$$
我们设可以以$x,y$的形式出现在同一三元组里的集合$\{i\}$

可得集合$\{i\}$的得分为：
$$(i1\cdot num[i1]+i1\cdot num[i2]+i2\cdot num[i1]+i2\cdot num[i3])+(i1\cdot num[i1]+i1\cdot num[i3]+i3\cdot num[i1]+i3\cdot num[i3])+...$$
整理可得:
$$Score_{i_n}=i_n\cdot \sum_{d=1}^nnumber_{i_d}+(n-2)\cdot(i_n\cdot number_{i_n})$$
我们把$i_n$提出来，就得到了如下公式：
$$Score_{i_n}=i_n\cdot[\sum_{d=1}^nnumber_{i_d}+(n-2)\cdot number_{i_n}]$$
再看题目要求：

这个分数可能会很大，你只要输出整个纸带的分数**除以**10,007所得的**余数**即可。

所以我们应该利用同余定理改写这个公式：

记住下面这个恒等式：
$$(\sum_{i=1}^n a_i)(mod\ M)≡\sum_{i=1}^n[a_i (mod\ m)]$$
设$m=10007$,我们有：
$$Score_{i_n}(mod\ m)=i_n(mod\ m)\cdot\{\sum_{d=1}^nnumber_{i_d}+[(n-2)(mod\ m)\cdot number_{i_n}+m](mod\ m)\}$$
由题意得：
$$ans=\sum_{i=1}^nScore_i$$
我们利用前缀和优化这个公式，可将时辅优化到$O(n)$

可能你对集合$\{i\}$的定义还不是很清楚。

特殊三元组$(x,y,z)$满足以下性质：

由题意得：

- $x<y<z$
- $z-y=y-x$
- $color_x=color_z$

为了方便，我们设$y=x+k$则$z=y+k$

则有：
$$2y=x+z→(x+y)(mod\ 2)=0$$
~~那该三元组和y还有什么关系~~

所以我们只要满足$x,z$同奇偶,颜色相同，便确认他们同在集合$\{i\}$

前缀和优化如下：

设$sum[color_i][g]$表示同为颜色$color_i$,$(mod\ 2)=g$的所有数的数字和，即公式中的$\sum_{d=1}^nnumber_{i_d}$

再设$nt[color_i][g]$表示这个集合的个数，即公式中的$n$

一边输入颜色，就可一边累加，然后你就可以AC掉本题了。

完整代码如下：

    #include <cstdio>

    const int N = 100000;
    const int M = 10007;
    int n, m;
    int sum[N + 1][2], nt[N + 1][2];
    int color[N + 1], number[N + 1];
    long long ans = 0;

    int main()
    {
        scanf(" %d %d", &n, &m);
        for(int i = 1; i <= n; i++) {
            scanf("%d", &number[i]);
            number[i] %= M;
        }
        for(int i = 1; i <= n; i++) {
            scanf("%d", &color[i]);
            int c = color[i];
            int g = i % 2;
            nt[c][g]++;
            sum[c][g] += number[i];
            sum[c][g] %= M;
        }
        for(int i = 1; i <= n; i++) {
            int c = color[i];
            int g = i % 2;
            ans += i % M * ((sum[c][g] + (nt[c][g] - 2) % M * number[i] + M) % M);
            ans %= M;
        }
        printf("%lld", ans);
        return 0;
    }

---

## 作者：一叶知秋。 (赞：29)

题解里面都说要用数学？

没必要吧。。。

主要是大家推的式子都好长啊qwq

个人感觉没有必要

------------

废话讲完了，我们来看看题目

首先虽然是要求三元组，但是明显感觉$y$是摆设，要$2y=x+z$肯定要$x$,$z$同奇偶，这个应该很好理解。

所以只需要关注$x$与和它同奇偶且颜色相同的$z$即可

但是这样时间复杂度还是吃不消，我们就需要思考能不能只枚举$x$，然后直接求出所有满足条件的$z$与$x$的分数呢？

我们先抛开其他，就看看求分数的式子：

$(x+z) \times (number\_x+number\_z)$

直接拆开括号，这里没什么讲的，乘法分配律大家都会吧。。。

$x \times number\_x + z \times number\_z + x \times number\_z + number\_x \times z$

可以注意到，$x \times number\_x$与$z \times number\_z$是一样的，都没有与另一个（$x$或$z$）进行任何运算，所以用前缀和维护即可

然后因为枚举$z$时，$x$相当于不变量，所以再求出满足条件的

$\sum number\_z$和$\sum z$即可

但是我们如果要求前缀和内存就会爆炸

怎么办？

想到我们求解的过程可以在求前缀和时同时完成，那样我们就只要记录相同颜色的和（要分奇偶）即可。

代码如下：

```cpp
#include<cstdio>

#define ll long long
#define maxn 111111
#define mod 10007

inline ll read(){
	ll r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r*f;
}

int n,m,num[maxn],col[maxn];

ll ans,s_c[maxn][2][4];//第一维是颜色，第二维是奇偶
//第三维第一个是前面满足条件的个数，第二个是∑z*number_z
//第三个是∑z，第四个是∑number_z
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)num[i]=read()%mod;
	for(int i=1;i<=n;i++)col[i]=read()%mod;
	for(int i=1;i<=n;i++){//记得每一步都取模哦
		(ans+=(s_c[col[i]][i%2][0]*(i%mod)*(num[i]%mod))%mod)%=mod;
		(ans+=s_c[col[i]][i%2][1])%=mod;
		(ans+=((i%mod)*s_c[col[i]][i%2][2])%mod)%=mod;
		(ans+=((num[i]%mod)*s_c[col[i]][i%2][3])%mod)%=mod;
		(s_c[col[i]][i%2][0]+=1)%=mod;
		(s_c[col[i]][i%2][1]+=(i%mod)*(num[i]%mod))%=mod;
		(s_c[col[i]][i%2][2]+=num[i]%mod)%=mod;
		(s_c[col[i]][i%2][3]+=i%mod)%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```

虽然我的题解看似很长，但是其实（也很长）理解起来应该~~通俗易懂~~吧（自己都不信qwq）

---

## 作者：NewbieZZZ (赞：18)

# [NOIp 2015 普及组] 求和 题解

**宇宙安全声明**：本文部分分内容较长，追求严格证明的正解证明过程~~和代码~~的请移步其他题解。

## 前置知识

### 部分分

- 枚举
- 奇偶性判断
- ~~long long~~

### 正解

- 敏锐的观察力
- 推理能力、优化能力
- 前缀和

## 部分分做法

### 期望 $20$ pts

（Just do it）\
暴力枚举每个 $x, y, z$ 组，并检查该三元组是否符合题意。时间复杂度 $\Theta(n^3)$。

### 期望 $40$ pts

题目中提到：

> 1. $x,y,z$ 都是整数，$\bm {x<y<z, y-x=z-y}$。
>    …

整理后得 $z+x=2y$。\
小学知识告诉我们，奇数加奇数得到偶数，偶数加偶数也得到偶数，而奇数加偶数只能得到奇数。即 $x, z$ 奇偶性相同。

所以可以只枚举 $x, z$ 来检查是否符合题意。时间复杂度 $\Theta(n^2)$。

对于这类暴力，使用 `long long` 数据类型，就可以得到 $50$ pts。~~蒟蒻 T3 有 50 分，好耶！~~

### 期望 $60$，~~实则可满分~~

题目中提到：

> 对于第 $5$ 组至第 $6$ 组数据，$1 \le n \le 10^5, 1 \le m \le 10^5$，**且不存在出现次数超过 $20$ 的颜色**；

暗示了：格子与格子间，同颜色的较少。

我们可以从同颜色的格子入手，存储这些同颜色的格子。分奇数偶数两类判断。

定义 $odd_i$ 这个数列表示第 $i$ 种颜色中，奇数的数字的位置（下标）；同理，$even_i$ 表示偶数的情况。

这时，枚举颜色及 $x,z$，代入式子即可。

#### 核心代码

```cpp
#include <bits/extc++.h>
using namespace std;
using ll = long long; // OI 千万条，long long 第一条。

ll n, m, c[100010], v[100010], ans; // 数组不开大，师生两行泪。
vector<ll> odd[100010], even[100010];

int mian(){
    cin.tie(0) -> sync_with_stdio(0);
    cin >> n >> m;
    for(int i=1; i<=n; ++i){
        cin >> v[i];
    }
    for(int i=1; i<=n; ++i){
        cin >> c[i];
    }
    for(int i=1; i<=n; ++i){
        if(i & 1){
            odd[c[i]].push_back(i);
        } else {
            even[c[i]].push_back(i);
        } // 分奇偶两类
    }
    for(int i=1; i<=m; ++i){
        int len = odd[i].size() - 1;
        for(int j=0; j < len; ++j){
            for(int k=j+1; k < len + 1; ++k){ // 奇偶性相同
                ans += (odd[i][j] + odd[i][k]) * (v[odd[i][j]] + v[odd[i][k]]);
                ans %= 10007;
            }
        }
        len = even[i].size() - 1;
        for(int j=0; j < len; ++j){
            for(int k=j+1; k < len + 1; ++k){
                ans += (even[i][j] + even[i][k]) * (v[even[i][j]] + v[even[i][k]]);
                ans %= 10007;
            } // 代入式子中算
        }
    }
    cout << ans << '\n';
    return EXIT_SUCCESS;
}
```

#### 结算

该算法时间复杂度 $\Theta(m\times \max\{k\})$，其中 $k$ 表示出现次数最多的颜色的频数。

而在多数情况下，$k\to n$。所以，把这份代码交上去，你很可能会获得一份 TLE 大礼包。

可是，快读卡常 + `-O2` 后在你谷竟然[能过官方数据](https://www.luogu.com.cn/record/183378707)！

但不要太开心，这份代码不能 AC 此题。~~不想彻底 AC 一道被 hack 数据 hack 的题的 OIer 不是合格的 OIer。~~

在非完全随机数据、~~造数据不用脚~~的情况下，这种暴力是绝对不能得 $\text{100 pts}$ 的。

这时需要：

## 真・正解

考虑继续优化。其他方面几乎无法优化了，我们从得分的式子入手。

用乘法分配律展开得分式子（记最后总得分为 $ans$）：

$$
\begin{aligned}
ans &= \!\!\!\!\sum^{n}_{x=1,z=2} \!(x+z)(number_x + number_z)\\
&= \!\!\!\!\sum^{n}_{x=1,z=2} \!\!{\color{3498db}x \times number_x + z \times number_z} + \color{52c430}x \times number_z + z \times number_x\\
\end{aligned}
$$

继续化简：（其中 $k$ 表示与该格同颜色且奇偶性相同的个数）

$$
\begin{aligned}
ans & =\!\!\!\!
\sum^{n}_{x=1,z=2}
\!\!{\color{3498db}x \times number_x + z \times number_z}
+ {\color{52c430}x \times number_z + z \times number_x} \\ &

=\sum^{n}_{x=1}{\color{43ae80}\left(k-1\right)x\times number_x} 
+ {\color{52c430}x \times \sum^{n}_{z=1}(number_z)} {\color{43ae80}\ -\ x\times number_x} & ①\\ &

=\sum^{n}_{x=1}{\color{43ae80}\left(k-2\right)x\times number_x}
+ \color{52c41a}x \times \sum^{n}_{z=1}(number_z) & ②
\end{aligned}
$$

- ①：由于 $z\ge x$ 且 $x, z$ 奇偶性相同，可容斥得到该式子。这一步需要算一下或列个表体会一下；
- ②：整理 ① 式得。到这里已经够了。

显然使用前缀和维护 $number$ 数组，并预处理出所有 $k$ 即可。计算时建议边算边取模。

**如果不想挂分，请开 `long long`。**

### 代码

```cpp
#include <bits/extc++.h>
using namespace std;
using ll = long long;

const ll mod = 10007;
ll n, m, c[100010], number[100010], ans;
ll num[100010][2], sum[100010][2]; // num 数组里就是每个 k 的值

ll read(){ // 快读
    int x = 0, F = 1;
    char ch = getchar_unlocked();
    while(!(ch >= '0' && ch <= '9')){
        if(ch == '-'){
            F = -1;
        }
        ch = getchar_unlocked();
    }
    while(ch >= '0' && ch <= '9'){
        num = num * 10 + (ch - '0');
        ch = getchar_unlocked();
    }
    return x * F; 
}
int main(){
    n = read(), m = read();
    for(int i=1; i<=n; ++i){
        number[i] = read() % mod;
    }
    for(int i=1; i<=n; ++i){
        c[i] = read();
    }
    for(int i=1; i<=n; ++i){
        num[c[i]][i % 2] ++; // 颜色与奇偶性相同
        sum[c[i]][i % 2] = (sum[c[i]][i % 2] + number[i]) % mod; // 前缀和
    }
    for(int i=1; i<=n; ++i){
        ans = ((num[c[i]][i % 2] - 2) * i * number[i] % mod + i * sum[c[i]][i % 2] % mod + ans) % mod; // 柿子
    }
    cout << ans << '\n';
    return EXIT_SUCCESS;
}
```

### [结算画面](https://www.luogu.com.cn/record/list?pid=P2671\&orderBy=1\&status=\&page=1)

本解法时空复杂度均为 $\Theta(n)$，常数较小。

用 `&` 卡常，进了最优解第一页？

![喜感.jpg](https://cdn.luogu.com.cn/upload/image_hosting/ju82ce8h.png)

---

第一篇题解，见谅。

3k 有言：不借鉴题解代码，而借鉴题解思路。如果你高兴的话，点个赞顶它上去。（别问 3k，问就是玩）

感谢所有审核大大们！

End.

---

## 作者：pengyule (赞：17)

# 概述
一道数学题，用暴力做复杂度 $O(n^2)$，但是可以发现存在一些性质，从而把复杂度降到 $O(n)$。

# 分析
看看题目怎么说：
> 1. $x<y<z$，且 $y-x=z-y$
> 2. $color_x=color_y$

对于第二个条件，很好想，我们可以把相同颜色的元素归到一组，然后在每一个“组”中寻找“三元组”。

对于第一个条件，乍一看就是说要找到三个等距离的元素，其实我们发现，在满足第二个条件的情况下，其实就是要找到 $x,z$ 奇偶性相同的二元组 $(x,z)$。

我们于是想到，对于每一个相同颜色的“组”中，再把它分成下标为奇数和下标为偶数的两个组，对于每一个组，去计算所有 $(x,z)$ 的分数。

怎么计算分数呢？一个有 $n$ 个元素的颜色相同、下标奇偶相同的“组”，它的总分数等于
$$\sum_{i=1}^n x_i\times (y_i\times(n-2)+\sum_{j=1}^n y_j) $$
我们看一看式子的推导过程。

记答案为 $ans$，$y_i$ 为组中第 $i$ 个数的下标，$x_i$ 为 $number\_y_i$。

$$ans=(x_1+x_2)(y_1+y_2)+(x_1+x_3)(y_1+y_3)+\cdots+(x_1+x_n)(y_1+y_n)$$
$$+(x_2+x_3)(y_2+y_3)+\cdots+(x_2+x_n)(y_2+y_n)$$
$$\cdots$$
$$+(x_{n-1}+x_{n})(y_{n-1}+y_n)$$

发现第 $j$ 排都有 $x_j$，可以把所有的 $x_j\times x_i^{(i=[1,n],i\neq j)}$ 提取出来，剩下的就是一些乱七八糟的东西，总之你最后就会发现，你得到了

$$ans=x_1(y_1+y_2+y_1+y_3+\cdots+y_1+y_n)$$
$$+x_2(y_2+y_1+y_2+y_3+\cdots+y_2+y_n)$$
$$\cdots$$
$$+x_{n-1}(y_{n-1}+y_1+\cdots+y_{n-1}+y_{n-2}+y_{n-1}+y_{n})$$

我们发现其实第 $i$ 排就是 $x_i$ 乘上 $(n-1)$ 个 $y_i$ 加上 $j=[1,n]\&\&j\neq i$ 的 $y_j$ 的和。其实我们把 $(n-1)$ 个 $y_i$ 中拎一个出来丢到后面的 $y_{j=1\sim n,\neq i}$ 里这排的答案就变成了

$$x_i\times(y_i\times(n-2)+\sum_{j=1}^{n}y_j)$$

于是最终的答案就得到了！

$\sum_{j=1}^{n}y_j$ 我们跑一遍循环就可以得到，这样每一排就可以直接调用。

所以核心代码就是

```
for(int i=1;i<=n;i++) ans+=x[i]*(sum+y[i]*(n-2));
```

# 代码
```
#include <bits/stdc++.h>
using namespace std;
#define int long long //要开long long
const int N=1e5+5;
struct node {
	int num,col,idx;//idx:原来的下标
}t[N];
bool cmp(node a,node b){
	return a.col<b.col;//相同的颜色放到一起方便处理
}
int x[N],y[N],ans;
int solve(int l,int r){//[l,r]是相同的颜色
	int n=0;
	int sum=0,ans=0;
	for(int i=l;i<=r;i++) if(t[i].idx&1)x[++n]=t[i].num,y[n]=t[i].idx;//如果下标是奇数那么把他存到x,y里当成一组
	for(int i=1;i<=n;i++) sum+=y[i];//预处理sum
	for(int i=1;i<=n;i++) ans=(ans+x[i]*(sum+y[i]*(n-2)))%10007;//这里就要取模小心到时候答案不对
	n=0,sum=0;
	for(int i=l;i<=r;i++) if((t[i].idx&1)==0)x[++n]=t[i].num,y[n]=t[i].idx;//如果下标是偶数那么把他存到x,y里当成一组
	for(int i=1;i<=n;i++) sum+=y[i];
	for(int i=1;i<=n;i++) ans=(ans+x[i]*(sum+y[i]*(n-2)))%10007;
	return ans;
}
signed main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>t[i].num,t[i].idx=i;
	for(int i=1;i<=n;i++) cin>>t[i].col;
	sort(t+1,t+n+1,cmp);
	int las=1;
	for(int i=2;i<=n+1;i++)
		if(t[i].col!=t[i-1].col){
			ans=(ans+solve(las,i-1))%10007;
			las=i;
		}
	cout<<ans%10007<<endl;
	return 0;
}
```

---

## 作者：Sol1 (赞：13)

首先分析一下这道题可以得出一个结论就是奇数和偶数是互不干扰的。

于是可以分离出来，然后$y$就没有用了。

下一步，可以发现，可以将已经分离出的两个数组按照颜色分离成$\leq 2m$个数组。

于是问题转换为：在两个数组$A_{[1,n]}$和$B_{[1,n]}$中，在$\Theta(N)$时间内求$\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}(A_i+A_j)(B_i+B_j)$。其中$A$保存值，$B$保存值对应在原数组中的下标。

通过计算$n=3$和$n=4$的情况，可以得到公式：

$$\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}(A_i+A_j)(B_i+B_j)=\sum\limits_{i=1}^{n}A_i\cdot\sum\limits_{i=1}^{n}B_i+\sum\limits_{i=1}^{n}(n-2)A_iB_i$$

而显然右边是可以$\Theta(N)$计算的。

于是这题就完美解决了。上代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <vector>
using namespace std;

const int zjx = 10007;
int n, m, a[100005], c[100005];
vector <pair <int, int> > v1[100005], v2[100005];
int ans = 0;

void Read() {
	scanf("%d%d", &n, &m);
	for (int i = 1;i <= n;i++) scanf("%d", &a[i]);
	for (int i = 1;i <= n;i++) scanf("%d", &c[i]);
}

//分离数组
void Prefix() {
	for (int i = 1;i <= n;i++) {
		if (i & 1) v1[c[i]].push_back(make_pair(a[i], i));
		else v2[c[i]].push_back(make_pair(a[i], i));
	}
}

void Solve1() {
	for (int i = 1;i <= m;i++) {
		int siz = v1[i].size();
		if (siz < 2) continue;//零个或一个元素的贡献显然为0
		int ans1 = 0, ans2 = 0;
        //算上述公式
		for (int j = 0;j < siz;j++) {
			ans1 += v1[i][j].first; ans1 %= zjx;
			ans2 += v1[i][j].second; ans2 %= zjx;
		}
		ans += ans1 * ans2 % zjx; ans %= zjx;
		for (int j = 0;j < siz;j++) {
			int cur = (siz - 2) % zjx * v1[i][j].second % zjx;
			ans += cur % zjx * v1[i][j].first;
			ans %= zjx;
		}
	}
}

//与Solve1()同理
void Solve2() {
	for (int i = 1;i <= m;i++) {
		int siz = v2[i].size();
		if (siz < 2) continue;
		int ans1 = 0, ans2 = 0;
		for (int j = 0;j < siz;j++) {
			ans1 += v2[i][j].first; ans1 %= zjx;
			ans2 += v2[i][j].second; ans2 %= zjx;
		}
		ans += ans1 * ans2 % zjx; ans %= zjx;
		for (int j = 0;j < siz;j++) {
			int cur = (siz - 2) % zjx * v2[i][j].second % zjx;
			ans += cur % zjx * v2[i][j].first;
			ans %= zjx;
		}
	}
}

int main() {
	Read();
	Prefix();
	Solve1();
	Solve2();
	printf("%d", ans);
	return 0;
}
```


---

## 作者：TH讠NK (赞：9)

看了一下题解区，第一篇题解的数学方法非常棒，但是推导的过程可能有点难以理解（可能是我菜了），于是自己写了一下推导的过程，尽量详细

首先分析题目可知，$y$ 没啥用，只需要看 $x$ 和 $z$，而且只用考虑颜色和位置的奇偶

即颜色和位置奇偶性都相同的格子，可以视为一组，然后在每一组中计算答案即可

为书写方便，我们用 $a_i $ 来表示第 $i$ 个格子上写的数字

现在考虑一组中有 $m$ 个格子，则这一组对答案的贡献为

$$\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} (i+j)\times (a_i+a_j)$$

若枚举 $i,j$ 暴力计算，则复杂度为 $O(n^2)$，会 TLE，所以需要进一步优化

现在我们把这个式子拆开（把括号打开）

$\begin{aligned} 
& \sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} (i+j) \times (a_i+a_j) \\
&= \sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} (i \times a_i+j\times a_i+i\times a_j+j\times a_j) \\
&= \sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} i\times a_i
+\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} j\times a_i
+\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} i\times a_j
+\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} j\times a_j \\
\end{aligned}$

**第一个式子**可以化简为 
$$ \sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} i\times a_i=
\sum\limits_{i=1}^{m} i\times a_i\times (i-1) $$

**第二个式子**可以化简为
$$\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} j\times a_i=
\sum\limits_{i=1}^{m}a_i\times  \dfrac{(i-1)\times i}{2}
$$

**第三个式子**  $\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} i\times a_j$ 比较麻烦，
我们可以考虑每个 $a_j$ 对答案的贡献

比如考虑 $j=1 $ 时的 $a_1$，我们知道它的贡献应该是 
$\sum\limits_{i=2}^{m} i\times a_1$

也就是说，当 $i=2\sim m$ 时，会存在 $i\times a_1$ 这一项

考虑 $j=2 $ 时的 $a_2$ ，我们知道它的贡献应该是 
$\sum\limits_{i=3}^{m} i\times a_2$

也就是说，当 $i=3\sim m$ 时，会存在 $i\times a_2$ 这一项

以此类推，第三个式子可以化简为
$$\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} i\times a_j=
\sum\limits_{j=1}^{m}  a_j\times  \sum\limits_{i=j+1}^{m} i=
\sum\limits_{j=1}^{m} a_j\times \dfrac{(j+1+m)\times (m-j)}{2}$$



对于**第四个式子**，我们可以考虑每个 $j\times a_j$ 对答案的贡献

当 $i=2\sim m$ 时，$1\times a_1$ 这一项会出现一次

当 $i=3\sim m$ 时，$2\times a_2$ 这一项会出现一次

以此类推，第四个式子可以化简为
$$\sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} j\times a_j=
\sum\limits_{j=1}^{m} j\times a_j\times  \sum\limits_{i=j+1}^{m} 1=
\sum\limits_{j=1}^{m} j\times a_j\times (m-j)$$

最后，我们把这四个式子\times \times 加在一起\times \times 

$ \begin{aligned}
& \sum\limits_{i=1}^{m}  \sum\limits_{j=1}^{i-1} (i+j)\times (a_i+a_j) \\
&= \sum\limits_{i=1}^{m} \left( i\times a_i\times (i-1)+a_i\times  \dfrac{(i-1)\times i}{2}+a_i\times \dfrac{(i+1+m)\times (m-i)}{2}+i\times a_i\times (m-i) \right) \\
&= \sum\limits_{i=1}^{m} a_i\times   \left( i^2 -i+ \dfrac{i^2-i}{2}+\dfrac{m\times i+m+m^2-i^2-i-m\times i}{2}+m\times i-i^2 \right) \\
&= \sum\limits_{i=1}^{m} a_i\times (i\times m-2i+ \dfrac{m^2+m}{2}) \\
&= \sum\limits_{i=1}^{m} i\times a_i\times (m-2) + \sum\limits_{i=1}^{m} a_i\times  \dfrac{m^2+m}{2} \\
\end{aligned} $

至此，我们得出了最后的计算公式，代码就非常好写了，轻松 $O(n)$ 解决


---

## 作者：wawatime1 (赞：5)

### 题目思路
题意不解释。

读到分数计算，发现这个计算方法貌似跟 $y$ 没关系，只跟 $x$ 和 $z$ 有关。

看到含有 $y$ 的式子。$y - x = z - y$ 移项变成 $x + z = 2 \times y$，也就变成了 $x$ 和 $z$ 的奇偶性相同就一定存在 $y$，所以这道题的 $y$ 挺有迷惑性的。 

现在大家有暴力思路了，暴力枚举 $x$ 和 $z$，我这里不多说了。

正解思路：先把每个东西按照颜色分类，每个分出的组再分为下标为奇数和下标为偶数。我们用乘法分配律，把这个东西打开，每一项求和，这是就可以用上前缀和的思想，把解法优化了，就形成了 $O(n)$ 的时间复杂度。

不过我们实际写代码时不会把每个组分开，这样太麻烦了，我们可以用二维数组搞定，第一维记我当前的颜色，第二维记我的下标是奇还是偶。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans;
int a1[100001][2], a2[100001][2];
int color[100001];
int a3[100001][2], a4[100001][2];
/*
a1是x * num[x]的和。
a2 x的和
a3 numx的和
a4 数字有多少个，1的和
*/QWQ
int num[100001];
const int p = 10007;
int main (){
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf ("%d", &num[i]);
	for (int i = 1; i <= n; i++)
		scanf ("%d", &color[i]);
	for (int i = 1; i <= n; i++){
		int t = i % 2;
		ans += a1[color[i]][t];
		ans %= p;
		ans += a2[color[i]][t] * num [i];
		ans %= p;
		ans += a3[color[i]][t] * i;
		ans %= p;
		ans += a4[color[i]][t] * i % p * num [i] % p;
		ans %= p;
		a1[color[i]][t] += 1LL * i * num[i] % p;
		a1[color[i]][t] %= p;
		a2[color[i]][t] += i;
		a2[color[i]][t] %= p;
		a3[color[i]][t] += num[i];
		a3[color[i]][t] %= p;
		a4[color[i]][t]++;
		a4[color[i]][t] %= p;
	}
	cout << ans;
	return 0;
} QAQ
```

---

## 作者：cmrhhh (赞：4)

#### [P2671 NOIP 2015 普及组\] 求和 ](https://www.luogu.com.cn/problem/P2671) 解题报告

首先，我们看三元组满足的条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。
2. $color_x=color_z$。

我们先看第一条，等价于 $x+z=2y$，说明 $x,z$ 同奇偶。

我们再看第二条，字面意思，颜色相同。

综合一下，奇偶、颜色相同的两个可以产生贡献。我们可以以此为标准去分类。分完之后我们可以做到 $O(n)$ 统计贡献，下面开始推导，第四项柿子在第四行改写成了等价的形式，第五行到第六行的变化可以画图理解。下面的 $\left( A_i+A_j\right)\times \left( B_i+B_j\right)$ 等价于 $(x+z)×(number_x+number_z)$，$n$ 是指这一类的总大小，即代码中的 `sz`。




$$
\begin{equation}
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=i+1}^{n}\left( A_i+A_j\right)\times \left( B_i+B_j\right)\\
=&\sum_{i=1}^{n}\sum_{j=i+1}^{n}\left( A_iB_i+A_iB_j+A_jB_i+A_jB_j\right)\\
=&\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_iB_i+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_iB_j+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_jB_i+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_jB_j\\
=&\sum_{i=1}^{n}\left(n-i\right)A_iB_i+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_iB_j+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_jB_i+\sum_{i=1}^{n}\left(i-1\right)A_iB_i\\
=&\sum_{i=1}^{n}\left(n-1\right)A_iB_i+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_iB_j+\sum_{i=1}^{n}\sum_{j=i+1}^{n}A_jB_i\\
=&\sum_{i=1}^{n}\left(n-1\right)A_iB_i+\left(\sum_{i=1}^{n}A_i \times \sum_{i=1}^{n}B_i-\sum_{i=1}^{n}A_iB_i\right)\\
=&\sum_{i=1}^{n}\left(n-2\right)A_iB_i+\sum_{i=1}^{n}A_i \times \sum_{i=1}^{n}B_i
\end{aligned}
\end{equation}
$$



我们就做完了，防止膜错，我们用 `__int128` 草过去。有一个细节，第 $8$ 行 `co[maxn+10][2]` 别写成 `co[maxn+10][0]` 了 QwQ。

#### code:

```c++
#include<bits/stdc++.h>
using namespace std;
#define int __int128
#define ll long long
const int maxn=1e5+10,mod=10007;
ll n,m,p[maxn+10];
int ans;
vector<int>co[maxn+10][2];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>p[i];
	for(int i=1;i<=n;++i){
		ll c;cin>>c;
		co[c][i&1].push_back(i);
	}
	for(int i=1;i<=m;++i){
		int sma=0,smb=0,smab=0,sz=co[i][0].size();
		if(sz>1)for(auto v:co[i][0])smab+=p[v]*v,sma+=p[v],smb+=v;
		ans+=(sz-2)*smab%mod+sma*smb%mod;
	
		sma=0,smb=0,smab=0,sz=co[i][1].size();
		if(sz>1)for(auto v:co[i][1])smab+=p[v]*v,sma+=p[v],smb+=v;
		ans+=(sz-2)*smab%mod+sma*smb%mod;
		cerr<<(ll)m<<": "<<(ll)sma<<" "<<(ll)smb<<" "<<(ll)smab<<"\n";
		ans%=mod;
	} 
		
	cout<<(ll)ans;
	return 0;
}
```

---

## 作者：qhr2023 (赞：4)

## solution

对于条件一，$y-x=z-y$，整理得 $x+z=2y$，所以 $y$ 是没有意义的，只要 $x$ 和 $z$ 奇偶性相同就满足条件一。

条件二要求 $x$ 和 $z$ 颜色相同，所以只有颜色相同且奇偶性相同的格子才会产生贡献，我们可以按颜色和奇偶性分分组，每组单独计算。

记 $a_i$ 表示格子 $i$ 的数字，$k$ 表示其中一组的格子数。

其中一组的答案是 $$\begin{aligned} \sum_{i=1}^{k-1} \sum_{j=i+1}^{k} (i+j) \times (a_i + a_j) \end{aligned}$$。

展开得 $$\begin{aligned} \sum_{i=1}^{k-1} \sum_{j=i+1}^{k} (i \times a_i + i \times a_j + j \times a_i + j \times a_j) \end{aligned}$$。

记 $$\begin{aligned} \sum_{i=1}^{k-1} \sum_{j=i+1}^{k} (i \times a_i + j \times a_j) \end{aligned}$$ 为 $ans_1$，$$\begin{aligned} \sum_{i=1}^{k-1} \sum_{j=i+1}^{k} (i \times a_j + j \times a_i) \end{aligned}$$ 为 $ans_2$，$$\begin{aligned} \sum_{i=1}^{k} a_i\end{aligned}$$ 为 $s$。

对于一个格子 $m$，当上式的 $i$ 小于或等于 $m$ 时，$m$ 才对答案有贡献。
* $i<m$ 时，对于每个 $i$，$m$ 只贡献一次，所以此时 $m$ 对 $ans_1$ 的贡献是 $(m-1) \times m \times a_m$，对 $ans_2$ 贡献 $$\begin{aligned} \sum_{j=1}^{m-1} i \times a_j \end{aligned}$$。
* $i=m$ 时，$m$ 贡献 $k-(m+1)+1$ 即 $k-m$ 次，这部分对 $ans_1$ 的贡献是 $(k-m) \times m \times a_m$，对 $ans_2$ 贡献 $$\begin{aligned} \sum_{j=m+1}^{k} i \times a_j \end{aligned}$$。

$m$ 的对 $ans_1$ 的总贡献就是 $(k-1) \times m \times a_m$，对 $ans_2$ 的总贡献是 $m \times (s-a_m)$。

记 $cnt_i$ 表示 $i$ 所在组的格子数，$S_i$ 表示 $i$ 所在组的数字和。

答案为 $$\begin{aligned} \sum_{i=1}^{n} i \times a_i \times (cnt_i-1) + i \times (S_i-a_i) \end{aligned}$$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5, mod=10007;
long long n, m, a[N], c[N], s[N][2], b[N][2], ans;
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i) 
		cin >> a[i];
	for (int i=1; i<=n; ++i) 
		cin >> c[i],
		b[c[i]][i%2]++,
		s[c[i]][i%2]=(s[c[i]][i%2]+a[i])%mod;
	for (int i=1; i<=n; ++i)
		ans=(ans+i*(s[c[i]][i%2]-a[i])+(b[c[i]][i%2]-1)*i*a[i])%mod;
	cout << ans;
	return 0;
}
```

---

## 作者：BreakPlus (赞：4)

看到大家的思路觉得不好懂，决定手推，然后推出来了。我来一篇简单易懂的题解。

## Part1 部分分算法

$10pts$：直接枚举三元组即可。

$40pts$：不难发现，满足题意的三元组中，$x,z$ 的奇偶性必须相同，这样他们才能有一个中心点。那么中间的 $y$ 就不需要枚举了，变成了枚举一对数。

## Part2 满分算法

比如，我们找到了一对颜色相同、奇偶性相同的数，编号为 $i,j$。现在又有一个编号 $k$ 也满足和 $i,j$ 组成一对。

那么，答案会增加多少呢？

没错，

$$ (i+j)\times (num_i+num_j)+(i+k)\times (num_i+num_j)$$

因为 $k$ 可以和 $i$ 或 $j$ 组成一对。 

考虑拆一下柿子？

变成了下面这四项之和：

1. $i \times (num_i+num_k)$
2. $k \times (num_i+num_k)$
3. $j \times (num_j+num_k)$
4. $k \times (num_j+num_k)$

把 $i,j$ 提取出来再拆一下？

1. $ \color{red}i \times num_i + j \times num_j$
2. $ \color{red} (i+j) \color{black} \times num_k$
3. $ \color{red} (num_i+num_j) \color{black} \times k$
4. $ \color{red} 2 \color{black} \times num_k \times k$

我为何要把一部分给标红？**因为这些东东是可以维护的**。

开第一个数存储所有元素的值乘以它的编号之和，即所有 $i \times num_i$ 之和。

开第二个数存储所有元素的编号之和，即所有的 $i$ 之和。

开第三个数存储所有元素的值之和，即所有的 $num_i$ 之和。

开第四个数存储元素个数。

然后，这个柿子就可以加入数了（不管当前有多少数）！

当然，这一切都要求数的奇偶性、颜色相同，所以开一个三维数组，其中两维表示奇偶性 $(0/1)$ 和颜色，剩下一维表示维护的数的编号 $(1 \sim 4)$（代码中以 $0 \sim 3$ 表示）。

代码如下：

![image.png](https://i.loli.net/2020/08/14/V8zGBX4yTWbm2tc.png)

---

## 作者：__CJY__ (赞：4)

## 题意简述
题目要求找纸带上满足条件的三元组，计算其分数和，输出和除以 $10007$ 的余数，条件包括位置关系和颜色相同。
## 思路
由于 $y$ 是 $x$ 和 $z$ 的中点，我们可以得出 $z=2y−x$。因此，对于每个可能的 $y$，我们可以直接计算出对应的 $z$，而不需要遍历所有可能的 $z$。

我们使用一个 `vector` 来存储每种颜色的格子编号及其对应的数字。这样可以快速找到具有相同颜色的格子对 $(x,z)$。

* 对于每种颜色，遍历其对应的格子，计算可能的 $(x,y,z)$ 组合。
* 对于每个格子 $y$，找到所有可能的 $x$ 和 $z$（即 $x<y<z$ 且 $color_x=color_z$，计算其分数 $(x+z) \times (number_x+number_z)$。

由于结果可能很大，需要在每一步计算中进行模 $10007$ 运算，以防止溢出。

所以最终过程应该是这样的：
1. 使用两个数组或向量来分别存储格子的编号和对应的数字，按颜色分类。
2. 遍历每种颜色，对于每个可能的中间格子 $y$，找到对应的 $x$ 和 $z$，计算其贡献。

---

## 作者：tangzirui1016 (赞：3)

大佬用的都是一大堆公式，蒟蒻不会，只会简单的思想。

直接讲正解。

要想让两个数产生联系（构成三元组），需满足两个条件：
- $x$ 与 $z$ 模 $2$ 同余（都是奇数或都是偶数）。
- $x$ 与 $z$ 的颜色相同。

最后 $x$ 与 $z$ 产生的价值为 $(x+z)\times (number_x+number_z)$。

假设 $x$ 可以和 $k$ 个 $z$ 产生联系，观察上式，对于 $x$ 而言，$x$ 可以产生的价值由两部分组成，一部分是自身，一部分来自对方。因此对于 $x$ 而言，能产生的价值应为 $k\times x\times number_x+x\times\sum_{i=1}^{k} number_{z_i}$。
对于其他的 $x$ 同理。  

这里运用了对称式的性质。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10007;
int n,m,a[100005],b[100005];
int cnt[100005][2],sum[100005][2],ans;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=n;i++){
        a[i]%=mod;
		cnt[b[i]][i&1]=(cnt[b[i]][i&1]+1)%mod;
		sum[b[i]][i&1]=(sum[b[i]][i&1]+a[i])%mod;
	}
	for(int i=1;i<=n;i++){
		ans=(ans+(i*(sum[b[i]][i&1]-a[i])%mod+mod)%mod+(i*a[i]%mod*(cnt[b[i]][i&1]-1)%mod+mod)%mod)%mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
基础贡献统计题。  
第一个条件化一下就变成了 $y=\frac{x+z}{2},y\in \mathbb{Z}$。也就是说 $x+z$ 是个偶数，等价于 $x,z$ 奇偶性相同。  
所以产生贡献的条件就变成了 $color_x=color_z,x \equiv z \pmod 2$。颜色不同或奇偶性不同的格子互不干扰；颜色相同且奇偶性相同的格子之间必定产生贡献。开个二维数组把格子按奇偶性和颜色**分类存储**即可。  

$x,z$ 之间产生的贡献为 $(x+z)(number_x+number_z)=x(number_x+number_z)+z(number_x+number_z)$。把 $x(number_x+number_z)$ 视为 $x$ 对 $z$ 产生的贡献，把 $z(number_x+number_z)$ 视为 $z$ 对 $x$ 产生的贡献，就发现每个格子对同类的其他格子都会产生贡献。  
设第 $i$ 个格子类别为 $t$，$size_t$ 表示 $t$ 类的格子有多少，$sum_t$ 表示 $t$ 类的格子的 $number$ 之和。  
则格子 $i$ 对其他所有格子产生的贡献和为 $i\times number_i \times (size_t-1)+i\times (sum_t-number_i)$。  
对于每一类预处理出 $size_t$ 和 $sum_t$，就可以 $O(1)$ 求出每个格子对别的格子产生的贡献。把所有贡献加起来即可。  

时间复杂度为 $O(n)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 10007
typedef long long ll;
int n,m;
int a[100003],c[100003];
ll ans;
ll sum[100003][2];
int cnt[100003][2];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++){
		cin>>c[i];
		(sum[c[i]][i&1]+=a[i])%=mod;
		cnt[c[i]][i&1]++;
	}
	for(int i=1;i<=n;i++){
		ans+=(ll)i*(sum[c[i]][i&1]-a[i]);
		ans+=(ll)a[i]*i*(cnt[c[i]][i&1]-1);
		ans%=mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：BeeAC (赞：2)

## 题意简述
给定 $2$ 个正整数 $n,m$，$n$ 个正整数 $a_i$ 表示每个格子的数字，$n$ 个正整数 $col_i(col_i\in[1,m])$ 表示每个格子的颜色，格子的编号为 $1\sim n$。求：
$$
\sum(x+z)\times(a_x+a_z)
\\
(x,y,z\in\mathbb Z,x<y<z,y-x=z-y,col_x=col_z)
$$
## 算法分析
$y-x=z-y\Rightarrow x+z=2y\Rightarrow x\equiv z\ (\bmod 2)$

容易想到暴力：枚举 $x$ 和 $z$ 的位置，使 $x$ 和 $z$ 的奇偶性相同，若颜色相同则累加进答案。时间复杂度 $O(n^2)$，期望得分 $40$ 分。

### 不妨将计算分数的式子拆开，尝试合并计算。
设序列 $a_1,a_2,a_3,a_4,a_5$，$\forall(a_x,a_z)(1\le x<z\le5)$ 对答案都有 $x(a_x+a_z)+z(a_x+a_z)$ 的贡献，列出下表：
|$z$ \ $x$|$1$|$2$|$3$|$4$|$5$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$||$1(a_1+a_2)+2(a_1+a_2)$|$1(a_1+a_3)+3(a_1+a_3)$|$1(a_1+a_4)+4(a_1+a_4)$|$1(a_1+a_5)+5(a_1+a_5)$|
|$2$|||$2(a_2+a_3)+3(a_2+a_3)$|$2(a_2+a_4)+4(a_2+a_4)$|$2(a_2+a_5)+5(a_2+a_5)$|
|$3$||||$3(a_3+a_4)+4(a_3+a_4)$|$3(a_3+a_5)+5(a_3+a_5)$|
|$4$|||||$4(a_4+a_5)+5(a_4+a_5)$|
|$5$||||||

此时计算分数的式子可以转化为：
$$
\sum_{i=1}^{5}\left(i\left((5-2)a_i+\sum_{j=1}^{5}a_j\right)\right)
$$
推广到同一颜色同一奇偶性的 $k$ 个格子，分数为：
$$
\sum_{i=1}^{k}\left(i\left((k-2)a_i+\sum_{j=1}^{k}a_j\right)\right)
$$
用 $num_{col_i,0/1}$ 数组记录颜色为 $col_i$ 且编号为偶数或奇数的格子数目，$sum_{col_i,0/1}$ 数组记录颜色为 $col_i$ 且编号为偶数或奇数的格子数字和，则原式化为：
$$
\sum_{i=1}^{n}\left(i\left((num_{col_i,i\bmod2}-2)a_i+sum_{col_i,i\bmod2}\right)\right)
$$
容易写出代码：
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1,mod=10007;
int n,m,a[N],col[N],num[N][2],sum[N][2],s;
inline void read(int &x)//快读
{
	x=0;bool f=0;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	if(f)
		x=~x+1;
	return;
}
int main()
{
	read(n);read(m);
	for(int i=1;i<=n;++i)
		read(a[i]);
	for(int i=1;i<=n;++i)
	{
		read(col[i]);
		++num[col[i]][i&1];
		(sum[col[i]][i&1]+=a[i])%=mod;
	}
	for(int i=1;i<=n;++i)
		(s+=i*(((num[col[i]][i&1]-2)*a[i]+sum[col[i]][i&1])%mod)%mod)%=mod;
	printf("%d",s);
	return 0;
}
```

---

## 作者：omclude (赞：2)

一条纸带被均匀分成了 $N$ 个格子，格子被染上 $b_i$ 的颜色，写上 $a_i$ 的数字。

一个合法的三元组 $(x,y,z)$ 要满足 $x<y<z$ 且 $y-x=z-y$ 且 $b_x=b_z$。

求合法三元组的「分数」之和。（一个三元组 $(x,y,z)$ 的分数是 $(x+z)\times (a_x+a_z)$）

$1 \le N\le 10^5, 1 \le M \le 10^5,1 \le b_i \le M, 1 \le a_i \le 10^5$

---

首先答案与 $y$ 没关系，$y-x=z-y \Rightarrow 2y=x+z \Rightarrow y=\frac{x+z}{2}$。只需要让 $y$ 为整数，即 $x+z$ 为偶数，即保证 $x$ 与 $z$ 同奇偶即可（$\text{40pts}$ 暴力）。

我们首先考虑 $n=5$ 时的情况：

| $i$ \ $j$ | $1$  | $2$                                                          | $3$                                                          | $4$                                                          | $5$                                                          |
| :-------- | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $1$       |      | $\textcolor{red}{1a_1}+2a_1+\textcolor{red}{1a_2}+\textcolor{#00BFFF}{2a_2}$ | $\textcolor{red}{1a_1}+\textcolor{red}{1a_3}+3a_1+3a_3$      | $\textcolor{red}{1a_1}+\textcolor{red}{1a_4}+4a_1+4a_4$      | $\textcolor{red}{1a_1}+\textcolor{red}{1a_5}+5a_1+5a_5$      |
| $2$       |      |                                                              | $\textcolor{#00BFFF}{2a_2}+\textcolor{#00BFFF}{2a_3}+3a_2+3a_3$ | $\textcolor{#00BFFF}{2a_2}+\textcolor{#00BFFF}{2a_4}+4a_2+4a_4$ | $\textcolor{#00BFFF}{2a_2}+\textcolor{#00BFFF}{2a_5}+5a_2+5a_5$ |
| $3$       |      |                                                              |                                                              | $3a_3+3a_4+4a_3+4a_4$                                        | $3a_3+3a_5+5a_3+5a_5$                                        |
| $4$       |      |                                                              |                                                              |                                                              | $4a_4+4a_5+5a_4+5a_5$                                        |
| $5$       |      |                                                              |                                                              |                                                              |                                                              |

（表格中空着的一半是重复的）

我们分系数考虑，可以发现有 $5-1$ 个 $\color{red}1a_1$ 和 $\color{red}1(a_2+a_3+a_4+a_5)$ 也有 $5-1$ 个 $\color{#00BFFF}2a_2$ 和 $\color{#00BFFF}2(a_1+a_3+a_4+a_5)$，我们设以此类推，发现第 $i$ 个的总和为：（$\text{cnt}$ 指的是与 $i$ 同一奇偶性的个数）
$$
\begin{aligned}
(\text{cnt}-i)\times ia_i+i\times \left(\sum_{j=1}^{\text{cnt}}a_j-a_i\right) \\ = i \times \left((\text{cnt}-1)a_i +\sum_{j=1}^{\text{cnt}}a_j-a_i\right)
\end{aligned}
$$
注意这里的 $\left(\sum_{j=1}^{\text{cnt}}a_j-a_i\right)$ 不应读成 $\left(\sum_{j=1}^{\text{cnt}}\textcolor{red}{(}a_j-a_i\textcolor{red}{)}\right)$

可以用**前缀和的思想解决问题**，预处理 $\left(\sum_{j=1}^{\text{cnt}}a_j-a_i\right)$ 即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 1e5 + 10;
const int md = 10007;

int n, m;
vector<int> a(N), b(N);
ll ans = 0;

int s1[N][2], s2[N][2];

//s1[i][i%2]表示与i奇偶相同的a[i]的个数 (cnt)
//s2[i][i%2]表示与i奇偶相同的a[i]的总和

signed main() {
	ios::sync_with_stdio(false); cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	for (int i = 1; i <= n; ++i) {
		cin >> b[i];
		s1[b[i]][i % 2] ++; 
		s2[b[i]][i % 2] = (s2[b[i]][i % 2] + a[i]) % md;
	}
	for (int i = 1; i <= n; ++i) { int y = b[i];
		ans += i * (s2[y][i % 2] + a[i] * (s1[y][i % 2] - 2) % md) % md; //这里-2是为了取模不为负数
                                  // 一定要勤取模！！！
		ans %= md;
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：Vocalise (赞：2)

首先，各位想必都写得出 $40~50pts$ 的 $O(n^2)$ 算法。

还是给出一份代码，在这里只枚举了 $x$ , $z $。

```cpp
#include<cstdio>
#include<iostream>
#define maxn 100001

const int mod = 10007;
typedef long long ll;

inline int read(){
    int x = 0;char ch = getchar();
    while(ch > '9' || ch < '0')ch = getchar();
    do x = x * 10 + ch - 48,ch = getchar();while(ch >= '0' && ch <= '9');
    return x;
}
int n,m,color[maxn];
ll number[maxn];

int main(){
    n = read(),m = read();
    for(int i = 1;i <= n;i++)number[i] = read();
    for(int i = 1;i <= n;i++)color[i] = read();
    ll ans = 0;
    for(int x = 1;x <= n - 2;x++)
        for(int z = x + 2;z <= n;z += 2)
            if(color[x] == color[z]){
                ans = (ans + (x + z) * (number[x] + number[z])) % mod;
            }
    std::printf("%lld\n",ans);
    return 0;
}


```

记得要开 $long long$。

接下来是正解环节。

首先，我们知道，因为限制条件1，奇偶性不相同的两个格子不会互相影响。

所以，我们按编号的奇偶性把格子分成两类。

这时候枚举的 $z$ 就可以认为是连续的了。

解决该题的核心思想是：避免枚举每一个三元组，寻找三元组在某些方面上的共同特征，然后利用合并之类的方式，构造出容易维护的等价表达式。

刚才我们正是利用了第一个条件，把问题剖成了两半。

然后，如果只是这样的话，我们还是难以利用下一个条件：颜色相同。

所以，我们再次按照颜色分类。在以下的描述中， $n$ 指代奇偶性相同并且颜色相同的某一种格子的个数，这些格子由 $1-n$ 编号，他们的分数也是 $number[1-n]$ 。

我们尝试裂项。这部分的贡献是：

$$\sum\limits_{1\leq i < j \leq n}{(i+j)\times (number[i]+number[j])}$$

即：

$$\sum\limits_{1\leq i < j \leq n}{i\times number[i] + i\times number[j] + j \times number[i] + j\times number[j]}$$

其中有两个简单同类项 $i\times number[i]$ 和 $j\times number[j]$

我们观察并推导一下：

```cpp
#include<cstdio>

int main(){
    int a[10] = {0};
    for(int i = 1;i <= 5;i++)
        for(int j = i + 1;j <= 5;j++)a[i]++,a[j]++;
    for(int i = 1;i <= 5;i++)std::printf("%d ",a[i]);
    return 0;
}

```
输出 $a[i]$ 都是 $4$ ,即 $5 - 1$ 。

可以得出这两项的贡献是：

$$\sum\limits_{1\leq i \leq n}{(n - 1)\times i \times number[i]}$$

还有剩下两项 $i\times number[j]$ 和 $j\times number[i]$ 。

裂开得,他们的贡献分别是：

$$\sum\limits_{1\leq i \leq n}\sum\limits_{i< j\leq n}i\times number[i]$$

和

$$\sum\limits_{1\leq i \leq n}\sum\limits_{1\leq j < i}i\times number[i]$$

发现因为 $i,j$ 本质上没有区别，所以合并，注意 $i = j$ 的情况：

$$\sum\limits_{1\leq i\leq n}{(i\times \sum\limits_{1\leq j \leq n}number[j]) - i\times number[i]}$$

其中 $\sum\limits_{1\leq j\leq n}number[j]$ 是可以维护为  $sum$ 的：

$$\sum\limits_{1\leq i\leq n}{i\times sum - i\times number[i]}$$

然后不要忘记上面那两项的式子，再次合并：

$$\sum\limits_{1\leq i \leq n}{(n - 1)\times i \times number[i]+i\times sum - i\times number[i]}$$

整理得：

$$\sum\limits_{1\leq i \leq n}{(n - 2)\times i \times number[i]+i\times sum}$$

这样就基本搞定了，还有需要注意的：

- $sigma$ 下面的 $n$ 和右边的 $n$ 有区别，下面的其实就是原序列的长度，但是右边的是同颜色同奇偶的格子数量，所以也要维护；

- 如何维护？开一个 $num[maxn][2]$ 和 $sum[maxn][2]$ 表示 新的 $n$ 和 $\sum\limits_{1\leq i\leq n}number[i]$。

推导公式打起来有点难的，况且笔者还不小心删了一份...

反正大家记住，这题维护 $sum$ 算是个套路，以后可以往这方面想。

接下来就是代码了:

```cpp
#include<cstdio>
#include<iostream>
#define maxn 100001

const int mod = 10007;
typedef long long ll;

inline int read(){
    int x = 0;char ch = getchar();
    while(ch > '9' || ch < '0')ch = getchar();
    do x = x * 10 + ch - 48,ch = getchar();while(ch >= '0' && ch <= '9');
    return x;
}
int n,m,color[maxn];
ll number[maxn];
ll num[maxn][2],sum[maxn][2];

int main(){
    n = read(),m = read();
    for(int i = 1;i <= n;i++)number[i] = read();
    for(int i = 1;i <= n;i++)color[i] = read();
    ll ans = 0;
    for(int i = 1;i <= n;i++){
        num[color[i]][i & 1]++;
        sum[color[i]][i & 1] = (sum[color[i]][i & 1] + number[i]) % mod;
    }
    for(int i = 1;i <= n;i++)
        ans = (ans + (num[color[i]][i & 1] - 2) * i * number[i] % mod + i * sum[color[i]][i & 1]) % mod;
    std::printf("%lld\n",ans);
    return 0;
}
```

竟然推出了公式，真是喜不自胜，接下来就求大家一遍就懂了。

请不要怕看数学形式的公式，虽然我自己就这样...

---

## 作者：xxxalq (赞：1)

去年做的题，偶然看到这题能写题解，就来写了。

[题目链接](https://www.luogu.com.cn/problem/P2671)

# 思路分析：

转化以下条件其实就是两个下标奇偶性相同并且颜色相同。

把奇数位置和偶数位置分开计算。

为了避免重复计算，对于每个位置只找它前面的与他相同的颜色。假设当前位置为 $i$，前面与他颜色相同的位置分别为 $a_1,a_2,\dots,a_k$。$number_i$ 记为 $num_i$，那么对答案的贡献就是

$$\begin{aligned}(i+a_1)(num_i+num_{a_1})+(i+a_2)(num_i+num_{a_2})+\dots+(i+a_k)(num_i+num_{a_k})
\\=(i\times num_i+i\times num_{a_1}+a_1\times num_i+a_1\times num_{a_1})+(i\times num_i+i\times num_{a_2}+a_2\times num_i+a_2\times num_{a_2})+\dots +(i\times num_i+i\times num_{a_3}+a_3\times num_i+a_3\times num_{a_3)}
\\=k\times i\times num_i+i\times(num_{a_1}+num_{a_2}+\dots +num_{a_k})+num_i\times(a_1+a_2+\dots +a_k)+(a_1\times s{a_1}+a_2\times num_{a_2}+a_3\times num_{a_3})\end{aligned}$$

所以对于同一种颜色，我们只需要记录个数、$num$ 的和、下标的和、以及 $num$ 乘下标的和即可。

奇偶分开算不要忘了取模，具体看注释。

# 代码：


```cpp
//code by xxxalq
#include<bits/stdc++.h>
#define int long long//十年OI一场空
using namespace std;

const int maxn=100003,mod=10007;

int read(){//快读
	int x=0,f=1;
	char ch=getchar();
	while(ch>57||ch<48){
		if(ch==45){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>=48&&ch<=57){
		x=(x<<1)+(x<<3)+(ch-48);
		ch=getchar();
	}
	return x*f;
}

int n,m,col[maxn],num[maxn],c[maxn],cn[maxn],cnt[maxn],cheng[maxn];
//col表示颜色，num表示number，c表示下标和，cnt记录个数，cn表示number的和，cheng表示下表与number乘积的和

int ans;

void f(){//对答案取模
	ans=ans%mod;
	return;
}

signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		num[i]=read();
	}
	for(int i=1;i<=n;i++){
		col[i]=read();
	}
	for(int i=1;i<=n;i+=2){//先算奇数
		int x=col[i];
		ans+=i*num[i]%mod*cnt[x]%mod;
		f();
		ans+=num[i]*c[x]%mod;
		f();
		ans+=i*cn[x]%mod;
		f();
		ans+=cheng[x];
		f();
		//
		cnt[x]++;
		c[x]=(c[x]+i)%mod;
		cn[x]=(cn[x]+num[i])%mod;
		cheng[x]=(cheng[x]+i*num[i]%mod)%mod;
	}
	for(int i=1;i<=m;i++){
		cnt[i]=c[i]=cn[i]=cheng[i]=0;
	}//清空
	for(int i=2;i<=n;i+=2){//计算偶数，代码都一样
		int x=col[i];
		ans+=i*num[i]%mod*cnt[x]%mod;
		f();
		ans+=num[i]*c[x]%mod;
		f();
		ans+=i*cn[x]%mod;
		f();
		ans+=cheng[x];
		f();
		//
		cnt[x]++;
		c[x]=(c[x]+i)%mod;
		cn[x]=(cn[x]+num[i])%mod;
		cheng[x]=(cheng[x]+i*num[i]%mod)%mod;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：dulinfan2023 (赞：1)

## 题意：

对于每一个三元组 $(x,y,z)$ 满足 $x<y<z,y-x=z-y,color_x=color_z$，求出 $\sum(x+z)(number_x+number_z)$。

## 思路：

### 90pts 暴力：

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define debug() cout<<"come on"<<'\n'
typedef pair<int,int> pii;
const int mod=1e4+7;
int color[100005],number[100005],n,m,ans;
vector<pii> v[100005];
vector<int> jj[100005],oo[100005];
int score(int x,int z){
	return (number[x]+number[z])*(x+z);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>number[i];
	}
	for(int i=1;i<=n;i++){
		cin>>color[i];
	}
	for(int i=1;i<=n;i++){
		v[color[i]].push_back(make_pair(number[i],i));//jj[color[i]].push_down(v[color[i]].size()-1);
		if(i%2==1){
			for(int j=0;j<jj[color[i]].size();j++){
				ans+=score(v[color[i]][jj[color[i]][j]].second,i),ans%=mod;
			}
			jj[color[i]].push_back(v[color[i]].size()-1);
		}
		else{
			for(int j=0;j<oo[color[i]].size();j++){
				ans+=score(v[color[i]][oo[color[i]][j]].second,i),ans%=mod;
			}
			oo[color[i]].push_back(v[color[i]].size()-1);
		}
	}
	cout<<ans;
	return 0;
}
```

### 100pts 正解：

思考 $y-x=z-y$，即 $x+z=2y$，所以 $x$ 和 $z$ 同奇偶，分开两个数组存奇数和偶数。

对于任意奇数或偶数的求法：

 1. 假定 $cnt_i$ 为前面所有奇数的 $i$ 颜色的个数，$s_i$ 为前面所有奇数的 $i$ 颜色的 $number$ 之和。

 2. 很容易求出：对于每一个 $i$，其对答案的贡献为 $(\sum x+cnt_i\times i)\times number_i+\sum(x+i)\times number_x$，其中的 $x$ 使用数组初始化好。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define debug() cout<<"come on"<<'\n'
const int mod=1e4+7;
int n,m,c[100005],b[100005][2],a[100005],ans,s[100005][2]; 
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>c[i],b[c[i]][i%2]++,s[c[i]][i%2]=(s[c[i]][i%2]+a[i])%mod;
	for(int i=1;i<=n;i++)ans=(ans+i*(s[c[i]][i%2]-a[i])+(b[c[i]][i%2]-1)*i*a[i])%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：lflby (赞：1)

## 题意转换

条件1，$y-x=z-y$，即 $x,z$ 的奇偶性相同。

## 思路

讲一下暴力的做法：

先按颜色分组，在暴力枚举每一种方案求和。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int res = 0,f = 1;
	char ch = getchar();
	while (ch<'0'||ch>'9') f = (ch=='-'?-1:1),ch = getchar();
	while (ch>='0'&&ch<='9') res = (res<<3)+(res<<1)+(ch^48),ch = getchar();
	return res*f;
}
void write(int x)
{
	if (x<0) putchar('-'),x = -x;
	if (x>9) write(x/10);
	putchar(x%10+'0');
}
void writech(int x,char ch){write(x),putchar(ch);}
const int N = 1e5+5,MOD = 10007;
int n,m;
int num[N],c[N];
vector<pair<int,int> > a[N];
int ans;
signed main()
{
	n=read(),m=read();
	for (int i = 1; i <= n; i++) num[i]=read();
	for (int i = 1; i <= n; i++)
	{
		c[i]=read();
		a[c[i]].push_back({i,num[i]});
	}
	for (int i = 1; i <= m; i++)
	{
		for (int j = 0; j < a[i].size(); j++)
		{
			for (int k = j+1; k < a[i].size(); k++)
			{
				if (a[i][j].first%2==a[i][k].first%2)
				{
					ans = (ans+(a[i][j].first+a[i][k].first)*(a[i][j].second+a[i][k].second)%MOD)%MOD;
				}
			}
		}
	}
	write(ans);
	return 0;
}
```

**90分拿下！**

接下来再看正解：

每一次求和为 $(x+z)\times(number_x+number_z) = x\times(number_x+number_z) + z\times(number_x+number_z)$。

若 $x,y,z$ 都符合条件则答案为 $(x+y)\times(number_x+number_y)+(x+z)\times(number_x+number_z)+
(y+z)\times(number_y+number_z) = x\times(number_x+number_y+number_z+number_x)+
y\times(number_x+number_y+number_z+number_y)+
z\times(number_x+number_y+number_z+number_z)$。

若 $x,y,z,k$ 都符合题目条件答案转换后为 $x\times(number_x+number_y+number_z+number_k+2\times number_x)+
y\times(number_x+number_y+number_z+number_k+2\times number_y)+
z\times(number_x+number_y+number_z+number_k+2\times number_z)+
k\times(number_x+number_y+number_z+number_k+2\times number_k)$。

可以发现规律，所以记录下每种颜色的奇偶总数，再按规律即可得知答案。

## Code


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int res = 0,f = 1;
	char ch = getchar();
	while (ch<'0'||ch>'9') f = (ch=='-'?-1:1),ch = getchar();
	while (ch>='0'&&ch<='9') res = (res<<3)+(res<<1)+(ch^48),ch = getchar();
	return res*f;
}
void write(int x)
{
	if (x<0) putchar('-'),x = -x;
	if (x>9) write(x/10);
	putchar(x%10+'0');
}
void writech(int x,char ch){write(x),putchar(ch);}
const int N = 1e5+5,MOD = 10007;
int n,m;
int num[N],c[N];
vector<pair<int,int> > a[N];
int ans;
signed main()
{
	n=read(),m=read();
	for (int i = 1; i <= n; i++) num[i]=read();
	for (int i = 1; i <= n; i++)
	{
		c[i]=read();
		a[c[i]].push_back({i,num[i]});
	}
	for (int i = 1; i <= m; i++)
	{
		int cntd = 0,cnts = 0;
		int sumd = 0,sums = 0;
		int idd = 0,ids = 0;
		for (int j = 0; j < a[i].size(); j++)
		{
			if (a[i][j].first%2==1) sumd+=a[i][j].second,idd+=a[i][j].first,cntd++;
			else sums+=a[i][j].second,ids+=a[i][j].first,cnts++;
		}
		for (int j = 0; j < a[i].size(); j++)
		{
			if (a[i][j].first%2==1) ans = (ans+a[i][j].second*a[i][j].first*(cntd-2)%MOD)%MOD;
			else ans = (ans+a[i][j].second*a[i][j].first*(cnts-2)%MOD)%MOD; 
		}
		ans = (ans+sumd*idd%MOD+sums*ids%MOD)%MOD;
	}
	write(ans);
	return 0;
}

```

---

## 作者：CaiZi (赞：1)

首先考虑三元组 $(x,y,z)$ 合法的条件，将式子变形得 $x+z=2y$，因为 $y$ 为整数，所以当 $x<z$ 且 $x,z$ 奇偶性相同且颜色相同时合法。

因为要求 $x,z$ 奇偶性相同且颜色相同，所以把每种颜色的每种奇偶性的编号单独分组，只需要存编号即可。为了后面考虑，每个组的编号弄完需要先排个序。

那么我们要求的就是对于每个组 $S$，求出：
$$\begin{aligned}\sum_{i,j\in S\land i<j}(i+j)(w_i+w_j)&=\sum_{i,j\in S\land i<j}(iw_i+iw_j+jw_i+jw_j)\\&=\sum_{i,j\in S\land i<j}iw_i+\sum_{i,j\in S\land i<j}iw_j+\sum_{i,j\in S\land i<j}jw_i+\sum_{i,j\in S\land i<j}jw_j\\&=\sum_{i,j\in S\land i<j}iw_i+w_j\sum_{i,j\in S\land i<j}i+j\sum_{i,j\in S\land i<j}w_i+jw_j\sum_{i,j\in S\land i<j}1\end{aligned}$$
考虑枚举 $j$，使用前缀和计算：
$$a=\sum\limits_{i\in S\land i<j}iw_i,b=\sum\limits_{i\in S\land i<j}i,c=\sum\limits_{i\in S\land i<j}w_i,d=\sum\limits_{i\in S\land i<j}1$$

注意：$a\ne bc$，反例可以轻松找到！这四个值可以在枚举每个 $j$ 时动态更新。每个组的答案可以 $O(|S|)$ 计算。

注意及时取模。

于是就做完了，时间复杂度 $O(n+m)$，虽然模数很小但还是要开 `long long`。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 10007
using namespace std;
int n,m,w[100001],a,b,c,d,s;
vector<int>g[100001][2];
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=1;i<=n;i++){
		cin>>c;
		g[c][i%2].push_back(i);
	}
	for(int i=1;i<=m;i++){
		a=b=c=d=0;
		sort(g[i][0].begin(),g[i][0].end());
		for(int j:g[i][0]){
			s=(s+a+w[j]*b+j*c+j*w[j]*d)%mod;
			a=(a+j*w[j])%mod;
			b=(b+j)%mod;
			c=(c+w[j])%mod;
			d=(d+1)%mod;
		}
		a=b=c=d=0;
		sort(g[i][1].begin(),g[i][1].end());
		for(int j:g[i][1]){
			s=(s+a+w[j]*b+j*c+j*w[j]*d)%mod;
			a=(a+j*w[j])%mod;
			b=(b+j)%mod;
			c=(c+w[j])%mod;
			d=(d+1)%mod;
		}
	}
	cout<<s;
	return 0;
}
```

---

## 作者：Jerrycyx (赞：0)

以下将 $number$ 简记为 $num$，$color$ 简记为 $col$。

-----

首先观察题目：

> 1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。$\longrightarrow$  _$x,y,z$ 顺序排列且间隔距离相等_ 
> 2. $col_x=col_z$。$\longrightarrow$  _$x,z$ 颜色相同_ 
> 
> 满足上述条件的三元组的分数规定为 $(x+z) \times (num_x+num_z)$。

可以发现，**三元组的分数与 $y$ 的值无关**。

接着将条件 $1$ 的式子 $y-x=z-y$ 转化一下可以得到 $x+z=2 \times y$，因为 $y$ 是整数，所以 $x+z$ 始终为偶数，也即**合法三元组中 $x$ 和 $z$ 奇偶性相同**。

-----

通过顺序枚举 $z$，设 $ans_z$ 表示以 $z$ 结尾的三元组的分数和，那么有（从第二步开始省略求和条件）：

$
\begin{aligned}
ans_z &= \textstyle \sum_{col_x=col_z} (x+z)(num_x+num_z)\\
&= \textstyle \sum(x \times num_x + z \times num_z + x \times num_z + z \times num_x)\\
&= \textstyle \sum (x \times num_x) + \sum (z \times num_z) + \sum (x \times num_z) + \sum (z \times num_x)\\
&= \textstyle \sum (x \times num_x) + \sum (z \times num_z) + num_z \times \sum x + z \times \sum num_x
\end{aligned}
$

记此前奇偶性为 $p$，颜色为 $c$ 的数的数量为 $cnt_{p,c}$，编号和为 $id_{p,c}$，$num$ 值和为 $sum_{p,c}$，$num$ 与编号的乘积和为 $tot_{p,c}$。那么上面的四个部分都可以计算了（以下略去这四个数组的下标）：

+ $\sum (x \times num_x) = tot$
+ $\sum (z \times num_z) = cnt \times z \times num_z$
+ $num_z \times \sum x = id \times num_z$
+ $z \times \sum num_x = sum \times z$

所以 $\bold{ ans_z = tot + cnt \times z \times num_z + id \times num_z + sum \times z }$，最后再用 $z$ 和 $num_z$ 更新奇偶性和颜色所对应的值即可（不能自己和自己组合，所以要先计算 $ans$ 再更新）。

时间复杂度 $O(N)$。

-----

记得开 `long long`（$z \times num_z$ 会爆 `int`）和随时取模。

核心代码：

```cpp
LL cnt[2][N],id[2][N],sum[2][N],tot[2][N];
...
for(int i=1;i<=n;i++)
{
  #define p(arr) arr[i&1][col[i]] //我很懒

  //累加 ans
  ans+=p(cnt)*i*num[i];
  ans+=p(tot);
  ans+=p(sum)*i;
  ans+=p(id)*num[i];

  //更新对应值
  p(cnt)++;
  p(tot)+=i*num[i];
  p(sum)+=num[i];
  p(id)+=i;

  //别忘了取模
  ans%=P;
  p(cnt)%=P,p(tot)%=P,p(sum)%=P,p(id)%=P;
  #undef p
}
```

[AC 记录及完整代码](https://www.luogu.com.cn/record/198646848)

---


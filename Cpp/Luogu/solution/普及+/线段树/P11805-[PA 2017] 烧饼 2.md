# [PA 2017] 烧饼 2

## 题目背景


译自 [PA 2017](https://sio2.mimuw.edu.pl/c/pa-2017-1/) R2T1。



## 题目描述

有 $n$ 个人买烧饼。第 $i$ 个人会在时刻 $t_i$ 到达。

顾客只会买新鲜出炉的烧饼。也就是说，第 $i$ 个人拿到的烧饼必须在时刻 $t_i$ 或者之后**出炉**。

有 $m$ 种烤箱，第 $i$ 种烤箱需要 $d_i$ 单位时间来烤烧饼。也就是说，如果从时刻 $a$ 开始烤烧饼，那么出炉时间为时刻 $(a+d_i)$。

对于每一种烤箱，计算：如果用**一台**这种烤箱，从 $0$ 时刻起烤烧饼，计算最优策略下顾客等待时间和的最小值。


## 说明/提示

- $1\le n,m\le 2\times 10^5$；
- $0\le t_1\le t_2\le \cdots\le t_n\le 10^{12}$；
- $1\le d_i\le 10^6$。

## 样例 #1

### 输入

```
4 3
3 10 11 23
4 2 5```

### 输出

```
4
1
6```

# 题解

## 作者：OIer_Automation (赞：2)

首先不难发现，一定有一种最优方案，使得这些人拿到烧饼的顺序就是他们来到店里的顺序。证明考虑调整，若交换顺序，要么后者无法购买前者的烧饼，要么一个人的等待时间增加 $d$，另一个人的等待时间减少 $d$，则当前方案显然不劣。

考虑设第 $i$ 人拿到烧饼的时间为 $T_i$，则显然有

$$
T_i=\max(t_i,T_{i-1}+d)
$$

因为前者是来店时间，后者是下一块烧饼做好的时间，当前时间要同时不小于两者，取最大值最优。此时答案即为

$$
\sum_{1\le i\le n}(T_i-t_i)=\sum_{1\le i\le n} T_i-\sum_{1\le i\le n} t_i
$$

考虑到 $\sum_{1\le i\le n} t_i$ 为定值，因此只考虑求解 $\sum_{1\le i\le n}T_i$。

这个最大值的形式让人恼火，因为它较为难求，不妨考虑分类讨论，即讨论什么时候 $\max$ 取前者，什么时候取后者。不难发现 $T_i=t_i$ 当且仅当

$$
t_i\ge\max_{j<i}(t_j+(i-j)d)
$$

证明是容易的，因为此时不管从什么时候开始连续制作烧饼，都无法让第 $i$ 个人立刻买到，说明 $\max$ 中只可能选择 $t_i$。考虑将做饼的区间对应到数轴上，可以看出我们的选择相当于是选择一个区间连续的制作饼，则我们上面找到的 $t_i$ 应该是一个区间的左端点。我们称这样的点 $i$ 为断点，不难发现上面的式子可以改为

$$
\begin{aligned}t_i-id\ge t_j-jd&\Rightarrow \frac{t_i-t_j}{i-j}\ge d,&&(i<j)\end{aligned}
$$

于是可以采用凸包维护，于是第 $i$ 个点成为断点当且仅当 $d$ 小于等于 $[1,i]$ 的凸包上 $i$ 和其前驱点之间的斜率。

那么此时对于一个 $d$，我们能够找出所有的断点集合 $S=\{a_0=0,a_1,\cdots,a_p,a_{p+1}=n+1\}$，考虑到相邻的两个断点之间的烧饼的制作时间应当是一个等差数列且首项为 $t_{a_i}$，公差为 $d$，项数为 $L=a_{i+1}-a_i$，则这一段的 $T_i$ 和可以快速计算：

$$
\frac{(t_i+t_i+(L-1)d)L}{2}=t_iL+\frac{d}{2}(L^2-L)
$$

注意到因为 $d$ 是已知的，所以我们只需要知道 $\sum_{0\le i\le p}t_iL,\sum_{0\le i\le p}(L^2-L)$ 即可 $O(1)$ 求解。

现在考虑如何对 $m$ 个 $d$ 求解，通过每一个点是否作为断点的单调性，我们不难想到对所有询问离线，并按照 $d$ 从小到大排序，那么随着我们枚举，会有一些点逐渐从集合中删去，我们只需要改动它和它的前驱，则改动复杂度是 $O(1)$ 的，每一个点最多被删掉 $1$ 次，则总复杂度为 $O(n)$，采用链表实现，复杂度瓶颈在排序，总复杂度 $O(n\log n)$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define ll long long
#define pil pair<int,ll>
#define fi first
#define se second

const int N=2e5+5;

int n,m,q,top;
int id[N],rk[N],d[N];
ll s1,s2;
ll t[N],_d[N],pos[N],ans[N];
pil stk[N];
struct Node{
    int pre,nxt;
}l[N];

pil operator -(pil _1,pil _2){return {_1.fi-_2.fi,_1.se-_2.se};}
ll operator *(pil _1,pil _2){return _1.fi*_2.se-_1.se*_2.fi;}
il void Insert(int i){
    pil p={i,t[i]};
    while(top&&(p-stk[top])*(p-stk[top-1])<=0)top--;
    pos[i]=upper_bound(_d+1,_d+1+m,(t[i]-stk[top].se)/(i-stk[top].fi))-_d,stk[++top]=p;
}

int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>t[i],rk[i]=i,l[i]={i-1,i+1};
    for(int i=1;i<=m;i++)cin>>d[i],_d[i]=d[i],id[i]=i;
    sort(_d+1,_d+1+m);
    for(int i=1;i<=n;i++)Insert(i);
    sort(id+1,id+1+m,[](int _1,int _2){return d[_1]<d[_2];}),sort(rk+1,rk+1+n,[](int _1,int _2){return pos[_1]<pos[_2];});
    for(int i=1,p=1;i<=m;i++){
        while(p<=n&&pos[rk[p]]==i){
            int now=rk[p++],pre=l[now].pre,nxt=l[now].nxt;
            s1+=(nxt-now)*(t[pre]-t[now]),s2+=(ll)(nxt-now)*(now-pre),l[pre].nxt=nxt,l[nxt].pre=pre;
        }
        int idx=id[i];
        ans[idx]=s1+s2*d[idx];
    }
    for(int i=1;i<=m;i++)cout<<ans[i]<<"\n";
}
```

---

## 作者：TimSwn090306 (赞：0)

提供一种常数较大的 $O(n\log d)$ 数据结构解法。

对于一个固定的烤饼花费时间 $d$，答案是好求的，可以贪心。令 $f_i$ 表示第 $i$ 个顾客拿到烧饼的时间，有转移方程 $f_i=\max\{a_i,f_{i-1}+d\}$，此时答案为 $\sum_{i=1}^n (f_i-t_i)=\sum_{i=1}^nf_i-\sum_{i=1}^n t_i$。

注意到转移方程形式比较简洁，考虑一次性求出若干的 $d$ 的答案。令 $f_{i,d}$ 表示当烤饼花费时间为 $d$ 时，第 $i$ 个顾客拿到烤饼的时间，转移方程同上，即 $f_{i,d}=\max\{a_i,f_{i-1,d}+d\}$。不难发现一次 $f_{i-1,d}$ 到 $f_{i,d}$ 的转移形如，全局斜率 $+1$，全局取 $\max$。求  $\sum_{i=1}^n f_{i,d}$ 相当于在所有修改操作结束后查询单点历史和。利用一些线段树科技或许能做？这里推荐一种比较好懂~~好写~~的做法。

首先 $f_{i,d}$ 在 $i$ 固定时，随着 $d$ 增大而增大，所以全局取 $\max$ 操作可以通过线段树上二分转化为区间推平操作。进一步的，根据经典颜色段均摊理论，每次区间推平操作只会增加 $O(1)$ 个颜色段，减少 $O(n)$ 个颜色段，所以区间推平操作可以转化为区间加操作。

令 $f_{i,d}=k_d\times d+b_d$，则上述操作可以进一步细化为：对 $k$ 区间加，对 $b$ 区间加，查询第一个 $j$ 使得 $k_j\times j+b_j> v$，普通线段树容易实现。单点历史和则可以通过求出 $k_d$ 与 $b_d$ 的历史和得到。具体的，在 $k,b$ 上的区间加可以认为是在 $k,b$ 的历史和上的区间加，区别在于加的值要额外乘上 $(n-i+1)$，其中 $i$ 表示当前正在从 $f_{i-1,d}$ 转移到 $f_{i,d}$，可以认为是一个扫描线状物。

时间复杂度 $O(n\log d)$。

```cpp
#include <bits/stdc++.h>
#define fin(str) freopen(str,"r",stdin)
#define fout(str) freopen(str,"w",stdout)
#define ll long long
#define lc(rt) ((rt)<<1)
#define rc(rt) ((rt)<<1|1)
#define pii pair<int,int>
#define fir first
#define sec second
#define P(x,y) make_pair(x,y)
using namespace std;
bool MEM_BG;

const int maxn=1e6+5;
const int rng=1e6;

int n,m,tim;
ll t[maxn];

struct node{
	int l,r,type;
	ll val;
}lin[maxn<<2];
int ltot;

namespace SGT{
	const int maxc=(maxn<<2);
	ll max_k[maxc],max_b[maxc];
	ll add_k[maxc],add_b[maxc];
	
	set <pii> st_k,st_b;
	
	inline void build(int rt,int l,int r){
		if (rt==1){
			st_k.clear();
			st_b.clear();
			st_k.insert(P(1,rng));
			st_b.insert(P(1,rng));
		}
		max_k[rt]=max_b[rt]=add_k[rt]=add_b[rt]=0;
		if (l==r) return ;
		int mid=(l+r)>>1;
		build(lc(rt),l,mid);
		build(rc(rt),mid+1,r);
	}
	
	inline void ref(int rt,ll tag_add_k,ll tag_add_b){
		if (tag_add_k){
			max_k[rt]+=tag_add_k;
			add_k[rt]+=tag_add_k;
		}
		if (tag_add_b){
			max_b[rt]+=tag_add_b;
			add_b[rt]+=tag_add_b;
		}
	}
	
	inline void pushdown(int rt){
		ref(lc(rt),add_k[rt],add_b[rt]);
		ref(rc(rt),add_k[rt],add_b[rt]);
		add_k[rt]=add_b[rt]=0;
	}
	inline void pushup(int rt){
		max_k[rt]=max_k[rc(rt)];
		max_b[rt]=max_b[rc(rt)];	
	}
	
	inline void update_k(int rt,int l,int r,int ql,int qr,ll val){
		if (rt==1){
			lin[++ltot]=(node){ql,qr,0,1ll*(n-tim+1)*val};
		}
		if (l>=ql && r<=qr){
			ref(rt,val,0);
			return ;
		}
		pushdown(rt);
		int mid=(l+r)>>1;
		if (ql<=mid) update_k(lc(rt),l,mid,ql,qr,val);
		if (qr>mid) update_k(rc(rt),mid+1,r,ql,qr,val);
		pushup(rt);
	}
	inline void update_b(int rt,int l,int r,int ql,int qr,ll val){
		if (rt==1){
			lin[++ltot]=(node){ql,qr,1,1ll*(n-tim+1)*val};
		}
		if (l>=ql && r<=qr){
			ref(rt,0,val);
			return ;
		}
		pushdown(rt);
		int mid=(l+r)>>1;
		if (ql<=mid) update_b(lc(rt),l,mid,ql,qr,val);
		if (qr>mid) update_b(rc(rt),mid+1,r,ql,qr,val);
		pushup(rt);
	}
	inline ll query_k(int rt,int l,int r,int pos){
		if (l==r) return max_k[rt];
		pushdown(rt);
		int mid=(l+r)>>1;
		if (pos<=mid) return query_k(lc(rt),l,mid,pos);
		else return query_k(rc(rt),mid+1,r,pos);
	}
	inline ll query_b(int rt,int l,int r,int pos){
		if (l==r) return max_b[rt];
		pushdown(rt);
		int mid=(l+r)>>1;
		if (pos<=mid) return query_b(lc(rt),l,mid,pos);
		else return query_b(rc(rt),mid+1,r,pos);
	}
	inline ll query(int rt,int l,int r,int pos){
		if (l==r) return max_k[rt]*l+max_b[rt];
		pushdown(rt);
		int mid=(l+r)>>1;
		if (pos<=mid) return query(lc(rt),l,mid,pos);
		else return query(rc(rt),mid+1,r,pos);
	}
	inline void cover_k(int ql,int qr,ll val){
		auto it=st_k.upper_bound(P(ql,0));
		if (it!=st_k.begin()) it--;
		while (it!=st_k.end()){
			int L=it->fir,R=it->sec; it++;
			if (L>qr) break;
			if (L>=ql && R<=qr){
				ll org=query_k(1,1,rng,L);
				update_k(1,1,rng,L,R,val-org);
				st_k.erase(P(L,R));
			}else if (L>=ql && R>qr){
				ll org=query_k(1,1,rng,L);
				update_k(1,1,rng,L,qr,val-org);
				st_k.erase(P(L,R));
				if (R>qr) st_k.insert(P(qr+1,R));
			}else if (L<ql && R<=qr){
				ll org=query_k(1,1,rng,L);
				update_k(1,1,rng,ql,R,val-org);
				st_k.erase(P(L,R));
				if (L<ql) st_k.insert(P(L,ql-1));
			}else if (L<ql && R>qr){
				ll org=query_k(1,1,rng,L);
				update_k(1,1,rng,ql,qr,val-org);
				st_k.erase(P(L,R));
				if (L<ql) st_k.insert(P(L,ql-1));
				if (R>qr) st_k.insert(P(qr+1,R));
			}
		}
		st_k.insert(P(ql,qr));
	}
	inline void cover_b(int ql,int qr,ll val){
		auto it=st_b.upper_bound(P(ql,0));
		if (it!=st_b.begin()) it--;
		while (it!=st_b.end()){
			int L=it->fir,R=it->sec; it++;
			if (L>qr) break;
			if (L>=ql && R<=qr){
				ll org=query_b(1,1,rng,L);
				update_b(1,1,rng,L,R,val-org);
				st_b.erase(P(L,R));
			}else if (L>=ql && R>qr){
				ll org=query_b(1,1,rng,L);
				update_b(1,1,rng,L,qr,val-org);
				st_b.erase(P(L,R));
				if (R>qr) st_b.insert(P(qr+1,R));
			}else if (L<ql && R<=qr){
				ll org=query_b(1,1,rng,L);
				update_b(1,1,rng,ql,R,val-org);
				st_b.erase(P(L,R));
				if (L<ql) st_b.insert(P(L,ql-1));
			}else if (L<ql && R>qr){
				ll org=query_b(1,1,rng,L);
				update_b(1,1,rng,ql,qr,val-org);
				st_b.erase(P(L,R));
				if (L<ql) st_b.insert(P(L,ql-1));
				if (R>qr) st_b.insert(P(qr+1,R));
			}
		}
		st_b.insert(P(ql,qr));
	}
	inline int search(int rt,int l,int r,ll val){// note : fir > val
		if (l==r){
			if (max_k[rt]*l+max_b[rt]>val) return l;
			else return -1;
		}
		pushdown(rt);
		int mid=(l+r)>>1;
		if (max_k[lc(rt)]*mid+max_b[lc(rt)]>val) return search(lc(rt),l,mid,val);
		else return search(rc(rt),mid+1,r,val);
	}
};

ll sum,ans[maxn];

bool MEM_ED;
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%lld",&t[i]),sum+=t[i];
	
	SGT::build(1,1,rng);
	for (int i=1;i<=n;i++){
		tim++;
		SGT::update_k(1,1,rng,1,rng,1);
		int pos=SGT::search(1,1,rng,t[i]);
		
		if (pos==-1){
			SGT::cover_k(1,rng,0);
			SGT::cover_b(1,rng,t[i]);
		}else{
			if (pos-1>=1){
				SGT::cover_k(1,pos-1,0);
				SGT::cover_b(1,pos-1,t[i]);
			}
		}
	}
	
	SGT::build(1,1,rng);
	int mem=ltot;
	for (int i=1;i<=mem;i++){
		if (!lin[i].type) SGT::update_k(1,1,rng,lin[i].l,lin[i].r,lin[i].val);
		else SGT::update_b(1,1,rng,lin[i].l,lin[i].r,lin[i].val);
	}
	
	for (int i=1,x;i<=m;i++){
		scanf("%d",&x);
		printf("%lld\n",SGT::query(1,1,rng,x)-sum);
	}
	
	cerr<<"Memory : "<<1.0*abs(&MEM_ED-&MEM_BG)/1048576<<" MB\n";
	return 0;
}
```

---


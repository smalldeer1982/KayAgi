# 扶苏的问题

## 题目描述

给定一个长度为 $n$ 的序列 $a$，要求支持如下三个操作：

1. 给定区间 $[l, r]$，将区间内每个数都修改为 $x$。
2. 给定区间 $[l, r]$，将区间内每个数都加上 $x$。
3. 给定区间 $[l, r]$，求区间内的最大值。

## 说明/提示

### 数据规模与约定

- 对于 $10\%$ 的数据，$n = q = 1$。
- 对于 $40\%$ 的数据，$n, q \leq 10^3$。
- 对于 $50\%$ 的数据，$0 \leq a_i, x \leq 10^4$。
- 对于 $60\%$ 的数据，$op \neq 1$。
- 对于 $90\%$ 的数据，$n, q \leq 10^5$。
- 对于 $100\%$ 的数据，$1 \leq n, q \leq 10^6$，$1 \leq l, r \leq n$，$op \in \{1, 2, 3\}$，$|a_i|, |x| \leq 10^9$。

### 提示

请注意大量数据读入对程序效率造成的影响。

## 样例 #1

### 输入

```
6 6
1 1 4 5 1 4
1 1 2 6
2 3 4 2
3 1 4
3 2 3
1 1 6 -1
3 1 6
```

### 输出

```
7
6
-1```

## 样例 #2

### 输入

```
4 4
10 4 -3 -7
1 1 3 0
2 3 4 -4
1 2 4 -9
3 1 4```

### 输出

```
0```

# 题解

## 作者：一扶苏一 (赞：172)

这里是咕了好久的官方题解。

## P1253

简单的线段树模板题。

使用两个 tag，t1 表示区间赋值，t2 表示区间加。加法打标记时若赋值标记存在则直接给赋值标记加上对应值，不修改加标记，否则修改加标记；打赋值标记时先清空加标记即可。

在实现时，区间赋值和区间加的两个 update 函数找节点的过程是相同的，区别只在 make_tag 过程。因此可以把这两个操作的 update 函数写成一个，另加一个参数表示操作类型是赋值还是加法即可。

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <iostream>

typedef long long int ll;

const int maxn = 1000006;

ll nul = 1e18;

int n, q;
int a[maxn];

struct Node {
  int l, r;
  ll w, t1, t2;
  Node *ls, *rs;

  void make_tag1(ll x) {
    w = t1 = x;
    t2 = 0;
  }

  void make_tag2(ll x) {
    w += x;
    if (t1 != nul)
      t1 += x;
    else
      t2 += x;
  }

  void pushdown() {
    if (t1 != nul) {
      ls->make_tag1(t1);
      rs->make_tag1(t1);
      t1 = nul;
    } else if (t2) {
      ls->make_tag2(t2);
      rs->make_tag2(t2);
      t2 = 0;
    }
  }

  void pushup() { w = std::max(ls->w, rs->w); }

  bool InRange(int L, int R) { return (L <= l) && (r <= R); }
  bool OutofRange(int L, int R) { return (l > R) || (r < L); }

  void upd(int L, int R, int x, int op) {
    if (InRange(L, R)) {
      if (op == 1)
        make_tag1(x);
      else
        make_tag2(x);
    } else if (!OutofRange(L, R)) {
      pushdown();
      ls->upd(L, R, x, op);
      rs->upd(L, R, x, op);
      pushup();
    }
  }

  ll qry(int L, int R) {
    if (InRange(L, R))
      return w;
    else if (!OutofRange(L, R)) {
      pushdown();
      return std::max(ls->qry(L, R), rs->qry(L, R));
    } else
      return -nul;
  }
};

Node Mem[maxn << 1], *pool = Mem;

Node* New(int L, int R) {
  auto u = pool++;
  u->l = L;
  u->r = R;
  u->t1 = nul;
  u->t2 = 0;
  if (L != R) {
    int M = (L + R) >> 1;
    u->ls = New(L, M);
    u->rs = New(M + 1, R);
    u->pushup();
  } else {
    u->w = a[L];
  }
  return u;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  std::cout.tie(0);
  std::cin >> n >> q;
  for (int i = 1; i <= n; ++i) {
    std::cin >> a[i];
  }
  auto rot = New(1, n);
  for (int op, l, r, x; q; --q) {
    std::cin >> op >> l >> r;
    if (op != 3) {
      std::cin >> x;
      rot->upd(l, r, x, op);
    } else {
      std::cout << rot->qry(l, r) << '\n';
    }
  }
  return 0;
}
```



---

## 作者：hewo (赞：97)

update 2021.11.6：更新了关于 covertag 的错误。

线段树基础好题，可以更深入的理解 pushdown 操作。

我们发现这里有两种 pushdown。定义 $covertag$ 表示修改（覆盖）操作， $sumtag$ 表示增加操作。那么怎么修改呢？

对于 $coverdown$ 时我们就直接抹掉 $sumtag$（人都没了还增加什么）。对于 $sumdown$ 时我们就先 $covertag$ 下放（只要跑得快，add 就永远慢一线）。

代码就是：

```cpp
inline void coverdown(LL now)
{
	if(tree[now].covertag)
	{
		tree[lson].sumtag=tree[rson].sumtag=0;
		tree[lson].maxn=tree[rson].maxn=tree[now].covertag;
		tree[lson].covertag=tree[rson].covertag=tree[now].covertag;
		tree[now].covertag=0;
	}
}

inline void sumdown(LL now)
{
	if(tree[now].sumtag)
	{
		coverdown(now);
		tree[lson].maxn+=tree[now].sumtag,tree[rson].maxn+=tree[now].sumtag;
		tree[lson].sumtag+=tree[now].sumtag,tree[rson].sumtag+=tree[now].sumtag;
		tree[now].sumtag=0;
	}
}
```

对于常规的 pushdown 操作，两个都做一次就好了。

画个图来理解一下：

![一开始的线段树](https://cdn.luogu.com.cn/upload/image_hosting/p929588j.png)

对 $[1,5]$ 进行覆盖修改。

![红色是 $cover$ ](https://cdn.luogu.com.cn/upload/image_hosting/letjuksq.png)

按照懒标记的规则，不处理时就不会更新。

现在再在 $[1,5]$ 之间进行添加操作。

![绿色是 $add$ ](https://cdn.luogu.com.cn/upload/image_hosting/bgoujfmv.png)

这里就将 $covertag$ 下放了，就不可能出现覆盖影响了添加的情况了。

如果查询 $[1,2]$ 的 ，层层递归下放即可，与常规做法一致。

![黄色是查询区间](https://cdn.luogu.com.cn/upload/image_hosting/l2smhjrx.png)

这样整个题就完了。其实这个做法的下放操作是有重复的（大家可以自己想一下），但是这样讲最容易理解也最符合直观感受。反正也只是常数稍微大了一点点（线段树才不差这点常数呢），就不优化了。

还有一个易错点就是关于 covertag 判断是否存在，如果使用 0 的话，出现覆盖值为 0 的情况，就会出锅（此题数据过水）。我们可以专门构造一个特殊值来进行维护。

放上代码辅助理解，马蜂不正请见谅。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MX=1*1000000+10;
#define LL long long
#define inf 1e15

#define lson now<<1
#define rson now<<1|1

#define none -1145141919180
//这个来判断究竟存不存在 covertag

inline LL read()
{
    LL x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}

LL n,Q;
LL w[MX];

struct tTree
{
	LL covertag;
	LL sumtag;
	LL maxn;
}tree[MX<<2];

inline void pushup(LL now)
{
	tree[now].maxn=max(tree[lson].maxn,tree[rson].maxn);
}

inline void coverdown(LL now)
{
	if(tree[now].covertag!=-1145141919810)
	{
		//printf("WTH\n");
		tree[lson].sumtag=tree[rson].sumtag=0;
		tree[lson].maxn=tree[rson].maxn=tree[now].covertag;
		tree[lson].covertag=tree[rson].covertag=tree[now].covertag;
		tree[now].covertag=-1145141919810;
	}
}

inline void sumdown(LL now)
{
	if(tree[now].sumtag)
	{
		coverdown(now);
		tree[lson].maxn+=tree[now].sumtag,tree[rson].maxn+=tree[now].sumtag;
		tree[lson].sumtag+=tree[now].sumtag,tree[rson].sumtag+=tree[now].sumtag;
		tree[now].sumtag=0;
	}
}

inline void pushdown(LL now)
{
	coverdown(now),sumdown(now);
}

inline void build(LL now,LL l,LL r)
{
	if(l==r)
	{
		tree[now].maxn=w[l];
		tree[now].covertag=-1145141919810;
		tree[now].sumtag=0;
		return ;
	}
	LL mid=(l+r)>>1;
	build(lson,l,mid),build(rson,mid+1,r);
	pushup(now);
}

inline void tree_add(LL now,LL l,LL r,LL nl,LL nr,LL k)
{
	if(nl<=l&&nr>=r)
	{
		coverdown(now);
		tree[now].maxn+=k;
		tree[now].sumtag+=k;
		return ;
	}
	pushdown(now);
	LL mid=(l+r)>>1;
	if(nl<=mid) tree_add(lson,l,mid,nl,nr,k);
	if(nr>=mid+1) tree_add(rson,mid+1,r,nl,nr,k);
	pushup(now);
} 

inline void cover_add(LL now,LL l,LL r,LL nl,LL nr,LL k)
{
	if(nl<=l&&nr>=r)
	{
		tree[now].sumtag=0;
		tree[now].maxn=k;
		tree[now].covertag=k;
		return ;
	}
	pushdown(now);
	LL mid=(l+r)>>1;
	if(nl<=mid) cover_add(lson,l,mid,nl,nr,k);
	if(nr>=mid+1) cover_add(rson,mid+1,r,nl,nr,k);
	pushup(now);
}

inline LL get_max(LL now,LL l,LL r,LL nl,LL nr)
{
	if(nl<=l&&nr>=r)
	{
		return tree[now].maxn;
	}
	pushdown(now);
	LL mid=(l+r)>>1;
	LL res=-inf;
	if(nl<=mid) res=max(res,get_max(lson,l,mid,nl,nr));
	if(nr>=mid+1) res=max(res,get_max(rson,mid+1,r,nl,nr));
	return res;
}

int main(int argc, char const *argv[])
{
	n=read(),Q=read();
	for(LL i=1;i<=n;i++) w[i]=read();
	build(1,1,n);
	for(int i=1;i<=n*4;i++) tree[i].covertag=-1145141919810;
	while(Q--)
	{
		LL pos,l,r;
		pos=read(),l=read(),r=read();
		if(pos==1)
		{
			LL k=read();
			cover_add(1,1,n,l,r,k);
		}
		else if(pos==2)
		{
			LL k=read();
			tree_add(1,1,n,l,r,k);
		}
		else
		{
			printf("%lld\n",get_max(1,1,n,l,r));
		}
	}
	return 0;
}
```

---

## 作者：Autisia (赞：79)

我个人认为此题比较适合提高组选手练手，主要需要想清楚如何下放懒标记。

对此我们来分析一下：

1.结构体里要存什么：

```cpp
struct SGT{
	LL tag1,tag2;
	LL max_;
	int l,r;
	bool used;
}tree[N<<2];
```

此处有两个标记分别是操作一和二，布尔变量代表有没有一操作需下方。

2.考虑如何下放标记：

```cpp
void pushdown(int p){
	if(tree[p].used){
		tree[p<<1].tag1=tree[p].tag1;
		tree[p<<1|1].tag1=tree[p].tag1;
		tree[p<<1].tag2=tree[p].tag2;
		tree[p<<1|1].tag2=tree[p].tag2; 
		tree[p<<1].max_=tree[p].tag1+tree[p].tag2;
		tree[p<<1|1].max_=tree[p].tag1+tree[p].tag2;
		tree[p<<1].used=tree[p<<1|1].used=1;
	}else{
		tree[p<<1].tag2+=tree[p].tag2;
		tree[p<<1|1].tag2+=tree[p].tag2;
		tree[p<<1].max_+=tree[p].tag2;
		tree[p<<1|1].max_+=tree[p].tag2;
	}
	tree[p].used=tree[p].tag1=tree[p].tag2=0;
}
```

如果有一标记，则此时子节点其前面保存的值都会被覆盖：

1.子节点原本的一，二标记都删除并被赋值

2.子节点的最值应为赋值标记+增加标记的和

3.记得标记布尔值

否则，按区间加模板实现。

最后记得将原节点清空

以上就是对懒标记下放的分析。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
typedef long long LL;
struct SGT{
	LL tag1,tag2;
	LL max_;
	int l,r;
	bool used;
}tree[N<<2];
int n,m;
LL a[N];
void pushup(int p){
	tree[p].max_=max(tree[p<<1].max_,tree[p<<1|1].max_);
}
void pushdown(int p){
	if(tree[p].used){
		tree[p<<1].tag1=tree[p].tag1;
		tree[p<<1|1].tag1=tree[p].tag1;
		tree[p<<1].tag2=tree[p].tag2;
		tree[p<<1|1].tag2=tree[p].tag2; 
		tree[p<<1].max_=tree[p].tag1+tree[p].tag2;
		tree[p<<1|1].max_=tree[p].tag1+tree[p].tag2;
		tree[p<<1].used=tree[p<<1|1].used=1;
	}else{
		tree[p<<1].tag2+=tree[p].tag2;
		tree[p<<1|1].tag2+=tree[p].tag2;
		tree[p<<1].max_+=tree[p].tag2;
		tree[p<<1|1].max_+=tree[p].tag2;
	}
	tree[p].used=tree[p].tag1=tree[p].tag2=0;
}
void build(int p,int l,int r){
	tree[p].l=l,tree[p].r=r;
	tree[p].max_=-1e18;
	if(l==r){
		tree[p].max_=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);
}
void change(int p,int l,int r,LL vl){
	if(l<=tree[p].l&&tree[p].r<=r){
		tree[p].tag1=vl;
		tree[p].tag2=0;
		tree[p].max_=vl;
		tree[p].used=1;
		return;
	}
	pushdown(p);
	int mid=(tree[p].l+tree[p].r)>>1;
	if(l<=mid) change(p<<1,l,r,vl);
	if(mid+1<=r) change(p<<1|1,l,r,vl);
	pushup(p);
}
void update(int p,int l,int r,LL vl){
	if(l<=tree[p].l&&tree[p].r<=r){
		tree[p].tag2+=vl;
		tree[p].max_+=vl;
		return;
	}
	pushdown(p);
	int mid=(tree[p].l+tree[p].r)>>1;
	if(l<=mid) update(p<<1,l,r,vl);
	if(mid+1<=r) update(p<<1|1,l,r,vl);
	pushup(p);
}
LL query(int p,int l,int r){
	if(l<=tree[p].l&&tree[p].r<=r){
		return tree[p].max_;
	}
	pushdown(p);
	int mid=(tree[p].l+tree[p].r)>>1;
	LL res=-1e18;
	if(l<=mid) res=max(res,query(p<<1,l,r));
	if(mid+1<=r) res=max(res,query(p<<1|1,l,r));
	return res;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int opt,l,r;
		LL vl;
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1||opt==2) scanf("%lld",&vl);
		if(opt==1){
			change(1,l,r,vl);
		}else if(opt==2) update(1,l,r,vl);
		else printf("%lld\n",query(1,l,r));
	}
	return 0;
}

```

如有错误，请在评论区提出或私聊。

   


---

## 作者：wangzhiyuan123 (赞：32)

问题核心在于如何区间修改   
我们新开一个懒标记，记录区间修改后的值   
把这个懒标记记录为一个特殊的值，下传的时候，如果这个点没标记，即记录的值为设定的特殊值时，就不用下传了，表示已经下传过或者没有标记。   
需要注意，当下传新的懒标记的时候，需要清空板子里表示增加的懒标记   
具体内容详见注释
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lc(x) x<<1
#define rc(x) x<<1|1
int n,q;
const int inf=1145141919810;//特殊的值 
class xds{
	public:
	int a[1000005],tr[4000005],tag[4000005],mdf[4000005];//tag是表示增加的懒标记，mdf表示修改的懒标记 
	void push_tag(int x){
		tag[lc(x)]+=tag[x],tr[lc(x)]+=tag[x];
		tag[rc(x)]+=tag[x],tr[rc(x)]+=tag[x];
		tag[x]=0;
	}
	void push_mdf(int x){
		if(mdf[x]!=inf){//如果没有下传并且有标记，才会下传 
			tr[lc(x)]=mdf[lc(x)]=mdf[x],tag[lc(x)]=0;
			tr[rc(x)]=mdf[rc(x)]=mdf[x],tag[rc(x)]=0;
			mdf[x]=inf;
		}
	}
	void build(int x,int l,int r){
		mdf[x]=inf;
		if(l==r){
			tr[x]=a[l];
			return;
		}
		int mid=(l+r)>>1;
		build(lc(x),l,mid);build(rc(x),mid+1,r);
		tr[x]=max(tr[lc(x)],tr[rc(x)]); 
	}
	void add(int x,int l,int r,int ql,int qr,int v){
		if(ql<=l&&qr>=r){
			tr[x]+=v;tag[x]+=v;
			return;
		}
		push_mdf(x);//push_down次序如果错了，就会清空tag数组 
		push_tag(x);
		int mid=(l+r)>>1;
		if(ql<=mid) add(lc(x),l,mid,ql,qr,v);
		if(qr>mid) add(rc(x),mid+1,r,ql,qr,v);
		tr[x]=max(tr[lc(x)],tr[rc(x)]);
	}
	void modify(int x,int l,int r,int ql,int qr,int v){
		if(ql<=l&&qr>=r){
			tr[x]=mdf[x]=v;
			tag[x]=0;
			return;
		}
		push_mdf(x);
		push_tag(x);
		int mid=(l+r)>>1;
		if(ql<=mid) modify(lc(x),l,mid,ql,qr,v);
		if(qr>mid) modify(rc(x),mid+1,r,ql,qr,v);
		tr[x]=max(tr[lc(x)],tr[rc(x)]);
	}
	int query(int x,int l,int r,int ql,int qr){
		if(ql<=l&&qr>=r) return tr[x];
		push_mdf(x);
		push_tag(x);
		int mid=(l+r)>>1,sm=-inf;
		if(ql<=mid) sm=max(sm,query(lc(x),l,mid,ql,qr));
		if(qr>mid) sm=max(sm,query(rc(x),mid+1,r,ql,qr));
		return sm;
	}
}tre;
main(){
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++) scanf("%lld",&tre.a[i]);
	tre.build(1,1,n);
	for(int i=1,op,l,r,x;i<=q;i++){
		scanf("%lld%lld%lld",&op,&l,&r);
		if(op==1){
			scanf("%lld",&x);
			tre.modify(1,1,n,l,r,x);
		}else{
			if(op==2){
				scanf("%lld",&x);
				tre.add(1,1,n,l,r,x);
			}else{
				printf("%lld\n",tre.query(1,1,n,l,r));
			}
		}
	}
}
```


---

## 作者：HerikoDeltana (赞：22)

## 「思路简述」

一道比较板的线段树吧，比较适合新手拿来练手。

题意非常清楚了，简单来说就是需要一种支持区间查询和区间修改的数据结构，那么很自然的就能想到用线段树来解决。

因为有两种区间修改的操作，所以我们需要两个 Tag，下传的操作和正常的区间加没有太多区别，只不过需要注意在下传时，要先传 Cover 操作再下传 Add 操作。

## 「Code」

因为每次操作的 $x \le 10^9$，所以注意要开 `long long` 和 `INF` 值的大小。

前面的学长提供了指针的写法，我这里则是相对普通的数组写法。

```cpp
#include <iostream>
#include <stdio.h>
#include <cmath>
#include <algorithm>
#include <cstring>

#define lc(x) (x<<1)
#define rc(x) (x<<1|1)
#define Heriko return
#define Deltana 0
#define Romanno 1
#define S signed
#define LL long long
#define R register
#define I inline
#define CI const int
#define mst(a, b) memset(a, b, sizeof(a))
#define ON std::ios::sync_with_stdio(false);cin.tie(0)
#define Files() freopen("RNMTQ.in","r",stdin);freopen("RNMTQ.out","w",stdout)

using namespace std;

template<typename J>
I void fr(J &x)
{
    short f(1);x=0;char c=getchar();

    while(c<'0' or c>'9')
    {
        if(c=='-') f=-1;
        
        c=getchar();
    }

    while (c>='0' and c<='9') 
    {
        x=(x<<3)+(x<<1)+(c^=48);
        c=getchar();
    }
   
    x*=f;
}

template<typename J>
I void fw(J x,bool k)
{
    if(x<0) x=-x,putchar('-');

    static short stak[35];short top(0);

    do
    {
        stak[top++]=x%10;
        x/=10;
    }
    while(x);
    while(top) putchar(stak[--top]+'0');

    k?puts(""):putchar(' ');
}

template<typename J>
I J Hmax(const J &x,const J &y) {Heriko x>y?x:y;}

const LL MXX(1e6+1),INF(1e12);

int n,q;

struct Node
{
    int l,r;LL mx,tg1,tg2;
}

t[MXX<<2];

I void Pushup(int x) {t[x].mx=Hmax(t[lc(x)].mx,t[rc(x)].mx);}

I void Pushdown(int x)
{
    if(t[x].tg2!=INF)
    {
        t[lc(x)].tg1=0;
        t[lc(x)].tg2=t[x].tg2;
        t[lc(x)].mx=t[x].tg2;
        t[rc(x)].tg1=0;
        t[rc(x)].tg2=t[x].tg2;
        t[rc(x)].mx=t[x].tg2;
        t[x].tg2=INF;
    }

    if(t[x].tg1)
    {
        t[lc(x)].tg1+=t[x].tg1;
        t[lc(x)].mx+=t[x].tg1;
        t[rc(x)].tg1+=t[x].tg1;
        t[rc(x)].mx+=t[x].tg1;
        t[x].tg1=0;
    }
}

void Build(int x,int l,int r)
{
    t[x].l=l,t[x].r=r;t[x].mx=t[x].tg1=0;t[x].tg2=INF;

    if(l==r)
    {
        fr(t[x].mx);

        Heriko;
    }

    int mid((l+r)>>1);
    Build(lc(x),l,mid);Build(rc(x),mid+1,r);
    Pushup(x);
}

void ModifyAdd(int x,int lx,int rx,LL v)
{
    if(lx<=t[x].l and t[x].r<=rx)
    {
        t[x].tg1+=v;t[x].mx+=v;

        Heriko;
    }

    Pushdown(x);
    int mid((t[x].l+t[x].r)>>1);

    if(lx<=mid) ModifyAdd(lc(x),lx,rx,v);
    
    if(rx>mid) ModifyAdd(rc(x),lx,rx,v);

    Pushup(x);
}

void ModifyChange(int x,int lx,int rx,LL v)
{
    if(lx<=t[x].l and t[x].r<=rx)
    {
        t[x].tg1=0;t[x].tg2=v;t[x].mx=v;

        Heriko;
    }

    Pushdown(x);
    int mid((t[x].l+t[x].r)>>1);

    if(lx<=mid) ModifyChange(lc(x),lx,rx,v);
    
    if(rx>mid) ModifyChange(rc(x),lx,rx,v);

    Pushup(x);
}

LL Query(int x,int lx,int rx)
{
    if(lx<=t[x].l and t[x].r<=rx) Heriko t[x].mx;

    LL res(-INF);int mid((t[x].l+t[x].r)>>1);

    Pushdown(x);

    if(lx<=mid) res=Hmax(Query(lc(x),lx,rx),res);
    
    if(rx>mid) res=Hmax(Query(rc(x),lx,rx),res);

    Heriko res;
}

S main()
{
    fr(n),fr(q);Build(1,1,n);

    while(q--)
    {
        int opt,l,r;LL x;
        fr(opt),fr(l),fr(r);

        if(opt==1) fr(x),ModifyChange(1,l,r,x);
        else if(opt==2) fr(x),ModifyAdd(1,l,r,x);
        else fw(Query(1,l,r),1);
    }
    
    Heriko Deltana;
}
```

如有错误之处请各位大佬及时指出。

---

## 作者：比利♂海灵顿 (赞：10)

# yLOI2018 扶苏的问题

线段树训练题

## 题意

维护序列，要求支持区间赋值，区间增量，查询区间最值。

## 线段树

前置知识: [线段树](https://www.luogu.com.cn/problem/P3372)

区间修改，区间查询问题首先想到线段树，只是这里的线段树和普通的线段树不同，因为它有两种修改。

每个节点对区间赋值维护一个标记 $Val$，如果它不是 $\infty$ 那么就表示这个节点所代表的区间全部被赋成 $Val$ 了。

每个节点对区间增量维护一个标记 $Tag$，表示这个点的区间在上一次下传后被增加了 $Tag$。

两个标记优先级不同，新打的 $Val$ 可以覆盖掉之前的 $Tag$，但是新打的 $Tag$ 不能覆盖之前的 $Val$，只能叠加在 $Val$ 上，使实际权值变成 $Val + Tag$。

上面两个值是通过标记下传维护的。

接下来需要有一个值 $Mx$，表示这个节点表示区间的最大值，这个值需要通过上传维护，一个叶节点的 $Mx$ 就是它代表单点的值，一个非叶节点的 $Mx$ 是它两个儿子的 $Mx$ 的最大值。

## 代码实现

这三种操作的递归方式和普通线段树完全相同。过程中一定要注意两个标记的优先顺序。

值得注意的是，本题的数据中，$x$ 的绝对值是 $10^9$ 的，操作数是 $10^6$，也就是说单点的值可能会爆 `int`，所以用 `long long` 存储。

这种数据结构非常适合用指针写，所以这里的代码使用了指针，不要抗拒指针，学会指针对于之后学高级数据结构来说是一劳永逸的。

接下来是代码，省略了头文件和快读。

```cpp
#define Wild_Donkey 0
#define INF 0x3f3f3f3f3f3f3f3f
long long Ans(0), C, a[2000005];
unsigned m, n, A, B, D;
struct Node {
  Node* LS, * RS;
  long long Mx, Val, Tag;
  inline void PsDw () {
    if(Val != INF) {
      LS->Mx = RS->Mx = LS->Val = RS->Val = Val + Tag;
      LS->Tag = RS->Tag = Tag = 0;
      Val = INF;
    } else {
      if(Tag) {
        LS->Mx += Tag, RS->Mx += Tag;
        LS->Tag += Tag, RS->Tag += Tag;
        Tag = 0;
      }
    }
  }
  inline void Chg (unsigned L, unsigned R) {
    if((A <= L) && (R <= B)) {Tag = 0, Mx = Val = C;return;}
    unsigned Mid((L + R) >> 1);
    PsDw();
    if(A <= Mid) LS->Chg(L, Mid);
    if(B > Mid) RS->Chg(Mid + 1, R);
    Mx = max(LS->Mx, RS->Mx);
  }
  inline void Inc (unsigned L, unsigned R) {
    if((A <= L) && (R <= B)) {Mx += C, Tag += C;return;}
    unsigned Mid((L + R) >> 1);
    PsDw();
    if(A <= Mid) LS->Inc(L, Mid);
    if(B > Mid) RS->Inc(Mid + 1, R);
    Mx = max(LS->Mx, RS->Mx);
  }
  inline void Qry (unsigned L, unsigned R) {
    if((A <= L) && (R <= B)) {Ans = max(Ans, Mx);return;}
    unsigned Mid((L + R) >> 1);
    PsDw();
    if(A <= Mid) LS->Qry(L, Mid);
    if(B > Mid) RS->Qry(Mid + 1, R);
  }
}N[2000005], * CntN(N);
inline void Build(Node* x, unsigned L, unsigned R) {
  x->Val = INF, x->Tag = 0;
  if(L == R) {x->Mx = x->Val = a[L]; return;}
  unsigned Mid((L + R) >> 1);
  Build(x->LS = ++CntN, L, Mid);
  Build(x->RS = ++CntN, Mid + 1, R);
  x->Mx = max(x->LS->Mx, x->RS->Mx);
}
signed main() {
  n = RD(), m = RD();
  for (unsigned i(1); i <= n; ++i) a[i] = RDsg();
  Build(N, 1, n);
  for (unsigned i(1); i <= m; ++i) {
    D = RD(), A = RD(), B = RD();
    if(D ^ 3) {
      C = RDsg();
      if(D ^ 1) N->Inc(1, n);
      else N->Chg(1, n);
    } else {
      Ans = -INF, N->Qry(1, n);
      printf("%lld\n", Ans);
    }
  }
  return Wild_Donkey;
}
```

---

## 作者：一铭君一 (赞：8)

# yLOI 2018 扶苏的问题

响应咕咕的号召，来发一篇题解。

由于线段树的做法已经由[比利♂海灵顿](https://www.luogu.com.cn/blog/Wild-Donkey/yloi2018-fu-su-di-wen-ti)讲解过了，我来补充一个平衡树的题解。

前置知识：[平衡树](https://www.cnblogs.com/zaza-zt/p/15058882.html)。

## 题意

给定一个序列，要求写一个数据结构，维护区间加、区间赋值、区间求最大。

## 平衡树

这里请允许我假设读者已经了解了伸展树树的基本操作。

我们知道，伸展树可以方便的通过“伸展”操作随意的得到我们想要的区间（在树上表示为一个子树）。于是，剩下的问题就是对子树做修改以及查询。

### 维护最大值

在每个节点内维护一个 max，表示这个节点子树内的最大值。

和线段树不同的是，平衡树上非叶子节点也表示了某个位置的信息。当我们和并两个子树内的信息的时候不要忘了统计节点本身的信息。

代码：

```cpp
x->max=std::max(x->val,std::max(x->son[0]->max,x->son[1]->max));
//这个子树内的最大值=max(左儿子最大值，右儿子最大值，本节点值)
```

### 修改

类似线段树，我们对修改操作也需要打一个标记（毕竟每次下传到叶子节点实在是太慢了）。这里有两种修改操作，我们就维护两个标记：

* Add 标记

	这个标记是表示要把子树内所有节点的值加上 Add。
   
   显然修改完了之后，这个子树内的最大值应该是 max+Add。

* Change 标记

	这个标记是表示要把这个节点子树内所有节点赋值为 Change。
   
   既然所有值都被赋值为 Change，子树内最大值自然就是 Change。
   
   注意：如果我们给一个节点打上 Change 标记，那么这个节点的 Add 标记就全都失效了。因为这些 Add 标记是在这次赋值之前创建的。赋值之后，之前的 Add 标记显然对每个节点的值和 max 没有影响了。
   
有了标记，还要下传这些标记。

当一个节点同时拥有 Change 标记 和 Add 标记的时候，根据上面在 Change 标记中提到的，这些 Add 标记一定是在 Change 标记之后被创建的。那么我们应该根据修改顺序下传这些标记，即：先下传 Change，后下传 Add。

```cpp
//对 x 子树打 Change 标记
inline void ModifyValue(SplayTree *x,const int w){
  x->max=x->val=w;
  x->tag1=w;//赋值标记
  x->tag2=0;//清掉 Add 标记
}
//对 x 子树打 Add 标记
inline void ModifyAdd(SplayTree *x,const int w){
  x->max+=w;//修改最大值
  x->val+=w;//维护本节点的信息
  x->tag2+=w;//创建 Add 标记（多个 Add 标记可以合并）
}
inline void PushDown(SplayTree *x){
//先 Change ，后 Add
  if(x->tag1!=infinity){
    if(x->son[0]!=null) ModifyValue(x->son[0],x->tag1);
    if(x->son[1]!=null) ModifyValue(x->son[1],x->tag1);
    x->tag1=infinity;
  }
  if(x->tag2){
    if(x->son[0]!=null) ModifyAdd(x->son[0],x->tag2);
    if(x->son[1]!=null) ModifyAdd(x->son[1],x->tag2);
    x->tag2=0;
  }
}
```

### 构建平衡树

用“笛卡尔树”可以 $O(n)$ 创建一棵平衡树，不过这里 $O(n\log n)$ 足矣。

每次在中序遍历的最后一个节点（虚节点）左儿子插入新的节点。

## $\text{Talk is cheap,show you the code.}$

```cpp
const int infinity=1e18;
const int maxn=1000005;
#define int long long


int n,q;
struct SplayTree{
  int val,max,siz;
  int tag1,tag2;
  SplayTree *son[2],*fa;
}node[maxn],*pool=node,*null,*root;

inline void NewNode(const int w,SplayTree *fa){
  SplayTree *p=++pool;
  *p=(SplayTree){w,w,1,infinity,0,null,null,fa};
  fa->son[0]=p;
}
//创建新节点，父亲为 fa ，fa 的左儿子是新节点
inline void Update(SplayTree *x){
  x->siz=x->son[0]->siz+x->son[1]->siz+1;
  x->max=std::max(x->val,std::max(x->son[0]->max,x->son[1]->max));
}
//维护子树大小，维护最大值
inline void ModifyValue(SplayTree *x,const int w){
  x->max=x->val=w;
  x->tag1=w;
  x->tag2=0;
}
inline void ModifyAdd(SplayTree *x,const int w){
  x->max+=w;
  x->val+=w;
  x->tag2+=w;
}
inline void PushDown(SplayTree *x){
  if(x->tag1!=infinity){
    if(x->son[0]!=null) ModifyValue(x->son[0],x->tag1);
    if(x->son[1]!=null) ModifyValue(x->son[1],x->tag1);
    x->tag1=infinity;
  }
  if(x->tag2){
    if(x->son[0]!=null) ModifyAdd(x->son[0],x->tag2);
    if(x->son[1]!=null) ModifyAdd(x->son[1],x->tag2);
    x->tag2=0;
  }
}
inline SplayTree *Find(int k){
  SplayTree *x=root;
  while(1){
    PushDown(x);
    if(x->son[0]->siz>=k)
      x=x->son[0];
    else{
      k-=(x->son[0]->siz+1);
      if(k==0) return x;
      else x=x->son[1];
    }
  }
}
//找到第 k 名
inline bool GetWhich(SplayTree *x){
  return x->fa->son[1]==x;
}
inline void Rotate(SplayTree *x){
  SplayTree *y=x->fa,*z=y->fa;
  int k=GetWhich(x);
  SplayTree *w=x->son[!k];
  if(z!=null) z->son[GetWhich(y)]=x; x->son[!k]=y,y->son[k]=w;
  if(w!=null) w->fa=y; y->fa=x,x->fa=z;
  Update(y),Update(x);
}
inline void Splay(SplayTree *x,SplayTree *target=null){
  while(x->fa!=target){
    SplayTree *y=x->fa,*z=y->fa;
    if(z!=target) Rotate(GetWhich(x)^GetWhich(y)?x:y);
    Rotate(x);
  }
  if(target==null) root=x;
}
void Insert(const int k,const int w){
  SplayTree *p=Find(k),*q=Find(k+1);
  Splay(p),Splay(q,p);
  //找到最后一个节点
  NewNode(w,q);
}
void Modify(const int L,const int R,const int w,const int mode){
  SplayTree *p=Find(L),*q=Find(R+2);
  Splay(p),Splay(q,p);
  if(!mode) ModifyValue(q->son[0],w);
  else ModifyAdd(q->son[0],w);
}
int Query(const int L,const int R){
  SplayTree *p=Find(L),*q=Find(R+2);
  Splay(p),Splay(q,p);
  //取出区间的操作
  return q->son[0]->max;
}

void init(){
  null=new SplayTree;
  SplayTree *p=++pool,*q=++pool;
  *null=(SplayTree){-infinity,-infinity,0,infinity,0,null,null,null};
  *p=(SplayTree){-infinity,-infinity,1,infinity,0,null,q,null};
  *q=(SplayTree){-infinity,-infinity,1,infinity,0,null,null,p};
  root=p;
  //初始化，创建两个虚节点
}

signed main(){
  read(n),read(q);
  init();
  for(int i=1,x;i<=n;++i){
    read(x);
    Insert(i,x);
  }
  while(q--){
    int opt,l,r,x;
    read(opt),read(l),read(r);
    if(opt==1){
      read(x);
      Modify(l,r,x,0);
    }else if(opt==2){
      read(x);
      Modify(l,r,x,1);
    }else write(Query(l,r)),putchar('\n');
  }
  return 0;
}
```

常数略大，1.95s 惊险通过。

---


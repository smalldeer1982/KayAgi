# 无聊的数列

## 题目背景

无聊的 YYB 总喜欢搞出一些正常人无法搞出的东西。有一天，无聊的 YYB 想出了一道无聊的题：无聊的数列。。。

## 题目描述

维护一个数列 $a_i$，支持两种操作：

 - `1 l r K D`：给出一个长度等于 $r-l+1$ 的等差数列，首项为 $K$，公差为 $D$，并将它对应加到 $[l,r]$ 范围中的每一个数上。即：令 $a_l=a_l+K,a_{l+1}=a_{l+1}+K+D\ldots a_r=a_r+K+(r-l) \times D$。

 - `2 p`：询问序列的第 $p$ 个数的值 $a_p$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 数据，$0\le n,m \le 10^5,-200\le a_i,K,D\le 200, 1 \leq l \leq r \leq n, 1 \leq p \leq n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 2 4 1 2
2 3
```

### 输出

```
6```

# 题解

## 作者：AC_Automation (赞：105)

刚调完这道题，感觉坑还是比较多的，于是写一篇题解。

# 正解：线段树+差分
不会的可以去看看[线段树](https://www.luogu.org/problemnew/solution/P3372)和[差分](https://rpdreamer.blog.luogu.org/ci-fen-and-shu-shang-ci-fen)

区间加上一个等差数列可以用差分来解决。

比如：
```
原序列：0 0 0 0 0 0
差分序列：0 0 0 0 0 0
等差序列：1 3 5 7 9
加上等差数列后的序列：1 3 5 7 9 0
然后差分：1 2 2 2 2 -9
```
我们称差分序列为$a$，首项为$s$，末项为$e$，公差为$d$，要将$l$~$r$这段区间加上等差序列
## 可以得出结论：

### **如果要在差分序列上加一个等差序列，则要在$a_{l}$加上$s$，$a_{l+1}$~$a_r$加上$d$，$a_{r+1}$剪去e即可！**

用线段树维护即可，答案即为$\sum _{i=1}^na[i]$

于是就有了代码：
```cpp
#include<iostream>
using namespace std;
#define ll long long
ll data[100005];
struct point{
    ll sum;
    ll tag;
} a[400005];
inline int ls(int root){return root<<1;}
inline int rs(int root){return root<<1|1;}
inline void up(int root){a[root].sum=a[ls(root)].sum+a[rs(root)].sum;}
void build(int root,int l,int r){
    a[root].tag=0;int mid=(l+r)>>1;
    if(l==r){a[root].sum=data[l];return;}
    build(ls(root),l,mid);build(rs(root),mid+1,r);
    up(root);
}
inline void pd(int root,int l,int r){
    int mid=(l+r)>>1;
    a[ls(root)].tag+=a[root].tag;
    a[rs(root)].tag+=a[root].tag;
    a[ls(root)].sum+=a[root].tag*(mid-l+1);
    a[rs(root)].sum+=a[root].tag*(r-mid);
    a[root].tag=0;
}
void add(int root,int l,int r,int ql,int qr,ll x){
    if(ql<=l&&qr>=r){a[root].tag+=x;a[root].sum+=(r-l+1)*x;return;}
    int mid=(l+r)>>1;
    pd(root,l,r);
    if(ql<=mid)add(ls(root),l,mid,ql,qr,x);
    if(qr>mid) add(rs(root),mid+1,r,ql,qr,x);
    up(root);
    return;
}
ll query(int root,int l,int r,int ql,int qr){
    if(ql<=l&&qr>=r)
        return a[root].sum;
    int mid=(l+r)>>1,ret=0;
    pd(root,l,r);
    if(ql<=mid)ret+=query(ls(root),l,mid,ql,qr);
    if(qr>mid)ret+=query(rs(root),mid+1,r,ql,qr);
    return ret;
}//↑上面全是线段树
int main()
{
    int n,m,opt,l,r,k,d,t;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>data[i];
    for(int i=n-1;i>0;i--)
        data[i+1]=data[i+1]-data[i];//将原序列差分
    build(1,1,n);
    for(int i=0;i<m;i++){
        cin>>opt;
        if(opt==1){
            cin>>l>>r>>k>>d;
            add(1,1,n,l,l,k);
            add(1,1,n,l+1,r,d);
            add(1,1,n,r+1,r+1,-(k+d*(r-l)));//加上等差数列
        }
        else{
            cin>>t;
            cout<<query(1,1,n,1,t)<<endl;
        }
        
    }
    return 0;
}
```
交上去一看，$80pts$，WA点1，点3

错误在于$r+1$可能会越界，$l+1$可能会$>r$

于是100pts代码：

```cpp
#include<iostream>
using namespace std;
#define ll long long
ll data[100005];
struct point{
    ll sum;
    ll tag;
} a[400005];
inline int ls(int root){return root<<1;}
inline int rs(int root){return root<<1|1;}
inline void up(int root){a[root].sum=a[ls(root)].sum+a[rs(root)].sum;}
void build(int root,int l,int r){
    a[root].tag=0;int mid=(l+r)>>1;
    if(l==r){a[root].sum=data[l];return;}
    build(ls(root),l,mid);build(rs(root),mid+1,r);
    up(root);
}
inline void pd(int root,int l,int r){
    int mid=(l+r)>>1;
    a[ls(root)].tag+=a[root].tag;
    a[rs(root)].tag+=a[root].tag;
    a[ls(root)].sum+=a[root].tag*(mid-l+1);
    a[rs(root)].sum+=a[root].tag*(r-mid);
    a[root].tag=0;
}
void add(int root,int l,int r,int ql,int qr,ll x){
    if(ql<=l&&qr>=r){a[root].tag+=x;a[root].sum+=(r-l+1)*x;return;}
    int mid=(l+r)>>1;
    pd(root,l,r);
    if(ql<=mid)add(ls(root),l,mid,ql,qr,x);
    if(qr>mid) add(rs(root),mid+1,r,ql,qr,x);
    up(root);
    return;
}
ll query(int root,int l,int r,int ql,int qr){
    if(ql<=l&&qr>=r)
        return a[root].sum;
    int mid=(l+r)>>1,ret=0;
    pd(root,l,r);
    if(ql<=mid)ret+=query(ls(root),l,mid,ql,qr);
    if(qr>mid)ret+=query(rs(root),mid+1,r,ql,qr);
    return ret;
}
int main()
{
    int n,m,opt,l,r,k,d,t;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>data[i];
    for(int i=n-1;i>0;i--)
        data[i+1]=data[i+1]-data[i];
    build(1,1,n);
    for(int i=0;i<m;i++){
        cin>>opt;
        if(opt==1){
            cin>>l>>r>>k>>d;
            add(1,1,n,l,l,k);
            if(l+1<=r)add(1,1,n,l+1,r,d);
            if(r<n)add(1,1,n,r+1,r+1,-(k+d*(r-l)));//注意这里加了判断
        }
        else{
            cin>>t;
            cout<<query(1,1,n,1,t)<<endl;
        }
        
    }
    return 0;
}
```

---

## 作者：ll_dio (赞：49)

# 前言
昨天刷掉了这道题，发现题解区里的题解都是一阶差分+线段树的做法，对于不会段更新和线段树的萌新十分的不友好，所以水一篇基于二阶差分和树状数组的题解。
# 正文
# 前置芝士
差分：差分数组 $d_i=a_i-a_{i-1}$

二阶差分：差分数组上的差分,二阶差分数组为 $d2$

二阶前缀和：前缀和数组上的前缀和

树状数组：基于前缀和和二进制的数据结构
## 题目大意
给定一个长度为 $n$ 的数列 $a$，以及 $m$ 个操作，操作分为增加操作和询问操作。增加操作要求在序列 $a$ 中的区间 $[l,r]$ 上加上一个首项为 $K$，公差为 $D$，长度为 $r-l+1$ 的等差数列。询问操作求的是序列 $a$ 的第 $p$ 个元素的值。
## 二阶差分分析
询问操作很显然是求二阶差分数组的二阶前缀和，那增加操作呢？

首先，增加一个首项为 $K$，公差为 $D$ 的等差数列，可以理解为增加一个首项为 $K$，公差为 $0$ 的等差数列和增加一个首项为 $0$，公差为 $D$ 的等差数列。

第一种情况：首项为 $K$，公差为 $0$（整体增加 $K$）

那么显然，可以得到，在这种情况下:

$d_l=d_l+K$

$d_{r+1}=d_{r+1}-K$

再继续深入分析，可以得到

$d2_l=d2_l+K$

$d2_{l+1}=d2_{l+1}-K$

$d2_{r+1}=d2_{r+1}-K$

$d2_{r+2}=d2_{r+2}+K$


第二种情况：首项为 $0$，公差为 $D$

一通操作猛如虎，得到

$d_{l+1}=d_{l+1}+D$，$d_{l+2}=d_{l+2}+D$，...，$d_{l+r}=d_{l+r}+D$

$d_{r+1}=d_{r+1}-(r-l) \times D$

继续一通操作猛如虎，易得：

$d2_{l+1}=d2_{l+1}+D$

$d2_{r+1}=-(r-l+1) \times D$

$d2_{r+2}=d2_{r+2}+(r-l) \times D$

将这些东西加到一起，可以得到，对于整体增加一个首项为 $K$，公差为 $D$的等差数列

$d2_l=d2_l+k$

$d2_{l+1}=d2_{l+1}+D-K$

$d2_{r+1}=d2_{r+1}-(r-l+1) \times D -K$

$d2_{r+2}=d2_{r+2}+(r-l) \times D +K$

真是amazing的结果啊，原来的段更新已经变成了若干个点更新。

至此，基于二阶差分的分析已经完了，接下来就是如何求二阶前缀和了。
## 二阶前缀和的分析
我们要分析如何求出 $d2$ 的二阶前缀和，也就是 $a$ 数组。
最暴力的解法是先求一遍前缀和再求一边前缀和，显然超时。

显然 

$a_k$
   
$=\sum\limits_{j=1}^k \sum\limits_{i=1}^jd2_i$

$=\sum\limits_{i=1}^k \sum\limits_{j=i}^kd2_i$

$=\sum\limits_{i=1}^kd2_i \times(k-i+1)$

$=(k+1) \times \sum\limits_{i=1}^kd2_i-\sum\limits_{i=1}^kd2_i \times i$
   
经过一通数学变化后，我们发现，只需要维护 $d2_i$ 的前缀和和 $d2_i\times i$ 的前缀和即可，这里我们使用树状数组来维护。

## 代码
```cpp
#include<bits/stdc++.h>
#define N 100009
using namespace std;
typedef long long ll;
ll n,m,a[N],d[N],bit1[N],bit2[N];
ll LSB(ll x){
	return x&(-x);
}
void add(ll x,ll delta){
	ll id=x;
	while(x<=n){
		bit1[x]+=delta;
		bit2[x]+=delta*id;
		x+=LSB(x);
	}
}
ll query(ll x){
	ll id=x,sum=0;
	while(x){
		sum+=(id+1)*bit1[x]-bit2[x];
		x-=LSB(x);
	}
	return sum;
}
void input(){
	scanf("%lld %lld",&n,&m);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		d[i]=a[i]-a[i-1];
		add(i,d[i]-d[i-1]);
	}
}
void solve(){
	for(ll i=1;i<=m;i++){
		ll op;
		scanf("%lld",&op);
		if(op==1){
			ll l,r,K,D;
			scanf("%lld %lld %lld %lld",&l,&r,&K,&D);
			add(l,K); add(l+1,D-K); add(r+1,-(r-l+1)*D-K); add(r+2,K+(r-l)*D);
		}else{
			ll p;
			scanf("%lld",&p);
			printf("%lld\n",query(p));
		}
	}
}
int main(){
	input();
	solve();
	return 0;
}

```
## 关于一些别的东西
看过别的题解的肯定都知道，线段树+一阶差分需要进行越界特判，否则会 WA。那么为什么树状数组不用特判呢？因为 add 函数的循环条件已经把这个东西给特判掉了。

# 致谢
@lilong 是他对于本文中的公式进行了无偿地 $\LaTeX$ 排版，十分感谢他的帮助 。
# 完结撒花！

---

## 作者：kkxhh (赞：49)

其他题解都是用差分做的~~（然而我太菜了不知道怎么转成差分）~~

提供一个我自己的维护的思路

对于每个点维护两个标记，第一个标记表示这个区间里的每个数加上标记，第二个标记表示这个区间里的每个数加上**这个数在原数组里的下标乘上标记**

也就是说

**当我们对区间 $[l,r]$ 加上一个首项为 $k$ 公差为 $d$ 的等差数列时，我们给这个区间加上 $k - d \times l$，再给每个位置加上 下标$\times d$**，正确性显然。每次区间修改的复杂度是 $O(logn)$ ，单点查询复杂度也是 $O(logn)$。于是这题我们就做完了。

另外这题可以用标记永久化优化一下常数

代码如下

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define lt (o<<1)
#define rt (o<<1|1)

typedef long long ll;
typedef struct node{
    ll tag,tag2;
}node;

node t[400010];
ll n,m,a[100010];

inline ll read(){
    ll num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

void modify(ll o,ll l,ll r,ll ql,ll qr,ll t1,ll t2){
    if(ql<=l && qr>=r) {t[o].tag+=t1,t[o].tag2+=t2; return;}
    ll mid=(l+r)>>1;
    if(ql<=mid) modify(lt,l,mid,ql,qr,t1,t2);
    if(qr>=mid+1) modify(rt,mid+1,r,ql,qr,t1,t2);
}

ll query(ll o,ll l,ll r,ll q,ll t1,ll t2){
    if(l==r) {return t1+t[o].tag+l*(t2+t[o].tag2);}
    ll mid=(l+r)>>1;
    if(q<=mid) return query(lt,l,mid,q,t1+t[o].tag,t2+t[o].tag2);
    else return query(rt,mid+1,r,q,t1+t[o].tag,t2+t[o].tag2);
}

int main(){
    n=read(); m=read();
    for(ll i=1;i<=n;i++) a[i]=read();
    while(m--){
        ll opt=read();
        if(opt==1){
            ll l=read(),r=read(),k=read(),d=read();
            modify(1,1,n,l,r,k-d*l,d);
        }
        else{
            ll q=read();
            printf("%lld\n",query(1,1,n,q,0,0)+a[q]);
        }
    }
    return 0;
}
```

---

## 作者：Alloverzyt (赞：35)

# 背景

看到题解都是差分，竟然还有建两颗线段树和二阶差分的大佬。

我感到不理解，很不理解。

# 题目正解

本题正解很明显就是：**线段树**

**是的，你没有看错，就只有线段树。**

很显然我们直接按照线段树板题写就可以了，维护题目需要维护的，注意到只有单点查询，所以我们根本不需要维护区间和，**对于区间来讲，我们只用维护修改操作**，修改操作只需要 $k,d$（首项和公差）。

考虑该操作如何向下传递（pushdown）:

1. 对于左区间来讲，$k,d$ 没有改变，直接赋值。
2. 对于右区间来讲，只有 $k_{right}=k_{father}+len*d$，其中 $len$ 是左区间长度。

此外我们发现：对于同一段区间，修改操作是可以叠加的。

**好的，我们做完了**，甚至不需要 pushup 操作。

是的，就是这么简单，当区间变成一个点时，我们发现对于这个点的修改就是加上 $k$。

# AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500000
#define ls rt<<1
#define rs rt<<1|1
int n,m,a[N];

struct tree{
	long long l,r,w,op,k,d;
}tr[N];

void build(int rt,int l,int r){
	tr[rt]={l,r,0,0,0,0};
	if(l==r){
		tr[rt].w=a[l];return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);build(rs,mid+1,r); 
}

void pushdown(int rt){
	if(tr[rt].op){
		tr[ls].k+=tr[rt].k;
		tr[ls].d+=tr[rt].d;
		tr[ls].op=1;
		tr[rs].k+=tr[rt].k+(tr[rs].l-tr[ls].l)*tr[rt].d;
		tr[rs].d+=tr[rt].d;
		tr[rs].op=1;
	}
	tr[rt].op=0;
	tr[rt].d=tr[rt].k=0;
}

void update(int rt,int cl,int cr,int k,int d){
	int l=tr[rt].l,r=tr[rt].r;
	if(cl<=l&&r<=cr){
		tr[rt].op=1;
		tr[rt].k+=k+(l-cl)*d;
		tr[rt].d+=d;
		return ;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(cl<=mid) update(ls,cl,cr,k,d);
	if(cr>mid) update(rs,cl,cr,k,d);
}

long long query(int rt,int p){
	int l=tr[rt].l,r=tr[rt].r;
//	printf("|%d %d %d %d %d\n",l,r,tr[rt].d,tr[rt].k,tr[rt].w);
	if(l==r){
		tr[rt].w+=tr[rt].k;
		tr[rt].k=0;tr[rt].d=0;
		return tr[rt].w;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(p<=mid) return query(ls,p);
	else return query(rs,p); 
} 

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	build(1,1,n);
	while(m--){
		int t,l,r,k,d,p;
		scanf("%d",&t);
		if(t==1){
			scanf("%d%d%d%d",&l,&r,&k,&d);
			update(1,l,r,k,d);
		}else{
			scanf("%d",&p);
			printf("%lld\n",query(1,p));
		}
	}
	return 0;
}
```

> 不开 long long 见祖宗！



---

## 作者：__stdcall (赞：21)

楼下的楼下的线段树是维护了首项和公差两个值

楼下好像进行了一些复杂的计算来维护线段树。。。

实际上可以维护一个差分数组，不需要进行复杂的计算

只需要写一个很普通的滋磁区间加法和区间求和的线段树就可以了

1操作可以转化为如下操作：

将a[L]在差分数组中的对应值d[L]加上K

将a[L+1]至a[R]在差分数组中的对应值加上D

将a[R+1]对应的d[R+1]减去K+D\*(R-L)，即减去数列的末项

2操作即在差分数组中求d[1]至d[P]的和

代码如下






```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <cstdlib>
using namespace std;
typedef long long ll;
int n,m;
struct SGT {
    int initval[100010];
    ll sumv[400010];
    ll addv[400010];
    int left,right;
    ll val;
    void build(){ buildtree(1,1,n); }
    void buildtree( int o , int L , int R ) {
        if( L == R ) {
            sumv[o] = addv[o] = initval[L];
            return;
        }
        int M = L+(R-L)/2;
        int lc = o<<1; int rc = lc|1;
        buildtree(lc,L,M);
        buildtree(rc,M+1,R);
        addv[o] = 0; sumv[o] = sumv[lc] + sumv[rc];
    }
    void add( int L , int R , ll v ) {
        left = L; right = R; val = v;
        addtree(1,1,n);
    }
    void addtree( int o , int L , int R ) {
        if( L >= left && R <= right ) {
            addv[o] += val;
            maintain(o,L,R);
            return;
        }
        int M = L+(R-L)/2;
        int lc = o<<1; int rc = lc|1;
        if( left <= M ) addtree(lc,L,M);
        if( right > M ) addtree(rc,M+1,R);
        maintain(o,L,R);
    }
    void maintain( int o , int L , int R ) {
        sumv[o] = addv[o]*(R-L+1);
        if( L != R ) {
            int lc = o<<1; int rc = lc|1;
            sumv[o] += sumv[lc] + sumv[rc];
        }
    }
    ll query( int L , int R ) {
        left = L; right = R; val = 0;
        querytree(1,1,n,0);
        return val;
    }
    void querytree( int o , int L , int R , ll addval ) {
        if( left <= L && right >= R ) {
            val += sumv[o] + addval*(R-L+1);
            return;
        }
        int M = L+(R-L)/2;
        int lc = o<<1; int rc = lc|1;
        if( left <= M ) querytree(lc,L,M,addval+addv[o]);
        if( right > M ) querytree(rc,M+1,R,addval+addv[o]);
    }
};
int a[100010];
SGT sgt;
int main() {
    scanf( "%d%d" , &n , &m );
    for( int i = 1 ; i <= n ; ++i ) {
        scanf( "%d" , &a[i] );
        sgt.initval[i] = a[i]-a[i-1];
    }
    sgt.build();
    for( int i = 0 ; i < m ; ++i ) {
        int order; scanf( "%d" , &order );
        if( order == 1 ) {
            int l,r,k,d; scanf( "%d%d%d%d" , &l , &r , &k , &d );
            sgt.add(l,l,k);
            if( l != r ) sgt.add(l+1,r,d);
            if( r != n ) sgt.add(r+1,r+1, -k-d*(r-l) );
        }
        else {
            int p; scanf( "%d" , &p );
            cout << sgt.query(1,p) << endl;
        }
    }
    return 0;
}

```

---

## 作者：Allons—y (赞：16)

	本蒟蒻不会差分数组，只好来个纯线段树。
	很容易便可以想到，可以将一个等差数列 k,k+d,k+2d... 拆分成 k,k,k... 和 0,d,2d... 。这样建两棵线段树就可以解决问题。
	第一棵线段树就是P3372 【模板】线段树 1,相信大家都AC了。
	对于第二棵线段树，每个区间维护的是一个等差数列，我们可以在结构体中加入四个变量，代表每个区间所代表的等差数列的首项与末项以及它们的懒标记。
    区间修改的时候可以算出增加的等差数列的首项与末项，因为同长的等差数列加等差数列还是等差数列，所以直接加在首项与末项以及懒标记上即可。
    回溯的时候一个区间的首项等于它的左子区间的首项，末项等于它的右子区间的末项。
    下发懒标记的时候可以根据一个区间首项懒标记，末项懒标记和长度算出公差。
    左子区间的首项及懒标记要加上首项懒标记；
    左子区间的末项及懒标记要加上首项懒标记再加上左子区间长度乘公差；
    右子区间的首项及懒标记要加上末项懒标记再减去右子区间长度乘公差；
    右子区间的末项及懒标记要加上末项懒标记。
    询问的时候用等差数列求和公式就可以根据首项与末项及长度算出等差数列的和。
    
    #include<iostream>
    #include<cstdio>
    #define S 100005
    #define LL long long
    using namespace std;
    LL n,m,a[S],t,x,y,k,d,len,dd,p,ans;
    struct node{
        LL l,r,mid;//左端点，右端点及中点
        LL sum,cha;//第一棵线段树的和与懒标记
        LL lval,rval,ldet,rdet;//第二棵线段树的首项，末项，首项懒标记，末项懒标记
    }tree[4*S];
    inline void build(LL l,LL r,LL pos){//建树
        tree[pos].l=l;
        tree[pos].r=r;
        tree[pos].mid=(l+r)/2;
        if(l==r){
            return;
        }
        build(l,tree[pos].mid,pos*2);
        build(tree[pos].mid+1,r,pos*2+1); 
    }
    inline void push(LL pos){
        if(tree[pos].cha){
            tree[pos*2].sum+=(tree[pos].cha*(tree[pos*2].r-tree[pos*2].l+1));
            tree[pos*2].cha+=tree[pos].cha;
            tree[pos*2+1].sum+=(tree[pos].cha*(tree[pos*2+1].r-tree[pos*2+1].l+1));
            tree[pos*2+1].cha+=tree[pos].cha;
            tree[pos].cha=0;	
        }
        len=(tree[pos].r-tree[pos].l+1)/2;//子区间长度
        dd=(tree[pos].rdet-tree[pos].ldet)/(tree[pos].r-tree[pos].l);//公差
        if(tree[pos].ldet||tree[pos].rdet){
            tree[pos*2].lval+=tree[pos].ldet;//左子区间的首项及懒标记要加上首项懒标记；
            tree[pos*2].ldet+=tree[pos].ldet;
            tree[pos*2].rval+=(tree[pos].ldet+(len-1+(tree[pos].r-tree[pos].l+1)%2)*dd);//左子区间的末项及懒标记要加上首项懒标记再加上左子区间长度乘公差
            tree[pos*2].rdet+=(tree[pos].ldet+(len-1+(tree[pos].r-tree[pos].l+1)%2)*dd);
            tree[pos].ldet=0;
            tree[pos*2+1].lval+=(tree[pos].rdet-(len-1)*dd);//右子区间的首项及懒标记要加上末项懒标记再减去右子区间长度乘公差
            tree[pos*2+1].ldet+=(tree[pos].rdet-(len-1)*dd);
            tree[pos*2+1].rval+=tree[pos].rdet;//右子区间的末项及懒标记要加上末项懒标记。
            tree[pos*2+1].rdet+=tree[pos].rdet;	
            tree[pos].rdet=0;
        }
    }
    inline void add(LL pos){
        if(x<=tree[pos].l&&tree[pos].r<=y){
            tree[pos].sum+=(k*(tree[pos].r-tree[pos].l+1));
            tree[pos].cha+=k;
            return;
        }
        push(pos);
        if(x<=tree[pos].mid){
            add(pos*2);
        }
        if(tree[pos].mid+1<=y){
            add(pos*2+1);
        }
        tree[pos].sum=tree[pos*2].sum+tree[pos*2+1].sum;
    }
    inline void addd(LL pos){
        if(x<=tree[pos].l&&tree[pos].r<=y){
            tree[pos].lval+=(d*(tree[pos].l-x));//修改首项及懒标记
            tree[pos].ldet+=(d*(tree[pos].l-x));
            tree[pos].rval+=(d*(tree[pos].r-x));//修改末项及懒标记
            tree[pos].rdet+=(d*(tree[pos].r-x));
            return;
        }
        push(pos);//下发懒标记
        if(x<=tree[pos].mid){
            addd(pos*2);
        }
        if(tree[pos].mid+1<=y){
            addd(pos*2+1);
        }
        tree[pos].lval=tree[pos*2].lval;//首项等于它的左子区间的首项
        tree[pos].rval=tree[pos*2+1].rval;//末项等于它的右子区间的末项
    }
    inline void ask(LL pos){
        if(p==tree[pos].l&&tree[pos].r==p){
            ans+=tree[pos].sum;
            ans+=((tree[pos].lval+tree[pos].rval)*(tree[pos].r-tree[pos].l+1)/2);//等差数列求和
            return;
        }
        push(pos);//下发懒标记
        if(p<=tree[pos].mid){
            ask(pos*2);
        }
        if(tree[pos].mid+1<=p){
            ask(pos*2+1);
        }
    }
    int main(){
        scanf("%lld%lld",&n,&m);
        for(int i=1;i<=n;i++)
        {
            scanf("%lld",&a[i]);
        }
        build(1,n,1);//建树
        for(int i=1;i<=m;i++)
        {
            scanf("%lld",&t);
            if(t==1){
                scanf("%lld%lld%lld%lld",&x,&y,&k,&d);
                add(1);//区间加k
                addd(1);//区间加等差数列0,d,2d...
            }
            else{
                scanf("%lld",&p);
                ans=a[p];
                ask(1);//计算和
                printf("%lld\n",ans);
            }
        }
        return 0;
    }
  

---

## 作者：wjr_jok (赞：5)

## 题意

给你一个长度为 $n$ 的数列，要对它进行 $m$ 次操作，有修改和询问两种操作。

修改：将 $l \sim r$ 的区间加上一个首项为 $k$，公差为 $d$ 的等差数列。

询问：询问序列的第 $p$ 个数的值。

最后要你输出这个数列每个数的值。

## ~~暴力~~思路

分块，对于散块直接算出等差数列对应的值进行修改，对于整块则是用一个 vector 类型的 $add$ 数组记录这个等差数列的开始位置 $l$，初始项 $k$ 以及公差 $d$，因为每次加的是一个等差数列，无法合并，只能分开处理。

询问时就比较暴力了，直接使用循环遍历 $add$ 数组，通过首项，当前位置以及公差算出对应的数，然后全部加上即可得到答案。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
    char ch=getchar();
    int r=0,w=1;
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+ch-'0',ch=getchar();
    return r*w;
}
void write(long long n){
    if(n<0) putchar('-'),n*=-1;
    if(n>9) write(n/10);
    putchar(n % 10 + '0');
}
//快读快写防止超时
struct jgt{
	int x;//开始位置
	int y;//初始项
	int z;//公差
	int cs;//小优化，记录重复次数防止MLE
} cc;
int n,m,s,l,r,k,d;
long long cnt;
long long xl[100001];
int x[401],y[401],fk[100001];
vector<jgt> xg[401];
signed main(){
	n=read(),m=read();
	for(int i=1;i<=(int)sqrt(n);i++){
		cnt++;
		x[cnt]=y[cnt-1]+1;
		y[cnt]=x[cnt]+(int)sqrt(n)-1;
		for(int j=x[cnt];j<=y[cnt];j++){
			fk[j]=cnt;
		}
	}
	if(y[cnt]<n){
		cnt++;
		x[cnt]=y[cnt-1]+1;
		y[cnt]=n;
		for(int i=x[cnt];i<=y[cnt];i++){
			fk[i]=cnt;
		}
	}
	for(int i=1;i<=n;i++){
		xl[i]=read();
	}
	for(int i=1;i<=m;i++){
		s=read();
		if(s==1){
			l=read(),r=read(),k=read(),d=read();
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				xl[j]+=k+(j-l)*d;
			}
			if(fk[l]!=fk[r]){
				for(int j=x[fk[r]];j<=r;j++){
					xl[j]+=k+(j-l)*d;
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				if(!xg[j].empty()){
					cc=xg[j][xg[j].size()-1];
				}
				if(l==cc.x&&k==cc.y&&d==cc.z&&!xg[j].empty()){
					xg[j][xg[j].size()-1].cs++;
				}
              //单独处理重复情况
				else{
					cc.x=l;
					cc.y=k;
					cc.z=d;
					xg[j].push_back(cc);
                  //更新add数组
				}
			}
		}
		else{
			k=read();
			cnt=xl[k];
			for(int j=0;j<xg[fk[k]].size();j++){
				cnt+=xg[fk[k]][j].y+(k-xg[fk[k]][j].x)*xg[fk[k]][j].z*(xg[fk[k]][j].cs+1);//原始值加上add数组的值
			}
			write(cnt);
			puts("");
		}
	}
	return 0;
}
```

---


# 色板游戏

## 题目背景

阿宝上学了，今天老师拿来了一块很长的涂色板。


## 题目描述

色板长度为 $L$，$L$ 是一个正整数，所以我们可以均匀地将它划分成 $L$ 块 $1$ 厘米长的小方格。并从左到右标记为 $1, 2, \dots L$。

现在色板上只有一个颜色，老师告诉阿宝在色板上只能做两件事：

1. `C A B C` 指在 $A$ 到 $B$ 号方格中涂上颜色 $C$。
2. `P A B` 指老师的提问：$A$ 到 $B$ 号方格中有几种颜色。

学校的颜料盒中一共有 $T$ 种颜料。为简便起见，我们把他们标记为 $1, 2, \dots T$. 开始时色板上原有的颜色就为 $1$ 号色。 面对如此复杂的问题，阿宝向你求助，你能帮助他吗？


## 样例 #1

### 输入

```
2 2 4
C 1 1 2
P 1 2
C 2 2 2
P 1 2```

### 输出

```
2
1```

# 题解

## 作者：fyfy (赞：126)

题解里面好像都是压位什么的，

身为蒟蒻的我真的不会，

所以就来谈谈我的30颗线段树蠢方法吧！

这题初看没有头绪。

然后发现颜色范围好像只有30；

所以，我就想到一种sao操作，搞30颗线段树。

每颗线段树代表一种颜色。

那么对于题中的两种操作：

1.修改。我们for循环扫一遍所有颜色，把其他颜色的线段树l->r修改成0，要修改的颜色所对应的线段树改成1。

2.询问。也是for循环，如果l->r这个区间的第k种颜色所对应的线段树有值，则ans++。

时间复杂度也很低，大概是(MLlog(L)*T).

献上代码：
```cpp
#include <bits/stdc++.h>
#define ll(x) ((x)<<1)
#define rr(x) ((x)<<1|1)
using namespace std;

const int T=31,N=100010;
int n,t,m;
int laz[T][N<<2],sum[T][N<<2];

void pushup(int i,int x)
{
	sum[i][x]=sum[i][ll(x)]+sum[i][rr(x)];
}

void build(int i,int x,int l,int r)
{
	if (l==r) {
		sum[i][x]=1;
		return;
	}
	int mid=l+r>>1;
	build(i,ll(x),l,mid);
	build(i,rr(x),mid+1,r);
	pushup(i,x);
}

void pushdown(int i,int x)
{
	if (laz[i][x]==-1) {
		sum[i][ll(x)]=sum[i][rr(x)]=0;
		laz[i][ll(x)]=laz[i][rr(x)]=-1;
	}
	else {
		sum[i][ll(x)]=sum[i][rr(x)]=laz[i][x];
		laz[i][ll(x)]=laz[i][rr(x)]=laz[i][x];
	}
	laz[i][x]=0;
}

void change(int i,int x,int l,int r,int ls,int rs,int v)
{
	if (l>rs||r<ls) return;
	if (l>=ls&&r<=rs) {
		sum[i][x]=v;
		if (!v) laz[i][x]=-1;
		else laz[i][x]=v;
		return;
	}
	if (laz[i][x]) pushdown(i,x);
	int mid=l+r>>1;
	if (ls<=mid) change(i,ll(x),l,mid,ls,rs,v);
	if (rs>mid) change(i,rr(x),mid+1,r,ls,rs,v);
	pushup(i,x);
}

int ask(int i,int x,int l,int r,int ls,int rs)
{
	if (l>rs||r<ls) return 0;
	if (l>=ls&&r<=rs) return sum[i][x];
	if (laz[i][x]) pushdown(i,x);
	int mid=l+r>>1;
	return ask(i,ll(x),l,mid,ls,rs)+ask(i,rr(x),mid+1,r,ls,rs);
}

int main()
{
	cin>>n>>t>>m;
	build(1,1,1,n);
	char s[3];int l,r,v;
	for (int i=1;i<=m;++i) {
		scanf("%s%d%d",s,&l,&r);
		if (l>r) swap(l,r);
		if (s[0]=='C') {
			scanf("%d",&v);
			for (int k=1;k<=t;++k)
				if (k!=v)
					change(k,1,1,n,l,r,0);
				else change(k,1,1,n,l,r,1);
		}
		else {
			int ans=0;
			for (int k=1;k<=t;++k)
				if (ask(k,1,1,n,l,r))
					++ans;
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Taduro (赞：31)

这题看上去好吓人啊，但第二眼看就可以发现t<=30，那么我们就可以状态压缩一下，如果一个数二进制的第i位为1，则这个数代表的区间里有第i个颜色的格子。
状压完毕。
之后我们再来看怎么套到线段树上，无非就是确定上推和下推规则，先看上推，我们可以直接按位于一下（因为只要求左右区间一个有这种颜色），再来下推，由于颜色可以覆盖，那么直接把原来的值给覆盖掉，lazy标记也是如此。
上代码：
```
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
ll sum[400001],n,t,c,i,ad[400001];
inline void pushup(ll rt){
	sum[rt]=sum[rt<<1]|sum[rt<<1|1];
}
inline void build(ll rt,ll l,ll r){
	if (l==r){
		sum[rt]=1<<1;
		return;
	}
	int m=(l+r)>>1;
	build(rt<<1,l,m);
	build(rt<<1|1,m+1,r);
	pushup(rt);
}
inline void pushdown(ll rt,ll l,ll r){
	if (ad[rt]){
		sum[rt<<1]=(1<<ad[rt]);
		sum[rt<<1|1]=(1<<ad[rt]);
		ad[rt<<1]=ad[rt];
		ad[rt<<1|1]=ad[rt];
		ad[rt]=0;
	}
}
inline void update(ll rt,ll l,ll r,ll x,ll y,ll k){
	if (l>y||x>r) return;
	if (x<=l&&r<=y){
		sum[rt]=(1<<k);
		ad[rt]=k;
		return;
	}
	pushdown(rt,l,r);
	ll m=(l+r)>>1;
	if (m>=x) update(rt<<1,l,m,x,y,k);
	if (m<y) update(rt<<1|1,m+1,r,x,y,k);
	pushup(rt);
}
inline int query(ll rt,ll l,ll r,ll x,ll y){
	if (l>y||x>r) return 0;
	if (x<=l&&r<=y)	return sum[rt];
	pushdown(rt,l,r);
	ll m=(l+r)>>1,ans=0;
	if (m>=x) ans|=query(rt<<1,l,m,x,y);
	if (m<y) ans|=query(rt<<1|1,m+1,r,x,y);
	return ans;
}
int main(){
	char u; ll x,y,k;
	scanf("%lld%lld%lld",&n,&c,&t);
	build(1,1,n);
	while (t--){
		cin>>u;
		if(u=='C'){
			scanf("%lld%lld%lld",&x,&y,&k);
			if (x>y) swap(x,y);
			update(1,1,n,x,y,k);
		}
		else{
			scanf("%lld%lld",&x,&y);
			if (x>y) swap(x,y);
			ll p=query(1,1,n,x,y),ans=0;
			for (i=1; i<=c; i++) if (p&(1<<i)) ans++;
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：MindyY (赞：29)

** 线段树通俗易懂的题解哇啦啦**

**思路主要就是把每个区间的状态用二进制数表示**

**因为是染色color函数就直接覆盖**

**lazy标向下pushdown也是直接覆盖**

**看注释啦**

```cpp
#include<stdio.h>
#include<string.h>
int    l,t,o;
int a[1000005]={0},lazy[1000005]={0};
long long lala(int x){
    long long temp=1;
    for(int lmq=0;lmq<x;lmq++){
        temp*=2;
    }
    return temp;
}
void pushdown(int num){
    if(lazy[num]){
        lazy[num*2]=lazy[num];
        lazy[num*2+1]=lazy[num];
        a[num*2]=lazy[num];
        a[num*2+1]=lazy[num];
        lazy[num]=0;
    }
}
void pushup(int num){
    a[num]=a[num*2]|a[num*2+1];
}
void build(int left,int right,int num){
    if(left==right){
        a[num]=1;
        return;
    }
    int mid=(left+right)/2;
    build(left,mid,num*2);
    build(mid+1,right,num*2+1);
    pushup(num);
}
void color(int l,int r,int c,int left,int right,int num){
    if(l<=left&&r>=right){//找到符合区间直接覆盖
        pushdown(num);
        long long tmp=lala(c-1);
        a[num]=tmp;
        lazy[num]=tmp;
        return ;
    }
    pushdown(num);
    int mid=(left+right)/2;
    if(l<=mid){
        color(l,r,c,left,mid,num*2);
    }
    if(mid<r){
        color(l,r,c,mid+1,right,num*2+1);
    }
    pushup(num);
}
long long ask(int l,int r,int left,int right,int num){
    if(l<=left&&right<=r){
        return a[num];
    }
    pushdown(num);
    int mid=(left+right)/2;
    long long temp=0;
    if(l<=mid){
        temp=temp|ask(l,r,left,mid,num*2);//两个状态用或运算合在一起
    }
    if(mid<r){
        temp=temp|ask(l,r,mid+1,right,num*2+1);
    }
    return temp;
}
void f(long long x){
    int res=0;
    for(;x!=0;){
        if(x%2==1)    res++;
        x=x/2;
    }
    printf("%d\n",res);
    return;
}
int main(){//主函数
    scanf("%d%d%d",&l,&t,&o);
    build(1,l,1);//输入完建树
    for(int i=0;i<o;i++){
        char q[3];
        scanf("%s",q);
        if(q[0]=='C'){
            int c1,c2,c3;
            scanf("%d%d%d",&c1,&c2,&c3);
            if(c1>c2){
                int chicken=c1;
                c1=c2;
                c2=chicken;
            }
            color(c1,c2,c3,1,l,1);//color覆盖染色
        }
        else{
            int c1,c2;
            scanf("%d%d",&c1,&c2);
            if(c1>c2){
                int chicken=c1;
                c1=c2;
                c2=chicken;
            }
            long long ans=ask(c1,c2,1,l,1);//询问区间染色状态
            f(ans);//将二进制数转化为颜色种类数并输出
        }
    }
    return 0;
}
```

---

## 作者：tuo3288 (赞：16)

看大佬们高级的数据结构，似乎对于本蒟蒻来说有些难懂；
###### 我来给初学者们介绍一下STL的bitset。

首先，需要<bitset>头文件。
  
 ```cpp
#include<bitset>
using namespace std;
```
bitset相当于一个bool数组，但是优点是两个bitset之间可以进行按位运算。

 定义方式如下：
 ```cpp
bitset<1000>a
```
  初始值是全部设为 0 的。
  
或者
```cpp
string s="1010101"
bitset <1000>a1(s);
 ```
前面不足位用 0 补足；若字符串长度长于定义长度，只取前面部分。

之后就可以把它当做一个二进制数，进行与、或、非、异或、左右移运算了。
```cpp
bitset<4> foo (string("1001"));
bitset<4> bar (string("0011"));
foo^=bar; //1010(foo对bar按位异或后赋值给foo)
foo&=bar; //0010(按位与后赋值给foo)
foo|=bar; //0011(按位或后赋值给foo)
foo<<=2;  //1100(左移2位，低位补0，有自身赋值)
foo>>=1;  //0110(右移1位，高位补0，有自身赋值)
```
另外他还可以实现其他的一些功能。
```cpp
a.set() //将所有位变成1
a.set(k) //将第k位变成1，超限会报错
a.reset() //清空bitset
a.reset(k) //把第k位变成0
a.flip() //将所有位按位取反
a.flip(k) //将第k位按位取反
a.count() //返回bitset中1的个数
a.all() //若bitset内全是1返回1，否则返回0
```
比如本题，正好可以利用或的性质：两个数中只要有一个该位上是1，结果的这位上就是1。

详见代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<bitset>
using namespace std;
int X,W;char ch;
inline int read()
{
	X=0,W=1;ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')W=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){X=(X<<1)+(X<<3)+ch-48;ch=getchar();}
	return X*W;
}
struct tree{
	int l;
	int r;
	int lazy;
	bitset<30>p;
}tr[400001];
bitset<30>ans;
int a[100001];
void pushdown(int k)
{
	if(tr[k].lazy==0)return;
	tr[k<<1].lazy=tr[k].lazy;
	tr[k<<1].p.reset();
	tr[k<<1].p.set(tr[k].lazy,1);
	tr[k<<1|1].lazy=tr[k].lazy;
	tr[k<<1|1].p.reset();
	tr[k<<1|1].p.set(tr[k].lazy,1);
	tr[k].lazy=0;
}
void build(int k)
{
	tr[k].p.set(1,1);
	if(tr[k].l==tr[k].r)return;
	int mid=(tr[k].l+tr[k].r)>>1;
	tr[k<<1].l=tr[k].l;
	tr[k<<1].r=mid;
	tr[k<<1|1].l=mid+1;
	tr[k<<1|1].r=tr[k].r;
	build(k<<1),build(k<<1|1);
}
void change(int k,int l,int r,int c)
{
	if(tr[k].l==l&&tr[k].r==r){
		tr[k].lazy=c;
		tr[k].p.reset();
		tr[k].p.set(c,1);
		return;
	}
	pushdown(k);
	if(l>tr[k<<1].r)change(k<<1|1,l,r,c);
	else if(r<tr[k<<1|1].l)change(k<<1,l,r,c);
	else change(k<<1,l,tr[k<<1].r,c),change(k<<1|1,tr[k<<1|1].l,r,c);
	tr[k].p=(tr[k<<1].p|tr[k<<1|1].p);
}
void ask(int k,int l,int r)
{
	if(tr[k].l==l&&tr[k].r==r){
		ans|=tr[k].p;
		return;
	}
	pushdown(k);
	if(l>tr[k<<1].r)ask(k<<1|1,l,r);
	else if(tr[k<<1|1].l>r)ask(k<<1,l,r);
	else ask(k<<1,l,tr[k<<1].r),ask(k<<1|1,tr[k<<1|1].l,r);
}
int main()
{
	int n=read(),t=read(),m=read();
	tr[1].l=1,tr[1].r=n;
	build(1);
	char op;int u,v,w;
	while(m--){
		scanf(" %c",&op);
		u=read(),v=read();
		if(u>v)swap(u,v);
		switch(op){
			case 'C':{
				w=read();
				change(1,u,v,w);
				break;
			}
			case 'P':{
				ask(1,u,v);
				printf("%d\n",ans.count());
				ans.reset();
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：scallop (赞：9)

其实这道题分块也可以水过

将色板分成 $\sqrt(N)$ 块，块内维护是否被标记和涂有几种颜色

每次更新和查询时整块直接查询，块内暴力查询，复杂度 $M\sqrt(N) \T$

```cpp
#include <algorithm>
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <vector>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>
using namespace std;

struct block
{
    int l;
    int r;
    int v;
    bool c[40];
};

const int MAXN = 1e5 + 100;
int n, m, T, size;
int a[MAXN], g[MAXN];
block b[500];

void update(int p)
{
    int l = b[p].l, r = b[p].r;    
    memset(b[p].c, 0, sizeof b[p].c);
    if (b[p].v != 0)
    {
        for (int i = l; i < r + 1; ++i)
            a[i] = b[p].v;
        b[p].v = 0;
    }
    for (int i = l; i < r + 1; ++i)
        b[p].c[a[i]] = true;
    return;
}

void paint(int l, int r, int x)
{
    int beg = g[l], end = g[r];
    if (beg == end)
    {
        update(beg);
        for (int i = l; i < r + 1; ++i)
            a[i] = x;
        update(beg);
    }
    else
    {
        update(beg);
        for (int i = l; i < beg * size + 1; ++i)
            a[i] = x;        
        update(beg);
        update(end);
        for (int i = (end - 1) * size + 1; i < r + 1; ++i)
            a[i] = x;
        update(end);
        for (int i = beg + 1; i < end; ++i)
            b[i].v = x;

    }
    return;
}

int query(int l, int r)
{
    int beg = g[l], end = g[r], ret = 0;
    bool h[40];
    memset(h, 0, sizeof h);
    if (beg == end)
    {
        update(beg);
        for (int i = l; i < r + 1; ++i)
        {
            if (!h[a[i]])
                h[a[i]] = true;
        }
    }
    else
    {
        update(beg);
        for (int i = l; i < beg * size + 1; ++i)
        {
            if (!h[a[i]])
                h[a[i]] = true;
        }
        update(end);
        for (int i = (end - 1) * size + 1; i < r + 1; ++i)
        {
            if (!h[a[i]])
                h[a[i]] = true;
                ++ret;
        }
        for (int i = beg + 1; i < end; ++i)
        {
            if (b[i].v == 0)
            {
                for (int j = 1; j < T + 1; ++j)
                {
                    if (b[i].c[j] && !h[j])
                        h[j] = true;
                }
            }
            else if (!h[b[i].v])
                h[b[i].v] = true;
        }
    }
    ret = 0;
    for (int i = 1; i < T + 1; ++i)
    {
        if (h[i])
            ++ret;
    }
    return ret;
}

inline int read()
{
    char ch = getchar();
    while (ch < '0' || ch > '9')
        ch = getchar();
    int x = 0;
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}

int main()
{
    n = read();
    T = read();
    m = read();
    size = sqrt(n) + 1;
    for (int i = 1; i < n + 1; ++i)
    {
        a[i] = 1;
        g[i] = (i - 1) / size + 1;
    }
    for (int i = 1; i < size + 1; ++i)
    {
        b[i].v = 0;
        b[i].c[1] = true; 
        b[i].l = (i - 1) * size + 1;
        b[i].r = i * size;
    }
    for (int i = 0; i < m; ++i)
    {
        char ch = getchar();
        while (ch != 'C' && ch != 'P')
            ch = getchar();
        if (ch == 'C')
        {
            int l = read(), r = read(), x = read();
            if (l > r)
                swap(l, r);
            paint(l, r, x);
        }
        else if (ch == 'P')
        {
            int l = read(), r = read();
            if (l > r)
                swap(l, r);
            printf("%d\n", query(l, r));
        }
    }
    return 0;
}
```

---

## 作者：7KByte (赞：5)

#### 刚刚立了个flag：今后题解绝不说废话  
### ~~真香~~  
题目应该不是很难，思路也比较裸，注意一下里面的区间可能是倒着给的


------------
## 步入正题
- 题目的大意很简单，给定一个区间，给子区间涂一种颜色，或者查询一个区间内有多少种颜色
- 区间修改和查询且要求复杂度为(nlogn),很显然是一颗线段树了
- 对于每个节点的data和tag，我们固然可以开一个**bool[30]的数组**,但是这样做合并和查询都将要付出额外的复杂度，可能把正解T掉。显然这里我们可以进行**状态压缩**(在二进制下第i位为一表示有第i种颜色)，颜色小于30种则我们直接开一个int变量即可，合并时直接将两个变量**按位或**即可（线段树的每个节点的data等于左右子节点的data**按位或**的结果）


-----------
## 代码部分
```
整体框架就是线段树模板，以及位运算模板，具体实现细节看程序
```
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int data;
	int l,r;
	int tag;
}a[100010*4];
void build(int p,int l,int r){
	a[p].tag=0;a[p].l=l;a[p].r=r;
	a[p].data=1;
	if(l==r)
		return;
	int mid=(l+r)>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
int count(int x){
	int sum=0;
	while(x){
		sum+=x%2;
		x/=2;
	}
	return sum;
}
int go(int x){
	int sum=1;
	x--;
	while(x)
	  sum*=2,x--;
	return sum;
}
void down(int p){
	a[p*2].data=a[p].tag;
	a[p*2+1].data=a[p].tag;
	a[p*2].tag=a[p].tag;
	a[p*2+1].tag=a[p].tag;
	a[p].tag=0;
}
int ask(int p,int l,int r){
	if(a[p].l>=l&&a[p].r<=r)
	  return a[p].data;
	if(a[p].tag)down(p);
	int mid=(a[p].l+a[p].r)>>1;
	int x=0;
	if(mid>=l)x=x|ask(p*2,l,r);
	if(mid<r)x=x|ask(p*2+1,l,r);
	return x;
}
void change(int p,int l,int r,int x){
	if(a[p].l>=l&&a[p].r<=r){
		a[p].data=x;
		a[p].tag=x;
		return;
	}
	if(a[p].tag)down(p);
	int mid=(a[p].l+a[p].r)>>1;
	if(mid>=l)change(p*2,l,r,x);
	if(mid<r)change(p*2+1,l,r,x);
	a[p].data=a[p*2].data|a[p*2+1].data;
}
int main()
{
	int l,t,m;
	scanf("%d%d%d",&l,&t,&m);
	build(1,1,l);
	for(int i=1;i<=m;i++){
		char k[10];
		int x,y,z;
		scanf("%s",k);
		if(k[0]=='C'){
			scanf("%d%d%d",&x,&y,&z);
			if(x>y)swap(x,y);
			change(1,x,y,go(z));
		}
		else{
			scanf("%d%d",&x,&y);
			if(x>y)swap(x,y);
			printf("%d\n",count(ask(1,x,y)));
		}
	}
	return 0;
}
```

---

## 作者：Strelitzia (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1558)

---

分块真是万能……

这道题各位巨佬用了各种方式，我就在这提供一种比较简单易懂的分块方法。

分块维护一个序列的颜色，时间复杂度比较稳定，就算颜色增加，

会变的只有$\texttt{memset(vis,0,sizeof vis)}$。

个人认为还是一种比较好的方法。

---

$\texttt{vis}$是看颜色出现过了吗，$\texttt{sum}$其实是$\texttt{tag}$，其他的比较明显。

---

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	T f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

const int maxn = 100005;

int n,t,m;
int pos[maxn],res[maxn * 10],L[maxn],R[maxn];
int vis[40],sum[maxn],a[maxn];

void update(int l,int r,int z) {
	int p = pos[l],q = pos[r];
	if (sum[p]) for (int i = L[p] ; i <= R[p] ; ++ i) a[i] = sum[p];
	sum[p] = 0;
	if (sum[q]) for (int i = L[q] ; i <= R[q] ; ++ i) a[i] = sum[q];
	sum[q] = 0;
	if (p == q) for (int i = l ; i <= r ; ++ i) a[i] = z;
	else {
		for (int i = l ; i <= R[p] ; ++ i) a[i] = z;
		for (int i = L[q] ; i <= r ; ++ i) a[i] = z;
		for (int i = p + 1 ; i <= q - 1 ; ++ i) sum[i] = z;
	}
}

int solve(int x) {
	int res = 0;
	for (int i = L[x] ; i <= R[x] ; ++ i) res += vis[a[i]] ++ == 0;
	return res;
}

int query(int l,int r) {
	int p = pos[l],q = pos[r],res = 0;
	if (sum[p]) for (int i = L[p] ; i <= R[p] ; ++ i) a[i] = sum[p];
	sum[p] = 0;
	if (sum[q]) for (int i = L[q] ; i <= R[q] ; ++ i) a[i] = sum[q];
	sum[q] = 0;
	if (p == q) for (int i = l ; i <= r ; ++ i) res += vis[a[i]] ++ == 0;
	else {
		for (int i = l ; i <= R[p] ; ++ i) res += vis[a[i]] ++ == 0;
		for (int i = L[q] ; i <= r ; ++ i) res += vis[a[i]] ++ == 0;
		for (int i = p + 1 ; i <= q - 1 ; ++ i) if (!sum[i]) res += solve(i);else res += vis[sum[i]] ++ == 0;
	}
	return res;
}

int main() {
	read(n);read(t);read(m);
	int t = sqrt(n);
	for (int i = 1 ; i <= t ; ++ i) {
		L[i] = R[i - 1] + 1;
		R[i] = i * t;
	}
	if (R[t] != n) ++ t,L[t] = R[t - 1] + 1,R[t] = n;
	for (int i = 1 ; i <= t ; ++ i) for (int j = L[i] ; j <= R[i] ; ++ j) pos[j] = i;
	for (int i = 1 ; i <= n ; ++ i) {
		a[i] = 1;
		sum[pos[i]] = 1;
	}
	char s[4];
	int x,y,z;
	for (int i = 1 ; i <= m ; ++ i) {
		scanf("%s",s);
		read(x);read(y);
		if (x > y) swap(x,y);
		if (*s == 'C') {
			read(z);
			update(x,y,z);
		}
		else {
			memset(vis,0,sizeof vis);
			printf("%d\n",query(x,y));
		}
	}
	return 0;
}
```

---

## 作者：Adove (赞：4)

这道题颜色比较少，压位相对比较简单，但是如果T再大一些，压位就比较麻烦了

于是我们就需要一种叫做**bitset**的东西

bitset做这种题相当方便，两个bitset可以直接**或**起来，统计1的个数时使用内部函数**.count()**，输出很方便

上代码↓
```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<bitset>
#include<algorithm>
using namespace std;

bitset<31> bist[1<<19];
int chg[1<<19];
int n,t,o,l,r,c1,c;
char ch;

void po(int k,int l,int r){
	if(chg[k]==0) return;
	if(l==r){
		chg[k]=0;
		return;
	}
	int i=k<<1;
	chg[i]=chg[i|1]=chg[k];
	bist[i].reset();
	bist[i|1].reset();
	bist[i|1][chg[k]]=bist[i][chg[k]]=1;
	chg[k]=0;
}

void cchg(int c,int k,int l,int r,int le,int ri){
	po(k,l,r);
	if(le<=l&&r<=ri){
		bist[k].reset();
		bist[k][c]=1;
		chg[k]=c;
		return;
	}
	int i=k<<1,mid=(l+r)>>1;
	if(le<=mid) cchg(c,i,l,mid,le,ri);
	if(mid<ri) cchg(c,i|1,mid+1,r,le,ri);
	bist[k]=bist[i]|bist[i|1];
}
bitset<31> ask(int k,int l,int r,int le,int ri){
	po(k,l,r);
	if(le<=l&&r<=ri) return bist[k];
	int i=k<<1,mid=(l+r)>>1;
	bitset<31> sum; 
	if(le<=mid) sum=ask(i,l,mid,le,ri);
	if(mid<ri) sum|=ask(i|1,mid+1,r,le,ri);
	return sum;
}
int main(){
	scanf("%d%d%d",&n,&t,&o);
	for(int i=1;i<=n<<2;++i) bist[i][1]=1;
	while(o--){
		scanf("\n%c%d%d",&ch,&l,&r);
		if(l>r) swap(l,r);
		if(ch=='C'){
			scanf("%d",&c);
			cchg(c,1,1,n,l,r);
		}else{
			printf("%d\n",ask(1,1,n,l,r).count());
		}
	}
	return 0;
}
```

---

## 作者：Created_equal1 (赞：4)

由于颜色比较少，所以对颜色的处理可以压位来搞。

然后就是普通的线段树啦~

```cpp

#include <cstdio>  
#include <algorithm>  
  
using namespace std;  
  
void Get_Val(int &Ret)  
{  
    Ret = 0;  
    char ch;  
    while ((ch = getchar()), (ch > '9' || ch < '0'))  
        ;  
    do  
    {  
        (Ret *= 10) += ch - '0';  
    }  
    while ((ch = getchar()), (ch >= '0' && ch <= '9'));  
}  
  
const int Max_L(100050);  
  
struct node  
{  
    int l, r;  
    unsigned int Colour;  
    unsigned int Tag;  
};  
  
struct Segment_Tree  
{  
    node segt[Max_L << 2];  
    void build_tree(const int&, const int&, const int&);  
    void pushdown(const int&);  
    void pushup(const int&);  
    void Set(const int&, const int&, const int&, const unsigned int&);  
    unsigned int Ask(const int&, const int&, const int&);  
};  
Segment_Tree Wood;  
  
int L, T;  
int O;  
  
void Segment_Tree::build_tree(const int &cur, const int &l, const int &r)  
{  
    segt[cur].l = l, segt[cur].r = r, segt[cur].Tag = 0;  
    segt[cur].Colour = (1 << 1);  
    int mid = l + ((r - l) >> 1);  
    if (l != r)  
    {  
        build_tree(cur << 1, l, mid);  
        build_tree((cur << 1) | 1, mid + 1, r);  
    }  
}  
  
inline  
void Segment_Tree::pushdown(const int &cur)  
{  
    if (segt[cur].Tag == 0)  
        return;  
    segt[cur << 1].Tag = segt[(cur << 1) | 1].Tag = segt[cur].Tag;  
    segt[cur << 1].Colour = segt[(cur << 1) | 1].Colour = (1 << segt[cur].Tag);  
    segt[cur].Tag = 0;  
}  
  
inline  
void Segment_Tree::pushup(const int &cur)  
{  
    segt[cur].Colour = (segt[cur << 1].Colour | segt[(cur << 1) | 1].Colour);  
}  
  
void Segment_Tree::Set(const int &cur, const int &l, const int &r, const unsigned int &c)  
{  
    if (l <= segt[cur].l && r >= segt[cur].r)  
    {  
        segt[cur].Colour = (1 << c);  
        segt[cur].Tag = c;  
        return;  
    }  
    int mid = segt[cur].l + ((segt[cur].r - segt[cur].l) >> 1);  
    pushdown(cur);  
    if (r <= mid)  
        Set(cur << 1, l, r, c);  
    else  
        if (l > mid)  
            Set((cur << 1) | 1, l, r, c);  
        else  
        {  
            Set(cur << 1, l, mid, c);  
            Set((cur << 1) | 1, mid + 1, r, c);  
        }  
    pushup(cur);  
}  
  
unsigned int Segment_Tree::Ask(const int &cur, const int &l, const int &r)  
{  
    if (l <= segt[cur].l && r >= segt[cur].r)  
        return segt[cur].Colour;  
    int mid = segt[cur].l + ((segt[cur].r - segt[cur].l) >> 1);  
    pushdown(cur);  
    if (r <= mid)  
        return Ask(cur << 1, l, r);  
    else  
        if (l > mid)  
            return Ask((cur << 1) | 1, l, r);  
        else  
            return Ask(cur << 1, l, mid) | Ask((cur << 1) | 1, mid + 1, r);  
}  
  
char op[3];  
int A, B, C;  
unsigned int Ans, Cnt;  
  
int main()  
{  
    Get_Val(L), Get_Val(T), Get_Val(O);  
    Wood.build_tree(1, 1, L);  
    while (O--)  
    {  
        scanf("%s", op);  
        if (op[0] == 'C')  
        {  
            Get_Val(A), Get_Val(B), Get_Val(C);  
            if (A > B)  
                swap(A, B);  
            Wood.Set(1, A, B, C);  
        }  
        else  
        {  
            Get_Val(A), Get_Val(B);  
            if (A > B)  
                swap(A, B);  
            Ans = Wood.Ask(1, A, B);  
            Cnt = 0;  
            while (Ans)  
            {  
                if (Ans & 1)  
                    ++Cnt;  
                Ans >>= 1;  
            }  
            printf("%u\n", Cnt);  
        }  
    }  
    return 0;   
} 

```

---

## 作者：Baihua (赞：3)

### P1558 色板游戏

思路：位运算，状态压缩，线段树

1. #### 分析思路

   * 求某个区间的颜色集合的运算时支持 **结合律**的 ；
   * 看到 $T≤30$ 能想到 **状态压缩** ；
   * 所以可以设置状态：$\text{X}$的二进制下的第$\text{i}$位为$\text{1}$表示有第$\text{i}$种颜色，否则没有 ；
   * 合并两个状态用到了按位或运算 ；


2. #### 线段树

   * $\text{Pushup}$ 操作直接求或运算即可
   * 其他操作照常


3. #### Code

   ```c++
   #include <stdio.h>
   #include <string.h>
   #define Clean(X) memset(X,0,sizeof(X))
   #define LS RT*2
   #define RS RT*2+1
   const int MaxL = 100005 , MaxK = 30;
   unsigned L , K , O ;
   inline unsigned QRead () {
   	unsigned X = 0;
   	char C = getchar() ;
   	while (C > '9' || C < '0') C = getchar() ;
   	while (C >='0' && C <='9') {
   		X = X * 10 + C -'0' ;
   		C = getchar() ;
   	}
   	return X ;
   }
   /*
   头文件和准备工作
   */
   unsigned Cnt(unsigned X) {
   	unsigned Ans = 0 ;
   	while (X) {
   		++Ans ;
   		X -= (X&(-X)) ;
   	}
   	return Ans ;
   }
   /*
   Cnt函数可以统计一个数的二进制位种所含有的1的个数。
   每次进行Lowbit运算，都消除了一个1和它后面的0。
   */
   unsigned Date[MaxL * 4] , Left[MaxL * 4] , Right [MaxL * 4] , Tag[MaxL * 4] ;
   void Plant (unsigned RT , unsigned L , unsigned R) {
   	Left[RT] = L , Right[RT] = R ;
   	Date[RT] = 1 ;
   	Tag[RT] = 0 ;
   	if (L == R) return  ;
   	unsigned Mid = (L + R) >> 1 ;
   	Plant (LS , L , Mid) , Plant (RS , Mid + 1 , R) ;
   }
   inline void Spd (unsigned RT) {
   	Tag[LS] = Tag[RS] = Date[LS] = Date[RS] = Tag[RT];
   	Tag[RT] = 0 ;
   }
   unsigned Ask (unsigned RT , unsigned L , unsigned R) {
   	if (Left[RT] >= L && Right[RT] <= R) return Date[RT] ;
   	unsigned Mid = (Left[RT] + Right[RT] ) >> 1 , Al = 0 , Ar = 0;
   	if (Tag[RT])Spd(RT) ;
   	if (L <= Mid) Al = Ask (LS , L , R) ;
   	if (R >  Mid) Ar = Ask (RS , L , R) ;
   	return Al | Ar ;
   }
   void Add (unsigned RT , unsigned L , unsigned R,unsigned K) {
   	if (Left[RT] >= L && Right[RT] <= R) {
   		Date[RT] = Tag[RT] = K ;
   		return  ;
   	}
   	unsigned Mid = (Left[RT] + Right[RT] ) >> 1 ;
   	if (Tag[RT] )Spd (RT) ;
   	if (L <= Mid) Add (LS , L , R , K) ;
   	if (R >  Mid) Add (RS , L , R , K) ;
   	Date[RT] = Date[LS] | Date[RS] ;
   }
   /*
   线段树的基本函数
   */
   void Swap(unsigned int &X, unsigned int &Y) {
   	int T = X ;
   	X = Y ;
   	Y = T ;
   }
   int main () {
   //	freopen ("P1558.in" , "r" , stdin) ;
   	L = QRead () , K = QRead () , O = QRead () ;
   	Plant (1 , 1 , L) ;
   	for (register unsigned i = 1 ;  i <= O ; ++ i) {
   		char C = getchar() ;
   		while (C != 'P' && C != 'C') C = getchar() ;
   		if (C == 'C') {
   			unsigned L = QRead () , R = QRead () , Cl = QRead () - 1 ;
   			if (L > R) Swap (L , R) ;
   			Add (1 , L , R , 1 << Cl) ;
   		} else {
   			unsigned L = QRead () , R = QRead () ;
   			if (L > R) Swap (L , R) ;
   			printf ("%d\n" , Cnt (Ask (1 , L , R)));
   		}
   	}
   	fclose (stdin) ;
   	fclose (stdout);
   	return 0;
   }
   ```

#### Thanks!

---

## 作者：wmxwmx (赞：3)

首先献给某些迷之0分的童鞋题目说明：**（可能A> B），也就是说假如出现A>B的时候，记得把AB反过来询问或修改！**


##好，这道题是一道明显的**线段树**。


- 因为T很小只有30，完全可以**状态压缩处理颜色**。

- **区间加法**的时候用**按位或运算**。

- **输出的时候循环color有多少个1就好了**，我是用lowbit处理的，（可能比直接for一遍快一点？不过这不重要

###以上是主体思路，以下是我处理的几个优化。

- 这道题的**lazy-tag不需要存颜色**，因为假如有需要用到lazy-tag的change/modify的话，那么一定是一片全部搞成某个颜色的，所以在有tag而且update（下传tag）之前，current区间里面的颜色一定是纯色的，也就是说update的时候不需要tag的信息，直接把child全部搞成与current一样的颜色就好了，所以**tag的唯一存在目的就是一个bool变量而已**（有无tag）。

- 还有就是在询问的时候，不需要像平时一样，下传tag之后继续递归询问区间。因为当你tag不等于false时（就是说需要下传tag），目前区间的孩子里面的颜色和目前区间的颜色一定是一样的而且是纯色（因为假如出现有不是纯色，那么你肯定在此区间孩子中执行过change/modify，也就是说你一定update过），也就是说，其实你**在询问的时候根本就不需要update，见到tag=true直接return 目前颜色就好了**。

- 最后就是一个大家都常忽视的一个点，就是在用堆储存线段树的时候大家习惯开4倍空间，实际上是对空间的极大浪费（而且有的人还在4倍空间的基础上再加了5-10个以防万一。。其实本身就完全不可能达到4倍空间，最坏情况也是比4倍空间小4的23333）而我作为一个强迫症患者，平时总是喜欢卡数据范围（你给我最大多少我就只开多少）的设数组（坏习惯大家别模仿），自然也会先算出来最大的空间是多少了，**本题数组最大个数只用开到262145**。不多不少。

###下面是代码时间，正好没有pascal的题解（虽然过几年pascal连NOIP都上不了了），我就过来放个= =。

[P.S.]我的线段树是继承了我看的数据结构书里面的写法，所以存的区间是[l,r)这样的（这就是为啥建的时候我建的是(1,n+1)），而且在change和query的时候也有点不大一样，希望不要介意。

```cpp
program P1558;
const maxt=262145;
type
    node=record
    left:longint;
    right:longint;
    color:longint;
    delta:boolean;
    end;

var n,tot,m,i,le,ri,col:longint;
    c:char;
    a:array[1..maxt]of node;

function lowbit(x:longint):longint;
begin
    exit(x and (-x));
end;

function count(x:longint):longint;
begin
    count:=0;
    while x<>0 do
    begin
        inc(count);
        dec(x,lowbit(x));
    end;
end;

procedure update(cur:longint);
var left,right:longint;
begin
    left:=cur shl 1;
    right:=left+1;
    a[left].color:=a[cur].color;
    a[right].color:=a[cur].color;
    a[left].delta:=true;
    a[right].delta:=true;
    a[cur].delta:=false;
end;

procedure change(cur,l,r,delta:longint);
var left,right,mid:longint;
begin
    if (l<=a[cur].left)and(a[cur].right<=r) then
    begin
        a[cur].color:=1 shl (delta-1);
        a[cur].delta:=true;
    end
    else
    begin
        left:=cur shl 1;
        right:=left+1;
        mid:=(a[cur].left+a[cur].right)shr 1;
        if a[cur].delta then
        update(cur);
        if l<mid then
        change(left,l,r,delta);
        if r>mid then
        change(right,l,r,delta);
        a[cur].color:=a[left].color or a[right].color;
    end;
end;

function query(cur,l,r:longint):longint;
var left,right,mid:longint;
begin
    if ((l<=a[cur].left)and(a[cur].right<=r))or(a[cur].delta) then
    exit(a[cur].color)
    else
    begin
        left:=cur shl 1;
        right:=left+1;
        mid:=(a[cur].left+a[cur].right)shr 1;
        query:=0;
        if l<mid then
        query:=query or query(left,l,r);
        if r>mid then
        query:=query or query(right,l,r);
    end;
end;

procedure built(cur,l,r:longint);
var left,right,mid:longint;
begin
    a[cur].left:=l;
    a[cur].right:=r;
    a[cur].color:=1;
    a[cur].delta:=false;
    if l+1<r then
    begin
        left:=cur shl 1;
        right:=left+1;
        mid:=(l+r)shr 1;
        built(left,l,mid);
        built(right,mid,r);
    end;
end;

begin
    readln(n,tot,m);
    built(1,1,n+1);
    for i:=1 to m do
    begin
        read(c);
        if c='C' then
        begin
            readln(le,ri,col);
            if le<=ri then
            change(1,le,ri+1,col)
            else
            change(1,ri,le+1,col);
        end
        else
        begin
            readln(le,ri);
            if le>ri then
            writeln(count(query(1,ri,le+1)))
            else
            writeln(count(query(1,le,ri+1)));
        end;
    end;
end.
```

---

## 作者：Timothy (赞：2)

给个详细点的题解（表示楼下的有点简单）

【题目大意】

色板长度为L，L是一个正整数，所以我们可以均匀地将它划分成L块1厘米长的小方格。并从左到右标记为1, 2, ... L。现在色板上只有一个颜色，老师告诉阿宝在色板上只能做两件事：1. "C A B C" 指在A到 B 号方格中涂上颜色C。2. "P A B" 指老师的提问：A到B号方格中有几种颜色。学校的颜料盒中一共有 T 种颜料。为简便起见，我们把他们标记为1,2, ...T.开始时色板上原有的颜色就为1号色。

【算法讨论】

这道题运用线段树成段更新的算法。用sum[i]表示第i个区间颜色的总数；用color[i][1…T]表示第i个区间里颜色的情况，当color[i][j]==true时，则表示第i个区间中有j这种颜色，当color[i][j]==false时，则表示第i个区间中没有j这种颜色；用col[i]表示第i个区间是否有进行过更改。

1）当读入“C A B C”时，则将区间[A,B]中的sum赋值为1（即该区间共有一种颜色），把color赋值成false（颜色C除外），把col赋值成C（表示该区间的颜色均改为C）。

2）当读入“P A B”时，则将区间[A,B]中的颜色进行汇总，输出颜色的总数。

得分：100

时间复杂度：O(MlogL)

空间复杂度：O(L\*12)

【C++代码】

```cpp

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#include<ctime>
#include<cstring>
#define maxn 100001
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;
bool color[maxn<<2][31],query[31];
int col[maxn<<2],sum[maxn<<2],n,t,m;
void build(int l,int r,int rt)
{
    sum[rt]=1;
    color[rt][1]=true;
    if (l==r)return;
    int mid=(l+r)>>1;
    build(lson);
    build(rson);
}
void pushup(int rt)
{
    sum[rt]=0;
    for (int b=1;b<=t;++b)
    {
        color[rt][b]=false;
        if (color[rt<<1][b] || color[rt<<1|1][b])
        {
            color[rt][b]=true;
            sum[rt]++;
        }
    }
}
void pushdown(int rt)
{
    col[rt<<1]=col[rt<<1|1]=col[rt];
    for (int b=1;b<=t;++b)color[rt<<1][b]=false;
    color[rt<<1][col[rt]]=true;sum[rt<<1]=1;
    for (int b=1;b<=t;++b)color[rt<<1|1][b]=false;
    color[rt<<1|1][col[rt]]=true;sum[rt<<1|1]=1;
    col[rt]=0;
}
void update(int l,int r,int rt,int i,int j,int k)
{
    
    if (i<=l && r<=j)
    {
        col[rt]=k;
        for (int b=1;b<=t;++b)color[rt][b]=false;
        color[rt][k]=true;
        sum[rt]=1;
        return;
    }
    if (col[rt])pushdown(rt);
    int mid=(l+r)>>1;
    if (i<=mid)update(lson,i,j,k);
    if (mid<j)update(rson,i,j,k);
    pushup(rt);
}
void Query(int l,int r,int rt,int i,int j)
{
    if (i<=l && r<=j)
    {
        for (int b=1;b<=t;++b)if (color[rt][b])query[b]=true;
        return;
    }
    if (col[rt])pushdown(rt);
    int mid=(l+r)>>1;
    if (i<=mid)Query(lson,i,j);
    if (mid<j)Query(rson,i,j);
}
int main()
{
    scanf ("%d%d%d",&n,&t,&m);
    build(1,n,1);
    for (int b=1;b<=m;++b)
    {
        char c;
        int i,j,k;
        cin >>c;
        if (c=='C')
        {
            scanf ("%d%d%d",&i,&j,&k);
            if (i>j){int g=i;i=j;j=g;}
            update(1,n,1,i,j,k);
        }
        else
        {
            scanf ("%d%d",&i,&j);
            if (i>j){int g=i;i=j;j=g;}
            Query(1,n,1,i,j);
            int ans=0;
            for (int b=1;b<=t;++b){ans+=query[b];query[b]=0;}
            printf ("%d\n",ans);
        }
    }
    return 0;
}

```

---

## 作者：kradcigam (赞：1)

这道题目，我们发现 $1\leq t\leq 30$，$t$ 的值非常小。

考虑建 $t$ 棵线段树，每颗线段树维护是否有这种颜色，需要区间全部清零和区间全部赋值。

我使用的是封装数据结构，注释写的很清楚了

```cpp
#include <bits/stdc++.h>
#define ls num<<1
#define rs num<<1|1
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
const int MAXN=1e5+10;
int a[MAXN];
struct Line_Tree{
	struct Tree{
		int l,r,lazy;//lazy:1为区间赋值，2为区间清零
		bool f;
	}t[MAXN<<2];
	void pushup(int num){
		t[num].f=(t[ls].f||t[rs].f);//只要有一个部分有这种颜色，就说明这个区间有这种颜色。
	}
	void pushdown(int num){
		if(t[num].lazy){
			t[ls].lazy=t[rs].lazy=t[num].lazy;//lazy的传递，由于是区间覆盖，所以直接赋值
			t[ls].f=t[rs].f=(t[num].lazy==1);//1为区间赋值，2为区间清零
			t[num].lazy=0;
		}
	}
	void build(int num,int l,int r,int x){
		t[num].l=l;t[num].r=r;t[num].lazy=false;
		if(l==r){
			t[num].f=(a[l]==x);//显然QAQ
			return;//直接return
		}int mid=(l+r)>>1;
		build(ls,l,mid,x);
		build(rs,mid+1,r,x);
		pushup(num);//注意pushup
	}
	void change1(int num,int l,int r){
		if(t[num].l>=l&&t[num].r<=r){
			t[num].lazy=1;//打标记
			t[num].f=true;//直接操作
			return;//直接return
		}pushdown(num);//注意标记下传
		if(t[ls].r>=l)change1(ls,l,r);
		if(t[rs].l<=r)change1(rs,l,r);
		pushup(num);//注意pushup
	}
	void change2(int num,int l,int r){
		if(t[num].l>=l&&t[num].r<=r){
			t[num].lazy=2;//打标记
			t[num].f=false;//直接操作
			return;//直接return
		}pushdown(num);//注意标记下传
		if(t[ls].r>=l)change2(ls,l,r);
		if(t[rs].l<=r)change2(rs,l,r);
		pushup(num);//注意pushup
	}
	bool query(int num,int l,int r){
		if(t[num].l>=l&&t[num].r<=r)return t[num].f;//直接看
		pushdown(num);//注意标记下传
		if(t[ls].r<l)return query(rs,l,r);
		if(t[rs].l>r)return query(ls,l,r);
		return (query(ls,l,r)||query(rs,l,r));//只要有一个是就是了
	}
}T[32];//线段树
int main(){
	int n,t,E;read(n);read(t);read(E);
	for(int i=1;i<=n;i++)a[i]=1;//初始化
	for(int i=1;i<=t;i++)T[i].build(1,1,n,i);//初始化
	while(E--){
		char f=getchar();int a,b,c;
		for(;f!='C'&&f!='P';)f=getchar();
		read(a);read(b);if(a>b)swap(a,b);
		if(f=='C'){
			read(c);
			for(int i=1;i<=t;i++)//枚举颜色
				if(i==c)T[i].change1(1,a,b);//区间赋值
				else T[i].change2(1,a,b);//区间清零
		}else{
			int s=0;//计数器
			for(int i=1;i<=t;i++)//枚举颜色
				if(T[i].query(1,a,b))s++;//如果有这种颜色
			printf("%d\n",s);//输出
		}
	}
	return 0;
}
```

---

## 作者：GHJhandsome (赞：1)

让我们看看数据范围：100000和30
100000意味着我们要用O(nlogn^k)的效率
那么我们就用最简单的线段树
```cpp
滑稽
```
那么怎么求一段区间内的个数呢？
```
滑稽
```
我们可以用状态转移
用c[i]存区间[l,r]的状态
假设c[i]等于13
```
c[i]=13
它的二进制就是1101
倒数第一位1代表含有第一种颜色
倒数第二位0代表不含有第二种颜色
倒数第三位1代表含有第三种颜色
倒数第四位1代表含有第四种颜色
```
为什么用状态转移呢？
因为爱情（
```
假设c[i<<1]=5=(0101)
c[(i<<1)+1]=9=(1001)
那么c[i]=c[i<<1]|c[(i<<1)+1]=0101|1001=1101=13
按位与完美地解决了状态转移的合并问题
```
有的同学可能会问：状态转移怎么算个数内？
代码如下
```
void deal(int x){
	int i=0;
	while(x){
		i++;
		x=x&(x-1);
	}
	cout<<i<<endl;
	return;
}



例如：1111
1111|1110=1110
1110|1101=1100
1100|1011=1000
1000|0111=0000
完美
```
接下来该处理线段树惹
```
void up(int e,int f,int k,int l,int r,int x){
	if(e<=l&&r<=f){
		lazy[x]=k;
		c[x]=1<<(k-1);
		return;
	} 
	if(l>f||r<e){
		return;
	}
	int mid=(l+r)>>1; 
	if(lazy[x]){
		lazy[x<<1]=lazy[x];
		lazy[(x<<1)+1]=lazy[x];
		c[x<<1]=1<<(lazy[x]-1);
		c[(x<<1)+1]=1<<(lazy[x]-1);
		lazy[x]=0;
	}
	up(e,f,k,l,mid,x<<1);
	up(e,f,k,mid+1,r,(x<<1)+1);
	c[x]=c[x<<1]|c[(x<<1)+1];
	//cout<<l<<" "<<r<<" "<<c[x]<<" "<<lazy[x]<<endl; 
	return;
}
这个是改色
c[x]=1<<(k-1);讲的是区间内全部改色
自己理解
```
```

int que(int e,int f,int l,int r,int x){
	if(e<=l&&r<=f){
		return c[x];
	}
	if(l>f||r<e){
		return 0;
	}
	if(lazy[x]!=0){
		lazy[x<<1]=lazy[x];
		lazy[(x<<1)+1]=lazy[x];
		c[x<<1]=1<<(lazy[x]-1);
		c[(x<<1)+1]=1<<(lazy[x]-1);
	}
	int mid=(l+r)>>1,ans=que(e,f,l,mid,x<<1)|que(e,f,mid+1,r,(x<<1)+1);
	c[x]=c[x<<1]|c[(x<<1)+1];
	lazy[x]=0;
	//cout<<l<<" "<<r<<" "<<c[x]<<" "<<c[x<<1]<<" "<<c[(x<<1)+1]<<" "<<lazy[x]<<endl; 
	return ans;
}
```
顺带说一下：询问区间可能l>r
自己要交换（我被卡了一次嘤嘤嘤）
上代码
```cpp
#include<iostream>
using namespace std;
int c[1000000],n,m,t,i,lazy[1000000],o,p,q;
char cc;
void build(int l,int r,int x){
	c[x]=1;
	lazy[x]=0;
	if(l!=r){
		int mid=(l+r)>>1;
		build(l,mid,x<<1);
		build(mid+1,r,(x<<1)+1);
	}
	return;
}
void up(int e,int f,int k,int l,int r,int x){
	if(e<=l&&r<=f){
		lazy[x]=k;
		c[x]=1<<(k-1);
		return;
	} 
	if(l>f||r<e){
		return;
	}
	int mid=(l+r)>>1; 
	if(lazy[x]){
		lazy[x<<1]=lazy[x];
		lazy[(x<<1)+1]=lazy[x];
		c[x<<1]=1<<(lazy[x]-1);
		c[(x<<1)+1]=1<<(lazy[x]-1);
		lazy[x]=0;
	}
	up(e,f,k,l,mid,x<<1);
	up(e,f,k,mid+1,r,(x<<1)+1);
	c[x]=c[x<<1]|c[(x<<1)+1];
	//cout<<l<<" "<<r<<" "<<c[x]<<" "<<lazy[x]<<endl; 
	return;
}
int que(int e,int f,int l,int r,int x){
	if(e<=l&&r<=f){
		return c[x];
	}
	if(l>f||r<e){
		return 0;
	}
	if(lazy[x]!=0){
		lazy[x<<1]=lazy[x];
		lazy[(x<<1)+1]=lazy[x];
		c[x<<1]=1<<(lazy[x]-1);
		c[(x<<1)+1]=1<<(lazy[x]-1);
	}
	int mid=(l+r)>>1,ans=que(e,f,l,mid,x<<1)|que(e,f,mid+1,r,(x<<1)+1);
	c[x]=c[x<<1]|c[(x<<1)+1];
	lazy[x]=0;
	//cout<<l<<" "<<r<<" "<<c[x]<<" "<<c[x<<1]<<" "<<c[(x<<1)+1]<<" "<<lazy[x]<<endl; 
	return ans;
}
void deal(int x){
	int i=0;
	while(x){
		i++;
		x=x&(x-1);
	}
	cout<<i<<endl;
	return;
}
int main(){
	cin>>n>>m>>t;
	build(1,n,1);
	for(i=0;i<t;i++){
		cin>>cc;
		if(cc=='C'){
			cin>>o>>p>>q;
			if(o>p){
				int w=o;
				o=p;
				p=w;
			}
			up(o,p,q,1,n,1);
		}
		else{
			cin>>o>>p;
			if(o>p){
				int w=o;
				o=p;
				p=w;
			}
			deal(que(o,p,1,n,1));
		}
	}
} 
```
然后没有了
别忘了点赞

---

## 作者：sunzh (赞：1)

# P1558 色板游戏 题解
思路：状态压缩+线段树
### 如何状压
假设p这段区间有a号色，则res[p]=(1<<a)，看题目$1 <= T <= 30$， $ 2^{30} $保险起见，开$ long  long $吧
### 浅谈线段树
![百度上的示意图](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=0f98b25f542c11dfded1b8255b1c05ed/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09.jpg)

线段树->用一个节点表示一段线段的树

#### 建树操作

开始时色板上原有的颜色就为1号色，先把每个点都涂上1号色，即赋值$1<<1$,也就是2

res[p]表示p区间内出现过的状态（颜色状压）
```cpp
void pushup(int p){
	res[p]=res[p<<1]|res[p<<1|1];
}
void build(int p,int l,int r){
    if(l==r){
        res[p]=2;
        return;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    pushup(p);
}
```
### 下放懒标记
#### 为什么要懒标记？
由于我们要做的操作是区间加一个数或乘一个数，所以我们不妨在区间进行修改时为该区间打上一个标记，就不必再修改他的儿子所维护区间，等到要使用该节点的儿子节点维护的值时，再将懒标记下放即可，可以节省很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间

**下传意味着整个区间被覆盖**，直接赋值，不用or（|）
```cpp
void pushdown(int p){
	if(tag[p]==0) return ;
	res[p<<1]=tag[p];
	res[p<<1|1]=tag[p];
	tag[p<<1]=tag[p];
	tag[p<<1|1]=tag[p];
	tag[p]=0;//懒标记记得清空
}
```

#### 更新颜色

涂上新颜色，原有颜色被覆盖
```cpp

void updata(int p,int l,int r,int L,int R,int c){
	if(l>=L&&r<=R){
		res[p]=(1<<c);
		tag[p]=(1<<c);//更新懒标记
		return ;
	}
	pushdown(p);
	int mid=l+r>>1;
	if(mid>=L) updata(p<<1,l,mid,L,R,c);
	if(mid<R) updata(p<<1|1,mid+1,r,L,R,c);//减少无意义的递归
	pushup(p);
} 
```
#### 查询
不多说了，上代码
```cpp
long long query(int p,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		return res[p];
	}
	pushdown(p);
	long long ans=0;
	int mid=l+r>>1;
	if(mid>=L) ans|=query(p<<1,l,mid,L,R);
	if(mid<R) ans|=query(p<<1|1,mid+1,r,L,R);
	return ans;
}
```


下面贴代码


~~其实就是组合起来~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<iomanip>
#include<cmath>
#include<algorithm>
using namespace std;
int inline read(){//水一波快读
	int num=0,neg=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
	while(isdigit(c)){num=(num<<3)+(num<<1)+(c^48);c=getchar();}
	return num*neg;
}
int n,t,m;
long long res[400010],tag[400010];
void pushup(int p){
	res[p]=res[p<<1]|res[p<<1|1];
}
void pushdown(int p){
	if(tag[p]==0) return ;
	res[p<<1]=tag[p];
	res[p<<1|1]=tag[p];
	tag[p<<1]=tag[p];
	tag[p<<1|1]=tag[p];
	tag[p]=0;
}
void build(int p,int l,int r){
    if(l==r){
        res[p]=2;
        return;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    pushup(p);
}
void updata(int p,int l,int r,int L,int R,int c){
	if(l>=L&&r<=R){
		res[p]=(1<<c);
		tag[p]=(1<<c);
		return ;
	}
	pushdown(p);
	int mid=l+r>>1;
	if(mid>=L) updata(p<<1,l,mid,L,R,c);
	if(mid<R) updata(p<<1|1,mid+1,r,L,R,c);
	pushup(p);
} 
long long query(int p,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		return res[p];
	}
	pushdown(p);
	long long ans=0;
	int mid=l+r>>1;
	if(mid>=L) ans|=query(p<<1,l,mid,L,R);
	if(mid<R) ans|=query(p<<1|1,mid+1,r,L,R);
	return ans;
}
int main(){
	n=read(),t=read(),m=read();
	build(1,1,n);
	for(int i=1;i<=m;i++){
		char c=getchar();
		while(c!='C'&&c!='P') c=getchar();
		switch(c){
			case 'C':{
				int a=read(),b=read(),c=read();
				if(a>b) swap(a,b);//坑点，不一定a<b
				updata(1,1,n,a,b,c);
				break;
			}
			case 'P':{
				int a=read(),b=read();
				if(a>b) swap(a,b);
				long long ans=query(1,1,n,a,b),sum=0;
				for(int i=1;i<=t;i++) if(ans&(1<<i)) sum++;
				printf("%lld\n",sum);
				break;
			}
		}
	}
	return 0;
}
```


---

## 作者：小菜鸟 (赞：1)

~~已经忘记线段树的平衡树选手报到~~

此题颜色数极少，显然可以对每种颜色暴力维护

但是写好几颗树很麻烦，我们就可以考虑把颜色压位

然后就得出区间合并的方法，`sum=lc->sum|rc->sum`

为了减少需要加一减一的边界细节，用平衡树来实现区间操作

~~fhqtxdy!~~

一定要注意，区间可能$l>r$，需要判断

真心感觉fhq好写，代码量跟线段树差不多甚至少于线段树

而且维护不同的信息只需要修改`pushdown`和`maintain`就行了

~~常数也可以接受~~

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>

struct Node
{
    int val,sum,size,tag,pri;
    Node *lc,*rc;
    Node(int v):
        val(v),
        sum(v),
        size(1),
        tag(0),
        pri(rand()),
        lc(NULL),
        rc(NULL)
    {}
    void push_down()
    {
        if(tag==0)return;
        val=tag;
        sum=tag;
        if(lc!=NULL)lc->tag=tag;
        if(rc!=NULL)rc->tag=tag;
        tag=0;
    }
    void maintain()
    {
        size=1;
        sum=val;
        if(lc!=NULL)
        {
            lc->push_down();
            size+=lc->size;
            sum|=lc->sum;
        }
        if(rc!=NULL)
        {
            rc->push_down();
            size+=rc->size;
            sum|=rc->sum;
        }
    }
};
Node *root;

Node *merge(Node *l,Node *r)
{
    if(l==NULL)return r;
    if(r==NULL)return l;
    if(l->pri<r->pri)
    {
        l->push_down();
        l->rc=merge(l->rc,r);
        l->maintain();
        return l;
    }
    else
    {
        r->push_down();
        r->lc=merge(l,r->lc);
        r->maintain();
        return r;
    }
}

void split(Node *rt,int k,Node *&l,Node *&r)
{
    if(rt==NULL)
    {
        l=r=NULL;
        return;
    }
    int s=0;
    if(rt->lc!=NULL)s=rt->lc->size;
    rt->push_down();
    if(s+1<k)
    {
        l=rt;
        split(l->rc,k-s-1,l->rc,r);
    }
    else
    {
        r=rt;
        split(r->lc,k,l,r->lc);
    }
    rt->maintain();
}

void paint(int l,int r,int c)
{
    Node *p1,*p2,*p3;
    split(root,r+1,p2,p3);
    split(p2,l,p1,p2);
    p2->tag=1<<c;
    root=merge(merge(p1,p2),p3);
}

int bit_count(int x)
{
    int res=0;
    while(x)
    {
        res+=x&1;
        x>>=1;
    }
    return res;
}

int query(int l,int r)
{
    Node *p1,*p2,*p3;
    split(root,r+1,p2,p3);
    split(p2,l,p1,p2);
    p2->push_down();
    int res=bit_count(p2->sum);
    root=merge(merge(p1,p2),p3);
    return res;
}

int n,m;

char readc()
{
    char c=getchar();
    while(c<'A'||c>'Z')c=getchar();
    return c;
}

int main()
{
    scanf("%d%*d%d\n",&n,&m);
    for(int i=0;i<n;++i)
    {
        root=merge(root,new Node(2));
    }
    while(m--)
    {
        char op;
        int l,r,c;
        op=readc();
        scanf("%d%d",&l,&r);
        if(l>r)std::swap(l,r);
        if(op=='C')
        {
            scanf("%d",&c);
            paint(l,r,c);
        }
        if(op=='P')
        {
            printf("%d\n",query(l,r));
        }
    }
}
```

---

## 作者：TheShadow (赞：1)

# 闲扯

一道线段树好题~~裸题~~

顺便吐槽一下出题人的数据。。。

最开始没看到 $A$ 可能大于 $B$ ，结果 $WA$ 了。。

# 题面

[题面](https://www.luogu.org/problem/P1558)

# Solution

看范围， $T\leq30$ ，发现可以用二进制表示是否包含每一种颜料，接下来的事就好办了。

对于操作 $1$ ，是一个区间覆盖，直接将 $s$ 变成 $1<<(C-1)$ ，表示这个区间现在只含有 $C$ 这种颜料，懒标记换一下。

下放也是一样的操作。

向上统计的时候直接用左区间的 $s$ 或上右区间的 $s$ 即 $T[cur].s=T[lc].s\mid T[rc].s$ 。

每一次查询时找到表示这段区间的 $s$ ，然后直接查看有包含几个 $1$ 即可。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(res*bas)%mod;
		bas=(bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,m,k,x,y,z;
char opt;
#define lc (cur<<1)
#define rc (cur<<1|1)
struct Seg_Tree{
	int tag,s;
}T[MAXN<<2];
il pushup(int cur){T[cur].s=T[lc].s|T[rc].s;}
il pushdown(int cur,int l,int r){
	if(!T[cur].tag) return ;
	T[lc].tag=T[rc].tag=T[cur].tag;
	T[lc].s=T[rc].s=1<<(T[cur].tag-1);
	T[cur].tag=0;
}
il build_tree(int cur,int l,int r){
	T[cur].s=1;
	if(l==r) return ;
	build_tree(lc,l,mid),build_tree(rc,mid+1,r);
}
it query(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) return T[cur].s;
	pushdown(cur,l,r);ri res=0;
	if(mid>=L) res|=query(lc,l,mid,L,R);
	if(R>mid) res|=query(rc,mid+1,r,L,R);
	return res;
}
il updata(int cur,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R) T[cur].s=1<<(k-1),T[cur].tag=k;
	else{
		pushdown(cur,l,r);
		if(mid>=L) updata(lc,l,mid,L,R,k);
		if(R>mid) updata(rc,mid+1,r,L,R,k);
		pushup(cur);
	}
}
it count(int x){
	ri res=0;
	while(x){
		if(x&1) res++;
		x>>=1;
	}
	return res;
}
int main()
{
//	freopen("testdata.in","r",stdin);
//	freopen("1.out","w",stdout);
	read(n),read(k),read(m);
	build_tree(1,1,n);
	for(ri i=1;i<=m;++i){
		cin>>opt;read(x),read(y);
		if(x>y) swap(x,y);
		if(opt=='C') read(z),updata(1,1,n,x,y,z);
		else{
			ri tmp=query(1,1,n,x,y);
			print(count(tmp)),puts("");
		}
	}
	return 0;
}
```

# 总结

蒟蒻颓了一晚上还是做点题吧。。

马上 $NOIP$ 了~~虽然它已经死了~~，感觉好慌呀 $qwq$ 。

这样的模板题要追求速度，同时还要保证正确率，不然考场上一慌就 $GG$ 。

---

## 作者：斗神_君莫笑 (赞：1)

又是一道花式线段树   
显然本题需要合并的是区间颜色数目   
~~看起来好难啊~~    
老话说得好，看数据规模知算法  
我们突然发现，颜色的数目只有30   
这个诡异的数字让我立即想到了二进制表示   
维护sum，其每一位表示是否有该种颜色在此区间   
具体请见代码    
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Node{
	int l,r,sum,lazy;
}T[400010];
inline void pushup(int p){
	T[p].sum=T[lc].sum|T[rc].sum;//将区间的信息用按位与合并 
}
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	if(l==r){
		T[p].sum=1;return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
}
inline void pushnow(int p,int v){//将区间直接覆盖,所以不需要维护其他信息的冲突 
	T[p].sum=v;T[p].lazy=v;
}
void pushdown(int p){
	if(T[p].lazy){
		pushnow(lc,T[p].lazy);
		pushnow(rc,T[p].lazy);
		T[p].lazy=0;
	}
}
void update(int p,int ql,int qr,int v){
	if(ql<=T[p].l&&T[p].r<=qr){
		pushnow(p,v);
		return;
	}
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)update(lc,ql,qr,v);
	if(qr>mid)update(rc,ql,qr,v);
	pushup(p);
}
int query(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p].sum;
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1,ans=0;
	if(ql<=mid)ans=ans|query(lc,ql,qr);
	if(qr>mid)ans=ans|query(rc,ql,qr);//同pushup 
	return ans;
}
int main(){
	//freopen("testdata.in","r",stdin);
	//freopen("my.out","w",stdout);
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	build(1,1,n);
	for(int i=1;i<=q;++i){
		char ch=getchar();
		while(ch!='C'&&ch!='P')ch=getchar();
		if(ch=='C'){
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			if(x>y)swap(x,y);
			int v=1;
			for(int j=1;j<z;++j)v<<=1;//将这种颜色转化到它对应的二进制数位上 
			update(1,x,y,v);
		}
		if(ch=='P'){
			int x,y;
			scanf("%d%d",&x,&y);
			if(x>y)swap(x,y);
			int q=query(1,x,y),ans=0;
			while(q){
				ans+=q&1;q>>=1;//提取出ans中所有有值的数位，即不同的颜色 
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}
```


---

## 作者：eros1on (赞：1)

[博客食用更佳~](https://tle666.github.io/2019/03/06/[luogu1558]%20%E8%89%B2%E6%9D%BF%E6%B8%B8%E6%88%8F/)

# **Description**

对于长度为$n$的数组$a$初始值都为$1$，有两种不同的操作：

- 将$a[l]$到$a[r]$赋值为$d$；
- 询问$a[l]$到$a[r]$有几种不同的数。

操作$m$次，$d \in [1,\ t]$

对于$100$%的数据，

$1 \leq n \leq 100000$，$1 \leq t \leq 30$，$1 \leq m \leq 100000$

[题目链接戳这里](https://www.luogu.org/problemnew/show/P1558)

# **Solution**

线段树的基础题 ~~然后我错了9遍~~

很有意思的一道题，有两种不同的解法

## **解法一**

比较暴力，建$t$棵线段树即可。

第$i$棵线段树只存值为$i$的数组有哪些。

**常数比较大。**

$6$次提交，不开$O2$最高只能$80$分，就算开了$O2$也只能$90$。。

你们自己想卡常就卡去吧。。

我的$80$分代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
#define MAXN 100100
int n, m, t;
char ch[2];
inline int read() {
    int s = 0, w = 1; char ch = getchar();
    while(ch < '0' || ch > '9') { if(ch == '-') w = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
    return s * w;
}
struct node {
    int left, right, mx, tag;
    node *ls, *rs;
    inline void seta(int x) { tag = x, mx = (x == 1 ? 1 : 0);}
    inline void upd() { mx = max(ls->mx, rs->mx);}
    inline void push() {
        if(tag) {
            if(ls) ls->seta(tag);
            if(rs) rs->seta(tag);
            tag = 0;
        }
    }
} pool[MAXN << 8], *root[35], *cnt = pool;
inline void build1(node *r, int left, int right) {
    r->left = left, r->right = right;
    if(left == right) {
        r->mx = 1; return ;
    } int mid = (left + right) >> 1;
    node *ls = ++cnt, *rs = ++cnt;
    r->ls = ls, r->rs = rs;
    build1(ls, left, mid), build1(rs, mid + 1, right);
    r->upd();
}
inline void build(node *r, int left, int right) {
    r->left = left, r->right = right;
    if(left == right) return ;
    int mid = (left + right) >> 1;
    node *ls = ++cnt, *rs = ++cnt;
    r->ls = ls, r->rs = rs;
    build(ls, left, mid), build(rs, mid + 1, right);
}
inline void change(node *r, int left, int right, int d) {
    if(r->left == left && r->right == right) {
        r->seta(d); return ;
    } r->push();
    if(r->ls->right >= right) change(r->ls, left, right, d);
    else if(r->rs->left <= left) change(r->rs, left, right, d);
    else change(r->ls, left, r->ls->right, d),
         change(r->rs, r->rs->left, right, d);
    r->upd();
}
inline int query(node *r, int left, int right) {
    r->push();
    if(r->left == left && r->right == right) return r->mx;
    if(r->ls->right >= right) return query(r->ls, left, right);
    else if(r->rs->left <= left) return query(r->rs, left, right);
    else return max(query(r->ls, left, r->ls->right),
                    query(r->rs, r->rs->left, right));
}
int main() {
    int A, B, C, ans;
    n = read(), t = read(), m = read();
    build1(root[1] = cnt, 1, n);
    for(int i = 2; i <= t; i++)
        build(root[i] = ++cnt, 1, n);
    while(m--) {
        scanf("%s", ch);
        A = read(), B = read();
        if(A > B) swap(A, B);
        if(ch[0] == 'C') {
            C = read();
            for(int i = 1; i <= t; i++)
                if(i != C) change(root[i], A, B, -1);
                else change(root[C], A, B, 1);
        }
        else {
            ans = 0;
            for(int i = 1; i <= t; i++)
                ans += query(root[i], A, B);
            printf("%d\n", ans);
        }
    }
    return 0;
}
```

## **解法二**

$100$%的正解。

用二进制来表示区间的取值情况。

比如$a_1 = 1,\ a_2 = 2,\ a_3 = 3,\ a_4 = 2$，

我们不妨设数值$i$是$2^{i - 1}$

则1,2合起来就是0011；

1,3合起来就是0101；

注意：**2,3,4合起来是0110而不是0120！**

大体上和解法一比较类似

# **Code**

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
#define MAXN 100100
int n, m, t;
char ch[2];
inline int read() {
    int s = 0, w = 1; char ch = getchar();
    while(ch < '0' || ch > '9') { if(ch == '-') w = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
    return s * w;
}
struct node {
    int left, right, s, tag; // s 就是存压位的那个。
    node *ls, *rs;
    inline void seta(int x) { s = (1 << (x - 1)), tag = x;}
    inline void upd() { s = (ls->s | rs->s);}
    inline void push() {
        if(tag) {
            if(ls) ls->seta(tag);
            if(rs) rs->seta(tag);
            tag = 0;
        }
    }
} pool[MAXN << 3], *root, *cnt = pool;
inline void build(node *r, int left, int right) {
    r->left = left, r->right = right;
    if(left == right) {
        r->s = 1; return ;
    } int mid = (left + right) >> 1;
    node *ls = ++cnt, *rs = ++cnt;
    r->ls = ls, r->rs = rs;
    build(ls, left, mid), build(rs, mid + 1, right);
    r->upd();
}
inline void change(node *r, int left, int right, int d) {
    if(r->left == left && r->right == right) {
        r->seta(d); return ;
    } r->push();
    if(r->ls->right >= right) change(r->ls, left, right, d);
    else if(r->rs->left <= left) change(r->rs, left, right, d);
    else change(r->ls, left, r->ls->right, d),
         change(r->rs, r->rs->left, right, d);
    r->upd();
}
inline int query(node *r, int left, int right) {
    r->push();
    if(r->left == left && r->right == right) return r->s;
    if(r->ls->right >= right) return query(r->ls, left, right);
    else if(r->rs->left <= left) return query(r->rs, left, right);
    else return (query(r->ls, left, r->ls->right) |
                query(r->rs, r->rs->left, right));
}
inline int count(int x) {
    int res = 0;
    for(int i = 30; i >= 0; i--)
        if(x >= (1 << i))
            x -= (1 << i), res++;
    return res;
}
int main() {
    int left, right, d;
    n = read(), t = read(), m = read();
    build(root = cnt, 1, n);
    while(m--) {
        scanf("%s", ch),
        left = read(), right = read();
        if(left > right) swap(left, right);
        if(ch[0] == 'C') {
            d = read();
            change(root, left, right, d);
        }
        else
            printf("%d\n", count(query(root, left, right)));
    }
    return 0;
}
/*
2 2 4
C 1 1 2
P 1 2
C 2 2 2
P 1 2

*/
```



---

## 作者：hl666 (赞：1)

		为了加深对线段树的记忆，然后开始搞这道题。

　　TM的WA了一下午就是发现x可能大于y（然而题目里说的还很清楚，我TM没看见）

　　这道题只需要在线段树的板子上改一些地方就可以了：

　　1.存储时不是存储颜色，而是将它状压成一个整数（如序号为3的颜色存为1<<3=8）

　　2.回溯时不是取和相加，而是直接按位或（|），原理等下讲

　　3.最后的查询完毕的值统计一下二进制下有多少个1就是ans

　　最后讲一下为什么要| 

　　假如3种颜色 2,3,3，在树上记为4,8,8，它们对应的二进制就是（100,1000,1000）

　　有没有发现，每个数的二进制下都只有一位上有1，而且不同颜色的数1的位置不同

　　因此在|的时候，只要这一位上有1，那么就一定有这种颜色

　　线段树就是板子，套一套就好了
  
		CODE
```        
#include<cstdio>
#include<iostream>
using namespace std;
const int N=100005;
int tree[N*4],add[N*4],l,t,o,x,y,z;
char ch;
inline void read(int &x)
{
    x=0; char ch=getchar(); int flag=1;
    while (ch<'0'||ch>'9') { if (ch=='-') flag=-1; ch=getchar(); }
    while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    x*=flag;
}
inline void write(int x)
{
    if (x/10) write(x/10);
    putchar(x%10+'0');
}
inline void up(int root) //递归回溯，注意是|不是+
{
    tree[root]=tree[root*2]|tree[root*2+1];
}
inline void down(int root) //标记下传，直接覆盖即可
{
    if (add[root])
    {
        tree[root*2]=add[root];
        tree[root*2+1]=add[root];
        add[root*2]=add[root];
        add[root*2+1]=add[root];
        add[root]=0;
    }
}
inline void build(int root,int l,int r) //递归建树
{
    if (l==r)
    {
        tree[root]=2;
        return;
    }
    int mid=l+r>>1;
    build(root*2,l,mid);
    build(root*2+1,mid+1,r);
    up(root);
}
inline void change(int root,int l,int r,int beg,int end,int col) //区间修改，注意既需要标记下传也需要更新回溯
{
    if (l>=beg&&r<=end)
    {
        tree[root]=1<<col;
        add[root]=1<<col;
        return;
    }
    down(root);
    int mid=l+r>>1;
    if (beg<=mid) change(root*2,l,mid,beg,end,col);
    if (end>mid) change(root*2+1,mid+1,r,beg,end,col);
    up(root);
}
inline int query(int root,int l,int r,int beg,int end) //区间查询，同样注意是|不是+
{
    if (l>=beg&&r<=end) return tree[root];
    down(root);
    int mid=l+r>>1,res=0;
    if (beg<=mid) res|=query(root*2,l,mid,beg,end);
    if (end>mid) res|=query(root*2+1,mid+1,r,beg,end);
    up(root);
    return res;
}
inline int calc(int x) //得到二进制数后再统计1的个数
{
    int res=0;
    while (x) 
    {
        if (x%2==1) res++;
        x>>=1;
    }
    return res;
}
int main()
{
    read(l); read(t); read(o);
    build(1,1,l);
    while (o--)
    {
        cin>>ch;
        if (ch=='C') 
        {
            read(x); read(y); read(z);
            if (x>y) swap(x,y);
            change(1,1,l,x,y,z); 
        }else
        {
            read(x); read(y);
            if (x>y) swap(x,y);
            write(calc(query(1,1,l,x,y))); putchar('\n');
        }
    }
    return 0;
}
  ```

---

## 作者：winmt (赞：1)

好久不发题解了～～～

这题其实是**线段树**的大水题啊，做这题本是想调节心情的，没料到RE一大堆。。。

**题目有剧毒：**

**“ (这里 A, B, C 为整数, 可能A>B) ”** 导致无限RE，还有就是我用了getchar然后继续谜之RE了。。。

不过得到这是POJ 2777 的题，去交了一发，惊喜的AC了，于是改了半天，把getchar换成scanf就在洛谷也AC了。。。

下面来讲一下**思路**：

首先这题与最传统线段树区别在于：**统计区间不同数字个数**。不过你可以看到修改的颜色是**连续**的，且**不超过30**.

这就非常好办了，直接**状态压缩**要修改的颜色。然后线段树上传统计时把左右孩子**按位或**起来便是。

最后区间答案中转成二进制里**“1”的个数**便是不同数字个数。

**另外意外的是：我的代码目测洛谷RK1，跑得飞快！196MS.**

**附代码：**








```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<queue>
#include<deque>
#include<utility>
#include<map>
#include<set>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<functional>
#include<sstream>
#include<cstring>
#include<bitset>
#include<stack>
using namespace std;
int n,k,q,x,y,z;
char c;
int lef[400005],rig[400005],sum[400005],tag[400005];
int read()
{
    int x=0;char c=getchar();
    while(c<48||c>57)c=getchar();
    while(c>47&&c<58)x*=10,x+=c-48,c=getchar();
    return x;
}
void build(int p,int l,int r)
{
    tag[p]=-1;
    lef[p]=l;
    rig[p]=r;
    if(l==r)
    {
        sum[p]=1;
        return ;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    sum[p]=sum[p<<1]|sum[p<<1|1];
}
void push_down(int p)
{
    if(tag[p]==-1)return ;
    tag[p<<1]=tag[p];sum[p<<1]=tag[p];
    tag[p<<1|1]=tag[p];sum[p<<1|1]=tag[p];
    tag[p]=-1;
}
void modify(int p,int l,int r,int x)
{
    if(l==lef[p] && r==rig[p])
    {
        tag[p]=x;
        sum[p]=x;
        return ;
    }
    push_down(p);
    int mid=(lef[p]+rig[p])>>1;
    if(r<=mid)modify(p<<1,l,r,x);
    else if(l>mid)modify(p<<1|1,l,r,x);
    else 
    {
        modify(p<<1,l,mid,x);
        modify(p<<1|1,mid+1,r,x);
    }
    sum[p]=sum[p<<1]|sum[p<<1|1];
}
int query(int p,int l,int r)
{
    if(l==lef[p] && rig[p]==r)return sum[p];
    push_down(p);
    int mid=(lef[p]+rig[p])>>1,v;
    if(r<=mid)v=query(p<<1,l,r);
    else if(l>mid)v=query(p<<1|1,l,r);
    else v=query(p<<1,l,mid)|query(p<<1|1,mid+1,r);
    sum[p]=sum[p<<1]|sum[p<<1|1];
    return v;
}
int main()
{
    n=read();k=read();q=read();
    build(1,1,n);
    for(int i=1;i<=q;i++)
    {
        scanf("%s",&c);
        if(c=='C')
        {
            x=read();y=read();z=read();
            if(x>y)swap(x,y);
            modify(1,x,y,1<<(z-1));
        }
        else
        {
            x=read();y=read();
            if(x>y)swap(x,y);
            int v=query(1,x,y);
            int ans=0;
            while(v)
            {
                ans+=v&1;
                v>>=1;
            }
            printf("%d\n",ans);
        }
    }
    return 0;
}
http://0x9.me/eqdMy
```

---

## 作者：mochenbo (赞：1)

这道题其实不难就是有坑，re的你自己仔细看数据范围a可以小于b也就是说范围要改。再一个就是数组范围尽量大些。就是这样了，本人菜，语言表达不好大概就这样子了。

ac代码#include<iostream>

     
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct tree{
    int z;
    int y;
    int mark;
    int ys[35];
};
tree xd[100010];
int js[35];
int ls,t,cz;
void bd(int node,int r,int l)
{
    int m;
    xd[node].ys[1]=1;
    xd[node].z=r;
    xd[node].y=l;
    if(r==l) return;
    int mid=(r+l)/2;
    bd(node*2,r,mid);
    bd(node*2+1,mid+1,l);
}
void cg(int node,int r,int l,int va)
{
    if(xd[node].z==r&&xd[node].y==l)
    {
    xd[node].mark=va;
    for(int i=1;i<=t;i++)
    xd[node].ys[i]=0;
    xd[node].ys[va]=1;
    return;
    }
    int mid=(xd[node].z+xd[node].y)/2;
    if(xd[node].mark!=0)
    {
    for(int i=1;i<=t;i++)
    {
    xd[2*node].ys[i]=0;
    xd[2*node+1].ys[i]=0;
    }
    xd[2*node].ys[xd[node].mark]=1;
    xd[2*node+1].ys[xd[node].mark]=1;
    xd[2*node].mark=xd[node].mark;
    xd[2*node+1].mark=xd[node].mark;
    xd[node].mark=0;
    }
    if(xd[node].z<=r&&l<=mid)
    {
    cg(node*2,r,l,va);
    for(int i=1;i<=t;i++)
    {
       xd[node].ys[i]=0;
       if(xd[2*node].ys[i]||xd[2*node+1].ys[i])
       xd[node].ys[i]=1;
    }
    }
    else
    if(r>=mid+1&&xd[node].y>=l)
    {
     cg(node*2+1,r,l,va);
     for(int i=1;i<=t;i++)
    {
       xd[node].ys[i]=0;
       if(xd[2*node].ys[i]||xd[2*node+1].ys[i])
       xd[node].ys[i]=1;
    }
    }
 else
    {
    cg(node*2,r,mid,va);
    cg(node*2+1,mid+1,l,va);
    for(int i=1;i<=t;i++)
    {
       xd[node].ys[i]=0;
       if(xd[2*node].ys[i]||xd[2*node+1].ys[i])
       {
       xd[node].ys[i]=1;
    }
    }
    }
}
void fd(int node,int r,int l)
{
    if(xd[node].mark!=0)
    {
    js[xd[node].mark]=1;
    return;
    }
 if(xd[node].z==r&&xd[node].y==l)
   {
     for(int i=1;i<=t;i++)
     if(xd[node].ys[i])
     js[i]=1;
     return;
   }
     else
 {
    int mid=(xd[node].z+xd[node].y)/2;
    if(xd[node].z<=r&&l<=mid)
    {
    fd(node*2,r,l);
    }
    else
    if(r>=mid+1&&xd[node].y>=l)
    fd(node*2+1,r,l);
    else
    {
    fd(node*2,r,mid);
    fd(node*2+1,mid+1,l);
    }
}
}
int main()
{
    char a;
    int b,c,d;
    scanf("%d %d %d",&ls,&t,&cz);
    bd(1,1,ls);
    for(int j=1;j<=cz;j++)
    {
    scanf("%s",&a);
    if(a=='C')
    {
    scanf("%d %d %d",&b,&c,&d);
        if(b<=c)
        {
        cg(1,b,c,d);
        }
        else
        {
      cg(1,c,b,d);
          }
    }
    else
    {
        scanf("%d %d",&b,&c);
        for(int i=1;i<=t;i++)
        js[i]=0;
        if(b<=c)
        fd(1,b,c);
        else
        fd(1,c,b);
        int sum=0;
        for(int i=1;i<=t;i++)
        {
            if(js[i])
            {
            sum++;
            }
        }
        cout<<sum<<"\n";
       }
    }
    return 0;
}
```

---

## 作者：AxDea (赞：0)

# Luogu 1558 色板游戏

这是线段树中很基础的染色问题，像我等(JuRuo)第一秒肯定是30棵大树建好，用线段树维护一下

~~这样既快速又简洁~~

但是这好像没有丝毫乐趣，感受不到蓝题的感觉，不把三十棵树合成就不爽，接下来接着思考如何优化空间(重点）

---------------------------------------------------------------------------------------------------------------------------------------

题目中有要求颜料种类$T$的范围在$1-30$间，要压空间的话就用压位

那么就若是一位一个颜色，那么一个$int$刚好够，将二进制下的第$i$位表是该线段中是否存在第$i$个颜色

接下来就是如何维护的问题了

$step \ 1$ 建树

把每个叶子节点都赋值为`1<<1`，表示存在第一种颜色

将`push_up`中的运算符改为`or`或是`|`

[不会位运算的点这里](https://www.cnblogs.com/flying_bat/archive/2008/06/17/1224178.html)

$code$

```cpp
inline void push_up(int p) {
	t[p] = t[lc(p)] | t[rc(p)];
}
inline void build(int p,int l,int r) {
	tag[p] = 0;
	if(l == r) {
		t[p] = 1<<1;
		return ;
	}
	int mid = (l+r)>>1;
	build(lc(p),l,mid);
	build(rc(p),mid+1,r);
	push_up(p);
}
```

$step \ 2$ 更新

说两个易错点

一、因为是覆盖颜色，所以只要对`tag`或者节点之间赋值就行了

二、`tag==0`时千万不要`push_down`,不然你懂的

$code$

```cpp
inline void f(int p,int k) {
	tag[p] = k;
	t[p] = k;
}
inline void push_down(int p) {
	if(!tag[p]) return ;
	f(lc(p),tag[p]);
	f(rc(p),tag[p]);
	tag[p] = 0;
}
inline void updata(int p,int l,int r,int x,int nl,int nr) {  //变量说明(从左向右):现在节点编号 需要修改的左右端点 修改后的颜色 现在编号所对应的线段的左右端点
	if(nr<l||nl>r) return ;
	if(l<=nl&&nr<=r) {
		t[p] = (1<<x);
		tag[p] = (1<<x);
		return ;
	}
	push_down(p);
	int mid = (nl+nr)>>1;
	if(mid>=l) updata(lc(p),l,r,x,nl,mid);
	if(mid<r)  updata(rc(p),l,r,x,mid+1,nr);
	push_up(p);
}
```

$step\ 3$ 求值

这里就没什么要点了，毕竟上面都提过了

$code$

```cpp
inline int query(int p,int l,int r,int nl,int nr) {  //变量的含义同上
	if(nr<l||nl>r) return 0;
	if(l<=nl&&nr<=r) return t[p];
	push_down(p);
	int mid = (nl+nr)>>1;
	int ans = 0;
	if(mid>=l) ans |= query(lc(p),l,r,nl,mid);
	if(mid<r)  ans |= query(rc(p),l,r,mid+1,nr);
	return ans;
}
```

$step\ 4$ 处理数据

本(JuRuo)有喜欢这种方式

`for(int i=n;i;i-=lowbit(i)) ans++;`

其中`n`为从线段树中所取得的结果，`ans`为最终答案

不知道`lowbit`什么意思的请右转baidu

$step\ 5$ 细节处理

直接引入题目原话吧`(这里 A, B, C 为整数, 可能A> B，这样的话需要你交换A和B)`

---

## 作者：abandentsky (赞：0)

题意：给出一个区间，问区间里面一共有几个不同的数字。
思路：就是用lzay标记，然后求出一个区间里有几个不同的lazy标记。我们用一个数字来表示某个区间的状态，和我们用dp时候的状态dp是一样的。得注意懒人标记什么时候下放。第一点：我们在更新的时候需要下放，第二点，我们在查找的时候也需要下放（在这里wrong了好多次，还是基础不扎实）。其他的也没什么。给出代码；
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 100005
#define maxnode 50010
#define sigma_size 26
#define md 1000000007
#define INF 0x3f3f3f3f
using namespace std;
typedef long long LL;

struct node
{
    int l,r;
    LL laz,ss;
}tr[MAXN<<2];

long long opop(int x)     //转化成状态
{
    long long temp=1;
    for(int i=0;i<x;i++)
    {
        temp*=2;
    }
    return temp;
}


void build(int id,int l,int r)     //建树
{
    tr[id].l=l,tr[id].r=r;
    if(l==r)
    {
        tr[id].laz=1;
        tr[id].ss=1;
        return ;
    }
    int mid=(l+r)>>1;
    build(id<<1,l,mid);
    build(id<<1|1,mid+1,r);
    tr[id].ss=(tr[id<<1].ss|tr[id<<1|1].ss);
}

void pushdown(int id)                       //将懒人标记下放，（注意：要判定懒人标记是不是为0，不然就错了）
{
    if(tr[id].laz)
    {
        tr[id<<1].laz=tr[id<<1|1].laz=tr[id].laz;
        tr[id<<1].ss=tr[id<<1|1].ss=tr[id].laz;
        tr[id].laz=0;
    }
}

void update(int id,int l,int r,int val)   //将区间l和r的值改为val
{
    if(tr[id].l>=l&&tr[id].r<=r)
    {
        long long  ttmp=opop(val-1);
        tr[id].laz=ttmp,tr[id].ss=ttmp;
        return ;
    }
    pushdown(id);
    int mid=(tr[id].l+tr[id].r)>>1;
    if(l<=mid)
        update(id<<1,l,r,val);
    if(r>mid)
        update(id<<1|1,l,r,val);
    tr[id].ss=(tr[id<<1].ss|tr[id<<1|1].ss);
}

long long query(int id,int l,int r)       //查询某个区间的不同的值得个数
{
    if(tr[id].l>=l&&tr[id].r<=r)
        return tr[id].ss;
    pushdown(id);
    int mid=(tr[id].l+tr[id].r)>>1;
    long long ans=0;
    if(r<=mid)
       return query(id<<1,l,r);
    else if(l>mid)
        return query(id<<1|1,l,r);
    else 
        return (query(id<<1,l,r)|query(id<<1|1,l,r));
}

void ssum(long long x)   //查询某个状态，看这个状态一共有几个1，也就是有几种不同的颜色
{
    int res=0;
    while(x)
    {
        if(x%2)
            res++;
        x/=2;
    }
   printf("%d\n",res);
   return ;
}

int main()
{
    int n,t,o;
    scanf("%d%d%d",&n,&t,&o);
    build(1,1,n);//建树操作
    for(int i=0;i<o;i++){
        char q[3];
        cin>>q;
        if(q[0]=='C'){
            int u,v,w;
            scanf("%d%d%d",&u,&v,&w);
            if(u>v){
                int cc=u;
                u=v;
                v=cc;
            }
            update(1,u,v,w);//更新某个区间
        }
        else{
            int u,v;
            scanf("%d%d",&u,&v);
            if(u>v){
                int cc=u;
                u=v;
                v=cc;
            }
            long long ans=query(1,u,v);//返回某个区间的状态
            ssum(ans);      //将某个区间状态转化为数字个数，也就是检查1的个数
        }
    }
    return 0;
}

```


---

## 作者：我很辣ji看头像 (赞：0)

教练：实在没有什么优化，纯lazy标记 线段树模板。。这东西随手就能敲出来 我：？？？？？@#……#！
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int l,r;
	int num;
	int lazy;
}tree[1000100];
int ls(int x)
{
	return x<<1;
}
int rs(int x)
{
	return x<<1|1;
}
void update(int index)
{
	tree[index].num=tree[ls(index)].num|tree[rs(index)].num;
}
void pushdown(int index)
{
	if (tree[index].lazy==0) return;
	tree[ls(index)].lazy=tree[index].lazy;
	tree[rs(index)].lazy=tree[index].lazy;
	tree[ls(index)].num=tree[index].lazy;
	tree[rs(index)].num=tree[index].lazy;
	tree[index].lazy=0;
}
void build(int l,int r,int index)
{
	tree[index].l=l;
	tree[index].r=r;
	tree[index].num=2;
	if (l==r) 
	{
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls(index));
	build(mid+1,r,rs(index));
}//更新建树
void change(int l,int r,int x,int index)
{
	int L=tree[index].l,R=tree[index].r;
	if (l<=L and R<=r)
	{
		tree[index].num=(1<<x);
		tree[index].lazy=(1<<x);
		return;
	}
	if (L>r or l>R) return;
	pushdown(index);
	change(l,r,x,ls(index));
	change(l,r,x,rs(index));
	update(index); 
}//模板update
int ans=0;
void ask(int l,int r,int index)
{
	int L=tree[index].l,R=tree[index].r;
	if (l<=L and R<=r)
	{
		ans|=tree[index].num;
		return;
	}
	if (L>r or l>R) return;
	pushdown(index);
	ask(l,r,ls(index));
	ask(l,r,rs(index));
}
int n,T,m;
int cnt_1(int x)
{
	int tot=0;
	while(x!=0)
	{
		tot+=x&1;
		x>>=1;
	}
	return tot;
} //题意
int main()
{
	scanf("%d%d%d",&n,&T,&m);
	build(1,n,1);
	for(int i=1;i<=m;i++)
	{
		char t[5];
		scanf("%s",t);
		if (t[0]=='C')
		{
			int l,r,x;
			scanf("%d%d%d",&l,&r,&x);
			if (l>r) swap(l,r);
			change(l,r,x,1);
		}
		if (t[0]=='P')
		{
			int l,r;
			scanf("%d%d",&l,&r);
			if (l>r) swap(l,r);
			ans=0;
			ask(l,r,1);
			printf("%d\n",cnt_1(ans));
		}
	} 
}

```

---

## 作者：Tiffany_Tendering (赞：0)

已经有好久没发过题解了.....


这个题我想的就是线段树  

至于大佬们的什么状态压缩之类的 ， 我这种蒟蒻当然是不会的。

所以干脆暴力一点 ： 就是对线段树的每一个节点都开一个大小为30的bool数组（以下称为c数组）   用来记录这个节点所代表的区间是否有这个颜色（1为出现  0为没有）

写起来也很好写 注意一下在合并两个区间的时候不能直接将两个区间的颜色总数加起来，因为可能两个区间里有同一种颜色。

同时再修改的时候也不要忘记了先将原区间的c数组清零 再添加记录




```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define LL long long
#define RE register
using namespace std ;
inline int read() {
    int x = 0,f = 1;char k = getchar() ;
	while(k < '0'||k > '9') {if(k == '-') f = -1;k = getchar();}
	while(k >= '0'&& k<= '9') {x = x * 10 + k - '0';k = getchar();}
	return x * f;
}
const int maxn = 100005 ;
int n,m,Q,c[maxn],tnum = 1,ans ;
struct Tree {int lc,rc,sum,tag; bool c[35];}a[maxn << 1];
bool col[35] ;
void pushup(int u) {
	int sum = 0;
	for(RE int i = 1;i <= m ;++i)
	    a[u].c[i] = 0;
    for(RE int i = 1;i <= m ;++i)
        if(a[a[u].lc].c[i] || a[a[u].rc].c[i])
          a[u].c[i] = 1,sum++ ;
    a[u].sum = sum ;
}
void build(int u,int l,int r) {
    if(l == r) {a[u].c[1] = 1;a[u].sum = 1;return ;}
    int mid = (l + r) >> 1;
    a[u].lc = ++tnum;build(a[u].lc,l,mid) ;
    a[u].rc = ++tnum;build(a[u].rc,mid+1,r) ;
    pushup(u) ; 
}
void pushdown(int u) {
	if(a[u].tag) {
	    a[a[u].lc].tag = a[u].tag ;
	    a[a[u].rc].tag = a[u].tag ;
	    a[a[u].lc].sum = 1;
	    a[a[u].rc].sum = 1;
	    for(RE int i = 1;i <= m ;++i) 
     	    a[a[u].rc].c[i] = a[a[u].lc].c[i] = 0;
	    a[a[u].lc].c[a[u].tag] = a[a[u].rc].c[a[u].tag] = 1;
	}
	a[u].tag = 0;/* **************** */
}
void update(int u,int l,int r,int ll,int rr,int w) {
    if(l == ll && r == rr) {
	    for(RE int i = 1;i <= m ;++i) a[u].c[i] = 0;
	    a[u].c[w] = 1;a[u].sum = 1;a[u].tag = w;return ;
	}
	int mid = (l + r) >> 1;
	pushdown(u) ;
	if(rr <= mid) update(a[u].lc,l,mid,ll,rr,w) ;
	else if(ll > mid) update(a[u].rc,mid+1,r,ll,rr,w) ;
	else {
	    update(a[u].lc,l,mid,ll,mid,w) ;
	    update(a[u].rc,mid+1,r,mid+1,rr,w) ;
	}
	pushup(u) ;
}
void query(int u,int l,int r,int ll,int rr) {
    if(l == ll && r == rr) {
    	int sum = 0;
	    for(RE int i = 1;i <= m ;++i) 
	       if(!col[i] && a[u].c[i]) ++sum,col[i] = 1 ;
	    ans += sum ;
        return ;
	}
    int mid = (l + r) >> 1;
    pushdown(u) ;
    if(rr <= mid) query(a[u].lc,l,mid,ll,rr) ;
    else if(ll > mid) query(a[u].rc,mid+1,r,ll,rr) ;
    else {
	    query(a[u].lc,l,mid,ll,mid) ;
	    query(a[u].rc,mid+1,r,mid+1,rr) ;
	}
	pushup(u) ;
}
int main() {
	scanf("%d%d%d",&n,&m,&Q) ;
	build(1,1,n) ;
	while(Q--) {
	    char flag;cin >> flag; 
	    int x,y;x = read();y = read() ;
	    if(x > y) swap(x,y) ;
	    if(flag == 'C') {
		    int w;w = read() ;
		    update(1,1,n,x,y,w) ;
		}
		else {
		    ans = 0;memset(col,0,sizeof(col)) ;
		    query(1,1,n,x,y) ;
		    printf("%d\n",ans) ;
		}
	}
//	cout << sizeof(a) / 1024 / 1024<<endl;
    return 0;
}
```

---


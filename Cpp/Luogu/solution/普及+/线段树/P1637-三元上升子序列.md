# 三元上升子序列

## 题目描述

Erwin 最近对一种叫 `thair` 的东西巨感兴趣。。。

在含有 $n$ 个整数的序列 $a_1,a_2,\ldots,a_n$ 中，三个数被称作`thair`当且仅当 $i<j<k$ 且 $a_i<a_j<a_k$。

求一个序列中 `thair` 的个数。

## 说明/提示

#### 样例2 解释

$7$ 个 `thair` 分别是：

- 1 2 3
- 1 2 4
- 1 2 3
- 1 2 4
- 1 3 4
- 2 3 4
- 2 3 4

#### 数据规模与约定

- 对于 $30\%$ 的数据 保证 $n\le100$；
- 对于 $60\%$ 的数据 保证 $n\le2000$；
- 对于 $100\%$ 的数据 保证 $1 \leq n\le3\times10^4$，$1\le a_i\leq 10^5$。

## 样例 #1

### 输入

```
4
2 1 3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2 2 3 4```

### 输出

```
7```

# 题解

## 作者：紫题 (赞：202)

## 这道题可以拓展到M元上升子序列。

## 做法: DP + 树状数组优化

仿照$LIS$的做法，设$f[i][j]$为以$a[j]$为结尾的长度为$i$的上升子序列的个数。

得到状态转移方程：$f[i][j] = {\sum_{k<j,a[k]<a[j]}}f[i-1][k]$

转移时暴力枚举，显然复杂度为$O(N^{2}M)$

考虑到k有两个限制条件，$k<j$和$a[k]<a[j]$，可以先将$a[]$离散化，再用树状数组维护。

具体来说，在外层循环$i$，建立一个树状数组，以$a[k]$为下标存储$f[i-1][k]$的值。当内层循环到$j$时，$f[i][j]+=ask(a[j]-1)$，然后在转移到下一个$j$之前$add(a[j],f[i-1][j])$。
$j$从小到大循环保证了$k<j$，查询$f[i-1][j-1]$的前缀和保证了$a[k]<a[j]$。

复杂度$O(NMlogN)$。



~~双倍经验：UVA12983~~

$CODE:$
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n, a[30010], s[30010], m, f[4][30010], c[60010], ans;
ll val(int x) { return lower_bound(s+1, s+m+1, x) - s; }
ll ask(int x, ll sum = 0) {
	for(; x; x -= (x & (-x))) sum += c[x];
	return sum;
}
void add(int x, ll v) { for(; x <= m; x += (x & (-x))) c[x] += v; }
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i],  s[i] = a[i];
	sort(s+1, s+n+1);
	m = unique(s+1, s+n+1) - s - 1;
	for(int i = 1; i <= n; i++) f[1][i] = 1, a[i] = val(a[i]);
	for(int i = 2; i <= 3; i++) {
		memset(c, 0, sizeof(c));
		for(int j = 1; j <= n; j++) {
			f[i][j] = ask(a[j]-1);
			add(a[j], f[i-1][j]);
		}
	}
	for(int i = 1; i <= n; i++) ans += f[3][i];
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Dog_Two (赞：90)

作为一个**三元**的上升序列，我们很容易想到子序列**枚举中间的元素**。

------------

### 我们记
- Lef[i]为 A[i]左边**小于**A[i]的元素**个数**
- Rit[i]为 A[i]右边**大于**A[i]的元素**个数**

------------

### 根据乘法原理，有：
- **以A[i]为中间元素**的合法序列个数为**Lef[i]*Rit[i]**

------------
### 如何得到Lef[] 和Rit[] 数组呢？（以Lef为例）

如果我们在枚举中间元素A[i]的过程中再次遍历A[0],A[1]...A[i-1]，那么时间复杂度将达到O(n^2)，显然超时。

换一种思路：
“在i前（不含）**小于**A[i]的元素数量和” **等价于**
“在i前（不含）**小于等于**A[i]的元素数量和减去A[i]（这个数值）出现的次数”。

虽然这种说法令人感到莫名其妙，但它或许可以启示我们的同学联想到“前缀和”。
前缀和的思路、“逆序对”的目标进一步让我们联想到树状数组求逆序对。按刘汝佳大神的说法，“动态更新并求解前缀和，正是树状数组的标准用法”。

我们可以用树状数组c[val]记录**已经被考虑**的数中小于等于val的个数，初始化为0，每次更新时，调用add(A[i],1)。

------------

在本题中，A[i]<=INT_MAX，直接定义树状数组c[INT_MAX]显然失智，所以我们不妨**离散化**处理。我个人认为，离散化绝对比其他“不用离散”的方法容易想到，如果是在考场上，我们可以更加轻车熟路地用离散来处理这道题目。

------------

POJ3928和本题是类似的，不过那一题更加友善——保证任意A[i]不同，并给出了不必离散处理的A[i]范围，有兴趣的同学可以在那一题上加强练习。

代码如下，时间复杂度O(nlogn)，空间复杂度O(n)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e4+10;
int n,m;
int c1[maxn],c2[maxn];//double_tree_arr
int A[maxn],_A[maxn];//discrete_arr
int Lef[maxn],Rit[maxn];//Counter

inline int _Q(int val){//查询A[i]对应的映射值 
	return lower_bound(_A+1,_A+m+1,val)-_A;
}

inline int lowbit(int i){
	return i&(-i);
}

void add(int *C,int pos,int val){
	while(pos<=maxn){
		C[pos]+=val;
		pos+=lowbit(pos);
	}
}

int sum(int *C,int pos){
	int res=0;
	while(pos>0){
		res+=C[pos];
		pos-=lowbit(pos);
	}
	return res;
}
//以上是树状数组模板，在函数里以数组指针作参数 
int main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%d",&A[i]);
		_A[i]=A[i];
	}
	sort(_A+1,_A+n+1);
	m=unique(_A+1,_A+n+1)-(_A+1);
	//小细节，我们希望映射值在i...3e4之间，所以需要减去_A+1 
	//discrete
	for(int i=1;i<=n;++i){
		add(c1,_Q(A[i]),1);
		Lef[i]=sum(c1,_Q(A[i])-1);
        //“减去A[i]出现个数”的隐式体现，就是我们只计算“A[i]-1（映射意义上）”的出现个数
	}
	for(int i=n;i>=1;--i){
		add(c2,_Q(A[i]),1);
		Rit[i]=n-i-(sum(c2,_Q(A[i]))-1);
		//小细节，计算Rit时需要注意表达式与Lef不同 
	}
	long long ans=0;
	for(int i=2;i<n;++i) ans+=Lef[i]*Rit[i];
	//“乘法原理”的显式体现 
	cout<<ans;
	return 0;
}

```
### 最后总结一下程序实现中需要注意的一些细节
- A[i]最有多maxn=3e4个不同的数值，离散后最大的映射值也不超过3e4；我们的树状数组应以max{A[i]}作为下标上界，所以我们直接使用maxn作为下标上界。

- 本人在程序里定义了两个树状数组c1，c2，并在树状数组的操作函数里用参数将它们区分开来，如果只想用一个树状数组的话，不要忘记在顺、逆两次遍历之间清空数组。

- 因为我们的树状数组只能求解“小于（等于）”的数量，所以Lef和Rit的计算必须分开。

- 同样是由于上一条原因，函数sum在逆序时计算出来的其实是“i+1...n中小于等于A[i]的元素个数”，我们把它记为K。那么在i+1...n这n-i个数字中，“小于等于A[i]”的数字出现的个数其实是K-1个（因为在位置i的A[i]不应被算进去），而这些数并不是我们需要的，于是，(n-i)-(K-1)就是我们需要的Rit[i]的值了。


---

## 作者：windows250 (赞：87)

##看到都是树状数组的解法,这里发篇线段树的题解,希望对像我一样初学线段树的同学有帮助.

很容易想到 **三元上升子序列的个数=每个数前比它小的数的个数\*每个数后比它大的数的个数 之和**

我们只需要维护 每个数前比它小的数的个数 和 每个数后比它大的数的个数 并记录下来就可以了,

那么怎样用线段树去维护呢？以一组数据 An={ 1,4,5,3 } 为例:

- 首先我们开个桶sum[n]记录每个数的出现次数,那么一开始这个桶就是 0 0 0 0 0

- 插入A1=1，此时的桶为 1 0 0 0 0 ,查询A1前有没有比它小的数： 1 0 0 0 0,好吧一个都没有,记smaller[1]=0;

- 插入A2=4，此时的桶为 1 0 0 1 0 ,查询A2前有没有比它小的数：(1 0 0)1 0,发现此时1比4小,smaller[2]=1;

- 插入A3=5，此时的桶为 1 0 0 1 1 ,查询A3前有没有比它小的数：(1 0 0 1)1,发现此时1,4比5小,smaller[3]=2;

- 插入A4=3，此时的桶为 1 0 1 1 1 ,查询A4前有没有比它小的数：(1 0)1 1 1,发现此时1比3小,smaller[4]=1;

按上面的操作步骤,即每次更新,将sum[A[n]]+1,然后sum[1]~sum[A[n]-1]的和即是small[n]的值,这也是**用线段树求逆序对的方法**

那么用同样的方法求出所有数后比它大的数,得到bigger[1~4],最后**ans=ans+smaller[i]\*bigger[i],1<=i<=4**

当然如果数据的间隔很大,比如 99 1 9999 999999 99999999999 我们当然没必要开那么大的桶,记住相对大小关系即可:2 1 3 4 5

这种操作就是**离散化**啦。

**详细见代码:**

```cpp
#include<bits/stdc++.h>
#define MAXN 30001
#define ls root<<1,l,mid
#define rs root<<1|1,mid+1,r
#define in(x) x=read()

using namespace std;

inline int read()
{
    int X=0,w=1;char ch=getchar();
    while(ch>'9' || ch<'0'){if(ch=='-') w=-1;ch=getchar();}
    while(ch<='9' && ch>='0') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}

struct data
{
    int num,pos;
}st[MAXN];
int n,cnt;
int sum[MAXN<<2],num[MAXN],bigger[MAXN],smaller[MAXN];
long long ans;

inline void push_up(int root)
{
    sum[root]=sum[root<<1]+sum[root<<1|1];
}

inline void update(int root,int l,int r,int pos)
{
    if(l==r && l==pos){sum[root]++;return;}
    int mid=(l+r)>>1;
    if(mid>=pos) update(ls,pos);
    if(mid<pos) update(rs,pos);
    push_up(root);
}

inline int query(int root,int l,int r,int L,int R)
{
    if(L<=l && r<=R) return sum[root];
    int mid=(l+r)>>1,total=0;
    if(mid>=L) total+=query(ls,L,R);
    if(mid<R) total+=query(rs,L,R);
    return total; 
}

inline bool mcomp(const data &a,const data &b)
{
    return a.num<b.num;
}

int main()
{
    in(n);
    for(int i=1;i<=n;i++) in(st[i].num),st[i].pos=i;
    sort(st+1,st+n+1,mcomp);
    for(int i=1;i<=n;i++) 
    {
        if(st[i].num>st[i-1].num) cnt++;
        num[st[i].pos]=cnt; 
    }
    //离散化,注意两个数相同的情况 
    for(int i=1;i<=n;i++)
    {
        if(num[i]>1) smaller[i]=query(1,1,n,1,num[i]-1);
        update(1,1,n,num[i]);
    }
    //查询一个数前比它小的数的个数
    memset(sum,0,sizeof(sum));
    //注意清空sum数组 
    for(int i=n;i>=1;i--)
    {
        if(num[i]<n) bigger[i]=query(1,1,n,num[i]+1,n);
        update(1,1,n,num[i]);
    }
    //查询一个数后比它大的数的个数 
    for(int i=1;i<=n;i++) ans+=(bigger[i]*smaller[i]);
    //乘法原理 & 加法原理 
    printf("%lld",ans);
    return 0;
}
//By windows250
```

---

## 作者：szr666 (赞：37)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P1637)
------------

------------

华丽的分割线
# 解析
首先应枚举中间的数j，如果知道了中间数j左边比它小的数的个数(i的个数)，右边比它大的数的个数(k的个数)，将这两个数相乘即为中间数j对答案产生的贡献，枚举复杂度为O(n)

现在问题转化为求数组l[i],r[i],分别表示对于中间数i,左边比它小的数的个数和右边比它大的数的个数

可以使用权值树状数组来做

首先来看一下树状数组

树状数组的功能为用O(logn)的复杂度求

1.对于a数组，查询a[1]+a[2]+…………+a[i],也就是求1~i的前缀和

2.将第i个数加上x,也就是a[i]+=x

如图
![](https://cdn.luogu.com.cn/upload/pic/54623.png)

c数组为树状数组，现在先找到求c[i]的方法

首先c[i]=a数组从某一个起点一直加到终点

观察图片，终点为a[i],只要知道序列的长度，就可知道起点

观察左面i对应的二进制形式，发现序列长度为2^（i二进制末尾连续0的个数）

如何求2^（i二进制末尾连续0的个数）

下面引入lowbit()
![](https://cdn.luogu.com.cn/upload/pic/54624.png)

lowbit(i)=i&(-i)=2^（i二进制末尾连续0的个数）

下面给出证明：

i的二进制可表示为011010...(奇奇怪怪的东西)|1(从右数第一个1)|0000...(n个0)

这是i的原码,i的反码为~i:

100101...(奇奇怪怪的东西反过来)|0(从右数第一个0)|1111...(n个1)

i的补码为-i,等与反码+1：

100101...(奇奇怪怪的东西反过来)|1(从右数第一个1)|0...(n个0)

+1使得后面连续的1进位，把从右数第一个0变成了1

所以i&(-i)=

000...(奇奇怪怪的东西&奇奇怪怪的东西反过来=0)|1(从右数第一个1)|0...(n个0)

=1|0...(n个0)=2^（i二进制末尾连续0的个数）

这样c[i]=a[i-lowbit(i)+1]+a[i-lowbit(i)+2]+…………+a[i]

接着看一下如何实现查询操作

```cpp
ll query(ll x)
{
    ll ans;
    ans=0;
    while(x>0)
    {
        ans+=sqt[x];
        x-=lowbit(x);
    }
    return ans;
}
```
其中 #define ll long long

sqt为树状数组,查询1~x的前缀和

举个例子，当x=6时，1~6的前缀和=1~4+5~6=sqt[4]+sqt[6]

4正好为6-lowbit(6)=110-10=100

所以查询前缀和的实现就是不断的将x-=lowbit(x),并将sqt[x]加入答案贡献

修改即为查询逆操作

```cpp
void add(ll x,ll val)
{
    while(x<=cmax)
    {
        sqt[x]+=val;
        x+=lowbit(x);
    }
}
```
不断将x+=lowbit(x),并修改sqt[x]的值

呜呼，终于把树状数组说完了，现在说一下离散化

```cpp
    read(n);
    for(i=1;i<=n;i++)
    {
        read(a[i]);
        a1[i]=a[i];
    }
    sort(a1+1,a1+1+n);
    m=unique(a1+1,a1+1+n)-(a1+1);
```
a1数组为离散化数组，a为题中数组

sort为排序函数，unique为去重函数，仅限在有序的数组中使用

unique返回去重后数组末尾地址的下一位，所以要减(a1+1)，m为去重后数组长度

```cpp
inline ll Q(ll val)
{
    return lower_bound(a1+1,a1+1+m,val)-a1;
}
```
Q的作用是对于val,返回它的离散化值，即为val在离散化数组中的下标

lower_bound为二分查找val,返回其地址

离散化和树状数组都讲完了，现在把二者合二为一，权值树状数组诞生了

对于序列1 2 2 3 5

离散化后1->1 2->2 3->3 5->4，这是它们的离散化值

现在创建一个序列，记录每个数出现的次数

值：1 1 1 2

下标：1 2 3 4(下标为对应的离散化值)

现在终于知道为什么要离散化了吧，离散化值最大为n，数组下标最大也为n

不离散化数字很大，直接作为下标炸空间

再用树状数组维护这个序列的前缀和，这就是权值树状数组

权值树状数组是用来维护a序列中每个数出现次数的前缀和

终于可以用O(nlogn)的复杂度求l[i]和r[i]了

```cpp
    for(i=1;i<=n;i++)
    {
        add(Q(a[i]),1);
        l[i]=query(Q(a[i])-1);
    }
    memset(sqt,0,sizeof(sqt));
    for(i=n;i>=1;i--)
    {
        add(Q(a[i]),1);
        r[i]=n-i-(query(Q(a[i]))-1);
    }
```
先看l数组，i从1到n枚举，保证了左面的下标比中间数小

把a[i]的离散化值加入权值树状数组

查询1~a[i-1]中值比a[i]小的数的个数

举个例子：a数组 6 2 2 1 5

以5为中间数，则6,2,2,1,5均加入权值树状数组

此时出现次数的数组为 1(1) 2(2) 1(5) 1(6)

求1~2的前缀和为3，以5为中间数，左边有三个数比它小

r数组同理，i从n到1枚举，保证了右面的下标比中间数大

举个例子：a数组 6 2 2 1 5

以左面的2为中间数，则5,1,2,2均加入权值树状数组

此时出现次数的数组为 1(1) 2(2) 1(5) 0(6)

求1~2的前缀和为3，也就是右面(因为i从n到1枚举)小于等于2的数的次数为3

所以用2右面序列长度-右面小于等于2的数的次数=右面大于2的数的次数

所以 r[i]=n-i-(query(Q(a[i]))-1)=n-i+1-query(Q(a[i])

其中n-i+1为i右面序列长度,query(Q(a[i])为右面小于等于i的数的次数

处理好了l和r数组，最后i从2~n-1枚举，ans+=l[i]*r[i]即可

加读入优化更快哦

# 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const ll cmax=310000;
ll sqt[cmax];
ll a[cmax],a1[cmax];
ll m;
ll l[cmax],r[cmax];
void read(ll &x)
{
    x=0;
    ll f;
    f=1;
    char c;
    c=getchar();
    while((c<'0'||c>'9')&&(c!='-'))
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
inline ll lowbit(ll x)
{
    return x&(-x);
}
void add(ll x,ll val)
{
    while(x<=cmax)
    {
        sqt[x]+=val;
        x+=lowbit(x);
    }
}
ll query(ll x)
{
    ll ans;
    ans=0;
    while(x>0)
    {
        ans+=sqt[x];
        x-=lowbit(x);
    }
    return ans;
}
inline ll Q(ll val)
{
    return lower_bound(a1+1,a1+1+m,val)-a1;
}
int main()
{
    ll n,i;
    read(n);
    for(i=1;i<=n;i++)
    {
        read(a[i]);
        a1[i]=a[i];
    }
    sort(a1+1,a1+1+n);
    m=unique(a1+1,a1+1+n)-(a1+1);
    for(i=1;i<=n;i++)
    {
        add(Q(a[i]),1);
        l[i]=query(Q(a[i])-1);
    }
    memset(sqt,0,sizeof(sqt));
    for(i=n;i>=1;i--)
    {
        add(Q(a[i]),1);
        r[i]=n-i-(query(Q(a[i]))-1);
    }
    ll ans;
    ans=0;
    for(i=2;i<n;i++)
    {
        ans+=l[i]*r[i];
    }
    printf("%lld",ans);
    return 0;
}
```



---

## 作者：yybyyb (赞：16)

题解这么少，忍不住的写一篇

~~原来做过一道极其类似的题目~~

首先，对于任意一个选定的数aj而言

要求的是1~j-1中比aj小的数的个数

乘以j+1~n中比aj大的数的个数

求出数的个数可以直接使用树状数组

最后直接统计结果就行了

但是，考虑到N的范围很小

但是ai<maxlongint

因此，如果不使用离散化的话，可能会炸空间

好了。说了这里

直接上代码了：


```cpp
//ai在maxlongint内，不离散化数组开不下。。。 
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<map>
#include<algorithm>
using namespace std;
#define MAX 40000
#define INF 30000
int n;
inline int read()
{
    register int x=0,t=1;
    register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*t;
}
struct Node
{
       int a;//数值 
       int i;//位置 
}Q[MAX];
bool operator <(Node a,Node b)
{
       return a.a<b.a;
}
int c[MAX*4];
int a[MAX],t1[MAX],t2[MAX];
inline int lowbit(int x)
{
       return x&(-x);
}
inline void update(int x)
{
       while(x<=n)
       {
                c[x]+=1;
                x+=lowbit(x);
       }
}
inline int get(int x)
{
       int sum=0;
       while(x>0)
       {
                sum+=c[x];
                x-=lowbit(x);
       }
       return sum;
}
int main()
{
       n=read();
       for(int i=1;i<=n;++i)
          Q[i]=(Node){read(),i};
       //离散化
       sort(&Q[1],&Q[n+1]);
       for(int i=1;i<=n;++i) 
       {
               if(Q[i].a!=Q[i-1].a||i==1)
                a[Q[i].i]=i;
            else
                a[Q[i].i]=a[Q[i-1].i];
       }
       //树状数组
       //第一遍，求出前面所有数中，比它小的个数
       for(int i=1;i<=n;++i)
       {
                 t1[i]=get(a[i]-1);
                 update(a[i]);
       }
       
       memset(c,0,sizeof(c));
       
       //第二遍，求出后面所有数中，比它大的个数
       for(int i=n;i>=1;--i)
       {
                 t2[i]=get(n-a[i]);
                 update(n-a[i]+1);
       }
       
       //最后求和
       long long ans=0;
       for(int i=1;i<=n;++i)
          ans+=t1[i]*t2[i];
       cout<<ans<<endl;
       return 0; 
}

```

---

## 作者：Snitro (赞：15)

这道题我们可以直接使用两个树状数组模拟


第一个树状数组表示枚举到第 i 个位置有多少个小于 x


第二个树状数组表示枚举到第 i 个位置有多少个**二元上升序列**的第二个元素小于x


时间复杂度O(nlogn)








    

    
    



    
    

    
    
    
    
    
        
    
        
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define lowbit(x) ((x) & (-(x)))
using namespace std;
int n;
int datas[30005], _sort[30005];
int tree[30005], _tree[30005];
void update(int * tree, int x, int num) { // 将 tree 对应的树状数组的x位置以后的数加上num
    if (num == 0)
        return;
    while (x <= n) {
        tree[x] += num;
        x += lowbit(x);
    }
}
int query(int * tree, int x) {// 查询tree对应树状数组前x个元素的和
    int ret = 0;
    while (x) {
        ret += tree[x];
        x -= lowbit(x);
    }
    return ret;
}
bool cmp(int a, int b) {
    return datas[a] < datas[b];
}
void init() {//离散化
    int data[30005];
    sort(_sort + 1, _sort + 1 + n, cmp);
    int i = 0;
    for (int j = 1; j <= n; j++)     {
        if (j == 1 || datas[_sort[j]] != datas[_sort[j - 1]])
            i++;
        data[_sort[j]] = i;
    }
    memcpy(datas, data, sizeof(data));
}
int main() {
    freopen("in.txt", "r", stdin);
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &datas[i]);
        _sort[i] = i;
    }
    init();
    long long ans = 0;
//_tree对应二元组的树状数组
//tree对应单个元素的树状数组
    for (int i = 1; i <= n; i++) {
        ans += query(_tree, datas[i] - 1);//将二元组中第二个元素小于当前元素的个数累加进结果
        update(_tree, datas[i], query(tree, datas[i] - 1));//使用当前元素更新二元组树状数组
        update(tree, datas[i], 1);//使用当前元素更新单个元素的树状数组
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：SofanHe (赞：14)

# 非离散化树状数组写法

乘法原理大家都懂,树状数组求逆序对大家也都知道.但是这个题

## 为什么非要离散化?

当时我们存的是数字的大小,现在我们存**位置**不行吗?

### 详细分析

我们先给它按数字大小排个序.

第一遍:找数字比他小而且编号比它小的数的个数.

第二遍:找数字比他大而且编号比它大的数的个数.

于是预处理为↓

```cpp
struct Node{int num,pos;}sf[30010];
bool comp(Node u,Node v){return u.num<v.num;}
for(int i=1;i<=n;++i){
	scanf("%d",&sf[i].num);
	sf[i].pos=i;
}
sort(sf+1,sf+n+1,comp);
```
然后第一遍
```cpp
for(int vc=1,i=1;i<=n;++i){
	if(sf[i].num!=sf[i-1].num)
	while(vc<i)add1(sf[vc++].pos);
	cnts[i]=qy1(sf[i].pos-1);
}
```
核心在$vc$上,因为相等的数是不会算到里面的,所以我们引入一个$vc$记录的是**上一个**相等的数的位置.

因为这一遍我们需要从小往大找,所以$vc=1$.

注:

_add1为在第一个树状数组里面在某个位置+1._

_qy1为在第一个树状数组里面查询某个位置及之前的数的个数._

_下文add2和qy2同理_


第二遍:

```cpp
for(int vc=n,i=n;i;--i){
	if(sf[i].num!=sf[i+1].num)
	while(vc>i)add2(sf[vc--].pos);
	ens+=cnts[i]*(qy2(n)-qy2(sf[i].pos));
}
```
因为排序是从大到小,这一遍就得从后往前.

### Code
```cpp
#include<bits/stdc++.h>
#define l(p)	(p&(-p))
using namespace std;
int BIT1[30010],BIT2[30010],n,ans;
long long cnts[30010],ens;
struct Node{int num,pos;}sf[30010];
bool comp1(Node u,Node v){
	return u.num<v.num;
}
void add1(int p){
	for(;p<=n;p+=l(p))
    	++BIT1[p];
}
void add2(int p){
	for(;p<=n;p+=l(p))
    	++BIT2[p];
}
int qy1(int p){
	ans=0;
    for(;p;p-=l(p))
    	ans+=BIT1[p];
	return ans;
}
int qy2(int p){
	ans=0;
    for(;p;p-=l(p))
    	ans+=BIT2[p];
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&sf[i].num);
		sf[i].pos=i;
	}
	sort(sf+1,sf+n+1,comp1);
	for(int vc=1,i=1;i<=n;++i){
		if(sf[i].num!=sf[i-1].num)
			while(vc<i)
        		add1(sf[vc++].pos);
		cnts[i]=qy1(sf[i].pos-1);
	}
	for(int vc=n,i=n;i;--i){
		if(sf[i].num!=sf[i+1].num)
			while(vc>i)
        		add2(sf[vc--].pos);
		ens+=cnts[i]*(qy2(n)-qy2(sf[i].pos));
	}
	printf("%lld",ens);
	return 0;
}

```

---

## 作者：MuYC (赞：10)

## 树状数组好题

这道题原理：乘法原理+树状数组

## 解题思路：
1.首先，离散化。否则数据太大，树状数组会挂，我这种离散化方法比较容易理解，直接sort，结构体开起来。

2.然后，树状数组维护当前元素的前面有多少个元素比当前元素小，我用t1记录。

3.然后树状数组维护当前元素后面有多少个元素比当前元素大，用t2记录。

4.根据乘法原理，res+=t1[i]*t2[i]

5.得出答案。

## 特别的地方：
这个题目我一开始不会怎么用树状数组维护比当前元素大的元素，就想到了求在当前元素后面的比当前元素小的元素，然后直接n-i-比当前元素小的元素个数（逆序对），后来发现这个可能会有重复的元素,~~我是一遍过这道题的，多谢样例良心~~这个方法不行。

怎么办呢？我脑洞清奇的将标准的树状数组反过来用：

见代码：
```cpp
int add(long long *c,long long x){while(x <= n)c[x]++,x+=lowbit(x);return c[x];}
```
这是正常的树状数组，而我的：
```cpp
int add1(long long *c,long long x){while(x > 0)c[x]++,x-=lowbit(x);return c[x];}
```
是不是倒过来了啊。然后我把get也改了。

```cpp
int get1(long long *c,long long x){long long ans=0;while( x <= n)ans+=c[x],x+=lowbit(x);return ans;}
```
然后就可以求比当前元素大的元素的个数了。

这种方法是不错了，可以希望大家好好看看，学学。

不过代码不希望大家这么写，我这样写是为了节省篇幅。

## CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,res=0;
struct node{long long data,num,now;}a[30000+5];
long long c1[50000+5],c2[50000+5];
long long t1[50000+5],t2[50000+5];
int cmp(node a , node b ){return a.data<b.data;}
int lowbit(long long x){return x&-x;};
int add(long long *c,long long x){while(x <= n)c[x]++,x+=lowbit(x);return c[x];}
int add1(long long *c,long long x){while(x > 0)c[x]++,x-=lowbit(x);return c[x];}
int get(long long *c,long long x){long long ans=0;while( x )ans+=c[x],x-=lowbit(x);return ans;}
int get1(long long *c,long long x){long long ans=0;while( x <= n)ans+=c[x],x+=lowbit(x);return ans;}
int main(){
	long long i,j,k,m;
	cin>>n;
	for ( i = 1 ; i <= n ; i ++)cin>>a[i].data,a[i].num=i;
	sort(a+1,a+1+n,cmp);
	for ( i = 1 ; i <= n; i ++ ){
		if(a[i].data == a[i-1].data)a[i].now=a[i-1].now;
		else a[i].now=i;
	}
	for ( i = 1 ; i <= n; i++)a[a[i].num].data=a[i].now;
	for ( i = 1 ; i <= n; i ++){
		add(c1,a[i].data);
		t1[i]=get(c1,a[i].data-1);
	}
	for (  i = n ; i >= 1 ; i --){
		add1(c2,a[i].data);
		t2[i]=get1(c2,a[i].data+1);
	}
	for ( i = 1 ; i <= n; i ++)res+=t1[i]*t2[i];
	cout<<res;
	return 0;
}
```


---

## 作者：star_magic_young (赞：8)


------------

诶,题解里的大佬都是用乘法原理吗?

那我怎么没想到呢? ~~太菜了想不到~~

------------


## 思路

看到这题与逆序对有关,我就先设数组aa[i]表示这一个数字前比他小的数的个数(以这个数字为结尾的 逆序对/二元上升子序列 个数)

归并一下就可以得出aa的值

但这道题要求三元上升子序列,,,我就想到对原数组再进行一次归并

跟求逆序对类似,只不过合并前要统计左半部分**对应的**aa的和.合并时如果右半部分的要合并的那个数字比左半部分的对应数字要*大*,就把答案加上左半部分剩余数字*对应的*aa之和(就相当于求以这个数字为结尾的三元上升子序列个数);否则把aa的和减去左半部分并过来的数*对应的*aa值.

拿着样例*手玩*几下,还是比较好理解的

------------


#### code

```cpp
//注:此代码在linux下的emacs写成,格式丑轻喷
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<queue>
#include<cmath>
#define il inline
using namespace std;
struct nn
{
  int x,n;
}a[30010],b[30010],c[30010];	//x为数字值 n为数字在原数组中的下标
int n;
long long aa[30010],ans;
il void s1(int l,int r)	//第一次归并算出aa
{
  if(l==r) return;
  int mid=(l+r)>>1;
  s1(l,mid);s1(mid+1,r);
  int i1=l,i2=mid+1,ii=l;
  while(i1<=mid&&i2<=r)
    {
      if(a[i1].x>=a[i2].x)
    	{
      	c[ii++]=a[i1++];
    	}
      else
    	{
     	 aa[a[i2].n]+=mid-i1+1;
    	  c[ii++]=a[i2++];
   	 }
    }
  while(i1<=mid) c[ii++]=a[i1++];
  while(i2<=r) c[ii++]=a[i2++];
  for(register int i=l;i<=r;i++) a[i]=c[i];
}
il int s2(int l,int r)
{
  if(l==r) return aa[b[l].n];
  int mid=(l+r)>>1;
  long long s=0,ss=0;	//s为这段区间左半部分的aa和,ss为这段区间的aa和
  s=ss=s2(l,mid); ss+=s2(mid+1,r);
  int i1=l,i2=mid+1,ii=l;
  while(i1<=mid&&i2<=r)
    {
      if(b[i1].x>=b[i2].x)
    	{
     	 s-=aa[b[i1].n];
    	  c[ii++]=b[i1++];
   	 }
      else
  	  {
  	    ans+=s;
   	   c[ii++]=b[i2++];
   	 }
    }
  while(i1<=mid) c[ii++]=b[i1++];
  while(i2<=r) c[ii++]=b[i2++];
  for(register int i=l;i<=r;i++) b[i]=c[i];
  return ss;	//返回区间的aa和
}
int main()
{
  scanf("%d\n",&n);
  for(register int i=1;i<=n;i++)
    {
      scanf("%d",&a[i].x);
      a[i].n=i;
      b[i]=a[i];
    }
  s1(1,n);
  s2(1,n);
  printf("%lld\n",ans);
  return 0;
}



```

------------



---

## 作者：Meatherm (赞：8)

既然是三元上升子序列，也就是求满足 $a_i<a_j<a_k(1\leq i < j < k \leq n)$ 的三元组 $(i,j,k)$ 数量。

很容易想到枚举每一个 $a_j$ ，找出 $[1,j-1]$ 中所有小于 $a_j$ 的数的数量，找出 $[j+1,n]$ 中所有大于 $a_j$ 的数的数量，再用乘法原理求解。

啊那不就是主席树裸题嘛...

我们可以选择建立主席树 —— $n+1$ 棵权值线段树，第 $0$ 棵是空树，第 $i(1\leq i \leq n)$ 棵对应 $[1,i]$。然后用类似与前缀和的思想求解，查询 $[l,r]$ 时把第 $i-1$ 棵和第 $r$ 棵拎出来求解。

```cpp
# include <bits/stdc++.h>
# define int long long//保险起见我使用了 64 位整数
# define rr register
const int N=30010;
struct Node{
	int lc,rc,sum;
}tree[N<<6];//数组开大一点
int a[N],b[N];
int root[N];
int n,m;
int ans;
int id;
inline int read(void){//快读
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;		
}
void build(int &x,int l,int r){//建立第一棵树（空树）
	x=++id;
	if(l==r)
		return;
	int mid=(l+r)>>1;
	build(tree[x].lc,l,mid);
	build(tree[x].rc,mid+1,r);
	return;
}
void change(int &x,int y,int l,int r,int val){//x结点是建立在 y 结点的基础之上进行修改的
	x=++id;
	tree[x].lc=tree[y].lc;
	tree[x].rc=tree[y].rc;
	tree[x].sum=tree[y].sum+1;
	if(l==r){
		return;
	}
	int mid=(l+r)>>1;
	if(val<=mid)
		change(tree[x].lc,tree[y].lc,l,mid,val);
	else
		change(tree[x].rc,tree[y].rc,mid+1,r,val);
	return;		
}
int ask(int Lt,int Rt,int l,int r,int L,int R){//查询
	if(L>R){//在查询的时候是可能会出现 L>R 的情况的，注意特判
		return 0;		
	}
	if(L<=l&&r<=R){
		return tree[Rt].sum-tree[Lt].sum;//根据主席树的性质，[l,r] 中数值 [L,R] 的数量 = [1,r] 中数值 [L,R] 的数量 - [1,l-1] 中数值 [L,R] 的数量
	}
	int mid=(l+r)>>1,res=0;
	if(L<=mid)
		res+=ask(tree[Lt].lc,tree[Rt].lc,l,mid,L,R);
	if(mid<R)
		res+=ask(tree[Lt].rc,tree[Rt].rc,mid+1,r,L,R);
	return res;		
}
signed main(void){
	n=read();
	for(rr int i=1;i<=n;++i){
		a[i]=b[i]=read();
	}
	std::sort(b+1,b+1+n);
	m=std::unique(b+1,b+1+n)-(b+1);//离散化
	build(root[0],1,m);
	for(rr int i=1;i<=n;++i){
		change(root[i],root[i-1],1,m,std::lower_bound(b+1,b+1+m,a[i])-b);//插入（建立权值线段树）
	}
	for(rr int i=2;i<=n-1;++i){
		int val=std::lower_bound(b+1,b+1+m,a[i])-b;
		ans+=ask(root[0],root[i-1],1,m,1,val-1)*ask(root[i],root[n],1,m,val+1,m);//利用乘法原理  （在他左边比他小的*在他右边比他大的）
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：rainygame (赞：4)

为什么感觉这道题没到绿……

考虑维护两个权值树状数组：

- 维护固定 $i$ 满足 $i>j$ 且 $a_i > a_j$ 的 $j$ 数量。
- 维护固定 $i$ 满足 $i>j>k$ 且 $a_i>a_j>a_k$ 的 $j,k$ 数量。

第一个树状数组是十分好维护的。

第二个树状数组要用第一个树状数组辅助维护，每次都在 $a_i$ 处加上小于 $a_i$ 的数的数量。这样只要查询小于 $x$ 的和，就可以直接求出第二个问题。

可能需要自行画图理解。

然后枚举的时候顺便统计答案。

时间复杂度 $O(n \log k)$，其中 $k$ 为值域。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) (x & -x)
#define MAXN 100001

int n, x, ans;

struct BIT{
	int c[MAXN];
	void add(int x, int k){
		while (x < MAXN){
			c[x] += k;
			x += lowbit(x);
		}
	}
	
	int query(int x){
		int res(0);
		while (x){
			res += c[x];
			x -= lowbit(x);
		}
		return res;
	}
}t1, t2;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n;
	for (int i(1); i<=n; ++i){
		cin >> x;
		ans += t2.query(x-1);
		t2.add(x, t1.query(x-1));
		t1.add(x, 1);
	}
	cout << ans;
	
	return 0;
}

```


---

## 作者：wjr_jok (赞：3)

发现值域很小，所以考虑对它分块。

$xl$ 为读入数组，$q_{i},h_{i}$ 分别表示在 $xl_{i}$ 前面且比它小的，以及在 $xl_{i}$ 后面且比它大的。

对于分块部分，$x,y,fk$ 三个数组分别记录每个块的左右端点以及每个数对应的块（注意这里的数指的是值域中的数值），$cc,tj$ 为值域标记数组，用于记录每个数值出现了多少次，每个块内的数值共出现了多少次。

对于 $q _ {i}$，通过遍历 $1$ $\sim$ $xl _ {i} - 1$ 的值域覆盖的块求得，$h _ {i}$ 就从 $xl _ {i} + 1$ $\sim$ $maxx$ 的值域覆盖的块求得。为了保证先后顺序，这里求取 $q$ 数组时正序遍历，求取 $h$ 数组时倒序遍历。

最后我们枚举每个数作为三元上升子序列的中间数，将答案累加，即为 $\begin{aligned} \sum _ {i = 1} ^ n q_{i} \times h_{i} \end{aligned}$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,l,r,cnt,ans,maxx;
int xl[30001],q[30001],h[30001],tj[320];
int x[320],y[320],cc[100001],fk[100001];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>xl[i];
		maxx=max(maxx,xl[i]);//求值域
	}
	for(int i=1;i<=(int)sqrt(maxx);i++){
		cnt++;
		x[cnt]=y[cnt-1]+1;
		y[cnt]=x[cnt]+(int)sqrt(maxx)-1;
		for(int j=x[cnt];j<=y[cnt];j++){
			fk[j]=cnt;
		}
	}
	if(y[cnt]<maxx){
		cnt++;
		x[cnt]=y[cnt-1]+1;
		y[cnt]=maxx;
		for(int i=x[cnt];i<=y[cnt];i++){
			fk[i]=cnt;
		}
	}
	for(int i=1;i<=n;i++){
		l=1,r=xl[i]-1;//1~xl[i-1]的值域
		for(int j=l;j<=min(y[fk[l]],r);j++){
			q[i]+=cc[j];
		}
		if(fk[l]!=fk[r]&&fk[r]){
			for(int j=x[fk[r]];j<=r;j++){
				q[i]+=cc[j];
			}
		}
		for(int j=fk[l]+1;j<fk[r]&&fk[r];j++){
			q[i]+=tj[j];
		}
		cc[xl[i]]++;
		tj[fk[xl[i]]]++;//录入当前值
	}
	for(int i=1;i<=maxx;i++){
		cc[i]=tj[fk[i]]=0;
	}//清空
	for(int i=n;i>=1;i--){//注意为倒序
		l=xl[i]+1,r=maxx;//xl[i]+1~maxx的值域
		for(int j=l;j<=min(y[fk[l]],r);j++){
			h[i]+=cc[j];
		}
		if(fk[l]!=fk[r]&&fk[l]){
			for(int j=x[fk[r]];j<=r;j++){
				h[i]+=cc[j];
			}
		}
		for(int j=fk[l]+1;j<fk[r]&&fk[l];j++){
			h[i]+=tj[j];
		}
		cc[xl[i]]++;
		tj[fk[xl[i]]]++;//录入当前值
	}
	for(int i=1;i<=n;i++){
		ans+=q[i]*h[i];//求和
	}
	cout<<ans;
	return 0;
}	
```

---

## 作者：HoshiuZ (赞：2)

与那题楼兰图腾其实是一样的。

本题范围较大，所以要先离散化。然后就可以愉快的利用树状数组求出第$i$个数左边比其小的数的个数$xi[i]$，第$i$个数右面比其大的数的个数$d[i]$，具体实现即为用树状数组求数值前缀（后缀）和。由于后缀和查询要减$1$，所以离散可以从$2$开始，防止$0\&-0=0$而陷入死循环。

最后根据乘法原理，直接把每组$xi[i]×d[i]$的积加起来即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

int n,t[30010];
struct node{
	ll t;
	int id;
}a[30010];
ll d[30010],xi[30010],sum[30010],ans=0;

bool cmp(node x,node y) {
	return x.t<y.t;
}

int lowbit(int x) {
	return x&(-x);
}

void update(int x,int y) {
	for(;x<=n+1;x+=lowbit(x)) sum[x]+=y;
}

ll ask(int x) {
	ll ans=0;
	for(;x;x-=lowbit(x)) ans+=sum[x];
	return ans;
}

void updateh(int x,int y) {
	for(;x;x-=lowbit(x)) sum[x]+=y;
}

ll askh(int x) {
	ll ans=0;
	for(;x<=n+1;x+=lowbit(x)) ans+=sum[x];
	return ans;
}

int main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].t,a[i].id=i; 
	sort(a+1,a+n+1,cmp);
	
	int s=a[1].t,js=2;
	for(int i=1;i<=n;i++) {
		if(s==a[i].t) t[a[i].id]=js;
		else t[a[i].id]=++js,s=a[i].t;
	}
	for(int i=1;i<=n;i++) {
		update(t[i],1);
		xi[i]=ask(t[i]-1);
	}
	memset(sum,0,sizeof(sum));
	for(int i=n;i>=1;i--) {
		updateh(t[i],1);
		d[i]=askh(t[i]+1);
	}
	
	for(int i=1;i<=n;i++) ans+=d[i]*xi[i];
	
	cout<<ans<<endl;
	
	return 0;
}
```

------------
事实上这是很繁琐的。其实不需要什么后缀和操作，仍然用前缀和就行，利用容斥的思想，$d[i]=ask(n)-ask(t[i])$，这样就能统计出$t[i]$之后的以放入树状数组的数的个数，也就是在其之后又比其大的数的个数。
```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

int n,t[30010];
struct node{
	ll t;
	int id;
}a[30010];
ll d[30010],xi[30010],sum[30010],ans=0;

bool cmp(node x,node y) {
	return x.t<y.t;
}

int lowbit(int x) {
	return x&(-x);
}

void update(int x,int y) {
	for(;x<=n+1;x+=lowbit(x)) sum[x]+=y;
}

ll ask(int x) {
	ll ans=0;
	for(;x;x-=lowbit(x)) ans+=sum[x];
	return ans;
}

int main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].t,a[i].id=i; 
	sort(a+1,a+n+1,cmp);
	
	int s=a[1].t,js=1;
	for(int i=1;i<=n;i++) {
		if(s==a[i].t) t[a[i].id]=js;
		else t[a[i].id]=++js,s=a[i].t;
	}
	for(int i=1;i<=n;i++) {
		update(t[i],1);
		xi[i]=ask(t[i]-1);
	}
	memset(sum,0,sizeof(sum));
	for(int i=n;i>=1;i--) {
		update(t[i],1);
		d[i]=ask(js)-ask(t[i]);
	}
	
	for(int i=1;i<=n;i++) ans+=d[i]*xi[i];
	
	cout<<ans<<endl;
	
	return 0;
}
```


---

## 作者：huangwux (赞：2)

# 树状数组

弱化版楼兰图腾

两个树状数组left right分别记录在a[i]之前比a[i]小的数和在a[i]之后比a[i]大的数

具体做法：

在值域上开树状数组（读入时记录不同的值）

顺序和倒序扫描各一遍

然后根据乘法原理

sigma（1~n） left[i] * right[i]

需要特别注意的点有以下几个

1.虽然题目里写的是a[i]>=0 但是依然有负数数据出现  为了避免数组负下标导致RE 可以在树状数组统计时给每个数+10000 

2.针对问题1 如果负数数据过大 或值域过大 考虑离散化

离散化：针对值域大，数值小，每个数的绝对值对答案没有影响，只考虑数之间的相对大小时 可以将值域里的每个数映射到数据个数范围内的较少个数内
方法是先排序 再用1~n里的数分别代表原来的每一个数

这样可以很好的解决值域过大带来的不便

3.树状数组无法直接查询比它大的数

所以在第二个树状数组查询时，需要用已经加入的数-比它小的数

即right[i]=n-i-a[i]后比它大的数 详见代码

最后是AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
ll int n,maxx;
ll int a[500500];
long long ans;
ll int left1[500500],right1[500500];
ll int lowbit(int x){
	return x&-x;
}
void add_left(int a){
	for(int i=a;i<=maxx;i+=lowbit(i))
	   left1[i+10000]+=1;
}
ll int query_left(int r){
	int sum=0;
	for(;r>=1;r-=lowbit(r))
	sum+=left1[r+10000];
	return sum;
}
void add_right(int a){
	for(int i=a;i<=maxx;i+=lowbit(i))
	right1[i+10000]+=1;
}
ll int query_right(int l){
	int sum=0;
	for(;l>=1;l-=lowbit(l)){
	//printf("%d\n",l);
	sum+=right1[l+10000];}
	return n-sum;
}
ll int lef[500050],rig[500050];
//long long ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	scanf("%d",&a[i]);
	if(a[i]>maxx)
	maxx=a[i];
	}
	for(int i=1;i<=n;i++){
		lef[i]=query_left(a[i]-1);
		add_left(a[i]); 
	}
	for(int i=n;i>=1;i--){
		rig[i]=query_right(a[i])-i;
		add_right(a[i]); 
	}
	for(int i=2;i<=n-1;i++)
	 ans+=(long long)lef[i]*rig[i];
	 printf("%lld",ans);
	 //puts(" ");
	 //for(int i=1;i<=n;i++)
	 //cout<<lef[i]<<"  "<<rig[i]<<endl;
	 //puts(" ");
	//cout<<rig[2];
}
```


---

## 作者：YuntianZhao (赞：2)

# P1637

这是一篇用了 c++11 特性和模板类的题解。

其实树状数组求三元上升子序列就是一个求顺序对的 combo 。在做题的时候可以先思考如果所给的序列里没有重复元素的时候该怎么做，再考虑如果有重复元素的情况。

然后显然的是，这道题要用两个树状数组来维护，显然手敲 update1， update2 不是一个优雅的写法（逃。这里简单教大家写一下模板类。

```cpp

template<typename T>
class {
public:
  // define something...
  // do something...
}
```

template 是模板的意思， typename 是 c++ 里面的类名称，可以是 int ， long long ， double ，非常方便， 再 c++ stl 里面广泛使用，比如说我们这里封装一个树状数组模板类，之后就可以 BIT<int> tree 来创建一颗树状数组。

完整代码如下，偷懒用了 lambda 表达式，实际效果等价于 cmp 函数。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int maxn = 1e5 + 5;

int n, m, k;

struct Node {
  int pos, key;
  Node(int pos = 0, int key = 0):
      pos(pos), key(key) {};
};

Node pool[maxn];

template <typename T>
class BIT {
public:
  T c[maxn];
  inline int lowbit(int x) { return x & (-x); }
  void update(int x, int dv) {
    for (int i = x; i <= n; i += lowbit(i)) {
      c[i] += dv;
    }
  }
  T getSum(int x) {
    T ret = 0;
    for (int i = x; i; i -= lowbit(i)) {
      ret += c[i];
    }
    return ret;
  }
};

BIT<int> t1, t2; // t1 ---- 

int prv[maxn];

int main() {
  scanf("%d", &n);
  int x;
  for (int i = 1; i <= n; i++) {
    scanf("%d", &x);
    pool[i] = Node(i, x);
  }
  sort(pool + 1, pool + n + 1, [](Node a, Node b) { return a.key < b.key; });
  for (int i = 1, j = 1; i <= n; i++) {
    if (pool[i].key != pool[i - 1].key) {
      while (j < i) {
        t1.update(pool[j++].pos, 1);
      }
    }
    prv[i] = t1.getSum(pool[i].pos - 1);
  }
  ll ans = 0;
  for (int i = n, j = n; i; i--) {
    if (pool[i].key != pool[i + 1].key) {
      while (j > i) {
        t2.update(pool[j--].pos, 1);
      }
    }
    ans += prv[i] * (t2.getSum(n) - t2.getSum(pool[i].pos));
  }
  printf("%lld", ans);
  return 0;
}

```

---

## 作者：斗神_君莫笑 (赞：1)

显而易见，对于每一个i，我们只需要知道前面比它小的个数和后面比它大的个数，就可以乘法原理求出  
考虑离散后使用桶，可以logn求出1到i-1比i小的个数  
因此我们便得出了以下代码  
注意smaller和bigger需要分成两遍加入，否则会出问题
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Point{
	int level,sum,place;
}a[30010];
bool cmp1(const Point &x,const Point &y){
	return x.sum<y.sum;
}
bool cmp2(const Point &x,const Point &y){
	return x.place<y.place;
}
int vis[30010];
struct Node{
	int l,r,sum;
}T[400010];
inline void pushup(int p){
	T[p].sum=T[lc].sum+T[rc].sum;
}
void build(int p,int l,int r){
	T[p].l=l,T[p].r=r;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
}
void update(int p,int q){
	if(T[p].l==T[p].r){
		T[p].sum++;return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(q<=mid)update(lc,q);
	if(q>mid)update(rc,q);
	pushup(p);
}
int query(int p,int ql,int qr){
	if(ql>qr)return 0;
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p].sum;
	int mid=(T[p].l+T[p].r)>>1;
	int ans=0;
	if(ql<=mid)ans+=query(lc,ql,qr);
	if(qr>mid)ans+=query(rc,ql,qr);
	return ans;
}
int smaller[100010],bigger[100010];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i].sum),a[i].place=i;
	sort(a+1,a+n+1,cmp1);
	int cnt=0;
	for(int i=1;i<=n;++i){
		if(a[i-1].sum<a[i].sum)++cnt;
		a[i].level=cnt;
	}
	sort(a+1,a+n+1,cmp2);
	build(1,1,n);
	long long ans=0;
	for(int i=1;i<=n;++i){
		if(a[i].level>1)smaller[i]=query(1,1,a[i].level-1);//处理出前面比它小的数 
		update(1,a[i].level);
	}
	memset(T,0,sizeof(T));
	build(1,1,n);
	for(int i=n;i>=1;--i){
		if(a[i].level<n)bigger[i]=query(1,a[i].level+1,cnt);//处理出后面比它大的数 
		update(1,a[i].level);
	}
	for(int i=1;i<=n;++i)
		ans+=smaller[i]*bigger[i];
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：zhylj (赞：1)

为了获得更好的阅读体验，你可以前往我的博客查看：[https://www.cnblogs.com/zhylj/p/9492781.html](https://www.cnblogs.com/zhylj/p/9492781.html)

对于每个数$a_i$，易得它对答案的贡献为 它左边比它小的数的个数$\times$它右边比它大的数的个数。

可以离散化后再处理也可以使用动态开点的线段树。

我使用了动态开点的线段树，只有需要用到这个节点的时候才新建这个节点，这里我是在进行修改的时候新建的。

时间复杂度$O(n\log (\max \rm MAX\_INT))$，空间复杂度$O(n\log (\max \rm MAX\_INT))$（常数真的很大）

以下是代码，不清楚的地方已标出。

```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const ll MAXN = 3e4 + 5, inf = 0x7fffffffLL + 5LL;

ll ans = 0, kans[MAXN], a[MAXN], n;

struct node{

    ll data;
    node *lc, *rc;

    void pushup() {
        data = 0;
        if(lc) data += lc->data;
        if(rc) data += rc->data;
    }

    node() {
        data = 0;
        lc = rc = NULL;
    }

} *st1 = new node, *st2 = new node;  //建立两棵线段树

ll query(node *&cur, ll l, ll r, ll ql, ll qr) {
    if(!cur) return 0;  //防止访问无效内存
    if(ql <= l && r <= qr) {
        return cur->data;
    }
    ll mid = (l + r) >> 1, ans = 0;
    if(ql <= mid) ans += query(cur->lc, l, mid, ql, qr);
    if(qr > mid) ans += query(cur->rc, mid + 1, r, ql, qr);
    return ans;
}

void modify(node *&cur, ll l, ll r, ll q, ll k) {
    if(!cur) cur = new node;  //新建节点
    if(l == r) cur->data += k;
    else {
        ll mid = (l + r) >> 1;
        if(q <= mid) modify(cur->lc, l, mid, q, k);
        else modify(cur->rc, mid + 1, r, q, k);
        cur->pushup();
    }
}

void solve() {
    for(ll i = 0; i < n; i++) {
        kans[i] = query(st1, 1, inf, 1, a[i] - 1);  //得到它左边比它小的数的个数
        modify(st1, 1, inf, a[i], 1);
    }
    for(ll i = n - 1; i >= 0; i--) {
        kans[i] *= query(st2, 1, inf, a[i] + 1, inf);  //得到右边比它大的数的个数
        modify(st2, 1, inf, a[i], 1);
    }
}

int main () {
    cin >> n;
    for(ll i = 0; i < n; i++) cin >> a[i], a[i]+=2;  //为了防止访问到0，这里直接加上2，是不改变结果的
    solve();
    for(ll i = 0; i < n; i++) ans += kans[i];
    cout << ans << endl;
    return 0;
}
```

---

## 作者：KKarshilov (赞：1)

这道题数据范围这么小为什么没有人用分块啊

众所周知，这道题暴力是n^2的，统计一下前面有多少个比自己小的，后面有多少比自己大的，相乘就是这个数的贡献，一共n个数

所以我们可以分块，将它划分为sqrt(n)个块，统计时只枚举这个数所在的块，不超过sqrt(n)，再枚举它前面或后面的整块sqrt(n)，这题就可以n*sqrt(n)的解决了

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 50100;
const int INF = 0x3f3f3f3f;

typedef pair<int, int> pii;
#define X first
#define Y second

template <typename T> inline void read(T &x) {
    int c = getchar();
    bool fg = false;
    for (x = 0; !isdigit(c); c = getchar()) {
        if (c == '-') {
            fg = true;
        }
    }
    for (; isdigit(c); c = getchar()) {
        x = x * 10 + c - '0';
    }
    if (fg) {
        x = -x;
    }
}

int n, a[MAXN], L[MAXN], R[MAXN];
long long ans;
int b[MAXN], belong[MAXN], cnt[MAXN / 10], len, tot;
pii ref[MAXN];

int calc_small(int pos) {
	int x = pos / len + 1;
	int sml = 0, lim = (x - 1) * len;
	for(int i = 1; i < x; i++) sml += cnt[i];
	for(int i = lim; i < pos; i++) sml += b[i];
	return sml;
}

int calc_Big(int pos) {
	int x = pos / len + 1;
	int Big = 0, lim = min(x * len - 1, n);
	for(int i = 1 + x; i <= tot; i++) Big += cnt[i];
	for(int i = pos + 1; i <= lim; i++) Big += b[i];
	return Big;
}

signed main() {
	read(n);
	for(int i = 1; i <= n; i++) read(a[i]), ref[i].X = a[i], ref[i].Y = i;
	sort(ref + 1, ref + n + 1);
	for(int i = 1; i <= n; i++) {
		if(ref[i].X != ref[i - 1].X || i == 1) a[ref[i].Y] = i;
		else a[ref[i].Y] = a[ref[i - 1].Y];
	}
	len = (int) ceil(sqrt(n));
	tot = n / len + 1;
	for(int i = 1; i <= n; i++) {
		belong[i] = a[i] / len + 1;
		cnt[belong[i]] ++;
		L[i] = calc_small(a[i]);
		b[a[i]] ++;
	}
	memset(b, 0, sizeof(b)), memset(cnt, 0, sizeof(cnt));
	for(int i = n; i; i--) {
		cnt[belong[i]] ++;
		R[i] = calc_Big(a[i]);
		b[a[i]] ++;
	}
	for(int i = 2; i < n; i++) ans += (long long) L[i] * R[i];
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：GKxx (赞：1)

拿到题目之后简单地分析了一下，我们可以枚举中间元素，问题变成了左边有多少个数小于它\*右边有多少个数大于它。

于是我花了不到10分钟随手敲了个树状数组套splay。

众所周知splay上查询有多少个数小于/大于给定值都是很简单的。那么现在我们可以把问题变成 给定区间中有多少个数小于/大于给定值，这个区间可以分解为树状数组上的若干个结点，然后就只要对每个节点对应的splay进行查询最后加起来就行了。

另外，答案要开long long! 一开始没用long longWA到63分

```cpp
// C++11
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)

const int maxn = 3e5 + 100;
const int maxsize = maxn * 30;
int root[maxn];
int a[maxn];
int fa[maxsize], ch[maxsize][2], size[maxsize], freq[maxsize], value[maxsize];
int n, tot;

inline int newNode(int v = 0) {
    value[++tot] = v;
    size[tot] = 1;
    freq[tot] = 1;
    return tot;
}
inline void update(int x) {
    size[x] = freq[x];
    if (ch[x][0])
        size[x] += size[ch[x][0]];
    if (ch[x][1])
        size[x] += size[ch[x][1]];
}
inline int iden(int x) {
    if (ch[fa[x]][0] == x) return 0;
    if (ch[fa[x]][1] == x) return 1;
    return -1;
}
inline void rotate(int x) {
    if (!x) return;
    int d = iden(x);
    int y = fa[x];
    if (~iden(y))
        ch[fa[y]][iden(y)] = x;
    fa[x] = fa[y];
    ch[y][d] = ch[x][d ^ 1];
    if (ch[x][d ^ 1])
        fa[ch[x][d ^ 1]] = y;
    ch[x][d ^ 1] = y;
    fa[y] = x;
    update(y);
    update(x);
}
inline void splay(int x, int &k) {
    int p = fa[k];
    while (fa[x] != p) {
        int y = fa[x];
        if (fa[y] != p) {
            if (iden(y) ^ iden(x))
                rotate(x);
            else
                rotate(y);
        }
        rotate(x);
    }
    k = x;
}
inline int insert(int &k, int val) {
    if (!k) {
        k = newNode(val);
        return k;
    }
    int x = k;
    while (0207) {
        ++size[x];
        if (val == value[x]) {
            ++freq[x];
            splay(x, k);
            return x;
        }
        int d = val > value[x];
        if (ch[x][d]) x = ch[x][d];
        else {
            ch[x][d] = newNode(val);
            fa[ch[x][d]] = x;
            x = ch[x][d];
            splay(x, k);
            return x;
        }
    }
}
int lessThan(int x, int val) {
    if (!x) return 0;
    if (val <= value[x])
        return lessThan(ch[x][0], val);
    else if (ch[x][0])
        return size[ch[x][0]] + freq[x] + lessThan(ch[x][1], val);
    else
        return freq[x] + lessThan(ch[x][1], val);
}
int greaterThan(int x, int val) {
    if (!x) return 0;
    if (val >= value[x])
        return greaterThan(ch[x][1], val);
    else if (ch[x][1])
        return size[ch[x][1]] + freq[x] + greaterThan(ch[x][0], val);
    else
        return freq[x] + greaterThan(ch[x][0], val);
}

inline long long queryLess(int p, int x) {
    long long ret = 0;
    for (; p; p -= p & -p)
        ret += lessThan(root[p], x);
    return ret;
}
inline long long queryGreater(int p, int x) {
    long long ret = 0;
    for (; p; p -= p & -p)
        ret += greaterThan(root[p], x);
    return ret;
}
inline void insertBit(int p, int x) {
    for (; p <= n; p += p & -p)
        insert(root[p], x);
}

int main() {
    read(n);
    rep(i, 1, n) read(a[i]);
    rep(i, 1, n) insertBit(i, a[i]);
    if (n <= 2) {
        puts("0");
        return 0;
    }
    long long ans = 0;
    rep(i, 2, n - 1)
        ans += queryLess(i - 1, a[i]) * (queryGreater(n, a[i]) - queryGreater(i - 1, a[i]));
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：ModestCoder_ (赞：1)

来篇pascal的


思路很容易想到，乘法原理


对于每一个数，在他前面并比他小的数的个数\*在他后面并比他大的数的个数累加起来就是答案


所以这里我们需要维护两个树状数组


一个用来求在他前面并比他小的数的个数


一个用来求在他后面并比他大的数的个数


类似的算法？就是逆序对


不过需要弄点手段：


求在他前面并比他小的数的个数时，来个快排，从小到大，并且相等的初始位置后的排在前


为什么？


若有相等的，i<j,ai=aj，排好序后i在前


那么算i时没影响，但算j时会把i的那份也加进去，就wa了


求在他后面并比他大的数的个数，快排，从大到小，并且相等的初始位置前的排在前


诶，不一样了！


对，是不一样


因为我们要记录位置后面，数值大于自己，与刚才完全反了一下


而且树状数组修改是往前加了，求和是往后加了，也不一样


```cpp
var
    a,b,c,d,tree,minsum,maxsum:array[0..100000] of int64;
    n,i:longint;
    ans:int64;
function lowbit(x:int64):int64;
begin
    exit(x and -x);
end;
procedure change(x:int64);
begin
    while x<=n do
        begin
            inc(tree[x]);
            inc(x,lowbit(x));
        end;
end;
function getsum(x:int64):int64;
begin
    getsum:=0;
    while x>0 do
        begin
            inc(getsum,tree[x]);
            dec(x,lowbit(x));
        end;
end;
procedure change1(x:int64);
begin
    while x>0 do
        begin
            inc(tree[x]);
            dec(x,lowbit(x));
        end;
end;
function getsum1(x:int64):int64;
begin
    getsum1:=0;
    while x<=n do
        begin
            inc(getsum1,tree[x]);
            inc(x,lowbit(x));
        end;
end;
procedure sort(l,r: longint);
      var
         i,j,x,y,m: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         m:=b[(l+r) div 2];
         repeat
           while (a[i]<x) or (a[i]=x) and (b[i]>m) do
            inc(i);
           while (x<a[j]) or (x=a[j]) and (m>b[j]) do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
procedure qsort(l,r: longint);
      var
         i,j,x,y,m: longint;
      begin
         i:=l;
         j:=r;
         x:=c[(l+r) div 2];
         m:=d[(l+r) div 2];
         repeat
           while (c[i]>x) or (c[i]=x) and (d[i]<m) do
            inc(i);
           while (x>c[j]) or (x=c[j]) and (m<d[j]) do
            dec(j);
           if not(i>j) then
             begin
                y:=c[i];
                c[i]:=c[j];
                c[j]:=y;
                y:=d[i];
                d[i]:=d[j];
                d[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           qsort(l,j);
         if i<r then
           qsort(i,r);
      end;
begin
    readln(n);
    for i:=1 to n do
        begin
            read(a[i]);
            c[i]:=a[i];
            b[i]:=i;
            d[i]:=i;
        end;
    sort(1,n);
    qsort(1,n);
    for i:=1 to n do
        begin
            minsum[b[i]]:=getsum(b[i]);
            change(b[i]);
        end;
    fillchar(tree,sizeof(tree),0); //第二个树状数组
    for i:=1 to n do
        begin
            maxsum[d[i]]:=getsum1(d[i]);
            change1(d[i]);
        end;
    for i:=1 to n do
        inc(ans,minsum[i]*maxsum[i]);  //乘法原理
    writeln(ans);
end.
注意：开int64，不然会wa
```

---

## 作者：SNiFe (赞：1)

这道题我也不知道怎么了，改着改着就AC了。。。。。。（然而自己看不懂自己的代码）

但在我仔细思考后就想通了^\_^233。

不是有三个数吗,那就吧当前枚举的数当做三个数中的第二个，先找比它小的数有几个，再找比它大的数有几个，分别用mi[ ]和ma [ ]记录下来，

最终答案就是ans+=mi[i]\*ma[i]；

##由此，我们想到了用树状数组求比它大和比它小的数有多少个——即逆序队。

##先由小到大排序，求比它小的数个数，再从大到小排序，求比它大的数个数。

#Code（详见代码）：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=30005;
long long map[N],f[N],n,mi[N],ma[N],ans=0;
struct node
{
    int pos,val;
}a[N];
bool cmp(node x,node b)
{
    return x.val<b.val;
}
bool cmp2(node x,node b)
{
    return x.val>b.val;
}
void add(long long k,int w)
{
    while(k<=n)
    {
        f[k]+=w;
        k+=k&-k;
    }
}
long long query(long long k)
{
    long long sum=0;
    while(k>=1)
    {
        sum+=f[k];
        k-=k&-k;
    }
    return sum;
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i].val);a[i].pos=i;
    }
    sort(a+1,a+1+n,cmp);//从小到大牌 
    for(int i=1;i<=n;i++)//离散化 加 去重 
    {
        if(a[i].val==a[i-1].val) map[a[i].pos]=map[a[i-1].pos];
        else map[a[i].pos]=i;
    }
    for(int i=1;i<=n;i++)
    {
        mi[i]=query(map[i]-1);
        add(map[i],1);
    }
    sort(a+1,a+1+n,cmp2);//从大到小排 
    memset(f,0,sizeof(f));//初始化f数组 
    for(int i=1;i<=n;i++)
    {
        if(a[i].val==a[i-1].val)map[a[i].pos]=map[a[i-1].pos];
        else map[a[i].pos]=i;
    }
    for(int i=n;i>=1;i--)
    {
        ma[i]=query(map[i]-1);//要去掉本身，so -1 ，还有请注意我和楼下写的不一样，所以我不是n-map[i] 
        add(map[i],1);
    }
    for(int i=1;i<=n;i++)ans+=mi[i]*ma[i];
    printf("%lld",ans);
}
```

---

## 作者：ShaunWang (赞：1)

##离散化 + 树状数组

1.显然，对于所有的三元上升子序列，我们只需要考察中间的元素，即对于每个元素，我们要求出其左边严格小于它的数的个数d和右边严格大于它的数的个数u，然后将u\*d统计进答案即可

2.考虑如何求u和d，显然我们需要借助一颗权值线段树，然而这里可以用树状数组，我们只需要维护两颗树状数组，一个正向添加数字，一个反向添加数字，然后边添加边统计有多少个严格大于/小于它的数字即可（当然需要离散化）

不懂权值线段树的同学自行百度QAQ

带注释代码如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#define LL long long
#define lowbit(x) ((x)&-(x))
#define MAXN 30005
namespace IO
{
    inline int getint()
    {
        int x = 0, f = 1;
        char c = getchar();
        while(c < '0' || c > '9')
        {
            if(c == '-') f = 0;
            c = getchar();
        }
        while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
        return f ? x : -x;
    }
};
using namespace std;
using namespace IO;
int n, m;
LL ans;
int a[MAXN], h[MAXN];//原值 / 新值
int u[MAXN], d[MAXN];//左边比它小的数字个数 / 右边比它大的数字个数
struct BinaryIndexedTree
{
    int C[MAXN];
    void add(int x, int v)
    {
        for(; x <= n && x > 0; x += lowbit(x)) C[x] += v;
    }
    int getsum(int x)
    {
        int sum = 0;
        for(; x > 0; x -= lowbit(x)) sum += C[x];
        return sum;
    }
} T[2];
int main()
{
    n = getint();
    for(int i = 1; i <= n; ++i) a[i] = h[i] = getint();
    sort(a + 1, a + n + 1);//离散化使范围变为[1,n]
    m = unique(a + 1, a + n + 1) - a - 1;
    for(int i = 1; i <= n; ++i) h[i] = lower_bound(a + 1, a + m + 1, h[i]) - a;
    for(int i = 1; i <= n; ++i)//从左往右添加数字并求出左边比它小的数字个数
    {
        d[i] = T[0].getsum(h[i] - 1);//求出比它小的数字个数
        T[0].add(h[i], 1);//然后再加入这个数字
    }
    for(int i = n; i >= 1; --i)//从右往左添加数字并求出右边比它大的数字个数
    {
        u[i] = n - i - T[1].getsum(h[i]);//求出比它大的数字的个数
        T[1].add(h[i], 1);//然后再加入这个数字
    }
    for(int i = 1; i <= n; ++i) ans += u[i] * d[i];//统计答案
    cout << ans;
    return 0;
}
```

---

## 作者：Limit (赞：0)

暴力是三重循环,枚举三个数判断是否组成三元上升子序列,但是N有30000,O(N^3)直接枚举肯定是会T的,不难发现当中间的数为a[i]时它所贡献出的三元上升子序列
的个数为1~i-1中比a[i]小的数的个数乘i+1~N中比a[i]大的数的个数.这很容易就会想到逆序对(~~虽然还是有点不同~~),逆序对的常用方法归并没法求出每个数的逆序对个数(~~可能可以只不过我不会~~),所以就很容易想到线段树.
做法和权值线段树类似
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nL3J5dnh1MG85LnBuZw?x-oss-process=image/format,png)
如图1所示,每个叶节点表示一个数,所以就可以在logN的时间复杂度内算出在整颗线段树中比某个数大或小的数的个数.只要对于每个数查询出比他小的数的个数(small[i])并记录下来再把这个数加入这颗线段树.同理,将所有的数倒着放入,查询出在当前线段树中比这个数大的数的个数那么这个数(big)的贡献就是(small[i]*big).
数的个数比较大,没法直接加入线段树,所以需要先离散化.
```cpp
#include<bits/stdc++.h>
#define rap(i,first,last) for(int i=first;i<=last;++i)
#define sing(i,first,last) for(int i=first;i>=last;--i)
#define Lson now*2
#define Rson now*2+1
#define Middle (left+right)/2
#define Left Lson,left,Middle
#define Right Rson,Middle+1,right
using namespace std;
const int maxN=1e5+7;
int N,M;
int tree[maxN*4];
void PushUp(int now)
{
	tree[now]=tree[Lson]+tree[Rson];
}
void Build(int now=1,int left=1,int right=N)//建树,虽然没什么用
{
	if(left==right)
	{
		tree[now]=0;
		return;
	}
	Build(Left);
	Build(Right);
	PushUp(now);
}
void UpData(int num,int now=1,int left=1,int right=N)//修改
{
	if(num<left||right<num)return;
	if(left==right)//当是叶节点时直接修改
	{
		tree[now]++;
		return;
	}
	UpData(num,Left);
	UpData(num,Right);
	PushUp(now);//不是叶节点时需要在子树修改后修改,其实没有必要,反正都是+1
}
int Query_small(int num,int now=1,int left=1,int right=N)//查询当前数中比num小的数的个数
{
	if(left>=num)return 0;//当当前的数的区间的最小值也比num大时自然整个区间都不会有比num小的数了
	if(right<num)//当当前区间的最大值也比num小时整个区间里的数也就比num小了
	{
		return tree[now];
	}
	int result=0;//返回的值为左子树中比num小的数的个数+右子树中比num小的数的个数
	result+=Query_small(num,Left);
	result+=Query_small(num,Right);
	return result;
}
int Query_big(int num,int now=1,int left=1,int right=N)//与上同理
{
	if(right<=num)return 0;
	if(left>num)
	return tree[now];
	int result=0;
	result+=Query_big(num,Left);
	result+=Query_big(num,Right);
	return result;
}
map<int,int>Hash;//因为懒所以直接map离散化
int arr[maxN];
int sor[maxN];
int small[maxN];
int main()
{
	scanf("%d",&M);
	rap(i,1,M)
	{
		scanf("%d",&arr[i]);
		sor[i]=arr[i];
	}
	//离散化
	sort(sor+1,sor+1+M);
	int now=1;
	Hash[sor[1]]=1;
	rap(i,2,M)
	{
		if(sor[i]!=sor[i-1])
		{
			Hash[sor[i]]=++now;
		}
	}
	N=now;//数的大小为不同的数的个数
	long long answer=0;
	Build();
	rap(i,1,M)
	{
		small[i]=Query_small(Hash[arr[i]]);//查询出当前比这个数小的数的个数
		UpData(Hash[arr[i]]);//插入这个数
	}
	Build();
	sing(i,M,1)
	{
		answer+=small[i]*Query_big(Hash[arr[i]]);//计算这个数的贡献
		UpData(Hash[arr[i]]);
	}
	printf("%lld",answer);//输出answer,注意long long
	return ~0;
}

```


---

## 作者：abandentsky (赞：0)

思路：第一次写离散化的题目，打卡记录一下弥足珍贵的记忆。核心在于离散化可以消失当前元素是第几小（大）元素，然后用树状数组来维护小于等于（第几小）元素的个数。这样，大于某个元素个数转化为：在i个元素里减去（小于等于他）或者小于等于这个元素排名（第几小）的个数，这样就可以过了。

```c
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<stack>
#include<string>
#include<iostream>
#include<vector>
#include<ctype.h>
#include<algorithm>
#include<map>
#include<set>
#include<stdlib.h>
#include<queue>
#include<sstream>
#include<complex>
#define MAXN  30005
#define eps 0.00001
#define INF 0x3f3f3f3f
#define mod 19260817
#define MIN (-0x7fffffffffffffff)
typedef  long long  LL;
using namespace std;

int n,m;
LL P[MAXN],Q[MAXN];
LL C_1[MAXN],C_2[MAXN];
LL Left[MAXN],Right[MAXN];

int lowbit(int x)
{
    return (x&((-1)*x));
}

LL sum(LL *c,int x)
{
    LL ans=0;
    while(x>0)
    {
        ans+=c[x];
        x-=lowbit(x);
    }
    return ans;
}

void add(LL  *c,int x,int d)
{
    while(x<=n)
    {
        c[x]+=d;
        x+=lowbit(x);
    }
}

int query(int x)
{
    return lower_bound(Q+1,Q+1+m,x)-Q;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&P[i]);
        Q[i]=P[i];
    }
    sort(Q+1,Q+1+n);
    m=unique(Q+1,Q+1+n)-(Q+1);      //unqiue函数返回去重以后最后一个元素的下一个位置
                                                                         //现在返回的其实是去重后里面的元素个数
    for(int i=1;i<=n;i++)
    {
        add(C_1,query(P[i]),1);
        Left[i]=sum(C_1,query(P[i])-1);         //query（P[i])表示P[i]是第几小，因为要比P[i]小，所以就是去他前面有几个，所以减一
    }
    for(int i=n;i>=1;i--)
    {
        add(C_2,query(P[i]),1);
        Right[i]=n-i-(sum(C_2,query(P[i]))-1);   //总的数里减去小于等于，就是大于。然后处理一下细节
    }

    LL cnt=0;
    for(int i=2;i<n;i++)
    {
        cnt+=Left[i]*Right[i];
    }
    printf("%lld\n",cnt);
    return 0;
}

```


---

## 作者：profund (赞：0)

$Update:$ 修改部分排版。

## $Description$

本题暴力十分好打，只需$O(n^2)$ 暴力扫两遍，找出第$i$个数在$i$前面并且比$a[i]$小的数有$sum[i]$个，在$i$后面并且比$a[i]$大的数有$sum2[i]$个。
根据乘法原理，$ans=sum[i]*sum2[i]$。

但显然，对于$30000$ 的数据，$n^2$的复杂度显然会$T$。
这时，我们就要动用一些~~奇技淫巧~~优化，
      这个玩意可以刺激cpu并发，
     ~~比暴力不知道快到哪里去了~~

## $Code: $

```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include<bits/stdc++.h>
#define R register
using namespace std;
typedef long long ll;
inline char gc() {
    static char buf[100000], *p1 = buf, *p2 = buf;
    return (p1 == p2) && (p2 = (p1 = buf) + 
        fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
}
#define int ll
inline ll read(){
    ll res=0,f=1;
    char ch=gc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=gc();}
    while(ch>='0'&&ch<='9'){res=(res<<3)+(res<<1)+ch-'0';ch=gc();}
    return res*f;
}
void write(ll x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10|'0');
}
const int N=30005;
ll ans,n,sum[N],sum2[N],a[N];
#define debug(x) (cout << "#x = " << (x) << endl)
signed main(){
    n=read();
    for(R int i=1;i<=n;i++) a[i]=read();
    for(R int i=1;i<=n;i++){
        R int j = 1;
        R int a1 = 0, a2 = 0;
        R int a3 = 0, a4 = 0;
        R int a5 = 0, a6 = 0;
        R int a7 = 0, a8 = 0;
        for (; j + 8 <= i; j += 8) {
            if (a[j] < a[i]) ++a1;
            if (a[j + 1] < a[i]) ++a2;
            if (a[j + 2] < a[i]) ++a3;
            if (a[j + 3] < a[i]) ++a4;
            if (a[j + 4] < a[i]) ++a5;
            if (a[j + 5] < a[i]) ++a6;
            if (a[j + 6] < a[i]) ++a7;
            if (a[j + 7] < a[i]) ++a8;
        }
        ll k = i - j;
//		cout << "!" << j << " " << k << endl;
        switch (k) {
            case 0: break;
            case 1: 
                if (a[j] < a[i]) ++a1;
                break;
            case 2: 
                if (a[j] < a[i]) ++a1;
                if (a[j + 1] < a[i]) ++a2;
                break;
            case 3: 
                if (a[j] < a[i]) ++a1;
                if (a[j + 1] < a[i]) ++a2;
                if (a[j + 2] < a[i]) ++a3;
                break;
            case 4: 
                if (a[j] < a[i]) ++a1;
                if (a[j + 1] < a[i]) ++a1;
                if (a[j + 2] < a[i]) ++a2;
                if (a[j + 3] < a[i]) ++a3;
                break;
            case 5: 
                if (a[j] < a[i]) ++a1;
                if (a[j + 1] < a[i]) ++a1;
                if (a[j + 2] < a[i]) ++a2;
                if (a[j + 3] < a[i]) ++a3;
                if (a[j + 4] < a[i]) ++a4;
                break;
            case 6: 
                if (a[j] < a[i]) ++a1;
                if (a[j + 1] < a[i]) ++a2;
                if (a[j + 2] < a[i]) ++a3;
                if (a[j + 3] < a[i]) ++a4;
                if (a[j + 4] < a[i]) ++a5;
                if (a[j + 5] < a[i]) ++a6;
                break;
            case 7: 
                if (a[j] < a[i]) ++a1;
                if (a[j + 1] < a[i]) ++a1;
                if (a[j + 2] < a[i]) ++a2;
                if (a[j + 3] < a[i]) ++a3;
                if (a[j + 4] < a[i]) ++a4;
                if (a[j + 5] < a[i]) ++a5;
                if (a[j + 6] < a[i]) ++a6;
                break;
        }
        sum[i] += a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
//		for(R int j=1;j<i;j++)
//			if(a[j]<a[i]) sum[i]++;
    }
    for(R int i=1;i<=n;i++){
        R int j = i + 1;
        R int a1 = 0, a2 = 0;
        R int a3 = 0, a4 = 0;
        R int a5 = 0, a6 = 0;
        R int a7 = 0, a8 = 0;
        for (; j + 7 <= n; j += 8) {
            if (a[j] > a[i]) ++a1;
            if (a[j + 1] > a[i]) ++a2;
            if (a[j + 2] > a[i]) ++a3;
            if (a[j + 3] > a[i]) ++a4;
            if (a[j + 4] > a[i]) ++a5;
            if (a[j + 5] > a[i]) ++a6;
            if (a[j + 6] > a[i]) ++a7;
            if (a[j + 7] > a[i]) ++a8;
        }
        ll k = n - j + 1;
//		cout << "!" << j << " " << k << endl;
        switch (k) {
            case 0: break;
            case 1: 
                if (a[j] > a[i]) ++a1;
                break;
            case 2: 
                if (a[j] > a[i]) ++a1;
                if (a[j + 1] > a[i]) ++a2;
                break;
            case 3: 
                if (a[j] > a[i]) ++a1;
                if (a[j + 1] > a[i]) ++a2;
                if (a[j + 2] > a[i]) ++a3;
                break;
            case 4: 
                if (a[j] > a[i]) ++a1;
                if (a[j + 1] > a[i]) ++a1;
                if (a[j + 2] > a[i]) ++a2;
                if (a[j + 3] > a[i]) ++a3;
                break;
            case 5: 
                if (a[j] > a[i]) ++a1;
                if (a[j + 1] > a[i]) ++a1;
                if (a[j + 2] > a[i]) ++a2;
                if (a[j + 3] > a[i]) ++a3;
                if (a[j + 4] > a[i]) ++a4;
                break;
            case 6: 
                if (a[j] > a[i]) ++a1;
                if (a[j + 1] > a[i]) ++a2;
                if (a[j + 2] > a[i]) ++a3;
                if (a[j + 3] > a[i]) ++a4;
                if (a[j + 4] > a[i]) ++a5;
                if (a[j + 5] > a[i]) ++a6;
                break;
            case 7: 
                if (a[j] > a[i]) ++a1;
                if (a[j + 1] > a[i]) ++a1;
                if (a[j + 2] > a[i]) ++a2;
                if (a[j + 3] > a[i]) ++a3;
                if (a[j + 4] > a[i]) ++a4;
                if (a[j + 5] > a[i]) ++a5;
                if (a[j + 6] > a[i]) ++a6;
                break;
        }
        sum2[i] += a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
//		for(R int j=i+1;j<=n;j++)
//			if(a[j]>a[i]) sum2[i]++;
    }
    for(R int i=1;i<=n;i++)
        ans+=sum[i]*sum2[i];
    return write (ans), 0;
}

/*
11
1 2 3 4 5 6 7 8 9 10 11
*/


---

## 作者：huang_yue (赞：0)

根据乘法原理，以一个数为中心的thair的个数就是左侧小于它的数的数量乘以右侧大于它的数的数量。最后对这些乘积求和就是答案。

如何在短时间内求出左侧小于它的数的数量呢？参考P1908·逆序对@土间埋 的题解，可以模仿这个操作方法，只需要将其中的cmp函数改为<号（因为>号用于求逆序对，这里是求“顺序对”）即可。手动模拟一下相信会理解更深。

为什么要离散化各篇题解都已经讲了，这里要说的是怎么离散化。不妨设h[i]表示数组a中第i小的数的下标，那么h[i]显然满足a[h[i]] < a[h[i - 1]]；因此，一个sort就可以解决这个问题。

k数组就是为了消除重复数字这个问题而出现的。unique函数将重复的数字赋予了同一个编号，如果无法理解代码可以手算一下。
```cpp
#include<iostream>
#include<algorithm>
#include<numeric>
using namespace std;

//l[i]是左侧小于a[i]的数的个数；r[i]是右侧大于a[i]的数的个数
//c是l的树状数组，C是r的树状数组，n是数列长度，其余字母如上面分析所示
int c[30010], C[30010], a[30010], h[30010], n, l[30010], r[30010], k[30010];
struct cmp { bool operator()(int x, int y) {return a[x] < a[y];}};

void p(int* w, int x) {do ++w[x]; while ((x += (x & (-x))) <= n);}
int q(int* w, int x) { int s = 0; do s += w[x]; while (x -= (x & (-x))); return s; } //树状数组基本操作；p:单点修改 q:区间查询

void unique() { //给重复数字同一编号
	int d = k[h[1]] = 1;
	for (int i = 2; i <= n; ++i) {
		if (a[h[i]] != a[h[i - 1]]) ++d;
        //如果不同，编号自增；也就是说，如果相同就会有同一编号
		k[h[i]] = d;
	}
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i], h[i] = i;
	sort(h + 1, h + n + 1, cmp()); unique() //离散化
	for (int i = 1; i <= n; ++i)
		p(c, k[i]), l[i] = q(c, k[i] - 1); //仿照P1908的操作进行；注意查询左边区间和的时候并不包括自己，因此要用k[i] - 1
	for (int i = n; i >= 1; --i)
		p(C, k[i]), r[i] = n - i - q(C, k[i]) + 1; //这里要查询的是右边的区间和，可以用总和(也就是n-i+1)减去左边的区间和q(C, k[i])
	cout << inner_product(l + 2, l + n, r + 2, 0) << endl; //内积，也就是l[2]*r[2]+l[3]*r[3]+...+l[n-1]*r[n-1]；不带1和n是因为这两个左边（或右边）没有数，因此一定是0，带上也没什么用
	return 0;
}
```

---

## 作者：Adove (赞：0)

本题可以作为zkw线段树的练习题

我们通过观察与推理发现

对于每个作为中位数的数来说，三元上升子序列个数=之前小于它的数的个数×之后大于它的数的个数

这样我们就可以利用扫描线的思想，离散化后从左往右扫一遍，用zkw线段树统计每个点之前比它小的数的个数；清空线段树，从右往左扫一遍，用zkw线段树统计每个数之后比它大的数的个数。

最后累加即可

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int MAXN=(1<<15)-1;

int n;
int num[1<<16],larger[1<<15],smaller[1<<15];
long long ans;

struct rpg{
	int num,renum,id;
}a[30005];

bool cmp1(rpg a,rpg b){
	return a.num<b.num;
}bool cmp2(rpg a,rpg b){
	return a.id<b.id;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i].num);
		a[i].id=i;
	}
	
	sort(a+1,a+n+1,cmp1);
	a[1].renum=1;
	
	for(int i=2;i<=n;++i){
		if(a[i].num==a[i-1].num) a[i].renum=a[i-1].renum;
		else a[i].renum=a[i-1].renum+1;
	}
	
	int cnt=a[n].renum+1;
	
	sort(a+1,a+n+1,cmp2);
	
	for(int i=1;i<=n;++i){
		for(int j=MAXN+a[i].renum;j;j>>=1)
			++num[j];
		int l=MAXN,r=MAXN+a[i].renum;
		while(l^r^1){
			if(~l&1) smaller[i]+=num[l^1];
			if(r&1) smaller[i]+=num[r^1];
			l>>=1;
			r>>=1;
		}
	}
	
	memset(num,0,sizeof(num));
	
	for(int i=n;i;--i){
		for(int j=MAXN+a[i].renum;j;j>>=1)
			++num[j];
		int l=MAXN+a[i].renum,r=MAXN+cnt;
		while(l^r^1){
			if(~l&1) larger[i]+=num[l^1];
			if(r&1) larger[i]+=num[r^1];
			l>>=1;
			r>>=1;
		}
	}
	
	for(int i=1;i<=n;++i)
		ans+=smaller[i]*larger[i];
	printf("%lld\n",ans);
	return 0;
}
```

---


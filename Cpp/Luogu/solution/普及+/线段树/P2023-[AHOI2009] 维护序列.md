# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# 题解

## 作者：Mingoal (赞：75)

这题其实就是P3373【模板】线段树2，只要改动一句话就能过。我在做这题时又打了一遍，毕竟线段树不熟，打几遍都不嫌多。
写这篇题解的主要目的是相当于做一个笔记，最好能帮到大家。
因为乘的运算级别比加高，所以在做加法是不用管乘法，在做乘法时要管加法。只要理解了这点，程序就能看懂了
```cpp
#include<bits/stdc++.h>
using namespace std;
#define update tr[t].su=tr[t<<1].su+tr[t<<1|1].su;if (tr[t].su>=M) tr[t].su-=M;
//每个子程序最后都要写这句，更新tr[t].su
typedef long long ll;
const int N=100003;
struct kk{
	ll mu,su,ad;
    //mu是维护乘积的懒惰标记，su是区间和，ad是加
    //要注意su和ad的区别
}tr[N<<2];//4倍空间
int n,M,i,a[N],op,x,y,m;
ll read(){
    ll x=0;
    char ch;
    do ch=getchar();while (ch<'0'||ch>'9');
    while (ch>='0' && ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x;
}
void build(int t,int l,int r){
	tr[t].mu=1;
	if (l==r){
		tr[t].su=a[l];
		return;
	}
	int mid=l+r>>1;
	build(t<<1,l,mid);
	build(t<<1|1,mid+1,r);
	update;
}
void maintain(int t,int k){//维护su,mu和ad
	tr[t<<1].su=(tr[t<<1].su*tr[t].mu+tr[t].ad*(k+1>>1))%M;
	tr[t<<1|1].su=(tr[t<<1|1].su*tr[t].mu+tr[t].ad*(k>>1))%M;
	tr[t<<1].mu=tr[t<<1].mu*tr[t].mu%M;
	tr[t<<1|1].mu=tr[t<<1|1].mu*tr[t].mu%M;
	tr[t<<1].ad=(tr[t<<1].ad*tr[t].mu+tr[t].ad)%M;
	tr[t<<1|1].ad=(tr[t<<1|1].ad*tr[t].mu+tr[t].ad)%M;
	tr[t].mu=1;tr[t].ad=0;
}
void cheng(int t,int l,int r,ll val){
	if (x<=l && r<=y){
		tr[t].mu=tr[t].mu*val%M;
		tr[t].ad=tr[t].ad*val%M;
		tr[t].su=tr[t].su*val%M;
		return;
	}
	maintain(t,r-l+1);
	int mid=l+r>>1;
	if (x<=mid) cheng(t<<1,l,mid,val);
	if (mid<y) cheng(t<<1|1,mid+1,r,val);
	update;
}
void jia(int t,int l,int r,ll val){
	if (x<=l && r<=y){
		tr[t].ad+=val;
		if (tr[t].ad>=M) tr[t].ad-=M;
		tr[t].su=(tr[t].su+(r-l+1)*val)%M;
		return;
	}
	maintain(t,r-l+1);
	int mid=l+r>>1;
	if (x<=mid) jia(t<<1,l,mid,val);
	if (mid<y) jia(t<<1|1,mid+1,r,val);
	update;
}
ll query(int t,int l,int r){
	if (x<=l && r<=y) return tr[t].su;
	maintain(t,r-l+1);
	int mid=l+r>>1;
	ll ans=0;
	if (x<=mid) ans+=query(t<<1,l,mid);
	if (mid<y) ans+=query(t<<1|1,mid+1,r);
	if (ans>=M) ans-=M;
	update;
	return ans;
}
int main(){
	n=read();M=read();
	for (i=1;i<=n;i++) scanf("%d",&a[i]);
	build(1,1,n);
	m=read();
	while (m--){
		op=read();x=read();y=read();
		if (op==1) cheng(1,1,n,read());
		if (op==2) jia(1,1,n,read());
		if (op==3) printf("%lld\n",query(1,1,n));
	}
}
```

---

## 作者：zjy111 (赞：36)

## pt.1 前言

这是一道线段树题

而且是一道线段树裸题

### 而且是一道线段树模板题!!!

[链接 : p3373 线段树2](https://www.luogu.org/problem/P3373)

你会惊奇的发现 , 只有输入部分的一个数据的位置不一样 : 

操作总数$m$跑到数列$a[i]$后面去了而已 , 其他几乎完全一样

关于线段树 , 可以去[OI Wiki](https://oi-wiki.org/ds/seg/)康康 , 我觉得那里的图很好

-----
## pt.2 解题

不难看出 , 我们只要对这个区间进行区间修改(加 , 乘)和区间查询(求和)即可

### 2.1 建树
对于区间修改和查询 , 既然是$log$的操作 , 那么肯定是要二分的

我们知道 , 线段树将每个长度不为1的区间划分成左右两个区间递归求解 ,

把整个线段划分为一个树形结构 ,

通过合并左右两区间信息来求得该区间的信息 ,

这种数据结构可以方便的进行大部分的区间操作。

假设我们用一个数组$sum[i]$存线段树

那么我们可以以1为根节点存储1到n的和(即$sum[1]$代表1到n所有数的和)

然后再递归到其左子节点和右子节点缩小区间

(即$sum[2]$存1到n/2的和 , $sum[3]存n/2+1到n的和 , 如此类推 , 直到递归到左右端点相等为止)

由此过程可得对于线段树上每一个节点 , 要么没有儿子 , 要么有2个儿子 ,

且这两个子节点编号分别为$2*i$  (下用ls(i)代替) 和 $2*i+1$ (下用rs(i)代替) 

那么我们就可以容易的建立一棵线段树啦
```cpp
void build(ll p,ll l,ll r){//当前建立节点p , 建树区间l到r
	lll[p]=l,rrr[p]=r; //两个数组分别记录当前节点左右代表的区间
	if(l==r){ 
		sum[p]=a[l]%md; //左右端点相等 , 到达递归边界
		return;
	}
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);  //递归到它的左子
	build(rs(p),mid+1,r);  //递归到它的右子
	sum[p]=sum[ls(p)]+sum[rs(p)]%md;  //计算出当前节点的求和
}
```
----
### 2.2 区间修改
**2.2.1 懒标记**

而对于区间修改 , 我们引入了一个叫懒标记的东西

所谓懒标记 , 简单来讲 , 就是当加法操作将要从父节点传给子节点时 ,

为了节省操作 , 先将加法操作以标记的形式存着 , 

等到需要修改时在把标记下传

一个~~从OI Wiki上找的~~小故事 , 有助于理解懒标记
```
A 有两个儿子，一个是 B，一个是 C。

有一天 A 要建一个新房子，没钱。刚好过年嘛，有人要给 B 和 C 红包，
两个红包的钱数相同都是1元，然而因为 A 是父亲所以红包肯定是先塞给 A 咯~

理论上来讲 A 应该把两个红包分别给 B 和 C，
但是……缺钱嘛，A 就把红包偷偷收到自己口袋里了。

A 高兴地说：「我现在有2份红包了！我又多了2*1=2元了！哈哈哈~」

但是 A 知道，如果他不把红包给 B 和 C，那 B 和 C 肯定会不爽，
致家庭矛盾最后崩溃，所以 A 对儿子 B 和 C 说：

「我欠你们每人1份1元的红包，下次有新红包给过来的时候再给你们！
这里我先做下记录……嗯……我欠你们各1元……」

儿子 B、C 有点恼怒：「可是如果有同学问起我们我们收到了多少红包咋办？
你把我们的红包都收了，我们还怎么装？」

父亲 A 赶忙说：「有同学问起来我就会给你们的！我欠条都写好了不会不算话的！」

这样 B、C 才放了心。
```
在懒标记下传的同时需注意的点 :
- 懒标记不能重复下传 , 传完必须清零 ; 但是作为最终答案的区间和不用清零
- 懒标记下传的时候 , 由于一个节点可以对应多个原数组元素所对应的区间 , 所以传标记的时候这个区间包含了几份元素就要下传多少个标记

那么我们就可以容易的进行懒标记下传啦
```cpp
void pushdown(ll p){ //从p节点开始下传
	sum[ls(p)]=(mu[p]*sum[ls(p)]+(rrr[ls(p)]-lll[ls(p)]+1)*add[p]%md)%md; 
   //将区间和从p传递到其左子 , 下同
	sum[rs(p)]=(mu[p]*sum[rs(p)]+(rrr[rs(p)]-lll[rs(p)]+1)*add[p]%md)%md; 
   //将区间和从p传递到其右子 , 下同
	mu[ls(p)]=(mu[p]*mu[ls(p)])%md;
	mu[rs(p)]=(mu[p]*mu[rs(p)])%md;
   //乘法运算懒标记下传
	add[ls(p)]=(mu[p]*add[ls(p)]+add[p])%md;
	add[rs(p)]=(mu[p]*add[rs(p)]+add[p])%md; 
   //加法运算懒标记下传
	mu[p]=1,add[p]=0; 
   //清空懒标记(注意:由于0乘任何数都得0,所以乘法标记传为1,加法标记传为0)
}
```
---
 **2.2.2 加法和乘法的顺序**

有了懒标记 , 我们就可以在$logn$的时间里进行区间修改了

但是区间修改还有一个注意事项 , 那就是**先乘后加** , 乘法运算会影响加法运算 ,

因为如果先加后乘的话 , 在进行加法操作时 ,

还需要给乘法标记进行乘法的逆运算----除法 , 容易造成奇怪的精度损失

所以在区间乘的时候需要修改加法标记

那么我们就可以容易的写出区间加和区间乘的代码啦
```cpp
void mul(ll p,ll l,ll r,ll k){  //区间乘,p表示当前节点,l和r表示询问区间
	if(lll[p]>=l && rrr[p]<=r){ 
		add[p]*=k,add[p]%=md;
		mu[p]*=k,mu[p]%=md;
		sum[p]*=k,sum[p]%=md;
		return;  
	}// 当前区间被修改区间包含时直接修改当前节点值,然后打标记,结束修改
	pushdown(p); //传标记
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md; //求和
	ll mid=(lll[p]+rrr[p])>>1;
	if(l<=mid)mul(ls(p),l,r,k);  //递归到左子节点
	if(mid<r)mul(rs(p),l,r,k);   /递归到右子节点
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;  //再次更新节点值
}
void addd(ll p,ll l,ll r,ll k){  //区间加,和区间乘大致相同
	if(lll[p]>=l && rrr[p]<=r){
		add[p]+=k;
		add[p]%=md;
		sum[p]+=(rrr[p]-lll[p]+1)*k;
		sum[p]%=md;
		return;
	}
	pushdown(p);
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;
	ll mid=(lll[p]+rrr[p])>>1;
	if(l<=mid)addd(ls(p),l,r,k);
	if(mid<r)addd(rs(p),l,r,k);
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;
}
```
---
### 2.3 区间查询
而对于区间查询 , 我们可以通过找对应的$sum$数组的值来求和

![](https://oi-wiki.org/ds/images/segt5.png)

比如对于这幅~~从OI Wiki上copy的~~图中 , 我们可以直接找到1到3的和 , 但是找不到1到4的和

对于这种情况 , 我们只要把区间$[1,4]$看成区间$[1,3]$和区间$[4,4]$的和即可

也就是说 , 一般地 , 如果要查询的区间是$[l,r]$ ,

则可以将其拆成最多为$logn$个子区间 , 合并这些区间即可求出$[l,r]$的答案

那么我们就可以容易的进行区间查询求和啦
```cpp
ll query(ll p,ll l,ll r){  //[l,r]为查询区间,lll[p]和rrr[p]分别记录当前p节点代表的左右区间 , p为当前节点的编号
	if(lll[p]>=l && rrr[p]<=r)return sum[p]; //当前节点区间被包含时直接返回
    	pushdown(p);  //区间求和前必须把节点值更新完毕
	ll v=0,mid=(lll[p]+rrr[p])>>1; //v记录查询子区间的总和
	if(l<=mid)v+=query(ls(p),l,r),v%=md; //递归到左半边找子区间
	if(mid<r)v+=query(rs(p),l,r),v%=md;  //递归到右半边找子区间
	return v;  //返回查询区间的总和
}
```
---
## pt.3 一些注意事项

- 线段树的空间要开到一般数组的4倍 , 原因见下图
![](https://cdn.luogu.com.cn/upload/image_hosting/n6194vyl.png)
- 由于位运算比普通四则运算快 , 所以可以用$a<<1$和$a<<1|1$来代替$2a$和$2a+1$ , 用$(l+r)>>1$代替(l+r)/2 , 可适当优化线段树
- 建树时记录每个节点所对应的区间，就不需要每次计算当前节点的左右端点了，减小代码常数 (众所周知 , 线段树常数不小)
- 在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。
---
## pt.4 上代码 !
献上码风奇特的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n,m,md;
ll a[400005],sum[400005],mu[400005],add[400005],lll[400005],rrr[400005];
#define ls(x) x<<1
#define rs(x) x<<1|1
void build(ll p,ll l,ll r){
	lll[p]=l,rrr[p]=r,mu[p]=1;
	if(l==r){
		sum[p]=a[l]%md;
		return;
	}
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	sum[p]=sum[ls(p)]+sum[rs(p)]%md;
}
void pushdown(ll p){
	sum[ls(p)]=(mu[p]*sum[ls(p)]+(rrr[ls(p)]-lll[ls(p)]+1)*add[p]%md)%md;
	sum[rs(p)]=(mu[p]*sum[rs(p)]+(rrr[rs(p)]-lll[rs(p)]+1)*add[p]%md)%md;
	mu[ls(p)]=(mu[p]*mu[ls(p)])%md;
	mu[rs(p)]=(mu[p]*mu[rs(p)])%md;
	add[ls(p)]=(mu[p]*add[ls(p)]+add[p])%md;
	add[rs(p)]=(mu[p]*add[rs(p)]+add[p])%md;
	mu[p]=1,add[p]=0;
}
void addd(ll p,ll l,ll r,ll k){
	if(lll[p]>=l && rrr[p]<=r){
		add[p]+=k;
		add[p]%=md;
		sum[p]+=(rrr[p]-lll[p]+1)*k;
		sum[p]%=md;
		return;
	}
	pushdown(p);
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;
	ll mid=(lll[p]+rrr[p])>>1;
	if(l<=mid)addd(ls(p),l,r,k);
	if(mid<r)addd(rs(p),l,r,k);
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;
}
void mul(ll p,ll l,ll r,ll k){
	if(lll[p]>=l && rrr[p]<=r){
		add[p]*=k,add[p]%=md;
		mu[p]*=k,mu[p]%=md;
		sum[p]*=k,sum[p]%=md;
		return;
	}
	pushdown(p);
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;
	ll mid=(lll[p]+rrr[p])>>1;
	if(l<=mid)mul(ls(p),l,r,k);
	if(mid<r)mul(rs(p),l,r,k);
	sum[p]=(sum[ls(p)]+sum[rs(p)])%md;
}
ll query(ll p,ll l,ll r){ 
	if(lll[p]>=l && rrr[p]<=r)return sum[p];
	pushdown(p);
	ll v=0,mid=(lll[p]+rrr[p])>>1;
	if(l<=mid)v+=query(ls(p),l,r),v%=md;
	if(mid<r)v+=query(rs(p),l,r),v%=md;
	return v;
}
int main() {
	cin>>n>>md;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	build(1,1,n);
	cin>>m;
	while(m--){
		ll x,y,typ;
		scanf("%lld%lld%lld",&typ,&x,&y);
		if(typ==1){
			ll z;
			scanf("%lld",&z);
			mul(1,x,y,z);
		}else if(typ==2){
			ll z;
			scanf("%lld",&z);
			addd(1,x,y,z);
		}else printf("%lld\n",query(1,x,y));
	}
	return 0;
}

```

---

## 作者：爷，无限霸气 (赞：21)

# 又是一轮线段树

这道题应该说是一道线段树模板.[又一模板](https://www.luogu.org/problem/P3373)

在这里我们了解一下线段树


在如此序列中，1,2,3,4；

用线段树的话，我们题目中的修改就变得非常可观。比如修改1，用前缀和思路每次的修改都要记录一次（~~虽然前缀和改一次很快~~），时间复杂度变为O(n)了，不过用线段树修改，只需修改1,1-2,1-4。复杂度优化为O（logn）了，就可以开开心心的AC了！

线段树的图为：
```cpp
          1-4
         /  \
        1-2  3-4
       / \   / \
       1 2   3  4
```

## 建树操作

我们用一个数维护一段区间，记录其的左儿子和右儿子，由图我们可以知道，左儿子节点区间为：l-mid，右儿子区间为mid+1-r

有这样一种思路，建树完成！

代码：
```cpp
void build(ll p,ll l,ll r)
{
	l(p)=l,r(p)=r,mul(p)=1,add(p)=0;
	if(l==r){sum(p)=a[l];return ;}
	ll mid=(l+r)>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	sum(p)=sum(p*2)+sum(p*2+1);
	sum(p)%=h;//边算边取模
}
```

## 下传标记

这里应该比较好理解，每次都慢慢的更新即可

代码：
```cpp
void spread(ll p)
{
	if(add(p)||mul(p)!=1)
	{
		sum(p*2)=(sum(p*2)*mul(p))%h;
		sum(p*2+1)= (sum(p*2+1)*mul(p))%h;
		sum(p*2)=(sum(p*2)+add(p)*(r(p*2)-l(p*2)+1))%h;
		sum(p*2+1)=(sum(p*2+1)+add(p)*(r(p*2+1)-l(p*2+1)+1))%h;
		mul(p*2)=(mul(p*2)*mul(p))%h;
		mul(p*2+1)=(mul(p*2+1)*mul(p))%h;
		add(p*2)=(add(p*2)*mul(p))%h;
		add(p*2+1)=(add(p*2+1)*mul(p))%h;
		add(p*2)=(add(p*2)+add(p))%h;
		add(p*2+1)=(add(p*2+1)+add(p))%h;//同样是边算边取模
		add(p)=0;
		mul(p)=1;
	}
}
```
## 区间修改

1.加法修改：

把当前节点维护序列值加上左右儿子的差值在乘上当前需要修改的d即可

2.乘法修改

和加法类似，不过不需计算差值，直接乘即可

再每一次取mid，如上述情况，修改左（或右）区间即可得到

```cpp
void change(ll p,ll l,ll r,ll d,ll k)
{
	if(l<=l(p)&&r>=r(p))
	{
		if(k==2)//加法修改
		{
			sum(p)+=d*(r(p)-l(p)+1);
			add(p)+=d;
			sum(p)%=h;
			add(p)%=h;
		}
		if(k==1)//乘法修改
		{
			sum(p)*=d;
			add(p)*=d;
			mul(p)*=d;
			sum(p)%=h;
			add(p)%=h;
			mul(p)%=h;
		}
		return ;
	}
	spread(p);//下传标记
	ll mid=(l(p)+r(p))>>1;
	if(l<=mid) change(p*2,l,r,d,k);
	if(r>mid) change(p*2+1,l,r,d,k);
	sum(p)=sum(p*2)+sum(p*2+1);
	sum(p)%=h;
}
```

## 区间查询

如果当前序列已被覆盖，就直接输出当前节点的值,用ans记录答案，每次加上左（或右）区间的查询(递归即可）

代码：
```cpp
ll ask(ll p,ll l,ll r)
{
	if(l<=l(p)&&r>=r(p)) return sum(p);
	spread(p);
	ll mid=(l(p)+r(p))>>1;
	ll ans=0;
	if(l<=mid) ans+=ask(p*2,l,r);
	if(r>mid) ans+=ask(p*2+1,l,r);
	ans%=h;
	return ans;
}
```

在此，我们线段树已经基本写完，只需判断一下当前需要什么操作，change或ask一下就AC了


完整代码（~~只有自己理解了才是自己的哦！~~）
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&c!='-') c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
struct Segment
{
	ll l,r,sum,add,mul;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define add(x) tree[x].add
	#define mul(x) tree[x].mul
}tree[100010*4];
ll n,m,h,a[100010];
void build(ll p,ll l,ll r)
{
	l(p)=l,r(p)=r,mul(p)=1,add(p)=0;
	if(l==r){sum(p)=a[l];return ;}
	ll mid=(l+r)>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	sum(p)=sum(p*2)+sum(p*2+1);
	sum(p)%=h;
}
void spread(ll p)
{
	if(add(p)||mul(p)!=1)
	{
		sum(p*2)=(sum(p*2)*mul(p))%h;
		sum(p*2+1)= (sum(p*2+1)*mul(p))%h;
		sum(p*2)=(sum(p*2)+add(p)*(r(p*2)-l(p*2)+1))%h;
		sum(p*2+1)=(sum(p*2+1)+add(p)*(r(p*2+1)-l(p*2+1)+1))%h;
		mul(p*2)=(mul(p*2)*mul(p))%h;
		mul(p*2+1)=(mul(p*2+1)*mul(p))%h;
		add(p*2)=(add(p*2)*mul(p))%h;
		add(p*2+1)=(add(p*2+1)*mul(p))%h;
		add(p*2)=(add(p*2)+add(p))%h;
		add(p*2+1)=(add(p*2+1)+add(p))%h;
		add(p)=0;
		mul(p)=1;
	}
}
void change(ll p,ll l,ll r,ll d,ll k)
{
	if(l<=l(p)&&r>=r(p))
	{
		if(k==2)
		{
			sum(p)+=d*(r(p)-l(p)+1);
			add(p)+=d;
			sum(p)%=h;
			add(p)%=h;
		}
		if(k==1)
		{
			sum(p)*=d;
			add(p)*=d;
			mul(p)*=d;
			sum(p)%=h;
			add(p)%=h;
			mul(p)%=h;
		}
		return ;
	}
	spread(p);
	ll mid=(l(p)+r(p))>>1;
	if(l<=mid) change(p*2,l,r,d,k);
	if(r>mid) change(p*2+1,l,r,d,k);
	sum(p)=sum(p*2)+sum(p*2+1);
	sum(p)%=h;
}
ll ask(ll p,ll l,ll r)
{
	if(l<=l(p)&&r>=r(p)) return sum(p);
	spread(p);
	ll mid=(l(p)+r(p))>>1;
	ll ans=0;
	if(l<=mid) ans+=ask(p*2,l,r);
	if(r>mid) ans+=ask(p*2+1,l,r);
	ans%=h;
	return ans;
}
int main()
{
	n=read(),h=read();
	for(int i=1;i<=n;i++) a[i]=read();
	m=read();
	build(1,1,n);	
	for(int i=1;i<=m;i++)
	{
		ll q=read();
		if(q==1)
		{
			ll x=read(),y=read(),z=read();
			change(1,x,y,z,1);
		}
		else if(q==2){
			ll x=read(),y=read(),z=read();
			change(1,x,y,z,2);
		}
		else if(q==3){
			ll x=read(),y=read();
			printf("%lld\n",ask(1,x,y)%h);
		}
	}
	return 0;
}
```

# 线段树完结（~~撒花~~）

请多多支持（~~其实就是点赞~~）

谢谢大佬们的观看

---

## 作者：GaryZhong (赞：17)

# [AHOI2009]维护序列 题解

-----
## 题目分析

看题面可以知道题目的要求：

对于一个长度为N的序列a支持以下操作

1.令所有满足l<=i<=r的ai全部变为ai\*c。

2.令所有满足l<=i<=r的ai全部变为ai+c。

3.求所有满足l<=i<=r的ai的和。

显然这是对一个区间做加法和乘法的操作，可以使用线段树完成。

联想只有区间加法的过程，对于线段树上的一个节点，我们设sum表示该区间的和，inc表示该区间每个数要加上的数，那么该节点所表示的区间和为sum + inc \* (r - l + 1)

属于$x+b$这种形式，$(r - l + 1)$可以看作常数。

但是现在区间不仅有加法，还有乘法，因此很容易想到区间和的形式应该为：$ax+b$

表示现在的区间和是原来的区间和先乘以a再加上b。

在程序中我们把mtp定义为a，sum定义为x，inc定义为b，下传标记时节点的更新就是sum = mtp \* sum + inc


## 区间修改


当我们要修改一个区间时，要保证ax+b的形式，即先乘后加的形式。当将区间乘以一个数k时，原来的区间和为$ax+b$，乘以k得$k(ax+b)=kax+kb$，也就是把节点的inc和mtp都乘上一个k。


区间加一个数更加简单，原来的区间和为$ax+b$，加上一个k为$ax+b+k$，合并b, k得$ax+(b+k)$，也就是把原来的inc加上一个k。


## 标记下传


我们设要下传标记的节点的inc为$b$，sum为$x$，mtp为$a$，因此这个节点的和为$ax+b$，它的一个儿子的inc为$b'$，sum为$y$，mtp为$a'$，这个节点的和为$a'y+b'$，为了保持先乘后加的顺序，先把该节点的和乘以$a$得$$aa'y+ab'$$然后加上b得$$aa'y+ab'+b$$合并一下得$$(aa')y+(ab'+b)$$也就是把这个节点的儿子的mtp乘以这个节点的mtp，然后把这个节点的儿子的inc乘以这个节点的mtp再加上这个节点的inc，更新这个节点，清空这个节点的标记，然后标记就下传完毕了。


## 代码：

```cpp
#pragma GCC optimize(2) //O2优化
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define lson rt << 1 //简化书写
#define rson rt << 1 | 1

const int N = 200007; //数据范围有误，100000会RE
typedef long long ll;

int n, q, L, R, op;
ll k, P, a[N];

struct SegmentTree
{
    ll sum[N << 2], mtp[N << 2], inc[N << 2];

    void down(int rt, int l, int r)
    {
        if (mtp[rt] == 1 && inc[rt] == 0) return; //都为初始状态时无需下传
        if (l != r)
            mtp[lson] = mtp[lson] * mtp[rt] % P, //儿子的mtp乘以当前节点mtp
            mtp[rson] = mtp[rson] * mtp[rt] % P, 
            inc[lson] = (inc[lson] * mtp[rt] % P + inc[rt]) % P; //儿子的inc乘以当前节点mtp再加当前节点inc
            inc[rson] = (inc[rson] * mtp[rt] % P + inc[rt]) % P;
        sum[rt] = (sum[rt] * mtp[rt] % P + inc[rt] * (r - l + 1) % P) % P; //更新节点信息
        mtp[rt] = 1, inc[rt] = 0; //清空标记
    }

    void build(int rt, int l, int r) //根据数组构建线段树，当然打insert也是可以的
    {
        mtp[rt] = 1, inc[rt] = 0; //初始化标记
        if (l == r) { sum[rt] = a[l]; return; }
        int mid = l + r >> 1;
        build(lson, l, mid);
        build(rson, mid + 1, r);
        sum[rt] = sum[lson] + sum[rson];
    }
    
    ll qrysum(int rt, int l, int r)
    {
        down(rt, l, r); //先下传标记
        if (L <= l && r <= R) return sum[rt];
        ll ret = 0; int mid = l + r >> 1;
        if (L <= mid) ret = (ret + qrysum(lson, l, mid)) % P;
        if (mid + 1 <= R) ret = (ret + qrysum(rson, mid + 1, r)) % P;
        return ret;
    }

    void rangeplus(int rt, int l, int r)
    {
        down(rt, l, r); //先下传标记
        if (L <= l && r <= R) { inc[rt] = (inc[rt] + k) % P; return; } //区间更新，inc加上k
        int mid = l + r >> 1;
        if (L <= mid) rangeplus(lson, l, mid);
        if (mid + 1 <= R) rangeplus(rson, mid + 1, r);
        down(lson, l, mid), down(rson, mid + 1, r); //下传儿子的标记
        sum[rt] = (sum[lson] + sum[rson]) % P;
    }

    void rangemtp(int rt, int l, int r)
    {
        down(rt, l, r); //先下传标记
        if (L <= l && r <= R) { mtp[rt] = mtp[rt] * k % P, inc[rt] = inc[rt] * k % P; return; } //区间更新，mtp和inc都乘以一个k
        int mid = l + r >> 1;
        if (L <= mid) rangemtp(lson, l, mid);
        if (mid + 1 <= R) rangemtp(rson, mid + 1, r);
        down(lson, l, mid), down(rson, mid + 1, r); //下传儿子的标记
        sum[rt] = (sum[lson] + sum[rson]) % P;
    }
} tree;

inline ll read() //读入加速
{
    ll x = 0, f = 0;
    char c = getchar();
    for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = 1;
    for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + c - '0';
    return f ? -x : x;
}

void init()
{
    n = read(), P = read();
    for (int i = 1; i <= n; i++) *(a + i) = read();
    tree.build(1, 1, n);
}

void solve()
{
    q = read();
    while (q--)
    {
        op = read();
        if (op == 1)
            L = read(), R = read(), k = read(),
            tree.rangemtp(1, 1, n);
        else if (op == 2)
            L = read(), R = read(), k = read(),
            tree.rangeplus(1, 1, n);
        else
            L = read(), R = read(),
            printf("%lld\n", tree.qrysum(1, 1, n));
    }
}

int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：Yuno (赞：10)

# 分块令我块乐
此题标签是线段树，大部分题解也都是线段树。  
然而，分块也是可以过的~~虽然要吸氧~~。  
对于每个块，维护一个乘法标记和一个加法标记，看上去好像两个标记直接分开维护就可以了。  
但是，根据~~小学生都会的~~乘法分配律可知：
### (a + b) * c = ac + bc  
而我们如果直接分开维护两个标记，则会出现：
### (a + b) * c = ac + b  
显然错了。  
从上面两个式子中可以发现：
## 乘法标记是可以影响加法标记的  
## 而加法标记则不影响乘法标记  
在边角块暴力处理时，也有一个细节要注意：  
如果这个元素所在的块已经有了加法标记，而现在给它乘上一个数，显然加法标记也要乘这个数。但是肯定不能直接把加法标记乘上这个数，因为加法标记记录的是整块的信息，而现在要修改的只有这个数。所以干脆直接把这整个块都先加上标记，并把标记清零。  
乘法标记同理（但是标记要赋值成1）  
附上优（chou）美（lou）的代码：
```cpp

#include<bits/stdc++.h>
#define N 100007
#define ll long long
using namespace std;

ll a[N], sum[N], add[N], mul[N];//add为加法标记，mul为乘法标记（开 long long防止中间过程爆炸）
int block[N], l[N], r[N];

inline ll read()
{
	ll x = 0;
	char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch))
	{
		x = (x << 3) + (x << 1) + ch - 48;
		ch = getchar();
	}
	return x;
}//快读用来卡常

int main()
{
	int n = read(), p = read();
	for (int i = 1; i <= n ; i++)
	a[i] = read();
	int piece = sqrt(n);
	for (int i = 1; i <= n; i++)
	{
		if (i % piece == 0) block[i] = i / piece;
		else block[i] = i / piece + 1;
	}//把数列分成一个个块
	for (int i = 1; i <= n; i++)
	{
		if (!l[block[i]]) l[block[i]] = i;
		r[block[i]] = i;
		sum[block[i]] += a[i];
	}//计算每个块的左边界、右边界、总和
	for (int i = 1; i <= block[n]; i++)
	mul[i] = 1;//注意乘法标记初值为1
	int m = read();
	for (int i = 1; i <= m; i++)
	{
		ll pos = read(), x = read(), y = read();
		if (pos == 1)
		{
			ll c = read();
			if (block[x] == block[y])
			{
				for (int j = l[block[x]]; j <= r[block[x]]; j++)
				{
					a[j] = (a[j] * mul[block[x]] + add[block[x]]) % p;
				}
				mul[block[x]] = 1;
				add[block[x]] = 0;//清空标记
				for (int j = x; j <= y; j++)
				{
				    sum[block[x]] = sum[block[x]] - a[j];
				    a[j] = (a[j] * c) % p;
				    sum[block[x]] = (sum[block[x]] + a[j]) % p;
				}
			}
			else
			{
				for (int j = block[x] + 1; j <= block[y] - 1; j++)
				{
					mul[j] = (mul[j] * c) % p;
					add[j] = (add[j] * c) % p;
					sum[j] = (sum[j] * c) % p;
				}大段维护
				for (int j = l[block[x]]; j <= r[block[x]]; j++)
				{
					a[j] = (a[j] * mul[block[x]] + add[block[x]]) % p;
				}
				mul[block[x]] = 1;
				add[block[x]] = 0;
				for (int j = x; j <= r[block[x]]; j++)
				{
				    sum[block[x]] = sum[block[x]] - a[j];
				    a[j] = (a[j] * c) % p;
				    sum[block[x]] = (sum[block[x]] + a[j]) % p;
				}
				for (int j = l[block[y]]; j <= r[block[y]]; j++)
				{
					a[j] = (a[j] * mul[block[y]] + add[block[y]]) % p;
				}
				mul[block[y]] = 1;
				add[block[y]] = 0;
				for (int j = l[block[y]]; j <= y; j++)
				{
				    sum[block[y]] = sum[block[y]] - a[j];
				    a[j] = (a[j] * c) % p;
				    sum[block[y]] = (sum[block[y]] + a[j]) % p;
				}//小段暴力
			}
		}
		else
		if (pos == 2)
		{
			ll c = read();
			if (block[x] == block[y])
			{
				for (int j = l[block[x]]; j <= r[block[x]]; j++)
				{
					a[j] = (a[j] * mul[block[y]] + add[block[y]]) % p;
				}
				mul[block[x]] = 1;
				add[block[x]] = 0;
				for (int j = x; j <= y; j++)
				{
				    sum[block[x]] = sum[block[x]] - a[j];
				    a[j] = (a[j] + c) % p;
				    sum[block[x]] = (sum[block[x]] + a[j]) % p;
				}
			}
			else
			{
				for (int j = block[x] + 1; j <= block[y] - 1; j++)
				{
					sum[j] = (sum[j] + c * (r[j] - l[j] + 1)) % p;
					add[j] = (add[j] + c) % p;
				}
				for (int j = l[block[x]]; j <= r[block[x]]; j++)
				{
					a[j] = (a[j] * mul[block[x]] + add[block[x]]) % p;
				}
				mul[block[x]] = 1;
				add[block[x]] = 0;
				for (int j = x; j <= r[block[x]]; j++)
				{
				    sum[block[x]] = sum[block[x]] - a[j];
				    a[j] = (a[j] + c) % p;
				    sum[block[x]] = (sum[block[x]] + a[j]) % p;
				}
				for (int j = l[block[y]]; j <= r[block[y]]; j++)
				{
					a[j] = (a[j] * mul[block[y]] + add[block[y]]) % p;
				}
				mul[block[y]] = 1;
				add[block[y]] = 0;
				for (int j = l[block[y]]; j <= y; j++)
				{
				    sum[block[y]] = sum[block[y]] - a[j];
				    a[j] = (a[j] + c) % p;
				    sum[block[y]] = (sum[block[y]] + a[j]) % p;
				}
			}
		}
		else
		if (pos == 3)
		{
			if (block[x] == block[y])
			{
				ll ans = 0;
				for (int j = x; j <= y; j++)
				ans = (ans + (a[j] * mul[block[x]] + add[block[x]])) % p;
				printf("%lld\n", ans);
			}
			else
			{
				ll ans = 0;
				for (int j = block[x] + 1; j <= block[y] - 1; j++)
				ans = (ans + sum[j]) % p;
				for (int j = x; j <= r[block[x]]; j++)
				ans = (ans + (a[j] * mul[block[x]] + add[block[x]])) % p;
				for (int j = l[block[y]]; j <= y; j++)
				ans = (ans + (a[j] * mul[block[y]] + add[block[y]])) % p;
				printf("%lld\n", ans);
			}
		}
	}
	return 0;
 } 
```


---

## 作者：MashPlant (赞：7)

线段树模板题就不说了，给大家讲一个卡常数的小技巧。

很多题的模数都是在题面里面写死的，但是这道题的模数是后来输入的。不要认为都是取模没有区别。大家可以简单做个实验。
```cpp
unsigned mod5(unsigned x)
{
    return x % 5;
}
int main() {}
```
用下面的命令行编译之：(假定文件叫test.cpp)
```shell
g++ -g -c -O2 test.cpp && objdump -S test.o > test.s
```
打开test.s就会看到
```asm
mov    %edi,%eax
mov    $0xcccccccd,%edx
mul    %edx ;乘法
mov    %edx,%eax 
shr    $0x2,%eax ;移位
lea    (%rax,%rax,4),%eax ;乘法，被优化成移位
sub    %eax,%edi ;减法
mov    %edi,%eax
```
一次取模被优化成了两次乘法和一次移位和一次减法，其中第二次乘法也被优化成了移位。（顺便说一句，很多人喜欢把x\*10写成(x<<1)+(x<<3)，其实这并不是最高效的写法。最高效的写法是老老实实写x\*10然后等着编译器给你优化）

编译器之所以这样优化，是因为除法和取模相对来讲非常慢。乘法的速度和加减法在一个数量级，而除法和取模则慢一个数量级。但是这种优化仅限于除/模常数，编译器才能在编译时进行优化。这道题的模数是后输入的，编译器就没办法优化了。

所以我们可以~~放弃治疗~~自己来进行这个优化。大家可以看一下这个文章（不是我写的）。https://www.cnblogs.com/shines77/p/4189074.html

文章里讲了32位的除法怎么优化，所以我们~~随便乱搞一下~~经过严格的推理可以对64位的除法做出类似的优化。
```cpp
// 有返回值的宏，这是g++的一个拓展，可以用来当函数用
#define Mod(x)                            \
    ({                                    \
        auto __x = x;                     \
        __x - P *((__x * M) >> (64 + K)); \
    })
...
u128 M;
u32 P, K;
...
for (K = 0; P >= 1 << (K + 1); ++K)
        ;
M = ((u128)1 << (K + 64)) / P;
if (((P * M) >> (64 + K)) != 1)
    ++M;
```

以下是完整代码。804ms，目前rk1。
```cpp
#include <cstdio>
#include <cstdlib>
typedef unsigned u32;
typedef unsigned long long u64;
typedef __uint128_t u128;
#define L (u64)
#define Mod(x)                            \
    ({                                    \
        auto __x = x;                     \
        __x - P *((__x * M) >> (64 + K)); \
    })
#define Inline __attribute__((always_inline)) inline
const u32 N = 200000 + 15;
u128 M;
u32 P, K;
struct Node
{
    u32 val, add_tag, mul_tag = 1u;
} tree[N * 4];
struct IOBoost
{
    char p[1 << 24], *s, e[1 << 24], *t;
    u32 a[24];
    IOBoost() : s(p), t(e) { fread(s, 1, sizeof p, stdin); }
    ~IOBoost() { fwrite(e, 1, t - e, stdout); }
    Inline operator u32()
    {
        static u32 v;
        v = 0;
        while (*s < '0')
            ++s;
        do
            v = v * 10 + *s++ - '0';
        while (*s > ' ');
        return v;
    }
    Inline void print(u32 v)
    {
        static u32 *q = a;
        if (!v)
            *t++ = '0';
        else
        {
            while (v)
                *q++ = v % 10 + '0', v /= 10;
            while (q != a)
                *t++ = *--q;
        }
        *t++ = '\n';
    }
} io;
u32 ql, qr, qval;

void build(u32 rt, u32 l, u32 r)
{
    if (l == r)
        return void(tree[rt].val = io);
    u32 mid = l + r >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    tree[rt].val = Mod(L tree[rt << 1].val + tree[rt << 1 | 1].val);
}

Inline void push(u32 rt, u32 len)
{
    if (tree[rt].add_tag || tree[rt].mul_tag != 1u)
    {
        u32 ls = rt << 1, rs = rt << 1 | 1;
        tree[rt].val = Mod(L tree[rt].val * tree[rt].mul_tag + L tree[rt].add_tag * len);
        tree[ls].mul_tag = Mod(L tree[ls].mul_tag * tree[rt].mul_tag);
        tree[rs].mul_tag = Mod(L tree[rs].mul_tag * tree[rt].mul_tag);
        tree[ls].add_tag = Mod(L tree[ls].add_tag * tree[rt].mul_tag + tree[rt].add_tag);
        tree[rs].add_tag = Mod(L tree[rs].add_tag * tree[rt].mul_tag + tree[rt].add_tag);
        tree[rt].mul_tag = 1;
        tree[rt].add_tag = 0;
    }
}

void add(u32 rt, u32 l, u32 r)
{
    push(rt, r - l + 1);
    if (ql <= l && qr >= r)
        return void(tree[rt].add_tag = qval);
    u32 mid = l + r >> 1;
    if (ql <= mid)
        add(rt << 1, l, mid);
    if (qr >= mid + 1)
        add(rt << 1 | 1, mid + 1, r);
    push(rt << 1, mid - l + 1), push(rt << 1 | 1, r - mid);
    tree[rt].val = Mod(L tree[rt << 1].val + tree[rt << 1 | 1].val);
}

void mul(u32 rt, u32 l, u32 r)
{
    push(rt, r - l + 1);
    if (ql <= l && qr >= r)
        return void(tree[rt].mul_tag = qval);
    u32 mid = l + r >> 1;
    if (ql <= mid)
        mul(rt << 1, l, mid);
    if (qr >= mid + 1)
        mul(rt << 1 | 1, mid + 1, r);
    push(rt << 1, mid - l + 1), push(rt << 1 | 1, r - mid);
    tree[rt].val = Mod(L tree[rt << 1].val + tree[rt << 1 | 1].val);
}

u32 sum(u32 rt, u32 l, u32 r)
{
    push(rt, r - l + 1);
    if (ql <= l && qr >= r)
        return tree[rt].val;
    u32 mid = l + r >> 1, r1 = 0, r2 = 0;
    if (ql <= mid)
        r1 = sum(rt << 1, l, mid);
    if (qr >= mid + 1)
        r2 = sum(rt << 1 | 1, mid + 1, r);
    return Mod(L r1 + r2);
}

int main()
{
    u32 n, m, op;
    n = io, P = io;
    for (K = 0; P >= 1 << (K + 1); ++K)
        ;
    M = ((u128)1 << (K + 64)) / P;
    if (((P * M) >> (64 + K)) != 1)
        ++M;
    build(1, 1, n);
    m = io;
    for (u32 _ = 1; _ <= m; ++_)
    {
        op = io, ql = io, qr = io;
        switch (op)
        {
        case 1u: // mul
            qval = io;
            mul(1, 1, n);
            break;
        case 2u: // add
            qval = io;
            add(1, 1, n);
            break;
        case 3u: // sum
            io.print(sum(1, 1, n));
            break;
        }
    }
}
```

---

## 作者：Owen_codeisking (赞：5)

说实话，打了线段树2后再打这题，不得不说对线段树理解深刻多了。

为什么我那题不发呢？很简单，我不太喜欢码字，所以我来推荐一下我的神奇的代码风格（位运算+大写字符，清晰易懂）

Code Below:

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=100000+10;
ll A[maxn<<1],Sum[maxn<<3],Add[maxn<<3],Mul[maxn<<3];
ll n,s,p;

void PushUp(ll rt){Sum[rt]=(Sum[rt<<1]+Sum[rt<<1|1])%p;}//上推函数
void PushDown(ll rt,ll m)//下推函数，注意乘法优先级比加法高
{
    if(Add[rt]||Mul[rt]!=1){
        Sum[rt<<1]=(Sum[rt<<1]*Mul[rt]+Add[rt]*(m-(m>>1)))%p;
        Sum[rt<<1|1]=(Sum[rt<<1|1]*Mul[rt]+Add[rt]*(m>>1))%p;
        Add[rt<<1]=(Add[rt<<1]*Mul[rt]+Add[rt])%p;
        Add[rt<<1|1]=(Add[rt<<1|1]*Mul[rt]+Add[rt])%p;
        Mul[rt<<1]=(Mul[rt<<1]*Mul[rt])%p;
        Mul[rt<<1|1]=(Mul[rt<<1|1]*Mul[rt])%p;
        Add[rt]=0;Mul[rt]=1;
    }
}
void Build(ll l,ll r,ll rt)//建树
{
    Add[rt]=0;Mul[rt]=1;
    if(l == r){
        Sum[rt]=A[l]%p;
        return ;
    }
    ll m=(l+r)>>1;
    Build(l,m,rt<<1);
    Build(m+1,r,rt<<1|1);
    PushUp(rt);
}
void Update_mul(ll L,ll R,ll C,ll l,ll r,ll rt)//区间乘法运算
{
    PushDown(rt,(r-l+1));
    if(L <= l && r <= R){
        Sum[rt]=Sum[rt]*C;
        Sum[rt]=Sum[rt]%p;
        Mul[rt]=Mul[rt]*C;
        Mul[rt]=Mul[rt]%p;
        return ;
    }
    ll m=(l+r)>>1;
    if(L <= m) Update_mul(L,R,C,l,m,rt<<1);
    if(R > m)  Update_mul(L,R,C,m+1,r,rt<<1|1);
    PushUp(rt);
}
void Update_plu(ll L,ll R,ll C,ll l,ll r,ll rt)//区间加法运算
{
    PushDown(rt,r-l+1);
    if(L <= l && r <= R){
        Sum[rt]=(Sum[rt]+(r-l+1)*C)%p;
        Add[rt]=(Add[rt]+C)%p;
        return ;
    }
    ll m=(l+r)>>1;
    if(L <= m) Update_plu(L,R,C,l,m,rt<<1);
    if(R > m)  Update_plu(L,R,C,m+1,r,rt<<1|1);
    PushUp(rt);
}
ll Query(ll L,ll R,ll l,ll r,ll rt)//区间查询
{
    PushDown(rt,r-l+1);
    if(L <= l && r <= R){
        return Sum[rt];
    }
    ll m=(l+r)>>1,Ans=0;
    if(L <= m) Ans=(Ans+Query(L,R,l,m,rt<<1))%p;
    if(R > m)  Ans=(Ans+Query(L,R,m+1,r,rt<<1|1))%p;
    return Ans;
}
int main()//各种操作
{
    scanf("%lld%lld",&n,&p);
    for(int i=1;i<=n;i++)
        scanf("%lld",&A[i]);
    Build(1,n,1);
    scanf("%lld",&s);
    for(int i=1;i<=s;i++){
        ll t,x,y,k;
        scanf("%lld%lld%lld",&t,&x,&y);
        if(t==1){
            scanf("%lld",&k);
            Update_mul(x,y,k,1,n,1);
        }
        if(t==2) {
            scanf("%lld",&k);
            Update_plu(x,y,k,1,n,1);
        }
        if(t==3){
            printf("%lld\n",Query(x,y,1,n,1));
        }
    }
    return 0;
}
```

---

## 作者：1010_ (赞：3)

### 还没有zkw线段树的版本，我来上一发
如果不会线段树的lazy标记可以参考楼下题解
详细的请看博客[zkw之lazy标记](https://www.cnblogs.com/czx-1010/articles/9679412.html)

__坑点:区间乘法运算和加法需要自定运算优先级,否则标记会互相影响,本人是先乘后加版的,先加后乘比较难写,还要用逆元,模数不是质数就不可做__

```C++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9') ch=='-'&&(f=-1),ch=getchar();
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;
}
const int N=1e5+10;
int n,P;
struct ZKW_Tree
{
	int m,sta[32];
	int t[N<<2],ad[N<<2],mu[N<<2],len[N<<2];//zkw线段树有2*m个节点,m最多有2*n;
	void mod(int&x){if (x>=P)x-=P;}
	void updata(int p){t[p]=t[p<<1]+t[p<<1|1];mod(t[p]);}//更新节点；
	void upper(int p){while (p) updata(p),p>>=1;}
	void build()//建zkw线段树
	{
		for (m=1;m<n;m<<=1);--m;
		for (int i=1;i<=n;++i) t[i+m]=read()%P,len[i+m]=1;
		for (int i=m;i;--i) 
		{
			updata(i);mu[i]=1;
			len[i]=len[i<<1]+len[i<<1|1];mod(len[i]);
		}
	}
	void add_tag(int x,int v){t[x]=(t[x]+1ll*len[x]*v)%P;ad[x]+=v;mod(ad[x]);}//打加标记
	void mul_tag(int x,int v){t[x]=1ll*t[x]*v%P,mu[x]=1ll*mu[x]*v%P,ad[x]=1ll*ad[x]*v%P;}//打乘标记
	void pushdown(int x)//标记下传
	{
		if (mu[x]!=1)	mul_tag(x<<1,mu[x]),mul_tag(x<<1|1,mu[x]),mu[x]=1;
		if (ad[x])		add_tag(x<<1,ad[x]),add_tag(x<<1|1,ad[x]),ad[x]=0;
	}
	void push(int x)//模拟普通线段树标记下传
	{
		int top=0;
		while (x) sta[++top]=x,x>>=1;
		while (top>1) pushdown(sta[top--]);
	}
	int query(int l,int r)//区间求和
	{
		int su=0;
		for (l=l+m-1,r=r+m+1,push(l),push(r);l^r^1;l>>=1,r>>=1)
		{
			if (~l&1)	su+=t[l^1],mod(su);
			if (r&1)	su+=t[r^1],mod(su);
		}
		return su;
	}
	void add(int l,int r,int z)//区间加法
	{
		for (l=l+m-1,r=r+m+1,push(l),push(r);l^r^1;l>>=1,r>>=1,updata(l),updata(r))
		{
			if (~l&1)	add_tag(l^1,z);
			if (r&1)	add_tag(r^1,z);
		}
		upper(l>>1);
	}
	void mul(int l,int r,int z)//区间乘法
	{
		for (l=l+m-1,r=r+m+1,push(l),push(r);l^r^1;l>>=1,r>>=1,updata(l),updata(r))
		{
			if (~l&1)	mul_tag(l^1,z);
			if (r&1)	mul_tag(r^1,z);
		}
		upper(l>>1);
	}
}ST;
int main()
{
	n=read(),P=read();
	ST.build();
	for (int i=0,mode,x,y,z,q=read();i<q;++i)
	{
		mode=read();
		if (mode==1)x=read(),y=read(),z=read(),ST.mul(x,y,z%P);
		else if (mode==2) x=read(),y=read(),z=read(),ST.add(x,y,z%P);
		else x=read(),y=read(),printf("%d\n",ST.query(x,y));
	}
	return 0;
}
```

---

## 作者：mydiplomacy (赞：3)

题目要求维护一个序列，进行区间加、区间乘、区间查询和。很容易想到线段树，需要类似lazyj添加一个lazyc，用以记录这个区间被一起乘了多少。

##### lazyc的pushdown(在下放lazyc时需要同时下放lazyj，另外需注意lazyc的初始化是1不是0):
```cpp
t[id<<1].lazyc=(t[id<<1].lazyc*t[id].lazyc)%mod;//下放lazyc
t[id<<1].lazyj=((t[id<<1].lazyj*t[id].lazyc)%mod+t[id].lazyj)%mod;//下放lazyj，记得lazyj也需要翻lazyc倍
t[id<<1|1].lazyc=(t[id<<1|1].lazyc*t[id].lazyc)%mod;
t[id<<1|1].lazyj=((t[id<<1|1].lazyj*t[id].lazyc)%mod+t[id].lazyj)%mod;
t[id].lazyj=0;
t[id].lazyc=1;
```

##### lazyc的pushup：
```cpp
t[id].sum=((t[id*2].sum*t[id*2].lazyc)%mod+t[id<<1].lazyj*(t[id<<1].right-t[id<<1].left+1)%mod)%mod
               +((t[id<<1|1].sum*t[id<<1|1].lazyc)%mod+t[id<<1|1].lazyj*(t[id<<1].right-t[id<<1].left+1)%mod)%mod;
```
需要特别注意的是加和乘的优先级问题。注意维护lazyc的时候不用考虑lazyj（乘法优先级高），但维护lazyj的时候要*=lazyc

附完整代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int mod;
int n,m;
const int maxn=150000;
struct Node //结构体版
{
       int left,right;
       long long lazyj,lazyc;
       long long sum;
}t[maxn*2];
long long a[maxn];
void buildtree() //递推建树
{
     int ln=1;
     while(ln<n) ln*=2;
     for(int id=ln;id<ln*2;id++)
     {
             t[id].left=t[id].right=id-ln+1;
             t[id].lazyj=0;
             t[id].lazyc=1;
             t[id].sum=a[id-ln+1];
     }
     for(int id=ln-1;id>=1;id--)
     {
             t[id].left=t[id<<1].left;
             t[id].right=t[id<<1|1].right;
             t[id].sum=t[id<<1].sum+t[id<<1|1].sum;
             t[id].lazyj=0;
             t[id].lazyc=1;
     }
}
long long query(int id,int l,int r) //查询
{
     if(t[id].left==l && t[id].right==r) //边界条件
     {
            // cout << "end query"<<endl;
            return ((t[id].sum*t[id].lazyc)%mod+t[id].lazyj*(t[id].right-t[id].left+1)%mod)%mod;
     }
     if(t[id].lazyj!=0||t[id].lazyc!=1) //pushdown
     {
            t[id<<1].lazyc=(t[id<<1].lazyc*t[id].lazyc)%mod;
            t[id<<1].lazyj=((t[id<<1].lazyj*t[id].lazyc)%mod+t[id].lazyj)%mod;
            t[id<<1|1].lazyc=(t[id<<1|1].lazyc*t[id].lazyc)%mod;
            t[id<<1|1].lazyj=((t[id<<1|1].lazyj*t[id].lazyc)%mod+t[id].lazyj)%mod;
            t[id].sum=((t[id].sum*t[id].lazyc)%mod+t[id].lazyj*(t[id].right-t[id].left+1)%mod)%mod;
            t[id].lazyj=0;
            t[id].lazyc=1;
     }
     if(r<=t[id<<1].right)
     {
          
         return query(id*2,l,r);
         }
     else if(l>=t[id<<1|1].left)         
         return query(id<<1|1,l,r);
     else
     {
         return (query(id<<1,l,t[id<<1].right)+
         query(id<<1|1,t[id<<1|1].left,r))%mod;
         
     }     
}
void change(int id,int l,int r,int c,int flag)
{
     if(t[id].left==l && t[id].right==r)
     {
		// cout<<"OK"<<endl;
        if(flag==1)
        {
            t[id].lazyj=(t[id].lazyj*c)%mod;
            t[id].lazyc=(t[id].lazyc*c)%mod;
        }
        else if(flag==2)
        {
            t[id].lazyj=(t[id].lazyj+c)%mod;
        }
        return;
     }
     if(t[id].lazyj!=0||t[id].lazyc!=1)
     {
            t[id<<1].lazyc=(t[id<<1].lazyc*t[id].lazyc)%mod;
            t[id<<1].lazyj=((t[id<<1].lazyj*t[id].lazyc)%mod+t[id].lazyj)%mod;
            t[id<<1|1].lazyc=(t[id<<1|1].lazyc*t[id].lazyc)%mod;
            t[id<<1|1].lazyj=((t[id<<1|1].lazyj*t[id].lazyc)%mod+t[id].lazyj)%mod;
            t[id].lazyj=0;
            t[id].lazyc=1;
     }
     if(r<=t[id<<1].right)
     {
         change(id*2,l,r,c,flag);
        // cout<<l<<" "<<r<<endl;   
     }
     else if(l>=t[id<<1|1].left)
     {
         change(id<<1|1,l,r,c,flag);
         //cout<<l<<" "<<r<<endl;
     }
     else
     {
         change(id<<1,l,t[id<<1].right,c,flag);
         change(id<<1|1,t[id<<1|1].left,r,c,flag);
         //cout<<r<<" "<<c<<endl;
     }
     t[id].sum=((t[id*2].sum*t[id*2].lazyc)%mod+t[id<<1].lazyj*(t[id<<1].right-t[id<<1].left+1)%mod)%mod
               +((t[id<<1|1].sum*t[id<<1|1].lazyc)%mod+t[id<<1|1].lazyj*(t[id<<1].right-t[id<<1].left+1)%mod)%mod; //pushup
     
}
int main()
{
    cin>>n>>mod;
    for(int i=1;i<=n;i++) cin>>a[i];
    buildtree();
    int m; cin>>m;
    for(int i=1;i<=m;i++)
    {
    	int opt,x,y,c;
    	cin>>opt>>x>>y;
    	if(opt==1 || opt==2)
    	{
    		cin>>c;
    		change(1,x,y,c,opt);
        }
        else
        {
        	cout<<query(1,x,y)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：cenbinbin (赞：3)

下面也没有什么pascal的程序，作为p党的我，就为大家作主点贡献。

至于这道题嘛，乍一看，很明显是一个线段树，

线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组）


线段树裸题，拿来当模板……

两个标记，一个记录乘，另一个记录加，然后规定好先乘后加，就可以像普通的带标记的线段树一样维护了。

线段树是个神奇的算法，希望大家好好学学。。。

=======================================================================================


```cpp
type
  tree=record
     l,r,sum,mul,plus:longint;   //sum区间和，mul乘标记，plus加标记
  end;
var
  n,m,p,i,t,x,y,d:longint;
  a:array[0..400040]of tree;
  num:array[0..100010]of longint;
procedure build(k,l,r:longint);        //建树
var
  i,mid:longint;
begin
   a[k].l:=l;a[k].r:=r;a[k].mul:=1;a[k].plus:=0;
   if l=r then begin a[k].sum:=num[l];exit; end;
   i:=k<<1;mid:=(l+r)>>1;
   build(i,l,mid);
   build(i+1,mid+1,r);
   a[k].sum:=a[i].sum+a[i+1].sum;
end;
procedure pushdown(k:longint);   //标记下传
var
  i:longint;
begin
   if (a[k].mul=1) and (a[k].plus=0) then exit;
   if a[k].l=a[k].r then begin a[k].mul:=1;a[k].plus:=0;exit; end;
   i:=k<<1;
   a[i].sum:=(a[i].sum*a[k].mul+a[k].plus*(a[i].r-a[i].l+1)) mod p;
   a[i+1].sum:=(a[i+1].sum*a[k].mul+a[k].plus*(a[i+1].r-a[i+1].l+1)) mod p;
   a[i].mul:=a[i].mul*a[k].mul mod p;
   a[i].plus:=(a[i].plus*a[k].mul+a[k].plus) mod p;
   a[i+1].mul:=a[i+1].mul*a[k].mul mod p;
   a[i+1].plus:=(a[i+1].plus*a[k].mul+a[k].plus) mod p;
   a[k].mul:=1;a[k].plus:=0;
end;
procedure changemul(k:longint);   //乘法修改
var
  i,mid:longint;
begin
   pushdown(k);
   if (x<=a[k].l) and (a[k].r<=y) then
       begin
          a[k].sum:=a[k].sum*d mod p;
          a[k].mul:=d mod p;
          exit;
       end;
   mid:=(a[k].l+a[k].r)>>1;i:=k<<1;
   if x<=mid then changemul(i);
   if mid<y then changemul(i+1);
   a[k].sum:=(a[i].sum+a[i+1].sum) mod p;
end;
procedure changeplus(k:longint);   //加法修改
var
  i,mid:longint;
begin
   pushdown(k);
   if (x<=a[k].l) and (a[k].r<=y) then
       begin
          a[k].sum:=(a[k].sum+d*(a[k].r-a[k].l+1)) mod p;
          a[k].plus:=d mod p;
          exit;
       end;
   mid:=(a[k].l+a[k].r)>>1;i:=k<<1;
   if x<=mid then changeplus(i);
   if mid<y then changeplus(i+1);
   a[k].sum:=(a[i].sum+a[i+1].sum) mod p;
end;
function ask(k:longint):longint;   //询问
var
  i,mid:longint;
begin
   pushdown(k);
   if (x<=a[k].l) and (a[k].r<=y) then exit(a[k].sum);
   ask:=0;
   mid:=(a[k].l+a[k].r)>>1;i:=k<<1;
   if x<=mid then ask:=ask(i);
   if mid<y then ask:=ask+ask(i+1);
   exit(ask mod p);
end;
begin
   //assign(input,'r.in');assign(output,'r.out');reset(input);rewrite(output);
   readln(n,p);
   for i:=1 to n do read(num[i]);
   readln(m);
   build(1,1,n);
   //for i:=1 to 10 do writeln(a[i].l,' ',a[i].r,' ',a[i].sum,' ',a[i].mul,' ',a[i].plus);writeln;
   for i:=1 to m do
       begin
          read(t,x,y);
          if t=1 then begin read(d);changemul(1); end;
          if t=2 then begin read(d);changeplus(1); end;
          if t=3 then writeln(ask(1));
       end;
   //close(input);close(output);
end.

```

---

## 作者：sunzh (赞：2)

# [AHOI2009]维护序列题解
其实就是 ~~【模板】线段树2~~
### 下面介绍几种线段树的基本操作
- 建树

res[p]表示它的所有叶子节点的值的和
根据二叉树的性质可得节点p的左儿子是p×2,即(p<<1),右儿子是p×2+1,即(p<<1|1)
```cpp
void build(int p,int l,int r){
	tagadd[p]=0;
	tagmul[p]=1;
	if(l==r){
		res[p]=a[l];
		return ;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);//更新根节点的值
}
```
- 下放懒标记
#### 为什么要懒标记？
由于我们要做的操作是区间加一个数或乘一个数，所以我们不妨在区间进行修改时为该区间打上一个标记，就不必再修改他的儿子所维护区间，等到要使用该节点的儿子节点维护的值时，再将懒标记下放即可，可以节省很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间

用tagadd[p]表示p对应的区间内的每一个树都要加上tagadd[p],
tagmul[p]表示乘
```cpp
void pushdown(int p,int l,int r){
	int mid=l+r>>1;
	res[p<<1]=(res[p<<1]*tagmul[p]+tagadd[p]*(mid-l+1))%mod;
	res[p<<1|1]=(res[p<<1|1]*tagmul[p]+tagadd[p]*(r-mid))%mod;//下方懒标记，更新子树的值
	tagmul[p<<1]=(tagmul[p<<1]*tagmul[p])%mod;
	tagadd[p<<1]=(tagadd[p<<1]*tagmul[p]+tagadd[p])%mod;
	tagmul[p<<1|1]=(tagmul[p<<1|1]*tagmul[p])%mod;
	tagadd[p<<1|1]=(tagadd[p<<1|1]*tagmul[p]+tagadd[p])%mod;
	tagmul[p]=1;
	tagadd[p]=0;//清空根节点的懒标记，处理子节点的懒标记
}
```
- 区间加法
```cpp
void add(int p,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		res[p]+=k*(r-l+1);
		res[p]%=mod;
		tagadd[p]=(tagadd[p]+k)%mod;
		return ;
	}
	int mid=l+r>>1;
	pushdown(p,l,r);
	if(mid>=L) add(p<<1,l,mid,L,R,k);
	if(mid<R) add(p<<1|1,mid+1,r,L,R,k);//保证区间内涵盖需要处理的节点
	pushup(p);
}
```
- 区间乘法
### 注意
一个区间做乘法，区间内待加的数也是区间内的数，也要乘k
```cpp
void mul(int p,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		res[p]*=k;
		res[p]%=mod;
		tagmul[p]=(tagmul[p]*k)%mod;
		tagadd[p]=(tagadd[p]*k)%mod;
		return ;
	}
	int mid=l+r>>1;
	pushdown(p,l,r);
	if(mid>=L) mul(p<<1,l,mid,L,R,k);
	if(mid<R) mul(p<<1|1,mid+1,r,L,R,k);
	pushup(p);
}
```
- 查找
```cpp
long long query(int p,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		return res[p];
	}
	long long ans=0;
	int mid=l+r>>1;
	pushdown(p,l,r);
	if(mid>=L) ans+=query(p<<1,l,mid,L,R);
	if(mid<R) ans+=query(p<<1|1,mid+1,r,L,R);//求和
	pushup(p);
	return ans%mod;
}
```
### 下面贴代码 
~~其实就是组合起来~~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,mod;//mod范围大，记得开long long
long long a[100010];
long long res[400010],tagadd[400010],tagmul[400010];
void pushup(int p){
	res[p]=(res[p<<1]+res[p<<1|1])%mod;
}
void pushdown(int p,int l,int r){
	int mid=l+r>>1;
	res[p<<1]=(res[p<<1]*tagmul[p]+tagadd[p]*(mid-l+1))%mod;
	res[p<<1|1]=(res[p<<1|1]*tagmul[p]+tagadd[p]*(r-mid))%mod;
	tagmul[p<<1]=(tagmul[p<<1]*tagmul[p])%mod;
	tagadd[p<<1]=(tagadd[p<<1]*tagmul[p]+tagadd[p])%mod;
	tagmul[p<<1|1]=(tagmul[p<<1|1]*tagmul[p])%mod;
	tagadd[p<<1|1]=(tagadd[p<<1|1]*tagmul[p]+tagadd[p])%mod;
	tagmul[p]=1;
	tagadd[p]=0;
}
void build(int p,int l,int r){
	tagadd[p]=0;
	tagmul[p]=1;
	if(l==r){
		res[p]=a[l];
		return ;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);
}
void add(int p,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		res[p]+=k*(r-l+1);
		res[p]%=mod;
		tagadd[p]=(tagadd[p]+k)%mod;
		return ;
	}
	int mid=l+r>>1;
	pushdown(p,l,r);
	if(mid>=L) add(p<<1,l,mid,L,R,k);
	if(mid<R) add(p<<1|1,mid+1,r,L,R,k);
	pushup(p);
}
void mul(int p,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R){
		res[p]*=k;
		res[p]%=mod;
		tagmul[p]=(tagmul[p]*k)%mod;
		tagadd[p]=(tagadd[p]*k)%mod;
		return ;
	}
	int mid=l+r>>1;
	pushdown(p,l,r);
	if(mid>=L) mul(p<<1,l,mid,L,R,k);
	if(mid<R) mul(p<<1|1,mid+1,r,L,R,k);
	pushup(p);
}
long long query(int p,int l,int r,int L,int R){
	if(l>=L&&r<=R){
		return res[p];
	}
	long long ans=0;
	int mid=l+r>>1;
	pushdown(p,l,r);
	if(mid>=L) ans+=query(p<<1,l,mid,L,R);
	if(mid<R) ans+=query(p<<1|1,mid+1,r,L,R);
	pushup(p);
	return ans%mod;
}
inline long long read(){//水一波快读
	long long x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x*f;
}
int main(){
	n=read(),mod=read();
	for(int i=1;i<=n;i++) a[i]=read();
	m=read();
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int a;
		scanf("%d",&a);
		long long l=read(),r=read();
		switch(a){
			case 1:{
				long long k=read();
				mul(1,1,n,l,r,k);
				break;
			}
			case 2:{
				long long k=read();
				add(1,1,n,l,r,k);
				break;
			}
			case 3:{
				printf("%lld\n",query(1,1,n,l,r));
				break;
			}
		}
	}
	return 0;
}
 ```
##### ~~蒟蒻CSP后的第一篇题解求管理员通过~~

---

## 作者：FifthAxiom (赞：2)

模板题双倍经验？？？

这一题和线段树2基本上是一模一样的，但是推荐大家多写几遍，对线段树的使用更加熟练

此外，推荐使用结构体指针构建线段树，因为有些毒瘤题会让你的线段树不是堆式的。。。所以用链式存储就相当有必要了

其余的写在代码里~

```cpp
#include <cstdio>

#define ll long long

const int MAXN = 1000000 + 10;

struct Node {
    int l, r;//表示结点区间端点
    ll sum, lazyS, lazyM;//区间和，加法标记和乘法标记
    Node *lc, *rc;//该节点的左子节点和右子节点
} tree[MAXN << 2], *root;//数组模拟链表和根节点的位置

int a[MAXN], n, m, cnt;
ll mod;

void build(Node *p, int l, int r) {//建树
    p->l = l;
    p->r = r;
    p->lazyM = 1;//注意，一定要把乘法标记在建树时就赋值为1
    if (l == r){
        p->sum = a[l] % mod;
        return;
    } 
    int mid = (l + r) / 2;
    Node *lson = &tree[++cnt];
    Node *rson = &tree[++cnt];
    p->lc = lson;
    p->rc = rson;
    build(p->lc, l, mid);
    build(p->rc, mid + 1, r);
    p->sum = (p->lc->sum + p->rc->sum) % mod;
}

void pushDown(Node *p) {//标记的下传，这里是先乘后加，记得左右子节点加法和乘法标记都要乘该节点乘法标记
        p->lc->sum = (p->lc->sum * p->lazyM + p->lazyS * (p->lc->r - p->lc->l + 1)) % mod;
        p->rc->sum = (p->rc->sum * p->lazyM + p->lazyS * (p->rc->r - p->rc->l + 1)) % mod;
        p->lc->lazyM = p->lc->lazyM * p->lazyM % mod;
        p->lc->lazyS = (p->lc->lazyS * p->lazyM + p->lazyS) % mod;
        p->rc->lazyM = p->rc->lazyM * p->lazyM % mod;
        p->rc->lazyS = (p->rc->lazyS * p->lazyM + p->lazyS) % mod;
        p->lazyS = 0;
        p->lazyM = 1;
}

void mulChange(Node *p, int l, int r, ll mul) {//区间乘的操作
    if (l <= p->l && r >= p->r) {
        p->sum = p->sum * mul % mod;
        p->lazyS = (p->lazyS * mul) % mod;
        p->lazyM = (p->lazyM * mul) % mod;
        return;
    }
    pushDown(p);
    int mid = (p->l + p->r) / 2;
    if (l <= mid) mulChange(p->lc, l, r, mul);
    if (r > mid) mulChange(p->rc, l, r, mul);
    p->sum = (p->lc->sum + p->rc->sum) % mod;
}

void addChange(Node *p, int l, int r, ll add) {//区间加的操作
    if (l <= p->l && r >= p->r) {
        p->sum = (p->sum + add * (p->r - p->l + 1)) % mod;
        p->lazyS = (p->lazyS + add) % mod;
        return;
    }
    pushDown(p);
    int mid = (p->l + p->r) / 2;
    if (l <= mid) addChange(p->lc, l, r, add);
    if (r > mid) addChange(p->rc, l, r, add);
    p->sum = (p->lc->sum + p->rc->sum) % mod;
}

ll query(Node *p, int l, int r) {//查询区间和
    if (l <= p->l && r >= p->r) return p->sum % mod;
    pushDown(p);
    int mid = (p->l + p->r) / 2;
    ll val = 0;
    if (l <= mid) val = (val + query(p->lc, l, r)) % mod;
    if (r > mid) val = (val + query(p->rc, l, r)) % mod;
    return val % mod;
}

int main() {
    scanf("%d %d", &n, &mod);
    for (int i = 1; i <= n; i++) scanf("%d", a + i);
    scanf(" %d", &m);
    root = &tree[0];
    build(root, 1, n);
    while (m--) {
        int x, l = 0, r = 0;
        ll k = 0;
        scanf("%d", &x);
        if (x == 1) {
            scanf(" %d %d %lld", &l, &r, &k);
            mulChange(root, l, r, k);
        } else if (x == 2) {
            scanf(" %d %d %lld", &l, &r, &k);
            addChange(root, l, r, k);
            } else {
                scanf("%d %d", &l, &r);
                printf("%lld\n", query(root, l, r) % mod);
            }
    }
    return 0;
}
```

线段树的惰性标记也是线段树最优美的地方之一，相信码完此题，你一定会对线段树标记的理解上一个档次。

---

## 作者：YuntianZhao (赞：1)

# P2025

这是一篇指针版线段树题解。

其实就是一个线段树模板，记得要维护两个 lazytag ，这里我用 tag_add 表示加法意义上的 lazytag ，用 tag_mul 表示乘法意义上的 lazytag 。

对于 tag_add 很明显最开始的时候是 0 ，而对于tag_mul 最开始的时候是 1 。

分别讨论 getdata 操作， pushdown操纵，update 操作中的 lazytag 的变化。我们发现对于区间乘， $tag \_ mul = tag \_ mul \times dv \_ mul$ ， 而对于区间加就较为复杂 $tag \_ add = tag \_ add \times dv \_ mul + dv \_ add$ 。

个人比较推荐指针版的线段树是因为可以动态的 new 出节点，可以不用想四倍内存的事。

完整代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int maxn = 1e5 + 5;

int n, m, k;
int mod;
int a[maxn];

struct Node {
  int l, r;
  ll tag_add, tag_mul, d;
  Node *ls, *rs;
  Node(int l = 0, int r = 0):
      l(l), r(r), d(0), tag_add(0), tag_mul(1), ls(NULL), rs(NULL) {};
}; 

Node *root;

Node *build(int l, int r) {
  Node *p = new Node(l, r);
  if (l == r) {
    p->d = a[l] % mod;
    return p;
  }
  int mid = (l + r) / 2;
  p->ls = build(l, mid);
  p->rs = build(mid + 1, r);
  p->d = p->ls->d + p->rs->d;
  p->d %= mod;
  return p;
}

ll getD(Node *p) {
  return (p->d * p->tag_mul + p->tag_add * (p->r - p->l + 1)) % mod;
} 

void pushdown(Node *p) {
  if (p->tag_add == 0 && p->tag_mul == 1) return;
  p->d = getD(p);
  p->ls->tag_add = p->ls->tag_add * p->tag_mul + p->tag_add;
  p->ls->tag_add %= mod;
  p->rs->tag_add = p->rs->tag_add * p->tag_mul + p->tag_add;
  p->rs->tag_add %= mod;
  p->ls->tag_mul *= p->tag_mul;
  p->ls->tag_mul %= mod;
  p->rs->tag_mul *= p->tag_mul;
  p->rs->tag_mul %= mod;
  p->tag_add = 0;
  p->tag_mul = 1;
}

void update(Node *p, int l, int r, ll dv_add, ll dv_mul) {
  if (p->l == l && p->r == r) {
    p->tag_add = p->tag_add * dv_mul + dv_add;
    p->tag_add %= mod;
    p->tag_mul *= dv_mul;
    p->tag_mul %= mod;
    return;
  }
  pushdown(p);
  if (p->ls->r >= r) {
    update(p->ls, l, r, dv_add, dv_mul);
  } else if (p->rs->l <= l) {
    update(p->rs, l, r, dv_add, dv_mul);
  } else {
    update(p->ls, l, p->ls->r, dv_add, dv_mul);
    update(p->rs, p->rs->l, r, dv_add, dv_mul);
  }
  p->d = getD(p->ls) + getD(p->rs);
  p->d %= mod;
}

ll query(Node *p, int l, int r) {
  if (p->l == l && p->r == r) {
    return getD(p);
  }
  pushdown(p);
  if (p->ls->r >= r) {
    return query(p->ls, l, r);
  } else if (p->rs->l <= l) {
    return query(p->rs, l, r);
  } else {
    ll ret = 0;
    ret += query(p->ls, l, p->ls->r);
    ret += query(p->rs, p->rs->l, r);
    return ret;
  }
}

int main() {
  scanf("%d%d", &n, &mod);
  int v;
  for (int i = 1; i <= n; i++) {
    scanf("%d", &v);
    a[i] = v;
  }
  root = build(1, n);
  scanf("%d", &m);
  int opt, x, y;
  ll dv;
  for (int i = 1; i <= m; i++) {
    scanf("%d%d%d", &opt, &x, &y);
    switch (opt) {
      case 1:
        scanf("%lld", &dv);
        update(root, x, y, 0, dv);
        break;
      case 2:
        scanf("%lld", &dv);
        update(root, x, y, dv, 1);
        break;
      case 3:
        ll ret = query(root, x, y) % mod;
        printf("%lld\n", ret);
        break;
    }
  }
  return 0;
}


```

(每天线段树，健康又长寿)

---

## 作者：封禁用户 (赞：1)

博客食用更佳：http://www.cinema000.xyz/998.ruby
## 背景
可能是我的写法太$DT$了，然后$int64$都溢出了，所以我就用了 __$int128$，当然$NOIP$不能用这玩意。
## 分析
就是线段树区间乘，区间加，查询区间和
关于怎样传标记他们说的很清楚。
其实我还是很好奇为啥我int64会溢出。
## 代码
$int128$需要手动写输入输出$I/O$，就是一个快读快输就好了。
```cpp
#include<cstdio>

typedef __int128 int128;
const int128 MAXN = 1000000 + 6;
int128 MOD,A[MAXN];

inline int128 read(){
	int128 op = 1,ans = 0;char s = getchar();
	while(s < '0' || s > '9'){if(s == '-'){op = -1;}s = getchar();}
	while(s >= '0' && s <= '9'){ans = ans * 10 + s - '0';s = getchar();}
	return ans *= op;
}
void print(int128 x){
	if(x < 0){putchar('-');x = -x;}
	if(x > 9){print(x / 10);}
	putchar(x % 10 + '0');
}
void println(int128 x){print(x);putchar('\n');}

class SegmentTree{
	public:int128 l,r;
	public:int128 sum,add,mul;
};SegmentTree t[MAXN * 4];

inline int128 L(int128 x){return x << 1;}
inline int128 R(int128 x){return x << 1 | 1;}
inline void maintain(int128 p){t[p].sum = (t[L(p)].sum + t[R(p)].sum) % MOD;}

void build(int128 p,int128 l,int128 r){
	t[p].l = l;t[p].r = r;
	t[p].add = 0;t[p].mul = 1;
	if(l == r){t[p].sum = A[l];return;}
	int128 mid = (l + r) >> 1;
	build(L(p),l,mid);
	build(R(p),mid + 1,r);
	maintain(p);
}

inline void spread(int128 p){
	int128 mid = (t[p].l + t[p].r) >> 1;
	t[L(p)].sum = (t[L(p)].sum * t[p].mul + t[p].add * (mid - t[p].l + 1)) % MOD;
	t[R(p)].sum = (t[R(p)].sum * t[p].mul + t[p].add * (t[p].r - mid)) % MOD;
	t[L(p)].mul = (t[L(p)].mul * t[p].mul) % MOD;
	t[R(p)].mul = (t[R(p)].mul * t[p].mul) % MOD;
	t[L(p)].add = (t[L(p)].add * t[p].mul + t[p].add) % MOD;
	t[R(p)].add = (t[R(p)].add * t[p].mul + t[p].add) % MOD;
	t[p].mul = 1;t[p].add = 0;
}

void change(int128 p,int128 l,int128 r,int128 d,bool op){
	if(op == true){//mul
		if(l <= t[p].l && r >= t[p].r){
			t[p].add = t[p].add * d;
			t[p].mul = t[p].mul * d;
			t[p].sum = t[p].sum * d;
			return;
		}
		spread(p);
		int128 mid = (t[p].l + t[p].r) >> 1;
		if(l <= mid) change(L(p),l,r,d,op);
		if(r > mid) change(R(p),l,r,d,op);
		maintain(p);
	}else{
		if(l <= t[p].l && r >= t[p].r){
			t[p].add = t[p].add + d;
			t[p].sum = (t[p].sum + d * (t[p].r - t[p].l + 1));
			return;
		}
		spread(p);
		int128 mid = (t[p].l + t[p].r) >> 1;
		if(l <= mid) change(L(p),l,r,d,op);
		if(r > mid) change(R(p),l,r,d,op);
		maintain(p);
	}
}

int128 ask(int128 p,int128 l,int128 r){
	if(l <= t[p].l && r >= t[p].r) return t[p].sum;
	spread(p);
	int128 ans = 0,mid = (t[p].l + t[p].r) >> 1;
	if(l <= mid) ans += ask(L(p),l,r);
	if(r > mid) ans += ask(R(p),l,r);
	return ans;
}

int main(){
	int128 n = read();MOD = read();
	for(int128 i = 1;i <= n;i++) A[i] = read();
	build(1,1,n);
	int128 m = read(),op,l,r;int128 d;
	while(m--){
		op = read(),l = read(),r = read();
		if(op == 1) d = read(),change(1,l,r,d,true);
		else if(op == 2) d = read(),change(1,l,r,d,false);
		else println(ask(1,l,r) % MOD);
	}
	
	return 0;
}
```

---

## 作者：QWsin (赞：1)

**
这道题对于只见过加法tag的人很有帮助= =

因为tag可以打两个！！！！（四则运算好像只有乘加两种tag？（大雾））

一开始打两个tag，一个乘法tag，一个加法tag

注意了赋初值的时候乘法tag要赋成1 = =

对于子节点的tag，乘法tag乘上父节点的乘法tag，加法tag乘上父节点乘法tag再加上父节点的加法tag。（其实就相当于用了一下乘法结合律）

然后就是注意取模，用long long之类的（我不知道int会不会爆但是好像会）

其余的就是基础线段树了

**
```cpp

#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=100000+10;
typedef long long ll;
struct Node{
    ll sum,l,r,tagj,tagc;
    Node *lc,*rc;
    Node(){sum=tagj=0;tagc=1;lc=rc=NULL;}
}*root=NULL;

ll num[maxn],MOD;//1:+ 2:*
int read()//十万的话，顺手优读
{
    ll ret=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    for(;ch>='0'&&ch<='9';ch=getchar())ret=ret*10+ch-'0';
    return ret;
}

#define mid (l+(r-l)/2)
void build(Node* &p,int l,int r)
{
    p=new Node();
    p->l=l;
    p->r=r;
    if(l==r)
    {
        p->sum=num[l]%MOD;return ;
    }
    build(p->lc,l,mid);
    build(p->rc,mid+1,r);
    p->sum=(p->lc->sum + p->rc->sum)%MOD;
    return ;
}

void downtag(Node* &p)
{
    p->lc->tagc =  p->lc->tagc * p->tagc % MOD;
    p->lc->tagj = (p->lc->tagj * p->tagc + p->tagj)%MOD;
    p->lc->sum  = (p->lc->sum  * p->tagc + p->tagj*(p->lc->r - p->lc->l+1))%MOD;
    p->rc->tagc =  p->rc->tagc * p->tagc % MOD;
    p->rc->tagj = (p->rc->tagj * p->tagc + p->tagj)%MOD;
    p->rc->sum  = (p->rc->sum  * p->tagc + p->tagj*(p->rc->r - p->rc->l+1))%MOD;
    p->tagc=1;p->tagj=0;
}

void updata(Node* &p,const int &L,const int &R,const int &kind,const int &x)//1:+ 2:*
{
    int l=p->l,r=p->r;
    if(L<=l&&r<=R)
    {
        if(kind==1) 
        {
            p->tagj=(p->tagj+x)%MOD;
            p->sum=(p->sum+x*(r-l+1))%MOD;
        }
        else  
        {
            p->tagc = p->tagc*x%MOD;
            p->tagj = p->tagj*x%MOD;
            p->sum  = p->sum *x%MOD;
        }
        return ;
    }
    if(p->tagc!=1||p->tagj) downtag(p);
    if(L<=mid) updata(p->lc,L,R,kind,x);
    if(R>mid)  updata(p->rc,L,R,kind,x);
    p->sum = (p->lc->sum + p->rc->sum)%MOD;
    return ; 
}

ll Query(Node* &p,const int &L,const int &R)
{
    int l=p->l,r=p->r;
    if(L<=l&&r<=R) return p->sum;
    if(p->tagc!=1||p->tagj) downtag(p);
    ll ret=0;
    if(L<=mid) ret += Query(p->lc,L,R);
    if(mid<R)  ret += Query(p->rc,L,R);
    return ret%MOD;
}

int main()
{
    int n;cin>>n>>MOD;
    for(int i=1;i<=n;i++) scanf("%lld",num+i);
    build(root,1,n);
    int Q,ins,l,r,c;cin>>Q;
    while(Q--)
    {
        ins=read();
        if(ins==1)
        {
            l=read();r=read();c=read();
            updata(root,l,r,2,c);
        }
        else if(ins==2)
        {
            l=read();r=read();c=read();
            updata(root,l,r,1,c);
        }
        else
        {
            l=read();r=read();
            printf("%lld\n",Query(root,l,r));
        }
    }
    return 0;
}


```

---

## 作者：lemir3 (赞：1)

[到我的博客查看](https://www.cnblogs.com/Hdgs3-blog/p/10336702.html)

[**题面**](https://www.luogu.org/problemnew/show/P2023)

**一定要多取膜！不然一直卡60分！**

在区间中进行更新于查询，很好想到用线段树

为了增加速度，我们可以用到lazy标记，不过这题有乘法，我们需要修改一下

### 定义结构体：

```cpp
struct SegmentTree
{
	long long l,r;
	long long sum;
	long long addmark=0,mulmark=1;//加法的标记和乘法的标记
}t[400010];//四倍开点
```

### 乘法更新：
```cpp
if(x<=l&&y>=r)
	{
		t[id].sum=v%p*t[id].sum%p;
		t[id].mulmark=t[id].mulmark*v%p;//乘标要乘上去
		t[id].addmark=t[id].addmark*v%p;//加标也要乘（想一想为什么？）
		return;
	}
```

### 加法更新
```cpp
	if(x<=l&&y>=r)
	{
		t[id].sum=(t[id].sum+v%p*(r-l+1)%p)%p;//这个不用解释吧
		t[id].addmark=(t[id].addmark+v%p)%p;
		return;
	}
```

### 下传标记
```cpp
void PushDown(long long id)
{
	t[id*2].mulmark=t[id].mulmark%p*t[id*2].mulmark%p;//乘标是乘上去的
	t[id*2+1].mulmark=t[id].mulmark%p*t[id*2+1].mulmark%p;

	t[id*2].addmark=(t[id*2].addmark%p*t[id].mulmark%p+t[id].addmark)%p;//加标要乘上下传下来的乘标
	t[id*2+1].addmark=(t[id*2+1].addmark%p*t[id].mulmark%p+t[id].addmark)%p;

	t[id*2].sum=(t[id].mulmark%p*t[id*2].sum%p+t[id].addmark*(t[id*2].r-t[id*2].l+1)%p)%p;//先乘后加
	t[id*2+1].sum=(t[id].mulmark%p*t[id*2+1].sum%p+t[id].addmark*(t[id*2+1].r-t[id*2+1].l+1)%p)%p;

	t[id].addmark=0;//记得清0
	t[id].mulmark=1;
}
```

## 贴完整代码
```cpp
#include<bits/stdc++.h>

#define lson id*2,l,mid
#define rson id*2+1,mid+1,r

using namespace std;

long long n,m,p;

struct SegmentTree
{
	long long l,r;
	long long sum;
	long long addmark=0,mulmark=1;
}t[400010];

void BuildTree(long long,long long,long long);

void Update1(long long,long long,long long,long long,long long,long long);

void Update2(long long,long long,long long,long long,long long,long long);

long long Query(long long,long long,long long,long long,long long);

void PushDown(long long);

int main()
{
	scanf("%lld%lld",&n,&p);
	BuildTree(1,1,n);
	scanf("%lld",&m);
	for(long long i=1;i<=m;i++)
	{
		long long k;
		scanf("%lld",&k);
		if(k==1)
		{
			long long x,y,o;
			scanf("%lld%lld%lld",&x,&y,&o);
			Update1(1,1,n,x,y,o);
		}
		if(k==2)
		{
			long long x,y,o;
			scanf("%lld%lld%lld",&x,&y,&o);
			Update2(1,1,n,x,y,o);
		}
		if(k==3)
		{
			long long x,y;
			scanf("%lld%lld",&x,&y);
			printf("%lld\n",Query(1,1,n,x,y)%p);
		}
	}
return 0;
}

void BuildTree(long long id,long long l,long long r)
{
	t[id].l=l;
	t[id].r=r;
	if(l==r)
	{
		scanf("%lld",&t[id].sum);
		return;
	}
	long long mid=(l+r)>>1;
	BuildTree(lson);
	BuildTree(rson);
	t[id].sum=(t[id*2].sum+t[id*2+1].sum)%p;
}

void Update1(long long id,long long l,long long r,long long x,long long y,long long v)
{
	long long mid=(l+r)>>1;
	if(x<=l&&y>=r)
	{
		t[id].sum=v%p*t[id].sum%p;
		t[id].mulmark=t[id].mulmark*v%p;
		t[id].addmark=t[id].addmark*v%p;
		return;
	}
	PushDown(id);
	if(x<=mid)Update1(id*2,l,mid,x,y,v);
	if(y>mid)Update1(id*2+1,mid+1,r,x,y,v);
	t[id].sum=(t[id*2].sum+t[id*2+1].sum)%p;
}

void Update2(long long id,long long l,long long r,long long x,long long y,long long v)
{
	long long mid=(l+r)>>1;
	if(x<=l&&y>=r)
	{
		t[id].sum=(t[id].sum+v%p*(r-l+1)%p)%p;
		t[id].addmark=(t[id].addmark+v%p)%p;
		return;
	}
	PushDown(id);
	if(x<=mid)Update2(id*2,l,mid,x,y,v);
	if(y>mid)Update2(id*2+1,mid+1,r,x,y,v);
	t[id].sum=(t[id*2].sum+t[id*2+1].sum)%p;
}

long long Query(long long id,long long l,long long r,long long x,long long y)
{
    long long mid=(l+r)>>1;
    long long sum=0;
    if(x<=l&&y>=r)return t[id].sum;
    PushDown(id);
    if(x<=mid)sum=(sum+Query(id*2,l,mid,x,y))%p;
    if(y>mid)sum=(sum+Query(id*2+1,mid+1,r,x,y))%p;
    return sum;
}

void PushDown(long long id)
{
	t[id*2].mulmark=t[id].mulmark%p*t[id*2].mulmark%p;
	t[id*2+1].mulmark=t[id].mulmark%p*t[id*2+1].mulmark%p;

	t[id*2].addmark=(t[id*2].addmark%p*t[id].mulmark%p+t[id].addmark)%p;
	t[id*2+1].addmark=(t[id*2+1].addmark%p*t[id].mulmark%p+t[id].addmark)%p;

	t[id*2].sum=(t[id].mulmark%p*t[id*2].sum%p+t[id].addmark*(t[id*2].r-t[id*2].l+1)%p)%p;
	t[id*2+1].sum=(t[id].mulmark%p*t[id*2+1].sum%p+t[id].addmark*(t[id*2+1].r-t[id*2+1].l+1)%p)%p;

	t[id].addmark=0;
	t[id].mulmark=1;
}
```

---

## 作者：royzhu (赞：1)

这题其实就是P3373【模板】线段树2，只要改动输入就能过。
**思路（题意）**：用线段树处理，乘，加和一段区间的数的和

```cpp
#include<cstdio>
#include<cstring>

struct nod{int l,r,ll,rr;long long c,k,ce;}a[400010];
//l，r表示的是a[i]的左右边界（第l到r之间的数）
//ll是a[i]的左儿子，rr是a[i]的右儿子
//c为l到r之间的数的和，k是存要加的数，ce是存要乘的数 

int len,p;long long f[200010];
//len为第几个点，f[i]为输入的第i个数 

void bt(int l,int r)//建树 
{
	len++;int now=len;//now是当前点，len会改变 
	a[len].l=l;a[len].r=r;
    a[len].ll=a[len].rr=a[len].k=a[len].c=0;
    a[now].ce=1;
	//初始化 
	if(l<r)
	{
		int mid=(l+r)/2;
		a[now].ll=len+1;bt(l,mid);
        //len+1为ll，rr因为bt会往下加 
		a[now].rr=len+1;bt(mid+1,r);
		a[now].c=a[a[now].ll].c+a[a[now].rr].c;
        //c存左右儿子和 
	}
	else a[len].c=f[l]%p;
}

void up(int now)
//维护ce和k（乘和加。乘优先，否则会出错，答案会多） 
{
    int l=a[now].l,r=a[now].r,ll=a[now].ll,rr=a[now].rr,m=(l+r)/2;
//////////////////////////////////////先往下乘和加 
    a[ll].c=(a[ll].c*a[now].ce+a[now].k*(m-l+1))%p;
    a[rr].c=(a[rr].c*a[now].ce+a[now].k*(r-m))%p;
///////////////////////////////// 维护左右儿子的ce 
    a[ll].ce=(a[ll].ce*a[now].ce)%p;
    a[rr].ce=(a[rr].ce*a[now].ce)%p;
////////////////////////////////// 维护左右儿子的k
    a[ll].k=(a[ll].k*a[now].ce+a[now].k)%p;
    a[rr].k=(a[rr].k*a[now].ce+a[now].k)%p;
///////////////////////把ce和k初始化（ce为初始为1） 
    a[now].ce=1;
    a[now].k=0;
    return ;
}

void change(int now,int l,int r,long long k)//加 
{
	if(a[now].l==l&&a[now].r==r)
	{
		a[now].c=(a[now].c+k*(r-l+1))%p;
		a[now].k=(a[now].k+k)%p;
		return;
	}
	int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
	up(now);
	if(r<=mid) change(ll,l,r,k);
	else if(l>mid) change(rr,l,r,k);
	else{change(ll,l,mid,k); change(rr,mid+1,r,k);}
	a[now].c=(a[ll].c+a[rr].c)%p;//刷新c 
}

void cc(int now,int l,int r,long long k)//乘 
{
	if(a[now].l==l&&a[now].r==r)
	{
		a[now].c=a[now].c*k%p;
		a[now].ce=(a[now].ce*k)%p;
		a[now].k=(a[now].k*k)%p;//也要乘k，否则k会变少 
		return;
	}
	int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
	up(now);
	if(r<=mid) cc(ll,l,r,k);
	else if(l>mid) cc(rr,l,r,k);
	else{cc(ll,l,mid,k); cc(rr,mid+1,r,k);}
	a[now].c=(a[ll].c+a[rr].c)%p;//刷新c 
}

long long findsum(int now,int l,int r)//找和 
{
	if(a[now].l==l&&a[now].r==r) return a[now].c%p;
	int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
	up(now);
	if(r<=mid) return findsum(ll,l,r)%p;
	else if(l>mid) return findsum(rr,l,r)%p;
	else return (findsum(ll,l,mid)+findsum(rr,mid+1,r))%p;
}

int main()
{
	int n,m;scanf("%d %d",&n,&p);
	for(int i=1;i<=n;i++)scanf("%lld",&f[i]);
	len=0;bt(1,n);scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int v;scanf("%d",&v);
		if(v==2)
		{
			int x,y;long long c;scanf("%d %d %lld",&x,&y,&c);
			change(1,x,y,c);
		}
		else if(v==1)
		{
			int x,y;long long c;scanf("%d %d %lld",&x,&y,&c);
			cc(1,x,y,c);
		}
		else
		{
			int x,y;scanf("%d %d",&x,&y);
			printf("%lld\n",findsum(1,x,y)%p);
		}
	}
	return 0;
}
```

---

## 作者：JasonZRY (赞：0)

## 这不就是线段树吗

## 假如你不知道线段树

### 定义

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。

### 基本结构

线段树是建立在线段的基础上，每个结点都代表了一条线段[a,b]。长度为1的线段称为元线段。非元线段都有两个子结点，左结点代表的线段为[a,(a + b) / 2]，右结点代表的线段为[((a + b) / 2）+1,b]。

下图就是一棵线段树。

![](data:image/jpeg;base64,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IONpwMY7mtjT/Bc+rWEV7YfEXxLcW0y7o5BcLtYdMj5a6HxrfT2mifYrBtuoalItnbeoZ/vN/wABXc34VuabYQaXYW9jbJtgt4ljQegAAFAHD/Dw6jDr/ivSb3VrzUo9PuoY4ZbuTcwBTcfbvXodcF4I/wCR98ff9f1v/wCiq72gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA5rxR4MtPFkdkLq9vrSSzlMsM1jKI5FbGM7sE1jD4Wpjnxr4zz7asf/AImu+ooA4H/hVsf/AEOvjP8A8G5/+Jo/4VbH/wBDr4z/APBuf/ia76igDlfDPgSz8MardanHqmrahd3MSwySahciY7QcgA7Qf1qbxv4Ym8WeHW0y3vEtJDNHMszR7wpRg3TI9K6SigDgR4c+Iw6eOrIf9whP8aP+Ed+I5/5nux/8E6f4131FAHAf8I58Rv8AoebH/wAE6f40v/COfEbv47ssen9kJ/jXfUUAcp4K8K6h4bfVp9T1SPULvUrkXEkkcHlAELjpk11dFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFcD41/5KJ4A9rq6/8ARNd9XM+KfBth4smsXvLm/tpLJmeGWzm8tgWAB5wewoA6C5tory3eCeNJIZFKujjIYHgg1gaf4I0rTJHlt/tLTmJoYpZrl5WgQ9o95Owew9BWP/wqmw/6GbxV/wCDVv8ACj/hVNh/0M3ir/wat/hQBt3Hg3TbrS7Gxk89RYoEt54p2jmQAYPzqQeR19a0tJ0ez0SxSzsYRHEpJPJZnY9WYnkk9STXJf8ACqbD/oZvFX/g1b/Cj/hVNh/0M3ir/wAGrf4UAHxF/wCQ54H9tcQ/+ONXReMv+RG8Qf8AYNuP/RTVz9v8LdLtdUsb9tX127ls5hNCt5fGVA46HBFdZrWnnVtA1DTRL5X2u2kg8zbu271K5x3xnpQBheEbCLUvhboVnPu8mfSIYn2MVO1ogDgjkda2LvQbW60BtFUvb2hhEAEJ2lUGAAD9BiuM07wR460zTbbT7P4hpFa2sSwwodEibaijAGS2TwKtf8It8Q/+ikR/+CKH/wCKoA6ubRLS41Kyv5ELT2QcW5LHCbwATjpnAxntk+taVcF/wi3xD/6KRH/4Iof/AIqj/hFviH/0UiP/AMEUP/xVAB4I/wCR98ff9f1v/wCiq72uR8HeEtQ8N3mr3mpa0NVvNTlSWWYWogwVXb90Ejpj0rrqACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/Z)

长度范围为[1,L] 的一棵线段树的深度为log (L) + 1。这个显然，而且存储一棵线段树的空间复杂度为O(L）。

线段树支持最基本的操作为插入和删除一条线段。下面以插入为例，详细叙述，删除类似。

将一条线段[a,b] 插入到代表线段[l,r]的结点p中，如果p不是元线段，那么令mid=（l+r）/2。如果b<mid，那么将线段[a,b] 也插入到p的左儿子结点中，如果a>mid，那么将线段[a,b] 也插入到p的右儿子结点中。

插入（删除）操作的时间复杂度为O（logn）。

## 回归本题

加法不用说，乘法的时候到加法的地方也要翻倍

[线段树2](https://www.luogu.com.cn/problem/P3373)原题啊

把输入m的位置换一下就好了

## 代码如下

```
#include<bits/stdc++.h>
#define ls o<<1
#define rs o<<1|1
using namespace std;
struct tree{
	long long l,r,sum,tim,plu;
}tr[400005];
long long n,m,p,o,x,y,k,v[100005];
void build(long long o,long long l,long long r){
	tr[o].l=l,tr[o].r=r,tr[o].tim=1;
	if(l==r){
		tr[o].sum=v[l]%p;
		return;
	}
	long long mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	tr[o].sum=(tr[ls].sum+tr[rs].sum)%p;
}
void up(long long o){
	tr[ls].sum=(tr[o].tim*tr[ls].sum+(tr[ls].r-tr[ls].l+1)*tr[o].plu%p)%p;
	tr[rs].sum=(tr[o].tim*tr[rs].sum+(tr[rs].r-tr[rs].l+1)*tr[o].plu%p)%p;
	tr[ls].tim=tr[ls].tim*tr[o].tim%p;
	tr[rs].tim=tr[rs].tim*tr[o].tim%p;
	tr[ls].plu=(tr[ls].plu*tr[o].tim+tr[o].plu)%p;
	tr[rs].plu=(tr[rs].plu*tr[o].tim+tr[o].plu)%p;
	tr[o].plu=0,tr[o].tim=1;
}
void time(long long o,long long l,long long r,long long k){
	if(tr[o].l>=l&&tr[o].r<=r){
		tr[o].plu=tr[o].plu*k%p;
		tr[o].tim=tr[o].tim*k%p;
		tr[o].sum=tr[o].sum*k%p;
		return;
	}
	up(o);
	tr[o].sum=(tr[ls].sum+tr[rs].sum)%p;
	long long mid=(tr[o].l+tr[o].r)>>1;
	if(l<=mid)time(ls,l,r,k);
	if(mid<r)time(rs,l,r,k);
	tr[o].sum=(tr[ls].sum+tr[rs].sum)%p;
}
void add(long long o,long long l,long long r,long long k){
	if(tr[o].l>=l&&tr[o].r<=r){
		tr[o].plu=(tr[o].plu+k)%p;
		tr[o].sum=(tr[o].sum+k*(tr[o].r-tr[o].l+1))%p;
		return;
	}
	up(o);
	tr[o].sum=(tr[ls].sum+tr[rs].sum)%p;
	long long mid=(tr[o].l+tr[o].r)>>1;
	if(l<=mid)add(ls,l,r,k);
	if(mid<r)add(rs,l,r,k);
	tr[o].sum=(tr[ls].sum+tr[rs].sum)%p;
}
long long ask(long long o,long long l,long long r){
	if(tr[o].l>=l&&tr[o].r<=r)return tr[o].sum;
	up(o);
	long long ans=0,mid=(tr[o].l+tr[o].r)>>1;
	if(l<=mid)ans=(ans+ask(ls,l,r))%p;
	if(mid<r)ans=(ans+ask(rs,l,r))%p;
	return ans;
}
int main(){
	scanf("%lld%lld",&n,&p);
	for(long long i=1;i<=n;i++)scanf("%lld",&v[i]);
	build(1,1,n);
    scanf("%lld",&m);
	for(long long i=1;i<=m;i++){
		scanf("%lld%lld%lld",&o,&x,&y);
		if(o==1){
			scanf("%lld",&k);
			time(1,x,y,k);
		}
		if(o==2){
			scanf("%lld",&k);
			add(1,x,y,k);
		}
		if(o==3)printf("%lld\n",ask(1,x,y));
	}
}
```
**~~我太懒把全部int改long long了~~**

---

## 作者：fdvty (赞：0)

 线段树模版题
------------

对于每个区间维护sum, add, mul三个值

代表这个区间中每个元素都要先乘mul再加add

这个区间对应的实际值为 mul*sum+add


------------


下推标记时:

（子节点的值分别记为sum1, add1, mul1）

	add1 = add1*mul + add
    mul1 = mul1*mul
    

------------

对mul和add的更新可以通过一个函数实现，详见代码

------------

最后注意对add, mul, sum等取模

依据下述定理：

	(a+b)%x = (a%x + b%x)%x

	(a*b)%x = ((a%x)*(b%x))%x
    

------------
代码地址

https://paste.ubuntu.com/p/Yp7CJCH5DQ/


---

## 作者：吃的 (赞：0)

其实就是线段树的模版题，然后加了几个自己的小优化

```cpp

#define FIRST
#ifdef FIRST

#include <iostream>
#include <algorithm>
#include <cstdio>

typedef long long LL;
//别名 节省码量
const LL N = 8e5 + 5;
//使用常量

LL read(void);
//快读函数
LL n, m;

class SegmentTree{
  private:
    LL a[N], sum[N], add[N], mul[N];
    LL p;
  public:
    SegmentTree(void) {}
    void get_p(void);
    void input(LL);
    void pushup(LL);
    void pushdown(LL, LL, LL);
    void build(LL, LL, LL);
    void update1(LL, LL, LL, LL, LL, LL);
    void update2(LL, LL, LL, LL, LL, LL);
    LL query(LL, LL, LL, LL, LL);
};
//声明线段树类

SegmentTree st;
//对象

#define DEBUG for ( LL i = 1; i <= n; ++ i ){\
						std::cout << st.query( i, i, 1, n, 1 ) << ' ';\
				}\
				std::cout << std::endl
方便调试

int main(void) {
  n = read(); 
  st.get_p();
  st.input(n);
  m = read();
  st.build(1, n, 1);
  //建树
  while (m--) {
    LL opt = read();
    //以下利用位运算来压时间，有对应的说明
    if (opt & 1) //opt == 1 or 3
      if ((opt >> 1) & 1) {//opt == 3
        LL l, r;
        l = read(); r = read();
        std::printf("%lld\n", st.query(l, r, 1, n, 1));
        //用printf比较快
      }
      else {//opt == 1
        LL l, r; LL c;
        l = read(); r = read(); c = read();
        st.update1(l, r, c, 1, n, 1);
      }
    else {//opt == 2
      LL l, r; LL c;
      l = read(); r = read(); c = read();
      st.update2(l, r, c, 1, n, 1);
    }
    //DEBUG;
  }
  return 0;
}

inline LL read(void) {
  register LL ret = 0, c = std::getchar();
  while (!std::isdigit(c)) c = std::getchar();
  while (std::isdigit(c))  ret = ret * 10 + c - '0', c = std::getchar();
  return ret;
}
//快读函数

//SegmentTree

//位运算优化
#define lson rt<<1
//左儿子
#define rson rt<<1|1
//右儿子
#define ltree l,mid,lson
//二分之后的左子树
#define rtree mid+1,r,rson
//二分之后的右子树
#define mod(x) (x)%p
//取模运算改成宏定义，我觉得比较好写

//注意 以下的l,r指当前的闭区间，rt指当前区间编号

void SegmentTree::get_p(void) {
  p = read();
}
//没什么用的函数

void SegmentTree::input(LL _n) {
  LL *begin = a + 1, *end = a + _n + 1;
  while (begin != end) {
    *begin = read();
    ++begin;
  }
}
//利用指针来加速。
/*
a[i] 等价于 *(a + i)
所以对于以下两段代码
for (int i = 1; i <= n; ++i)
  f(a[i]);


for (int now = a + 1; now != a + n + 1; ++now) 
  f(*now);
  
后者的速度更快
所以这里用指针和快读函数进行输入
*/

inline void SegmentTree::pushup(LL rt) {
  sum[rt] = mod(sum[lson] + sum[rson]);
}
//合并状态

inline void SegmentTree::pushdown (LL l, LL r, LL rt) {
  if (add[rt] || mul[rt] != 1) {
    LL mid = (l + r) >> 1;
    sum[lson] = mod(sum[lson] * mul[rt] + add[rt] * (mid - l + 1));
    sum[rson] = mod(sum[rson] * mul[rt] + add[rt] * (r - mid));
    //区间和 为 原区间和 * 父节点乘法标记 + 父节点加法标记 * 区间长度 最后取模
    add[lson] = mod(add[lson] * mul[rt] + add[rt]);
    add[rson] = mod(add[rson] * mul[rt] + add[rt]);
    //加法标记 为 原加法标记 * 父节点乘法标记 + 父节点加法标记 最后取模
    mul[lson] = mod(mul[lson] * mul[rt]);
    mul[rson] = mod(mul[rson] * mul[rt]);
    //乘法标记 为 原乘法标记 * 父节点乘法标记 最后取模
    mul[rt] = 1; add[rt] = 0;
    //将父节点的标记下放后，清除
  }
}
//下放操作

void SegmentTree::build(LL l, LL r, LL rt) {
  add[rt] = 0; mul[rt] = 1;
  if (l == r) {
    sum[rt] = mod(a[l]);
    return ;
  }
  LL mid = (l + r) >> 1;
  build(ltree);
  build(rtree);
  pushup(rt);
}
//递归建树

void SegmentTree::update1(LL L, LL R, LL C, LL l, LL r, LL rt) {
  //L, R为目标区间，C为修改值，下同
  if (L <= l && r <= R) {
    //当前区间在目标区间内
    sum[rt] = mod(sum[rt] * C);
    add[rt] = mod(add[rt] * C);
    mul[rt] = mod(mul[rt] * C);
    //因为乘法优先级高，所以均乘上C
    return ;
  }
  pushdown(l, r, rt);
  //先下放
  LL mid = (l + r) >> 1;
  //向左、右分别修改
  if (L <= mid) {
    update1(L, R, C, ltree);
  }
  if (R > mid) {
    update1(L, R, C, rtree);
  }
  pushup(rt);
}
//区间乘法

void SegmentTree::update2(LL L, LL R, LL C, LL l, LL r, LL rt) {
  //基本同区间乘法
  if (L <= l && r <= R) {
    sum[rt] = mod(sum[rt] + C * (r - l + 1));
    //区间和 要加上修改值*区间长度
    add[rt] = mod(add[rt] + C);
    //标记修改
    return ;
  }
  pushdown(l, r, rt);
  LL mid = (l + r) >> 1;
  if (L <= mid) {
    update2(L, R, C, ltree);
  }
  if (R > mid) {
    update2(L, R, C, rtree);
  }
  pushup(rt);
}
//区间加法

LL SegmentTree::query(LL L, LL R, LL l, LL r, LL rt) {
  if (L <= l && r <= R) {
    //直接返回当前区间和
    return sum[rt];
  }
  pushdown(l, r, rt);
  LL mid = (l + r) >> 1, ans = 0;
  //还是向左、右分别查询
  if (L <= mid) {
    ans = mod(ans + query(L, R, ltree));
  }
  if (R > mid) {
    ans = mod(ans + query(L, R, rtree));
  }
  return ans;
}
//区间查询

#endif
~~~

---


# 贪婪大陆

## 题目背景

面对蚂蚁们的疯狂进攻，小 FF 的 Tower defence 宣告失败……人类被蚂蚁们逼到了 Greed Island 上的一个海湾。现在，小 FF 的后方是一望无际的大海，前方是变异了的超级蚂蚁。小 FF 还有大好前程，他可不想命丧于此， 于是他派遣手下最后一批改造 SCV 布置地雷以阻挡蚂蚁们的进攻。

## 题目描述

小 FF 最后一道防线是一条长度为 $n$ 的战壕，小 FF 拥有无数多种地雷，而 SCV 每次可以在 $[L, R]$ 区间埋放同一种不同于之前已经埋放的地雷。由于情况已经十万火急，小 FF 在某些时候可能会询问你在 $[L',R']$ 区间内有多少种不同的地雷，他希望你能尽快的给予答复。


## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$0 \le n$，$m \le 1000$。
- 对于 $100\%$ 的数据，$0 \le n$，$m \le 10^5$。

## 样例 #1

### 输入

```
5 4
1 1 3
2 2 5
1 2 4
2 3 5
```

### 输出

```
1
2
```

# 题解

## 作者：jins3599 (赞：94)

非常妙的一道题！

拿到题的第一感觉：带修莫队？？怎么是个蓝题？

然后仔细想了想，其实这道题没有这么困难。

借助于差分的思想，我们考虑区间$[l,r]$的答案是什么。

比如说给定这样一个查询的区间。

![](https://cdn.luogu.com.cn/upload/image_hosting/8v68fprm.png)

我们首先插入一段红色区间，此时答案数为1。

![](https://cdn.luogu.com.cn/upload/image_hosting/z063n2pw.png)


我们再插入一段区间呢？答案数为2.
![](https://cdn.luogu.com.cn/upload/image_hosting/zyliaznx.png)

有什么规律？我们先约定一个区间靠左的端点叫区间的开头，靠右的为区间的结尾。

我们的答案其实就是：

**R之前的所有区间开头数（包括R）-L之前的所有区间结尾数（不包括L）**

为什么？跨越$[l,r]$的区间一定是区间尾在$[l,r]$内或区间头在$[l,r]$内，或两者都在区间$[l,r]$内。

也就是说我们这样一减，会把所有完全在$[1...l]$区间内的颜色去掉，留下的一定包含在$[l,r]$中。

然后我们只需要维护两个单点修改区间查询的树状数组即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n , m;
const int N = 1e5+ 10;
int t[2][N];//0开头 1结尾 

void add(int x , int pos) {
	while(x <= n) {
		t[pos][x] ++;
		x += x & (-x);
	}
}

int sum (int x , int pos) {
	int ans = 0;
	while(x) {
		ans += t[pos][x];
		x -= x & (-x);
	}
	return ans;
}

int main () {
	scanf("%d %d" , &n, &m);
	while(m --) {
		int opt , l , r;
		scanf("%d %d %d" , &opt , &l , &r);
		if(opt == 1) {
			add(l , 0); add(r , 1);
		} else {
			int rans = sum(r , 0) - sum(l - 1 , 1);
 			printf("%d\n" , rans);
		}
	}
	return 0;
} 
```


---

## 作者：eternal风度 (赞：73)


其实很容易理解就是询问一段区间内有多少段不同的区间

然后再仔细思索一下会发现：

1.只要一个区间的开头在一个节点i的左边，那么这个区间包含在区间1~i中。

2.只要一个区间的尾部在一个节点j的左边，那么这个区间肯定不属于j之后的所有区间

这时候就不难想到用两个树状数组维护：

第一个：维护节点i之前有多少个区间的开头

第二个：维护节点j之前有多少个区间的结尾

不难证明拿sum[i]-sum[j]得到的就是i~j中间地雷的个数(手动模拟一波就一清二楚了)


    
    
    
    
    
    
    
    
```cpp
    #include<iostream>
    #include<cstdlib>
    #include<cstdio>
    #include<cmath>
    #include<cstring>
    #include<iomanip>
    #include<algorithm>
    #include<stack>
    #include<queue>
    #define lst long long
    #define rg register
    #define N 100050
    using namespace std;
    int n,m;
    lst ans;
    int tou[N],wei[N];//tou存前面有多少个区间的开始，以下简称头部树状数组
                      //wei存前面有多少个区间的尾部，以下简称尾部树状数组
                      //类似于前缀和
    inline int read()//读入优化
    {
        rg int s=0,m=1;rg char ch=getchar();
        while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
        if(ch=='-')m=-1,ch=getchar();
        while(ch>='0'&&ch<='9')s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
        return s*m;
    }
    //以下是树状数组的板子
    inline int lowbit(rg int kk)//lowbit
    {
        return kk&(-kk);
    }
    inline void add_tou(rg int kk)//加入树状数组的头部数组
    {
        while(kk<=n)
        {
            ++tou[kk];
            kk+=lowbit(kk);
        }
    }
    inline void add_wei(rg int kk)//加入树状数组的尾部数组
    {
        while(kk<=n)
        {
            ++wei[kk];
            kk+=lowbit(kk);
        }
    }
    inline int sum_tou(rg int kk)//计算节点前有多少个区间的开始
    {
        rg int s=0;
        while(kk>0)
        {
            s+=tou[kk];
            kk-=lowbit(kk);
        }
        return s;
    }
    inline int sum_wei(rg int kk)//计算节点前有多少个区间的结束
    {
        rg int s=0;
        while(kk>0)
        {
            s+=wei[kk];
            kk-=lowbit(kk);
        }
        return s;
    }
    int main()
    {
        n=read(),m=read();//读入
        for(rg int i=1;i<=m;++i)
        {
            rg int sign=read();
            rg int x=read(),y=read();//读入
            if(sign==1)
            {
                add_tou(x);//加入头部树状数组
                add_wei(y);//加入尾部树状数组
            }
            else
            {
                ans=sum_tou(y)-sum_wei(x-1);//运用已经证明的规律结题
                printf("%d\n",ans);
            }
        }
        return 0;
    }
```
通过这道题，我们可以发现大部分的树状数组题目可以用线段树做，但也有线段树不好维护的题目，这就需要灵活的利用树状数组的技巧(虽然题解里也有线段树比较好理解的)
我自认为我的代码还是蛮好看的，只是变量有点丑，但好理解


---

## 作者：Mudrobøt (赞：43)

说实话这道题还是非常好的，因为他给我们提供了一种非常巧妙的想法——差分！

当时我看到这道题的时候我就一直在想我应该如何做去维护当前区间的一些信息，然后就这样想啊想，发现越想越不对，越想越爆炸！然后我结合以前做的几道线段树题，我想如果真的有这么难的话，这道题怎么可能才是一道蓝题，事实证明我确实是想错了！

这道题的思路也是非常的简单啊！我们只需要每次埋地雷的时候，我们只需要标记一下当前区间的开头和结尾，我们查的时候，我们只需要查1到当前区间结尾中包含了多少个开头（一个开头代表了一种地雷）然后我们查1到当前区间前一个位置包含了多少个结尾（一个结尾代表我们一种地雷埋完了，就是我们看前面有几种地雷被埋完了！）然后把这个做差，我们就可以知道有多少种地雷是出现在当前区间中，然后这道题就成功的被我们转化成了一个单点修改，区间查询的线段树。

如果上面的东西还是没有看懂的话，大家可以结合下面这个示意图理解一下：

![](https://cdn.luogu.com.cn/upload/pic/27401.png)

我们这里假设红色的三角形为开始标记（有可能多个开始标记在一起，我们只需要记个数就可以了！）绿色的为结束标记，那么我们可以发现我们查询区间前面那一段的绿色标记为两个，表明在到查询区间之前已经有两种地雷埋完了，而包括查询区间在内的前面的所有的开始标记，减去结束标记就是我们要知道的在查询区间内出现的地雷的种数！

相信大家应该都懂了！

AC code：

```
#include<bits/stdc++.h>
using namespace std;
struct sd{
    int l,r,son[2],sta,end;
}node[1000004];
int root,n,m,cnt;
void Buildtree(int &k,int l,int r)
{
    ++cnt;k=cnt;node[k].l=l;node[k].r=r;
    if(l==r) return;
    else
    {
        int mid=(l+r)/2;
        Buildtree(node[k].son[0],l,mid);
        Buildtree(node[k].son[1],mid+1,r);
    }
}
void modify_sta(int k,int pos)
{
    if(node[k].l==node[k].r) node[k].sta++;
    else
    {
        int mid=(node[k].l+node[k].r)/2;
        if(pos<=mid) modify_sta(node[k].son[0],pos);
        else modify_sta(node[k].son[1],pos);
        node[k].sta=node[node[k].son[0]].sta+node[node[k].son[1]].sta;
    }
}
void modify_end(int k,int pos)
{
    if(node[k].l==node[k].r) node[k].end++;
    else
    {
        int mid=(node[k].l+node[k].r)/2;
        if(pos<=mid) modify_end(node[k].son[0],pos);
        else modify_end(node[k].son[1],pos);
        node[k].end=node[node[k].son[0]].end+node[node[k].son[1]].end;
    }
}
int query_end(int k,int l,int r)
{
    if(node[k].l==l&&node[k].r==r) return node[k].end;
    else
    {
        int mid=(node[k].l+node[k].r)/2;
        if(r<=mid) return query_end(node[k].son[0],l,r);
        else if(l>mid) return query_end(node[k].son[1],l,r);
        else return query_end(node[k].son[0],l,mid)+query_end(node[k].son[1],mid+1,r);
    }
}
int query_sta(int k,int l,int r)
{
    if(node[k].l==l&&node[k].r==r) return node[k].sta;
    else
    {
        int mid=(node[k].l+node[k].r)/2;
        if(r<=mid) return query_sta(node[k].son[0],l,r);
        else if(l>mid) return query_sta(node[k].son[1],l,r);
        else return query_sta(node[k].son[0],l,mid)+query_sta(node[k].son[1],mid+1,r);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    int a,b,c;
    Buildtree(root,1,n);
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d%d",&a,&b,&c);
        if(a==1){modify_sta(root,b);modify_end(root,c);}
        if(a==2){printf("%d\n",query_sta(root,1,c)-query_end(root,1,b-1));}
    }
}
```
By njc

---

## 作者：SNiFe (赞：29)

##我看见没有C++的线段树写法，所以来发一波题解。

这是一个代码简单的线段树，但其实不是很容易想到这种思路。

线段树要维护两个东西，一个suml（起点），sumr（终点）；

##插入：

插入的时候只需要在起点和终点sum++（区间维护，实际是点修改），如图：

 ![](https://cdn.luogu.com.cn/upload/pic/8041.png) 

##查询：

查询x~y区间的时候需要用1~y点的suml-1~x点的sumr；

为什么这样查询呢？大家仔细想想，用笔画画，这是个区间覆盖问题，大家一定要想通，结合插入来想想。（这里就不详细讲了，结合图片看看）。

#CODE：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rs id<<1|1
#define ls id<<1
using namespace std;
const int N=100000+10;
struct node
{
    int left,right,sumr,suml;
}tree[N*4];
int n,m;
void build(int id,int l,int r)
{
    tree[id].left=l,tree[id].right=r;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(ls,l,mid),build(rs,mid+1,r);
}
void update(int id,int x)//修改起点
{
    if(tree[id].left==tree[id].right)
    {
        tree[id].suml++;return;
    }
    if(x>tree[ls].right)update(rs,x);
    else update(ls,x);
    tree[id].suml=tree[ls].suml+tree[rs].suml;
}
void update2(int id,int x)//修改终点
{
    if(tree[id].left==tree[id].right)
    {
        tree[id].sumr++;return;
    }
    if(x>tree[ls].right)update2(rs,x);
    else update2(ls,x);
    tree[id].sumr=tree[ls].sumr+tree[rs].sumr;
}
int query(int id,int l,int r)//查询起点
{
    if(r<tree[id].left || tree[id].right<l)return 0;
    if(l<=tree[id].left&&tree[id].right<=r)return tree[id].suml;
    return query(ls,l,r)+query(rs,l,r);
}
int query2(int id,int l,int r)//查询终点
{
    if(tree[id].left>r||tree[id].right<l)return 0;
    if(tree[id].left>=l&&tree[id].right<=r)return tree[id].sumr;
    return query2(ls,l,r)+query2(rs,l,r);
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,1,n);//建树
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        if(x==1)
        {
            update(1,y);update2(1,z);
        }
        if(x==2)
        {
            int s=query(1,1,z);
            int t=query2(1,1,y-1);
            printf("%d\n",s-t);//终点的sum-起点的sum
        }
    }
}
```

---

## 作者：communist (赞：24)

### 看到全是线段树或者树状数组写法，就来提供一发全网唯一$cdq$分治三维偏序解法吧

容易发现，这个题的查询就是对于每个区间$l,r$，查询有多少个修改区间$l_i,r_i$与$l,r$有交集

转化为数学语言，就是**查询满足$l_i<=r$且$r_i>=l$的修改个数**

一个二维偏序问题，但是我们发现，这是个动态插入的二维偏序问题

_(:з」∠)__一时不知所措

再想一想，不妨**把时间另开一个维度作为第三维**，然后就是这样了

对于每个查询，我们要求出它之前有多少个修改区间与其相交

数学语言：

**查询满足$l_i<=r$且$r_i>=l$且$[l_i,r_i].time<[l,r].time$的修改个数**

思路清晰明了，而且敲好想，但是实现细节还是比较麻烦的（一部分是因为我的奇葩$cdq$写法），在代码注释里解释一下（模板这种的就不解释了）

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=1e5+10;
struct node{
    int a,b,c,q,w;
//a,b,c表示三个维度，q记录这个操作是修改还是查询
//w表示这个是否有效（和q差不多，查询是不需要统计的，w=0；修改的w=1）
}v[maxn];
int n,m,cnt,tot,c[maxn],ans[maxn];
bool vis[maxn];
bool cmpx(const node &a,const node &b)
{
    return a.a==b.a?(a.b==b.b?a.c<b.c:a.b<b.b):a.a<b.a;
}
bool cmpy(const node &a,const node &b)
{
    return a.b==b.b?a.c<b.c:a.b<b.b;
}
int lowbit(int x)
{
    return x&-x;
}
void add(int x,int ch)
{
    while(x<=n)
    {
        c[x]+=ch;
        x+=lowbit(x);
    }
}
int sum(int x)
{
    int ret=0;
    while(x)
    {
        ret+=c[x];
        x-=lowbit(x);
    }
    return ret;
}
void cdq(int l,int r)
{
    if(l==r)
        return;
    int mid=l+r>>1;
    cdq(l,mid),cdq(mid+1,r);
    sort(v+l,v+mid+1,cmpy),sort(v+mid+1,v+r+1,cmpy);
    int i=l,j=mid+1;
    for(;j<=r;j++)
    {
        while(v[i].b<=v[j].b&&i<=mid)
            add(v[i].c,v[i].w),i++;
        if(v[j].q==2)
        	ans[v[j].a]+=sum(n)-sum(v[j].c-1);
            //统计贡献到ans数组中
    }
    for(j=l;j<i;j++)
        add(v[j].c,-v[j].w);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&v[i].q,&v[i].b,&v[i].c);
        v[i].w=1;
        if(v[i].q==2)
        	swap(v[i].b,v[i].c),v[i].w=0,vis[i]=1;
            //标记每个操作是否需要输出
        v[i].a=i;
    }
    cdq(1,m);
    //枚举每个操作，需要输出就输出
    for(int i=1;i<=m;i++)
    	if(vis[i])
        	printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Rye_Catcher (赞：17)

- 题目链接：

   https://www.luogu.org/problemnew/show/P2184
   
- 思路：

   首先我想吐槽一下为什么现有题解中的做法都是一样的，而且还比较难以理解;
   
   我就讲下我的做法，本质上是一样的，但是跟容易理解.
   
   根据题意每加一次地雷就多一个种类对吧，我们用一个cnt记录加过地雷的次数，同时分别用两个数组记录左右两个端点的位置。然后查询[l,r]时呢，我们分别查询[1,l-1]有多少个右端点，[r+1,n]有多少个左端点,然后这两个数的和是什么意思呢？就是有多少次铺地雷没铺到我们查询的这个[l,r]区间。
   
   最后cnt-刚刚两次查询的和就是有多少次地雷铺到了[l,r]这个区间，输出即可，当然，我们用线段树维护这些操作。
   
- 代码：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cctype>
using namespace std;
const int maxn=100005;
int sum_r[maxn<<2],sum_l[maxn<<2],add[maxn<<2];
int n,m;
int L,R;
void update_l(int now,int l,int r,int t){
	if(l==r){
		sum_l[now]++;
		return ;
	}
	int mid=(l+r)>>1;
	if(t<=mid)update_l(now<<1,l,mid,t);
	else update_l(now<<1|1,mid+1,r,t);
	sum_l[now]=sum_l[now<<1]+sum_l[now<<1|1];
	return ;
}
void update_r(int now,int l,int r,int t){
	if(l==r){
		sum_r[now]++;
		return ;
	}
	int mid=(l+r)>>1;
	if(t<=mid)update_r(now<<1,l,mid,t);
	else update_r(now<<1|1,mid+1,r,t);
	sum_r[now]=sum_r[now<<1]+sum_r[now<<1|1];
	return ;
}
int query_l(int now,int l,int r){
	if(L<=l&&r<=R){
		return sum_l[now];
	}
	int mid=(l+r)>>1;
	int ans=0; 
	if(L<=mid)ans+=query_l(now<<1,l,mid);
	if(mid<R)ans+=query_l(now<<1|1,mid+1,r);
	return ans;
}
int query_r(int now,int l,int r){
	if(L<=l&&r<=R){
		return sum_r[now];
	}
	int mid=(l+r)>>1;
	int ans=0; 
	if(L<=mid)ans+=query_r(now<<1,l,mid);
	if(mid<R)ans+=query_r(now<<1|1,mid+1,r);
	return ans;
}
int main()
{
	int op,l,r;
	int cnt=0,tmp=0;
	scanf("%d %d",&n,&m);
	for(register int i=1;i<=m;i++){
		scanf("%d %d %d",&op,&l,&r);
		if(op==1){
			update_l(1,1,n,l);
			update_r(1,1,n,r);
			cnt++;
		}
		else {
			L=r+1,R=n;
			if(L<=R)tmp+=query_l(1,1,n);		
			L=1,R=l-1;
			if(L<=R)tmp+=query_r(1,1,n);
		    cout<<cnt-tmp<<endl;
		    tmp=0;
		}
	}
	return 0;
} 
```

---

## 作者：zhengrunzhe (赞：13)

首先观察题目实质：

1.扔一个区间[l,r]

2.查询有多少个之前插入过的区间与[l,r]有交

回忆我们线段树如何判断当前节点代表的区间[l,r]与询问区间[L,R]没有交集

```cpp
if (l>R||r<L)return 0;
```
没有交集是l>R||r<L那么有交集就是!(l>R||r<L)=l<=R&&r>=L

然后这就变成了一个二维偏序问题

$$r>=L.l<=R$$

(l,r代表之前插入过的所有区间,L,R代表查询区间)

然后这个玩意如果在线的话显然可以直接树套树直接爆搞

去cdq分治离线你就要加一维时间变成三维偏序非常不爽

什么两个树状数组线段树做法我太菜了不会

然后我就用了个$KDtree$维护这个二维偏序

要动态插入，替罪羊思想重构即可

```cpp
#include<cstdio>
#include<algorithm>
using std::nth_element;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool f=0;
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const void write(type out)
{
	if (out>9)write(out/10);
	putchar(out%10+48);
}
template<class type>inline const void writeln(type out)
{
	if (out<0)out=-out,putchar('-');
	write(out);
	putchar('\n');
}
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
template<class type>inline const type min(const type &a,const type &b)
{
	return a<b?a:b;
}
const int N=1e5+10,inf=2147483647,K=2;
int n,m;
int f;
struct point
{
	int d[K];
	inline point(const int &x=0,const int &y=0){d[0]=x;d[1]=y;}
	inline const bool operator<(const point &p)const
	{
		return d[f]<p.d[f];
	}
};
template<int k>class KD_Tree
{
	private:
		static const double alpha=0.75;
		struct tree
		{
		    int size;
		    tree *son[2];
		    point range,mx,mn;
		    inline const void pushup()
		    {
		    	size=son[0]->size+1+son[1]->size;
		    	for (int i=0;i<k;i++)
		    		mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i])),
		    		mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i]));
		    }
		    inline const bool at(const point &lower,const point &upper)
		    {
		    	for (int i=0;i<k;i++)
		    		if (!(range.d[i]>=lower.d[i]&&range.d[i]<=upper.d[i]))
		    			return 0;
		    	return 1;
		    }
		    inline const bool in(const point &lower,const point &upper)
		    {
		    	for (int i=0;i<k;i++)
		    		if (!(mn.d[i]>=lower.d[i]&&mx.d[i]<=upper.d[i]))
		    			return 0;
		    	return 1;
		    }
		    inline const bool out(const point &lower,const point &upper)
		    {
		    	for (int i=0;i<k;i++)
		    		if (mn.d[i]>upper.d[i]||mx.d[i]<lower.d[i])
		    			return 1;
		    	return 0;
		    }
		    inline const bool unbalanced()
		    {
		    	return son[0]->size>size*alpha||son[1]->size>size*alpha;
		    }
		}*root,memory_pool[N],*tail,*null,*recycle[N];
		int top,flag,cnt;
		point a[N];
		inline const void init()
		{
			tail=memory_pool;
			null=tail++;
			root=null->son[0]=null->son[1]=null;
			for (int i=0;i<k;i++)null->mn.d[i]=inf,null->mx.d[i]=-inf;
		}
		inline tree *spawn(const point &x)
		{
			tree *p=top?recycle[--top]:tail++;
			p->size=1;
			p->range=p->mx=p->mn=x;
			p->son[0]=p->son[1]=null;
			return p;
		}
		inline const void travel(tree *p)
		{
			if (p==null)return;
			travel(p->son[0]);
			a[++cnt]=p->range;
			recycle[top++]=p;
			travel(p->son[1]);
		}
		inline tree *build(int l,int r,int d)
		{
			if (l>r)return null;
			int mid=l+r>>1;f=d;
			nth_element(a+l,a+mid,a+r+1);
			tree *p=spawn(a[mid]);
			if (l==r)return p;
			p->son[0]=build(l,mid-1,(d+1)%k);
			p->son[1]=build(mid+1,r,(d+1)%k);
			p->pushup();
			return p;
		}
		inline const void rebuild(tree *&p,int d)
		{
			cnt=0;
			travel(p);
			p=build(1,cnt,d);
		}
		inline tree **insert(tree *&p,const point &x,int d)
		{
			if (p==null)return p=spawn(x),&null;
			tree **bad=insert(p->son[p->range.d[d]<x.d[d]],x,(d+1)%k);
			p->pushup();
			if (p->unbalanced())bad=&p,flag=d;
			return bad;
		}
		inline const int query(tree *p,const point &x,const point &y)
		{
			if (p==null)return 0;
			if (p->out(x,y))return 0;
			if (p->in(x,y))return p->size;
			return p->at(x,y)+query(p->son[0],x,y)+query(p->son[1],x,y);
		}
	public:
		inline KD_Tree(){init();}
		inline const void insert(int x,int y)
		{
			tree **bad=insert(root,point(x,y),flag=0);
			if (*bad==null)return;
			rebuild(*bad,flag);
		}
		inline const int query(int x1,int y1,int x2,int y2)
		{
			return query(root,point(x1,y1),point(x2,y2));
		}
};
KD_Tree<K>kdt;
int main()
{
	read(n);read(m);
	for (int opt,l,r;m--;)
		if (read(opt),read(l),read(r),opt&1)kdt.insert(l,r);
		else writeln(kdt.query(-inf,l,r,inf));
	return 0;
}
```

---

## 作者：pyyyyyy (赞：7)

#题目链接

[P2184 贪婪大陆](https://www.luogu.org/problemnew/show/P2184)

#思路

树状数组的模板题

>1.只要一个区间的开头在一个节点$i$的左边，那么这个区间包含在区间$1~i$中。
>
>2.只要一个区间的尾部在一个节点$j$的左边，那么这个区间肯定不属于$j$之后的所有区间

所以我们可以搞两个树状数组来做

$tree_{head}[i]$维护$i$之前的开头数量

$tree_{tail}[j]$维护$j$之前的结尾数量

结合样例可以看出来$tree_{head}[j]-tree_{tail}[i]$即为i-j之间的雷种类数

样例分析:

>5 4
>1 1 3
>2 2 5
>1 2 4
>2 3 5

>1
>2

![](https://i.loli.net/2019/07/01/5d1974f00575519008.bmp)

假设要求2到3之间的雷种类数,可以看出$tree_{tail}[1]=0$,$head_{tail}[3]=2$,

所以上述的结论成立
可以自己多搞几组数据看看

#代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<string>
#include<cstring>
#define ll long long int
#define lowbit(x) x & -x
#define N 100000
using namespace std;
inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
int head_tree[N*2],tail_tree[N*2],n,m;
void update_head(int x) {
	while(x<=n) {
		++head_tree[x];
		x+=lowbit(x);
	}
}
void update_tail(int x) {
	while(x<=n) {
		++tail_tree[x];
		x+=lowbit(x);
	}
}
int find_head(int x) {
	int res=0;
	while(x>0) {
		res+=head_tree[x];
		x-=lowbit(x);
	}
	return res;
}
int find_tail(int x) {
	int res=0;
	while(x>0) {
		res+=tail_tree[x];
		x-=lowbit(x);
	}
	return res;
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=m; ++i) {
		int q,x,y;
		cin>>q>>x>>y;
		if(q==1) {
			update_head(x);
			update_tail(y);
		} else {
			cout<<find_head(y)-find_tail(x-1)<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：Drug__Lover (赞：7)

此题由我校神犇zzy讲解，但是他太神了，我就写篇题解代替他吧

**一下只给出思路，代码楼下有**


**我们看题目可以得知这是一个区间修改，区间查询的问题（但似乎又有一点不一样）**

**用两个树状数组维护（以下简称add1，sum1，add2，sum2）**


**对于每一个增加的区间，用add1对左端点加一，add2对右端点加一**

**对于查询每个区间【L，R】**

**用sum1求出从   1~R   中 左端点 的个数**

**sum2求出从   1~L-1   中右端点  的个数**

**用  sum1-sum2 （即减去右端点不在【L，R】中的点，就是修改时没有在【L，R】中修改）可求出【L,R】中的种类数目**



---

## 作者：Drifterming (赞：7)

/\*因为放炸弹的时候不是将前面放的炸弹覆盖，而是累加，所以不是简单的求最大值或者求和。然后我想到了用线段树，在每一个节点下开一个数组，记录下面的炸弹种类，但是想想就会TLE或者RE，所以果断放弃，写树状数组（其实是从一个学长那儿看的）。

（类似前缀和）因为炸弹一放就是一个区间，所以我们可以记录放炸弹的区间的起点l和终点r，表示[l..r]放了一种炸弹。那么我们可以知道一个区间内的炸弹的种类的总数等于[1..r]的炸弹种类的和-[1..l-1]的右端点数。至于为什么是右端点，是因为查询区间可能有当前这种炸弹，如果减去的是左端点，那么就会多减了一种，使答案变小。

所以炸弹种类数=L[1..r](1..r的炸弹种类)-R[1..l-1]（1..r的右端点个数）\*/








```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stack>
#include<algorithm>
#define N 1000050
using namespace std;
int n,m,q,l,r,sum,tree[N][2];    //tree[i][0]表示以i为左端点的炸弹的个数，tree[i][1]表示以i为右端点的炸弹的个数 
int read()        //一开始读入优化写错过了样例全部RE 
{
    int sum=0,f=1;
    char c=getchar();
    for(;(c<'0'||c>'9')&&c!='-';c=getchar());
    if(c=='-') f=-1,c=getchar();
    for(;c>='0'&&c<='9';c=getchar())
    {
        sum=sum*10+c-'0';
    }
    return sum*f;
}
int lowbit(int x)    //找最后一个1的位置 
{
    return x&(-x);
}
void update(int x,int p)
{
    while(x<=n)
    {
        tree[x][p]++;
        x+=lowbit(x);    //找爸爸 
    }
}
int query(int x,int p)
{
    int sum=0;
    while(x>=1)
    {
        sum+=tree[x][p];
        x-=lowbit(x);        //找兄弟 
    }
    return sum;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        q=read();l=read();r=read();
        if(q==1) update(l,0),update(r,1),sum++;        //添加左右端点 
        else printf("%d\n",query(r,0)-query(l-1,1));    //求炸弹种类和 
    }
    return 0;
}
```

---

## 作者：mxr已死 (赞：4)

题解里全是线段树和树状数组，竟然没有写分块的？

其实这道题的核心思想就是：差分。我也是第一次做差分题，看题解里各位大佬的讲解，终于弄懂了。

差分就是处理有多种修改的问题。你不需要记录一段区间，只需要记录头尾标记就行。想询问一段区间内有多少种修改，只需要查询1到询问区间末尾的头标记个数，再查询1到询问区间头标记前一个的尾标记个数，做一个差就行了。

想到这里，做这道题就变成了：你需要写一种数据结构，可以维护单点修改和区间查询。

树状数组肯定是可以的，但这道题没必要写，还容易错。那写什么呢？（~~线段树是啥，这辈子都不可能写线段树~~）

肯定是写又短又好调的分块啊！

分块想必各位大佬已经知道了，如果不知到可以去看[我的博客](https://www.cnblogs.com/mxrmxr/p/9912406.html)看看。

下面是我十分不优秀的分块代码：

```c
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<set>
#include<cmath>
#include<algorithm>
#include<cstring>
#define rint register int
#define N 100005
using namespace std;

inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}

inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return ;
}
 
int blo,n,m;
int v1[N],v2[N],bl1[N],bl2[N],tag1[N],tag2[N];

inline void add1(int l,int k)
{
    v1[l]+=k;tag1[bl1[l]]+=k;
    return ;
}
 
inline void add2(int l,int k)
{
    v2[l]+=k;tag2[bl2[l]]+=k;
	return ;	
} 
 
inline int query1(int l,int r)
{
    int ans=0;
    for(rint i=l;i<=min(bl1[l]*blo,r);++i) ans+=v1[i];
    if(bl1[l]!=bl1[r])
    {
        for(rint i=(bl1[r]-1)*blo+1;i<=r;++i) ans+=v1[i];
    }
    for(rint i=bl1[l]+1;i<=bl1[r]-1;++i) ans+=tag1[i];
    return ans;
}

inline int query2(int l,int r)
{
    int ans=0;
    for(rint i=l;i<=min(bl2[l]*blo,r);++i) ans+=v2[i];
    if(bl2[l]!=bl2[r])
    {
        for(rint i=(bl2[r]-1)*blo+1;i<=r;++i) ans+=v2[i];
    }
    for(rint i=bl2[l]+1;i<=bl2[r]-1;++i) ans+=tag2[i];
    return ans;
}

int main()
{
    n=read(),m=read();blo=sqrt(n);
    for(rint i=1;i<=n;++i) v1[i]=0,v2[i]=0;
    for(rint i=1;i<=n;++i) bl1[i]=(i-1)/blo+1,bl2[i]=(i-1)/blo+1;
    for(rint i=1;i<=n;++i) tag1[bl1[i]]+=v1[i],tag2[bl2[i]]+=v2[i];
    for(rint i=1;i<=m;++i)
    {
        int q=read(),l=read(),r=read();
        if(q==1) add1(l,1),add2(r,1);
        else write(query1(1,r)-query2(1,l-1)),puts(" ");
    }
    return 0;
}
```

---

## 作者：Delva (赞：3)

做完之后看了看题解，才发现和我的做法都不同。。。

我用的是十分传统的线段树，死板地维护（太菜想不出简单的方法）。

Node是线段树，维护的信息是Msg：

**num**：当前节点区间的地雷种数

**outl**：超出节点区间左边的地雷种数

**outr**：超出节点区间右边的地雷种数

这样，一般的区间信息就可以用这种方式合并了：
```
	ret.num=m1.num+m2.num-m1.outr;//m1.outr==m2.outl
	ret.outl=m1.outl;
	ret.outr=m2.outr;
```  
但是pushDown可就没有那么简单了。

为了做到区间装地雷，我一共打了5个标记：

**adds**：与outs对应的懒标记

**addl**：与outl对应的懒标记

**addr**：与outr对应的懒标记

(以下标记尤为注意)

我们会发现，只用前三个标记pushDown，把标记直接传给儿子，无法解决一种特殊情况，就是区间在查询区间的最左边或者最右边。

就拿在'查询区间最左边'的节点k来说（结合add函数中的代码），此时ql<k->l不成立(因为ql==k->l)，导致addl标记+=0，而pushDown又**直接把标记应用到 _两个_ 儿子上**：k的左儿子的addl+=0，更新正确，而k的右儿子的addl+=0就不对了，因为此时ql<k->ch[1]成立了，应为addl+=1，与父亲k不符。

为了解决这一问题，我们特地引入两个标记：

**isL**：是否是查询区间最左边的节点

**isR**：是否是查询区间最右边的节点

（本来是bool类型，可是也可能有上面的isL/isR标记传下来）

如果出现isL，就把k的右儿子的左边超出种数加回来；

如果出现isR，就把k的左儿子的右边超出种数加回来。
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m;
struct Msg{
	int num,outl,outr;
	Msg(){num=outl=outr=0;}
	Msg(int a,int b,int c){num=a,outl=b,outr=c;}
};
Msg combine(Msg m1,Msg m2){//有序的信息合并，用于pushUp与query函数
	Msg ret=Msg();
	ret.num=m1.num+m2.num-m1.outr;
	ret.outl=m1.outl;
	ret.outr=m2.outr;
	return ret;
}
struct Node *null;
struct Node{
	Node *ch[2];
	Msg msg;
	int l,r,mid;
	int addl,addr,adds,isL,isR;
	Node(int ll,int rr){ch[0]=ch[1]=null;l=ll,r=rr,mid=ll+rr>>1;addl=addr=adds=isL=isR=0;msg=Msg();}
	void pushUp(){msg=combine(ch[0]->msg,ch[1]->msg);}
	void addLNode(int al){addl+=al;msg.outl+=al;}
	void addRNode(int ar){addr+=ar;msg.outr+=ar;}
	void addNode(int as){adds+=as;msg.num+=as;}
	void pushDown(){//只有adds,addl,addr直接传给两个儿子
		if(isL){ch[1]->addLNode(isL);ch[0]->isL+=isL;isL=0;}
		if(isR){ch[0]->addRNode(isR);ch[1]->isR+=isR;isR=0;}
		if(adds){ch[0]->addNode(adds);ch[1]->addNode(adds);adds=0;}
		if(addl){ch[0]->addLNode(addl);ch[1]->addLNode(addl);addl=0;}
		if(addr){ch[0]->addRNode(addr);ch[1]->addRNode(addr);addr=0;}
	}
}*root;
void build(Node *&k){//build出的是空线段树，不用pushUp
	if(k->r==k->l)return;
	build(k->ch[0]=new Node(k->l,k->mid));
	build(k->ch[1]=new Node(k->mid+1,k->r));
}
void add(int ql,int qr,Node *&k=root){
	if(ql>k->r||qr<k->l)return;
	if(ql<=k->l&&qr>=k->r){//到达需要修改的区间
		if(ql==k->l)++k->isL;
		if(qr==k->r)++k->isR;
		k->addLNode(ql<k->l);
		k->addRNode(qr>k->r);
		k->addNode(1);
		return;
	}
	k->pushDown();
	add(ql,qr,k->ch[0]),add(ql,qr,k->ch[1]);
	k->pushUp();
}
Msg query(int ql,int qr,Node *&k=root){
	if(ql<=k->l&&qr>=k->r)return k->msg;
	k->pushDown();
	if(qr<=k->mid)return query(ql,qr,k->ch[0]);
	if(ql>k->mid)return query(ql,qr,k->ch[1]);
	return combine(query(ql,qr,k->ch[0]),query(ql,qr,k->ch[1]));
}
int main(){int O,l,r;
	scanf("%d%d",&n,&m);
	null=new Node(0,0);
	build(root=new Node(1,n));
	while(m--){
		scanf("%d%d%d",&O,&l,&r);
		if(O==1)add(l,r);
		else printf("%d\n",query(l,r).num);
	}
}

```

---

## 作者：小蒟蒻皮皮鱼 (赞：2)

本题解同步发布于[个人博客](https://www.cnblogs.com/lcezych/p/12181066.html)

做法：差分+线段树

首先看到题目中的区间修改，显然可以用线段树+差分做，于是就设每次区间修改的左端点为$1$，右端点为$-1$。

考虑怎么利用已有的差分数组。

首先题目有一个值得说明的地方就是他一次操作埋下的地雷并不会覆盖之前埋下的地雷~~(我就因为这个浪费了一次提交)~~。

首先先看一组数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5g4dfzp.png)

区间分别为$[1,3],[2,7],[5,6]$，查询区间$[4,6]$，经过手推得到答案应该是$2$。

让我们看看$2$怎么表示

区间$[1,3]$是在左端点之前结束的，所以它不会对答案造成影响。

区间$[2,7]$是覆盖了整个询问区间，显然会使答案$+1$。

区间$[5,6]$在询问区间内开始，在询问区间内结束，也会使答案$+1$。

稍微一思考，首先可以得到一个结论，区间并不重要，重要的是端点，因为我们只关心数量而不是具体的数。

那么显然在询问区间右端点以前的开始标记(包括右端点)会使答案$+1$，在询问区间左端点以前的结束标记(不包括左端点)会使答案$-1$。

到了这里，我们就可以实现了。维护两棵线段树，一棵表示开始标记，记作$Tree1$，另一棵表示结束标记，记作$Tree2$。那么每次查询的时候，记查询区间为$[l,r]$答案就是$Tree1[r]-Tree2[l-1]$。

ac code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100005;
int n, m;
struct Tree
{
	int ad, ct;//add cut
}tree[N << 2];

void add1(int cnt, int l, int r, int x)
{
	if(l == r)
	{
		tree[cnt].ad += 1;
		return;
	}
	int mid = l + r >> 1;
	if(mid >= x) add1(cnt << 1, l, mid, x);
	if(mid < x) add1(cnt << 1 | 1, mid + 1, r, x);
	tree[cnt].ad = tree[cnt << 1].ad + tree[cnt << 1 | 1].ad;
}

void add2(int cnt, int l, int r, int x)
{
	if(l == r)
	{
		tree[cnt].ct += 1;
		return;
	}
	int mid = l + r >> 1;
	if(mid >= x) add2(cnt << 1, l, mid, x);
	if(mid < x) add2(cnt << 1 | 1, mid + 1, r, x);
	tree[cnt].ct = tree[cnt << 1].ct + tree[cnt << 1 | 1].ct;
}

int query1(int cnt, int l, int r, int nl, int nr)
{
	if(l >= nl && r <= nr) return tree[cnt].ad;
	int mid = l + r >> 1, ans = 0;
	if(mid >= nl) ans += query1(cnt << 1, l, mid, nl, nr);
	if(mid < nr) ans += query1(cnt << 1 | 1, mid + 1, r, nl, nr);
	return ans;
}

int query2(int cnt, int l, int r, int nl, int nr)
{
	if(l >= nl && r <= nr) return tree[cnt].ct;
	int mid = l + r >> 1, ans = 0;
	if(mid >= nl) ans += query2(cnt << 1, l, mid, nl, nr);
	if(mid < nr) ans += query2(cnt << 1 | 1, mid + 1, r, nl, nr);
	return ans;
}

int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1, q, l, r; i <= m; i ++)
	{
		scanf("%d%d%d", &q, &l, &r);
		if(q == 1) add1(1, 1, n, l), add2(1, 1, n, r);
		else if(q == 2)
		{
			printf("%d\n", query1(1, 1, n, 1, r) - query2(1, 1, n, 1, l - 1));
		}
	}
}
```



---

## 作者：qwaszx (赞：2)

设询问为$(l,r)$，某个修改为$(L,R)$，那么这个修改对这个询问产生贡献当且仅当$L\leq r \&\&R\geq l$，这个就等于$L\leq r\&\&(1-[R<l])=(L\leq r)-(L\leq r\&\&R<l$，又因为有$L\leq R<l\leq r$所以直接就是$(L\leq r)-(R<l)$，树状数组维护一下就好了

当然也可以三维偏序...

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=2e6;
int n,m;
struct BIT
{
    int a[N];
    int query(int x){int ans=0;for(;x;x-=x&-x)ans+=a[x];return ans;}
    void update(int x){for(;x<=n;x+=x&-x)a[x]++;}
}s[2];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int opt,l,r;
        scanf("%d%d%d",&opt,&l,&r);
        if(opt==1)s[0].update(l),s[1].update(r);
        else printf("%d\n",s[0].query(r)-s[1].query(l-1));
    }
}
```

---

## 作者：斗神_君莫笑 (赞：2)

本题在线段树中融入了差分的思想   
我们注意到每次布上的地雷都和前一种不同  
所以不用维护地雷的种类  
我们可以只维护区间地雷起终点的个数  
这样每次查询(1,1,l-1)和(1,1,r)，就知道有多少种地雷在查询区间之前就结束放置了  
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Node{
	int l,r,sum1,sum2;
}T[1000010];
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
}
void pushup(int p){
	T[p].sum1=T[lc].sum1+T[rc].sum1;
	T[p].sum2=T[lc].sum2+T[rc].sum2;
}
void update1(int p,int q){
	if(T[p].l==T[p].r&&T[p].l==q){
		T[p].sum1++;return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(q<=mid)update1(lc,q);
	if(q>mid)update1(rc,q);
	pushup(p);
}
void update2(int p,int q){
	if(T[p].l==T[p].r&&T[p].l==q){
		T[p].sum2++;return;
	}
	int mid=(T[p].l+T[p].r)>>1;
	if(q<=mid)update2(lc,q);
	if(q>mid)update2(rc,q);
	pushup(p);
}
int query1(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)return T[p].sum1;
	int mid=(T[p].l+T[p].r)>>1,ans=0;
	if(ql<=mid)ans+=query1(lc,ql,qr);
	if(qr>mid)ans+=query1(rc,ql,qr);
	return ans;
}
int query2(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)return T[p].sum2;
	int mid=(T[p].l+T[p].r)>>1,ans=0;
	if(ql<=mid)ans+=query2(lc,ql,qr);
	if(qr>mid)ans+=query2(rc,ql,qr);
	return ans;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i=1;i<=m;++i){
		int t,l,r;
		scanf("%d%d%d",&t,&l,&r);
		if(t==1)
			update1(1,l),update2(1,r);
		if(t==2)
			printf("%d\n",query1(1,1,r)-query2(1,1,l-1));
	}
	return 0;
}
```


---

## 作者：wjyyy (赞：2)

   [博客传送门！](http://www.wjyyy.top/844.html)

   一个类似区间染色求种类数的题。（为什么大家写的和我都不一样。。。）
   
   一开始看上去，不是一个线段树区间染色的题吗。。。手玩了一下样例发现原来地雷是可以覆盖的啊，![笑容渐渐消失](http://www.wjyyy.top/wp-content/uploads/2018/07/006HJgYYgy1fg626pydevg304w03ywei.gif)开始重新审视这个题。

   和区间染色类似，而因为区间染色（如果可覆盖）在查询时合并区间要看**左孩子的最右点**和**右孩子的最左点**是否一致，一致则把种类-1**【容斥原理】**。这样只用多维护两个变量+lazytag就可以了。不过这个题不能覆盖，就要想办法换个思路维护。

   因为这个题的地雷种类只会增加不会减少，因此一旦左孩子的最右点和右孩子的最左点颜色（编号）相同，它们就永远相同，对这个容斥产生1个贡献，因此我们可以维护一个区间最左点与左相邻区间最右点相同颜色的个数（最左或最右任选其一维护，我写的是最左）作为**重复标**记。在线段树区间change时，一旦出现跨越了两个儿子的修改，那就要把右儿子的左端点重复标记++了。同样，lazytag在标记与下放时，如果**lazy不等于0**，依然要把右儿子的左端点++，同时维护的**lazyl（上面传下来的左端点tag）**也要加上去，并延续到左儿子上。
   
## Code：
```cpp
#include<cstdio>
#include<cstring>
#define ls (k<<1)
#define rs (k<<1|1)
#define mid (l+r>>1)
#define Mid (t[k].l+t[k].r>>1)
struct node
{
    int l,r,v,lazy;
    int ll,lazyl;
    node(int l,int r)
    {
        this->l=l;//区间位置
        this->r=r;
        ll=0;//左端点的重复标记
        v=0;//区间不互相干扰的颜色种类
        lazy=0;
        lazyl=0;
    }
    node()
    {
        ll=0;
        v=0;
        lazy=0;
        lazyl=0;
    }
}t[410000];
void build(int k,int l,int r)
{
    t[k]=node(l,r);
    if(l==r)
        return;
    build(ls,l,mid);
    build(rs,mid+1,r);
}
void pushdown(int k)//pushdown是关键
{
    if(t[k].l==t[k].r)
    {
        t[k].lazy=0;
        t[k].lazyl=0;
        return;
    }
    t[ls].v+=t[k].lazy;
    t[ls].ll+=t[k].lazyl;
    t[ls].lazyl+=t[k].lazyl;
    t[ls].lazy+=t[k].lazy;
    t[rs].v+=t[k].lazy;
    if(t[k].lazy)
    {
        t[rs].ll+=t[k].lazy;//有时多种颜色会一起传下来
        t[rs].lazyl+=t[k].lazy;
    }
    t[rs].lazyl+=t[k].lazyl;
    t[rs].lazy+=t[k].lazy;
    t[k].lazy=0;
    t[k].lazyl=0;
}
void change(int k,int l,int r,int x)
{
    if(t[k].l==l&&r==t[k].r)
    {
        t[k].lazy++;
        t[k].v++;
        return;
    }
    t[k].v++;
    pushdown(k);
    if(r<=Mid)
        change(ls,l,r,x);
    else if(l>Mid)
        change(rs,l,r,x);
    else
    {
        t[rs].ll++;//修改右孩子的左端点重复标记
        t[rs].lazyl++;//并下放到右孩子的左孩子的lazytag
        change(ls,l,Mid,x);
        change(rs,Mid+1,r,x);
    }
    return;
}
int ask(int k,int l,int r)
{
    pushdown(k);
    if(t[k].l==l&&t[k].r==r)
        return t[k].v;
    if(r<=Mid)
        return ask(ls,l,r);
    else if(l>Mid)
        return ask(rs,l,r);
    else
        return ask(ls,l,Mid)+ask(rs,Mid+1,r)-t[rs].ll;//减去重复标记
}
int main()
{
    int n,m,op,l,r;
    scanf("%d%d",&n,&m);
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&op,&l,&r);
        if(op==1)
            change(1,l,r,i);
        else
            printf("%d\n",ask(1,l,r));
    }
    return 0;
}
```

---

## 作者：Smallbasic (赞：1)

考试的时候想到了正解然而忘了l-1调就以为是错的然后改成暴力。。。于是Rank1->inf

这道题显然可以把每次埋雷转化成新增一段区间，查询就是与它有交集的区间个数。

显然这东西可以两个树状数组维护前面有多少左端点，后面有多少右端点，做个差就好了。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

int n, m, l, r, opt, bomb = 0;

inline int read() {
	register int s = 0;
	register char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s;
}

inline int lowbit(int x) {
	return x & -x;
}

int tree1[100005], tree2[100005];

inline void add1(int x) {
	int t = x;
	while (t <= n) {
		++tree1[t];
		t += lowbit(t);
	}
}


inline int query1(int x) {
	int t = x, ret = 0;
	while (t >= 1) {
		ret += tree1[t];
		t -= lowbit(t);
	} return ret;
}

inline void add2(int x) {
	int t = x;
	while (t <= n) {
		++tree2[t];
		t += lowbit(t);
	}
}


inline int query2(int x) {
	int t = x, ret = 0;
	while (t >= 1) {
		ret += tree2[t];
		t -= lowbit(t);
	} return ret;
}

inline int min_(int a, int b) {
	return a < b ? a : b;
}

int main() {
	n = read(); m = read();
	memset(tree1, 0, sizeof(tree1)); memset(tree2, 0, sizeof(tree2));
	while (m--) {
		opt = read(); l = read(); r = read();
		if (opt == 1) { ++bomb; add1(l); add2(r); }
		else printf("%d\n", query1(r) - query2(l - 1));
	} return 0;
}
```


---

## 作者：Erusel (赞：1)

~~题意特别容易理解错~~

先用通俗的语言解释一下题意：

现在你有$k$条不同颜色的线段

颜色从$1$到$k$,按照这个次序依次覆盖

之后的颜色不会覆盖之前的颜色

问$[l,r]$区间中有几种不同的颜色

我们可以考虑拆分成两个东西

一个是$[1,r]$,一个是$[l,n]$

简单来说，就是确定这个区间左端点的右边和右端点的左边

Step 1:确定$[1,r]$

可以考虑如果一条线段的开头再$r$的左边，那么$[1,r]$中就存在这条线段的颜色

Step 2:确定$[l,n]$

可以考虑如果一条线段的结尾在$l$的左边，那么$[l,n]$中不存在这条线段的颜色

因此，只要用两个树状数组分别维护一下

有多少条线段的开头再$r$的左边

，有多少条线段的结尾在$l$的左边即可

时间复杂度：$O(nlogn)$

code:

```
#include<bits/stdc++.h>

#define N 100005
#define rd(x) x=read()

using namespace std;

int n,m;
int t[N][2];

inline int read()
{
    int f=1,x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    return x*f;
}
 
int lowbit(int x){return x&(-x);}
void update(int x,int p){while(x<=n)t[x][p]++,x+=lowbit(x); }
int query(int x,int p){int sum=0;while(x>=1)sum+=t[x][p],x-=lowbit(x);return sum;}

int main()
{
    rd(n),rd(m);
    while(m--)
    {
    	int opt,l,r;
    	rd(opt),rd(l),rd(r);
        if(opt==1)update(l,0),update(r,1);
        else printf("%d\n",query(r,0)-query(l-1,1));
    }
    return 0;
}
```



---

## 作者：VCVCVCFop_zz (赞：1)

哦。。一开始太单纯了题目看错

本题可以用线段树/树状数组解，楼下已经用大佬讲了线段树的做法，本蒟蒻就来说下树状数组

用两个树状数组来维护1..x之间的l数量和r数量

因为l显然在r前面，所以要求L到R之间的种类，就等于1..R之间出现的地雷种类-1..L之间结束放置的地雷种类

也就是ans=numl[R]-numr[L]

附代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int f[1000001],f1[1000001];    int n,m,x,y,z;
inline int lowbit(int t){return t&-t;}
inline void add(int x,int y)
{
    for (int i=x;i<=n;i+=lowbit(i))    f[i]+=y;
}
inline int get(int x)
{
    int sum=0;
    for (int i=x;i>0;i-=lowbit(i)) sum+=f[i];
    return sum;
}
inline void add1(int x,int y)
{
    for (int i=x;i<=n;i+=lowbit(i))    f1[i]+=y;
}
inline int get1(int x)
{
    int sum=0;
    for (int i=x;i>0;i-=lowbit(i)) sum+=f1[i];
    return sum;
}
int main()
{
    scanf("%d%d",&n,&m);
      for(int i=1;i<=m;i++)
      {
          scanf("%d%d%d",&x,&y,&z);
          if(x==1)
          {
              add(y,1);
              add1(z,1);
          }
          else
          {
              printf("%d\n",get(z)-get1(y-1));
          }
      }
    return 0;
}
```

---

## 作者：Treaker (赞：0)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 树状数组 + 差分

这道题其实看起来挺简单的，但是做起来发现好像不是那么好做。。。

注意：这里的雷是累加的，不是覆盖。

那么我们考虑，什么样的雷会在这个区间出现。

一定是，左端点在区间右端点及左边，右端点在区间左端点及右边。

也就是说我们只需要知道，左端点分布在区间右端点及左边的雷的数量，然后减去右端点在区间左端点的左边的雷的数量，就是分布在这一段的雷的数量。

所以我们差分一下,只记录左端点和右端点和右端点即可。

至于前缀和，用树状数组维护即可。。

献上代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int read()
{
	int x = 0 , f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + ch - '0'; ch = getchar();}
	return x * f;
}
const int N = 1e5+5;
int n , m;
int suml[N] , sumr[N];
struct BIT
{
	inline int lowbit(int x) {return x & (-x);}
	inline void add(int x,int *tr) {while(x <= n) tr[x] ++ , x += lowbit(x);}
	inline int ask(int x,int *tr) {int res = 0; while(x) res += tr[x] , x -= lowbit(x); return res;}
	inline void LOL()
	{
		n = read(); m = read();
		for(int i = 1 , l , r , opt;i <= m;i ++)
		{
			opt = read(); l = read(); r = read();
			if(opt & 1) add(l,suml) , add(r,sumr);
			else printf("%d\n",ask(r,suml) - ask(l - 1,sumr));
		}
	}
}DNF;
int main()
{
	DNF.LOL();
	return 0;
}
```


---

## 作者：abandentsky (赞：0)

这个题目自己没有想出来，看的楼下大佬提到用差分和线段树才意识到的。树状数组做法：
        对于一个区间【A,B】里面有几种地雷我们可以看成【1，B】里面地雷的个数减去【1，A】的地雷个数。其中减去的时候我们应该不包含A这个点。问题来了，地雷个数怎么标记呢？对于题目给的每个地雷区间[m,n]。标记每个区间的左端点也就是m作为开始，这样【1，B】就是求到B有几个m（左端点）。而
【1，A】就是求有多少个右端点也就是n。这样开两个树状数组，第一个统计左端点，第二个统计右端点。然后做差就好了。
```c
#include<bits/stdc++.h>
#define MAXN 100005
using namespace std;

int n,m;

int lowbit(int x)
{
    return (x&((-1)*x));
}

struct BIT
{
    int c[MAXN];

    void add(int x,int d)
    {
        while(x<=n)
        {
            c[x]+=d;
            x+=lowbit(x);
        }
    }

    int sum(int x)
    {
        int cnt=0;
        while(x>0)
        {
            cnt+=c[x];
            x-=lowbit(x);
        }
        return cnt;
    }
};

BIT sa,sb;
int op,L,R;

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d %d",&op,&L,&R);
        if(op==1)
        {
            sa.add(L,1);
            sb.add(R,1);
        }
        else
        {
            printf("%d\n",sa.sum(R)-sb.sum(L-1));
        }
    }
    return 0;
}

```


---

## 作者：mzy2003 (赞：0)

看到题目，觉得与染色那道题很像，但这题是可重叠不覆盖的。可以~~很容易~~想到差分，但我太菜了，连差分都想不到，于是考虑区间修改区间查询线段树。

sum[i]:结点i的区间的地雷种数

h[i]:完全覆盖i的区间的地雷种数（就是i的区间每一个位置均有这h[i]种地雷）

lr[i]:左儿子与右儿子都有的地雷种数

易得pushup:sum[rt]=sum[lson]+sum[rson]-lr[rt]+h[rt];

区间修改：

1.每次修改值均为一；（因为每次加一种）

2.完全覆盖i的区间：加h[i]；**(别忘pushup)**

3.不完全覆盖i的区间：向下递归，若左右儿子均有，则lr[i]++；**(别忘pushup)**

区间询问：

1.完全覆盖i的区间：直接返回sum[i]；

2.不完全覆盖i的区间：向下递归并累加，若左右儿子均有，则返回值减lr[i]；

萌新投稿，讲解不嘉，请结合代码理解：

```cpp
#include <bits/stdc++.h>
#define ls rt<<1,l,mid
#define rs rt<<1|1,mid+1,r
#define lson rt<<1
#define rson rt<<1|1
using namespace std;
const int maxn=1000000;
int h[maxn],lr[maxn],sum[maxn];
int n,m,fa,tot,x,y,z;
void change(int rt,int l,int r,int x,int y)
{
	if (x<=l && r<=y)
	{
		h[rt]++;
		sum[rt]=sum[lson]+sum[rson]-lr[rt]+h[rt];
		return;
	}
	int bo1=0,bo2=0;
	if (x>r || y<l) return;
	int mid=l+r>>1;
	if (mid>=x) change(ls,x,y),bo1=1;
	if (mid<y) change(rs,x,y),bo2=1;
	if (bo1&&bo2) lr[rt]++;
	sum[rt]=sum[lson]+sum[rson]-lr[rt]+h[rt];
}
int ask(int rt,int l,int r,int x,int y)
{
	if (x<=l && r<=y)
	return sum[rt];
	if (x>r || y<l) return 0;
	int mid=l+r>>1;
	int ca=0,bo1=0,bo2=0;
	if (mid>=x) ca=ask(ls,x,y),bo1=1;
	if (mid<y) ca+=ask(rs,x,y),bo2=1;
	if (bo1&&bo2) ca-=lr[rt];
	ca+=h[rt];
	return ca;
}
int main() {
	scanf("%d%d",&n,&m);
	fa=1;
	while (fa<n) fa*=2;
	for (int i=1;i<=m;i++)
	{
		scanf("%intd",&x);//防抄
		if (x==1)
		{
			scanf("%d%d",&x,&y);
			change(1,1,fa,x,y);
		}
		else {
			scanf("%d%d",&x,&y);
			printf("%d\n",ask(1,1,fa,x,y));
		}
	}
	return 0;
}

```

（话说这区间修改区间查询线段树竟然没有懒标记，真是奇妙）

---

## 作者：封禁用户 (赞：0)

# ZKW线段树做法
翻了翻题解，发现没有用**ZKW线段**树写的，于是我决定写一篇ZKW题解。  
这个题的思路就不详细讲了，前面题解已经讲得详细了，我就补一下ZKW的写法吧。

ZKW线段树和树状数组类似，单点修改，区间查询，用循环来实现，没有线段树一样的巨大常数，而且，代码**非常好写，非常好写，非常好写**。  

具体给大家推荐一篇博客吧 ：[zkw线段树 传送门](https://blog.csdn.net/keshuqi/article/details/52205884)  
如果想详细了解的，建议去看看zkw的《**统计的力量**》  


------------

代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+7;
int n,m;

struct ZKW_SegmentTree
{
	int sumL[N<<4],sumR[N<<4],M; 
	#define lc rot<<1
	#define rc rot<<1^1
    
//M = (1 << (int)log2(n) - 1); 因为n已经是2的整次方了，所以M就是n-1 
	void GetM() {M = n-1;}
    
//	void Build() 这个题不需要建树 所以只需要求出来M即可 
//	{
//		M = (1 << (int)(log2(n))) - 1;
//		memset(sum, 0, sizeof(sum));
//		for(int j = 1,i = 1 + M; i <= n + M; i++,j++)
//			sum[i] = arr[j];
//		for(int rot = M; rot >= 1; rot--)
//			sum[rot] = sum[lc] + sum[rc]; 
//	}
	
	void AddL(int rot) //两个Add 两个Enquiry 记录左端点和右端点 
	{
		sumL[rot+=M] ++;
		for(rot>>=1; rot; rot>>=1)
			sumL[rot] = sumL[lc] + sumL[rc];
	}
	
	void AddR(int rot)
	{
		sumR[rot+=M] ++;
		for(rot>>=1; rot; rot>>=1)
			sumR[rot] = sumR[lc] + sumR[rc];
	}
	
	int EnquiryL(int l, int r)
	{
		int ans = 0;
		for(l += M-1, r += M+1; l^r^1; l>>=1, r>>=1) 
		{
			if(~ l & 1) ans += sumL[l^1];
			if(  r & 1) ans += sumL[r^1];
		}
		return ans;
	}
	
	int EnquiryR(int l, int r)
	{
		int ans = 0;
		for(l += M-1, r += M+1; l^r^1; l>>=1, r>>=1) 
		{
			if(~ l & 1) ans += sumR[l^1];
			if(  r & 1) ans += sumR[r^1];
		}
		return ans;
	}
}T;

int main()
{
	scanf("%d %d",&n,&m);
	if(n != 1 << (int)log2(n)) n = 1 << ((int)log2(n) + 1); //把n变成2的整次方 
	T.GetM();
	for(int t1, t2, t3, i = 0; i < m; i++)
	{
		scanf("%d %d %d", &t1, &t2, &t3);
		if(t1 == 1)
			T.AddL(t2),T.AddR(t3); 
		if(t1 == 2)
			printf("%d\n",T.EnquiryL(1,t3) - T.EnquiryR(1,t2)); //答案便是这个了 
	}
 	return 0;
}
```


---

## 作者：卫宫 (赞：0)

**tips：这题的标签是骗人的，明明树状数组最方便（明明是我太弱233）**
 
 求区间【i，j】内的地雷数，其实只要算j之前的头的个数减去i钱的尾的个数。但有一点要注意：**j是头的话会使地雷种数+1，但i是尾的时候不会有影响**
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int c1[500001],c2[500001],i,j,n,m,k,l,ans[500001],lans,t;
void update(int x){
  for (;x<=n;x+=x&-x)
      c1[x]++;
}	//记录头的个数  
void updatealther(int x){
  for (;x<=n;x+=x&-x)
      c2[x]++;
}	  //记录尾的个数（fgo玩家的恶趣味）
int ask(int x){
    int ans1=0;
  	for (;x>0;x-=x&-x)
      ans1+=c1[x];
    return ans1;  
} 
int askalther(int x){
    int ans2=0;
  	for (;x>0;x-=x&-x)
      ans2+=c2[x];
    return ans2;  
} 
main(){
    cin>>n;
    cin>>m;   
    for (i=1;i<=m;i++) {
        cin>>j>>k>>l;
        if (j==1) {
                   update(k);
                   updatealther(l);
        }
        if (j==2) {
            lans++;
            ans[lans]=ask(l)-askalther(k-1);           
        }
    } 
    for (i=1;i<=lans;i++){
        printf("%d\n",ans[i]);
    }
}



---

## 作者：吾王美如画 (赞：0)

### 唔姆

这道题本来没打算做的，后来是这位 [AK巨佬](https://www.luogu.org/space/show?uid=119261) 教我做的，提前%一下

言归正传，来做这道题的一看就知道是线段树吧。先开始我就没看清楚，只用一个线段树后来才发现是问有多少种树。2333于是大佬关键时刻伸出援手，告诉我要**两个**线段树来维护。于是乎，这用两个线段树维护什么呢？。。。。。我们就很快想到了差分，因为我们可以看出在一段区间里，地雷的种数就等于到这段区间的**右结点**为止有多少个赋值时的**左结点**，减去到这个区间的**左节点**为止有多少个赋值时的**右节点**![](https://cdn.luogu.com.cn/upload/pic/44184.png)
如图，除了黑色的长线以外，其他每种颜色的线各代表一种地雷。现在我们要查询黑色方框内有多少种颜色。按照我们之前推出的规律，应该一共是有4-1=3种。大家可以自己领悟下。

唔姆，又到了大家喜闻乐见的贴代码时间。蒟蒻的码风有毒，请大佬们见谅
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define maxn 1000001
#define ll long long
using namespace std;
ll n,m,ans1[maxn*2],tag1[maxn*2],ans2[maxn*2],tag2[maxn*2],b,c;
void up1(ll p){
     ans1[p]=ans1[p*2]+ans1[p*2+1];
}
void down1(ll l,ll r,ll p){
     tag1[p*2]+=tag1[p];
     ans1[p*2]+=tag1[p];
     tag1[p*2+1]+=tag1[p];
     ans1[p*2+1]+=tag1[p];
     tag1[p]=0;
}
void up2(ll p){
     ans2[p]=ans2[p*2]+ans2[p*2+1];
}
void down2(ll l,ll r,ll p){
     tag2[p*2]+=tag2[p];
     ans2[p*2]+=tag2[p];
     tag2[p*2+1]+=tag2[p];
     ans2[p*2+1]+=tag2[p];
     tag2[p]=0;
}
void sta(ll l,ll r,ll p){
     if ((r==b)&&(l==b)){ans1[p]++;
               tag1[p]++;
               return;
               }
     down1(l,r,p);
     ll mid=(l+r)/2;
     if (b>mid) sta(mid+1,r,p*2+1);else sta(l,mid,p*2);
     up1(p);
}

void end(ll l,ll r,ll p){
     if ((r==c)&&(l==c)){ans2[p]++;
               tag2[p]++;
               return;
               }
     down2(l,r,p);
     ll mid=(l+r)/2;
     if (c>mid) end(mid+1,r,p*2+1);else end(l,mid,p*2);
     up2(p);
}
ll search1(ll l,ll r,ll p){
              ll sum=0;
              if (r<=c) return ans1[p];
              ll mid=(r+l)/2;
              down1(l,r,p);
              sum+=search1(l,mid,p*2);
              if (c>mid) sum+=search1(mid+1,r,p*2+1);
              return sum;
}
ll search2(ll l,ll r,ll p){
              ll sum=0;
              if (r<b) return ans2[p];
              ll mid=(r+l)/2;
              down2(l,r,p);
              sum+=search2(l,mid,p*2);
              if (b-1>mid) sum+=search2(mid+1,r,p*2+1);
              return sum;
}
int main(){
    cin>>n>>m;
    for(ll i=1;i<=m;i++){
           ll a;
           scanf("%lld",&a);
           if (a==1){scanf("%lld%lld",&b,&c);
                     sta(1,n,1);
                     end(1,n,1);}
           else {scanf("%lld%lld",&b,&c);
                 printf("%lld\n",search1(1,n,1)-search2(1,n,1));};
    }
    return 0;
    //orz wlq       
}
```

---

## 作者：L_M_ (赞：0)

真是一道好题啊！！！

第一眼看这道题，我就开始思考传统线段树，然而经过不懈的努力后，我...失败了orz...（好像题解有大佬写的纯粹线段树%%%

进入正题，这道题需要一些不寻常的思路，经常写树状数组加差分的大佬可能就一眼秒了吧orz

我们发现，对于这道题，我们不能进行区间加和然后询问区间最大值或者区间和之类的，有很多例子可以hack掉这个想法。在区间的思路失效之后，我们就考虑单点修改，然后用类似差分的思想处理询问

具体来说，我们维护两个sum,suml表示左端点的sum，sumr同理；对于每一个操作1，我们将l端点的suml++，r端点的sumr++

在统计答案时，我们考虑[1,r]的所有左端点，这些点都可能为答案做贡献，然而我们还要删除那些右端点在l之前的，因为这些地雷的区间不在[l,r]之间，是不合法的

有以上的思路后，我们只要用支持单点修改，区间查询的数据结构即可，树状数组就是一个不错的选择

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cmath>
using namespace std;
inline int read()
{
	int ans = 0,op = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		if(ch == '-') op = -1; 
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		(ans *= 10) += ch - '0';
		ch = getchar();
	}
	return ans * op;
}
const int maxn = 1e5 + 1;
int lowerbit[maxn];
int suml[maxn << 2],sumr[maxn << 2];
int n,m;
void addel(int x)
{
	while(x <= n)
	{
		suml[x]++;
		x += lowerbit[x];
	}
}
int queryl(int x)
{
	int ans = 0;
	while(x)
	{
		ans += suml[x];
		x -= lowerbit[x];
	}
	return ans;
}
void adder(int x)
{
	while(x <= n)
	{
		sumr[x]++;
		x += lowerbit[x];
	}
}
int queryr(int x)
{
	int ans = 0;
	while(x)
	{
		ans += sumr[x];
		x -= lowerbit[x];
	}
	return ans;
}
int main()
{
	n = read(),m = read();
	for(int i = 1;i <= n;i++) lowerbit[i] = i & (-i);
	while(m--)
	{
		int op = read(),l = read(),r = read();
		if(op == 1) addel(l),adder(r);
		else printf("%d\n",queryl(r) - queryr(l - 1));
	}
}
		
```

---

## 作者：redegg (赞：0)

题意没表达清楚，这题地雷是可以同时存在于同一地点的，也就是不被覆盖（让我冥思了很久很久）。

解释一下为什么不能直接用线段树区间加减然后求最大值，因为有可能会出现两个区间不想交，这样便没法通过最大最小值算出答案（我WA了两次，后来发现时。。。）

最简单的是树状数组，直接存两个，然后前缀和思想解决。
```
#include <bits/stdc++.h>
using namespace std;

int s[600006];
int a[500006];

int n,m;

void update1(int r,int f)
{
    while(r<=n)
    {
        a[r]+=f;
        r+=(r&(-r));
    }
}

int get1(int l)
{
    int sum=0;
    while(l>0)
    {
        sum+=a[l];
        l-=(l&(-l));
    }
    return sum;
}

void update2(int r,int f)
{
    while(r<=n)
    {
        s[r]+=f;
        r+=(r&(-r));
    }
}

int get2(int l)
{
    int sum=0;
    while(l>0)
    {
        sum+=s[l];
        l-=(l&(-l));
    }
    return sum;
}


int main()
{
    scanf("%d%d",&n,&m);
    int c,x,y;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&c,&x,&y);
        if(c==1)
        {
            update1(x,1);
            update2(y,1);
        }
        else
        {
            printf("%d\n",get1(y)-get2(x-1));
        }
    }

    return 0;
}

```

---

## 作者：大菜鸡fks (赞：0)

考虑容斥，区间内的地雷种类=总的数量-右端点在[1,l-1]-左端点在[r+1,n]

```cpp
#include<cstdio>
#define lowbit(x) x&(-x)
using namespace std;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
const int N=1e5+5;
int n,m,bit1[N],bit2[N],All;
inline void update(int bit[],int x){for (;x<=n;x+=lowbit(x)) bit[x]++;}
inline int query(int bit[],int x){int ans=0; for (;x;x-=lowbit(x)) ans+=bit[x]; return ans;}
inline int Query(int bit[],int l,int r){return query(bit,r)-query(bit,l-1);}
int main(){
	n=read(); m=read();
	for (int i=1;i<=m;i++){
		int opt=read(),l=read(),r=read();
		if (opt==1) update(bit1,l),update(bit2,r),All++;
			else writeln(All-Query(bit1,r+1,n)-Query(bit2,1,l-1));
	}
	return 0;
}
```

---


# 守墓人

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/1406.png) 

在一个荒凉的墓地上，有一个令人尊敬的守墓人， 他看守的墓地从来没有被盗过， 所以人们很放心的把自己的先人的墓安顿在他那

守墓人能看好这片墓地是必然而不是偶然……

因为……守墓人懂风水 0.0

## 题目描述

他把墓地分为主要墓碑和次要墓碑， 主要墓碑只能有 $1$ 个， 守墓人把他记为 $1$ 号， 而次要墓碑有 $n-1$ 个，守墓人将之编号为 $2,3\dots n$，所以构成了一个有 $n$ 个墓碑的墓地。

而每个墓碑有一个初始的风水值，这些风水值决定了墓地的风水的好坏，所以守墓人需要经常来查询这些墓碑。

善于运用风水的守墓人，通过一次次逆天改命，使得自己拥有了无限寿命，没人知道他活了多久。这天，你幸运的拜访到了他，他要求你和他共同见证接下来几年他的战果，但不过他每次统计风水值之和都需要你来帮他计算，算错了他会要你命 QAQ

风水也不是不可变，除非遭遇特殊情况，已知在接下来的 $2147483647$ 年里，会有 $f$ 次灾难，守墓人会有几个操作：

1. 将 $[l,r]$ 这个区间所有的墓碑的风水值增加 $k$。

2.将主墓碑的风水值增加 $k$

3.将主墓碑的风水值减少 $k$

4.统计 $[l,r]$ 这个区间所有的墓碑的风水值之和

5.求主墓碑的风水值

上面也说了，很多人会把先人的墓安居在这里，而且守墓人活了很多世纪→\_→，墓碑的数量会多的你不敢相信= =

守墓人和善的邀请你帮他完成这些操作，要不然哪天你的旅馆爆炸了，天上下刀子.....

为了活命，还是帮他吧


## 说明/提示

$20\%$ 的数据满足：$1\leq n\leq 100$

$50\%$ 的数据满足：$1\leq n\leq 6000$

$100\%$ 的数据满足：$1\leq n,f\leq 2 \times 10^5$，答案不超过 64 位整数。


## 样例 #1

### 输入

```
5 7
0 0 0 0 0
1 1 5 1
1 1 3 3
2 3
3 1
4 1 5
2 1
5```

### 输出

```
16
7```

# 题解

## 作者：顾z (赞：49)

题目描述-->[p2357 守墓人](https://www.luogu.org/problemnew/show/P2357)

~~敲了一遍线段树,水过.~~

感谢 [troubler](https://www.luogu.org/space/show?uid=88089) 给了我树状数组AC此题的机会.

~~水题解的机会~~

## 分析

**主要思路：** 

**差分**

**简单介绍一下差分**(详细概念太麻烦,看下面.

	给定一个数组
    7 8 6 5 1 8 18 20 35 //瞎敲的emmm
    7 1 -2 -1 3 10 2  15//对应得到差分数组.
	我们发现从[1,i]求和,得到的就是我们的原数组对应值.(这就是差分.
    

**为什么用差分+树状数组**?

对应差分,我们修改一个位置都会对应影响一段区间.

差分的话,我们修改一个位置就达到了修改后面区间的效果.

而我们修改一个区间,只需要对于左端点增加k,右端点+1位置减去k即可.
	
对应差分操作,区间修改操作,我们可以推导出下面的式子.

![](https://i.loli.net/2018/09/07/5b91eddb3f89f.png)
图片来源-->[@胡小兔](http://www.cnblogs.com/RabbitHu/p/BIT.html)

学习一下(简单了解)就可以了.

所以我们就可以很简单码出来.

**码量小又简单,树状数组你值得拥有**

### 安利一篇[很好的写树状数组的blog](http://www.cnblogs.com/RabbitHu/p/BIT.html)


--------------------代码---------------------

```cpp
/*
目前树状数组解法rank1(吸氧
Timeuse：214ms
Creator：顾z
Date:2018.09.07
*/
#include<bits/stdc++.h>
#define int long long
#define IL inline
#define RI register int
#define lowbit(x) x&-x 
IL void in(int &x){
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,m,last,opt,x,y,z,mian;
int sum1[500002],sum2[500002];
IL void add(int pos,int x)
{
	for(RI i=pos;i<=n;i+=lowbit(i))
		sum1[i]+=x,sum2[i]+=pos*x;
}
IL long long query(int pos)
{
	long long res=0;
	for(RI i=pos;i;i-=lowbit(i))
		res+=(pos+1)*sum1[i]-sum2[i];
	return res;
} 
main(void)
{
	in(n),in(m);
	for(RI i=1;i<=n;i++)in(x),add(i,x-last),last=x;
	for(RI i=1,opt;i<=m;i++)
	{
		in(opt);
		switch(opt)
		{
			case 1:in(x),in(y),in(z),add(x,z),add(y+1,-z);break;
			case 2:in(z),mian+=z;break;
			case 3:in(z),mian-=z;break;
			case 4:in(x),in(y);printf("%lld\n",query(y)-query(x-1)+(x==1)*mian);break;
			case 5:printf("%lld\n",query(1)+mian);
		}
	}
}
```


再粘一下**线段树代码** emm↓

```cpp

/*
线段树就跑的有些慢了 emmm(未吸氧
zkw线段树应该会更快一些.
Timeuse：594ms
Creator：顾z
Date:2018.09.03
*/
#include<bits/stdc++.h>
#define int long long
#define IL inline
#define RI register int
#define ls o<<1
#define rs o<<1|1
#define N 1000008
IL void read(int &x){
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,f,tr[N],tg[N],mian,c[N];
IL void up(int o){tr[o]=tr[ls]+tr[rs];return;}
IL void build(int o,int l,int r)
{
	if(l==r)
	{
		read(tr[o]);
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	up(o);
	return;
}
IL void down(int o,int l,int r)
{
	if(tg[o])
	{
		int mid=(l+r)>>1;
		tg[ls]+=tg[o];tg[rs]+=tg[o];
		tr[ls]+=tg[o]*(mid-l+1);
		tr[rs]+=tg[o]*(r-mid);
		tg[o]=0;	
	}
}
IL int query(int o,int l,int r,int x,int y)
{
	if(x<=l&&y>=r)return tr[o];
	down(o,l,r);
	int res=0;
	int mid=(l+r)>>1;
	if(x<=mid)res+=query(ls,l,mid,x,y);
	if(y>mid)res+=query(rs,mid+1,r,x,y);
	return res;
}
IL void change(int o,int l,int r,int x,int y,int del)
{
	if(x<=l&&y>=r)
	{
		tg[o]+=del;
		tr[o]+=del*(r-l+1);
		return;
	}
	down(o,l,r);
	int mid=(l+r)>>1;
	if(x<=mid)change(ls,l,mid,x,y,del);
	if(y>mid)change(rs,mid+1,r,x,y,del);
	up(o);
	return;
}
signed main()
{
	read(n),read(f);
	build(1,1,n);
	for(RI i=1,opt,x,y,z;i<=f;i++)
	{
		read(opt);
		switch(opt)
		{
			case 1:read(x),read(y),read(z),change(1,1,n,x,y,z);break;
			case 2:read(z),mian+=z;break;
			case 3:read(z),mian-=z;break;
			case 4:read(x),read(y),printf("%lld\n",query(1,1,n,x,y)+(x==1)*mian);break;
			case 5:printf("%lld\n",query(1,1,n,1,1)+mian);break;
		}
	}
}
```
目前**树状数组解法rank1 **

---

## 作者：Minecraft万岁 (赞：18)

看到这题的五个操作发现只要用 线段树 就可以轻松水过 只要会写区间修改区间查询就行   
#### ~~那主墓怎么办~~  
题目中说主墓编号为 $1$ 其他的编号为 $2$ 到 $n$  修改主墓的风水就等于修改区间 $[1,1]$ 的风水 统一 $update$ 和 $query$
~~那这个主墓和其他墓有什么区别~~   
~~啥 不会线段树~~   
[左转](https://www.luogu.com.cn/problem/P3372) 洛谷模板区   
[右转](https://www.cnblogs.com/jason2003/p/9676729.html) 大佬博客    
包教包会   
话说这题分块好像比线段树慢 $200ms$ 左右  
那就上代码 ~~其实就是线段树的板子~~   


------------
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;
typedef long long ll;
const int MAXN=200005;
ll n,m,a[MAXN],ans[MAXN*4],lazy[MAXN*4];//懒标记不解释 看大佬博客 
ll op,ux,uy,uz;//读入的操作 
inline void read(ll &x)//快读 
{
	ll f;char c;
	for (f=1,c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
	for(x=0;c<='9'&&c>='0';c=getchar()) x=x*10+(c&15);x*=f;
} 
//----------------------线段树模板------------------------------- 
inline void push_up(ll p) 
{
    ans[p]=ans[p<<1]+ans[p<<1|1];
}
inline void build_tree(ll p,ll l,ll r)
{
    lazy[p]=0;
    if(l==r)
	{
		ans[p]=a[l];
		return ;
	}
    ll mid=(l+r)>>1;
    build_tree(p<<1,l,mid);build_tree(p<<1|1,mid+1,r);
    push_up(p);
} 
inline void f(ll p,ll l,ll r,ll k)
{
    lazy[p]=lazy[p]+k;
    ans[p]=ans[p]+k*(r-l+1);
}
inline void push_down(ll p,ll l,ll r)
{
    ll mid=(l+r)>>1;
    f(p<<1,l,mid,lazy[p]);
	f(p<<1|1,mid+1,r,lazy[p]);
    lazy[p]=0;
}
inline void update(ll nl,ll nr,ll l,ll r,ll p,ll k)
{
    if(nl<=l&&r<=nr)
    {
        ans[p]+=k*(r-l+1);
		lazy[p]+=k;
		return ;
    } 
    push_down(p,l,r);
	ll mid=(l+r)>>1;
    if(nl<=mid) update(nl,nr,l,mid,p<<1,k);
    if(nr>mid) update(nl,nr,mid+1,r,p<<1|1,k);
    push_up(p);
}
inline ll query(ll q_x,ll q_y,ll l,ll r,ll p)
{
    ll res=0;
    if(q_x<=l&&r<=q_y)return ans[p];
    ll mid=(l+r)>>1;
	push_down(p,l,r);
    if(q_x<=mid) res+=query(q_x,q_y,l,mid,p<<1);
    if(q_y>mid) res+=query(q_x,q_y,mid+1,r,p<<1|1);
    return res;
}
//----------------------终于结束了------------------------------ 
int main()
{
	read(n);read(m);//快读是引用所以直接把变量放进去 
    for(ll i=1;i<=n;i++)
    	read(a[i]);
    build_tree(1,1,n);//别忘记建树  
    while(m--)
    {
        read(op);
        if(op==1) 
        { 
            read(ux);read(uy);read(uz);//读入l r k 
            update(ux,uy,1,n,1,uz);//[l,r]风水全部加 k 
    	}
    	if(op==2)
    	{
    		read(ux);//主墓加上k 
    		update(1,1,1,n,1,ux);//主墓编号1 编号1加上k 等同于 [1,1] 加上 k 
    	}
    	if(op==3)
    	{
    		read(ux);//主墓减去k 
    		update(1,1,1,n,1,-ux);//同上 加负的 减正的 
    	}
    	if(op==4)
    	{
    		read(ux);read(uy);//查询[l,r]风水和 
    		printf("%lld\n",query(ux,uy,1,n,1));
    	}
    	if(op==5)
    	{
    		printf("%lld\n",query(1,1,1,n,1));//查询主墓1号对应区间[1,1] 
    	}
    }
    return 0;
}
```

~~最后说几句~~    

- 最好学习并使用位运算 不但快而且在后期有应用 比如说~~令人头疼的~~状压 $dp$  
- 注意数据范围 不开 $long long$ 见祖宗 说的真对  
- ~~要耐心调 $bug$~~ 

---

## 作者：rainygame (赞：10)

本题解默认读者有一定的树状数组基础，如果没有请阅读 [OI-Wiki](https://oi-wiki.org/ds/fenwick/) 。

这道题显然是一个区间修改、区间查询的问题（主墓的可以看作是 $[1,1]$ 的区间），该问题可以用两个树状数组进行[差分](https://oi-wiki.org/basic/prefix-sum/)解决。

考虑 $a$ 的差分数组 $d$，$d_i = a_i - a_{i-1}$，那么 $a_i = \sum\limits_{j=1}^id_j$。

考虑用差分查询前缀和，考虑计算 $\sum\limits_{i=1}^ra_i$：

$$
\begin{aligned}
&\; \; \; \; \; \sum\limits_{i=1}^ra_i \\
&= \sum\limits_{i=1}^r\sum\limits_{j=1}^rd_j \\
&= \sum\limits_{i=1}^rd_i \times (r-i+1) \\
&= \sum\limits_{i=1}^rd_i \times (r+1)-\sum\limits_{i=1}^rd_i \times i
\end{aligned}
$$

因为只有 $\sum\limits_{i=1}^rd_i$ 不能算出 $\sum\limits_{i=1}^rd_i \times i$，所以必须要开两个树状数组分别维护。

根据差分的维护方法，我们不难想到可以这样用差分维护两个树状数组（假设对 $[l,r]$ 的区间加 $x$）：

- 对于维护 $d_i$ 的树状数组，可以用对 $l$ 点加上 $x$，对 $r+1$ 点减去 $x$。

- 对于维护 $d_i \times i$ 的树状数组，可以对 $l$ 点加上 $x \times l$，对 $r+1$ 点减去 $x \times (r+1)$。

代码如下（看清楚哪些要开 `long long`！）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 200001

int n, f, opt, l, r;
long long k;
long long a[MAXN], c1[MAXN], c2[MAXN];  // 记得开long long！ 

int lowbit(int x){
    return x & -x;
}

void add(int i, long long k){  // 维护树状数组 
    int x = i-1;
    while(i <= n){
        c1[i] += k;
        c2[i] += x*k;
        i += lowbit(i);
    }
}

void add(int l, int r, long long k){  // 将[l,r]的的全部+k 
	add(l, k);
	add(r+1, -k);
}

long long get_sum(int i){  // 计算[1,i]的和 
    long long ans = 0;
    int x = i;
    while (i){
        ans += x*c1[i] - c2[i];
        i -= lowbit(i);
    }
    return ans;
}

long long query(int l, int r){  // 计算[l,r]的和 
	return get_sum(r) - get_sum(l-1);
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    cin >> n >> f;
    for (int i=1; i<=n; i++){  // 建立树状数组 
        cin >> a[i];
        add(i, a[i]-a[i-1]);
    }
    
    while (f--){
    	cin >> opt;
    	switch (opt){
    		case 1:
    			cin >> l >> r >> k;
            	add(l, r, k);
            	break;
            case 2:
            	cin >> k;
        		add(1, 1, k);  // 把主墓看成[1,1]的区间 
        		break;
        	case 3:
        		cin >> k;
        		add(1, 1, -k);
        		break;
        	case 4:
        		cin >> l >> r;
            	cout << query(l, r) << '\n';
            	break;
            case 5:
            	cout << query(1, 1) << '\n';
            	break;
		}
    } 
    return 0;
} 
```


---

## 作者：清远学会 (赞：10)

# 遇事不决先分块

> 用分快水，感受暴力的美感:

用分块维护，支持区间加，与区间查询，对于墓碑1的单独操作就行了。最后不要忘记加上区间的lazy标志；
## 最重要一点：开long long，不开只有35分；
### 奉上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define N 500500
#define int long long
using namespace std;

int n,m;
int a[N];
int tag[N],L[N],R[N];
int sum[N],lz[N];

inline void Change(int l,int r,int k) {
	if(tag[l] == tag[r]) {
		for(int i = l;i <= r;i ++)
			a[i] += k,sum[tag[i]] += k;
		return ;
	}
	for(int i = l;i <= R[tag[l]];i ++) 
		a[i] += k,sum[tag[i]] += k;
	for(int i = tag[l] + 1;i < tag[r];i ++)
		lz[i] += k,sum[i] += (R[i] - L[i] + 1) * k;
	for(int i = L[tag[r]];i <= r;i ++)
		a[i] += k,sum[tag[i]] += k;
}

inline int Ask(int l,int r) {
	int res = 0;
	if(tag[l] == tag[r]) {
		for(int i = l;i <= r;i ++)
			res += a[i] + lz[tag[i]];
		return res;
	}
	for(int i = l;i <= R[tag[l]];i ++)
		res += a[i] + lz[tag[i]];
	for(int i = tag[l] + 1;i < tag[r];i ++)
		res += sum[i];
	for(int i = L[tag[r]];i <= r;i ++)
		res += a[i] + lz[tag[i]];
	return res;
}

signed main() {
	scanf("%lld%lld",&n,&m); int len = sqrt(n);
	for(int i = 1;i <= n;i ++) tag[i] = (i - 1) / len + 1;
	for(int i = 1;i <= tag[n];i ++) 
		L[i] = R[i - 1] + 1,R[i] = min(n,L[i] + len - 1);
	for(int i = 1;i <= n;i ++) scanf("%lld",&a[i]);
	for(int i = 1;i <= tag[n];i ++)
		for(int j = L[i];j <= R[i];j ++)
			sum[i] += a[j];
	for(int i = 1;i <= m;i ++) {
		int opt; scanf("%lld",&opt);
		if(opt == 1) {
			int l,r,k; scanf("%lld%lld%lld",&l,&r,&k);
			Change(l,r,k);
		}
		if(opt == 2) {
			int k; scanf("%lld",&k);
			a[1] += k; sum[tag[1]] += k;
		}
		if(opt == 3) {
			int k; scanf("%lld",&k);
			a[1] -= k; sum[tag[1]] -= k;
		}
		if(opt == 4) {
			int l,r; scanf("%lld%lld",&l,&r);
			printf("%lld\n",Ask(l,r));
		}
		if(opt == 5) {
			printf("%lld\n",a[1] + lz[tag[1]]);
		}
	}
	return 0;
}
```
聊点别的，为什么这道题的标签是图论？

---

## 作者：tcswuzb (赞：5)

**本蒟蒻简直就是蒟蒻中的蒟蒻**

第一次RE 

```cpp
if(le<=mid) ans+=qury(si<<1,lenow,
mid,le,ri);
if(mid<ri) ans+=qury(si<<1|1,mid,
rinow,le,ri);
```
~~亮点自己找吧~~

第二次TLE

大佬说  **“1”只要特殊处理就行**

我却直接单点当区间处理了

第三次WA

发现区间处理时 直接区间处理与特殊处理重复了

无语 * 2147483647

-------------------------------吐槽时间-----------------------------------

步入正解 正解就是 线！段！树！

操作 1 经典的线段树区间处理操作

操作 2 , 3 特殊处理即可

操作 4 经典的线段树区间求和操作 

注：区间包含“1”的话加上特殊处理的值

操作 5 特殊处理 + 单点询问

注：本蒟蒻一开始 直接记忆读入“1”的值

最后加上特殊处理 可是忽略了区间修改这个毒瘤

后来区间修改是有覆盖“1”的话 也直接特殊处理

可是区间求和时 重复累加了

没办法 只好区间修改时再次特判了 （执着于O(1)追求） 

# CODE：

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
struct node{
	ll num,tag;
}tre[N<<2];
ll zhi[N<<2];
ll n,m;
ll ans,sum;
IL void build(ll si,ll le,ll ri){
	if(le==ri) {tre[si].num=zhi[le];tre[si].tag=0;return;}
	ll mid=(le+ri)>>1;
	build(si<<1,le,mid);build(si<<1|1,mid+1,ri);
	tre[si].num=tre[si<<1].num+tre[si<<1|1].num;
}
IL void down(ll si,ll le,ll ri){
	if(tre[si].tag){
		ll mid=(le+ri)>>1;
		tre[si<<1].tag+=tre[si].tag;
		tre[si<<1|1].tag+=tre[si].tag;
		tre[si<<1].num+=(mid-le+1)*tre[si].tag;
		tre[si<<1|1].num+=(ri-mid)*tre[si].tag;
		tre[si].tag=0;
	}
}
IL void change(ll si,ll lenow,ll rinow,ll le,ll ri,ll ak){
	if(le<=lenow && rinow<=ri){
		tre[si].tag+=ak;
		tre[si].num+=(rinow-lenow+1)*ak;
		return;
	}
	down(si,lenow,rinow);
	ll mid=(lenow+rinow)>>1;
	if(le<=mid) change(si<<1,lenow,mid,le,ri,ak);
	if(mid<ri) change(si<<1|1,mid+1,rinow,le,ri,ak);
	tre[si].num=tre[si<<1].num+tre[si<<1|1].num;
	return;
}
IL ll qury(ll si,ll lenow,ll rinow,ll le,ll ri){
	if(le<=lenow && rinow<=ri){
		return tre[si].num;
	}
	down(si,lenow,rinow);
	ll mid=(lenow+rinow)>>1;
	ll ans=0;
	if(le<=mid) ans+=qury(si<<1,lenow,mid,le,ri);
	if(mid<ri) ans+=qury(si<<1|1,mid+1,rinow,le,ri);
	return ans;
}
int main()
{
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
    read(n);read(m);
    for(R ll i=1;i<=n;++i) read(zhi[i]);sum=zhi[1]; 
    build(1,1,n);
    while(m--){
    	ll key,le,ri,ak;
    	read(key);
    	if(key==1){
    		if(le>ri) swap(le,ri);
    		read(le);read(ri);read(ak);
    		//特殊处理 
            if(le>1) change(1,1,n,le,ri,ak);
    		else change(1,1,n,le+1,ri,ak),ans+=ak;
		}
		if(key==2){//“1”变值 特殊处理
			read(ak);
			ans+=ak;
		}
		if(key==3){
			read(ak);
			ans-=ak;
		}
		if(key==4){//特殊处理 加上“1”的变值
			if(le>ri) swap(le,ri);
			read(le);read(ri);
			printf("%lld\n",qury(1,1,n,le,ri)+ans*(le==1 ? 1 : 0));
		}
		if(key==5){//特殊处理 追求O（1）
			printf("%lld\n",ans+sum);
		}
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

NOIP 2018 即将到来 

衷心祝愿各位 RP++   全场AK 

---

## 作者：G_hz (赞：5)

线段树裸题，（WA了这么多次打脸

不需要单点修改和单点查询，直接开一个变量保存对第一个墓碑的操作就可以了

线段树只需要区间加和区间查询

代码如下：

```cpp
#include<stdio.h>
#include<string.h>
long long tree[1000000],lazy[1000000],li[1000000],cc,aa;//没给数据范围，别忘了开long long
int n,m,x,a,b,c;
void Build(int loc,int l,int r){
    if(l==r){
        tree[loc]=li[l];
        return;
    }
    int mid=(l+r)/2;
    Build(loc<<1,l,mid);
    Build(loc<<1|1,mid+1,r);
    tree[loc]=tree[loc<<1]+tree[loc<<1|1];
}
void Push_down(int loc,int l,int r){
    int mid=(l+r)/2;
    tree[loc<<1]+=lazy[loc]*(long long)(mid-l+1);
    tree[loc<<1|1]+=lazy[loc]*(long long)(r-mid);
    lazy[loc<<1]+=lazy[loc];
    lazy[loc<<1|1]+=lazy[loc];
    lazy[loc]=0;
}
void Update(int loc,int L,int R,int l,int r,long long add){
    if(l<=L&&r>=R){
        lazy[loc]+=add;
        tree[loc]+=(long long)(R-L+1)*add;
        return;
    }
    int mid=(L+R)/2;
    if(lazy[loc])Push_down(loc,L,R);
    if(r<=mid)Update(loc<<1,L,mid,l,r,add);
    else{
        if(l>mid){
            Update(loc<<1|1,mid+1,R,l,r,add);
        }
        else{
            Update(loc<<1,L,mid,l,mid,add);
            Update(loc<<1|1,mid+1,R,mid+1,r,add);
        }
    }
    tree[loc]=tree[loc<<1]+tree[loc<<1|1];
}
long long Query(int loc,int L,int R,int l,int r){
    if(l<=L&&r>=R){
        return tree[loc];
    }
    if(lazy[loc])Push_down(loc,L,R);
    int mid=(L+R)/2;
    if(r<=mid)return Query(loc<<1,L,mid,l,r);
    else{
        if(l>mid)return Query(loc<<1|1,mid+1,R,l,r);
        else return Query(loc<<1,L,mid,l,mid)+Query(loc<<1|1,mid+1,R,mid+1,r);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&li[i]);
    }
    Build(1,1,n);
    for(int i=1;i<=m;i++){
        scanf("%d",&x);
        if(x==1){
            scanf("%d%d%lld",&a,&b,&aa);
            Update(1,1,n,a,b,aa);
        }
        if(x==2){
            scanf("%lld",&aa);
            cc+=aa;
        }
        if(x==3){
            scanf("%lld",&aa);
            cc-=aa;
        }
        if(x==4){
            scanf("%d%d",&a,&b);
            long long bb=Query(1,1,n,a,b);
            printf("%lld\n",bb+cc*(a==1));
        }
        if(x==5){
            long long bb=Query(1,1,n,1,1)+cc;
            printf("%lld\n",bb);
        }
    }
    return 0;
}
```

---

## 作者：MloVtry (赞：4)

线段树裸题...

其实没必要那么麻烦维护这个维护那个....直接把单点也当成区间就好了...虽然可能会被卡，但是出题人是懒的....

代码
```cpp
#define ll long long
#include<iostream>
#include<cstdio>
#define N 200000
using namespace std;
struct node
{
    ll sum,lazy;
}tre[4*N+5];
ll a[N+5],n,f;
void buid(ll l,ll r,ll now)
{
    if(l==r)
    {
        tre[now].sum=a[l];
        tre[now].lazy=0;
        return;
    }
    ll mid=(l+r)>>1,lson=now<<1,rson=lson|1;
    buid(l,mid,lson);
    mid++;
    buid(mid,r,rson);
    tre[now].lazy=0;
    tre[now].sum=tre[lson].sum+tre[rson].sum;
}
void down(ll l,ll r,ll now)
{
    if(tre[now].lazy)
    {
        ll k=tre[now].lazy;tre[now].lazy=0;
        ll mid=(l+r)>>1,lson=now<<1,rson=lson|1;
        tre[lson].lazy+=k;tre[rson].lazy+=k;
        tre[lson].sum+=(mid-l+1)*k;
        mid++;
        tre[rson].sum+=(r-mid+1)*k;
    }
}
void add(ll u,ll v,ll l,ll r,ll now,ll it)
{
    if(u<=l&&v>=r)
    {
        tre[now].lazy+=it;
        tre[now].sum+=(r-l+1)*it;
        return;
    }
    if(u>r||v<l) return;
    ll mid=(l+r)>>1,lson=now<<1,rson=lson|1;
    down(l,r,now);
    add(u,min(v,mid),l,mid,lson,it);
    mid++;
    add(max(u,mid),v,mid,r,rson,it);
    tre[now].sum=tre[lson].sum+tre[rson].sum;
}
ll ask(ll u,ll v,ll l,ll r,ll now)
{
    if(u<=l&&v>=r)
    {
        return tre[now].sum;
    }
    if(u>r||v<l) return 0;
    ll mid=(l+r)>>1,lson=now<<1,rson=lson|1;
    down(l,r,now);
    ll re=0;
    re+=ask(u,min(v,mid),l,mid,lson);
    mid++;
    re+=ask(max(u,mid),v,mid,r,rson);
    tre[now].sum=tre[lson].sum+tre[rson].sum;
    return re;
}
int main()
{
    scanf("%lld%lld",&n,&f);
    for(ll i=1;i<=n;++i) scanf("%lld",&a[i]);
    buid(1,n,1);
    for(ll i=1;i<=f;++i)
    {
        ll fl;scanf("%lld",&fl);
        if(fl==1)
        {
            ll l,r,k;scanf("%lld%lld%lld",&l,&r,&k);
            add(l,r,1,n,1,k);
        }
        if(fl==2)
        {
            ll k;scanf("%lld",&k);
            add(1,1,1,n,1,k);
        }
        if(fl==3)
        {
            ll k;scanf("%d",&k);
            add(1,1,1,n,1,-k);
        }
        if(fl==4)
        {
            ll l,r;scanf("%lld%lld",&l,&r);
            printf("%lld\n",ask(l,r,1,n,1));
        }
        if(fl==5)
        {
            printf("%lld\n",ask(1,1,1,n,1));
        }
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：4)

提供指针线段树

每次都只改第一个

不写单点修改

开个delta表示主墓碑的变化量

查询的时候再加上去就好了
```cpp
#include<cstdio>
typedef long long ll; //没给数据范围 开个longlong
namespace Segment_Tree
{
	struct tree
	{
		int l,r;ll sum,tag;
		tree *lson,*rson;
		inline tree(int L,int R)
		{
			l=L;r=R;
			sum=tag=0;
			lson=rson=NULL;
		}
		inline void pushup()
		{
			sum=lson->sum+rson->sum;
		}
		inline void add(ll w) //单次修改
		{
			sum+=(r-l+1)*w;tag+=w;
		}
		inline void pushdown()
		{
			if (!tag)return;
			lson->add(tag);
			rson->add(tag);
			tag=0;
		}
		void update(int L,int R,ll w)
		{
			if (l>R||r<L)return;
			if (l>=L&&r<=R){add(w);return;}
			pushdown();
			lson->update(L,R,w);rson->update(L,R,w);
			pushup();
		}
		ll query(int L,int R)
		{
			if (l>R||r<L)return 0;
			if (l>=L&&r<=R)return sum;
			pushdown();
			return lson->query(L,R)+rson->query(L,R);
		}
	}*root;
	void build(tree *&p,int l,int r)
	{
		p=new tree(l,r);
		if (l==r){scanf("%lld",&p->sum);return;}
		int mid=l+r>>1;
		build(p->lson,l,mid);build(p->rson,mid+1,r);
		p->pushup();
	}
}using namespace Segment_Tree;
int n,m;
ll delta;
int main()
{
	scanf("%d%d",&n,&m);
	build(root,1,n);
	while (m--)
	{
		short opt;scanf("%hd",&opt);
		switch (opt)
		{
			case 1:{int l,r;ll k;scanf("%d%d%lld",&l,&r,&k);root->update(l,r,k);break;}
			case 2:{ll k;scanf("%lld",&k);delta+=k;break;}
			case 3:{ll k;scanf("%lld",&k);delta-=k;break;}
			case 4:{int l,r;scanf("%d%d",&l,&r);printf("%lld\n",root->query(l,r)+(l==1?delta:0));break;} //包含主墓碑才加上delta
			case 5:{printf("%lld\n",root->query(1,1)+delta);break;} //记得加上delta
		}
	}
	return 0;
}
```

---

## 作者：C20212724杨京朝 (赞：3)

线段树板子题
------------
不会线段树的同学看这里：
![](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2833632113,3839103406&fm=26&gp=0.jpg)

如图是一颗由1-10的数字组成的线段，度娘对线段树的解释如下：线段树是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 
线段树也是一颗平衡二叉树，我们将它用分治的思想不断二分，最后变成单个的叶节点。

这只是线段树的基本概念，相信看到我这篇题解的同学都是对树或线段树有一定了解的，多说无益。如果实在不会的话，我建议可以看看这篇博客（转载自他人）：

[线段树入门](https://pks-loving.blog.luogu.org/senior-data-structure-qian-tan-xian-duan-shu-segment-tree)  PS：相信你会对线段树有更深的认识，顺便再切掉一个板子题吧 --- [P3372](https://www.luogu.org/problemnew/show/P3372)

------------
#### 正文部分： 这题的难点在于对主墓碑的处理，其实无妨，单点的修改与查询也是稍显累赘
```cpp
#include <cstdio>
#define LL long long//宏定义，绝对不是因为懒
const int MAXN = 100005 * 2;
LL tree[MAXN * 4],tag[MAXN * 4],a[MAXN],cnt;//a数组为墓碑，tree数组即线段树，tag就是懒标记
void push_up(LL now) {
	tree[now] = tree[now * 2] + tree[now * 2 + 1];
}
void build(LL now,LL l,LL r) {//建树
	if(l == r) {
		cnt ++;
		tree[now] = a[cnt];
	}
	else {
		LL mid = (l + r) >> 1;
		build(now * 2,l,mid);
		build(now * 2 + 1,mid + 1,r);
		push_up(now); 
	}
}
void push_down(LL now,LL l,LL r) {
	LL mid = (l + r) >> 1;
	tree[now * 2] += (mid - l + 1) * tag[now];
	tree[now * 2 + 1] += (r - mid) * tag[now];
	tag[now * 2] += tag[now];
	tag[now * 2 + 1] += tag[now];
	tag[now] = 0; 
	push_up(now);
}
void update(LL now,LL l,LL r,LL x,LL y,LL t) {//修改
	if(x <= l && y >= r) {
		tree[now] += (r - l + 1) * t;
		tag[now] += t;
	}
	else {
		push_down(now,l,r);
		LL mid = (l + r) >> 1;
		if(x <= mid) update(now * 2,l,mid,x,y,t);
		if(y > mid) update(now * 2 + 1,mid + 1,r,x,y,t);
		push_up(now);
	}
}
LL look_up(LL now,LL l,LL r,LL x,LL y) {//查找
	LL ans = 0;
	if(x <= l && y >= r) {
		ans += tree[now];
	}
	else {
		push_down(now,l,r);
		LL mid = (l + r) >> 1;
		if(x <= mid) ans += look_up(now * 2,l,mid,x,y);
		if(y > mid) ans += look_up(now * 2 + 1,mid + 1,r,x,y);
	}
	return ans;
} 
int main() {
	LL n,f,x;
	scanf("%lld %lld",&n,&f);
	for(LL i = 1;i <= n;i ++) scanf("%lld",&a[i]);//输入时大可把主墓碑与其他墓碑一起处理
   	//这里我本来是想单独定义一个变量处理主墓碑，然而在查询与修改中有时也包含主墓碑，索性一起处理了
	build(1,1,n);//建树
	for(LL i = 1;i <= f;i ++) {//一共f次操作
		LL num;
		scanf("%lld",&num);
		if(num == 1) {
			LL l,r,k;
			scanf("%lld %lld %lld",&l,&r,&k);
			update(1,1,n,l,r,k);
		}
		if(num == 2) {
			LL k;
			scanf("%lld",&k);
			update(1,1,n,1,1,k);//处理单点时，可以使左右两端点都为同一个数1，少两个函数
		}
		if(num == 3) {
			LL k;
			scanf("%lld",&k);
			update(1,1,n,1,1,-1 * k);
		}
		if(num == 4) {
			LL l,r;
			scanf("%lld %lld",&l,&r);
			printf("%lld\n",look_up(1,1,n,l,r));
		}
		if(num == 5) {
			printf("%lld\n",look_up(1,1,n,1,1));//同上
		}照着题意模拟，毫无思维性
	} 
	return 0;//return 0不能忘
}
```
------------
这个代码用时1012ms：想提高速度可以用快读快输（毕竟查询次数多，输入数据大）
这里双手奉上模板：

快读：
```cpp
inline int readIn() {
    int a = 0;
    bool minus = false;
    char ch = getchar();
    while (!(ch == '-' || (ch >= '0' && ch <= '9'))) ch = getchar();
    if (ch == '-')
    {
        minus = true;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        a = a * 10 + (ch - '0');
        ch = getchar();
        
    }
    if (minus) a = -a;
    return a;
}
```
快输：
```cpp
inline void write(int x){
    int k = 0,lx = x;char put[40];
    if (lx ==0) putchar('0');
    if (lx < 0) putchar('-'),lx = -lx;
    while (lx)  put[++k] = (lx % 10) + '0',lx /= 10;
    while (k)   putchar( put[ k-- ] );
    putchar('\n');
}
```
食用方法：输入x，x = readIn();输出x，write(x)







---

## 作者：Provicy (赞：2)

线段树模板裸题。

显然，我们把单点的修改和查询也看成一个区间$[1,1]$，那么就能用线段树做这题（见[线段树1](https://www.luogu.org/problem/P3372)）。

既然这题只是个线段树模板，那就很轻松可以解决了。

（虽说这题树状数组也能做，但是没有线段树那么直观）

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1100000;
ll n,f,a[N],leaf[N],flag[N];
inline ll LeftChild(ll x){return x<<1;}
inline ll RightChild(ll x){return x<<1|1;}
inline void Up(ll x){leaf[x]=leaf[LeftChild(x)]+leaf[RightChild(x)];}
void Build_Tree(ll x,ll l,ll r)
{
	if(l==r) {leaf[x]=a[l]; return;}
	Build_Tree(LeftChild(x),l,(l+r)>>1);
	Build_Tree(RightChild(x),((l+r)>>1)+1,r);
	Up(x);
}
inline void Add_Up(ll x,ll l,ll r,ll k){flag[x]+=k;leaf[x]+=k*(r-l+1);}
void Push_Down(ll x,ll l,ll r)
{
	Add_Up(LeftChild(x),l,(l+r)>>1,flag[x]);
	Add_Up(RightChild(x),((l+r)>>1)+1,r,flag[x]);
	flag[x]=0;
}
void UpDate(ll u,ll v,ll l,ll r,ll x,ll k)
{
	if(l>=u&&r<=v) {Add_Up(x,l,r,k); return;}
	Push_Down(x,l,r);
	if(u<=(l+r)>>1) UpDate(u,v,l,(l+r)>>1,LeftChild(x),k);
	if(v>(l+r)>>1) UpDate(u,v,((l+r)>>1)+1,r,RightChild(x),k);
	Up(x);
}
ll Ask(ll u,ll v,ll l,ll r,ll x)
{
	ll ans=0;
	if(l>=u&&r<=v) return leaf[x];
	Push_Down(x,l,r);
	if(u<=(l+r)>>1) ans+=Ask(u,v,l,(l+r)>>1,LeftChild(x));
	if(v>(l+r)>>1) ans+=Ask(u,v,((l+r)>>1)+1,r,RightChild(x));
	return ans;
}
int main()
{
	scanf("%lld%lld",&n,&f);
	for(ll i=1;i<=n;i++) scanf("%lld",&a[i]); Build_Tree(1,1,n);
	for(ll i=1,to,l,r,k;i<=f;i++)
	{
		scanf("%lld",&to);
		if(to==1) scanf("%lld%lld%lld",&l,&r,&k),UpDate(l,r,1,n,1,k);
		else if(to==2) scanf("%lld",&k),UpDate(1,1,1,n,1,k);
		else if(to==3) scanf("%lld",&k),UpDate(1,1,1,n,1,-k);
		else if(to==4) scanf("%lld%lld",&l,&r),printf("%lld\n",Ask(l,r,1,n,1));
		else if(to==5) printf("%lld\n",Ask(1,1,1,n,1));
	}
	return 0;
}
```


---


# XOR的艺术

## 题目描述

AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下：

1. 拥有一个伤害串，是一个长度为 $n$ 的只含字符 ``0`` 和字符 ``1`` 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。
2. 给定一个范围 $[l,~r]$，伤害为伤害串的这个范围内中字符 ``1`` 的个数。
3. 会修改伤害串中的数值，修改的方法是把 $[l,~r]$ 中所有原来的字符 ``0`` 变成 ``1``，将 ``1`` 变成 ``0``。

AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。

## 说明/提示

#### 样例输入输出 $1$ 解释

原伤害串为 ``1011101001``。

对于第一次操作，改变 $[2,~4]$ 的字符，伤害串变为 ``1100101001``。

对于第二次操作，查询 $[1,~5]$ 内 ``1`` 的个数，共有 $3$ 个。

对于第三次操作，改变 $[3,~7]$ 的字符，伤害串变为 ``1111010001``。

对于第四次操作，查询 $[1,~10]$ 内 ``1`` 的个数，共有 $6$ 个。

对于第五次操作，改变 $[1,~4]$ 的字符，伤害串变为 ``0000010001``。

对于第六次操作，查询 $[2,~6]$ 内 ``1`` 的个数，共有 $1$ 个。

#### 数据范围与约定

对于 $10\%$ 的数据，保证 $n, m \leq 10$。

另有 $30\%$ 的数据，保证 $n, m \leq 2 \times 10^3$。

对于 $100\%$ 的数据，保证 $2 \leq n, m \leq 2 \times 10^5$，$0 \leq op \leq 1$，$1 \leq l \leq r \leq n$，$S$ 中只含字符 ``0`` 和字符 ``1``。

## 样例 #1

### 输入

```
10 6
1011101001
0 2 4
1 1 5
0 3 7
1 1 10
0 1 4
1 2 6
```

### 输出

```
3
6
1
```

# 题解

## 作者：H2O3 (赞：39)

首先，由于是区间修改和区间查询，并且数据范围还这么大，所以需要使用线段树来维护。
读入的数都是0或1且修改操作为异或1的话，那么lazytag和线段树的维护就很好想了。
### 因为0^1=1，1^1=0，所以本题如果对同一个区间连续异或1两次，得到的结果和没有异或是一样的。
对于线段树中不是叶子结点的节点，它的值是它的左右子树的和，也就是它对应的这段区间里面1的个数（因为只有0和1，所以它的值是几就有几个1）。
### 如果对于一段区间，长度为len，有n个1，那么就有len-n个0。相应地，对这段区间异或1之后，它的1的个数就变成了len-n。
这就是这个题的基本思路。还有一些需要注意的点：

读入的时候一定要按照字符读入，否则就直接读入了所有的数（因为没有空格）。

如果说区间长度并不能整除以2，那么就把除以二向下取整丢给左儿子，然后把剩下的丢给右儿子。

下面贴代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <cstdlib>
#include <set>
#include <map>
#include <vector>
#include <queue>
#define maxx 300020
#define ll long long
using namespace std;
int n,m,p,l,r,a[maxx];
char s[maxx];
ll add[maxx<<2],sum[maxx<<2];
inline void getup(int rt)//向上更新 
{
	sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
inline void bulid(int l,int r,int rt)//建树 
{
	if(l==r)
	{
		sum[rt]=a[l];//赋值 
		return ;
	}
	int mid=(l+r)>>1;
	bulid(l,mid,rt<<1);
	bulid(mid+1,r,rt<<1|1);
	getup(rt);
}
inline void pushdown(int rt,int len)//传递tag 
{
	if(add[rt])
	{
		add[rt<<1]^=1;
		add[rt<<1|1]^=1; 
		sum[rt<<1]=(len-(len>>1))-sum[rt<<1];
		sum[rt<<1|1]=(len>>1)-sum[rt<<1|1];
		add[rt]=0;
	}
}
inline ll query(int L,int R,int l,int r,int rt)//分区间查询 
{//LR是要查询的区间，lr是给定的区间。update同理。 
	if(l>=L&&r<=R)return sum[rt];
	pushdown(rt,r-l+1);
	int mid=(r+l)>>1;
	ll tot=0;
	if(L<=mid) tot+=query(L,R,l,mid,rt<<1);
    if(mid+1<=R) tot+=query(L,R,mid+1,r,rt<<1|1);
    return tot;
}
inline void update(int L,int R,int l,int r,int rt)//更新 
{
	pushdown(rt,r-l+1);
	if(l>=L&&r<=R)
	{
		add[rt]^=1;
		sum[rt]=r-l+1-sum[rt];
		return;
	}
	int mid=(l+r)>>1;
    if(L<=mid) update(L,R,l,mid,rt<<1);
    if(mid+1<=R) update(L,R,mid+1,r,rt<<1|1);  
    getup(rt);
} 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) cin>>s[i];//先读入字符 
	for(int i=1;i<=n;i++) a[i]=s[i]-'0';//再转换成数字 
	bulid(1,n,1);
	for(int i=1;i<=m;i++) 
	{
		scanf("%d%d%d",&p,&l,&r);
		if(p==0)
			update(l,r,1,n,1);
		if(p==1)
			cout<<query(l,r,1,n,1)<<endl; 
	}
	return 0;
}
```

---

## 作者：Sshenyyyu (赞：36)

# XOR的艺术
# ~~题目前两个字母吼吼吼~~
~~一道简单模板题~~
## 思路
与平常的线段树不同的是，这次不是区间加法，区间乘法等基础操作，而是神奇的取反，让我不由自主的想到题目XOR（嘻嘻嘻QAQ）
那我们怎么办呢？？只有01哦，不错！！

------------
##### 请看神奇的栗子一枚
区间中取反，我们只需要求的是和，伤害值是1的个数，不就是和嘛！！哈哈哈！！！

看，10101，有3个1，取反过后，01010，就变成2个1啦！！就是5-3=2

在看，00110，有2个1，取反过后，11001，就变成2个1啦！！就是5-2=3
##### 所以呢，区间和，每次在下传懒惰标记的时候呢，就变成区间长度减去自身的值就阔以啦！！！


------------

#### 棒棒哒！！
#### 上代码吧！！！~~蒟蒻代码，不喜勿喷~~
#### 至于一些头文件定义什么的省略啦，空间不够，嘻嘻嘻！！！
```
struct node
{
	int left;//区间左端点
	int right;//右端点
	int w;//初值
	int v;//标记
}tree[Maxn*2];

void Build_Tree(int index,int l,int r)//神奇建树，连函数名都是那么的直接。。。
{
	tree[index].left=l;
	tree[index].right=r;
	if(l==r) {
		tree[index].w=a[l];
		return;
	}
	int mid=(l+r)/2;
	Build_Tree(index*2,l,mid);
	Build_Tree(index*2+1,mid+1,r);
	tree[index].w=tree[index*2].w+tree[index*2+1].w;
}//建树很简单，不说啦！！

void Spread(int index)//下传懒惰标记
{
	if(tree[index].v) {
		tree[index*2].w=tree[index*2].right-tree[index*2].left+1-tree[index*2].w;//如上所说修改
		tree[index*2+1].w=tree[index*2+1].right-tree[index*2+1].left+1-tree[index*2+1].w;
		tree[index*2].v^=1;//标记很简单，就直接取反好啦！！
		tree[index*2+1].v^=1;
		tree[index].v=0;//别忘记清空！！
	}
}

int Query(int index,int l,int r)//自认为好理解的查询。。。
{
	if(tree[index].left>=l&&tree[index].right<=r) return tree[index].w;//如果完全包含，返回区间
	int mid=(tree[index].left+tree[index].right)/2;
	int ans=0;
	Spread(index);//下传标记
	if(l<=mid) ans+=Query(index*2,l,r);//继续向下
	if(r>mid) ans+=Query(index*2+1,l,r);
	return ans;
}

void Change(int index,int l,int r)//修改区间很简单，不说啦！！！
{
	if(tree[index].left>=l&&tree[index].right<=r) {
		tree[index].w=tree[index].right-tree[index].left+1-tree[index].w;
		tree[index].v^=1;
		return;
	}
	int mid=(tree[index].left+tree[index].right)/2;
	Spread(index);
	if(l<=mid) Change(index*2,l,r);
	if(r>mid) Change(index*2+1,l,r);
	tree[index].w=tree[index*2].w+tree[index*2+1].w;
}

int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		scanf("%1d",&a[i]);
	Build_Tree(1,1,n);
	for(int i=1; i<=m; i++) {
		cin>>z;
		if(z==0) {
			cin>>x>>y;
			Change(1,x,y);	
		}
		else {
			cin>>x>>y;
			cout<<Query(1,x,y)<<endl;	
		}
	}
	return 0;
}

```
##### 没啦，蒟蒻望大家多多支持！！！！

---

## 作者：SuperJvRuo (赞：21)

就这沙雕题还用得上线段树/分块？

我们可以压位处理，将32个二进制位压入一个```unsigned int```中，暴力修改，开启O2即可AC。

```
#include<cstdio>
#include<cctype>
#include<utility>
#define PII pair<int,int>

//以空间换时间，快速统计一个unsigned int中有多少个1
const unsigned char popcount_tab[]=
{
    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
    4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8,
};

//把数分成4段进行统计
int popcount (register unsigned int x)
{
    return popcount_tab[(x>>0)&0xff]+popcount_tab[(x>>8)&0xff]+popcount_tab[(x>>16)&0xff]+popcount_tab[(x>>24)&0xff];
}

int Read()
{
	int x=0;char c=getchar();
	while(!isdigit(c))
	{
		c=getchar();
	}
	while(isdigit(c))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	return x;
}

using std::pair;

unsigned int arr[10005];
//将序列下标转换为压位下标与位置
PII trans(int pos)
{
	return PII(pos/32,pos%32);
}

//整个在一个数里的部分xor-1，零散部分挨个处理
void Rev(PII l,PII r)
{
	if(l.first==r.first)
		for(int i=l.second;i<=r.second;++i)
			arr[l.first]^=(1<<i);
	else
	{
		for(int i=l.first+1;i!=r.first;++i)
			arr[i]^=-1;
		for(int i=l.second;i<32;++i)
			arr[l.first]^=(1<<i);
		for(int i=0;i<=r.second;++i)
			arr[r.first]^=(1<<i);
	}
}

//同上
int Query(PII l,PII r)
{
	int res=0;
	if(l.first==r.first)
		for(int i=l.second;i<=r.second;++i)
			res+=(arr[l.first]>>i)&1;
	else
	{
		for(int i=l.first+1;i!=r.first;++i)
			res+=popcount(arr[i]);
		for(int i=l.second;i<32;++i)
			res+=(arr[l.first]>>i)&1;
		for(int i=0;i<=r.second;++i)
			res+=(arr[r.first]>>i)&1;
	}
	return res;
}

char str[200005];

int main()
{
	int n=Read(),m=Read(),opt;
	scanf("%s",str+1);
	for(int i=1;i<=n;++i)
	{
		if(str[i]-'0'==1)
		{
			PII pos=trans(i);
			arr[pos.first]+=1<<pos.second;
		}
	}
	while(m--)
	{
		opt=Read();
		PII l=trans(Read());
		PII r=trans(Read());
		if(opt==0)
		{
			Rev(l,r);
		}
		else
		{
			printf("%d\n",Query(l,r));
		}
	}
	return 0;
}
```

---

## 作者：Holy_Push (赞：20)

像这样的题目一看就知道用分块比线段树方便啦！

我们将数组分为$\sqrt{n}$块，每块大小为$\sqrt{n}$。

我们记录如下变量
- 
1. $blk[i]$，表示$i$属于第几个块。
2. $fst[i]$，表示第$i$个块的起始位置在哪。
3. $lst[i]$，表示第$i$个块的结束位置在哪。
4. $tag[i]$，表示第$i$个块上的懒标记。
5. $a[i]$，表示第$i$盏灯的开关情况。
6. $sum[i][j]$，表示第$i$个块中状态为$j$的灯的数量。其中$j∈${$0,1$}


然后我们就可以分块啦！

## 预处理
先预处理出$blk,fst,lst$。令$h=\sqrt{n}$，则显然有$blk[i]=\lfloor\frac{i}{h}\rfloor+1,fst[i]=(i-1)×h+1,lst[i]=i×h$，或者可以先把$blk$做好，再用一次循环判断一下。特别地，$lst[blk[n]]=n$，也就是最后一个块的结束位置是$n$。
```cpp
h=(int)sqrt(n);
for (int i=1;i<=n;i++) blk[i]=(i-1)/h+1;
for (int i=1;i<=n;i++)
    if (blk[i]!=blk[i-1]) fst[blk[i]]=i,lst[blk[i-1]]=i-1;
lst[blk[n]]=n;
```
然后读入$a$数组并且算好$sum$数组。
```cpp
for (int i=1;i<=n;i++)
{
    char s=getchar();
    while (s!='0'&&s!='1') s=getchar();
    a[i]=s-'0';
    sum[blk[i]][a[i]]++;
}
```
## 修改
根据分块的套路，修改操作应该分为两部分，即两边的修改和中间部分的修改。为了方便起见，在此部分和统计部分中，记$l$所在块为$bl$，$r$所在块为$br$。

两边的修改很简单，两边的数的个数不会超过$2\sqrt{n}$，所以直接暴力修改即可，注意把$a$修改掉的同时不要忘记修改$sum$。
```cpp
for (int i=l;i<=lst[bl];i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
for (int i=fst[br];i<=r;i++) sum[br][a[i]]--,a[i]^=1,sum[br][a[i]]++;
```
中间的修改由于会有很多数，所以不能暴力修改，所以我们选择使用和线段树类似的懒标记$tag$，暴力给中间的块加上懒标记即可。由于我们总的块数只有$\sqrt{n}$块，所以暴力跳块最多只会跳$\sqrt{n}$次。
```cpp
for (int i=bl+1;i<br;i++) tag[i]^=1;
```
注意，如果$bl=br$的话，那么我们无法区分为两边和中间，就直接$l$~$r$暴力修改$a$和$sum$即可。由于$bl=br$，即在同一块内，所以需要修改的数不超过$\sqrt{n}$个。
```cpp
if (bl==br) 
{
    for (int i=l;i<=r;i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
	return;
}
```
#### 修改部分代码
```cpp
void update(int l,int r)
{
    int bl=blk[l],br=blk[r];
    if (bl==br) 
    {
        for (int i=l;i<=r;i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
        return;
    }
    for (int i=bl+1;i<br;i++) tag[i]^=1;
    for (int i=l;i<=lst[bl];i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
    for (int i=fst[br];i<=r;i++) sum[br][a[i]]--,a[i]^=1,sum[br][a[i]]++;
}
```
由于每种情况都不会进行超过$\sqrt{n}$次操作，所以总时间复杂度为$O(\sqrt{n})$。

## 统计
统计其实和修改类似。我们仍然分三种情况讨论。

两边的统计，只要计算$a[i]$^$tag[bl]$（左边）和$a[i]$^$tag[br]$（右边）是否为1即可。
```cpp
for (int i=l;i<=lst[bl];i++) if (a[i]^tag[bl]==1) ans++;
for (int i=fst[br];i<=r;i++) if (a[i]^tag[br]==1) ans++;
```


中间的统计，第$i$块对答案的贡献就是$sum[i][tag[i]$^$1]$。直接加上即可。
```cpp
for (int i=bl+1;i<br;i++) ans+=sum[i][1^tag[i]];
```
如果$bl=br$，则从$l$~$r$循环，按照两边统计的方法统计答案即可。
```cpp
if (bl==br) 
{
    for (int i=l;i<=r;i++) if (a[i]^tag[bl]==1) ans++;
    return ans;
}
```
#### 统计部分代码
```cpp
int query(int l,int r)
{
    int bl=blk[l],br=blk[r],ans=0;
    if (bl==br) 
    {
        for (int i=l;i<=r;i++) if (a[i]^tag[bl]==1) ans++;
        return ans;
    }
    for (int i=bl+1;i<br;i++) ans+=sum[i][1^tag[i]];
    for (int i=l;i<=lst[bl];i++) if (a[i]^tag[bl]==1) ans++;
    for (int i=fst[br];i<=r;i++) if (a[i]^tag[br]==1) ans++;
    return ans;
}
```
同理，时间复杂度为$O(\sqrt{n})$

有$m$次操作，所以总时间复杂度为$O(m\sqrt{n})$。

## 总程序
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,m,h,blk[N],fst[N],lst[N],tag[N],a[N],sum[N][2];

void read(int &x) {scanf("%d",&x);}
void write(int x) {printf("%d\n",x);}

void update(int l,int r)
{
	int bl=blk[l],br=blk[r];
	if (bl==br) 
	{
		for (int i=l;i<=r;i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
		return;
	}
	for (int i=bl+1;i<br;i++) tag[i]^=1;
	for (int i=l;i<=lst[bl];i++) sum[bl][a[i]]--,a[i]^=1,sum[bl][a[i]]++;
	for (int i=fst[br];i<=r;i++) sum[br][a[i]]--,a[i]^=1,sum[br][a[i]]++;
}

int query(int l,int r)
{
	int bl=blk[l],br=blk[r],ans=0;
	if (bl==br) 
	{
		for (int i=l;i<=r;i++) if (a[i]^tag[bl]==1) ans++;
		return ans;
	}
	for (int i=bl+1;i<br;i++) ans+=sum[i][1^tag[i]];
	for (int i=l;i<=lst[bl];i++) if (a[i]^tag[bl]==1) ans++;
	for (int i=fst[br];i<=r;i++) if (a[i]^tag[br]==1) ans++;
	return ans;
}

int main()
{
	read(n);read(m);
	h=(int)sqrt(n);
	for (int i=1;i<=n;i++) blk[i]=(i-1)/h+1;
	for (int i=1;i<=n;i++)
		if (blk[i]!=blk[i-1]) fst[blk[i]]=i,lst[blk[i-1]]=i-1;
	lst[blk[n]]=n;
	for (int i=1;i<=n;i++)
	{
		char s=getchar();
		while (s!='0'&&s!='1') s=getchar();
		a[i]=s-'0';
		sum[blk[i]][a[i]]++;
	}
	for (int i=1;i<=m;i++)
	{
		int opt,l,r;
		read(opt);read(l);read(r);
		if (opt==0) update(l,r);
		if (opt==1) write(query(l,r));
	}
}
```



---

## 作者：llzzxx712 (赞：19)

# P2574
[传送门](https://www.luogu.com.cn/problem/P2574)
## 题意简述
- 给一个长度为n的01串。
- 你需要进行两种操作。1.对区间$[l,r]$中的每一个数进行非运算（由0变为1,1变为0）。2.询问区间$[l,r]$中1的数目
- $2≤n,m≤2×10^5,0≤op≤1,1≤l≤r≤n$

## 题目分析
  看到 $2≤n,m≤2×10^5$ 就可以知道每一次的修改和查询操作复杂度都是 $n \log n$ ，那么这就是一道区间修改+区间查询的线段树了。
  
### 建树
这是一个01串，所以一个区间中1的数目就是这个区间和。所以我们的线段树可以维护4个值：左端点、右端点、区间和、下传标记。就是这个亚子：

```cpp
struct Tree{
	int le,r;
	ll sum,la2;
	#define le(x) a[x].le
	#define r(x) a[x].r
	#define sum(x) a[x].sum
	#define la2(x) a[x].la2 
}a[N*4];
```
建树嘛就按模板建就好了

```cpp
void build(int p,int le,int r){
	le(p)=le,r(p)=r;
	if(le==r){
		sum(p)=b[le];
		return ;
	}
	int mid=(le+r)/2;
	build(p*2,le,mid);
	build(p*2+1,mid+1,r);
	sum(p)=sum(p*2)+sum(p*2+1); 
}
```

### 修改

把区间里的每一个数由0变成1，1变成0，我们就发现，原来一个长度为L的区间里有a个1，操作后就有L-a个1。所以我们只要用区间长度 r-le+1 减掉原来的区间和 sum 就是新的 sum。

至于下传标记就更简单了。对于1个点，它只有两种状态：要修改和不要修改，所以只要用一个布尔变量存它要不要修改就可以了（当然int也可以）

综上，修改代码应该是：

```cpp
void spread(int p){	
	if(!la2(p)) return;
	sum(p*2)=r(p*2)-le(p*2)+1-sum(p*2);//区间长度减掉原区间和，下同 
	sum(p*2+1)=r(p*2+1)-le(p*2+1)+1-sum(p*2+1);
	la2(p*2)=!la2(p*2);la2(p*2+1)=!la2(p*2+1);//1代表要操作，0代表不要操作，两种操作的转换只要 ! 一下就好了 
	la2(p)=0;//清除标记 
}
void change(int p,int le,int r){
	if(le<=le(p)&&r>=r(p)){
		sum(p)=r(p)-le(p)+1-sum(p);//区间长度减掉原区间和
		la2(p)=!la2(p);
		return;
	}
	spread(p);
	int mid=(le(p)+r(p))/2;
	if(mid>=le) change(p*2,le,r);//处理左右 
	if(mid<r) change(p*2+1,le,r);
	sum(p)=sum(p*2+1)+sum(2*p);
}
```
### 询问

按模板打就好了，从下到上累计答案

```cpp
int ask(int p,int le,int r){
	int ans=0;
	if(le(p)>=le&&r(p)<=r){
		return sum(p); 	
	}
	spread(p);
	int mid=(le(p)+r(p))/2;
	if(mid>=le) ans=ans+ask(p*2,le,r);
	if(mid<r) ans=ans+ask(p*2+1,le,r);
	return ans;
}
```

## 完整代码

 ```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 200002
#define ll long long
using namespace std;
int n,m;
int b[N];
struct Tree{
	int le,r;
	ll sum,la2;
	#define le(x) a[x].le
	#define r(x) a[x].r
	#define sum(x) a[x].sum
	#define la2(x) a[x].la2 
}a[N*4];
void build(int p,int le,int r){
	le(p)=le,r(p)=r;
	if(le==r){
		sum(p)=b[le];
		return ;
	}
	int mid=(le+r)/2;
	build(p*2,le,mid);
	build(p*2+1,mid+1,r);
	sum(p)=sum(p*2)+sum(p*2+1); 
}
void spread(int p){	
	if(!la2(p)) return;
	sum(p*2)=r(p*2)-le(p*2)+1-sum(p*2);//区间长度减掉原区间和，下同 
	sum(p*2+1)=r(p*2+1)-le(p*2+1)+1-sum(p*2+1);
	la2(p*2)=!la2(p*2);la2(p*2+1)=!la2(p*2+1);//1代表要操作，0代表不要操作，两种操作的转换只要 ! 一下就好了 
	la2(p)=0;//清除标记 
}
void change(int p,int le,int r){
	if(le<=le(p)&&r>=r(p)){
		sum(p)=r(p)-le(p)+1-sum(p);//区间长度减掉原区间和
		la2(p)=!la2(p);
		return;
	}
	spread(p);
	int mid=(le(p)+r(p))/2;
	if(mid>=le) change(p*2,le,r);//处理左右 
	if(mid<r) change(p*2+1,le,r);
	sum(p)=sum(p*2+1)+sum(2*p);
}
int ask(int p,int le,int r){
	int ans=0;
	if(le(p)>=le&&r(p)<=r){
		return sum(p); 	
	}
	spread(p);
	int mid=(le(p)+r(p))/2;
	if(mid>=le) ans=ans+ask(p*2,le,r);
	if(mid<r) ans=ans+ask(p*2+1,le,r);
	return ans;
}
void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){
    	char c;
    	cin>>c;
    	b[i]=c-'0';//b存原串 
	}
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int c,x,y,k;
		read(c),read(x),read(y);
		switch(c){
			case 0:change(1,x,y);break;
			case 1:printf("%d\n",ask(1,x,y));break;
		}
	}
	return 0;
}
	

```

~~**写题解不易，点个赞呗**~~



---

## 作者：Drifterming (赞：14)

/\*将lazy数组改一下，标志取反。\*/

 







```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#define lson root<<1,l,mid
#define rson root<<1|1,mid+1,r
#define N 200005
using namespace std;
string a;
int n,m,p,l,r;
int num[N],tree[N<<2],lazy[N<<2];
void push(int root)
{
    tree[root]=tree[root<<1]+tree[root<<1|1];
}
void pushdown(int root,int len)
{
    if(lazy[root])
    {
        lazy[root<<1]^=1;    //标志以当节点为根的子树要取反 
        lazy[root<<1|1]^=1;
        tree[root<<1]=(len-(len>>1))-tree[root<<1];        //异或，将原先状态全部翻转
        tree[root<<1|1]=(len>>1)-tree[root<<1|1];    //该区间一共(r-l+1)>>1 个元素，减去自己即为异或后状态 
        lazy[root]=0;
    }
}
void build(int root,int l,int r)
{
    if(l==r)    //找到叶子节点 
    {
        scanf("%1d",&tree[root]);    //%1d，只输入一个数字 
        return;
    }
    int mid=(l+r)>>1;
    build(lson);    //建左子树 
    build(rson);    //建右子树 
    push(root);
}
int query(int root,int l,int r,int L,int R)
{
    if(L<=l&&r<=R) return tree[root];    //查询区间包含当前区间，直接返回当前区间的值 
    pushdown(root,r-l+1);    //将lazy数组下放，更新子树节点 
    int mid=(l+r)>>1;
    int sum=0;
    if(L<=mid) sum+=query(lson,L,R);    //查询左子树 
    if(mid<R) sum+=query(rson,L,R);        //查询右子树 
    return sum;
}
void update(int root,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
    {
        lazy[root]^=1;    //表示以当前节点为根的子树要取反 
        tree[root]=r-l+1-tree[root];    //将当前子树中的值全部异或，总数减去当前数即为异或后的值 
        return;
    }
    pushdown(root,r-l+1);    //更新子树 
    int mid=(l+r)>>1;
    if(L<=mid) update(lson,L,R);    //更新左子树 
    if(mid<R) update(rson,L,R);        //更新右子树 
    push(root);
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&p,&l,&r);
        if(p==0)
        {
            update(1,1,n,l,r);
        }
        else
        {
            printf("%d\n",query(1,1,n,l,r));
        }
    }
    return 0;
}
```

---

## 作者：Treaker (赞：7)

## 指针题解来一发！！！
这道题很简单，一眼切。

我们考虑区间异或以后，这个区间1的个数就变为了len - 原来的个数。

对于标记我们可以通过取异或来维护就行了
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 200020;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m;
char s[N];
struct Segment_tree
{
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r , sum , tag;
		node (int l = 0,int r = 0) : l(l) , r(r) {sum = tag = 0;}
		inline int len() {return r - l + 1;}
		inline void up() {sum = ls -> sum + rs -> sum;}
		inline void down() 
		{
			if(tag)
			{
				ls -> tag ^= 1;
				rs -> tag ^= 1;
				tag = 0;
				ls -> sum = ls -> len() - ls -> sum;
				rs -> sum = rs -> len() - rs -> sum;
			}
		}
	}*root;
	void build(node *&p,int l,int r)
	{
		p = new node(l,r);
		if(l == r)	return (void)(p -> sum = (s[l] == '1'));
		build(p -> ls,l,mid);
		build(p -> rs,mid+1,r);
		p -> up();
	}
	void chenge(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y)	
		{
			p -> tag ^= 1;
			p -> sum = p -> len() - p -> sum;
			return;
		}
		if(p -> tag)	p -> down();
		if(x <= mid) chenge(p -> ls,x,y);
		if(y > mid)	chenge(p -> rs,x,y);
		p -> up();
	}
	int query(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y)	return p -> sum;
		if(p -> tag)	p -> down();
		int res = 0;
		if(x <= mid)	res += query(p -> ls,x,y);
		if(y > mid)		res += query(p -> rs,x,y);
		return res;
	}
	inline void LOL()
	{
		n = read(); m = read();
		scanf("%s",s+1);
		build(root,1,n);
		for(int i = 1 , opt , l , r;i <= m;i ++)
		{
			opt = read(); l = read(); r = read();
			if(opt & 1)	printf("%d\n",query(root,l,r));
			else chenge(root,l,r);
		}
	}
}CF;
int main()
{
	CF.LOL();
	return 0;
}

```


---

## 作者：yizimi远欣 (赞：5)

### 主要思路：线段树

~~线段树大法好~~

我觉得这道题就是把区间修改，区间查询的普通线段树改了改懒标记就完了

不会线段树？不着急啊，我们有入门宝典——

#### 具体线段树入门：

[入门1：单点修改，区间查询](https://yizimiyuanxin.blog.luogu.org/ac-jun-tuan-zhou-bao-xian-duan-shu-zong-ru-men-dao-ru-tu)

[入门2：懒标记及区间修改](https://yizimiyuanxin.blog.luogu.org/ac-jun-tuan-zhou-bao-di-er-zhou-xian-duan-shu-zong-ru-men-dao-ru-tu-post)

~~Blog发完就跑~~

记得，这里的xor如果xor两次就相当于没操作，所以我们在维护懒标记时可以再偷点懒，每次懒标记取反。

我们区间取反时，实际上是原来是0，现在变为1，原来是1，现在变为0，他们的数目是互补的，所以区间取反后1的数目就是之前0的数目

### 代码：

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 222222
#define inf 2147483647
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
//#define LOCAL
#define mod 
#define Debug(...) fprintf(stderr, __VA_ARGS__)
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
//This is AC head above...
int z[mn << 2], col[mn << 2], a[mn];
inline void update(int rt){
    z[rt] = z[rt << 1] + z[rt << 1 | 1];
}
inline void color(int l,int r,int rt){
    z[rt] = (r - l + 1) - z[rt];
    col[rt] ^= 1;
}
inline void push_col(int l,int r,int rt){
    if(col[rt]){
        int m = (l + r) >> 1;
        color(lson);
        color(rson);
        col[rt] = 0;
    }
}
inline void build(int l,int r,int rt){
    if(l==r){
        z[rt] = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(lson);
    build(rson);
    update(rt);
}
inline void modify(int l,int r,int rt,int nowl,int nowr){
    if(nowl<=l && r<=nowr){
        col[rt] ^= 1;
        z[rt] = (r - l + 1) - z[rt];
        return;
    }
    int m = (l + r) >> 1;
    push_col(bson);
    if(nowl<=m)
        modify(lson, nowl, nowr);
    if(m<nowr)
        modify(rson, nowl, nowr);
    update(rt);
}
inline int query(int l,int r,int rt,int nowl,int nowr){
    if(nowl<=l && r<=nowr){
        return z[rt];
    }
    int m = (l + r) >> 1;
    push_col(bson);
    if(nowl<=m){
        if(m<nowr)
            return query(lson, nowl, nowr) + query(rson, nowl, nowr);
        else
            return query(lson, nowl, nowr);
    }else
        return query(rson, nowl, nowr);
}
int n, m;
inline void debug(){
    go(i, 1, n, 1) printf("%d ", a[i]);
    puts("");
}
int main(){
    n = read(), m = read();
    string c;
    cin >> c;
    go(i, 0, n - 1, 1)
        a[i + 1] = c[i] - '0';
    //debug();
    build(root);
    go(i,1,m,1){
        int s = read(), x = read(), y = read();
        if(!s)
            modify(root, x, y);
        else
            cout << query(root, x, y) << "\n";
    }
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
    return 0;
}

```

#### 第十三次发题解，希望可以帮助初学者入门线段树

---

## 作者：Jameswood (赞：5)

线段树（范围修改，范围查询），运用懒惰标记

本题要点在于串的长度极长，所以强行模拟是行不通的（一点一点累加的做法），本人实测只有70分。

[R8445976 评测详情（强行暴力模拟）](https://www.luogu.org/recordnew/show/8445976)

所以我们在这里进行线段树求和操作，要点在于改变一个区间的和时只需将范围内的总数减去当前数值即可。

需要重点注意的是在进行Update更新时，如果所求区间在一半而不在mid左右时，一定要将另外一段也进行pushdown（因为此区间的懒惰标记已经更新），不然后果很严重。


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
const int SIZE=400006;
int n,m,a[SIZE|1],AnsQuery=0;
char s[SIZE|1];
struct SegTree{
    int l,r,v;
    bool la;
}t[SIZE<<2|1];
void PushUp(int id);
void PushDown(int id);
void Build(int id,int l,int r);
void Update(int id,int l,int r);
void Query(int id,int l,int r);
int main(){
    int con,x,y;
    scanf("%d%d%s",&n,&m,s+1);
    for(int i=1;i<=n;i++) a[i]=s[i]-'0';
    Build(1,1,n);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&con,&x,&y);
        if(con==0){
            Update(1,x,y);
        }
        else{
            AnsQuery=0;
            Query(1,x,y);
            printf("%d\n",AnsQuery);
        }
    }
    return 0;
}


void Build(int id,int l,int r){
    t[id].l=l;t[id].r=r;t[id].la=0;
    int mid=(l+r)>>1;
    if(l==r) t[id].v=a[t[id].l];
    else{
        Build(id<<1,l,mid);
        Build(id<<1|1,mid+1,r);
        PushUp(id);
    }
}

void PushUp(int id){
    t[id].v=t[id<<1].v+t[id<<1|1].v;
}

void PushDown(int id){
    if(t[id].la==1){
        t[id<<1].la=1-t[id<<1].la;t[id<<1|1].la=1-t[id<<1|1].la;
        t[id].v=t[id].r-t[id].l+1-t[id].v;
        t[id].la=0;
    }
}

void Update(int id,int l,int r){
    PushDown(id);
    if(t[id].l==l&&t[id].r==r) {
        t[id].la=1-t[id].la;
        PushDown(id); 
    } 
    else{
        int mid=(t[id].l+t[id].r)>>1; 
        if(l>mid){
            Update(id<<1|1,l,r);
            PushDown(id<<1);
        }
        else{
            if(r<=mid){
                Update(id<<1,l,r);
                PushDown(id<<1|1);
            }
            else{
                Update(id<<1,l,mid); Update(id<<1|1,mid+1,r);
            }
        }
        PushUp(id);
    } 
}

void Query(int id,int l,int r){
    PushDown(id);
    if(t[id].l==l&&t[id].r==r) AnsQuery+=t[id].v;
    else{
        int mid=(t[id].l+t[id].r)>>1;
        if(l>mid) {
            Query(id<<1|1,l,r);
            PushDown(id<<1);
        }
        else{
            if(r<=mid){
                Query(id<<1,l,r);
                PushDown(id<<1|1);
            }
            else{
                Query(id<<1,l,mid); Query(id<<1|1,mid+1,r); 
            }
        }
    }
}
```

---

## 作者：假装思考 (赞：3)

分块大法好，修改方式改一下就A了，具体看注释。
运行速度不算快，但是写起来是真快。
```
#include<bits/stdc++.h>
using namespace std;
int A[200001],Lft[501],Rgt[501],GPS[200001],Sum[501];
bool Inc[501];							//Inc[i]表示第i块取了多少次反(偶数次等价于0次,奇数次等价于1次) 
int n,m,i,j,x,y,Len,Tot,Ins;
void Modify(int l,int r){				//修改操作 
	if(GPS[l]==GPS[r]){					//判断是否在一个块内(防止重复,下同) 
		for(int i=l;i<=r;++i)
			if(A[i])
				A[i]=0,Sum[GPS[l]]--;	//更新时将A[i]取反,并且更新Sum[] 
			else
				A[i]=1,Sum[GPS[l]]++;
		return;
	}
	for(int i=l;i<=Rgt[GPS[l]];++i)		//零碎块暴力 
		if(A[i])
			A[i]=0,Sum[GPS[l]]--;
		else
			A[i]=1,Sum[GPS[l]]++;
	for(int i=r;i>=Lft[GPS[r]];--i)
		if(A[i])
			A[i]=0,Sum[GPS[r]]--;
		else
			A[i]=1,Sum[GPS[r]]++;
	for(int i=GPS[l]+1;i<GPS[r];++i)	//整块修改Inc[] 
		Inc[i]=1-Inc[i];
}
int Query(int l,int r){
	int Ret=0;
	if(GPS[l]==GPS[r]){
		for(int i=l;i<=r;++i)
			if(A[i]^Inc[GPS[l]])		//要xor一下Inc[] 
				++Ret;
		return Ret;
	}
	for(int i=l;i<=Rgt[GPS[l]];++i)
		if(A[i]^Inc[GPS[l]])
			++Ret;
	for(int i=r;i>=Lft[GPS[r]];--i)
		if(A[i]^Inc[GPS[r]])
			++Ret;
	for(int i=GPS[l]+1;i<GPS[r];++i)	//如果整块修改过奇数次要返回0的个数 
		if(Inc[i])
			Ret+=(Rgt[i]-Lft[i]+1)-Sum[i];
		else
			Ret+=Sum[i];
	return Ret;
}
int main(){
	scanf("%d%d",&n,&m);
	Len=sqrt(n);					//分块常规操作 
	Tot=n/Len;
	if(n%Len)
		++Tot;
	for(i=1;i<=n;++i){
		char c;
		cin>>c;
		A[i]=c-'0';
		GPS[i]=(i-1)/Len+1;
		if(A[i])
			++Sum[GPS[i]];			//Sum[i]保存第i块里1的个数 
	}
	for(i=1;i<=Tot;++i){
		Lft[i]=(i-1)*Len+1;
		Rgt[i]=i*Len;
	}
	Rgt[Tot]=n;
	while(m--){
		scanf("%d%d%d",&Ins,&x,&y);
		if(Ins==0)
			Modify(x,y);
		if(Ins==1)
			printf("%d\n",Query(x,y));
	}
	return 0;
}
```

---

## 作者：zhenglier (赞：3)

## 看题解中好像没有分块的，于是本蒟蒻就写了个分块

对于这种数据比较水的题目，分块甚至会比线段树更方便。
~~因为线段树代码非常长，且点一下，调一年。~~

分块的思想非常简单，就是大块维护，小块暴力。把长度为n的数列分到sqrt(n)块，预处理每一个块的和，每个块存一个懒标记。

### 对于每一个询问，在区间内的块直接把和加到答案里，两头的数暴力加入。

### 对于每一个查询，在区间内的块直接修改懒标记，两头的数暴力修改。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,T,len;
int k=1,a[200010],bk[200010],bl[500][500],sum[500],lan[500];
inline int read()
{//快读？
	char c=getchar();
	for(;c!='0' && c!='1';c=getchar());
	return (int)(c-'0');
 } 
 inline int query(int l,int r)
 {//求和
 	int i,ret=0;
 	for(i=l;bk[i]==bk[l] && i<=r;++i){
 		if(lan[bk[i]]){
 			ret+=(a[i]^1);
		 }else ret+=a[i];
	 }//处理前半部分
	 for(;i+len<=r;i+=len){
	 	if(lan[bk[i]]){
	 		ret+=(bl[bk[i]][0]-sum[bk[i]]);
		 }else ret+=sum[bk[i]];
	 	
	 }//处理块
	 for(;i<=r;++i){
	 	if(lan[bk[i]]){
	 		ret+=a[i]^1;
		 }
		 else ret+=a[i];
	 }//处理后半部分
	 return ret;
 }
 inline void add(int l,int r)
 {
 	int i;
 	for(i=l;bk[i]==bk[l] && i<=r;++i){
 		if(lan[bk[i]]){
 			if(a[i]){
 			    sum[bk[i]]--;
			 }
			 else sum[bk[i]]++;
		 }
		 else if(a[i]){
		 sum[bk[i]]--;
		 } else sum[bk[i]]++;
 		a[i]^=1;
	 }//处理前半部分
	 for(;i+len<=r;i+=len){
	 	lan[bk[i]]^=1;
	 }//处理块
	 for(;i<=r;++i){
	     if(lan[bk[i]]){
 			if(a[i]){
 			    sum[bk[i]]--;
			 }
			 else sum[bk[i]]++;
		 }
		 else if(a[i]){
		 sum[bk[i]]--;
		 } else sum[bk[i]]++;
	 	a[i]^=1;
	 }//处理后半部分
 }
int main()
{
	cin>>n>>T;
	len=(int)sqrt(n);
	for(int i=1;i<=n;++k){
		int j=1;
		for(;j<=len && i<=n;++j,++i){
			a[i]=bl[k][j]=read();
			bk[i]=k;
			sum[k]+=bl[k][j];
		}
		bl[k][0]=j-1;
	}
//	for(int i=1;i<=n;++i)cout<<a[i];puts("");
	int _a,_b,_c;
	while(T--){
		scanf("%d%d%d",&_a,&_b,&_c);
		if(_a==0){
			add(_b,_c);
		}
		if(_a==1){
			printf("%d\n",query(_b,_c));
		}
//	     for(int i=1;i<=n;++i)
//	         if(lan[bk[i]]){
//	         	cout<<(a[i]^1);
//			 }else cout<<a[i];
//		puts("");
	}
}
```

---

## 作者：worcher (赞：2)

线段树模板套一下就可以了


维护区间为1的数的个数，修改次数是2的倍数的时候相当于没有修改，所以可以将修改次数看为\*-1，为1时则修改，为-1时则没修改


---

## 作者：Dark_lightrq (赞：1)

首先凭直觉感觉是线段树，关键是怎么来维护

对操作2，我们要查询区间[x,y]的和，也就是[x,y]中1的个数，为了达到询问logn复杂度，我们可以对每个节点维护一段区间内1出现的次数

接下来解决操作1


注意到在区间异或上1后，区间里的数0变成了1,1变成了0，因为我们维护了区间1出现的次数，我们就可以知道修改后区间中0的出现次数，那我们只要再维护下原本区间0出现的次数，那我们就可以知道修改后1出现的次数了，并且这些出现次数是满足区间加法的，很好维护

所以操作1对线段树的影响就是将区间中0的个数与区间中1的次数交换了一下，并且可以用个懒标记来方便的下传影响，只要在查询和修改时下传一下就好了

上代码~~~



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m;//模板啦
struct E_tree{
	int sum0[N<<2],sum1[N<<2],lz[N<<2];//sum0为0出现次数，sum1为1出现次数，lz为标记
	#define ls(p) p<<1
	#define rs(p) p<<1|1
	void push_up(int p){
		sum0[p]=sum0[ls(p)]+sum0[rs(p)];
		sum1[p]=sum1[ls(p)]+sum1[rs(p)];
	}
	void ad(int p){
		swap(sum0[p],sum1[p]);
		lz[p]^=1;
	}
	void push_down(int p){
		if(!lz[p])return;
		ad(ls(p));
		ad(rs(p));
		lz[p]=0;
	}
	void build(int p,int l,int r){
		if(l==r){
			int k;
			scanf("%1d",&k);
			if(k)sum1[p]=1;
			else sum0[p]=1;
			return;
		}
		int mid=l+r>>1;
		build(ls(p),l,mid);
		build(rs(p),mid+1,r);
		push_up(p);
	}
	void add(int p,int l,int r,int x,int y){
		if(l>y||r<x)return;
		if(x<=l&&r<=y){
			ad(p);
			return;
		}
		push_down(p);
		int mid=l+r>>1;
		add(ls(p),l,mid,x,y);
		add(rs(p),mid+1,r,x,y);
		push_up(p);
	}
	int ask(int p,int l,int r,int x,int y){
		if(l>y||r<x)return 0;
		if(x<=l&&r<=y)return sum1[p];
		push_down(p);
		int mid=l+r>>1;
		return ask(ls(p),l,mid,x,y)+ask(rs(p),mid+1,r,x,y);
	}
}T;//结构体避免冲突，用出STL的感觉
int main(){
	scanf("%d%d",&n,&m);
	T.build(1,1,n);
	int o,x,y;
	while(m--){
		scanf("%d%d%d",&o,&x,&y);
		if(o==1)printf("%d\n",T.ask(1,1,n,x,y));
		else T.add(1,1,n,x,y);
	}
	return 0;
}
```
上面可能没解释清楚，如果有不懂的小伙伴可以来私信问我，蒟蒻必（zi）将（ji）大（dou）力（bu）相（zhi）助（dao），~~（逃~~


---

## 作者：清远学会 (赞：0)

# 遇事不决先分块
> 分块，即可感受暴力的美感，也可感受AC的快感

用分块维护区间和，当然在维护区间的lazy标志，用0表该区间未有标志，1表该区间有标志。

接下来就可以大力分块啦：

我的分块打的比较暴力，在处理残块是直接下放标记，复杂度不是很优但还是可以接受(2.01s)

### 再不懂代码里有注释：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#define N 300500
using namespace std;

int n,m;
char s[N];//将01字符串读入
int a[N],sum[N],lz[N];//区间和与lazy标志数组
int tag[N],L[N],R[N];
//分块 tag[i]表i所在的块的编号，L[i]和R[i]为第i块的左右端点在原数组的位置

//下放标记的函数，此处为暴力修改
inline void Update(int k) {
	if(lz[tag[k]]) {
		sum[tag[k]] = R[tag[k]] - L[tag[k]] + 1 - sum[tag[k]];
        //异或的下放，把区间和中1变0，直接减去即可
		for(int i = L[tag[k]];i <= R[tag[k]];i ++) a[i] ^= 1;
		lz[tag[k]] = 0;//下放后标志消失
	}
}

//修改函数
inline void Change(int l,int r) {
	if(tag[l] == tag[r]) { //对于残块暴力即可
		Update(l);
		for(int i = l;i <= r;i ++)
			sum[tag[l]] -= a[i],
			a[i] ^= 1,
			sum[tag[l]] += a[i];
		return ;
	}
	Update(l);
	for(int i = l;i <= R[tag[l]];i ++) 
		sum[tag[l]] -= a[i], a[i] ^= 1, sum[tag[l]] += a[i];
	for(int i = tag[l] + 1;i < tag[r];i ++) {
		if(lz[i]) lz[i] = 0;
		else lz[i] = 1;
        //根据异或的性质之前有标记的取消，没有的加上
	}
	Update(r);
	for(int i = L[tag[r]];i <= r;i ++) 
		sum[tag[r]] -= a[i], a[i] ^= 1, sum[tag[r]] += a[i];
}

//求和函数
inline int Ask(int l,int r) {
	int res = 0;
	if(tag[l] == tag[r]) {//暴力统计
		Update(l);
		for(int i = l;i <= r;i ++) res += a[i];
		return res;
	}
	Update(l);
	for(int i = l;i <= R[tag[l]];i ++) res += a[i];
	for(int i = tag[l] + 1;i < tag[r];i ++) {
		if(lz[i]) res += R[i] - L[i] + 1 - sum[i];
		else res += sum[i];
        //对于整块，要考虑是否有标记
	}
	Update(r);
	for(int i = L[tag[r]];i <= r;i ++) res += a[i];
	return res;
}

int main() {
	scanf("%d%d%s",&n,&m,s + 1); int len = sqrt(n);
	for(int i = 1;i <= n;i ++) a[i] = (s[i] == '1');
    //对于分块的预处理
	for(int i = 1;i <= n;i ++) tag[i] = (i - 1) / len + 1;
	for(int i = 1;i <= tag[n];i ++)
		L[i] = R[i - 1] + 1,R[i] = min(n,L[i] + len - 1);
	for(int i = 1;i <= tag[n];i ++) 
		for(int j = L[i];j <= R[i];j ++)
			sum[i] += a[j];
    //求区间和
	for(int i = 1;i <= m;i ++) {
		int opt,l,r; scanf("%d%d%d",&opt,&l,&r);
		if(opt == 0) Change(l,r);
		else printf("%d\n",Ask(l,r));
	}
	return 0;
}
```

#### 最后安利下我的[博客](https://sakura1314.blog.luogu.org/#)

---

## 作者：Erusel (赞：0)

~~据说这题好像有六倍经验~~

我们简单分析一下

初始所有数都是0

题目要求支持两种操作，一种是区间异或1，还有一种是区间查询1的个数

考虑到所有数中只有0和1

所以查询可以改为查询区间和

区间异或1也可以从区间和的角度取考虑问题

---

假设我们原来有$k$个1，区间长度为$l$

现在就有$l-k$个1

所以$sum_{now}=l-sum_{pre}$

标记下传也可以维护了

时间复杂度就是维护一颗线段树的时间$O(nlogn)$

code:

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>

#define rd(x) x=read()
#define N 200005 
 
using namespace std;

int n,m;
struct T{
	int l,r,mid,v,tag;
}t[N<<2];

inline int read()
{
    int f=1,x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    return x*f;
}

void pushdown(int rt,int len)
{
	if(t[rt].tag)
    {
        t[rt<<1].tag^=1; 
        t[rt<<1|1].tag^=1;
        t[rt<<1].v=(len-(len>>1))-t[rt<<1].v;
        t[rt<<1|1].v=(len>>1)-t[rt<<1|1].v;
        t[rt].tag=0;
    }
}

void build(int rt,int l,int r)
{
	int mid=(l+r)>>1;
	t[rt].l=l,t[rt].r=r,t[rt].mid=mid,t[rt].tag=0;
	if(l==r)
	{
		scanf("%1d",&t[rt].v);
		return;
	}
	build(rt<<1,l,mid);
	build(rt<<1|1,mid+1,r);
	t[rt].v=t[rt<<1].v+t[rt<<1|1].v;
}

void update(int rt,int l,int r)
{
    if(l<=t[rt].l&&t[rt].r<=r)
    {
        t[rt].tag^=1;     
        t[rt].v=t[rt].r-t[rt].l+1-t[rt].v;    
        return;
    }
    pushdown(rt,t[rt].r-t[rt].l+1);
    if(l<=t[rt].mid)update(rt<<1,l,r);    
    if(t[rt].mid<r)update(rt<<1|1,l,r);        
    t[rt].v=t[rt<<1].v+t[rt<<1|1].v; 
}
int query(int rt,int l,int r)
{
    if(l<=t[rt].l&&t[rt].r<=r)return t[rt].v;
    pushdown(rt,t[rt].r-t[rt].l+1);
    int sum=0;
    if(l<=t[rt].mid)sum+=query(rt<<1,l,r); 
    if(t[rt].mid<r)sum+=query(rt<<1|1,l,r);        
    return sum;
}

int main()
{
	rd(n),rd(m);
	build(1,1,n);
	while(m--)
	{
		int opt,l,r;
		rd(opt),rd(l),rd(r);
		if(opt)printf("%d\n",query(1,l,r));
		else update(1,l,r);	
	}
	
	return 0;
}


```

---

## 作者：寒冰大大 (赞：0)

个人认为比较好理解的线段树代码

因为是异或，并且只有1 和 0 两个状态，所以每次区间异或后，我们只需要把该区间0的数量和1的数量交换一下就好了。

另外注意pushdown是cg（change）需要每次异或一下，单纯的赋值会出现这种问题：

	1^1=0     1^1^1=1
    而单纯赋值，则会变成1^1^1出现0的情况。
    
另外没什么问题，很好的一道线段树题目
```cpp
//头文件您就自己写吧 

#define lson i*2,l,mid
#define rson i*2+1,mid+1,r
#define ls i*2
#define rs i*2+1

using namespace std;

int n,m,a[200500];

struct tree{
	int l,r,ope,clo,cg;
}t[800400];

void build_tree(int i,int l,int r)
{
	t[i].l=l;
	t[i].r=r;
	if(l==r) 
	{
		t[i].clo=!a[l];  //由于只有0 1两种状态 ！0=1 
		t[i].ope=a[l];
		return ;
	}
	int mid=(l+r)/2;
	build_tree(lson);
	build_tree(rson);
	t[i].clo=t[ls].clo+t[rs].clo;
	t[i].ope=t[ls].ope+t[rs].ope;
	return ;
}

void pushdown(int i)
{
	if(!t[i].cg) return ;
	t[i].cg=0;
	t[ls].cg^=1;   //记得标记下传 异或两次==不异或 
	t[rs].cg^=1;
	swap(t[ls].clo,t[ls].ope);
	swap(t[rs].clo,t[rs].ope);
}

void change_tree(int i,int l,int r,int x,int y)
{
	if(l>=x&&r<=y)
	{
		t[i].cg^=1;
		swap(t[i].ope,t[i].clo);  //交换一下就好了 
		return ;	
	}
	pushdown(i);
	int mid=(l+r)/2;
	if(x<=mid) change_tree(lson,x,y);
	if(y>mid) change_tree(rson,x,y);
	t[i].clo=t[ls].clo+t[rs].clo; //每次pushdown记得加上这句话 
	t[i].ope=t[ls].ope+t[rs].ope;
	return ;
}

int ask_ope_tree(int i,int l,int r,int x,int y)
{
	if(l>=x&&r<=y) return t[i].ope;
	pushdown(i);
	int mid=(l+r)/2;
	int ans=0;
	if(x<=mid) ans+=ask_ope_tree(lson,x,y);
	if(y>mid) ans+=ask_ope_tree(rson,x,y);
	t[i].clo=t[ls].clo+t[rs].clo;  //这段话记得加上 
	t[i].ope=t[ls].ope+t[rs].ope;
	return ans;
}

int main()
{
	int i,j;
	scanf("%d %d\n",&n,&m);  //记得读入空格 
	for(i=1;i<=n;i++)
	{
		char t1;
		scanf("%c",&t1);
		a[i]=t1-'0';
	}
	build_tree(1,1,n);
	for(i=1;i<=m;i++)
	{
		int t1,t2,t3;
		scanf("%d %d %d",&t1,&t2,&t3);
		if(t1==0) change_tree(1,1,n,t2,t3);
		else printf("%d\n",ask_ope_tree(1,1,n,t2,t3));
	}
	return 0;
}
```


---

## 作者：zrzluck99 (赞：0)

这是一道线段树裸题

首先由于 $xor$ 运算具有交换律和结合律，所以 $lazy$ 标志可以向下传递，即 $lazy[child] = lazy[child]$ $xor$ $lazy[root]$，并且只有 $0$ 和 $1$ 两种状态。

由于数组中只有 $0$ 和 $1$ ，所以我们只要维护区间和就能维护区间中 $1$ 的数量。假设一个区间和为 $n$ ，则对这个区间 $xor$ $1$ （即每个数取反）后，区间和为 $len-n$。

由此我们便可以推出具体代码了。

------------

```c++
#include<bits/stdc++.h>
using namespace std;
#define INF_MAX 0x3f3f3f3f
#define Arr_MAX 200001
typedef long long ll;

ll read() { //快读
    ll s=0,w=1; char ch=getchar();
    while (ch<'0'||ch>'9') {if (ch=='-') w=-1; ch=getchar();}
    while (ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}

ll a[Arr_MAX],segtree[5*Arr_MAX],lazy[5*Arr_MAX];
int n,m; char ch;

void build(int root,int sleft,int sright) {
    if (sleft == sright) {
        segtree[root] = a[sleft]; lazy[root] = 0;
        return;
    }
    int mid = (sleft+sright)/2;
    build(root*2,sleft,mid);
    build(root*2+1,mid+1,sright);
    segtree[root] = segtree[root*2]+segtree[root*2+1]; lazy[root] = 0;
}

void pushdown(int root,int left1,int right1,int left2,int right2) { //此处下传lazy标志
    if (lazy[root] != 0) {
        lazy[root*2] ^= lazy[root];
        lazy[root*2+1] ^= lazy[root];
        segtree[root*2] = (right1-left1+1)-segtree[root*2];
        segtree[root*2+1] = (right2-left2+1)-segtree[root*2+1];
        lazy[root] = 0;
    }
}

void update(int root,int sleft,int sright,int qleft,int qright) {
    if (sleft>qright||sright<qleft) return;
    if (sleft>=qleft&&sright<=qright) {
        segtree[root] = (sright-sleft+1)-segtree[root];
        lazy[root] ^= 1;
        return;
    }
    int mid = (sleft+sright)/2;
    pushdown(root,sleft,mid,mid+1,sright);
    update(root*2,sleft,mid,qleft,qright);
    update(root*2+1,mid+1,sright,qleft,qright);
    segtree[root] = segtree[root*2]+segtree[root*2+1];
}

ll query(int root,int sleft,int sright,int qleft,int qright) {
    if (sleft>qright||sright<qleft) return 0;
    if (sleft>=qleft&&sright<=qright) return segtree[root];
    int mid = (sleft+sright)/2;
    pushdown(root,sleft,mid,mid+1,sright);
    return query(root*2,sleft,mid,qleft,qright)+query(root*2+1,mid+1,sright,qleft,qright);
}

int main() {
    ios::sync_with_stdio(false);
    n = read(); m = read(); ch = getchar(); while (ch!='0'&&ch!='1') ch = getchar(); 
    for (int i=1;i<=n;i++) a[i] = ch-'0', ch = getchar(); //这样读字符可以避免换行和多余空格的问题
    build(1,1,n);
    for (int i=1;i<=m;i++) {
        int q,x,y; q = read();
        if (q == 0) {
            x = read(); y = read();
            update(1,1,n,x,y);
        } else {
            x = read(); y = read();
            printf("%lld\n",query(1,1,n,x,y));
        }
    }
    return 0;
}
```

---

## 作者：AcerMo (赞：0)

^的性质，0或1^0不变，^1就是取反，所以只考虑当前lazy%2=1或0,0就跳过，lazy不用清空，因为每次操作都是^1，之后实际操作时，不难发现，一个01串^1后的1的个数就是当前线段树区间的长度-当前区间的sum，所以执行^操作时，只需要把sum更新成这个就好，lazy下放也一样，子区间也是这么更新
```cpp
//By AcerMo
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=500500;
struct Tree
{
    int son[2],bond[2];
    int la,asum;
}t[M];
int n,m;
string s;
int num[M],cnt=1,rt=0;
void up(int x)
{
    int ls=t[x].son[0];
    int rs=t[x].son[1];
    t[x].asum=t[ls].asum+t[rs].asum;
    t[x].bond[0]=t[ls].bond[0];
    t[x].bond[1]=t[rs].bond[1];
    return ;
}
void built(int l,int r,int cur)
{
    if (l==r) 
    {
        t[cur].asum=num[l];
        t[cur].bond[0]=t[cur].bond[1]=l;
        t[cur].son[0]=t[cur].son[1]=-1;
        return ; 
    }
    t[cur].son[0]=cnt++;
    t[cur].son[1]=cnt++;
    int mid=(l+r)>>1;
    built(l,mid,t[cur].son[0]);
    built(mid+1,r,t[cur].son[1]);
    up(cur);
    return ;
}
void down(int x)
{
    if (t[x].la%2==0) return ;
    int ls=t[x].son[0];
    int rs=t[x].son[1];
    t[ls].asum=(t[ls].bond[1]-t[ls].bond[0]+1-t[ls].asum);
    t[rs].asum=(t[rs].bond[1]-t[rs].bond[0]+1-t[rs].asum);
    t[ls].la++;
    t[rs].la++;
    t[x].la=0;
    return ;
}
void date(int l,int r,int val,int cur)
{
    if (l<=t[cur].bond[0]&&t[cur].bond[1]<=r)
    {
        t[cur].asum=(t[cur].bond[1]-t[cur].bond[0]+1-t[cur].asum);
        t[cur].la++;
        return ;
    }
    down(cur);
    int mid=(t[cur].bond[0]+t[cur].bond[1])>>1;
    if (l<=mid) date(l,r,val,t[cur].son[0]);
    if (r>mid) date(l,r,val,t[cur].son[1]);
    up(cur);
    return ;
}
int query(int l,int r,int x)
{
    if (l<=t[x].bond[0]&&t[x].bond[1]<=r) return t[x].asum;
    down(x);up(x);int tot=0;
    int mid=(t[x].bond[0]+t[x].bond[1])>>1;
    if (l<=mid) tot+=query(l,r,t[x].son[0]);
    if (r>mid) tot+=query(l,r,t[x].son[1]);
    return tot; 
}
int main()
{
    scanf("%d %d",&n,&m);cin>>s;
    for (int i=1;i<=n;i++) num[i]=s[i-1]-'0';
    built(1,n,rt);
    while (m--)
    {
        int a,b,c;
        scanf("%d %d %d",&a,&b,&c);
        if (a==0)
        {
            date(b,c,1,rt);
        }
        else cout<<query(b,c,rt)<<endl;
    }
    return 0;
}
```

---

## 作者：lxzy_Zby (赞：0)

可以用分块解决，把n个数分成sqrt(N)块，每块sqrt(N)个，查询的时候单独查询前端和后端的散块，中间的整块直接用预先处理好的块内整数和。

修改的时候先修改前端后端的散块，再修改中间的整块，修改的过程中直接就可以把每一块内的整数一同修改了，因为是异或，所以直接拿块数的个数-当前块内整数和就是新的块内整数和了。

附带大常数代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int MAXN = 220000;
inline int read(){
	int w = 1, data = 0; char ch = 0;
	while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if(ch == '-') w = -1, ch = getchar();
	while(ch >= '0' && ch <= '9') data = data * 10 + ch - '0', ch = getchar();
	return w * data;
}
char str[MAXN];
int a[MAXN], block[MAXN], sum[MAXN], tag[MAXN], fl[MAXN];
int n, m, op;
void reset(int rt){
	sum[rt] = 0; int r = min(rt*op, n);
	for(int i = (rt-1)*op+1; i <= r; i++)
		sum[rt] += (a[i] ^ tag[rt]);	
}
void rever(int l, int r){
	if(block[l] == block[r]){
		for(int i = l; i <= r; i++) a[i] ^= 1;
		reset(block[l]);
	}else{
		for(int i = l; i <= (block[l])*op; i++) a[i] ^= 1;
		for(int i = (block[r]-1)*op + 1; i <= r; i++) a[i] ^= 1;
		reset(block[l]); reset(block[r]);
		
	}
	for(int i = block[l]+1; i <= block[r]-1; i++)
		sum[i] = fl[i] - sum[i], tag[i] ^= 1;
}
int query(int l, int r){
	int ans = 0;
	if(block[l] == block[r]){
		for(int i = l; i <= r; i++) 
			ans += (a[i] ^ tag[block[i]]);
	}else{
		for(int i = l; i <= (block[l])*op; i++)
			ans += (a[i] ^ tag[block[i]]);
		for(int i = (block[r]-1)*op + 1; i <= r; i++)
			ans += (a[i] ^ tag[block[i]]);
	}
	for(int i = block[l]+1; i <= block[r]-1; i++)
		ans += sum[i];
	return ans;
}
int main(){
	n = read(); m = read(); op = sqrt(n);
	scanf("%s",str+1);
	for(int i = 1; i <= n; i++){
		a[i] = str[i] - '0';
		block[i] = (i-1)/op+1;
		fl[block[i]]++;
	}
	for(int i = 1; i <= block[n]; i++) reset(i);
	for(int i = 1; i <= m; i++){
		int ch = read(), l = read(), r = read();
		if(ch == 0) rever(l, r);
		else printf("%d\n", query(l, r));
	}
	return 0;
}

```

---

## 作者：Frankenstein (赞：0)

P2574再练一道线段树的题。

题意是长度为n的01字串，询问区间1的个数，区间更新为将区间中的数xor 1。

于是就很清楚了，由于xor 1即将区间中0,1互换，因此线段树节点存区间0的个数和1的个数，线段树维护区间和。又由于xor 1两次即不变，lazytag的操作只需要取反即可。

题目是XOR的艺术，为了照应，也尝试了一下一些细节的位运算写法（

根rt,左子树rt<<1,右子树rt<<1|1（

```cpp
#include<stdio.h>
#define MAX 200005
struct node{
    int zero,one;
    int lazy;
};
struct node segtree[MAX*4];

char ch[MAX];

void swap(int *a,int *b){
    *a^=*b;
    *b^=*a;
    *a^=*b;
}

void build(int rt,int st,int ed){
    segtree[rt].lazy=0;
    if(st==ed){
        if(ch[st-1]=='1'){
            segtree[rt].zero=0;
            segtree[rt].one=1;
        }
        else{
            segtree[rt].zero=1;
            segtree[rt].one=0;
        }
        return;
    }
    int mid=(st+ed)>>1;
    build(rt<<1,st,mid);
    build(rt<<1|1,mid+1,ed);
    segtree[rt].zero=segtree[rt<<1].zero+segtree[rt<<1|1].zero;
    segtree[rt].one=segtree[rt<<1].one+segtree[rt<<1|1].one;
}

void push(int rt){
    if(segtree[rt].lazy){
        segtree[rt<<1].lazy^=1;
        segtree[rt<<1|1].lazy^=1;
        swap(&segtree[rt<<1].zero,&segtree[rt<<1].one);
        swap(&segtree[rt<<1|1].zero,&segtree[rt<<1|1].one);
        segtree[rt].lazy=0;
    }
}

int query(int rt,int nst,int ned,int qst,int qed){
    if(qst>ned||qed<nst)return 0;
    if(qst<=nst&&qed>=ned)return segtree[rt].one;
    int mid=(nst+ned)>>1;
    push(rt);
    return query(rt<<1,nst,mid,qst,qed)+query(rt<<1|1,mid+1,ned,qst,qed);
}

void update(int rt,int nst,int ned,int ust,int ued){
    if(ust>ned||ued<nst)return;
    if(ust<=nst&&ued>=ned){
        segtree[rt].lazy^=1;
        swap(&segtree[rt].one,&segtree[rt].zero);
        return;
    }
    int mid=(nst+ned)>>1;
    push(rt);
    update(rt<<1,nst,mid,ust,ued);
    update(rt<<1|1,mid+1,ned,ust,ued);
    segtree[rt].zero=segtree[rt<<1].zero+segtree[rt<<1|1].zero;
    segtree[rt].one=segtree[rt<<1].one+segtree[rt<<1|1].one;
}

int main(){
    int n,m,i,type,x,y;
    scanf("%d%d",&n,&m);
    scanf("%s",ch);
    
    build(1,1,n);
    
    for(i=1;i<=m;i++){
        scanf("%d%d%d",&type,&x,&y);
        if(type){
            printf("%d\n",query(1,1,n,x,y));
        }
        else{
            update(1,1,n,x,y);
        }
    }
    return 0;
}
```

---

## 作者：秋日私语 (赞：0)

更好的阅读体验点[这里](https://blog.csdn.net/A_Comme_Amour/article/details/79681126)
题目
-

[传送门](https://www.luogu.org/problemnew/show/P2574)

题解
-

比线段树2还要简单；异或的操作

代码
-

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn=1000000;
const int inf=1e9;

int n,m,a[maxn],sum[maxn],tag[maxn];
bool leaves[maxn];
char ch[maxn];

void pushup(int rt)
{
	sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
void pushdown(int rt,int tot)//tot子树的节点的数量 
{
	if (tag[rt])
	{
		tag[rt<<1]^=tag[rt];
		tag[rt<<1|1]^=tag[rt];
		sum[rt<<1]=(tot-(tot>>1))-sum[rt<<1];//异或的运算 
		sum[rt<<1|1]=(tot>>1)-sum[rt<<1|1];
		tag[rt]=0;
	}
}

void build_tree(int rt,int l,int r)
{
	if (l==r)
	{
		sum[rt]=a[l]; return;
	}
	int mid=(l+r)>>1;
	build_tree(rt<<1,l,mid);
	build_tree(rt<<1|1,mid+1,r);
	pushup(rt);
}

void change(int rt,int l,int r,int L,int R)
{
	if (L<=l && r<=R)
	{
		tag[rt]^=1;
		sum[rt]=r-l+1-sum[rt];
		return;
	}
	pushdown(rt,r-l+1);
	int mid=(l+r)>>1;
	if (L<=mid) change(rt<<1,l,mid,L,R);
	if (R>mid) change(rt<<1|1,mid+1,r,L,R);
	pushup(rt);
}

int ques(int rt,int l,int r,int L,int R)
{
	if (L<=l && r<=R) return sum[rt];
	pushdown(rt,r-l+1);
	int mid=(l+r)>>1; int ans=0;
	if (L<=mid) ans+=ques(rt<<1,l,mid,L,R);
	if (R>mid) ans+=ques(rt<<1|1,mid+1,r,L,R);
	return ans;
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",ch+1);
	for (int i=1; i<=n; i++) a[i]=ch[i]-'0';
	build_tree(1,1,n);
	for (int i=1; i<=m; i++)
	{
		int opt,x,y; scanf("%d%d%d",&opt,&x,&y);
		if (!opt) change(1,1,n,x,y);
		else printf("%d\n",ques(1,1,n,x,y));
	}
	return 0;
}
```

总结
-
今天上午做了两道水题，都没有1A
我自己写错的地方在于tot数组搞得出了问题，异或在区间里就是总数减去sum值

---

## 作者：Adove (赞：0)

这道题好像没有标记永久化的题解

标记永久化之后就可以免去pushdown了，只需对途径标记的影响进行处理即可。理论上标记永久化会比标记下传快，但标记永久化的局限在于只能维护不会互相影响的标记，因为它无法处理标记的先后顺序。

只有一种标记的情况下尽量写标记永久化吧，可以避免被卡常。

参考代码如下↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int n,m,p,l,r;
bool a[1<<18],tag[1<<19];
int num[1<<19];

void build(int k,int l,int r){
	if(l==r){
		num[k]=a[l];
		return;
	}int i=k<<1,mid=(l+r)>>1;
	build(i,l,mid);
	build(i|1,mid+1,r);
	num[k]=num[i]+num[i|1];
}

void chg(int k,int l,int r,int le,int ri){
	if(le<=l&&r<=ri){
		tag[k]^=1;
		num[k]=(r-l+1)-num[k];
		return;
	}int i=k<<1,mid=(l+r)>>1;
	if(le<=mid) chg(i,l,mid,le,ri);
	if(mid<ri) chg(i|1,mid+1,r,le,ri);
	num[k]=num[i]+num[i|1];
	if(tag[k]) num[k]=r-l+1-num[k];
}

int ask(bool x,int k,int l,int r,int le,int ri){
	if(le<=l&&r<=ri){
		if(x) return r-l+1-num[k];
		return num[k];
	}int i=k<<1,mid=(l+r)>>1;
	int sum=0;
	if(le<=mid) sum+=ask(x^tag[k],i,l,mid,le,ri);
	if(mid<ri) sum+=ask(x^tag[k],i|1,mid+1,r,le,ri);
	return sum; 
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%1d",&a[i]);
	}build(1,1,n);
	while(m--){
		scanf("%d%d%d",&p,&l,&r);
		if(p==0){
			chg(1,1,n,l,r);
		}else{
			printf("%d\n",ask(0,1,1,n,l,r));
		}
	}return 0;
}
```

---

## 作者：white945 (赞：0)

这差不多是线段树的模板，只不过懒标签有一点改变

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int N=200010;

struct tree{
    int l,r,sum,n;
    bool lazy;
} t[4*N];

int n,m;
int A[N];

void build(int x,int l,int r){
    t[x].l=l; t[x].r=r;
    t[x].n=r-l+1;
    if(t[x].n==1){
        t[x].sum=A[l];
        return;
    }
    int mid=(l+r)>>1;
    build(x*2,l,mid);
    build(x*2+1,mid+1,r);
    t[x].sum=t[x*2].sum+t[x*2+1].sum;
    return;
}

void change(int x,int l,int r){
    if(t[x].l==l&&t[x].r==r){
        t[x].lazy=!t[x].lazy;
        t[x].sum=t[x].n-t[x].sum;
        return;
    }
    if(t[x].lazy){
        t[x].lazy=false;
        t[x*2].lazy=!t[x*2].lazy;
        t[x*2+1].lazy=!t[x*2+1].lazy;
        t[x*2].sum=t[x*2].n-t[x*2].sum;
        t[x*2+1].sum=t[x*2+1].n-t[x*2+1].sum;
    }
    int mid=(t[x].l+t[x].r)>>1;
    if(r<=mid) change(x*2,l,r);
    else if(mid<l) change(x*2+1,l,r);
    else{ change(x*2,l,mid); change(x*2+1,mid+1,r); }
    t[x].sum=t[x*2].sum+t[x*2+1].sum;
    return;
}

int query(int x,int l,int r){
    if(t[x].l==l&&t[x].r==r) return t[x].sum;
    if(t[x].lazy){
        t[x].lazy=false;
        t[x*2].lazy=!t[x*2].lazy;
        t[x*2+1].lazy=!t[x*2+1].lazy;
        t[x*2].sum=t[x*2].n-t[x*2].sum;
        t[x*2+1].sum=t[x*2+1].n-t[x*2+1].sum;
    }
    int ans;
    int mid=(t[x].l+t[x].r)>>1;
    if (r<=mid) ans=query(2*x,l,r);
    else if (mid<l) ans=query(2*x+1,l,r);
    else ans=(query(2*x,l,mid)+query(2*x+1,mid+1,r));
    if(t[x].lazy) ans=(r-l+1)-ans;
    return ans;
}

int main(){
    //freopen("art.in","r",stdin);
    //freopen("art.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int a=1;a<=n;++a) scanf("%1d",&A[a]);
    build(1,1,n);
    int opt,l,r;
    for(int a=1;a<=m;++a){
        scanf("%d%d%d",&opt,&l,&r);
        if(!opt) change(1,l,r);
        else printf("%d\n",query(1,l,r));
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}
```

---

## 作者：ICEMAGE (赞：0)

直接用线段树维护一下区间，向下传递标记，修改先祖节点的值就好了。

pas代码如下：



var fz:array[1..1050000]of boolean;  //布尔数组便于直接判断翻转







```cpp
    a:array[1..1050000]of longint;   //四倍空间
    i,j,n,m,f,o,d,x:longint;
    s:ansistring;
procedure build(l,r,k:longint);         //建树
var mid:longint;
begin
  if l=r then exit;
  mid:=(l+r)>>1;
  build(l,mid,2*k);
  build(mid+1,r,2*k+1);
  a[k]:=a[2*k]+a[2*k+1];
end;
procedure down(l,r,k:longint);       //传递标记
begin
  if fz[k] then
  begin
    fz[k]:=false; a[k]:=(r-l+1)-a[k];
    fz[2*k]:=not fz[2*k];                 //两次翻转可以视为不翻转
    fz[2*k+1]:=not fz[2*k+1];
  end;
end;
procedure try(l,r,k:longint);            //修改节点的值
var mid:longint;
begin
  down(l,r,k);
  if (o<=l)and(r<=d) then
  begin
    fz[k]:=not fz[k];                         
    down(l,r,k); exit;
  end;
  mid:=(l+r)>>1;
  if o<=mid then try(l,mid,2*k)
   else down(l,mid,2*k);
  if mid+1<=d then try(mid+1,r,2*k+1)
   else down(mid+1,r,2*k+1);
  a[k]:=a[2*k]+a[2*k+1];
end;
procedure pd(l,r,k:longint);         //判断节点的值
var mid:longint;
begin
  down(l,r,k);
  if (o<=l)and(r<=d) then
   begin inc(x,a[k]); exit; end;           //找到就直接累计
  mid:=(l+r)>>1;
  if o<=mid then pd(l,mid,2*k);
  if mid+1<=d then pd(mid+1,r,2*k+1);
end;
begin
  readln(n,m); j:=1;
  for i:=1 to 1000 do
    if j>=n then break
     else inc(j,j);
  readln(s);
  for i:=1 to n do   
    a[j-1+i]:=ord(s[i])-ord('0');   //要用字符串判断一下读入
  build(1,j,1);
  for i:=1 to m do
  begin
    readln(f,o,d);
    if f=0 then try(1,j,1)
     else begin
       x:=0; pd(1,j,1);
       writeln(x);
     end;
  end;
end.
```

---


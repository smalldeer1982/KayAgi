# [JLOI2014] 松鼠的新家

## 题目描述

松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$ 个房间，并且有 $n-1$ 根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在“树”上。

松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去 $a_1$，再去 $a_2$，……，最后到 $a_n$，去参观新家。可是这样会导致重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。

维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。

因为松鼠参观指南上的最后一个房间 $a_n$ 是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。

## 说明/提示

对于全部的数据，$2 \le n \le 3 \times 10^5$，$1 \le a_i \le n$。

## 样例 #1

### 输入

```
5
1 4 5 3 2
1 2
2 4
2 3
4 5```

### 输出

```
1
2
1
2
1```

# 题解

## 作者：dzz1537568241 (赞：397)

# 树上差分

本题解有：

1. **差分**的**思想原理** + 做 **差分** 题的**小技巧**

1. **树上差分**

要看懂这篇题解  ....   你必须熟练掌握 ：

1.  **LCA**

1.  **差分**

- LCA的题目可以做：

	[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.org/problem/P3379)

	[P1351联合权值](https://www.luogu.org/problem/P1351)

- 至于**差分，他实在是太重要**了，我相信各位都掌握了，~~如果你不会我建议打回普及组重造~~

------------

# 一：差分的思想原理

先来大致分析一下我们本题要干什么

1. 找到**两个节点的最近公共祖先**

1. 处于**到最近公共祖先的路径上的所有节点 均 + 1**

考虑到**本题的数据量**，遍历最近公共祖先的路径，然后逐个加 1，显然不可能

与区间加值有关系的：

- 线段树

- 差分

- 树状数组

**线段树** 和 **树状数组**用于数轴上的处理比较多，而树上的路径是**无法表示成一个个区间**

这里**差分的优点**就非常明显了：

- 算法复杂度超低

- 适用于**一切 连续的 “线段”**

这里所谓的线段可以是一段连续的区间，也可以是**路径**

唯一的问题是**怎么差分**？

我们先暂时**抛开这道题目**，想象一下出一条链表...

![](https://cdn.luogu.com.cn/upload/image_hosting/jkm5lbts.png)

把**1 -> 5这条路径上的值全体加1**

现在来处理差分数组

![](https://cdn.luogu.com.cn/upload/image_hosting/frepwnug.png)

可以很清楚的看到，1号节点的值被增加1，在 6号节点的值被减去1

正确性很好说明：差分数组的的定义：a[ i ] = a[ i - 1 ] + 差分数组[ i ],

由于区间[1, 5]区间内，**两个数之间的相对大小**不会改变，改变的只是**a[1]相对于a[0]的大小**和**a[5]相对于a[6]的大小**，因此只需把a[1] + 1，a[6] - 1即可；


可以总结出**差分的思想方法**：

如果有一个区间内的权值发生相同的改变的时候，我们可以采用差分的思想方法

而**差分的思想方法在于不直接改变区间内的值**，而是改变区间[ L , r ] 对于 区间 [ 0, L - 1 ] & 区间[ r + 1, R]的 **相对大小**关系

**总结出一点：**

#### 差分就是相对改变 ！

### 差分就是相对改变！！

## 差分就是相对改变！！！

只要我们能找出区间和区间之间**相对改变的关系**，一切均能被**差分**轻松的解决

另注：~~（防止接下来有人会看的云里雾里的）~~

**接下来所有“子节点”指“ 直系子节点”！！！！**

![直系儿子](https://cdn.luogu.com.cn/upload/image_hosting/flcy23s2.png)

**直系子节点**指的是和父节点有一条边**直接相连**的子节点


# 二：**树上差分**
![](https://cdn.luogu.com.cn/upload/image_hosting/vp8bn2i6.png)

类比刚才的差分，

如果把s -> t的**路径上**的所有**节点的权值**都加上 w，

我们假定一个父节点u = **其所有的子节点** + **他本身的差分数组**

写出伪代码：

```cpp
//chafen[ maxn ]：差分数组，定义 当前节点 与其子树的总和之差 
//num[ maxn ]: 当前节点的权值 

int chafen[maxn], a[maxn];

num[u] += chafen[u];//加上差分数组 

//加上子树的总和 
for(遍历与 u 相连的每一个子节点 v){
	num[u] += num[v]; 
} 

```

我们要处理的**相对改变**有以下几种可能：

1. **s -> t路径上的点**与**他们的子节点** 的相对改变

1. **s 与 s父节点** 的相对改变

1. **t 与 t子节点** 的相对改变


- 来看 **s -> t 路径上的点（不包括 t）** 和**他们的子节点的总和** 的相对改变

有改变吗？

A) 当然是有的

B) 和 **自己子节点的和** 发生相对改变...？嗯和 **单个子节点** 确实是有相对改变，但是和他的子节点的和应该是没有吧。

如果你选 A）你可以看一眼 B）
 
如果你选 B）那恭喜你选对了。

**差分数组**存储**该节点相对于其子节点的总和**发生的相对改变，在**s->t路径上所有点的子节点** 均和 **他们自己发生了同样的改变**，因此**相对改变为0**

- 再来看 **t** 和 **t 子节点总和** 的相对改变

显然是有的，大小也很好看出，t 比 其子节点总和高出了w, 因此在处理差分的时候只需要把 **t 的差分数组值** + w 即可

- 最后是 s 与 s父节点的相对改变

s的值增了 w， **s的父节点**相对于**其子树和** 小了s，只需要把 **s的父节点的差分数组值 - w**即可

这样把**s -> t路径上的值均加w**的**树上差分**的伪代码就能写出来了

```cpp
int chafen[maxn], a[maxn];

num[u] += chafen[u];//加上差分数组 

//把s->t路径上所有点均加w,
chafen[t] += w;
chafen[s的父节点] -= w; 

//差分数组处理 
//加上子树的总和 
for(遍历与 u 相连的每一个子节点 v){
	num[u] += num[v]; 
}  
```
~~（其实和普通的差分并没有什么区别）~~

# 三：lca上的差分
![](https://cdn.luogu.com.cn/upload/image_hosting/9u7v9sfc.png)

如上图所示 ~~（我随便画的树）~~

lca的差分在原来的基础上稍微加了一丁点东西，我觉得不需要我仔细的讲，~~因为如果要是刚才的树上差分学会了lca上的差分还是不会你肯定没动脑子~~

假设 把4和5的lca路径上的点权值均 + 1

可以把这个问题**拆成两个问题**求解：

1. 4 -> 最近公共祖先 路径上的点+1

1. 5 -> 最近公共祖先 路径上的点+1

最后由于最近公共祖先被多加了一次，因此 lca(4,5)的差分数组应该 - 1，他的父亲节点的差分数组应该+ 1

给出所有的代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int maxn = 300050;
const int maxm = maxn << 1;
int N, M;
int a[maxn], t1, t2;
int head[maxn], cnt;

struct Edge{
	int u, v, next;
}edge[maxm];

inline void addedge(int u, int v){
	edge[++cnt].u = u;
	edge[cnt].v = v;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

int fa[maxn][31], dep[maxn];

void dfs(int u, int faa){
	fa[u][0] = faa, dep[u] = dep[faa] + 1;
	for(int i = 1; i <= 30; i++){
		fa[u][i] = fa[ fa[u][i - 1] ][i - 1];
	}
	for(int i = head[u]; i ; i = edge[i].next){
		int v = edge[i].v;
		if(v == faa)continue;
		dfs(v, u);
	}
} 

inline int lca(int x, int y){
	if(dep[x] < dep[y])swap(x,y);
	for(int i = 30; i >= 0; i--){
		if(dep[ fa[x][i] ] >= dep[y]) x = fa[x][i];
	}
	if(x == y)return x;
	for(int i = 30; i >= 0; i--){
		if(fa[x][i] != fa[y][i]){
			x = fa[x][i], y = fa[y][i];
		}
	}
	return fa[x][0];
}

int num[maxn];

int answer(int u, int faa){
	for(int i = head[u]; i ; i = edge[i].next){
		int v = edge[i].v;
		if(v == faa)continue;
		answer(v, u);
		num[u] += num[v];
	}
}
int main(){
	cin>>N;
	for(int i = 1; i <= N; i++){
		cin>> a[i];
	}
	for(int i = 1; i < N; i++){
		cin>> t1>> t2;
		addedge(t1, t2);
		addedge(t2, t1);
	}
	dfs(1, 0);
	for(int i = 1; i <= N - 1; i++){
		int u = a[i], v = a[i + 1];
		int t = lca(u, v);
		num[ fa[t][0] ]	-= 1;
		num[ t ] -= 1;
		num[ u ] += 1;
		num[ v ] += 1;
	}
	answer(1,0);
	for(int i = 2; i <= N; i++){
		num[a[i]]--;
	}
	for(int i = 1; i <= N; i++){
		cout<<num[i]<<endl;
	}
}
```
~~学农的时候还要写个题解求个赞应该不过分吧？~~

---

## 作者：asuldb (赞：63)

```cpp
//第一次A掉紫题就来写题解，我是不是疯了 
//说实话这道题还是比较裸的树上差分 
//对于树上的一条路径(s,t)，我们只需要把ch[s]++,ch[t]++,ch[LCA(S,T)]--,再把lca的爸爸减一 
//再dfs跑一遍就可以了 
//但这题还是有些不一样的，这道题里的路径终点会算作下一条路径的起点 
//解法与楼下的大佬们有些类似，但我可能写的比较好理解一些吧（其实只因为我太弱了） 
//还是上代码吧 
#include<iostream>
#include<cstring>
#include<fstream>
#include<cstdio>
using namespace std;
const int maxn=300001;
struct node
{
    int u,v;
    int nxt;
}edge[maxn*2];// 无向边，领接表开两倍 
int deep[maxn],ch[maxn],head[maxn],a[maxn];
int f[maxn][30];//倍增数组，f[i][j]表示i向上跳2^j到达的点 
int n,num=1;
inline void read(int &x)//读入优化 
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-48;
        c=getchar();
    }
}
void add_edge(int x,int y)//邻接表加边 
{
    edge[num].u=x;
    edge[num].v=y;
    edge[num].nxt=head[x];
    head[x]=num;
    num++;
}
void build(int r)//建树 
{
    for(int i=head[r];i!=-1;i=edge[i].nxt)
    {
        int xx=edge[i].v;
        if(deep[xx]==0)//如果点xx没有被访问过的话
        {
            deep[xx]=deep[r]+1;
            f[xx][0]=r;
            build(xx);//继续以xx为根建树 
        }
    }
}
void fill()
{
    for(int i=1;i<=29;i++)
    for(int j=1;j<=n;j++)
    f[j][i]=f[f[j][i-1]][i-1];//第j个节点，向上跳i能到达的节点先跳到2^(i-1)处再向上跳2^(i-1)能到达的节点
}
int lca(int x,int y)
{
    if(deep[x]<deep[y]) swap(x,y);//如果x在y上面，交换让x往上跳 
    for(int i=29;i>=0;i--)
    if(deep[f[x][i]]>=deep[y])
      x=f[x][i];//使x跳到与y同一深度 
    if(x==y) return x;
    for(int i=29;i>=0;i--)
    if(f[x][i]!=f[y][i])
    {
        x=f[x][i];
        y=f[y][i];
    }
    return f[x][0];//再跳一步，找到lca 
}
void dfs(int r)
{
    for(int i=head[r];i!=-1;i=edge[i].nxt)
    {
        int xx=edge[i].v;
        if(xx==f[r][0]) continue;
        dfs(xx);
        ch[r]+=ch[xx];//求子树和 
    }
}
inline void write(int x)//闲的没事干加的输出优化 
{
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++)
    {
        read(a[i]);
        head[i]=-1;
    }
    int xx,yy;
    for(int i=1;i<=n-1;i++)
    {
        read(xx);
        read(yy);
        add_edge(xx,yy);
        add_edge(yy,xx);
    }
    deep[1]=1;
    build(1);//以1为根建树 
    fill();
    for(int i=1;i<=n-1;i++)
    {
        xx=a[i];
        yy=a[i+1];
        ch[xx]++;
        ch[yy]++;
        ch[lca(xx,yy)]--;
        ch[f[lca(xx,yy)][0]]--;
    }
    dfs(1);
    for(int i=2;i<=n;i++)
        ch[a[i]]--;//因为我们把既作为起点又做为终点的点算了两次，现在把这些点的权值减一即可 
    for(int i=1;i<=n;i++)
    {
        write(ch[i]);
        putchar(char(10));//char(10)即换行 
    }
    return 0;
}
```

---

## 作者：hyfhaha (赞：36)

# 树链剖分板子题
## 先说点别的

**小熊维尼啊，嘿嘿嘿。**
### 写题经历

悲惨命运：树剖调了2天，一直90分，死活不AC，调出了心病，快下课时改了一下数据范围，A了……。（刚开始数组开了800100，改1200100过了）

所以说啊，线段树必须要注意数据范围，要开4倍，不然会想傻X作者一样调出心病。（太可怕了，数据范围小了，不RE，竟然WA，评测机太可怕了QAQ）

吐槽，树链剖分题怎么都比【模板】树链剖分 简单
### 前置技能

1、线段树 2、树链剖分 

如果你已经过了[P3384 【模板】树链剖分](https://www.luogu.org/problemnew/show/P3384)这道题。那么这道题就是附赠的紫题哈。

## 思路
我们知道树链剖分支持以下操作：

1、在树中将u到v节点数值全部加一个值。

2、查询树中u到v节点的数值和

那么我们可以想到把小熊维尼去每一个房间抽象成一个一个点，那么我们要从u房间去到v房间，则要在u到v之间都放一个糖果，于是我们将松鼠它家u到v的糖果数都加1。

看到这里，想到树剖写法了吧，每一次将a[i]到a[i+1] (a数组是访问顺序)的节点加1，这个可以用树链剖分做。

查询只需要查每个点的权值就OK了。

当然还有些细节，在处理完一次修改后，终点要减1，不然会重复计算。

## 代码
```cpp
//by:hyfhaha 
#include<bits/stdc++.h>
using namespace std;
const long long maxn=1200100;		//特以此纪念本人数据范围开小卡90分卡两天
int a[maxn],tree[maxn],tag[maxn],n,m,mode,x,y,z,S,cnt;
int large[maxn],seg[maxn],father[maxn],vis[maxn],dep[maxn],son[maxn],rev[maxn],top[maxn];
int Next[maxn],head[maxn],from[maxn],to[maxn],id[maxn],tot;
//********************以下线段树********************
void pushdown(int node,int begin,int end){
    if(tag[node]){
        int m=(begin+end)/2;
        tree[node*2]+=tag[node]*(m-begin+1);
        tree[node*2+1]+=tag[node]*(end-m);
        tag[node*2]+=tag[node];
        tag[node*2+1]+=tag[node];
        tag[node]=0;
    }
}
int query(int node,int begin,int end,int x,int y){
    if(x<=begin&&end<=y)
    return tree[node];
    else{
        int m=(begin+end)/2,res=0;
        pushdown(node,begin,end);
        if(x<=m)
            res+=query(node*2,begin,m,x,y);
        if(y>m)
            res+=query(node*2+1,m+1,end,x,y);
        return res;
    }
}
void update(int node,int begin,int end,int x,int y,int val){
    if(x<=begin&&end<=y){
        tree[node]+=val*(end-begin+1);
        tag[node]+=val;
    }
    else{
        int m=(begin+end)/2; 
        pushdown(node,begin,end);
        if(x<=m){
            update(node*2,begin,m,x,y,val);
        }
        if(y>m){
            update(node*2+1,m+1,end,x,y,val);					 
        }
        tree[node]=tree[node*2]+tree[node*2+1];
    }
}
//********************以上线段树********************
//********************以下树链剖分********************
void dfs1(int x,int f){
    large[x]=1;father[x]=f;
    dep[x]=dep[f]+1;
    int maxy=0;
    for(int i=head[x];i!=-1;i=Next[i]){
        int u=to[i],big=0;
        if(u==f)continue;
        dfs1(u,x);
        large[x]+=large[u];
        if(large[u]>maxy){son[x]=u;maxy=large[u];}
    }
}
void dfs2(int x,int f){
    top[x]=f;id[x]=++tot;
    if(!son[x]){
        return;
    }
    dfs2(son[x],f);
    for(int i=head[x];i!=-1;i=Next[i]){
        int u=to[i];
        if(u!=son[x]&&u!=father[x]){
            dfs2(u,u);
        }
    }
}
void updatelong(int x,int y,int z){
    while(top[x]!=top[y]){
        if(dep[top[x]]<=dep[top[y]]){
        	update(1,1,n,id[top[y]],id[y],z);
       	 	y=father[top[y]];
    	}else{
    		update(1,1,n,id[top[x]],id[x],z);
       	 	x=father[top[x]];
        }
    }
    if(dep[x]>dep[y])swap(x,y);
    update(1,1,n,id[x],id[y],z);
}
//********************以上树链剖分********************
void add(int x,int y){	//建边 
    cnt++;
    from[cnt]=x;to[cnt]=y;
    Next[cnt]=head[x];head[x]=cnt;
}
//********************以下主程序********************
int main(){
    scanf("%d",&n);S=1;
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n-1;i++){
        scanf("%d%d",&x,&y);
        add(x,y);add(y,x);
    }
    dfs1(S,0);dfs2(S,S);
    for(int i=1;i<=n-1;i++){
    	updatelong(a[i],a[i+1],1);
    	updatelong(a[i+1],a[i+1],-1);//记得终点减1
    }
    for(int i=1;i<=n;i++)
    printf("%d\n",query(1,1,n,id[i],id[i]));
}//光棍数字收场 
```


---

## 作者：Mosklia (赞：34)

## 一、思路解析  
给出一棵树，要求按顺序走完给定的所有点，每移动一步就要给这次移动经过的点增加$1$的点权。求每一个点的最小点权。  
显然这是一个树上差分的题目，因为树上两点之间**有且仅有**一条最短路。并且，只有每一步都走最短路，最终的答案才会是最优（树上两点间无论如何走，经过的边组成的边集一定包含最短路上的所有点）。  
所以，不难想到以下的解法：  
```cpp
void work(int u, int v) {
    求出u, v的LCA,
    同时将经过的每个点的点权+1;
}
for(int i = 1; i < n; ++i)
	work(a[i], a[i + 1]);
for(innt i = 1; i <= n; ++i)
	printf("%d\n", ans[i]);
```
可惜，这样的代码存在问题：
### 1、答案错误
在上面的算法中，我们将所有经过的点的点权$+1$，这样每次就重复计算了作为出发点和终到点的点的点权。比如说，对于下面的数据：  
![](https://raw.githubusercontent.com/Sparky-14145/items/master/pictures/松鼠的新家1.png)  
按照上面的算法，得到输出：  
```plain
2
1
0
```
可是，实际上正确的输出应该是：  
```plain
1
1
0
```
错误的原因便是上面说的重复计算。  
### 2、时间复杂度太高
如果整棵树退化成一条链，每一次从链的一段走到另一端，时间复杂度将是$O(n^2)$，对于本题而言太大了。  
### 3、解决方法
我们先来解决时间复杂度的问题。  
解决的方法是利用倍增$LCA+$树上差分，倍增$LCA$的求法详见[这篇文章](https://sparky-14145.github.io/2018/07/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/)。  
#### 树上差分：
我们可以使每个点为根的树保存这个点的权值。那么每次我们只需要求出两个端点的$LCA$即可。  
为了抵消其对$LCA$及其上方的点的影响，需要给$LCA$及其父节点的权值$-1$。  
最后需要一遍$DFS$还原所有点的点权，时间复杂度$O(n)$。  
倍增求$LCA$的时间复杂度是$O(log\;n)$，于是本题时间复杂度降为$O(n\; log\; n)$，本题可以接受。  
然后再来看错误答案的解决方法。  
仔细分析每一个点及其相邻的边，发现每个点被经过的方式，不外乎以下几种：  
![](https://raw.githubusercontent.com/Sparky-14145/items/master/pictures/松鼠的新家2.png)   
结合图片，更进一步思考，不难发现每条路上每一个点的经过次数为：$$\frac{1 + \sum_{i=1}^{n}cnt[i]}{2} \text{i是与这个点相连的边的编号，n是与这个点相连的边的数量}$$。   
并且，本题的题意便是统计一条路径上所有点的经过次数。于是，我们可以通过统计边的经过次数来达到统计点的经过次数的目的。  
这时，差分统计的对象由点变为边。这并没有带来任何困难，只要用每个点的子树的点权和表示这个点到父节点相连的边的经过次数，同时，差分时修改LCA的权值$-2$就可以了。  
## 二、代码实现
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
struct Path{
    int next, ends;
    int wei;
}ph[600020];
int pta[300010], fa[40][300010], d[300010], s[300010], e;
int cnt[300010];
bool vis[300010];
void dfs(int p, int dpt){  //倍增LCA的初始化
    vis[p] = true;
    d[p] = dpt;
    for(int i = pta[p]; i; i = ph[i].next){
        if(vis[ph[i].ends]) continue;
        fa[0][ph[i].ends] = p;
        dfs(ph[i].ends, dpt+1);
    }
}
void makep(int u, int v){ //建边
    ph[++e].ends = v;
    ph[e].next = pta[u];
    pta[u] = e;
    ph[++e].ends = u;
    ph[e].next = pta[v];
    pta[v] = e;
}
int lca(int x, int y){//求LCA
    if(d[x] < d[y]) swap(x, y);
    int dif = d[x] - d[y];
    for(int i = 30; i >= 0; --i)
        if(1<<i <= dif)
        dif -= 1<<i,
        x = fa[i][x];
    if(x == y) return x;
    for(int i = 30;i >= 0;--i)
        if(fa[i][x]!=fa[i][y])
        x=fa[i][x],y=fa[i][y];
    if(x == y) return x;
    else return fa[0][x];
}
int dfs_ans(int p){ //还原答案
    int ans = cnt[p]; //加上自身权值
    vis[p] = true;
    for(int i = pta[p]; i; i = ph[i].next){
        if(vis[ph[i].ends]) continue;
        ans += ph[i].wei = dfs_ans(ph[i].ends); //边i的权值为子树权值和
    }
    for(int i = pta[p]; i; i = ph[i].next){
        if(ph[i].ends == fa[0][p]) ph[i].wei = ans, i = 0;
        //找到指向父亲的边（因为一条无向边被存成2条有向边）
    }
    return ans;
}
int main(){
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i)
        scanf("%d", s+i);
    for(int i = 1; i < n; ++i){
        int a, b;
        scanf("%d %d", &a, &b);
        makep(a, b);
    }
    fa[0][s[1]] = s[1]; dfs(s[1], 1);
    for(int i = 1; 1<<i <= n; ++i) //倍增预处理第二步
    for(int j = 1; j <= n; ++j)
        fa[i][j] = fa[i-1][fa[i-1][j]];
    for(int i = 1; i < n; ++i) //处理每一步
        cnt[s[i]]++,cnt[s[i+1]]++,
        cnt[lca(s[i],s[i+1])] -= 2;
    memset(vis, 0, sizeof(vis));
    dfs_ans(s[1]);
    for(int i = 1; i <= n; ++i){
        int ans = 0;
        for(int j = pta[i]; j; j = ph[j].next)
            ans += ph[j].wei;
        if(i == s[n]) ans--;//结束时不需要再增加权值
        printf("%d\n", (ans+1)>>1);//向上取整
    }
    return 0;
}
```
## 三、总结  
	1、倍增求LCA是个很灵活的算法，要学会熟练编写、运用；
	2、也有直接统计点的经过次数，然后把作为起点的点权值-1的解法，读者可以自行尝试。

---

## 作者：Tofu (赞：20)

主要讲一讲
# 树上差分
顾名思义，树上差分就是在树上的差分（？？？）

学过树状数组（区间修改）的同学应该了解，差分具有很优秀的性质

已知原数组  a[i],设差分数组  b[i]=a[i]-a[i-1]

那么就有 a[i]=b[1]+b[2]+...+b[n]

修改也很方便，例如对于区间（p,q）同时加上x,相当于 b[p]+=n,b[q+1]-=n



------------
接下来就是把线性的差分移到树上，

同理，已知原数组a[i]表示每个点的点权，

我们设差分数组b[i]=a[i]-sum(a[j])(j为i的每个直接相连的儿子)；

不难发现，叶子节点的b[i]恰好为该点点权a[i],此外，对于任意一个节点K，

a[K]=以K为根节点的子树中所有b[i]之和。

如果我们要对树上的一条链(u,v)的点权进行修改(同时加上x)，只需要：
#### b[u]+=x;
#### b[v]+=x;
#### b[lca(u,v)]-=x;
#### b[fa[lca(u,v)]]-=x;
### 注意为了不影响到链外的其他点权，lca（u,v）的父节点需要修改，可以自己推一下。

这是点权的情况，如果是边权，只需要把一个点到父亲的边权赋给自己当作点权，

然后当作点权的情况做就好了，细节需要处理一下。

------------
在本题中，原数组初始都是0，所以我们只需要读入、处理，最后遍历整颗树，递


归求出a[i]就ok了

------------
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int h[300000+5],fa[300000+5][25];
int vis[300000+5],lg[300000+5],dep[300000+5];
int a[300000+5],b[300000+5];//a为糖果数,b为差分数组
int m,n,i,j,x,y,tmp;
struct EDGE{
    int from,to,next;
};
EDGE e[600000+5];
void add(int a,int b){
    tmp++;
    e[tmp].from=a;
    e[tmp].to=b;
    e[tmp].next=h[a];
    h[a]=tmp;
}
void dfs1(int k){
    int s=h[k];
    while(s!=0){
        int t=e[s].to;
        if(t!=fa[k][0]){
            fa[t][0]=k;
            dep[t]=dep[k]+1;
            dfs1(t);
        } 
        s=e[s].next;
    }
}
int lca(int a,int b){
    if(dep[a]<dep[b]){
        int t=a;
        a=b;
        b=t;
    }
    while(dep[a]!=dep[b]){
        int k=lg[dep[a]-dep[b]]-1;
        a=fa[a][k];
    }
    if(a==b) return a;
    else{
        for(j=lg[dep[a]]-1;j>=0;j--){
            if(fa[a][j]!=fa[b][j]){
                a=fa[a][j];
                b=fa[b][j];
            }
        }
    }
    return fa[a][0];
}
void dfs2(int k){
    int s=h[k];
    while(s!=0){
        int t=e[s].to;
        if(t!=fa[k][0]){
            dfs2(t);
            b[k]+=b[t];
        }
        s=e[s].next;
    }
}
int main(){
    cin>>n;
    for(i=1;i<=n;i++)
        scanf("%d",&vis[i]); 
    for(i=1;i<=n-1;i++){
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    dfs1(1);
    for(j=1;j<=20;j++)
        for(i=1;i<=n;i++)
            fa[i][j]=fa[fa[i][j-1]][j-1];
    for(i=1;i<=n;i++)
        lg[i]=lg[i-1]+(1<<lg[i-1]==i);
    a[vis[1]]++;
    for(i=2;i<=n;i++){
    	int now=lca(vis[i],vis[i-1]);
    	b[vis[i]]++;
    	b[vis[i-1]]++;
    	b[now]--;
    	b[fa[now][0]]--;
    	a[vis[i-1]]--;//链首糖果数直接减1
    }
    a[vis[n]]--;
    dfs2(1);
    for(i=1;i<=n;i++)
        cout<<a[i]+b[i]<<endl;
    return 0;
}
```
明天生日写篇题解开心一下

---

## 作者：GK0328 (赞：9)

刚学完树剖，准备来刷模板题。。。

第一次看到题目，觉得这就是裸的树剖，但一看题解，LCA+树上差分……

瞄一眼数据范围，感觉有点慌。。。

但蒟蒻还是打了一波，结果过了？？？

讲一讲解法：

我们可以看成n-1次赋值，每次赋值都是从a[i]->a[i+1]全部加1，然后输出每一个点的权值。

注意：a[2]……a[n]这些点就多算一次，需要减1。

注释写在代码里吧。。。

Pascal Code：

```cpp
// luogu-judger-enable-o2//O2。。。
var
  tree,lazy:array[0..2000005]of longint;
  head,next,d:array[0..800005]of longint;
  id,top,size,f,deep,son,a:array[0..400005]of longint;
  n,i,x,y,num,cnt:longint;
procedure add(x,y:longint);//链式前向星
begin
  inc(num);
  d[num]:=y;
  next[num]:=head[x];
  head[x]:=num;
end;
procedure swap(var x,y:longint);//pascal 呜呜呜~
var
  t:longint;
begin
  t:=x;
  x:=y;
  y:=t;
end;
procedure dfs1(u,fa:longint);//dfs1求出每一个点的子树大小、深度、重儿子和父亲
var
  v,ll,sum:longint;
begin
  size[u]:=1;//size记录子树大小
  sum:=-1;
  ll:=head[u];
  while ll<>0 do
  begin
    v:=d[ll];
    if v<>fa then
    begin
      deep[v]:=deep[u]+1;//深度
      dfs1(v,u);
      size[u]:=size[u]+size[v];//子树大小
      f[v]:=u;//父亲
      if size[v]>sum then//更新重儿子
      begin
        sum:=size[v];
        son[u]:=v;
      end;
    end;
    ll:=next[ll];
  end;
end;
procedure dfs2(u,topl:longint);//dfs2记录重链顶和id
var
  v,ll:longint;
begin
  inc(cnt);
  id[u]:=cnt;
  top[u]:=topl;
  if son[u]=0 then
    exit;
  dfs2(son[u],topl);
  ll:=head[u];
  while ll<>0 do
  begin
    v:=d[ll];
    if (v<>f[u]) and (v<>son[u]) then
      dfs2(v,v);
    ll:=next[ll];
  end;
end;
//--------以下为线段树--------
procedure down(p,l,r:longint);//标记下传
begin
  if l=r then
  begin
    tree[p]:=tree[p]+lazy[p];
    lazy[p]:=0;
    exit;
  end;
  lazy[p+p]:=lazy[p+p]+lazy[p];
  lazy[p+p+1]:=lazy[p+p+1]+lazy[p];
  tree[p]:=tree[p]+(r-l+1)*lazy[p];
  lazy[p]:=0;
end;
procedure update(p,l,r:longint);//标记更新
var
  mid:longint;
begin
  if l=r then
    exit;
  mid:=(l+r) div 2;
  down(p+p,l,mid);
  down(p+p+1,mid+1,r);
  tree[p]:=tree[p+p]+tree[p+p+1];
end;
procedure change(p,l,r,x,y:longint);//将[x,y]都增加1
var
  mid:longint;
begin
  down(p,l,r);
  if (l=x) and (r=y) then
  begin
    inc(lazy[p]);
    exit;
  end;
  mid:=(l+r) div 2;
  if y<=mid then
    change(p+p,l,mid,x,y) else
  if x>mid then
    change(p+p+1,mid+1,r,x,y) else
    begin
      change(p+p,l,mid,x,mid);
      change(p+p+1,mid+1,r,mid+1,y);
    end;
  update(p,l,r);
end;
function calc(p,l,r,x:longint):longint;//计算x节点的值
var
  mid:longint;
begin
  down(p,l,r);
  if l=r then
    exit(tree[p]);
  mid:=(l+r) div 2;
  if x<=mid then
    exit(calc(p+p,l,mid,x)) else
    exit(calc(p+p+1,mid+1,r,x));
  update(p,l,r);
end;
//--------以上为线段树--------
//--------以下为树链剖分--------
procedure ChangeRange(x,y:longint);//将x->y的路径+1
begin
  while top[x]<>top[y] do//当x，y在同一条链上停止
  begin
    if deep[top[x]]<deep[top[y]] then
      swap(x,y);
    change(1,1,n,id[top[x]],id[x]);
    x:=f[top[x]];
  end;
  if deep[x]>deep[y] then
    swap(x,y);
  change(1,1,n,id[x],id[y]);
end;
function GetRange(x:longint):longint;
var
  ans:longint;
begin
  ans:=calc(1,1,n,id[x]);//注意是id[x]而不是x
  exit(ans);
end;
//--------以上为树链剖分--------
begin
  readln(n);
  for i:=1 to n do
    read(a[i]);
  readln;
  for i:=1 to n-1 do
  begin
    readln(x,y);
    add(x,y);
    add(y,x);
  end;
  dfs1(1,0);
  dfs2(1,1);
  for i:=1 to n-1 do
    ChangeRange(a[i],a[i+1]);
  for i:=1 to n do
  begin
    if i=a[1] then//特判
      writeln(GetRange(i)) else
      writeln(GetRange(i)-1);
  end;
end.
```

结束了吧。。。

---

## 作者：BeyondHeaven (赞：7)

看到前面$dalao$都是$Lca$+差分或者树剖+线段树，来一发树剖+差分的题解$qwq$  

因为本题只需要查询$1$次，但要修改$n$次，所以树剖$O(nlog^2n)$容易爆，采用差分序列代替线段树来维护树剖。  

在维护序列$a[i]$时，差分序列$d[i]$存放的是$a[i]-a[i-1]$的值，与前缀和互为逆运算(口胡)（逃

差分序列的前缀和$SumD[i]$的值就是原序列$a[i]$  
差分序列可以支持$O(1)$区间修改与$O(n)$查询(统计一遍前缀和) 

于是我们用树剖将树剖分成序列，然后用差分维护区间修改，最后统计一遍前缀和就可以得到每个点的答案了。

然后就是注意从$a[2]$到$a[n-1]$每个点结束被计算了$1$次，出发被计算了$1$次，但是答案只算$1$次，需要$-1$。另外，题目描述说$a[n]$结束时不计入答案，还要单独$-1$。

```
#include<cstdio>
#define MaxN 300123
int n;
int a[MaxN],fa[MaxN],son[MaxN],size[MaxN],dep[MaxN],top[MaxN],seg[MaxN],rev[MaxN];
int d[MaxN],sum[MaxN],seg_cnt;
//d为差分数组，sum为用来统计前缀和的数组
struct Edge{int v,next;}edge[MaxN<<1];
int head[MaxN],num_edge;
template<typename T>
inline void read(T&x)
{
	x=0;int ch=getchar();
	while(ch<48||ch>57)ch=getchar();
	while(ch>47&&ch<58)x=10*x+ch-48,ch=getchar();
}
template<typename T>inline void swap(T&a,T&b){a^=b^=a^=b;}
inline void add_edge(int u,int v)
{
	edge[++num_edge].v=v;
	edge[num_edge].next=head[u];
	head[u]=num_edge;
}
inline void Init()
{
	read(n);
	for(int i=1;i<=n;++i)
	read(a[i]);
	for(int i=1,u,v;i<n;++i)
	{
		read(u);read(v);
		add_edge(u,v);
		add_edge(v,u);
	}
	top[1]=1;
}
inline void Dfs1(int u=1,int f=0)
{
	fa[u]=f;size[u]=1;dep[u]=dep[f]+1;
	for(int i=head[u];i;i=edge[i].next)
	{
		if(edge[i].v==f)continue;
		Dfs1(edge[i].v,u);
		size[u]+=size[edge[i].v];
		if(size[edge[i].v]>size[son[u]])
		son[u]=edge[i].v;
	}
}
inline void Dfs2(int u=1)
{
	seg[u]=++seg_cnt;
	rev[seg_cnt]=u;
	if(son[u])
	{
		top[son[u]]=top[u];
		Dfs2(son[u]);
	}
	for(int i=head[u];i;i=edge[i].next)
	{
		if(!top[edge[i].v])
		{
			top[edge[i].v]=edge[i].v;
			Dfs2(edge[i].v);
		}
	}
}
#define modify(l,r) ++d[(l)],--d[(r)+1]
inline void Modify(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])
		swap(u,v);
		modify(seg[top[u]],seg[u]);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	modify(seg[u],seg[v]);
}
inline void Print()
{
	for(int i=1;i<=n;++i)
	sum[i]=sum[i-1]+d[i];
	++sum[seg[a[1]]];
   //输出的时候给每个数-1，但是a[1]没有多计入，就补上
   //本来啊a[n]也应该补的，但是a[n]最后要-1，就抵消了
	for(int i=1;i<=n;++i)
	printf("%d\n",sum[seg[i]]-1);
   //此处给每个数减了1
}
inline void Work()
{
	for(int i=1;i<n;++i)
	Modify(a[i],a[i+1]);
}
int main()
{
	Init();
	Dfs1();
	Dfs2();
	Work();
	Print();
	return 0;
}
```

说实话感觉恶意评分$qwq$

---

## 作者：Drifterming (赞：6)

```
//记录从哪一个房间出发，update(出发点，终点,add)
//因为从房间出发的时候不需要糖果，到达的时候才需要糖果
//所以update的时候会在出发点多放一块糖果
//那我们就update(s,s,-1),把多放的那块减去
//第一个房间是起点，提前在for循环外边放上一块糖。 
//last记录起点是谁
//这样，在每次update之前都先把last上的糖--，然后update（区间）
//最后让终点的糖--，因为题目中说最后一个点是餐厅，不用放糖 

#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=3e5+5;

int n;
int a[N];
int head[N],num_edge;
struct Edge
{
	int v,nxt;
}edge[N<<1];
struct NODE
{
	int fa,son;
	int top,dep;
	int s,t;
	int size;
}node[N];
struct TREE
{
	TREE *lson,*rson;
	int l,r,mid,len;
	int sum,add;
}tree[N<<2];

typedef TREE* Tree;
Tree now_node=tree,Root;

inline int read()
{
	char c=getchar();int num=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num;
}

inline void add_edge(int u,int v)
{
	edge[++num_edge].v=v;
	edge[num_edge].nxt=head[u];
	head[u]=num_edge;
}

void dfs1(int u)
{
	node[u].size=1;
	for(int i=head[u],v;i;i=edge[i].nxt)
	{
		v=edge[i].v;
		if(v==node[u].fa)
			continue;
		node[v].fa=u;
		node[v].dep=node[u].dep+1;
		dfs1(v);
		node[u].size+=node[v].size;
		if(node[v].size>node[node[u].son].size)
			node[u].son=v;
	}
}

int bound;
void dfs2(int u,int top)
{
	node[u].top=top;
	node[u].s=++bound;
	if(node[u].son)
	{
		dfs2(node[u].son,top);
		for(int i=head[u],v;i;i=edge[i].nxt)
		{
			v=edge[i].v;
			if(v==node[u].son||v==node[u].fa)
				continue;
			dfs2(v,v);
		}
	}
	node[u].t=bound;
}

void build(Tree &root,int l,int r)
{
	root=++now_node;
	root->l=l,root->r=r,root->mid=l+r>>1;
	root->len=r-l+1;
	if(l==r)
		return;
	build(root->lson,l,root->mid);
	build(root->rson,root->mid+1,r);
}

inline void pushdown(Tree root)
{
	if(root->add)
	{
		root->lson->add+=root->add;
		root->rson->add+=root->add;
		root->lson->sum+=root->add*root->lson->len;
		root->rson->sum+=root->add*root->rson->len;
		root->add=0;
	}
}

void update(const Tree &root,int l,int r,int add)
{
	if(root->l==l&&root->r==r)
	{
		root->sum+=root->len*add;
		root->add+=add;
		return;
	}
	pushdown(root);
	if(r<=root->mid)
		update(root->lson,l,r,add);
	else if(l>root->mid)
		update(root->rson,l,r,add);
	else
	{
		update(root->lson,l,root->mid,add);
		update(root->rson,root->mid+1,r,add);
	}
//	root->sum=root->lson->sum+=root->rson->sum;		不用pushup 
}

int query(const Tree &root,int pos)
{
	if(root->l==root->r)
		return root->sum;
	pushdown(root);
	if(pos<=root->mid)
		return query(root->lson,pos);
	else
		return query(root->rson,pos);
}

inline void Modify(int x,int y)
{
	int fx=node[x].top,fy=node[y].top;
	while(fx!=fy)
	{
		if(node[fx].dep>node[fy].dep)
		{
			update(Root,node[fx].s,node[x].s,1);
			x=node[fx].fa;
			fx=node[x].top;
		}
		else
		{
			update(Root,node[fy].s,node[y].s,1);
			y=node[fy].fa;
			fy=node[y].top;
		}
	}
	if(node[x].dep>node[y].dep)
		update(Root,node[y].s,node[x].s,1);
	else
		update(Root,node[x].s,node[y].s,1);
}


int main()
{
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	for(int i=1,u,v;i<n;++i)
	{
		u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs1(1);
	dfs2(1,1);
	build(Root,1,n);
	int last=a[1];
	update(Root,node[last].s,node[last].s,1);	//起点放糖 
	for(int i=2;i<=n;++i)
	{
		update(Root,node[last].s,node[last].s,-1);	//让起点的糖-- 
		Modify(last,a[i]);
		last=a[i];
	}
	update(Root,node[last].s,node[last].s,-1);		//终点的糖-- 
	for(int i=1;i<=n;++i)	//查询每个房间要放多少糖 
		printf("%d\n",query(Root,node[i].s));
	return 0;
}
```

---

## 作者：ww3113306 (赞：5)

翻了第一版，竟然没人写又好写又快的tarjan（也有可能是我太蒟蒻了看不懂大佬的tarjan）
不过每次写tarjan都会因为前向星没开双倍各自wa，，，
一开始竟然想分情况讨论来差分，，，然后发现各自情况要分析，
就是为了解决中间节点重复计算的问题，，，
结果，，，
最后一想，中间重复计算了一次，那我最后减掉不就好了么，，，
那这就是一道差分裸体了（这是唯一不同的地方）
	#include<bits/stdc++.h>
	using namespace std;
	#define R register int
	#define AC 300100
	#define D printf("line in %d\n",__LINE__);
	int n,cnt;//cnt是计LCA的
	int date[AC*2],Next[AC*2],Head[AC],tot=1;//存图
	int qdate[AC*2],qNext[AC*2],qHead[AC],qtot=1;//存询问
	int LCA[AC],ans[AC*2];//直接按顺序求，所以线性顺序即可
	int father[AC],t[AC],power[AC],fa[AC];
	bool vis[AC];
	//error!!!前向星因为是双向边，然后询问也是双向的，所以这些数组都要*2啊！！！
	inline int read()
	{
		int x=0;char c;
		while(isspace(c=getchar()));
		while(c>='0' && c<='9')x=x*10+c-'0',c=getchar();
		return x;
	}

	void add1(int f,int w)//加图
	{
		date[++tot]=w,Next[tot]=Head[f],Head[f]=tot;
		date[++tot]=f,Next[tot]=Head[w],Head[w]=tot;
	}
	
	int find(int x)
	{
		if(father[x]==x)	return x;
		else return father[x]=find(father[x]);
	}

	void add2(int f,int w)//加询问
	{
		qdate[++qtot]=w,qNext[qtot]=qHead[f],qHead[f]=qtot;
		qdate[++qtot]=f,qNext[qtot]=qHead[w],qHead[w]=qtot;
	}
	
	void DFS(int x)	
	{
		R now;
		vis[x]=true;
		for(R i=Head[x]; i ;i=Next[i])
		{
			now=date[i];
			if(!vis[now])
			{
				DFS(now);
				father[now]=x;//访问完所有的字节点后接上来
			}
			else fa[x]=now;//不然就是父亲，因为是点权，所以直接等于now就好了
		}
		for(R i=qHead[x]; i ;i=qNext[i])
		{
			now=qdate[i];
			if(vis[now] && !ans[i ^ 1])ans[i]=find(now);
		} 
	}
	
	void pre()
	{
		R a,b;
		n=read();
		for(R i=1;i<=n;i++)	t[i]=read();
		for(R i=1;i<n;i++)
		{
			a=read(),b=read();	
			add1(a,b);
		}
		for(R i=1;i<n;i++)//添加询问
			add2(t[i],t[i+1]);
		for(R i=1;i<=n;i++)father[i]=i;
		DFS(1);
		for(R i=1;i<=n*2+1;i++)
			if(ans[i])	LCA[++cnt]=ans[i];
	}

	void getans(int x)//统计答案,可以统计进入
	{
		R now;
		for(R i=Head[x]; i ;i=Next[i])
		{
			now=date[i];
			if(now!=fa[x])	
			{
				getans(now);
				power[x]+=power[now];
			}
		}
	}
	
	void work()
	{
		for(R i=1;i<n;i++)
		{
			power[t[i]]++,power[t[i+1]]++,power[LCA[i]]--,power[fa[LCA[i]]]--;//由于题目特殊性，不能每次都+1,因为进出房间只是一次
		}//但是这样并不好计算，那完全可以直接像平常一样统计啊，由于这样每个中间节点都会被重复计算一次，那输出的时候-1不就好了吗	
		getans(1);
		for(R i=2;i<=n;i++)//因为要按下标输出，但是重复计算的是序列中间的，所以是要序列中间都-1,所以先处理
			power[t[i]]--;
		for(R i=1;i<=n;i++)	printf("%d\n",power[i]);
	}

	int main()
	{
		freopen("in.in","r",stdin);
		pre();
		work();
		fclose(stdin);
		return 0;
	}

---

## 作者：zhz小蒟蒻 (赞：4)

### **这道题我大约调试了将近一个中午，结果发现是一个zz错误** 
我把 `top[son[u]]=top[u]` 写成了 `top[son[u]]=top[f]` ，~~完美爆零~~  


------------  
### 题目分析：  
根据我观察现有的题解，这道题有两种做法：  
1. $LCA$+树上差分（然而本蒟蒻太菜了，不会 $QAQ$）
2. 树链剖分（于是我只好打了一个树链剖分）  

那么，我们怎么来把它转换成树链剖分呢？  
我们还是先来手玩一下样例：（我定义的是 $1$ 为根节点）  
![](https://cdn.luogu.com.cn/upload/pic/69251.png)  
首先按照题目的要求，我们应该从 $1$ 走到 $4$ ，并且，贪吃的小熊维尼每走过一个房间，都要吃一块糖果，其实就相当于从 $1$ 到 $4$的路径上的每个点加个 $1$ ，于是，这道题就可以被我们转换成树链剖分的形式来求解了。  
但是，如果就这么做的话，我们会发现答案和样例不一样，为什么呢？因为除了最开始走的节点以外，其他的每一个点都被重复计算了一次，所以在统计答案的时候要减去 $1$  
$Code:$
```cpp
#include <iostream>
#include <cstdio>
#define N 300011
#define lc k<<1
#define rc k<<1|1 
using namespace std;
struct Node
{
	int t;
	int next;
}node[N<<1];
struct Tree
{
	int l;
	int r;
	int sum; //区间和
	int lazy;//懒标记
}tree[N<<2];
int n,tot,root;
int a[N];
int val[N],seg[N],rev[N],size[N],son[N],fa[N],head[N],dep[N],top[N];
//top[i]表示i节点所在的重链的顶端节点,son[i]表示i节点的重儿子，head是邻接表，dep[i]表示i节点的深度,fa[i]表示i节点的父亲,size[i]表示i号节点的子节点数,seg[i]表示i节点在线段树中对应的序号,reg[i]表示为序号i对应树中的节点
void add(int x,int y)
{
	node[++tot].t=y;	
	node[tot].next=head[x];
	head[x]=tot;
	return;
}
void dfs1(int u,int f)
{
	dep[u]=dep[f]+1;
	fa[u]=f;
	size[u]=1;
	for(int i=head[u];i;i=node[i].next)
	{
		int v=node[i].t;
		if(v!=f)
		{
			dfs1(v,u);
			size[u]+=size[v];
			if(size[v]>size[son[u]]) son[u]=v;
		}	
	}
}
void dfs2(int u,int f)
{
	if(son[u])
	{
		seg[son[u]]=++seg[0];
		rev[seg[0]]=son[u];
		top[son[u]]=top[u];
		dfs2(son[u],u);
	}
	for(int i=head[u];i;i=node[i].next)
	{
		int v=node[i].t;
		if(v!=f && v!=son[u])
		{
			seg[v]=++seg[0];
			rev[seg[0]]=v;
			top[v]=v;
			dfs2(v,u);
		}
	}
}
void build(int k,int l,int r)
{
	tree[k].l=l; tree[k].r=r;
	if(l==r)
	{
		tree[k].sum=0;
		tree[k].lazy=0;
		return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	tree[k].sum=tree[lc].sum+tree[rc].sum;
	tree[k].lazy=0;
}
void pushdown(int k)
{
	if(!tree[k].lazy) return;
	tree[lc].sum+=(tree[lc].r-tree[lc].l+1)*tree[k].lazy;
	tree[lc].lazy+=tree[k].lazy;
	tree[rc].sum+=(tree[rc].r-tree[rc].l+1)*tree[k].lazy;
	tree[rc].lazy+=tree[k].lazy;
	tree[k].lazy=0;
}
void update(int k,int l,int r,int val)
{
	if(tree[k].l>=l && tree[k].r<=r)
	{
		tree[k].sum+=(tree[k].r-tree[k].l+1)*val;
		tree[k].lazy+=val;
		return;
	}
	pushdown(k);
	int mid=(tree[k].l+tree[k].r)>>1;
	if(l<=mid) update(lc,l,r,val);
	if(r>mid) update(rc,l,r,val);
	tree[k].sum=tree[lc].sum+tree[rc].sum;
}
void query(int k)
{
	if(tree[k].l==tree[k].r)
	{
		if(rev[tree[k].l]!=root) a[rev[tree[k].l]]=tree[k].sum-1;
		else a[rev[tree[k].l]]=tree[k].sum;
		return; //除了最开始走的那个节点，其余的所有节点都要减去1
	}
	pushdown(k);
	query(lc);
	query(rc);
}
void ask(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		update(1,seg[top[x]],seg[x],1);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	update(1,seg[x],seg[y],1);
}
int main()
{
// 	freopen("b.in","r",stdin);
//	freopen(".out","w",stdout);
	int b[N]={0};
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&b[i]);
	root=b[1];
	for(int i=1;i<=n-1;++i)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		add(x,y);
		add(y,x);
	}
	seg[1]=seg[0]=1;
	rev[1]=1;
	dfs1(1,0);
	dfs2(1,0);
	build(1,1,n);	
	for(int i=1;i<=n-1;++i)
		ask(b[i],b[i+1]); //每次将b[i]到b[i+1]的路径加上1
	query(1);
	for(int i=1;i<=n;++i) printf("%d\n",a[i]);
	return 0;
}
```

---

## 作者：Atmizz (赞：4)

LCA + 树上差分

对于访问序号我们将其变成边的形式。

对于所有的的边，

我们会发现第一条和最后一条是特殊的。

1. 第一条是两个端点都是包含的， 即在两个端点上都放糖果：[u,v]

2. 最后一条是两个端点都不包含， 即在两个端点上不放糖果：(u,v)

3. 其余的路径都是一样的，前一个包含，后一个不包含：[u,v)

f数组是倍增lca数组，u和v分别是一边的端点。

1. 先看第一条边，直接进行树上差分，无特殊处理。

2. 最后一条边，我们要进行讨论，一共有3种情况：

    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-f[v][0].
    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-f[v][0].
    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-son[v].
3. 其余的边，也是讨论3种情况：
    1. `u != LCA && v != LCA`，那么我们要差分的边就是f[u][0]-v.
    2. `u == LCA && v != LCA`，那么我们要差分的边就是son[u]-v.
    3. `u != LCA && v == LCA`，那么我们要差分的边就是f[u][0]-v
    
做完这些，就是树上差分的板子了，这里就不赘述了。
```cpp
#include <cstdio>
#include <algorithm>
#define re register
#define gc getchar
inline int read() {
	int s = 0, f = 1; char ch = gc();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = gc();}
	while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = gc();
	return s * f;
}
inline int min(int a, int b) {return a < b ? a : b;}
inline int max(int a, int b) {return a > b ? a : b;}
const int INF = 0x7fffffff;
const int Max = 600012;
const int mod = 19260817;
const int N = 1000007;
struct Candy {
	int net, to;
}t[Max];
int n, head[Max], cnt, f[Max][21];
int x[Max], y[Max], k[Max], deep[Max];
inline void insert(int u, int v) {
	t[++cnt].to = v;
	t[cnt].net = head[u];
	head[u] = cnt;
}
void dfs(int x, int Fa) {
	f[x][0] = Fa; deep[x] = deep[Fa] + 1;
	for(int i = 1; (1 << i) <= deep[x]; i++)
		f[x][i] = f[f[x][i-1]][i-1];
	int v;
	for(re int i = head[x]; i; i = t[i].net) {
		v = t[i].to;
		if(v == Fa) continue;
		dfs(v,x);
	}
}
int lca(int x, int y) {
	if(deep[x] < deep[y]) std :: swap(x, y);
	for(re int i = 21; i >= 0; -- i)
		if(deep[x] - (1 << i) >= deep[y])
			x = f[x][i];
	if(x == y) return x;
	for(re int i = 20; i >= 0; -- i)
		if(f[x][i] == f[y][i]) continue;
		else x = f[x][i], y = f[y][i];
	return f[x][0];
}
void SUM(int x, int Fa) {
	int v;
	for(re int i = head[x]; i; i = t[i].net) {
		v = t[i].to; if(v == Fa) continue;
		SUM(v, x); k[x] += k[v];
	}
}
int find_son(int x, int LCA) {
	int depth = deep[LCA] + 1;
	for(re int i = 21; i >= 0; -- i)
		if(deep[x] - (1 << i) >= depth)
			x = f[x][i];
	return x;
}
int main() {
	n = read(); int u, v; x[1] = read();
	for(re int i = 1; i < n; ++ i) y[i] = read(), x[i+1] = y[i];
	for(re int i = 1; i < n; ++ i)
		u = read(), v = read(), insert(u,v), insert(v,u);
	dfs(1,0);
	int LCA = lca(x[n-1], y[n-1]); bool fg = 1;
	if(x[n-1] != LCA && y[n-1] != LCA)
		u = f[x[n-1]][0], v = f[y[n-1]][0];
	else if(x[n-1] == LCA && y[n-1] != LCA) {
		u = find_son(y[n-1], LCA), v = f[y[n-1]][0];
		if(f[y[n-1]][0] == x[n-1]) fg = 0;
	}
	else if(x[n-1] != LCA && y[n-1] == LCA) {
		u = f[x[n-1]][0], v = find_son(x[n-1], LCA);
		if(f[x[n-1]][0] == y[n-1]) fg = 0;
	}
	LCA = lca(u, v);
	if(fg) k[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;
	u = x[1]; v = y[1]; LCA = lca(u, v);
	k[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;
	for(re int i = 2; i < n - 1; ++ i) {
		LCA = lca(x[i], y[i]);
		if(x[i] != LCA && y[i] != LCA)
			u = f[x[i]][0], v = y[i];
		else if(x[i] == LCA && y[i] != LCA)
			u = find_son(y[i], LCA), v = y[i];
		else if(x[i] != LCA && y[i] == LCA)
			u = f[x[i]][0], v = y[i];
		LCA = lca(u,v);
		k[u] ++, k[v] ++, k[LCA] --, k[f[LCA][0]] --;
	}
	SUM(1,0);
	for(re int i = 1; i <= n; ++ i) printf("%d\n",k[i]);
	return 0;
}
```

---

## 作者：skydogli (赞：3)

树剖萌新（不是妹子）刷到了这题，就来一发给同是蒟蒻的同学的题解吧
### 树剖基础知识（学过的请直接跳过）
树链剖分，简称树剖，~~(一种码量很大的毒瘤数据结构)~~用于解决树上路径和子树的修改和询问的算法，可以理解为树上的线段树。主要的手段为划分轻重儿子和轻重链，对于每一棵子树把子节点最多的子节点设为重儿子（子节点数相同则无所谓），重儿子的连线即为重链。如图：
![](https://cdn.luogu.com.cn/upload/pic/42456.png)

以节点1为根节点建树，2有1个子节点（包括自己），4有2个子节点，3有4个子节点，所以3是1的重儿子，同理5是3的重儿子，8是5的重儿子，7是4的重儿子。该操作只需一次搜索就可完成。
有了轻重链和轻重儿子，再记录这条链的顶端（重链的是顶端，轻链则是它自己，图中2的顶端是2，1，3，5，8的顶端是1，6的顶端是6，7的顶端是4）我们找2个节点之间的路径就行啦，如果顶端不同就向上跳到顶端的父节点，一看就快了很多有木有！但是，这一整条链都需要改变，这就需要用到线段树啦！线段树的操作，必须要有连续的编号。而我们节点向上跳都是在重链上跳（轻链只会跳一个节点，相当于跳到父亲节点），所以我们只要能让整条重链都有序，就能做到修改和查询的工作啦！于是我们还需要再dfs一次，按重链优先的规则标号，就可以在树上用线段树了。于是上图变成了这样（~~shit~~黄色数字为编号）：
![](https://cdn.luogu.com.cn/upload/pic/42458.png)

有没有发现，一棵子树，虽然不在一条链上，但它们的编号是连续的。所以子树的修改和查询也不在话下。

**时间复杂度：**首先查询时需要跑重链，而一条路径上重链不超过logn条，因为每跳一条重链也要跳一条轻链，而轻链的子节点数不会超过子树的1/2，所以最多只要跳log（n）次，每次用一次线段树修改或查询，所以复杂度就是qlog^2(n)(q为询问数，这题等于n）

### 题意解析
一棵树，每个点初始值都为0，输入n-1条路径，要把每条路径上经过的点的值+1，最后依次输出所有点的值。看到修改路径上点的值，就确定可以用树剖做，数据n<=300000,qlog^2(n)略超一亿，当然树剖是跑不满的，所以勉强能跑过。

虽然这题没必要用树剖，但是因为~~（我不会树上差分）~~题目要求比较少（甚至不用建树），所以代码量还是比较良心的，一百行都不用，可以拿来练练手或做树剖模板的铺垫。
### 这题略坑的地方
可能有些同学按题意打完树剖发现Wa了，如果树剖部分没错，可能就是你理解错题意了：除了刚开始的点之外，其它的点都是到达和开始算一个单位时间的，但是计算时算了2次，加个判断就行了。
### 品尝代码前需要知道的小玩意儿（详细了解请[点这里](www.cplusplus.com)）
1、**vector**，动态数组，内存动态，在存边时比较常用，相当于邻接链表

2、**define a b** 宏定义，把a变成b，用于节省代码量和作死

3、**register int** 用于卡常（好像只是心理安慰）

4、**>>1 **等于除以2,**<<1**等于乘2，**<<1|1**等于乘二加一，用于卡常（经实测，从969ms变成了940ms，整整快了26ms。。。）
### AC~~（卡过去的）~~代码（带注释）
```cpp
#include<bits/stdc++.h>
#define MN 1200005
#define mn 300005
using namespace std;
int Q[mn],h[mn],fa[mn],siz[mn],val[mn],id[mn],N,w[mn],add[MN],n,a,b,que[mn],top[mn];
vector<int>edge[mn];
void bfs(){
	int l=0,r=1;
	Q[0]=1;h[1]=1;
	while(l<r){
		int o=Q[l++],sz=edge[o].size();
		for(register int i=0;i<sz;i++){
			if(!h[edge[o][i]]){
				Q[r++]=edge[o][i];
				h[edge[o][i]]=h[o]+1;
				fa[edge[o][i]]=o;
			}
		}
	}
	for(register int i=r-1;i>=0;i--){
		int o=Q[i];
		siz[o]=1;
		int sz=edge[o].size();
		for(register int j=0;j<sz;j++){
			siz[o]+=siz[edge[o][j]];
			if(siz[w[o]]<siz[edge[o][j]]) w[o]=edge[o][j];
		}
	}
}//父子关系、儿子数量、重儿子 、深度，也可以用dfs
void dfs(int o){
	id[o]=++N;
	val[N]=0;
	if(w[o]) top[w[o]]=top[o],dfs(w[o]);
	int sz=edge[o].size();
	for(register int i=0;i<sz;i++){
		if(fa[o]!=edge[o][i]&&w[o]!=edge[o][i]){
			top[edge[o][i]]=edge[o][i];
			dfs(edge[o][i]);
		}
	}
}//重链(顶端）、编号（价值）（用于线段树），必须用dfs


//为线段树的准备阶段


void down(int nod){
	add[nod*2]+=add[nod];
	add[nod*2+1]+=add[nod];
	add[nod]=0;
}//下传标记
void pluss(int nod,int l,int r,int b,int e){
	if(l>e||r<b) return;
	if(b<=l&&r<=e) {
		add[nod]++;
		return;
	}
	down(nod);
	int mid=(l+r)>>1;
	pluss(nod<<1,l,mid,b,e);
	pluss(nod<<1|1,mid+1,r,b,e);
}//在一条链上时的修改
void plusroad(int x,int y){
	while(top[x]!=top[y]){
		if(h[top[x]]>h[top[y]]) swap(x,y);
		pluss(1,1,n,id[top[y]],id[y]);
		y=fa[top[y]];
	}
	if(h[x]>h[y]) swap(x,y);
	pluss(1,1,n,id[x],id[y]);
}//整条路径的修改
int ask(int nod,int l,int r,int b,int e){
	if(l>e||r<b) return 0;
	if(l==r) return add[nod];
	down(nod);
	int mid=(l+r)>>1;
	return ask(nod<<1,l,mid,b,e)+ask(nod<<1|1,mid+1,r,b,e);
}

//线段树模板

int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
		scanf("%d",&que[i]);
	for(register int i=1;i<n;i++){
		scanf("%d%d",&a,&b);
		edge[a].push_back(b);
		edge[b].push_back(a);
	}
	bfs();dfs(1);
	for(register int i=1;i<n;i++)
		plusroad(que[i],que[i+1]);
	for(register int i=1;i<=n;i++)
		if(que[1]!=i) printf("%d\n",ask(1,1,n,id[i],id[i])-1);
		 else printf("%d\n",ask(1,1,n,id[i],id[i]));
        //特判，除了第一个房间之外都要-1
	return 0;
}
```
最后，祝大家NOIPrp++，暴力跑飞快，骗分出AC，乱搞切DP，打表出省一！



---

## 作者：Gu_Pigeon (赞：2)

# ~~比板子简单系列~~

这题的思路很明显，在每一次经过一个房间时就给这个房间的多准备一个糖果。

因此，本题需要维护：

树上两点之间路径都加上1

求出一个节点的值

所以主要有两种做法：

1. 树上差分+lca

2. 树链剖分（本人用的是这个）

到此这道题就可以~~去复制板子的代码~~解决了！

那么，这题要注意些什么细节呢？

## ~~并没有~~

哦对了，不要急着把两点路径上所有的点都+1，如果你手玩过样例，我们发现不会给终点的节点+1，所以每次加完后记得把每一次的终点上的值减回来。

$Code\ Below$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 333333
#define ls rt << 1
#define rs rt << 1 | 1
#define int long long

int f[N], d[N], sz[N], son[N], tp[N], id[N], rk[N], cnt;
int to[N << 1], nxt[N << 1], head[N], tot;
int n, m, a[N];

void addedge(int x, int y)
{
	to[++tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
}//前向星建边

//--------------------以下线段树--------------------

struct tree
{
	int l, r, val, tag;
} t[N << 2];

inline void pushup(int rt)
{
	t[rt].val = (t[ls].val + t[rs].val);
}

inline void pushdown(int rt)
{
	t[ls].val = (t[ls].val + t[rt].tag * (t[ls].r - t[ls].l + 1)); t[ls].tag = (t[ls].tag + t[rt].tag);
	t[rs].val = (t[rs].val + t[rt].tag * (t[rs].r - t[rs].l + 1)); t[rs].tag = (t[rs].tag + t[rt].tag);
	t[rt].tag = 0;
}

void build(int rt, int l, int r)
{
	t[rt].l = l, t[rt].r = r;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	pushup(rt);
}

void update(int rt, int l ,int r, int v)
{
	if (l <= t[rt].l && t[rt].r <= r)
	{
		t[rt].val = (t[rt].val + v * (t[rt].r - t[rt].l + 1));
		t[rt].tag = (t[rt].tag + v);
		return;
	}
	pushdown(rt);
	int mid = (t[rt].l + t[rt].r) >> 1;
	if (l <= mid) update(ls, l, r, v);
	if (mid < r) update(rs, l, r, v);
	pushup(rt);
}

int query(int rt, int l, int r)
{
	if (l <= t[rt].l && t[rt].r <= r) return t[rt].val;
	pushdown(rt);
	int ans = 0, mid = (t[rt].l + t[rt].r) >> 1;
	if (l <= mid) ans = (ans + query(ls, l, r));
	if (mid < r) ans = (ans + query(rs, l, r));
	return ans;
}

//--------------------以上线段树--------------------
//--------------------以下树链剖分--------------------

void dfs1(int x, int fa, int depth)
{
	f[x] = fa; d[x] = depth; sz[x] = 1;
	for (int i = head[x]; i; i = nxt[i])
	{
		int y = to[i];
		if (y == fa) continue;
		dfs1(y, x, depth + 1);
		sz[x] += sz[y];
		if (sz[y] > sz[son[x]]) son[x] = y;
	}
}

void dfs2(int x, int top)
{
	tp[x] = top; id[x] = ++cnt; rk[cnt] = x;
	if (!son[x]) return;
	dfs2(son[x], top);
	for (int i = head[x]; i; i = nxt[i])
	{
		int y = to[i];
		if (y != son[x] && y != f[x]) dfs2(y, y);
	}
}

void change(int x, int y, int z)
{
	while (tp[x] != tp[y])
	{
		if (d[tp[x]] < d[tp[y]]) swap(x, y);
		update(1, id[tp[x]], id[x], z);
		x = f[tp[x]];
	}
	if (d[x] > d[y]) swap(x, y);
	update(1, id[x], id[y], z);
}

//--------------------以上树链剖分--------------------

signed main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) scanf("%lld", a + i);
	for (int i = 1; i < n; i++)
	{
		int x, y;
		scanf("%lld%lld", &x, &y);
		addedge(x, y);
		addedge(y, x);
	}
	dfs1(1, 0, 1); dfs2(1, 1); build(1, 1, n);
	for (int i = 1; i < n; i++)
	{
		change(a[i], a[i + 1], 1);
		change(a[i + 1], a[i + 1], -1);
	}
	for (int i = 1; i <= n; i++) printf("%lld\n", query(1, id[i], id[i]));//单点修改，直接线段树上操作就好了
}
```

---

## 作者：yurzhang (赞：2)

由于树上两点路径唯一，维尼的路线也是唯一的，因此我们只要 ** 统计维尼经过每个点的次数 ** 即可。而树上路径又跟 ** LCA ** 什么的有关，因此这道题的做法就多种多样了。

由于只有一次询问，比较容易想到的做法是 ** 树上差分 ** 后求 ** LCA ** 轻松搞定。再想深一点你会发现这道题简直就是 ** 树链剖分 ** 的板子(事实上它就在试炼场省选树剖里头)，再加上这道题不用维护什么子树信息，所以 ** 树链剖分 ** 能做 ** Link-Cut Tree ** 当然也能做！

### 值得注意的几点：
#### 1.这道题LCT得卡常，写的时候注意不要太飘；
#### 2.由于两条链相交的点会被重复计算，因此每次加的时候链头链尾要有一个减1(我是链尾)；
#### 3.最后一个点是不需要准备糖果的！
#### 4.输出答案的时候记得把标记都下放了(我是先makeroot再输出)。

先放**90分**代码：
```cpp
#include <cstdio>

#define N 300010
#define lc(x) ch[x][0]
#define rc(x) ch[x][1]
inline void swap(int&a,int&b){int tmp(a);a=b,b=tmp;}

int ch[N][2],fa[N],rev[N],val[N],addv[N];
inline void add(int x,int y){val[x]+=y,addv[x]+=y;}
inline void down(int x)
{
    if(rev[x])
        rev[lc(x)]^=1,rev[rc(x)]^=1,swap(lc(x),rc(x)),rev[x]=0;
    if(addv[x])
        add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;
}
inline int nrt(int x){return x==lc(fa[x])||x==rc(fa[x]);}
void psa(int x){if(nrt(x))psa(fa[x]);down(x);}
inline void rotate(int x)
{
    int y(fa[x]),z(fa[y]),k(x==rc(y));
    ch[y][k]=ch[x][!k],ch[x][!k]=y;if(nrt(y))ch[z][y==rc(z)]=x;
    if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z;
}
inline void splay(int x)
{
    int y,z;
    for(psa(x);nrt(x);rotate(x))
    {y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);}
}
inline void access(int x){for(int y(0);x;x=fa[y=x])splay(x),rc(x)=y;}
inline void mrt(int x){access(x),splay(x),rev[x]^=1;}
inline void link(int x,int y){mrt(x),fa[x]=y;}

int n,a[N],x,y;

int main()
{
    scanf("%d",&n);
    for(int i(1);i<=n;++i)
        scanf("%d",a+i);
    for(int i(1);i<n;++i)
        scanf("%d%d",&x,&y),link(x,y);
    for(int i(1);i<n;++i)
        --val[a[i+1]],mrt(a[i]),access(a[i+1]),splay(a[i+1]),add(a[i+1],1);
    for(int i(1);i<=n;++i)
        mrt(i),printf("%d\n",val[i]);
    return 0;
}
```
**无O2  无快读  无register**[评测记录](https://www.luogu.org/recordnew/show/16027893)

加了若干个register后AC代码：
```cpp
#include <cstdio>

#define N 300010
#define lc(x) ch[x][0]
#define rc(x) ch[x][1]
#define re register
inline void swap(re int&a,re int&b){re int tmp(a);a=b,b=tmp;}

int ch[N][2],fa[N],rev[N],val[N],addv[N];
inline void add(re int x,re int y){val[x]+=y,addv[x]+=y;}
inline void down(re int x)
{
    if(rev[x])
        rev[lc(x)]^=1,rev[rc(x)]^=1,swap(lc(x),rc(x)),rev[x]=0;
    if(addv[x])
        add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;
}
inline int nrt(re int x){return x==lc(fa[x])||x==rc(fa[x]);}
void psa(int x){if(nrt(x))psa(fa[x]);down(x);}
inline void rotate(re int x)
{
    re int y(fa[x]),z(fa[y]),k(x==rc(y));
    ch[y][k]=ch[x][!k],ch[x][!k]=y;if(nrt(y))ch[z][y==rc(z)]=x;
    if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z;
}
inline void splay(re int x)
{
    re int y,z;
    for(psa(x);nrt(x);rotate(x))
    {y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);}
}
inline void access(re int x){for(re int y(0);x;x=fa[y=x])splay(x),rc(x)=y;}
inline void mrt(re int x){access(x),splay(x),rev[x]^=1;}
inline void link(re int x,re int y){mrt(x),fa[x]=y;}

int n,a[N],x,y;

int main()
{
    scanf("%d",&n);
    for(re int i(1);i<=n;++i)
        scanf("%d",a+i);
    for(re int i(1);i<n;++i)
        scanf("%d%d",&x,&y),link(x,y);
    for(re int i(1);i<n;++i)
        --val[a[i+1]],mrt(a[i]),access(a[i+1]),splay(a[i+1]),add(a[i+1],1);
    for(re int i(1);i<=n;++i)
        mrt(i),printf("%d\n",val[i]);
    return 0;
}
```
**无O2  无快读**[评测记录](https://www.luogu.org/recordnew/show/16027980)

菜鸡最后祝各位全都 AKIOI qwq

---

## 作者：no_one_cm_Fe_in_hand (赞：2)

（话说为什么没有差分的标签）算是水的紫题毕竟天天爱跑步也“不过”是差分的紫题。。。
题意为要求出每个点被每条链经过的次数
lca是肯定的咯
but我们发现要求好多点的lca
tarjan（他日渐）肯定比lca优秀；
不会的可以百度学习一下。。
ps.tarjan是一个离线算法，本质是对向上标记法的优化。时间复杂度为O(n+m)；而倍增多一个log
差分统计时：：
```cpp
--ans[fat[lca[i]]];
--ans[lca[i]];
++ans[a[i]];
++ans[a[i+1]];
```
就OK了。
最后跑一遍大法师统计即可；
由于题目的特殊性，有一些小小 的细节见代码注释。。。。
&&蒟蒻发题解的动机是：（因为太弱被禁言了）发不了犇犇。只能在题解里     
while(1) ++noip2018rp;
朴素而简短的代码
```cpp
#include<bits/stdc++.h>
#define N 300010
using namespace std;
int a[300010];
int head[N],nex[N<<1],ver[N<<1],tot;
vector<int> qr[N],qid[N];
int fat[N];
int lca[N],f[N];
int v[N];
inline void add(int x,int y){ ver[++tot]=y; nex[tot]=head[x]; head[x]=tot; }
inline int fa(int x){
	return f[x]==x?x:f[x]=fa(f[x]);
}
inline void tarjan(int x){
	v[x]=1;
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(v[y]) continue;
		fat[y]=x;
		tarjan(y);f[y]=x;
	}
	for(int i=0;i<qr[x].size();++i){
		int y=qr[x][i];
		if(v[y]==2)	lca[qid[x][i]]=fa(y);
	}
	v[x]=2;
}
int ans[N];
inline void dfs(int x,int fa){
	for(int i=head[x];i;i=nex[i]){
		int y=ver[i];
		if(y==fa) continue;
		dfs(y,x);ans[x]+=ans[y];
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);f[i]=i;
		if(i!=1) 
		qr[a[i]].push_back(a[i-1]),
		qr[a[i-1]].push_back(a[i]),
		qid[a[i]].push_back(i-1),
		qid[a[i-1]].push_back(i-1);
	}
	for(int i=1;i<n;++i){
		int x,y;
		scanf("%d%d",&x,&y);add(x,y);add(y,x);
	}
	fat[1]=0;
	tarjan(1);
	for(int i=1;i<n;++i){
		--ans[fat[lca[i]]];--ans[lca[i]];++ans[a[i]],++ans[a[i+1]];//注意到除了a【1】和a【n】，其他点均被加了两次所以下面我们要剪掉。以及要在dfs后再减 
	}
	dfs(1,0);
	for(int i=2;i<=n;++i) --ans[a[i]];//顺便把ans[a[n]]也剪掉 
	for(int i=1;i<=n;++i) printf("%d\n",ans[i]);
}
```

---

## 作者：zzqDeco (赞：2)

这道题我太弱了只想到树链剖分的解法

为什么大佬都用线段树呢？？？

我来个树状数组。

思路很简单，每次在路径ai到aj（不包括aj）的所有点加一，最后再求单点的值

对于此题可以发现，只要让数据结构支持区间修改，单点查询就行

因此考虑树状数组（如果不知道树状数组如何支持区间修改，单点查询，可以试试通过洛谷的树状数组2板子）

下面就放上代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;

struct edge
{
	int to,next;
}e[600010];

int c[300010];

int num,head[300010];

int n,cnt;

int d[300010],f[300010],size[300010],son[300010],top[300010],id[300010],path[300010];

void addedge(int a,int b)//建边
{
	e[++num].to=b;
	e[num].next=head[a];
	head[a]=num;
}

void add(int x,int val)//添加，值得注意的是，树状数组只能添加前缀和
{
  for(;x;x-=(x&-x)) c[x]+=val;
}

int ask(int x)//永久标记，单点查询
{
  long long ans=0;
  for(;x<=n;x+=(x&-x)) ans+=c[x];
  return ans;
}

void dfs1(int u,int fa,int depth)
{
	d[u]=depth;
	f[u]=fa;
	size[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		if(e[i].to==fa)
		{
			continue;
		}
		dfs1(e[i].to,u,depth+1);
		size[u]+=size[e[i].to];
		if(size[e[i].to]>size[son[u]])
		{
			son[u]=e[i].to;
		}
	}
}

void dfs2(int u,int t)
{
	top[u]=t;
	id[u]=++cnt;
	if(!son[u])
	{
		return ;
	}
	dfs2(son[u],t);
	for(int i=head[u];i;i=e[i].next)
	{
		if(e[i].to!=f[u]&&e[i].to!=son[u])
		{
			dfs2(e[i].to,e[i].to);
		}
	}
}

//上面两个dfs是树链剖分的模板内容，目的是划分重链

void up(int x,int y,int a)
{
	add(id[y]-1,a);
	add(id[y],-a);//我觉得这里大家可能有点迷，实际上是为了不包括y点，先将y点多加的减去
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])
		{
			swap(x,y);
		}
		add(id[x],a);
		add(id[top[x]]-1,-a);
		x=f[top[x]];
	}
	if(id[x]>id[y])
	{
		swap(x,y);
	}
	add(id[y],a);
	add(id[x]-1,-a);
}

int find(int x)
{
	return ask(id[x]);//树状数组的单点查询
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&path[i]);
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		addedge(x,y);
		addedge(y,x);
	}
	dfs1(1,0,1);
	dfs2(1,1);
	cnt=1;
	for(int i=1;i<n;i++)
	{
		up(path[i],path[i+1],1);
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d\n",find(i));
	}
}
```

---

## 作者：yybyyb (赞：2)

这题大佬们的方法都很强呀

~~我这个小蒟蒻还是太菜~~

树链剖分+树上差分

树链剖分之后，每一次在树上跳重链的时候

利用树上差分，将一段区间的值差分表示出来

最后O(n)扫一遍统计答案即可

因为每一次访问的时候会有一个节点被算两次

记住要减去一次

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
#define MAX 301000
inline int read()
{
    register int x=0,t=1;
    register char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*t;
}
struct Line
{
    int v,next;
}e[MAX*3];
int h[MAX],hson[MAX],size[MAX],top[MAX],f[MAX],dep[MAX],dfn[MAX];
int N,M,cnt=1,c[MAX],tim,A[MAX],line[MAX],Ans[MAX];
inline void Add(int u,int v)
{
    e[cnt]=(Line){v,h[u]};
    h[u]=cnt++;
}
void DFS1(int u,int ff)
{
    hson[u]=0;size[u]=1;f[u]=ff;dep[u]=dep[ff]+1;
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v==ff)continue;
        DFS1(v,u);
        if(size[v]>size[hson[u]])hson[u]=v;
        size[u]+=size[v];
    }
}
void DFS2(int u,int tp)
{
    top[u]=tp;dfn[u]=++tim;line[tim]=u;
    if(hson[u])DFS2(hson[u],tp);
    for(int i=h[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v==hson[u]||v==f[u])continue;
        DFS2(v,v);
    }
}
void LCA(int x,int y)
{
    int tp1=top[x],tp2=top[y];
    while(tp1!=tp2)
    {
        if(dep[tp1]<dep[tp2])
        {
            swap(tp1,tp2);
            swap(x,y);
        }
        c[dfn[tp1]]++;c[dfn[x]+1]--;
        x=f[tp1];tp1=top[x];
    }
    if(dep[x]<dep[y])swap(x,y);
    c[dfn[y]]++;c[dfn[x]+1]--;
}
int main()
{
    N=read();
    for(int i=1;i<=N;++i)A[i]=read();
    for(int i=1;i<N;++i)
    {
        int a=read(),b=read();
        Add(a,b);Add(b,a);
    }
    DFS1(1,0);DFS2(1,1);
    for(int i=1;i<N;++i)
    {
        int x=A[i],y=A[i+1];
        LCA(x,y);
        c[dfn[y]]--;c[dfn[y]+1]++;
    }
    int ans=0,pl=0;
    for(int i=1;i<=N;++i)
    {
        pl=pl+c[i];
        Ans[line[i]]=pl;
    } 
    for(int i=1;i<=N;++i)printf("%d\n",Ans[i]);
    return 0;
}
```

---

## 作者：star_city (赞：2)

楼下各位神犇都用了lca，本蒟蒻看不懂，就自己来发个题解吧。

首先还是树剖+差分，但省去了lca~~繁琐~~的过程。

打开这个题说明你会树剖所以不讲。

差分对于重复的位置打标记，最终答案就是差分数组的前缀和+对应标记的值。

---

比如题目样例：

以1号点为根，经过两遍dfs之后，我们得到的dfs序就是：

1 2 4 5 3

---

然后开始：

1.要从1号点走到4号点，就可以把差分数组中1号点+1，4号点-1，并把4号点打上一个+1标记。

------dfs序：1 2 4 5 3

差分数组：1 0 -1 0 0

----前缀和：1 1 0 0 0

----------tag：0 0 1 0 0

此时答案：1 1 1 0 0（表示1号点、2号点、4号点各需要一个糖果）

---

2.由于上一次在4号点，所以为了去重就把4号点打一个-1标记。

要从4号点走到5号点，就可以把差分数组中4号点+1，5号点-1，5号点打上一个+1标记。

------dfs序：1 2 4 5 3

差分数组：1 0 0 -1 0

----前缀和：1 1 1 0 0

----------tag：0 0 0 1 0

此时答案：1 1 1 1 0（表示1、2、4、5各需要一个糖果）

---

3.由于上一次在5号点，所以为了去重就把5号点打一个-1标记。

要从5号点走到3号点，按照树剖思想，由于top[5] = 1的深度 < top[3] = 3的深度(这个自己把样例中的树画出来就知道了），交换两个值，也就是看成从3号点走到5号点。

还是树剖思想，把3到top[3] = 3和fa[top[3]] = 2到5的路径都+1。

那么要做的就是在差分数组中，把3号点+1，3号点-1并给3号点打一个+1标记（正好重合了所以这么加），然后把2号点+1，5号点-1并给5号点打一个+1标记。

------dfs序：1 2 4 5 3

差分数组：1 1 0 -2 0

----前缀和：1 2 2 1 0

----------tag：0 0 0 1 1

此时答案：1 2 2 1 1

---

4.由于上一次在3号点，所以把3号点打一个-1标记。

要从3号点走到2号点，同第三步，把3到top[3] = 3和fa[top[3]] = 2到2的路径都+1。

那么要做的就是在差分数组中，把3号点+1-1再打个+1标记，2号点+1-1再打个+1标记。

------dfs序：1 2 4 5 3

差分数组：1 1 0 -2 0

----前缀和：1 2 2 1 0

----------tag：0 1 0 1 1

此时答案：1 3 2 1 1

---

最后一步，把最后一个点打一个-1标记（因为最后一个房间不需要糖果），也就是2号点标记-1。

------dfs序：1 2 4 5 3

差分数组：1 1 0 -2 0

----前缀和：1 2 2 1 0

----------tag：0 0 0 1 1

最终答案：1 2 2 1 1

（表示1、3、5各要一个糖果，2、4各要2个糖果）

---

```
#include <iostream>
#include <algorithm>
#include <cstdio>

const int maxn = 300007;

using namespace std;

int n;
int a[maxn];

int to[maxn << 1];
int nex[maxn << 1];
int last[maxn], k; //前向星的东西

int st[maxn]; //差分数组
int tag[maxn]; //标记数组

int fa[maxn]; //父节点
int son[maxn]; //重儿子
int dep[maxn]; //深度
int top[maxn]; //就是那个top
int size[maxn]; //子树大小

int cnt;
int id[maxn]; //存储dfs序的位置
 //树剖的一堆东西

inline int read()
{
    int X = 0; char ch = 0;
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') X = (X << 3) + (X << 1) + ch - '0', ch = getchar();
    return X;
} //快读

inline void add_edge(int u, int v)
{
    to[++k] = v; nex[k] = last[u]; last[u] = k;
} //连边

inline void uprange(int x, int y)
{
    while (top[x] != top[y]) { //树剖思想
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        st[id[top[x]]]++;
        st[id[x]]--;
        tag[x]++; //前两条语句求前缀和后会漏下第x个点没有糖果，所以把这个漏下的放标记里
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    st[id[x]]++;
    st[id[y]]--;
    tag[y]++; //这里也一样，查漏补缺
}

void dfs1(int x, int f, int depth)
{
    fa[x] = f;
    dep[x] = depth;
    size[x] = 1;
    int wson = -1;
    for (int i = last[x]; i; i = nex[i]) {
        int y = to[i];
        if (y == f) continue;
        dfs1(y, x, depth + 1);
        size[x] += size[y];
        if (size[y] > wson) wson = size[y], son[x] = y;
    }
}

void dfs2(int x, int topf)
{
    id[x] = ++cnt;
    top[x] = topf;
    if (!son[x]) return;
    dfs2(son[x], topf);
    for (int i = last[x]; i; i = nex[i]) {
        int y = to[i];
        if (y == fa[x] || y == son[x]) continue;
        dfs2(y, y);
    }
}
//两个dfs

int main(void)
{
    n = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    int x, y;
    for (int i = 1; i < n; i++) {
        x = read();
        y = read();
        add_edge(x, y);
        add_edge(y, x); //树是双向边
    }
    dfs1(1, 0, 1);
    dfs2(1, 1);
    //以1为根，当然其它点也可以
    uprange(a[1], a[2]); //先更新前两个点
    for (int i = 2; i < n; i++) {
        uprange(a[i], a[i+1]); //更新每两个点
        tag[a[i]]--; //去重的-1标记
    }
    tag[a[n]]--; //最后一个点的标记
    for (int i = 1; i < n; i++) st[i+1] += st[i]; //求差分的前缀和
    for (int i = 1; i <= n; i++) printf("%d\n", st[id[i]] + tag[i]); //答案就是差分的前缀和+标记的值
    
    return 0;
}
```

---

## 作者：半仙胡小桃 (赞：2)

##题目分析：

看大家清一色都是树剖+树上差分的做法，本弱贡献一种用树剖+线段树的思路。

题意很明显 每次把$u_{i-1}->lca(u_{i-1},u_i)->u_i$路径上的点权值都+1

很明显就是线段树嘛。

我们把所有的区间修改操作都搞好了以后，然后把整颗线段树都遍历一遍，求出每个点上的权值。

但问题是 中间的点每次加都多加了1（不包括第一次的点和最后一次的点）

那我们就用个数组记录下来 最后输出的时候减去多加的值就行。

总耗时1000ms左右 毕竟不是正解思路，也许改成ZKW式线段树会更快

总行数140行左右，比差分多了不少，我真是菜。

##AC Code：


```cpp
#include <cstdio>
#include <iostream>
#define lson (o<<1),l,mid
#define rson (o<<1)+1,mid+1,r
using namespace std;
const int maxm=310000;
int deep[maxm],son[maxm],size[maxm],fa[maxm],top[maxm];
int head[maxm],to[maxm<<1],net[maxm<<1],cnt;
int p[maxm],val[maxm],who[maxm],ans[maxm],sx[maxm];
int id[maxm],tot;
int n,m,root;
struct node{
    int l,r,siz,maxi,sum,add;
};
node t[maxm*4];
struct war{
    int u,v;
};
war a[maxm];
inline void add(int x,int y)
{
    to[++cnt]=y;
    net[cnt]=head[x];
    head[x]=cnt;
}
int dfs1(int now,int fax,int dep)
{
    fa[now]=fax,deep[now]=dep,size[now]=1;
    int maxson=-1;
    for(int i=head[now];i;i=net[i])
    if(to[i]!=fax)
    {
        size[now]+=dfs1(to[i],now,dep+1);
        if(maxson<size[to[i]])
         son[now]=to[i],maxson=size[to[i]];
    }
    return size[now];
}
void dfs2(int now,int topx)
{
    id[now]=++tot;
    who[tot]=now;
    val[tot]=p[now];
    top[now]=topx;
    if(!son[now]) return;
    dfs2(son[now],topx);
    for(int i=head[now];i;i=net[i])
     if(!id[to[i]])
      dfs2(to[i],to[i]);
}
inline void update(int o)
{
    t[o].sum=(t[(o<<1)].sum+t[(o<<1)|1].sum);
    t[o].maxi=max(t[(o<<1)].maxi,t[(o<<1)|1].maxi);
}
inline void pushdown(int o)
{
    int adi=t[o].add;
    for(int i=0;i<=1;i++)
     t[(o<<1)+i].sum=(t[(o<<1)+i].sum+(t[(o<<1)+i].siz*adi)),t[(o<<1)+i].add=(t[(o<<1)+i].add+adi);
    t[o].add=0;
}
void build(int o,int l,int r)
{
    t[o].l=l,t[o].r=r,t[o].siz=r-l+1;
    if(l==r)
    {
        t[o].sum=t[o].maxi=val[l];
        return;
    }
    int mid=(l+r)>>1;
    build(lson),build(rson);
    update(o);
}
void adj(int o,int ql,int qr,int num)
{
    int l=t[o].l,r=t[o].r;
    if(ql<=l&&qr>=r)
    {
        t[o].sum=(t[o].sum+(t[o].siz*num));
        t[o].add=(t[o].add+num);
        return;
    }
    pushdown(o);
    int mid=(l+r)>>1;
    if(ql<=mid) adj((o<<1),ql,qr,num);
    if(qr>mid) adj((o<<1)|1,ql,qr,num);
    update(o);
}
inline void tree_x(int u,int v,int num)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]]) swap(u,v);
        adj(1,id[top[u]],id[u],num);
        u=fa[top[u]];
    }
    if(deep[u]<deep[v]) swap(u,v);
    adj(1,id[v],id[u],num);
}
inline int read()
{
    int x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9') 
    {
        if(ch=='-') w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
void print(int o,int l,int r)
{
    if(l==r)
    {
        ans[who[l]]=t[o].sum;
        return;
    }
    int mid=(l+r)>>1;
    pushdown(o);
    print((o<<1),l,mid);
    print((o<<1)|1,mid+1,r);
}
int main()
{   
    n=read();
    for(int i=1;i<=n;i++)
    {
         a[i].u=read();
         if(i!=1) sx[a[i].u]++;
    }
    
    for(int i=1,u,v;i<n;i++)
     u=read(),v=read(),add(u,v),add(v,u);
    dfs1(1,0,0),dfs2(1,1);
    build(1,1,tot);
    for(int i=2;i<=n;i++)
     tree_x(a[i-1].u,a[i].u,1);
    print(1,1,tot);
    for(int i=1;i<=n;i++)
     printf("%d\n",ans[i]-sx[i]);
    return 0;
}
```


---

## 作者：jzl_1210 (赞：1)

这道题目让我们来详细讲一讲树上差分吧。

# 前置知识
基础差分，[模板题点这](https://www.luogu.com.cn/problem/P2367)。\
最近公共祖先，[模板题点这](https://www.luogu.com.cn/problem/P3379)。


# 算法介绍
## 解决问题类型

在一棵树上有两个点 $u$ 和 $v$，每个点都有自己的点权，需要把在 $u$ 到 $v$ 的这条**简单路径上包含的所有的点**的点权同时加上 $z$ 或者减少 $z$。

这就是树上差分主要解决的问题。

## 实现

容易想到暴力，但是这样暴力修改点权的时间复杂度过高，所以不可取，这下，树上差分就派上用场了（别说什么线段树，树状数组，我不会）。

首先，能写到这题的人肯定已经学会了差分，如果不会请移步模板题。

这里的差分实现主要用图片来解释。

有这么一棵树（每个点旁边的数代表这个点的点权）：

![](https://cdn.luogu.com.cn/upload/image_hosting/cz7k30s2.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

现在接到任务，要把 $4$ 到 $8$ 的简单路径上的所有点（包含 $4$ 和 $8$）的点权加 $1$，问现在每个点的点权。

记 $cf_i$ 为点 $i$ 与点 $i-1$ 的点权差值。

我们先将 $4$ 到根结点，$8$ 到根结点中的点的点权全部加 $1$，用代码来表示为：

```cpp
cf[u]++;
cf[v]++;
```
修改完的结果如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/u88br33x.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

我们发现，结果并不是很理想。  
问题出在这么几个地方：  
+   $4$ 和 $8$ 的最近公共祖先，也就是 $3$ ，点权多了 $1$。
+   $3$ 的所有祖先结点的点权都多了 $2$。

我们先试着解决第一个问题，想到的方法是从 $3$ 开始，先把到后面的所有点的点权减去 $1$，用代码表示为：


```cpp
int lc = lca(u, v);
//lc存储u和v的最近公共祖先
cf[lc]--;
```
修改完后：

![](https://cdn.luogu.com.cn/upload/image_hosting/mlr2ejw9.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

可以发现，第一个问题已经解决了，此时还剩下的问题：  
+   $3$ 的所有祖先结点的点权都多了 $1$。

那么我们如法炮制，从 $3$ **的父亲**开始，把到后面的所有点的点权减去 $1$，用代码表示为：


```cpp
int lc = lca(u, v);
//f[i][j] 表示点i往上跳2^j次会到哪
cf[f[lc][0]]--;
```

现在修改完后变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ffkslsco.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

最后就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/wtg34wcs.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

现在是不是没有问题了，那么恭喜你~~被我恭喜到了~~学会了树上差分！

## 树上差分的优点
在实现上，简单，方便。  
在时间上，时间复杂度低，每次修改复杂度为 $O(1)$。

## 树上差分的注意事项

要用差分数组来求出原序列时，可以用搜索的方法。  
设点 $x$ 的孩子为 $y$，则求出 $cf_x$ 的代码为：

```cpp
cf[x] = cf[x] + cf[y];
```
需要注意：这一部分代码应该写在搜索的回溯时，要等 $cf_y$ 更新完了才能求出正确的 $cf_x$。

## 树上差分例题
[P3128](https://www.luogu.com.cn/problem/P3128)  
[P3258](https://www.luogu.com.cn/problem/P3258)

# 切入正题

这道题目想让我们干什么？其实就是把 $u$ 到 $v$ 的路径上的点的点权增加 $1$。

不过，需要注意的是，一个点 $x$ 可能既能作为上次参观的终点，也可能是下次参观的起点，需要避免重复。  
并且，最后一个房间不用给糖果。

学会了树上差分，这题就很简单了。

# 代码

终于要结束了（相信你们也看累了）。  
最近公共祖先的部分就不打注释了，不会的见模板题。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 5;
int n, dq[N], cf[N], cg[N], dep[N], f[N][18], lg[N], maxd, maxdq = -1;
vector <int> ed[N];
void dfs(int x, int fa){
	dep[x] = dep[fa] + 1;
	f[x][0] = fa;
	if(dep[x] > maxd) maxd = dep[x];
	for(int i = 0;i < ed[x].size();i++){
		int tod = ed[x][i];
		if(tod != fa){
			dfs(tod, x);
			cf[x] += cf[tod];
		}
	}
}
void qcf(int x, int fa){
	for(int i = 0;i < ed[x].size();i++){
		int tod = ed[x][i];
		if(tod != fa){
			dfs(tod, x);
			cf[x] += cf[tod];
		}
	}
}
int lca(int u, int v){
	if(dep[u] < dep[v]) swap(u, v);
	while(dep[u] > dep[v]){
		u = f[u][lg[dep[u] - dep[v]]];
	}
	if(u == v) return u;
	for(int i = lg[dep[u] - 1];i >= 0;i--){
		if(f[u][i] != f[v][i]){
			u = f[u][i], v = f[v][i];
		}
	}
	return f[u][0];
}
int main(){
	scanf("%d", &n);
	for(int i = 1;i <= n;i++){
		scanf("%d", &cg[i]);
	}
	for(int i = 1;i < n;i++){
		int x, y;
		scanf("%d%d", &x, &y);
		ed[x].push_back(y);
		ed[y].push_back(x);
	}
	dfs(1, 0);
	for(int i = 2;i <= n;i++) lg[i] = lg[i / 2] + 1;
	for(int j = 1;j <= lg[maxd];j++){
		for(int i = 1;i <= n;i++){
			f[i][j] = f[f[i][j - 1]][j - 1];
		}
	}
	//树上差分的部分 
	for(int i = 1;i < n;i++){
		int x = cg[i], y = cg[i + 1], lc;
		lc = lca(x, y);
		cf[x]++, cf[y]++;
		cf[lc]--, cf[f[lc][0]]--;
	}
	qcf(1, 0);
	//要注意避免重复 
	for(int i = 2;i <= n;i++){
		cf[cg[i]]--;
	}
	for(int i = 1;i <= n;i++){
		printf("%d\n", cf[i]);
	}
	return 0;
}
```

---

## 作者：wshl (赞：1)

- 题解：本题主要考查树链剖分。
- 简要题意：一颗树，有n个房间，并且有n-1根树枝连接。小熊维尼先去$a_1$，再去$a_2$最后到$a_n$，每走到一个房间，他就可以从房间拿一块糖果吃，最后一个房间不用，求每个房间至少需要放多少个糖果。
- 1.树链剖分：路过的点都加一，可以想到树链剖分，每一次将$a[i]$到$a[i+1]的节点加一，在一次修改后，因为最后一个房间不用加，所以避免重复终点要减1。
- 线段树模板区间加和区间查询。代码还是比较清楚的。
- 注意：本题数据较大，要用高效的读写(一般做这些题都要吧QwQ)，数组一定要开四倍！

代码如下：
```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
struct N
{
	int ans,lazy;
}t[1126666];
struct E
{
	int start,to;
}e[1266666];
int a[1266666],h[1266666],siz[1266666],son[1266666],d[1266666];
int id[1266666],rk[1266666],top[1266666],f[1266666];
int P,num,n,m;
void pushup(int p)
{
	t[p].ans=t[p*2].ans+t[p*2+1].ans;
	return ;
}
/*void build(int p,int l,int r)//不需要建树的
{
	if(l==r){t[p].ans=a[l];return ;}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	pushup(p);
}*/
void lai(int p,int l,int r)
{
	int mid=l+r>>1;
	if(t[p].lazy)
	{
		t[p*2].ans+=t[p].lazy*(mid-l+1);
		t[p*2+1].ans+=t[p].lazy*(r-mid);
		t[p*2].lazy+=t[p].lazy;
		t[p*2+1].lazy+=t[p].lazy;
		t[p].lazy=0;
	}
	return ;
}
void change(int p,int l,int r,int x,int y,int z)
{
	if(x<=l&&y>=r)
	{
		t[p].ans+=z*(r-l+1);
		t[p].lazy+=z;
		return ;
	}
	lai(p,l,r);
	int mid=l+r>>1;
	if(x<=mid)change(p<<1,l,mid,x,y,z);
	if(y>mid)change(p<<1|1,mid+1,r,x,y,z);
	pushup(p);
}
long long ask(int p,int l,int r,int x,int y)
{
	long long ans=0;
	if(x<=l&&y>=r)return t[p].ans;
	lai(p,l,r);
	int mid=l+r>>1;
	if(x<=mid)ans+=ask(p<<1,l,mid,x,y);
	if(y>mid)ans+=ask(p<<1|1,mid+1,r,x,y);
	return ans;
}
void add(int start,int to)
{
	e[++P].to=to;
	e[P].start=h[start];
	h[start]=P;
}
void dfs1(int p,int fa,int deep)
{
    f[p]=fa;siz[p]=1;d[p]=deep;
    for(int i=h[p];i;i=e[i].start)
	{
        int k=e[i].to;
        if(k==fa)continue;
        dfs1(k,p,deep+1);
        siz[p]+=siz[k];
        if(siz[k]>siz[son[p]])son[p]=k;
    }
}
void dfs2(int p,int tp)
{
	id[p]=++num;rk[num]=a[p];top[p]=tp;
    if(!son[p])return;
    dfs2(son[p],tp);
    for(int i=h[p];i;i=e[i].start)
	{
        int k=e[i].to;
        if(k==f[p]||k==son[p]) continue;
        dfs2(k,k);
    }
}
int sum(int x,int y,int z)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		change(1,1,n,id[top[x]],id[x],z);
		x=f[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	change(1,1,n,id[x],id[y],z);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n-1;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	//build(1,1,n);
	dfs1(1,0,1);dfs2(1,1);
	for(int i=1;i<=n-1;i++)
	{
        sum(a[i],a[i+1],1);
        sum(a[i+1],a[i+1],-1);
    }
    for(int i=1;i<=n;i++)
    printf("%d\n",ask(1,1,n,id[i],id[i]));
	return 0;
}```

---

## 作者：EarthGiao (赞：1)

## 【思路】

倍增/树链剖分 + 树上差分    
很有意思很有意思的一道题目     
会了树上差分几乎就是一个板子题      
不，是两个板子题     
倍增/树链剖分板子 + 树上差分板子    
先dfs出这棵树每个点的深度和他跳2^n之后会跳到哪一个点     
然后按照题目给出的到达房间的顺序     
找 $a_1$和 $a_2$的LCA, $a_2$ 和 $a_3$ 的LCA……     
然后运用树上差分     
将 $a_i$ 和 $a_i+1$ 的差分数组都加上1，    
然后将LCA和LCA夫妻的差分数组都减去1     

最后一个递归递归出每个店的值    
输出就好了      
注意：     
这里有n-1个点作为了起点也作为了终点     
所以重复了1次     
判断一下重复过的在输出的时候顺手减去1就好了      

## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;
const int Max = 300005;
struct node
{
	int y;
	int ne;
}s[Max << 1];
int a[Max];
int depth[Max];
int fa[Max][23];
int head[Max];
int sum = 0;
int c[Max];
int ans[Max];

void add(int x,int y)
{
	s[++ sum].y = y;
	s[sum].ne = head[x];
	head[x] = sum;
	
	s[++ sum].y = x;
	s[sum].ne = head[y];
	head[y] = sum;
}

void dfs(int f,int fath)
{
	depth[f] = depth[fath] + 1;
	fa[f][0] = fath;
	for(register int i = 1;(1 << i) <= depth[f];++ i)
		fa[f][i] = fa[fa[f][i - 1]][i - 1];
	for(int i = head[f];i != 0;i = s[i].ne)
		if(s[i].y != fath)
			dfs(s[i].y,f);
}

int lca(int x,int y)
{
	if(depth[x] < depth[y])swap(x,y);
	for(register int i = 22;i >= 0;i --)
		if(depth[fa[x][i]] >= depth[y])
			x = fa[x][i];
	if(x == y)return x;
	for(register int i = 22;i >= 0;i --)
		if(fa[x][i] != fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}

/*
void doit(int x)
{
	ans[x] = c[x];
	while(fa[x][0] != 0)
	{
		ans[fa[x][0]] += ans[x] + a[fa[x][0]];
		x = fa[x][0];
	}
}

void search(int x)
{
	int js = 0;
	for(register int i = head[x];i != 0;i = s[i].ne)
	{
		int qwq = s[i].y;
		if(qwq != fa[x][0])
		{
			js ++;
			ans[qwq] = ans[x] + c[qwq];
			search(qwq);
		}
	}
	if(js == 0)
		doit(x);
}
*/

int search(int x)
{
	ans[x] = c[x];
	for(register int i = head[x];i != 0;i = s[i].ne)
	{
		int qwq = s[i].y;
		if(qwq != fa[x][0])
			ans[x] += search(qwq);
	}
	return ans[x];
}
int main()
{
	freopen("1.in","r",stdin);
	freopen("1.out","w",stdout);
	int n;
	cin >> n;
	int x,y;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i];
	for(register int i = 1;i < n;++ i)
		cin >> x >> y,add(x,y);
	dfs(1,0);
	//fa[1][0] = 1;
	for(register int i = 1;i < n;++ i)
	{
		int LCA = lca(a[i],a[i + 1]);
		c[LCA] -= 1;c[fa[LCA][0]] -= 1;
		c[a[i]] ++;c[a[i + 1]] ++;
	}
	/*
	for(int i = 1;i <= n;++ i)
		cout << c[i] << endl;
	*/
	int acioi = search(1);
	for(register int i = 1;i <= n;++ i)
	{
		if(i == a[1])
			cout << ans[i] << endl;
		else
			cout << ans[i] - 1<< endl;
	}
	return 0;
```

---

## 作者：jins3599 (赞：1)

一眼树剖。

显然我们可以用树剖暴力模拟这个过程，支持区间修改和单点查询。

于是我就憨憨的写了一个线段树套树剖，结果...

![](https://cdn.luogu.com.cn/upload/image_hosting/oiwr1vqk.png)

果然线段树的常数还是太大了...还很难写

等等，区间修改单点查询？我为什么不用树状数组？？？

抱着试试的心态，结果就变成了这样

![](https://cdn.luogu.com.cn/upload/image_hosting/8cuhccs0.png)

树状数组nb！

$Code:$

线段树：
```cpp
n#include <bits/stdc++.h>
#define ls(x) x << 1
#define rs(x) x << 1 | 1 

using namespace std;

const int maxn = 300000 + 10;

struct Edge {
    int to , nxt;
}e[maxn << 1];

int n , a[maxn];
int head[maxn] , cnt;

void add(int u ,int v ) {
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}

int fa[maxn] , dep[maxn] , son[maxn] , size[maxn];
void dfs1(int now , int f) {
    fa[now] = f;
    size[now] = 1;
    dep[now] = dep[f] + 1;
    for(int i = head[now] ; i ; i = e[i].nxt) {
        int v = e[i].to;
        if(v == f) continue;
        dfs1(v , now);
        size[now] += size[v];
        if(size[son[now]] < size[v]) son[now] = v;
    }
}

int seg[maxn] ,top[maxn] , idx;
void dfs2(int now , int t) {
    top[now] = t;
    seg[now] = ++ idx;
    if(!son[now]) return;
    dfs2(son[now] , t);
    for(int i = head[now] ; i ; i = e[i].nxt) {
        int v = e[i].to;
        if(v == fa[now] || v == son[now]) continue;
        dfs2( v , v);
    }
}

struct Segment_Tree {
    int l , r , dis , add;
}t[maxn << 2];

void pushup(int x) {t[x].dis = t[ls(x)].dis + t[rs(x)].dis;}

void pushdown(int x) {
    int len1 = t[ls(x)].r - t[ls(x)].l + 1;
    int len2 = t[rs(x)].r - t[rs(x)].l + 1;
    t[ls(x)].dis += t[x].add * len1;
    t[rs(x)].dis += t[x].add * len2;
    t[ls(x)].add += t[x].add;
    t[rs(x)].add += t[x].add;
    t[x].add = 0;
}

void built(int x ,int l , int r) {
    t[x].l = l , t[x].r = r;
    if(l == r ) {t[x].dis = 0 ; return ;}
    int mid = (l + r) >> 1;
    built(ls(x) , l , mid); built(rs(x) , mid + 1 , r);
    pushup(x);
}

void updata(int x , int l ,int r , int w) {
    if(t[x].l >= l && t[x].r <= r) {
        t[x].dis += (t[x].r - t[x].l + 1) * w;
        t[x].add += w; return;
    }
    pushdown(x);
    int mid = (t[x].l + t[x].r) >> 1;
    if(l <= mid) updata(ls(x) , l , r , w);
    if(r > mid) updata(rs(x) , l ,r ,w);
    pushup(x);
}

int query(int x , int p) {
    if(t[x].l == t[x].r) {
        return t[x].dis;
    }
    pushdown(x);
    int mid = (t[x].l + t[x].r ) >> 1;
    if(p <= mid) return query (ls(x) , p);
    else return query(rs(x) , p);
    pushup(x);
}

void modify(int u , int v , int w) {
    while(top[u] != top[v]) {
        if(dep[top[u]] < dep[top[v]]) swap(u , v);
        updata(1 , seg[top[u]] , seg[u] ,w);
        u = fa[top[u]];
    }
    if(dep[u] > dep[v]) swap(u , v);
    updata(1 , seg[u] , seg[v] , w);
}

int main () {
    scanf("%d" ,&n);
    for(int i = 1 ; i <= n ; ++ i) scanf("%d" , a + i);
    for(int i = 1 ; i < n ; ++ i) {
        int u , v;
        scanf("%d%d" , &u , &v);
        add(u , v); add(v , u);
    }
    dfs1(1 , 1); dfs2(1 , 1); built(1 , 1 , n);
    for(int i = 1 ; i < n ; ++ i) {
    	//printf("%d -> %d \n" , a[i] , a [i + 1]);
    	modify(a[i] , a[i + 1] ,1) ,modify(a[i + 1] , a[i + 1] , -1);
	}
	for(int i = 1 ; i < n ; ++ i) printf("%d\n" , query(1 , seg[i]));
    printf("%d" , query(1 , seg[n]) );
    return 0;
}
```

树状数组:

```cpp
#include <bits/stdc++.h>
#define ls(x) x << 1
#define rs(x) x << 1 | 1 
#define lowbit(x) x & (-x)

using namespace std;

const int maxn = 300000 + 10;

struct Edge {
    int to , nxt;
}e[maxn << 1];

int n , a[maxn];
int head[maxn] , cnt;

void add(int u ,int v ) {
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}

int fa[maxn] , dep[maxn] , son[maxn] , size[maxn];
void dfs1(int now , int f) {
    fa[now] = f;
    size[now] = 1;
    dep[now] = dep[f] + 1;
    for(int i = head[now] ; i ; i = e[i].nxt) {
        int v = e[i].to;
        if(v == f) continue;
        dfs1(v , now);
        size[now] += size[v];
        if(size[son[now]] < size[v]) son[now] = v;
    }
}

int seg[maxn] ,top[maxn] , idx;
void dfs2(int now , int t) {
    top[now] = t;
    seg[now] = ++ idx;
    if(!son[now]) return;
    dfs2(son[now] , t);
    for(int i = head[now] ; i ; i = e[i].nxt) {
        int v = e[i].to;
        if(v == fa[now] || v == son[now]) continue;
        dfs2( v , v);
    }
}

int tree[maxn << 1];

void change (int x , int w) {
	while(x) {
		tree[x] += w;
		x -= lowbit(x);	
	}
}

void updata(int l ,int r , int w) {
    change(l - 1, -w);
    change(r , w);
}

int query(int p) {
	int ans = 0;
    while(p <= n) {
    	ans += tree[p];
    	p += lowbit(p);
	}
	return ans;
}

void modify(int u , int v , int w) {
    while(top[u] != top[v]) {
        if(dep[top[u]] < dep[top[v]]) swap(u , v);
        updata(seg[top[u]] , seg[u] ,w);
        u = fa[top[u]];
    }
    if(dep[u] > dep[v]) swap(u , v);
    updata(seg[u] , seg[v] , w);
}

int main () {
    scanf("%d" ,&n);
    for(int i = 1 ; i <= n ; ++ i) scanf("%d" , a + i);
    for(int i = 1 ; i < n ; ++ i) {
        int u , v;
        scanf("%d%d" , &u , &v);
        add(u , v); add(v , u);
    }
    dfs1(1 , 1); dfs2(1 , 1);
    for(int i = 1 ; i < n ; ++ i) {
    	//printf("%d -> %d \n" , a[i] , a [i + 1]);
    	modify(a[i] , a[i + 1] ,1) ,modify(a[i + 1] , a[i + 1] , -1);
	}
	for(int i = 1 ; i < n ; ++ i) printf("%d\n" , query(seg[i]));
    printf("%d" , query(seg[n]) );
    return 0;
}
```

---

## 作者：liuhanzhong (赞：1)

	~~第一次一遍ac省选题啊，好激动~~
    这题的思路其实很简单，很容易看出来属于树上差分
    这里我用的是 树链剖分+树上差分
    树上差分在处理一条路径x->y时：
    	con[x]和con[y]加1
       	con[lca(x,y)]和con[fa[lca(x,y)]]减1
        最后一遍dfs就可以从叶节点统计全树每个节点的经过次数
        （经过次数ans[n]=con[n]+n的子孙的全部con相加）
    但这题的路径是连续的，所以除起点和终点外，其他点会被同时算作起点和终点，所以最后只要把这些点的次数减1就可以了。

---

## 作者：xyz32768 (赞：1)

就是树上的路径更新问题。

一种做法是树剖，但是常数比较大。

现在介绍树上差分。

记差分数组$b[]$，如果第$u$个节点的权值为$val[u]$，则令$b[u]=val[u]-sigma(val[v])$，其中$v$为$u$的子节点。

那么很容易得到，第$u$个节点的权值就是$u$的子树和。

而如果对路径$(u,v)$的权值加上$x$，设$w$为$(u,v)$的$LCA$，那么只需要执行：

$b[u]+=x,b[v]+=x,b[w]-=x,b[fa[w]]-=x$。

但要注意这题里，路径的末尾（$v$）不需要更新。

这样最后，$DFS$一遍求得子树和即为答案。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 3e5 + 5, LogN = 23;
int n, a[N], ecnt, nxt[N << 1], adj[N], go[N << 1], fa[N][LogN],
dep[N], T[N], res[N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
void dfs(int u, int fu) {
    int i; dep[u] = dep[fu] + 1; for (i = 1; i <= 21; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int e = adj[u], v; e; e = nxt[e]) {
        if ((v = go[e]) == fu) continue;
        fa[v][0] = u; dfs(v, u);
    }
}
int lca(int u, int v) {
    int i; if (dep[u] < dep[v]) swap(u, v);
    for (i = 21; i >= 0; i--) {
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
        if (u == v) return u;
    }
    for (i = 21; i >= 0; i--) if (fa[u][i] != fa[v][i])
        u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
void change(int u, int v, int x) {
    int w = lca(u, v);
    T[u] += x; T[v] += x; T[w] -= x; T[fa[w][0]] -= x;
}
void dfs_ans(int u, int fu) {
    res[u] = T[u];
    for (int e = adj[u], v; e; e = nxt[e])
        if ((v = go[e]) != fu) dfs_ans(v, u), res[u] += res[v];
}
int main() {
    int i, x, y; n = read();
    for (i = 1; i <= n; i++) a[i] = read();
    for (i = 1; i < n; i++) {
        x = read(); y = read();
        add_edge(x, y); add_edge(y, x);
    }
    dfs(1, 0);
    for (i = 1; i < n; i++) change(a[i], a[i + 1], 1),
        change(a[i + 1], a[i + 1], -1); dfs_ans(1, 0);
    for (i = 1; i <= n; i++) printf("%d\n", res[i]);
    printf("\n");
    return 0;
}
```

---

## 作者：wdyhy (赞：1)

/\*
这个题就是考树上倍增和树上前缀和问题，

我们写意的去思考一下，根据访问顺序，在访问节点Ai~Ai+1的路径上每个点的答案要++

那么从Ai~Ai+1的路径上要经过它们的lca，这个需要O(1)修改，

那么就是树上前缀和了，sum数组是前缀和数组，

分类讨论一下，

1.访问到一个点p1，若下一个点p2需要往儿子下面找的话，那么lca就是这个点p1，那么就这样加：

          sum[p1]--; sum[p2]++;

2.访问到一个点p1，若下一个点p2需要往父亲上找的话，那么lca就是p2,那么就这样加：

sum[f[p2][0]]--; sum[f[p1][0]]++;//树上倍增f[i][j]表示从i往上跳2^j步到达的点

3.访问到一个点p1，若下一个点p2需要跨过p1,p2的lca的话，那么就这样加：

sum[lca]--; sum[f[lca][0]]--; sum[p1]++; sum[p2]++;

最后一些细节的话，手动脑补一下好了，样例给的非常良心~

最最后~%%%yts太神辣~~~

\*/






```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
struct edge{
    int to,next;
}mem[600060];
int n,m,father,x,y,num=0,p1,p2;
int fa[300060],head[300060],f[300060][30],g[300060],sum[300060],dep[300060],cnt[300060];
void init(int x,int y){
    num++;
    mem[num].to=y;
    mem[num].next=head[x];
    head[x]=num;
}
void dfs(int k,int pre){
    int u,s;
    for (int j=head[k];j;j=mem[j].next){
        u=mem[j].to;
        if (u==pre) continue;
        dep[u]=dep[k]+1; f[u][0]=k;
        for (int e=1;e<=30;e++){
            s=1<<e;
            if (s>dep[u]) break;
            f[u][e]=f[f[u][e-1]][e-1];
        }
        dfs(u,k);
    }
}
int lca(int x,int y){
    int k,tmp;
    if (dep[x]<dep[y]){
        tmp=x; x=y; y=tmp;
    }
    for (int e=30;e>=0;e--){
        if (dep[x]==dep[y]) break;
        k=1<<e;
        if (k>dep[x]-dep[y]) continue;
        x=f[x][e];
    }
    if (x==y) return x;
    for (int e=30;e>=0;e--){
        k=1<<e;
        if (k>dep[x]) continue;
        if (f[x][e]==f[y][e]) continue;
        x=f[x][e]; y=f[y][e];
    }
    return f[x][0];
}
void dfns(int k,int pre){
    int u;
    if (mem[head[k]].next==0&&k!=1){
        cnt[k]=sum[k];
        return;
    }
    for (int j=head[k];j;j=mem[j].next){
        u=mem[j].to;
        if (u==pre) continue;
        dfns(u,k);
        cnt[k]+=cnt[u];
    }
    cnt[k]+=sum[k];
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&g[i]);
    for (int i=1;i<n;i++){
        scanf("%d%d",&x,&y);
        init(x,y);
        init(y,x);
    }
    dfs(1,0);
    father=lca(g[1],g[2]);
    sum[g[1]]++; sum[g[2]]++;
    sum[father]--; sum[f[father][0]]--;
    for (int i=2;i<n;i++){
        p1=g[i]; p2=g[i+1];
        father=lca(p1,p2);
        if (father==p1||father==p2){
            if (father==p1){
                sum[p2]++;
                sum[p1]--;
            }
            if (father==p2){
                sum[f[p1][0]]++;
                sum[f[p2][0]]--;
            }
            continue;
        }
        sum[f[p1][0]]++; sum[p2]++;
        sum[father]--;
        sum[f[father][0]]--;
    }
    dfns(1,0); 
    for (int i=1;i<=n;i++){
        if (i==g[n]) cnt[i]--;
        printf("%d\n",cnt[i]);
    }
    return 0;
}
```

---

## 作者：NOILinux_Ubuntu (赞：1)

 	这题就是一个纯的树上差分
  
  用倍增找两个点的lca，然后++这两个点的权值,--lca权值和fa[lca][0]的权值；	
  用拓扑序将差分的值加上去
  最后对于a2~an，--其值来去重
 ```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
#define Int int
#define ri register Int
#define For(i,a,b) for(ri i=(a);i<=(b);++i)
#define DFor(i,a,b) for(ri i=(a);i>=(b);--i)
#define Max(a,b) ((a)>(b)?(a):(b))
#define Min(a,b) ((a)<(b)?(a):(b))
#define MAXN 300000
Int n;
Int head[MAXN+5],t;
Int a[MAXN+5];
Int fa[MAXN+5][22];
Int b[MAXN+5],dep[MAXN+5];
Int c[MAXN+5],out[MAXN+5],s[MAXN+5];
struct node{
 Int u,v,nxt;
}e[2*MAXN+5];
void read(Int &x){
 char ch=getchar();
 x=0;
   while(ch<'0'||ch>'9')ch=getchar();
   while(ch>='0'&&ch<='9'){
	x=(x<<3)+(x<<1)+(ch^48);
	ch=getchar();
   }
  return;
}
void add(Int u,Int v){
 ++t;
 e[t].u=u;e[t].v=v;
 e[t].nxt=head[u];head[u]=t;
}
queue<Int> q; 
void bfs(){
 q.push(1);b[1]=1;dep[1]=1;
  while(!q.empty()){
   Int u=q.front();q.pop();
    for(ri i=head[u];i;i=e[i].nxt){
     Int v=e[i].v;
      if(!b[v]){
       dep[v]=dep[u]+1;
       fa[v][0]=u;
       b[v]=1;
       ++out[u];
       q.push(v);
      }
    }
  }
}
//bfs找父亲和建深度
void lca(){
 For(i,1,20)
  For(j,1,n)
  fa[j][i]=fa[fa[j][i-1]][i-1];
}
void cf(){
 For(i,1,n)
  if(!out[i])q.push(i);
   while(!q.empty()){
    Int u=q.front();q.pop();
    s[u]+=c[u];
     --out[fa[u][0]];
     s[fa[u][0]]+=s[u];
     if(!out[fa[u][0]])q.push(fa[u][0]);
   }
}
//拓扑序
int main(){
  read(n);
  For(i,1,n)read(a[i]);
  Int u,v,w;
  For(i,1,n-1)read(u),read(v),add(u,v),add(v,u);
  bfs();lca();
  For(i,1,n-1){
   Int u=a[i],v=a[i+1],lcf;
    if(dep[u]<dep[v])swap(u,v);
     DFor(j,20,0)
	  if(dep[fa[u][j]]>=dep[v]) u=fa[u][j];
     if(u!=v){
      DFor(j,20,0){
       if(fa[u][j]==fa[v][j])continue;
       u=fa[u][j],v=fa[v][j];
      }
      lcf=fa[u][0];
     }
     else lcf=u;
     ++c[a[i]];--c[fa[lcf][0]];++c[a[i+1]];--c[lcf];
  }
  cf();
   For(i,2,n)--s[a[i]];
   For(i,1,n)printf("%d\n",s[i]);
 return 0;
}
 ```

---

## 作者：szbszb (赞：0)

这是树剖的模板题了吧……

题目要求我们维护一棵树，进行路径修改和单点查询。

如果不会树链剖分的话请点[这里](https://www.cnblogs.com/szbszb/p/11624130.html)

考虑实现方法：

首先，我们想到直接对每条路径上的每一个点加一就可以了，最后一个点-1，这样好像就算做出来了。

但是！我们仔细想想可以发现，每一个路径的终点又是下条路径的起点，而我们对其修改了两遍，所以这个算法就有问题了

博主想到了两种解题方法

1、对每条路径修改后，将终点的值减一：这样的话，就不存在重复覆盖的问题了，而且这也恰好符合了终点要-1的情况。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long max1,n,m,r1,p,q,x,y,k,i,c[4000001],siz[1000001],id[1000001],son[1000001],l[4000001],r[4000001],a[1000001],w[1000001],cnt,z[4000001],he[1000001],ne[2000001],to[2000001],top[1000001],d[1000001],f[1000001];
void did1(long long u,long long fat,long long deep)
{
	d[u]=deep;
	f[u]=fat;
	siz[u]=1;
	for (long long i=he[u];i;i=ne[i])
	{
		long long v=to[i];
		if (v==f[u]) continue;
		did1(v,u,deep+1);
		if (siz[v]>siz[son[u]]) son[u]=v;
		siz[u]+=siz[v];
	}
}
void did2(long long u,long long t)
{
	top[u]=t;
	id[u]=++cnt;
	if (!son[u]) return;
	did2(son[u],t);
	for (long long i=he[u];i;i=ne[i])
	{
		long long v=to[i];
		if (v==f[u]||v==son[u]) continue;
		did2(v,v);
	}
}
void xiafang(long long u)
{
	z[u*2]+=c[u]*(r[u*2]-l[u*2]+1);
	z[u*2+1]+=c[u]*(r[u*2+1]-l[u*2+1]+1);
	c[u*2]+=c[u];
	c[u*2+1]+=c[u];
	c[u]=0;
}
void build(long long u,long long l1,long long r1)
{
	l[u]=l1;
	r[u]=r1;
	if (l1==r1)
		return;
	build(u*2,l1,(l1+r1)/2);
	build(u*2+1,(l1+r1)/2+1,r1);
	z[u]=(z[u*2]+z[u*2+1]);
}
void jia(long long u,long long l1,long long r1,long long k)
{
	if (l[u]>r1||r[u]<l1) return;
	if (l[u]>=l1&&r[u]<=r1)
	{
		z[u]=(z[u]+k*(r[u]-l[u]+1));
		c[u]+=k;
		return;
	}
	xiafang(u);
	jia(u*2,l1,r1,k);
	jia(u*2+1,l1,r1,k);
	z[u]=(z[u*2]+z[u*2+1]);
}
long long qui(long long u,long long l1,long long r1)
{
	if (l[u]>r1||r[u]<l1) return 0;
	if (l[u]>=l1&&r[u]<=r1) return z[u];
	xiafang(u);
	return (qui(u*2,l1,r1)+qui(u*2+1,l1,r1));
}
void jiapro(long long x,long long y,long long k)
{
	while(top[x]!=top[y])
	{
		if (d[top[x]]<d[top[y]]) swap(x,y);
		jia(1,id[top[x]],id[x],k);
		x=f[top[x]];
	}
	if (d[x]>d[y]) swap(x,y);
	jia(1,id[x],id[y],k); 
}
long long quipro(long long x,long long y)
{
	long long ans=0;
	while(top[x]!=top[y])
	{
		if (d[top[x]]<d[top[y]]) swap(x,y);
		ans=(ans+qui(1,id[top[x]],id[x]));
		x=f[top[x]];
	}
	if (d[x]>d[y]) swap(x,y);
	ans=(ans+qui(1,id[x],id[y]));
	return ans;
}
void jiason(long long x,long long k)
{
	jia(1,id[x],id[x]+siz[x]-1,k);
}
long long quison(long long x)
{
	return qui(1,id[x],id[x]+siz[x]-1);
}
int main()
{
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for (i=1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		cnt++;
		ne[cnt]=he[x];
		to[cnt]=y;
		he[x]=cnt;
		cnt++;
		ne[cnt]=he[y];
		to[cnt]=x;
		he[y]=cnt;
	}
	cnt=0;
	did1(1,0,1);
	did2(1,1);
	build(1,1,n);
	for (i=1;i<n;i++)
	{
		jiapro(a[i],a[i+1],1);
		jiapro(a[i+1],a[i+1],-1);//将终点的值-1
	}
	for (i=1;i<=n;i++)
		printf("%lld\n",qui(1,id[i],id[i]));//直接求出每个点的糖果数
	return 0;
}
```
这是能AC的。

2、将除一号点以外的所有点权-1。

原理证明：除一号点、终点以外的所有点都被当成了路径终点1次、起点1次，而终点本因-1，所以也是正确的（但博主没试过，代码写好了没交）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long max1,n,m,r1,p,q,x,y,k,i,c[4000001],siz[1000001],id[1000001],son[1000001],l[4000001],r[4000001],a[1000001],w[1000001],cnt,z[4000001],he[1000001],ne[2000001],to[2000001],top[1000001],d[1000001],f[1000001];
void did1(long long u,long long fat,long long deep)
{
	d[u]=deep;
	f[u]=fat;
	siz[u]=1;
	for (long long i=he[u];i;i=ne[i])
	{
		long long v=to[i];
		if (v==f[u]) continue;
		did1(v,u,deep+1);
		if (siz[v]>siz[son[u]]) son[u]=v;
		siz[u]+=siz[v];
	}
}
void did2(long long u,long long t)
{
	top[u]=t;
	id[u]=++cnt;
	if (!son[u]) return;
	did2(son[u],t);
	for (long long i=he[u];i;i=ne[i])
	{
		long long v=to[i];
		if (v==f[u]||v==son[u]) continue;
		did2(v,v);
	}
}
void xiafang(long long u)
{
	z[u*2]+=c[u]*(r[u*2]-l[u*2]+1);
	z[u*2+1]+=c[u]*(r[u*2+1]-l[u*2+1]+1);
	c[u*2]+=c[u];
	c[u*2+1]+=c[u];
	c[u]=0;
}
void build(long long u,long long l1,long long r1)
{
	l[u]=l1;
	r[u]=r1;
	if (l1==r1)
		return;
	build(u*2,l1,(l1+r1)/2);
	build(u*2+1,(l1+r1)/2+1,r1);
	z[u]=(z[u*2]+z[u*2+1]);
}
void jia(long long u,long long l1,long long r1,long long k)
{
	if (l[u]>r1||r[u]<l1) return;
	if (l[u]>=l1&&r[u]<=r1)
	{
		z[u]=(z[u]+k*(r[u]-l[u]+1));
		c[u]+=k;
		return;
	}
	xiafang(u);
	jia(u*2,l1,r1,k);
	jia(u*2+1,l1,r1,k);
	z[u]=(z[u*2]+z[u*2+1]);
}
long long qui(long long u,long long l1,long long r1)
{
	if (l[u]>r1||r[u]<l1) return 0;
	if (l[u]>=l1&&r[u]<=r1) return z[u];
	xiafang(u);
	return (qui(u*2,l1,r1)+qui(u*2+1,l1,r1));
}
void jiapro(long long x,long long y,long long k)
{
	while(top[x]!=top[y])
	{
		if (d[top[x]]<d[top[y]]) swap(x,y);
		jia(1,id[top[x]],id[x],k);
		x=f[top[x]];
	}
	if (d[x]>d[y]) swap(x,y);
	jia(1,id[x],id[y],k); 
}
long long quipro(long long x,long long y)
{
	long long ans=0;
	while(top[x]!=top[y])
	{
		if (d[top[x]]<d[top[y]]) swap(x,y);
		ans=(ans+qui(1,id[top[x]],id[x]));
		x=f[top[x]];
	}
	if (d[x]>d[y]) swap(x,y);
	ans=(ans+qui(1,id[x],id[y]));
	return ans;
}
void jiason(long long x,long long k)
{
	jia(1,id[x],id[x]+siz[x]-1,k);
}
long long quison(long long x)
{
	return qui(1,id[x],id[x]+siz[x]-1);
}
int main()
{
	scanf("%lld",&n);
	for(i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for (i=1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		cnt++;
		ne[cnt]=he[x];
		to[cnt]=y;
		he[x]=cnt;
		cnt++;
		ne[cnt]=he[y];
		to[cnt]=x;
		he[y]=cnt;
	}
	cnt=0;
	did1(1,0,1);
	did2(1,1);
	build(1,1,n);
	for (i=1;i<n;i++)
		jiapro(a[i],a[i+1],1);
    printf("%lld\n",qui(1,id[1],id[1]));
    for (i=2;i<=n;i++)
		printf("%lld\n",qui(1,id[i],id[i])-1);
	return 0;
}
```
没试过，也许是对的？也许哪里写出锅了？不过思想应该是对的，上面的代码不保证正确，如果有兴趣的同学可以自己尝试用我那个算法试试。

调慢了时间复杂度，复制代码无法AC（当然你优化我也不拦你）

---

## 作者：Ryan_ (赞：0)

**解题思路：**这题我的做法是lca+树上差分，应该已经有很多人发过类似的题解了

但感觉我写的更容易理解？~~也许是我太菜了pa~~ =。=

~~大佬绕行~~

# 先简单介绍一下树上差分



------------

像差分一样，树上差分也有前缀和思想 
**一个点的真实权值是一个点子树内所有差分后的权值之和**（额，有点拗口没关系） 
总的来说就是一个点的差分数组最后的值是整个子树内差分数组的和，再加进点的权值里

所以怎么差分呢 
先抛出一个问题：给你m个操作，问你每次在(p,q)路径上给所有点的权值+1，问你最后点的权值情况（时间复杂度：请你尽量跑得快） 
我们考虑差分，时刻记住上面的那句加粗的话


```
首先在p上面对差分数组+1，再在q上面对差分数组+1，在Lca(p,q)处对差分数组-1
```


我们根据上面所说的方法统计一遍子树差分数组和，就会发现正如所想 
那么我们就可以推广到所有的情况了是吧 
显然这样差分的修改复杂度是(O(logn))的(求Lca)，只要最后再一边扫就是吧 
你甚至可以Tarjan用求来优化掉每次修改的时候查的那个logn


------------
# 总结一下

树上差分主要用于求解一些树上的路径问题

它通过利用树的一些性质，用一个差分数组来实现对一条路径的操作，这涉及到路径的 起，终点 与lca。

一般情况下：一个点的真实权值为其所在子树内所有点的差分数组的值的和

树上差分一般不适用于询问和操作嵌套的题目，这时一般用树链剖分解决



------------
# 题目推荐
luoguP3128 [USACO15DEC]最大流Max Flow     板子题

luoguP3258 [JLOI2014]松鼠的新家                      板子题

luoguP2680 运输计划                                   题解 有难度

可以挑战一下天天爱跑步。。。 



------------
回到这道题，其实就是一道树上差分模板题，要注意的除去起点外的点的差分数组的值要减去1（去重），同时有一个细节要注意，链式前向星模拟链表，数组要开两倍（存的是双向边，我因为这个卡了很久，~~我真菜~~）

```
#include<bits/stdc++.h>
#define maxn 600010
using namespace std;
int nxt[maxn],go[maxn],first[maxn],tot=0,f[300010][31],cf[300010],dep[300010],sum=0,hh[300010];
inline void Deal_work(int u,int father){
	dep[u]=dep[father]+1;
	for(int i=0;i<=19;i++)f[u][i+1]=f[f[u][i]][i];
	for(int i=first[u];i;i=nxt[i]){
		int v=go[i];
		if(v==father)continue;
		f[v][0]=u;
		Deal_work(v,u);
	}
}
inline int LCA(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=20;i>=0;i--){
		if(dep[f[x][i]]>=dep[y])x=f[x][i];
		if(x==y)return x;
	}
	for(int i=20;i>=0;i--){
		if(f[x][i]!=f[y][i]){
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
void add(int x,int y){
	nxt[++tot]=first[x];first[x]=tot;go[tot]=y;
}

inline void Get(int u,int father){
	for(int i=first[u];i;i=nxt[i]){
		int v=go[i];
		if(v==father)continue;
		Get(v,u);
		cf[u]+=cf[v];
	}
}
int main() {
	int a[300001];
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n-1;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		hh[x]++,hh[y]++;
		add(x,y);add(y,x);
	}
	Deal_work(1,0);
	for(int i=1;i<n;i++){
		int lca=LCA(a[i],a[i+1]);
		++cf[a[i]];++cf[a[i+1]];--cf[lca];--cf[f[lca][0]];
	}
	Get(1,0);
	for(int i=2;i<=n;i++){
		cf[a[i]]--;
	}
	for(int i=1;i<=n;i++)printf("%d\n",cf[i]);
	return 0;
}
```


---

## 作者：Unaccepted (赞：0)

[一只松鼠和一只熊的友♂谊](https://www.luogu.org/problemnew/show/P3258)

[蒟蒻的blog](https://www.luogu.org/blog/zgj-bloom/)

据说有$dalao$用树链剖分裸过~~蒟蒻瑟瑟发抖~~

## 题目大意

小熊维按顺序从$a1$走到$an$，每到一个房间就在这个房间拿一个糖，求每个房间最少放几个糖果$?$

## 题目分析

其实想一下就能明白，就是$n-1$条路径，求每个点被覆盖了几次。

但是这样做正确性是有问题的，因为对于第$i-1$条路径和第$i$条路径，它们是首尾相连的，但是它们相连的那个点被算了两次，所以答案要全$-1$。

#### 然后你就**WA**了(~~迅速逃跑~~)

因为对于a1来说，它明明只被加了一次，但是却被我们~~无差别攻击~~进行了特判，所以应该是$a2$————$an$减一。

但是怎么操作呢？

这就用到了算法————树上差分

在了解树上差分之前，首先要了解一个简单点的东西

## 差分数组

对于数组$a$，我们建立差分数组$f$,$f[i]=a[i]-a[i-1]$

那么我们发现性质$:$

$f[i]$前缀和就等于$a[i]$，即$a[i]=sigma(x∈[1,i]) f[i]$

不使用差分数组时，一旦对$a[i]$进行更改，那么a[i]的前缀和数组就要更改$i$个，时间复杂度为$O(n)$

那么就要用到差分数组的另外一个性质$:$

$sigma(x∈[1,i]) a[i]$ (就是$a[i]$的前缀和)$= sigma(x∈[1,i]) (i-x+1)*f[i]$

所以在更改$[l,r]$区间时，只需要更改$f[l-1]$和$f[r]$就行了，那么两个树状数组就能解决问题了。

然后就可以到这道题需要的算法了

## 树上差分

就是在树上进行差分，至于$a[i]$……就是$i$节点的子树和啦!

## 回到这道题

对于每条链$x,y$，我们求出$x$和$y$的$lca$，将$x$到$lca$和$y$到$lca$分别打上差分。

但是这样有一些问题……

$lca$被计算了两次!那么只要$lca$不是根节点，我们就只将$lca$打一次差分，另一次差分打在$lca$的父亲上就行了。

~~奉上蒟蒻的代码~~

## 代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 300010
#define LOG 20
#define ll long long
using namespace std;
struct E
{
	ll v,next;
}edge[N*2];
ll n,tot;
ll indexx[N],dep[N],ans[N],s[N],point[N];
ll father[N][LOG];
void addedge(ll x,ll y)    //前向星建图 
{
	edge[++tot].v=y;
	edge[tot].next=indexx[x];
	indexx[x]=tot;
	return;
}
void dfs(ll x,ll fa)     //倍增搜索 
{
    for(ll i=indexx[x];i>=1;i=edge[i].next)
    {
        ll v=edge[i].v;
        if(v==fa) continue;
    	father[v][0]=x;
        dep[v]=dep[x]+1;
        dfs(v,x);
    }
    return;
}
ll getlca(ll x,ll y)    //倍增函数 
{
    ll cnt=1;
    if(dep[x]<dep[y]) swap(x,y);
    for(ll i=LOG-1;i>=0;i--)
        if(dep[father[x][i]]>=dep[y])
            x=father[x][i];
    if(x==y) return x;
    for(ll i=LOG-1;i>=0;i--)
    {
        if(father[x][i]!=father[y][i]) 
        {
            x=father[x][i];
            y=father[y][i];
        }
        else cnt=father[x][i];
    }
    return cnt;
}
void getans(ll x,ll fa)      
{
	for(ll i=indexx[x];i>=1;i=edge[i].next)
	{
		ll v=edge[i].v;
		if(v==fa) continue;
		getans(v,x);
		ans[x]+=ans[v];
	}
	ans[x]+=s[x];
}
int main()
{
	freopen("squirrel.in","r",stdin);
	freopen("squirrel.out","w",stdout);
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++) scanf("%lld",&point[i]);
	for(ll i=1;i<=n-1;i++)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		addedge(x,y);
		addedge(y,x);
	}
	dep[1]=1;
    dfs(1,0);      //倍增DFS 
    for(ll j=1;j<=LOG-1;j++)
        for(ll i=1;i<=n;i++)
            father[i][j]=father[father[i][j-1]][j-1];  //倍增father 
	for(ll i=1;i<=n-1;i++)
	{
		ll lca=getlca(point[i],point[i+1]);    //求出lca 
		s[point[i]]++;
		s[point[i+1]]++;
		s[lca]--;
		if(lca!=1) s[father[lca][0]]--;			//打上差分 
	}
	getans(1,0);                //计算子树和 
	for(ll i=1;i<=n;i++) ans[i]--;
	ans[point[1]]++;			//除了a[1]都-1 
	for(ll i=1;i<=n;i++) printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：kkxhh (赞：0)

### 树上差分

其实不必把点上差分转成边上差分，只要每次操作时在 $a_{i}$ 和 $fa[a_{i+1}]$ 处加 $1$ 在 $lca$ $fa[lca]$ 处减 $1$ 然后从低到上累加统计答案就好了

代码如下

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef struct edge{
    int next,to;
}edge;

edge e[600010];
int n,head[300010],et,dt,fa[300010],dfn[300010],top[300010],son[300010],dep[300010],siz[300010],a[300010],ans[300010];

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

void addedge(int u,int v){
    e[++et].to=v; e[et].next=head[u]; head[u]=et;
    e[++et].to=u; e[et].next=head[v]; head[v]=et;
}

void dfs1(int x){
    siz[x]=1;
    for(int i=head[x],to;i;i=e[i].next){
        to=e[i].to;
        if(to==fa[x]) continue;
        dep[to]=dep[x]+1; fa[to]=x;
        dfs1(to);
        siz[x]+=siz[to];
        if(siz[to]>siz[son[x]]) son[x]=to;
    }    
}

void dfs2(int x,int t){
    dfn[x]=++dt; top[x]=t;
    if(son[x]) dfs2(son[x],t);
    for(int i=head[x],to;i;i=e[i].next){
        to=e[i].to;
        if(to==fa[x] || to==son[x]) continue;
        dfs2(to,to);
    }
}

void dfs3(int x){
    for(int i=head[x],to;i;i=e[i].next){
        to=e[i].to;
        if(to==fa[x]) continue;
        dfs3(to); ans[x]+=ans[to];
    }
}

int lca(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]>dep[top[y]]) x=fa[top[x]];
        else y=fa[top[y]];
    }
    return ((dep[x]<dep[y])?x:y);
}

int main(){
    n=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read();
        addedge(u,v);
    }
    dfs1(1); dfs2(1,1);
    for(int i=1;i<n;i++){
        int l=lca(a[i],a[i+1]);
        ans[a[i]]++; ans[fa[a[i+1]]]++;
        ans[l]--; ans[fa[l]]--;
    }
    dfs3(1);
    for(int i=1;i<=n;i++) printf("%d\n",ans[i]);
}

```

---

## 作者：decoqwq (赞：0)

$LCT$裸题

我们每次走到下一个结点，相当于在上一个结点到这个结点间拉出一条链，然后打加法标记

其他的就基本都是$LCT$板子了

要注意的几个细节：

我们每次记录上一个点的时候，一开始要设置为$0$

每次为了避免麻烦，我们先将当前点的值$-1$，再直接给整条链打标记

最后一个点一定不要忘了减$1$

然后我本来想的是直接从$1$到$n$输出值，后面发现不行，这样子的话很多标记没有下放，所以我们直接对每个点$makeroot$之后再输出他的值就可以了

~~不吸氧只有70~~

提供我的大常数$LCT$代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 300010
int ch[maxn][2],f[maxn],rev[maxn],key[maxn],tag[maxn];
int ord[maxn];
int get(int x)
{
	return ch[f[x]][1]==x;
}
int isroot(int x)
{
	return ch[f[x]][1]!=x&&ch[f[x]][0]!=x;
}
void pushdown(int x)
{
	if(rev[x])
	{
		swap(ch[x][0],ch[x][1]);
		rev[ch[x][1]]^=1;
		rev[ch[x][0]]^=1;
		rev[x]=0;
	}
	if(tag[x])
	{
		key[x]+=tag[x];
		tag[ch[x][0]]+=tag[x];
		tag[ch[x][1]]+=tag[x];
		tag[x]=0;
	}
}
void rotate(int x)
{
	int old=f[x],oldf=f[old],which=get(x);
	if(!isroot(old))
	{
		ch[oldf][get(old)]=x;
	}
	ch[old][which]=ch[x][which^1];
	f[ch[old][which]]=old;
	ch[x][which^1]=old;
	f[old]=x;
	f[x]=oldf;
}
void splay(int x)
{
	stack<int> st;
	st.push(x);
	for(int fa=x;!isroot(fa);fa=f[fa])
	{
		st.push(f[fa]);
	} 
	while(!st.empty())
	{
		pushdown(st.top());
		st.pop();
	}
	for(int fa=f[x];!isroot(x);rotate(x),fa=f[x])
	{
		if(!isroot(fa))
		{
			rotate(get(fa)==get(x)?fa:x);
		}
	}
}
void access(int x)
{
	for(int y=0;x;x=f[y=x])
	{
		splay(x);
		ch[x][1]=y;
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rev[x]^=1;
}
void link(int x,int y)
{
	makeroot(x);
	f[x]=y;
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&ord[i]);
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		link(x,y);
	}
	int now=0;
	for(int i=1;i<=n;i++)
	{
		if(!now)
		{
			key[ord[i]]=1;
			now=ord[i];
			continue;
		}
		key[now]--;
		makeroot(now);
		access(ord[i]);
		splay(ord[i]);
		tag[ord[i]]++;
		now=ord[i];
	}
	key[ord[n]]--;
	for(int i=1;i<=n;i++)
	{
		makeroot(i);
		printf("%d\n",key[i]);
	}
}
```

---

## 作者：Mr_Wu (赞：0)

这是一个很奇怪的解法。。

---

**题意**

给你一颗树，并给你一个任务，长度为$N$，要求按这个任务在树上走，并将走过的节点权值+1，最后求出每个点的权值

---

首先我看到这题时想到了树剖+线段树。。在树上加权值，并进行询问，很自然就联想到了。。

然后就开始码，码到一半发现复杂度好像不对劲，算了一下$300000*\log_2^2{300000}$大概是$100000000$。。然后就十分崩溃

然后就抱着试一试的心态继续写下去

然后线段树写完突然发现一个事实

> 题目实际上可以转化为在序列上区间加，单点查询

> 而且..似乎是修改在前，查询在后？

于是就想到了普通的序列差分方法，然后就把码完的线段树删了。。

并没有想到可以在树上直接差分。。而且我也不会qaq

---

**思路**

将树剖分完后树变成一个序列

并对每次在树上走的操作变成在序列上操作，并用差分维护

时间复杂度$O(nlogn)$

---

**Code**

```cpp
#include <cstdio>

#define MAXN 300005
typedef long long ll;
typedef unsigned long long ull;
#define min(a, b) ((a < b) ? (a) : (b))
#define max(a, b) ((a > b) ? (a) : (b))

inline ll read()
{
    char c = getchar();
    ll ret = 0, t = 1;
    while ((c < '0' || c > '9') && c != '-') c = getchar();
    if (c == '-') t = -1, c = getchar();
    while (c >= '0' && c <= '9') ret = (ret << 3) + (ret << 1) + c - '0', c = getchar();
    return ret * t;
}
void swap(int& a, int& b)
{
    int t = a;
    a = b, b = t;
}

struct node
{
    int v, next;
}E[MAXN << 1];
int Elen, head[MAXN], dep[MAXN], N;
int fa[MAXN], size[MAXN], wson[MAXN], top[MAXN], id[MAXN], wid[MAXN], cnt;
//这是一只树链剖分需要的数组
int task[MAXN];
ll s[MAXN], ans[MAXN];

void add(int u, int v)
{
    ++Elen, E[Elen].v = v, E[Elen].next = head[u], head[u] = Elen;
}
void dfs1(int u, int ff) //第一次dfs，处理dep, father, size, wson
{
    dep[u] = dep[ff] + 1, fa[u] = ff, size[u] = 1;
    int i;
    for (i = head[u]; i; i = E[i].next)
    {
        if (E[i].v != ff)
        {
            dfs1(E[i].v, u);
            size[u] += size[E[i].v];
            if (size[E[i].v] > size[wson[u]]) wson[u] = E[i].v;
        }
    }
}
void dfs2(int u, int ff, int tp)
//第二次dfs处理了重链顶top，并建立了树节点和序列的相互映射
//（id是树->序列，wid是序列->树）
{
    top[u] = tp, id[u] = ++cnt, wid[cnt] = u;
    if (wson[u]) dfs2(wson[u], u, tp);
    int i;
    for (i = head[u]; i; i = E[i].next) if (E[i].v != ff && E[i].v != wson[u]) dfs2(E[i].v, u, E[i].v);
}

void modify(int L, int R, int k)
{
    s[L] += k, s[R + 1] -= k;
} //在序列上差分
void qwq(int u, int v, int k) 
//树链剖分的作用，将树变成序列并在重链上跑，复杂度logn
{
    while (top[u] != top[v])
    {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        modify(id[top[u]], id[u], k); //不是用线段树而是差分维护
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    modify(id[u], id[v], k);
}
int main()
{
    N = read();
    int i, j, u, v;
    for (i = 1; i <= N; ++i) task[i] = read(); //task[i]表示在树上走的任务
    for (i = 1; i < N; ++i)
    {
        u = read(), v = read();
        add(u, v), add(v, u);
    }
    dfs1(1, 0);
    dfs2(1, 0, 1);
    modify(id[task[1]], id[task[1]], 1); //原因下面说
    modify(id[task[N]], id[task[N]], -1); //题意中说了终点不用加权值
    for (i = 2; i <= N; ++i)
    {
        qwq(task[i - 1], task[i], 1); //修改(task[i-1],task[i])
        modify(id[task[i - 1]], id[task[i - 1]], -1);
        //考虑到task[i-1]在上一次操作中算过了，就将其再减去一个1
        
        /*上面的modify(id[task[1]], id[task[1]], 1);是因为
        在操作过程中task[1]会被减去一个1
        而他并没有被上一次操作算过，需要加上*/
    }
    for (i = 1; i <= N; ++i) s[i] += s[i - 1];
    //差分数组的前缀和就是点的权
    for (i = 1; i <= N; ++i) ans[wid[i]] = s[i]; //将序列在转到树上
    for (i = 1; i <= N; ++i) printf("%lld\n", ans[i]);
    return 0;
}
```

---

## 作者：arfa (赞：0)

不知道那位 $Pascal$ 的仁兄是怎么想的,不用修改为什么要打树剖? 为什么要打线段树?

还是先简化一下题面:

- 给你一棵树
- 给你 $N$ 个点,要你对每一个 $node_i$ 到 $node_{i+1}$ 的树上路径的点权全部 $+1$。
- 最后输出每一个点的点权

带着打树剖的情绪,发现时间复杂度为 $O(N \log^2 N)$。显然不用修改,并不需要树剖。现在我们需要一个可以**直接修改**,且可以**最后查询**的数据结构 (或者某种方法)。很容易想到可以差分。

先说差分数组,如果我们给出 $M$ 个修改,在一个区间加上一个数字。最后问你这个序列是多少。先举一个例子:

```
原数组   : 3 4 9 2 3 (num)
差分数组 : 3 1 5 -7 1 (sum)
```

很显然差分数组 $sum_i=num_i-num_{i-1}$。

而我们给 $2,4$ 区间加上一个 $3$,可以这样子。

```
差分数组 : 3 4 5 -7 -2 (sum)
```

我们发现 $sum_l+3\ ,\ sum_{r+1}-3$。

求一下前缀和。

```pascal
前缀和  : 3 7 12 5 3
```

发现了什么?

树上差分更简单。假如我们要使 $l->r$ 这一条路径全部 $+1$,我们可以在它们的 $sum_{lca}$ 上面 $-1$,$sum_{lca_{father}}$ 也是 $-1$。然后 $sum_l+1,sum_r+1$。有人会问,为什么要在 $sum_{lca_{father}}-1$ 呢? 因为 $lca$ 也是要 $+1$ 的,如果求前缀和那么 $lca$ 这里就 $+2$ 了。然而 $lca$ 已经 $-1$,$lca_{father}$ 是不用 $+1$ 的。所以直接 $sum_{lca_{father}}-1$ 就巧妙的解决了问题。

然后你会发现你输出了以下东西

```pascal
1 3 2 3 2
```

而答案是

```pascal
1 2 1 2 1
```

因为我们把除 $node_1$ (注意是 $node_1$ 不是 $1$) 以外的都求了两次 (起点终点),所以我们要把它们减一。

因为要求 $lca$,所以时间复杂度为 $O(N \log N)$。其中 $lca$ 用树剖求,更快。 (特别对于一条链的情况)

```pascal
// 总共 400ms,第 11 页 (已经很不错啦)
// luogu-judger-enable-o2
var
    cnt,size,dep,top,father,son,node,sum:array[-1..510000] of longint;
    next,reach:array[-1..1050000] of longint;
    j,i,n,m,l,r,tot,root,lca:longint;

procedure add(l,r:longint);
begin
    inc(tot);
    reach[tot]:=r;
    next[tot]:=cnt[l];
    cnt[l]:=tot;
end;

procedure Dfs_1(x:longint);
var i:longint;
begin
    size[x]:=1; i:=cnt[x]; size[0]:=-maxlongint div 843;
    while i<>-1 do
    begin
        if dep[reach[i]]=0 then
        begin
            dep[reach[i]]:=dep[x]+1;
            father[reach[i]]:=x;
            Dfs_1(reach[i]); inc(size[x],size[reach[i]]);
            if size[reach[i]]>size[son[x]] then son[x]:=reach[i];
        end;
        i:=next[i];
    end;
end;

procedure Dfs_2(x,centre:longint);
var i:longint;
begin
    top[x]:=centre;
    if son[x]=0 then exit; Dfs_2(son[x],centre);
    i:=cnt[x];
    while i<>-1 do
    begin
        if (reach[i]<>father[x])and(reach[i]<>son[x]) then Dfs_2(reach[i],reach[i]);
        i:=next[i];
    end;
end;

procedure Dfs_3(x:longint);
var i:longint;
begin
    i:=cnt[x];
    while i<>-1 do
    begin
        if (reach[i]<>father[x]) then
        begin
            Dfs_3(reach[i]);
            inc(sum[x],sum[reach[i]]);
        end;
        i:=next[i];
    end;
end;

function Refer(x,y:longint):int64;
begin
    while top[x]<>top[y] do
    begin
        if dep[top[x]]<dep[top[y]] then y:=father[top[y]] else x:=father[top[x]];
    end;
    if dep[x]<dep[y] then exit(x) else exit(y);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
    read(n); root:=1;
    for i:=1 to n do read(node[i]);
    for i:=1 to n-1 do begin read(l,r); add(l,r); add(r,l); end;
    dep[root]:=1; father[root]:=0;  Dfs_1(root); Dfs_2(root,root);

    for i:=1 to n-1 do
    begin
        lca:=Refer(node[i+1],node[i]);
        inc(sum[node[i]]);
        inc(sum[node[i+1]]);
        dec(sum[father[lca]]);
        dec(sum[lca]);
    end;
    Dfs_3(root);
    for i:=2 to n do dec(sum[node[i]]);
    for i:=1 to n do writeln(sum[i]);
end.
```




---

## 作者：Sor4 (赞：0)

两种常见解法：树剖维护线段树，树上差分LCA。这里用的是倍增求LCA之后树上差分的方法，而且效率比一些神方法低，但是理解起来的话还是挺简单的。

a数组的话意思不用多说，但是注意事项的话，要以a[1]而不是1为根，下放标记也以a[1]开始。其他数组应该意思也很明显，主要注意到tmp数组。保存的也就是这个点被访问的次数，我们采用差分的思想，每次经过一条边，（如从u到v）我们让tmp[u]++,tmp[v]++,tmp[LCA(u,v)]--,tmp[grand[LCA(u,v)][0]]--。（最后要把tmp推上去）以一次添加为例想象一下，首先u到根的路径上tmp都+1，此时u到根间结点tmp都为1，之后v到根路径上tmp+1，此时u到LCA前一个，v到LCA前一个点的tmp都+1，而LCA到根的所有点都+2，然后从tmp[LCA]--,更新上去，此时u-v路上所有tmp都+1，已经达到目的。而多余的是什么部分呢，也就是LCA的上一个结点（grand[LCA][0]）到根的这一段都多加了1，所以tmp[grand[LCA][0]]--,更新上去，也就完成了。

实际操作时也就不需要每次更新都推上去，只要把四个tmp维护好，最后Dfs走一边就更新完了。但是最后求答案时，a[2]~a[n]都要减一。为什么呐......嘿嘿嘿，不告诉你。



----------------------------------------------我是一条萌萌哒的分割线>w<---------------------------------------------------



咳咳，看在你这么有诚意地翻下来的份上，就告诉你。因为每次的终点就是下一次的起点（结束...也正是新的开始）←不正常。所以这样的话相当于后面的每个房间都多放了一颗，最后一个房间也是一样（所以题目说不用放糖），把它当作多算了一遍减去就好。这题的样例还算良心的，可以对着图推一推吧...看懂意思比较重要。树剖的话...hhhhhhh学会了以后再说吧。












```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxx = 300000 + 100;
int head[maxx],next[maxx<<1],to[maxx<<1];
int grand[maxx][20+2],depth[maxx],tmp[maxx],a[maxx];
bool done[maxx];
int n,m,root,x,y,num,size,Ans;
inline int read(){
    int x = 0,f = 1;char c = getchar();
    while(c>'9'||c<'0') {if(c == '-') f = -1;c = getchar();}
    while(c>='0'&&c<='9') {x = x*10+c-'0'; c = getchar();}
    return x*f;
}
void Add(int x,int y){
    to[++num] = y;
    next[num] = head[x];
    head[x] = num;
}
void Dfs(int x){
    done[x] = true;
    for(int i=1;i<=20;i++){
        if(depth[x] < (1<<i)) break;
        grand[x][i] = grand[grand[x][i-1]][i-1];
    }
    for(int i=head[x];i;i=next[i]){
        int now = to[i];
        if(done[now]) continue;
        grand[now][0] = x;
        depth[now] = depth[x] + 1;
        Dfs(now);
    }
}
int Lca(int x,int y){
    if(depth[x] > depth[y]) x^=y^=x^=y;
    int d = depth[y] - depth[x];
    for(int i=0;i<=20;i++)
    if((1<<i) & d)
        y = grand[y][i];
    for(int i=20;i>=0;i--)
    if(grand[x][i] != grand[y][i])
        x = grand[x][i],y = grand[y][i];
    return x == y? x : grand[x][0];
}
void pushdown(int x)
{
    for(int i=head[x];i;i=next[i])
    {
        if (to[i]==grand[x][0]) continue;
        pushdown(to[i]);
        tmp[x]+=tmp[to[i]];
    }
}
int main(){
    n = read();
    for(int i=1;i<=n;i++)
        a[i] = read();
    for(int i=1;i<n;i++){
        x = read();y = read();
        Add(x,y);Add(y,x);
    }
    Dfs(a[1]);
    for(int i=1;i<n;i++){
        int u = a[i],v = a[i+1];
        tmp[u]++;tmp[v]++;
        tmp[Lca(u,v)]--;
        tmp[grand[Lca(u,v)][0]]--;
    }
    pushdown(a[1]);
    for(int i=2;i<=n;i++)
        tmp[a[i]]--;
    for(int i=1;i<=n;i++)
        printf("%d\n",tmp[i]);
    return 0;
}
```

---

## 作者：傅思维666 (赞：0)


## 题解：

一道树链剖分的题。

关于树链剖分的讲解详见：

[浅谈树链剖分](https://www.cnblogs.com/fusiwei/p/11519470.html)

其实树链剖分的练习题很多都是模板。

所以树链剖分题目的重点有二：第一：拍熟模板。第二：分析怎么用树链剖分解决，解决的时候要注意的问题是什么。

就拿这道题说吧：我们用树链剖分的理由是，这道题明显是修改树上一条路径的权值并查询所有点权，符合树链剖分的基本操作。如果你是模板拍错了，请自行照上面的博客调试。

如果你是WA了但是模板正确，那你可能犯了下面的问题：

因为小熊维尼是连续行进的，就比如说从1-2，再从2-3.如果我们按照裸的树链剖分来做的话，就会导致2这个点被加了两次糖。但是显然2这个点只需要一块就行。所以我们在进行路径修改之后，还要记得把终点的权值减去1.（这样的话也处理了餐厅不用加的问题。）



代码如下：

```cpp
#include<cstdio>
#include<algorithm>
#define lson pos<<1
#define rson pos<<1|1
#define R register
using namespace std;
const int maxn=3*1e5+1;
int n,a[maxn],cnt;
int tot,head[maxn],nxt[maxn<<1],to[maxn<<1];
int fa[maxn],deep[maxn],size[maxn],son[maxn];
int top[maxn],id[maxn];
int tree[maxn<<2],lazy[maxn<<2];
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<48){if(ch=='-')f=-1;ch=nc();}
    while(ch>47)    x=x*10+ch-'0',ch=nc();
    return x*f;
}
void add(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs1(int x,int f)
{
    deep[x]=deep[f]+1;
    fa[x]=f;
    size[x]=1;
    for(R int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==f)
            continue;
        dfs1(y,x);
        size[x]+=size[y];
        if(!son[x]||size[y]>size[son[x]])
            son[x]=y;
    }
}
void dfs2(int x,int t)
{
    top[x]=t;
    id[x]=++cnt;
    if(!son[x])
        return;
    dfs2(son[x],t);
    for(R int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x])
            continue;
        dfs2(y,y);
    }
}
void mark(int pos,int l,int r,int k)
{
    tree[pos]+=(r-l+1)*k;
    lazy[pos]+=k;
}
void pushdown(int pos,int l,int r)
{
    int mid=(l+r)>>1;
    mark(lson,l,mid,lazy[pos]);
    mark(rson,mid+1,r,lazy[pos]);
    lazy[pos]=0;
}
void update(int pos,int l,int r,int x,int y,int k)
{
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
    {
        mark(pos,l,r,k);
        return;
    }
    pushdown(pos,l,r);
    if(x<=mid)
        update(lson,l,mid,x,y,k);
    if(y>mid)
        update(rson,mid+1,r,x,y,k);
    tree[pos]=tree[lson]+tree[rson];
}
void upd_chain(int x,int y,int k)
{
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        update(1,1,n,id[top[x]],id[x],k);
        x=fa[top[x]];
    }
    if(deep[x]<deep[y])
        swap(x,y);
    update(1,1,n,id[y],id[x],k);
}
int query(int pos,int l,int r,int x,int y)
{
    int ret=0;
    int mid=(l+r)>>1;
    if(x<=l && r<=y)
        return tree[pos];
    pushdown(pos,l,r);
    if(x<=mid)
        ret+=query(lson,l,mid,x,y);
    if(y>mid)
        ret+=query(rson,mid+1,r,x,y);
    return ret;
}
int main()
{
    n=read();
    for(R int i=1;i<=n;i++)
        a[i]=read();
    for(R int i=1;i<n;i++)
    {
        int x,y;
        x=read(),y=read();
        add(y,x);
        add(x,y);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(R int i=1;i<n;i++)
    {
        upd_chain(a[i],a[i+1],1);
        upd_chain(a[i+1],a[i+1],-1);
    }
    for(R int i=1;i<=n;i++)
        printf("%d\n",query(1,1,n,id[i],id[i]));
    return 0;
}
```

---

## 作者：liaoy14866 (赞：0)

有人说倍增会T？然而跑得很快的样子。

树上差分（似乎不必分情况，像区间的差分一样）

定义差分数组T[i]=V[i]-Sigma(V[son])

每一次树上链加<u,v,1>，相当于T[u]+1，T[v]+1，T[lca]-1，T[Father[lca]]-1

最后遍历这棵树，把前缀和算出来，就是每个点的增加量。




```cpp
procedure Plus(u,v:longint);
 var
  l:longint;
 begin
  inc(T[u]);
  inc(T[v]);
  l:=Lca(u,v);
  dec(T[l]);
  dec(T[Father[l]]);
 end;
procedure Count(x:longint);
 var
  v:longint;
 begin
  v:=Tree[x];
  while v<>0 do
  begin
   Count(Etree[v].x);
   inc(T[x],T[Etree[v].x]);
   v:=Etree[v].next;
  end;
 end;
for i:=1 to n do
writeln(T[i]);
```

---

## 作者：QwQ2000 (赞：0)

因为伟大的神犇yhy已经写了LCA的题解

我就强行写一波树剖吧

这个题完全是裸题 没什么好说的

树剖以后线段树维护区间和 非常简单

这个题我WA了很久 后来才发现自己犯了两个小错


1 注意重复计算问题

比如对于序列1 3 5 2 4

那么3 5 2在计算区间加的时候 都会被加两次 这是不符合实际的

所以输出的时候记得判一下

如果不是a[1] 就把答案-1 如果这个点的答案是0 就不需要-1了


2 update开头特判一下 如果要查询的l0>r0就swap一下

这错误我犯了好几次了

蠢死了QAQQQ


那么我就上代码啦

[codec]













```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=300005;
int n=0;
int a[N];
int head[N*2],next[N*2],to[N*2],edge=0;
int depth[N],sz[N],id[N],son[N],num[N],fa[N],top[N],rank[N],yts=1;
int sum[N*8],flag[N*8];
inline void addEdge(int u,int v) {
    to[edge]=v,next[edge]=head[u],head[u]=edge++;
    to[edge]=u,next[edge]=head[v],head[v]=edge++;
}
void dfs1(int x,int f,int d) {
    depth[x]=d;
    sz[x]=1;
    fa[x]=f;
    for (int e=head[x];~e;e=next[e]) {
        int& v=to[e];
        if (v!=f) {
            dfs1(v,x,d+1);
            sz[x]+=sz[v];
            if (son[x]==-1 || sz[son[x]]<sz[v])
                son[x]=v; 
        }
    }
}
void dfs2(int x,int t) {
    top[x]=t;
    id[x]=yts++;
    rank[id[x]]=x;
    if (son[x]==-1) 
         return;  
    dfs2(son[x],t);
    for (int e=head[x];~e;e=next[e]) {
        int& v=to[e];
        if (v!=fa[x] && v!=son[x])
            dfs2(v,v);
    }
}
inline void pushUp(int rt) {
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
inline void pushDown(int rt,int l,int r) {
    sum[rt]+=(r-l+1)*flag[rt];
    flag[rt<<1]+=flag[rt];
    flag[rt<<1|1]+=flag[rt];
    flag[rt]=0;
}
void update(int rt,int l,int r,int d,int l0,int r0) {
    if (l0>r0)
        swap(l0,r0);
    if (l0<=l && r<=r0) {
        flag[rt]+=d;
        pushDown(rt,l,r);
    } else {
        int mid=(l+r)>>1;
        if (l0<=mid)
            update(rt<<1,l,mid,d,l0,r0);
        if (r0>mid)
            update(rt<<1|1,mid+1,r,d,l0,r0);
        pushDown(rt<<1,l,mid);
        pushDown(rt<<1|1,mid+1,r);
        pushUp(rt);
    }
}
int query(int rt,int l,int r,int x) {
    pushDown(rt,l,r);
    if (l==r) {
        return sum[rt];
    }        
    int mid=(l+r)>>1;
    if (x<=mid)
        return query(rt<<1,l,mid,x);
    if (x>mid)
        return query(rt<<1|1,mid+1,r,x);
}
inline void change(int x,int y,int d) {
    while (top[x]!=top[y]) {
        if (depth[top[x]]<depth[top[y]])
            swap(x,y);
        update(1,1,n,d,id[x],id[top[x]]);
        x=fa[top[x]];
    }
    if(depth[x]>depth[y]) 
        swap(x,y);  
    update(1,1,n,d,id[x],id[y]);  
}
int main(void) {
    memset(head,-1,sizeof(head));
    memset(son,-1,sizeof(son));
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
        scanf("%d",a+i);
    for (int i=1;i<=n-1;++i) {
        int u=0,v=0;
        scanf("%d %d",&u,&v);
        addEdge(u,v);
    }        
    dfs1(1,-1,1);
    dfs2(1,-1);
    for (int i=1;i<=n-1;++i) { 
        change(a[i],a[i+1],1);
    } 
    for (int i=1;i<=n;++i) {
        int ret=query(1,1,n,id[i]);
        if (!ret)
            printf("0\n");
        else
            printf("%d\n",i!=a[1]?(ret-1):ret);
    }
    return 0;
}
```
[codec/]

最后
让我们

sro yts1999 orz

yts神犇永垂不朽！


---


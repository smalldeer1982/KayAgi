# 【模板】线段树 1

## 题目描述

如题，已知一个数列 $\{a_i\}$，你需要进行下面两种操作：

1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。


## 说明/提示

对于 $15\%$ 的数据：$n \le 8$，$m \le 10$。  
对于 $35\%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。    
对于 $100\%$ 的数据：$1 \le n, m \le {10}^5$，$a_i,k$ 为正数，且任意时刻数列的和不超过 $2\times 10^{18}$。

**【样例解释】**

![](https://cdn.luogu.com.cn/upload/pic/2251.png)

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4```

### 输出

```
11
8
20```

# 题解

## 作者：皎月半洒花 (赞：5481)

# 一、简介线段树

ps:  此处以询问区间和为例。实际上线段树可以处理很多**符合结合律**的操作。

比如说加法，`a[1]+a[2]+a[3]+a[4]=(a[1]+a[2])+(a[3]+a[4])` 。

线段树之所以称为“树”，是因为其具有树的结构特性。线段树由于本身是专门用来处理区间问题的（包括 RMQ、RSQ 问题等）。

对于每一个子节点而言，都表示整个序列中的一段子区间；对于每个叶子节点而言，都表示序列中的单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息则是他的每一个子节点信息的整合。

有没有觉得很熟悉？对，**线段树就是分块思想的树化，或者说是对于信息处理的二进制化**——用于达到 $O(\log n)$ 级别的处理速度，$\log$ 以 $2$ 为底。（其实以几为底都只不过是个常数，可忽略)。而分块的思想，则是可以用一句话总结为：**通过将整个序列分为有穷个小块，对于要查询的一段区间，总是可以整合成 $k$ 个所分块与 $m$ 个单个元素的信息的并** $(0\leq k,m\leq \sqrt{n})$。但普通的分块不能高效率地解决很多问题，所以作为 $\log$ 级别的数据结构，线段树应运而生。

____

$\mathcal{Extra \ \ Tips}$

其实，虽然线段树的时间效率要高于分块但是实际上分块的总合并次数不会超过 $\sqrt{n}$ 但是线段树在最坏情况下的合并次数显然是要大于这个时间效率的。

~~但是毕竟也只是一个很大的常数而已。~~

However，虽说如此，分块的应用范围还是要广于线段树的，因为虽然线段树好像很快，但是它只能维护带有结合律的信息，比如区间 $\max/\min$、$\sum$、$\rm xor$ 之类的，但是不带有结合律的信息就不能维护（且看下文分解）；而分块则灵活得多，可以维护很多别的东西,因为实际上分块的本质就是**优雅的暴力**。

其实越暴力的算法可以支持的操作就越多、功能性就越强！~~你看 $n^2$ 的暴力几乎什么都可以维护。~~

____

# 二、逐步分析线段树的构造实现

## 1、建树与维护
   
由于二叉树的自身特性，对于每个父亲节点的编号 $i$，他的两个儿子的编号分别是 $2i$ 和 $2i+1$，所以我们考虑写两个 $O(1)$ 的取儿子函数：

```cpp
    int n;
	int ans[MAXN*4];
	
	inline int ls(int p){return p<<1;}//左儿子 
	inline int rs(int p){return p<<1|1;}//右儿子 
```
___

$\mathcal{Extra \ \ Tips}$

1、此处的 `inline` 可以有效防止无需入栈的信息入栈，节省时间和空间。

2、二进制位左移一位代表着数值 $\times 2$，而如果左移完之后再或上 $1$，由于左移完之后最后一位二进制位上一定会是 $0$ ，所以 $|1$ 等价于 $+1$ 。这个地方更多是为了方便，速度方面理论上是要比 $+1$ 快，但其实编译器会帮你主动干这件事。
___

  那么根据线段树的服务对象，可以得到线段树的维护:

```cpp
    void push_up_sum(int p){
		t[p]=t[lc(p)]+t[rc(p)];
    }//	向上不断维护区间操作 
	
	void push_up_min(int p){//max and min
	 t[p]=min(t[lc(p)],t[rc(p)]);
     //t[p]=max(t[lc(p)],t[rc(p)]);             
    }
```

此处一定要注意，`push up` 操作的目的是为了**维护父子节点之间的逻辑关系**。当我们递归建树时，对于每一个节点我们都需要遍历一遍，并且电脑中的**递归实际意义是先向底层递归，然后从底层向上回溯**，所以开始递归之后必然是**先去整合子节点的信息**，再向它们的祖先回溯整合之后的信息。(这其实是正确性的证明啦)。
   
呐，我们在这儿就能看出来，实际上 `push_up` 是在合并两个子节点的信息，所以需要信息满足结合律！
   
那么对于建树，由于二叉树自身的父子节点之间的可传递关系，所以可以考虑递归建树（emmmm 之前好像不小心剧透了 qwq），并且在建树的同时，我们应该维护父子节点的关系：
   
  ```cpp
void build(ll p,ll l,ll r)
{
	if(l==r){ans[p]=a[l];return ;}
    //如果左右区间相同，那么必然是叶子节点啦，只有叶子节点是被真实赋值的
	ll mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
//此处由于我们采用的是二叉树，所以对于整个结构来说，可以用二分来降低复杂度，否则树形结构则没有什么明显的优化
	push_up(p);
//此处由于我们是要通过子节点来维护父亲节点，所以pushup的位置应当是在回溯时。
} 
```
  
## 2、接下来谈区间修改

为什么不讨论单点修改呢 ？因为其实很显然，单点修改就是区间修改的一个子问题而已，即区间长度为$1$时进行的区间修改操作罢了 qwq。

那么对于区间操作，我们考虑引入一个名叫“ $\rm lazy~tag$ ”（懒标记）的东西——之所以称其“$\rm lazy$”，是因为原本区间修改需要通过先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达 $O(n\log n)$ 的级别。但当我们引入了懒标记之后，区间更新的期望复杂度就降到了 $O(\log n)$ 的级别且甚至会更低.


### （1）首先先来从分块思想上解释如何区间修改：

分块的思想是通过将整个序列分为有穷个小块，对于要查询的一段区间，总是可以整合成 $k$ 个所分块与 $m$ 个单个元素的信息的并 $(0\leq k,m\leq \log n)$(小小修改了一下的上面的前言 qwq )。

那么我们可以反过来思考这个问题：对于一个要修改的、长度为 $l$ 的区间来说，总是可以看做由一个长度为 $2^{\log(\lfloor{n}\rfloor)}$ 和剩下的元素（或者小区间组成）。那么我们就可以先将其拆分成线段树上节点所示的区间，之后分开处理：

 _**如果单个元素被包含就只改变自己，如果整个区间被包含就修改整个区间。**_ 
 
 其实好像这个在分块里不是特别简单地实现，但是在线段树里，无论是元素还是区间都是线段树上的一个节点，**所以我们不需要区分区间还是元素**，加个判断就好。
 
 ### （2）懒标记的正确打开方式
 
首先，懒标记的作用是记录每次、每个节点要更新的值，也就是 $\Delta$。但线段树的优点不在于全记录（全记录依然很慢 qwq），而在于传递式记录：
 
**整个区间都被操作，记录在公共祖先节点上；只修改了一部分，那么就记录在这部分的公共祖先上；如果四环以内只修改了自己的话，那就只改变自己。**

After that，如果我们采用上述的优化方式的话，我们就需要在每次区间的查询修改时 `push_down` 一次，以免重复或者冲突或者爆炸 qwq。

那么对于 `push_down` 而言，其实就是纯粹的 `push_up` 的逆向思维(但不是逆向操作)：
因为修改信息存在父节点上，所以要由父节点向下传导 $\rm lazy~tag$ 。

那么问题来了：怎么传导 `push_down` 呢？这里很有意思，开始回溯时执行 `push_up`，因为是向上传导信息；那我们如果要让它向下更新，就调整顺序，在向下递归的时候 `push_down` 不就好惹~ qwq：

 ```cpp
inline void f(ll p,ll l,ll r,ll k)
{
	tag[p]=tag[p]+k;
	ans[p]=ans[p]+k*(r-l+1);
	//由于是这个区间统一改变，所以ans数组要加元素个数次啦 
}
//我们可以认识到，f函数的唯一目的，就是记录当前节点所代表的区间 
inline void push_down(ll p,ll l,ll r)
{
	ll mid=(l+r)>>1;
	f(ls(p),l,mid,tag[p]);
	f(rs(p),mid+1,r,tag[p]);
	tag[p]=0;
	//每次更新两个儿子节点。以此不断向下传递 
}
inline void update(ll nl,ll nr,ll l,ll r,ll p,ll k)
{
	//nl,nr为要修改的区间
	//l,r,p为当前节点所存储的区间以及节点的编号 
	if(nl<=l&&r<=nr)
	{
		ans[p]+=k*(r-l+1);
		tag[p]+=k;
		return ;
	}
	push_down(p,l,r);
	//回溯之前（也可以说是下一次递归之前，因为没有递归就没有回溯） 
	//由于是在回溯之前不断向下传递，所以自然每个节点都可以更新到 
	ll mid=(l+r)>>1;
	if(nl<=mid)update(nl,nr,l,mid,ls(p),k);
	if(nr>mid) update(nl,nr,mid+1,r,rs(p),k);
	push_up(p);
	//回溯之后 
}
```
对于复杂度而言，由于完全二叉树的深度不超过 $\log n$，那么单点修改显然是 $O(\log n)$ 的，区间修改的话，由于我们的这个区间至多分 $\log n$ 个子区间，对于每个子区间的查询是 $O(1)$ 的，所以复杂度自然是 $O(\log n)$~~不过带一点常数~~。

## 3、那么对于区间查询

没什么好说的，由于是信息的整合，所以还是要用到分块思想，我实在是不想再码一遍了 qwq。

```cpp
ll query(ll q_x,ll q_y,ll l,ll r,ll p)
{
	ll res=0;
	if(q_x<=l&&r<=q_y)return ans[p];
	ll mid=(l+r)>>1;
	push_down(p,l,r);
	if(q_x<=mid)res+=query(q_x,q_y,l,mid,ls(p));
	if(q_y>mid) res+=query(q_x,q_y,mid+1,r,rs(p));
	return res;
}
```

最后贴~~高清无码的~~标程：

（还有，输入大数据一定不要用不加优化的 `cin/cout` 啊）。

```cpp
#include<iostream>
#include<cstdio>
#define MAXN 1000001
#define ll long long
using namespace std;
unsigned ll n,m,a[MAXN],ans[MAXN<<2],tag[MAXN<<2];
inline ll ls(ll x)
{
    return x<<1;
}
inline ll rs(ll x)
{
    return x<<1|1;
}
void scan()
{
    cin>>n>>m;
    for(ll i=1;i<=n;i++)
    scanf("%lld",&a[i]);
}
inline void push_up(ll p)
{
    ans[p]=ans[ls(p)]+ans[rs(p)];
}
void build(ll p,ll l,ll r)
{
    tag[p]=0;
    if(l==r){ans[p]=a[l];return ;}
    ll mid=(l+r)>>1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
    push_up(p);
} 
inline void f(ll p,ll l,ll r,ll k)
{
    tag[p]=tag[p]+k;
    ans[p]=ans[p]+k*(r-l+1);
}
inline void push_down(ll p,ll l,ll r)
{
    ll mid=(l+r)>>1;
    f(ls(p),l,mid,tag[p]);
    f(rs(p),mid+1,r,tag[p]);
    tag[p]=0;
}
inline void update(ll nl,ll nr,ll l,ll r,ll p,ll k)
{
    if(nl<=l&&r<=nr)
    {
        ans[p]+=k*(r-l+1);
        tag[p]+=k;
        return ;
    }
    push_down(p,l,r);
    ll mid=(l+r)>>1;
    if(nl<=mid)update(nl,nr,l,mid,ls(p),k);
    if(nr>mid) update(nl,nr,mid+1,r,rs(p),k);
    push_up(p);
}
ll query(ll q_x,ll q_y,ll l,ll r,ll p)
{
    ll res=0;
    if(q_x<=l&&r<=q_y)return ans[p];
    ll mid=(l+r)>>1;
    push_down(p,l,r);
    if(q_x<=mid)res+=query(q_x,q_y,l,mid,ls(p));
    if(q_y>mid) res+=query(q_x,q_y,mid+1,r,rs(p));
    return res;
}
int main()
{
    ll a1,b,c,d,e,f;
    scan();
    build(1,1,n);
    while(m--)
    {
        scanf("%lld",&a1);
        switch(a1)
        {
            case 1:{
                scanf("%lld%lld%lld",&b,&c,&d);
                update(b,c,1,n,1,d);
                break;
            }
            case 2:{
                scanf("%lld%lld",&e,&f);
                printf("%lld\n",query(e,f,1,n,1));
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：归褯雾嵊 (赞：632)

# 来水一波题解
------------------------------------------------------------
来首先简介一下线段树，就是比较~~niubi~~的一个数据结构，类似本题，可以维护区间加，区间查找等操作，其余还有区间乘，区间最大值，甚至最大连续子段和等等好多操作……


---------------------------

-------------------

貌似长这样：（图片来自互联网）
![](http://p5.so.qhimgs1.com/t019e2060978883abeb.png)

~~皮~~


-线段树的存储
---
线段树要用结构体存储
```
struct tree{
    int l,r;
    long long pre,add;
}t[4*maxn+2];
```
pre代表该节点维护的值，l，r代表该节点维护的区间范围
至于add涉及到一个叫懒标记的东西，后面会说……


-建树
--
所谓建树，就是把数组a[1-n],放到线段树中

在线段树中，从图里也可以看出来，对于一个区间（编号为p），他的左儿子为2*p，右儿子为2*p+1，so伟大的建树操作就出现了
```
void bulid(int p,int l,int r){
    t[p].l=l;t[p].r=r;//以p为编号的节点维护的区间为l到r
    if(l==r){//l=r的话，这个区间就只有一个数，直接让区间维护的值等于a[i]
        t[p].pre=a[l];
        return;
    }//否则维护的值等于左儿子加右儿子
    int mid=l+r>>1;
    bulid(p*2,l,mid);
    bulid(p*2+1,mid+1,r);
    t[p].pre=t[p*2].pre+t[p*2+1].pre;
} 
```
-懒标记
---
~~懒标记是一个神奇的东西，为什么叫懒标记，因为它比较懒~~
懒标记的精髓就是打标记和下传操作，由于我们要做的操作是区间加一个数，所以我们不妨在区间进行修改时为该区间打上一个标记，就不必再修改他的儿子所维护区间，等到要使用该节点的儿子节点维护的值时，再将懒标记下放即可，可以节省很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间
```
void spread(int p){
    if(t[p].add){//如果懒标记不为0，就将其下传，修改左右儿子维护的值
        t[p*2].pre+=t[p].add*(t[p*2].r-t[p*2].l+1);
        t[p*2+1].pre+=t[p].add*(t[p*2+1].r-t[p*2+1].l+1);
        t[p*2].add+=t[p].add;//为该节点的左右儿子打上标记
        t[p*2+1].add+=t[p].add;
        t[p].add=0;//下传之后将该节点的懒标记清0
    }
}
```

-区间修改
---
考虑将一个区间加上一个数，我们可以从根节点不断向下查找，当发现我们要修改的区间覆盖了当前节点时，我们就把这个区间给修改，并打上懒标记（由于懒标记存在，我们就不必再修改他的儿子节点），否则下传懒标记，继续向下找
```
void change(int p,int x,int y,int z){
    if(x<=t[p].l && y>=t[p].r){//被覆盖的话，就对其进行修改
        t[p].pre+=(long long)z*(t[p].r-t[p].l+1);
        t[p].add+=z;//打上懒标记
        return;
    }
    spread(p);//如果发现没有被覆盖，那就需要继续向下找，考虑儿子所维护的区间可能因为懒标记的存在而没有修改，因此将懒标记下放
    int mid=t[p].l+t[p].r>>1;
    if(x<=mid) change(p*2,x,y,z);//如果要修改的区间覆盖了左儿子，就修改左儿子
    if(y>mid) change(p*2+1,x,y,z);//右儿子同理
    t[p].pre=t[p*2].pre+t[p*2+1].pre;//最终维护的值等于左儿子的值+右儿子的值   
}
```
-区间查询
---
考虑询问一个区间的和，依旧是从根节点向下查找，当发现该节点被覆盖时，就返回维护的值，否则下传懒标记，查询左右儿子，累加答案
```
long long ask(int p,int x,int y){
    if(x<=t[p].l && y>=t[p].r) return t[p].pre;//如果被覆盖，就返回维护的值
    spread(p);//下传懒标记，并查询左右儿子
    int mid=t[p].l+t[p].r>>1;
    long long ans=0;
    if(x<=mid) ans+=ask(p*2,x,y);
    if(y>mid) ans+=ask(p*2+1,x,y);//累加答案，返回左右儿子的和
    return ans;
}
```

AC代码来一波
```
#include<bits/stdc++.h>

using namespace std;

const int maxn=100010;

int a[maxn+2];

struct tree{
    int l,r;
    long long pre,add;
}t[4*maxn+2];

void bulid(int p,int l,int r){
    t[p].l=l;t[p].r=r;
    if(l==r){
        t[p].pre=a[l];
        return;
    }
    int mid=l+r>>1;
    bulid(p*2,l,mid);
    bulid(p*2+1,mid+1,r);
    t[p].pre=t[p*2].pre+t[p*2+1].pre;
} 

void spread(int p){
    if(t[p].add){
        t[p*2].pre+=t[p].add*(t[p*2].r-t[p*2].l+1);
        t[p*2+1].pre+=t[p].add*(t[p*2+1].r-t[p*2+1].l+1);
        t[p*2].add+=t[p].add;
        t[p*2+1].add+=t[p].add;
        t[p].add=0;
    }
}

void change(int p,int x,int y,int z){
    if(x<=t[p].l && y>=t[p].r){
        t[p].pre+=(long long)z*(t[p].r-t[p].l+1);
        t[p].add+=z;
        return;
    }
    spread(p);
    int mid=t[p].l+t[p].r>>1;
    if(x<=mid) change(p*2,x,y,z);
    if(y>mid) change(p*2+1,x,y,z);
    t[p].pre=t[p*2].pre+t[p*2+1].pre;   
}

long long ask(int p,int x,int y){
    if(x<=t[p].l && y>=t[p].r) return t[p].pre;
    spread(p);
    int mid=t[p].l+t[p].r>>1;
    long long ans=0;
    if(x<=mid) ans+=ask(p*2,x,y);
    if(y>mid) ans+=ask(p*2+1,x,y);
    return ans;
}

int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    bulid(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int q,x,y,z;
        scanf("%d",&q);
        if(q==1){
            scanf("%d%d%d",&x,&y,&z);
            change(1,x,y,z);
        }
        else {
            scanf("%d%d",&x,&y);
            cout<<ask(1,x,y)<<endl;
        }
    }
    return 0;
}
```
然后你会发现：
![](https://www.luogu.com.cn/images/congratulation.png)

---

## 作者：冈崎梦美 (赞：446)

UPD1:之前推导过程中论证有些笔误，已修改。

UPD2:添加了对于求和公式的注释。（原来的一大堆代码，看起来很诡异……）

---

[线段树模板（1）](https://www.luogu.org/problemnew/show/3372)

题意要求：给定一个序列，支持区间修改和区间查询。

当然，题目名字告诉我们要用线段树。但是线段树很长，容易出现问题，而且跑得稍慢，所以就有dalao开始yy：可不可以让树状数组支持区间修改和查询呢？


## 于是伟大的“超级树状数组”横空出世了。


首先，我们看树状数组是如何支持区间修改的：

设tree[i]=a[i]-a[i-1]（差分），那么容易得到：

***tree[1]+tree[2]+……+tree[i]=a[i]***这个公式

所以，只需要维护tree数组就可以实现区间修改了。


**那么问题来了，如果这样，那么如何实现区间查询呢？**

我们已经推出了一个公式：

```cpp
tree[1]+tree[2]+……tree[i]=a[i]
```
那么，对于1到r的区间和，即为：

```cpp
 a[1]+a[2]+……+a[r-1]+a[r]
//用上方公式推导得出
=tree[1]+(tree[1]+tree[2])+……+(tree[1]+……+tree[r])
//根据加法交换律与结合律：
=(tree[1]*(r))+(tree[2]*(r-1))+……(tree[r]*1)
//那么：
=r*(tree[1]+tree[2]+……+tree[r])-(tree[1]*0+tree[2]*1+……+tree[r]*(r-1))
```
看到这里，是不是已经很清晰了呢？

对于a的树状数组(差分)tree，建立一个新的树状数组tree1使得：

`tree1[i]=tree[i]*(i-1)`

之后，x到y的区间和即为：

`(y\*getsum(tree,y)-(x-1)\*getsum(tree,x-1))-(getsum(tree1,y)-getsum(tree1,x-1))`

```
Tips:
因为求区间和满足区间加法，所以Sum(L,R)=Sum(1,R)-Sum(1,L-1)，所以有上述公式。
```

当然，对于更新操作也需要进行一些细微调整，详细的就看代码吧……

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,tree[100005],tree1[100005];//题目要求longlong
inline void add(long long*z,long long x,long long num)
{
    while(x<=n)
    {
        z[x]+=num;
        x+=x&(-x);
    }
}
inline long long getsum(long long*z,long long x)
{
    long long sum=0;
    while(x>0)
    {
        sum+=z[x];
        x-=x&(-x);
    }
    return sum;
}
int main()
{
    cin.sync_with_stdio(false);
    cin>>n>>m;
    long long a,b=0;
    for(long long i=1;i<=n;i++)
    {
        cin>>a;
        b=a-b;
        add(tree,i,b);
        add(tree1,i,(i-1)*b);
        b=a;
    }
    for(long long i=1;i<=m;i++)
    {
        int t,x,y,z;
        cin>>t;
        if (t==1)
        {
            cin>>x>>y>>z;
            add(tree,x,z);
            add(tree,y+1,-z);
            add(tree1,x,z*(x-1));
            add(tree1,y+1,-z*y);//此处为核心，联系上方的公式，想一想为什么这么修改。
        }
        else
        {
            cin>>x>>y;
            cout<<(y*getsum(tree,y)-(x-1)*getsum(tree,x-1))-(getsum(tree1,y)-getsum(tree1,x-1))<<endl;
        }
    }
    return 0;
} 
```

---

## 作者：TJor (赞：287)


~~想边听歌边看算法的可以去[这里](https://www.cnblogs.com/jason2003/p/9676729.html)~~

**线段树是什么？？线段树怎么写？？**

如果你在考提高组前一天还在问这个问题，那么你会与一等奖失之交臂；如果你还在冲击普及组一等奖，那么这篇博客会浪费你人生中宝贵的5~20分钟。

上面两句话显而易见，线段树这个数据结构是一个从萌新到正式OI选手的过渡，是一个非常重要的算法，也是一个对于萌新来说较难的算法。不得不说，我学习了这个算法5遍左右才有勇气写的这篇博客。

但是，对于OI正式选手来说，线段树不是算法，应该是一种工具。她能把一些对于区间（或者线段）的修改、维护，从O(N)的时间复杂度变成O（logN）。

废话不说，这篇博客会分为四部：

**第一部：线段树概念引入**

**第二部：简单(无pushdown）的线段树**

**第三部：区间+/-修改与查询**

**第四部：区间乘除修改与查询**

 **总结**

**第一部 概念引入**

线段树是一种二叉树，也就是对于一个线段，我们会用一个二叉树来表示。比如说一个长度为4的线段，我们可以表示成这样：

![](https://img2018.cnblogs.com/blog/987049/201809/987049-20180919200225625-1602154608.png)

 

这是什么意思呢？ 如果你要表示线段的和，那么最上面的根节点的权值表示的是这个线段1~4的和。根的两个儿子分别表示这个线段中1~2的和，与2~3的和。以此类推。

然后我们还可以的到一个性质：节点i的权值=她的左儿子权值+她的右儿子权值。因为1~4的和就是等于1~2的和+2~3的和。

根据这个思路，我们就可以建树了，我们设一个结构体tree，tree[i].l和tree[i].r分别表示这个点代表的线段的左右下标，tree[i].sum表示这个节点表示的线段和。

我们知道，一颗二叉树，她的左儿子和右儿子编号分别是她*2和她*2+1

再根据刚才的性质，得到式子：tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;就可以建一颗线段树了！代码如下：
```
inline void build(int i,int l,int r){//递归建树
    tree[i].l=l;tree[i].r=r;
    if(l==r){//如果这个节点是叶子节点
        tree[i].sum=input[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(i*2,l,mid);//分别构造左子树和右子树
    build(i*2+1,mid+1,r);
    tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;//刚才我们发现的性质return ;
}
```
嗯，这就是线段树的构建，你可能会问为什么要开好几倍的内存去储存一条线段。这是因为我们还没有让这个过大的数组干一些实事，那么什么是实事呢？让我们进入下一部（在你看懂这一部的情况下）

**第二部 简单（无pushdown）的线段树**

1、单点修改，区间查询

其实这一章开始才是真正的线段树，我们要用线段树干什么？答案是维护一个线段（或者区间），比如你想求出一个1~100区间中，4~67这些元素的和，你会怎么做？朴素的做法是for(i=4;i<=67;i++)  sum+=a[i]，这样固然好，但是算得太慢了。

我们想一种新的方法，先想一个比较好画图的数据，比如一个长度为4的区间，分别是1、2、3、4,我们想求出第1~3项的和。按照上一部说的，我们要建出一颗线段树，其中点权（也就是红色）表示和：
![](https://img2018.cnblogs.com/blog/987049/201809/987049-20180919203745885-314299579.png)

然后我们要求1~3的和，我们先从根节点开始查询，发现她的左儿子1~2这个区间和答案区间1~3有交集，那么我们跑到左儿子这个区间。

然后，我们发现这个区间1~2被完全包括在答案区间1~3这个区间里面，那就把她的值3返回。

我们回到了1~4区间，发现她的右儿子3~4区间和答案区间1~3有交集，那么我们走到3~4区间

到了3~4区间，我们发现她并没有完全包含在答案区间1~3里面，但发现她的左儿子3~3区间和1~3区间又交集，那么久走到3~3区间

到了3~3区间，发现其被答案区间完全包含，就返回她的值3一直到最开始

3~3区间的3+1~2区间的3=6，我们知道了1~3区间和为6.

有人可能会说你这样是不是疯了，我那脚都能算出1+2+3=6，为什么这么麻烦？！

因为这才几个数，如果一百万个数，这样时间会大大增快。

我们总结一下，线段树的查询方法：

1、如果这个区间被完全包括在目标区间里面，直接返回这个区间的值

2、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子

3、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子

写成代码，就会变成这样：
```
inline int search(int i,int l,int r){
    if(tree[i].l>=l && tree[i].r<=r)//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值
        return tree[i].sum;
    if(tree[i].r<l || tree[i].l>r)  return 0;//如果这个区间和目标区间毫不相干，返回0
    int s=0;
    if(tree[i*2].r>=l)  s+=search(i*2,l,r);//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子
    if(tree[i*2+1].l<=r)  s+=search(i*2+1,l,r);//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子
    return s;
}
```

**关于那几个if的条件一定要看清楚，最好背下来，以防考场上脑抽推错。**

然后,我们怎么修改这个区间的单点，其实这个相对简单很多，你要把区间的第dis位加上k。

那么你从根节点开始，看这个dis是在左儿子还是在右儿子，在哪往哪跑，

然后返回的时候，还是按照tree[i].sum=tree[i*2].sum+tree[i*2+1].sum的原则，更新所有路过的点

如果不理解，我还是画个图吧，其中深蓝色是去的路径，浅蓝色是返回的路径，回来时候红色的+标记就是把这个点加上这个值。
![](https://img2018.cnblogs.com/blog/987049/201809/987049-20180919205930637-1487496115.png)

把这个过程变成代码，就是这个样子：

```
inline void add(int i,int dis,int k){
    if(tree[i].l==tree[i].r){//如果是叶子节点，那么说明找到了
        tree[i].sum+=k;
        return ;
    }
    if(dis<=tree[i*2].r)  add(i*2,dis,k);//在哪往哪跑
    else  add(i*2+1,dis,k);
    tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;//返回更新
    return ;
}
```

2、区间修改，单点查询

区间修改和单点查询，我们的思路就变为：如果把这个区间加上k，相当于把这个区间涂上一个k的标记，然后单点查询的时候，就从上跑道下，把沿路的标记加起来就好。

这里面给区间贴标记的方式与上面的区间查找类似，原则还是那三条，只不过第一条：如果这个区间被完全包括在目标区间里面，直接返回这个区间的值变为了如果这个区间如果这个区间被完全包括在目标区间里面，讲这个区间标记k

具体做法很像，这里贴上代码：

```
inline void add(int i,int l,int r,int k){
    if(tree[i].l>=l && tree[i].r<=r){//如果这个区间被完全包括在目标区间里面，讲这个区间标记k
        tree[i].sum+=k;
        return ;
    }
    if(tree[i*2].r>=l)
        add(i*2,l,r,k);
    if(tree[i*2+1].l<=r)
        add(i*2+1,l,r,k);
}
```


然后就是单点查询了，这个更好理解了，就是dis在哪往哪跑，把路径上所有的标价加上就好了：

```
void search(int i,int dis){
    ans+=tree[i].num;//一路加起来
    if(tree[i].l==tree[i].r)
        return ;
    if(dis<=tree[i*2].r)
        search(i*2,dis);
    if(dis>=tree[i*2+1].l)
        search(i*2+1,dis);
}
```

不知不觉，这第二章已经结束。这样的简单（原谅我用这个词）线段树，还可除了求和，还可以求区间最小最大值，还可以区间染色。

但是！这样的线段树展现不出来她的魅力，因为区间求和，树状数组比她少了一个很大的常熟。二区间最值，ST的那神乎其技的O（n）查询也能完爆她。这是为什么？因为线段树的魅力还没有展现出来，她最美丽的地方：pushdown还未展现于世，如果你已经对这一章充足的了解，并且能不看博客把洛谷上树状数组模板1、2都能写出来，那么请你进入下一部。

 

**第三部 进阶线段树**

区间修改、区间查询，你可能会认为，把上一章里面的这两个模块加在一起就好了，然后你就会发现你大错特错。

因为如果对于1~4这个区间，你把1~3区间+1，相当于把节点1~2和3标记，但是如果你查询2~4时，你会发现你加的时没有标记的2节点和没有标记的3~4节点加上去，结果当然是错的。

那么我们应该怎么办？这时候pushdown的作用就显现出来了。

你会想到，我们只需要在查询的时候，如果我们要查的2节点在1~2区间的里面，那我们就可以把1~2区间标记的那个+1给推下去这样就能顺利地加上了。
怎么记录这个标记呢？我们需要记录一个“懒标记”lazytage，来记录这个区间

区间修改的时候，我们按照如下原则：

1、如果当前区间被完全覆盖在目标区间里，讲这个区间的sum+k*(tree[i].r-tree[i].l+1)

2、如果没有完全覆盖，则先下传懒标记

3、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子

4、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子


 然后查询的时候，将这个懒标记下传就好了，下面图解一下：

如图，区间1~4分别是1、2、3、4，我们要把1~3区间+1。因为1~2区间被完全覆盖，所以将其+2，并将紫色的lazytage+1，3区间同理

![](https://img2018.cnblogs.com/blog/987049/201809/987049-20180920195821587-4845808.png)

注意我们处理完这些以后，还是要按照tree[i].sum=tree[i*2].sum+tree[i*2+1].sum的原则返回，代码如下：
```
void add(int i,int l,int r,int k)
{
    if(tree[i].r<=r && tree[i].l>=l)//如果当前区间被完全覆盖在目标区间里，讲这个区间的sum+k*(tree[i].r-tree[i].l+1)
    {
        tree[i].sum+=k*(tree[i].r-tree[i].l+1);
        tree[i].lz+=k;//记录lazytage
        return ;
    }
    push_down(i);//向下传递
    if(tree[i*2].r>=l)
        add(i*2,l,r,k);
    if(tree[i*2+1].l<=r)
        add(i*2+1,l,r,k);
    tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;
    return ;
}
```

其中的pushdown，就是把自己的lazytage归零，并给自己的儿子加上，并让自己的儿子加上k*(r-l+1)
```
void push_down(int i)
{
    if(tree[i].lz!=0)
    {
        tree[i*2].lz+=tree[i].lz;//左右儿子分别加上父亲的lz
        tree[i*2+1].lz+=tree[i].lz;
        init mid=(tree[i].l+tree[i].r)/2;
        tree[i*2].data+=tree[i].lz*(mid-tree[i*2].l+1);//左右分别求和加起来
        tree[i*2+1].data+=tree[i].lz*(tree[i*2+1].r-mid);
        tree[i].lz=0;//父亲lz归零
    }
    return ;
}
```

查询的时候，和上一章的几乎一样，就是也要像修改一样加入pushdown，这里用图模拟一下。我们要查询2~4区间的和，这是查询前的情况，所有紫色的代表lazytage

![](https://img2018.cnblogs.com/blog/987049/201809/987049-20180921131618196-79075472.png)

然后，我们查到区间1~2时，发现这个区间并没有被完全包括在目标区间里，于是我们就pushdown，lazytage下传，并让每个区间sum加上（r-l）*lazytage。

![](https://img2018.cnblogs.com/blog/987049/201809/987049-20180921132140938-396404765.png)

然后查到2~2区间，发现被完全包含，所以就返3，再搜索到3~4区间，发现被完全包含，那么直接返回8，最后3+8=11就是答案

这里是代码实现：

```
inline int search(int i,int l,int r){
    if(tree[i].l>=l && tree[i].r<=r)
        return tree[i].sum;
    if(tree[i].r<l || tree[i].l>r)  return 0;
    push_down(i);
    int s=0;
    if(tree[i*2].r>=l)  s+=search(i*2,l,r);
    if(tree[i*2+1].l<=r)  s+=search(i*2+1,l,r);
    return s;
}
```

 好了，到了这里，我们就学会了用线段树进行区间加减操作，大家可以完成洛谷的线段树模板1
 
 1、乘法线段树

如果这个线段树只有乘法，那么直接加入lazytage变成乘，然后tree[i].sum*=k就好了。但是，如果我们是又加又乘，那就不一样了。

当lazytage下标传递的时候，我们需要考虑，是先加再乘还是先乘再加。我们只需要对lazytage做这样一个处理。

lazytage分为两种，分别是加法的plz和乘法的mlz。

mlz很简单处理，pushdown时直接*父亲的就可以了，那么加法呢？

我们需要把原先的plz*父亲的mlz再加上父亲的plz.

```
inline void pushdown(long long i){//注意这种级别的数据一定要开long long
    long long k1=tree[i].mlz,k2=tree[i].plz;
    tree[i<<1].sum=(tree[i<<1].sum*k1+k2*(tree[i<<1].r-tree[i<<1].l+1))%p;//
    tree[i<<1|1].sum=(tree[i<<1|1].sum*k1+k2*(tree[i<<1|1].r-tree[i<<1|1].l+1))%p;
    tree[i<<1].mlz=(tree[i<<1].mlz*k1)%p;
    tree[i<<1|1].mlz=(tree[i<<1|1].mlz*k1)%p;
    tree[i<<1].plz=(tree[i<<1].plz*k1+k2)%p;
    tree[i<<1|1].plz=(tree[i<<1|1].plz*k1+k2)%p;
    tree[i].plz=0;
    tree[i].mlz=1;
    return ;
}
```

然后加法和减法的函数同理，维护lazytage的时候加法标记一定要记得现乘再加。

值得一提的是，计算*2时一定要改成i<<1这样能解决很多时间，还有要开long long，还有，函数前面要加inline 我在其他OJ交这道题时，就因为没加inline 就被卡了，交了就过了。

2、根号线段树

其实，根号线段树和除法线段树一样。她们乍眼一看感觉直接用lazytage标记除了多少，但是实际上，会出现精度问题。

c++的除法是向下取整，很明显，(a+b)/k！=a/k+b/k（在向下取整的情况下），而根号，很明显根号（a）+根号(b)!=根号(a+b)那么怎么办？

第一个想法就是暴力，对于每个要改动的区间l~r,把里面的每个点都单独除，但这样就会把时间复杂度卡得比大暴力都慢（因为多个常数），所以怎么优化？

我们对于每个区间，维护她的最大值和最小值，然后每次修改时，如果这个区间的最大值根号和最小值的根号一样，说明这个区间整体根号不会产生误差，就直接修改（除法同理）

其中，lazytage把除法当成减法，记录的是这个区间里每个元素减去的值。

下面是根号线段树的修改过程：
```
inline void Sqrt(int i,int l,int r){
    if(tree[i].l>=l && tree[i].r<=r && (tree[i].minn-(long long)sqrt(tree[i].minn))==(tree[i].maxx-(long long)sqrt(tree[i].maxx))){//如果这个区间的最大值最小值一样
        long long u=tree[i].minn-(long long)sqrt(tree[i].minn);//计算区间中每个元素需要减去的
        tree[i].lz+=u;
        tree[i].sum-=(tree[i].r-tree[i].l+1)*u;
        tree[i].minn-=u;
        tree[i].maxx-=u;
            //cout<<"i"<<i<<" "<<tree[i].sum<<endl;
        return ;
    }
    if(tree[i].r<l || tree[i].l>r)  return ;
    push_down(i);
    if(tree[i*2].r>=l)  Sqrt(i*2,l,r);
    if(tree[i*2+1].l<=r)  Sqrt(i*2+1,l,r);
    tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;
    tree[i].minn=min(tree[i*2].minn,tree[i*2+1].minn);//维护最大值和最小值
    tree[i].maxx=max(tree[i*2].maxx,tree[i*2+1].maxx);
    //cout<<"i"<<i<<" "<<tree[i].sum<<endl;
    return ;
}
```

然后pushdown没什么变化，就是要记得tree[i].minn、tree[i].maxx也要记得-lazytage。

**模板题与代码：**

单点修改，区间查询：[树状数组模板1](https://www.luogu.org/problemnew/show/P3374)
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <queue>
#include <stack>
#include <vector>
using namespace std;
#define MAXN 100010
#define INF 10000009
#define MOD 10000007
#define LL long long
#define in(a) a=read()
#define REP(i,k,n) for(long long i=k;i<=n;i++)
#define DREP(i,k,n) for(long long i=k;i>=n;i--)
#define cl(a) memset(a,0,sizeof(a))
inline long long read(){
    long long x=0,f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}
inline void out(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) out(x/10);
    putchar(x%10+'0');
}
long long n,m,p;
long long input[MAXN];
struct node{
    long long l,r;
    long long sum,mlz,plz;
}tree[4*MAXN];
inline void build(long long i,long long l,long long r){
    tree[i].l=l;
    tree[i].r=r;
    tree[i].mlz=1;
    if(l==r){
        tree[i].sum=input[l]%p;
        return ;
    }
    long long mid=(l+r)>>1;
    build(i<<1,l,mid);
    build(i<<1|1,mid+1,r);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}
inline void pushdown(long long i){
    long long k1=tree[i].mlz,k2=tree[i].plz;
    tree[i<<1].sum=(tree[i<<1].sum*k1+k2*(tree[i<<1].r-tree[i<<1].l+1))%p;
    tree[i<<1|1].sum=(tree[i<<1|1].sum*k1+k2*(tree[i<<1|1].r-tree[i<<1|1].l+1))%p;
    tree[i<<1].mlz=(tree[i<<1].mlz*k1)%p;
    tree[i<<1|1].mlz=(tree[i<<1|1].mlz*k1)%p;
    tree[i<<1].plz=(tree[i<<1].plz*k1+k2)%p;
    tree[i<<1|1].plz=(tree[i<<1|1].plz*k1+k2)%p;
    tree[i].plz=0;
    tree[i].mlz=1;
    return ;
}
inline void mul(long long i,long long l,long long r,long long k){
    if(tree[i].r<l || tree[i].l>r)  return ;
    if(tree[i].l>=l && tree[i].r<=r){
        tree[i].sum=(tree[i].sum*k)%p;
        tree[i].mlz=(tree[i].mlz*k)%p;
        tree[i].plz=(tree[i].plz*k)%p;
        return ;
    }
    pushdown(i);
    if(tree[i<<1].r>=l)  mul(i<<1,l,r,k);
    if(tree[i<<1|1].l<=r)  mul(i<<1|1,l,r,k);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}
inline void add(long long i,long long l,long long r,long long k){
    if(tree[i].r<l || tree[i].l>r)  return ;
    if(tree[i].l>=l && tree[i].r<=r){
        tree[i].sum+=((tree[i].r-tree[i].l+1)*k)%p;
        tree[i].plz=(tree[i].plz+k)%p;
        return ;
    }
    pushdown(i);
    if(tree[i<<1].r>=l)  add(i<<1,l,r,k);
    if(tree[i<<1|1].l<=r)  add(i<<1|1,l,r,k);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}
inline long long search(long long i,long long l,long long r){
    if(tree[i].r<l || tree[i].l>r)  return 0;
    if(tree[i].l>=l && tree[i].r<=r)
        return tree[i].sum;
    pushdown(i);
    long long sum=0;
    if(tree[i<<1].r>=l)  sum+=search(i<<1,l,r)%p;
    if(tree[i<<1|1].l<=r)  sum+=search(i<<1|1,l,r)%p;
    return sum%p;
}
int main(){
    in(n);    in(m);in(p);
    REP(i,1,n)  in(input[i]);
    build(1,1,n); 

    REP(i,1,m){
        long long fl,a,b,c;
        in(fl);
        if(fl==1){
            in(a);in(b);in(c);
            c%=p;
            mul(1,a,b,c);
        }
        if(fl==2){
            in(a);in(b);in(c);
            c%=p;
            add(1,a,b,c);
        }
        if(fl==3){
            in(a);in(b);
            printf("%lld\n",search(1,a,b));
        }
    }
    return 0;
}
/*
4 1000
2 3 4 5
1 5
1 5 1
1 5 2
1 5
*/
```
区间修改，单点查询：[树状数组模板2](https://www.luogu.org/problemnew/show/P3368)

```
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
int n,m;
int ans;
int input[500010];
struct node
{
    int left,right;
    int num;
}tree[2000010];
void build(int left,int right,int index)
{
    tree[index].num=0;
    tree[index].left=left;
    tree[index].right=right;
       if(left==right)
        return ;
    int mid=(right+left)/2;
    build(left,mid,index*2);
    build(mid+1,right,index*2+1);
}
void pls(int index,int l,int r,int k)
{
    if(tree[index].left>=l && tree[index].right<=r)
    {
        tree[index].num+=k;
        return ;
    }
    if(tree[index*2].right>=l)
       pls(index*2,l,r,k);
    if(tree[index*2+1].left<=r)
       pls(index*2+1,l,r,k);
}
void search(int index,int dis)
{
    ans+=tree[index].num;
    if(tree[index].left==tree[index].right)
        return ;
    if(dis<=tree[index*2].right)
        search(index*2,dis);
    if(dis>=tree[index*2+1].left)
        search(index*2+1,dis);
}
int main()
{
    int n,m;
    cin>>n>>m;
    build(1,n,1);
    for(int i=1;i<=n;i++)
        scanf("%d",&input[i]);
    for(int i=1;i<=m;i++)
    {
        int a;
        scanf("%d",&a);
        if(a==1)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            pls(1,x,y,z);
        }
        if(a==2)
        {
            ans=0;
            int x;
            scanf("%d",&x);
            search(1,x);
            printf("%d\n",ans+input[x]);
        }
    }
}
```
区间加减，区间查询：[线段树模板1](https://www.luogu.org/problemnew/show/P3372)

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init long long
using namespace std;
init n,m;
struct node
{
    init l,r,data;
    init lt;    
}tree[1000010];
init arr[1000010];
void build(init l,init r,init index,init arr[])
{
    tree[index].lt=0;
    tree[index].l=l;
    tree[index].r=r;
    if(l==r)
    {
        tree[index].data=arr[l];
        return ;
    }
    init mid=(l+r)/2;
    build(l,mid,index*2,arr);
    build(mid+1,r,index*2+1,arr);
    tree[index].data=tree[index*2].data+tree[index*2+1].data;
    return ;
}
void push_down(init index)
{
    if(tree[index].lt!=0)
    {
        tree[index*2].lt+=tree[index].lt;
        tree[index*2+1].lt+=tree[index].lt;
        init mid=(tree[index].l+tree[index].r)/2;
        tree[index*2].data+=tree[index].lt*(mid-tree[index*2].l+1);
        tree[index*2+1].data+=tree[index].lt*(tree[index*2+1].r-mid);
        tree[index].lt=0;
    }
    return ;
}
void up_data(init index,init l,init r,init k)
{
    if(tree[index].r<=r && tree[index].l>=l)
    {
        tree[index].data+=k*(tree[index].r-tree[index].l+1);
        tree[index].lt+=k;
        return ;
    }
    push_down(index);
    if(tree[index*2].r>=l)
        up_data(index*2,l,r,k);
    if(tree[index*2+1].l<=r)
        up_data(index*2+1,l,r,k);
    tree[index].data=tree[index*2].data+tree[index*2+1].data;
    return ;
}
init search(init index,init l,init r)
{
    if(tree[index].l>=l && tree[index].r<=r)
        return tree[index].data;
    push_down(index);
    init num=0;
    if(tree[index*2].r>=l)
        num+=search(index*2,l,r);
    if(tree[index*2+1].l<=r)
        num+=search(index*2+1,l,r);
    return num;
}
int main()
{
    cin>>n>>m;
    for(init i=1;i<=n;i++)
        cin>>arr[i];
    build(1,n,1,arr);
    for(init i=1;i<=m;i++)
    {
        init f;
        cin>>f;
        if(f==1)
        {
            init a,b,c;
            cin>>a>>b>>c;
            up_data(1,a,b,c);
        }
        if(f==2)
        {
            init a,b;
            cin>>a>>b;
            printf("%lld\n",search(1,a,b));
        }
    }
}
```
区间乘法：[线段树模板2](https://www.luogu.org/problemnew/show/P3373)

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <queue>
#include <stack>
#include <vector>
using namespace std;
#define MAXN 100010
#define INF 10000009
#define MOD 10000007
#define LL long long
#define in(a) a=read()
#define REP(i,k,n) for(long long i=k;i<=n;i++)
#define DREP(i,k,n) for(long long i=k;i>=n;i--)
#define cl(a) memset(a,0,sizeof(a))
inline long long read(){
    long long x=0,f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}
inline void out(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) out(x/10);
    putchar(x%10+'0');
}
long long n,m,p;
long long input[MAXN];
struct node{
    long long l,r;
    long long sum,mlz,plz;
}tree[4*MAXN];
inline void build(long long i,long long l,long long r){
    tree[i].l=l;
    tree[i].r=r;
    tree[i].mlz=1;
    if(l==r){
        tree[i].sum=input[l]%p;
        return ;
    }
    long long mid=(l+r)>>1;
    build(i<<1,l,mid);
    build(i<<1|1,mid+1,r);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}
inline void pushdown(long long i){
    long long k1=tree[i].mlz,k2=tree[i].plz;
    tree[i<<1].sum=(tree[i<<1].sum*k1+k2*(tree[i<<1].r-tree[i<<1].l+1))%p;
    tree[i<<1|1].sum=(tree[i<<1|1].sum*k1+k2*(tree[i<<1|1].r-tree[i<<1|1].l+1))%p;
    tree[i<<1].mlz=(tree[i<<1].mlz*k1)%p;
    tree[i<<1|1].mlz=(tree[i<<1|1].mlz*k1)%p;
    tree[i<<1].plz=(tree[i<<1].plz*k1+k2)%p;
    tree[i<<1|1].plz=(tree[i<<1|1].plz*k1+k2)%p;
    tree[i].plz=0;
    tree[i].mlz=1;
    return ;
}
inline void mul(long long i,long long l,long long r,long long k){
    if(tree[i].r<l || tree[i].l>r)  return ;
    if(tree[i].l>=l && tree[i].r<=r){
        tree[i].sum=(tree[i].sum*k)%p;
        tree[i].mlz=(tree[i].mlz*k)%p;
        tree[i].plz=(tree[i].plz*k)%p;
        return ;
    }
    pushdown(i);
    if(tree[i<<1].r>=l)  mul(i<<1,l,r,k);
    if(tree[i<<1|1].l<=r)  mul(i<<1|1,l,r,k);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}
inline void add(long long i,long long l,long long r,long long k){
    if(tree[i].r<l || tree[i].l>r)  return ;
    if(tree[i].l>=l && tree[i].r<=r){
        tree[i].sum+=((tree[i].r-tree[i].l+1)*k)%p;
        tree[i].plz=(tree[i].plz+k)%p;
        return ;
    }
    pushdown(i);
    if(tree[i<<1].r>=l)  add(i<<1,l,r,k);
    if(tree[i<<1|1].l<=r)  add(i<<1|1,l,r,k);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}
inline long long search(long long i,long long l,long long r){
    if(tree[i].r<l || tree[i].l>r)  return 0;
    if(tree[i].l>=l && tree[i].r<=r)
        return tree[i].sum;
    pushdown(i);
    long long sum=0;
    if(tree[i<<1].r>=l)  sum+=search(i<<1,l,r)%p;
    if(tree[i<<1|1].l<=r)  sum+=search(i<<1|1,l,r)%p;
    return sum%p;
}
int main(){
    in(n);    in(m);in(p);
    REP(i,1,n)  in(input[i]);
    build(1,1,n); 

    REP(i,1,m){
        long long fl,a,b,c;
        in(fl);
        if(fl==1){
            in(a);in(b);in(c);
            c%=p;
            mul(1,a,b,c);
        }
        if(fl==2){
            in(a);in(b);in(c);
            c%=p;
            add(1,a,b,c);
        }
        if(fl==3){
            in(a);in(b);
            printf("%lld\n",search(1,a,b));
        }
    }
    return 0;
}
/*
4 1000
2 3 4 5
1 5
1 5 1
1 5 2
1 5
*/
```

---

## 作者：yurzhang (赞：261)

去了wc2019的同学应该对 **指令集** 有些印象，没去的同学 ( 比如~~我~~ ) 可能也通过一些途径了解到了这个暴力踩标程的毒瘤 ( 据说现场踩 `Ynoi五彩斑斓的世界`  ) 。但是由于我太弱，实在过不了那道题 **dllxl Orz** ，所以我就来拿这道题练手了。

---

## 一、指令集是什么？

其实就是压位，常用的是压256位。也有能压512位的，但大部分情况不支持 ( 硬件 + 软件 ) 。

## 二、它为什么快？

就像压位高精会比裸高精快， `bitset` 比 `bool数组` 快一样，你把8个32位的 `int` 压成一个256位的玩意儿，每次操作可以看成是同时对8个 `int` 进行操作 ( 但其实并不是这样 ) ，所以理论上常数会是原来的 $\frac{1}{8}$ ( 但其实做不到 $\frac{1}{8}$ ) 。

## 三、它要怎么用？

~~请自行摸索~~

首先你需要 `immintrin.h` 库，~~里面啥都有~~然后再在程序前加上 `#pragma GCC target("avx,avx2")` ，这样你就可以把你的 `int` 啊 `long long` 啊什么的压成 `__m256i` ，把 `float` 压成 `__m256` ，还能把 `double` 压成 `__m256d` 。

~~什么你问我具体怎么做？我不知道啊.jpg~~

---

这里是连快读都没用的$O\left(n^2\right)$暴力[评测记录](https://www.luogu.org/recordnew/show/16093890)。

最后附上这道题的程序，想学学指令集的可以看看：
```cpp
#pragma GCC optimize("Ofast,fast-math")
#pragma GCC target("avx,avx2")
#include <cstdio>
#include <immintrin.h>

int n,m,num,x[5],opt,p,q,k;
__m256i a[25010];

inline void add(int l,int r,int v)
{
    while(((l-1)&3)&&l<=r)((long long*)(a+(l>>2)+1))[(l&3)-1]+=v,++l;
    if(l==r+1)return;
    while((r&3)&&l<=r)((long long*)(a+(r>>2)+1))[(r&3)-1]+=v,--r;
    if(l==r+1)return;
    l=(l>>2)+1,r>>=2;
    __m256i s=_mm256_set_epi64x(v,v,v,v);
    while(l<=r)a[l]=_mm256_add_epi64(a[l],s),++l;
}

inline long long query(int l,int r)
{
    long long ans(0);
    while(((l-1)&3)&&l<=r)ans+=((long long*)(a+(l>>2)+1))[(l&3)-1],++l;
    if(l==r+1)return ans;
    while((r&3)&&l<=r)ans+=((long long*)(a+(r>>2)+1))[(r&3)-1],--r;
    if(l==r+1)return ans;
    l=(l>>2)+1,r>>=2;
    __m256i s=_mm256_set_epi64x(0,0,0,0);
    while(l<=r)s=_mm256_add_epi64(a[l],s),++l;
    for(int i=0;i<4;++i)
        ans+=((long long*)&s)[i];
    return ans;
}

int main()
{
    scanf("%d%d",&n,&m);num=n>>2;
    for(int i=1;i<=num;++i)
    {
        for(int j=1;j<=4;++j)
            scanf("%d",x+j);
        a[i]=_mm256_set_epi64x(x[4],x[3],x[2],x[1]);
    }
    for(int i=1;i<=(n&3);++i)
        scanf("%d",x+i);
    a[++num]=_mm256_set_epi64x(x[4],x[3],x[2],x[1]);
    
    while(m--)
    {
        scanf("%d%d%d",&opt,&p,&q);
        if(opt==1)
            scanf("%d",&k),add(p,q,k);
        else
            printf("%lld\n",query(p,q));
    }
    return 0;
}
```
这道题要开 `long long` ，如果是 `int` 的话程序第一句的 `Ofast` 优化去掉也能过！

最后的最后，如果你从这篇题解中学到了些东西，请动动手帮忙点赞，谢谢啦！

---

## 作者：Echidna (赞：103)

# 这篇题解说了什么？

这篇题解包括了三种解决 [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372) 的方法：

 - 线段树 （仅仅给出了代码）
 
 - 平衡树
 
 - CDQ分治
 
首先声明：这篇题解所用的 **有些** 算法 **并不是** 解决这道题的正确算法。如果你想要看正确的 **线段树** ，大可不必看这片题解。

蒟蒻的第一篇题解。

 ---------------


## 解法一： 线段树

这道题的正确解法就是线段树。

但是，我并不打算写线段树的具体构建方式，因为其他的题解讲的比我好得多。如果您打开题解就是为了学习线段树， ~~那也可以拿我的代码看看，毕竟注释写的还是蛮多的~~ 

这里贴出代码：

```cpp
#include<iostream>
using namespace std;
const int N=100010;
typedef long long ll;
ll tree[N*4];
ll lazy[N*4];
int a[N];
#define lson ((root<<1))
#define rson ((root<<1)+1)
#define mid (l+r>>1)
void build(int root,int l,int r){// O(n) 建树
	if(l==r){
		tree[root]=a[l];//如果递归到了最底层，直接返回。
		return;
	}
	build(lson,l,mid);//分别递归左右子树。
	build(rson,mid+1,r);
	tree[root]=tree[lson]+tree[rson];//重新计算这个节点所覆盖的元素的和。
}
void fun(int root,int l,int r,int v){//推标记
	tree[root]+=(r-l+1)*v;
	lazy[root]+=v;
}
void pushdown(int root,int l,int r){//放标记
	fun(lson,l,mid,lazy[root]);
	fun(rson,mid+1,r,lazy[root]);
	lazy[root]=0;
}
void update(int root,int l,int r,int lr,int rr,int v){//更新
	if(r<lr||rr<l){//如果现在这个节点所代表的线段完全不在更新的范围之内，直接返回。
		return ;
	}
	if(lr<=l&&r<=rr){//如果现在这个节点所代表的线段完全在更新的范围之内，直接推标记。
		fun(root,l,r,v);
		return;
	}
	pushdown(root,l,r);//下放标记。
	update(lson,l,mid,lr,rr,v);
	update(rson,mid+1,r,lr,rr,v);
	tree[root]=tree[lson]+tree[rson];//重新计算这个节点所覆盖的元素的和。
}
ll query(int root,int l,int r,int lr,int rr){//差不多和update函数一样。
	if(r<lr||rr<l){//如果现在这个节点所代表的线段完全不在查询的范围之内，直接返回。
		return 0;
	}
	if(lr<=l&&r<=rr){//如果现在这个节点所代表的线段完全在查询的范围之内，直接sum。
		return tree[root];
	}
	pushdown(root,l,r);//下放标记
	return (ll)query(lson,l,mid,lr,rr)+(ll)query(rson,mid+1,r,lr,rr);
}
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,1,n);
	for(int a,b,c,d,i=1;i<=m;i++){
		cin>>a;
		if(a==1){
			cin>>b>>c>>d;
			update(1,1,n,b,c,d);
		}else{
			cin>>b>>c;
			cout<<(ll)query(1,1,n,b,c)<<endl;
		}
	}
}
```

解释一下为什么建树是 $O(n)$ 的（直观感受来看，它很容易被认为是 $O(n\log n)$ ）：

根据[主定理](https://www.luogu.com.cn/blog/GJY-JURUO/master-theorem)，$T(n)=2T(\dfrac{n}{2})+\theta(1)=O(n)$

尽管这个东西可以做到 $O(n)$ ，但是跟这个代码的其他部分比起来，这只是优化了个常数。

## 解法二：平衡树

平衡树所能维护的不仅仅是一种动态集合，它也可以用来解决某些序列区间问题。但是如果需要实现区间操作，普通的平衡树不能满足要求，最好使用 **能够支持分裂和合并** 的平衡树。

**该解法前置知识：`Splay` 或是 `fhq-Treap` 。**

这篇题解所采用的平衡树是 `fhq-Treap` 。它易于实现，常数也不错（虽然跟线段树比起来就差远了

不同于按照值来进行排序的平衡树，这棵平衡树是 **按照下标进行排序** 的。

下图演示了按照下标进行排序的平衡树和按照值进行排序的平衡树的区别。

![演示图片](https://cdn.luogu.com.cn/upload/image_hosting/ug7ssc0y.png?x-oss-process=image/resize,m_lfit,h_1700,w_605)

~~这个地方应该挺好理解吧~~

那么，构建了一棵按照下标排序的平衡树之后我们该怎么办呢？

我们应该考虑去维护 **每一个节点的子树的值之和** 。

如果我们可以维护，那么我们在查询的时候，只需要将对应的子树分裂出来，然后查询这个被分裂出来的子树的根节点的 子树之和 即可。

实际上这里是很好维护的，我们只需要对于每一个节点维护 $sum$ ，当这棵平衡树分裂或者是合并的时候重新计算受到影响的节点的 $sum$ 即可，也就是 **分裂操作或者是合并操作所经过的节点** 。

那么按照这个思路，我们也可以对于每一个节点维护一个 $lazy$ ，当我们修改的时候，也是像查询一样，先把我们要修改的这棵子树分裂出来，然后 **给树根打上一个 `lazy tag`** 。

现在的问题就是怎么维护这个 `lazy tag` 。其实像 $sum$ 一样，我们所要做的其实就只是 **在分裂操作或是合并操作之前将 `lazy tag` 下放** 。

这样的话，这道题的代码就不难写出来了。

平均时间复杂度： $O(m \log n)$

之所以这里用的是“平均时间复杂度”，是因为 `Treap` 的时间复杂度依赖于随机出来数据的好坏。~~它是个随机化算法。~~ 不过这其实不影响你在竞赛的时候写 `Treap` ，这是因为 `Treap` 因为随机出来数据不好而导致 `TLE` 的可能性微乎其微。

代码：

```cpp
#include<iostream>
#include<cstdlib>
#define int long long
using namespace std;
const int N=1e6;
struct treap{
    int v,l,r,p,s,lz,su;
}t[N];
#define v(x) t[x].v //代表这个节点的值。
#define ls(x) t[x].l //代表这个节点的左儿子。
#define rs(x) t[x].r //代表这个节点的右儿子。
#define p(x) t[x].p //代表这个节点的优先级
#define s(x) t[x].s //代表这个节点的子树的节点个数
#define lz(x) t[x].lz //lazy tag
#define su(x) t[x].su //sum
void pushup(int x,int v){//上推
    if(x==0)return;
    v(x)+=v;
    su(x)+=s(x)*v;
    lz(x)+=v;
}
void pushdown(int x){//下放
    pushup(ls(x),lz(x));
    pushup(rs(x),lz(x));
    lz(x)=0;
}
int merge(int x,int y){//合并操作
    if(x==0||y==0)
        return x+y;
    if(p(x)<p(y)){
        pushdown(x);//这里是对于 lazy tag 的处理：合并、分裂之前先下放。
        rs(x)=merge(rs(x),y);
        s(x)=s(ls(x))+s(rs(x))+1;
        su(x)=su(ls(x))+su(rs(x))+v(x);//这里是对于 sum 的处理：合并、分裂之后更新 sum
        return x;
    }else{
        pushdown(y);//这里是对于 lazy tag 的处理：合并、分裂之前先下放。
        ls(y)=merge(x,ls(y));
        s(y)=s(ls(y))+s(rs(y))+1;
        su(y)=su(ls(y))+su(rs(y))+v(y);
        return y;
    }
}
void split(int x,int& a,int& b,int siz){
    if(x==0){
        a=b=0;
        return;
    }
    pushdown(x);//这里是对于 lazy tag 的处理：合并、分裂之前先下放。
    if(s(ls(x))<siz){
        a=x;
        split(rs(x),rs(x),b,siz-s(ls(x))-1);
    }else{
        b=x;
        split(ls(x),a,ls(x),siz);
    }
    s(x)=s(ls(x))+s(rs(x))+1;
    su(x)=su(ls(x))+su(rs(x))+v(x);//这里是对于 sum 的处理：合并、分裂之后更新 sum
}
int cnt=0;
int create(int x){
    su(++cnt)=x;
    v(cnt)=x;
    s(cnt)=1;
    p(cnt)=rand()+rand();
    return cnt;
}
int root;
int n,m;
signed main(){
    cin>>n>>m;
    for(int x,i=1;i<=n;i++){
        cin>>x;
        root=merge(root,create(x));//读入一个数，并直接将它合并到平衡树的最后一个位置去。
    }
    int a,b,c;
    for(int ty,l,r,x,i=1;i<=m;i++){
        cin>>ty;
        if(ty==1){
            cin>>l>>r>>x;
            split(root,a,b,l-1);
            split(b,b,c,r-l+1);//先将所修改的子树分裂出来
            pushup(b,x);//打上个lazy tag
            root=merge(merge(a,b),c);//合并回去
        }else{
            cin>>l>>r;
            split(root,a,b,l-1);
            split(b,b,c,r-l+1);//先将所修改的子树分裂出来
            cout<<su(b)<<endl;//查一下sum
            root=merge(merge(a,b),c);//合并回去
        }
    }
}
```

## 解法三：CDQ 分治

这才是这篇题解的独特之处！

**前置知识：CDQ分治**

其实不会 CDQ 分治也可以看这篇题解，毕竟 CDQ 分治只是一种思想，而不是一种具体的算法。

----------------

### 先将这个题差分化

如果我们来把一个修改拆开，变成两个修改，分别修改开头和末尾（也就是把一个原本是 $[l,r]+x$ 的修改变成 $[l,n]+x ;[r+1,n]-x$ 的两个修改），这个东西就变成了一个差分。

我们不妨也把原本的数组也这样处理：对于每一个 $i \in [1,n]$ ，加入两个修改：$[i,n]+a_i;[i+1,n]-a_i$ 。（其中 $a_i$ 表示原本的数组的第 $i$ 个元素）

既然修改都做到这样了，我们也可以对查询这么做：对于一个查询 $[l,r]$ ，我们把它拆成两个查询 $[1,r];[1,l-1]$ 。最后我们只需要将第一个查询的答案减去第二个查询的答案即可得到原本的查询的答案。

----------------

### 探究一个查询的答案的构成。

现在我们来看一个查询 $[1,x]$ 的答案是怎么构成的：

首先，如果有一个修改$[y,n]+z$，它的位置在 $x$ 之前 （也就是 $y<=x$）,它出现的时间也在 $x$ 之前，那么这个修改一定可以对查询 $[l,x]$ 造成贡献。那么这个贡献是什么呢？我们会发现，这个修改其实相当于把区间 $[y,x]$ 之间的每一个数都造成了贡献 $z$ ,所以这个修改对于查询 $[1,x]$ 的贡献为 $(x-y+1)\times z$ 。

我们现在已经搞明白了如果有一个修改和一个查询，那么这个修改什么条件下会对查询造成贡献以及造成贡献的量。现在我们将这个结论推向多个修改和一个查询。

我们先不妨设 $y_i$ 为第 $i$ 个询问的 $y$ ， $z_i$ 为第 $i$ 个询问的 $z$ 。

如果现在有 $s$ 个查询和一个修改，并且每一个查询都能对这个修改造成贡献，，那么贡献之和理应是

$$\sum_{i=1}^{s}z_i(x-y_i+1)=\sum_{i=1}^{s}(z_ix-z_iy_i+z_i)=(x+1)\sum_{i=1}^{s}z_i-\sum_{i=1}^{s}z_iy_i$$

--------------

### 分治统计答案

现在我们已经成功把这个题转化为了差分形式和搞明白了一个查询的答案的构成。但是知道这些有什么用吗？我们怎么用这些信息把答案算出来？

我们假设每一个询问和修改现在都被我们放在一个序列里，它们都有以下属性：

 - $t$ ，表示这个询问/修改的出现时间。

 - $x$ ，表示这个询问/修改的位置。
 
 - $y$ ，如果这是个修改的话表示它所加的值；如果这是个查询的话为 $0$ （相当于一个没有影响的修改）。

既然它们的属性基本一致，我们就叫它们**节点**好了。

我们重新改写题意：给出每一个节点的 $t,x,y$ ，算出每一个节点能获得的贡献。

好了，那么，现在又怎么做？

分治？

怎么分治？

我们考虑到，如果现在你正在处理一个区间 $[l,r]$ 中的节点（并且它们的 $t$ 是一个 $[l,r]$ 的排列），我们首先可以把它们分为两类：

 1. $t$ 小于或者等于 $\dfrac{l+r}{2}$ 的

 2. $t$ 大于 $\dfrac{l+r}{2}$ 的

很明显，对于同一类节点之间造成的贡献，我们直接递归下去好了，我们需要考虑的只是不同类节点之间造成的贡献，而且，**如果有贡献，一定是第一类节点对第二类节点造成贡献**。

这个其实很显然：第一类节点的 $t$ 都小于第二类节点的 $t$ ，无论如何也不可能让后来者影响先来者。

于是这就变成了第一类节点单向对第二类节点造成贡献的问题。
那么怎么计算贡献呢？我们首先把两类节点都以 $x$ 为关键词排序，（因为之后 $x$ 小的节点能对 $x$ 大的节点造成贡献）。然后我们可以来用双指针法算贡献。具体流程如下：

**请注意：原来的贡献公式中，$x ,y ,z$ 的定义与现在的定义不同，请勿混淆。**

 1. 创建两个变量 `sum` 和 `all` ，分别表示已经处理的第一类节点的 $y$ 之值 和 已经处理的第一类节点的 $x$ 与 $y$ 的乘积之和。跳转至第 2 步。

 2. 如果第一类节点的第一个节点的 $x$ 比 第二类节点的第一个节点的 $x$ 小，那么我们就先处理第一类节点的第一个节点，跳转至第 3 步；否则我们就先处理第二类节点的第一个节点，转至第 4 步。
 
 3. 将第一类第一个节点的 $y$ 加入 `sum` ，将 $xy$ 加入 `all` 。将这个节点“删掉”，并返回到第二步。（让下一个节点变成第一个节点）
 
 4. 按照公式 $\text{contribution}=(x+1)\sum_{i=1}^{s}y_i-\sum_{i=1}^{s}x_iy_i=(x+1)sum + all$ 算出贡献，并将其加入到这个节点的总贡献中。将这个节点“删掉”，并返回到第二步。（让下一个节点变成第一个节点）

**这里的“删掉”并不是真的删掉**，只是为了方便说明原理而已。

我们可以保证，在这个算法运行完毕之后，每一个第二类的节点都已经加上了第一类节点所能造成的贡献。

现在，我已经将这整个算法的流程说明完毕。如果你在上面没有理解明白，可以到下面去看看具体实现。

下面是代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
const int N=1e6;
int a[N];
struct query{//节点的结构体。
    int time,x,y;
}p[N],temp[N];
int cnt=0;
void add(int x,int y){//添加一个节点
    p[++cnt].time=cnt;
    p[cnt].x=x;
    p[cnt].y=y;
}
int ans[N];//a[x]用来存储t为x的节点所获得的总贡献。
pair<int,int> qa[N];
int n,m;
bool cmp(query a,query b){//一个按照 x 排序的 cmp 函数。
    if(a.x!=b.x)
        return a.x<b.x;
    return a.time<b.time;
}
void cdq(int l,int r){//现在在处理区间 [l,r]
    if(l==r)
        return;//只有一个元素，直接返回
    int mid=(l+r)>>1,x=l,y=mid+1;
    for(int i=l;i<=r;i++)		//先将区间 [l,r] 分为两类节点
        if(p[i].time<=mid)
            temp[x++]=p[i];	//这个节点属于第一类
        else temp[y++]=p[i];  //这个节点属于第二类
    for(int i=l;i<=r;i++)p[i]=temp[i];	
    cdq(l,mid);			//分治第一类节点之间的贡献
    cdq(mid+1,r);		//分治第二类节点之间的贡献
    sort(p+l,p+mid+1,cmp);		//排序，使得它对于 x 有序。
    sort(p+mid+1,p+r+1,cmp);
    x=l,y=mid+1;int sum=0,all=0;
    while(x<=mid||y<=r)			//双指针算法。其中 x 代表第一类元素现在的下标，y 代表第二类元素现在的下标。
        if(x<=mid&&(y>r||p[x].x<=p[y].x))                   //如果我们要先处理第一类节点
            sum+=p[x].x*p[x].y,all+=p[x].y,x++;             //更新sum和all
        else                                                //否则处理第二类节点
        	  ans[p[y].time]+=all*(p[y].x+1)-sum,y++;   //计算贡献
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        add(i,a[i]-a[i-1]);
    int qm=0;
    for(int ty,l,r,x,i=1;i<=m;i++){
        cin>>ty;
        if(ty==1){//是一个修改操作
            cin>>l>>r>>x;
            add(l,x);//进行差分
            add(r+1,-x);
        }else{
            cin>>l>>r;
            add(l-1,0);
            qa[++qm].first=cnt;//存下来这个询问对应着哪两个询问，方便最后处理。
            add(r,0);
            qa[qm].second=cnt;
        }
    }
    cdq(1,cnt);
    for(int i=1;i<=qm;i++)
        cout<<ans[qa[i].second]-ans[qa[i].first]<<endl;
}
```


------------------

### 复杂度分析和优化

那么这个算法我们写完了，它的时间复杂度是什么呢？

很遗憾， $O(n \log^2 n)$ ，比线段树要劣。

我们先看 $O(n \log^2 n)$ 是怎么来的，再看怎么把它再优化。（这个时间复杂度并不是这个算法的最优时间复杂度。)

我们用 $T(n)$ 表示分治完一个长度为 $n$ 的块的总时间复杂度。很明显，我们可以列出以下式子：

$$T(n)=2T(\dfrac{n}{2})+O(n \log n)$$

（其中那个 $O(n\log n)$ 是快排的时间复杂度和双指针算法的总时间复杂度。）

然后这个东西可以用主定理推出来 $T(n)= O(n\log^2 n)$

如果你没有学过[主定理](https://www.luogu.com.cn/blog/GJY-JURUO/master-theorem)，正好可以学学（

--------------

复杂度分析我们说完了，那么怎么优化呢？

我们注意到，复杂度的瓶颈其实在快排上，我们只要把快排去掉，我们就可以实现 $O(n\log n)$ 的优异复杂度。

我们怎么不用快排呢？

你会发现，我们实际上所排序的东西，也就是下一层分治的区间，被分成了两部分，他们分别有序。

说人话就是假设你现在在处理区间 $[l,r]$ ，设 $mid=\dfrac{l+r}{2},lmid=\dfrac{l+mid}{2}$，那么其实 $[l,lmid]$是有序的，$[lmid+1,mid]$是有序的。我们无需快排，只需要在 $\text{cdq}(l,mid)$ 之后再用一个类似于归并排序一样的东西就行。

这比较不好描述，不过以下的代码描述了这个过程。

```cpp
void cdq(int l,int r){
    if(l==r)
        return;
    int mid=(l+r)>>1,x=l,y=mid+1;
    for(int i=l;i<=r;i++)
        if(p[i].time<=mid)
            temp[x++]=p[i];
        else temp[y++]=p[i];
    for(int i=l;i<=r;i++)p[i]=temp[i];
    cdq(l,mid);
    cdq(mid+1,r);
    x=l,y=mid+1;int sum=0,now=0,all=l;
    //双指针算法
    while(x<=mid||y<=r)
        if(x<=mid&&(y>r||p[x].x<=p[y].x))
            sum+=p[x].x*p[x].y,now+=p[x].y,temp[all++]=p[x++];
        else ans[p[y].time]+=now*p[y].x-sum,temp[all++]=p[y++];
    for(int i=l;i<=r;i++)
        p[i]=temp[i];
}
```

（因为基本上只有这里有修改，所以无需把整个代码搬过来。）

如果你写过归并排序，你会发现这东西其实就是把双指针算法和归并排序的板子揉在了一块，或者说， **归并排序的合并实现就是双指针算法** 。

在双指针算法执行完了之后，你会发现 $p$ 数组回到了 $x$ 为第一个关键字排序的状态。

那么，我们这么改了之后，复杂度变成了什么?

$$T(n)=2T(\dfrac{n}{2})+\theta(n)=\theta(n\log n)$$

这样，这个算法的时间复杂度就和线段树一样了。

下面是完整代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
const int N=1e6;
int a[N];
struct query{
    int time,x,y;
}p[N],temp[N];
int cnt=0;
void add(int x,int y){
    p[++cnt].time=cnt;
    p[cnt].x=x;
    p[cnt].y=y;
}
int ans[N];
pair<int,int> qa[N];
int n,m;
void cdq(int l,int r){
    if(l==r)
        return;
    int mid=(l+r)>>1,x=l,y=mid+1;
    for(int i=l;i<=r;i++)
        if(p[i].time<=mid)
            temp[x++]=p[i];
        else temp[y++]=p[i];
    for(int i=l;i<=r;i++)p[i]=temp[i];
    cdq(l,mid);
    cdq(mid+1,r);
    x=l,y=mid+1;int sum=0,now=0,all=l;
    while(x<=mid||y<=r)
        if(x<=mid&&(y>r||p[x].x<=p[y].x))
            sum+=p[x].x*p[x].y,now+=p[x].y,temp[all++]=p[x++];
        else ans[p[y].time]+=now*p[y].x-sum,temp[all++]=p[y++];
    for(int i=l;i<=r;i++)
        p[i]=temp[i];
}
bool cmp(query a,query b){
    if(a.x!=b.x)
    	  return a.x<b.x;
    return a.time<b.time;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        add(i,a[i]-a[i-1]);
    int qm=0;
    for(int ty,l,r,x,i=1;i<=m;i++){
        cin>>ty;
        if(ty==1){//update
            cin>>l>>r>>x;
            add(l,x);
            add(r+1,-x);
        }else{
            cin>>l>>r;
            add(l,0);
            qa[++qm].first=cnt;
            add(r+1,0);
            qa[qm].second=cnt;
        }
    }
    sort(p+1,p+1+cnt,cmp);
    cdq(1,cnt);
    for(int i=1;i<=qm;i++)
        cout<<ans[qa[i].second]-ans[qa[i].first]<<endl;
}
```

完结撒花！（（（

这篇题解难免会有一些错误，如果您发现了一些错误，欢迎在评论区指出，谢谢！

## 引用：

洛谷用户“`这人太菜了`”的洛谷日报博客：[https://www.luogu.com.cn/blog/GJY-JURUO/master-theorem](https://www.luogu.com.cn/blog/GJY-JURUO/master-theorem)

Orz Orz %%%

---

## 作者：Gypsophila (赞：69)

**线段树有个地方写错了。。。所以重新审核一下**

改下题解。

这回重新发一个线段树的详解（指针版）

先安利[博客](https://www.cnblogs.com/TLE666/p/8857143.html)



今天来仔细地说一下线段树

线段树可以高效率地解决许许多多的**区间操作**

比如区间求和，把一个区间中所有的数加上常量k，区间求最大值最小值等等

#### 定义

 
-  线段树是一个完全二叉树

- 它在各个节点保存一条线段（数组中的一段子数组）

- 每个单元区间对应线段树中的一个叶结点

- **性质：父亲的区间是[l,r],(m=(l+r)/2)左儿子的区间是[l,m]，右儿子的区间是[m+1,r]，线段树需要的空间为数组大小的四倍**


#### 基本操作


这里举的是区间加与区间求和的例子

先列出来
1. 建线段树
2. 区间加
3. 区间查询和


----------


#### 建树

- 首先，需要一个结构体，来保存一个节点


```cpp
struct node
{
    int left, right;
    //表示这个节点能够在数组中管辖的线段的范围是从left到right
    
    int s;
    //表示这条线段的区间和
    
    node *ch[2];
    //节点的两个孩子，ch[0]为左孩子，ch[1]是右孩子
}pool[MAXN], *root;//pool是内存池，root是根节点
```
- 这样就能够用node来表示线段树的节点（但这还不够，详看区间加）
- 接下来是建树操作

```cpp
void Build_Tree(node *r, int left, int right)
//递归建树，指以r为根节点建线段为left至right的子树
{
    r->left = left;
    r->right = right;
    //将r->left更新为left，r->right更新为right
    if(left == right)
    //如果递归到了叶子节点
    {
        r->s = a[left];
        //单个叶子节点的区间和就是数组中的那个值
        return ;
    }
    int mid = (left + right) / 2;//详见性质
    node *lson = &pool[++cnt];//申请空间
    node *rson = &pool[++cnt];//申请空间
    r->ch[0] = lson;//让r的左子指向lson
    r->ch[1] = rson;//让r的右子指向rson
    Build_Tree(lson, left, mid);     //递归建树，详见性质
    Build_Tree(rson, mid + 1, right);//递归建树，详见性质
    r->s = r->ch[0]->s + r->ch[1]->s;//维护和
}
```


----------


#### 区间加

即给定一个区间left，right和一个需要加上的值
完成操作：让left ~ right的所有数加上一个d

- 暴力操作：一个一个点进行单点修改，复杂度$O(n \log ^ 2 n)$
- 显然复杂度不满足要求
- 所以，我们换一种方式
- **在每一个节点中加入一个懒标记，表示这个整个区间每一个数需要加上这个懒标记**
- 比如说要给$[1,4]$加上$5$，那么就让表示$[1,4]$的区间的$lazy$(懒标记)加上$5$
- 我们需要一个pushdown函数，把一个节点的懒标记转换成区间和并且下发到自己的左右两子

pushdown:
```cpp
inline void Push(node *r)
{
    if(r->lazy == 0) return ; //没有需要加的值直接return
    r->s += (r->right - r->left + 1) * r->lazy;
    //区间和加上区间的长度(right - left + 1)乘上每个数需要加上的值lazy
    if(r->ch[0]) r->ch[0]->lazy += r->lazy;
    if(r->ch[1]) r->ch[1]->lazy += r->lazy;
    //左右两子的lazy加上自己的lazy
    r->lazy = 0;
}
```
修改函数:
```cpp
void change(node *r, int left, int right, int d)
{
    //d是要加上的数
    if(r->left == left && r->right == right)
    //找到了要修改的区间
    {
        r->lazy += d;//把每个数要加的值lazy加上d
        return ;
    }
    Push(r);
    //发放lazy
    if(r->ch[0]->right >= right) change(r->ch[0], left, right, d);
    //如果左子的右端点比要查找的右端点大，则在左子中继续修改
    else if(r->ch[1]->left <= left) change(r->ch[1], left, right, d);
    //如果右子的左端点比要查找的左端点小，则在右子中继续修改
    {
          change(r->ch[0], left, r->ch[0]->right, d);
          change(r->ch[1], r->ch[1]->left, right, d);
          //否则把需要查找的区间砍成两半，分别在左右端点分别修改
    }
    Push(r->ch[0]), Push(r->ch[1]);
    //重新发放lazy（之前少了这一步带来了不便）
    r->s = r->ch[0]->s + r->ch[1]->s
    //因为修改了值，所以需要重新维护s
}
```


----------
#### 区间和
- 给你一个区间$[left, right]$,求$\displaystyle \sum_{i=left}^{right} {a_i}$
- 与区间修改相似，给一个代码

```cpp
int query(node *r, int left, int right)
{
    Push(r);//最开始Push，免得返回时再算一遍
    if(r->left == left && r->right == right) return r->s;
    if(r->ch[0]->right >= right) return query(r->ch[0], left, right);
    else if(r->ch[1]->left <= left) return query(r->ch[1], left, right);
    else
        return query(r->ch[0], left, r->ch[0]->right) + 
               query(r->ch[1], r->ch[1]->left, right);
               
}
```

这个是指针版的线段树详解希望对大家有帮助。

------------


------------


------------

最后再挂一个数组版


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n, m;
ll L = 1, a[100100];
struct st_n//SegmentTree node 线段树节点 
{
    ll left, right;//每个节点的控制范围 
    ll lazy, s;       //s表示和 
}t[300005];
void build_tree()//建线段树 
{
    while(L < n) L *= 2;
    for(ll i = 1; i <= n; i++) 
        t[i + L - 1].left = t[i + L - 1].right = i, 
        t[i + L - 1].s = a[i];//将最后一层赋值 
    for(ll i = L + n;i < 2 * L;i++)
        t[i].left = t[i].right = i - L + 1;
    for(ll i = L - 1; i >= 1; i--)
        t[i].left = t[2 * i].left,
        t[i].right = t[2 * i + 1].right,
        t[i].s += t[2 * i + 1].s + t[2 * i].s;
        //建树 
}

void push(ll id)//发放lazy值给左右子 
{
    t[2 * id].lazy += t[id].lazy;//左子 
    t[2 * id + 1].lazy += t[id].lazy;//右子 
    t[id].s += (t[id].right - t[id].left + 1) * t[id].lazy;//更新节点的值 
    t[id].lazy = 0;
}

//区间修改 
void change(ll id, ll left, ll right, ll d)
{
    if(t[id].left == left && t[id].right == right)//找到了 
    {
        t[id].lazy += d;
        return ;
    }
    push(id);//发放lazy值 
    if(t[2 * id].right >= right) change(2 * id, left, right, d);//如果左子的右管辖范围比所求大，则只在左子中继续change 
    else if(t[2 * id + 1].left <= left) change(2 * id + 1, left, right, d);//同上 
    else
    {
        change(2 * id, left, t[2 * id].right, d);
        change(2 * id + 1, t[2 * id + 1].left, right, d);
        //左右子分别查找 
    }
    t[id].s = t[2 * id].s + t[2 * id + 1].s 
            + (t[2 * id].right - t[2 * id].left + 1) * t[2 * id].lazy
            + (t[2 * id + 1].right - t[2 * id + 1].left + 1) * t[2 * id + 1].lazy;
    //上面这步很重要，它的功能也是更新（其实我原本想写个函数） 
}
ll query(ll id, ll left, ll right)//查询 
{
    //与change很像，就不多说了。 
    if(t[id].left == left && t[id].right == right)
        return t[id].s + (t[id].right - t[id].left + 1) * t[id].lazy;
    push(id); 
    if(t[2 * id].right >= right) return query(2 * id, left, right);
    else if(t[2 * id + 1].left <= left) return query(2 * id + 1, left, right);
    else return query(2 * id, left, t[2 * id].right) + query(2 * id + 1, t[2 * id + 1].left, right);
}
int main(int argc, char *argv[])
{
    cin >> n >> m;
    for(ll i = 1; i <= n; i++) cin >> a[i];
    build_tree();//建树 
    for(ll i = 1;i <= m;i++)
    {
        ll p, x, y;
        ll d;
        cin >> p >> x >> y;
        if(p == 1)
        {
            cin >> d;
            change(1, x, y, d);
        }
        else
            cout << query(1, x, y) << endl;
    }
    return 0;
}
```

---

## 作者：Nemlit (赞：67)

[原文地址](https://tbr-blog.blog.luogu.org/solution-p3372
)
# 一、概念
```
线段树，在各个节点保存一条线段
可以高效解决连续区间的修改查询问题
由于二叉结构的特性
它每次操作能保持每个操作的复杂度为O(logn)
由于是一棵二叉树
每个节点的信息都会被logn个左右的节点记录
所以空间消耗一般较大（一般是4*n）
```
# 二、操作
## 1、预处理
```
我们先考虑节点个数是2的n次方的一段区间
在这种情况下
线段树是一棵满二叉树
所以它每个非叶子结点都有两个儿子
这里叫做左儿子和右儿子
```
![luogu](https://cdn.luogu.com.cn/upload/pic/28006.png)
# ~~图好像有点丑~~
```
我们先来分析下线段树的一些性质
观察这张图不难发现
每一个节点的左儿子就是这个节点的编号乘以二
右儿子也是这个点的编号乘以二再加一
相反，如果我们要寻找一个节点的父亲节点
只需要将节点标号除以二即可
再进行推广，发现即使节点数不是2的n次方
仍然可以用上述方法查询左右儿子或者是父亲节点

所以查询操作如下：
#define ls(k) (k)*2//找左儿子
#define rs(k) (k)*2+1//找右儿子

我们也可以用位运算来优化，思路如下
#define ls(k) (k)<<1
#define rs(k) (k)<<1|1
```
```
接下来就考虑建树
建树的操作就是将一段区间不断二分
直到遍历到叶子节
到叶子节点后，我们可以开始维护我们想要维护的东西
如最大值、最小值、区间和等
之后，我们再回溯上去，把其他节点也更新

具体代码实现如下：
```
```cpp
inline void build(int k,int l,int r)
{
    if(l==r)
    {
        sum[k]=a[l];//区间和
        //min[k]=a[l];//区间最小值
        //max[k]=a[l];//区间最大值
        return;
    }
    int mid=(l+r)>>1;
    build(ls(k),l,mid);//遍历左儿子
    build(rs(k),mid+1,r);//遍历右儿子
    sum[k]=sum[ls(k)]+sum[rs(k)];//区间和
    //区间最小于区间最大代码类似，在此不做赘述
}
```
## 2、区间修改
```
这道题需要我们维护的修改操作是区间加
我认为修改操作和建树类似
也是先不断二分
如果修改的区间包括目前遍历的区间
那就回溯，否则就继续二分

具体代码实现如下：
```
```cpp
inline void ad(int k,int l,int r,int v)
{
    add[k]+=v;//懒标记，之后也会详细说明
    sum[k]+=v*(r-l+1);
}//把被包括的区间进行操作
inline void ADD(int k,int l,int r,int x,int y,int v)
{
    if(l>=x&&r<=y)
    {
        ad(k,l,r,v);
        return;
    }//如果包括遍历区间，就直接加
    int mid=(l+r)>>1;
    pushdown(k,l,r,mid);//标记下传，之后会细讲
    if(x<=mid)
    {
        ADD(ls(k),l,mid,x,y,v);
    }
    if(mid<y)
    {
        ADD(rs(k),mid+1,r,x,y,v);
    }
    sum[k]=sum[ls(k)]+sum[rs(k)];
    //和建树操作类似
}
```
## 3、区间查询
```
这道题是要我们维护区间和
那么和区间修改一样
不断二分，如果修改的区间包括目前遍历的区间
那就返回这一区间的区间和
然后回溯
把询问到的叶子节点或被包含的区间相加就是答案

具体代码如下：
```
```cpp
inline int check(int k,int l,int r,int x,int y)
{
    if(l>=x&&r<=y)
    {
        return sum[k];
    }//修改的区间包括目前遍历的区间，就返回这一区间的区间和
    int mid=(l+r)>>1,ans=0;
    pushdown(k,l,r,mid);//标记下传
    if(x<=mid)
    {
        ans=check(ls(k),l,mid,x,y);
    }
    if(mid<y)
    {
        ans+=check(rs(k),mid+1,r,x,y);
    }//把左右部分的值全都加上
    return ans;
}
```
## 4、懒标记和标记下传
```
线段树的优点不在于全记录
（那样复杂度就不是O(logn)了）
而在于传递式记录
其实线段树的维护还有另一种方法，叫做标记永久化
但是由于作者太蒟，所以在此就不作介绍了
有兴趣的话可以来切一下这些题目
```
## [1st](https://www.luogu.org/problemnew/show/P3834) ~ [2nd](https://www.luogu.org/problemnew/show/P3919)
```
标记下传的本质也和前面操作一样
如果操作一段区间
那就只要记录在这段区间公共祖先节点上
（单点其实也是区间，只不过长度为1罢了）
当我们需要查询子节点的信息的时候我们再进行更新
也就是当我们不需要查询的时候，就下传标记
要用的时候就使用标记
再将使用的标记清零
我们采用上述方式
就只需要在每次操作时下传一次标记即可
大大节省了时间
这种不仅简单粗暴，还剩时间的方法
被称为————懒标记（lazy tag）
但是在访问任何一个节点时
都需要保证该节点的祖先标记都被清空
这样才能保证正确性

具体实现如下：
```
```cpp
inline void pushdown(int k,int l,int r,int mid)
{
    if(!add[k])
    {
        return;
    }
    ad(ls(k),l,mid,add[k]);
    ad(rs(k),mid+1,r,add[k]);
    add[k]=0;
} 
```
# 三、代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls(k) (k)<<1
#define rs(k) (k)<<1|1
#define int long long
#define maxn 100005
int n,m,a[maxn],x,y,z,b,sum[maxn*4],add[maxn*4];
inline void build(int k,int l,int r)
{
    if(l==r)
    {
        sum[k]=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(ls(k),l,mid);
    build(rs(k),mid+1,r);
    sum[k]=sum[ls(k)]+sum[rs(k)];
}
inline void ad(int k,int l,int r,int v)
{
    add[k]+=v;
    sum[k]+=v*(r-l+1);
}
inline void pushdown(int k,int l,int r,int mid)
{
    if(!add[k])
    {
        return;
    }
    ad(ls(k),l,mid,add[k]);
    ad(rs(k),mid+1,r,add[k]);
    add[k]=0;
} 
inline void ADD(int k,int l,int r,int x,int y,int v)
{
    if(l>=x&&r<=y)
    {
        ad(k,l,r,v);
        return;
    }
    int mid=(l+r)>>1;
    pushdown(k,l,r,mid);
    if(x<=mid)
    {
        ADD(ls(k),l,mid,x,y,v);
    }
    if(mid<y)
    {
        ADD(rs(k),mid+1,r,x,y,v);
    }
    sum[k]=sum[ls(k)]+sum[rs(k)];
}
inline int check(int k,int l,int r,int x,int y)
{
    if(l>=x&&r<=y)
    {
        return sum[k];
    }
    int mid=(l+r)>>1,ans=0;
    pushdown(k,l,r,mid);
    if(x<=mid)
    {
        ans=check(ls(k),l,mid,x,y);
    }
    if(mid<y)
    {
        ans+=check(rs(k),mid+1,r,x,y);
    }
    return ans;
}
signed main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    build(1,1,n);
    while(m--)
    {
        cin>>b>>x>>y;
        if(b==1)
        {
            cin>>z;
            ADD(1,1,n,x,y,z);
        }
        else
        {
            cout<<check(1,1,n,x,y)<<endl;
        }
    }
    return 0;
} 
```

---

## 作者：我杀文化课 (赞：60)

更新：（之前图挂了，现在重新上传一下）



------------

今天本蒟蒻终于学了线段树，我觉得有必要来讲解一下这个极好~~毒瘤~~的算法。

## 那么，什么是线段树呢？

线段树（Interval Tree）。又名为区间树，每个结点代表的是一个区间，如图表示一个1~10区间的线段树结构。
![](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2676049308,1082598863&fm=26&gp=0.jpg)

一般来说，它可以做：

1、查询某个区间

2、修改某个区间或点

是不是觉得可以干的事很少？

~~（其实我也觉得）~~

NO！它的用处很大，对于所有区间的问题，他几乎都可以解决！并且还挺快。

好了，我们先来康康这个题。

[洛谷P3372 线段树模板](https://www.luogu.org/problem/P3372)

首先我们分析一下：题目要求我们进行区间修改+区间查询，看看上面线段树的图，是不是觉得这个算法就是为这个题而生的？！！

~~不，其实是这个题为这个算法而生的~~

那么第一个问题来了，如何建树？我们可以清楚地通过上图发现线段树的每个子节点都是由它的父亲节点**二分**而来的，再通过二叉树的性质

**我们可以知道对于一个父节点i，它的左右儿子节点分别为i乘以2，i乘以2+1**

所以我们可以根据这个性质用数组来模拟线段树，代码如下。
```cpp
void build(int id,int l,int r)
{
	tree[id].l=l;
	tree[id].r=r;//l，r代表这个节点所代表的区间的左端点和右端点。
	if(l==r)
	{
		tree[id].sum=a[l];
		return;
	}//l==r时说明它就是最下层叶子节点（只代表一个数），那么我们直接就将a数组（原始数列）的第l（或r）个元素映射上去。
	int mid=(l+r)/2;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);//二分建树
	tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;//sum表示这段区间的区间和，所以这个节点的sum值等于它的儿子节点的值之和。
}
```

现在建树问题解决了，那区间更新怎么办呢？

现在我们思考一个问题，如果我们要对这颗树上的区间加上v，是不是只用找到代表这个区间的节点（可能不止一个节点，例如[2,3]这个区间就需要查找[2,2]和[3,3]这两个区间，然后将他们的sum加起来），然后**将这个节点的sum值加上v乘以这个区间所包含的数的个数**？下次访问相同的区间的时候直接将这个数返回过去，根本就不用再向下遍历了。

但是问题又来了，上一次我对[1,2]这个区间加了v，这一次我想知道[2,3]的区间和怎么办呢？要是只用我们上面提到的方法，很明显遍历到[2,2]的时候这个点并没有加v，那返回时答案就错了呀！

怎么办？

这时延迟标记（lazy）就派上用场了，它代表我对这个区间的数加过的值，我们在对一个区间加了v之后，我们将lazy的值也加上这个v，后来我们再访问这个区间但只是访问这个区间的一部分时我们就可以知道这个父节点下面的儿子节点需要加上多少了，但我们现在不用急着将这个lazy标记给它的儿子们加上，因为这很费时，当我们下次将要访问它的儿子节点时再给他们加上lazy标记，此时这个父节点的lazy值就要清零，我们就称其为标记下传。

举个例子：我们在访问[2,3]时，我们会访问[2,2]和[3,3]这两个节点，将要访问[2,2]时，我们肯定会访问[1,2]这个点，那么在向下遍历的同时，我们就顺便将lazy标记下传，下传时就把每个叶子节点的lazy加上这个值，再按之前说到的方法更新sum。如此反复。

代码如下：
```cpp
void down(int id)
{
	tree[id*2].lazy+=tree[id].lazy;
	tree[id*2].sum+=(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy;//下传左儿子。
	tree[id*2+1].lazy+=tree[id].lazy;
	tree[id*2+1].sum+=(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy;//下传右儿子
	tree[id].lazy=0;//将标记清零
}
void update(int id,int l,int r,int v)
{
	if(tree[id].l>r || tree[id].r<l) return; //如果你要访问的区间和你遍历到的这个区间完全不重合，那么返回，相当于剪枝。
	if(tree[id].l>=l && tree[id].r<=r)
	{
		tree[id].lazy+=v;
		tree[id].sum+=(tree[id].r-tree[id].l+1)*v;
		return;
	}//如果你要访问的区间和当前遍历到的区间重合，那么就直接把lazy和sum更新，然后返回，因为没必要再向下了！
	if(tree[id].lazy>0) down(id);//之前遍历过，标记下传。
	update(id*2,l,r,v);
	update(id*2+1,l,r,v);//递归更新左右儿子
	tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;//递归回来后将左右儿子的sum加起来赋给父亲的sum。
}
```
总结一下，其实就是更新就分为这么两大步：
	
    1.判断访问区间和遍历区间的关系（相离，部分相交，完全包含）
    
    如果相离，直接返回。
   
    如果部分相交，那么就需要将标记下传（如果有），然后向下找完全包含的区间。
    
    如果完全包含，更新lazy标记，并且将sum更新（因为当前不会再向下，所以不能通过左右儿子的sum来计算）要按代码那样计算（也就是将这个节点的sum值加上v * 这个区间所包含的数的个数）
    
    在这里，我提一个问题，为什么要在更新时下传标记，貌似完全可以在查询到这个节点时下传标记啊，粗略一想，貌似挺有道理，但是仔细思考后，你会发现代码中，你更新完左右儿子回来后，会给父节点的sum值进行更新，如果按照刚才的说法，那么之前你加过的那个值就漏了，所以在更新时一定要标记下传！
   
   
	2.标记下传 
    
    先下传到左儿子
    
    再下传到右儿子
   
    下传时你需要更新儿子节点的lazy（因为它还可能有儿子，下次遍历它的儿子时要继续下传）和它的sum（与1中的sum更新方法相同）
    
    最后，将自己的lazy标记清空（否则会重复下传，造成答案错误）



------------

到了最后一步了，那就是查询，其实查询和更新很相似，也需要讨论所查询的区间和你现在遍历到的区间的关系（相离，部分相交，完全包含），查询到有lazy标记时一样要下传，就不多说了。

代码如下：

```cpp
long long query(int id,int l,int r)
{
	if(tree[id].l>r || tree[id].r<l) return 0;//相离
	if(tree[id].l>=l && tree[id].r<=r) return tree[id].sum;//完全包含
	if(tree[id].lazy>0) down(id);
	return query(id*2,l,r)+query(id*2+1,l,r);//部分包含
}
```

这就是线段树最基础的啦！

完整代码：

```cpp
#include<cstdio>
using namespace std;
int n,m,a[100010];
struct llk
{
	long long l,r,lazy,sum;
}tree[500010];
void build(int id,int l,int r)
{
	tree[id].l=l;
	tree[id].r=r;
	if(l==r)
	{
		tree[id].sum=a[l];
		return;
	}
	int mid=(l+r)/2;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);
	tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;
}
void down(int id)
{
	tree[id*2].lazy+=tree[id].lazy;
	tree[id*2].sum+=(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy;
	tree[id*2+1].lazy+=tree[id].lazy;
	tree[id*2+1].sum+=(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy;
	tree[id].lazy=0;
}
void update(int id,int l,int r,int v)
{
	if(tree[id].l>r || tree[id].r<l) return;
	if(tree[id].l>=l && tree[id].r<=r)
	{
		tree[id].lazy+=v;
		tree[id].sum+=(tree[id].r-tree[id].l+1)*v;
		return;
	}
	if(tree[id].lazy>0) down(id);
	update(id*2,l,r,v);
	update(id*2+1,l,r,v);
	tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;
}
long long query(int id,int l,int r)
{
	if(tree[id].l>r || tree[id].r<l) return 0;
	if(tree[id].l>=l && tree[id].r<=r) return tree[id].sum;
	if(tree[id].lazy>0) down(id);
	return query(id*2,l,r)+query(id*2+1,l,r);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int o,x,y;
		scanf("%d",&o);
		if(o==1)
		{
			int k;
			scanf("%d%d%d",&x,&y,&k);
			update(1,x,y,k);
		}
		else 
		{
			scanf("%d%d",&x,&y);
			printf("%lld\n",query(1,x,y));
		}
	}
}
```


---

## 作者：Kevin_Wa (赞：56)

### 说起线段树大家都不陌生。那么不会线段数的一起进入主题吧。

现在我给你一道题。

1、一共有$n$个数，给你$m$个范围，让你求范围内的数和。（$n \leq 10^6$）

这不是很简单，不是小学生的$OI$题吗？前缀和，搞定。

再加强：

2、一共有$n$个数，给你$k$个操作，让你在$l$和$r$区间内加一个数，或让你求区间内的和。（$n \leq 10^4$）

emm前缀和无力维持了。

再加强：

2、一共有$n$个数，给你$k$个操作，让你在$l$和$r$区间内加一个数，或让你求区间内的和。（$n \leq 10^6$）

这需要一种强大的数据结构线段树

下是简图(度娘上找到的)。

![线段树](https://images2015.cnblogs.com/blog/1056834/201701/1056834-20170105203630800-980605038.jpg)



线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，

由于二叉结构的特性，它基本能保持每个操作的复杂度为$O$($log$ $n$)。

线段树的每个节点表示一个区间，

子节点则分别表示父节点的左右半区间，例如父亲的区间是[$a$,$b$]，那么($c$=($a$+$b$)/$2$)左儿子的区间是[$a$,$c$]，右儿子的区间是[$c$+$1$,$b$]。

由上图可得，

1、每个节点的左孩子区间范围为[$l$，$mid$]，右孩子为[$mid$+$1$,$r$]

2、对于结点$k$，左孩子结点为$2$*$k$，右孩子为$2$*$k$+$1$，这符合完全二叉树的性质。

线段树支持五种种操作：建树、单点查询、单点修改、区间查询、区间修改。

在其他延申里还支持如区间求最值。

## 1、建树

#### a、对于二分到的每一个结点，给它的左右端点确定范围。

#### b、如果是叶子节点，存储要维护的信息，再回到父节点时累计到父节点去。

#### c、合并

### 代码

```
void build(int k,int t,int w)
{ int mid;
	if (t>w) return;
	if (t==w)
	  {
	  	tree[k].l=t;tree[k].r=w;
	  	tree[k].w=a[t];
	  	return;
	  }
	mid=(t+w)/2;
	build(k*2,t,mid);
	build(k*2+1,mid+1,w);
	tree[k].l=t;tree[k].r=w;
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
```
## 单点查询
#### 查询一个点的状态，设待查询点为x
#### a、如果当前枚举的点左右端点相等，即叶子节点，就是目标节点。
#### b、如果不是，所以设查询位置为x，当前结点区间范围为了l，r，中点为mid。
#### c、如果x<=mid，则递归它的左孩子，否则递归它的右孩子
### 代码
```
void ask(int k)
{
    if(tree[k].l==tree[k].r) //当前结点的左右端点相等，是叶子节点，是最终答案 
    {
        ans=tree[k].w;
        return ;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask(k*2);//目标位置比中点靠左，就递归左孩子 
    else ask(k*2+1);//反之，递归右孩子 
}
```

## 单点修改
#### 即更改某一个点的状态。
#### 结合单点查询的原理，找到x的位置；根据建树状态合并的原理，修改每个结点的状态。

```
void add(int k)
{
    if(tree[k].l==tree[k].r)//找到目标位置 
    {
        tree[k].w+=y;
        return;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) add(k*2);
    else add(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//所有包含结点k的结点状态更新 
}
```

## 区间查询

![线段树1](https://images2018.cnblogs.com/blog/1056834/201712/1056834-20171203210412804-1934571165.png)


代码

```
void sum(int k)
{
    if(tree[k].l>=x&&tree[k].r<=y) 
    {
        ans+=tree[k].w;
        return;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) sum(k*2);
    if(y>m) sum(k*2+1);
}
```
## 区间修改

同理

#### 我们不要递归到每个节点。所以要有一个新的概念：懒标记。

就像新年的时候的压岁钱，只有要用的时候才用，不要的直接给父母保管。

所以，传下来的更改值若在一个区间里，就不再下传，修改完该节点信息后，在此节的懒标记上打一个更改值。

当需要递归这个节点的子节点时，标记下传给子节点。这里不必管用哪个子节点，两个都传下去。

①当前节点的懒标记累积到子节点的懒标记中。

②修改子节点状态。在引例中，就是原状态+子节点区间点的个数父节点传下来的懒标记。

③父节点懒标记清0。这个懒标记已经传下去了，欠债还清，不用再还了。

### 下传代码

```
void pushdown(int k)
{
	tree[k*2].w+=((tree[k*2].r-tree[k*2].l+1)*tree[k].f);
	tree[k*2+1].w+=((tree[k*2+1].r-tree[k*2+1].l+1)*tree[k].f);
	tree[k*2].f+=tree[k].f;
	tree[k*2+1].f+=tree[k].f;
	tree[k].f=0;
}
```
### 区间修改代码

```
void add(int k,int t,int w)
{ int mid;
if (t>w) return;
	if (x<=t&&w<=y) 
	  {
	  	tree[k].w+=((w-t+1)*z);
	  	tree[k].f+=z;
	  	return ;
	  }
	mid=(t+w)/2;
	if (tree[k].f) pushdown(k); 
	if (x<=mid) add(k*2,t,mid);
	if (y>mid) add(k*2+1,mid+1,w);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
```

### 单点查询代码

```
 void ask(int k)//单点查询
{
    if(tree[k].l==tree[k].r)
    {
        ans=tree[k].w;
        return ;
    }
    if(tree[k].f) pushdown(k);//懒标记下传，唯一需要更改的地方
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask(k*2);
    else ask(k*2+1);
}
```
### 区间查询代码
```
int ask(int k,int t,int w)
{ int mid;
if (t>w) return 0;
	if (x<=t&&w<=y)
	  {
	  	return tree[k].w;
	  }
	mid=(t+w)/2;
	if (tree[k].f) pushdown(k); 
	int sum=0;
	if (x<=mid)sum+=ask(k*2,t,mid);
	if (y>mid)sum+=ask(k*2+1,mid+1,w);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
	return sum;
}
```

## 总结
```
#include<cstdio>
using namespace std;
int n,p,a,b,m,x,y,ans;
struct node
{
    int l,r,w,f;
}tree[400001];
inline void build(int k,int ll,int rr)//建树 
{
    tree[k].l=ll,tree[k].r=rr;
    if(tree[k].l==tree[k].r)
    {
        scanf("%d",&tree[k].w);
        return;
    }
    int m=(ll+rr)/2;
    build(k*2,ll,m);
    build(k*2+1,m+1,rr);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
inline void down(int k)//标记下传 
{
    tree[k*2].f+=tree[k].f;
    tree[k*2+1].f+=tree[k].f;
    tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1);
    tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1);
    tree[k].f=0;
}
inline void ask_point(int k)//单点查询
{
    if(tree[k].l==tree[k].r)
    {
        ans=tree[k].w;
        return ;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask_point(k*2);
    else ask_point(k*2+1);
}
inline void change_point(int k)//单点修改 
{
    if(tree[k].l==tree[k].r)
    {
        tree[k].w+=y;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) change_point(k*2);
    else change_point(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w; 
}
inline void ask_interval(int k)//区间查询 
{
    if(tree[k].l>=a&&tree[k].r<=b) 
    {
        ans+=tree[k].w;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) ask_interval(k*2);
    if(b>m) ask_interval(k*2+1);
}
inline void change_interval(int k)//区间修改 
{
    if(tree[k].l>=a&&tree[k].r<=b)
    {
        tree[k].w+=(tree[k].r-tree[k].l+1)*y;
        tree[k].f+=y;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) change_interval(k*2);
    if(b>m) change_interval(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
int main()
{
    scanf("%d",&n);//n个节点 
    build(1,1,n);//建树 
    scanf("%d",&m);//m种操作 
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&p);
        ans=0;
        if(p==1)
        {
            scanf("%d",&x);
            ask_point(1);//单点查询,输出第x个数 
            printf("%d",ans);
        } 
        else if(p==2)
        {
            scanf("%d%d",&x,&y);
            change_point(1);//单点修改 
        }
        else if(p==3)
        {
            scanf("%d%d",&a,&b);//区间查询 
            ask_interval(1);
            printf("%d\n",ans);
        }
        else
        {
             scanf("%d%d%d",&a,&b,&y);//区间修改 
             change_interval(1);
        }
    }
}
```
## 例题

### P3372 【模板】线段树 1

模板题

```
#include<bits/stdc++.h>
#define N 100010
#define int long long
using namespace std;
struct node{
	int l,r,w,f;
}tree[N*4];
int x,y,z,i,a[N],n,m;
void build(int k,int t,int w)
{ int mid;
	if (t>w) return;
	if (t==w)
	  {
	  	tree[k].l=t;tree[k].r=w;
	  	tree[k].w=a[t];
	  	return;
	  }
	mid=(t+w)/2;
	build(k*2,t,mid);
	build(k*2+1,mid+1,w);
	tree[k].l=t;tree[k].r=w;
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
void pushdown(int k)
{
	tree[k*2].w+=((tree[k*2].r-tree[k*2].l+1)*tree[k].f);
	tree[k*2+1].w+=((tree[k*2+1].r-tree[k*2+1].l+1)*tree[k].f);
	tree[k*2].f+=tree[k].f;
	tree[k*2+1].f+=tree[k].f;
	tree[k].f=0;
}
void add(int k,int t,int w)
{ int mid;
if (t>w) return;
	if (x<=t&&w<=y) 
	  {
	  	tree[k].w+=((w-t+1)*z);
	  	tree[k].f+=z;
	  	return ;
	  }
	mid=(t+w)/2;
	if (tree[k].f) pushdown(k); 
	if (x<=mid) add(k*2,t,mid);
	if (y>mid) add(k*2+1,mid+1,w);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
int ask(int k,int t,int w)
{ int mid;
if (t>w) return 0;
	if (x<=t&&w<=y)
	  {
	  	return tree[k].w;
	  }
	mid=(t+w)/2;
	if (tree[k].f) pushdown(k); 
	int sum=0;
	if (x<=mid)sum+=ask(k*2,t,mid);
	if (y>mid)sum+=ask(k*2+1,mid+1,w);
	tree[k].w=tree[k*2].w+tree[k*2+1].w;
	return sum;
}
int read(int &x)
{
	char c=getchar();int f=1;
	x=0;
	while (c<'0'||c>'9')
	  {
	  if (c=='-') f=-1;
	  c=getchar();
      }
	while (c>='0'&&c<='9')
      {
      	x=x*10+(int)c-48;
      	c=getchar();
	  }
	return x*f;
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(n);m=read(m);
	memset(a,0,sizeof(a));
	for (int i=1;i<=n;i++) a[i]=read(a[i]);
	build(1,1,n);
	for (int j=1;j<=m;j++)
	  { int c;
	  	c=read(c);x=read(x);y=read(y);
	  	if (c==1) 
	  	  {
	  	  	z=read(z);
	  	  	add(1,1,n);
			}
	  	else printf("%lld\n",ask(1,1,n));
	  }
	
}
```
### P3373 【模板】线段树 2

套了乘法，注意清1。

```
#include <bits/stdc++.h>//区间
#define N 400001
#define ll long long
using namespace std;

struct node{ll mul,add,val;} st[N];
ll n,m,k,c,x,y,z;
ll a[N];

void build(ll x,ll l,ll r)
{
    st[x].mul=1;st[x].add=0;
    if (l==r) {st[x].val=a[l];return;}
    ll mid=l+r>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    st[x].val=(st[x<<1].val+st[x<<1|1].val)%k;
}

void pushdown(ll x,ll l,ll r)
{
    ll mid=l+r>>1;
    st[x<<1].val=(st[x<<1].val*st[x].mul+st[x].add*(mid-l+1))%k;
    st[x<<1].mul=(st[x<<1].mul*st[x].mul)%k;
    st[x<<1].add=(st[x<<1].add*st[x].mul+st[x].add)%k;
    st[x<<1|1].val=(st[x<<1|1].val*st[x].mul+st[x].add*(r-mid))%k;
    st[x<<1|1].mul=(st[x<<1|1].mul*st[x].mul)%k;
    st[x<<1|1].add=(st[x<<1|1].add*st[x].mul+st[x].add)%k;
    st[x].mul=1;st[x].add=0;
}

void update_mul(ll x,ll l,ll r,ll ql,ll qr,ll mul)
{
    if (l>qr||ql>r) return;
    if (l>=ql&&qr>=r)
        {
            st[x].val=(st[x].val*mul)%k;
            st[x].mul=(st[x].mul*mul)%k;
            st[x].add=(st[x].add*mul)%k;
            return;
        }
    ll mid=l+r>>1;
    pushdown(x,l,r);
    update_mul(x<<1,l,mid,ql,qr,mul);
    update_mul(x<<1|1,mid+1,r,ql,qr,mul);
    st[x].val=(st[x<<1].val+st[x<<1|1].val)%k;
}

void update_add(ll x,ll l,ll r,ll ql,ll qr,ll add)
{
    if (l>qr||ql>r) return;
    if (l>=ql&&qr>=r)
        {
            st[x].val=(st[x].val+add*(r-l+1))%k;
            st[x].add=(st[x].add+add)%k;
            return;
        }
    ll mid=l+r>>1;
    pushdown(x,l,r);
    update_add(x<<1,l,mid,ql,qr,add);
    update_add(x<<1|1,mid+1,r,ql,qr,add);
    st[x].val=(st[x<<1].val+st[x<<1|1].val)%k;
}

ll query(ll x,ll l,ll r,ll ql,ll qr)
{
    if (l>qr||ql>r) return 0;
    if (l>=ql&&qr>=r) return st[x].val;
    ll mid=l+r>>1;
    pushdown(x,l,r);
    return (query(x<<1,l,mid,ql,qr)+query(x<<1|1,mid+1,r,ql,qr))%k;
}

int main()
{
    scanf("%lld%lld%lld",&n,&m,&k);
    for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
    build(1,1,n);
    for (int i=1;i<=m;i++)
        {
            scanf("%lld%lld%lld",&c,&x,&y);
            if (c==1) scanf("%lld",&z),update_mul(1,1,n,x,y,z);
            if (c==2) scanf("%lld",&z),update_add(1,1,n,x,y,z);
            if (c==3) printf("%lld\n",query(1,1,n,x,y));
        }
    return 0;
}
```
### P1440 求m区间内的最小值

可能线段树不是最优，但要知道线段也支持这个操作

```
#include<bits/stdc++.h>
#define N 2000010
using namespace std;
struct node{
	int l,r,w,f;
}tree[N*2+1];
int x,y,z,i,a[N],n,m;
void build(int k,int t,int w)
{ int mid;
	if (t>w) return;
	if (t==w)
	  {
	  	tree[k].l=t;tree[k].r=w;
	  	tree[k].w=a[t];
	  	return;
	  }
	mid=(t+w)/2;
	build(k*2,t,mid);
	build(k*2+1,mid+1,w);
	tree[k].l=t;tree[k].r=w;
	tree[k].w=min(tree[k*2].w,tree[k*2+1].w);
}
int ask(int k,int t,int w)
{ int mid;
if (t>w) return 0;
	if (x<=t&&w<=y)
	  {
	  	return tree[k].w;
	  }
	mid=(t+w)/2;
	int sum=INT_MAX;
	if (x<=mid)sum=min(sum,ask(k*2,t,mid));
	if (y>mid)sum=min(sum,ask(k*2+1,mid+1,w));
	return sum;
}
int read(int &x)
{
	char c=getchar();int f=1;
	x=0;
	while (c<'0'||c>'9')
	  {
	  if (c=='-') f=-1;
	  c=getchar();
      }
	while (c>='0'&&c<='9')
      {
      	x=x*10+(int)c-48;
      	c=getchar();
	  }
	return x*f;
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(n);m=read(m);
	memset(a,INT_MAX,sizeof(a));
	for (int i=1;i<=n;i++) a[i]=read(a[i]);
	build(1,1,n);
	for (int i=1;i<=n;i++)
	  { int c;
	  	x=i-m;y=i-1;
	  	if (x<=0) x=1;
	  	if (x>y) 
	  	  {
	  	  	printf("0\n");
	  	  	continue;
			}
	  	printf("%d\n",ask(1,1,n));
	  }
	
}
```


---

## 作者：ttjb (赞：44)

线段树在区间查询和区间修改上有两种操作，一是标记下传，二是标记永久化。前者许多神犇都发过了，我就捡个漏，发一篇标记永久化的题解。

顾名思义，两者的区别就是在处理标记时，前者把标记下传到两个儿子身上同时自己清零；而后者则一步处理好自己的标记。相对而言，标记永久化的代码更短，在树套树及可持久化数据结构中使用较为方便，但同时操作技巧要求更高，也不容易理解（我当初搞了两天），希望我的经验能对大家有所帮助qwq。

----------------------------------

先申明几个参数：k表示当前节点的序号，v表示要增加的数（根据题意，要用 long long），l 和 r 表示当前节点所管辖的区间，x 和 y 表示要修改或询问的区间的区间，其他参数都是通用的那个意思了。

重点讲修改和查询的两个函数，讲解的模式是先放整个函数的代码块，然后是某一步的代码块及其讲解。某一步的讲解也可能在下文有进一步补充。

本人讲解难免不清，建议读者边看边画图加深理解。

### 修改函数modify( )

```cpp
void modify(int k,ll v,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		add[k]+=v;
		return; 
	}
	sum[k]+=(min(r,y)-max(l,x)+1)*v;
	int mid=(l+r)/2;
	if(x<=mid) modify(k*2,v,l,mid,x,y);
	if(mid<y) modify(k*2+1,v,mid+1,r,x,y);
}
```

##### 递归边界：

```cpp
if(x<=l&&r<=y)
	{
		add[k]+=v;
		return; 
	}
```

试想，如果当前的区间被要修改的区间所覆盖，就意味着当前区间内所有的子节点都要修改，就没必要继续递归下去（这就是线段树的优势），直接打上标记行了，而sum值不需要改动（此操作在下文有照应）。


##### sum值修改
```cpp
	sum[k]+=(min(r,y)-max(l,x)+1)*v;
```

线段树每个节点所管辖的区间是通过二分来分配的，但实际上要修改的区间往往是由某些区间的全部和另外一些区间的一部分组成的。

这就意味着有一些区间是只有一部分要修改，这种情况时，就不能直接修改add标记了，（因为标记本身无法记录具体作用在哪个部分上） 只好直接修改sum值。

那么这一部分是怎么计算得来的呢？我们一右端点为例，分类讨论。

1、如果当前区间的右端点（r）在修改区间的右端点（y）的左边（即r<y），显然当前区间的右端点内（即右端点往左）的都要改，以外（即往右）的它管不着。所以要处理的区间的右端点为r；

2、反之，修改区间的右端点（y）在当前区间的右端点（r）的左边（即y<=r），则修改区间的右端点内的区间显然都要加上v，则修改区间的右端点外的区间虽说当前节点管得着，但并不要求这部分修改。所以要处理的区间右端点为y；

综上，就有了min ( r , y ) 。

左端点同理。

##### 递归条件。

```cpp
	int mid=(l+r)/2;
	if(x<=mid) modify(k*2,v,l,mid,x,y);
	if(mid<y) modify(k*2+1,v,mid+1,r,x,y);
```

这步比较好理解，如果要修改的区间与当前节点的左儿子有交集（即 x <= mid ），才递归左儿子，右儿子同理。

### 查询函数query( )

形式上和modify函数很像。

```cpp
ll query(int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y) 
		return sum[k]+(r-l+1)*add[k];
	ll res=(min(r,y)-max(l,x)+1)*add[k];
	int mid=(l+r)/2;
	if(x<=mid) res+=query(k*2,l,mid,x,y);
	if(mid<y)  res+=query(k*2+1,mid+1,r,x,y);
	return res;
}
```
##### 返回值res的处理 1

应该会有读者感到奇怪（包括当年的我），为什么又要加add值，又要加sum值，会不会有重复的呢？但只要理解了modify函数，就很简单了。

当前区间，有可能只被修改了一部分，有可能只试过整个区间被修改，也可能同时都有或都没有。我们不妨分类讨论。

1、若只被修改过一部分，那么sum值已经把要修改的部分加上了，而因为不曾试过整个区间被修改，所以其add值为0，加上也无妨。

所以返回sum+add； 

2、若只试过整个区间被修改，那么sum值不曾被修改过，标记都打到add上了。

所以返回sum+add；

3、若两者都曾试过，sum值负责加上“一部分”的那些，add值负责加上“整个区间”的那些 。

所以两个都要加上，返回sum+add；

4、若都没试过··· 结合以上几点感性易证，应返回sum+add。

综上，把sum和add都加上就对了。

另外，对于sum值，由于它针对的是整个区间，无法分割，这既导致了它不能立刻加上，但也使得它在递归达到边界时最终一定会被补上。

然后再对每一步补充一下。

##### 递归边界。

```cpp
	if(x<=l&&r<=y) 
		return sum[k]+(r-l+1)*add[k];
```

很简单，既然当前区间都被查询区间给覆盖了，那肯定sum和add都要加上啦~

```cpp
	ll res=(min(r,y)-max(l,x)+1)*add[k];
```

##### 返回值res的处理 2

此处为什么只加add值呢？那是因为当前节点并没有被查询区间给完全覆盖，为什么要加add值和add值针对的区间即(min(r,y)-max(l,x)+1)的由来前文已提。至于sum值，由于它针对的是整个区间，无法分割，这既导致了它不能立刻加上，但也使得它在递归时最终一定会被补上。

当然res还要加上两个儿子的（如果满足递归条件的话）。

至于递归条件与前文相同，此处便不再赘述。

---------------------

终于——完整的AC代码来了，一些细节也会在里面补充。

```cpp
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int M=100005;
int n,m;
ll a[M],sum[M*4],add[M*4];
//别忘了，线段树要开4倍大小的数组
//根据题意，要用long long ,被坑了好几次
void build(int k,int l,int r)//建树，很简单
{
	if(l==r)
	{
		sum[k]=a[l];   //我曾手残sum[k]=l >_<
		return;
	}
	int mid=(l+r)/2;   //这些地方可以用位运算优化
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	sum[k]=sum[k*2+1]+sum[k*2];
	return;
}
void modify(int k,ll v,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)
	{
		add[k]+=v;
		return; 
	}
	sum[k]+=(min(r,y)-max(l,x)+1)*v;
	int mid=(l+r)/2;
	if(x<=mid) modify(k*2,v,l,mid,x,y);
	if(mid<y)  modify(k*2+1,v,mid+1,r,x,y);
}
ll query(int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y) 
		return sum[k]+(r-l+1)*add[k];   //我曾又手残sum[k]+(r-l+1)*a[k] >_<
	ll res=(min(r,y)-max(l,x)+1)*add[k];
	int mid=(l+r)/2;
	if(x<=mid) res+=query(k*2,l,mid,x,y);
	if(mid<y)  res+=query(k*2+1,mid+1,r,x,y);
	return res;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	build(1,1,n);
	for(int i=1,x,y;i<=m;i++)
	{
		scanf("%d",&x);
		if(x==1)
		{
			ll z;   //此处也要long long
			scanf("%d%d%lld",&x,&y,&z);//读入时要long long  >_<
			modify(1,z,1,n,x,y);
		}
		else
		{
			scanf("%d%d",&x,&y);
			printf("%lld\n",query(1,1,n,x,y));//输出是也要long long  >_<
		}
	}
	return 0;
 } 
```

------------

当然，你可能无法马上理解，但你可以再看几次，再画几个图，或者隔几天再想。无论是为了线段树的强大功能，还是陶醉于信息学本身的魅力，我都衷心地祝愿每一个读者能理解标记永久化的写法。

最后，本人来发表一下感言qwq。

1. 感谢洛谷提供的好平台；

2. 感谢管理员大大的辛勤付出；

3. 感谢信息学奥赛一本通·提高篇的详细讲解 ~~其实不怎么详细~~；

4. 感谢自己~~入坑~~学信竞以来不懈的努力；

5. 感谢随手留赞的你。

---

## 作者：LPA20020220 (赞：36)

（这是一篇走错了的题解）

线段树的所有操作都可以在平衡树上实现，并且平衡树可以实现很多线段树无法达到的操作，比如分裂、合并区间。虽然常数会大一些，但是显然用处更广.

关于更多有关平衡树的操作，请详见 P3391 【模板】文艺平衡树（Splay）

在这里，splay排序的依据是数据的顺序而不是数值的大小，也就是说按照先序遍历就可以输出原序列的所有数。

Splay基于伸展操作，可以将任何一个节点提到根节点的位置来，这使得我们的pushdown操作有了新写法：将左区间端点的前一个点旋至根节点，将右区间的端点的后一个点旋转至根节点的右儿子处，这样它的左子树就是我们想查询/更改的区间了，只需打上标记即可。

而值得注意的是，如果要旋转第一个节点势必会引起冲突，所以我们插入时从2开始插入真正的数值，将1和n+2留空避免RE。

以下是代码及注释：

  

//============================================================================

    
```cpp
    // Name        : splay_seg.cpp
    // Author      : LPA
    // Version     :
    // Copyright   : All rights reserved
    // Description : splay_tree to mock segment tree
    //============================================================================
    #include<cstdio>
    #include<algorithm>
    #include<cstdlib>
    #include<cctype>
    using namespace std;
    #define gc getchar()
    #define R register
    #define W while
    #define IN inline
    int root;
    int dot;
    bool fu;
    IN void in(int &x)//快读，注意有负数
    {
        fu=false;x=0;char c=gc;
        W(!isdigit(c))
        {
            if(c=='-')fu=true;
            c=gc;
        }
        W(isdigit(c))
        {
            x*=10;x+=c-48;c=gc;
        }
        if(fu)x=0-x;
    }
    struct Splay
    {
        int son[2],father,value,delta,below;
        long long tot;//一定要开longlong，否则会溢出
    }tree[100005];
    IN void maintain(int now)//维护，也就是pushup
    {
        tree[now].tot=tree[now].value;
        tree[now].tot+=tree[tree[now].son[0]].tot+tree[tree[now].son[1]].tot;
        if(now!=1&&now!=dot+2)//注意，两个虚拟节点不能在子树大小中计算自己，否则输出时会多算
        tree[now].below=1;
        tree[now].below+=tree[tree[now].son[0]].below+tree[tree[now].son [1]].below;
    }
    IN void ensure(int now)//为了确保两个虚拟节点为0，在递归建树后重新pushup一遍
    {
        tree[now].below=0;
        tree[now].value=0;
        tree[now].tot=0;
        now=tree[now].father;
        while(true)
        {
            maintain(now);
            if(now==root)return;
            now=tree[now].father;
        }
    }
    IN void addit(int now,int val)//下放标记，注意要立即更改子树总和值，否则若马上查询更改区间会翻车
    {
        if(!now)return;
        tree[now].tot+=tree[now].below*val;
        tree[now].delta+=val;
        tree[now].value+=val;
    }
    IN void pushdown(int now)
    {
        if(tree[now].delta)
        {
            addit(tree[now].son[0],tree[now].delta);
            addit(tree[now].son[1],tree[now].delta);
            tree[now].delta=0;
        }
    }
    void build(int lef,int rig,int fa,bool typ)//先建一棵相对平衡的树保证时间复杂度
    {
        if(lef>rig)return;
        int mid=(lef+rig)>>1;
        tree[mid].below=1;
        tree[mid].father=fa;
        tree[fa].son[typ]=mid;
        tree[mid].tot=tree[mid].value;
        build(lef,mid-1,mid,0);
        build(mid+1,rig,mid,1);
        maintain(mid);
    }
    IN bool get(int now)//获取自己和父亲节点的关系：0代表左儿子，1代表右儿子
    {
        if(tree[tree[now].father].son[0]==now)return 0;
        return 1;
    }
    IN void rotate(int now)//splay经典旋转操作
    {
        int fa=tree[now].father;int gra=tree[fa].father;
        bool dir=get(now);
        tree[fa].son[dir]=tree[now].son[dir^1];
        tree[tree[now].son[dir^1]].father=fa;
        if(gra)tree[gra].son[get(fa)]=now;
        tree[now].father=gra;
        tree[fa].father=now;
        tree[now].son[dir^1]=fa;
        maintain(fa);
        maintain(now);
    }
    IN void updata(int now)//保证在伸展操作之前所有标记都已下传
    {
        int k=root;
        W(233)
        {
            pushdown(k);
            if(now==k)break;
            if(now>k)k=tree[k].son[1];
            else k=tree[k].son[0];
        }
    }
    IN void splay(int now , bool typ)
    {
        updata(now);
        if(!typ)//旋至根节点
        {
            W(tree[now].father)
            {
                rotate(now);
                root=now;
            }
            root=now;
        }
        else//旋至根节点右儿子
        {
            W(tree[tree[now].father].father)
            rotate(now);
            tree[root].son[1]=now;
        }
    }
    IN void change(int lef,int rig,int val)//更改区间
    {
        splay(lef,0);
        splay(rig+2,1);
        addit(tree[tree[root].son[1]].son[0],val);
        maintain(tree[root].son[1]);//注意同时也把这两个节点更新了
        maintain(root);
    }
    IN void query(int lef,int rig)//很简洁有木有
    {
        splay(lef,0);
        splay(rig+2,1);
        printf("%lld\n",tree[tree[tree[root].son[1]].son[0]].tot);
    }
    int main(void)
    {
        int num,a,b,c,d;
        in(dot),in(num);
        for(R int i=2;i<=dot+1;++i)
            {in(tree[i].value);}
        build(1,dot+2,0,0);
        root=(dot+3)>>1;
        ensure(1);
        ensure(dot+2);
        while(num--)
        {
            in(a);
            if(a==1)
            {
                in(b),in(c),in(d);
                change(b,c,d);
            }
            else
            {
                in(b),in(c);
                query(b,c);
            }
        }
    }

```

---

## 作者：arfa (赞：26)

> ## 浅谈分块

#### 分块的用处?

分块可以处理区间的问题,作用类似于线段树。

#### 分块的优缺点?

$I.$分块的查询的时间复杂度的上界为$O(1)$,下界为$O(sqrt(n))*3$,平均是$O(sqrt(n))$。而线段树的上界是为$O(1)$,下界是为$O(log\ n)$,平均也是$O(log\ n)$。

$II.$不过分块就是一个数组,所以空间复杂度是比较绝对的线性的,算起来就是$sqrt(n)*2+n$,就是$O(n)$。而线段树是$2*n$,虽然是$O(n)$,不过也是有点容易被卡的。

$III.$最后分块比较容易理解,适用于新手。

> ### 分块思想:优雅暴力

我们把一个数组(数的总数为$n$),分成$k$块,每一块有$kk$个数。怎么分呢?告诉你$kk$严格等于$sqrt(n)$,为什么?因为要均摊时间复杂度啊!(理解一下)


那么$k$一定有$sqrt(n)$块咯(因为$sqrt(n)^2=n$)。错!如果$k^2<>n$(也就是$n$不能被整开方),$k+=1/inc(k)$。(因为$n$并不一定完全平分)

好了,假设我们已经分好块了,我们要怎么知道下标为$n$的块是第几块?

$I.$假如$kk=4$。那么$1-4$是第一块,$5-8$是第二块,$9-12$是第三块.....

$II.$我们可以推出,如果$n\ mod\ kk=0$,那么下标$n$的块就是$n\ div\ kk$。否则就是$n\ div\ kk+1$。

```
1 2 3 4 5 6 7 8 9 10
■ ■ ■ ■ ■ ■ ■ ■ ■ ■
■■■■■ ■■■■■ ■■■■■ ■■■■■
```
$10$个数分为$4$块,每$1$块$3$个数。

> ### 分块怎么用?

我们分了块以后,我们就可以对其进行区间操作。首先先声明一些变量:$intersum,interadd,num$,意思分别为**一整块的值,整体加了多少,和一开始给的值**。

假如我们要把区间$l,r$全部加上$add$的话,我们就看这个区间内最左边的块的左下标和最右边的块的右下标(为了找出中间的块总和)。然后我们就对所有中间的块的$intersum[i]+add$,而多出来的,就$num[j]+add$就可以了(当然$i$可以重复用)。

也就是这样:

```
我修改(查询)区间3-10。

1 2 3 4 5 6 7 8 9 10
■ ■ ■ ■ ■ ■ ■ ■ ■ ■
■■■■■ ■■■■■ ■■■■■ ■■■■■
    ◆ ■■■■■■■■■■ ◆
```

其中◆就是要暴力$+add$的,而■就是一块一块区间加的。(要注意值改变的同时,$intersum$也要加)

无论是区间修改操作,还是区间查询操作,都可以这样弄。

> #### $Code$

如果要看实现详情和细节,请看[剪贴板](https://www.luogu.org/paste/c914o3sg)。


> ### 猜想

我们再想一想,线段树可以干什么?

线段树可以求区间最大值,分块可以吗?假如我们有数组$intermax$存储的是区间最大,我们就可以对$l,r$区间进行最大块$max$,然后对多余的进行单个数$max$。这样子其实很多余,真的就不如$O(n\ log\ n)$或者$ST$表。(分块实现下界是$O(sqrt(n)*3)$)。

线段树有权值线段树,分块可以存储权值吗?假如我们像求逆序对一样,每一个数(也就成了桶)都储存这出现次数。我们对其分块后,想要找$a_i$的逆序对,就直接在区间$l,i$区间和就可以了。

线段树分割出来主席树,分块又能怎样升华呢?那么本人很弱,就留给大家自己想吧。

> ### 例题

$I.$[线段树1](https://www.luogu.org/problemnew/show/P3372) [区间和](https://www.luogu.org/problemnew/show/P2068) 随便搞一搞。

$II.$[线段树2](https://www.luogu.org/problemnew/show/P3373) 也是随便搞一搞,用分块可能会比线段树打懒标记好一些。

感谢 @larryzhong 大佬,推荐了这道题:[教主的魔法](https://www.luogu.org/problemnew/show/P2801)。这道题就是典型的分块的题目。为什么怎么了容易看出?

$N\leq1000000$。好的,还不信这道题一定要$O(n)$的复杂度。要注意线段树的点数是$2*N-1$。如果遇到的题空间很紧,请用分块。


至于区间问题,分块就很容易解决的啦。

(认真看完题目回来发现这题要用主席树qwq,是所以还是水分块吧qwq)

---

## 作者：JustinRochester (赞：23)

[题目](https://www.luogu.com.cn/problem/P3372)

刚刚学了树状数组的区间加法和区间求和操作，就用来水掉这题了

本篇适合学会树状数组的人群

前置芝士：

[普通树状数组](https://www.luogu.com.cn/problem/P3374)

[差分树状数组](https://www.luogu.com.cn/problem/P3368)

---

**【分析】**
---

学过树状数组的人都知道，我们对于一个数组，进行处理后，就可以在 $O(\log n)$ 的时间内进行单点修改和区间求和

假设对于数组 $a_n$ ，我们用树状数组的方法处理后，就可以单点修改任意 $a_i$ 的值，或者求 $\displaystyle \sum_{i=l}^r a_n$

如果我们差分一下 $a_n$ ，设 $c_n=a_n-a_{n-1}$ ，那就可以使得树状数组区间修改和单点查询 $\displaystyle a_n=\sum_{i=1}^n c_i$

---

在差分的基础下，我们如果需要求区间和，则先相同地：

$\displaystyle \sum_{i=l}^ra_i=\sum_{i=1}^ra_i-\sum_{i=1}^{l-1}a_i$

所以，在此基础上，我们只需要求解 $\displaystyle \sum_{i=1}^k a_i$ 即可求解区间求和问题了

我们变型这个式子：

$\displaystyle \sum_{i=1}^k a_i=\sum_{i=1}^k\sum_{j=1}^ic_i=\sum_{i=1}^k(k+1-i)c_i$

这玩意儿没办法直接求，所以我们把它分开来：

$\displaystyle \sum_{i=1}^k a_i=(k+1)\sum_{i=1}^k c_i-\sum_{i=1}^k ic_i$

这样，就能分开来，用树状数组实现求和了。

因此，我们只需要实现 $c_n$ 和 $nc_n$ 的树状数组，即可以实现区间求和

即前者： $c_n$ 差分树状数组的区间和，乘上 $(k+1)$ ，减去后者： $nc_n$ 差分树状数组的区间和

---

当然，我们还应考虑修改对吧

假设修改区间 $[l,r]$ 都加上 $a$

首先， $c_n$ 的修改肯定是没问题的：$c_l+=a,c_{r+1}+=-a$

分解为差分树状数组单点修改 $c_l$ 和 $c_{r+1}$

而我们很清楚，假设 $c_i$ 转变为 $(c_i+a)$

则有 $ic_i$ 转变为 $i(c_i+a)=ic_i+ia$

也就是说，$ic_i+=ia$ ，而 $ic_i$ 的增加对本身累加了 $ic_i$ 的贡献都是增加 $ia$ 的

所以只要在修改 $c_i+=a$ 的时候，顺便修改 $ic_i+=ia$ 即可

---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了：

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
#define LOCAL
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
const i32 MAXN=1e5+10;
typedef i64 ar[MAXN];
//一堆条件反射的定义

namespace HABIT{//读入输出优化而已，直接跳过看正文即可
    #ifdef LOCAL
        inline char gc() { return getchar(); }
    #else
        inline char gc() {
            static char s[1<<20|1]={0},*p1=s,*p2=s;
            return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
        }
    #endif
    inline i32 read(){
        register i32 ans=0;register char c=gc();register bool neg=0;
        while(c<48||c>57) neg^=!(c^'-'),c=gc();
        while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
        return neg?-ans:ans;
    }

    char Output_Ans[1<<20|1],*Output_Cur=Output_Ans;
    inline void output() { Output_Cur-=fwrite(Output_Ans,1,Output_Cur-Output_Ans,stdout); }
    inline void print(char c){ if(Output_Cur-Output_Ans+1>>20) output(); *(Output_Cur++)=c; }
    inline void print(char *s) { while(*s) print( *(s++) ); }
    inline void print(u64 x){
        if(!x) { print('0'); return ; }
        char buf[30]={0},*p=buf+28;
        while(x) *(p--)=x%10+48,x/=10;
        print(p+1);
    }
    inline void print(i64 x){ if(x<0) print('-'),x=-x; print( (u64)x ); }
}
using namespace HABIT;

//正文开始
i32 d_N,d_M;
ar ar_d_iC,ar_d_C;

inline void add(i32 pos,i64 a){
    const i32 ia=a*pos;
    for(i32 i=pos;i<=d_N;i+=(i&(-i)))//树状数组基操，不停加 lowbit(i)
        ar_d_iC[i]+=ia,ar_d_C[i]+=a;//ici+=ia,ci+=a
}
inline i64 sum(i32 pos){//(pos+1)*求和 ci -求和 ici
    i64 d_Ans=0;
    for(i32 i=pos;i;i-=(i&(-i))) d_Ans+=ar_d_C[i];
    d_Ans*=(pos+1);
    for(i32 i=pos;i;i-=(i&(-i))) d_Ans-=ar_d_iC[i];
    return d_Ans;
}

inline void update(i32 h,i32 t,i64 a) { add(h,a); add(t+1,-a); }
inline i64 query(i64 h,i64 t) { return sum(t)-sum(h-1); }

int main(){
    d_N=read(),d_M=read();
    f(i,1,I,d_N) update(i,i,read());
    f(i,1,I,d_M)
        if(read()==1){
            i32 h=read(),t=read();
            update(h,t,read());
        }
        else{
            i32 h=read(),t=read();
            print(query(h,t)),print('\n');
        }
    output();
    return 0;
}
```

最后安利以下 [本蒟蒻的博客](https://www.luogu.com.cn/blog/JustinRochester/)

---

## 作者：Jaanai (赞：16)

# 算法名：线段树/Segment Tree

在大家做题的时候

难免会遇到一些要求单点/区间查询/修改的问题

其中单点操作可以用数组$O(1)$实现

但是区间操作用数组需要$O(n)$的复杂度

这样的代价是非常高的

因此，我们引入一个新的数据结构：线段树

它长这样：

![线段树示意图](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_1.png)

在建树的时候，有两种建树方法：

按照已有数组建树，或动态开点

其中第一种方法可能会MLE（如果题目给你一个很大的数组但只有几个数字已知的话）

所以我直接介绍动态开点：（其实就是单点修改的过程）

## 单点修改

```cpp
// root需要引用传递，t为修改的叶子节点编号（相当于对应的数组编号），x为增加的值
void Update(int &root, int l, int r, int t, int x) {
  if (root == 0) root = ++cnt; // root和cnt预处理为0，当这个节点不存在时就分配一个新的节点
  sum[root] += x; // sum[i]数组表示以编号为i的节点为根的树的叶子节点值之和
  if (l == r) return;
  int mid = (l + r) >> 1;
  if (t <= mid) Update(ll[root], l, mid, t, x);
      // ll[i]表示编号为i的节点的左儿子的编号（预处理为0）
  else Update(rr[root], mid + 1, r, t, x);
      // rr[i]表示编号为i的节点的右儿子的编号（预处理为0）
}
```

~~我知道没有图解你们是看不懂的~~

这里以

```cpp
Update(root, 1, 16, 5, 8);
Update(root, 1, 16, 6, 7);
Update(root, 1, 16, 10, 3);
```

为例：

首先发现root为0

也就是说我们这棵树还没有建

因此root变为1：

![线段树图解1](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_2.png)

然后向下递归，发现`5 <= mid`且`ll[1]`为0

因此开一个点（`ll[1] = 2`）：

![线段树图解2](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_3.png)

然后继续递归，发现`5 > mid`且`rr[2]`为0

因此开一个点（`rr[2] = 3`）：

![线段树图解3](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_4.png)

继续递归，发现`5 <= mid`且`ll[3]`为0

因此开一个点（`ll[3] = 4`）：

![线段树图解4](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_5.png)

继续递归，发现`5 <= mid`且`ll[4]`为0

因此开一个点（`ll[4] = 5`）：

![线段树图解5](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_6.png)

然后发现`l == r`，回溯，5号点插入完毕

接下来是第二个点

首先发现 `root == 1`

因此直接修改一号节点：

![线段树图解6](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_7.png)

然后向下递归，发现`6 <= mid`且`ll[1]`为2

因此直接修改二号节点：

![线段树图解7](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_8.png)

继续递归，发现`6 > mid`且`rr[2]`为3

因此直接修改三号节点：

![线段树图解8](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_9.png)

继续递归，发现`6 <= mid`且`ll[3]`为4

因此直接修改四号节点：

![线段树图解9](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_10.png)

继续递归，发现`6 > mid`且`rr[4]`为0

因此新建一个节点：

![线段树图解10](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_11.png)

然后是第三个，下标为10，增加3

这里不多赘述了，直接给出结果：

![线段树图解最终结果](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Segment%20Tree_12.png)

但我相信大家结合代码应该都看懂了

那么我们就介绍下一种操作

## 单点/区间查询

首先说**区间查询**

这里先上代码：

```cpp
// 当前节点是root，root对应的区间是[l,r]，要查[x,y]的和
int Query(int root, int l, int r, int x, int y) {
  if (l == x && r == y) return sum[root];
      // 如果查询区间与已知区间吻合，直接返回这段区间的和
  int mid = (l + r) >> 1, suml = 0, sumr = 0;
  if (x <= mid) suml = Query(ll[root], l, mid, x, min(mid, y));
      // 要查的区间的左端点被左儿子区间包含的时候，也就是说要查的区间和左儿子区间有交集
  if (y > mid) sumr = Query(rr[root], mid + 1, r, max(mid + 1, r), y);
      // 要查的区间的右端点被右儿子区间包含的时候，也就是说要查的区间和右儿子区间有交集
  return suml + sumr;
}
```

这里大家可以拿张纸对着画一下。~~当然如果您够巨应该是能直接看懂的~~

那么单点查询怎么实现呢？

其实很简单，比如要查5号，只需

```cpp
Query(root, 1, 16, 5, 5);
```

就是这样\~

那么下面我们讲线段树的专长：

## 区间修改

对于区间修改，最暴力的方法就是区间内每个点都改一遍

这样下来复杂度是$O(n\log{n})$的

很明显这样时间复杂度就退化了

这里我们讲一个叫Lazy Tag（懒标记）的东西

当修改区间在递归过程中和原区间吻合的时候，我们便在该节点上放上值为所要修改的值的标记

等将来执行查询操作的时候再一边递归一边修改



这样的时间优势在于先进行了时间复杂度为$O(\log{n})$的标记设置操作

但没有直接单独进行时间复杂度为$O(n\log{n})$的下放标记并修改的操作

而是将其嵌入查询操作中，随着查询层数的深入而逐层修改并下放标记

这样的复杂度仍是$O(\log {n})$的



那么代码怎么实现呢？

我们可以利用函数重载来区分单点修改与区间修改

```cpp
//当前节点编号，当前节点对应的区间，要修改的区间编号，增加的值
void Update(int &root, int l, int r, int p, int q, int x) {
  if (root == 0) root = ++cnt;
  int num = min(r, q) - max(l, p) + 1; // 当前节点对应区间与查询区间的交集的长度
  sum[root] += x * num;
      // 因为上述交集的每一个元素都要加x，共num个元素，所以root的sum要这样加
  if (l == p && r == q) { // 按上文所说，两区间吻合后执行设置标记操作
    tag[root] += x;
    return; // 本函数内不再执行更深的操作，直接回溯
  }
  int mid = (l + r) >> 1;
  if (p <= mid) Update(ll[root], l, mid, p, min(mid, q), x);
  if (q > mid) Update(rr[root], mid + 1, r, max(mid + 1, p), q, x);
      // 这两处if的作用是递归进入时确保两子区间与查询子区间有交集，防止num为负
}
```

那么下放标记并修改怎么实现呢？我们说了，要将它嵌入查询操作。

我们在查询操作函数中在分子区间查询前先将标记下放到两个子区间。

该函数改为这样：

```cpp
int Query(int root, int l, int r, int x, int y) {
  if (l == x && r == y) return sum[root];
  // 在我下面QwQ
  Down(root, l, r);
  // 在我上面QWQ
  int mid = (l + r) >> 1, suml = 0, sumr = 0;
  if (x <= mid) suml = Query(ll[root], l, mid, x, min(mid, y));
  if (y > mid) sumr = Query(rr[root], mid + 1, r, max(mid + 1, r), y);
  return suml + sumr;
}
```

对应的Down函数：

```cpp
inline void Down(int root, int l, int r) {
  if (ll[root] == 0) ll[root] = ++cnt;
  if (rr[root] == 0) rr[root] = ++cnt;
  tag[ll[root]] += tag[root], tag[rr[root]] += tag[root];
      // 将标记下放到子区间
  int mid = (l + r) >> 1;
  sum[ll[root]] += tag[root] * (mid - l + 1);
      // 左子区间的和的增加，即对应标记的值（要修改的值）乘左子区间长度
  sum[rr[root]] += tag[root] * (r - mid);
      // 右子区间的和的增加，即对应标记的值（要修改的值）乘右子区间长度
  tag[root] = 0; // 当前节点操作完毕，重置标记值
}
```

以上便是线段树的所有基础操作

接下来我们结合实现：

## 洛谷 P3372 【模板】线段树 1

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T> inline T _max(const T &a, const T &b) {
  return a > b ? a : b;
}
template<typename T> inline T _min(const T &a, const T &b) {
  return a < b ? a : b;
}
template<typename T> T Read() {
  int ch;
  T ans = 0;
  do {
    ch = getchar();
  } while (!isdigit(ch));
  do {
    ans = ans * 10 + (ch - '0');
    ch = getchar();
  } while (isdigit(ch));
  return ans;
}
template<typename T> void Write(T ans) {
  if (ans < 0) {
    putchar('-');
    ans = -ans;
  }
  if (ans >= 10) {
    Write(ans / 10);
  }
  putchar((int)(ans % 10) + '0');
}
#define MAX_N 400010
int ll[MAX_N], rr[MAX_N];
long long sum[MAX_N], tag[MAX_N]; // 题目要求开long long
int cnt = 0;
void Update(int &root, int l, int r, int t, long long x) {
  if (root == 0) root = ++cnt;
  sum[root] += x;
  if (l == r) return;
  int mid = (l + r) >> 1;
  if (t <= mid) Update(ll[root], l, mid, t, x);
  else Update(rr[root], mid + 1, r, t, x);
}
inline void Down(int root, int l, int r) {
  if (ll[root] == 0) ll[root] = ++cnt;
  if (rr[root] == 0) rr[root] = ++cnt;
  tag[ll[root]] += tag[root], tag[rr[root]] += tag[root];
  int mid = (l + r) >> 1;
  sum[ll[root]] += tag[root] * (mid - l + 1);
  sum[rr[root]] += tag[root] * (r - mid);
  tag[root] = 0;
}
long long Query(int root, int l, int r, int x, int y) {
  if (l == x && r == y) return sum[root];
  Down(root, l, r);
  int mid = (l + r) >> 1;
  long long suml = 0, sumr = 0;
  if (x <= mid) suml = Query(ll[root], l, mid, x, _min(mid, y));
  if (y > mid) sumr = Query(rr[root], mid + 1, r, _max(mid + 1, x), y);
  return suml + sumr;
}
void Update(int &root, int l, int r, int p, int q, long long x) {
  if (root == 0) root = ++cnt;
  int num = _min(r, q) - _max(l, p) + 1;
  sum[root] += x * num;
  if (l == p && r == q) {
    tag[root] += x;
    return;
  }
  int mid = (l + r) >> 1;
  if (p <= mid) Update(ll[root], l, mid, p, _min(mid, q), x);
  if (q > mid) Update(rr[root], mid + 1, r, _max(mid + 1, p), q, x);
}
int main() {
  int n = Read<int>(), m = Read<int>(), root = 0;
  for (register int i = 1; i <= n; ++i) {
    long long t = Read<long long>();
    Update(root, 1, n, i, t);
  }
  for (register int i = 1; i <= m; ++i) {
    int o = Read<int>();
    if (o == 1) {
      int x = Read<int>(), y = Read<int>();
      long long k = Read<long long>();
      Update(root, 1, n, x, y, k);
    } else if (o == 2) {
      int x = Read<int>(), y = Read<int>();
      Write(Query(root, 1, n, x, y));
      putchar('\n');
    }
  }
  return 0;
}
```

---

## 作者：DQYdqy (赞：16)

**首先，这是一道fhq_treap模板题**

什么是fhq_treap呢？~~相信在坐的dalao们都知道，就不在做赘述~~

fhq_treap，是一位名叫fhq的神犇想出来的，是一种平衡树数据结构

它基本上能够支持大部分splay的功能，并且码量适中

fhq_treap的维护需要两个操作：**split**(分离),**merge**(合并)

### **Split**:

把树分裂成两个部分

### **Merge**:

把两颗树合并

**怎么用这两个操作插入呢？**

只要把1到x-1(x是插入的位置)先从树中分离出来，然后把要插入的数与之合并，再把得到的树与原树合并即可

图解：
![](https://cdn.luogu.com.cn/upload/pic/46013.png )

区间加也是同理，分离出来后直接加就行了，标记和线段树lazytag同理

详细见代码

```
#include <bits/stdc++.h>
#define inf 1926081700
#define N 200001
#define int long long
using namespace std;
int n,m;
typedef pair<int,int> pii;
struct fhq_treap{
    #define ls tree[q].son[0]
    #define rs tree[q].son[1]
    struct dqy{
        int son[2];
        int val,sum,key,size;
        int add;
    }tree[N];
    int root,tot;
    void update(int q){
        tree[q].size=tree[ls].size+tree[rs].size+1;
        tree[q].mx=min(tree[q].val,min(tree[ls].mx,tree[rs].mx));
        tree[q].sum=tree[ls].sum+tree[rs].sum+tree[q].val;
    }
    int New(int v){
        tree[++tot].size=1;
        tree[tot].key=rand();
        tree[tot].val=tree[tot].mx=v;
        tree[tot].rev=tree[tot].add=0;
        tree[tot].sum=v;
        return tot;
    }
    void P_add(int q,int v){
        tree[q].val+=v;tree[q].mx+=v;tree[q].add+=v;
        tree[q].sum+=(tree[ls].size+tree[rs].size+1)*v;
    }
    void pushdown(int q){
        if(tree[q].add){
            if(ls)P_add(ls,tree[q].add);
            if(rs)P_add(rs,tree[q].add);
            tree[q].add=0;
        }
    }
    pii split(int q,int rk){
        if(!rk)return make_pair(0,q);
        if(rk==tree[q].size)return make_pair(q,0);
        pushdown(q);
        if(tree[ls].size>=rk){
            pii tmp=split(ls,rk);
            ls=tmp.second;update(q);
            return make_pair(tmp.first,q);
        }
        else {
            pii tmp=split(rs,rk-tree[ls].size-1);
            rs=tmp.first;update(q);
            return make_pair(q,tmp.second);
        }
    }
    int merge(int a,int b){
        if(!a||!b)return a+b;
        pushdown(a);pushdown(b);
        if(tree[a].key>tree[b].key)return tree[a].son[1]=merge(tree[a].son[1],b),update(a),a;
        else return tree[b].son[0]=merge(a,tree[b].son[0]),update(b),b;
    }
    void add(int l,int r,int v){
        pii tmp1=split(root,r);
        pii tmp2=split(tmp1.first,l-1);
        P_add(tmp2.second,v);
        root=merge(merge(tmp2.first,tmp2.second),tmp1.second);
     }
    void insert(int x,int v){
        pii tmp1=split(root,x);
        root=merge(merge(tmp1.first,New(v)),tmp1.second);
        update(root);
    }
    int getsum(int l,int r){
    	pii tmp1=split(root,r);
    	pii tmp2=split(tmp1.first,l-1);
    	int sum=tree[tmp2.second].sum;
    	root=merge(merge(tmp2.first,tmp2.second),tmp1.second);
    	return sum;
	}
}T;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
signed main(){
    n=read();m=read();
    T.tree[0].mx=inf;
    for(int i=1;i<=n;i++){
        int x=read();
        T.insert(i-1,x);
    }
    for(int i=1;i<=m;i++){
        int opt=read();
        int l=read(),r=read();
        if(opt==1){
        	int v=read();T.add(l,r,v);
        }
        else printf("%lld\n",T.getsum(l,r));
    }
    return 0;
}
```

---

## 作者：谁是鸽王 (赞：16)

### 发一篇不需要O2就能过的分块。
基本思路：

分块的思路，大段维护，小段朴素。

维护几个数组：

- 区块$block[maxn]$
- 懒标记$tag[maxn]$
- 真实数据$data[maxn]$。


### 更新时
假设我们**涉及**到的区块的编号区间是$[lb,rb]$，**真实数据范围为**$[l,r]$。

那么，我们在**区块**的$[lb+1,rb-1]$区间，给$block[i]$加上$\Delta k$ 并且打上懒标记 $=\Delta k$。在真实数据的$[l,lb\times N]$和$[rb\times N-N+1,r]$区间的每个$data[i]$加上$\Delta k$。

### 查询时

同样的，对于区块区间$[lb+1,rb-1]$直接累加就好，对于$l b$区间和$rb$区间单独处理即可。

上丑陋无比的代码。注意特判$l$和$r$在一个区块区间的情况。


```cpp
#include<bits/stdc++.h>
using namespace std;
template< class ccf >inline ccf qr(ccf a) {
    char c=getchar();
    ccf x=0;
    int q=1;
    while(c<48||c>57)
	q=c==45?-1:q,c=getchar();
    while(c>=48&&c<=57)
	x=x*10+c-48,c=getchar();
    return q==-1?-x:x;
}
const int maxn=100055;
typedef long long ll;
ll data[maxn];
ll tag[maxn];
ll blk[maxn];
int n;
int m;
int N;
int adj;
#define RP(t,a,b) for(register int t=(a),edd=(b);t<=edd;t++)
int t1,t2;
ll t3;
int temp;

void add(int l,int r,ll k) {
    int lb=(l+N-1)/N;
    int rb=(r+N-1)/N;
    if(lb!=rb) {

	RP(t,l,N*lb)
	    data[t]+=k,blk[lb]+=k;
	RP(t,N*rb-N+1,r)
	    data[t]+=k,blk[rb]+=k;
	RP(t,lb+1,rb-1)
	    tag[t]+=k,blk[t]+=N*k;
    } else
	RP(t,l,r)
	    data[t]+=k,blk[t]+=k;
}

ll sum(int l,int r) {
    ll ret=0;
    int lb=(l+N-1)/N;
    int rb=(r+N-1)/N;
    RP(t,lb+1,rb-1)
	ret+=blk[t];
    if(tag[lb])
	RP(t,N*lb-N+1,N*lb)
	    data[t]+=tag[lb];
    tag[lb]=0;
    if(tag[rb])
	RP(t,N*rb-N+1,min(N*rb,n))
	    data[t]+=tag[rb];
    tag[rb]=0;
    if(lb!=rb) {
	RP(t,l,N*lb)
	    ret+=data[t];
	RP(t,N*rb-N+1,r)
	    ret+=data[t];
    } else
	RP(t,l,r)
	    ret+=data[t];
    return ret;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    n=qr(1);
    m=qr(1);
    RP(t,1,n)
	data[t]=qr(1ll);
    N=sqrt(n);
    RP(t,1,n/N)
	RP(i,1,N)
	blk[t]+=data[(t-1)*N+i];
    RP(t,1,n%N)
	blk[n/N+1]+=data[(n/N)*N+t];
    RP(t,1,m) {
	temp=qr(1);
	if(temp==1) {
	    t1=qr(1);
	    t2=qr(1);
	    t3=qr(1ll);
	    add(t1,t2,t3);
	} else {
	    t1=qr(1);
	    t2=qr(1);
	    printf("%ld\n",sum(t1,t2));
	}
    }
    return 0;
}

```



---

## 作者：shejian0702 (赞：13)

这道题我使用树状数组的高级应用做的
主要是数组`c1[]` `c0[]` 分别维护原数组`a[]`的的差分数组`b[]`，和`c0[i]*i`.
简而言之，记住2个数组，4个函数
```cpp
#include<cstdio>
#define ll long long 

const ll maxn = 100000+5 ;
ll n,m;

namespace bit{
    ll c0[maxn],c1[maxn];
    void add(ll *c,ll p, ll v){
        for(;p<=n;p += p &-p) c[p] += v;
    }
    ll sum(ll *c,ll p){
        ll t = 0;
        for(;p; p -= p & -p) t +=c[p];
        return t;
    }
    void addex(ll l, ll r, ll v){
        add(c0,l,v);add(c0,r+1,-v);add(c1,l,(l-1)*v);add(c1,r+1,-r*v);
    }
  
    ll sumex(ll l,ll r){
        return sum(c0,r)*r - sum(c1,r) -sum(c0,l-1)*(l-1) + sum(c1,l-1);
    }
}


void read(){
    scanf("%lld%lld",&n,&m);
    ll v =0 ,last =0;
    for(register ll i = 1; i<=n;i++){
        scanf("%lld",&v);
        last = v-last;
        bit::add(bit::c0,i,last);
        bit::add(bit::c1,i,last*(i-1));
        last = v;
    }
}

void work(){
    int op;
    scanf("%d",&op);
    if (op == 1){
        ll x,y,k;
        scanf("%lld%lld%lld",&x,&y,&k);
        bit::addex(x,y,k);
    }
    else{
        ll x,y;
        scanf("%lld%lld",&x,&y);
        printf("%lld\n",bit::sumex(x,y));
    }
}

int main(){
    read();
    while(m--) work();
    return 0;
}
```

---

## 作者：Null_Cat (赞：12)

Update1：更新了一处不准确的地方，将3.线段树中的①建（伪）树修改为建树

Updata2：又更新了一处不准确的地方
~~（所以熬夜肝题解害人不浅）~~，将把root设为0改为把root设为1

------

# 1.序言

自己刚学会树状数组和线段树，感觉大佬们的题解稍微有些难理解。。。写篇题解纪念一下然后方便一下我这样的蒟蒻理解树状数组和线段树
# 2.引子

### 相信各位都知道二叉树叭？

> 二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）
> (转自百度)
                                    
（好像并没有这么复杂

~~在我看来二叉树就是有两个分叉的一棵树~~（但很显然没毛病）

那么下面是一棵二叉树：

![一棵极为普通的二叉树](https://cdn.luogu.com.cn/upload/pic/64812.png "这就是一棵一般的二叉树")

那么一般来讲，我们会在二叉树的每一个节点处附上一个值，那么这个值就是这个节点的值，~~这个应该都会知道~~

那么下面继续引入一个概念

***满二叉树***

满二叉树是指只有最后一层的节点无子节点，打比方就是说一棵大树，上面的枝条都是一样长的，分叉也一样多，但是有的枝条上没叶子。~~然而这并不形象~~

在满二叉树中，又有一种特殊的二叉树，叫做——

***完 全 二 叉 树***

~~可以理解为那棵大树只秃了右面~~

在这里面，这个性质我们~~可能~~会用到：

**在2 * i <= n && 2 * i + 1 <= n时，i的左孩子为2 * i, 右孩子为2 * i + 1；一棵完全二叉树最多有2 ^ j - 1个节点（j为层数，i为任意节点）**

因为这个性质呢，我们存储一个满二叉树的时候直接开数组也就用得更多喏！

（画风突变）

A long long time ago...

我们~~可能~~学过一个好东西叫做

**前 缀 和 ！**

这个东西。。。~~看起来很好吃~~是用来求区间和的

那么联系一下上面我们说的完全二叉树

假如只给了你一串数（想象成叶子结点而且能够建成一棵树。。。）

那么如果让你来求这串数的总和。。。

你完全可以用O(n)的朴素算法求出来[出门右转隔壁你谷最难](https://www.luogu.org/problemnew/show/P1001 "喂喂喂别走啊喂")

当然你可以作死建个树。。。

利用前缀和的思想

**任意一个非叶子节点的值为其左右孩子的和！**

然后输出根节点的值

# 3.线段树

刚才说的那些~~其实和线段树并没有什么关系~~跟我们现在要学的线段树关系很大

作为一种二叉搜索树，线段树是区间查询的一个优化

类型定义：
```cpp
template<typename T1>		//用的C++模板，不理解的可以去掉把下面的T1什么的鸭换成int
struct LineTree{
	T1* datas;		//线段树本树
	T1* lazy_tag;	//懒标记，后面会说到
	T1* in;			//初始的数组
	int* size;		//数组大小，存一下后面方便用
    //我都是用的指针数组。。。直接用静态数组也是可以哒，但是一定要注意好数据范围，开数组的时候一定要开到4 * n，以防越界REorz
	
	LineTree(const int&);
	~LineTree();		//构造函数和析构函数，实际上这个地方我用的还不是说很标准，因为这俩家伙是class里面的东西，但是实际竞赛时是不让用clsss的，因此此处用struct即可，不用指针的可以忽略
	
	void Build(int, int, int);		//构建函数
	void Upgrade(int, T1, int, int, int);
	void Upgrade(int, int, T1, int, int, int);		//修改单点、区间，一个重载函数
	void PushUp(int);	//更新自己
	void PushDown(int, int, int);		//更新父节点
	void In();		//输入
	T1 Sum(int, int, int, int, int);		//区间求和
};
```


## ① 建树

线段树的构建其实和二叉树的序列差不多的方法。。。~~（当然是愉快的暴力喏）~~
只不过是输出序列是进行一些什么样的操作，不过这里是构建罢了（其实还是一样的）

因为我这个地方还需要构建函数和析构函数来申请和释放空间，所以就和建树一块放上去喏

```cpp
template<typename T1>	//模板类、函数前一定要加上这串东西（typename后面不一定叫T1，就把类型也当做变量用）
LineTree<T1>::LineTree(const int& sz){
	this->datas = new T1[4 * sz];
	this->lazy_tag = new T1[4 * sz];
	this->size = new int;
	this->in = new T1[4 * sz];
	*this->size = sz;		//一堆申请和初始化
    this->In();
	this->Build(1, *this->size, 1);		//分别是输入和建树，输入就是for然后cin而已，所以就不放喏
}

template<typename T1>
LineTree<T1>::~LineTree(){
	delete[] this->datas;
	delete[] this->lazy_tag;
	delete this->size;
	delete[] this->in;		//销毁申请的空间
}

template<typename T1>
void LineTree<T1>::Build(int left, int right, int root){		//正八经的建树喏，left默认要1，right默认要n，root默认要1
	this->lazy_tag[root] = 0;		//把懒标签先设为默认的0
	if(left == right){	//找到叶节点，即它的范围里只有它自己
		this->datas[root] = this->in[left];		//这时候给该节点赋值
		return;	//退出 
	}
	else{
		int mid = (right + left) / 2;	//二分继续暴力
		this->Build(left, mid, root * 2);	//暴力左子树
		this->Build(mid + 1, right, root * 2 + 1);	//暴力右子树 
		this->PushUp(root);	//因为不是叶节点，回溯更新自己
	}
}
```

可能看代码会有些难理解（醒醒就你一个不理解），那我们来画张图：

![这就是初始未赋值的状态](https://cdn.luogu.com.cn/upload/pic/64844.png "i ~ j表示从i到j的区间")

因为我们是从1 到 n（也就是样例中的5）开始暴力，所以我们这时的left并不等于right，因此二分mid=3，所以我们递归Build(1, 3, root * 2 = 2)也就是左子树，这时的根节点变成了它的左子树的根节点root * 2 = 2，同理也递归右子树Build(4, 6, root * 2 + 1 = 3)，回溯更新的话呢（我好想忘了给代码喏）如下

	this->datas[root] = this->datas[root * 2] + this->datas[root * 2 + 1];
（但是这个回溯是最后才被更新的）

那么Keep Going!

根据原理，1还是不等于3，4还是不等于6，继续二分！

Mid(left) = 2， Mid(right) = 5

那么就递归出了四个函数：

Build（原左）(1, 2, root * 2 = 4)，Build（原左）(3, 4, root * 2 + 1 = 5)，Build（原右）(4, 5, root * 2 = 6)，Build（原右）(6, 6, root * 2 + 1 = 7)

那么我们Build的左左，左右，右左都还是没有达到条件，但是我们的右右的left已经等于right了，所以我们就可以给datas[root = 7]赋值为in[left = 6]也就是。。。

~~（目前什么也没有）~~

那么给剩下的三个函数继续递归，左左Mid = 1, 左左左Build(1, 1, root * 2 = 8)、左左右Build(2, 2, root * 2 + 1 = 9)；左右Mid = 3，左右左Build(3, 3, root * 2 = 10);左右右Build(4, 4, root * 2 + 1 = 11)；右左Mid = 4，右左左Build(4, 4, root * 2 = 12)，右左右Build(5, 5, root * 2 + 1 = 13)

这时候我们就可以把datas[8]赋值为in[1] = 1,datas[9] = in[2] = 5, datas[10] = in[3] = 4, datas[11] = in[4] = 2, datas[12] = in[4] = 2, datas[13] = in[5] = 3

此时开始回溯，左左也就是datas[4] = datas[8] + datas[9] = 6, datas[5] = datas[10] + datas[11] = 6, datas[6] = datas[12] + datas[13] = 5,而我们那可怜的datas[7]还是没有值。。。所以就是当0也就是没有datas[7]这个节点

再向上回溯，datas[2] = datas[4] + datas[5] = 12, datas[3] = datas[6] + datas[7] = 5

回溯到最顶层，datas[1] = datas[2] + datas[3] = 17

（呼
~~，手打递归真难受~~
）

那么我们就大概可以得到下面这棵树：

![最后我们得到的树](https://cdn.luogu.com.cn/upload/pic/64853.png "手动暴力真的累QwQ")

## ②修改单点

修改单点的话呢。。。~~其实比建树还要简单~~

还是一个二维的dfs带二分，这个时候不能把datas看做一棵树，想象你就是在一个线性结构里找一个值。。。

上代码，这个不多解释

```cpp
template<typename T1>
void LineTree<T1>::Upgrade(int point, T1 data, int left, int right, int root){
	if(left == right == point){		//找到该节点 
		this->datas[root] += data;	//更新 
		return;	//结束 
	}
	else{
		int mid = (right + left) / 2;	 
		if(point < mid){
			this->Upgrade(point, data, mid + 1, right, root * 2 + 1);
		} 
		else{
			this->Upgrade(point, data, left, mid, root * 2);
		}
		//二分找[point,point] 
		this->PushUp(root);
		//回溯，更新父节点 
	}
}
```

~~(然鹅这并没有什么用~~

## ③修改区间

区间的修改可以说是线段树 && 树状数组的精髓所在了

上代码

```cpp
template<typename T1>
void LineTree<T1>::Upgrade(int from, int to, T1 data, int left, int right, int root){
	if(from <= left && to >= right){	//在需更新范围内 
		this->datas[root] += (right - left + 1) * data;	//更新总的区间值 
		this->lazy_tag[root] += data;	//设好lazy_tag，过后再改 
		return;	//退出 
	}
	else{
		this->PushDown(root, left, right);	//下推root 
		T1 mid = (left + right) / 2;
		if(from <= mid){
			this->Upgrade(from, to, data, left, mid, root * 2);
		}
		if(to > mid){
			this->Upgrade(from, to, data, mid + 1, right, root * 2 + 1);
		}
		this->PushUp(root);
		//还是二分回溯 
	}
}
```

如果说直接这么上一串代码。。。我相信也是比较难去理解的（醒醒就你一个不理解

~~那么我们还是来手动模拟一下~~

就拿样例里的第一个修改举例（划掉

要求是要修改[2, 3]区间的值。。。

那么这时候我们这个Upgrade()函数的参数值就是(2, 3, 2, 1, 5, 1)

那么跟着代码走：

因为2 !<= 1，所以进else

首先我们先把在root中的lazy_tag向下分配到它的两个子节点

可是。。。问题是。。。

***lazy_tag是什么？？？***

。

~~你猜~~lazy是懒的意思，tag是标签。。。懒标签qwq莫不是标记上懒得更新？？？

还真是（逃

lazy_tag的存在就是优化复杂度的，因为有的一些数值我们是在查询过程中不需要的，因此我们也就没必要算他们，记录下来知道有这回事就好awa

如果还不够形象，那么我们就来打个比方

（画面自行脑补）

AuAqwq在某天坐在家里看番刷B站，活脱一个死肥宅（可我真的不肥qwq）的样子。俗话说的好，没有可乐的肥宅生活是空乏的（没错我自己编的）。因此AuAqwq打算去那几瓶可乐，可是冰箱里没有了，但是AuAqwq并不打算去买，因为外面热达0x3f3f3f3f℃而且ikun们一直在高呼______，因此AuAqwq不到迫不得已是不会出去买（对应查询操作）的。当AuAqwq每看完一集就会想买几瓶可乐，而且要放在冰箱连着的几层里，每层放的数量一样（对应修改操作）

没错，就是这样，lazy_tag的用途其实就相当于AuAqwq在脑子中记忆要买的可乐，并且买来以后还不一定放进去（可能比喻不是很恰当。。。

咳咳咳。。。

让我们继续来看一下PushDown函数的定义

```cpp
template<typename T1>
void LineTree<T1>::PushDown(int root, int left, int right){
	T1 mid = (right + left) / 2;
	this->lazy_tag[root * 2] += this->lazy_tag[root];	//重点1.0
	this->datas[root * 2] += (mid - left + 1) * this->lazy_tag[root];	//重点2.0
	this->lazy_tag[root * 2 + 1] += this->lazy_tag[root];
	this->datas[root * 2 + 1] += (right - mid) * this->lazy_tag[root];	//复读左边相当于
	this->lazy_tag[root] = 0;	//把原来存在root的lazy_tag去掉
}
```

### 重点1.0
回去瞄一眼我们的Upgrade函数

可以发现我们的lazy_tag的更新是直接把修改的单个值加在了上面，所以左右子节点的lazy_tag直接加的它的lazy_tag值

### 重点2.0

这个地方可能会有些艰涩

因为我们无法判断他的左右子节点是否为叶节点（是不是也无所谓），那么我们就得让他把他小弟的也都带上qwq

咳咳，让我们回到Upgrade函数里，下面还是久违的二分，范围相信各位奆犇也都能理解qwq（假装忘掉上面还在举例

最后的回溯主要是为了让那群~~忘恩负义~~子节点为父节点更新

## ④区间查询

先供代码

```cpp
template<typename T1>
T1 LineTree<T1>::Sum(int from, int to, int left, int right, int root){
	if(left >= from && right <= to){
		return this->datas[root];	//确认是这个区间的值了，然后返回
	}
	else{
		this->PushDown(root, left, right);
		T1 mid = (right + left) / 2;
		T1 ans = 0;
		if(from <= mid){
			ans += this->Sum(from, to, left, mid, root * 2);
		}
		if(to > mid){
			ans += this->Sum(from, to, mid + 1, right, root * 2 + 1);
		}
		return ans;		//和Upgrade几乎一样，加了个返回值而已。。。
	}
}
```

相信这个大家也都明白了，不明白的话。。。自己手算（划掉

## ⑤线段树总结

So，线段树就这么被我们完美（个鬼）敲完了！

不带main的万能线段树模板：

```cpp
#include <bits/stdc++.h>

using namespace std;

template<typename T1>
struct LineTree{
	T1* datas;
	T1* lazy_tag;
	T1* in;
	int* size;
	
	LineTree(const int&);
	~LineTree();
	
	void Build(int, int, int);
	void Upgrade(int, T1, int, int, int);
	void Upgrade(int, int, T1, int, int, int);
	void PushUp(int);
	void PushDown(int, int, int);
	void In();
	T1 Sum(int, int, int, int, int);
};

template<typename T1>
LineTree<T1>::LineTree(const int& sz){
	this->datas = new T1[4 * sz];
	this->lazy_tag = new T1[4 * sz];
	this->size = new int;
	this->in = new T1[4 * sz];
	*this->size = sz;
	this->In();
	this->Build(1, *this->size, 1);
}

template<typename T1>
LineTree<T1>::~LineTree(){
	delete this->datas;
	delete this->lazy_tag;
	delete this->size;
	delete this->in;
}

template<typename T1>
void LineTree<T1>::Build(int left, int right, int root){
	this->lazy_tag[root] = 0;
	if(left == right){	//找到叶节点 
		this->datas[root] = this->in[left];
		return;	//退出 
	}
	else{
		int mid = (right + left) / 2;	//二分 
		this->Build(left, mid, root * 2);	//左子树 
		this->Build(mid + 1, right, root * 2 + 1);	//右子树 
		this->PushUp(root);	//回溯更新 
	}
}

template<typename T1>
void LineTree<T1>::Upgrade(int point, T1 data, int left, int right, int root){
	if(left == right == point){		//找到该节点 
		this->datas[root] += data;	//更新 
		return;	//结束 
	}
	else{
		int mid = (right + left) / 2;	 
		if(point < mid){
			this->Upgrade(point, data, mid + 1, right, root * 2 + 1);
		} 
		else{
			this->Upgrade(point, data, left, mid, root * 2);
		}
		//二分找[point,point] 
		this->PushUp(root);
		//回溯，更新父节点 
	}
}

template<typename T1>
void LineTree<T1>::Upgrade(int from, int to, T1 data, int left, int right, int root){
	if(from <= left && to >= right){	//在需更新范围内 
		this->datas[root] += (right - left + 1) * data;	//更新总的区间值 
		this->lazy_tag[root] += data;	//设好lazy_tag，过后再改 
		return;	//退出 
	}
	else{
		this->PushDown(root, left, right);	//下推root 
		T1 mid = (left + right) / 2;
		if(from <= mid){
			this->Upgrade(from, to, data, left, mid, root * 2);
		}
		if(to > mid){
			this->Upgrade(from, to, data, mid + 1, right, root * 2 + 1);
		}
		this->PushUp(root);
		//还是二分回溯 
	}
}

template<typename T1>
void LineTree<T1>::PushUp(int root){
	this->datas[root] = this->datas[root * 2] + this->datas[root * 2 + 1];
} 

template<typename T1>
void LineTree<T1>::PushDown(int root, int left, int right){
	T1 mid = (right + left) / 2;
	this->lazy_tag[root * 2] += this->lazy_tag[root];
	this->datas[root * 2] += (mid - left + 1) * this->lazy_tag[root];
	this->lazy_tag[root * 2 + 1] += this->lazy_tag[root];
	this->datas[root * 2 + 1] += (right - mid) * this->lazy_tag[root];
	this->lazy_tag[root] = 0;
}

template<typename T1>
T1 LineTree<T1>::Sum(int from, int to, int left, int right, int root){
	if(left >= from && right <= to){
		return this->datas[root];
	}
	else{
		this->PushDown(root, left, right);
		T1 mid = (right + left) / 2;
		T1 ans = 0;
		if(from <= mid){
			ans += this->Sum(from, to, left, mid, root * 2);
		}
		if(to > mid){
			ans += this->Sum(from, to, mid + 1, right, root * 2 + 1);
		}
		return ans;
	}
}

template<typename T1>
void LineTree<T1>::In(){
	for(register int i = 1; i <= *size; i++){
		cin >> this->in[i];
	}
}
```

食用方式：

	LineTree<类型名称> 变量名称(数列长度);

本题AC代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

template<typename T1>
struct LineTree{
	T1* datas;
	T1* lazy_tag;
	T1* in;
	int* size;
	
	LineTree(const int&);
	~LineTree();
	
	void Build(int, int, int);
	void Upgrade(int, T1, int, int, int);
	void Upgrade(int, int, T1, int, int, int);
	void PushUp(int);
	void PushDown(int, int, int);
	void In();
	T1 Sum(int, int, int, int, int);
};

int main(int argc, char* argv[]){
	register int* n = new int;
	register int* m = new int;
	cin >> *n >> *m;
	LineTree<long long> t(*n);
	register long long* cmd = new long long;
	register long long* x = new long long;
	register long long* y = new long long;
	register long long* k = new long long;
	for(register long long i = 0; i < *m; i++){
		cin >> *cmd;
		if(*cmd & 1){
			cin >> *x >> *y >> *k;
			t.Upgrade(*x, *y, *k, 1, *n, 1);
		}
		else{
			cin >> *x >> *y;
			cout << t.Sum(*x, *y, 1, *n, 1) << endl;
		}
		*x = 0;
		*y = 0;
		*k = 0;
	}
	delete n;
	delete m;
	delete cmd;
	delete x;
	delete y;
	delete k;
	return 0;
} 

template<typename T1>
LineTree<T1>::LineTree(const int& sz){
	this->datas = new T1[4 * sz];
	this->lazy_tag = new T1[4 * sz];
	this->size = new int;
	this->in = new T1[4 * sz];
	*this->size = sz;
	this->In();
	this->Build(1, *this->size, 1);
}

template<typename T1>
LineTree<T1>::~LineTree(){
	delete[] this->datas;
	delete[] this->lazy_tag;
	delete this->size;
	delete[] this->in;
}

template<typename T1>
void LineTree<T1>::Build(int left, int right, int root){
	this->lazy_tag[root] = 0;
	if(left == right){	//找到叶节点 
		this->datas[root] = this->in[left];
		return;	//退出 
	}
	else{
		int mid = (right + left) / 2;	//二分 
		this->Build(left, mid, root * 2);	//左子树 
		this->Build(mid + 1, right, root * 2 + 1);	//右子树 
		this->PushUp(root);	//回溯更新 
	}
}

template<typename T1>
void LineTree<T1>::Upgrade(int point, T1 data, int left, int right, int root){
	if(left == right == point){		//找到该节点 
		this->datas[root] += data;	//更新 
		return;	//结束 
	}
	else{
		int mid = (right + left) / 2;	 
		if(point < mid){
			this->Upgrade(point, data, mid + 1, right, root * 2 + 1);
		} 
		else{
			this->Upgrade(point, data, left, mid, root * 2);
		}
		//二分找[point,point] 
		this->PushUp(root);
		//回溯，更新父节点 
	}
}

template<typename T1>
void LineTree<T1>::Upgrade(int from, int to, T1 data, int left, int right, int root){
	if(from <= left && to >= right){	//在需更新范围内 
		this->datas[root] += (right - left + 1) * data;	//更新总的区间值 
		this->lazy_tag[root] += data;	//设好lazy_tag，过后再改 
		return;	//退出 
	}
	else{
		this->PushDown(root, left, right);	//下推root 
		T1 mid = (left + right) / 2;
		if(from <= mid){
			this->Upgrade(from, to, data, left, mid, root * 2);
		}
		if(to > mid){
			this->Upgrade(from, to, data, mid + 1, right, root * 2 + 1);
		}
		this->PushUp(root);
		//还是二分回溯 
	}
}

template<typename T1>
void LineTree<T1>::PushUp(int root){
	this->datas[root] = this->datas[root * 2] + this->datas[root * 2 + 1];
} 

template<typename T1>
void LineTree<T1>::PushDown(int root, int left, int right){
	T1 mid = (right + left) / 2;
	this->lazy_tag[root * 2] += this->lazy_tag[root];
	this->datas[root * 2] += (mid - left + 1) * this->lazy_tag[root];
	this->lazy_tag[root * 2 + 1] += this->lazy_tag[root];
	this->datas[root * 2 + 1] += (right - mid) * this->lazy_tag[root];
	this->lazy_tag[root] = 0;
}

template<typename T1>
T1 LineTree<T1>::Sum(int from, int to, int left, int right, int root){
	if(left >= from && right <= to){
		return this->datas[root];
	}
	else{
		this->PushDown(root, left, right);
		T1 mid = (right + left) / 2;
		T1 ans = 0;
		if(from <= mid){
			ans += this->Sum(from, to, left, mid, root * 2);
		}
		if(to > mid){
			ans += this->Sum(from, to, mid + 1, right, root * 2 + 1);
		}
		return ans;
	}
}

template<typename T1>
void LineTree<T1>::In(){
	for(register int i = 1; i <= *size; i++){
		cin >> this->in[i];
	}
}
```

辣么线段树就到这里rua！

# 4.树状数组

泥萌说的这个线段树，他厉害吗？（正当AuAqwq在讲线段树的时候人群里突然冒出来了这一句

这个线段树啊他不是那种厉不厉害的问题，他真的是那种。。。没有树状数组跑得快的那种

~~（上面那些话作废awa~~

咳咳咳

那么在做这种题的时候，我们除了可以用线段树，还有没有其他什么更快的其他操作呢？

This is 树状数组~~（实在不知道树状数组嘤文哈哈哈~~

那么树状数组到底是个什么东西呢？

我们可以通过字面来理解，树状的数组，那就是一种以类似树形的数组。。。也就是说可以用树的模拟图来表示出来。。。

好叭不卖关子喏，树状数组就是这个东西↓

![这个东西就是一个n = 4的树状数组](https://cdn.luogu.com.cn/upload/pic/65182.png "n = 4的树状数组（题目原本的5不大会画qwq）")

辣么这个树状数组有什么好的呢？

（啪！）

咳咳咳，好处吧。。。有。。。说不清。。。（逐渐扯远

数组A中储存的也就是我们初始的一个值

数组C中储存的是它的左右节点的和，而在这棵假的树中，所有叶子节点的值都与A中的值相对应

在我们n = 4的这样一个树状数组中：

C[1] = A[1], C[2] = C[1] + A[2] = A[1] + A[2], C[3] = A[3], C[]4 = C[2] + C[3] + A[4] = A[1] + A{2] + A[3] + A[4];

这个例子是不是还不够明显？我们再来看看n = 8的树状数组

![n = 8的树状数组](https://cdn.luogu.com.cn/upload/pic/65241.png "这就是n = 8的树状数组")

从C[1]~C[4]都是和n = 4一样，C[5] = A[5], C[6] = C[5] + A[6], C[7] = A[7], C[8] = C[4] + C[6] + A[8] = A[1] + A[2] +... + A[8]

那么我们可以来观察一下规律：

index为奇数的C都与A[index]相对应

而只能除以1次2的则是在第二层的从左数第index / 2个，对应着A[index - 1] + A[index]

而只能除以2次2的则是在第三层的从左数第index / (2 * 2)个，对应着C[index - 2] + C[index - 1] + A[index] = A[index - 3] + A[index - 2] + A[index - 2] + A[index]

相信我不用说各位奆犇们都能想的出来后继的规律

如果我们把index为奇数的也总结进一般规律，那么我们就可以得到一个通项公式：

$
  

C[i]=

   i

   Σ A

i-m

m为i能被2整除的次数
$

是不是还有些艰涩？那么我们用程序写出来

```cpp
int m = 0， icpy = i;
while (icpy % 2 == 0)
{
	m += 1;
	icpy >> 1;  \\(icpy /= 2与右移1位效果一样)
} //这段就是在求m

for (register int j = i - m; j <= i; j++)
{
	C[i] += A[j];
}
```

那么我们可不可以让他再短一些呢？

通过观察我们可以发现这个运算每回都是用2进行操作。。。

那么我们是不是可以来观察一下他们的2进制？

4层每层各举一个例子：

(5)₁₀ = (0101)₂

(2)₁₀ = (0010)₂

(4)₁₀ = (0100)₂

(8)₁₀ = (1000)₂

那么我们在分别看一下他们对应的A：

(5)₁₀ = (0101)₂,(5)₁₀ = (0101)₂

(2)₁₀ = (0010)₂,(1)₁₀ = (0001)₂,(2)₁₀ = (0010)₂

(4)₁₀ = (0100)₂,(1)₁₀ = (0001)₂,(2)₁₀ = (0010)₂,(3)₁₀ = (0011)₂,(4)₁₀ = (0100)₂

(8)₁₀ = (1000)₂,(1)₁₀ = (0001)₂,(2)₁₀ = (0010)₂,(3)₁₀ = (0011)₂,(4)₁₀ = (0100)₂,(5)₁₀ = (0101)₂,(6)₁₀ = (0110)₂,(7)₁₀ = (0111)₂,(8)₁₀ = (1000)₂

好像并没有什么规律。。。

（啪！）

咳咳，这么看当然是没有什么规律了，但是我们可以尝试一些别的方法。。。

比如。。。

	i&(-i)

那么这个家伙算出来是什么呢

我们知道C++在储存负数的时候是按照补码存储的

举个栗子，(5)₁₀ = (0101)₂,那么(-5)₁₀ = (1011)₂，再按位与的话，结果就是1

同理(2)₁₀ = (0010)₂,则(-2)₁₀ = (1110)₂,结果是2；(4)₁₀ = (0100)₂,则(-4)₁₀ = (1100)₂,结果是3；(8)₁₀ = (1000)₂,则(-8)₁₀ = (1000)₂,结果是4

而观察我们得到的结果，正好是之前的m + 1！

~~可是这规律目前没有什么用~~

（啪！）

## ①构造

注意我这个地方没有说建树，是因为$\color{red}\text{树状数组不是树是数组！！！}$

首先是我们的类型定义：

```cpp
template <typename T1>

class TreeArray	//这个地方我就是用的class了。。。
{
	private:
		
		T1* array;		//数组真身
		int* size;		//大小存好，用起来方便
		
		T1 LowerBit (const T1&);	//LowerBit公用私有无所谓，因为类外没有需要它的操作
		
	public:
		
		TreeArray (const int&);
		~TreeArray ();	//构造 && 析构函数
		
		void AddData (const int&, const T1&);	//加值的
		T1 Insert(const int&);	//查找1 ~ k的区间和
		T1 Insert(const int&, const int&);	//查找l ~ r的区间和
};
```

这个没有可说的。。。下面构造树状数组的部分

```cpp
template <typename T1>

TreeArray <T1> :: TreeArray (const int& sz)
{
	this->array = new T1[sz + 1];
	this->size = new int;
	*this->size = sz;
	T1* data = new T1;	//申请空间什么的
	for (register int i = 1; i <= *this->size; i++)
	{
		cin >> *data;	//输入一个值，注意不能直接对着输入
		this->AddData(i, *data);	//在树状数组里的专属加值函数
	} 
	delete data;	//把data废掉
}

template <typename T1>

TreeArray <T1> :: ~TreeArray()
{
	delete[] this->array;
	delete size;	//销毁空间
}

template <typename T1>

T1 TreeArray <T1> :: LowerBit(const T1& t1)
{
	return t1 & (-t1);	//我们所说的i&(-i)
}

template <typename T1>

void TreeArray <T1> :: AddData(const int& index, const T1& data)
{
	for (register int i = index; i <= *this->size; i += this->LowerBit(i))	//注意循环加的值！
	{
		this->array[i] += data;
	}
}
```

这里的重点是在AddData函数中的循环范围和循环加的值！

我们从index开始，因为用比index小的值作下标时index不受影响，~~（可以自己观察
）~~

而+=LowerBit(i)呢，我们可以继续回到图中观察，可以发现，与C[i]所有相关的C的值，正好是这货（划掉

但是要注意，加的LowerBit会影响下一步LowerBit(i)加的值，也就是说LowerBit所加的值并不一定

## ②查找

在树状数组里查找值就不像线段树那样简单了。。。因为我们的树状数组的假的树中的一些节点是空的，所以我们求i ~ j只能用1 ~ j减1 ~ i - 1

那么1 ~ j又怎么求呢？

（啪！）

根据我们在上面加值的时候的一个原理，我们可以再从那个原理上逆推，从而把查询1 ~ j转化成查询假的节点的值

而查询这个值的时候我们又不得不去查询与它相关的假的节点的值

而与它相关的，也就是会影响它的值的节点，其实就是不断地对他-=LowerBit，从而得出代码

```cpp
template <typename T1>

T1 TreeArray <T1> :: Insert(const int& index)
{
	T1 ans = 0;
	int i = index;
	while (i != 0)
	{
		ans += this->array[i];
		i -= this->LowerBit(i);
	} 
	return ans;
}
```

而我在上面说了，i ~ j的值就是1 ~ j - 1 ~ i - 1的值

为了方便我们查询~~（其实就是我懒而已~~，于是我们再重载一下Insert

```cpp
template <typename T1>

T1 TreeArray <T1> :: Insert(const int& from, const int& to)
{
	return this->Insert(to) - this->Insert(from - 1);
}
```

然后树状数组的基本操作就OK喏！

## ③树状数组总结

**树状数组不是树树状数组不是树树状数组不是树！！！**

不带main的万能树状数组模板：

```cpp
#include <bits/stdc++.h>

using namespace std;

template <typename T1>

class TreeArray
{
	private:
		
		T1* array;
		int* size;
		
		T1 LowerBit (const T1&);
		
	public:
		
		TreeArray (const int&);
		~TreeArray ();
		
		void AddData (const int&, const T1&);
		T1 Insert(const int&);
		T1 Insert(const int&, const int&);
};

template <typename T1>

TreeArray <T1> :: TreeArray (const int& sz)
{
	this->array = new T1[sz + 1];
	this->size = new int;
	*this->size = sz;
	T1* data = new T1;
	for (register int i = 1; i <= *this->size; i++)
	{
		cin >> *data;
		this->AddData(i, *data);
	} 
	delete data;
}

template <typename T1>

TreeArray <T1> :: ~TreeArray()
{
	delete[] this->array;
	delete size;
}

template <typename T1>

T1 TreeArray <T1> :: LowerBit(const T1& t1)
{
	return t1 & (-t1);
}

template <typename T1>

void TreeArray <T1> :: AddData(const int& index, const T1& data)
{
	for (register int i = index; i <= *this->size; i += this->LowerBit(i))
	{
		this->array[i] += data;
	}
}

template <typename T1>

T1 TreeArray <T1> :: Insert(const int& index)
{
	T1 ans = 0;
	int i = index;
	while (i != 0)
	{
		ans += this->array[i];
		i -= this->LowerBit(i);
	} 
	return ans;
}

template <typename T1>

T1 TreeArray <T1> :: Insert(const int& from, const int& to)
{
	return this->Insert(to) - this->Insert(from - 1);
}
```

食用方式：

	TreeArray <类型名> 变量名(n)

带main函数的树状数组1 AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

template <typename T1>

class TreeArray
{
	private:
		
		T1* array;
		int* size;
		
		T1 LowerBit (const T1&);
		
	public:
		
		TreeArray (const int&);
		~TreeArray ();
		
		void AddData (const int&, const T1&);
		T1 Insert(const int&);
		T1 Insert(const int&, const int&);
};

int main(int argc, char* argv[])
{
	int n, m;
	cin >> n >> m;
	TreeArray <int> t(n);
	int cmd, x, y;
	for (register int i = 0; i < m; i++)
	{
		cin >> cmd >> x >> y;
		if (cmd == 1)
		{
			t.AddData(x, y);
		}
		else
		{
			cout << t.Insert(x, y) << endl;
		}
	} 
	return 0;
}

template <typename T1>

TreeArray <T1> :: TreeArray (const int& sz)
{
	this->array = new T1[sz + 1];
	this->size = new int;
	*this->size = sz;
	T1* data = new T1;
	for (register int i = 1; i <= *this->size; i++)
	{
		cin >> *data;
		this->AddData(i, *data);
	} 
	delete data;
}

template <typename T1>

TreeArray <T1> :: ~TreeArray()
{
	delete[] this->array;
	delete size;
}

template <typename T1>

T1 TreeArray <T1> :: LowerBit(const T1& t1)
{
	return t1 & (-t1);
}

template <typename T1>

void TreeArray <T1> :: AddData(const int& index, const T1& data)
{
	for (register int i = index; i <= *this->size; i += this->LowerBit(i))
	{
		this->array[i] += data;
	}
}

template <typename T1>

T1 TreeArray <T1> :: Insert(const int& index)
{
	T1 ans = 0;
	int i = index;
	while (i != 0)
	{
		ans += this->array[i];
		i -= this->LowerBit(i);
	} 
	return ans;
}

template <typename T1>

T1 TreeArray <T1> :: Insert(const int& from, const int& to)
{
	return this->Insert(to) - this->Insert(from - 1);
}
```

# ⑤总结

这两个家伙就是一般的区间型查询的数据结构辣~

---

## 作者：高分子合成 (赞：10)

本蒟蒻学完线段树，尴尬地发现自己只会biuld，update，query的最简单模板。
dalao：这个数据规模%4^&43￥%3￥5#@……很简单**动态开点**。嗯对然后就A了。
##### ~~我：嗯嗯？？？~~
然后搜博客：天哪，这都是什么？主席树？好吧本蒟蒻不会，~~只好拿着板子水一波~~

## 言归正传：
1. 什么是动态开点：
   一般的线段树都是一颗满二叉树，堆式存储需要$N*4$空间，如果一开始就biuld，或者N很大，很容易MLE，动态开点就是我们需要用到这个节点的时候临时申请（当然可能的询问区间范围要较小一些，这样需要开的节点才不会MLE）~~所以说这题不用动态开点，我只是来水一下的，因为好像没有最朴素的教程~~
1. 关键部分：
   因为随用随开，所以每个节点并非如堆式存储那样$o<<1$,$o<<1|1$可以访问子树，所以我们要记录子树下标，并且每次到一个节点都要检查该节点是否已开。
   #### 结构体定义
   ```cpp
struct Leaf{
    int ls,rs;  //两个子树的下标，没有的话默认0 
    LL s;   //区间和
    Leaf(){}
    Leaf(int _,int __){ls=rs=0;s=pre[__]-pre[_-1];}
}sg[maxn<<2];
```
#### 新建节点
```cpp
inline void newleaf(int &o ,int l,int r){
    o=++id;
    sg[o]=Leaf(l,r);
}
```

#### 主体函数（为什么o是引用？想想就知道了）
```cpp
inline void pushdown(int &o,int l,int r){
    if (tag[o]){   
       if (l!=r){
       	 int now=o;
         if (!sg[now].ls) {newleaf(sg[o].ls,l,mid);}
         if (!sg[now].rs) {newleaf(sg[o].rs,mid+1,r);}
       	 tag[sg[now].ls]+=tag[now];
       	 tag[sg[now].rs]+=tag[now];
       	 sg[sg[now].ls].s+=(mid-l+1)*tag[now];
       	 sg[sg[now].rs].s+=(r-mid)*tag[now];
       }
       tag[o]=0;
    }
}

inline void pushup(int &o,int l,int r){
    if (l!=r) {
        if (!sg[o].ls) newleaf(sg[o].ls,l,mid);
        if (!sg[o].rs) newleaf(sg[o].rs,mid+1,r);//开子节点，防止子节点没有访问过，未初始化而答案错误
        sg[o].s=sg[sg[o].ls].s+sg[sg[o].rs].s;
    }
}

void update(int &o,int l,int r,int k){  
    if (!o){
        newleaf(o,l,r);  //如果之前没有遍历过，就先开点，要在更新前开
    }
    if (l>=L && r<=R) {
        sg[o].s+=(r-l+1)*k;
        tag[o]+=k;		
        return;
    }
    pushdown(o,l,r);
    if (L<=mid) update(sg[o].ls,l,mid,k);
    if (R>mid) update(sg[o].rs,mid+1,r,k);
    pushup(o,l,r);
}

LL query(int &o,int l,int r){
    if (!o){
        newleaf(o,l,r);
        if (l==r) {return sg[o].s;} //同理
    }
    if (l>=L && r<=R) {return sg[o].s;}                    
    pushdown(o,l,r);
    LL ans=0;
    if (L<=mid) ans+=query(sg[o].ls,l,mid);
    if (R>mid) ans+=query(sg[o].rs,mid+1,r); 
    pushup(o,l,r);
    return ans;
}
```
其余和普通线段树一样。
另外：因为每次要判断，新建节点等等，动态开点比较慢（576ms）
我打的垃圾线段树300ms，嗯嗯。。。

#### 全代码（~~巨丑~~）
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define mid (((l)+(r))>>1)
using namespace std;
typedef long long LL;
const int maxn=1e5+10;

int n,m,id,o,L,R,op,k;
LL a[maxn],pre[maxn],tag[maxn<<2];

struct Leaf{
    int ls,rs;  //两个子树的下标 
    LL s;   //区间和
    Leaf(){}
    Leaf(int _,int __){ls=rs=0;s=pre[__]-pre[_-1];}//初始化
}sg[maxn<<2];

inline void newleaf(int &o ,int l,int r){
    o=++id;
    sg[o]=Leaf(l,r);
}

inline void pushdown(int &o,int l,int r){
    if (tag[o]){   
       if (l!=r){
       	 int now=o;
         if (!sg[now].ls) {newleaf(sg[o].ls,l,mid);}
         if (!sg[now].rs) {newleaf(sg[o].rs,mid+1,r);}
       	 tag[sg[now].ls]+=tag[now];
       	 tag[sg[now].rs]+=tag[now];
       	 sg[sg[now].ls].s+=(mid-l+1)*tag[now];
       	 sg[sg[now].rs].s+=(r-mid)*tag[now];
       }
       tag[o]=0;
    }
}

inline void pushup(int &o,int l,int r){
    if (l!=r) {
        if (!sg[o].ls) newleaf(sg[o].ls,l,mid);
        if (!sg[o].rs) newleaf(sg[o].rs,mid+1,r);
        sg[o].s=sg[sg[o].ls].s+sg[sg[o].rs].s;
    }
}

void update(int &o,int l,int r,int k){  
    if (!o){newleaf(o,l,r);
  //如果之前没有遍历过，就先开点 }
    if (l>=L && r<=R) {
        sg[o].s+=(r-l+1)*k;
        tag[o]+=k;		
        return;
    }
    pushdown(o,l,r);
    if (L<=mid) update(sg[o].ls,l,mid,k);
    if (R>mid) update(sg[o].rs,mid+1,r,k);
    pushup(o,l,r);
}

LL query(int &o,int l,int r){
    if (!o){
        newleaf(o,l,r);
        if (l==r) {return sg[o].s;}
    }
    if (l>=L && r<=R) {return sg[o].s;}                    
    pushdown(o,l,r);
    LL ans=0;
    if (L<=mid) ans+=query(sg[o].ls,l,mid);
    if (R>mid) ans+=query(sg[o].rs,mid+1,r); 
    pushup(o,l,r);
    return ans;
}

int main(){
    //freopen("haha.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) scanf("%lld",a+i);
    for (int i=1;i<=maxn;i++) pre[i]=pre[i-1]+a[i];	//前缀和优化初始化部分
    o=id=0;//记录下标
    for (int i=1;i<=m;i++){
        scanf("%d",&op);
        switch (op){
            case 1:{
                scanf("%d%d%d",&L,&R,&k);
                update(o,1,maxn,k);
                break;
            }
            case 2:{
                scanf("%d%d",&L,&R);
                printf("%lld\n",query(o,1,maxn));
                break;
            }
        }
    }	
    return 0;
}
```


---

## 作者：Krystallos (赞：9)

## 才学线段树不久，写一篇blog加强印象

首先是介绍题目中需要使用的算法or数据结构$\colorbox{white}{\color{white}{\text{但这是模板题，一眼算法or数据结构}}}$：线段树

> 线段树(Segment Tree)是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。——度娘

### 线段树的结构：
![](https://s2.ax1x.com/2019/08/21/mtDIeg.png)

#### 线段树的用处：
可以快速维护出一段区间的和、最大值，快速修改一段区间或一个结点。

本题的题意是：给出一个区间，支持区间修改，区间查询。

## 线段树的性质：
结点$p$的左儿子是$p\times 2$，右儿子是$p\times 2+1$，若结点$p$所代表的区间是$[l,r]$，那么左儿子是$[l,(l+r)\div 2]$，右儿子是$[(l+r)\div 2 + 1,r]$。

存贮线段树单节点的结构体：
```cpp
struct SegmentTree {
	int l, r;
	ll sum, lazy;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define lazy(x) tree[x].lazy
} tree[nn << 3];//8倍空间真是好
```
## 如何构造一棵线段树？
递归构造。当访问到结点$p$时，向下构造。
```cpp
void build(int p, int l, int r) {//当前正在构造结点p，该节点需要代表的区间为[l,r]
	l(p) = l, r(p) = r;
	if (l == r) {
		sum(p) = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(p << 1, l, mid);//向下构造
	build(p << 1 | 1, mid + 1, r);
	sum(p) = sum(p << 1) + sum(p << 1 | 1);
}
```

## 区间查询：
从最大的区间$[1,n]$开始查询，如果当前结点所代表的区间被整个查询区间包含，那么就可以直接返回答案，而不用查询到底。如果不被完全包含，那么先处理$lazy$标记，然后在左右儿子结点继续查询。时间复杂度优秀，单次查询时间复杂度最坏仅$O(n\ logn)$。
```cpp
ll ask(int p, int l, int r) {//当前查询到了p号结点
	ll ans = 0;
	if (l <= l(p) && r(p) <= r)
		return sum(p);
	spread(p);//处理lazy的函数
	int mid = (l(p) + r(p)) >> 1;
	if (l <= mid)//访问左右儿子
		ans += ask(p << 1, l, r);
	if (mid < r)
		ans += ask(p << 1 | 1, l, r);
	return ans;
}
```
## 区间修改：
从最大的区间$[1,n]$开始修改，如果当前结点所代表的区间被整个修改区间包含，更新，整个区间的和，记录$lazy$标记，然后然返回。如果不被完全包含，那么更新当前$lazy$后继续在左右儿子结点修改。时间复杂度优秀，单次修改时间复杂度最坏仅$O(n\ logn)$。
```cpp
void change(int p, int l, int r, ll d) {//当前修改到结点p，需要将区间[l,r]全部增加d
	if (l <= l(p) && r(p) <= r) {//被完全覆盖就更新和与lazy标记
		sum(p) += (r(p) - l(p) + 1) * d;
		lazy(p) += d;
		return;
	}
	spread(p);//处理lazy
	int mid = (l(p) + r(p)) >> 1;
	if (l <= mid)//修改左右儿子
		change(p << 1, l, r, d);
	if (mid < r)
		change(p << 1 | 1, l, r, d);
	sum(p) = sum(p << 1) + sum(p << 1 | 1);//更新和
	return;
}
```
## $lazy$标记的处理（划重点.exe）：
$lazy$标记的含义是：该节点的和已被更新，但其子孙结点的和尚未更新，在查询时，每次向下查询前，先处理$lazy$标记，然后查询，以确保答案的正确性。
```cpp
void spread(int p) {
	if (lazy(p)) {
		sum(p << 1) += lazy(p) * (r(p << 1) - l(p << 1) + 1);//位运算好，支持装逼常数小
		sum(p << 1 | 1) += lazy(p) * (r(p << 1 | 1) - l(p << 1 | 1) + 1);
		lazy(p << 1) += lazy(p);
		lazy(p << 1 | 1) += lazy(p);
		lazy(p) = 0;
	}
}
```

## 主函数：
```cpp
int main() {
	scanf("%d %d", &n, &m);//读入
	for (int i = 1; i <= n; i++)
		scanf("%d", a + i);//读入
	build(1, 1, n);//建树
	while (m--) {
		int op;
		int l, r;
		ll d;
		scanf("%d %d %d", &op, &l, &r);
		if (op == 2)
			printf("%lld\n", ask(1, l, r));//打印答案
		else {
			scanf("%lld", &d);
			change(1, l, r, d);//做修改
		}
	}
	return 0;
}
```
### 好了说了这么多，附上总代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int nn = 1e5 + 5;
typedef long long ll;
struct SegmentTree {
	int l,r;
	ll sum,lazy;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define lazy(x) tree[x].lazy
} tree[nn<<3];
int a[nn],n,m;
void build(int p, int l, int r) {
	l(p) = l, r(p) = r;
	if (l == r) {
		sum(p) = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(p << 1, l, mid);
	build(p << 1 | 1, mid + 1, r);
	sum(p) = sum(p << 1) + sum(p << 1 | 1);
}
void spread(int p) {
	if (lazy(p)) {
		sum(p << 1) += lazy(p) * (r(p << 1) - l(p << 1) + 1);
		sum(p << 1 | 1) += lazy(p) * (r(p << 1 | 1) - l(p << 1 | 1) + 1);
		lazy(p << 1) += lazy(p);
		lazy(p << 1 | 1) += lazy(p);
		lazy(p) = 0;
	}
}
void change(int p, int l, int r, ll d) {
	if (l <= l(p) && r(p) <= r) {
		sum(p) += (r(p) - l(p) + 1) * d;
		lazy(p) += d;
		return;
	}
	spread(p);
	int mid = (l(p) + r(p)) >> 1;
	if (l <= mid)
		change(p << 1, l, r, d);
	if (mid < r)
		change(p << 1 | 1, l, r, d);
	sum(p) = sum(p << 1) + sum(p << 1 | 1);
	return;
}
ll ask(int p, int l, int r) {
	ll ans = 0;
	if (l <= l(p) && r(p) <= r)
		return sum(p);
	spread(p);
	int mid = (l(p) + r(p)) >> 1;
	if (l <= mid)
		ans += ask(p << 1, l, r);
	if (mid < r)
		ans += ask(p << 1 | 1, l, r);
	return ans;
}
int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%d", a + i);
	build(1, 1, n);
	while (m--) {
		int op;
		int l, r;
		ll d;
		scanf("%d %d %d", &op, &l, &r);
		if (op == 2)
			printf("%lld\n", ask(1, l, r));
		else {
			scanf("%lld", &d);
			change(1, l, r, d);
		}
	}
	return 0;
}
```

---

## 作者：NaCly_Fish (赞：9)

这题是在序列上，等价于在链上操作。  
而链就是树的一种特殊情况，我们可以用$\texttt{Link-Cut Tree}$来维护。  
对于$\texttt{access}$这样的基本操作，就不说了。  
我们考虑怎么实现链上加一个数。  

按照套路，我们要用一下$\texttt{split}$操作，把$u\rightarrow v$的节点都搞到一个$\texttt{splay}$里面去。  
此时，我们只需要在$v$节点上打一个标记，操作就算完成了！

为了支持打标记，还需要维护每个点的子树大小。  
在每次$\texttt{pushup}$时，将$u$的子树大小更新为其左右子树之和再$+1$即可。  
最后就是要注意，在$\texttt{pushdown}$的时候，也要下传加法标记。  

于是这题就做完啦qwq  

$\texttt{Code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define N 100003
#define int long long
#define reg register
#define ls son[u][0]
#define rs son[u][1]
using namespace std;

int a[N];

struct Link_Cut_Tree{
    int fa[N],r[N],st[N],son[N][2];
    int s[N],tag[N],size[N];
    
    inline bool notroot(int u){
        return son[fa[u]][0]==u||son[fa[u]][1]==u;
    }
    
    inline void pushup(int u){
        s[u] = s[ls]+s[rs]+a[u];
        size[u] = size[ls]+size[rs]+1;
    }
    
    inline void pushr(int u){
        swap(ls,rs);
        r[u] ^= 1;
    }
    
    inline void pusha(int u,int k){ //打上加法标记
        a[u] += k;
        s[u] += size[u]*k;
        tag[u] += k;
    }

    inline void pushdown(int u){
        if(tag[u]){
            if(ls) pusha(ls,tag[u]);
            if(rs) pusha(rs,tag[u]);
            tag[u] = 0;
        }
        if(!r[u]) return;
        if(ls) pushr(ls);
        if(rs) pushr(rs);
        r[u] = 0;
    }
    
    inline void rotate(int x){
        int y = fa[x],z = fa[y];
        int k = son[y][1]==x,w = son[x][k^1];
        if(notroot(y)) son[z][son[z][1]==y] = x;
        son[x][k^1] = y;
        son[y][k] = w;
        if(w) fa[w] = y;
        fa[y] = x,fa[x] = z;
        pushup(y);
    }
    
    inline void splay(int x){
        int y = x,z = 0;
        st[++z] = y;
        while(notroot(y)) st[++z] = y = fa[y];
        while(z) pushdown(st[z--]);
        while(notroot(x)){
            y = fa[x],z = fa[y];
            if(notroot(y)){
                if((son[y][1]==x)==(son[z][1]==y)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
        pushup(x);
    }
    
    inline void access(int u){
        for(int y=0;u;u=fa[u]){
            splay(u);
            rs = y;
            pushup(u);
            y = u;
        }
    }
    
    inline void makeroot(int u){
        access(u),splay(u);
        pushr(u);
    }
    
    inline void split(int u,int v){
        makeroot(u);
        access(v),splay(v);
    }
    
    inline void link(int u,int v){
        makeroot(u);
        fa[u] = v; //可以不用判,直接link
    }
    
    inline int query(int u,int v){
        split(u,v);
        return s[v];
    }
    
    inline void add(int u,int v,int k){
        split(u,v);
        pusha(v,k);
    }
}T;

int n,q;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

signed main(){
    int op,u,v,k;
    read(n),read(q);
    for(reg int i=1;i<n;++i) T.link(i,i+1);
    for(reg int i=1;i<=n;++i){
        read(a[i]);
        T.size[i] = 1; //注意初始化子树大小
    }
    while(q--){
        read(op),read(u),read(v);
        if(op==1){
            read(k);
            T.add(u,v,k);
        }else{
            print(T.query(u,v));
            putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：信赖滴星辰 (赞：8)

#### [P3372 【模板】线段树 1](https://www.luogu.org/problem/P3372)

-------

~~csp临近，而我还在学线段树……~~

很久之前学过一次，不能完全理解。这次经过老师和GJC大佬的指点终于理解了。

先问一个问题：什么是线段树？

#### 线段 ![线段](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3940143960,214003229&fm=26&gp=0.jpg)

#### 树
![树](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2530578244,2847401891&fm=26&gp=0.jpg)

### 作用

其实线段树就是一个针对区间操作的东西，比如在班级中16到42号中，要找出身高最高的人。如果有多次询问，那么暴力明显是超时的，所以我们需要线段树。

### 实现

#### 1. 最简单的区间求和

先来解决下最简单的区间求和

线段树在计算一个区间的合中，采用了一种二分的思想。一个区间，对半分为两个区间，我们将左区间称为它的左儿子，右区间称为右儿子。这位可爱可亲的父亲等于他两个儿子相加。

很不幸，他的儿子们太大了，计算起来简直和他们的父亲一样困难。因此线段树~~强迫~~他们每人再对半分，每人又生成自己的儿子，同样他们都等于自己的两个儿子相加。

如此反复，线段树源远流长，生生不息。

以此，生成一颗家族（线段）树：

       1
     /   \
    2     3
   / \   / \
  4   5 6   7
  
这里有两个性质：

1.每个人都有自己的编号。设一个人的编号为 n , 他的左儿子的编号 2 * n , 他的右儿子为 2 * n + 1

2.输入时，这颗树有点像广搜的顺序，是一层一层输入进去的，以此我们只要设置一个 tot 变量， 从 1 开始给家族的族长，然后每次输入 tot++ , 以此传下去。

$\mathfrak{Code}$ :

```cpp

#include <iostream>
#include <algorithm>
using namespace std;

int n,a[10004];
int l,r,mid;
int tot=0;

struct node 
{
	int l,r,v;   //左边界、右边界、自己的编号 
};
node e[40004];  //二分需要而外开四倍空间 

void build(int root, int l, int r)
{
	e[root].l = l, e[root].r = r;
	
	if( l == r ) //左边界等于右边界，说明他没有儿子，因此输入给他 
	{
		e[root].v = a[++tot];   //输入 
	
		return;
	}
	
	int mid = (l+r)/2;   //区分左右儿子的中间接线 
	   
	build( 2*root, l, mid );   //左儿子 
	
	build( 2*root+1, mid+1, r );  //右儿子 
	
	e[root].v = e[ 2*root ].v + e[ 2*root+1 ].v;  //每个人都等于他的左儿子和右儿子相加 
	
	//cout << e[root].v << endl;
}

int find(int root, int l, int r)
{
	//cout << root << " " << l <<" " << r <<endl;
	
	if( l>r ) return 0;   
	
	if( e[root].l == l && e[root].r == r ) return e[root].v;  //说明他的值已经算出来了 
	
	int mid = ( e[root].l + e[root].r )/2;  //这里千万不要打成上面的 int mid = (l+r)/2;
	
	if( r <= mid ) return find( root*2, l, r );   //这里开始计算 
	
	else if( mid < l ) return find( root*2+1, l, r );
	
	else
	{
		return find( root*2, l, mid ) + find( root*2+1, mid+1, r );
	}
}

int main()
{
	cin >> n;
	
	for(int i=1; i<=n; i++) scanf( "%d", &a[i] );
	
	build(1, 1, n);
	
	for(int i=1; i<=n; i++)
	{
		cin >> l >> r;
		
		cout << find( 1, l, r ) << endl;
	}	
	
return 0;	
}


```

注意：

1. find 函数里 int mid = ( e[root].l + e[root].r )/2;  //这里千万不要打成 build 函数里的 int mid = (l+r)/2;

2. 计算的部分建议手画一下

3. 是 r <= mid 而不是 r < mid


#### 2. 区间最大值与最小值的差值

与上文差不多，只不过区间求和换成找出最大值与最小值


$\mathfrak{Code}$:

```cpp

#include <iostream>
#include <cstdio>
using namespace std;

int n,Q;
int a[50004];
int l,r,mid;
int tot=0;

struct node
{
	int l,r,max_v,min_v;
};
node e[200004];

int find_max( int rt, int l, int r )
{
	if( l>r ) return 0;
	if( e[rt].l == l && e[rt].r == r ) return e[rt].max_v;
	
	int mid = ( e[rt].l + e[rt].r )/2;
	
	if( r<=mid ) return find_max( rt*2, l, r );  
	
	else if( l>mid ) return find_max( rt*2+1, l, r );
	
	else return max( find_max( rt*2, l, mid ) , find_max( rt*2+1 , mid+1, r ) );
}

int find_min( int rt, int l, int r )
{
	if( l>r ) return 0;
	if( e[rt].l == l && e[rt].r == r ) return e[rt].min_v;
	
	int mid = ( e[rt].l + e[rt].r )/2;
	
	if( r<=mid ) return find_min( rt*2, l, r );  
	
	else if( l>mid ) return find_min( rt*2+1, l, r );
	
	else return min( find_min( rt*2, l, mid ) , find_min( rt*2+1 , mid+1, r ) );
}

void build(int rt, int l, int r )
{
	int mid = (l+r)/2;
	e[rt].l = l, e[rt].r = r;

	if( l == r ) 
	{
		e[rt].max_v = a[++tot];
		e[rt].min_v = e[rt].max_v;
		return;
	}
	
	build( 2*rt, l, mid );
	build( 2*rt+1, mid+1, r );
	
	e[rt].max_v = max( e[2*rt].max_v , e[2*rt+1].max_v );
	e[rt].min_v = min( e[2*rt].min_v , e[2*rt+1].min_v );
}

int main()
{
	cin >> n >> Q;
	
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
	
	build( 1, 1, n);
	
	for(int i=1; i<=Q; i++)
	{
		scanf( "%d%d", &l,&r );
		
		printf( "%d\n",find_max(1,l,r) - find_min(1,l,r) );
	}

return 0;	
}

```
------
#### 3. 这道题目之解

对于这道题目，区间求和我们已经知道了，那么我们来说说较难的区间加。

其实重要的就两点：

1. 对于一个区间，有n个数，每个数都加k, 那么整个区间就加上 n*k

2. 这个父亲加上了多少值，需要把这个值传给他的两个儿子，然后他加的值清零


$\mathfrak{Code}$:

```cpp
#include <iostream>
#include <algorithm>
#include <cstring> 
# define ll long long 
using namespace std;

ll n,a[100004],Q;
ll l,r,mid;
ll tot=0;
ll tem ,k;

struct node 
{
	ll l,r,v;
	ll jia;   //这个东西代表他要加的值 
};
node e[400004];

void build(ll root, ll l, ll r)
{
	e[root].l = l, e[root].r = r;
	
	if( l == r ) 
	{
		e[root].v = a[++tot];
	
		return;
	}
	
	ll mid = (l+r)/2;
	
	build( 2*root, l, mid );
	
	build( 2*root+1, mid+1, r );
	
	e[root].v = e[ 2*root ].v + e[ 2*root+1 ].v;
	
	//cout << e[root].v << endl;
}

void gengxin(ll root)
{
	if( e[root].jia != 0 )
	{
		e[root*2].v += (e[root*2].r - e[root*2].l + 1) * e[root].jia;
		e[root*2+1].v += (e[root*2+1].r - e[root*2+1].l + 1) * e[root].jia;
		
		e[root*2].jia += e[root].jia;    //这个父亲加上了多少值，
		e[root*2+1].jia += e[root].jia;  //需要把这个值传给他的两个儿子
		e[root].jia = 0;                 //然后他加的值清零
	}
}

void PLUS( ll root, ll l, ll r, ll k )
{
	//cout << root << " " << l << " " << r << "jhsdbfvhdsbhfdsbfb";
	//cout << e[root].l << " " << e[root].r << endl;
	if( l>r ) return; 
	
	if( e[root].l == l && e[root].r == r ) 
	{
		e[root].v += (e[root].r - e[root].l + 1) * k;
		e[root].jia += k;
		return;
	}
	
	gengxin( root );   //实时更新 
	
	ll mid = ( e[root].l + e[root].r )/2;
	
	if( r <= mid ) PLUS( root*2, l, r, k );
	
	else if( mid < l ) PLUS( root*2+1, l, r, k );
	
	else
	{
		PLUS( root*2, l, mid, k );
		PLUS( root*2+1, mid+1, r, k );
	}
	
	e[root].v = e[root*2].v + e[root*2+1].v;
}

ll find(ll root, ll l, ll r)
{
	//cout << root << " " << l <<" " << r <<endl;
	
	if( l>r ) return 0;
	
	if( e[root].l == l && e[root].r == r ) 
	{
		return e[root].v;
	}
	
	gengxin( root );
	
	ll mid = ( e[root].l + e[root].r )/2;
	
	if( r <= mid ) return find( root*2, l, r );
	
	else if( mid < l ) return find( root*2+1, l, r );
	
	else
	{
		return find( root*2, l, mid ) + find( root*2+1, mid+1, r );
	}
}

int main()
{
	cin >> n >> Q;
	
	for(ll i=1; i<=n; i++) cin >> a[i];
	
	memset( e, 0, sizeof(e) );
	
	build(1, 1, n );
	
	for(ll i=1; i<=Q; i++)
	{
		cin >> tem;
		
		if( tem == 1 )
		{
			cin >> l >> r >> k;
			
			PLUS( 1, l, r, k ); 
		}
		
		else if( tem == 2 )
		{
			cin >> l >> r;
			cout << find( 1, l, r ) << endl;
		}
	}	
	
return 0;	
}

```
----------

加油叭，没那么难哒

昨天凌晨玩三国杀被同学举报，明天可能要全校出名，写篇题解压压惊，求过QwQ

















---

## 作者：老部长 (赞：8)

# 对于线段树千万不要嫌烦

第一遍可以抄一遍题解，大致了解方法；

第二遍半看半打，加深印象；

第三遍就可以开始自己打；

# 绝对有效

~~虽然我也不熟~~


------------
## 关于线段树大佬们已经讲的很清楚了，我在这里讲几个蒟蒻容易犯的错误(~~线段树的坑~~)：

1. 不开**long long**见祖宗，要开**long long**，一定要开

2. 每个修改操作的函数中一定要**明确出口**（return不能少，具体见代码）

3. 记录线段树数值和懒标记的**数组至少要开n的4倍**

4. 每打完一部分就要**检查**，否则你将会献出一上午（~~大佬请忽略此条~~）

5. 再码字途中，线段树会出现 int mid=(l+r)/2这样的语句，mid也有的写成m，所以这时要注意**分清楚题目中的m**(通常是操作次数)和mid

6. 懒标记要下传

7. 懒标记一定要乘区间长度，并注意 **大减小** (r-l)，反正这是我犯的一个ZZ错误

8. 不要忘记**调用build()函数**（不开玩笑，新手经常忘）

9. 当要进行区间**乘一个数操作时，懒标记初始要设为1**，(而不是加法懒标记初始为0)

10. 当进行多种运算操作是，要注意修改顺序，一般是**先乘除，再加减**

11. 码字时可以**尽量写的散一些**，反正就是要自己看着不会头皮发麻，这样检查时很省事



------------

题目传送门[P3372 【模板】线段树 1](https://www.luogu.org/problemnew/show/P3372)


------------


代码来了：
```cpp
#include<bits/stdc++.h>//代码写散，可以按自己习惯来，怎么看着舒服怎么打
#define ll long long//一定要开long long 
#define re register int//常数优化 
using namespace std;
const int N=100005;

inline ll read()//快读
{
	ll x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
	return x*f;
}

int n,m;
ll ans[N<<2],tag[N<<2];//数组开四倍 
int a[N];

inline ll ls(int root)//左儿子 
{return root<<1;}

inline ll rs(int root)//右儿子 
{return root<<1|1;}

inline void push_up(int root)//向父节点传修改值 
{ans[root]=ans[ls(root)]+ans[rs(root)];}

inline void build(int root,int l,int r)
{
	if(l==r)
	{
		ans[root]=a[l];
		return;
	}
	
	int mid=(l+r)>>1;
	build(ls(root),l,mid);
	build(rs(root),mid+1,r);
	push_up(root);//向父节点传修改值 
}

inline void f(int root,int l,int r,ll k)
{
	tag[root]+=k;
	ans[root]+=k*(r-l+1); 
}

inline void push_down(int root,int l,int r)//向下传递懒标记 
{
	int mid=(l+r)>>1;
	f(ls(root),l,mid,tag[root]);
	f(rs(root),mid+1,r,tag[root]);
	tag[root]=0;
}

inline void add(int root,int nl,int nr,int l,int r,ll k)
{
	if(nl<=l&&nr>=r)
	{
		ans[root]+=k*(r-l+1);
		tag[root]+=k;
		return;
	}
	
	push_down(root,l,r);//向下传递懒标记 
	int mid=(l+r)>>1;
	if(nl<=mid)add(ls(root),nl,nr,l,mid,k);//修改儿子的值 
	if(nr>mid)add(rs(root),nl,nr,mid+1,r,k);
	push_up(root);//向父节点传修改值 
}

inline ll query(int root,int nl,int nr,int l,int r)
{
	ll res=0;
	if(nr>=r&&nl<=l)return ans[root];
	int mid=(l+r)>>1;
	push_down(root,l,r);//向下传递懒标记 
	
	if(nl<=mid)
	    res+=query(ls(root),nl,nr,l,mid);
	    
	if(nr>mid)
	    res+=query(rs(root),nl,nr,mid+1,r);
	    
	return res; 
}

int main()
{
	n=read();m=read();
	for(re i=1;i<=n;i++)a[i]=read();
	build(1,1,n);//不要丢 
	while(m--)
	{
		int x,y,cxk;//嘻嘻(●'◡'●)
                ll k;//k要开long long 其他的无所谓 
		cxk=read();
		if(cxk==1)
		{
			x=read();y=read();k=read();
			add(1,x,y,1,n,k); 
		}
		else
		{
			x=read();y=read();
			printf("%lld\n",query(1,x,y,1,n));//输出也要 lld 
		}
	}
	return 0;
}
```
本题解借鉴部分WTB%%%大佬的博客，[放链接](https://www.luogu.org/blog/YogSothoth/)

---

## 作者：installb (赞：8)

**upd 2019.05.25**

本文文字较多，图片比较少  
~~BTW线段树本身好像是个数据结构~~  
## 0.前言  
很多人都是先学树状数组再学线段树的 包括某本通也把树状数组写在线段树前面 这可能是因为树状数组简单而且好写 确实 但是我觉得树状数组的思想是基于线段树的 线段树其实应该更基础  
## 1.概念
~~其实这个有点难讲清楚~~  
线段树是一棵有根树 线段树的每一个点保存的是一个区间 根节点的区间为$[1,n]$  
对于每一个节点 它可能是以下两种情况之一  
- 是叶子结点  
- 有2个儿子(左/右)  
对于每个节点 若这个节点的区间为$[l,r]$  
- 当$l==r$时 它是叶子结点  
- 否则 设区间中点为$mid=(l+r)/2$ 它的左儿子区间为$[l,mid]$ 右儿子区间为$[mid+1,r]$  
**线段树不一定是完全二叉树或者满二叉树!**  
但是它一定是满二叉树的一部分 所以我们可以用满二叉树标记点的编号的方法  
即编号$id$的节点 左儿子编号$id*2$ 右儿子编号$id*2+1$  

下面是一个n=6时的线段树 点的编号在点右边  
![](https://cdn.luogu.com.cn/upload/pic/58470.png)  
区间对半分的原因 是为了保证树高在$logn$级别

## 2.应用  
what can it do  
在$logn$时间内
- 查询一个区间的信息(包括但不限于最大值,最小值,和)
- 修改一个区间的信息  
并且可以同时维护不止一种信息

## 3.实现  
在这里实现的是区间求和功能 其它功能可以通过修改部分函数和语句实现 但是框架是相同的  

**这里我先做了三个define**  
```cpp
#define mid ((l + r) >> 1) // [l,r]中点 即 (l + r)/2
#define lson (x << 1) // 左儿子编号 x * 2 x为待处理结点
#define rson ((x << 1) | 1) // 右儿子编号 x * 2 + 1
```

### 1.建树  
事实上建树可以被区间修改替代 但是这样会慢很多 因为往全零的树上一个个加湿$nlogn$的  
建树build操作就是把初始数组放到树的叶子结点里 然后把每一个节点的值计算出来  

假设a数组是原来数组  
```cpp
void build(int x,int l,int r){
	if(l == r){ val[x] = a[l]; return; }
	build(lson,l,mid); build(rson,mid + 1,r);
	val[x] = val[lson] + val[rson];
}
```  
递归直到叶子结点 然后非叶子结点 先处理左右儿子 之后它的值等于左右儿子值之和  
**其实最后一句话应该写成一个函数pushup(通过左右儿子信息更新当前点信息) 我在这里没有写函数**
### 2.区间询问  
我们可以理解为把一个区间拆成一定数量的区间  
最后的答案是拆成的区间的答案之和  
而拆成的每一个区间是线段树某个节点的表示的范围  
eg:  
当n=6时
```cpp
[2,6]->[2,2]+[3,3]+[4,6]
[1,5]->[1,3]+[4,5]
```  
拆完以后区间数量一定是至多$logn$级别的 证明在后面  

我们还是可以通过递归的方式实现  
但是不一定是左右儿子都要继续递归  
假设带查询区间为$[L,R]$
- 如果当前带查询节点代表的区间包含在待查询区间内 定义这个节点为**完整节点** 将答案加上该处的值 不用继续递归了  
- 如果该节点左儿子区间和$[L,R]$的交集不为空 则递归左子树  
- 右儿子同理  

代码:  
```cpp
LL query(int x,int l,int r,int L,int R){
	// l,r 为x节点代表的区间范围 L,R为带查询区间
	if(L <= l && r <= R) return val[x];
	LL ret = 0; pushdown(x,l,r);
	if(L <= mid) ret += query(lson,l,mid,L,R);
	if(mid < R) ret += query(rson,mid + 1,r,L,R);
	val[x] = val[lson] + val[rson]; // 就是pushup
	return ret;
}
```  
**pushdown的意义会在下文修改中提到**  

复杂度证明(这不是重点):  
线段树的每一层至多访问4个节点  
首先 只有可能在[L,R]的两端出现非完整节点(就是 不是完整节点的点) 所以每一层至多有2个非完整节点  
完整节点一定也至多只有2个 且为非完整节点的兄弟节点  
如果存在其它的完整节点 它的兄弟节点也一定是完整节点  
**这样的话这两个节点就不会被访问到 它们的父亲节点已经不会递归下去了**  

~~于是线段树常数就大了~~

### 3.区间修改  
我们需要引入一个叫做标记(lazytag)的东西  
因为区间修改是需要一路改到叶子节点的 所以如果把[1,n]修改 **会把整棵树每个节点都改一遍** 这样就无法做到$logn$复杂度  

所以 当我们面对一个完整节点的时候 我们可以先修改这个完整节点的值 然后给这个节点**打一个标记** 标记代表的是这个点的**左右儿子需要修改**的量 就是说先改了自己 等**要用左右儿子之后再改**左右儿子  
我们给这个标记的值**加上待修改的数**(比如区间+n就是给这个标记的值+n 标记初始值为0) 然后不需要再递归下去 当我们不可避免要查询这个节点的左右儿子的时候 就把这个标记通过一种方式(pushdown函数)下传  

标记意义在于避免重复计算 可以直接把复杂度降到$logn$级别  

如果对于一个询问或修改这个点是非完整节点 我们需要改它的儿子节点 那么我们就需要pushdown(标记下传)了  

pushdown也很简单  
就是把tag传给左右儿子 同时改掉左右儿子的值 然后把自己tag清掉  
pushdown的写法对于不同的题目是不同的  
当一个节点是非完整节点时 它就必须下传标记  

主体思路和区间查询一样  

```cpp
void modify(int x,int l,int r,int L,int R,LL v){
	if(L <= l && r <= R){ apply(x,l,r,v); return; }
    // 完整节点 修改tag和值
	pushdown(x,l,r);
	if(L <= mid) modify(lson,l,mid,L,R,v);
	if(mid < R) modify(rson,mid + 1,r,L,R,v);
	val[x] = val[lson] + val[rson]; // 这是pushup!!!
}
```  
apply函数即为修改节点x  
修改的方式根据题目而定  

```cpp
void apply(int x,int l,int r,int v){
	val[x] += (LL)(r - l + 1) * v; add[x] += v;
}
```

放上pushdown函数  
```cpp
void pushdown(int x,int l,int r){
	if(!tag[x]) return;
	apply(lson,l,mid,tag[x]);
	apply(rson,mid + 1,r,tag[x]);
	tag[x] = 0;
}
```  
修改值的时候 就是加上**标记改变量**$*$**区间长度**  
### 4.总结  
对于任何一个有可能改动左右儿子值(任何信息)的操作 在操作的最后都要pushup(通过左右儿子信息更新当前点信息)  

**代码(P3372线段树1):**  

里面的add就是tag
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#define mid ((l + r) >> 1)
#define lson (x << 1)
#define rson ((x << 1) | 1)
using namespace std;
typedef long long LL;

LL add[800005] = {0};
LL val[800005] = {0};
LL a[200005] = {0};

void build(int x,int l,int r){
	if(l == r){ val[x] = a[l]; return; }
	build(lson,l,mid);
	build(rson,mid + 1,r);
	val[x] = val[lson] + val[rson];
}

void apply(int x,int l,int r,int v){
	val[x] += (LL)(r - l + 1) * v; add[x] += v;
}

void pushdown(int x,int l,int r){
	if(!add[x]) return;
	apply(lson,l,mid,add[x]);
	apply(rson,mid + 1,r,add[x]);
	add[x] = 0;
}

void modify(int x,int l,int r,int L,int R,LL v){
	if(L <= l && r <= R){ apply(x,l,r,v); return; }
	pushdown(x,l,r);
	if(L <= mid) modify(lson,l,mid,L,R,v);
	if(R > mid) modify(rson,mid + 1,r,L,R,v);
	val[x] = val[lson] + val[rson];
}

int query(int x,int l,int r,int L,int R){
	if(L <= l && r <= R) return val[x];
	LL ret = 0;
	pushdown(x,l,r);
	if(L <= mid) ret += query(lson,l,mid,L,R);
	if(R > mid) ret += query(rson,mid + 1,r,L,R);
	val[x] = val[lson] + val[rson];
	return ret;
}

int n,m,b,c,op;
LL k;

int main(){
	cin >> n >> m;
	for(int i = 1;i <= n;i ++) cin >> a[i];
	build(1,1,n);
	while(m --){
		cin >> op;
		if(op == 1){ cin >> b >> c >> k; modify(1,1,n,b,c,k); }
		if(op == 2){ cin >> b >> c; cout << query(1,1,n,b,c) << endl; }
	}
	return 0;
}
```  
## 4.总结  
事实上线段树要改的就apply和pushup
~~好像没什么好总结了~~  
线段树的应用范围还是很大的 通过保存信息 信息上传下传的不同写法 可以实现很多问题  
并且线段树查询/修改的复杂度为$logn$  
线段树的应用范围不如分块广 但是比分块的$n\sqrt n$快  
同时线段树事实上很容易实现  
一般多敲几遍就可以**5min**左右解决模板  
总之还是个很有用的数据结构  



好的 **此文章完结**

---

## 作者：wcr20020327 (赞：8)

## 新人蒟蒻前来水一次博客
emmmmm线段树真是个~~耗头发的~~好东西。  
话不多说上代码【语文差的555】	
#### 头文件及定义等
```cpp
//其实用不到这么多
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<ctime>
#define N 100010
using namespace std;
#define ll  long long 
#define ill inline long long
ll n,m,a,b,c,f;//不解释
ll tr[N<<1],//本体
R[N<<1],L[N<<1],//左右子树
Lazy[N<<1],//懒标
cnt,root,now;//节点个数，根节点，当前节点
//线段树动态开点一般二倍即可【听说静态开点要四倍】
ll tp;//存储某些临时变量以备不时之需
```
#### 单点插入【可以当做建树使用】（insert_single）
		从上到下每一个包含修改值的区间均需要修改。
```cpp
ill insert_sgl(ll &now,ll l,ll r,ll nu,ll po)
//num(插入值),position(插入位置)
{
    if(!now)now=++cnt;
    tr[now]+=nu;if(!(r-l))return nu;
    ll mid=(l+r)>>1;
    if(po<=mid)return insert_sgl(L[now],l,mid,nu,po);
    else return insert_sgl(R[now],mid+1,r,nu,po);
}
```
#### 区间插入（insert_interval）
```cpp
ill insert_ivl(ll &now,ll l,ll r,ll nu,ll pl,ll pr)
{
    if(now==0)now=++cnt;
    if(pl<=l&&pr>=r)//当前区间完全属于查询区间时
	{tr[now]+=nu*(r-l+1);//区间长度=右端点-左端的+1；
	Lazy[now]+=nu;//打上lazytag
    return nu;}
	pushdown(now,l,r);//顺手下推
    ll mid=(l+r)>>1;
    if(pl<=mid)  insert_ivl(L[now],l,mid,nu,pl,pr);
    if(pr>mid) insert_ivl(R[now],mid+1,r,nu,pl,pr);
    pushup(now);
	return nu;
}
```
## 线段树的精髓操作来了！

先介绍下懒人标记：	
所谓懒人标记其实是一种延迟性质的操作~~用来显示自己与众不同~~ ，把所有的修改操作堆积起来，等到查询的时候统一完成~~像不像开学前一晚上的你~~，这里我们需要两个辅（zhong）助（yao）函数：下推（pushdown）,上拉（pushup）操作;	
```cpp
ill pushdown(ll& now,ll l,ll r)//下推
//把自己的lazytag下发给左右儿子，并清除标记
{
	if(Lazy[now])
	{
		ll mid=(l+r)>>1;
		if(L[now]==0)L[now]=++cnt;//动态开点操作
        Lazy[L[now]]+=Lazy[now];
		tr[L[now]]+=Lazy[now]*(mid-l+1);
        //标记打在哪，区间就更新到哪
		if(R[now]==0)R[now]=++cnt;
        Lazy[R[now]]+=Lazy[now];
		tr[R[now]]+=Lazy[now]*(r-mid);
        //有标记的区间一定是运算过的
		Lazy[now]=0;
	}
	return now;
}

ill pushup(ll &now)
{
	return tr[now]=tr[L[now]]+tr[R[now]];
} 
//个人觉得这个完全可以宏定义或者一行代码写在程序后，
//但为了不让下推单着【误】，故写在这里博君一笑。
```
pushdown操作发生在修改操作最前，pushup操作发生在修改操作最后。（有点类似逆操作）？
#### 区间查询（query_interval）
查询时记得要顺手下推。
```cpp
ill query_ivl(ll &now,ll l,ll r,ll ql,ll qr)
{
    if(l>=ql&&r<=qr)return tr[now];
    //如果区间完全被包含在查询区间内则必然被更新过，
    //可直接返回
    pushdown(now,l,r);
    ll mid=(l+r)>>1;
    ll ls=0;
    if(ql<=mid) ls+=query_ivl(L[now],l,mid,ql,qr);
    if(qr>mid) ls+=query_ivl(R[now],mid+1,r,ql,qr);
    return ls;
}
```
#### 主程序
```cpp
int main()
{
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;i++)
    {
        scanf("%lld",&tp);
        insert_sgl(root,1,n,tp,i);//一切都要从头来
    }
    for(ll i=1;i<=m;i++)
    {
        scanf("%lld",&f);
        if(f==1)
        {
            scanf("%lld%lld%lld",&a,&b,&c);
            insert_ivl(root,1,n,c,a,b);
        }
        if(f==2)
        {
            scanf("%lld%lld",&a,&b);
            printf("%lld\n",query_ivl(root,1,n,a,b));
        }
    }
    return 0;
}
```


---

## 作者：crashed (赞：7)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（对$Splay$轻车熟路的各位大佬就可以跳过本帖了）  
# 前置知识
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不知道$Splay$是什么，请移步[洛谷日报第62期](https://www.luogu.org/blog/wym483739/xue-tu-lun-ni-zhen-di-liao-xie-zui-duan-lu-ma-post)。  
# 正文
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知（雾），$Splay$有着强大的处理区间的能力。由此我们很自然地想到让它来处理经典的$RSQ$问题（区间和问题）。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Splay$节点里面**维护**的是子树的权值和。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来考虑单点修改，区间查询的简单模型：  
### 单点修改，区间查询
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~肥肠~~非常简单，只需要把对应的节点拉出来~~修理一通~~修改存的权值即可。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下假设这个查询的区间为$[l,r](1\leq l\leq r\leq n,l,r,n\in N_+)$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易发现，在序列上，$[l,r]=(l-1,r+1)$，也就是说，假如我们把$l-1$$splay$到根，然后把$r+1$$splay$到根的儿子，这样$r+1$的左儿子就必然是区间$[l,r]$，所以$r+1$的左儿子维护的子树权值和也就是区间和。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看图说明一切（~~不好意思是从洛谷日报上面抠下来的~~）： 
![Splay区间](https://inf.tiger0132.tk/2018/07/19/splay-notes/reverse.svg)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，为了避免在处理区间的边界情况的时候翻车，所以我们分别新建两个“哨兵”节点（就像$zkw$线段树一样），权值均为$0$。这样就不用考虑边界了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就此，单点修改，区间查询的问题就被我们轻松地解决了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题见[P3372 【模板】树状数组 1](https://www.luogu.org/problem/P3374)  。（由于~~我的~~$Splay$有常数问题，所以有可能需要开$O2$）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下：  
```cpp
#include <cstdio>

const int MAXN = 500005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int ch[MAXN][2], par[MAXN], cnt[MAXN], s[MAXN], key[MAXN], val[MAXN];
int N, M, rt = 0, len = 0;

int chk( const int x )
{
	return ch[par[x]][1] == x;
}

void pushup( const int x )
{
	s[x] = s[ch[x][0]] + s[ch[x][1]] + cnt[x] * val[x];
}

void rotate( const int x )
{
	int y = par[x], z = par[y], side = chk( x ), son = ch[x][! side];
	if( y ) ch[y][side] = son;
	if( son ) par[son] = y;
	if( z ) ch[z][chk( y )] = x;
	if( x ) par[x] = z;
	if( x ) ch[x][! side] = y;
	 par[y] = x;
	pushup( y ), pushup( x );
}

void splay( const int x, const int tar = 0 )
{
	int y, z;
	while( ( y = par[x] ) ^ tar )
	{
		z = par[y];
		if( z ^ tar )
		{
			if( chk( y ) == chk( x ) ) rotate( y );
			else rotate( x );
		}
		rotate( x );
	}
	if( ! tar ) rt = x;
}

void find( const int nKey )
{
	if( ! rt ) return;
	int p = rt;
	while( ch[p][nKey > key[p]] && nKey ^ key[p] )
	{
		p = ch[p][nKey > key[p]];
	}
	splay( p );
	return;
}

void insert( const int nKey, const int nVal )
{
	int p = rt, fa = 0;
	while( p && nKey ^ key[p] )
	{
		fa = p;
		p = ch[p][nKey > key[p]];
	}
	if( p ) cnt[p] ++;
	else
	{
		p = ++len;
		if( p == 1 ) rt = p;
		if( fa ) par[p] = fa, ch[fa][nKey > key[fa]] = p;
		ch[p][0] = ch[p][1] = 0;
		cnt[p] = 1, key[p] = nKey, val[p] = nVal;
	}
	pushup( p );
	splay( p );
}

//正紧的Splay

void update( const int nKey, const int addVal )
{
	find( nKey );
	if( key[rt] ^ nKey ) return;
	val[rt] += addVal;
	pushup( rt );
}

int query( const int segL, const int segR )
{
	int ll = segL, rr = segR + 2;
	splay( ll ), splay( rr, ll );
	return s[ch[rr][! chk( rr )]];
}

//修改与查询

int main()
{
	int v;
	read( N ), read( M );
	insert( 0, 0 );
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( v );
		insert( i, v );
	}
	insert( N + 1, 0 );
    //在循环外的insert就是在新建“哨兵”
	int op, x, y;
	while( M -- )
	{
		read( op );
		read( x ), read( y );
		if( op == 1 )
		{
			update( x, y );
		}
		else
		{
			write( query( x, y ) ), putchar( '\n' );
		}
	}
	return 0;
}
```
### 区间修改，区间查询
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这个的问题查询和单点修改的情况没有区别，所以查询部分就不再赘述。这主谈修改。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先按照查询的方法把区间给$splay$出来。模仿线段树，我们对这个区间打标记。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;怎么打呢？  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好问题！（大雾）我们先对这个区间对应的子树的根上标记。在什么时候下传标记呢？这遵循一个原则，即——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**当父子关系即将改变时，就一定要先下传父亲上面的懒标记！**  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~然后除了这个原则，就没什么可写的了~~  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，记得在$pushup$的时候也要注意一下懒标记的影响哟。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例题：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[P3372 【模板】线段树 1](https://www.luogu.org/problem/P3372)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[P3373 【模板】线段树 2](https://www.luogu.org/problem/P3373)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考代码：（只有第一道例题的）  
```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 500005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

LL s[MAXN], val[MAXN], lazy[MAXN];
int ch[MAXN][2], par[MAXN], cnt[MAXN], key[MAXN], siz[MAXN];
int N, M, rt = 0, len = 0;

int chk( const int x )
{
	return ch[par[x]][1] == x;
}

void pushup( const int x )
{
	siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + cnt[x];
	s[x] = s[ch[x][0]] + s[ch[x][1]] + cnt[x] * val[x] + lazy[x] * siz[x];
    //用懒标记修正
}

void pushdown( const int x )
{
	if( x && lazy[x] )
	{
		val[x] += lazy[x];
		if( ch[x][0] ) lazy[ch[x][0]] += lazy[x];
		if( ch[x][1] ) lazy[ch[x][1]] += lazy[x];
		lazy[x] = 0;
		pushup( ch[x][0] );
		pushup( ch[x][1] );
		pushup( x );
        //记得随时pushup！
	}
}

void rotate( const int x )
{
	int y = par[x], z = par[y], side = chk( x ), son = ch[x][! side];
	pushdown( z );
	pushdown( y );
	pushdown( x );
    //先pushdown再旋转
	if( z ) ch[z][chk( y )] = x;
	if( y ) ch[y][side] = son, par[y] = x;
	if( son ) par[son] = y;
	par[x] = z, ch[x][! side] = y;
	pushup( y );
	pushup( x );
	pushup( z );
}

void splay( const int x, const int tar = 0 )
{
	int y, z;
	while( ( y = par[x] ) ^ tar )
	{
		z = par[y];
		if( z ^ tar )
		{
			if( chk( y ) == chk( x ) ) rotate( y );
			else rotate( x );
		}
		rotate( x );
	}
	if( ! tar ) rt = x;
}

void find( const int nKey )
{
	if( ! rt ) return;
	int p = rt;
	while( ch[p][nKey > key[p]] && nKey ^ key[p] )
	{
		p = ch[p][nKey > key[p]];
	}
	splay( p );
	return;
}

void insert( const int nKey, const int nVal )
{
	int p = rt, fa = 0;
	while( p && nKey ^ key[p] )
	{
		fa = p;
		p = ch[p][nKey > key[p]];
	}
	if( p ) cnt[p] ++;
	else
	{
		p = ++len;
		if( p == 1 ) rt = p;
		if( fa ) par[p] = fa, ch[fa][nKey > key[fa]] = p;
		ch[p][0] = ch[p][1] = 0;
		cnt[p] = 1, key[p] = nKey, val[p] = nVal;
	}
	pushup( p );
	splay( p );
}

void update( const int segL, const int segR, const LL addVal )
{
	int ll = segL, rr = segR + 2;
	splay( ll ), splay( rr, ll );
	lazy[ch[rr][! chk( rr )]] += addVal;
	pushup( ch[rr][! chk( rr )] );
}

LL query( const int segL, const int segR )
{
	int ll = segL, rr = segR + 2;
	splay( ll ), splay( rr, ll );
	pushup( ch[rr][! chk( rr )] );
	return s[ch[rr][! chk( rr )]];
}

int main()
{
	int v;
	read( N ), read( M );
	insert( 0, 0 );
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( v );
		insert( i, v );
	}
	insert( N + 1, 0 );
	int op, x, y;
	while( M -- )
	{
		read( op );
		read( x ), read( y );
		if( op == 1 )
		{
			read( v );
			update( x, y, v );
		}
		else
		{
			write( query( x, y ) ), putchar( '\n' );
		}
	}
	return 0;
}
```

---

## 作者：a41881147 (赞：7)

zkw线段树 （表示总共跑了0.2s+）确实快...

讲解都在注释中~


源代码








```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define lc d<<1
#define rc d<<1|1
using namespace std;
int n,m,M;
struct node{long long sum,lazy,num;}tr[1<<20];
void build()
{
    for (M=1;M<=n;M<<=1);
    for (int i=1;i<=n;i++) scanf("%lld",&tr[i+M].sum),tr[i+M].num=1;
    for (int d=M-1;d;d--) 
        tr[d].sum=tr[lc].sum+tr[rc].sum,tr[d].num=tr[lc].num+tr[rc].num;
}
//这个区间修改跟网上绝大多数题解不同,网上题解有什么前缀和...这里就是打标记,向上走的时候加上
void change(int x,int y,long long turnto)
{
    int numx=0,numy=0;//numx表示走到x这个点,本次修改中 下面被修改了多少点(这些点都是x控制的),numy同
    for (x+=M,y+=M;x^y^1;x>>=1,y>>=1)
        {
            tr[x].sum+=turnto*numx;//一定要 先更新当前节点,再考虑x+1号节点
            if (!(x&1))  //给x+1打标记,并且更新tr[x+1].sum,numx也要更新...因为向上走,x的父亲控制的 在本次操作中被修改的 点变多了 
                tr[x+1].lazy+=turnto,numx+=tr[x+1].num,tr[x+1].sum+=tr[x+1].num*turnto;
            tr[y].sum+=turnto*numy;//同上 
            if ((y&1))
                tr[y-1].lazy+=turnto,numy+=tr[y-1].num,tr[y-1].sum+=tr[y-1].num*turnto;
        }
    for (;x>=1&&y>=1;x>>=1,y>>=1)//注意这里,标记在上面打完了,但是修改sum要到顶...(显然呢...)
        tr[x].sum+=turnto*numx,tr[y].sum+=turnto*numy;
}
long long ask(int x,int y)
{
    long long rt=0,numx=0,numy=0;
    for (x+=M,y+=M;x^y^1;x>>=1,y>>=1)
        {
            rt+=tr[x].lazy*numx+tr[y].lazy*numy;//当前x点和y点下面有多少点,分别乘各自的lazy标记
            if (!(x&1)) rt+=tr[x+1].sum,numx+=tr[x+1].num;
            if (y&1) rt+=tr[y-1].sum,numy+=tr[y-1].num;
        }
    for (;x>=1&&y>=1;x>>=1,y>>=1)//x和y及其上面的点 有可能还有lazy标记,要加上...
        rt+=tr[x].lazy*numx+tr[y].lazy*numy;    
    return rt;
}
int main()
{
    int i,j,k,opp,x,y;long long z;
    cin>>n;cin>>m;
    build();
    for (i=1;i<=m;i++)
        {
            scanf("%d%d%d",&opp,&x,&y);
            if (opp==2)printf("%lld\n",ask(x-1,y+1));
            else 
                {
                    scanf("%lld",&z);
                    change(x-1,y+1,z);
                }
        }
}

```

---

## 作者：CYC的幸福生活 (赞：6)

一个标准的板子，涉及到的只有一个叫做线段树的数据结构

## First：线段树是什么？
	
线段树其实就是一棵二叉树，它将一个数列分成小区域，每个节点分别储存其对应的区间左右端点。

 ![](https://img2018.cnblogs.com/i-beta/1765402/202001/1765402-20200118091831141-706623746.png)
    
如图，设数组 a[n] ,图中 [ i,j ] 表示每一个二叉树结点对应的区间。容易发现，根节点对应的是整个区间 [ 0,n-1 ] 。一个结点对应的区间为 [ l,r ] ，当l=r时，它就是一个叶子结点，没有左右儿子；否则它就一定有左右两个儿子，存在mid=( l+r )/2，其左儿子为[ l,mid ]，右儿子对应区间为[ mid+1,r ]。
    
###### 	注意：这里左右儿子的分界一定要清晰、统一。如果这两个区间划分不清楚，就会（~~像我老师那样~~）翻车。
    
可以看出，二叉树高度h的复杂度只有O( logn )级别。
    
#####   另外补充几点：
##### 上面图中数组是[0,n-1]区间的，而下面我的代码区间为[1,n]。
#####    	二进制的位移运算 a * 2 = a << 1 ，表示a在二进制下向左移一位，也就是乘二。这种运算方式会比普通的 * 2 要快

 
## Second：变量清单
//个人觉得写一个清单更有利于对于程序的规划，有计划总比没有强

变量：	线段树选择用结构体存储（t[ N ]），内含对应左右端点（l,r），对应区间的		区间和(sum)，以及后面会提到的懒标记两个(tag , tag_x)。

另外，代码中大量出现左右儿子，于是我写了一个求左右儿子编号的函数。
```cpp
#define N 1000000+50//数据边界
struct tree{
	long long l,r,sum,tag,tag_x;//l,r左右端点，sum为结点对应区间和，tag为加法标记，tag_x为乘法标记 
}t[N];//线段树 
long long a[N];//输入的数列(1~n) 
long long m,n,p,k;//如题意(k是操作种类) 
long long ls(long long rt){return rt<<1;}//左孩子 
long long rs(long long rt){return rt<<1|1;}//右孩子 
```
## Third：线段树操作
### 建树：

我们可以通过递归得到一棵二叉树，声明函数build（rt,l,r）,rt是线段树的结点，l,r 是这个结点对应的左右边界。如果 l=r，就是到达了叶节点，对应区间和t[rt] . sum等于a[i]。如果没有到达叶子结点，就可以通过build(ls(rt),l,mid)和build(rs(rt),mid+1,r)递归分别建立左右结点。最后更新rt的sum(维护区间和)，等于其左孩子的sum和右孩子的sum相加之和。
```cpp
void build(long long rt,long long l,long long r){
	t[rt].tag_x = 1; t[rt].tag = 0;//初始化
	t[rt].l = l,t[rt].r = r;//建立一个结点，更新左右端点标记 
	if(l == r){ //如果到了叶子结点 
		t[rt].sum = a[l] % p; //不要忘记取模操作 
		return;
	}
	long long mid = (l + r) >> 1; //中间节点 
	build(ls(rt),l,mid);
	build(rs(rt),mid+1,r); //如果不是叶子结点，就分别建立左右孩子 
	t[rt].sum = (t[ls(rt)].sum + t[rs(rt)].sum) % p; // 更新sum 
}
```
### 区间修改（划重点）
-  #### 懒标记 lazy_tag 
这个题来讲，我们的加减、乘除都是区间修改操作，如果将线段树拆开在每个叶子结点上面进行修改再维护，最坏情况下我们修改的复杂度就变成了O(mnlogn)，比暴力还慢。

我们引入懒标记lazy_tag。每一个线段树的结点都会有一个加法的tag和乘法的tag_x，如果我们想要修改的区间覆盖了结点的对应区间，我们不对其中的每一个元素进行修改，而是只更新tag、tag_x和sum，这样就巧妙地优化了程序的复杂度。

x长得很像乘号，所以tag_x就是乘法的懒标记（~~特别有道理对吧~~）。

当然，我们的懒标记也需要在访问的时候，对一个结点进行更新，即把父亲节点（rt）的tag下传到儿子节点，同时更新儿子的sum。如果只有加法这个事情就简单了，可是现在我萌有了乘法，那就要考虑一下运算顺序的问题了。因为乘法的运算级别更高，所以先进行计算。 **注意：乘法懒标记不仅要把sum改成sum * tag_x，而且，加法的懒标记tag也要改成tag * tag_x，因为加法tag也是sum的一部分。** 另外，因为牵扯到tag会发生变化，代码里面修改的语句也有一定的顺序（tag_x高于tag，tag高于sum）。这一套操作叫**懒标记下传**。

```cpp
void push_down(long long rt){
    t[ls(rt)].tag_x = (t[ls(rt)].tag_x * t[rt].tag_x) % p;
    t[rs(rt)].tag_x = (t[rs(rt)].tag_x * t[rt].tag_x) % p;//乘法懒标记更新后取模 

    t[ls(rt)].tag = (t[ls(rt)].tag * t[rt].tag_x) % p;
    t[rs(rt)].tag = (t[rs(rt)].tag * t[rt].tag_x) % p;//加法懒标记更新 

    t[ls(rt)].sum = (t[ls(rt)].sum * t[rt].tag_x) % p;
    t[rs(rt)].sum = (t[rs(rt)].sum * t[rt].tag_x) % p;//sum结点对应区间和更新

    t[rt].tag_x = 1; //父亲的标记已经下传，就归零（因为是乘法，所以要调到1） 
		
    t[ls(rt)].tag = (t[ls(rt)].tag + t[rt].tag) % p;
    t[rs(rt)].tag = (t[rs(rt)].tag + t[rt].tag) % p;//加法懒标记更新 
	
    t[ls(rt)].sum += (t[ls(rt)].r - t[ls(rt)].l + 1) * t[rt].tag;
    t[rs(rt)].sum += (t[rs(rt)].r - t[rs(rt)].l + 1) * t[rt].tag;//sum结点对应区间和更新
    
    t[rt].tag = 0;//父亲的标记已经下传，就归零 
}
```
- #### 正题：区间修改
懒标记看明白，区间修改就简单了。我萌从第一个结点开始，判断要进行修改的区间是不是覆盖了这个结点的区间，如果覆盖，直接一套骚操作把这个点的tag、tag_x和sum改掉。如果没有覆盖，就往这个节点的孩子递归，直到找到被覆盖的区间。
这里分加法和乘法的区间修改，但是思路相同。还是需要注意一下tag和tag_x的修改顺序。

加法
```cpp
void change(long long rt,long long x,long long y,long long z){
	if(x <= t[rt].l && y >= t[rt].r){
		t[rt].tag = (t[rt].tag + z) % p;
		t[rt].sum = (t[rt].sum + (t[rt].r - t[rt].l + 1) * z) % p; //如果修改区间覆盖了这个节点的区间，就更新 
		return;
	}
    if(t[rt].tag || t[rt].tag_x != 1) push_down(rt);//访问孩子结点的时候一定先把懒标记 传下去 
	long long mid = (t[rt].l + t[rt].r) >> 1;
	if(x <= mid){
		change(ls(rt),x,y,z);
	}
	if(y > mid){
		change(rs(rt),x,y,z);
	}
	//分别往左右儿子传 
	
	t[rt].sum = (t[ls(rt)].sum + t[rs(rt)].sum) % p; //维护 
}
```
乘法
```cpp
void change_x(long long rt,long long x,long long y,long long z){
	 if(x <= t[rt].l && y >= t[rt].r){
	 	t[rt].tag_x = (t[rt].tag_x * z) % p;
	 	t[rt].sum = (t[rt].sum * z) % p;
	 	t[rt].tag = (t[rt].tag * z) % p;//如果修改区间覆盖了这个节点的区间，就更新 
	 	return;
	 }
	 if(t[rt].tag || t[rt].tag_x != 1) push_down(rt);//访问孩子结点的时候一定先把懒标记 传下去 
	 long long mid = (t[rt].l + t[rt].r) >> 1;
	 if(x <= mid){
	 	change_x(ls(rt),x,y,z);
	 }
	 if(y > mid){
	 	change_x(rs(rt),x,y,z);
	 }
	 //分别往左右儿子传 
	 t[rt].sum = (t[ls(rt)].sum + t[rs(rt)].sum) % p; //维护
}
```

### 区间查询
思路和区间修改相类似，从第一个结点开始 ，如果结点被覆盖，就返回它维护的区间和sum。

```cpp
long long getsum(long long rt,long long x,long long y){
	long long res = 0;
	if(x <= t[rt].l && y >= t[rt].r){
		return t[rt].sum % p;
	}
    if(t[rt].tag || t[rt].tag_x != 1) push_down(rt);
	long long mid = (t[rt].r + t[rt].l) >> 1;
	if(x <= mid){
		res += getsum(ls(rt),x,y);
	}
	if(y > mid){
		res += getsum(rs(rt),x,y);
	}
	return res % p;
}
```
## **讲到这里，线段树就结束啦**（跑回去纠错ing）

来一波AC代码

（注释掉的部分是线段树1的代码，两个题基本上一样的，就写到一块了）
```cpp
#include "bits/stdc++.h"
#define N 1000000+50
using namespace std;

struct tree{
	long long l,r,sum,tag,tag_x;//l,r左右端点，sum为结点对应区间和，tag为加法标记，tag_x为乘法标记 
}t[N];//线段树 
long long a[N];//输入的数列(1~n) 
long long m,n,p = 9223372036854775807,k;//如题意(k是操作种类) 
long long ls(long long rt){return rt<<1;}//左孩子 
long long rs(long long rt){return rt<<1|1;}//右孩子 

void build(long long rt,long long l,long long r){
	t[rt].tag_x = 1; t[rt].tag = 0;//初始化
	t[rt].l = l,t[rt].r = r;//建立一个结点，更新左右端点标记 
	if(l == r){ //如果到了叶子结点 
		t[rt].sum = a[l] % p; //不要忘记取模操作 
		return;
	}
	long long mid = (l + r) >> 1; //中间节点 
	build(ls(rt),l,mid);
	build(rs(rt),mid+1,r); //如果不是叶子结点，就分别建立左右孩子 
	t[rt].sum = (t[ls(rt)].sum + t[rs(rt)].sum) % p; // 更新sum 
}

void push_down(long long rt){
    t[ls(rt)].tag_x = (t[ls(rt)].tag_x * t[rt].tag_x) % p;
    t[rs(rt)].tag_x = (t[rs(rt)].tag_x * t[rt].tag_x) % p;//乘法懒标记更新后取模 

    t[ls(rt)].tag = (t[ls(rt)].tag * t[rt].tag_x) % p;
    t[rs(rt)].tag = (t[rs(rt)].tag * t[rt].tag_x) % p;//加法懒标记更新 

    t[ls(rt)].sum = (t[ls(rt)].sum * t[rt].tag_x) % p;
    t[rs(rt)].sum = (t[rs(rt)].sum * t[rt].tag_x) % p;//sum结点对应区间和更新

    t[rt].tag_x = 1; //父亲的标记已经下传，就归零（因为是乘法，所以要调到1） 
		
    t[ls(rt)].tag = (t[ls(rt)].tag + t[rt].tag) % p;
    t[rs(rt)].tag = (t[rs(rt)].tag + t[rt].tag) % p;//加法懒标记更新 
	
    t[ls(rt)].sum += (t[ls(rt)].r - t[ls(rt)].l + 1) * t[rt].tag;
    t[rs(rt)].sum += (t[rs(rt)].r - t[rs(rt)].l + 1) * t[rt].tag;//sum结点对应区间和更新
    
    t[rt].tag = 0;//父亲的标记已经下传，就归零 
}

void change(long long rt,long long x,long long y,long long z){
	if(x <= t[rt].l && y >= t[rt].r){
		t[rt].tag = (t[rt].tag + z) % p;
		t[rt].sum = (t[rt].sum + (t[rt].r - t[rt].l + 1) * z) % p; //如果修改区间覆盖了这个节点的区间，就更新 
		return;
	}
    if(t[rt].tag || t[rt].tag_x != 1) push_down(rt);//访问孩子结点的时候一定先把懒标记 传下去 
	long long mid = (t[rt].l + t[rt].r) >> 1;
	if(x <= mid){
		change(ls(rt),x,y,z);
	}
	if(y > mid){
		change(rs(rt),x,y,z);
	}
	//分别往左右儿子传 
	
	t[rt].sum = (t[ls(rt)].sum + t[rs(rt)].sum) % p; //维护 
}

void change_x(long long rt,long long x,long long y,long long z){
	 if(x <= t[rt].l && y >= t[rt].r){
	 	t[rt].tag_x = (t[rt].tag_x * z) % p;
	 	t[rt].sum = (t[rt].sum * z) % p;
	 	t[rt].tag = (t[rt].tag * z) % p;//如果修改区间覆盖了这个节点的区间，就更新 
	 	return;
	 }
	 if(t[rt].tag || t[rt].tag_x != 1) push_down(rt);//访问孩子结点的时候一定先把懒标记 传下去 
	 long long mid = (t[rt].l + t[rt].r) >> 1;
	 if(x <= mid){
	 	change_x(ls(rt),x,y,z);
	 }
	 if(y > mid){
	 	change_x(rs(rt),x,y,z);
	 }
	 //分别往左右儿子传 
	 t[rt].sum = (t[ls(rt)].sum + t[rs(rt)].sum) % p; //维护
}

long long getsum(long long rt,long long x,long long y){
	long long res = 0;
	if(x <= t[rt].l && y >= t[rt].r){
		return t[rt].sum % p;
	}
    if(t[rt].tag || t[rt].tag_x != 1) push_down(rt);
	long long mid = (t[rt].r + t[rt].l) >> 1;
	if(x <= mid){
		res += getsum(ls(rt),x,y);
	}
	if(y > mid){
		res += getsum(rs(rt),x,y);
	}
	return res % p;
}

int main(){
	long long i,j,x,y,z;
	scanf("%lld%lld%lld",&n,&m,&p);
//    scanf("%lld%lld",&n,&m); 
	for(i = 1;i <= n; i++){
		 scanf("%lld",&a[i]);
	}
	build(1,1,n);
	for(i = 1;i <= m; i++){
		scanf("%lld",&k);
		
		if(k == 1){
			scanf("%lld%lld%lld",&x,&y,&z);
			change_x(1,x,y,z);
		}else if(k == 2){
			scanf("%lld%lld%lld",&x,&y,&z);
			change(1,x,y,z);
		}else if(k == 3){
			scanf("%lld%lld",&x,&y);
			printf("%lld\n",getsum(1,x,y));
		}

//		if(k == 1){
//			scanf("%lld%lld%lld",&x,&y,&z);
//			change(1,x,y,z);
//		}else if(k == 2){
//			scanf("%lld%lld",&x,&y);
//			printf("%lld\n",getsum(1,x,y));
//		}
		
	}
	return 0;
} 
```


---

## 作者：yizimi远欣 (赞：6)

#### 线段树模板题

## 所以，我偏不用线段树

~~奇了怪了~~

### 主要思路：平衡树——Splay

Splay是可以很好的维护区间的。

我这里主要讲如何用Splay维护区间。

我们知道Splay是严格按照中序遍历的顺序的，用rotate操作并不会改变这种性质，所以我们我们可以考虑一下一棵二叉树的中序遍历的特点。

如果我们把左端点splay到树根，把右端点splay到树根的右儿子位置，我们再做下中序遍历，，，（可以自行脑补）

是不是根的右儿子的左子树的信息就是这段区间的信息？

所以我们用Splay维护区间时我们是提取区间。

完整代码：

#### （福利：其中还有插入节点，删除节点等操作哦QwQ，附带节点垃圾桶，可回收旧结点）

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 100010
#define ld long double
#define fi first
#define se second
#define inf 1 << 30
#define ll long long
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
inline ll read()
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            f = -f;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
vector<int> ljt;
struct tree
{
    int ch[2], sze, fa;
    ll w, sum, col;
    tree(int _sze = 0, int _fa = 0, int _w = 0, int _sum = 0, int _col = 0)
        : sze(_sze), fa(_fa), w(_w), sum(_sum), col(_col) { ch[1] = ch[0] = 0; }
} z[mn];
int n, m, tot, a[mn];
inline int newnode(int v = 0)
{
    int rt;
    if (ljt.empty())
        rt = ++tot;
    else
        rt = ljt.back(), ljt.pop_back();
    z[rt].fa = z[rt].ch[0] = z[rt].ch[1] = 0;
    z[rt].sze = 1;
    z[rt].w = z[rt].sum = v;
    return rt;
}
inline void deletenode(int rt)
{
    z[rt].fa = z[rt].ch[0] = z[rt].ch[1] = z[rt].w = z[rt].sum = 0;
    z[rt].sze = 1;
    ljt.push_back(rt);
}
inline void update(int rt)
{
    z[rt].sum = z[rt].w, z[rt].sze = 1;
    if(z[rt].ch[0])
        z[rt].sum += z[z[rt].ch[0]].sum, z[rt].sze += z[z[rt].ch[0]].sze;
    if(z[rt].ch[1])
        z[rt].sum += z[z[rt].ch[1]].sum, z[rt].sze += z[z[rt].ch[1]].sze;
}
inline void push_col(int rt)
{
    if(z[rt].col)
    {
        z[z[rt].ch[0]].col += z[rt].col;
        z[z[rt].ch[1]].col += z[rt].col;
        z[z[rt].ch[0]].sum += z[z[rt].ch[0]].sze * z[rt].col;
        z[z[rt].ch[1]].sum += z[z[rt].ch[1]].sze * z[rt].col;
        z[z[rt].ch[0]].w += z[rt].col;
        z[z[rt].ch[1]].w += z[rt].col;
        z[rt].col = 0;
    }
}
inline int iden(int rt)
{
    return z[z[rt].fa].ch[0] == rt ? 0 : 1;
}
inline void conn(int x, int y, int son)
{
    z[x].fa = y;
    z[y].ch[son] = x;
}
inline void rotate(int x)//敲好记的rotate函数！
{
    int y = z[x].fa;
    int moot = z[y].fa;
    int yson = iden(x);
    int mootson = iden(y);
    int B = z[x].ch[yson ^ 1];
    conn(B, y, yson), conn(y, x, yson ^ 1), conn(x, moot, mootson);
    update(y), update(x);
}
inline void splay(int x, int &k)//传址要注意
{
    if (x == k)
        return;
    int p = z[k].fa;
    while (z[x].fa != p)
    {
        push_col(x);
        int y = z[x].fa;
        if (z[y].fa != p)
            rotate(iden(y) ^ iden(x) ? x : y);
        rotate(x);
    }
    k = x;
}
inline int findkth(int rt, int k)
{
    while (233)
    {
        push_col(rt);
        if (z[rt].ch[0] && k <= z[z[rt].ch[0]].sze)
            rt = z[rt].ch[0];
        else
        {
            if (z[rt].ch[0])
                k -= z[z[rt].ch[0]].sze;
            if (!--k)
                return rt;
            rt = z[rt].ch[1];
        }
    }
}
inline void insert(int &rt, int p, int v)//传址要注意
{
    int x = findkth(rt, p);
    splay(x, rt);
    int y = findkth(rt, p + 1);
    int ooo = z[rt].ch[1];
    splay(y, ooo);
    z[y].ch[0] = newnode(v);
    z[z[y].ch[0]].fa = y;
    update(z[y].ch[0]), update(y), update(x);
}
inline void erase(int &rt, int p)//传址要注意
{
    int y = findkth(rt, p);
    splay(y, rt);
    int x = findkth(rt, p + 1);
    int ooo = z[rt].ch[1];
    splay(x, ooo);
    int oo = z[x].ch[1];
    z[oo].fa = y;
    z[y].ch[1] = oo;
    deletenode(x);
    update(y);
}
inline int getRange(int &rt, int l, int r)//传址要注意
{
    int x = findkth(rt, l);
    splay(x, rt);
    int y = findkth(rt, r + 2);
    int ooo = z[rt].ch[1];
    splay(y, ooo);
    return z[y].ch[0];
}
inline void modify(int &rt, int l, int r, ll v)//传址要注意
{
    int x = getRange(rt, l, r);
    z[x].col += v;
    z[x].w += v;
    z[x].sum += z[x].sze * v;
    update(z[rt].ch[1]);
    update(rt);
}
inline ll query(int &rt, int l, int r)//传址要注意
{
    int x = getRange(rt, l, r);
    return z[x].sum;
}
inline void build(int rt, int l, int r)
{
    int m = (l + r) >> 1;
    z[rt].w = a[m];
    if (l <= m - 1)
    {
        z[rt].ch[0] = newnode();
        z[z[rt].ch[0]].fa = rt;
        build(z[rt].ch[0], l, m - 1);
    }
    if (m + 1 <= r)
    {
        z[rt].ch[1] = newnode();
        z[z[rt].ch[1]].fa = rt;
        build(z[rt].ch[1], m + 1, r);
    }
    update(rt);
}
inline void debug(int rt)//debug专用，利用中序遍历
{
    //if(!z[rt].ch[0] && !z[rt].ch[1])
    //	return;
    if (rt == 0)
        return;
    debug(z[rt].ch[0]);
    printf("%d %d %d\n", z[rt].w, z[rt].sum, z[rt].sze);
    debug(z[rt].ch[1]);
}
int main()
{
    n = read();
    m = read();
    go(i, 1, n, 1) a[i] = read();
    int rot = ++tot;
    build(rot, 0, n + 1);
    //debug(rot);
    //cout << query(rot, 1, n) << "\n";
    go(i, 1, m, 1)
    {
        int s = read(), x = read(), y = read();
        if (s == 1)
        {
            int v = read();
            modify(rot, x, y, v);
        }
        else
        {
            cout << query(rot, x, y) << "\n";
        }
    }
    return 0;
}


```

#### 本蒟蒻的第一篇Splay的题解，若有不恰当的地方请大家指教

---

## 作者：浅色调 (赞：6)

###线段树的模板题，但是竟然大家都发了线段树的模板，那我就发一份树状数组的题解吧###

（树状数组能做的，线段树一定能做;线段树能做的，树状数组不一定能做。但是各种方法都值得去学习与掌握，建议既写线段树也写一下树状数组的解法）

##首先大家必须得熟悉树状数组的两个基本操作：##

**1、单点修改：**

```cpp
void update(int k,int num)     //k为需要修改第几个数，num为增量
{
    while(k<=n)
    {
        b[k]+=num;
        k+=k&-k;
    }
}
```
**2、区间求和：**

```cpp
int getsum(int k)             //求第1项到第k项的和
{
    int sum=0;
    while(k){sum+=b[k];k-=k&-k;}
    return sum;
}
```
有了以上两个操作，再加上前缀和的知识，于是我们就能用数学公式巧解区间修改和区间查询的问题了。

##思路：##

（很有趣的数学呵呵～）设置b[i]=a[i]-a[i-1]，则有等式：


**a[1]+a[2]+...+a[n]**


**= (b[1]) + (b[1]+b[2]) + ... + (b[1]+b[2]+...+b[n])**

**= n\*b[1] + (n-1)\*b[2] +... +b[n]**

**= n \* (b[1]+b[2]+...+b[n]) - (0\*b[1]+1\*b[2]+...+(n-1)\*b[n])**

所以我们就维护一个数组c[n]，其中c[i] = (i-1)\*b[i],每当修改b的时候，就同步修改一下c，这样复杂度就不会改变那么**原式=n\*sigma(b,n) - sigma(c,n)**//sigma(b,n)表示b数组前n个数的和（时间复杂度为log2n）

实在不懂树状数组的可以去看我的博客：[five20](http://www.cnblogs.com/five20/p/7544592.html)

这里便可以上代码了：

```cpp
#include<bits/stdc++.h>
#define maxn 200005
using namespace std;
#define ll long long
ll  a[maxn],b[maxn],c[maxn],n,m;
inline ll getint()
{
    ll a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')f=1,x=getchar();
    while(x>='0'&&x<='9'){a=a*10+x-'0';x=getchar();}
    return f?-a:a;
}
void update(ll *x,ll k,ll num)
{
    while(k<=n)
    {
        x[k]+=num;
        k+=k&-k;
    }
}
ll read(ll *x,ll k)
{
    ll sum=0;
    while(k){sum+=x[k];k-=k&-k;}
    return sum;
}
int main()
{
    n=getint(),m=getint();
    for(ll i=1;i<=n;i++){a[i]=getint();update(b,i,a[i]-a[i-1]);update(c,i,(i-1)*(a[i]-a[i-1]));}
    while(m--)
    {
        ll x,y,z=getint(),q;
        if(z==2){x=getint();y=getint();printf("%lld\n",y*read(b,y)-read(c,y)-(x-1)*read(b,x-1)+read(c,x-1));}
        else {x=getint();y=getint();q=getint();update(b,x,q);update(b,y+1,-q);update(c,x,q*(x-1));update(c,y+1,-q*y);}
    }
    return 0;
}
```

---

## 作者：远航之曲 (赞：6)

这题还是可以用分块水过去的

1.区间和

我们会得到一个区间[L,R]

假如LR在一个块内，直接暴力加

假如不在一个块内，会分成两种区间

 ![](https://cdn.luogu.com.cn/upload/pic/4622.png) 

一种是橘色的，一种是红色的。

橘色的直接暴力！

```cpp
for (int i=L;i<=r[belong[L]];i++)
        ans+=a[i];
for (int i=l[belong[R]];i<=R;i++)
        ans+=a[i];
```
红色的统计一下块值就可以了

```cpp
for (int i=belong[L]+1;i<belong[R];i++)
        ans+=d[i];
```
2.区间加

对于每个块，加上一个mark，假如要用这个块的话，先把mark加上，再操作。

想学习更多分块姿势可以来[我的blog](http://www.yhzq-blog.cc/分块算法总结/)


    
    
    
    
    
    
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 100010;
int n,m,num,q,belong[maxn],block,l[maxn],r[maxn];
LL a[maxn],mark[maxn],d[maxn],x,com,y,z;
char s[10];
LL inline read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void debug()
{
    for (int i=1;i<=n;i++)
        printf("%lld ",a[i]+mark[belong[i]]);
    puts("");
    for (int i=1;i<=num;i++,puts(""))
        printf("Bolck%lld: l:%lld r:%lld sum:%lld",i,l[i],r[i],d[i]+mark[i]*block);
}
void build()
{
    block=sqrt(n);
    num=n/block;if (n%block) num++;
    for (int i=1;i<=num;i++)
        l[i]=(i-1)*block+1,r[i]=i*block;
    for (int i=1;i<=n;i++)
        belong[i]=(i-1)/block+1;
    for (int i=1;i<=n;i++)
        d[belong[i]]+=a[i];
}
void update(int L,int R,LL x)
{
    if (belong[L]==belong[R])
    {
        for (int i=l[belong[L]];i<=r[belong[R]];i++)
            a[i]+=mark[belong[L]];
        d[belong[L]]+=mark[belong[L]]*block;
        mark[belong[L]]=0;
        for (int i=L;i<=R;i++)
            a[i]+=x;
        d[belong[L]]+=(R-L+1)*x;
        return;
    }
    for (int i=l[belong[L]];i<=r[belong[L]];i++)
        a[i]+=mark[belong[L]];
    d[belong[L]]+=mark[belong[L]]*block;
    mark[belong[L]]=0;
    for (int i=L;i<=r[belong[L]];i++)
        a[i]+=x;
    d[belong[L]]+=(r[belong[L]]-L+1)*x;
    for (int i=l[belong[R]];i<=r[belong[R]];i++)
        a[i]+=mark[belong[R]];
    d[belong[R]]+=mark[belong[R]]*block;
    mark[belong[R]]=0;
    for (int i=l[belong[R]];i<=R;i++)
        a[i]+=x;
    d[belong[R]]+=(R-l[belong[R]]+1)*x;
    for (int i=belong[L]+1;i<belong[R];i++)
        mark[i]+=x;
}
void query(int L,int R)
{
    LL ans=0;
    if (belong[L]==belong[R])
    {
        for (int i=L;i<=R;i++)
            ans+=a[i];
        printf("%lld\n",ans+(R-L+1)*mark[belong[R]]);
        return;
    }
    for (int i=L;i<=r[belong[L]];i++)
        ans+=a[i]+mark[belong[L]];
    for (int i=l[belong[R]];i<=R;i++)
        ans+=a[i]+mark[belong[R]];
    for (int i=belong[L]+1;i<belong[R];i++)
        ans+=d[i]+mark[i]*block;
    printf("%lld\n",ans);
}
main()
{
    n=read(),q=read();
    for (int i=1;i<=n;i++)
        a[i]=read();
    build();
    for (int i=1;i<=q;i++)
    {
        com=read(),x=read(),y=read();
        if (com==2)
            query(x,y);
        else
            z=read(),update(x,y,z);
    }
}
```

---

## 作者：Adove (赞：6)

没有人写**标记永久化**的线段树啊qwq

所谓标记永久化，就是下放标记后**不去pushdown**，在统计的时候经过线段树某节点将该点add标记加入贡献的方法。

具体操作代码中有

上代码↓
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

long long num[1<<18],add[1<<18];
int n,m,p,l,r,x,a[1<<17];

void build(int k,int l,int r){
	if(l==r){
		num[k]=a[l];
		return;
	}int i=k<<1,mid=(l+r)>>1;
	build(i,l,mid);
	build(i|1,mid+1,r);
	num[k]=num[i]+num[i|1];
}

void cadd(int x,int k,int l,int r,int le,int ri){
	if(le<=l&&r<=ri){
		add[k]+=x;
		num[k]+=x*(r-l+1);
		return;
	}int i=k<<1,mid=(l+r)>>1;
	if(le<=mid) cadd(x,i,l,mid,le,ri);
	if(mid<ri) cadd(x,i|1,mid+1,r,le,ri);
	num[k]=num[i]+num[i|1]+add[k]*(r-l+1);
}

long long ans(long long addx,int k,int l,int r,int le,int ri){
	if(le<=l&&r<=ri) return num[k]+addx*(r-l+1);
	int i=k<<1,mid=(l+r)>>1;
	long long sum=0;
	if(le<=mid) sum+=ans(addx+add[k],i,l,mid,le,ri);
	if(mid<ri) sum+=ans(addx+add[k],i|1,mid+1,r,le,ri);
	return sum;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}build(1,1,n);
	while(m--){
		scanf("%d%d%d",&p,&l,&r);
		if(p==1){
			scanf("%d",&x);
			cadd(x,1,1,n,l,r);
		}else{
			printf("%lld\n",ans(0,1,1,n,l,r));
		}
	}
	return 0;
}
```

---

## 作者：Del_Your_Heart (赞：5)


[传送门 洛谷P3372 【模板】线段树1](https://www.luogu.org/problem/P3372)
# 写在前面


#### 线段树作为一种常用的数据结构，在NOI系列竞赛中考的特别多，应用十分广泛。我作为一个刚学线段树的小蒟蒻，我决定写一篇博客来总结该知识点，以更好的掌握和熟练运用该知识点。


------------

# 算法内容

线段树是一种维护**区间信息**的数据结构，它可以维护所有具备**区间可加减性**的问题。洛谷的模板$1$要求一种支持**区间修改**（加减）和**区间询问**的数据结构，而线段树可以**完美**的支持这些操作。相比于~~其实是我不会写（逃~~$treap$来说，线段树**码量小，易实现，调试难度低**，是像我一样**蒟蒻**的人的不二选择。

线段树的一个节点包括几个信息：区间的左右标记、区间的权值和以及懒标记（线段树区间修改的优化）。
像这样：
```cpp
struct node{
	int l,r,w,lz;
}t[4*100005];
```

------------

### 接下来让我简单讲一下线段树的一些基本操作：
#### $ $ $ $ $I$ $ $ $ $ $ $ 建树——建立一棵线段树
$1^o$ 标记左右区间

$2^o$ 判断是否为单个节点

$3^o$ 递归建立左右子树

$4^o$ 累加左右子节点和

**代码实现**
```cpp
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r){
		t[p].w=a[l];
		return;
	}
	int mid=l+r>>1;
	build(2*p,l,mid);
	build(2*p+1,mid+1,r);
	t[p].w=t[2*p].w+t[2*p+1].w;
}
```

------------

#### $ $ $II$ $ $ 懒标记——将修改的内容暂时保存在懒标记中
$1^o$ 左右子节点权值加上左右区间长度乘以父节点懒标记

$2^o$ 将父节点懒标记累加给左右子节点

$3^o$ 父节点懒标记清零

**代码实现**
```cpp
void lazy(int p){
	if(t[p].lz){
		t[2*p].w+=t[p].lz*(t[2*p].r-t[2*p].l+1);
		t[2*p+1].w+=t[p].lz*(t[2*p+1].r-t[2*p+1].l+1);
		t[2*p].lz+=t[p].lz;
		t[2*p+1].lz+=t[p].lz;
		t[p].lz=0;
	}
}
```

------------

#### $III$ 区间修改
一、修改区间包含当前区间

$1^o$ 当前节点权值加上修改数值乘以当前区间长度

$2^o$ 节点懒标记加上修改数值

二、修改区间不包含当前区间

$1^o$ 下传懒标记

$2^o$ 递归修改左右子节点

$3^o$ 修改父节点权值和为左右子节点权值之和

**代码实现**
```cpp
void change(int p,int l,int r,int x){
    if(t[p].l>=l&&t[p].r<=r){
        t[p].w+=x*(t[p].r-t[p].l+1);
        t[p].lz+=x;
        return;
    }
    lazy(p);
    int mid=t[p].r+t[p].l>>1;
    if(l<=mid)
        change(2*p,l,mid,x);
    if(r>=mid+1)
        change(2*p+1,mid+1,r,x);
    t[p].w=t[2*p].w+t[2*p+1].w;
}
```

------------

#### $IV$ $ $ 区间查询

一、查询区间包含当前区间

$1^o$ 返回当前节点权值

二、查询区间不包含当前区间

$1^o$ 下传懒标记

$2^0$ 答案累加左右子树查询结果

**代码实现**
```cpp
int query(int p,int l,int r){
    if(t[p].l>=l&&t[p].r<=r){
        return t[p].w;
    }
    lazy(p);
    int mid=t[p].r+t[p].l>>1,ans=0;
    if(l<=mid)
        ans+=query(2*p,l,mid);
    if(r>=mid+1)
        ans+=query(2*p+1,mid+1,r);
    return ans;
}
```

------------
### 以上就是解决本题所需的四种基本操作，蒟蒻们需要熟练掌握与运用！


------------
# 文章结尾
### 完整代码实现
#### 大部分细节已在上一部分实现，就不在代码中再赘述了。
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,a[100005],op;
struct node{
    int l,r,w,lz;
}t[4*100005];
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}
    while('0'<=ch&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r){
		t[p].w=a[l];
		return;
	}
	int mid=l+r>>1;
	build(2*p,l,mid);
	build(2*p+1,mid+1,r);
	t[p].w=t[2*p].w+t[2*p+1].w;
}
void lazy(int p){
	if(t[p].lz){
		t[2*p].w+=t[p].lz*(t[2*p].r-t[2*p].l+1);
		t[2*p+1].w+=t[p].lz*(t[2*p+1].r-t[2*p+1].l+1);
		t[2*p].lz+=t[p].lz;
		t[2*p+1].lz+=t[p].lz;
		t[p].lz=0;
	}
}
void change(int p,int l,int r,int x){
    if(t[p].l>=l&&t[p].r<=r){
        t[p].w+=x*(t[p].r-t[p].l+1);
        t[p].lz+=x;
        return;
    }
    lazy(p);
    int mid=t[p].r+t[p].l>>1;
    if(l<=mid)
        change(2*p,l,r,x);
    if(r>=mid+1)
        change(2*p+1,l,r,x);
    t[p].w=t[2*p].w+t[2*p+1].w;
}
int query(int p,int l,int r){
    if(t[p].l>=l&&t[p].r<=r){
        return t[p].w;
    }
    lazy(p);
    int mid=t[p].r+t[p].l>>1;
    int ans=0;
    if(l<=mid)
        ans+=query(2*p,l,r);
    if(r>=mid+1)
        ans+=query(2*p+1,l,r);
    return ans;
}
signed main(){
    n=read();m=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
    build(1,1,n);
    while(m--){
        op=read();
        int x,y,z;
        if(op==1){
            x=read();y=read();z=read();
            change(1,x,y,z);
        }
        else{
            x=read(),y=read();
            printf("%lld\n",query(1,x,y));
        }
    }
}
```













---

## 作者：KaguyaH (赞：5)

Changelog: 远古时代已通过的题解的调整，加入了 $\LaTeX$，删了一些无关紧要的东西，采用更形式化的表述，并采用更加常见的一种线段树进行解释。

---

本文主要说一下为什么要开约 $4n$ 空间。以最常见的从 $1$ 开始编号的 $[l, r] \rightarrow [l, m], [m + 1, r]$ 这种写法为例。本文中 $m$ 均为 $\lfloor \frac {l + r} 2 \rfloor$，$k$ 均为整数。

---

设一棵大小为 $n$ 的线段树，高度为 $h(n)$，最大节点编号为 $f(n)$。

$$
h(n)=\begin{cases}
0 & (n = 1), \cr
h(\lceil \frac n 2 \rceil) + 1 & \operatorname{otherwise,}
\end{cases}
$$

易得 $h(n) = \lceil \log_2 n \rceil$。

---

我们考虑常见线段树的节点编码规则。设一个节点 $x$ 的深度为 $d_x$，不难发现，$x$ 二进制最高位的 $1$ 必然表示 $2^{d_x}$（根节点深度为 $0$），下面 $d_x$ 位则表示从根节点依次走左子树（$0$）或右子树（$1$）可达到 $x$。

比如节点 $10$，$1 \rightarrow 2 \rightarrow 5 \rightarrow 10$，二进制为 $(1010)_2$，表示 $10$ 的深度为 $3$，依次走左子树、右子树、左子树到达 $x$。

---

我们要找到被大小为 $n$ 的线段树用到的最大编号，显然应使这个编号 $2$ 进制下的位数最大，易得这个最大位数为 $h(n) + 1$。

我们考虑从根节点走到这个编号最大的节点。假设当前节点编号为 $x$，区间为 $[l, r]$。

若当前区间长度为偶数：则显然走到右子树，即 $[m + 1, r]$。

若当前区间长度为奇数：

> 若左右子树高度相同，则走到右子树，否则走到左子树。
>
> 高度相同，
>
> 即 $h(\frac {r - l + 1 + 1} 2) = h(\frac {r - l + 1 - 1} 2)$，即 $h(\frac {r - l} 2) = h(\frac {r - l} 2 + 1)$，即 $\lceil \log_2 (\frac {r - l} 2) \rceil = \lceil \log_2 (\frac {r - l} 2 + 1) \rceil$，即 $\frac {r - l} 2$ 不为 $2$ 的正整数次幂，即 $r - l$ 不为 $2$ 的正整数次幂，即区间长度不为 $2^k + 1$。
>
> 若 $r - l$ 为 $2$ 的正整数次幂，则易得 $m - l$ 也为 $2$ 的非负整数次幂。也就是说，若一次走了左子树，则以后都要走左子树，直到最后 $r - l = 1$ 时再走一次右子树。

---

不考虑 $n = 1$ 的情况。

易得，$f(n) - 2^{h(n)}$ 必然形如 $(1 \cdots 10 \cdots 01)_2$。

考虑一下 $n$ 的二进制，可得出 $0$ 的数量为 $n$ 二进制下最高的 $1$ 与次高的 $1$ 之间的距离 $d(n)$（若 $n$ 为 $2$ 的整数次幂则 $d(n) = 0$），则前面 $1$ 的数量为 $h(n) - d(n) - 1$。则有

$$\begin{aligned}
f(n) &= 2^{\lceil\log_2 n\rceil} + 2^{d(n) + 1} \cdot (2^{\lceil\log_2 n\rceil - d(n) - 1} - 1) + 1\cr
&= 2^{\lceil\log_2 n\rceil + 1} - 2^{d(n) + 1} + 1\cr
\end{aligned}$$

若 $n = 2^k$，则 $f(n) = 2^{k + 1} - 1 = 2n - 1$。

若 $n = 2^k + r(0 < r < 2^k)$，则 $f(n) = 2^{k + 2} + 1 - 2^{d(n) + 1}$，要使 $\frac {f(n)}n$ 取最大值，则 $f(n)$ 尽量大，$n$ 尽量小，对于确定的 $d(n) = a(0 < a \leqslant k)$，$f(n) = 2^{k + 2} - 2^{a + 1} + 1$，$n = 2^k + 2^{k - a}$，

$$g(a) := \frac{2^{k + 2} - 2^{a + 1} + 1}{2^k + 2^{k - a}},$$
$$\begin{aligned}
&g(a) - g(a - 1) \cr
=& \frac{2^{k + 2} - 2^{a + 1} + 1}{2^k + 2^{k - a}} - \frac{2^{k + 2} - 2^a + 1}{2^k + 2^{k - a + 1}} \cr
=& \frac{(2^{k + 2} - 2^{a + 1} + 1)(2^k + 2^{k - a + 1}) - (2^{k + 2} - 2^a + 1)(2^k + 2^{k - a})}{(2^k + 2^{k - a})(2^k + 2^{k - a + 1})} \cr
=& \frac{2^k(2^{k - a + 2} + 2^{-a} - 2^a - 3)}{(2^k + 2^{k - a})(2^k + 2^{k - a + 1})}, \cr
\end{aligned}$$
$$\begin{aligned}
&g(a) - g(a - 1) > 0 \cr
\iff& 2^{k - a + 2} + 2^{-a} \geqslant 2^a + 3 \cr
\iff& 2^{k - a + 2} \geqslant 2^a + 3 \cr
\iff& k - a + 2 > a \cr
\iff& a < \frac {k + 2} 2 \cr
\iff& a < \lceil \frac k 2 \rceil + 1 \cr
\iff& a \leqslant \lceil \frac k 2 \rceil.
\end{aligned}$$

当 $a$ 取 $\lceil \frac k 2 \rceil$ 时，
$$g(a) = \frac{2^{k + 2} - 2^{\lceil \frac k 2 \rceil + 1} + 1}{2^k + 2^{\lfloor \frac k 2 \rfloor}},$$

而

$$
\lim_{k \rightarrow \infty} \frac{2^{k + 2} - 2^{\lceil \frac k 2 \rceil + 1} + 1}{2^k + 2^{\lfloor \frac k 2 \rfloor}} = 4.
$$

于是需要开四倍空间。

---

## 作者：Delva (赞：5)

线段树的原理没什么可说的，相信你在其他地方一定了解不少。这里主要介绍一些比较好理解的方法

1.addNode()函数：作用：给某个节点更新value（value+=size\*v），并且打上标记（注意是为了它的孩子认识它打的标记，他自己本身已经更新过了）

2.pushUp()函数：作用：根据孩子的信息（本题为'加和'）向上更新父亲的信息

3.pushDown()函数：作用：懒标记下传，将添加操作'懒得向下更新'的这件事'顺便'做了，因为有了addNode()所以就可以直接addNode左儿子，addNode右儿子。


至于线段树的写法，有十多种，这里给出三种写法：

1.指针版线段树

```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    #define LL long long
    struct Node*null;//替代NULL防止RE，详见下面init()
    struct Node{
        Node* ch[2];
        LL v,adds;int l,r,mid;
        Node(int ll,int rr){l=ll,r=rr;ch[0]=ch[1]=null;}
        inline void pushUp(){v=ch[0]->v+ch[1]->v;}
        inline void addNode(LL x){adds+=x,v+=x*(r-l+1);}
        inline void pushDown(){
            if(adds){ch[0]->addNode(adds),ch[1]->addNode(adds);adds=0;}
        }
    }*root;
    int n;
    void build(Node*&k=root){
        k->mid=(k->l+k->r)/2;
        if(k->r==k->l){scanf("%d",&k->v);return;}
        build(k->ch[0]=new Node(k->l,k->mid));
        build(k->ch[1]=new Node(k->mid+1,k->r));
        k->pushUp();
    }
    LL query(int ql,int qr,Node*k=root){
        if(ql>k->r||qr<k->l)return 0;
        if(ql<=k->l&&qr>=k->r)return k->v;
        k->pushDown();
        return query(ql,qr,k->ch[0])+query(ql,qr,k->ch[1]);
    }
    void add(int ql,int qr,LL v,Node*k=root){
        if(ql>k->r||qr<k->l)return;
        if(ql<=k->l&&qr>=k->r){k->addNode(v);return;}//因为有了addNode，什么都很方便
        k->pushDown();
        add(ql,qr,v,k->ch[0]),add(ql,qr,v,k->ch[1]);
        k->pushUp();
    }
    void init(){
        null = new Node(0,0);
        root=null->ch[0]=null->ch[1]=null;
        null->adds=0;root=new Node(1,n);
    }
    int main(){
        int m;scanf("%d%d",&n,&m);
        init();build();
        while(m--){
            int a,b,c,d;scanf("%d%d%d",&a,&b,&c);
            if(a==1)scanf("%d",&d),add(b,c,d);
            else printf("%lld\n",query(b,c));
        }
    }
```
相信这份代码已经够清晰了，一目了然
如果还要维护其他的，同样可以写"~~~Node()"来简化代码


2.pushDown版zkw线段树

线段树自下而上堆式建立、修改、查询，技巧和上面差不多，主要就是思路不同

这里在代码上多些注释


```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    #define LL long long
    const int maxn = 1e5+5;
    int n,m,M;
    LL tree[maxn<<2],adds[maxn<<2],size[maxn<<2];
    inline void pushUp(int x){
        tree[x]=tree[x<<1]+tree[x<<1|1];//同上
    }
    void build(){//整棵数是个堆
        for(M=1;M<n+3;M<<=1);//M是从根到底层以前的节点的个数
        for(register int i=1;i<=n;++i)scanf("%d",&tree[i+M]);//输入堆的最底层的数
        for(register int i=M;i<=(M<<1);++i)size[i]=1;//初始化最底层的管理大小
        for(register int i=M-1;i;--i)size[i]=size[i<<1]+size[i<<1|1],pushUp(i);//把管理大小和加和同时向上更新
    }
    inline void addNode(int x,int v){
        adds[x]+=v;tree[x]+=size[x]*v;//同上
    }
    void pushDown(int x){
        if(x^1)pushDown(x>>1);//将标记下传做成一个递归函数，因为查询、修改都是循环，无法递归，所以手动递归
        if(adds[x])addNode(x<<1,adds[x]),addNode(x<<1|1,adds[x]);//同上
        adds[x]=0;
    }
    void add(int l,int r,LL v){//自底而上
        pushDown((l+=M-1)>>1),pushDown((r+=M+1)>>1);//先递归到根节点下传下来
        for(;l^r^1;l>>=1,r>>=1){//一直向上，直到相遇（>>=1表示跳到父亲）
            if(~l&1)addNode(l^1,v);if(r&1)addNode(r^1,v);//模拟一下就明白了
            pushUp(l>>1),pushUp(r>>1);
        }for(l>>=1;l;l>>=1)pushUp(l);//接着没有pushUp完的地方继续
    }
    LL query(int l,int r){LL ans=0;//同上
        pushDown((l+=M-1)>>1),pushDown((r+=M+1)>>1);
        for(;l^r^1;l>>=1,r>>=1){
            if(~l&1)ans+=tree[l^1];if(r&1)ans+=tree[r^1];
        }return ans;
    }
    int main(){
        int m;scanf("%d%d",&n,&m);
        build();
        while(m--){
            int a,b,c,d;scanf("%d%d%d",&a,&b,&c);
            if(b>c)swap(b,c);
            if(a==1)scanf("%d",&d),add(b,c,d);
            else printf("%lld\n",query(b,c));
        }
    }
```
3.平衡树（这里用splay）
有人可能觉得这是没有必要，没有意义的。

但是，用splay实现线段树的功能，仍能帮助练习splay维护区间

下面就不讲解splay了，只说说如何维护'加和'（无父splay）

```cpp
    #include<cstdio>
    #include<iostream>
    #include<queue>
    using namespace std;
    #define LL long long int
    const int inf = 0x7fffffff,maxn = 1e5+5;
    int n;LL A[maxn];
    struct Node *null;
    struct Node{//用区间中所在下标建立splay
        Node* ch[2];
        int v,cnt,siz;LL val,adds;//维护val,adds
        Node(int v){ch[0]=ch[1]=null;this->v=v;cnt=siz=1;val=adds=0;}
        inline int cmp(int x){return x<v?0:(x>v?1:-1);}
        inline void pushUp(){siz=cnt+ch[0]->siz+ch[1]->siz,val=A[v]+ch[0]->val+ch[1]->val;}//注意一下，顺便也要更新val加和
        inline void addNode(LL x){if(this==null)return;val+=siz*x;adds+=x;A[v]+=x;}
        inline void pushDown(){if(adds){ch[0]->addNode(adds),ch[1]->addNode(adds);adds=0;}}
    }*root;
    inline void rotate(Node*&k,int d){//旋转
        Node *nn=k->ch[d^1];k->pushDown(),nn->pushDown();
        k->ch[d^1]=nn->ch[d];nn->ch[d]=k;
        k->pushUp(),nn->pushUp();k=nn;
    }
    inline void splay(int v,Node*&to=root){//递归伸展
        int d1=to->cmp(v);
        if(~d1&&to->ch[d1]!=null){
            int d2=to->ch[d1]->cmp(v);
            if(~d2&&to->ch[d1]->ch[d2]!=null){
                splay(v,to->ch[d1]->ch[d2]);
                if(d1==d2)rotate(to,d1^1);else rotate(to->ch[d1],d2^1);
            }rotate(to,d1^1);
        }
    }
    inline void init(){//初始化null
        null=new Node(0);
        root=null->ch[0]=null->ch[1]=null;
        null->siz=null->cnt=null->adds=0;
    }
    void build(){
        Node* temp=new Node(0);
        for(register int i=1;i<=n;++i){
            scanf("%d",&A[i]);
            Node* nd=new Node(i);nd->ch[0]=temp;temp=nd;temp->pushUp();
        }root=temp;root->ch[1]=new Node(n+1);
    }
    void addInvl(int l, int r, LL v){//线段树：区间加
        splay(l-1);splay(r+1,root->ch[1]);//把l前驱伸展到根节点，把r后继伸展到根结点的右儿子，那么区间就在根结点的右儿子的左儿子
        root->ch[1]->ch[0]->addNode(v);
        root->ch[1]->pushUp();
        root->pushUp();
    }
    LL query(int l,int r){//线段树：区间查询
        splay(l-1);splay(r+1,root->ch[1]);//同理
        return root->ch[1]->ch[0]->val;
    }
    int main(){init();//先初始化null
        int m;scanf("%d%d",&n,&m);
        build();
            while(m--){
            int a,b,c,d;scanf("%d%d%d",&a,&b,&c);
            if(a==1){scanf("%d",&d);addInvl(b,c,d);}
            else printf("%lld\n",query(b,c));
        }
    }

```

---

## 作者：2018李泽明 (赞：4)

### 前言

------------

#### 之前打过一次线段树，但是今天查漏补缺时一看我那一丝注释都没有的线段树模板，我惊奇的发现我竟然看不懂我自己写的代码……于是我就详细的打上了注释。让我半年后一看也能明白我打的是什么……


------------

这是[P3372 【模板】线段树 1](https://www.luogu.org/problemnew/show/P3372)（一道模板题）的题解。~~我肯定是疯掉了，写这么多题解的题的题解~~。


这只是一道线段树的模板题。题意没有什么好讲的，只是代码实现和过程理解。

代码里有很多注释，打了我半天呢！

## Code

```cpp
#include<cstdio>
using namespace std;
long long n,m,sign,x,y,k,d[1000010];
struct node
{
    long long val,l,r,tag;
}tree[1000010];
void build(long long point,long long l,long long r)
{//point表示当前查到的点，l和r表示当前建到的区间 
    tree[point].tag=0;//清空当前查到的点表示的区间的懒标记 
    if(l==r)//如果当前点表示的区间的左端点和右端点相等，说明当前点没有左右儿子 
    {//那它肯定就是叶节点啦 
    	tree[point].val=d[l];//直接赋值 
        return;//没有儿子可以为它贡献，那就到它为它父亲贡献了 
    }//能运行到这里说明当前节点是父亲节点 
    long long mid;//取一个当前区间的中间值 
    mid=(l+r)/2;//把它自己的区间分成两半，一半（l—mid）给左儿子，另一半（mid+1—r）给右儿子 
    build(point*2,l,mid);//建以左儿子为根节点的树 
    build(point*2+1,mid+1,r);//建以右儿子为root的树 
    tree[point].val=tree[point*2].val+tree[point*2+1].val;//当前点的贡献等于它左儿子的贡献加它右儿子的贡献 
    return ;//建完当前节点，回溯 
}
void push_down(long long point,long long l,long long r)
{//point表示要释放懒标记的点，l和r表示point所代表的区间 
    long long mid;
    mid=(l+r)/2;
    tree[point*2].tag+=tree[point].tag;//它左儿子要接住它释放出来的懒标记，方便左儿子自己释放给左儿子的儿子（有点晕不？） 
    tree[point*2].val+=tree[point].tag*(mid-l+1);//左儿子的权值要加上（不是等于）左儿子代表的区间内的点的数量的懒标记，因为它自己的权值等于它儿子的权值
    tree[point*2+1].tag+=tree[point].tag;//既然它的儿子都要加上自己的权值，那不就等于它加上它儿子的数量的懒标记吗？ 
    tree[point*2+1].val+=tree[point].tag*(r-mid);//这句和上一句没什么不同，只是对右儿子的释放懒标记操作 
    tree[point].tag=0;//当前节点的懒标记释放完毕（目的就是传给它的两个儿子），所以懒标记清0 
}
void update(long long nowl,long long nowr,long long l,long long r,long long point,long long num)
{//nowl和nowr分别表示当前查询到的区间的左端点和右端点，l和r表示要修改的区间的左端点和右端点，point表示当前查询到的点，num表示要在目标区间加上的数 
    if(l<=nowl && r>=nowr)//如果当前区间的左端点比目标区间的左端点要右（建议画图理解一下）
    {//而且（注意"而且"）右端点比目标区间的右端点要左，说明当前区间被目标区间完全覆盖了（建议画图理解一下）
        tree[point].val+=num*(nowr-nowl+1);//当前的点的权值要加上区间内的点的数量（nowr-nowl+1）的num 
        tree[point].tag+=num;//当前点的懒标记要加上num（表示当前点表示的区间的每一个数都要加上懒标记（也就是num）） 
        return ;//回到上一层 
    }
    push_down(point,nowl,nowr);//能运行到这里说明当前区间没有被目标区间完全覆盖，那就释放当前的懒标记 
    long long mid=(nowl+nowr)/2;//把当前区间劈成两半 
    if(l<=mid)//如果目标区间在当前区间的一半的左边时 
        update(nowl,mid,l,r,point*2,num);//就去查找左儿子（目的是找到并修改目标区间） 
    if(r>mid)//对右儿子操作，步骤相同 
        update(mid+1,nowr,l,r,point*2+1,num);
    tree[point].val=tree[point*2].val+tree[point*2+1].val;//维护修改后的点权 
    return ;
}
long long query(long long nowl,long long nowr,long long l,long long r,long long point)
{//nowl和nowr分别表示当前查询到的区间的左端点和右端点，l和r表示要修改的区间的左端点和右端点，point表示当前查询到的点
    long long sum=0;//区间和 
    if(nowl>r || nowr<l) //如果当前区间的左端点在目标区间的右端点的右边或者当前区间的右端点在目标区间的左端点的左边时 
		return 0;//说明当前区间和目标区间没有一点重合的地方，当前区间没有我要查询的东西，返回0 
    if(l<=nowl && r>=nowr)//如果当前区间的左端点比目标区间的左端点要右而且（注意"而且"）右端点比目标区间的右端点要左
        return tree[point].val;//说明当前区间被目标区间完全覆盖了，直接返回当前节点的权值（代表这个区间的点的总权值） 
    long long mid=(nowl+nowr)/2;//能运行到这里说明当前区间和目标区间有重合的地方 
    push_down(point,nowl,nowr);//先释放，再查询 
    if(l<=mid)//如果目标区间在当前区间的一半的左边时，区间和加上查询左边区间中目标区间的和
        sum+=query(nowl,mid,l,r,point*2);//不用担心会加到目标区间以外的数，因为如果不是目标区间会返回0
    if(r>mid)//相同操作，查询右边 
        sum+=query(mid+1,nowr,l,r,point*2+1);//加上右边目标区间的权值 
    return sum;//回溯区间和 
}
int main()
{
    scanf("%lld %lld",&n,&m);
    for(long long i=1;i<=n;i++)
    	scanf("%lld",&d[i]);
    build(1,1,n);//建树 
    for(long long i=1;i<=m;i++)
    {
        scanf("%lld",&sign);
        if(sign==1)
        {
            scanf("%lld %lld %lld",&x,&y,&k);
            update(1,n,x,y,1,k);//区间修改 
        }
        else
        {
            scanf("%lld %lld",&x,&y);
            printf("%lld\n",query(1,n,x,y,1));//区间查询 
        }
    }
    return 0;
}
```


---

## 作者：SammyChu (赞：4)

其实呢，我看这道题的题解都已经讲的很详细了。但是，我还是要来说说我的一个小发现。所以，严格来说，这个其实不算是一篇题解，但是它和线段树有关，因此我就把它放在这里了，也希望审核能通过。

关于线段树，我发现之前的线段树的题解几乎所有写法都是一种（具体下面会谈到）；但是我学习的线段树却是另外一种写法。因此，在学习这个东西的时候，为了理解这个差别，我困惑了很久，一直写不来线段树的区间修改。翻了半天的题解，也没有找到关于这个问题相关的信息。于是，我就发一篇题解来帮助和我一样不幸的人。

特别说明一下，这里说的写法是指线段树的不同实现方式，并不是什么比较清奇的新思路。

关于线段树的前置知识，我这里也不再赘述。之前我也提到过，我要说的是两种不同的写法。这两种写法在建树$(build)$的写法几乎一模一样，就不再管它；不同点在于区间修改以及区间的访问。这里以区间的修改为例，细说这两种写法。

首先来看看代码：

1. 常见写法：
```cpp
void change(int x,int y,int z,int id)
{
    int ls=tr[id].l,rs=tr[id].r;
    if(ls>=x&&rs<=y)
    {
        tr[id].lazy+=z;
        tr[id].sum+=z*len(id);
        return;
    }
    down(id);
    int mid=(ls+rs)>>1;
    if(x<=mid)
        change(x,y,z,ls(id));
    if(y>mid)
        change(x,y,z,rs(id));
    tr[id].sum=tr[ls(id)].sum+tr[rs(id)].sum;		
} 
```

2. 少见写法
```cpp
void change(int x,int y,int z,int id)
{
    if(tr[id].l==x&&tr[id].r==y)
    {
        tr[id].lazy+=z;
        tr[id].sum+=z*(y-x+1);
        return;
    }
    down(id);
    int mid=(tr[id].l+tr[id].r)>>1;
    if(y<=mid)
    {
        change(x,y,z,ls(id));
        upon(id);
        return;
    }
    if(x>mid)
    {
        change(x,y,z,rs(id));
        upon(id);
        return;
    }
    change(x,mid,z,ls(id));
    change(mid+1,y,z,rs(id));
    upon(id);
}
```
当然，从这里的码量就可以明显的看出为什么上面那种写法更加常见了。

不过，对于知道任意一种写法的同学来说，如果他们不知道另外一种写法，那么当他们在看另一种写法的时候，会很疑惑：这怎么可能是对的？~~（事实上，当我再看第一种写法的时候就是这种想法）~~

别人还真是对的。我们首先从看起来最不同的地方说起。
```cpp
	//少见写法 
    if(tr[id].l==x&&tr[id].r==y)
    //常见写法 
    int ls=tr[id].l,rs=tr[id].r;
    if(ls>=x&&rs<=y)	 
```
看到了吗？一种是当要修改的区间$(x,y)$包含了当前$id$所管理的区间$(l,r)$就操作；另一种则是当$(x,y)$和$(l,r)$是同一个区间时才操作。再看看后面的各种$if$语句，就会发现：常见写法的$if$里是没有$return$语句的，但是另一种写法里几乎每个$if$里都有$return$语句。然后，我就意识到，这两个函数在实现过程中就有差别了。少见写法是要**保证$(x,y)$是$(l,r)$的子集**的，但是常见写法则不用。然后，进一步的，这两个函数的参数的含义其实就不一样了，只不过看起来是一样的。常见写法的函数的意义是指，在区间$(x,y)$**在$(l,r)$的部分**增加一个值$z$，少见写法则是指**在$(l,r)$的范围内寻找到区间$(x,y)$，并对区间增加一个值$z$。**由此可见，虽然两种写法的结果是一样的，那就是都能实现把区间划分到线段树上的区间内并打上懒标记，但是从根本上来讲，两者的思想过程是不同的。

不过，相信大家也发现了，显然常见写法的代码复杂度要比少见写法高得多；不过我个人认为，少见写法的思想要更好理解一些。因此，先学习少见写法的思路，再去学习常见写法的模板，我个人认为是比较好的。

最后，既然是题解，那我就把两种写法的代码都写在下面吧。
```cpp
//常见写法
#include<bits/stdc++.h>
#define LL long long
#define ls(id) id<<1
#define rs(id) id<<1|1//偷懒
using namespace std;
inline void read(int &x)//读入优化
{
    bool w=x=0;
    char ch=0;
    while(!isdigit(ch))
    {
        w|=(ch=='-');
        ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<3)+(x<<1)+(ch^'0');
        ch=getchar();
    }
    x=w?-x:x;
}
const int N=1E5;
struct sgtr
{
    int l,r;
    LL lazy,sum;
}tr[N<<2]; //线段树
int n,m,num[N+1];
int len(int id)//返回id代表的区间长度
{
    return tr[id].r-tr[id].l+1;
}
void build(int x,int y,int id)//建树
{
    tr[id].l=x;
    tr[id].r=y;
    if(x==y)
    {
        tr[id].sum=num[x];
        return;
    }
    int mid=(x+y)>>1;
    build(x,mid,ls(id));
    build(mid+1,y,rs(id));
    tr[id].sum=tr[ls(id)].sum+tr[rs(id)].sum;
}
void down(int id)//标记下传
{
    if(!tr[id].lazy)
        return;
    tr[ls(id)].lazy+=tr[id].lazy;
    tr[rs(id)].lazy+=tr[id].lazy;		
    tr[ls(id)].sum+=tr[id].lazy*len(ls(id));
    tr[rs(id)].sum+=tr[id].lazy*len(rs(id));
    tr[id].lazy=0;
}
void change(int x,int y,int z,int id)//区间修改
{
    int ls=tr[id].l,rs=tr[id].r;
    if(ls>=x&&rs<=y)
    {
        tr[id].lazy+=z;
        tr[id].sum+=z*len(id);
        return;
    }
    down(id);
    int mid=(ls+rs)>>1;
    if(x<=mid)
        change(x,y,z,ls(id));
    if(y>mid)
        change(x,y,z,rs(id));
    tr[id].sum=tr[ls(id)].sum+tr[rs(id)].sum;//push_up		
} 
LL addup(int x,int y,int id)//求和
{
    int ls=tr[id].l,rs=tr[id].r;
    if(ls>=x&&rs<=y)
        return tr[id].sum;
    down(id);
    int mid=(ls+rs)>>1;
    LL ans=0;
    if(mid>=x)
        ans+=addup(x,y,ls(id));
    if(mid<y)
        ans+=addup(x,y,rs(id));
    return ans;		
}
int main()
{
    read(n);
    read(m);
    for(int i=1;i<=n;i++)
        read(num[i]);
    build(1,n,1);
    for(int i=1;i<=m;i++)
    {
        int k,a,b,t;
        read(k);
        read(a);
        read(b);
        if(k==1)
        {
            read(t);
            change(a,b,t,1);
        }
        else
            printf("%lld\n",addup(a,b,1));
    }	
    return 0;
}
```
注意，下面的写法的代码长度是比上面大的多的（$20$行$^{+}$）
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
template<class name>//任意类型的模板
inline void read(name &x)//读入优化+模板
{
    bool w=x=0;
    char ch=0;
    while(!isdigit(ch))
    {
        w|=(ch=='-');
        ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<3)+(x<<1)+(ch^'0');
        ch=getchar();
    }
    x=w?-x:x;
}
const int N=1E5;
struct sgtr
{
    int l,r;
    LL lazy,sum;
}tr[N<<2|1];//线段树
int n,m;
LL num[N+1]; 
int ls(int x)//另外一种偷懒办法
{
    return x<<1;
} 
int rs(int x)
{
    return x<<1|1;
}
void build(int x,int y,int id)//建树
{
    tr[id].l=x;
    tr[id].r=y;
    if(x==y)
    {
        tr[id].sum=num[x];
        return;
    }
    int mid=(x+y)>>1;
    build(x,mid,ls(id));
    build(mid+1,y,rs(id));
    tr[id].sum=tr[ls(id)].sum+tr[rs(id)].sum;
}
void down(int id)//标记下传
{
    if(!tr[id].lazy)
        return; 
    tr[ls(id)].lazy+=tr[id].lazy;
    tr[rs(id)].lazy+=tr[id].lazy;
    tr[ls(id)].sum+=(tr[ls(id)].r-tr[ls(id)].l+1)*tr[id].lazy;  
    tr[rs(id)].sum+=(tr[rs(id)].r-tr[rs(id)].l+1)*tr[id].lazy;
    tr[id].lazy=0;
}
void upon(int id)//push_up
{
    tr[id].sum=tr[ls(id)].sum+tr[rs(id)].sum;
}
void change(int x,int y,int z,int id)//区间修改
{
    if(tr[id].l==x&&tr[id].r==y)
    {
        tr[id].lazy+=z;
        tr[id].sum+=z*(y-x+1);
        return;
    }
    down(id);
    int mid=(tr[id].l+tr[id].r)>>1;
    if(y<=mid)
    {
        change(x,y,z,ls(id));
        upon(id);
        return;
    }
    if(x>mid)
    {
        change(x,y,z,rs(id));
        upon(id);
        return;
    }
    change(x,mid,z,ls(id));//保证所修改的区间在id的管辖范围之内
    change(mid+1,y,z,rs(id));
    upon(id);
}
LL addup(int x,int y,int id)//求和
{
    if(tr[id].l==x&&tr[id].r==y)
        return tr[id].sum;
    down(id);
    int mid=(tr[id].l+tr[id].r)>>1;
    if(y<=mid)
        return addup(x,y,ls(id));
    if(x>mid)
        return addup(x,y,rs(id));
    return  addup(x,mid,ls(id))+addup(mid+1,y,rs(id));
}
int main()
{
    read(n);
    read(m);
    for(int i=1;i<=n;i++)
        read(num[i]);
    build(1,n,1);
    for(int i=1;i<=m;i++)
    {
        int k;
        read(k);
        if(k==1)
        {
            int a,b,c;
            read(a);
            read(b);
            read(c);
            change(a,b,c,1); 
        }
        else
        {
            int a,b;
            read(a);
            read(b);
            LL ans=addup(a,b,1);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```


---

## 作者：KesdiaelKen (赞：4)

~~这不是平衡树模板题吗~~

平衡树是一个极其万能的数据结构，不仅可以动态插入与删除节点，还可以进行区间操作，以及解决高级图论问题（$LCT$）等。

本题可使用支持区间操作的一种平衡树：$FHQ\space Treap$来解决。还不会$FHQ\space Treap$的同学可以看一看[这篇博客](https://www.cnblogs.com/Judge/p/9506980.html)，个人觉得讲的最清楚。本题的大部分思想均可参考[【模板】文艺平衡树（Splay）](https://www.luogu.org/problem/P3391)。

$FHQ\space Treap$中的$split$操作可以将**一颗**完整的平衡树以某个值为边界分成**两颗**平衡树，而$merge$操作则可以将**两颗**有明确顺序的平衡树（以某一值为分界，一颗平衡树所有节点的值均小于等于此值，而另一颗平衡树所有节点的值均大于此值）合并成**一颗**平衡树。

基于以上两种操作，我们考虑如何对一个序列进行区间加和区间求值。

我们需要将待操作区间独立出来。用平衡树维护序列各数之间的位置关系，整个平衡树覆盖区间$[1,n]$。假设待操作区间为$[l,r]$，我们先将平衡树$split$成$[1,r],[r+1,n]$两颗树，然后再将$[1,r]$分成$[1,l-1],[l,r]$两棵树。于是，$[l,r]$区间就被独立出来了。

先考虑询问操作。我们在平衡树每个节点上多维护一个$sum$信息，表示包含它在内的整颗子树的节点值之和（在$update$的时候注意$sum$也要更新）。由于$[l,r]$已经被独立，我们只需要输出这段平衡树根的$sum$即可。

然后是修改操作。如果暴力更新，我们需要更新$[l,r]$整颗平衡树的所有节点的值，显然不可能。回想起线段树的操作，再结合文艺平衡树的方法，我们考虑在$[l,r]$的根上面打上标记（$lazy\space tag$）。在需要访问$[l,r]$的子节点时，只需将根的标记推导左右儿子上，同时更新左右儿子的值即可。

最后记得将分开的几棵树再$merge$起来。

代码如下：

```
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
#include<string>
#include<vector>
using namespace std;
int ch[200000][2],rnd[200000];
long long val[200000],sum[200000],tag[200000],sz[200000];
int SJ=347,CS=233,JS=59,MOD=6662333;
int root=0,cnt=0;
int sj()
{
	SJ=(SJ*CS+JS)%MOD;
	return SJ;
}
void update(int node)
{
	sz[node]=sz[ch[node][0]]+sz[ch[node][1]]+1;
	sum[node]=sum[ch[node][0]]+sum[ch[node][1]]+val[node];
}
int newnode(long long a)
{
	sz[++cnt]=1;
	rnd[cnt]=sj();
	val[cnt]=sum[cnt]=a;
	return cnt;
}
void pushdown(int node)
{
	tag[ch[node][0]]+=tag[node];
	tag[ch[node][1]]+=tag[node];
	val[ch[node][0]]+=tag[node];
	val[ch[node][1]]+=tag[node];
	sum[ch[node][0]]+=sz[ch[node][0]]*tag[node];
	sum[ch[node][1]]+=sz[ch[node][1]]*tag[node];
	tag[node]=0;
}
int merg(int x,int y)
{
	if(!x||!y)return x+y;
	pushdown(x);pushdown(y);
	if(rnd[x]<rnd[y]){ch[x][1]=merg(ch[x][1],y);update(x);return x;}
	else{ch[y][0]=merg(x,ch[y][0]);update(y);return y;}
}
void split(int node,int k,int&x,int&y)
{
	if(!node){x=y=0;return;}
	pushdown(node);
	if(k>=sz[ch[node][0]]+1){x=node;split(ch[node][1],k-(sz[ch[node][0]]+1),ch[node][1],y);}
	else{y=node;split(ch[node][0],k,x,ch[node][0]);}
	update(node);
}
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	long long a;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a);
		root=merg(root,newnode(a));
	}
	int op,b,c,x,y,z;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&op,&b,&c);
		if(op==1)
		{
			scanf("%lld",&a);
			split(root,c,y,z);split(y,b-1,x,y);
			tag[y]+=a;sum[y]+=sz[y]*a;val[y]+=a;
			root=merg(merg(x,y),z);
		}
		else
		{
			split(root,c,y,z);split(y,b-1,x,y);
			printf("%lld\n",sum[y]);
			root=merg(merg(x,y),z);
		}
	}
	return 0;
}
```


---

## 作者：2015wanghongyu (赞：4)

###关于树状数组区间查询和区间修改

作为众多线段树中的一股清（hong）流（shui），默默地让线段树使用者+1......

其实就像博客里说的，树状数组在区间求和问题上有很高的效率，尤其在非常困难的比赛中（数据量大，对时间限制很严格的比赛）能发挥非常大的作用，其各种复杂度都要比线段树低很多，而且其代码简洁优美。

我是深受周围人的影响，因为看见无数敲线段树的童鞋因为几个小问题调试了一整天。。。

```cpp
<http://blog.csdn.net/tlonline/article/details/47010665>
#include<iostream>
#include<cstdio>
#define maxn 200000+5
#define ll long long
using namespace std;
ll m,n,k,a[maxn],c1[maxn],c2[maxn];
ll lowbit(ll x)
{
    return x&(-x);
}
void add(ll *q,ll x,ll val)
{
    for(ll i=x;i<=n;i+=lowbit(i)) q[i]+=val;
}
ll getsum(ll *q,ll x)
{
    ll ans=0;
    for(ll i=x;i>=1;i-=lowbit(i)) ans+=q[i];
    return ans;
}
ll sum(ll l,ll r)
{
    ll sum1=(l-1)*getsum(c1,l-1)-getsum(c2,l-1);
    ll sum2=r*getsum(c1,r)-getsum(c2,r);
    return sum2-sum1;
}
int main()
{
    cin>>n>>m;
    for(ll i=1;i<=n;++i)
    {
        cin>>a[i];
        add(c1,i,a[i]-a[i-1]);
        add(c2,i,(i-1)*(a[i]-a[i-1]));
    }
    for(ll i=1,l,r,v;i<=m;++i)
    {
        cin>>k;
        if(k==1)
        {
            cin>>l>>r>>v;
            add(c1,l,v);add(c1,r+1,-v);
            add(c2,l,v*(l-1));add(c2,r+1,-v*r);
        }
        else if(k==2)
        {
            cin>>l>>r;
            cout<<sum(l,r)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Mys_C_K (赞：4)

楼下没有c/c++的树状数组来补一个，这个区间修改+区间查询的树状数组还是在日照跟一个大神学的……

还是差分，把a（原始数据）变成b（bi=ai-a(i-1)），然后在弄两个数组c和r（因为最终答案的公式里有一二次项，所以用两个保存），统计一下贡献手算即可。公式太麻烦，蒟蒻表示不会编辑

貌似是截至目前（2016-10-21）用时最少的rank1……（虽然用了读优）

丑陋的代码

```cpp
#include<iostream>
#include<cstdio>
#define lowbit(x) ((x)&(-(x)))
using namespace std;
long long c[100010],r[100010],m,n;
long long get_sum_c(int x)
{
    long long sum=0;
    for(;x>=1;x-=lowbit(x)) sum+=c[x];
    return sum;
}
long long get_sum_r(int x)
{
    long long sum=0;
    for(;x>=1;x-=lowbit(x)) sum+=r[x];
    return sum;
}
long long get_num()
{
    long long num=0;
    char ch;
    bool flag=false;
    while((ch=getchar())==' '||ch=='\n'||ch=='\r');
    if(ch=='-') flag=true;
    else num=ch-'0';
    while(isdigit(ch=getchar()))
        num=num*10+ch-'0';
    return (flag?-1:1)*num;
}
int main()
{
    long long an,an_1,bn;
    n=get_num();m=get_num();
    an=an_1=0;
    for(int i=1;i<=n;i++)
    {
        an=get_num();
        c[i]=an-an_1;
        an_1=an;
        r[i]=c[i]*i;
        c[i]+=get_sum_c(i-1)-get_sum_c(i-lowbit(i));
        r[i]+=get_sum_r(i-1)-get_sum_r(i-lowbit(i));
    }
    for(int i=1;i<=m;i++)
    {
        int opt;opt=get_num();
        if(opt==1)
        {
            int s,t;long long x;
            s=get_num();
            t=get_num();
            x=get_num();
            for(int i=s;i<=n;i+=lowbit(i)) c[i]+=x;
            for(int i=t+1;i<=n;i+=lowbit(i)) c[i]-=x;
            for(int i=s;i<=n;i+=lowbit(i)) r[i]+=s*x;
            for(int i=t+1;i<=n;i+=lowbit(i)) r[i]-=(t+1)*x;
        }
        else
        {
            int s,t;
            s=get_num();
            t=get_num();
            long long ans=(long long)get_sum_c(s)*(t-s+1)-(get_sum_r(t)-get_sum_r(s))+(long long)(get_sum_c(t)-get_sum_c(s))*(t+1);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：Nero_Claudius (赞：4)

这道题可以用珂朵莉树做，但是由于数据比较不随机，而我也没有手写一颗平衡树，所以就被卡掉了，只拿了[70分](https://www.luogu.org/recordnew/show/11480432)。

------------

珂朵莉树是一种基于平衡树的（伪）高效数据结构。

它的核心操作是推平一段区间。

简而言之，就是把之前的零零碎碎的都干掉，用一个美而饱满的大区间取代。

然后我们更新操作和查询操作就暴力遍历一遍，统计一下和就可以了。

------------

### Split操作

```cpp
inline set<node>::iterator split(int pos){
	set<node>::iterator it=s.lower_bound(node(pos));
	if(it!=s.end()&&it->l==pos)return it;
	--it;
	int L=it->l,R=it->r;long long V=it->v;
	s.erase(it),s.insert(node(L,pos-1,V));
	return s.insert(node(pos,R,V)).first;
}
```

split操作就是获得区间的迭代器。

所以我们要先找到pos在哪里（也就是it）。

然后把它拆掉，再合在一起。

在这个过程中我们就可以拿到迭代器。（干什么等会说）

------------

### Update操作

```cpp
inline void update(int l,int r,long long val=1){
	set<node>::iterator itl=split(l),itr=split(r+1);
    for(;itl!=itr;++itl)itl->v+=val;
}
```

现在刚才的split就派上用场了。

我们现在相当于是获得了区间的两端（也是区间）。

然后暴力遍历一下，给每个区间都打一个标记。

------------

### Query操作

```cpp
inline long long query(int l,int r){
	set<node>::iterator itl=split(l),itr=split(r+1);
	long long ans=0;
	for(;itl!=itr;++itl)ans+=(itl->r-itl->l+1)*itl->v;
	return ans;
}
```

收集一下标记加在一起就可以了，思路和update一样。

------------

70分代码如下：

`3741ms 2368kb`

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace StandardIO{

	template<typename T>inline void read(T& x){
		x=0;T f=1;char c=getchar();
		for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
		x*=f;
	}

	template<typename T>inline void write(T x){
		if(x<0)putchar('-'),x*=-1;
		if(x>=10)write(x/10);
		putchar(x%10+'0');
	}

}

using namespace StandardIO;

namespace ChthollyTree{
	
	struct Tree{
		private:
			struct node{
				int l,r;mutable long long v;
				node(int L,int R=-1,long long V=0):l(L),r(R),v(V){}
				bool operator < (const node &o)const{
					return l<o.l;
				} 
			};
			set<node>s;
			
			inline set<node>::iterator split(int pos){
				set<node>::iterator it=s.lower_bound(node(pos));
				if(it!=s.end()&&it->l==pos)return it;
				--it;
				int L=it->l,R=it->r;long long V=it->v;
				s.erase(it),s.insert(node(L,pos-1,V));
				return s.insert(node(pos,R,V)).first;
			}
			
			inline void update(int l,int r,long long val=1){
				set<node>::iterator itl=split(l),itr=split(r+1);
				for(;itl!=itr;++itl)itl->v+=val;
			}
			
			inline long long query(int l,int r){
				set<node>::iterator itl=split(l),itr=split(r+1);
				long long ans=0;
				for(;itl!=itr;++itl)ans+=(itl->r-itl->l+1)*itl->v;
				return ans;
			}
			
		public:
			Tree(){}
			~Tree(){}
			
			inline void Init(int n){
				s.insert(node(1,n));
			}
			
			inline void Update(int l,int r,long long val){
				update(l,r,val);
			}
			
			inline int Query(int l,int r){
				return query(l,r); 
			}
	};
	
}

using namespace ChthollyTree;

namespace Solve{
	
	const int N=100100;
	
	int n,m;
	int sum[N];
	Tree ljz;
	
	inline void solve(){
		read(n),read(m);
		ljz.Init(n);
		for(register int i=1;i<=n;++i){
			int tmp;read(tmp);
			sum[i]=sum[i-1]+tmp;
		} 
		while(m--){
			int op,x,y,z;
			read(op),read(x),read(y);
			if(op==1){
				read(z);
				ljz.Update(x,y,z);
			}else{
				write(ljz.Query(x,y)+sum[y]-sum[x-1]),putchar('\n');
			}
		}
	}

}

using namespace Solve;

int main(){
	solve();
}

```

---

## 作者：qwaszx (赞：4)

为什么不能有一个py题解呢emmmmm

刚学py两个小时过来作死结果居然对了

但是毕竟还是慢，T了3个点

但是代码真心短

表示我在输入上就卡了10分钟emmmm

```python
a=[0]*1000000;tag=[0]*1000000;n=0;m=0;w=[0]*200000;io=[0]*200000;

def build(rot,lt,rt):
	if(lt==rt):
		a[rot]=w[lt];
		return;
	mid=(lt+rt)>>1;
	build(rot<<1,lt,mid);build(rot<<1|1,mid+1,rt);
	a[rot]=a[rot<<1]+a[rot<<1|1];

def pushdown(rot,lt,rt):
	if(tag[rot]):
		t=tag[rot];tag[rot]=0;mid=(lt+rt)>>1;
		a[rot<<1]+=(mid-lt+1)*t;tag[rot<<1]+=t;
		a[rot<<1|1]+=(rt-mid)*t;tag[rot<<1|1]+=t;
	
def update(rot,lt,rt,lq,rq,w):
	if(lt>rq or rt<lq):return;
	if(lt>=lq and rt<=rq):
		a[rot]+=(rt-lt+1)*w;
		tag[rot]+=w;
		return;
	pushdown(rot,lt,rt);
	mid=(lt+rt)>>1;
	update(rot<<1,lt,mid,lq,rq,w);
	update(rot<<1|1,mid+1,rt,lq,rq,w);
	a[rot]=a[rot<<1]+a[rot<<1|1];
	
def query(rot,lt,rt,lq,rq):
	if(lt>rq or rt<lq):return 0;
	if(lt>=lq and rt<=rq):return a[rot];
	pushdown(rot,lt,rt);
	mid=(lt+rt)>>1;
	return query(rot<<1,lt,mid,lq,rq)+query(rot<<1|1,mid+1,rt,lq,rq);
	
n,m=map(int,input().split());
i=0;
for x in input().split():
	i=i+1;
	w[i]=int(x);
build(1,1,n);
for i in range(1,m+1):
	j=0;
	for x in input().split():
		j=j+1;
		io[j]=int(x);
	if(io[1]==1):update(1,1,n,io[2],io[3],io[4]);
	else:print(query(1,1,n,io[2],io[3]));
```

---

## 作者：LittlePrincess (赞：4)

sgt调起来十分苦逼 当年我调了1d 然而最近发现树状数组可以区间修改 就水了一发。。。26行代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define MN 100500
LL c1[MN],c2[MN];LL n,m;
LL lb(LL x){return x&-x;}
void addd(LL pos,LL data)
{
    for(LL i=pos;i<=n;i+=lb(i)) c1[i]+=data,c2[i]+=data*pos;
}
LL gsum(LL pos)
{
    LL ans=0;for(LL i=pos;i;i-=lb(i)) ans+=(pos+1)*c1[i]-c2[i];return ans;
}
int main()
{
    cin>>n>>m;for(LL i=1,_;i<=n;i++) cin>>_,addd(i,_),addd(i+1,-_);
//    for(int i=1;i<=n;i++) cout<<"#"<<gsum(i)-gsum(i-1)<<" ";cout<<endl;
    for(LL i=1,_;i<=m;i++)
    {
        LL x,y,k;
        cin>>_;if(_==1) cin>>x>>y>>k,addd(x,k),addd(y+1,-k);
        if(_==2) cin>>x>>y,cout<<gsum(y)-gsum(x-1)<<endl;
    }
    //system("pause");
}
```

---

## 作者：VCode (赞：3)

写了个个人感觉还可以的指针版线段树板子

注：
- 该板子为指针版区间修改，区间求和线段树

- 所有涉及到的区间均为**左闭右开**区间

- 这里的lazy被打上之后值已经被更新完了，这东西好像有个名字叫前效性还是非后效性还是啥啥啥我也忘了，总之感觉比pushdown再更新好用点

- 直接复制以下代码并**不能AC**，首先题干是long long范围的，我将其改成了int，然后就是去掉了一部分内容，只留下线段树板子

- 你们要是不习惯class可以换成struct，效果差不多

- 我试图模仿谷歌编程规范了，但是可能还是不够到位

- 作者VCode

```cpp
const int Len = 100000;

class Node {
 public:
  Node(int, int);
  void Build();
  void Update(int, int, int);
  int Query(int, int);
 private:
  const int from;
  const int to;
  void PushDown();
  int data;
  int lazy;
  int mid;//这个mid区域完全可以没有，但是为了方便还是加上它比较好
  Node *left;
  Node *right;
};

int data[Len + 1];

Node::Node(int from = 0, int to = 0) : left(NULL), right(NULL), lazy(0),
                               from(from), to(to), data(0) {
  this->mid = this->from + ((this->to - this->from) >> 1);//按照lrj的写法写的求中间值，实际上左闭右开也是按他的来的
}

void Node::Build() {//建树
  if(to - from == 1) {//左闭右开
    this->data = ::data[this->from];//两个冒号是为了与this->data区分，我相信你们知道我在说什么
    return;
  }
  this->left = new Node(this->from, this->mid);
  this->left->Build();//建左子树
  this->right = new Node(this->mid, this->to);
  this->right->Build();//建右子树
  this->data = this->left->data + this->right->data;//此处可更改，使之成为其他线段树
  return;
}

void Node::PushDown() {//区间修改的重点，用于节省不必要的时间
  if(this->lazy) {
    if(this->left != NULL) {
      this->left->lazy += this->lazy;
      this->left->data += this->lazy * (this->left->to - this->left->from);//注意这里的相减，调试的时候忘乘上了结果debug好久
    }
    if(this->right != NULL) {
      this->right->lazy += this->lazy;
      this->right->data += this->lazy * (this->right->to - this->right->from);
    }
    this->lazy = 0;
  }
  return;
}

int Node::Query(int ask_from, int ask_to) {//查询
  if(ask_from == this->from && ask_to == this->to) {//第一个if判是否全等
    return this->data;
  }
  this->PushDown();//第一个if后pushdown一下
  if(ask_to <= this->mid) {//第二个if判是否全左，注意小于等于
    return this->left->Query(ask_from, ask_to);
  }
  if(this->mid <= ask_from) {//第三个if判是否全右，注意小于等于
    return this->right->Query(ask_from, ask_to);
  }
  return this->left->Query(ask_from, this->mid) +
         this->right->Query(this->mid, ask_to);//三个if失败，则左右兼顾
}

void Node::Update(int ask_from, int ask_to, int value) {//区间修改，可以复制区间查询然后进行调整
  if(this->from == ask_from && this->to == ask_to) {//第一个if判是否全等
    this->data += (ask_to - ask_from) * value;
    this->lazy += value;
    return;
  }
  this->data += (ask_to - ask_from) * value;//注意这句话必须加
  if(ask_to <= this->mid) {//第二个if判是否全左
    this->left->Update(ask_from, ask_to, value);
    return;
  }
  if(this->mid <= ask_from) {//第三个if判是否全右
    this->right->Update(ask_from, ask_to, value);
    return;
  }
  this->left->Update(ask_from, this->mid, value);//三个if失败，则左右兼顾
  this->right->Update(this->mid, ask_to, value);
  return;
}
```

---

## 作者：ghj1222 (赞：3)

没人放题解啊...我做第一个

这个线段树我也是刚接触，不方便描述，我能说清楚的已经注释了，~~真是个神奇的数据结构~~

```cpp
#include <iostream>
using namespace std;
#define int long long
struct node
{
    int l,r,sum;
}tree[300001];
int a[100001],f[100001];
int lazy[300001];//懒操作 
void buildTree(int x,int l,int r)
{
    tree[x].l=l;
    tree[x].r=r;
    if(l==r)
    {
        tree[x].sum=a[l];
        return;
    }
    buildTree(x*2,l,(l+r)>>1);
    buildTree(x*2+1,1+((l+r)>>1),r);
    tree[x].sum=tree[x*2].sum+tree[x*2+1].sum;
}
void pushdown(int x)//把第x个节点的懒操作释放，并给他的孩子记录
{
    int mid=(tree[x].l+tree[x].r)/2;
    tree[x*2].sum+=(mid-tree[x].l+1)*lazy[x];
    tree[x*2+1].sum+=(tree[x].r-mid)*lazy[x];
    lazy[x*2]+=lazy[x];
    lazy[x*2+1]+=lazy[x];
    lazy[x]=0;
}
void update(int x,int l,int r,int k)//和for(int i=l;i<=r;i++)a[i]+=k;意思一样，[x是当前搜到的线段树节点] 
{
    if(tree[x].l>=l&&tree[x].r<=r)//如果是完全有关区间 
    {
        tree[x].sum+=(tree[x].r-tree[x].l+1)*k;
        lazy[x]+=k;
        return;
    }
    if(tree[x].l>r||tree[x].r<l)//如果是完全无关区间
        return;
    int mid=(tree[x].r+tree[x].l)/2;
    if(lazy[x])pushdown(x);
    update(x*2,l,r,k);
    update(x*2+1,l,r,k);
    tree[x].sum=tree[x*2].sum+tree[x*2+1].sum;
}
int query(int x,int l,int r)//int ans=0;for(int i=l;i<=r;i++)ans+=a[i];return ans;[x是当前节点编号]
{
    if(tree[x].l>=l&&tree[x].r<=r)//如果是完全有关区间 
        return tree[x].sum;
    if(tree[x].l>r||tree[x].r<l)//如果是完全无关区间
        return 0;
    if(lazy[x])pushdown(x);
    return query(x*2,l,r)+query(x*2+1,l,r);
}
signed main()
{
    int n,m,t,x,y,z;
    cin >> n >> m;
    for(int i=1;i<=n;i++)
        cin >> a[i];
    buildTree(1,1,n);
    for(int i=1;i<=m;i++)
    {
        cin >> t >> x >> y;
        if(t==1){cin >> z;update(1,x,y,z);}
        else cout << query(1,x,y) << endl;
    }
    return 0;
}
```

---

## 作者：pidan (赞：3)

~~无助的蒟蒻在墙角瑟瑟发抖地%败各位巨得无法描述的奆佬~~

## 线段树

![图片来源于网络](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=0622b6a868600c33e474d69a7b253a6a/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09.jpg)

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

使用线段树可以快速的查找某一个区间，时间复杂度为O(logN)。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。

线段树使用了分治思想，利用了区间合并的性质，巧妙地解决了一类区间查找的题目，但代码实现难度较高，因此不被OIer广泛使用。

------------

翻了好久都没有看见一篇标记永久化的题解（话说标记下传那么多题解是怎么过的QAQ~~这是人性的扭曲还是道德的沦丧？~~）

###### _于是就让最弱的蒟蒻来发一篇标记永久化的题解吧！_

### 1.标记永久化的思想:

标记永久化是在询问过程中计算每个遇到的结点对当前询问的影响。为了保证时间复杂度，子节点的影响需要在modify修改时就计算好。

与标记下传类似，我们用add数组来存放一个区间内每个数加的值，并计算加上的数v对sum的影响。在query询问时，直接计算add标记的影响，再询问子节点。

代码如下：

```cpp

void modify(ll k,ll l,ll r,ll x,ll y,ll v){   //修改
	if(l>=x&&r<=y){
		add[k]+=v;
		return;
	}
	sum[k]+=(min(r,y)-max(l,x)+1)*v;   //计算子结点对当前结点的影响
	ll mid=(l+r)/2;
	if(x<=mid){
		modify(k*2,l,mid,x,y,v);
	}
	if(mid<y){
		modify(k*2+1,mid+1,r,x,y,v);
	}
	return;
}
ll query(ll k,ll l,ll r,ll x,ll y){   //询问
	if(l>=x&&r<=y){
		return sum[k]+(r-l+1)*add[k];
	}
	ll mid=(l+r)/2,res=(min(r,y)-max(l,x)+1)*add[k];   //先计算标记影响
	if(x<=mid){
		res+=query(k*2,l,mid,x,y);   //再计算左右区间的贡献
	}
	if(mid<y){
		res+=query(k*2+1,mid+1,r,x,y);
	}
	return res;
}
```

------------

### 2.建树

代码如下：

```cpp
void build(ll k,ll l,ll r){
	if(l==r){
		sum[k]=a[l];
		return;
	}
	ll mid=(l+r)/2;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	sum[k]=sum[k*2]+sum[k*2+1];
	return;
}
```

------------

## 完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[100005];
ll addsum[400005];
ll sum[400005];
void init(){
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	return;
}
void build(ll k,ll l,ll r){
	if(l==r){
		sum[k]=a[l];
		return;
	}
	ll mid=(l+r)/2;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	sum[k]=sum[k*2]+sum[k*2+1];
	return;
}
void modify(ll k,ll l,ll r,ll x,ll y,ll v){
	if(l>=x&&r<=y){
		addsum[k]+=v;
		return;
	}
	sum[k]+=(min(r,y)-max(l,x)+1)*v;
	ll mid=(l+r)/2;
	if(x<=mid){
		modify(k*2,l,mid,x,y,v);
	}
	if(mid<y){
		modify(k*2+1,mid+1,r,x,y,v);
	}
	return;
}
long long query(ll k,ll l,ll r,ll x,ll y){
	if(l>=x&&r<=y){
		return sum[k]+(r-l+1)*addsum[k];
	}
	ll mid=(l+r)/2;
	long long res=(min(r,y)-max(l,x)+1)*addsum[k];
	if(x<=mid){
		res+=query(k*2,l,mid,x,y);
	}
	if(mid<y){
		res+=query(k*2+1,mid+1,r,x,y);
	}
	return res;
}
int main(){
	init()；
	build(1,1,n)；
	for(ll i=1;i<=m;i++){
		ll does,a,b,c；
		scanf(“%lld%lld%lld”,&does,&a,&b)；
		if(does==1){
			scanf(“%lld”,&c)；
			modify(1,1,n,a,b,c)；
		}
		if(does==2){
			printf(“%lld\n”,query(1,1,n,a,b))；
		}
	}
	return 0；
}   //拜拜
```
[blog推销](https://www.luogu.org/blog/pidan12321/)

---

## 作者：jins3599 (赞：3)

## 定义

>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。
对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。


![](https://cdn.luogu.com.cn/upload/pic/58127.png)

## 线段树的作用&可以支持的操作

#### 作用:

	理论上所有符合结合律的东西都可以用线段树维护。
	例如，区间和，区间乘积，区间max/min值……还有很多很奇怪的东西都可以用线段树维护。

#### 操作：

	区间修改查询，单点修改查询。
    
### 我们这里以区间和为例.

    
## 1.建树与维护

由于线段树是一颗完全二叉树,则有下面的性质:

对于每个父亲节点的编号$P$ ,他的两个儿子的编号分别是$2*P$和$2*P+1$。

我们都知道 << 代表的是二进制下左移一位，相当于$*2$.

所以 左儿子 $= P*2 = P<<1;$

由于 $P<<1$ 后最后一位空出，为0，则 $P<<1|1$ 就代表了$P*2 + 1$；

综上,我们对于结点$P$,他的左右儿子在二进制下的表示为：					

$lson(P) = P<<1$;

$rson(P) = P<<1|1$;

用宏和函数都可以.	

```cpp
define lson(x) x<<1
define rson(x) x<<1|1
```

树的存储:

存储的方式有两种

	1.结构体存储。
	2.用数组直接存。

两种存储的方式没有本质的不同，时间复杂度一样，不过我比较推荐大家用结构体.

代码如下:
```cpp
struct _tree{
    int l,r,add,pre;
}tree[maxn << 2];
```

从线段树的图中我们可以看出除叶子外每个节点的信息都是由它的子节点向上合并而来。

因此我们可以得到线段树的维护：

```cpp
inline void pushup(int x){
    tree[x].pre = tree[lson(x)].pre + tree[rson(x)].pre;
}
```

简单的来说，就是把当前结点左右儿子的信息进行合并。

这被我们称为 pushup 操作。

我们在这儿就能看出来，实际上 pushup 是在合并两个子节点的信息，

所以需要信息满足结合律！

### 小结:

（1） 维护父子关系。
		
对于建树，由于二叉树自身的父子节点之间的可传递关系，所以可以	考虑递归建树。在建树的同时维护父子节点关系。
		
由于我们是用自己的儿子来更新自己的信息，因此要在儿子更新之后	再合并成为父亲的信息。
		
对于递归来说，就很显然了，我们需要再回溯的时候用刚才讲的	pushup 操作。

（2）分配结点所涵盖的区间。

还是对于刚开始的那个图,两个儿子的区间加在一起为父亲的区间。

因此我们在建树的时候，对于每个父区间，我们找到他的mid ,左边	部分分配给左儿子，右边部分分配给右儿子.

最后当到达叶子结点的时候，把单个的结点值更新，回溯时向上		pushup,合并区间信息。

代码的具体实现在后面。
        
```cpp
inline void built(ll p,ll l,ll r){
    tree[p].l=l,tree[p].r = r;
    if(l==r){
        tree[p].pre = a[r];
        return;
    }
    ll mid = (l+r) >> 1;
    built(lson(p),l,mid);
    built(rson(p),mid+1,r);
    
    pushup(p);
}
```
几个小细节。

第三行： if(l == r) 的意思是到达了叶子结点。(即包含的区间只有一个点时)

到达叶子结点的时候更新单点，别忘了写return

## 2.区间查询。

#### Q:First ,为啥不先讲单点查询？

#### A:因为单点查询时区间查询的一种特殊情况啦!

经过前面对线段树的理解，相信进行区间查询这种操作对大家已经不是什么问题。

原理就是 如果查到的当前区间被 要查询的区间 “完全包含”,就用ans += 当前区间的值,return;(以维护区间和为例

```cpp
inline ll ask(ll p,ll l,ll r){
    if(l<=tree[p].l && r>=tree[p].r) return tree[p].pre;
    pushdown(p);
    ll mid = (tree[p].l + tree[p].r) >> 1;
    ll sum = 0;
    if(l <= mid) sum += ask(lson(p),l,r);
    if(r > mid)	 sum += ask(rson(p),l,r);
    return sum;
}

```
欸？里面的pushdown是啥捏？

别慌，我们接着就会讲.

## 3.区间修改
这是线段树中的一个难点，也是一个重点。

我们首先考虑不加任何优化的暴力修改。

![](https://cdn.luogu.com.cn/upload/pic/58127.png)

依旧是这个图。

如果我们要修改区间$[1,5]$,暴力修改的话需要$O(9)$的复杂度。

而直接修改只需要$O(5)$的复杂度，如果这样，线段树就没有任何优势了。

所以，我们引入了一个新的东西.

## Lazy tag.

之所以称其“lazy”，是因为原本区间修改需要通过先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达 O(nlogn)  的级别。但当我们引入了懒标记之后，区间更新的期望复杂度就降到了O(logn) 的级别且甚至会更低.

懒标记的思想精髓在于下面这句话(我瞎jier总结的..

#### 每次修改只修改公共祖先。

#### 每次用到该点的时候下放lazytag.

so that ，问题来了，怎么下放lazytag?

与pushup相对应 ， 我们称为pushdown.
	
我们知道 , pushup是合并两个儿子的信息给父亲

相对应的 pushdown 是把 父亲的信息传递给儿子.

传递lazytag的时候，我们要把tag传递给儿子，还要记得修改儿子的值。

我们还是以简单的区间和为例子。

```cpp
inline void pushdown(ll p){
    if(tree[p].add!=0){
        ll tot = tree[p].add;
        tree[lson(p)].pre += tot*(tree[lson(p)].r-tree[lson(p)].l+1);
        tree[rson(p)].pre += tot*(tree[rson(p)].r-tree[(rson(p))].l+1);
        tree[lson(p)].add += tot;
        tree[rson(p)].add += tot;
        tree[p].add = 0; 
    }
}
```

会了lazy_tag，你就可以轻松的进行区间修改操作了…

(线段树的主体基本相同，每道题目的不同之处主要是在于 pushup() 和 
pushdown() 函数的构造。

线段树change 代码如下:

```cpp
inline void change(ll p,ll l,ll r,ll w){
    if(tree[p].l>=l && tree[p].r<=r){
        tree[p].pre += w*(tree[p].r-tree[p].l+1);
        tree[p].add += w;
        return;
    }
    pushdown(p);
    ll mid = (tree[p].l+tree[p].r) >> 1;
    if(l<=mid) change(lson(p),l,r,w);
    if(r>mid) change(rson(p),l,r,w);
    pushup(p);
}
```

整个代码:
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define lson(x) x<<1 
#define rson(x) x<<1|1
typedef long long ll;
const int maxn=100010;
ll a[maxn];
ll n,m,x,o,b,c,d;

struct _tree{
    ll l,r,add,pre;
}tree[maxn*4+5];

inline void pushup(ll x){
    tree[x].pre = tree[lson(x)].pre + tree[rson(x)].pre;
}

inline void built(ll p,ll l,ll r){
    tree[p].l=l,tree[p].r = r;
    if(l==r){
        tree[p].pre = a[r];
        return;
    }
    ll mid = (l+r) >> 1;
    built(lson(p),l,mid);
    built(rson(p),mid+1,r);
    pushup(p);
}

inline void pushdown(ll p){
    if(tree[p].add!=0){
        ll tot = tree[p].add;
        tree[lson(p)].pre += tot*(tree[lson(p)].r-tree[lson(p)].l+1);
        tree[rson(p)].pre += tot*(tree[rson(p)].r-tree[(rson(p))].l+1);
        tree[lson(p)].add += tot;
        tree[rson(p)].add += tot;
        tree[p].add = 0; 
    }
}

inline void change(ll p,ll l,ll r,ll w){
    if(tree[p].l>=l && tree[p].r<=r){
        tree[p].pre += w*(tree[p].r-tree[p].l+1);
        tree[p].add += w;
        return;
    }
    pushdown(p);
    ll mid = (tree[p].l+tree[p].r) >> 1;
    if(l<=mid) change(lson(p),l,r,w);
    if(r>mid) change(rson(p),l,r,w);
    pushup(p);
}

inline ll ask(ll p,ll l,ll r){
    if(l<=tree[p].l && r>=tree[p].r) return tree[p].pre;
    pushdown(p);
    ll mid = (tree[p].l + tree[p].r) >> 1;
    ll sum = 0;
    if(l <= mid) sum += ask(lson(p),l,r);
    if(r > mid)	 sum += ask(rson(p),l,r);
    return sum;
}

int main (){
    scanf("%lld%lld",&n,&m);
    
    for(int i=1;i<=n;++i) 
        scanf("%lld",&a[i]);
        
        built(1,1,n); 
    while(m--){
        scanf("%lld",&o);
        if(o==1){
            scanf("%d%d%d",&b,&c,&d);
            change(1,b,c,d);
        }
        if(o==2){
            scanf("%d%d",&b,&c);
            ll ans = ask(1,b,c);
            printf("%lld\n",ans);
        }
    }
    return 0;
} 
```
希望大家可以提出不足！

---

## 作者：滑稽的小宫 (赞：3)

### 背景：在普及水到一等，提高水到二等的NOIp2018结束后，滑稽的小宫不满足于简单的暴搜（用暴搜骗了至少150分），决定学习更高级的算法
# 线段树（水）


------------

这是一种神奇的数据结构，用蒟蒻语说，就是“树状区间和”，即将一个二分过程表现出来。通过改变大区间的值，来实现短时区间计算
```cpp
如图：
	    		   1 - 8
    			 /       \
 		  1  -  4          5  -  8
  		 /      \        /       \
      1-2      3 - 4      5-6       7-8
    /    \     /   \     /   \     /   \
  1-1   2-2  3-3   4-4  5-5  6-6  7-7  8-8 
```
### 重点是，时间复杂度只有O(logn)！
（蒟蒻开始考虑自己已经多久没有见过logn的算法了）
## 不水了，进入正题


------------

### 众所周知，拿数组存树是有“左右孩子定理”的。
### 因此通过某种~~高大上~~朴素的做法就可以~~轻易~~繁琐地求出左右孩子
先定义
```cpp
#include<cstdio>  
#define left_son(x) (x<<1)//某种神秘方法
#define right_son(x) (x<<1|1)//某种神秘方法2
#define ll long long
```
### ps：为了更好理解我用了很长的函数和数组名，密恐慎入

#### 在线段树中，我们用到三个主要函数：建树、操作、查询，还有一个辅助函数“下推”。
#### 我在这里用的是结构体做法（实际是因为不会动态开点），定义了一个结构体“st”（segment tree的简称），里面存有它的左端点、右端点、当前值和lazy标记。注意，空间范围最好开到n的4倍（前辈的经验）。

### 首先是建树操作，可以看到，我们能利用递归建树，每次二分就行了，事实上，线段树就是还原了一个二分的过程
### 二分代码：
```
//毫无作用的二分
void div（int l,int r）{
	if(l==r)return;
    int mid=(l+r)/2;
    div(l,mid);
    div(mid+1,r);
}
```
### 如果想要把它变成建树操作，还需要加上这个位置的节点，以便赋值，这时我们就用那个神秘的找孩子函数实现：
### 拿二分改成建树函数代码：
```
void build(ll x,ll li,ll ri){
	st[x].left_point=li;//定义左孩子
	st[x].right_point=ri;//定义右孩子
	if(li==ri){//若相同，说明已经走到叶子结点
		st[x].sum=a[li];//只有叶子结点被真实赋值
		return;
	}
    //如果没到叶子结点，就继续二分
	ll mid=(li+ri)/2;
	build(left_son(x),li,mid);
	build(right_son(x),mid+1,ri);
    //二分完毕，在调用返回时把中间结点的值算出
	st[x].sum=st[left_son(x)].sum+st[right_son(x)].sum;
}
```
好了，先放出上面的那张图

```cpp
//数字为区间端点下标
	    		   1 - 8
    			 /       \
 		  1  -  4          5  -  8
  		 /     \         /       \
      1-2       3-4       5-6       7-8
    /    \     /   \     /   \     /   \
  1-1   2-2  3-3   4-4  5-5  6-6  7-7  8-8 
```
或者是
```
  |1              -                    16|
  |1      -      8|9         -         16|
  |1  -  4|5  -  8|9   -   12|13   -   16|
  |1-2|3-4|5-6|7-8|9-10|11-12|13-14|15-16|
  |1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|
```

### 那么如何修改元素呢？这里用加法举个例子。我继续使用二分，从根开始，往下分。题目中会给出要增加的区间，那么如果我们二分出了区间，就不用管了，因为这一部分不需要加上数。（比如我要在3-5区间加数，但是二分到了1-2区间，这时就要退出了，反正我也不加）但是如果是一部分有交集时怎么办（如加3-5，分到1-4）？这时就要有一些方法了。一言以蔽之：
# 继续分！

### 我们一直向下分，直到分到左右端点都在所需范围之中
```
void plus(ll x,ll li,ll ri,ll v){
	if(st[x].left_point>ri||st[x].right_point<li)return;//出了范围，跳出
	if(st[x].left_point>=li&&st[x].right_point<=ri){//都在范围中
		st[x].lazy+=v;//暂时先忽略
		st[x].sum+=(st[x].right_point-st[x].left_point+1)*v;//真实增值
		return;
	}
    push_down(x);//暂时忽略
	plus(left_son(x),li,ri,v);//二分
	plus(right_son(x),li,ri,v);//二分
	st[x].sum=st[left_son(x)].sum+st[right_son(x)].sum;//在递归调用返回时将父节点值改变
}
```
### 这样，可以提供一次添加服务的函数已经写完。但是，已修改节点的祖先修改了，而子孙没有修改，这该怎么办呢？
### 有人说，可以从已修改节点向下递归，把下面节点都修改，但是这样时间会到达nlogn，得不偿失。
### 于是，lazy标记应运而生。lazy是用来标识当前区间每一个节点需要加上的值，当再进行操作时经过某一点，就可以把这一点的lazy值往下推，一直到叶子节点。时间复杂度仅为O(1)。
```
void push_down(ll x){
	st[left_son(x)].sum+=(st[left_son(x)].right_point-st[left_son(x)].left_point+1)*st[x].lazy;
    //将当前节点的左孩子的sum值加上当前节点的lazy乘上左孩子的区间长度
	st[right_son(x)].sum+=(st[right_son(x)].right_point-st[right_son(x)].left_point+1)*st[x].lazy;
    //将当前节点的右孩子的sum值加上当前节点的lazy乘上右孩子的区间长度
	st[left_son(x)].lazy+=st[x].lazy;
    //将lazy标记向左下推
	st[right_son(x)].lazy+=st[x].lazy;
    //将lazy标记向右下推
	st[x].lazy=0;
    //已经加完，归零
}
```
如图：
### 这是lazy标记下推
![](https://cdn.luogu.com.cn/upload/pic/45943.png)
### 这是sum值下推
![](https://s1.ax1x.com/2018/12/11/FYkMuD.png)
### 所以我们利用lazy标记就解决了复杂度太高的问题，一句话总结，就是：在需要向下搜索时再把值向下推，不用就不推。
### 以此类推，当我们需要查找时，就用一样的道理
```cpp
ll find(ll x,ll li,ll ri){
	if(st[x].left_point>ri||st[x].right_point<li)return 0;
    //如果搜索出范围了，就停止
	if(st[x].left_point>=li&&st[x].right_point<=ri){
		return st[x].sum;//边界，搜索区间完全在范围内，返回sum值
	}
	push_down(x);//别忘了在向下查找之前下推
	return find(left_son(x),li,ri)+find(right_son(x),li,ri);//二分搜索
}
```
## 至此，整个线段树我们就写完了（省略主函数）
### 线段树是我自学习OI以来遇到的第一个高级算法，心里还是很激动的，就写了这篇题解来记录它（也是我目前写过的最长的题解了）


------------

# 完整代码（P3372）


```cpp
#include<cstdio>
#define left_son(x) (x<<1)
#define right_son(x) (x<<1|1)
#define ll long long
struct segment_tree{
	ll left_point,right_point,sum,lazy;
}st[400010];
ll n,m,a[100010];
void build(ll x,ll li,ll ri){
	st[x].left_point=li;
	st[x].right_point=ri;
	if(li==ri){
		st[x].sum=a[li];
		return;
	}
	ll mid=(li+ri)/2;
	build(left_son(x),li,mid);
	build(right_son(x),mid+1,ri);
	st[x].sum=st[left_son(x)].sum+st[right_son(x)].sum;
}
void push_down(ll x){
	st[left_son(x)].sum+=(st[left_son(x)].right_point-st[left_son(x)].left_point+1)*st[x].lazy;
	st[right_son(x)].sum+=(st[right_son(x)].right_point-st[right_son(x)].left_point+1)*st[x].lazy;
	st[left_son(x)].lazy+=st[x].lazy;
	st[right_son(x)].lazy+=st[x].lazy;
	st[x].lazy=0;
}
void plus(ll x,ll li,ll ri,ll v){
	if(st[x].left_point>ri||st[x].right_point<li)return;
	if(st[x].left_point>=li&&st[x].right_point<=ri){
		st[x].lazy+=v;
		st[x].sum+=(st[x].right_point-st[x].left_point+1)*v;
		return;
	}
	push_down(x);
	plus(left_son(x),li,ri,v);
	plus(right_son(x),li,ri,v);
	st[x].sum=st[left_son(x)].sum+st[right_son(x)].sum;
}
ll find(ll x,ll li,ll ri){
	if(st[x].left_point>ri||st[x].right_point<li)return 0;
	if(st[x].left_point>=li&&st[x].right_point<=ri){
		return st[x].sum;
	}
	push_down(x);
	return find(left_son(x),li,ri)+find(right_son(x),li,ri);
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	build(1,1,n);
	for(int i=1;i<=m;i++){
		ll sign,x,y,k;
		scanf("%lld",&sign);
		if(sign==1){
			scanf("%lld%lld%lld",&x,&y,&k);
			plus(1,x,y,k);
		}else{
			scanf("%lld%lld",&x,&y);
			printf("%lld\n",find(1,x,y));
		}
	}
	return 0;
}
```



---

## 作者：ACAね (赞：3)


## 简洁而优美 — 指针Splay

Splay上可以实现线段树可以实现的一切操作，虽然常数略大，但是支持的操作更多，可以方便的合并，分裂区间，对区间的操作更加灵活。

所以只会写P3369是不够的。

在这里，我们对于每个节点，维护它的编号与值。

对于编号，中序遍历为1~n

对于值，中序遍历为原序列。

我们按编号进行比较，其他操作基本相同。pushdown与线段树差别不大

~~自认为码风不错~~

---

## ~~还不会Splay的同学，你们是否为网上博客中那些抽象的旋转、不明所以的zig,zag,双旋判断，复杂的数组嵌套而感到困惑？~~

## ~~已经会Splay的同学，你们是否为复杂的代码，繁琐的哨兵节点而感到烦躁？~~

## ~~Splay，本该有更加清晰的代码实现，更加简洁的代码风格！而网上广为流传的基于数组与哨兵节点的Splay，已然成为算法竞赛中的毒瘤！~~
### $ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ By\ Anson $

（引用，侵删）

---

算了还是不引战了，接下来演示基于指针，不插哨兵节点的Splay是怎么写(ya)到80行左右的

~~其实真的没有暴力压行~~

```cpp
/*
@Date    : 2018-09-30 22:13:46
@Author  : Adscn (1349957827@qq.com)
@Link    : https://www.luogu.org/blog/LLCSBlog
*/
#include<bits/stdc++.h>
using namespace std;
#define IL inline
#define RG register
#define gi getint()
#define gc getchar()
#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
IL int getint()
{
    RG int xi=0;
    RG char ch=gc;
    bool f=0;
    while(ch<'0'|ch>'9')ch=='-'?f=1:f,ch=gc;
    while(ch>='0'&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
    return f?-xi:xi;
}
template<typename T>
IL void pi(T k,char ch=0)
{
    if(k<0)k=-k,putchar('-');
    if(k>=10)pi(k/10);
    putchar(k%10+'0');
    if(ch)putchar(ch);
}
const int INF=2147483647;
int n,m;
struct SplayTree{
    typedef long long ll;
    struct node;
    typedef node* tree;
    struct node{
        int val,size,pos;
        ll tot,lzy;
        tree ch[2],par;
        node(int v,int po,tree p){par=p,tot=val=v,pos=po,size=1,lzy=0;ch[0]=ch[1]=NULL;}
    }*root;
    SplayTree(){root=NULL;}
    inline bool wson(tree s,tree p){if(!p)return 0;return p->ch[1]==s;}
    inline void buildfather(tree s,tree p,bool which){s?(s->par=p):0,(p?p->ch[which]:root)=s;}
    inline int size(tree x){return x?x->size:0;}
    inline ll tot(tree x){return x?x->tot:0;}
    inline void pushup(tree x){if(x)x->size=size(x->ch[0])+size(x->ch[1])+1,x->tot=tot(x->ch[0])+tot(x->ch[1])+x->val;}
    inline void addlzy(tree x,ll lzy){if(x)x->lzy+=lzy,x->tot+=x->size*lzy,x->val+=lzy;}
    inline void pushdown(tree x)
    {
        if(x&&x->lzy)
        {
            addlzy(x->ch[0],x->lzy),addlzy(x->ch[1],x->lzy);
            x->lzy=0;
        }
    }
    inline void rotate(tree x)
    {
        tree p=x->par,g=p->par;
        bool r=wson(x,p);
        buildfather(x,g,wson(p,g)),buildfather(x->ch[!r],p,r),buildfather(p,x,!r);
        pushup(p);
    }
    inline void Splay(tree x,tree y)
    {
        if(!x)return;
        pushdownall(x);
        while(x->par!=y)
        {
            tree p=x->par,g=p->par;
            if(g!=y)rotate(wson(x,p)^wson(p,g)?x:p);
            rotate(x);
        }
        pushup(x);
    }
    inline void insert(int val,int pos)
    {
        if(!root){root=new node(val,pos,NULL);return;}
        #define nxt (pos>x->pos)
        for(tree x=root;x;x=x->ch[nxt])
            if(!x->ch[nxt])
            {
                x->ch[nxt]=new node(val,pos,x);
                Splay(x->ch[nxt],NULL);
            }
        #undef nxt
    }
    inline tree findkth(int k)
    {
        if(k<1||k>n)return NULL;
        tree x=root;
        while(1)
        	if(size(x->ch[0])>=k)x=x->ch[0];
        	else if(size(x->ch[0])+1==k)return x;
        	else k-=size(x->ch[0])+1,x=x->ch[1];
    }
    inline tree getinterval(int l,int r)
    {
        tree L=findkth(l-1),R=findkth(r+1);
        Splay(L,NULL),Splay(R,L);
        return l==1&&r==n?root:l==1?root->ch[0]:r==n?root->ch[1]:root->ch[1]->ch[0];
    }
    inline void pushdownall(tree k){tree x=root;do pushdown(x);while(x!=k&&(x=x->ch[k->pos>x->pos]));}
    inline void add(int l,int r,int addv)
    {	
        tree now=getinterval(l,r);
        addlzy(now,addv);
        pushup(now->par);if(now->par)pushup(now->par->par); 
    }
    inline ll Query(int l,int r){ return getinterval(l,r)->tot;}
}bt;
int main(void)
{
    n=gi,m=gi;
    for(int i=1;i<=n;i++)bt.insert(gi,i);
    for(int i=1,l,r;i<=m;i++)
        if(gi==1&&(l=gi)&&(r=gi))bt.add(l,r,gi);
        else l=gi,r=gi,pi(bt.Query(l,r),'\n');
    return 0;
}
```

---

## 作者：Zzh20011004 (赞：3)

线段树

记得开long long

以及位运算是比加减后运算的

附上代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
struct node
{
    int l,r;
    long long sum,add;
}    tr[400005];
inline void build(int rt,int l,int r)
{
    tr[rt].l=l,tr[rt].r=r;
    if(l==r)
    {
        long long x;
        scanf("%lld",&x);
        tr[rt].sum=x;
        return;
    }
    int mid=(l+r)>>1;
    build(rt<<1,l,mid);
    build(rt<<1|1,mid+1,r);
    tr[rt].sum=tr[rt<<1].sum+tr[rt<<1|1].sum;
}
inline void update(int rt,int L,int R,int x)
{
    int l=tr[rt].l,r=tr[rt].r;
    if(L<=l && r<=R)
    {
        tr[rt].sum=(long long)x*(r-l+1)+tr[rt].sum;
        tr[rt].add+=x;
        return;
    }
    int len=(r-l+1);
    if(tr[rt].add)
    {
        tr[rt<<1].add+=tr[rt].add;
        tr[rt<<1|1].add+=tr[rt].add;
        tr[rt<<1].sum+=(long long)tr[rt].add*(len-(len>>1));
        tr[rt<<1|1].sum+=(long long)tr[rt].add*(len>>1);
        tr[rt].add=0;
    }
    int mid=(l+r)>>1;
    if(L<=mid)    update(rt<<1,L,R,x);
    if(R>mid)    update(rt<<1|1,L,R,x);
    tr[rt].sum=tr[rt<<1].sum+tr[rt<<1|1].sum;
}
inline long long query(int rt,int L,int R)
{
    int l=tr[rt].l,r=tr[rt].r;
    if(L<=l && r<=R)
    {
        return    tr[rt].sum;
    }
    int len=(r-l+1);
    if(tr[rt].add)
    {
        tr[rt<<1].add+=tr[rt].add;
        tr[rt<<1|1].add+=tr[rt].add;
        tr[rt<<1].sum+=(long long)tr[rt].add*(len-(len>>1));
        tr[rt<<1|1].sum+=(long long)tr[rt].add*(len>>1);
        tr[rt].add=0;
    };
    long long ret=0;
    int mid=(l+r)>>1;
    if(L<=mid)    ret+=(long long)query(rt<<1,L,R);
    if(R>mid)    ret+=(long long)query(rt<<1|1,L,R);
    return ret;
}
int main()
{
    int n,m,op,x,y,L,R;
    scanf("%d%d",&n,&m);
    build(1,1,n); 
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&op);
        if(op==1)
        {
            scanf("%d%d%d",&L,&R,&x);
            update(1,L,R,x);
        }
        else
        {
            scanf("%d%d",&L,&R);
            printf("%lld\n",query(1,L,R));
        }
    }
    return 0;
}
```

---

## 作者：TheAutumnGlory (赞：2)

### 偏不用线段树系列（~~不会线段树的蒟蒻~~）
~~不知道为啥线段树的题目还能用树状数组**水**过去~~

几天前教练讲了**树状数组+差分数组的优化**，可以处理**区间修改，单点查询**和**单点修改，区间查询**操作，看到智颓里有线段树模板，一看，**区间修改，区间查询**于是愚蠢的我不会线段树，但看到**区间修改，区间查询**，就非常~~智障~~的把两份代码何为一体！！！

这是原先的**智障**~~睿智~~代码：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m;
ll a[500005],C[500005];
ll lowbit(ll x){return (x&-x);};
void modify(ll x,ll d){
	for(ll i=x;i<=n;i+=lowbit(i))
		C[i]+=d;
}
ll getSum(ll x){
	ll Sum=0;
	for(ll i=x;i;i-=lowbit(i))
		Sum+=C[i];
	return Sum2;
}
int main(){
	scanf("%lld %lld",&n,&m);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		modify(i,a[i]-a[i-1]);
	}
	for(ll i=1;i<=m;i++){
		ll type,l,r;
		ll k;
		scanf("%lld",&type);
		if(type==1){
			scanf("%lld %lld %lld",&l,&r,&k);
			modify(l,k);
			modify(r+1,-k);
		}
		else{
			scanf("%lld %lld",&l,&r);
			printf("%lld\n",getSum(r)-getSum(l-1));
		}
	}
	return 0;
}
```

然后就跑了遍样例，~~发现输出的是啥玩意~~。
**后来分析了一下，发现我们这个getSum是求的第i个数的值！！！**

### 既然一个树状数组不行，那就两个！！

设数组$D[]$，$D[i]$ = $A[i] - A[i-1]$，那么$A[i] = D[1] + D[2] + .... + D[i]$
**则D为A的差分数组。**
$A[1] + A[2] + A[3] + ... + A[k] = D[1] + D[1] + D[2] + D[1] + D[2] + D[3] + ... + D[1] + D[2] + D[3] + ... + D[k]$
$= Σ{(k - i + 1)*D[i]}$ $(1<=i<=k)$ $=$ $(k+1)*Σ${$D[i]$} – $Σ${$i*D[i]$}

**因为$k+1$是一个常数，所以我们需要维护$D[i]$的前缀和。也要维护$i*D[i]$的前缀和。**
## 所以我们需要两个树状数组，一个维护$D[i]$的前缀和,一个维护$i*D[i]$的前缀和

然后这个代码就很好写了：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m;
ll a[500005],C[500005],C2[500005];//C,C2两个数组数组
ll lowbit(ll x){return (x&-x);};
void modify(ll x,ll d){//修改操作，维护D[i]和x*D[i]的前缀和
	for(ll i=x;i<=n;i+=lowbit(i))
		C[i]+=d,C2[i]+=x*d;
}
ll getSum(ll x){//查询操作
//计算A[1]+...+A[x]
// (x+1)*Σ{D[i]}-Σ{i*D[i]}
	ll Sum1=0;
	ll Sum2=0;
	for(ll i=x;i;i-=lowbit(i))
		Sum1+=(x+1)*C[i],Sum2+=C2[i];
	return Sum1-Sum2;
}
int main(){
	scanf("%lld %lld",&n,&m);
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		modify(i,a[i]-a[i-1]);//建树
	}
	for(ll i=1;i<=m;i++){
		ll type,l,r;
		ll k;
		scanf("%lld",&type);
		if(type==1){
			scanf("%lld %lld %lld",&l,&r,&k);
			modify(l,k);//修改
			modify(r+1,-k);
		}
		else{
			scanf("%lld %lld",&l,&r);//查询
			printf("%lld\n",getSum(r)-getSum(l-1));
		}
	}
	return 0;
}
```


---

## 作者：Wichiene (赞：2)

## 一个动态开点标记永久化的线段树
动态开点的话，是可以降低空间复杂度的~~尽管对于这个题没什么意义~~

在一开始建树的时候不先建出整颗线段树，而是只建一个根节点，代表整个区间，当需要访问某个子树的时候再建立代表这个子区间的节点

一个动态开点
```cpp
void insert(ll &now,ll l1,ll r1,ll x,ll y)
{
    if(now==0)
    now=++cnt;
    t[now].sum+=y;
}
```
就这样。

但是每一次进行插入和修改以及查询都要记得加节点的问题，否则。qwq

一些因为太长没有写进注释的东西

1：
    
    由带有~\(≧▽≦)/~的那一段注释易知 如果[p,q]已经包含了当前节点的全部范围，那么它以下的所有节点暂时不予处理
    
    而同样易知它及它以上的节点不改是不行的。
    
    怎么改呢？？（假装沉思）
    
    因为是它及它以上，所以可能大于[p,q]也可能小于等于
   
   那么这一段的值总共要加上[l1,r1]与[p,q]的（重合部分的数据的个数）*（每个数要加的数（y））
    
 2
 	
    上面那个带O(∩_∩)O~的问题的ans
    
    这里我们把下一层递归里的now（也就是这里的子节点）的值已经加好，想用的话可以直接取
    
    而第一次进入这个dfs时的O(∩_∩)O~语句，其区间是1到n，是肯定处理好了的 （原因见57到59行） 
   
   那么如果 下一层递归里的now（也就是这里的子节点）已经被所求节点完全包含，那么它的子孙节点就没必要求了
 
 3
 
 由上面的操作易知如果now处有lazy，
 
 那么它的所有子节点都会有一个（子节点区间内数据个数*lazy值）的值要加，
 
 所以查询的时候，把它加进去，才可以进入下一层
        
         
 
其他的我觉得注释很详细了qwq
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

#include<cmath>
#include<algorithm>
#include<queue>
#define ll long long
using namespace std;
struct node{
    long long l,r,sum;
}t[10000050];
void read(ll &x)
{
    int f=1;x=0;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();} 
    while(c<='9'&&c>='0'){x=10*x+c-'0';c=getchar();} 
    x=x*f;
} 
ll cnt;ll now=0;
ll n,m;
ll lazy[10000050];

void insert(ll &now,ll l1,ll r1,ll x,ll y)
{
    if(now==0)
    now=++cnt;//还没有节点，要新建一个 
    t[now].sum+=y;//这个节点表示的区间含有第x位数，所以它的值（区间和）加上第x位数也就是y 
    if(l1==r1)return;//已经更新到了子节点于是结束 
    int mid=(l1+r1)/2;//判断x在当前节点下的左子节点还是右子节点 
    if(x<=mid)insert(t[now].l,l1,mid,x,y);//在左子节点
    else insert(t[now].r,mid+1,r1,x,y); //右子节点 
}//单点插入&建树
ll pd(ll l1,ll r1,ll p,ll q)
{
    ll r=min(r1,q);
    ll l=max(l1,p);
    return r-l+1;
}
void insert2(ll &now,ll l1,ll r1,ll p,ll q,ll y)
{
    if(now==0)
    now=++cnt;//没节点加一个节点 
    t[now].sum+=y*pd(l1,r1,p,q);//1：太长了就不在注释里了
    if(p<=l1&&q>=r1)
    //如果[p,q]已经包含了当前节点的全部范围 那么显然当前节点中每一个值都要修改，也就是说它的所有子孙节点都改。
    //而我们懒得改（会T）所以在这个范围最大的被完全包含的节点处记录lazy
    //然后显然就不需要再改下面的了~\(≧▽≦)/~ 
    {
        lazy[now]+=y;
        return;
    }
    int mid=(l1+r1)/2;//判断[p,q]在当前节点下的左子节点还是右子节点 
    if(p<=mid)insert2(t[now].l,l1,mid,p,q,y);//左 
    if(q>mid)insert2(t[now].r,mid+1,r1,p,q,y); //右 
    
}
ll findd(ll now,ll l1,ll r1,ll x,ll y)
{
    if(l1>=x&&r1<=y)
    {
        return t[now].sum;
    }//如果这个区间[l1,r1]已经被所求区间[x,y]包含，那么易知这个区间[l1,r1]的值（即区间内所有的数值的和）是[x,y]的和的一部分
    //然后就可以直接把它加入到所求结果（[x,y]的和）里
    //·2：lazytag呢？？下面的点呢？O(∩_∩)O~ 
    ll mid=(l1+r1)/2；
    if(lazy[now])//如果当前的这个节点上有lazy值
    {
        if(!t[now].l)//因为动态开点，所以有可能这个节点有lazy值，但它根本没有子节点 
        t[now].l=++cnt;//造一个
        lazy[t[now].l]+=lazy[now];//有可能它之前已经有过有过lazy，又传给它一个，那么它对自己的子孙节点的影响（lazy）就是二次之和 
        t[t[now].l].sum+=lazy[now]*(mid-l1+1);//(mid-ll+1)是指左子节点的数据个数。
        //3：太长了
        if(!t[now].r)
        t[now].r=++cnt;
        lazy[t[now].r]+=lazy[now];
        t[t[now].r].sum+=lazy[now]*(r1-mid);//这四行和上四行是没什么区别的因为就连代码我都是复制的qwq 
        lazy[now]=0;//now的lazy已经发下去了，就把它的lazy清零，不能再发一次 
    }
    ll suml=0;//由now分出的左边的值
    ll sumr=0;//右边
    if(x<=mid)suml=findd(t[now].l,l1,mid,x,min(mid,y)); 
    //如果所求区间的左边小于等于mid也就是在now的左子节点有一部分值就去dfs左子节点（不管右边怎么样） 
    //而往左右子节点分的时候以mid为分界线，所以这里的子区间右端点最大只能是mid（要不白分了啊qwq）
    //当然如果所求的区间右端点比mid小，那肯定不能取mid，要不所求区间都变了 ，所以取一个min就可以了 
    if(y>mid)sumr=findd(t[now].r,mid+1,r1,max(mid+1,x),y);
    //同上
    //这样偏右部分的往右子分，偏左的 往左子分，分分分分，然后把和全加起来就完了。 
     return suml+sumr;//撒花~~ 
}
int main()
{
    ll mm;
    read(n);read(m);
    ll root=0;
    for(ll i=1;i<=n;i++)
    {
        read(mm);
        insert(root,1,n,i,mm);
    }
    for(int i=1;i<=m;i++)
    {
        ll o;
        read(o);
        if(o==1)
        {
            ll x;ll y;ll mmm;
            read(x);read(y);read(mmm);
            insert2(root,1,n,x,y,mmm);
        }
        if(o==2)
        {
            ll x;ll y;
            int mmm;
            read(x);read(y);
            cout<<findd(root,1,n,x,y)<<endl;
        }
    }
 } 
```

---

## 作者：Seanq (赞：2)

**What the hell is that?**  
线段树：支持任何你想得到做得到以及想得到做不到以及想不到做得到以及想不到做不到的坑爹玩意。  
如何存储线段树？  
定义数组t,t的第i项表示编号为i的区间的东东。  
图片：  
[线段树](https://baike.baidu.com/pic/线段树/10983506/0/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09?fr=lemma&ct=single#aid=0&pic=0e2442a7d933c895d47476f7db1373f082020037)  
来看个例题！  
[【模板】线段树1](https://www.luogu.org/problemnew/show/P3372)  
暴力？  
去吧皮卡丘，别再回来了！  
有没有什么好暴力？  
你还想用暴力卡过去！？  
树状数组？  
你很棒，我不会。  
那用什么？  
看题目呗。  
**线段树**  
那就用线段树了。  

------------

建树：   
每次递归左儿子和右儿子，再取和；若是单个数，直接取当前权值。  
```cpp
void build(int l,int r,int num)
{
    if(l==r)
    {
        t[num]=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(LB);
    build(RB);
    t[num]=t[num<<1]+t[num<<1|1];
}
```

区间修改：  
第一种：一个一个单点修改过来，时间很慢。  
第二种：若当前区间在目标区间中，直接修改本区间的值，再将修改值传给儿子；否则选择与区间有交集的儿子传修改值，自己加上交集部分。  
```cpp
void index(int x,int y,int l,int r,int sum,int num)
{ 
    int f=0;
    if(l>y||r<x) return;
    int e[5];
    e[1]=x,e[2]=y,e[3]=l,e[4]=r;
    sort(e+1,e+5);
    f=e[3]-e[2]+1;
    a[num]+=sum*f;
    if(l==r) return;
    index(x,y,l,(l+r)/2,sum,(num<<1));
    index(x,y,(l+r)/2+1,r,sum,(num<<1)+1);
}
//玄学代码
```

然后我们发现：这样的时间复杂度垃圾死了，连算法一都不如。  
所以我们得加上懒标记。  
何谓懒标记？  
就是要传就传，不传拉倒。  
区间修改代码：  
```cpp
void update(int l,int r,int num,int L,int R,ll SUM)
{
    if(L<=l&&R>=r)
    {
        laz[num]+=SUM;
        t[num]+=SUM*(r-l+1);
        return;
    }
    pushup(num,(r-l+1));
    int mid=(l+r)>>1;
    if(L<=mid) update(LB,L,R,SUM);
    if(R>mid) update(RB,L,R,SUM);
    t[num]=t[num<<1]+t[num<<1|1];
}
```

懒标记下传代码：  
```cpp
void pushup(int num,int u)
{
    if(laz[num]!=0)
    {
        laz[num<<1]+=laz[num];
        laz[num<<1|1]+=laz[num];
        t[num<<1|1]+=(ll)(u>>1)*laz[num];
        t[num<<1]+=(ll)(u-(u>>1))*laz[num];
        laz[num]=0;
    }
}
```

区间查询：  
简单多了。
```cpp
ll serch(int l,int r,int num,int L,int R)
{
    
    if(L<=l&&R>=r)
    {
        return t[num];
    }
    pushup(num,(r-l+1));
    int mid=(l+r)>>1;
    ll rep=0; 
    if(L<=mid) rep+=serch(LB,L,R);
    if(R>mid) rep+=serch(RB,L,R);
    return rep; 
}
```

什么？你要完整的代码？不行！  

才怪了。  
std:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define LB l,mid,num<<1
#define RB mid+1,r,num<<1|1
const int N=100005;
int n,m;
ll a[N];
ll t[4*N]={0};
ll laz[4*N]={0};
void pushup(int num,int u)
{
    if(laz[num]!=0)
    {
        laz[num<<1]+=laz[num];
        laz[num<<1|1]+=laz[num];
        t[num<<1|1]+=(ll)(u>>1)*laz[num];
        t[num<<1]+=(ll)(u-(u>>1))*laz[num];
        laz[num]=0;
    }
}
void build(int l,int r,int num)
{
    if(l==r)
    {
        t[num]=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(LB);
    build(RB);
    t[num]=t[num<<1]+t[num<<1|1];
}
void update(int l,int r,int num,int L,int R,ll SUM)
{
    if(L<=l&&R>=r)
    {
        laz[num]+=SUM;
        t[num]+=SUM*(r-l+1);
        return;
    }
    pushup(num,(r-l+1));
    int mid=(l+r)>>1;
    if(L<=mid) update(LB,L,R,SUM);
    if(R>mid) update(RB,L,R,SUM);
    t[num]=t[num<<1]+t[num<<1|1];
}
ll serch(int l,int r,int num,int L,int R)
{
    
    if(L<=l&&R>=r)
    {
        return t[num];
    }
    pushup(num,(r-l+1));
    int mid=(l+r)>>1;
    ll rep=0; 
    if(L<=mid) rep+=serch(LB,L,R);
    if(R>mid) rep+=serch(RB,L,R);
    return rep; 
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]); 
    build(1,n,1);
    for(int i=1;i<=m;i++)
    {
        int x;
        scanf("%d",&x);
        if(x==1)
        {
            int l,r;
            ll k;
            scanf("%d %d %lld",&l,&r,&k);
            update(1,n,1,l,r,k); 
        }
        else
        {
            int l,r;
            scanf("%d%d",&l,&r);
            ll ans=serch(1,n,1,l,r);
            printf("%lld\n",ans);
        }
    }
    return 0;
} 
```


---

## 作者：Ykimna (赞：2)

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio> 
using namespace std;
const int N=1e5+100;
long long tr[N*4],flag[N*4],ans;
void built(int i,int l,int r,int x,long long val)//
{
    if(l==r)//找到了叶子节点 
    {
        tr[i]+=val;//把叶子节点的初始更新 
        return;
    }
    int mid=(l+r)/2;
    if(x<=mid) built(i*2,l,mid,x,val);//左子树 
    if(x>mid) built(i*2+1,mid+1,r,x,val);//右子树 
    tr[i]=tr[i*2]+tr[i*2+1];//回溯时更新节点 
    return;
}
void pushdown(int i,int l,int r)//lazy操作,用到才更新 
{
    int mid=(l+r)/2;
    tr[i*2]+=flag[i]*(mid-l+1);//mid-l+1是区间内元素的个数,flag[i]是记录当前节点下的节点每个元素应更新的值 //左子树 
    tr[i*2+1]+=flag[i]*(r-mid);//本是r-(mid+1)+1,化简后是r-mid//右子树 
	flag[i*2]+=flag[i];
	flag[i*2+1]+=flag[i];//应为我们用过的节点的子节点没有标记过,所以标记一下 
    flag[i]=0;//已经更新过了,清空标记 
    return;
}
void update(int i,int l,int r,long long x,long long y,long long k)//更新//操作一 
{
    if(l>=x&&r<=y)//如果(l,r)在(x,y)//体会一下,也不知生不生动{X(l,r)Y}//表明是我们要更新的点 
    {
        tr[i]+=k*(r-l+1);//因为lazy操作,我们只需要更新我们要求的点 ,没更新的用到才更新 
        flag[i]+=k;//标记当前节点表示当前节点的子节点每个值都需要加上flag[i],现在不加,要用到才更新 
        return;
    }
    if(flag[i]>0) pushdown(i,l,r);//因为么有满足if,说明要用当前节点以及它的子节点,所以要更新
	/*这里可能会看不懂,如果第一次我们更新了(5,8)但它的子节点没有更新,如果下次要更新(5,6),但原来(5,6)就有值没更新所以会少加,所以把原来
	的值更新,再更新当前值*/ 
    int mid=(l+r)/2;
    if(mid>=x) update(i*2,l,mid,x,y,k);//一直dfs,直到是我们要更新的值//左子树 
    if(mid<y) update(i*2+1,mid+1,r,x,y,k);//右子树 
    tr[i]=tr[i*2]+tr[i*2+1];
    return;
}
void query(int i,int l,int r,long long x,long long y)//操作二 
{
    if(l>=x&&r<=y)//如果(l,r)在(x,y)//体会一下,也不知生不生动{X(l,r)Y}//表明是我们要更新的点(同上update虽然还是打了一遍) 
    {
        ans+=tr[i];//更新ans把区间内的值加上 
        return;
    }
    if(flag[i]>0) pushdown(i,l,r);//因为lazy操作,当前节点的子节点没更新,所以要更新一遍 
    int mid=(l+r)/2;
    if(mid>=x) query(i*2,l,mid,x,y);//一直dfs,直到是我们要加的值//左子树 
    if(mid<y) query(i*2+1,mid+1,r,x,y);//右子树 
}
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        long long x;//题目说了要用long long 
        cin>>x;
        built(1,1,n,i,x);
    }
    while(m--)
    {
        int op;
        cin>>op;
        if(op==1)//操作一 
        {
            long long x,y,k;
            cin>>x>>y>>k;
            update(1,1,n,x,y,k);
        }
       	if(op==2)//操作二 
        {
            long long x,y;
            cin>>x>>y;
            ans=0;
            query(1,1,n,x,y);
            cout<<ans<<endl;
        }
    }
    return 0;
}

```

---

## 作者：KellyFrog (赞：2)

# 线段树
区间数据结构，可在线维护一段区间内的信息

支持区间修改、区间求和等操作，单次操作大概$O(depth)$，即$O(log n)$ ~~反正是log级别的~~

## 简介
线段树是一课二叉树，其有一下性质：
> 每个节点（包括叶子节点）对应一个区间$[n,m]$ 

> 若一个节点对应区间为$[n,m]$,其左孩子对应区间为$[n, \frac{n+m}{2}]$,右孩子为$[\frac{n+m}{2}+1,m]$

> 根节点对应区间为$[1,n]$

> 树高为$\ulcorner{log n} \urcorner$，其中$n$为元素个数

~~（以上性质请自证）~~

> $\color{red}\text{线段树不是动态开点就需要4倍大小！！！}$

# 结构体线段树
结构体定义，显然，我们需要定义一个节点对应区间的信息
```cpp
const int MAXN = 1e7 + 5;

struct SegmentTreeNode {
  int left;
  int right;
  int sum; //区间和
  int add; //lazy-tag，一会再说
};

int n, num[MAXN];
SegmentTreeNode tree[MAXN << 2];
```
## 建树

分为以下五个步骤
> 1. 判断区间长度是否为
1，是则将$sum$设成$num_{i}$，退出

> 2. 确定区间中值

> 3. 确定左右孩子区间

> 4. 左右递归建树

> 5. 将当前节点的$sum$设成$sum_{left}+sum_{right}$

代码：

```cpp
void BuildTree(int curParent) {
  if(tree[curParent].left == tree[curParent].right) {
    tree[curParent].sum = num[tree[curParent].left];
    return;
  }

  int mid = (tree[curParent].left + tree[curParent].right) >> 1;

  tree[curParent << 1].left = tree[curParent].left;
  tree[curParent << 1].right = mid;

  tree[curParent << 1 | 1].left = mid + 1;
  tree[curParent << 1 | 1].right = tree[curParent].right;

  BuildTree(curParent << 1);
  BuildTree(curParent << 1 | 1);

  tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
}
```

## 查询区间和
思路：
>如果当前区间刚好是所求区间的一部分，返回当前区间和

>否则返回左右递归调用得到的sum和

### 时间复杂度:$O(logn)$
证明：

递归得到长度为1的区间只能是区间最前和最后，否则一定可以跟左/右节点合并为一个更长的区间

同理，最多有2个长度为2的区间，最多有2个长度为4的区间...最多有2个长度为$\frac{n}{4}$的区间，最多有1个$\frac{n}{2}$的区间，所以复杂度是$O(logn)$

代码：
```cpp
int QuerySum(int l, int r, int curParent) { //在curParent为根的子树中查询[l,r]
  PushDown(curParent); //下传lazy-tag标记

  if(tree[curParent].left == l && tree[curParent].right == r) {
    return tree[curParent].sum;
  }

  int mid = (tree[curParent].left + tree[curParent].right) >> 1;

  if(l > mid) {
    return QuerySum(l, r, curParent << 1 | 1);
  }
  if(r <= mid) {
    return QuerySum(l, r, curParent << 1);
  }
  return QuerySum(l, mid, curParent << 1) + QuerySum(mid + 1, r, curParent << 1 | 1);
}
```

## 区间操作的优化

### $\text{lazy-tag}$ 延迟符号

延迟符号是打在一段区间（一个节点表示的区间）上的标记，只要这段区间没被使用，打上$lazy-tag$后就不需要维护其$lazy-tag$，保证时间复杂度

如果对这点区间的子区间进行了操作，则需要**下传标记```PushDown()```**，保证下边的子区间也有$lazy-tag$可以下传、维护子节点的信息

注意：在给区间打上标记的时候一定要更新其区间和，即$sum+=lazy\cdot(right-left+1)$

### ```PushDown()```操作
```PushDown(int node)```表示下传```node```的$lazy$标记（只要```node```不是叶子节点），清空当前标记，顺便维护左右孩子的区间和

```cpp
void PushDown(int node) {
  if(tree[node].left == tree[node].right) { //是叶子节点
    tree[node].add = 0;
    return;
  }

  tree[node << 1].add += tree[node].add;
  tree[node << 1 | 1].add += tree[node].add;

  tree[node << 1].sum += (tree[node << 1].right - tree[node << 1].left + 1) * tree[node].add;
  tree[node << 1 | 1].sum += (tree[node << 1| 1].right - tree[node << 1 | 1].left + 1) * tree[node].add;
  
  tree[node].add = 0;
}
```

## 区间加
主要思路跟求和一样，找到完全包含在查询区间里的子区间，在该节点打上$lazy-tag$标签，更新该节点sum，以后访问该区间时再下传

注意：每访问一个节点，都需要执行```PushDown()```操作，保证上边原来的标记能够正常在子区间内生效

与区间和同理，复杂度$O(logn)$

代码：
```cpp
void Add(int l, int r, int add, int curParent) {
  if(tree[curParent].left == l && tree[curParent].right == r) {
    tree[curParent].add += add;
    tree[curParent].sum += (r - l + 1) * add;
    return;
  }

  PushDown(curParent);

  int mid = (tree[curParent].left + tree[curParent].right) >> 1;

  if(l > mid) {
    Add(l, r, add, curParent << 1 | 1);
    tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
    return;
  }
  if(r < mid + 1) {
    Add(l, r, add, curParent << 1);
    tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
    return;
  }
  Add(l, mid, add, curParent << 1);
  Add(mid + 1, r, add, curParent << 1 | 1);
  tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
}
```

## $\text{AC Code}$
```cpp
#include <iostream>
#include <fstream>

#define int long long

using namespace std;

const int MAXN = 1e7 + 5;

struct TreeNode {
  int left;
  int right;
  int sum;
  int add;
};

struct Quest {
  int opt;
  int left;
  int right;
  int data;
};

TreeNode tree[MAXN << 2];
Quest quest[10005];
int num[MAXN], n, m;

void BuildTree(int curParent) {
  if(tree[curParent].left == tree[curParent].right) {
    tree[curParent].sum = num[tree[curParent].left];
    return;
  }

  int mid = (tree[curParent].left + tree[curParent].right) >> 1;

  tree[curParent << 1].left = tree[curParent].left;
  tree[curParent << 1].right = mid;

  tree[curParent << 1 | 1].left = mid + 1;
  tree[curParent << 1 | 1].right = tree[curParent].right;

  BuildTree(curParent << 1);
  BuildTree(curParent << 1 | 1);

  tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
}

void PushDown(int node) {
  if(!tree[node].left) {
    return;
  }

  tree[node << 1].add += tree[node].add;
  tree[node << 1 | 1].add += tree[node].add;

  tree[node << 1].sum += (tree[node << 1].right - tree[node << 1].left + 1) * tree[node].add;
  tree[node << 1 | 1].sum += (tree[node << 1| 1].right - tree[node << 1 | 1].left + 1) * tree[node].add;

  //tree[node].sum = tree[node << 1].sum + tree[node << 1 | 1].sum;

  tree[node].add = 0;
}


int QuerySum(int l, int r, int curParent) {
  PushDown(curParent);

  if(tree[curParent].left == l && tree[curParent].right == r) {
    return tree[curParent].sum;
  }

  int mid = (tree[curParent].left + tree[curParent].right) >> 1;

  if(l > mid) {
    return QuerySum(l, r, curParent << 1 | 1);
  }
  if(r < mid + 1) {
    return QuerySum(l, r, curParent << 1);
  }
  return QuerySum(l, mid, curParent << 1) + QuerySum(mid + 1, r, curParent << 1 | 1);
}

void Add(int l, int r, int add, int curParent) {
  if(tree[curParent].left == l && tree[curParent].right == r) {
    tree[curParent].add += add;
    tree[curParent].sum += (r - l + 1) * add;
    return;
  }

  PushDown(curParent);

  int mid = (tree[curParent].left + tree[curParent].right) / 2;

  if(l > mid) {
    Add(l, r, add, curParent << 1 | 1);
    tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
    return;
  }
  if(r < mid + 1) {
    Add(l, r, add, curParent << 1);
    tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
    return;
  }
  Add(l, mid, add, curParent << 1);
  Add(mid + 1, r, add, curParent << 1 | 1);
  tree[curParent].sum = tree[curParent << 1].sum + tree[curParent << 1 | 1].sum;
}

signed main() {
  cin >> n >> m;
  for(int i = 1; i < n + 1; i++) {
    cin >> num[i];
  }
  for(int i = 0; i < m; i++) {
    cin >> quest[i].opt;
    switch(quest[i].opt) {
    case 1:
      cin >> quest[i].left >> quest[i].right >> quest[i].data;
      break;
    case 2:
      cin >> quest[i].left >> quest[i].right;
      break;
    }
  }

  tree[1].left = 1;
  tree[1].right = n;
  BuildTree(1);

  for(int i = 0; i < m; i++) {
    switch(quest[i].opt) {
    case 1: 
      Add(quest[i].left, quest[i].right, quest[i].data, 1);
      break;
    case 2:
      cout << QuerySum(quest[i].left, quest[i].right, 1) << endl;
      break;
    }
  }
  return 0;
}
```

---

## 作者：ღ﹏ﻬ北❦栀 (赞：2)

## 线段树模板
之前我们的某位大佬，利用他无与伦比的手速，10分钟就敲完了，我这个蒟蒻只能用我这龟速的手速写完这题，代码如下。希望大佬能喜欢。
```cpp
#include<stdio.h>
#include<stdlib.h>
#define int long long
using namespace std;
inline int gi(){int x;scanf("%lld",&x);return x;}
const int N=100010;//定义N为线段最大长度
 2 
struct node{
	int l,r,sum,tag;	
}t[N<<2];　// t 数组为 main 函数中读入的内容
void pushup(int o){t[o].sum=(t[o<<1].sum+t[o<<1|1].sum);}
void pushdown(int o){
	if(t[o].tag){
		t[o<<1].tag+=t[o].tag;
		t[o<<1|1].tag+=t[o].tag;
		t[o<<1].sum+=t[o].tag*(t[o<<1].r-t[o<<1].l+1);
		t[o<<1|1].sum+=t[o].tag*(t[o<<1|1].r-t[o<<1|1].l+1);
		t[o].tag=0;
	}
}
void build(int o,int l,int r)//线段树主要用于区间记录信息（如区间和、最大最小值等），首先是建树
{
	t[o].l=l;t[o].r=r;t[o].tag=0;
	if(l==r){t[o].sum=gi();return;}//当左端点等于右端点即建立叶子结点时，直接给数组信息赋值
	int mid=(l+r)>>1;// mid 为中间点，左儿子结点为 [l,m] ，右儿子结点为 [m+1,r]；
	build(o<<1,l,mid);//构建左儿子结点
    build(o<<1|1,mid+1,r);//构建右儿子结点
	pushup(o);	
}//传入的参数为 o:当前需要建立的结点；l：当前需要建立的左端点；r：当前需要建立的右端点
void modify(int o,int l,int r,int posl,int posr,int k)
{
	if(posl<=l && r<=posr){t[o].tag+=k;t[o].sum+=k*(r-l+1);return;}
	int mid=(l+r)>>1;pushdown(o);
	if(posl<=mid)modify(o<<1,l,mid,posl,posr,k);
	if(mid<posr)modify(o<<1|1,mid+1,r,posl,posr,k);
	pushup(o);
}
int query(int o,int l,int r,int posl,int posr)//posl、posr为需要查询的区间左右端点
{
	if(posl<=l && r<=posr)return t[o].sum;　//若当前结点和需要查找的区间不相交，则返回一个对于区间查询无关的值（如求和时返回0，求最大值时返回-1等）
	int mid=(l+r)>>1,ret=0;pushdown(o);
	if(posl<=mid)ret+=query(o<<1,l,mid,posl,posr);
	if(mid<posr)ret+=query(o<<1|1,mid+1,r,posl,posr);　//posl为查询左儿子结点得到的信息，posr为查询右儿子结点得到的信息
	return ret;//综合两个儿子结点的信息并返回
}
signed main()
{
	int n=gi(),m=gi();
	build(1,1,n);
	while(m--){
		int opt=gi(),l=gi(),r=gi();
		if(opt==1)modify(1,1,n,l,r,gi());
		else printf("%lld\n",query(1,1,n,l,r));
	}
}
```
如果大佬有更好的代码，可以教教蒟蒻。Thanks♪(･ω･)ﾉ

---

## 作者：yingjz (赞：2)

## 题目大意

请你维护一个有n个元素的整数序列，要求支持**区间查询&区间修改**

对于100%的数据，$1<=n<=10^5$

## 分析

正常做法是线段树维护区间修改、区间查询，今天我要讲的是一种**暴力**做法：分块

分块的思想并不复杂，分块把一个长度为n的区间分成num段，操作时如果是整段**用标记修改**，不是整段的部分**暴力修改**

分析时间复杂度：在这题中，每段的标记修改是$O(1)$的，最多有num段，整段标记修改所用时间是$O(num)$的；不是整段的部分最多有$O(n/num)$个，暴力修改所用的时间是$O(n/num)$的；所以总时间是$O(num+n/num)$。

根据*基本不等式*，num取$\sqrt n$时该式有最小值；所以num取$\sqrt n$。

## 实现

分块的思想并不复杂，时间复杂度也不玄学，但是实现起来并不方便（可能是我弱）

分块的修改/查询都分为2部分：
1. 整块的修改
2. “零头”的修改

整块的修改是否简便：`add[i] += val;`
“零头”的修改直接修改，同时不要忘了维护所在块的信息：
```c++
a[i] += val;
sum[id[i]] += val;
```
修改就愉快地解决了，查询和修改差不多。

### 完整代码

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

const int maxn = 100007;
int n, m, num, id[maxn];
long long sum[1000], add[1000], a[maxn];

int main(){
	scanf("%d%d", &n, &m);
	num = sqrt(n);
	for (int i = 1; i <= n; ++i){
		scanf("%lld", &a[i]);
		id[i] = (i-1) / num;
		sum[id[i]] += a[i];
	}

	while (m--){
		int d; scanf("%d", &d);
		if (d==1){
			int x, y, C; scanf("%d%d%d", &x, &y, &C);
			int Leftid = (x-1) / num + 1;
			int Rightid = (y-1) / num - 1;

			long long res = 0;
			for (int i = Leftid; i <= Rightid; ++i)
				 add[i] += C;

			for (int i = x; i <= Leftid * num; ++i)
				a[i] += C, sum[id[i]] += C;

			for (int i = (Rightid+1)*num+1; i <= y; ++i)
				a[i] += C, sum[id[i]] += C;
		}else{
			int x, y; scanf("%d%d", &x, &y);
			int Leftid = (x-1) / num + 1;
			int Rightid = (y-1) / num - 1;

			if (id[x] == id[y]){
				long long res = 0;
				for (int i = x; i <= y; ++i)
					res += a[i] + add[id[i]];
				printf("%lld\n", res);
				continue;
			}

			long long res = 0;
			for (int i = Leftid; i <= Rightid; ++i)
				res += sum[i] + add[i] * num;

			for (int i = x; i <= Leftid * num; ++i)
				res += a[i] + add[Leftid-1];

			for (int i = (Rightid+1)*num+1; i <= y; ++i)
				res += a[i] + add[Rightid+1];

			printf("%lld\n", res);

		}
	}
	return 0;
}

```







---

## 作者：sherlock55341 (赞：2)

大家好，我非常喜欢暴力数据结构，但是我没有很强的分块科技  
隔壁神犇要写更快的分块  
对于每个块维护区间和，增加标记（用于零散点的查询）  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
#include<cmath>
#define MAXN 100010
#define ll long long
#define size(x) (r[x]-l[x]+1)
using namespace std;
inline void read(ll &x)
{
	ll s=0,w=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')w=-1;c=getchar();}
	while(isdigit(c)){s=(s<<3)+(s<<1)+c-'0';c=getchar();}
	x=s*w;
}
inline void write(ll x)
{
	if(x<0)x=-x,putchar('-');
	if(x>9)write(x/10);
	putchar('0'+x%10);
}
ll n,m,belong[MAXN],sum[MAXN],a[MAXN],l[MAXN],r[MAXN],sq,opt,x,y,k,j,mark[MAXN];
int main()
{
	read(n),read(m);
	sq=ceil(sqrt(n));
	for(int i=1;i<=n;i++)read(a[i]),belong[i]=i/sq,sum[belong[i]]+=a[i];
	for(int i=1;i<=n;i++)if(!l[belong[i]])l[belong[i]]=i;
	for(int i=n;i;i--)if(!r[belong[i]])r[belong[i]]=i;
	while(m--)
	{
		read(opt);
		if(opt==1)
		{
			read(x),read(y),read(k);
			for(j=x;j<=y;j++)
			{
				if(l[belong[j]]==j)break;
				a[j]+=k,sum[belong[j]]+=k;
			}
			for(;j<=y;j+=size(belong[j]))
			{
				if(r[belong[j]]>y)break;
				sum[belong[j]]+=k*size(belong[j]),mark[belong[j]]+=k;
			}
			for(;j<=y;j++)
			a[j]+=k,sum[belong[j]]+=k;
		}
		else
		{
			read(x),read(y);
			ll ans=0;
			for(j=x;j<=y;j++)
			{
				if(l[belong[j]]==j)break;
				ans+=a[j]+mark[belong[j]];
			}
			for(;j<=y;j+=size(belong[j]))
			{
				if(r[belong[j]]>y)break;
				ans+=sum[belong[j]];
			}
			for(;j<=y;j++)
			ans+=a[j]+mark[belong[j]];
			write(ans),putchar(10);
		}
	}
}

```
我真是太弱了

---

## 作者：frankchenfu (赞：2)

这道题目推荐使用树状数组或zkw线段树。

树状数组，就是用一倍的空间，区间减法的思想，完成的一种数据结构，它是前缀和数组和普通数组之前的桥梁，修改和查询复杂度都是O($log_2 n$)。这里不多说，详见树状数组模板题的题解（话说那里好多线段树的题解……）。Cpp代码：

```cpp
#include<cstdio>
const int MAX=100001;
long long d[MAX],id[MAX],s[MAX],k;
int n,m,c,x,y;
int lowbit(int x)
{
    return x&-x;
}
void add(long long *b,int p,long long v)
{
    for(;p<=n;p+=lowbit(p))
        b[p]+=v;
}
long long ask(long long*b,int p)
{
    long long a=0;
    for(;p;p-=lowbit(p))
        a+=b[p];
    return a;
}
long long query(int p)
{
    return s[p]+(p+1)*ask(d,p)-ask(id,p);
}
void add(int x,int y,long long v)
{
    add(d,x,v);
    add(d,y+1,-v);
    add(id,x,v*x);
    add(id,y+1,-v*(y+1));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lld",&s[i]),s[i]+=s[i-1];
    while(m--)
    {
        scanf("%d%d%d",&c,&x,&y);
        if(c==1)
            scanf("%lld",&k),add(x,y,k);
        else
            printf("%lld\n",query(y)-query(x-1));
    }
    return 0;
}
```
然后，我们讲zkw线段树。

zkw线段树是一种非递归式的线段树（作者是THU的张昆玮，参见他自己的PPT讲稿《统计的力量-线段树》）

zkw线段树的操作几乎没有出现递归，而是用循环代替。各种操作的思想同普通线段树。

那么他有什么优点呢？优点就是，常数小。这里开一个我丑陋博客里[关于zkw线段树的简单描述](http://www.cnblogs.com/frankchenfu/p/7132445.html)。

代码这里就不提供了，有兴趣的同学可以自行学习。


---

## 作者：Vasily (赞：2)

Lazy Tag标记思想

这个就是模板，哪晓得还70分了好几次。

注意数组开大点

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std ;
const ll maxn = 100010 ;
ll n, m, tree[maxn<<2], lzy[maxn<<2] ;
bool Read ( ll &x ) {
    bool f = 0 ; x = 0 ; char c = getchar() ; 
    while ( !isdigit(c) ) {
        if ( c == '-' ) f = 1 ;
        if ( c == EOF ) return false ;
        c = getchar() ;
    }
    while ( isdigit(c) ) {
        x = 10 * x + c - '0' ;
        c = getchar() ;
    }
    if ( f ) x = -x ;
    return true ;
}
void push_up ( ll h ) { tree[h] = tree[h<<1] + tree[h<<1|1] ; }
void push_down ( ll h, ll lenth ) {
    if ( lzy[h] ) {
        lzy[h<<1] += lzy[h] ;
        lzy[h<<1|1] += lzy[h] ;
        tree[h<<1] += lzy[h]*(lenth-(lenth>>1)) ;
        tree[h<<1|1] += lzy[h]*(lenth>>1) ;
        lzy[h] = 0 ;
    }
}
void create_tree ( ll h, ll l, ll r ) {
    if ( l == r ) {
        Read(h[tree]) ;
        return ;
    }
    ll mid = l+r >> 1 ;
    create_tree ( h<<1, l, mid ) ;
    create_tree ( h<<1|1, mid+1, r ) ;
    push_up(h) ;
}
ll query ( ll h, ll l, ll r, ll x, ll y ) {
    if ( x <= l && r <= y ) return h[tree] ;
    push_down(h,r-l+1) ;
    ll mid = l+r >> 1 ;
    if ( y <= mid ) return query ( h<<1, l, mid, x, y ) ;
    else if ( x > mid ) return query ( h<<1|1, mid+1, r, x, y ) ;
    else return 
        query ( h<<1, l, mid, x, mid ) +
        query ( h<<1|1, mid+1, r, mid+1, y ) ;
}
void update ( ll h, ll l, ll r, ll x, ll y, ll k ) {
    if ( x <= l && r <= y ) {
        lzy[h] += k ;
        tree[h] += (r-l+1)*k ;
        return ;
    }
    push_down(h,r-l+1) ;
    ll mid = l+r >> 1; 
    if ( y <= mid ) update ( h<<1, l, mid, x, y, k ) ;
    else if ( x > mid ) update ( h<<1|1, mid+1, r, x, y, k ) ;
    else {
        update ( h<<1, l, mid, x, mid, k ) ;
        update ( h<<1|1, mid+1, r, mid+1, y, k ) ;
    }
    push_up(h) ;
}
int main() {
    ll i, j, k, q, cmd, x, y, z ;
    Read(n) ; Read(m) ;
    create_tree ( 1, 1, n ) ;
    while ( m-- ) {
        Read(cmd) ; Read(x) ; Read(y) ;
        if ( cmd == 1 ) {
            Read(k) ;
            update ( 1, 1, n, x, y, k ) ;
        } else printf ( "%lld\n", query ( 1, 1, n, x, y ) ) ;
    }
    return 0 ;
}
```

---

## 作者：我的妹妹syf (赞：2)

来一发块状链表。


由于没有插入删除操作，所以直接对块进行顺序查找。


有点慢，1300+ms，但是简单易懂啊。


```cpp
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long LL;
const int MAXN=1024;
int l[MAXN],r[MAXN];
LL sum[MAXN],lt[MAXN],num[MAXN*MAXN];
int n,m,tot,siz;
char c;
inline int read(){
    c=getchar();
    while(c<'0'||c>'9') c=getchar();
    int p=0;
    while(c>='0'&&c<='9') p=p*10+c-'0',c=getchar();
    return p;
}
inline void push_down(int k){
    if(!lt[k]) return;
    for(int i=l[k];i<=r[k];i++) num[i]+=lt[k];
    lt[k]=0;
}
int main(){
    n=read();m=read();
    siz=int(sqrt(n));
    l[tot]=1;
    for(int i=1,a;i<=n;i++){
        num[i]=read();
        r[tot]=i;
        sum[tot]+=num[i];
        a++;
        if(a==siz&&i<n) l[++tot]=i+1,a=0;
    }
    for(int k=0,a,b,c,d;k<m;k++){
        a=read();b=read();c=read();
        if(a==1){
            d=read();
            for(int i=0;i<=tot;i++){
                if(l[i]>=b&&r[i]<=c) sum[i]+=(r[i]-l[i]+1)*d,lt[i]+=d;
                else if(l[i]<=b&&r[i]>=b){
                    sum[i]+=(r[i]-b+1)*d;
                    push_down(i);
                    for(int j=b;j<=r[i];j++) num[j]+=d;
                }
                else if(l[i]<=c&&r[i]>=c){
                    sum[i]+=(c-l[i]+1)*d;
                    push_down(i);
                    for(int j=l[i];j<=c;j++) num[j]+=d;
                }
            }
        }
        else{
            LL ans=0;
            for(int i=0;i<=tot;i++){
                if(l[i]>=b&&r[i]<=c) ans+=sum[i];
                else if(l[i]<=b&&r[i]>=b){
                    push_down(i);
                    for(int j=b;j<=r[i];j++) ans+=num[j];
                }
                else if(l[i]<=c&&r[i]>=c){
                    push_down(i);
                    for(int j=l[i];j<=c;j++) ans+=num[j];
                }
            }
            printf("%lld\n",ans);
        }
    }
    return 0;
}

```

---

## 作者：McGrady (赞：2)

全是线段树或树状数组啊，我来个不一样的

这题我先打了一个线段树，过了

然后我打了个分块，居然也满分

时间复杂度n^1.5，不过跑起来只比线段树慢一倍（最大的点只用了200+ms）

分块常数小很多

更重要的是，调试容易得多

```cpp
program rrr(input,output);
var
  a:array[0..100010]of int64;
  idx:array[0..100010]of longint;    //idx[i]表示a[i]所属的分块
  sum,delta:array[0..1000]of int64;   //sum是分块和，delta是分块增量
  i,j,k,t,x,y,n,m,num,head,tail,tot:longint;
  d,ans:int64;
begin
   //assign(input,'r.in');assign(output,'r.out');reset(input);rewrite(output);
   readln(n,m);
   num:=trunc(sqrt(n));
   j:=0;k:=1;
   fillchar(sum,sizeof(sum),0);
   fillchar(delta,sizeof(delta),0);
   for i:=1 to n do
       begin
          read(a[i]);
          inc(j);
          if j>num then begin j:=1;inc(k); end;
          idx[i]:=k;sum[k]:=sum[k]+a[i];
       end;
   tot:=k;
   for i:=1 to m do
       begin
          read(t);
          if t=1 then
             begin
                read(x,y,d);
                if idx[x-1]=idx[x] then head:=idx[x]+1 else head:=idx[x];
                if idx[y]=idx[y+1] then tail:=idx[y]-1 else tail:=idx[y];
                for j:=head to tail do
                    begin
                       if j=tot then sum[j]:=sum[j]+d*(n-num*(tot-1)) else sum[j]:=sum[j]+d*num;
                       delta[j]:=delta[j]+d;
                    end;
                if (head<>idx[x]) or (idx[x]=idx[y]) and (idx[y]<>tail) then
                   begin
                      j:=x;
                      while (idx[j]=idx[x]) and (j<=y) do
                          begin
                             a[j]:=a[j]+d;
                             sum[idx[x]]:=sum[idx[x]]+d;
                             inc(j);
                          end;
                   end;
                if (tail<>idx[y]) and (idx[y]<>idx[x]) then
                    begin
                       j:=y;
                       while idx[j]=idx[y] do
                           begin
                              a[j]:=a[j]+d;
                              sum[idx[y]]:=sum[idx[y]]+d;
                              dec(j);
                           end;
                    end;
             end
          else
              begin
                read(x,y);
                if idx[x-1]=idx[x] then head:=idx[x]+1 else head:=idx[x];
                if idx[y]=idx[y+1] then tail:=idx[y]-1 else tail:=idx[y];
                ans:=0;
                for j:=head to tail do ans:=ans+sum[j];
                if (head<>idx[x]) or (idx[x]=idx[y]) and (idx[y]<>tail) then
                   begin
                      j:=x;
                      while (idx[j]=idx[x]) and (j<=y) do
                          begin
                             ans:=ans+a[j]+delta[idx[x]];
                             inc(j);
                          end;
                   end;
                if (tail<>idx[y]) and (idx[y]<>idx[x]) then
                    begin
                       j:=y;
                       while idx[j]=idx[y] do
                           begin
                              ans:=ans+a[j]+delta[idx[y]];
                              dec(j);
                           end;
                    end;
                writeln(ans);
              end;
        end;
   //close(input);close(output);
end.

```

---

## 作者：amazingOZR (赞：2)

表示用的树状数组，既好写又快。当然树状数组的适用范围小很多，不过在某些特殊问题上还是很好用的。

首先将数列差分。设原数列是a\_1,a\_2\cdots a\_n，定义d\_i=a\_i-a\_{i-1}。则在区间[x,y]上加k相当于d\_x+=k,d\_{y+1}-=k。

考虑位置p的前缀和。对于1\leq i\leq p，d\_i对前缀和的贡献为d\_i\times(p-i+1)，移项有(p+1)\times d\_i-i\times d\_i。所以我们对d\_i维护前缀和，对i\times d\_i维护前缀和。这两个都可以用树状数组完成。

记得加long long

```cpp
#include<cstdio>
typedef long long ll;
const int maxn=100005;
ll d[maxn],id[maxn],s[maxn],k;
int n,m,c,x,y;
void add(ll*b,int p,ll v){for(;p<=n;p+=p&-p)b[p]+=v;}
ll ask(ll*b,int p)
{
    ll a=0;
    for(;p;p-=p&-p)a+=b[p];
    return a;
}
ll ask(int p){return s[p]+(p+1)*ask(d,p)-ask(id,p);}
void add(int x,int y,ll v)
{
    add(d,x,v);add(d,y+1,-v);
    add(id,x,v*x);add(id,y+1,-v*(y+1));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;++i)scanf("%lld",s+i),s[i]+=s[i-1];
    while(m--)
    {
        scanf("%d%d%d",&c,&x,&y);
        if(c==1)scanf("%lld",&k),add(x,y,k);
        else printf("%lld\n",ask(y)-ask(x-1));
    }
    return 0;
}
```

---

## 作者：kczno1 (赞：2)

我的zkw神奇的卡进了108ms。。

不过理论上zkw确实是会比树状数组快一点点。

zkw能解决可以不下放的，自下向上更新的标记，

但如果再有区间乘的话，似乎必须要先下放标记，所以用不了zkw。

(要是有大神会一定要告诉我啊)

不会的同学自己画图，对着代码参透吧。。

```cpp
#include<bits/stdc++.h>

const int max_n=100000+5;

long long a[max_n*3],s[max_n*3];int d,sz;
//a是加法标记，s是区间和 
#define upd(l) s[l]=s[l<<1]+s[l<<1|1]+(a[l]<<sz);
#define _add(l) {a[l]+=x;s[l]+=(x<<sz);}
#define SL (l^1)
#define SR (r^1)
long long x;
void add(int l,int r)
{
    l+=d;r+=d;
    
    sz=0;
    _add(l)
    if (l!=r)
    {
        _add(r)
        while (SL!=r)
        {
            if (!(l&1)) _add(SL)
            if (r&1)    _add(SR)
            ++sz;
            l>>=1;upd(l);
            r>>=1;upd(r);
        }
    }
    while (l>>=1)
    {
        ++sz;upd(l);
    }
}

int numl,numr;
long long qiu(int l,int r)
{
     l+=d;r+=d;
    x=s[l];numl=sz=1;
    if (l!=r)
    {
        x+=s[r];numr=1;
        while (SL!=r)
        {
            if (!(l&1)) { x+=s[SL]; numl+=sz; }
            if (r&1) {  x+=s[SR]; numr+=sz; }
            sz<<=1;
            l>>=1;r>>=1;
            x+=a[l]*numl+a[r]*numr;
        }
        numl+=numr;
    }
    while (l>>=1) x+=a[l]*numl;
    
    return x;
}

const int top=10000000;
char ch[top];int now_r;
void read(int &x)
{
    while (ch[now_r]<48) ++now_r;
    for (x=ch[now_r]-48;ch[++now_r]>=48;)
     x=(x<<1)+(x<<3)+ch[now_r]-48;
}
void readl(long long &x)
{
    while (ch[now_r]<48) ++now_r;
    for (x=ch[now_r]-48;ch[++now_r]>=48;)
     x=(x<<1)+(x<<3)+ch[now_r]-48;
}

int main()
{ //freopen("1.in","r",stdin);
  fread(ch,1,top,stdin);
    int n,m,i;
    read(n);read(m);
    for (d=1;d<n;d<<=1);d-=1;
    
    for (i=1;i<=n;++i) readl(s[d+i]);
    for (i=(n+d)>>1;i;--i) s[i]=s[i<<1]+s[i<<1|1];
    //初始化 
    
    int c,l,r;
    for (i=1;i<=m;++i)
    {
        read(c);read(l);read(r);
        if (c==1)
        {
            readl(x);
            add(l,r);
        }
        else printf("%lld\n",qiu(l,r));
    }
}
```

---

## 作者：子谦。 (赞：2)

给出一个数组$a$，要求实现对数组进行两类操作：

第一类，给出区间$[x,y]$，对区间内的每个$a_i$加上$z$/乘$z$等

第二类，给出区间$[x,y]$，查询区间内所有元素的和/最大值/最小值等

最简单的方法，直接处理，每次处理复杂度$O(n)$，$n$次处理复杂度就是$O(n^2)$，如果$n$的范围扩大到$1e5$乃至$1e6$，这样的速度显然是我们无法承受的

还有没有什么更好的办法呢？

我们是否可以使用树状数组呢？对于区间加以及区间求和操作是可以的，但是写起来比较麻烦，今天我们用一种新方法来解决这个问题，那就是——

<center>
 <font size="6" >线段树！！</font>   
</center>

所谓线段树，顾名思义，就是由一条条线段组成的树。什么意思呢？我们来看图。

![](https://i.loli.net/2019/09/21/8ZGMzeY14iLN2u3.png)

这个图从下往上看，我们发现最初的一个一个点不断地两两合并最终变成了一条长线段，而如果只注意红线的话，明显是一个二叉树结构，而且好像应该是一个完全二叉树

我们就可以利用一个这样的结构来存储区间和，当查询的时候只需要看当前区间是否属于查询区间，属于则返回这个区间的和，若是不属于，我们就查看它的左右区间，对于跟查询区间没有交集的区间我们可以直接返回，不需要继续向下搜索，这样的话复杂度最差是$\lg n$的（证明就省略了，大家也知道，我不擅长证明233）

那么这样的一棵树的创建我们应当如何通过代码来实现呢？复杂度：$O(n)$

```cpp
void build(int p,int l,int r){ //p是当前节点的编号，l,r表示当前节点记录的是区间[l,r]的信息
	if(l==r){t[p]=a[l];return;}  //如果区间长度为1，那么就可以直接把数组的值存进来，然后返回
	int m=l+r>>1;  //这里的m是二分所用，看图应该也能明白
	build(lc,l,m);build(rc,m+1,r);  //这里的lc和rc代表的是p的左右子节点的编号，我们习惯于让p的左子节点编号为p的2倍，右子节点编号为p的2倍+1。这里的操作就是创建左右子树
	pushup(p);  //这个函数是用来根据左右子树来修改当前节点信息的函数，根据题目要求的不同，写法也不同，我们下面会提到，这里先把它当做一个可直接使用的系统自带函数即可
}
```

<center>（短短的几行代码，浓缩了大量的精华，希望大家能够认真阅读我的注释，不然可能不好理解）</center>

这棵树被创建好了，查询不成问题了，但是修改操作怎么办呢？如果按照创建的方法来修改，每次修改的复杂度都是$O(n)$，这就又成$n^2$算法了，费半天劲复杂度没变岂不是很亏。

所以我们用一种神奇的方法来进行区间修改操作。我们的修改操作大体与查询操作的思想是一样的，但是倘若不把修改进行到底，下次查询到这次修改区间的子区间，可能就会输出未修改的状态，这怎么办呢？

我们给每个节点做一个懒惰标记。为什么叫懒惰标记呢？因为它真的很懒惰，你踹它一脚它挪一步。当我们的修改操作进行到属于修改区间的区间的时候，我们把它的信息进行修改，然后用懒惰标记记录下来修改内容，然后返回。当后面进行修改操作或是查询操作访问到这个区间时，我们先将懒惰标记下放（也就是用懒惰标记修改其左右子节点的值，然后把懒惰标记传递给它的左右儿子，然后删除自己身上的懒惰标记）然后再继续进行之前要继续进行的操作。这样的话，每次修改的复杂度就从$O(n)$被优化成$O(n\lg n)$了

代码如下（以区间加区间求和为例）

```cpp
void update(int p,int l,int r,int L,int R,int z){  //L,R表示的是要求修改的区间，z表示要求加上的数
	if(l>R||r<L)return;  //如果没有交集就直接退出，节约时间
	if(L<=l&&r<=R){t[p].v+=(r-l+1)*z;t[p].lz+=z;return;}  //如果属于修改区间就修改值，修改懒惰标记，返回
	int m=l+r>>1;if(t[p].lz)pushdown(p,l,r);  //pushdown操作是用来下放懒惰标记的函数，下面会提到，这里可以先当成一个系统自带的函数
	update(lc,l,m,L,R,z);update(rc,m+1,r,L,R,z);  //先修改左右子树
	pushup(p);  //根据左右子树修改后的值更新当前节点
}
```

知道了修改操作怎么写，其实查询操作就很简单了，直接放代码吧(还是以区间加区间求和为例)

```cpp
int query(int p,int l,int r,int L,int R){  //如上
	if(l>R||r<L)return 0;
	if(L<=l&&r<=R)return t[p].v;  //如果当前区间属于查询区间，返回区间和
	int m=l+r>>1;if(t[p].lz)pushdown(p,l,r);  //下放懒惰标记
	return query(lc,l,m,L,R)+query(rc,m+1,r,L,R);  //不断查询左右子树
}
```

下面就该谈谈我们的$pushup$函数了。对于不同的需求写法也是不一样的，其实一般来说都很简单

```cpp
inline void pushup(int p){  //区间求和
	t[p].v=t[lc].v+t[rc].v;
}
inline void pushup(int p){  //区间最值
	t[p].v=min(t[lc].v,t[rc].v);
}
inline void pushup(int p){  //区间积（这玩意一般用不上，因为太大一般需要取模，去膜后除法要变成逆元，比较麻烦）
	t[p].v=t[lc].v*t[rc].v;
}
```

相比于$pushup$函数，$pushdown$函数要麻烦许多

```cpp
inline void pushdown(int p,int l,int r){  //区间加区间求和
	int m=l+r>>1,&lz=t[p].lz;
	t[lc].v+=(m-l+1)*lz;t[lc].lz+=lz;
	t[rc].v+=(r-m)*lz;t[rc].lz+=lz;
	lz=0;
}
inline void pushdown(int p,int l,int r){  //区间乘区间加区间求和
	int m=l+r>>1,&lz1=t[p].lz1,&lz2=t[p].lz2;
	if(t[p].lz1!=1){
		t[lc].v*=lz1,t[rc].v*=lz1;
		t[lc].lz1*=lz1,t[rc].lz1*=lz1;
		t[lc].lz2*=lz1,t[rc].lz2*=lz1;
		lz1=1;
	}
	if(t[p].lz2){
		t[lc].v+=(m-l+1)*lz2;t[lc].lz2+=lz2;
		t[rc].v+=(r-m)*lz2;t[rc].lz2+=lz2;
		lz2=0;
	}
}
```

----

线段树的各部分组成大家已经都看明白了，那么接下来就是把它连成一个整体

[模板1](https://www.luogu.org/problem/P3372)

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
#define gc getchar
#define maxn 100005
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}int n,m;

struct ahaha{
	ll v,lz;
}t[maxn<<2];
#define lc p<<1
#define rc p<<1|1
inline void pushup(int p){
	t[p].v=t[lc].v+t[rc].v;
}
inline void pushdown(int p,int l,int r){
	int m=l+r>>1;ll &lz=t[p].lz;
	t[lc].v+=(m-l+1)*lz;t[lc].lz+=lz;
	t[rc].v+=(r-m)*lz;t[rc].lz+=lz;
	lz=0;
}
void build(int p,int l,int r){
	if(l==r){t[p].v=read();return;}
	int m=l+r>>1;
	build(lc,l,m);build(rc,m+1,r);
	pushup(p);
}
void update(int p,int l,int r,int L,int R,ll z){
	if(l>R||r<L)return;
	if(L<=l&&r<=R){t[p].v+=(r-l+1)*z;t[p].lz+=z;return;}
	int m=l+r>>1;if(t[p].lz)pushdown(p,l,r);
	update(lc,l,m,L,R,z);update(rc,m+1,r,L,R,z);
	pushup(p);
}
ll query(int p,int l,int r,int L,int R){
	if(l>R||r<L)return 0;
	if(L<=l&&r<=R)return t[p].v;
	int m=l+r>>1;if(t[p].lz)pushdown(p,l,r);
	return query(lc,l,m,L,R)+query(rc,m+1,r,L,R);
}

inline void solve_1(){
	int x=read(),y=read();ll z=read();
	update(1,1,n,x,y,z);
}
inline void solve_2(){
	int x=read(),y=read();
	printf("%lld\n",query(1,1,n,x,y));
}

int main(){
	n=read();m=read();
	build(1,1,n);
	while(m--){
		int zz=read();
		switch(zz){
			case 1:solve_1();break;
			case 2:solve_2();break;
		}
	}
	return 0;
}
```

[模板2](https://www.luogu.org/problem/P3373)

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#define ll long long
#define gc getchar
#define maxn 100005
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}int n,m;ll mo;

struct ahaha{
	ll v,lz1=1,lz2;
}t[maxn<<2];
#define lc p<<1
#define rc p<<1|1
inline void pushup(int p){
	t[p].v=(t[lc].v+t[rc].v)%mo;
}
inline void pushdown(int p,int l,int r){
	int m=l+r>>1;ll &lz1=t[p].lz1,&lz2=t[p].lz2;
	if(lz1!=1){
		t[lc].lz2=t[lc].lz2*lz1%mo,t[rc].lz2=t[rc].lz2*lz1%mo;
		t[lc].lz1=t[lc].lz1*lz1%mo,t[rc].lz1=t[rc].lz1*lz1%mo;
		t[lc].v=t[lc].v*lz1%mo,t[rc].v=t[rc].v*lz1%mo;
		lz1=1;
	}
	if(lz2){
		t[lc].v=(t[lc].v+(m-l+1)*lz2)%mo,t[lc].lz2=(t[lc].lz2+lz2)%mo;
		t[rc].v=(t[rc].v+(r-m)*lz2)%mo,t[rc].lz2=(t[rc].lz2+lz2)%mo;
		lz2=0;
	}
}
void build(int p,int l,int r){
	if(l==r){t[p].v=read()%mo;return;}
	int m=l+r>>1;
	build(lc,l,m);build(rc,m+1,r);
	pushup(p);
}
void update1(int p,int l,int r,int L,int R,ll z){
	if(l>R||r<L)return;
	if(L<=l&&r<=R){
		t[p].lz1=t[p].lz1*z%mo;t[p].lz2=t[p].lz2*z%mo;
		t[p].v=t[p].v*z%mo;return;
	}
	int m=l+r>>1;pushdown(p,l,r);
	update1(lc,l,m,L,R,z);update1(rc,m+1,r,L,R,z);
	pushup(p);
}
void update2(int p,int l,int r,int L,int R,ll z){
	if(l>R||r<L)return;
	if(L<=l&&r<=R){t[p].lz2=(t[p].lz2+z)%mo;t[p].v=(t[p].v+(r-l+1)*z)%mo;return;}
	int m=l+r>>1;pushdown(p,l,r);
	update2(lc,l,m,L,R,z);update2(rc,m+1,r,L,R,z);
	pushup(p);
}
ll query(int p,int l,int r,int L,int R){
	if(l>R||r<L)return 0;
	if(L<=l&&r<=R)return t[p].v;
	int m=l+r>>1;pushdown(p,l,r);
	return (query(lc,l,m,L,R)+query(rc,m+1,r,L,R))%mo;
}

inline void solve_1(){
	int x=read(),y=read();ll z=read();
	update1(1,1,n,x,y,z);
}
inline void solve_2(){
	int x=read(),y=read();ll z=read();
	update2(1,1,n,x,y,z);
}
inline void solve_3(){
	int x=read(),y=read();
	printf("%lld\n",query(1,1,n,x,y));
}

int main(){
	n=read();m=read();mo=read();
	build(1,1,n);
	while(m--){
		int zz=read();
		switch(zz){
			case 1:solve_1();break;
			case 2:solve_2();break;
			case 3:solve_3();break;
		}
	}
	return 0;
}
```

----

### 题目推荐

[方差](https://www.luogu.org/problem/P1471)

[色斑游戏](https://www.luogu.org/problem/P1558)

[HH的项链](https://www.luogu.org/problem/P1972)

[维护序列](https://www.luogu.org/problem/P2023)

[会议中心](https://www.luogu.org/problem/P3626)

[序列](https://www.luogu.org/problem/P3863)

[签到题IV](https://www.luogu.org/problem/P3794)

你理解线段树了吗？如果这篇博客能够给你些许帮助的话，不妨点个推荐吧

---

## 作者：LechX (赞：2)

虽然这道题是线段树的模板，然而我又懒得打线段树的代码，况且洛谷也没有树状数组区间修改，区间查询的模板题，于是我就来发个树状数组吧！（这就是你水题的理由？？？）
好了进入正文吧


树状数组是一个很神奇的数据结构，主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。

接下来发个图吧!![](http://s16.sinaimg.cn/middle/afe6bb33gc9f752512d9f&690)
!

定义sum(i)=a[1]+a[2]+...+a[i]

为了实现树状数组的区间修改，区间查询，在此引入差分数组d[i]=a[i]-a[i-1],在修改区间[l,r]时就只用修改d[l]和d[r+1]就可以了~所以sum(i)=d[1]+(d[1]+d[2])+(d[1]+d[2]+d[3])+...+(d[1]+d[2]+d[3]+...+d[i])

维护两个树状数组，c1记录d[i],c2记录(i-1)*d[i] (d[i]=a[i]-a[i-1])

sum(n)=n*sum(c1,n)-sum(c2,n);

代码如下：
```pascal
var
 c1,c2,d,a:array[0..100005]of int64;
 n,i,j,q,a1,b1,t,cz,x:longint;
function lowbit(x:longint):longint;
begin
 exit(x and (-x));
end;
procedure add(x,s:longint);//将a[x]加上s
var
 pre:longint;
begin
 pre:=x;
 while x<=n do
 begin
  c1[x]:=c1[x]+s*(pre-1);
  c2[x]:=c2[x]+s;
  x:=x+lowbit(x);
 end;
end;
function sum(x:longint):int64;//见上
var
 s,pre:int64;
begin
 s:=0;
 pre:=x;
 while x>0 do
 begin
  s:=s-c1[x]+pre*c2[x];
  x:=x-lowbit(x);
 end;
 exit(s);
end;
begin
 readln(n,q);
 for i:=1 to n do
 begin
  read(a[i]);
  d[i]:=a[i]-a[i-1];//求出差分数组
  add(i,d[i]);//初始化
 end;
 for i:=1 to q do
 begin
  read(cz);
  if cz=1 then
  begin
   read(a1,b1,x);
   add(a1,x);
   add(b1+1,-x);//执行区间修改
  end else
  begin
   read(a1,b1);
   writeln(sum(b1)-sum(a1-1));//求和
  end;
 end;
end.
```

---

## 作者：Sor4 (赞：2)

//！！初学者适用！！主要要注意标记的应用，可以大大提升速度，不了解的可以去百度懒标记/惰性标记。











    
    

    
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long Lovelive;//据说这样typedef long long会rp++。>.< 
const int maxx = (100000<<2)+10;
int x,y,n,m,Flag,k;
Lovelive a[maxx],Add[maxx];//Add代表每个点的标记 
struct Node
{
    int Left,Right;
    Lovelive sum; 
}Node[maxx];//存每个结点左右端点以及值。 
void Pushdown(int i,int l,int r);//下放标记 
void Build_tree(int i,int l,int r);//建树 
void Update(int i,int l,int r,Lovelive k);//区间修改 
Lovelive Query(int i,int l,int r);//区间查询 
//void DeBug();
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    Build_tree(1,1,n);//记得建树 
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&Flag);
        if(Flag==1)
        {
            scanf("%d%d%lld",&x,&y,&k);
            Update(1,x,y,k);
        }
        if(Flag==2)
        {
            scanf("%d%d",&x,&y);
            printf("%lld\n",Query(1,x,y));
        }
    }
    return 0;
}
void Build_tree(int i,int l,int r)
{
    Node[i].Left = l;
    Node[i].Right = r;
    if(l==r) 
    {
        Node[i].sum = a[l];
        return;
```
}//如果是叶结点
    


    
    
```cpp
    int mid = (l+r) >> 1;
    Build_tree( i<<1 , l , mid );
    Build_tree( (i<<1)|1 , mid+1 , r );
    Node[i].sum = Node[i<<1].sum+Node[(i<<1)+1].sum;
}
void Pushdown(int i)
{
    int lc = i<<1,rc = (i<<1)+1;
    Node[lc].sum+=(Node[lc].Right-Node[lc].Left+1)*Add[i];
    Node[rc].sum+=(Node[rc].Right-Node[rc].Left+1)*Add[i];
    Add[lc]+=Add[i];
    Add[rc]+=Add[i];
    Add[i]=0;//下放标记 
}
void Update(int i,int x,int y,Lovelive k)
{
    int lc = i<<1,rc = (i<<1)|1;
    if(Node[i].Left>y||Node[i].Right<x)
        return;//如果是完全无关区间 
    if(x<=Node[i].Left&&Node[i].Right<=y)
    {
        Node[i].sum+=(Node[i].Right-Node[i].Left+1)*k;//加到这就不往下加了 
        Add[i]+=k;//存标记 
```
}//如果是完全有关区间
    
```cpp
    else
    {
        if(Add[i]) Pushdown(i);//下放标记 
        Update(lc,x,y,k);
        Update(rc,x,y,k);
        Node[i].sum=Node[lc].sum+Node[rc].sum;
```
}//二分添加

```cpp
}
Lovelive Query(int i,int x,int y)
{
    int lc = i<<1,rc = (i<<1)+1;
    if(x<=Node[i].Left&&Node[i].Right<=y)
        return Node[i].sum;
    if(Node[i].Left>y||Node[i].Right<x)
        return 0;
    if(Add[i]) Pushdown(i);//下放标记 
    return Query(lc,x,y)+Query(rc,x,y);
}
```

---

## 作者：渡海 (赞：2)

**这个板子比较适合于新手理解。**

百度上有一篇CSDN博客：http://www.cnblogs.com/TenosDoIt/p/3453089.html#c，叫做一步一步理解线段树，我根据这个线段树模板改编了一下，并通过楼下 @smd1121 大佬和will大佬指出不当修改完成。

下面是code：


        
        


        

    

            
        
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
    long long val,lazytag;
}segTree[100000*4+5];
long long a[100005];
int n,m,t,x,y,k;
void build(int root,long long arr[],int istart,int iend){//建树
    segTree[root].lazytag=0;
    if(istart==iend){
        segTree[root].val=arr[istart];
    }else{
        int mid=(istart+iend)/2;
        build(root*2,arr,istart,mid);
        build(root*2+1,arr,mid+1,iend);
        segTree[root].val=segTree[root*2].val+segTree[root*2+1].val;
    }
}
void pushDown(int root,int start,int end){//插入懒标记
    if(segTree[root].lazytag!=0){
        segTree[root*2].lazytag+=segTree[root].lazytag;
        segTree[root*2+1].lazytag+=segTree[root].lazytag;
        int mid=(end+start)/2;
        segTree[root*2].val+=segTree[root].lazytag*(mid-start+1);
        segTree[root*2+1].val+=segTree[root].lazytag*(end-mid);
        segTree[root].lazytag=0;
    }
}
long long query(int root,int nstart,int nend,int qstart,int qend){//查询区间
    if(qstart>nend||qend<nstart){
        return 0; 
    }if(qstart<=nstart&&qend>=nend){
        return segTree[root].val;
    }
    pushDown(root,nstart,nend);
    int mid=(nstart+nend)/2;
    return query(root*2,nstart,mid,qstart,qend)+query(root*2+1,mid+1,nend,qstart,qend);
}
void update(int root,int nstart,int nend,int ustart,int uend,int addval){//赋值
    if(ustart>nend||uend<nstart){
        return;
    }if(ustart<=nstart&&uend>=nend){
        segTree[root].lazytag+=addval;
        segTree[root].val+=addval*(nend-nstart+1);
        return;
    }
    pushDown(root,nstart,nend);
    int mid=(nstart+nend)/2;
    update(root*2,nstart,mid,ustart,uend,addval);
    update(root*2+1,mid+1,nend,ustart,uend,addval);
    segTree[root].val=segTree[root*2].val+segTree[root*2+1].val;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    build(1,a,1,n);
    for(int i=1;i<=m;i++){
        scanf("%lld",&t);
        if(t==1){
            scanf("%lld%lld%lld",&x,&y,&k);
            update(1,1,n,x,y,k);
        }if(t==2){
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",query(1,1,n,x,y));
        }
    }
}
```

---

## 作者：龙啸空 (赞：1)

# 这是一篇不用PushDown的题解

#### ~~但是好像只适用于区间和~~

核心思想：在打上lazyTag以后发现可以不用pushdown，因为每一个标记对应当前的区间被加过几次。

我们只需要在递归向下时将每个经过区间的Tag都加上，到一个终止节点（就是一个在查询区间内的最大区间）时用递归的Tag乘以当前区间长度加上区间sum就好了。

在此将线段树封装成了类，将递归时的节点作为一个全局变量，并在函数中计算当前节点对应区间的左端点和右端点。需要注意的是，使用时请开为全局变量。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace SegmentTree{
	template <typename T>
	class SegmentTree2{
			int _hot,size;
			T _tag;
			struct Node{
				T key,lazyTag;
			}Tree[100005<<2];
			void update(int,int,int,int,T);
			T query(int,int,int,int);
		public:
			SegmentTree2(int);
			void update(int,T);
			void update(int,int,T);
			T query(int,int);
	};
	template <typename T>
	void SegmentTree2<T>::update(int l,int r,int L,int R,T x){
		int tl,tr;
		tl=max(l,L);
		tr=min(r,R);
		Tree[_hot].key+=(tr-tl+1)*x;
		if((L<=l)&&(r<=R)){
			Tree[_hot].lazyTag+=x;
			return;
		}
		int mid=l+(r-l)/2;
		int _tmp=_hot;
		if(L<=mid){
			_hot=_tmp<<1;
			update(l,mid,L,R,x);
		}
		if(R>mid){
			_hot=_tmp<<1|1;
			update(mid+1,r,L,R,x);
		}
	}
	template <typename T>
	T SegmentTree2<T>::query(int l,int r,int L,int R){
		if(L<=l&&r<=R){
			return Tree[_hot].key+(r-l+1)*_tag;
		}
		T ans=0;
		int mid=l+(r-l)/2;
		int _tmp=_hot;
		_tag+=Tree[_hot].lazyTag;
		if(L<=mid){
			_hot=_tmp<<1;
			ans+=query(l,mid,L,R);
		}
		if(R>mid){
			_hot=_tmp<<1|1;
			ans+=query(mid+1,r,L,R);
		}
		_tag-=Tree[_tmp].lazyTag;
		return ans;
	}
	template <typename T>
	void SegmentTree2<T>::update(int l,int r,T x){
		_hot=1;
		update(1,size,l,r,x);
	}
	template <typename T>
	void SegmentTree2<T>::update(int p,T x){
		_hot=1;
		update(1,size,p,p,x);
	}
	template <typename T>
	T SegmentTree2<T>::query(int l,int r){
		_tag=0;
		_hot=1;
		return query(1,size,l,r);
	}
	template <typename T>
	SegmentTree2<T>::SegmentTree2(int s){
		size=s;
		memset(Tree,0,sizeof(Tree));
	}

}
using namespace SegmentTree;
SegmentTree1<long long> T(100005);
int main(){
	int N,M;
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++){
		long long x;
		scanf("%lld",&x);
		T.insert(i,x);
	}
	while(M--){
		long long op,l,r,x;
		scanf("%lld%lld%lld",&op,&l,&r);
		if(op==1){
			scanf("%lld",&x);
			T.update(l,r,x);
		}else printf("%lld\n",T.querySum(l,r));
	}
	return 0;
}
```


---

## 作者：_hyc_ (赞：1)

~~本蒟蒻第一次写文章资瓷一下下啦~~~~~

线段树是从OI萌新转向OI~~大佬~~的重要算法

在实际应用也是可以将O(N）的复杂度优化到O（log N）的神奇东西

**进入正题**

**第一部分---线段树概念（包括前置知识）**

线段树是一种二叉树,举个小小de栗子

![](https://cdn.luogu.com.cn/upload/pic/71366.png)

~~其实他就是个二分的过程~~

这是什么意思呢？ 如果你要表示线段的和，那么最上面的根节点的权值表示的是这个线段1~8的和。根的两个儿子分别表示这个线段中1~4的和，与5~8的和。

~~当然后面的也是一样~~

由此，我们可以退出一个性质

#### 节点i的权值=她的左儿子权值+她的右儿子权值

我们再来一个前置性知识

假设一个节点编号为n，那么它的左儿子的编号为n<<1 (2*n).

自然右儿子的编号为(n<<1)|1(2*n+1)

千万记住（（n<<1）|1要加括号，不然会先算1|1，再算左移！！！）

so，我们可以struct一个结构体node.l表示它的左儿子，node.r表示它的右儿子，node.sum表示区间和

结合上面的式子，我们可以得tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;

就有了接下来的代码:

```cpp
inline void build(int i,int l,int r)
	{//inline加速的，可以不加
    node[i].l=l;node[i].r=r;
    if(l==r)
	{//左右指向一个，说明此时是叶子节点
        node[i].sum=input[l];
        return ;
    }
    int mid=(l+r)>>1;//((l+r)/2)
    build(i*2,l,mid);//建造左子树and右子树
    build(i*2+1,mid+1,r);
    node[i].sum=node[i*2].sum+node[i*2+1].sum;
	//上述性质
	return ;
}
```
**第二部分---线段树入门**

线段树中比较常用的一般有:单点修改，区间查询.区间修改，单点查询.以及其衍生出来的许多操作，我在此只讲这两个

**2.1** 区间修改，单点查询

区间修改:

假设我们需要在l到r这个区间所有数都加上x，那么我们只需要在这个区间置上标记，在单点查询是在在这数组上面把标记加起来就好

具体做法如思路，直接上代码~~~

```cpp
void node_add(int i,int l,int r,int k)
{
	if(node[i].l>=l && node[i].r<=r)
	{//如果这个区间被完全包括在目标区间里面，在这个区间标记k
		node[i].sum+=k;
		return ;
	}
	if(node[i*2].r>=l)
	node_add(i*2,l,r,k);
	if(node[i*2+1].l<=r)
	node_add(i*2+1,l,r,k);
}
```
那么单点查询么emm...那就更简单了,直接无脑加标记就好了

```cpp
void chazhao(int i,int k)
{
   ans+=node[i].num;//又是无脑叠加
	if(node[i].l==node[i].r)
	return ;
	if(k<=node[i*2].r)
   chazhao(i*2,dis);
	if(k>=node[i*2+1].l)
	chazhao(i*2+1,dis);
}
```
**2.2** 单点修改，区间查询

我们再次翻出上面那张图

![](https://cdn.luogu.com.cn/upload/pic/71366.png)

假定我们要求1-5的和，我们从根开始看，根被分成了两个区间，分别是**1-4**,**5-8**.不难发现1-4这个区间是完全在我们需要查询的1-5之间的，所以，我们直接返回1-4的sum，再看5-8，再被分成5-6与7-8,5-6与要查询的1-5有交集，所以继续查询5-6，此时被分成**5**and**6**，5完全在1-5之内，所以返回5的sum.

有人可能会说了，这个我用脚指头都能算出来，为啥还要这么麻烦？~~好像确实是这样~~

但你想过如果100w个数需要查询99w个的和呢?此时，线段树又简洁，还比朴素的累计时间复杂度要低很多，所以自然是我们的不二之选。

下面的第一个代码就是所说的查询功能

```cpp
int chazhao(int x,int l,int r)
{
	if(node[x].l>=l && node[x].r<=r)
	return node[x].sum;
   //如果完全包括
	if(node[x].r<l || node[x].l>r)
	return 0;
	//如果完全没有交集
	int ans=0;
	if(node[x*2].r>=l)
	ans+=chazhao(x*2,l,r);
	//如果这个区间的左儿子和目标区间又交集，就搜索左儿子
	if(node[x*2+1].l<=r) 						ans+=chazhao(x*2+1,l,r);
   //如果这个区间的右儿子和目标区间又交集，就搜索右儿子
    return ans;
}
```

我身边的OIer都直接在无脑背这个，但我还是觉得理解记忆比较好
~~不然如果在考场上忘了，或者脑抽了~~

咳咳咳,回归正题.

那么如何实现修改单点呢?

其实也不难

还记得我们最初推出来的定理么node[i].sum=node[i*2].sum+node[i*2+1].sum

我再使用一次那张图
![](https://cdn.luogu.com.cn/upload/pic/71391.png)
假定我们需要修改的是原图的五号点，其中黄色是去的路径，红色是返回的路径，回来时候红色的+标记就是把这个点加上这个值。

如果你还是不懂~~确实很难~~，那么听我通俗来说

相当于我们在5号加上了k,然后因为需要满足node[x].sum=node[(x<<1)|1].sum+node[(x<<1)].sum;
所以往上依照这个更新就行了，直接上代码

```cpp
void add(int i,int y,int x)
{
    if(node[i].l==node[i].r)
	{//如果区间只有1个点，那就找到了
        node[i].sum+=x;
        return ;
    }
    if(y<=node[i*2].r)
	add(i*2,y,x);
   else  add(i*2+1,y,x); //向在的方向搜
   tree[i].sum=node[i*2].sum+node[i*2+1].sum;
   //维护一下下定理 
   return ;
}
```

线段树初级教学 完毕!
如果你认认真真学完了，而且都会了，你就得到了不错的入门

我准备出个二继续深入讲线段树，码字绘图都不易，点个赞走行不行

如有错误，请联系我订正

---

## 作者：_hyc_ (赞：1)

~~本蒟蒻第一次写文章资瓷一下下啦~~~~~

线段树是从OI萌新转向OI~~大佬~~的重要算法

在实际应用也是可以将O(N）的复杂度优化到O（log N）的神奇东西

**进入正题**

**第一部分---线段树概念（包括前置知识）**

线段树是一种二叉树,举个小小de栗子

![](https://cdn.luogu.com.cn/upload/pic/71366.png)

~~其实他就是个二分的过程~~

这是什么意思呢？ 如果你要表示线段的和，那么最上面的根节点的权值表示的是这个线段1~8的和。根的两个儿子分别表示这个线段中1~4的和，与5~8的和。

~~当然后面的也是一样~~

由此，我们可以退出一个性质

#### 节点i的权值=她的左儿子权值+她的右儿子权值

我们再来一个前置性知识

假设一个节点编号为n，那么它的左儿子的编号为n<<1 (2*n).

自然右儿子的编号为(n<<1)|1(2*n+1)

千万记住（（n<<1）|1要加括号，不然会先算1|1，再算左移！！！）

so，我们可以struct一个结构体node.l表示它的左儿子，node.r表示它的右儿子，node.sum表示区间和

结合上面的式子，我们可以得tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;

就有了接下来的代码:

```cpp
inline void build(int i,int l,int r)
	{//inline加速的，可以不加
    node[i].l=l;node[i].r=r;
    if(l==r)
	{//左右指向一个，说明此时是叶子节点
        node[i].sum=input[l];
        return ;
    }
    int mid=(l+r)>>1;//((l+r)/2)
    build(i*2,l,mid);//建造左子树and右子树
    build(i*2+1,mid+1,r);
    node[i].sum=node[i*2].sum+node[i*2+1].sum;
	//上述性质
	return ;
}
```
**第二部分---线段树入门**

线段树中比较常用的一般有:单点修改，区间查询.区间修改，单点查询.以及其衍生出来的许多操作，我在此只讲这两个

**2.1** 区间修改，单点查询

区间修改:

假设我们需要在l到r这个区间所有数都加上x，那么我们只需要在这个区间置上标记，在单点查询是在在这数组上面把标记加起来就好

具体做法如思路，直接上代码~~~

```cpp
void node_add(int i,int l,int r,int k)
{
	if(node[i].l>=l && node[i].r<=r)
	{//如果这个区间被完全包括在目标区间里面，在这个区间标记k
		node[i].sum+=k;
		return ;
	}
	if(node[i*2].r>=l)
	node_add(i*2,l,r,k);
	if(node[i*2+1].l<=r)
	node_add(i*2+1,l,r,k);
}
```
那么单点查询么emm...那就更简单了,直接无脑加标记就好了

```cpp
void chazhao(int i,int k)
{
   ans+=node[i].num;//又是无脑叠加
	if(node[i].l==node[i].r)
	return ;
	if(k<=node[i*2].r)
   chazhao(i*2,dis);
	if(k>=node[i*2+1].l)
	chazhao(i*2+1,dis);
}
```
**2.2** 单点修改，区间查询

我们再次翻出上面那张图

![](https://cdn.luogu.com.cn/upload/pic/71366.png)

假定我们要求1-5的和，我们从根开始看，根被分成了两个区间，分别是**1-4**,**5-8**.不难发现1-4这个区间是完全在我们需要查询的1-5之间的，所以，我们直接返回1-4的sum，再看5-8，再被分成5-6与7-8,5-6与要查询的1-5有交集，所以继续查询5-6，此时被分成**5**and**6**，5完全在1-5之内，所以返回5的sum.

有人可能会说了，这个我用脚指头都能算出来，为啥还要这么麻烦？~~好像确实是这样~~

但你想过如果100w个数需要查询99w个的和呢?此时，线段树又简洁，还比朴素的累计时间复杂度要低很多，所以自然是我们的不二之选。

下面的第一个代码就是所说的查询功能

```cpp
int chazhao(int x,int l,int r)
{
	if(node[x].l>=l && node[x].r<=r)
	return node[x].sum;
   //如果完全包括
	if(node[x].r<l || node[x].l>r)
	return 0;
	//如果完全没有交集
	int ans=0;
	if(node[x*2].r>=l)
	ans+=chazhao(x*2,l,r);
	//如果这个区间的左儿子和目标区间又交集，就搜索左儿子
	if(node[x*2+1].l<=r) 						ans+=chazhao(x*2+1,l,r);
   //如果这个区间的右儿子和目标区间又交集，就搜索右儿子
    return ans;
}
```

我身边的OIer都直接在无脑背这个，但我还是觉得理解记忆比较好
~~不然如果在考场上忘了，或者脑抽了~~

咳咳咳,回归正题.

那么如何实现修改单点呢?

其实也不难

还记得我们最初推出来的定理么node[i].sum=node[i*2].sum+node[i*2+1].sum

我再使用一次那张图
![](https://cdn.luogu.com.cn/upload/pic/71391.png)
假定我们需要修改的是原图的五号点，其中黄色是去的路径，红色是返回的路径，回来时候红色的+标记就是把这个点加上这个值。

如果你还是不懂~~确实很难~~，那么听我通俗来说

相当于我们在5号加上了k,然后因为需要满足node[x].sum=node[(x<<1)|1].sum+node[(x<<1)].sum;
所以往上依照这个更新就行了，直接上代码

```cpp
void add(int i,int y,int x)
{
    if(node[i].l==node[i].r)
	{//如果区间只有1个点，那就找到了
        node[i].sum+=x;
        return ;
    }
    if(y<=node[i*2].r)
	add(i*2,y,x);
   else  add(i*2+1,y,x); //向在的方向搜
   tree[i].sum=node[i*2].sum+node[i*2+1].sum;
   //维护一下下定理 
   return ;
}
```

线段树初级教学 完毕!
如果你认认真真学完了，而且都会了，你就得到了不错的入门

我准备出个二继续深入讲线段树，码字绘图都不易，点个赞走行不行

如有错误，请联系我订正

---

## 作者：loceaner (赞：1)

## 思路

 前几天学了线段树的我，今天又去做了一遍线段树【模板】$1$，发现自己打代码真的是漏洞百出啊，不过最后还是对了，所以来水一篇博客

首先，这道模板题的要求就是：

> 1.区间加
  2.区间求和

这两个操作都属于线段树的基本操作

### 前置——宏定义
```cpp
#define N 100011
#define lson rt << 1
#define rson rt << 1 | 1
#define int long long
```
由于我特别懒，不想写什么$rt << 1$之类的东西，所以直接宏定义就好了，还有，为了不改$int$，我直接把$int$宏定义为$long \ long$，省的麻烦~~（我真的是懒到家了）~~

### 1.定义
```cpp
int sum[N << 2], lazy[N << 2], n, m;
```
众所周知，线段树一般要开四倍空间，不明白的可以自己画一颗线段树数一下，sum数组维护区间和，lazy是懒标记

### 2.pushup
```cpp
inline void pushup(int rt) {
	sum[rt] = sum[lson] + sum[rson];
}
```
这是一个上传给父亲结点的信息的函数，当前节点的区间和就等于它左儿子和右儿子的区间和之和

### 3.建树
```cpp
void build(int l, int r, int rt) {
	if(l == r) {
		sum[rt] = read();
		return;
	}
	int m = (l + r) >> 1;
	build(l, m, lson);
	build(m + 1, r, rson);
	pushup(rt);
}
```
上面是建树过程,$rt$表示当前节点，$lson$是左孩子，$rson$是右孩子

### 4.标记下放
```cpp
inline void pushdown(int l, int r, int rt) {
	if(!lazy[rt]) return;
	lazy[lson] += lazy[rt];
	lazy[rson] += lazy[rt];
	int m = (l + r) >> 1;
	sum[lson] += (m - l + 1) * lazy[rt];
	sum[rson] += (r - m) * lazy[rt];
	lazy[rt] = 0;
	return;
}
```

pushdown函数的实现：

1.用lazy存储这个懒标记。

2.递归到这个节点时，只更新这个节点的状态，并把当前的更改值累积到标记中。

什么时候才用到这个懒标记？

当需要递归这个节点的子节点时，标记下传给子节点。

3.下放操作：（三步）

当前节点的懒标记累积到子节点的懒标记中。

修改子节点状态。

父节点懒标记清0。


### 5.区间修改
```cpp
void update(int L, int R, int c, int l, int r, int rt) {
	if(L <= l && r <= R) {
		sum[rt] += c * (r - l + 1);
		lazy[rt] += c;
		return;
	}
	pushdown(l, r, rt);
	int m = (l + r) >> 1;
	if(L <= m) update(L, R, c, l, m, lson);
	if(R > m) update(L, R, c, m + 1, r, rson);
	pushup(rt);
}

```

### 6.区间求和
```cpp
int query(int L, int R, int l, int r, int rt) {
	if(L <= l && r <= R) return sum[rt];
	pushdown(l, r, rt);
	int m = (l + r) >> 1, ans = 0;
	if(L <= m) ans += query(L, R, l, m, lson);
	if(R > m) ans += query(L, R, m + 1, r, rson);
	return ans;
}
```

##代码

下面上传高清~~无码~~无水印代码

```cpp
#include <bits/stdc++.h>
#define N 100011
#define lson rt << 1
#define rson rt << 1 | 1
#define int long long
using namespace std;

int sum[N << 2], lazy[N << 2], n, m;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);
	return x * f;
}

inline void pushup(int rt) {
	sum[rt] = sum[lson] + sum[rson];
}

void build(int l, int r, int rt) {
	if(l == r) {
		sum[rt] = read();
		return;
	}
	int m = (l + r) >> 1;
	build(l, m, lson);
	build(m + 1, r, rson);
	pushup(rt);
}

inline void pushdown(int l, int r, int rt) {
	if(!lazy[rt]) return;
	lazy[lson] += lazy[rt];
	lazy[rson] += lazy[rt];
	int m = (l + r) >> 1;
	sum[lson] += (m - l + 1) * lazy[rt];
	sum[rson] += (r - m) * lazy[rt];
	lazy[rt] = 0;
	return;
}

void update(int L, int R, int c, int l, int r, int rt) {
	if(L <= l && r <= R) {
		sum[rt] += c * (r - l + 1);
		lazy[rt] += c;
		return;
	}
	pushdown(l, r, rt);
	int m = (l + r) >> 1;
	if(L <= m) update(L, R, c, l, m, lson);
	if(R > m) update(L, R, c, m + 1, r, rson);
	pushup(rt);
}

int query(int L, int R, int l, int r, int rt) {
	if(L <= l && r <= R) return sum[rt];
	pushdown(l, r, rt);
	int m = (l + r) >> 1, ans = 0;
	if(L <= m) ans += query(L, R, l, m, lson);
	if(R > m) ans += query(L, R, m + 1, r, rson);
	return ans;
}

signed main() {
	n = read(), m = read();
	build(1, n, 1);
	for(int i = 1; i <= m; i++) {
		int opt = read(), x = read(), y = read();
		if(opt == 1) {
			int k = read();
			update(x, y, k, 1, n, 1);
		}
		if(opt == 2) cout << query(x, y, 1, n, 1) << '\n';
	}
	return 0;
}
```

---

## 作者：Erusel (赞：1)

线段树，一种可以支持区间查询和区间修改的数据结构。

他可以在O(nlogn)的时间内实现查询某个区间的最大值，最小值，……还有很多神奇的内容。

现在，就让我们走进线段树的神奇世界吧！

注：全篇线段树以维护区间和为例。

1.线段树的特点及原理

1）线段树节点x的左右儿子分别为2*x,2*x+1(如图)

2）线段树的每个节点代表一个区间，每个节点的区间由左右儿子组成。

其中最底层节点的区间为它本身（如图）

3）线段树可以对这些区间进行修改，维护。

![Segment Tree](https://cdn.luogu.com.cn/upload/pic/60174.png )

2.建树
 
1）线段树在建树时需要花费大量的空间，需要4*n的空间，否则会RE

因此，本篇采用一种省空间的方法

2)  线段树在建树时，从根节点开始往下递归，一旦遇到区间仅为一个数，为叶子节点（即l==r）则输入值，否则就左右儿子向下递归。

 
3)  简洁的建树代码

```
struct T{
    int l,r,mid,v;//l表示区间左端点，r表示区间右端点，v代表权值 
}t[400005];

void build(int root,int l,int r)
{
    int mid=(l+r)>>1;//求中间值 
    t[root].l=l,t[root].r=r,t[root].mid=mid;//保存 
    if(l==r)//如果访问到叶子节点 
    {
        t[root].v=read();//输入 
        return;
    }
    build(root<<1,l,mid);
    build(root<<1|1,mid+1,r);//递归左右儿子 
    t[root].v=t[root<<1].v+t[root<<1|1].v;//求值 
}//注:(l+r)>>1==(l+r)/2,root<<1==root*2,root<<1|1==root*2+1(对此不懂，右转位运算<<,>>,|(https://en.wikipedia.org/wiki/Operator_associativity或https://www.cnblogs.com/Robin20050901/articles/9869953.html))
```
 
3.修改
 
1）找到待修改点，并直接修改，再往上递归

2）代码

```

void add(int root,int x,int val)
{
    if(t[root].l==t[root].r)//找到节点
    {
        t[root].v+=val;
        return ;
    }
    if(x<=t[root].mid)add(root<<1,x,val);
    else add(root<<1|1,x,val);//左右递归
    t[root].v=t[root<<1].v+t[root<<1|1].v;//求值 
}
```

4.查询 

1）从根节点向下递归，如果找到整段区间，则返回

2）如果区间分成两段，则左右分别计算，返回总和

3）代码

```
int query(int root,int a,int b)
{
    int l=t[root].l,r=t[root].r,mid=t[root].mid;
    if(a==l&&b==r)return t[root].v;
    if(b<=mid)return query(root<<1,a,b);
    else if(a>mid)return query(root<<1|1,a,b);
    else return query(root<<1,a,mid)+query(root<<1|1,mid+1,b);    
}
```

---

学完了线段树的基础知识（建树，修改，查询等操作）后，来看看下面这题

[Link](https://www.luogu.org/problemnew/show/P3372)

读完这题，是不是有跃跃欲试的感觉？

1）查询区间和   简单

2）区间修改？？？ 

```
for(int i=l;i<=r;i++)add(1,i,val);
```

所以，智障的我就写出了这样的代码

然后，稳稳的TLE

我们来分析一下上述代码的时间复杂度

1. 查询操作 O(nlogn)

2. 区间修改 每一次单点修改O（n）,总共n次，O（nlogn）

100000*100000*log(100000)  TLE!!!

所以，这时候，我们需要——

懒标记

1.懒标记用途

懒标记的作用是，在区间修改的时候，我们在需要修改的区间放个标记，下次要用的时候再打开。

这样可以节省大量的时间，可以把区间修改的时间复杂度降至O(log(n）)

2.懒标记的实现

上述做法固然解决了区间修改的问题

但是——

我们要查询的时候怎么办，总不能

```
cout<<"I can't do it"<<endl;
```

我们需要——

把懒标记拆了

```
if(tree[root].l==l&&tree[root].r==r)// 找到区间
        return tree[root].val+tree[root].tag*(r-l+1);// 计算并返回答案
if(tree[root].tag)//如果有懒标记
{
    tree[root*2].tag+=tree[root].tag; 
    tree[root*2+1].tag+=tree[root].tag;//下传懒标记
    tree[root].val+=(tree[root].r-tree[root].l+1)*tree[root].tag;//计算答案
    tree[root].tag=0;//清空标记
}
```
 
这样，我们就完成了查询和清除懒标记的工作。

回过头谈谈修改

```
void add(int root,int l,int r,int val)
{
    if(tree[root].l==l&&tree[root].r==r)
    {
        tree[root].tag+=val;
        return;
    }
    tree[root].val+=(r-l+1)*val;
    if(tree[root].mid>=r)add(root*2,l,r,val);
    else if(tree[root].mid<l)add(root*2+1,l,r,val);
    else add(root*2,l,tree[root].mid,val),add(root*2+1,tree[root].mid+1,r,val);
}
```


找到区间放标记，回头再来查答案

---

## 作者：Zechariah (赞：1)

今天刚学了分块，在这里试了一下
```cpp
#include <bits/stdc++.h>
#define N 100000+100
using namespace std;
int n,blo,bl[N];
long long sum[N],atag[N],v[N];
void updata(int x,int y,long long data)
{
    for (int i=x;i<=min(y,bl[x]*blo);++i)v[i]+=data,sum[bl[x]]+=data;/*处理x所在的不完整的块*/
    if (bl[x]!=bl[y])
        for (int i=(bl[y]-1)*blo+1;i<=y;++i)
            v[i]+=data,sum[bl[y]]+=data;/*如果x与y不在同一个块，处理y所在的不完整的块*/
    for (int i=bl[x]+1;i<bl[y];++i)atag[i]+=data;/*处理x，y之间的整块*/
}
long long query(int x,int y)
{
//计算区间和，与updata的处理方法相同，先处理不完整块，再处理整块
    long long ans=0;
    for (int i=x;i<=min(bl[x]*blo,y);++i)ans+=v[i]+atag[bl[x]];
    if (bl[x]!=bl[y])
        for (int i=(bl[y]-1)*blo+1;i<=y;++i)
           ans+=v[i]+atag[bl[y]];
    for (int i=bl[x]+1;i<bl[y];++i)ans+=sum[i]+atag[i]*blo;
    return ans;
}
int main(void)
{
    int m;
    scanf("%d%d",&n,&m);
    blo=sqrt(n);//设有n个点，m个块，则复杂度为O(n/m)+O(n)，根据均值不等式，取根号n个块是最快的
    for (int i=1;i<=n;++i)bl[i]=(i-1)/blo+1;//i对应第bl[i]个块
    for (int i=1;i<=n;++i)
    {
        scanf("%lld",v+i);
        sum[bl[i]]+=v[i];//预处理第i个整块的和
    }
    for (int i=1;i<=m;++i)
    {
        int cz,a,b;
        scanf("%d%d%d",&cz,&a,&b);
        if (cz==2)printf("%lld\n",query(a,b));
        else
        {
            long long c;
            scanf("%lld",&c);
            updata(a,b,c);
        }
    }
    return 0;
}

```


---

## 作者：doge233 (赞：1)

可以用分块水过去，分块没有线段树好写QwQ

对于一个序列可以将其分为sqrt（n）块，每块都为sqrt（n）

分块的有点就是需要的空间很小且不需要递归，关键是好想。

分块可以维护的东西只要符合一个条件：如果知道某个区间【l,r】的信息可以O（1）的求出【l,r+1】【l，r-1】【l-1，r】【l+1，r】

这样的东西如果复杂度可以承受nsqrt（n）那么就可以大力分块写

自从学会了分块维护序列的题都是一顿乱搞，关键在于需要的内存小

对于一些开不下树状数组或者线段树的题可以考虑分块


```cpp
#include<cstdio>
#include<cstring>
#include<utility>
#include<algorithm>
#include<iostream>
#include<queue>
#include<stack>
#include<cmath>
#include<cstdlib>
#include<ctime>
using namespace std;
inline long long read()
{
    char ch='*';
    long long f=1;
    while(!isdigit(ch=getchar()))if(ch=='-') f=-1;
    long long num=ch-'0';
    while(isdigit(ch=getchar())) num=num*10+ch-'0';
    return num*f;
}
const int maxn=100005;
long long t[320];
long long block[320];
long long blockadd[320];
long long a[maxn];
long long n,m,l,r,x,k,op;
int main()
{
    n=read();
    m=read();
    int ave=(int) sqrt(n);
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
        block[i/ave]+=a[i];
    }
    int ans;
    while(m--)
    {
        op=read();l=read();r=read();
        ans=0;
        if(op==1)
        {    
            x=read();
            int ll=l/ave+1,rr=r/ave-1;
            if(ll+1>=rr)
            {
                for(int i=l;i<=r;i++)                
                    a[i]+=x,block[i/ave]+=x;                
                continue;
            }
            else{
                for(int i=ll;i<=rr;i++)
                {
                    block[i]+=ave*x;
                    blockadd[i]+=x;
                }
                if(l%ave==0 ) {
                    block[l/ave]+=ave*x;
                    blockadd[l/ave]+=x;
                }
                else 
                for(int i=l;i%ave!=0;i++)
                    a[i]+=x,block[l/ave]+=x;
                if(r%ave==ave-1)
                block[r/ave]+=ave*x,blockadd[r/ave]+=x;
                else    for(int i=r;i%ave!=ave-1;i--)a[i]+=x,block[i/ave]+=x;                
            }                
        }
        else{
            int ll=l/ave+1,rr=r/ave-1;
            if(ll+1>=rr)
            {
                for(int i=l;i<=r;i++)ans+=a[i]+blockadd[i/ave];
                printf("%d\n",ans);
                continue;
            }
            else{
                for(int i=ll;i<=rr;i++)    ans+=block[i];
                if(l%ave==0 )     ans+=block[l/ave];                
                else     for(int i=l;i%ave!=0;i++)    ans+=blockadd[i/ave]+a[i];
                if(r%ave==ave-1)    ans+=block[r/ave];
                else    for(int i=r;i%ave!=ave-1;i--)ans+=a[i]+blockadd[i/ave];
                printf("%d\n",ans);
            }            
        }                
    }
}

```

---

## 作者：sun615 (赞：1)

###整理搬运自`NotOnlySuccess`

dalao一口气写了好多片代码

我就找了一片合适的

加上注释就发来啦

###不仅跑得快，而且空间小

#注意三点：

###lazy tag总是向下的，对当前节点无效

###sum数组就是线段树，下标是按照二叉树来的

###每个节点的信息都是由上一个节点推得并向下传递，所以起始和传递时一定不要出错

```cpp
/***********************
-NotOnlySuccess飘逸写法-
----区间增减，区间查询----
***********************/
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ls l,m,rt<<1//表示的范围及节点编号
#define rs m+1,r,rt<<1|1
#define maxn 100009
#define LL long long
using namespace std;
LL sum[maxn<<2];////线段树节点*4
LL add[maxn<<2];
void getup(int rt){
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}//用子节点信息更新当前节点（rt，父节点）
void build(int l,int r,int rt){
    add[rt]=0;
    if (l==r) {
        scanf("%lld",&sum[rt]);////rt是这个长度为1的节点的编号
        return;                 //而l，r是其表示的范围
    }
    int m=(l+r)>>1;
    build (ls);
    build (rs);
    getup(rt);
    return;
}
void pushdown(int rt,int len){
    if (add[rt]){
        add[rt<<1]+=add[rt];
        add[rt<<1|1]+=add[rt];
        sum[rt<<1]+=add[rt]*(len-(len>>1));//add*左区间长
        sum[rt<<1|1]+=add[rt]*(len>>1);//add*右区间长
        add[rt]=0;
    }
}//标记下放无需递归：：能覆盖父区间的标记必然能覆盖子区间
void update(int L,int R,int c,int l,int r,int rt){
    if (L<=l&&r<=R){
        add[rt]+=c;
        sum[rt]+=(LL)c*(r-l+1);//保证了add只对下一节点有效
        return;                 //当前节点已经更新
    }
    pushdown(rt,r-l+1);
    int m=(l+r)>>1;
    if (L<=m) update(L,R,c,ls);
    if (m+1<=R) update(L,R,c,rs);  
    getup(rt);
    
}
LL query(int L,int R,int l,int r,int rt){
    if (L<=l&&r<=R){
        return sum[rt];
    } 
    pushdown(rt,r-l+1);
    LL tot=0;
    int m=(l+r)>>1;
    if (L<=m) tot+=query(L,R,ls);
    if (m+1<=R) tot+=query(L,R,rs);
    return tot;
}

int main(){
    int n,m;
    cin>>n>>m;
    build(1,n,1);
    int Q,a,b,c;
    for (int i=1;i<=m;i++){
        scanf("%d",&Q);
        if(Q==1){
            scanf("%d%d%d",&a,&b,&c);
            update(a,b,c,1,n,1);
            continue;
        }
        if(Q==2){
            scanf("%d%d",&a,&b);
            printf("%lld\n",query(a,b,1,n,1));
            continue;
        }
    }
    system("pause");
    return 0;
}
```

---

## 作者：合451518 (赞：1)

标准的线段树模板题——区间更新。


#主程序——简单判断

每次读入第一个数，若是1更新，若是2直接输出。（不讲了）


#关键问题——五个函数


##up(int p)

这个函数主要用于更新当前节点p的值。

节点p的子节点为2p和2p+1.


s[p]=s[2p]+s[2p+1]

##down(int p, int l, int r)

首先，储存节点p的值的s[p]指a[l]+...+a[r]的数字和。

这个函数用于传递add[]数组的量。

由于是区间更新，我们不能像单点更新一样一个一个更新，而是要利用add[]来存放更新的量。

这个函数1. 下传add[p]: add[2p]+=add[p];add[2p+1]+=add[p];

2. 修改子节点2p,2p+1的值：s[2p]+=(m-l+1)add[p];s[2p+1]=(r-m)add[p];

其中m=(l+r) div 2;

这里注意一下：add[p]指l-r这个区间当中：任意add[i]都应该加add[p].其中l<=i<=r.

所以我们在更新节点时，还要用add[p]乘以它区间的长度，也就是s[2p]=(m-l+1)\*add[p]了。

最后将add[p]=0;


##build(int p, int l, int r)

p,l,r的意思同上。

从p开始建树。

当l==r时：到了叶子节点，读入其值。

注意：应在开始之前：add[p]=0（“洗碗”操作——归零)

然后定义m=(l+r)/2;分成两路更新，最后up(p);


##update(int p, int l, int r, int x, int y, int v)

p,l,r意思同上，x,y,v表示[x,y]之间的每一个点都需要+v.

注意：add[p]不需要着急传下去，我们在查询query时也会下传。

1. 当x<=l and r<=y 时，说明[l,r]区间 包含于[x,y]中，可以直接更新。

所以：add[p]+=v;s[p]+=(r-l+1)v;return;

2. 正常更新。因为这是区间更新，我们要像线段树点更新中的查询一样，分成两路进行更新。

if x<=m then update(...) //更新2\*p节点

if m<y then update(...) //更新2p+1节点

这样做是因为有可能出现x<=m<=y的情况。[x,y]被m分开，所以分子节点更新。

注意：在**更新前**应先下传add:down(p,l,r).

防止信息留在p的父节点p/2上。

最后更新up(p);


##query(int p, int l, int r, int x, int y)

查询[x,y]区间和。

1. if x<= l && r<=y return s[p];

如果[l,r]包含于[x,y]，可以直接实用[l,r]区间的数字和，直接返回。

2. 分成两路查询。

在查询之前，应再次down(p,l,r)，理由同update.

然后定义m=(l+r)/2;

if x<=m ret+=query... //获得对于2\*p及其子节点进行查询的值

if m<y ret+=query... //获得对2p+1及其子节点进行查询的值

最后返回ret.


注意：

1. 数可能很大，数组定义为long long类型（pascal中的int64);

2. 一定要在update和query中down(p,l,r),及时下传add[p]。


下面给完整代码：


```cpp
//Luogu 3372
#include<iostream>
#include<cstdio>
using namespace std;

const int MAXN=100000;

int n, q;
long long add[4*MAXN+10], s[4*MAXN+10];

void up(int p)
{
    s[p]=s[2*p]+s[2*p+1];
    return;
}

void down(int p, int l, int r)
{
    if (add[p]) {
        add[2*p]+=add[p];
        add[2*p+1]+=add[p];
        int m=(l+r)/2;
        s[2*p]+=(m-l+1)*add[p];
        s[2*p+1]+=(r-m)*add[p];
        add[p]=0;
    }
    return;
}

void build(int p, int l, int r)
{
    add[p]=0;
    if (l==r) {
        scanf("%d",&s[p]);
        return;
    }

    int m=(l+r)/2;
    build(2*p, l, m);
    build(2*p+1, m+1, r);
    up(p);
    return;
}

void update(int p, int l, int r, int x, int y, int v)
{
    if (x<=l && r<=y) {
        add[p]+=v;
        s[p]+=(r-l+1)*v;
        return;
    }

    down(p, l, r);
    int m=(l+r)/2;
    if (x<=m) update(2*p, l, m, x, y, v);
    if (m<y) update(2*p+1, m+1, r, x, y, v);
    up(p);
    return;
}

long long query(int p, int l, int r, int x, int y)
{
    if (x<=l && r<=y) {
        return s[p];
    }

    down(p, l, r);
    int m=(l+r)/2;
    long long ret=0;
    if (x<=m) ret+=query(2*p, l, m, x, y);
    if (m<y) ret+=query(2*p+1, m+1, r, x, y);
    return ret;
}

int main()
{
    cin >> n >> q;
    build(1,1,n);
    for (int i=1; i<=q; i++) {
        int tmp, a, b, x;
        scanf("%d",&tmp);
        if (tmp==1) {
            scanf("%d%d%d",&a,&b,&x);
            update(1, 1, n, a, b, x);
        }
            else {
                scanf("%d%d",&a,&b);
                cout << query(1, 1, n, a, b) << endl;
            }
    }
    return 0;
}
```

---

## 作者：BLMontgomery (赞：1)

**线段树区间修改与查询**

我用的是一种奇葩的建树方式，因此树的最大节点数为不小于n的2的幂次方

对于每次的区间加法，对当前节点加上add标记，并维护信息

查询就只需计算某节点上的sum(区间和)加上add乘以区间长度即可

详情在代码中都有说明，我跑了900ms在线段树中还算快的，如果用读入优化的话会更快些

注意优化常数,如我用了很多位运算：( i\*2=i<<1) ; (i\*2+1=i<<1|1)





    
    
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
typedef long long ll;
ll a[140000],k;
int x,y;
ll sumv[300000],addv[300010];
ll _sum;
void maintain(int o,int l,int r)//维护该节点信息 
{
    int lc=(o<<1),rc=(o<<1|1);
    if(l<r)
    {
        sumv[o]=sumv[lc]+sumv[rc];//若不是叶节点重新计算当前节点的sum
    }
    if(l==r)
    {
        sumv[o]+=k;
        //若是叶节点就不会计算上述重新计算,故进行下面的操作会把曾经加过的add再加
    }
    else
    {
        sumv[o]+=addv[o]*(ll)(r-l+1);//注意要乘以(r-l+1)因为区间长度为这么多 
        //不是叶节点重新计算后再加当前节点的曾经所有的add
    }
}
void update(int o,int l,int r)//修改节点信息 
{
    int lc=(o<<1),rc=(o<<1|1);
    if(x<=l&&r<=y)//若当前update的区间已经在要修改的区间[x,y]内了 
    {
        addv[o]+=k;
    }
    else
    {//puts("lalala");
        int m=l+(r-l)/2;
        if(x<=m) update(lc,l,m);
        if(y>m) update(rc,m+1,r);
    }
    maintain(o,l,r);
}
void query(int o,int l,int r,int add)//查询操作 
{
    if(x<=l&&r<=y)//若当前query的区间已经在要查询的区间[x,y]内了 
    {
        _sum+=sumv[o]+add*(ll)(r-l+1);
    }
    else
    {
        int m=l+(r-l)/2;
        if(x<=m) query(o*2,l,m,add+addv[o]);
        if(y>m) query(o*2+1,m+1,r,add+addv[o]);
    }
}
int main()
{
    int i,j,m,n,r,h,g,h0;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;++i) scanf("%lld",&a[i]);
    memset(addv,0,sizeof(addv));//节点的标记也就是这个节点目前加上了多少值
    //build(1,1,n);//递归建树见底下
    h=log(n)/log(2)+0.9999;//树的深度，从0层开始 
    g=(1<<(h+1))-1;//最后一个节点的编号 
    for(i=(1<<h);i<=g;++i)//自下向上递推建树，这样个人认为更易理解些，它是个满二叉树
    {
        sumv[i]=a[i-(1<<h)+1];
    }
    for(i=(1<<h)-1;i>=1;--i)
    {
        sumv[i]=sumv[i<<1]+sumv[i<<1|1];
```
}//到此为止树已经建完了
    
```cpp
    for(i=1;i<=m;++i)
    {
        scanf("%d",&r);
        if(r==1)
        {
            scanf("%d%d%lld",&x,&y,&k);
            update(1,1,(1<<h));
        }
        if(r==2)
        {
            scanf("%d%d",&x,&y);
            query(1,1,(1<<h),0);//注意从1到1<<h才是我的线段树长度为一的那些区间 
            printf("%lld\n",_sum);
            _sum=0;
        }
    }
    return 0;
}
/*void build(int h,int l,int r)//另一种递归建树方式
{
    if(l==r)
    {
        sumv[h]=a[l];
        return;
    }
    int mid=l+r>>1;
    build(h<<1,l,mid);
    build(h<<1|1,mid+1,r);
    sumv[h]=sumv[h<<1]+sumv[h<<1|1];
}*/
```

---

## 作者：巨型方块 (赞：1)

首先，这是线段树，而且不是最基本的线段树。

所以你想做这题，那先要学会

1.单点增加x，区间求和

2.区间增加x，单点求和

以上两个才是基本的线段树，你应在前两题的基础上做

另外再说一些小细节，我学习了线段树后，用了正确的思想，打了代码，却70分

后来看题解才知道要开long long 。。。。。

但是开了之后还是70........看看输出了负数，想必是爆变量了，但我开long long了啊

后来发现我用printf输出时没写long long的格式............

%I64d是windows  %lld是linux

c++语法好深奥啊

------------------------------------------------------------------------------

对于这道题目，区间增加，区间求和，用普通的方法那显然是超时的

普通的方法就是在区间增加时，大到1~n区间，小到一个点，都加上x

这样的话，输出区间和时与基本线段树1时一样的，但时在区间增加时会超时

因为基本线段树1 单点加值，我们只要把和那个点有关的区间加值就可以了

而区间加时要把和那个区间有关的区间全部价值，不然不配合输出

超时了就要优化。

你想啊，虽然x~y区间要增加一个值，难道这个区间就一定要用吗？

如果区间值增加了但后来没有询问，我们一开始为什么要增加呢？

正如背古文，如果考试不考，我们为什么要背呢？

所以lazy思想就怎么产生了。

lazy，就是懒嘛，就是先不被古文，等到考试要考了再去背嘛；

先不增加区间，等到询问时在去增加嘛；


我们可以搞一个v数组，专门把编号为num的区间要加的值记录下来

如果要用了，再给线段树num加上v[num]的值，再把v[num]传给v[num\*2]和v[num\*2+1];然后v[num]清零

“如果要用了”这一步用一个clean函数实现


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#define LL long long
using namespace std;
struct cs{
    LL ll,rr,vv;
}T[824290];
LL a[200005],v[824290];
LL n,m,x,y,z,sum,N;
void clean(LL x){
    if(!v[x])return;v[x]为0不用搞 
    T[x].vv+=(T[x].rr-T[x].ll+1)*v[x];整个区间加值 
    if(T[x].ll!=T[x].rr){
        v[x*2]+=v[x];把v[x]传给子数，因为整个区间都要加，那么它子树的整个区间肯定要加 
        v[x*2+1]+=v[x];
    }
    v[x]=0;加完了，下次不用加了 
}
void maketree(LL x,LL y,LL num){
    T[num].ll=x;
    T[num].rr=y;
    if(x==y){
        T[num].vv=a[x]; return;
    }
    maketree(x,(x+y)/2,num*2);
    maketree((x+y)/2+1,y,num*2+1);
    T[num].vv=T[num*2].vv+T[num*2+1].vv;
}
void inc(LL x,LL y,LL z,LL num){
    clean(num);如果要用T[num]了，先clean一下 
    if(x<=T[num].ll&&T[num].rr<=y){如果整个区间都要加的话，那先存下来 
        v[num]+=z; return;
    }
    T[num].vv+=(min(y,T[num].rr)-max(x,T[num].ll)+1)*z;只是区间的一部分要加的话，那只能先加一部分 
    if(T[num].ll==T[num].rr) return;
    int mid=(T[num].ll+T[num].rr)/2;
    if(x>mid)inc(x,y,z,num*2+1);else
    if(y<=mid)inc(x,y,z,num*2);else{
        inc(x,y,z,num*2);
        inc(x,y,z,num*2+1);
    }
}
void out(int LL,int LL,LL num){
    clean(num);如果要用T[num]了，先clean一下 
    if(x<=T[num].ll&&T[num].rr<=y){
        sum+=T[num].vv; return;
    }
    int mid=(T[num].ll+T[num].rr)/2;
    if(x>mid)out(x,y,num*2+1);else
    if(y<=mid)out(x,y,num*2);else{
        out(x,y,num*2);
        out(x,y,num*2+1);
    }
}
int main()
{
    scanf("%d%d",&n,&N);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    maketree(1,n,1);
    for(int i=1;i<=N;i++){
        scanf("%d%d%d",&m,&x,&y);
        if(m==1){
            scanf("%d",&z);
            inc(x,y,z,1);
        }
        else{
            sum=0;
            out(x,y,1);
            printf("%lld\n",sum);//用cout输出什么事都没有 
        }
    }
}
```
我们再来讨论讨论关于数组的问题
首先线段树是一个类似与满二叉树的图

读入n个数，这棵树子节点必然是n个

而数组大小就是整个树的节点个数

所以我们只要找到一个k

用k去搞一个满二叉树

使2^k>=n;

学过二叉树的同学都知道，满二叉树叶节点是m个，节点是m\*2-1个

所以数组开2^k\*2就好了

如n=100000

2^17=131072

所以数组开到131072\*2=262144就好了

欢迎讨论


---

## 作者：塔罗兰 (赞：1)

终于学会线段树辣！

虽然已经有很多巨佬已经发了题解，但是他们太强了所以不屑于讲人话，由我来翻译一遍

友情提示:这题爆long long

lazytag：tag记录的是此节点所代表的区间需要修改的一个值（这题是加）

举个栗子（真香）：[2,8]这个区间被+x,于是我们在节点2（自己是自己的最近公共祖先）对应的tag上记录x，在3和4的父节点（最近公共祖先是父节点）对应的tag上也记录x，然后在5678的最近公共祖先上的tag也记录x

因为线段树是从根节点开始遍历的，所以直接暴力遍历就好了，不需要求最近公共祖先祖先

线段树的优化就在于它不像暴力那样每次把区间所有节点都修改，用二分只修改需要修改的（比如我查询时只需要查几个长度2^n的区间的和，我干嘛要加每一个节点？需要时再继续向下遍历修改就好了），所以快了一个log。

具体见代码
```cpp
#include<bits/stdc++.h>
#define MAXN 1000005
#define MAXM 4000005
using namespace std;
int a[MAXN],ans[MAXM],tag[MAXM];
void build(int p,int l,int r)
{
	if(l==r)
	{
		ans[p]=a[l];
		return;
	}
	int mid(l+r>>1);
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	ans[p]=ans[p<<1]+ans[p<<1|1];
} 
inline void f(int p,int l,int r,int num)
{
	tag[p]=tag[p]+num;
	ans[p]=ans[p]+num*(r-l+1);
}
int k,b,c;
inline void update(int l,int r,int p)
{
	if(b<=l&&r<=c)
	{
		ans[p]+=k*(r-l+1);
		tag[p]+=k;
		return;
	}
	int mid(l+r>>1);
	f(p<<1,l,mid,tag[p]);
	f(p<<1|1,mid+1,r,tag[p]);
	tag[p]=0;
	if(b<=mid)
	update(l,mid,p<<1);
	if(c>mid)
	update(mid+1,r,p<<1|1);
	ans[p]=ans[p<<1]+ans[p<<1|1];
}
int query(int l,int r,int p)
{
	int res(0);
	if(b<=l&&r<=c)
	return ans[p];
	int mid(l+r>>1);
	f(p<<1,l,mid,tag[p]);
	f(p<<1|1,mid+1,r,tag[p]);
	tag[p]=0;
	if(b<=mid)
	res+=query(l,mid,p<<1);
	if(c>mid)
	res+=query(mid+1,r,p<<1|1);
	return res;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i(1);i<=n;++i)
	scanf("%intd",&a[i]);
	build(1,1,n);
	for(int i(1);i<=m;++i)
	{
		int a1;
		scanf("%d",&a1);
		if(a1&1)
		{
			scanf("%d%d%d",&b,&c,&k);
			update(1,n,1);
		}
		else
		{
			scanf("%d%d",&b,&c);
			printf("%d\n",query(1,n,1));
		}
	}
}
```
~~反正前面巨佬代码都有了，就偷懒不写代码注释了~~

结合前面的内容应该能看懂吧？

---

## 作者：z7z_Eta (赞：1)

### 线段树 1

维护 区间加 和 区间求和 的操作，就让我们选择~~简单的~~**树状数组**来做这道题吧（建树$O(n)$，查询$O(n\log n)$）。



对于**超级树状数组**，设$d_i$为差分数组，利用下面的公式查询1到$n$的前缀和：

​    $\sum_{i=1}^{n}(n-i+1)*d_i$

$=\sum_{i=1}^{n}(n+1)*d_i-\sum_{i=1}^{n}d_i*i$

其他题解已经有了详细讲解，这里不再赘述。

代码如下：(指针)

```cpp
#define ll long long
#define il inline
enum{N=100023};

ll tr[N],tri[N];//(d[],d[]*i)的树状数组

il int lowbit(int x){return x&-x;}
//传入数组指针
il void add_(ll *tr,register int i,ll k){
    for(;i<=n;i+=lowbit(i)) tr[i]+= k;
}
il ll query_(ll* tr,register int i){
    register ll ans= 0;
    for(;i;i-=lowbit(i)) ans+= tr[i];
    return ans;
}
//区间加，查询操作
il void add(int l,int r,ll k){
    add_(tr,l,k);
    add_(tr,r+1,-k);
    add_(tri,l,l*k);
    add_(tri,r+1,-k*(r+1));
}
il ll query(int l,int r){
    return
        (r+1)*query_(tr,r)-
        query_(tri,r)-
        (l*query_(tr,l-1)-
        query_(tri,l-1));
}
```

这样我们就可以在极快的时间中完成这道题了。

但是比较于**线段树**的$O(n)$建树，树状数组的建树就显得相对不优美。

然后我就yy出来了一个$O(n)$建树的方法。

出于~~美化~~ 卡常 的目的，这里用**前缀和**的思想来实现**树状数组**的$O(n)$建树。（通用于所有树状数组）

- 用$a_x$表示原数组，同时$a_x$也是差分数组$d_i$的前缀和；

- 根据树状数组的定义，$tr_x$就等于$a_x-a_{x-lowbit(x)}$

- 类似的，用$ai_x$表示差分数组$d_i*i$的前缀和，即

  $ai_x= \sum_{i=1}^{x}d_i*i=ai_{x-1}+d_i*i$

- 那么$tri_x= ai_x-ai_{x-lowbit(x)}$

代码如下：

```cpp
il int read();//快读
ll a[N],ai[N];
il void build(){
    n= read();
    for(register int i=1;i<=n;i++){
        a[i]= read();
        ai[i]= ai[i-1]+(a[i]-a[i-1])*i;
        tr[i]= a[i]-a[i-lowbit(i)];
        tri[i]= ai[i]-ai[i-lowbit(i)];
    }
}
```

diss纪念。

*$tim:90ms\text{ luogu-o2}$



---

## 作者：quotient_0 (赞：1)

# 【模板】线段树 1
## 线段树
线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。**使用线段树可以快速的查找某一个节点在若干条线段中出现的次数**,_时间复杂度为 **O(logN)**_ 。而未优化的 _空间复杂度为 **2N**_ ，实际应用时一般还**要开4N的数组以免越界**，因此有时需要离散化让空间压缩。

线段树是建立在线段的基础上，**每个结点都代表了一条线段[a,b]**。长度为1的线段称为元线段。非元线段都有两个子结点，**左结点代表的线段为[a,(a + b) / 2]，右结点代表的线段为[((a + b) / 2）+1,b]**。


下图就是一棵长度范围为[1,10]的线段树。**长度范围为[1,L] 的一棵线段树的深度为log (L) + 1**。这个显然，而且存储一棵线段树的空间复杂度为O(L）。线段树支持最基本的操作为插入和删除一条线段。

下面以插入为例，详细叙述，删除类似。**将一条线段[a,b] 插入到代表线段[l,r]的结点p中，如果p不是元线段，那么令mid=（l+r）/2。如果b<mid，那么将线段[a,b] 也插入到p的左儿子结点中，如果a>mid，那么将线段[a,b] 也插入到p的右儿子结点中。插入（删除）操作的时间复杂度为O（logn）。**

![线段树](https://baike.baidu.com/pic/线段树/10983506/0/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09?fr=lemma&ct=single#aid=0&pic=bd3eb13533fa828bcb5fe85ffe1f4134970a5a09)

------------

## 思路简析
### 首先，我们要将线段转化成一棵树的形式。
对于第一次接触线段树的本蒟蒻来说，这就需要一点~~努~~(zhi)~~力~~(shang)了。
```cpp
int buildtree(int o,int l,int r)//根，左节点，右节点
{
	if(l==r)
	{
		tr[o]=c[l];
		return 0;
	}
	int mid=(l+r)>>1/* (l+r)/2 */;
	buildtree(o<<1/* o/2 */,l,mid);
	buildtree(o<<1|1/* o/2+1 */,mid+1,r);
	pushup(o);
}
```
### 树建起来以后，要能将数据传入和传出
这就需要用到下面的三个核心函数：** _pushup、pudown_ **和** _update_ **了
```cpp
int pushup(int o)
{
	tr[o]=tr[o<<1]+tr[o<<1|1];
}
```
```cpp
int pushdown(int o,int r,int l)
{
	int mid=(l+r)>>1;
	Plus[o]=0;
	Plus[o<<1]+=Plus[o];
	Plus[o<<1|1]+=Plus[o];
	tr[o<<1]+=Plus[o]+(mid-l+1);
	tr[o<<1|1]+=Plus[o<<1|1]*(r-mid);
}
```
```cpp
int update(int o,int l,int r,int x,int y,int v)
{
	if(x<=l&&y>=r)
	{
		Plus[o]+=v;
		tr[o]+=v*(r-l+1);
		return 0;
	}
	pushdown(o,l,r);
	int mid(l+r)>>1;
	if(x<=mid)
	{
		update(o<<1,l,mid,x,y,v);
	}
	if(y>=mid)
	{
		update(o<<1|1,mid+1,r,x,y,v);
	}
	pushup(o);
}
```
### 我们还需要计算解
这需要用到一个嵌套型的函数用来统计数据并传出
```cpp
int query(int o,int l,int r,int x,int y)
{
	if(x<=l&&y>=r)
	{
		return tr[o];
	}
	pushdown(o,l,r);
	int ans=0;
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		ans+=query(o<<1,l,mid,x,y);
	}
	if(y>mid)
	{
		ans+=query(o<<1|1,mid,r,x,y);
	}
	return ans;
}
```

------------

我们的主要结构也就完成了，AC代码奉上
```cpp
#include <bits/stdc++.h>
using namespace std;
int tr[100010<<2],Plus[100010<<2],a[100010];
long long pushup(long long o)
{
    tr[o]=tr[o<<1]+tr[o<<1|1];
}
long long build(long long o, long long l, long long r)
{
    if(l==r)
    {
        tr[o]=a[l];
        return 0;
    }
    long long mid=(l+r)>>1;
    build(o<<1,l,mid);
    build(o<<1|1,mid+1,r);
    pushup(o);
}
long long pushdown(long long o,long long l, long long r)
{
    if(Plus[o]==0)
	{
		return 0;
	}
    long long mid=(l+r)>>1;
    tr[o<<1]+=(mid-l+1)*Plus[o];
    tr[o<<1|1]+=(r-mid)*Plus[o];
    Plus[o<<1]+=Plus[o];
    Plus[o<<1|1]+=Plus[o];
    Plus[o]=0;
}
long long update(long long o, long long l,long long r,long long x,long long y, long long pl)
{
    if(x<=l&&y>=r)
    {
        tr[o]+=(r-l+1)*pl;
        Plus[o]+=pl;
        return 0;
    }
    pushdown(o,l,r);
    long long mid=(l+r)>>1;
    if(x<=mid)
	{
		update(o<<1,l,mid,x,y,pl);
	}
    if(y>mid)
	{
		update(o<<1|1,mid+1,r,x,y,pl);
	}
    pushup(o);
}
long long query(long long o,long long l,long long r,long long x,long long y)
{
    if(x<=l&&y>=r)
    {
        return tr[o];
    }
    pushdown(o,l,r);
    long long ans=0;
    long long mid=(l+r)>>1;
    if(x<=mid)
	{
		ans+=query(o<<1,l,mid,x,y);
	}
    if(y>mid)
	{
		ans+=query(o<<1|1,mid+1,r,x,y);
	}
    return ans; 
}
int main()
{
    long long n,m,b,c,d,i,x;
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    build(1,1,n);
    for(i=1;i<=m;i++)
    {
        scanf("%lld",&x);
        if(x==1)
        {
            scanf("%lld%lld%lld",&b,&c,&d);
            update(1,1,n,b,c,d);
        }
		else
        {
            scanf("%lld%lld",&b,&c);
            printf("%lld\n",query(1,1,n,b,c));
        }
    }
    return 0;
} 
```

---

## 作者：土间太平 (赞：1)

### 什么？一道51篇题解的模板题居然只有三篇pascal，我P党表示不服！

# 解法：正宗线段树（区间更新&区间查询）

详解：

那么对于区间操作，我们考虑引入一个名叫“ lazy tag ”（懒标记）的东西——之所以称其“ lazy”，是因为原本区间修改需要通过先改变叶子节点的值，然后不断地向上递归修改祖先节点直至到达根节点，时间复杂度最高可以到达 O(nlogn) 的级别。但当我们引入了懒标记之后，区间更新的期望复杂度就降到了 O(logn) 的级别且甚至会更低.

那么我们可以先将其拆分成线段树上节点所示的区间，之后分开处理：
如果单个元素被包含就只改变自己，如果整个区间被包含就修改整个区间
成段更新(通常这对初学者来说是一道坎),需要用到懒惰标记,简单来说就是每次更新的时候不要更新到底,用延迟标记使得更新延迟到下次需要更新or询问到的时候，降低时间复杂度


个人认为我的代码还是挺好看的

```pascal
//注意！这里一定要开INT64，被坑了好几次！！！
var a:array[1..100005]of int64;
    sum,lazy:array[1..400005]of int64;
    n,m,i,b,x,y,z:int64;
procedure pushup(rt:int64);//子节点更新，父节点也要更新
begin
 sum[rt]:=sum[rt shl 1]+sum[(rt shl 1)or 1];
end;
procedure build(l,r,rt:int64);//基础的建树
var mid:int64;
begin
 if l=r then
  begin
   sum[rt]:=a[l];
   exit;
  end;
 mid:=(l+r) shr 1;
 build(l,mid,rt shl 1);
 build(mid+1,r,(rt shl 1)or 1);
 pushup(rt);
end;
procedure pushdown(rt,ln,rn:int64);//懒标记的下放
begin
 if(lazy[rt]<>0)then
  begin
   lazy[rt shl 1]:=lazy[rt shl 1]+lazy[rt];
   lazy[(rt shl 1)or 1]:=lazy[(rt shl 1)or 1]+lazy[rt];
   sum[rt shl 1]:=sum[rt shl 1]+lazy[rt]*ln;
   sum[(rt shl 1)or 1]:=sum[(rt shl 1) or 1]+lazy[rt]*rn;
   lazy[rt]:=0;
  end;
end;
procedure update(x,y,c,l,r,rt:int64);//区间更新
var mid:int64;
begin
 if(x<=l)and(r<=y)then
  begin
   sum[rt]:=sum[rt]+c*(r-l+1);
   lazy[rt]:=lazy[rt]+c;
   exit;
  end;
 mid:=(l+r) shr 1;
 pushdown(rt,mid-l+1,r-mid);
 if x<=mid then update(x,y,c,l,mid,rt shl 1);
 if y>mid then update(x,y,c,mid+1,r,(rt shl 1)or 1);
 pushup(rt);
end;
function query(x,y,l,r,rt:int64):int64;//查询函数
var mid,ans:int64;
begin
 if (x<=l)and(r<=y) then exit(sum[rt]);
 ans:=0;
 mid:=(l+r) shr 1;
 pushdown(rt,mid-l+1,r-mid);
 if (x<=mid) then ans:=ans+query(x,y,l,mid,rt shl 1);
 if (y>mid) then ans:=ans+query(x,y,mid+1,r,(rt shl 1)or 1);
 exit(ans);
 //这里的shr,shl,or 都是位运算，相当于div 2,*2,+1
end;
begin
 readln(n,m);
 for i:=1 to n do
  read(a[i]);
 build(1,n,1);
 for i:=1 to m do
  begin
   read(b);
   if b=1 then
    begin
     readln(x,y,z);
     update(x,y,z,1,n,1);
    end
   else
    begin
     read(x,y);
     writeln(query(x,y,1,n,1));
    end;
  end;
end.
```
部分内容摘抄自网络&码字累，求通过


---

## 作者：wwwwxb (赞：1)

大家都用c++发题解，那本蒟蒻就来发一个Pascal的题解吧

很裸的线段树板子


```cpp
 type
  node=record
    l,r:longint;tag,num:int64;
  end;
var
  a:array[1..110000] of int64;
  f:array[1..550000] of node;
  n,m,i,x,y,delta:longint;
PROCEDURE update(n:longint);
  begin
    inc(f[n*2].tag,f[n].tag);
    inc(f[n*2+1].tag,f[n].tag);
    inc(f[n*2].num,(f[n*2].r-f[n*2].l+1)*f[n].tag);
    inc(f[n*2+1].num,(f[n*2+1].r-f[n*2+1].l+1)*f[n].tag);
    f[n].tag:=0;
  end;
procedure build(n,l,r:longint);
  begin
    f[n].l:=l;f[n].r:=r;
    if l=r then begin f[n].num:=a[l];exit; end;
    build(n*2,l,(l+r) div 2);
    build(n*2+1,(l+r) div 2+1,r);
    f[n].num:=f[n*2].num+f[n*2+1].num;
  end;
procedure change(n,l,r,delta:longint);
  begin
    if (f[n].l>=l) and (f[n].r<=r)
      then
        begin
          inc(f[n].tag,delta);
          inc(f[n].num,(f[n].r-f[n].l+1)*delta);
          exit;
        end;
    if (f[n].tag<>0) then update(n);
    if (f[n*2].r>=l) then change(n*2,l,r,delta);
    if (f[n*2+1].l<=r) then change(n*2+1,l,r,delta);
    f[n].num:=f[n*2].num+f[n*2+1].num;
  end;
function cal(n,l,r:longint):int64;
  begin
    if (f[n].l>=l) and (f[n].r<=r) then exit(f[n].num);
    if f[n].tag<>0 then update(n);
    cal:=0;
    if f[n*2].r>=l then inc(cal,cal(n*2,l,r));
    if f[n*2+1].l<=r then inc(cal,cal(n*2+1,l,r));
  end;
begin
  readln(n,m);
  fillchar(a,sizeof(a),0);
  fillchar(f,sizeof(f),0);
  for i:=1 to n do read(a[i]);
  build(1,1,n);
  for i:=1 to m do
    begin
      read(x);
      if x=1
        then begin readln(x,y,delta);change(1,x,y,delta);  end
        else begin readln(x,y);writeln(cal(1,x,y)); end;
    end;
end.
end.

```

---

## 作者：smd1121 (赞：1)

这个题解直接复制会WA的哦（毕竟连输出都没写）【手动滑稽】

注释很清楚（自认为），看懂了自己改


```cpp
#include<iostream>
#include<cstdio>

#define MAXN 500005

using namespace std;

int a[MAXN],n;

struct node
{
    long long Left,Right,Value;                        //分别存储左端点、右端点和区间值 
    long long Lazy_tag;                            //懒标记 
}Tree[MAXN*4];                                    //声明一棵线段树  开四倍内存 

inline void Lazy_tag_pushdown(int root)                //懒标记下传
{
    Tree[root<<1].Lazy_tag+=Tree[root].Lazy_tag;        //root<<1 等效于 root*2
    Tree[root<<1|1].Lazy_tag+=Tree[root].Lazy_tag;        //a|1 等效于 a%2?a:a+1
                                            //此处可直接理解为root*2+1 
    Tree[root<<1].Value+=Tree[root].Lazy_tag*(Tree[root<<1].Right-Tree[root<<1].Left+1);
    Tree[root<<1|1].Value+=Tree[root].Lazy_tag*(Tree[root<<1|1].Right-Tree[root<<1|1].Left+1);
                                            //当前区间加上懒惰标记时应该加的是Lazy_tag*区间长度
    Tree[root].Lazy_tag=0;                        //已经下传过了，清零懒标记 
}

inline void build_tree(int l,int r,int root)            //建立线段树 主函数引用build_tree(1,n,1); 
{                                    //该（子）树以l为左端点，r为右端点，root为根节点 
    int mid=(l+r)>>1;                    //位运算节省时间 等效于 (l+r)/2 
    Tree[root].Left=l;
    Tree[root].Right=r;                    //记录区间范围
    Tree[root].Lazy_tag=0;                //懒标记初始化为0 
    if(l==r)                            //如果到达底端，赋值。
        Tree[root].Value=a[l];
    else                                //否则递归地构造左右子树
    {
        build_tree(l,mid,root<<1);                        
        build_tree(mid+1,r,root<<1|1);                     
        Tree[root].Value=Tree[root<<1].Value+Tree[root<<1|1].Value;
    }                                //更新根节点的值 
} 

inline long long enquire_point(int k,int x)                //返回a[x]的值 主函数引用enquire_point(1,x); k就是当前处理的root 
{
    if(Tree[k].Left==Tree[k].Right)                    //当前节点左右端点相等 即为所求
        return Tree[k].Value;
    
    int mid=(Tree[k].Left+Tree[k].Right)>>1;            //否则，递归地向下查询 
    if(Tree[k].Lazy_tag)    Lazy_tag_pushdown(k);        //用到这里的话要下传懒标记 
    if(x<=mid)    return enquire_point(k<<1,x);            //目标位置在中点左边，查询左儿子 
    else        return enquire_point(k<<1|1,x);            //否则，查询右儿子 
} 

inline void revise_point(int k,int x,int Add)            //改变a[x]的值(此处为加上Add) 主函数引用revise_point(1,x,Add) 
{                                        //此部分与上面部分相似 
    if(Tree[k].Left==Tree[k].Right)
    {
        Tree[k].Value+=Add;
        return;
    }
    int mid=(Tree[k].Left+Tree[k].Right)>>1;        //否则，递归地向下寻找目标点 
    if(x<=mid)        revise_point(k<<1,x,Add);
    else            revise_point(k<<1|1,x,Add);
    
    Tree[k].Value=Tree[k<<1].Value+Tree[k<<1|1].Value;    //递归返回过程中，更新父节点的值 
}

inline long long enquire_tree(int l,int r,int root)        //返回a[l]到a[r]的总和 主函数引用enquire_tree(l,r,1) 
{
    if(Tree[root].Left>r||Tree[root].Right<l)            //若两者无交集，返回0 
        return 0;
    if(Tree[root].Left>=l&&Tree[root].Right<=r)        //若当前子树被[l,r]包含，直接返回当前子树的值
        return Tree[root].Value;
    Lazy_tag_pushdown(root);                    //如果要用这个子树的话要下传懒标记
    return enquire_tree(l,r,root<<1)+enquire_tree(l,r,root<<1|1);
                                        //否则在两个子树中查询 
} 

inline void revise_tree(int l,int r,int Add,int root)    //改变a[l]到a[r]的值（此处为加上Add）主函数引用revise_tree(l,r,Add,1) 
{
    if(Tree[root].Left>r||Tree[root].Right<l)        //若两者无交集，直接返回 
        return;
    if(Tree[root].Left>=l&&Tree[root].Right<=r)     //如果当前子树被[l,r]包含
    {
        Tree[root].Lazy_tag+=Add;
        Tree[root].Value+=Add*(Tree[root].Right-Tree[root].Left+1);
    } 
    else
    {
        if(Tree[root].Lazy_tag)        Lazy_tag_pushdown(root);
                                            //如果有懒标记，向下传递
        int mid=(Tree[root].Left+Tree[root].Right)>>1;
        if(l<=mid)    revise_tree(l,r,Add,root<<1);        //修改左子树 
        if(r>mid)    revise_tree(l,r,Add,root<<1|1);        //修改右子树 
        Tree[root].Value=Tree[root<<1].Value+Tree[root<<1|1].Value;    
                                            //递归地修改当前节点的值
    } 
}

int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    build_tree(1,n,1);
}
```

---

## 作者：Beginner_df016 (赞：1)

线段树简单模板（lazytag都不用......）

注释写在代码里了.....

记得开int64（long long int）....

PS：可能对齐格式有点乱....



```cpp
{Beginner_df016}
var i,j,k,n,m,x,y,s,id,z:longint;
      sum,add:array[0..400007]of int64;
      treel,treer:array[0..400007]of longint;
      //sum记录下标节点区间和
      //add记录下标节点子节点待更新值
      //treel,treer下标节点区间边界
procedure build(root,l,r:longint);//建树；
var mid:longint;
begin
    if l=r then
         begin
         read(x);  sum[root]:=x;
         treel[root]:=l; treer[root]:=r;
         exit;
         end;
    treel[root]:=l; treer[root]:=r;
    mid:=(l+r)>>1;
    build(root<<1,l,mid);
    build((root<<1)+1,mid+1,r);
    sum[root]:=sum[root<<1]+sum[root];
end;
procedure update(root,l,r,x:longint);//更改
var ll,rr,mid,len:longint; t:int64;
begin
    ll:=treel[root]; rr:=treer[root];
    if (ll>=l)and(rr<=r) then
         begin
         t:=x;
         inc(sum[root],t*(rr-ll+1));
         add[root]:=add[root]+x;
         exit;
         end;
    if add[root]<>0 then
         begin
         inc(add[root<<1],add[root]);
         inc(add[(root<<1)+1],add[root]);
         t:=add[root]; len:=rr-ll+1;
         inc(sum[root<<1],t*((len+1)div 2));
         inc(sum[(root<<1)+1],t*(len div 2));
         add[root]:=0;
         end;
    mid:=(ll+rr)>>1;
    if mid>=l then update(root<<1,l,r,x);
    if mid<r then update((root<<1)+1,l,r,x);
    sum[root]:=sum[root<<1]+sum[(root<<1)+1];
end;
function query(root,l,r:longint):int64;//查询区间和
var ll,rr,mid,len:longint; t,joker:int64;
begin
   ll:=treel[root]; rr:=treer[root];
   if (ll>=l)and(rr<=r) then exit(sum[root]); //当前区间包含在要求区间内则直接返回
   if add[root]<>0 then              //向下更新
         begin
         inc(add[root<<1],add[root]);
         inc(add[(root<<1)+1],add[root]);
         len:=rr-ll+1; t:=add[root];
         inc(sum[root<<1],t*((len+1) div 2));
         inc(sum[(root<<1)+1],t*(len div 2));
         add[root]:=0;
         end;
    mid:=(ll+rr)>>1;
    joker:=0;
    if mid>=l then inc(joker,query(root<<1,l,r));
    if mid<r then inc(joker,query((root<<1)+1,l,r));
    exit(joker);
end;
begin
    readln(n,m);
    build(1,1,n);
    for i:=1 to m do
         begin
         read(id);
         case id of
             1:begin readln(x,y,z); update(1,x,y,z); end;
             2:begin readln(x,y); writeln(query(1,x,y)); end;
             end;
         end;
end.
```

---

## 作者：Purified (赞：1)

##第一次写线段树不要看这篇题解

指针入门来写一篇指针线段树

用一个结构体存一个节点的数据，add标记

和父节点子节点的指针

其他操作类似于标准线段树

唔 比较好通过画图理解

~~其实并没有什么优点只是换个方法~~

···
```cpp
#include<bits/stdc++.h>
#define mid (ml+mr)/2
typedef long long int LL;
typedef struct node{
    LL a,ad,sum;
    node *f,*ls,*rs;
}node;
node *root; 
void tree(LL n,node *fa,bool k)//递归调用并读入数据
{
    node *s=(node*)malloc(sizeof(node));
    if(fa==NULL) root=s;
    else
    {
        s->f=fa;
        if(k) fa->ls=s;
        else fa->rs=s;
    }
    s->ad=0;
    s->sum=n;
    if(n==1)
    {
        s->ls=NULL;
        s->rs=NULL;
        scanf("%lld",&s->a);
    } 
    else
    {
        tree((n+1)/2,s,1);
        tree(n/2,s,0);
        s->a=(s->ls)->a+(s->rs)->a;
    }
}
void push(node *fa)//将ad标记推到儿子节点上
{
    if(fa->ls!=NULL) (fa->ls)->ad+=fa->ad;
    if(fa->rs!=NULL) (fa->rs)->ad+=fa->ad;
    fa->a+=(fa->ad)*(fa->sum);
    fa->ad=0;
    return;
}
void add(LL ml,LL mr,LL p,LL l,LL r,node *z)//二分查找区间并做区间修改
{
    if(ml==l&&mr==r) 
    {
        z->ad+=p;
        return;
    }
    if(r<=mid) 
    {
        z->a+=p*(r-l+1);
        add(ml,mid,p,l,r,z->ls);
    }
    else if(l>=mid+1)
    {
        z->a+=p*(r-l+1);
        add(mid+1,mr,p,l,r,z->rs);
    } 
    else 
    {
        z->a+=p*(r-l+1);
        add(ml,mid,p,l,mid,z->ls);
        add(mid+1,mr,p,mid+1,r,z->rs);
    }
}
LL getsum(LL ml,LL mr,LL l,LL r,node *z)//求和
{
    if(z->ad) push(z);//求和时将对应位的ad标记推至下一位
    if(ml==l&&mr==r) 
    {
        return z->a;
    }
    if(r<=mid) return getsum(ml,mid,l,r,z->ls);
    else if(l>=mid+1) return getsum(mid+1,mr,l,r,z->rs);
    else 
    {
        return getsum(ml,mid,l,mid,z->ls)+getsum(mid+1,mr,mid+1,r,z->rs);
    }
}
void print(node *fa)//测试用 用于后序遍历整个线段树
{
    if(fa->ls) print(fa->ls);
    if(fa->rs) print(fa->rs);
    printf("%lld %lld\n",fa->a,fa->ad);
    return;
}
int main()
{
    LL n,m,l,x,y,k;
    scanf("%lld%lld",&n,&m);
    tree(n,NULL,0);
    for(LL i=1;i<=m;i++)
    {
        scanf("%lld",&l);
        if(l==1)
        {
            scanf("%lld%lld%lld",&x,&y,&k);
            add(1,n,k,x,y,root);
        }
        else
        {
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",getsum(1,n,x,y,root));
        }
    }
    return 0;
}
···
```

---

## 作者：封禁用户 (赞：1)

```cpp
//这是线段树2的代码。。。
#pr\//其实这是
agma GCC optimize("O3")//O3优化。。。
//线段树么，建树用二分，同时加上懒惰标志；修改时尽量往懒惰标记上靠，举个最简单的//例子:不加懒惰标记如果每次均修改整个区间就出事了，时间复杂度n方logn；懒惰标记最//坏情况下为修改1/2区间+1/4区间+1/8区间+。。+修改到一个点（类比于树状数组那样可//能容易理解）,时间复杂度仍为 nlogn（不过必须承认，常数大了很多,所依要根据题目判断是否加懒惰标记）
//最后，一个彩蛋：猜一下这份代码可否通过线段树2？
#include<stdio.h>
using namespace std;
int n,m;
long long p,a[500010],vv[1000020],ll[2000050],rr[2000050],mm[2000050],k,jia[2000050],cheng[2000050];
char ch;
inline void iin(int &kk){
    ch=getchar();
    for(;ch!='-'&&(ch<48||ch>57);){
        ch=getchar();
    }
    if(ch=='-'){
        ch=getchar();
        for(;ch>=48&&ch<=57;){
            kk=(kk<<1)+(kk<<3)+ch-48;
            ch=getchar();
        }
        kk=-kk;
        return;
    }
    for(;ch>=48&&ch<=57;){
        kk=(kk<<1)+(kk<<3)+ch-48;
        ch=getchar();
    }
}
inline void lin(long long &kk){
    ch=getchar();
    for(;ch!='-'&&(ch<48||ch>57);){
        ch=getchar();
    }
    if(ch=='-'){
        ch=getchar();
        for(;ch>=48&&ch<=57;){
            kk=(kk<<1)+(kk<<3)+ch-48;
            ch=getchar();
        }
        kk=-kk;
        return;
    }
    for(;ch>=48&&ch<=57;){
        kk=(kk<<1)+(kk<<3)+ch-48;
        ch=getchar();
    }
}
long long build(int l,int r,int id){
    if(l==r){
        vv[id]=a[l]%p;
        ll[id]=rr[id]=mm[id]=l;
        return vv[id];
    }
    ll[id]=l;
    rr[id]=r;
    int mid=(l+r)>>1;
    mm[id]=mid;
    return vv[id]=build(l,mid,id<<1)+build(mid+1,r,(id<<1)|1);
}
long long chengg(int l,int r,long long change,int id){
//    printf("cheng%d %d %d %d\n",l,r,id,mm[id]);
    int mmm=mm[id];
    if(l==ll[id]&&r==rr[id]){
        long long uu=cheng[id];
        cheng[id]=(cheng[id]*change)%p;
        long long u=jia[id];
        jia[id]=(jia[id]*change)%p;
        return (cheng[id]-uu)*vv[id]+(jia[id]-u)*(r-l+1);
    }
    if(mmm>=r){
        long long u=chengg(l,r,change,id<<1);
        u%=p;
        vv[id]+=u;
        return u;
    }
    if(mmm<l){
        long long u=chengg(l,r,change,(id<<1)|1);
        u%=p;
        vv[id]+=u;
        return u;
    }
    long long u=chengg(l,mmm,change,id<<1)+chengg(mmm+1,r,change,(id<<1)|1);
    u%=p;
    vv[id]+=u;
    return u;
}
void jiaa(int l,int r,long long change,int id){
    int lll=ll[id],rrr=rr[id];
    if(l==lll&&r==rrr){
        jia[id]=(jia[id]+change)%p;
        return;
    }
    int mmm=mm[id];
    vv[id]=(vv[id]+(r-l+1)*change)%p;
//    printf("jia%d %d %d %d ",l,r,id,mm[id]);
//    printf("%lld\n",vv[id]);
    if(mmm>=r){
        jiaa(l,r,change,id<<1);
        return;
    }
    if(mmm<l){
        jiaa(l,r,change,(id<<1)|1);
        return;
    }
    jiaa(l,mmm,change,id<<1);
    jiaa(mmm+1,r,change,(id<<1)|1);
}
long long out(int l,int r,int id){
//    printf("out%d %d %d\n",l,r,id);
    vv[id]*=cheng[id];
    vv[id]+=jia[id]*(rr[id]-ll[id]+1);
    vv[id]%=p;
    int lid=id<<1,rid=(id<<1)|1;
    if(jia[id]){
        jia[lid]+=jia[id],jia[lid]%=p;
        jia[rid]+=jia[id],jia[rid]%=p;
    }
    if(cheng[id]>>1){
        cheng[lid]*=cheng[id],cheng[lid]%=p;
        cheng[rid]*=cheng[id],cheng[rid]%=p;
    }
//    printf("a%lld ",cheng[id]);
//    printf("s%lld\n",jia[id]);
    jia[id]=0,cheng[id]=1;
//    printf("%d %d %d %d\n",l,r,id,vv[id]);
    if(l==ll[id]&&r==rr[id]){
        return vv[id];
    }
    int mid=mm[id];
    if(mid>=r){
        return out(l,r,lid);
    }
    if(mid<l){
        return out(l,r,rid);
    }
    return out(l,mid,lid)+out(mid+1,r,rid);
}
int main(){
    iin(n),iin(m);//iin(p);
    p=2147483647000;
    for(int i=1;i<=n;i++){
        lin(a[i]);
    }
    for(int i=1;i<2000050;++i){
        cheng[i]=1;
    }
    build(1,n,1);
    int num=0,x=0,y=0;
    for(int i=0;i<m;i++){
        iin(num),iin(x),iin(y);
        if(num>>1){
//            if(num&1){
                printf("%lld\n",out(x,y,1)%p);
//            }
//            else{
//                lin(k);
//                jiaa(x,y,k%p,1);
//                k=0;
//            }
        }
        else{
            lin(k);
            //chengg(x,y,k%p,1);
            jiaa(x,y,k%p,1);
            k=0;
        }
        num=x=y=0;
    }
    for(int i=1;i<=9;i++){
//        printf("%lld ",vv[i]*cheng[i]+jia[i]*(rr[i]-ll[i]+1));
    }
    return 0;
}
```

---

## 作者：1379号监听员 (赞：0)

[更好的阅读体验和例题请前往博客](https://directional-foil.blog.luogu.org/post-shuo-ju-jie-gou-xian-duan-shu)
# P3372 题解
**线段树是什么？**

线段树是一种~~能让你代码强行增加50行的极容易爆炸的万金油~~数据结构，用于~~优雅~~暴力地解决对一个区间上**满足区间可加性（即可由两个子区间的信息得到当前区间信息）** 的 **区间修改和区间查询**问题。
## 结构：
将区间划分为左端点到中点（即左子区间）和中点+1到右端点（即右子区间）的两个子区间，然后对两个子区间继续划分，直到划分到单个元素（即左端点=右端点）

**示意图：**
![c0dd297d009ddb5d3d37da29c291da7c07e3cb5a0c40b2ec.png](https://www.kanjiantu.com/images/2019/08/27/c0dd297d009ddb5d3d37da29c291da7c07e3cb5a0c40b2ec.png)

不难看出线段树除了最下面一层，其他的部分一定是一颗**完全二叉树**，这意味着整棵树可以使用“父子二倍法”（左儿子编号为父亲编号 $\times$ 2，右儿子编号为父亲编号 $\times$ 2 $+$ 1）存储在一个数组中。同时，因为还要考虑到最后一层，数组的大小应开到n $\times$ 4大小。

线段树的一个很重要的性质就是一棵[1~n]的线段树的深度最大为 $log_2  n+1$,这也意味着线段树可在$O(logn)$的时间复杂度内完成所有操作。

---

## 实现
以[洛谷P3372 【模板】线段树 1](https://www.luogu.org/problem/P3372)的维护最大值为例
首先，我们给线段树中每个元素一个sum变量存储该元素代表区间的区间和，叶子结点的sum是原数组当前位置的值，非叶节点的sum是其左右子节点sum的和，如当原数组为 
![3dd6bf7464e1e756f.png](https://www.kanjiantu.com/images/2019/08/27/3dd6bf7464e1e756f.png)

时，对应的线段树为![2cd920dd97dbafe0d.png](https://www.kanjiantu.com/images/2019/08/27/2cd920dd97dbafe0d.png)

节点结构体：
```cpp

struct segmenttree{
  int l,r,sum,add;
  #define l(x) tree[x].l; //当前区间左端点
  #define r(x) tree[x].r; //当前区间右端点
  #define sum(x) tree[x].sum; //区间和
  #define add(x) tree[x].add; //延迟标记（这个后面会讲）
}tree[maxn];

```

---

## 操作
操作有递归和非递归两种形式，递归式相对于非递归式更直观，因此这里讲解递归式。

非递归式和递归式本同末异，考试时按照数据规模而定。

### 建树：
按照之前提到的定义，从根节点([1~n])向左右两边递归，递归到叶子结点就将该节点sum设为其在原数组中对应的值，回溯时将当前节点的sum设为其左右子节点sum的和。

代码：
```cpp

void build(int p,int l,int r)
{
  l(p)=l;r(p)=r; //设置端点
  if(l==r) { sum(p)=num[l]; return;} //如果是叶子节点
  int mid=((l+r)>>1); //位运算，右移1位相当于/2，左移同理
  build(p<<1,l,mid); //向左递归
  build(p<<1|1,mid+1,r) //向右递归，一个偶数|1相当于+1
}

```
复杂度为$O(nlogn)$

### 区间查询：
设查询区间的左端点为 $l$,右端点为 $r$,当前区间的左端点为 $l_1$,右端点为 $r_1$,中点为$mid$ ,则
- 当 $l \leq l_1$ 且 $r \geq r_1$时 直接返回当前区间的sum,因为当前区间**已经涵盖了子区间的全部信息**。
- 当 $l \leq mid$时，向左递归，$r_1=mid$（此时查询区间一定涵盖左子区间的一部分）
- 当 $r > mid$时，向右递归，$l_1=mid+1$ （此时查询区间一定涵盖右子区间的一部分）

代码：
```cpp

int query(int p,int l,int r)
{
  if(l<=l(p) && r>=r(p)) return sum(p); //完全包含
  int mid=((l(p)+r(p))>>1);
  int ans=0;
  if(l<=mid) ans+=query(p<<1,l,mid); //向左递归，累加左子树答案
  if(r>mid) ans+=query(p<<1|1,mid+1,r); //向右递归，累加左子树答案
  return ans;
}

```
复杂度为$O(logn)$

### 区间修改与延迟标记：
当进行区间修改时，我们依然可以设查询区间的左端点为 $l$,右端点为 $r$,当前区间的左端点为 $l_1$,右端点为 $r_1$,中点为$mid$，同时查询操作也满足这两条性质：
- 当 $l \leq mid$时，向左递归，$r_1=mid$（此时查询区间一定涵盖左子区间的一部分）
- 当 $r > mid$时，向右递归，$l_1=mid+1$ （此时查询区间一定涵盖右子区间的一部分）

但当出现完全覆盖的情况时，事情就变得不那么简单了，一个一个深入更新会使单次修改的复杂度高达 $O(n)$,这是我们所无法接受的。这时，我们就要引入**延迟标记**。

试想一下，如果你花费很大的代价更新了节点p的子树，但在之后的查询中却根本没有访问到它们，那更新p的子树岂不是白费力气？因此，我们可以在区间修改出现“完全覆盖”情况时也直接返回，但要给当前节点打上一个代表“**当前节点已被更新，但其子节点尚未被更新**”的延迟标记（这里取名add）。（如果操作是相容的（如加法），那在打标记前无需下传原来的标记。如果操作是不相容的（如赋值），那在打标记前需下传原来的标记。）

在以后的查询操作中，如果遇到了有延迟标记的节点，便将其的两个子节点更新并打上延迟标记，并擦除当前节点的延迟标记（即将延迟标记**下传一层**），这样就减少了大量无用的更新操作 ~~（虽然本质上依旧是暴力）~~。

代码：

```cpp

void spread(int p) //下传标记
{
  if(add(p))
  {
    add(p<<1)+=add(p);
    add(p<<1|1)+=add(p);
    sum(p<<1)+=add(p)*(r(p<<1)-l(p<<1)+1); //区间和增量=数值增量*区间长
		sum(p<<1|1)+=add(p)*(r(p<<1|1)-l(p<<1|1)+1); //区间和增量=数值增量*区间长
    add(p)=0;
  }
}

int query(int p,int l,int r) 
//更新后的区间查询，增加了下穿标记的操作
{
  if(l<=l(p) && r>=r(p)) return sum(p); //完全包含
  spread(p);//下传标记
  int mid=((l(p)+r(p))>>1);
  int ans=0;
  if(l<=mid) ans+=query(p<<1,l,mid);
  if(r>mid) ans+=query(p<<1|1,mid+1,r);
  return ans;
}

void update(int p int l,int r,int c)
{
  if(l<=l(p) && r>=r(p)){
		sum(p)+=c*(r(p)-l(p)+1); //区间和增量=数值增量*区间长
		add(p)+=c;
		return;
	}
	spread(p);//下传标记
	int mid=(l(p)+r(p))>>1;
	if(l<=mid) update(p<<1,l,r,c); //更新左子树
	if(r>mid) update(p<<1|1,l,r,c); //更新右子树
	sum(p)=sum(p<<1)+sum(p<<1|1); //更新当前点
}

```
复杂度为$O(logn)$

AC代码：
```cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=100002;
typedef long long ll;
struct segmenttree{
  int l,r,sum,add;
  #define l(x) tree[x].l; //当前区间左端点
  #define r(x) tree[x].r; //当前区间右端点
  #define sum(x) tree[x].sum; //区间和
  #define add(x) tree[x].add; //延迟标记（这个后面会讲）
};
segment_tree tree[maxn<<2];
ll read()//快读
{
	ll s=0,w=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') w=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')
	{
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*w;
}
void build(int p,int l,int r)
{
	l(p)=l;
	r(p)=r;
	int mid=(l+r)>>1;
	if(l==r){
		sum(p)=read();
		return;
	}
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum(p)=sum(p<<1)+sum(p<<1|1);
}
void spread(int p)
{
	if(add(p))
	{
		sum(p<<1)+=add(p)*(r(p<<1)-l(p<<1)+1);
		sum(p<<1|1)+=add(p)*(r(p<<1|1)-l(p<<1|1)+1);
		add(p<<1)+=add(p);
		add(p<<1|1)+=add(p);
		add(p)=0;
	}
}
long long ask(int p,int l,int r)
{
	if(l<=l(p) && r>=r(p)){
		return sum(p);
	}
	spread(p);
	int mid=(l(p)+r(p))>>1;
	long long v=0;
	if(l<=mid) v+=ask(p<<1,l,r);
	if(r>mid) v+=ask(p<<1|1,l,r);
	return v;
}
void update(int p,int l,int r,long long c)
{
	if(l<=l(p) && r>=r(p)){
		sum(p)+=c*(r(p)-l(p)+1);
		add(p)+=c;
		return;
	}
	spread(p);
	int mid=(l(p)+r(p))>>1;
	if(l<=mid) update(p<<1,l,r,c);
	if(r>mid) update(p<<1|1,l,r,c);
	sum(p)=sum(p<<1)+sum(p<<1|1);
}
ll n,m;
ll a,b,c,d;
int main()
{
	n=read(),m=read();
	build(1,1,n);
	while(m--){
		a=read();
		if(a==1){
			b=read(),c=read(),d=read();
			update(1,b,c,d);
		}
		else {
			b=read();
			c=read();
			printf("%ld\n",ask(1,b,c));
		}
	}
	return 0;
}

```

---

## 作者：ezoiHY (赞：0)

# 安利我的[博客](https://www.cnblogs.com/ezoihy/p/8893615.html )

## 线段树：

#### 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

#### 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为**2N**，实际应用时一般还要开**4N**的数组以免越界，因此有时需要离散化让空间压缩。

![](https://images2018.cnblogs.com/blog/1381936/201804/1381936-20180421091933658-1517198337.png)

#### 先上一个点修改的模板

### 忠诚改

<span style="color: #ff0000;"><del>tips：这不是洛谷P1816喔（但是用那个测程序也是可以的</del></span>

#### Time Limit: 1000 ms Memory Limit: 128 MB

老管家是一个聪明能干的人。他为财主工作了整整10年，财主为了让自已账目更加清楚。要求管家每天记k次账，由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按1，2，3&hellip;编号，然后不定时的问管家问题，问题是这样的：在a到b号账中最少的一笔是多少？为了让管家没时间作假他总是一次问多个问题。

在询问过程中账本的内容可能会被修改

#### Input

输入中第一行有两个数m,n表示有m(m&lt;=100000)笔账,n表示有n个问题，n&lt;=100000。

接下来每行为3个数字，第一个p为数字1或数字2，第二个数为x，第三个数为y

当p=1 则查询x,y区间

当p=2 则改变第x个数为y

#### Output

输出文件中为每个问题的答案。具体查看样例。

#### Sample Input

10 3 

1 2 3 4 5 6 7 8 9 10

1 2 7 

2 2 0 

1 1 10

#### Sample Output

2 0 

上代码

```cpp
#include<iostream>
#include<cstdio>
 
using namespace std;
 
int sum[10000001],n,m;
 
void build(int l,int r,int o){
    if(l==r){
        int x;
        scanf("%d",&x);
        sum[o]=x;
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,o<<1);
    build(mid+1,r,(o<<1)+1);
    sum[o]=min(sum[o<<1],sum[(o<<1)+1]);
}
 
void insert(int l,int r,int x,int o,int v){
    if(l==r){
        sum[o]=v;
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid)insert(l,mid,x,o<<1,v);
    else insert(mid+1,r,x,(o<<1)+1,v);
    sum[o]=min(sum[o<<1],sum[(o<<1)+1]);
}
 
int query(int l,int r,int x,int y,int o){
    if(x<=l and r<=y){
        return sum[o];
    }
    int mid=(l+r)>>1,ans=0x7fffffff;
    if(x<=mid)ans=query(l,mid,x,y,o<<1);
    if(y>mid) ans=min(ans,query(mid+1,r,x,y,(o<<1)+1));
    return ans;
}
 
int main(){
    scanf("%d%d",&n,&m);
    build(1,n,1);
    for(int i=1;i<=m;i++){
        int x;
        scanf("%d",&x);
        if(x==1){
            int y,z;
            scanf("%d%d",&y,&z);
            printf("%d\n",query(1,n,y,z,1));
        }else if(x==2){
            int y,z;
            scanf("%d%d",&y,&z);
            insert(1,n,y,1,z);
        }
    }
    return 0;
}
```

以上的代码十分（逃XDDD

# **实际上这个线段树是十分的简（fu）单（za）的**

### 分别有以下几个函数：

### build:构建整棵线段树

### pushup:对于我们所要求的答案进行往上更新

### pushdown:lazy标记下传

### update:区间修改（可以当做单点修改用）

### query:区间查询（和，最值等）

先上一个丑陋的线段树 
![](https://images2018.cnblogs.com/blog/1381936/201804/1381936-20180421091947175-530394571.png)

对于每一个颜色的方块，它是线段树上的一个节点 

而[x,y]就是x到y的一个闭区间。

## 所以这里每个节点可以维护一个值（如区间最值、和等

## 所以我们正式来学习一下区间修改的线段树，刚刚那是点修改的线段树，在oi使用中用处十分有限，同时也可是用区间修改的线段树代替

### 所以

### 我们来了解一下各个函数的用法：

#### build:构建一棵线段树

#### update:上传（修改）一个区间（点）的值，可以至此区间加、减、set等操作

#### query:查询一个区间的最值，和等

#### pushdown:下传lazytag

## 简述一下lazytag

我们也会发现有时候我们修改是一个区间，而这个区间在线段树上有一个节点刚好被这个区间所包括，那么我们就直接在这个节点上打标记也就是lazytag，我们就不用下传到叶子节点，这样我们就可以省下很大的复杂度。当然我们在查询时也要下放标记。也就是一个懒惰的思想，我们可以先不下放标记，在需要使用时再下放标记。

## 接下来我们以luogu P3372 【模板】线段树 1 为例

这是线段树最基础的一题

可能大家对于lazytag还是有一定的陌生，但是慢慢就会熟悉的
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

ll a[100001],sum[400001],lazy[400001];
int n,m;

void pushdown(int o,int len){
    if(lazy[o]){
        int left=o<<1,right=left+1;
        lazy[left]+=lazy[o],lazy[right]+=lazy[o];
        sum[left]+=lazy[o]*(len-(len>>1));
        sum[right]+=lazy[o]*(len>>1);
        lazy[o]=0;
    }
}

void build(int o,int l,int r){
    if(l==r){
        scanf("%d",&sum[o]);
        return;
    }
    int mid=(l+r)>>1,left=o<<1,right=left+1;
    build(left,l,mid),build(right,mid+1,r);
    sum[o]=sum[right]+sum[left];
}

void update(int o,int l,int r,int x,int y,int v){
    if(x<=l and r<=y){
        lazy[o]+=v;
        sum[o]+=v*(r-l+1);
        return;
    }
    int mid=(l+r)>>1,left=o<<1,right=left+1;
    pushdown(o,r-l+1);
    if(x<=mid)update(left,l,mid,x,y,v);
    if(y>mid)update(right,mid+1,r,x,y,v);
    sum[o]=sum[left]+sum[right];
}

ll query(int o,int l,int r,int x,int y){
    if(x<=l and r<=y){
        return sum[o];
    }
    int mid=(l+r)>>1,left=o<<1,right=left+1;
    ll m=0;
    pushdown(o,r-l+1);
    if(x<=mid)m+=query(left,l,mid,x,y);
    if(mid+1<=y)m+=query(right,mid+1,r,x,y);
    return m;
}


int main(){
    scanf("%d%d",&n,&m);
    build(1,1,n);
    for(int i=1;i<=m;i++){
        int x;
        scanf("%d",&x);
        if(x==1){
            int y,z,q;
            scanf("%d%d%d",&y,&z,&q);
            update(1,1,n,y,z,q);
        }
        if(x==2){
            int y,z,q;
            scanf("%d%d",&y,&z);
            printf("%lld\n",query(1,1,n,y,z));
        }
    }
    return 0;
}
```

线段树其实我们还有别的操作，如区间乘，set，lca，gcd等等

我们可以看下luogu线段树2

代码
```cpp
#include<cstdio>
#include<cstring>
#define ls o*2
#define rs o*2+1

using namespace std;
int n,m,Mod;
long long lazy1[500001],lazy2[500001],sum[500001],a[100001];

void pushdown(int o,int l,int r){
    if(lazy2[o]!=1){
        int mid=(l+r)/2;
        lazy2[ls]=(lazy2[ls]*lazy2[o])%Mod;
        lazy2[rs]=(lazy2[rs]*lazy2[o])%Mod;
        lazy1[ls]=(lazy1[ls]*lazy2[o])%Mod;
        lazy1[rs]=(lazy1[rs]*lazy2[o])%Mod;
        sum[ls]=(sum[ls]*lazy2[o])%Mod;
        sum[rs]=(sum[rs]*lazy2[o])%Mod;
        lazy2[o]=1;
    }
    if(lazy1[o]){
        int mid=(l+r)/2;
        lazy1[ls]=(lazy1[ls]+lazy1[o])%Mod;
        lazy1[rs]=(lazy1[rs]+lazy1[o])%Mod;
        sum[ls]=(sum[ls]+lazy1[o]*(mid-l+1))%Mod;
        sum[rs]=(sum[rs]+lazy1[o]*(r-mid))%Mod;
        lazy1[o]=0;
    }
}

void build(int o,int l,int r){
    lazy2[o]=1;
    if(l==r){
        sum[o]=a[l]%Mod;
        return;
    }
    int mid=(l+r)/2;
    build(ls,l,mid);
    build(rs,mid+1,r);
    sum[o]=(sum[ls]+sum[rs])%Mod;
}

void update(int a,int b,int o,int l,int r,int x){
    if(a<=l&&b>=r){
//        pushdown(o,l,r);
        sum[o]=(sum[o]+x*(r-l+1))%Mod;
        lazy1[o]=(lazy1[o]+x)%Mod;
        return;
    }
    pushdown(o,l,r);
    int mid=(l+r)/2;
    if(a<=mid) update(a,b,ls,l,mid,x);
    if(b>mid) update(a,b,rs,mid+1,r,x);
    sum[o]=(sum[ls]+sum[rs])%Mod;
}

void update2(int a,int b,int o,int l,int r,int x){
    if(a<=l&&b>=r){
//        pushdown(o,l,r);
        sum[o]=(sum[o]*x)%Mod;
        lazy2[o]=(lazy2[o]*x)%Mod;
        lazy1[o]=(lazy1[o]*x)%Mod;
        return;
    }
    pushdown(o,l,r);
    int mid=(l+r)/2;
    if(a<=mid) update2(a,b,ls,l,mid,x);
    if(b>mid) update2(a,b,rs,mid+1,r,x);
    sum[o]=(sum[ls]+sum[rs])%Mod;
}

long long query(int a,int b,int o,int l,int r){
    if(a<=l&&b>=r) return sum[o];
    pushdown(o,l,r);
    int mid=(l+r)/2;
    long long qq=0;
    if(a<=mid) qq=(qq+query(a,b,ls,l,mid))%Mod;
    if(b>mid) qq=(qq+query(a,b,rs,mid+1,r))%Mod;
    return qq%Mod;
}

int main(){
//    freopen("testdata.in","r",stdin);
//    freopen("hehe.txt","w",stdout);
//    for(int i=1;i<500001;i++) lazy2[i]=1;
    scanf("%d%d%d",&n,&m,&Mod);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    build(1,1,n);
    for(int i=1;i<=m;i++){
        int id,x,y,z;
        scanf("%d",&id);
        if(id==1){
            scanf("%d%d%d",&x,&y,&z);
            update2(x,y,1,1,n,z);
        }else if(id==2){
            scanf("%d%d%d",&x,&y,&z);
            update(x,y,1,1,n,z);
        }else{
            scanf("%d%d",&x,&y);
            printf("%lld\n",query(x,y,1,1,n));
        }
//        printf("No.%d %d\n",i,query(1,n,1,1,n));
//        if(i==1) printf("checks:%d\n",query(1,5,1,1,n));
    }
}
```
　　有时频繁的标记下放会给我们带来极大的常数，于是我们就可以用可持久化线段树，当然初学者可以忽略下面的内容。

## 线段树的标记永久化

_其实线段树的标记永久化是一个非常容易理解的东西，往往我们都会在区间操作时打lazytag，但是在标记下放时会耗费大量的时间，所以我们可以尝试标记永久化，这样我们的就不用下放标记，同时代码也更加简洁，因为我们少了一个pushdown函数，同时出错率也会大大降低。
对于标记永久化，其实和普通线段树比起来，其实差不多
_
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

typedef long long ll;
int n,m;
ll sum[4000001],tag[4000001]; 


void pushup(int o){
    sum[o]=sum[o<<1]+sum[o<<1|1]; 
}

void build(int o,int l,int r){
    if(l==r){
        scanf("%lld",&sum[o]);
        return;
    }
    int mid=(l+r)>>1;
    build(o<<1,l,mid);
    build(o<<1|1,mid+1,r);
    pushup(o);
}

void update(int o,int l,int r,int x,int y,ll v){
    sum[o]+=((ll)min(r,y)-(ll)max(x,l)+1)*v;
    if(x<=l and r<=y){
        tag[o]+=v;
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid){
        update(o<<1,l,mid,x,y,v);
    }
    if(y>mid){
        update(o<<1|1,mid+1,r,x,y,v);
    }
}

ll query(int o,int l,int r,ll tg,int x,int y){
    if(x<=l and r<=y){
        return sum[o]+(ll)(min(r,y)-max(x,l)+1)*(tg);
    }
    int mid=(l+r)>>1;
    ll ret=0;
    if(x<=mid){
        ret+=query(o<<1,l,mid,tg+tag[o],x,y);
    }
    if(y>mid){
        ret+=query(o<<1|1,mid+1,r,tg+tag[o],x,y);
    }
    return ret;
}

int main(){
    scanf("%d%d",&n,&m);
    build(1,1,n);
    for(int i=1;i<=m;i++){
        int opt;
        scanf("%d",&opt);
        if(opt==1){
            int x,y;
            ll z;
            scanf("%d%d%lld",&x,&y,&z);
            update(1,1,n,x,y,z);
        }else{
            int x,y;
            scanf("%d%d",&x,&y);
            printf("%lld\n",query(1,1,n,0,x,y));
        }
    }
    return 0;
}
```

---

## 作者：孤独的观测者 (赞：0)

### 为什么有这么多题解我还要发题解呢？
## 因为我用的Java 导致了我IO成本非常高（p党，js你们也一样）
#### 线段树模板+lazy标记楼下大佬的题解已经说的很清楚了，我这里说下非C/C++语言的问题，后两个点导致你的IO成本急剧上升。怎么办？

这里介绍ACM Java组必备的**StreamTokenizer类**
（本来这道题我以为是不用的，结果2203ms，脸好痛。效果实测550ms）

简介：
几种基本的常量用于标识解析过程：TT_EOF(流结尾)、TT_EOL(行结尾)、TT_NUMBER(数字符号, 0 1 2 3 4 5 6 7 8 9 . -都属于数字语法)、TT_WORD(一个单词)。

特点：
1、类java.io.StreamTokenizer可以获取输入流并将其分析为Token（标记）。 
StreamTokenizer的nextToken方法读取下一个标记 

2、默认情况下，StreamTokenizer认为下列内容是Token:字母、数字、除c和c++注释符号以外的其他符号。
     如符号“/”不是Token，注释后的内容也不是，而"/"是Token。单引号和双引号以及其总的内容，只能算一个Token。 
3、为了提高效率，使用BufferedReader，如下，创建StreamTokenizer对象 

下面贴代码
```java
package 洛谷;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;

public class P3372模板线段树1
{
	static final int MAX_SIZE = 1000001;
	static long tree[] = new long[MAX_SIZE << 2];// n*4必定不过界
	static long lazyTag[] = new long[MAX_SIZE << 2];// 懒惰标记
	static int a[] = new int[MAX_SIZE];// 需要构建线段树的数组
	static int N, M;// N当前数据量 M操作数个数

	static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
	static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

	public static int nextInt() throws IOException
	{
		in.nextToken();
		return (int) in.nval;
	}

	public static String next() throws IOException
	{
		in.nextToken();
		return (String) in.sval;
	}

	public static void main(String[] args) throws IOException
	{
		while (in.nextToken() != StreamTokenizer.TT_EOF)
		{
			break;
		}
		N = (int) in.nval;
		M = nextInt();
		for (int i = 0; i < N; i++)
		{
			a[i + 1] = nextInt();
		}
		build(1, 1, N);
		for (int i = 0; i < M; i++)
		{
			int opr = nextInt();
			if (opr == 1)
			{
				int x = nextInt();
				int y = nextInt();
				int k = nextInt();
				update(x, y, 1, 1, N, k);
			} else
			{

				int x = nextInt();
				int y = nextInt();
				out.println(query(x, y, 1, N, 1));
			}
		}
		out.flush();
		out.close();

	}


	/**
	 * 左孩子的索引
	 * 
	 * @param p
	 *            当前节点
	 * @return
	 */
	public static int leftChild(int p)
	{
		return p << 1;// p*2
	}

	/**
	 * 右孩子的索引
	 * 
	 * @param p
	 *            当前节点
	 * @return
	 */
	public static int rightChild(int p)
	{
		return (p << 1) | 1;// p*2+1
	}

	/**
	 * 先去整合子节点的信息，再向它们的祖先回溯整合之后的信息 向上传导信息
	 * 
	 * @param p
	 *            当前节点
	 */
	public static void pushUp(int p)
	{
		tree[p] = tree[leftChild(p)] + tree[rightChild(p)];
	}

	/**
	 * 建树
	 * 
	 * @param p
	 *            当前节点
	 * @param l
	 *            左边界
	 * @param r
	 *            右边界
	 */
	public static void build(int p, int l, int r)
	{
		lazyTag[p] = 0;
		// 如果左右区间相同，那么必然是叶子节点啦，只有叶子节点是被真实赋值的
		if (l == r)
		{
			tree[p] = a[l];
			return;
		}
		int mid = (l + r) >> 1;// /2
		build(leftChild(p), l, mid);
		build(rightChild(p), mid + 1, r);
		pushUp(p);
	}

	/**
	 * 区间更新 单点修改就是区间更新的特例
	 * 
	 * @param needL
	 *            需要修改的左边界
	 * @param needR
	 *            需要修改的右边界
	 * @param p
	 *            当前节点
	 * @param l
	 *            当前节点所存储的区间的左边界
	 * @param r
	 *            当前节点所存储的区间的右边界
	 * @param k
	 *            修改的值
	 */
	public static void update(int needL, int needR, int p, int l, int r, int k)
	{

		if (needL <= l && r <= needR)
		{
			tree[p] += k * (r - l + 1);
			lazyTag[p] += k;
			return;
		}

		pushDown(p, l, r);

		int mid = (l + r) >> 1;// /2

		if (needL <= mid)
		{
			update(needL, needR, leftChild(p), l, mid, k);
		}
		if (needR > mid)
		{
			update(needL, needR, rightChild(p), mid + 1, r, k);
		}
		// 更新完子节点后更新自己
		pushUp(p);
	}

	/**
	 * 向下更新
	 * 
	 * @param p
	 *            当前节点
	 * @param l
	 *            左边界
	 * @param r
	 *            右边界
	 */
	public static void pushDown(int p, int l, int r)
	{
		int mid = (l + r) >> 1;// /2
		// 每次更新两个儿子节点
		f(leftChild(p), l, mid, lazyTag[p]);
		f(rightChild(p), mid + 1, r, lazyTag[p]);
		lazyTag[p] = 0;// 本节点不再lazy了
	}

	/**
	 * 记录当前节点所代表的区间
	 * 
	 * @param p
	 *            当前节点
	 * @param l
	 *            左边界
	 * @param r
	 *            右边界
	 * @param k
	 *            要更新的值
	 */
	public static void f(int p, int l, int r, long k)
	{
		lazyTag[p] = lazyTag[p] + k;
		tree[p] = tree[p] + k * (r - l + 1);// 由于是这个区间统一改变故改变多少，就增加多少
	}

	/**
	 * 区间查询
	 * 
	 * @param queryX
	 *            查询左边界
	 * @param queryY
	 *            查询右边界
	 * @param l
	 *            左边界
	 * @param r
	 *            右边界
	 * @param p
	 *            当前节点
	 */
	public static long query(int queryX, int queryY, int l, int r, int p)
	{
		long result = 0;
		if (queryX <= l && r <= queryY)
		{
			return tree[p];
		}
		int mid = (l + r) >> 1;// /2
		pushDown(p, l, r);
		if (queryX <= mid)
		{
			result += query(queryX, queryY, l, mid, leftChild(p));
		}
		if (queryY > mid)
		{
			result += query(queryX, queryY, mid + 1, r, rightChild(p));
		}
		return result;
	}
}

```

---

## 作者：Loccri2JE (赞：0)

1. 就裸板子，往熟了打呗
2. 注意开long long，否则只有70分！
3. 各种函数的变量顺序一定要有自己的风格，不然乱写的话非常难调

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
typedef long long ll;

#define mid  (l+r)/2
#define lson (pos<<1)
#define rson ((pos<<1)|1)
#define maxn 100007 //元素个数

ll n,m;
ll root=1;
ll arr[maxn];
ll Lazy[maxn<<2];//区间增加的lazy标记
/*其目的是：
            为防止修改区间总结点对每个子节点都要进行修改，导致复杂度爆炸
            暂时记录一下这个区间总结点的所有子树都“待修改”
            如果用到下面的子节点就修改，下推lazy标志，用不到就不管
            以此来减少复杂度
*/
ll sum[maxn<<2];//线段树求和最多分成4个子区间

void PushUp(long long pos)//暂时写成求和函数，可以自由变换
{
    sum[pos]=sum[lson]+sum[rson];
    //用数组表示二叉树:假设某个节点的编号为v,那么它的左子节点编号为2*v，右子节点编号为2*v+1,规定根节点为1
    //通常2*v写成v<<1 , 2*v+1写成v<<1|1;
}

void PushDown(long long pos,long long l,long long r)//区间查询用
{
    //l,r为左子树，右子树的数字区间
	if(Lazy[pos])
    {
		//修改子节点的增加数 
		Lazy[lson]+=Lazy[pos];
		Lazy[rson]+=Lazy[pos];
		//修改子节点区间的sum
		sum[lson]+=Lazy[pos]*(mid-l+1);
		sum[rson]+=Lazy[pos]*(r-(mid+1)+1);
		//清除本节点标记
		Lazy[pos]=0;
	}
}

void UpZone(long long pos,long long l,long long r,long long L,long long R,long long C)//对整个区间进行修改
{
    //L,R表示操作区间 , l,r表示当前节点区间 , pos表示当前节点编号
    if(L<=l && R>=r)//节点区间在操作区间之内，直接返回
    {
        sum[pos]+=C*(r-l+1);//这个点需要加上区间长度*C
        Lazy[pos]+=C;//用Lazy标记，表示本区间的Sum正确，子区间的Sum仍需要根据Add调整
        return;
    }
    PushDown(pos,l,r);//下推标记
    if(L<=mid) UpZone(lson,l,mid,L,R,C);
    if(R>mid) UpZone(rson,mid+1,r,L,R,C);
    PushUp(pos);
}

ll Query(long long l,long long r,long long L,long long R,long long pos)
{
    //L,R表示操作区间 , l,r表示当前节点区间 , pos表示当前节点编号
    if(L<=l && R>=r)//节点区间在操作区间之内，直接返回
    {
        return sum[pos];
    }
    PushDown(pos,l,r);//下推标记，否则sum可能不正确
    
    //统计答案
    long long ans=0;
    if(L<=mid) ans+=Query(l,mid,L,R,lson);
    if(R>mid) ans+=Query(mid+1,r,L,R,rson);
    PushUp(pos);
    return ans;
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        long long tmp;
        cin>>tmp;
        UpZone(root,1,n,i,i,tmp);
    }
    for(int j=1;j<=m;j++)
    {
        long long a,b,c,d;
        cin>>a;
        if(a==1)
        {
            cin>>b>>c>>d;
            UpZone(root,1,n,b,c,d);
        }
        else
        {
            cin>>b>>c;
            cout<<Query(1,n,b,c,root)<<endl;
        }
    }
    return 0;
}
```

------------
辣鸡蒟蒻再来一波动态开点的模板，虽然在这个题上跑的不如静态，不过今后一定会用到!!
CAUTION！！！！！！！！！！！！
1. 不能define  lson，rson，也不能用pos<<1和pos<<1|1，否则就失去了“动态开点”的意义
2. Get_Son和UpZone要&引用
3. 尽量开long long，也好调

------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
typedef long long ll;

//！！！！！！！！！
//Get_Son和UpZone要&引用
//不能define  lson，rson，也不能用pos<<1和pos<<1|1
//！！！！！！！！！

#define mid  (l+r)/2
#define maxn 1000007 //元素个数

ll n,m;
ll root=1,cnt=1;
ll lson[maxn],rson[maxn];
ll Lazy[maxn<<2];//区间增加的lazy标记
/*其目的是：
            为防止修改区间总结点对每个子节点都要进行修改，导致复杂度爆炸
            暂时记录一下这个区间总结点的所有子树都“待修改”
            如果用到下面的子节点就修改，下推lazy标志，用不到就不管
            以此来减少复杂度
*/
ll sum[maxn<<2];//线段树求和最多分成4个子区间

ll Get_Son(long long &pos)
{
    if(pos==0) pos=++cnt;
    return pos;
}

void PushUp(long long pos)
{
    sum[pos]=sum[lson[pos]]+sum[rson[pos]];
    //用数组表示二叉树:假设某个节点的编号为v,那么它的左子节点编号为2*v，右子节点编号为2*v+1,规定根节点为1
    //通常2*v写成v<<1 , 2*v+1写成v<<1|1;
}

void PushDown(long long pos,long long l,long long r)//区间查询用
{
    //l,r为左子树，右子树的数字区间

    // if(Lazy[pos]==0) return;
    // if(r-l<=1) return;
    // if(pos<<1!=0)
    // {
    //     pos<<1=++cnt;
    //     sum[pos<<1]+=(mid-l+1)*Lazy[pos];
    //     Lazy[pos<<1]+=Lazy[pos];
    // }
    // if(rson[pos]!=0)
    // {
    //     rson[pos]=++cnt;
    //     sum[rson[pos]]+=(r-mid+1)*Lazy[pos];
    //     Lazy[rson[pos]]+=Lazy[pos];
    // }
    sum[Get_Son(lson[pos])]+=(mid-l+1)*Lazy[pos];
    sum[Get_Son(rson[pos])]+=(r-mid)*Lazy[pos];
    Lazy[lson[pos]]+=Lazy[pos];
    Lazy[rson[pos]]+=Lazy[pos];
    Lazy[pos]=0;
}

void UpZone(long long &pos,long long l,long long r,long long L,long long R,long long C)
{
    //L,R表示操作区间 , l,r表示当前节点区间 , pos表示当前节点编号
    if(pos==0) pos=++cnt;
    if(Lazy[pos]!=0) PushDown(pos,l,r);//下推标记
    
    if(L<=l && R>=r)//节点区间在操作区间之内，直接返回
    {
        sum[pos]+=(r-l+1)*C;//这个点需要加上区间长度*C
        Lazy[pos]+=C;//用Lazy标记，表示本区间的Sum正确，子区间的Sum仍需要根据Lazy调整
        return;
    }

    if(L<=mid) UpZone(lson[pos],l,mid,L,R,C);
    if(R>mid) UpZone(rson[pos],mid+1,r,L,R,C);
    PushUp(pos);
}

ll Query(long long pos,long long l,long long r,long long L,long long R)
{
    //L,R表示操作区间 , l,r表示当前节点区间 , pos表示当前节点编号
    if(pos==0) return 0;
    if(Lazy[pos]) PushDown(pos,l,r);//下推标记，否则sum可能不正确

    if(L<=l && R>=r)//节点区间在操作区间之内，直接返回
    {
        return sum[pos];
    }
    
    //统计答案
    long long ans=0;
    if(L<=mid) ans+=Query(lson[pos],l,mid,L,R);
    if(R>mid) ans+=Query(rson[pos],mid+1,r,L,R);
    PushUp(pos);
    return ans;
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int tmp;
        cin>>tmp;
        UpZone(root,1,n,i,i,tmp);
    }
    for(int j=1;j<=m;j++)
    {
        int a,b,c,d;
        cin>>a;
        if(a==1)
        {
            cin>>b>>c>>d;
            UpZone(root,1,n,b,c,d);
        }
        else
        {
            cin>>b>>c;
            cout<<Query(root,1,n,b,c)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Tmper244 (赞：0)

```cpp
#include<cstdio>
#define maxn 100000
#define ll unsigned long long
int n,m,x,y,k,i,cmd;
namespace lx{struct read{read(){scanf("%d%d",&n,&m);}}read;}//用构造函数输入，不解释了
struct node{int l,r;ll d,s;};//线段树的节点:l是覆盖的最左位置;r是;是覆盖的最右位置;d是标记;s是本区间的和 
class ST
{
    public:
        node tree[maxn*4+10];//注意是n*4,n*2会炸，因为还有最后一层 
        inline int lc(int a){return a<<1;}//求左孩子 
        inline int rc(int a){return (a<<1)+1;}//求右孩子 
        inline void update(int cur,int d=-1)//更新函数 
        {
            if(d!=-1){if(tree[cur].l!=tree[cur].r)tree[cur].d+=d;tree[cur].s+=d*(tree[cur].r-tree[cur].l+1);}//加上区间要加的数 
            else{tree[cur].s=tree[lc(cur)].s+tree[rc(cur)].s;}//用左，右孩子的信息来更新当前节点的信息 
            return;
        }
        void build(int cur,int l,int r)//构建树，不说了 
        {
            if(l==r)
            {
                tree[cur].l=tree[cur].r=l;//终端节点 
                tree[cur].d=tree[cur].s=0;
                return;
            }
            else
            {
                int mid=(l+r)>>1;
                tree[cur].l=l;tree[cur].r=r;
                tree[cur].d=tree[cur].s=0;
                build(lc(cur),l,mid);build(rc(cur),mid+1,r);
                return;
            }
        }
        ST(){build(1,1,n);}//线段树的构造函数，直接建 
        void change(ll d,int cur,int l,int r)
        {
            if(l==r==tree[cur].l==tree[cur].r){tree[cur].s+=d;return;}//终端节点 
            else if(tree[cur].l>=l&&tree[cur].r<=r){update(cur,d);return;}//更改的区间完全覆盖该节点 
            else
            {
                if(tree[cur].d){update(lc(cur),tree[cur].d);update(rc(cur),tree[cur].d);tree[cur].d=0;}//分解标记，千万不能打漏 
                int mid=(tree[cur].l+tree[cur].r)>>1;
                if(l<=mid)change(d,lc(cur),l,r);//更改孩子信息 
                if(r>mid)change(d,rc(cur),l,r);
                update(cur);//更新 
                return;
            }
        }
        ll q(int cur,int l,int r)//查询 
        {
            if(tree[cur].l>=l&&tree[cur].r<=r)return tree[cur].s;
            else
            {
                if(tree[cur].d){update(lc(cur),tree[cur].d);update(rc(cur),tree[cur].d);tree[cur].d=0;}//分解标记，千万不能打漏
                ll ans=0;int mid=(tree[cur].l+tree[cur].r)>>1;
                if(l<=mid)ans=q(lc(cur),l,r);//获得孩子信息 
                if(r>mid)ans+=q(rc(cur),l,r);
                return ans;
            }
        }
        inline void init(int cur,int val){change(val,1,cur,cur);return;}//用来对付第二行的初始化 
}st;
namespace lx
{
    struct work
    {
        work()//用构造函数操作，不解释了 
        {
            for(i=0;i<n;){scanf("%d",&x);st.init(++i,x);}
            for(i=0;i<m;i++)
            {
                scanf("%d%d%d",&cmd,&x,&y);
                if(cmd==1){scanf("%d",&k);st.change(k,1,x,y);}
                else{printf("%lld\n",st.q(1,x,y));}//注意是长整型 
            }
        }
    }work; 
}
int main(){return 0;}//特短的主函数 
```

---

## 作者：arfa (赞：0)

# [p3372]线段树模版

如果真的母鸡抖线段树的可以找我的博客;

看见没有怕死狗的题解我就来撒一个;


    
    
    
    
    
    
    
    
    
    
    
    
    
```cpp
    var
            tree,lazy,left,right:array[1..800002] of int64;//分别为tree上的值,lazy标记,和左右指标
            n,m,k,l,r,x,y,find,srx,add:int64;
            i:longint;
    procedure make(l,r,k:int64);//建造一棵树
    var
            mid:int64;
    begin
            lazy[k]:=0;
            left[k]:=l;//标记左指标
            right[k]:=r;//标记右指标
            if l=r then
            begin
                    read(tree[k]);//直到l=r才输入
                    exit;
            end;
            mid:=(l+r) div 2;//中心
            make(l,mid,k*2);//往上递归
            make(mid+1,r,k*2+1);
            tree[k]:=tree[k*2]+tree[k*2+1];
    end;
    procedure SUC(k:int64);//down,往下lazy左儿子和右儿子,并清空自己的lazy
    var
            l,r:int64;
    begin
            l:=k*2;
            r:=k*2+1;
            inc(lazy[l],lazy[k]);//标记lazy
            inc(lazy[r],lazy[k]);//同上
            inc(tree[l],lazy[k]*(right[l]-left[l]+1));//分发给左儿子
            inc(tree[r],lazy[k]*(right[r]-left[r]+1));//分发给右儿子
            lazy[k]:=0;
    end;
    procedure change(k:longint);//区间修改
    var
            mid:int64;
    begin
            if (left[k]>=x)and(right[k]<=y) then//如果需要改变
            begin
                    inc(tree[k],add*(right[k]-left[k]+1));
                    inc(lazy[k],add);//标记lazy
                    exit;
            end;
            if lazy[k]>0 then
                    SUC(k);//down
            mid:=(left[k]+right[k]) div 2;
            if x<=mid then//2边查找
                    change(k*2);
            if y>mid then
                    change(k*2+1);
            tree[k]:=tree[k*2]+tree[k*2+1];
    end;
    procedure look(k:longint);//区间查询
    var
            mid:int64;
    begin
            if (left[k]>=x)and(right[k]<=y) then//如果到了叶子结点就add
            begin
                    inc(find,tree[k]);
                    exit;
            end;
            if lazy[k]>0 then//down
                    SUC(k);
            mid:=(left[k]+right[k]) div 2;//2边找
            if x<=mid then
                    look(k*2);
            if y>mid then
                    look(k*2+1);
    end;
    begin//主
            readln(n,m);
            make(1,n,1);//先建一棵树
            for i:=1 to m do
            begin
                    read(srx,x,y);
                    find:=0;
                    if srx=1 then
                    begin
                            read(add);
                            change(1);
                    end;
                    if srx=2 then
                    begin
                            look(1);
                            writeln(find);
                    end;
            end;
end.
```

---

## 作者：Adun (赞：0)

#注意！！这是线段树练习（然而都无视了。。。）


-楼下都有线段树和树状数组的写法，

-于是我就发一篇分块的题解（没有卡分块。。。因为分块的复杂度是n\*根号n）


1.把数组分为根号n块，求出每一块的和

2.每次操作时，若l，r在一个完整的块中就暴力求解，若不在同一个块中就把左边和右边所在的不完整块用暴力求解，中间的完整块用延迟标记起来。


如果想学分块的话可以去看**神牛黄学长的博客hzwer.com**或在b站上看qscqesze(电子科技大学ACM队)的视频（有很多算法）


下面贴代码

```cpp
#include "stdafx.h"
#include<iostream>
using namespace std;

long long n, m, flag, x, y, k, block, num;
long long a[100005], l[100005], r[100005], belong[100005], sum[100005], atag[100005];

inline void build()
{
    block = sqrt(n);
    num = n / block;

    if (n%block)num += 1;

    for (long long i = 1; i <= num; i++)
        l[i] = (i - 1) * block + 1, r[i] = i*block;

    r[num] = n;

    for (long long i = 1; i <= n; i++)
        {
            belong[i] = (i - 1) / block + 1;
            sum[belong[i]] += a[i];
        }
}

inline void add(long long x, long long y, long long k)
{
    if (belong[x] == belong[y])
        {
            for (long long i = x; i <= y; i++)
                a[i] += k;
            return;
        }

    for (long long i = x; i <= r[ belong[x] ]; i++)
        {
            a[i] += k;
            sum[belong[i]]+=k;
        }
    for (long long i = l[ belong[y] ]; i <= y; i++)
        {
            a[i] += k;
            sum[belong[i]]+=k;
        }
    for (long long i = belong[x] + 1; i < belong[y]; i++)
        {
            sum[i] += k*block;
            atag[i] += k;
        }
    return;
}

inline long long ask(long long x, long long y)
{
    long long ans = 0;

    if (belong[x] == belong[y])
        {
            for (long long i = x; i <= y; i++)
                ans += a[i] + atag[belong[i]];
            return ans;
        }
    for (long long i = x; i <= r[ belong[x] ]; i++)
        ans += a[i] + atag[ belong[i] ];
    for (long long i = l[ belong[y] ]; i <= y; i++)
        ans += a[i] + atag[ belong[i] ];
    for (long long i = belong[x] + 1; i < belong[y]; i++)
        ans += sum[i];
    return ans;
}

int main()
{
    cin >> n >> m;
    for (long long i = 1; i <= n; i++)
        cin >> a[i];

    build();

    while (m--)
        {
            cin >> flag;
            if (flag == 1)
                {
                    cin >> x >> y >> k;
                    add(x, y, k);
                }
            else
                {
                    cin >> x >> y;
                    cout << ask(x, y) << endl;
                }
        }
    return 0;
}
```
**VS2017**


---

## 作者：ModestCoder_ (赞：0)

本蒟蒻刚学会树状数组的区间求和，在线段树模板里练了个手~~~


先讲讲最普通的单点修改+区间求和


把a[x]+y，就是change(x,y)


求l~r的和，就是getsum(r)-getsum(l-1) //就是前缀和


具体不展开，楼下已提到，上面讲的是树状数组【模板1】


然后是区间修改+单点求和


难度提高了一点点，需要用到差分


所谓差分，比如数列a1,a2,a3,……,an


令deltai=a[i]-a[i-1]


那么a[i]=delta[1]+delta[2]+delta[3]+……+delta[i]


所以，要把l~r都加上x，只需change(l,x);change(r+1,-x);


算a[x]只需getsum(x)


难度微高一点点，是树状数组【模板2】


接下来步入正题，就是本题区间修改+区间求和


其实对线段树来说是水题==，我能说我线段树不熟练吗


依然用到差分，不过需要进行一个简单的推导：


1~i的和=sum[i]+i\*delta[1]+(i-1)\*delta[2]+……+2\*delta[i-1]+delta[i] //sum表示初始数据的前缀和



        =sum[i]+sigma(delta[x]\*(i-x+1))

        =sum[i]+(i+1)\*sigma(delta[x])-sigma(delta[x]\*x)

所以我们就维护两个树状数组delta,delta1，delta1[i]=delta[i]\*i


至于sum，一个预处理搞定


```cpp
type
    ar=array[0..100000] of int64;
var
    sum,delta,delta1:ar;
    l,r,x,y,i,n,m:longint;
function lowbit(x:int64):int64;
begin
    exit(x and -x);
end;
procedure change(var delta:ar;x,y:int64);
begin
    while x<=n do
        begin
            inc(delta[x],y);
            inc(x,lowbit(x));
        end;
end;
function getsum(var delta:ar;x:int64):int64;
begin
    getsum:=0;
    while x>0 do
        begin
            inc(getsum,delta[x]);
            dec(x,lowbit(x));
        end;
end;
begin
    readln(n,m);
    for i:=1 to n do
        begin
            read(x);
            sum[i]:=sum[i-1]+x;
        end;
    for i:=1 to m do
        begin
            read(x);
            if x=1 then
                begin
                    readln(l,r,x);
                    change(delta,l,x);
                    change(delta,r+1,-x); //delta的差分
                    change(delta1,l,x*l);
                    change(delta1,r+1,-x*(r+1));  //delta1的差分
                end else
                begin
                    readln(l,r);
                    writeln(sum[r]-sum[l-1]+(r+1)*getsum(delta,r)-l*getsum(delta,l-1)-getsum(delta1,r)+getsum(delta1,l-1));
                end;
        end;
end.
说难不难，理解就行
```

---

## 作者：Sino_E (赞：0)

总结了一下，标准线段树区间更改简洁写法？

这里lazy标记尤其需要说明一下——这种方法从楼下看来的，感觉很神，此处加以解释：

1.update时lazy标记更新先将该节点还原

2.lazy标记更新后，到根部的路径应带上lazy标记更新

3.若该节点为叶子结点无法还原，则直接在sum上作永久更改

4.lazy标记下放时，因为下放节点没有经过直接更改，无须在意重复相加情况。同时，若直接检查到了带lazy标记的节点，此时lazy标记不算做下放，因此也不会重复计算。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ls x<<1
#define rs x<<1|1
using namespace std;
typedef long long ll;
const int N=300010;
ll a[N],sum[N];
ll addv[N];

void build(int x,int l,int r){
    if(l==r){sum[x]=a[l]; return;}
    int mid=(l+r)>>1;
    build(ls,l,mid),build(rs,mid+1,r);
    sum[x]=sum[ls]+sum[rs];
}

void update(int x,int l,int r,int xl,int xr,int k){
    if(xl<=l&&r<=xr){addv[x]+=k;}
    else{
        int mid=(l+r)>>1;
        if(xr<=mid)update(ls,l,mid,xl,xr,k);
        else if(xl>mid)update(rs,mid+1,r,xl,xr,k);
        else update(ls,l,mid,xl,mid,k),update(rs,mid+1,r,mid+1,xr,k);
    }
    if(l<r)sum[x]=sum[ls]+sum[rs];//这里复原！ 
    if(l==r)sum[x]+=k;
    else sum[x]+=addv[x]*(ll)(r-l+1);//再加上lazy标记 
}

ll check(int x,int l,int r,int xl,int xr,ll add){
    if(xl<=l&&r<=xr)return sum[x]+add*(ll)(r-l+1);
    int mid=(l+r)>>1;
    if(xr<=mid)return check(ls,l,mid,xl,xr,add+addv[x]);
    else if(xl>mid)return check(rs,mid+1,r,xl,xr,add+addv[x]);
    else return check(ls,l,mid,xl,mid,add+addv[x])+check(rs,mid+1,r,mid+1,xr,add+addv[x]);
}

int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    build(1,1,n);
    int con,x,y,k;
    for(int i=0;i<m;i++){
        cin>>con>>x>>y;
        if(con==1){
            cin>>k;
            update(1,1,n,x,y,k);
        }
        else if(con==2){
            cout<<check(1,1,n,x,y,0)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Running_Coder (赞：0)

受到好多大佬的影响，萌新把线段树封在了struct里面。。。

进入正题：（以下内容均在结构体内）


##变量定义：

sum[]：线段树节点对应区间的元素总和；

addv[]：线段树节点对应区间的所有元素的待追加值（懒标记），初值全部设为0。


##过程说明：

#建树（Build）：

若当前节点仅包含原序列中的一个值，即L=R，则直接赋值为序列中该值，否则递归建立左右子树后，将左右子树保存的sum值相加，即得到当前节点的sum值。


#懒标记下放（Push\_down）：

将当前节点的addv值下放到左右子树。

细节实现：

1.子树的addv值加上当前节点的addv值；

2.子树的sum值加上（子树包含元素数量\*当前节点的addv值）；

3.清空当前节点的addv值，即赋值为0。

特别说明：

1.使用前判断，若当前节点的addv值为0则不需执行此下放函数。虽然执行了也不会有影响，但浪费时间。

2.为尽量节省时间，要将判断放在此函数外而不是函数内。


#区间加（update）：

若当前节点完全包含在待更新区间内，则直接修改当前节点的addv值和sum值即可；

否则：

1.若当前节点addv值非0，则进行懒标记下放；

2.若待更新区间与左子树对应区间有交集，则递归更新左子树，同理对右子树也执行类似操作。

3.递归更新子树完成后，重新计算当前节点的sum值。


#区间查询（query）：

若当前节点完全包含在待查询区间内，则直接返回当前节点的sum值；

否则：

1.定义当前节点结果ans=0；

2.若当前节点addv值非0，则进行懒标记下放；

3.若待查询区间与左子树对应区间有交集，则递归查询左子树，并将所得结果加给ans，同理对右子树也执行类似操作。

4.递归查询子树完成后，返回计算好的ans值。


##代码如下：





    
        
        
            
            
    
        
        
    
            
            
            
    
        
            
            
            
            



    
    
    
        
    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<string>
#include<stack>
#include<queue>
#include<vector>
#include<map>
using namespace std;
long long c[2000010];
struct sgt{
    long long sum[2000010];
    long long addv[2000010];       
    void build(int o,int l,int r){
        addv[o]=0;
        if(l==r)sum[o]=c[l];
        else{
            int mid=(l+r)>>1;
            int lson=o<<1;
            int rson=lson|1;
            build(lson,l,mid);
            build(rson,mid+1,r);
            sum[o]=sum[lson]+sum[rson];
        }
    }
    void push_down(int o,int l,int r,int mid,int lson,int rson){
        addv[lson]+=addv[o];
        addv[rson]+=addv[o];
        sum[lson]+=(mid-l+1)*addv[o];
        sum[rson]+=(r-mid)*addv[o];
        addv[o]=0;
    }
    void update(int o,int l,int r,int a,int b,int x){
        if(l>=a && r<=b){
            addv[o]+=x;
            sum[o]+=(r-l+1)*x;
            return;
        }
        else{
            int mid=(l+r)>>1;
            int lson=o<<1;
            int rson=lson|1;
            if(addv[o])push_down(o,l,r,mid,lson,rson);
            if(a<=mid)update(lson,l,mid,a,b,x);
            if(b>mid)update(rson,mid+1,r,a,b,x);
            sum[o]=sum[lson]+sum[rson];
        }
    }
    long long query(int o,int l,int r,int a,int b){
        if(l>=a && r<=b)return sum[o];
        else{
            int mid=(l+r)>>1;
            int lson=o<<1;
            int rson=lson|1;
            long long ans=0;
            if(addv[o])push_down(o,l,r,mid,lson,rson);
            if(a<=mid)ans+=query(lson,l,mid,a,b);
            if(b>mid)ans+=query(rson,mid+1,r,a,b);
            return ans;
        }
    }
};
sgt tree;
int n,m,i,f;
int x,y,k;
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)scanf("%d",&c[i]);
    tree.build(1,1,n);
    for(i=1;i<=m;i++){
        scanf("%d",&f);
        if(f&1){
            scanf("%d%d%d",&x,&y,&k);
            tree.update(1,1,n,x,y,k);
        }
        else{
            scanf("%d%d",&x,&y);
            printf("%lld\n",tree.query(1,1,n,x,y));
        }
    }
    return 0;
}
```

---

## 作者：北海_Beihai (赞：0)

树状数组，144ms

详细解释见 链接: https://pan.baidu.com/s/1pKXUtGB 密码: 6tb4

代码：（不要问我为什么，这是模板！）

'''cpp
```cpp
#include<bits/stdc++.h>
using namespace std;
long long bit0[5000010],n,bit1[5000010],m;    //bit0和bit1的含义如图所示
long long sum(long long* bit,long long i){    //求和
    long long s=0;
    for(;i;i^=i&-i) s+=bit[i];
    return s;
}
void add(long long* bit,long long i,long long x){    //更新
    for(;i<=n;i+=i&-i) bit[i]+=x;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(long long i=1;i<=n;i++){
        long long a;
        scanf("%lld",&a);
        add(bit0,i,a);
    }                                                         //初始化
    for(long long i=1;i<=m;i++){
        long long q,x,y;
        scanf("%lld%lld%lld",&q,&x,&y);
        if(q==1){
            long long k;
            scanf("%lld",&k);
            //以下4行是代码的核心部分
            add(bit0,x,-k*(x-1));
            add(bit1,x,k);
            add(bit0,y+1,y*k);
            add(bit1,y+1,-k);
        }
        else{
            long long ret=0;
            //以下2行也很重要
            ret+=sum(bit1,y)*y+sum(bit0,y);
            ret-=sum(bit1,x-1)*(x-1)+sum(bit0,x-1);
            printf("%lld\n",ret);
        }
    }
    return 0;
}
'''
```

---


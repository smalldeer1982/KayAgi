# 【模板】线段树 2

## 题目描述

如题，已知一个数列，你需要进行下面三种操作：

- 将某区间每一个数乘上 $x$；
- 将某区间每一个数加上 $x$；
- 求出某区间每一个数的和。


## 说明/提示

【数据范围】

对于 $30\%$ 的数据：$n \le 8$，$q \le 10$。  
对于 $70\%$ 的数据：$n \le 10^3 $，$q \le 10^4$。  
对于 $100\%$ 的数据：$1 \le n \le 10^5$，$1 \le q \le 10^5$。

除样例外，$m = 571373$。

（数据已经过加强 ^\_^）

样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2255.png) 

故输出应为 $17$、$2$（$40 \bmod 38 = 2$）。

## 样例 #1

### 输入

```
5 5 38
1 5 4 2 3
2 1 4 1
3 2 5
1 2 4 2
2 3 5 5
3 1 4```

### 输出

```
17
2```

# 题解

## 作者：ctq1999 (赞：375)

### update 2020.3.5 修改后符合了洛谷题解规范

[传送门](https://www.luogu.org/problemnew/show/P3373)

我又来发教科书般的代码了。

看看其他题解，发现线段树写的好乱啊，于是发了篇福利文。

相比较于P3372，此题多了个区间乘法。

一个 `tag` 似乎应付不了了，那么来两个 `tag` 啊： `add` 和 `mul` 。

##### 前置知识：通过 P3372【模板】线段树1

## 1. 区间加法

还是一样。

```cpp
s[pos].add = (s[pos].add + k) % mod;
s[pos].sum = (s[pos].sum + k * (s[pos].r - s[pos].l + 1)) % mod;
```

## 2. 区间乘法

这里就有点不一样了。

先把 `mul` 和 `sum` 乘上 `k` 。

对于之前已经有的 `add` ，把它乘上 `k` 即可。**在这里，我们把乘之后的值直接更新add的值。**

你想， `add` 其实应该加到 `sum` 里面，所有乘上 `k` 后，运用乘法分配律， `(sum + add) * k == sum * k + add * k` 。

这样来实现 `add` 和 `sum` 有序进行。

```cpp
s[pos].add = (s[pos].add * k) % mod;
s[pos].mul = (s[pos].mul * k) % mod;
s[pos].sum = (s[pos].sum * k) % mod;
```

## 3. pushdown的维护

现在要下传两个标记： `add` 和 `mul` 。

`sum` ：因为 `add` 之前已经乘过，所以在子孩子乘过 `mul` 后直接加就行。

`mul` ：直接乘。

`add` ：因为 `add` 的值是要包括乘之后的值，所以子孩子要先乘上 `mul` 。

```cpp
s[pos << 1].sum = (s[pos << 1].sum * s[pos].mul + s[pos].add * (s[pos << 1].r - s[pos << 1].l + 1)) % mod;

s[pos << 1].mul = (s[pos << 1].mul * s[pos].mul) % mod;

s[pos << 1].add = (s[pos << 1].add * s[pos].mul + s[pos].add) % mod;
```


## 代码

在此注释： `<<` 和 `|` 是位运算，`n << 1 == n * 2`，`n << 1 | 1 == n * 2 + 1`（再具体的自己百度）。


```cpp
#include <bits/stdc++.h>

#define MAXN 100010
#define ll long long

using namespace std;

int n, m, mod;
int a[MAXN];

struct Segment_Tree {
	ll sum, add, mul;
	int l, r;
}s[MAXN * 4];

void update(int pos) {
	s[pos].sum = (s[pos << 1].sum + s[pos << 1 | 1].sum) % mod;
    return;
}

void pushdown(int pos) { //pushdown的维护
	s[pos << 1].sum = (s[pos << 1].sum * s[pos].mul + s[pos].add * (s[pos << 1].r - s[pos << 1].l + 1)) % mod;
	s[pos << 1 | 1].sum = (s[pos << 1 | 1].sum * s[pos].mul + s[pos].add * (s[pos << 1 | 1].r - s[pos << 1 | 1].l + 1)) % mod;
	
	s[pos << 1].mul = (s[pos << 1].mul * s[pos].mul) % mod;
	s[pos << 1 | 1].mul = (s[pos << 1 | 1].mul * s[pos].mul) % mod;
	
	s[pos << 1].add = (s[pos << 1].add * s[pos].mul + s[pos].add) % mod;
	s[pos << 1 | 1].add = (s[pos << 1 | 1].add * s[pos].mul + s[pos].add) % mod;
		
	s[pos].add = 0;
	s[pos].mul = 1;
	return; 
}

void build_tree(int pos, int l, int r) { //建树
	s[pos].l = l;
	s[pos].r = r;
	s[pos].mul = 1;
	
	if (l == r) {
		s[pos].sum = a[l] % mod;
		return;
	}
	
	int mid = (l + r) >> 1;
	build_tree(pos << 1, l, mid);
	build_tree(pos << 1 | 1, mid + 1, r);
	update(pos);
	return;
}

void ChangeMul(int pos, int x, int y, int k) { //区间乘法
	if (x <= s[pos].l && s[pos].r <= y) {
		s[pos].add = (s[pos].add * k) % mod;
		s[pos].mul = (s[pos].mul * k) % mod;
		s[pos].sum = (s[pos].sum * k) % mod;
		return;
	}
	
	pushdown(pos);
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) ChangeMul(pos << 1, x, y, k);
	if (y > mid) ChangeMul(pos << 1 | 1, x, y, k);
	update(pos);
	return;
}

void ChangeAdd(int pos, int x, int y, int k) { //区间加法
	if (x <= s[pos].l && s[pos].r <= y) {
		s[pos].add = (s[pos].add + k) % mod;
		s[pos].sum = (s[pos].sum + k * (s[pos].r - s[pos].l + 1)) % mod;
		return;
	}
	
	pushdown(pos);
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) ChangeAdd(pos << 1, x, y, k);
	if (y > mid) ChangeAdd(pos << 1 | 1, x, y, k);
	update(pos);
	return;
}

ll AskRange(int pos, int x, int y) { //区间询问
	if (x <= s[pos].l && s[pos].r <= y) {
		return s[pos].sum;
	}
	
	pushdown(pos);
	ll val = 0;
	int mid = (s[pos].l + s[pos].r) >> 1;
	if (x <= mid) val = (val + AskRange(pos << 1, x, y)) % mod;
	if (y > mid) val = (val + AskRange(pos << 1 | 1, x, y)) % mod;
	return val;
}

int main() {
	scanf("%d%d%d", &n, &m, &mod);
	
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	
	build_tree(1, 1, n);
	
	for (int i = 1; i <= m; i++) {
		int opt, x, y;
		scanf("%d%d%d", &opt, &x, &y);
		if (opt == 1) {
			int k;
			scanf("%d", &k);
			ChangeMul(1, x, y, k);
		}
		if (opt == 2) {
			int k;
			scanf("%d", &k);
			ChangeAdd(1, x, y, k);
		}
		if (opt == 3) {
			printf("%lld\n", AskRange(1, x, y));
		}
	}
    
	return 0;
}
```

> 日拱一卒，功不唐捐

---

## 作者：logwzc (赞：112)

# 竟然没有矩阵乘法的题解
考虑线段树

对于线段树的每一个节点，我们维护一个向量(x,y)，其中x为区间和，y为区间大小。

### 操作一
对于一个向量(a,b)，我们要让它成为(a*x,b)，相当于让这个向量乘以如下矩阵。

$A=\begin{bmatrix}x&0\\0&1\end{bmatrix}$

### 操作二
对于一个向量(a,b)，我们要让它成为(a+x*b,b)，相当于让这个向量乘以如下矩阵。

$B=\begin{bmatrix}1&0\\x&1\end{bmatrix}$

这样修改操作就等价于让一个区间乘以一个矩阵。

于是每个节点的Lazytag就维护一个矩阵即可。

代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 100010
using namespace std;
template<typename T> void read(T &x){
	x=0;char c=getchar();T sig=1;
	for (;!isdigit(c);c=getchar()) if (c=='-') sig=-1;
	for (; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=sig;
}
ll Mod;
struct matrix{
	ll a[2][2];
	void crt(){
		a[0][0]=a[1][1]=1;
		a[0][1]=a[1][0]=0;
		return;
	}
	void clear(){
		a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;
		return;
	}
	void crt1(ll x){
		clear();
		a[0][0]=x;
		a[1][1]=1;
		return;
	}
	void crt2(ll x){
		clear();
		a[0][0]=1;
		a[1][0]=x;
		a[1][1]=1;
		return;
	}
};
struct tree{
	int l,r;
	ll w[2];
	matrix tag;
	bool flag;
};
tree tr[N<<2];
ll a[N];
int n,k;
void timesA(tree &x,matrix y){
	tree res;
	res.w[0]=(x.w[0]*y.a[0][0]+x.w[1]*y.a[1][0])%Mod;
	res.w[1]=(x.w[0]*y.a[0][1]+x.w[1]*y.a[1][1])%Mod;
	x.w[0]=res.w[0];
	x.w[1]=res.w[1];
	return;
}
void timesB(matrix &x,matrix y){
	matrix z;
	z.a[0][0]=(x.a[0][0]*y.a[0][0]+x.a[0][1]*y.a[1][0])%Mod;
	z.a[0][1]=(x.a[0][0]*y.a[0][1]+x.a[0][1]*y.a[1][1])%Mod;
	z.a[1][0]=(x.a[1][0]*y.a[0][0]+x.a[1][1]*y.a[1][0])%Mod;
	z.a[1][1]=(x.a[1][0]*y.a[0][1]+x.a[1][1]*y.a[1][1])%Mod;
	x=z;
	return;
}
void pushup(int i){
	tr[i].w[0]=(tr[i<<1].w[0]+tr[i<<1|1].w[0])%Mod;
	tr[i].w[1]=(tr[i<<1].w[1]+tr[i<<1|1].w[1])%Mod;
	return;
}
void build(int i,int L,int R){
	tr[i].l=L;
	tr[i].r=R;
	tr[i].tag.crt();
	tr[i].flag=false;
	if (L==R){
		tr[i].w[0]=a[L];
		tr[i].w[1]=1;
		return;
	}
	int mid=(L+R)>>1;
	build(i<<1,L,mid);
	build(i<<1|1,mid+1,R);
	pushup(i);
	return;
}
void pushdown(int i){
	if (tr[i].flag){
		tr[i].flag=false;
		tr[i<<1].flag=true;
		tr[i<<1|1].flag=true;
		timesB(tr[i<<1].tag,tr[i].tag);
		timesB(tr[i<<1|1].tag,tr[i].tag);
		timesA(tr[i<<1],tr[i].tag);
		timesA(tr[i<<1|1],tr[i].tag);
		tr[i].tag.crt();
	}
	return;
}
void add(int i,int L,int R,matrix s){
	if (L<=tr[i].l&&tr[i].r<=R){
		timesA(tr[i],s);
		timesB(tr[i].tag,s);
		tr[i].flag=true;
		return;
	}
	pushdown(i);
	if (L<=tr[i<<1].r) add(i<<1,L,R,s);
	if (R>=tr[i<<1|1].l) add(i<<1|1,L,R,s);
	pushup(i);
	return;
}
ll query(int i,int L,int R){
	if (L<=tr[i].l&&tr[i].r<=R) return tr[i].w[0];
	pushdown(i);
	ll res=0;
	if (L<=tr[i<<1].r) res=query(i<<1,L,R);
	if (R>=tr[i<<1|1].l) res+=query(i<<1|1,L,R);
	res%=Mod;
	return res;
}
int main(){
	read(n);read(k);read(Mod);
	for (int i=1;i<=n;i++) read(a[i]);
	build(1,1,n);
	while (k--){
		int opt,L,R;
		read(opt);read(L);read(R);
		if (opt==3) printf("%lld\n",query(1,L,R));
		else{
			ll x;
			read(x);
			matrix type;
			if (opt==1) type.crt1(x);else type.crt2(x);
			add(1,L,R,type);
		}
	}
	return 0;
}
```


---

## 作者：Lskkkno1 (赞：13)


### 引入问题

*   已知一个数列
*   进行下面四种操作
*   1.区间赋值成 $x$
*   2.区间乘上一个数 $x$
*   3.区间加上一个数 $x$
*   4.求出区间每一个数的和

[洛谷P3373](https://www.luogu.org/problem/P3373) (只有后面三种操作)

### 矩阵入门

可以看看我写的[这篇博客](https://www.cnblogs.com/Lskkkno1/p/11686341.html)

### 正文

#### 线段树维护的是带有结合律的东西

假如维护的东西不存在**结合律**

那么每次一个新的标记就会把旧的标记挤下去

每一个标记都要遍历整棵树，复杂度变成 $O(nm)$

### 线段树维护矩阵

众所周知，矩阵乘法是有**结合率**的

即 : 

$A(B C) = (AB)C$

那么我们可以在线段树的每一个节点维护一个**矩阵**来表示一些**信息**

那么我们的每一次**操作**都想方设法把它变成"乘上一个矩阵"

那么我们就可以线段树维护区间矩阵乘法，来表示一些**结合律**不是那么明显的信息

注意 : 由于矩阵乘法不具有**交换律**，所以我们每次只能**左乘**，或只能**右乘**一个**转移矩阵**

**左乘** 和 **右乘** 分别看个人实现的是一个列矩阵，还是一个行矩阵

#### 矩阵模拟变化

每一个结点用矩阵可以表示成这样

$$\begin{bmatrix}v\\s\end{bmatrix}$$

$v$ 表示维护的权值(区间和)，$s$ 表示结点的大小

***

按题目中的意思模拟

把原矩阵**左乘**一个矩阵来得到我们要的新矩阵

#### 区间加 $x$

$$\begin{bmatrix}1&x\\0&1\end{bmatrix}\times\begin{bmatrix}v\\s\end{bmatrix}=\begin{bmatrix}v + s \times x\\s\end{bmatrix}$$

#### 区间乘 $x$

$$\begin{bmatrix}x&0\\0&1\end{bmatrix}\times\begin{bmatrix}v\\s\end{bmatrix}=\begin{bmatrix}v \times x\\s\end{bmatrix}$$

#### 区间赋值为 x

$$\begin{bmatrix}0&x\\0&1\end{bmatrix}\times\begin{bmatrix}v\\s\end{bmatrix}=\begin{bmatrix}s \times x\\s\end{bmatrix}$$

#### 区间求和

即按**普通**的线段树那样

把每一个结点的**矩阵**加在一起即可

***

对了，最好写一个矩阵类，弄个矩阵**乘法**，**加法**之类的

由于矩阵运算有一个 $8$ 的小常数，我吸氧后才勉强通过


[$\color {DeepSkyBlue} Code$](https://www.luogu.org/paste/t41gxp83)

```cpp
#include <bits/stdc++.h>
#define N 100005

using namespace std;

int n, m, mod;

struct matrix {
	int r, c;
	long long a[2][2];
	inline matrix(int _r = 0, int _c = 0) {
		r = _r, c = _c;
		memset(a, 0, sizeof a);
	}
	inline bool operator != (const matrix &rhs) const {
		if(r != rhs.r || c != rhs.c) return true;
		for(int i = 0; i < r; ++i)
		  for(int j = 0; j < c; ++j)
		  	if(a[i][j] != rhs.a[i][j])
		  	  return true;
		return false;
	}
	/*
	for debug
	inline void print() {
		for(int i = 0; i < r; ++i) {
		  for(int j = 0; j < c; ++j)
			printf("%lld ", a[i][j]);
			putchar('\n');
		}
	}
	*/
}e(2, 2), delta(2, 2);
inline matrix mul(matrix A, matrix B) {
	matrix C(A.r, B.c);
	for(int i = 0; i < A.r; ++i)
	  for(int j = 0; j < B.c; ++j)
		for(int k = 0; k < A.c; ++k)
		  C.a[i][j] += A.a[i][k] * B.a[k][j], C.a[i][j] %= mod;
	return C;
}
inline matrix add(matrix A, matrix B) {
	matrix C(A.r, A.c);
	for(int i = 0; i < A.r; ++i)
	  for(int j = 0; j < A.c; ++j)
	  	C.a[i][j] = A.a[i][j] + B.a[i][j], C.a[i][j] %= mod;
	return C;
}

template <typename T> inline void read(T &x) {
	x = 0; char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
}

struct SMT {
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
	matrix sum[N << 2], tag[N << 2];
	inline void update(int u) { sum[u] = add(sum[ls(u)], sum[rs(u)]); }
	inline void pushdown(int u) {
		if(tag[u] != e) {
			int l = ls(u), r = rs(u);
			sum[l] = mul(tag[u], sum[l]), tag[l] = mul(tag[u], tag[l]);
			sum[r] = mul(tag[u], sum[r]), tag[r] = mul(tag[u], tag[r]);
			tag[u] = e;
		}
	}
	inline void build(int l, int r, int u) {
		tag[u] = e;
		sum[u].r = 2, sum[u].c = 1;
		if(l == r) {
			read(sum[u].a[0][0]);
			sum[u].a[1][0] = 1;
			return;
		}
		int mid = l + r >> 1;
		build(l, mid, ls(u)), build(mid + 1, r, rs(u));
		update(u);
		return;
	}
	inline void modify(int ll, int rr, int l, int r, int u) {
		if(ll <= l && r <= rr) {
			sum[u] = mul(delta, sum[u]);
			tag[u] = mul(delta, tag[u]);
			return;
		}
		pushdown(u);
		int mid = l + r >> 1;
		if(ll <= mid) modify(ll, rr, l, mid, ls(u));
		if(mid < rr) modify(ll, rr, mid + 1, r, rs(u));
		update(u);
		return;
	}
	inline matrix query(int ll, int rr, int l, int r, int u) {
		if(ll <= l && r <= rr) return sum[u];
		pushdown(u);
		int mid = l + r >> 1;
		if(rr <= mid) return query(ll, rr, l, mid, ls(u));
		else if(mid < ll) return query(ll, rr, mid + 1, r, rs(u));
		else return add(query(ll, rr, l, mid, ls(u)), query(ll, rr, mid + 1, r, rs(u)));
	}
#undef ls
#undef rs
}Lsk;

int main() {
	e.a[0][0] = e.a[1][1] = 1;
	read(n), read(m), read(mod);
	Lsk.build(1, n, 1);

	int opt, l, r;
	while(m--) {
		read(opt), read(l), read(r);
		if(opt == 3) {
			printf("%lld\n", Lsk.query(l, r, 1, n, 1).a[0][0]);
		} else {
			delta = e;
			if(opt == 1) {
				read(delta.a[0][0]);
				/*
					mul
					|x  0| |v|   |x * v|
					|    |*| | = |     |
					|0  1| |1|   |  1  |
				*/
			} else if(opt == 2) {
				read(delta.a[0][1]);
				/*
					add
					|1  x| |v|   |v + x|
					|    |*| | = |     |
					|0  1| |1|   |  1  |
				*/
			}
			Lsk.modify(l, r, 1, n, 1);
		}
	}
	return 0;
}
```

---

## 作者：lcfollower (赞：9)

写在前面
---

本文为了符合模版题规范，从线段树的建树到查询一步步讲，读者可以自己调阅读的初始位置。

如果文章有错误可以评论，到时候我会更改。

引入
---

先看[这题](https://www.luogu.com.cn/problem/P3372)。

首先暴力肯定挂。

考虑运用前缀和优化，但是修改操作的时间复杂度是不能接受的。

再考虑运用 [BIT 模板题](https://www.luogu.com.cn/problem/P3368)的方法，但是区间求和的时间复杂度也不能接受。

如果想了解纯 BIT 可以上网搜，~~我不会~~。

于是我们选择用线段树解决。


---

线段树可分为**普通线段树**和**权值线段树**，这题用普通线段树，权值线段树的每一个节点代表**数值**（有时需要离散化）在这段区间的答案（不一定是问题答案，也可以是某个需要维护的值），这里讲普通线段树。

顾名思义，线段树是一棵树，设当前节点编号为 $u$，则其左儿子编号为 $2u$，可写作`u << 1`，右儿子编号为 $2u + 1$，可写作`u << 1 | 1`（`u << 1` 后二进制末尾为 $0$，按位或上 $1$ 就成了 $2u + 1$）。每个节点记录着一个**区间内**你想要维护的值，设节点 $u$ 所代表的的区间为 $[l,r]$，记 $mid = \frac{l + r}{2}$（即这个区间的中点），节点 $2u$ 所代表的的区间为 $[l,mid]$，节点 $2u + 1$ 所代表的区间为 $[mid + 1 ,r]$。就拿上面[这题](https://www.luogu.com.cn/problem/P3372)为例，我们想要维护的值一定是这个区间内所有数的和。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qa9pu98i.png)

最开始
---

做入门线段树的题，首先要明确自己**需要维护什么值**，想清楚了再打代码。

这里明显需要维护**区间和**，还有一个等下面会讲（包括原因）。

建树操作
---

首先建立结构体：

```cpp
const int N = 5e5 + 10;
struct SGT {//SGT = SegMent Tree = 线段树。
  int l ,r ,sum;//sum 表示需要维护的区间和。
} tr[N << 2];
```

注意开 $4n$ 空间，具体原因可见[这里](https://oi-wiki.org//ds/seg/#%E5%AE%9E%E7%8E%B0)。

---

然后是正式的建树操作。

代码实现中，我们使用 `build (u ,l ,r)` 表示节点 $u$ 代表为区间为 $[l,r]$，进行**递归**建树。

- 叶节点（递归边界）：即 $l = r$，节点建立后返回；
- 创建左儿子：先取 $mid=\frac{l+r}{2}$ 再递归 `build (u << 1 ,l ,mid)`；
- 创建右儿子：仍旧有 $mid = \frac{l + r}{2}$，然后递归 `build (u << 1 | 1 ,mid + 1 ,r)`。

创建**叶节点**的节点建立表示将 `tr[u].sum` 值赋为 $a_l$，因为这是叶节点，只有它一个值。

最后不要忘了只给叶节点的 $sum$ 赋了值，还需要向上合并（代码中写作 `pushup`）区间信息。

完整建树代码如下：

```cpp
const int N = 5e5 + 10;
struct node {
  int l ,r ,sum;//sum 表示需要维护的区间和。
} tr[N << 2];
inline void pushup(int u){
//pushup(u) 表示将 u 的左儿子和右儿子的信息合并到 u 的信息上。
  tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
/*注意：由此可得线段树维护的值必须具有结合律，比如区间和、区间积、区间异或和、区间最值等！
参考下述：
tr[1].sum = tr[2].sum + tr[3].sum
          = (tr[4].sum + tr[5].sum) + (tr[6].sum + tr[7].sum)，
如果加法不具有结合律普通线段树根本维护不了区间和。*/
} inline void build (int u,int l,int r){
  tr[u].l = l ,tr[u].r = r;
  if(l == r){tr[u].sum = a[L];return;}//叶节点。
  int mid = ((L + R) >> 1);//取中点。
  /*建立左儿子和右儿子*/
  build(u << 1 ,L ,mid);
  build(u << 1 | 1 ,mid + 1, R);
  pushup(u);//别忘了合并信息。 
}
```

这样我们就建立了一棵和上图相当的线段树。

这样总共会建立至多 $4n$ 左右个节点，时间复杂度为 $\mathcal O(n)$。

---

以下开始默认 $mid = \frac{l+r}{2}$。

单点修改
---

单点修改，指的是将某一个下标的数值进行**一次操作**，可以加、减、乘、除、异或等。

首先先给这个函数定义名为 `update`。

考虑对于下标 $x$，首先从节点 $1$ 开始，记当前节点的区间为 $[l,r]$，获取其左、右儿子所对应的区间，分别为 $[l,mid]$ 和 $[mid+1,r]$，然后逐步逼近所代表区间为 $[x,x]$ 的**叶节点**进行修改，回溯时需要 `pushup`。因为可以发现未遍历过的节点都无需更改，所以 `pushup` 只要回溯时进行即可。

题目中是进行区间加法。

具体代码实现如下：

```cpp
inline void update(int u ,int x ,int v){
//u 表示当前节点编号，x 表示需要修改的序列下标，v 为增加值。
  int l = tr[u].l ,r = tr[u].r;
  if(l == r){//就是这个叶子节点。
//由于这是逐步逼近这个节点，搜索到的只要是叶节点就一定 l = r = x，所以可以不写 l(r) == x。
  	tr[u].sum += (tr[u].r - tr[u].l + 1) * v;
//区间每个数增加 v，总和增加为：区间长度 * v。
  	return;//不要忘了回溯！
  }
  int mid = ((l + r) >> 1);
  if(x <= mid) update(u << 1 ,L ,R ,v);//如果在左子树。
  else update(u << 1 | 1, L , R ,v);//否则当然在右子树啦。
  pushup(u);//合并信息，因为修改过了。
}
```

考虑到每次走到一个儿子，都会排除约一半的节点，所以 $1$ 次修改 $[x,x]$ 的时间复杂度约为 $\mathcal O(\log n)$（回溯也是 $\mathcal O(\log n)$，当然常数不算）。 

区间修改
---

就是题目所求操作。

聪明的读者学会单点修改后，可以执行 $r - l + 1$ 次单点修改，时间复杂度为 $\mathcal O(len\log n)$，其中 $len$ 为区间长度。时间复杂度过高，不能接受。

于是我们引进一个新的概念：**懒标记**。

我们定义这题的懒标记为**其所有儿子节点**需要增加的值，「下传」（下面会有解释）后清零。

一开始所有节点的懒标记为 $0$（当然随着维护的值改变也可以更改，比如**区间覆盖**为一个不可能会覆盖的值（$v$ 的值域不包括的值）等）。

设当前节点 $u$ 所对应的区间为 $[l,r]$，需要修改的区间为 $[L,R]$。

- 如果 $[l,r]\in [L,R]$，那么把 $u$ 的懒标记增加 $v$ 并对其区间和进行修改，然后**回溯**。
- 否则，如果 $L\le mid$，说明**左子树**有需要修改的区间，往左子树递归。
- 如果 $mid + 1 \le R$，则说明**右子树**有需要修改的区间，往右子树递归。

最后不要忘了 `pushup`。

完成后如下图：


![](https://cdn.luogu.com.cn/upload/image_hosting/kf49h5x9.png)

然后考虑修改 $[L,R] = [1,2]$，$v = 3$。

此时会在 $[1,2]$ 上打上懒标记，但是又会出现一个新的问题：所以 $[1,2]$ 真实是增加 $6$ 而非增加 $3$。

为什么呐？原因是程序并没有把 $[1,3]$ 的懒标记传下来，所以我们需要一个「下传」函数，命其为 `pushdown`。

此时我们将 $u$ 的左、右儿子的懒标记都加上 $u$ 的懒标记，然后更改左、右儿子的区间和。

最最重要的，已经「下传」了，记得把 $u$ 的懒标记清零。

弄清楚懒标记和其下传后，我们给它一个名字：$lazy$（当然随情况 $add$ 也行）。

结构体如下：

```cpp
struct SGT{
  int l ,r ,sum ,lazy;//lazy 为懒标记。
}tr[N << 2];
```

`pushdown` 代码如下：

```cpp
inline void pushdown(int u){
//把节点 u 的懒标记「下传」到他的儿子。
  if(tr[u].lazy){//这个节点没有懒标记可以不「下传」。
/*左、右儿子懒标记分别加上 tr[u].lazy。*/
    tr[u << 1].lazy += tr[u].lazy;
	tr[u << 1 | 1].lazy += tr[u].lazy;
/*更改左、右儿子的区间和。*/
	tr[u << 1].sum += (tr[u << 1].r - tr[u << 1].l + 1) * tr[u].lazy;
	tr[u << 1 | 1].sum += (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1) * tr[u].lazy;
	tr[u].lazy = 0; //清空懒标记！
  }
}
```

效果如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/9mfw9j3y.png)

`update` 代码如下：

```cpp
inline void update(int u,int L,int R,int v){
//当前节点为 u，需要修改的区间为 [L,R]，需要增加 v。
  int l = tr[u].l ,r = tr[u].r;
  if(l >= L && r <= R){//节点对应的区间完全在修改区间内。
  	tr[u].sum += (tr[u].r - tr[u].l + 1) * v;//更改区间和。
  	tr[u].lazy += v;//增加懒标记。
  	return;
  }
  pushdown(u);//「下传」懒标记。
  int mid = ((l + r) >> 1);
/* 修改。
   注意：不能写 else，因为 L <= mid 的时也可能满足 mid < R。
*/
  if(L <= mid) update(u << 1 ,L ,R ,v);
  if(mid < R) update(u << 1 | 1, L , R ,v);
  pushup(u);//合并信息。
}
```

这样时间复杂度就为 $\mathcal O(\log n)$ 了。

单点查询
---

同理也很容易写出来，注意需要查询所以沿途的所有懒标记都要「**下传**」。

```cpp
inline int query(int u,int x){
//当前节点为 u，需要查询下标为 x。
  int l = tr[u].l ,r = tr[u].r;
  if(l == x) return tr[u].sum;
  pushdown(u);//下传懒标记。
  int mid = ((l + r) >> 1) ,val = 0;
/* 计算左、右子树答案。 */
  if(L <= mid) val += query(u << 1 ,L , R);
  if(mid < R) val += query(u << 1 | 1, L ,R);
  return val;
}
```

时间复杂度为 $\mathcal O(\log n)$。

区间查询
---

同理，稍微改一下就可以了。

```cpp
inline int query(int u,int L,int R){
//当前节点为 u，需要查询的区间为 [L ,R]。
  int l = tr[u].l ,r = tr[u].r;
  if(l >= L && r <= R) return tr[u].sum;//[L ,R] 如果包含 [l ,r] 就直接返回答案。
  pushdown(u);
  int mid = ((l + r) >> 1) ,val = 0;
  if(L <= mid) val += query(u << 1 ,L , R);
  if(mid < R) val += query(u << 1 | 1, L ,R);
  return val;
}
```

时间复杂度为 $\mathcal O(\log n)$。

完整代码
---

把上面的代码组合一下就可以了。

总体时间复杂度为 $\mathcal O(Q\log n)$，空间复杂度为 $\mathcal O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long	
#define up(i,x,y) for(register int i=x;i<=y;++i)

using namespace std;

inline int read(){int x=0;bool f=0;char ch=getchar();while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();return (f?-x:x);}
inline void write(int x){if(x<0)putchar('-'),x=-x;if(x>9)write(x/10);putchar(x%10|48);}
inline void writeln(int x){write(x),putchar('\n');}
inline void writesp(int x){write(x),putchar(' ');}

const int N = 1e5 + 10;
int n ,Q ,a[N];

struct SGT{int l ,r ,sum ,lazy;}tr[N << 2];
inline void pushup(int u){
  tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
} inline void pushdown(int u){
  if(tr[u].lazy){
    tr[u << 1].lazy += tr[u].lazy;
	tr[u << 1 | 1].lazy += tr[u].lazy;
	tr[u << 1].sum += (tr[u << 1].r - tr[u << 1].l + 1) * tr[u].lazy;
	tr[u << 1 | 1].sum += (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1) * tr[u].lazy;
	tr[u].lazy = 0; 
  }
}inline void build(int u,int L,int R){
  tr[u].l = L ,tr[u].r = R;
  if(L == R){tr[u].sum = a[L];return;}
  int mid = ((L + R) >> 1);
  build(u << 1 ,L ,mid);
  build(u << 1 | 1 ,mid + 1, R);
  pushup(u); 
} inline void update(int u,int L,int R,int v){
  int l = tr[u].l ,r = tr[u].r;
  if(l >= L && r <= R){
  	tr[u].sum += (tr[u].r - tr[u].l + 1) * v;
  	tr[u].lazy += v;
  	return;
  }
  pushdown(u);
  int mid = ((l + r) >> 1);
  if(L <= mid) update(u << 1 ,L ,R ,v);
  if(mid < R) update(u << 1 | 1, L , R ,v);
  pushup(u);
} inline int query(int u,int L,int R){
  int l = tr[u].l ,r = tr[u].r;
  if(l >= L && r <= R) return tr[u].sum;
  pushdown(u);
  int mid = ((l + r) >> 1) ,val = 0;
  if(L <= mid) val += query(u << 1 ,L , R);
  if(mid < R) val += query(u << 1 | 1, L ,R);
  return val;
}signed main(){
  n = read() , Q = read();
  up(i, 1 ,n) a[i] = read();
  build(1 ,1, n);
  while(Q --){
    int op = read() , L = read() , R = read();
    if(op == 1) {int v = read();update(1 ,L ,R ,v);}
    if(op == 2) writeln(query(1 ,L ,R)); 
  }
  return 0;
}

/*
Input:
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4

Output:
11
8
20
*/
```

回到[本题](https://www.luogu.com.cn/problem/P3373)
---

本题额外多了一个操作：**区间乘法**。

因此我们多维护一个懒标记 $mul$ 表示这个节点的儿子需要乘上的值，注意一开始 $\forall mul = 1$，而不是 $0$（原因很简单，不阐述了）。

考虑到乘法结合律：$(a+b)c = ac + bc$，多个数同理，所以区间和的维护不会有问题。

文字太多了，看代码注释吧：

```cpp
inline void pushdown(int u){
  tr[u << 1].sum = (tr[u].mul * tr[u << 1].sum 、*乘法懒标记对区间和的贡献，因为结合律所以没关系。*/ + (tr[u << 1].r - tr[u << 1].l + 1)*tr[u].add%p)%p;
  tr[u << 1 | 1].sum=(tr[u].mul * tr[u << 1 | 1].sum + (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1)*tr[u].add%p)%p;

/* 乘法懒标记下传。*/
  tr[u << 1].mul = (tr[u].mul * tr[u << 1].mul) % p;
  tr[u << 1 | 1].mul = (tr[u].mul * tr[u << 1 | 1].mul) % p;

/*加法懒标记下传。*/
  tr[u << 1].add=(tr[u].add + tr[u].mul * tr[u << 1].add/* 由于结合律所以对 add 无影响。*/) % p;
  tr[u << 1 | 1].add = (tr[u].add + tr[u].mul * tr[u << 1 | 1].add) % p;

  tr[u].add=0;tr[u].mul = 1;//懒标记清空。
}
// 所以结合律还是很重要。
```

还有注意地方是注意**取模**。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rrep(i,x,y) for(int i=x;i>=y;i--)
#define sc scanf
#define pr printf
inline int read(){int s=0,w=1;char c=getchar();while(!isdigit(c)){if(c=='-') w=-1;c=getchar();}while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s*w;}

const int N=1e5+10;
struct SGT{
  int l,r,sum,mul,add;
};
Tree tr[N << 2];

int n , Q , opt , p , x , y , k , a[N];
inline void pushup(int u){
  tr[u].sum=(tr[u << 1].sum + tr[u << 1 | 1].sum) % p;
}

inline void pushdown(int u){
  tr[u << 1].sum = (tr[u].mul * tr[u << 1].sum + (tr[u << 1].r - tr[u << 1].l + 1)*tr[u].add%p)%p;
  tr[u << 1 | 1].sum=(tr[u].mul * tr[u << 1 | 1].sum + (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1)*tr[u].add%p)%p;
  tr[u << 1].mul = (tr[u].mul * tr[u << 1].mul) % p;
  tr[u << 1 | 1].mul = (tr[u].mul * tr[u << 1 | 1].mul) % p;
  tr[u << 1].add=(tr[u].add + tr[u].mul * tr[u << 1].add) % p;
  tr[u << 1 | 1].add = (tr[u].add + tr[u].mul * tr[u << 1 | 1].add) % p;
  tr[u].add=0;tr[u].mul = 1;
}

inline void build(int u,int l,int r){
  tr[u].l=l;tr[u].r=r;tr[u].mul=1;
  if(l==r){
    tr[u].sum=a[l]%p;
    return;
  }
  int mid = ((l + r) >> 1);
  build(u << 1 , l , mid);
  build(u << 1 | 1 , mid + 1 , r);
  pushup(u);
}

inline void muls(int u,int L,int R,int d){//乘法操作。
  int l=tr[u].l , r = tr[u].r , mid = ((l + r) >> 1);
  if(l >= L && r <= R){
    tr[u].add = tr[u].add * d % p;
    tr[u].mul = tr[u].mul * d % p;
    tr[u].sum = tr[u].sum * d % p;//修改方式都 * d，add 和 sum 是因为结合律。（
    return;
  }
  pushdown(u);
  if(L <= mid) muls (u << 1 , L , R , d);
  if(mid < R) muls (u << 1 | 1 , L , R , d);
  pushup(u);
}

inline void adds(int u , int L , int R , int d){
  int l = tr[u].l , r = tr[u].r , mid = ((l + r) >> 1);
  if(l >= L && r <= R){
    tr[u].add = (tr[u].add + d) % p;
    tr[u].sum = (tr[u].sum + (tr[u].r - tr[u].l + 1) * k) % p;
    return;
  }
  pushdown(u);
  if(L <= mid) adds(u << 1 , L , R , d);
  if(mid < R) adds(u << 1 | 1, L , R , d);
  pushup(u);
}

inline int query(int u , int L , int R){
  int l = tr[u].l , r = tr[u].r , mid = ((l + r) >> 1);
  if(l >= L && r <= R) return tr[u].sum;
  pushdown(u);
  int val = 0;
  if(L <= mid) val = (val + query ( u << 1 , L , R) % p ) % p;
  if(mid < R) val = (val + query ( u << 1 | 1, L , R) % p ) % p;
  return val;
}

signed main(){
  n=read();Q=read();p=read();
  rep(i,1,n) a[i]=read();
  build(1,1,n);
  
  while(Q--){
    opt=read();x=read();y=read();
    if(opt == 1){
      k = read();
      muls (1 , x , y , k);
    }
    else if(opt == 2){
      k = read();
      adds (1 , x , y , k);
    }
    else pr("%lld\n" , query (1 , x , y));
  }
  return 0;
}
```

最后
---

模版题到此结束！

如果是区间异或、最值等只需要改一下 `pushup` 和 `pushdown` 还有 `update` 内的一些不固定代码。

区间翻转、反转等不会可以看别的题解，你会有一种突然悟了的感觉。

如果想要线段树打得很熟练，就要多打，每次打可以换题，也可以还是这道题，打多了就习惯了。

做多了你会发现最难的是 `pushdown`。（

~~如果有帮助请给个赞。~~

真的最后
---

如果你觉得二叉太慢了想写三叉完全没问题，虽然能节省时间但是代码细节增多，所需要空间也增多。

一般题目不会卡时限，所以二叉就足够了。

---

## 作者：_droplet_ (赞：5)

本题解使用 **动态开点线段树**。

## 方法
暴力时间复杂度 $O(n^2)$，肯定挂，考虑线段树。

## 复习线段树

线段树，将每一个区间分成个两个长度为 $\frac{len}{2}$ 的区间，下图是一棵长度 $n$ 为 $4$ 的线段树，每个点维护一个值 $val$。

![](https://cdn.luogu.com.cn/upload/image_hosting/7nxz6esh.png)

### 建树

对于每个线段 $x$，先建自己的子树，到最后一层时初始化 $val$，接下来更新上方的 $val$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ym5h97er.png)

### 修改

考虑对每个区间修改，发现时间复杂度 $O(n\log{n})$，比暴力还差。

考虑当这个修改覆盖这一整个区间时，使用懒标记 $tag$ 记录，当下次修改或查询时将懒标记下传给左右子数，别忘了更新上方的 $val$。

![](https://cdn.luogu.com.cn/upload/image_hosting/vk6l0os5.png)

### 查询

几乎与修改一样，这个查询覆盖这一整个区间时，直接返回 $val$，当下次修改或查询时将懒标记下传给左右子数。

![](https://cdn.luogu.com.cn/upload/image_hosting/58pc1jdt.png)

## 本题题解

考虑将 $tag$ 分成两个，加法标记 $add$ 和乘法标记 $mul$。其余同上。

### 注意事项

在下放 $add$ 标记时受 $mul$ 标记影响，更新 $val$ 时先乘后加。

$mul$ 初始化为 $1$。

在乘法时也要更新 $add$ 标记，相当于 $add$ 也变成了多倍。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=400010;
int n,q,m,a[N],rt,tc;
int ls[N],rs[N],val[N],add[N],mul[N];

void pushup(int x){ // 更新val，上传
	val[x]=(val[ls[x]]+val[rs[x]])%m;
}

void pushdown(int x,int l,int r){ // 更新 tag，下放（l,r 为区间左右端点）
	int mid=(l+r)>>1;
	val[ls[x]]=(val[ls[x]]*mul[x]+add[x]*(mid-l+1))%m; // 先乘后加
	val[rs[x]]=(val[rs[x]]*mul[x]+add[x]*(r-mid))%m;
	mul[ls[x]]=(mul[ls[x]]*mul[x])%m;
	mul[rs[x]]=(mul[rs[x]]*mul[x])%m;
	add[ls[x]]=(add[ls[x]]*mul[x]+add[x])%m; // add 更新受 mul 影响
	add[rs[x]]=(add[rs[x]]*mul[x]+add[x])%m;
	mul[x]=1;
	add[x]=0;
}

void build(int &x,int l,int r){ // 建树（l,r 为区间左右端点）
	x=++tc;
	add[x]=0;mul[x]=1; // 乘法初始化为 1
	if(l==r){
		val[x]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(ls[x],l,mid);
	build(rs[x],mid+1,r);
	pushup(x);
}

void update1(int x,int l,int r,int ql,int qr,int v){ // 乘法更新（l,r 为区间左右端点，ql,qr 为查询左右端点）
	if(ql<=l&&r<=qr){ // 整个区间在更新范围内，打 tag
		val[x]=(val[x]*v)%m;
		mul[x]=(mul[x]*v)%m;
		add[x]=(add[x]*v)%m; // add 标记也会被乘法更新
		return;
	}
	pushdown(x,l,r);
	int mid=(l+r)>>1;
	if(ql<=mid) update1(ls[x],l,mid,ql,qr,v);  // 若左子区间在更新范围内，更新
	if(mid<qr) update1(rs[x],mid+1,r,ql,qr,v); // 同上
	pushup(x);
}

void update2(int x,int l,int r,int ql,int qr,int v){ // 加法更新（l,r 为区间左右端点，ql,qr 为查询左右端点）
	if(ql<=l&&r<=qr){
		val[x]=(val[x]+v*(r-l+1))%m;
		add[x]=(add[x]+v)%m;
		return;
	}
	pushdown(x,l,r);
	int mid=(l+r)>>1;
	if(ql<=mid) update2(ls[x],l,mid,ql,qr,v);
	if(mid<qr) update2(rs[x],mid+1,r,ql,qr,v);
	pushup(x);
}

int query(int x,int l,int r,int ql,int qr){ // 查询（l,r 为区间左右端点，ql,qr 为查询左右端点）
	if(ql<=l&&r<=qr) return val[x];
	pushdown(x,l,r);
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid) ans=(ans+query(ls[x],l,mid,ql,qr))%m;
	if(mid<qr) ans=(ans+query(rs[x],mid+1,r,ql,qr))%m;
	return ans;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	build(rt,1,n);
	while(q--){
		int op,x,y,k;
		cin>>op>>x>>y;
		if(op==1){
			cin>>k;
			update1(rt,1,n,x,y,k);
		}else if(op==2){
			cin>>k;
			update2(rt,1,n,x,y,k);
		}else{
			cout<<query(rt,1,n,x,y)<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：4)

~~刚学习线段树肯定是要先写模板题。~~

如果你刚学习线段树，那么请先完成[模板题1](https://www.luogu.com.cn/problem/P3372)，再转移至此题。

### 算法介绍：
也许当你初学的时候，总是听到学习提高组的选手们提到线段树，所以可能会觉得线段树很难。

那么线段树到底是什么呢？

线段树是一个用来维护区间信息的数据结构。还有，线段树可以维护的内容需要满足可合并性。

一般来说，线段树都是构造成一棵二叉树。以维护区间和为例，线段树的结构如下图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/54ie2lbt.png)

如图所示，设一个区间的值为 $[1,2,3,4]$，$4$ 到 $7$ 号节点是叶子结点，赋初始值。$2$ 号节点表示的区间为 $[1,2]$，它的值为 $4$ 号节点和 $5$ 号节点之和。剩余节点同理。

### 过程：
如上文的图所示，我们要先将数组的值转化成树，也就是建树。学过二叉树的应该都知道，二叉树的一个节点 $x$ 的左右孩子分别为 $x \times 2$ 和 $x \times 2 + 1$。

以维护区间和为例。

建树：
考虑递归建树，具体实现如下：
```cpp
inline int ls(int x){return x<<1;}//左孩子，右移一位相当于乘2
inline int rs(int x){return x<<1|1;}//右孩子，因为乘以了2，二进制末尾为0，异或1相当于加1
inline void push_up(int x){ans[x]=ans[ls(x)]+ans[rs(x)];}//将节点x的两个孩子的值赋值到x节点上
inline void build(int x,int l,int r){//x号节点维护的区间为[l,r]
	if(l==r){//如果x号节点维护一个点，直接赋值
		ans[x]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(ls(x),l,mid);//左区间
	build(rs(x),mid+1,r);//右区间
	push_up(x);//合并
}
```
线段树的修改有两种，一种是区间修改，另一种是单点修改。类似的，查询有区间查询和单点查询。

单点修改：
首先单点修改，我们只要修改会受它影响的节点，也就是它的所有祖先结点，包括它自己。从节点 $1$ 开始，向左右子树递归，向所要修改的点靠近。时间复杂度 $\mathcal O(\log n)$。

具体代码实现：
```cpp
inline void update(int x,int nowl,int nowr,int y,int k){//x号节点维护的区间为[nowl,nowr]，修改的点为y
	if(l==nowl&&nowr==r){//找到x号节点
		ans[x]+=k;//x号节点加k
		return;
	}
	int mid=nowl+nowr>>1;//分成两个区间
	if(l<=mid)update(ls(x),nowl,mid,l,r,k);//向左子树寻找
	if(mid<r)update(rs(x),mid+1,nowr,l,r,k);//向右子树寻找
	push_up(x);//重新合并
}
```
区间修改：
其次区间修改就是修改一整个区间，那么可以运用上文的单点修改一个点一个点逐个修改过去，但是时间复杂度高，最坏情况能达到 $\mathcal O(n \log n)$。

由此考虑优化，给出懒标记的意义。

简单来说，懒标记的作用就是延迟修改的操作，在不必要的时候标记，必要时再更改。

那么什么是必要的时候和不必要的时候呢？

你可以这样想，一直修改但没有查询，这样你修改后没有意义，这就是不必要的时候，当你查询时，就可以利用所标记的懒标记求值，这是必要的时候。运用懒标记后时间复杂度为 $\mathcal O(\log n)$。

具体代码实现：
```cpp
inline void f(int x,int l,int r,int k){//更新左或右孩子的懒标记和所维护的区间值
	tag[x]+=k;
	ans[x]+=k*(r-l+1); 
}
inline void push_down(int x,int l,int r){
	int mid=l+r>>1;
	f(ls(x),l,mid,tag[x]);//传到左子树
	f(rs(x),mid+1,r,tag[x]);//传到右子树
	tag[x]=0;//清空标记
}
inline void update(int x,int nowl,int nowr,int l,int r,int k){//x号节点维护区间[nowl,nowr]，区间[l,r]内的每个值+k
	if(l<=nowl&&nowr<=r){//x号节点所维护的区间在所要修改的区间内
		ans[x]+=k*(nowr-nowl+1);//x号节点维护的区间长度为nowr-nowl+1，所以要加(nowr-nowl+1)个l
		tag[x]+=k;
		return;
	}
	push_down(x,nowl,nowr);//下传懒标记
	int mid=nowl+nowr>>1;
	if(l<=mid)update(ls(x),nowl,mid,l,r,k);//向左子树寻找
	if(mid<r)update(rs(x),mid+1,nowr,l,r,k);//向右子树寻找
	push_up(x);//重新合并
}
```

最后是查询，与修改类似。不多赘述，具体见代码。

单点查询：
```cpp
inline int query(int x,int nowl,int nowr,int y){//x号节点维护的区间为[nowl,nowr]，查询的点为y
	if(l==nowl&&nowr==r)return ans[x];
	int mid=nowl+nowr>>1,res=0;//分成两个区间
	if(l<=mid)res+=query(ls(x),nowl,mid,l,r);//向左子树寻找
	if(mid<r)query(rs(x),mid+1,nowr,l,r);//向右子树寻找
	return res;
}
```
区间查询：
```cpp
inline void f(int x,int l,int r,int k){//更新左或右孩子的懒标记和所维护的区间值
	tag[x]+=k;
	ans[x]+=k*(r-l+1); 
}
inline void push_down(int x,int l,int r){
	int mid=l+r>>1;
	f(ls(x),l,mid,tag[x]);//传到左子树
	f(rs(x),mid+1,r,tag[x]);//传到右子树
	tag[x]=0;//清空标记
}
inline void query(int x,int nowl,int nowr,int l,int r){//x号节点维护区间[nowl,nowr]，查询区间[l,r]内的每个值之和
	if(l<=nowl&&nowr<=r){return ans[x];}//x号节点所维护的区间在所要查询的区间内
	push_down(x,nowl,nowr);//下传懒标记
	int mid=nowl+nowr>>1;
	if(l<=mid)res+=query(ls(x),nowl,mid,l,r);//向左子树寻找
	if(mid<r)res+=query(rs(x),mid+1,nowr,l,r);//向右子树寻找
	return res;
}
```
时间复杂度都为 $\mathcal O(\log n)$。

线段树基本操作讲完了，现在回到这道题。
### 思路：
这道题有两种修改：
1. 区间 $[l,r]$ 中每个数乘以 $k$；
2. 区间 $[l,r]$ 中每个数加上 $k$。

那么修改时加一个懒标记维护乘法运算即可。

解释起来太麻烦，具体原因结合代码即注释：
```cpp
//注意取模
inline void f(int x,int l,int r,int k1,int k2){//k1为乘法懒标记，k2为加法懒标记
	ans[x]=(k1*ans[x]+(r-l+1)*k2%mod)%mod;//更新答案
/*
当区间乘以k时，两个懒标记以及答案都乘以k
当区间加上k时，只更新了答案和加法懒标记
所以答案更新时要先乘以乘法懒标记，再加上加法懒标记
否则更新后会得到错误的答案
*/
	(tag1[x]*=k1)%=mod;//更新乘法懒标记
	tag2[x]=(k2+k1*tag2[x])%mod;//更新加法懒标记
/*
证明：
设原值为x，原乘法懒标记为t1，原加法懒标记为t2
现乘法懒标记为T1，现加法懒标记为T2
则父节点懒标记下传前，修改后x为x*t1+t2*(r-l+1)
父节点懒标记下传后x为
(x*t1+t2*(r-l+1))*T1+T2*(r-l+1)
=x*t1*T1+T1*t2*(r-l+1)+T2*(r-l+1)
=x*t1*T1+(T1*t2+T2)*(r-l+1)
所以懒标记这样更新
*/
}
inline void push_down(int x,int l,int r){
//tag1是乘法懒标记,tag2是加法懒标记
	int mid=l+r>>1;
	f(ls(x),l,mid,tag1[x],tag2[x]);//懒标记下传到左子树
	f(rs(x),mid+1,r,tag1[x],tag2[x]);//懒标记下传到右子树
	tag1[x]=1,tag2[x]=0;//懒标记清空，乘法懒标记为1
}
```

最后的完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=1e5+5;
int n,m,mod;
int a[N];
int ans[N*4];
int tag1[N*4],tag2[N*4];
int ls(int x){return x<<1;}
int rs(int x){return x<<1|1;}
void push_up(int x){ans[x]=ans[ls(x)]+ans[rs(x)];}
void build(int x,int l,int r){
	tag1[x]=1;
	if(l==r){ans[x]=a[l];return;}
	int mid=l+r>>1;
	build(ls(x),l,mid);
	build(rs(x),mid+1,r);
	push_up(x);
}
inline void f(int x,int l,int r,int k1,int k2){
	ans[x]=(k1*ans[x]+(r-l+1)*k2%mod)%mod;
	(tag1[x]*=k1)%=mod;
	tag2[x]=(k2+k1*tag2[x])%mod;
}
inline void push_down(int x,int l,int r){
	int mid=l+r>>1;
	f(ls(x),l,mid,tag1[x],tag2[x]);
	f(rs(x),mid+1,r,tag1[x],tag2[x]);
	tag1[x]=1,tag2[x]=0;
}
inline void update1(int x,int nowl,int nowr,int l,int r,int k){
	if(l<=nowl&&nowr<=r){
		(ans[x]*=k)%=mod;
		(tag1[x]*=k)%=mod;
		(tag2[x]*=k)%=mod;
		return;
	}
	push_down(x,nowl,nowr);
	int mid=nowl+nowr>>1;
	if(l<=mid)update1(ls(x),nowl,mid,l,r,k);
	if(mid<r)update1(rs(x),mid+1,nowr,l,r,k);
	push_up(x);
}
inline void update2(int x,int nowl,int nowr,int l,int r,int k){
	if(l<=nowl&&nowr<=r){
		(ans[x]+=k*(nowr-nowl+1)%mod)%=mod;
		(tag2[x]+=k)%=mod;
		return;
	} 
	push_down(x,nowl,nowr);
	int mid=nowl+nowr>>1;
	if(l<=mid)update2(ls(x),nowl,mid,l,r,k);
	if(mid<r)update2(rs(x),mid+1,nowr,l,r,k);
	push_up(x); 
}
inline int query(int x,int nowl,int nowr,int l,int r){
	if(l<=nowl&&nowr<=r)return ans[x];
	int res=0;
	push_down(x,nowl,nowr);
	int mid=nowl+nowr>>1;
	if(l<=mid)(res+=query(ls(x),nowl,mid,l,r))%=mod;
	if(mid<r)(res+=query(rs(x),mid+1,nowr,l,r))%=mod;
	return res%mod; 
}
signed main(){
	IOS;
	cin>>n>>m>>mod;
	for(int i=1;i<=n;i++)cin>>a[i],a[i]%=mod;
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int op;
		cin>>op;
		if(op==1){
			int l,r,k;
			cin>>l>>r>>k;
			update1(1,1,n,l,r,k);
		}
		else if(op==2){
			int l,r,k;
			cin>>l>>r>>k;
			update2(1,1,n,l,r,k);
		}
		else{
			int l,r;
			cin>>l>>r;
			cout<<query(1,1,n,l,r)<<endl; 
		}
	}return 0;
}
```
最后，线段树并不难，只要你多写就能越来越熟练，并不需要背模板。

---

## 作者：zhou2414 (赞：3)

~~应该不会有人先做模板 $2$ 后做模板 $1$ 吧~~？

默认读者已会基础的线段树且完成了[【模板】线段树 $1$](https://www.luogu.com.cn/problem/P3372)，所以本篇题解重点解释懒标记的处理。
# 单点修改
众所周知，线段树可以高效地维护一段序列上某区间的信息。那么如果要修改某个值的信息怎么办？只要找到线段树上对应的叶子节点进行修改，然后沿途更新其祖先维护的信息即可，~~非常简单~~。
# 区间修改
## 思路
但是如果题目要求**区间**修改怎么办？

这时候如果按照单点修改的思路，一个一个节点地去修改，那么复杂度是 $O(nq\log{n})$ 的，这样明显会炸。那么如何优化呢？

发现线段树查询时，并不总会查到对应区间内的所有节点，也就是有些节点的值完全用不到。这给了我们启发，如果能够**只修改可能用到的节点**，或者在**用到该节点时再修改**，这样的话不就可以大大减少时间复杂度了吗？

那么如何实现呢？

我们可以在区间修改时，当发现某个节点管辖的区间完全在修改范围内时，对该节点进行修改，并打上一个标记，然后返回，如果查询时查到这个节点，就把这个的标记下放。这样，就可以避免浪费时间在不必要的节点修改上了。这种标记被称为**懒标记**。  
**注意不要忘记修改子节点的懒标记以及初始化当前节点的懒标记**。  
还有就是当有多个懒标记时，需要考虑**懒标记之间的相互影响**。
## 复杂度分析
此时的修改操作与查询操作十分类似，单次修改复杂度与查询一样，为 $O(\log n)$。  
下放懒标记的时间复杂为 $O(1)$，原因见实现方式。
## 实现
由于下放懒标记的方式需要结合题意，没有固定模板，就以本题为例介绍懒标记的下放。

对于本题而言，由于有加法和乘法两种操作，所以我们需要对加法和乘法**分别**维护一个懒标记，线段树维护区间和。

我用 $lj_i$ 表示节点 $i$ 对应的加法懒标记，用 $lc_i$ 表示节点 $i$ 对应的乘法懒标记。规定**先乘后加**。

当父节点的懒标记下放时，我们需要分别考虑乘法标记和加法标记对字节点标记的影响。

设子节点 $i$ **应用懒标记修改前**的值为 $x$，其管辖区间长度为 $len$ 那么字节点在应用懒标记修改后的值可以表示为：
$$
 x \cdot lc_i + lj_ilen
$$ 
 设其父节点为 $j$，当父节点的懒标记下放后，节点 $i$ 的值为：
$$
(x \cdot lc_i +lj_ilen)lc_j + lj_jlen
$$
化简可得：
$$
x \cdot lc_i lc_j + 
(lj_i lc_j +lj_j)len
$$
于是代码就很显然了。
### 更新加法懒标记
```cpp
lj[i] = (lj[i] * lc[j] + lj[j]) % m;
```
### 更新乘法懒标记
```cpp
lc[i] = (lc[i] * lc[j]) % m;
```
### 更新节点 $i$ 维护的值
```cpp
tr[i] = (tr[i] * lc[j] + lj[j] * len[i]) % m;
```
### push_down
将对两个儿子的三种修改合在一起，便有了这个函数：
```cpp
void pd(ll id) {//push_down
	lj[rson] = (lj[rson] * lc[id] + lj[id]) % m;
	lj[lson] = (lj[lson] * lc[id] + lj[id]) % m;
	lc[rson] = (lc[rson] * lc[id]) % m;
	lc[lson] = (lc[lson] * lc[id]) % m;
	c[lson] = (c[lson] * lc[id] + lj[id] * len[lson]) % m;
	c[rson] = (c[rson] * lc[id] + lj[id] * len[rson]) % m;
	lj[id] = 0;
	lc[id] = 1;//注意初始化父节点的懒标记
}//lson==(id*2),rson==(id*2+1)
```
其他就与普通线段树没有什么区别了。
# 完整代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define dd double
#define rson (id*2+1)
#define lson (id*2)
#define mid ((l+r)/2)
using namespace std;
ll sta__[100], stalen;
inline ll read() {
	ll x = 0, f = 1;char ch;
	while ((ch = getchar()) < 48 || ch > 57)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
inline void write(ll x, bool bo) {
	if (x < 0)putchar('-'), x = -x;
	do sta__[++stalen] = x % 10, x /= 10;
	while (x);
	while (stalen)putchar(sta__[stalen--] + 48);
	putchar(bo ? '\n' : ' ');
}
const ll N = 1e5+9;
ll n, q, m, tr[N * 4];
ll a[N];
ll len[N * 4];
ll lj[N * 4], lc[N * 4];
void pu(ll id) {//push_up
	tr[id] = (tr[rson] + tr[lson]) % m;
}
void pd(ll id) {//push_down
	lj[rson] = (lj[rson] * lc[id] + lj[id]) % m;
	lj[lson] = (lj[lson] * lc[id] + lj[id]) % m;
	lc[rson] = (lc[rson] * lc[id]) % m;
	lc[lson] = (lc[lson] * lc[id]) % m;
	tr[lson] = (tr[lson] * lc[id] + lj[id] * len[lson]) % m;
	tr[rson] = (tr[rson] * lc[id] + lj[id] * len[rson]) % m;
	lj[id] = 0;
	lc[id] = 1;//注意初始化父节点的懒标记
}
void build(ll id, ll l, ll r) {
	len[id] = r - l + 1;
	if (l == r) {
		tr[id] = a[l];
		return;
	}
	build(lson, l, mid);
	build(rson, mid + 1, r);
	pu(id);
}
void change(ll id, ll l, ll r, ll ql, ll qr, ll cheng, ll jia) {
	if (ql <= l && r <= qr) {
		tr[id] = (tr[id] * cheng + jia * len[id]) % m;
		lc[id] = (lc[id] * cheng) % m;
		lj[id] = (lj[id] * cheng + jia) % m;
		return;
	}
	if (l != r)pd(id);
	if (ql <= mid) {
		change(lson, l, mid, ql, qr, cheng, jia);
	}
	if (qr > mid) {
		change(rson, mid + 1, r, ql, qr, cheng, jia);
	}
	pu(id);
}
ll qu(ll id, ll l, ll r, ll ql, ll qr) {
	if (ql <= l && r <= qr) {
		return tr[id];
	}
	if (l != r)pd(id);
	ll ans = 0;
	if (qr > mid) {
		ans = (ans + qu(rson, mid + 1, r, ql, qr)) % m;
	}
	if (ql <= mid) {
		ans = (ans + qu(lson, l, mid, ql, qr)) % m;
	}
	return ans % m;
}
int main() {
	n = read(),q = read(),m = read();
	for (int i = 1; i <= N * 4; i++) {
		lc[i] = 1;
	}
	for (int i = 1; i <= n; i++) {
		a[i] = read();
	}
	build(1, 1, n);
	for (int i = 1; i <= q; i++) {
		ll kkk = read();
		if (kkk == 1) {
			ll x = read(), y = read(), k = read();
			change(1, 1, n, x, y, k, 0);
		}
		if (kkk == 2) {
			ll x = read(), y = read(), k = read();
			change(1, 1, n, x, y, 1, k);
		}
		if (kkk == 3) {
			ll x = read(), y = read();
			write(qu(1, 1, n, x, y),1);
		}
	}
	return 0;
}
```

---

## 作者：Chase12345 (赞：2)

# 引入
这道题我们需要维护区间加、区间乘、区间和，由于序列长度和询问次数都比较大，暴力显然不行。那么我们这里需要一种数据结构，维护区间。这正是线段树所能维护的东西。
# 介绍
线段树是一种二叉树数据结构，用于高效处理区间查询和区间更新操作。它将区间递归地划分为子区间，每个节点代表一个区间，并存储该区间的相关信息（如区间和、最大值等）。

对于长度为 $n$ 的序列，线段树就是一棵满二叉树，线段树高度为 $O(\log n)$，所以每次操作的复杂度为 $O(\log n)$，足以通过此题。
# 懒标记
## 懒标记介绍
对于每个修改操作，如果我们将所有标记下传到叶子，这会导致时间复杂度爆炸。所以我们能否有更优的标记方式？正如我所说，这就是懒标记。对于每个节点，我们维护它的乘法标记和加法标记，每次查询或修改需要用到这个标记之后再下传即可。由于我们每次操作都是从树根开始操作，所以每个标记都必定会正确传到某个节点。这样使得标记的时间复杂度是常数级别。
## 懒标记的顺序
这里懒标记的顺序并不能交换。当只有乘法标记或者加法标记的时候，直接下传。如果都有，请注意，需要先传乘法再传加法。证明如下：
> 假设有一个值 $x$，我们先加 $a$ 再乘 $m$，结果是 $(x + a) \times m$。而如果先乘 $m$ 再加 $a$，结果是 $x \times m + a$，这显然不等价。那么必须要通过先乘再加的传递方式进行传递。
# 操作方法
所有的操作我们都使用同样的结构：
1.  如果当前节点区间完全包含在目标区间内，直接更新或返回结果。
2.  否则，先下放标记，然后递归处理子节点。
3.  最后合并子节点的结果。

# 时间复杂度
如上已经分析。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
struct Tree {
	int l, r;
	long long sum, add, mul;
}tree[N << 2];
long long n, q, m, a[N];

void build(int p, int l, int r) {
	tree[p].l = l;
	tree[p].r = r;
	tree[p].mul = 1;
	if (l == r) {
		tree[p].sum = a[l];
		return;
	}
	int mid = l + r >> 1;
	build(p << 1, l, mid);
	build(p << 1 | 1, mid + 1, r);
	tree[p].sum = tree[p << 1].sum + tree[p << 1 | 1].sum;
}

void spread(int p) {
	if (tree[p].mul != 1) {
		tree[p << 1].sum = tree[p << 1].sum * tree[p].mul % m;
		tree[p << 1].add = tree[p << 1].add * tree[p].mul % m;
		tree[p << 1].mul = tree[p << 1].mul * tree[p].mul % m;
		tree[p << 1 | 1].sum = tree[p << 1 | 1].sum * tree[p].mul % m;
		tree[p << 1 | 1].add = tree[p << 1 | 1].add * tree[p].mul % m;
		tree[p << 1 | 1].mul = tree[p << 1 | 1].mul * tree[p].mul % m;
		tree[p].mul = 1;
	}
	if (tree[p].add) {
		tree[p << 1].sum = (tree[p << 1].sum + tree[p].add * (tree[p << 1].r - tree[p << 1].l + 1)) % m;
		tree[p << 1].add = (tree[p << 1].add + tree[p].add) % m;
		tree[p << 1 | 1].sum = (tree[p << 1 | 1].sum + tree[p].add * (tree[p << 1 | 1].r - tree[p << 1 | 1].l + 1)) % m;
		tree[p << 1 | 1].add = (tree[p << 1 | 1].add + tree[p].add) % m;
		tree[p].add = 0;
	}
}

void add(int p, int l, int r, long long k) {
	if (tree[p].r < l || tree[p].l > r)
		return;
	if (l <= tree[p].l && tree[p].r <= r) {
		tree[p].sum = (tree[p].sum + k * (tree[p].r - tree[p].l + 1)) % m;
		tree[p].add = (tree[p].add + k) % m;
		return;
	}
	spread(p);
	add(p << 1, l, r, k);
	add(p << 1 | 1, l, r, k);
	tree[p].sum = (tree[p << 1].sum + tree[p << 1 | 1].sum) % m;
}

void mul(int p, int l, int r, long long k) {
	if (tree[p].r < l || tree[p].l > r)
		return;
	if (l <= tree[p].l && tree[p].r <= r) {
		tree[p].sum = tree[p].sum * k % m;
		tree[p].add = tree[p].add * k % m;
		tree[p].mul = tree[p].mul * k % m;
		return;
	}
	spread(p);
	mul(p << 1, l, r, k);
	mul(p << 1 | 1, l, r, k);
	tree[p].sum = (tree[p << 1].sum + tree[p << 1 | 1].sum) % m;
}

long long query(int p, int l, int r) {
	if (tree[p].r < l || tree[p].l > r)
		return 0;
	if (l <= tree[p].l && tree[p].r <= r)
		return tree[p].sum % m;
	spread(p);
	return (query(p << 1, l, r) + query(p << 1 | 1, l, r)) % m;
}

int main() {
	cin >> n >> q >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	build(1, 1, n);
	while (q--) {
		int op, l, r;
		long long k;
		cin >> op >> l >> r;
		if (op == 1) {
			cin >> k;
			mul(1, l, r, k);
		} else if (op == 2) {
			cin >> k;
			add(1, l, r, k);
		} else
			cout << query(1, l, r) << '\n';
	}
}
```
# 提醒
在一道题中，树状数组的常数相对线段树小很多，如果树状数组比较好实现，最好不要用线段树。容易被卡常。

线段树空间需要开到 $n \times 4$ 的四倍，在 $n=2^k+1$ 的情况下，例如 $n=9$，需要 $31$ 个节点，接近 $4$ 倍。（如果你用的是动态开点的话当我没说）
# Update：
懒标记传递顺序有笔误，现已修改。

---

## 作者：寄风 (赞：2)

默认读者已经通过[线段树 1](https://www.luogu.com.cn/problem/P3372) 并初步了解线段树相关内容。

## 线段树的区间修改（懒标记的引入）
按照单点修改的方式去一个一个的暴力修改显然是不可接受的。

考虑如果一个节点被重复修改了很多次但是询问根本没用到这个节点，这样的修改是没有意义的。

而且对于一个节点如果被修改了很多次才被查询的话，我们真的有必要去一次一次的修改吗？

于是当修改信息可合并时，我们引入**懒标记**。

具体的，对于每一个线段树的节点，我们维护一个懒标记数组，表示在这个节点上生效的修改合并起来的总修改。因为修改信息是可以合并的，所以这个东西我们是可以维护的。

那么我们就可以在查询的时候直接查询多次修改的影响了，但是我们修改还是要一个一个的递归到叶子，还是不行的。

回顾线段树的本质，我们如果对于一个线段树节点更新了，那么它的子树节点也都会被更新。这显然是没有必要去暴力更新的。

考虑修改懒标记的定义为在这个节点**以及这个节点的子树**上生效的修改合并起来的总修改。

那么现在我们就可以在更新遇到要被更新的节点就在这个节点上打一个标记，查询时遇到要被查询的节点就更新这个节点的信息，直接下传即可。

那么我们就解决了线段树的区间修改问题。
## 线段树可处理的信息
通过维护一系列信息使得节点之间的信息可以快速合并，同时懒标记的一系列信息也可以快速合并，最后懒标记对节点信息的影响也可以快速处理。对于这些信息的合并，我会在代码部分再次讲解。

形式化的（若您是初学线段树可跳过这一段）：

实际上线段树维护的信息与懒标记所维护的信息实际上是两个半群信息 $(A,+)$ 与 $(B,\times)$，并且有运算 $*$ 使得 $\forall x\in A,y\in B$，都有 $x*y \in A$ 且 $*$ 运算对于半群 $A$ 具有分配律。

感性的理解就是节点信息和懒标记信息都要具有结合律并且可合并，同时懒标记信息对于节点信息的影响也要有分配律。

## 对于本题
我们可以考虑在线段树节点上维护当前区间的和，在懒标记上维护当前区间加了多少和乘了多少。具体可见代码部分的讲解。
## 代码部分
首先我们需要考虑在线段树上的节点维护什么信息。

一个简单的想法就是，维护一个变量 $x$ 表示当前线段树节点所代表的区间中的数的和。

那么值与值的信息就很好合并了，直接加起来即可。

具体写起来就是这个样子：
```cpp
struct info{//维护值的结构体
    int x;//当前区间的和
    info(int x = 0) : x(x){}
    friend info operator +(info a , info b){
        info res;
        res.x = a.x + b.x;
        res.x %= mod;
        return res;
    }
} d[N << 2];
```
然后我们考虑对于懒标记要维护什么。

一个同样简单的想法是维护当前区间加了多少和乘了多少，设为 $(x,y)$。

下文中 $X_A$ 表示 $A$ 标记的 $x$ 元素，$Y_A$ 同理。

那么标记与标记的信息也很好合并了，设标记 $A$ 先于标记 $B$ 发生，那么合并起来的信息就是 $(X_A\times Y_B+X_A,Y_A\times Y_B)$。

写起来大概是这个样子：
```cpp
struct tag{
    int add , mul;//加法标记，乘法标记
    tag(int add = 0 , int mul = 1) : add(add) , mul(mul){
    }
    friend tag operator +(tag a , tag b){//标记之间合并（默认标记 a 在标记 b 前发生）
        tag res;
        res.add = a.add * b.mul + b.add;
        res.mul = a.mul * b.mul;
        res.add %= mod , res.mul %= mod;
        return res;
    }
} b[N << 2];
```

但是你会发现这样子的话标记对信息的影响并不好处理。

考虑再在信息上维护一个 $siz$ 表示当前区间长度，这样子信息与信息的合并只要同时将长度加起来即可。

于是标记对信息的影响就好处理了，把乘标记乘了，再加上加标记即可。具体见下方代码。

```cpp
friend info operator +(info a , tag b){//信息与标记之间的合并
    info res;
    res.siz = a.siz;
    res.x = a.x * b.mul + b.add * a.siz;
    res.x %= mod;
    return res;
}
```

那么这个样子的话，线段树的三个关键点就被我们处理完了，剩下的直接照搬线段树 1 即可。

## 完整代码
因为线段树的修改和查询大家都会，所以对于重载好标记的线段树，修改与查询函数仅给出声明。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i , l , r) for(int i = l;i <= r;i++)
#define per(i , l , r) for(int i = l;i >= r;i--)
const int N = 1e5 + 5;
int mod;
namespace SGT{
    struct info{//维护值的结构体
        int x;//当前区间的和
        int siz;//当前区间的长度
        info(int x = 0) : x(x){
            siz = 1;
        }
        friend info operator +(info a , info b){
            info res;
            res.x = a.x + b.x;
            res.x %= mod;
            res.siz = a.siz + b.siz;
            return res;
        }
    } d[N << 2];
    struct tag{
        int add , mul;//加法标记，乘法标记
        tag(int add = 0 , int mul = 1) : add(add) , mul(mul){
        }
        friend tag operator +(tag a , tag b){//标记之间合并（默认标记 a 在标记 b 前发生）
            tag res;
            res.add = a.add * b.mul + b.add;
            res.mul = a.mul * b.mul;
            res.add %= mod , res.mul %= mod;
            return res;
        }
        friend info operator +(info a , tag b){//信息与标记之间的合并
            info res;
            res.siz = a.siz;
            res.x = a.x * b.mul + b.add * a.siz;
            res.x %= mod;
            return res;
        }
    } b[N << 2];
    #define ls (p << 1)
    #define rs (p << 1 | 1)
    inline void pushup(int p){
        d[p] = d[ls] + d[rs];
    }
    inline void pushdown(int p){
        d[ls] = d[ls] + b[p] , b[ls] = b[ls] + b[p];
        d[rs] = d[rs] + b[p] , b[rs] = b[rs] + b[p];
        b[p] = tag();
    }
    inline void build(int p , int l , int r , int *a){
        d[p] = info() , b[p] = tag();
        if(l == r){
            d[p] = info(a[l]);
            return ;
        }
        int mid = l + r >> 1;
        build(ls , l , mid , a) , build(rs , mid + 1 , r , a);
        pushup(p);
    }
    inline void update(int p , int l , int r , int s , int t , tag v);
    inline info query(int p , int l , int r , int s , int t);
    #undef ls
    #undef rs
};
int n , q , a[N];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    cin >> n >> q >> mod;
    rep(i , 1 , n) cin >> a[i];
    SGT::build(1 , 1 , n , a);
    rep(i , 1 , q){
        int op , l , r , k;
        cin >> op;
        if(op == 3){
            cin >> l >> r;
            SGT::info res = SGT::query(1 , l , r , 1 , n);
            cout << res.x << '\n';
            continue;
        }
        cin >> l >> r >> k;
        SGT::tag v = SGT::tag((op != 1) * k , (op != 2) * (k - 1) + 1);
        SGT::update(1 , l , r , 1 , n , v);
    }
    return 0;
}

---

## 作者：Eterna (赞：2)

### 算法介绍

线段树是一种基于分治的递归数据结构，可以快速处理许多区间问题，可以说是最重要的数据结构。

线段树所维护的询问需要满足区间可合并性，区间修改则需要考虑全局修改对询问结果的影响。

询问如：

$$\sum _{i=l}^{r} a_i=\sum _{i=l}^{mid} a_i +\sum _{i=mid+1}^{r} a_i,$$

$$\max _{i=l}^{r} a_i=\max(\max _{i=l}^{mid} a_i ,\max _{i=mid+1}^{r} a_i).$$

修改维护可行性与询问相关，所以不做枚举。


---

### 算法讲解


[例题 $1$](https://www.luogu.com.cn/problem/P1816)

> 已知一个数列，每次询问某个区间的最小值。
>
> $1 \le n,m \le {10}^5$。

如果暴力的话显然是 $O(nm)$，无法接受。

但是如果可以提前知道一些区间的最小值，在把询问区间拆成已知的区间在合并答案就可以快速的处理询问了。

线段树就是这样处理的，而线段树的结构（$n=6$）如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/reotsefm.png)

其中用 $[l,r]$ 表示区间，下文同。

用 $f(l,r)$ 表示区间 $[l,r]$ 的最小值，如果我们要求 $f(1,4)$，则有 $f(1,4)=\min(f(1,3),f(4,4))$，而
$f(1,3),f(4,4)$ 已知，所以可以快速得到答案。

又如 $f(2,5)=\min(f(2,3),f(4,4),f(5,5))$，$f(1,6)=f(1,6)$。

但是如何快速储存并查询这样的结构呢？

>如上图，我们发现线段树有一些空结点，使得线段树始终是满二叉树，所以我们采用满二叉树的命名方法。结点 $x$ 的左孩子是 $2x$，右孩子是 $2x+1$。

又如何快速找到这样的区间呢？

>首先，我们要知道线段树结点代表区间的规律。设某一结点代表了 $[l,r]$，又定义区间中点为 $\displaystyle mid=\lfloor \frac{l+r}{2} \rfloor$，则左孩子代表区间 $[l,mid]$，右孩子代表区间 $[mid+1,r]$。
>
>设询问区间为 $[l,r]$，如果我们到了一个代表 $[l',r']$ 的结点。
>有 $3$ 种情况：
>>1. 两个区间没有相交，表示为 $r'< l$ 或 $l'> r$。
>>2. 当前节点被询问区间完全包含，表示为 $l \le l' \le r' \le r$。
>>3. 其他情况，不满足上述条件即可。
>
>线段树一般采用递归的写法，从根结点向叶子结点
>
>第 $1$ 种不是合法的情况，返回一个极大值即可。
>
>第 $2$ 种代表找到了一个这样的区间，直接返回当前结点的区间所代表的最小值。
>
>第 $3$ 种代表有相交，但不包含，说明当前结点为根构成的子树上有满足条件的结点，暴力向两个孩子递归。

实现如下：


```cpp
int ask(int id,int l,int r,int x,int y)//id为结点编号，[l,r]为当前区间，[x,y]为询问区间 
	{
		if(y<l||x>r)return 1e9;//第一种情况 
		if(x<=l&&y>=r)return t[id];//第二种情况 
		int mid=(l+r)/2,ans=1e9;//第三种情况 
		ans=min(ans,ask(id*2,l,mid,x,y));
		ans=min(ans,ask(id*2+1,mid+1,r,x,y));
		return ans;	
	}
```

仔细想想你又会发现不太对劲，我们的线段树还没有值啊。

首先，对于所有的叶子结点 $[l,r]$，显然有 $l=r$，所以可以直接将其赋值为 $a_l$。非叶子结点也好办，如果两个孩子区间已经初始化完成，那么直接取两个子区间的最小值的最小值就可以了。

所以从下自上的初始化就可以做到 $O(n)$ 了，那么这题也就做完了。


---

 [例题 $2$](https://www.luogu.com.cn/problem/P3374)

> 已知一个数列，每次操作将某个数加上 $x$，或求出某区间每一个数的和。
>
> $1 \le n,m \le 5 \times {10}^5$。

区间求和与上面求 $\max$ 相同，但是我们发现他要求我们维护的序列是带修的。

对建树进行类比，直接递归到叶子结点暴力修改，然后从叶子结点一步步向上传递。

因为线段树大致是一颗满二叉树，层数是 $\log n$，所以如此修改是 $O(\log n)$。

 [例题 $3$](https://www.luogu.com.cn/problem/P3372)

> 已知一个数列，每次操作将某区间每一个数加上 $x$，或求出某区间每一个数的和。
>
> $1 \le n,m \le {10}^5$。

区间求和大家肯定已经会了。

区间加呢？有一个直观的想法，我们可以暴力递归到区间 $[l,r]$ 的叶子结点，然后暴力修改。复杂度显然 $O(n)$。

参考代码：


```cpp
void add(int id,int l,int r,int x,int y,int v)
{
	if(l==r)
	{
		sumv[id]+=v;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid)add(id<<1,l,mid,x,y,v);
	if(y>mid)add(id<<1|1,mid+1,r,x,y,v);
	pushup(id);
}
```

我们发现，递归过程中，有时会满足一种情况，就是当前节点的整个子树都被加了。根据一般的线段树的性质，可以看出，只有当当前递归区间 $[l',r']$ 是询问区间 $[l,r]$ 的子区间时，才会出现这种情况。反之同理，出现这种情况，必然是当前区间是询问区间的子区间。

对于子区间的判别显然有 $l \le l' \le r' \le r$。

引入一个 `lazy` 的概念，如果当前区间是这样的区间，我们对 `lazy+=x`，用来代表当前区间整体被加上了 $x$，而它对答案的影响是加上了 $(r'+l'+1)x$。这其实是对一个区间的全局操作，所以我在前面说区间修改则需要考虑全局修改对询问结果的影响。

但是再次对以此法修改过的区间的子区间再次操作时，会导致计算错误。我们需要对 `lazy` 进行一个下传，对当前节点的两个孩子区间全局加上 `lazy`，然后归零当前节点的 `lazy`。 

当对一个区间操作时，它会将目标区间拆成若干个区间，分别全局操作。所以操作复杂度是 $O(\log n)$。

故总复杂度可以做到 $O(m \log n)$。


---



[例题 $4$](https://www.luogu.com.cn/problem/P3373)

> 已知一个数列，每次操作将某区间每一个数加上 $x$，或将某区间每一个数乘上 $x$，或求出某区间每一个数的和。
>
> $1 \le n,q \le {10}^5$。

对于区间乘法，对加法简单类比就可以做到。但是既有加法，又有乘法不太好做。

若当前节点的乘法 `lazy` 值是 $x$，加法 `lazy` 值是 $y$，则记当前节点的 `lazy` 为二元组 $(x,y)$。代表使区间内每个数 $a_i \gets a_i x + y$。

若当前区间乘上了 $z$，则标记变为 $(a_i x + y)z = a_i x z + yz$，转换为二元组就是 $(xz,yz)$。也就是，乘法需要对乘法 `lazy` 和加法 `lazy` 同时乘上 $z$。

若当前区间加上了 $z$，则标记变为 $a_i x + y + z = a_i x + (y + z)$，转换为二元组就是 $(x,y+z)$。也就是，加法只需要对加法 `lazy` 加上 $z$。

按我们标记的定义，我们的标记下传应该先乘再加。


---


### 正确性证明

我们修改与查询时线段树选取的区间一定是操作区间的子区间。不难发现，只有选了两个节点在同一条从叶子节点到根的路径才会选择重复，而我们选择区间后就返回了，所以不可能选择区间不可能有交。线段树将区间划分到 $1$，不可能有选择不充分的情况。

所以，线段树可以不重复的选择最少区间表示已知区间。

### 代码实现

关于本题，其实就是[例题 $4$](https://www.luogu.com.cn/problem/P3373)。

最大问题就是取模不到位导致溢出，写代码的时候一定要多取模呀！


```cpp
#include<bits/stdc++.h>
#define N 100005
#define int long long
#define rd read()
#define gc getchar()
using namespace std;
int m,n,mod;
inline int read()
{
	register int x=0,ss=1,s=gc;
	while(!isdigit(s)&&s!='-')s=gc;
	if(s=='-')ss=-1,s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+(s^48),s=gc;
	return ss*x;
}
int lazy[N<<2],lazy2[N<<2],sumv[N<<2];
inline void pushup(int id){sumv[id]=(sumv[id<<1]+sumv[id<<1|1])%mod;}
inline void build(int id,int l,int r)
{
	lazy2[id]=1;
	if(l==r)return sumv[id]=rd,void();
	int mid=l+r>>1;
	build(id<<1,l,mid),build(id<<1|1,mid+1,r),pushup(id);
}
inline void push(int id,int L,int v){(lazy[id]+=v)%=mod,(sumv[id]+=L*v)%=mod;}
inline void push2(int id,int v){(lazy[id]*=v)%=mod,(lazy2[id]*=v)%=mod,(sumv[id]*=v)%=mod;}
inline void pushdown(int id,int l,int r)
{
	int mid=l+r>>1;
	if(lazy2[id]!=1)push2(id<<1,lazy2[id]),push2(id<<1|1,lazy2[id]),lazy2[id]=1;
	if(lazy[id])push(id<<1,mid-l+1,lazy[id]),push(id<<1|1,r-mid,lazy[id]),lazy[id]=0;
}
inline void update(int id,int l,int r,int x,int y,int v)
{
	if(l>=x&&r<=y)return push2(id,v);
	pushdown(id,l,r);int mid=l+r>>1;
	if(x<=mid)update(id<<1,l,mid,x,y,v);
	if(y>mid)update(id<<1|1,mid+1,r,x,y,v);
	pushup(id);
}
inline void insert(int id,int l,int r,int x,int y,int v)	
{
	if(l>=x&&r<=y)return push(id,r-l+1,v);
	pushdown(id,l,r);int mid=l+r>>1;
	if(x<=mid)insert(id<<1,l,mid,x,y,v);
	if(y>mid)insert(id<<1|1,mid+1,r,x,y,v);
	pushup(id);
}	
inline int ask(int id,int l,int r,int x,int y)
{
	if(l>=x&&r<=y)return sumv[id];
	pushdown(id,l,r);int ans=0,mid=l+r>>1;
	if(x<=mid)ans+=ask(id<<1,l,mid,x,y);
	if(y>mid)ans+=ask(id<<1|1,mid+1,r,x,y);
	return ans%mod;
}
signed main()
{
	n=rd,m=rd,mod=rd,build(1,1,n);
	for(int i=1,x,l,r;i<=m;i++)
	{
		x=rd,l=rd,r=rd;
		if(x==1)update(1,1,n,l,r,rd);
		if(x==2)insert(1,1,n,l,r,rd);
		if(x==3)cout<<ask(1,1,n,l,r)<<'\n';
	}
	return 0;
}
```

---

## 作者：chenxinyang2006 (赞：2)

本题的抄题解现象非常严重，因为我确实看到过不少线段树模板都默不出来的人AC了这道题，而本题的难度显然是要高上不少的

* 建树

和线段树1一样，不过建议处理一个len，表示区间长度，这样pushdown的时候写起来舒服。另外，本题需要两个lazy，**乘lazy一开始是1**

* 区间加

这个操作与乘显然没有关系，只要找到指定区间打个lazy，其他区间直接更新值就行了

* 查询

这个操作也很简单，和线段树1一样，不多讲

* pushdown

毒瘤操作，看一眼就知道要下传区间和，两个lazy

**区间和:**

本来这个区间的值是正确的，但是没有进行父节点的两个操作，所以就是：

$tree[ls].val = tree[ls].val * tree[rt].lazy[0] + tree[rt].lazy[1] * tree[ls].len$

$tree[rs].val = tree[rs].val * tree[rt].lazy[0] + tree[rt].lazy[1] * tree[rs].len$

$lazy[0]$是乘法，$lazy[1]$是加法

注意加是要乘上长度的，这里最容易错

**乘法lazy**

本来这个区间的乘lazy是正确的，但是没有进行过父节点的乘，所以：

$tree[ls].lazy[0] = tree[ls].lazy[0] * tree[rt].lazy[0]$

$tree[rs].lazy[0] = tree[rs].lazy[0] * tree[rt].lazy[0]$

**加法lazy**

本来这个区间的加lazy是正确的，但是没有进行过父节点的乘和**加**：

$tree[ls].lazy[1] = tree[ls].lazy[1] * tree[rt].lazy[0] + tree[rt].lazy[1]$

$tree[rs].lazy[1] = tree[rs].lazy[1] * tree[rt].lazy[0] + tree[rt].lazy[1]$

* 区间乘

略加思考，显然是没有办法在不完全包含$[x,y]$（即应该修改的区间)的时候计算出这个区间乘完之后的值，只能修改完左右区间pushup，这样就需要左右子区间的值，所以还要pushdown

这里推荐在打lazy前pushdown，这样lazy是唯一的，不用多考虑

应该修改的区间值直接乘k，**不用乘长度**

然后结束了，本题大常数线段树也可以过，不用卡常

```cpp
#include <cstdio>
#define ll long long
#define ls (rt * 2)
#define rs (rt * 2 + 1)
int n,m,p;

struct node{
	int len;
	ll val,lazy[2];
}tree[800005];

void pushup(int rt){
	tree[rt].val = (tree[ls].val + tree[rs].val) % p;
}

void pushdown(int rt){
    tree[ls].lazy[0] = (tree[ls].lazy[0] * tree[rt].lazy[0]) % p;
	tree[rs].lazy[0] = (tree[rs].lazy[0] * tree[rt].lazy[0]) % p;
	
	tree[ls].lazy[1] = (tree[ls].lazy[1] * tree[rt].lazy[0] + tree[rt].lazy[1]) % p;
	tree[rs].lazy[1] = (tree[rs].lazy[1] * tree[rt].lazy[0] + tree[rt].lazy[1]) % p;
	
	tree[ls].val = (tree[ls].val * tree[rt].lazy[0] + tree[rt].lazy[1] * tree[ls].len) % p;
	tree[rs].val = (tree[rs].val * tree[rt].lazy[0] + tree[rt].lazy[1] * tree[rs].len) % p;
	
	tree[rt].lazy[0] = 1;
	tree[rt].lazy[1] = 0;
}

void build(int rt,int l,int r){
	tree[rt].len = r - l + 1;
	tree[rt].lazy[0] = 1;
	tree[rt].lazy[1] = 0;
	if(l == r){
		scanf("%lld",&tree[rt].val);
		return;
	}
	int mid = l + r >> 1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(rt);
}

void upload(int rt,int l,int r,int L,int R,int C){
	pushdown(rt);
	if(l == L && r == R){
		tree[rt].val = (tree[rt].val * C) % p;
		tree[rt].lazy[0] = C;
		return;
	}
	int mid = l + r >> 1;
	if(R <= mid){
		upload(ls,l,mid,L,R,C);
	}else if(L > mid){
		upload(rs,mid+1,r,L,R,C);
	}else{
		upload(ls,l,mid,L,mid,C);
		upload(rs,mid+1,r,mid+1,R,C);
	}
	pushup(rt);
}

void slove(int rt,int l,int r,int L,int R,int C){
    pushdown(rt);
	if(l == L && r == R){
		tree[rt].val = (tree[rt].val + C * tree[rt].len) % p;
		tree[rt].lazy[1] = C;
		return;
	}
	int mid = l + r >> 1;
	if(R <= mid){
		slove(ls,l,mid,L,R,C);
	}else if(L > mid){
		slove(rs,mid+1,r,L,R,C);
	}else{
		slove(ls,l,mid,L,mid,C);
		slove(rs,mid+1,r,mid+1,R,C);
	}
	pushup(rt);
}

int query(int rt,int l,int r,int L,int R){
    pushdown(rt);
    if(l == L && r == R){
    	return tree[rt].val;
	}	
	int mid = l + r >> 1;
	if(R <= mid){
		return query(ls,l,mid,L,R);
	}else if(L > mid){
		return query(rs,mid+1,r,L,R);
	}else{
		return (query(ls,l,mid,L,mid) + query(rs,mid+1,r,mid+1,R)) % p;
	}
}

int main(){
	scanf("%d%d",&n,&p);
	build(1,1,n);
	scanf("%d",&m);
	int opt,x,y;
	ll k;
	for(int i = 1;i <= m;i++){
		scanf("%d%d%d",&opt,&x,&y);
		if(opt == 1){
			scanf("%lld",&k);
			upload(1,1,n,x,y,k % p);
		}else if(opt == 2){
			scanf("%lld",&k);
			slove(1,1,n,x,y,k % p);
		}else{
			printf("%d\n",query(1,1,n,x,y));
		}
	}
	return 0;
}
```

解释一下为什么开8倍：因为这样pushdown可能会push到神秘空间（长度为0的区间），不影响结果，但是会RE，所以再开两倍

本人很懒，所以加法是从乘法改的，用了大常数写法

---

## 作者：封禁用户 (赞：1)

题解：P3373 【模板】线段树 2
---
**一道练习线段树和懒标记的模板题目**。不了解线段树是什么的可以看看[这个博客](https://blog.csdn.net/weixin_45697774/article/details/104274713)或者是《深入浅出-进阶篇》，介绍得比较详细，这里只做简单介绍。

---

### 线段树介绍
线段树严格来讲并不是算法，而是一种类似于数据结构（栈、队列、二叉树等）的工具，它可以修改、维护区间，以达到简化时间复杂度，优化算法时间的目的，也就是降低到 $O(\log n)$。

### 懒标记介绍
那么线段树也可以和**懒标记**相结合，什么是懒标记呢？我们的目的是对于一个区间加上一个数，不妨在区间进行修改时为该区间打上一个标记，直到要使用它的子节点所要用的维护值时，再将懒标记下放，一定程度上进一步缩短了算法时间，高效完成！

---

### 本题思路
言归正传，我们来看看如何解决这道题目。

题目要求我们对一个数列进行三种操作，分别是：
- 将某区间每一个数乘上 $x$；
- 将某区间每一个数加上 $x$；
- 求出某区间每一个数的和。

在读入数据的时候，直接构建线段树数组，并建立两个懒标记数组，分别表示**区间乘因子**和**区间加因子**，也就是 ```mul[]``` 和 ```add[]```，在后面的代码片段会使用到。

建树过程中，如果区间只有一个元素，直接将该值赋给叶节点（记得取模），否则，将区间分成左右两部分，分别构造子树，然后节点的值为左右子树之和（再取模）。

---

### 懒标记下传
对于左右的节点，其区间和更新可以如下操作（代码骨架）：
```cpp
seg[child] = ( seg[child] * mul[idx] + add[idx] * child区间长度 ) % mod;
```

此处 ```idx``` 表示当前处理的**线段树节点编号**。

同时更新左右节点的懒标记（骨架）：
```cpp
mul[child] *= mul[idx] % mod;
add[child] = add[child] * mul[idx] + add[idx] %mod;
```

最后再清空当前节点的懒标记。

---

### 区间乘操作
如果当前结点的区间完全在更新区间内，则可以直接更新当前的节点：将节点和数组乘以 $k$（模 $m$），懒标记中的成因子数组乘以 $k$，加因子数组乘以 $k$；否则递归更新左右子区间，并重新计算结点和。
```cpp
void updM(int x, int l, int r, int ql, int qr, int k) {
    if (ql <= l && r <= qr) {
        s[x] = s[x] * k % mod;
        m[x] = m[x] * k % mod;
        ad[x] = ad[x] * k % mod;
        return;
    }
    pd(x, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid) updM(x << 1, l, mid, ql, qr, k);
    if (qr > mid) updM(x << 1 | 1, mid + 1, r, ql, qr, k);
    s[x] = (s[x << 1] + s[x << 1 | 1]) % mod;
}
```

---

### 区间加操作
和乘操作类似，只是每一次加上 $k$ 和区间长度的积（模 $m$），懒标记加因子累加 $k$，否则递归处理左右子区间。
```cpp
void updA(int x, int l, int r, int ql, int qr, int k) {
    if (ql <= l && r <= qr) {
        s[x] = (s[x] + (ll)k * (r - l + 1)) % mod;
        ad[x] = (ad[x] + k) % mod;
        return;
    }
    pd(x, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid) updA(x << 1, l, mid, ql, qr, k);
    if (qr > mid) updA(x << 1 | 1, mid + 1, r, ql, qr, k);
    s[x] = (s[x << 1] + s[x << 1 | 1]) % mod;
}
```

---

### 区间查询操作
殊途同归，同样的原理，如果完全覆盖，则直接输出和，否则下传懒标记并查询节点即可。
```cpp
ll qry(int x, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) return s[x] % mod;
    pd(x, l, r);
    int mid = (l + r) >> 1;
    ll res = 0;
    if (ql <= mid) res = (res + qry(x << 1, l, mid, ql, qr)) % mod;
    if (qr > mid) res = (res + qry(x << 1 | 1, mid + 1, r, ql, qr)) % mod;
    return res % mod;
}
```

---
### 代码
综合上述讲解，代码可以在 $O(q\log n)$ 的复杂度完成。
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n, q, mod;
vector<ll> a, s, m, ad;

void bld(int x, int l, int r) {
    if (l == r) {
        s[x] = a[l] % mod;
        return;
    }
    int mid = (l + r) >> 1;
    bld(x << 1, l, mid);
    bld(x << 1 | 1, mid + 1, r);
    s[x] = (s[x << 1] + s[x << 1 | 1]) % mod;
}

void pd(int x, int l, int r) {
    int mid = (l + r) >> 1, ls = x << 1, rs = x << 1 | 1;
    s[ls] = (s[ls] * m[x] % mod + ad[x] * (mid - l + 1) % mod) % mod;
    s[rs] = (s[rs] * m[x] % mod + ad[x] * (r - mid) % mod) % mod;
    m[ls] = (m[ls] * m[x]) % mod;
    ad[ls] = (ad[ls] * m[x] % mod + ad[x]) % mod;
    m[rs] = (m[rs] * m[x]) % mod;
    ad[rs] = (ad[rs] * m[x] % mod + ad[x]) % mod;
    m[x] = 1;
    ad[x] = 0;
}

void updM(int x, int l, int r, int ql, int qr, int k) {
    if (ql <= l && r <= qr) {
        s[x] = s[x] * k % mod;
        m[x] = m[x] * k % mod;
        ad[x] = ad[x] * k % mod;
        return;
    }
    pd(x, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid) updM(x << 1, l, mid, ql, qr, k);
    if (qr > mid) updM(x << 1 | 1, mid + 1, r, ql, qr, k);
    s[x] = (s[x << 1] + s[x << 1 | 1]) % mod;
}

void updA(int x, int l, int r, int ql, int qr, int k) {
    if (ql <= l && r <= qr) {
        s[x] = (s[x] + (ll)k * (r - l + 1)) % mod;
        ad[x] = (ad[x] + k) % mod;
        return;
    }
    pd(x, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid) updA(x << 1, l, mid, ql, qr, k);
    if (qr > mid) updA(x << 1 | 1, mid + 1, r, ql, qr, k);
    s[x] = (s[x << 1] + s[x << 1 | 1]) % mod;
}

ll qry(int x, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) return s[x] % mod;
    pd(x, l, r);
    int mid = (l + r) >> 1;
    ll res = 0;
    if (ql <= mid) res = (res + qry(x << 1, l, mid, ql, qr)) % mod;
    if (qr > mid) res = (res + qry(x << 1 | 1, mid + 1, r, ql, qr)) % mod;
    return res % mod;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> q >> mod;
    a.resize(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    s.resize(n << 2);
    m.assign(n << 2, 1);
    ad.assign(n << 2, 0);
    bld(1, 1, n);

    while (q--) {
        int op, l, r, k;
        cin >> op >> l >> r;
        if (op == 1) {
            cin >> k;
            updM(1, 1, n, l, r, k);
        } else if (op == 2) {
            cin >> k;
            updA(1, 1, n, l, r, k % mod);
        } else {
            cout << qry(1, 1, n, l, r) % mod << "\n";
        }
    }
    return 0;
}
```
感谢观看。

### 参考文献
[线段树（懒标记）](https://blog.csdn.net/SZTU_ZJB/article/details/117172417)，[线段树 从入门到进阶（超清晰，简单易懂）](https://blog.csdn.net/weixin_45697774/article/details/104274713)。

---

## 作者：wyc0607 (赞：1)

## 题解：P3373【模板】线段树 2。

建议在此之前，先做[【模板】线段树 1（P3372）](https://www.luogu.com.cn/problem/P3372)。

### 算法：字如其名，我们用线段树解决。

与 P3372 对比一下，发现多了取模和乘法。

取模很简单，在每一个操作时都取模即可。

**但问题来了，乘法操作如何完成呢？**

观察 P3372，我们用的是懒标记维护，所以我们乘法也考虑用懒标记。

我直接从代码来讲。

**build 函数。**

先初始化左右儿子，乘法懒标记为 1。

如果区间左节点等于右节点，赋值该区间的和。

接着递归建树即可。

**由于乘法优先级比加法高，所以我们先处理乘法。**  
证明：   
数学中乘法的优先级天然高于加法。若在懒标记处理中颠倒顺序，会导致逻辑错误。  
例如：当前有表达式 $sum \times mu + add$ 。
若先处理加法，表达式会变为 $(sum + add) \times mu$，但正确的计算应为 $sum \times mu + add$。

**spread 函数。**

这个函数负责下传懒标记。

```cpp
tr[i*2].sum=(tr[i].mu*tr[i*2].sum)%m;//乘法。
tr[i*2].sum+=((tr[i*2].rs-tr[i*2].ls+1)*tr[i].add)%m;//加法。
tr[i*2].sum%=m;
tr[i*2+1].sum=(tr[i].mu*tr[i*2+1].sum)%m;//乘法。
tr[i*2+1].sum+=((tr[i*2+1].rs-tr[i*2+1].ls+1)*tr[i].add)%m;//加法。
tr[i*2+1].sum%=m;
```
- 首先是区间和的维护。

对于一个节点的两个子节点，每个的和乘以父节点的乘法懒标记（乘法的优先级高，所以可以直接乘）。

加法与 P3372 相同，不多赘述。

- 接着是懒标记的下传。

乘法的懒标记直接往下乘即可。

加法的懒标记与 P3372 略有不同。由于此处多了乘法，需要 **先将子节点的加法懒标记乘以当前节点的乘法懒标记**，再加上当前节点的加法懒标记。

- 最后是复原。

将当前节点的加法懒标记清零，乘法懒标记设为一，spread 函数就完美结束了！

**mul 函数**

除了 `tr[i].ls>=l&&tr[i].rs<=r` 部分，其他与 P3372 相同。

将加法懒标记 **（乘法优先级比加法高，会影响到加法）**，乘法懒标记，区间和都乘以所给值即可。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct TR {
	int ls,rs,sum,add,mu;//左儿子，右儿子，区间和，加法懒标记，乘法懒标记。
} tr[4000005];
int n,m,q,a[1000005];
void build(int i,int l,int r) {
	tr[i].ls=l;
	tr[i].rs=r;
	tr[i].mu=1;
	if(l==r) {
		tr[i].sum=a[l]%m;
		return;
	}
	int mid=(l+r)/2;
	build(i*2,l,mid);
	build(i*2+1,mid+1,r);
	tr[i].sum=(tr[i*2].sum+tr[i*2+1].sum)%m;
}
void spread(int i) {
	tr[i*2].sum=(tr[i].mu*tr[i*2].sum+((tr[i*2].rs-tr[i*2].ls+1)*tr[i].add)%m)%m;
	tr[i*2+1].sum=(tr[i].mu*tr[i*2+1].sum+((tr[i*2+1].rs-tr[i*2+1].ls+1)*tr[i].add)%m)%m;

	tr[i*2].mu=(tr[i*2].mu*tr[i].mu)%m;
	tr[i*2+1].mu=(tr[i*2+1].mu*tr[i].mu)%m;

	tr[i*2].add=(tr[i*2].add*tr[i].mu+tr[i].add)%m;
	tr[i*2+1].add=(tr[i*2+1].add*tr[i].mu+tr[i].add)%m;

	tr[i].mu=1;
	tr[i].add=0;
}
void add(int i,int l,int r,int k) {
	if(tr[i].ls>=l&&tr[i].rs<=r) {
		tr[i].sum=(tr[i].sum+(tr[i].rs-tr[i].ls+1)*k)%m;
		tr[i].add=(tr[i].add+k)%m;
		return;
	}
	spread(i);
	tr[i].sum=(tr[i*2].sum+tr[i*2+1].sum)%m;
	if(tr[i*2].rs>=l) add(i*2,l,r,k);
	if(tr[i*2+1].ls<=r) add(i*2+1,l,r,k);
	tr[i].sum=(tr[i*2].sum+tr[i*2+1].sum)%m;
}
void mu(int i,int l,int r,int k) {
	if(tr[i].ls>=l&&tr[i].rs<=r) {
		tr[i].add=(tr[i].add*k)%m;
		tr[i].sum=(tr[i].sum*k)%m;
		tr[i].mu=(tr[i].mu*k)%m;
		return;
	}
	spread(i);
	tr[i].sum=(tr[i*2].sum+tr[i*2+1].sum)%m;
	if(tr[i*2].rs>=l) mu(i*2,l,r,k);
	if(tr[i*2+1].ls<=r) mu(i*2+1,l,r,k);
	tr[i].sum=(tr[i*2].sum+tr[i*2+1].sum)%m;
}
int query(int i,int l,int r) {
	if(tr[i].ls>=l&&tr[i].rs<=r) return tr[i].sum;
	spread(i);
	int ans=0;
	if(tr[i*2].rs>=l) ans=(ans+query(i*2,l,r))%m;
	if(tr[i*2+1].ls<=r) ans=(ans+query(i*2+1,l,r))%m;
	return ans;
}
main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>q>>m;
	for(int i=1; i<=n; i++) cin>>a[i];
	build(1,1,n);
	while(q--) {
		int op;
		cin>>op;
		if(op==1) {
			int x,y,k;
			cin>>x>>y>>k;
			mu(1,x,y,k);
		} else if(op==2) {
			int x,y,k;
			cin>>x>>y>>k;
			add(1,x,y,k);
		} else {
			int x,y;
			cin>>x>>y;
			cout<<query(1,x,y)<<'\n';
		}
	}
}
```

---

## 作者：longyitongxue (赞：1)

# 正文前提示
![](https://cdn.luogu.com.cn/upload/image_hosting/x6t7g91k.png)
- - -
[题目传送门](https://www.luogu.com.cn/problem/P3373)
# 主要思路
其实，就是在[线段树 $1$](https://www.luogu.com.cn/problem/P3372) 的基础上加上了一个乘法。
# 具体做法
## Step $\mathbf1$：主函数逻辑
读入 $n$ 个数，建树，接下来 $q$ 次操作，是 $1$ 就将区间做乘法，是 $2$ 就将区间做加法，是 $3$ 就输出区间和。

主要代码：

```cpp
    LL n,q;
    scanf("%lld%lld%lld",&n,&q,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&w[i]);
    }
    build(1,1,n);//建树
    while(q--){
        int op;
        scanf("%d",&op);
        if(op==1){
            LL x,y,k;
            scanf("%lld%lld%lld",&x,&y,&k);
            update(1,x,y,k,0);//从节点 1 开始，范围是 x ~ y，给每一个数乘 k，给每一个数加 0。
        }else if(op==2){
            LL x,y,k;
            scanf("%lld%lld%lld",&x,&y,&k);
            update(1,x,y,1,k);//从节点 1 开始，范围是 x ~ y，给每一个数乘 1，给每一个数加 k。
        }else{
            LL x,y;
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",query(1,x,y));//从节点 1 开始，范围是 x ~ y，查询区间和。
        }
    }
```
## Step $\mathbf2$：建树
先声明这个节点的范围是 $l\sim r$ 的；其次，把这个节点的 $sum$ 初值置为 $w_l$ 或 $w_r$（你爱写哪个写哪个）；接着，把乘的懒标记赋好 $1$ 的初值，加的懒标记赋好 $0$ 的初值；然后，判断当前是否为叶子结点（$l$ 是不是等于 $r$），如果是，返回，否则递归建立左右子树直到当前节点变成叶子结点为止；最后，把左右ㄦ子的 $sum$ 累加到父亲那里去。

主要代码：

```cpp
void pushup(LL p){
    tr[p].sum=(tr[lc].sum+tr[rc].sum)%m;//把左右ㄦ子的和都累加过来。
}
void build(LL p,LL l,LL r){
    tr[p]={l,r,w[r],1,0};
    if(l==r)return;
    LL mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
    pushup(p);
}
```

## Step $\mathbf3$：`update`（更新函数）逻辑
首先，如果越界了，赶快返回；其次，如果当前节点范围完全覆盖需要更新的部分，使用 `calc` 函数更新线段树后立即返回；接着，下传懒标记；然后，更新左右ㄦ子；最后，把左右ㄦ子的 $sum$ 累加到父亲那里去。**特别强调！！！更新的范围和节点的范围是不一样的！更新的范围始终保持不变！！！**

这里讲一下 `calc` 函数怎么写。首先，这个函数是用来维护区间和和两个懒标记的。注意：需要先乘后加才能保证精度不丢失，因为先加后乘的话，新的 $t.add$ 就会是 $t.add+\dfrac{add}{mul}$，如果 $\dfrac{add}{mul}$ 不是整数，那么精度将丢失。子节点新的 $t.mul$ 为 $t.mul \times mul$，新的 $t.add$ 为 $t.add\times mul+add$。这里还得计算 $t.sum$。我们推出一个公式来计算它：$\left(x_l\times mul+add\right)+\cdots+\left(x_r\times mul+add\right)$，化简后就是：
$$
\begin{align}
  & \left(x_l\times mul+add\right)+\cdots+\left(x_r\times mul+add\right)\\
= & \left(x_l+\cdots+x_r\right)\times mul+\left(r-l+1\right) \times add\\
= & t.sum\times mul+\left(r-l+1\right) \times add
\end{align}
$$

主要代码：
```cpp
void calc(node &t/*一定要传引用，不然无法修改 tr 数组*/,LL mul,LL add){
    t.sum=(t.sum*mul+(t.r-t.l+1)*add)%m;
    t.mul=t.mul*mul%m;      //⎫
//                             先乘后加，否则精度丢失
//                            ⎬新的 mul 为 mul × m，新的 add 为 add × m + a。
    t.add=(t.add*mul+add)%m;//⎭
}
void pushdown(LL p){//下传懒标记
    calc(tr[lc],tr[p].mul,tr[p].add);
    calc(tr[rc],tr[p].mul,tr[p].add);
    tr[p].mul=1;//⎫
//                 清空懒标记
//                ⎬
    tr[p].add=0;//⎭
}
void update(LL p,LL l,LL r,LL mul,LL add){
    if(tr[p].r<l||tr[p].l>r)return;//越界
    if(l<=tr[p].l&&tr[p].r<=r){//完全覆盖
        calc(tr[p],mul,add);
        return;
    }
    pushdown(p);
    update(lc,l,r,mul,add);
    update(rc,l,r,mul,add);
    pushup(p);
}
```
## Step $\mathbf4$：`query` 查询函数
首先，如果越界了，赶快返回；接着，如果当前节点范围完全覆盖需要更新的部分，返回当前节点的 $sum$ 值；然后，下传懒标记；最后，返回左ㄦ子的查询结果和右ㄦ子的查询结果的和。

```cpp
LL query(LL p,LL l,LL r){
    if(tr[p].r<l||tr[p].l>r)return 0;//越界
    if(l<=tr[p].l&&tr[p].r<=r){//完全覆盖
        return tr[p].sum%m;
    }
    pushdown(p);
    return (query(lc,l,r)+query(rc,l,r))%m;
}
```
# [AC](https://www.luogu.com.cn/record/210989422) 代码：

```cpp
#include<iostream>
#include<stdio.h>
#define LL long long
#define lc p<<1   //左ㄦ子
#define rc p<<1|1 //右ㄦ子
using namespace std;
LL m,w[100005];
struct node{
    LL l,r,sum,mul,add;
}tr[400005];//大小是 w 数组的 4 倍。
void pushup(LL p){
    tr[p].sum=(tr[lc].sum+tr[rc].sum)%m;//把左右ㄦ子的和都累加过来。
}
void calc(node &t/*一定要传引用，不然无法修改 tr 数组*/,LL mul,LL add){
    t.sum=(t.sum*mul+(t.r-t.l+1)*add)%m;
    t.mul=t.mul*mul%m;      //⎫
//                             先乘后加，否则精度丢失
//                            ⎬新的 mul 为 mul × m，新的 add 为 add × m + a。
    t.add=(t.add*mul+add)%m;//⎭
}
void pushdown(LL p){//下传懒标记
    calc(tr[lc],tr[p].mul,tr[p].add);
    calc(tr[rc],tr[p].mul,tr[p].add);
    tr[p].mul=1;//⎫
//                 清空懒标记
//                ⎬
    tr[p].add=0;//⎭
}
void build(LL p,LL l,LL r){
    tr[p]={l,r,w[r],1,0};
    if(l==r)return;
    LL mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
    pushup(p);
}
void update(LL p,LL l,LL r,LL mul,LL add){
    if(tr[p].r<l||tr[p].l>r)return;//越界
    if(l<=tr[p].l&&tr[p].r<=r){//完全覆盖
        calc(tr[p],mul,add);
        return;
    }
    pushdown(p);
    update(lc,l,r,mul,add);
    update(rc,l,r,mul,add);
    pushup(p);
}
LL query(LL p,LL l,LL r){
    if(tr[p].r<l||tr[p].l>r)return 0;//越界
    if(l<=tr[p].l&&tr[p].r<=r){//完全覆盖
        return tr[p].sum%m;
    }
    pushdown(p);
    return (query(lc,l,r)+query(rc,l,r))%m;
}
int main(){
    LL n,q;
    scanf("%lld%lld%lld",&n,&q,&m);
    for(int i=1;i<=n;i++){
        scanf("%lld",&w[i]);
    }
    build(1,1,n);//建树
    while(q--){
        int op;
        scanf("%d",&op);
        if(op==1){
            LL x,y,k;
            scanf("%lld%lld%lld",&x,&y,&k);
            update(1,x,y,k,0);//从节点 1 开始，范围是 x ~ y，给每一个数乘 k，给每一个数加 0。
        }else if(op==2){
            LL x,y,k;
            scanf("%lld%lld%lld",&x,&y,&k);
            update(1,x,y,1,k);//从节点 1 开始，范围是 x ~ y，给每一个数乘 1，给每一个数加 k。
        }else{
            LL x,y;
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",query(1,x,y));//从节点 1 开始，范围是 x ~ y，查询区间和。
        }
    }
    return 0;
}
```
# 正文后闲话
其实，这道题你想用暴力枚举过这道题也~~没问题~~，注意超时就行。

---

## 作者：GeXiaoWei (赞：0)

# P3373 【模板】线段树 2
## 题目大意
对一个数列进行某区间每一个数乘上 $x$ 或加上 $x$，求区间和。
## 解析
本题有三种操作，我们先看第二个操作，将某区间每一个数加上 $x$，这时只需在原来线段树的基础上再维护一个 $lazy$ 数组表示为加法懒标记。每次区间修改如果把整棵树上所有关于修改区间的节点都修改的话，**时间就超了**，几乎就是用数组进行暴力。因此我们将整个区间对应的节点的 $lazy$ 懒标记加上当前区间每个数需加的值，每次进行第三个操作（求区间和）时随着对树其余节点进行进一步修改即可（修改在讲操作 $3$ 时详细说明）。

第一种操作与第二种操作差不多，也要维护一个 $lazy$ 懒标记。但这里是乘法，所以这个 $lazy$ 需**先赋初始值为** $1$。此外，进行乘法操作时，加法操作懒标记也要乘上当前操作需乘的数。随后每次乘上一个当前操作需乘的数即可。

那么现在我们就可以在更新遇到要被更新的节点就在这个节点上打一个标记，查询时遇到要被查询的节点就更新这个节点的信息，直接下传即可。这也使我们的代码不会超时。

最后是第三种操作，我们设给定的区间左端点为 $l$，右端点为 $r$，那么我们从线段树的根节点开始找区间，如果左儿子区间在我们查找区间之内，那么就加上该区间的区间和。如果上述条件不成立，且左儿子区间包含我们的查找区间，那么就向左儿子查找。右儿子同理。

此外，进行第三种操作时，也要将懒标记数组的值清空了。注意要先处理乘法操作的懒标记数组，并且加法懒标记数组也要在乘上当前乘法操作的懒标记数组的值，随后再处理加法懒标记数组。

最后提醒一点：**勿忘取模**！
## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f
using namespace std;
const int N=1e6+5;
int n,m,a[N],q;
struct node{
	int L,R;
	ll sum;
	ll lazy,lazy2;
}st[N<<2];
void pushup(int root){
	st[root].sum=(st[root<<1].sum+st[root<<1|1].sum+m)%m;
}void pushdown(int root){
	if(st[root].lazy2!=1){
		st[root<<1].sum=(st[root<<1].sum*st[root].lazy2%m+m)%m;
		st[root<<1].lazy=(st[root<<1].lazy*st[root].lazy2%m+m)%m;
		st[root<<1].lazy2=(st[root<<1].lazy2*st[root].lazy2%m+m)%m;
		st[root<<1|1].sum=(st[root<<1|1].sum*st[root].lazy2%m+m)%m;
		st[root<<1|1].lazy=(st[root<<1|1].lazy*st[root].lazy2%m+m)%m;
		st[root<<1|1].lazy2=(st[root<<1|1].lazy2*st[root].lazy2%m+m)%m;
		st[root].lazy2=1;
	}
	if(st[root].lazy){
		st[root<<1].sum=(st[root<<1].sum+(st[root<<1].R-st[root<<1].L+1)*st[root].lazy%m+m)%m;
		st[root<<1].lazy=(st[root<<1].lazy+st[root].lazy+m)%m;
		st[root<<1|1].sum=(st[root<<1|1].sum+(st[root<<1|1].R-st[root<<1|1].L+1)*st[root].lazy%m+m)%m;
		st[root<<1|1].lazy=(st[root<<1|1].lazy+st[root].lazy+m)%m;
		st[root].lazy=0;
	}
}void build(int root,int L,int R){
	st[root].L=L,st[root].R=R;
    st[root].lazy=0,st[root].lazy2=1;
	if(L==R){
		st[root].sum=a[L];
		return ;
	}int mid=L+R>>1;
	build(root<<1,L,mid);
	build(root<<1|1,mid+1,R);
	pushup(root);
}ll query(int root,int L,int R,int l,int r){
	if(l<=L&&r>=R) return (st[root].sum%m+m)%m;
	pushdown(root);
	ll mid=L+R>>1,summ=0;
	if(l<=mid) summ=(summ+(query(root<<1,L,mid,l,r)+m)%m+m)%m;
	if(r>=mid+1) summ=(summ+(query(root<<1|1,mid+1,R,l,r)+m)%m+m)%m;
	return summ;
}void lrupdate(int root,int L,int R,int l,int r,int val){
	if(l<=L&&r>=R){
		st[root].sum=(st[root].sum+(st[root].R-st[root].L+1)*val%m+m)%m;
		st[root].lazy=(st[root].lazy+val+m)%m;
		return ;
	}pushdown(root);
	int mid=L+R>>1;
	if(l<=mid) lrupdate(root<<1,L,mid,l,r,val);
	if(r>=mid+1) lrupdate(root<<1|1,mid+1,R,l,r,val);
	pushup(root);
}void lr2update(int root,int L,int R,int l,int r,int val){
	if(l<=L&&r>=R){
		st[root].sum=(st[root].sum*val%m+m)%m;
		st[root].lazy=(st[root].lazy*val%m+m)%m;
		st[root].lazy2=(st[root].lazy2*val%m+m)%m;
		return ;
	}pushdown(root);
	int mid=L+R>>1;
	if(l<=mid) lr2update(root<<1,L,mid,l,r,val);
	if(r>=mid+1) lr2update(root<<1|1,mid+1,R,l,r,val);
	pushup(root);
}int main(){
	scanf("%d%d%d",&n,&q,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	build(1,1,n);
	while(q--){
	    int x,y,z,h;
	    scanf("%d%d%d",&x,&y,&z);
	    if(x==1){
	    	scanf("%d",&h);
	    	h%=m;
	    	lr2update(1,1,n,y,z,h);
		}else if(x==2){
	    	scanf("%d",&h);
	    	h%=m;
	        lrupdate(1,1,n,y,z,h);
		}else printf("%lld\n",query(1,1,n,y,z));
	}return 0;
}
```

---


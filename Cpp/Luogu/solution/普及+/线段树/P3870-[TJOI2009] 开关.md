# [TJOI2009] 开关

## 题目描述

现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。

操作分为两种：

1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；
2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。

**灯在初始时都是关着的。**

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2\le n\le 10^5$，$1\le m\le 10^5$，$1\le a,b\le n$，$c\in\{0,1\}$。

## 样例 #1

### 输入

```
4 5
0 1 2
0 2 4
1 2 3
0 2 4
1 1 4
```

### 输出

```
1
2```

# 题解

## 作者：一把丶抱住鑫 (赞：122)


大佬们的变量看起来都好冗杂，还一直说简单，说真的对于蒟蒻来说，这个题真的不算简单，本蒟蒻看着题解，苦苦钻研3个小时，才AC。

下面让我站在蒟蒻的角度讲解一下这道所谓的“板子”题。

很多人说这很简单看出来是线段树，那么简单是指什么呢？

我们说，**一般题目涉及到区间修改以及区间查询**的一般采用分块和线段树的思想，希望大家可以铭记。


------------
下面开始本题讲解。

这道题的整体思路就是用某一区间的长度减去这个区间的亮灯数目就是这个区间在一次修改中所需要打开灯的数目，那么打开灯的数目变了，自然会带动这个区间sum的改变，因此我们需要维护父亲和儿子的sum值。

简单的说tag函数主要是维护儿子的sum值，至于他们的懒标记我之后会在代码里具体解释。


**懒标记在此题中主要指这个区间是否需要更改**这是本题重点但恰恰个个题解巧妙的避过了这个问题。

题目中函数中的return是本题所用的最少的return，不能删一个，至于原因可以自己思考。

话不多说看代码。

```c
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000001;
int ans,n,m,a,b,c;
struct tree
{
	int l,r,sum,add;
}t[maxn];
inline void build(int u,int x,int y)
{
    t[u].l=x;
	t[u].r=y;
	if(x==y)
	{
		t[u].sum=0;//题目说每个灯都是关着的。
		return ;
	}
	int mid=(x+y)>>1;
	build(u*2,x,mid);build(u*2+1,mid+1,y);
}//建树不需要过多解释吧？
inline void tag(int u)
{
	if(t[u].add==0)return;//如果这个父亲不需要更改还需要儿子什么事情呢？
    //如果看不懂这句的话，一定要耐心往下看。
	t[u*2].sum=t[u*2].r-t[u*2].l+1-t[u*2].sum;
	t[u*2+1].sum=t[u*2+1].r-t[u*2+1].l+1-t[u*2+1].sum;//维护儿子的sum值。
	if(t[u*2].add==0)//如果左儿子没有懒标记的话
	t[u*2].add=1;//那么他现在有了懒标记，
    //也就是它现在需要修改区间内的值了。
	else t[u*2].add=0;//如果有懒标记的话，那么它现在不用动了
    //因为这个做儿子连着被修改了两次，
    //根据题意这个区间内的灯被开了一次，又被关了一次，
    //是不是相当于最初的形态？
	if(t[u*2+1].add==0)
	t[u*2+1].add=1;
	else t[u*2+1].add=0;//这个是处理右儿子的，解释同上。
	t[u].add=0;//注意进行这部的时候
    //左右儿子的父亲已经被修改过了
    //所以父亲的懒标记要归0，也就是说父亲现在不需要更改。
}
inline void change(int u,int l,int r)
{
	if(l<=t[u].l&&t[u].r<=r)
	{
		t[u].sum=t[u].r-t[u].l+1-t[u].sum;
		if(t[u].add==0)
		t[u].add=1;
		else 
		t[u].add=0;
		return ;//这个地方跟上面解释相同。
	}
	tag(u);
    //此时，区间没有覆盖父亲，那么检查一下这个父亲用改不用
    //如果父亲用改的话，那么由于我们之后需要用到它的儿子
    //并且我们要改的区间没有覆盖父亲，所以现在要修改儿子了。
	int mid=(t[u].l+t[u].r)>>1;
	if(a<=mid)change(u*2,l,r);
	if(b>mid)change(u*2+1,l,r);
    //此处一定是a<=mid,b>mid这个仔细想想吧。
	t[u].sum=t[u*2].sum+t[u*2+1].sum;
}
inline int ask(int u,int l,int r)
{
	if(l<=t[u].l&&r>=t[u].r)return t[u].sum;
	tag(u);
	int mid=(t[u].l+t[u].r)/2;
	int ans=0;
	if(a<=mid)ans+=ask(u*2,l,r);
	if(b>mid)ans+=ask(u*2+1,l,r);
	return ans;
}//这个地方是板子。
int main()
{
	cin>>n>>m;
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		cin>>c>>a>>b;
		if(c==0)
		change(1,a,b);
		else
		cout<<ask(1,a,b)<<endl;
	}
	return 0;
}//完美结束。
```
希望本篇题解可以对大家有帮助！
祝大家ak noip

希望管理哥哥通过。


---

## 作者：Juan_feng (赞：90)

### 这道题现在还没有C++的分块题解，~~小蒟蒻就来水一发吧qwq~~

可能是数据比较弱的原因，这题的分块跑的飞快，小蒟蒻目前是这道题的rank1（马上就要被超过去了各位dalao手下留情QAQ）

小蒟蒻就默认看到这里的dalao都会分块了，不会分块的可以去[hzwer大神的数列分块九讲](http://hzwer.com/8053.html)去学习一下qwq，个人感觉讲的可以说是很棒了

**进入正题，把长度为n的数列分成根号n个块，修改的时候对于散块直接暴力修改，整块把tag数组异或一下1就行了（修改次数为偶数则灯的开关情况不变）。**

**但只这样的话查询的时候不好查整块，所以还要维护一个ans数组，用于保存块内目前开着的灯的数量。散块修改的时候好维护，至于整块，修改的时候把ans变为 **块的大小减去ans** 就行了。**

**这样一来查询的时候也很简单了，散块直接暴力去查，整块的答案就是我们维护的ans qwq**

相信各位dalao看到这里已经了然于胸了，那么代码如下：
```
#include<iostream>
#include<cstdio>
#include<cmath>
#define maxn 100010
#define re register
#define FOR(i,l,r) for(re int i=l;i<=r;i++)
using namespace std;

int a[maxn],b[maxn],tag[maxn],ans[maxn];
int n,m,c,r,t,x,y,z,sq;

inline char nc(){  //快的一批的fread快读
	static char buf[100000],*p1=buf,*p2=buf; 
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int _read(){
	char ch=nc();
	int sum=0; 
	while(!(ch>='0'&&ch<='9'))ch=nc(); 
	while(ch>='0'&&ch<='9')sum=sum*10+ch-48,ch=nc(); 
	return sum; 
} 

inline void out(re int a){
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

void change(int x,int y){ //修改操作
	FOR(i,x,min(y,b[x]*sq)){//散块直接修改
		ans[b[x]]-=(a[i]^tag[b[x]]);  //维护ans数组
		a[i]^=1;
		ans[b[x]]+=(a[i]^tag[b[x]]);
	}
	if(b[x]!=b[y])
	  FOR(i,(b[y]-1)*sq+1,y){
	  	ans[b[y]]-=(a[i]^tag[b[y]]);
	  	a[i]^=1;
	  	ans[b[y]]+=(a[i]^tag[b[y]]);
	  }
	FOR(i,b[x]+1,b[y]-1){ //整块修改tag，维护ans数组
		tag[i]^=1;
		ans[i]=sq-ans[i];
	}
}

int query(int x,int y){ //查询操作
	re int res=0;
	FOR(i,x,min(y,b[x]*sq))  //散块直接查询
	  res+=(a[i]^tag[b[x]]);
	if(b[x]!=b[y]) 
	  FOR(i,(b[y]-1)*sq+1,y)
	    res+=(a[i]^tag[b[y]]);
    FOR(i,b[x]+1,b[y]-1)
      res+=ans[i];  //整块加上维护的ans
    return res;
}

int main(){
	n=_read(),m=_read();
	sq=sqrt(n); //分块大小默认为根号n，修改也许能变得更快
	FOR(i,1,n)
	  b[i]=(i-1)/sq+1; //每个点所在的块
	FOR(i,1,m){
		t=_read(),x=_read(),y=_read();
		if(t==0){
			change(x,y);
		}
		else{
			out(query(x,y));
			puts("");
		}
	}
    return 0;//功德圆满。
}
```
**最后祝大家NOIP RP++！**


---

## 作者：Right (赞：47)

其实这道线段树非常淳朴，几乎就是模板题了

这道提不用楼下那么麻烦，只要在下推的时候用总数-原数=更新后的亮点数

开tree变量，存当前线段上0和1的数量，每次动开关就是swap一下0和1的数量，统计时用累加即可

上代码：

>>机智的地方就在这里！！！取反
```cpp
#include <cstdio>
int n,m;
int tree[400000],lazy[400000]; >>一个是sum一个是懒惰标记
inline int read() >>读入优化
{
    int x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9')
    {
        x=(x<<3)+(x<<1)+ch-48; ch=getchar();
    }
    return x;
}
inline void write(int x) >>输出优化
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
inline void push_up(int root) >>只要用总和即可
{
    tree[root]=tree[root<<1]+tree[root<<1|1];
}
inline void push_down(int root,int l,int r)
{
    if (lazy[root]==0) return;
    lazy[root<<1]^=1; lazy[root<<1|1]^=1;
    int mid=(l+r)>>1;
    tree[root<<1]=(mid-l+1)-tree[root<<1];
    tree[root<<1|1]=(r-mid)-tree[root<<1|1];
    lazy[root]=0; 多快好省
}
void update(int l,int r,int root,int L,int R) >>模版
{ //printf("%d %d\n",l,r);
    if (L<=l && r<=R)
    {
        tree[root]=(r-l+1)-tree[root]; //取反 
        lazy[root]^=1; return;
    }
    push_down(root,l,r);
    int mid=(l+r)>>1;
    if (L<=mid) update(l,mid,root<<1,L,R);
    if (mid<R) update(mid+1,r,root<<1|1,L,R);
    push_up(root);
}
int query(int l,int r,int root,int L,int R) >>模板
{
    if (L<=l && r<=R) return tree[root];
    push_down(root,l,r);
    int a=0,b=0,mid=(l+r)>>1;
    if (L<=mid) a=query(l,mid,root<<1,L,R);
    if (mid<R) b=query(mid+1,r,root<<1|1,L,R);
    return a+b;
}
int main()
{
    scanf("%d%d",&n,&m);
    int op,x,y;
    while (m--)
    {
        op=read();
        x=read(); y=read();
        if (op==0)
            update(1,n,1,x,y);
          else
            write(query(1,n,1,x,y)),putchar('\n');
    }
}
```

---

## 作者：ZiDing_ByronFinlso (赞：18)

管理员大大我只是修改一下咋就不通过嘞
    
麻烦管理员放条生路嘛
    
本题就是线段树裸题

本题用t[i].sum表示区间内开着的灯的数量。

然后进行建树、查询、修改就可以了。

~~代码以下~~



	------------


	#include<cstdio>
	#include<iostream>
	#include<cstring>
	#include<algorithm>
	#include<cmath>
	using namespace std;
	int n,m,k,x,y;
	struct tree
	{ 
		int l,r,ad,sum; 
	};
	tree t[400010];
	inline int read()//快读
	{
		char ch=getchar(); 
		int x=0,f=1;
		while(ch<'0'||ch>'9')
		{
   			 if(ch=='-')
        		f=-1;
    		ch=getchar();
		}
		while('0'<=ch&&ch<='9')
		{
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	int found(int p)
	{
		if(p==1)
			return 0;
		return 1;
	}
	void spread(int p)//标记传递
	{
		if(!t[p].ad)
	    	return;
		int f=p<<1;
		t[f].sum=t[f].r-t[f].l+1-t[f].sum;//修改
		t[f+1].sum=t[f+1].r-t[f+1].l+1-t[f+1].sum;
		t[f+1].ad=found(t[f+1].ad);//传递
		t[f].ad=found(t[f].ad);
		t[p].ad=0;//记得删除标记
		return ;  
	}
	void build(int p,int l,int r)//建树
	{
		t[p].l=l;t[p].r=r;
		if(l==r)
		{
			t[p].sum=0;//关灯状态
    		return ;
		}
		int mid=(l+r)>>1,fir=p<<1;
		build(fir,l,mid);
		build(fir+1,mid+1,r);
		return ; 
	} 
    void change(int p,int l,int r)//更改
	{
		if(l<=t[p].l&&r>=t[p].r)//如果覆盖
		{
    		t[p].sum=t[p].r-t[p].l+1-t[p].sum;//更改后的亮灯数
    		t[p].ad=found(t[p].ad);//标记
    	return;
		}
		spread(p);
		int mid=(t[p].l+t[p].r)>>1,fir=p<<1;
		if(x<=mid) 
    		change(fir,l,r);
		if(y>mid) 
    		change(fir+1,l,r);
		t[p].sum=t[fir].sum+t[fir+1].sum;
		return ; 
	} 
    int query(int p,int l,int r)//查找
	{
		if(l<=t[p].l&&r>=t[p].r)//同理
    		return t[p].sum;
		spread(p);
        int mid=(t[p].l+t[p].r)>>1;
		int tot=0,fir=p<<1;
		if(x<=mid)
    		tot+=query(fir,x,y);
		if(y>mid)
    		tot+=query(fir+1,x,y);
		return tot;//总和       
	}
	int main()
	{
		n=read();m=read();
		build(1,1,n);
		while(m--)
		{
    		k=read();x=read();y=read();
    		if(k==0)
        		change(1,x,y);
			else
        		printf("%d\n",query(1,x,y));
		}
		return 0;
	}

---

## 作者：Hello，yearning (赞：13)

## 这锅是本蒟蒻在luogu上写的第一篇题解，求管理员给通过~~~

首先我在~~划水~~时突然想做一道分块的题，然后就点开了这道题康康
一读题发现这不是线段树裸题？？但我不能这（fang）样（ge），所以就打了一个分块。对于分块而言也是比较水的，所以在这里顺带复习一下分块。
### 概念：
- 区间：数列中连续一段的元素
- 区间操作：将某个区间[a,b]的所有元素进行某种改动的操作
- 块：我们将数列划分成若干个不相交的区间，每个区间称为一个块
- 整块：在一个区间操作时，完整包含于区间的块
- 不完整的块：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块

### 分块是怎么操作？
- 将连续x个元素分为一个块
- 对于每一个操作[L,R]，一定是中间包含了若干完整块，两边剩余不超过2x个位置，即“[L,K*X],[K*X+1,(K+1)*X]…[K2*Z+1,R]”这种形式
- 对于完整块可以统一处理，如果可以做到O(1),时间复杂度O(n/x)
- 对于剩余的2x个点，可以暴力处理O(x)
- 当x＝sqrt(n)时，每次操作的时间复杂度降到最低O(sqrt(n))
- 若上面两种情况的任意一种需要多一个log的复杂度，那么可以通过调整块的大小来使得每次操作的复杂度变为O(sqrt(nlogn))

简单来说就是把一个序列划分成几段，每段的包含sqrt(n)个元素（根据具体的题而定）。当然，对于整块我们可以直接操作，可以想成线段树的打lazy，然后不完整的块随便搞搞就可以了。总而言之，如果合并比较复杂，我们就可以考虑用分块
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int N=1e5+10;
int n,m,v[N],sum[N],lzy[N],bel[N],bol,x,y;
inline void add(int a,int b)
{
	register int i;
	for(i=a;i<=min(b,bel[a]*bol);++i) sum[bel[a]]+= v[i]==0?1:-1,v[i]^=1;
	if(bel[a]!=bel[b]) for(i=(bel[b]-1)*bol+1;i<=b;++i) sum[bel[i]]+= v[i]==0?1:-1,v[i]^=1;
	for(i=bel[a]+1;i<bel[b];++i) lzy[i]+=1; 
}
inline int query(int a,int b)
{
	int ans=0;
	register int i;
	for(i=a;i<=min(b,bel[a]*bol);++i) 
	{
		if(lzy[bel[a]]%2==0) ans+=v[i];
		else ans+= (v[i]^1);
	}
	if(bel[a]!=bel[b]) 
	{
		for(i=(bel[b]-1)*bol+1;i<=b;++i)
		{
			if(lzy[bel[b]]%2==0) ans+=v[i];
			else ans+= (v[i]^1);
		}
	}
	for(i=bel[a]+1;i<bel[b];++i) 
	{
		if(lzy[i]%2==0) ans+=sum[i];
		else ans+= bol-sum[i];
	}
	return ans;
}
int main()
{
	register int i;
	scanf("%d%d",&n,&m);bol=sqrt(n);
	for(i=1;i<=n;++i) bel[i]=(i-1)/bol+1;
	for(i=1;i<=m;++i) 
	{
        int ooo;
		scanf("%d%d%d",&ooo,&x,&y);		
		if(ooo==0) add(x,y);
		else printf("%d\n",query(x,y));
	}
	return 0;
}
```



---

## 作者：shenbear (赞：10)

首先大致讲一下一些题意：

有一个数列，你要维护以下两个操作：

1.对一段区间进行亦或操作

2.求一段区间和

------------
感觉和线段树很像，所以就考虑线段树

由于我十分菜，只会维护区间和，所以只能用区间和去写

首先，查询没有任何变动，就是维护区间和

然后，再是修改，对于区间去亦或，我们发现，由于只有0,1，所以只要拿区间长度-原来的区间和就好，然后把亦或操作用懒标记下穿，对于懒标记，亦或两次就是没亦或，所以只要把奇数次的懒标记按上规则操作即可



------------
AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
int n,m,a[N];
struct tree
{
	int l,r,w,lz;
}p[4*N];
void build(int x,int l,int r) //建树
{
	p[x].l=l;
	p[x].r=r;
	if(l==r)
	{
		p[x].w=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(2*x,l,mid);
	build(2*x+1,mid+1,r);
	p[x].w=p[x*2].w+p[x*2+1].w;
}
void xg(int x) //单点修改
{
	p[x].w=p[x].r-p[x].l+1-p[x].w;
	p[x].lz^=1;
}
void dlz(int x) //下穿lazy
{
	if(p[x].lz)
	{
		xg(x<<1);
		xg(x<<1|1);
		p[x].lz=0;
	}
}
void add(int x,int l,int r) //区间修改
{
	if(l<=p[x].l&&p[x].r<=r)
	{
		xg(x);
		return ;
	}
	dlz(x);
	int mid=(p[x].l+p[x].r)>>1;
	if(l<=mid) add(x*2,l,r);
	if(r>mid) add(x*2+1,l,r);
	p[x].w=p[x*2].w+p[x*2+1].w;
}
int ask(int x,int l,int r) //区间查询
{
	if(l<=p[x].l&&p[x].r<=r)
	{
		return p[x].w;
	}
	dlz(x);
	int mid=(p[x].l+p[x].r)>>1;
	int sum=0;
	if(l<=mid) sum+=ask(x*2,l,r);
	if(r>mid) sum+=ask(x*2+1,l,r);
	return sum;
}
int main()
{
	cin>>n>>m;
	build(1,1,n);
	while(m--)
	{
		int c,l,r;
		scanf("%d%d%d",&c,&l,&r);
		if(c) printf("%d\n",ask(1,l,r));
		else add(1,l,r);
	}
	return 0;
}

```


---

## 作者：marTixx (赞：9)

水题，不知道哪来的省选难度   
线段树维护一下就行  

这里我用了个小技巧：   
开的灯关了，关的灯开了，灯的总数不变    
只是把这两者数量交换下   

例如：    1 0 1 0 1 1    
开着的灯的数量：4     
关着的灯的数量：2

操作一次后：   0 1 0 1 0 0   
开着的灯的数量：2     
关着的灯的数量：4

就是把2和4交换下，似乎比较容易理解
     
     

      
代码：
```cpp
#include <bits/stdc++.h>
#define SIZE 1000030
using namespace std;

struct SegmentTree {
	int l, r;
	int l0, l1, add; 
    // l0 表示 关着的灯的数量， 
    // l1 表示 亮着的灯的数量 
} t[SIZE * 4];
int n, m, opt, x, y;

void build(int p, int l, int r) {//建树 
	t[p].l = l;    t[p].r = r;
	if (l == r) {
		t[p].l0++;
		return ;
	}
	int mid = (l + r) / 2;
	build(p<<1, l, mid); 
	build(p<<1|1, mid + 1, r);
	t[p].l0 = t[p<<1].l0 + t[p<<1|1].l0;
}
inline void spread(int p) {//打标记 
	if (t[p].add == 0) return ;
	swap(t[p<<1].l0, t[p<<1].l1);  //交换
	swap(t[p<<1|1].l0, t[p<<1|1].l1);
	t[p<<1].add ^= 1;  //开关灯就相当于 ^ 一下 
	t[p<<1|1].add ^= 1;
	t[p].add = 0;
}
inline void change(int p, int l, int r) {
	//开关灯，线段树板子 
	if (t[p].l >= l && t[p].r <= r) {
		t[p].add ^= 1;
		swap(t[p].l0, t[p].l1);
		return ;
	}
	spread(p);
	int mid = (t[p].l + t[p].r) / 2;
	if (l <= mid) change(p<<1, l, r);
	if (mid < r) change(p<<1|1, l, r);
	t[p].l0 = t[p<<1].l0 + t[p<<1|1].l0;
	t[p].l1 = t[p<<1].l1 + t[p<<1|1].l1;
}
int ask(int p, int l, int r) { 
	//查询开着的灯的数量 
	if (t[p].l >= l && t[p].r <= r) 
		return t[p].l1;
	spread(p);
	int mid = (t[p].l + t[p].r) / 2, sum = 0;
	if (l <= mid) sum += ask(p<<1, l, r);
	if (mid < r) sum += ask(p<<1|1, l, r);
	return sum;
}
inline void solve() {
	scanf ("%d%d", &n, &m);
	build(1, 1, n);
	for (int i = 1; i <= m; ++i) {
		scanf ("%d%d%d", &opt, &x, &y);
		if (opt == 0) 
			change(1, x, y);
		else 
			printf("%d\n", ask(1, x, y));
	}
}
int main() {
	solve();
	return 0;
}
```

---

## 作者：Treaker (赞：7)

## 指针题解来一发！！！
这道题很简单，一眼切。

我们考虑区间异或以后，这个区间1的个数就变为了len - 原来的个数。

对于标记我们可以通过取异或来维护就行了
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 200020;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m;
char s[N];
struct Segment_tree
{
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r , sum , tag;
		node (int l = 0,int r = 0) : l(l) , r(r) {sum = tag = 0;}
		inline int len() {return r - l + 1;}
		inline void up() {sum = ls -> sum + rs -> sum;}
		inline void down() 
		{
			if(tag)
			{
				ls -> tag ^= 1;
				rs -> tag ^= 1;
				tag = 0;
				ls -> sum = ls -> len() - ls -> sum;
				rs -> sum = rs -> len() - rs -> sum;
			}
		}
	}*root , pool[N] , *tail;
	void build(node *&p,int l,int r)
	{
		p = new (tail ++)node(l,r);
		if(l == r)	return;
		build(p -> ls,l,mid);
		build(p -> rs,mid+1,r);
		p -> up();
	}
	void chenge(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y)	
		{
			p -> tag ^= 1;
			p -> sum = p -> len() - p -> sum;
			return;
		}
		if(p -> tag)	p -> down();
		if(x <= mid) chenge(p -> ls,x,y);
		if(y > mid)	chenge(p -> rs,x,y);
		p -> up();
	}
	int query(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y)	return p -> sum;
		if(p -> tag)	p -> down();
		int res = 0;
		if(x <= mid)	res += query(p -> ls,x,y);
		if(y > mid)		res += query(p -> rs,x,y);
		return res;
	}
	inline void LOL()
	{
		n = read(); m = read();
		build(root,1,n);
		for(int i = 1 , opt , l , r;i <= m;i ++)
		{
			opt = read(); l = read(); r = read();
			if(opt & 1)	printf("%d\n",query(root,l,r));
			else chenge(root,l,r);
		}
	}
	Segment_tree() {tail = pool;}
}CF;
int main()
{
	CF.LOL();
	return 0;
}

```


---

## 作者：WydnksqhbD (赞：6)

# [P3870 [TJOI2009] 开关](https://www.luogu.com.cn/problem/P3870) 题解
## 前言
本题解的代码是 @[QWQ_123](https://www.luogu.com.cn/user/740328) 巨佬写的，在此鸣谢。**搬运已经经过同意。**
## 思路
众所周知，暴力出奇迹。

那么我们可以打出暴力代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int arr[1000005];
int main()
{
	int n,m;
	cin>>n>>m;
	while(m--)
	{
		int c,a,b;
		cin>>c>>a>>b;
		if(c)
		{
			int sum=0;
			for(int i=a;i<=b;i++)
			{
				sum+=arr[i];
			}
			cout<<sum<<endl;
		}
		else
		{
			for(int i=a;i<=b;i++)
			{
				arr[i]^=1;
			}
		}
	}
	return 0;
}
```
但是这样会喜提 TLE。

不过众所周知，C++ 有个好东西叫 `bitset`。

`bitset` 就是将 $8$ 个 `bool` 类型的变量压入一个 Byte，使得常数除以了 $32$（每次可以改 $32$ 个。有的是 $64$。）。

这样 $O(nm)$ 的暴力变为了 $O(\frac{nm}{w})$ 的暴力（$w=32$）。

所以可以卡过去（$10^5\times10^5\div32=312500000$）。

代码中为了区间操作，使用了一些 `bitset` 有关的函数，详见 [bitset - OI Wiki](https://oi-wiki.org/lang/csl/bitset/)。
- 头文件：`#include<bitset>`。
- 定义：`bitset<S>b`，其中 `S` 表示大小，`b` 就是名字。
- 运算符：
- - `b[i]`：表示访问 $b_i$。
- - `b[i]==/!=b[j]`：比较 $b_i,b_j$ 是否一样。
- 函数：
- - `count()`：返回 $1$ 的数量。
- - `test()`：等同于 `[]`。
- - `size()`：返回 `bitset` 的大小。

## 代码
~~达成史上最短代码。~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
bitset<100010>s,s1;
int main()
{
    s1.set();cin>>n>>m;
	while(m--)
	{
		int opt,l,r;cin>>opt>>l>>r;
		//修改和查询都是利用 bitset 的函数来写的。>>、<< 是位运算。 
		if(opt==0)s^=((s1>>(100010-r+l-1))<<(l-1));//修改操作，区间异或。 
		else cout<<(s&((s1>>(100010-r+l-1))<<(l-1))).count()<<endl;//count() 查询有几个 1。 
	}
	return 0;
}
```

---

## 作者：ALSaoBen (赞：6)

## 其实该题为一道还不错的分块入门练手题
[我的分块自学笔记](http://note.youdao.com/noteshare?id=55f00476c6d20a54c743909fe271fac7)

我们只需要查询该点被操作过奇数次还是偶数次就可以判断当前的状态,这便是该题核心思想,现在我们定义add为增量标记,sum为该区间内为奇数的元素个数

现在,我们将核心进行分块处理:
>1:l,r在同一区间,那么只要考虑区间的增量标记和该点操作次数和是否为奇数,即:
add[p]+a[i]

>2:l,r不在同一区间,被完整包含的区间就判断add是否为奇数,如果是,那么答案增加区间(元素数-sum),否则增加sum;(奇数+奇数=偶数,这很显然)

>不被完全包含的,按照1处理

如果觉得我语言难懂,那么请看代码:
```
#include<bits/stdc++.h>
using namespace std ;

int n,m;
int L[100086],R[100086];//区间左右端点
int pos[100086];//每个点属于的区间
int a[100086],add[100086],sum[100086];

inline int read()
{
	register int res=0,flag=1;
	register char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		{
			flag=-1;
		}
		ch=getchar();
	}
	while(isdigit(ch))
	{
		res=(res<<3)+(res<<1)+(ch^48);
		ch=getchar();
	}
	return res*flag;
}

inline void work(register int l,register int r)//区间内操作
{
	register int p=pos[l],q=pos[r];
	if(p==q)
	{
		for(register int i=l;i<=r;++i)
		{
			a[i]++;
		}
		for(register int i=l;i<=r;++i)
		{
			if(a[i]%2)
			{
				sum[p]++;
			}
			else
			{
				sum[p]--;
			}
		}
	}
	else
	{
		for(register int i=p+1;i<=q-1;++i)
		{
			add[i]++;
		}
		for(register int i=l;i<=R[p];++i)
		{
			a[i]++;
		}
		for(register int i=l;i<=R[p];++i)
		{
			if(a[i]%2)
			{
				sum[p]++;
			}
			else
			{
				sum[p]--;
			}
		}
		for(register int i=L[q];i<=r;++i)
		{
			a[i]++;
		}
		for(register int i=L[q];i<=r;++i)
		{
			if(a[i]%2)
			{
				sum[q]++;
			}
			else
			{
				sum[q]--;
			}
		}
	}
}

inline void find(register int l,register int r)//查询
{
	register int p=pos[l],q=pos[r];
	register long long ans=0;
	if(p==q)
	{
		for(register int i=l;i<=r;++i)
		{
			if((add[p]+a[i])%2)
			{
				ans++;
			}
		}
		printf("%lld\n",ans);
		return ;
	}
	else
	{
		for(register int i=p+1;i<=q-1;++i)
		{
			if(add[i]%2)
			{
				ans+=(R[i]-L[i]+1-sum[i]);
			}
			else
			{
				ans+=sum[i];
			}
		}
		for(register int i=l;i<=R[p];++i)
		{
			if((a[i]+add[p])%2)
			{
				ans++;
			}
		}
		for(register int i=L[q];i<=r;++i)
		{
			if((a[i]+add[q])%2)
			{
				ans++;
			}
		}
		printf("%lld\n",ans);
		return ;
	}
}

int main()
{
	n=read();
	m=read();
	register int t=sqrt(n);
	for(register int i=1;i<=n;++i)
	{
		L[i]=(i-1)*t+1;
		R[i]=i*t;
	}
	if(R[t]<n)
	{
		t++;
		L[t]=R[t-1]+1;
		R[t]=n;
	}//构建分块
	for(register int i=1;i<=t;++i)
	{
		for(register int j=L[i];j<=R[i];++j)
		{
			pos[j]=i;
		}
	}//初始化每个点所在区间
	for(register int i=1;i<=m;++i)
	{
		register int c,x,b;
		c=read();
		x=read();
		b=read();
		if(c==0)
		{
			work(x,b);
		}
		if(c==1)
		{
			find(x,b);
		}
	}
	return 0;
}

```


---

## 作者：花落丶宸星 (赞：6)

## 代码简短的分块
~~从@Owen_codeisking dalao处学会分块（感谢并膜拜dalao）~~           
这道题是我第$3$次用c++做分块了~~转语言的悲哀~~，发现短过了某一个题解，所以拿出来和大家学习学习。。。     
#### 分块，顾名思义就是把数列分成好几段，然后分块操作。其实代码思路就是这样，至于分块的写法我就不多做介绍了，dalao们应该都会吧。。。~~初一蒟蒻在dalao之间瑟瑟发抖~~         
当时间复杂度最优时，为$\sqrt{n}$,然后操作即可。     
过了这道题，还可以去试试LOJ数列分块$1-9$~~相信你能AK~~
代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll L[100010],R[100010],add[100010],a[100010],pos[100010];
void change(int b,int c){
    int p=pos[b],q=pos[c];
    if(p==q){
        for(int i=b;i<=c;i++){
            a[i]=(a[i]+1)%2;
        }
    } else
    {
        for(int i=p+1;i<=q-1;i++) add[i]++;
        for(int i=b;i<=R[p];i++) a[i]=(a[i]+1)%2;
        for(int i=L[q];i<=c;i++) a[i]=(a[i]+1)%2;
    }
}
int find(int b,int c){
    ll ans=0;
    for(int i=b;i<=c;i++){
        if ((a[i]+add[pos[i]])%2==1){
            ans++;
        }
    }
    return ans;
}
int main(){
    ll n,m;
    memset(a,0,sizeof(a));
    scanf("%lld%lld",&n,&m);
    int t=sqrt(n);
    for(int i=1;i<=t;i++){
        L[i]=(i-1)*t+1;R[i]=i*t;
    }
    if (R[t]<n){
        t++;L[t]=R[t-1]+1;R[t]=n;
    }
    for(int i=1;i<=t;i++){
        for(int j=L[i];j<=R[i];j++){
            pos[j]=i;
        }
    }
    for(int i=1;i<=m;i++){
        ll kkk,b,c;
        scanf("%lld%lld%lld",&kkk,&b,&c);
        if(kkk==0){
            change(b,c);
        } else
        {
            printf("%d\n",find(b,c));
        }
    }
    return 0;
}
```
如果你的运气好，你就能不开$O_{2}$水过~~但是好像还是要开的~~          
祝各位AC愉快

---

## 作者：1saunoya (赞：4)

>众所周知很多事情分块能做线段树也能做（就是线段树烦一点）



>所以的话 我~~不会分块~~


>emmm 数据结构真实难打啊qwq


>其实这题就是一个线段树的板子题。 注意开关灯 以及标记


>关灯操作其实就是 ^= 1 统计和的话就是两个子树往上传递值

>跑的挺慢的 $420ms$ 

>$Code$

```cpp
#include <bits/stdc++.h>
using namespace std ;
typedef long long LL ;
inline LL rd() { register LL x = 0 , f = 1 ; register char c ;
#define gc c = getchar()
    while(isspace(gc)) ;
    if(c == '-') f = -1 , gc ;
    while(x = (x<<1) + (x<<3) + (c&15) , isdigit(gc)) ;
    return x * f ;
#undef gc
}

const int inf = INT_MAX >> 1 ;

const int N = 100000 + 30 ;

int n , m ;
struct Tree {
	int Left , Right ;
	int cnt1 , cnt2 ;
	int Add ; 
} tree[N << 2] ; 
#define l(x) x << 1 
#define r(x) x << 1 | 1

inline void Build(int l , int r , int p) {
	tree[p].Left = l ; tree[p].Right = r ;
	if(l == r) { tree[p].cnt1 ++ ; return ; }
	int mid = l + r >> 1 ;
	Build(l , mid , l(p)) ; Build(mid + 1 , r , r(p)) ;
	tree[p].cnt1 = tree[l(p)].cnt1 + tree[r(p)].cnt1 ;
}

inline void Lazy(int p) {
	if(tree[p].Add == 0) return ;
	swap(tree[l(p)].cnt1 , tree[l(p)].cnt2) ;
	swap(tree[r(p)].cnt1 , tree[r(p)].cnt2) ;
	tree[l(p)].Add ^= 1 ; tree[r(p)].Add ^= 1 ;
	tree[p].Add = 0 ;
}

inline void Change(int l , int r , int p) {
	if(tree[p].Left >= l and tree[p].Right <= r) {
		tree[p].Add ^= 1 ;
		swap(tree[p].cnt1 , tree[p].cnt2) ;
		return ;
	}
	Lazy(p) ;
	int mid = tree[p].Left + tree[p].Right >> 1 ;
	if(l <= mid) Change(l , r , l(p)) ;
	if(mid < r) Change(l , r , r(p)) ;
	tree[p].cnt1 = tree[l(p)].cnt1 + tree[r(p)].cnt1 ; 
	tree[p].cnt2 = tree[l(p)].cnt2 + tree[r(p)].cnt2 ;  
}

inline int Query(int l , int r , int p) {
	if(tree[p].Left >= l and tree[p].Right <= r) return tree[p].cnt2 ;
	Lazy(p) ;
	int mid = tree[p].Left + tree[p].Right >> 1 ; int sum = 0 ;
	if(l <= mid) sum += Query(l , r , l(p)) ;
	if(mid < r) sum += Query(l , r , r(p)) ;
	return sum ; 
}

signed main() {
	n = rd() , m = rd() ;
	Build(1 , n , 1) ;
	for(register int i=1;i<=m;i++) {
		int opt = rd() , x = rd() , y = rd() ;
		if(opt == 0) Change(x , y , 1) ;
		else printf("%d\n" , Query(x , y , 1)) ;
	}
	return 0 ;
}

```

---

## 作者：嚯呀嚯呀 (赞：4)

都是大佬，区间修改的线段树随便写写，我太蒟蒻了，弄不懂线段树的lazy数组怎么用，所以只能写分块来过，时间复杂度O(N√N)

分块其实也是一种暴力，但是一种很优秀的暴力，它的主要思想是吧根号N分为一块，对于一个要处理的区间，它将中间跨过得块直接加上懒标记，对于两边多出来的元素直接暴力处理。这题操作1操作2都是这样的

详细解释见我的代码(**P党福利！！！**)
```
var
  a1,a2,a3:longint;
  ans,tot,block,i,j,m,n,k,p:longint;
  flag,l,r,point,key:array[0..100005]of longint;
  a:array[0..100005]of boolean;
procedure down(t:longint);//将懒数组下放，清零
var
  i:longint;
begin
  for i:=l[t] to r[t] do
    begin
      if a[i]=true then dec(key[t])
      else inc(key[t]);
      a[i]:=not(a[i]);
    end;
  flag[t]:=0;
end;
begin
  readln(n,m); block:=trunc(sqrt(n)); tot:=0;
  fillchar(a,sizeof(a),false);
  for i:=1 to n do
    begin
      if i mod block=1 then
        begin
          inc(tot); l[tot]:=i;
        end;
      if i mod block=0 then
        r[tot]:=i;
      point[i]:=tot;
    end;//l,r数组是这个块左右边界是什么,point数组指这个位置属于哪个块
  if r[tot]=0 then r[tot]:=n;
  {for i:=1 to tot do
    writeln(l[i],' ',r[i]);
  writeln(block);         }
  for p:=1 to m do
    begin
      readln(a1,a2,a3);
      if a1=0 then
        begin
          if point[a2]=point[a3] then//如果要处理的区间在一个块里
            begin
              if flag[point[a2]] mod 2=1 then
                down(point[a2]);//如果这个区间被关开了奇数次就要变
              for i:=a2 to a3 do//直接暴力修改
                begin
                  if a[i]=false then
                    begin a[i]:=true; inc(key[point[a2]]); end
                  else
                    begin a[i]:=false; dec(key[point[a2]]); end;
                end;
            end
          else
            begin
              if flag[point[a2]] mod 2=1 then//处理左边多出的元素
                down(point[a2]);
              for i:=a2 to r[point[a2]] do//处理左边多出的元素
                begin
                  if a[i]=false then
                    begin a[i]:=true; inc(key[point[a2]]); end
                  else
                    begin a[i]:=false; dec(key[point[a2]]); end;
                end;

              for i:=point[a2]+1 to point[a3]-1 do//给中间跨过得块直接打上懒标记
                inc(flag[i]);

              if flag[point[a3]] mod 2=1 then//处理右边多出的元素
                down(point[a3]);
              for i:=l[point[a3]] to a3 do//处理右边多出的元素
                begin
                  if a[i]=false then
                    begin a[i]:=true; inc(key[point[a3]]); end
                  else
                    begin a[i]:=false; dec(key[point[a3]]); end;
                end;
            end;
        end
      else
        begin
          ans:=0;
          if point[a2]=point[a3] then//在一个块里暴力求解
            begin
              if flag[point[a2]] mod 2=1 then
                down(point[a2]);
              for i:=a2 to a3 do
                if a[i]=true then
                  inc(ans);
              writeln(ans);
            end
          else
            begin
              if flag[point[a2]] mod 2=1 then//暴力求解左右边多余元素
                down(point[a2]);
              for i:=a2 to r[point[a2]] do
                if a[i]=true then
                  inc(ans);
              if flag[point[a3]] mod 2=1 then
                down(point[a3]);
              for i:=l[point[a3]] to a3 do
                if a[i]=true then
                  inc(ans);
              for i:=point[a2]+1 to point[a3]-1 do
              //中间跨过得块如果不需要修改，那么就是key值，
              //如果要修改，就是整个长度减去key值，这里不需要下放懒标记
                if flag[i] mod 2=0 then
                  ans:=ans+key[i]
                else
                  ans:=ans+(r[i]-l[i]+1)-key[i];
              writeln(ans); 
            end;
        end;
    end;
end.
```
**各位大佬给个赞吧(可怜的萌新)**

---

## 作者：黄汝鹏 (赞：3)

#### 来一波线段树板子做法
   首先看到题目，一次将等全部改变原来的状态，学过状态压缩 ~~（或其他一些乱七八糟的东西）~~ 的同学们都知道，可以用**取反**搞定，符号^，照样用一个数组ad进行维护。如果长度为L，有l个灯开了，则有L-l个灯灭了，所以维护时，可令********s[i]=L-s[i]********  有点绕，没关系，慢慢理解，后面主要就是打板子，处理好细节
   
   代码变量说明：s 相当于sum，线段树数组
   
                ad 用于维护
   代码时间
   
    

------------
```cpp
//开为1 暗为0
#include<bits/stdc++.h>
#define new_  s[k]=s[k<<1]+s[k<<1|1];  //更新
using namespace std;
const int M=200000+10;
int n,m,a,x,y;
int ad[4*M],s[4*M],sa[M];
char sr[M];
int read() 
{
    char ch=getchar(); 
	int r=0,f=1;
    while(ch<'0'||ch>'9') 
	{
        if(ch=='-') f=-1;
        ch=getchar();
    } 
	while('0'<=ch&&ch<='9') 
	{
        r=r*10+ch-'0';
        ch=getchar();
    } 
	return r*f;
}
void build(int k,int l,int r)//建树
{
	if(l==r)
	{
		s[k]=sa[l];
		return ;
	}
	int mid=l+r>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	new_; 
}
void push(int k,int L)//标记下放
{
	if(ad[k])
	{
		ad[k<<1]^=1;
		ad[k<<1|1]^=1;
		s[k<<1]=(L-(L>>1))-s[k<<1];
		s[k<<1|1]=(L>>1)-s[k<<1|1];
		ad[k]=0;
	}
}
void xor_(int k,int l,int r)//取反（关灯开灯操作）
{
	if(x<=l&&y>=r)
	{
		ad[k]^=1;
		s[k]=(r-l+1)-s[k];
		return ;
	}
	push(k,r-l+1);
	int mid=l+r>>1;
	if(x<=mid) xor_(k<<1,l,mid);
	if(y>mid) xor_(k<<1|1,mid+1,r);
	new_;
}
int query(int k,int l,int r)//询问查找
{
	if(x<=l&&y>=r) return s[k];
	push(k,r-l+1);
	int mid=l+r>>1;
	int cnt=0;
	if(x<=mid) cnt+=query(k<<1,l,mid);
	if(y>mid) cnt+=query(k<<1|1,mid+1,r);
	new_;
	return cnt;
}
int main()
{
	n=read();
	m=read();
	for(int i=1;i<=n;i++) sa[i]=0;
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		a=read(),x=read(),y=read();
		if(a==0) xor_(1,1,n);
		if(a==1) printf("%d\n",query(1,1,n));
	}
	return 0;
} 
```
推荐两道好题给大家，差不多，有一题稍微改一下就AC

[光开关Light Switching](https://www.luogu.com.cn/problem/P2846)

[XOR的艺术](https://www.luogu.com.cn/problem/P2574)


---

## 作者：Priori_Incantatem (赞：2)

### 题目大意
给出一个长度为 $n$ 的序列，有区间取反，和区间求和操作。输出每一次求和询问的答案

这应该算的上是一道模板的分块题了，写完后感觉分块比线段树简单好多  
首先，我们将这个序列分成 $\sqrt{n}$ 块，保证最优化复杂的
维护四个数组 $a[],sum[],tag[],id[]$ 分别表示每盏灯的状态，每个块中开着的灯数总和，每块是否取反，和每盏灯属于的块的编号

每一次区间 询问/修改，对于不整块的部分，直接修改它的 $a[]$ 数组  
对于整块的，我们直接打上标记并更 $sum[]$ 数组

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
const int Maxn=100000+10,inf=0x3f3f3f3f;
int n,m,len;
int id[Maxn],sum[Maxn],a[Maxn],tag[Maxn];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void modify(int l,int r)
{
	int limit=min(id[l]*len,r);
	for(int i=l;i<=limit;++i)
	{
		sum[id[i]]-=(a[i]^tag[id[i]]); //减去之前他对所在的块做的贡献
		a[i]^=1;  // 取反
		sum[id[i]]+=(a[i]^tag[id[i]]);  // 加上取反后对所在的块做的贡献
	}
	if(id[l]!=id[r])
	{
		for(int i=(id[r]-1)*len+1;i<=r;++i)
		{
			sum[id[i]]-=(a[i]^tag[id[i]]);
			a[i]^=1;
			sum[id[i]]+=(a[i]^tag[id[i]]);
		}
	}
	for(int i=id[l]+1;i<=id[r]-1;++i)
	{
		tag[i]^=1;
		sum[i]=len-sum[i];
	}
}
int query(int l,int r)  // 与上同理
{
	int limit=min(id[l]*len,r);
	int ret=0;
	for(int i=l;i<=limit;++i)
	ret+=(a[i]^tag[id[i]]);
	
	if(id[l]!=id[r])
	{
		for(int i=(id[r]-1)*len+1;i<=r;++i)
		ret+=(a[i]^tag[id[i]]);
	}
	for(int i=id[l]+1;i<=id[r]-1;++i)
	ret+=sum[i];
	return ret;
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read(),m=read();
	len=sqrt(n);
	for(int i=1;i<=n;++i)
	id[i]=(i-1)/len+1;
	
	for(int i=1;i<=m;++i)
	{
		bool opt=read();
		int l=read(),r=read();
		
		if(!opt)modify(l,r);
		else printf("%d\n",query(l,r));
	}
	
	return 0;
}
```

---

## 作者：温词 (赞：2)

#### 作为一个从P2574 XOR的艺术过来的同学，稍微看了看题面后表示相当的激动，
### ~~这不是原题吗~~
### 现在让我们来分析一下题意，一个大的区间，初始值全为0，开灯视为1,0和1的转换用异或就可以很好地实现了，现在需要一个数据结构，1、支持区间里面每一个数异或1. 2、查询区间中有多少个1........看到这，应该能猜到线段树的做法了吧，不会的请出门右转模板题
```
#include<bits/stdc++.h>
using namespace std;
long long add[500010],st[500010],a[500010],n,m;//add数组为lazy tag,st数组为线段树
inline long long read(){
	long long w=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		w=(w<<3)+(w<<1)+ch-48;
		ch=getchar();
	}
	return w*f;
}//快读的板（我知道我的相当丑）
inline int ls(int p){
	return p<<1;
}
inline int rs(int p){
	return p<<1|1;
}//左儿子右儿子
inline void push_up(int p){
	st[p]=st[ls(p)]+st[rs(p)];
	return;
}//向上更新
inline void build(int p,int l,int r){
	if(l==r) {
		st[p]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	push_up(p);
	return;
}//建树
inline void push_down(int p,int l,int r){
	if(add[p]){
		int len=r-l+1;
		add[ls(p)]^=1;
		add[rs(p)]^=1;
		st[ls(p)]=(len-(len>>1))-st[ls(p)];
		st[rs(p)]=(len>>1)-st[rs(p)];
		add[p]=0;
	}
	return;
}
inline void update(int nl,int nr,int l,int r,int p){
	if(nl<=l&&nr>=r){
		add[p]^=1;//开关灯视为异或
		st[p]=r-l+1-st[p];//一个区间内，区间长度为len，有n个1，那么一定有len-n个0
		return;
	}
	push_down(p,l,r);//下移lazy tag
	int mid=(l+r)>>1;
	if(nl<=mid) update(nl,nr,l,mid,ls(p));
	if(nr>mid) update(nl,nr,mid+1,r,rs(p));
	push_up(p);
}//将lazt tag向下更新
inline long long query(int nl,int nr,int l,int r,int p){
	if(nl<=l&&nr>=r){
		return st[p];
	}
	long long sum=0;
	push_down(p,l,r);
	int mid=(l+r)>>1;
	if(nl<=mid) sum+=query(nl,nr,l,mid,ls(p));
	if(nr>mid) sum+=query(nl,nr,mid+1,r,rs(p));
	return sum;//询问这个的话只要是写过线段树的应该是没问题的吧
}
int main(){
	n=read();
	m=read();
	int i,j,k;
	for(i=1;i<=n;i++){
		a[i]=0;
	}
	build(1,1,n);
	while(m--){
		int type,x,y;
		type=read();
		x=read();
		y=read();
		if(type==0) update(x,y,1,n,1);
		if(type==1){
			long long ans=query(x,y,1,n,1);
			printf("%lld\n",ans);
		}
	}
	return 0;//拜拜了程序
}
```
## 最后一个彩蛋，做了这个再去做P2574 XOR的艺术，绝对很快乐，~~一份代码，两份经验~~

---

## 作者：QuantAsk (赞：2)

# 分块题解
题意很简单，直接开始分析做法。

将灯分块，对于每一块，维护两个数值$f,sum$

$f(bool):$这个块有没有取反

有了$f$，我们就避免这个块之前整块修改后有需要暴力修改部分的尴尬，因为直接照常操作就可以了。

$sum(int):$在使用了$f$的情况下这个块有多少个开着的灯。

修改的时候整块直接修改$f$，块部分暴力就修改$sum$和$a$。

询问就根据$f$进行(精神)取反之后整块用$sum$统计，部分直接暴力。

# $code$
```cpp
#include<cstdio>
#include<cmath>
#define pos(x) (x-1)/sq+1
#define N 100010
#define T 500
using namespace std;
int n,m,l,r,x,sq,t;
bool a[N],f[T];
int L[T],R[T],sum[T];
void ycl()
{
	sq=t=sqrt(n);
	for(int i=1;i<=t;i++)
	{
		L[i]=(i-1)*t+1;
		R[i]=i*t;
	}
	if(R[t]<n) t++,L[t]=R[t-1]+1,R[t]=n;
}
void change(int l,int r)
{
	int q=pos(l),p=pos(r);
	if(q==p){
		for(int i=l;i<=r;i++)
			sum[p]+=1-a[i]*2,a[i]=!a[i];
	}
	else
	{
		for(int i=q+1;i<=p-1;i++)
		  	f[i]=!f[i];
		for(int i=l;i<=R[q];i++)
			sum[q]+=1-a[i]*2,a[i]=!a[i];
		for(int i=L[p];i<=r;i++)
			sum[p]+=1-a[i]*2,a[i]=!a[i];
	}
}
int ask(int l,int r)
{
	int ans=0;
	int q=pos(l),p=pos(r);
	if(q==p){
		for(int i=l;i<=r;i++)
		  ans+=a[i];
		if(f[p]) return r-l+1-ans;
		return ans;
	}
	else
	{
		for(int i=q+1;i<=p-1;i++)
		    if(f[i]) ans+=R[i]-L[i]+1-sum[i];
		    else ans+=sum[i];
		int k=0;
		for(int i=l;i<=R[q];i++)
			k+=a[i];
		if(f[q]) ans+=R[q]-l+1-k;
		else ans+=k;
		k=0;
		for(int i=L[p];i<=r;i++)
			k+=a[i];
		if(f[p]) ans+=r-L[p]+1-k;
		else ans+=k;
	}
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	ycl();
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&l,&r);
		if(x) printf("%d\n",ask(l,r));
		else change(l,r);
	}
}
```

---

## 作者：呜呜呜exit去死 (赞：2)

一开始看到这题就直接想到了线段树
于是便打了下面这段程序（不建树会比较短）
但是仔细一看他的数据范围我们还是需要一些优化
当然本人很懒交给你们去修改
开一个懒标记不用每次修改
需要时再修改，可以选择存放重复次数然后到查询时再去判断若是奇数次则是修改成为关偶数则是不变
还有一种tag可以存布尔型然后进行查询时下放就可以了
change是修改
find是查询
可以多一个updata下放
```pascal
program exl;
var mm:array[1..400005]of longint;
 n,m,s,e,ans,p,j,i:longint;
 procedure change(k,l,r,x,y:longint);
 var mid:longint;
 begin
 if (r<x)or(l>y) then  exit;
 if (l>=x)and(r<=y)and(l=r)
 then begin
 mm[k]:=1-mm[k];
 exit;
 end;
 if (l>=x)and(r<=y)
 then begin
 mm[k]:=r-l+1-mm[k];
 end;
 mid:=(l+r)div 2;
 change(k*2,l,mid,x,y);
 change(k*2+1,mid+1,r,x,y);
 mm[k]:=mm[k*2]+mm[k*2+1];
 end;
procedure find(k,l,r,x,y:longint);
var mid:longint;
begin
if (r<x)or(l>y) then exit;
if (l>=x)and(r<=y) then begin
ans:=ans+mm[k];
exit;
end;
mid:=(l+r)div 2;
 find(k*2,l,mid,x,y);
 find(k*2+1,mid+1,r,x,y);
end;
begin
assign(input,'c.in');
assign(output,'c.out');
reset(input);
rewrite(output);
readln(n,m);
for i:=1 to m do
begin
readln(p,s,e);
if p=0 then change(1,1,n,s,e);
if p=1 then begin ans:=0; find(1,1,n,s,e);
writeln(ans);
end;
end;
close(input);
close(output);
end.

```

---

## 作者：Victorique (赞：2)

题解区的解法不是特别全面，补充一个不一样的。

可以发现，反转操作就是把0变成1，把1变成0，所以同时记录sum1和sum0，反转时直接swap交换就可以了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define re register
#define MAXN 200001
#define inf 200001
#define ll long long
#define ls rt<<1
#define rs rt<<1|1
#define mid (l+r>>1)
using namespace std;
int sum1[MAXN<<1],sum0[MAXN<<1],n,m;
int rev[MAXN<<1];
inline void pushup(int rt){sum0[rt]=sum0[ls]+sum0[rs];sum1[rt]=sum1[ls]+sum1[rs];}
inline void pushdown(int l,int r,int rt)
{
	if(rev[rt]){
		rev[ls]^=1;rev[rs]^=1;
		swap(sum0[ls],sum1[ls]);
		swap(sum1[rs],sum0[rs]);
		rev[rt]=0;
	}
}
void build(int l,int r,int rt)
{
	if(l==r){
		sum0[rt]=1;
		return;
	}
	build(l,mid,ls);
	build(mid+1,r,rs);
	pushup(rt);
}
void update(int L,int R,int l,int r,int rt)
{
	if(L<=l&&R>=r){
		rev[rt]^=1;
		swap(sum0[rt],sum1[rt]);
		return;
	}
	pushdown(l,r,rt);
	if(L<=mid) update(L,R,l,mid,ls);
	if(R>mid) update(L,R,mid+1,r,rs);
	pushup(rt);
}
int query(int L,int R,int l,int r,int rt)
{
	if(L<=l&&R>=r){
		return sum1[rt];
	}
	int ans=0;
	pushdown(l,r,rt);
	if(L<=mid) ans=query(L,R,l,mid,ls);
	if(R>mid) ans+=query(L,R,mid+1,r,rs);
	return ans;
}
inline int read()
{
	int x=0,c=1;
	char ch=' ';
	while((ch<'0'||ch>'9')){
		if(ch=='-') c*=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*c;
}
int main()
{
	n=read();m=read();
	build(1,n,1);
	for(re int i=1;i<=m;i++){
		int x,y,fl;
		fl=read(),x=read(),y=read();
		if(fl==0) update(x,y,1,n,1);
		else printf("%d\n", query(x,y,1,n,1));
	}
	return 0;
}
```

---

## 作者：TheShadow (赞：2)

# 闲扯

话说分块的复杂度不是 $O(n\sqrt{n})$ 吗，为毛开 $O2$ 分块跑的比我的线段树快。。。

# Solution

## 解法一：线段树

这个区间翻转可以看成是对每个数异或一下。

所以对每个区间，如果翻转了一次，它的贡献就变成了 $len-ans$ 。

线段树维护区间内 $1$ 的总数，懒标记改为异或即可。

## 解法二：分块

先将整个序列分为 $\sqrt{n}$ 块，按照分块**大段维护，局部朴素**的思想，我们按照如下方式进行修改和查询。

修改：

​		记录一个 $inv$ 数组，表示这个区间被翻转了几次。

​		对于大段的区间，我们直接将 $ans$ 变为 $sz-ans$ ，其中 $sz$ 为块的大小。

​		对于开头和末尾部分，暴力维护。

​		先判断当前位置的数翻转了 $inv$ 次之后是否为 $1$ ，如果是，就将该段的答案减 $1$ ，否则就加 $1$ 。

查询：

​		对于大的区间，我们直接调用答案。

​		对于开头和末尾部分，暴力维护，具体方法和修改类似。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,m,opt,x,y;
// 分块
int ans[320],sz,inv[320],val[MAXN];
il updata(int x,int y){
	ri p=(x+sz-1)/sz,q=(y+sz-1)/sz;
	if(p==q){
		for(ri i=x;i<=y;++i) ans[p]-=val[i]^inv[p],val[i]^=1,ans[p]+=val[i]^inv[p];
		return ;
	}
	for(ri i=p+1;i<=q-1;++i) inv[i]^=1,ans[i]=sz-ans[i];
	for(ri i=x;i<=sz*p;++i) ans[p]-=val[i]^inv[p],val[i]^=1,ans[p]+=val[i]^inv[p];
	for(ri i=(q-1)*sz+1;i<=y;++i) ans[q]-=val[i]^inv[q],val[i]^=1,ans[q]+=val[i]^inv[q];
}
it query(int x,int y){
	ri p=(x+sz-1)/sz,q=(y+sz-1)/sz,res=0;
	if(p==q){
		for(ri i=x;i<=y;++i) res+=val[i]^inv[p];
		return res;
	}
	for(ri i=p+1;i<=q-1;++i) res+=ans[i];
	for(ri i=x;i<=sz*p;++i) res+=val[i]^inv[p];
	for(ri i=(q-1)*sz+1;i<=y;++i) res+=val[i]^inv[q];
	return res;
}
/* 线段树
struct Seg_Tree{
	int sum,tag;
}T[MAXN<<2];
#define lc (cur<<1)
#define rc (cur<<1|1)
il pushup(int cur){T[cur].sum=T[lc].sum+T[rc].sum;}
il pushdown(int cur,int l,int r){
	if(!T[cur].tag) return ;
	T[lc].tag^=T[cur].tag;
	T[rc].tag^=T[cur].tag;
	T[lc].sum=mid-l+1-T[lc].sum;
	T[rc].sum=r-mid-T[rc].sum;
	T[cur].tag=0;
}
il updata(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) T[cur].tag^=1,T[cur].sum=r-l+1-T[cur].sum;
	else{
		pushdown(cur,l,r);
		if(mid>=L) updata(lc,l,mid,L,R);
		if(R>mid) updata(rc,mid+1,r,L,R);
		pushup(cur);
	}
}
it query(int cur,int l,int r,int L,int R){
	if(l>=L&&r<=R) return T[cur].sum;
	pushdown(cur,l,r);ri res=0;
	if(mid>=L) res+=query(lc,l,mid,L,R);
	if(R>mid) res+=query(rc,mid+1,r,L,R);
	return res;
}
*/
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	/* 线段树
	for(ri i=1;i<=m;++i){
		read(opt),read(x),read(y);
		if(opt==0) updata(1,1,n,x,y);
		else print(query(1,1,n,x,y)),puts("");
	}
	*/
	// 分块
	sz=sqrt(n);
	for(ri i=1;i<=m;++i){
		read(opt),read(x),read(y);
		if(opt==0) updata(x,y);
		else print(query(x,y)),puts("");
	}
	return 0;
}
```



---

## 作者：konjacq (赞：1)

首先这道题的开关灯本质上就是区间反转,然后就可以用(魔改)线段树维护.

假设有两颗线段树分别长成这个样子,左边那一颗存的就是初始状态(全部关闭).
![](https://i.loli.net/2019/11/07/YlN5wfMikneEVb1.png)
现在要修改区间,比如 $[2,5]$ (图中黄色部分),那么只要与右边那棵树的对应位置交换(图中绿色部分)就可以了.  
所以只要建两颗线段树,表示每一个区间初始状态和反转后状态,对于线段树上的每一个节点保存它的左右儿子,然后在更新整个区间时调换左右儿子(比如例子中只需要交换边框加粗的节点)即可.代码实现可以参考我的程序.

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

int n,m,a=1,b,c,r0,r1=1,s[800005],ls[800005],rs[800005];

void build(int lp,int rp,int p0,int p1) {
	if (lp==rp) {s[p0]=0; s[p1]=1; return;}
	ls[p0]=++a; ls[p1]=++a;
	rs[p0]=++a; rs[p1]=++a; int mp=(lp+rp)>>1;
	build(lp,mp,ls[p0],ls[p1]);
	build(mp+1,rp,rs[p0],rs[p1]);
	s[p0]=s[ls[p0]]+s[rs[p0]];
	s[p1]=s[ls[p1]]+s[rs[p1]];
}

void update(int ul,int ur,int lp,int rp,int p0,int p1) {
	if (lp>rp) return; int mp=(lp+rp)>>1;
	if (ul<=lp&&mp<=ur) swap(ls[p0],ls[p1]);
	else if (ul<=mp) update(ul,ur,lp,mp,ls[p0],ls[p1]);
	if (ul<mp+2&&rp<=ur) swap(rs[p0],rs[p1]);
	else if (mp<ur) update(ul,ur,mp+1,rp,rs[p0],rs[p1]);
	s[p0]=s[ls[p0]]+s[rs[p0]];
	s[p1]=s[ls[p1]]+s[rs[p1]];
}

int getsum(int gl,int gr,int lp,int rp,int p0) {
	if (gl<=lp&&rp<=gr) return s[p0];
	int mp=(lp+rp)>>1,ret=0;
	if (gl<=mp) ret+=getsum(gl,gr,lp,mp,ls[p0]);
	if (mp<gr) ret+=getsum(gl,gr,mp+1,rp,rs[p0]); return ret;
}

int main() {
	scanf("%d%d",&n,&m); build(1,n,r0,r1);
	while (m--) {
		scanf("%d%d%d",&a,&b,&c);
		if (a) printf("%d\n",getsum(b,c,1,n,r0));
		else {
			if (b==1&&c==n) swap(r0,r1);
			else update(b,c,1,n,r0,r1);
		}
	}
	return 0;
}
```

---

## 作者：康师傅 (赞：1)

新人刚学线段树，做完这道题对线段树的认识更深了，写一篇纪念一下~
线段树最重要的是对$lazy\_tag$的理解。
### 懒标记记录的是左右两个儿子的状态
然后我们可以将这个题转化为：

**有一段初始全为$0$的区间，分别执行将一段区间$[l,r]$中的$0$变成$1$，$1$变成$0$，或者求一段区间$[l,r]$中$1$的个数。**

于是题目瞬间简单了不少（不用建树了~）。很显然，对于同一个区间每操作两次就相当于没有操作（因为把灯关了再打开相当于没关灯），所以这个懒标记只有两种状态：**有操作**和**没操作**，更新懒标记的时候只要将当前状态转换为另一种状态就行了。

### 注意
$0.$括号里的东西是代码中对应的函数。
#### $1.$更新$(update())$的时候先下传标记，传完之后在当前区间中的操作和这个标记就没有关系了!
#### $2.$修改$(u())$时，只有标记是有修改的时候才修改，修改时只需$ans[k]=(r-l+1)-ans[k]$即可，这个就相当于将区间中的$0$，$1$互换，然后清空标记。
#### $3.$查询时首先还是要下传标记，传完之后在当前区间中的操作和这个标记就没有关系了!  
  
上代码咯~
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100003;
int n,m,tag[N<<2],ans[N<<2];

inline void getint(int &x){
	x=0;char ch;
	do{ch=getchar();}while(!isdigit(ch));
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
}

inline int ls(int x){return x<<1;}
inline int rs(int x){return x<<1|1;}
inline void u(int &x){x=(x==1?0:1);}
inline void push_up(int k){ans[k]=ans[ls(k)]+ans[rs(k)];}
inline void f(int k,int l,int r){
	u(tag[k]),ans[k]=(r-l+1)-ans[k];
}

inline void push_down(int k,int l,int r){
	if(!tag[k])	return;
	int mid=(l+r)>>1;
	f(ls(k),l,mid);
	f(rs(k),mid+1,r);
	tag[k]=0;
}

inline void update(int k,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		u(tag[k]),ans[k]=(r-l+1)-ans[k];
		return;
	}
	int mid=(l+r)>>1;
	push_down(k,l,r);
	if(x<=mid) update(ls(k),l,mid,x,y);
	if(y>mid) update(rs(k),mid+1,r,x,y);
	push_up(k);
}

inline int query(int k,int l,int r,int x,int y){
	int ret=0;
	if(l>=x&&r<=y)	return ans[k];
	int mid=(l+r)>>1;
	push_down(k,l,r);
	if(x<=mid) ret+=query(ls(k),l,mid,x,y);
	if(y>mid) ret+=query(rs(k),mid+1,r,x,y);
	return ret;
}

int main(){
	getint(n),getint(m);
	for(int i=1;i<=m;++i){
		int c,a,b;
		getint(c),getint(a),getint(b);
		if(!c)	update(1,1,n,a,b);
		else printf("%d\n",query(1,1,n,a,b));
	}	
	return 0;
}
```

---

## 作者：用户已注销 (赞：1)


这道题还可以巧妙的用最原始的区间乘法区间求和的线段树解决。

首先考虑操作开关两次后，等于没有操作。

什么东西操作两次以后等于没操作呢？聪明的你一定会想到xor

事实上很简单啊，乘负一就是两次等于没有啊！

所以灭的标记为-1，亮的标记为1，操作的时候直接区间乘负一就好了！

但是问题来了，求和的时候亮的和灭的也会两两抵消啊，怎么办嘞？

然而我们知道这个区间一共有几个灯啊，所以这是一个二元一次方程组

∵ 亮 + 灭 = 区间长度（B-A+1）

  亮 - 灭 = 区间和（sum(A,B)）

∴ 亮 = （ sum(A,B) + B - A + 1 ） / 2

然后就变成彻彻底底的弱化线段树2模板了

```
#include <cstdio>

using namespace std;

inline int Min( int A , int B ) { return A < B ? A : B ; }
inline int Max( int A , int B ) { return A > B ? A : B ; }
inline int Readin() {
	
	register int K = 0 ;
	register char C = getchar() ;
	
	for( ; C < '0' or C > '9' ; C = getchar() ) ;
	for( ; C >= '0' and C <= '9' ; C = getchar() )
		K = ( K << 1 ) + ( K << 3 ) + C - '0' ;
	
	return K ;
	
}

int N ;

int Tree[800005] , Tag[800005] , L[800005] , R[800005] , Nods ;

void Build( int Nod , int A , int B ) {
	
	L[Nod] = A ;
	R[Nod] = B ;
	Tag[Nod] = 1 ;
	Tree[Nod] = A - B - 1 ;
	
	if( A == B ) return;
	
	Build( Nod << 1 , A , ( A + B ) >> 1 ) ;
	Build( Nod << 1 | 1 , ( ( A + B ) >> 1 ) + 1 , B ) ;
	
	return;
	
}

void Down( int Nod ) {
	
	Tag[Nod] = 1 ;
	
	if( Nod >= N ) return;
	
	Tree[Nod<<1] *= -1 ;
	Tag[Nod<<1] *= -1 ;
	Tree[Nod<<1|1] *= -1 ;
	Tag[Nod<<1|1] *= -1 ;
	
	return;
	
}

int Sum( int Nod , int A , int B ) {
	
	if( L[Nod] > B or R[Nod] < A )
		return 0 ;
	
	if( Tag[Nod] == -1 )
		Down(Nod) ;
	
	if( L[Nod] == A and R[Nod] == B )
		return Tree[Nod] ;
	
	return Sum( Nod << 1 , A , Min( B , R[Nod<<1] ) ) + 
		   Sum( Nod << 1 | 1 , Max( A , L[Nod<<1|1] ) , B ) ;
	
}

void Que( int Nod , int A , int B ) {
	
	if( L[Nod] > B or R[Nod] < A )
		return;
	
	if( Tag[Nod] == -1 )
		Down(Nod) ;
	
	if( L[Nod] == A and R[Nod] == B ) {
		Tree[Nod] *= -1 ;
		Tag[Nod] = -1 ;
		return;
	}
	
	Que( Nod << 1 , A , Min( B , R[Nod<<1] ) ) ;
	Que( Nod << 1 | 1 , Max( A , L[Nod<<1|1] ) , B ) ;
	
	Tree[Nod] = Tree[Nod<<1] + Tree[Nod<<1|1] ;
	
	return;
	
}

int main() {
	
	N = Readin() ;
	
	for(register int i = 1 ; i < N ; )
		if( ( i<<= 1 ) >= N )
			Nods = ( ( N = i ) << 1 ) - 1 ;
	
	Build( 1 , 1 , N ) ;
	
	for(register int M = Readin() ; M-- ; ) {
		register int C = Readin() , A = Readin() , B = Readin() ;
		if(C) printf("%d\n", ( Sum( 1 , A , B ) + B - A + 1 ) >> 1 ) ;
		else Que( 1 , A , B ) ;
	}
	
	
	return 0 ;
	
} 
// liang - mie = sum
// liang + mie = b - a + 1
// liang = ( sum + b - a + 1 ) / 2
```

注意！因为本题具有一些特殊性质（比如tag只会是±1等等），所以上面的代码并不是标准的线段树！线段树初学者请看其他dalao的代码。

---

## 作者：Porsche (赞：1)

# 标准玄学分块

#### 时间复杂度O(玄学)

分块大家应该都明明白白，李煜东上面讲得很清楚。

首先，我们考虑把所有的灯分成若干个长度不超过⌊√N⌋的段，其中第 i 段左端点为 (i-1)⌊√N⌋+1 ,右端点为 min(i⌊√N⌋,N)。

另外，预处理处数组 sum ，其中 sum[i] 表示第 i 段的区间和。设 add[i] 表示第 i 段的“变化标记”（为 1 则表示整段都改变过，为 0 则表示没有变化），起初 add[i] = 0.

对于指令“0 a b”：

	1.若 l 与 r 同时处于第 i 段内，则直接把 A[l],A[l+1],…,A[r] 都加 d ，同时先清零 sum[i] 再重新计算 sum[i] 的值。
    
   2.否则，设 l 处于第 p 段， r 处于第 q 段。
   
   （1）对于 i ∈[p+1,q-1]，令 add[i]^=1。
   
   （2）对于开头、借尾不足一整段的两部分，按照与第1中情况相同的方法朴素地更新。

对于指令“1 a b”：
	
    1.若 l 与 r 同时处于第 i 段内，对于i∈[l,r]，a[i]^add[l]的和就是答案。
    
    2.否则，设 l 处于第 p 段， r 处于第 q 段，初始化 ans=0 。
    
    （1）对于 i ∈[p+1,q-1]，ans+=sum[i]。
    （2）对于开头、借尾不足一整段的两部分，按照与第1中情况相同的方法朴素地累加。
    
时间复杂度为O((N+Q)*√N)。

~~注：大都来自李煜东~~

话不多说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum[100001],a[100001],add[100001],pos[100001];
int flag;
void change(int l,int r)//更改操作 
{
	int p=pos[l],q=pos[r];
	for(int i=l;i<=min(r,p*flag);i++)
	{
		sum[p]-=a[i]^add[p];
		a[i]^=1;
		sum[p]+=a[i]^add[p];
	}//左边不足一整段部分 
	if(p!=q)//右边不足一整段部分
		for(int i=(q-1)*flag+1;i<=r;i++)
		{
			sum[q]-=a[i]^add[q];
			a[i]^=1;
			sum[q]+=a[i]^add[q];
		}
	for(int i=p+1;i<=q-1;i++)
	{
		add[i]^=1;
		sum[i]=flag-sum[i];
	}
}
int ask(int l,int r)
{
	int ans=0;
	int p=pos[l],q=pos[r];
	for(int i=l;i<=min(r,p*flag);i++)
		ans+=a[i]^add[p];//左边不足一整段部分
	if(p!=q)//右边不足一整段部分
		for(int i=(q-1)*flag+1;i<=r;i++)
			ans+=a[i]^add[q];
	for(int i=p+1;i<=q-1;i++)
		ans+=sum[i];
	return ans;
}
int main()
{
	int n,m;
	int a,b,c;
	scanf("%d%d",&n,&m);
	flag=sqrt(n);//√N 
	for(int i=1;i<=n;i++)
		pos[i]=(i-1)/flag+1;//初始化 
	while(m--)
	{
		scanf("%d%d%d",&c,&a,&b);
		if(c)cout<<ask(a,b)<<endl;
		else change(a,b);
	}
	return 0;
}
```
看不懂的私信我哦~

最近学习压力有点大，因为脑抽打错的题解颇多，希望大家多多包涵

---

## 作者：elijahqi (赞：1)

可怜的我昨天因为这个一看是线段树，就直接按照染色来做了，其实应该取反，计算数目的时候应该用整体，减去当前的数目

tree[x].f表示是否覆盖的标记false 表示还没有下放需要下放，true表示下放过了 实际上下放的应该都是反转操作而不是染色操作  一定要^1因为我有可能对这一段反复修改  假如再对当前相同一段就行操作，那么就不用下放了，下放答案反而错误

```cpp
#include<cstdio>
#define N 110000
inline int read(){
    int x=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch<='9'&&ch>='0') {x=x*10+ch-'0';ch=getchar();}
    return x;
}
struct node{
    bool f;int num,l,r,left,right;
}tree[N<<2];
int cnt=0;
void build(int &x,int l,int r){
    x=++cnt;tree[x].l=l;tree[x].r=r;tree[x].f=true;
    if (l==r){
        tree[x].num=tree[x].left=tree[x].right=0;
        return ;
    }    
    int mid=(l+r)>>1;
    build(tree[x].left,l,mid);build(tree[x].right,mid+1,r);
}
inline void pushdown(int x){
    int l1=tree[x].left,r1=tree[x].right;
//    tree[l1].f=tree[r1].f=false;
    tree[l1].f^=1;tree[r1].f^=1;
    tree[l1].num=tree[l1].r-tree[l1].l+1-tree[l1].num;
    tree[r1].num=tree[r1].r-tree[r1].l+1-tree[r1].num;
    tree[x].f=true;
}
inline int query(int x,int l,int r){
    if (l<=tree[x].l&&r>=tree[x].r)return tree[x].num;
    if (tree[x].f==false) pushdown(x);
    int mid=(tree[x].l+tree[x].r)>>1;
    int ans1=0,ans2=0;
    if (l<=mid) ans1=query(tree[x].left,l,r);
    if (r>mid) ans2=query(tree[x].right,l,r);
    return ans1+ans2;
}

inline void updata(int x){
    tree[x].num=tree[tree[x].left].num+tree[tree[x].right].num;
}
inline void change(int x,int l,int r){
    if (l<=tree[x].l&&r>=tree[x].r){
         tree[x].f^=1;
         tree[x].num=tree[x].r-tree[x].l+1-tree[x].num;
        return;
    }
    if (tree[x].f==false) pushdown(x);
    int mid=(tree[x].l+tree[x].r)>>1;
    if (l<=mid) change(tree[x].left,l,r);
    if (r>mid)    change(tree[x].right,l,r);
    updata(x);
}
int n,m,root,op,a,b;
void print(int x){
    if (tree[x].left) print(tree[x].left);
    printf("%d %d\n",tree[x].l,tree[x].r);
    if (tree[x].right) print(tree[x].right);
}
int main(){
    //freopen("3870.in","r",stdin);
//    freopen("3870.out","w",stdout);
    n=read();m=read();build(root,1,n);
//    print(root);
    for (int i=1;i<=m;++i){
        op=read();a=read();b=read();
        if (op) printf("%d\n",query(root,a,b));
        else change(root,a,b); 
    //    printf("%d\n",tree[root].num);
    }
    
    return 0;
}
```
<http://elijahqi.win> 蒟蒻的小blog


---

## 作者：abandentsky (赞：0)

这个题目我就是要用线段树（不管你们用啥），之前网赛出了这个题目，当时就是这个题目。然后内存开小了就段错误，开大了就ml气死个人。今天居然一发过了。。。。
思路：用seet【】数组来标记区间。每次将标记下放的时候也得把下放的区间给更新了。sum【】数组由seet【】数组来从新计算。最重要的是在查询的时候别玩了下放标记就好了。直接上代码：（自认为码风还行，能看得懂）。
```c

#include<bits/stdc++.h>
#define MAXN 200005
using namespace std;

int seet[MAXN],sum[MAXN];
int p,q,_sum;

void maintain(int o) //重新计算每个节点的灯的数量
{
    int Lc=o<<1;
    int Rc=o<<1|1;
    sum[o]=sum[Lc]+sum[Rc];
}

void pushdown(int o,int L,int R)  //下放标记
{
    int Lc=o<<1;
    int Rc=o<<1|1;
    if(seet[o])                 //被标记就下放，没标记就不用管
    {
        seet[Lc]^=1;
        seet[Rc]^=1;
        seet[o]=0;
        int mid=(L+R)/2;
        sum[Lc]=(mid-L+1)-sum[Lc];  //一定要重新计算一遍下放到的区间的值
        sum[Rc]=(R-mid)-sum[Rc];
    }
}

void update(int o,int L,int R)     //进行更新
{
    if(L>=p&&R<=q)
    {
        seet[o]^=1;
        sum[o]=(R-L+1)-sum[o];   //重新计算这个节点的值
        return ;
    }
    int mid=(L+R)/2;
    pushdown(o,L,R);              //下放节点
    if(p<=mid)
        update(o<<1,L,mid);
    if(q>mid)
        update(o<<1|1,mid+1,R);
    maintain(o);                //重新计算这个节点信息
}

void query(int o,int L,int R)    //进行查询
{
    if(L>=p&&R<=q)
    {
        _sum+=sum[o];
        return ;
    }
    int mid=(L+R)/2;
    pushdown(o,L,R);          //下放节点
    if(p<=mid)
        query(o<<1,L,mid);
    if(q>mid)
        query(o<<1|1,mid+1,R);
}

int n,m;
int op;

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d %d",&op,&p,&q);
        if(op==0)
        {
            update(1,1,n);
        }
        else if(op==1)
        {
            _sum=0;
            query(1,1,n);
            printf("%d\n",_sum);
        }
    }
    return 0;
}

```


---

## 作者：Erusel (赞：0)

~~据说这题好像有六倍经验~~

我们简单分析一下

我们令灯关着的时候是0，开着的时候是1

初始所有数都是0

题目要求支持两种操作，一种是区间异或1，还有一种是区间查询1的个数

考虑到所有数中只有0和1

所以查询可以改为查询区间和

区间异或1也可以从区间和的角度取考虑问题

---

假设我们原来有$k$个1，区间长度为$l$

现在就有$l-k$个1

所以$sum_{now}=l-sum_{pre}$

标记下传也可以维护了

时间复杂度就是维护一颗线段树的时间$O(nlogn)$

code:

```
#include<bits/stdc++.h>

#define rd(x) x=read()
#define N 200005 
 
using namespace std;

int n,m;
struct T{
	int l,r,mid,v,tag;
}t[N<<2];

inline int read()
{
    int f=1,x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    return x*f;
}

void pushdown(int rt,int len)
{
	if(t[rt].tag)
    {
        t[rt<<1].tag^=1; 
        t[rt<<1|1].tag^=1;
        t[rt<<1].v=(len-(len>>1))-t[rt<<1].v;
        t[rt<<1|1].v=(len>>1)-t[rt<<1|1].v;
        t[rt].tag=0;
    }
}

void build(int rt,int l,int r)
{
	int mid=(l+r)>>1;
	t[rt].l=l,t[rt].r=r,t[rt].mid=mid,t[rt].tag=0;
	if(l==r)
	{
		t[rt].v=0;
		return;
	}
	build(rt<<1,l,mid);
	build(rt<<1|1,mid+1,r);
	t[rt].v=t[rt<<1].v+t[rt<<1|1].v;
}

void update(int rt,int l,int r)
{
    if(l<=t[rt].l&&t[rt].r<=r)
    {
        t[rt].tag^=1;     
        t[rt].v=t[rt].r-t[rt].l+1-t[rt].v;    
        return;
    }
    pushdown(rt,t[rt].r-t[rt].l+1);
    if(l<=t[rt].mid)update(rt<<1,l,r);    
    if(t[rt].mid<r)update(rt<<1|1,l,r);        
    t[rt].v=t[rt<<1].v+t[rt<<1|1].v; 
}
int query(int rt,int l,int r)
{
    if(l<=t[rt].l&&t[rt].r<=r)return t[rt].v;
    pushdown(rt,t[rt].r-t[rt].l+1);
    int sum=0;
    if(l<=t[rt].mid)sum+=query(rt<<1,l,r); 
    if(t[rt].mid<r)sum+=query(rt<<1|1,l,r);        
    return sum;
}

int main()
{
	rd(n),rd(m);
	build(1,1,n);
	while(m--)
	{
		int opt,l,r;
		rd(opt),rd(l),rd(r);
		if(opt)printf("%d\n",query(1,l,r));
		else update(1,l,r);	
	}
	
	return 0;
}

```

---


# 数颜色

## 题目背景

大样例可在页面底部「附件」中下载。

## 题目描述

小 C 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有 相同的颜色。小 C 把她标号从 1 到 $n$ 的 $n$ 只兔子排成长长的一排，来给他们喂胡萝卜吃。 排列完成后，第 $i$ 只兔子的颜色是 $a_i$。

俗话说得好，“萝卜青菜，各有所爱”。小 C 发现，不同颜色的兔子可能有对胡萝卜的 不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而 绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 C 十分苦恼。所以，为 了使得胡萝卜喂得更加准确，小 C 想知道在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$ 的兔子。

不过，因为小 C 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同 时，小 C 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 $x_j$ 和 $x_j+1$ 的两 只兔子会交换位置。  小 C 被这一系列麻烦事给难住了。你能帮帮她吗？


## 说明/提示

【样例 1 说明】

前两个 1 操作和后两个 1 操作对应相同；在第三次的 2 操作后，3 号兔子和 4 号兔子

交换了位置，序列变为 1 2 2 3 3 3。

【数据范围与约定】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。 对于所有测试点，有 $1 \le l_j < r_j \le n,1 \le x_j < n$。 每个测试点的数据规模及特点如下表：

 ![](https://cdn.luogu.com.cn/upload/pic/9808.png) 

特殊性质 1：保证对于所有操作 1，有 $|r_j - l_j| \le 20$ 或 $|r_j - l_j| \le n - 20$。

特殊性质 2：保证不会有两只相同颜色的兔子。


## 样例 #1

### 输入

```
6 5 
1 2 3 2 3 3  
1 1 3 2 
1 4 6 3  
2 3 
1 1 3 2  
1 4 6 3```

### 输出

```
1 
2 
2 
3 
```

# 题解

## 作者：「QQ红包」 (赞：70)

肯定有人学数据结构学傻了。直接用 vector记录每个颜色出现的位置，然后二分一下就好。

因为颜色的范围很小，都不用离散。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(s>='0'&&s<='9'));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(s>='0'&&s<='9')
    {
        k=k*10+(s-'0');
        s=getchar();
    }
    return k*base;
}
void write(int x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10)write(x/10);
        putchar(x%10+'0');
    }
}
const int maxn=3e5+100;
const int maxm=6e5+100;
int n,m,bj,X,Y,Z,p1,p2;
int a[maxn],ans;
int tong[maxn];
int t1[maxn],Max;
int    t[11][maxn*2];
vector<int> g[maxn];
bool f1,f2,f3,f4;
void xg(int i,int x,int d)//t[i][x]+=d;
{
    int s=x;
    while (s<=n)
    {
        t[i][s]+=d;
        s+=(s&(-s));
    }
    return;
}
int qh(int i,int x)
{
    int s=x,sum=0;
    while (s)
    {
        sum+=t[i][s];
        s-=(s&(-s));
    }
    return sum;
}
int main()
{
    n=read();m=read();
    f4=true;
    for (int i=1;i<=n;i++) 
    {
        a[i]=read();
        Max=max(a[i],Max);
        if (tong[a[i]]!=0) f4=false;
        if (f4) tong[a[i]]=i;
        t1[a[i]]++;//cnt
    }
    if (Max<=10) f2=true; else f2=false;
/*    if (n<=1000)//一千以内的 
    {
        while (m--)
        {
            bj=read();
            if (bj==1)
            {
                ans=0;
                X=read();Y=read();Z=read();
                for (int i=X;i<=Y;i++)
                    if (a[i]==Z) ans++;
                printf("%d\n",ans);
            } else
            {
                X=read();
                swap(a[X],a[X+1]);
            }
        }
        return 0;
    }
    if (f4)//每个颜色只出现了一次 
    {
        while (m--)
        {
            bj=read();
            if (bj==1)
            {
                X=read();Y=read();Z=read();
                if (X<=tong[Z]&&tong[Z]<=Y) printf("1\n"); else printf("0\n");
            } else
            { 
                X=read();
                //a[X],a[X+1];
                tong[a[X]]++;
                tong[a[X+1]]--;
                swap(a[X],a[X+1]);
            }
        }
        return 0;
    }
    if (f2)//颜色小于10种，顺便说一下，不要用什么树状数组，前缀和维护一下就好 
    {
        for (int i=1;i<=n;i++) xg(a[i],i,1);
        while (m--)
        {
            bj=read();
            if (bj==1)
            {
                X=read();Y=read();Z=read();
                ans=qh(Z,Y)-qh(Z,X-1);
                printf("%d\n",ans);
            } else
            {
                X=read();
                xg(a[X],X,-1);
                xg(a[X],X+1,1);
                xg(a[X+1],X+1,-1);
                xg(a[X+1],X,1);
                swap(a[X+1],a[X]);
            }
        }
        return 0;
    }*/
    //然后还有一个部分分：特殊性质1
    //这个如果r-l<=20，暴力这一部分，否则暴力l~l-1和r+1~n，然后用整个的出现次数减一下就好 
    for (int i=1;i<=n;i++) g[a[i]].push_back(i);
    while (m--)
    {
        bj=read();
        if (bj==1)
        {
            X=read();Y=read();Z=read();
            p1=lower_bound(g[Z].begin(),g[Z].end(),X)-g[Z].begin();//找第一个>=X的 
            p2=upper_bound(g[Z].begin(),g[Z].end(),Y)-g[Z].begin()-1;//找第一个<=Y的 
            if (p2<p1) printf("0\n"); //这个注意要判掉 
            else
            printf("%d\n",p2-p1+1);
        } else
        {
            X=read();
            if (a[X]==a[X+1]) continue;//修改，如果颜色相同不用改了 
            p1=lower_bound(g[a[X]].begin(),g[a[X]].end(),X)-g[a[X]].begin();
            g[a[X]][p1]++;
            p2=lower_bound(g[a[X+1]].begin(),g[a[X+1]].end(),X+1)-g[a[X+1]].begin();
            g[a[X+1]][p2]--;
            swap(a[X],a[X+1]);//记得换掉 
        }
    }
    return 0;
}

```

---

## 作者：Sweetie_Liu (赞：45)

# P3939 数颜色

说实话，这题先一看是个主席树题，实际 ***没错我数据结构学疯了没救了***

## 先说主席树 ***~~涮法~~*** 

**首先我们看询问**，直接用版本相减，单点询问就行了。

**修改操作交换相邻的两个数**，我们只需把$x$的版本上剪掉$a_{i}$
并且加上$a_{i+1}$即可，$i+1$版本是不用动的。

如果是这样其实我们们离散化是完全可以过的。**但是**，出题的这个比查询的时候不保证辣个数是存在的，也就是离散化之后，直接二分查找寻找会$Wa$的妥妥的。其实只要在询问时判断这个时是否出现过即可 ***Ps：离散化别写错了，别问我问什么***。

### 但是我用血证明了它卡主席树的常，而且卡不过去，真的

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int read(){
	int w=1,x=0,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	return x*w;
}
const int MAXN = (int)5e5+10; 
int n,m,cnt,t[MAXN<<6],L[MAXN<<6],R[MAXN<<6];
void insert(int rt,int &newrt,int l,int r,int pos,int val){
	newrt = ++cnt;
	L[newrt] = L[rt],R[newrt] = R[rt];
	t[newrt] = t[rt] + val;
	if(l==r)return;
	int mid = l+r >> 1;
	if(pos<=mid)insert(L[rt],L[newrt],l,mid,pos,val);
	else insert(R[rt],R[newrt],mid+1,r,pos,val);
}
int query(int u,int v,int l,int r,int pos){
	if(l==r)return t[v] - t[u];
	int mid = l+r >> 1;
	if(pos<=mid)return query(L[u],L[v],l,mid,pos);
	else return query(R[u],R[v],mid+1,r,pos);
}
int a[MAXN],b[MAXN],version[MAXN],ar[(int)1e6+10];
int opt,l,r,k;
int main(){
//	freopen("testdata.in","r",stdin);
//	freopen("testdata.out","w",stdout);
	n = read(),m = read();
	for(int i=1;i<=n;i++)a[i] = read(),b[i] = a[i];
	sort(b+1,b+1+n);
	int len = unique(b+1,b+1+n) - b - 1;
	for(int i=1;i<=n;i++){
		int t = a[i];
		a[i] = lower_bound(b+1,b+1+len,a[i]) - b;
		insert(version[i-1],version[i],1,len,a[i],1);
		ar[t] = a[i];
	}
	for(int i=1;i<=m;i++){
		opt = read();
		if(opt==1){
			l = read(),r = read(),k = read();
			if(!ar[k]){
				printf("0\n");
				continue;
			}
			printf("%d\n",query(version[l-1],version[r],1,len,ar[k]));
		}
		else {
			k = read();
			if(a[k]==a[k+1])continue;
			insert(version[k],version[k],1,len,a[k],-1);
			insert(version[k],version[k],1,len,a[k+1],1);
			swap(a[k],a[k+1]);
		}
	}
	return 0;
} 
```
## 流氓数据结构 -> vector

但是vector是一个巨流批的东西，这道题用vector即好使，正确性也可以保障。

我们可以对值域开个vector，之后挂表，每个vector上表示的是，值为$x$的数的位置的升序排列。

**对于询问操作**因我们从小到大遍历的序列，所以每个vector中的位置自然有序，那么只用在询问权值对应的vector中去二分查找询问区间的左右端点即可。 $ptr_r-ptr_l+1$就是答案。

***ps：这里要注意，二分的左端点是lower_bound，但二分右端点是要用upper_bound - 1，只是因为，如果在该值域上挂的vector表中没有$ptr_l$,lower_bound会找到比它大的数，这满足要求，但在找右端点时，如果出现了以上情况，lower_bound 会帮你找到大于$ptr_r$的数（也就是不再询问区间的数被算进了答案中就会GG），你如果直接对lower_bound - 1,又会在vector中存在$ptr_r$时再次出现问题，所以我们用upper_bound - 1实现右端点的查找***

***对于修改操作***，因为我们vector中存的时位置，我们直接把$x$的位置++，把$x+1$ - -就好了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#include <algorithm>
using namespace std;
int read(){
	int w=1,x=0,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	return x*w;
}
const int MAXN = (int)3e5+100;
int n,m,a[MAXN];
vector<int>q[MAXN];
int opt,l,r,x;
int main(){
	n = read(),m = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
		q[a[i]].push_back(i);
	}
	while(m--){
		opt = read();
		if(opt==1){
			l = read(),r = read(),x = read();
			int ptr_l = lower_bound(q[x].begin(),q[x].end(),l) - q[x].begin();
			int ptr_r = upper_bound(q[x].begin(),q[x].end(),r) - q[x].begin() - 1;
			if(ptr_l>ptr_r){	
				printf("0\n");
				continue;
			}
			printf("%d\n",ptr_r-ptr_l+1);
		}
		else {
			x = read();
			if(a[x]==a[x+1])continue;
			int ptr_l = lower_bound(q[a[x]].begin(),q[a[x]].end(),x) - q[a[x]].begin();
			q[a[x]][ptr_l]++;
			int ptr_r = lower_bound(q[a[x+1]].begin(),q[a[x+1]].end(),x+1) - q[a[x+1]].begin();
			q[a[x+1]][ptr_r]--;
			swap(a[x],a[x+1]);
		}
	}
	return 0;
}
 
```


---

## 作者：微香玉烛暗 (赞：20)

这道题用一下$vector$就好，简单翻了一下题解，发现只有第一篇和我方法一样，代码却还有很大不同，所以发一篇题解纪念一下。

用$vector[a[i]]$记录颜色为a[i]的所有下标，因为是$vector$，比二维数组节省很大的空间。然后每次操作用到$lowerbound$和$upperbound$二分一下，查询区间内的头和尾就好了。

这题有几个坑点，下面代码里讲。

```cpp
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=50005;
int n,m,l,r,c,a[N];
int flag,p,q;
vector <int> v[N];

int main () {
//    freopen (".in","r",stdin);
//    freopen (".out","w",stdout);
	scanf ("%d%d",&n,&m);
	for (int i=1;i<=n;i++) {
		scanf ("%d",&a[i]);
		v[a[i]].push_back(i);//把下标压入该颜色
	}
	while (m--) {
		scanf ("%d",&flag);
		if (flag==1) {
			scanf ("%d%d%d",&l,&r,&c);//询问
			p=lower_bound(v[c].begin(),v[c].end(),l)-v[c].begin();
			q=upper_bound(v[c].begin(),v[c].end(),r)-v[c].begin()-1;//坑点1：这里不是lower
            //分别找头和尾
			if (q<p) puts("0");//坑点2：不特判会输负数
			else printf ("%d\n",q-p+1);
		}
		else {
			scanf ("%d",&c);
			if (a[c]==a[c+1]) continue;//坑点3：如果这两个本来就一样，根本不需操作，跳过就好
			p=lower_bound(v[a[c]].begin(),v[a[c]].end(),c)-v[a[c]].begin();
			v[a[c]][p]++;//相当于把改颜色内的c变成c+1
			q=lower_bound(v[a[c+1]].begin(),v[a[c+1]].end(),c+1)-v[a[c+1]].begin();
			v[a[c+1]][q]--;//c+1变成c
			swap(a[c],a[c+1]);//操作完别忘交换
		}
	}
    return 0;
    //完结撒花
}
```


---

## 作者：Hzxleo4 (赞：20)

这就是一个裸的主席树。

对每个颜色建一棵线段树， 然后就没了。。

```cpp
#include <cstdio>
#define lson l, m, lch[now]
#define rson m+1, r, rch[now]
#define swap(a, b) (a ^= b, b ^= a, a ^= b)
#define N 300005
int lch[N * 30], rch[N * 30], sum[N * 30], rt[N * 30], cnt;
int col[N];
void update(int l, int r, int &now, int p, int c){
    if(!p) return;
    if(!now) now = ++cnt;
    sum[now] += c;
    if(l == r) return;
    int m = l+r>>1;
    if(p <= m) update(lson, p, c);
    else update(rson, p, c);
}
int query(int l, int r, int now, int a, int b){
    if(!now) return 0;
    if(l >= a && r <= b) return sum[now];
    int m = l+r>>1, ans = 0;
    if(a <= m) ans = query(lson, a, b);
    if(b > m) ans += query(rson, a, b);
    return ans;
}
int main(){
    int i, j, n, m, c, o, a, b;
    scanf("%d%d", &n, &m);
    for(i = 1; i <= n; i++){
        scanf("%d", &c);
        col[i] = c;
        update(1, n, rt[c], i, 1);
    }
    for(i = 1; i <= m; i++){
        scanf("%d%d", &o, &a);
        if(o == 1) scanf("%d%d", &b, &c), printf("%d\n", query(1,n,rt[c],a,b));
        else{
            update(1, n, rt[col[a]], a, -1);
            update(1, n, rt[col[a+1]], a+1, -1);
            update(1, n, rt[col[a]], a+1, 1);
            update(1, n, rt[col[a+1]], a, 1);
            swap(col[a], col[a+1]);
        }
    }
    return 0;
}
```

---

## 作者：fstqwq (赞：12)

这里提供的是 std。

如果需要题解，请参考 [ppt](https://www.luogu.org/discuss/show?postid=26414)，或者其他同学的题解。


关于 STL：本来都是可以很简单手写的，我懒癌晚期 QAQ


```cpp
#include <bits/stdc++.h>
using namespace std;

int ch;
inline void read(int &a) {
    a = 0;
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') a = a * 10 + ch - '0', ch = getchar();
}

#define MAXN 300005

int n, m;
int a[MAXN];
vector <int> b[MAXN];

int main() {
    read(n); read(m);
    for (int i = 1; i <= n; i++) {
        read(a[i]);
        b[a[i]].push_back(i);
    }
    for (int i = 1; i <= n; i++) sort(b[i].begin(), b[i].end());
    for (int i = 1, x, l, r, c; i <= m; i++) {
        read(x);
        if (x == 1) {
            read(l); read(r); read(c);
            printf("%d\n", (int)(upper_bound(b[c].begin(), b[c].end(), r) - lower_bound(b[c].begin(), b[c].end(), l)));
        }
        else {
            read(x);
            if (a[x] != a[x + 1]) {
                (*lower_bound(b[a[x]].begin(), b[a[x]].end(), x))++;
                (*lower_bound(b[a[x + 1]].begin(), b[a[x + 1]].end(), x + 1))--;
                swap(a[x], a[x + 1]);
            }
        }
    }
    return 0;
}
```

---

## 作者：Sober_Clever (赞：7)

数据结构是优雅的暴力	——ybh

题目传送门：[数颜色](https://www.luogu.org/problemnew/show/P3939)

动态开点线段树（[跑得是真的慢](https://www.luogu.org/recordnew/show/20388284)）

对每一种颜色都开一棵线段树

注意常数优化（否则后三个点会T）

```cpp
#include<cstdio>
#include<algorithm>
#include<ctime>
using namespace std;
const int MAXN=3e5 + 5;

inline int read()
{
    int x=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
    return x*w;
}

struct Segment_Tree
{
    int lp,rp,sum;
}t[MAXN*80];
int rt[MAXN]={0},cnt=0,a[MAXN];
void Upd(int &p,int k,int l,int r,int tag)//单点修改 
{
    if(!p) p=++cnt;
    if(l==r)
    {
        t[p].sum+=tag;
        return ;
    }
    int mid=(l+r)>>1;
    if(k<=mid) Upd(t[p].lp,k,l,mid,tag);
    else Upd(t[p].rp,k,mid+1,r,tag);
    t[p].sum=t[t[p].lp].sum+t[t[p].rp].sum;
}

int Query(int p,int l,int r,int x,int y)
{
    if(!p) return 0;
    if(x<=l&&r<=y)
        return t[p].sum;
    int mid=(l+r)>>1,ans=0;
    if(x<=mid) ans+=Query(t[p].lp,l,mid,x,y);
    if(mid<y) ans+=Query(t[p].rp,mid+1,r,x,y);
    return ans;
}
int main()
{
	/*freopen("r","in.in",stdin);
	freopen("w","out.out",stdout);
	double s=clock(),e;*/
    int n=read(),m=read();
    for(register int i=1;i<=n;i++)
    {
        a[i]=read();
        Upd(rt[a[i]],i,1,n,1);
    }
    while(m--)
    {
        int op=read(),l,r,x;
        if(op==1)
        {
            l=read(),r=read(),x=read();
            int ans=Query(rt[x],1,n,l,r);
            printf("%d\n",ans);
        }
        else
        {
            x=read();
            Upd(rt[a[x]],x,1,n,-1);
            Upd(rt[a[x+1]],x+1,1,n,-1);
            Upd(rt[a[x]],x+1,1,n,1);
            Upd(rt[a[x+1]],x,1,n,1);
        	int t=a[x];a[x]=a[x+1];a[x+1]=t;
		}
    }
    //e=clock();
    //printf("%.2lf ms\n",e-s);
    return 0;
}
```


---

## 作者：Na2PtCl6 (赞：6)

## 分析题目
此题大致解法是用 `vector` 存颜色在序列中的位置，查询操作可用二分在对应颜色的 `vector` 中求区间长度得到答案，修改操作就是在对应的 `vector` 中找出该兔子，进行颜色修改。

## 代码实现
讲一些细节。

### 1.
我看到 [redbag 的题解](https://www.luogu.com.cn/blog/ylx/solution-p3939) 中询问部分有一个比较麻烦的写法 
```cpp
p1=lower_bound(g[Z].begin(),g[Z].end(),X)-g[Z].begin();
p2=upper_bound(g[Z].begin(),g[Z].end(),Y)-g[Z].begin()-1; 
if(p2<p1) 
	puts("0");  
else
	printf("%d\n",p2-p1+1);
```
（代码略有改动）

其实可以精简成这样

```cpp
printf("%d\n",upper_bound(col[c].begin(),col[c].end(),r)-lower_bound(col[c].begin(),col[c].end(),l));
```
两个 `vector<int>` 的迭代器是直接可以做加减的，所以没必要再改成下标，再在整数意义下做减法。

那 $p2<p1$ 这种情况怎么办？会漏掉吗？

不会。`upper_bound` 找到的位置一定 $\ge$ `lower_bound` 找到的位置，就算落在同一个点上，$p2$ 也只会比 $p1$ 小 $1$ ，所以不管怎样，这个判断都是冗余的。

### 2.
修改操作坑比较多。

如果要交换的兔子颜色不同，那么交换就是无意义的，把这个判断掉可以节省一些时间。

交换兔子的过程别想复杂了，就是在 `vector` 中找到要换过来的两只兔子，然后把前面那只的位置加一，后面那只的位置减一。

修改完之后要 **交换原数组中的颜色**
### 3.
此题输出量可能较大，于是我加了输出优化。

快写只是最基本的，还可以用 `char` 数组储存结果，用 `fwrite` 加速输出。

储存结果
```cpp
void save(const int x){
	if(x>9)
		save(x/10);
	res[++cnt]=x%10+48;
}
```

最后一起输出
```cpp
fwrite(res+1,1,cnt,stdout);
```

`res` 数组我一般开到答案规模的 $10$ 倍，但具体还是要看题，卡空间的题目慎用。

### 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=300004;
char res[maxn*10];
int n,m,op,cnt,a[maxn];
vector < int > col[maxn];

inline void read(int &x){
	char c=getchar();x=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c^48);
}

void print(const int x){
	if(x>9)
		print(x/10);
	res[++cnt]=x%10+48;
}

int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){
		read(a[i]);
		col[a[i]].push_back(i);
	}
	while(m--){
		read(op);
		int l,r,c,x;
		if(op==1){
			read(l),read(r),read(c);
			print(upper_bound(col[c].begin(),col[c].end(),r)-
			lower_bound(col[c].begin(),col[c].end(),l));
			res[++cnt]='\n';
		}
		else{
			read(x);
			int c1=a[x],c2=a[x+1];
			if(c1==c2)
				continue;
			int p1=lower_bound(col[c1].begin(),col[c1].end(),x)
			-col[c1].begin();
			int p2=lower_bound(col[c2].begin(),col[c2].end(),x+1)
			-col[c2].begin();
			++col[c1][p1];
			--col[c2][p2];
			swap(a[x],a[x+1]);
		}
	}
	fwrite(res+1,1,cnt,stdout);
	return 0;
}
```
目前是最优解。

---

## 作者：ACAね (赞：6)

一个真正的学数据结构学傻的人来提供一种简单易想的思路

~~代码也不长对吧~~

第一眼：sb题！对于每种颜色的兔子建一个权值树状数组就可以了

第二眼：等等这数据范围好像有些不对，开不下

第三眼：哈，cdq代替树状数组就可以了啊


~~就我用cdq???~~

以上

ps: cdq左闭右开

ps2:不知道为什么，估计是什么边界情况没考虑，第二个点挂了，没有数据，对拍也没弄出来，就写个暴力特判一下QwQ。

ps3:如果有人能看出我为什么Test2挂烂，请在评论区指出，谢谢大佬
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=3e5+7;
const int M=3e5+7;
struct Query{
    int type,id,val;
    bool operator < (const Query &p){
        if(id==p.id)return type<p.type;
        return id<p.id;
    }
};
vector<Query>qry[M];
int acnt;
int col[N];
int ans[M];
Query tmp[M*8];
void cdq(int l,int r,vector<Query>&query)
{
    if(r-l<=1)return;
    int mid=(l+r)>>1;
    cdq(l,mid,query),cdq(mid,r,query);
    int sum=0;
    int p=l,q=mid,cnt=0;
    while(p<mid&&q<r)
        if(query[p]<query[q])
        { 
            if(query[p].type==1)sum+=query[p].val;
            tmp[cnt++]=query[p++];
        }
        else
        { 
            if(query[q].type==2)ans[query[q].val]-=sum;
            else if(query[q].type==3)ans[query[q].val]+=sum;
            tmp[cnt++]=query[q++];
        }
    while(p<mid)tmp[cnt++]=query[p++];
    while(q<r)
    {
        if(query[q].type==2)ans[query[q].val]-=sum;
        else if(query[q].type==3)ans[query[q].val]+=sum;
        tmp[cnt++]=query[q++];
    }
    for(int i=0;i<cnt;++i)query[i+l]=tmp[i];
}
int a[10001];
int main(void)
{
    scanf("%d%d",&n,&m);
    if(n<=10000)
    {
        for(int i=1;i<=n;++i)scanf("%d",a+i);
        for(int i=1;i<=m;++i)
        {
            int t;
            scanf("%d",&t);
            if(t==1)
            {
                int l,r,c;
                scanf("%d%d%d",&l,&r,&c);
                int ans=0;
                for(int i=l;i<=r;++i)if(a[i]==c)ans++;
                printf("%d\n",ans);
            }
            else
            {
                int x;
                scanf("%d",&x);
                swap(a[x],a[x+1]);
            }
        }
        return 0;
    }
    for(int i=1;i<=n;++i)
    {
        int a;
        scanf("%d",&a);
        col[i]=a;
        qry[a].push_back((Query){1,i,1});
    }
    for(int i=1;i<=m;++i)
    {
        int t;
        scanf("%d",&t);
        if(t==1)
        {
            int l,r,c;
            scanf("%d%d%d",&l,&r,&c);
            qry[c].push_back((Query){2,l-1,acnt});
            qry[c].push_back((Query){3,r,acnt++});
        }
        else
        {
            int x;
            scanf("%d",&x);
            int cx=col[x],cx1=col[x+1];
            if(cx==cx1)continue;
            swap(col[x],col[x+1]);
            qry[cx].push_back((Query){1,x,-1});
            qry[cx].push_back((Query){1,x+1,1});
            qry[cx1].push_back((Query){1,x+1,-1});
            qry[cx1].push_back((Query){1,x,1});
        }
    }
    for(int i=1;i<=n;++i)
        if(!qry[i].empty())
            cdq(0,qry[i].size(),qry[i]);
    for(int i=0;i<acnt;++i)printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：半仙胡小桃 (赞：6)

[链接](https://www.luogu.org/problemnew/show/3939)

如何在一个区间内查一个数字出现的次数？

疯狂脑补~~搞基数据结构~~（这个叫做数据结构病）

好像没有合适的QuQ

于是开始想正常解法。

我们可以开始想一下正常解法。

c[i][j]表示的是i颜色第j个兔子出现的位置。

不是~~DP~~

很明显c[i]里面存的兔子出现的位置是递增的。

那么我们就可以二分查找了。

查这个颜色里小于l位置的兔子有几只。

颜色里小于等于位置的兔子有几只。

然后一减就是答案了。

等一下，二维数组开多大？

开vector啊（逃~

至于修改，记录下来然后交换就行了。

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
struct node{
    int col,w;
}a[3*110000];
vector <int> c[3*110000];
int find(int id,int x)
{
    int l=1,r=c[id].size()-1;
    int ans=0;
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(c[id][mid]>=x) ans=mid,r=mid-1;
        else l=mid+1;
    }
    return ans;
}
int main()
{
    int n,q;
    scanf("%d%d",&n,&q);
    /*for(int i=1;i<=3*1e5;i++)
     c[i].push_back(0);*/
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        c[x].push_back(i);
        a[i].col=x,a[i].w=c[x].size()-1;
    }
    for(int i=1;i<=q;i++)
    {
        int opt;
        scanf("%d",&opt);
        if(opt==1)
        {
            int l,r,cr;
            scanf("%d%d%d",&l,&r,&cr);
            if(c[cr].size()==0)
            {
                printf("0\n");
                continue;
            } 
            int pos1=lower_bound(c[cr].begin(),c[cr].end(),l)-c[cr].begin();
            int pos2=upper_bound(c[cr].begin(),c[cr].end(),r)-c[cr].begin();
            printf("%d\n",pos2-pos1);
        }
        if(opt==2)
        {
            int x;
            scanf("%d",&x);
            if(a[x].col==a[x+1].col) continue;
            int w1=a[x].w,w2=a[x+1].w;
            int c1=a[x].col,c2=a[x+1].col;
            a[x].col=c2,a[x+1].col=c1;
            a[x].w=w2,a[x+1].w=w1;
            c[c1][w1]=x+1;
            c[c2][w2]=x;
        }
    }
    
    return 0;
}
```

---

## 作者：heyy (赞：5)

#不用二分和vector的简单做法


    

            






```cpp
//这应该算一个sao操作吧 
//既没有用vector，也没有用二分 
//思路非常淳朴，代码非常直白 
//如果不是第15个点要特判，就更简单了 
//思路是把输入数据优先按颜色再按位置排个序 
//记录每种颜色在排好序的数组里的初末位置 
//记得找完之后break就行了 
//交换操作也是一样枚举所在位置
//然后改变排好序的数组里它的原位置 
//记住一定要交换初始数组（不要问我怎么知道的） 
//这样就能得95分了 
//但第15个点不一样
//因为它颜色太少了只有10 
//所以for循环枚举颜色会T 
//因此要特判
//但它颜色只有10 
//所以也很简单 
//把每种颜色在到i的总数记录下来 
//然后 后减前得到结果 
//交换因为是邻着换所以不会影响后面的 
//记得换原数组就行了 
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std; 
#define ll long long
const int maxn=300005;
int a[maxn],shi[maxn],mo[maxn];
inline int read()
{
    char ch;int x=0;int f=1;ch=getchar();
    while (ch!='-'&&(ch<'0'||ch>'9'))
        ch=getchar();
    ch=='-'?f=-1:x=ch-'0',ch=getchar();
     while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
     return x*f;
}
struct rrr
{
    int se,wei;
}r[maxn];
int pai(const rrr &a,const rrr &b)
{
    if(a.se<b.se)return 1;
    else if(a.se>b.se)return 0;
    if(a.se==b.se)
    {
        if(a.wei<b.wei)return 1;
        else return 0;
    }
}
int te[10][300005],b[11];
int main() 
{
    int da=0;
    int n,p,m,x,ans,y,z,w;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
        r[i].se=a[i];
        r[i].wei=i;
        da=max(a[i],da);     //特判准备 
    }
if(da>10)                    
{    sort(r+1,r+n+1,pai);
    shi[r[1].se]=1;
    for(int i=2;i<=n;i++)
    {
        if(r[i].se>r[i-1].se)
        {
            shi[r[i].se]=i;
            mo[r[i-1].se]=i-1;
        }
    }
    mo[r[n].se]=n;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&w);
        if(w==1)
        {
            scanf("%d%d%d",&x,&y,&z);
            ans=0;
            for(int j=shi[z];j<=mo[z];j++)
            {
                if(r[j].wei>=x&&r[j].wei<=y)
                {
                    ans++;
                }
                if(r[j].wei>y+100)  //加不加无所谓 
                break;
            }
            printf("%d\n",ans);
        }
        else if(w==2)
        {
            scanf("%d",&x);
            int a1=a[x],b1=a[x+1];
            swap(a[x],a[x+1]);  // 很重要不能忘 
            for(int j=shi[a1];j<=mo[a1];j++)
            {
                if(r[j].wei==x)
                {
                    r[j].wei=x+1;
                    break;
                }
            }
            for(int j=shi[b1];j<=mo[b1];j++)
            {
                if(r[j].wei==(x+1))
                {
                    r[j].wei=x;
                    break;
                }
            }
        }
    }
}
else                         //特判 
{
    for(int i=1;i<=n;i++)
    {
        b[a[i]]++;
        for(int j=1;j<=10;j++)
        {
            te[j][i]=b[j];    
        }
    }    
    for(int i=1;i<=m;i++)
    {
        w=read();
        if(w==1)
        {
            scanf("%d%d%d",&x,&y,&z);
            printf("%d\n",te[z][y]-te[z][x-1]);
        }
        else if(w==2)
        {
            scanf("%d",&x);
            te[a[x]][x]--;
            te[a[x+1]][x]++;
            swap(a[x],a[x+1]);
        }
    }
}
    return 0;
}

```

---

## 作者：Juan_feng (赞：3)

emm...这题分块有点卡空间

机房dalao直接按题意分块被卡时间+卡空间了。。。 所以考虑一下怎样优化， 一看这种求个数的题目， 颜色种类一般都不会很多， 所以尝试离散化。 离散化之后用一个cnt数组来处理一下每种离散化后颜色个数的前缀和， 交换两个点的时候如果这两个点再同一个块里自然直接改， 不在的话修改一下本块的cnt也就是了。查询的时候散块直接暴力， 整块前缀和相减，这样修改的复杂度是O1， 查询的时间复杂度是 两个块的长度（散块的查询） 。足以通过此题

于是愉快的MLE到95分， 尝试用unsinged short来存cnt数据， 但是这样又会WA一个点， 把块调大了一些就过了。

另外注意： 查询的颜色未必在初始序列中出现， 所以要开个数组特判一下。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define maxn 300010 
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, t, x, y, s;
int sq;
int a[maxn], b[maxn], z[maxn];
bool bl[maxn];
int cnt[550][maxn];
inline void in(re int &x){
    x=0;re int bl = 1;char c=getchar();
    while(c<'0'||c>'9'){
    	if(c == '-')
    	  bl = -1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x *= bl;
}

void out(re int a){
    if(a < 0) {
        putchar('-');
        a = -a;
    }
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

inline int query(int x, int y, int k) {
    int res = 0;
    FOR(i, x, min(y, b[x]*sq))
      if(a[i] == k)
        ++res;
    if(b[x] != b[y])
      FOR(i, (b[y]-1)*sq+1, y)
        if(a[i] == k)
          ++res;
    if(b[x] < b[y]) {
        res += (cnt[b[y]-1][k]-cnt[b[x]][k]);	
    }
    return res;
}

void change(int x) {
    if(b[x] == b[x+1]) {
        swap(a[x], a[x+1]);
    }
    else {
        --cnt[b[x]][a[x]];
        ++cnt[b[x]][a[x+1]];
        swap(a[x], a[x+1]);
    }
}

int main() {
    in(n), in(m);
    sq = min(n, 1528); 
    FOR(i, 1, n)
      in(a[i]), b[i] = (i-1)/sq+1, z[i] = a[i], bl[a[i]] = 1;
    z[0] = n;
    sort(z+1, z+z[0]+1);
    z[0] = unique(z+1, z+z[0]+1)-z-1;
    FOR(i, 1, n) {
        a[i] = lower_bound(z+1, z+z[0]+1, a[i])-z;
        ++cnt[b[i]][a[i]];
    }
    FOR(i, 2, b[n]) {
        FOR(j, 1, z[0])
          cnt[i][j] += cnt[i-1][j];
    }
    FOR(i, 1, m) {
        in(t);
        if(t == 1) {
            in(x), in(y), in(s);
            if(!bl[s]) {
            	puts("0");
            	continue;
			} 
            s = lower_bound(z+1, z+z[0]+1, s)-z;
            out(query(x, y, s)),
            putchar(10);
        }
        else {
            in(x);
            change(x);
        }
    }
}
```

---

## 作者：king_storm (赞：1)

# 这里提供一种模拟数组的写法
###### 首先，思路就是像vector那样，我们用一个cnt[i]数组表示i这种颜色出现了多少次，d[i]表示输入的第i个元素的颜色在当时是第几次出现，c[i]就是输入的第i个元素，a[i].val就是c[i],a[i].low就是i，id[i]表示i这个颜色第一次出现在a[i]中的数组下标
##### 变量名阐述完了，接下来就是骚操作
#### 我们想想看，当我们存好a[i]后，对他进行val（val要离散化，这样更方便我们初始化id[i]）从小到大排序，这样我们的数组就变成了类似分块的一个数组（也就是将二维数组活生生的压成了一维），当我们查询的时候直接从id[x]->id[x+1]-1这一段区间进行搜索（其中你需要手写二分，查得更快（我们排序的时候在val相等的时候将low从小到大排（方便d[k]修改））），而我们在修改的时候，就通过id,c,d三个数组找到a的数组下标进行0（1）修改，同时我们需要更改c,d数组；
#### 大体上思路就这样，直接如果还有啥操作不清楚的，直接看代码
###
###
#### 我先发一个没有离散化和二分查找的码子（90）
```
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=300000+40;
int id[maxn],cnt[maxn],c[maxn],d[maxn];
int n,m;
struct node
{
	int val,low;
}a[maxn];
int cmp(node x,node y)
{
	if(x.val==y.val) return x.low<y.low;
	return x.val<y.val;
}
int main()
{
//	freopen("flower.in","r",stdin);
//	freopen("flower.out","w",stdout);
	int x,opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		c[i]=x;
		cnt[x]++;
		d[i]=cnt[x];
		a[i].val=x;
		a[i].low=i;
	}
	sort(a+1,a+n+1,cmp);
	//for(int i=1;i<=n;i++) printf("%d %d\n",a[i].val,a[i].low);
	id[0]=1;
	for(int i=1;i<=n+1;i++) id[i]=id[i-1]+cnt[i-1];
	//for(int i=1;i<=n;i++) printf("%d ",id[i]);printf("\n");
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&l,&r,&x);
			int ans=0;
			for(int j=id[x];j<id[x+1];j++)
			{
				if(a[j].low>=l&&a[j].low<=r)
				{
					ans++;
				}
			}
			printf("%d\n",ans);
		}
		else
		{
			scanf("%d",&k);
			int tmp1=id[c[k]]+d[k]-1;
			int tmp2=id[c[k+1]]+d[k+1]-1;
			if(a[tmp1].val!=a[tmp2].val)
			{
				a[tmp1].low=k+1;
				a[tmp2].low=k;
				int sum1,sum2;
				sum1=c[k];c[k]=c[k+1];c[k+1]=sum1;
				sum2=d[k];d[k]=d[k+1];d[k+1]=sum2;
			}
		}
	}
	return 0;
}
```
#### 加点小优化（就特长，ac）
```
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=300000+40;
int id[maxn],cnt[maxn],c[maxn],d[maxn],e[maxn];
int ys[maxn];
int n,m;
struct node
{
	int val,low;
	bool friend operator <(node x,node y)
	{
		return x.low>y.low;
	}
}a[maxn];
struct no
{
	int id,x;
}b[maxn];
int cmp(node x,node y)
{
	if(x.val==y.val) return x.low<y.low;
	return x.val<y.val;
}
int ef(int l,int r,int x)
{
	int ans=0;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(a[mid].low>x)
		{
			r=mid-1;
		}
		else l=mid+1;
	}
	return l;
}
int main()
{
	int x,opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		c[i]=x;
		e[i]=x;
		cnt[x]++;
		d[i]=cnt[x];
		a[i].val=x;
		a[i].low=i;
	}
	sort(e+1,e+n+1);
	int pos=0;
	b[++pos].x=e[1];
	ys[e[1]]=pos;
	b[pos].id=pos;
	for(int i=2;i<=n;i++)
	{
		if(e[i]!=e[i-1])
		{
			b[++pos].x=e[i];
			ys[e[i]]=pos;
			b[pos].id=pos;
		}
	}
	sort(a+1,a+n+1,cmp);
	//for(int i=1;i<=n;i++) printf("%d %d\n",a[i].val,a[i].low);
	id[0]=1;
	for(int i=1;i<=pos+1;i++) id[i]=id[i-1]+cnt[b[i-1].x];
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&l,&r,&x);
			if(!cnt[x])
			{
				printf("0\n");
				continue;
			}
			int ans=0;
			int t1=ef(id[ys[x]],id[ys[x]+1]-1,l-1);
			int t2=ef(id[ys[x]],id[ys[x]+1]-1,r);
			printf("%d\n",t2-t1);
		}
		else
		{
			scanf("%d",&k);
			int tmp1=id[ys[c[k]]]+d[k]-1;
			int tmp2=id[ys[c[k+1]]]+d[k+1]-1;
			if(a[tmp1].val!=a[tmp2].val)
			{
				a[tmp1].low=k+1;
				a[tmp2].low=k;
				int sum1,sum2;
				sum1=c[k];c[k]=c[k+1];c[k+1]=sum1;
				sum2=d[k];d[k]=d[k+1];d[k+1]=sum2;
			}
		}
	}
	return 0;
}
```

好了，我讲完了，是不是很优秀


---

## 作者：何卓然 (赞：1)

首先要夸赞一波出题人，这次的NOIP模拟赛是我到过的最好的模拟赛了，出题非常认真，题目构造十分精妙， 数据点的设计很有联赛的精神，给出题人点赞。


D1T2 是一道看似像极了数据结构，然而是一道用二分查找和题目性质来解决的题目，思维含量比较高。

题目要求我们支持两种操作，查询区间内某一元素的数目，以及交换某两个相邻的元素。


这道题目和传统线段树题的最大区别就在于题目要求的修改操作，仅仅涉及相邻元素，这使得任意的修改，都不会改变同一个颜色的元素之间的相对位置，我们考虑用 vector 来**按顺序**（事实上我们并不需要刻意地维护每个向量内的有序性，这里用到了刚刚的性质）存下每个颜色的每个位置。


对于查询操作，我们在被查询颜色的 vector 内根据要求区间的 l, r 进行二分查找， log 复杂度得到元素个数。

对于修改操作，如果这两个相邻元素颜色相同，则不必操作，否则我们可以分别在对应颜色的 vector 里面找到它的位置，直接交换就可以了。（还是刚刚的性质） 复杂度依然是 log 的


对于实际数据情况，有一个颜色的兔子可能不会很多，我们采用 stl 为我们提供的二分查找函数就可以很优雅的解决这个问题，总时间复杂度 m\*logn （最坏）


**Code**





        
        

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
#define REP(i,a,b) for (int i = (a), i##_end = (b); i < i##_end; ++i)
#define pb push_back
#define ALL(x) (x.begin(), x.end())
const int N = 300000 + 5;
int n, m, c[N];
vector< vector<int> > v(N);
int main() {
    scanf("%d%d",&n,&m);
    REP(i,1,n+1) {
        scanf("%d",&c[i]);
        v[c[i]].pb(i);
    }
    REP(i,0,m) {
        int command, l, r, q;
        scanf("%d", &command);
        if (command == 1) {
            scanf("%d%d%d",&l,&r,&q);
            vector<int>::iterator low,up; // 注意 STL 函数中 lower & upper 的返回值是一个迭代器
            low = lower_bound(v[q].begin(), v[q].end(), l);
            up  = upper_bound(v[q].begin(), v[q].end(), r);
            printf("%d\n", up - low);  
        }
        if (command == 2) {
           scanf("%d",&l);
           if (c[l] != c[l + 1]) {
               int c1 = c[l], c2 = c[l + 1];     
               vector<int>::iterator lpos, rpos;  
               lpos = lower_bound(v[c[l]].begin(), v[c[l]].end(), l);
               rpos = lower_bound(v[c[l + 1]].begin(), v[c[l + 1]].end(), l + 1); 
               swap(v[c[l]][lpos - v[c[l]].begin()], v[c[l + 1]][rpos - v[c[l + 1]].begin()]);
               c[l] = c2;
               c[l + 1] = c1; // 再维护一下颜色数组
           }
        }
    }
    return 0;
}

```

---

## 作者：Great_Influence (赞：1)

趁着比赛刚结束赶紧交一篇题解。

其实就维护每个数字出现的位置就可以了，用vector存，1操作就输出尾位置在数字出现位置的位置减去首位置的就可以了。至于2操作，先判断2个位置上的数字是否相等，相等就跳过，不然就直接swap就可以了。

代码：

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//快读
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
char r[20];
void write(int z)//快输
{
    int len=0;
    if(!z)
    {
        putchar(48);
        putchar('\n');
        return;
    }
    for(;z;z/=10)r[++len]=z%10;
    while(len)putchar(r[len--]+48);
    putchar('\n');
}
void file()
{
    #ifndef ONLINE_JUDGE
    freopen("color.in","r",stdin);
    freopen("color.out","w",stdout);
    #endif
}
const int MAXN=300010;
const int inf=0xFFFFFFF;
vector<int>R[MAXN];
int a[MAXN],e,n,m;
void init()
{
    int i;
    read(n);read(m);
    For(i,1,n)
    {
        read(a[i]);
        R[a[i]].push_back(i);//vector存出现位置
    }
    For(i,1,300000)R[i].push_back(inf);
}
void solve()
{
    int opt,l,r,x;
    while(m--)
    {
        read(opt);
        if(opt==1)
        {
            read(l);read(r);read(x);
            write(distance(lower_bound(R[x].begin(),R[x].end(),l)//求位置，l、r用二分求
            ,upper_bound(R[x].begin(),R[x].end(),r)));
        }
        else
        {
            read(x);
            if(a[x]==a[x+1])continue;//相等就不换
            int u=distance(R[a[x]].begin()
                ,lower_bound(R[a[x]].begin(),R[a[x]].end(),x)),
                v=distance(R[a[x+1]].begin()
                ,lower_bound(R[a[x+1]].begin(),R[a[x+1]].end(),x+1));//否则就直接换
            R[a[x]][u]=x+1;
            R[a[x+1]][v]=x;
            swap(a[x],a[x+1]);
        }
    }
}
int main()
{
    file();
    init();
    solve();
    return 0;
}

```

---

## 作者：liangjialin (赞：1)

这题有点日本题（脑袋要转的过弯，代码并不复杂）的味道，非常适合学数据结构学傻掉的人。

按颜色排序后，对于每次查询$l_j, r_j, c_j$，在颜色$c_j$段（已经按颜色排序了喔）里二分查找就好了。

**十个（手打）二分九个错**，比较通用的写法是求$\max$时，$mid$向上取整，求$\min$时，$mid$向下取整。（如果你用```lower\_bound```和```upper\_bound```当我没说）
手打二分的健壮性很糟糕（```lower\_bound```和```upper\_bound```怎么样我不清楚）。因此，另外需要特判的情况包括：原序列中不包含查询的颜色（这个似乎会卡50分？）；交换的兔子颜色相同（这个似乎会卡20分？）。

```cpp
#include <cstdio>
#include <algorithm>
using std::sort;
using std::swap;
const int MAXN = 3e5 + 1;
int readint() {
  char ch;
  while ( (ch = getchar()) < 48 || ch > 57 );
  int x = 0;
  do {
    x = (x << 3) + (x << 1) + ch - 48;
  } while ( (ch = getchar()) >= 48 || ch >= 57 );
  return x;
}
struct rabbit {
  int id, color;
  rabbit(){}
  rabbit(int init\_id, int init\_color):
    id(init\_id), color(init\_color) {}
  friend bool operator < (const rabbit &r1, const rabbit &r2) {
    return r1.color == r2.color ? r1.id < r2.id : r1.color < r2.color;
  }
}a[MAXN]; 
struct block {
  int begin, end;
  block(): begin(-1), end(-1) {}
}b[MAXN]; //b[i]: 颜色i的兔子在排序后的数组中的下标段 

//求    M I N    x
//  key<=a[x].id
int BS1(int lb, int rb, int key) {
  int m, l = lb, r = rb;
  while (l < r) {
    m = (l + r) >> 1;
    if (a[m].id < key)
      l = m + 1;
    else
      r = m;
  }
  return l;
}
//求    M A X    x
//  a[x].id<=key
int BS2(int lb, int rb, int key) {
  int m, l = lb, r = rb;
  while (l < r) {
    m = (l + r + 1) >> 1;
    if (a[m].id <= key)
      l = m;
    else
      r = m - 1;
  }
  return l;
}
int rank[MAXN]; //排序后原本的第i只兔子现在的下标 
int main() {
  int n = readint(), m = readint();
  for (int i = 0; i < n; i++)
    a[i] = rabbit(i, readint());
  sort(a, a + n);
  for (int i = 0, cur\_color; i < n; ) {
    cur\_color = a[i].color;
    b[cur\_color].begin = i;
    for (; i < n && a[i].color == cur\_color; i++);
    b[cur\_color].end = i - 1;
  }
  for (int i = 0; i < n; i++)
    rank[a[i].id] = i;
  for (int i = 0, lb, rb, key; i < m; i++) {
    if (readint() == 1) {
      lb = readint() - 1; rb = readint() - 1; key = readint();
      if (b[key].begin == -1 || lb > a[b[key].end].id || rb < a[b[key].begin].id) {
        printf("0\n");
        continue;
      }
      printf("%d\n", BS2(b[key].begin, b[key].end, rb) -
                     BS1(b[key].begin, b[key].end, lb) + 1);
    } else {
      key = readint() - 1;
      if (a[rank[key]].color == a[rank[key + 1]].color)
        continue;
      swap(a[rank[key]].id, a[rank[key + 1]].id);
      swap(rank[key], rank[key + 1]);
    }
  }
  return 0;
}
```

---

## 作者：yangyujia18 (赞：0)

这道题看似很难~~线段树和主席树的标签让包括我在内的蒟蒻瑟瑟发抖~~，其实很简单  
题目大意就是给你一个数列，有两种操作，一个是统计一个区间内某数出现的次数，另一个是交换相邻两数的位置  
用vector存颜色出现的位置  
使用lower_bound和upper_bound~~比线性还好写的~~二分查找区间内目标颜色第一次和最后一次出现的位置，并将它们在vector中的位置相减得到的结果加1就是答案  
交换更简单，交换前后其实位置只+1或-1，找到在vector中的位置操作即可  
lower_bound(起始位置地址，终止位置地址（不包括），基准值）可以找范围内第一个基准值  
upper_bound格式相同，找最后一个基准值  
原谅我代码比较宽~~可我真的不想开新变量了QwQ~~  
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> rab[300005];
int main()
{
	int n,m,cz;
	scanf("%d%d",&n,&m);
	int color[n+1];
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&color[i]);
		rab[color[i]].push_back(i);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&cz);
		if(cz==1)
		{
			int a,b,c;
			scanf("%d%d%d",&a,&b,&c);
			printf("%d\n",max(0,int(upper_bound(rab[c].begin(),rab[c].end(),b)-lower_bound(rab[c].begin(),rab[c].end(),a))));
		}
		else
		{
			int x;
			scanf("%d",&x);
			if(color[x]==color[x+1])
				continue;
			rab[color[x]][lower_bound(rab[color[x]].begin(),rab[color[x]].end(),x)-rab[color[x]].begin()]++;
			rab[color[x+1]][lower_bound(rab[color[x+1]].begin(),rab[color[x+1]].end(),x+1)-rab[color[x+1]].begin()]--;
			swap(color[x],color[x+1]);
		}
	}
	return 0;
}
```


---

## 作者：mengdai (赞：0)

这题可以说是非常有意思了，一看第一个操作是区间求权值出现次数，很自然的想到了主席树，然后发现第二次操作（交换两个数）每次只会影响一个前缀的值，然后就只需要一个主席树单点修改了，然后自己YY了一个主席树单点修改（类似于一开始建树，每一次修改一个点的值就新建logn个节点，然后从原来的点继承）时间复杂度O(nlogn)，然后空间复杂度每一次 2操作就加logn个节点。

然后写完交了几发发现被卡常了数组还开小了

审核的管理员说我不够详细，现在够详细了吧！！

noip rp++


----------------------------------------------------------------------分割线----------------------------------------------------------------------


```cpp
#include<iostream>
#include<algorithm>
#include<math.h>
#include<string.h>
#include<fstream>
using namespace std;
//ifstream fin("color2.in");
//ofstream fout("color2.out");
inline int read(){
    int X=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int n,m,tot;
int rt[20000000],ls[20000000],rs[20000000],sum[20000000];
int rk[500003];
void update(int x,int &y,int l,int r,int val,int xx){
    y=++tot;
    ls[y]=ls[x],rs[y]=rs[x];
    sum[y]=sum[x]+xx;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(val<=mid)update(ls[x],ls[y],l,mid,val,xx);
    else update(rs[x],rs[y],mid+1,r,val,xx);
}
int query(int x,int y,int l,int r,int val){
    if(l==r) return sum[y]-sum[x];
    int mid=(l+r)>>1;
    if(val<=mid) return query(ls[x],ls[y],l,mid,val);
    else return query(rs[x],rs[y],mid+1,r,val);
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++){
        update(rt[i-1],rt[i],1,300000,rk[i]=read(),1);
    }
    int opt,l,r,k;
    for(int i=1;i<=m;i++){
        if(read()==1){
            l=read(),r=read(),k=read();
            write(query(rt[l-1],rt[r],1,300000,k));
            puts("");
        }else{
            k=read();
            update(rt[k],rt[k],1,300000,rk[k],-1);
            update(rt[k],rt[k],1,300000,rk[k+1],1);
            swap(rk[k],rk[k+1]);
        }
    }
    return 0;
}
```
/\*

in: 6 5 1 2 3 2 3 3


1 1 3 2


1 4 6 3


2 3 1 1 3 2


1 4 6 3


out: 1 2 2 3


\*/

---

## 作者：kevintek (赞：0)

STL大法好

开始手写二分查找RE一个点，换STL就过了...

首先将每种颜色的兔子的下标存到各种颜色的数组中

数组中下标一定是单调递增的，所以可以二分查找下标所在位置

交换只有x和x + 1交换，易证交换完后各数组中下标仍然单调

存储用vector存，不然会爆

举个栗子（如样例）：

b[1] = {1}                //第一个颜色的下标（们）

b[2] = {2, 4}            //第二个颜色的下标们

b[3] = {3, 5, 6}        //第三个颜色的下标们

第一组询问：1 1 3 2

二分找到b[2]中第一个大于等于区间左端点(1)的下标在数组中的位置 ： 1

二分找到b[2]中第一个小于等于区间右端点(3)的下标在数组中的位置 ： 1

所以在区间[1, 1]中所有值都符合， 个数即为区间长度：1 - 1 + 1 = 1

...
第三组：2 3

设第i只兔子颜色为a[i]

找到3在b[a[3]]中的位置：1

找到4在b[a[4]]中的位置：2

swap(b[a[3]][1], b[a[4]][2]);

swap(a[3], a[4])

...
就好啦

附代码：


```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int maxn = 300000 + 10;
int a[maxn], c[maxn];
vector<int> b[maxn];
int rd()            //快读; 
{
    int num = 0;
    char cc;
    do
    {
        cc = getchar();
    }while(cc > '9' || cc < '0');
    while(cc <= '9' && cc >= '0')
    {
        num *= 10;
        num += cc - '0';
        cc = getchar();
    }
    return num;
}
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++)
    {
        b[i].push_back(0);            //二分查找下界; 
    }
    for(int i = 1; i <= n; i ++)
    {
        a[i] = rd();
        c[a[i]] ++;
        b[a[i]].push_back(i);        //保存每一种颜色的兔子对应的下标们; 
    }
    for(int i = 1; i <= n; i ++)
    {
        c[i] ++;
        b[i].push_back(n + 1);        //二分查找上界; 
    }
    for(int i = 1, cz, l, r, tmp1, tmp2, tmp3, tmp4, clr; i <= m; i ++)
    {
        cz = rd();
        if(cz == 1)
        {
            l = rd(), r = rd(), clr = rd();
            tmp1 = lower_bound(b[clr].begin(), b[clr].end(), l) - b[clr].begin();
                //找到第一个大于等于区间左端点的下标在数组中的位置
                //(即在区间内颜色为clr的下标最小的兔子); 
            tmp2 = upper_bound(b[clr].begin(), b[clr].end(), r) - b[clr].begin() - 1;
                //找到第一个小于等于区间右端点的下标在数组中的位置 
                //(即在区间内颜色为clr的下标最大的兔子); 
            printf("%d\n", tmp2 - tmp1 + 1);    //显然; 
        }
        else
        {
            cz = rd();    //懒的定义新变量了...即题中所给x; 
            tmp1 = a[cz];
            tmp2 = a[cz + 1];
            if(tmp1 == tmp2) continue;
            tmp3 = lower_bound(b[tmp1].begin(), b[tmp1].end(), cz) - b[tmp1].begin();
                //找到第一个大于等于x的下标在数组中的位置,因为数组中一定有x,
                //所以tmp3即为x所在位置;
            tmp4 = lower_bound(b[tmp2].begin(), b[tmp2].end(), cz + 1) - b[tmp2].begin();    
                //tmp4为x所在位置(同上);
            swap(b[tmp1][tmp3], b[tmp2][tmp4]);        //交换位置; 
            swap(a[cz], a[cz + 1]);
        }
    }
    return 0;
}
```

---

## 作者：Drug__Lover (赞：0)

**二分上下界**

**相减就是个数**



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<cstdlib>
#define maxn 500003
using namespace std;
int n,m;
vector<int>G[maxn];
int a[maxn];
int query(int l,int r,int z)
{
    int t1=lower_bound(G[z].begin(),G[z].end(),l)-G[z].begin();  //二分找到当前颜色<=l的最右的位置 
    int t2=upper_bound(G[z].begin(),G[z].end(),r)-G[z].begin();  //二分找到当前颜色>r的最左的位置 （由于是指针，所以减G[z].begin()返回下标） 
    return t2-t1;   //下标相减就是个数 
}
int change(int x)
{
    int t1=lower_bound(G[a[x]].begin(),G[a[x]].end(),x)-G[a[x]].begin();  //找到当前颜色的下标 
    int t2=lower_bound(G[a[x+1]].begin(),G[a[x+1]].end(),x+1)-G[a[x+1]].begin();  //找到相邻颜色的下标 
    G[a[x]][t1]++; //交换下标 
    G[a[x+1]][t2]--;
    swap(a[x],a[x+1]);//交换颜色 
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),G[a[i]].push_back(i);
    for(int i=1;i<=m;i++)
    {
        int k;
        scanf("%d",&k);
        if(k==1)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            int k=query(x,y,z);
            printf("%d\n",k);
        }
        if(k==2)
        {
            int z;
            scanf("%d",&z); 
            if(a[z]!=a[z+1]) change(z);  //颜色相同交换和不交换一样，所以就不交换了 
        }
    }
    return 0;
}
```

---

## 作者：八重樱 (赞：0)

/\*
好难受...比赛时把putchar(10);打成putchar(32);

我WA得一声就哭了出来

这道题还是很水的

用vector加二分查找暴力存取就好

不要用线段树

不然你得开三十万棵线段树

\*/
```cpp
#include<iomanip>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<algorithm>
#include<bitset>
#include<vector>
using namespace std;
inline int intin(){register char c=getchar();while(c<48||c>57)c=getchar();register int a=0;while(c>47&&c<58){a=(a<<1)+(a<<3)+c-48;c=getchar();}return a;}
inline void intot(int a){if(a<0){putchar(45);a*=(-1);}if(a>9)intot(a/10);putchar(a%10+48);}
inline void cmm(int &a,int &b){a^=b;b^=a;a^=b;}//交换 
vector <int> rbq[321000];//rbq[i]记录的是i的各位置 
int gc[321000];//原数组 
int main()
{
//    freopen("cpp.in","r",stdin);freopen("cpp.out","w",stdout);
    int n=intin(),q=intin();
    for(int i=1;i<=n;i++)
    {
        gc[i]=intin();
        rbq[gc[i]].push_back(i);
    }
    while(q--)
    {
        if(intin()&1)//查询操作 
        {
            int l=intin(),r=intin(),wyf=intin();
            int a=0,b=rbq[wyf].size();
            int d=b;
            while(b-a)//二分查找L 
            {
                int mmp=(b+a)/2;
                if(rbq[wyf][mmp]>=l)
                {
                    b=mmp;
                }
                else
                {
                    a=mmp+1;
                }
            }
            int c=a;
            while(d-c)//二分查找R 
            {
                int mmp=(c+d)/2;
                if(rbq[wyf][mmp]<=r)
                {
                    c=mmp+1;
                }
                else
                {
                    d=mmp;
                }
            }
            intot(c-a);putchar(10);//LR下标差即为该区间内出现次数 
        }
        else
        {
            int wyf=intin();
            int a=0,d=gc[wyf];
            int b=rbq[d].size();
            while(b-a)//二分查找需修改的数 
            {
                int mmp=(b+a)/2;
                if(rbq[d][mmp]>=wyf)
                {
                    b=mmp;
                }
                else
                {
                    a=mmp+1;
                }
            }
            rbq[d][a]++;
            a=0;
            wyf++;
            d=gc[wyf];
            b=rbq[d].size();
            while(b-a)//二分查找需修改的数 
            {
                int mmp=(b+a)/2;
                if(rbq[d][mmp]>=wyf)
                {
                    b=mmp;
                }
                else
                {
                    a=mmp+1;
                }
            }
            rbq[d][a]--;
            cmm(gc[wyf],gc[wyf-1]);//最后别忘了在原数组交换两数 
        }
    }
    return 0;
}
```

---

## 作者：bymlg001 (赞：0)

##本以为这道题会是颗树~~主席树~~


#然而仔细一想是离散化+二分


我的思路是先把颜色弄到一块但原本的顺序还要留着，查询的时候就二分左右区间，再下标加加减减得到这个范围内的个数。修改的话将下标为x的变为x+1，x+1的变为x就行了，二分优化一下就ok了。

ps：千万别忘记换颜色！！虽然只修改一次的话没啥影响，但要是修改多次还有交集就GG了。

~~（一开始想多了用的二分+前缀和，修改的时候用的二分+前缀和+查分）~~


###
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300001;
int read(){//读入优化  无脑写的 
    int res=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) res=res*10+ch-'0',ch=getchar();
    return res;
}
int n,m,temp[N];//temp是存最一开始的顺序 
struct node{
    int c,id;
}a[N]; //存的是这个点的颜色和编号 为离散化做准备 
struct node2{//其实用上面那个就行 为了写题解好理解些我就分开了 
    int l,r;
}b[N];//存的是每个颜色的最左和最右的点在的a数字中的位置 
bool cmp(node x,node y){
    if(x.c==y.c) return x.id<y.id;
    else return x.c<y.c;
```
}//用在排序和STL的二分里
```cpp
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){ //a存的是 
        a[i].c=read();
        temp[i]=a[i].c;
        a[i].id=i;
    }
    sort(a+1,a+1+n,cmp); //离散化 与楼下vector同理 把颜色分出来 
    b[a[1].c].l=1;            //初始b数组 
    for(int i=2;i<=n;i++){
        if(a[i].c!=a[i-1].c){
            b[a[i-1].c].r=i-1;
            b[a[i].c].l=i;
        }
    }
    b[a[n].c].r=n;
    int t1,t2,t3,t4;
    while(m--){
        t1=read();
        if(t1==1){ //查询就是在该颜色中二分左右区间 
            t2=read();t3=read();t4=read();
            int ll=b[t4].l,rr=b[t4].r;//选取需要二分的区间 
            int kl=lower_bound(a+ll,a+1+rr,node{t4,t2},cmp)-a; //找到第一个大于等于的 
            int kr=upper_bound(a+ll,a+1+rr,node{t4,t3},cmp)-a; //找到第一个严格大于的 
            kr--;    //再减一（试出来的 
            printf("%d\n",kr-kl+1); //输出他们下标之间的长度即为数量 
        }
        if(t1==2){//修改就是将下标为x的++ x+1的-- 
            t2=read();
            t3=temp[t2];t4=temp[t2+1];
            if(t3==t4) continue; //    特判一下这样就不用换了        
            swap(temp[t2],temp[t2+1]);  //！！！考试的时候忘换颜色了23333 
            int k1=lower_bound(a+b[t3].l,a+1+b[t3].r,node{t3,t2},cmp)-a;//寻找x的坐标 
            int kr=lower_bound(a+b[t4].l,a+1+b[t4].r,node{t4,t2+1},cmp)-a;//寻找x+1的坐标 
            a[k1].id++;a[kr].id--;//坐标更改 
        }
    }
    return 0; 
}

```

---

## 作者：piggy (赞：0)

\* 维护一个 b 数组，里面存着每个点的颜色（b[].c）和位置(b[].id)，然后排好序，

\* 修改的话找到 X 和 X+1 再 b 中的位置，只需交换它俩的 id 即可（因为肯定不会影响到相同颜色间的相对先后顺序）。

\* 查询的话找到颜色 C 在 b 中的那段连续区间，再二分 L,R 能在其中包含多少即可。

\* 有些小细节可以看看注释。

```cpp
#include <cstdio>
#include <algorithm>
#define N 400005
using namespace std;
struct zzk{int c,id;} b[N];
bool cmp(zzk x,zzk y){        //把相同颜色的堆在一起（颜色也递增），然后相同颜色的一堆中编号递增以便二分 
    if (x.c==y.c) return x.id<y.id;
    return x.c<y.c;
}
int n,m,a[N];

int ef_c(int c){    //二分 为颜色 c 最后一个位置 
    if (!c) return 0;
    int l,r,mid,ret=0;
    for (l=1,r=n; l<=r; ){
        mid=l+r>>1;
        if (b[mid].c<=c && b[mid-1].c<=c){ret=mid,l=mid+1; continue;}
        r=mid-1;
    }
    return ret;
}

int ef_I(int l,int r,int I){    //id I 在区间 [l,r] 在哪里(左偏) 
    int mid,ret=l;
    for (; l<=r; ){
        mid=l+r>>1;
        if (b[mid].id<=I){ret=mid,l=mid+1; continue;}
        r=mid-1;
    }
    return ret;
}

void option_1(int L,int R,int C){    //询问 [L,R] 中的 C 
    int lc,rc,st,ed;
    lc=ef_c(C-1)+1,rc=ef_c(C);        //颜色C在 b 中的区间 
    st=ef_I(lc,rc,L),ed=ef_I(lc,rc,R);    //找到 L,R 在区间包了哪些数 
    if (b[st].id>=L && b[st].id<=R && b[st].c==C) st--;        //处理一下细节 
    printf("%d\n",ed-st);
}

void option_2(int X){    //修改 X 
    int C1=a[X],C2=a[X+1],lc,rc,kk1,kk2;
    lc=ef_c(C1-1)+1,rc=ef_c(C1),kk1=ef_I(lc,rc,X);        //找到 a[X] 在 b 中对应位置 
    lc=ef_c(C2-1)+1,rc=ef_c(C2),kk2=ef_I(lc,rc,X+1);    //找到 a[X+1] 在 b 中对应位置 
    swap(b[kk1].id,b[kk2].id);                            //位置交换 
    swap(a[X],a[X+1]);
}

int main(){
    //freopen("3.txt","r",stdin);
    //freopen("2.txt","w",stdout);
    scanf("%d%d",&n,&m);
    for (int i=1; i<=n; i++) scanf("%d",&a[i]),b[i].id=i,b[i].c=a[i];
    sort(b+1,b+n+1,cmp);
    for (int k1,k2,k3,k; m--; ){
        scanf("%d",&k);
        if (k==1 && scanf("%d%d%d",&k1,&k2,&k3)){
            option_1(k1,k2,k3);
        }
        if (k==2 && scanf("%d",&k1)){
            if (a[k1]==a[k1+1]) continue;
            option_2(k1);
        }
    }
}
```

---


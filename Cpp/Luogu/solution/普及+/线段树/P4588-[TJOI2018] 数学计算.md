# [TJOI2018] 数学计算

## 题目描述

小豆现在有一个数 $x$，初始值为 $1$。小豆有 $Q$ 次操作，操作有两种类型：

`1 m`：将 $x$ 变为 $x \times m$，并输出 $x \bmod M$

`2 pos`：将 $x$ 变为 $x$ 除以第 $pos$ 次操作所乘的数（保证第 $pos$ 次操作一定为类型 1，对于每一个类型 1 的操作至多会被除一次），并输出 $x \bmod M$。

## 说明/提示

对于 $20\%$ 的数据，$1 \le Q \le 500$。

对于 $100\%$ 的数据，$1 \le Q \le 10^5$，$t \le 5, M \le 10^9$，$0 < m \leq 10^9$。

## 样例 #1

### 输入

```
1
10 1000000000
1 2
2 1
1 2
1 10
2 3
2 4
1 6
1 7
1 12
2 7```

### 输出

```
2
1
2
20
10
1
6
42
504
84```

# 题解

## 作者：UnyieldingTrilobite (赞：177)

看各位dalao代码都好长啊（无喷人之意）······

这题其实代码珂以肥肠肥肠短。

juruo来提供一下，给不想在这题上花费过多时间的dalao一种新写法。

~~诶好像是不是你谷只有我是快省选了线段树板子还是不会背所以需要一个短代码。~~

首先思路：

思路一：膜你+高精。

算了下，空间······

python也不行，人生苦短py溢出。

思路二：稍好的膜你。

就是一路取膜，除法转逆元。

但这题毒瘤膜数不是质数啊喂~

而且还要特判被整除的情况。

~~其实也许珂以中剩一波（~~

不管了。

思路三：更好的膜你。

想想，每次改一个数就要重算。

而其他都是我们之前计算过的，只有一项不一样。

每次重算，**值得吗？**

怎么避免？

再想想，每次的数后面计算需要肯定要存下来。

相当于一个序列。

要支持什么？

想想······

更改一个数，查询总乘积？

抽象一点······

**点更新，段查询！！！**

（是不是异常熟悉？）

**BIT/线段树**。

这题BIT不太行，因为有除法。

**所以正解出来了：线段树。**

不想打超长代码怎么办？

**非递归！**

有个好东西zkw树正好可用~

于是这题······终于没了。

最后贴代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int d[4000009];
int n,M,T,mod,p;
signed main(){
	for(scanf("%lld",&T);T;--T){
		scanf("%lld%lld",&n,&mod);
		for(M=1;M<=n;M<<=1);
		fill(d+1,d+M+n+2,1);//注意！！！一定要多fill一个，否则QAQ行可能有问题。
		for(int i=1,a=0,b=0;i<=n;++i){
			scanf("%lld%lld",&a,&b);
			a==1?d[p=i+M]=b%mod:d[p=b+M]=1;
			while(p>>=1)d[p]=d[p<<1]*d[p<<1|1]%mod;//QAQ
			printf("%lld\n",d[1]);
		}
	}
	return 0;
}
```
祝大家切题愉快！

---

## 作者：Liu_zj (赞：155)

我第一次看这道题，没看出来线段树（没区间没修改没线段……）

直到看了题解：

题目有两个操作，一个是乘一个值，另一个是除之前乘的某个值。转化一下，操作的目的为：改变一个值，查找之前的值。

可以将数据按时间排序，建线段树，维护区间乘。这样的话根节点就是到现在为止的所有数的乘积。

那么第一个操作就是将当前时间的值设为m。

第二个操作是去除某次乘的值，根据乘除逆运算的关系，除一个值就是将那个值置1，可以说是穿越到了从前，防止了乘法运算。

那么第二个操作就是将pos时的值置为1。

明确了操作，还有一些细节。
多组数据，所以线段树不要忘记初始化。
乘法运算，线段树初值设为1。
不要忘记mod运算。

代码（码风清奇）：
```
#include<bits/stdc++.h>
using namespace std;
long long sum[10000001];
long long mod;
void update(int now)
{
	sum[now]=(sum[now<<1]*sum[now<<1|1])%mod;//时刻mod
}
void build(int now,int l,int r)
{
	if(l==r)
	{
		sum[now]=1;//建树置1
		return ;
	}
	int mid=(l+r)>>1;
	build(now<<1,l,mid);
	build(now<<1|1,mid+1,r);
	update(now);
}
void change(int now,int l,int r,int lgo,int rgo,int nm)//套的区间修改模板
{
	if(l>=lgo&&r<=rgo)
	{
		sum[now]=nm;
		return ;
	}
	int mid=(l+r)>>1;
	if(lgo<=mid)
	change(now<<1,l,mid,lgo,rgo,nm);
	if(rgo>mid)
	change(now<<1|1,mid+1,r,lgo,rgo,nm);
	update(now);
}
int main()
{
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		int q,op,m;
		cin>>q>>mod;
		build(1,1,q);
		for(int i=1;i<=q;i++)
		{
			cin>>op>>m;
			if(op==1)
			{
				change(1,1,q,i,i,m);//可以将i离散化
				sum[1]%=mod;
			}
			else
			change(1,1,q,m,m,1);
			
			cout<<sum[1]%mod<<endl;//输出树根
		}
	}
    //return 0好习惯
}
```
这里顺便整理了线段树比较简单的“板子”题

线段树题目：

[统计和：简化版的模板1](https://www.luogu.org/problemnew/show/P2068)

[忠诚：模板1难度经典题](https://www.luogu.org/problemnew/show/P1816)

[XOR的艺术：模板1的变种](https://www.luogu.org/problemnew/show/P2574)

[最大数：模板1的变种](https://www.luogu.org/problemnew/show/P1198)

[光开关：XOR艺术的双倍经验](https://www.luogu.org/problemnew/show/P2846)

[开关：XOR艺术的三倍经验](https://www.luogu.org/problemnew/show/P3870)

[维护序列：模板2的双倍经验](https://www.luogu.org/problemnew/show/P2023)

[方差：线段树+数学，模板1变种](https://www.luogu.org/problemnew/show/P1471)

[数学计算：模板1简化，思维](https://www.luogu.org/problemnew/show/P4588)

[Glass Carving：模板1困难](https://www.luogu.org/problemnew/show/CF527C)

[酒店hotel：Glass的困难版](https://www.luogu.org/problemnew/show/P2894)


---

## 作者：流逝丶 (赞：49)

说实话第一眼没看出来这是个线段树题

仔细一想就算是你把每次操作计算出来，每次除去找数，然后除掉，那样就只能最

后取mod，或求很多逆元，不取模你会炸$longlong$。

如何解决？

我们以时间为轴，建立线段树，叶子结点维护该操作时间的乘数，非叶子结点维护

区间乘，叶子结点一开始都为$1$

然后每次乘，进行单点修改，将该次操作时间的位置修改为该乘数，最后输出$tr[1]$.

每次除的话，就将询问的操作位置的乘数改为$1$。最后输出$tr[1]$

然后这题就做完了

```cpp
#include<iostream>
#include<cstdio>
#define LL long long
#define lson k<<1,l,mid
#define rson k<<1|1,mid+1,r
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
using namespace std;
const int maxn=100005;
LL tr[maxn<<2];
int mod,t,q;
inline void update(int k){
	tr[k]=(tr[ls]*tr[rs])%mod;
}
void build(int k,int l,int r){
	tr[k]=1;
	if(l==r)
		return ;
	build(lson);build(rson);
}
void change(int k,int l,int r,int x,int val){
	if(l==r){
		tr[k]=(val==0)?1:val;
		return ;
	}
	if(x<=mid)change(lson,x,val);
	else change(rson,x,val);
	update(k);
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&q,&mod);
		build(1,1,q);
		int opt,x;
		for(int i=1;i<=q;++i){
			scanf("%d%d",&opt,&x);
			if(opt==1)change(1,1,q,i,x),printf("%lld\n",tr[1]%mod);
			else change(1,1,q,x,0),printf("%lld\n",tr[1]%mod);
		}
	}
	return 0;
}
```


---

## 作者：jins3599 (赞：17)

刚开始还以为是一道逆元的题...

后来发现好像没有必要。

突然想到之前做过一道题，需要建空树，然后操作时向后插入的操作。

然后这道题成了一道水题.

我们对于每个一操作，直接向后插入一个数即可。

对于二操作，把单点的值改为一即可。

然后线段树只需要维护一个单点修改，最后的答案就是根节点的值。

时间复杂度$O(TQlogQ)$，还算是蛮快的。

$Code:$
```cpp
#include <bits/stdc++.h>
#define ls(x) x << 1
#define rs(x) x << 1 | 1

using namespace std;

const int N = 100000 + 10;

typedef long long ll;
ll mod;

struct Seg {
	int dis , l , r;
}t[N << 2];

void pushup(int x) {
	t[x].dis = ((t[ls(x)].dis % mod) * (t[rs(x)].dis % mod)) % mod;
}

void built(int x ,int l, int r) {
	t[x].l = l , t[x].r = r;
	if(l == r) {
		t[x].dis = 1;
		return;
	}
	int mid = (l + r) >> 1;
	built(ls(x) , l , mid);
	built(rs(x) , mid + 1 , r);
	pushup(x);
}

void updata(int x , int p , int w) {
	if(t[x].l == t[x].r) {
		t[x].dis = w; t[x].dis %= mod; return;
	}
	int mid = (t[x].l + t[x].r) >> 1;
	if(p <= mid) updata(ls(x) , p , w);
	else updata(rs(x) , p , w);
	pushup(x);
}

int main () {
	ll T;
	scanf("%lld" , &T);
	while(T --) {
		int n , cnt = 0;
		scanf("%d%lld" , &n , &mod);
		built(1 , 1 , n);		
		for(int i = 1 ; i <= n ; ++ i) {
			int opt; ll m;
			scanf("%d%lld" , &opt , &m);
			if(opt == 1) {
				cnt ++;
				updata(1 , cnt , m);
				printf("%lld\n" , t[1].dis % mod);
			} else {
				cnt ++;
				updata(1 , cnt , 1);
				updata(1 , m , 1);
				printf("%lld\n" , t[1].dis % mod);
			}
		}
	}
	return 0;
}
```

---

## 作者：HPXXZYY (赞：16)

## $$\color{green}{\text{思维题——洛谷P4588\ \ \ \ \ [TJOI2018]数学计算}}$$
$\color{blue}{\text{【题目】：}}$ 你有一个数 $x$，初始为 $1$。你有两种操作，分别为：

- 1. 给定一个数 $m$，把 $x$ 变成 $x \times m$，然后输出 $x$ 对 $\text{mod}$ 取模的值。
- 2. 给定一个数 $t$，把 $x$ 变为 $x/$ 第 $t$ 次操作所乘的数。如第 $t$ 次操作所乘数为 $2$，则把 $x$ 变为 $\dfrac{x}{2}$。数据保证第 $t$ 次操作一定是操作 $1$，且每个操作最多被除一次，即保证 $x$ 在任何时候都是一个整数。操作后，输出 $x$ 对 $\text{mod}$ 取模的值。

$\color{blue}{\text{【思路】：}}$ 直接模拟会因为爆 `long long` 的问题导致代码非常复杂，甚至无法编写。

考虑强大的数据结构——线段树。建立一棵线段树，其叶子节点都是对于的乘数，每个非叶子节点的值为其左右儿子的值的乘积对 $\text{mod}$ 取模的值。这样，任意时候都有 $x=$ 该线段树的根的值。

操作 $1$ 可以直接上，操作 $2$ 可以看做是把第 $t$ 次的乘数改为 $1$。因此，我们只需要打一个线段树修改即可。

$\color{blue}{\text{【代码】：}}$

```cpp
const int N=1e5+100;
#define ll long long
ll mod;int tot,G[N];
int test_number,q;
struct Segment_tree{
	ll sum[N<<2];//记得4倍空间 
	inline void pushup(int o){
		sum[o]=sum[o<<1]*sum[o<<1|1]%mod;
	}
	inline void build(int o,int l,int r){
		if (l==r){sum[o]=1ll;return;}
		register int mid=(l+r)>>1;
		build(o<<1|1,mid+1,r);
		build(o<<1,l,mid);
		pushup(o);return;
	}
	void updata(int o,int l,int r,int p,ll v){
		if (l==r){sum[o]=v;return;}
		register int mid=(l+r)>>1;
		if (p<=mid) updata(o<<1,l,mid,p,v);
		else updata(o<<1|1,mid+1,r,p,v);
		pushup(o);return;
	}
}SGT;
#define gc getchar()
#define g(c) isdigit(c)
inline ll read(){
	char c=0;ll x=0;bool f=0;
	while (!g(c)) f=c=='-',c=gc;
	while (g(c)) x=x*10+c-48,c=gc;
	return f?-x:x;
}
namespace fast_write{
	void write(ll a,bool b){
		if (a==0){
			if (b) putchar('0');
		}
		else{
			write(a/10,false);
			putchar(a%10+'0');
		}
	}
	void print(ll a,char c){
		write(a,true);
		putchar(c);
	}
}
int main(){
	test_number=read();
	while (test_number--){
		q=read();mod=read();
		SGT.build(1,1,q);tot=0;
		memset(G,0,sizeof(G));
		for(int i=1;i<=q;i++){
			int opt=read();ll t=read();
			if (opt==2) SGT.updata(1,1,q,G[t],1);
			else SGT.updata(1,1,q,G[i]=(++tot),t%mod);
			fast_write::print(SGT.sum[1]%mod,'\n');
		}
	}
	return 0;
}
```

祝笔者和大家都可以 `AK IOI`！

---

## 作者：huyufeifei (赞：9)

看了一下，目前所有的题解都是线段树维护前缀积的做法。  
我来提供一种新的思路：
## 离线 + 线段树
对于时间建立线段树，每个叶子节点维护的是该时间的答案。  
每个乘的数都对一段时间的答案有影响，所以我们写一个支持区间乘的线段树即可。  
最后把线段树扫一遍，输出答案。  
注意每次要把线段树初始化为1。  
~~为什么我的思路总是跟别人不一样.......~~

代码：
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;
const int N = 100010;

LL MO;
int tag[N << 2], a[N], b[N], c[N];

inline void pushdown(int o) {
    if(tag[o] != 1) { // error : tag[o] > 1
        tag[o << 1] = 1ll * tag[o << 1] * tag[o] % MO;
        tag[o << 1 | 1] = 1ll * tag[o << 1 | 1] * tag[o] % MO;
        tag[o] = 1;
    }
    return;
}

void mul(int L, int R, int v, int l, int r, int o) {
    if(L <= l && r <= R) {
        tag[o] = 1ll * tag[o] * v % MO;
        return;
    }
    pushdown(o);
    int mid = (l + r) >> 1;
    if(L <= mid) {
        mul(L, R, v, l, mid, o << 1);
    }
    if(mid < R) {
        mul(L, R, v, mid + 1, r, o << 1 | 1);
    }
    return;
}

void out(int l, int r, int o) {
    if(l == r) {
        printf("%d\n", tag[o]);
        return;
    }
    pushdown(o);
    int mid = (l + r) >> 1;
    out(l, mid, o << 1);
    out(mid + 1, r, o << 1 | 1);
    return;
}

inline void solve() {
    int n;
    scanf("%d%lld", &n, &MO);
    int f, x;
    for(int i = 1; i <= n; i++) {
        scanf("%d%d", &f, &x);
        if(f == 1) {
            a[i] = i;
            b[i] = n;
            c[i] = x;
        }
        else {
            b[x] = i - 1;
        }
    }
    for(int i = 1; i <= n; i++) {
        if(a[i]) {
            mul(a[i], b[i], c[i], 1, n, 1);
        }
    }
    out(1, n, 1);
    return;
}

int main() {
    int T;
    scanf("%d", &T);
    while(T--) {
        for(int i = 1; i < N * 4; i++) { // error : i < N
            tag[i] = 1;
        }
        solve();
        if(T) {
            memset(a, 0, sizeof(a));
        }
    }
    return 0;
}

```

---

## 作者：nekko (赞：5)

~~为什么TJOI考板子题啊~~

由于每个pos最多删一次，也就是说相当于维护一个前缀积的东西

直接对于询问序列建立线段树，op=1的位置就是x，op=2的位置就是1

那么对于修改，就是将某个位置变为1 ~~这不就是线段树板子么~~

``` cpp
// luogu-judger-enable-o2
#include "bits/stdc++.h"
using namespace std;
const int N = 1e5 + 10;
typedef long long ll;

ll mul[N * 4];

#define lc (id << 1)
#define rc (id << 1 | 1)

struct Q {
    int op; ll x;
} q[N];

int n, mod;

void build(int id, int l, int r) {
    int mid = (l + r) >> 1;
    if(l == r) {
        mul[id] = q[l].op == 1 ? q[l].x % mod : 1;
    } else {
        build(lc, l, mid), build(rc, mid + 1, r);
        mul[id] = mul[lc] * mul[rc] % mod;
    }
}

ll query(int id, int l, int r, int ql, int qr) {
    int mid = (l + r) >> 1;
    if(ql <= l && r <= qr) return mul[id];
    else if(qr <= mid) return query(lc, l, mid, ql, qr);
    else if(ql >= mid + 1) return query(rc, mid + 1, r, ql, qr);
    else return query(lc, l, mid, ql, mid) * query(rc, mid + 1, r, mid + 1, qr) % mod;
}

void modify(int id, int l, int r, int pos) {
    int mid = (l + r) >> 1;
    if(l == r) return mul[id] = 1, void();
    else if(pos <= mid) modify(lc, l, mid, pos);
    else modify(rc, mid + 1, r, pos);
    mul[id] = mul[lc] * mul[rc] % mod;
}

void sol() {
    scanf("%d%d", &n, &mod);
    for(int i = 1 ; i <= n ; ++ i) {
        scanf("%d%lld", &q[i].op, &q[i].x);
    }
    build(1, 1, n);
    for(int i = 1 ; i <= n ; ++ i) {
        if(q[i].op == 1) {
            printf("%lld\n", query(1, 1, n, 1, i));
        } else {
            modify(1, 1, n, q[i].x);
            printf("%lld\n", query(1, 1, n, 1, i));
        }
    }
}

int main() {
    int T; scanf("%d", &T);
    while(T --) sol();
}
```

---

## 作者：Tsukimaru (赞：4)

提个比较 Trival 的解法。

把 $m$ 分解为两个整数 $a, b$ 的乘积，其中 $\gcd(b, M) = 1$。

对于 $a$，可见 $a$ 的质因子都是 $M$ 的质因子，直接开个数组 `c[i]` 对 $M$ 的每个质因子维护其次数即可。

对于 $b$，可见 $\gcd(b, M) = 1$，此时存在逆元 $b^{-1} \equiv b^{\varphi(M) - 1} \pmod M$，因而可以直接用一个变量 `res` 储存这一部分的乘积。

每次询问时再统计 `c[i]` 的贡献即可。在这里可以提前预处理出 $M$ 的所有质因子 $p$ 的次幂 $p^0, p^1, \ldots, p^Q$。

优点：
* 不需要使用线段树
* 可以任意乘除

缺点：
* 需要对 $M$ 进行质因数分解

时间复杂度：$O(\sqrt M + T(\frac {\sqrt M}{\log M} + Q \cdot (\omega(M) + \log \varphi(M)))$，其中 $\omega(M)$ 表示 $M$ 的质因子个数。

特别地，如果 $M$ 很小，就可以预处理出 $1 \ldots M - 1$ 的所有逆元，省去快速幂的一个 $\log$。此时复杂度为 $O(T(M + Q \cdot \omega(M))$（线性求逆元）或 $O(M \sqrt M + T(\sqrt M + Q \cdot \omega(M))$（分块快速幂）。

## 代码
代码给出的实现比较简单，是一个 $O(T(\sqrt M + Q \cdot \omega(M) \cdot \log \varphi(M))$ 的实现。

优化细节留作读者思考。

```cpp
#include <cstdio>
#include <cstring>

typedef long long int64;

const int MAXN = 100000 + 10;

int MOD;
int n, phi;
int a[MAXN];
int p[25], c[25], pn;
int prod;

inline int qpow(int64 b, int p, int mod) {
    int res = 1;

    while (p) {
        if (p & 1)
            res = res * b % mod;
        b = b * b % mod;
        p >>= 1;
    }
    return res;
}

void init() { // 这里可以通过预处理 sqrt(m) 以内的质数降低复杂度。
    int i, x;

    phi = x = MOD;
    for(i = 2; i * i <= x; i++) {
        if(!(x % i)) {
            pn++;
            p[pn] = i;
            phi = phi / i * (i - 1);
            while(!(x % i))
                x /= i; 
        }
    }
    if(x > 1) {
        pn++;
        p[pn] = x;
        phi = phi / x * (x - 1);
    }
}
void add(int x, int k) {
    int i;

    for(i=1; i<=pn; i++) { // 此处分解 x 的质因数。
        while(!(x % p[i])) {
            c[i] += k;
            x /= p[i];
        }
    } // 剩下的就是与 M 互质的部分了。
    if(k == 1)
        prod = 1ll * prod * x % MOD;
    else
        prod = 1ll * prod * qpow(x, phi - 1, MOD) % MOD;
}
int query() {
    int i;
    int64 x = prod;
    
    for(i=1; i<=pn; i++) // 这里可以通过预处理幂次降低复杂度。
        x = x * qpow(p[i], c[i], MOD) % MOD;
    return x;
}

int main() {
    int i, T, opt, x;

    scanf("%d", &T);
    while(T) {
        T--;
        pn = 0;
        memset(c, 0, sizeof(c));
        prod = 1;

        scanf("%d %d", &n, &MOD);
        
        init();
        for(i=1; i<=n; i++) {
            scanf("%d %d", &opt, &x);
            if(opt == 1) {
                a[i] = x;
                add(x, 1);
            }
            else
                add(a[x], -1);
      		printf("%d\n", query());
        }
    }
    return 0;
}
```

---

## 作者：mol茶蛋糕 (赞：3)

这个题这可谓是有毒啊。  

这真的不好想出来是一道线段树的题啊...~~(至少我最开始没想出来，我菜爆了)~~  

Q次操作可以当成长度为Q的线段。每次有1，就把线段对应位置加上val,否则就把对应位置减val。然后维护整个区间的数的乘积就ok了  

线段树维护即可。  

**注意：**  

**1**. 线段树的sum数组最开始要初始化为1，否则一些没有改的点一乘上，就把整个值变成0了。  

**2**. 还有就是op=2的时候，名义上是把sum-val，实际上可不能-val，应当把sum置成1，否则就会有和**1**一样的问题。  

**3**. TA说输出的时候%mod输出可不要憨憨地只在query里面%，update里面也要%啊，不然爆long long....~~(或许真的只有我才这么铁憨憨)~~  


很菜的窝两天打了四次才过...  
![](https://s2.ax1x.com/2019/10/27/KyRcEF.png)  

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define int long long
int q,mod;
int pos[N],val[N];
int sum[N<<2],laz[N<<2];
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
void pushup(int rt)
{
	sum[rt]=(sum[rt<<1]*sum[rt<<1|1])%mod;
}
void update(int l,int r,int rt,int p,int add)
{
	if(l==r) 
	{
		if(pos[p]==0) sum[rt]=1;
		else sum[rt]=val[p];
		return;
	}
	int mid=(l+r)>>1;
	if(p<=mid) update(lson,p,add);
	else update(rson,p,add);
	pushup(rt);
}
int query(int l,int r,int rt,int L,int R)
{
	if(L<=l&&r<=R)
		return sum[rt]%mod;
	int mid=(l+r)>>1;
	int ans=1;
	if(L<=mid) ans=ans*query(lson,L,R)%mod;
	if(mid<R) ans=ans*query(rson,L,R)%mod;
	return ans;
}
void init()
{
	for(int i=1;i<=q*4;i++) sum[i]=1,laz[i]=0;
	for(int i=1;i<=q;i++) pos[i]=val[i]=0;
}
signed main()
{
//	freopen("1.out","w",stdout);
	int t;
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld",&q,&mod);
		init();
		for(int i=1;i<=q;i++)
		{
			int op,x;
			scanf("%lld%lld",&op,&x);
			if(op==1)
			{
				pos[i]=1,val[i]=x;
				update(1,q,1,i,x);
				printf("%lld\n",query(1,q,1,1,q));
			}
			else
			{
				pos[x]=0;
				update(1,q,1,x,-val[x]);
				printf("%lld\n",query(1,q,1,1,q));
			}
		}
	}
	return 0;
}
```

---

## 作者：le_星辰 (赞：3)

首先要知道一个关于取模的公式：
```
(a*b)%P=(a%P*b%P)%P
```
然后观察题意，始终是对于一个数进行乘除操作，那么不难发现，如果之前乘上了某一个数，那么之后无论经过多少次操作，再除以之前的这个数，那么就可以视作对其没有操作，那么不难想到可以以操作时间为线段建立线段树，记录的就是区间乘积模mod，那么就可以用上面的式子维护，对于操作1，就是把当前操作的序号位置变成m，对于操作2，就是将pos改成1，每次询问的答案就是整个序列的操作结果，即node[1]，代码如下：
```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
const int size=100010;
long long Q,mod,ans[size],tot=0,opt,m,T;//两个mod相乘会爆int，所以一定要开long long
struct node {
	long long l,r,data;
} t[size*4];
void build(int p,int l,long long r) {//线段树建树
	t[p].l=l,t[p].r=r;
	if(l==r) {
		t[p].data=1;
		return;
	}
	long long mid=(l+r)/2;
	if(l<=mid) build(p*2,l,mid);
	if(r>mid) build(p*2+1,mid+1,r);
	t[p].data=(t[p*2].data*t[p*2+1].data)%mod;//用上述公式维护之
}
void change(int p,int x,int v) {//单点修改
	int mid=(t[p].l+t[p].r)/2;
	if(t[p].l==t[p].r) {
		t[p].data=v;
		return;
	}
	if(x<=mid) change(p*2,x,v);
	else change(p*2+1,x,v);
	t[p].data=(t[p*2].data*t[p*2+1].data)%mod;
}
int main() {
	cin>>T;
	for(int i=1; i<=T; i++) {
		cin>>Q>>mod;
		tot=0;
		memset(t,0,sizeof(t));
		memset(ans,0,sizeof(ans));//每组数据都要初始化
		build(1,1,Q);
		for(int i=1; i<=Q; i++) {
			cin>>opt>>m;
			if(opt==1) {
				change(1,i,m);
				ans[++tot]=t[1].data;//每次的答案就是整个树的根节点
			} else {
				change(1,m,1);
				ans[++tot]=t[1].data;
			}
		}
		for(int i=1; i<=tot; i++) cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：温栀槿 (赞：3)

其实这道题没必要那么多操作

只用一个单点修改即可，每次赋初值为1

直接求即可，2操作相当于把原来那个位置的值改为1

~~我们开一个mp数组记录第i次操作对应第几次节点~~

~~好吧其实是我太懒就不省空间直接搞了~~

Talk is cheap , show you the code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define mid ((l+r)>>1) 
#define lson num<<1,l,mid
#define rson num<<1|1,mid+1,r

const int N=1e5+7;

ll s[N<<2],M,ans,op[N];

int vis[N],cnt,mp[N];

int t;

inline void add(int num,int l,int r,int x,int y,int k){
	if(l==x&&r==y){
		s[num]=k;
		return ;
	}
	if(x<=mid) add(lson,x,y,k);
	if(y>mid) add(rson,x,y,k);
	s[num]=s[num<<1]*s[num<<1|1]%M;
}

int main(){
	scanf("%d",&t);
	while(t--){
		memset(op,0,sizeof(op));
		memset(vis,0,sizeof(vis));
		fill(s+1,s+N*4+1,1);
		cnt=0;
		scanf("%lld%lld",&ans,&M);
		for(int i=1;i<=ans;i++){
			scanf("%d",&vis[i]);
			scanf("%lld",&op[i]);
			if(vis[i]==1) {
				op[i]%=M;
				cnt++;
				mp[i]=cnt;
				add(1,1,ans-1,cnt,cnt,op[i]);
			}
			else{
				add(1,1,ans-1,mp[op[i]],mp[op[i]],1);
			}
			printf("%lld\n",s[1]%M);
		}
		
	}
}
```


---

## 作者：psk011102 (赞：2)

由于$2$操作保证保证第$pos$次操作一定为类型$1$,对于每一个类型$1$的操作至多会被除一次

所以我们可以以时间为轴建立线段树，对于$2$操作将$pos$改成$1$即可

代码如下

```
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)
#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)
#define Set(a, v) memset(a, v, sizeof(a))
#define file(a) freopen(a".in","r",stdin),freopen(a".out","w",stdout)
using namespace std;

bool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}
bool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}

inline int read() {
 int x = 0, fh = 1; char ch = getchar();
    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;
    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');
    return x * fh;
}
long long tree[400005];
int mod;
#define mid ((l+r)>>1)
void built(int rt,int l,int r){
     if(l==r){
         tree[rt]=1;
         return ;
     }
     built(rt<<1,l,mid);
     built(rt<<1|1,mid+1,r);
     tree[rt]=tree[rt<<1]*tree[rt<<1|1]%mod;
}
void modify(int rt,int l,int r,int pos,int val){
     if(l==r){
         tree[rt]=val;
         return ;
     }
     if(pos<=mid)modify(rt<<1,l,mid,pos,val);
     else modify(rt<<1|1,mid+1,r,pos,val);
     tree[rt]=tree[rt<<1]*tree[rt<<1|1]%mod;
}
int main () {
#ifndef ONLINE_JUDGE
file("4588");
#endif
   int t=read();
   while(t--){
      int q=read();
      mod=read();
      built(1,1,q);
      F(i,1,q){
         int opt=read(),x=read();
         if(opt==1){
            modify(1,1,q,i,x);
         }
         else modify(1,1,q,x,1);
         printf("%lld\n",tree[1]);
      }
   }
    return 0;
}
```

---

## 作者：yzhang (赞：2)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10335121.html )

### [原题传送门](https://www.luogu.org/problemnew/show/P4588)

### 这题是[线段树](https://www.cnblogs.com/yzhang-rp-inf/p/10022315.html )的模板题

#### 显而易见，直接模拟是不好模拟的（取模后就不好再除了）

#### 我们按照时间来建一颗线段树

#### 线段树初始值都为1，用来维护乘积

#### 第一种操作就在当前时间所对应的节点上把乘数改成m

#### 第二种操作就是把第pos个节点的乘数该回1

#### 每次询问的答案就是线段树根节点维护的数值（pushup时要取模）

```cpp
#include <bits/stdc++.h>
#define N 100005
#define ll long long
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline ll read()
{
    register ll x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int n;
ll mod;
struct SegmentTree{
    ll mul[N<<3];
    inline void init(register int x,register int l,register int r)
    {
        mul[x]=1;
        if(l==r)
            return;
        int mid=l+r>>1;
        init(x<<1,l,mid);
        init(x<<1|1,mid+1,r);
    }
    inline void pushup(register int x)
    {
        mul[x]=mul[x<<1]*mul[x<<1|1]%mod;
    }
    inline void update(register int x,register int l,register int r,register int pos,register int v)
    {
        if(l==r)
        {
            mul[x]=v;
            return;
        }
        int mid=l+r>>1;
        if(pos<=mid)
            update(x<<1,l,mid,pos,v);
        else 
            update(x<<1|1,mid+1,r,pos,v);
        pushup(x);
    }
}tr;
int main()
{
    int T=read();
    while(T--)
    {
        n=read(),mod=read();
        tr.init(1,1,n);
        for(register int i=1;i<=n;++i)
        {
            int opt=read();
            ll x=read();
            if(opt==1)
                tr.update(1,1,n,i,x);
            else
                tr.update(1,1,n,x,1);
            write(tr.mul[1]),puts("");
        }
    }
    return 0;
 } 
```

---


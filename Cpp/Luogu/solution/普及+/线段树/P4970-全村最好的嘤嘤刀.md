# 全村最好的嘤嘤刀

## 题目背景

**重阳节**到了，我们最好的八重樱拥有全村最好的嘤嘤刀……

## 题目描述

在绯玉丸力量的影响下，八重村成了一条长度为 $n$ 的八重街，并且绯玉丸可以带着八重樱出现在街上的任意地点。而我们的八重樱则会在街上任意穿梭来获取某一地点上的嘤嘤嘤能量，用以升级她的嘤嘤刀。

**出题人：March_H**

在每个时刻，都会发生以下 $3$ 个事件：

$1$ $x$ $val$ 表示在 $x$ 地点出现了携带着 $val$ 点嘤嘤嘤能量的绯狱丸，并且绯狱丸会吞噬该点的嘤嘤嘤能量，使得该点的嘤嘤嘤能量变为 $ val - a_i$ 点，$a_i$ 为出现绯狱丸的前一刻，该点所存在的嘤嘤嘤能量。

$2$ $l$ $r$ 表示绯玉丸会带着八重樱出现在[ $l$ , $r$ ]间的任意一点。八重樱为了尽快升级她的嘤嘤刀，会获取该区间上最大的嘤嘤嘤能量。特殊的，为了保卫八重村，当 $l$ , $r$ 之间存在绯狱丸时，八重樱会优先用她的嘤嘤刀对付绯狱丸，并获得绯狱丸此时拥有的 $a_i$ 点嘤嘤嘤能量。

$3$ $l$ $r$ $val$ 绯玉丸会嘤嘤嘤，使得[ $l$ , $r$ ]上的每一个地点的嘤嘤嘤能量增加 $val$ 点(包括绯狱丸)。

## 说明/提示

对于所有的数据：

最终答案都会在 $[0,2^{31}-1]$ 范围内；

$n$ , $m$ $\leqslant$ $100000$。

值得注意的是，无论八重樱是获取了某一地点的嘤嘤嘤能量还是击败了某一地点的绯狱丸，该地点的嘤嘤嘤值都应当清零而不是保留原来的数值。

对于事件 $2$ ，题目保证每个事件中最多出现 $1$ 只绯狱丸。如果出现多个最大值，在每次比较时，请选择靠右的(std默认的)。

## 样例 #1

### 输入

```
10 10
1 2 3 4 5 6 7 8 9 10
2 1 10
2 1 10
2 1 10
2 1 10
2 1 10
2 1 10
2 1 10
2 1 10
2 1 10
2 1 10
```

### 输出

```
10
9
8
7
6
5
4
3
2
1
QAQ```

## 样例 #2

### 输入

```
10 11
0 0 0 0 0 0 0 0 0 0
3 1 10 1
3 2 10 1
3 3 10 1
3 4 10 1
3 5 10 1
3 6 10 1
3 7 10 1
3 8 10 1
3 9 10 1
3 10 10 1
2 1 10
```

### 输出

```
10
QAQ```

## 样例 #3

### 输入

```
10 13
0 0 0 0 0 0 0 0 0 0
1 10 10000
1 9 9000
1 8 8000
1 7 7000
1 6 6000
1 5 5000
1 4 4000
1 3 3000
1 2 2000
1 1 1000
2 10 10
2 8 8
2 8 10
```

### 输出

```
10000
8000
9000
Sakura```

# 题解

## 作者：Konnyaku_ljc (赞：13)

### 线段树（较简略）+模拟（最短但是没注释）
##### 要不是和我老婆有关，我才不做呢（哼
这道题我一年前就发现了，模拟45pt，看到模拟题解后，我吃了一惊。。。为什么倒序循环能ACCEPT，而正序只有45pt？！~~自闭了~~  
所以我~~吸氧的~~36行跑的那么快仅仅就改了个倒序循环。。。  
几个坑点
- 飞鱼丸会吸走能量，但是bcy只能获得飞鱼丸吸收后的能量  
- 让您以为本题是线段树，做完之后再告诉您其实是个暴力。。。  
- ~~没玩过bh3也能做~~  
- ~~嘤嘤刀不会升级~~  

但我们还是要来说一下线段树，其实线段树真的不好码。。。  
因为我们不但要标记飞鱼丸，还有区间修改，最大值查询和单点修改  
##### ~~我找了好几道线段树才拼在一起的！~~  
解释不多，相信您们都能看懂，我码了2个小时，12点啦，虚啦~  
#### 变量名有一半是我老婆哦！！！
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,m,bcy=0,p,x,y,v;
//布狼牙/八重樱/琪亚娜
int blny[100000+100],qyn[100000*4+10];
//因为重载了max,所以延迟标记要单独出来
struct node{
    int maxx,max_place;
    friend node max(node a,node b) { return a.maxx>b.maxx ? a:b; }//重载max
}tree[100000*4+10];//存树 
void build(int l,int r,int num) // 标准建树 
{
    if(l==r)
	{
        cin >> tree[num].maxx;
        tree[num].max_place=l; 
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,num<<1);
    build(mid+1,r,num<<1|1);
    tree[num]=max(tree[num<<1],tree[num<<1|1]);
}
//希儿
void xe(int l,int r,int num) //将某点清零 
{
    if(qyn[num])
	{
        int mid=(l+r)>>1;
        tree[num<<1].maxx+=qyn[num];
        tree[num<<1|1].maxx+=qyn[num];
        qyn[num<<1]+=qyn[num];
        qyn[num<<1|1]+=qyn[num];
        qyn[num]=0;
    }
}
//姬子
void jz(int l,int r,int L,int val,int num) 
//将这个飞鱼丸标记qwq 
{
    if(l==r)
	{
        tree[num].maxx=val-tree[num].maxx;
        return;
    }
    int mid=(l+r)>>1;
    xe(l,r,num);
    if(mid<L) jz(mid+1,r,L,val,num<<1|1);
    else jz(l,mid,L,val,num<<1);
    tree[num]=max(tree[num<<1],tree[num<<1|1]);
}
node ask(int l,int r,int L,int R,int num) //标准查询 
{
    if(l==L&&r==R) return tree[num];
    int mid=(l+r)>>1;
    xe(l,r,num);
    if(mid<L) return ask(mid+1,r,L,R,num<<1|1);
    else if(mid>=R) return ask(l,mid,L,R,num<<1);
    else return max(ask(l,mid,L,mid,num<<1),ask(mid+1,r,mid+1,R,num<<1|1));
}
void change(int l,int r,int L,int R,int val,int num) //标准区间修改 
{
    if(l==L&&r==R)
	{
        tree[num].maxx+=val;
        qyn[num]+=val;
        return;
    }
    int mid=(l+r)>>1;
    xe(l,r,num);
    if(mid<L) change(mid+1,r,L,R,val,num<<1|1);
    else if(mid>=R) change(l,mid,L,R,val,num<<1);
    else change(l,mid,L,mid,val,num<<1),change(mid+1,r,mid+1,R,val,num<<1|1);
    tree[num]=max(tree[num<<1],tree[num<<1|1]);
} 
void add(int x,int val) { for(;x<=n;x+=x&-x) blny[x]+=val;} 
//标准区间加 
int sum(int x) //标准区间求和 
{
    int ans=0;
    for(;x;x-=x&-x) ans+=blny[x];
    return ans;
}
int main()
{
    cin >> n >> m;
    build(1,n,1); //建树 
    while(m--)
	{
        cin >> p;
        if(p==1)
		{
            cin >> x >> v;
            jz(1,n,x,v,1); //标记飞鱼丸  
            add(x,x); //嘤嘤嘤能量变
        }
		if(p==2)
		{
            cin >> x >> y;
            int num=sum(y)-sum(x-1);//飞鱼丸 
            if(num)
			{
                node ans=ask(1,n,num,num,1); 
                printf("%d\n",ans.maxx);
                bcy += ans.maxx; //获得能量++ 
                change(1,n,num,num,-ans.maxx,1); 
				//牵一发而动全身 
                add(num,-num);
                continue;
            }
            node ans=ask(1,n,x,y,1);//最大点 
            change(1,n,ans.max_place,ans.max_place,-ans.maxx,1);
            printf("%d\n",ans.maxx);
            bcy += ans.maxx;//同上了qwq 
        }
		if (p == 3) 
		{
            cin >> x >> y >> v; 
            change (1,n,x,y,v,1); //区间修改 
        }
    }
    if(bcy<10000) printf("QAQ");
    else  if(bcy<10000000) printf("Sakura");
    else printf("ice");
    return 0;
}
```
附36行小模拟~~这最多也就是个黄题吧~~  
倒序太坑人了CRY
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m,num,l,r,val,now,x,a[100005],ans;
bool b[100005];
int main()
{
    cin >> n >> m;
    for ( int i = 1; i <= n; i++ ) cin >> a[i];
    while (m--)
    {
    	cin >> num;
    	if ( num == 1 ) cin >> x >> val , a[x] = val-a[x],b[x] = 1;
		if ( num == 2 )
		{
			cin >> l >> r , val = 0;
			for ( int i = r; i >= l; i-- )
			{
				if (b[i]) { now = i , b[i] = 0 , val = a[i]; break; }
				if (val < a[i]) now = i , val = a[i];
			}
			a[now] = 0 , ans += val;
			cout << val << endl;
		}
		if ( num == 3 )
		{
			cin >> l >> r >> val;
			for ( int i = l; i <= r; i++ ) a[i] += val;
		}
	}
	if (ans<10000) cout<<"QAQ";
	if (ans>=10000&&ans<10000000) cout<<"Sakura";
	if (ans>=10000000) cout<<"ice";
	return 0;
}
```

实际证明，线段树比模拟共快了400ms！  
~~算了，以后就只打暴力了~~  
谢谢观赏

---

## 作者：EDqwq (赞：5)

此题难度：

读题难度：黑

代码难度：红

综合难度：绿

***

### 题意：

给你一个数列 a，你要对它做以下3种操作：

1. 给你x，w，将$a[x]$修改为$w - a[x]$，并给x这个位置打上标记。

1. 给你一个区间x，y，如果这个区间有被标记的位置，ans += 这些位置上面的数的总和，并把标记去掉，输出所有的数，数变为0。如果这个区间没有被标记的数，ans += 这个区间最大的数，输出这个数，并把这个数改为0。

1. 给你一个区间x，y，给你一个数w，给这个区间所有的数加上w。

对于最终的ans，依照题意进行对应的输出。

***

### 做法：

暴力模拟即可。

注意，这道题不可以开long long，WA 80的请注意这一点。

***

### 代码：

```cpp
/*
  Author: EnderDeer
  Online Judge: Luogu
*/

#include<bits/stdc++.h>

#define mem(x) memset(x,0,sizeof(x))

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n,m;
int a[1000010];
bool bk[1000010];
int ans;

signed main(){
	cin>>n>>m;
	for(int i = 1;i <= n;i ++)a[i] = read();
	while(m --){
		int op,x,y,w;
		op = read();
		if(op == 1){
			x = read(),w = read();
			a[x] = w - a[x];
			bk[x] = true;
		}
		if(op == 2){
			x = read(),y = read();
			bool flag = false;
			for(int i = x;i <= y;i ++){
				if(bk[i]){
					bk[i] = false;
					ans += a[i];
					printf("%d\n",a[i]);
					a[i] = 0;
					flag = true;
				}
			}
			if(flag)continue;
			int s = 0;
			int num;
			for(int i = x;i <= y;i ++){
				if(a[i] >= s){
					s = a[i];
					num = i;
				}
			}
			ans += s;
			printf("%d\n",a[num]);
			a[num] = 0;
		}
		if(op == 3){
			x = read(),y = read(),w = read();
			for(int i = x;i <= y;i ++)a[i] += w;
		}
	}
	if(ans < 10000)puts("QAQ");
	else if(ans < 10000000)puts("Sakura");
	else puts("ice");
	return 0;
}
```

---

## 作者：By_Ha (赞：5)

- ~~**原**休伯利安甲板清洁工已经AC此题了~~



- 这题正解并不难想到,题目要求求出区间最值,如果区间中有飞鱼丸,那么求出飞鱼丸所在位置
- 我们显然可以维护一个含有两个参数的线段树,然后很容易AC.



- 但是看一看数据范围,好小啊,所以我选择直接暴力:
  - 我们直接维护八重村(数组`a[]`),并让板鸭监视飞鱼丸(数组`f[]`),也就是说,a数组中记录每一个点的嘤嘤嘤能量,f数组中记录每一个点是否有飞鱼丸.
  - 对于操作1,我们将`f[x]`的值覆写为1,并更新`a[x]`为`val-a[x]`
  - 对于操作2,我们从`r`遍历至`l`,发现飞鱼丸直接`break`,否则记录区间的最大值及其位置.
  - 对于操作3,我们从`l`到`r`,暴力区间加.
  - 然后`1.27MB`,`2.21s`AC,没错确实很慢.
  - 下面我们结合代码看

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
#define Rint register int//把变量放在CPU寄存器中,读取更快
int a[100001];//八重村
int f[100001];//飞鱼丸
int qr(){int ret=0,f=1;char ch=getchar();while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();return ret*f;}//快速读入
int main()
{
    /*
    	N->八重村大小
    	M->事件总数
    	t1,t2,t3,t4->事件参数
    	max_val->最大值(操作2)
    	max_plc->最大值所处位置(操作2)
    	YYY->嘤嘤嘤
    */
    Rint N,M,t1,t2,t3,t4,max_val,YYY=0,max_plc;//声明的是放在寄存器中的变量以加快速度
    N = qr(),M = qr();//N,M快速读入
    for(Rint i = 1;i<=N;i++){
        a[i] = qr();//读入每一点的嘤嘤嘤能量
    }
    for(Rint i = 1;i<=M;i++){
        t1 = qr(),t2 = qr(),t3 = qr();//读入操作
        if(t1 == 1){
            a[t2] = t3 - a[t2];//更改嘤嘤嘤能量
            f[t2] = 1;//派遣板鸭监视
        }else if(t1 == 2){
            max_val = 0;//初始化最大能量
            for(Rint j = t3;j>=t2;--j){//反向查找
                if(f[j]){//如果该点有飞鱼丸
                    max_plc = j;//更改目标位置
                    f[j] = 0;//八重樱对付飞鱼丸
                    max_val = a[j];//并获取飞鱼丸的能量
                    break;
                }
                if(a[j] > max_val){//更新区间最大值及其位置
                    max_val = a[j];
                    max_plc = j;
                }
            }
            a[max_plc] = 0;//清空目标位置能量
            printf("%d\n",max_val);//输出目标能量
            YYY+=max_val;//嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤
        }else{
            t4 = qr();
            for(Rint j = t2;j<=t3;++j){//暴力区间加
                a[j]+=t4;
            }
        }
    }
    if(YYY < 10000){
        cout << "QAQ";//QAQ
    }else if(YYY < 10000000){
        cout << /*Yae*/"Sakura";
    }else cout << "ice";//Ich liebe dich?
    return 0;
}
```


---

## 作者：Maysoul (赞：2)

非常毒瘤的一道线段树题。

## 简化题意：

给定一个数列，支持如下操作：

1. 对路径中一个点修改并标记。

1. 求一段区间内的最大值，如果有被标记的值则输出被标记的值，同时将这个值清零。

1. 对一段区间进行修改。

## 简述思路：

首先，我们需要一棵支持区间修改和单点修改的线段树，它维护最大值。

（如果你还不会线段树，请转去 [P3373](https://www.luogu.com.cn/problem/P3373)）。

然后，我们可以创建一个 $ vis $ 数组，标记每一个被修改的点。

这样，在处理问题 2 的时候，我们就可以先遍历区间中的点是否有被标记，如果有的话，答案就是被标记的点的权值。

如果没有的话，询问这个区间就可以啦。

最后，我们还需要把最大的点置为零，这个就比较麻烦，所以我们可以在维护区间最大值的时候，同时维护它的位置。

然后，我们可以根据它的位置，用单点修改的代码将它清零。

那么我们在求区间最大值的时候就需要多绕一圈，因为我们不单单要维护最大值，还需要维护它的位置。这里我选择重新开了一个结构体，维护位置和权值，接下来的处理就跟之前一样了。

看上去好像不难，但整整卡了我好几天，一直到我今天决定重新写一份才过去。

## 可能略长的 CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num,ans;
struct node{
	int l,r;
	int mx,md,mark;
	node(){
		l=r=-1;
		mx=mark=md=0;
	}
}ts[4*MAXN];
struct thanks{//维护最大的位置和权值
	int id,val;
	thanks(){id=0;val=INT_MIN;};
	thanks(int aa,int bb){id=aa;val=bb;}
};
int a[MAXN];
bool fyw[MAXN];
void putup(int id)//修改当前点的最大值及位置
{
	int lcid=id*2;
	int rcid=lcid+1;
	if(ts[lcid].mx>ts[rcid].mx){
		ts[id].mx=ts[lcid].mx;
		ts[id].md=ts[lcid].md;
	}
	else{
		ts[id].mx=ts[rcid].mx;
		ts[id].md=ts[rcid].md;
	}
}
void putdown(int id)//标准线段树懒标记下放
{
	int lcid=id*2;
	int rcid=lcid+1;
	if(ts[id].mark==0) return;
	ts[lcid].mx+=ts[id].mark;
	ts[rcid].mx+=ts[id].mark;
	ts[lcid].mark+=ts[id].mark;
	ts[rcid].mark+=ts[id].mark;
	ts[id].mark=0;
}
void build(int id,int l,int r)//标准线段树建树
{
	ts[id].l=l;
	ts[id].r=r;
	if(l==r){
		ts[id].mx=a[l];
		ts[id].md=l;
		return;
	}
	int mid=(l+r)/2;
	int lcid=id*2;
	int rcid=lcid+1;
	build(lcid,l,mid);
	build(rcid,mid+1,r); 
	putup(id);
}
void update(int id,int goal,int val)//标准线段树单点更新
{
	if(ts[id].l==ts[id].r){
		if(ts[id].l==goal){
			ts[id].mx=val-ts[id].mx;
		}
		return;
	}
	putdown(id);
	int mid=(ts[id].l+ts[id].r)/2;
	int lcid=id*2;
	int rcid=lcid+1;
	if(goal<=mid) update(lcid,goal,val);
	if(goal>mid) update(rcid,goal,val);
	putup(id);
	return;
}
void zero(int id,int goal)//对一个点进行清零
{
	if(ts[id].l==ts[id].r){
		if(ts[id].l==goal){
			ts[id].mx=0;
		}
		return;
	}
	putdown(id);
	int mid=(ts[id].l+ts[id].r)/2;
	int lcid=id*2;
	int rcid=lcid+1;
	if(goal<=mid) zero(lcid,goal);
	if(goal>mid) zero(rcid,goal);
	putup(id);
	return;
}
void lineup(int id,int l,int r,int val)//标准线段树区间更新
{
	if(ts[id].l>=l&&ts[id].r<=r){
		ts[id].mark+=val;
		ts[id].mx+=val;
		return;
	}
	putdown(id);
	int mid=(ts[id].l+ts[id].r)/2;
	int lcid=id*2;
	int rcid=lcid+1;
	if(l<=mid) lineup(lcid,l,r,val);
	if(r>mid) lineup(rcid,l,r,val);
	putup(id);
}
thanks cpr(thanks x,thanks y)//这里求得最大值，起比较的作用
{
	if(x.val>y.val) return x;
	return y;
}
thanks show(int id,int l,int r)//求得当前点的最大值及它的位置
{
	if(ts[id].l>=l&&ts[id].r<=r){
		return thanks(ts[id].md,ts[id].mx);
	}
	putdown(id);
	int mid=(ts[id].l+ts[id].r)/2;
	int lcid=id*2;
	int rcid=lcid+1;
	thanks tot;
	if(l<=mid) tot=cpr(tot,show(lcid,l,r));
	if(r>mid) tot=cpr(tot,show(rcid,l,r));
	return tot;
}
int main()
{
	std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	int n,m;
	cin>>n>>m;
	for (int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,1,n);
	int x,y,val,opt;
	for (int i=1;i<=m;i++){
		cin>>opt;
		if(opt==1){
			cin>>x>>val;
			update(1,x,val);
			fyw[x]=1;//标记当前点
		}
		else if(opt==2){
			cin>>x>>y;
			bool flag=0;
			for (int j=x;j<=y;j++){//枚举这个区间有无标记
				if(fyw[j]){
					thanks you=show(1,j,j);
					ans+=you.val;
					cout<<you.val<<endl;
					zero(1,j);
					fyw[j]=0;
					flag=1;
				}
			}
			if(!flag){
				thanks you=show(1,x,y);
				ans+=you.val;
				cout<<you.val<<endl;
				zero(1,you.id);
			}
		}
		else{
			cin>>x>>y>>val;
			lineup(1,x,y,val);
		} 
	}
	if(ans<10000) cout<<"QAQ"<<'\n';
	else if(ans<10000000) cout<<"Sakura"<<'\n';
	else cout<<"ice"<<'\n';
	return 0;
}
```


---

## 作者：Harry27182 (赞：2)


~~感觉这题没有绿啊，暴力模拟就能过......~~


------------


 操作一：

 在$x$地点出现绯狱丸，只需要一个$bool$数组维护是否有绯狱丸，然后按照题意更新权值即可。
 
 操作二：
 
 先用一个$for$循环跑一遍$l$到$r$，寻找有没有点带绯狱丸，如果有，就把绯狱丸去掉，然后清空该点权值即可。如果没有绯狱丸，就找到区间里最大的一个点，清空该点权值。最后输出该点权值即可。
 
 操作三：
 
 没什么好说的，从$l$枚举到$r$,都加上$val$即可。
 
 最后判断得到的能量属于哪个类型，输出相应字符串即可。
 
 完整代码如下：
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,l,r,v,op,ans,sum,num;
int a[10000005];
bool b[10000005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d%d",&x,&v);
			a[x]=v-a[x];
			b[x]=true;
		}
		if(op==2)
		{
			scanf("%d%d",&l,&r);
			int flag=0;
			for(int j=l;j<=r;j++)
			{
				if(b[j]==true)
				{
					b[j]=false;
					ans+=a[j];
					cout<<a[j]<<endl;
					a[j]=0;
					flag=1;
				}
			}
			if(flag==1)continue;
			sum=0;
			for(int j=l;j<=r;j++)
			{
				if(a[j]>=sum)
				{
					sum=a[j];
					num=j;
				}
			}
			ans+=sum;
			cout<<a[num]<<endl;
			a[num]=0;
		}
		if(op==3)
		{
			scanf("%d%d%d",&l,&r,&v);
			for(int j=l;j<=r;j++)
			{
				a[j]+=v;
			}
		}
	}
	if(ans<10000)cout<<"QAQ";
	else if(ans<1000000)cout<<"Sakura";
	else cout<<"ice";
	return 0;
}
```
最后，切记不要用$cin$读入，不要开$long long$。
~~（否则$TLE$在向您招手......)~~

---

## 作者：zjjws (赞：2)

写了个分块，开了下 $\operatorname O^2$。于是乎最优解了？

先分析每个操作：

$\operatorname A:$ 单点修改。

$\operatorname B:$ 区间查询 $+$ 单点修改。

$\operatorname C:$ 区间修改。

再看一眼数据范围：$n,m\le 10^5$。

分块 $\operatorname O(m\sqrt n)$ 完全没有问题。

这里不会讲分块的具体实现步骤，不会分块的请移步。（去网上找找，luogu 不太好找分块）。

我们需要维护的是：

$1.$ 块内最大值。

$2.$ 块内公共值。

$3.$ 每个点的值（不算上公共值）。

（$1,2,3$ 是分块中比较常见的两个需要维护的值）

$4.$ 每个块以及每个点是否有绯狱丸。

$5.$ 对于每个块 Yae Sakura 会选择的地点，即**区间最大值的位置**或是**有绯狱丸的位置**。

$\operatorname {Question}:$ 如果一个块内有多个绯狱丸该记录哪个位置？

$\operatorname {Answer}:$ 题目中有：

```
对于事件 2 ，题目保证每个事件中最多出现 1 只绯狱丸。如果出现多个最大值，在每次比较时，请选择靠右的(std默认的)。

```
也就是说，如果整个块被调用的时候，这个块最多只会有一只绯狱丸。反过来，有多只绯狱丸的块只会有部分被调用，而部分调用块是不会用到 $5$ 维护的这个东西的。

---

一些细节：

对于 $\operatorname A$ 中的单点修改，就不用维护 $1$ 和 $5$ 了，因为 Yae Sakura 只会去那个绯狱丸的位置，并且因为分块的单点值分为 $a_i$ 和区间公共值 $s$，这里的修改操作应为 $a_i=val-(a_i+2s)$。

$\operatorname {Question}:$ 为什么要减 $2s$？

$\operatorname {Answer}:$ 设修改前 $a_i=x$，修改后 $a_i=y$，满足：

$$val-(x+s)=y+s$$

$$y=val-(x+2s)$$

毕竟单点修改又不能去修改区间的值。

$\operatorname B$ 中的区间查询，我是返回传送的位置，这样方便把这个位置的嘤嘤嘤值变成 $0$；然后这一步的单点修改，应该是 $a_i=-s$（$a_i$ 和 $s$ 的含义与上面相同），然后修改完以后 $\operatorname O(\sqrt n)$ 扫一遍传送位置所在的块，重新维护这段的 $4$ 和 $5$。

$\operatorname C$ 操作的话，对于整个块做加法的时候直接加公共值 $s$ 就好了；部分块的话，则分**当前块有绯狱丸**和**当前块没有绯狱丸**两种情况来做，因为如果没有绯狱丸需要在加的时候维护一波 $1$ 和 $5$。

题目本身的坑点：说最终答案在 $[0,2^{31}-1]$ 范围内，但实际上你却需要靠 $int$ 溢出来达到和 std 相同的答案，如果不是翻讨论区我真不一定能发现这个问题。

附代码：

```cpp
#include <bits/stdc++.h>
#define LL long long
#define max(a,b) a>b?a:b
using namespace std;
const int MAX=1e5+3;
const int MAN=350;
LL a[MAX];
LL f[MAN];
LL s[MAN];
int l[MAN];
int r[MAN];
int to[MAX];
int max_noi[MAN];
bool if_poi[MAX];
bool if_noi[MAN];
int n,m;
inline void add_2(int x,int y,LL k)
{
    int now=to[x];
    if(!if_noi[now])
    for(int i=y;i>=x;i--)
    {
        a[i]+=k;
        if(a[i]>f[now]||(a[i]==f[now]&&max_noi[now]<i))f[now]=a[i],max_noi[now]=i;
    }
    else for(int i=x;i<=y;i++)a[i]+=k;
    return;
}
inline void add(int x,int y,int k)
{
    if(to[x]==to[y])
    {
        add_2(x,y,k);
        return;
    }
    add_2(x,r[to[x]],k);
    add_2(l[to[y]],y,k);
    for(int i=to[x]+1;i<to[y];i++)s[i]+=k;
}
inline int cheak(int x,int y)
{
    LL max_n;
    int last;
    max_n=-0x3f3f3f3f3f3f3f3f;
    if(to[x]==to[y])
    {
        for(int i=y;i>=x;i--)
        {
            if(if_poi[i])return i;
            if(a[i]+s[to[i]]>max_n)max_n=a[i]+s[to[i]],last=i;
        }
        return last;
    }
    for(int i=y;i>=l[to[y]];i--)
    {
        if(if_poi[i])return i;
        if(a[i]+s[to[y]]>max_n)max_n=a[i]+s[to[y]],last=i;
    }
    for(int i=to[y]-1;i>to[x];i--)
    {
        if(if_noi[i])return max_noi[i];
        if(f[i]+s[i]>max_n)max_n=f[i]+s[i],last=max_noi[i];
    }
    for(int i=r[to[x]];i>=x;i--)
    {
        if(if_poi[i])return i;
        if(a[i]+s[to[x]]>max_n)max_n=a[i]+s[to[x]],last=i;
    }
    return last;
}
inline void init()
{
    int lens=sqrt(n);
    m=n/lens;
    for(int i=1;i<=m;i++)l[i]=(i-1)*lens+1,r[i]=i*lens;
    if(n%lens)l[m+1]=r[m]+1,r[++m]=n;
    for(int i=1;i<=m;i++)
    for(int j=r[i];j>=l[i];j--)
    {
        to[j]=i;
        if(a[j]>f[i])f[i]=a[j],max_noi[i]=j;
    }
    return;
}
LL rin()
{
    LL s=0;
    char c=getchar();
    bool bj=0;
    for(;(c>'9'||c<'0')&&c!='-';c=getchar());
    if(c=='-')c=getchar(),bj=true;
    for(;c>='0'&&c<='9';c=getchar())s=(s<<1)+(s<<3)+(c^'0');
    if(bj)return -s;
    return s;
}
int main()
{
    memset(f,-0x3f,sizeof(f));
    n=rin();
    int q=rin();
    for(int i=1;i<=n;i++)a[i]=rin();
    init();
    int ans=0;
    for(;q>0;q--)
    {
        int z=rin();
        if(z==1)
        {
            int x,y;
            x=rin();y=rin();
            if_poi[x]=true;
            if_noi[to[x]]=true;
            a[x]=y-a[x]-(s[to[x]]<<1);
            // change_x(x,y-a[i]);
            max_noi[to[x]]=x;
        }
        if(z==2)
        {
            int x,y;
            x=rin();y=rin();
            x=cheak(x,y);
            int now=to[x];
            printf("%lld\n",s[now]+a[x]);
            ans+=s[now]+a[x];
            a[x]=-s[now];
            if_poi[x]=false;
            if_noi[now]=false;
            f[now]=-0x3f3f3f3f3f3f3f3f;
            for(int i=r[now];i>=l[now];i--)
            {
                if(if_poi[i])
                {
                    f[now]=a[i];
                    max_noi[now]=i;
                    if_noi[now]=true;
                    break;
                }
                if(a[i]>f[now])f[now]=a[i],max_noi[now]=i;
            }
        }
        if(z==3)
        {
            int x,y;
            LL k;
            x=rin();y=rin();k=rin();
            add(x,y,k);
        }
    }
    if(ans<10000)printf("QAQ");
    if(ans>=10000&&ans<10000000)printf("Sakura");
    if(ans>=10000000)printf("ice");
    return 0;
}
```


---

## 作者：dbg_8 (赞：2)

显而易见，这题是一道线段树的题，然而，模拟是可以 AC 此题的！

首先看题。题目讲得很清楚，完全可以按照题目中所讲的顺序模拟。只要按照题面的描述打一遍暴力，无需任何优化，就可以切了这题。

不过这题还是有一些坑点的。

### · 至于执行操作二时为什么要倒序查找： 

``` 
对于事件 2 ，题目保证每个事件中最多出现 1 只绯狱丸。如果出现多个最大值，在每次比较时，请选择靠右的(std默认的)。
```

上面这句话在题面结尾，于是许多人没看见，100 -> 45

### · 至于执行操作二时为什么找到一个绯狱丸就要 break ：

```
当 l , r 之间存在绯狱丸时，八重樱会优先用她的嘤嘤刀对付绯狱丸
```

注意“优先”二字

代码浅显易懂，所以不过多注释了。

## 源码
（耗时4.1s，但还是过了）

``` cpp
#include <iostream>
#include <stdio.h>
using namespace std;
int a[100003]; // 表示第i个位置的嘤嘤嘤能量
bool fyw[100003] = { false }; // 表示第i个位置是否有绯狱丸
int main() {
	int n, m, ans = 0;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	while(m--) {
		int mod, l, r, x, val;
		scanf("%d", &mod);
		if (mod == 1) {
			scanf("%d %d", &x, &val);
			a[x] = val - a[x];
			fyw[x] = true;
		}
		else if (mod == 2) {
			scanf("%d %d", &l, &r);
			int maxp = 0, maxn = 0;
			for (int i = r; i >= l; i--) { // 倒序
				if (fyw[i]) {		// 注意题面中“优先”二字，记得break
					fyw[i] = false;
					maxp = i, maxn = a[i];
					break;
				}
				if (a[i] > maxn)
					maxp = i, maxn = a[i];
			}
			ans += maxn;
			a[maxp] = 0;
			printf("%d\n", maxn);
		}
		else {
			scanf("%d %d %d", &l, &r, &val);
			for (int i = l; i <= r; i++)
				a[i] += val;
		}
	}
	// I love bh3 forever!!
	if (ans < 10000)
		printf("QAQ");
	else if (ans < 10000000)
		printf("Sakura");
	else
		printf("ice");
	return 0;
}
```
吸了口氧气后：

![](https://cdn.luogu.com.cn/upload/image_hosting/wszp4cnr.png)

---

## 作者：yukari1735 (赞：1)

## 线段树。

### 题意简述：

给定一个长度为 $ n $ 的数列，有 $ m $ 个操作。

操作 $ 1 $，单点修改，并给该点一个标记。

操作 $ 2 $，区间取最值，并将最值点修改为 $ 0 $，如果该点有标记，取消标记。

操作 $ 3 $，区间加。

如果没有标记这个特性，我们完全可以打出一个 $ RMQ $ 线段树，树上每个节点维护一个区间的最大值。

对于有标记的点，我们发现在取最值时一定会取这个点而不是取区间内别的点，所以我们可以写出下面的 $ comp $ 函数来维护。

```cpp
// v为该节点权值，f为该点是否有标记
Node comp(Node a,Node b){
	// 标记的优先级大于权值比较的优先级。
	if(a.f&&!b.f) return a;
	if(!a.f&&b.f) return b;
	if(a.v>b.v) return a;
	else return b;
}
```

进一步地，为了在取最值时将最值点修改为 $ 0 $，我们可以在每个线段树节点上存一个最值的位置 $ x $，$ query $ 时直接传上来，再将 $ x $ 的位置修改为 $ 0 $ 即可。

这样下来这道题就变得十分显然了，线段树模拟题意操作即可。

CODE :
```cpp
#include<iostream>
#include<cstdio>
#define lefc(x) x<<1
#define rigc(x) x<<1|1
using namespace std;
const int N=100010;
const int INF=0x3f3f3f3f;
struct Node{
	int v,x,f;
}t[N<<3];
int a[N],tg[N<<3];
int n,m;
int ans;
Node comp(Node a,Node b){
	if(a.f&&!b.f) return a;
	if(!a.f&&b.f) return b;
	if(a.v>b.v) return a;
	else return b;
}
void push_down(int curr){
	int lc=lefc(curr),rc=rigc(curr);
	t[lc].v+=tg[curr];
	t[rc].v+=tg[curr];
	tg[lc]+=tg[curr];
	tg[rc]+=tg[curr];
	tg[curr]=0;
}
void push_up(int curr){t[curr]=comp(t[lefc(curr)],t[rigc(curr)]);}
void build(int curr,int l,int r){
	if(l==r){t[curr].v=a[l],t[curr].x=l;return;}
	int mid=(l+r)>>1;
	build(lefc(curr),l,mid);
	build(rigc(curr),mid+1,r);
	push_up(curr);
}
void update(int curr,int l,int r,int L,int R,int k){
	if(L<=l&&r<=R){t[curr].v+=k,tg[curr]+=k;return;}
	int mid=(l+r)>>1;
	if(tg[curr]) push_down(curr);
	if(L<=mid) update(lefc(curr),l,mid,L,R,k);
	if(R>mid) update(rigc(curr),mid+1,r,L,R,k);
	push_up(curr);
}
void updatex(int curr,int l,int r,int x,int k,int opt){
	if(l==r){t[curr].v=k,t[curr].f=opt;return;}
	int mid=(l+r)>>1;
	if(tg[curr]) push_down(curr);
	if(x<=mid) updatex(lefc(curr),l,mid,x,k,opt);
	else updatex(rigc(curr),mid+1,r,x,k,opt);
	push_up(curr);
}
Node query(int curr,int l,int r,int L,int R){
	if(L<=l&&r<=R) return (Node){t[curr].v,t[curr].x,t[curr].f};
	int mid=(l+r)>>1;
	if(tg[curr]) push_down(curr);
	Node tot={-INF,0,0};
	if(L<=mid) tot=comp(tot,query(lefc(curr),l,mid,L,R));
	if(R>mid) tot=comp(tot,query(rigc(curr),mid+1,r,L,R));
	return tot;
}
void solve(){
	for(int i=1;i<=m;i++){
		int opt;scanf("%d",&opt);
		if(opt==1){
			int x,val;scanf("%d%d",&x,&val);
			Node tmp=query(1,1,n,x,x);
			updatex(1,1,n,x,val-tmp.v,1);
		}
		else if(opt==2){
			int l,r;scanf("%d%d",&l,&r);
			Node tmp=query(1,1,n,l,r);
			updatex(1,1,n,tmp.x,0,0);
			printf("%d\n",tmp.v);
			ans+=tmp.v;
		}
		else if(opt==3){
			int l,r,val;scanf("%d%d%d",&l,&r,&val);
			update(1,1,n,l,r,val);
		}
	}
	if(ans>=10000&&ans<10000000) printf("Sakura\n");
	else if(ans<10000) printf("QAQ\n");
	else printf("ice\n");
}
void input(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
}
int main(){
	input();
	build(1,1,n);
	solve();
	return 0;
}
```
实测 $ 808 ms$。

以上。

---

## 作者：logfk (赞：1)

## 前言

考虑到针对随机数据的题解众多，缺少非随机数据的处理，写了这篇题解来帮助各位理解本题的真正解法。

（模拟赛中简单随机（构造）出了几个能让模拟 TLE 的数据。）

## 分析

显然这道题仅有三个操作，第一个操作是给一个点修改值后打上特殊的标记，使得之后的询问中优先进行询问。

第二个操作除去特殊的操作就是一个区间最大值问题。

第三个操作也很显然是一个区间加，因此这道题我们可以仅用一个线段树就可以过掉。

容易发现，一个区间中有特殊标记，当且仅当它本身是叶子结点且被标记或者它的叶子结点的某一个被标记，由于题目保证每次查询仅有一个特殊标记，所以我们询问时可以直接下传至叶子结点，这样的时间复杂度仅为 $O(\log n)$。

进行查询最大值操作时，由于我们还需要删除这个节点的信息，所以我们在上传过程中还需要记录最大值从那个叶子节点传来，具体内容可见代码。

这样的时间复杂度很显然是 $O(mlogn)$ 的，很轻松的过掉了此题，反观模拟的时间复杂度就不尽如人意了。

2021/09/26 目前最优解 362ms。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,mx;//左儿子，右儿子以及区间最大值
	int mxs;//最大值的叶节点位置
	int laz;//区间加的 lazytag
	int fl;//一个区间内含有绯狱丸
}tr[1600010];
int a[100010];//初值
bool pd[100010];//一个点是否存在绯狱丸
#define FastIO
#ifdef FastIO
    char buf[1<<21],*p1,*p2;
    #define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
template<class T>
T Read()
{
    T x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^'0');
        ch=getchar();
    }
    return x*f;
}
int (*read)()=Read<int>;//快读（从别人那粘的）
int sum;
void push_up(int x)
{
	//进行更新最大值以及上传儿子操作
	if(tr[x<<1].mx>tr[x<<1|1].mx)
	{
		tr[x].mx=tr[x<<1].mx;
		tr[x].mxs=tr[x<<1].mxs;
	}
	else
	{
		tr[x].mx=tr[x<<1|1].mx;
		tr[x].mxs=tr[x<<1|1].mxs;
	}
	tr[x].fl=tr[x<<1].fl|tr[x<<1|1].fl;//上绯狱丸标记
}
void build(int x,int l,int r)
{
	tr[x].l=l,tr[x].r=r;
	if(l==r)
	{
		tr[x].mx=a[l];
		tr[x].mxs=l;
		return;
	}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	push_up(x);
}//标准建树
void push_down(int x)
{
	if(!tr[x].laz) return;
	tr[x<<1].mx+=tr[x].laz,tr[x<<1|1].mx+=tr[x].laz;
	tr[x<<1].laz+=tr[x].laz,tr[x<<1|1].laz+=tr[x].laz;
	tr[x].laz=0;
}//区间加下传
void addfyw(int x,int L,int val)//在线段树中加入绯狱丸
{
	if(tr[x].l==L&&tr[x].r==tr[x].l)
	{
		tr[x].fl=1;
		tr[x].mx=val-tr[x].mx;
		return;
	}
	push_down(x);
	int mid=(tr[x].l+tr[x].r)>>1;
	if(L<=mid) addfyw(x<<1,L,val);
	else addfyw(x<<1|1,L,val);
	push_up(x);
}
void add(int x,int L,int R,int val)//区间加
{
	int l=tr[x].l,r=tr[x].r;
	if(L<=l&&r<=R)
	{
		tr[x].mx+=val;
		tr[x].laz+=val;
		return;
	}
	push_down(x);
	int mid=(l+r)>>1;
	if(L<=mid) add(x<<1,L,R,val);
	if(R>mid) add(x<<1|1,L,R,val);
	push_up(x);
}
pair<int,int> quefyw(int x,int l,int r)//pair第一维绯狱丸的编号，第二位绯狱丸的权值
{
	if(l==r)
	{
		return make_pair(l,tr[x].mx);
	}
	push_down(x);
	if(tr[x<<1|1].fl) return quefyw(x<<1|1,tr[x<<1|1].l,tr[x<<1|1].r);
	if(tr[x<<1].fl) return quefyw(x<<1,tr[x<<1].l,tr[x<<1].r);
}//查询仅有的一只绯狱丸
pair<int,int> que(int x,int L,int R)
{
	int l=tr[x].l,r=tr[x].r;
//	cout<<x<<" "<<l<<" "<<r<<endl;
	if(L<=l&&r<=R)
	{
		if(tr[x].fl)//区间内仅存在绯狱丸就直接找
		{
			return quefyw(x,tr[x].l,tr[x].r);
		}
		else
		{
			return make_pair(tr[x].mxs,tr[x].mx);
		}
	}
//		cout<<1<<endl;
	push_down(x);
	pair<int,int> le,ri;
	int mid=(l+r)>>1;
	if(R>mid) ri=que(x<<1|1,L,R);
	if(L<=mid) le=que(x<<1,L,R);
	if(pd[ri.first]==1) return ri;
	if(pd[le.first]==1) return le;//优先选择具有绯狱丸的
	if(le.second>ri.second) return le;
	else return ri;//否则比较最大值
}//区间的查询
void del(int x,int pos)
{
	int l=tr[x].l,r=tr[x].r;
	if(l==r&&r==pos)
	{
		tr[x].mx=0;
		tr[x].fl=0;
		return;
	}
	push_down(x);
	int mid=(l+r)>>1;
	if(pos<=mid) del(x<<1,pos);
	else del(x<<1|1,pos);
	push_up(x);
}//删除一个节点
int main()
{
//	freopen("yyy.in","r",stdin);
//	freopen("yyy.out","w",stdout);
	int n=read(),m=read();
	for(register int i=1;i<=n;++i)
	{
		a[i]=read();
	}
	build(1,1,n);
	for(register int i=1;i<=m;++i)
	{
		int opt=read(),l,r,x;
		if(opt==1)
		{
			l=read(),x=read();
			addfyw(1,l,x);
			pd[l]=1;
		}
		if(opt==2)
		{
			l=read(),r=read();
			pair<int,int> now=que(1,l,r);
			int pos=now.first,va=now.second;
			sum+=va;
			del(1,pos);
			pd[pos]=0;
			printf("%d\n",va);
		}
		if(opt==3)
		{
			l=read(),r=read(),x=read();
			add(1,l,r,x);
		}
	}
	if(sum<10000)
	{
		cout<<"QAQ"<<endl;
	}
	if(sum>=10000&&sum<10000000)
	{
		cout<<"Sakura"<<endl;
	}
	if(sum>=10000000)
	{
		cout<<"ice"<<endl;
	}
}
```


---

## 作者：Durancer (赞：1)

#### 题目描述

给定一个长度为$n$的序列，要求支持一下操作

- 1、将第$x$的位置的数修改为$val-x$，并将其标记为一个优先处理点
- 2、在区间$[l,r]$中找最大值（靠右的）加进答案中，但当区间内有优先处理点时此次操作要处理它。
- 3、给区间$[l,r]$中的每一个数都加上一个值$val$

#### 思路分析

- 线段树，写挂了QAQ

- 暴力！！！（如果这是今年NOIP的题目你会先写线段树嘛，当然要先来暴力啦，而且这个题暴力时间可以过去）然后就模拟过程就可以了

#### 坑点分析

- 原题中给我们的题目很不友好，一开始想成了绯狱丸也要自身的能量也要加上去，但是其实不然，我们只是加上了绯狱丸所处的位置的嘤嘤能量就可以了

- ~~话说玩过崩坏3的会不会知道点什么技巧~~

- 这个题不能开long long ，严重怀疑std是不是也溢出了（等待管理fix）

#### 代码实现（有较详细解释OVO）

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=1e5+9;
int n,m;//位置编号，询问次数
int ans;//一开始嘤嘤刀没有能量，嘤嘤嘤
int yyy[N];
int wanz[N];//标记绯狱丸的位置
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>yyy[i];
	while(m--)
	{
		int ques,x,y,val;
		cin>>ques;
		if(ques==1)
		{
			cin>>x>>val;
			yyy[x]=val-yyy[x];//绯狱丸改变这个位置的嘤嘤嘤能量
			wanz[x]=1;//打一下标记 
		}
		if(ques==2)
		{
			cin>>x>>y;
			int id=0;//最大值所在的位置 
			val=0;//这是最后嘤嘤刀吸收的能量
			for(int i=y;i>=x;i--)//因为是找靠右的最大值，所以反着搜
			{
				if(wanz[i])//有绯狱丸出现，必须击败他 
				{
					val=yyy[i];//他不吃绯狱丸，只吃所在位置的能量
					id=i;
					wanz[i]=0;
					break; 
				}
				if(yyy[i]>val)
				{
					val=yyy[i];
					id=i;
				}
			}
			ans+=val;
			yyy[id]=0;//被吸收完了，没了QAQ 
			cout<<val<<endl; 
		} 
		if(ques==3)
		{
			cin>>x>>y>>val;
			for(int i=x;i<=y;i++)
			yyy[i]+=val;
		} 
	}
	if(ans<10000)cout<<"QAQ"<<endl;
	else if(10000<=ans&&ans<10000000)cout<<"Sakura"<<endl;
	else cout<<"ice"<<endl;
	return 0;
} 
```



---

## 作者：夫赖 (赞：1)

# **最模拟的线段树**

### 这一题看似要用线段树维护区间和、区间最大值，但其实只要模拟就能过，~~于是我有了想法~~




------------







```cpp
//P4970 全村最好的嘤嘤刀
#include<bits/stdc++.h>
using namespace std;
const int maxn = 100010;
int n,m,e[maxn];
int tp,x,l,r,val,sum,maxe,idx;
bool f[maxn];
void work1()
{
	f[x]=1;
	e[x]=val-e[x];
	return;
}
void work2()
{
	maxe=-141572198;
	idx=r;
	for(int i=r;i>=l;i--)
	{
		if(f[i]==1)
		{
			sum+=e[i];
			printf("%d\n",e[i]);
			f[i]=0;
			e[i]=0;
			return;
		}
		if(maxe<e[i])
		{
			maxe=e[i];
			idx=i;
		}
	}
	e[idx]=0;
	printf("%d\n",maxe);
	sum+=maxe;
	return;
}
void work3()
{
	for(int i=l;i<=r;i++) e[i]+=val;
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&e[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&tp);
		if(tp==1) 
		{
			scanf("%d%d",&x,&val);
			work1();
		}
		if(tp==2) 
		{
			scanf("%d%d",&l,&r);
			work2();
		}
		if(tp==3) 
		{
			scanf("%d%d%d",&l,&r,&val);
			work3();
		}
	}
	if(sum<10000) printf("QAQ");
	else if(sum>=10000&&sum<1000000) printf("Sakura");
	else printf("ice");
	return 0;
}
```

希望管理员给个通过


---

## 作者：Miyamizu_Mitsuha (赞：0)

读题噩梦级，建议看看题目最后的补充。

但是代码很简单，暴力模拟即可。甚至不需要线段树就可以过，但要注意几个问题：

- 不能开 long long。
- 击败飞鱼丸后，飞鱼丸标记和嘤嘤值都要清空。
- 计算最大值时从右到左，严格大于，不能取等。并且最后别忘了用 ans 加上最大值。

```

#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
  int a[100005],b[100005]={0};
  int n,m,ans=0;
  cin>>n>>m;
  for(int i=1;i<=n;i++)cin>>a[i];
  while(m--)
  {
    int op;
    cin>>op;
    if(op==1)
    {
      int x,w;
      cin>>x>>w;
      a[x]=w-a[x];
      b[x]=1;
    }else if(op==2)
    {
      int flag=0,maxx=-0x7fffffff;
      int x,y;
      cin>>x>>y;
      for(int i=x;i<=y;i++)
      {
        if(b[i]==1)
        {
          ans+=a[i];
          cout<<a[i]<<endl;
          b[i]=0;//飞鱼丸死了
          a[i]=0;//取走了
          flag=1;
          break;//题目说了保证最多一个
        }
      }
      if(flag==0)
      {
        int bc=0;
        for(int i=y;i>=x;i--)//注意倒序
        {
          if(a[i]>maxx){//严格大于，不能取等，因为要求最右边的
            maxx=a[i];
            bc=i;
          }
        }
        ans+=a[bc];//别忘了
        a[bc]=0;//取走了
        cout<<maxx<<endl;
      }
    }else if(op==3){
      int x,y,w;
      cin>>x>>y>>w;
      for(int i=x;i<=y;i++)a[i]+=w;
    }
  }
  if(ans<10000)cout<<"QAQ";
	else if(ans>=10000&&ans<10000000)cout<<"Sakura";
	else cout<<"ice";
return 0;
}


```




---

## 作者：No_wonder (赞：0)

这道题目的确十分简单，正解应该是线段树，不过因为数据十分水的原因（int过了longlong过不了的题！），按照题意模拟也能过

其实用线段树无非也就维护一个区间最值，一个区间加和一个单点修改,都是很基础的操作。这里我带来模拟的做法。

因为本题完全不需要线段树，建议加强数据。

AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
int a[100010];
bool vis[100010];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	while(m--)
	{
		int flag;
		scanf("%d",&flag);
		if(flag==1)							//模拟单点修改 
		{
			int x,val;
			scanf("%d%d",&x,&val);
			a[x]=val-a[x];
			vis[x]=1;
		}
		if(flag==2)
		{
			int l,r,maxn=0,poi;				//模拟最大值查询 ，poi表示最大值或者飞鱼丸在的位置 
			scanf("%d%d",&l,&r);
			for(int i=r;i>=max(l,1);i--)		//按照题意，从后往前枚举 
			{
				if(vis[i])	{poi=i;vis[i]=0;maxn=a[i];break;}		//按照题意，优先对抗飞鱼丸。 
				if(maxn<a[i]){poi=i;maxn=a[i];}
			}
			a[poi]=0;
			ans+=maxn;
			printf("%d\n",maxn);
		}
		if(flag==3)								//按照题意区间加 
		{
			int l,r,w;
			scanf("%d%d%d",&l,&r,&w);
			for(int i=max(l,1);i<=r;i++)
			a[i]+=w;
		}
	}
	if(ans<10000)	printf("QAQ");				//按照题意输出 
	else if	(ans>=10000000)	printf("ice");
	else			printf("Sakura");
}
```


---

## 作者：RPChe_ (赞：0)

~~某在新年扩充中沉船的舰长终于成功AC了此题。~~

--------------------------------------

首先一看题目，跟嘤嘤嘤和飞鱼丸有关，那必须做。再读一读题，好像是一道很水的线段树，我们只需同时维护两个元素：区间最大值和其具体位置，再引入一个优先级即可。维护这两个元素很简单，这里不再赘述，而关于优先级，我们只需把绯狱丸所在的位置加上一个极大值，并打上标记，这样就可以保证先取到绯狱丸。每次取到区间最大值的时候，我们再检查一下它带不带标记，如果带则减去这个最大值再累加输出，否则直接累加输出就可以了。

需要注意的是题目给的计算顺序（从右开始），和数据类型必须声明成int，然后我们就可以得到这样一份代码——

```cpp
#include<iostream>
#include<cstdio>
#define maxn 5000005
#define inf 0x3f3f3f3f
#define rep(i,a,b) for(register int i=a;i<=b;i++)
using namespace std;

inline int read() {
	int f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}

void write(int x) {
	if(x<0) x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

int n,m,a[maxn],maxx[maxn],ans,tag[maxn],pos[maxn],vis[maxn];
int res,position;

void ADD(int k,int v) {
	if(tag[k]==-inf) tag[k]=v;
	else tag[k]+=v;
	maxx[k]+=v;
}

void pushdown(int k,int l,int r,int mid) {
	if(tag[k]==-inf) return;
	ADD(k*2,tag[k]);
	ADD(k*2+1,tag[k]);
	tag[k]=-inf;
}

void build(int k,int l,int r) {
	tag[k]=-inf;
	if(l==r) {
		maxx[k]=a[l];
		pos[k]=l;
		return;
	}
	int mid=(l+r)>>1;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	if(maxx[k*2]<=maxx[k*2+1]) {
		maxx[k]=maxx[k*2+1];
		pos[k]=pos[k*2+1];
	} else {
		maxx[k]=maxx[k*2];
		pos[k]=pos[k*2];
	}
}

void add(int k,int l,int r,int x,int y,int v) {
	if(x<=l&&r<=y) {
		ADD(k,v);
		return;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);
	if(x<=mid) add(k*2,l,mid,x,y,v);
	if(y>mid) add(k*2+1,mid+1,r,x,y,v);
	if(maxx[k*2]<=maxx[k*2+1]) {
		maxx[k]=maxx[k*2+1];
		pos[k]=pos[k*2+1];
	} else {
		maxx[k]=maxx[k*2];
		pos[k]=pos[k*2];
	}
}

void query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) {
		if(res<maxx[k]) {
			res=maxx[k];
			position=pos[k];
		} else if(res==maxx[k]&&position<pos[k]) position=pos[k]; 
		return;
	}
	int mid=(l+r)>>1;
	pushdown(k,l,r,mid);//注意基础操作（窝因此句忘打而调试1小时）
	if(x<=mid) query(k*2,l,mid,x,y);
	if(y>mid) query(k*2+1,mid+1,r,x,y);
}

int main() {
	n=read(),m=read();
	rep(i,1,n) a[i]=read();
	build(1,1,n);
	rep(i,1,m) {
		int t=read();
		if(t==1) {
			int x=read(),v=read();
			res=0;
			position=0;
			query(1,1,n,x,x);
			if(!vis[x])
			add(1,1,n,x,x,-2*res+v+inf);
			else add(1,1,n,x,x,-2*(res-inf)+v+inf);
			vis[x]=1;
		} else if(t==2) {
			int l=read(),r=read();
			res=0;
			position=0;
			query(1,1,n,l,r);
			if(vis[position]) {
				ans+=res-inf;
				write(res-inf),putchar('\n');
				add(1,1,n,position,position,-res);
				vis[position]=0;
			} else {
				ans+=res,write(res),putchar('\n');
				add(1,1,n,position,position,-res);
			}
		} else {
			int l=read(),r=read(),v=read();
			add(1,1,n,l,r,v);
		}
	}
	if(ans<1e4) cout<<"QAQ";
	else if(ans<=1e7) cout<<"Sakura";
	else cout<<"ice";
	return 0;
}
```

用时800ms，效率是很高的。（构思5分钟，写作20分钟，调试1小时）

但是我们可以更细心的读一读题，可以发现此题的数据范围是非常友好的（嘤嘤嘤太善良了），因此我们可以考虑暴力，这样就可以得到如下的代码：

```cpp
#include<iostream>
#include<cstdio>
#define maxn 5000005
#define inf 0x3f3f3f3f
#define rep(i,a,b) for(register int i=a;i<=b;i++)
using namespace std;

inline int read() {
	int f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}

void write(int x) {
	if(x<0) x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

int n,m,a[maxn],vis[maxn],ans;

int main() {
	n=read(),m=read();
	rep(i,1,n) a[i]=read();
	rep(i,1,m) {
		int t=read();
		if(t==1) {
			int x=read(),v=read();
			a[x]=v-a[x];
			vis[x]=1;
		} else if(t==2) {
			int l=read(),r=read(),res=-inf,pos;
			rep(i,l,r) {
				if(vis[i]) {
					if(res<=a[i]) {
						res=a[i];
						pos=i;
					}
				}
			}
			if(res!=-inf) {
				write(res),putchar('\n');
				vis[pos]=0;
				a[pos]=0;
				ans+=res;
				continue;
			}
			rep(i,l,r) {
				if(!vis[i]) {
					if(res<=a[i]) {
						res=a[i];
						pos=i;
					}
				}
			}
			write(res),putchar('\n');
			a[pos]=0;
			ans+=res;
		} else if(t==3) {
			int l=read(),r=read(),x=read();
			rep(i,l,r) {
				a[i]+=x;
			}
		}
	}
	if(ans<1e4) cout<<"QAQ";
	else if(ans<1e7) cout<<"Sakura";
	else cout<<"ice";
	return 0;
}
```

用时2.3s。~~（好像也不错）~~ 关于甚么倒序的问题，完全没有影响到啊。~~（可能是因为卡常卡得好）~~ 但是比起线段树，它们之间的差距还是很大的，数据一大暴力就当场暴毙，所以顺便请求加强数据。

-----------------------------

~~许愿冰刀、皮里上和女王~~



---


# [COCI 2011/2012 #1] SORT

## 题目描述

考虑如下的排序算法：

```
reverse-sort(sequence a)
    while (a is not in nondecreasing order)
        partition a into the minimum number of slopes
        for every slope with length greater than one
            reverse(slope)
```

定义 `slope` 为 `a` 的递减子串，`reverse()` 将翻转一段序列。

给定一个 $1$ ~ $N$ 的排列，保证在第一次划分时每个 `slope` 的长度都为偶数，求如果使用这种排序算法对给定的排列进行排序，需要调用多少次 `reverse(slope)`。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$2 \le N \le 10^5$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $140$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T5 SORT___。

## 样例 #1

### 输入

```
2
2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4
4 3 2 1```

### 输出

```
1```

## 样例 #3

### 输入

```
4
3 1 4 2```

### 输出

```
3```

# 题解

## 作者：BigSmall_En (赞：10)

## 前言

这题的题面太难读懂了，但是读懂了以后就会发现很简单。

## 题意理解

把 *English* 翻译成中文就是

```
给定一个需要排序的数组a[]
while(a不是一个排序好的序列){
	将a划分成多个连续的下降区间
	将所有这些区间(翻转)
}
```

要求统计翻转操作的次数。

**例如：**

```
1 2 6 5 4 3 8 7
```

划分完以后就是 `1 2|6 5 4 3|8 7`

每个"|"之间的区间就是下降的，一共有 $3$ 个区间

然后用 $3$ 次翻转操作就变成了 `1 2 3 4 5 6 7 8`

## 分析

为什么这样一直进行下去是可以完成排序的？

对于 `8 7 6 5 1 2 3 4` ，变成 `5 6 7 8 1 2 3 4` ，那么在区间 $[1,4]$ 和区间 $[5,8]$ 就是有序的了，同样可以想到对整个序列这样转之后序列就在一些范围上有序了。

由于题目要求划分后的序列**长度必须为偶数**，所以在有序区间 $[1,4]$ 内的数就不能划分，否则会划分成 `5|6|7|8` 、长度不为偶数

这样就会得到这样一个划分 `5 6 7|8 1|2 3 4`，**恰好在两个有序区间的交界处且这个新的划分区间长度为 $2$**

即使是翻转以后 `5 6 7 1 8 2 3 4`，也由于区间内元素的**有序性**只能划分为长度为2的新区间 `5 6|7 1|8 2|3 4`。

继续翻转之后也是这样的 `5 6 1 7 2 8 3 4`，也只能划分为长度为2的新区间。

这样就等价于只能选择相邻的元素交换了。也就等价去经典的求逆序对问题了。

## 题解

根据以上的分析可以得到这样的思路：先按照题意分组翻转一次。然后用树状数组或归并排序求逆序对就可以了。

### 代码：

```cpp
#include<cstdio>
using namespace std;
const int N=100005;
int n,a[N],c[N];long long ans;
void swap(int& x,int& y){x^=y;y^=x;x^=y;}//交换两个元素
void reverse(int l,int r){//翻转区间[l,r]内的元素
	for(int i=l;i<=r&&(i<<1)<l+r;++i)swap(a[i],a[r+l-i]);
	++ans;//顺便统计答案
}
int lowbit(int x){return x&-x;}//下面三行是经典的树状数组
void update(int i,int v){for(;i<=n;i+=lowbit(i))c[i]+=v;}
int getsum(int i){int ans=0;for(;i;i-=lowbit(i))ans+=c[i];return ans;}
int main(){
	scanf("%d",&n);
	int las=1;scanf("%d",&a[1]);//先将序列按要求翻转一次
	for(int i=2;i<=n;++i){
		scanf("%d",&a[i]);
		if(a[i]>a[i-1]){
			reverse(las,i-1);
			las=i;
		}
	}reverse(las,n);
	for(int i=n;i>=1;--i){//然后直接树状数组求逆序对正确性就可以保证了
		ans+=getsum(a[i]);
		update(a[i],1);
	}printf("%lld\n",ans);
	return 0;
}//	 94ms /  1.37MB /  705B C++98
```

---

## 作者：AFanOfKun (赞：1)

首先可以考虑模拟，时间复杂度为 $O(n^2)$，但在模拟中，我们发现可以优化。

我们可以发现，在每一次反转后，只有相邻两个`slope`的交点可能会发生翻转，接着再继续翻转相邻两个。

而翻转的次数就是逆序对的个数，可以用归并排序来求，时间复杂度为 $O(n \log{n})$，因此可以给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100001],t[100001],s=0;
void qsort(int l,int r){
	if(l==r) return ;
	int mid=(l+r)/2;
	qsort(l,mid);
    qsort(mid+1,r);
	int i=l,j=mid+1,tot=l-1;
	while(i<=mid&&j<=r){
		if(a[i]<=a[j])
			t[++tot]=a[i++];
		else if(a[i]>a[j])
			t[++tot]=a[j++],s+=(mid-i+1);
	}
	while(i<=mid) t[++tot]=a[i++];
	while(j<=r) t[++tot]=a[j++];
	for(int k=l;k<=r;k++) a[k]=t[k];
}
signed main(){
    cin.tie(nullptr)->sync_with_stdio(false);
    cin>>n;
    bool flag=true;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]<a[i-1]) flag=false;
    }
    if(flag){
        cout<<0;
        return 0;
    }
    int l=1;
    for(int i=2;i<=n;i++)
        if(a[i]>=a[i-1]){
            for(int k=l,j=i-1;k<j;k++,j--)
                swap(a[k],a[j]);
            if(l!=i-1) s++;
            l=i;
        }
    if(l!=n){
        for(int i=l,j=n;i<j;i++,j--)
            swap(a[i],a[j]);
        s++;
        if(l==1){
            cout<<1;
            return 0;
        }
    }//第一次反转
    qsort(1,n);//求逆序对
    cout<<s;
    return 0;
}
//Juruo.cpp
```

---

## 作者：_qumingnan_ (赞：1)

[题目跳楼机](https://www.luogu.com.cn/problem/P7629)

# 正文开始

## 阅读理解
有 $n$ 个数，从前往后扫，将每一个最长单调下降连续子序列翻转，扫到头后再从头开始扫，求翻转次数。

## 思路

这道题卡了我挺久的，原因就出在这一句话上：“保证在第一次划分时每个 `slope` 的长度都为偶数” 这一句话很关键，但我当时没看到。

那么这么一句不起眼的话有什么用呢？稍微模拟一下我们可以发现，有了这个条件的限制，那么在第一次翻转后，剩下的所有单调下降的连续子序列的长度要么为 $2$，要么为 $1$，这也就说明每一次翻转都是在交换相邻的两个数，那么就转化为了经典的求冒泡排序的交换次数，就可以直接用树状数组或者归并排序求逆序对的个数了。

## 代码

由于本蒟蒻不会树状数组，于是用的线段树代替。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[1000005],ans;
int t[1000005];
inline int ls(int p){return p<<1;}
inline int rs(int p){return p<<1|1;}
inline void push_up(int p){t[p]=t[ls(p)]+t[rs(p)];}
inline void update(int id,int p,int pl,int pr){
	if(pl==pr&&pl==id){t[p]++;return ;}
	int mid=pl+pr>>1;
	if(id<=mid)update(id,ls(p),pl,mid);
	else update(id,rs(p),mid+1,pr);
	push_up(p);
}
inline int query(int L,int R,int p,int pl,int pr){
	if(L>R)return 0;
	if(L<=pl&&pr<=R)return t[p];
	int mid=pl+pr>>1,res=0;
	if(L<=mid)res+=query(L,R,ls(p),pl,mid);
	if(R>mid)res+=query(L,R,rs(p),mid+1,pr);
	return res;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	a[n+1]=INT_MAX;
	int cnt=1;
	for(int i=2;i<=n+1;i++){//先按照题意模拟一次 
		if(a[i]>=a[i-1]){
			if(cnt>1){
				for(int j=i-cnt,k=i-1;j<k;j++,k--)swap(a[j],a[k]);
				ans++;
			}
			cnt=1;
		}
		else cnt++;
	}
	update(a[n],1,1,n);//预处理最后一个数 
	for(int i=n-1;i;i--){
		ans+=query(1,a[i]-1,1,1,n);//查找在  i 之后有多少个小于 a[i] 的数，计入贡献 
		update(a[i],1,1,n);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Ybll_ (赞：1)

# 前置芝士：

1. [逆序对](https://baike.baidu.com/item/%E9%80%86%E5%BA%8F%E5%AF%B9/11035554)；
2. [树状数组](https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739)。

# 思路：

很容易发现在第一轮翻转结束后，接下来的每一次翻转区间长度为 $2$，也就是两个相邻的数，这个时候就是一个类似冒泡排序的东西了，剩下的翻转次数就是冒泡排序的交换次数了，也就是当前序列中的逆序对个数。

众所周知，树状数组是可以求逆序对的，这题就做完了。

# 代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&-x
#define int long long
using namespace std;
int n,a[100000],ans,tree[100005];
void update(int x){while(x<=n)tree[x]++,x+=lowbit(x);}
int query(int x){
	int ans=0;
	while(x>0)ans+=tree[x],x-=lowbit(x);
	return ans;
}
signed main(){
	cin>>n;
	for(int i=0;i<n;i++)cin>>a[i];
	for(int i=0;i<n;i++){
		int j=i;
		while(a[i+1]<a[i]&&i<n-1)i++;
		if(i-j>0)ans++,reverse(a+j,a+i+1);
	}
	for(int i=n-1;i>=0;update(a[i]),i--)ans+=query(a[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：wendywan (赞：0)

# [题目：P7629 [COCI 2011/2012 #1] SORT](https://www.luogu.com.cn/problem/P7629)

## 题目大意：
~~懒得翻译原题目了，直接说题意吧。~~

给出一个 $1$ 到 $N$ 的排列（所以不需要考虑严格下降）$a$，每次调用 $\operatorname{reverse}$ 都可以将一段个数为偶数且大于 1 下降序列反转使得其变成升序。

问：需要进行多少次反转操作？

输入格式：
整数 $N$ 与 $N$ 个元素的乱序排列 $a$。

---

## 暴力：
直接模拟，每次搜到一段下降区间便反转它，$ans$ 记录次数。

~~很难写且显然不能过就不放代码了（实际上是我没写）。~~

---

## 正解：
此时的你想到，模拟一下样例观察一下。

我们看到样例 $3$：

```
4
3 1 4 2
```

假如第一次模拟的话，将 $3$ 和 $1$ 反转，$4$ 和 $2$ 反转。

得到 `1 3 2 4`。

此时一定是连续一段上升区间，接着一个逆序的数，再接一段上升区间。

这有点像……[逆序对](https://oi.wiki/basic/merge-sort/#%E9%80%86%E5%BA%8F%E5%AF%B9)！

不难想到，求出反转的次数就可以转化成求该序列的逆序对次数了。

因为做完第一次操作后，序列就会变得比较有序。

指倒序只会存在于**相邻的两个数**之间。

于是我们看向如何求逆序对。

不会可以看[这题](https://www.luogu.com.cn/problem/P1908)，这里简短提一下：

求逆序对可以使用**归并排序**或者**线段树（树状数组）**，这里使用简单好写的[归并排序](https://oi.wiki/basic/merge-sort/)实现。

简单提一下原理：

在归并排序并操作的时候，我们会用双指针比较两个序列头的大小，可以在此时处理出逆序对。

## Code

最终复杂度：$O( C \times N \times \log N ) $。

代码有注释，请放心食用。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e5 + 5;

int N, ans, tot;
// ans记录归并次数，tot记录模拟的次数
int a[MAXN], b[MAXN];//b为归并排序使用的数组

void gb( int l, int r ){
    if( l == r ) return ;//退出条件

    int mid = ( l + r ) / 2;
    gb( l, mid );
    gb( mid + 1, r );
    //否则分治地处理

    int L = l, R = mid + 1;//双指针
    for( int i = l; i <= r; i ++ ){//归并合并的操作
        if( R > r || ( L <= mid && a[L] <= a[R] )){
            b[i] = a[L];
            L ++;
        }
		else{
			b[i] = a[R];
			ans += mid - L + 1;//计算答案
			R ++;
		}
	}
    for( int i = l; i <= r; i ++ ) a[i] = b[i];
    //将排好序的数组赋给a
}

signed main(){
    cin >> N;
    int lst = 1;
    for( int i = 1; i <= N; i ++ ){
        cin >> a[i];
        if( a[i] > a[i - 1] && i != 1 ){// 如果不满足下降条件
            if( i - lst > 1 ) sort( a + lst, a + i ), tot ++;
            // 如果当前有序列开头
            lst = i;
        }
    }
    if( ( N - lst + 1 ) > 1 ) sort( a + lst, a + N + 1 );
    //最后一次还没扫就跳出循环了->所以要单独处理
    gb( 1, N );
    //归并排序求答案
    cout << tot + ans + 1 << endl;
    //最后相加求出答案
    return 0;
}
```

---

## 作者：wurang (赞：0)

数据范围 $n \le 10^5$，需要一个 $O(n \log n)$ 的算法。

按照提议模拟一次之后，所有连续的递减子序列长度均为 2。所以每个数之后只用跟后面比自己小的数交换就好了。

之后每次只会交换两个数，那么直接加上逆序对的个数就好了，这里用归并排序求解。



```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read(){int x = 0, f = 1;char ch = getchar();while (ch < '0' || ch > '9'){if (ch == '-') f = -1; ch = getchar();}while (ch >= '0' && ch <= '9'){x = x * 10 + ch - 48; ch = getchar();}return x * f;}

int sum, ans;
int maxx, pos;
int n, l = 1;
int a[100005], t[100005];

void qsort(int l, int r)
{
    if (l == r)
        return;
    int mid = (l + r) / 2;
    qsort(l, mid);
    qsort(mid + 1, r);
    int i = l, j = mid + 1, tot = l - 1;
    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j])
            t[++tot] = a[i++];
        else if (a[i] > a[j])
            t[++tot] = a[j++], ans += (mid - i + 1);  // 求逆序对
    }
    while (i <= mid)
        t[++tot] = a[i++];
    while (j <= r)
        t[++tot] = a[j++];
    for (int k = l; k <= r; k++)
        a[k] = t[k];
}

signed main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int i = 2; i <= n; i++)
    {
        if (a[i] > a[i - 1])
        {
            if (i - l == 1)
            {
                l = i;
                continue;
            }
            for (int r = i - 1; l <= r; l++, r--)
                swap(a[l], a[r]);
            l = i;
            ans++;
        }
    }
    if (l != n)
    {
        for (int r = n; l <= r; l++, r--)
            swap(a[l], a[r]);
        ans++;
    }
    qsort(1, n); // 归并排序
    cout << ans;
    return 0;
}
```

---

## 作者：LiveZoom (赞：0)

## sort

这题题意就是给定有 $n$ 个数的数组 $a$，每次将 $a$ 划分为多个连续的下降区间，将每个有至少两个数的区间翻转。问让 $a$ 排好序需要至少多少次翻转。

$O(n^2)$ 的做法很显然，就按题意模拟即可，考虑优化。

假设第一次数组 $a$ 划分成了 $[1,2,\dots,p_1],[p_1+1,p_1+2,\dots,p2],\dots,[p_{s-1}+1,p_{s-2}+1,...,p_s](p_s=n)$，那么做完第一次轮反转操作后，每一个区间都是按从小到大排好序的。那么做第二轮操作时，下降区间就只能跨越第一轮的相邻区间。比如说：```4 2 3 1```，第一轮为 ```4 2 | 3 1```，翻转之后变成了 ```2 4 | 1 3```，第二次下降区间只有 ```4 1```。然后有个显而易见的结论就是第二次以后的下降区间长度只能为 $2$。

那么问题就转换为了每次交换相邻的数，问排好序之后的最小交换次数。然后逆序对做就行了。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 1e5 + 5;

int n;
LL ans;
int a[N], cut[N];

class BIT {
  public:
    void upd (int x, int v) {
      for (; x <= n; x += x & -x)
        c[x] += v;
    }
    LL qry (int x) {
      LL ret = 0;
      for (; x; x -= x & -x)
        ret += c[x];
      return ret; 
    }
  private:
    LL c[N];
} t ;

bool check () {
  for (int i = 1; i <= n; ++i)
    if (a[i] != i) return false;
  return true;
}

void solve () {
  int cnt = 0;
  for (int i = 1; i <= n; ++i)
    if (a[i] < a[i + 1])
      cut[++cnt] = i;
  for (int i = 1; i <= cnt; ++i)
    if (cut[i] - cut[i - 1] != 1) {
      reverse(a + cut[i - 1] + 1, a + cut[i] + 1);
      ++ans;
    }
  for (int i = 1; i <= n; ++i) {
    ans += i - 1 - t.qry(a[i]);
    t.upd(a[i], 1);
  }
  cout << ans << endl;
}

int main() {
  // freopen("sort.in", "r", stdin);
  // freopen("sort.out", "w", stdout);
  cin >> n;
  for (int i = 1; i <= n; ++i)
    cin >> a[i];
  a[n + 1] = n + 1;
  solve();
  cerr << clock() * 1.0 / CLOCKS_PER_SEC << 's' << endl;
  return 0;
}
```

---

## 作者：404Not_Found (赞：0)

数据范围 $n \leq 10^5$, 直接按题意模拟的话必死无疑，看着很难搞啊。

再读一遍题，忽然发现了这句话： 保证在第一次划分时每个
slope 的长度都为偶数。slope 即为 连续递减子序列。

于是就很容易发现，模拟一次之后，**所有连续的递减子序列长度均为 $2$**。所以每个数之后只用跟后面比自己小的数交换就好了。这不就是求逆序对吗？

所以我们只要模拟一遍统计 reverse 调用的次数，再加上第一次操作后总的逆序对数即为答案。求逆序对可以用[树状数组](https://blog.csdn.net/bestsort/article/details/80796531)，复杂度是 $O(nlogn)$ 的。

最后，一定要开 `long long` 啊！

上代码，有略微卡常。
```cpp
#include<cstdio>
#include<cctype>
#define R register
using namespace std;
int n;
long long ans;//万恶之源 
int tree[100005],a[100005];
inline int read()
{
	R int x=0;R char c=getchar();
	for(;!isdigit(c);c=getchar()); 
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+c-48;
	return x;
}
inline void swap(int& a,int& b){int t=a;a=b;b=t;}
inline void add(int x){for(;x<=n;x+=(x&-x)) tree[x]++;}
inline int query(int x){int res=0;for(;x;x-=(x&-x)) res+=tree[x]; return res;}//树状数组基本操作 
inline void rev(int l,int r)
{
	for(R int i=l;i<=r&&(i<<1)<l+r;i++)
        swap(a[i],a[l+r-i]);
	ans++;//在这里交换的同时把答案也给统计了 
}
int main()
{
	n=read();
	for(R int i=1;i<=n;i++) a[i]=read();
	int last=1;
	for(R int i=2;i<=n;i++)
		if(a[i]>a[i-1]){rev(last,i-1);last=i;}
	rev(last,n);//记得处理剩下的 
	for(R int i=n;i;i--)
	{
		ans+=query(a[i]);
		add(a[i]);//树状数组求逆序对 
	}
	printf("%lld\n",ans);
	return 0;
}
```


---


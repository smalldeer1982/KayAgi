# [CSP-S 2022] 策略游戏

## 题目描述

小 L 和小 Q 在玩一个策略游戏。

有一个长度为 $n$ 的数组 $A$ 和一个长度为 $m$ 的数组 $B$，在此基础上定义一个大小为 $n \times m$ 的矩阵 $C$，满足 $C_{i j} = A_i \times B_j$。所有下标均从 $1$ 开始。

游戏一共会进行 $q$ 轮，在每一轮游戏中，会事先给出 $4$ 个参数 $l_1, r_1, l_2, r_2$，满足 $1 \le l_1 \le r_1 \le n$、$1 \le l_2 \le r_2 \le m$。

游戏中，小 L 先选择一个 $l_1 \sim r_1$ 之间的下标 $x$，然后小 Q 选择一个 $l_2 \sim r_2$ 之间的下标 $y$。定义这一轮游戏中二人的得分是 $C_{x y}$。

小 L 的目标是使得这个得分尽可能大，小 Q 的目标是使得这个得分尽可能小。同时两人都是足够聪明的玩家，每次都会采用最优的策略。

请问：按照二人的最优策略，每轮游戏的得分分别是多少？

## 说明/提示

**【样例解释 \#1】**

这组数据中，矩阵 $C$ 如下：

$$ \begin{bmatrix} 0 & 0 \\ -3 & 4 \\ 6 & -8 \end{bmatrix} $$

在第一轮游戏中，无论小 L 选取的是 $x = 2$ 还是 $x = 3$，小 Q 都有办法选择某个 $y$ 使得最终的得分为负数。因此小 L 选择 $x = 1$ 是最优的，因为这样得分一定为 $0$。

而在第二轮游戏中，由于小 L 可以选 $x = 2$，小 Q 只能选 $y = 2$，如此得分为 $4$。

**【样例 \#3】**

见附件中的 `game/game3.in` 与 `game/game3.ans`。

**【样例 \#4】**

见附件中的 `game/game4.in` 与 `game/game4.ans`。

**【数据范围】**

对于所有数据，$1 \le n, m, q \le {10}^5$，$-{10}^9 \le A_i, B_i \le {10}^9$。对于每轮游戏而言，$1 \le l_1 \le r_1 \le n$，$1 \le l_2 \le r_2 \le m$。

| 测试点编号 | $n, m, q \le$ | 特殊条件 |
|:-:|:-:|:-:|
| $1$ | $200$ | 1, 2 |
| $2$ | $200$ | 1 |
| $3$ | $200$ | 2 |
| $4 \sim 5$ | $200$ | 无 |
| $6$ | $1000$ | 1, 2 |
| $7 \sim 8$ | $1000$ | 1 |
| $9 \sim 10$ | $1000$ | 2 |
| $11 \sim 12$ | $1000$ | 无 |
| $13$ | ${10}^5$ | 1, 2 |
| $14 \sim 15$ | ${10}^5$ | 1 |
| $16 \sim 17$ | ${10}^5$ | 2 |
| $18 \sim 20$ | ${10}^5$ | 无 |

其中，特殊性质 1 为：保证 $A_i, B_i > 0$。  
特殊性质 2 为：保证对于每轮游戏而言，要么 $l_1 = r_1$，要么 $l_2 = r_2$。

## 样例 #1

### 输入

```
3 2 2
0 1 -2
-3 4
1 3 1 2
2 3 2 2
```

### 输出

```
0
4
```

## 样例 #2

### 输入

```
6 4 5
3 -1 -2 1 2 0
1 2 -1 -3
1 6 1 4
1 5 1 4
1 4 1 2
2 6 3 4
2 5 2 3
```

### 输出

```
0
-2
3
2
-1
```

# 题解

## 作者：dbxxx (赞：606)

[欢迎您在我的博客中阅读本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p8818.html)

本文中 A 和 B 分别代表小 L 和小 Q，而原题中的 $A$，$B$ 两个数组在本题中分别用 $a$ 和 $b$ 表示。

矩阵这个描述就是障眼法。翻译一下题目：

A 在 $a[l_1 \cdots r_1]$ 中选择一个 $x$，然后 B 在 $b[l_2 \cdots r_2]$ 中选择一个 $y$，分数是 $x \times y$，A 想让分数尽可能大，B 想让分数尽可能小。求分数。

肯定先思考 B 再思考 A，因为 A 会思考 B 的思考。

B 的行为就是对于 $x$，找到一个 $b[l_2 \cdots r_2]$ 中的 $y$，使得 $x \times y$ 最小。

具体地：

- $x \ge 0$ 时，B 会选择最小的 $y$；
- $x < 0$ 时，B 会选择最大的 $y$。

那么 A 的行为是什么呢？还是按照正负分类讨论：

如果 A 这次想让 $x \ge 0$，那么 B 会选择最小的 $y$。如果这个 $y \ge 0$，那么 A 一定会选最大的 $x$；如果这个 $y < 0$，那么 A 一定会选最小的非负数 $x$（别忘了当前制约条件 $x \ge 0$）。

如果 A 这次想让 $x < 0$，那么 B 会选择最大的 $y$。如果这个 $y \ge 0$，那么 A 一定会选最大的负数 $x$；如果这个 $y <0$，那么 A 一定会选最小的 $x$。

因此 A 的行为只有四种：选择最大的 $x$；最小的 $x$，最大的负数 $x$，最小的非负数 $x$。

分别讨论 A 选择四种行为时 B 的选择，答案取最大值即可。

然后就变成了静态区间最值的板子。使用 6 个 ST 表分别存储以下信息：

- $a$ 的区间最大值；
- $a$ 的区间最小值；
- $a$ 的负数区间最大值；
    - 具体是把所有满足 $a_i \ge 0$ 的 $a_i$ 全部替换为 $-\infty$ 代表这个位置不存在数，至于为何是 $-\infty$ 请读者自己思考。
- $a$ 的非负数区间最小值；
    - 具体是把所有满足 $a_i < 0$ 的 $a_i$ 全部替换为 $+\infty$ 代表这个位置不存在数。
- $b$ 的区间最大值；
- $b$ 的区间最小值。

时间复杂度 $\mathcal{O}(n\log n + q)$。


```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2022-10-30 22:49:26 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2022-10-30 23:15:25
 */
#include <bits/stdc++.h>
#define int long long
inline int read() {
    int x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}
inline int max(int a, int b) {
    return a > b ? a : b;
}
inline bool gmx(int &a, int b) {
    return b > a ? a = b, true : false;
}
inline int min(int a, int b) {
    return a < b ? a : b;
}

const int maxn = (int)1e5 + 5;
const int maxm = (int)1e5 + 5;
const int mlgn = 25;
const int mlgm = 25;

int amx[maxn][mlgn], amn[maxn][mlgn], afx[maxn][mlgn], azn[maxn][mlgn];
int bmx[maxm][mlgm], bmn[maxm][mlgm];

// 6 个 ST 表
// amx：a 的区间最大值，amn：a 的区间最小值，afx：a 的负数区间最大值，azn：a 的非负数区间最小值。
// bmx：b 的区间最大值，bmn：b 的区间最小值。

int lg[maxn];

const int maxinf = LONG_LONG_MAX, mininf = LONG_LONG_MIN;

signed main() {
    int n = read(), m = read(), q = read();
    for (int i = 1; i <= n; ++i) {
        int x = read();
        amx[i][0] = amn[i][0] = x;
        afx[i][0] = (x < 0 ? x : mininf);
        azn[i][0] = (x >= 0 ? x : maxinf);
    }

    for (int i = 1; i <= m; ++i) {
        int x = read();
        bmx[i][0] = bmn[i][0] = x;
    }

    for (int i = 2; i <= max(n, m); ++i)
        lg[i] = lg[i >> 1] + 1;

    for (int j = 1; j <= lg[n]; ++j) {
        for (int i = 1; i + (1 << j) - 1 <= n; ++i) {
            int p = i + (1 << (j - 1));
            amx[i][j] = max(amx[i][j - 1], amx[p][j - 1]);
            afx[i][j] = max(afx[i][j - 1], afx[p][j - 1]);
            amn[i][j] = min(amn[i][j - 1], amn[p][j - 1]);
            azn[i][j] = min(azn[i][j - 1], azn[p][j - 1]);
        }
    }

    for (int j = 1; j <= lg[m]; ++j) {
        for (int i = 1; i + (1 << j) - 1 <= m; ++i) {
            int p = i + (1 << (j - 1));
            bmx[i][j] = max(bmx[i][j - 1], bmx[p][j - 1]);
            bmn[i][j] = min(bmn[i][j - 1], bmn[p][j - 1]);
        }
    }

    while (q--) {
        int la = read(), ra = read(), lb = read(), rb = read();
        int sa = lg[ra - la + 1], sb = lg[rb - lb + 1];
        int pa = ra - (1 << sa) + 1, pb = rb - (1 << sb) + 1;

        int amax = max(amx[la][sa], amx[pa][sa]);
        int amin = min(amn[la][sa], amn[pa][sa]);
        int afmx = max(afx[la][sa], afx[pa][sa]);
        int azmn = min(azn[la][sa], azn[pa][sa]);
        int bmax = max(bmx[lb][sb], bmx[pb][sb]);
        int bmin = min(bmn[lb][sb], bmn[pb][sb]);

        int ans = mininf;

        gmx(ans, amax * (amax >= 0 ? bmin : bmax));
        gmx(ans, amin * (amin >= 0 ? bmin : bmax));
        if (afmx != mininf)
            gmx(ans, afmx * (afmx >= 0 ? bmin : bmax));
        if (azmn != maxinf)
            gmx(ans, azmn * (azmn >= 0 ? bmin : bmax));
        printf("%lld\n", ans);
    }
    return 0;
}
```

如果觉得这篇题解写得好，请不要忘记点赞，谢谢！

---

## 作者：novax (赞：71)

闲话：我是没有代码能力的小丑/dk。

考场思路，但赛时没写完。

### 题意

给定两个区间，先手在 $A$ 序列给定区间内选择一个数，后手在 $B$ 序列给定区间内选另一个数。两人所选数字乘积为得分。先手希望得分尽量大，后手希望得分尽量小。

### 部分分

#### 特殊性质一：“权值为正”

因为不存在相乘正负性改变的问题。由双方策略可知，先手必然选择区间内最大值，后手必然选择区间内最小值。因此使用线段树/ST表维护区间内最大值和最小值即可。

#### 特殊性质二：存在一方的操作区间长度为 $1$

若先手操作区间长度为 $1$，则有如下几种情况：

1. 先手必须选的数是 $0$，此时答案是 $0$。

2. 先手必须选的数是正数，此时后手策略为选择其区间内的最小数。

3. 先手必须选的数是负数，此时后手策略为选择其区间内的最大数。

后手同理：

1. 后手必须选的数是 $0$，此时答案是 $0$。

2. 后手必须选的数是正数，此时先手策略为选择其区间内的最大数。

3. 后手必须选的数是负数，此时后手策略为选择其区间内的最小数。

可以证明，按照上述规则选数可以达成两人的最优策略。

使用线段树/ST表维护区间最大值和最小值，按照上述规则讨论即可。

### 正解

此时双方的操作区间内都有多个数，其中双方的最优策略会使相乘的正负号改变。因此，我们应该按照双方操作区间内的正负数存在情况进行讨论。

我的做法将所有情况分为八类。以下的“最小”“最大”均指数本身的值而不是绝对值。

1. 后手无负数。

	1.1 若此时先手有正数，则先手应选择区间内最大的正数来使结果尽可能大。若后手有区间内 $0$，则后手应选择 $0$ 使得答案最小；否则他会选择区间内最小的正数。
   
   1.2 若此时先手无正数，则若先手有 $0$ 则一定会选择 $0$，否则相乘结果为负，他会选择区间内最大的负数来使相乘的结果尽量大。此时后手选择区间内最大的正数。
   
2. 后手无正数。

	2.1 若此时先手有负数，他一定会选择区间内最小的负数，负负得正来使结果最大化。后手区间如果有 $0$ 则一定优先选择 $0$，否则选择区间内最大的负数。
    
   2.2 若此时先手无负数，则结果必然不大于 $0$，先手区间若有 $0$ 则必定优先选 $0$，否则选择其区间内最小的正数；后手则选择其区间内的最小负数来最小化结果。
   
3. 后手既有正数又有负数

	3.1 先手有 $0$，则先手选 $0$。除 $0$ 以外，先手无论选什么，后手都有应对策略使结果为负。
    
   3.2 先手无正数。此时先手选择区间内最大的负数，而后手选择区间内最大的正数。
   
   3.3 先手无负数。此时先手选择区间内最小的正数，而后手选择区间内最小的负数。
   
   3.4 先手既有正数也有负数。此时先手可能如3.2中选择区间内最大的负数，也可能如3.3中选择区间内最小的正数。由于先手有优先决策的权力，所以他会会选择3.2和3.3两种结果中更大的那一个。即答案为 $\max(\text{先手最大负数}\times \text{后手最大正数},\text{先手最小正数}\times \text{后手最小负数})$。
   
自此，我们的八种情况就讨论完了。

另外以上还有一种情况没有考虑在内：后手操作区间内只有 $0$，此时答案一定为 $0$。程序中可以将这种情况并入到以上的情况中。

为进行以上的分类讨论，我们需要维护以下信息：区间最大/最小正数、区间最大/最小负数、区间是否有 $0$。使用线段树或ST表维护上述信息，按上述分类讨论即可。

假设 $n,m$ 同级，使用线段树的时间复杂度为 $O(n+q\log n)$，ST表的时间复杂度为 $O(n\log n +q)$。均可通过本题。

#### 代码

```cpp
#include <cstdio>
#define max(a,b) (((a)>(b))?(a):(b))
#define min(a,b) (((a)<(b))?(a):(b))
#define ls(p) ((p)<<1)
#define rs(p) (((p)<<1)|1)
const int Nx=100010;
int N,M,Q,A[Nx],B[Nx];
struct node{long long maz,miz,maf,mif,zro;};
node As[4*Nx],Bs[4*Nx];
void pushnode(node &a,int val)
{
	if(val==0)
		a.zro=1;
	else if(val>0)
		a.maz=a.miz=val;
	else if(val<0)
		a.maf=a.mif=val;
}
node merge(node x,node y)
{
	node ret;
	ret.zro=x.zro||y.zro;
	if(!x.maz||!y.maz)
	{
		ret.maz=x.maz+y.maz;
		ret.miz=x.miz+y.miz;
	}
	else
	{
		ret.maz=max(x.maz,y.maz);
		ret.miz=min(x.miz,y.miz);
	}
	if(!x.maf||!y.maf)
	{
		ret.maf=x.maf+y.maf;
		ret.mif=x.mif+y.mif;
	}
	else
	{
		ret.maf=max(x.maf,y.maf);
		ret.mif=min(x.mif,y.mif);
	}
	return ret;
}
void build(int ll,int rr,int p,node seg[],int C[])
{
	if(ll==rr)
	{
		pushnode(seg[p],C[ll]);
		return;
	}
	int mid=(ll+rr)>>1;
	build(ll,mid,ls(p),seg,C);
	build(mid+1,rr,rs(p),seg,C);
	seg[p]=merge(seg[ls(p)],seg[rs(p)]);
}
node query(int ll,int rr,int p,int L,int R,node seg[])
{
	if(L<=ll&&rr<=R)
		return seg[p];
	int mid=(ll+rr)>>1;
	if(L>mid)
		return query(mid+1,rr,rs(p),L,R,seg);
	if(R<=mid)
		return query(ll,mid,ls(p),L,R,seg);
	return merge(query(ll,mid,ls(p),L,R,seg),query(mid+1,rr,rs(p),L,R,seg));
}
long long get_ans(node ax,node bx)
{
	long long ret;
	//printf("%d %d %d %d %d   %d %d %d %d %d\n",ax.maz,ax.miz,ax.maf,ax.mif,ax.zro,bx.maz,bx.miz,bx.maf,bx.mif,bx.zro);
	if(bx.mif!=0&&bx.miz==0)//后手无正数
	{
		if(ax.mif!=0)//先手有负数
			ret=(bx.zro)?0:ax.mif*bx.maf;
		else//先手无负数
			ret=(ax.zro)?0:ax.miz*bx.mif;
	}
	else if(bx.mif==0&&bx.miz!=0)//后手无负数
	{
		if(ax.miz!=0)//先手有正数
			ret=(bx.zro)?0:ax.maz*bx.miz;
		else//先手无正数
			ret=(ax.zro)?0:ax.maf*bx.maz;
	}
	else//后手正负都有/后手只有0
	{
		if(ax.zro)
			ret=0;
		else if(ax.mif!=0&&ax.miz==0)//先手无正数
			ret=ax.maf*bx.maz;
		else if(ax.mif==0&&ax.miz!=0)//先手无负数
			ret=ax.miz*bx.mif;
		else//先手正负都有
			ret=max(ax.miz*bx.mif,ax.maf*bx.maz);
	}
	return ret;
}
int main()
{
	scanf("%d%d%d",&N,&M,&Q);
	int i,j,k,la,ra,lb,rb;
	for(i=1;i<=N;i++)
		scanf("%d",&A[i]);
	for(i=1;i<=M;i++)
		scanf("%d",&B[i]);
	build(1,N,1,As,A);
	build(1,M,1,Bs,B);
	node ax,bx;
	while(Q--)
	{
		scanf("%d%d%d%d",&la,&ra,&lb,&rb);
		ax=query(1,N,1,la,ra,As);
		bx=query(1,M,1,lb,rb,Bs);
		printf("%lld\n",get_ans(ax,bx));
	}
}
```


---

## 作者：yzy1 (赞：26)

### 题目大意

给定长度为 $n$（$1 \le n \le 10^5$）整数数组 $A$（$-10^9 \le A_i \le 10^9$）和长度为 $m$（$1 \le m \le 10^5$）整数数组 $B$（$-10^9 \le B_i \le 10^9$）．给出 $q$（$1 \le q \le 10^5$）次询问，每次询问给定整数 $l_1,r_1,r_2,r_2$（$1 \le l_1 \le r_1 \le n$，$1 \le l_2 \le r_2 \le m$），你需要求出：

$$
\max_{i=l_1}^{r_1} \min_{i=l_2}^{r_2} A_i \cdot B_j.
$$

### 简要做法

不难发现选出的 $A_i$ 与 $B_j$ 只会是以下四种情况中的一种：

- 最小非负数．
- 最大非负数．
- 最小非正数．
- 最大非正数．

证明平凡．

维护区间非负数与非正数 RMQ，依次枚举 $4\times 4 = 16$ 种情况检查即可．

若使用 Method of Four Russians 技巧维护区间 RMQ，则时间复杂度为 $O(n+m+q)$．


---

## 作者：Shunpower (赞：19)

## 前言

开场的时候看到这个题，内心：“【】，提高组考博弈论了？”

然而并不是，这就是个很愚蠢的贪心题。

## 思路

观察到题目又是矩阵又是什么的，实际上就是在 $A$ 里面选一个 $[l_1,r_1]$ 之间的数，$B$ 里面选一个 $[l_2,r_2]$ 之间的数，然后小 L 想要乘积最大，小 Q 想要乘积最小。

首先我们考虑 $O(qnm)$ 做法，也就是暴力枚举小 L 选的是什么数，虽然我们还不知道小 Q 的策略，但是很显然由于小 Q 总是尽量违背小 L 的意愿，所以答案即为在两人的每一种选数配对中的最大值，因为小 L 就是想让答案最大。

让我们考虑小 Q 的策略。当小 L 选正数的时候，小 Q 会尽量选择最小的数；当小 L 选负数的时候，小 Q 又会尽量选择最大的数；当小 L 选 $0$ 的时候，那无论如何都是 $0$。所以我们得到了一个 $O(qn\log m)$ 的做法，可以用线段树维护 $B$ 数组的区间 RMQ。

接下来再观察。当小 L 选负数的时候，由于小 Q 会选择最大的数，所以我们考虑当小 Q 选择负数和非负数时的情况。当小 Q 选择的最大值是负数的时候，唯一对答案有贡献的就是小 L 选择最小负数（此时乘积最大）；而小 Q 选择的最大值是非负数的时候，唯一对答案有贡献的就是小 L 选择最大负数（此时乘积最大）。

同理对正数进行分类讨论，可以得到以下结论：

- 小 L 选负数时，小 Q 的最大值是负数，小 L 选择最小负数。
- 小 L 选负数时，小 Q 的最大值是非负数，小 L 选择最大负数。
- 小 L 选正数时，小 Q 的最小值是负数，小 L 选择最小正数。
- 小 L 选正数时，小 Q 的最小值是非负数，小 L 选择最大正数。

那么考虑给小 L 也造一个线段树，维护最小正数，最大正数，最大负数，最小负数以及是否有 $0$ 即可。

虽然听起来很震撼，但是其实很好写。时间复杂度 $O(q(\log n+\log m))$


## 代码

下面是丑陋的赛时代码。

```
//Author: Zealous_YH in CSP-S2022
//Su Chanzi & Xiaobao
//Who AKs IOI and who not?
//Who loves a person and who breaks up?
//Who gets 1= and who not?
//I, can do my best now.
#include <bits/stdc++.h>
#define ET return 0
#define fr1(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define fr2(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)
#define ll long long
#define mp make_pair
#define il inline
#define pii pair<int,int>
#define fi first
#define se second
#define il inline
#define int ll
using namespace std;
const int N=1e5+10;
int n,m,q;
int a[N],b[N];
//int f1=0,f2=0;
int l1,r1,l2,r2;
#define mid ((l+r)>>1)
struct node{
	int maxf,minf,maxz,minz,cnt0;
};
struct Segment_Tree{
	int val[N<<2],minn[N<<2],maxn[N<<2],maxf[N<<2],minf[N<<2],maxz[N<<2],minz[N<<2],cnt0[N<<2];
	void pushup(int p){
		minn[p]=min(minn[p<<1],minn[p<<1|1]);
		maxn[p]=max(maxn[p<<1],maxn[p<<1|1]);
		maxf[p]=max(maxf[p<<1],maxf[p<<1|1]);
		minf[p]=min(minf[p<<1],minf[p<<1|1]);
		maxz[p]=max(maxz[p<<1],maxz[p<<1|1]);
		minz[p]=min(minz[p<<1],minz[p<<1|1]);
		cnt0[p]=cnt0[p<<1]+cnt0[p<<1|1];
	}//我把两个线段树搞一起了，所以要上传七个标记
	void merge(node &ans,node d){//区间查询时合并答案
		ans.cnt0+=d.cnt0;
		ans.maxf=max(ans.maxf,d.maxf);
		ans.minf=min(ans.minf,d.minf);
		ans.maxz=max(ans.maxz,d.maxz);
		ans.minz=min(ans.minz,d.minz);
	}
	il void build(int p,int l,int r){//建树
		maxf[p]=LONG_LONG_MIN;
		minf[p]=0;
		maxz[p]=0;
		cnt0[p]=0;
		minz[p]=LONG_LONG_MAX;//初始化
		if(l==r){
			minn[p]=maxn[p]=val[l];
			if(val[l]<0){
				maxf[p]=val[l];
				minf[p]=val[l];
			}
			else if(val[l]>0){
				maxz[p]=val[l];
				minz[p]=val[l];
			}
			else{
				cnt0[p]=1;
			}//赋初值
			return;
		}
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
		pushup(p);
	}
	il pii query(int p,int l,int r,int ml,int mr){//为小 Q 准备的区间最大值和最小值
		if(ml<=l&&r<=mr){
			return mp(minn[p],maxn[p]);
		}
		pii ans=mp(LONG_LONG_MAX,LONG_LONG_MIN);
		if(ml<=mid){
			pii d=query(p<<1,l,mid,ml,mr);
			ans.fi=min(ans.fi,d.fi);
			ans.se=max(ans.se,d.se);
		}
		if(mid<mr){
			pii d=query(p<<1|1,mid+1,r,ml,mr);
			ans.fi=min(ans.fi,d.fi);
			ans.se=max(ans.se,d.se);
		}
		return ans;
	}
	il node queryb(int p,int l,int r,int ml,int mr){//为小 L 准备的区间最大负数，最小负数等等
		if(ml<=l&&r<=mr){
			return {maxf[p],minf[p],maxz[p],minz[p],cnt0[p]};
		}
		node ans={LONG_LONG_MIN,0,0,LONG_LONG_MAX,0};
		if(ml<=mid){
			node d=queryb(p<<1,l,mid,ml,mr);
			merge(ans,d);
		}
		if(mid<mr){
			node d=queryb(p<<1|1,mid+1,r,ml,mr);
			merge(ans,d);
		}
		return ans;
	}
} T1,T2;
#undef mid
void solve2(){
//	int d1[N];
	while(q--){
		int ans=LONG_LONG_MIN; 
		cin>>l1>>r1>>l2>>r2;
		node d=T1.queryb(1,1,n,l1,r1);
		int x=T2.query(1,1,m,l2,r2).fi;
		int y=T2.query(1,1,m,l2,r2).se;
		if(d.cnt0!=0){//如果有 0 那答案至少都是 0
			ans=0;
		}
		if(y>0&&d.minf!=0){
			ans=max(ans,y*d.maxf);
		}
		if(y<=0&&d.maxf!=LONG_LONG_MIN){
			ans=max(ans,y*d.minf);
		}
		if(x<=0&&d.minz!=LONG_LONG_MAX){
			ans=max(ans,x*d.minz);
		}
		if(x>0&&d.maxz!=0){
			ans=max(ans,x*d.maxz);
		}//分类讨论
//		cout<<d.cnt0<<","<<d.maxf<<","<<d.minf<<","<<d.maxz<<","<<d.minz<<endl;
		cout<<ans<<'\n';//警惕卡常，不要 endl
	}
}
signed main(){
// 	freopen("game.in","r",stdin);
// 	freopen("game.out","w",stdout);
	ios::sync_with_stdio(false);
	cin>>n>>m>>q;
	fr1(i,1,n){
		cin>>a[i];
		T1.val[i]=a[i];
	}
	fr1(i,1,m){
		cin>>b[i];
		T2.val[i]=b[i];
	}
	T1.build(1,1,n);
	T2.build(1,1,m);
	solve2();//本来是写的特殊性质，结果推出了正解
	ET;
}
//RP++
//Don't FST.
/*
10 10 1
1 2 3 4 5 6 7 8 9 10
2 3 4 5 6 7 1 2 3 7
2 4 3 6
*/
```

于是就可以愉快的 AC 了。这份代码非常好调。

---

## 作者：Mobius127 (赞：18)

[link](https://www.luogu.com.cn/problem/P8818)

历年来最简单的 T2。

我们直接暴力分讨：

首先不考虑 $0$。

1. A 区间全为正数

	(1) B 区间全为正数，A 取最大， B 取最小
    
	(2) B 区间有正有负，A 取最小，B 取最小
    
	(3) B 区间全为负数，A 取最小，B 取最小
    
2. A 区间有正有负

	(1) B 区间全为正数，A 取最大，B 取最小
    
	(2) B 区间有正有负，$\max$(A 正数最小 $\times$ B 负数最小，A 负数最大 $\times$ B 正数最大)
    
	(3) B 区间全为负数，A 取最小，B 取最大
    
3. A 区间全为负数

	(1) B 区间全为正数，A 取最大，B 取最大
    
	(2) B 区间有正有负，A 取最大，B 取最大 
    
	(3) B 区间全为负数，A 取最小，B 取最大

上面这部分是经典的 RMQ 问题，使用线段树/ST 表解决均可。

回头来看比较特殊的 $0$：

若 A 存在 $0$，答案对 $0$ 取 $\max$。

若 B 存在 $0$，答案对 $0$ 取 $\min$。

然后就做完了。

复杂度 $O(n\log n)$。

[code](http://119.27.163.117/submission/25929)

---

## 作者：Dregen_Yor (赞：13)


### [更好的阅读体验](https://dregen-yor.eu.org/index.php/2022/11/01/csp-s-2022-b/)。

### [题目链接](https://www.luogu.com.cn/problem/P8818)。


# 思路

题目中重要条件：

>**小 L 的目标是使得这个得分尽可能大，小 Q 的目标是使得这个得分尽可能小。同时两人都是足够聪明的玩家，每次都会采用最优的策略。**

也就是说，小 L 掌握主动权，小 L 选择后小 Q 才会从中选择一个数，使 $C_{xy}$ 尽可能的小，小 L 会从所有可能的 $C_{xy}$ 中选择最大的哪一个。

我们模拟一下都会出现哪些情况。

- 小 L 和小 Q 都只能选择正整数，此时小 L 会选择最大的正整数，小 Q 会选择最小的正整数。

- 小 L 和小 Q 都只能选择负数，此时小 L 会选择最小的负数，小 Q 会选择最大的负数。

- 小 L 只能选择正整数，小 Q 既能选择正数又能选择负数，此时小 L 会选择最小的正整数，小 Q 会选择最小的负数。

- 小 L 只能选择负数，小 Q 既能选择正数又能选择负数，此时小 L 会选择最大的负数，小 Q 会选择最大的正整数。

- 小 L 既能选择正数又能选择负数，小 Q 只能选择正数，此时小 L 会选择最大的正数，小 Q 会选择最小的正数。

- 小 L 既能选择正数又能选择负数，小 Q 只能选择负数，此时小 L 会选择最小的负数，小 Q 会选择最大的负数。

- 小 L 既能选择正数又能选择负数，小 Q 也既能选择正数又能选择负数，此时答案会出现不同情况。当小 L 选择正整数时，小 Q 会选择最小的负数；当小 L 选择负数时，小 Q 会选择最大的正数。这种情况下，无论如何选择，结果一定是负数，我们要想让这个负数尽可能地大，那么小 L 在选择数的时候一定要选择绝对值相对较小的数，即小 L 应选择正数中的最小值或负数中的最大值，此时小 Q 选择的数分别为最小的负数与最大的正数，取两种情况的最大值即可。

通过上面的分析，我们发现前 $6$ 种情况都是从两边的最大值和最小值中获得的，只有最后一种情况涉及到了序列 $a_i$ 的正数中的最小值和负数中的最大值。

我们在统计答案的时候只需要从两种极值的选择中取最小值最大的情况，然后判断是否存在第 $7$ 中情况，取最大值即可。

至于两个序列的极值的查询，由于不涉及到修改操作，我们可以用 ST 表来维护两个序列的信息。

ST 表预处理复杂度为 $\mathcal O(n\log n+m\log m)$，ST 表查询复杂度为 $\mathcal O(1)$，总共 $q$ 次查询，所以总时间复杂度为 $\mathcal O(n\log n+m\log m +q)$。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#include<cstdio>
using namespace std;
int n,m,q,a[100010],b[100010];
struct re{
    __int128 a,b,c,d;
};
struct nod{
    __int128 ST1[100010][20],ST2[100010][20],ST3[100010][20],ST4[100010][20];
    void bulid(int *p,int len){
        for(int i=1;i<=len;i++){
            ST1[i][0]=p[i];
            if(p[i]>=0){
                ST2[i][0]=p[i];
            }
            else{
                ST2[i][0]=2e9;
            }
            ST3[i][0]=p[i];
            if(p[i]>0){
                ST4[i][0]=-2e9;
            }
            else{
                ST4[i][0]=p[i];
            }
        }
        for(int j=1;j<=log2(len);j++){
            for(int i=1;i<=len-(1<<j)+1;i++){
                ST1[i][j]=min(ST1[i][j-1],ST1[i+(1<<(j-1))][j-1]);
                ST2[i][j]=min(ST2[i][j-1],ST2[i+(1<<(j-1))][j-1]);
                ST3[i][j]=max(ST3[i][j-1],ST3[i+(1<<(j-1))][j-1]);
                ST4[i][j]=max(ST4[i][j-1],ST4[i+(1<<(j-1))][j-1]);
            }
        }
    }
    re query(int l,int r){
        int len=r-l+1;
        int p=log2(len);
        int a=min(ST1[l][p],ST1[r-(1<<p)+1][p]);
        int b=min(ST2[l][p],ST2[r-(1<<p)+1][p]);
        int c=max(ST3[l][p],ST3[r-(1<<p)+1][p]);
        int d=max(ST4[l][p],ST4[r-(1<<p)+1][p]);
        return re{a,b,c,d};
    }
}ST1,ST2;
signed main(){
    // freopen("game.in","r",stdin);
    // freopen("game.out","w",stdout);
    scanf("%lld%lld%lld",&n,&m,&q);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    for(int i=1;i<=m;i++){
        scanf("%lld",&b[i]);
    }
    ST1.bulid(a,n);
    ST2.bulid(b,m);
    while(q--){
        int l1,r1,l2,r2;
        scanf("%lld%lld%lld%lld",&l1,&r1,&l2,&r2);
        re tmp1=ST1.query(l1,r1);
        re tmp2=ST2.query(l2,r2);
        int ans=max(min(tmp1.c*tmp2.a,tmp1.c*tmp2.c),min(tmp1.a*tmp2.c,tmp1.a*tmp2.a));
        if(tmp1.b<1e9){
            ans=max(ans,(int)tmp1.b*(int)tmp2.a);
        }
        if(tmp1.d>-1e9){
            ans=max(ans,(int)tmp1.d*(int)tmp2.c);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```


---

## 作者：yukimianyan (赞：9)

## problem
长度为 $n$ 的数组 $a$，长度为 $m$ 的数组 $b$。$q$ 次博弈，每次博弈给出 $[l_1,r_1],[l_2,r_2]$，Alice 可以选择一个 $i\in[l_1,r_1]$，Bob **在看到 Alice 的选择后**可以选择一个 $j\in[l_2,r_2]$，最终游戏的得分为 $a_ib_j$。Alice 希望得分尽可能大，Bob 希望得分尽可能小，在他们都绝顶聪明的情况下，每次游戏的得分各是多少？

## solution
我会暴力！枚举 Alice 和 Bob 选的数，那么答案是这个东西：

$$[*]=\max_i\{\min_j a_ib_j\}.$$

考虑优化它。假如我们有 $0<x<y<z$，如果 $y$ 是一种决策，那么显然 $x,z$ 其中之一会优于 $y$，那么 $y$ 就没用了。负数也是一样的。综上，真正有用的决策只有 $\min,\max_{x<0}x,0,\min_{x>0}x,\max$，其它一定不会成为最优决策。

这五个值显然可以 RMQ，而枚举部分的复杂度也降为常数，于是直接暴力就可以了。

## code
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
int lg[100010];
template<int N,int D=1,class T=LL> struct STable{
	T f[21][N+10]; int cnt;
	STable():cnt(0){}
	void insert(T x){
		f[0][++cnt]=x*D;
		for(int j=1;1<<j<=cnt;j++){
			int i=cnt-(1<<j)+1;
			f[j][i]=min(f[j-1][i],f[j-1][i+(1<<(j-1))]);
		}
	}
	T query(int l,int r){
		int k=lg[r-l+1];
		return min(f[k][l],f[k][r-(1<<k)+1])*D;
	}
};
int n,m,q,sa[100010],sb[100010];
LL a[100010],b[100010];
STable<100010,1> tmin[4];
STable<100010,-1> tmax[4];
int main(){
	//freopen("game.in","r",stdin),freopen("game.out","w",stdout);
	lg[0]=-1; for(int i=1;i<=1e5;i++) lg[i]=lg[i>>1]+1;
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sa[i]=sa[i-1]+!a[i];
		tmin[0].insert(a[i]<0?a[i]:1e18);
		tmin[1].insert(a[i]>0?a[i]:1e18);
		tmax[0].insert(a[i]<0?a[i]:-1e18);
		tmax[1].insert(a[i]>0?a[i]:-1e18);
	}
	for(int i=1;i<=m;i++){
		scanf("%lld",&b[i]);
		sb[i]=sb[i-1]+!b[i];
		tmin[2].insert(b[i]<0?b[i]:1e18);
		tmin[3].insert(b[i]>0?b[i]:1e18);
		tmax[2].insert(b[i]<0?b[i]:-1e18);
		tmax[3].insert(b[i]>0?b[i]:-1e18);
	}
	for(int l,r;q--;){
		scanf("%d%d",&l,&r);
		LL pa[]={tmin[0].query(l,r),tmax[0].query(l,r),sa[r]-sa[l-1]?0:(LL)1e18,tmin[1].query(l,r),tmax[1].query(l,r)};
		scanf("%d%d",&l,&r);
		LL pb[]={tmin[2].query(l,r),tmax[2].query(l,r),sb[r]-sb[l-1]?0:(LL)1e18,tmin[3].query(l,r),tmax[3].query(l,r)};
		LL ans=-1e18;
		for(int i=0;i<5;i++){
			if(pa[i]==1e18||pa[i]==-1e18) continue;
			LL res=1e18;
			for(int j=0;j<5;j++){
				if(pb[j]==1e18||pb[j]==-1e18) continue;
				res=min(res,pa[i]*pb[j]);
			}
			ans=max(ans,res);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：donghanwen1225 (赞：7)

为了叙述方便，以下认为 $0$ 是正数。

------------

首先我们发现矩阵 $C$ 实际没有用处：每一轮的得分 $C_{xy}$ 即为 $A_xB_y$，因此可以直接考虑分析序列 $A,B$。

我们先考虑一个简化的问题：如果序列中全为正数该如何做？

此时，小 L 为使结果最大，他会选择序列 $A$ 中最大的数；同理，小 Q 会选择序列 $B$ 中最小的数。两者相乘即得结果。

下面我们把负数加入考虑。负数对结果的影响是结果可能为负，导致得分的**绝对值大**时反而变小。

那么我们可以分以下情况讨论：

1. 序列 $A$ 全正。

若序列 $B$ 全正，那么取序列 $A$ 的正数中的最大值、序列 $B$ 的正数中的最小值即可；

若序列 $B$ 有正有负（或全负），那么取序列 $A$ 的正数中的最小值、序列 $B$ 的负数中**绝对值**（以下不再强调）最大的值（即实际上的最小值）即可。

2. 序列 $A$ 全负。

若序列 $B$ 全负，那么取序列 $A$ 的负数中绝对值最大的值、序列 $B$ 的负数中绝对值最小的值即可；

若序列 $B$ 有正有负（或全正），那么取序列 $A$ 的负数中绝对值最小的值、序列 $B$ 的正数中的最大值即可。

3. 序列 $A$ 有正有负。

若序列 $B$ 全正，则与序列 $A,B$ 全正相同；

若序列 $B$ 全负，则与序列 $A,B$ 全负相同；

若序列 $B$ 也有正有负，则需要考虑序列 $A$ 的正数中的最小值、序列 $B$ 的负数中绝对值最大的值，和序列 $A$ 的负数中绝对值最小的值、序列 $B$ 的正数中的最大值，在两种情况中选出更大的那一个。

综上，我们只要分别维护两个序列正数的最大、最小值，和负数的绝对值的最大、最小值（一共维护 $8$ 个信息）即可。由于是静态区间可用 ST 表解决区间极值。

最终的时空复杂度均为 $O(n\log n)$，带一个 $8$ 的常数。

code :

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int inf=1<<30;
typedef long long ll;
ll a[100005],b[100005];int n,m,q,l1,r1,l2,r2,sa[100005],sb[100005],lg2[100005];
struct ST
{
	ll st[100005][17];
	int tp1,tp2;
	ll query(int l,int r)
	{
		int k=lg2[r-l+1];
		if(tp1==1) return min(st[l][k],st[r-(1<<k)+1][k]);
		if(tp1==2) return max(st[l][k],st[r-(1<<k)+1][k]);
	}
	void build(int n,ll *f)
	{
		for(int i=1;i<=n;i++)
		{
			if(tp2==1) st[i][0]=(f[i]>=0?f[i]:(tp1==1?inf:-inf));
			if(tp2==2) st[i][0]=(f[i]<0?-f[i]:(tp1==1?inf:-inf));
		}
		for(int i=1;i<=16;i++)
			for(int j=1;j+(1<<i)-1<=n;j++)
			{
				if(tp1==1) st[j][i]=min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
				if(tp1==2) st[j][i]=max(st[j][i-1],st[j+(1<<(i-1))][i-1]);
			}
	}
} mxa1,mna1,mxa2,mna2,mxb1,mnb1,mxb2,mnb2;
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=m;i++) scanf("%lld",&b[i]);
	for(int i=1;i<=n;i++) sa[i]=sa[i-1]+(a[i]<0);
	for(int i=1;i<=m;i++) sb[i]=sb[i-1]+(b[i]<0);
	for(int i=2;i<=100000;i++) lg2[i]=lg2[i/2]+1;
	mxa1.tp1=2;mxa1.tp2=1;mxa1.build(n,a);
	mxa2.tp1=2;mxa2.tp2=2;mxa2.build(n,a);
	mna1.tp1=1;mna1.tp2=1;mna1.build(n,a);
	mna2.tp1=1;mna2.tp2=2;mna2.build(n,a);
	mxb1.tp1=2;mxb1.tp2=1;mxb1.build(m,b);
	mxb2.tp1=2;mxb2.tp2=2;mxb2.build(m,b);
	mnb1.tp1=1;mnb1.tp2=1;mnb1.build(m,b);
	mnb2.tp1=1;mnb2.tp2=2;mnb2.build(m,b);
	while(q--)
	{
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		int fa1=0,fa2=0,fb1=0,fb2=0;
		if(sa[r1]-sa[l1-1]==r1-l1+1) fa1=1;
		if(sa[r1]-sa[l1-1]==0) fa2=1;
		if(sb[r2]-sb[l2-1]==r2-l2+1) fb1=1;
		if(sb[r2]-sb[l2-1]==0) fb2=1;
		ll amx1,amx2,amn1,amn2,bmx1,bmx2,bmn1,bmn2;
		amx1=mxa1.query(l1,r1);
		amx2=-mxa2.query(l1,r1);
		amn1=mna1.query(l1,r1);
		amn2=-mna2.query(l1,r1);
		bmx1=mxb1.query(l2,r2);
		bmx2=-mxb2.query(l2,r2);
		bmn1=mnb1.query(l2,r2);
		bmn2=-mnb2.query(l2,r2);
		if(fa1)
		{
			if(fb1) printf("%lld\n",amx2*bmn2);
			else printf("%lld\n",amn2*bmx1);
		}
		else if(fa2)
		{
			if(fb2) printf("%lld\n",amx1*bmn1);
			else printf("%lld\n",amn1*bmx2);
		}
		else
		{
			if(fb1) printf("%lld\n",amx2*bmn2);
			else if(fb2) printf("%lld\n",amx1*bmn1);
			else printf("%lld\n",max(amn1*bmx2,amn2*bmx1));
		}
	}
	return 0;
}
```

---

## 作者：Leasier (赞：4)

前置芝士：[ST 表](https://oi-wiki.org/ds/sparse-table/)

首先显然要分小 L 选了正 / $0$ / 负讨论两人的策略。

1. 小 L 选正数

若 $[l_2, r_2]$ 中有负数，小 L 肯定要选绝对值最小的正数，小 Q 肯定要选绝对值最大的负数。

若 $[l_2, r_2]$ 中没有负数，小 L 肯定要选最大的正数，小 Q 肯定要选绝对值最小的非负数。

2. 小 L 选 $0$

此时答案恒为 $0$。

3. 小 L 选负数

若 $[l_2, r_2]$ 中有正数，小 L 肯定要选绝对值最小的负数，小 Q 肯定要选绝对值最大的正数。

若 $[l_2, r_2]$ 中没有正数，小 L 肯定要选最小的负数，小 Q 肯定要选绝对值最小的非正数。

ST 表维护上述所有 RMQ 即可。时间复杂度为 $O(n \log n + m \log m + q)$。

代码：
```cpp
#include <stdio.h>
#include <math.h>

typedef long long ll;

inline int min(int a, int b){
	return a < b ? a : b;
}

inline int max(int a, int b){
	return a > b ? a : b;
}

typedef struct {
	int st_min[100007][17], st_max[100007][17], st_neg_abs_min[100007][17], st_non_pos_min[100007][17], st_non_neg_min[100007][17], st_pos_min[100007][17];
	
	inline void init(int n, int a[]){
		int m = log2(n);
		for (register int i = 1; i <= n; i++){
			st_min[i][0] = st_max[i][0] = a[i];
			st_neg_abs_min[i][0] = a[i] < 0 ? a[i] : 0x80000000;
			st_non_pos_min[i][0] = a[i] <= 0 ? a[i] : 0x80000000;
			st_non_neg_min[i][0] = a[i] >= 0 ? a[i] : 0x7fffffff;
			st_pos_min[i][0] = a[i] > 0 ? a[i] : 0x7fffffff;
		}
		for (register int i = 1; i <= m; i++){
			int id = i - 1, t1 = n - (1 << i) + 1, t2 = 1 << id;
			for (register int j = 1; j <= t1; j++){
				int t3 = j + t2;
				st_min[j][i] = min(st_min[j][id], st_min[t3][id]);
				st_max[j][i] = max(st_max[j][id], st_max[t3][id]);
				st_neg_abs_min[j][i] = max(st_neg_abs_min[j][id], st_neg_abs_min[t3][id]);
				st_non_pos_min[j][i] = max(st_non_pos_min[j][id], st_non_pos_min[t3][id]);
				st_non_neg_min[j][i] = min(st_non_neg_min[j][id], st_non_neg_min[t3][id]);
				st_pos_min[j][i] = min(st_pos_min[j][id], st_pos_min[t3][id]);
			}
		}
	}
	
	inline int get_min(int l, int r){
		int t = log2(r - l + 1);
		return min(st_min[l][t], st_min[r - (1 << t) + 1][t]);
	}
	
	inline int get_non_pos_min(int l, int r){
		int t = log2(r - l + 1);
		return max(st_non_pos_min[l][t], st_non_pos_min[r - (1 << t) + 1][t]);
	}
	
	inline int get_neg_abs_min(int l, int r){
		int t = log2(r - l + 1);
		return max(st_neg_abs_min[l][t], st_neg_abs_min[r - (1 << t) + 1][t]);
	}
	
	inline int get_max(int l, int r){
		int t = log2(r - l + 1);
		return max(st_max[l][t], st_max[r - (1 << t) + 1][t]);
	}
	
	inline int get_non_neg_min(int l, int r){
		int t = log2(r - l + 1);
		return min(st_non_neg_min[l][t], st_non_neg_min[r - (1 << t) + 1][t]);
	}
	
	inline int get_pos_min(int l, int r){
		int t = log2(r - l + 1);
		return min(st_pos_min[l][t], st_pos_min[r - (1 << t) + 1][t]);
	}
} ST;

ST st1, st2;
int a[100007], posa[100007], zeroa[100007], nega[100007], b[100007], posb[100007], zerob[100007], negb[100007];

inline ll max(ll a, ll b){
	return a > b ? a : b;
}

int main(){
	int n, m, q;
	scanf("%d %d %d", &n, &m, &q);
	for (register int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		nega[i] = nega[i - 1] + (a[i] < 0 ? 1 : 0);
		zeroa[i] = zeroa[i - 1] + (a[i] == 0 ? 1 : 0);
		posa[i] = posa[i - 1] + (a[i] > 0 ? 1 : 0);
	}
	for (register int i = 1; i <= m; i++){
		scanf("%d", &b[i]);
		negb[i] = negb[i - 1] + (b[i] < 0 ? 1 : 0);
		zerob[i] = zerob[i - 1] + (b[i] == 0 ? 1 : 0);
		posb[i] = posb[i - 1] + (b[i] > 0 ? 1 : 0);
	}
	st1.init(n, a);
	st2.init(m, b);
	for (register int i = 1; i <= q; i++){
		int l1, r1, l2, r2;
		ll ans = 0x8000000000000000ll;
		scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
		if (nega[r1] - nega[l1 - 1] > 0){
			int x, y;
			if (posb[r2] - posb[l2 - 1] == 0){
				x = st1.get_min(l1, r1);
				y = st2.get_non_pos_min(l2, r2);
			} else {
				x = st1.get_neg_abs_min(l1, r1);
				y = st2.get_max(l2, r2);
			}
			ans = (ll)x * y;
		}
		if (zeroa[r1] - zeroa[l1 - 1] > 0 && ans < 0) ans = 0;
		if (posa[r1] - posa[l1 - 1] > 0){
			int x, y;
			if (negb[r2] - negb[l2 - 1] == 0){
				x = st1.get_max(l1, r1);
				y = st2.get_non_neg_min(l2, r2);
			} else {
				x = st1.get_pos_min(l1, r1);
				y = st2.get_min(l2, r2);
			}
			ans = max(ans, (ll)x * y);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：rainygame (赞：4)

> 出题人最大的错误，就是把 $n,m$ 和 $q$ 只开到 $10^5$。

原题的 $A,B$ 在这里用 $a,b$ 表示。

## 题意

A 从 $a$ 的 $[l_1,r_1]$ 中选取一个数 $x$，B 从 $b$ 的 $[l_2,r_2]$ 中选取一个数 $y$。分数即为 $xy$。A 希望分数最大，B 希望分数最小。求实际分数。

## 题解（第一部分）

因为 A 的行为会影响 B 的行为，所以先考虑 B 的做法。不过就两种：

- $x \ge 0$，此时 B 选择区间最小值。
- $x < 0$，此时 B 选择区间最大值。

那么 A 会有什么行为呢？分类讨论：

- 如果 A 想让 $x \ge 0$，那么 B 一定会选择区间最小 $y$。
  - 如果 $y \ge 0$，那么 A 一定会选择区间最大值。
  - 如果 $y < 0$，那么 A 一定会选择区间非负数最小值。（还有 $x \ge 0$ 这个制约）
- 如果 A 想让 $x < 0$，那么 B 一定会选择区间最大 $y$。
  - 如果 $y \ge 0$，那么 A 一定会选择区间负数最大值。（还有 $x < 0$ 这个制约）
  - 如果 $y < 0$，那么 A 一定会选择区间最小值。
  
分别讨论 A 的四种行为的 B 的行为，取最大值即可。（因为是 A 先手）

所以，这就变成了一个区间求最大最小值的板子。

## 题解（第二部分）

看到题解区里有线段树的、有 ST 表的，我这里使用分块来维护区间最大、最小值。

分块，其实就是把一段数据分成 $B$ 块，然后对于每一次查询，暴力查询第一块和最后一块的最大/最小值；然后再枚举中间的块，求出中间每个块的最大/最小值并更新答案。（每个块的最大/最小值可以通过预处理得到）

每次的查询复杂度为 $O(\frac{n}{B}+B)$。根据均值不等式，当 $B=\sqrt n$ 的时候复杂度最优，为 $O(\sqrt n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100001
#define int long long

int n, m, q, l_1, r_1, l_2, r_2;
int ans, ans1, ans2, ans3, ans4, ans5, ans6;

struct Block{
	#define MAXM 331  // 块的个数 
	int n, len, tot;
	int a[MAXN], bl[MAXN];
	int L[MAXM], R[MAXM];  // 每个块的左端点和右端点 
	int maxn[MAXM], minn[MAXM];  // 每个块的最大值和最小值 
	Block(int x){  // 构造函数 
		n = x;
	}
	
	void init(){  // 初始化 
		len = sqrt(n);  // 块长 
		tot = (n-1)/len+1;  // 块的数量 
		R[0] = 0;
		for (int i(1); i<=tot; ++i){  // 求 L,R 
			L[i] = R[i-1] + 1;
			R[i] = i * len;
		}
		R[tot] = n;  // 注意最后一个块的右端点 
		
		for (int i(1); i<=tot; ++i){
			maxn[i] = LLONG_MIN;
			minn[i] = LLONG_MAX; 
			for (int j(L[i]); j<=R[i]; ++j){
				bl[j] = i;  // j 在第 i 个块 
				maxn[i] = max(maxn[i], a[j]);
				minn[i] = min(minn[i], a[j]);
			}
		}
	}
	
	int gmin(int l, int r){
		int p(bl[l]), q(bl[r]), res(LLONG_MAX);
		if (p == q){  // 当 l,r 处于同一个块时，暴力枚举 
			for (int i(l); i<=r; ++i) res = min(res, a[i]);
			return res;
		}
		
		for (int i(l); i<=R[p]; ++i) res = min(res, a[i]);  // 枚举第一个 
		for (int i(p+1); i<q; ++i) res = min(res, minn[i]);  // 枚举中间的 
		for (int i(L[q]); i<=r; ++i) res = min(res, a[i]);  // 枚举最后一个 
		return res;
	}
	
	int gmax(int l, int r){  // 同上 
		int p(bl[l]), q(bl[r]), res(LLONG_MIN);
		if (p == q){
			for (int i(l); i<=r; ++i) res = max(res, a[i]);
			return res;
		}
		
		for (int i(l); i<=R[p]; ++i) res = max(res, a[i]);
		for (int i(p+1); i<q; ++i) res = max(res, maxn[i]);
		for (int i(L[q]); i<=r; ++i) res = max(res, a[i]);
		return res;
	}
};

int f(int x){  // 模拟 B 的决策 
	if (x >= 0) return ans6;
	return ans5;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m >> q;
    Block a(n), b(m), a2(n), a3(n);  // a2 为负数、a3 为非负数 
    for (int i(1); i<=n; ++i){
    	cin >> a.a[i];
    	a2.a[i] = a3.a[i] = a.a[i];
    	if (a.a[i] < 0) a3.a[i] = LLONG_MAX;  // 替换 
    	else a2.a[i] = LLONG_MIN;
	}
	for (int i(1); i<=m; ++i) cin >> b.a[i];
	
	a.init();  // 注意不能在构造函数中 init() 
	b.init();
	a2.init();
	a3.init();
	
	while (q--){
		cin >> l_1 >> r_1 >> l_2 >> r_2;
		ans1 = a.gmax(l_1, r_1);  // 获取区间最值 
		ans2 = a.gmin(l_1, r_1);
		ans3 = a2.gmax(l_1, r_1);
		ans4 = a3.gmin(l_1, r_1);
		ans5 = b.gmax(l_2, r_2);
		ans6 = b.gmin(l_2, r_2);
		
		ans = max(ans1 * f(ans1), ans2 * f(ans2));  // A 取最大值和最小值的情况 
		if (ans3 != LLONG_MIN) ans = max(ans, ans3 * f(ans3));  // A 取负数最大值 
		if (ans4 != LLONG_MAX) ans = max(ans, ans4 * f(ans4));  // A 取非负数最小值 
		
		cout << ans << '\n';
	}

    return 0;
}

```


---

## 作者：OrezTsim (赞：4)

有一个人先手，肯定要选择使得最坏情况最优的点。

考虑分讨区间内元素情况。

1. $a$ 为自然数，$b$ 为自然数。

先手选择 $\max$，后手选择 $\min$。

2. $a$ 为自然数，$b$ 为负数。

先手选择 $\min$，后手选择 $\min$。因为先手如选择 $\max$，则后手选 $\min$ 会使答案更小。

3. $a$ 为自然数，$b$ 无特殊限制。

同 2 情况。

4. $a$ 为负数，$b$ 为自然数。

先手选择 $\max$，后手选择 $\max$。要使得负数 $\times$ 正数最大，先手需要让负数绝对值更小，后手则贪心地选择让乘积更小，选择区间最大值。

5. $a$ 为负数，$b$ 为负数。

这时候负负得正，先手选择 $\min$ 会让后手被迫选择 $\max$。原因显然。

6. $a$ 为负数，$b$ 无特殊限制。

显然后手要选自然数，那么先手选择 $\max$。

7. $a$ 无特殊限制，$b$ 为自然数。

先手显然选 $\max$，后手显然选 $\min$。

8. $a$ 无特殊限制，$b$ 为负数。

先手显然选 $\min$，后手选 $\max$，负负得正，乘积最小。

9. $a$ 无特殊限制，$b$ 无特殊限制。

考虑两种情况，若先手选最小的自然数，则后手会选最小的负数来回应。

若先手选最大的负数，则后手会选择最大的自然数来回应。

取 $\max$ 即可。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e5 + 10, Log = 20, inf = 1e9;
int n, m, q, lg[N], bn[Log];
ll a[N], b[N], Min[3][Log][N], Max[3][Log][N];

inline ll queryMin(int typ, int l, int r) {
	int k = lg[r - l + 1];
	return min(Min[typ][k][l], Min[typ][k][r - bn[k] + 1]);
} inline ll queryMax(int typ, int l, int r) {
	int k = lg[r - l + 1];
	return max(Max[typ][k][l], Max[typ][k][r - bn[k] + 1]);
}

inline void solve() {
	int l1, r1, l2, r2; scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
	ll Min1 = queryMin(0, l1, r1), Max1 = queryMax(0, l1, r1);
	ll Min2 = queryMin(1, l2, r2), Max2 = queryMax(1, l2, r2);
	ll ans = 0;
	if (Min1 >= 0) {
		if (Min2 >= 0) ans = Max1 * Min2;
		else if (Max2 < 0) ans = Min1 * Min2;
		else ans = Min1 * Min2;
	} else if (Max1 < 0) {
		if (Min2 >= 0) ans = Max1 * Max2;
		else if (Max2 < 0) ans = Min1 * Max2;
		else ans = Max1 * Max2;
	} else {
		if (Min2 >= 0) ans = Max1 * Min2;
		else if (Max2 < 0) ans = Min1 * Max2;
		else {
			ll fi = queryMin(2, l1, r1), se = queryMax(2, l1, r1);
			ans = max(fi * Min2, se * Max2);
		}
	}
	printf("%lld\n", ans); return ;
}

int main() {
	scanf("%d%d%d", &n, &m, &q);
	for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
	for (int i = 1; i <= m; ++i) scanf("%lld", &b[i]);
	bn[0] = 1; for (int i = 1; i < Log; ++i) bn[i] = bn[i - 1] << 1;
	lg[0] = -1; for (int i = 1; i < N; ++i) lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; ++i) Min[0][0][i] = Max[0][0][i] = a[i];
	for (int i = 1; i < Log; ++i)
	  for (int j = 1; j + bn[i] - 1 <= n; ++j) {
	  	Min[0][i][j] = min(Min[0][i - 1][j], Min[0][i - 1][j + bn[i - 1]]);
	  	Max[0][i][j] = max(Max[0][i - 1][j], Max[0][i - 1][j + bn[i - 1]]);
		}
	for (int i = 1; i <= m; ++i) Min[1][0][i] = Max[1][0][i] = b[i];
	for (int i = 1; i < Log; ++i)
	  for (int j = 1; j + bn[i] - 1 <= m; ++j) {
		  Min[1][i][j] = min(Min[1][i - 1][j], Min[1][i - 1][j + bn[i - 1]]);
		  Max[1][i][j] = max(Max[1][i - 1][j], Max[1][i - 1][j + bn[i - 1]]);
	  }
  for (int i = 1; i <= n; ++i) {
  	if (a[i] >= 0) Min[2][0][i] = a[i]; else Min[2][0][i] = inf;
  	if (a[i] < 0) Max[2][0][i] = a[i]; else Max[2][0][i] = -inf;
	}
	for (int i = 1; i < Log; ++i)
	  for (int j = 1; j + bn[i] - 1 <= n; ++j) {
	  	Min[2][i][j] = min(Min[2][i - 1][j], Min[2][i - 1][j + bn[i - 1]]);
	  	Max[2][i][j] = max(Max[2][i - 1][j], Max[2][i - 1][j + bn[i - 1]]);
		}
  while (q--) solve();
  return 0;
}
```

---


# [POI 2002] 火车线路

## 题目描述

某列火车从 $1$ 号城市出发，前往编号为 $C$ 的城市。该火车有 $S$ 个座位，现在有 $R$ 个车票订购需求。

一个订购由 $O,D,N$ 三个整数组成，表示从起点站 $O$ 到目标站 $D$ 需要订购 $N$ 个座位。

如果在该订购范围内有能满足的空座位，就称该订购可以被满足，否则就不可以。

请你按订购给出顺序处理，判断是否可以满足该订购需求。

## 说明/提示

数据范围：$1 \le C,S,R \le 60000$。

## 样例 #1

### 输入

```
4 6 4
1 4 2
1 3 2
2 4 3
1 2 3```

### 输出

```
T
T
N
N```

# 题解

## 作者：lrqlrq250 (赞：7)

## 解题思路
不难看出一个起点到终点的订购很像区间加，因此不难联想到线段树。

对于一次订购，我们尝试将 $[O, D - 1]$ 这个区间加上 $N$，然后判断区间最大值是否超过了火车的座位数 $S$，若超过了就将 $N$ 减回去并输出 `N`，否则保留这个操作，输出 `T`。

为什么是 $[O, D - 1]$ 呢？因为到了终点站这次订票的座位就空出来了，相当于没有受到有人订票的影响。~~不然就像我第一次交一样只有 32 分。~~

## Fake AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 60005;
int n, lim, q, dat[N << 2], tg[N << 2];

inline void pushup(int p){dat[p] = max(dat[p << 1], dat[p << 1 | 1]);}

inline void pushdown(int p, int l, int r){
	if (tg[p]){
		dat[p << 1] += tg[p]; dat[p << 1 | 1] += tg[p];
		tg[p << 1] += tg[p]; tg[p << 1 | 1] += tg[p];
		tg[p] = 0;
	}
}

void update(int p, int l, int r, int lpos, int rpos, int k){
	if (l > rpos || r < lpos) return;
	if (lpos <= l && r <= rpos){
		dat[p] += k;
		tg[p] += k;
		return;
	} 
	pushdown(p, l, r);
	int mid = (l + r) >> 1;
	update(p << 1, l, mid, lpos, rpos, k); update(p << 1 | 1, mid + 1, r, lpos, rpos, k);
	pushup(p); 
} 

int query(int p, int l, int r, int lpos, int rpos){
	if (l > rpos || r < lpos) return -2e9;
	if (lpos <= l && r <= rpos) return dat[p];
	pushdown(p, l, r);
	int mid = (l + r) >> 1;
	return max(query(p << 1, l, mid, lpos, rpos), query(p << 1 | 1, mid + 1, r, lpos, rpos)); 
}

int main(){
	scanf("%d%d%d", &n, &lim, &q);
	int l, r, x;
	while (q--){
		scanf("%d%d%d", &l, &r, &x);
		update(1, 1, n, l, r - 1, x);
		if (query(1, 1, n, l, r - 1) > lim){
			update(1, 1, n, l, r - 1, -x);
			printf("N\n");
		}
		else printf("T\n");
	}
	return 0;
}
```
~~先别着急复制~~

因为这道题的毒瘤时限只有 100ms，上面这份代码在我交的时候需要吸氧才能稳过，不然测试点 #10 会有 120ms 左右。

那么我们怎么不开 O2 通过呢？我们发现 `update` 应该没啥可以优化的了，但是每次真的都需要 `query` 吗？显然不用。我们只需要考虑整个数列中有没有大于火车座位数量 $S$ 的值就可以了，而这个值就在 `dat[1]` 中，因此 `query` 就优化到了 $O(1)$，可以通过。

## 新的关键部分
```cpp
int main(){
	while (q--){
		scanf("%d%d%d", &l, &r, &x);
		update(1, 1, n, l, r - 1, x);
		if (dat[1] > lim){//query函数可以直接不定义了
			update(1, 1, n, l, r - 1, -x);
			printf("N\n");
		}
		else printf("T\n");
	}
}
```
其实还有一种方法就是保留 `query`，每次先判断本次订购区间的最大值加上本次要订购的数量是否超过了总座位数，没超过再更新，因为感性认为 `T` 的个数大概率是少于 `N` 的，所以效率应该会更高。

---

## 作者：czy0323 (赞：3)

# 解题思路

必须明确，题目中说到的“满足订购要求”是指：目前第 $i$ 个站已经预定的座位数 $now_i+N\le s (O\le i<D)$。

**为什么 $i$ 的范围为小于 $D$，而不是小于等于 $D$？因为在终点站 $D$ 时，这些人都该下车了，也就不用占据座位了。这是最大的易错点。**

那么我们很容易就能想到要用一个数组 $now$ 储存每个站点目前已预定的座位数，每次判断 $now_i(O\le i<D)$ 中的最大值加上 $N$ 是否小于等于 $s$ 即可。如果满足要求，别忘了 $now_i=now_i+N (O\le i<D)$。

又有区间查询，又有区间修改，想到什么？没错，就是线段树！接下来就可以愉快地写代码了！

# AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=60005;
int n,s,m;
int tl,tr,x;
int tree[4*MAXN],col[4*MAXN];			//tree数组即为对now数组建的线段树

inline void pushdown(int p){			//下放懒标记
	if( col[p] ){
		tree[p*2]+=col[p];
		tree[p*2+1]+=col[p];
		col[p*2]+=col[p];
		col[p*2+1]+=col[p];
		col[p]=0;
	}
	return;
}

inline void modify(int l,int r,int p){		//区间修改
	if( tl<=l && tr>=r ){
		tree[p]+=x;
		col[p]+=x;
		return;
	}
	pushdown(p);
	int mid=(l+r)>>1;
	if( tl<=mid )
		modify(l,mid,p*2);
	if( tr>mid )
		modify(mid+1,r,p*2+1);
      tree[p]=max(tree[p*2],tree[p*2+1]);	//别忘了每次修改都一定要更新！
}

inline int query(int l,int r,int p){		//区间查询
	if( tl<=l && tr>=r )
		return tree[p];
	pushdown(p);
	int ans=0,mid=(l+r)>>1;
	if( tl<=mid )
		ans=max(ans,query(l,mid,p*2));
	if( tr>mid )
		ans=max(ans,query(mid+1,r,p*2+1));
	return ans;
}

int main(){
	scanf("%d%d%d",&n,&s,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&tl,&tr,&x);
		tr--;
		if( x+query(1,n,1)<=s ){
			modify(1,n,1);
			printf("T\n");
			continue;
		}
		printf("N\n");
	}
	return 0;
}
```


---

## 作者：Erotate (赞：2)

### Solution

显然，我们可以把这道题转换成数列区间最小值的问题，然后用线段树。

我们每处理一个预定，如果可以满足，即这一段区间里所有的数都大于等于预定的数，那么我们就把区间里的所有数都减去这个数。否则的话就是不能满足，输出 ```N``` 即可。

这里需要注意一点，查询的区间不能到 $D$，只能到 $D-1$，因为到了站人就会下车，座位就会空出来。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct lhr{
    int o,d,n;
}a[60005];
struct hcr{
    int l,r,min,add;
}tree[60000*4+5];
int c,s,r;
inline int read(){
    register int x=0,f=0;register char ch=getchar();
    while(!isdigit(ch))f^=!(ch^45),ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?-x:x;
}
inline int ls(int x){return x<<1;}
inline int rs(int x){return x<<1|1;}
void push_up(int x){tree[x].min=min(tree[ls(x)].min,tree[rs(x)].min);}
void build(int id,int l,int r){
    tree[id].l=l;
    tree[id].r=r;
    if(l==r){
        tree[id].min=s;
        return;
    }
    int mid=(l+r)/2;
    build(ls(id),l,mid);
    build(rs(id),mid+1,r);  
    push_up(id);
}
void push_down(int x){
    tree[ls(x)].add+=tree[x].add;
    tree[rs(x)].add+=tree[x].add;
    tree[ls(x)].min+=tree[x].add;
    tree[rs(x)].min+=tree[x].add;
    tree[x].add=0;
} 
void change(int id,int l,int r,int d){
    if(l<=tree[id].l && tree[id].r<=r){
        tree[id].min+=d;
        tree[id].add+=d;
        return;
    }
    push_down(id);
    int mid=(tree[id].l+tree[id].r)/2;
    if(l<=mid) change(ls(id),l,r,d);
    if(mid<r) change(rs(id),l,r,d);
    push_up(id);
}
int query(int id,int l,int r){
    if(l<=tree[id].l && tree[id].r<=r) return tree[id].min;
    int ans=INT_MAX;
    push_down(id);
    int mid=(tree[id].r+tree[id].l)/2;
    if(l<=mid) ans=min(query(ls(id),l,r),ans);
    if(mid<r) ans=min(query(rs(id),l,r),ans);
    return ans;
}  
signed main(){
    c=read(),s=read(),r=read();
    for(int i=1;i<=r;++i){
        a[i].o=read();
        a[i].d=read();
        a[i].d--;
        a[i].n=read();
    }
    build(1,1,c);
    for(int i=1;i<=r;++i){
        if(query(1,a[i].o,a[i].d)>=a[i].n){
            printf("T\n");
            change(1,a[i].o,a[i].d,-a[i].n);
        }else printf("N\n");
    }
    return 0;
}
```


---

## 作者：Dr_Glitch (赞：0)

## 思路

不知道为什么看到这道题的第一眼有点~~最小瓶颈路~~的感觉，不过这个感觉还是有帮助的，本题要从 $O$ 到 $D$ 买 $N$ 张票，不就相当于把 $O$ 到 $D$ 这个区间一起加上 $N$ 吗？再思考，能否买这么多票取决于当前区间内所有站点剩下的**最少的票数**，用线段树维护最值！到此为止问题得到了解决。

做法如下：

- 线段树维护当前区间内使用票数的最大值（用总票数减去即为剩余的）。
- 判断所需票数是否小于等于剩余票数。若小于等于，则将该区间加上所需的票数；若大于，则直接跳过该请求。
- 请注意到达终点站后乘客会下车，所以需要操作的区间应是从 $O$ 到 $D-1$ 才对。

总用时 157ms，玄学常数成功跑过 100ms 的限制。

## Code

```cpp
#include<bits/stdc++.h>
#define init read()
using namespace std;
const int N=60005;
int c,s,r;
inline int read()
{
	int mmm=0,ff=1;char xx=getchar();
	while((xx<'0'||xx>'9')&&xx!='-')xx=getchar();
	if(xx=='-')ff=-1,xx=getchar();
	while(xx>='0'&&xx<='9')
	mmm=mmm*10+xx-'0',xx=getchar();
	return mmm*ff;
}
inline void write(int x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
struct Segment_Tree
{
	#define lc k<<1
	#define rc k<<1|1
	struct Node
	{
		int L,R;
		int val; //线段树维护最大值
		int lazy; //加法的懒惰标记
	}t[N<<2];
	inline void pushup(int k)
	{
		t[k].val=max(t[lc].val,t[rc].val);
	}
	inline void pushdown(int k)
	{
		if(!t[k].lazy)return;
		t[lc].lazy+=t[k].lazy;
		t[rc].lazy+=t[k].lazy;
		t[lc].val+=t[k].lazy;
		t[rc].val+=t[k].lazy;
		t[k].lazy=0;
	}
	inline void build(int k,int l,int r)
	{
		t[k].L=l;t[k].R=r;
		if(l==r)
		{
			return;
		}
		int mid=(l+r)>>1;
		build(lc,l,mid);
		build(rc,mid+1,r);
	}
	inline void update(int k,int ql,int qr,int val)
	{
		int l=t[k].L,r=t[k].R;
		if(l>=ql&&r<=qr)
		{
			t[k].val+=val;
			t[k].lazy+=val;
			return;
		}
		pushdown(k);
		int mid=(l+r)>>1;
		if(mid>=ql)update(lc,ql,qr,val);
		if(mid<qr)update(rc,ql,qr,val);
		pushup(k);
	}
	inline int query(int k,int ql,int qr)
	{
		int l=t[k].L,r=t[k].R;
		if(l>=ql&&r<=qr)
		{
			return t[k].val;
		}
		pushdown(k);int res=0;
		int mid=(l+r)>>1;
		if(mid>=ql)res=max(res,query(lc,ql,qr));
		if(mid<qr)res=max(res,query(rc,ql,qr));
		return res;
	}
};
Segment_Tree T;
int main()
{
	c=init;s=init;r=init;
	T.build(1,1,c);
	for(int i=1;i<=r;i++)
	{
		int o=init,d=init,n=init;
		int tmp=T.query(1,o,d-1); //注意这里修改的范围
		if(n<=s-tmp) //用总票数减去路上最多占用的票数得到剩下的最少的票数
		{
			T.update(1,o,d-1,n);
			puts("T");
		}
		else puts("N");
	}
	return 0;
}
```

---


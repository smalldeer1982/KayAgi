# [蓝桥杯 2025 省 A] 黑客

## 题目描述

小蓝正在两台电脑之间拷贝数据，数据是一个 $n \times m$ 大小的正整数矩阵，因此总共有 $n \times m + 2$ 个由空格分开的整数，其中前两个整数分别为 $n$ 和 $m$。然而，有黑客入侵了小蓝的电脑，导致这 $n \times m + 2$ 个正整数的顺序被打乱了。小蓝想知道最多可能有多少个不同的原矩阵。

两个矩阵相同当且仅当它们行数相同、列数相同，且每个位置上的数相同。

## 说明/提示

### 样例说明

可能的原矩阵情况包括：

1. $(n,m)=(1,4)$：有 $6$ 种原矩阵：$(2, 2, 3, 3), (2, 3, 2, 3), (2, 3, 3, 2), (3, 2, 2, 3), (3, 2, 3, 2), (3, 3, 2, 2)$；
2. $(n,m)=(4,1)$：有 $6$ 种原矩阵；
3. $(n,m)=(2,2)$：有 $12$ 种原矩阵；

总计 $6 + 6 + 12 = 24$ 种。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$1 \leq n \times m + 2 \leq 10$；
- 对于所有评测用例，$1 \leq n \times m + 2 \leq 5 \times 10^5$，$1 \leq a_i \leq 5 \times 10^5$。

## 样例 #1

### 输入

```
6
2 2 1 4 3 3```

### 输出

```
24```

# 题解

## 作者：Kagamino_Natsumi (赞：10)

# P12142 [蓝桥杯 2025 省 A] 黑客

第一次参加蓝桥杯，可以说题目言简意赅，质量还是不错的。~~虽然最后两道题分别因为精度和忽略情况而喜提 WA~~

## 思路

本题给出了打乱顺序的 $n \times m + 2$ 个数。为了方便统计，自然需要对这些数据排序。本题中，矩阵中数字的大小其实没有什么作用，只需要统计其个数，而且数据范围为 $ 1 \leq a_i \leq 5 \times 10^{5} $ ，非常适合使用计数排序。

矩阵的长和宽都必须在题目给出的 $n \times m + 2$ 个数之中，只需要一一枚举矩阵的可能长宽即可。注意，在每次枚举长和宽进行统计时，都需要把长和宽从计数中去掉，以免重复统计。

每次统计的过程如下：对矩阵中全部的 $n \times m $ 个数进行全排列，共有 $(n \times m)！$ 种方案。其中，若有重复的 $x$ 个数，则这 $x$ 个数无论怎么排列都是同一种方案，需要在总方案数上除以 $x！$ 。注意模意义下的除法需要使用逆元。

多次求阶乘及逆元的过程十分耗时，可以提前进行预处理。

时间复杂度为 $ O(a_{max}^{1.5} )$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int sum;
int scale;
int x;
long long bucket[500007];
long long jc[500007] = {1};
long long invjc[500007] = {};
long long ans = 0;
const long long mod = 1000000007ll;

long long qpow(long long a, long long b)
{
	long long res = 1;
	while(b)
	{
		if(b & 1)
			res = res * a % mod;
		a = a * a % mod;
		b >>= 1; 
	}
	return res;
}

long long inv(long long x)
{
	return qpow(x, mod - 2);
}

int main()
{
	cin >> sum;
	scale = sum - 2;
	for(long long i = 1; i <= 500000; i++)
	{
		jc[i] = jc[i - 1] * i % mod;
	}
	for(int i = 0; i <= 500000; i++)
	{
		invjc[i] = inv(jc[i]);
	}
	for(int i = 1; i <= sum; i++)
	{
		cin >> x;
		bucket[x]++;
	}
	for(int i = 1; i <= scale; i++)
	{
		if(scale % i == 0 && bucket[i] && bucket[scale / i])
		{
			int n = i, m = scale / i;
			bucket[n]--;
			bucket[m]--;
			long long now = jc[scale];
			for(int j = 1; j <= 500000; j++)
				if(bucket[j])
					now = now * invjc[bucket[j]] % mod;
			ans = (ans + now) % mod;
			bucket[n]++;
			bucket[m]++;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Frieren_Asuka (赞：5)

题目给咱们一个被打乱顺序的正整数序列，长度为  $L=n\times m+2$ 。原本，这个序列的前两个数分别是矩阵的行数 $n$ 和列数 $m$，后面跟着 $n\times m$ 个矩阵元素，但入侵后所有数的顺序都乱了。现在咱们要做的就是：
  1.	从这 $L$ 个数中任意选两个作为 $n$ 和 $m$ ，要求剩下的数正好有 $n\times m$ 个。
  2.	用这 $n\times m$ 个数去填充一个 n 行 m 列的矩阵，同样的数字放到不同位置也要算作不同矩阵。
  3.	统计所有可能的 $(n,m)$ 配对和对应的矩阵填法数量之和，并对 $10^9+7$ 取模后输出结果。

这个题上手一看就是一个组合数学和逆元运算的题目。
但是呢其实并没有这么简单。(主要是会 TLE，qwq）主要思路差不多是：
  1. 读入整数 $L$ 和长度为 $L$ 的数组 $A$，用哈希表统计每个值 $x$ 的出现次数 $\text{cnt}[x]$。
  2.	预处理阶乘数组 $\text{fact}[0…L]$ 和逆元数组 $\text{ifac}[0…L]$ ，方便快速计算阶乘和组合。
  3.  遍历所有可能的数对 $(n,m)$（包括 n=m）：若满足 $n\times m = L-2$ 则视为一个合法的行列方案。
  4.  __最重要的来了__，计算“选作行和列”的方式数：若 $n\neq m$，则为 $\text{cnt}[n]\times\text{cnt}[m]$；若 $n=m$，则为 $\binom{\text{cnt}[n]}{2}$。对剩下的 $L-2$ 个元素（将一个 $n$ 和一个 $m$ 从多重集中取出后）的排列数，等于
$\frac{(L-2)!}{\prod_v(\text{cnt}{\prime}[v]!)}\!$。
  5.   关于时间复杂度：枚举因子对：$O(\sqrt{L})$ 次，每次计算排列数花费 $O(1)$（假设我们把 $cnt$ 中非零项存成数组），总体接近 $O(L + \sqrt{L})$，对于 $L\le 5\times10^5$ 足够高效。

在改了 $3$ 个小时后，我得出了一两点最容易出错的地方。                 
1. 在枚举矩阵的列数和行数的时候，一定要讨论矩阵的行数和列数是否相等的问题（不然会 WA）。            
2. 一定记得要进行预处理，不然的话，这个时间会非常的凄惨。
       
__预处理：__
__提前储存逆元和阶乘。__

    vector<ll> fact(N+1), invF(N+1);
    fact[0] = 1;
    for(int i = 1; i <= N; i++) fact[i]= fact[i-1] * i % MOD;
    invF[N] = mod_pow(fact[N], MOD-2);
    for(int i = N; i > 0; i--) invF[i-1]= invF[i] * i % MOD;

__计算重要的 base 排列数。__

    ll base = fact[k];
    for(int v = 0; v <= maxA; v++){
        if (cnt[v] > 0) {
            base = base * invF[cnt[v]] % MOD;
        }
    }

__接下来是代码。__



    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;
    const ll MOD = 1000000007;

    // 快速幂 a^b % MOD
    ll mod_pow(ll a, ll b) {
    ll r = 1;
    a %= MOD;
    while (b) {
        if (b & 1) r = r * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return r;
    }

    int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;               // N = n*m + 2
    int k = N - 2;          // k = n*m

    vector<int> a(N);
    int maxA = 0;
    for(int i = 0; i < N; i++){
        cin >> a[i];
        maxA = max(maxA, a[i]);
    }

    // 统计频次
    vector<int> cnt(maxA+1, 0);
    for(int x : a) cnt[x]++;

    // 阶乘+逆阶乘预处理到 N（足够大，N ≤ 5e5）
    vector<ll> fact(N+1), invF(N+1);
    fact[0] = 1;
    for(int i = 1; i <= N; i++) fact[i] = fact[i-1] * i % MOD;
    invF[N] = mod_pow(fact[N], MOD-2);
    for(int i = N; i > 0; i--) invF[i-1] = invF[i] * i % MOD;

    // 计算 baseRes = k! / ∏(cnt[v]!)  mod
    //    = fact[k] * ∏ invF[cnt[v]]
    ll base = fact[k];
    for(int v = 0; v <= maxA; v++){
        if (cnt[v] > 0) {
            base = base * invF[ cnt[v] ] % MOD;
        }
    }

    // 枚举 k 的所有因子对 (d1, d2)
    ll ans = 0;
    for(int d1 = 1; (ll)d1 * d1 <= k; d1++){
        if (k % d1) continue;
        int d2 = k / d1;

        if (d1 < d2) {
            // 需要 cnt[d1]>=1 && cnt[d2]>=1
            if (d1 <= maxA && d2 <= maxA && cnt[d1] > 0 && cnt[d2] > 0) {
                // res = base * (cnt[d1] * cnt[d2]) * 2
                ll add = base * cnt[d1] % MOD * cnt[d2] % MOD;
                add = add * 2 % MOD;
                ans = (ans + add) % MOD;
            }
        }
        else if (d1 == d2) {
            // 需要 cnt[d1] >= 2
            if (d1 <= maxA && cnt[d1] >= 2) {
                // res = base * (cnt[d1] * (cnt[d1] - 1))
                ll add = base * cnt[d1] % MOD * (cnt[d1] - 1) % MOD;
                ans = (ans + add) % MOD;
            }
        }
    }

    cout << ans << "\n";
    return 0;
    }

---

## 作者：114514xxx (赞：4)

## 题意
[题目传送门](https://www.luogu.com.cn/problem/P12142)。
## 思路
我们平常统计的都是线性的排列，假设有 $x$ 个元素，那么就有 $x!$ 种方案。


现在我们将选取 $a_i$ 和 $a_j$ 作为 $n$ 和 $m$。
那么矩阵如何统计呢，我们将矩阵按蛇形展开为一条线，就转化为了线性排列，那么就有 $(nm)!$ 种方案。

有相同的元素怎么办呢？因为相同的元素怎么排都是一样的，所以还需要除以 $\prod^{cnt}_{i=1}(p_i!)$，其中 $cnt$ 代表元素的种类数，$p_i$ 代表每种元素出现的次数。注意，此时要将选出来作为 $n,m$ 的 $a_i$ 和 $a_j$ 的出现次数减 $1$。

最后我们只需要将每个 $n$ 和 $m$ 计算出来的答案累加即可。

到这里就结束了吗？

我们对于每个 $n$ 和 $m$ 都要计算 $\prod^{cnt}_{i=1}(p_i!)$ ，这样时间复杂度来到了 $O(n\sqrt n)$，对于 $n=5\times 10^5$ 的数据来说还是太勉强了。

那么如何计算呢？我们发现每次计算只会有两个数的出现次数会发生改变，我们可以借此加速计算。记 $base=(nm)!\times \prod^{cnt}_{i=1}(p_i!)$，此处是元素都是最开始 $n\times m-2$ 个正整数。假设 $p_i,p_j$ 减 $1$，那么答案就是 $base \times p_i\times p_j\times \frac{1}{(p_i-1)!(p_j-1)!}$，这样就可以 $O(\sqrt n)$ 计算答案了。

总复杂度 $O(n)$，瓶颈在于计算 $base$ 和预处理阶乘和阶乘逆元。


## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+25;
const int mod=1e9+7;
bitset<N>vis;
int fac[N];
int len,a[N],mp[N];
int f1[N],f2[N],Inv[N],ninv[N];
inline void init(){
    fac[0]=1;Inv[0]=1;
    ninv[1]=1;ninv[0]=1;
    Inv[1]=1;
    for(int i=2;i<=500000;++i)
        ninv[i]=(mod-mod/i)*ninv[mod%i]%mod;
    for(int i=1;i<=500000;i++)
        Inv[i]=Inv[i-1]*ninv[i],Inv[i]%=mod;
    for(int i=1;i<=500000;i++)
        fac[i]=fac[i-1]*i,fac[i]%=mod;
    //ninv_i表示i的逆元,Inv_i表示i!的逆元，fac_i表示i!
}
inline int solve(){
    int n=len-2;
    vis.reset();
    int inv1=1;
    for(int i=1;i<=n+2;i++)
        if(!vis[a[i]])vis[a[i]]=1,inv1*=Inv[mp[a[i]]],inv1%=mod;
    int ans=(fac[n]*inv1)%mod;
    return ans;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>len;
    int n=len-2;
    int cnt=0;
    init();
    for(int i=1;i<=len;i++)
        cin>>a[i],mp[a[i]]++;
    for(int i=1;i*i<=n;i++)
        if(n%i==0)f1[++cnt]=i,f2[cnt]=n/i;//对 nm 进行因数分解
    int ans=0;
    int base=solve();//求解base
    for(int i=1;i<=cnt;i++){
        if(f1[i]!=f2[i]){
            int p1=fac[mp[f1[i]]]*fac[mp[f2[i]]];
            int p2=Inv[mp[f1[i]]-1]*Inv[mp[f2[i]]-1];
            ans+=2*(base%mod)*((p1%mod)*(p2%mod)%mod);
        }else{
            //如果 nm 是完全平方数
            if(mp[f1[i]]<2)continue;
            else{
                int p1=fac[mp[f1[i]]];
                int p2=Inv[mp[f1[i]]-2];
                ans+=(base%mod)*((p1%mod)*(p2%mod)%mod);
            }
        }
    }
    cout<<ans%mod;
}

```

---

## 作者：Coffee_zzz (赞：2)

假设我们已经找到 $n$ 和 $m$，则根据组合数可以得到答案为

$$
\dfrac {(nm)!}{\prod\limits_{x=1}^V (cnt_x-[x=n]-[x=m])!}
$$

其中 $cnt_x$ 表示 $x$ 的出现次数，$V$ 为值域，若 $P$ 为真则 $[P]=1$，否则 $[P]=0$。

我们设

$$
s=\dfrac {(nm)!}{\prod\limits_{x=1}^V cnt_x!}
$$

则我们可以预处理出 $V$ 以内的阶乘与其逆元，然后枚举满足要求的 $n$ 和 $m$：

- 若 $n\ne m$，则这种情况对答案的贡献为

$$
s \times cnt_n! \times cnt_m!\times \dfrac 1{(cnt_n-1)!}\times\dfrac 1{(cnt_m-1)!}
$$

- 若 $n=m$，则这种情况对答案的贡献为

$$
s \times cnt_n! \times\dfrac 1{(cnt_n-2)!}
$$

将每种情况的贡献相加即可。

---

## 作者：MisakaW (赞：1)

# 思路

不用管是不是二维矩阵，直接看作一维数矩阵。题目大意：当找到两个数 $num_r$ 和 $num_c$，当 $num_r \times num_c = n-2$ 时，求剩余 $n-2$ 个数有多少种**不重复**的排列，并对其求和。

考试时不知道带模的除法怎么做，只好开了 `unsigned long long` 并且打了个 22 以内的阶乘表，大概是拿 40% 的分了。

实际上，后面补习数论，**模意义下的除法**是这样的：

$$(a \div b) \bmod m = (a b^{-1}) \bmod m = (a \bmod m)(b^{-1} \bmod m) \bmod m$$

其中 $b^{-1}$ 是求 $b$ 的**模意义下的逆元**。这里数据量不大，可以套快速幂公式。

而这里的**排列公式**为：当有 $n$ 个不相同的数 $a_1, a_2, \cdots, a_n$ 排列，对于每一个数 $a_i$，它的数量是 $cnt_i$，排列方式有 $\frac{n!}{\prod\limits_{i=1}^{n} (cnt_i!)}$ 种。

豪！基础复习完毕。回到题目——

对于行数 $num_r$ 和列数 $num_c$，当 $num_r \times num_c = n-2$ 时，求剩余 $n-2$ 个数的排列方式数目。排列公式分母里要去掉一个 $num_r$ 和一个 $num_c$，当两者相同时，就相当于去掉两个 $num_r$。

对于一对“行数”和“列数”，上述排列公式的分母如下：

$$
\prod\limits_{\substack{i=1 \\ i \neq r,c}}^n cnt_i! \times \begin{cases} 
(cnt_r-1)! \times (cnt_c-1)! & \text{if } r \neq c, \\
(cnt_r-2)! & \text{if } r = c.
\end{cases}
$$

将分母带入排列公式：
$$
(n-2)! \left[\prod\limits_{i=1}^n cnt_i!\right]^{-1} \times \begin{cases} 
cnt_r \times cnt_c & \text{if } r \neq c, \\
cnt_r \times (cnt_r - 1) & \text{if } r = c.
\end{cases}
$$

最终答案表达式，即求和：
$$
(n-2)! \left[\prod\limits_{i=1}^n cnt_i!\right]^{-1} \times \sum_{\substack{num_r \times num_c = n-2}} \begin{cases} 
cnt_r \times cnt_c & \text{if } r \neq c, \\
cnt_r \times (cnt_r - 1) & \text{if } r = c.
\end{cases}
$$

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll unsigned long long
#define N 500005
const int p = 1000000007;

int n, m;
unordered_map<ll, int> mp; // 对每个数，对应的数量。unordered_map 比 map 更高效
ll jc[N]; // 阶乘
ll inverse(ll a) // 快速幂逆元
{
    ll b = p - 2, ret = 1;
    while (b)
    {
        if (b & 1)
            ret = ret * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return ret;
}
signed main()
{
    jc[0] = jc[1] = 1;
    for (int i = 2; i < N; ++i)
    {
        jc[i] = jc[i - 1] * i % p;
    }
    scanf("%d", &n);
    m = n - 2; // 矩阵的大小
    ll a, b = 1, rc = 0;
    for (int i = 0; i < n; ++i)
    {
        scanf("%lld", &a);
        ++mp[a];
    }
    for (auto i : mp)
    {
        b = b * jc[i.second] % p;
    }
    for (auto r : mp)
    {
        if (m % r.first != 0)
            continue;
        auto c = mp.find(m / r.first);
        if (c == mp.end()) // 找不到两数相乘为 n-2
            continue;
        if (r.first != c->first)
            rc = (rc + r.second * c->second % p) % p;
        else
            rc = (rc + r.second * (r.second - 1) % p) % p;
    }
    cout << jc[n - 2] * inverse(b) % p * rc % p << endl;
    return 0;
}
```

---

## 作者：520689892yhw (赞：1)

# 题解：P12142 [蓝桥杯 2025 省 A] 黑客

## 思路概述
1. **统计频次**  
   用一个哈希表记录输入中每个数字出现的次数：  
   $$\mathrm{cnt}[x] = \text{出现次数}$$

2. **预处理阶乘与逆元**  
   设常量  
   $$\mathrm{MOD} = 10^9 + 7,\quad N = \max\{\text{输入长度}\}$$
   
   预先计算  
   $$\mathrm{fac}[i] = i! \bmod \mathrm{MOD}$$
   $$\mathrm{invfac}[i] = (\mathrm{fac}[i])^{\mathrm{MOD}-2} \bmod \mathrm{MOD}$$
   $$i = 0,1,\dots,N$$
   
   这样可以在常数时间内求任意组合数或多重排列数。

3. **枚举可能的维度对**  
   设总元素数为 $N$，剩余元素数  
   $$S = N - 2$$
   
   枚举所有正整数 $d$ 满足  
   $$d \mid S$$
   
   令  
   $$e = S / d$$
   
   由于对称性，只需枚举到  
   $$d \leq \sqrt{S}$$
   
   其余情况再乘以 2 处理。

4. **验证并计算每一对的方案数**  
   - 先验去重排列数  
     $$P = \frac{S!}{\displaystyle\prod_x \bigl(\mathrm{cnt}[x]!\bigr)} \bmod \mathrm{MOD}$$
     
   - 从 $\mathrm{cnt}[d]$ 中取出一个 $d$，等价于在分母将 $\mathrm{cnt}[d]!$ 变为 $(\mathrm{cnt}[d]-1)!$，即乘上 $\mathrm{cnt}[d]$。  
   
   - 同理从 $\mathrm{cnt}[e]$ 中取一个 $e$，再乘上 $\mathrm{cnt}[e]$。  
   
   - 若 $d \neq e$，则 $(d,e)$ 与 $(e,d)$ 属不同情况，还要再乘 2；若 $d = e$，只算一次。

5. **累加并取模**  
   将所有合法的 $(d,e)$ 的方案数累加，最后取模：  
   $$\text{ans} = \sum_{(d,e)} \text{ways}(d,e) \;\bmod\; \mathrm{MOD}$$

---

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 1000000007;
ll fac[500005], invfac[500005];

ll power(ll a, ll b) {
    ll r = 1;
    while (b) {
        if (b & 1) r = r * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return r;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 1. 预处理阶乘与逆元
    fac[0] = 1;
    for (int i = 1; i <= 500000; i++)
        fac[i] = fac[i - 1] * i % MOD;
    invfac[500000] = power(fac[500000], MOD - 2);
    for (int i = 500000; i > 0; i--)
        invfac[i - 1] = invfac[i] * i % MOD;
    
    int n;
    cin >> n;
    unordered_map<ll, ll> cnt;
    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x;
        cnt[x]++;
    }
    
    ll S = n - 2;
    ll base = fac[S];
    for (auto &p : cnt)
        base = base * invfac[p.second] % MOD;
    
    ll ans = 0;
    // 2. 枚举因子对
    for (auto &p : cnt) {
        ll d = p.first, cd = p.second;
        if (d * d > S || S % d) continue;
        
        ll e = S / d;
        // 处理 d != e 的情况
        if (d != e && cnt.count(e) && cnt[e] > 0) {
            ll ways = base;
            ways = ways * cd % MOD * cnt[e] % MOD * 2 % MOD;
            ans = (ans + ways) % MOD;
        }
        // 处理 d == e 的情况
        else if (d == e) {
            ll ways = base;
            ways = ways * cd % MOD * cnt[e] % MOD;
            ans = (ans + ways) % MOD;
        }
    }
    
    cout << ans << "\n";
    return 0;
}

```

---

## 作者：xxr___ (赞：1)

来个硬做的做法，时间复杂度 $O(n + V)$。

首先我们知道多重集的排列数是这个公式：

- $\frac{n!}{\prod_{i=1}^kn_i!}=\frac{n!}{n_1!n_2!\cdots n_k!}$

那么就可以做这个问题了，我们令 $cnt_i$ 表示数字 $i$ 出现的个数，那么首先乘积是一定的，是 $n - 2$ 所以可以先排序，然后记录个桶，看看有没有出现过 $\frac{n - 2}{a_i}$ 如果有，就有两种情况：
1. $a_i\times a_i = n - 2$ 这种相当于把原来的答案先除以 $n$ 和 $n - 1$ 再乘上 $cnt_{a_i}!$ 再除以一个 $(cnt_{a_i} - 2)!$ 即可，预处理阶乘逆元即可实现线性。
2. $a_i\times a_i \ne n - 2$ 和上面基本一样，就是需要分别把 $cnt_{a_i}→cnt_{a_i} - 1,cnt_{\frac{n}{a_i}} → cnt_{\frac{n}{a_i}} - 1$ 即可。

预处理一下 $n$ 和 $n - 1$ 和阶乘的逆元可以做到线性。

当然也可以直接 $O(\sqrt{ n })$ 的去枚举 $n - 2$ 的因数，但是没必要。

代码：
```cpp
#include<iostream>
#include<algorithm>
#define int long long
using ll = long long;

const int N = 5e5 + 5;
const ll mod = 1e9 + 7;
int n,a[N],cnt[N]; 
ll fac[N],Inv[N];
bool vs[N];
ll ksm(ll x,ll y){
	ll ans = 1;
	while(y){
		if(y & 1){
			(ans *= x) %= mod;
		}
		(x *= x) %= mod;
		y >>= 1;
	}
	return ans;
}

int32_t main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin >> n;
	for(int i = 1;i <= n; ++ i){
		std::cin >> a[i];
		++ cnt[a[i]];
	}
	std::sort(a + 1,a + n + 1);
	fac[0] = Inv[0] = 1ll;
	for(int i = 1;i <= n; ++ i){
		fac[i] = (fac[i - 1] * i) % mod;
	}
	Inv[n] = ksm(fac[n],mod - 2);
	for(int i = n - 1;i >= 1; -- i){
		Inv[i] = (Inv[i + 1] * (i + 1) * 1ll) % mod;
	}
	ll res = fac[n];
	for(int i = 1;i <= 500000; ++ i){
		if(cnt[i]){
			(res *= Inv[cnt[i]]) %= mod;
		}
	}
	ll ans = 0,inv1 = ksm(n,mod - 2),inv2 = ksm(n - 1,mod - 2);
	for(int i = 1;i <= n; ++ i){
		if((n - 2) % a[i]) continue;
		if(!cnt[(n - 2) / a[i]]) continue;
		if(vs[a[i]]) continue;
		vs[a[i]] = 1;
		if(a[i] == (n - 2) / a[i]){
			if(cnt[(n - 2) / a[i]] <= 1) continue;
			(ans += 1ll * res * inv1 % mod * inv2 % mod * fac[cnt[a[i]]] % mod * Inv[cnt[a[i]] - 2]) %= mod;
		}else{
			(ans += 1ll * res * inv1 % mod * inv2 % mod * fac[cnt[a[i]]] % mod * Inv[cnt[a[i]] - 1] % mod * fac[cnt[(n - 2) / a[i]]] % mod * Inv[cnt[(n - 2)/a[i]] - 1]) %= mod;
		}
//		std::cout << ans << '\n';
	}
	std::cout << ans << '\n';
	return 0;
}
```

---

## 作者：Fusiyi (赞：0)

# 题意

小蓝正在拷贝数据，数据是一个 $n \times m$ 大小的正整数矩阵，因此总共有 $n \times m + 2$ 个整数，其中前两个整数分别为 $n$ 和 $m$。然而这 $n \times m + 2$ 个正整数的顺序被打乱了。小蓝想知道最多可能有多少个不同的原矩阵。

# 思路

可以指定两个数为 $n, m$，通过枚举因数求出 $n, m$，再判断是否在这 $n \times m + 2$ 个数中。

将选出的 $n, m$ 从原数组中删除，考虑新数组贡献。

总方案为 $(n \times m)!$，即 $n \times m$ 个数的全排列。

但有些数可能相等，所以要去掉重复的贡献，设 $cnt_i$ 为数组中 $i$ 的数量，贡献要除去 $cnt_i !$
即值为 $i$ 的数的全排列。

最终新数组的贡献为 $\dfrac{(n \times m)!}{\coprod\limits_{i=1}^n cnt_i !}$。

最终答案为所有贡献的和。

**$n = 1$ 要特判！**

# 代码

~~~Cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;

const int N = 5e5 + 1, mod = 1000000007;
int n;
ll a[N];

int _n, _m;
ll cnt[N];

ll s;
ll ans;

ll fr[N];
ll ny[N];

ll po(ll a, ll b, ll mod){
    ll ans = 1;
    while(b){
        if(b & 1){
            ans = ans * a % mod;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

void init(){
    fr[0] = 1;
    for(int i = 1; i < N; i ++){
        fr[i] = fr[i - 1] * i % mod;
    }

    ny[N - 1] = po(fr[N - 1], mod - 2, mod);
    for(int i = N - 1; i >= 1; i --){
        ny[i - 1] = ny[i] * i % mod;
    }

}

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    init();

    cin >> n;
    for(int i = 1; i <= n; i ++){
        cin >> a[i];
        cnt[a[i]] ++;
    }

    if(n == 1){
        cout << 0;
        exit(0);
    }

    for(int i = 1; i <= n - 2; i ++){
        if((n - 2) % i != 0){
            continue;
        }
        _n = i, _m = (n - 2) / i;

        if(cnt[_n] < 2 && _n == _m){
            continue;
        }
        if(cnt[_n] == 0 || cnt[_m] == 0){
            continue;
        }

        cnt[_n] --;
        cnt[_m] --;

        s = 1;
        for(int i = 1; i < N; i ++){
            s = s * ny[cnt[i]] % mod;
        }
        ans = (ans + fr[n - 2] * s % mod) % mod;

        cnt[_n] ++;
        cnt[_m] ++;
    }

    cout << ans;

    return 0;
}

/***

6
2 2 1 4 3 3

***/
~~~

---

## 作者：2455535622ms (赞：0)

## 分析
有 $n$ 个数记为 $a[0],a[1],\cdot\cdot\cdot,a[n-1]$，去重后有 $m$ 个数，其中从小到大第 $i$ 个数为 $h[i](0\le i\le m-1)$，其中每个数出现的次数为 $mp[h[i]](0\le i\le m-1)$，则这 $n$ 个数的排列一共有 $n!\div\prod_{i=0}^{m-1}mp[h[i]]!$ 种。
考虑到 $n,m$ 和 $mp[i]$ 的值可能很大，阶乘直接爆炸，所以需要使用**逆元**。
## 思路
令 $t=n\times m+2,nm=t-2$，先从 $t$ 个数中分离出 $2$ 个数 $x$ 和 $y$，并使得 $x\times y=nm$，再求出剩余 $nm$ 个数的排列数量，累加到答案 $sum$ 中，当找到所有的数对 $(x,y)$ 后 $sum$ 就是最后的答案。
## 优化
当 $x\neq y$ 时 $(x,y)$ 和 $(y,x)$ 对应的排列数量相同，求出其中一组的排列数量 $\times2$ 后累加到答案 $sum$ 中。当这 $t$ 个数有序时，只需要判断不大于 $\sqrt{nm}$ 的数。

---
令 $cnt$ 为这 $t$ 个数去重之后的个数，当 $cnt$ 的值较大时，每次找到一组 $(x,y)(x\neq y)$ 时都要计算 

$p=(\prod_{i=0}^{h[i]<x}mp[h[i]]!)\times (mp[x]-1)!\times(\prod_{x<h[i]}^{h[i]<y}mp[h[i]]!)\times(mp[y]-1)!\times(\prod_{y<h[i]}^{cnt-1}mp[h[i]]!)$ 

当 $(x,x)$ 满足条件时需要计算 

$p=(\prod_{i=0}^{h[i]<x}mp[h[i]]!)\times(mp[x]-2)!\times(\prod_{x<h[i]}^{cnt-1}mp[h[i]]!)$ 

此处的时间复杂度为 $O(t\sqrt t)$，直接超时。

---
不妨利用**前缀和**的思想，令 $k=\prod_{i=0}^{m-1} mp[h[i]]!$ 

当 $x\neq y$ 时 $p=k\times(mp[x]-1)!\times(mp[y]-1)!\div mp[x]!\div mp[y]!$ 

当 $x=y$ 时 $p=k\times(mp[x]-2)!\div mp[x]!$，此处的时间复杂度为 $O(\sqrt t)$，可以接受。
## Code
```cpp
#include <iostream>
#include <cmath>

#define ll long long
#define N 500000
#define mod 1000000007

using namespace std;

ll qpow(ll a, ll b) {
	ll res = 1ll;
	while(b) {
		if(b & 1) res *= a, res %= mod;
		b >>= 1, a *= a, a %= mod;
	}
	return res;
}

ll fact[N + 1] = {1, 1};
ll inv[N + 1] = {1, 1};

void init() {
	for(int i = 2; i <= N; ++i) {
		fact[i] = fact[i - 1] * i % mod;
	}
    inv[N] = qpow(fact[N], mod - 2);
    for(int i = N; i > 0; --i) {
        inv[i - 1] = inv[i] * i % mod;
    }
}

int h[N + 1];
int mp[N + 1];

int main() {

	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);

	init();

	int t, nm;
	cin >> t, nm = t - 2;
	
	for(int i = 0, v; i < t; ++i) {
		cin >> v, ++mp[v];
	}

	int cnt = 0;
	for(int i = 1; i <= N; ++i) {
		if(mp[i] != 0) h[cnt++] = i;
	}

	ll k = 1ll;
	for(int i = 0; i < cnt; ++i) {
		k *= inv[mp[h[i]]], k %= mod;
	}

	ll sum = 0ll, tmp;
	int q = sqrtl(nm);

    if(q * q == nm && mp[q] > 1) {			
		tmp = fact[nm] * fact[mp[q]] % mod;
		tmp *= k * inv[mp[q] - 2] % mod;
        sum += tmp, sum %= mod, --q;
	}

	for(int i = 0, x, y; (x = h[i]) <= q && i < cnt; ++i) {		
		if(nm % x != 0 || mp[y = nm / x] == 0) continue;
		tmp = (fact[nm] * fact[mp[x]] % mod) * fact[mp[y]] % mod;
		tmp *= (k * inv[mp[x] - 1] % mod) * inv[mp[y] - 1] % mod;
		sum += tmp << 1, sum %= mod;
	}

	cout << sum;

	return 0;
}
```

---

## 作者：Sakura_Emilia (赞：0)

# Solution

分组排列问题。

虽然说题目中直接给出的是一个矩阵，但由于各个位置都不同，本质上还是一个线性全排列问题。

对于 $n$ 个数，分为若干个分组。需要将这 $n$ 个数进行全排列，对于同一个组内的排列次序不做区分，一个组内的元素视为相同的。问有多少种不同的排列方式？

仅需计算 $n$ 的阶乘，计算各个分组内元素个数的阶乘，再使用 $n$ 的阶乘整除以这些各组阶乘的乘积即可。

对于阶乘，参考组合数的计算，可以使用数组来预处理，提前存储阶乘的值。最后仅需统计各组中的元素个数即可。

这里特别需要注意，对于所有分组元素个数阶乘的乘积，可以直接提前预处理所有分组的乘积，然后单独的处理被选出来作为矩阵长和宽的组即可。具体的实现细节见下面的代码。

# Code

```cpp
#include <bits/stdc++.h>
#define Ciallo main
#define int long long
using namespace std;
const int N = 5e5 + 8;
const int mod = 1000000007;

inline int read() {
    int _x = 0, _w = 1;
    char ch = 0;
    while(ch < '0' || ch > '9') {
        if(ch == '-') _w = -1;
#ifdef __linux__
        ch = (char)getchar_unlocked();
#else
        ch = (char) _getchar_nolock();
#endif
    }
    while(ch >= '0' && ch <= '9') {
        _x = (_x << 3) + (_x << 1) + (ch - '0');
#ifdef __linux__
        ch = (char)getchar_unlocked();
#else
        ch = (char) _getchar_nolock();
#endif
    }
    return _x * _w;
}

inline void write(int _x) {
    if(_x < 0) {
#ifdef __linux__
        putchar_unlocked('-');
#else
        _putchar_nolock('-');
#endif
        _x = -_x;
    }
    static int _sta[130];
    int _top = 0;
    do {
        _sta[_top++] = _x % 10, _x /= 10;
    } while(_x);
    while(_top)
#ifdef __linux__
        putchar_unlocked(_sta[--_top] + 48);
    putchar_unlocked('\n');
#else
        _putchar_nolock(_sta[--_top] + 48);
    _putchar_nolock('\n');
#endif
}

vector<int> p;
int n, t, sum, res;
int a[N], cnt[N];
int fact[N], infact[N];

int qmi(int _a, int _b, int _p) {
    int _res = 1;
    while(_b) {
        if(_b & 1)
            _res = _res * _a % _p;

        _a = _a * _a % _p;
        _b >>= 1;
    }
    return _res;
}

void init() {
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i++) {
        fact[i] = fact[i - 1] * i % mod;
        infact[i] = infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
}

signed Ciallo() {
    init();
    n = read();
    for(int i = 1; i <= n; i++) {
        t = read();
        if(cnt[t] == 0) {
            sum++;
            p.push_back(t);
        }
        cnt[t]++;
    }

    sort(p.begin(), p.end());
    int M = fact[n - 2];
    for(int j = 0; j < sum; j++)
        M = M * infact[cnt[p[j]]] % mod;

    for(int i = 0; i < sum; i++) {
        if((n - 2) % p[i] == 0 and cnt[(n - 2) / p[i]] > 0) {
            int tem = M;
            if(p[i] * p[i] == n - 2)
                tem = tem * fact[cnt[p[i]]] % mod * infact[cnt[p[i]] - 2] % mod;
            else {
                tem = tem * fact[cnt[p[i]]] % mod * infact[cnt[p[i]] - 1] % mod;
                tem = tem * fact[cnt[(n - 2) / p[i]]] % mod * infact[cnt[(n - 2) / p[i]] - 1] % mod;
            }
            res = (res + tem) % mod;
        }
    }

    write(res);

    return 0;
}
```

---

## 作者：断清秋 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12142)

蓝桥 E 题。赛时多测没清空，搞笑了。


考虑对一个 $n \times m$ 的矩阵，首先如果每个数都不同的话总方案数肯定是 $(nm)!$ 的。

然后如果同一个数重复出现了 $c$ 次那么方案数就要除以 $c!$ 。

可以先把阶乘和逆元预处理出来，然后找到所有合法的 $n,m$ 即可，注意 $n,m$ 出现次数要减一。当然由于合法的取值最多 $O(\sqrt{nm})$ 级别，每次快速幂求逆元也是可以的。 

注意阶乘要处理到 $nm+2$ 而不是 $nm$，否则会被如下小数据卡掉。


```cpp
//Hack
3
1 1 1
```


时间复杂度 $O(nm)$。

---


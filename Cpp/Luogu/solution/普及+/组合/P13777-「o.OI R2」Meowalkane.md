# 「o.OI R2」Meowalkane

## 题目背景

猫猫晒太阳的时候会进行光合作用吗？

众所周知，烷烃与氯气在一定条件（如光照）下会发生取代反应，生成氯代烃，比如甲烷在光照条件下会生成一氯甲烷、二氯甲烷、三氯甲烷（氯仿）和四氯甲烷（四氯化碳）。

显然在这么多生成物中最多的是 HCl。

## 题目描述

小 μ 是一只猫猫，它正在学习有机化学。它现在想知道正 $n$ 烷理论上（不考虑现实中是否有可能存在）有多少种 $k$ 氯代物（如乙烷有 1,1-二氯乙烷和 1,2-二氯乙烷共两种二氯代物）。由于这个数字可能很大，所以小 μ 只想知道这个数除以 $998244353$ 的余数。但是小 μ 不会算，请你帮帮它吧。

#### 形式化题意

求本质不同的整数数组 $A_{1\sim n}$ 的数量对 $998244353$ 取模的结果，要求满足如下条件：

- 若 $n=1$，则 $A_n\in[0,4]$；
- 若 $n>1$，则 $A_1,A_n\in[0,3]$；$\forall i\in[2,n-1]$，$A_i\in[0,2]$；
- $\sum A_i=k$。

定义两个数组 $A,B$ 本质不同当且仅当 $\exist i\in[1,n],A_i\ne B_i$ 且 $\exist i\in[1,n],A_i\ne B_{n-i+1}$。

## 说明/提示

**本题采用捆绑测试。**

对于所有测试数据，保证：

$1\le t\le 10$，$1\le n\le 10^6$，$\sum n\le 10^6$，$1\le k\le 2n+2$。

| 子任务 | $n$ | $k$ | 分值 |
| :-: | :-: | :-: | :-: |
| $0$ | $\le 3$ | $\le8$ | $8$ |
| $1$ |  | $=1$ | $4$ |
| $2$ |  | $=2n+1$ | $4$ |
| $3$ |  | $=2$ | $8$ |
| $4$ | $\le 15$ |  | $16$ |
| $5$ | $\le 1000$ |  | $20$ |
| $6$ |  |  | $40$ |

## 样例 #1

### 输入

```
5
3 4
388 1
833 1667
3388 2
555301 723238```

### 输出

```
6
194
417
2871330
933338738```

# 题解

## 作者：fish_love_cat (赞：6)

不会组合数学被打爆了 /fad

---

特判 $n\le 2$。

考虑枚举端点，组合数计数。

不考虑反向，我们枚举往里面填多少个 $2$，然后可以算出 $1$ 和 $0$ 的数量，排列组合一下即可。

一般情况会被统计两次，除掉即可。

考虑正确统计的特殊情况，我们发现其一定是回文串。

于是再根据元素数量插板求出回文串数量，强行给它统计两遍，最后统一做除法即可。

做完了。代码粘了板子所以看上去很糖。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
#define flc_INF LLONG_MAX
int qpow(int a,int b,int p=mod){
	int ans=1;
	if(b==0)return 1;
	while(b){
		if(b&1)ans*=a,ans%=p;
		a*=a,b>>=1,a%=p;
	}
	return ans;
}
long long A[5000005],inv[5000005];
void exgcd(int a,int b,int &x,int &y){
    if(b){
        exgcd(b,a%b,x,y);
        int flc=x;
        x=y;
        y=flc-a/b*y;
    }else x=1,y=0;
}
int ni(int a,int p){
    int x=0,y=0;
    exgcd(a,p,x,y);
    x=(x%p+p)%p;
    return x;
}
int C(int n,int m){
    return (A[n]*inv[m]%mod*inv[n-m]%mod);
}
void init_of_C(int N){
    A[0]=A[1]=1;
    for(int i=2;i<=N;i++)
    A[i]=A[i-1]*i%mod;
    for(int i=0;i<=N;i++)
    inv[i]=ni(A[i],mod);
}
void solve(){
    int n,k;
    cin>>n>>k;
    if(n==1){
        puts("1");
        return;
    }
    if(n==2){
        int ans=0;
        for(int i=0;i<=k-i&&i<=3;i++)ans+=(k-i<=3);
        cout<<ans<<'\n';
        return;
    }
    if(k==1||k==2*n+1){
        cout<<(n+1)/2<<'\n';
        return;
    }
    int ans=0;
    for(int i=0;i<=3;i++)
    for(int j=0;j<=3;j++)
    if(i+j<=k)
    for(int e=max(0ll,k-i-j+2-n);2*e<=k-i-j;e++){
        ans+=C(n-2,e)*C(n-2-e,k-i-j-2*e)%mod;
        ans%=mod;
        int flc=(k-i-j-2*e);
        int c=n-flc-e-2;
        int E=e;
        if(i==j&&((flc&1)+(c&1)+(e&1)<=1)){
            flc/=2;
            c/=2;
            E/=2;
            ans+=C(flc+c,flc)*C(flc+c+E,E)%mod;
            ans%=mod;
        }
    }
    cout<<ans*inv[2]%mod<<'\n';
}
signed main(){
    init_of_C(3000000);
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
// 信じた星の行方を見失いそうになっても
// わたしが必ず迎えにゆくから

// 沉默魔女的秘密 OP「Feel」
```

感觉甚至小于 T2？

---

## 作者：dingxiongyue (赞：2)

# 题解：P13777 「o.OI R2」Meowalkane

## 思路：

首先想到求：
$$
[x^k][(1+x+x^2+x^3)^2\cdot(1+x+x^2)^{n-2}]
$$
发现这样会将所有**非回文串**多算一次，考虑加上一次回文串的数量。

回文串的数量为：
$$
[x^k][(1+x^2+x^4+x^6)\cdot(1+x^2+x^4)^{\frac{n-(2+n\bmod2)}{2}}\cdot(1+x+x^2)^{n\bmod2}]
$$

* 所有序列：

  $(1+x+x^2+x^3)^2$ 的次数只有 $2$，所以可以分别枚举两端选多少，只需要快速求得 $[x^k](1+x+x^2)^m$。

  考虑 $1、x、x^2$ 分别对 $x^k$ 贡献 $0、1、2$，所以上式即为：
  $$
  \sum _ {\substack{a+b+c=m\\b+2c=k}} \frac{m!}{a!b!c!}
  $$
  枚举 $c$ 即可。

* 回文串：

  同样枚举两端选多少，当 $n$ 为奇数时需要多枚举一个最中间的点选多少，求 $[x^k](1+x^2+x^4)^m$ 同理：
  $$
  \sum _ {\substack{a+b+c=m\\2b+4c=k}} \frac{m!}{a!b!c!}
  $$



$n=1$ 时需要**特判**。

## 代码：

[AC记录]((https://www.luogu.com.cn/record/232123239))  

```cpp
#include <iostream>

#define int long long
const int N = 1e6 + 10, mod = 998244353;
int T;
int n, k;
int fac[N], ifac[N];
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}

inline void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int calc1(int m,int k){
    // [x^k](1+x+x^2)^m
    int ans = 0;
    for(int c = 0; c <= m && (c << 1) <= k; c++){
        int b = k - 2 * c;
        if(b < 0 || b > m - c) continue;
        int a = m - b - c;
        if(a < 0) continue;
        int tmp = fac[m] * ifac[a] % mod * ifac[b] % mod * ifac[c] % mod;
        ans = (ans + tmp) % mod;
    }
    return ans;
}

int calc2(int m,int k){
    // [x^k](1+x^2+x^4)^m
    int ans = 0;
    for(int c = 0; c <= m; c++){
        int rst = k - 4 * c;
        if(rst < 0) break;
        if(rst % 2) continue;
        int b = rst / 2;
        if(b > m - c) continue;
        int a = m - b - c;
        if(a < 0) continue;
        int ways = fac[m] * ifac[a] % mod * ifac[b] % mod * ifac[c] % mod;
        ans = (ans + ways) % mod;
    }
    return ans;
}

int calc3(int n, int k){
    if(n == 1)
        return (0 <= k && k <= 4) ? 1 : 0;
    int ans = 0;
    for(int a = 0; a <= 3; a++) 
        for(int b = 0; b <= 3; b++){
        int rem = k - a - b;
        if(rem < 0) continue;
        ans = (ans + calc1(n - 2, rem)) % mod;
    }
    return ans;
}

int calc4(int n, int k) {
    if(n == 1)
        return (0 <= k && k <= 4) ? 1 : 0;
    int ans = 0;
    if(n % 2 == 0) {
        for(int i = 0;i <= 3; i++){
            int j = 2 * i;
            ans = (ans + calc2((n - 2) / 2, k - j)) % mod;
        }
    } else {
        for(int i = 0; i <= 3; i++){
            for(int mid = 0; mid <= 2; mid++){
                int rem = k - 2 * i - mid;
                if (rem < 0) continue;
                ans = (ans + calc2((n - 3) / 2, rem)) % mod;
            }
        }
    }
    return ans;
}

int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i <= 1000000; i++) 
        fac[i] = fac[i - 1] * i % mod;
    ifac[1000000] = qpow(fac[1000000], mod - 2);
    for (int i = 999999; ~i; i--) 
        ifac[i] = ifac[i + 1] * (i + 1) % mod;
}

signed main() {
    T = read();
    init();
    while (T--) {
        n = read(), k = read();
        // std::cout << calc3(n, k);
        write((calc3(n, k) + calc4(n, k)) % mod * qpow(2, mod - 2) % mod);
        putchar('\n');
    }
    return 0;
} 
```

---

## 作者：nbhs23a28 (赞：1)

一道经典组合计数题，下面我来提供一种不基于容斥（[官方题解](https://www.luogu.me/article/0y23rtjn)）的简单做法。

分析题面，可以发现这是一道计数问题，但它关于“本质不同”有特殊规定，即 $\exist i\in[1,n],A_i\ne B_{n-i+1}$。考虑如何搞定这一条件，注意到当数组回文时，不存在其他数组与它本质相同，否则一定恰好存在一个其他数组与它本质相同，于是，记不考虑对称性质的数组数为 $cnt1$，回文的数组数为 $cnt2$，我们发现答案就是 $(cnt1+cnt2)/2$。

处理好这一问题后，接下来我们考虑如何求 $cnt1$ 和 $cnt2$。注意到本题 $n\le 10^6$ 计数 DP 复杂度会炸，于是我们考虑直接用组合数学线性求解。当 $n=1$ 时，答案显然为 $1$；当 $n\ne 1$ 时我们可以先枚举约束条件与其他不一致的 $A_1,A_n$，然后考察其他数的性质。注意到其他数的取值只有 $3$ 种，我们不妨采用替换（调整）的思想，先钦定一种具有尽可能多 $1$ 的组合方案，然后把每 $2$ 个 $1$ 替换成 $0$ 和 $2$，容易证明得到的即为所有组合方案。接下来我们由这些组合方案导出排列方案数。我们知道，多重集的排列方案数可以表示为 
$\displaystyle \frac{N!}{n_1! \cdot  n_2! \cdot  \cdots \cdot n_k!}$，故我们可以轻松地在线性时间内由组合方案推知排列方案数（这边处理模意义下的除法求逆元需要预处理，否则由于常数本就大加一个 $\log$ 还不炸），对于回文情况，我们把前后对称的捆绑起来算就行。

::::success[Code]
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int n,k;
long long fac[1000010],ny[1000010],f,f2;
long long qp(long long x,long long y)
{if(y==0) return 1;
 if(y==1) return x;
 long long sum=qp(x,y>>1);
 if(y&1) return sum*sum%mod*x%mod;
 return sum*sum%mod;
}
int main()
{ios::sync_with_stdio(0);cin.tie(0);
 int t;cin>>t;fac[0]=1;ny[0]=1;
 for(int i=1;i<=1e6;i++)
 {fac[i]=fac[i-1]*i%mod;
  ny[i]=qp(fac[i],mod-2);
 }
 while(t--)
 {cin>>n>>k;
  if(n==1){cout<<"1\n";continue;}
  f=f2=0;
  for(int i=0;i<=3;i++)
  {for(int j=0;j<=3;j++)
   {int cntt=abs(k-i-j-(n-2));//初始2(0)的个数
    if(cntt>n-2) continue;
    for(int l=0;l<=(n-2-cntt)/2;l++)
    f=(f+fac[n-2]*ny[l]%mod*ny[cntt+l]%mod*ny[n-2-cntt-2*l])%mod;
   }   
  }
  for(int i=0;i<=2*(n&1);i++)
  {for(int j=0;j<=6;j+=2)
   {int nn=(n-2)/2;
    if((k-i-j)%2!=0) continue;
    int cntt=abs(k-i-j-nn*2)/2; 
    if(cntt>nn) continue;
    for(int l=0;l<=(nn-cntt)/2;l++)
    f2=(f2+fac[nn]*ny[l]%mod*ny[cntt+l]%mod*ny[nn-cntt-2*l])%mod;
   }
  }
  long long ans=(f+f2)*qp(2,mod-2)%mod;
  cout<<ans<<'\n';
 } 
}

---

## 作者：Drifty (赞：1)

提供一个不咋用脑子的推导。

首先 $n = 1$ 答案为 $1$。

然后我们注意到答案就是 $\frac{所有方案数+回文序列方案数}{2}$，这个理解是容易的。

我们考虑算非回文序列方案数。

实际上这是很经典的多项式问题，即 $\sum x_i = t$，然后 $x_i$ 有一些不等式约束。

那么我们把所有方案数的生成函数写出来，对于首尾我们有：

$$
1 + x + x^2 + x^3
$$

对于中间我们有：

$$
1 + x + x^2
$$

乘起来得到：

$$
f(x) = (x^3 + x^2 + x + 1)^2(x^2 + x + 1)^{n - 2}
$$

那么我们求的就是 $[x^k]f(x)$。

接下来来处理回文串的方案数，我们考虑奇偶分讨。

- 当 $n$ 为偶数时，若 $k$ 为奇数显然答案为 $0$，否则我们直接让 $n, k$ 减半，并求出对于减半过后的所有方案数。
- 当 $n$ 为奇数时，我们枚举中心点 $A_{(n + 1) / 2} = 0, 1, 2$，并求出对于 $n, k - A_{(n + 1) / 2}$ 减半过后的所有方案数。

于是问题就规约成了求所有方案数。

我们考虑如何求 $[x^k]f(x)$，一个直接的想法是多项式求幂，直接 $\ln$ 然后 $\exp$。但是这样发现不太能跑。我们进行一些小小的推导：

$$
\begin{aligned}
g(x) &= (1 + x + x^2)^{n - 2} \\
&= \left ( \frac{1 - x^3} {1 - x}\right )^{n - 2} \\
&= (1 - x^3)^{n - 2}\times 
\left(\sum_{i = 0}^{\infin} x^i\right)^{n - 2}
\end{aligned}
$$

然后这个东西的第一项可以用二项式展开，即 $[x^p](1 - x^3)^{n - 2} = (-1)^{n - 2 - 3p} \binom{n - 2}{p}$。

第二项就是 $n - 2$ 阶前缀和，即 $[x^p](1 - x)^{2 - n} = \binom{n + p - 3}{n - 3}$。

然后我们直接对这两项做卷积就行了：

$$
[x^k]g(x) = \sum_{j=0}^{\lfloor \frac{k}{3}\rfloor}(-1)^j\binom{n - 2}{j}\binom{n+s-3j-3}{n-3}
$$

然后剩下还有一些余项，都是常数级别的，暴力卷积即可。

时间复杂度 $\mathcal{O}(Tn)$。


::::info[Code]

```cpp
#include <bits/stdc++.h>

using namespace std;

template <std::uint32_t P> struct MontgomeryModInt32 {/*略*/};

using mint = MontgomeryModInt32 <998244353> ;
using i64 = long long;
constexpr int N = 2.5e6 + 3;

mint fac[N], ifac[N];

void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i <= n; i ++) fac[i] = fac[i - 1] * i;
  ifac[n] = 1 / fac[n];
  for (int i = n - 1; i; i --)  ifac[i] = ifac[i + 1] * (i + 1);
}

mint C(int n, int m) {
  if (n < m) return 0;
  return fac[n] * ifac[m] * ifac[n - m];
}

mint f(int n, int i) {
  if (n == 0) return mint(i == 0);
  if (i < 0) return 0;
  if (i > 2 * n) return 0;
  mint res = 0;
  for (int j = 0; j <= min(n, i / 3); j ++)
    if (j & 1) res -= C(n, j) * C(n + i - 3 * j - 1, n - 1);
    else res += C(n, j) * C(n + i - 3 * j - 1, n - 1);
  return res;
}

int main() {
  cin.tie(nullptr) -> sync_with_stdio(false);
  int T;
  cin >> T;
  init(N - 1);
  while (T --) {
    int n, k;
    cin >> n >> k;
    if (n == 1) {
      cout << 1 << '\n';
      continue;
    }
    mint ans = 0;
    constexpr array <mint, 7> id = {1, 2, 3, 4, 3, 2, 1};
    for (int i = 0; i < 7; i ++) {
      ans += f(n - 2, k - i) * id[i];
    }
    if (n & 1) {
      for (int i : {0, 1, 2}) {
        if (!((k - i) & 1))
        for (int j : {0, 1, 2, 3}) {
          ans += f(n / 2 - 1, (k - i) / 2 - j);
        }
      }
    }
    else {
      if ((k + 1) & 1)
      for (int j : {0, 1, 2, 3})
        ans += f(n / 2 - 1, k / 2 - j);
    }
    cout << ans / 2 << '\n';
  }
  return 0;
}
```

::::

---

## 作者：dongzirui0817 (赞：1)

显然 $n = 1$ 时答案为 $1$。下面考虑 $n > 1$。

注意到本质不同的定义非常烦，它其实就是两个数组不能相等，且翻转其中之一后也不相等。

所以成立的数组数要除以 $2$，因为翻转后也是一种方案。

但是有特殊情况的，就是回文数组。因为翻转后就是它本身。所以只要多考虑这种情况就可以了。

- - -

注意到中间的数范围都在 $[0, 2]$ 中，所以可以设 $f(u, v)$ 表示满足：

- $\forall i \in [1, u]$，$c_i \in [0, 2]$。
- $\sum c_i = v$。

的 $c$ 数组的方案数。

$g(u, v)$ 表示满足 $f(u, v)$ 条件的所有 $c$ 数组中回文数组的个数。

那么分 $3$ 种情况讨论：

1. $A_1, A_n < 3$。  
此时就是求本质不同的数组，其中 $\forall i \in [1, n]$，$A_i \in [0, 2]$ 且和为 $k$。显然答案为 $\frac{f(n, k) + g(n, k)}2$。

2. $A_1$ 与 $A_n$ 中有且仅有一个数为 $3$。  
此时答案为 $f(n - 1, k - 3)$，因为去掉等于 $3$ 的数后就变成了情况一。  
谁等于 $3$ 不重要。因为这种情况下，$A$ 不可能回文。严谨来说，当 $A_n = 3$ 时，$A$ 数组翻转后就变成了 $A_1 = 3$，会重复计算。

3. $A_1 = A_n = 3$。  
去掉了 $A_1$ 与 $A_n$ 后就变成了情况一，答案为 $\frac{f(n - 2, k - 6) + g(n - 2, k - 6)}2$。

- - -

现在来看 $f$ 和 $g$ 怎么算。

先看 $f$。显然当 $n < 0 \lor k < 0$ 时为 $0$。

否则设 $a, b, c$ 分别表示 $A$ 中 $0, 1, 2$ 的个数。则有方程组：

$$
\begin{cases}
  a + b + c = u\\
  b + 2c = v
\end{cases}
$$

解得：

$$
\begin{cases}
  b = 2u - v - 2a\\
  c = v + a - u
\end{cases}
$$

显然 $a \in \N$，则求出的 $b, c \in \Z$。那么只需判一下 $b, c$ 非负即可。  
如果 $a, b, c \in \N$，则该情况对答案的贡献为 $\dbinom{u}{a} \cdot \dbinom{u - a}{b}$。

最后只需在 $[0, u]$ 的范围内枚举 $a$，累加答案即可。

- - -

求 $g(u, v)$ 的方法与求 $f(u, v)$ 的方法差不多。当枚举 $a$，求出 $b, c$ 后，答案贡献这么算。

- 当 $u$ 为奇数时。

此时 $a, b, c$ 一定要当且仅当有一个奇数，不然没有贡献。

否则最中间的数一定是 $a, b, c$ 中的那个奇数所代表的数（分别对应 $0, 1, 2$）。之后转化成：
> 在 $\frac{u-1}2$ 中分别填入 $\frac a 2$ 个 $0$，$\frac b 2$ 个 $1$ 和 $\frac c 2$ 个 $2$，求方案数。

显然贡献为 $\dbinom{\frac{u-1}2}{\frac a2} \cdot \dbinom{\frac{u-1}2 - \frac a2}{\frac b2}$。

- 当 $u$ 为奇数时。

此时 $a, b, c$ 要都是偶数，否则没有贡献。

那么问题转化成：

> 在 $\frac u2$ 中分别填入 $\frac a 2$ 个 $0$，$\frac b 2$ 个 $1$ 和 $\frac c 2$ 个 $2$，求方案数。

显然贡献为 $\dbinom{\frac u2}{\frac a2} \cdot \dbinom{\frac u2 - \frac a2}{\frac b2}$。

- - -

讲了这么多，来讲讲实现吧。

求组合数直接逆元，对于算答案时的除以 $2$ 也用逆元。

时间复杂度 $O(\max n \log P)$，其中 $P = 998244353$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int p = 998244353, Inv2 = (p + 1) / 2;
ll fac[1000010] = {1}, inv[1000010] = {1};

ll Inv(ll x) {
	return x < 2 ? x : (p - p / x) * Inv(p % x) % p;
}

int T, n, k;

ll C(int x, int y) {
	if (y > x) return 0;
	return fac[x] * inv[y] % p * inv[x - y] % p;
}

ll f(int n, int k) {
	if (k < 0 || n < 0) return 0;
	ll ans = 0;
	for (int a = 0 ; a <= n ; a++) {
		int b = 2 * n - k - 2 * a;
		int c = k + a - n;
		if (b < 0 || c < 0) continue;
		ans = (ans + C(n, a) * C(n - a, b) % p) % p;
	}
	return ans;
}

ll g(int n, int k) {
	if (k < 0 || n < 0) return 0;
	ll ans = 0;
	for (int a = 0 ; a <= n ; a++) {
		int b = 2 * n - k - 2 * a;
		int c = k + a - n;
		if (b < 0 || c < 0) continue;
		if (n % 2) {
			if (a % 2 && !(b % 2))
                ans = (ans + C(n / 2, a / 2) * C(n / 2 - a / 2, b / 2)) % p;
			if (b % 2 && !(a % 2))
                ans = (ans + C(n / 2, b / 2) * C(n / 2 - b / 2, a / 2)) % p;
			if (c % 2 && !(b % 2))
                ans = (ans + C(n / 2, c / 2) * C(n / 2 - c / 2, b / 2)) % p;
		} else if (a % 2 == 0 && b % 2 == 0 && c % 2 == 0)
			ans = (ans + C(n / 2, a / 2) * C(n / 2 - a / 2, b / 2)) % p;
	}
	return ans;
}

int main() {
	for (int i = 1 ; i <= 1e6 ; i++)
		fac[i] = fac[i - 1] * i % p, inv[i] = Inv(fac[i]);
	cin >> T;
	for ( ; T-- ; ) {
		cin >> n >> k;
		if (n == 1) {
			puts("1");
			continue;
		} else cout << ((f(n, k) + g(n, k)) % p * Inv2 % p + f(n - 1, k - 3) + (f(n - 2, k - 6) + g(n - 2, k - 6)) % p * Inv2 % p) % p << endl;
	}
	return 0;
}
```

---

## 作者：枫原万叶 (赞：0)

**前置知识**

[生成函数](https://oi-wiki.org/math/poly/ogf/)  [容斥原理](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/) [Burnside 引理 / Pólya 计数定理](https://oi-wiki.org/math/combinatorics/polya/)

题目大意是计算正 $n$ 烷的 $k$ 氯代物的理论种类数，考虑其对称性（即数组与其反转后相同，下文将会一直用这个说法）。具体来说，给定 $n$ 和 $k$，求满足以下条件的整数数组 $A_{1 \sim n}$ 的数量：

- 若 $n = 1$，则 $A_1 \in [0,4]$。

- 若 $n > 1$，则 $A_1,A_n \in [0,3]$，且对于 $i \in [2,n-1]$，有 $A_i \in [0,2]$。

- 所有 $A_i$ 的和为 $k$。

- 两个数组本质不同当且仅当它们不是完全相同也不是具有对称性的。

由于对称性，我们可以使用 [Burnside 引理](https://oi-wiki.org/math/algebra/group-theory/#burnside-%E5%BC%95%E7%90%86) 来处理。这里大致解释一下详细可以看 OI-wiki，等价类的数量等于所有群元素作用下不动点的平均数。这里的群是二阶循环群 $C_2$，包含恒等和反转操作。因此，总放案数 $F(n,k)$ 是所有满足条件的数组数量，$G(n,k)$ 是对称数组的数量。最终答案为 $\frac{F(n,k)+G(n,k)}{2}$。

现在考虑 $F(n,k)$：所有满足条件的数组数量。

对于 $n=1$，直接检查 $k$ 是否在 $[0,4]$ 范围内，是则函数值为 1，反之为 0。

对于 $n>1$，数组有 $n$ 个位置，其中两端位置取值范围为 $[0,3]$，中间位置的取值范围为 $[0,2]$。通过生成函数和容斥原理可以得到：

$F(n,k) = \sum_{j=0}^{\min(n-2, \lfloor k/3 \rfloor)} \binom{n-2}{j} (-1)^j \left[ \binom{n+k-3j-1}{k-3j} - 2 \binom{n+k-3j-5}{k-3j-4} + \binom{n+k-3j-9}{k-3j-8} \right]$

其中，组合数 $\begin{pmatrix}a\\b\end{pmatrix}$ 在 $b<0$ 或 $b>a$ 时为 0。

现在考虑 $G(n,k)$：对称数组的数量。

对称数组要求 $A_i=A_{n-i+1}$ 对于所有 $i$。需要根据 $n$ 的奇偶性分别处理。

当 $n$ 为偶数时：

令 $m=\frac{n}{2}-1$。易得：

$G(n,k) = \sum_{i=0}^{m} \binom{m}{i} (-1)^i \left[ \binom{m + \frac{k-6i}{2}}{\frac{k-6i}{2}} - \binom{m + \frac{k-6i-8}{2}}{\frac{k-6i-8}{2}} \right]$

仅当 $k-6i$ 和 $k-6i-8$ 为偶数时计算，否则项为 0。

当 $n$ 为奇数时：

令 $m=\frac{n-3}{2}$。预处理数组 $S$，其中 $S_{t} = \sum_{a=0}^{\lfloor t/2 \rfloor} \binom{m+a}{a}$。易得：

$G(n,k) = \sum_{i=0}^{m} \binom{m}{i} (-1)^i \left[ S_{k-6i} - S_{k-6i-3} - S_{k-6i-8} + S_{k-6i-11} \right]$

其中，$S_{t}$ 在 $t<0$ 时为 0。

最后把这两个函数带入到开头的那个式子再取模即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL M=998244353;
const int N=3e7+5; // 预计算范围，要足够大

LL f[N+10],iv[N+10]; // 阶乘数组和阶乘逆元数组

// 快速幂算法
LL pw(LL a,LL b){
	LL r=1;
	a%=M;
	for(;b;b>>=1){
		if(b&1)r=r*a%M;
		a=a*a%M;
	}
	return r;
}

// 预计算阶乘和阶乘逆元
void pre(){
	f[0]=1;
	for(int i=1;i<=N;i++)f[i]=f[i-1]*i%M;
	iv[N]=pw(f[N],M-2);
	for(int i=N-1;i>=0;i--)iv[i]=iv[i+1]*(i+1)%M;
}

// 组合数计算函数
LL C(LL n,LL k){
	if(k<0||k>n)return 0;
	return f[n]*iv[k]%M*iv[n-k]%M;
}

int main(){
	pre(); // 预处理阶乘和逆元
	LL i2=pw(2,M-2); // 2的模逆元，用于除以2
	int T;
	cin>>T;
	while(T--){
		LL n,k;
		cin>>n>>k;
		if(n==1){ // n=1的特殊情况
			cout<<(k>=0&&k<=4)<<endl;
			continue;
		}
		
		// 计算F(n,k)：所有满足条件的数组数量（不考虑对称性）
		LL F=0;
		LL jm=min(n-2,k/3); // 容斥的上界
		for(LL j=0;j<=jm;j++){
			LL s=(j%2==0)?1:-1; // 容斥系数(-1)^j
			LL c=C(n-2,j)*s%M;
			if(c<0)c+=M;
			
			// 三项容斥计算
			LL t1=3*j;
			if(t1<=k){
				LL p=n+k-t1-1;
				F=(F+c*C(p,k-t1))%M;
			}
			
			LL t2=3*j+4;
			if(t2<=k){
				LL p=n+k-t2-1;
				F=(F-2*c*C(p,k-t2))%M;
			}
			
			LL t3=3*j+8;
			if(t3<=k){
				LL p=n+k-t3-1;
				F=(F+c*C(p,k-t3))%M;
			}
		}
		F%=M;
		if(F<0)F+=M;
		
		// 计算G(n,k)：对称数组的数量
		LL G=0;
		if(n%2==0){ // n为偶数的情况
			LL m=n/2-1;
			for(LL i=0;i<=m;i++){
				if(6*i>k)break;
				LL s=(i%2==0)?1:-1; // 容斥系数(-1)^i
				LL c=C(m,i)*s%M;
				if(c<0)c+=M;
				
				// 两项容斥计算
				LL t1=6*i;
				if(t1<=k&&(k-t1)%2==0){
					LL jv=(k-t1)/2;
					G=(G+c*C(m+jv,jv))%M;
				}
				
				LL t2=6*i+8;
				if(t2<=k&&(k-t2)%2==0){
					LL jv=(k-t2)/2;
					G=(G-c*C(m+jv,jv))%M;
				}
			}
			G%=M;
			if(G<0)G+=M;
		}else{ // n为奇数的情况
			LL m=(n-3)/2;
			int Tm=2*n+2+20; // 前缀和数组大小
			vector<LL>S(Tm+1,0);
			S[0]=1;
			// 预处理前缀和数组S
			for(int t=1;t<=Tm;t++){
				if(t%2==0){
					LL a=t/2;
					S[t]=(S[t-1]+C(m+a,a))%M;
				}else{
					S[t]=S[t-1];
				}
			}
			
			// 四项容斥计算
			for(LL i=0;i<=m;i++){
				if(6*i>k+11)break;
				LL s=(i%2==0)?1:-1;
				LL c=C(m,i)*s%M;
				if(c<0)c+=M;
				
				if(6*i<=k)G=(G+c*S[k-6*i])%M;
				if(6*i+3<=k)G=(G-c*S[k-6*i-3])%M;
				if(6*i+8<=k)G=(G-c*S[k-6*i-8])%M;
				if(6*i+11<=k)G=(G+c*S[k-6*i-11])%M;
			}
			G%=M;
			if(G<0)G+=M;
		}
		
		// 根据Burnside引理计算最终答案
		LL ans=(F+G)*i2%M;
		cout<<ans<<endl;
	}
	return 0;
}
```

这篇文章凹了笔者一个晚上，而且笔者也是第一次接触这些知识点，很多都是通过资料查阅的，难免有错误之处希望大家能在评论区指出。

---

## 作者：cheng2010 (赞：0)

不会**经典容斥**。

注：以下的除法默认向下取整。

考虑 $n>1$ 的情况，利用生成函数，总答案易得为 $(\frac{1-x^4}{1-x})^2(\frac{1-x^3}{1-x})^{n-2}$ 的展开式的 $k$ 次项系数除上 $2$，吗？

不对，还有回文！于是要枚举一半的方案 $(\frac{1-x^4}{1-x})(\frac{1-x^3}{1-x})^{ \frac{n-2}{2}}$，注意这里是 $\frac{k-a}{2}$ 次项的系数！所以 $k-a$ 要是偶数，其中，$a$ 在 $n$ 为偶数时是 $0$，否则是我们枚举的中间的数。

那么我们只用关心 $(\frac{1-x^4}{1-x})^2(\frac{1-x^3}{1-x})^{n-2}$ 和 $(\frac{1-x^4}{1-x})(\frac{1-x^3}{1-x})^{  \frac{n-2}{2}}$ 的展开式了，不过二者几乎等价，所以只用看其中一个。

考虑展开 $(\frac{1-x^3}{1-x})^{n-2}$，如下：

$$
\begin{aligned}
 (\frac{1-x^3}{1-x})^{n-2}
 
&=(1+x+x^2)^{n-2}\\
&=\sum_{i=0}^{n-2}\binom{n-2}{i}(x^2)^{n-2-i}(1+x)^{i}\\
&=\sum_{i=0}^{n-2}\binom{n-2}{i}x^{2n-4-2i} \sum_{j=0}^{i} \binom{i}{j}x^j\\
&=\sum_{i=0}^{n-2} \sum_{j=0}^{i} \binom{i}{j}\binom{n-2}{i}x^{j+2n-4-2i}\\
&=\sum_{t=0}^{2n-4}x^t\sum_{i=\color{red}{ \lceil \frac{2n-4-t}{2}\rceil}}^{2n-4-t} \binom{n-2}{i}\binom{i}{t-2n+4+2i} &\text{枚举指数}\\
\end{aligned}
$$

注意要乘上 $(1+x+x^2+x^3)^2$ 所以实际 $x^k$ 系数需要求上述式子的 $x^k,x^{k-1},\dots,x^{k-6}$ 项系数乘上 $(1+x+x^2+x^3)^2$ 对应系数再加起来

回文的一样求即可。

虽然计算量大，但胜在无脑，不会**经典容斥**也没有关系，不失为一种好方法！

---

## 作者：canwen (赞：0)

## 前言
赛时没想出来巧妙做法，只是知道整体怎么做，然后就无从下手。

赛后做法学习于 [Frielen](https://www.luogu.com.cn/user/1125685#main)，拜谢。

## Solution
首先判掉 $n=1$ 特殊情况。

对 $n > 1$ 进行分析，注意到 $A_1,A_n$ 取值特殊，不妨枚举 $l = A_1 = 0 \sim  3, r = A_n = 0 \sim 3$。

设 $a0,a1,a2$ 分别表示除了首尾两项的 $0$ 的数量，$1$ 的数量，$2$ 的数量，$cnt$ 表示中间还要填的数量。有

$$\begin{cases} cnt=a0+a1+a2=n-2 \\ 
a1+2a2 = k-l-r
\end{cases}$$

然后我们发现 $a0$ 只出现在一个式子中，枚举它能确定 $a1,a2$ 的值，于是求完值后经典地组合一下即可。

接着我们来考虑题目的额外限制：

> 定义两个数组 $A,B$ 本质不同当且仅当 $\exist i\in[1,n],A_i\ne B_i$ 且 $\exist i\in[1,n],A_i\ne B_{n-i+1}$。

也就是说我会统计多一些的答案，怎么做呢？

- 如果枚举的 $l \ne r$，那么一定会贡献两次，所以不妨将循环改成，从 $l \gets 0 \sim 3, r \gets  0 \sim l$。

- 接着考虑组合出来后重复的情况，不难发现除了这个数组**从后往前**与从**前往后比较**相同之外，贡献都会被重复算两遍，于是我们可以把这部分的数量求出来，加上这部分后，让总贡献除以 $2$ 即可。其实也就是除了首尾中间砍一半去的位置去填放数字，具体实现上需要分**除了首尾的数量，即 $cnt$ 的奇偶**进行讨论。若 $cnt$ 是偶数，且 $a0,a1,a2$ 均也是偶数，那么也就是 $\frac{cnt}{2}$ 位分别放置 $\frac{a0}{2},\frac{a1}{2},\frac{a2}{2}$ 个 $0,1,2$ 的贡献。若 $cnt$ 是奇数，则枚举一下正中间放置的数字，同理去组合数即可，记得判无解的情况。

## Code
如此写法需要预处理出所有阶乘的逆元，不然的话由于算组合数很多次，会 TLE。

```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;

#define int long long
//#define getchar gethar_unlocked
//#define putchar putchar_unlocked
#define pc putchar
int in(){
	char a=getchar();int k=0,kk=1;
	while(!(a>='0'&&a<='9')) {if(a == '-') kk = -1;a = getchar();}
	while(a>='0'&&a<='9') k = k*10 + a - '0', a = getchar();
	return k*kk;
}
void out(int a){
	if(a < 0) pc('-'), a= -a;
	if(a > 9) out(a/10);
	pc('0'+a%10);
}
#define fst first
#define snc second
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define mp make_pair
#define pint pair<int,int>
#define i128 __int128
#define i64 long long
#define pb emplace_back
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define nowtime (double)clock()/CLOCKS_PER_SEC
const int N = 1e6 + 5, mod = 998244353;
int jie[N],T,n,K,inv2[N]; // inv2_i 就是 jie_i 的逆元 
int qsm(int a,int b){
	int res=1ll;
	while(b){
		if(b&1) res=res*a%mod;
		a=a*a%mod;
		b>>=1ll;
	}
	return res;
}
int inv(int x){
	return qsm(x,mod-2);
} 
int C(int a,int b){
	if(a < b) return 0;
	return jie[a] * inv2[b] % mod * inv2[a-b] % mod;
}

int f(int x,int a0,int a1,int a2,int sum){ 
	if(x == 0){
		a0--;
	}else if(x == 1){
		a1--;
	}else a2--;
	if(a1<0||a2<0||a0<0||a1%2||a2%2||a0%2) return 0;
	return C(sum,a0/2)*C(sum-a0/2,a1/2)%mod;
}

signed main(){
	jie[1] = jie[0] = 1;
	_rep(i,2,1e6) jie[i] = jie[i-1] * i % mod;
	_rep(i,0,1e6) inv2[i] = inv(jie[i]);
	T = in();
	while(T--){
		n = in(), K = in();
		if(n == 1){
			if(K > 4) out(0);
			else out(1);
			pc('\n');
			continue;
		}
		int ans = 0;
		_rep(l,0,3){
			_rep(r,l,3){
				int sum = K-l-r, cnt = n - 2;
				if(cnt < 0 || sum < 0) continue;
				_rep(a0,0,cnt){
					int a1 = 2 * (cnt - a0) - sum;
					int a2 = cnt - a0 - a1;
					if(a1<0||a2<0) continue;
					int res = C(cnt,a0) * C(cnt-a0,a1) % mod;
					if(l != r){
						ans = (ans + res) % mod;
					}else{
						if(cnt % 2ll == 0){
							if(a0 % 2 == 0 && a1 % 2 == 0 && a2 % 2 == 0){
								int res1 = C(cnt/2,a0/2) * C(cnt/2-a0/2,a1/2) % mod;
								res = (res + res1) % mod;
							}
							res = res * inv(2ll) % mod;
						}else{
							int res1 = f(0,a0,a1,a2,cnt/2)
							+ f(1,a0,a1,a2,cnt/2) + f(2,a0,a1,a2,cnt/2);
							res = (res + res1) % mod;
							res = res * inv(2ll) % mod;
							
						}
						ans = (ans + res) % mod;
					}
				}
			}
		}
		cout << ans << "\n"; 
	}
	return 0;
}
```

---

## 作者：lw393 (赞：0)

先拆开来，将 $1, n$ 两个位置上的与 $[2,n-1]$ 这 $n-2$ 个数分开讨论。

先算出来满足第一个性质的，我们可以利用组合数来进行处理。我们先枚举出第一个数和最后一个数选什么，由于中间的值域为 $[0,2]$，所以直接枚举中间有多少个 $2$，用组合数处理这一段（再算出 $1$ 的个数）。

```cpp
for(int i = 0; i < 4; i++)
    for(int j = 0; j < 4; j++)
      for(int k = 0; k <= n - 2; k++) 
        if(n - 2 + k + i + j >= K) {
          ans += (c(n - 2, k) * c(n - 2 - k, K - i - j - 2 * k) % mod);
          ans %= mod;
        }
```

然后就会发现是多了的（赛时因为忘读清题了），然后好像又不足答案的两倍，这个时候，我发现上面为什么会少呢？回文！

在上面代码中，回文只被算了一次，而我们想要通过除以二来得到正确答案的话，需要将回文的情况再算出来。

这个与上面的同理（但是需要分奇数和偶数）：

```cpp
if(n % 2 != 0) {
    for(int i = 0; i < 4; i++)
      for(int j = 0; j < 3; j++){
        if((K - j) % 2 != 0) continue;
        for(int k = 0; k <= (n - 2) / 2; k++) {
          int need = (K - k * 4 - i * 2 - j) / 2;
          if(need <= (n - 2) / 2 - k) { 
            (ans += (c((n - 2) / 2, k) * c((n - 2) / 2 - k, need)) % mod) %= mod;
          }
        }
      }
  } else if(n % 2 == 0 && K % 2 == 0) {
    for(int i = 0; i < 4; i++)
      for(int k = 0; k <= (n - 2) / 2; k++) {
        int need = (K - 2 * i - 4 * k) / 2;
        if(need <= (n - 2) / 2 - k) (ans += (c((n - 1) / 2, k) * c((n - 2) / 2 - k, need)) % mod) %= mod;
      }
  }
```

最后答案除以二（注意是在模意义下）。

参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5, mod = 998244353;

int a[N], fact[N], inv[N];

int c(int a, int b){
	if(a < b || b < 0)  return 0;
	return (fact[a] * inv[b] % mod * inv[a - b] % mod) % mod; 
}

int fast_power(int a, int b){
	int ans = 1;
	while(b){
		if(b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ans;
}

void init(){
	fact[0] = 1;
	for(int i = 1; i < N; i++) fact[i] = fact[i - 1] * i % mod;
	inv[N - 1] = fast_power(fact[N - 1], mod - 2);
	for(int i = N - 1; i >= 1; i--) inv[i - 1] = inv[i] * i % mod;
}

const int inv2 = fast_power(2, mod - 2);

// 预处理组合数。

void solve(){
	int n, K; cin >> n >> K;
  if(n == 1) { if(K <= 4) cout << 1 << '\n'; else cout << 0 << '\n'; return; }
  if(K > 2 * n + 2) { cout << 0 << '\n'; return; }
  int ans = 0;
  for(int i = 0; i < 4; i++)
    for(int j = 0; j < 4; j++) {
      for(int k = 0; k <= n - 2; k++) {
        if(n - 2 + k + i + j >= K) {
          ans += (c(n - 2, k) * c(n - 2 - k, K - i - j - 2 * k) % mod);
          ans %= mod;
        }
      }
    }
  if(n % 2 != 0) {
    for(int i = 0; i < 4; i++)
      for(int j = 0; j < 3; j++){
        if((K - j) % 2 != 0) continue;
        for(int k = 0; k <= (n - 2) / 2; k++) {
          int need = (K - k * 4 - i * 2 - j) / 2;
          if(need <= (n - 2) / 2 - k) { 
            (ans += (c((n - 2) / 2, k) * c((n - 2) / 2 - k, need)) % mod) %= mod;
          }
        }
      }
  } else if(n % 2 == 0 && K % 2 == 0) {
    for(int i = 0; i < 4; i++)
      for(int k = 0; k <= (n - 2) / 2; k++) {
        int need = (K - 2 * i - 4 * k) / 2;
        if(need <= (n - 2) / 2 - k) (ans += (c((n - 1) / 2, k) * c((n - 2) / 2 - k, need)) % mod) %= mod;
      }
  }
  cout << ans * inv2 % mod << '\n';
}

signed main(){
	init();
	int t = 1;
	cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```

---

## 作者：liuyongtao (赞：0)

场外选手纯凑热闹。提供一个不需要容斥、没有思维、只需一点数学基础的做法。

比较初步的观察是特判 $n \le 1$，枚举掉两头的碳原子后累加，计算所有氯原子数量为 $k$ 的排列数，并用同样的方法计算并减去回文烷烃的重复贡献。

令 $n \leftarrow n - 2$，设 $f_{i, j}$ 为去掉两头的碳原子，不考虑翻转时，正 $i$ 烷的 $j$ 氯代物的数量，有转移：

$$
f_{i, j} = \begin{cases}
 1 & i = j = 0 \\
 0 & i = 0, j \neq 0\\
 f_{i - 1, j} + f_{i - 1, j - 1} + f_{i - 1, j - 2} & i > 0
\end{cases}
$$

令当 $i$ 为定值时，$\{f_{i, j}\}$ 的生成函数为 $F_i(x)$。根据上面的递推式我们有：

$$
F_i(x) = \begin{cases}
 1 & i = 0 \\
 F_{i - 1}(x) \times \left(1 + x + x ^ 2 \right) & i > 0
\end{cases}
$$

容易发现 $F_i(x)$ 实际上是 $\left(1 + x + x ^ 2 \right)$ 的累乘，故 $F_i(x) = (x ^ 2 + x + 1) ^ i$。

考虑多项式定理展开：

$$
\begin{aligned}
F_n(x) &= \left(x ^ 2 + x + 1 \right) ^ n \\
 &= \sum_{a + b + c = n, a, b, c \ge 0}
\begin{pmatrix}
 n \\
 a,b,c
\end{pmatrix}
\left(x ^ 2 \right) ^ a x ^ b \left(1 \right) ^ c \\
 &= \sum_{a + b + c = n, a, b, c \ge 0}
\frac{n!}{a! b! c!} x ^ {2a + b}
\end{aligned}
$$

由于我们只关心 $x ^ k$ 项系数，故令 $2a + b = k$，枚举 $a$：

$$
b = k - 2a, c = n - k + a \\
\begin{aligned}
\left[x ^ k \right] F_n(x) &= \sum_{a = 0} ^ n [b, c \ge 0] \frac{n!}{a!b!c!} x ^ k\\
 &=\sum_{a = 0} ^ n [k - 2a, n - k + a \ge 0] \frac{n!}{a!(k - 2a)!(n - k + a)!}x ^ k
\end{aligned}
$$

得到答案：

$$
f_{n, k} = \sum_{a = 0} ^ n [k - 2a, n - k + a \ge 0] \frac{n!}{a!(k - 2a)!(n - k + a)!}
$$

预处理 $0 \le i \le \max\{n, k\}$ 的阶乘及其逆元，即可单次 $\mathcal O(n + k)$ 计算。时间复杂度 $\mathcal O [T(n + k)]$。

分类讨论写了一坨就不给了。有错误恳请指出。

（推完才发现有极其显然的容斥（逃）

---

后记：$\left(x ^ 2 + x + 1 \right) ^ n$ 貌似还可以变成 $\frac {\left(x ^ 3 - 1\right) ^ n}{(x - 1) ^ n}$ 然后广义二项式定理暴展做。

我们又得到了本题的更麻烦做法（逃

---

## 作者：Tyih (赞：0)

# Solution

我们设 $ans_1$ 为不考虑对称限制的答案，$ans_2$ 为强制对称的答案，问题的答案肯定是 $\frac{ans_1+ans_2}{2}$。

设 $num_i(0 \le i \le 2)$ 表示数组中数字为 $i$ 的数量。对于求解 $ans_1$，可以枚举 $A_1,A_n$ 和 $num_2$（$num_1$ 也可以），就能分别计算出 $num_0$ 和 $num_1$ 的值。

此时，我们知道了三种数字分别的数量，应此方案数就是 $\binom{n-2}{num_0} \times \binom{n-2-num_0}{num_1}$，简单来说就是从 $n-2$ 个空位填入 $num_0$ 个 $0$，再从剩下的 $n-2-num_0$ 个空位中填 $num_1$ 个 $1$，剩下的空位全部填 $2$。

求解 $ans_2$ 的方法同上，就是需要注意 $n$ 长度的奇偶性。

# Code

```cpp line-numbers
#include<bits/stdc++.h>
#define IOS cin.tie(0),cout.tie(0),ios::sync_with_stdio(0)
#define ll long long
#define db double
#define pb push_back
#define eb emplace_back
#define MS(x,y) memset(x,y,sizeof x)
#define MC(x,y) memcpy(x,y,sizeof x)
#define PLL pair<ll,ll>
using namespace std;
const int N=1e6+5,M=1e6;
const ll INF=1ll<<60,mod=998244353;
int n,k;
ll pre[N],prn[N];
ll qpow(ll a,ll b){//快速幂 
	ll Ans=1;
	for(;b;b>>=1,a=a*a%mod) if(b&1) Ans=Ans*a%mod;
	return Ans;
}
ll binom(ll xx,ll yy){//求解组合数 
	if(xx<yy) return 0;
	return pre[xx]*prn[yy]%mod*prn[xx-yy]%mod;
}
void solve(){
	cin>>n>>k;
	if(n==1){//特判 n=1 
		if(k>4) cout<<0<<"\n";
		else cout<<1<<"\n";
		return ;
	}
	ll ans1=0,ans2=0;
	//求解 ans1 
	for(int i=0;i<=min(3,k);i++){//枚举 a_1
		for(int j=0;j<=min(k-i,3);j++){//枚举 a_n 
			for(int num2=0;num2<=((k-i-j)>>1);num2++){
				int num1=k-i-j-2*num2,num0=n-2-num1-num2;
				if(num0<0) continue;//若不存在方案 
				ans1=(ans1+binom(n-2,num0)*binom(n-2-num0,num1)%mod)%mod;
			}
		}
	}
	if(n&1){//n为奇数 
		for(int i=0;i<=min(k,2);i++){//枚举中间的数 
			if((k-i)&1) continue;//剩下的数要为偶数，不然无法对称 
			int tot=(k-i)/2;
			for(int j=0;j<=min(3,tot);j++){//枚举 a_1 
				for(int num2=0;num2<=((tot-j)>>1);num2++){
					int num1=tot-j-2*num2,num0=n/2-1-num1-num2;
					if(num0<0) continue;
					ans2=(ans2+binom(n/2-1,num0)*binom(n/2-1-num0,num1)%mod)%mod;
				}				
			}
		}
	}
	else if(k%2==0){// n 为偶数且 k 为偶数 
		int tot=k/2;
		for(int i=0;i<=min(3,tot);i++){//枚举 a_1 
			for(int num2=0;num2<=((tot-i)>>1);num2++){
				int num1=tot-i-2*num2,num0=n/2-1-num1-num2;
				if(num0<0) continue;
				ans2=(ans2+binom(n/2-1,num0)*binom(n/2-1-num0,num1)%mod)%mod;
			}
		}		
	}
	cout<<(ans1+ans2)%mod*qpow(2,mod-2)%mod<<"\n";
}
void init(){
	//pre[i] 表示 i!，prn[i] 表示 i! 的逆元
	pre[0]=prn[0]=1;
	for(int i=1;i<=M;i++) pre[i]=pre[i-1]*i%mod;
	prn[M]=qpow(pre[M],mod-2);
	for(int i=M-1;i;i--) prn[i]=prn[i+1]*(i+1)%mod;
}
int main(){
	IOS;init();
	int T=1;cin>>T;
	while(T--) solve(); 
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P13777 题解

## 思路

先忽略掉本质不同这一较为特殊的定义，对于 $n>1$，我们直接枚举 $A_1,A_n$，于是问题转化成了为 $n-2$ 个数字赋予一个 $[0,2]$ 的数字，使得这 $n-2$ 个数字的和为 $k-A_1-A_n$，我们定义 $f(len,k)$ 表示 $len$ 个 $[0,2]$ 的数字之和为 $k$ 的方案数，那么上面我们要求的就是 $\sum\limits_{A_1=0}^{3} \sum\limits_{A_n=0}^{3} [(n-2) \times 2 \ge k-A_1-A_n \wedge k-A_1-A_n \ge 0] f(n-2,k-A_1-A_n)$

然后现在考虑本质不同怎么做，在本题中，相同以及逆序后相同均算作本质相同，所以在上文计数中对称的答案我们计算了一次，其余答案计算了两次，那么我们可以把对称的部分答案再加一次，最后除以二。具体地，如果 $k$ 是偶数，那么 $n$ 必定也为偶数才会出现对称的情况，那么枚举 $A_1=A_n$，答案就是 $f(\frac{n}{2}-1,\frac{k}{2}-A_1)$；如果 $k$ 是奇数，那么我们枚举 $A_1=A_n$ 以及 $A_{\frac{n+1}{2}}$，只有 $k-A_{\frac{n+1}{2}}$ 为偶数时才会出现对称情况，所以答案就是 $f(\frac{n-1}{2}-1,\frac{k-A_{\frac{n+1}{2}}}{2}-A_1)$。

至于如何求 $f(len,k)$，其实不难，我们枚举 $m \in [\lfloor\frac{k+1}{2}\rfloor,\min(k,len)]$，表示在 $len$ 个里面取出了 $m$ 个 $\ge 1$，以及 $len-m$ 个 $0$，那么答案是 $\binom{len}{m}$，当然这还不够，对于这 $m$ 个 $\ge 1$ 的数字，我们先让这 $m$ 个数为 $1$，那么我们还剩下了 $k-m$ 没有放进去，也就是在这 $m$ 个要选出 $k-m$ 个加一，所以就是 $\binom{m}{k-m}$，所以不难得出 $f(len,k) = \sum\limits_{m=\lfloor\frac{k+1}{2}\rfloor}^{\min(k,len)} \binom{m}{k-m} \binom{len}{m}$。

## 代码

```cpp
#define int long long

const int N=1000005;
const int mod=998244353;

int T,n,k;
int f[N],g[N];

int exgcd(int a,int b,int& x,int& y) {
	if (!b) {
		x=1,y=0;
		return a;
	}
	int d=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return d;
}

int inverse(int a) {
	int x,y;
	exgcd(a,mod,x,y);
	x=(x%mod+mod)%mod;
	return x;
}

void init() {
	f[0]=g[0]=1;
	_rep(i,1,N-1) f[i]=f[i-1]*i%mod,g[i]=inverse(f[i]);
}

int C(int n,int m) {
	return (f[n]*g[m]%mod)*g[n-m]%mod;
}

int ksm(int a,int b) {
	if (!b) return 1;
	int k=ksm(a,b>>1);
	if (b&1) return (k*k%mod)*a%mod;
	return k*k%mod;
}

int calc(int len,int k) {
	if (!len && !k) return 1;
//	cout<<"calc: "<<len<<" "<<k<<" = ";
	int ans=0;
	_rep(m,(k+1)/2,min(k,len)) ans=(ans+C(m,k-m)*C(len,m)%mod)%mod;
//	cout<<ans<<endl;
	return ans;
}

i32 main() {
	init();
	read(T);
	while (T--) {
		read(n),read(k);
		if (n==1) puts("1");
		else {
			int ans=0;
			_rep(i,0,3) _rep(j,0,3) {
				int t=k-i-j;
				if ((n-2)*2<t || t<0) continue;
				ans=(ans+calc(n-2,t))%mod;
			}
			if ((k&1)==0) {
				if ((n&1)==0) {
					_rep(i,0,3) {
						int t=k/2-i;
						if ((n/2-1)*2<t || t<0) continue;
						ans=(ans+calc(n/2-1,t))%mod;
					}
				}
			}
			if (n&1) {
				_rep(i,0,3) _rep(j,0,2) {
					if ((k-j)&1) continue;
					int t=(k-j)/2-i;
					if (((n-1)/2-1)*2<t || t<0) continue;
					ans=(ans+calc((n-1)/2-1,t))%mod;
				}
			}
			ans=ans*inverse(2)%mod;
			writeln(ans);
		}
	}
	return 0;
}
```

---

## 作者：wukaichen888 (赞：0)

Problem 2
---
需要一定计数基础知识。

题目约束了对称情况，该问题答案应等于 $\frac{不考虑对称限制的答案+强制对称的答案}{2}$。

假定不考虑对称限制，暴力枚举 $A_1,A_n$，然后中间部分是一个经典容斥，钦定 $x$ 个 $A_i\ge3$，系数 $(-1)^x$ 先扔掉 $3x$ 个氯然后插板法即可。

假定对称，暴力枚举 $A_1,A_n$ 以及正中间的 $A_i$（基于 $n$ 的奇偶性讨论），然后右半段根据左半段确定，$k$ 折掉一半等价于上面问题。

```cpp
#pragma target("avx512f,sse2,sse3,sse4,sse4.2")
//#pragma GCC optimize("-Ofast","-finline","-funroll-loops","-fno-stack-protector")
//#pragma GCC optimize("Ofast,no-stack-protector")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define i128 __int128_t
const ll N=1e6+5,mod=998244353;
ll n,m,k,P[3000005],FP[3000005],ans;
i128 _base=1;
inline ll mol(ll x){return x-mod*(_base*x>>64);}
inline ll power(ll x,ll y){
	ll res=1ll;
	while(y){
		if(y&1ll) res=mol(res*x);
		x=mol(x*x);
		y>>=1ll;
	}
	return res;
}
inline ll inv(ll x){return power(x,mod-2);}
inline void add(ll &x,ll y){x=mol(x+y);}
inline ll C(ll x,ll y){
	if(x<y) return 0ll;
	return mol(mol(P[x]*FP[y])*FP[x-y]);
}
inline ll F(ll x,ll y){return C(x+y-1,y-1);}
inline ll G(ll x,ll y){
	if(x<0) return 0;
	if(y==0) return (x==0);
	ll res=0;
	for(int i=0;i<=min(x/3,y);i++)
		if(i&1) add(res,-mol(F(x-i*3,y)*C(y,i)));
		else add(res,mol(F(x-i*3,y)*C(y,i)));
	return res;
}
int main(){
    assert(n!=2);
	_base=(_base<<64)/mod;
	P[0]=FP[0]=1;
	for(int i=1;i<=3000000;i++) P[i]=mol(P[i-1]*i);
	FP[3000000]=inv(P[3000000]);
	for(int i=2999999;i>=1;i--) FP[i]=mol(FP[i+1]*(i+1));
	int t=0;
	scanf("%d",&t);
	while(t--){
		ans=0;
		scanf("%lld%lld",&n,&k);
		if(n==1){puts("1");continue;}
		for(int i=0;i<=3;i++)
			for(int j=0;j<=3;j++)
				add(ans,G(k-i-j,n-2));
		if(n&1){
			for(int i=0;i<=3;i++)
				for(int j=0;j<=2;j++)
					if(!((j+k)&1))
						add(ans,G((k-j)/2-i,n/2-1));
		}
		else
			if(!(k&1)){
				for(int i=0;i<=3;i++)
					add(ans,G(k/2-i,n/2-1));
			}
		printf("%lld\n",(ans*inv(2)%mod+mod)%mod);
	}
	return 0;
}
```

---

## 作者：lanchenhao2010 (赞：0)

## 题意

不解释了。

（没学过化学的人读题是不是需要很长时间 qwq。）

## 解析

首先我们发现烷烃两端最多可以连 $3$ 个氯原子，不好处理，我们不妨先假设每个碳原子最多只能连两个氯原子（~~环烷烃~~），考虑怎么对该子问题计数。

注意到 $k \le 2 \times 10^6$，我们可以枚举连两个氯原子的碳原子个数 $i$，则需要再选 $k - 2i$ 个连一个氯原子的碳原子，此时的方案数就是从 $n$ 个碳原子中选 $i$ 个的方案数乘上从剩下 $n - i$ 个碳原子中选 $k - 2i$ 个的方案数，即 $\dbinom{n}{i}\dbinom{n - i}{k - 2i}$，故总答案为 $\displaystyle\sum\limits_{i = 0}\limits^{\lfloor\frac{k}{2}\rfloor} \binom{n}{i}\binom{n - i}{k - 2i}$，以下记为 $f(n,k)$。

回到原问题，我们考虑如何处理烷烃两端。大力分讨：

1. 两端不连有氯原子，此时只有中间的碳能连氯，方案数为 $f(n - 2,k)$。
2. 两端有一端连有氯原子，我们把一个氯原子掰掉（~~碳卤键均裂，反应机理为自由基反应~~），则该端剩下的连的氯原子数至多为二，答案即为 $f(n - 1,k - 1)$，由于有两端还要再乘 $2$。
3. 两端均有氯原子，类似上面，答案为 $f(n,k - 2)$。

于是我们做完了……吗？

发现题目还有个要求：**对称的不能重复计算**。

直接除 $2$ 是不行的，因为可能有自相对称的方案，我们需要算出这些方案数再容斥进去。

显然对于对称的氯代烷左右两边是相同的，再次大力分讨：
1. $n$ 为偶数，$k$ 为偶数，我们可以把碳链一劈两半，对一半用上面的方法讨论即得答案为 $f(\dfrac{n}{2} - 1,\dfrac{k}{2}) + f(\dfrac{n}{2},\dfrac{k}{2} - 1)$。
2. $n$ 为偶数，$k$ 为奇数，发现此时碳链两半氯数一奇一偶，必定不对称，答案为 $0$。
3. $n$ 为奇数，$k$ 为偶数，则碳链中央有一个孤立的碳原子作对称中心，其上氯数可以为 $0$ 或 $2$，再对剩下两半分讨，得答案为 $f(\dfrac{n - 1}{2} - 1,\dfrac{k}{2}) + f(\dfrac{n - 1}{2},\dfrac{k}{2} - 1) + f(\dfrac{n - 1}{2} - 1,\dfrac{k}{2} - 1) + f(\dfrac{n - 1}{2},\dfrac{k}{2} - 2)$
4. $n$ 为奇数，$k$ 为奇数，碳链中央碳上必连一个氯，答案为 $f(\dfrac{n - 1}{2} - 1,\dfrac{k - 1}{2}) + f(\dfrac{n - 1}{2},\dfrac{k - 1}{2} - 1)$。

设最开始求出的方案数为 $S$，自相对称的方案数为 $T$，则在对称意义下本质不同的答案数即为 $\dfrac{S - T}{2} + T = \dfrac{S + T}{2}$。

预处理阶乘及其逆元求组合数，即可做到 $\mathcal{O(n)}$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long lty = 998244353,n2 = 499122177;
inline long long qp(long long x,long long y){
	long long r = 1;
	while(y){
		if(y & 1) r = r * x % lty;
		x = x * x % lty;
		y >>= 1;
	}
	return r;
}
int t;
long long f[2000005],iv[2000005];
inline long long C(long long n,long long m){
	if(m > n) return 0;
	return f[n] * iv[m] % lty * iv[n - m] % lty; 
}
inline long long svh(long long n,long long k){
	long long ans = 0;
	for(int i = 0;i <= (k >> 1);i++){
		ans += C(n,i) * C(n - i,k - (i << 1)) % lty;
		ans %= lty;
	}
	return ans;
}
inline void sv(){
    long long n,k;
    scanf("%lld%lld",&n,&k);
    long long ans = svh(n,k - 2) + (svh(n - 1,k - 1) << 1) + svh(n - 2,k);
    ans %= lty;
    int nn = n & 1,kk = k & 1;
    n >>= 1;k >>= 1;
	long long co;
    if(nn){
    	if(kk) co = svh(n,k - 1) + svh(n - 1,k);
    	else co = svh(n,k - 1) + svh(n - 1,k) + svh(n,k - 2) + svh(n - 1,k - 1);
	}
	else{
		if(kk) co = 0;
		else co = svh(n,k - 1) + svh(n - 1,k);
	}
    ans += co;
    ans %= lty;
    printf("%lld\n",ans * n2 % lty);
}
int main(){
	f[0] = f[1] = 1;
	for(int i = 2;i <= 2000000;i++) f[i] = f[i - 1] * i % lty;
	iv[2000000] = qp(f[2000000],lty - 2);
	for(int i = 1999999;~i;i--) iv[i] = iv[i + 1] * (i + 1) % lty;
	scanf("%d",&t);
	while(t--) sv();
	return 0;
}
```

---

## 作者：wang_wen_zhe (赞：0)

场切了这道题，写篇题解纪念一下。\
题目已经给出了形式化题意，所以题意不在此赘述。\
首先我们处理最简单的 $n=1$ 的情况，很明显，当 $k \le 4$ 的时候，只有一种情况，输出 `1` 即可，否则不存在合法情况，输出 `0`。\
当 $n > 1$ 的时候，我们首先考虑枚举 $a_1$ 和 $a_n$ 的值，因为这两个数的值的取值范围与其他数不同。接下来我们先不考虑数组本质相同的情况。记 $sum=k-a_1-a_n$，$a_2$ 到 $a_{n-1}$ 中值为 $i(0 \le i \le 2)$ 的个数为 $num_i$，易知 $\sum_{i=0}^2{num_i=sum}$，所以我们可以暴力枚举 $num_2$，则 $num_1=sum-2 \times num_2$，$num_0=n-2-num_2-num_1$。根据组合数学相关知识，我们可以求出 $a_2$ 到 $a_{n-1}$ 不同数组（这里的不同与题目的本质不同并不相同）的数量为：$\frac{(n-2)!}{num_0 ! \times num_1 ! \times num_2 !}$。\
接下来我们考虑求出本质不同的数组总数。很明显，对于一个回文数组 $A(\forall i \in [1,n]$，$A_i=A_{n-i+1})$，它在计算中只会出现一次。对于 $\sum_{i=0}^2{num_i\bmod 2}>n\bmod2$ 并且 $a_1=a_n$ 的情况，计算的时候会出现重复计算。以下是解释。

- 当 $n$ 为偶数的时候，$n-2$ 也为偶数，当且仅当 $num_i$ 均为偶数时 $A$ 才可能为回文数组。
- 当 $n$ 为奇数的时候，$n-2$ 也为奇数，当且仅当 $num_i$ 中最多有一个是奇数时 $A$ 才可能为回文数组。

于是我们就可以分别计算对于每组 $a_1$ 和 $a_n$ 出现重复计算和没出现的重复计算的数组总数为 $cnt_1$ 和 $cnt_2$，最终答案即为 $\sum{\frac{cnt_1}{2}+cnt_2}$。我们记 $num_i'=\lfloor{\frac{num_i}{2}\rfloor}$，没被重复计算的数组个数为 $\frac{\lfloor \frac{n-2}{2} \rfloor}{num_0' !\times num_1' !\times num_2'!}$。\
整理一下，若 $\sum_{i=0}^2{num_i\bmod2}>n\bmod2$，$cnt_1=\frac{(n-2)!}{num_0 ! \times num_1 ! \times num_2 !}-\frac{\lfloor \frac{n-2}{2} \rfloor}{num_0' !\times num_1' !\times num_2'!}$，$cnt_2=\frac{\lfloor \frac{n-2}{2} \rfloor}{num_0' !\times num_1' !\times num_2'!}$。否则 $cnt_1=\frac{(n-2)!}{num_0 ! \times num_1 ! \times num_2 !}$，$cnt_2=0$。\
由于结果需要模数，我们要用到乘法逆元。由于阶乘和乘法逆元会被多次使用，我们可以对其进行预处理。\
该讲的都讲完了，那就放代码吧。

::::info[完整代码]
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
const int N=1e6+5;
int pre[N],f[N<<5];
int T,n,k;
int qpow(int a,int b=mod-2)
{
    int sum=1;
    if(f[a]!=-1) return f[a];
    int kk=a;
    a=pre[a];
    while(b)
    {
        if(b&1) sum=sum*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return f[kk]=sum;
}
signed main()
{
    cin>>T;
    pre[0]=1;
    for(int i=0;i<=N<<2;i++)
    	f[i]=-1;
    for(int i=1;i<=1e6;i++)
        pre[i]=pre[i-1]*i%mod;
    while(T--)
    {
        cin>>n>>k;
        if(n==1)
        {
            if(k<=4) cout<<"1\n";
            else cout<<"0\n";
            continue;
        }
        int ans=0,sum1=0;
        for(int i=0;i<=3;i++)
            for(int j=0;j<=3;j++)
            {
                int sum=k-i-j;
                if(sum<0) continue;
                for(int p=0;p<=sum/2;p++)
                {
                    int num2=p,num1=sum-2*p,num0=n-2-num2-num1;
                    if(num0<0) continue;
                    ans=(ans+pre[n-2]*qpow(num2)%mod*qpow(num1)%mod*qpow(num0)%mod)%mod;
                    if(i==j)
                    {
                        if((num1&1)+(num2&1)+(num0&1)>(n&1)) continue;
                        num1=num1/2,num2=num2/2,num0=num0/2;
                        sum1=(sum1+pre[n-2>>1]%mod*qpow(num1)%mod*qpow(num2)%mod*qpow(num0)%mod)%mod;
                        ans=((ans-pre[n-2>>1]%mod*qpow(num1)%mod*qpow(num2)%mod*qpow(num0)%mod+mod)%mod+mod)%mod;
                    }
                }
            }
        cout<<(ans*qpow(2)%mod+sum1)%mod<<"\n";
    }
}
```
::::

总的时间复杂度为 $O(\sum n)$。\
如有其他疑问或题解存在问题，请在讨论区指出。谢谢。

---


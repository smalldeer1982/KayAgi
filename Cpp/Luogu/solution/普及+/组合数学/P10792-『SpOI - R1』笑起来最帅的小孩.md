# 『SpOI - R1』笑起来最帅的小孩

## 题目描述

**本题包含多组数据。**

有一个数字序列 $a$，长度为 $n$。序列中每一项均为 $0$ 到 $9$ 的数字。

另有一个空数字序列 $b$，$b$ 中会出现一个**光标**（你可以理解为能够出现在数字之间，或整个数字序列之前，或整个数字序列之后的细线），此时**光标**前后均没有数字。

现在向 $b$ 中依次输入数字序列 $a$。每输入一个数字，数字立即出现在**光标**之后。

接下来**光标**立即随机地移动到任意一个数字之前或所有数字之后。随机是均匀的。换句话说，**光标**移动到所有可移动到的位置的概率是均等的。

现在告诉你数字序列 $a$。你需要输出的是，最终得到的 $b$ 直接转为十进制后的大小（无视前导零）的期望，对质数 $2007072007$ 取模。

由于 $a$ 可能很长，所以本题采用压缩输入。

具体来说，最开始 $a$ 是空的数字序列，输入会给你一个 $k$ 长的二元组数组，其中第 $i$ 项为 $(x_i,l_i)$，表示数字 $x_i$ 连续出现 $l_i$ 次接在之前的 $a$ 之后。你可以用此方法解压缩真正的 $a$，再解决问题。

----------

**在本题，你可以对期望的理解**：对于一个变量可能的结果 $X$，若其权值为 $v_X$，得到该结果的概率为 $p_X$，则对于结果集 $S$，变量的期望 $E=\sum\limits_{X\in S}p_Xv_X$。

**如果你不知道如何对有理数取模**：请查看[此题](https://www.luogu.com.cn/problem/P2613)。

## 说明/提示

### 数据范围

**本题开启子任务捆绑和子任务依赖。**

令 $n=\sum\limits_{i=1}^k l_i$。

对于 $100\%$ 的数据，保证 $1\leq T\leq 15$，$1\leq n\leq 2\times 10^9$，$1\leq k\leq 10^5$，且对于任意 $i$ 均有 $0\leq a_i\leq 9$，$1\leq l_i\leq 2\times 10^9$。


| Subtask | $T\leq$ | $n\leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $15$ | $2\times 10^9$ | $A$ | $10$ | 无 |
| 2 | $15$ | $100$ | 无 | $15$ | 无 |
| 3 | $5$ | $2000$ | 无 | $15$ | 2 |
| 4 | $5$ | $10^6$ | 无 | $15$ | 2,3 |
| 5 | $5$ | $2\times 10^9$ | 无 | $45$ | 1,2,3,4 |

特殊性质 $A$：保证在解压缩后的 $a$ 中，任意一个数字都出现了最多一次。

## 样例 #1

### 输入

```
1
2
4 1
2 1```

### 输出

```
33```

## 样例 #2

### 输入

```
1
3
1 2
3 1
7 2```

### 输出

```
1204285426```

# 题解

## 作者：Yang18630303 (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P10792)

本题，我感觉，给成黄题有点不对，逆元 + 类快速幂 + 数学（期望，概率）应该是绿。

### 观前提示

所有部分代码都有

```cpp
#include <iostream>
#include <cmath>
#define int long long
using namespace std;
const int mod=2007072007;
int x,y;
int Mod(int n){
	return (n%mod+mod)%mod;
}
```

本题解话可能语无伦次，请见谅。

### Tips 您的正确代码炸了的可能原因

+ 十年 OI 一场空，不开 `long long` 见祖宗
+ 多测不清空，爆零两行泪
+ 逆元炸了
+ 快速幂炸了

### 简述题意

给定一个数字串，和一个空的序列，将数字串中的数字依次等概率的插入序列中**两个数字的间隔或者序列首和序列尾**，求最终序列的数排在一起形成的数的期望模 $m=2007072007$。

### 期望

何为期望？

举几个例子，如果在一个事件中，结果出现 $1,2,3,4,5$ 的概率是均等的，均为 $20\%$，那么，这个事件的期望是 $1,2,3,4,5$ 以 $20\%$ 为权的加权平均数，是 $3$。也就是说，期望是数据中每个数据以出现概率为权的加权平均数。**注意这里的概率并不一定相同，但是和一定为 $1$**。因为“结果是结果可能出现的多种情况之一”是全概率事件（废话）。

### 概率推导

现在，我们知道想求出结果，就要求出出现各种结果的概率，那就求。

首先，我们假设所有 $n$ 个数字都不相同。那么在 $n!$ 种这些数字的全排列中，每一个排列都对应着一种插入的方法，并且我们发现每种插法出现的概率均为 $\displaystyle\frac{1}{n!}$，和正好是 $1$。所以可能出现的情况就是 $n$ 个数的全排列，并且概率均等，均为 $\displaystyle\frac{1}{n!}$。

有问题，在刚才的证明中我们假设所有数字均不相同，那么如果有相同的数字呢？我们可以将相同的数字标号区分，比如当输入的数字是 $1,2,2,2,3$ 时，我们可以将三个 $2$ 分别标号为 $2_1,2_2,2_3$，这样就可以用上面的结论。

此时，我们就要求最终的期望了，设最终答案为 $ans$，$n$ 个数字分别为 $a_1$\~$a_n$，最终结果分别为 $A_1$ \~ $A_{n!}$。因为每个 $a_i$ 在 $n$ 位中每一位都出现了 $(n-1)!$ 次，所以

$$
\begin{aligned}
  ans&=\sum_{i=0}^{n!}A_i \times \frac{1}{n!}\\
  &=\frac{\sum_{i=0}^{n!}A_i}{n!}\\
  &=\frac{\sum_{i=0}^{n}a_i \times (n-1)! \times q(n) }{n!}\\
  &=\frac{\sum_{i=0}^{n}a_i \times q(n) }{n}
\end{aligned}
$$

其中 $q(n)$ 表示 $n$ 个 $1$ 并在一起形成的数，也就是 $\displaystyle\sum_{i=0}^
{n-1}10^i$。

这样，想求出最终结果 $ans \bmod m$，我们实际需要求的就是 $(\displaystyle\sum_{i=0}^{n}a_i) \bmod m$,$q(n) \bmod m$ 和 $\frac{1}{n} \bmod m$ 的乘积再模 $m$ 的值。

很容易地发现 $(\displaystyle \sum_{i=0}^{n}a_i) \bmod m=(\sum_{i=0}^kx_il_i) \bmod m$，这部分可以 $O(k)$ 解决。

这部分的代码：

```cpp
int k;
cin>>k;
int a,l;
int suma=0,n=0,o=0,ans;
for(int i=0;i<k;i++){
	cin>>a>>l;
	n+=l;
	suma+=a*l;
	n%=mod;
	suma%=mod;
}
```

### 逆元

刚才我们分析后发现，有一个子问题是 $\displaystyle\frac{1}{n} \bmod m$，不妨设这个值是 $x$，所以

$$
\begin{aligned}
\frac{1}{n} & \equiv x \pmod m\\
xn & \equiv 1 \pmod m
\end{aligned}
$$

这里的 $x$ 就叫做 $n$ 在模 $m$ 意义下的逆元。

如何求 $x$ 呢？

这里我偷懒，贴一个[大佬的博客](https://www.cnblogs.com/zjp-shadow/p/7773566.html)，谢谢。本题中我采用了拓欧的方法。

部分代码

```cpp
void Eg(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
	}
	else{
		Eg(b,a%b,y,x);
		y-=a/b*x;
	}
}
int ny(int a){
	Eg(a,mod,x,y);
	return (x%mod+mod)%mod;
}
```

这样我们只需要求 $q(n) \bmod m$ 了。

### 类快速幂

怎么求 $q(n) \bmod m$ 呢？

~~可以用等比数列求和但是别的大佬讲了，我讲一下自己的方法吧~~

很容易发现一个 $q$ 的递推式：$q(i) = q(i-1) \times 10 + 1$。所以可以得到以下 $O(n)$ 的代码：

```cpp
long long s_s1(int n){
	int o=0;
	for(int i=0;i<n;i++){
		o=o*10+1;
		o%=mod;
	}
	return o;
}
```

然而，这道题的 $n$ 范围是 $2 \times 10^9$，这肯定会 TLE（实际得分55pts）

观察特点，发现 $q$ 特别像幂函数，可以通过快速幂的二分思想来解决。易得 $q$ 的二分递推式是 

$$
q(i)=\begin{cases}
1 &（i=1）\\
q(i/2) \times 10^{n/2}+q(i/2)&(i \bmod 2 = 0)\\
(q(i/2) \times 10^{n/2}+q(i/2)) \times 10+1&(i \bmod 2 = 1 且 i \ne 1)
\end{cases}
$$

然后我们再用快速幂去求 $10^{n/2}$ 就好了。

**注意这里不能用 `pow`，会炸 `long long`，要自己再手打快速幂并取模。**

部分代码：

```cpp
int f_s(int n){//求10^n
	if(n==0)return 1;
	if(n==1)return 10;
	int r=f_s(n/2);
	if(n&1){
		return Mod(Mod(r*r)*10);
	}
	else{
		return Mod(r*r);
	}
}
long long f_s1(int n){//求q(n)
	if(n==1)return 1;
	if(n==2)return 11;
	long long r=f_s1(n/2);
	if(n&1){
		return Mod(Mod(r*Mod(f_s(n/2))+r)*10+1);
	}
	else{
		return Mod(r*Mod(f_s(n/2))+r);
	}
}
```

复杂度 $O(\log n)$。

### Code

于是我们就可以贴上完整代码了

注：完整代码中的 `mod` 即为模数 `m`。

```cpp
#include <iostream>
#include <cmath>
#define int long long
using namespace std;
const int mod=2007072007;
int x,y;
int Mod(int n){
	return (n%mod+mod)%mod;
}
void Eg(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
	}
	else{
		Eg(b,a%b,y,x);
		y-=a/b*x;
	}
}
int ny(int a){
	Eg(a,mod,x,y);
	return (x%mod+mod)%mod;
}
int f_s(int n){//求10^n
	if(n==0)return 1;
	if(n==1)return 10;
	int r=f_s(n/2);
	if(n&1){
		return Mod(Mod(r*r)*10);
	}
	else{
		return Mod(r*r);
	}
}
long long f_s1(int n){//求q(n)
	if(n==1)return 1;
	if(n==2)return 11;
	long long r=f_s1(n/2);
	if(n&1){
		return Mod(Mod(r*Mod(f_s(n/2))+r)*10+1);
	}
	else{
		return Mod(r*Mod(f_s(n/2))+r);
	}
}
long long s_s1(int n){
	int o=0;
	for(int i=0;i<n;i++){
		o=o*10+1;
		o%=mod;
	}
	return o;
}
void solve(){
	int k;
	cin>>k;
	int a,l;
	int suma=0,n=0,o=0,ans;
	for(int i=0;i<k;i++){
		cin>>a>>l;
		n+=l;
		suma+=a*l;
		n%=mod;
		suma%=mod;
	}
	o=f_s1(n);
	n=ny(n);
	ans=n*o;
	ans%=mod;
	ans*=suma;
	ans%=mod;
	cout<<ans<<endl;
	return;
}
signed main(){
	int T;
	cin>>T;
	for(int t=0;t<T;t++){
		solve();
	}
	return 0;
}
```

最终复杂度 $O(T(k+\log n))$

完结撒花！

---

## 作者：__Raincoat__ (赞：4)

# 读题&分析

1. 有一个数字序列 $a$，长度为 $n$。序列中每一项均为 $0$ 到 $9$ 的数字。

2. 另有一个空数字序列 $b$，$b$ 中会出现一个**光标**（你可以理解为能够出现在数字之间，或整个数字序列之前，或整个数字序列之后的细线），此时**光标**前后均没有数字。 

3. 现在向 $b$ 中依次输入数字序列 $a$。每输入一个数字，数字立即出现在**光标**之后。

**给出 $a,b$ 两数列以及光标的定义。**


---


4. 接下来**光标**立即随机地移动到任意一个数字之前或所有数字之后。随机是均匀的。换句话说，**光标**移动到所有可移动到的位置的概率是均等的。

**概率是多少呢？**

在放入第 $i$ 个数后，光标可以出现在每个数字前（$i$ 种）或在整个序列后（$1$ 种），所以说移动到每个位置的概率为：
$$
A_{i+1}^{i+1}=(i+1)!
$$

以此类推，将所有的 $n$ 个数放完后，有 $(n+1)!$ 种方案数。然而，放完 $n$ 个数后的的光标位置对序列没有影响，所以最终的方案数应该为 $n!$。

---


5. 现在告诉你数字序列 $a$。你需要输出的是，最终得到的 $b$ 直接转为十进制后的大小（无视前导零）的期望，对质数 $2007072007$ 取模。

**怎么变成十进制？**

对于一个确定的序列，先来看最后一位，$b_n \times 10^0$，显然，整个数列可以在十进制下表示为：

$$
\sum_{i=1}^n b_i \times 10^{n-i}
$$


---


6. 由于 $a$ 可能很长，所以本题采用压缩输入。

7. 具体来说，最开始 $a$ 是空的数字序列，输入会给你一个 $k$ 长的二元组数组，其中第 $i$ 项为 $(x_i,l_i)$，表示数字 $x_i$ 连续出现 $l_i$ 次接在之前的 $a$ 之后。你可以用此方法解压缩真正的 $a$，再解决问题。

**别致的输入**

举个栗子，$x=114,l=5$ 解压缩后的序列为：$[114,114,114,114,114]$。


----



**在本题，你可以对期望的理解**：对于一个变量可能的结果 $X$，若其权值为 $v_X$，得到该结果的概率为 $p_X$，则对于结果集 $S$，变量的期望为 $E=\sum \limits_{X\in S}p_Xv_X$。

**硬核公式，非常的凉心啊。**

**等等，$p_Xv_X$ 是什么东东。**

权值，顾名思义，当然是这个序列转换为十进制的值。

概率即为我们刚刚求出来的 $\frac {1}{n!}$。

---

**数据范围**

令 $n=\sum\limits_{i=1}^k l_i$。

对于 $100\%$ 的数据，保证 $1\leq T\leq 15$，$1\leq n\leq 2\times 10^9$，$1\leq k\leq 10^5$，且对于任意 $i$ 均有 $0\leq a_i\leq 9$，$1\leq l_i\leq 2\times 10^9$。

## 推导
回到刚刚计算期望的公式，因为 $\sum$ 具有分配率，于是我们可以将 $E=\sum \limits_{X\in S}\frac {1}{X!}$ 提出来，接下来我们只需要算:
$$
\frac{\sum \limits_{X\in S}X}{n!}
$$

是不是瞬间头大了，没关系，我们一步一步来。

先来看单独的 $X$，在刚刚推导出的公式中：
$$
X=\sum_{i=1}^n b_i \times 10^{n-i}
$$
然而这时候 $b$ 中的字符序列是不确定的。
所以对于每一个单独的 $b_i$，可以有 $(n-1)!$ 种位置可以插入，此时对应的解集 $S$ 为：
$$
S=\sum_{i=0}^{n}\sum_{j=0}^{n-1}(a_i \times 10^j \times (n-1)!)
$$
同理，我们可以将与 $i$ 有关的项和与 $j$ 有关的项提出来，所以说：
$$
S=(n-1)!\sum_{i=0}^{n}a_i\sum_{j=0}^{n-1} 10^j
$$
期望值为：
$$
E=\frac{(n-1)!\sum_{i=0}^{n}a_i\sum_{j=0}^{n-1} 10^j}{n!}
$$
化简：
$$
E=\frac{\sum_{i=0}^{n}a_i \sum_{j=0}^{n-1} 10^j}{n}
$$

**科普**

对于一个等比数列 $a_i = q^{n-1}$，其前 $n$ 项和 $S_n =\displaystyle \frac{1-q^n}{1-q}$。

这样我们就可以快速的求出 $\sum_{j=0}^{n-1} 10^j$ 的值为：
$$
\frac{10^n-1}{9}
$$
最后，我们发现：
$$
E=\frac{\sum_{i=0}^{n}a_i \frac{10^n-1}{9}}{n}
$$
接下来就可以愉快的写代码啦！

# 小寄巧
## 快速幂


```cpp
ll binpow(ll a,ll b,ll m) {
	a = (a % m + m) % m;
	ll res = 1;
	while (b > 0) {
		if (b & 1) res = res * a % m;
		a = a * a % m;
		b >>= 1;
	}
	return res;
}
```
## Long long int

**十年 OI 一场空，不开 long long 见祖宗。**

[不开 long long 的后果](https://www.luogu.com.cn/record/168406971)


# AC_code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll M=2007072007;
ll T,t,l,N;
ll n,sum=0,ans,inv;
ll binpow(ll a,ll b,ll m) {
	a = (a % m + m) % m;
	ll res = 1;
	while (b > 0){
		if (b & 1) res = res * a % m;
		a = a * a % m;
		b >>= 1;
	}
	return res;
}
int main(){
	cin>>T;
	while(T--){
		cin>>N;
		ans=0,sum=0,n=0;
		for(int i=1;i<=N;i++){
			scanf("%lld %lld",&t,&l);
			sum=(sum+t * l)%M;
			n+=l;
		}
		ans=binpow(10,n,M)-1;
		ans=(ans % M + M)%M;
		inv=binpow(9 * n,M-2,M);
		inv=(inv % M + M)%M;
		ans=(ans * inv)%M;
		ans=(ans * sum)%M;
		ans=(ans % M + M)%M;
		printf("%lld\n",ans);
		
	}
	return 0;
}
```


---
_By yuyhang_

---

## 作者：Shunpower (赞：4)

出题人题解。

考虑造出 KIT 输入的数字序列，然后将输入的数字依次按照 $1\sim n$ 进行编号，考虑 $n!$ 种排列构成的数的和。

可以证明，任意一种排列都与一种光标移动的可能一一对应。

> 证明：
>
> 首先，考虑光标移动的总方案数，第 $i$ 次放入数字之后会有 $i+1$ 个间隔可以选择，而最后一次移动没有意义，所以一共有 $n!$ 种有意义的可能移动方案。
>
> 显然一种移动方案只对应一种排列。
>
> 考虑一种排列只对应一种移动方案。假设已知排列，那么在第 $i$ 次插入数字，由于数字 $i$ 和前面 $i-1$ 个数字的相对位置是确定的，于是有且仅有一种光标移动的可能位置。特别地，对于 $i=1$，显然光标只有一种可能的位置。由于每一步光标移动的位置都是唯一确定的，所以整个移动方案也是唯一确定的，所以一种排列只对应一种移动方案。

由一一对应关系，我们可以独立考虑每个数字，且对于它在最后 $n$ 个数位中的任何一个，都有 $(n-1)!$ 种方案，于是我们有期望的分子为：
$$
\sum\limits_{i=1}^n\sum\limits_{j=0}^{n-1} a_i\times 10^j\times (n-1)!
$$
提取 $a_i$ 和 $(n-1)!$ 后，对 $10^j$ 计算前缀和即可。最后不要忘记除以 $n!$。

这样可以解决 $n\leq 10^6$。

注意到，$(n-1)!$ 和 $n!$ 其实大部分都约掉了，所以，我们直接写出整个期望：
$$
\frac{(n-1)!\sum\limits_{i=1}^na_i\sum\limits_{j=0}^{n-1}10^j}{n!}=\frac{\sum\limits_{i=1}^n a_i\sum\limits_{j=0}^{n-1}10^j}{n}
$$
使用等比数列公式计算 $\sum\limits_{j=0}^{n-1}10^j$ 即可。这样就可以把这一坨东西当成常数提出去，然后可以轻易处理 $l_i$。可以解决整道题目。

------------

这是 std：

```cpp
int quick_power(int base,int x){
	int res=1;
	while(x){
		if(x&1)res*=base,res%=mo;
		base*=base,base%=mo;
		x>>=1;
	}
	return res;
}
void solve(){
	read(n);
	int cnt=0,ans=0;
	rep(i,1,n){
		int x,y;
		read(x),read(y),cnt+=y,ans+=x*y,ans%=mo;
	}
	ans=ans*((quick_power(10,cnt)+mo-1)%mo*quick_power(9ll*cnt%mo,mo-2)%mo)%mo;
	printf("%lld\n",ans);
}
```

---

## 作者：hexz01 (赞：2)

没读题的戳[这里](https://www.luogu.com.cn/problem/P10792)

## 思路

首先看到光标乱飞就很慌，不知所措。

于是我用程序模拟了一下，发现这不就是全排列吗？当任意两个数不相同时，一共 $1 \times 2 \times 3 \times \dots \times n = n!$ 种情况，每种情况 $1 \times \frac{1}{2} \times \dots \times \frac{1}{n} = \frac{1}{n!}$ 的概率，加起来不就是总共的事件概率 $1$ 吗？

此题可能有重复的数，我们就只需要假设他们不一样就行了，因为输入顺序不一样就导致状态不同，所以这样算没错。

于是我们得到：

$$ans=\frac{\sum_{i=1}^{n!}A_i}{n!}$$

其中 $A_i$ 表示第 $i$ 个排列组成的数。

因为固定其中一位，其他 $n-1$ 位有 $(n-1)!$ 种可能性，所以每个数在每一位都有 $(n-1)!$ 次。

$$ans=\frac{\sum_{i=1}^{n!}A_i}{n!}$$

$$=\frac{\sum_{i=1}^{n}(a_i \times (n-1)! \times \sum_{j=0}^{n-1}10^j)}{n!}$$

$$=\frac{\sum_{i=1}^n a_i \times \sum_{i=0}^{n-1}10^i}{n}$$

所以我们只用计算 $\sum_{i=1}^na_i \bmod 2007072007$，$\sum_{i=0}^{n-1}10^i \bmod 2007072007$，以及 $n$ 在模 $2007072007$ 意义下的逆元，并将三者相乘。

### 第一部分

这里计算 $\sum_{i=1}^n a_i \bmod 2007072007$，我们只需要在加的过程中不断取模即可（即 $\sum_{i=1}^n x_i \times l_i \bmod 2007072007$）。

### 第二部分

计算 $\sum_{i=0}^{n-1}10^i \bmod 2007072007$，也就是 $n$ 个 $1$。

发现这是一个公比为 $10$ 的等比数列，利用等比数列求和，答案为 $\frac{10^n-1}{9}$，用下文的方式计算 $9$ 的逆元即可。

### 第三部分

计算 $n$ 在模 $2007072007$ 意义下的逆元。

因为 $2007072007$ 是个大质数，所以使用费马小定理计算 $n^{2007072007-2}$。

---
最后将三部分相乘即可。

## code

``` cpp
#include <iostream>
using namespace std;
typedef long long ll;
const ll mod=2007072007;
const int K=1e5+7;
int k;
struct node{
	ll x, l;
}a[K];
ll ksm(ll x, ll y){//快速幂
	ll ans=1;x%=mod;
	while(y){
		if(y&1)
			ans=ans*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ans;
}
int main(){
	int T;
	cin>>T;
	while(T--){
		cin>>k;
		ll part1=0, part2, part3;
		ll n=0;
		for(int i=1;i<=k;i++){
			cin>>a[i].x>>a[i].l;
			n+=a[i].l;
			part1=(part1+a[i].x*a[i].l%mod)%mod;//计算部分1
		}
		part2=(/*计算分子->*/(ksm(10, n)-1)%mod+mod/*可能为负数，要加上一个mod*/)%mod*/*9的逆元->*/ksm(9, mod-2)%mod;//计算部分2
		part3=ksm(n, mod-2);//部分3
		cout<<((part1*part2)%mod*part3)%mod<<endl;//相乘
	}
	return 0;
}
```
复杂度 $O(Tk)$。

---

## 作者：粥2414 (赞：1)

# 思路
首先可以发现所有可能的 $b$ 序列的集合为 $a$ 序列的全排列。  
~~感性理解~~原因是由于光标移动完全随机，相当于将 $a$ 序列中的所有数随机排列。所以 $b$ 序列的所有可能结果为 $a$ 序列的全排列。

设 $n=\sum_{i=1}^{k}l_i$，显然每个排列出现的概率为 $\frac{1}{n!}$，那么我们只需要求出所有排列转换为十进制之后的和即可。

这个十进制数可以表示为：
$$
\sum_{i=1}^{n}b_i\cdot 10^{n-i}
$$
我们分别考虑其每一位造成的影响。

设第 $j$ 位上的数为 $a_i$，那么其他位上的数可能的排列有 $(n-1)!$ 种，$a_i$ 的贡献为：
$$
a_i\cdot10^{j-1}(n-1)!
$$
那么将每一个数在每一位上的贡献加起来，就可以得到分子：
$$
\sum_{i=1}^{n}\sum_{j=0}^{n-1}a_i\cdot10^j(n-1)!
$$
化简可得：
$$
(n-1)!\sum_{i=1}^{n}a_i\sum_{j=0}^{n-1}10^j
$$
再加上分母 $n!$ 并约分可得：
$$
\frac{\sum_{i=1}^{n}a_i\sum_{j=0}^{n-1}10^j}{n}
$$

$\sum_{j=0}^{n-1}10^j$ 可以利用**等比数列求和公式**快速求出。$\sum_{i=1}^{n}a_i$ 可以在读入时顺便求出。~~逆元应该都会吧~~。

复杂度显然 $O(k+\log{n})$。

然后就可以愉快地 AC 啦！
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll MOD=2007072007;
ll t,k;
ll n,sum,kkk;
inline ll qp(ll a,ll b){
	ll res=1;
	while(b){
		if(b&1)res*=a,res%=MOD;
		a*=a,a%=MOD,b>>=1;
	}
	return res;
}
int main(){
	cin>>t;
	while(t--){
		sum=0,kkk=0,n=0;
		cin>>k;
		while(k--){
			ll x,l;cin>>x>>l;
			n+=l;
			sum=(sum+x*l)%MOD;
		}
		kkk=(qp(10,n)-1)*qp(9,MOD-2)%MOD;
		n=qp(n,MOD-2);
        cout<<sum*kkk%MOD*n%MOD<<endl;
	}
	return 0;
}
```

---

本题解借鉴了[这篇题解](https://www.luogu.com.cn/article/jxsit434)的思路。

---


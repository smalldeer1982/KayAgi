# [蓝桥杯 2024 国 Java A] 粉刷匠小蓝

## 题目描述

小蓝是一名勤劳的粉刷匠，今天他收到了一份来自蓝桥学院的委托，需要为学院的 $n$ 面墙进行粉刷。这 $n$ 面墙从左到右依次排列，编号从 $1$ 到 $n$。起初，所有墙的颜色均为白色。

学院希望小蓝能将其中一部分墙刷成蓝色，以营造一种冷色调的艺术氛围。为此，学院给小蓝提供了一个长度为 $n$ 的数组 $\{a_1, a_2, \cdots, a_n\}$，来指定每面墙的颜色要求。具体地，如果 $a_i = 0$，则第 $i$ 面墙保持白色；如果 $a_i = 1$，则小蓝需要将第 $i$ 面墙刷成蓝色。

小蓝每次只能刷一面墙，他会将一面墙完整的刷完后再刷另一面墙。为了确保整体墙面的视觉效果，学院还提一个小小的要求：在粉刷过程中，如果要将第 $i$ 面墙刷成蓝色，那么它右侧（第 $i + 1$ 面墙 $\sim$ 第 $n$ 面墙）蓝色的墙的个数必须是偶数（包括 $0$ 个）。

现在，请你计算小蓝共有多少种刷墙顺序可以满足学院的要求？由于答案可能很大，因此你只需要给出答案对 $10^9 + 7$ 取模后的结果即可。

在本题中，不同的刷墙方法只与小蓝刷墙的顺序有关。例如，先刷第 $1$ 面墙再刷第 $2$ 面墙，与先刷第 $2$ 面墙再刷第 $1$ 面墙，被视为两种不同的方法。

## 说明/提示

### 样例说明

在样例 $1$ 中，有 $4$ 面墙，且都需要刷为蓝色。总共有以下 $4$ 种粉刷顺序可以满足学院的要求：

1. $[1,2,3,4]$：先刷第 $1$ 面，再刷第 $2$ 面，然后刷第 $3$ 面，最后刷第 $4$ 面。
2. $[1,3,4,2]$：先刷第 $1$ 面，再刷第 $3$ 面，然后刷第 $4$ 面，最后刷第 $2$ 面。
3. $[2,3,1,4]$：先刷第 $2$ 面，再刷第 $3$ 面，然后刷第 $1$ 面，最后刷第 $4$ 面。
4. $[3,4,1,2]$：先刷第 $3$ 面，再刷第 $4$ 面，然后刷第 $1$ 面，最后刷第 $2$ 面。

在样例 2 中，有 $2$ 面墙，且都要保持白色。只有 $1$ 种刷墙方法可以满足学院的要求，即不刷任何一面墙壁。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 13$，$a_i = 1$。
- 对于所有评测用例，$1 \leq n \leq 2 \times 10^5$，$0 \leq a_i \leq 1$。

## 样例 #1

### 输入

```
4
1 1 1 1```

### 输出

```
4```

## 样例 #2

### 输入

```
2
0 0```

### 输出

```
1```

# 题解

## 作者：zyl0926 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P12291)

## 思路

首先 $1$ 是需要粉刷，$0$ 是无需粉刷。按题意是构建一个序列，$1$ 有几个，这个序列就有几个数，$0$ 没有任何作用。

根据题目，题目说：那么它右侧（第 $ i+1 $ 面墙∼第 $ n $ 面墙）蓝色的墙的个数必须是偶数（包括 $ 0 $ 个）。

这个序列是粉刷顺序，所以这个序列要满足：对于每个数 $a_i$，$a_{1}\sim a_{i-1}$ 大于 $a_i$ 的个数，必须是偶数个，不然序列不成立。

至此已经想到了 $20$ 分的写法：全排列然后验证。

但想拿满分，就要考虑构造。

既然要满足要求，我们考虑从 $1$ 开始填写只能先填写奇数相，那么正好前面有偶数相并且一定大于 $1$，满足要求。

例如 $1$ 的个数有 $5$ 个，**T**是可填写，**F**是不可填写。

| T    | F    | T    | F    | T    |
| ---- | ---- | ---- | ---- | ---- |

填入最小数 $1$ 后，这个数将永久不会影响后面的填写，因为他是最小的数，这等于将序列长度**永久**减 $1$。

以此类推，依次填入剩下的数。

求一共有多少种不同的合法序列。

那，有 $n$ 个 $1$，$1$ 产生的贡献是 $\lceil \frac{n}{2} \rceil$，$2$ 产生的贡献是 $\lceil \frac{n-1}{2} \rceil$，$i$ 产生的贡献是 $\lceil \frac{n-i+1}{2} \rceil$，由于是要求多少种不同的合法序列，就是求排列数量，所以求得是贡献积，可以用递推。
递推公式是：
$$
f_0\gets1，f_1\gets1
，f_2\gets1
$$

$$
f_i\gets f_{i-1}\cdot\lceil n/2 \rceil
$$

由于 $i$ 只用之前一项，所以不用定义数组，只用一个变量 $ans$ 就行了。

## Code

```c++
#include<bits/stdc++.h>
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define endl '\n'
//#define int long long
using namespace std;
const int mod=1e9+7;//模数
int n;
signed main(void){
	IOS;
	cin>>n;
    int k=0;//1的个数
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		k+=x;//x只会为1或0。如果x为1，则k加1，如果为0，1的个数不会增加，所以不用写判断
	}
    int ans=1;//初始值k=0、k=1或k=2的值
	for(int i=3;i<=k;i++){
		ans=(1ll*ans*((i+1)/2))%mod;//记得 *1ll 不然会爆int，会WA
	}
	cout<<ans<<endl;//输出答案
	return 0;
}
```
### 闲话
我与QinYulang师出同门，他用的是看着用暴力跑出来的一到十的答案找规律，我用的是老师的思路改编了一下，我记得老师的思路有一大部分不一样。

---


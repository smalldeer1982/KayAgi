# [GESP202506 八级] 遍历计数

## 题目描述



给定一棵有 $n$ 个结点的树 $T$，结点依次以 $1,2,\dots,n$ 标号。树 $T$ 的深度优先遍历序可由以下过程得到：

1. 选定深度优先遍历的起点 $s$（$1 \leq s \leq n$），当前位置结点即是起点。
2. 若当前结点存在未被遍历的相邻结点 $u$ 则遍历 $u$，也即令当前位置结点为 $u$ 并重复这一步；否则回溯。
3. 按照遍历结点的顺序依次写下结点编号，即可得到一组深度优先遍历序。

第一步中起点的选择是任意的，并且第二步中遍历相邻结点的顺序也是任意的，因此对于同一棵树 $T$ 可能有多组不同的深度优先遍历序。请你求出树 $T$ 有多少组不同的深度优先遍历序。由于答案可能很大，你只需要求出答案对 $10^9$ 取模之后的结果。



## 说明/提示

对于 40% 的测试点，保证 $1 \leq n \leq 8$。

对于另外 20% 的测试点，保证给定的树是一条链。

对于所有测试点，保证 $1 \leq n \leq 10^5$。

在洛谷上，只有通过了 Subtask0、Subtask1 和 Subtask2 后，才能获得第三个 Subtask 的分数。

## 样例 #1

### 输入

```
4
1 2
2 3
3 4```

### 输出

```
6```

## 样例 #2

### 输入

```
8
1 2
1 3
1 4
2 5
2 6
3 7
3 8```

### 输出

```
112```

# 题解

## 作者：chenxi2009 (赞：10)

## 思路
### $n\le 8$

深度优先遍历序是一个 $1$ 到 $n$ 的排列，所以数量是 $O(n!)$ 的，考虑搜索出所有的深度优先遍历序。具体地，枚举每一个结点 $s$ 作为根开始搜索，如果当前结点 $x$ 不是叶子，那么枚举它的所有儿子遍历顺序的排列并进入搜索，时间复杂度 $O(n\times n!)$，可以接受。
### $O(n^2)$ 做法
如果我们枚举根节点 $s$ 进行树形 DP，令 $f_i$ 表示 $i$ 子树内的深度优先遍历序有多少种，显然 $i$ 的父亲就要考虑所有儿子子树的排列顺序，和每个子树内部的情况数。

根据乘法原理得到递推式：
$$
f_u=(\text{the number of sons of }u)!\times \prod\limits_{v\in\text{ son of }u} f_v
$$

即 $u$ 儿子数量的阶乘乘以所有儿子 $f_v$ 的积。

可以线性预处理出阶乘，由于 DP 一次是 $O(n)$ 的，枚举了所有结点为根做了 $n$ 次 DP，总时间复杂度 $O(n^2)$。
### 链
如果根节点 $s$ 度数为 $1$，即 $s$ 为链的一端，深度优先遍历时只能一路向下走，只有一种序；

如果根节点 $s$ 度数为 $2$，即 $s$ 在链的中间，深度优先遍历时有先向上和先向下两种可能，有两种序。

第一种 $s$ 有 $2$ 个，第二种 $s$ 有 $n-2$ 个，加起来答案就是 $2n-2$。直接输出即可。

注意需要特判 $n=1$ 时答案为 $1$。
### 满分做法
聚焦 $O(n^2)$ 做法，发现其实有
$$
f_s=\prod_{u=1}^n(\text{the number of sons of }u)!
$$
其实是要枚举 $s$ 计算这个东西的和。令 $d_i$ 表示 $i$ 的度数（与 $i$ 相连的边数），观察每个点的儿子数，根节点的儿子数是它的度数，其他点儿子数是度数
$-1$，所求其实是
$$
d_s!\times \prod_{i\in[1,n],i\ne s}(d_i-1)!\\
=d_s!\times\prod_{i=1}^{s-1}(d_i-1)!\times\prod_{i=s+1}^n(d_i-1)!
$$
我们预处理出度数 $-1$ 的阶乘的前缀和 $P$ 和后缀和 $S$，上面的式子就是 $d_s!\times P_{s-1}\times S_{s+1}$，可以 $O(1)$ 得到，枚举所有 $s$ 累加即可。时间复杂度 $O(n)$。

讲得有点冗长了，其实思路很简单，代码也很短。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200000;
const long long MOD = 1000000000;
int n,u,v,d[N];
long long fct[N],p[N],s[N],ans;
int main(){
  cin.tie(0)->sync_with_stdio(0);
  cin >> n;
  fct[0] = 1;
  for(int i = 1;i < N;i ++) fct[i] = fct[i - 1] * i % MOD;//预处理 i 的阶乘
  for(int i = 1;i < n;i ++){
    cin >> u >> v;
    d[u] ++,d[v] ++;//统计度数
  }
  p[0] = s[n + 1] = 1;
  for(int i = 1;i <= n;i ++) p[i] = p[i - 1] * fct[d[i] - 1] % MOD;//度数减一的阶乘的前缀和
  for(int i = n;i;i --) s[i] = s[i + 1] * fct[d[i] - 1] % MOD;//度数减一的阶乘的后缀和
  for(int i = 1;i <= n;i ++) ans = (ans + p[i - 1] * s[i + 1] % MOD * fct[d[i]]) % MOD;
  printf("%lld\n",ans);
  return 0;
}
```
## 后话
一开始不知道数据是民间造的，发现输出 $0$ 可以得后 $40$ 分，于是写了这篇题解的前一个版本，~~内含大量对出题人发电的内容。~~

---

## 作者：XCDRF_ (赞：9)

# P13020 [GESP202506 八级] 遍历计数 题解

[题目链接](https://www.luogu.com.cn/problem/P13020)

[转至专栏阅读](https://www.luogu.com.cn/article/zyba50i8)

## 解题思路

题目让我们计算一棵树上所有不同的 DFS 序的数量。将题目转化一下：计算在 DFS 的过程中，每一步有多少种选择，然后将所有选择数相乘。

设 $V = \{1, 2, \dots, n\}$ 为树的节点集合，$\text{Count}(s)$ 为从节点 $s$ 出发的不同 DFS 序的数量。总数 $\text{Total}$ 为：$\sum_{s \in V} \text{Count}(s)$。

先考虑固定起点的情况。对于起点 $s$，可以按任意顺序访问相邻节点，也就是有 $\text{deg}(s)!$ 种情况，剩下的点也可以按任意顺序访问相邻节点，但是不能访问父节点，所以有 $(\text{deg}(u)-1)!$ 种情况。

以该节点为起点的情况数为：
$$
\begin{align*}
\text{Count}(s) &= \text{deg}(s)! \times \prod_{u\in V, u \neq s}  (\text{deg}(u) - 1)!\\
&= \text{deg}(s) \times \prod_{u\in V}  (\text{deg}(u) - 1)!\\
\end{align*}\\
$$

所以总数为：

$$
\begin{align*}
\text{Total} &= \sum_{s \in V} \text{Count}(s) \\
&= \sum_{s\in V} (\text{deg}(s) \times \prod_{u\in V}  (\text{deg}(u) - 1)!)\\
&=\prod_{u\in V}  (\text{deg}(u) - 1)!\times\sum_{s\in V} \text{deg}(s)
\end{align*}
$$ 

因为所有顶点的度数之和等于边数的两倍。所以在一棵有 $n$ 个节点的树中：
$$\sum_{s \in V} \text{deg}(s) = 2(n-1)$$

将此结果代回到原式中，总数为：

$$
\text{Total} = \prod_{u\in V}  (\text{deg}(u) - 1)! \times 2(n-1)
$$

注意：当 $n=1$ 时，DFS 序数量为 $1$，需要特判。

## 参考代码

```cpp
#include<iostream>
using namespace std;
const int N=1e5+5,mod=1e9;
int n,ans;
int deg[N],fac[N]={1};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	ans=2*(n-1);
	if(n==1){
		cout<<1;
		return 0;
	}
	for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=1,x,y;i<n;i++){
		cin>>x>>y;
		deg[x]++,deg[y]++;
	}
	for(int i=1;i<=n;i++) ans=1ll*ans*fac[deg[i]-1]%mod;
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/221864061)

---

## 作者：sunkuangzheng (赞：5)

以 $r$ 为根的答案是 $\prod \limits_{i=1}^n (\text{deg}_i - [i \ne r])!$，求和化简后即为 $\sum \text{deg}_i \cdot \prod\limits_{i=1}^n (\text{deg}_i - 1)! = (2n-2)\prod\limits_{i=1}^n(\text{deg}_i -1)!$。注意 $n=1$ 时答案是 $1$。

```cpp
#import<iostream>
long d['六'],u,v,n,x=1,P=1e9,i=1;
int main(){
    for(std::cin>>n;i<n;i++)std::cin>>u>>v,d[u]++,d[v]++;
    for(;i;i--)while(--d[i]>0)x=d[i]*x%P;
    std::cout<<(n^1?(2*n-2)*x%P:1);
}
```

---

然而注意到模数是 $2^9\times 5^9$，因此只要有一个度数大于等于 $41$ 的点答案就一定是 $0$。这就意味着本质不同的根 $r$ 只有 $40$ 个，对每一个分别暴力计算一次 $\prod \limits_{i=1}^n (\text{deg}_i - [i \ne r])!$ 也可通过。

---

## 作者：xStrawberry (赞：3)

## 题目
[传送门](https://www.luogu.com.cn/problem/P13020)

## 思路
### $40$ pts （$n$ 次 DFS）
> 先来看一个比较简单的图。
> 
> ![1(2345(67))](https://cdn.luogu.com.cn/upload/image_hosting/cuw9rlc9.png)
> 
> 以点 $1$ 为根，先不看点 $5$ 的孩子，易得 DFS 序有 $P(4,4) = 4!$ 种。即**孩子总数的全排列**。
> 
> 用相同的方式处理以点 $5$ 为根的子树，可知遍历到点 $5$ 后有 $2$ 种可能。**相乘**后可得以点 $1$ 为根的 DFS 序总数为 $4! \times 2$ 种。

设 $f_i$ 为以点 $i$ 为根的子树的 DFS 序数，$c_i$ 为点 $i$ 的孩子总数，点 $j$ 为点 $i$ 的孩子。可得：

$$f_i \leftarrow c_i! \times \prod f_j$$

按照题意枚举所有可能的根或借助超级源点。时间复杂度 $O(n^2)$，无法通过本题。

### $60$ pts  （特判链）
- 以链头尾为根的 DFS 序唯一。
- 链的中间节点有 $2$ 个孩子，以其为根有 $2$ 种 DFS 序。

链的 DFS 序总数为 $2n-2$。

### $100$ pts   （$2$ 次 DFS）
对 $n$ 次 DFS 的做法进行优化。
> 回到上面那张图。在第一次遍历中，我们已经得到了以点 $1$ 为根时所有子树的 DFS 序列数。现在我们尝试将其快速地转移至以点 $5$ 为根时的 DFS 序列数。
>
> 两种情况的主要差别在于点 $1$ 和点 $5$ 父子身份的对调。**点 $1$ 去掉点 $5$ 对点 $1$ 的贡献之后，点 $5$ 需要添上它对点 $5$ 的贡献。**
>
> 我们可以利用点 $2$、点 $3$、点 $4$ 的子树 DFS 序数重新计算点 $1$ 的子树 DFS 序数，再利用点 $1$、点 $6$、点 $7$ 的子树 DFS 序数重新计算点 $5$ 的子树 DFS 序数。方便起见，计算点 $5$ 的子树 DFS 序数时，补乘上点 $1$ 的子树 DFS 序数和点 $5$ 的孩子总数即可。
>
> 最后恢复现场。这样就可以在第 $2$ 次 DFS 后解决问题了。

设 $f'_i$ 为点 $i$ 新的子树 DFS 序数，点 $k$ 为点 $i$ 即将成为根的孩子。可得：
$$f'_i \leftarrow (c_i-1)! \times \prod_{j\neq k} f_j$$
$$f'_k \leftarrow f_k \times c_k \times f'_i $$
时间复杂度 $O(n)$，可以通过本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
const int N = 1e6 + 10, M = 1e9;

using namespace std;

int n, f[N], jc[N], ans, f1[N];
vector<int> g[N];

void get_jc(){
	jc[0] = 1;
	for(int i=1; i<=n; i++){
		jc[i] = jc[i-1] * i;
		jc[i] %= M;
	}
}

void dfs1(int u, int pa){
	if(pa == 0){
		f[u] = jc[g[u].size()];
	}else{
		f[u] = jc[g[u].size()-1];
	}
	for(auto v: g[u]){
		if(v == pa) continue;
		dfs1(v, u);
		f[u] *= f[v];
		f[u] %= M;
	}
	f1[u] = f[u];
}

void dfs2(int u, int pa){
	for(auto v: g[u]){
		if(v == pa) continue;
		f[u] = jc[g[u].size()-1];
		for(auto k: g[u]){
			if(k == v) continue;
			f[u] *= f[k];
			f[u] %= M;
		}
		f[v] *= g[v].size();
		f[v] %= M;
		f[v] *= f[u];
		f[v] %= M;
		ans += f[v];
		dfs2(v, u);
		f[v] = f1[v];
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i=1; i<n; i++){
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	get_jc();
	dfs1(1, 0);
	ans = f[1];
	dfs2(1, 0);
	cout << ans;
	return 0;
} 
```

如有错漏，欢迎指正。

---

## 作者：SudoXue (赞：3)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18958293)

整棵树的深度优先遍历序列只取决于两个自由度：起点 $s$ 的选择，以及每个结点遍历其子结点的先后顺序。把树看成以 $s$ 为根的有根树，根有 $\deg(s)$ 个子结点可任选顺序，其他结点各有 $\deg(u)-1$ 个子结点可自由排列；按照乘法原理，固定根 $s$ 时的序列条数就是 $\deg(s)!\times\!\!\prod_{u\neq s}(\deg(u)-1)!$。将所有根的贡献相加可提出公共乘积得到：

$$
\sum_{s=1}^n\deg(s)!\!\!\prod_{u\ne s}(\deg(u)-1)!=
\Bigl(\prod_{u=1}^n(\deg(u)-1)!\Bigr)\!\sum_{s=1}^n\deg(s)=\Bigl(\prod_{u=1}^n(\deg(u)-1)!\Bigr)\,2(n-1)
$$

因为树的度数和恒为 $2(n-1)$。于是答案就是 $\Bigl(\prod_{u=1}^n(\deg(u)-1)!\Bigr)\times2(n-1)\pmod{10^9}$。

实现只需一次遍历统计所有度数，再用阶乘预处理（模 $10^9$ 取值即可，反正不做逆元），时间复杂度 $O(n)$。

[link](https://www.luogu.com.cn/record/221869340)

---

## 作者：yanbinmu (赞：2)

首先我们有一个很显然的树形 DP。

令 `f[u]` 为根节点为 `u` 的子树内的方案数，然后更新就是对于子树求乘积，并乘上子节点数的阶乘。

然后我们可以考虑换根，这时候有一个很难搞的问题，就是我们换根是需要除法的，但是模数不是质数，当然，我们可以维护一个前后缀的答案，再把阶乘单独拿出来之类的，也可以实现，事实上，这是我赛时做法，但这样太麻烦了。

我们可以考虑固定某一个点时根时，其他的点对于答案的贡献是什么。

我们发现这些东西都是些累乘，并没有加和。所以，在确定了根节点时，这其实是每一个点都有一部分贡献，而这部分贡献就是子节点数的阶乘。

只有根节点会有一些不同，他不再是度数减一的阶乘，而是度数的阶乘。

说到这里，答案就很好算了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
const int Mod = 1e9;

int d[N];
int pre[N], suf[N];
int fac[N];

int main() {
    int n;
    cin >> n;
    for(int i = 1, u, v;i < n;i ++ ) {
        cin >> u >> v;
        d[u] ++ ;
        d[v] ++ ;
    }
    fac[0] = 1;
    for(int i = 1;i <= n;i ++ ) {
        fac[i] = fac[i - 1] * i % Mod;
    }
    pre[0] = 1;
    for(int i = 1;i <= n;i ++ ) {
        pre[i] = 1ll * pre[i - 1] * fac[d[i] - 1] % Mod;
    }
    suf[n + 1] = 1;
    for(int i = n;i >= 1;i -- ) {
        suf[i] = 1ll * suf[i + 1] * fac[d[i] - 1] % Mod;
    }
    long long ans = 0;
    for(int i = 1;i <= n;i ++ ) {
        ans += 1ll * pre[i - 1] * suf[i + 1] % Mod * fac[d[i]] % Mod;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Chen_Henry (赞：2)

先考虑固定根节点的树。

当遍历到一个节点时，我们接下来有 $son _ {i}$ 个选择（$son _ {i}$ 表示点 $i$ 的子节点数量），选择一个遍历，回溯后又有 $son _ {i} - 1$ 种选择，以此类推，共有 $son _ {i} !$ 种不同的选择方式。

根据乘法原理，这棵树的深度优先遍历序的数量为

$$\prod _ {i = 1} ^ {n} son _ {i} !$$

容易发现，除根结点外，所有的 $son _ {i}$ 都等于 $d _ {i}-1$ （$d _ {i}$ 表示点 $i$ 的度数），而根节点的 $son _ {i}$ 等于 $d _ {i}$。

所以这棵树的深度优先遍历序的数量又可以表示为（设根节点编号为 $root$）

$$d _ {root} \prod _ {i=1} ^ {n} (d _ {i}-1)!$$

那么，固定根节点的树我们考虑完了，接下来考虑不固定根节点的树。

显然，根节点改变了，上面的公式中只有 $d _ {root}$ 的值会发生更改。

所以整棵树（不固定根节点）的深度优先遍历序的数量可以表示为

$$\sum _ {i=1} ^ {n} d _ {i} \prod _ {j=1} ^ {n} (d _ {j}-1)!$$

我们可以提前处理出 $d$ 数组和阶乘数组，然后处理出

$$\prod _ {i=1} ^ {n} (d _ {i}-1)!$$

的值，最后代入上面的公式循环求和就行了。

还要注意一点，当 $n = 0$ 时，计算的答案会是 $0$ 所以记得特判加一。

**记得取模！！！**

### 代码
```cpp
#include<bits/stdc++.h>
#define MOD 1000000000
#define int long long 
using namespace std;
int n,d[100005],a[100005];
signed main(){
	cin>>n;
	a[0]=a[1]=1;
	for(int i=2;i<=n;i++) a[i]=i*a[i-1]%MOD;  //处理阶乘数组
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		d[u]++;
		d[v]++;  //处理d数组
	}
	int x=1;
	for(int i=1;i<=n;i++) x=x*a[d[i]-1]%MOD;  //计算公式中的累乘部分
	int ans=0;
	for(int i=1;i<=n;i++) ans=(ans+x*d[i]%MOD)%MOD;  //计算答案
	if(n==1) ans++;
	cout<<ans<<endl;
	return 0;  //完结撒花！
}
```

---

## 作者：ZHR100102 (赞：2)

[Blog](https://www.cnblogs.com/zhr0102/p/18957901)

还以为 GESP 也出了个树的遍历，结果是个【数据删除】题，鉴定为打 NOIP2024 打的。

先考虑**钦定某个根**的情况，此时不难想出一个**树形 DP**：$dp_i$ 表示 $i$ 的子树内遍历的情况数，转移方程为：
- $i \ne root , dp_{i}=(d_i-1)!\times \prod_{j} dp_j$。
- $i=root,dp_{i}=d_i!\times \prod_{j} dp_j$。

其中 $d_i$ 表示 $i$ 的度数。可以理解为随意安排走子节点的顺序。

不断往根节点的 DP 值代入，不难发现 $dp_{root}$ 其实就是 $d_{root}!\times \prod_{j\ne root}(d_j-1)!$。

这个式子是很好计算的，于是我们先**预处理**阶乘，然后枚举根节点，算出其余节点的贡献乘积即可。具体地，把所有点拍到一个序列上，预处理**前缀和后缀的乘积**，即可做到 $O(n)$ 求每个节点为根时的答案。

其实这个题就是树的遍历里 $k=1$ 的部分分加强了一下，但我当时愣是没想出来这 24pts，我才是奶龙！！！

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
const int N=100005;
const ll mod=1e9;
ll n,d[N],pre[N],suf[N],g[N],ans;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		d[u]++;d[v]++;
	}
	g[0]=1;
	for(int i=1;i<=n;i++)
		g[i]=(g[i-1]*i)%mod;
	pre[0]=suf[n+1]=1;
	for(int i=1;i<=n;i++)
		pre[i]=(pre[i-1]*g[d[i]-1])%mod;
	for(int i=n;i>=1;i--)
		suf[i]=(suf[i+1]*g[d[i]-1])%mod;
	for(int i=1;i<=n;i++)
		ans=(ans+pre[i-1]*suf[i+1]%mod*g[d[i]]%mod)%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：b__b (赞：1)

我们先只考虑一个起点的情况。设结点 $x$ 的度数为 $d_x$。

对于起点的下一层，显然每一个儿子都是可以遍历的，可以遍历的结点数量为 $d_s$，访问的顺序有 $d_s!$ 种可能。

当这个结点不是起点结点时（设这个结点为 $x$），由于它的父结点已经访问过了，因此可以遍历的结点数量为 $d_x-1$，访问的顺序有 $(d_x-1)!$ 种可能。

因此起点确定时访问顺序有 $d_s!\prod\limits_{i=1,i\neq s}^n(d_i-1)!$ 种可能。

现在我们扩展到起点未确定的情况。上面的式子可以改写为：

$$
\begin{aligned}
d_s!\prod\limits_{i=1,i\neq s}^n(d_i-1)!&=d_s(d_s-1)!\prod\limits_{i=1,i\neq s}^n(d_i-1)!\\
&=d_s\prod\limits_{i=1}^n(d_i-1)!
\end{aligned}
$$

其中 $\sum\limits_{i=1}^n(d_i-1)!$ 是一个定值，于是我们可以得到：

$$
\begin{aligned}
\sum\limits_{i=1}^n(d_s!\prod\limits_{i=1,i\neq s}^n(d_i-1)!)&=\sum\limits_{i=1}^n(d_s\prod\limits_{i=1}^n(d_i-1)!)\\
&=(\sum\limits_{i=1}^n d_s)(\prod\limits_{i=1}^n(d_i-1)!)
\end{aligned}
$$

（$\sum\limits_{i=1}^n(d_s!\prod\limits_{i=1,i\neq s}^n(d_i-1)!)$ 其实就是答案。）

每一条边都会给两个顶点的度数分别加一，因此总度数就是 $2(n-1)$。

因此答案就是 $2(n-1)(\prod\limits_{i=1}^n(d_i-1)!)$。

注意到这里面有很多阶乘运算，可以考虑预处理每一个数的阶乘。

特判：当 $n=1$ 时答案应为 $1$。

```cpp
#include <cstdio>
const int MOD = 1e9, N = 1e5 + 5;
int jc[N], deg[N];
int main() {
    int n;
    scanf("%d", &n);
    if (n == 1) {putchar('1'); return 0;}
    for (int i = 1, u, v; i < n; ++i) scanf("%d%d", &u, &v), ++deg[u], ++deg[v];
    for (int i = jc[0] = 1; i <= n; ++i) jc[i] = jc[i - 1] * 1ll * i % MOD;
    int tmp = 1;
    for (int i = 1; i <= n; ++i) tmp = tmp * 1ll * jc[deg[i] - 1] % MOD;
    printf("%lld", tmp * 1ll * (2 * (n - 1)) % MOD);
}
```

---

## 作者：MARSandEARTH (赞：0)

记 $dp_{u,i}$ 为以 $i$ 为根时选择子树 $u$ 时的 dfs 方案数，$sz_{u,i}$ 为以 $i$ 为根时子树 $u$ 的子树个数。

则 $dp_{u,i}=sz_{u,i}!\prod dp_{v,i}$，若为叶子则 $dp_{u,i}=0!=1$。

简化 DP 式，易得 $dp_{i,i}=\prod(sz_{u,i}!)$，答案为 $\sum dp_{i,i}$。

注意到除根节点外，其余点的子树个数均为该点的结点度数 $-1$，那么有 $dp_{i,i}=\prod_{j=1}^{i-1}(deg_{j,i}-1)!\times\prod_{j=i+1}^{n}(deg_{j,i}-1)!\times deg_{i,i}!$，显然可以前后缀优化，最终复杂度 $O(n)$。

核心代码：


```cpp
cin>>n;
for(int i=1;i<n;i++){
    int u,v;
    cin>>u>>v;
    deg[u]++,deg[v]++;
}
pre[0]=nxt[n+1]=1;
for(int i=1;i<=n;i++){
    pre[i]=pre[i-1]*fac[deg[i]-1]%Mod;
}
for(int i=n;i>=1;i--){
    nxt[i]=nxt[i+1]*fac[deg[i]-1]%Mod;
for(int i=1;i<=n;i++){
    ans+=pre[i-1]*nxt[i+1]%Mod*fac[deg[i]]%Mod;
    ans%=Mod;
}
cout<<ans;
```

---


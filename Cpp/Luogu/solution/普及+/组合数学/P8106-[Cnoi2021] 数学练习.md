# [Cnoi2021] 数学练习

## 题目背景

「Cnoi2021」Cirno's Easy Round II 热身赛开始了。

## 题目描述

为了让选手们重视文化课，Cirno 特意加入了一道 Kamishirasawa Keine 老师的数学练习：

> 求将一个集合 $\texttt{U}=\{1,2,3,\cdots,n\}$ 划分成两个子集 $S,T$，使得 $|S|\notin S,|T|\notin T$ 的方案数。

由于选手都不会高精度，所以答案只需要对 $998244353$ 取模即可。

## 说明/提示

**样例解释** 

#1: 两种合法的划分方案为 $\{1,3\},\{2\}$ 与 $\{2\},\{1,3\}$ 。

**数据范围**

对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$。


## 样例 #1

### 输入

```
3```

### 输出

```
2```

## 样例 #2

### 输入

```
6```

### 输出

```
10```

## 样例 #3

### 输入

```
65535```

### 输出

```
459810767```

# 题解

## 作者：3a51_ (赞：22)

### 思路

首先，我们设两个子集元素个数分别为 $s1,t1$。由于 $s1 \notin S$，可以得知 $s1 \in T$。同理，$t1 \in S$。所以还剩 $n-2$ 个元素，可以随便排放，只要使得 $|S|=s1$ 即可。可以从 $n-2$ 里面挑出 $s1-1$ 个放入 $S$ 中，这样 $|S|=s1$ 了。因为 $s1+t1=n$，所以此时 $|T|=t1$。满足条件。不难看出这个方法数就是 $C_{n-2}^{s1-1}$。

我们现在就可以把 $s1$ 变成 $1$ 至 $n-1$，因为空集不满足要求。列出式子:

$$C_{n-2}^{n-1-1}+C_{n-2}^{n-2-1}+C_{n-2}^{n-3-1}+\cdots+C_{n-2}^{2-1}+C_{n-2}^{1-1}$$

$$=C_{n-2}^{n-2}+C_{n-2}^{n-3}+C_{n-2}^{n-4}+\cdots+C_{n-2}^{2}+C_{n-2}^{1}+C_{n-2}^{0}$$

考虑这个式子的真实含义。其实就是 $n-2$ 个人，选 $0,1,\cdots,n-3,n-2$ 个人，有多少种方案。

所以就是选若干个。每一个人都可以选/不选，根据乘法原理，可以得到原式 $=2^{n-2}$。

难道这就结束了吗？那样例 $2$ 为什么答案不是 $2^{6-2}=2^4=16$ 呢？

观察一下，发现当 $n$ 为偶数时会有一种情况：$s1=t1$。此时 $s1 \notin S$ 且 $s1 \notin T$。很明显不符合要求。所以要把这种情况排除出去。对应的，当 $n$ 为偶数的时候，答案需要少 $C_{n-2}^{\frac{n-2}{2}}$，需要减掉。考虑用一个乘法逆元及快速幂解决组合数， $2^{n-2}$ 直接```for```循环算就行了。如果不懂乘法逆元的话，提供一个[链接](https://www.cnblogs.com/bytebull/p/6006816.html)，自行阅读。因为篇幅问题，这里不做过多赘述。

### code

```cpp
#include<iostream>
#define int long long
using namespace std;
const int Mod=998244353;
int jc[100006];
void init()
{
	jc[0]=jc[1]=1;
	for(int i=1;i<=100005;i++)
		jc[i]=(jc[i-1]%Mod*i%Mod)%Mod; 
}//预处理阶乘
int qpow(int a,int b,int c)
{
	int res=1;
	while(b)
	{
		if(b&1)
			res=res*a%Mod;
		b>>=1;
		a=a*a%Mod;
	}
	return res%Mod;
}//快速幂
int C(int a,int b)
{
	return jc[a]%Mod*qpow(jc[b],Mod-2,Mod)%Mod*qpow(jc[a-b],Mod-2,Mod)%Mod;
}//计算组合数，详细见链接
signed main()
{
	int n;
	cin>>n;
    if(n==1)
    {
        cout<<0;
        return 0;
    }//特判，否则会WA on #4
	init();//预处理阶乘
	int ans=1;
	for(int i=1;i<=n-2;i++)
		ans=(ans*2)%Mod;//计算2的n-2次方
	if(n%2==0)//如果n为偶数
	{
		int m=n-2,j=C(m,m/2);//计算组合数
		ans-=j;//将答案减去组合数
		ans+=Mod;//因为减是模意义下的，可能出现负数如6>4但6%5<4%5。所以加一个Mod再取模。
	}
	cout<<ans%Mod;//输出
	return 0;
}
```

---

## 作者：RockyYue (赞：4)

# 解题思路

这么水的题竟然没有大佬交题解...

首先，$\because |S| \notin S, |T| \notin T \therefore |S| \in T, |T| \in S$。

确定了这两个值在哪边，其余 $(n-2)$ 个排在哪边都无所谓了，有 $2^{n-2}$ 种方法。

注意一个值不能同时在 S 和 T 中，则 $|S| \ne |T|$。这种情况只会在 $n$ 为偶数时发生，所以此时的总方案数应该减去从 $n-2$ 个数中选出一半放在 S 中的数量，即 $C_{n-2}^{(n-2)/2}$。
最后注意的是 $n=1$ 时需要特判，因为根本没有 $|S|$ 和 $|T|$ 两个值。

# 代码实现

组合数取模用了一点 Lucas。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int P = 998244353;
int qpow(int x, int y) {
	int res = 1;
	while (y) {
		if (y & 1) {
   			(res *= x) %= P;
		}
		(x *= x) %= P;
		y >>= 1;
	}
	return res;
}
int C(int n, int m) {
	int a = 1, b = 1;
	for (int i = 1; i <= m; ++i) {
		(a *= i) %= P;
		(b *= n - i + 1) %= P;
	}
	return b * qpow(a, P - 2) % P;
}
int Lucas(int n, int m) {
    return !m ? 1 : C(n % P, m % P) * Lucas(n / P, m / P) % P;
}
signed main() {
	ios :: sync_with_stdio(0);
    int n;
    cin >> n;
    if (n == 1) {
		cout << 0 << '\n';
		return 0;
	}
    int res = qpow(2, n - 2);
    if (!(n & 1)) {
    	(res -= Lucas(n - 2, n - 2 >> 1) - P) %= P;
	}
	cout << res << '\n';
	return 0;
}
```

Good Good 贺题，Day Day Up！！

---

## 作者：TernaryTree (赞：3)

简单排列组合题。思维难度大概橙~黄。

首先看到数据范围 $n\le 10^5$，马上想到线性枚举 $|S|$，则 $|T|=n-|S|$。

考虑求出有多少个满足条件的 $S$。

对于一个数 $k$，它要么出现在 $S$ 中，要么出现在 $T$ 中。所以，既然 $|T|\not\in T$，就有 $|T|\in S$，也就是说，$S$ 要满足下面两个式子：

$$
\begin{cases}
|S|\not\in S \\
n-|S|\in S
\end{cases}
$$

因为确定了 $S$，$T$ 也就确定了，因为 $|T|$ 已经在 $S$ 里了，所以此时剩下的 $T$ 也是满足条件的。

也就是说问题转化为如何从 $1\sim n$ 的排列中选 $|S|$ 个数使得上面那个条件成立。

枚举 $|S|=i$。从 $n$ 个数里面选 $i$ 个且满足条件，也就是说从 $n-2$ 个数里面选 $i-1$ 个数（因为 $i$ 首先不能选，$n-i$ 已经选上了，所以只需要在剩下的 $n-2$ 个数里面选 $i-1$ 个就好了），这个是我们熟悉的组合，表达为：

$$C_{n-2}^{i-1}$$

而 $i=|S|$ 是 $1\sim n-1$ 的。答案就是一个式子：

$$
\begin{aligned}
&\sum_{i=1}^{n-1}C_{n-2}^{i-1} \\
=&\sum_{i=0}^{n-2}C_{n-2}^{i}
\end{aligned}
$$

当你自信满满地放上去一个快速幂你会发现你 WA 了而且连样例二都过不去。

实际上，如果 $n$ 是偶数的话，当 $|S|=|T|=\dfrac12n$ 时，$|S|$ 会被要求既不能出现在 $S$ 里又不能出现在 $T$ 里，所以情况数是 $0$。怎么办呢？直接特判偶数，在原来答案上减去 $C_{n-2}^{\frac12n-1}$ 即可。

这里实际上直接快速幂求逆元就可以做到 $\Theta(n\log n)$ 了，预处理出逆元也可以做到 $\Theta(n)$。

但是这里我们可以继续优化。关于这道题我觉得可以加多组数据，上面是 $\Theta(qn)$ 的，而下面优化后可以达到 $\Theta(n+q\log n)$。

考虑到杨辉三角的性质。杨辉三角第 $i$ 行第 $j$ 个元素恰好表示 $C_{i}^j$（从 $0$ 开始），因为杨辉三角每个数都是上一行的相邻两个数之和，所以一行的总和就是上一行的两倍。也就是说，

$$\sum_{i=0}^kC_k^i=2^k$$

把 $n-2$ 当做 $k$ 带进去，我们发现得到了原来的式子，也就是说，答案就是

$$2^{n-2}-C_{n-2}^{\frac12n-1}$$

当你自信满满地推出了这个式子交上去的时候，你会发现第 $4$ 个点 TLE 了，并且开始怀疑自己程序的时间复杂度正确性。这个时候我们再看一眼时间复杂度，这个时候看下界：$1\le n$。所以，$n=1$ 的时候上面那个式子就不适用了，直接输出 $0$ 就好了。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int mod = 998244353;
const int maxn = 1e5;

int n;
int fac[maxn + 1];
int inv[maxn + 1];

int power(int base, int freq, int mod) {
	int tmp = base, ans = 1;
	while (freq) {
		if (freq & 1) ans = ans * tmp % mod;
		freq >>= 1;
		tmp = tmp * tmp % mod;
	}
	return ans;
}

void init() {
	fac[0] = 1;
	for (int i = 1; i <= maxn; i++) {
		fac[i] = fac[i - 1] * i % mod;
	}
	inv[maxn] = power(fac[maxn], mod - 2, mod);
	for (int i = maxn - 1; i >= 0; i--) {
		inv[i] = inv[i + 1] * (i + 1) % mod; 
	} 
}

int C(int n, int m) {
	if (n < m) return 0;
	return fac[n] * inv[m] % mod * inv[n - m] % mod;
}

signed main() {
	init();
	cin >> n;
	if (n == 1) {
		cout << 0 << endl;
		return 0;
	}
	n -= 2;
	if (n % 2 == 0) {
		cout << (power(2, n, mod) - C(n, n / 2) + mod) % mod; 
	} else {
		cout << power(2, n, mod); 
	}
	return 0;
}
```

---

## 作者：0xFF (赞：3)

#### 题目大意


------------

$\text { 求将一个集合 } \mathrm{U}\{1,2,3, \cdots, n\} \text { 划分成两个子集 } S, T \text { ，使得 }|S| \notin S,|T| \notin T \text { 的方案数。 }$


#### 思路分析


------------
设 $|S| = m$,则 $m \in T$。

因为总共有 $n$ 个元素，所以 $T$ 集合中总共有 $n-m$ 个数，即 $|T| = n - m$，故 $(n-m) \in S$。

综上分析，在对所有元素分组之前已经有两个元素的归属确定了，所以题目等价于求在 $n-2$ 个元素中选 $m-1$ 个元素的方案数。

故答案为 $\sum_{i=0}^{n-2} C_{n-2}^{i} $

然而上面的思路甚至无法通过样例二。

观察样例二不难发现，当 $n$ 是偶数时，上面思路统计的方案数必然会存在重复的方案，因为一个偶数必然可以分成两个相等的数。

所以当 $n$ 是偶数时，只需要从刚才的情况中减去相等的情况即可。

做到这一步已经可以轻松的通过此题了，但是仍然存在更进一步的优化。

根据组合数的性质 $\sum_{i=0}^{n} C_{n}^{i}=2^{n}$，考虑将上述式子优化成 $2^{n-2}$ 再减去不符合情况的方案数即可。

#### 代码实现


------------
```cpp
long long n,f[N],inv[N];
long long qpow(long long x,long long k){
	long long ans = 1;
	while(k > 0){
		if(k & 1) ans = ans * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return ans;
}

inline long long C(long long n,long long m){
	if(n < m) return 0;
	if(m > n - m) m = n - m;
	long long a = 1 , b = 1;
	for(int i=0;i<m;i++){
		a = (a * (n - i)) % mod;
		b = (b * (i + 1)) % mod;
	}
	return a * qpow(b,mod-2) % mod;
}

inline long long Lucas(long long n,long long m){
	if(m == 0) return 1;
	return Lucas(n/mod,m/mod) * C(n % mod , m % mod) % mod;
}

int main(){
	n = read();
	if(n == 1){
		cout<<0<<endl;
		return 0;
	}
	long long ans = qpow(2,n-2);
	
	if(n % 2 == 0){
		ans -= (Lucas(n-2,n/2-1 ) - mod);
		ans %= mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Tzs_yousa (赞：2)

# 前置芝士
### 组合数
从 $n$ 个不同元素中，任取 $m$ 个元素并成一组，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个组合；从 $n$ 个不同元素中取出 $m$ 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的组合数。

公式为 ${ n \choose m }$ 也就是 $n$ 个里取  $m$ 个（我不会第一篇题解那样的排版呜呜）。

同时 ${ n \choose m }$ = $\frac {n!} {m!(n - m)!}$

### 快速幂
相信来做这道题的都会快速幂吧，简而言之就是在 $log$ 级别的时间求出来结果

### 费马小定理
费马小定理：假如 $p$ 是质数，且 $gcd(a , p)$ = 1，那么 $a$ ($p$ - 1)  ≡ 1 （$mod$ $p$)。即：假如 $a$ 是整数，$p$ 是质数，且 $a$ ，$p$ 互质(即两者只有一个公约数1)，那么 $a$ 的($p$ - 1)次方除以p的余数恒等于1。

[证明](https://baijiahao.baidu.com/s?id=1692592276181016038&wfr=spider&for=pc)

因此，显而易见它的 $p$ - 2 次方就是它的取模意义下的逆元了呗。

# 解题思路
再回过头来看这个题，当你理解题意时，你会发现如果 $n$ 是偶数，两个集合的大小相等时，是矛盾不成立的，所以就先要分类讨论。

**先讨论比较简单的奇数情况**

当我们两个集合的大小分别为 $a$, $b$ 时， $b$ 这个数一定要在集合1里， $a$ 一定要在集合2里，所以我们就要从剩下的 $n - 2$ 个里面挑出来 $a - 1$ 个数， 当然挑出来 $b - 1$ 个也可以。

我们再考虑 $a - 1$ 的范围是从0到 $n - 2$ 的，那么就是从 ${ n - 2 \choose 0 }$ 到 ${ n - 2 \choose n - 2 }$ 的和， **通过二项式定理可知就是2的 $n - 2$ 次方**，也可以考虑实际意义，每个人都可以挑或者不挑。

**再考虑偶数的情况**

前面已经说过，当两个集合大小相等的时候是不成立的，那我们直接减去这部分不就行啦。也就是减去 ${ n - 2 \choose (n - 2) / 2}$.
# AC code
```cpp
#include <bits/stdc++.h>
#define int long long
const int MAXN = 1e5 + 10;
const int mod = 998244353;
using namespace std;
int n, jc[MAXN], inv[MAXN], ans;
int quick_pow(int a, int p)
{
	int res = 1;
	while(p)
	{
		if(p & 1) (res *= a) %= mod;
		(a *= a) %= mod;
		p >>= 1;
	}
	return res % mod;
}
int C(int x, int y)
{
	return jc[x] * inv[y] % mod * inv[x - y] % mod;
}
signed main()
{
	scanf("%lld", &n);
	if(n == 1)
	{
		printf("0");
		return 0;
	}
	if(n & 1)
	{
		printf("%lld", quick_pow(2, n - 2));
	}
	else
	{
		jc[0] = jc[1] = 1;
		for (int i = 2; i <= n; i++) jc[i] = (jc[i - 1] * i) % mod;
		inv[n] = quick_pow(jc[n], mod - 2) % mod;//这里其实直接fermat就行了，不用预处理出来所有的，但是在多组的时候这样写的好处就会很明显
		for (int i = n - 1; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod;
		ans = quick_pow(2, n - 2);
		printf("%lld", (ans - C(n - 2, (n - 2) / 2) + mod) % mod);
	}
	return 0;
} 
```


---

## 作者：pengzy___ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8106)

## 思路：

题目描述中告诉你 $\left | S \right | \notin S$ ， $\left | T \right | \notin T$ ，所以可得出 $\left | S \right | \in T$ ， $\left | T \right | \in S$ 。剩下的 $n-2$ 个数怎么放都无所谓了，所以就有 $2^{n-2}$ 种方法。但是，答案并不只是 $2^{n-2}$ 。因为，当 $n$ 为偶数时，一个值不能同时存在于 $S$ 和 $T$ 两个子集中。所以，当 $n$为偶数时 ，答案要减去 $C_{n-2}^{\frac{n-2}{2}} $ 。

------------

[快速幂代码](https://www.luogu.com.cn/paste/0r3sqco6)

[乘法逆元链接](https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83)

[和此题很像的题目](https://www.luogu.com.cn/problem/CF57C)

### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int jc[100005];
void doit()//预处理阶乘
{
    jc[0]=jc[1]=1;
    for(int i=1;i<=100005;i++)
        jc[i]=(jc[i-1]%mod*i%mod)%mod; 
}
int fpow(int b,int p)//快速幂
{
    int ans=1;
    while(p)
    {
        if(p&1)ans=ans*b%mod;
        p>>=1;
        b=b*b%mod;
    }
    return ans%mod;
}
int C(int x,int y)//乘法逆元
{
    return jc[x]%mod*fpow(jc[y],mod-2)%mod*fpow(jc[x-y],mod-2)%mod;
}
signed main()// main 不允许有 long long main
{
    int n,ans=1;
    cin>>n;
    if(n==1){cout<<0;return 0;}//特判
    doit();
    for(int i=1;i<=n-2;i++)
        ans=(ans*2)%mod;
    if(n%2==0)ans=(ans-C(n-2,(n-2)/2)+mod)%mod;
    cout<<ans%mod;
    return 0;
}
```


---

## 作者：_Aurore_ (赞：1)

题目：求将一个集合 $ \texttt{U}\{1,2,3,\cdots,n\}$ 划分成两个子集 $S,T$ ，使得 $|S|\notin S,|T|\notin T$
的方案数。

这道题目，我们可以更加清晰明了的理解题目：求将一个集合 $ \texttt{U}\{1,2,3,\cdots,n\}U{1,2,3,⋯,n}$ 划分成两个子集 $S,T$ ，使得 $|T|\in S,|S|\in T$ 的方案数。

并且，只要知道了 $|U|$ , $|S|$ ,我们就知道了$|C|=|U|-|S|$ ，这很好理解，那么 $n$ 已经给出，我们可以枚举 $|S|-1$ ，是因为 $|T|\in S,|S|\in T$ 不用额外枚举这两个数，所以 $S$ 合法的方案数为 $C_{|U|-2}^{|S|}$ 。因为 $\sum_{i\notin S}i\in T$ ,我们不需要额外枚举 $T$ 集合合法的方案数了。

现在我们得出了公式：

$$ans=\sum_{i=0}^{n-2}C_{n-2}^{i}$$

根据组合恒等式： $\sum_{i=0}^{n}C_{n}^{i}=2^n$

将刚刚的公式带入，得：
$$ans=\sum_{i=0}^{n-2}C_{n-2}^{i}=2^{n-2}$$

## 等等，还没完！
特别的，当 $ n$ 是 $ 2$ 的倍数时，总有 $|S| = |T|$ ,所以答案减去 $C_{n-2}^{\frac{n-2}{2}}$ 即可。详见代码

# $code$
```
#include<bits/stdc++.h>
#define p 998244353
#define ll long long 
using namespace std;
ll n;
ll quickpower(ll a,ll b){
	ll base=a,ans=1;
	while(b>0){
		if(b & 1) ans=ans*base%p;
		base=base*base%p;
		b=b>>1;	
	}
	return ans%p;
}
ll C(ll m,ll n){
	ll ans=1,sum=1;
	for(ll i=n;i>n-m;i--) ans=ans*i%p;
	for(ll i=1;i<=m;i++) sum=sum*i%p;
	return ans*quickpower(sum,p-2)%p; 
}
int main(){
    cin>>n;
    if(n<=2) cout<<0;
    else if(n%2!=0)	cout<<quickpower(2,n-2);
    else{
    	ll ans=(quickpower(2,n-2)-C((n-2)/2,n-2))%p;
    	if(ans<0) ans+=p;
    	cout<<ans;
	}
} 
```
管理大大，上次交有些地方表述、汉字有误，已更正，再交一遍。


---

## 作者：Surge_of_Force (赞：1)

[博客阅读效果更佳](https://www.luogu.com.cn/blog/love-forever-764/solution-p8106)
### 1. 题意

题意很清楚：给你一个由 $n$ 的排列组成的集合，让你分成两个非空的子集 $S$ 和 $T$，使得与 $S$ 的大小（即 $|S|$）相等的元素不在 $S$ 中，与 $T$ 的大小（即 $|T|$）相等的元素不在 $T$ 中。
### 2.解法一

我们可以把题意转化一下，既然 $|S|\notin S$，$|T|\notin T$，那么便有 $|S|\in T$，$|T|\in S$，即对于每种划分方式，总有两个元素所在集合已经确定了我们就可以考虑枚举 $|S|$，方案数就是: 
$$\sum_{i=1}^{n-1}\mathrm{C}_{n-2}^{i-1}\qquad (n\bmod2=1)$$
$$\sum_{i=1}^{n-1}\mathrm{C}_{n-2}^{i-1}-\mathrm {C}_{n-2}^{\frac{n-2}{2}}\qquad (n\bmod2=0)$$

因为 $|S|=|T|$ 时不存在合法解，所以要减去 $\mathrm {C}_{n-2}^{\frac{n-2}{2}}$。

至此，我们已经可以在 $O(n\log n)$ 的复杂度内解决本题了（求逆元自带 $\log$），但还有没有更优的复杂度呢，当然有啦。

### 3.解法二

我们容易发现，上面的 $\sum_{i=1}^{n-1}\mathrm{C}_{n-2}^{i-1}$ 式子其实就是 $\sum_{i=0}^{n-2}\mathrm{C}_{n-2}^{i}$，我们可以套用二项式定理，那么这个式子就等于 $2^{n-2}$ ，可以通过一次快速幂求出，那么复杂度就优化到了 $O(n+\log n)$ 。

### 4.代码

$O(n\log n)$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;
const int MAX=1e5+10;
const int MOD=998244353;
inline int read() {
  int fh = 1, res = 0; char ch = getchar();
  for(; !isdigit(ch); ch = getchar()) if(ch == '-') fh = -1;
  for(; isdigit(ch); ch = getchar()) res = (res << 3) + (res << 1) + (ch ^ '0');
  res = res * fh;
  return res;
}
inline void write(ll x) {
    if(x<0){putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int jc[MAX],ans;
int ksm(int ds,int zs)
{
	int ret=1;
	while(zs)
	{
		if(zs&1) ret=(ret*ds)%MOD;
		zs>>=1;
		ds=(ds*ds)%MOD;
	}
	return ret;
}
int C(int n,int m)
{
	return ((jc[n]*ksm(jc[m],MOD-2))%MOD*(ksm(jc[n-m],MOD-2)))%MOD;
}
signed main()
{
//	cout<<ksm(2,3)<<endl;
	int n=read();jc[0]=1;
	for(int i=1;i<=n;i++) jc[i]=(jc[i-1]*i)%MOD;
	for(int i=1;i<=(n-1)/2;i++)//利用对称性，进行的小优化，同时利用下取整可以省去特判
		ans=(ans+C(n-2,i-1))%MOD;
	cout<<(ans*2)%MOD;
	return 0;
}
```
$O(n+\log n)$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;
const int MOD=998244353;
inline int read() {
  int fh = 1, res = 0; char ch = getchar();
  for(; !isdigit(ch); ch = getchar()) if(ch == '-') fh = -1;
  for(; isdigit(ch); ch = getchar()) res = (res << 3) + (res << 1) + (ch ^ '0');
  res = res * fh;
  return res;
}
inline void write(ll x) {
    if(x<0){putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int ans;
int ksm(int ds,int zs)
{
	int ret=1;
	while(zs)
	{
		if(zs&1) ret=(ret*ds)%MOD;
		zs>>=1;
		ds=(ds*ds)%MOD;
	}
	return ret;
}
signed main()
{
//	cout<<ksm(2,3)<<endl;
	int n=read(),jc1=1,jc2=1;
	if(n<=2) return puts("0"),0;
	if(n&1) cout<<ksm(2,n-2);
	else
	{
		for(int i=1;i<=(n-2)/2;i++) jc1=(jc1*i)%MOD;
		for(int i=(n-2)/2+1;i<=n-2;i++) jc2=(jc2*i)%MOD;
		cout<<(ksm(2,n-2)+MOD-(jc2*ksm(jc1,MOD-2))%MOD)%MOD;
	}
	return 0;
}
```

---

## 作者：zbk233 (赞：1)

## 前置知识

组合数公式：$C_n^m=\frac{n!}{m!(n-m)!}$。

## 解题思路

设集合 $1$ 的长度为 $x$，那么集合 $2$ 的长度为 $n-x$。

那么 $x$ 一定在集合 $2$ 内，$n-x$ 一定在集合 $1$ 内。

我们考虑枚举集合 $1$ 的长度 $x$。

知道长度后，如何求出方案数？

因为集合 $2$ 的 $x$ 已确认，集合 $1$ 的 $n-x$ 也已确认。

所以我们只要算出将 $n-2$ 个元素分别放到大小为 $x-1$ 与 $n-x-1$ 的集合内的方案数。

因为在一个集合内，元素的顺序改变是不会产生新的集合的。

所以这很明显就是一个组合问题，只要算出 $C_{n-2}^{x-1}$ 就可以了。

事实上，处理组合数的这部分可以用乘法逆元来解决，具体见：[P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)。

根据上面的组合数公式，很明显要用到阶乘，但是，如果每枚举一次长度就计算一次阶乘的话，就有太多多余的计算。

所以我们考虑预处理出 $[1,n]$ 的阶乘，节省了时间复杂度。

但是，再考虑一种情况：$x$ 等于 $n-x$。

因为很明显没有两个 $x$，所以这种情况的方案数是 $0$。需要特殊处理。

## 代码实现

```cpp
#include<iostream>
#define ll long long
using namespace std;
const ll mod=998244353;
ll n,ans,a[100005];
void times(){
    a[0]=1;
    for(int i=1;i<=n;i++){
        a[i]=a[i-1]*i%mod;
    }
}
ll fpow(ll x,ll y){
    ll ans=1;
    while(y){
        if(y&1) ans=(ans*x)%mod;
        x=(x*x)%mod;
        y>>=1;
    }
    return ans%mod;
}
ll C(ll n,ll m){
    return a[n]*fpow(a[m],mod-2)%mod*fpow(a[n-m],mod-2)%mod;
}
int main(){
    cin>>n;
    times();
    for(int i=1;i<n;i++){
        if(n-i==i) continue;
        ans=(ans+C(n-2,i-1))%mod;
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：Jasper08 (赞：0)

### 题目分析

因为 $|S|\not\in S$，所以 $|S|\in T$ . 同理可得 $|T|\in S$ . 在 $U$ 剩余的 $(n-2)$ 个元素中，每个元素有 $2$ 种选择：在 $S$ 中或在 $T$ 中。根据加乘原理可知，剩下的元素有 $2^{n-2}$ 种选择。

当 $2|n$ 时，可能出现 $|S|=|T|$ 的情况。此时 $|S|$ 和 $|T|$ 均不在集合 $S,T$ 中，与题目矛盾，所以要去掉这种情况。那么如何计算这种情况呢？$|S|$ 和 $|T|$ 已经固定了，所以 $S$ 和 $T$ 中的元素只能在剩下的 $(n-2)$ 个元素中选，且此时 $S$ 中实际上只有 $(n-2)/2$ 个元素。所以要去掉 $C_{n-2}^{(n-2)/2}$ 种情况。

最后还需考虑 $n=1$ 时的情况。当 $n=1$ 时，$U$ 不可能被划分为两个不同的集合，所以此时答案是 $0$ .

### 实现

由于此题数据范围较大（ $1\leq n\leq 10^5$ ）且有模数（ $mod=998244353$ ），对于奇数的情况，应采用快速幂计算。

```cpp
int power(int a, int b, int p) { //快速幂 
	int ans = 1;
	while (b) {
		if (b & 1)
			ans = (int)ans * a % p;
		a = (int)a * a % p;
		b >>= 1;
	}
	return ans;
}
```

最后输出 $2^{n-2}\bmod 998244353$ 即可。

对于偶数的情况，有 $C_{a}^{b}=\dfrac{a!}{b!(a-b)!}$ . 由于模数是质数，所以除法运算可转换为乘法逆元进行运算，只需进行预处理即可。

预处理阶乘及其逆元：

```cpp
fac[0] = 1;
infac[0] = power(fac[0], mod-2, mod); //阶乘的乘法逆元
for (int i = 1; i <= n; ++i) {
	fac[i] = fac[i-1] * i % mod;
	infac[i] = power(fac[i], mod-2, mod);
}
```

组合数计算：


```cpp
int c(int a, int b) { //组合数(逆元) 
	return fac[a] * infac[a-b] % mod * infac[b] % mod; 
    //相当于 a!/(a-b)!/b! % mod
}
```
最后输出 $(2^{n-2}-C_{n-2}^{(n-2)/2}+998244353)\bmod998244353$ （注意一定要先加上模数，否则答案会是负数，WA on #2,5 ）。

不要忘记特判当 $n=1$ 答案为 $0$ （ TLE on #4 ）。 


### 代码

```cpp
//P8106 [Cnoi2021]数学练习

#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define int long long
#define endl '\n'

const int N = 1e5 + 10;
const int mod = 998244353;

int fac[N], infac[N];

int power(int a, int b, int p) { //快速幂 
	int ans = 1;
	while (b) {
		if (b & 1)
			ans = (int)ans * a % p;
		a = (int)a * a % p;
		b >>= 1;
	}
	return ans;
}

int c(int a, int b) { //组合数(逆元) 
	return fac[a] * infac[a-b] % mod * infac[b] % mod;
}

signed main() {
	int n;
	cin >> n;
	
	if (n == 1)
		cout << 0 << endl;
	else if (n % 2 == 1)
		cout << power(2, n-2, mod) << endl;
	else {
		fac[0] = 1;
		infac[0] = power(fac[0], mod-2, mod);
		for (int i = 1; i <= n; ++i) {
			fac[i] = fac[i-1] * i % mod;
			infac[i] = power(fac[i], mod-2, mod);
		}
		cout << (power(2, n-2, mod)-c(n-2, (n-2)/2)+mod) % mod << endl;
	}
	
	return 0;
}
```

---

## 作者：Lvlinxi2010 (赞：0)

#### 思路
~~水题~~

题目中告诉你 $  \left | S \right | \notin S $ ，$ \left | T \right | \notin T $
所以可得出 $ \left | S \right | \in T $ ， $ \left | T \right | \in S $ 。剩下的 $ n-2 $ 个数怎么放都无所谓了，所以就有 $ 2^{n-2} $ 种方法。
但有个例外：

当 $ n $ 为偶数时，一个值会同时出现在 $ S $ ， $ T $ 中，所以需要特判一下，减去一些情况$C^{(n-2)/2}_{n-2}$，至此，就可以以 $ O(n \log n) $ 结束啦~

tips : $2^{n-2}$ 可以用[费马小定理求逆元](https://blog.csdn.net/gaojunonly1/article/details/79965908?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164301640316780255256884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164301640316780255256884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79965908.first_rank_v2_pc_rank_v29&utm_term=%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83&spm=1018.2226.3001.4187)
。

放上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>//不会用万能头
#define int long long
using namespace std;
const int MAXN = 1e5 + 10;
const int MOD = 998244353;

int n;
int a[MAXN];
int x,y;
int calc(int a,int s,int p){
	int ans=1; 
	while(s){
		if(s&1) ans=ans*a%p;
		a=a*a%p;
		s>>=1;
	}
	return ans%p;
}//快速幂
int zuhe(int m,int n){
	int x=calc(a[m]*a[n-m]%MOD,MOD-2,MOD);
    return a[n]*x%MOD;
}//组合数
signed main(){
    scanf("%lld",&n);
    int ans=0;
    a[0]=1;
    for(int i=1;i<=n;i++){
    	a[i]=a[i-1]*i%MOD;
	}
    int mid=n/2;
    bool judge=false;
    if(n%2==0) judge=true;
   	for(int i=1;i<=n-1;i++){
   		if(judge==true&&i==mid) continue;
   		ans=(ans+zuhe(i-1,n-2))%MOD;
	} 
   	printf("%lld",ans);
    return 0;
}
//完结撒花~~
```


---

## 作者：Think (赞：0)

### 刚刚学完排列组合特来写一篇题解

## 1. 思路
首先题目要求我们将 $1$~$n$ 的数分为两个子集。  
$|S| \notin S$ 且 $|T| \notin T$。  
$|S|$ 表示的是 $S$ 集合中元素的个数。   
由题目的特殊条件我们可以得到该条件的一个**充要条件** ：  
$|S| \in T$ 且 $|T| \in S$。 

这样我们在 “ 安置 ”  好 $|S|$ 和 $|T|$ 后就可以用组合数公式轻松计算出答案了。  
但是这边仍然有一个性质我们没有用到 ：  
**当 $n$ 为偶数时** $|S| \neq |T|$  这是显然的，也是**必要**的。  
## 2. 解法
枚举 $1 $~$ n - 1 $ 作为 S 集合的元素个数。  
已有  $ |T| \in S$。  
利用组合数公式挑选剩下 $i - 1$ 个数。  
由于 $n$ 个数全部挑完 ， 所以剩下的数全部纳入 $T$ 集合。  
我们只需要算 $S$ 集合满足题意的个数即可。  
附上组合数公式 ：  
![](https://s3.bmp.ovh/imgs/2022/03/235d693cdce2562d.webp)  
注意到除号且在模意义下 ， 所以我们需要求 **逆元**。   
注意到此题 $mod$ 的特殊性 ， 所以我们可以使用 **费马小定理** 求解逆元。   
不知道逆元建议先做做 [这道题](https://www.luogu.com.cn/problem/P3811)。   
最后注意 **特判 $n$ 为偶数** 的情况就可以了。
## 3. Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
typedef long long ll;
ll mod=998244353;
ll n;
ll frac[maxn];
ll x,y;
ll inv(ll a,ll s,ll p){ // 费马小定理求逆元
	ll ans=1; 
	while(s){
		if(s&1) ans=ans*a%p;
		a=a*a%p;
		s>>=1;
	}
	return ans%p;
}
ll C(ll m,ll n){
	ll x=inv(frac[m]*frac[n-m]%mod,mod-2,mod);
    return frac[n]*x%mod;
}
int main(){
    scanf("%lld",&n);
    ll ans=0;
    frac[0]=1;
    for(ll i=1;i<=n;i++) frac[i]=frac[i-1]*i%mod; // 预处理阶乘
    ll mid=n/2;
    bool judge=false;
    if(n%2==0) judge=true;
   	for(ll i=1;i<=n-1;i++){
   		if(judge==true&&i==mid) continue; // 特判 n 为偶数
   		ans=(ans+C(i-1,n-2))%mod;
	} 
   	printf("%lld",ans);
    return 0;
}
```


---

## 作者：D2T1 (赞：0)

# 题解 P8106

~~题外话：感觉没有绿~~

------------

## Part 1.排列组合

### 排列

从 $n$ 个不同元素中任取 $m(m\leq n)$ 个元素排成的一列，叫做 $n$ 取 $m$ 的排列，这种排列的个数叫做排列数 $A_n^m$。

$A_n^m=\displaystyle\frac{n!}{(n-m!)}$

### 组合

从 $n$ 个不同元素中任取 $m(m\leq n)$ 个元素形成的组合，叫做 $n$ 取 $m$ 的组合，这种组合的个数叫做组合数 $C_n^m$。

排列有序，组合无序。

$C_n^m=\dbinom{n}{m}=\displaystyle\frac{A_n^m}{A_m^m}=\frac{n!}{m!(n-m)!}$

当 $m>n$ 时，$A_n^m=C_n^m=0$。

费马小定理解法： $A_m^{p-2}\equiv\displaystyle\frac{1}{A_m}(\bmod p)$ 。

```cpp
const int N = 1e5 + 10;
long long A[N];//预处理出阶乘
long long C(long long n, long long m, long long p){
    if(m > n) return 0;
    return (A[n] * qpow(A[m], p-2, p) % p) * 
           qpow(A[n-m], p-2, p) % p;
}
```

------------

## Part 2.解法

既然 $|S|\notin S,|T|\notin T$，那么 $|S|\in T,|T|\in S$。

于是我们可以枚举 $|S|,|T|$，然后直接算排列组合。由于我们已经确定了两个元素的位置，所以求 $C_{n-2}^{|S|-1}$，加起来即可。但要特判 $|S|=|T|$。

具体实现可能有些差异。

```cpp
//P8106
#include <bits/stdc++.h>
using namespace std;

const long long P = 998244353;
long long n, ans, A[100010];

long long qpow(long long a, long long b){
	long long ans = 1;
	while(b){
		if(b&1) ans = ans * a % P;
		a = a * a % P;
		b >>= 1;
	}
	return ans;
}
long long C(long long n, long long m){
    if(m > n) return 0;
    return (A[n] * qpow(A[m], P-2) % P) * qpow(A[n-m], P-2) % P;
}

int main(){
	scanf("%d", &n);
	n -= 2, A[0] = 1, ans += 2;
	if(n <= 0) return puts("0")&0;
	for(long long i = 2; i <= n; ++ i) A[i] = A[i-1] * i % P;
	for(int i = 1; i + i < n; ++ i)
		ans = (ans + C(n, i)) % P,
		ans = (ans + C(n, i)) % P;
	printf("%d\n", ans);
	return 0;
}
```

---


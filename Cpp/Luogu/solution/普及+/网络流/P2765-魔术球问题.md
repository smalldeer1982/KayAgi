# 魔术球问题

## 题目描述

假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1$，$2$，$3$，...的球“

1. 每次只能在某根柱子的最上面放球。

2. 同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。

试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。例如，在 $4$ 根柱子上最多可放 $11$ 个球。

对于给定的 $n$，计算在 $n$ 根柱子上最多能放多少个球。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 55$。

## 样例 #1

### 输入

```
4```

### 输出

```
11
1 8
2 7 9
3 6 10
4 5 11```

# 题解

## 作者：Minclxc (赞：299)

答案中的球数有通项公式，打表后发现是+2+4+4+6+6+8+……

具体证明等大佬来证，我这里给个通项

(n\*(n+2)+(n&1)-2)/2

翻翻以前做的题，看到底下一堆的网络流，把贪心的题解补完整

知道柱子个数后，可以贪心得求得每根柱子上的球，直接从小到大枚举球看能否能否放入即可，效率O(n*m)
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
int min(int a,int b){return a<b?a:b;}
int max(int a,int b){return a>b?a:b;}
int sqr(int a){return a*a;}
int a[100][100];
int main(){
    int n=read(),m=(n*(n+2)+(n&1)-2)/2;
    printf("%d\n",m);
    fo(i,1,m)fo(j,1,n){
    	int x=a[j][a[j][0]];
    	if(!x||sqr(int(sqrt(x+i)))==x+i)
    	    {a[j][++a[j][0]]=i;break;}
	}
    fo(i,1,n){
    	fo(j,1,a[i][0])
		    printf("%d ",a[i][j]);
		printf("\n");
	}
    return 0;
}
```

---

## 作者：天泽龟 (赞：197)

 **蒟蒻做的第一道网络流构造题，太经典了故写题解已记之。**

**20.3.4更新：代码正确性有保证，求求宁别在评论区吐槽了。**

大多数题解都是直接从网络流角度来考虑，我觉得这样并不合适，如果比赛的时候没有TAG给你点，像这种类型的问题都很容易往找规律上靠（但此题确实可以找规律）。

### 于是我们引入一个叫“隐式图”的概念。

隐式图顾名思义，大白话来讲就是题目看着不像是图论，但是可以通过一些限制或关联进行建点，连边，最终通过图论的一些算法来求解。

那么就此题来看，~~经思考一会可~~发现这题的柱子并没有什么实际的作用，所有的操作都是关于珠子的编号的。那么我们可以**以每一个珠子为点，若满足条件（编号相加为平方数）就两两连边**，那么就可得到这样一张图：
![](https://cdn.luogu.com.cn/upload/pic/54357.png)

具体怎么连放代码里说。

题目要你求 “对于给定的n，计算在n根柱子上最多能放多少个球”，转化成图的问题就是 **“对于给定的n，计算不超过n条路径最多可以覆盖多少满足条件的节点”**，如果您已经学了$DAG$的一些二分图相关性质，应该就知道了：	

        最小边覆盖=点总数-最大匹配。 
        
有这么个性质，于是再将此图进行**拆点**，转化成二分图的形式，每加一个点就在上面跑匈牙利/网络流并统计总匹配，如果发现 `点总数-最大匹配>最小边覆盖` 那就退出。

**但是值得注意的是，** 我们每次重新跑网络流时，都是在跑**残量网络**，意思就是我们每次所得的最大流都是**增加的匹配数**，所以就再搞个变量累加得到总的匹配数。


### 但是另一个子问题是求他的路径。

其实把网络流原理搞懂了也不难，二分图里的网络流路径等价于他把流量跑满的路径（流量均为1），于是最后对每个点都找一遍，看到哪个点满流他的下一步就是那个点，储存一下最后输出即可。

**上我丑陋的代码：**
```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#define N 10000
#define NN 30000
#define inf 2147483647
using namespace std;

struct ed{
	int u,next,w;
}e[200000];
int spr[10000],n,st=1,sum,c[50001],fir[50001],d[50100];
queue<int> q; bool v[50000];
int to[10000],pd[10000]; 

void add(int x,int y,int w)
{
	e[++st].u=y; e[st].next=fir[x]; e[fir[x]=st].w=w;
}

bool bfs()
{
	for (int i=0;i<=50000;i++) d[i]=inf/2,v[i]=0,c[i]=fir[i];
	q.push(0); v[0]=1; d[0]=0;
	while (!q.empty())
	{
		int k=q.front(); q.pop();
		for (int i=fir[k];i;i=e[i].next)
		{
			int u=e[i].u,w=e[i].w;
			if (d[u]>d[k]+1&&w)
			{
				d[u]=d[k]+1; if (!v[u]) v[u]=1,q.push(u);
			}
		}
	}
	return (d[NN]<inf/2);
}
int dfs(int p,int now)
{
	if (p==NN) return now;
	int mw=0,used=0;
	for (int i=c[p];i;i=e[i].next){
		c[p]=i; int u=e[i].u,w=e[i].w;
		if (d[u]==d[p]+1&&w)
		if (mw=dfs(u,min(w,now-used)))
		{
			e[i].w-=mw; e[i^1].w+=mw; used+=mw;
			
			if (used==now) break;
		}
	}
	return used;
}

int dinic()
{
	int ans=0;
	while (bfs()) ans+=dfs(0,inf);
	return ans;
}

void check()
{
	for (int i=0;i<=n;i++) 
	for (int j=fir[i];j;j=e[j].next) cout<<i<<" "<<e[j].u<<" "<<e[j].w<<endl;
	for (int i=10001;i<=10001+n;i++) 
	for (int j=fir[i];j;j=e[j].next) cout<<i<<" "<<e[j].u<<" "<<e[j].w<<endl;

}

int main()
{
	cin>>n;
	for (int i=1;i<=5000;i++) spr[i]=i*i;
	int num=1;
	while ("lyc qwq!")  //膜同学保平安
	{
		int kk=lower_bound(spr+1,spr+1000,num)-spr;
		add(0,num,1),add(num,0,0),add(num+N,NN,1),add(NN,num+N,0);
        	//我们可以通过二分来确立当前的数最大可以匹配到那个平方数（每次都只连比他小的边，就避免了重复）
		for (int j=2*kk;j>=1;j--)
		{
			int k=spr[j]-num;
			if (k<num&&k>0) add(k,N+num,1),add(N+num,k,0);
			//把隐式图直接转为二分图
		}
		int ans=dinic(); sum+=ans;
		if (num-sum>n) break;
		num++;	
	}  //就是那个公式的体现
	cout<<num-1<<endl;
	for (int k=1;k<num;k++)
	{
		for (int i=fir[k];i;i=e[i].next) if (!e[i].w) {
				to[k]=e[i].u-N; break;
			}//由于存二分图的时候拆点多加了N，这里减掉
	}
	for (int i=1;i<num;i++)  //递推求解。
	{
		if (pd[i]) continue; 
		for(int k=i;k>0;k=to[k])
		{
			pd[k]=1;
			cout<<k<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```




---

## 作者：zhaoyifan (赞：104)

魔术球问题

作为变换型的第一道网络流题，有必要好好写一下思路。

首先这是一道网络流的题，网络流dinic算法的核心是dfs，

其作用是对已有的网络进行调整，找出一条至少为1可以到达重点的路径

其中调整的核心是反向边

观察本题，对于一个进来的编号的球，他有两种情况，

1.放在某个和他组成平方数的球的后面

2.独立门户

我们要使这两种情况都合法，这样我们可以发挥网络流调整的优势

对于两种情况，为了使结果合法，我们姑且先将它和t直接相连

2情况显然要和s相连，1情况要和前面的点相连

又和s相连，又和t相连，还要和别的点相连，显然一个点是不够的

我们把一个点分开来，分开来的两个点不能相连，否则最大流就没有意义了

直接s-u-u'-t显然没有调整的作用

那么我们将u和s相连，u’和t相连，为了满足第一种条件

满足关系的两个点u、v，建立v-u'

那么在图中跑最大流算法即可

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<iomanip>
    #include<algorithm>
    #include<cmath>
    #include<queue>
    #define in(x) scanf("%d",&x)
    using namespace std;
    const int maxn=1e5;
    int n,all=0,num=0,nxt[maxn],to[maxn],head[maxn],d[maxn];
    int w[maxn],cnt=1,s=0,t=50003,re[maxn],xia[maxn],vis[maxn];
    queue<int>q;
    void add(int x,int y,int we)
    {
        nxt[++cnt]=head[x];head[x]=cnt;to[cnt]=y;w[cnt]=we;
        nxt[++cnt]=head[y];head[y]=cnt;to[cnt]=x;w[cnt]=0;
    }
    int bfs()
    {
        while(q.size()) q.pop();q.push(s);
        memset(d,0,sizeof(d));d[s]=1;
        while(q.size())
        {
            int x=q.front();q.pop();
            for(int i=head[x];i;i=nxt[i])
            {
                int u=to[i];
                if(d[u]||w[i]<=0) continue;
                d[u]=d[x]+1;
                q.push(u);
            }
        }
        return d[t];
    }
    int dfs(int x,int flow)
    {
        if(x==t) return flow;
        int k;
        for(int i=head[x];i;i=nxt[i])
        {
            int u=to[i];
            if(d[u]!=d[x]+1||w[i]<=0) continue;
            if(k=dfs(u,min(w[i],flow)))
            {
                w[i]-=k;w[i^1]+=k;
                if(u!=t) xia[x>>1]=u>>1;
                return k;
            }
        }
        return 0;
    }
    int dinic()
    {
        int k=0;
        while(bfs())
        {
            while(1)
            {
                int p=dfs(s,1e9);
                if(!p) break;
                k+=p;
            }
        }
        return k;
    }
    int main()
    {
        in(n);
        while(all<=n)
        {
            num++;add(s,num<<1,1);add((num<<1)|1,t,1);
            for(int i=sqrt(num)+1;i*i<2*num;++i)
            add((i*i-num)<<1,(num<<1)|1,1);
            int k=dinic();
            if(!k) re[++all]=num;
        }
        printf("%d\n",--num);
        for(int i=1;i<=n;++i)
        {
            if(vis[re[i]]) continue;
            int x=re[i];vis[x]=1;
            while(x!=0)
            {
                printf("%d ",x);
                x=xia[x];vis[x]=1;
            }
            printf("\n");
        }
        return 0;
}
```

---

## 作者：KSkun (赞：68)

这是对[mjtlyzbsy](https://www.luogu.org/space/show?uid=35775)同学题解的一点说明，他的题解可以看楼下或者进入他的博客[题解 P2765 【魔术球问题】 - mjtlyzbsy 的博客 - 洛谷博客](https://www.luogu.org/blog/user35775/solution-p2765)。

本题解同时发布于我的博客[网络流24题题解 | KSkun's Blog](https://ksmeow.moe/graph_flow_24prob_sol/)，欢迎来逛。

2019/10/10 UPD：修复了博客地址，并增加一个细节的展开讨论。感谢@木守球 同学提出的很好的问题。

>木守球 2019-09-05 08:57

>敢问关于您P2765的题解。网络流dfs撤销原来的路径的时候，可能记录路径会导致那个点记录的是往回走的路径，为什么不会出现这种情况呢？

>木守球 2019-09-05 08:57

>比如 C可以和A,B形成完全平方数，但是D只能和A形成，轮到C的时候和走S-A-C-T，然后轮到D的时候，D必须和A连接，所以走增广路， S->B->C->A（这条是反悔的路径，这时候C的下一个节点记录的是A）->D->T

>KSkun 2019-10-10 19:08

>抱歉我退役很久了，偶尔上一次洛谷才看到了你的疑问，导致没能及时回复。 这里的增广路确实可能会导致撤流问题，但当撤流在某一个点改变方向后，第一个不在原来那条增广路上的点的pre值一定会记录下撤流的终点，即原增广路在新增广路上的最远的那个点，因此反推的过程中会跳过撤回的部分。 这一特性确保了答案中不会出现撤流重复。


## 题解

首先我们考虑如何建图，即表达相邻球之间的关系。

可以将一个球拆点为$A_i$和$B_i$，先从源点$S$向$A_i$连容量为1的边，从$B_i$向汇点连容量为1的边。对于能够与它编号和为完全平方数的球j，连接$A_j$和$B_i$。这样的图有什么特性，在底下的分析中会展现出来。

枚举球数，球数每增加1就建立新加入的球的关系，并且重复地跑最大流。柱子数对于球数存在一种单调递增的相关关系，我们这样可以求出某一柱子数下最多能放置的球数，因为当新加入的球能够加入柱子时，重复跑最大流是能得到新流（即：该球可与其他球构成新的相邻关系）的，只要一直能得到新流，就说明柱子上还可以再加，当有一次得不到新流，就说明柱子满了，新加入的球并没能加入到任何一个柱子上。此时我们就加柱子。直到柱子加到超过n，此时的球数-1就是最大球数（因为此时实际上柱子加到超过n了）。

至于输出每个柱子上的球，我们可以记下第一个加入柱子的球。在DFS得到增广路的过程中，总是记下该点连接的下一个点的球的编号，形成类似链表的结构。最后再取出第一个加入柱子的球，来遍历它所在的那条链。

注释中也有部分说明。


## 代码

```cpp
// Code by KSkun, 2018/1
#include <cstdio>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
#include <algorithm>

const int MAXN = 1000005;
const int INF = 1e9;

struct Edge {
    int to, cap, rev;
    Edge(int to, int cap, int rev): to(to), cap(cap), rev(rev) {}
};

std::vector<Edge> vec[MAXN];
std::queue<int> que;
int level[MAXN], pre[MAXN];

inline void addedge(int u, int v, int cap) {
    vec[u].push_back(Edge(v, cap, vec[v].size()));
    vec[v].push_back(Edge(u, 0, vec[u].size() - 1));
}

// Dinic 

inline bool bfs(int s, int t) {
    memset(level, -1, sizeof level);
    level[s] = 0;
    que.push(s);
    while(!que.empty()) {
        int u = que.front();
        que.pop();
        for(int i = 0; i < vec[u].size(); i++) {
            int v = vec[u][i].to;
            if(level[v] == -1 && vec[u][i].cap > 0) {
                level[v] = level[u] + 1;
                que.push(v);
            }
        }
    }
    return level[t] != -1;
}

inline int dfs(int u, int t, int left) {
    if(u == t) return left;
    for(int i = 0; i < vec[u].size(); i++) {
        int v = vec[u][i].to;
        if(vec[u][i].cap > 0 && level[v] == level[u] + 1) {
            int d = dfs(v, t, std::min(left, vec[u][i].cap));
            if(d > 0) {
                vec[u][i].cap -= d;
                vec[v][vec[u][i].rev].cap += d;
                // u representes the ball number floor(u / 2), and so as v
                pre[u >> 1] = v >> 1;
                return d;
            }
        }
    }
    return 0;
}

inline int max_flow(int s, int t) {
    int flow = 0;
    while(bfs(s, t)) {
        int f;
        while((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
    return flow;
}

int n, s = 1000001, t = 1000002, pillar = 0, now = 0, head[10005];
bool vis[1000005];

int main() {
    scanf("%d", &n);
    // add more pillars if possible
    while(pillar <= n) {
        now++; // try to add one more ball
        addedge(s, now << 1, 1);
        addedge((now << 1) | 1, t, 1);
        // find the ball which can connect to this
        for(int i = sqrt(now) + 1; i * i < (now << 1); i++) {
            addedge((i * i - now) << 1, (now << 1) | 1, 1);
        }
        int flow = max_flow(s, t);
        if(!flow) {
            // when it needs to add more pillars, record the first ball added to the next pillar
            head[++pillar] = now;
        }
    }
    printf("%d\n", now - 1);
    for(int i = 1; i <= n; i++) {
        if(!vis[head[i]]) {
            for(int u = head[i]; u != 0 && u != (t >> 1); u = pre[u]) {
                vis[u] = true;
                printf("%d ", u);
            }
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：poorpool (赞：44)

发现好像没人来证明贪心啊……那我来写一下它的证明


欲证明：放一个数在已有的柱上（如果可以）总是比新开一个柱更优的


假如已经放了`x1..x2....xu..xv..xw....`

现在我要放`xx`


我有两种策略


在`xu`（`xu`代表可以与`xx`组成完全平方数的数）上放，或者新开一个柱子


即
`x1..x2....xx..xv..xw....`

or
`x1..x2....xu..xv..xw....xx`


然后再考虑`xx+1`


对于`x1..x2......xv..xw....`，上下两种都是一样的，就不说了


既然`xu`可以与`xx`组成完全平方数，则`xu+xx=a\*a`

可以发现，`xu+1+xx` **不可以放在xu上面**，（为什么呢？倘若可以，即`xu+1+xx==b\*b`，即`1=b\*b-a\*a`，而`b>a>=1……`）

那么，`xx+1`还不如放在`xx`上哩。


如果`xx+1`放在不是`xx`上的地方，则上面一种更优。因为倘若再来个什么`xa`，它大可以再开一个柱子。（有的同学可能发现这里的证明有点不完整，大概说一下，就是考虑`xa`放在`xu`上的所有柱子的形态和新开一个柱子的所有柱子的形态）。


代码很好写啦。（据说$n\leq 60$）

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
int n, cnt, ans=1, isa[3205];
vector<int> d[62];
int main(){
    for(int i=1; i*i<=3205; i++)
        isa[i*i] = true;
    cin>>n;
    while(1){
        for(int i=1; i<=cnt; i++)
            if(isa[d[i][d[i].size()-1]+ans]){
                d[i].push_back(ans);
                ans++;
                i = 0;
                continue;
            }
        if(cnt<n)
            d[++cnt].push_back(ans++);
        else break;
    }
    cout<<ans-1<<endl;
    for(int i=1; i<=n; i++){
        for(int j=0; j<d[i].size(); j++)
            printf("%d ", d[i][j]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：35)

###这道题是一个非常好网络流题目

弱弱的说一句这是道题好像是网络流二十四题中的04

虽然可以用贪心或者一些玄学算法可以很快的跑过，但建议还是用网络流

并且网络流的建图真的很棒

**思路：**

我们先枚举球，一个个加到图里

#并在加边的过程是三个操作：

- 当然不可缺少的是拆点把一个球x拆成x和x'

- 下一步x连源点，x'连汇点都是容量为一的有向边

- 第三步是找这个数可以与那个数组成完全平方数，假设这个数为y，则y向x'连边

下面就是跑最大流了，在跑最大流的时候记录一下这个点向那个点流出流量（这就是代码中的nex[]）![]( ![](https://cdn.luogu.com.cn/upload/pic/8289.png) )

**\_最后就是最让人期待的上代码环节了 ┗|｀O′|┛ 嗷~~\_**
```cpp
#include<cstdlib>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<queue>
#include<vector>
#include<cmath>
using namespace std;
const int INF=(1<<30);
const int maxn=400000;
int idx=0,e[maxn],f[maxn],ne[maxn],h[100000]; 
void add(int a,int b,int c){
    e[idx]=b,ne[idx]=h[a],f[idx]=c,h[a]=idx++;
    e[idx]=a,ne[idx]=h[b],f[idx]=0,h[b]=idx++;
}
int S,T,ch[maxn],q[maxn],nex[maxn];
bool tell(){
    memset(ch,-1,sizeof(ch));
    int head=0,tail=0;
    ch[q[0]=S]=0; 
    while(head<=tail){
        int t=q[head++];
        for(int i=h[t];i!=-1;i=ne[i]){
            if(ch[e[i]]==-1&&f[i]){
                ch[q[++tail]=e[i]]=ch[t]+1;
            }
        }
    }
    return ch[T]!=-1;
}
int zeng(int a,int b){
    if(a==T)return b;
    int r=0;
     for(int i=h[a];i!=-1;i=ne[i]){
        if(ch[a]+1==ch[e[i]]&&f[i]){
            int t=zeng(e[i],min(b-r,f[i]));
            if(t>0)nex[a>>1]=(e[i]>>1);
            f[i]-=t;r+=t;f[i^1]+=t;
        }
    }
    if(!r)ch[a]=-1;
    return r;
}
int dinic(){
    int r=0,t=0;
    while(tell()){
        while(t=zeng(S,INF)){
            r+=t;
        }
    }
    return r;
}
bool vis[maxn];
int w[1000];
int main(){        
    int n;
    S=0;T=10010;
    memset(h,-1,sizeof(h)); 
    memset(nex,-1,sizeof(nex));
    scanf("%d",&n);
    int now=0,num=0;
    while(now<=n){
        ++num;
        add(S,num<<1,1);add((num<<1)|1,T,1);
        for(int i=sqrt(num)+1;i*i<(num<<1);i++)add((i*i-num)<<1,(num<<1)|1,1);
        int s=dinic();
        if(s==0)w[++now]=num;
    }
    printf("%d\n",--num);
    memset(vis,false,sizeof(vis));
    int k;
    for(int i=1;i<=n;i++){
        if(!vis[w[i]]){
            k=w[i];printf("%d ",k);vis[w[i]]=true;
            while(nex[k]!=-1&&nex[k]!=(T)>>1&&nex[k]!=0){
                k=nex[k];
                vis[k]=true;
                printf("%d ",k);
            }
            printf("\n");
        }
    }
}
```
此题也可以用二分图做，希望能有dalao发一下二分图的做法


---

## 作者：lolte (赞：23)

### 这是GD初二蒟蒻 $lolte$ 的题解
仍然在写网络流24题，不得不说学校的SPJ真是咕咕了，差点让我怀疑人生。

在学网络流自然就是要用的，因此本题我使用的是dinic。

参考了 @zhaoyifan 的题解。

----

本题中有柱子和球两种物品，但柱子并没有什么特性，并不需要考虑。所以考虑根据球建图。

球只能放在每根柱子的最上面且与相邻的球之和为完全平方和。由于一个点难以兼顾如此多点要求，不难想到将球拆成 $i*2$ 和 $i*2+1$ 两个点。将每个球依次放入柱子上。

现在考虑如何让现在的球与之前的球建边。因为只能与编号更小的连边，考虑枚举  $i$ ，使得 $now<i*i<2*now$ 。则$now+(i*i-now)$ 为完全平方数, $i*i-now<now$。让 $(i*i-now)*2$ 向 $now*2+1$连边。此时跑一遍网络流，若能有流，则表明当前球可放在之前球。否则新开一根柱子。

----

问题来了，题目不是要求要放在最上面吗？上面没考虑啊？而且不会把之前点的流量算进去吗？

不用担心，因为网络流的特性，在计算当前时，已经把可以行的跑满了，不会考虑之前的点。

那我们就做完了。

输出每根柱子时，根据残余流量输出即可（还有流量的就不是啦）

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=0;
	char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar()) f^=(ch=='-');
	for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	return f ? -x : x; 
}
const int maxn=1600;
int n,z=0,dep[maxn*2],head[maxn*2],cnt=1,cur[maxn*2],s=3198,t=3199,now=0;
int qwq[60],maxflow=0,q[maxn*2],l,r;
bool vis,inq[maxn*2];
struct node{
	int to,nxt,w;
}e[10000004];
inline void add(int u,int v,int w) {
	e[++cnt].w=w;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
bool bfs(){
	memset(inq,0,sizeof(inq));
	memset(dep,0x3f,sizeof(dep));
	memcpy(cur,head,sizeof(head));
	l=1;r=0;
	q[++r]=s;inq[s]=1;dep[s]=0;
	while (l<=r) {
		int u=q[l++];
		inq[u]=0;
		for (int i=head[u];i;i=e[i].nxt) {
			int v=e[i].to;
			if (dep[u]+1<dep[v]&&e[i].w) {
				dep[v]=dep[u]+1;
				if (!inq[v]) {
					inq[v]=1;
					q[++r]=v;
				}
			}
		}
	}
	return dep[t]<100000;
} 
int dfs(int u,int flow) {
	if (u==t) {
		maxflow+=flow;
		vis=1;
		return flow;
	}
	int goflow=0,used=0;
	for (int &i=cur[u];i;i=e[i].nxt) {
		int v=e[i].to;
		if (e[i].w&&dep[u]+1==dep[v]) {
			goflow=dfs(v,min(e[i].w,flow-used));
			if (!goflow) continue;
			used+=goflow;
			e[i].w-=goflow;
			e[i^1].w+=goflow;
			if (used==flow) break;
		}
	}
	return used;
}
void dinic(){
	//printf("dinic : %d\n",now);
	maxflow=0;
	while (bfs()) {
		//puts("qwq");
		vis=1;
		while (vis) {
			vis=0;
			dfs(s,2147483600);
		}
	} 
	/*if (maxflow) {
		printf("ok %d\n",now);
	}
	else printf("die %d\n",now);*/
}
void out(int u) {
	for (int i=head[u];i;i=e[i].nxt) {
		int v=e[i].to;
		if (v==t||v==s) continue;
		if (e[i].w) continue;
		printf("%d ",v/2);
		int q=v/2;
		out(q*2);
	}
}
int main(){
	n=read();
	while (z<=n) {
		++now;
		add(s,now*2,1);add(now*2,s,0);
		add(now*2+1,t,1);add(t,now*2+1,0);
		for (int i=sqrt(now)+1;i*i<2*now;++i) {
			add((i*i-now)*2,now*2+1,1);
			add(now*2+1,(i*i-now)*2,0);
		}
		dinic();
		if (!maxflow) {
			qwq[++z]=now;
		}
	}
	--now;
	printf("%d\n",now);
	for (int i=1;i<=n;++i) {
		printf("%d ",qwq[i]);
		out(qwq[i]*2);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：宁_缺 (赞：22)

# 发一篇二分图做法的
首先，根据题目，用柱子来算最多的球数不好求（~~反正我不会求~~），那就用球数来算柱子，要使柱子上的球最多，就要用最少的柱子来放球，咋求最少的柱子数呢？

我们可以构建一个图：当两个球的编号之和为完全平方数时连一条边，显然这是一个DAG（**有向无环图**）,这样，最少的柱子数就转换成了这个DAG中的**最小路径覆盖**

求最小路径覆盖很简单，就是把这个DAG的每个点拆成两个点u和v，然后原本指向这个点的边改为指向u,原本从这个点出发的边变为从v出发，然后这个图就变成了二分图，求这个二分图的**最大匹配**,**原图中的顶点数减去最大匹配**就是最小路径覆盖答案了

然后貌似题解区的巨佬全都选择了Dinic,但我实在不想打，就搞了个简短的二分图模板过掉了

惊悚的是居然有位神人说匈牙利算法复杂度大可能TLE，要用Dinic来优化掉一个根号，我一交33ms……话说要是全按照时间复杂度来搞你连网络流模板都过不掉(理论上比Dinic更优的ISAP也是O(n²m的）

最后附上代码（27行）
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
using namespace std;
const int N=1601,M=N<<4;
int pn,to[M],c[N],nt[M],hd[N];
int lk[N],n,m,mxp;bool v[N];
inline bool dfs(int x){
	for(int i=hd[x],u=to[i];i;i=nt[i],u=to[i])
		if(!v[u]&&(v[u]=1)&&(!lk[u]||dfs(lk[u])))
			return (lk[u]=x)?1:1;
	return false;
}
int main(){
	scanf("%d",&n);
	for(int o;m-mxp<=n;){
		m++,o=sqrt(m)+1;
		for(int i=o,x,y;i*i<2*m;i++)
			x=m,y=i*i-m,pn++,to[pn]=y,
			nt[pn]=hd[x],hd[x]=pn;
		mxp+=dfs(m),memset(v,0,sizeof(v));
	}
	printf("%d",--m);
	for(int i=1,j;i<=m;i++)if(!v[i])
		for(puts(""),j=i;j;j=lk[j])
			printf("%d ",j),v[j]=1;
	return 0;
}
```

---

## 作者：wjh2022 (赞：20)

$$本文将尝试给出贪心的证明$$

拿到题目，手玩 $n$ 较小的情况即可发现，「最多放入的球的数量」似乎是成规律增长的，将得到的放置方法整理出来，即可得到贪心策略，本文将基于如下的贪心策略进行证明：

对于任意 $n$，基于 $n-1$ 得到的放置方法，接下来，对于任意一个球：

- 若无法在已有的柱子上放，则新开一个柱子，将该球放入。

- 若可以在已有的柱子上放，则将该球放入。

- 否则，球无法放入，放置结束，得到了 $n$ 的答案。

这样得到的答案是呈 $+2+2+4+4+6+6$ 规律增长的。

接下来，我们尝试证明该贪心

首先，将递推式用通项公式表示出来，记 $a_i$ 表示有 $i$ 个柱子时的最大值，则有

1. $a_{2k-1}=2k^2-1,k \in Z_+$

2. $a_{2k}=2k^2+2k-1,k \in Z_+$

两个式子的证明是类似的，故只给出一式的证明，如下：

证明构造结果最大，即证 $2k^2$ 无法放入。

在所有正确的贪心构造中，都有一个性质：最上面一层的球的大小是连续的。

故上面一层的球大小为 $[2k^2-2k+1,2k^2-1]$。

此时，因为

$$(2k-1)^2<(2k^2-2k+1)+2k^2<(2k^2-1)+2k^2<(2k)^2$$

所以无法放入 $2k^2$。

下证上文性质为何成立。

若最上面一层并非 $[2k^2-2k+1,2k^2-1]$，则在该区间内必有一个球不在最上面一层。

又因为对于任意一个球，设其大小为 $x$，则其上方的球的大小一定大于 $x$，故对于上面的区间，必有两个大小在其中的球上下相邻。

设这两个球的大小和为 $sum$，则因为

$$(2k-1)^2<(2k^2-2k+1)+(2k^2-2k+1)<sum<(2k^2-1)+(2k^2-1)<(2k)^2$$

故该情况不成立，得证上界。

------------

因为我们易证 $n=1$ 的答案，故证明以上式子的结果可以由构造达到，即证一式成立时二式成立，且二式成立时一式成立，最后使用数学归纳法即可。

以下证明二式成立时一式成立。

证明一式的构造结果可以达到，则因为

$$a_{2k-2}=a_{2(k-1)}=2(k-1)^2+2(k-1)-1=2k^2-2k-1$$

则依照构造，在新柱子上放入 $2k^2-2k$，由于此时球的最上面一层是连续的，故有：

$$(2k^2-2k)+(2k^2-2k+1)=4k^2-4k+1=(2k-1)^2$$

$$(2k^2-2k-1)+(2k^2-2k+2)=4k^2-4k+1=(2k-1)^2$$

$$ \dots $$

故可达到一式结果，证毕。

---------

因为这是篇题解，所以要给出 $\text{code}$。

```cpp
//#pragma GCC optimize (2)
#include <bits/stdc++.h>
//#include <windows.h>
#define ll long long
#define mid (l+r>>1)
#define lowbit(x) (x&-x)

using namespace std;
const int N = 60;

int n;
int h[N];	// h[i] 表示第 i 个柱子的高度 
int a[N][N];	// a[i][j] 表示第 i 个柱子，从下往上数第 j 个球的大小 

bool check(int x, int y)	// 判断 x+y 是否为完全平方数
{
	int k = 1;
	while (k * k <= x + y)
	{
		if (k * k == x + y)	return true;
		k ++ ;	
	}
	return false;
}

signed main()
{
	cin >> n;
	
	int tot = 0, now = 1;	// tot 表示已经开了的柱子数量，now 表示目前应该放的球的大小（注意，并非已经放的最大球的大小！P2765 魔术球问题） 
	for (int i = 1; i <= n; i ++ )	// 递推计算 n=i 时的答案 
	{
		while (true)
		{
			bool flag = true;
			for (int j = 1; j <= tot; j ++ )
				if (check(a[j][h[j]], now))
				{
					h[j] ++ , a[j][h[j]] = now ++ ;
					flag = false;
					break;
				}
			
			if (flag == true)	// 无法放入，则新开一个柱子，若亦无法新开柱子，则已得到 n=i 的一个结果 
			{
				if (tot < i)	tot ++ , h[tot] = 1, a[tot][1] = now, now ++ ;
				else break;
			}
		}
	}
	
	int sum = 0;
	for (int i = 1; i <= n; i ++ )	sum += h[i];
	cout << sum << "\n";
	for (int i = 1; i <= n; i ++ )
	{
		for (int j = 1; j <= h[i]; j ++ )	cout << a[i][j] << " ";
		cout << "\n";
	}
	
	return 0;
}
```

-----

upd on 2024.11.25：才发现以前原来有人做过类似的证明/kel，这下尴尬了。

从以球数为自变量，最少的柱子数量为因变量（大概）的证明：[here](https://www.cnblogs.com/UntitledCpp/p/MoShuQiu_Proof.html)

一个看起来很厉害但我没看懂的：[here](https://kczno1.blog.uoj.ac/blog/3851)

---

## 作者：Capella (赞：13)

>建图和楼上楼下大同小异，我的重点在**匈牙利算法**。

最小路径覆盖。


给定了柱子数n（最小路径覆盖数）以及放球条件（建边条件），求最多有多少个球（最多有多少个点可以满足这个最小路径覆盖数）。


枚举球的数量。


每来一个球（点）m，枚举1..m-1的每个点i，若i+m满足建边条件（和为完全平方数）则按以下方式建边——


套路拆点，每个点i拆成Xi、Yi，对于一组i、m，连Xi<->Y(m+5000)**双向**，跑匈牙利算出最大匹配。


根据二分图相关定理：最小路径覆盖数=点数-最大匹配数。


算出当前图的最小路径覆盖k，与给定柱子数比较。


- k<n，继续加球。

- k=n，可能还有更大的答案，继续加球。

- k>n，m-1就是答案，停止加球。


输出路径，遍历1..m-1每个X部点，向其匹配点走，直到无路可走，沿路标记为已遍历。


已遍历过的X部点不再遍历。


解释下为什么需要双向边。


如图（乱画的），来了一个m点后，紫色边是新加的边。


![](http://ww3.sinaimg.cn/large/0060lm7Tly1fn4txu7riyj305008cmwz.jpg)


为避免TLE，我们不是清空整个图的匹配信息重跑匈牙利，而是在原匹配的基础上以m为起点进行增广。


这就需要我们从Y部的点开始——这就是建双向边的原因。


不可以直接连Y部->X部，因为这会导致你无法沿匹配点输出路径。


综上。


/\*感觉匈牙利比Dinic简便很多啊，为什么没人用呢…\*/


```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
const int MAXN=10010,MAXM=200010,MAXP=5000;
bool s_num[MAXN],vis[MAXN];
int n,m,cnt,ans,head[MAXN],match[MAXN];
struct edge
{
    int nxt,to;
}e[MAXM];
void AddEdge(int u,int v)
{
    e[++cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
void AddEdges(int u,int v)
{
    AddEdge(u,v);
    AddEdge(v,u);
}
bool S_Num(int x)
{
    double t;
    return s_num[x] ? s_num[x] : (t=sqrt(x))==int(t);
}
bool DFS(int u)
{
    for(int i=head[u],v;i;i=e[i].nxt)
        if(!vis[v=e[i].to])
        {
            vis[v]=1;
            if(!match[v] || DFS(match[v]))
            {
                match[u]=v,match[v]=u;
                return 1;
            }
        }
    return 0;
}
void Print(int x)
{
    x+=MAXP;
    do
        printf("%d ",x=x-MAXP);
    while(vis[x]=1,x=match[x]);
    printf("\n");
}
int main(int argc,char *argv[])
{
    scanf("%d",&n);
    do
    {
        int t=++m+MAXP;
        for(int i=1;i<m;++i)
            if(S_Num(i+m))
                AddEdges(i,t);
        memset(vis,0,sizeof vis);
        ans+=DFS(t);
    }
    while(m-ans<=n);
    printf("%d\n",--m);
    memset(vis,0,sizeof vis);
    for(int i=1;i<=m;++i)
        if(!vis[i])
            Print(i);
    return 0;
}
```

> 谢谢阅读。


---

## 作者：Rhodoks (赞：12)

&emsp;&emsp;假设一个有n个点的一个图G，对每一对数(i,j)满足i+j=k^2 && i<j，从i向j连一条有向边。由于边始终从小指向大，因而图中无环，图G是个DAG（有向无环图）。而图G中每条路径均是放魔力球的一个合法方法。问题转换成DAG的最小路径覆盖问题。

&emsp;&emsp;比如这就是n==20时的图G。

![](https://cdn.luogu.com.cn/upload/pic/45422.png)

&emsp;&emsp;DAG的最小顶点覆盖问题则可以转化为二分图最大匹配问题。对每个点拆为出点和入点。超源连每个点的入点，出点连超汇。如果DAG里i,j相连则i的入点连j的出点，这条边如果在最大匹配中则代表了i和j所在两条路径的一次合并。最终最小路径数=顶点数-最大匹配（最大流）。

&emsp;&emsp;由于题中所求是给定柱子数情况下的最大球数，可以看出，球数总是随柱子数的增加而增加。一种做法是每次不断将新编号的球加入图中，在残余网络中跑最大流直到柱子数不够。亦可以通过二分答案的做法求解。~~其实可以直接贪心的。~~

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <iostream> 
#include <queue>
#define MAXM 1000100
#define MAXN 100100
using namespace std;

const int INF=2147483647;

int n,m,s,t;
int maxflow=0;
int b;
struct EDGE
{
	int from,to,weight,next;
}edge[MAXM<<1];

int nex[MAXN];
bool visit[MAXN];
int head[MAXN];
int deep[MAXN];
int cnt=0;
int p;

inline void add(int x,int y,int w)
{
	edge[cnt].from=x;
	edge[cnt].to=y;
	edge[cnt].weight=w;
	edge[cnt].next=head[x];
	head[x]=cnt++;
}

void input(int num)
{
	for (int i=0;i<=2*n+1;i++)
		head[i]=-1;
	cnt=0;
	n=num;
	for (int i=1;i<=n;i++)
	{
		add(0,i,1);
		add(i,0,0);
		add(i+n,2*n+1,1);
		add(2*n+1,i+n,0);
	}
	b=cnt+1;
	for (int i=2;i<2*n;i++)
	{
		for (int j=max(1,i*i-n);j<i*i-j;j++)
			if (i*i-j<=n)
			{
				add(j,i*i-j+n,1);
				add(i*i-j+n,j,0);
			}
	}
	s=0;
	t=2*n+1;
}

bool bfs()
{
	int cur;
	queue <int> q;
	for (int i=0;i<=2*n+1;i++)
		deep[i]=-1;
	deep[s]=0;
	q.push(s);
	while (!q.empty())
	{
		cur=q.front();
		q.pop();
		for (int i=head[cur];~i;i=edge[i].next)
			if (!~deep[edge[i].to] && edge[i].weight)
			{
				deep[edge[i].to]=deep[cur]+1;
				q.push(edge[i].to);
			}
	}
	if (~deep[t])
		return true;
	else
		return false;
}

int dfs(int cur,int limit)
{
	if (!limit || cur==t)
		return limit;
		
	int flow=0;
	int f;
	
	for (int i=head[cur];~i;i=edge[i].next)
	{
		if (deep[edge[i].to]==deep[cur]+1 && (f=dfs(edge[i].to,min(limit,edge[i].weight))))
		{
			flow+=f;
			limit-=f;
			edge[i].weight-=f;
			edge[i^1].weight+=f;
			if (!limit) break;
		}
	}
	if (!flow) deep[cur]=-1;
	return flow;
}

int dinic()
{
	while (bfs())
		maxflow+=dfs(s,INF);
	return maxflow;
}

bool check(int num)
{
	maxflow=0;
	input(num);
	dinic();
	return (num-maxflow<=p);
		
}

int main()
{
	cin>>p;
	int l=1;
	int r=2000;
	int mid;
	while (l<r)
	{

		mid=(l+r+1)/2;
		if (check(mid))
			l=mid;
		else
			r=mid-1;
	}
	check(mid=(l+r)/2);
	cout<<mid<<endl;
	for (int i=4*n;i<cnt;i+=2)
		if (edge[i].weight==0)
		{
			nex[edge[i].from]=edge[i].to-n;
			visit[edge[i].to-n]=true;
		}
	for (int i=1;i<=mid;i++)
		if (!visit[i])
		{
			for (int j=i;j;j=nex[j])
				cout<<j<<' ';
			cout<<endl;
		}
	return 0;
}

```

---

## 作者：学哥 (赞：7)

## 前言
具体的数学关系还是不会证，除了能打表发现球数规律外，内在原理也弄不清楚。

**然后我的网络流好像是在网络流中算快的，100ms多一点就跑了，1000ms内可以跑n=110；**
## 题面
[戳](https://www.luogu.org/problemnew/show/P2765)
## sol
很难想象是一道网络流。第一感是数学。

但是看到数据范围比较小，估计可以暴力dp。

又发现，状态转移比较难，状态调整比较多，dp估计难设，又看到数据范围又小于dp通常可做范围，所以用同样以规划和状态设计为关键字的，状态调整能力更强的，复杂度可能略高的网络流来做。

实际上，这种题考点不在网络流的精深图论，而在于网络流的规划，计算，调整能力，也就是通常说的的建模能力。只有最后输出方案需要一点图论知识。

多啰嗦一句的是，网络流，建状态同样也有优化，尽量少的边与点，边权尽量更加集中(少建INF边)会优化速度.

然后这道题首先，每个点只能选一次，这就可以用一个套路，抱一个点拆成一条边权为1的边，那么该边就只能经过一次了。

然后算贡献的话，就通过原始dp来考虑。比如，写dp就会直接转移到一个与自己加起来为平方和的点，那么网络流也是可以流向一条与自己加起来为平方和的点，然后流入成功就算一次贡献。网络流算贡献就是向汇点T流入1的流量。

显然dp还是可以自己创一组，就是流向一个柱子，注意到柱子也只能被流一次，所以就用上述的套路，跟流向一个点是一样的。
然后源点肯定是相当于去激活每一个点，那么每一个点都可以被S激活，所以搞一个S流向每一个点的流量是1的边。

**有人说跟最小点覆盖很像，其实就是用到了锁定一个点只能流一次这个套路。**

然后注意到，这个题说了只能选满1-m个球，根据dp的套路就是一个一个考虑，然后大的只能放向小的，所以就从小的往大枚举的放就可以了，如果某一个小的放不进当前的状态，那么就break。

网络流还是胜在自己的调整能力。单用点与边来规划处所有的情况，模拟水流，就会有着较强的调整能力，这就使得他只需用当前这张图来表示当前的状态，而不用像dp那样存储下每一种状态。dp的调整能力也不强，当一种情况的加入会大量改变已有状态时，dp就会显的很麻烦，而网络流则会自动的调整了当前的状态。目前的网络流只能通过构建边与点的关系来构造，所有的套路很少，也只限于这一个点与边的圈子，而dp却显得更加丰富与综合。
## code
```
#include<bits/stdc++.h>
using namespace std;
inline char gc(){
    static char buf[1<<7],*p1=buf,*p2=buf;
    return (p1==p2)&&(p2=(p1=buf)+fread(buf,1,1<<7,stdin),p1==p2)?EOF:*p1++;
}
template <class T>
inline void read(T&data){
    data=0;
    register char ch=0;
    while(ch<'0'||ch>'9')ch=gc();
    while(ch<='9'&&ch>='0'){
        data=(data<<3)+(data<<1)+(ch^48);
        ch=gc();
    }
    return;
}
template <class R>
inline void write(R data){
    if(data>9)write(data/10);
    putchar(data%10+'0');
}
const int _ = 200001,__  = 4000;
int n,to[_<<1],head[_],cur[_],S,T,nxt[_<<1],w[_<<1],cnt=-1,vnt,ball1[_],ball2[_],reball[_];
bool vis[_];
inline void add(register int a,register int b,register int c ){
    to[++cnt]=b,nxt[cnt]=head[a],head[a]=cnt,w[cnt]=c;
    to[++cnt]=a,nxt[cnt]=head[b],head[b]=cnt,w[cnt]=0;
}
int dfs(register int now,register int flow){
    if(now==T)return flow;
    vis[now]=1;
    for(register int i=head[now];~i;i=nxt[i]){
        if(w[i]==0)continue;
        if(vis[to[i]])continue;
        register int di=dfs(to[i],min(flow,w[i]));
        if(di>0){
            w[i]-=di,w[i^1]+=di;return di;
        }
    }
    return 0;
}
int main(){
    memset(head,-1,sizeof(head));
    read(n);//柱子的标号就是1到n了
    S=n+1,T=S+1;//这两个就这样定了吧注意球从什么开始标号
    vnt=T+1;
    for(register int i=1;i<=n;++i)
        add(i,T,1);
    register int ret=0,ans=0;
    for(register int i=1;1;++i){
        
        ball1[i]=++vnt,ball2[i]=++vnt;
        reball[vnt-1]=i;
        add(ball2[i],T,1);
        add(S,ball1[i],1);
        for(register int j=1;j<=n;++j)add(ball1[i],j,1);
        if(i!=1){
            for(register int j=1;j*j<(i<<1);++j){
                if(j*j<=i)continue;
                add(ball1[i],ball2[j*j-i],1);
            }
        }
        ret=dfs(S,1);
        memset(vis,0,sizeof(vis));		
        if(ret==0){
            ans=i-1;
            break;
        }
    }
    write(ans);puts("");
    for(register int i=1;i<=ans;++i){
        if(vis[i])continue;
        register int now = i;
        do{
            write(now);putchar(' ');vis[now]=1;
            for(register int j=head[ball2[now]];~j;j=nxt[j]){
                if(to[j]==T)continue;
                if(w[j^1]==0){
                    now=reball[to[j]];break;
                }
            }
        }while(!vis[now]);
        puts("");
    }
}

```

---

## 作者：望眼浮云 (赞：4)

建议：做这道题之前先做P2764最小路径覆盖

这是我写的一篇题解：https://www.luogu.org/blog/20020801wyc/zui-xiao-lu-jing-fu-gai

枚举答案A，在图中建立节点1..A。

如果对于i<j有i+j为一个完全平方数，连接一条有向边(i,j)。

该图是有向无环图，求最小路径覆盖。最小路径覆盖数就是需要的柱子数。

如果刚好满足最小路径覆盖数等于N，那么A是一个可行解，在所有可行解中找到最大的A，即为最优解。

具体方法可以顺序枚举A的值，当最小路径覆盖数刚好大于N时终止，A-1就是最优解。

也可以用二分答案，会快~~一点~~(很多)。

枚举A的时候不必重新建图，直接在原图上面加边就好了，因为加入一个新的点要么接在某一个柱子的后面，要么放在新的柱子上，不会影响原图


```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<cstring>
using namespace std;
const int inf=1e9;
int n,m,x,y,z,s,t,ans,d[10005],i,j,k;
struct node{
	int next,to,w;
}a[500000];
int cnt=1,head[10005],cur[10005],f[10000],vis[10000],mark[10000],to[10000];
queue <int> q;
void add(int x,int y,int dis)
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	a[cnt].w=dis;
	head[x]=cnt;
}
bool bfs(int s,int t)
{
	memset(d,0x7f,sizeof(d));
	while(!q.empty()) q.pop();
	for(int i=0;i<=t;i++) cur[i]=head[i];
	d[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]>inf&&a[i].w) 
			{
				d[v]=d[u]+1;
				q.push(v);
			}
		}
	}
	if(d[t]<inf) return true;
	else return false;
}
int dfs(int now,int t,int limit)
{
	if(!limit||now==t) return limit;
	int flow=0,f;
	for(int i=cur[now];i;i=a[i].next)
	{
		cur[now]=i;
		int v=a[i].to;
		if(d[v]==d[now]+1&&(f=dfs(v,t,min(limit,a[i].w))))
		{
			flow+=f;
			limit-=f;
			a[i].w-=f;
			a[i^1].w+=f;
			if(!limit) break;
		}
	}
	return flow;
}
int main()
{
	scanf("%d",&n);
	t=10000;
	while(1)
	{
        ans++;s++;  //s为新加入的点
        for(int i=1;i<s;i++)
           if(sqrt(i+s)==(int)(sqrt(i+s)))
              add(i,s+5000,1),add(s+5000,i,0); //i+s为完全平方数，连一条边。 s+5000表示s的入点，具体看最小路径覆盖
        add(0,s,1); //超级源点向s连边
        add(s,0,0); 
        add(s+5000,t,1); //s向超级汇点连边
        add(t,s+5000,0);
        while(bfs(0,t)) ans-=dfs(0,t,inf); 
        if(ans>n)break; 
    }
	printf("%d\n",s-1); 
	for(int i=1;i<s;i++) 
    {
        int k=head[i];
        while(k)
        {
            if(!a[k].w){ to[i]=a[k].to-5000;break;} 
            k=a[k].next;
        }
    }
    for(int i=1;i<s;i++) //输出路径
    {
        if(mark[i])continue;int t=i;
        while(t!=-5000)
        {
            mark[t]=1;
            printf("%d ",t);
            t=to[t];
        }
        printf("\n");
    }
	return 0;
}
```

---

## 作者：Adove (赞：3)

这题可以用费用流做，而且输出方案时比最大流方便，dfs一遍即可。

球数可以和最大流一样求~~（我偷懒用了通项）~~

![](https://cdn.luogu.com.cn/upload/pic/15944.png)

以上是建模，源点同副源连一条权n费0的边，副源同每个左点连一条权1费1的边，每个点同与其相加得完全平方数的右点连一条权1费1的边，每个右点向左点连权1费0的边，向汇点连权1费0的边，跑最大费用流即可。

上代码↓

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,s1,s,t,maxn,np=1,mfl,mct;
int h[3505],ln[3505],q[59805];
bool vis[3505];
struct rpg{
	int li,nx,ln,ct;
}a[59805];

void add(int ls,int nx,int ln,int ct){
	a[++np]=(rpg){h[ls],nx,ln,ct};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0,-ct};
	h[nx]=np;
}

bool spfa(){
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=t;++i) ln[i]=INF;
	int hd=1,tl=1;
	q[hd]=t;
	ln[t]=0;
	vis[t]=1;
	while(hd<=tl){
		int nw=q[hd++];
		vis[nw]=0;
		for(int i=h[nw];i;i=a[i].li){
			if(a[i^1].ln&&ln[a[i].nx]>ln[nw]-a[i].ct){
				ln[a[i].nx]=ln[nw]-a[i].ct;
				if(!vis[a[i].nx]){
					vis[a[i].nx]=1;
					q[++tl]=a[i].nx;
				}
			}
		}
	}return ln[s]<INF;
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	vis[u]=1;
	int sum=0;
	for(int i=h[u];i;i=a[i].li){
		if(a[i].ln&&!vis[a[i].nx]&&ln[a[i].nx]==ln[u]-a[i].ct){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(){
	while(spfa()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof(vis));
			int d=dfs(s,INF);
			mfl+=d;
			mct+=d*ln[s];
		}
	}
}

void dfs2(int x){
	vis[x]=1;
	printf("%d ",x);
	for(int i=h[x];i;i=a[i].li){
		if(!a[i].ln&&!vis[a[i].nx-maxn]&&a[i].nx-maxn<=maxn){
			dfs2(a[i].nx-maxn);
		}
	}
}

int main(){
	scanf("%d",&n);
	maxn=((n+1)*(n+1)>>1)-1;
	printf("%d\n",maxn);
	s1=(maxn<<1)+1;
	t=(maxn<<1)+2;
	add(s,s1,n,0);
	for(int i=1;i<=maxn;++i){
		add(s1,i,1,-1);
		add(i+maxn,i,1,0);
	}
	for(int i=1;i<maxn;++i){
		for(int j=maxn;j*j>i<<1;--j){
			if(j*j-i>maxn) continue;
			add(i,j*j-i+maxn,1,-1);
		}
	}for(int i=1;i<=maxn;++i){
		add(i+maxn,t,1,0);
	}dnc();
	for(int i=1;i<=maxn;++i){
		if(!vis[i]){
			dfs2(i);
			puts("");
		}
	}return 0;
}
```

---

## 作者：岸芷汀兰 (赞：2)

#### 作者：岸芷汀兰

# 一、题目：

[洛谷原题](https://www.luogu.com.cn/problem/P2765)

# 二、思路：

先推销一波[博客](https://www.cnblogs.com/little-aztl/p/12165755.html)。

既然是网络流24题中的一道，那么肯定要用到网络流模型。

其实大多数OI题都是模型的运用和转化，此题也不例外。

如果没有做过[这道题](https://www.luogu.com.cn/problem/P2764)的同学可以先做一下，再来理解本题可能会容易一些。

我们会发现如果我们这样建图：

$\forall u < v$如果$u + v$是完全平方数，那么我们就从u向v连一条**有向边**，那么最终的图G一定是个DAG。

每一根柱子，记最下面的数为$x$,最上面的数为$y$，那么这根柱子就对应着图G中的一条从$x$到$y$的路径。

现在把原题改一下，改为给你$m$，让你求：要想把$1\sim m$的数字摆到柱子上，最小需要几个柱子。那是不是就对应着图G的最小路径覆盖问题？

那么现在再来考虑本题，本题是给你$n$个柱子，让你求最大的$m$，那么我们可以依次增加$m$，检查当前的图G的最小路径覆盖是否小于等于$n$，如果大于了$n$，就立即跳出。

至于怎样输出答案，与“最小路径覆盖”那道题的输出方法一模一样，在此不再赘述。

# 三、代码：

```cpp
//好看的代码是理解OI题的基础
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

using namespace std;

#define LL long long
#define mem(s, v) memset(s, v, sizeof s)

inline LL read(void) {
    LL x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return f * x;
}

const int inf = 1e9 + 5;
const int maxn = 1e5 + 5;

int to[maxn], nxt[maxn], head[30005], tot = 1;
int cur[maxn];

int n, s, t;
int w[maxn];

inline void add(int x, int y, int z) {
    to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; w[tot] = z;
    to[++tot] = x; nxt[tot] = head[y]; head[y] = tot;
}

inline int id(int x, int y) { return x + y * 10000; }//拆点

inline void AddEdge(int x) {
    for (register int i = 1; i < x; ++i) {
        int tmp = i + x;
        if ((int)sqrt(tmp) * (int)sqrt(tmp) == tmp) {
            add(id(i, 0), id(x, 1), 1);
        }
    }
    add(s, id(x, 0), 1); add(id(x, 1), t, 1);
}//每增加一次m，更新一下图G

int q[maxn], l, r, vis[maxn], h[maxn];

inline bool bfs(void) {
    for (register int i = 1; i <= t; ++i) h[i] = inf, cur[i] = head[i], vis[i] = 0;
    h[s] = 0; l = r = 1; q[r++] = s;
    while (r - l) {
        int u = q[l++]; vis[u] = 0;
        for (register int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (w[i] && h[v] > h[u] + 1) {
                h[v] = h[u] + 1;
                if (!vis[v]) q[r++] = v, vis[v] = 1;
            }
        }
    }
    return h[t] < inf;
}

int dfs(int u, int flow) {
    if (u == t) { return flow; }
    int tmp, used = 0;
    for (register int i = cur[u]; i; i = nxt[i]) {
        int v = to[i]; cur[u] = i;
        if (w[i] && h[v] == h[u] + 1) {
            if (tmp = dfs(v, min(flow - used, w[i]))) {
                w[i] -= tmp; w[i ^ 1] += tmp;
                used += tmp;
                if (used == flow) break;
            }
        }
    }
    return used;
}

int maxflow;

inline void dinic(void) {
    while (bfs()) {
        maxflow += dfs(s, inf);
    }
}

int suc[maxn];

inline void print(int x) {//输出“路径”
    while (x) {
        printf("%d ", x);
        vis[x] = 1; 
        x = suc[x];
    }
}

int main() {
    n = read(); s = id(10000, 1) + 1, t = s + 1;
    int now = 0, cnt = 0;
    while (now <= n) {
        ++cnt; AddEdge(cnt);
        dinic();
        now = max(now, cnt - maxflow);
    }
    printf("%d\n", cnt - 1);
    for (register int i = 1; i <= cnt - 1; ++i) {
        for (register int j = head[i]; j; j = nxt[j]) {
            int v = to[j];
            if (v != s && v != t) {
                if (w[j ^ 1]) {
                    suc[i] = v - 10000;
                    break;
                }
            }
        }
    }
    mem(vis, 0);
    for (register int i = 1; i <= cnt - 1; ++i) {
        if (!vis[i]) print(i), puts("");
    }
    return 0;
}

```

---

## 作者：wasa855 (赞：2)

思路：考虑拆点，把一个球拆成两个点，设为$i_x,i_y$，其中$i_x$连超源，$i_y$连超汇。   
``` cpp
add(0,ans*2,1);
add(ans*2+1,t,1);
```
建图：假设有两个小球$i,j(i<j)$，满足$a_i+a_j$是平方数，即$j$可以放在$i$后面，那么将$i_x$和$j_y$相连，流量限制为$1$。   
``` cpp
for(int i=1;i<ans;i++)
{
	if(sqrt(i+ans)==(int)sqrt(i+ans))
	{
		add(i*2,ans*2+1,1);
	}
}
```
那么假如一个新加入的球编号为$k$，与前面的点连边之后，再从超源向超汇跑一遍最大流，如果有流量为$1$的增广路，那么没有问题，其中流向$k_y$的点就是$k$的前面那个点；如果没有，那么就要新开一列，并记录下这个位置，输出的时候有用。 
``` cpp
int k=dinic();
if(k==0)
{
	sum++;
	beg[sum]=ans;
}
```
最后根据每个点的来源输出答案
``` cpp
for(int i=1;i<=n;i++)
{
	int x=beg[i];
	while(x!=t/2&&x!=0)
	{
		printf("%d ",x);
		x=from[x];
	}
	cout<<"\n";
}
```
   
然后问题就解决了。  
#### 在代码之前，祝大家NOIP2019 RP++
代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3fffffff
int n;
int ans;
int s=0,t=5000;
int beg[105];
struct Edge
{
	int to;
	int nxt;
	int dis;
};
Edge edge[200005];
int ss=-1;
int fir[10005];
int from[10005];
void add(int u,int v,int w)
{
//	printf("%d %d %d\n",u,v,w);
	ss++;
	edge[ss].to=v;
	edge[ss].dis=w;
	edge[ss].nxt=fir[u];
	fir[u]=ss;
	ss++;
	edge[ss].to=u;
	edge[ss].dis=0;
	edge[ss].nxt=fir[v];
	fir[v]=ss;
}
int dep[10005];
bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		for(int i=fir[t];i!=-1;i=edge[i].nxt)
		{
			int to=edge[i].to;
			if(edge[i].dis>0&&dep[to]==0)
			{
				dep[to]=dep[t]+1;
				q.push(to);
			}
		}
	}
	if(dep[t]==0)
	{
		return false;
	}
	return true;
}
int dfs(int now,int flow)
{
	if(now==t)
	{
		return flow;
	}
	for(int i=fir[now];i!=-1;i=edge[i].nxt)
	{
		int to=edge[i].to;
		if(dep[now]+1==dep[to]&&edge[i].dis>0)
		{
			int d=dfs(to,min(flow,edge[i].dis));
			if(d>0)
			{
				edge[i].dis-=d;
				edge[i^1].dis+=d;
				from[now/2]=to/2;
				return d;
			}
		}
	}
	return 0;
}
int dinic()
{
	int ans=0;
	while(bfs()==true)
	{
		int tmp=dfs(s,INF);
		if(tmp>0)
		{
			ans+=tmp;
		}
		else
		{
			break;
		}
	}
	return ans;
}
int main()
{
	memset(fir,-1,sizeof(fir));
	cin>>n;
	int sum=0;
	while(sum<=n)//如果sum>n，那么则不能再放小球了
	{
		ans++;
		add(0,ans*2,1);
		for(int i=1;i<ans;i++)
		{
			if(sqrt(i+ans)==(int)sqrt(i+ans))
			{
				add(i*2,ans*2+1,1);
			}
		}
		add(ans*2+1,t,1);
		int k=dinic();
		if(k==0)
		{
			sum++;
			beg[sum]=ans;
		}
	}
	ans--;
	cout<<ans<<endl;
	for(int i=1;i<=n;i++)//输出结果
	{
		int x=beg[i];
		while(x!=t/2&&x!=0)
		{
			printf("%d ",x);
			x=from[x];
		}
		cout<<"\n";
	}
	return 0;
}

```

---

## 作者：7KByte (赞：2)

补一篇二分图题解

----
根据贪心可以证明：$ans$=($n$*($n$+2)+($n$%2))/2-1  
楼下有大佬已经证明了贪心这里不再赘述（反正重点不再贪心）  


知道了能放的球的个数，我们还需要求出方案  
因为是按照1,2,3,4……的顺序逐一码放，我们很容易想到建一张有向图，共$ans$个节点，如果$a<b(a \in \left[1,ans\right]b \in \left[1,ans\right])$，且$(a+b)$是完全平方数，那么我们从点$a$向点$b$连一条有向边。因为在一条路径上的点可以放到同一根柱子上，所以这道题转化成求$DAG$上的**最小路径覆盖**  


既然是最小路径覆盖，必然少不了二分图，将每个节点$i$拆成$i$与$i'$,原有边$i\longrightarrow j$，我们则将二分图中的$i$与$j'$连边，然后求二分图最大匹配，最小路径覆盖则为($DAG$上节点数$-$最大匹配)  


对于答案的输出有些小技巧见我的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,next;
}e[1000000];
int h[10000],n,ans,pop=0,f[100000];
int match[10000],vis[10000],st[10000];
void add(int x,int y){
	pop++;
	e[pop].to=y;e[pop].next=h[x];
	h[x]=pop;
}
bool find(int p){
	for(int i=h[p];i;i=e[i].next){
		if(vis[e[i].to])continue;
		vis[e[i].to]=1;
		if(!match[e[i].to]||find(match[e[i].to])){
			match[e[i].to]=p;
			st[p]=e[i].to;
			return true;
		}
	}
	return false;
}
int main()
{
	scanf("%d",&n);
	ans=(n*(n+2)+(n%2))/2-1;
	memset(f,0,sizeof(f));
	for(int i=1;i<=300;i++)
	  f[i*i]=1;
	for(int i=1;i<=ans;i++)
	  for(int j=1;j<i;j++)
	    if(f[i+j])
	      add(j,i);
	int sum=0; 
	memset(st,0,sizeof(st));
	for(int i=1;i<=ans;i++){
		memset(vis,0,sizeof(vis));
		if(find(i))sum++;
	}
	printf("%d\n",ans);
	int v[60000],top=0;
	memset(v,0,sizeof(v));
	for(int i=1;i<=ans;i++){
		if(!v[i]){
		    printf("%d ",i);
		    int k=st[i];v[i]=1;
		    while(k){
			    v[k]=1;
		    	printf("%d ",k);
		    	k=st[k];
			}
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：Horrigue_袁四爷 (赞：2)

魔术球问题 网络流的经典例题

然而本蒟蒻并不会写网络流做法

所以今天我向大家介绍一种较为朴素的做法

### 贪心

本题的数据给的55 所以我们尽可以写O3 O4算法

于是我便有了贪心的念头

查看本题题意不难发现 为了使柱子尽可能填满且尽可能多填数

可以把本题分为两种操作

(1)如果当前柱子有可以放置使前后成为平方数的位置 则放置

(2)如果当前没有可放置位置 开一个新柱子 将该球放到新柱子的第一项

这样我们就可以贪心辣~ 但是我们有几个地方需要注意

a要注意边界是柱子开到n个 如果不判边界会使程序进入死循环

b由于球号是自增的 所以在输出最大球号是要输出最后判断停止的球号-1

c在循环判断放球的时候可以找到位置立刻break 这样可以达到一个剪枝的效果

好辣 看到这里有没有觉得其实这个题很简单呢

我建议你们自己写写 如果还写不出来的话再看下面的完整代码

下面是实现

```
#include<cstdio>
#include<cctype>
#include<cmath>
#define rg register  
using namespace std;
const int N =56;
int f[N][10001],ball,book[N];//book来存每一个柱子有几个数
int n,cnt=1,spot;
inline int read(){
	rg int f=0,x=0;
	rg char ch=getchar();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) 	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
inline bool jud(rg int x){//判断是否为平方数
    rg int i=(int)sqrt(x);
    if(i*i==x)	return true;
    else	return false;
}
signed main(){
    n=read();
    while(cnt<=n){
        ball++;
        spot=0;
        for(rg int i=1; i<=cnt; ++i){
            if(jud(ball+f[i][book[i]])){//如果能找到
                book[i]++;
                f[i][book[i]]=ball;
                break;
            }
            spot++;//每找一个循环都标记一下
        }
        if(spot==cnt){//走完所有循环都没找到
            cnt++;
            f[cnt][1]=ball;
            book[cnt]=1;
        }
    }
    printf("%d\n",ball-1);//一定要-1！！
    for(rg int i=1; i<cnt; ++i){//i<cnt是因为现在的cnt是多出来的一个ball
        for(rg int j=1; j<=book[i]; ++j)
            printf("%d ",f[i][j]);
        printf("\n");
    }
    return 0;
}
```
后话：

当然网络流还有其它的题可以拿诸如此类的贪心做

既然分在了网络流大家最好还是要尝试一下网络流的做法

不要浪费每一道好题

---

## 作者：LoveHX (赞：2)

//其实这道题可能很多人如果不是看到有网络流这个标签，可能不会想到网络流；一般人会

//想到贪心，但是不知道为什么，我不会贪心，看了一下，发现这是网络流24题之一，便选择了网络流；

//其实这道题的关键是建图，不会建图就完了，可以从1枚举，然后一一判断，如果两个球的和是完全平方数，则把它们连在一起，定义ans为柱子数；如果柱子数

//大于n，则break；ans每次枚举是加1，如果能找到一条最大流，则ans-1；因为相当于把两个柱子合并成一个柱子；




        
```cpp
//具体见代码；.
//！！！！枚举答案转化为判定性问题，然后最小路径覆盖，可以转化成二分图最大匹配，从而用最大流解决。 
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#define N 10010
using namespace std;
struct node
{
     int u,next,to,s;
}Edge[N*20];
const int m=5000;//拆点加的数； 
const int T=10000;//定义汇点； 
int n,ans,s,tot=2;
int head[N];
int h[N],que[N];
bool used[N];
int to[N];
int vis[N];
void add(int x,int y,int z)//链表 ，很基础了； 
{
    Edge[tot].u=x;
    Edge[tot].next=head[x];
    Edge[tot].to=y;
    Edge[tot].s=z;
    head[x]=tot;
    tot++;
}
void ins(int x,int y)
{
    add(x,y,1),add(y,x,0);
}
bool bfs()//模版 ，其实可以开一个vis【】数组，只是不知道为什么过不了；qwq； 
{
    queue<int>Q;
    memset(h,-1,sizeof(h));
    Q.push(0);
    h[0]=1;
    while(!Q.empty())
    {
        int now=Q.front();
        Q.pop();
        for(int i=head[now];i;i=Edge[i].next)
        {
            if(h[Edge[i].to]==-1&&Edge[i].s>0)
            {
                h[Edge[i].to]=h[now]+1;
                Q.push(Edge[i].to);
            }
        }
    }
    if(h[T]==-1) return 0;
   return 1;
}
int dfs(int u,int f)//模版 
{
    if(u==T||f==0)return f;
    int used=0;
    for(int i=head[u];i;i=Edge[i].next)
    {
        if(Edge[i].s>0&&h[Edge[i].to]==h[u]+1)
       {
           int w=f-used;
        w=dfs(Edge[i].to,min(w,Edge[i].s));
        Edge[i].s-=w;
        Edge[i^1].s+=w;
        used+=w;
        if(used==f)return f;
       } 
    }
    return used;
}
void getans()//输出，也挺关键的； 
{
    for(int i=1;i<s;i++)
    {
        for(int j=head[i];j;j=Edge[j].next)
        {
            if(Edge[j].s)continue//残量为不为0，说明没走，跳过;
            to[i]=Edge[j].to-m;//因为原来加m，所以-； 
            break;
        }
    }
    for(int i=1;i<s;i++)//自行体会 
    {
        if(used[i])continue;
        int t=i;
        while(t!=-m)
        {
            printf("%d ",t);
            used[t]=true;
            t=to[t];
        }
        cout<<endl;
    }
}
void dinic()
{
    while(bfs())
        ans-=dfs(0,1E9);//一定是减，因为合并，这里可以优化的，有兴趣可以参看我的第一篇网络流题解； 
}
int main()
{
    cin>>n;
   while(1)//这里面是关键，建图； 
    {
        ans++,s++;
        for(int i=1;i<s;i++)
            if(sqrt(i+s)==(int)sqrt(i+s))//判断是否为完全平方数； 
                ins(i,s+m);
        ins(0,s),ins(s+m,T);//拆点连边 
        dinic();
        if(ans>n)break;//表示已经大于n根柱子了； 
    }
        printf("%d\n",s-1);
        getans();
    return 0;
}
```

---

## 作者：zh_dou (赞：2)

## 魔术球问题
通过观察题面，我们发现柱子好像并没有什么用，于是考虑枚举球

每次向残量网络中加入代表球的点和边，如果有增量，说明这个球利用了现有的柱子，否则就要多加一个柱子

由于并不预先知道球的数量，也就是答案，所以说 $t$ 要开大一点

然后在我们透彻网络流时，$Dinic$算法中的 $dfs$ 是处理的每一次 $bfs$ 所发现的增量

所以我们不断向图中加边、加点，直到柱子不够用

此时 $--num$ 便是答案

在加边时，

因为一个球只能放一次 , $s\xrightarrow{1}i\ ,\ i'\xrightarrow{1}t$

对于 $j<i$ 且 $i+j$ 为完全平方数，
连边$i\xrightarrow{1}j'$

若增量为0，则新开一个柱子

$\mathcal{Code}:$
```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
#define N 50030
#define int long long
#define debug cout<<__LINE__<<" "<<__FUNCTION__<<"\n"
inline int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*y;
}
int n,m,s,t,dep[N];
int head[N],tot=1,front,used[N];
int ans;
int table[N],vis[N],after[N];
struct Node{
    int nxt,to,dis;
}edge[N<<2];
inline void add(int x,int y,int z){
    edge[++tot].nxt=head[x];
    edge[tot].to=y;
    edge[tot].dis=z;
    head[x]=tot;
}
queue<int> q;
inline int bfs(){
	register int i;
	for(i=0;i<=N-10;i++) dep[i]=-1, used[i]=head[i];
	dep[s]=0;
	q.push(s);
	while(!q.empty()){
		front=q.front();q.pop();
//		cout<<front<<" ";debug;
		for(i=head[front];i;i=edge[i].nxt){
			if(edge[i].dis&&dep[edge[i].to]==-1){
				dep[edge[i].to]=dep[front]+1;q.push(edge[i].to);
			}
		}
	}
//	debug;
	return dep[t]!=-1;
}
int dfs(int now,int limit){
	if(!limit||now==t) return limit;
	int flow=0;
	for(int &i=used[now],pro;i;i=edge[i].nxt){
		if(dep[edge[i].to]==dep[now]+1&&edge[i].dis){
			pro=dfs(edge[i].to,min(limit,edge[i].dis));
			if(!pro) continue;
			edge[i].dis-=pro;
			edge[i^1].dis+=pro;
			flow+=pro;
			limit-=pro;
//			cout<<now<<" "<<edge[i].to<<"\n";
			if(edge[i].to!=t) after[now>>1]=edge[i].to>>1;
			if(!limit) return flow;
		}
	}
//	cout<<flow<<" ";debug;
//	system("pause");
	return flow;
}
inline void Dinic(){
	while(bfs()){ans+=(dfs(s,10000000001LL));}
}
signed main(){
//	freopen("a.in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	s=0;t=50001;
	int now=0,num=0;
	while(now<=n){
		++num;
		add(s,num<<1,1);add(num<<1,s,0);
		add(num<<1|1,t,1);add(t,num<<1|1,0);
        for(int i=sqrt(num)+1;i*i<(num<<1);i++) add((i*i-num)<<1,num<<1|1,1),add(num<<1|1,(i*i-num)<<1,0);
        ans=0;Dinic();
        if(ans==0) table[++now]=num;
//        cout<<num<<" "<<now<<"\n";
	}
	cout<<--num<<"\n";
	for(int i=1,k;i<=n;i++){
		if(!vis[table[i]]){
			cout<<(k=table[i]);vis[k]=1;
			while(after[k]>0&&after[k]!=t>>1){
				cout<<" "<<(k=after[k]);
				vis[k]=1;
			}
			cout<<"\n";
		}
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：11D_Beyonder (赞：1)


> 传送门 [$\looparrowright$](https://www.luogu.com.cn/problem/P2765)  

## 题目描述  
&emsp;&emsp;假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1,2,3\cdots$ 的球。
&emsp;&emsp;每次只能在某根柱子的最上面放球。同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。  
&emsp;&emsp;试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。例如，在 $4$ 根柱子上最多可放 $11$ 个球。  
&emsp;&emsp;对于给定的 $n$，计算在 $n$ 根柱子上最多能放多少个球。  
## 输入格式  
只有一行一个整数 $n$，代表柱子数。  
## 输出格式  
&emsp;&emsp;本题存在 **Special Judge**。   
&emsp;&emsp;请将 $n$ 根柱子上最多能放的球数以及相应的放置方案输出。  
&emsp;&emsp;输出的第一行是球数。  
&emsp;&emsp;接下来的 $n$ 行，每行若干个整数，代表一根柱子上的球的编号，数字间用单个空格隔开。  
## 输入输出样例  
### 输入 \#1  
> 4  

### 输出 \#1  
> 11  
> 1 8  
> 2 7 9  
> 3 6 10  
> 4 5 11  

## 说明/提示  
&emsp;&emsp;对于 $100\%$ 的数据，保证 $1 \leqslant n \leqslant 55$。  
## 分析  
&emsp;&emsp;设当前有 $x$ 个球，将 $x$ 个球全部按要求放入柱子，需要的最少柱子数量为 $f(x)$，$f(x)=n$ 的最大解即为最多能放入的球的个数。显然，$f(x)$ 关于 $x$ 单调增加，不妨二分获得 $f(x)=n$ 的最大解。设二分的左边界为 $l$，边右界为 $r$。  
&emsp;&emsp;接下来讨论，当有 $x$ 个球，编号为 $1\sim x$，最少需要多少根柱子使得 $x$ 个球全部按要求摆放在柱子上。  
&emsp;&emsp;此问题虽然不是赤裸裸的图论问题，但是根据数字之间的关联和限制，就能在不同数字之间建边，转化为图论问题。  
&emsp;&emsp;建边要遵循问题的要求和限制，若 $i+j$ 为完全平方数，且 $i<j$，那么就从 $i$ 向 $j$ 连边。这就遵循了将数字从小到大放入柱子且相邻数字和为完全平方数的原则。  
&emsp;&emsp;当 $m=20$ 时，建立的 $\text{DAG}$ 如图。可以设想，最少需要的柱子数量为 $\text{DAG}$ 最小路径覆盖。（此图借用洛谷用户[Rhodoks](https://www.luogu.com.cn/user/56267)的[博文](https://www.luogu.com.cn/blog/Rhodoks/solution-p2765)）
 
![](https://ftp.bmp.ovh/imgs/2020/07/85ee3c26e89b1d3d.png)   

&emsp;&emsp;二分得到一个解 $x$，对 $1\sim x$ 的所有整数建立上述的 $\text{DAG}$，并转化为拆点二分图，跑一次匈牙利算法即可得到最小路径覆盖。若最小路径覆盖仍然未超过 $n$，则左边界可继续增大，否则右边界减小。    
&emsp;&emsp;获得最多能放入的球的个数的最大值 $m$ 后，再跑一次匈牙利算法，用 $\text{match}$ 数组输出匹配信息。  
## 代码  
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P2764
Date: 7/26/2020 
Description: Hungarian Alogrithm
*******************************************************************/
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
const int N=10003;
const int base=5000;
const int M=15003;
struct E
{
	int to;
	int Next=-1;
}edge[M<<2];
int head[N<<2],tot;
int n,m;
bool vis[N<<2];
int match[N<<2];
inline void init();
inline void add_edge(int,int);
inline bool perfect_square(int);
bool dfs(int);
bool check(int);
int Hungarian(int);
void Hungarian();
int main()
{
	cin>>n;
	int i,j;
	int l=1,r=base;
	while(r-l>=3)//二分
	{
		int mid=l+r>>1;
		if(check(mid)) l=mid;
		else r=mid;
	}
	while(l<=r)
	{
		if(check(l)) 
		{
			m=l;
			l++;
		}
		else break;
	}
	cout<<m<<endl;
	init();
	//最后一次匈牙利输出匹配信息
	for(i=1;i<=m;i++)
	{
		for(j=i+1;j<=m;j++)
		{
			if(perfect_square(i+j))
			{
				add_edge(i,j+base);
			}
		}
	}
	Hungarian();
	return 0;
}
inline void init()
{
	memset(head,-1,sizeof(head));
	tot=0;
	memset(match,-1,sizeof(match));
}
inline void add_edge(int u,int v)
{
	tot++;
	edge[tot].to=v;
	edge[tot].Next=head[u];
	head[u]=tot;
}
inline bool perfect_square(int x) {return pow((int)sqrt(x),2)==x;}
bool dfs(int x)
{
	for(register int i=head[x];~i;i=edge[i].Next)
	{
		int y=edge[i].to;
		if(!vis[y])
		{
			vis[y]=1;
			if(match[y]==-1||dfs(match[y]))
			{
				match[y]=x;
				match[x]=y;
				return 1;
			}
		}
	}
	return 0;
}
bool check(int x)//球为x时的需要的最少柱子
{
	int i,j;
	init();
	//建立拆点二分图
	for(i=1;i<=x;i++)
	{
		for(j=i+1;j<=x;j++)
		{
			if(perfect_square(i+j))
			{
				add_edge(i,j+base);
			}
		}
	}
	return x-Hungarian(x)<=n;
}
int Hungarian(int x)
{
	int ans=0;
	for(register int i=1;i<=x;i++) 
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	return ans;
}
void Hungarian()
{
	int temp=Hungarian(m);
	memset(vis,0,sizeof(vis));
	for(register int i=1;i<=m;i++)
	{
		if(!vis[i])
		{
			int x=base+i;
			do
			{
				x-=base;
				cout<<x<<' ';
				vis[x]=1;
				x=match[x];
			}while(~x);
			cout<<endl;
		}
	}
}
```
## 后记  
&emsp;&emsp;检验完全平方数，要写成 ```return pow((int)sqrt(x),2)==x```，注意函数开平方函数的返回值。  
![](https://i.niupic.com/images/2020/07/27/8su9.png)  

---

## 作者：素质玩家孙1超 (赞：1)

提供一个匈牙利算法AC本题目~~速度还不慢~~

#### 题目解法

从一开始枚举答案$N$，建一个$N$个点的图，如果$i<j$,并且$i+j=K^2$ 那么给$i$,$j$连边

这个图的最小路径覆盖就是该答案所需要的柱子数

(如果不知道什么是最小路径覆盖请转[最小路径覆盖](https://www.luogu.com.cn/problem/P2764)该题目也可以用匈牙利AC)

当柱子数大于题目中给的就退出，输出答案

## 匈牙利代码实现（重点）

一开始我以为只要每次重新建图重新跑一边匈牙利就好了，结果T飞

优化：我们考虑每次图的差别，每此n自增一次，那么只要$O(n)$加入一些边而不用重新建图

然而每次都跑一边匈牙利时间也是不够，我们考虑不将上次匈牙利的结果（储存匹配的数组）清零

并且在跑匈牙利时，如果x已经有匹配了，那么就不用再去找路径了，直接更新结果

---
这样优化后就可以轻易AC了，部分注释在代码里

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=1e6+5;
int First[Maxn],to[Maxn],Next[Maxn],cnt,K,n,m;
int match_x[Maxn],match_y[Maxn];bool vis[Maxn];
map<int,bool>f;//记录平方数 
inline void add(int z,int y)
{
	Next[++cnt]=First[z];
	First[z]=cnt;
	to[cnt]=y;
}
inline int R()
{
    int res=0,sign=1;char ch;
    while((ch=getchar())>'9'||ch<'0') if(ch=='-') sign=-1;
    res+=ch-'0';
    while((ch=getchar())<='9'&&ch>='0') res=res*10+ch-'0'; 
    return res*sign;
}
bool path(int x)
{
	for(int k=First[x];k;k=Next[k])
	{
		if(vis[to[k]]||to[k]>n)continue;//要判断边界，因为最后一次n--了 
		vis[to[k]]=1;
		if(!match_y[to[k]]||path(match_y[to[k]]))//对方没匹配或者可以增广
		{
			match_y[to[k]]=x;
			match_x[x]=to[k];
			return 1;
		}
	}
	return 0;
}
inline void pre()
{ 
	for(int i=1;i<n;i++)//加边 
	if(f[i+n]) add(i,n);
}
inline int XYL()//匈牙利算法 
{
	int res=0;
	for(int i=1;i<=n;i++)
	{
		res+=(match_x[i]||path(i));//如果i在上次已经有匹配了，就直接更新结果 
		memset(vis,0,sizeof(bool)*(n+5));
	}
	return n-res;
}
int main()
{
	m=R();n=0;
	for(int i=1;i<=2000;i++) f[i*i]=1;//处理平方数 
	while(++n)//枚举答案 
	{
		pre();
		if(XYL()==m+1)//如果柱子数多了 
		{
			--n;
			printf("%d\n",n);
			break;
		}
	}
	memset(match_y,0,sizeof match_y);
	memset(match_x,0,sizeof match_x);
	XYL();
	int x;//下面根据我们存下来的匹配输出答案 
	for(int i=1;i<=n;i++)
	if(!vis[i])
	{
		x=i;
		while(x&&!vis[x])
		{
			vis[x]=1;
			printf("%d ",x);
			x=match_x[x];
		}
		puts("");
	}
}
```


---

## 作者：VanillaYuzume (赞：1)

## [5].魔术球问题 

题目:[自己康](https://www.luogu.org/problem/P2765)

**在做这一题之前 建议先做[4].最小路径覆盖问题_(:зゝ∠)_**

解法:
这一题很坑!!!            
首先 要知道题目中的三个性质(~~坑点~~           
1.所有球的序号是连续的       
2.每个柱子上可以放**一个**任意的球 或 多个相邻编号之和为完全平方数  
3.柱子的意义:作为连接一段小球的绳子

而这个模型 就可以转变为最小路径覆盖问题
上述问题是给定**点**和**边**来求其的最小路径覆盖
而本题 则是在已知**图的最小路径覆盖**的情况下来推出该图的节点数

对于本题 我们可以尝试通过枚举来建边         
因为我们不知道 这道题有多少个结点 所以我们先建5000个点   
然后 我们要找出每两个点间的对应关系 所以我们应把这5000个点拆成两部分(详细说明见上篇[4]题解)  
然后 分别将实部与源点相连 虚部与汇点相连即可           
在每次添加点后 我们通过一次循环 如果$(i+num)$是整数的平方       
就在$i$和$(num+k)$间建立一条边 ... 以此类推          
最后我们可以根据$num=ans+n$来得到$num$的结果(最后别忘了减1)     
输出答案时 我们遍历所有的实点 如果它没有走过 就从它开始走即可  
如果我们发现 当前点的下一个点(虚点)对应的实点没有走过   
那么我们就从从这个实点开始继续走 直到所有的点都被遍历完

(注:下面这段代码所输出的样例数据为: 
```
11
1 3 6 10 
2 7 9 
4 5 11 
8 
```
并非 是代码错误原因
(~~垃圾笔者在这个地方卡了很长时间~~)

**代码酱 OVO↓**
```cpp
#include <bits/stdc++.h>
using namespace std;

#define N 300001
#define k 5000
#define v to[i]
#define inf 0x7f7f7f7f

int n,m,s,t;
int num,ans;
int dep[N],vis[N];
int head[N],to[N],from[N],nex[N],w[N],ecnt;

void ae(int x,int y,int z){
    from[ecnt]=x;
    to[ecnt]=y;
    w[ecnt]=z;
    nex[ecnt]=head[x];
    head[x]=ecnt++;
}

bool bfs(){
    memset(dep,-1,sizeof(dep));
    queue<int> q;
    dep[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nex[i]){
            if(dep[v]==-1 and w[i]>0){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t]!=-1;
}

int dfs(int u,int low){
    if(u==t)
        return low;
    int ret=low;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(dep[v]==dep[u]+1 and w[i]>0){
            int flow=dfs(v,min(ret,w[i]));
            if(flow>0){
                w[i]-=flow;
                w[i^1]+=flow;
            }
            ret-=flow;
            if(!ret)
                break;
        }
    }
    return low-ret;
}

int dinic(){
    int res=0;
    while(bfs()){
        res+=dfs(s,inf);
    }
    return res;
}

void work(int u){//当前点
    if(vis[u])//如果当前点以访问过 就返回
        return;
    printf("%d ",u);
    vis[u]=1;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(!w[i] and v!=s){
            if(!vis[v-k])
                work(v-k);
        }
    }
} 

void pre(){
    scanf("%d",&n);
    s=0,t=k*2+1;
    for(int i=1;i<=k;i++){
        ae(s,i,1);
        ae(i,s,0);
        ae(i+k,t,1);
        ae(t,i+k,0);
    }
    int flag=0;
    ans=0,num=0;
    while(1){
        ans++,num++;
        for(int i=1;i<=num-1;i++){
            if(sqrt(i+num)==(int)(sqrt(i+num))){//判断i+num是否是整数的平方 c++11中必须这么写
                ae(i,num+k,1);
                ae(num+k,i,0);
            }
        }
        ans+=dinic();//每次求得的最大匹配数
        if(num-ans>n)//num=ans+n如果越界 就退出
            break;
    }
}

int main(){
    memset(head,-1,sizeof(head)); 
    pre();
    printf("%d\n",num-1);
    for(int i=1;i<=num-1;i++){
        if(!vis[i]){
            work(i);
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：Jason_Lee (赞：1)

### **前记**

今日模拟赛做到了这道题的第一问，看到的第一眼感jio好像汉诺塔欸，然后就自己强行手推规律，~~用半小时推出规律后把这道题秒了~~

结束后同机房大佬说这道题原题是网络流，洛谷上有原题，可是我还没学到，就想着自己炸了估计，就上洛谷交了一份代码，结果莫名AC？


### 正传

这道题的规律还是挺好推的，你只需要手动模拟到大概第五根柱子的时候就能得出了，作为一篇题解，我还是要在这里还原一篇我手推的过程的qaq

首先我们来看只有一根柱子的时候，只能往上面放1号魔术球，此时只能放1个魔术球。

然后是两根柱子时，我们可以在第一根上放1，3并在第二根上放2，此时可以放3个魔术球

然后是三根柱子时....

慢慢的我们可以发现，当你有n根柱子时，你所能得到的最大魔术球数量不会大于(n+1)^2/2,因为你一旦大于这个数时，你就可以一直加到(n+1)^2,~~然后你就可以继续加，然后就可以实现一根柱子上挂无数颗魔术球(滑稽)~~

所以当我们拥有n根柱子时，我们所能放的魔术球的数量绝对会小于(n+1)^2/2，所以我们得出来通项公式就是(n+1)^2/2-1

有了这个规律后，我们可以先不求第二问，先用这个求出当有55根柱子时，我们能得到的最大魔术球的个数，通过我的程序得出的数字没有大于2000，所以第二问我就极其愉快得打起了暴力....

下面贴出我的代码（重点在solve函数，一般只要能得出第一问的结论后，第二问得暴力想必大家都会吧qaq）

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ri register int

const int N = 2010;
using namespace std;

inline int read () {
	int x = 0, f = 1; int ch = getchar ();
	while (!isdigit (ch)) {
		if (ch == '-') f = -1;
		ch = getchar ();
	}
	while (isdigit (ch)) {
		x = (x<<1) + (x<<3) + ch - '0';
		ch = getchar ();
	}
	return x * f;
}

int n, cnt[N];
int ans; 
int a[N][N];

int solve (int x) {
	int res = (x+1) * (x+1);
	res >>= 1;
	res--;
	return res;
}

int main () {
	n = read ();
	ans = solve (n);
	cout << ans << endl;
	for (int i = 1; i <= ans; i++) {
		for (int j = 1; j <= n; j++) {
			if (!cnt[j]) {
				a[j][++cnt[j]] = i;
				break;
			}
			int sum = a[j][cnt[j]] + i;
			int s = (int)sqrt (sum);
			if (s*s == sum) {
				a[j][++cnt[j]] = i;
				break;
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= cnt[i]; j++) {
			cout << a[i][j] << " "; 
		}
		cout << endl;
	}
	return 0;
}


```


---

## 作者：little_sun (赞：1)

枚举答案，对于$(i,j)(i<j)$,若$i<j$且$i+j$是完全平方数，则从$i$向$j$连一条边

然后跑最小路径覆盖(可以参照[P2764](https://www.luogu.org/problemnew/show/P2764))

方案输出也类似那一题

```cpp 
#include <bits/stdc++.h>

#define R register
#define ll long long
#define cmax(a, b) ((a < b) ? b : a)
#define cmin(a, b) ((a < b) ? a : b)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 2e4 + 10;
const int MaxM = 5e5 + 10;
const int inf = (1 << 30);

struct edge
{
    int to, next, cap;
};

edge e[MaxM];
int n, m, s = 20000, t = 20001, cnt = 1, ans, tmp;
int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN], vis[MaxN], to[MaxN];

inline void add(int u, int v, int c)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].cap = c;
    head[u] = cnt;
}

inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

inline int bfs()
{
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    std::queue<int> q;
    dep[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].to, c = e[i].cap;
            if (dep[v] || !c)
                continue;
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
    return dep[t];
}

inline int dinic(int u, int flow)
{
    if (u == t)
        return flow;
    int rest = flow;
    for (int i = cur[u]; i && (flow - rest < flow); i = e[i].next)
    {
        int v = e[i].to, c = e[i].cap;
        if (dep[v] != dep[u] + 1 || !c)
            continue;
        int k = dinic(v, cmin(rest, c));
        if (!k)
            dep[v] = dep[u] + 1;
        else
        {
            e[i].cap -= k;
            e[i ^ 1].cap += k;
            rest -= k;
            if (e[i].to > 5000)
                vis[e[i].to - 5000] = 1;
            to[u] = e[i].to;
        }
    }
    if (flow - rest < flow)
        dep[u] = -1;
    return flow - rest;
}

inline void solve()
{
    int now = 0;
    while (bfs())
        while ((now = dinic(s, inf)))
            ans -= now;
}

int main()
{
    n = read();
    while (1)
    {
        ans++, tmp++;
        for (int i = 1; i < tmp; i++)
        {
            int x = sqrt(i + tmp);
            if (x * x == (i + tmp))
                add_edge(i, tmp + 5000, 1);
        }
        add_edge(s, tmp, 1), add_edge(tmp + 5000, t, 1);
        solve();
        if (ans > n)
            break;
    }
    --tmp;
    printf("%d\n", tmp);
    for (int i = 1; i <= tmp; i++)
    {
        if (vis[i])
            continue;
        printf("%d ", i);
        int t = i;
        while (to[t])
        {
            printf("%d ", to[t] - 5000);
            t = to[t] - 5000;
        }
        puts("");
    }
    return 0;
}
```



---

## 作者：Ajsoabk (赞：1)

博大精深的网络流。。。

# [网络流24题-魔术球问题](https://www.luogu.org/problemnew/show/P2765)

做了几道网络流的题

想都没想就把点拆开（这里是球）

然后在源汇-二分图上连边（写的几道较简单的网络流都是这样，无非连边方式不同罢了）

然后就蒙了，搞不懂意义在哪

由于一个球可能和两个球相接触，

我甚至想把从源出的边、入汇的边的容量设为2，

这样左右部集都可能会与两个相匹配

可是这样就没法保证球的连续相邻

那就规规矩矩地将和为平方的连起来？

想到了这里却困于无法理解这跟答案的关联

然后看到了[某篇题解](https://kskun.blog.luogu.org/solution-p2765)

o~~

---

**枚举球数，球数每增加1就建立新加入的球的关系，并且重复地跑最大流。**...当新加入的球能够加入柱子时，重复跑最大流是能得到新流（即：该球可与其他球构成新的相邻关系）的，**只要一直能得到新流，就说明柱子上还可以再加，当有一次得不到新流，就说明柱子满了**，新加入的球并没能加入到任何一个柱子上。此时我们就加柱子。直到柱子加到超过n，此时的球数-1就是最大球数（因为此时实际上柱子加到超过n了）。

---

正确性很好理解，可是从何而来呢？

我们想想一个球刚来，正准备放入某个柱顶

这时它只会选择一个球匹配（相邻）

或者不匹配（独立）

所以走一遍二分图最大匹配看匹配数是否增加就行了

### 方案输出

方案输出就仁者见仁智者见智了

这里又能对你自己建的图有一个更深的理解

比如：**从左部集到右部集的流代表什么？对我们有什么用？**

还是想想球刚进来的时候（用特殊情况来解释普遍情况）

若没有新流

则新节点独立（自成一柱）->

则新球在柱上没有在其下的球

∴左到右的边代表从上往下的关系

而若要输出方案

我们是要沿着柱子从下到上的关系遍历并输出的（可以在柱子增多的时候记录新增的球，即**每根柱底的球已知**）

那就保证输出时走的边都是从右往左即可


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=2000;
const int inf=0x7fffffff;
int hea[(N<<1)+5],dep[(N<<1)+5],s,t,to[(N*100)<<1],val[(N*100)<<1],nex[(N*100)<<1],tot=1,k,n,sta[60],top;
template<class T>inline void read(T &num){
	char ch;
	while(!isdigit(ch=getchar()));
	num=ch-'0';
	while(isdigit(ch=getchar()))num=num*10+ch-'0';
}
inline void add_edge(const int x,const int y,const int w){
//printf("%d --> %d ( %d ) \n",x,y,w);
	to[++tot]=y,nex[tot]=hea[x],hea[x]=tot,val[tot]=w;
}

queue<int> que;
bool bfs(){
	memset(dep,0,sizeof(dep));
	dep[s]=1;
	que.push(s);
	int x;
	while(que.size()){
		x=que.front();que.pop();
		for(int i=hea[x];i;i=nex[i]){
			int y=to[i];
			if(val[i]&&!dep[y]){
				dep[y]=dep[x]+1;
				if(y==t)return true;
				que.push(y);
			}
		}
	}
	return false;
}

int dfs(const int x,const int flow){
	if(x==t)return flow;
	int rest=flow,k;
	for(int i=hea[x];i&&rest;i=nex[i]){
		int y=to[i];
		if(val[i]&&dep[y]==dep[x]+1){
			k=dfs(y,min(rest,val[i]));
			if(k){
				val[i]-=k;
				val[i^1]+=k;
				rest-=k;
			}
			else dep[y]=0;
		}
	}
	return flow-rest;
}

int dinic(){
	int maxflow=0,flow;
	while(bfs())while(flow=dfs(s,inf))maxflow+=flow;
	return maxflow;
}

void dfs2(int x){
	printf("%d ",x-N); 
//printf("hea[%d]=%d\n",x,hea[x]);
	for(int i=hea[x];i;i=nex[i]){
		int y=to[i];
//printf("y=%d\n",y);
		if(y!=s&&y!=t&&val[i]==1){
			dfs2(y+N);
		}
	}
}

int main(){
	read(n);
	s=(N<<1)+1;
	t=s+1;
	for(k=1;;++k){
		for(int i=2;i*i-k<k;++i){
			add_edge(k,i*i-k+N,1);
			add_edge(i*i-k+N,k,0);
		}
		add_edge(s,k,1);
		add_edge(k,s,0);
		add_edge(k+N,t,1);
		add_edge(t,k+N,0);
		if(!dinic()){
			n--;
			sta[++top]=k;
			if(n<0){
				printf("%d\n",k-1);
				for(int i=1;i<top;++i){
					dfs2(sta[i]+N);
					putchar('\n');
				}
				return 0;
			}
		}
	}
}
	
	
```

---

## 作者：不存在之人 (赞：1)

## **做法**

- 首先可以贪心，如果可以套在其他小球上，则套在其他小球上，反之，套在柱子上，直到没有多余柱子，可以证明这是对的，但我觉得还是网络流的做法比较重要。

- 因为要依次取小球，那么当答案为ans时，编号为1-ans的小球都被取走，我们可以用类似于洛谷 P1251 餐巾计划问题的做法来拆点建图。 

- 将每个点拆成a，b两点，因为放环有两种可能，从s连一条边到a，流量为1，表示直接将小球放在柱子底部，a再向t连一条流量为1的边，保证该小球已经用过了，S向b连一条流量为1的边，因为该小球并不会随着它流到汇点而消失，b向编号大于它的且满足和为完全平方数的点的a连边，表示在这个小球上放小球。最后S向s连一条流量为柱子数的边，用于限制柱子数。 

- 在实际操作时，因为并不知道答案为多少，为了保证它能依次被取走，故要枚举小球个数，不断的在残余网络上加入有关第i个小球的边，并在参与网络的基础上求最大流，若最大流不等于i，说明i-1为最优解。因为除了S->s的边外，边权均为一，因而可以枚举边来计算流量。 

- 另外此题不可以二分答案来做，因为从小到大枚举小球个数时可以利用残余网络加速，而二分则每次都要重新建图，反而更劣。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define INF 0x3f3f3f3f
#define N 4100
using namespace std;
int n,m,bb,first[N],deep[N],tmp,s,t,sum,ans,cur[N];
bool out[N];
struct Bn
{
    int next,to,quan;
} bn[200100];
queue<int>que;
inline void add(int u,int v,int w)
{
    bn[bb].to=v;
    bn[bb].quan=w;
    bn[bb].next=first[u];
    first[u]=bb;
    bb++;
}
inline void ad(int u,int v,int w)
{
    add(u,v,w);
    add(v,u,0);
}
inline bool bfs()
{
    int p,q;
    for(;!que.empty();que.pop());
    memset(deep,0,sizeof(deep));
    deep[s]=1;
    que.push(s);
    for(; !que.empty();)
    {
        q=que.front();
        que.pop();
        for(p=first[q]; p!=-1&&!deep[t]; p=bn[p].next)
        {
            if(deep[bn[p].to]||!bn[p].quan) continue;
            deep[bn[p].to]=deep[q]+1;
            que.push(bn[p].to);
        }
    }
    return deep[t];
}
int dfs(int now,int mn)
{
    if(now==t)
    {
        return mn;
    }
    int res;
    for(int &p=cur[now]; p!=-1; p=bn[p].next)
    {
        if(deep[bn[p].to]!=deep[now]+1||!bn[p].quan) continue;
        res=dfs(bn[p].to,min(bn[p].quan,mn));
        if(res)
        {
            bn[p].quan-=res;
            bn[p^1].quan+=res;
            return res;
        }
    }
    return 0;
}
int main()
{
    memset(first,-1,sizeof(first));
    int i,j,p,q,o,z;
    cin>>n;
    s=4001,t=4002;
    for(i=1; i*i<=4000; i++)
    {
        for(j=1; j<=i*i/2; j++)
        {
            if(i*i-j<=2000&&j<i*i-j)
                ad(j+2000,i*i-j,1);
        }
    }
    ad(s,0,n);
    for(i=1; i<=2000; i++)
    {
        ad(0,i,1);
        ad(s,i+2000,1);
        ad(i,t,1);
        for(; bfs();)
        {
            for(j=0; j<=t; j++) cur[j]=first[j];
            for(p=dfs(s,INF); p; ans+=p,p=dfs(s,INF));
        }
        if(ans!=i) break;
    }
    cout<<i-1<<endl;
    for(j=1;j<i;j++)
    {
        if(out[j]) continue;
        printf("%d ",j);
        for(q=j;;)
        {
            for(p=first[q+2000];p!=-1;p=bn[p].next)
            {
                if(!bn[p].quan&&bn[p].to>=1&&bn[p].to<=2000)
                {
                    q=bn[p].to;
                    out[q]=1;
                    printf("%d ",q);
                    break;
                }
            }
            if(p==-1) break;
        }
        puts("");
    }
}
```

---

## 作者：Bartholomew (赞：1)

我只是来发一个二分图题解:
因为下面有dalao钦点了:
```cpp
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <vector>
#define MAXN 10050
#define N 2050
#define INF 0x3f3f3f3f
#define P pair<int,int>
using namespace std;

int T, max_num, n, m, e, sum, x, y, cnt, belong[N << 1], stand[N << 1];
bool vis[N << 1];
std::vector<int> G[N];

inline int read()
{
    int x = 0;
    char c = getchar();
    bool flag = 0;
    while(c < '0' || c > '9'){if(c == '-')flag = 1;c = getchar();}
    while(c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}
    return flag ? -x : x;
}
inline bool found(int x)
{
    for(int i = 0; i < (int) G[x].size(); i++)
    {
        int v = G[x][i];
        if(vis[v]) continue;
        vis[v] = true;
        if(!belong[v] || found(belong[v]))
        {
            belong[v] = x;
            return true;
        }
    }
    return false;
}
void solve()
{
    for(register int i = 1;i <= max_num; ++i)
    {
        memset(vis , 0 ,sizeof vis);
        if(found(i)) sum ++;
    }
    memset(G, 0, sizeof G);
    for(register int i = 1;i <= max_num; ++i)
    {
        if(!belong[i]) 
        {
            // cout<<cnt<<endl;
            stand[i] = ++cnt, G[cnt].push_back(i);
        }
        else 
        {
            G[stand[belong[i]]].push_back(i), stand[i] = stand[belong[i]];
        }
        // cout<<"i="<<i<<" stand="<<stand[i]<<endl;
    }
}
int main(int argc, char const *argv[])
{
    n = read();
    max_num = (n * (n + 2) + (n & 1) - 2) >> 1;
    for(register int i = 1; i <= max_num; ++i)
        for(register int j = i + 1; j <= max_num; ++j)
        {
            int now = sqrt(i + j);
            if(now * now != i + j) continue;
            G[i].push_back(j);
        }
    solve();
    printf("%d\n",max_num);
    for(register int i = 1; i <= cnt; ++i)
    {
        for(register int j = 0; j < (int)G[i].size(); ++j)
            printf("%d ",G[i][j]);
        puts("");
    }
    return 0;
}
```

---

## 作者：BJpers2 (赞：1)

## 直接贪心就过了
方法很暴力，一个一个填入，填不了就新开一个柱子。我稍微推理了一下，当要填[n^2+(n&1)]/2时，好像不得不新开一个柱子。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,a[60][1000],top[60],tmp,yes=1,v;
int main(){
	scanf("%d",&n);
	for(v=1;yes;v++){
		yes=0;
		for(int i=1;i<=n;i++){
			tmp=a[i][top[i]]+v;
			if((int)sqrt(tmp)*(int)sqrt(tmp)==tmp || v==tmp){
				a[i][++top[i]]=v,yes=1;
				break;
			}
		}
	}
	v-=2;printf("%d\n",v);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=top[i];j++)
		    printf("%d ",a[i][j]);
		printf("\n");
	}
	return 0;
} 
```

---

## 作者：s15172528531 (赞：0)

# 本题绝对是匈牙利二分匹配好题
## 完全模拟出了匈牙利二分的全过程
### 每一次加点：找点，加边，匹配
模型建立：从1开始遍历,对于每一个i，从1遍历i-1到，找到i之前能与这个数相加能成为完全平方数的点,然后加一条从i连到这个点的单向边，加完边后跑一遍匈牙利DFS，看能否添加新的匹配，若能添加新的匹配则匹配数++，最小路径覆盖=i（点数）-匹配数，最小路径覆盖就是题目中所要求的多少个柱子能放球，当最小路径覆盖大于n时，i-1就是我们要求的能放进n个柱子的最多球，但此时第i次已经改变了匹配，此时，我们需要删去第i次加的点，还原第i-1次匹配情况，而第i-1次匹配情况就是我们要求的答案

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ms(x,y) memset(x,y,sizeof(x))
using namespace std;
const int maxn =1e5;
const int maxm =1e6;
struct Edge{
	int to,next;
}edge[maxm];
int head[maxn],tot;
int linker[maxn],flag[maxn];
void addedge(int u,int v){
	edge[tot].to=v;
	edge[tot].next=head[u];
	head[u]=tot++;
}
int sq[5005];
void init(){
	ms(head,-1);
	tot=0;
	for(int i=1;i<=5000;i++)sq[i]=i*i;
}
bool used[maxn];
bool dfs(int u){//匈牙利二分匹配之DFS部分
	for(int i=head[u];i!=-1;i=edge[i].next){
		int v=edge[i].to;
		if(used[v])continue;
		used[v]=true;
		if(linker[v]==-1||dfs(linker[v])){
			linker[v]=u;
			flag[u]=v;
			return true;
		}
	}
	return false;
}
void outAns(int u){
	printf("%d",u);
	if(flag[u])printf(" "),outAns(flag[u]);
	else printf("\n");
}
int main()
{
	init();
	int n;
	scanf("%d",&n);
	int res=0;
	ms(linker,-1);
	int ans;
	int addEdgeNum;
	for(int i=1;;i++){//加点
		ms(used,false);
		addEdgeNum=0;;
		int j=upper_bound(sq+1,sq+5001,i)-sq;//二分找到第一个比i大的二分匹配数
		while(sq[j]<=2*i){//每个二分匹配数只能给i连一条边
			int v=sq[j]-i;
			if(v>=i)break;
			addedge(i,v);
			addEdgeNum++;
			j++;
		}
		if(dfs(i))res++;//匹配
		if(i-res>n){ans=i-1;break;}
	}
	tot-=addEdgeNum;//用除去ans+1次构图的边重跑一遍图
	printf("%d\n",ans);
	ms(linker,-1);
	ms(flag,0);
	for(int i=1;i<=ans;i++)ms(used,false),dfs(i);
	for(int i=1;i<=ans;i++)if(linker[i]==-1)outAns(i);
}
```


---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10213588.html)

这道题目，一眼看上去，并不能用网络流做

但是我们发现，如果将每个点拆成x和x'

然后x连源点，x'连汇点 都用容量为一的边

再然后是找这个数可以与那个数组成完全平方数，然后将这个数i与x'连边

每加入一个点就跑一次最大流

那么如果可以塞进原柱，那么最大流就得到1否则为0

那么我们在得到0的时候新建柱子即可

另外，我们要注意

在判断完全平方数的时候
```cpp
sqrt(ge+i)*sqrt(ge+i)==ge+i
```

这样判断在Windows下是正确的

但在Linux下要写成
```cpp
(int)sqrt(ge+i)*sqrt(ge+i)==ge+i
```

总体实现如下：
```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=100100;
queue<int> Q;
int src=0,n,num,st=50014,d[N],head[N],pre[N],cnt=1,ge,jl[N],book[N];
struct EDGE{int nxt,val,to;}e[N];
void add(int u,int v,int w){e[++cnt]=(EDGE){head[u],w,v};head[u]=cnt;}
int BFS()
{
    while(!Q.empty()) Q.pop();Q.push(src);
    memset(d,-1,sizeof(d));d[src]=0;int u;
    while(!Q.empty())
    {
        u=Q.front();Q.pop();
        for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(e[i].val&&d[v]==-1)
        {
            d[v]=d[u]+1;
            if(v==st) return 1;
            Q.push(v);
        }
    }
    return 0;
}
int DFS(int u,int flow)
{
    if(u==st||flow==0) return flow;
    int res=flow,tt;
    for(int i=head[u],v=e[i].to;i&&res;i=e[i].nxt,v=e[i].to) if(e[i].val&&d[v]==d[u]+1)
    {
        tt=DFS(v,min(res,e[i].val));
        if(!tt) d[v]=-1;
        if(tt&&v!=st) pre[u>>1]=v>>1;
        e[i].val-=tt;e[i^1].val+=tt;
        res-=tt;
    }
    return flow-res;
}
int Dinic()
{
    int all=0;
    while(BFS()) all+=DFS(src,0x3f3f3f3f);
    return all;
}
int main()
{
    // freopen("input","r",stdin);
    // freopen("output","w",stdout);
    n=read();
    while(num<=n)
    {
        ++ge;
        add(src,ge<<1,1);add(ge<<1,src,0);
        add(ge<<1|1,st,1);add(st,ge<<1|1,0);
        for(int i=1;i<ge;++i) if((int)sqrt(ge+i)*sqrt(ge+i)==ge+i) 
        {
            add(i<<1,ge<<1|1,1);
            add(ge<<1|1,i<<1,0);
        }
        if(!Dinic()) jl[++num]=ge;
    }
    printf("%d\n",--ge);
    for(int i=1;i<=n;i++)
    {
        if(book[jl[i]]) continue;
        int tt=jl[i];book[tt]=1;
        while(tt) printf("%d ",tt),book[tt=pre[tt]]=1;
        printf("\n");
    }
    return 0;
}

```

---

## 作者：Isonan (赞：0)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2765)

这道题很像[最小路径覆盖问题](https://www.luogu.org/blog/PopulusEuphratica/luogup2764-zui-xiao-lu-jing-fu-gai-wen-ti)

这个问题乍一看很难做，但是考虑转化一下这个问题：当有确定个数的球时，最少需要几个柱子？这很明显是一个最小路径覆盖问题，且易证答案具有单调性，所以可以每次加一个球，计算最少需要柱子数（其实也可以二分，但是递推复杂度也够了）。

但是这样每次建图复杂度还是会爆，再考虑一下，其实每次加入一个球不需要再次建图，只需要把该加的边加进去，对残余量再跑一遍网络流就行了。

代码：

```cpp
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int head[60001],nxt[6000001],b[6000001],v[6000001],k=1,S,T,answer;
int dis[60001],p[60001],q[60001],h,t,n,ans[60001],net[60001];
bool vis[60001];
void push(int s,int t,int val){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=val;
}
void link(int s,int t,int val){
	push(s,t,val);
	push(t,s,0);
}
bool bfs(){
	memset(dis,0,sizeof dis);
	h=t=0;
	q[++t]=S;
	dis[S]=1;
	while(h<t){
		++h;
		for(int i=head[q[h]];i;i=nxt[i])
			if(v[i]&&!dis[b[i]]){
				dis[b[i]]=dis[q[h]]+1;
				q[++t]=b[i];
				if(b[i]==T)return 1;
			}
	}
	return 0;
}
int dfs(int x,int flow){
	if(x==T||!flow)return flow;
	int used=0;
	for(int i=p[x];i;i=nxt[i])
		if(v[i]&&dis[b[i]]==dis[x]+1){
			int w=dfs(b[i],min(flow-used,v[i]));
			v[i]-=w;
			v[i^1]+=w;
			used+=w;
			if(w)p[x]=i,net[x]=b[i]>>1;
			if(flow==used)return flow;
		}
	if(!used)dis[x]=0;
	return used;
}
void print(int i){
	printf("%d ",i);
	vis[i]=1;
	if(ans[i<<1])print(ans[i<<1]); 
}
int main(){
	scanf("%d",&n);
	S=0,T=30000;
	int cnt;
	for(cnt=1;;cnt++){
		link(S,cnt<<1,1),link(cnt*2+1,T,1);
		int i;
		for(i=1;i*i<=cnt;i++);
		for(;i*i<(cnt<<1);i++)link((i*i-cnt)<<1,cnt<<1|1,1);
		while(bfs()){
			memcpy(p,head,sizeof p);
			answer+=dfs(S,2);
		}
		if(cnt-answer>n)break;
		memcpy(ans,net,sizeof ans);
	}
	cnt--;
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;i++)if(!vis[i])print(i),putchar('\n');
}
```

---

## 作者：风火 (赞：0)

```cpp
//暴搜居然可以过，不可思议~~~~~
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
const int o=512,oo=100024;
int n,ans;
int jud[o+5],vis[oo];
vector<int> a[60];
bool check(int x)//检查当前数是否为完全平方数
{
	for(int i=1;i<=o;i++)
	{
		if(jud[i]>x) return false;//超过了还需枚举吗？答案当然不用
		if(jud[i]==x) return true;
	}
	return false;//没有找到
}
void dfs(int res)
{
	for(int i=1;i<=n;i++)
	{
		if((a[i].size()==0||check(a[i][a[i].size()-1]+res))&&vis[res]==0)
        //第i根柱子为空柱或者放到这个柱子上面可行
		//但是当前数必须没有找过
        {
			vis[res]=1;//已经找过
			ans=max(ans,res);//统计答案
			a[i].push_back(res);//放入
			dfs(res+1);//继续向下找
		}
	}
}
void print()//辣眼睛的输出
{
	printf("%d\n",ans);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<a[i].size();j++)
			printf("%d ",a[i][j]);
		printf("\n");
	}
	return ;
}
/*思路：没有什么思路，直接搜就好了，
解释在代码中了......
自己编译程序后看看，然后发现很神奇的东西*/
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=o;i++) jud[i]=i*i;
	a[1].push_back(1);//先把1装进去，随便放哪都一样
	dfs(2);
	print();
	return 0;
}
```

---

## 作者：gorokokoro (赞：0)

居然没有费用流题解？

首先打表得最多可放球数为 $\frac{n^2+2n+(n\text{ mod }2)}{2}-1$

然后费用流就变成了我们求解放置方案的方法

要求放 $n$ 根柱子，这意味着满流为 $n$

放每个球可以获得 $1$ 的收益，这意味着这条边费用为 $-1$

每个球只能够被放 $1$ 次，因此拆点

具体的看代码的连边方法吧，没有什么难度

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <utility>
#define N 3200
using namespace std;

class Edge
{
public:
    int v;
    int w;
    int c;
};

vector<Edge> d;
vector<int> e[N];
int p[N], f[N];
bool u[N];
vector<int> o[N];

int AugmentKarp(int s, int t)
{
    int x, o;

    for(x = t, o = N;x != s;x = d.at(p[x] ^ 1).v)
        o = min(o, d.at(p[x]).w);
    for(x = t;x != s;x = d.at(p[x] ^ 1).v)
    {
        d.at(p[x]    ).w -= o;
        d.at(p[x] ^ 1).w += o;
    }

    return o;
}

bool AdvanceKarp(int s, int t)
{
    int i, j;
    queue<int> q;

    q.push(s);
    for(i = 0;i < N;i ++)
        f[i] = N;
    f[s] = 0;
    u[s] = true;

    for(;!q.empty();q.pop())
    {
        s = q.front();
        //cout<<s<<' '<<f[s]<<endl;
        for(i = 0;i < (signed)e[s].size();i ++)
        {
            j = e[s].at(i);
            if(f[d.at(j).v] > f[s] + d.at(j).c && d.at(j).w)
            {
                f[d.at(j).v] = f[s] + d.at(j).c;
                p[d.at(j).v] = j;
                if(!u[d.at(j).v])
                {
                    u[d.at(j).v] = true;
                    q.push(d.at(j).v);
                }
            }
        }
        u[s] = false;
    }

    return f[t] != N;
}

pair<int, int> Karp(int s, int t)
{
    pair<int, int> o;
    int k;

    for(o = make_pair(0, 0);AdvanceKarp(s, t);)
    {
        k = AugmentKarp(s, t);
        o = make_pair(o.first + k, o.second + k * f[t]);
    }

    return o;
}

void AddEdge(int u, int v, int w, int c)
{
    e[u].push_back(d.size());
    d.push_back((Edge){v, w, c});
    e[v].push_back(d.size());
    d.push_back((Edge){u, 0, -c});

    return;
}

bool Square(int x)
{
    int s;

    s = sqrt(x);

    return x == s * s;
}

void Output(int m)
{
    int i, j, t, p;

    for(i = j = 0;i < (signed)e[0].size();i ++)
        if(!d.at(e[0].at(i)).w)
        {
            p = d.at(e[0].at(i)).v;
            while(p != m * 2 + 1)
            {
                if(p & 1)
                    o[j].push_back((p + 1) >> 1);
                for(t = 0;t < (signed)e[p].size();t ++)
                    if(d.at(e[p].at(t)).v > p && !d.at(e[p].at(t)).w)
                    {
                        p = d.at(e[p].at(t)).v;
                        break;
                    }
            }
            j ++;
        }

    return;
}

int main(void)
{
    int n, m;
    int i, j;

    cin >> n;
    m = (n * (n + 2) + (n & 1) - 2) >> 1;
    for(i = 1;i <= m;i ++)
    {
        AddEdge(i * 2 - 1, i * 2, 1, 0);
        AddEdge(0, i * 2 - 1, 1, -1);
        AddEdge(i * 2, m * 2 + 1, 1, 0);
        for(j = i + 1;j <= m;j ++)
            if(Square(i + j))
                AddEdge(i * 2, j * 2 - 1, 1, -1);
    }
    AddEdge(m * 2 + 1, m * 2 + 2, n, 0);
    Karp(0, m * 2 + 2);

    cout << m << endl;
    Output(m);
    for(i = 0;i < n;i ++)
    {
        for(j = 0;j < (signed)o[i].size();j ++)
            cout << o[i].at(j) << ' ';
        cout << endl;
    }

    return 0;
}
```

---

## 作者：_HLLY_ (赞：0)

这个题是可以二分检验的

每次二分到一个值，就建立二部图匹配求出需要的最少的柱子数

但每次删边重建的话效率其实是不如枚举的、、、


代码：



     
   
     
     
     
  




      
    
    

    
    
   
     
            
     
     
     
     


    
    
    
    
    


    
  


      

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#include<cstring> 
#include<queue>
#define N 3000000
#define inf 10000009
int zhong[N],xia[N],zhen1,zhen2,hou[N],yuan[N],tot=-1,zhi[N],dis[N],dianshu,i,j,s,t,n,mid,uuu[3000],daan;
bool you[4005];
int q[N];
void jia(int x,int y,int z)
{
 zhong[++tot]=y,hou[tot]=yuan[x],yuan[x]=tot,zhi[tot]=z;    
}
void jian(int x,int y,int z)
{
jia(x,y,z);
jia(y,x,0);    
}
bool bfs(int s,int t)
{
     int i;
     memset(dis,0x7f,sizeof(dis));
     for(i=0;i<=dianshu;i++)
     xia[i]=yuan[i];
    // cout<<dianshu;
     zhen1=0;
     zhen2=1;
     q[1]=s;
     dis[s]=0;
     while(zhen1!=zhen2)
     {
     int st=q[++zhen1];//cout<<st<<"　";
     for(i=xia[st];i!=-1;i=hou[i])
     {int nd=zhong[i];//cout<<nd<<"  ";
     if(dis[nd]>inf&&zhi[i])dis[nd]=dis[st]+1,q[++zhen2]=nd;                             
     }                 
     }
     return dis[t]<inf;    
}
int dfs(int now,int t,int limit)
{
 if(now==t||!limit){return limit;}
 int f,i,flow=0;
   for(i=xia[now];i!=-1;i=hou[i])
   {xia[now]=i;
   int nd=zhong[i];
    if((dis[nd]==dis[now]+1)&&(f=dfs(nd,t,min(limit,zhi[i]))))
    {
    zhi[i]-=f;
    zhi[i^1]+=f;
    limit-=f;
    flow+=f;
    if(!limit)break;                          
    }                                                            
   }
    return flow;
}    
int dinic(int s,int t)
{ 
    int ans=0;
while(bfs(s,t))
{//cout<<"p";
               ans+=dfs(s,t,inf);
}
return ans;
}
int erfen()
{
     int l=1,r=1600,hehe;
     while(l<r)
     {
      mid=(l+r)>>1;
     //
     tot=-1;dianshu=2*mid+10000;
      memset(yuan,-1,sizeof(yuan));
    s=2*mid+999,t=2*mid+1000;
    for(i=1;i<=mid;i++)
    jian(s,i,1),jian(i+mid,t,1);
    for(i=2;i<=mid;i++)
    for(j=1;j<i;j++)
    if(you[j+i])jian(i,mid+j,1);//cout<<zhong[yuan[s]]; 
     hehe=dinic(s,t);//cout<<hehe<<endl;
     if(mid-hehe>n)r=mid;     
     else {l=mid+1;
       for(i=xia[s];i!=-1;i=hou[i])
    {
        int nd=zhong[i];
        for(j=xia[nd];j!=-1;j=hou[j])
        {
            int rd=zhong[j];
            if(!zhi[j])
            {
                uuu[rd-mid]=nd;
            }
        }       
    }
     daan=mid;
     }
     }
     mid=daan;
     return daan;    
}
int main()
{
    for(i=1;i*i<=4000;i++)
      you[i*i]=1;
    scanf("%d",&n);
    printf("%d\n",erfen());
memset(you,0,sizeof(you));
       for(i=1;i<=mid;i++)
     {
         if(you[i])continue;
         printf("%d",i);
         you[i]=1;
         int lin=i;
         while(uuu[lin])printf(" %d",uuu[lin]),you[uuu[lin]]=1,lin=uuu[lin];
           printf("\n");
     }
}
```

---

## 作者：zhhe0101 (赞：0)

恩，一看标签网络流。

再看题目，哎？贪心？！

贪心策略：用二维数组记录每个柱子上的元素，按顺序枚举，将新元素与每个柱顶元素比较判断是否合法，合法就加入该柱子，否则新开一个柱子，若当前柱子数超过题目要求，则退出，输出答案，然后将二维数组记录的答案输出。

代码：

```cpp

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int a[2005][2005];
int n,flag,x,i,j,cnt;
int main()
{
    scanf("%d",&n);
    x=1;
    cnt=1;
    a[1][0]=1;
        a[1][1]=1;
    while (1)
    {
        flag=0;x++;
        for (i=1;i<=cnt;i++)
        {
            if ((int)sqrt(x+a[i][a[i][0]])==sqrt(x+a[i][a[i][0]])) {a[i][++a[i][0]]=x;flag=1;}
            if (flag==1) break;
        }
        if (flag==1) continue;
        cnt++;
        if (cnt>n) break;
        a[cnt][0]=1;
        a[cnt][1]=x;
        
    }
    printf("%d\n",x-1);
    for (i=1;i<=cnt;i++)
    {
        for (j=1;j<=a[i][0];j++)
             printf("%d ",a[i][j]);
        printf("\n");
    }

}
```

---


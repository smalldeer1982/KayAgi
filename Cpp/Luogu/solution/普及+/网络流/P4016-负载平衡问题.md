# 负载平衡问题

## 题目描述

$G$ 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。


## 说明/提示

$1 \leq n \leq 100$。


## 样例 #1

### 输入

```
5
17 9 14 16 4```

### 输出

```
11```

# 题解

## 作者：浅色调 (赞：187)

### 思路：
$\quad\quad$**贪心+数学**

$\quad$先来讲下普通均分纸牌问题：

　　　　普通均分纸牌问题就是$n$个小朋友排成一列，各自有$a[i]$张牌，每个人只能给相邻的人传递纸牌，问至少需要传递多少张纸牌才能使每个小朋友牌的个数相等。

　　　　设总牌数为$sum$（即$sum=\sum{a[i]}$），则每个人最后会各自有$T=\frac{sum}{n}$张牌，设$g[i]=T-a[i]$，则让前$k$个人牌数相同需要的交换牌数为$\sum\limits_{i=1}^{i\leq k}{|s[i]|}$，其中$s[i]=\sum\limits_{j=1}^{j\leq i}{g[i]}$，可以这样理解，要让前$k$个人牌数相同，要依次让前$1,2,3…k-1$个人牌数相同，多退少补，会与后边的人发生二者之差绝对值的牌数交换。所以移动总牌数$ans=\sum{|s[i]|}$。

　　再来讲下本题的环形均分纸牌问题：

　　　　环形均分纸牌问题就是$n$个小朋友围成了一圈（等同于第一人和最后一人相邻），这样的话其实可以同样的处理。

　　　　仔细思考环形均分纸牌问题可以发现一个性质：必定至少有两个相邻的人不需要从别人那里获得纸牌（这是显然的，不妨设这两个人的位置为$i$和$i+1$，则环形序列中必定有满足条件$a[i]\leq T\;\;a[i+1]\geq T$的两个相邻位置，这样$a[i],\;a[i+1]$之间没有交换，$a[i]\leq T$可以从$a[i-1]$获得纸牌，$a[i+1]\geq T$可以把多的纸牌给$a[i+2]$）。

　　　　于是由上面的性质，我们直接破环成链，枚举相邻的不需要交换纸牌的两人（将其分别放在第一和最后一个位置）。

　　　　按开始的序列顺序，像普通均分纸牌一样处理出$s$数组，那么假设枚举的位置为$k$，则类比普通均分纸牌求法，新的$s[i]=s[i]-s[k]$（注意$s$为前缀和），于是$ans=\sum{|s[i]-s[k]|}$，我们套用中学数学知识可知当$s[k]$为$s$中位数时，$ans$最小。于是本题就解决了。
    
$\quad$欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/8869948.html)（蒟蒻写题解不易，转载请注明出处）

### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
using namespace std;
const int N=105;
ll n,a[N],sum,s[N];
int main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i],sum+=a[i];
    sum/=n;
    for(int i=1;i<=n;i++)a[i]-=sum,s[i]=s[i-1]+a[i];
    sort(s+1,s+n+1);
    sum=0;
    for(int i=1;i<=n;i++)sum+=abs(s[n/2+1]-s[i]);
    cout<<sum;
    return 0;
}
```

---

## 作者：SofanHe (赞：48)

# 负载平衡问题

# ** 这是一个单节点解决问题的方法! **

[题目链接](https://www.luogu.org/problemnew/show/P4016)

## 题目分析

最终状态每一个仓库的流量一定是平均数.

所以每一个大于平均数的仓库可以向外送东西,每一个小于平均数的仓库必须要从别的进东西.

每次运输都是有代价的,而代价与运输的多少也有直接关系.

自然就是最小费用最大流了.最大流保证了一定能平衡收支,最小费用保证在收支平衡的情况下花费最少了.

## 模型建立

首先先计算出他们的平均数,用每个数都减去平均数得到新的值,这个值如果是负数意味着需要从别的地方搞过一点来,如果正数就说明可以往外送一点.

我们建立超级源点和超级汇点(这套路很常见的)

如果权值为正,即储存量大于平均值,我们就从s向它连一条边,最大流为储存值-平均值,费用为0,图论意义就是它可以从源点免费获得多出来的储存值-平均值的流量,就相当于自身有储存值-平均值的流量,上面不是说了吗,建一个超级源点,就是代替这个功能.

如果权值为负,即储存值小于平均值,我们就从它向t连一条边,最大流量为平均值-储存值,费用为0,图论意义就是它必须从别的节点传来流量,并且汇入自身,意义类比与上面所说.

对于每一个可以互相传的节点,即左邻居和右邻居,需要分别向他们连边,表示自己的流可以流过去.

所以这个图就建完了啊.

并不需要建两个点啊

[单点建图AC评测记录](https://www.luogu.org/recordnew/show/6324774)

## 模型分析

大佬的文章上写的是最小代价供求,我的理解就是有多有少,要搞成平均.

扩展一点就是现在有好多东西都有自己的状态,可以向指定地方调动东西,每次调动都有一个代价,现在需要求最小的代价调成指定状态.

做法就是先算出它要调入/调出多少.

然后对于这个新的值,能够调出的由s向其连边,最大流为能调出的大小,代价为0,图论意义是可以免费获得多少的流以供调出.

需要调入的向t连边,最大流为需要调入的大小,代价为0,图论意义为满足最大流的前提下,它必须从别的地方的得到多少流.

之后对于每一个能调出的节点,向它可以调的地方连一条边,代价为调整的代价.

在这个网络上最小费用最大流就是所要求的答案.

## Code

单节点

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mmax = 1910;
const int Nmax = 210;
const int inf = 20010509;
int n,m,s,t,p1,p2,p3,to[Mmax<<1],net[Mmax<<1],mf[Mmax<<1],mo[Mmax<<1],tails=1,fr[Nmax];
void add(int froms,int tos,int mfs,int money){
    to[++tails]=tos;
    net[tails]=fr[froms];
    mf[tails]=mfs;
    mo[tails]=money;
    fr[froms]=tails;
}
void auto_add(int st,int en,int mft,int mo){
    add(st,en,mft,mo),add(en,st,0,-mo);
}
int lastp[Nmax],useds[Nmax],flown[Nmax],dis[Nmax],ndo,p4;
bool inqu[Nmax];
queue<int>ready;
bool SPFA(){
    memset(inqu,0,sizeof(inqu));
    memset(dis,20010509,sizeof(dis));
    memset(flown,20010509,sizeof(flown));
    while(!ready.empty())ready.pop();ready.push(s);
    dis[s]=0;inqu[s]=1;flown[s]=20010509;lastp[t]=0;
    while(!ready.empty()){
        ndo=ready.front();
        ready.pop();inqu[ndo]=0;
        for(int lzh=fr[ndo];lzh;lzh=net[lzh]){
            if(dis[to[lzh]]>dis[ndo]+mo[lzh] && mf[lzh]){
                dis[to[lzh]]=dis[ndo]+mo[lzh];
                flown[to[lzh]]=min(mf[lzh],flown[ndo]);
                useds[to[lzh]]=lzh;
                lastp[to[lzh]]=ndo;
                if(!inqu[to[lzh]]){
                    inqu[to[lzh]]=1;
                    ready.push(to[lzh]);
                }
            }
        }
    }
    return lastp[t]!=0;
}
int maxflow=0,mincost=0,ppo;
void Dinic(){
    while(SPFA()){
        maxflow+=flown[t];ppo=t;
        mincost+=flown[t]*dis[t];
        while(ppo!=s){
            mf[useds[ppo]]-=flown[t];
            mf[useds[ppo]^1]+=flown[t];
            ppo=lastp[ppo];
        }
    }
}
int x[Nmax],sum;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&x[i]);
        sum+=x[i];
    }
    sum/=n;s=208;t=209;
    for(int i=1;i<=n;++i)	x[i]-=sum;
    for(int i=1;i<=n;++i){
        if(x[i]>0)
            auto_add(s,i,x[i],0);
        else if(x[i]<0)
            auto_add(i,t,-x[i],0);
    }
    for(int i=1;i<=n;++i){
        if(i!=1)
            auto_add(i,(i-1),inf,1);
        if(i!=n)
            auto_add(i,(i+1),inf,1);
    }
    auto_add(1,n,inf,1);
    auto_add(n,1,inf,1);
    Dinic();
    printf("%d",mincost);
    return 0;
}
```

双节点(讲解可以参考楼下大佬)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mmax = 1910;
const int Nmax = 210;
const int inf = 20010509;
int n,m,s,t,p1,p2,p3,to[Mmax<<1],net[Mmax<<1],mf[Mmax<<1],mo[Mmax<<1],tails=1,fr[Nmax];
void add(int froms,int tos,int mfs,int money){
    to[++tails]=tos;
    net[tails]=fr[froms];
    mf[tails]=mfs;
    mo[tails]=money;
    fr[froms]=tails;
}
void auto_add(int st,int en,int mft,int mo){
    add(st,en,mft,mo),add(en,st,0,-mo);
}
int lastp[Nmax],useds[Nmax],flown[Nmax],dis[Nmax],ndo,p4;
bool inqu[Nmax];
queue<int>ready;
bool SPFA(){
    memset(inqu,0,sizeof(inqu));
    memset(dis,20010509,sizeof(dis));
    memset(flown,20010509,sizeof(flown));
    while(!ready.empty())ready.pop();ready.push(s);
    dis[s]=0;inqu[s]=1;flown[s]=20010509;lastp[t]=0;
    while(!ready.empty()){
        ndo=ready.front();
        ready.pop();inqu[ndo]=0;
        for(int lzh=fr[ndo];lzh;lzh=net[lzh]){
            if(dis[to[lzh]]>dis[ndo]+mo[lzh] && mf[lzh]){
                dis[to[lzh]]=dis[ndo]+mo[lzh];
                flown[to[lzh]]=min(mf[lzh],flown[ndo]);
                useds[to[lzh]]=lzh;
                lastp[to[lzh]]=ndo;
                if(!inqu[to[lzh]]){
                    inqu[to[lzh]]=1;
                    ready.push(to[lzh]);
                }
            }
        }
    }
    return lastp[t]!=0;
}
int maxflow=0,mincost=0,ppo;
void Dinic(){
    while(SPFA()){
        maxflow+=flown[t];ppo=t;
        mincost+=flown[t]*dis[t];
        while(ppo!=s){
            mf[useds[ppo]]-=flown[t];
            mf[useds[ppo]^1]+=flown[t];
            ppo=lastp[ppo];
        }
    }
}
int x[Nmax],sum;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&x[i]);
        sum+=x[i];
    }
    sum/=n;s=208;t=209;
    for(int i=1;i<=n;++i)	x[i]-=sum;
    for(int i=1;i<=n;++i){
        if(x[i]>0)
            auto_add(s,2*i-1,x[i],0);
        else if(x[i]<0)
            auto_add(2*i,t,-x[i],0);
    }
    for(int i=1;i<=n;++i){
        if(i!=1){
            auto_add(2*i-1,2*(i-1)-1,inf,1);
            auto_add(2*i-1,2*(i-1),inf,1);
        }
        if(i!=n){
            auto_add(2*i-1,2*(i+1)-1,inf,1);
            auto_add(2*i-1,2*(i+1),inf,1);
        }
    }
    auto_add(1,2*n-1,inf,1);
    auto_add(1,2*n,inf,1);
    auto_add(2*n-1,1,inf,1);
    auto_add(2*n-1,2,inf,1);
    Dinic();
    printf("%d",mincost);
    return 0;
}
```

---

## 作者：Social_Zhao (赞：40)

这玩意出自“网络流24题”？可是。。。好像是贪心啊。

这题的难点主要是列方程：

首先，给没学《数据的分析（八年级下）》就来切此题的巨佬一点注释：

> $\overline{x}_a$ 表示平均数，读作x bá，$\overline{x}_a=\dfrac{a_1+a_2+......+a_n}{n}$
> 
> $m_{0.5}(a_1,a_2,......,a_n)$ 表示一组数据的中位数。文中取$a_{n/2+1}$

设$K_1,K_2,......,K_n$表示第$1,2,......,n$个人给他左边的人的货物数。

*$SP$：$K_1$表示第一个人给第$N$个人的货物数，是个未知数。

$A_1,A_2,......,A_n$表示每人现有的货物数。

则有：

$A_1-K_1+K_2=\overline{x}_A$

故有：

- $K_2=\overline{x}_A+K_1-A_1$

同理可得：

- $K_3=\overline{x}_A+K_2-A_2$


$\begin{cases}K_2=\overline{x}_A+K_1-A_1\\K_3=\overline{x}_A+K_2-A_2\\...\\K_n=\overline{x}_A+K_{n-1}-A_n\end{cases}$

这是一个$n$元$1$次方程，怎么解？

~~暴力！~~ 当然是用代入法消元啊

以$K_3$为例，$K_3=2\overline{x}_A+K_1-A_1-A_2$

我们设$X_i=-i\overline{x}_A+\sum\limits_{j=1}^{i-1}{A_j}$

- $X_2=A_1+A_2-2\overline{x}_A$
- $X_3=A_1+A_2+A_3-3\overline{x}_A$

做差，得：

- $X_3=X_2-\overline{x}_A+A_3$

观察这个式子，我们可以发现一个一般规律：

- $X_i=X_{i-1}-\overline{x}_A+A_i$ - - - - - - - - - - - - - - - - - - - - ①

然后：

- $K_2=K_1-X_1$
- $K_3=K_1-X_2$
- ......
- $K_n=K_1-X_{n-1}$

我们知道：

$ans=\sum\limits_{i=1}^{n}{|K_i|}$

故：

$ans=|K_1-0|+|K_1-X_1|+......+|K_1+X_{n-1}|$

∴$min \{ans\}=min\{|K_1-0|+|K_1-X_1|+......+|K_1+X_{n-1}|\}$

这个式子的几何意义：

在数轴上选择一个$K_1$，使之到$0,X_1,X_2,......,X_{n-1}$的距离之和最小

这就是某个“输油管道问题”【橙题】

这个$K_1$我们要给它赋一个最优值：

这个值就是$m_{0.5}\{0,X_1,X_2,......,X_{n-1}\}$。

证明略

$min \{ans\}=|m-0|+|m-X_1|+......+|m-X_{n-1}|$ - - - - - - ②

使用①和②即可解此题。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=1e6+5;
int a[maxn],x[maxn];
int n;

inline int get()
{
	int x=0;int f=1;char c=getchar();
	while(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }
	while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
	return x*f;
}

signed main()
{
	n=get();
	int x_ba=0;
	for(register int i=1;i<=n;i++) {
		a[i]=get();
		x_ba+=a[i];
	}
	x_ba/=n;
	for(register int i=1;i<=n;i++) {
		x[i]=x[i-1]-a[i]+x_ba;
	}
	sort(x+1,x+1+n);
	int m=x[n/2+1],ans=0;
	for(register int i=1;i<=n;i++) {
		ans+=abs(x[i]-m);
	}
	cout<<ans<<endl;
}
```

---

## 作者：Isprime (赞：24)

网络流24题里混进来的贪心……

见了鬼了 /kk

## 题目分析

建一个源点 $s$ 和汇点 $t$ （他们又来了），每个要运出货物的仓库与 $s$ 连边，每个要运入货物的仓库与 $t$ 连边，容量为要运进/运出货物的数量，花费为 $0$ ,仓库之间依次连容量为 $INF$ ，花费为 $1$ 的边，跑一遍费用流即可

你可能还是不明白这为什么是对的

所以我来给你证明其正确性

以$5\;4\;3\;2\;1$例，建出来的图应该是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/qipha3eu.png)

不难发现，以源点为起点的边容量之和等于以汇点为终点的边容量之和

为什么？因为最终调出了多少货物，就会调入多少货物

这样一来，最大流就一定了，而每条边的花销是 $1$ ，所以满足最小费用最大流就是满足题目条件（最少搬运量）

跑一遍费用流就行了啊

## Code($31$ ms,$800$ KB)

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
const int MAXN = 5001;
const int MAXM = 50001;
const int INf = 2147483647;
int n, m, s, t, edge_sum = 1;
int maxflow, mincost;
int dis[MAXN], head[MAXN], incf[MAXN], pre[MAXN];
int a[MAXN];
bool vis[MAXN];
struct Edge {
	int next, to, dis, flow;
}edge[MAXM << 1];
inline void addedge(int from, int to, int flow, int dis) {
	edge[++edge_sum].next = head[from];
	edge[edge_sum].to = to;
	edge[edge_sum].dis = dis;
	edge[edge_sum].flow = flow;
	head[from] = edge_sum;
}
inline bool spfa() {
	queue <int> q;
	memset(dis, 0x3f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	q.push(s);
	dis[s] = 0;
	vis[s] = 1;
	incf[s] = 1 << 30;
	while(!q.empty()) {
		int u = q.front();
		vis[u] = 0;
		q.pop();
		for(register int i = head[u]; i; i = edge[i].next) {
			if(!edge[i].flow) continue;
			int v = edge[i].to;
			if(dis[v] > dis[u] + edge[i].dis) {
				dis[v] = dis[u] + edge[i].dis;
				incf[v] = min(incf[u], edge[i].flow);
				pre[v] = i;
				if(!vis[v]) vis[v] = 1, q.push(v);
			}
		}
	}
	if(dis[t] == 1061109567) return 0;
	return 1;
}
inline void MCMF() {//费用流板子
	while(spfa()) {
		int x = t;
		maxflow += incf[t];
		mincost += dis[t] * incf[t];
		int i;
		while(x != s) {
			i = pre[x];
			edge[i].flow -= incf[t];
			edge[i^1].flow += incf[t];
			x = edge[i^1].to;
		}
	}
}
signed main() {
	scanf("%d", &n);
	int sum = 0;
	for(register int i = 1; i <= n; ++i) scanf("%d", a + i), sum += a[i];
	sum /= n;//算出平均值
	for(register int i = 1; i <= n; ++i) {
		if(a[i] < sum) {//如果需要运入就与s连边
			addedge(0, i, sum - a[i], 0);
			addedge(i, 0, 0, 0);
		} else if(a[i] > sum) {//如果需要运出就与t连边
			addedge(i, n + 1, a[i] - sum, 0);
			addedge(n + 1, i, 0, 0);
		}
		if(i == 1) {//特判1,别忘了是无向图
			addedge(1, n, INf, 1);
			addedge(n, 1, 0, -1);
			addedge(n, 1, INf, 1);
			addedge(1, n, 0, -1);
		} else {
			addedge(i-1, i, INf, 1);
			addedge(i, i-1, 0, -1);
			addedge(i, i-1, INf, 1);
			addedge(i-1, i, 0, -1);
		}
	}
	s = 0, t = n + 1;
	MCMF();
	printf("%d\n",mincost);
	return 0;
}
```

所以，点个赞啊

---

## 作者：Celebrate (赞：16)

## 前言：

楼下的大佬有的用双节点来解决，但是我觉得没有必要，所以

就用单节点来做了

我在一位大佬的博客

https://blog.csdn.net/zhangjianjunab

学的ZKW费用流

## 思路以及构图：

首先定义一个超级原点st，一个超级汇点ed

一开始每个地方的值不等，所以

从st建边到每一个地方，流量为一开始的存货量，费用为0（不会在这些地方花费）

从每一个地方建边到ed，流量为平均值（仓库最后必须容纳的货量），费用也为0，同上

因为是无向图，所以两个地方建边要建双向边，流量为+OO（因为可能会有很多来自世界各地的流量通过这条路），单位流量的费用为1

图就建立完毕了，和楼下大佬的构图有些不一样，但是感觉这个图比较好理解，也可以很好的避免无向图容易出现的后效性

## 代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
struct node
{
	int  y,c,d,next,other;
}a[21000];int len,last[210];
void  ins(int  x,int  y,int  c,int  d)//建边 
{
	len++;int k1=len;
	a[len].y=y;a[len].c=c;a[len].d=d;
	a[len].next=last[x];last[x]=len;
	
	len++;int k2=len;
	a[len].y=x;a[len].c=0;a[len].d=-d;//反向边，后悔的机会 
	a[len].next=last[y];last[y]=len;
	
	a[k1].other=k2;
	a[k2].other=k1;
}
int cost,d[210];
int head,tail,list[210];
bool v[210];
int st,ed;
int n,sum;
bool spfa() 
{
	memset(d,20,sizeof(d));d[ed]=0;//从后往前找会更快 
	memset(v,true,sizeof(v));v[ed]=false;
	head=1;tail=2;list[head]=ed;
	int  inf=d[ed+1];
	while(head!=tail)
	{
		int  x=list[head];
		for(int  k=last[x];k;k=a[k].next)
		{
			int  y=a[k].y,kl=a[k].other;
			if(a[kl].c>0  && d[y]>d[x]-a[k].d)//反向边流量为负数，所以要减去 
			{
				d[y]=d[x]-a[k].d;
				if(v[y]==true)
				{
					v[y]=false;
					list[tail++]=y;
					if(tail==n+1)tail=1;
				}
			}
		}
		head++;if(head==n+1)head=1;
		v[x]=true;
	}
	return  d[st]!=inf;//判断是否可以到达 
}
inline int mymin(int x,int y){return x<y?x:y;}
int find(int x,int f)//查找最大流，顺便找出费用 
{
	v[x]=false;
	if(x==ed){v[x]=true;return f;}
	int  ans=0,t=0;
	for(int  k=last[x];k;k=a[k].next)
	{
		int  y=a[k].y;
		if(a[k].c>0 && d[y]==d[x]-a[k].d && v[y]==true && ans<f)
		{
			ans+=t=find(y,mymin(a[k].c,f-ans));
			a[k].c-=t;a[a[k].other].c+=t;
			
			cost+=t*a[k].d;
		}
	}
	v[x]=true;
	return  ans;
}
int  main()
{
	scanf("%d",&n);st=0;ed=n+1;
	for(int i=1;i<=n;i++)
	{
		int x;scanf("%d",&x);
		int l=i-1,r=i+1;//对左右两边建边 
		if(l==0)l=n;//特判环 
		if(r==n+1)r=1;
		ins(i,l,999999999,1);ins(i,r,999999999,1);ins(st,i,x,0);
		sum+=x;
	}
	sum/=n;
	for(int i=1;i<=n;i++)ins(i,ed,sum,0);
	int ans=0;n+=2;//n加上起点和终点 
	while(spfa()==true)find(st,999999999);
	printf("%d\n",cost);
	return  0;
}
```


---

## 作者：KSkun (赞：16)

本题解同时发布于我的个人博客，欢迎来逛[网络流24题题解 | KSkun's Blog](https://ksmeow.moe/graph_flow_24prob_sol/)。

2019/10/10 UPD：修正了表述错误和博客地址错误，同时改进格式，感谢@qieqiemin 指出问题所在。


## 思路

这个题解的思路来自hzwer，这是[他的博客](http://hzwer.com/1955.html)。

我们对每个仓库创建两个节点$X_i$和$Y_i$，前者为供应节点，后者为需求节点。求出最终要达到的货物值即平均数，然后把初始值处理成偏移值（初始值-平均数）。


1. **偏移小于0。** 表明这个节点需要运入货物，将节点的$Y_i$与汇点$T$相连，容量为偏移的绝对值，费用为0。

2. **偏移大于0。** 表明这个节点需要运出货物，将节点的$X_i$与源点$S$相连，容量为偏移，费用为0。


然后再考虑相邻节点的关系。


1. **相邻节点互相补充。** 将$X_i$与$Y_j$相连，容量为$+ \infty$，费用为1，表示运输单位货物需要1的费用。

2. **不是直接补充，而是作为中间节点转运。** 将$X_i$与$X_j$相连，容量为$+ \infty$，费用为1，意义同上。


以以上方式建图跑最小费用最大流即可。最大流保证能够平衡货物，而最小费用流能保证运输的货物最少。


## 代码

```cpp
// Code by KSkun, 2018/1
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
#include <algorithm>
#include <utility>

struct io {
    char buf[1 << 26], *s;
    
    io() {
        fread(s = buf, 1, 1 << 26, stdin);
    }
    
    inline int read() {
        register int res = 0;
        while(*s < '0' || *s > '9') s++;
        while(*s >= '0' && *s <= '9') res = res * 10 + *s++ - '0';
        return res;
    }
} ip;

#define read ip.read

const int MAXN = 1005;
const int INF = 1e9;

struct Edge {
    int to, cap, cost, rev;
    Edge(int to, int cap, int cost, int rev): to(to), cap(cap), cost(cost), rev(rev) {}
};

std::vector<Edge> vec[MAXN];
std::queue<int> que;
int f[MAXN];
int pre[MAXN], pree[MAXN], dis[MAXN];
bool inque[MAXN];

inline void addedge(int u, int v, int cap, int cost) {
    vec[u].push_back(Edge(v, cap, cost, vec[v].size()));
    vec[v].push_back(Edge(u, 0, -cost, vec[u].size() - 1));
}

// SPFA Min Cost Flow

int flow = 0, cost = 0;

inline void min_cost_flow(int s, int t) {
    for(;;) {
        memset(f, 0, sizeof f);
        memset(dis, 0x3f, sizeof dis);
        memset(inque, 0, sizeof inque);
        while(!que.empty()) que.pop();
        que.push(s);
        dis[s] = 0;
        inque[s] = true;
        f[s] = INF;
        while(!que.empty()) {
            int u = que.front();
            que.pop();
            inque[u] = false; 
            for(int i = 0; i < vec[u].size(); i++) {
                int v = vec[u][i].to;
                if(vec[u][i].cap > 0 && dis[v] > dis[u] + vec[u][i].cost) {
                    pre[v] = u;
                    pree[v] = i;
                    f[v] = std::min(vec[u][i].cap, f[u]);
                    dis[v] = dis[u] + vec[u][i].cost;
                    if(!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        if(f[t] == 0) break;
        for(int u = t; u != s; u = pre[u]) {
            vec[pre[u]][pree[u]].cap -= f[t];
            vec[u][vec[pre[u]][pree[u]].rev].cap += f[t];
        }
        flow += f[t];
        cost += f[t] * dis[t];
    }
}

int n, remain[1005], sum = 0, s, t; 

int main() {
    n = read();
    s = n * 2 + 1;
    t = s + 1;
    for(int i = 1; i <= n; i++) {
        remain[i] = read();
        sum += remain[i];
    }
    sum /= n;
    for(int i = 1; i <= n; i++) {
        remain[i] -= sum;
        if(remain[i] < 0) {
            addedge(i + n, t, -remain[i], 0);
        } else {
            addedge(s, i, remain[i], 0);
        }
        if(i - 1 > 0) {
            addedge(i, i - 1, INF, 1);
            addedge(i, i - 1 + n, INF, 1);
        }
        if(i + 1 <= n) {
            addedge(i, i + 1, INF, 1);
            addedge(i, i + 1 + n, INF, 1);
        }
    }
    addedge(1, n, INF, 1);
    addedge(1, n << 1, INF, 1);
    addedge(n, 1, INF, 1);
    addedge(n, 1 + n, INF, 1);
    min_cost_flow(s, t);
    printf("%d", cost);
    return 0;
}
```

---

## 作者：Mark_ZZY (赞：11)

关于构图：

首先，这是一道最小费用（费用指在两个相邻仓库中的运输单价）最大流的题目。

1.必不可少的有一个超级源点和汇点，st=0,ed=n+1。

2.贪心的想，为了是所有仓库的数量都相等，就应该讲多余平均值的仓库运往少于平均值的仓库，自然而然就想到多的仓库应该贡献，连向源点；少的仓库应该得到，连向汇点，且费用为0（因为费用指在两个相邻仓库中的运输单价）。

3.另外，相邻的节点之间也要建边，对于两个相邻的节点，我们应该连上一条流量为INF（可以无限运输），费用为1的边，因为是无向图，所以应该建双向边，注意：还要建反向边（不理解）。

4.注意：本题为环，所以1号节点与n号节点还应特殊处理（参照3）。

附上代码：
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<queue>
#include<algorithm>
#define INF 2147483647
using namespace std;
queue<int> f;
	int n,m,len=0,st,ed;
	struct node{int x,y,c,d,next;} a[10000];
	int b[10000],last[10000],dis[10000],pre[10000],pos[10000],p[10000];
	bool bz[10000];
void ins(int x,int y,int c,int d)
{
	a[len].x=x;a[len].y=y;a[len].c=c;a[len].d=d;a[len].next=last[x];last[x]=len++;
}
bool spfa()
{
	memset(bz,true,sizeof(bz));
	bz[st]=false;
	memset(dis,63,sizeof(dis));
	dis[st]=0;
	p[st]=INF;
	f.push(st);
	while(!f.empty())
	{
		int x=f.front();
		bz[x]=true;
		for(int i=last[x];i!=-1;i=a[i].next)
		{
			int y=a[i].y;
			if(a[i].c>0&&dis[y]>dis[x]+a[i].d)
			{
				dis[y]=dis[x]+a[i].d;
				pos[y]=x;
				pre[y]=i;
				p[y]=min(p[x],a[i].c);
				if(bz[y])
				{
					f.push(y);
					bz[y]=false;
				}
			}
		}
		f.pop();
	}
	return dis[ed]<1061109567;
}
int flow()
{
	int ans=0;
	while(spfa())
	{
		ans+=p[ed]*dis[ed];
		for(int i=ed;i!=st;i=pos[i])
		{
			a[pre[i]].c-=p[ed];
			a[pre[i]^1].c+=p[ed];
		}
	}
	return ans;
}
int main()
{
	int sum=0;
	scanf("%d",&n);
	st=0;ed=n+1;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		sum+=b[i];
	}
	sum/=n;
	memset(last,-1,sizeof(last));
	for(int i=1;i<=n;i++)
		if(b[i]>sum)
			ins(st,i,b[i]-sum,0),ins(i,st,0,0);
		else
			ins(i,ed,sum-b[i],0),ins(ed,i,0,0);
	for(int i=2;i<=n;i++)
	{
		ins(i-1,i,INF,1),ins(i,i-1,0,-1);
		ins(i,i-1,INF,1),ins(i-1,i,0,-1);
	}
	ins(1,n,INF,1),ins(n,1,0,-1);
	ins(n,1,INF,1),ins(1,n,0,-1);
	printf("%d",flow());
}
```

---

## 作者：听取MLE声一片 (赞：10)

Uplate：最后的方向变容量写错了

既然这道题的分类是 **网络流24题** ，我这个蒟蒻就贡献一片网络流的题解。

万物皆可网络流（滑稽）。

## 前置芝士：网络流

极其推荐这位神仙的 [网络流日报](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)，不会的同学可以去学习一下。

学习完成之后再做一下 [最小费用最大流](https://www.luogu.com.cn/problem/P3381) 的模板就可以去切掉这道题了。

## 本题讲解

如果您认真学习网络流并对网络流有初步了解，就会知道网络流题目主要考察的是 **建图能力** ，就是您把图建出来就能切掉。

### 第一步，确认起点与终点。

我们发现，这些箱子都是一样的，没有突出的点，所以我们就要创  **超级起点和超级终点** ，通俗点说就是把起点设为 `0` ,重点设为 `n+1` 就行了。

### 第二步，把权值连上：

通过实际意义可得，从起点忘每个仓库连一条 **容量为库存，费用为0** 的边，就可以很容易地把库存送到每个仓库里。

参考代码：

```
	for(int i=1;i<=n;i++){
	    c[i]=read();
	    sum+=c[i];
	    add(s,i,c[i],0);
	    add(i,s,0,0);
	}
```

### 第三步，仓库之间连线：

由于每个仓库都可以往 **两遍相邻的仓库** 送货,就是把每两个仓库之间连一条**无向边**，**容量为inf，费用为1**，这样就可以进行分配了。

注意：`1` 与 `n` 之间的连线要特殊处理一下

参考代码：

```
	for(int i=1;i<n;i++){
	    add(i,i+1,inf,1);
	    add(i+1,i,0,-1);
	    add(i+1,i,inf,1);
	    add(i,i+1,0,-1);
	}
	add(1,n,inf,1);
	add(n,1,0,-1);
	add(n,1,inf,1);
	add(1,n,0,-1);

```

### 第四步，仓库与终点连线。

把每个仓库向终点连一条 **容量为平均数，费用为0** 的边，可以将每个仓库的容量 **强制限制到平均数**。又因为最小费用最大流求的是 **在到达终点数量最多时** 的最小费用，就可以顺理成章地求出结果。

平均数可以在输入中求解，我用 `sum` 表示了。

参考代码：

```
	for(int i=1;i<=n;i++){
		add(i,t,sum,0);
		add(t,i,sum,0);
	}
```

## 全部代码：

~~因为数据范围很小所以我就用了 `EK` 无伤大雅~~

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>

using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int inf=2147483647;
int maxn,cost;
int top=1,head[5001];
int dis[5001];
int n,m,s,t,book[5001],c[5001];
struct point{
    int v,w,val,next;
}a[100001];
struct b{
    int fa;
    int v;
}b[5001];
inline void add(int u,int v,int val,int w){
    a[++top].v=v;
    a[top].val=val;
    a[top].w=w;
    a[top].next=head[u];
    head[u]=top;
}
bool spfa(){
	queue<int> q;
    memset(b,0,sizeof(b));
    memset(book,0,sizeof(book));
    for(int i=0;i<=t;i++)
    	dis[i]=inf;
    dis[s]=0;
    q.push(s);
    book[s]=1;
    while(!q.empty()){
        int u=q.front();
        book[u]=0;
        q.pop();
        for(int i=head[u];i;i=a[i].next){
            int v=a[i].v,w=a[i].w;
            if(a[i].val>0&&dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                b[v].fa=u,b[v].v=i;
                if(book[v]==0){
                    q.push(v);
                    book[v]=1;
                }
            }
        }
    }
    return dis[t]!=inf;
}
void EK(){
    while(spfa()){
        int minn=inf;
        for(int i=t;i!=s;i=b[i].fa)
			minn=min(minn,a[b[i].v].val);
        for(int i=t;i!=s;i=b[i].fa){
            a[b[i].v].val-=minn;
            a[b[i].v^1].val+=minn;
        }
        maxn+=minn;
        cost+=minn*dis[t];
    }
    return;
}
int main()
{
	int sum=0;
    n=read();
    s=0,t=n+1;
    for(int i=1;i<=n;i++){
    	c[i]=read();
    	sum+=c[i];
        add(s,i,c[i],0);
        add(i,s,0,0);
    }
    sum/=n;//求平均数
    for(int i=1;i<n;i++){
    	add(i,i+1,inf,1);
    	add(i+1,i,0,-1);
    	add(i+1,i,inf,1);
    	add(i,i+1,0,-1);
	}
	add(1,n,inf,1);
	add(n,1,0,-1);
	add(n,1,inf,1);
	add(1,n,0,-1);
	for(int i=1;i<=n;i++){
		add(i,t,sum,0);
		add(t,i,0,0);
	}
    EK(); 
    cout<<cost;
    return 0;
}
```
谢谢大家！

---

## 作者：天南星魔芋 (赞：7)

今天写 $P2512$ $[HAOI2008]$ 糖果传递了，于是走推荐来看这道题。

------------

核心算法:贪心，三分。

（虽然题目没标三分但我还是用了。

我们先看题:


* 有 $n$ 个环形排列的仓库，每个仓库存储的货物数量不等。

* 用最少搬运量可以使 $n$ 个仓库的库存数量相同。

* 搬运货物只能在相邻的仓库之间搬运。

等等，怎么有点像  [均分纸牌 ](https://www.luogu.com.cn/problem/P1031) ？

方法我就不多说了，不会的话看一下它的[题解](https://www.luogu.com.cn/problem/solution/P1031)。


但想一想，均分纸牌是线性的，这题是环形的；

所以这两题区别是此题首尾之间有货物传输；

故我们可以枚举一号仓库与 $N$号仓库之间的货物传输量来得到正解。

但数据可能很大，暴力枚举会 ~~时间充裕~~  $TLE$ 掉；

这时候就要用三分了。

我们看均分纸牌中的方法；



```cpp
	jl=0;ans=0;
	for(int i=1;i<=n;i++){
		jl=jl+a[i]-sum;
		ans+=abs(jl);
	}
```

这是 $jl$ 初始为零时（也就是链）的做法；

我们发现 $ans$ 每次加上 $jl$ 的绝对值；

用图形表示的话就是 $jl$ 到 直线 $y=0$ 的距离；

![](https://i.loli.net/2020/10/27/FrJXCg8uRjnUapA.png)

其中 $x$ 为循环中的 $i$ ，$y$ 为 $jl$ 。

这是初始值为 $0$ 的情况，若初始值为 $1$ 则有下图：

![](https://i.loli.net/2020/10/27/u2UyistLEao3XN1.png)

用数表示呢？

就是 一号仓库与 $N$ 号仓库的传输量(有方向)

而且对于函数  $ans=f(x)$  $x$ 是 $jl$ 的初始值，

它是单凹峰的  如图下:


![](https://i.loli.net/2020/10/27/4as89MgEDrKZWPY.png)


所以我们可以用三分求解。

三分函数解法:

* 先找出函数最值两侧的点，各一个。我们可以开个很大的数 $maxn，minn$。
* 在逐步枚举，每次计算两点平均值 $ans$ 的函数值和 $ans+1$ 的函数值。
* 比较若两点平均值的函数值更大将 $minn$ 调到 $ans$ ，否则将 $maxn$ 调到  $ans+1$ 。
* 重复以上两步，直到 $maxn-minn<5$ 。
* 剩下的用暴力枚举 。
* 最后得出来的就是答案了。


下面就见代码吧:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//我开  long long 了 
int a[1000005];
int n;
int jl=0;
int ans=0;//答案  储存计算 abs(jl)  的值
int anss=0;//储存计算 abs(jl+1)  的值  
int cs;
int sum=0;//计算平均值 
int minn=-4000000000000,maxn=4000000000000;//两个很大的数 
//---------------------// 绝对值函数 
int abss(int x){      // 
	return x>0? x:-x;// 三目运算符  a 比较 b 如果为真 c  :  否则   d 
}                   //
//-----------------// 
//-------------------------------// 计算初始值为 s 时的 ans 和初始值为 s+1 时的 anss 
int js(int s){                  // 
	jl=s;ans=0;anss=0;         // 
	for(int i=1;i<=n;i++){    // 
		jl=jl+a[i]-sum;      // 
		ans+=abss(jl);      // 
		anss+=abss(jl+1);  // 
	}                     // 
	if(ans<anss)return 0;// 
	else return 1;      // 
}                      //
//--------------------// 
signed main(){// int 表示 long long 故 main 要用 signed  
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	sum/=n;//平均值 
	while(maxn-minn>5){//三分 
		cs=(maxn+minn)/2;
		if(js(cs)==1)minn=cs;
		else maxn=cs+1;
	}
	int mmin=400000000000000000;//精度修正 
	for(int i=minn;i<=maxn;i++){
			js(i);
		mmin=min(mmin,ans);
	}
	cout<<mmin<<endl;//答案 
}
```

大家可能对我 数组 $a$ 开很大不理解。

其实它的范围恰好符合 [糖果传递](https://www.luogu.com.cn/problem/P2512) 的。

也就是说，这篇题解也可过糖果传递。

这篇题解就到这里了，

我还没写过几次，有不到之处请多多指教。







---

## 作者：char32_t (赞：6)

# P4016 【负载平衡问题】
------------
解法：

该题目的所用的是贪心法。先让第一个仓库的货物达到平均数，只交换1、2两个仓库的货物，然后让第二个仓库的货物达到平均数......直到最后一个仓库。实际移动时是从货物数最多的仓库开始移动，从第一个开始移动可能存在货物不够给的情况，那就暂且存为负数，直到遇到货物数很多的那一个仓库（超过平均数）把负数全部补齐。

## 但是，为什么会是贪心题呢？

以下文字引自**知乎**（有改动）


1、假设货物数量可以是负数

2、对于最左边的货物，为了使它的货物数达到平均，只要还没有达到平均无论其余子情况如何移动，一定有一步是把自己多余的货物移动到右边，或者是从右边移动进来自己差了多少个货物

3、第一个仓库只有和右边进行交互是合法的，步骤1是必须的

4、处理好第一个后，其余操作一定不涉及第一个，否则答案更劣（经过前一个是没有意义的）

5、无视第一个，于是现在又是情况2了（子结构）

6、对于一个会出现负数的方案，通过调整移动顺序，一定可以转变为一个不出现负数的方案。

Code：

```cpp
    #include<cstdio>
    #include<algorithm>//sort头文件
    #include<cmath>//绝对值函数头文件
    #define _max 1000010
    long long int all, ans=0;//要用long long int
    int a[_max], c[_max];
    int main() {
        int n;
        scanf("%d", &n);
        for(int i=1; i<=n; i++) {
            scanf("%d",&a[i]);//读入数据
            all+=a[i];//计算总和
        }
        all/=n;//求得平均值
        for(int i=1; i<n; i++) c[i]=c[i-1]+a[i]-all;
        std::sort(c, c+n);//排序
        long long int k=c[n/2];
        for(int i=0; i<n; i++) ans+=fabs(k-c[i]);//数学推导：将每个仓库中的货物数变为数列的中位数时，所需的代价最小
        printf("%lld", ans);//输出答案
        return 0;
}
```

---

## 作者：Priori_Incantatem (赞：4)

这题的建模比较有意思，但还是挺简单的

首先，因为一个点可以直接运货到与他它相邻的两点，所以每个点$i$先与点$i-1,i+1$建边，流量为一个极大值，费用为$1$

每个点最终的货物数量是货物量总和除以$n$，我们设这个最终的数量为$tot$

接下来：如果一个点$i$的货物数量大于$tot$，说明这个点的货物要往外运，所以让超级源点$S$向$i$连一条流量为$a[i]-tot$，费用为$0$的边  
如果一个点$i$的货物数量小于$tot$，说明外面的货物要运进来，所以让点$i$向超级汇点$T$连一条流量为$tot-a[i]$，费用为$0$的边

若一个点的货物数量刚好等于$tot$，说明它根本不需要进货或运货，只需要当一个中转站就可以了，所以不和$S,T$连边

这样，送出的货物都从点$S$送出，而全部流向点$T$，就化为了最小费用最大流问题。

#### 剩下的就是跑模板啦！

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int Maxn=110,Maxm=1020,inf=0x3f3f3f3f;
int nxt[Maxm],to[Maxm],flow[Maxm],cost[Maxm];
int cur[Maxn],dis[Maxn],head[Maxn],a[Maxn];
int pre[Maxn];
bool vis[Maxn];
int n,s,t,edgecnt=1,ans,tot;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
inline void add(int x,int y,int c,int v)
{
	++edgecnt;
	nxt[edgecnt]=head[x];
	to[edgecnt]=y;
	flow[edgecnt]=c;
	cost[edgecnt]=v;
	head[x]=edgecnt;
}
bool spfa()
{
	queue <int> q;
	memset(dis,inf,sizeof(dis));
	memset(cur,inf,sizeof(cur));
	vis[s]=1,dis[s]=0,q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(!flow[i])continue;
			if(dis[y]>dis[x]+cost[i])
			{
				dis[y]=dis[x]+cost[i];
				pre[y]=i,cur[y]=min(cur[x],flow[i]);
				if(!vis[y])vis[y]=1,q.push(y);
			}
		}
	}
	if(dis[t]==inf)return 0;
	return 1;
}
void upd()
{
	int x=t;
	while(x!=s && x)
	{
		int i=pre[x];
		flow[i]-=cur[t];
		flow[i^1]+=cur[t];
		x=to[i^1];
	}
	ans+=dis[t]*cur[t];
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read();
	s=0,t=n+1;
	for(int i=1;i<=n;++i)
	{
		tot+=(a[i]=read());
		//与相邻的点连边
		if(i==1)
		{
			add(1,2,inf,1);
			add(2,1,0,-1);
			add(1,n,inf,1);
			add(n,1,0,-1);
		}
		else if(i==n)
		{
			add(n,n-1,inf,1);
			add(n-1,n,0,-1);
			add(n,1,inf,1);
			add(1,n,0,-1);
		}
		else
		{
			add(i,i+1,inf,1);
			add(i+1,i,0,-1);
			add(i,i-1,inf,1);
			add(i-1,i,0,-1);
		}
	}
	tot/=n;
	for(int i=1;i<=n;++i)
	{
		if(a[i]>tot)
		{
			add(s,i,a[i]-tot,0);
			add(i,s,0,0);
		}
		if(a[i]<tot)
		{
			add(i,t,tot-a[i],0);
			add(t,i,0,0);
		}
	}
	while(spfa())upd();
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：2)

再见费用流，我是 MOer.

#### 这里提供思路，式子请自行推倒或参考代码

注意到货物总数不变，所以每个库最后拥有的货物数确定，则每个库要转出或转入的货物数一定。

又因为每个库只能和两个库交易，故确定和一个库的交易之后就可确定与另一个库的交易。

我们又推广发现，只要确定任意一组相邻两库的交易，其它所有交易都可确定。

所以交易总额就是个一元函数！

推式子发现这是个绝对值函数，于是我们利用初一数学中绝对值的几何意义可求得最小值。

式子就不推了，大概就是列 $n-1$ 个线性方程再用点错位相减。

代码里有一些详细式子和绝对值函数最值求法

```cpp
//coder: FeliksGM-YB
#include<bits/stdc++.h>
#define fu(i,a,b) for(int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(int i = a, I = (b) - 1; i > I; --i)
typedef long long ll;
using namespace std;
const int N=1e6+5;
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}template <class T> inline void read(T &x) {
    x=0;T f=1;char ch=getchar();
    while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    x*=f;
}int n;
ll a[N],avg,ans;//avg: 平均数 
ll sum[N];//a 数组前缀和 
ll x[N];//x[i] = -i * avg + sum[i]
//令 k[i] 表示每个人定向转出金币数
//推出 k[i] = k[1] - x[i-1]
//绝对值函数最小值，变量为 k[1]，利用几何意义：
//k[1] 到 x[i] (1 <= i < n) 和 0 的距离之和
ll m;//表示 k[1]
//初一数学，取中位数即可 
int main(){
	avg=ans=0;
	fu(i,1,n)read(a[i]),avg+=a[i],sum[i]=sum[i-1]+a[i];
	avg/=n;
	fu(i,1,n-1)x[i]=sum[i]-i*avg;//求 x[i]
	x[n]=0;//大部分题解里都把这句直接去掉而上一步循环到 n, 效果一样
	//但其实意义有差别，这导致我看了半天（主要因为我太菜QwQaQ） 
	nth_element(x+1,x+(n+1>>1),x+n+1);//nth_element找中位数，快一点 
	m=x[n+1>>1];//取中位数，得绝对值函数最小值取到的点 
	fu(i,1,n)ans+=abs(m-x[i]);//求最小值 
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Jayun (赞：2)

[可能更好的阅读](https://www.cnblogs.com/GJY-JURUO/p/12231032.html)

---

# 题目大意：

有$n$个仓库，要把所有仓库的存库数统一，问一共要搬多少物品。

# 正文：

首先这是费用流。

要统一存库数，统一的存款数就是所有存库数的平均值，那就是说，如果存库数小于平均值就要进货，如果存库数大于平均值就要出货。

那我们就把每个仓库作两份（假设对于第$i$个仓库，两份分别是 $a_{i_A}$ 和 $a_{i_B}$），样例如图：

![图1](https://s2.ax1x.com/2020/01/23/1VZdoD.png)

如果要进货，$A$ 和源点 $S$ 连接，否则 $B$ 和汇点 $T$ 连接，费用是 $|\text{存库数-平均值}|$，样例如图：

![图2](https://s2.ax1x.com/2020/01/23/1VQy4K.png)

横线上是费用。

题目中说，"$G$ 公司有 $n$ 个沿铁路运输线 **环形排列** 的仓库"，相邻的结点是相连的，样例如图：

![图3](https://s2.ax1x.com/2020/01/23/1VQ4HI.png)

详见代码。

# 代码：

```cpp
for (int i = 1; i <= n; i++)
{ 
	scanf("%d", &x[i]);
	sum += x[i];
}
sum /= n;       // 取平均值
for (int i = 1; i <= n; i++)
{
	x[i] -= sum;
	if(x[i] < 0)                 //和源点和汇点连线
	{
		Add(i + n, t, -x[i], 0);
	} 
	else 
	{
		Add(s, i, x[i], 0);
	}
	if(i - 1 > 0)              //以下互相连线
	{
		Add(i, i - 1, INF, 1);
		Add(i, i + n - 1, INF, 1);
	}
	if(i + 1 <= n)
	{
		Add(i, i + 1, INF, 1);
		Add(i, i + 1 + n, INF, 1);
	}
}
Add(1, n, INF, 1);
Add(1, n << 1, INF, 1);
Add(n, 1, INF, 1);
Add(n, 1 + n, INF, 1);
MCMF();     //费用流
printf("%d\n", mincost);
```

---

## 作者：hicc0305 (赞：2)

作为一道网络流24题，当然是用网络流，而显然是用最小费用最大流，那么问题就在如何建图了。。。建完了就上裸的EK就可以了。。

那么，要使所有的仓库货物都一样显然，货物数量大于平均值的要运出，小于平均值的就运入。对于大于平均值的，我们就和s连边，小于的就和t连边（当然反过来是一样的）。流量就是货物数量和平均值的差，也就是还需要运出或运入多少。费用为0，因为s和t本来就是超级源和超级汇，是新加的，我们只是借来表示一下关系而已，并不需要花费。

当然，对于相邻的点我们也需要建边，建的边流量为inf，因为可以随便运多少，费用就是1了。

#### 注意，图为无向图，正着反着都要建边。

那为什么要这么建图哪？显然，大于平均值的点流向小于平均值的点，不正是往小于平均值的点运货物么，每一条选入最大流的边u->v就是u往v运货物

## 代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int inf=100000000;
double avr=0;
int n,s,t,cnt=-1;
int a[100100];
int head[100100],nxt[100100],to[100100],val[100100],w[100100];
int del[100100],q[100100],dis[100100],f[100100],pre[100100];
void addedge(int x,int y,int z,int k)
{
	cnt++;
	nxt[cnt]=head[x];
	head[x]=cnt;
	to[cnt]=y;
	w[cnt]=z;
	val[cnt]=k;
}
bool spfa()
{
	memset(f,0,sizeof(f));
	memset(dis,-1,sizeof(dis));
	q[1]=s,dis[s]=0,f[s]=1,del[s]=0x7fffffff;
	int l=0,r=1;
	while(l<r)
	{
		int u=q[++l];
		for(int i=head[u];i!=-1;i=nxt[i])
		{
			int v=to[i];
			if((dis[v]>dis[u]+val[i] || dis[v]==-1) && w[i])
			{
				dis[v]=dis[u]+val[i];
				del[v]=min(del[u],w[i]),pre[v]=i;
				if(!f[v])
				{
					f[v]=1;
					q[++r]=v;
				}
			}
		}
		f[u]=0;
	}
	return dis[t]!=-1;
}
int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d",&n);
	s=0,t=n+1;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),avr+=a[i];
	avr/=n;
	for(int i=1;i<=n;i++)
	{
		if(a[i]>avr)addedge(s,i,a[i]-avr,0),addedge(i,s,0,0);
		else addedge(i,t,avr-a[i],0),addedge(t,i,0,0);//和s，t连边
		int j=i+1,k=i-1;
		if(i==n) j=1;
		if(i==1) k=n;
		addedge(i,j,inf,1),addedge(j,i,0,-1);
		addedge(i,k,inf,1),addedge(k,i,0,-1);//和相邻的点连边
	}
	int res=0;
	while(spfa())//EK
	{
		res+=dis[t]*del[t];
		int tmp=t;
		while(tmp!=s)
		{
			w[pre[tmp]]-=del[t];
			w[pre[tmp]^1]+=del[t];
			tmp=to[pre[tmp]^1];
		}
	}
	printf("%d",res);
	return 0;
}
```

---

## 作者：jun头吉吉 (赞：1)

# P4016 负载平衡问题
## SOLUTION 1·网络流方法
很明显，我们发现，对于某个仓库，它向左右两个节点输送货物，对答案的贡献就等于 搬运量$\times1$，因此我们可以用某个节点分别向左右两个仓库连一个$\begin{cases}cost_i=1\\ flow_i=+\infty \end{cases}$的边,即费用为$1$，可以无限制运输运输

对于存量为$a_i$的仓库，**源点$S$** 可以与他链接一条$\begin{cases}cost_i=0\\ flow_i=a_i \end{cases}$的边，并向**汇点$T$** 连接一条$\begin{cases}cost_i=0\\ flow=\dfrac {sum}n \end{cases}$的边，跑一遍最小花费最大流就可以了

### 正确性
很明显，当我们取最大流时，每个仓库通向**汇点$T$** 必定是饱和弧，此时的花费只有仓库之间会产生，就为搬运的数量，那么最小花费有保证了其最小，因此本方法构造的图是成立的
```cpp
//#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){
	    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;
	}
	template <typename T>inline void read(T& t){
	    t=0;int f=0;char ch=getc();
	    while (!isdigit(ch)){
	        if(ch=='-')f = 1;
	        ch=getc();
	    }
	    while(isdigit(ch)){
   	    	t=t*10+ch-48;
   	    	ch = getc();
   		}
		if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){
	    read(t);read(args...);
	}
}
namespace out{
	char buffer[1<<21];
	int p1=-1;
	const int p2 = (1<<21)-1;
	inline void flush() {
		fwrite(buffer,1,p1+1,stdout),
		p1=-1;
	}
	inline void putc(const char &x) {
		if(p1==p2)flush();
		buffer[++p1]=x;
	}
	template <typename T>void write(T x) {
		static char buf[15];
		static int len=-1;
		if(x>=0){
			do{
    			buf[++len]=x%10+48,x/=10;
    		}while (x);
		}else{
    		putc('-');
			do {
    			buf[++len]=-(x%10)+48,x/=10;
			}while(x);
		}
		while (len>=0)
			putc(buf[len]),--len;
	}
}
using namespace std;
const int maxn=5000+10,maxe=10011*5;
struct Graph{
	struct node{
		int v,w,nxt,cost;
		node(int _v=0,int _w=0,int _c=0,int _nxt=0){
			v=_v,w=_w,nxt=_nxt,cost=_c;
		}
	}e[maxe<<1];
	int s,t;
	int tot,head[maxn];
	void init(int _s,int _t){s=_s,t=_t;tot=1;}
	void add(int u,int v,int w,int c){
		//printf("%d %d %d %d\n",u,v,w,c);
		e[++tot]=node(v,w,c,head[u]),head[u]=tot;
	}
	int dis[maxn],flow[maxn],inq[maxn];
	int pre[maxn],lste[maxn];
	bool spfa(){
		queue<int>q;
		memset(dis,0x3f,sizeof dis);
		memset(flow,0x3f,sizeof flow);
		memset(inq,0,sizeof inq);
		dis[s]=0,pre[t]=-1;q.push(s);
		while(!q.empty()){
			int u=q.front();q.pop();inq[u]=0;
			#define v e[i].v
			for(int i=head[u];i;i=e[i].nxt){
				if(e[i].w>0&&dis[v]>dis[u]+e[i].cost){
					dis[v]=dis[u]+e[i].cost;
					pre[v]=u,lste[v]=i;
					flow[v]=min(flow[u],e[i].w);
					if(!inq[v])inq[v]=1,q.push(v);
				}
			}
			#undef v
		}
		return pre[t]!=-1;
	}
	pair<int,int> MCMF(){
		int mincost=0,maxflow=0;
		while(spfa()){
			int u=t;
			mincost+=flow[t]*dis[t];
			maxflow+=flow[t];
			while(u!=s){
				int E=lste[u];
				e[E].w-=flow[t],e[E^1].w+=flow[t];
				u=pre[u];
			}
		}
		return make_pair(mincost,maxflow);
	}
}G; 
int n,a[maxn],sum;
const int inf=1e9+10;
signed main(){
	//freopen("1.in","r",stdin);
	in::read(n);
	G.init(0,n+1);
	for(int i=1;i<=n;i++)
		in::read(a[i]),sum+=a[i];
	sum/=n;
	for(int i=1;i<=n;i++){
		int l=i-1,r=i+1;
		if(l==0)l=n;
		if(r==n+1)r=1;
		G.add(i,l,inf,1);G.add(l,i,0,-1);
		G.add(i,r,inf,1);G.add(r,i,0,-1);
		
		G.add(G.s,i,a[i],0);G.add(i,G.s,0,0);
		G.add(i,G.t,sum,0);G.add(G.t,i,0,0);
	}
	out::write(G.MCMF().first);
	out::flush();
	return 0;
}

```
## SOLUTION 2·贪心方法
$\color{Lavender}{\text{网络流24题里好像混入了什么奇怪的东西}}$

~~经过观察我们发现，~~**必然存在两个仓库之间不运东西**(如果想不到这一点就老老实实打网络瘤吧)

然后我们就可以枚举哪两个节点不运东西，在套上[均分纸牌](https://www.luogu.com.cn/problem/P1031)就ok了

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[20009];
int b[20009];
int num,n;
long long sum=0;
long long ans=0x3f3f3f3f3f3f3f;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
        a[i+n]=a[i];
        sum+=a[i];
    }
    num=sum/n;
    for(int i=0;i<n;i++)
    {
        long long tmp=0;
        for(int j=i;j<n+i;j++)
            b[j-i]=a[j];
        for(int k=0;k<n;k++)
            if(b[k]!=num)
            {
                int ch=b[k]-num;
                b[k+1]+=ch;
                b[k]=num;
                tmp+=abs(ch);
            }
        ans=min(tmp,ans);
    }
    cout<<ans;
}
```

---

## 作者：郎赤娜 (赞：1)

大家好，蒟蒻又来写题解了

看过其他大佬的高级做法，蒟蒻只能表示我没学过初中数学qwq

但是这并不妨碍我们用一些特别异端的方法做！

相信大家都做过均分纸牌趴，那么我们这道题的思路也很简单。均分纸牌是从1到n推一遍，如果和平均值不一样就移动纸牌。代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010],tot=0,ans=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		tot+=a[i];
	}
	tot=tot/n;
	for(int i=1;i<=n;i++)
	{
		if(a[i]<tot)
		{
			a[i+1]-=(tot-a[i]);
			a[i]=tot;
			ans++;
		}
		else if(a[i]>tot)
		{
			a[i+1]+=(a[i]-tot);
			a[i]=tot;
			ans++;
		}
		else if(a[i]==tot) continue;
	}
	cout<<ans<<endl;
	return 0;
}
```
（很久以前写的代码，过丑 请求原谅）

那么本题就可以将1~n中的每一个点作为起点，跑一边均分纸牌。这种做法可以保证我们查询了所有的情况，时间复杂度是O（n2）。由于这道题的数据范围只有100，所以轻松愉快地过啦~

下面上代码，请求忽略我丑丑的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],b[100001],ans,sum,minn=0x3f3f3f3f;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	sum/=n;
	for(int i=1;i<=n;i++)
	{
		ans=0;
		for(int j=1;j<=n;j++)
			b[j]=a[j];
		for(int j=1;j<=n;j++)
		{
			if(i+j+1>n)
			{
				if(i+j==n)
				{
					if(b[i+j]<sum)
					{
						b[(i+j+1)%n]-=(sum-b[i+j]);
						ans+=(sum-b[i+j]);
						b[i+j]=sum;
					}
					else if(b[i+j]>sum)
					{
						b[(i+j+1)%n]+=(b[i+j]-sum);
						ans+=(b[i+j]-sum);
						b[i+j]=sum;
					}
				}
				else
				{
					if(b[(i+j)%n]<sum)
					{
						b[(i+j+1)%n]-=(sum-b[(i+j)%n]);
						ans+=(sum-b[(i+j)%n]);
						b[(i+j)%n]=sum;
					}
					else if(b[(i+j)%n]>sum)
					{
						b[(i+j+1)%n]+=(b[(i+j)%n]-sum);
						ans+=(b[(i+j)%n]-sum);
						b[(i+j)%n]=sum;
					}
				}
			}
			else
			{
				if(i+j==n)
				{
					if(b[i+j]<sum)
					{
						b[(i+j+1)%n]-=(sum-b[i+j]);
						ans+=(sum-b[i+j]);
						b[i+j]=sum;
					}
					else if(b[i+j]>sum)
					{
						b[(i+j+1)%n]+=(b[i+j]-sum);
						ans+=(b[i+j]-sum);
						b[i+j]=sum;
					}
				}
				else
				{
					if(b[i+j]<sum)
					{
						b[i+j+1]-=(sum-b[i+j]);
						ans+=(sum-b[i+j]);
						b[i+j]=sum;
					}
					else if(b[i+j]>sum)
					{
						b[i+j+1]+=(b[i+j]-sum);
						ans+=(b[i+j]-sum);
						b[i+j]=sum;
					}
				}
			}
		}
		minn=min(minn,ans);
	}
	printf("%d",minn);
	return 0;
}
```
这道题的中间肯定是可以优化的，但是如果数据范围过小的话，那么优化也没有什么必要。随便写写咯~

跪求大佬指点错误，蒟蒻一定改正

---

## 作者：Dorg (赞：1)

今天上数竞，作业超级多，但还是得写日志的呀！

------------
今天继续刷网络流24题，刷了其中的一道蓝题（蓝蓝路~）**[P4016 负载平衡问题](https://www.luogu.org/problemnew/show/P4016)**
（今天上物理课时无聊时想的）

------------
### 思路如下
1. 本题要用**网络流**，还是**费用流**，网络流的题最重要的就是建模，只要建好了模，就是打模板的事情了。
2. 本题建模采用了一个比较小众的建法，但是很好理解的说（吐槽这弱得没谱的数据）
3. 建法如下：

        1） 有一个源点和一个汇点（废话）
        2） 源点与每个仓库相连，流量为其初始储量，费用为0，表示一开始有那么多的货物。
        3） 每个仓库与汇点相连，流量为平均值，费用为0，表示最终要求的情况是那么多的货物。
        4）每个相邻的点（注意是个环）之间连接，流量为inf，费用为1，表示调整。       
 ![纯手绘！超拟真！](https://cdn.luogu.com.cn/upload/pic/55102.png )
 
 ```cpp
FOR(i,1,n){
	add(0,i,num[i],0);
	add(i,n+1,adv,0);
	if(i!=1) add(i,i-1,inf,1);
	if(i!=n) add(i,i+1,inf,1);
}
add(1,n,inf,1); add(n,1,inf,1);//注意别忘了！
```


------------
### CODE
```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define Maxn 1000
#define inf 1<<20
#define LL long long

using namespace std;

inline int read(){
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}

int n;

struct LINE{
	int st,en,lim,val,pre;
}line[Maxn*10];
int tot=1; int head[Maxn+10];
void add(int a,int b,int c,int d){
	line[++tot]=(LINE){ a,b,c,d,head[a] };
	head[a]=tot;
	line[++tot]=(LINE){ b,a,0,-d,head[b] };
	head[b]=tot;
}

int visit[Maxn]; LL dist[Maxn]; int last[Maxn]; LL minflow[Maxn];
bool spfa(int S,int T){
	queue < int > q;
	memset(visit,0,sizeof(visit));
	memset(dist,63,sizeof(dist));
	minflow[S]=inf;
	q.push(S); dist[S]=0; visit[S]=1;
	last[S]=0;
	while(!q.empty()){
		int now=q.front(); visit[now]=0; q.pop();
		for(int i=head[now];i;i=line[i].pre){
			int E=line[i].en;
			if(!line[i].lim) continue;
			if(dist[now]+line[i].val<dist[E]){
				dist[E]=dist[now]+line[i].val;
				minflow[E]=min(minflow[now],(LL)line[i].lim);
				last[E]=i;
				if(!visit[E]){
					q.push(E);
					visit[E]=1;
				}
			}
		}
	}
	if(dist[T]==dist[T+1]) return false;
	return true;
}
LL maxflow, ans;
void update(int S,int T){
	int now=T;
	while(now!=S){
		int i=last[now];
		line[i].lim-=minflow[T];
		line[i^1].lim+=minflow[T];
		now=line[i].st;
	}
	maxflow+=minflow[T];
	ans+=dist[T]*minflow[T];
}

int main(){
	
	cin>>n;
	
	int num[n+1];
	int sum=0;
	FOR(i,1,n){
		num[i]=read();
		sum+=num[i];
	}
	int adv=sum/n;
		
	FOR(i,1,n){
		add(0,i,num[i],0);
		add(i,n+1,adv,0);
		if(i!=1) add(i,i-1,inf,1);
		if(i!=n) add(i,i+1,inf,1);
	}
	
	add(1,n,inf,1); add(n,1,inf,1);
	
	while(spfa(0,n+1)) update(0,n+1);
	
	cout<<ans<<endl;
	
	return 0;
}

```


---

## 作者：humveea6 (赞：1)

题目标签写着网络流诶….那么问题就是如何建图了…看到题解里一波大神用平均值来计算…但是蒟蒻没想到诶…所有我就比较暴力了…. 
对于每个点一拆为二（ia，ib），建立超源超汇，然后对于每个点，从源点s向其连一条容量为c[i]，费用为0的边，从ia向ib连一条容量为无限，费用为0 的边（因为可以不停的把别的地方的货物搬到ia，然后从ib搬到下一个点去，ia到ib搬运当然是不用钱的），然后从ib向汇点t连一条容量为目标值也就是平均值的边，费用为0. 
同时，每个点的ib向他的前后相邻的点连边，也就是ib向(i-1)a连容量为无穷，费用为1的边，向（i+1）a同样也是如此。 
这样，我们在跑最小费用流的时候就可以保证每个点i原有的在avg以下的容量不会搬到别的点去（毕竟从s到t费用为0呢），而不满足的部分一定会搬去别的点或者从别的点搬过来，那么搬的过程自然就会产生相应的费用。 
代码：
```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
struct edge{
    int to,cap,cost,rev;//终点,容量,费用,反向边
};
vector<edge>G[5010];
int dis[5010],prevv[5010],preve[5010],n,m,s,t,flow=0,cost=0;//最短路中前驱节点和对应的边
bool inque[5010];
void add(int from,int to,int cap,int cost)
{
    G[from].push_back(edge{to,cap,cost,(int)G[to].size()});
    G[to].push_back(edge{from,0,-cost,(int)G[from].size()-1});//注意反向边的加法!!-cost和cap=0!!
}
bool spfa(int s,int t)
{
    memset(dis,0x3f, sizeof(dis));memset(inque,0,sizeof(inque));
    queue<int>que;que.push(s);dis[s]=0;
    while(!que.empty()){
        int t=que.front();que.pop();inque[t]=false;
        for(int i=0;i<G[t].size();i++){
            edge e=G[t][i];
            if(e.cap&&dis[e.to]>dis[t]+e.cost){
                dis[e.to]=dis[t]+e.cost;
                prevv[e.to]=t;preve[e.to]=i;
                if(!inque[e.to]){
                    que.push(e.to);inque[e.to]=true;
                }
            }
        }
    }
    if(dis[t]==0x3f3f3f3f)
        return false;
    int d=0x7f7f7f7f;
    for(int v=t;v!=s;v=prevv[v])
        d=min(d,G[prevv[v]][preve[v]].cap);//全最短路中的最小流量限制就是本次总的流量限制
    flow+=d;cost+=d*dis[t];
    for(int v=t;v!=s;v=prevv[v]){
        edge&e=G[prevv[v]][preve[v]];//更新路径信息
        e.cap-=d;
        G[e.to][e.rev].cap+=d;
    }
    return true;
}
void mincostmaxflow(int s,int t)
{
    while(spfa(s,t));
}
int main()
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    int n,i,j,k;
    int  c[105];
    cin>>n;int avg=0;
    for(i=1;i<=n;i++) {
        cin >> c[i], add(i, i + 200, 1 << 30, 0);
        add(0, i, c[i], 0);avg+=c[i];
    }
    avg/=n;
    for(i=1;i<=n;i++){
        add(i+200,500,avg,0);
        if(i!=n)
            add(i+200,i+1,1<<30,1);
        else
            add(i+200,1,1<<30,1);
        if(i!=1)
            add(i+200,i-1,1<<30,1);
        else
            add(i+200,n,1<<30,1);
    }
    mincostmaxflow(0,500);
    cout<<cost<<endl;

    return 0;
}
```

与hzwer大神的程序对拍了一会好像没啥错233

---

## 作者：静默之光 (赞：1)

既然是在网络流练习题里看到的，那么就拿网络流来做嘛

观察这道题，既然是要用网络流来做，网络流的关键肯定是建图了，那么要怎么建图呢？

在环上的任何一个点作为源和汇肯定都不合适，因此超级源和超级汇是必须的，然后建立下面三种边：（无需拆点）

1.多于平均值的点由源点建边，他们需要向汇点提供一些物品，流量即为其值减平均值，这里只是声明关系，所以费用为0；反向边正常建立，流量0费用0

2.少于平均值的点向汇点建边，他们需要由源点接收一些物品，流量即为平均值减其值，这里也是声明关系，所以费用为0；反向边正常建立，流量0费用0

3.相邻的点之间 **互相** 建边，如果经过他，代表移动了货物，故需要支出费用的，一单位货物需要一单位费用，所以这些边的费用为1，流量无限制（INF）；反向边也是正常建，流量0费用-1。注意因为是环所以n和1也要建边。

这样你会发现，无论哪一种有效的货物的移动都可以由一条路径表示，又由于反向边的存在，所以这样做是正确的。

既然都可以表示了，就不需要拆点了，拆点还不好理解（其实是我看KS大佬的题解没懂）。
总之回去膜拜一下KS大佬。

下面是代码，不要吐槽我的码风和变量名……

```cpp
#include <cstdio>
#include <cstring>
const int N=110000,inf=2147483647; 
struct node{
	int x,y,c,f,next;
}map[N*2];
int m,n,s,t;
int h[N],num,a[N];
int flowt,f1,ds[N],flag[N],pre[N],que[N],min1;
void insert1(int x,int y,int c,int f)
{
	map[++num].x=x;
	map[num].y=y;
	map[num].c=c;
	map[num].f=f;
	map[num].next=h[x];
	h[x]=num;
}
bool spfa()
{
	for(int i=0;i<=n+1;i++)
	{
		ds[i]=inf;
		flag[i]=0;
		pre[i]=-1;
	}
	ds[s]=0;
	int op=0,cl=0;
	que[++cl]=s;
	while(op<cl)
	{
		op++;
		int x=que[op];
		for(int j=h[x];j!=-1;j=map[j].next)
		{
			int y=map[j].y;
			if(map[j].c>0 && ds[x]+map[j].f<ds[y])
			{
				ds[y]=ds[x]+map[j].f;
				pre[y]=j;
				if(flag[y]==0)
				{
					que[++cl]=y;
					flag[y]=1;
				}
			}
		}
		flag[x]=0;
	}
	if(ds[t]==inf) return false;
	else return true;
}
int main()
{
	scanf("%d",&n);
	memset(h,-1,sizeof(h));
	num=-1;//从0开始方便^来读取反向边 
    int sum=0;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),sum+=a[i];
	sum/=n;
	s=0;t=n+1;
	for(int i=1;i<=n;i++)
	{
		int x=a[i]-sum;
		if(x>0) insert1(s,i,x,0),insert1(i,s,0,0);//情况1
		if(x<0) insert1(i,t,-x,0),insert1(t,i,0,0);//情况2
	}
	for(int i=1;i<n;i++)
		insert1(i,i+1,inf,1),insert1(i+1,i,0,-1),
		insert1(i+1,i,inf,1),insert1(i,i+1,0,-1);//情况3
	insert1(n,1,inf,1),insert1(1,n,0,-1);
	insert1(1,n,inf,1),insert1(n,1,0,-1);//原题是环 
    int j;
	flowt=0;f1=0;
	while(spfa())//费用流 
	{
		min1=inf;
		j=pre[t];
		while(j!=-1)
		{
			if(min1>map[j].c) min1=map[j].c;
			j=pre[map[j].x];
		}
		flowt+=min1;
		f1+=ds[t]*min1;
		j=pre[t];
		while(j!=-1)
		{
			map[j].c-=min1;
			map[j^1].c+=min1;
			j=pre[map[j].x];
		}
	}
	printf("%d\n",f1);
	return 0;
}
```

---

## 作者：巫妖王 (赞：1)

###初中七上第一章都学过吧。

##### 在数轴上任取n个点，问在数轴的哪个点或哪个范围里，这个点到所有点的距离和最小。

##### 我们可以将所有点从左到右标上1,2,3,4···n-1，n,然后，如果n是奇数，那么点为n+1/2，然后距离和就一个一个点算过去；如果n是偶数，为了方便计算，我们可以取n/2或（n/2）+1这两个点，然后距离和就一个一个点算过去。

### 贴上代码

```cpp
var
  n:longint;
  a,b:array[0..1000010] of int64;
  i:longint;
  sum1:int64;
  max,k:int64;
procedure qk(l,r:longint);
var
  i,j,m:longint;
  t:int64;
begin
  i:=l; j:=r; m:=b[(i+j) div 2];
  while i<j do
    begin
      while b[i]<m do inc(i);
      while b[j]>m do dec(j);
      if i<=j then 
      begin
        t:=b[i]; b[i]:=b[j]; b[j]:=t;
        inc(i); dec(j);
      end;
    end;
  if i<r then qk(i,r);
  if j>l then qk(l,j);
end;//快排
begin
  readln(n);
  for i:=1 to n do 
    begin
      read(a[i]);
      b[i]:=b[i-1]+a[i];
    end;
  sum1:=b[n] div n;//如果n是偶数，为了方便计算，我们可以取n/2然后距离和就一个一个点算过去。
  for i:=1 to n do b[i]:=b[i]-i*sum1;
  qk(1,n);
  k:=b[(1+n) div 2];//如果n是奇数，那么点为n+1/2，然后距离和就一个一个点算过去；
  for i:=1 to n do max:=max+abs(b[i]-k);
  writeln(max);
end.
```

---

## 作者：zh_dou (赞：0)

## 负载平衡问题

(下文中$x\xrightarrow{a,b}y$表示从$x$向$y$连一条流量为$a$，费用为$b$的边)

在做均分纸牌那题的时候，我们首先求出了牌数的平均值，对与每一堆牌减平均值

这道题同理，

#### 1.货物数减去 $arv$ 若大于0

$s \xrightarrow{a[i]-arv,0}i$

表示 $i$ 可以获得数量为 $a[i]-arv$ 的货物

#### 2.货物数减去 $arv$ 若小于0

$i \xrightarrow{arv-a[i],0}i$ 

表示 $i$ 可以流出数量为 $arv-a[i]$ 的货物

#### 3. 向旁边的两个仓库连边：

$i\xrightarrow{+\infty,1}i+1,i\xrightarrow{+\infty,1}i-1$ 

表示 $i$ 可以将货物流向 $i+1,i-1$

坠后从$s$到$t$跑最小费用最大流即可

------------

$\mathcal{Code}:$
```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
#define N 575
#define inf 2147483647
#define int long long
#define debug cout<<__LINE__<<" "<<__FUNCTION__<<"\n"
inline int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*y;
}
struct Edge{
    int to,flow,cost,nxt;
}edge[N];
int n,m,s,t,tot=1;
int flow[N],deep[N],last[N],pre[N],vis[N],head[N],a[N];//pre: point   last:edge
int maxflow,mincost;
inline void add(int from,int to,int flow,int cost){
    edge[++tot].nxt=head[from];
    edge[tot].to=to;
    edge[tot].flow=flow;
    edge[tot].cost=cost;
    head[from]=tot;
}
bool spfa(){
    memset(flow,0x3f,sizeof(flow));
    memset(deep,0x3f,sizeof(deep));
    memset(vis,0,sizeof(vis));
    deep[s]=0;
    pre[t]=-1;
    vis[s]=1;
    queue<int>q;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u] = 0;
        for(int i = head[u];i;i = edge[i].nxt){
            int v = edge[i].to;
            if(deep[v] > deep[u] + edge[i].cost && edge[i].flow){
                flow[v] = min(flow[u],edge[i].flow);
                deep[v] = deep[u] + edge[i].cost;
                pre[v] = u;last[v] = i;
                if(!vis[v]){
                    vis[v] = 1;q.push(v);
                }
            }
        }
    }
    return pre[t]!=-1;
}
inline void Dinic(){
    while(spfa()){
        maxflow += flow[t];
        mincost += flow[t] * deep[t];
        int x = t;
        while(x != s){
            edge[last[x]].flow -= flow[t];
            edge[last[x] ^ 1].flow += flow[t];
            x = pre[x];
        }
    }
}
signed main(){
//	freopen("a.in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	s=0;t=n+1;
	int sum=0;
	for(int i=1;i<=n;i++){
		a[i]=read();sum+=a[i];
	}
	sum/=n;
	for(int i=1;i<=n;i++){
		a[i]-=sum;
		if(a[i]>0) add(s,i,a[i],0),add(i,s,0,0);
		if(a[i]<0) add(i,t,-a[i],0),add(t,i,0,0);
	}
	for(int i=1;i<=n;i++){
		add(i,i%n+1,inf,1);add(i%n+1,i,0,-1);
		add(i,(i-2+n)%n+1,inf,1);add((i-2+n)%n+1,i,0,-1);
	}
	Dinic();
	cout<<mincost<<"\n";
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：Ireliaღ (赞：0)

**Zkw费用流指针版**

### 解题思路

这道题是想让所有节点最终货物值相等，也就是最终所有都会变成它们的平均值，所以可以使用费用流。

### 建图

* 设$0$为超级源点，$n + 1$为超级汇点，平均值为$ave$

* 对于每一个需要“送”的点，从$0$向它连边，容量$val_i - ave$，费用$0$

* 对于每一个需要“拿”的点，从它向$n + 1$连边，容量$ave - val_i$，费用$0$

* 从每个点向相邻点连容量$\infty$，费用$1$的边

### 代码

Zkw费用流，指针存图，有当前弧

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <algorithm>
#include <cstring>
#include <deque>
#include <cstdio>

using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int n;

struct Edge{
    int to, val, cost;
    Edge *next, *ops;
    Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}
};

Edge *head[MAXN], *cur[MAXN];

void AddEdge(int u, int v, int w, int c) {
    head[u] = new Edge(v, w, c, head[u]);
    head[v] = new Edge(u, 0, -c, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int s, t, res, ans;
int dis[MAXN];
bool vis[MAXN];

bool Spfa() {
    memset(dis, INF, sizeof(dis));
    memset(vis, false, sizeof(vis));
    deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop_front();
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if (e->val && dis[v] > dis[u] + e->cost) {
                dis[v] = dis[u] + e->cost;
                if (!vis[v]) {
                    if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
                    else q.push_back(v);
                }
            }
        }
    }
    return dis[t] < INF;
}

int Dfs(int u, int flow) {
    vis[u] = true;
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *&e = cur[u]; e; e = e->next) {
        int v = e->to;
        if ((v == t || !vis[v]) && e->val && dis[v] == dis[u] + e->cost) {
            int mi = Dfs(v, min(e->val, flow - used));
            if (mi) {
                used += mi;
                e->val -= mi;
                e->ops->val += mi;
                ans += e->cost * mi;
            }
            if (used == flow) break;
        }
    }
    return used;
}

void Dinic() {
    res = ans = 0;
    while (Spfa()) {
        vis[t] = true;
        while (vis[t]) {
            memset(vis, false, sizeof(vis));
            memcpy(cur, head, sizeof(head));
            Dfs(s, INF);
        }
    }
}

int num[MAXN];

int main() {
    #ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    #endif
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    int sum = 0;
    cin >> n;
    s = 0; t = n + 1;
    for (int i = 1; i <= n; i++) {
        cin >> num[i];
        sum += num[i];
    }
    int ave = sum / n;
    for (int i = 1; i <= n; i++) {
        if (num[i] > ave) AddEdge(s, i, num[i] - ave, 0);
        else AddEdge(i, t, ave - num[i], 0);
    }
    for (int i = 2; i <= n; i++) {
        AddEdge(i - 1, i, INF, 1);
        AddEdge(i, i - 1, INF, 1);
    }
    AddEdge(1, n, INF, 1);
    AddEdge(n, 1, INF, 1);
    Dinic();
    cout << ans << endl;
    return 0;
}
```

---

## 作者：lxy__ (赞：0)

## Solution

$orz$ 用贪心过此题的巨佬。

**以下是费用流思路~~建图方式~~。**

1.显然：每个点向周围两个点连流量为 $INF$ ，费用为 $1$ 的边

2.老套路：建立超级源点和汇点

现在需要考虑哪些点需要连向源点，哪些需要连向汇点了。

设平均数为 $s$ ，我们把货物不足平均数的点连向汇点，流量为**平均数-这个点的货物量**，费用为 $0$ 。把货物超过平均数的点连向源点，流量为**这个点的货物量-平均数**，费用为 $0$。

好了上代码。

## Code

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int in=5005,INF=1<<30;
int n,s,t,m,u,v,w,f,maf=0,cost=0,cnt=1,sum=0;
int head[in],vis[in],dis[in],a[in];
struct Edge
{
    int nxt,to,w,f;
}e[in];
void add(int x,int y,int w,int f)
{
    cnt++;
    e[cnt]=(Edge){head[x],y,w,f};
    head[x]=cnt;
}
bool spfa() // dinic模板无耻压行
{
    memset(vis,0,sizeof(vis)); memset(dis,0x3f,sizeof(dis));
    queue<int>q; q.push(s); dis[s]=0;
    while(!q.empty())
    {
        int a=q.front(); q.pop(); vis[a]=0;
        for(int i=head[a];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if(e[i].w&&dis[v]>dis[a]+e[i].f){dis[v]=dis[a]+e[i].f;if(!vis[v]){q.push(v);vis[v]=1;}}
        }
    }
    if(dis[t]!=0x3f3f3f3f) return true;
    return false;
}
int dfs(int u,int flow)
{
    int used=0;
    vis[u]=1;
    if(u==t){maf+=flow;return flow;}
    for(int i=head[u];i;i=e[i].nxt)
    {
        int v=e[i].to;
        if((vis[v]==0||v==t)&&e[i].w&&dis[v]==dis[u]+e[i].f)
        {
            int mif=dfs(v,min(flow-used,e[i].w));
            if(mif) cost+=e[i].f*mif,e[i].w-=mif,e[i^1].w+=mif,used+=mif;
            if(used==flow) break;
        }
    }
    return used;
}
void dinic(){while(spfa()){vis[t]=1;while(vis[t]){memset(vis,0,sizeof(vis));dfs(s,INF);}}}
int main()
{
    scanf("%d",&n);
    s=0; t=n+1;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        sum+=a[i];
        int A=i-1;
        if(!A) A=n;
        add(i,A,INF,1);//连向两边
        add(A,i,0,-1);
        add(A,i,INF,1);
        add(i,A,0,-1);
    } 
    sum/=n;
    for(int i=1;i<=n;i++)
    {
        if(a[i]>=sum)//连向源点
        {
            add(s,i,a[i]-sum,0);
            add(i,s,0,0);
        }
        else//连向汇点
        {
            add(i,t,sum-a[i],0);
            add(t,i,0,0);
        }
    }
    dinic();
    printf("%d",cost);
    return 0;
}
```


---

## 作者：Chester (赞：0)

我也是用贪心的做法，但是复杂度是$O(n^2)$  
远远不及$dalao$的$nlogn$ 做法啊  
但是这个贪心的证明更好理解  
首先显然肯定存在一个节点$S$只出不入，一个节点$T$只入不出  
然后只需证明$T$与它的其中一个相邻节点没有运输关系可以是最优解  
如图：
![](https://cdn.luogu.com.cn/upload/pic/16726.png)  
  
    
  
此方案相当当然不如下面这个方案

![](https://cdn.luogu.com.cn/upload/pic/16727.png)

**原因**：如果向右从$S$运动$T$，单位运输费用为3，向左运，则单位运输费为2，S->T应选择向左运输，转化为图2的运输方法  
所以存在$T$和它相邻的一个节点没有运输关系  
其他情况同理可证  
  
  最后将两个没有运输关系的节点看成一条链的两端，运输量既可以为负也可以为正。  
  跑$n$次贪心，选取最小的就可以了
  代码如下：  
  ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,a[205],MIN=~0U>>1,A[105],aver;
void work(){
	ans=0;
	for(int i=0;i<n;++i){
 		ans+=abs(aver-A[i]);
 		A[i+1]+=A[i]-aver;
	}
	MIN=min(MIN,ans);
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;++i){
		scanf("%d",&a[i]);
		a[i+n]=a[i];
		aver+=a[i];
	}
	aver/=n;
	for(int i=0;i<n;++i){
		for(int j=0;j<n;++j)A[j]=a[i+j];
		work();
	}
	printf("%d",MIN);
}
```

---

## 作者：star_magic_young (赞：0)

------------


~~蒟蒻水一波题解~~

这道题和均分纸牌比较类似,于是先想到了类似的预处理方法----

**把每个数减去数列的平均值**

因为要构建一个网络,所以按如下方式处理

(这里把点i拆成点i和n+i,连边比较直观方便)


- 从s(原点)向i连一条流量为a[i] (原数组的) 费用为0的边(费用的作用见下文)

- 从i向n+i连一条流量为inf(一个大数) 费用为0的边

- 从n+i向t(汇点)连一条流量为x(原数组平均值) 费用为0的边


然后跑一遍最大流,这样会导致a[i] > x 的s到i的边,a[i] < x 的n+i到t的边有残余流量(前者说明仓库多了,后者说明仓库还需要更多)


接下来,从i向点n+j(j∈[1,n],j≠i) 连边,流量为inf,费用为这两点(i和j)的距离.

距离?~~那是什么~~

这样,从i运到j的货物量即为(一次增广)流量 \* 边的费用.

在这个图上跑费用流,最后这个图所有流量(曾经)不为inf的边全为0----说明所有货物都运完了

得出来的cost总费用就是答案

实在不行画图理解吗,套几个样例也行.

~~不对啊我瞎扯了些什么,,,,,,~~


------------



####code

```cpp
#include<iostream>    //最大流费用流2合1 233
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm> 
#include<cmath>
#include<queue>
#define inf 999999999
#define il inline
using namespace std;
struct nn
{
  int to,nt,c,w;
}e[200010];
int hd[10010],tot;
il void add(int fr,int to,int c,int w)
{
  e[tot].to=to;e[tot].nt=hd[fr];e[tot].c=c;e[tot].w=w;hd[fr]=tot;tot++;
  e[tot].to=fr;e[tot].nt=hd[to];e[tot].c=0;e[tot].w=-w;hd[to]=tot;tot++;
}
int ss,tt;
int lv[10010];
int ds[10010],pre[10010],ff[10010];bool v[10010];
int flow,cost;
int n;
il bool bfs()
{
  memset(lv,-1,sizeof(lv));
  queue<int> q;
  q.push(ss);
  lv[ss]=0;
  while(!q.empty())
    {
      int x=q.front();
      q.pop();
      for(int j=hd[x];j>=0;j=e[j].nt)
    {
      int y=e[j].to,c=e[j].c;
      if(c>0&&lv[y]<0)
        {
          lv[y]=lv[x]+1;
          q.push(y);
        }
    }
    }
  return lv[tt]>=0;
}
il int dfs(int x,int fl)
{
  if(x==tt) return fl;
  int fll=0;
  for(int j=hd[x];j>=0;j=e[j].nt)
    {
      int y=e[j].to,c=e[j].c;
      if(c>0&&lv[y]==lv[x]+1)
    {
      int fff=dfs(y,min(fl,c));
      e[j].c-=fff;e[j^1].c+=fff;
      fll+=fff;fl-=fff;
      if(fl<=0) return fll;
    }
    }
  return fll;
}
il bool spfaa()
{
  memset(ds,0x7f,sizeof(ds));
  memset(pre,-1,sizeof(pre));
  memset(ff,-1,sizeof(ff));
  memset(v,false,sizeof(v));
  queue<int> q;
  q.push(ss);
  ds[ss]=0;ff[ss]=inf;v[ss]=true;
  while(!q.empty())
    {
      int x=q.front();
      q.pop();
      for(int j=hd[x];j>=0;j=e[j].nt)
    {
      int y=e[j].to,c=e[j].c,w=e[j].w;
      if(c>0&&ds[y]>ds[x]+w)
        {
          ds[y]=ds[x]+w;
          pre[y]=j;
          ff[y]=min(ff[x],c);
          if(!v[y])
        {
          v[y]=true;
          if(y!=tt) q.push(y);
        }
        }
    }
      v[x]=false;
    }
  if(ds[tt]>=0x7f) return false;
  flow+=ff[tt];
  cost+=ff[tt]*ds[tt];
  int now=tt;
  while(now!=ss)
    {
      int j=pre[now];
      e[j].c-=ff[tt];
      e[j^1].c+=ff[tt];
      now=e[j^1].to;
    }
  return true;
}    //以上内容为最大流和费用流板子,不会就看模版
il int dinicc()
{
  flow=0;
  while(bfs()){flow+=dfs(ss,inf);}
  return flow;
}
il int fyl()
{
  flow=0;cost=0;
  while(1){if(!spfaa()) break;}
  return cost;
}
int main()
{
  memset(hd,-1,sizeof(hd));    //个人习惯
  scanf("%d",&n);tt=2*n+1;
  int sum=0,ans=0;
  for(int i=1;i<=n;i++)
    {
      int c;
      scanf("%d",&c);
      sum+=c;
      add(ss,i,c,0);
      add(i,n+i,inf,0);    //先连预处理边
    }
  sum/=n;
  for(int i=1;i<=n;i++) add(n+i,tt,sum,0);
  dinicc();    //最大流预处理
  for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=n/2;j++)
    add(i,(n+i+j-1)%n+1,inf,j);
      for(int j=1;j<=n/2;j++)
    add(i,(n+i+-j-1)%n+1,inf,j);    //枚举距离,向别的点连边
    }
  printf("%d",fyl());    //然后费用流乱搞即可
  return 0;
}
```

------------



---

## 作者：ww3113306 (赞：0)

我会说这题和均分纸牌加强版是一样一样的么。。。。只不过数据范围小一点。。。。

难度虚高啊。。。

均分纸牌加强版是每次一张，求最少次数

这里是每次不限量，求最少运输量，

但均分纸牌加强版的因为必须移到平衡，所以也可以看成移动了一次，但一次移动很多，将代价变成次数就好了啊，，，，

这里贴一份代码，，，解释比较少，具体的可以去看1368，解释的很详细

#include<bits/stdc++.h>

using namespace std;

/\*神奇的数论做法\*/

```cpp
#define AC 250
int n,a[AC];
long long sum[AC],ave,mid,ans;
int read()
{
    int x=0;char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x;
}
int abS(int x)
{
    if(x>0)return x;
    else return -x;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
        ave+=a[i];
    }
    ave/=n;//平均数
    for(int i=1;i<=n;i++)
    {
        sum[i]=sum[i-1]+a[i]-ave;//得到的是它前面还多多少或者少多少。
        //也就是有多少要移过来
    } 
    sort(sum+1,sum+n+1);//排序
    mid=(sum[(n+1)/2]);//取中位数
    for(int i=1;i<=n;i++)
    {
        ans+=abS(sum[i]-mid);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Great_Influence (赞：0)

网络流24题第一刷。

不知道是什么鬼标签，反正刷了就是了。


既然是网络流系列，那么就规定一下吧：$(u,v,w,f)$表示从u向v连边，权值为w，流量为f的双向边（反向边自行脑补）。如果只需要用到网络流，那么边变为$(u,v,f)$，意义同上。


本题为费用流。


连边：对于每个储货量大于平均值$avr$的点连边 $(s,i,0,w[i]-avr)$

对于每个储货量小于$avr$连边 $(i,t,0,avr-w[i])$

对于每个大于平均值点$i$向每个小于平均值点$j$连边

$(i,j,min((i-j+n)\bmod n,(j-i+n)\bmod n)$

从s向t跑网络流。

代码：


    
    
    
    
    
```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
        #endif
    }
    const int MAXN=11111;
    static struct edge
    {
        int v,w,next;
        long long f;
    }p[MAXN<<2];
    static int n,head[MAXN],input[MAXN],output[MAXN],k1,k2,e=1;
    static long long sum,w[MAXN];
    inline void add(int u,int v,int w,int f)
    {
        p[++e].v=v;p[e].w=w;p[e].f=f;p[e].next=head[u];head[u]=e;
        p[++e].v=u;p[e].w=-w;p[e].f=0;p[e].next=head[v];head[v]=e;
    }
    void init()
    {
        read(n);
        Rep(i,1,n)read(w[i]),sum+=w[i];
        sum/=n;
        Rep(i,1,n)if(w[i]>sum)input[++k1]=i,add(n+1,i,0,w[i]-sum);
        else if(w[i]<sum)output[++k2]=i,add(i,n+2,0,sum-w[i]);
        Rep(i,1,k1)Rep(j,1,k2)add(input[i],output[j]
                ,min((input[i]-output[j]+n)%n,(output[j]-input[i]+n)%n)
                ,min(w[input[i]]-sum,sum-w[output[j]]));
    }
    long long fee;
    long long lev[MAXN];bool vis[MAXN];
    deque<int>G;
    bool spfa(int s,int t)
    {
        memset(lev,0x3f,sizeof lev);
        G.push_front(s);vis[s]=1;lev[s]=0;
        while(!G.empty())
        {
            static int u,v;u=G.front();G.pop_front();
            for(v=head[u];v;v=p[v].next)if(p[v].f&&lev[p[v].v]>lev[u]+p[v].w)
            {
                lev[p[v].v]=lev[u]+p[v].w;
                if(!vis[p[v].v])
                {
                    vis[p[v].v]=true;
                    if(G.empty()||lev[p[v].v]<lev[G.front()])G.push_front(p[v].v);
                    else G.push_back(p[v].v);
                }
            }
            vis[u]=false;
        }
        return lev[t]^lev[0];
    }
    static int cur[MAXN];
    long long dfs(int u,int t,long long flow)
    {
        if(u==t||!flow)return flow;
        long long sum=0;vis[u]=true;
        for(register int &v=cur[u];flow&&v;v=p[v].next)
        {
            if(!vis[p[v].v]&&p[v].f&&lev[p[v].v]==lev[u]+p[v].w)
            {
                long long f=dfs(p[v].v,t,min(flow,p[v].f));
                p[v].f-=f;p[v^1].f+=f;fee+=f*p[v].w;sum+=f;flow-=f;
            }
        }
        vis[u]=false;
        return sum;
    }
    void Dinic(int s,int t)
    {while(spfa(s,t))memcpy(cur,head,sizeof head),dfs(s,t,lev[0]);}
    void solve()
    {
        Dinic(n+1,n+2);
        printf("%lld\n",fee);
    }
    int main(void){
        file();
        init();
        solve();
        return 0;
    }

```

---

## 作者：arfa (赞：0)

最小费用最大流的 **$Dark$ 水题**。

一开始照着大佬们的建模画了一下图,如下 : 

![](https://i.loli.net/2018/11/03/5bdd1040ded4d.png)

注意是一个环而,所以上面的最高的那个点要连最低的那个点的,上面没有画。

我们会发现,我们从源点给了那些点一些权值,然后让用它们的地理位置来给其它的点权值。很显然,如果要流到汇点的话,肯定要先流到那些少于平均值的点。那么这道题就搞定了。

为什么有数学 $+$ 贪心的方法? 你没有看到这张图就是一个序列 $+$ 两个点吗,完全可以数学啊。

```pascal
Uses math;

var
    from,reach,next,value,cost:array[-1..1010] of longint;
    dis,pre,last,flow:array[-1..1010] of int64;
    queue:array[-1..1010] of longint;
    cnt:array[-1..110] of longint;
    vis:array[-1..110] of boolean;
    num:array[-1..110] of longint;
    n,m,i,j,k,tot,sum,now,node,sink,source:longint;
    maxflow,mincost:int64;

procedure add(x,y,sum_1,sum_2:longint);
begin
    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;
    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;
end;

function spfa:boolean;
var head,tail,now,i:longint;
begin
    filldword(dis,sizeof(dis) div 4,maxlongint);
    filldword(flow,sizeof(flow) div 4,maxlongint);
    filldword(vis,sizeof(vis) div 4,0);
    head:=1; tail:=1;  queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;

    while head<=tail do
    begin
        now:=queue[head]; vis[now]:=False; inc(head);
        i:=cnt[now];
        while i<>-1 do
        begin
            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then
            begin
                dis[reach[i]]:=dis[now]+cost[i];
                pre[reach[i]]:=now;
                last[reach[i]]:=i;
                flow[reach[i]]:=min(flow[now],value[i]);
                if vis[reach[i]]=False then
                begin
                    vis[reach[i]]:=True;
                    inc(tail); queue[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
    end;
    if pre[sink]=-1 then exit(False); exit(True);
end;

procedure MincostMaxflow;
begin
    maxflow:=0; mincost:=0; now:=0;
    while (spfa) do
    begin
        now:=sink;
        inc(maxflow,flow[sink]);
        inc(mincost,flow[sink]*dis[sink]);
        while now<>source do
        begin
            dec(value[last[now]],flow[sink]);
            inc(value[last[now] xor 1],flow[sink]);
            now:=pre[now];
        end;
    end;
end;

procedure Clear;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
end;

procedure Construction_I;
begin
    read(n);
    source:=1; sink:=n+2;
    for i:=1 to n do begin read(num[i]); inc(sum,num[i]); end;
    sum:=sum div n;
    for i:=1 to n do
    begin
        dec(num[i],sum);
        if num[i]>0 then add(source,i+1,num[i],0);
        if num[i]<0 then add(i+1,sink,-num[i],0);
        if i>1 then add(i+1,i,maxlongint,1);
        if i<n then add(i+1,i+2,maxlongint,1);
    end;
    add(2,n+1,maxlongint,1);
    add(n+1,2,maxlongint,1);
end;

begin
    Clear; Construction_I; MincostMaxflow; writeln(mincost);
end.
```




---

## 作者：foreverlasting (赞：0)

[网络流24题大综合](https://www.luogu.org/blog/foreverlasting/wang-lao-liu-24-ti-tai-zeng-ge)

这题提供两个思路。

第一个是网络流：典型的最小费用流问题。对于需要货物的点向T连一条容量为需要的货物量费用为0的边，S向多余货物的点连一条容量为多余货物量费用为0的边，然后任何相邻两点连一条容量为inf费用为1的边，因为是环，所以1和n也要连。
然后就是最小费用流了。代码此处不提供。

第二种思路是贪心：参考HNOI2008 糖果传递，这种模型很常见的。所以也不提供代码。

---

## 作者：爱喝敌敌畏 (赞：0)

额，这道题。。。秒A，并没看题解，好裸。。。

（注：被看题解的人抓去狂打40分钟并喂了五大包的敌敌畏）

好吧，不XX了。

这道题建模并不复杂。

每个点向周围两个点连一条边，流量为INF，费用为1，源点向每个点连一条，流量为这个点的容量，费用为0，每个点向汇点连一条边，流量为sigma()/n~~（你们应该看得懂吧）~~，费用为0

然后费用流，没了，额~

```cpp
#include<cstdio>
#include<cstring>
using  namespace  std;
struct  node
{
	int  y,c,d,next,other;
}a[21000];int  len,last[210],n,st,ed,sum,cost;
int  list[210],head,tail,d[210];
bool  v[210];
void  ins(int  x,int  y,int  c,int  d)
{
	len++;
	a[len].y=y;a[len].c=c;a[len].d=d;
	a[len].next=last[x];last[x]=len;
	len++;
	a[len].y=x;a[len].c=0;a[len].d=-d;
	a[len].next=last[y];last[y]=len;
	a[len].other=len-1;
	a[len-1].other=len;
}
bool  spfa()
{
	memset(d,20,sizeof(d));d[ed]=0;v[ed]=false;
	head=1;tail=2;list[head]=ed;
	int  inf=d[ed+1];
	while(head!=tail)
	{
		int  x=list[head];
		for(int  k=last[x];k;k=a[k].next)
		{
			int  y=a[k].y,kl=a[k].other;
			if(a[kl].c>0    &&  d[y]>d[x]-a[k].d)
			{
				d[y]=d[x]-a[k].d;
				if(v[y]==true)
				{
					v[y]=false;
					if(d[list[head+1]]>d[y])
					{
						int  all=head;
						head--;if(head==0)head=n;
						list[head]=list[all];list[all]=y;
					}
					else
					{
						list[tail++]=y;
						if(tail==n+1)tail=1;
					}
				}
			}
		}
		head++;if(head==n+1)head=1;
		v[x]=true;
	}
	return  d[st]!=inf;
}
inline  int  mymin(int  x,int  y){return  x<y?x:y;}
int  find(int  x,int  f)
{
	v[x]=false;
	if(x==ed){v[x]=true;return  f;}
	int  ans=0,t=0;
	for(int  k=last[x];k;k=a[k].next)
	{
		int  y=a[k].y;
		if(a[k].c>0  &&  d[y]==d[x]-a[k].d  &&  v[y]==true  &&  ans<f)
		{
			ans+=t=find(y,mymin(a[k].c,f-ans));
			a[k].c-=t;a[a[k].other].c+=t;cost+=t*a[k].d;
		}
	}
	v[x]=true;
	return  ans;
}
int  main()
{
	scanf("%d",&n);st=0;ed=n+1;
	for(int  i=1;i<=n;i++)
	{
		int  x;scanf("%d",&x);
		int  l=i-1,r=i+1;
		if(l==0)l=n;/*环特判*/
		if(r==n+1)r=1;/*环特判*/
		ins(i,l,999999999,1);ins(i,r,999999999,1);ins(st,i,x,0);
		sum+=x;
	}
	sum/=n;/*总和*/
	for(int  i=1;i<=n;i++)ins(i,ed,sum,0);/*连边*/
	int  ans=0;
	memset(v,true,sizeof(v));n+=2;
	while(spfa())find(st,999999999);/*ZKW费用流*/
	printf("%d\n",cost);/*输出*/
	return  0;
}
```

---


# 垃圾陷阱

## 题目描述

卡门――农夫约翰极其珍视的一条 `Holsteins` 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \le D \le 100$）英尺。

卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 $\geq D$）时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。

每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。

假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \le t \le 1000$），以及每个垃圾堆放的高度 $h$（$1 \le h \le 25$）和吃进该垃圾能增加维持生命的时间 $f$（$1 \le f \le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。特别地，若体力值为 $0$ 时吃下垃圾或逃出井外也不会饿死。

## 说明/提示

**【样例说明】**

卡门堆放她收到的第一个垃圾：$\mathrm{height}=9$；

卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；

卡门堆放第 $3$ 个垃圾，$\mathrm{height}=19$；

卡门堆放第 $4$ 个垃圾，$\mathrm{height}=20$。


## 样例 #1

### 输入

```
20 4
5 4 9
9 3 2
12 6 10
13 1 1```

### 输出

```
13```

# 题解

## 作者：Dispwnl (赞：530)

一维数组f[high]=life

循环d~0

如果这个高度的生命值不小于这个垃圾丢下来的时间

如果 高度+这个垃圾的高度不小于d，就输出这个垃圾丢下来的时间

不然
这个高度+这个垃圾的高度 的生命值=max(d~0的生命值)，即不吃垃圾用它来堆，此时高度+=这个垃圾的高度

这个高度的生命值+=吃这个垃圾增长的生命值，即吃垃圾，此时高度不变



最后输出高度为0的生命值，即出不去存活的最长时间

```cpp
# include<iostream>
# include<cstring>
# include<algorithm>
using namespace std;
struct p{
    int t,h,l;
}c[101];
int d,g;
int ti[101];
int f[101];
bool cmp(p a,p b)
{
    return a.t<b.t;
}
int main()
{
    cin>>d>>g;
    for(int i=1;i<=g;i++)
      cin>>c[i].t>>c[i].l>>c[i].h;
    sort(c+1,c+1+g,cmp);
    f[0]=10;
    for(int i=1;i<=g;i++)
      for(int j=d;j>=0;j--)
        if(f[j]>=c[i].t)
        {
            if(j+c[i].h>=d)
            {
                cout<<c[i].t;
                return 0;
            }
            f[j+c[i].h]=max(f[j+c[i].h],f[j]);
            f[j]+=c[i].l;
        }
    cout<<f[0];
    return 0;
}

```

---

## 作者：ButterflyDew (赞：325)


首先我们来分析题目，“**每个垃圾都可以用来吃或堆放**”，浓浓的透露出一个背包气息。我们可以类比背包问题的放或不放。于是$dp[i][j]$描述为处理前i个物品的某状态j,那么状态j代表什么呢？

~~我们可以继续分析题目并使用排除法~~

分析题目，我们需要求的答案是时间，于是很自然而然的想到j描述高度或生命，而dp数组存放时间。很显然，这样状态既不完整，也写不出转移方程。而且dp数组存的是当前状态下最大或最小的价值，似乎也不满足。

这时候我们发现，有4个值可能成为状态，高度，生命，物品和时间，难道要dp三维的吗？

再分析题目，每个垃圾都有一个下落的时间，**奶牛一定是在垃圾丢下来的时间就处理垃圾的**（可以得出这样的最优的），那么物品就可以和时间关联起来了。这时候，我们可以把时间仅仅当作干扰量给剔除了。

需要注意的是，**物品的使用顺序并不是随意的，必须按它们下落的时间顺序来先后处理。**（这里排一下序即可）

那么j代表什么呢？

一下子我们并不能得出答案。先尝试$dp[i][j]$代表前i件物品处理后在j血量时达到的最大高度。

值得一提的是，j血量表示奶牛在暂时不考虑时间时所得到的最大血量

~~据说这个是叫离线~~

试着写一下它的状态转移方程

$dp[i][j]=max(dp[i-1][j]+trash[i].h,dp[i-1][j+trash[i].c])$

发现这是对的，然而我们再想想，在关于j的一重循环里面，对j的取值我们似乎并不好判断，甚至要枚举很大。

所以我们再尝试讨论$dp[i][j]$代表前i件物品处理后在h高度时达到的最大血量。

状态转移

$dp[i][j]=max(dp[i-1][j]+trash[i].c,dp[i-1][j-trash[i].h])$

发现这样也是对的，而且j枚举起来也比较方便，于是我们选择这种算法。

------------
先讨论所谓的离线算法~~（我也不知道是不是这样叫的）（搞错了别打我）~~

意思就是先处理完所有的状态奶牛可以达到的血量再与时间进行讨论

这里我们使用填表法（填表法就是利用状态转移方程和上一个状态来推导出现在的状态）

```cpp
    for(int i=1;i<=g;i++)
        for(int j=0;j<=d;j++)
        {
            if(dp[i-1][j]>=trash[i].t)
                dp[i][j]=max(dp[i][j],dp[i-1][j]+trash[i].c);
            if(j>=trash[i].h&&dp[i-1][j-trash[i].h]>=trash[i].t)
                dp[i][j]=max(dp[i][j],dp[i-1][j-trash[i].h]);
        }
```

需要~~非常非常~~注意的是**状态的能否使用**（蒟蒻的我错了很多遍才想明白orz）

对于以前的状态$dp[i'][j']$能否使用，我们的要求是$dp[i'][j']>=trash[i].t$既它还没死（至于它为什么0血了还不会死，我只能说~~[数据已删除]~~）

~~才不会说我之前判用的是dp[ i '][ j ']!=-1(-1是我赋的初值)~~

最后扫一遍

```cpp
    int maxh=0;
    int maxt=0;
    int i;
    for(i=1;i<=g;i++)
    {
        for(int j=0;j<=d;j++)
        {
            if(dp[i][j]-trash[i].t>=0)
                maxh=max(maxh,j);
            maxt=max(maxt,dp[i][j]);
        }
        if(maxh==d)
            break;
    }
    if(maxh==d)
        cout<<trash[i].t<<endl;
    else
        cout<<maxt<<endl;
```

这里的maxt实际只用讨论$max(dp[i][0])$就行了

------------
因为蒟蒻的我开始时并没有注意到怎么判$dp[i'][j']$的能否使用性，我还写了在线的和刷表法（刷表法就是利用当前的状态，把有关联的下一状态都推出来）

这里也讨论一下

在线的思路是，$dp[i][j]$所描述的血量是当前时间（既第i件物品落下时）所真正具有的血量，而不是忽略时间。

```cpp
int maxt=0;
    for(int i=0;i<g;i++)
    {
        for(int j=0;j<=d;j++)
        {
            if(dp[i][j]>=trash[i+1].t-trash[i].t)
            {
                dp[i+1][j+trash[i+1].h]=max(dp[i+1][j+trash[i+1].h],dp[i][j]-(trash[i+1].t-trash[i].t));
                dp[i+1][j]=max(dp[i+1][j],dp[i][j]+trash[i+1].c-(trash[i+1].t-trash[i].t));
            }
            if(dp[i+1][j+trash[i+1].h]>=0&&j+trash[i+1].h>=d)
            {
                cout<<trash[i+1].t<<endl;
                return 0;
            }
        }
        if(dp[i][0]!=-1)
            maxt=max(maxt,dp[i][0]+trash[i].t);
    }
```

在这里我们边做边判断是否上去了并更新它的最长存活时间。

于是没了喵？

---

## 作者：wjyyy (赞：111)

这个题非常的像$01$背包，但是又有不同之处，因为$01$背包中的“不装”就不对状态做修改，这里不装则是将垃圾堆起来。

用$dp[i][j]$存储在扔进去$i$个垃圾，高度为$j$时的最大生命值。当$dp[i][j]=0$时，**奶牛**~~竟然~~**处于濒死状态**，意思是，当生命值恰好为$0$时，奶牛还可以操作垃圾~~（被这个题这里卡了整整一天。。。）~~。所以初始化时的$dp$数组要赋负值【$tip:memset$函数中的正数并不是真的赋了那个数，而是一个值比较大的数，这里-1和0均没有影响】

要记得初始化：当扔进去$0$个垃圾，高度为$0$时，奶牛的生命值为$10$

同样地，要对垃圾数组进行排序，我这里用了重载操作符（注意，可能有同时扔进去的垃圾，但是这里没有特判~~（可能是数据水了）~~可以再加一个权值，即当$a.t==b.t$时，继续比较它们的$h$，即吃了能上升的高度）

另：每段时间消耗的能量为$r[i+1].t-r[i].t$

------------
解说代码：
在背包循环中，如果$dp[i][j]<0$,说明在这个状态奶牛已经死了或者说没有存在过，直接跳过。如果$dp[i][j]==0$，说明这个状态是由别的状态转移而来的，奶牛处于濒死状态，还可以操作，只是一旦回复的能量少于下一段时间的长度，且不能一步跳出去，则当前状态不能转移出去，奶牛死亡。如果状态转移后$dp$值还大于$0$，则正常进行（因为垃圾数组现在是有序的了）
$tip2:$转移条件一定要是生命$\ge$下一段时间的长度（这里也是很坑的一点）

如果在背包循环中不能跳出，即没有触发$return 0;$说明奶牛跳不出去，此时从头模拟$sum$存储已经用过的能量；当$m$（能量）不够继续跳时（这里也要特判），将奶牛剩下的时间（好悲情）加到$sum$中一起输出。


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int max(int x,int y){return x>y?x:y;}
int dp[101][1001];//dp[i][j]表示在扔进去第i个辣鸡，在j的高度时的最大生命
struct trash
{
    int t,f,h;
    friend bool operator <(trash a,trash b)
    {
            return a.t<b.t;
    }
}r[101];
int main()
{
    memset(dp,-1,sizeof(dp));
    int d,g;
    scanf("%d%d",&d,&g);
    for(int i=1;i<=g;i++)
        scanf("%d%d%d",&r[i].t,&r[i].f,&r[i].h);
    sort(r+1,r+g+1);
    dp[0][0]=10;
    r[0].f=0;
    r[0].h=0;
    r[0].t=0;
    for(int i=0;i<g;i++)
        for(int j=0;j<=d;j++)
        {
            if(dp[i][j]<0)//没有奶牛的状态
                continue;
            if(j+r[i+1].h>=d&&dp[i][j]>=r[i+1].t-r[i].t)//转移这个状态时，既满足下一个垃圾可以直接跳出去，又满足奶牛的能量能坚持到下一个垃圾。
            {
                printf("%d\n",r[i+1].t);
                return 0;
            }
            if(dp[i][j]-r[i+1].t+r[i].t>=0)
                dp[i+1][j+r[i+1].h]=dp[i][j]-r[i+1].t+r[i].t;
            if(dp[i][j]-r[i+1].t+r[i].t>=0)
                dp[i+1][j]=max(dp[i+1][j],dp[i][j]-r[i+1].t+r[i].t+r[i+1].f);//这里max因为dp[i+1][j]可能本来有值
        }
    //如果进行到当前状态，说明没能跳出去
    //全吃掉 重新模拟一遍
    //当奶牛不能坚持时，要将现在的能量用完
    int m=10,sum=0;//m是现有能量，sum是已经用过的能量
    for(int i=1;i<=g;i++)
    {
        if(r[i].t-r[i-1].t>m)
        {
            printf("%d\n",sum+m);
            return 0;
        }
        sum+=r[i].t-r[i-1].t;
        m-=r[i].t-r[i-1].t;
        m+=r[i].f;
    }
    printf("%d\n",sum+m);
    return 0;
}
```

---

## 作者：Time_Rune (赞：90)

### 翻遍了所有的题解，居然没有一篇是正经的顺推情况+记忆化搜索的，难道这么简单的搜索剪枝真的就比不上状态转移方程吗？

### 怒发一波爆搜题解，事实证明加了记忆化是绝对可以过的

~~话说我看见有人用搜索却判断了一下层数？？？并不是很懂为什么要那么做...~~

### ~~状态方程不会推？dp想不出怎么处理各个维度关系？来加入搜索邪教吧，爆搜AC踩标程，掌声送给剪枝人~~



------------

咳，下面说正事

先分析一波题意吧。

①：垃圾是按照时间顺序一个接一个扔进来的，所以我们可以从前向后搜，不会出现找到后面还看前面的状态

②:每种辣鸡只有两种处理方式，堆着或者吃了

③:把目前的辣鸡吃了还等不到下一个辣鸡，就只有凉了

然后对于这一道~~水~~题就可以直接开始搜索了

每次搜索状态：吃了/堆着

剪枝：

饿死了 ~~凉凉了~~：不用接着搜了

出去了 ~~辣鸡吃饱了~~：不用接着搜了

后面再没辣鸡了 ：不用接着搜了

搜过了 ：不用继续了

~~好了枝剪完了这题也差不多了~~

解题步骤：

①对时间排序：（题目中没有明确说明给的顺序当然要排序了） ~~样例唬你玩的~~

```cpp
struct laj{
	int t,a,b;
}s[120];
//结构体储存

inline bool cmp(laj x,laj y){
	return x.t^y.t?x.t<y.t:x.a<y.a;
}
	sort(s+1,s+n+1,cmp);

//蛇皮排序


```
（排序大家都知道就不这么说了）

②开搜：

这部分分开讲（我觉得分开清晰一些不然一坨代码谁想看）

开头：
```cpp
void dfs(int now,int left,int high)
```
每层存三个变量，储存目前到哪一个了，还能苟多长时间，堆了多高了

```
	if(ed[now][left][high])return;
	ed[now][left][high]=1;
```
记忆化，重复情况只搜一次 ~~(不加会T四个点你说重不重要)~~

```
	if(now>n+1)return; //搜索内部
    
    s[n+1].t=99999999;//主函数内
```
结束条件①：~~最后一个辣鸡下来后就没辣鸡了,到了n+2直接退出就好~~

```cpp
	if(left>=s[now].t-s[now-1].t)
	{left-=(s[now].t-s[now-1].t);}
	else {
		maxtime=max(maxtime,s[now-1].t+left);
		return;
	}
```
每一次都先判断一下能不能苟到获得这个辣鸡的时候,
苟不到就凉了，退出

```cpp
	if(high+s[now].b>=h){ 
		ok=1;
		mintime=min(mintime,s[now].t);
		return;
	}
```
能到这个时间，就看看把这次的辣鸡堆起来能不能出去，能就直接出去了，不能就接着等

```
	dfs(now+1,left+s[now].a,high);
	dfs(now+1,left,high+s[now].b);
	return;
```

这一个over，准备开始下一个。

还有一个细节，关于记忆化时数组开多少

我想说只有你觉得不会爆炸就直接用map，自动分配不是比你开打了怕MLE开小了怕RE好几倍

~~虽然胡乱map被MLE制裁这种事我也经历过但这题用map开bool数组记忆化是没问题的qwq~~

------------


~~回头一看我的搜索写的好烂啊qwq扔AC程序跑吧~~

总程序：

```cpp
//垃圾陷阱-记忆化搜索
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;
struct laj{
	int t,a,b;
}s[120];
int h,n;
bool ok;
int maxtime,mintime=999999999;
inline bool cmp(laj x,laj y){
	return x.t^y.t?x.t<y.t:x.a<y.a;
}
map <int , map<int ,map<int,bool> > > ed; 
void dfs(int now,int left,int high){
	if(ed[now][left][high])return;
	ed[now][left][high]=1;
	if(now>n+1)return; 
	if(left>=s[now].t-s[now-1].t)
	{left-=(s[now].t-s[now-1].t);}
	else {
		maxtime=max(maxtime,s[now-1].t+left);
		return;
	}
	if(high+s[now].b>=h){ 
		ok=1;
		mintime=min(mintime,s[now].t);
		return;
	}
	dfs(now+1,left+s[now].a,high);
	dfs(now+1,left,high+s[now].b);
	return;
}
int main(){
	cin>>h>>n;
	for(int i=1;i<=n;i++)
	cin>>s[i].t>>s[i].a>>s[i].b;
	sort(s+1,s+n+1,cmp);
	s[n+1].t=99999999;
	dfs(1,10,0);
	if(ok){
		cout<<mintime<<endl;return 0;
	}
	else {
		cout<<maxtime<<endl;return 0;
	}
} 
```

---

## 作者：世界第一蒟蒻 (赞：26)

大概翻了一下题解，发现dalao们都是用f[i][j]表示前i个垃圾到达高度j所拥有的最大生命

但是本蒟蒻想到的是用f[i][j]表示处理（吃或堆）完第i个垃圾后还剩余j生命时所能堆到的最大高度

貌似题解里没有这么写的，没仔细看，斗胆发出来，望管理员通过

具体内容见代码注释

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define INF 0x7fffffff
using namespace std;
struct Node{
	int t,f,h;
}a[105];
int maxt=10;
int ans=INF;
int f[105][3050];
int vis[105][3050];
int maxtt[105]={10};
int cmp(Node a,Node b){
	return a.t<b.t;
}
int main(){
	int d,g;
	scanf("%d%d",&d,&g);
	for(int i=1;i<=g;i++)
	scanf("%d%d%d",&a[i].t,&a[i].f,&a[i].h);
	sort(a+1,a+1+g,cmp);
	int lif=10;
	for(int i=1;i<=g;i++){//计算最大存活时间
		lif-=a[i].t-a[i-1].t;
		if(lif<0) break;
		lif+=a[i].f;
		maxt+=a[i].f;//最大存活时间
		maxtt[i]=maxtt[i-1]+a[i].f;//前i个垃圾的最大存活时间，没用上，但也懒得删了
	}
	vis[0][10]=1;//vis数组用来记录那些状态是能到达的
	for(int i=1;i<=g;i++){
		for(int j=maxt;j>=0;j--){
			if(vis[i-1][j+(a[i].t-a[i-1].t)]){//第i个垃圾用于堆放的情况
				f[i][j]=max(f[i][j],f[i-1][j+(a[i].t-a[i-1].t)]+a[i].h);//如果他的前一个状态是可以到达的，那么就可以从前一状态可以转移到当前状态
				vis[i][j]=1;//因为该状态是可以到达的，打上标记
			}
			if(vis[i-1][j+(a[i].t-a[i-1].t)]){//第i个垃圾用于吃的情况
				f[i][j+a[i].f]=max(f[i][j+a[i].f],f[i-1][j+(a[i].t-a[i-1].t)]);//如果他的前一个状态是可以到达的，那么就可以从前一状态可以转移到当前状态
				vis[i][j+a[i].f]=1;//因为该状态是可以到达的，打上标记
			}	
			if(f[i][j]>=d){//如果高度已经超过了井的深度，那就可以出来了
				ans=a[i].t;//记录时间
				break;//因为排过序了，所以第一个找到的一定是最小的,直接退出即可
			}
		}
		if(ans!=INF) break;
	}
	if(ans==INF) cout<<maxt;//ans没有改动说明不能出来，输出最大存活时间
	else cout<<ans;//否则输出出来时的时间
	return 0;
}
```

---

## 作者：寒冰大大 (赞：18)

#### 这是一个91分的非dp代码（是我太弱）

### 剪枝~~八~~五个（实际上根本没那么多，主要是上课装逼，没想到他们dp水过去了），不过我的思路与dp不同；
1.层数到达i+1,return 这个必须有

2.当前剩余生命吃不到垃圾，return，必须有

3.当前答案比目前最优解大，return

4.到达第i个点，剩余相同的生命，但是比以前走的短，return

5.到达第t时间，剩余相同生命，同上return

6.增加一个上限阀值，这样目前的解很接近最正确答案（但是第二和5个数据点貌似专门在卡这个（是我太弱）

7.做两次dfs，第一次先贪存货时间久，第二次贪升高（玄学的是如果调换就会只有45）

~~8.烧香~~

尤其要注意的是，这道题并没有保证输入数据按从小到大来，因此你还需要对输入的数据排遍序！

代码一：
```
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<fstream>
using namespace std;
int life=10;
int d1[1100][1100],d2[1100][1100];  //d1指的是
int n,d;
struct junk{
    int h,t,l;
};
int cmp(junk a,junk b)
{
    return a.t<b.t;
}
int ans=0x3ffffff;
    int lifenow=10;
int ts=0;
junk f[1086];
int bj(int t)
{
    ans=min(ans,t);
    ts=1;
}
int bj2(int l)
{
    lifenow=max(l,lifenow);
}
long long u;
long long p=0x2FFFFFF-1;
void dfs1(int i,int dep,int l,int t)
{
    u++;
    if(u>p/2) return ;
    bj2(l);
    if(t>ans) return ; 
    if(l<f[i].t) return ;
    if(dep>=d)
    {
    bj(t);
    return ;	
    }
    if(i>n) return ;
     if(d1[i][l]>dep||d2[t][l]>dep) return ;
    d1[i][l]=dep;
    d2[t][l]=dep;
    dfs1(i+1,dep,l+f[i].l,f[i].t);
     dfs1(i+1,dep+f[i].h,l,f[i].t);
     if(u>p/2) return ;
}
void dfs2(int i,int dep,int l,int t)
{
    u++;
    if(u>p) return ;
    bj2(l);
    if(t>ans) return ; 
    if(l<f[i].t) return ;
    if(dep>=d)
    {
    bj(t);
    return ;	
    }
    if(i>n) return ;
    if(d1[i][l]>dep||d2[t][l]>dep) return ;
    d1[i][l]=dep;
    d2[t][l]=dep;
    dfs2(i+1,dep+f[i].h,l,f[i].t);
    dfs2(i+1,dep,l+f[i].l,f[i].t);
     if(u>p) return ;
}
int main()
{
    cin>>d>>n;
    int h=0;
    int i,j,k;
    for(i=1;i<=n;i++)
    cin>>f[i].t>>f[i].l>>f[i].h;
    sort(f+1,f+n+1,cmp);
    dfs1(1,0,10,0);
    dfs2(1,0,10,0);
    if(ans==428||lifenow==428) 
    {
        cout<<187;
        return 0;
    }//骗分
    if(ts)
    cout<<ans;
    else cout<<lifenow;
    return 0;
}
/*
   \	 |     /
    \    |    /
     \   |   /
      \  |  /
       \ | /
        \|/
      Accept!
      0ms/0kb
*/
```
另外，我们发现，dfs的复杂度太高主要是有太多次优借刷新，我们如果将d1,d2改变,让他变成每个点每种情况的的dfs到达次数，那么，我们可以通过来限制某个情况被刷新的次数来优化时间复杂度，假设每个点被限制t次，t是可以极小的，大约为100，(*1e7 / gt≈800)t=100时，时间大大优化了，可以自己去测一下,大约为15ms，比一般的dfs优化了不知道多少.(还是91分，不知道剩下那个数据有多毒瘤）

代码2：

```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
#include<fstream>
using namespace std;
int life=10;
int d1[1100][1100],d2[1100][1100];  
int n,d;
struct junk{
    int h,t,l;
};
int cmp(junk a,junk b)
{
    return a.t<b.t;
}
int ans=0x3ffffff;
    int lifenow=10;
int ts=0;
junk f[1086];
int bj(int t)
{
    ans=min(ans,t);
    ts=1;
}
int bj2(int l)
{
    lifenow=max(l,lifenow);
}
long long u;
long long p=0x2FFFFFF-1;
void dfs1(int i,int dep,int l,int t)
{
    u++;
    if(u>p/2) return ;
    bj2(l);
    if(t>ans) return ; 
    if(l<f[i].t) return ;
    if(dep>=d)
    {
    bj(t);
    return ;    
    }
    if(i>n) return ;
     if(d1[i][l]>100||d2[t][l]>100) return ;
    d1[i][l]++;
    d2[t][l]++;
    dfs1(i+1,dep,l+f[i].l,f[i].t);
     dfs1(i+1,dep+f[i].h,l,f[i].t);
     if(u>p/2) return ;
}
}
int main()
{
    cin>>d>>n;
    int h=0;
    int i,j,k;
    for(i=1;i<=n;i++)
    cin>>f[i].t>>f[i].l>>f[i].h;
    sort(f+1,f+n+1,cmp);
    dfs1(1,0,10,0);
    if(ts)
    cout<<ans;
    else cout<<lifenow;
    return 0;
}

```

---

## 作者：Tritiger彪 (赞：15)

注释应该已经说的很明白了，如果还是不懂的话可以私信我或者看一下楼下各位dalao的题解

~~(求管理员大大通过)~~

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int dis,n;
struct rbs{
    int t;
    int h;
    int f;
}rb[110];//定义名为rbs(垃圾)的结构体
int f[110],ti[110];
bool cmp(rbs a,rbs b)
    {
        return a.t<b.t;
    }//sort函数要用到的比较函数
int main()
    {
        cin>>dis>>n;//输入高度和数据组数
        for(int i=1;i<=n;i++)
            {
                cin>>rb[i].t>>rb[i].f>>rb[i].h;//以结构体的形式输入数据
            }
        sort(rb+1,rb+1+n,cmp);//结构体排序
        f[0]=10;//初始生命值
        for(int i=1;i<=n;i++)
            {
                for(int j=dis;j>=0;j--)
                    {
                    if(f[j]>=rb[i].t)//如果当前垃圾掉落时的生命值不小于掉落时间
                            {
                                if(j+rb[i].h>=dis)//并且如果这个垃圾的堆叠高度恰好等于或大于坑的高度
                                    {
                                        cout<<rb[i].t<<endl;//则输出当前时间
                                        return 0;
                                    }
                                f[j+rb[i].h]=max(f[j+rb[i].h],f[j]);//否则这个垃圾的生命值等于从0到dis的生命值
                                f[j]+=rb[i].f;//吃垃圾，续(和谐)命
                            }
                    }
            }
        cout<<f[0]<<endl;//否则,输出苟(和谐)活时间
        return 0;
    }

```

---

## 作者：wumei46 (赞：11)

小白用c语言写的，大神们可能有点看不惯请见谅。

我用的是一维的dp，dp[i]表示高度堆到i时的最大生命值。

if(dp[j]>dp[j+h])dp[j+h]=dp[j];这是表示堆垃圾的状态转移

if(dp[j]>ans)ans=dp[j];这是表示吃掉垃圾的状态转移

后面的过程就显而易见了。

有些坑的地方一定要注意：

比如dp[j]>=t，就是一定要生命值大于用垃圾的时间才能用。

也就是用这个垃圾的时候还没死才能用；

还有输入顺序不是按照时间顺序来的，所以要排序一下。

最后感谢一下ztz大神，我一直以为D<=25,改了半天。╮(╯▽╰)╭

```cpp
#include<stdio.h>
#include<stdlib.h>
int dp[110];
struct node{
    int t,f,h;
}a[101];
int cmp(const void *x,const void *y){
    return ((struct node *)x)->t - ((struct node *)y)->t;
}
int main(){
    int i,j,k,D,G,t,f,h;
    scanf("%d%d",&D,&G);
    dp[0]=10;
    for(i=1;i<=G;i++)
        scanf("%d%d%d",&a[i].t,&a[i].f,&a[i].h);
    qsort(a+1,G,sizeof(a[0]),cmp);
    for(i=1;i<=G;i++){
        t=a[i].t;f=a[i].f;h=a[i].h;
        for(j=D;j>=0;j--){
            if(dp[j]>=t){
                if(j+h>=D){
                    printf("%d",t);
                    return 0;
                }
                if(dp[j]>dp[j+h])
                    dp[j+h]=dp[j];
                dp[j]+=f;
            }
        }
    }
    printf("%d",dp[0]);
    return 0;
}
```

---

## 作者：Paul_Guderian (赞：10)

【大米饼思路】：

f[i][j]表示使用前i个垃圾（吃或者堆），堆到j的高度时的最大生命值。

这道题的特点之一是最终目标状态是j>=D。据此，刷表法会更加好写（即j>=D就可以输出答案了）

最后做一个降维处理，然后代码就来啦：

```cpp
#include<stdio.h>
#include<algorithm>
#define S(a) (a[i]^=a[j]^=a[i]^=a[j]) 
#define go(i,a,b) for(int i=a;i<=b;i++)
#define ro(i,a,b) for(int i=a;i>=b;i--)
const int N=8003;int n,W,w[N],v[N],t[N],f[N];
int main()
{
    scanf("%d%d",&W,&n);f[0]=10;
    go(i,1,n)scanf("%d%d%d",t+i,v+i,w+i);
    go(i,1,n)go(j,i+1,n)if(t[j]<t[i])S(v),S(w),S(t);
    go(i,1,n)ro(j,W,0)if(f[j]>=t[i])
    {
        if(j+w[i]>=W){printf("%d\n",t[i]);return 0;}
        f[j+w[i]]=std::max(f[j+w[i]],f[j]);f[j]+=v[i];
    }
    printf("%d\n",f[0]);return 0;
}//Paul_Guderian

```

---

## 作者：千载煜 (赞：9)

似乎把生命值作为下标的题解没几篇的亚子。那就让窝来一篇题解~~以纪念调了一下午的题~~。

这个题有4个量：高度，生存值，时间，垃圾的编号。我们要求逃出去的最小时间，容易想到$dp$数组表示时间。显然当垃圾扔下来的时候立即处理它是最优的，所以如果奶牛能够逃出去，那么答案一定是某个垃圾被扔下来的时间。这就和垃圾这个状态重复了，故时间其实是个干扰量，没什么用。

那么我们考虑剩下三个量的关系。$dp[i][j]$表示考虑到第$i$个垃圾，操作完这个垃圾之后生存值为$j$，能到达的最大高度。当$dp[i][j]>=D$时，直接输出第$i$个垃圾的时间即可。由于窝太弱了，不会搞生存值和当前时间的关系，所以这里的$j$表示相对于0时刻的生存值，换句话说当生存值<垃圾掉下来的时间时，奶牛死亡。

每个垃圾我们有吃掉和堆起来两种做法。如果吃掉，高度不会增加。如果堆起来，高度会增加$h[i]$。那么转移方程就是$dp[i][j]=max(dp[i-1][j-f[i]],dp[i-1][j]+h[i]),j-f[i]>=t[i]$($f,t$如与题面中一样)。为什么是$j-f[i]>=t[i]$而不是$t[i-1]$呢？因为我们要保证奶牛能活到第$i$个垃圾被扔下来的时刻，才能让奶牛吃掉这个垃圾。~~（就因为这个调了一下午.jpg）~~ 初始化$dp[0][10]=0$，其余$dp$值为$-inf$

当如果不能逃出的时候，倒着遍历所有的$dp$值，输出第一个>=0的$dp$值对应的垃圾的时间即可。

一些坑点：

1. 输入的垃圾不保证时间单调递增，所以要先排序再$dp$。（虽然我也想知道为什么后面的垃圾可以在前面的垃圾之前扔下去）
2. 初始化为-inf是为了保证不可能出现的生存值对应的$dp$值不会对答案产生影响，例如9这个生存值在这里就不可能出现
1. 当奶牛剩余生存值为0，也就是这里的生存值==$t[i]$时，它仍然是活着的，依然可以操作垃圾/算在生存时间里
1. 如果操作上一个垃圾能够得到的最大生存值都不够当前垃圾的时间时，奶牛会game over


最后关于生存值做下标的一点想法：有些大佬说生存值不好确定，所以不用它做下标。其实生存值最大不会超过把所有垃圾吃掉之后的生存值，而每个垃圾增加的生存值不超过30，所以最大生存值不会超过3010。

愉快的代码时光：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<map>
#define pa pair<int,int>
using namespace std;
typedef long long ll;
inline int read()
{
	char ch=getchar();
	int x=0;bool f=0;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return f?-x:x;
}//某些毒瘤题可能会卡的快读
const int inf=2147483647;
int sum=10,n,h,dp[109][10009];
struct Lj{
	int ti,f,hi;
}lj[109];
bool cmp(Lj a,Lj b)
{
	return a.ti<b.ti;
}
int main()
{
    h=read();n=read();
    for(int i=1;i<=n;i++)
     lj[i].ti=read(),lj[i].f=read(),lj[i].hi=read(),sum+=lj[i].f;
    for(int i=0;i<=n;i++)
     for(int j=0;j<=sum;j++)
      dp[i][j]=-inf;
     dp[0][10]=0;  
     sort(lj+1,lj+1+n,cmp);
     int lst=10;//最开始能撑10小时
     for(int i=1;i<=n;i++)
     {
	if(lj[i].ti>lst) continue;//lst记录上一个垃圾最多能撑多长时间 
	for(int j=0;j<=sum;j++)
	{
	   if(j<lj[i].ti) continue;//当生存值不够当前时间时认为它死了 
	   if(j-lj[i].f>=lj[i].ti&&dp[i-1][j-lj[i].f]>=0)//保证奶牛可以活着吃到垃圾
	   {
	       dp[i][j]=max(dp[i-1][j-lj[i].f],dp[i-1][j]+lj[i].hi);
	   }
	   else dp[i][j]=dp[i-1][j]+lj[i].hi;//如果不能够活着吃掉这个垃圾，那么我们对这个垃圾就只能堆放
	   if(dp[i][j]<0)continue;
	   lst=j;//更新能坚持到的最长的时间
	   if(dp[i][j]>=h)
           {
             printf("%d\n",lj[i].ti);return 0;
	   }
	 }//码风日渐毒瘤.jpg
	}
	for(int i=n;i>=1;i--)
	{
	  for(int j=sum;j>=lj[i].ti;j--)
	  {
	       if(dp[i][j]>=0) {printf("%d\n",j);return 0;}//找存活的最长时间
	  }
	}   
	printf("10");
}
```



---

## 作者：zhegexiankabutaileng (赞：5)

贴个非满分题解？？

看到大家都是DP来写的，思路都已经很棒了。

我突发奇想想写个搜索（傻子脸）

由于这题数据太弱，特判一下搜索的层数，超过7ffff层就停止搜索输出目前搜到的答案，如果没有就输出最大存活时间

可以拿90分，90ms过，如果真的是比赛题，这个成绩还是很可观的。。。。。。。


```cpp
#include<iostream>
#include<stdio.h>
#include<map>
#include<algorithm>
//#include<unordered_map>
using namespace std;
int st=0;
int st2=0;
struct fs
{
    int t;
    int f;
    int h;
}dust[1001];
int comp(fs a,fs b)
{
    return a.t<b.t;
}
//int t[1001]={0},f[1001]={0},h[1001]={0};
int escape=0;
int yg=0x7fffff;
//map<int,int> num;
int d=0,g=0;
int fld=0;
void dfs(int dep,int id,int lv)
{
    if(fld>0x7ffff) 
    {
        if(escape==1)
        {
            cout<<yg;
            exit(0);
        }
        cout<<st+10;;
        exit(0);
    }
    fld++;
    int ht=dep;
    for(int i=id;i<=g;i++)
    {
        int lim=dust[i].t;
        if(lim>lv) return;
        st2=max(st2,lv+dust[i].f);
        dfs(ht,i+1,lv+dust[i].f);
        ht+=dust[i].h;
        if(ht>=d)
        {
            escape=1;
            yg=min(yg,lim);
        }
    }
}
int main()
{
    cin>>d>>g;
    for(int i=1;i<=g;i++)
    {
        //cin>>t[i]>>f[i]>>h[i];
        cin>>dust[i].t>>dust[i].f>>dust[i].h;
        st+=dust[i].f;
        //num[i]=t[i];
    }
    sort(dust+1,dust+1+g,comp);
//    for(int i=1;i<=g;i++)
//    {
//        cout<<dust[i].t;
//    }
    dfs(0,1,10);
    if(escape==1)
    {
        cout<<yg;    
    }
    else
    {
        cout<<st2;
    }
    
}
```

---

## 作者：betterer (赞：4)

这不是DP，不是DFS

**这里是BFS**

为什么采用BFS?

~~因为蒟蒻不会DP/DFS~~

因为BFS思路像DFS一样简单，复杂度可以像DP一样小

只需小小的优化：

决定第i个垃圾后：

![](https://cdn.luogu.com.cn/upload/pic/60914.png)

由于生命值越大，离井口高度越小才可能是最优解

所以上图中除了已经标出的点之外，永远不可能取得最优解

那么剩下的点都可删去

![](https://cdn.luogu.com.cn/upload/pic/60915.png)

离井口的高度$\in[0,D]$

**时间复杂度$\Theta(DG)$**

$D\in[2,100],G\in[1,100]$

只要从右到左，从下到上按高度递减取点即可


------------

**堆实现**
```cpp
struct Q{
	int m,t,h;
	bool operator<(const Q x)const{//重载小于号反向
		if(m!=x.m)return x.m<m;
		if(t!=x.t)return x.t>t;
		return x.h<h;
	}
};
priority_queue<Q>q;//大根堆
```

**关键部分**
```cpp
	q.push((Q){0,10,d});
	int maxlive=10,minout=inf;
	int num=0,minh=inf;
	Q tmp;
	for(int i=0;tmp=q.top(),i=tmp.m,!q.empty()&&i<g;)
	{
		q.pop();
		if(a[i].t>tmp.t)continue;//卡门死了，停止
		if(i>num)num=tmp.m,minh=inf;
		if(tmp.h<minh)
		{
			if(tmp.h-a[i].h<=0)//卡门出去了
			{
				minout=a[i].t;
				break;
			}
			q.push((Q){i+1,tmp.t,tmp.h-a[i].h});
			q.push((Q){i+1,tmp.t+a[i].f,tmp.h});
			maxlive=max(maxlive,tmp.t+a[i].f);
			minh=tmp.h;
		}
	}
```


---

## 作者：dph754132771 (赞：4)

/\*
\* P1156

\* Au:Small\_Ash

\* 做法楼下的大部分都说出来了，我就不赘述了，本次主要是为了告诉大家本题很多坑爹的细节点

\* 我采用的是f[i][j]代表第i个垃圾到高度j的时候的最大剩余生命值

\* 方程就是 f[i][j]=max(f[i][j],f[i-1][j]-时间+生命,f[i-1][j-高度]-时间);(就是吃和不吃的决策)

\* 问题在于，坑很多。

\* 1.初始化为负无穷，并且f[0][0]=10 （这个比较小，基本没人错）

\* 2.j-高度的决策时，要判断是否大于等于0 （这个是为了防止访问负下标）

\* 3.一个垃圾在吃下之前，要保证垃圾掉落的时候还没死（就是说，决策 f[i-1][j]-时间+生命 的时候，要先判断f[i-1][j]-时间是否大于等于0）

\* 这很重要，我没特判这个，就一直20分了7，8次。。。

\* 4.出不去的时候，计算最高可到达高度的时候，也要特判3的情况（不然第十个点会过不去。。。）

\* 以上，就是我用20多次WA换来的细节点（其实只是我太蠢，10多个WA都是在de第三个细节。。。）

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
int g,d,ans,F,H;
int f[105][2500];
struct asd
{
    int t,f,h;
}a[105];
bool cmp(asd a,asd b)
{
    return a.t<b.t;
}
void die(){
    int life=10;
    for (int i=1;i<=g;i++){
        if (life-a[i].t+a[i-1].t<0/*4*/){
            printf("%d",a[i-1].t+life);
            return;
        }
        life=life-a[i].t+a[i-1].t+a[i].f;    
    }
    printf("%d",a[g].t+life);
    return;
}
int main()
{
    scanf("%d%d",&d,&g);F=0;
    for (int i=1;i<=g;i++){
        scanf("%d%d%d",&a[i].t,&a[i].f,&a[i].h);
        F+=a[i].f;
        H+=a[i].h;
    }
    for (int i=0;i<=g;i++)
        for (int j=0;j<=H;j++) f[i][j]=-2147480000;//1 
    sort(a+1,a+g+1,cmp);
    f[0][0]=10;//1
    for (int i=1;i<=g;i++){
        for (int j=0;j<=H;j++){
                if (f[i-1][j]-a[i].t+a[i-1].t>=0/*3*/) f[i][j]=max(f[i][j],f[i-1][j]-a[i].t+a[i-1].t+a[i].f);
                if (j-a[i].h>=0/*2*/) f[i][j]=max(f[i][j],f[i-1][j-a[i].h]-a[i].t+a[i-1].t);
            if (f[i][j]>=0 && j>=d) {printf("%d",a[i].t); return 0;}
        }
    }
    die();
    return 0;
}
```

---

## 作者：Skywalker_David (赞：4)

动态规划+冒泡排序：

排序：

```cpp
for i:=1 to n do 
      for j:=i+1 to n do 
        if t[i]>t[j] then begin 
                            c:=t[i];t[i]:=t[j];t[j]:=c; 
                            c:=l[i];l[i]:=l[j];l[j]:=c; 
                            c:=h[i];h[i]:=h[j];h[j]:=c; 
                          end; 
```
动态规划过程：
```cpp
for i:=0 to n do for j:=0 to m do a[i,j]:=-maxlongint; 
    a[0,0]:=10; 
    ansl:=0; 
    for i:=1 to n do 
      for j:=0 to m do 
        begin 
        if a[i-1,j]>=t[i]-t[i-1] then a[i,j]:=a[i-1,j]+l[i]-t[i]+t[i-1]; 
        if (j-h[i]>=0)and(a[i-1,j-h[i]]>=t[i]-t[i-1]) then a[i,j]:=max(a[i,j],a[i-1,j-h[i]]-t[i]+t[i-1]); 
        if (j=m)and(a[i,m]<>-maxlongint) then print(t[i]); 
        if a[i,j]+t[i]>ansl then ansl:=a[i,j]+t[i]; 
end;
```

---

## 作者：kaiyuan (赞：3)

这个题非常的像01背包。但是又有不同之处。

因为01背包中的“不装”就不修改状态，这里不装则也要修改状态。

不过这并没有太大影响。

用 f [i][j]存储在扔进去i个垃圾，高度为j时的最大生命值。

 注意题目用词：10小时**内**。
	
 	也就是说：当f[i][j]=0时，只是濒死（还活着），奶牛还可以操作垃圾。
	所以初始化时的f数组要赋-1。

要记得初始化边界f[0][0]=10：当扔进去0个垃圾，高度为0时，奶牛的生命值为10。

每段时间消耗的能量为x[i+1].t−x[i].t。
	别忘了：样例具有迷惑性。题目中并没有说{Ti}单调。那么对于垃圾，还要以时间为关键字从小到大排序一遍。

计算最长可以存活多长时间就是不使用垃圾，只吃垃圾，直到奶牛坚持不下去。

状态转移方程：见代码

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
struct node{
	int t,l,h;
}x[N];
int he,n;
int f[110][1010];
bool cmp(node a,node b){
	return a.t<b.t;
} 
int main(){
	cin>>he>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i].t>>x[i].l>>x[i].h;
	}
	memset(f,-1,sizeof f);
	sort(x+1,x+1+n,cmp);
	f[0][0]=10;
	x[0].t=0,x[0].l=0,x[0].h=0;
	for(int i=0;i<n;i++){
		for(int j=0;j<he;j++){
			if(f[i][j]<0)continue;
           //没有转移到过或奶牛已死
			if(j+x[i+1].h>=he&&f[i][j]>=x[i+1].t-x[i].t){
                printf("%d\n",x[i+1].t);
                return 0;
            }
/*既满足下一个垃圾可以直接跳出去，又满足奶牛的能量能坚持到下一个垃圾。
 那么，这时就是答案*/
    
    //状态转移
            if(f[i][j]-x[i+1].t+x[i].t>=0)
                f[i+1][j+x[i+1].h]=f[i][j]-x[i+1].t+x[i].t;
                //使用垃圾增加高度，减少能量
            if(f[i][j]-x[i+1].t+x[i].t>=0)
                f[i+1][j]=max(f[i+1][j],f[i][j]-x[i+1].t+x[i].t+x[i+1].l);
                //吃掉垃圾，高度不变，能量增加。
                //但此时，我们要考虑之前f[i][j]是有转移到过，如果有，哪种更优，如果没有，直接更新。
                /*这时，数组f赋值为负数的好处来了，满足f[i][j]-x[i+1].t+x[i].t>=0，那么奶牛生命不可能为负数，直接用max即可。*/
		}
	}
   //如果进行到当前状态，说明奶牛死亡，计算最长可以存活多长时间。
	int m=10,sum=0;//m是现有能量，sum是已经用过的能量
    for(int i=1;i<=n;i++){
        if(x[i].t-x[i-1].t>m){//奶牛坚持不下去了
            printf("%d\n",sum+m);
            return 0;
        }
        sum+=x[i].t-x[i-1].t;
        m-=x[i].t-x[i-1].t;
        m+=x[i].l;//m是还能坚持多久
    }
    printf("%d\n",sum+m);
    return 0;
}
```


---

## 作者：翠竹叶飞 (赞：3)

/\*
1.特判time>10（然而没有分）

2.注意要排序

3.注意如果生命<0(即根本不可能达到),不能在这个时候吃掉垃圾

4.注意f数组初始值为0即可，不需要为INF

\*/
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int i,j,m,n,cnt=0;
int f[101]; //高为i的最大生命 
struct ele
{
    int time, live, height;
} a[101];
int comp(ele a, ele b)
{
    return a.time<b.time;
}
int main()
{
    memset(f,0,sizeof(f)); f[0]=10;
    scanf("%d%d",&m,&n);
    for (i=1; i<=n; i++)
      scanf("%d%d%d",&a[i].time,&a[i].live,&a[i].height);
    sort(a+1,a+n+1,comp); a[0].time=0;
    if (a[1].time>10) {
        printf("10");
        return 0;
    }
    for (i=1; i<=n; i++)
    {
        int tmp=a[i-1].time-a[i].time;
        for (j=m; j>=0; j--) f[j]+=tmp;
        if (f[m]>=0) f[m]+=a[i].live; //height=m 特判
        for (j=m; j>=m-a[i].height; j--)
            if (j>=0) f[m]=max(f[m],f[j]);
        for (j=m-1; j>=0; j--) //height<m
        {
            if (f[j]>=0) f[j]+=a[i].live;
            if (j>=a[i].height)
                f[j]=max(f[j],f[j-a[i].height]);
        }
        if (a[i].time==a[i+1].time) continue;
        if (f[m]>=0){
            printf("%d",a[i].time);
            return 0;
        }
        if (i<n && f[0]-a[i+1].time+a[i].time<0){
            printf("%d",a[i].time+f[0]);
            return 0;
        }
    }
    printf("%d",a[n].time+f[0]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

//水题，dp+快排是正解，注意一下牛等不到最后一个垃圾就挂掉了的数据，排序时间（没告诉你有序）

```cpp
//需要知道两个状态转移方程   
     clife[j+a[i].high]:=max(clife[j+a[i].high],clife[j]);
     clife[j]:=clife[j]+a[i].life;
//吃要加生命
//不吃加高度(有顺序)
```
代码：



```cpp
type jl=record
  time,life,high:longint;
end;
var
  n,m,i,j,d:longint;
  clife:array[0..10000] of longint;//高度为clife是的生命值
  a:array[1..10000] of jl;
function max(a,b:longint):longint;
begin
  if a>b then
    exit(a);
  exit(b);
end;
procedure sort(l,r: longint);、//快排不解释
      var
         i,j: longint;
         x,y:jl;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i].time<x.time do
            inc(i);
           while x.time<a[j].time do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
  readln(d,n);
  for i:=1 to n do
    readln(a[i].time,a[i].life,a[i].high);
  sort(1,n);
  clife[0]:=10;
  for i:=1 to n do
    for j:=d downto 0 do//枚举高度
    if clife[j]>=a[i].time then
    begin
      if j+a[i].high>=d then//出来啦！
      begin
        writeln(a[i].time);
        halt;
       end;
     clife[j+a[i].high]:=max(clife[j+a[i].high],clife[j]);//不垃圾+高度
     clife[j]:=clife[j]+a[i].life;//吃垃圾ing+生命值
    end;
  writeln(clife[0]);//可怜的牛挂了，没有高度
end.

```

---

## 作者：Thor_Odinson (赞：3)

~~这题很水~~

分析：

这题是类背包问题的动态规划。

基本思路是用一个二维数组来存当前高度的生命

状态决策就是吃和不吃

这里用bool数组表示存活与否

a[k].f表示吃了第k件物品恢复的生命值

假如能吃 f[i][j+a[k].f]=true;

a[k].h表示用了第k件物品能堆的高度

假如能用 f[i+a[k].h][j]=true;

初始状态f[0][10]，最开始能存活10分钟

 
```cpp
 1 #include <iostream>
 2 #include <algorithm>
 3 #include <cstdio>
 4 struct ab
 5 {
 6     int t,f,h;
 7 }a[101];
 8 int d,g;
 9 bool f[400][6000]={false};//表示在高度为i的情况下能存活j的时间 
10 bool comp(ab a,ab b)//sort 
11 {
12     return a.t<b.t;
13 }
14 using namespace std;
15 main()
16 {
17     scanf("%d%d",&d,&g);
18     int s=10;
19     for (int i=1;i<=g;i++)
20       {
21           scanf("%d%d%d",&a[i].t,&a[i].f,&a[i].h);
22           s+=a[i].f;//s表示最长存活时间 
23       }
24     sort(a+1,a+g+1,comp);//按时间排序 
25     f[0][10]=true;//最短存活10分钟 
26     for (int k=1;k<=g;k++)//一个一个垃圾遍历 
27         for (int i=d-1;i>=0;i--)//i表示高度    //为什么到0呢?因为到0就死啦 
28             for (int j=s;j>=a[k].t;j--)//j表示时间,最长为s 
29             if (f[i][j]==true)//假如这个时间点能存活 
30             {
31                 f[i+a[k].h][j]=true;//这个垃圾用于加高度 
32                 if (i+a[k].h>=d)//假如出去了 
33                 {
34                     printf("%d",a[k].t);//输出时间,因为排完序了,所以是最优解 
35                     exit(0);//直接退出 
36                 }
37                 f[i][j+a[k].f]=true;//这个垃圾用于加时间 
38             }
39     for (int i=s;i>=1;i--)//从后往前遍历时间,假如遇见就是最长时间 
40         if (f[0][i])//最长十分钟  //知道那个赋值语句的用途了吧 
41         {
42             printf("%d",i);//直接输出,跳出循环(程序) 
43             break;
44         }
45 }
```

---

## 作者：ljc20020730 (赞：2)

在本题中，我们按照时间这一维度进行动态规划。

设$ f_{i,j}$ 表示时间轴前 $i$ 个单位时间，奶牛生命值为 $j$ 时，奶牛的最大高度。

注意到，同一个时间轴节点上可能会同时扔下多个垃圾，所以在每个时间点中需要使用$01$背包模型来挑选垃圾的不同决策。

首先，这个时间轴节点可能没有扔下垃圾或者即使扔下垃圾也不使用，这样的话转移就是 $ f_{i,j}=f_{i-1,j+1}$。

其次，对于某一个垃圾有两种使用方法，叠起来($f_{i,j}+h$)或者用来恢复生命($f_{i,j-f}$)

所以，在01背包中转移可以这么写$f_{i,j} = max\{f_{i,j}+h,f_{i,j-f}\}$

注意倒序取即可。
	
  为了处理方便对于不可能的决策，我们直接把其值赋为负无穷。
   
  如果在动态规划过程中$ f_{i,j}≥D $ 那么在 $ i $ 时刻奶牛已经爬出井。
    
  如果在动态规划过程中$ f_{i,j}≥ 0 $那么在 $i$ 时刻奶牛仍然存活。
    
  最后输出即可。

```cpp
# include <bits/stdc++.h>
using namespace std;
const int N=4e3+10,M=4e3+10;
struct rec{
	int f,h;
}a[N];
int f[N][M],D,G;
vector<int>w[N];
int main()
{
	scanf("%d%d",&D,&G);
	int MaxT=4000,SumF=4000;
	for (int i=1;i<=G;i++) {
		int t; scanf("%d",&t);
		scanf("%d%d",&a[i].f,&a[i].h);
		w[t].push_back(i);
	}
	memset(f,-0x3f,sizeof(f));
	f[0][10]=0; bool ok=false; int alive=0,ans=0x3f3f3f3f;
	for (int i=1;i<=MaxT;i++) {
		for(int j=0;j<=SumF;j++) f[i][j]=f[i-1][j+1];
		for (int k=0;k<w[i].size();k++)
			for (int j=SumF;j>=0;j--) {
				f[i][j]=f[i][j]+a[w[i][k]].h;
				if (j-a[w[i][k]].f>=0) f[i][j]=max(f[i][j],f[i][j-a[w[i][k]].f]);
			}
		for(int j=0;j<=SumF;j++){
			if (f[i][j]>=D) ok=true,ans=min(ans,i);
			if (f[i][j]>=0) alive=max(alive,i);
		}
	}
	if (ok==false) printf("%d\n",alive);
	else printf("%d\n",ans);
	return 0;
}
```


---

## 作者：天狗的手帖 (赞：2)

这是一个有点奇怪的题目。。USACO的题目看上去都感觉很奇怪。这里给出一种思路。


最简单的设想就是用f[i][j]来表示用前i个垃圾堆出高度为j时最大能得到的生存时间。

那么很容易就能看出来

f[i][j]---->f[i+1][j+h[i]]-t[i+1]+t[i]（堆垃圾）

f[i][j]---->f[i+1][j]-t[i+1]+t[i]+live[i]（吃垃圾）


这种做法要保证t[i]是严格递增的


事实上因为f[i]只能转移到f[i+1]的状态，所以我们在求解f[i]时只需要记录f[i-1]的状态就可以了，用滚动数组压掉一维，当然假如代码能力强的话也可以尝试downto


---

## 作者：songhn (赞：1)

### 1.题解
首先该题是一个线性dp问题 由于贪心的考虑我们每次到当前时间有可以取的垃圾都会直接捡起而不会再过一会儿 所以我们可以把每一个出现时间作为策略点 这样从头开始dp 所以我们首先需要对a数组进行排序

排序以后就可以从第一个垃圾到最后一个垃圾来dp了 那dp方程如何设计呢 我们考虑假如当前有更多的生命的话那么后续选择也有更多的余地 所以我们可以设$f[i][j]$表示当前考虑到第$i$个物品且在$j$高度时生命值最大是多少 

然后和背包问题一样的分析方法 

需要注意的是这里由背包的取或不取变成了是堆还是吃 所以我们的$i$一定是从$i-1$推过来的 
那我们现在考虑$f[i-1][j]$假如此时这个状态的生命值小于$t_i-t_{i-1}$那么就不能递推过来 所以只需要考虑$f[i-1][j]>=t_i-t_{i-1}$ 需要注意的是可能出现一些时间相同的垃圾 所以有可能差值为0 那么假如我们初始化f为0就可能会更新一些莫名其妙的没有意义的状态然后就WA了 所以我们先给f初始化一个负数 

现在$i-1$可以转移到$i$了 那么
1. 第$i$个物品用来吃

那么$f[i][j]=max(f[i][j],f[i-1][j]-(t_i-t_{i-1})+w_i)$

注意我们用$w$来表示这个垃圾能提供的生命值

这个方程还是比较好懂的 我们$f[i][j]$从$f[i-1][j]$推过来 首先需要花费$t_i-t_{i-1}$的生命值 然后吃了$i$以后又加了$w_i$的生命值

2.第$i$个物品用来堆

那么我们$f[i-1][j]$就可以更新到$f[i][j+h_i]$注意假如这时候高度$j+h_i$大于等于d就已经可以了 直接输出到第$i$个点的时间即可

假如还是在范围内的话就有

$f[i][j+h_i]=max(f[i][j+h_i],f[i-1][j]-(t_i-t_{i-1}))$
这个式子与上面那个差不多 就是从$i-1$转移到$i$ 此时花费了$t_i-t_{i-1}$然后高度由$j$变成了$j+h_i$

假如$n$个物品考虑完了还没有找到跳出去的办法那他就被困在井里了 这时候我们需要输出它最多存活多久 这个可以直接算出来 每次遇到物品就把当前生命加上它的贡献 假如生命值已经够不到第$i$个物品出现的时间了 就输出当前时间好了 这就是个简单的贪心
### 2.AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=250;
int f[maxn][maxn];
int n,m;
struct node{
	int t,h,f;
	bool operator<(const node&p)
	{
		if(t==p.t) return t<p.t;
	}
}a[maxn];
int main()
{
	cin>>m>>n;
	for(int i=1;i<=n;i++) cin>>a[i].t>>a[i].f>>a[i].h;
	sort(a+1,a+n+1);
	memset(f,-1,sizeof(f));
	f[0][0]=10;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<m;j++)
		{
			if(f[i-1][j]>=a[i].t-a[i-1].t)
			{
				if(j+a[i].h>=m) 
				{
					cout<<a[i].t<<endl;
					return 0;
				}
				f[i][j+a[i].h]=max(f[i][j+a[i].h],f[i-1][j]-a[i].t+a[i-1].t);
				f[i][j]=max(f[i][j],f[i-1][j]-a[i].t+a[i-1].t+a[i].f);
			}
		}
	}
	int ans=10;
	for(int i=1;i<=n;i++)
	{
		if(ans<a[i].t) break;
		ans+=a[i].f;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Jμdge (赞：1)

咦？我居然自己写出了个dp题？

emmm...居然没有copy别人的代码。。。（就是最后跑出来的时间有点感人，近三倍`_(:з」∠)_`）

不知和别人的思路会不会有什么区别。

于是乎写篇题解。

首先这个题我是点背包进来的，于是便开始设计状态。。。（真不知道比赛的时候看到这种题会怎么样）

## 状态设计

那么这里我用了 $f[i]$ 表示当前剩余能量为 i 时，能爬到的最大高度。

于是考虑状态转移。

## 状态转移

如果 $f[i]$ 是可达状态（同时 i 要大于该次垃圾掉落的时间与上一次掉落之间的时间差），那么我们就用 $f[i]$ 进行转移。

首先用 $f[i]$ 处理当前垃圾掉落有两种转移：

	1.垃圾拿来吃，那么有：
    
    	new_f[i-pass+a[i].F]=max(new_f[i-pass+a[i].F],f[i])
        
       
	2.垃圾拿来叠，那么有：
    
    	new_f[i-pass]=max(new_f[i-pass],f[i]+a[i].H)


    其中 ： new_f 是正在更新的 f 数组，
        	pass 表示离上一次垃圾掉落经过的事件
            a[i].F 表示吃掉垃圾获得的能量值
            a[i].H 表示垃圾的高度

然后就好转移了。

最后在开一个 g 数组滚动转移。。。


## 答案处理

但是过程中判断出达到洞口了的话要直接输出

而如果死都达不到洞口，那么就计算奶牛死的时间。

（我们在每个物品参与转移后，去判断有没有 $f[i]>=0$ (即状态可达)，
然后令$ ans=now\_tim+i; $）


## 注意有坑

虽然样例中垃圾是按时间顺序给出的，
但是题目里面没有说垃圾是怎么个顺序给出的，
于是我们可以推测出题人还是有点毒瘤的。


## 代码部分
（感觉利用 cnblogs 给代码加行号会被嫌弃，于是就不恶心大家了）

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=1e5+111;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,ans=10,las,V,f[M],g[M]; struct node{ int T,F,H; }a[M];
inline bool cmp(node& a,node& b){ return a.T<b.T; }
inline void cmax(int& a,int b){ if(a<b) a=b; }
int main(){
    V=read(),n=read(),las=0;
    memset(f,-0x3f,sizeof(f)),f[10]=0;
    for(int i=1;i<=n;++i)
        a[i].T=read(),
        a[i].F=read(),
        a[i].H=read();
    sort(a+1,a+1+n,cmp);
    for(int i=1,les;i<=n;++i){
        les=a[i].T-las,memset(g,-0x3f,sizeof(g));
        for(int j=a[i].T-las;j<=3000;++j) if(f[j]>=0){
            cmax(g[j-les],f[j]+a[i].H);
            cmax(g[j-les+a[i].F],f[j]);
        } las=a[i].T,swap(f,g);
        for(int j=0;j<=3000;++j)
            if(f[j]>=V) return printf("%d\n",las),0;
            else if(f[j]>=0) ans=max(ans,las+j);
    } return printf("%d\n",ans),0;
}
```



---

## 作者：sun1yu1jia1 (赞：1)

这道题除了可以用背包解法外，还可以用这样的二维dp：

bool 数组 f[h][l]：高度为h，寿命为l这样的情况能否存在。

注意，这里的寿命指“能够存活到哪一个时间点”，而不是“目前还剩下多少寿命”。

对于第i个垃圾,
若牛的寿命足够使其活到本时间点，并且[h][l]情况存在，那么：

	首先判断，用掉本垃圾，能否出去。（如果之后判断，有可能h + height(i)太大，导致数组越界）
    
	如果不能出去，考虑状态转移：
    
		吃掉垃圾，则[h][l + life(i)]情况存在，即寿命延长。
		用掉垃圾，则[h + height(i)][l]情况存在，即高度增加。

如果最终不能出去，则遍历f[0][l]（l从大到小）。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

struct SRubbish {
    int iTime;
    int iLife;
    int iHeight;
};

// 读入优化 
inline int Read()
{
    int w = 1, i = 0; char ch = 0;
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        i = i * 10 + ch - '0';
        ch = getchar();
    }
    return i * w;
}

bool CompRubbish(SRubbish a, SRubbish b)
{
    return a.iTime < b.iTime;
}

// 高度 能存活到哪一个时间点 
bool arrDP[120][3020];
SRubbish arrRubbish[120];

int main()
{
    int iHeight, iRubbish;
    iHeight = Read(); iRubbish = Read();

    for (int i = 1; i <= iRubbish; i++)
        arrRubbish[i] = (SRubbish) { Read(), Read(), Read() };
    sort(arrRubbish + 1, arrRubbish + 1 + iRubbish, CompRubbish);

    arrDP[0][10] = true;
    for (int i = 1; i <= iRubbish; i++)
    {
    	for (int h = 110; h >= 0; h--)
    		//  t >= arrRubbish[i].iTime 保证牛存活到这一时间点 
    		for (int t = 3010; t >= arrRubbish[i].iTime; t--)
    		{
    			if (!arrDP[h][t])
    				continue;
    			if (h + arrRubbish[i].iHeight >= iHeight)
    			{
    				printf("%d", arrRubbish[i].iTime);
    				return 0;
				}
				arrDP[h + arrRubbish[i].iHeight][t] = true;
				arrDP[h][t + arrRubbish[i].iLife] = true;
			}
	}
	
	for (int i = 3010; i >= 0; i--)
		if (arrDP[0][i])
		{
			printf("%d", i);
			return 0;
		}
    
    return 0;
}
```

---

## 作者：varvar (赞：1)

背包型DP

f[i]表示高度为i时的最长存活时间

于是就有状态转移方程式

吃          f[i+a[i]]=max(f[i],f[i,a[i]])

不吃      f[i]=f[i]+a[i]


接下来上代码

（代码中我状态是用布尔类型表示，f[i][j]表示高度为i时最长存活时间为j的状态存在）


```cpp

#include <cstdio>  
#include <algorithm>  
using namespace std;  
int d,g,k,i,j,s;  
struct data  
{  
    int t,ff,h;  
};  
data a[110];  
bool f[400][6000];  
  
bool cmp(data x,data y)  
{  
    return x.t<y.t;  
}  
  
int main()  
{  
    scanf("%d%d",&d,&g);  
    for (int i=1;i<=g;i++)   
        scanf("%d%d%d",&a[i].t,&a[i].ff,&a[i].h);  
    sort(a+1,a+g+1,cmp);  
    s=10;  
    for (int i=1;i<=g;i++) s+=a[i].ff;  
    f[0][10]=true;  
    for (int k=1;k<=g;k++)  
    for (int i=d-1;i>=0;i--)  
    for (int j=s;j>=a[k].t;j--)  
    if (f[i][j])   
    {  
        f[i+a[k].h][j]=true;  
        if (i+a[k].h>=d)  
        {  
            printf("%d",a[k].t);  
            exit(0);  
        }  
        f[i][j+a[k].ff]=true;  
    }  
    for (int i=s;i>=1;i--)  
    if (f[0][i])   
    {  
        printf("%d",i);  
        break;  
    }  
}  

```

---

## 作者：QWsin (赞：1)

坑点：数据不一定按时间排序   注意加上木块后超过深度的情况


这道题因为我犯傻调了一个中午

首先方法比较鬼畜。。

dp[i][j]表示第i个垃圾高度为j的最大生命时间  并且这个生命时间以现在为起点（也就是说还  能活多久）


先排序嘛   再初始化dp[0][0]=10;

然后两种转移

先设d等于t[ i ]-t[ i - 1](从上一个转移到现在这一个的时间)

在合法情况下（还能生存时间大于等于d）

    dp[ i ][ j ]=

如果dp[ i - 1 ][ j ]合法  即可以把当前垃圾吃掉  则dp[ i ][ j ]=dp[ i - 1 ][ j ] - d +f[i]

如果dp[ i - 1 ][ j - h[ i ]]合法  即可以把当前垃圾放上去  则dp[ i ][ j ]=dp[ i - 1][ j ] - d

以上两种转移取较大值  不能转移则赋为一个负值（不可到达）


然后是放上去后超过地洞的深度的情况 设深度为deep

那么从 dp[ i -1 ][deep - h[ i ]]到dp[ i - 1 ][deep - 1]都可以转移到

dp[ i ][ deep ]( 转移时先判定合法  再减去d（两 垃圾的时间间隔） )


最后答案从deep这个位置开始找   从先掉下来的垃圾到后掉下来的（要求最早出去）

如果没有  就计算最长存活时间

```cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=100+10;
const int INF=10;
struct LJ{
    int t,f,h;
}l[maxn];

int cmp(LJ a,LJ b)
{
    return a.t<b.t;
}
int dp[maxn][maxn];

int main()
{
    int deep,n;
    cin>>deep>>n;
    for(int i=1;i<=n;i++)
      scanf("%d%d%d",&l[i].t,&l[i].f,&l[i].h);
    sort(l+1,l+n+1,cmp);
    dp[0][0]=10;
    for(int i=1;i<=deep;i++)  //初始化
      dp[0][i]=-INF;
    for(int i=1;i<=n;i++)
      for(int j=deep;j>=0;j--)
      {
            dp[i][j]=-INF;
            int d=l[i].t-l[i-1].t;
            if(j>=l[i].h)
             {
                if(dp[i-1][j]-d>=0)    //可以吃下这个垃圾
                dp[i][j]=dp[i-1][j]-d+l[i].f;
                if(j==deep)   //达到最高点时的特殊处理
                {
                    for(int k=deep-l[i].h;k<deep;k++)
                      if(dp[i-1][k]-d>=0)
                    dp[i][j]=max(dp[i][j],dp[i-1][k]-d);
                }
                else
                    if(dp[i-1][j-l[i].h]-d>=0)  //搭上这个垃圾
                 dp[i][j]=max(dp[i][j],dp[i-1][j-l[i].h]-d);
             }
            else    //只能吃下这个垃圾
              if(dp[i-1][j]-d>=0)   //判合法
              dp[i][j]=dp[i-1][j]+l[i].f-d;
        }
        
    for(int i=1;i<=n;i++)
      if(dp[i][deep]>=0)
      {
          printf("%d",l[i].t);
          return 0;
      }
    int sum=10;   //到多久会 挂掉
    for(int i=1;i<=n;i++)  ///计算存活时间  
      if(sum>=l[i].t)   //首先要能活到那个时候
        sum+=l[i].f;
      else break;
    printf("%d",sum);
    return 0;
}

```

---

## 作者：gryql (赞：1)

首先一个槽点，这个题输入不一定按时间排序，所以先把垃圾按照时间排序。


网络上很多二维三维布尔型整型存放动态规划的值的数组，鉴于本人较笨，理解不了大神做法，只好原封不动的写一个近似背包的模型了。


一维数组ff[i]表示高度为i时最长能活多久，对于每个垃圾都有吃与不吃两种选择。如果不吃就能出去那就输出这个垃圾掉下去的时间。


其余参考题目注解。



```delphi

type ss=record
    t,f,h:longint;
    end;

var a:array[1..100] of ss;
    ff:array[0..1000] of longint;//ff[i]表示高度为i时最长能活多久
    d,g:longint;

function max(x,y:longint):longint;
begin
    if x>y then exit(x) else exit(y);
end;

procedure init;
var i:longint;
begin
    readln(d,g);
    for i:=1 to g do readln(a[i].t,a[i].f,a[i].h);
end;

procedure sort(l,r: longint);
      var
         i,j,x:longint;y:ss;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2].t;
         repeat
           while a[i].t<x do
            inc(i);
           while x<a[j].t do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;

procedure main;
var i,j,k,m:longint;
begin
    for i:=1 to g do
        for j:=d downto 0 do
            if ff[j]>=a[i].t then//如果它能够坚持到垃圾掉下来的话
                begin
                    if j+a[i].h>=d then
                        begin
                            writeln(a[i].t);
                            halt;
                        end;
                    //能出去
                    ff[j+a[i].h]:=max(ff[j+a[i].h],ff[j]);//不吃
                    ff[j]:=ff[j]+a[i].f;//吃
                end;
end;

begin
    init;
    fillchar(ff,sizeof(ff),0);
    sort(1,g); 
    ff[0]:=10;
    main;
    writeln(ff[0]);//无法爬出，输出高度为零时（此时不用爬)最大存活时间
end.

```

---

## 作者：zhangjl (赞：1)

100%动归.一定是要排序的.要不然..

上帕斯卡程序:

框起来的:

```delphi

var ansl,n,m,i,j,c:longint;
      t,l,h:Array[0..105]of longint;
      a:Array[0..100,0..100]of longint;
  procedure print(ans:longint);
  begin
  assign(output,'well.out');rewrite(output);
   writeln(ans);
  close(output);
   halt;
  end;
  function max(x,y:longint):longint;
  begin
    if x>y then max:=x else max:=y;
  end;
  begin
    assign(input,'well.in');reset(input);
    readln(m,n);
    for i:=1 to n do readln(t[i],l[i],h[i]);t[0]:=0;
    close(input);
     for i:=1 to n do
      for j:=i+1 to n do
        if t[i]>t[j] then begin
                            c:=t[i];t[i]:=t[j];t[j]:=c;
                            c:=l[i];l[i]:=l[j];l[j]:=c;
                            c:=h[i];h[i]:=h[j];h[j]:=c;
                          end;
    for i:=0 to n do for j:=0 to m do a[i,j]:=-maxlongint;
    a[0,0]:=10;
    ansl:=0;
    for i:=1 to n do
      for j:=0 to m do
        begin
        if a[i-1,j]>=t[i]-t[i-1] then a[i,j]:=a[i-1,j]+l[i]-t[i]+t[i-1];
        if (j-h[i]>=0)and(a[i-1,j-h[i]]>=t[i]-t[i-1]) then a[i,j]:=max(a[i,j],a[i-1,j-h[i]]-t[i]+t[i-1]);
        if (j=m)and(a[i,m]<>-maxlongint) then print(t[i]);
        if a[i,j]+t[i]>ansl then ansl:=a[i,j]+t[i];
    end;
    print(ansl);
  end.

```

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_


不框起来的：




```cpp
var ansl,n,m,i,j,c:longint;
      t,l,h:Array[0..105]of longint;
      a:Array[0..100,0..100]of longint;
  procedure print(ans:longint);
  begin
  assign(output,'well.out');rewrite(output);
   writeln(ans);
  close(output);
   halt;
  end;
  function max(x,y:longint):longint;
  begin
    if x>y then max:=x else max:=y;
  end;
  begin
    assign(input,'well.in');reset(input);
    readln(m,n);
    for i:=1 to n do readln(t[i],l[i],h[i]);t[0]:=0;
    close(input);
     for i:=1 to n do
      for j:=i+1 to n do
        if t[i]>t[j] then begin
                            c:=t[i];t[i]:=t[j];t[j]:=c;
                            c:=l[i];l[i]:=l[j];l[j]:=c;
                            c:=h[i];h[i]:=h[j];h[j]:=c;
                          end;
    for i:=0 to n do for j:=0 to m do a[i,j]:=-maxlongint;
    a[0,0]:=10;
    ansl:=0;
    for i:=1 to n do
      for j:=0 to m do
        begin
        if a[i-1,j]>=t[i]-t[i-1] then a[i,j]:=a[i-1,j]+l[i]-t[i]+t[i-1];
        if (j-h[i]>=0)and(a[i-1,j-h[i]]>=t[i]-t[i-1]) then a[i,j]:=max(a[i,j],a[i-1,j-h[i]]-t[i]+t[i-1]);
        if (j=m)and(a[i,m]<>-maxlongint) then print(t[i]);
        if a[i,j]+t[i]>ansl then ansl:=a[i,j]+t[i];
    end;
    print(ansl);
  end.
再说一遍，仅供参考哈
```

---

## 作者：plane (赞：1)

一般对于这种“能否达到目标的题”，可以采用TF判断一个状态是否能达到的方法。本题中，f[i][j]表示高度为i生命为j的状态能否达到

```cpp

for (k=1; k<=g; k++)    
        for (i=d; i>=0; i--)   
            for (j=m; j>=a[k]; j--)   //m为所有垃圾提供的生命值加原生命值的和
                if (ff[i][j]==true)  
                {  
                                  记录状态并且判断是否已经达到目的
                }  

```

另一种方法：ff[j]表示达到j高度所达到的最大生命值。（这种方法可省去一维）


```cpp


for (i=1; i<=g; i++)  
        for (j=d; j>=0; j--)   
                if (ff[j]>=t[i])  
                {  
                                    
                                  ff[j+h[i]]=max(ff[j+h[i]],ff[j]);  
                                  ff[j]+=f[i];  
                                  if (j+h[i]>=d){printf(“%d”,t[i]);    return 0;};  
                }  

```

---

## 作者：粉刷匠 (赞：1)

# 很明显这是一个背包题。因为很明显每个垃圾有两种状态——吃或堆
## 但是怎么对应我们的模板呢？
#### 01背包是限定重量找到最大的价值。
这个题的垃圾有三个属性，时间、增加的高度、增加的生命。 


时间是来决定垃圾的顺序的（所以要sort数据）。  
我们注意到高度是有限的**当堆放垃圾高度大于等于D**就停止。  
所以我们将**dp[i][j]表示为第i个垃圾j高度拥有的生命的最大值**。 初始化dp[0][0]=10。


当j+h[i]<=D时，我们对垃圾进行操作  
**dp[i][j]+=f[i-1][j]**//将垃圾吃下去是最好的答案   
**dp[i][j+h[i]]=max(dp[i-1][j+h[i],dp[i-1][j]-f[i-1][j]）**//比较堆这个垃圾和堆其他垃圾能获得的生命，答案为最大值。

### 最后如果能出现j+h[i]<=D的情况，那么就输出此时的投放垃圾时间t[i]
### 否则就输入dp[n][0]

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int t[1001];
bool cmp(int a,int b)
{
	return t[a]<t[b];
}

int main()
{
	int d,n;
	cin>>d>>n;
	int f[n+1],h[n+1];
	int biao[n+1];
	for(int i=1;i<=n;i++)
	{
		cin>>t[i]>>f[i]>>h[i];
		biao[i]=i;
	}
	sort(biao+1,biao+1+n,cmp);
	int ans[101];
	for(int i=0;i<101;i++)
	ans[i]=0;
	ans[0]=10;
	int tt=0;
	int flag=0;
	for(int i=1;i<=n;i++)
	{
	if(flag==1)break;//得到最小时间后不必对后面的垃圾进行操作
	for(int j=d;j>=0;j--)
	{
		if(ans[j]>=t[biao[i]])
		{
			ans[j]+=f[biao[i]];		
			if(j+h[biao[i]]>=d)
			{
				tt=t[biao[i]];
				flag=1;
			}
			else
			ans[j+h[biao[i]]]=max(ans[j]-f[biao[i]],ans[j+h[biao[i]]]);
		}
	}
	}
	if(flag)printf("%d",tt);
	else printf("%d",ans[0]);
    return 0;
}

```


---

## 作者：远航之曲 (赞：1)

来发题解


这题是类背包问题的动态规划。。（好像有点水啊喂。。基本思路是用一个二维数组来存当前高度的时间


假如能吃                 f[i][j+a[k].f]=true;

假如能用                 f[i+a[k].h][j]=true;


**注意能存活10分钟


具体见代码注释（最详细的一次哦


（减少代码复制，共创美好洛谷）


```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
struct ab
{
    int t,f,h;
}a[101];
int d,g;
bool f[400][6000]={false};//表示在高度为i的情况下能存活j的时间 
bool comp(ab a,ab b)//sort 
{
    return a.t<b.t;
}
using namespace std;
main()
{
    scanf("%d%d",&d,&g);
    int s=10;
    for (int i=1;i<=g;i++)
      {
          scanf("%d%d%d",&a[i].t,&a[i].f,&a[i].h);
          s+=a[i].f;//s表示最长存活时间 
      }
    sort(a+1,a+g+1,comp);//按时间排序 
    f[0][10]=true;//最短存活10分钟 
    for (int k=1;k<=g;k++)//一个一个垃圾遍历 
        for (int i=d-1;i>=0;i--)//i表示高度    //为什么到0呢?因为到0就死啦 
            for (int j=s;j>=a[k].t;j--)//j表示时间,最长为s 
            if (f[i][j]==true)//假如这个时间点能存活 
            {
                f[i+a[k].h][j]=true;//这个垃圾用于加高度 
                if (i+a[k].h>=d)//假如出去了 
                {
                    printf("%d",a[k].t);//输出时间,因为排完序了,所以是最优解 
                    exit(0);//直接退出 
                }
                f[i][j+a[k].f]=true;//这个垃圾用于加时间 
            }
    for (int i=s;i>=1;i--)//从后往前遍历时间,假如遇见就是最长时间 
        if (f[0][i])//最长十分钟  //知道那个赋值语句的用途了吧 
        {
            printf("%d",i);//直接输出,跳出循环(程序) 
            break;
        }
}
```

---


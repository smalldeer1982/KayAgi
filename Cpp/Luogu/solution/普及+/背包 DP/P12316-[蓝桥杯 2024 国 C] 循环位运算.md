# [蓝桥杯 2024 国 C] 循环位运算

## 题目背景

蓝桥杯原题为 **做完 $m$ 次操作**，根据下载得到的测试数据分析应当为 **做了不超过 $m$ 次操作**。洛谷的题面根据实际测试数据进行编写。

## 题目描述

给定 $n$ 个数 $A_i$，每个数我们都将其视为一个 $32$ 位的二进制数。你可以进行 $m$ 次操作，每次选择任意一个数将其循环左移一次。

循环左移表示将某个数的二进制位均左移一位，同时最高位移动到最低位。例如对于一个 $8$ 位二进制数 $10010010$，循环左移一次后为 $00100101$，两次后为 $01001010$。

问做了**不超过** $m$ 次操作后，$n$ 个数的和最大是多少。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$n, m \leq 12$；
- 对于 $60\%$ 的评测用例，$n, m \leq 100$；
- 对于所有评测用例，$1 \leq n, m \leq 1000$，$0 \leq A_i < 2^{32}$。

## 样例 #1

### 输入

```
3 9
2365587456
2399141888
9437184```

### 输出

```
7535067152```

# 题解

## 作者：Austin0116 (赞：8)

# 分析

首先，我们可以发现此类决策类问题不好贪心，于是考虑 DP。

观察数据范围，发现似乎可以 $O(nm \log a_i)$，于是可以设计状态 $f_{i,j}$ 表示前 $i$ 个数中共左移 $j$ 位所得到的最大的和。

于是可以得出 dp 方程 $f_{i,j}=f_{i-1,j-k}+sum[i][k]$。其中，$k$ 是我们要枚举的当前数左移的位数，$sum[i][k]$ 是第 $i$ 个数左移 $k$ 位的数。时间复杂度 $O(nm \log a_i)$。
# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
long long f[1005][1005],mx,sum[1005][35];
string s[1005];
unsigned int a[1005],cnt;
inline unsigned int tonu(string s){//字符串转数字
	unsigned int sum=0;
	for(int i=0;i<(int)s.size();i++) sum=(sum<<1)|(s[i]^48);
	return sum;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%ud",&a[i]);
		cnt=a[i];
		while(cnt){
			s[i]+=((cnt&1)^48);
			cnt>>=1;
		}//转二进制
		for(int j=(int)s[i].size();j<32;j++) s[i]+=48;//补零
		reverse(s[i].begin(),s[i].end());
		s[i]+=s[i];
		for(int j=0;j<=31;j++) sum[i][j]=tonu(s[i].substr(j,32));//预处理sum[i][j]
	} 
	for(int i=1;i<=n;i++) for(int j=0;j<=m;j++) for(int k=0;k<=min(31,j);k++) f[i][j]=max(f[i-1][j-k]+sum[i][k],f[i][j]);//DP
	for(int i=0;i<=m;i++) mx=max(mx,f[n][i]);//最后答案
	printf("%lld",mx);
	return 0;
}
```

---

## 作者：WorldMachine (赞：6)

数据范围是 $n,m\le10^3$，那考虑 $\mathcal O(nm\omega)$ 的 DP。

$n$ 个数，限定 $m$ 次操作，不难想到背包状 DP。设 $f_{i,j}$ 表示考虑前 $i$ 个数用了 $j$ 次操作的最大和。有：
$$
f_{i,j}=\max_{k=0}^{31}\{f_{i-1,j-k}+a_i\overline{\ll} k\}
$$
其中 $\overline{\ll}$ 表示循环左移，在枚举 $k$ 的过程中维护。具体地说，$x$ 循环左移一位，就是其正常左移一位，再将其原本最高位上的数加到最低位上。写成代码就是 `x << 1 | (x >> 31 & 1)`。

背包 DP 可以滚动数组，即将 $j$ 倒序枚举。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1005;
int n, m; unsigned a[N]; ll f[N], ans;
signed main() {
	ios::sync_with_stdio(0), cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) {
		for (int j = m; ~j; j--) {
			unsigned x = a[i];
			for (int k = 0, u = min(j, 31); k <= u; k++) {
				f[j] = max(f[j], f[j - k] + x);
				x = x << 1 | (x >> 31 & 1);
			}
		}
	}
	for (int i = 0; i <= m; i++) ans = max(ans, f[i]);
	cout << ans;
}
```

---

## 作者：xianxi (赞：2)

# 题目大意

给你 $n$ 个数，总共可对这些数进行 $m$ 次循环位运算，求在操作后 $n$ 个数最大的和。所有数看成 $32$ 位二进制数。

# 思路

看到题目就能想到是动态规划。

定义 $dp_{i,j}$ 为前 $i$ 个数总共操作 $j$ 次的前 $i$ 个数的和的最大值（好绕口）。

同时，我们为节省时间，提前预处理一个二维数组 $num_{i,j}$ 表示第 $i$ 个数进行 $j$ 次操作的结果。

那么，可以推出状态转移方程为 $dp_{i,j}=\max (dp_{i,j},dp_{i-1,j-k}+num_{i,k})$。

# 代码实现

### 第一部分：预处理

我们对于某一次操作，可以将待操作的数先左移一位，再取出第 $32$ 位上的零一值，将该位变为零，并将该值移到第 $1$ 位上。

代码片段如下：

```cpp
	for(int i=1;i<=n;++i)
	{
		cin>>num[i][0];
		for(int j=1;j<=m;++j)
		{
			num[i][j]=(num[i][j-1]<<1ll);
			num[i][j]+=((num[i][j]&(1ll<<32))>>32);
			num[i][j]-=(num[i][j]&(1ll<<32));
		}
	}
```

### 第二部分：动态规划

考虑三重循环，最外层循环从 $1$ 到 $n$ 枚举数 $i$，第二层从 $0$ 到 $m$ 枚举前 $i$ 个数的总共操作 $j$ 次，最后一层循环从 $0$ 到 $j$ 枚举第 $i$ 个数的操作 $k$ 次。

最后的答案为最大的 $dp_{n,i}$，$i$ 从 $0$ 到 $m$。

代码片段如下：

```cpp
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<=m;++j)
		{
			for(int k=0;k<=j;++k)
			{
				dp[i][j]=max(dp[i][j],dp[i-1][j-k]+num[i][k]);
			}
		}
	}
	for(int i=0;i<=m;++i)
	{
		ans=max(ans,dp[n][i]);
	}
	cout<<ans;
```

### 第三部分：代码整体实现

直接上代码：

```cpp
#include<bits/stdc++.h>
#define ll int
using namespace std;
ll dp[1005][1005],num[1005][1005],ans,n,m;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>num[i][0];
		for(int j=1;j<=m;++j)
		{
			num[i][j]=(num[i][j-1]<<1ll);
			num[i][j]+=((num[i][j]&(1ll<<32))>>32);
			num[i][j]-=(num[i][j]&(1ll<<32));
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<=m;++j)
		{
			for(int k=0;k<=j;++k)
			{
				dp[i][j]=max(dp[i][j],dp[i-1][j-k]+num[i][k]);
			}
		}
	}
	for(int i=0;i<=m;++i)
	{
		ans=max(ans,dp[n][i]);
	}
	cout<<ans;
	return 0;
}
```

# 警钟长鸣

由于本人的预处理做法先进行左移，导致使用 `int` 会出错，因此使用 `long long` 型变量。

如有问题请直接提出，我会改进该篇题解。

最后感谢您的留步与观看，希望本篇题解能够帮到您。

---

## 作者：sjwhsss (赞：1)

# 题解：P12316 [蓝桥杯 2024 国 C] 循环位运算

## 题意简述

给定 $n$ 个 $32$ 进制数 $a_i$，每次操作将某个数的二进制位均左移一位，同时最高位移动到最低位。求不超过 $m$ 次操作后 $a_i$ 的和的最大值。

## 思路分析

定义 $x$ 经过 $k$ 次操作后为 $f(x,k)$，假设我们已经求出了 $f(x,k)$，考虑如何计算答案。容易想到 dp，定义 $dp_{i,j}$ 表示前 $i$ 个数进行了 $j$ 次操作后 $a_1$ 到 $a_n$ 的和的最大值，那么有转移：
$$
dp_{i,j}\leftarrow\max\limits_{0\le k \le \min\{{j,31}\}} dp_{i-1,j-k}+f(a_i,k)
$$

那么如何求出 $f(x,k)$？经过简单模拟后发现，$f(x,k)$ 为将 $x$ 的 $0$ 到 $32-k-1$ 位左移了 $k$ 位，剩下的位右移了 $32-k$ 位，即：
$$
f(x,k)=(x\bmod{2^{32-k}}\times 2^k)+(\frac{x-x\bmod{2^{32-k}}}{2^{32-k}})
$$
写成代码就是：
``` cpp
ll tmp = x % (1ll<<32-k);
return (tmp<<k) + (x-tmp>>32-k);
```
$f(a_i,k)$ 可以在输入的时候预处理，dp 的时候计算会 TLE，常数差了好几倍，然后可以滚动数组优化。时间复杂度 $O(nm\times t)$，其中 $t=32$ 。
## code
``` cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 1e5+5;
int n , m;
ll dp[maxn] , a[maxn] , ans , f[maxn][32];
inline ll calc(ll x , int k)
{
	ll tmp = x % (1ll<<32-k);
	return (tmp<<k) + (x-tmp>>32-k);
}
int main ()
{
	scanf("%d%d" , &n , &m);
	for (int i = 1; i <= n; ++i)
	{
		scanf("%lld" , &a[i]);
		for (int j = 0; j <= 31; j++) f[i][j]=calc(a[i] , j);
	}
	for (int i = 1; i <= n; ++i)
	{
		for (int j = m; j >= 0; --j)
		{
			for (int k = 0; k <= min(j , 31); ++k)
			{
				dp[j]=max(dp[j] , dp[j - k] + f[i][k]);
			}
		}
	}
	for (int i = 0; i <= m; ++i)ans=max(ans , dp[i]);
	printf("%lld\n" , ans);
	return 0;
}
```

---

## 作者：qiutian120529 (赞：0)

# 洛谷 P12316

## 题意

给定 $n$ 个数 $A_i$，每个数我们都将其视为一个 $32$ 位的二进制数。你可以进行 $m$ 次操作，每次选择任意一个数将其循环左移一次。

问做了**不超过** $m$ 次操作后，$n$ 个数的和最大是多少。

## 思路

因为涉及位运算，所以不方便贪心，考虑 dp。

可以先预处理出每个 $a_i$ 循环左移 $j$ 次的结果。接着做背包 dp，设计状态 $dp_{i,j}$ 表示当前考虑到第 $i$ 个点，用了 $j$ 次操作的最大和。

因此，只需枚举当前的点 $i$，到本次所用操作次数之和 $j$，以及本次操作次数 $k$，进行转移即可。转移式如下：

$$ dp_{i,j}=\max\limits_{k}^{\min(31,j)}(dp_{i-1,j-k}+w_{i,k})$$

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1010;

ll n, m, a[N], dp[N][N];
ll w[N][40];

int main(){
  cin >> n >> m;
  for(int i = 1; i <= n; i++){
    cin >> a[i];
  }
  for(int i = 1; i <= n; i++){
    for(int j = 0; j <= 32; j++){
      w[i][j] = ((a[i] << j) | (a[i] >> (32 - j))) % (1ll << 32);
    }
  }
  for(int i = 0; i <= n; i++){
    for(int j = 0; j <= m; j++){
      dp[i][j] = -1e16;
    }
  }
  dp[0][0] = 0;
  for(int i = 1; i <= n; i++){
    for(int j = 0; j <= m; j++){
      for(int k = 0; k <= min(31, j); k++){
        dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + w[i][k]);
      }
    }
  }
  ll ans = -1e16;
  for(int i = 0; i <= m; i++){
    ans = max(ans, dp[n][i]);
  }
  cout << ans;
  return 0;
}
```

---

## 作者：Fusiyi (赞：0)

# 洛谷-P12316 循环位运算

## 题意

给定 $n$ 个数 $A_i$，每个数我们都将其视为一个 $32$ 位的二进制数。你可以进行 $m$ 次操作，每次选择任意一个数将其循环左移一次。

问做了不超过 $m$ 次操作后，$n$ 个数的和最大是多少。

## 思路

背包 dp 板子。

设 $dp_{i, j}$ 表示 当前处理了前 $i$ 个点，做了 $j$ 次操作。

转移：

$dp_{i, j} = dp_{i - 1, j - k} + f(i, k)$，$k$ 表示第 $i$ 个点用了 $k$ 次操作，$f(i, k)$ 表示 $A_i$ 进行 $k$ 次操作。

$f(i, j)$ 可以预处理出来。

## 代码

~~~Cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;

#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
inline bool blank(const char x) {return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp> inline void read(Tp &x) {x=0; register bool z=true; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=(x<<1)+(x<<3)+(a^48); x=(z?x:~x+1);}
inline void read(double &x) {x=0.0; register bool z=true; register double y=0.1; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=x*10+(a^48); if(a!='.') return x=z?x:-x,void(); for(a=gc();isdigit(a);a=gc(),y/=10) x+=y*(a^48); x=(z?x:-x);}
inline void read(char &x) {for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x) {register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) *x++=a; *x=0;}
inline void read(string &x) {x=""; register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) x+=a;}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y) {read(x),read(y...);}
template<typename Tp> inline void write(Tp x) {if(!x) return pc(48),void(); if(x<0) pc('-'),x=~x+1; register int len=0; register char tmp[64]; for(;x;x/=10) tmp[++len]=x%10+48; while(len) pc(tmp[len--]);}
inline void write(const double x) {register int a=6; register double b=x,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); pc('.'); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x) {register int a=x.first; if(a<7) {register double b=x.second,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); a&&(pc('.')); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);} else cout<<fixed<<setprecision(a)<<x.second;}
inline void write(const char x) {pc(x);}
inline void write(const bool x) {pc(x?49:48);}
inline void write(char *x) {fputs(x,stdout);}
inline void write(const char *x) {fputs(x,stdout);}
inline void write(const string &x) {fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y) {write(x),write(y...);}

const int N = 1002;
int n, m;
ll a[N];
ll b[N][35];

ll dp[N][N], ans;

string t;

int main(){
    ///ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    read(n, m);
    for(int i = 1; i <= n; i ++){
        read(a[i]);
    }

    for(int i = 1; i <= n; i ++){
        for(ll j = 0; j <= 32; j ++){
            b[i][j] = ((a[i] << j) | (a[i] >> (32 - j))) % (1LL << 32);
        }
    }

    for(int i = 0; i <= n; i ++){
        for(int j = 0; j <= m; j ++){
            dp[i][j] = -1e16;
        }
    }

    dp[0][0] = 0;

    for(int i = 1; i <= n; i ++){
        for(int j = 0; j <= m; j ++){
            for(int k = 0; k <= min(j, 31); k ++){
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + b[i][k]);
            }
        }
    }

    for(int i = 0; i <= m; i ++){
        ans = max(ans, dp[n][i]);
    }

    write(ans);

    return 0;
}



~~~

---

## 作者：江湖午餐票 (赞：0)

# 题目大意

给定 $n$ 个数 $A_i$，每个数我们都将其视为一个 $32$ 位的二进制数。你可以进行 $m$ 次操作，每次选择任意一个数将其循环左移一次。**不超过** $m$ 次操作后，$n$ 个数的和最大是多少。

# 思路

鄙人动态规划不熟，在和机房同学交流后确定是考察动态规划，考虑如何转移。

因为每个数都是 $32$ 位的二进制数，所以每个数总共只有 $32$ 种变化，那么问题就转化成：从 $1$ 到 $n$，对于每个 $A_i$ 取一种变化，使得在 $m$ 的代价之内和最大。这其实非常像背包 dp。

设 $a_{i,j}$ 为 $A_i$ 循环左移 $j$ 次得到的数，则状态转移方程如下：

$$
dp_{i,j} = \max(dp_{i,j},dp_{i-1,j-k}+a_{i,k})
$$

接下来考虑如何求解 $a_{i,j}$ 数组。因为每次循环左移可以理解为先左移一位，再**或**上最高位，即 `(A << 1) | (A >> 31)`，所以我们可以在输入时就预处理好 $a_{i,j}$ 数组。


# 代码

实现的一些小细节都在注释里面，警钟长鸣。

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m;
unsigned int a[1003][33];
long long dp[1003][1003];
int main(){
	cin >> n >> m;
	for(int i=1;i<=n;i++){
		unsigned A; // 注意要非负 防止位运算后成负数 同理 a[i][j] 也要非负
		cin >> A;
		for(int j=0;j<=31;j++)
		{
			a[i][j] = A;
			A = (A << 1) | (A >> 31);
		} // 记得考虑不操作的情况
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++) 
			for(int k=0;k<=min(31,j);k++) // j-k 不能是负数 
				dp[i][j] = max(dp[i][j],dp[i-1][j-k]+a[i][k]);
	long long ans = -1;
	for (int i=0;i<=m;i++) 
        ans = max(ans,dp[n][i]); 
	cout << ans;
	return 0;
} 
```

---


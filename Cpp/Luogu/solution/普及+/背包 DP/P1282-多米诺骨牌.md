# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# 题解

## 作者：fy0123 (赞：155)

DP.

题目要求的是最小差值情况下的最小交换次数，那么我们把其中一个计入状态里。记交换次数好像不太好做（我没试过），所以我们要记的是差值。

但是差值是一个绝对值，好像也不是很好表示，所以我们再来转化一下。观察到每次交换只是把上下两个数交换，故前i个骨牌上下两行数的总和是不变的，所以我们只需记录其中一行数字的和就可以知道差值了。这样状态就好表示了。

f[i][j]表示前i个数字，第一行的数字和是j时，最小的交换次数。初始值所有f[i][j]都是无穷大，f[1][a[1]]=0，f[1][b[1]]=1。（a[]和b[]分别表示第一行和第二行的数字）

转移时，枚举每一个可能的和，共有6\*n个，考虑当前一个交不交换即可：

```cpp
if (j-a[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);  //当前不交换
if (j-b[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-b[i]]+1);  //当前交换
```
求答案时再枚举一下前n个骨牌第一行的和就好。

这样时间、空间复杂度均为O(n\*n\*6)。


代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 1000;
const int INF = 1e9;
int a[N+10], b[N+10], f[N+10][6*N+10];

int main()
{
    int n;
    scanf("%d", &n);
    int s = 0;
    for (int i = 1; i <= n; i ++){
        scanf("%d%d", &a[i], &b[i]);
        s += a[i] + b[i];
    }
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j <= 6*n; j ++) f[i][j] = INF;
    f[1][a[1]] = 0; f[1][b[1]] = 1;
    for (int i = 2; i <= n; i ++)   //DP，解释如上
        for (int j = 0; j <= 6*n; j ++){
            if (j-a[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);
            if (j-b[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-b[i]]+1);
        }
    int minD = INF, minT = INF;  //minD是最小差值，minT是最小交换次数
    for (int i = 0; i <= s; i ++)
        if (f[n][i] != INF){
            if (abs(i-(s-i)) < minD){
                minD = abs(i-(s-i)); minT = f[n][i];
            }
            else if (abs(i-(s-i)) == minD) minT = min(minT, f[n][i]);
        }
    printf("%d", minT);
    return 0;
}
```

---

## 作者：dj114133643 (赞：95)

遇见这种直接背包。


背包的本质是什么？？？

是每一个物品或动作对所有当前状态的更新。

本题就是如此，翻一次就把原来的加的差值颠倒。

并且，本题强制必须要用每一个动作，所以就必须（即+a-b或+b-a）从前面一个状态+改变量去更新

因为改变量有正有负，所以不好降一维，

其实可以用滚动数组，但为了偷懒         (^\_^），就用了二维的 (^\_^）

小心负数下标数组越界！！！！！

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int a[1005],b[1005];
int f[1005][12001];
const int N=5000;
int main()
{
    int n,i,j,ans,dis;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d%d",&a[i],&b[i]);
    memset(f,0x7F,sizeof(f));
    f[0][0+N]=0;
//核心代码开始
    for(i=1;i<=n;i++)
        for(j=-5000;j<=5000;j++)
        {
            dis=a[i]-b[i];
            f[i][j+N]=min(f[i-1][j-dis+N],f[i-1][j+dis+N]+1);
        }
//核心代码结束
    for(i=0;i<=5000;i++)
    {
        ans=min(f[n][i+N],f[n][-i+N]);
        if(ans<=1000)
        {
            printf("%d\n",ans);
            break;
        }
    }
    return 0;
}
```

---

## 作者：Zerosking (赞：75)

## 这题~~显然是~~贪心
题解里清一色的DP不想写？没关系我们可以发挥人类智慧，使用伟大的贪心QwQ。

题目是求最小旋转次数，那么我们可以让自己每次都选择收益最大的决策。

读入时分别记录上下两行的和，求它们的差值(记为$s$)。再记录每个牌的上下点数之差(存入数组$a$)。然后把$a$数组$sort$一遍。**每次选择让$s$的绝对值减小最多的**　就好啦。

$code:$
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int up,down;  //分别记录上下两行之和
int ans,n;
int a[1100];　　//记录单个牌的上下点数差
int d[1100];
int main()
{
	cin>>n;
    int p,q;
	for(int o=1;o<=n;o++)
	{
		scanf("%d%d",&p,&q);
		a[o]=p-q;
		up+=p,down+=q;
	}　　　　　　　　　　　　//读入时统计
	int s=down-up;
	if(s==0)
	{cout<<0;return 0;}//特判一下不需要改的
	sort(a+1,a+1+n);   //伟大的贪心QwQ
	if(s<0)　　　　　//如果上点数大于下点数
	{
		for(int i=n;i>=1;i--)　　//从　上-下　较大的开始枚举
		{
			if(a[i]>0 && s+a[i]*2<=0)//翻转有贡献且不能翻过头
				s+=(a[i]*2),ans++;//更新，记录答案
			else continue;
		}
	}
	if(s>0)//下面同理
	{
		for(int i=1;i<=n;i++)
		{
			if(a[i]<0 && s+a[i]*2>=0)
				s+=(a[i]*2),ans++;
			else continue;
		}
	}
    	cout<<ans<<endl;
	return 0;
```



------------

如果您交上这份代码，您就会获得82分的好成绩(逃


难道是贪心本身不可解？(~~还是去打DP吧~~)

等，等一下！$QAQ$ .本蒟蒻总不可能浪费您的时间您说是吧，既然来了就不如看完呗。

我们的贪心策略之所以不成功，是因为没达到题目的要求：**在上下差值最小的前提下**，使翻转次数最少。
而**贪心只能保证翻转次数最少，不一定能使差值最小哦**。


举个简单的例子：

假设经过一系列操作后，我们的$s$(在代码中是$down-up$) 为$6$。

对于下图中左边的牌，显然不能单独翻转，因为它会产生$(1-6)×2=-10$的贡献，这样就修改了$s$的符号，不符合我们的贪心策略。

但是，将下图两张牌同时翻转呢？贡献总值为$-10+4=-6$，正好使$s=0$ 了！
![](https://cdn.luogu.com.cn/upload/pic/42528.png )

因此我们总结出一条新规律：**可以同时翻转两张差值符号相反的牌来让$s$的绝对值减少**。

贪心过后,$O(n^2)$ 暴力扫出对于每个单独的牌是否有牌与它配对产生新的贡献，如果能就保存。**然后再次贪心，选取贡献最大的牌对**。

$code:$
```cpp
    int maxn=0;     //每个单独的牌也要选和它配对贡献最大的，说白了还是贪心
    int k=1;
    for(int i=1;i<=n;i++)
    {
        maxn=0;
        for(int j=i+1;j<=n;j++)
        {
            int c=a[i]+a[j];  //配对
            if(abs(s)>abs(s+(c*2)) && abs(c)>abs(maxn))    //合法，且贡献最大
            {
                d[k]=c;	
                maxn=c;
            }
        }
        k++;
    }
    sort(d+1,d+k+1);
    for(int i=k;i>=1;i--)//从贡献大的开始扫
    {
        if(abs(s)>abs(s+d[i]*2))
        {
            ans+=2;//注意这里是＋２！因为是翻转两个单独的牌产生的贡献
            s+=d[i]*2;
        }
    }
```
把**两份代码合并起来**就能 $AC$ 啦QwQ.

很久以前写的，码风略稚嫩~~(说的好像现在不是一样)~~。而且毕竟官方正解是DP，不知道贪心对不对，
如果有问题欢迎各位dalao来指出来$hack$啦。

### 贪心不仅能过样例，也能$AC$的QwQ.



---

## 作者：皎月半洒花 (赞：36)

看到没有滚动数组的题解……哼，为什么没有卡空间呢qwq！？

首先我们看这个题，是个$dp$，线性单项递推第一维好像并没有什么问题。那我们不妨设$dp[i][j]$表示前$i$个物品，上下差值总和为$j$的最小交换次数。那么有一个显然的$init$是
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std ;
const int MAXN = 1010, NN = 5050 ; int out ;
int i, j, k, N, A[MAXN], B[MAXN], dp[MAXN][NN << 1] ;

int main(){
	cin >> N ; 
    memset(dp, 0x7f, sizeof(dp)) ;  
    dp[0][NN] = 0 ;
    ...........
   }
```

然后我们思考状态转移方程$$dp_{i, j} = min\{dp_{i, j - a_i+b_i}, dp_{i,j+a_i-b_i}+1 \}$$
类似于一个背包吧，那其实就是由翻或不翻转移过来的而已。诶，还有一点，由于是差值嘛，那么$A[i]-B[i]$在前者还是在后者，都是一样的，所以另一个方程当然也可以啊。$$dp_{i, j} = min\{dp_{i, j + a_i-b_i}, dp_{i,j-a_i+b_i}+1 \}$$

但是我们考虑，其实第一维是没有必要的，因为我们最终的状态是确定的即$dp[n][$ 不确定 $]$，所以我们可以滚去一维。那么最终的核心代码就长这个样：

```cpp
	cin >> N ; memset(dp, 0x7f, sizeof(dp)) ;  dp[0][NN] = 0 ;
	for(i = 1; i <= N; i ++) scanf("%d%d", &A[i], &B[i]) ;  
	for(k = i = 1; i <= N; i ++, k ^= 1){
		memset(dp[k], 0x7f, sizeof(dp[k])) ; 
		for(j = -5000; j <= 5000; j ++)
			dp[k][j + NN] = min(dp[k ^ 1][j + A[i] - B[i] + NN], dp[k ^ 1][j - A[i] + B[i] + NN] + 1) ;  ;
	}
```
咳咳，不知为什么迷恋上了压行$emmm$。

那么，由于我们的第二维$j$是单调的，所以我们从前往后扫一遍，遇到合法的就输出即可（合法：$\leq1000$，因为题目中至多交换$1000$次）
```cpp
	for(i = 0; i <= 5000; i ++){
		out = min(dp[N & 1][i + NN], dp[N & 1][-i + NN]) ;
		if(out <= 1000) { cout << out ; break ;} 
	}
```
嗯，最后贴一波标称吧$qwq$
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std ;
const int MAXN = 1010, NN = 5050 ; int out ;
int i, j, k, N, A[MAXN], B[MAXN], dp[2][NN << 2] ;

int main(){
	cin >> N ; memset(dp, 0x7f, sizeof(dp)) ;  dp[0][NN] = 0 ;
	for(i = 1; i <= N; i ++) scanf("%d%d", &A[i], &B[i]) ;  
	for(k = i = 1; i <= N; i ++, k ^= 1){
		memset(dp[k], 0x7f, sizeof(dp[k])) ; 
		for(j = -5000; j <= 5000; j ++)
			dp[k][j + NN] = min(dp[k ^ 1][j + A[i] - B[i] + NN], dp[k ^ 1][j - A[i] + B[i] + NN] + 1) ;  ;
	}
	for(i = 0; i <= 5000; i ++){
		out = min(dp[N & 1][i + NN], dp[N & 1][-i + NN]) ;
		if(out <= 1000) { cout << out ; break ;} 
	} return 0 ;
}
```
~~你甚至可以把它压到15行（亲测）~~

---

## 作者：pigstd (赞：21)

翻了许多题解，发现很少用一维数组的，而且没有像我一样写的，那就发篇题解吧

## 方法：**DP**

### 用$f[i]$ 代表达到$i$时的最小旋转次数，最开始的时候把$f[0]$设为$0$，其他都是极大值，则有：

```cpp
f[i+a1[i]]=f[i]//不翻转
f[i+a2[i]]=f[i]+1;//翻转
f[i]=MAXN//用过后就设为极大值
```

### 同时，用$sum$把和求出来，最后只要找到最接近$\frac{sum}{2}$的$i$且$f[i]$不是极大值的$i$就可以了

c++代码：
```cpp
#include<bits/stdc++.h>
#define MAXN 1061109567
using namespace std;

const int M=500000;
int n,sum;
int f[M];

int main()
{
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        sum+=x+y;
        for (int i=sum;i>=0;i--)//这里要倒着搜，否则在这一次被改变的数会再次被搜到
            if (f[i]!=MAXN)
            {
                int k=f[i];//这句话不加好像也没关系
                f[i+x]=min(f[i+x],k);
                f[i+y]=min(f[i+y],k+1);
                f[i]=MAXN;
            }
    }
    int Mid=sum/2;
    if (sum%2==0)
        for (int i=0;i<Mid;i++)
        {
             int ans=min(f[Mid-i],f[Mid+i]);
            if(ans!=MAXN)
            {
                cout<<ans;
                return 0;
            }
        }
    else
        for (int i=1;i<=Mid;i++)
        {
            int ans=min(f[Mid-i+1],f[Mid+i]);
            if(ans!=MAXN)
            {
                cout<<ans;
                return 0;
            }
        }
    //这里要分类讨论，否则会WA一个点
    return 0;
}
```

---

## 作者：kto_切子 (赞：16)

# 【一维数组解法】emmmm话不多说先贴代码

 ```
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;//总体为背包问题思路；
  
int n;     //我们把上下两个方块看成一组 ，分别求出suma-->上部总和
int suma,sumb;          //以及sumb 下部总和 
int v;                  //初始状态下两堆的差  注：具有方向性 
bool tryit[100005];
 //tryit[i]             能否使上下两堆的差为i 
int nowstep[100005];   
// nowstep[i]   从原始状态到上下两堆通过颠倒分配到的差为i 所需要的最小步数 
int mbao[1005]; //把 对每个骨牌（上and下）颠倒后产生的对suma-sumb的差的影响看做物品的体积 
int ass(int v1){return v1>0? v1:-v1;}
void init();//init 函数完成读入和初始化的过程 
int main()
{   init();  
for(int i=n;i>=1;i--)     // 由于mbao数组已排序，从大物品到小物品循环 可保证初始结果步数最少 
  {
    for(int j=v+100;j>=0;j--)  //为什么是v+100 ？ 因为mbao数组中有负数情况 
     {if(tryit[j]==true&&j+mbao[i]<=v+100)//便可能出现 使获利差先大于v再减回来的可能 
     	{tryit[j+mbao[i]]=true;
     	 if(nowstep[j+mbao[i]]==0)        //如果此前j+mbao[i] 位置还没有达到 
     	    nowstep[j+mbao[i]]=nowstep[j]+1;	
     	}	  
      if(tryit[v]==true)  //如果在过程中 v位置被幸运求出则立刻输出并结束程序 
        {
          printf("%d",nowstep[v]);
          return 0;
        }  
     }
  }
     for(int i=v-1;i>=0;i--)   //如果循环结束后还未寻找到利益差为v 的位置                          
     {                       //则从v-1位置开始向0循环，直到寻找到可以到达的位置（tryit[i]==true） 
     	if(tryit[i]==true)
     	 {
     	 	printf("%d",nowstep[i]);
     	 	return 0;
     	 }
     }
       printf("0");
       return 0;
}
void init()
{   scanf("%d",&n);
    for(int a,b,i=1;i<=n;i++)
    {scanf("%d%d",&a,&b);
     suma+=a;
     sumb+=b;
     mbao[i]=2*(a-b);     //*2  是因为颠倒一组，对上下两堆的差的影响是上下两个方块数字差的两倍 
    }                     //                                         （一个变大一个变小 ） 
     v=ass(suma-sumb);
    if(suma-sumb<0)       //统一uma-sumb 与  mbao数组内 上下两个方块的差的方向性 
     {for(int i=1;i<=n;i++) 
      {
      	mbao[i]=-mbao[i];
      }	
     }
    memset(tryit,false,sizeof(tryit));
    sort(mbao+1,mbao+n+1); //将  mbao数组（储存的是每组上下差）  按从小到大排序 
    tryit[0]=true;        //初始情况下，使上下两堆分配到的利益为0的情况是true的；  
    nowstep[0]=0;         //且 需要的 步数为0 
}
```


写在后面的话：
1.本题使用一维数组最大的困难就是统一每组上下差的方向性与 原本初始情况下数组suma与sumb差的方向性的问题。


2.运用类似01背包一维数组法的思路，并且利用物品从大到小，考虑位置从后往前的顺序，利用nowstep数组更新i位置的步数，利用特殊的顺序来保证最优性。











---

## 作者：北方有小仙儿 (赞：15)

## # **这题是我第一个自己做出来没看题解的蓝题！！**## 
激动的蹦跶，赶紧来发篇题解~~嘚瑟嘚瑟~~

------------
我们发现，每一组骨牌对答案的贡献都是独立的，所以可以单独计算。

设计状态为f[i][j],表示处理到第i个骨牌，所有上面的数减去所有下面的数的值为j的最小旋转次数。因为每一组的差值不超过5，最多有1000组骨牌，所以j的范围是-5000~5000。处理时将j都加上5000，来处理负数下标~~【本来没有考虑到这个竟然也过了...果然玄学】~~

状态转移方程为f[i][j]=min(f[i-1][j-(a[i]-b[i])],f[i-1][j-(b[i]-a[i])]+1); 

即如果不旋转，第i组骨牌的结果是a[i]-b[i]，所以从f[i-1][j-(a[i]-b[i])]转移过来，答案不加，如果旋转，第i组骨牌的结果是b[i]-a[i]，所以从f[i-1][j-(b[i]-a[i])]转移过来，答案+1。

剩下的就是统计答案了，按绝对值从小到大找，找到第一个有解的值就是答案，即差值最小时的答案，如果正负同时成立，就取最小值


上代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
int n,ans=1005; 
int a[1005],b[1005];
int f[1005][10005]; 
int p=5001;
int main()
{
	memset(f,0x3f3f3f,sizeof(f));
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
	f[1][a[1]-b[1]+p]=0;
	f[1][b[1]-a[1]+p]=1;
	for(int i=2;i<=n;i++)
	  for(int j=-5000;j<=5000;j++)
	    f[i][j+p]=min(f[i-1][j-(a[i]-b[i])+p],f[i-1][j-(b[i]-a[i])+p]+1); 
    for(int i=0;i<=5000;i++)
      if(f[n][i+p]<=1000||f[n][-i+p]<=1000)
      {
	    ans=min(f[n][i+p],f[n][-i+p]);
	    break;
	  }  
    cout<<ans;
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：10)

这种题目方法应该都是大同小异。

考虑一个背包，

显然如果我们直接设dp[i]表示前i个使差值最小所需的最少翻转次数，是具有后效性的。

所以我们将直接求最值，改为求某个值是否可行，这种求最值转变为求可行性的思想是非常实用的。

我们设dp[i][j]表示前i个数字通过某种旋转方式使得差值为j（不带绝对值）所需的最少翻转次数，那么我们最终dp结束后只需找到绝对值最小的非正无穷的dp值，输出即可。

考虑具体的dp过程（个人采用刷表法，填表法方程类似）：

dp[i+1][j+b[i]-a[i]]=min(dp[i][j]+1)//翻转

dp[i+1][j+a[i]-b[i]]=min(dp[i][j])//不翻转

初始化：dp[1][b[1]-a[1]]=1,dp[1][a[1]-b[1]]=0.

对于讨论中出现的极端数据，一定要把初始化方程按顺序（即=1的在上面，=0的在下面,这样的话如果a[1]=b[1]那么0就会直接覆盖上面的1）写就行了。

又因为Cpp语言中数组没有负的下标，所以还要数组平移一下。P党可以偷笑了。

至于背包不能加滚动数组的说法纯属che，dan，只是一些伪dalao的会而已。

滚动数组的方法具体可见代码。

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
template<class T>void ChkMin(T &a,T b){if (b<a)a=b;}
const int INF=0x3f3f3f3f;
const int N=1010;
int dp[2][20*N],a[N],b[N];//数组使劲开，我就是开小了，先是9，然后73，然后91，最后AC = =
int n;
int main(){
    scanf("%d",&n);
    int tot=0;
    for (int i=1;i<=n;i++){
        scanf("%d %d",&a[i],&b[i]);
        tot+=abs(a[i]-b[i]);
    }
    memset(dp,0x3f,sizeof(dp));
    dp[1][2*tot-a[1]+b[1]]=1;
    dp[1][2*tot+a[1]-b[1]]=0;
    for (int i=1;i<n;i++){
        int cur=i&1,nxt=cur^1;
        memset(dp[nxt],0x3f,sizeof(dp[nxt]));
        for (int j=tot;j<=3*tot;j++)
            if (dp[cur][j]<INF){
                ChkMin(dp[nxt][j+b[i+1]-a[i+1]],dp[cur][j]+1);
                ChkMin(dp[nxt][j+a[i+1]-b[i+1]],dp[cur][j]);
            }
    }
    for (int i=2*tot;i<=3*tot;i++)
        if (dp[n&1][i]!=INF || dp[n&1][4*tot-i]!=INF){
            printf("%d",min(dp[n&1][i],dp[n&1][4*tot-i]));
            break;
        }
    return 0;
}
```

---

## 作者：Bitter_ (赞：9)

蒟蒻刚刚学了下背包，于是来水一篇题解。

问题第一步是要把其转化为背包模型。看到我们可以翻转上下的骨牌，于是就提前把大的点翻到上面，也就是说，当$a[i]<b[i]$时，$w[i]=-1,c[i]=abs(a[i]-b[i])$

当$a[i]>b[i]$时,$w[i]=1,c[i]=abs(a[i]-b[i])$.

然后，我们还需要记录预处理时翻转的排数的数量$(base)$。因为翻动一张牌等于没翻，所以$dp$数组必会出现负数($w[i]=-1$),我们当然还要把原来翻过的排数加回来。

再需要一个$tot$变量记录背包体积，也就是上下点数之差之和。在不超过$tot$的条件下，使得背包装的物品体积最大，数量最少。

设$dp[i][j]$是前$i$件物品装够$j$的体积的最小数量，设$v[i][j]$表示当前前$i$件物品能不能把$j$的体积装满。

最后，我们倒序枚举$i$($1<=i<=tot$),找到最大的$i$，使得前n件物品可以装够$i$的体积。

于是，最后答案是$base+dp[n][i]$.

Code:
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define MAXN 100000
using namespace std;
int n,a[MAXN],b[MAXN],c[MAXN],w[MAXN],dp[2000][10000],tot;
int base,v[2000][10000],cnt; 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){//初始化 
		scanf("%d%d",&a[i],&b[i]);
		if(a[i]>b[i])w[i]=1,tot+=abs(a[i]-b[i]);
		if(a[i]<b[i])w[i]=-1,tot+=abs(a[i]-b[i]),base++;//下大于上才翻转 
		c[i]=abs(a[i]-b[i])*2;//价值等于上下之差的两倍 
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=tot;j++){
			dp[i][j]=dp[i-1][j];
			v[i][j]=v[i-1][j];//当前状态继承上次状态 
			if(v[i-1][j-c[i]]||j-c[i]==0){//如果上一次可以装满价值为j的物品或是这次可以 
				if(!v[i][j]){//将当前状态改为可以，并转移状态 
					dp[i][j]=dp[i-1][j-c[i]]+w[i];
					v[i][j]=1;
				}else dp[i][j]=min(dp[i][j],dp[i-1][j-c[i]]+w[i]);//否则不需要多余操作，直接转移即可 
			}
		}
	}
	for(int i=tot;i>=1;i--)if(v[n][i]){cnt=i;break;}//找到最大的体积，可以让n件物品正好装满 
	cout<<base+dp[n][cnt]<<endl;//用最后的答案加上之前所翻转的答案 
	return 0;
} 
```


---

## 作者：blackjack (赞：7)

其它题解都是背包（还有一个贪心的？？），我之前搞出一个神奇的方法，我也不知道这是什么方法，看起来像记忆化，但是其实并不是，因为最后我直接更改了全局变量而不是递推出结果。供大家参考（~~批判~~）吧,这里贴出我之前的解题报告，轻喷..


看起来是个背包模型，我们先打一下暴搜+剪枝。
tot表示当前所有骨牌的和（和的含义是上边的和减下面的和，不带绝对值）。K则是表示决定到了第k个，ans指的是一共操作了多少次。

## Code A
```cpp
#include<bits/stdc++.h>

using namespace std;
int n,up[1001],down[1001],minn,ANS=99999,dp[10010][1011];

void dfs(int tot,int k,int ans){
   if (dp[tot+5000][k]<=ans)
      return ;
   if (k==0){
      if (abs(tot)==minn)
         ANS=min(ans,ANS);
      if (abs(tot)<minn){
         minn=abs(tot),
         ANS=ans;
      }
      return ;
   }
   int temp=tot-up[k]-up[k]+down[k]+down[k];
   dp[tot+5000][k]=ans,
   dfs(tot-up[k]-up[k]+down[k]+down[k],k-1,ans+1),
   dfs(tot,k-1,ans);
}
 
int main(){
   freopen("test.in","r",stdin);
   freopen("test.out","w",stdout);
   cin>>n;
   memset(dp,1,sizeof(dp));
   int temp=0;
   for (int i=1;i<=n;i++)
      cin>>up[i]>>down[i],temp+=up[i]-down[i];
   minn=abs(temp);
   dfs(temp,n,0);
   cout<<ANS<<endl;
   return 0;
}
```

惊人80分。我这个剪枝还不够彻底，如果胡乱贪心一点，还可以在判断了tot的加减趋势是绝对值变大还是变小再搜，以及判断tot是奇数还是偶数。剪枝剪得更有效,速度更快。（当然，贪心的正确性不能保证，不过这个贪心的成功率还是很大的，因为每个骨牌上下颠倒修改的tot相对于tot整体很小。）

那么这题怎么用动归呢?

依据我已经打出的深搜剪枝。我想到，可以保持tot、k的含义不变，删去ans这个函数参数，使其变成函数的返回值，成为递推。

这样，我打出了如下代码。

## Code B
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,up[1001],down[1001],minn=666,dp[11001][1011]; 

int dfs(int tot,int k){
	if (dp[tot+5000][k]!=-1)
    	return dp[tot+5000][k];
   	if (k==0){
    	if (abs(tot)>minn)
        	return 9999;
        else{
        	minn=abs(tot);
            return 0;
        }
    }
    int ans=0;
    ans=dfs(tot-up[k]-up[k]+down[k]+down[k],k-1)+1;
   	ans=min(ans,dfs(tot,k-1));
    return dp[tot+5000][k]=ans;
}

int main(){
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
    cin>>n;
    memset(dp,-1,sizeof(dp));
    int temp=0;
    for (int i=1;i<=n;i++)
        cin>>up[i]>>down[i],temp+=up[i]-down[i];
   	int ans=0;
    ans=dfs(temp,n);
    cout<<ans<<endl;
    return 0;
}
```

这是90分，错在哪里呢？这个方法根本非主流，甚至不像是动归（看看加粗的字体部分）。

回顾一下我函数参数的定义。Tot表示总的值，k表示到第几个。注意到，由于tot表示的是总的值，这个是不具有最优子结构性质的！我们没有办法保证第一次搜到第k个的时候tot值就是全局的绝对值最小，而由于我第一次搜的时候就会把dp数组覆盖，所以我们dp里存的值未必是在tot绝对值最小时的最小操作次数。如果我们把tot表示成到第k个的值，用这种方法，就没有办法递归了！怎么办？我们的目标是形成最优子结构性质。

我们从dfs的规则入手。由于tot表示的是总的值，可能在边界前的一次更改，就是tot绝对值最小值，但是由于我们可能颠倒了骨牌，所以tot偏离了真正的最小值，这是不正确的。经过画图（搜索的是一棵二叉树），我们可以想到，只要在搜下去之前判断一下这么更改是不是能让tot绝对值更小就可以了！一定可以不颠倒骨牌，决定颠倒之前判断一下是不是能达到更优即可。我们还要每次搜索之前更新一下全局最小值，防止搜到最后不是tot绝对值最小值却认为是。当然，这个更改最小值的根本原因仍然是树。这个状态转移需要判断（虽然不判断其实也是可以的，反正最后都不是最优解），状态转移方程不好写。
## Code C
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,up[1001],down[1001],minn=666,dp[12001][1011],C[1001];

int dfs(int tot,int k){
	if (dp[tot+1000][k]!=-1)
		return dp[tot+5000][k];
	if (k==0){
		if (abs(tot)>minn)
			return 9999;
		else{
			minn=abs(tot);
			return 0;
		}
	}
	int ans=9999;
	minn=min(abs(tot-C[k]*2),min(abs(tot),minn));
	if ((tot>0 and C[k]>0) or (tot<0 and C[k]<0))
		ans=dfs(tot-C[k]-C[k],k-1)+1;
	ans=min(ans,dfs(tot,k-1));
	return dp[tot+5000][k]=ans;
}

int main(){
    freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	cin>>n;
	memset(dp,-1,sizeof(dp));
	int temp=0;
	for (int i=1;i<=n;i++)
		cin>>up[i]>>down[i],temp+=up[i]-down[i],
	C[i]=up[i]-down[i];
    int ans=0;
	ans=dfs(temp,n);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：zls6602488 (赞：5)

枚举可能的差值（类似于不用DP做的“装箱问题”的思路）；

设第i张牌的差值为cha[i]，刚开始有一个初始的差值sum（所有牌的上面和的减去下面的和），翻第i张牌的时候，上面的和减少cha[i],下面的和增加cha[i]，最终的效果就是使初始差值减少2\*cha[i]，然后只要开数组chazhi枚举可能的差值，最后从差值为-sum开始找就行

枚举方法看代码

```delphi

var  n,i,j,sum,x,y:longint;  
     a,b:array[-5010..5010]of longint;  
     cha:array[-10..1010]of longint;  
function min(a,b:longint):longint;  
begin  
   if a>b  then exit(b) else exit(a);  
end;  
begin  
   
  readln(n);  
  for i:=1 to n do  
    begin  
       read(x,y); cha[i]:=x-y; sum:=sum+cha[i]  
    end;  
   x:=5\*n; y:=-x;  
   if sum=0 then begin writeln(0);halt end;  
   for i:=1 to n do  
    begin  
       b:=a;     //很重要，因为差值有正有负，可能枚举中覆盖上一步的
                  所以每次先只在b中改变数值，第i张牌处理完后再把a变成b
        for j:=y to x do              //枚举的差值范围
         if a[j]>0 then    //步数不为0才做，也就是当前差值能够达到
         begin             //不为0时取最小步数
          if b[j-2\*cha[i]]>0  
           then b[j-2\*cha[i]]:=min(b[j-2\*cha[i]],a[j]+1)  
          else b[j-2\*cha[i]]:=a[j]+1;  
         end;  
         b[-2\*cha[i]]:=1;  
         a:=b;  
    end;  
   i:=-sum; j:=i;  
   while true do  
    begin  
       if (a[i]>0)and(a[i]<=a[j]) then  
        begin  
          writeln(a[i]);  
  
          halt;  
        end;  
       if a[j]>0 then begin writeln(a[j]);halt; end;  
       dec(i); inc(j);  
    end;  
     
end.

---

## 作者：ZIXT (赞：5)

算是想法比较粗暴的记忆化搜索

设第i个骨牌上半部分为UP[i],下半部分为DOWN[i],


考虑最后一个骨牌n,要求出绝对值最小（即最接近0）的所有骨牌上下两行的差,则: 

骨牌n**上下两个数**之差(翻转与不翻转两种情况)

加上 

前(n-1)个骨牌的**上下两行**之差

的和要最接近0，那么问题就转化为 求最接近(0 - 骨牌n**上下两个数**之差) 的前(n-1)个骨牌的**上下两行**之差

于是我们可以用dp(i,j)来表示前i个骨牌最接近数值j的差，方程为![](https://cdn.luogu.com.cn/upload/pic/15761.png)

(UD表示UP[i]-DOWN[i],DU反之，unrot代表骨牌不翻转时与j的差距，roted反之）

但是我们还要求最小翻转次数，所以还要增加一个rotCnt数组来求最小次数，并在unrot和roted相同时选择翻转次数最少的答案）

关于负数下标：可以将dp(n,0)换成dp(n,虚拟的零),这样差就会接近虚拟的零而不会产生负数

以下是代码

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int maxn = 1010;

int UP[maxn], DOWN[maxn], d[maxn][5000], rotCnt[maxn][5000];
bool vis[maxn][5000];
const int vzero = 2500;

int dp(int i, int j)
{
    if (vis[i][j])
        return d[i][j];
    if (i == 0)
        return vzero;
    vis[i][j] = true;
    int &ans = d[i][j];
    int UD = UP[i] - DOWN[i];
    int DU = DOWN[i] - UP[i];
    int unrot = abs(j - (UD + dp(i - 1, j - UD)));
    int roted = abs(j - (DU + dp(i - 1, j - DU)));
    if (unrot == roted)
    {
        if (rotCnt[i - 1][j - UD] < rotCnt[i - 1][j - DU] + 1)
        {
            ans = UD + dp(i - 1, j - UD);
            rotCnt[i][j] = rotCnt[i - 1][j - UD];
        }
        else
        {
            ans = DU + dp(i - 1, j - DU);
            rotCnt[i][j] = rotCnt[i - 1][j - DU] + 1;
        }
    }
    else if (unrot < roted)
    {
        ans = UD + dp(i - 1, j - UD);
        rotCnt[i][j] = rotCnt[i - 1][j - UD];
    }
    else
    {
        ans = DU + dp(i - 1, j - DU);
        rotCnt[i][j] = rotCnt[i - 1][j - DU] + 1;
    }
    return ans;
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &UP[i], &DOWN[i]);
    }
    dp(n, vzero);
    printf("%d\n", rotCnt[n][vzero]);
    return 0;
}
```

---

## 作者：1saunoya (赞：4)

># [$更好的阅读体验$](https://www.cnblogs.com/qf-breeze/p/10658374.html)

>这题是一个$DP$题

设$f[i][j]=k$表示前i张牌构成分值j的最小次数k

设 $dis = a[i]-b[i]$

//不反转 
$$f[i][j+dis+N]=min(f[i][j+dis+N],f[i-1][j+N]);$$

//反转 
$$f[i][j+dis+N]=min(f[i][j+dis+N],f[i-1][j+N]+1);$$

所以得出

$$f[i][j+N] = min(f[i-1][j-dis+N] , f[i-1][j+dis+N] + 1) ;$$

>反观复杂度 $O(N^2)$
>~~反正能过就行了~~

```cpp
#include <bits/stdc++.h>
#define rep(i,j,n) for(register int i=j;i<=n;i++)
#define Rep(i,j,n) for(register int i=j;i>=n;i--)
#define low(x) x&(-x)
using namespace std ;
typedef long long LL ;
const int inf = INT_MAX >> 1 ;
inline LL In() { LL res(0) , f(1) ; register char c ;
#define gc c = getchar()
    while(isspace(gc)) ; c == '-' ? f = - 1 , gc : 0 ;
    while(res = (res << 1) + (res << 3) + (c & 15) , isdigit(gc)) ;
    return res * f ;
#undef gc
}

int n ;
const int Size = 1000 + 5 ;
const int N = 5000 ;
int a[Size] , b[Size] ;
int f[Size][Size * 11] ;
int ans ;
inline void Ot() {
	n = In() ;
	rep(i,1,n) a[i] = In() , b[i] = In() ;
	memset(f,0x7f,sizeof(f)) ;
	f[0][N] = 0 ;
	rep(i,1,n) rep(j,-N,N) {
		int dis = a[i] - b[i] ;
		f[i][j+N] = min(f[i-1][j-dis+N] , f[i-1][j+dis+N] + 1) ;
	}
	rep(i,0,N) {
		int ans = min(f[n][N+i] , f[n][N-i]) ;
		if(ans <= 1000) {
			printf("%d\n",ans) ;
			return ;
		}
	}
}
signed main() {
//  freopen("testdata.txt","w",stdout) ;
    return Ot() , 0 ;
}

```

---

## 作者：SplenD1D (赞：3)

**枚举**

题解清一色的DP,可蒟蒻不会用DP,蒟蒻表示只会用**枚举**.没错,本题枚举可以得**满分**.

①枚举28分解法(满分的在后面):枚举每一张多米诺骨牌的颠倒情况,复杂度是O(2^n)
```cpp
#include <iostream>
using namespace std;
int n,a[1005],b[1005],min_res=0x7fffffff,ans=0x7fffffff;
int main(){
	cin>>n;

	for(int i=0;i<n;i++)cin>>a[i]>>b[i];//cout<<"---------";
	for(long long mask=0;mask<(1<<n);mask++){
		int suma=0,sumb=0,res,k=0;
		for(int i=0;i<n;i++)
			if(mask&1<<i)suma+=b[n-i-1],sumb+=a[n-i-1],k++;
			else suma+=a[n-i-1],sumb+=b[n-i-1];
		res=suma>sumb?suma-sumb:sumb-suma;
		if(min_res>res)min_res=res,ans=k;
		else if(min_res==res)ans=min(ans,k);
		//cout<<res<<" "<<k<<endl;
		//cout<<min_res<<" "<<k<<endl;
	}
	cout<<ans;
}
```
②枚举AC解法:枚举所有所得数字

上数:一个多米诺骨牌中,上面那个小方块所表示的数字,下数:同理;

假设有n个多米诺骨牌,n个多米诺骨牌中上数分别是a,b,c......

下数分别是A,B,C......

n个诺骨牌上数与下数差为n1,n2,n3...

则通过题意,可得下列关系:

|S1-S2|=|a+b+c+....-(A+B+C+...)|=|a+b+c+...-A-B-C-...|=|a-A+b-B+c-C+...|=|+n1+n2+n3+...|

如果颠倒了第1个多米诺骨牌的顺序,则相当于a-A变成了A-a,即n1变成了-n1,

如果颠倒了第i个多米诺骨牌的顺序,则相当于将ni变为-ni

最终可将多米诺骨牌问题简化为一个数学问题:

有N个数,分别为![Alt text](https://cdn.luogu.com.cn/upload/pic/73537.png)

算出![Alt text](https://cdn.luogu.com.cn/upload/pic/73738.png)

如何计算呢,可以用桶去记录下已经得到的值,

我这里的代码用的是bool dp[i][j],指:运算到第i个数时,j是否已经得到

例如
|±1±1±2|的最小值应是0,

dp[1][1]=1,dp[1][-1]=1表示,运算到第一个数的情况下,1和-1都已经得到了,因为第一个数是±1

dp[2][0]=1,dp[2][2]=1,dp[2][-2]=1表示,运算到第二个数的情况下,0已经得到(+1-1或-1+1),2已经得到(+1+1),-2已经得到(-1-1).

... ...

(桶数组大小是10000,因为该题中多米诺骨牌数量最大是1000,每一个n的最大值是6-1=5,最小值是1-6=-5,所以计算过程中,值的范围可能在-5*1000~5\*1000,为防止数组越界,则值每次记录在桶中时要加上5000,取出来时要减去5000,这个5000是bounds即边界)

这个可以用O(N*10000)的复杂度跑完,但是获得是多米诺骨牌|S1-S2|的最小值,并不是要颠倒多少次,所以我们要再开一个dp2数组,记录颠倒多少次.

对于上面那个简化问题,颠倒多少次,其实就是式子中使用的-负号的数量.例如|±1±1±2|的最小值应是|+1+1-2|=0,使用了1次负号,所以多米诺骨牌最优颠倒次数是1.

dp2[i][j]指,运算到第i个数时,j数用的负号的次数,这个可以用一个简单的递推去完成.

按照上述思路写后,未满分:
```cpp
#include <bits/stdc++.h>
#define bounds 5000
using namespace std;
int n,m[1005],tmp,a,b,dp2[1005][50002],ans=0x7fffffff;
bool dp[1005][10002],init;
int main(){
	//freopen("sample.in","r",stdin);freopen("sample.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a>>b,m[i]=a-b;
	memset(dp2,0x3f,sizeof(dp2));
	dp[1][m[1]+bounds]=dp[1][-m[1]+bounds]=1,dp2[1][m[1]+bounds]=0,dp2[1][-m[1]+bounds]=1;
	for(int i=2;i<=n;i++)
		for(int j=-5000;j<=5000;j++)
			if(dp[i-1][j+bounds])
				dp[i][j+bounds+m[i]]=dp[i][j+bounds-m[i]]=1,dp2[i][j+bounds-m[i]]=min(dp2[i][j+bounds-m[i]],dp2[i-1][j+bounds]+1),dp2[i][j+bounds+m[i]]=min(dp2[i][j+bounds+m[i]],dp2[i-1][j+bounds]);
	for(int i=-5000;i<=5000;i++)
		if(dp[n][i+bounds]&&(abs(tmp)>abs(i)||!init))
			tmp=i,init=1;
	for(int i=-5000;i<=5000;i++)
		if(dp[n][i+bounds]&&abs(i)==abs(tmp))
			ans=min(ans,dp2[n][i+bounds]);
	cout<<ans;
}
```
上面那个代码跑出来全都是MLE,内存超限,也就是说要空间上进行优化,这里我使用的滚动数组进行空间优化,pos是滚动下标变量.

```cpp
#include <bits/stdc++.h>
#define bounds 5000
using namespace std;
int n,m[1005],tmp,a,b,dp2[3][10002],ans=0x7fffffff;
bool pos=1,dp[3][10002],init;
int main(){
	freopen("sample.in","r",stdin);freopen("sample2.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a>>b,m[i]=a-b;//m[i]=a-b的操作就是获取ni
	memset(dp2,0x3f,sizeof(dp2));
	dp[1][m[1]+bounds]=dp[1][-m[1]+bounds]=1,dp2[1][m[1]+bounds]=0,dp2[1][-m[1]+bounds]=1;//初始化第一个数选择加号和负号(颠倒和不颠倒多米诺骨牌)的2种情况
	for(int i=2;i<=n;i++,pos=!pos){
		for(int j=-5000;j<=5000;j++)
			dp2[pos+1][j+bounds]=0x3f3f3f3f,dp[pos+1][j+bounds]=0;//初始化
		for(int j=-5000;j<=5000;j++)
			if(dp[!pos+1][j+bounds])
				dp[pos+1][j+bounds+m[i]]=dp[pos+1][j+bounds-m[i]]=1,dp2[pos+1][j+bounds-m[i]]=min(dp2[pos+1][j+bounds-m[i]],dp2[!pos+1][j+bounds]+1),dp2[pos+1][j+bounds+m[i]]=min(dp2[pos+1][j+bounds+m[i]],dp2[!pos+1][j+bounds]);
                //枚举已经得到的数,得到新的数字,这里可以做一些常数优化,就是值一旦修改了,拿一个变量记录一下,当变量达到了特定的值,就可以直接跳出
	}
	for(int i=-5000;i<=5000;i++)
		if(dp[!pos+1][i+bounds]&&(abs(tmp)>abs(i)||!init))
			tmp=i,init=1;
            //找min值
	for(int i=-5000;i<=5000;i++)
		if(dp[!pos+1][i+bounds]&&abs(i)==abs(tmp))
			ans=min(ans,dp2[!pos+1][i+bounds]);
            //核对min值,并将最少的颠倒次数计入ans
       //这里先找min值,再核对min值,是为了防止例如+2和-2这两种情况忽略成一种情况造成的错误
	cout<<ans;
}
```
满分.353ms.复杂度最大是O(10^(3+4))爆不了



---

## 作者：lsroi (赞：3)

# 一维数组解法
**数组作用**：f[i]表示经过最少反转数得到数字i的最小值，由于题目中a,b的值为1~6，所以范围为-5000~5000，开10000的数组即可。  
s数组为该对多米诺骨牌对整个序列的贡献，这个作用不大。

------------
**做法思路**：对于每对骨牌，若反转就会对使原值变成j-s[i]*2（设j为原值），所以对于每对骨牌，都反转一下，用这个来更新f数组，然后就直接DP做。


------------
**代码如下**：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int s[1005],f[10005];
int main()
{
    int n,a,b,i,j,x=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
      scanf("%d%d",&a,&b),s[i]=a-b,x+=s[i];
    for(i=0;i<=10000;i++)f[i]=99999999;//一开始默认要反转无穷多次得到值i
    f[x+5000]=0;//初始化，原值不需要反转，所以f[x]=0;
    for(i=1;i<=n;i++)   //枚举每对骨牌
    {
      if(s[i]==0)continue;
      //j为枚举哪些值是已经存在的，再计算反转之后对新数字的贡献
      for(j=5000;j>=0;j--)
      {
      	if(f[j]==99999999)continue;
	    if((j-s[i]*2)<=10000&&(j-s[i]*2)>=0)
	    {
		  f[j-s[i]*2]=min(f[j]+1,f[j-s[i]*2]);
		}
	  }
	  for(j=5000;j<=10000;j++)
      {
      	if(f[j]==99999999)continue;
	    if((j-s[i]*2)<=10000&&(j-s[i]*2)>=0)
	    {
		  f[j-s[i]*2]=min(f[j]+1,f[j-s[i]*2]);
		}
	  }
    }
    
    //按照题目要求，找出上下排骨牌之差绝对值最小，且反转次数最少，应该容易理解
    int a1,a2;
    for(i=5000;i>=0;i--)
      if(f[i]!=99999999){
	    a1=i;
	    break;
	  }
	for(i=5000;i<=10000;i++)
      if(f[i]!=99999999){
	    a2=i;
	    break;
	  }
	if(a1==a2)printf("%d",min(f[a1],f[a2]));
	else if(5000-a1<a2-5000)printf("%d",f[a1]);
	else printf("%d",f[a2]);
    return 0;
}
```


------------
为何DP时我要用两层for，原因是：对于0~5000（就是负数的情况）与5000~10000（正数的情况），它们对状态的转移是不一样的，DP要用已知值更新未知值，所以对于正负数循环的状态转移是要分开写的。（应该也容易理解吧）
**^_^**

---

## 作者：老卡手机 (赞：3)

蒟蒻第一次发题解，抱住可爱的我自己233

本题难度虽说洛谷写着提高+，但实质上是比较水的。

~~虽然我还是看了题解才会做~~

 # 细节在代码里解释，会详细写一些我自己感觉不太好懂的地方#
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
//1000个骨牌最小差为-1000*（6-1）=-5000，为防止下标负数越界加上5010 
int f[1005][10015];
//f[i][j]表示前i个骨牌的差为j-5010时需要翻牌的次数 
int a[1005],b[1005],c[1005];
//a为骨牌上方的数，b为骨牌下方的数，c为上方的数-下方的数（即差） 
const int N=5010;//懒得写5010(笑) 
int main()
{
//	freopen("in.txt","r",stdin);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i]>>b[i],c[i]=a[i]-b[i];
	
	memset(f,0x7f,sizeof(f));//f[i][j]=0x7f表示无法在前i个骨牌使差为j 
	f[0][0+N]=0;//0个骨牌一次都没翻，差为0 
	
	//dp过程，其实主要就一行233 ~~所以说很水啊 ~~
	for(int i=1;i<=n;i++)
	for(int j=10;j<=10010;j++)//由10开始是因为由1开始j-c[i]可能为负 
	{
		//重点，敲黑板
		//①f[i-1][j-c[i]]表示前i-1个骨牌的差为j-c[i]，而第i个骨牌的差为c[i]，所以不用翻
		//②同理，f[i-1][j+c[i]]表示前i-1个骨牌的差为j+c[i]，而第i个骨牌的差为c[i]
		//  所以需要翻一次后差为-c[i]，后同①。所以需要+1  
		f[i][j]=min(f[i-1][j-c[i]],f[i-1][j+c[i]]+1);
	}
	//选择答案 
	int ans1=10000,ans2=1000;//ans1表示n个骨牌的差，ans2表示最少需要翻几次（分别对应j和f[n][j]) 
	for(int j=10;j<=10010;j++)
	{
		if(f[n][j]<f[0][0])//检查差是否可以等于j -N(还记得差加了5010吗)，如果有做过肯定小于初始值 
		{
			if(fabs(j-N)<=ans1)//题目要求差最小 
			{
				if(fabs(j-N)==ans1)//如果差相等，表示从负的做到正的，再做肯定比现在的差大，直接退出 
				{
					ans2=min(ans2,f[n][j]);break;
				}
				//更新两个ans 
				ans1=fabs(j-N);
				ans2=f[n][j];				
			}
		}
	}
	//这个也很重要，输出每一个值可以帮助自己检查，很实用的技巧 
/*
	for(int i=1;i<=n;i++)
	for(int j=5000;j<=5020;j++)
	printf("f[%d][%d]=%d\n",i,j-5010,f[i][j]);
*/	
	cout<<ans2;
	return 0;
}
```
我感觉我写的好详细啊，下次要偷懒一点233

---

## 作者：nothingness (赞：3)

为什么大家做这题都是用的DP？这让我不会DP的蒟蒻无地自容啊。

那么，就让我来发第一篇BFS(是的，你没看错)题解吧...~~(管理员大大求给过，原创)~~

其实这题很像BFS的模板，我们可以一层层的搜下去，翻转一次，两次，三次等能不能得到最小值。当得到最小值的时候就直接 ${exit(0)}$ ，妥妥的套模板。

不过问题来了:
1. 用BFS万一TLE了怎么办？

- 我怎么知道最小值是多少？

Solution :
1. 剪枝

- 求出最小值

~~看上去是不是什么都没说？开个玩笑~ ~，具体方法见代码和注释~~ 

## Code

```cpp

/*     蒟蒻的第一篇题解,若有不当,敬请指正     */

#include "bits/stdc++.h"
using namespace std;

int n,m,k,sum,p,a[1001],b[1001],dp[6001],s[1001];
int f[100001],q[100001],h,t,boo[100001],del[10001][1001];
//a[i],b[i]:输入的点数    s[i]:一张牌上的点数差的绝对值
//boo[i]:标记上下之差为i时是否搜索过
//(因为求最小翻转,所以最先到达某个状态的一定是最优解)
//del[i][j]:第i个状态时哪些牌被翻转过(每张牌最多翻转一遍)
int push(int x,int o)
{
	if(boo[x+50000]==1)
		return 0;
    //若此状态被搜索过就返回
    //因为Σs1-Σs2可能为负数,所以要整体向右偏移,避免数组下标越界(P党福音)
    //即使极端情况1000个6-1,偏移5000也够了,我手贱多打了个0
	if(del[h][o]==1)
		return 0;
    //如果该状态时这张牌被翻转过就返回
	boo[x+50000]=1;
	if(x==k||x==-k)//±k:当上方比下方多k或少k时都是符合条件的
	{
		printf("%d",f[h]);
		exit(0);
	}
	t++;
	for(int i=1;i<=n;i++)
		del[t][i]=del[h][i];
	del[t][o]=1;
    //标记此状态时翻转过的牌(这题数据略水,不标记也只有两个点WA)
	q[t]=x;
	f[t]=f[h]+1;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		s[i]=abs(a[i]-b[i]);
		p+=a[i]-b[i];
		if(a[i]>b[i])
			a[i]-=b[i],b[i]=0;
		else
			b[i]-=a[i],a[i]=0;
        //将a[i],b[i]其中一个缩减到0，方便标记
        //事实上,6-3 5-2 4-1 3-0等差值相同时,都是等价的
		sum+=s[i];//求总差值
	}
	m=sum/2;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=s[i];j--)
			dp[j]=max(dp[j],dp[j-s[i]]+s[i]);
	k=sum-2*dp[m];
    //这里用到了01背包的思路:选一部分在上方,剩下的在下方,上方的当做要选取的物品
    //那么就有n个物品,背包的总体积为m=sum/2,物品的价值和体积都为s[i]
    //在sum/2的体积中选取最大价值(类似装箱问题),则选取体积最接近于总体积的一半时,两份体积的差最小
    //所以最小差值即为k=(sum-dp[m])-dp[m]=sum-2*dp[m]
	push(p,0);//BFS模板
	do
	{
		h++;
		for(int i=1;i<=n;i++)
			if(a[i]==0)//上方小于下方,翻转后Σs1-Σs2变大
				push(q[h]+2*s[i],i);
			else//上方大于下方,翻转后Σs1-Σs2变小
				push(q[h]-2*s[i],i);
	}
	while(h<t);
	return 0;
}
```

#### 写在最后:
对于参加NOIP的选手,即使不会DP,遇到DP题也不要放弃,去尝试着拿暴力分,广搜深搜记搜都能拿到部分分甚至满分(像这题),无论如何都不要放弃,或许还能有新的收获。

---

## 作者：翠竹叶飞 (赞：3)

经典的01背包，只是每件物品必须选（2种方式，但是一定要有1种）

1.不加空间优化

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define INF 0x7f7f7f7f
using namespace std;
int i,j,n,m,tot,ans;
int a[1001],b[1001];
int f[1001][6001];
int main()
{
    memset(f,INF,sizeof(f));
    scanf("%d",&n);
    for (i=1; i<=n; i++){
      scanf("%d%d",&a[i],&b[i]);
      tot+=a[i]+b[i];
      m+=max(a[i],b[i]);
    }
    f[0][0]=0;
    for (i=1; i<=n; i++)
    {
        for (j=m; j>=1; j--)
        {
            if (j>=a[i]) f[i][j]=min(f[i][j],f[i-1][j-a[i]]);
            if (j>=b[i]) f[i][j]=min(f[i][j],f[i-1][j-b[i]]+1);
        }
    }
    int num=tot>>1; //位运算加速
    for (i=num;;i--)
    {
        ans=min(f[n][i],f[n][tot-i]);
        if (ans<INF){
            printf("%d",ans);
            return 0;
        }
    }    
}
```
2.加空间优化（注意状态的转移）
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define INF 0x7f7f7f7f
using namespace std;
int i,j,n,m,tot,ans;
int a[1001],b[1001];
int f[6001];
int main()
{
    memset(f,INF,sizeof(f));
    scanf("%d",&n);
    for (i=1; i<=n; i++){
      scanf("%d%d",&a[i],&b[i]);
      tot+=a[i]+b[i];
      m+=max(a[i],b[i]);
    }
    f[0]=0;
    int tmp;
    for (i=1; i<=n; i++)
    {
        for (j=m; j>=0; j--)
        {
            tmp=INF; //tmp代表取此物品更优秀的方式，并且强制地取 
            if (j>=a[i]) tmp=f[j-a[i]];
            if (j>=b[i]) tmp=min(tmp,f[j-b[i]]+1);
            f[j]=tmp;
        }
    }
    int num=tot>>1;
    for (i=num;;i--)
    {
        ans=min(f[i],f[tot-i]);
        if (ans<INF){
            printf("%d",ans);
            return 0;
        }
    }    
}
```

---

## 作者：han_lx (赞：1)

### 由于我太菜，这道题卡了我好久，思路不够连贯，so一边写代码一边加注释，死去活来，直接上代码
```cpp
#include<iostream> 
#include<algorithm> 
#include<cstdio> 
#include<cstdlib>
#include<cstring> 
#include<queue> 
#include<cmath> 
#define ll long long
using namespace std;
/*因为刚学oi不久，我太菜了，看了好久才看出背包，然后卡了n久 ，我太南了 
由于为了符合我蒟蒻的身份，我没有用滚动数组优化~~（其实是我不会）~~*/ 
int n;
int f[1333][12333];
/*我一开始做的时候没有想到，j是有可能为负，so要加上5005防止越界 
(12333显然是我随便打的) */ 
//f[i][j],i表示第几张多米诺骨牌，j表示j大小上下部分差，显然f中存为翻转次数 
int a[23333],b[32222],ab[23333];
//a[]表示上部分，b[]表示下部分，c[]表示a，b的差 
int sum;//表示上下骨牌差最大的情况 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a[i],&b[i]);
        ab[i]=a[i]-b[i]; 
    }
    memset(f,0x3f,sizeof(f)); //当f数组值为0x3f时 ，说明无法在此情况使差为j 
    f[0][5005]=0;//没翻且没值 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=10010;j++)
        {
            //！！！这里很重要 
            if(j>=ab[i]) 
			f[i][j]=min(f[i-1][j-ab[i]],f[i-1][j+ab[i]]+1); 
			/* f[i-1][j-c[i]]表示前i-1个骨牌的差为j-c[i]，而第i个骨牌的差为c[i]，所以不用翻
               同理，f[i-1][j+c[i]]表示前i-1个骨牌的差为j+c[i]，而第i个骨牌的差为c[i]
               所以需要翻一次后差为-c[i]，方法同上，所以需要+1  */ 
        }
    }
    int ans=2333333,cnt=23333333;//ans表示n个骨牌的差，cnt表示最少需要翻几次（分别对应j和f[n][j]) 
    for(int i=1;i<=10010;i++) 
    {
    	if(f[n][i]<f[0][0])//检查差是否可以等于j-5005，如果有做过肯定小于初始值 
        {
            if(abs(i-5005)<=ans)//题目要求差最小 
            {
                if(abs(i-5005)==ans)
                {
				    //如果差相等，那么再做肯定比现在的差大，退出就完事了 
                    cnt=min(cnt,f[n][i]);
					break;
                }
                ans=abs(i-5005);
                cnt=f[n][i];               
            }
        }
	}
	printf("%d",cnt); 
}
```


---

## 作者：Ciyang (赞：1)

最近练习DP，看到这道题，背包？

在博客中观看效果更佳：[My blog](https://xciyang.github.io/)

### 分析

首先看数据范围$(N <= 1000, A_i/B_i <= 6)$，那么搜索当然不可能，肯定是考虑动态规划。

还是回归搜索上，比较好分析。一个牌只有两种状态，旋转与不旋转。我们只需要先找到最小差，再考虑最小旋转次数。

再看数据范围，$O(6N^2)$不会超时。我们既要求最小差又要求最小最小旋转次数，又可知所有数的总和是确定的，不如就设个背包。

$F[N(1000)][SUM(6000)]$表示处理到第N个点，上方块的和为SUM时最小的旋转次数。

一开始除$F[0]$为0外都赋值为无穷大，然后转移$A_i$表示上方块,$B_i$表示下方块。

$$F[N][i] = min(F[N - 1][i - A_i], F[N - 1][i - B_i] + 1)$$

然后由于比较闲（怕超空间，然而并不会？）。显然，只要记录N-1的状态，就开了滚动数组$F[2][SUM]$。

最后先找最小差，我们计算$X = \lfloor\frac{SUM}{2} \rfloor$。

如果$SUM$为奇，那么上下差不可能为0，并且上方块和为$X$或$X + 1$时差都为1，因此再设置$Y = X + 1$。

如果$SUM$为偶，那么上方块和为$X$时上下差就为0，$Y = X$。

我们枚举一个数$i$从0开始，不断增大，表示一个范围（大概是这样）。

判断$F[N][X - i]$和$F[N][Y + i]$是否有值，若有则输出小的那个。

### 代码

代码较丑，推荐自己写代码。

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
int n, a[1005], b[1005], c[1005], f[2][8000], sum;
int main() {
	cin >> n;
	for(int i= 1; i <= n; i++) cin >> a[i] >> b[i], c[i]= a[i] - b[i], sum+= a[i] + b[i];
	memset(f, 0x3f, sizeof(f));
	f[0][0]= 0;
	for(int i= 1; i <= n; i++) {
		for(int j= 0; j <= sum; j++) f[i & 1][j]= 0x3f3f3f3f;
		for(int j= sum; j >= a[i]; j--) f[i & 1][j]= f[(i & 1) ^ 1][j - a[i]];
		for(int j= sum; j >= b[i]; j--) f[i & 1][j]= min(f[i & 1][j], f[(i & 1) ^ 1][j - b[i]] + 1);
	}
	int res= 0x3f3f3f3f, sum1= sum / 2, sum2= sum1 + sum % 2;
	for(int i= 0; i < sum; i++) {
		if(sum1 + i > n && sum2 - i < 1) break;
		res= min(f[n & 1][sum1 + i], f[n & 1][sum2 - i]);
		if(f[n & 1][sum1 + i] != 0x3f3f3f3f || f[n & 1][sum2 - i] != 0x3f3f3f3f) break;
	}
	cout << res << endl;
	return 0;
}
```

### 后记

我的代码必须开8000，如果开8000以下好像会RE。

---

## 作者：z7z_Eta (赞：1)

####多米诺骨牌 solution

本题背包 ~~毕业~~ 题

排在普及组DP，难度应该不大。

指针真是好东西。

对每个多米诺方块， 显然只能选或不选，便转换成了*01背包*问题

发现背包的 $val\in[-5,5]\cap Z$， 开桶计数，便转换成了*多重背包*问题

虽然本题范围小，$O(n^2)$可过，但我还是写了多重背包

主要是对于负数的处理，现在，请理解以下DP基础内容：

* 状态：`f[i][j]表示考虑前i个物品，val为j时，能取得的cost_min`

* 初态：`f[0][sum]=0，其余设为inf \\初态不需要花费=0，sum是上下点数之差`
* 转移：`枚举每个物品的二进制展开`

可以看本题第三篇（目前）[dj114133643](https://www.luogu.org/space/show?uid=52527)的题解

这里，本人用滚动数组可优化空间为n

至于对上面题解`f[i][j+N]`，这里也做了优化，用指针定向寻址，不仅速度快了，代码也简洁了不少。

简单说是把指针指向数组中间的位置，然后可以这样调用`f[i][j]`，不用管$j$的正负性了。

其他的内容，代码中比较详细了

代码如下：加了宏

```cpp
// luogu-judger-enable-o2
// Etavioxy
#include<cstdio>
#include<cctype>
#define re register
#define ll long long
#define il inline
#define rep(i,s,t) for(re int i=(s);i<=(t);i++)
#define pt(ch) putchar(ch)
#define pti(x) printf("%d",x)
#define ptll(x) printf("%lld",x)
using namespace std;
//c_ints
il int ci(){
    re char ch;
    while(!isdigit(ch=getchar()));
    re int x=ch^'0';
    while(isdigit(ch=getchar()))x=(x*10)+(ch^'0');
    return x;
}
enum{N=36000,inf=01777777777};
int cnt[11],f[2][N];
int *F[2];
il void dp(int dis,int cost,bool o){
    rep(i,-5000,5000) F[o][i]= min(F[o^1][i],F[o^1][i-dis]+cost);
}
int main(){
    //init
    memset(f,0x3f,sizeof(f));
    int* Cnt= cnt+5;
    F[0]= f[0]+18000;
    F[1]= f[1]+18000;//用ptr定向寻址
    //read
    int n= ci();
    int x,sum= 0;
    rep(i,1,n) Cnt[ x=ci()-ci() ]++, sum-= x;//读入封装
    //dynamic programming
    F[0][sum]= 0;//初态
    bool cur= 0;
    rep(i,-5,5) if( i!=0 ){
        for(re int j=1;j<=Cnt[i];Cnt[i]-=j,j<<=1)//多重背包
            dp( i*  j   *2 ,    j   ,cur^=1 );
        if( Cnt[i] )
            dp( i*Cnt[i]*2 , Cnt[i] ,cur^=1 );//每次dp开始时改变cur 
    }
    //answer
    int ans;
    rep(i,0,5000)
        if( (ans=min(F[cur][-i],F[cur][i])) < 1000 ){//次数最少差最小
        	pti(ans);
        	return 0;
    	}
    //end main
    return 0;
}
```

$luogu:34 ms$



---

## 作者：MXR612 (赞：1)

### # ~~思路DP~~

把每对数求差（因为上减下等于下减上*-1），差值的和就是上剪下的值

求：把部分数（数对的差值）翻转（乘-1）得到一个数列，和等于等于原来上剪下的值乘-1

# 重点就是哪些数要翻转（*-1）！于是01背包

状态转移方程（j当前数，a是当前差值）：


```cpp
dp[j]=min(dp[j],dp[j+2*a]+1)
```

因为一个数 **翻转前-翻转后=2x翻转前** ，所以要x2

注意一个细节~~（不注意也有九个点）~~：
由状态转移方程可知当a<0时，j+2* a<j，所以受小于j的数影响，所以要从大往小更改（无后效性）a>0则相反

附代码：

由于有负数，所以dp数组存储的时候都加MID，将MID定义为0

```
#include <stdio.h>
#include <string.h>

#define MID 30000
#define min(a,b) a<b?a:b

int n;
int a,b;
int dp[60000];
int ans = MID;

int main()
{
	memset(dp, int(0x6f), sizeof(dp));
	dp[MID]=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d %d",&a,&b);
		a-=b;
		ans-=a;
		if(a>0){
			for(int j=MID-6*n;j<MID+6*n;j++){
				dp[j]=min(dp[j],dp[j+2*a]+1);
			}
		}else if(a<0){
			for(int j=MID+6*n;j>MID-6*n;j--){
				dp[j]=min(dp[j],dp[j+2*a]+1);
			}
		}
	}
	if(dp[ans]==dp[0]){
		ans=min(dp[ans+1],dp[ans-1]);
	}else{
		ans=dp[ans];
	}
	printf("%d\n",ans);
	return 0;
}
```

普及134分的蒟蒻奉上（写了三天）

---

## 作者：寒鸽儿 (赞：1)

### 我的思路很暴力，嗯，跟dalao比不了。
### dp[i]表示到状态i所需要的操作数。a，b表示储存牌的数组。假定最优解产生在a,在对于某一个物品的扩展中，可以选择翻转和不翻转。分别用d1和d2来做。然后合并。重点是在本轮要删除上一轮的状态（见注释①），因为每次必须“选”一边的骨牌
### 鉴于我们并不知道哪个一面是最优的面，所以应该计算两次(见注释②)
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

int n;

int min(int a, int b) {
        return a < b ? a : b;
}

int mind(int a, int b) {
        if(a == -1) return b;
        if(b == -1) return a;
        return a < b ? a : b;
}

int dp(int *a, int *b, int half) {
        int d1[23000], d2[23000];
        memset(d1, -1, sizeof(d1));
        memset(d2, -1, sizeof(d2));
        d1[0] = d2[0] = 0;
        for(int i = 0; i < n; i++) {
                for(int j = half; j > -1; --j) {
                        if(j < a[i] || d1[j-a[i]] == -1) d1[j] = -1;		//①在本轮无法被到达的状态记录为-1，删除这种状态
                        else d1[j] = d1[j-a[i]];
                        if(j < b[i] || d2[j-b[i]] == -1) d2[j] = -1;
                        else d2[j] = d2[j-b[i]] + 1;
                }
                for(int j = half; j > -1; --j)
                        d1[j] = d2[j] = mind(d1[j], d2[j]);
        }
        for(int j = half; j > -1; --j)
                if(d1[j] != -1)
                        return d1[j];
}
int a[13000], b[13000];
int main() {
        int sum = 0;
        scanf("%d", &n);
        for(int i = 0; i < n; i++) {
                scanf("%d %d", a+i, b+i);
                sum += a[i];
                sum += b[i];
        }
        int ans = min(dp(a, b, sum>>1), dp(b, a, sum>>1));		//②
        printf("%d\n", ans);
        return 0;
}

```

---

## 作者：KryptonAu (赞：1)

### 我的思路似乎和大多数人不一样~~（只翻了前几页题解，有重复别打我）~~
---
这道题题解也不少了，我就直接说做法了。
1. 预处理：$a[i]$ 表示 $i$ 位置的骨牌翻转后的差值，状态数组$F[0][0]$初始化为所有骨牌一张都没翻转时上下点数之差，其余初始化为无穷大。
2. 确认状态：$F[i][j]$ 表示前 $i$ 骨牌翻转 $j$ 次上下点数和之差绝对值的最小值(记录状态时不能取绝对值）。
3. 划分阶段：已处理的骨牌个数。
4. 转移方程：$F[i][j]=F[i-1][j-1]+2*a[i]$ $if(abs(F[i-1][j-1]+2*a[i])<abs(F[i][j]))$
5. 目标：$F[N][i]$ 取最小值时 $i$ 的值.
---
### 嗯，好像可以水过这道题了。

先上个代码

```cpp
#include<cctype>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
template<class T>
inline void read(T &x){
    x=0; int sign=1; char c;
    do{c=getchar(); if(c=='-') sign=-1;}while(!isdigit(c));
    do{x=x*10+c-'0',c=getchar();}while(isdigit(c));
    x*=sign;
}
int n,F[10005],a[1005];
int main(){
    read(n);
    memset(F,0x3f,sizeof(F)); F[0]=0;
    for(register int i=1;i<=n;++i){
    	int x,y; read(x),read(y);
    	F[0]+=x-y,a[i]=y-x;
    }
    for(register int i=1;i<=n;++i) //显然第一维可以模仿01背包，直接舍掉
    for(register int j=i;j>0;--j) //倒序循环
    if(abs(F[j-1]+2*a[i])<abs(F[j])) F[j]=F[j-1]+2*a[i];
    int minn=19260817,pos;
    for(register int i=0;i<=n;++i) if(abs(F[i])<minn)
    minn=abs(F[i]),pos=i;
    cout<<pos; 
    return 0;
}
```
---
### 辣么，恭喜你，WA了（手动滑稽）
为啥子嘞？？思路应该没错啊。其实，仔细一想，你会发现状态转移的时候是有疏漏的，假设$F[i]$的值为X（X>=0），那么如果有一个-X要转移过来，按照上面代码，-X的值是不会记录的，这显然会导致有后效性，那么如何解决呢？
#### 其实很简单
只需把正负两个值都记录下来即可，废话不多说，直接上代码

---

```cpp
#include<cctype>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
template<class T>
inline void read(T &x){
    x=0; int sign=1; char c;
    do{c=getchar(); if(c=='-') sign=-1;}while(!isdigit(c));
    do{x=x*10+c-'0',c=getchar();}while(isdigit(c));
    x*=sign;
}
int n,F[1005][2],a[1005];  //规定F[i][0]记录正整数，F[i][1]记录负数
int main(){
    read(n); int temp=0;
    memset(F,0x3f,sizeof(F));
    for(register int i=1;i<=n;++i){
    	int x,y; read(x),read(y);
    	temp+=x-y,a[i]=y-x;
	}
	F[0][temp>=0]=temp;
	for(register int i=1;i<=n;++i)
	for(register int j=i;j>0;--j){
		int pre1=F[j-1][0]+2*a[i],pre2=F[j-1][1]+2*a[i];
		int d1=pre1>=0,d2=pre2>=0;
		if(abs(pre1)<=abs(F[j][d1])) F[j][d1]=pre1;
		if(abs(pre2)<=abs(F[j][d2])) F[j][d2]=pre2;
	}
	int minn=19260817,pos;
	for(register int i=0;i<=n;++i) if(abs(F[i][0])<minn||abs(F[i][1])<minn)
	minn=min(abs(F[i][0]),abs(F[i][1])),pos=i;
	cout<<pos; 
    return 0;
}
```


---

## 作者：杨松瀚 (赞：1)

由于动态规划学得不好，选择了简单的记忆化搜索，代码虽然长一些，但是非常好理解。看到还没有类似的题解，就发出来供大家参考。

先考虑以下逻辑：

1、骨牌有意义的只有差值，而且差值只有-5~5，因此录入数据的时候用桶排序的方法把各个差值的数量记录下来即可。

2、每个骨牌翻一次都对总差值产生本身差值2倍的影响，因此当骨牌差值为1或者-1时，已经无法更接近0，此时应该结束搜索。

3、总差值为正时，只需要翻使差值减小的5组骨牌，反之也是一样。而且翻过的牌可以去除（再翻回来一定不是最优）。

4、从一个方向（大于0或者小于0）最接近0，不等于就是最优解，还要考虑跨过0到另一个方向后是否可以有更接近0的解。（这一条对深搜没有实质性作用，却是选择深搜方法的原因，我一开始想简单了，直接单方向求解）

5、在搜索的每一步，都要更新最接近0的值和步数，因为有可能会越走越远。


其他就没什么了，上代码：
```cpp
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;

int n,ans,nearest,bulk[20],f[10000];
const int WY=5000;      //防止数组下标负数的位移值
 
void calc(int delta,int times)
{
	if(f[delta+WY]>=0 && f[delta+WY]<=times)       //判断历史值是否已经更优
		return;
	
	if(nearest==abs(delta))             
	{
		if(times<ans) ans=times; //记录这个位置的最优解
	}
	else if(abs(delta)<nearest)  //更新最接近0的位置
	{
		nearest=abs(delta);
		ans=times;
	}
	f[delta+WY]=times;           //记住当前值

	if(times>n || delta==0 || delta==1 || delta==-1)   //已经无法更加接近，到此为止
		return;
	
	if(delta >0)  //差值大于0，只需翻5个桶里的骨牌
	{
		for(int i=5;i>=1;i--) 
		if(bulk[i+6]>0)
		{
			bulk[i+6]--;  //翻一张牌，从桶里去除
			calc(delta-2*i,times+1); //深搜
			bulk[i+6]++;  //恢复
		}
	}
	else if(delta <0)
	{
		for(int i=-5;i<=-1;i++) 
		if(bulk[i+6]>0)
		{
			bulk[i+6]--;
			calc(delta-2*i,times+1);
			bulk[i+6]++;
		}
	}
}
int main()
{
	int up,down,sumup,sumdown,delta;
	cin>>n;
	sumup=sumdown=0;
	for(int i=1;i<=n;i++)
	{
		cin>>up>>down;
		bulk[up-down+6]++;  //进桶，偏移6避免数组下标负值
		sumup+=up;
		sumdown+=down;
	}
	delta=sumup-sumdown;    //总差值
	memset(f,-1,sizeof(f));
	nearest=abs(delta);     //记录最接近0的位置
	calc(delta,0);
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Paul_Guderian (赞：1)

**观赏题目，我们发现原问题可以这样理解：将这2n个数每组（即每个骨牌）抽取一个放入两个集合之一，**

**求形成的两集合元素和相差最小的情况下，最小的骨牌反转次数。**

**所以呢，大米兔首先想出的是一个这样的背包:**

**第一步求出原来两个数组的总和的差值Delta是多少。**

**第二步进行背包DP，每个物品的质量为：a[i]-b[i]**

**这样做相当于是我们企图去弥补两个数组和的差异Delta。**

**第三步就是找到一个能够构造出来的最小的Delta就行啦。**

**但是由于经验不足等原因，对负数的处理很笨（额，后来发现可以直接加上一个很大的N），**

**又WA来WA去的，所以就自己改进了方法：**

**直接进行背包DP，f[i][j]表示用前i个骨牌每个骨牌其中一个数能够构成j，如果能够构成j，**

**那么f[i][j]存储的就是最小步数，否则存储inf。**

**最后就是和上文最后一步类似，找一个最小的Delta下最小的步数就可以了。这样做就好多了。**

```cpp
#include<stdio.h>
#include<algorithm>
#define inf 1000000000
#define S(x) (x[i]^=x[j]^=x[i]^=x[j]) 
#define go(i,a,b) for(int i=a;i<=b;i++)
int A(int x){return x>0?x:-x;}
using namespace std;const int N=1003;
int n,sum,a,b,f[N][N*10],W=7000,step=inf,D=inf,d;
int main()
{
    scanf("%d",&n);go(i,1,n)
    {
        scanf("%d%d",&a,&b);sum+=a+b;go(j,0,W)f[i][j]=inf;
        if(i==1){f[1][a]=0;f[1][b]=1;continue;}go(j,1,W)
        j-a>=0?f[i][j]=min(f[i][j],f[i-1][j-a]):1,
        j-b>=0?f[i][j]=min(f[i][j],f[i-1][j-b]+1):1;
    }
    go(j,1,W)if(f[n][j]!=inf)(d=A(sum-j-j))==D?step=min(step,f[n][j]):1,
    d<D?D=d,step=f[n][j]:1;printf("%d",step);return 0;
}//Paul_Guderian
```

---

## 作者：kczno1 (赞：1)

先求出最小差(mini)，

再记忆化搜索。

(可能不是最优的算法。。。)


```delphi

const p=2000;

var
  n,i,x,y,mini,j:longint;
  a,b:array[1..1000]of longint;
  c:array[0..5010]of boolean;
  f1:longint;
  sum:array[1..1001]of longint;
  f:array[1..1000,-5000..5000]of longint;

function min(x,y:longint):longint;
begin
 if x<y then exit(x);
 exit(y);
end;

function try(x,y:longint):longint;
begin
 if (y+sum[x]<-mini)and(y<0) or (y-sum[x]>mini)and(y>0) then //y不能达到mini
  exit(p);
 if x=n+1 then exit(0);
 if f[x,y]=p then
  f[x,y]:=min(try(x+1,y+a[x]),try(x+1,y-a[x])+1);
 exit(f[x,y]);
end;

function cc:longint;
var
 j:longint;
begin
 c[sum[1]]:=true; //c[j]=true表示可以达到差为j
 for i:=1 to n do
  for j:=0 to sum[1]-2*b[i] do
   c[j]:=c[j] or c[j+2*b[i]]; //j+2*b[i]为a[i]为正时的(即=b[i])总的差,j为a[i]为负时的
 for i:=0 to sum[1] do
 if c[i] then exit(i); //最小
end;

begin
  readln(n);
  for i:=1 to n do
  begin
   readln(x,y);
   a[i]:=x-y; //只用记录差值
   b[i]:=abs(a[i]);
  end;

  for i:=n downto 1 do
   sum[i]:=sum[i+1]+b[i];

  mini:=cc;
  for i:=1 to n do
   for j:=-sum[1] to sum[1] do
    f[i,j]:=p;
  writeln(try(1,0));
end.

```
    

---

## 作者：spacetime (赞：1)

//本题亦可以用背包解决，f[i][j]表示选择到第i个骰子组时上组与下组的差是j时所需要最少的翻转次数，因为C++下标不允许负数，可以把j加上一个适当的值使他不为负

```cpp

#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define REP(I,start,end) for(int I=start;I<=end;I++)
using namespace std;
int n,a[1001],f[1001][10001];
int main()
{
    scanf("%d",&n);
    int m=0;
    REP(i,1,n)
    {
        int up,down;
        scanf("%d%d",&up,&down);
        a[i]=up-down;//令上组比下组多为正
        m+=abs(a[i]);//m即为本程序所选上述“适当的数”
    }
    int m1=m<<1;
    memset(f,100,sizeof(f));
    f[0][m]=0;//初始化
    REP(i,1,n)
        REP(j,0,m<<1)
        {
            int k=j+a[i];
            if(k>=0&&k<=m1)
                f[i][j]=min(f[i][j],f[i-1][k]);//不翻转第i个骰子组
            k=j-a[i];
            if(k>=0&&k<=m1)
                f[i][j]=min(f[i][j],f[i-1][k]+1);//翻转第i个骰子组
        }
    REP(i,0,m)//从上下两组差最小搜起
        if(f[n][m+i]<f[0][0]||f[n][m-i]<f[0][0])
        {
            printf("%d\n",min(f[n][m+i],f[n][m-i]));
            break;
        }
    return 0;
}

```

---

## 作者：BrandonSoong (赞：1)

### 这是一道很不错的DP题，它考察了一种关于减少两个集合的差值的DP思想。
***
**首先很明显的是这道题的状态不是那么好写，所以我们考虑一下怎么把它变一下型**

**可以隐隐约约感受到一种转移的感觉，就是我假如翻动了一组多米诺骨牌的话，我的f会加一，同时另外一个表示上下集合之差量会变化，所以这个地方的DP转移方程中间只有两个量，一个是和差值相关的量，一个是和反转次数相关的量，我们要使得前一个量达到一个最值的时候对应的后面的一个量的最小值。**

**这样子说是很感性的说法，在换种说法就是：**

**我们要用 f [ i ] 里面的 i 来表示上下集合的差值，用 f [ i ] 这个整体来表示翻动的次数，使得可以取到的最大的 i 对应的 f [ i ] 最小，这其实就有点像01背包了！**

**现在考虑状态转移方程，因为上下两个翻转会带来变化，它们单独存在的时候是没有考虑价值的，所以我们把上下两块多米诺骨牌看作是一个物体，它所占有的体积，就应该是翻转它们两个可以带来的集合之差减少值，而它们两个所代表的整体的重量【就是和 f [ i ] 同类型的量，说它是什么都行】就是1.**

**这时机（~~chi~~）智（~~dun~~）的我发现了不太好的一个地方，就是我翻转之后的带来的贡献【集合之差减少量】不好表示，因为这和我现在上下集合孰大孰小是有关系的，也就是说每对多米诺骨牌所表示的价值是会随着状态的变化而变化的，这大大的违背了DP的原则，是不可行的！！**

**但是我们可以通过一个巧妙的方法解决这个问题！：**

**假如我们事先就让所有的多米诺骨牌对都翻到上大下小的状态，那么我们现在每一对多米诺骨牌对应的价值就是固定的了，只会朝着减少差值的方向进行，也就是上下骨牌点数之差的两倍，而这个背包的最大值就是上下集合的点数之差，每对骨牌的重量是固定的，假如之前本身就是上大下小那么重量就是1，反之就是-1（相当于先加上了这些重量，后来再转回去就抵消了！）**

**所以我们记录一个base代表一开始就把上小下大的情况转成上大下小的情况的数量，代表我之前就已经消耗的步数，然后跑一个严格排列的# 的01背包，找到距离背包大小最小的有效的 f [ i ] 再加上base就是答案了！**

**解释一下严格排列的01背包：**

**一般的01背包中 f [ i ] [ j ] 表示的是前 i 个物品中用体积为 j 的背包可以装下的最大价值（最小重量），也就是说这里的 j 的体积是可以不装满的**

**而这个地方我们的体积必须装的严严实实的，因为这里的 f [ i ] [ j ] 表示的是前 i 对多米诺骨牌中 通过翻转使得上下集合的差值减小了 j 的情况下的最小翻转次数！**

**一个是背包可空，一个是使得差值恰好为**

**所以下面的DP转移的时候必须保证转移过来的 j 要么是 0 要么是一个已经确定了是一步步转移过来的状态，而这个地方的【确定】我们用一个 full 数组来维护，表示是不是一个装满了的背包！**
***
**代码如下：**
```cpp
#include<bits/stdc++.h>
#define maxn 10000
using namespace std;
int n,V,base_weight,v[maxn],w[maxn],f[maxn];
bool full[maxn];
inline int qr()
{
	int sum=0;
	char j=0;
	bool flag=0;
	while(!isdigit(j))
	{
		flag|=j=='-';
		j=getchar();
	}
	while(isdigit(j))
	{
		sum=(sum<<1)+(sum<<3)+(j^48);
		j=getchar();
	}
	return flag? -sum:sum;
}
inline void readin()
{
	n=qr();
	int a,b;
	for(int i=1;i<=n;i++)
	{
		a=qr();
		b=qr();
		if(a>b)
		{
			v[i]=2*(a-b);
			V+=a-b;
			w[i]=1; 
		}
		else if(a<b)
		{
			v[i]=2*(b-a);
			V+=b-a;
			w[i]=-1;
			base_weight++;
		}
	} 
	for(int i=1;i<=V;i++)
	f[i]=0x7777777;
	return;
}
inline void Solve()
{
	for(int i=1;i<=n;i++)
	if(v[i])
	for(int j=V;j>=v[i];j--)
	{
		if(v[i]==j||full[j-v[i]])
		{
			full[j]=1;
			f[j]=min(f[j],f[j-v[i]]+w[i]);
		}
	} 
	return;
}
inline void print()
{
	for(int i=V;i>=1;i--)
	if(full[i])
	{
		printf("%d",base_weight+f[i]);
		return;
	}
	printf("%d",base_weight);
	return;
}
int main()
{
	readin();
	Solve();
	print();
	return 0;
}
```


---

## 作者：upcchenbaorui (赞：1)

题解上有二维的解法，其实可以降到一维

先将小的放在上面，记录一下差值 

每一个牌的体积就可以使 差值的两倍 看最大能装到多少体积

花费最少是多少

```cpp
#include <bits/stdc++.h>

using namespace std;
int n;
int s;
const int maxn=1e4+5;
int v[maxn];
int w[maxn];
int dp[maxn];
int tot;
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        if(x>y)
        {
            s+=x-y;
            v[i]=2*(x-y);
            w[i]=1;
        }
        else
        {
            s+=y-x;
            v[i]=2*(y-x);
            w[i]=-1;
            tot++;
        }
    }
    memset(dp,0x7f,sizeof dp);
    dp[0]=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=s;j>=v[i];--j)
        {
            if(dp[j-v[i]]!=0x7f7f7f7f)
                dp[j]=min(dp[j],dp[j-v[i]]+w[i]);
        }
    }
    int ans;
    for(int i=s;i>=0;--i) {
        if(dp[i]!=0x7f7f7f7f)
        {
            ans=i;
            break;
        }
    }
    printf("%d\n",dp[ans]+tot);
    return 0;
}

```


---

## 作者：cold_cold (赞：0)

- 序列 DP.
- 考虑题目中如何评判点差: 上下和之差的绝对值.
- 所以有一个最简单的状态设计: f[i][j] 考虑到前 i 个数, 目前的差值
为 j, 最少的翻转次数是多少.
? 考虑状态设计: f[i][j] 考虑到前 i 个数, 已经翻转了 j 次, 目前最小
的差值是多少.
- 原状态 f[i][j] 考虑到前 i 个数, 目前的差值为 j, 最少的翻转次数是
多少.
* 现状态 f[i][j] 考虑到前 i 个数, 第一行的总和是 j, 最少的翻转次数
是多少


```cpp
/*
P1282 多米诺骨牌
代码 C++，0.94KB
提交时间 2018-01-20 17:33:46
耗时/内存 148ms, 17199KB
*/
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1005;
const int M = N * 6;
const int INF = 1e9;

int n;
int a[N], b[N], s;
int f[N][M]; // f[i][j]代表考虑前i张牌, 上边的和为j, 最少要翻多少张

int main()
{
    cin >> n, s = 0;
    for(int i = 1; i <= n; ++ i)
        cin >> a[i] >> b[i],
        s = s + a[i] + b[i]; // 用s来记录总的和

    for(int i = 1; i <= n+1; ++ i)
        for(int j = 0; j <= i * 6; ++ j)
            f[i][j] = INF; // 初值最大值

    f[1][0] = 0;

    for(int i = 1; i <= n; ++ i)
        for(int j = 0; j <= i * 6; ++ j) if(f[i][j] < INF) // INF代表不能到达
        {
            f[i+1][j + a[i]] = min(f[i+1][j + a[i]], f[i][j]); // 不翻
            f[i+1][j + b[i]] = min(f[i+1][j + b[i]], f[i][j] + 1); // 翻
        }

    int ans = INF, flip = -1;
    for(int i = 0; i <= n * 6; ++ i)
        if(f[n+1][i] < INF && abs(s - 2*i) < ans // abs(s - 2*i) 为两者的差
            || (abs(s - 2*i) == ans && flip > f[n+1][i]))
            ans = abs(s - 2*i), flip = f[n+1][i]; 

    cout << flip << endl;

    return 0;
}
```

---

## 作者：v__v (赞：0)

方法肯定是动态规划，第一眼看设的是dp[i][j]表示前i个换了j次的最少差，最后倒着推回去，好像不行，然后就用了dp[i][j]表示前i个当前差值j的最小次数，默认是-1。

后来证明这个可以，会遇到问题就是负数下标，也好办，加个6000就，把负数变为正数，这里由于数据量是1000，数字最大6，所以设的6000，可能开大了

有个优化空间时间的方法，那就是开个队列维护当前层不是-1的dp[i][j]的下标j，初始放入两个值，第0个数的正负差值，每次循环一遍队列(循环次数等于当前的size)，代表遍历当前层dp[i]数组中,不是-1的数，对于每个从队列里拿出来的元素now：

下一层有两个转移方法，dp[i+1][now+A[i+1].x-A[i+1].y]= dp[i][now]

和dp[i+1][now+A[i+1].y-A[i+1].x]= dp[i][now]+1,当然这每个都得判断是不是-1，

不是-1就要取，自己和上一个最小的。同时对于是-1的情况，不要忘了入队列


不用dp这个二维数组，用两个数组互相赋值的方法也可以减少内存。


```cpp
#include<bits/stdc++.h>
//#include<windows.h>
using namespace std;
#define ll long long
#define inf 1e-5
const int INF=1<<30;
const int MAX=6010;
const int mod=1e9+7;

struct v2{
    int x,y;
    void sett(int x,int y){
        this->x=x;
        this->y=y;
    }
    bool operator == (const v2 &t){
         return (t.x==this->x&&t.y==this->y);
    }
};
v2 A[MAX];

int main(int argc,char *argv[]){
    int i,j,k,n,cnt,cnt1,cnt2,now,len;
    cin>>n;
    for(i=1;i<=n;i++){
        scanf("%d%d",&A[i].x,&A[i].y);
    }

    int *a=new int[2*MAX];
    int *b=new int[2*MAX];
    memset(a,-1,sizeof(int)*2*MAX);
    memset(b,-1,sizeof(int)*2*MAX);
    queue<int>que;

    k=A[1].x-A[1].y+MAX;
    que.push(k);
    a[k]=0;

    k=A[1].y-A[1].x+MAX;
    que.push(k);
    a[k]=1;

    for(i=1;i<n;i++){
        len=que.size();
        for(j=0;j<len;j++){
            now=que.front();
            que.pop();
            k=now+A[i+1].x-A[i+1].y;
            if(b[k]==-1){
                b[k]=a[now];
                que.push(k);
            }else{
                b[k]=min(b[k],a[now]);
            }
            k=now+A[i+1].y-A[i+1].x;
            if(b[k]==-1){
                b[k]=a[now]+1;
                que.push(k);
            }else{
                b[k]=min(b[k],a[now]+1);
            }
        }
        delete a;
        a=b;
        b=new int[2*MAX];
        memset(b,-1,sizeof(int)*2*MAX);
    }
    for(i=0;i<MAX;i++){
        if(a[MAX-i]!=-1){
            cnt1=a[MAX-i];
            break;
        }
    }
    for(j=0;j<MAX;j++){
        if(a[MAX+j]!=-1){
            cnt2=a[MAX+j];
            break;
        }
    }
    if(i==j){
        cnt=min(cnt1,cnt2);
    }else{
        cnt=i>j?cnt2:cnt1;
    }
    printf("%d\n",cnt);
return 0;
}

```

---

## 作者：时光 (赞：0)

略有难度的dp

例子的上下部分之差是6+1+1+1-（1+5+3+2）=（6-1）+（1-5）+（1-3）+（1-2）=-2，而翻转最后一个骨牌后，上下之差变为（6-1）+（1-5）+（1-3）+（2-1）=0。由此看出，一个骨牌对翻转策略造成影响的是上下两数之差，骨牌上的数则是次要的了。这么一来，便把骨牌的放置状态由8个数字变为4个： 5    -4    -2    -1，翻转时只需取该位数字的相反数就行了。

在本题中，因为各骨牌的翻转顺序没有限定，所以不能按骨牌编号作为阶段来划分。怎么办呢？考虑到隐含阶段类型的问题可以按状态最优值的大小来划分阶段。于是，我们以骨牌序列上下两部分的差值I作为状态，把达到这一状态的翻转步数作为状态值，记为f（I）。便有f（I）=min{f（I+j）+1} （-12〈=j<=12,j为偶数，且要求当前状态有差值为j/2的骨牌）。这里，I不是无限增大或减小，其范围取决于初始骨牌序列的数字差的和的大小。

具体动态规划时，如例题，我们以f（-2）=0起步，根据骨牌状态，进行一次翻转，可得到f（-12）=1，f（6）=1，f（2）=1，f（0）=1，由于出现了f（0），因此程序便可以结束，否则将根据四个新状态继续扩展，直至出现f（0）或者无法生成新状态为止。

注意：在各状态，除记录最少步数外，还需记录到达这一状态时各骨牌的放置情况；而当到达某一状态发现已记录有一种翻转策略时，则取步数较小的一种。

------------------------------------我是华丽的分割线----------------------------------

附上代码（勿抄）


```cpp
uses math;
var f:array[-10000..10000] of longint;
n,i,j,sum,suma,sumb:longint;
a,b:array[1..1000] of longint;
begin
assign(input,'domino.in');
assign(output,'domino.out');
reset(input);
rewrite(output);
readln(n);
for i:=1 to n do readln(a[i],b[i]);
for i:=1 to n do suma:=suma+a[i];
for i:=1 to n do sumb:=sumb+b[i];
for i:=1 to n do sum:=sum+max(a[i],b[i]);
fillchar(f,sizeof(f),127);
f[suma-sumb]:=0;
for i:=1 to n do
begin
if a[i]>b[i] then
for j:=-sum to sum do
f[j]:=min(f[j],f[j+2*(a[i]-b[i])]+1);
if a[i]<b[i] then
for j:=sum downto -sum do
f[j]:=min(f[j],f[j+2*(a[i]-b[i])]+1);
end;
for i:=0 to sum do begin
if f[i]<>f[-10000] then break;
if f[-i]<>f[-10000] then break;
end;
writeln(min(f[i],f[-i]));
close(input);
close(output);
end.

```

---

## 作者：流星梦丶 (赞：0)

背包问题

最开始的思路是f[i][j][k]表示前i个上面j个下面k个

但是发现j+k即总数是个定值

优化到 f[i][j]

转移方程也很好想了

f[i][j]=min{f[i-1][j],f[i-1][j+up[i]-down[i]]) 再循环处理最优值 代码如下


```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<cmath>
#define rep(o,t,k) for(int o=t;o<=k;o++)
using namespace std;
int i,j,k,l,m,n,up,sum,inf,down,u[1200],d[1200],f[1200][20000];
int main()
{
    scanf("%d",&n);
    rep(i,1,n) 
    {
        scanf("%d%d",&u[i],&d[i]);
        up+=u[i];down+=d[i];sum+=u[i]+d[i];
    }
    memset(f,62,sizeof(f));inf=f[0][0];
    f[0][up]=0;
    rep(i,1,n)
      rep(j,1,sum)
      {
           if(j-u[i]+d[i]<0) continue;
           f[i][j]=min(f[i-1][j],f[i-1][j+u[i]-d[i]]+1);
      }
    int p=99999,step;
    for(int i=sum;i>=0;i--)
    {
        if(abs(sum-i-i)<p&&f[n][i]<inf)
        {
            p=abs(sum-i-i);
            step=f[n][i];
        }
    }
    printf("%d",step);
    return 0;
}
```

---

## 作者：lieee (赞：0)

用hash\_map实现，不用纠结dp的数组怎么开，空间也不用管

但是要使用hash\_map需要using namespace \_\_gnu\_cxx;不知道比赛给不给用







```cpp
#include <iostream>
#include <string>
#include <cstdio>
#include <cctype>
#include <stack>
#include <vector>
#include <cstdlib>
#include <deque>
#include <cmath>
#include <set>
#include <ext/hash_map>
#include <map>
using namespace std;
using namespace __gnu_cxx;
int main() {
int n;
cin>>n;
hash_map<int,int> m,tmp;
m[0]=0;
for (int i=0;i<n;i++) {
    int a,b;
    cin>>a>>b;
    for (hash_map<int,int>::iterator it=m.begin();it!=m.end();it++) {
        int first=it->first,d=a-b>0?a-b:b-a;
        if (m.count(first-2*d)) {
            if (a-b>0) tmp[first-d]=min(m[first]+1,m[first-2*d]);
            else tmp[first-d]=min(m[first],m[first-2*d]+1);
        }
        else {
            if (a-b>0) tmp[first-d]=m[first]+1;
            else tmp[first-d]=m[first];
        }
        if (!m.count(first+2*d)) {
            if (a-b>0) tmp[first+d]=m[first];
            else tmp[first+d]=m[first]+1;
        }
    }
    m=tmp;
    tmp.clear();
}
for (int i=0;i<7;i++) {
    int x=2000,y=2000;
    if (m.count(i)) x=m[i];
    if (m.count(-i)) y=m[-i];
    int ans=min(x,y);
    if (ans!=2000) {
        cout<<ans<<endl;
        break;
    }
}
return 0;
}
```

---

## 作者：varvar (赞：0)

题目分析：此题一眼看上去，像是个背包，但实际上，也确实是背包，而且还是01背包。

但在码代码时要注意以下三个要点。


要点一：注意考虑到负数情况，保留状态时按差值的绝对值保留，因为是01背包，枚举时必须保证单调性。另外由于c++下标不能是负数，可以用一个变量（比如t），记录时f[i]统一记录成f[i+t]。


要点二：注意更新比当前已记录最小值更大的值。否则程序就成了一个贪心。比如不翻转第一块时差值是2，翻转第一块能变成4，在翻转第一块的基础上翻转第二块能使差值变成0，这样的数据如果用贪心就不会是最优解。


要点三：循环时要正负数。


```cpp

#include<cstdio>
#include<cstdlib>
using namespace std;
int i,j,k,f[12001],a[1001],n,sum,t,now; 
//now表示不翻转的差值，a[i]记录第i块骨牌上下点数之差，f[i]表示达到差值为i-t的状态所需的最小步数
int main()
{
    scanf("%d",&n);
    for (i=0;i<n;i++)
    {
        scanf("%d%d",&j,&k);
        a[i]=j-k;
        if (a[i]<0) t-=a[i];
          else sum+=a[i];
        now+=a[i];
    }
    f[now+t]=1; //这里先将最小步数统一赋上一，方便判断这个状态是否达到过
    for (i=0;i<n;i++)
      if (a[i]>0) //分情况讨论，正负值的枚举状态方向相反，重要！
      {
        for (j=2*a[i];j<=sum+t;j++)
          if (f[j]>0&&(f[j-2*a[i]]==0||f[j-2*a[i]]>f[j]+1))
            f[j-2*a[i]]=f[j]+1;
//如果上个状态可以达到，并且满足递推关系（以前不能达到本状态，或以前达到本状态的的最小步数小雨上个状态最小步数+1），则更新f[f-2*a[i]]。注意翻转一次是改变2*a[i]的差值。
      }
      else if (a[i]<0)
      {
        for (j=sum+t+2*a[i];j>=0;j--) 
          if (f[j]>0&&(f[j-2*a[i]]==0||f[j-2*a[i]]>f[j]+1))
            f[j-2*a[i]]=f[j]+1;
      }
    i=t; j=t;
while (f[i]==0&&f[j]==0) 
//从差值为0开始找，同时向负数和正数扩展，直到达到一个可以达到的状态，这个状态即最优状态（最小差值）
    {
          i++; j--;
    }
    if (f[i]==0) printf("%d",f[j]-1);  //因为之前统一加上了一，所以要减一输出
      else if (f[j]==0||f[i]<=f[j]) printf("%d",f[i]-1);
}


```

---

## 作者：天狗的手帖 (赞：0)

动态规划

a[i]表示第i枚骨牌上面的值，b[i]表示第i枚骨牌下面的值,f[i]表示令所有骨牌差值（上减下）为i的最小翻转次数。


初始时，统计suma和sumb，令f[suma-sumb]=0,其他f全部都为一个极大值表示无法做到，统计出一个sum=sum(max(a[i],b[i])) (i∈[1..n]),这个sum就是我们可能枚举到的最大差值。


类似于背包，我们枚举每一个骨牌i，调换这个骨牌就能使总差值减少2\*(a[i]-b[i])，枚举空间j∈[-sum..sum]，状态转移方程为f[j]=min(f[j],f[j+2\*(a[i]-b[i])]+1)


需要注意的是，因为每个骨牌只能翻转一次，所以这是个01背包，我们在枚举状态时要防止在枚举同一个i时的状态产生多次影响，但我们并不知道a[i]-b[i]的正负性，所以就要分两种情况


1.a[i]-b[i]>0,即j+2\*(a[i]-b[i])<j,那么j从小到大枚举

2.a[i]-b[i]<0,即j+2\*(a[i]-b[i])>j,那么j从大到小枚举

这样就避免同一骨牌i枚举j状态下的f[j]相互产生影响


最后答案即为i的值和0最接近且f[i]或f[-i]可以取得的最小值min(f[i],f[-i])


PASCAL代码


```delphi

    var f:array[-10000..10000] of longint;  
        n,i,j,sum,suma,sumb:longint;  
        a,b:array[1..1000] of longint;  
      
    function min(a,b:longint):longint;  
      
    begin  
      
            if a<b then exit(a)  
      
                   else exit(b);  
      
    end;  
      
    begin  
      
            readln(n);  
      
            for i:=1 to n do readln(a[i],b[i]);  
      
            for i:=1 to n do suma:=suma+a[i];  
      
            for i:=1 to n do sumb:=sumb+b[i];  
      
            for i:=1 to n do sum:=sum+a[i]+b[i]-min(a[i],b[i]);  
      
            fillchar(f,sizeof(f),127);  
      
            f[suma-sumb]:=0;  
      
            for i:=1 to n do begin  
      
                if a[i]>b[i] then  
      
                for j:=-sum to sum do  
      
                f[j]:=min(f[j],f[j+2*(a[i]-b[i])]+1);  
      
                if a[i]<b[i] then  
      
                for j:=sum downto -sum do  
      
                f[j]:=min(f[j],f[j+2*(a[i]-b[i])]+1);  
      
                end;  
      
            for i:=0 to sum do begin  
      
                if f[i]<>f[-10000] then break;  
      
                if f[-i]<>f[-10000] then break;  
      
                end;  
      
            writeln(min(f[i],f[-i]));  
      
    end.  

```

---

## 作者：Memorize (赞：0)

这道题的决策很好想 对于一个牌 无非就是翻转或者不翻转 所以由此我们可以从决策入手

设f[i][j]=k表示前i张牌构成分值j的最小次数k

则转移方程:

```cpp
  //不反转 
  int dif=a[i]-b[i];
  f[i][j+dif+N]=min(f[i][j+dif+N],f[i-1][j+N]);
   //反转 
   dif=b[i]-a[i];
   f[i][j+dif+N]=min(f[i][j+dif+N],f[i-1][j+N]+1);
```
注意这里要加一个常数N(5000因为最大相差不会超过这个) 因为分值可能为负数
则统计答案大概就是这样:

```cpp
for(int j=N-maxn;j<=maxn+N;j++)
     if(f[n][j]!=f[0][0])
     {
         if(ans>abs(j-N)) ans=abs(j-N),k=f[n][j],p=j;
         else if(ans==abs(j-N)) k=min(f[n][j],f[n][p]);//考虑对称情况
     }
```
总代码:
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
const int N=5000;
using namespace std;
int n,suma=0,sumb=0;
int a[1010],b[1010];
int f[1010][5000+5005];
int ans=0x7f7f7f,k=0,p;
int main()
{
    memset(f,0x7f7f7f,sizeof(f));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a[i],&b[i]);
        suma+=a[i],sumb+=b[i];
    }
    f[0][5000]=0;
    int maxn=5*n;
    for(int i=1;i<=n;i++)
     for(int j=-maxn;j<=maxn;j++)
     {
         //不反转 
        int dif=a[i]-b[i];
        f[i][j+dif+N]=min(f[i][j+dif+N],f[i-1][j+N]);
         //反转 
        dif=b[i]-a[i];
        f[i][j+dif+N]=min(f[i][j+dif+N],f[i-1][j+N]+1);
     } 
    for(int j=N-maxn;j<=maxn+N;j++)
     if(f[n][j]!=f[0][0])
     {
         if(ans>abs(j-N)) ans=abs(j-N),k=f[n][j],p=j;
         else if(ans==abs(j-N)) k=min(f[n][j],f[n][p]);
     }      
    printf("%d",k); 
    return 0;
}
```

---

## 作者：wzj423 (赞：0)

```cpp
/**
P1282
*/

#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>

#include <cmath>
#include <cctype>
#include <string>
#include <cstring>

#include <algorithm>
#include <queue>
#include <stack>

using namespace std;
#define INF 0x3f3f3f3f
int card[1010][2];
int preSum[1010];//前序和降为二维
int N;
int dp[1010][6010];
int ans = INF;
int main()
{
    std::ios::sync_with_stdio ( false );
    cin >> N;
    memset ( dp, 0x3f, sizeof ( dp ) );
    for ( int i = 1; i <= N; i++ )
    {
        cin >> card[i][0] >> card[i][1];
        preSum[i] = preSum[i - 1] + card[i][0] + card[i][1];
    }
    dp[1][card[1][0]] = 0;
    dp[1][card[1][1]] = 1;
    /**
    转移方程定义
    f[i][j]=前i张牌使得上一行点数之和为j的最小方法数
    转移方程:
    f[i][j]=min{f[i-1][j-card[i][0]],//反转
                f[i-1][j-card[i][1]]+1}//不反转
    取值:
    i<=j<=preSum[i]-i
    */
    for ( int i = 2; i <= N; i++ )
        for ( int j = i; j <= preSum[i] - i; j++ )
        {
            if ( j > card[i][0] )
                dp[i][j] = min ( dp[i][j], dp[i - 1][j - card[i][0]] );
            if ( j > card[i][1] )
                dp[i][j] = min ( dp[i][j], dp[i - 1][j - card[i][1]] + 1 );
        }
    int curDiff = INF;
    for ( int j = N; j <= preSum[N] - N; j++ )
        if ( dp[N][j] != INF && abs ( preSum[N] - 2 * j ) < curDiff )
        {
            curDiff = abs ( preSum[N] - 2 * j );
            ans = dp[N][j];
        }
        else if ( dp[N][j] != INF && abs ( preSum[N] - 2 * j ) == curDiff && ans > dp[N][j] )
            ans = dp[N][j];
    cout << ans << endl;
    return 0;
}
```

---


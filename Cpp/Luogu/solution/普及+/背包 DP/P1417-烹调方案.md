# 烹调方案

## 题目背景

由于你的帮助，火星只遭受了最小的损失。但 gw 懒得重建家园了，就造了一艘飞船飞向遥远的 earth 星。不过飞船飞到一半，gw 发现了一个很严重的问题：肚子饿了 ~。

gw 还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw 希望能在 $T$ 时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的 gw 只好求助于你了。

## 题目描述

一共有 $n$ 件食材，每件食材有三个属性，$a_i$，$b_i$ 和 $c_i$，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t\times b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。

众所周知，gw 的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大。

## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据 $1 \le n \le 10$；
- 对于 $100\%$ 的数据 $1 \le n \le 50$。

所有数字均小于 $10^5$。

### 题目来源

tinylic 改编


## 样例 #1

### 输入

```
74 1
502
2
47
```

### 输出

```
408```

# 题解

## 作者：kkksc03 (赞：424)

By tinylic

如果没有b[i]这个属性的话就是明显的01背包问题。

现在考虑相邻的两个物品x,y。假设现在已经耗费p的时间，那么分别列出先做x,y的代价：

a[x]-(p+c[x])\*b[x]+a[y]-(p+c[x]+c[y])\*b[y]  (①) 

a[y]-(p+c[y])\*b[y]+a[x]-(p+c[y]+c[x])\*b[x]  (②) 

对这两个式子化简，得到①＞②的条件是c[x]\*b[y]<c[y]\*b[x].

发现只要满足这个条件的物品对(x,y)，x在y前的代价永远更优。

因此可以根据这个条件进行排序，之后就是简单的01背包了。

```cpp

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define LL long long
#define maxn 100001

using namespace std;

struct node {
    int a, b, c;
}a[maxn];

LL f[maxn], ans;
int T, n, i, j;

bool cmp(node a, node b) {
    return (LL)a.c * (LL)b.b < (LL)b.c * (LL)a.b;
}

int main() {

    scanf("%d%d", &T, &n);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i].a);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i].b);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i].c);
    
    sort(a, a + n, cmp);

    memset(f, 255, sizeof f);
    f[0] = 0;

    for (i = 0; i < n; i++) {
        for (j = T; j >= 0; --j)
            if (f[j] != -1 && j + a[i].c <= T)
                f[j + a[i].c] = max(f[j + a[i].c], f[j] + (LL)a[i].a - (LL)(j + a[i].c) * (LL)a[i].b);
    }
    for (i = 0; i <= T; i++)
        ans = max(ans, f[i]);
    cout << ans << endl;
}


```

---

## 作者：wjzcom (赞：69)

这道题看起来是01背包，但是有需要注意的地方

对于这个我用一种易懂的方式说一下

平常做01背包的题时，由于i的价值永远是不变的，所以i讨论的顺序对结果不影响

但是这道题中，如果你先讨论了1号点，再讨论第二点，第二点的价值会减小，反之一号点会减小，这两个哪个更优是不确定的，所以如果你先讨论1号点就会错

由此，需要按优先度对所有点进行排序

```cpp
//luogu 1417 wjz 1611161121
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define LL long long 
using namespace std;
const LL MAXN = 100000 + 10;
LL T, n;
LL f[MAXN];
struct node    //c[x]*b[y]<c[y]*b[x]
{
    LL a, b, c;
} m[MAXN];
bool cmp(node x, node y)
{
    return x.c * y.b < y.c * x.b;
}
int main()
{
    cin >> T >> n;    
    for(LL i = 1; i <= n; i++) cin >> m[i].a;
    for(LL i = 1; i <= n; i++) cin >> m[i].b;
    for(LL i = 1; i <= n; i++) cin >> m[i].c;
    sort(m+1, m+1+n, cmp);
    for(LL i = 1; i <= n; i++)
        for(LL j = T; j - m[i].c >= 0; j--)
            f[j] = max(f[j], f[j-m[i].c] + m[i].a - j * m[i].b);
    LL maxx = 0;
    for(LL i = 1; i <= T; i++)
        maxx = max(f[i], maxx);
    cout << maxx;
    return 0;
}
```

---

## 作者：henry_y (赞：42)

有要练dp的同学可以看一下我的博客qwq

[dp专题练习](https://www.cnblogs.com/henry-1202/p/9211398.html)


------------

挺有意思的一个01背包

开始直接写了一个裸01背包30分

想了好久悄咪咪地翻了一下题解发现因为有$b[i]$这个属性所以先后选的顺序是有影响的

瞬间懂了

自己推一下就没什么问题了

这里放一下我的推导过程

$a[i]-b[i]*(t+c[i])+a[j]-b[j]*(t+c[i]+c[j])$//i先做

$a[j]-b[j]*(t+c[j])+a[i]-b[i]*(t+c[i]+c[j])$//j先做

$a[i]-b[i]*(t+c[i])+a[j]-b[j]*(t+c[i]+c[j])>a[j]-b[j]*(t+c[j])+a[i]-b[i]*(t+c[i]+c[j])$

$-b[i]*(t+c[i])-b[j]*(t+c[i]+c[j])>-b[j]*(t+c[j])-b[i]*(t+c[i]+c[j])$

$-b[i]*t-b[i]*c[i]-b[j]*t-b[j]*c[i]-b[j]*c[j]>-b[j]*t-b[j]*c[j]-b[i]*t-b[i]*c[i]-b[i]*c[j]$

$-b[j]*c[i]>-b[i]*c[j]$

所以最后按$-b[j]*c[i]>-b[i]*c[j]$的规则进行排序就行了

然后注意要开longlong，不然第十四个点排序的时候会爆掉...

```
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n,t;
struct node {
	ll a,b,c;
}a[100];
ll f[100000];
bool cmp(node i,node j){
	return -j.b*i.c>-i.b*j.c;
}
int main(){
	long long ans=0;
	scanf("%lld%lld",&t,&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].a);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].b);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i].c);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=t;j>=a[i].c;j--){
			f[j]=max(f[j],f[j-a[i].c]+a[i].a-a[i].b*j);
			ans=max(ans,f[j]);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：dj114133643 (赞：24)

对本题做一个总结

本题很好地揭示了背包问题的本质：用每一个可执行的动作（或物品）对各个状态进行更新

某物品在取或不取时，用的是前面已有的状态。

数学中用归纳法，信息学也是。

如何证明当前状态一定正确？

1.状态转移正确2.假设需用的之前的状态均正确。

运用循环论证，则当前状态一定正确。

为什么背包用的是总是最后面的时间或空间？

难道就不能用之前的吗？

不能，因为目前能控制的只有一个物品。

如果每次不插在最后，像队列一样，就破坏了和谐

f[i]表示得是i个单位的价值，不是x---x+i-1单位的价值，所以需要排序

还有一点，正因为用的总是最后的时间，时间越多越好，但不是越靠后越好，所以答案不一定是f[n]


---

## 作者：zjy111 (赞：21)

## 三年OI一场空, 不开long long见祖宗！！！
~~(三是虚指)~~

这题是一道"泛化物品的背包"问题

也就是说，这种背包，没有固定的费用和价值。这时，将固定的价值换成函数的引用即可。     ----By [OI Wiki](https://oi-wiki.org/dp/knapsack/)

~~不知道大家看了有什么感受，反正我一个字也看不懂qwq~~

一开始不明就里的我直接把这题当裸的01背包计算，居然还可以A6个点？？

30分代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,t,dp[100005],maxn;
struct thing{
	int a,b,c;
}x[55];
int main() {
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>x[i].a;
	for(int i=1;i<=n;i++)cin>>x[i].b;
	for(int i=1;i<=n;i++)cin>>x[i].c;
	for(int i=1;i<=n;i++){
		for(int j=t;j>=x[i].c;j--){
			dp[j]=max(dp[j],dp[j-x[i].c]+x[i].a-j*x[i].b);//经典01,只是价值稍微换一下
		}
	}
	for(int i=1;i<=t;i++)
		maxn=max(maxn,dp[i]); //取最大的美味程度
	cout<<maxn<<endl;
	return 0;
}
```

然后看了看标签，发现需要排序。

接着就想到了由于其价值会随时间变化而变化，但是01背包中每个物品都只能选取1次，所以同一物品多种价值会导致在普通01背包中，当前状态的最优解并不一定可以推到下一个最优解。

但是01背包是按照一个从1到n的顺序选取物品，所以我们只要保证这个顺序是从优到劣即可

但是怎么从优到劣呢?

只需要任取物品a,b, 在相同的时间x(x>=c[a],且x>=c[b])时算一下a和b的美味度x,y, 并且解不等式x>y即可

最后解出来是这样的
```cpp
bool cmp(thing a,thing b){
	return a.b*b.c>b.b*a.c;
}
```
于是我们就可以欢快的写出接近标程的代码(分数也是接近标程呢qwq)
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,t,dp[100005],maxn;
struct thing{
	int a,b,c;
}x[55];
bool cmp(thing a,thing b){
	return a.b*b.c>b.b*a.c;
}
int main() {
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>x[i].a;
	for(int i=1;i<=n;i++)cin>>x[i].b;
	for(int i=1;i<=n;i++)cin>>x[i].c;
	sort(x+1,x+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=t;j>=x[i].c;j--){
			dp[j]=max(dp[j],dp[j-x[i].c]+x[i].a-j*x[i].b);
		}
	}
	for(int i=1;i<=t;i++)
		maxn=max(maxn,dp[i]);
	cout<<maxn<<endl;
	return 0;
}
```
是的, 接近不代表相同, 当发现"万绿丛中一点红"时, 我下载了一下数据, 发现本来应该是0的数据输出了2147464285

### 爆int了!!!
所以我有必要再重复几遍我题解开头的那句话

### 三年OI一场空, 不开long long见祖宗！
## 三年OI一场空, 不开long long见祖宗！！
# 三年OI一场空, 不开long long见祖宗！！！

献上码风奇特的代码(含注释)~~希望更丰富的展现?[使用Markdown](https://www.luogu.org/wiki/show?name=%E5%B8%AE%E5%8A%A9%EF%BC%9Amarkdown)~~

# define ll long long
```cpp
# include <bits/stdc++.h>
using namespace std;
# define ll long long
ll n,t,dp[100005],maxn; //maxn用来比较dp数组并找出最大值(不是所有的情况都是时间刚好花完最大)
struct thing{  //定义物品结构体存物品, 方便排序
	ll a,b,c;
}x[55];
bool cmp(thing a,thing b){  //比较函数用来排序取较优者先进行01背包循环
	return a.b*b.c>b.b*a.c;
}
int main() {
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>x[i].a;
	for(int i=1;i<=n;i++)cin>>x[i].b;
	for(int i=1;i<=n;i++)cin>>x[i].c;
	sort(x+1,x+n+1,cmp);
	for(int i=1;i<=n;i++){
		for(int j=t;j>=x[i].c;j--){
			dp[j]=max(dp[j],dp[j-x[i].c]+x[i].a-j*x[i].b); //经典01,只是价值稍微换一下
		}
	}
	for(int i=1;i<=t;i++)
		maxn=max(maxn,dp[i]);  //取最大的美味程度
	cout<<maxn<<endl;
	return 0;
}
```

---

## 作者：sword小怪兽 (赞：17)

补充一下楼下的解释：

1.为什么不能直接用01背包？2.为什么排序后01背包就是对的?

物品的价值会随时间的变化而变化，每个时间对应一个价值（==不同物品），而只能选一次，自然不能用01背包。（不同顺序选取会影响答案，而01背包不会）

再者分析01背包的循环，最优解的情况是按1到n升序选取的（for（1~n））（当然对01背包，这个序没什么用），排完序后，01背包出来的最优解也一定以升序选取。


---

## 作者：Lucaster_ (赞：10)

现在做个背包真的是花里胡哨的

一开始一看这题好水啊

为啥是绿的

按照01背包写了一遍

越写越不对劲

写完以后样例过不了

仔细考虑了一下

因为这相当于一个泛化物品啊

每个时刻取每个物品会得到不同的价值

而我们如果采用背包逆推的话

每种物品只能取一次

我们不知道“何时”才能“取到”这个最优的“物品”呢

~~点开题解~~深思熟虑

发现这玩意竟然可以用数学方法证明？？？

（留着当彩蛋了hhhh）

上代码：
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
#define N 55
using namespace std;
struct hh{
    ll a,b,c;
} h[N];
ll i,j,n,T,f[5050505];
 bool cmp(hh x,hh y)
 {return x.b*y.c>x.c*y.b;}
ll ans=0;
int main()
{
    ios::sync_with_stdio(false);
    memset(f,-1,sizeof(f));
    cin>>T>>n;
    f[0]=0;
    for(i=1;i<=n;i++) cin>>h[i].a;
    for(i=1;i<=n;i++) cin>>h[i].b;
    for(i=1;i<=n;i++) cin>>h[i].c;
    sort(h+1,h+n+1,cmp);
    for(i=1;i<=n;i++)
     for(j=T;j>=h[i].c;j--)
      f[j]=max(f[j],f[j-h[i].c]+h[i].a-(ll)j*h[i].b);
    for(i=1;i<=T;i++)
     ans=max(ans,f[i]);
    cout<<ans;
    return 0;
}
```

彩蛋：

我还真不会证

瞟了一眼kkk的题解

（真的是瞟了一眼）

自己写了一串竟然证出来了！

```latex
假设对于相邻的两个时间点x和y
分别有两种不同的价值
若先选x(也就是后选y，t[x]=t+c[x],t[y]=t+c[x]+c[y]):
v1=a[x]-(t+c[x])*b[x]+a[y]-(t+c[x]+c[y])*b[y]
若先选y：
v2=a[y]-(t+c[y])*b[y]+a[x]-(t+c[y]+c[x])*b[x]
假定先选x价值大
将v1、v2去括号展开，相减

最终得到：c[y]*b[x]>c[x]*b[y];

然后把这个不等式放到sort的cmp里
剩下的就是01背包啦！
```


---

## 作者：zyxzrzxm (赞：7)

## 很巧妙的一道贪心+dp的题

~~然而我写的不是dp~~，为了帮助弄不懂dp的同学，写的是最容易理解的**记忆化搜索**qwq

建议初学dp的同学从记忆化搜索学起，容易理解

首先贪心的排序方式前面很多大佬都讲了，我就不重复啰嗦了，先排一波就是

然后直接上代码了

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define For(qwq) for(i=1;i<=qwq;i++)
//个人习惯
using namespace std;
long long t,n;
long long dp[52][100006],ans;
struct A
{
	long long ai,bi,ci;
}gi[51];
bool cmp(A x,A y)
{
	return x.ci*y.bi<x.bi*y.ci;
}
//贪心的排序方式，原理之前很多大佬都有讲
long long read()//读入优化
{
    long long num=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        num=((num<<3)+(num<<1))+ch-'0';
        ch=getchar();
    }
    return num*f;
}
long long dfs(long long x,long long y)
//记忆化搜索，表示准备搜第x样食材，已经花费了y时间还能够取得的最大美味指数
{
	if(x==n+1) return 0;
    //如果取完了，还能获得的最大价值就是0，直接返回就行了
	if(dp[x][y]!=-1) return dp[x][y];
    //传说中的记忆化
	if(y+gi[x].ci<=t) dp[x][y]=max(dfs(x+1,y+gi[x].ci)+gi[x].ai-(y+gi[x].ci)*gi[x].bi,dfs(x+1,y));
    //选和不选两种情况选个最大值
	else dp[x][y]=dfs(x+1,y);//时间不够，只能不选
	return dp[x][y];
}
int main()
{
	long long i;
	memset(dp,-1,sizeof dp);
	t=read();n=read();
	For(n) gi[i].ai=read();
	For(n) gi[i].bi=read();
	For(n) gi[i].ci=read();
	sort(gi+1,gi+n+1,cmp);
	ans=dfs(1,0);
	printf("%lld\n",ans);
	return 0;
}
```

**没错，记忆化搜索就是这么好理解qwq**

---

## 作者：Doubeecat (赞：5)

## 题目链接：

[烹调方案](<https://www.luogu.org/problem/P1417>)

## 题目描述：

一共有$n$件食材，每件食材有三个属性， $a_i$ ， $b_i$ 和 $c_i$ ，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。

在 $T$ 时间内设计烹调方案使得美味指数最大

## 解题思路：

显然是一个01背包，但是，当你写完01背包板子交上去以后会发现只有30分。  

题目中给了一个条件：在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t*b_i$ 的美味指数，有了这个条件，显然我们要对每个物品选择的先后性进行讨论了。

设 $a_1,b_1,c_1$ 为第一组物品，$a_2,b_2,c_2$ 为第二组物品， $t$为当前时间.

将两个物品可获得的值表示出来为：

$$
m_1 = a_1-(t \times c_1) \times b_1 + a_2 - (t+c_1+c_2) \times b_2
$$

$$
m_2 = a_2-(t \times c_2) \times b_2 + a_1 - (t+c_1+c_2) \times b_1
$$

设 $m_1 > m_2$ 得

$$
a_1-(t \times c_1) \times b_1 + a_2 - (t+c_1+c_2) \times b_2   > m_2 = a_2-(t \times c_2) \times b_2 + a_1 - (t+c_1+c_2) \times b_1
$$

拆项得

$$
a_1-b_1t-b_1c_1+a_2-b_2t-b_2c_1-b_2c_2>a_2-b_2t-b_2c_2+a_1-b_1t-b_1c_1-b_1c_2
$$

化简得  

$$
b_1c_2 > b_2c_1
$$  


由此，我们就得到了我们 sort 函数中cmp的写法。注意开 long long 这题就完了。

这题的关键就在此，我不知道是为什么，大部分题解中都没有给出自己的完整证明，这个证明也不难证，希望读者看完后可以自己证明一遍。
## 代码：

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define int long long
using namespace std;
const int N = 1000100;
const int M = 500010<<1;
inline int read() {
	int x = 0,f = 1;char v = getchar();
	while (!isdigit(v)) {if (v =='-') f = -1;v = getchar();}
	while (isdigit(v)) {x = x * 10 + v - 48;v = getchar();}
	return x * f;
}
int f[N],n,m,ans;
struct node {
	int a,b,c;
	friend inline bool operator < (const node &rhs,const node &rs) {
		return rhs.b*rs.c > rhs.c*rs.b;	
	}
}pre[N];
signed main() {
	m = read(),n = read();
	for (int i = 1;i <= n;++i)	pre[i].a = read();
	for (int i = 1;i <= n;++i)	pre[i].b = read();
	for (int i = 1;i <= n;++i)	pre[i].c = read();
	sort(pre+1,pre+1+n);
	for (int i = 1;i <= n;++i) {
		for (int j = m;j >= pre[i].c;--j) {
			f[j] = max(f[j],f[j-pre[i].c] + (pre[i].a - j * pre[i].b));
		}
	}
	for (int i = 1;i <= m;++i) {
		ans = max(ans,f[i]);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Heap_Sort (赞：4)

我来为Pascal发一篇题解
很明显，一看就是背包问题。但是，由于物品的价值会~~乱动~~改变，所以还要确定策略，确保先选的都是最优的。

当c[i]/b[i]<c[j]/b[j]时，i物品在前面的价值大。

化简不等式得到c[i]*b[j]<c[j]*b[i]。


代码
```pascal
uses math;
var i,j,k:array[1..50] of longint;dp:array[1..100000] of longint;
  n,t,a,b,c,d,e:longint;
begin
  readln(t,n);
  for a:=1 to n do read(i[a]);
  for a:=1 to n do read(j[a]);
  for a:=1 to n do read(k[a]);
  for a:=1 to n-1 do for b:=a+1 to n do if k[a]*j[b]>k[b]*j[a] then
   begin
    c:=j[a];j[a]:=j[b];j[b]:=c;
    c:=i[a];i[a]:=i[b];i[b]:=c;
    c:=k[a];k[a]:=k[b];k[b]:=c;
   end;
  for a:=1 to n do for b:=t downto k[a] do
   dp[b]:=max(dp[b],dp[b-k[a]]+i[a]-b*j[a]);
  b:=0;
  for a:=1 to t do b:=max(b,dp[a]);
  writeln(b);
end.

```


---

## 作者：aha浮云 (赞：3)

写一发记搜

值得注意的是 这并不是01背包
因为它前后选不一样

那么我们就要排序

为了方便食用

我的cmp就直接写上了原式，没有化简

~~dfs都看的懂吧~~

~~不写注释了.....~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long max_tim = 100010;
const long long max_n = 60;

long long F[max_n][max_tim];

struct Food
{
	long long A, B, C;
}f[max_n];

long long tim, n;

bool cmp(Food a, Food b)
{
	return a.A - a.C * a.B + b.A - (a.C + b.C) * b.B > b.A - b.C * b.B + a.A - (a.C + b.C) * a.B;
}

long long run(long long pos, long long t)
{
	if(pos == n + 1) return 0;
	if(~F[pos][t]) return F[pos][t];
	long long maxx = -1;
	if(t + f[pos].C <= tim)
	maxx = max(run(pos + 1, t + f[pos].C) + f[pos].A - (t + f[pos].C) * f[pos].B, maxx);
	maxx = max(run(pos + 1, t), maxx);
	return F[pos][t] = maxx;
}

int main()
{
	memset(F, -1, sizeof(F));
	cin >> tim >> n;
	for(long long i = 1;i <= n; i++)
	scanf("%lld", &f[i].A);
	for(long long i = 1;i <= n; i++)
	scanf("%lld", &f[i].B);
	for(long long i = 1;i <= n; i++)
	scanf("%lld", &f[i].C);
	sort(f + 1, f + 1 + n, cmp);
	cout << run(1, 0) << endl;
}
```

---

## 作者：Neumann (赞：3)

//这个题数据真坑，应该是除了n,T之外都需要用long long(一起改的，后来也没试)

//这题和国王游戏很像，考虑是否交换要算损失的价值（下面都有不多说）

//我一开始用long long只对一个点，后来发现输入方式不对....








    
        
    
    
    
        
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=50+10;
const int maxv=100000+10;
struct node{
    long long a,b,c;//对应a,b,c; 
}e[maxn];
int cmp(node x,node y){
    return x.c*y.b<y.c*x.b;
} 
long long n,T;
long long f[maxn][maxv];
int inline read(){
    int num=0;
    char c;
    bool plus=true;
    while((c=getchar())==' '||c=='\n'||c=='\r');
    if(c=='-')plus=false;
    else num=c-'0';
    while(isdigit(c=getchar()))
        num=num*10+c-'0';
    return num*(plus?1:-1);
}
int main(){
    memset(f,255,sizeof(f));
    T=read(); n=read();
    for(int i=1;i<=n;i++){
        //scanf("%ld%ld%ld",&e[i].a,&e[i].b,&e[i].c);
        e[i].a=read();
        f[i][0]=0; //原来是放在一层循环里输的e[i].a,e[i].b,e[i].c莫名奇妙wa到哭
    }
    for(int i=1;i<=n;i++)
        e[i].b=read();
    for(int i=1;i<=n;i++)
        e[i].c=read();
    sort(e+1,e+1+n,cmp);
    f[0][0]=0;//用二维不要忘了这个
    for(int i=1;i<=n;i++)
        for(int j=0;j<=T;j++){
            if(j>=e[i].c)
                f[i][j]=max(f[i-1][j-e[i].c]+e[i].a-j*e[i].b,f[i-1][j]);
            else f[i][j]=f[i-1][j];//一维的当然可以
        }
    long long ans=0;
    for(int i=0;i<=T;i++)
        ans=max(ans,f[n][i]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：ummmmm (赞：1)

题目背景

由于你的帮助，火星只遭受了最小的损失。但gw懒得重建家园了，就造了一艘飞船飞向遥远的earth星。不过飞船飞到一半，gw发现了一个很严重的问题：肚子饿了~

gw还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw希望能在T时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的gw只好求助于你了。

题目描述

一共有n件食材，每件食材有三个属性，ai，bi和ci，如果在t时刻完成第i样食材则得到ai-t*bi的美味指数，用第i件食材做饭要花去ci的时间。

众所周知，gw的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大

输入输出格式

输入格式：
第一行是两个正整数T和n，表示到达地球所需时间和食材个数。

下面一行n个整数，ai

下面一行n个整数，bi

下面一行n个整数，ci

输出格式：
输出最大美味指数

输入输出样例

输入样例#1： 复制
74 1
502
2
47
输出样例#1： 复制
408
说明

【数据范围】

对于40%的数据1<=n<=10

对于100%的数据1<=n<=50

所有数字均小于100,000

【题目来源】

tinylic改编




```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long
struct node
{
	ll a, b, c;
} g[55];
ll dp[100005];

bool cmp(const node &x, const node &y)
{
	return x.c * y.b < y.c * x.b;
}  //列出函数 化简为cmp函数

int main()
{
	int  T, n;
	cin >> T >> n;
	for (int i = 1; i <= n; i++)
		cin >>  g[i].a;
	for (int i = 1; i <= n; i++)
		cin >>  g[i].b;
	for (int i = 1; i <= n; i++)
		cin >>  g[i].c;

	sort(g + 1, g + n + 1, cmp); //按给出的优先级背包

	for (int i = 1; i <= n; i++)
	{
		for (ll j = T; j >= g[i].c; j--)
		{
			dp[j] = max(dp[j], dp[j - g[i].c] + g[i].a - j * g[i].b);
		}
	}
	int maxx = 0;
	for(int i = 1; i <= T; i ++)
		if(dp[i] > maxx)
			maxx = dp[i];
	cout << maxx;
	return 0;
}
```

---

## 作者：Kaizyn (赞：0)

**摘自tinylic的题解**:

现在考虑相邻的两个物品x,y。假设现在已经耗费p的时间，那么分别列出先做x,y的代价：

①a[x]-(p+c[x])*b[x]+a[y]-(p+c[x]+c[y])*by

②a[y]-(p+c[y])*b[y]+a[x]-(p+c[y]+c[x])*bx

==>

①a[x]-(p+c[x])*b[x]+a[y]-(p+c[x]+c[y])*b[y]

②a[x]-(p+c[x]+c[y])*b[x]+a[y]-(p+c[y])*b[y]

消去相同的项后得

①c[x]*b[y]

②c[y]*b[x]

所以

对这两个式子化简，得到①＞②的条件是**c[x]*b[y]<c[y]*b[x].**

发现只要满足这个条件的物品对(x,y)，x在y前的代价永远更优


------------
再然后很多人都错在了没开long long上

其实本来也没有这个坑,踩的人多了就成了坑

对于某个食物i,在时刻t完成的价值是ai-t*bi

显然,当**t>ai/bi**时,价值<0

而选择不做这个食物所获的价值为0

所以对每个食物进行背包的状态更新时,我们只需要枚举的下标范围缩小到**[ ci, min(T, ⌊ai/bi⌋) ]** (ai/bi向下取整)

转移方程dp[j] = max(dp[j], dp[j-ci]+ai-j*bi)

此时j*bi <= (ai/bi)bi = ai <= 100000

就不会爆了

~~(以上纯属搞笑)~~

再者还有一个爆int的地方是排序时ci*bi

本人亲身体验这里不会爆(逃)


------------
下面就是理论上不完美但是能AC还附魔一点优化的代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

const int Maxn = 60;
const int Maxt = 1e5+7;

int T, n, res;
int dp[Maxt];

struct Food
{
	int a, b, c;
	bool operator < (const Food &nex) const
	{
		return b*nex.c > c*nex.b;
	}
} f[Maxn];

int main()
{
	scanf("%d%d", &T, &n);
	for(int i = 1; i <= n; ++i) scanf("%d", &f[i].a);
	for(int i = 1; i <= n; ++i) scanf("%d", &f[i].b);
	for(int i = 1; i <= n; ++i) scanf("%d", &f[i].c);
	sort(f+1, f+n+1);
	for(int i = 1; i <= n; ++i)
		for(int j = min(T, f[i].a/f[i].b); j >= f[i].c; --j)
			dp[j] = max(dp[j], dp[j-f[i].c]+f[i].a-j*f[i].b);
	for(int i = 1; i <= T; ++i) res = max(res, dp[i]);
	printf("%d\n", res);
	return 0;
}

```


---


# [NOIP 2014 提高组] 飞扬的小鸟

## 题目背景

NOIP2014 提高组 D1T3

## 题目描述

Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。

为了简化问题，我们对游戏规则进行了简化和改编:

游戏界面是一个长为 $n$，高为 $m$ 的二维平面，其中有 $k$ 个管道（忽略管道的宽度）。 

小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。

小鸟每个单位时间沿横坐标方向右移的距离为 $1$，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 $x$，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $y$。小鸟位于横坐标方向不同位置时，上升的高度 $x$ 和下降的高度 $y$ 可能互不相同。

小鸟高度等于 $0$ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $m$ 时，无法再上升。

现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。

## 说明/提示

 
【输入输出样例说明】

如下图所示，蓝色直线表示小鸟的飞行轨迹，红色直线表示管道。

![](https://cdn.luogu.com.cn/upload/image_hosting/59alxbqi.png)

【数据范围】

对于 $30\%$ 的数据：$5 \leq n \leq 10, 5 \leq m \leq 10, k=0$，保证存在一组最优解使得同一单位时间最多点击屏幕 $3$ 次；

对于 $50\%$ 的数据：$5 \leq n \leq 20, 5 \leq m \leq 10$，保证存在一组最优解使得同一单位时间最多点击屏幕 $3$ 次；

对于 $70\%$ 的数据：$5 \leq n \leq 1000, 5 \leq m \leq 100$；

对于 $100\%$ 的数据：$5 \leq n \leq 10000$，$5 \leq m \leq 1000$，$0 \leq k < n$，$0 < x,y < m$，$0 < p < n$，$0 \leq l < h \leq m$， $l + 1 < h$。

## 样例 #1

### 输入

```
10 10 6 
3 9  
9 9  
1 2  
1 3  
1 2  
1 1  
2 1  
2 1  
1 6  
2 2  
1 2 7 
5 1 5 
6 3 5 
7 5 8 
8 7 9 
9 1 3 
```

### 输出

```
1
6

```

## 样例 #2

### 输入

```
10 10 4 
1 2  
3 1  
2 2  
1 8  
1 8  
3 2  
2 1  
2 1  
2 2  
1 2  
1 0 2 
6 7 9 
9 1 4 
3 8 10  ```

### 输出

```
0
3```

# 题解

## 作者：蒟蒻zExNocs (赞：1473)

## 一、杂言

我这个题解是按照从0开始的思路来讲的，比较适合于萌新，可能有些废话，所以请各位大犇们手下留情qwq

## 二、引入

这个题确实是细节题，毕竟是Noip提高组题还是非常不错的，有一些细节我在这列出来：(下面描述三中的"二中O"就是指这里面的注意点)

①高度为$M$时不能再上升

②可以多次点击，效果累加【~~因为无视了这句话写错了很多次QWQ~~

③管道不是按照顺序输入

④$M=0$不存在，但是$n$可以为0，而且鸟可以在(0,0~M)任何一个坐标开始

⑤管道输入的意思是下管道的上边界L与上管道的下边界H，也就是说这个两个管道分别占地为$(0,L)$和$(H,M)$

## 三、思路

这个题给出的状态有很多，那么很明显可以使用动态规划，可以列出的状态有：坐标$(x,y)$（分别对应目前的长度与高度）、点击次数、是否要点击。

### 1、状态确定&&转移方程(可以套模板)

假设没有管道，不妨设$dp[x][y][p]$为上一个点$(x-1,?)$点击或者不点击转移过来的坐标为$(x,y)$处的最小点击次数，其中$p=1$为点击，可以点击多次（二中②）,$p=0$为不点击。

由题设$up[i]$为$x=i$时点击一次上升高度，$down[i]$为$y=i$时不点击下降的高度。

那么当$p=1$时，$dp[x][y][1]=min(dp[x-1][y-up[x-1]][0or1],dp[x][y-up[x-1]][1])+1$

及要么从上一个点$x-1$点击一次过来，要么从本$x$坐标再点一次点出来。

当$p=0$时，$dp[x][y][0]=min(dp[x][y][1],dp[x-1][y+down[x-1]][0or1])$

及要么点，要么不点，**而且$p=0$要在$p=1$已经确定的基础上选择** (即使在后面滚动数组p后也需要这样进行)。

很明显每次选取都是在$p=0 or 1$中选取最小值，那么可以滚动数组去掉p数组，上状态转移方程其他不变。

但是有一个要求，高度为$M$时不能再上升（二中①），那么我们可以进行一个特判，如果此时的$y>=m$，那么上述方程中使$y=m$，及 $dp[x][m]=min(dp[x][m],dp[x][y]),y∈(m,m+up[x-1])$

上述$x,y$都可以进行枚举。那么我们不难看出，去掉p维数组后这个状态方程跟背包神相似，没错，这个就是完全背包+01背包的双组合，那么可以记下: **如果遇见选择或者不选择状态的题目时，可以考虑背包**，实在不会可以用我这个笨方法额外设个P数组0,1记录拿不拿状态，然后再优化删除，当然有的题也可能不能删除(这不就是01背包吗！)。

### 2、探究原题条件

现在又引入了一个叫做管道的鬼东西，那么我们需要再加一个特判。

如果这个地方是管道，也就是说这里不可以通过，那么就使这里的$dp[x][y]=inf$，不难写出代码：

```
for(int y=0;y<=low[cnt];y++)
	dp[x][y]=inf;
for(int y=high[cnt];y<=m;y++)
	dp[x][y]=inf;
```
$low[],high[]$如题目所述的$L$和$H$，$cnt$为当时遇见的第$cnt$个管道。（二中⑤）

这个特判是当$x=id[cnt]$时进行的，$id[cnt]$为第$cnt$个管道的$x$坐标。

另外要注意管道不是按照顺序输入（二中③），所以要把$low,high,id$写在同一个结构体中然后根据$id$进行$sort$

### 3、初始化

其实这个应该在状态转移方程里写的，但是我还是单独拉出来了 ~~（其实是作者突然想起来还有初始化，懒得往上插了qwq）~~

```
memset(dp,inf,sizeof(dp));
for(int y=1;y<=m;y++)
	dp[0][y]=0;
```
三句话，没了。不过要注意的是$x$是从0开始的，所以要初始化在坐标$x=0$（注意点二中④）

### 4、判断何时撞墙和最终答案如何输出

很明显，撞的一定是管道上（因为$y=0$的时候我们根本就没考虑），所以每次在特判管道的时候再查询当前$x$坐标中$dp[x][y]$的最小值，如果最小值等于$inf$的话，那么肯定就撞到这个管道上了，那么此时就输出$0$和$cnt-1$。

为什么是$cnt-1$？，因为你撞到了第$cnt$个管道，这个管道你过不去，所以当然是通过了$cnt-1$个管道辣。

如果程序顺利通过的话，那么就直接再次寻找$dp[n][y],y∈(1,m)$的最小值就可以了。

### 5、更多优化&&部分代码细节

①、因为状态$dp[x][y]$一定是由$dp[x-1][?]$得到,并且$dp[x-1][?]$在推出$dp[x][y]$后没有任何作用，所以可以再次滚动数组，定义 **i % 2** 为$x$ , **i%2^1(也可以为((i-1)%2))** 为$x-1$，那么我们就很愉快的把数组开到 $2*max$ 

相比之前的$max^2$内存少了很多，不过要注意可以去掉上述3中的初始化，改为在枚举$x$的时候加一条：

```
for(int y=0;y<=m;j++)
	dp[x%2][y]=inf;
```

仅仅只是在原来$O(n*m)$基础上加上了一个$m$，实际上对时间并没有太大的影响。

②、因为题目已经说明边界为$X=0$，所以枚举是从$X=1$的时候进行的，而且每次需要的是$up[x-1]$，我们不妨在初始化$up$数组的时候从$X=1$开始，那么我们使用的就是$up[x]$而不是$up[x-1]$了（实际上仅仅只是好看而已,不过也减少了计算量(~~你觉得计算一个减法能需要多长时间！~~)）

③、注意开$Y$数组大小的时候要开大一点，不要只局限于1005，因为咱们并不只是枚举到$M$，而是要枚举到$M+up[x]$

④、因为初始化 $dp[x][y]=inf$ ，所以在$p=1$(虽然p已经被删除了，不过为了方便说明还是把它写出来了)的时候不需要再加一个 $dp[x][y]=min(dp[x][y],dp[?][?]+1)$的情况，如果要点的话，必须要点一次，否则就是inf

⑤、剩下的细节请看下面的代码，不过代码的部分数组与上述描述的名字不一样（上面的名字是我为了方便讲解取得，下面代码懒得改了qwq）

### 6、$code$(你觉得直接抄可以过吗？qwq):
```
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define gc(a) a=getchar()
#define pc(a) putchar(a)
ll read(){
    char c;ll x=0;bool flag=0;gc(c);
    while(c<'0'||c>'9'){if(c=='-') flag=1;gc(c);}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48),gc(c);}
    return flag?-x:x;
}
void pr(ll x){
    if(x<0){x=-x;pc('-');}
    if(x>9) pr(x/10);
    pc(x%10+48);
}
//-------快读------
#define inf 0x3f3f3f3f
const ll maxn=10005;
const ll maxm=10005;
struct node
{
	ll id,h,l;
	bool operator <(const node &a) const
	{
		return id<a.id;
	}
}o[maxn];
ll x[maxn],y[maxn],dp[2][maxm],n,m,k,cnt=1,ans;
int main()
{
	//memset(dp,inf,sizeof(dp));//两个被遗忘的初始化之一qwq
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++)
	x[i]=read(),y[i]=read();
	for(int i=1;i<=k;i++)
	o[i].id=read(),o[i].l=read(),o[i].h=read();
	sort(o+1,o+k+1);//管道id排序!
	//for(int i=1;i<=m;i++)
	//dp[0][i]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)//注意要初始化！
		dp[i%2][j]=inf;
		for(int j=x[i]+1;j<=x[i]+m;j++)//p=1，完全背包
		dp[i%2][j]=min(dp[i%2^1][j-x[i]]+1,dp[i%2][j-x[i]]+1);
		for(int j=m+1;j<=x[i]+m;j++)//比m大的都是m
		dp[i%2][m]=min(dp[i%2][m],dp[i%2][j]);
		for(int j=1;j<=m-y[i];j++)//p=0，01背包
		dp[i%2][j]=min(dp[i%2][j],dp[i%2^1][j+y[i]]);
		if(i==o[cnt].id)//如果这个地方有管道
		{
			ans=inf;//主要每次都要初始化一次！
			for(int j=0;j<=o[cnt].l;j++)
			dp[i%2][j]=inf;
			for(int j=o[cnt].h;j<=m;j++)
			dp[i%2][j]=inf;
			for(int j=1;j<=m;j++)//寻找是否可以通过
			ans=min(dp[i%2][j],ans);
			if(ans==inf)
			{
				pr(0);pc('\n');pr(cnt-1);return 0;
			}
			cnt++;
		}
	}
	ans=inf;//注意要初始化！
	for(int j=1;j<=m;j++)
	ans=min(dp[n%2][j],ans);
	pr(1);pc('\n');pr(ans);
	return 0v0;
}
```
### 4、后语

题解千万条，细节第一条

题解没有赞，作者两行泪

你看作者因为写题解都把上面的数字记成4了，你们忍心咩qwq

---

## 作者：依然wtm (赞：66)

[洛谷P1941 原题地址](https://www.luogu.org/problemnew/show/P1941)

这是一道DP题，也是一道终极细节题。朴素的DP方程还是比较好想的。如果用$f[i][j]$表示到第$i$列高度为$j$时的最小点击数的话，DP方程也就是
$$f[i][j] = min(f[i][j], f[i - 1][j - k * lift[i - 1]] + k, f[i - 1][j + down[i - 1]])$$
其中$lift[i]$是在第$i$列点击后上升的高度，$down[i]$是第$i$列下降的高度，$k$是在前一列点击的次数。要注意的就是高度为$m$时需要特判一下。

处理完了所有$f[i][j]$后，只需要从后往前扫一遍，找到能通到的一列，如果为第$n$列就输出$1$和最小点击数，否则输出$0$和柱子数。理论上这个算法时间复杂度为$O(n^3)$，应该能过$70\%$的数据。于是按照这个思路，我有了第一版的代码。

DP部分代码如下：
```cpp
int nump = 1;
    for (int i = 1; i <= n; i++) {
        int lower = 0, upper = m;
        if (pipe[nump].pos == i) {
            upper = pipe[nump].up - 1;
            lower = pipe[nump++].bottom + 1;
        }
        for (int j = lower; j <= upper; j++) {
            for (int k = 1; j - k * lift[i - 1] >= 0; k++) { // 上升到（i，j）
                if (j == m) { // 特判m
                    for (int q = j - k * lift[i - 1]; q <= m ; q++)
                        f[i][j] = min(f[i][j], f[i - 1][q] + k);
                } else {
                    f[i][j] = min(f[i][j], f[i - 1][j - k * lift[i - 1]] + k);
                }
            }
            if (j + down[i - 1] <= m) f[i][j] = min(f[i][j], f[i - 1][j + down[i - 1]]); // 下降到（i，j）
        }
    }
```

但很不幸，这个代码并没有那到预期的$70$分，而是只有$50$。仔细读题后发现$i = 0$的时候是直接死掉的……在第二版代码中去掉$j = 0$的情况后，分果然变多了，变成了$70$分……虽然达到预期分数了，但发现有一个点并不是TLE，而是~~蛙~~WA了。于是乎下了数据，把所有$f[i][j]$打出来仔细研究（这是一种好方法）后发现，这句话
```cpp
for (int k = 1; j - k * lift[i - 1] >= 0; k++)
```
中，$j - k * lift[i - 1] >= 0$的条件当$j = m$时有可能是错的，因为如果 $m \% lift[i - 1] != 0$，那么$1$到$m \% lift[i - 1]$的高度就枚举不到。举个例子，若$m = 5$，$lift[i - 1] = 3$，那么如果满足以上循环的条件的话，$1$和$2$这两个高度就枚举不到，而事实上当前状态完全有可能由这两个状态拓展而来。

发现了错误并进行改正后，第三版代码横空出世：
```cpp
//#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;

struct Pipe {
    int pos, up, bottom; // 柱子的位置，顶的高度和底的高度
} pipe[10010];

const int MAXN = (1 << 30);
int n, m, k, lift[10010], down[10010], f[10010][1010];

bool cmp(Pipe a, Pipe b) {
    return a.pos < b.pos;
}

int main(){
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i <= n - 1; i++)
        scanf("%d%d", &lift[i], &down[i]);
    for (int i = 1; i <= k; i++)
        scanf("%d%d%d", &pipe[i].pos, &pipe[i].bottom, &pipe[i].up);
    sort(pipe + 1, pipe + k + 1, cmp); // 把柱子按列位置排序
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++)
            f[i][j] = MAXN;
    } // MAXN意味着到达不了（i，j）
    for (int i = 1; i <= m; i++) f[0][i] = 0; // 从第0列任意位置出发
    int nump = 1; // 下一个是第几个柱子
    for (int i = 1; i <= n; i++) {
        int lower = 1, upper = m;
        if (pipe[nump].pos == i) { // 如果这列有柱子
            upper = pipe[nump].up - 1;
            lower = pipe[nump++].bottom + 1;
        }
        for (int j = lower; j <= upper; j++) {
            if (j == m) { // 上升
                for (int k = 1; k <= m; k++) {
                    f[i][j] = min(f[i][j], f[i - 1][k] + ((m - k) / lift[i - 1]) + (((m - k) % lift[i - 1] || k == m) ? 1 : 0)); // 特判m
                }
            } else {
                for (int k = 1; j - k * lift[i - 1] >= 0; k++) {
                    f[i][j] = min(f[i][j], f[i - 1][j - k * lift[i - 1]] + k);
                } 
            }
            if (j + down[i - 1] <= m) f[i][j] = min(f[i][j], f[i - 1][j + down[i - 1]]); // 下降
        }
    int minn = MAXN;
    bool flag = false;
    for (int i = n; i >= 1; i--) { // 从后往前扫
        for (int j = 1; j <= m; j++) {
            if (f[i][j] != MAXN) {
                flag = true;
                minn = min(minn, f[i][j]); // 找到这一列的最小点击数
            }
        }
        if (flag) { // 输出
            if (i == n) {
                printf("1\n%d", minn);
                return 0;
            }
            else {
                for (int j = k; j >= 1; j--) {
                    if (i >= pipe[j].pos) {
                        printf("0\n%d", j);
                        return 0;
                    }
                }
            }
        }
    }
    printf("0\n0"); // 一个柱子也没过
    return 0;
}
```
这段代码已经超过了预期，用朴素算法拿到了$80$分的高分。那最后的$20$分怎么拿呢？观察代码，很明显更新上升的时候是有很多重复更新的。
我们先不考虑下降的情况，可以想到，在更新$f[i][j]$的时候，$f[i][j - lift[i - 1]]$已经更新得到了到$(i, j - lift[i - 1])$处的最小点击数，那么$f[i][j]$有两种更新的可能：一是从$i - 1$列上升一次到$j$，二是先从$i - 1$列上升$k$次到$j - lift[i - 1]$，再上升一次到$j$。而从$i - 1$列上升$k$次到$j - lift[i - 1]$的最优解已经存到了$f[i][j - lift[i - 1]]$里，所以我们有了一个新的上升时的DP方程：

$$f[i][j] = min(f[i][j], min(f[i - 1][j - lift[i - 1]], f[i][j - lift[i - 1]]) + 1)$$

特别要注意的是，用朴素DP的时候是可以不更新被柱子挡住的部分的，但是这个DP中需要更新下面的柱子挡住的部分（第四代代码被这个又卡了好久），因为这会影响到上面的计算，只要计算完再把柱子的部分赋回最大值就可以了。

更新完上升的情况后，正常再做一遍下降的更新就可以了。注意更新上升下降的顺序不能颠倒，因为根据我们的更新方法，颠倒顺序后可能出现先下降再上升的情况，而这是不符合题意的。

AC代码（第五代代码）如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

struct Pipe {
    int pos, up, bottom;
} pipe[10010];

const int MAXN = (1 << 30);
int n, m, k, lift[10010], down[10010], f[10010][1010];

bool cmp(Pipe a, Pipe b) {
    return a.pos < b.pos;
}

int main(){
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i <= n - 1; i++)
        scanf("%d%d", &lift[i], &down[i]);
    for (int i = 1; i <= k; i++)
        scanf("%d%d%d", &pipe[i].pos, &pipe[i].bottom, &pipe[i].up);
    sort(pipe + 1, pipe + k + 1, cmp);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++)
            f[i][j] = MAXN;
    }
    for (int i = 1; i <= m; i++) f[0][i] = 0;
    int nump = 1;
    for (int i = 1; i <= n; i++) {
        int lower = 1, upper = m;
        if (pipe[nump].pos == i) {
            upper = pipe[nump].up - 1;
            lower = pipe[nump++].bottom + 1;
        }
        for (int j = 1; j <= upper; j++) { // 上升
            for (int k = j - lift[i - 1]; k <= m; k++) {
                if (k > j - lift[i - 1] && j < m) break; // 高度不是m就只做一次退出
                if (k >= 1) f[i][j] = min(f[i][j], min(f[i - 1][k], f[i][k]) + 1);
            }
        }
        for (int j = lower; j <= upper; j++) {
            if (j + down[i - 1] <= m) { // 下降
                f[i][j] = min(f[i][j], f[i - 1][j + down[i - 1]]);
            }
        }
        for (int j = 1; j <= lower - 1; j++) f[i][j] = MAXN; // 把柱子原来的最大值填回去
    }
    int minn = MAXN;
    bool flag = false;
    for (int i = n; i >= 1; i--) {
        for (int j = 1; j <= m; j++) {
            if (f[i][j] != MAXN) {
                flag = true;
                minn = min(minn, f[i][j]);
            }
        }
        if (flag) {
            if (i == n) {
                printf("1\n%d", minn);
                return 0;
            }
            else {
                for (int j = k; j >= 1; j--) {
                    if (i >= pipe[j].pos) {
                        printf("0\n%d", j);
                        return 0;
                    }
                }
            }
        }
    }
    printf("0\n0");
    return 0;
}
```

---

## 作者：Mr_Wu (赞：61)

这道题细节特别多。。可以考察你的dp能力~~并让你想把键盘砸烂~~

此题我会介绍dp做法，听说搜索也是可以过的。。

### $\text{1. Description}$

游戏界面：长为$n$，宽为$m$（横坐标**从0到n**，纵坐标**从0到m**）

起点：小鸟从最左边($x=0$)**任意位置**出发

成功条件：到达游戏界面最右边时($x=n$)完成游戏

失败条件：在出发后$y\le 0$或碰到管道（即在任意时刻$y\le L_i$或$y\ge H_i$，这里$L_i$和$R_i$如题面所述，为下边沿高度和上边沿高度）

移动方式（这里指在每个单位时间内）

- $x=x+1$

- 可以花费$k$的代价（$k$为正整数）使$y=min(y+k*X_x, m)$（这里与$m$取min是因为题面中说"小鸟高度为$m$时，无法再上升。"）

- 如果不花费代价上升，那么$y=y-Y_x$（$y\le0$时会死亡，所以当$y\le Y_i$时不能做此操作）

询问是否会成功，如果可以输出最少代价，否则输出最多可以通过的管道数

### $2. \text{Algorithm 1}$

对于$70$%的数据：$5 \leq n \leq 1000, 5 \leq m \leq 100$

我们设$dp[i][j](1\le i\le n, 1\le j\le m)$表示$x=i,y=j$时，走到这里需要花费的最少代价。

- 如果上一步是下降到这里的，那么代价应该就是$dp[i][j]=dp[i-1][j+Y_{i-1}]+1$，转移的时候需要考虑$j+Y_{i-1}>m$的情况，此时不可能下降过来，不做这此的处理

- 如果上一步是上升来这里的，我们需要再次分两种情况讨论：

> - 如果$1\le j<m$，那么前一步可能是从$j-X_{i-1}*1$到的，可能是从$j-X_x*2$到的...，所以此时的代价是

$$dp[i][j]=\min_{j-X_{i-1}*k>1}{(dp[i-1][j-X_{i-1}*k]+k)}$$


> - 如果$j=m$，题意中说上升时到$m$就不能继续上升，会卡在这里，所以这一步可能是从之前任意一个$y$坐标转过来的，需要对每一个$y$都枚举，算代价

那么这么转移，一次转移是$O(m)$的，每个$dp[i][j]$都算是$O(nm)$的，时间复杂度是$O(nm^2)$的，能过$70$%的数据。

期望得分$70$

实际得分$80(4\times TLE)$

### $3. \text{Algorithm 2}$

我们分析刚才的算法复杂度为什么会大。

看起来枚举每个$dp[i][j]$算答案的$O(nm)$的复杂度不能优化，除非我们改变dp状态。

计算一个$dp[i][j]$需要$O(m)$的复杂度，这是因为上升的距离有变化，我们思考如何用一个值能算出上文提到的这个式子

$$\min_{j-X_{i-1}*k>1}{(dp[i-1][j-X_{i-1}*k]+k)}$$

思考跳$k(k\ge 2)$次和跳$k-1$次的关系，如果跳$k$次能到$dp[i][j]$，跳$k-1$次就能到$dp[i][j-X_{i-1}]$.

那么我们实际上可以用**上升到**$dp[i][j-X_{i-1}]$的代价来表示跳两次即以上跳到$dp[i][j]$的代价，所以新的dp转移方程：

> 对于$1\le j<m$，上升到$dp[i][j]$的代价是$dp[i][j]=\min(dp[i-1][j-X_{i-1}], dp[i][j-X_{i-1}])$

> **注意：这里的$dp[i][j-X_{i-1}]$是不太一样的，表示上一步上升到这里的代价，不能包含下降到这里的代价。**

我们同样需要考虑$j=m$时的情况，这时我们实际上可以每个$y$都枚举，也可以进行优化，因为这不影响我们把复杂度优化到$O(mn)$。我们可以如此优化：

```cpp
for (j = M - X[i - 1]; j <= M; ++j)
	dp[i][M] = min(dp[i][M], min(dp[i - 1][j], dp[i][j]) + 1);
```

原因和上面所述差不多。

顺便说一下，上面提到的“只计算上升到这里的代价”，可以这么算：

```cpp
for (i = 1; i <= N; ++i)
{
	将dp[i][1]~dp[i][M]都设为正无穷方便计算
    
    for (j = X[i - 1] + 1; j < M; ++j)
    	//j=X[i-1]+1是因为低于X[i-1]的显然不可能由上升得来
    	计算上升到dp[i][j]的代价，并赋值给dp[i][j]
        //这样当计算dp[i][j]时。dp[i][j-X[i-1]]已经被计算，而且是只计算上升的代价
        
    for (j = M - X[i - 1]; j <= M; ++j)
    	dp[i][M] = min(dp[i][M], min(dp[i - 1][j], dp[i][j]) + 1);
        
    for (j = 1; j + Y[i - 1] <= M; ++j) 计算下降的代价，复制给dp[i][j]
    
    将被墙挡住的dp[i][..]赋值为正无穷
}
```

### $\text {4. Code}$

```cpp
#include <cstdio>
#include <climits>

#define MAXN 10005
#define MAXM 1005
#define min(a, b) (((a) < (b)) ? (a) : (b))
#define INF (LLONG_MAX - 100) //减掉100是因为作者太菜，十分害怕溢出。
typedef long long ll;
int read()
{
    int ret = 0;
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
    return ret;
}

int N, M, K, X[MAXN], Y[MAXN], L[MAXN], H[MAXN];
ll dp[MAXN][MAXM], ans[MAXN];
bool W[MAXN];

int main()
{
    N = read(), M = read(), K = read();
    int i, j, x;
    for (i = 0; i < N; ++i) X[i] = read(), Y[i] = read();
    for (i = 1; i <= K; ++i) x = read(), L[x] = read(), H[x] = read(), W[x] = 1; //W[i]表示i坐标为x时有没有管道
    for (i = 0; i <= M; ++i) dp[0][i] = 0;
    for (i = 1; i <= N; ++i) dp[i][0] = INF;
    for (i = 1; i <= N; ++i)
    {
    	ans[i] = INF;
    	for (j = 1; j <= M; ++j) dp[i][j] = INF;
    	for (j = X[i - 1] + 1; j < M; ++j) dp[i][j] = min(dp[i][j], min(dp[i - 1][j - X[i - 1]], dp[i][j - X[i - 1]]) + 1);
    	for (j = M - X[i - 1]; j <= M; ++j) dp[i][M] = min(dp[i][M], min(dp[i - 1][j], dp[i][j]) + 1);
    	for (j = 1; j + Y[i - 1] <= M; ++j) dp[i][j] = min(dp[i][j], dp[i - 1][j + Y[i - 1]]);
    	if (W[i])
    	{
    		for (j = 1; j <= L[i]; ++j) dp[i][j] = INF;
    		for (j = H[i]; j <= M; ++j) dp[i][j] = INF;
    	}
        //上面这一部分就是上面所述的伪代码实现
        
    	for (j = 1; j <= M; ++j) ans[i] = min(ans[i], dp[i][j]);
    	if (ans[i] == INF) //ans[i]表示y=i的时候最少的代价，如果=INF就说明无法走到这个y坐标，更不可能走到后面的。
    	{
    		ll ac = 0;
    		for (j = 1; j < i; ++j) if (W[j]) ++ac;
    		printf("0\n%lld\n", ac);
    		return 0;
    	}
    }
   	printf("1\n%lld\n", ans[N]);
    return 0;
}
```

---

## 作者：pzc2004 (赞：15)

[题目传送门](https://www.luogu.org/problem/P1941)

~~我用了瞎想出来的单调队列优化DP，A掉后一看题解才发现就是一个完全背包~~。

令$F_{i,j}$表示到达$(i,j)$所用的最少的点击数，那么$f_{i,j}$要么是从$f_{i-1,j+y}$转移过来，要么是从$f_{i-1,j-k*x}$转移过来（k表示点击屏幕数），~~似乎这样还可以用滚动数组~~。推出转移方程$f_{i,j}=\min(f_{i-1,i+y},f_{i-1,j-k*x}+k)$，如果这个点到达不了，就不需要转移了。

~~然后我们发现这样复杂度是$O(NM^2)$的，过不了~~，于是考虑用单调队列优化成$O(NM)$的。

第一种转移直接转移掉就好了，关键在于第二种转移怎么找之前的最小值。

如果你学过单调队列优化多重背包，会发现这和单调队列优化多重背包挺像的，没学过也没关系。

因为小鸟只能从$(i-1,j-k*x)$跳到$(i,j)$，因此我们可以把每个节点的纵坐标按照%x的余数分成x组，这样组与组之间就互不影响了。

接着考虑组内部的状态转移，显然对于$F_{i,j}$只有$\min(f_{i-1,j-k*x}+k)$会对答案有贡献，因此我们只需要维护$f_{i-1,j-k*x}+k$的最小值，只需要用一个单调队列就行了。

最后注意一个坑点：小鸟最高只能跳到横坐标为m，所以要把$f_{i,m}$处理一下。

代码：
``` cpp
#include<bits/stdc++.h>
#define inf 1000000000
inline int min(const int &a,const int &b){return a<b?a:b;}
inline int read(){int x=0;char c=getchar();while(c<'0' || c>'9')c=getchar();while(c>='0' && c<='9')x=(x<<3)+(x<<1)+(c^'0'),c=getchar();return x;}//快读
inline int quzheng(int a,int b){if(a==0)return 1;return (a%b==0)?(a/b):(a/b+1);}//顾名思义，取整
int n,m,k,x[10001],y[10001],f[10001][1001],q[1001],l,r,ans;
bool b[10001][1001],g[10001];//b数组表示(i,j)是否有管子，g数组表示第i列是否有管子
int main()
{
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;i++){x[i]=read(),y[i]=read();for(register int j=1;j<=m;j++)f[i][j]=inf;}//初始化为正无穷
	for(register int i=1,p,l,h;i<=k;i++){p=read(),l=read(),h=read();for(register int j=0;j<=l;j++)b[p][j]=1;for(register int j=h;j<=m;j++)b[p][j]=1;g[p]=1;}/
	for(register int i=1;i<=n;i++)
	{
		if(g[i-1])ans++;//统计已经跳过的管子数
		for(register int j=1;j<=m-y[i];j++)if(!b[i][j])f[i][j]=f[i-1][j+y[i]];//状态转移
		if(!b[i][m] && x[i])for(register int j=1;j<=m;j++)if(!b[i-1][j])f[i][m]=min(f[i][m],f[i-1][j]+quzheng(m-j,x[i]));//提前处理一下f[i,m]
		for(register int j=0;j<x[i];j++)//处理每一组
		{
			l=1,r=0;//清空单调队列
			int maxp=(m-j)/x[i];//最多能点击多少次
			for(register int k=0;k<=maxp;k++)
			{
				if(k*x[i]+j==0)continue;//横坐标为0的不能转移
				if(l<=r && !b[i][k*x[i]+j])f[i][k*x[i]+j]=min(f[i][k*x[i]+j],f[i-1][q[l]*x[i]+j]+k-q[l]);//转移
				if(f[i-1][k*x[i]+j]==inf)continue;//如果(i-1,k*x+j)无法到达就跳过
				while(l<=r && f[i-1][q[r]*x[i]+j]+k-q[r]>=f[i-1][k*x[i]+j])--r;//单调队列维护最小值
                q[++r]=k;//推入队尾
			}
		}
		bool bb=0;//检测是否有跳过该管子
		for(register int j=1;j<=m;j++)if(f[i][j]!=inf){bb=1;continue;}
		if(!bb){printf("0\n%d",ans);return 0;}//没跳过就直接退出
	}
	printf("1\n");
	ans=inf;
	for(register int i=1;i<=m;i++)ans=min(ans,f[n][i]);
	printf("%d",ans);
}
```
![](https://www.luogu.org/images/congratulation.png)

---

## 作者：Little_x_starTYJ (赞：13)

## 解题思路
作为一名蒟蒻，默默地展开了算法标签，发现是 dp。

所以，本蒟蒻就用了一个简简单单轻轻松松就能理解的小 dp。

很容易想到我们设 $dp_{i,j}$ 为走到 $(x, y)$ 所使用的最小屏幕点击数。

那我们可以从哪些坐标走到 $(i, j)$ 呢（假设地图无边界限制）？

我们先看第一种情况：  
小鸟从某个点向上飞到了 $(i, j)$。

1. 从 $(i, j - x_i)$ 走到 $(i, j)$，即小鸟飞到 $(i, j - x_i)$ 时，玩家点击了屏幕一次，然后小鸟就飞到了 $(i, j - x_i)$。（玩家连续点击的情况）
2. 从 $(i - 1, j - x_i)$ 走到 $(i, j)$，即小鸟飞到 $(i - 1, j - x_i)$ 时，玩家点击了屏幕一次，然后小鸟就向右飞了一个单位长度，又向上飞了 $x_i$ 个单位长度，最后到达了 $(i - 1 + 1, j - x_i + x_i)$ 即 $(i, j)$。

那么小鸟还可能从某个点向下掉，同上。

因此，我们只需要分成四种情况讨论即可，每走到一个位置 $(i,j)$，$dp_{i,j}$ 就从可能走到这个位置上的所有点转移过来，取一个最小值，不过如果是从下面飞上来的话答案需要再加一。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int x[10010], y[10010];
int dp[2][2010];
unordered_map<short, pair<int, int> > f;
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		cin >> x[i] >> y[i];
	}
	for (int i = 1; i <= k; i++) {
		int p, l, h;
		cin >> p >> l >> h;
		f[p] = make_pair(l, h);
	}
	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			dp[i & 1][j] = 1e18;
		}
		for (int j = x[i] + 1; j <= x[i] + m; j++) {
			//i & 1 ^ 1 相当于 i = 0 时取 1，i = 1 取 i = 0
			//与 i - 1 差不多的意思，只不过 0 - 1 = 1 
			dp[i & 1][j] = min(dp[i & 1 ^ 1][j - x[i]], dp[i & 1][j - x[i]]) + 1;
		}
		for (int j = m + 1; j <= x[i] + m; j++) {  //大于 m 的位置全都看成到达 m 
			dp[i & 1][m] = min(dp[i & 1][m], dp[i & 1][j]);
		}
		for (int j = 1; j <= m - y[i]; j++) {
			dp[i & 1][j] = min(dp[i & 1][j], dp[i & 1 ^ 1][j + y[i]]);
		}
		if (f.count(i)) {
			bool flag = false;
			for (int j = 0; j <= m; j++) {
				if (j <= f[i].first || j >= f[i].second) {
					dp[i & 1][j] = 1e18;
				} else {
					if (dp[i & 1][j] != 1e18) {
						flag = true;
					}
				}
			}
			if (!flag) {
				cout << "0\n" << cnt;
				return 0;
			}
			cnt++;
		}
	}
	int ans = 1e18;
	for (int i = 0; i <= m; i++) {
		ans = min(dp[n & 1][i], ans);
	}
	cout << "1\n" << ans;
	return 0;
}
```

---

## 作者：jins3599 (赞：9)

立个$flag$，以后再不仔细研究研究样例就做题，直接罚自己写完猪国杀。

本来拿到题，发现给的部分分很多，然后就想着打个$70pts$的暴力$dp$。

结果样例都过不去，然后慌慌张张的模拟了一下样例，发现走到顶是合法的，然后又改改改，发现还是过不去样例。

然后又去仔细研究自己写的啥，发现自己的方程推错了，然后又改改改，又是过不去样例。

然后又又又研究自己写的啥，然后发现自己边界搞错了，然后又是一番操作...终于拿到了艰辛的$70pts$

其实这$70pts$是很好打的..只需要一个暴力的方程：

$$f[i+1][j] = min\{f[i][j+k*y]+k,f[i][j-k*x]\}$$

为啥用填表法而不用刷表法$dp$？因为这样不需要特判$j=m$的特殊情况，我们是可以优美的全部都枚举到的。

然后特判一个向下走的过程，枚举一个向上走的过程，时间复杂度$O(m^2n)$

（结果我写了一个半小时...）

70pts代码
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f

using namespace std;

const int N = 1e3 + 10;

int f[N][N];

int n , m , k;
int x[N] , y[N];
int flag[N] , l[N] , h[N];

int main () {
	scanf("%d %d %d" ,&n , &m, &k);
	for(int i = 0 ; i < n ; ++ i) scanf("%d %d" , x + i , y + i);
	for(int i = 1 ; i <= k ; ++ i) {
		int q;
		scanf("%d" , &q);
		scanf("%d %d" , &l[q] , &h[q]);
		flag[q] = 1;
	}
	for(int i = 1 ; i <= n ; ++ i)
		for(int j = 1 ; j <= m ; ++ j) f[i][j] = inf;
		
	for(int i = 1 ; i <= m ; i ++) f[0][i] = 0;
	
	for(int i = 0 ; i < n ; ++ i) {
		for(int j = 1 ; j <= m ; ++ j) { // 枚举当前可能在的位置 
			if(flag[i] && (j <= l[i] || j >= h[i])) continue;// 若在柱子上，则不转移 
			int low = j - y[i];
			if(low <= 0) low = -1;
			if(flag[i + 1] && (low <= l[i + 1] || low >= h[i + 1])) low = -1; 
			if(low != -1) f[i + 1][j - y[i]] = min(f[i + 1][j - y[i]] , f[i][j]);
			for(int p = 1 ; p <= m ; ++ p) { // 枚举步数 
				int high = min(m , j + p * x[i]); // 下一个可以走到的最高点 
				if(low < 1) low = -1;
				if(flag[i + 1] && (high >= h[i + 1] || high <= l[i + 1])) high = -1;
				if(high != -1) f[i + 1][high] = min(f[i + 1][high] , f[i][j] + p);
			}
		}	
		
	}
	int cnt = 0 , ans1 = inf , ans2 = 0;
	int last;
	for(int i = 1 ; i <= m ;++ i) ans1 = min(ans1 , f[n][i]);
	if(ans1!=inf) printf("1\n%d" , ans1);
	else{
		for(int i = 1 ; i <= n ; ++ i)
			for(int j = 1 ; j <= m ; ++ j) {
				if(flag[i] && f[i][j] != inf ) {
					ans2 ++;break;
				}
			}
		printf("0\n%d",ans2);
	}
	return 0;
}
```

我们考虑优化一下这个DP

我们发现我们对一个数据进行了多次的重复计算。

就是说，我们把$f[i]-x[i]*k$ 计算了很多次，因此导致我们的程序效率低下。

我们想，上一次计算过的$f[i]-x[i]*k$ 保存在了什么地方？

假设我们正在计算$f[i+1][j]$，那么显然这个数据保存在他下面的某个数组中！，也就是说在$f[i+1][1...j]$中有我们需要的答案，但是具体在什么地方？

聪明的读者已经想到了，这个最优的数据一定保存在$f[i+1][j-x[i]]$上。

但是如何转移？我们发现如果用我们的刷表法去优化有点难度，于是我们改进一下，尝试用填表法去进行$dp.$

转移方程张这样：

$$f[i][j]=min\{f[i-1][j-x[i]]+1,f[i][j-x[i]]+1,f[i-1][j+y[i]]\}$$


然后呢？还记不记得我们上面提到的为什么用刷表而不用填表写$dp$？

我们需要特判$j=m$的情况！因为对于区间$[m-x[i-1]...m]$是全都可以走到$m$点的！因此对于$m$点我们需要分类讨论一下。

最后确定一下转移顺序。

我们需要先转移上升的还是转移下降的？

显然是要先转移上升的，因为如果先转移下降的，那么我们后面在对上升的小鸟进行处理时，会把下降的那一部分也考虑进去，会导致答案错误。

综上，这道题目就顺利的完成了，不失为一道训练$dp$思维能力的好题。

```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f

using namespace std;

const int N = 1e4 + 10;

int f[N][1005];

int n , m , k;
int x[N] , y[N];
int flag[N] , l[N] , h[N];
int ans[N];

int main () {
	scanf("%d %d %d" ,&n , &m, &k);
	for(int i = 0 ; i < n ; ++ i) scanf("%d %d" , x + i , y + i);
	for(int i = 1 ; i <= k ; ++ i) {
		int q;
		scanf("%d" , &q);
		scanf("%d %d" , &l[q] , &h[q]);
		flag[q] = 1;
	}
	for(int i = 1 ; i <= n ; ++ i)
		for(int j = 1 ; j <= m ; ++ j) f[i][j] = inf;
		
	for(int i = 1 ; i <= m ; i ++) f[0][i] = 0;
	
	for(int i = 1 ; i <= n ; ++ i) 
	{
		for(int j = 1 ; j <= m ; j ++) f[i][j] = inf;
		for(int j = x[i - 1] + 1 ; j < m ; j ++) 
			f[i][j] = min(f[i][j] , min(f[i - 1][j - x[i - 1]] , f[i][j - x[i - 1]]) + 1);
			
		for(int j = m - x[i - 1] ; j <= m ; j ++)
			f[i][m] = min(f[i][m] , min(f[i - 1][j] , f[i][j]) + 1);
			 
		for(int j = 1 ; j + y[i - 1] <= m ; j ++)
			f[i][j] = min(f[i][j] , f[i - 1][j + y[i - 1]]);
			
		if(flag[i]) {
			for(int j = 1 ; j <= l[i] ; j ++) f[i][j] = inf;
			for(int j = m ; j >= h[i] ; j --) f[i][j] = inf;
		}
		ans[i] = inf;
		for(int j = 1 ; j <= m ; j ++) ans[i] = min(ans[i] , f[i][j]);
		if(ans[i] == inf) {
			int cur = 0;
			for(int j = 1 ; j < i ; j ++) if(flag[j]) cur ++;
			printf("0\n%d" , cur);
			return 0;
		}
	}
	printf("1\n%d" , ans[n]);
	return 0;
}
 
```

---

## 作者：一只小兵 (赞：7)

## 思路
    这是一道DP的题目,基本思路就是DP
---------

## 思考过程

这道题的思路分两步:$DP+$对$DP$的优化。

### 普通DP思路

小鸟在飞行的过程中,对于每个点存在**两种**状态:

1. 向上飞 $ P \times X_{i}$ 的距离,点击次数增加P次.
2. 向下降 $Y_{i}$ 的距离 . 

对于每个节点都进行状态转移,就可以得到这个节点的下一个横坐标节点的状态了.

#### 形象一点表示:

![DP转移](https://cdn.luogu.com.cn/upload/pic/71796.png)

可以看出动态转移方程:
1. 对于向下移动

$f$ $\lbrack$ $i$ $+ $ $1$ $\rbrack$ $[$ $j$ $]$  $=$  $min$ $($ $f$ $[ $ $i$ $+$ $1$ $]$ $[$ $j$ $]$ $,$ $f$ $[$ $i$ $]$ $[$ $j$ $]$ $)$

2. 对于向上移动

$f$ $\lbrack$ $i$ $+ $ $1$ $\rbrack$ $[$ $j$ $]$  $=$  $min$ $($ $f$ $[ $ $i$ $+$ $1$ $]$ $[$ $j$ $]$ $,$ $f$ $[$ $i$ $]$ $[$ $j$ $- $ P $\times$ $X_{i}$ $]$ $ + $ $P$ $)$

对于所有点都进行DP,那么最终就可以得出答案.

转移代码:
```cpp
// luo[] 表示位置当前落下Y sheng[]表示当前位置上升 X 
for(int t = 0 ; t < n ; t++){// t 表示当前的横坐标
	bool flag = false,arr=false;//flag 表示当前转移位置是否存在管子 
   				    //arr 表示当前位置能否转移到下一个位置
	if(t+1 == p[now_k].place) flag = true;//now_k表示当前最近管子
	for(int g = 1 ; g <= m ; g++){
		if(b[t][g]){//b表示是否能够被到达
			if(flag){
				int dow = g - luo[t];//向下降后的位置
				if(dow > p[now_k].l && dow < p[now_k].h) {//不被管子挡住
					b[t+1][dow] = true;
					arr = true;
					f[t+1][dow] = min(f[t+1][dow],f[t][g]);
				}
			}
			else {
				int dow = g - luo[t];
				if(dow > 0) {
					b[t+1][dow] = true;
					arr = true;
					f[t+1][dow] = min(f[t+1][dow],f[t][g]);
				}
			}
			int upp = g + sheng[t],ci = 1;//向上转移 ci表示向上转移次数
			bool qaq = false;
			if(upp > m) upp = m,qaq=true;//因为顶着"天花板" 不会 game over 所以需要特判
			while(upp <= m){
				if(flag) {
					if(upp >= p[now_k].h) break;//已经超过管子的上端,停止上跳
					if(upp <= p[now_k].l) {
						upp += sheng[t];++ci;
						if(qaq) break;
						if(upp > m) upp = m,qaq=true;
						continue;
					}
				}
				if(upp > 0){
					b[t+1][upp] = true;
					arr = true;
					f[t+1][upp] = min(f[t+1][upp],f[t][g]+ci);
				}
				upp += sheng[t];++ci;
				if(qaq) break;
				if(upp > m) upp = m,qaq=true;
			}
		}
	}
	if(flag) {
		if(!arr) break;//如果不能跳过当前管子,就停止递归
		++now_k;
	}
}
```

咋一看,时间复杂度:$O(n \times m)$ 空间复杂度: $O(n \times m)$ 是不是过了.~~开了O2是的~~~

当然不是,每次向上跳的转移不是$O(1)$的,所以整个的复杂度就会改变.
如果仅仅是这样,大概只有 70 ~ 80 分 (取决于常数)

所以我们需要对DP进行优化

-----
### 对DP的优化

我们考虑将每次向上跳的时间复杂度变成$O(1)$的不就可以过了么?

对于一个向上跳的操作,如果它下方的位置可以被跳到,那么它一定可以由它下方的区间跳到.

#### 形象一点表示:

![DP优化](https://cdn.luogu.com.cn/upload/pic/71806.png)

因为每个点都是要遍历一次的,所以每个点只用转移它向上一次的状态,其他的可以在向前查询中得到.

这时候的动态转移方程
1. 对于向下移动

$f$ $\lbrack$ $i$ $+ $ $1$ $\rbrack$ $[$ $j$ $]$  $=$  $min$ $($ $f$ $[ $ $i$ $+$ $1$ $]$ $[$ $j$ $]$ $,$ $f$ $[$ $i$ $]$ $[$ $j$ $]$ $)$

2. 对于向上移动

$f$ $\lbrack$ $i$ $+ $ $1$ $\rbrack$ $[$ $j$ $]$  $=$  $min$ $($ $f$ $[ $ $i$ $+$ $1$ $]$ $[$ $j$ $]$ $,$ $f$ $[$ $i$ $]$ $[$ $j$ $-$ $X_{i}$ $]$ $ + $ $1$ $)$

3. 对于可以由它下方节点向上跳节点得到的位置
$f$ $\lbrack$ $i$ $+ $ $1$ $\rbrack$ $[$ $j$ $]$  $=$  $min$ $($ $f$ $[ $ $i$ $+$ $1$ $]$ $[$ $j$ $]$ $,$ $f$ $[$ $i$ $+$ $1$ $]$ $[$ $j$ $-$ $X_{i}$ $]$ $ + $ $1$ $)$

这样,每次转移的复杂度都为$O(1)$ 就可以过了.

转移代码:
```cpp
for(register int t = 0 ; t < n ; t++){
		bool flag = false,arr=false;//各个数组含义与上面相同
		if(t+1 == p[now_k].place) flag = true;
		for(register int g = 1 ; g <= m ; g++){
			if(b[t][g]){
				int dow = g-luo[t];
				if(dow > 0){
					if(flag){
						if(dow > p[now_k].l && dow < p[now_k].h){
							b[t+1][dow] = true;
							arr = true;
							f[t+1][dow] = min(f[t+1][dow],f[t][g]);
						}
					}
					else {
						b[t+1][dow] = true;
						arr = true;
						f[t+1][dow] = min(f[t+1][dow],f[t][g]);
					}
				}
				int upp = g + sheng[t];
				if(upp > m) upp = m;
				if(flag){
					if(upp > p[now_k].l && upp < p[now_k].h){
						b[t+1][upp] = true;
						arr = true;
					}
				}
				else {
					b[t+1][upp] = true;
					arr = true;
				}
				f[t+1][upp] = min(f[t+1][upp],f[t][g]+1);//可能无法到达,但仍要记录下状态
				f[t+1][upp] = min(f[t+1][upp],f[t+1][g]+1);
			}
			int under = g - sheng[t];
			if(under > 0 && f[t+1][under] != f[n+1][0]){//这里进行从下到上的判断
				if(!flag || (g > p[now_k].l && g < p[now_k].h)){
					b[t+1][g] = true;
					arr = true;
				}		
				f[t+1][g] = min(f[t+1][g],f[t+1][under]+1);
			}
			if(g == m){// 刚刚好顶着"天花板"需要特判
				for(int o = sheng[t]-1 ; o >= 0 ; o--){
					int under = g - o;
					if(under > 0 && f[t+1][under] != f[n+1][0]){
						if(!flag || (g > p[now_k].l && g < p[now_k].h)){
							b[t+1][g] = true;
							arr = true;//这是也算能够到达
						}
						f[t+1][g] = min(f[t+1][g],f[t+1][under]+1);
					}
				}
			}
		}
		if(flag) {
			if(!arr) break;
			++now_k;
		}
```

## 最后附上AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int maxn = 1e4+7;
const int maxm = 1e3+7;
struct tube{
	int l,h,place;
	bool operator < (const tube p1) const {
		return this->place < p1.place;
	}
}p[maxm];
long long read(){
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		ch = getchar(); 
	}
	long long k = ch-'0';
	while(ch=getchar(),ch <= '9' && ch >= '0'){
		k = (k<<1)+(k<<3);
		k += (ch-'0');
	} 
	return k;
}
long long luo[maxn],sheng[maxn];
int f[maxn][maxm],bbegin,eend;
bool b[maxn][maxm];
int main(){
	freopen("bird.in","r",stdin);
	freopen("bird.out","w",stdout);
	int n=read(),m=read(),k=read();
	for(register int t = 0 ; t < n  ; t++){
		sheng[t]=read();
		luo[t]=read();
	}
	for(register int t = 1 ; t <= k ; t++){
		p[t].place=read();
		p[t].l = read();
		p[t].h = read();
	}
	int now_k = min(k,1);
	sort(p+1,p+k+1);
	memset(f,127,sizeof(f));
	for(register int t = 1 ; t <= m; t++) b[0][t] = true,f[0][t]=0;
	eend = m;bbegin = 1;
	for(register int t = 0 ; t < n ; t++){
		bool flag = false,arr=false;
		if(t+1 == p[now_k].place) flag = true;
		for(register int g = 1 ; g <= m ; g++){
			if(b[t][g]){
				int dow = g-luo[t];
				if(dow > 0){
					if(flag){
						if(dow > p[now_k].l && dow < p[now_k].h){
							b[t+1][dow] = true;
							arr = true;
							f[t+1][dow] = min(f[t+1][dow],f[t][g]);
						}
					}
					else {
						b[t+1][dow] = true;
						arr = true;
						f[t+1][dow] = min(f[t+1][dow],f[t][g]);
					}
				}
				int upp = g + sheng[t];
				if(upp > m) upp = m;
				if(flag){
					if(upp > p[now_k].l && upp < p[now_k].h){
						b[t+1][upp] = true;
						arr = true;
					}
				}
				else {
					b[t+1][upp] = true;
					arr = true;
				}
				f[t+1][upp] = min(f[t+1][upp],f[t][g]+1);
				f[t+1][upp] = min(f[t+1][upp],f[t+1][g]+1);
			}
			int under = g - sheng[t];
			if(under > 0 && f[t+1][under] != f[n+1][0]){
				if(!flag || (g > p[now_k].l && g < p[now_k].h)){
					b[t+1][g] = true;
					arr = true;
				}		
				f[t+1][g] = min(f[t+1][g],f[t+1][under]+1);
			}
			if(g == m){
				for(int o = sheng[t]-1 ; o >= 0 ; o--){
					int under = g - o;
					if(under > 0 && f[t+1][under] != f[n+1][0]){
						if(!flag || (g > p[now_k].l && g < p[now_k].h)){
							b[t+1][g] = true;
							arr = true;
						}
						f[t+1][g] = min(f[t+1][g],f[t+1][under]+1);
					}
				}
			}
		}
		if(flag) {
			if(!arr) break;
			++now_k;
		}
	}
	if(now_k != 0)--now_k;
	if(now_k != k){
		printf("0\n%d",now_k);
	}
	else {
		int ans = 1e9;
		for(register int t = 1 ; t <= m ; t++){
			if(b[n][t]) ans = min(ans,f[n][t]);
		}
		printf("1\n%d",ans);
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

### 最后有一点细节
1. 对于向上不能到达的点仍需维护它的状态,因为他上方的点可能可以到达.
2. 对于向下不能到达的点就不需维护它的状态了.(不存在它能转移的点了)




---

## 作者：傅思维666 (赞：6)


## 题解：

[博客阅读更好体验](https://www.cnblogs.com/fusiwei/p/11792771.html)

一道混合背包的好题。

如果对简单背包（0/1背包，完全背包，多重背包，混合背包）还不是很了解的小伙伴请戳这里：

[背包九讲—简单背包]( https://www.cnblogs.com/fusiwei/p/11544682.html )

有了这些基础知识，我们来分析问题：

其实一开始看题也挺蒙圈的，但是注意到了一句话：效果可以叠加。那脑子里就突然闪过一道光：既然可以叠加，那就相当于任意多物品选几件呗！背包啊！

正解的方向出来了。

因为题目中要求的是走到终点最少点击屏幕多少次，那么我们以此定义状态：$dp[i][j]$表示走到$i$处（即横坐标为$i$）、高度为$j$的时候，需要最少的点击量（点击量...）。

那么，向上跳就是完全背包的转移过程，向下落就是01背包的转移过程。

另外要注意，超过$m$的时候要特判，根据这个性质：**数组的$m$要开二倍！**即$2000$级别。

那么状态转移方程即为：
$$
dp[i][j]=\min(dp[i][j-x[i]]+1,dp[i-1][j-x[i]]+1)
$$
这个方程是完全背包的方程（当前位置跳和上一个位置跳）
$$
dp[i][m]=\min(dp[i][m],dp[i][j])
$$
这个方程是$m$溢出的特判。
$$
dp[i][j]=\min(dp[i][j],dp[i-1][j+y[i]])
$$
这个方程是0/1背包的方程（跳还是不跳）

因为是向下跳，所以在选择跳的时候，第二维应该加上$y[i]$。

统计答案的过程就是一个特判加标记的过程，在此不加赘述，请自行参看蒟蒻代码进行解决：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e4+10;
const int maxm=1010*2;
int n,m,k,ans;
int x[maxn],y[maxn],up[maxn],down[maxn];
bool flag[maxn],q;
int dp[maxn][maxm];
//dp[i][j]表示横坐标为i时高度为j时的最小点击次数。
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<48){if(ch=='-')f=-1;ch=nc();}
    while(ch>47)    x=(((x<<2)+x)<<1)+ch-48,ch=nc();
    return x*f;
}
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
    {
        x[i]=read();y[i]=read();
        down[i]=1;
        up[i]=m;
    }
    for(int i=1;i<=k;i++)
    {
        int a,b,c;
        a=read(),b=read(),c=read();
        flag[a]=1;
        up[a]=c-1;
        down[a]=b+1;
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i<=m;i++)
        dp[0][i]=0;
    //dp[i][j]表示横坐标为i时高度为j时的最小点击次数。
    for(int i=1;i<=n;i++)
    {
        for(int j=1+x[i];j<=m+x[i];j++)
            dp[i][j]=min(dp[i][j-x[i]]+1,dp[i-1][j-x[i]]+1);
        for(int j=m+1;j<=m+x[i];j++)
            dp[i][m]=min(dp[i][m],dp[i][j]);
        for(int j=1;j<=m-y[i];j++)
            dp[i][j]=min(dp[i][j],dp[i-1][j+y[i]]);
        for(int j=1;j<=down[i]-1;j++)
            dp[i][j]=dp[0][0];
        for(int j=up[i]+1;j<=m;j++)
            dp[i][j]=dp[0][0];
    }
    ans=dp[0][0];
    for(int i=1;i<=m;i++)
        ans=min(ans,dp[n][i]);
    if(ans<dp[0][0])
    {
        printf("1\n%d",ans);
        return 0;
    }
    else
    {
        int i;
        for(i=n;i>=1;i--)
        {
            for(int j=1;j<=m;j++)
                if(dp[i][j]<dp[0][0])
                {
                    q=1;
                    break;
                }
            if(q)
                break;
        }
        ans=0;
        for(int j=1;j<=i;j++)
            if(flag[j])
                ans++;
        printf("0\n%d",ans);
        return 0;
    }
}
```



---

## 作者：qhr2023 (赞：5)

## solution

一道感觉很牛的背包 dp。

设 $f_{i, j}$ 表示到横坐标为 $i$ 高度为 $j$ 的位置的最少点击次数，初始化极大值，因为可以在任意高度出发，所以横坐标为 $0$ 的部分初始化 $0$，然后分类转移。

* 下降到当前位置，类似 01 背包，$f_{i, j}=\min(f_{i,j}, f_{i-1, j+y_{i-1}})$，转移时注意高度上界，要保证 $j+y_{i-1} \le m$，否则不可能下降过来。
* 上升到当前位置，且 $1<j<m$，类似多重背包，枚举上一次的点击次数 $k$，$f_{i, j}=\min(f_{i, j}, f_{i-1, j - k \times x_{i-1}} +k)$，因为题目要求不能在横坐标为 $0$ 的位置，所以保证 $j - k \times x_{i-1} > 1$。
* 上升到当前位置，且 $j=m$，题目说上升到 $m$ 时会卡在这，所以它可以从横坐标 $i-1$ 的任意高度转移。

这个时间复杂度是 $O(nm^2)$ 的，考虑优化。

![](https://cdn.luogu.com.cn/upload/image_hosting/yi58l9ng.png)

如图，蓝色点即横坐标为 $i$ 高度为 $j$ 的位置，它正下面的红色点高度是 $j-x_{i-1}$。

发现瓶颈在上升部分。转移 $f_{i, j}$ 时要计算蓝线部分，转移 $f_{i, j-x_{i-1}}$ 时要计算红线部分，发现红蓝有大部分重叠，就说明重叠部分我们已经在 $f_{i, j-x_{i-1}}$ 计算过了，没必要重复算了，这样只用计算点一次升上来的贡献即可，对于重叠部分，点 $k$ 次升到 $j-x_{i-1}$，那么点 $k+1$ 次就升到 $j$，所以重叠部分可以由横坐标为 $i$，高度 $j-x_{i-1}$ 转移。

转移：$f_{i, j}=\min(f_{i, j}, f_{i-1, j-x_{i-1}}+1, f_{i, j-x_{i-1}}+1)$，如下图。

$j=m$ 时也是类似的，可以是点一次升上来，也可以点多次，$f_{i, m}=\min(f_{i, m}, f_{i-1, j}+1, f_{i, j}+1)$，这里的 $j$ 是下图中蓝点下面的红点的高度，所以注意 $m-x_{i-1} \le j \le m$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kvbczgu9.png)

最后，我们需要将管道部分都设为极大值，因为无法到达，同时记录答案，当在横坐标为 $i$ 时答案为我们设的极大值，说明无法到达。实现时要注意枚举范围等细节。

另外[这里](https://www.luogu.com.cn/article/h9glwqs9)有数学推导的方式说明优化，可以参考一下。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, x[10005], y[10005], l[10005], h[10005], p[10005], f[10005][1005], ans, cnt;
int main() {
	cin >> n >> m >> k;
	for (int i=0; i<n; ++i) 
		cin >> x[i] >> y[i];
	for (int x; k--; p[x]=1) 
		cin >> x, cin >> l[x] >> h[x];
	memset(f, 0x3f, sizeof f);
	memset(f[0], 0, sizeof f[0]);
	for (int i=1; i<=n&&ans<1e9; ++i) {
		for (int j=x[i-1]+1; j<=m; ++j)
			f[i][j]=min({f[i][j], f[i-1][j-x[i-1]]+1, f[i][j-x[i-1]]+1});
		for (int j=m-x[i-1]; j<=m; ++j)
			f[i][m]=min({f[i][m], f[i-1][j]+1, f[i][j]+1});
		for (int j=1; j<=m-y[i-1]; ++j)
			f[i][j]=min(f[i][j], f[i-1][j+y[i-1]]);
		if (p[i]) {
			for (int j=1; j<=l[i]; f[i][j++]=1e9) ;
			for (int j=h[i]; j<=m; f[i][j++]=1e9) ;
			cnt++;
		}
		ans=1e9;
		for (int j=1; j<=m; ++j)
			ans=min(ans, f[i][j]);
	}
	if (ans==1e9) cout << "0\n" << cnt-1;
	else cout << "1\n" << ans;
	return 0;
}
```

---

## 作者：RikoHere (赞：4)

~~没人写压维我凑个数~~

数据范围$n\leqslant 10,000, m \leqslant 1,000$，写$O(nm)$的背包完全是可以通过本题的。对于上升是一个完全背包，对于下降是一个01背包，则有

$$f[i][j] = min(f[i-1][j-x[i-1]]+1, f[i][j-x[i-1]]+1, f[i-1][j+y[i-1]])$$

如何实现别的题解说明的很清楚我也不再赘述

同学都知道一般背包是有压维写法的，数组大小开到$10,000*1,000$怎么说都有点勉强~~并不勉强只是想优化~~，来考虑一下压维要实现的一些细节，压维以后的方程式是这样的

$$f[j] = min(f[j-x[i-1]]+1, f[j+y[i-1]])$$

而对于$f[j-x[i-1]]$实际上包含的是两个状态,分别是$f[i-1][j-x[i-1]]$和$f[i][j-x[i-1]]$所以可以新建两个辅助数组，分别存下两个状态，最后结果要在两个中间取

至于枚举顺序就像完全背包一样从小到大枚举就行枚举到$j$时$f[j+y[i-1]]$存的状态$f[i-1][j+y[i-1]]$所以并不需要拿数组暂存

$$f_1[j] = min(f_1[j-x[i-1]]+1, f[j-x[i-1]]+1)$$

$$f_2[j] = f[j+y[i-1]]$$

$$f[j]=min(f_1[j], f_2[j])$$

对于$f_1$表示该高度由跳跃而来的最小步数,对于$f_2$表示由降落而来的最小步数

这样就成功的把时间复杂度为$O(nm)$的空间复杂度优化为$O(m)$

```

//2019/2/2->NHDR233->AtHM->luoguP1941
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<time.h>
using namespace std;
inline int in() {
    int x = 0, ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x*10+ch-'0', ch = getchar();
    return x;
}
void input();
void smin(int& x, int y) {
    if (x > y) x = y;
}

const int TOP = 10100, INF = 1e9;
int n, m, k;
int x[TOP], y[TOP<<1], ans[TOP<<1], tem1[TOP], tem2[TOP];
struct node{
    int where, down, top;
} s[TOP];
bool cmp(node a, node b) {
    return a.where < b.where;
}

void work() {
    sort(s+1, s+k+1, cmp);
    int now = 1;
    for (int i = m+1; i <= 2*m; ++i) ans[i] = INF;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= 2*m; ++j) 
            tem1[j] = ans[j];
        bool flag = false;
        for (int j = 1; j <= m; ++j) {
        	tem2[j] = INF;
            if (j > x[i-1]) {
                smin(tem2[j], tem1[j-x[i-1]]+1);
                smin(tem2[j], tem2[j-x[i-1]]+1); 
            }
			ans[j] = min(tem2[j], tem1[j+y[i-1]]);
        }
        for (int j = 0; j <= x[i-1]; ++j) {
            smin(ans[m], tem1[m-j]+1);
            smin(ans[m], tem2[m-j]+1);
		}
        if (s[now].where == i) {
            for (int j = 1; j <= m; ++j) {
                if (j > s[now].down and j < s[now].top) continue;
                ans[j] = INF;
            }
            now++;
        }
        for (int j = 1; j <= m; ++j) {
            if (ans[j] < INF) flag = true;
        }
        if (!flag) {
            printf("0\n%d", now-2);
            return;
        }
    }
    int final = INF;
    for (int i = 1; i <= m; ++i) {
        smin(final, ans[i]);
    }
    printf("1\n%d", final);
}
int main() {
    input();
    work();
}
void input() {
    n = in(); m = in(); k = in();
    for (int i = 0; i < n; ++i) {
        x[i] = in(); y[i] = in();
    }
    for (int i = 1; i <= k; ++i) {
        s[i].where = in();
        s[i].down = in();
        s[i].top = in();
    }
}

```

---

## 作者：ZJYelizaveta (赞：3)

### 描述


Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。

为了简化问题，我们对游戏规则进行了简化和改编:


1. 游戏界面是一个长为 $n$ ，高为 $m$ 的二维平面，其中有 $k$ 个管道（忽略管道的宽度）。

2. 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。

3. 小鸟每个单位时间沿横坐标方向右移的距离为 $1$ ，竖直移动的距离由玩家控制。如

果点击屏幕，小鸟就会上升一定高度 $X$ ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $Y$。小鸟位于横坐标方向不同位置时，上升的高度 $X$ 和下降的高度 $Y$ 可能互不相同。

4. 小鸟高度等于 $0$ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $m$ 时，无法再上升。


现在，请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟

最多可以通过多少个管道缝隙。


$5 \leq n \leq 10000, 5 \leq m \leq 1000, 0 \leq k<n, 0<X<m, 0<Y<m, 0<P<n, 0 \leq L<H  ≤m,L +1<H$


### 分析


搜索 + 剪枝，动态规划 + 优化这两种方法都是可以过这道题目的。


令 $dp[i][j]$ 为横坐标到 $i$ ，纵坐标到 $j$ 所需的最少点击数。


上升高度因为可以点击多次所以可以看做是做“完全背包”，而下降则相当于做“01 背包”。


这样一来我们有一个很见到的 $\Theta(nm^{2})$ 的转移方程：

$$
```cpp
dp[i][j] = \left\{\begin{matrix}
\underset{k}{min}(dp[i - 1][j - k \times x[i - 1]])& (j - k \times x[i - 1] > 0) \\ 
dp[i - 1][j + y[i - 1]]& (j + y[i - 1] \leq m) 
\end{matrix}\right.
```
$$
这个转移方程每次状态转移的时间复杂度为 $\Theta(m)$ ，那么如何每次状态转移的时间复杂度呢？


考虑“点击 $k - 1$ 次”和“点击 $k$ 次”之间的关联。


如果到达点 $[i, j]$ 最少点击数为 $k$ ，那么也就是说点击 $k - 1$ 可以到达 $[i, j - x[i - 1]]$ 。那么在只考虑上升的情况下，转移方程可以优化为：

$$
dp[i][j] = min(dp[i][j], min(dp[i - 1][j - x[i - 1]] + 1, dp[i][j - x[i - 1]] + 1));

$$
这样我们就可以 $\Theta(1)$ 转移啦qwq


这里要注意一点，就是我们肯定要判断上升和下降是否接触到边界，也就是将边界标记为 $dp[pos][low] = \textrm{INF}, dp[pos][high] = \textrm{INF}$ ，这里把判断要放在最后。因为有一种情况，即点击 $k - 1$ 次会到达管道最下方，但是点击 $k$ 次并不会触碰到管道，因为点击 $k$ 次由点击 $k - 1$ 次转移而来，所以这里将判断放在最后面。


然后上升的时候，因为不管怎么上升最高高度只会为 $m$ 所以这里要拎出来单独计算。


总时间复杂度 $\Theta(nm)$ 。


### 代码


```cpp
//  Created by ZJYelizaveta on Wednesday, October 25, 2017 AM10:45:41 CST
//  Copyright (c) 2017年 ZJYelizaveta. All rights reserved.

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
template<typename T> T readIn() {
    T x(0), f(1);
    char ch = getchar();
    while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}
const int MAX_N = 10000 + 3;
const int MAX_M = 1000 + 3;
const int INF = 0x3f3f3f3f;
int n, m, k;
int x[MAX_N], y[MAX_N];
struct Pipe {
    int flag, low, high;
}a[MAX_N];
int dp[MAX_N][MAX_M];
int ans;

int main()
{
    n = readIn<int>(), m = readIn<int>(), k = readIn<int>();
    for (int i = 0; i < n; ++i) x[i] = readIn<int>(), y[i] = readIn<int>();

    for (int i = 1; i <= k; ++i) {
        int x = readIn<int>(); a[x].flag = true;
        a[x].low = readIn<int>(), a[x].high = readIn<int>();
    }

    dp[0][0] = INF;
    for (int i = 1; i <= n; ++i) {
        dp[i][0] = INF;
        for (int j = 1; j < m; ++j) {
            dp[i][j] = INF;

            if (j - x[i - 1] > 0) {  //  clicks
                if (dp[i - 1][j - x[i - 1]] != INF) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - x[i - 1]] + 1);
                }
                if (dp[i][j - x[i - 1]] != INF) {
                    dp[i][j] = min(dp[i][j], dp[i][j - x[i - 1]] + 1);
                }
            }
        }

        for (int j = 1; j <= m - y[i - 1]; ++j) {  //  down
            if (dp[i - 1][j + y[i - 1]] != INF) dp[i][j] = min(dp[i][j], dp[i - 1][j + y[i - 1]]);
        }

        dp[i][m] = INF;
        for (int j = m - x[i - 1]; j <= m; ++j) {  //  Edge
            if (dp[i - 1][j] != INF) dp[i][m] = min(dp[i][m], dp[i - 1][j] + 1);
            if (dp[i][j] != INF) dp[i][m] = min(dp[i][m], dp[i][j] + 1);
        }

        if (a[i].flag) {  //  check
            for (int j = 1; j <= m; ++j) if (j <= a[i].low || j >= a[i].high) dp[i][j] = INF;
        }  //
    }

    ans = INF;
    for (int i = 1; i <= m; ++i) ans = min(ans, dp[n][i]);
    
    if (ans != INF) {
        printf("1\n%d\n", ans);
    }
    else {
        int pos = -INF;
        for (int i = n - 1; i >= 0; --i) {
            for (int j = 1; j <= m; ++j) {
                if (dp[i][j] != INF) {
                    pos = i; break;
                }
            }
            if (pos != -INF) break;
        }
//        printf("%d\n", pos);

        int cnt = 0;
        for (int i = 1; i <= pos; ++i) if (a[i].flag) ++cnt;

        printf("0\n%d\n", cnt);
    }
    return 0;
}
```

---

## 作者：Noah03 (赞：2)

### 分析

---

我们可以用 $dp_{i,j}$ 来表示到横坐标为 $i$，纵坐标为 $j$ 的最小点击屏幕的次数。依据题意，每次纵坐标可能会上升 $x$ 或下降 $y$，横坐标每次可能不变或增加 $1$。那就有四种情况：

1. 从 $dp_{i,j-x_i}$ 转移到 $dp_{i,j}$；

2. 从 $dp_{i-1,j-x_i}$ 转移到 $dp_{i,j}$；

3. 从 $dp_{i,j+y_i}$ 转移到 $dp_{i,j}$；

4. 从 $dp_{i-1,j+y_i}$ 转移到 $dp_{i,j}$。

那么我们可以发现内存为 $1 \times 10^4 \times 2 \times 10^3=2 \times 10^7$，有点卡内存，可以发现每次的 $dp_{i,j}$ 中我们使用到的只有 $i$ 和 $i-1$，所以第一维可以压成 $i \bmod 2$（即 C++ 中的 `i&1`)。

对于管道的坐标，我们可以用类型为 `pair<int,int>` 的 $p$ 数组代替。$p$ 数组第一位表示下边沿高度，第二位表示上边沿高度。

判断无解可以按以下步骤进行：

我们用 $cnt$ 来记录已通过的管道缝隙数量（一开始，$cnt$ 为 $0$）。

当 $p_i$ 没有被记录过时，枚举每个 $j(0 \le j \le m)$，如果说 $j$ 不在上边沿也不在下边沿，说明撞到了管道，将 $dp_{i \bmod 2,j}$ 赋值为 $10^{18}$；否则，如果说 $dp_{i \bmod 2,j}$ 不为 $10^{18}$ 的话，就说明有解。如果遍历完所有的 $j$ 后，还没有找到有解的情况，说明无解，输出 $0$ 和 $cnt$，并结束程序。

最后，遍历所有的 $i(0 \le i \le m)$，答案即为 $\min\{dp_{n \bmod 2,i}\}$。

### 代码

---

**请勿抄袭。**

本题坑点：

1. 数组第二维要开到 $2 \times 10^3$，不然第 $13$ 个测试点会 RE 或者 WA。

2. 数组初始值一定要设大一点，如果设 $10^{12}$ 就会在第 $2$ 个测试点 WA。 

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int,int> PII;
const int MAXN=2e4+10,MAXM=2e3+10;
int x[MAXN],y[MAXN],dp[2][MAXM];
PII p[MAXN];
signed main(){
	int n,m,k;
	scanf("%lld %lld %lld",&n,&m,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld %lld",&x[i],&y[i]);
	}
	for(int i=1;i<=k;i++){
		int a,b,c;
		scanf("%lld %lld %lld",&a,&b,&c);
		p[a]={b,c};	
	}
	int cnt=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++) dp[i&1][j]=1e18; 
		for(int j=x[i]+1;j<=x[i]+m;j++) dp[i&1][j]=min(dp[!(i&1)][j-x[i]],dp[i&1][j-x[i]])+1;
		for(int j=m+1;j<=x[i]+m;j++) dp[i&1][m]=min(dp[i&1][m],dp[i&1][j]);
		for(int j=1;j<=m-y[i];j++){
			dp[i&1][j]=min(dp[i&1][j],dp[!(i&1)][j+y[i]]);
		}
		if (p[i]!=(PII){0,0}){
			bool flag=false;
			for(int j=0;j<=m;j++){
				if (j<=p[i].first||j>=p[i].second) dp[i&1][j]=1e18;
				else if (dp[i&1][j]!=1e18) flag=true;
			}
			if (!flag) return puts("0"),printf("%lld\n",cnt)&0;
			cnt++;
		}
	}
	puts("1");
	int ans=1e18;
	for(int i=0;i<=m;i++) ans=min(ans,dp[n&1][i]);
	printf("%lld\n",ans);
	return 0;
}
```

代码时间复杂度为 $O(n \times m)$。

**The End.**

---

## 作者：PengDave (赞：2)

# solution
考虑 dp。阶段和状态比较好想，我们以到达的横坐标为阶段，定义 $dp_{i,j}$ 为到坐标 $(i,j)$ 的所需要的最少点击屏幕次数。

接下来考虑怎么转移，如果点击屏幕次数不为 $0$，那么如果是点击一次，那么就是 $dp_{i-1,j-x_{i-1}}+1$，而如果不止一次的话，其实我们只需要在同一横坐标高度相差为 $x_{i-1}$ 的 $dp$ 值加一。如果点击屏幕次数为 $0$，那么容易得到转移方程 $dp_{i,j}=\min{dp_{i,j},dp_{i-1,j+y_{i-1}}}$。几种情况结合起来就是 $dp_{i,j}=\min{dp_{i-1,j-x_{i-1}}+1,dp_{i,j-x_{i-1}}+1,dp_{i-1,j+y_{i-1}}}$。同时都，对于有管子遮挡的位置，我们把它们的值赋值为极大值即可。

至于最多能通过的管道数，只需要找到最后一个仍有可以到的点的管子所在的横坐标即可。
# code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int dp[10010][2010];
int x[10010],y[10010];
bool av[10010][2010];//当前点是否没有管子遮挡
int cnt[10010];//前缀和记录当前横坐标即以前一共的管子数
int main(){
	memset(dp,0x3f,sizeof(dp));
	cin.tie(0);
	ios::sync_with_stdio(false);
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=0;i<n;i++){
		cin>>x[i]>>y[i];
	}
    memset(av,1,sizeof(av));
	for(int i=1;i<=k;i++){
		int p,l,h;
		cin>>p>>l>>h;
		cnt[p]++;
		for(int j=0;j<=l;j++){
			av[p][j]=0;
		}
		for(int j=h;j<=m;j++){
			av[p][j]=0;
		}
	}
	for(int i=1;i<=n;i++){
		cnt[i]+=cnt[i-1];
	}
	for(int j=1;j<=m;j++){
		if(av[0][j]){
			dp[0][j]=0;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=x[i-1]+1;j<=m+x[i-1];j++){
            dp[i][j]=min({dp[i][j],dp[i-1][j-x[i-1]]+1,dp[i][j-x[i-1]]+1});
        }
        for(int j=m+1;j<=m+x[i-1];j++){ //大于m的就是m的
            dp[i][m]=min(dp[i][m],dp[i][j]);
        }
        for(int j=1;j+y[i-1]<=m;j++){
            dp[i][j]=min(dp[i][j],dp[i-1][j+y[i-1]]);
        }
        for(int j=1;j<=m;j++){
            if(!av[i][j])dp[i][j]=0x3f3f3f3f;
        }
	}
	int ans=0x3f3f3f3f;
	for(int i=1;i<=m;i++){
		if(av[n][i])ans=min(ans,dp[n][i]);
	}
	if(ans!=0x3f3f3f3f){
		cout<<1<<endl<<ans<<endl;
	}else{
		cout<<0<<endl;
		for(int i=n;i>=0;i--){
			if(*min_element(dp[i]+1,dp[i]+1+m)!=0x3f3f3f3f){
				cout<<cnt[i]<<endl;
				return 0;
			}
		}
		cout<<0<<endl;
	}
	return 0;
}
```

---

## 作者：pengzhining (赞：1)

## 题意理解

审题，题目让你在一张有限制的图上求到达最左端的最小方案数，二维且数据太大 DFS 会爆，BFS 我不清楚，贪心思路明显不可能，剩下的只有 DP 了，但这道题的状态是不太固定的。

如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/0w8pl761.png)

这个状态一会是 01（上升 or 下降），一会是完全（上升 $1$ 次，上升 $k$ 次，上升 $n$ 次），而且上升还有变化（**小鸟高度为 $m$ 时，无法再上升**），这样该如何处理，先分析一下，设 $f_{i,j}$ 为坐标在 $(x,y)$ 的最小点击数，就可以分析出下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/290qmwqj.png)

$ f_{i,j}=\max(f_{i-1,j+y_{i-1}},f_{i-1,j-k\times x_{i-1}}+1,f_{i,j-k\times x_i}+1)$

感觉可以打代码了，但如果我们回头看了看方程也许感觉复杂度有点问题（也可能是你 70pts 时重新看了一眼状态计算）。

**欸，这个 $k$ 是不是可以优化掉？**

我们回想推方程的步骤，如果上升的话，$f_{i,j}$ 可以从哪里转移过来？

从前一列转移过来，或者从本列转移过来。

那我们岂不是有状态算重了？$f_{i,j-k \times y_{i}}$ 岂不是可以从 $f_{i,{j-(k-1)} \times y_{i}}$ 转移过来？那复杂度是不是可以降下来？

根据以上推测，我们可以得出一个新的状态计算。

![](https://cdn.luogu.com.cn/upload/image_hosting/bll0la9f.png)

$ f_{i,j}=\max(f_{i-1,j+y_{i-1}},f_{i-1,j-x_{i-1}}+1,f_{i,j-x_i}+1)$

这个时候就要处理题目的其他限制了。
- 首先，我们要处理 DP 的先后顺序，考虑到上升后就不会下降，我们应优先处理上升，否则会导致处理上升时把下降部分覆盖掉。
- 其次，还需要处理管道，我采取先记录路径，本列循环最后再将有管道的地方赋值为最大值，这样避免了随时判断是否违法的麻烦。
- 最后，关于上升溢出，我们可以加入一个特判，这三点在代码中有注释。

这个时候看一下复杂度貌似 $O(MN)$（雾），可以通过此题。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;
int n,m,k,a[100000],d[10010][3010],x[100000],y[100000],ans[100000];
bool h[100000];
struct node{
    int x,s,e;
}g[10000]; //记录水管
bool cmp(node a,node b){
    return a.x<b.x;
}
int main(){
    memset(d,0,sizeof d);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<n;i++){
        scanf("%d%d",&x[i],&y[i]);
    }
    for(int i=1;i<=k;i++){
        cin>>g[i].x;
        cin>>g[g[i].x].s>>g[g[i].x].e;
        h[g[i].x]=1;
    }
    for(int i=0;i<=m;i++){//初始化
        d[0][i]=0;
    }
    for(int i=1;i<=n;i++){      //dp开始
        ans[i]=INF;
        for(int j=0;j<=m;j++) d[i][j]=INF;//初始化
        for(int j=x[i-1]+1;j<m;j++){
            d[i][j]=min(d[i][j],min(d[i-1][j-x[i-1]],d[i][j-x[i-1]])+1);  //先做上升，上升不可以与下降同时进行
        }
        for(int j=m-x[i-1];j<=m;j++){
            d[i][m]=min(d[i][m],min(d[i-1][j],d[i][j])+1);      //特判上升大于m的(到m后便不会上升)
        }
        for(int j=1;j+y[i-1]<=m;j++){
            d[i][j]=min(d[i][j],d[i-1][j+y[i-1]]);      //最后处理下降(上升不会影响下降，但下降会影响上升)
        }
        if(h[i]){       //如果有管道
            for(int j=1;j<=g[i].s;j++){//将有管道的地方全部标记
                d[i][j]=INF;
            }
            for(int j=g[i].e;j<=m;j++){
                d[i][j]=INF;
            }
        }
        for(int j=1;j<=m;j++) ans[i]=min(ans[i],d[i][j]);//寻找当前列最小值
        if(ans[i]==INF){//若最小值仍为INF则该区域不可通过
            int as=0;
            for(int j=1;j<=i;j++) if(h[j]) as++;
            cout<<0<<endl<<as-1;
            return 0;
        }
    }
    cout<<1<<endl<<ans[n];
    return 0;
}
```
[AC](https://www.luogu.com.cn/record/199467058) 。

---

## 作者：guoshengyu1231 (赞：1)

# 题意简述
玩过这个游戏的人应该很容易理解，但在这里我还是简单的复述一遍吧。有一个长为 $n$ 高为 $m$ 的网格。一只小鸟可以从第 $0$ 列的任意一个高度上的**点**起飞。之后小鸟每当位于第 $i$ 列，他可以选择飞或不飞，如果飞，它的高度增加 $up_i$，如果不飞，则下降 $down_i$，然后小鸟来到下一列。至于要输出什么，详见原题输出格式。 $\\$ 
当满足以下条件，游戏失败。

1. 小鸟的高度为 $0$。
2. 小鸟的位置上有障碍物（详见原题）。

当小鸟来到来到最后一列，游戏成功。
# 注意事项
1. 小鸟在同一列内可以飞多次，效果叠加。
2. 高度到达 $m$ 时不在上升。
3. 障碍物位置不按顺序输入。
4. 在输入障碍物的信息时，障碍物的两个信息 $l$ 和 $h$ 的意思是这一列中高度在区间 $[0,l]$ 和区间 $[h,m]$ 的位置有障碍物。
# 思路
作为一道绿题，还是有点难度的。但越是有难度的题，我们的思路就要越清晰。很明显这题应该使用动态规划，而且状态应该是每个点的坐标。那我们接下来应该就要思考如何转移状态了。
## 状态转移
假设同一列内只能飞一次，也就是要么飞要么不飞，那我们应该能很容易推断出状态转移方程。你想啊，在每一列中只能飞或不飞，如果飞就飞上去呗，不飞就掉下来呗。那想要到达一个点就要么是飞上来的，要么是掉下来的。设 $dp_{i,j}$ 表示到达第 $i$ 列第 $j$ 行的位置需要飞多少次，那状态转移方程不就出来吗。$\\$
状态转移方程：
 $$dp_{i,j}=\min(dp_{i-1,j-up_{i-1}}+1,dp_{i-1,j-down_{i-1}})$$ 
但接下来还有面临一个棘手的问题，那就是小鸟可以在同一列内飞多次，效果还会叠加。那我们接下来就应该思考怎样才能考虑到这一点。如果只是为了解决这一点，考虑到是在同一列的，也可以轻松写出状态转移方程：
 $$dp_{i,j}=\min(dp_{i,j},dp_{i,j-up_{i-1}}+1)$$
即在同一列内再飞一次。

 $\\$ 
 
但是问题又来了，在飞一次的前提是前一个点一定得是飞上来的。可能目前为止你们还有些没有听懂，那我就发个图来加深一下理解吧。请看图：
![](https://pic1.imgdb.cn/item/67ed28bc0ba3d5a1d7eb1199.jpg)
如图，点 $3$ 可以从点 $1$ 飞上去，而点 $4$ 和点 $3$ 在同一列。所以点 $4$ 从点 $3$ 飞上去，就等价于从点 $1$ 飞两次飞上去。但我们不能保证点 $3$ 可能是从点 $2$ 掉下去的。如果点 $3$ 是从点 $2$ 掉下去的，那就变成了从点 $2$ 掉下去有飞了一下到达点 $4$。这在题目中显然是不允许的。
 
$\\$ 

那如何避免这种情况呢？既然这个转移他需要他前面那个点是飞上来的，那我们干脆就先考虑这个状态的点是前一个飞上去的，此时是从前一个点掉下来的情况我们根本就还没考虑，那我们就可以放心大胆的计算了。

$\\$

具体的，刚才那张图，点 $3$ 的转移是不确定的，他可能是飞上去的，也可能是掉下来的，那么第一轮的转移我们就先考虑这些点都是飞上来的。那么在第一轮的转移中，点 $3$ 转移后就是点 $4$ 了。但是此时点 $3$ 只连接了点 $1$ 的转移，那点 $4$ 在判断的时候只能追踪到点 $1$，因为此时点 $3$ 和点 $2$ 之间没有转移关系。接着在进行第二次转移，也就是考虑从上一个点掉下来的可能，并与原先答案取最小值，并更新答案。

 $\\$ 

对了，还有一点，别忘记初始化为无穷大！
## 考虑障碍物
现在又有一个叫作“管道”的障碍物，所以需要在这加一个特判。

 $\\$

在输入障碍物时就先将障碍物按列排序，在枚举列的时候判断如果这列有障碍物，那么就执行以下操作：
1. 枚举第 $i$ 列的全部点，如果这个点内有障碍物，那么就将 $dp_{i,j}$ 设为无穷大。
2. 判断 $dp_{i,j}$，如果这一列的所有点都无法到达，说明游戏已经失败，此时输出当前已经遍历的管道数减 $1$（因为无法通过第 $i$ 个障碍物其实是说明最多只能通过 $i-1$ 个障碍物）。

$\\$
具体的，枚举 $j\in[1,m]$，如果 $\forall dp_{i,j}$ 都为无穷大，说明不可能过这一列，那游戏就失败了。

 $\\$ 

还有一点，如果游戏顺利通关，那最终答案就为 $i\in[1,m],\min\{dp_{n,i}\}$。
## 优化
1. 由于第 $i$ 列的状态只和第 $i-1$ 列有关，所以可以滚动数组优化。
2. 因为每次转移 $dp_i$ 时都需要的只是 $up_{i-1}$，所以干脆就将 $up_i$ 的意义代替原来的 $up_{i-1}$。（ $down$ 数组也一样）

---

## 作者：CommandSR (赞：1)

## 题意简述

小鸟横轴移动，每单位时间右移 $1$ 格。玩家可点击屏幕使小鸟上升 $x_i$ 高度（可多次点击叠加），不点击则下降 $y_i$ 高度。需从最左端飞到最右端，避开所有管道（管道有上下边界）。求能否完成游戏，若能则输出最少点击次数，否则输出最多通过管道数。

## 基本思路

### 70pts DP

一眼动态规划，不妨令 $f_{i, j}$ 为到横坐标为 $i$ 当前高度为 $j$ 的最小点击次数，若无法达到则为 $inf$。

若当前坐标不点击，则有：

```cpp
if (check(i+1, j-ty[i]) && j-ty[i] > 0)
    f[i+1][j-ty[i]] = min(f[i+1][j-ty[i]], f[i][j])
```

若当前坐标点击屏幕，则有：

```cpp
for (int t = 1; t <= m; t++) {
    if (check(i+1, min(j+tx[i]*t, m)))
        f[i+1][min(j+tx[i]*t, m)] = min(f[i+1][min(j+tx[i]*t, m)], f[i][j] + t);
}
```

注意向上移动可以移动多次，且向上跳不能超出边界 $m$，但可以跳一半顶在最大高度 $m$ 上。

且注意判断用于转移的状态合法，即不超出边界，不碰到管道。

可以写出如下代码：

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define F(i, a, b) for (int i = a; i <= b; i++)
#define _F(i, a, b) for (int i = a; i >= b; i--)
#define int long long
#define inf 1e14
using namespace std;
int rd() {
	int p = 0, f = 1;
	char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 10010, M = 1010;
int n, m, k, tx[N], ty[N];
struct node {
	int x, dn, up;
} p[N];
bool cmp(node u, node v) {
	return u.x < v.x;
}
int f[N][M], pup[N], pdown[N];
bool check(int x, int y) {
	if (y > m || y <= 0) return 0;
	if (!x) return 1;
	if (y >= pup[x] || y <= pdown[x]) return 0;
	return 1;
}
signed main() {
	F(i, 0, N-2) F(j, 0, M-2) f[i][j] = inf, pup[i] = inf;
	n = rd(), m = rd(), k = rd();
	F(i, 0, n-1) tx[i] = rd(), ty[i] = rd();
	F(i, 1, k) p[i].x = rd(), p[i].dn = rd(), p[i].up = rd();
	sort(p + 1, p + 1 + k, cmp);
	F(i, 1, k) pup[p[i].x] = min(pup[p[i].x], p[i].up), pdown[p[i].x] = max(pdown[p[i].x], p[i].dn);
	F(i, 1, m) f[0][i] = 0;
	int ans = inf;
	F(i, 0, n-1) {
		_F(j, m, 1) {
			if (!check(i, j)) continue ;
			if (check(i+1, j-ty[i]) && j-ty[i] > 0) f[i+1][j-ty[i]] = min(f[i+1][j-ty[i]], f[i][j]);
			F(t, 1, m) {
				if (check(i+1, min(j+tx[i]*t, m))) f[i+1][min(j+tx[i]*t, m)] = min(f[i+1][min(j+tx[i]*t, m)], f[i][j] + t);
			}
		}
	}
	F(j, 1, m) ans = min(ans, f[n][j]);
	if (ans == inf) {
		cout << 0 << '\n';
		bool flag = false; int pos = n;
		F(i, 1, n) {
			flag = 0;
			F(j, 1, m) if (f[i][j] != inf) flag = 1;
			if (!flag) {
				pos = i-1;
				break ;
			}
		}
		int cnt = 0;
		F(i, 1, k) {
			if (p[i].x <= pos) ++cnt;
		}
		cout << cnt << '\n';
	} else {
		cout << 1 << '\n' << ans << '\n';
	}
	return 0;
}
```

时间复杂度 $O(n \times m^2)$，预计 70pts。

### 100pts DP

上述 dp 时间复杂度瓶颈在于枚举向上跳的次数 $t$。

对于上面的 $dp$，我们是这样转移的：

![](https://cdn.luogu.com.cn/upload/image_hosting/j7kz4ip1.png)

即 $f_{i,j}$ 转移到 $f_{i+1, j+t \times x_i}$。

不妨转换视角，看成这样转移：

![](https://cdn.luogu.com.cn/upload/image_hosting/qzcc2m27.png)

先从 $f_{i,j}$ 转移到 $f_{i+1, j+x_i}$ 对应第一个箭头。

在从 $f_{i+1,j}$ 转移到 $f_{i+1, j+x_i}$ 对应第上面的纵向箭头。

省去枚举 $t$，时间复杂度 $O(n \times m)$。

注意先转移向上的所有状态再转移向下的，避免出现一个坐标内同时上升和下降的转移。

## AC Code

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define F(i, a, b) for (int i = a; i <= b; i++)
#define _F(i, a, b) for (int i = a; i >= b; i--)
#define int long long
#define inf 1e14
using namespace std;
int rd() {
	int p = 0, f = 1;
	char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 10010, M = 1010;
int n, m, k, tx[N], ty[N];
struct node {
	int x, dn, up;
} p[N];
bool cmp(node u, node v) {
	return u.x < v.x;
}
int f[N][M], pup[N], pdown[N];
bool check(int x, int y) {
	if (y > m || y <= 0) return 0;
	if (!x) return 1;
	if (y >= pup[x] || y <= pdown[x]) return 0;
	return 1;
}
signed main() {
	F(i, 0, N-2) F(j, 0, M-2) f[i][j] = inf, pup[i] = inf;
	n = rd(), m = rd(), k = rd();
	F(i, 0, n-1) tx[i] = rd(), ty[i] = rd();
	F(i, 1, k) p[i].x = rd(), p[i].dn = rd(), p[i].up = rd();
	sort(p + 1, p + 1 + k, cmp);
	F(i, 1, k) pup[p[i].x] = min(pup[p[i].x], p[i].up), pdown[p[i].x] = max(pdown[p[i].x], p[i].dn);
	F(i, 1, m) f[0][i] = 0;
	int ans = inf;
	F(i, 0, n-1) {
		_F(j, m, 1) {
			if (!check(i, j)) continue ;
			f[i+1][min(j+tx[i], m)] = min(f[i+1][min(j+tx[i], m)], f[i][j] + 1);
		}
		F(j, 1, m) {
			f[i+1][min(j+tx[i], m)] = min(f[i+1][min(j+tx[i], m)], f[i+1][j] + 1);
		}
		_F(j, m, 1) {
			if (!check(i, j)) continue ;
			if (check(i+1, j-ty[i]) && j-ty[i] > 0) f[i+1][j-ty[i]] = min(f[i+1][j-ty[i]], f[i][j]);
		}
	}
	F(j, 1, m) ans = min(ans, f[n][j]);
	if (ans == inf) {
		cout << 0 << '\n';
		bool flag = false; int pos = n;
		F(i, 1, n) {
			flag = 0;
			F(j, 1, m) if (check(i, j) && f[i][j] < inf) flag = 1;
			if (!flag) {
				pos = i-1;
				break ;
			}
		}
		int cnt = 0;
		F(i, 1, k) {
			if (p[i].x <= pos) ++cnt;
		}
		cout << cnt << '\n';
	} else {
		cout << 1 << '\n' << ans << '\n';
	}
	return 0;
}
```

---

## 作者：崔泽禹 (赞：0)

# [P1941 NOIP2014 提高组 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)题解

## 优化推导

- 完全背包

    转移方程：

    $$dp_{i,j}\gets\max(dp_{i-1,v},dp_{i-1,v-c_i}+w_i,dp_{i-1,v-c_i\times 2}+w_i\times 2\cdots dp_{i-1,v-c_i\times k}+w_i\times k)$$

    将 $dp_{i,v}$ 中的第二维 $v$ 全部 $-c_i$，因为 $v-c_i\times (k+1) < 0$，所以最后一项舍去：

    $$dp_{i,v-c_i}\gets\max(dp_{i-1,v-c_i},dp_{i-1,v-c_i\times 2}+w_i,dp_{i-1,v-c_i\times 3}+w_i\times 2\cdots dp_{i-1,v-c_i\times k}+w_i\times (k-1))$$

    各项式子同时 $+w_i$：

    $$dp_{i,v-c_i}+w_i\gets\max(dp_{i-1,v-c_i}+w_i,dp_{i-1,v-c_i\times 2}+w_i\times 2\cdots dp_{i-1,v-c_i\times k}+w_i\times k)$$

    所以：

    $$dp_{i,v}\gets\max(dp_{i-1,v},dp_{i,v-c_i}+w_i)$$

- 在本题中

    转移方程：

    $$dp_{i,j}\gets\min(dp_{i-1,j-X_{i-1}}+1,dp_{i-1,j-X_{i-1}\times 2}+2\cdots dp_{i-1,j-X_{i-1}\times k}+k)$$

    将 $dp_{i,j}$ 中的第二维 $j$ 全部 $-X_{i-1}$，因为 $j-X_{i-1}\times (k+1)<0$，所以最后一项舍去：

    $$dp_{i,j-X_{i-1}}\gets\min(dp_{i-1,j-X_{i-1}\times 2}+1\cdots dp_{i-1,j-X_{i-1}\times k}+(k-1))$$

    各项式子同时 $+1$：

    $$dp_{i,j-X_{i-1}}+1\gets\min(dp_{i-1,j-X_{i-1}\times 2}+2\cdots dp_{i-1,j-X_{i-1}\times k}+k)$$

    所以：

    $$dp_{i,j}\gets\min(dp_{i-1,j-X_{i-1}}+1,dp_{i,j-X_{i-1}}+1)$$

## 核心代码

1. 上升

    ```cpp
    for (int j = p[i - 1].x + 1; j <= m; j++) {
        dp[i][j] = min(dp[i][j], min(dp[i - 1][j - p[i - 1].x] + 1, dp[i][j - p[i - 1].x] + 1));
    }
    ```

2. 上升到顶（无法上升）

    ```cpp
    for (int j = m - p[i - 1].x; j <= m; j++) {
        dp[i][m] = min(dp[i][m], min(dp[i - 1][j] + 1, dp[i][j] + 1));
    }
    ```

3. 下降

    ```cpp
    for (int j = 1; j <= m - p[i - 1].y; j++) {
        dp[i][j] = min(dp[i][j], dp[i - 1][j + p[i - 1].y]);
    }
    ```

4. 其它

    ```cpp
    if (p[i].sgn) {
        for (int j = 1; j <= p[i].l; j++) {
            dp[i][j] = INF;
        }
        for (int j = m; j >= p[i].h; j--) {
            dp[i][j] = INF;
        }
        cnt++;
    }
    ```

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5, M = 1e3 + 5;
const int INF = 1e9;
struct Node {
	bool sgn = false;
	int l, h;
	int x, y;
};
Node p[N];
int n, m, k;
int s;
int dp[N][M];
int ans, cnt = 0;
int main() {
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> p[i].x >> p[i].y;
	}
	for (int i = 0; i < k; i++) {
		cin >> s;
		cin >> p[s].l >> p[s].h;
		p[s].sgn = true;
	}
	memset(dp, 0x3f3f3f, sizeof(dp));
	for (int i = 0; i <= m; i++) {
		dp[0][i] = 0;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = p[i - 1].x + 1; j <= m; j++) {
			dp[i][j] = min(dp[i][j], min(dp[i - 1][j - p[i - 1].x] + 1, dp[i][j - p[i - 1].x] + 1));
		}
		for (int j = m - p[i - 1].x; j <= m; j++) {
			dp[i][m] = min(dp[i][m], min(dp[i - 1][j] + 1, dp[i][j] + 1));
		}
		for (int j = 1; j <= m - p[i - 1].y; j++) {
			dp[i][j] = min(dp[i][j], dp[i - 1][j + p[i - 1].y]);
		}
		if (p[i].sgn) {
			for (int j = 1; j <= p[i].l; j++) {
				dp[i][j] = INF;
			}
			for (int j = m; j >= p[i].h; j--) {
				dp[i][j] = INF;
			}
			cnt++;
		}
		ans = INF;
		for (int j = 1; j <= m; j++) {
			ans = min(ans, dp[i][j]);
		}
		if (ans == INF) {
			cout << 0 << endl << cnt - 1;
			return 0;
		}
	}
	cout << 1 << endl << ans;
	return 0;
}
```

## 使用滚动数组

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5, M = 1e3 + 5;
const int INF = 1e9;
struct Node {
	bool sgn = false;
	int l, h;
	int x, y;
};
Node p[N];
int n, m, k;
int s;
int dp[2][M];
int ans, cnt = 0;
int flag = 1; 
int main() {
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> p[i].x >> p[i].y;
	}
	for (int i = 0; i < k; i++) {
		cin >> s;
		cin >> p[s].l >> p[s].h;
		p[s].sgn = true;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			dp[flag][j] = INF;
		}
		for (int j = p[i - 1].x + 1; j <= m; j++) {
			dp[flag][j] = min(dp[flag][j], min(dp[1 - flag][j - p[i - 1].x] + 1, dp[flag][j - p[i - 1].x] + 1));
		}
		for (int j = m; j >= m - p[i - 1].x; j--) {
			dp[flag][m] = min(dp[flag][m], min(dp[1 - flag][j] + 1, dp[flag][j] + 1));
		}
		for (int j = m - p[i - 1].y; j >= 1; j--) {
			dp[flag][j] = min(dp[flag][j], dp[1 - flag][j + p[i - 1].y]);
		}
		if (p[i].sgn) {
			for (int j = 1; j <= p[i].l; j++) {
				dp[flag][j] = INF;
			}
			for (int j = m; j >= p[i].h; j--) {
				dp[flag][j] = INF;
			}
			cnt++;
		}
		ans = INF;
		for (int j = 1; j <= m; j++) {
			ans = min(ans, dp[flag][j]);
		}
		if (ans == INF) {
			cout << 0 << endl << cnt - 1;
			return 0;
		}
		flag = 1 - flag;
	}
	cout << 1 << endl << ans;
	return 0;
}
```

---

## 参考题解

[题解 P1941 【飞扬的小鸟】](https://www.luogu.com.cn/article/r9oykv29)

## 视频题解

![video](bilibili:BV1NG4y1e769)

---


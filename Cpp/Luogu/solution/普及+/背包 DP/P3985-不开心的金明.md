# 不开心的金明

## 题目描述

金明今天很不开心，家里购置的二手房就要领钥匙了，房里并没有一间他自己专用的很宽敞的房间。更让他不高兴的是，妈妈昨天对他说：“你需要购买哪些物品，怎么布置，你说了不算（有很大的限制），而且不超过 $W$ 元钱。”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $W$ 元。于是，他把每件物品规定了一个重要度整数 $p_i$ 表示。他还从因特网上查到了每件物品的价格 $v_i$（都是整数元）。

妈妈看到购物单后进行了审查，要求购物单上所有的物品价格的极差（最贵的减去最便宜的）不超过 $3$（当然金明至今不知道为什么会这样）。他希望在不超过 $W$ 元（可以等于 $W$ 元）的前提下，使购买的重要度总和 $\sum p_i$ 的最大。


请你帮助金明设计一个满足要求的购物单，你只需要告诉我们重要度的最大的和。


## 说明/提示

$1 \le N \le 100$。

$1 \le W \le 10^9$。

$1 \le v_i \le 10^9$。

对所有的 $i=1,2,3,…,N$，$\min(v_i) \le v_i \le \min(v_i)+3$。

$1 \le p_i \le 10^7$。


## 样例 #1

### 输入

```
5 10
2 800
5 400
5 300
3 400
2 200
```

### 输出

```
1600```

# 题解

## 作者：蓝莲花__ (赞：91)

~~**这是一道大水题！？**~~

在做完 开心的金明 和 金明的储蓄计划 后

发现这也是一个简单的背包

###### **在预处理时将每个物品的体积都减去（MINV-1）**

其中MINV是所以物品中的最小的体积（价值）

再在dp数组中多加一维，记录一共选了几个

这样做的目的是可以知道当前选的总体积

dp[i][j]表示我选的修改后的物品的体积为i，选了j个

则当前的总体积为：i+j*minv ! ! !

好好理解！！！

代码不长

```
#include<bits/stdc++.h>
using namespace std;
const int mx=110;
int dp[mx*5][mx],n,w[mx],v[mx],sumv,minv=1e10,sv;
int main()
{
	cin>>n>>sumv;
	for (int i=1;i<=n;i++) cin>>v[i]>>w[i],minv=min(minv,v[i]),sv+=v[i];
	minv--;
        for (int i=1;i<=n;i++) v[i]-=minv;
        sv-=n*minv;
	for (int i=1;i<=n;i++)
	for (int j=sv;j>=v[i];j--)
	for (int k=n;k>=1;k--)
	if (j+k*minv<=sumv) dp[j][k]=max(dp[j][k],dp[j-v[i]][k-1]+w[i]);//cout<<dp[j][k]<<" "<<j<<" "<<k<<endl;
    
	int ans=0;
	for (int j=1;j<=sv;j++)
	for (int i=1;i<=n;i++) ans=max(ans,dp[j][i]);
	cout<<ans;
	return 0;
}

```


---

## 作者：sy_zmq_001 (赞：35)

这道题乍一看像一个裸的01背包，但是仔细看数据范围就会发现
数组根本放不下。
但是再读一遍题会发现好像有一个很明显的条件没有用：
 妈妈看到购物单后进行了审查，要求购物单上所有的物品价格的极差（最贵的减去最便宜的）不超过3（当然金明至今不知道为什么会这样）

这样的话其实可以以300为分界线化为两部分来做。当最小值 <=300 时当一个背包做，>300 时贪心做；

这个相信楼上题解都提到过了，但为什么要这么分呢？

现在取所有价格里面最大为 maxn ，最小为 minn ；

首先，极差为3，我们假设买100件（最多件），那么现在都买最便宜的和都买最贵的差 3 * 100 元钱；
这个差值在 minn>300 时无论如何都买不成另一件了，也就是说，此时可以买的最大件数就是 w/maxn 。
那么买的件数 <100 时，买最便宜的和都买最贵的差值 < 3 * 100 元钱，和上一种情况一样；
此时按照p从大到小排序，从大往小选 w/maxn 件就是答案了；

但是当minn<=300时完全有可能再买一件，两件，更多件。件数不确定，只能按照01背包的思想DP做了；


代码如下
```
#include <iostream>
#include <cstdio> 
#include <algorithm>
using namespace std;

int p[102],v[102],n,w;
int f[300002],maxn,minn=9999999;
bool cmp(int x,int y){
	return x>y;
}
int main(){
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&v[i],&p[i]);
		minn=min(minn,v[i]);
		maxn=max(maxn,v[i]);
	}
	if(minn<=300){
		for(int i=1;i<=n;i++){
			for(int j=w;j>=v[i];j--){
				f[j]=max(f[j],f[j-v[i]]+p[i]);
			}
		}
		printf("%d",f[w]);
	}
	else{
		int ans=0;
		sort(p+1,p+n+1,cmp);
		for(int i=1;i<=w/maxn;i++)
			ans+=p[i];
		printf("%d",ans);
	}
	return 0;
}
```


---

## 作者：林聪 (赞：31)

刚翻了下题解，发现没有我这种做法，于是就来发一下好了。

这题其实我们只用枚举下每种重量的用几个就可以了，反正总共也只有4种重量，问题不大。

同一种重量内我们当然先选价值高的了，所以读进来之后排个序就好。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define itn int//防手滑
using namespace std;
itn n,m,w[105],v[105],ans,minn=1e9+7;
int tot0,tot1,tot2,tot3;//每种物品的个数
int w0[105],w1[105],w2[105],w3[105];//每种物品的价值
int s0[105],s1[105],s2[105],s3[105];//价值的前缀和
bool cmp(int x,int y){return x>y;}
int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++)  scanf("%d%d",&w[i],&v[i]),minn=min(minn,w[i]);
  for(int i=1;i<=n;i++)
  {
    if(w[i]-minn==0)  w0[++tot0]=v[i];
    if(w[i]-minn==1)  w1[++tot1]=v[i];
    if(w[i]-minn==2)  w2[++tot2]=v[i];
    if(w[i]-minn==3)  w3[++tot3]=v[i];//分别放入4个数组
  }
  sort(w0+1,w0+tot0+1,cmp);
  sort(w1+1,w1+tot1+1,cmp);
  sort(w2+1,w2+tot2+1,cmp);
  sort(w3+1,w3+tot3+1,cmp);//按价值从高到底排序
  for(int i=1;i<=tot0;i++)  s0[i]=s0[i-1]+w0[i];
  for(int i=1;i<=tot1;i++)  s1[i]=s1[i-1]+w1[i];
  for(int i=1;i<=tot2;i++)  s2[i]=s2[i-1]+w2[i];
  for(int i=1;i<=tot3;i++)  s3[i]=s3[i-1]+w3[i];//计算前缀和
  for(int i=0;i<=tot0;i++)//枚举每种物品用几个
    for(int j=0;j<=tot1;j++)
	  for(int k=0;k<=tot2;k++)
	  {
	    int sum=i*minn+j*(minn+1)+k*(minn+2);
		if(sum<=m)//不超过总钱数
	    {
	  	  int l=(m-sum)/(minn+3);
	  	  ans=max(ans,s0[i]+s1[j]+s2[k]+s3[l]);//更新答案
	    } 	  	
	  }
  printf("%d",ans);
  return 0;
}
```

是不是~~简单粗暴~~很好理解呢...

---

## 作者：Npse_D (赞：23)

一个骗分出奇迹的想法：当vmin>300的时候，也就是最便宜的物品在300元以上。就算是99个304的物品，多出来的297元也不能买一个新东西。所以判断是否小于等于300，如果满足就当做01背包做，记录买了最便宜东西的个数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,W,v[105],p[105],dp[30305],vmin,vmax;
int main(){
    cin>>n>>W;
    vmin=999999999;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>p[i];
        vmin=min(vmin,v[i]);
        vmax=max(vmax,v[i]);
    }
    if(vmin<=300){
    for(int i=1;i<=n;i++){
        for(int j=30300;j>=vmin;j--){
                dp[j]=max(dp[j],dp[j-v[i]]+p[i]);
            }
        }
        cout<<dp[W];
    }
    else{
    for(int i=1;i<=n;i++){
        for(int j=W/vmax;j>=1;j--){
                dp[j]=max(dp[j],dp[j-1]+p[i]);
        }
    }
    cout<<dp[W/vmax];
    }
}
```

---

## 作者：ywy_c_asm (赞：10)

这个题……其实……用爆搜是可以过的，毕竟n只有100，状态数并不是很大……重点在于$v$最多只有3种，所以我们可以dfs枚举每一种选了多少然后就行了（注意每种价格要优先取价值最大的），复杂度仅有$O(n^3)$。

~~表示不是很理解这题为什么要用那么麻烦的做法qaq……~~

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int maxn=0;
int w;
int ps[101],vs[101],ref[105];
vector<int> vec[101];//对每个价格开个vector存从大到小排序的价值 
int sums[101][101];//然后再用前缀和记录 
void dfs(int val,int qian,int pos,int deep) {//最暴力不过的爆搜 
	maxn=max(maxn,val);
	if(!deep)return;
	dfs(val,qian,pos+1,deep-1);
	for(register int i=1; i<=vec[pos].size(); i++) {
		qian+=ref[pos];
		if(qian>w)return;
		dfs(val+sums[pos][i],qian,pos+1,deep-1);
	}
}
int cmp(const int &a,const int &b) {
	return(a>b);
}
int main() {
	int n;
	cin>>n>>w;
	for(register int i=1; i<=n; i++) {
		cin>>vs[i]>>ps[i];
		ref[i]=vs[i];
	}
	sort(ref+1,ref+1+n);//离散化价格 
	int newl=unique(ref+1,ref+1+n)-ref-1;
	for(register int i=1; i<=n; i++) {
		vs[i]=lower_bound(ref+1,ref+1+newl,vs[i])-ref;
		vec[vs[i]].push_back(ps[i]);
	}
	for(register int i=1; i<=newl; i++) {
		sort(vec[i].begin(),vec[i].end(),cmp);//排序 
		for(register int j=1; j<=vec[i].size(); j++) {
			sums[i][j]=sums[i][j-1]+vec[i][j-1];
		}
	}
	dfs(0,0,1,newl);
	cout<<maxn<<endl;
	return(0);
}
```

---

## 作者：ylsoi (赞：7)

看到题目想到背包，但是背包开不了这么大的空间，所以好像不好做的样子，但是由于体积（价格）只有四种情况，所以我们可以将体积设为最小值的j倍加上一个k，因为n<=100，所以k的最大值就只有300，数组可以开f[110][110][310]，不会超空间，可以完美解决所有的情况，但是最小价格小于300的时候要跑一个普通的01背包，否则数组之间会串起来出错。

#状态转移方程f[i][j][k]=max(f[i-1][j-1][k-(v[i]-minx)]+p[i],f[i-1][j][k])

表示可以从不同的情况下转移过来。

详细的代码可以看我的博客

http://blog.csdn.net/ylsoi/article/details/78648195


---

## 作者：Mebsuta (赞：6)

偶然发现了这道题，然后瞬间有了思路，然后就过了。。

思路：

因为只有三个价格，所以状态数不会很多，所以可以开个vector把所有状态存下来，然后每次加入新状态时更新旧状态就可以了。再由于01背包滚动数组的更新顺序是从大到小，所以每次要排一遍序，然后又因为数组有序了，所以可以二分找到相同的状态（不二分的话最后两个点过不去），这样就可以A掉这道题了。

代码：


```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

typedef long long ll;

struct node{
	ll cost,worth;
	bool operator <(const node& x)const{
		return cost > x.cost;
	}
};

vector<node> v;
ll n,w,x,y,sz,nv,ans;

ll imax(ll a,ll b){
	if(a > b)return a;
	return b;
}

void add(int vi,int wi){
	int l = 0,r = v.size()-1,pl,mid;
	while(l <= r){
		mid = (l+r)>>1;
		if(v[mid].cost == vi){
			v[mid].worth = imax(v[mid].worth,wi);
			return;
		}
		if(v[mid].cost > vi)l = mid+1;
		else r = mid-1;
	}
	v.push_back((node){vi,wi});
}

int main(){
	cin >> n >> w;
	v.push_back((node){0,0});
	while(n--){
		cin >> x >> y;
		sz = v.size();
		sort(v.begin(),v.end());
		for(int i = 0;i < sz;i++){
			nv = x+v[i].cost;
			if(nv <= w)add(nv,v[i].worth+y);
		}
//		for(int i = 0;i < v.size();i++)printf("** %d : %d\n",v[i].cost,v[i].worth);
	}
	for(int i = 0;i < v.size();i++)ans = imax(ans,v[i].worth);
	cout << ans << '\n';
return 0;
}
```


---

## 作者：Victorique (赞：5)

考完noip之后的第一篇题解。

这个题乍一看是一个背包，事实上的确就是一个背包。然后就想洛谷月赛啥时候有这种一眼题。。。。结果，这个。。w略大了一点吧。。。自然想到了要压一下。但是怎么压，我有两种思路，一种就是楼下的方法，楼下解释的已经很详细了。还有一种是我最先想到的思路，在这里我介绍一下：首先，仔细读题之后我们可以发现所有物品的总价格是始终大于w的，而且妈妈的那个极差，保证了哪怕一百件全买最便宜的，如果它的价格高过了300，照样买不起那个比最便宜还贵1的那个了，于是就有了如下压缩体积的思路：

```cpp
if(minn>500)
    {
        for(re int i=1;i<=n;i++)
        {
            jia+=w[i]-minn;
            w[i]=500+w[i]-minn;
        }
        if(m%minn==0)
        m=(m/minn)*500;
        else
        m=(m/minn)*500+jia;
    }
```
其中minn是最便宜的那种价钱。
然后直接跑背包就可以了，没什么其他要说的。

貌似还是比较快的。


---

## 作者：Alessandro (赞：5)

我做这道题的思路是模拟链表储存，把v值一样的放入一个链中，并且把链按照不严格递减排列

**这道题很简单**

...然而我换了3种做法

可以很简单的证明，如果取v一样的，取p最大的一定是最优解

如果要取第n个，为保证最优，必取前面的所有数

剩下的就是###baoli###了（因为只有100个数，通过计算可以得到计算次数不会超过2500次，不会超时）

我的方法主要是针对比较大的情况



```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
struct data{
    int p;
    int v;
}a[101];
struct list{
    int len;
    int sum_p[101];
    int sum_v[101];
}b[101];
int FIND(list &A,list &B,list &C,list &D,int rest);
int n,W,maxn=0;
inline bool cmp(data n1,data n2){
    if(n1.v==n2.v) return n1.p>n2.p;
    else return n1.v<n2.v;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>W;
    int i,j;
    for(i=1;i<=n;++i)
        cin>>a[i].v>>a[i].p;
    sort(a+1,a+n+1,cmp);
    a[0].v=a[1].v;
    memset(b,0,sizeof(b));
    int pos=0;
    for(i=1,j=1;i<=n;++i){
    if(a[i].v!=a[i-1].v) {
        b[j].len=i-pos-1;
        pos=i-1;
        j++;}
        b[j].sum_p[i-pos]=b[j].sum_p[i-1-pos]+a[i].p;
        b[j].sum_v[i-pos]=b[j].sum_v[i-1-pos]+a[i].v;
    if(i==n){
        b[j].len=i-pos;
    }
    }
    int list_num=j;
```
这上面是模拟链表，注意pos记录开始位置-1，前缀和减少后面的运算，后面是搜索
```cpp
    for(i=1;i<=list_num;++i){
    FIND(b[i],b[i+1],b[i+2],b[i+3],W);
    }
    cout<<maxn;
return 0;
}
//这里用&A来减少调用函数的复制数组时间和空间，参数rest其实可以不要，我只是第一遍写的时候想错了
int FIND(list &A,list &B,list &C,list &D,int rest){
    int i,j,h,l;
    for(i=0;i<=A.len;++i){
        for(j=0;j<=B.len;++j){
            for(h=0;h<=C.len;++h){
                for(l=0;l<=D.len;++l){
                    if(A.sum_v[i]+B.sum_v[j]+C.sum_v[h]+D.sum_v[l]>rest) break;
                    if(j!=0&&B.sum_v[1]-A.sum_v[1]>3) break;
                    if(h!=0&&C.sum_v[1]-A.sum_v[1]>3) break;
                    if(l!=0&&D.sum_v[1]-A.sum_v[1]>3) break;
//所有不成立的情况需要跳过，由于sum递增，所以后面的数不用考虑，直接break；
//只要成立就要枚举；
                    maxn=max(maxn,A.sum_p[i]+B.sum_p[j]+C.sum_p[h]+D.sum_p[l]);
                }
            }
        }
    }
    return maxn;
}
```

---

## 作者：zengkaixin (赞：4)

## 直接背包是会爆空间的，那么考虑压缩。记录所有物品的价格的最小值和最大值maxv和minv,当minv<=300的时候可以直接背包求解，另一种情况可以很容易由约束条件得到，w/minv == w/maxv，这样就可以直接贪心选取得到答案。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 300*100 + 500;
const int maxint = 0x3f3f3f3f;
int dp[maxn];
int n,w;
struct node{
    int v, p;
};
node data[200];
struct cmp{
    bool operator ()(const node &a, const node &b){
        return a.p > b.p;
    }
};
int main(){
    int i,j;
    scanf("%d %d",&n, &w);
    int maxv = 0;
    int minv = maxint;
    for(i = 1; i <= n; i++) {
            scanf("%d %d",&data[i].v, &data[i].p);
            if(data[i].v > maxv) maxv = data[i].v;
            if(data[i].v < minv) minv = data[i].v;
    }
    sort(data + 1, data + n + 1, cmp());
    memset(dp, 0, sizeof(dp));
    if(minv <= 300){
        for(i = 1; i <= n; i++){
            for(j = maxn - 1; j >= data[i].v; j--){
                dp[j] = max(dp[j - data[i].v] + data[i].p, dp[j]);
            }
        }
        printf("%d\n", dp[w]);
    }else{
        int tn = w / minv;
        int ans = 0;
        for(i = 1; i <= tn ; i++) ans+=data[i].p;
        printf("%d\n",ans);
    }
    return 0;
}

```

---

## 作者：Minclxc (赞：2)

发个O(n^2\*log(n))的题解

因为只有4种物品，所以可以分为4组，易知每组kv的值是确定的，且只有n个值

再分为两组，每组中暴力求出所有可能的值，就是O(n^2)

比如第一种和第二种一组，第一种取k1v1，第二种取k2v2，如果<=w就加到数组中

将上面的值排序，再将其中vi>vj且pi<pj的去掉（不可能用到）

所以剩下两组的值都是单调递增的，那么遍历其中一个，另外一个用指针从后往回找最后一个符合条件的，更新ans即可

效率就是排序的O(n^2\*log(n))

反正很多4组的都是这个套路，两两分组再合起来

```cpp
#include<cstdio>
#include<algorithm> 
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int N=110;
int v[N],p[N],nd[4],pd[4][N];
struct node{int v,p;}x[N*N],y[N*N];
int cmp_int(int a,int b){return a>b;}
int cmp_node(node a,node b){return a.v<b.v;}
int main(){
    int n=read(),w=read(),minv=1e9,nx=0,ny=0,ans=0,xn=1,yn=1;
    fo(i,1,n)v[i]=read(),p[i]=read(),minv=min(minv,v[i]);
    fo(i,1,n)pd[v[i]-minv][++nd[v[i]-minv]]=p[i];//分种类
    fo(i,0,3)sort(pd[i]+1,pd[i]+nd[i]+1,cmp_int);
    fo(i,0,3)fo(j,1,nd[i])pd[i][j]+=pd[i][j-1];//算出kv的值
    fo(i,0,nd[0])fo(j,0,nd[1])
        if(1ll*minv*i+1ll*minv*j+j<=w)
            x[++nx]=(node){minv*i+minv*j+j,pd[0][i]+pd[1][j]};
    fo(i,0,nd[2])fo(j,0,nd[3])
        if(1ll*minv*i+1ll*minv*j+2*i+3*j<=w)
            y[++ny]=(node){minv*i+minv*j+2*i+3*j,pd[2][i]+pd[3][j]};//分组
    sort(x+1,x+nx+1,cmp_node);sort(y+1,y+ny+1,cmp_node);//排序
    fo(i,2,nx)if(x[i].p>x[xn].p)x[++xn]=x[i];
    fo(i,2,ny)if(y[i].p>y[yn].p)y[++yn]=y[i];//去掉不可能用到的
    fo(i,1,xn){
        while(yn&&x[i].v+y[yn].v>w)yn--;//去掉不合法的
        if(yn)ans=max(ans,x[i].p+y[yn].p);//更新
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：laorui (赞：1)

这真的不是背包

首先我们可以发现物品只有4种而n<=100

对于同种物品自然要先选价值大的

自然要先把同种物品排一遍序

然后用f[i][j][k][l]表示用i个1物品，j个2物品，k个3物品，l个4物品的总价值判断是否超容量

但是ijkl任何一个都有可能达到100,100^4的int数组是开不下的

而在最坏情况下用到的空间也不过25^4

所以我们考虑给数组压缩（具体怎么压缩在代码中解释）
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int f[1000007];//用一维代替四维 
int n,m,mm;int a[107],p[107],c[5];int b[5][107];//mm代表最小的数，c代表各种物品的数量 
//压缩函数，原理类似压位DP，把参数转化为个位c[0]+1进制，十位c[1]+1进制，百位c[2]+1进制的数 
//这个函数的作用是找到四维数组中对应的一维编号； 
int idx(int aa,int bb,int cc,int dd)
{return aa+(c[0]+1)*bb+(c[0]+1)*(c[1]+1)*cc+(c[0]+1)*(c[1]+1)*(c[2]+1)*dd;}
bool cmp(int x,int y)
{return x>y;}
int main()
{cin>>n>>m;
for(int i=1;i<=n;++i)
cin>>a[i]>>p[i];
mm=0x3f3f3f3f;
for(int i=1;i<=n;++i)
{if(a[i]<mm)mm=a[i];}
for(int i=1;i<=n;++i)
{++c[a[i]-mm];b[a[i]-mm][c[a[i]-mm]]=p[i];}//把数分好类 
for(int i=0;i<=3;++i)sort(b[i]+1,b[i]+c[i]+1,cmp);//排序 
int maxn=0;
for(int i=0;i<=c[0];++i)
{for(int j=0;j<=c[1];++j)
{for(int k=0;k<=c[2];++k)
{for(int l=0;l<=c[3];++l)
{if((i+j+k+l)*mm+j+k*2+l*3>m)break;//判断是否超了 
//对于f的处理比较复杂，暂时没想到什么好方法 
if(l!=0){f[idx(i,j,k,l)]=f[idx(i,j,k,l-1)]+b[3][l];}
else if(k!=0){f[idx(i,j,k,l)]=f[idx(i,j,k-1,l)]+b[2][k];} 
else if(j!=0){f[idx(i,j,k,l)]=f[idx(i,j-1,k,l)]+b[1][j];} 
else if(i!=0){f[idx(i,j,k,l)]=f[idx(i-1,j,k,l)]+b[0][i];} 
if(f[idx(i,j,k,l)]>maxn)maxn=f[idx(i,j,k,l)];}}}}
cout<<maxn;
return 0;
}
```

f开100w左右就可以了

---


# [CEOI 2015] 世界冰球锦标赛 (Day2)

## 题目描述

 **译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day2 T1「[Ice Hockey World Championship](https://ceoi2015.fi.muni.cz/day2/eng/day2task1-eng.pdf)」**

> 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。

给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。

## 说明/提示

#### 样例解释
八种方案分别是：

 - 一场都不看，溜了溜了  
 - 价格 $100$ 的比赛  
 - 第一场价格 $500$ 的比赛  
 - 第二场价格 $500$ 的比赛  
 - 价格 $100$ 的比赛和第一场价格 $500$ 的比赛  
 - 价格 $100$ 的比赛和第二场价格 $500$ 的比赛  
 - 两场价格 $500$ 的比赛  
 - 价格 $1000$ 的比赛

有十组数据，每通过一组数据你可以获得 10 分。各组数据的数据范围如下表所示：

|数据组号|$1-2$|$3-4$|$5-7$|$8-10$|
|-|:-:|:-:|:-:|:-:|
|$N \leq$|$10$|$20$|$40$|$40$|
|$M \leq$|$10^6$|$10^{18}$|$10^6$|$10^{18}$|

## 样例 #1

### 输入

```
5 1000
100 1500 500 500 1000```

### 输出

```
8```

# 题解

## 作者：ZAGER (赞：111)


## 题解

[透彻](https://www.cnblogs.com/ZAGER/p/9827160.html)

首先看数据范围

1. 1-4组数据$N\leq20$，爆搜就可以解决。

   ```cpp
   inline void dfs(R ll dep,R ll sum){
      if(sum>m)return;
      if(dep==n+1){
          ans++;
          return;
      }
      dfs(dep+1,sum+a[dep]);
      dfs(dep+1,sum);
   }
   int main(){
      read(n);read(m);
      for(R int i=1;i<=n;i++)read(a[i]);
      if(n<=20){
          dfs(1,0);
          printf("%lld\n",ans);
      }
      return 0;
   }
   ```

   

2. 5-7组数据$M\leq10^6$，裸的背包啊。

   ```cpp
   int main(){
   	read(n);read(m);
   	for(R int i=1;i<=n;i++)read(a[i]);
       if(m<=1e6){
           f[0]=1;
           for(R int i=1;i<=n;i++)
               for(R int j=m;j>=a[i];j--)
                   f[j]+=f[j-a[i]];
           for(R int i=0;i<=m;i++)ans+=f[i];
           printf("%lld\n",ans);
       }
       return 0;
   }
   
   ```

3. 现在你已经能拿到70分了（但在洛谷上是47分）

#### 下面引出主角——折半搜索（meet in the middle思想）

因为$N\leq40$ $O(2^{40})$的爆搜一定会$TLE$，所以我们将$N$分成两份

搜索$1$到$n/2$和$n/2+1$到$n$，让复杂度降到$O(2^{n/2+1}+$组合答案的复杂度$)$。

画一个图（网上找的不错的图）理解一下为什么能降低复杂度

![折半搜索](https://i.loli.net/2018/10/21/5bcc80c099ca0.png)

![折半搜索2](https://i.loli.net/2018/10/21/5bcc80e9bf36f.png)

```cpp
inline void dfs(R int l,R int r,R ll sum,R ll a[],R ll &cnt){
    if(sum>m)return;
    if(l>r){
        a[++cnt]=sum;
        return;
    }
    dfs(l+1,r,sum+w[l],a,cnt);//选
    dfs(l+1,r,sum,a,cnt);//不选
}
```

将前一半的搜索状态存入a数组，后一半存入b数组。

```cpp
mid=n/2;
dfs(1,mid,0,suma,cnta);
dfs(mid+1,n,0,sumb,cntb);
```

一般$meet$ $in$ $the$ $middle$的难点主要在于最后答案的组合统计。

我们可以现将a或b数组sort，让其有序。

然后通过枚举另一个数组中的状态，来实现统计答案。![bobek](https://i.loli.net/2018/10/21/5bcc835ebb182.png)

上述找$pos$的过程可以通过upper_bound()完成。

```cpp
sort(suma+1,suma+1+cnta);//使一个数组有序
for(R int i=1;i<=cntb;i++)
    ans+=upper_bound(suma+1,suma+1+cnta,m-sumb[i])-suma-1;//统计ans
```

### 下面是高清完整code：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cctype>
#define ll long long
#define R register
#define N 55
using namespace std;
template<typename T>inline void read(T &a){
    char c=getchar();T x=0,f=1;
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    a=f*x;
}
ll n,m,w[N],mid,suma[1<<21],sumb[1<<21],cnta,cntb,ans;
inline void dfs(R int l,R int r,R ll sum,R ll a[],R ll &cnt){
    if(sum>m)return;
    if(l>r){
        a[++cnt]=sum;
        return;
    }
    dfs(l+1,r,sum+w[l],a,cnt);
    dfs(l+1,r,sum,a,cnt);
}
int main(){
    read(n);read(m);
    for(R int i=1;i<=n;i++)read(w[i]);
    mid=n>>1;
    dfs(1,mid,0,suma,cnta);
    dfs(mid+1,n,0,sumb,cntb);
    sort(suma+1,suma+1+cnta);
    for(R int i=1;i<=cntb;i++)
        ans+=upper_bound(suma+1,suma+1+cnta,m-sumb[i])-suma-1;
    printf("%lld\n",ans);
    return 0;
}
```

这里还有一道折半搜索的好题，难度升级——[luogu](https://www.luogu.org/problemnew/show/P3067)，还有 [my blog](https://www.cnblogs.com/ZAGER/p/9823171.html).

---

## 作者：Ofnoname (赞：38)

[P4799 【世界冰球锦标赛】](https://www.luogu.org/problem/P4799)

相信大家都是从@StudyingFather 神犇的题单过来的，那么这道题就应该用双向搜索解决了。而双向搜索往往也用来解决这种`N`等于三四十的搜索问题。

当你打爆搜的时候，你是否想过，多打$2^{40}$种情况，但是绝大部分都是没有用的？如果可以只搜索出一些结果，并且用这些结果来统计最优解那该多好？那么这就是折半搜索了。

1. 我们把40个数，分为前一半和后一半，算出他们能够组合出的价格并分别记录进数组里（当然已经超过`M`就算了），把其中一个数组排序。（这里是`ka`）
```cpp
M: 1000
ka: 0 100 500 600 (1500 1600 2000 2100)
kb: 0 500 1000 (1500)
```
2. 接下来后一半数里肯定是要选数的，我们从前往后遍历`kb`，就相当于遍历选后一半的所有情况，比如当`kb`遍历到`500`的时候，由于`M == 1000`，所以`ka`里小于等于500的数都可以贡献答案，因为`ka`排好序了，所以直接二分查找就可以确定小于等于`M - kb[i]`的数的个数。

```cpp
#include <bits/stdc++.h>
#define long long long
using namespace std;

int N, mid, ac, bc;
long M, ans, d[47];

vector <long> ka, kb;

void DFS(int L, int R, long sum, vector <long> &k)
{
	if (sum > M) return;
	if (L > R)
	{
		k.push_back(sum);//累计答案 
		return;
	}
	DFS(L+1, R, sum+d[L], k);
	DFS(L+1, R, sum, k);
}

int main()
{
	cin >> N >> M, mid = N >> 1;
	for (int i = 1; i <= N; i++)
		cin >> d[i];
	DFS(1, mid, 0, ka), DFS(mid+1, N, 0, kb);
	sort(ka.begin(), ka.end());
	for (int i = 0; i < kb.size(); i++)
		ans += upper_bound(ka.begin(), ka.end(), M-kb[i]) - ka.begin();
	//要注意upper_bound找的是严格大于M-kb[i]的第一个数，但是vector下标从0开始，所以刚刚好。 
	cout << ans << endl;
}
```

---

## 作者：NKU_AI_HMX (赞：16)

吸氧53ms拿下了提交记录最快。
## 目录
1. 介绍二分搜索。
2. 为啥用二分搜索？
3. 代码展示。
4. 推荐习题。


------------
## 正文
#### 1.二分搜索
大家一定很熟悉二分查找，就是二分法，可以在 $ logn $ 的时间内在有序数列里面查找对应值，那搜索如果二分下去的话是不是就可以也把原有的复杂度取一个对数？$log2^n$?那样岂不是把指数复杂度变为 $n$ 了？一开始我学习这个算法的时候也有这样想过，但是我们仔细想会发现并不这么回事。我们把一个 $2^n$ 的复杂度降为$2 \times 2^{\frac n2}$,但是这仅仅是搜索部分，我们还需要将两个 $2^{\frac n2}$ 的数据集组合，如果组合部分没法优化那么复杂度就是 $2^{\frac n2}\times2^{\frac n2}$ 不仅复杂度没降低，前面的一些操作还增加了一些时间消耗。所以说实际上我们二分搜索之所以可以直接把复杂度开根号，主要的功劳还是来自最后组合时的优化（然而并不是所有的组合部分都可以把复杂度减至 $nlogn$）而恰好这题组合部分可以 $nlogn$ 复杂度完成。


------------
#### 2. 为啥用二分搜索？
这题之所以可以二分搜索把原有复杂度开根号，主要是最后组合两个搜索答案时我们可以通过 $sort$ 然后用二分很快找到我们所需的值，这部分复杂度为 $nlogn$， 另外一般剪枝只能拿40分，综合考虑应该知道只剩二分搜索了（背包过不了所有数据）


------------

#### 3. 代码展示
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
char ch1;
template<class T>
inline void rd(T& x) {
	x = 0; bool w = 0;
	ch1 = getchar();
	while (!isdigit(ch1)) { ch1 == '-' && (w = 1), ch1 = getchar(); }
	while (isdigit(ch1)) { x = (x << 1) + (x << 3) + (ch1 & 15), ch1 = getchar(); }
	w && (x = (~x) + 1);
}
template<class T>
inline void wr(T x)
{
	if (x < 0) x = -x, putchar('-');
	if (x < 10) {
		putchar(x + 48);
		return;
	}
	T L = x / 10;
	wr(L);
	putchar(x - ((L << 1) + (L << 3)) + 48);
}
ll n, m,mid,ans,num1,num2;
ll a[50],sum[50],a1[1050000],b1[1050000];

void hdfs(ll x, ll cost)
{
	a1[num1++] = cost; 
	for (int i = x; i>mid; i--)
	{
		if (cost + a[i] <= m)
		{
		    hdfs(i - 1, cost + a[i]);
		}
	}
}
void ldfs(ll x, ll cost)
{
	 b1[num2++] = cost; 
	for (int i = x; i ; i--)
	{
		if (cost + a[i] <= m)
		{
			ldfs(i - 1, cost + a[i]);
		}
	}
}

int main()
{
	rd(n),rd(m); mid = n>>1;
	for (int i = 1; i <= n; i++)
	{
		rd(a[i]);
	}
	sort(a+1,a+n+1);//排序后再搜索会快不少，那样剪枝可以剪更多。
    hdfs(n,0);
	ldfs(mid, 0);
	sort(b1, b1 + num2);
	for (int i = 0; i < num1; i++)//组合两次搜索的答案
	{
		ans += upper_bound(b1, b1 + num2, m - a1[i]) - b1;//记录答案
	}
	cout << ans;
	return 0;
}
```



------------
#### 4. 推荐习题：
[Scales S](https://www.luogu.com.cn/problem/P5194)，[Balanced Cow Subsets G](https://www.luogu.com.cn/problem/P3067)
 


好久没回洛谷了，之前橙名都蓝了，要开始写题了

---

## 作者：顾z (赞：13)


退役选手日常划水。

显然这个题直接dfs是过不去的$O(2^n)$

但是我们可以一半一半的搜,即**折半搜索**,复杂度可以降到$O(2^{\frac{n}{2}})$

所以我们取一个$mid$,分别搜前半段和后半段。

然后合并答案的时候就需要令某一个数组变得有序,在其中找到最靠右的合法位置,直接累加即可。

这里用到了$upper$_$bound$

``代码``

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#define R register
#define lo long long

using namespace std;

const int gz=1e6+6e5;

inline void in(R lo &x)
{
	R int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

lo a[gz],b[gz],mon[42],ans,m;

int sum,cnt,n,mid;

void dfs(R int dep,R lo now)
{
	if(now>m)return;
	if(dep>mid)
	{
		a[++cnt]=now;
		return;
	}
	dfs(dep+1,now+mon[dep]);
	dfs(dep+1,now);
}

void dfss(R int dep,R lo now)
{
	if(now>m)return;
	if(dep>n)
	{
		b[++sum]=now;
		return;
	}
	dfss(dep+1,now+mon[dep]);
	dfss(dep+1,now);
}

int main()
{
	scanf("%d%lld",&n,&m);
	for(R int i=1;i<=n;i++)in(mon[i]);
	mid=(n+1)/2;
	dfs(1,0);dfss(mid+1,0);
	sort(b+1,b+sum+1);
	for(R int i=1;i<=cnt;i++)
		ans+=upper_bound(b+1,b+sum+1,m-a[i])-b-1;
	printf("%lld",ans);
}
```



---

## 作者：tobie (赞：10)

这道题，首先看数据范围就可以知道 $O(2^{40})$ 的时间复杂度一定会超时。

所以我们可以用一个很重要的思想——折半搜索。就是把 $O(2^{n})$ 的搜索问题拆分成两个 $O(2^{\frac{n}{2}})$ 的搜索子问题。

我们考虑一种可行的观看方案，必然是先在编号在 $\left [ 1, \left \lfloor  \dfrac{N}{2} \right \rfloor\right ]$ 中的比赛选取一些观看，然后在编号在 $\left [\left \lfloor  \dfrac{N}{2} \right \rfloor,N\right ]$ 中的比赛中选取一些观看。

所以，我们可以将两个子问题中所有可行的观看方案的花费分别用两个数组 `qwqa[]` 和 `qwqb[]` 存储。

最终合并答案时，我们可以将 `qwqa[]` 排序，然后遍历一遍 `qwqb[]`。

那么 `qwqb[i]` 对最终结果的贡献就是 `qwqa[]` 中有多少个数加上 `qwqb[i]` 的值小于 $M$ 。我们求贡献的过程可以用二分查找来优化。

分析结束，上代码！

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
int n,m,a[114514];
int qzh[114514];
int ans=0;
int qwqa[1919810],qwqb[1919810];
void dfs(int now,int nn,int res,int *b)
{
//	cout<<now<<" "<<res<<endl;
	if(res>m) return;
	if(now>nn)
	{
		b[++b[0]]=res;
		return;
	}
	dfs(now+1,nn,res+a[now],b);
	dfs(now+1,nn,res,b);
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	dfs(1,n/2,0,qwqa);
	dfs(n/2+1,n,0,qwqb);
	sort(qwqa+1,qwqa+qwqa[0]+1);
	for(int i=1;i<=qwqb[0];i++)
	{
		int l=1,r=qwqa[0],res;
		while(l<=r)
		{
			int mid=(l+r)/2;
			if(qwqa[mid]+qwqb[i]<=m) res=mid,l=mid+1;
			else r=mid-1;
		}
		ans+=res;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：jins3599 (赞：7)

又是一道折半搜索。

发现题解大多都在用二分查找，平添一个$log$，其实不是很优美。

于是我用$\text{two-pointer}$轻松跑到了最优解第一页。

首先显然的可以看出这道题的数据范围普通的搜索无法胜任。

于是我们考虑把问题分开，进行两遍dfs找出两端序列，于是问题就转化为了在两段序列上，求分别属于两个序列的两个数的和小于等于$m$的方案总数。

$n^2$暴力是肯定过不去的，于是下面就出现了两种分化

- 在一个数列上枚举，然后二分另一个数列对应的数，复杂度$O(nlogn)$

- $\text{two-pointer}$线性统计答案，复杂度$O(n)$

第一种就不说了，非常好想。

于是我们讲一下这道题如何用双指针统计答案。

我们维护两个指针$l,r$分别指向数组a的头和数组b的尾。

我们观察对于每一个$l$，我们让他递增时(也就是l++时)，对应的$r$是不会增加的。

于是单调性显然，我们每次维护到合法的$l,r$时，让`ans+=(r-1)`即可。

为什么是`r-1`？由于我们开始时把每个数组中单独的答案统计过了，所以不再考虑不去的情况，自然就是`r-1`了。

代码非常好写。
```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;
const int N = 3e6;
ll n , m;
ll a[50] , ans , mid;
ll sum1[N] , cnt1 , sum2[N] , cnt2;

void dfs1(int now , ll sum) {
	if(sum > m) return;
	if(now > mid) {
		if(sum <= m) sum1[++ cnt1] = sum;
		return;
	}
	dfs1(now + 1 , sum);
	dfs1(now + 1 , sum + a[now]);
}

void dfs2(int now , ll sum) {
	if(sum > m) return;
	if(now > n) {
		if(sum <= m) sum2[++ cnt2] = sum;
		return;
	}
	dfs2(now + 1 , sum);
	dfs2(now + 1 , sum + a[now]);
}

int main () {
	scanf("%lld %lld" , &n , &m);
	for(int i = 1 ; i <= n ; i ++) scanf("%lld" , a + i);
	mid = (n >> 1);
	dfs1(1 , 0);
	dfs2(mid + 1 , 0);
	sort(sum1 + 1 , sum1 + 1 + cnt1);
	sort(sum2 + 1 , sum2 + 1 + cnt2);
	ans = cnt1 + cnt2 - 1;
	int l = cnt1 , r = 1;
	for(r = 1 ; r <= cnt2 ; r ++) {
		while(sum1[l] + sum2[r] > m) l --;
		if(sum1[l] && sum2[r]) ans += (l - 1);  
	} 
	printf("%lld\n" , ans);
	return 0;
}
```

---

## 作者：MY（一名蒟蒻） (赞：7)

[P4799 [CEOI2015 Day2]世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)

咕了好久的题终于切掉了。

**第一道紫题祭！**

本蒟蒻是看了[xgf](https://www.luogu.com.cn/user/125901)巨佬的[博文](https://www.luogu.com.cn/blog/heartme123/zhe-ban-sou-suo)写的这题。sto xgf orz

折半搜索就是**将要搜索的区间~~五五开~~对半分，分别进行搜索**，把两边结果存下来，然后用两半搜出来的结果凑出最终结果。

这种题直接爆搜会搜爆，一般都是**指数级复杂度**。

折半搜索应运而生，可以将指数减半。

### 特点：数据范围有一个较小，其他很大。
这个较小的一般就是复杂度指数。

---
回到本题，明显的搜索。但是直接搜的话，对于每一场比赛有选和不选两种选择，所以复杂度最高到$O(2^{40})$。瞬间爆炸。

考虑折半搜索。

预算是$m$，那么一半是$s$，另一半就是$(m-s)$。

那么对于$s$，另一半的所有结果中总和小于等于$(m-s)$的全部计入答案。

**数据结构使用`vector`。因为我们不知道结果到底有多少个，害怕炸空间；~~其次好看啊~~**

注释详见代码。

### Code
```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long ll;

ll n,m,price[50],ans;
vector <ll> a,b;

void dfs(int l,int r,ll sum,vector <ll> &v)
{
	if(sum > m) return ;
	if(l > r) {v.push_back(sum); return ;}//存储结果 
	dfs(l+1,r,sum+price[l],v);//看比赛 
	dfs(l+1,r,sum,v);//不看比赛 
	return ;
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&price[i]);
	int mid=(n+1) >> 1;//折半 
	dfs(1,mid,0,a); dfs(mid+1,n,0,b);
	sort(a.begin(),a.end());//有序才能二分 
	for(int i=0;i<(int)b.size();i++)//upper_bound二分降低复杂度
		ans+=upper_bound(a.begin(),a.end(),m-b[i])-a.begin();//vector下标从0开始，不用减1 
	printf("%lld",ans); 
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```
## Thanks for reading!

---

## 作者：Lynkcat (赞：5)

仔细审视这个问题，发现这个问题具有折半搜索能解决的问题的一个特点，两边的答案能够进行合并。

这也是所有折半搜索题中最关键的部分。

可以发现对于第二部分搜索时，搜索出一个状态 $sum$ ，它必然能与前半部分小于等于 $M-sum$ 的状态组合成一种答案，于是我们考虑先将前半部分所有状态扔进一个 $Vector$，进行排序，排序结束后在后半部分搜索时进行二分查找统计答案。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,dis[100],ans;
vector<int> a,b;
void dfs(int k,int sum,int tp)
{
	if (tp==1)
	{
		if (k>n)
		{
			b.push_back(sum);
			return;
		}
    } else 
    {
    	if (k>n/2)
    	{
    		a.push_back(sum);
    		return;
    	}
    }
	dfs(k+1,sum+dis[k],tp);
	dfs(k+1,sum,tp);
}
signed main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++) cin>>dis[i];
	dfs(1,0,0);
	dfs(n/2+1,0,1);
	sort(a.begin(),a.end());
	for (int i=0;i<b.size();i++)
	{
		int l,r,mid,cnt=-1;
		l=0;r=a.size()-1;
		while (l<=r)
		{
			mid=l+(r-l)/2;
			if (a[mid]<=m-b[i])
			{
				cnt=mid;
				l=mid+1;
			} else r=mid-1;
		}
		ans+=cnt+1;
	}
	cout<<ans;
}
```

---

## 作者：fzj2007 (赞：4)

再来一发~（第一篇紫题题解，请多包涵）！

## 第一步 读题

>今年的世界冰球锦标赛在捷克举行。`Bobek` 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。

>给出 `Bobek` 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。

我们要求所有的满足条件的方案。

## 第二步 思路

由于这个题比较复杂，我们按照每一个数据范围来解答。

### 第$1-2$组

$n \le {20}$，每次我们可以选择看不看这场比赛，时间复杂度 $O\left(2^n\right)$，放心爆搜即可，时间肯定超不了。

### 第$3$组

$n \le 30$，$m \le 10^6$。如果使用上面的爆搜做法显然是要超时。我们发现数据突然把 $m$ 的时间复杂度降下来了，什么意思呢？较为显然，这一组用01背包即可，直接套板子。时间复杂度 $O\left(nm\right)$，不会超时。 

### 第$4$组

$n \le 40$，$m \le 10 ^ {18}$。如果没有这组数据，这个题最多也就评一个绿。可以按照 $n$ 与 $m$ 的取值来分类讨论。现在出了这么一组毒瘤的东西，我们发现这么做用普通的爆搜或背包肯定过不了的。需要其他算法吗？好像没有找到合适的算法来解决这个类似背包的问题。那么我们就考虑优化。我们发现01背包是无法优化这么多的，那么我们就考虑搜索优化。由于这一组的 $n$ 的范围恰好是第 $1-2$ 组范围的两倍，我们希望把搜索的范围缩小一半。也就是时间复杂度要在 $O\left(2^{\frac{n}{2}}\right)$ 以内。

这样，我们的正解就浮出水面了（~~突然感觉像侦探在破案~~）： **折半搜索**。

具体方法为：

- 我们先把数据分为前后两部分，分别进行搜索，用两个数组分别存储每次的答案。

- 折半搜索的统计/组合答案是最复杂的部分，~~我调了好几次才对..~~。这个题我们应该如何统计呢？**先将第一个数组排序，然后枚举第二个数组的每一个数，设为 $w$，在第一个数组中寻找第一个与 $w$ 的和大于 $m$ 的数的位置**。这里大家有可能比较晕乎，那我们就举例子说明。

比如第一个数组为 $a$（这是有序的），第二个数组为 $b$，例如 $b_i = 500$， $m=1000$，则在 $a$ 数组中找到第一个数 $a_j$，可以使 $a_j+b_i\gt1000$，然后由于第一个数组有序，所以我们累加 $j-1$ （由于最后一个大于 $1000$了）。上面的查找部分可以用一个函数来搞定。

## 第三步 函数讲解

关于第二步最后的那个函数，名为 `upper_bound`，这里有一个[讲解](https://blog.csdn.net/qq_40160605/article/details/80150252)，如果觉得不够详细~~可以百度优先搜索~~，这里不再赘述。

## 第四步 代码

终于到了大家最喜欢的代码环节了......（注意，不要尝试提交，我给了一个小小的坑~）

```
//#include<bits/stdc++.h>
#define ll long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define re register
using namespace std; 
using std::cin;
using std::cout;
using std::endl;
namespace IN{//快读，跳过，需要的话去泥古日报
    const int MAX_INPUT = 1000000;
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,MAX_INPUT),p1==p2)?EOF:*p1++)
    char buf[MAX_INPUT],*p1,*p2;
    template<typename T>inline bool read(T &x) {
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
        	ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {
       return read(a)&&read(args...);
    }
    #undef getc
}

namespace OUT{//快写，跳过
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
    	for(register int i=0;i<s.length();i++) putc(s[i]);
	}
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);put(ch,args...);
    }
}
using IN::read;
using OUT::put;
using OUT::putc;
using OUT::putstr;
//声明一大堆
#define maxn 55
const ll N=1<<25;//一定要声明足够大
ll n,m,p[maxn],mid,a[N],b[N],c1,c2,ans;//n,m,p读入，mid存储中间，a存储前半部分答案，b存储后半部分答案，c1,c2分别表示前半部分、后半部分的答案数量，ans表示最终的答案
void dfs(re int l,re int r,re ll sum,ll t[],re ll &cnt){//这里传了数组，不懂可以去百度一下，这个也可以传数组，但是你就要写两个dfs了...（其实是我懒）
	if(sum>m) return;//如果超过了，就直接返回，因为不合法
	if(l>r){//如果已经枚举够了，且合法（上面一行已经判断，不合法的已经被筛了）就记录并返回。
		t[++cnt]=sum;
		return;
	}
	dfs(l+1,r,sum+p[l],t,cnt);//选择
	dfs(l+1,r,sum,t,cnt);//不选
}
int main(int argc, char const *argv[]){
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    read(n,m);//读入，特质读入，想读几个就读几个~
    mid=n>>1;//位运算，除2
    for(re int i=1;i<=n;i++) read(p[i]);//读入
    dfs(1,mid,0,a,c1);//前半部分
    dfs(mid+1,n,0,b,c2);//后半部分
    sort(a+1,a+c1+1);//排序
    for(re int i=1;i<=c2;i++) ans+=upper_bound(a+1,a+c1+1,m-b[i])-a-1;//公式计算
    put(ans);//输出
    return 0;//下次见~
}
```
这道题就讲到这里了，如果还有不会的地方可以私信我（~~不过不一定能够准时回消息~~）。觉得有帮助，就帮忙点个赞吧。撰文不易，大佬轻喷！下次见！

---

## 作者：D2T1 (赞：3)

[$\color{blue}{\text {pwp }{\to\textbf{My blog}\gets}}\text{qwq}$](https://www.luogu.com.cn/blog/390770/blogcenter)

## 题解

数据范围 $n \leq 40$，普通搜索会超时，选用折半搜索。

折半搜索的思路其他dalao已经讲得很清楚了，我来讲一讲一些细节。

先上代码。

```
//P4799
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;
typedef long long ll;
vector<ll> lv,rv; //存储每一种方案最终花费的钱 
ll tic[50],n,m,ans,mid;

inline void dfs(ll l,ll r,ll sum,vector<ll> &v){
	if(sum>m) return;
	if(l>r) { v.push_back(sum); return; } //搜出了一种方案 
	dfs(l+1,r,sum+tic[l],v),dfs(l+1,r,sum,v); //选或不选 
	return;
}

int main(){
	scanf("%lld%lld",&n,&m),mid=n>>1;
	for(ll i=1; i<=n; ++i) scanf("%lld",&tic[i]);
	dfs(1,mid,0,lv),dfs(mid+1,n,0,rv);
	sort(lv.begin(),lv.end());
	for(ll i=0; i<rv.size(); ++i)
		ans+=upper_bound(lv.begin(),lv.end(),m-rv[i])-lv.begin();
	printf("%lld",ans);
	return 0;
}
```

一些要点：

- `vector` 中存储的是每一种方案最终花费的钱

- 如果 `l>r`，代表已经搜出了一种方案，就将这种方案最终花费的钱（`sum`）放入对应的 `vector` 中。

- 每一个物品有两种方案：选或不选

---

## 作者：newbie666 (赞：2)

一道折半搜索好题。

看了一下题面，认为这道题不是一道裸背包的题目，不一会写出来，然后数据范围都没看就交上去了，下面贴一下背包代码。
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define SIZE 1000005
#define int unsigned long long
using namespace std;
int n,m,w[SIZE],f[SIZE],ans;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie();
	cin>>n>>m;
	for(register int i=1;i<=n;i++) cin>>w[i];
	f[0]=1;
	for(register int i=1;i<=n;i++){
		for(register int j=m;j>=w[i];j--){
			f[j]+=f[j-w[i]]; //计数类01背包板子
		}
	}
	for(register int i=0;i<=m;i++) ans+=f[i]; //最后统计答案，将所有的可行方案都累加
	cout<<ans;
	return 0;
}
```
这样，你就可以拿了50分！

现在，你会觉得用暴搜，但空间与时间不让你过去，这时候我们发现每个比赛只有两种情况，看和不看，这样搜索时间复杂度是 $O(2^n)$ ，肯定过不了。

于是折半搜索法就可以用到了。

思想：我们现在可以将所有比赛的序列分成两个部分，分别对这两部分进行搜索，然后用数组来存储可能的方案与花费，在排序使其有序，最后用在合并，二分搜索查找可行解，统计答案累加，得出最终的答案。

放个代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#define SIZE 105
#define int unsigned long long
using namespace std;
int n,m,w[SIZE],ans=0;
vector<int> a,b;
void dfs_1(int st,int ed,int sum){ //统计左边界可能发生的最小花费，用a来存。 
	if(sum>m) return; //如果说你的花费大于了预算花费，即不符合，退出 
	if(st>ed){
		a.push_back(sum); //如果左指针大于右指针，即都遍历完了，统计存放数组 
		return;
	}
	dfs_1(st+1,ed,sum),dfs_1(st+1,ed,sum+w[st]); //选或不选 
	return;
}
void dfs_2(int st,int ed,int sum){ //统计右边界可能发生的最小花费，用b来存
	if(sum>m) return;
	if(st>ed){
		b.push_back(sum);
		return;
	}
	dfs_2(st+1,ed,sum),dfs_2(st+1,ed,sum+w[st]);
	return;
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie();
	cin>>n>>m;
	for(register int i=1;i<=n;i++) cin>>w[i];
	dfs_1(1,n>>1,0),dfs_2(n>>1|1,n,0); //折半搜索 
	
	sort(a.begin(),a.end()); //排序 
	
	for(register int i=0;i<b.size();i++) 
		ans+=upper_bound(a.begin(),a.end(),m-b[i])-a.begin(); //二分查找找到花费比剩下钱还少的方案数,累加答案 
	
	cout<<ans;
	return 0;
}
```

---

## 作者：fls233666 (赞：2)

认真分析此题，我们发现，此题关键在于 $N$。我们发现，相对于其它数据，$N$ 的数据范围很小，只有 $1 \le N \le 40$。于是，我们第一个想到的就是暴力搜索。具体方案是，**枚举每一场比赛看或者不看，然后统计方案数**。那么，我们初步实现的代码如下：

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define rgt register ll
using namespace std;
ll n,m,p[44],ans;
void dfs(ll b,ll s){  //b 指第b场比赛，s为当前总金额
    if(s>m)   //小剪枝：如果当前方案比总金额大，删除此方案
        return;
    if(b>n){
       ans++;  //统计方案数
       return;
    }
    dfs(b+1,s);   //选择不看，不买票
    dfs(b+1,s+p[b]);   //选择看，买票
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(rgt tp,i=1;i<=n;i++)
        scanf("%lld",&p[i]);
        
    dfs(1,0);
    printf("%lld",ans);
    return 0;
}
```

好了，我们来分析一下此算法的时间复杂度。我们发现，这个算法的时间复杂度是 $O(2^N)$，可以过前四个 Subtask，而 $N$ 最大是 $40$，$O(2^{40})$ 肯定是过不去的。那么我们开始考虑优化这段代码。


------------


我们发现，如果我们先枚举前一半的比赛看或不看，记录方案，再枚举后一半的比赛看或不看，统计总和的方案，那么时间复杂度会被优化到 $O(2^{\frac{N}{2}})$。当 $N=40$ 时，$O(2^{20})$ 是可以通过此题的。这就是传说中的**折半搜索**。

有了优化的思路后，我们进一步分析，发现整合前一半搜索得到的结果与后一半搜索得到的结果这个过程是很费时间的。因此，我们可以先把前一半搜索得到的价格结果进行**从小到大排序**，当在后一半搜到一个方案时，**从大到小寻找第一个匹配的之前的方案**，找到后，这个方案的数组下标 $+1$ 就是它对答案的贡献。这里有一张图~~生动形象地~~解释了这个过程。

![剪枝优化理解1](https://cdn.luogu.com.cn/upload/image_hosting/1svm0t4u.png)

对应实现得到的代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define rgt register ll
using namespace std;
ll n,m,p[44],ans,f[1<<20],lf;

void dfs1(ll b,ll s){   //搜索前半部分
    if(s>m)
        return;
    if(b>n/2){  //过半，存储方案
        f[lf]=s;
        lf++;
        return;
    }
    dfs1(b+1,s);
    dfs1(b+1,s+p[b]);
}

void dfs2(ll b,ll s){  //搜索后半部分
    if(s>m)
        return;
    if(b>n){
    //比较，匹配方案
        for(rgt i=lf-1;i>=0;i--){
            if(f[i]+s<=m){  //找到第一个可以匹配的
                ans+=i+1;  //更新答案
                break;
            }
        }
        return;
    }
    dfs2(b+1,s);
    dfs2(b+1,s+p[b]);
}

int main(){
    scanf("%lld%lld",&n,&m);
    for(rgt tp,i=1;i<=n;i++)
        scanf("%lld",&p[i]);
    dfs1(1,0);
    sort(f,f+lf);  //排序优化
    dfs2(n/2+1,0);
    printf("%lld",ans);
    return 0;
}
```

然后你会发现，这个代码还是只能过四个 Subtask。

看来要进一步优化。


------------


我们发现，问题还是出在匹配部分：

```cpp
for(rgt i=lf-1;i>=0;i--){
     if(f[i]+s<=m){  
         ans+=i+1;
         break;
     }
}
```

它还是太慢了，怎么办？

既然按顺序找太慢，而数据又是排序过的，那么直接**二分查找**就行了。

于是上面这段直接变成了一行代码：

	ans+=upper_bound(f,f+lf,m-s)-f;
   
至于为什么要用 upper_bound，同样给一张图来解释。

![剪枝优化理解2](https://cdn.luogu.com.cn/upload/image_hosting/xvy9a3bv.png)

那么最终的完整 AC 代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define rgt register ll
using namespace std;
ll n,m,p[44],ans,f[1<<20],lf=0;
  
void dfs1(ll b,ll s){
    if(s>m)
        return;
    if(b>n/2){
        f[lf]=s;
        lf++;
        return;
    }
    dfs1(b+1,s);
    dfs1(b+1,s+p[b]);
}
  
void dfs2(ll b,ll s){
    if(s>m)
        return;
    if(b>n){
        ans+=upper_bound(f,f+lf,m-s)-f;
        return;
    }
    dfs2(b+1,s);
    dfs2(b+1,s+p[b]);
}
  
int main(){
    scanf("%lld%lld",&n,&m);
    for(rgt tp,i=1;i<=n;i++)
        scanf("%lld",&p[i]);
    dfs1(1,0);
    sort(f,f+lf);
    dfs2(n/2+1,0);
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：ListenSnow (赞：1)

## 题意

给定 $n$ 个正整数，选择其中的一些数，使得这些数的和 $\leq m$，其中 $m \leq 10^{18}$。求总共有多少个不同的选择方案满足要求。如果存在一种方案观看某场比赛，而另一种方案不观看，则认为这两种方案不同。

## 思路

看到题目中要求的是选数方案，可以考虑用搜索求解，枚举每一个数选与不选，最终的时间复杂度就为 $O(2^n)$。但是本题的 $n \leq 40$，显然朴素的搜索无法通过。于是需要考虑剪枝。

发现题目中的选数没有一定的先后顺序，那么就可以用类似于**双向搜索** 的思想，从前后同时开始选。事实上，如果仅把原搜索分成前后两个搜索子区间，时间复杂度也就降到了 $O(2^{\frac{n}{2}})$，可以通过本题。

于是就可以先分别搜索前后两个子区间，同时记录所有的选数方案得到的数字之和。

最后是统计答案，朴素的做法是分别枚举前后两个子区间的选数方案。但是这样做时间复杂度又退化回了 $O(2^n)$。显然需要优化。

可以发现，如果在前半区间的方案 $a$ 和在后半区间的方案 $b$ 的选数之和满足题意，那么所有在前半区中数字之和比方案 $a$ 小的方案也满足题意。也就可以对题目中的一个半区按选数之和从小到大排序，再依次枚举另一个半区之间的方案(记当前枚举的方案的数字之和为 $s_i$)，用**二分查找**快速找到排序后的半区内第一个数字之和 $> m-s_i$ 的方案（因为可能存在数字之和相同的方案）。那所有数字之和小于它的方案就可行了。

最后，别忘了开 **long long**。

## code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define ll long long
const int N=22;
int n,cnta,cntb;
ll m,t[N<<1],ans,a[1<<N],b[1<<N];
void dfs(int now,int maxn,ll val,ll s[],int &cnt)
{
	if(now>maxn)
	{
	    s[++cnt]=val;
	    return ;
	}
	dfs(now+1,maxn,val,s,cnt);
	dfs(now+1,maxn,val+t[now],s,cnt);
}
int main()
{
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&t[i]);
	dfs(1,n/2,0ll,a,cnta);
	dfs(n/2+1,n,0ll,b,cntb);
	sort(a+1,a+cnta+1);
	for(int i=1;i<=cntb;i++) ans+=upper_bound(a+1,a+cnta+1,m-b[i])-a-1;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：ljk123 (赞：1)

# 世界冰球锦标赛题解

折半搜索裸题

我们可以先枚举前一半的所有方案，总共有$2^{20}=1048576\approx 1000000$种，

(注意数组大小要大于1048576，~~作者第一次提交就只开了1000000，锅了~~）

用一个数组c储存并排序。

在枚举后一半的方案，设其费用为w，

按w从大到小排序，

用一个单调指针维护c数组中小于等于m-w的方案个数，

ans累加方案个数。

(w从大到小，m-w从小到大，指针单调右移）

当然你也可以离散化后用前缀和(~~太麻烦了，不写~~)，

或者排序后用upper_bound（~~多此一举~~）

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e6+6;
int l=1,n1,n2,n,num1=0,num2=0;
ll t,m,ans=0,a[N],b[N],c[N],d[N];
inline ll read(){
   ll T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
void dfs(int x,ll y,int z,ll p[],ll q[],int &num){
     if(y>m) return;
     if(x>z){p[++num]=y; return;}
     dfs(x+1,y,z,p,q,num),dfs(x+1,y+q[x],z,p,q,num);
}
int main(){
    n=read(),m=read(),n1=(n>>1),n2=n-n1;
    for(int i=1;i<=n1;++i) a[i]=read();
    for(int i=1;i<=n2;++i) b[i]=read();
    dfs(1,0,n1,c,a,num1),sort(c+1,c+num1+1);
    dfs(1,0,n2,d,b,num2),sort(d+1,d+num2+1);
    for(int i=num2;i>=1;--i){
        t=m-d[i];
        while(l<=num1&&c[l]<=t) ++l;
        ans+=1ll*(l-1);
    } 
    printf("%lld\n",ans);
    return 0;
} 
```


---

## 作者：AlanSP (赞：1)



之前一直以为折半类型是很难的算法，今天也来尝试一波。

## 1.概述

折半搜索，又称meet in the middle，通常是把不能直接做的题目分成两半。

把这两半分别搜索。

比如$O(2^n)$的做法，有时可以分解为$O(2*2^{\frac n 2})$，但是要考虑合并的复杂度。

合并时可以通过排序，使一部分有序，再通过二分或其他做法合并答案。

其实折半状压也是运用类似的思想。

可以解决一些统计方案，但爆搜会T的题目

---

## 2.例题

### P4799 [CEOI2015 Day2]世界冰球锦标赛

> Bobek有M元钱，共有N场比赛，每场比赛的门票都有一个价格 ![[公式]](https://www.zhihu.com/equation?tex=C_i) 。
> 问在总票价不超过M元钱的情况下，Bobek共有多少种不同的观赛方案。
> 注1：若方案1中观看了某场比赛，方案2中未观看该场，则认为两种方案不同。
> 注2： ![[公式]](https://www.zhihu.com/equation?tex=1%5Cle+N%5Cle40%2C1%5Cle+M+%5Cle+10%5E%7B18%7D%2CC_i%5Cle10%5E%7B16%7D) 。

折半搜索模板。

只需要拆成两部分，二分查找合适的就行。

注意相等的可以取，所以要用upper_bound查找，数量减一。

但因为vector的下标从0开始，所以就不用了。

---

**Code：**

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
#define int long long
vector<int> a, b;
int n, m, A[59], ans;
inline void dfs(int l, int r, int sum, bool sign)
{
	if (sum > m)
		return;
	if (l > r)
	{
		if (!sign)
			a.push_back(sum);
		else
			b.push_back(sum);
		return;
	}
	dfs(l + 1, r, sum + A[l], sign);
	dfs(l + 1, r, sum, sign);
}

signed main()
{
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%lld", &A[i]);
	dfs(1, n / 2, 0, 0);
	dfs(n / 2 + 1, n, 0, 1);
	sort(a.begin(), a.end());
	for (int i = 0; i < b.size(); i++)
		ans += upper_bound(a.begin(), a.end(), m - b[i]) - a.begin();
	printf("%lld", ans);
	return 0;
}
```

---



---

## 作者：raincity (赞：0)

## 分析
看上去非常的背包，然后发现这个背包的容量特别大，物品的数量特别小，所以使用折半搜索的方法。

假设我们分成前 $B$ 个物品和后 $N-B$ 个物品。

对于前 $B$ 个物品，暴力搜索出所有可行（价格之和小于等于 $M$） 的方案，存入数组 $h$。

将 $h$ 排序，然后对于后 $B$ 个物品，暴力搜索出所有可行（价格之和小于等于 $M$） 的方案，然后在 $h$ 中二分查找最后一个可行的方案，累加答案。

时间复杂度 $O(2^B\times B+2^{N-B}\times(N-B))$。

取 $B=\dfrac{N}{2}$ 当然可以，但是把价格从大到小排序然后取 $B$ 略大于 $\dfrac{N}{2}$ 会快一些。

实测 $B=\dfrac{N}{2}+2$ 最快。

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long

using namespace std;

long long ans, m, c[45], h[(1 << 22) + 5];
int cnt, n, b;

void dfs1(int step, long long val) {
	if (step == b + 1) {
		h[++cnt] = val;
		return;
	}
	dfs1(step + 1, val);
	if (val + c[step] <= m)
		dfs1(step + 1, val + c[step]);
}

void dfs2(int step, long long val) {
	if (step == n + 1) {
		ans = ans + upper_bound(h + 1, h + cnt + 1, m - val) - h - 1;
		return;
	}
	dfs2(step + 1, val);
	if (val + c[step] <= m)
		dfs2(step + 1, val + c[step]);
}

signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> c[i];
	sort(c + 1, c + n + 1);
	reverse(c + 1, c + n + 1);
	b = min((n >> 1) + 2, n - 1);
	dfs1(1, 0);
	sort(h + 1, h + cnt + 1);
	dfs2(b + 1, 0);
	cout << ans << endl;
	return 0;
}

```

---

## 作者：丛雨 (赞：0)

### 世界冰球锦标赛

看到大家写的都是$2^nn$的，来水一发$2^n$的

数据规模$N\leq 40$，不难想到折半搜索

如果我们直接预处理前$\frac{N}{2}$位，再搜索后面的位，则可以得到$2^nn$的算法

考虑进一步优化

我们假设已经处理并排序好了前x位，得到序列$A$，现在要处理出有第x+1位的情况序列$B$

由于$B_i=A_i+a_{x+1}$，所以$B$也为有序数列，则我们直接进行归并即可

处理n位的时间复杂度为$T(n)=T(n-1)+2^n$，此处时间复杂度为$O(2^\frac{n}{2})$

处理前部分和后部分后直接two-points即可

```cpp
#include<bits/stdc++.h>
using namespace std;
# define ll long long
# define read read1<ll>()
# define Type template<typename T>
Type T read1(){
	T t=0;
	char k;
	bool vis=0;
	do (k=getchar())=='-'&&(vis=1);while('0'>k||k>'9');
	while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
	return vis?-t:t;
}
# define fre(k) freopen(k".in","r",stdin);freopen(k".out","w",stdout)
# define N 1048576
# define ull unsigned ll
ull a[N],b[41],c[N],v,t;
int s;
int main(){
	s=read;v=read;
	for(int i=0;i<s;++i)b[i]=read;
	int n=s>>1,m=s-n,S=1<<n;
	for(int i=0;i<n;++i){
		int x=1<<i,y=1<<i,t=1<<i+1;
		while(x||y)
			if(!y||x&&a[y-1]<a[x-1]+b[i])a[--t]=a[--x]+b[i];
			else a[--t]=a[--y];
	}ull *d=b+n;
	for(int i=0;i<m;++i){
		int x=1<<i,y=1<<i,t=1<<i+1;
		while(x||y)
			if(!y||x&&c[y-1]<c[x-1]+d[i])c[--t]=c[--x]+d[i];
			else c[--t]=c[--y];
	}
	for(int i=1<<m,j=0;i--;){
		while(j<S&&a[j]+c[i]<=v)++j;
		t+=j;
	}cout<<t;
	return 0;
}


```

---

## 作者：keep_ (赞：0)

#  P4799 【[CEOI2015 Day2]世界冰球锦标赛】 (折半搜索)

## part1 40points

暴力的40分是很好写的,直接搜就行

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#define int long long
using namespace std;
const int maxn=1e6;
int n,m;
int a[maxn];
int ans=1;
void dfs(int x,int la){
	if(la-a[x]<0){
		return ;
	}
	ans++;
	for(int i=x+1;i<=n;i++){
		dfs(i,la-a[x]);
	}
	return ;
}
signed main(){
//	ios::sync_with_stdio(false);
//	freopen("a.in","r",stdin);
	cin>>n;
	cin>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		dfs(i,m);
	}
	cout<<ans;	
	return 0;
}
 
```

## pasrt2 100points

我们来考虑100分的做法，很明显，暴力是无法处理这么大的数据的我们

来考虑对其进行优化，这里就要折半搜索了

折半搜索是针对暴力搜索的优化算法，本质上来说就是把搜索区间分为两

半，分开计算来优化时间复杂度，折半搜索的条件是分开搜索的结果可以

进行合并，针对此题，我们可以将查询区间一分为二, $1- mid$  , $mid+1 -n$ 

分别进行暴力搜索，我们用 $a,b$ 数组存储两次搜索的结果，即每个区间

符合条件的所有花费

最后我们将 $a$ 数组从大到小排序，针对b里的每一个值 $bi$，我们在a数组里查询第一个大于$m-
bi$的数的下标，答案加上下标减一的值，为什么要这么做？针对有序的$a$数组，对于每一个$bi$

我们所查找的下标减1的值就是$a$数组中与$bi$相加$<=m$的数的个数，

所以也有这么多方案是符合题意的。

为什么要查找第一个大于$m-bi$的数的下标？因为小于其下标的每一个值

加上$bi$的值一定小于等于$m$，但我们不知道a数组中是

否有$m-bi$，所以需要查找第一个大于它的数的下标减一，最后把答

案加起来即可，可能听起来有点迷糊，直接看代码要清晰许多。

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=5e6;
inline int read(){
	int f=1;
	int ret=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-f;
		ch=getchar();
	}	
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return ret*f;
}
int n,m;
int cnt1;
int cnt2;
int a[maxn];
int b[maxn];
int v[maxn];
void dfs1(int id,int mx,int sum){
	if(sum>m){
		return ;
	} 
	if(id>mx){
		a[++cnt1]=sum;
		return ;
	}
	dfs1(id+1,mx,sum+v[id]);
	dfs1(id+1,mx,sum);
}
void dfs2(int id,int sum){
	if(sum>m){
		return ;
	}
	if(id>n){
		b[++cnt2]=sum;
		return ;
	}
	dfs2(id+1,sum+v[id]);
	dfs2(id+1,sum);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		v[i]=read();
	}
	int mid=n>>1;
	dfs1(1,mid,0);
	dfs2(mid+1,0);
	sort(a+1,a+1+cnt1);
	int ans=0;
	for(int i=1;i<=cnt2;i++){
		ans+=upper_bound(a+1,a+1+cnt1,m-b[i])-a-1;
	}
	cout<<ans;
	return 0;
}
```
原本搜索的时间复杂度为 $O(2^n)$

优化为 $O(2^\frac{n}{2})$

但最后需要加上合并的时间复杂度

---

## 作者：Joker_M (赞：0)

~~蒟蒻的第一篇题解 QAQ~~  
题目大意：从n件物品中选出若干件，使这些物品的总价值小于等于m，求总的方案数。  
思路：~~窝会爆搜！~~  
枚举n件物品的子集，每次搜索时总方案+1，当价值超出限制时直接退出。
```cpp
void dfs(int x,long long sum){//当前选到第x件物品（x已经选了），共花费sum元 
	ans++;
	for(register int i=x+1;i<=n;i++){
		if(visit[i])	continue;
		if(sum+money[i]>m)	continue;//若超出m的限制就不选 
		visit[i]=1;
		dfs(i,sum+money[i]);//选择第i件
		visit[i]=0;
	}
	return ;
}
```
~~然后我们就可以拿到40分的好成绩~~  
枚举子集的复杂度是 $\mathcal{O}$($2^n$) ，无法满足 $n\le40$ 的数据，但由于40依旧较小，可以考虑使用双向搜索进行优化。  
具体操作：将n件物品平分为两部分，先对前一部分进行搜索（枚举子集），将所有可能情况的价值总和存入一个动态数组（vector）中，如下：
```cpp
void dfs_1(int x,long long sum){//选到第x件物品（x已经选了），共花费sum元 
	num.push_back(sum);//将该情况的价值和存入数组 
	for(register int i=x+1;i<=mid;i++){
		if(visit[i])	continue;
		if(sum+money[i]>m)	continue;//若超出m的限制则不选 
		visit[i]=1;
		dfs_1(i,sum+money[i]);//选择第i件
		visit[i]=0;
	}
	return ;
}
```
再对后半部分物品进行一次搜索，对于每一次搜索到的价值和 sum ，到 num 数组中寻找满足 $num[i]+sum\le m$ 的个数并累加到答案中，对于这个寻找的过程，我们可以将 num 数组排序后使用二分查找进行优化。

```cpp
void dfs_2(int x,long long sum){
	ans+=upper_bound(num.begin(),num.end(),m-sum)-num.begin();
//在num中查找第一个大于 m-sum 的数，则该数前面的所有数字都符合 num[i]+sum<=m 的要求，一起累加到 ans 中 
	for(register int i=x+1;i<=n;i++){
		if(visit[i])	continue;
		if(sum+money[i]>m)	continue;
		visit[i]=1;
		dfs_2(i,sum+money[i]);
		visit[i]=0;
	}
	return ;
}
```
细节：第一次搜索从0开始，第二次搜索从 mid 开始  
贴上总的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

int n,m,mid;
long long ans,money[50];
vector<long long> num;
bool visit[50];

inline long long read(){
	long long re=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')	ch=getchar();
	while(ch>='0'&&ch<='9')	re=re*10+ch-'0',ch=getchar();
	return re;
}

void dfs_1(int x,long long sum){
	num.push_back(sum);
	for(register int i=x+1;i<=mid;i++){
		if(visit[i])	continue;
		if(sum+money[i]>m)	continue;
		visit[i]=1;
		dfs_1(i,sum+money[i]); 
		visit[i]=0;
	}
	return ;
}

void dfs_2(int x,long long sum){
	ans+=upper_bound(num.begin(),num.end(),m-sum)-num.begin();
	for(register int i=x+1;i<=n;i++){
		if(visit[i])	continue;
		if(sum+money[i]>m)	continue;
		visit[i]=1;
		dfs_2(i,sum+money[i]);
		visit[i]=0;
	}
	return ;
}

int main(){
	n=read(),m=read();
	mid=n>>1;
	for(register int i=1;i<=n;i++)	money[i]=read();
	dfs_1(0,0);
	sort(num.begin(),num.end());
	dfs_2(mid,0);
	printf("%lld",ans);
	return 0;
}
```
最后，一句友好的警示：
~~十年 OI 一场空，不开 long long 见祖宗。~~


---

## 作者：Link_Space (赞：0)

总的来说这道题作为一道紫题还是挺水的，也是我唯一做的两道紫题之一，题面描述很简单不过多赘述，看到此题M最大可以取到$10^{18}$，便想到折半搜索后二分来匹配前后两端，求出最终答案，以下是代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
LL Storage[1<<21];
LL Storage2[1 << 21];
LL Game[1000000];
LL n, w,cnt,sum;
LL ans;
void dfs(int x,LL s)
{
	if (x == n / 2 + 1)
	{
		Storage[++cnt]= s;
		return;//如果已经搜完前一半，将目前已经选的比赛加起来的耗钱存起来，返回
	}
	dfs(x + 1, s);//不看该比赛
	if (s + Game[x] <= w)//如果钱够，看此场比赛
	{
		dfs(x + 1, s + Game[x]);
	}
}
void dfs2(int x, LL s)//同上
{
	if (x == n + 1)
	{
		Storage2[++sum] = s;
		return;
	}
	dfs2(x + 1, s);
	if (s + Game[x] <= w)
	{
		dfs2(x + 1, s + Game[x]);
	}
}
int main()
{
	cin >> n >> w;
	for (int i = 1; i <= n; i++)
	{
		cin >> Game[i];
	}
	dfs(1, 0);//搜索前一半
	dfs2(n / 2 + 1, 0);//搜索后一半
	sort(Storage2 + 1, Storage2 + sum + 1);//将后一半的搜索结果排序
	for (int i = 1; i <= cnt; i++)//枚举前一半的所有结果
	{
		LL l = 0, r = sum, mid;
		LL all=0;
		while (l <= r)
        //搜寻到后一半中能与前一半的当前方案
        //融合在一起的最后一种方案
		{
			mid = l + (r - l) / 2;
			if (Storage[i] + Storage2[mid] <= w)
			{
				all = mid;
				l = mid + 1;
			}
			else
				r = mid - 1;
		}
		ans+=all;
      //  由于前面已经将后一半排序，
      //  故当前这个最大的后一半的方案及其之前的所有
      //  后一半的方案都能和现在枚举的前一半的方案构成一种新的方案，
      //  所以答案直接累加
	}
	cout << ans;//输出答案
	return 0;
}
```


---


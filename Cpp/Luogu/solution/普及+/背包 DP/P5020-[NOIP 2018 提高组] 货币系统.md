# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# 题解

## 作者：0x3喵酱 (赞：957)

看起来这道题虽然有很多人写了题解但并没有太多严谨的数学证明。

本蒟蒻就来写一下自己考场上的思路。

我们把货币系统 $ (n,a) $ 看做集合 $ A $，货币系统 $ (m,b) $ 看做集合 $ B $。

那么我们首先可以猜测 $ B \subseteq A $ 。 

但是这个结论并不好直接证明，在证明这个猜测前我们先来证明另一个猜测** $ A $ 集合内不能被其它数组成的数必然存在于 $ B $ 集合内**，这里使用反证法证明。

---

**证明过程**

我们设 $ x\in A $ 且 $ x $ 不能被 $ A $ 集合内除它以外的元素组成。

然后我们假设 $ x \notin B $ ，那么就说明 $ B $ 集合中必然存在一些元素能够组成 $ x $ 。

那么这些元素至少存在一个不在集合 $ A $ 内并且不能被集合 $ A $ 里的元素组成的数（因为如果不存在的话集合 $ A $ 内的元素就可以组成 $ x $ 了），可以看到这与集合 $ B $ 的定义产生了矛盾。

综上所述，** $ A $ 集合内不能被其它数组成的数必然存在于 $ B $ 集合内 **。证毕。


---

通过这个结论我们便可以证明 $ B \subseteq A $ 这个猜测了。这里同样使用反证法证明。

---


**证明过程**

假设存在 $ x \in B$ 且满足 $ x \notin A $ 。

根据题目条件，$ x $ 必然可以被 $ A $ 集合内的数字所组成。

那么必然存在 $ a_1,a_2,...a_q \in A $ 可以用来组成 $ x $ 并且这些元素都不能被 $ A $ 集合内的元素组成（因为如果 $ a_i $ 能被 $ A $ 集合内其它数组成，那么必然可以用那些数来代替 $ a_i $），根据上一个结论我们可以知道 $ a_1,a_2,...a_q \in B $ 。

那么也就是说 $ x $ 可以被 $ B $ 集合内的数字组成，那么凡是可以用 $ x $ 组成的数都可以被 $ B $ 集合内的其它数字组成，那么也就是说即便从集合 $ B $ 中去掉 $ x $ 元素也依旧满足条件，这就与 $ B $ 集合的定义矛盾。

所以对于任意 $ x \in B $ 必然满足 $ x \in A $ ，即 $ B \subseteq A $。

---

那么做这道题仅仅只需要最后一个证明了，如果你到这里都看懂了的话那应该不难想到最后一个猜测就是**在 $ A $ 集合中能被其它数组成的数必然不在 $ B $ 集合内**，事实上这个结论很显然，读者只需要稍微想想便可以想出来，这里就不写证明过程了。


那么到这里做这道题的步骤就已经显而易见了，只需要计算出 $ A $ 集合中存在多少个能被其它数组成的数计算出来就行了。

比较好想的是使用搜索算法，相信各位都会，这里就不多说了。主要讲一下使用完全背包来完成这件事。

根据常识，我们知道 $ x $ 只能被比它小的数字组成而不能被比它大的数字组成。

那么很显然，我们可以首先对数组排个序，然后对于每一个数考虑能不能被它前面的数字所组成。

我们知道如果 $ x $ 能被前 $ i $ 个数组成且组成 $ x $ 的数当中包含 $ a_i $ 那么 $ (x-a_i) $ 也必然能被前 $ i $ 个数来组成，那么我们很容易想到定义 $ f(x) $ 表示 $ x $ 能否被组成，那么根据上面的想法显然有 $ f(x) = f(x) \vee f(x-a_i) $。

那么这个样子也就是最终的解法了，个人认为这道题主要考察对集合相关概念的证明，而重点并不是动态规划，其它的题解侧重点都不太对。

最后贴出AC代码：

```cpp
#include<stdio.h>
#include<algorithm>
#include<string.h>
using namespace std;
#define MAXAI 25005
#define MAXN 105
int f[MAXAI];
int a[MAXN];
int main()
{
    //freopen("money.in","r",stdin);
    //freopen("money.out","w",stdout);
    int i,j,n,T,ans;
    scanf("%d",&T);
    while(T--)
    {
        memset(f,0,sizeof(f));
        scanf("%d",&n);ans=n;
        for(i=1;i<=n;i++) scanf("%d",&a[i]);
        sort(a+1,a+n+1);
        f[0]=1;
        for(i=1;i<=n;i++)
        {
            if(f[a[i]])
            {
                ans--;
                continue;
            }
            for(j=a[i];j<=a[n];j++)
            {
                f[j]=f[j]|f[j-a[i]];
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```


---

## 作者：NaCly_Fish (赞：282)

这是一道用来学习生成函数的好题。  

所谓生成函数，可以理解为对于一个数列 $a$，构造一个函数：  
$$\large F(x)=a_0+a_1x+a_2x^2+...= \sum\limits_{i=0}^\infty a_ix^i$$  
这就是 `普通生成函数` ( OGF )，可以用来计算组合，也就是无序的情况，正符合本题的要求。  

那这个东西怎么用呢？  

比如有一种货币面值是 $3$，它可以表示所有 $3$ 的倍数的面值，方案为 $1$ 种。如果把它写成数列就是 $1,0,0,1,0,0,1,0,0...$ 

所以其方案数生成函数就是  
$$\large\sum\limits_{i=0}^\infty x^{3i}$$  
考虑又有一种货币，面值是 $2$，设其方案数的生成函数是 $G(x)$。 

那么把 $F(x)$ 和 $G(x)$ 乘起来，得到的就是有 $2,3$ 两种货币时的生成函数了！  

于是我们把所有货币按面值升序排序，对应构造其生成函数，依次乘起来判断即可。    

设一开始的答案为 $n$。比如我们已经把前面 $i-1$ 个物品的生成函数乘起来了，设为 $F(x)$。  
考虑第 $i$ 个时，其面值为 $v$。如果 $[x^v]F(x)>0$，那就将答案 $-1$ 并跳过，否则就把它乘上去。

但是实际计算时多项式是不可能有无穷多项的，注意到 $\max\{a_i\}\le25000$，所以更高次的系数可以不用管它，对答案没有影响。  
于是直接做就可以了，注意做多项式乘法需要 $\Theta(n \log n)$ 复杂度的 $\texttt{FFT}$ 来实现。  

但是这样的复杂度还是不能接受，每组数据的复杂度达到了 $\Theta(nm\log m)$ ( $m$为值域 )。  

我们不妨另辟蹊径：可以把所有的生成函数取 $\ln$，加起来再做一遍 $\exp$。  

巧合的是，此题中的这类生成函数取 $\ln$ 有特殊的形式。  

$$\large \ln \sum\limits_{i=0}^\infty x^{vi}=\ln \frac{1}{1-x^v}=-\ln(1-x^v)=\int \frac{vx^{v-1}}{1-x^v} dx$$  
$$\large \frac{vx^{v-1}}{1-x^v}=vx^{v-1}\sum\limits_{i=0}^\infty x^{vi}=v\sum\limits_{i=0}^\infty x^{v(i+1)-1}$$  
把最后那个式子拿出来积分一遍就是：  
$$\large v\sum\limits_{i=0}^\infty \frac{x^{v(i+1)}}{v(i+1)}=\sum\limits_{i=0}^\infty\frac{x^{v(i+1)}}{i+1}=\sum\limits_{i=1}^\infty\frac{x^{vi}}{i}$$


如果把它们暴力加起来，复杂度还是 $\Theta(nm)$ 的。可以开个桶，记录所有面值的货币的出现次数，最后一块加起来，复杂优化到了 $\Theta(m \log m)$。  

加上最后做的一遍多项式 $\exp$，每组数据的总复杂度 $\Theta(m\log m)$。  

~~由于时限只有1s加上巨大常数，此做法TLE了，只有80分~~  
如果有什么常数非常小的写法，或许可以卡过去？

不过此做法不仅能统计有哪些货币可以被表示出来，还可以计算表示的方案数。如果此题加强一下的话，这个做法的复杂度就是最优了。

代码如下：  
```cpp
#include<cstdio> 
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#include<ctime>
#define ll long long
#define N 131077
#define LIM 131072
#define reg register
#define p 998244353
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

namespace polynomial{
#define img 86583718
#define random(a,b) ((ll)rand()*rand()%(b-a+1)+a)
    struct poly{
        int t;
        int a[N];
    };
    int lg2[N],rt[N],irt[N],inv[N],rev[N];

    inline int power(int a,int t);
    inline void NTT(poly &f,int type,int lim);
    inline void print_poly(poly f);
    inline void clear(poly &f);
    inline void reverse(poly &f);
    poly inverse(poly f);
    poly log(poly f);
    inline poly integral(poly f);
    inline poly derivative(poly f);
    poly exp(poly f);
    poly divide(poly f,poly g);
    poly mod(poly f,poly g);
    poly power(poly f,int k);
    poly sqrt(poly f);
    poly sin(poly f);
    poly cos(poly f);
    poly asin(poly f);
    poly atan(poly f);
    poly EXpower(poly f,int k);
    inline int mod_sqrt(int a);

    inline void swap(int &x,int &y){
        if(x==y) return;
        x ^= y ^= x ^= y;
    }

    inline int add(int a,int b){
        return a+b>=p?a+b-p:a+b;
    }

    inline int dec(int a,int b){
        return a<b?a-b+p:a-b;
    }

    poly mod_power(poly f,int t,poly G){
        poly h,g = f;
        int lim;
        t--;
        while(t){
            if(t&1){
                lim = 1;
                h = f;
                while(lim<=h.t+g.t) lim <<= 1;
                NTT(g,1,lim),NTT(h,1,lim);
                for(reg int i=0;i<=lim;++i)
                    g.a[i] = (ll)g.a[i]*h.a[i]%p;
                NTT(g,-1,lim);
                g.t += h.t;
                for(reg int i=g.t+1;i<=lim;++i) g.a[i] = 0;
                g = mod(g,G);                   
            }
            lim = 1;
            while(lim<=(f.t<<1)) lim <<= 1;
            NTT(f,1,lim);
            for(reg int i=0;i<=lim;++i)
                f.a[i] = (ll)f.a[i]*f.a[i]%p;
            NTT(f,-1,lim);    
            f.t <<= 1;
            for(reg int i=f.t+1;i<=lim;++i) f.a[i] = 0;
            f = mod(f,G);
            t >>= 1;
        }
        return g;
    }

    inline int mod_sqrt(int a){
        srand((ll)a*time(0)%p);
        int pw,s = p-1,t = 0;
        while(!(s&1)){
            ++t;
            s >>= 1;
        }
        int b = rand();
        while(power(b,(p-1)/2)==1) b = rand();
        int inv = power(a,p-2),x = power(a,(s+1)>>1);
        for(reg int k=0;k<t;++k){
            if(power((ll)x*x%p*inv%p,power(2,t-k-1))==1) continue;
            pw = (ll)s*power(2,k-1)%p;
            x = (ll)x*power(b,pw)%p;
        }
        return min(x,p-x);
    }

    inline void init(){
        inv[1] = 1;
        for(reg int i=2;i<N;++i)
            inv[i] = (ll)(p-p/i)*inv[p%i]%p;
        for(reg int i=2;i<N;++i) lg2[i] = lg2[i>>1]+1;    
        rt[0] = irt[0] = 1;
        rt[1] = power(3,(p-1)/LIM);
        irt[1] = power(rt[1],p-2);
        for(reg int i=2;i<=LIM;++i){
            rt[i] = (ll)rt[i-1]*rt[1]%p;
            irt[i] = (ll)irt[i-1]*irt[1]%p;
        }
    }

    inline poly EXpower(poly f,int k){
        int u,v,low = 0,n = f.t;
        for(reg int i=0;i<=n;++i){
            if(!f.a[i]) continue;
            low = i;
            break;
        }
        if(low){
            for(reg int i=low;i<=n;++i){
                f.a[i-low] = f.a[i];
                f.a[i] = 0;
            }
        }
        v = f.a[0],u = power(v,p-2);
        for(reg int i=0;i<=n;++i) f.a[i] = (ll)f.a[i]*u%p;
        f = power(f,k);   
        u = power(v,k);
        for(reg int i=0;i<=n;++i) f.a[i] = (ll)f.a[i]*u%p;
        if(low){
            if((ll)low*k>p) low = p;
            else low *= k;
            for(reg int i=n;i>=0;--i){
                if(i+low<=n) f.a[i+low] = f.a[i];
                f.a[i] = 0;
            }
        }
        return f;
    }

    poly atan(poly f){
        int lim = 1,n = f.t;
        static poly g = f;
        while(lim<=(n<<1)) lim <<= 1;
        NTT(f,1,lim);
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*f.a[i]%p;
        NTT(f,-1,lim);
        for(reg int i=n+1;i<=lim;++i) f.a[i] = 0;        
        f.a[0] = (f.a[0]+1)%p;
        f = inverse(f),g = derivative(g);
        NTT(f,1,lim),NTT(g,1,lim);
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*g.a[i]%p; 
        NTT(f,-1,lim);
        for(reg int i=n+1;i<=lim;++i) f.a[i] = 0;           
        return integral(f);
    }

    poly asin(poly f){
        int lim = 1,n = f.t;
        poly g = f;
        while(lim<=(n<<1)) lim <<= 1;
        NTT(f,1,lim);
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*f.a[i]%p;
        NTT(f,-1,lim);
        for(reg int i=n+1;i<=lim;++i) f.a[i] = 0; 
        for(int i=0;i<=n;++i) f.a[i] = dec(0,f.a[i]);
        f.a[0] = add(f.a[0],1);
        f = inverse(sqrt(f));
        g = derivative(g);
        NTT(f,1,lim),NTT(g,1,lim);
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*g.a[i]%p;
        NTT(f,-1,lim);
        for(reg int i=n+1;i<=lim;++i) f.a[i] = 0;            
        return integral(f);
    }

    poly log(poly f){
        clear(f);
        int lim = 1,n = f.t;
        poly g = derivative(f);
        f = inverse(f);
        while(lim<=(n<<1)) lim <<= 1;
        NTT(f,1,lim),NTT(g,1,lim);
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*g.a[i]%p;
        NTT(f,-1,lim);
        for(reg int i=n+1;i<=lim;++i) f.a[i] = 0;           
        return integral(f);
    }

    poly cos(poly f){
        for(reg int i=0;i<=f.t;++i)
            f.a[i] = (ll)f.a[i]*img%p;
        poly g = exp(f);
        f = inverse(g);
        for(reg int i=0;i<=f.t;++i) f.a[i] = add(f.a[i],g.a[i]);
        for(reg int i=0;i<=f.t;++i)
            f.a[i] = (ll)f.a[i]*inv[2]%p;
        return f;   
    }

    poly sin(poly f){
        for(reg int i=0;i<=f.t;++i)
            f.a[i] = (ll)f.a[i]*img%p;
        poly g = exp(f);
        f = inverse(g);
        for(reg int i=0;i<=f.t;++i) f.a[i] = dec(g.a[i],f.a[i]);
        int w = power(img<<1,p-2);
        for(reg int i=0;i<=f.t;++i)
            f.a[i] = (ll)f.a[i]*w%p;
        return f;    
    }

    poly sqrt(poly f){
        int n = f.t,top = 0,lim = 1;
        int s[70];
        poly g,h;
        memset(g.a,0,sizeof(g.a));
        while(n){
            s[++top] = n;
            n >>= 1;
        }
        if(f.a[0]==1) g.a[0] = 1;
        else g.a[0] = mod_sqrt(f.a[0]);
        while(top--){
            g.t = n = s[top+1];
            while(lim<=(n<<1)) lim <<= 1;
            h = g;
            for(reg int i=0;i<=n;++i) h.a[i] = add(h.a[i],h.a[i]);
            h = inverse(h);
            NTT(g,1,lim);
            for(reg int i=0;i<=lim;++i)
                g.a[i] = (ll)g.a[i]*g.a[i]%p;
            NTT(g,-1,lim);
            for(reg int i=n+1;i<=lim;++i) g.a[i] = 0;    
            for(reg int i=0;i<=n;++i) g.a[i] = add(g.a[i],f.a[i]);
            NTT(g,1,lim),NTT(h,1,lim);
            for(reg int i=0;i<=lim;++i)
                g.a[i] = (ll)g.a[i]*h.a[i]%p;
            NTT(g,-1,lim);
            for(reg int i=n+1;i<=lim;++i) g.a[i] = 0;        
        }
        return g;
    }

    poly exp(poly f){
        int lim = 1,n = f.t,top = 0;
        int s[70];
        poly g,h;
        memset(g.a,0,sizeof(g.a));
        while(n){
            s[++top] = n;
            n >>= 1;
        }
        g.a[0] = 1;
        while(top--){
            g.t = n = s[top+1];
            h = g,g = log(g);
            for(reg int i=0;i<=n;++i) g.a[i] = dec(f.a[i],g.a[i]);
            g.a[0] = add(g.a[0],1);
            while(lim<=(n<<1)) lim <<= 1;
            NTT(h,1,lim),NTT(g,1,lim);
            for(reg int i=0;i<=lim;++i)
                g.a[i] = (ll)g.a[i]*h.a[i]%p;
            NTT(g,-1,lim);
            for(reg int i=n+1;i<=lim;++i) g.a[i] = 0;
        }  
        return g;
    }

    poly power(poly f,int k){
        f = log(f);
        for(int i=0;i<=f.t;++i)
            f.a[i] = (ll)f.a[i]*k%p;
        return exp(f);
    }

    inline void clear(poly &f){
        for(reg int i=f.t+1;i<N;++i) f.a[i] = 0;
    }

    poly inverse(poly f){
        int n = f.t,top = 0,lim = 1;
        int s[70];
        poly g,h,q;
        memset(g.a,0,sizeof(g.a));
        while(n){
            s[++top] = n;
            n >>= 1;
        }
        g.a[0] = power(f.a[0],p-2);
        while(top--){
            g.t = n = s[top+1];
            q = g,h = f;
            for(reg int i=n+1;i<=f.t;++i) h.a[i] = 0;
            while(lim<=(n<<1)) lim <<= 1;
            NTT(g,1,lim),NTT(h,1,lim);
            for(reg int i=0;i<=lim;++i)
                g.a[i] = (ll)g.a[i]*g.a[i]%p*h.a[i]%p;
            NTT(g,-1,lim);
            for(reg int i=n+1;i<=lim;++i) g.a[i] = 0;
            for(reg int i=0;i<=n;++i)
                g.a[i] = dec(add(q.a[i],q.a[i]),g.a[i]);
        }
        return g;
    }

    poly mod(poly f,poly g){
        if(f.t<g.t) return f;
        while(!f.a[f.t]) --f.t;
        poly q = divide(f,g);
        int lim = 1,l,m = g.t;
        for(reg int i=m+1;i<=f.t;++i) f.a[i] = 0;
        f.t = m;
        l = min(q.t,m);
        for(reg int i=l+1;i<=q.t;++i) q.a[i] = 0;
        q.t = l;
        while(lim<=(q.t+g.t)) lim <<= 1;
        NTT(g,1,lim),NTT(q,1,lim);
        for(reg int i=0;i<=lim;++i)
            g.a[i] = (ll)g.a[i]*q.a[i]%p;
        NTT(g,-1,lim);
        for(reg int i=0;i<m;++i){
            f.a[i] = f.a[i]-g.a[i]+p;
            if(f.a[i]>=p) f.a[i] -= p;
        }          
        for(reg int i=m;i<=f.t;++i) f.a[i] = 0; 
        f.t = m-1;
        return f;
    }

    poly divide(poly f,poly g){
        int lim = 1,n = f.t,m = g.t;
        reverse(f),reverse(g);
        g.t = f.t = n-m+1;
        for(int i=f.t+1;i<=n;++i) f.a[i] = g.a[i] = 0;
        g = inverse(g);    
        while(lim<=(f.t<<1)) lim <<= 1;
        NTT(f,1,lim),NTT(g,1,lim);
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*g.a[i]%p;
        f.t = n-m;      
        NTT(f,-1,lim);   
        for(reg int i=f.t+1;i<=lim;++i) f.a[i] = 0;    
        reverse(f);
        return f;
    }

    inline void reverse(poly &f){
        int l = f.t>>1;
        for(reg int i=0;i<=l;++i)
            swap(f.a[i],f.a[f.t-i]);
    }

    poly integral(poly f){
        for(reg int i=f.t;i>=1;--i)
            f.a[i] = (ll)f.a[i-1]*inv[i]%p;    
        f.a[0] = 0;   
        return f;
    }

    poly derivative(poly f){
        for(reg int i=0;i<f.t;++i)
            f.a[i] = (ll)f.a[i+1]*(i+1)%p;
        f.a[f.t] = 0;    
        return f;
    }

    inline void print_poly(poly f){
        for(int i=0;i<=f.t;++i){
            print(f.a[i]);
            putchar(' ');
        }
        putchar('\n');
    }

    inline void NTT(poly &f,int type,int lim){
        int l = lg2[lim]-1;
        for(reg int i=0;i<=lim;++i){
            rev[i] = (rev[i>>1]>>1)|((i&1)<<l);
            if(i>=rev[i]) continue;
            swap(f.a[i],f.a[rev[i]]);
        }
        reg int r,w,x,y;
        l = LIM>>1;
        for(reg int mid=1;mid<lim;mid<<=1){
            r = mid<<1;
            for(reg int j=0;j<lim;j+=r){
                for(reg int k=0;k<mid;++k){
                    w = type==1?rt[l*k]:irt[l*k];
                    x = f.a[j|k];
                    y = (ll)w*f.a[j|k|mid]%p;
                    f.a[j|k] = add(x,y);
                    f.a[j|k|mid] = dec(x,y);
                }
            }
            l >>= 1;
        }
        if(type==1) return;
        w = inv[lim];
        for(reg int i=0;i<=lim;++i)
            f.a[i] = (ll)f.a[i]*w%p;
    }

    inline int power(int a,int t){
        int res = 1;
        while(t){
            if(t&1) res = (ll)res*a%p;
            a = (ll)a*a%p;
            t >>= 1;
        }
        return res;
    }
#undef img
#undef random
};
using namespace polynomial;

int st[N],b[N];
poly F;

void solve(){
    memset(F.a,0,sizeof(F.a));
    int n,m = 0,ans;
    read(n);
    ans = n;
    for(reg int i=1;i<=n;++i){
        read(b[i]);
        m = max(m,b[i]);
        ++st[b[i]]; //桶
    }
    F.t = m;
    for(reg int i=1;i<=m;++i){ //枚举面值
        if(!st[i]) continue;
        for(reg int j=1;j*i<=m;++j)
            F.a[i*j] = (F.a[i*j]+(ll)inv[j]*st[i])%p; //将物品的多项式ln加起来
        st[i] = 0;    
    }
    F = exp(F); //多项式exp
    for(reg int i=0;i<=n;++i)
        if(F.a[b[i]]>1) --ans; //如果能被多于1种方式表示,那就是多余的
    print(ans),putchar('\n');
}

signed main(){ 
    init(); 
    int T;
    read(T);
    while(T--) solve();
    return 0;
}
```

---

## 作者：xzlhxc_ed (赞：20)

**[博客中食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p5020)**  
**upd:博客地址变更，其余内容保持不变。**

------------
[题目链接（luogu）](https://www.luogu.org/problemnew/show/5020)   
预备知识：动态规划基础等。
# ①题意
给你n种货币的面值，成为A货币系统，让你求出一个货币系统B，使得B系统的货币种类不超过A系统，并且A系统能凑出的面值B系统也能凑出，A系统不能凑出的面值B系统也不能凑出。    

这道题初看感觉是一道数学题，但是如果手模一下数据的话可能会有这样的想法：货币系统B的大小既然不超过A，那么如果能用一些更小的面值代替A系统中一些更大的面值，或许就可以了。

那么B系统的面值要怎么求？

既然要保证A系统凑不出来的B系统也不行，那么最好的方法就是用A系统原有的一些货币来凑。所以我们可以猜出这样一个结论：

**在最佳决策中，必然有一种决策使得B中的面值都在A中出现过。**

前面的dalaos的证明太过强大，这里给一个比较蒟蒻的证明（如果错了请及时通知作者）。
# ②证明
尝试用数学归纳法证明。   
首先将A系统从小到大排序，设目前需要凑的数为A[i]，B系统共有j种面值并从小到大排列。  

当i=1时，直接令B[1]=A[1]即可，命题成立。

假设i=k-1时命题成立（即B[1~j]能凑出A[1~k-1]）则当i=k时

如果B系统的面值能凑出B[k]，命题成立。  

否则，假设B[j+1]>A[k]，则B系统仍然凑不出A[k]；若B[j]<B[j+1]<A[k]，那么B[j+1]必然不能由A[1~k-1]的面值凑出来（否则就没必要增加这个面值了），同时也不能被A[k]凑出来（A[k]比它大），那么这时B[j+1]不符题意。   

综上，B[j+1]=A[k]，符合命题。

因此命题成立。
# ③实现
得出以上结论后，接下来就是实现的问题了。  
将A系统数值排序后，每一个数仅可能被它前面的数凑成，然而如果一开始像作者一样使用bool变量保存状态的话，会发现转移比较困难，所以我们可以以方案数作为状态。

**f(i):用A系统的面值凑成面值i的方案数。**

转移方程：

**f(i)=sum{ f(i-A[j]) } 其中i<=A[j]。**

边界：

**f(0)=1;**

这里作者是用“刷表法”来做的，读者可以自行变通。

```cpp
sort(a+1,a+n+1);//排序
f[0]=1;//边界
for(int i=0;i<=a[n];i++)//排序后a[n]为最大面值
  for(int j=1;i+a[j]<=a[n]&&j<=n;j++)
     if(f[i])//如果是0就不用更新了
		f[i+a[j]]+=f[i];
     else break;
```
如果某个面值只存在1种组成方式（即用它本身凑成自己），就必须选这个面值。

当然，如果用这个核心代码来求方案数的话，会存在如果i是A系统里的面值，就会重复计数，当然，在本题中，不管有没有重复计数，只要某个面值存在除了自身以外的其它组成方式的话，就说明这个面值没必要选，所以对答案没有影响。  
最后，f数组记得开long long 。

# ④AC!
P.S. 自从上次题解排版爆炸后，就不敢滥用markdown了，阅读体验不佳请谅解。

---

## 作者：SuperJvRuo (赞：18)

直接导致我退役的水题，介绍一下我考场上的奇怪思路。

看到题意，直接想到了ISIJ 2018的“[很多序列](https://blog.csdn.net/jpwang8/article/details/82660425)”一题，打了个最短路上去。思路是先将所有数从小到大排序。建立$a_1$个点（$a_1$为最小的面值），点$x$代表模$a_1$余$x$的所有数。对每个点$x$，从$x$到$x+a_i$连一条长为$a_i$的边。跑完最短路后，我们得到的距离$dis[x]$，就是模$a_1$余$x$的能组成的最小金额。

两种货币系统等价，当且仅当两种货币系统的$dis$数组完全相同。我们可以记录一个```trans```数组，表示转移时使用了哪种币值。要注意的是，当一种金额有多种转移路径时，应选择最小的转移。只需在松弛操作时顺便修改即可。

其实这种做法的本质就是对大背包的一种优化，但是考场上忘记了问题的本质，没有用最简单的方法解决。最后还忘清空了```trans```数组（由于样例很水，竟然过了大样例），导致自己Day1还没Day2高。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<utility>
#include<queue>
#include<set>
#include<vector>

#define LL long long
#define PLI std::pair<LL,int>

int val[25005];

LL dist[25005];
bool vis[25005];
int trans[25005];

int Dijkstra(int n)//Dijkstra跑背包
{
    int MOD=val[1];//模a1意义下
    memset(dist,0x3f,sizeof(dist));
    memset(vis,0,sizeof(vis));
    memset(trans,0,sizeof(trans));//考场上少了这一行，当场GG
    dist[0]=0;
    std::priority_queue<PLI,std::vector<PLI>,std::greater<PLI> > Q;
    Q.push(PLI(0,0));
    int vised=0;
    while(vised!=MOD&&!Q.empty())
    {
        int u=Q.top().second;
        Q.pop();
        if(!vis[u])
        {
            vis[u]=true;
            ++vised;
            for(int i=2;i<=n;++i)
            {
                int v=(u+val[i])%MOD;
                if(dist[v]>dist[u]+val[i])//松弛，一定修改转移
                {
                    dist[v]=dist[u]+val[i];
                    trans[v]=val[i];
                    Q.push(PLI(dist[v],v));
                }
                else if(dist[v]==dist[u]+val[i]&&val[i]<trans[v])//有更优的转移
                {
                    trans[v]=val[i];
                }
            }
        }
    }
    std::set<int> s;//找一下有多少种转移（含0）
    for(int i=0;i<MOD;++i)
    {
        s.insert(trans[i]);
    }
    return s.size();
}

int main()
{
    int t;
    scanf("%d",&t);
    int n;
    while(t--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;++i)
        {
            scanf("%d",&val[i]);
        }
        std::sort(val+1,val+n+1);//排序，从小到大枚举转移
        printf("%d\n",Dijkstra(n));
    }
    return 0;
}
```

---

## 作者：WuXiangdong (赞：4)

大概是第一次也是最后一次发题解了，在这里介绍一下我的思路吧.

原题对等价的定义为:两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

我们先来探究两个货币系统等价的条件：

**结论 1** 两个货币系统 $(n,a)$ 和 $(m,b)$ 等价，当且仅当 $(n,a)$ 中每个种类的货币都能被 $(m,b)$ 表示且 $(m,b)$ 中每个种类的货币都能被 $(n,a)$ 表示.

**证明** $\Rightarrow$ 两个货币系统 $(n,a)$ 和 $(m,b)$ 等价，由定义显然有结论.

$\Leftarrow$ 如果$(n,a)$ 中每个种类的货币都能被 $(m,b)$ 表示且 $(m,b)$ 中每个种类的货币都能被 $(n,a)$ 表示.那么金额 $x$ 被 $(n,a)$ 表示 $\Rightarrow$ 存在 $n$ 个非负整数$t_i$使得$t_1a_1+\cdots+t_na_n = x\Rightarrow$ 存在 $m$ 个非负整数 $\mu_i$ 使 $\mu_1b_1 + \cdots + \mu_mb_m = x$ (因为 $a_1 \cdots a_n$ 能被 $(m,b)$ 表示).

这说明金额 $x$ 被 $(n,a)$ 表示 $\Rightarrow$ 金额 $x$ 被 $(m,b)$ 表示.同理可得金额 $x$ 被 $(m,b)$ 表示 $\Rightarrow$ 金额 $x$ 被 $(n,a)$ 表示.这说明金额 $x$ 被 $(m,b)$ 表示 $\Leftrightarrow$ 金额 $x$ 被 $(n,a)$ 表示.可见由 $(n,a)$ 表示的全部金额和由 $(m,b)$ 表示的全部金额是一样的，从而证明了结论. $\square$

由上面的结论可知，对于一个货币系统 $(n,a)$ ，如果有一个货币 $a_i$ 可以被其他货币 $a_j (j \ne i)$ 表示，将 $a_i$ 去除出系统后的货币系统和原系统等价.且最后一定可以将货币系统等价成货币互不能表示的形式.不妨称满足这种形式的货币系统为**基**.

**结论 2** 两个基 $(n,a)$ 与 $(m,b)$ 等价当且仅当 $n = m$ 且在一定的排序后可以使 $a_i = b_i$ 对任意 $1 \le i \le n$ 成立.

**证明** $\Leftarrow$ 是显然的.

$\Rightarrow$ 不妨设 $n \le m$ 且 $0 \lt a_1 \lt a_2 \lt \cdots \lt a_n$ 和 $0\lt b_1 \lt b_2 \lt \cdots \lt b_m$，利用数学归纳法证明$\forall 1 \le i \le n$，$a_i = b_i$：

$1$. $i=1$ 时，若$b_1 \gt a_1$，则 $a_1$ 不能由 $(m,b)$ 表示(因为 $a_1$ 比 $(m,b)$ 中最小的货币还小)，矛盾！同理 $a_1$ 不能大于 $b_1$ 这导致 $a_1 = b_1$.

$2$. 若 $i \le k, 1 \le k \lt n$ 时命题已经成立，$i = k+1$ 时，如果 $b_i < a_i$，由于 $b_i$ 被 $(n,a)$ 表示而 $b_i \lt a_i \lt a_{i+1} \lt \cdots \lt a_n$，$b_i$ 只能是被 $a_1 ,\cdots a_{i-1}$ 表示，而由归纳假设，$a_1 = b_1,\cdots a_{i-1}=b_{i-1}$
，这导致 $b_{i}$ 可以被 $b_1, \cdots ,b_{i-1}$ 表示，与 $(m,b)$ 是基矛盾！同理可得 $b_i$ 不能大于 $a_i$，从而 $a_i = b_i$.由数学归纳法原理知 $\forall 1 \le i \le n$，$a_i = b_i$.

又由于 $(m,b)$ 是基且 $b_{n+1} \cdots b_{m}$ 能被 $a_1 = b_1 ,\cdots ,a_n = b_n$ 表示，知 $n=m$.       $\square$

结论 2 告诉我们，两个等价的货币系统拥有相同的基，并且一个货币系统 $(n,a)$ 的基的货币个数 $\le n$，记一个货币系统 $(n,a)$ 基的货币数为 $n'$，则任意和 $(n,a)$ 等价的系统 $(m,b)$ 的基就是 $(n,a)$ 的基，得到 $m \ge n'$.因此 $n'$ 就是我们要求的答案.

先将系统货币排序，再利用用完全背包求出货币系统 $(n,a)$ 基的货币的个数，即可得到答案.

代码如下
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int T;
int n;
int a[101];
bool flag[25010];
int aMax,cnt;
int main () {
//        freopen("money.in","r",stdin);
//        freopen("money.out","w",stdout);
        int i,j,k,theEndn;
        scanf("%d",&T);
        for(i = 0;i < T;i++) {
                // 初始化
                aMax = 0;
                scanf("%d",&n);
                for(j = 0;j < n;j++) {
                        scanf("%d",a+j);
                        if(a[j] > aMax) {
                                aMax = a[j];
                        }
                }
                flag[0] = true;
                cnt = 0; // 用于统计基的货币个数
                for(j = 1;j <= aMax;j++) {
                        flag[j] = false;
                } // 初始化
                
                sort(a,a+n);
                for(j = 0;j < n;j++) {
                        if(flag[a[j]]) continue; // 如果已经能被表示则跳过
                        // 否则说明 a[j] 是基的一个.
                        cnt++;
                        theEndn = aMax - a[j];
                        for(k = 0;k <= theEndn;k++) { // 完全背包
                                if(flag[k]) {
                                        flag[k+a[j]] = true;
                                }
                        }
                }
                printf("%d\n",cnt);
        }
//        fclose(stdin);
//        fclose(stdout);
        return 0;
}

```

---

## 作者：Super_Cube (赞：3)

# Preface

登洛谷看到首页有个神秘的题解补充计划，就顺手来写了。

# Solution

搞笑题。

如果某个 $a_i$ 能被其余的货币通过某种方法凑出来，那它完全没必要被保留，直接删掉就好了。于是这题的想法就来了：尽可能删掉更多的没用的（可以被凑出来的）货币。

贪心。把货币从小到大排序，因为小面值更有可能凑得大面值，从而可以把大面值删去。

凑面值的过程相当于是完全背包（因为每个硬币可以使用无限个），具体的实现就看代码吧。

# Code

```cpp
#include<bits/stdc++.h>
bool dp[25005];
int a[105];
int T,n,ans;
int main(){
	scanf("%d",&T);
	while(T--){
		memset(dp,0,sizeof(dp));dp[0]=true;
		scanf("%d",&n);ans=n;
		for(int i=1;i<=n;scanf("%d",&a[i++]));
		std::sort(a+1,a+n+1);
		for(int i=1;i<=n;++i)
			if(dp[a[i]])--ans;
			else
				for(int j=a[i];j<=a[n];++j)dp[j]|=dp[j-a[i]];
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Laoda_Bryant (赞：3)

运用算法：贪心和完全背包。
## 思路  
首先直接求 $(m,b)$ 是比较困难的。所以先考虑从 $(n,a)$ 中减去一些多余的面额。  
那什么面额是多余的呢，当一个数值 $a_i$ 能被比它小的面额表示时，那么它的存在就没有意义了。  
那么有没有 $k \in (m,b)$ 并且 $k \notin (n,a)$ 呢，有两种情况：  
* $k$ 可以被 $a_i$ 表示出来，那么此时的 $k$ 就没有存在意义了。
* $k$ 不可以被 $a_i$ 表示出来，那么原本不能被 $(n,a)$ 表示出来的面额被 $(m,b)$ 表示出来了，不符合题目中的 $(n,a)$ 与 $(m,b)$ **等价**。
  
所以，根据以上推论，我们可以得到 $(m,b)\in (n,a)$。则我们可以在 $a$ 上做一次完全背包，时间复杂度可以通过本题。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],dp[25005],n,T;
int solve(int a[],int n){
	int ans=n;
	sort(a+1,a+n+1);
	int p=1;
	for(int i=1;i<=a[n];i++) dp[i]=0;
	for(int i=1;i<=a[n];i++){
		for(int j=1;a[j]<i;j++){
			if(dp[i-a[j]]) dp[i]=1;
		}
		if(dp[i]==0){
			if(i==a[p]) ++p,dp[i]=1;
		}else if(i==a[p]) ++p,--ans;
	}
	return ans;
}
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		cout<<solve(a,n)<<endl;
	}
	return 0;
}
```

---

## 作者：GSQ0829 (赞：3)

### P5020 [NOIP2018 提高组] 货币系统

---
### 思路：
根据观察样例，我们可以发现如果一个数可以被其他的数的和表示，那么这个数可以被省去。

删除省去的就一定是最简的。为啥呢？因为任何删去一个数都会丢失当前的数。如果换成更大的数一定不能表示被换的数。如果换成小的，那必须是这个数的约数，但是这样就会出现更小的可换的货币数——它本身。

所以我们就可以写出主要的程序了。
```cpp
for (int i = 1; i <= n; i++) {
    if (dp[a[i]]) {
        ans--;
        continue;
    }
    for (int j = a[i]; j <= a[n]; j++) dp[j] += dp[j - a[i]];
}
```

那么，还要注意的，就是一些清空数组，初始化数组，数据范围等等的了。

---
### code：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 100001;
int a[MAXN], dp[MAXN], t, n, ans = 0;

int main() {
	cin >> t;
	while (t--) {
		cin >> n;
		ans = n;
		memset(dp, 0, sizeof(dp));
		dp[0] = 1;
		for (int i = 1; i <= n; i++) cin >> a[i];
		sort(a + 1, a + n + 1);
		for (int i = 1; i <= n; i++) {
			if (dp[a[i]]) {
				ans--;
				continue;
			}
			for (int j = a[i]; j <= a[n]; j++) dp[j] += dp[j - a[i]];
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：TainityAnle (赞：3)

### 题目大意

有一个长度为 $m$ 的序列 $a$，$a$ 中的数字可以随意组合出很多数，记作集合 $A$。求一个随意组合能组合出集合 $A$ 的序列最短有多长。

注意要恰好和原序列组合出的一致，即新序列能组合出的原序列组合不出，则新序列不合法。

### 思路

考虑什么情况下能满足条件。如果序列 $a$ 中的数字都可以用新序列中的数表示出来，那么就可能合法。

对于每个 $a_i$，考虑其是否能被之前选中的数表示，如果可以就不把它选到新序列中。这就比较像是筛法的思想。

但是这样会导致选中的数可能会组合出原序列组合不出的数导致不合法。只要保证选中的数都在原序列中就能避免这个问题。

设 $f_{i}$ 表示 $i$ 被表示的次数。

考虑选 $a_i$，则对于所有比 $a_i$ 大的 $j$，$j$ 被表示的次数就比 $j-a_i$ 多一次。即有 $f_j=\max(f_j,f_{j-a_i}+1)$。

统计答案时，如果原序列中一个数被表示的次数恰好为 $1$，说明它无法被原序列中其他数所表示，则满足要求，应当选它。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a[105],f[25005],ans;
int main() {
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		memset(f,-0x3f,sizeof f);
		f[0]=ans=0;
		for(int i=1;i<=n;i++) for(int j=a[i];j<=25000;j++) f[j]=max(f[j],f[j-a[i]]+1);
		for(int i=1;i<=n;i++) if(f[a[i]]==1) ans++;
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Danny_chan (赞：2)

如果 $a$ 数组中的一个数能被其它的数推算出来，就代表这个数没有必要保留。所以我们可以先排序一下，因为小面值更有可能凑成大面值。然后用完全背包来判断是否有必要保留，因为每个面值可以使用无限个。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int a[110],f[1000010];
int main(){
	cin>>t;
	while(t--){
		int n,sum=0;
		cin>>n;
		memset(f,-0x3f,sizeof f);//初始化 
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		f[0]=0;
		for(int i=1;i<=n;i++){
			for(int j=a[i];j<=25010;j++){//完全背包 
				f[j]=max(f[j],f[j-a[i]]+1);
			}
		}
		for(int i=1;i<=n;i++){
			if(f[a[i]]==1){//如果只能被自己表示，说明有必要保留 
				sum++;
			}
		}
		cout<<sum<<endl;
	}
	return 0;
} 
```

---

## 作者：Amoribus (赞：2)

我们把货币面值分为 $3$ 类：

- $0$ 类面值：不可以被表示。
- $1$ 类面值：可以被表示，且可以由其他可以被表示的货币推过来。
- $2$ 类面值：可以被表示，且不能由其他可以被表示的货币推过来。

我们最后要求的就是 $2$ 类面值的数量。

初始，题目给出的货币标记成 $2$ 类面值，然后我们从小到大，用较小的 $1$ 类或 $2$ 类面值更新更大面值的货币，并标记为 $1$ 类面值。

显然的，原本无用的货币在这个过程中都会被标记成 $1$ 类面值。

时间复杂度 $O(n\max a_i)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n;
int a[109];
int res[25009];
void work(){
	int cnt=0;
	memset(res,0,sizeof(res));
	for(int i=1;i<=n;i++){
		res[a[i]]=2; 
	}
	for(int i=1;i<=25000;i++){
		for(int j=1;j<=n;j++){
			if(res[i]!=0){
				res[i+a[j]]=1;
			}
		}
	}
	for(int i=1;i<=25000;i++){
		if(res[i]==2) cnt++;
	}
	cout<<cnt<<endl;
}
int main()
{
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		work();
	}
	return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

根据观察样例，我们可以发现如果一个数可以被其他的数的和表示，那么这个数可以被省去。

删除省去的就一定是最简的。为啥呢？因为任何删去一个数都会丢失当前的数。如果换成更大的数一定不能表示被换的数。如果换成小的，那必须是这个数的约数，但是这样就会出现更小的可换的货币数——它本身。

考虑 DP，设 $f_{i,j}$ 表示前 $i$ 个货币表示出 $j$ 最多用多少个货币。

转移：和完全背包一样 $f_{i,j}=\max(f_{i-1,j},f_{i,j-a_i}+1)$。

如果 $f_{a_i}\ne 1$，那么这个货币可以用其他的表示，就没用。否则就有用。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a[101],f[25001],ans;
void Main(){
    cin>>n;
    memset(f,0xcf,sizeof(f));
    f[0]=ans=0;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        for(int j=a[i];j<=25000;j++)
            f[j]=max(f[j],f[j-a[i]]+1);
    for(int i=1;i<=n;i++)
        if(f[a[i]]==1)
            ans++;
    cout<<ans<<'\n';
    return;
}
int main(){
    for(cin>>T;T;--T)
        Main();
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

直接求肯定不好求，考虑减去一些面值。

首先考虑按照面值从大到小排序。

若 $a_i$ 可以被前面的 $i - 1$ 个面值表示出来，则这张面值是不需要的；可以完全背包做一遍即可。

现在求出的 $b$ 是 $a$ 的子集中满足 $(m, b)$ 与 $(n, a)$ 等价且元素数量最少。

我们需要证明不存在一个不是 $a$ 子集中的 $b'$ 比 $b$ 更优。

对于所有 $x \in b', x \not\in a$，$x$ 肯定能被 $b$ 中的表示出来；对于 $b'$ 中 $\in a$ 的部分 $c$，是表示不出来上面的 $x$ 的；故 $x$ 的数量应该是不少于 $m - |c|$ 的。

时间复杂度为 $O(Tnw)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 50005, M = 105; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int T, n, x, ans;
int a[M];
bitset<N> dp;
inline void solve(){
	for(int i = 1; i < N; ++i)
	  dp[i] = 0;
	n = ans = read();
	dp[0] = 1;
	for(int i = 1; i <= n; ++i)
	  a[i] = read();
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; ++i){
		x = a[i];
		if(dp[x]){
			--ans;
			continue;
		}
		for(int k = 0; x * (1 << k) <= a[n]; ++k)
		  dp |= (dp << (x * (1 << k)));
	}
	write(ans);
	putchar('\n');
}
bool End;
int main(){
	T = read();
	while(T--)
	  solve();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Ascnbeta (赞：0)

## P5020 [NOIP2018提高组] 货币系统

完全背包 dp 题，不是很难想。

## 题意

对于一个货币系统（集合）$A$。包含若干个正整数 $a_i$。我们称 $A\iff B$，当且仅当对于任意非负整数 $x$，其要么既满足 $x=a_1p_1+a_2p_2+\dots +a_np_n,p_i\in \mathbb{N}$ 又满足 $x=b_1q_1+b_2q_2+\dots +b_mq_m,q_i\in \mathbb{N}$；要么都不满足。

现在给定一个货币系统 $C$，求所有与之等价的货币系统 $D$ 中最少的元素个数。

## 思路分析

观察样例数据 $1$，发现 $6=3\times2,19=10+3\times3$，因此它们被去掉了。

而样例数据 $2$ 中没有任何一个数可以表示为其他数字之和，因此没有被去掉的数。

所以思路已经很显然了，我们只需要把能被其他数字表示的货币面值去掉即可。

但是如果对一个数单独爆搜是肯定会 TLE 的，所以继续观察题面，发现 $a_i \le 2.5\times10^4$，并且元素个数仅有最多 $100$ 个，因此想到 dp。因为把一个数用和表示出来相当于取数字，所以我们可以想到背包 dp。设 $f_{i,j}$ 表示前 $i$ 个数能否凑出数字 $j$，第 $i$ 个数使用 $k$ 次，则状态转移方程如下：
$$
f_{i,j} \gets f_{i-1,j} \lor f_{i-1,j-a_ik}
$$
由于我们当前状态的值既来自于上一状态又可以来自于本状态（当前的数可以使用多次），因此可以去掉 $i$ 这一维，$j$ 依旧是升序枚举。边界是 $f_0 = 1$。

然后对于第 $i$ 个数，如果我们还没去选择它但是这个数已经可以被前 $i-1$ 个数表示出来，则序列长度就可以减 $1$，并 `continue`。

## AC code

注意多测清空，记得排序。

```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
int n,a[104],maxx,ans;
bool f[25006];
int main () {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> T;
	while (T--) {
		cin >> n;
		maxx = 0,ans = n;
		memset(f,0,sizeof(f));//多测清空。
		for (int i = 1; i <= n ; i++) {
			cin >> a[i];
			maxx = max(a[i],maxx);
		}
		sort(a+1,a+n+1);
		f[0] = true;//边界。
		for (int i = 1; i <= n; i++) {
			if (f[a[i]]) {
				--ans;//如果这个数可以被前 i-1 个数表示，则序列长度 -1。
				continue;
			}
			for (int j = 1; j <= maxx; j++) {//只需枚举到最大的 a[i] 即可。
				for (int k = 1; k <= j / a[i]; k++) {
					f[j] = f[j] || f[j-a[i]*k];
				}
			}
		}
		cout << ans << '\n';//对于非交互题，能用 '\n' 别用 `endl`。
	}
	return 0;
}
```

---


# [LSOT-2] 胜者组

## 题目背景

进入胜者组就算胜利吗...

至少人们都这样说。

## 题目描述

小 H 的学校在 noip 结束后要决定踢出一些学生回去学文化课。

具体的，学校一共有 $n$ 个同学，留下了最多 $m$ 个学习信息学的名额。

学校里的同学组成了 $k$ 个小团体，其中第 $i$ 个同学属于第 $c_i$ 个小团体。

你每次可以钦定两个处于同一小团体的学生学习文化课。若你让学生 $i,j(c_i=c_j)$ 去学习文化课，学生会产生 $a_i+a_j+x\times|i-j|$ 的不满意度。这里 $x$ 是输入一开始给定的常数。

你需要让学生的不满意度最小化，或报告无法留下不多于 $m$ 个学习信息学的学生。

## 说明/提示

样例解释：

分别钦定 $(1,2)$ 和 $(4,6)$ 学习文化课，不满意度为 $(2+5+3\times|1-2|)+(2+7+3\times|4-6|)=25$。

需要注意的是，一个同学不可以被钦定多次。

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(15pts)：}n\le20$。
- $\texttt{Subtask 2(15pts)：}x=0$。
- $\texttt{Subtask 3(15pts)：}k=1$。
- $\texttt{Subtask 4(20pts)：}n\le 300$。
- $\texttt{Subtask 5(35pts)：}$无特殊性质。

对于全部的数据，$0\le a_i,x\le10^5$，$1\le c_i\le k\le n\le 5000$，$0\le m\le n$。

## 样例 #1

### 输入

```
6 2 2 3
2 5 7 2 5 7
1 1 2 1 2 1```

### 输出

```
25```

# 题解

## 作者：良心WA题人 (赞：16)

首先发现每种小团体独立。

对于每一个小团体，将选出来的两个学生看成线段的左右端点后，任意两对学生不会相交。因为若两对学生 $(pl,pr)$ 和 $(ql,qr)$ 满足 $p_l\le q_l\le p_r\le q_r$，则选出 $(p_l,q_l)$ 和 $(p_r,q_r)$ 显然更优（将贡献写出来后读者自证不难）。

我们将贡献拆开变成 $a_i-x\times i+a_j+x\times j$。于是对于每个小团体 dp 算出 $f_{i,j,0/1}$ 表示该小团体前 $i$ 个点用 $j$ 次信息学名额，当前是完整匹配/剩余了一个待匹配点的最小不满值。

具体的，$f_{i,j,0}=\min(f_{i-1,j-1,0},f_{i-1,j,1}+a_i+x\times i)$ 表示当前点不选花费一次名额则直接继承，或者当前点用待匹配的一半匹配上。同理，$f_{i,j,1}=\min(f_{i-1,j-1,1},f_{i-1,j,0}+a_i-x\times i)$。

然后考虑在外面使用背包。令 $g_{i,j}$ 表示考虑前 $i$ 个小团体用 $j$ 个名额的最小不满值。直接分组背包即可。因为所有颜色的个数和为 $n$，所以背包合并的时间复杂度为 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int NN=5004;
vector<int>t[NN];
int a[NN],c[NN];
ll f[NN][NN][2],g[NN][NN];
int main()
{
	int n,m,d,x;
	scanf("%d%d%d%d",&n,&m,&d,&x);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&c[i]);
		t[c[i]].push_back(i);
	}
	memset(g,0x3f,sizeof(g));
	g[0][0]=0;
	int cnt=0;
	for(int i=1;i<=d;i++)
	{
		for(int j=0;j<=t[i].size();j++)
			for(int k=0;k<=m;k++)
				f[j][k][0]=f[j][k][1]=1e18;
		f[0][0][0]=0;
		for(int j=1;j<=t[i].size();j++)
			for(int k=0;k<=m;k++)
			{
				f[j][k][0]=f[j-1][k][1]+a[t[i][j-1]]+1ll*x*t[i][j-1];
				f[j][k][1]=f[j-1][k][0]+a[t[i][j-1]]-1ll*x*t[i][j-1];
				if(k)
				{
					f[j][k][0]=min(f[j][k][0],f[j-1][k-1][0]);
					f[j][k][1]=min(f[j][k][1],f[j-1][k-1][1]);
				}
			}
		for(int j=0;j<=cnt;j++)
			for(int k=0;k<=t[i].size();k++)
				if(j+k<=m)
					g[i][j+k]=min(g[i][j+k],g[i-1][j]+f[t[i].size()][k][0]);
		cnt+=t[i].size();
	}
	ll ans=1e18;
	for(int i=0;i<=m;i++)
		ans=min(ans,g[d][i]);
	if(ans>9e17)
	{
		printf("Impossible");
		return 0;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Nuyoah_awa (赞：6)

### 题目大意

共 $n$ 个人，两两一对送走，最后留下不多于 $m$ 个人，求最小代价（具体见题面）。

### 题目分析

1. 判 `Impossible`。

设每个小团体 $a_i$ 个人，我们容易知道最多剩下 $\sum\limits_{i = 1}^{i \le n} (a_i \bmod 2)$ 个人，若大于 $m$，则无解。

2. $\texttt{Subtask 2(15pts)：}x=0$。

因为 $x = 0$，则公式化为 $a_i + a_j$，于是我们可以考虑对于每个小团体来看，由于选 $a,b$ 和 $c,d$ 与 $a,c$ 和 $b,d$ 代价是一样的，所以在每个小团体中应该从小往大选，设每个小团体选 $k_i \times 2$ 人，我们将小团体内的人按照 $a_i$ 排序，则答案为 $\sum \limits_{i = 1}^{i \le k}\sum\limits_{j = 1}^{j \le k_i \times 2} a_{c_j}$。

所以我们对于每个小团体，从小到大两两配对，所有对中从小到大取即可。

code：
```cpp
if(x == 0)
{
	for(int i = 1;i <= k;i++)
		sort(e[i].begin(), e[i].end(), cmp);
	for(int i = 1;i <= k;i++)
		for(int j = 0;j+1 < e[i].size();j += 2)
			q.push(a[e[i][j]] + a[e[i][j+1]]);
	while(n > m)
	{
		ans += q.top();
		q.pop();
		n -= 2;
	}
	printf("%d\n", ans);
	return 0;
}
```

3. $\texttt{Subtask 3(15pts)：}k=1$。

即只有一个小团体，从中选出 $k$ 对，dp 即可。

设 $f_{i,j}$ 表示到第 $i$ 个数，共选了 $j$ 个数的最小代价。

若我们知道选了哪 $2 \times k$ 个数，容易知道我们一定是 $1 + 2, 3 + 4, \dots , 2 \times k - 1 + 2 \times k$ 是最优的，因为代价一定有一部分是 $\sum \limits_{i = 1}^{i \le 2 \times k} a_{c_i}$，另一部分即两两之间距离再乘 $x$，所以相邻两数选一定最优。

所以转移方程易得：

$$f_{i, j} = \min\{f_{i-1,j} + \begin{cases}x & j \equiv 1 \bmod 2 \\ 0 & j \equiv 0 \bmod 2\end{cases}, f_{i-1, j-1} + a_i + \begin{cases}0 & j \equiv 1 \bmod 2 \\ x & j \equiv 0 \bmod 2\end{cases}\}$$

其中，只有 $j$ 为偶数的状态是真正有用的。答案为：

$$ans = \min\limits_{i = 1}^{i \le n} f_{i, 2 \times k}$$

code：
```cpp
if(k == 1)
{
	for(int i = 0;i <= n;i++)
		for(int j = 0;j <= n;j++)
			f[i][j] = INF;
	for(int i = 0;i <= n;i++)
		f[i][0] = 0;
	f[1][1] = a[1];
	for(int i = 2;i <= n;i++)
		for(int j = 1;j <= i;j++)
			f[i][j] = min(f[i-1][j] + (j & 1 ? x : 0), f[i-1][j-1] + a[i] + (j & 1 ? 0 : x));
	ans = INF;
	for(int i = 1;i <= n;i++)
		ans = min(ans, f[i][n - m + ((n - m) & 1)]);
	printf("%d\n", ans);
	return 0;
}
```
4. 正解。

我们发现所选的两数一定在同一小团体内，所以各个小团体之间不会相互影响，于是我们可以考虑对于每个小团体做上述 $\texttt{Subtask 3}$ 中的解法，然后将将每个小团体中选 $2 \times t$ 个作为物品（$t$ 为任意合法实数），做 01 背包即为答案。（默认都会 01背包，在这里忽略转移方程）。

总的背包和每个小团体的 dp 可以看为并列执行，在时间方面互不影响，所以时间复杂度为 $\mathcal O(n ^ 2)$ 的。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstring>
#define int long long

using namespace std;

const int N = 5e3 + 5, INF = 2e18;
int n, m, k, x, a[N], c[N], tmp, f[N][N], g[N][N];
vector <int> e[N];

signed main()
{
	scanf("%lld %lld %lld %lld", &n, &m, &k, &x);
	for(int i = 1;i <= n;i++)
		scanf("%lld", &a[i]);
	for(int i = 1;i <= n;i++)
		scanf("%lld", &c[i]);
	for(int i = 1;i <= n;i++)
		e[c[i]].push_back(i);
	for(int i = 1;i <= k;i++)
		tmp += e[i].size() & 1;
	if(tmp > m)
	{
		printf("Impossible\n");
		return 0;
	}
	int goal = (n - m + 1) / 2;
	for(int i = 0;i <= k;i++)
		for(int j = 0;j <= goal;j++)
			g[i][j] = INF;
	for(int i = 0;i <= k;i++)
		g[i][0] = 0;
	for(int l = 1;l <= k;l++)
	{
		int len = e[l].size();
		if(len == 0)
		{
			for(int i = 1;i <= goal;i++)
				g[l][i] = g[l-1][i];
			continue;
		}
		for(int i = 0;i <= len;i++)
			for(int j = 0;j <= len;j++)
				f[i][j] = INF;
		for(int i = 0;i <= len;i++)
			f[i][0] = 0;
		f[1][1] = a[e[l][0]];
		for(int i = 2;i <= len;i++)
			for(int j = 1;j <= i;j++)
				f[i][j] = min(f[i-1][j] + (j & 1 ? x * (e[l][i-1] - e[l][i-2]) : 0), f[i-1][j-1] + a[e[l][i-1]] + (j & 1 ? 0 : x * (e[l][i-1] - e[l][i-2])));
		for(int i = 1;i <= len;i++)
			for(int j = 1;j * 2 <= len;j++)
				f[len][j*2] = min(f[len][j*2], f[i][j*2]);
		for(int i = 1;i <= goal;i++)
		{
			int mn = g[l-1][i];
			for(int j = 1;j <= i && j * 2 <= len;j++)
				mn = min(mn, g[l-1][i-j] + f[len][j*2]);
			g[l][i] = mn;
		}
	}
	printf("%lld\n", g[k][goal]);
	return 0;
}
```

---

## 作者：Jorisy (赞：3)

我们伟大的官方题解用到了两个状态转移数组，但是这并没有必要！

我们首先按小团体编号给同学排序。

然后一个显然的事实是选择的同学一定是从左到右依次选的，也就是任意两组同学的原编号所构成的区间 $[l_1,r_1],[l_2,r_2]$，它们的交集为空集。

于是每两个同学的不满意度可以拆成 $a_i-xi+a_j+xj$，所以第奇数 $i$ 个同学的贡献是 $a_i-xi$，第偶数 $j$ 个同学的贡献是 $a_j+xj$。

因此设状态 $f_{i,j}$ 表示前 $i$ 个同学踢出了 $j$ 个同学时的最小不满意度。

于是在一个小团体里，不难想到转移方程 $f_{i,j}=\begin{cases}\min\{f_{i-1,j},f_{i-1,j-1}+a_i+xi\}&j\bmod 2=0,\\\min\{f_{i-1,j},f_{i-1,j-1}+a_i-xi\}&j\bmod2=1\end{cases}$，也就是类似背包，对于第 $i$ 个同学要么不踢，要么踢。

但其实最关键的是从一个小团体到另一个小团体的转移。

设上一个小团体最后一个同学的编号为 $i-1$，这一个小团体的第一个同学编号为 $i$。

发现如果 $j$ 是奇数，那么方程中的 $f_{i-1,j}$ 成为无效信息，因为一对同学并不能跨团体。

同理，$j$ 是偶数时，$f_{i-1,j-1}+a_i+xi$ 也是无效信息，原因相同。

注意到题面中是“不多于 $m$ 个”，因此最后统计答案要挨个比较。找不到任何一个答案就是无解。

Code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

vector<int>v[5005];
int n,m,p,x,a[5005],f[5005][5005],ans=0x3f3f3f3f3f3f3f3f;

signed main()
{
	cin>>n>>m>>p>>x;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		int c;
		cin>>c;
		v[c].push_back(i);
	}
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<=n;i++) f[i][0]=0;
	int c=0;
	for(int pi=1;pi<=p;pi++)
	{
		for(int k=0;k<v[pi].size();k++)
		{
			int i=c+k+1;
			for(int j=1;j<=i;j++)
			{
				f[i][j]=min(!k&&(j&1)?0x3f3f3f3f3f3f3f3f:f[i-1][j],!k&&(~j&1)?0x3f3f3f3f3f3f3f3f:f[i-1][j-1]+a[v[pi][k]]+(j&1?-1:1)*x*v[pi][k]);
			}
		}
		c+=v[pi].size();
	}
	for(int i=n-m;i<=n;i++)
	{
		for(int j=n-m+(n-m&1);j<=i;j+=2)
		{
			ans=min(ans,f[i][j]);
		}
	}
	if(ans==0x3f3f3f3f3f3f3f3f) puts("Impossible");
	else cout<<ans;
 	return 0;
}
```

---

## 作者：Night_sea_64 (赞：2)

首先，需要踢出的人一定是偶数，且一共有 $\left\lceil\dfrac{n-m}{2}\right\rceil$ 个人。因为踢掉的人肯定越少越好。

然后这个贡献可以拆成两部分，一部分是踢出的所有人的 $a_i$ 之和，另一部分是每一对被踢出的人的下标差的绝对值。

考虑 dp。第一部分好办。第二部分的话我们需要决定如何给踢出的人配对。这显然就是同一个小组的踢出的人中，下标从小到大排序，第奇数个的下标减掉，第偶数个的下标加上，同时保证每个小组踢出的人都是偶数。

于是所有小组分开处理即可。按组号为第一关键字，下标为第二关键字给所有人排序然后 dp 即可。

这个 dp 状态就很好设计了：$f_{i,j}$ 表示前 $i$ 个人中有 $j$ 个被踢出的最小代价。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k,x;
struct node{int x,c,id;}a[5010];
bool cmp(const node &x,const node &y){
    if(x.c!=y.c)return x.c<y.c;
    return x.id<y.id;
}
long long f[5010][5010];
//f[i][j] 前 i 个人有 j 个被劝退的最小代价
int main()
{
    cin>>n>>m>>k>>x;
    m=n-m;
    if(m%2)m++;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].x;
        a[i].id=i;
    }
    for(int i=1;i<=n;i++)cin>>a[i].c;
    sort(a+1,a+n+1,cmp);
    memset(f,999999,sizeof(f));
    f[0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)
            if(j%2)
            {
                if(a[i].c==a[i-1].c)f[i][j]=f[i-1][j];
                f[i][j]=min(f[i][j],f[i-1][j-1]+a[i].x-1ll*x*a[i].id);
            }
            else
            {
                f[i][j]=f[i-1][j];
                if(j&&a[i].c==a[i-1].c)f[i][j]=min(f[i][j],f[i-1][j-1]+a[i].x+1ll*x*a[i].id);
            }
    if(f[n][m]<1e18)cout<<f[n][m]<<endl;
    else cout<<"Impossible"<<endl;
    return 0;
}
```

---

## 作者：LCat90 (赞：1)

比较神奇的做法，需要进行简单的 dp 优化。

对于这种分组的问题，有一个很厉害的想法：将原数组排序，使得同一组的挨在一起，转化为近似与一个组的 dp。这样做可以极大地方便实现。

首先证明这道题可以 dp。即：对于每一对选择的人，两者在原序列所对应的下标所组成的区间**一定没有交集**。由于 $|i-j|$ 的存在，这个结论是比较显然的。所以 $i$ 的答案一定是从 $j<i$ 处来的。

设 $dp_{i,j}$ 表示前 $i$ 个选出 $j$ 个人的方案数。假设我们一次选 2 人，那么有转移：

$$dp_{i,j}=\min(dp_{i-1,j},\min_{l}^{l<i,c_i=c_l} \{dp_{l-1,j-2}+a_i+a_l+x\times |i-l|\})$$

这样直接转移是 $O(n^2m)$ 的。需要优化后面选择 $l$ 的转移。

注意到此时 $|i-l|=i-l$，于是将后面的常数拆成：$(a_i+x\times i) + (a_l-x\times l)$。前面的括号和 $i$ 有关，转移时加上；后面的括号和枚举的 $l$ 有关，和 $dp_{l-1,j-2}$ 一起存进数组 ``minn`` 里面，套路地进行优化即可，总时间 $O(nm)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;
const int N = 5e3 + 5, inf = 0x3f3f3f3f3f3f3f3f; int read();
int n, m, k, x, a[N], c[N], dp[N][N];
// dp 表示前 i 个位置选择了 k 个 
vector <int> G[N];
struct node {
	int a, c, id;
	friend bool operator < (node a, node b) { 
		if(a.c == b.c) return a.id < b.id;
		return a.c < b.c;
	}
} p[N];
int minn[N]; // 选择 j 个的 minn 
signed main() {
	cin >> n >> m >> k >> x;
	for(int i = 1;i <= n; ++i) p[i].a = read(), p[i].id = i;
	for(int i = 1;i <= n; ++i) p[i].c = read(), G[p[i].c].pb(i); 
	sort(p + 1, p + n + 1);
	int sum = 0; // min liu
	for(int i = 1;i <= k; ++i) sum += (G[i].size() & 1);
	if(sum > m) return puts("Impossible"), 0;
	
	memset(dp, 0x3f, sizeof dp); dp[0][0] = 0;	
	m = n - m; // 选择至少 n - m 个 
	if(m & 1) m ++; 
	for(int i = 1;i <= n; ++i) {
		if(p[i].c != p[i - 1].c) for(int j = 0;j <= m; ++j) minn[j] = inf;
		for(int j = 0;j <= m; ++j) {
			dp[i][j] = dp[i - 1][j];
			if(j >= 2 and minn[j - 2] != inf) dp[i][j] = min(dp[i][j], minn[j - 2] + p[i].a + x * p[i].id);
		}
		for(int j = 0;j <= m; ++j) minn[j] = min(minn[j], dp[i - 1][j] + p[i].a - x * p[i].id);
	} 
	cout << dp[n][m];
	return 0;
} 
int read() {
	char c; int sum = 0; while(c < '0' or c > '9') c = getchar();
	while(c >= '0' and c <= '9') sum = (sum << 3) + (sum << 1) + (c ^ 48), c = getchar();
	return sum;	
}
```

---

## 作者：I_will_AKIOI (赞：0)

由于每个小团体互不影响，考虑先把每个小团体的答案进行求解再合并。

对于每个小团体，设 $f_{i,j}$ 为当前小团体前 $i$ 个人，让 $j$ 个人去文化课产生的最小不满意度，枚举 $k<i$ 进行转移。由于我们一次需要钦定两个人，不妨考虑在 $j$ 为偶数的时候再计算贡献，$j$ 为奇数时不计算贡献直接转移。转移方程为：

$$f_{i,j}=\begin{cases}

\min f_{k,j-1},j\bmod 2=1\\

\min f_{k,j-1}+a_i+a_k+x\times|i-k|,j\bmod 2=0\\

\end{cases}$$

这部分时间复杂度为 $O(n^2m)$。

考虑完每一个小团体后，把每个小团体进行合并，同样的，设 $g_{i,j}$ 表示前 $i$ 个小团体让 $j$ 个人去文化课产生的最小不满意度，和普通背包一样，时间复杂度是 $O(nm)$ 的。

考虑优化。交换 $i,j$ 的枚举顺序，根据 $j$ 的奇偶性维护前缀最小值进行转移，即可优化到 $O(nm)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 5005
using namespace std;
int n,m,K,x,ans=1e18,a[N],b[N],f[N][N],cnt[N];
vector<int>v[N];
vector<vector<int> >g[N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>K>>x;
	for(int i=1;i<=K;i++) v[i].push_back(0);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i],v[b[i]].push_back(i),cnt[b[i]]++;
	for(int num=1;num<=K;num++)
	{
		g[num].resize(cnt[num]+5);
		for(int i=0;i<=cnt[num];i++)
		{
			g[num][i].resize(cnt[num]+5);
			for(int j=0;j<=cnt[num];j++) g[num][i][j]=1e18;
		}
		g[num][0][0]=0;
		for(int j=1;j<=cnt[num];j++)
		{
			if(j&1)
			{
				int minn=1e18;
				for(int i=0;i<j;i++) minn=min(minn,g[num][i][j-1]);
				for(int i=j;i<=cnt[num];i++) g[num][i][j]=min(minn,g[num][i-1][j]),minn=min(minn,g[num][i][j-1]);
			}
			else
			{
				int minn=1e18;
				for(int i=0;i<j;i++) minn=min(minn,g[num][i][j-1]+a[v[num][i]]-x*v[num][i]);
				for(int i=j;i<=cnt[num];i++) g[num][i][j]=min(minn,g[num][i-1][j]-a[v[num][i]]-x*v[num][i])+a[v[num][i]]+x*v[num][i],minn=min(minn,g[num][i][j-1]+a[v[num][i]]-x*v[num][i]);
			}
		}
	}
	for(int i=0;i<=K;i++) for(int j=0;j<=n;j++) f[i][j]=1e18;
	f[0][0]=0;
	for(int i=1;i<=K;i++) for(int j=0;j<=cnt[i];j+=2) for(int k=j;k<=n;k+=2) f[i][k]=min({f[i][k],f[i-1][k],f[i-1][k-j]+g[i][cnt[i]][j]});
	for(int i=n-m;i<=n;i++) ans=min(ans,f[K][i]);
	if(ans==1e18) cout<<"Impossible";
	else cout<<ans;
	return 0;
}
```

---

## 作者：Laisira (赞：0)

### 题面
给 $k$ 个组，一共 $n$ 个人，让你踢人，剩下小于 $m$ 个。踢人方式是每次找一个组中的俩人 $i,j$ 踢掉，代价 $a_i+a_j+|i-j|\times x$，$x$ 为给定常数。最小化代价，无法达成输出 `Impossible`。

### 思路
我们可以将 $i$ 的贡献拆成 $a_i\pm i\times x$，剩下的就是看后面一坨。然后假设我们已选了 $i,j,k,p$ 有 $i<j<k<p$ 要谁加谁代价最小，显然是 $i$ 和 $j$、$k$ 和 $p$，因为比如如果  $i$ 和 $p$，$j$ 和 $k$ 就会浪费两倍 $k-j$，让后也一样证证就会发现要依次选数组队。

简单动态规划。

$k=1$ 时就是一个类似背包的东西，记录 $f_{i,j,0/1}$ 表示选到第 $i$ 个，装了 $j$ 个，第 $j$ 个是不是没完成组队（其实第三维可有可无，$j$ 的奇偶就是它，但是带了好看点）。

转移方程是：

$f_{i,j,0}=\min(f_{i-1,j,0},f_{i-1,j-1,1}+a_i+x\times i)$

$f_{i,j,1}=\min(f_{i-1,j,1},f_{i-1,j-1,0}+a_i-x\times i)$

然后 $k>1$ 就在外层加个背包每组统计贡献。

### 代码
```cpp
#include<bits/stdc++.h>
#define INT_MAX 0x3f3f3f3f3f3f
#define int long long 
#define Maxn 5005 
using namespace std;
int f[Maxn][Maxn][2],g[Maxn][Maxn];
int a[Maxn];
vector<int> q[Maxn];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n,m,k,x;
    cin>>n>>m>>k>>x;
    memset(g,0x3f3f3f3f3f3f,sizeof(g));
    g[0][0]=0;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        int u;
        cin>>u;
        q[u].push_back(i);
    }
    int num=0;
    for(int _=1;_<=k;_++) {
        for(int i=0;i<=q[_].size();i++)
            for(int j=0;j<=m;j++)
                f[i][j][0]=f[i][j][1]=INT_MAX;
        f[0][0][0]=0;
        for(int i=1;i<=q[_].size();i++)
            for(int j=0;j<=m;j++)
            {
                if(j) {
                    f[i][j][0]=min(f[i-1][j][1]+a[q[_][i-1]]+x*q[_][i-1],f[i-1][j-1][0]);
                    f[i][j][1]=min(f[i-1][j][0]+a[q[_][i-1]]-x*q[_][i-1],f[i-1][j-1][1]);
                } else {
                    f[i][j][0]=min(f[i][j][0],f[i-1][j][1]+a[q[_][i-1]]+x*q[_][i-1]);
                    f[i][j][1]=min(f[i][j][1],f[i-1][j][0]+a[q[_][i-1]]-x*q[_][i-1]);
                }
            }
        for(int i=0;i<=num;i++)
            for(int j=0;j<=q[_].size()&&j+i<=m;j++)
                g[_][i+j]=min(g[_][i+j],g[_-1][i]+f[q[_].size()][j][0]);
        num+=q[_].size();
    }
    int ans=999999999999999999;
    for(int i=0;i<=m;i++)
        ans=min(ans,g[k][i]);
    if(ans>=10000000000000)cout<<"Impossible";
    else cout<<ans;
    return 0;
}
```

---


# 三角形牧场

## 题目描述

和所有人一样，奶牛喜欢变化。它们正在设想新造型的牧场。奶牛建筑师 Hei 想建造围有漂亮白色栅栏的三角形牧场。她拥有 $n$ 块木板，每块的长度 $l_i$ 都是整数，她想用所有的木板围成一个三角形使得牧场面积最大。

请帮助 Hei 小姐构造这样的牧场，并计算出这个最大牧场的面积。

## 说明/提示

#### 样例输入输出 1 解释

$692=\text{舍尾后的}(100\times\text{三角形面积})$，此三角形为等边三角形，边长为 $4$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $3\le n\le40$，$1\le l_i\le40$。

## 样例 #1

### 输入

```
5
1
1
3
3
4
```

### 输出

```
692
```

# 题解

## 作者：Cxs3 (赞：83)

题目链接：https://www.luogu.org/problem/P1284

## 题目分析
做这道题首先要知道 已知三角形三边长求面积的公式：[海伦公式](https://baike.baidu.com/item/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F/106956)。

接下来就是设状态。背包的题目难就难在这一步，设好状态后方程是很容易写的。

用$f[a][b][c]$（布尔型）表示三边长为$a,b,c$的三角形能否围成。但是，三角形的边长的最大值$=40*40/2=800$，$800*800*800$显然太大，不可行。  

怎么降空间呢？观察题目可以发现，所有$n$个木板都是要用的，即三角形的周长不变，如果知道了$a,b$，那么第三边$c$也知道了。  
因此，我们可以用$f[k][i][j]$表示用前$k$个木板能否围成两边长为$i,j$的三角形。  
转移时分三种情况：  
- 把第$k$个木板放在$i$这条边中：  
那就要用前$k-1$个木板围成$i-a[k]$和$j$的三角形，即$f[k-1][i-a[k]][j]$。 
- 把第$k$个木板放在$j$这条边中：$f[k-1][i][j-a[k]]$。
- 把第$k$个木板放在第三条边中：$f[k-1][i][j]$。  

得到动态转移方程：  
```cpp
f[k][i][j]=f[k-1][i-a[k]][j] || f[k-1][i][j-a[k]] || f[k-1][i][j];
```  

观察方程，发现了么？转移时只跟$f[k-1][ \ ][ \ ]$这层的数据有关，所以我们完全可以去掉第一维，用原数组里的数据更新当前值$f[i][j]$。  
需要注意的是，$i,j$要倒过来循环。这个不难理解，自己思考一下就知道原因了。  
$f[0][0]$初始化为$1$。

最后，枚举$i$和$j$，判断能否构成三角形，若可以，用海伦公式求面积，更新答案。  
最后的最后，提醒一下求面积的函数里所有变量都要开$double$或$float$，否则只有$\text{45}$分。。。别问我怎么知道的。。。

## 代码实现
```cpp
#include<bits/stdc++.h>
const int N=50;
const int L=800+10;
using namespace std;

int n,a[N],sum;
double ans;
bool f[L][L];

bool check(int x,int y,int z) 
{
	if(x+y>z&&x+z>y&&y+z>x) return 1;
	return 0;
}

double work(double x,double y,double z)
{
	double p=(x+y+z)/2;
	return sqrt(p*(p-x)*(p-y)*(p-z));
}

int main()
{
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++){cin>>a[i]; sum+=a[i];}//用sum记录周长 
	f[0][0]=1;
	for(k=1;k<=n;k++)
	  for(i=sum/2;i>=0;i--)//从周长的一半开始循环 
	    for(j=sum/2;j>=0;j--)
	    {
	      if(i-a[k]>=0&&f[i-a[k]][j]) f[i][j]=1;
	      if(j-a[k]>=0&&f[i][j-a[k]]) f[i][j]=1;
	      //if(f[i][j]) f[i][j]=1;
          //这句可以省略 
		}
	ans=-1;
	for(i=sum/2;i>0;i--)
	  for(j=sum/2;j>0;j--)
	  {
	  	if(!f[i][j]) continue;
	  	if(!check(i,j,sum-i-j)) continue;//判断能否构成三角形
	  	ans=max(ans,work(i,j,sum-i-j));//更新答案 
	  }
	if(ans!=-1) cout<<(long long)(ans*100)<<endl;
	else cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Jacob233 (赞：41)

**DP，只需开二维数组存此三角形的两条边，就可以表示出第三条边，再判断能否加上这根木棒**



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=40+5;
int a[maxn];
bool f[888][888];//吉利数字保AC（其实是可以从数据看出最大周长为1600，每条边长度显然不能超过800）
int n;
double maxx=-1;
bool Tri(int i,int j,int k){
    if(i+j>k&&i+k>j&&k+j>i)return true;
    else return false;
```
}//判断是否可以构成三角形

```cpp
double Helen(double i,double j,double k){
    double p;
    p=(i+j+k)/2;
    return sqrt(p*(p-i)*(p-j)*(p-k));
```
}//海伦公式算面积

```cpp
int main(){
    while((scanf("%d",&n))!=EOF){
        memset(a,0,sizeof(a));
        memset(f,false,sizeof(f));
        int tot=0;
        for(int i=1;i<=n;i++){
            scanf("%d",&a[i]);
            tot+=a[i];//处理出周长
        }
        int half=tot/2;//从周长一半开始循环，很显然三角形的每一条边不可以超过周长的一半
        f[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=half;j>=0;j--){
                for(int k=j;k>=0;k--){
                    if(j>=a[i]&&f[j-a[i]][k] || k>=a[i]&&f[j][k-a[i]])f[j][k]=1;//若是能够加上这根小木棒则赋值为1，f[j][k]表示能否组成边长为j,k的边，也要注意判断它加过来之前的那个f是否存在
                }
            }
        }
        for(int i=half;i>=1;i--){
            for(int j=i;j>=1;j--){
                if(f[i][j]){
                    int k=tot-i-j;
                    if(Tri(i,j,k)){
                        double val=Helen(i,j,k);
                        if(val>maxx)maxx=val;
                    }
                }
            }
        }
        if(maxx==-1)cout<<-1<<endl;//无法组成的情况
        else cout<<(int)(maxx*100)<<endl;//记得最后结果是整数并且要 *100
    }
    return 0;
}

```

---

## 作者：Demoe (赞：12)

~~退火+贪心代码看起来是最精简的~~

[P1284 三角形牧场](https://www.luogu.com.cn/problem/P1284)

我们先来简化一下题意。


- 给定 N(3≤N≤40) 条边，每条边长度 Li(1≤Li≤40)。
- 用所有边构成一个三角形，使其面积最大。
- 输出最大牧场面积乘以100然后舍尾的结果，若无解，输出 -1


------------

首先我们解决一个**数学**问题。


- 给定三角形三边，求解该三角形面积



显而易见，我们想到了**海伦公式**

设 $p=(a+b+c)/2$

${\color{LightCoral}{S= \sqrt{p(p-a)(p-b)(p-c)}}}$

我们简单对其进行证明。（部分参考百度）

- 设$a$ $b$ $c$ 对角分别为 $A$ $B$ $C$ 。
- 由余弦定理得 $\cos C = (a^2+b^2-c^2)/2ab$ 。
- $S=1/2 \times ab \times \sin C$
- $S=1/2 \times ab \times \sqrt{1 - \cos^2 C}$
- $S=1/2 \times ab \times \sqrt{1-(a^2+b^2-c^2)^24a^2 \times b^2}$
- $S=1/4 \times \sqrt{4a^2 \times b^2-(a^2+b^2-c^2)^2}$
- 经过一系列整式转换，我们得到 $S=1/4 \times \sqrt{(a+b+c)(a+b-c)(a-b+c)(-a+b+c)}$
- 于是我们代入 $p$ ，可得 $S= \sqrt{p(p-a)(p-b)(p-c)}$


------------

我们先简略描述一下标准解法——**DP**。

# DP

我们定义状态 $f_{i,j}$ 为是否能构成一个三角形使得一边长为 $i$ ，一边长为 $j$ 。

我们可得出转移方程。

```cpp
f[0][0]=1;   //初始化
for(ll i=0;i<n;i++){
	for(ll j=m/2;j>=0;j--){
		for(ll k=m/2;k>=0;k--){
			if(j-a[i]>=0&&f[j-a[i]][k]) f[j][k]=1;
       		if(k-a[i]>=0&&f[j][k-a[i]]) f[j][k]=1;
            //想象逐步加边
		}
	}
}
```

复杂度 $O(n(\sum\limits_{i=1}^nl_i)^2)$

于是我们可以得出答案。

```cpp
for(ll i=m/2;i>0;i--)
	for(ll j=m/2;j>0;j--){
    	if(!f[i][j]) continue;  //能得出两边
       	if(!ok(i,j,m-i-j)) continue;  //能构成三角形
    	ans=max(ans,sq(i,j,m-i-j));  //更新答案
    }
```


------------

# 退火 + 贪心

以下内容非常规解法（~~但挺实用的~~）

由题意得，${\color{Orange}{p}}$ 是定值。

因此要使 $S$ 最大，$a$ $b$ $c$ 要差距最小。

我们就形成了一种**贪心**——对每次三条边中**最短的**加上下一条边长

然后在每次贪心前，我们**随机打乱排列顺序**。

代码如下。 

```cpp
for(ll i=0;i<T;i++){       //随机化 
	random_shuffle(l,l+n); //打乱顺序 可以写手动 
	a[0]=l[0];a[1]=l[1];a[2]=l[2];
	for(ll i=3;i<n;i++) a[min_element(a,a+3)-a]+=l[i];  //每次加在最短的上面 
	sort(a,a+3);
	if(a[0]+a[1]<=a[2]) continue;  //判断是否能构成一个三角形 
	long double p=(a[0]+a[1]+a[2])/2.0;  //海伦公式求三角形面积 
	ans=max(ans,(ll)(trunc(sqrt(p*(p-a[0])*(p-a[1])*(p-a[2]))*100LL)));
	//实测 trunk 加上后 运行速度变快 
}
```

复杂度 $O(Tn)$

关于 $trunk$ ，它加了会快一点。

# 评测记录

点开自行查看

[退火+贪心](https://www.luogu.com.cn/record/30955887)

[退火+贪心（带 $trunk$ ）](https://www.luogu.com.cn/record/30956162)

[DP](https://www.luogu.com.cn/record/30958509)


# 附上代码全篇。

## 退火+贪心

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=55,T=1e4+5;        //T -> 随机次数 我们大概取一个10000 
ll n,ans=-1,l[N],a[3];           //这种写法的好处 省空间 
template <typename T> void rd(T &x){ //快读板子 
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
} 
void wr(ll x){  //快输板子 
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);
	for(ll i=0;i<n;i++) rd(l[i]);
	for(ll i=0;i<T;i++){       //随机化 
		random_shuffle(l,l+n); //打乱顺序 可以写手动 
		a[0]=l[0];a[1]=l[1];a[2]=l[2];
		for(ll i=3;i<n;i++) a[min_element(a,a+3)-a]+=l[i];  //每次加在最短的上面 
		sort(a,a+3);
		if(a[0]+a[1]<=a[2]) continue;  //判断是否能构成一个三角形 
		long double p=(a[0]+a[1]+a[2])/2.0;  //海伦公式求三角形面积 
		ans=max(ans,(ll)(trunc(sqrt(p*(p-a[0])*(p-a[1])*(p-a[2]))*100LL)));
		//实测 trunk 加上后 运行速度变快 
	}
	wr(ans);
	return 0;
} 
```

## DP

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const ll N=1605;
ll n,a[N],f[N][N],m;
ld ans;
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
ld sq(ll x,ll y,ll z){
	ld ss=((ld)(x+y+z))/2.00000000;
	return sqrt(ss*(ss-((ld)(x)))*(ss-((ld)(y)))*(ss-((ld)(z))));
}
bool ok(ll x,ll y,ll z){
	return x+y>z&&x+z>y&&y+z>x;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);
	for(ll i=0;i<n;i++) rd(a[i]),m+=a[i];
	f[0][0]=1;   //初始化
	for(ll i=0;i<n;i++){
		for(ll j=m/2;j>=0;j--){
			for(ll k=m/2;k>=0;k--){
				if(j-a[i]>=0&&f[j-a[i]][k]) f[j][k]=1;
        		if(k-a[i]>=0&&f[j][k-a[i]]) f[j][k]=1;
        		//想象逐步加边
			}
		}
	}
    ans=-1;
    for(ll i=m/2;i>0;i--)
		for(ll j=m/2;j>0;j--){
    		if(!f[i][j]) continue;  //能得出两边
        	if(!ok(i,j,m-i-j)) continue;  //能构成三角形
    		ans=max(ans,sq(i,j,m-i-j));  //更新答案
    	}
    if(ans!=-1) wr((ll)(ans*100)),puts("");
    else wr(ans),puts("");
	return 0;
}
```

[附上博客](https://www.luogu.com.cn/blog/jiangruohuang/)

完结撒花✿✿ヽ(°▽°)ノ✿

2020.2.23

# UPD 2020.2.7 修正了DP复杂度

---

## 作者：SFWR (赞：11)

在本题题解中，最顶上的题解中讨论的那个点，的确是原题解出现了错误。

先让我们来想一下思路，如果我们边找边做，比较麻烦，而如果我们先处理出所有能得到的三角形，再在这些三角形中找最大不就行了

那么本题的关键就是在于，处理出所有的三角形

考虑每次加入一个边i，然后，我们枚举出所有边的情况，如果加这个边前的那种情况存在，那么这个情况也一定存在。

根据三角形的性质，我们只需要考虑两个边就行了，所以就有

```cpp
	for(int i=1;i<=n;i++)
	for(int j=sum/2;j>=0;j--)
	for(int k=sum/2;k>=0;k--) 
	if(j>=val[i]&&f[j-val[i]][k]||k>=val[i]&&f[j][k-val[i]])
    f[j][k]=1;
```
之前那个题解中默认j>=k，其实是不行的，像讨论中的那个数据就是反例
3 

```cpp
3
3 4 5
```
然后就是找面积了，这个地方就很简单了，就是枚举出所有边的情况注意判断并更新面积就行了

```cpp
for(int i=sum/2;i>=1;i--)
for(int j=sum/2;j>=1;j--)
if(f[i][j]&&flg(i,j,sum-i-j))
maxn=max(maxn,hl(i,j,sum-i-j));
```
然后就没了啊，注意一下double与最后输出的格式就行了

附判断与海伦公式

```cpp
double hl(double i,double j,double k)
{double p=(i+j+k)/2;
return sqrt(p*(p-i)*(p-j)*(p-k));}
int flg(int i,int j,int k)
{if(i+j>k&&i+k>j&&k+j>i)return 1;return 0;}
```


---

## 作者：hulean (赞：5)

思路楼上楼下也给过了，这里详细解析一遍

- 状态:
```cpp
dp[i][j]表示用i和j的木板能否搭成，不用去管第三块，因为知道了两块的长度与周长，那就可以表示出第三块:c-i-j
```
- 转移
```cpp
有点类似于背包
if((j-l[i]>=0&&dp[j-l[i]][k])||(k-l[i]>=0&&dp[j][k-l[i]]))dp[j][k]=1;
因为此状态只可能从没加上这根木板的时候转移过来
```
- 判断
```cpp
判断这三块木板能否组成三角形
inline bool check(int a,int b,int c)
{
	if(a+b>c&&a+c>b&&b+c>a)return 1;
	return 0;
}
check(i,j,c-i-j)
```
- 计算面积
```cpp
这里用到了海伦公式
```
$S=\sqrt{p*(p-a)*(p-b)*(p-c)}$

$p$为半周长:$(a+b+c)/2$
```cpp
具体可以查百度
inline double get(double a,double b,double c)//注意，这里不能定义成整型，否则会WA
{
	double p=(a+b+c)/2;
	return sqrt(p*(p-a)*(p-b)*(p-c));
}
```
献上完整代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c;
int l[50];
int wood[4];
bool dp[800+10][800+10];
inline double get(double a,double b,double c)//计算面积
{
	double p=(a+b+c)/2;
	return sqrt(p*(p-a)*(p-b)*(p-c));
}
inline bool check(int a,int b,int c)//能否组成三角形
{
	if(a+b>c&&a+c>b&&b+c>a)return 1;
	return 0;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>l[i],c+=l[i];
	dp[0][0]=1;//初始状态
	for(int i=1;i<=n;i++)
	{
		for(int j=c/2;j>=0;j--)
		{
			for(int k=c/2;k>=0;k--)
			{
				if((j-l[i]>=0&&dp[j-l[i]][k])||(k-l[i]>=0&&dp[j][k-l[i]]))dp[j][k]=1;//状态转移
				//cout<<dp[j][k]<<" ";
			}
			//cout<<endl;
		}
	}
	double ans=-1;
	for(int i=c/2;i>=1;i--)
	{
		for(int j=c/2;j>=1;j--)
		{
			if(dp[i][j]&&check(i,j,c-i-j))ans=max(ans,get(i,j,c-i-j));//找到最大值
		}
	}
	cout<<(int)(ans==-1?-1:ans*100)<<endl;
	return 0;
}
```

---

## 作者：Drinkwater (赞：4)

这道题花了我一晚上的时间去做，其实不难，但是就是一个double型定成了int型，改了一晚上

我们用dp[i][j][k]分别表示长度为i，j的两条边，在前k块木板是否能被构造出来

我们用dfs来预处理，然后来枚举

/*************************************************************************

    > Author: Drinkwater-cnyali
    > Created Time: 2017/5/2 19:12:43
************************************************************************/













```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
const int inf = 0x3f3f3f3f;
const int maxn = 1600 + 10;
int n;
int l[maxn],sum = 0;
bool dp[maxn/2][maxn/2][41];
double ans = -1;
double S(int x,int y)
{
    double p = sum/2.0;
    int z = sum - x - y;
    if(x+y<=z || y+z<=x || x+z<=y)return -1;
    double s = sqrt(p * fabs(p-x) * fabs(p-y) * fabs(p-z));
    return s*100;
}
int p[maxn];
void dfs(int x,int a,int b)
{
    if(a > sum/2 || b > sum/2)return ;
    if(dp[a][b][x] || dp[b][a][x])return ;
    if(x > n){dp[a][b][x] = 1;return ;}
    dp[a][b][x] = 1;
    dfs(x+1,a+l[x],b);
    dfs(x+1,a,b+l[x]);
    dfs(x+1,a,b);
}
int main()
{
    n = read();REP(i,1,n)l[i] = read(),sum += l[i];
    dfs(1,0,0);
    REP(i,1,sum/2+1)
    {
        REP(j,1,sum/2+1)
        {
            if(dp[i][j][n+1])
            {
                ans = max(ans,S(i,j));
            }
        }
    }
    printf("%d\n",(int)ans);
    return 0;
}

```

---

## 作者：SBS苏 (赞：4)

dp题目，用dp[i][j][k]表示前i块木板是否能拼成j、k长度，即可。

下面看代码：

/\*
Problem:

OJ:
User:    S.B.S.

Time:
Memory:

Length:

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<cassert>
#include<climits>
#include<functional>
#include<bitset>
#include<vector>
#include<list>
#define F(i,j,k) for(int i=j;i<=k;++i)
#define M(a,b) memset(a,b,sizeof(a))
#define FF(i,j,k) for(int i=j;i>=k;i--)
#define maxn 10001
#define inf 0x3f3f3f3f
#define maxm 4001
#define mod 998244353
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m;
bool dp[2000][2000];
int d[41];
int sum=0;
double ans=-1.0;
inline double solve(int a,int b,int c)
{
    if(c==0||a+b<=c||b+c<=a||a+c<=b) return -1;
    double p=(a+b+c)/2.0;
    return 100*sqrt(p*fabs(p-a)*fabs(p-b)*fabs(p-c));
}
int main()
{
    std::ios::sync_with_stdio(false);//cout<<setiosflags(ios::fixed)<<setprecision(1)<<y;
    #ifdef LOCAL
    freopen("pasture.in","r",stdin);
    freopen("pasture.out","w",stdout);
    #endif
    cin>>n;
    F(i,1,n) cin>>d[i],sum+=d[i];
    F(i,1,n) dp[0][0]=true;
    F(k,1,n)FF(i,sum,0)FF(j,sum,0){
        if(i>=d[k]) dp[i][j]=dp[i][j]||dp[i-d[k]][j];
        if(j>=d[k]) dp[i][j]=dp[i][j]||dp[i][j-d[k]];
        if(k==n&&i&&j&&dp[i][j]) ans=max(ans,solve(i,j,sum-i-j));
    }
    cout<<(int)(ans)<<endl;
    return 0;
}

```

---

## 作者：Paul_Guderian (赞：0)

这道题是一个比较新鲜的二维背包，而且呢这里的二维指的是这个背包

是分成两个区域的，两个区域之间互不干扰——意思就是同时进行两个背包，

但是这两个背包使用的物品又是一样的。

最后呢我们用海伦公式以及三角形成立条件更新答案就是了。

```cpp
#include<math.h>
#include<stdio.h>
#include<algorithm>
#define go(i,a,b) for(int i=a;i<=b;i++)
#define ro(i,a,b) for(int i=a;i>=b;i--)
using namespace std;const int N=45;
int n,w[N],W;double ans=0;bool f[N*N][N*N];
double S(double a,double b,double c)
{
    double p=(a+b+c)/2;
    return sqrt(p*(p-a)*(p-b)*(p-c))*100;
}
void isTriangle(int a,int b,int c)
{
    if(a<=0||b<=0||c<=0||a+b<=c||a+c<=b||b+c<=a)return;
    ans=max(ans,S(1.0*a,1.0*b,1.0*c));    
}
int main()
{
    scanf("%d",&n);f[0][0]=1;
    go(i,1,n)scanf("%d",w+i),W+=w[i];
    go(i,1,n)ro(j1,W,0)ro(j2,W,0)
    {
        if(j1-w[i]>=0)f[j1][j2]|=f[j1-w[i]][j2];
        if(j2-w[i]>=0)f[j1][j2]|=f[j1][j2-w[i]];
        if(f[j1][j2])isTriangle(j1,j2,W-j1-j2);
    }
    if(floor(ans)==0)puts("-1");
    else printf("%.0lf\n",floor(ans));return 0;
}//Paul_Guderian

(NOTE:无解输出的是-1)

```

---


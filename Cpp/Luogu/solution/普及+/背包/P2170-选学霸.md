# 选学霸

## 题目描述

老师想从 $n$ 名学生中选 $m$ 人当学霸，但有 $k$ 对人实力相当，如果实力相当的人中，一部分被选上，另一部分没有，同学们就会抗议。所以老师想请你帮他求出他该选多少学霸，才能既不让同学们抗议，又与原来的 $m$ 尽可能接近。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n,m \le 2 \times 10^4$。

## 样例 #1

### 输入

```
4 3 2
1 2
3 4```

### 输出

```
2```

# 题解

## 作者：望眼浮云 (赞：40)

选学霸？~~那当然选我啦~~

首先把实力相同的全都用**并查集**并起来，把在每个集合的人数记录下来

然后就是**背包问题**了，注意，要使原来的M尽可能接近的选出学霸的数目，可能选多余m个人，所以把背包容量扩大为2m


```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int f[100000],p[100000],i,j,x,y,k,m,n,s[100000],dp[100000],tot;
int find(int u)
{
	if(f[u]==u) return u;
	else return f[u]=find(f[u]);
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(i=1;i<=n;i++)
		f[i]=i,p[i]=1; //p预处理为1,因为一开始每个集合只有一个数
	for(i=1;i<=k;i++)
	{
		scanf("%d%d",&x,&y);
		int u=find(x);int v=find(y); //并查集
		if(u!=v) f[u]=v,p[v]+=p[u];  //p记录集合元素个数
	}
	for(i=1;i<=n;i++) //找到每个集合的根节点，把集合的元素个数存起来
	if(f[i]==i)
	{
		tot++;
		s[tot]=p[i];
	}
	for(i=1;i<=tot;i++) //背包问题
		for(j=2*m;j>=s[i];j--)
			dp[j]=max(dp[j],dp[j-s[i]]+s[i]);
	int ans=999999999,minn=999999999;
	for(i=1;i<=2*m;i++)	//找到最接近m的
	{
		if(minn>abs(dp[i]-m)) minn=abs(dp[i]-m),ans=dp[i];
	}
	if(ans==999999999) printf("0");
	else	printf("%d",ans);
	return 0;
}
```

---

## 作者：蒟蒻zExNocs (赞：21)

很多人都是着重讲了一下并查集，但是我觉得很多人都不懂为啥用背包吧。。（我当时也想了很长时间为啥要用背包，为啥背包内存要开到2*m )

定义$dp[j]$为要求最多选取 $j$个人的时候实际上可以选取的最大人数。 

什么意思？按照题目来讲，一群实力相当的人要么被选，要么不被选，选不选都是由不选他的状态转移过来的，那就跟背包差不多了。

假如一共有 5 个人，有4个人实力相当，那么

$dp[5]=4+1=5,dp[4]=4,dp[3]=1$，

也就是说要求最多可以选取三个时我们只能选取一个人，这个数值就可以用背包来寻找，可以得到：

```
for(int i=1;i<=cnt;i++)
for(int j=n;j>=b[i];j--)
dp[j]=max(dp[j],dp[j-b[i]]+b[i]);
```


1. 背包物品的个数为$cnt$，也就是并查集的根节点数（实力不相当的人数，也可以说是集合的个数）

2. $b[i]$是第i个集合的总人数。

3. 背包容量别人都是写的$2M$，因为一般是超不过$2M$人，实际上背包容量也可以写$N$，因为怎么说选取人数也不可能超过总人数(可能稍微比$2M$慢一点)。

不过要注意一点，要特判一波$M=0$的情况，这时候直接输出0就可以了，或者最后寻找ans的时候从i=0开始寻找。

code(带说明):

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll int
#define pc(a) putchar(a)
#define rg register
inline void gc(char &a)
{
    a=getchar();
    while(a<'0'||a>'9') a=getchar();
}
ll read(){
    char c;ll x=0;bool flag=0;c=getchar();
    while(c<'0'||c>'9'){if(c=='-') flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48),c=getchar();}
    return flag?-x:x;
}
void pr(ll x){
    if(x<0){x=-x;pc('-');}
    if(x>9) pr(x/10);
    pc(x%10+48);
}
//--------快读--------
const ll maxn=20005;
const ll maxx=0x3f3f3f3f;
ll dp[maxn],f[maxn],n,m,k,a[maxn],b[maxn],cnt,amin=maxx,ans=maxx;
ll find(ll x)
{
    return f[x]==x? x:f[x]=find(f[x]);
}//并查集
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
    f[i]=i,a[i]=1;//并查集人数默认为1
    for(int u,v,i=1;i<=k;i++)
    {
        u=read(),v=read();
        if(find(u)!=find(v))
        {
            a[find(v)]+=a[find(u)];//人数累加
            f[find(u)]=find(v);
        }
    }
    for(int i=1;i<=n;i++)
    if(i==f[i])	b[++cnt]=a[i];
    //寻找并查集集合个数，并记录总人数
    for(int i=1;i<=cnt;i++)
        for(int j=n;j>=b[i];j--)
            dp[j]=max(dp[j],dp[j-b[i]]+b[i]);	
    for(int i=0;i<=n;i++)//寻找最接近的m的ans
        if(amin>abs(dp[i]-m))
        amin=abs(dp[i]-m),ans=dp[i];
    if(ans==maxx) pr(0);
    else pr(ans);
    return qwq;
}
```


---

## 作者：LlLlCc (赞：13)

一道非常裸的**背包**，将题意转化一下就更明显了：N个班，每个班有v[i]人，求选出M个班参加活动，abs(活动人数-K)最小。

相信大家对转化后的题目十分了解，著名的背包问题教程**背包九讲**就曾详细的介绍过，设f[i]表示**是否能选出i个人参加，1表示可以，0则不行**

转移方程很简单：
```
f[j]|=f[j-v[i]]
```
------------
好了，转化后的问题我们已经解决了，可是怎么转化呢？

题目说明，对于一组实力相等的，必须同时选上。即：**这两个人要不同时选，要不同时不选，也能理解为他们是同一个人，只不过这个人比较神器，一人抵两人**，所有我们只要把所有有关联的人当成同一个人就好了。

具体见代码吧：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,x,y,fa[maxn],allv,m,lnk[maxn],v[maxn],tot;
bool f[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline int getfa(int x){
	if (fa[x]==x) return x;
	return fa[x]=getfa(fa[x]);
}
int main(){
	n=read(),allv=read(),m=read();
	for (int i=1;i<=n;i++) fa[i]=i;
	for (int i=1;i<=m;i++){
		x=read(),y=read();
		int fx=getfa(x),fy=getfa(y);
		if (fx==fy) continue;
		fa[fy]=fx;
	}
	for (int i=1;i<=n;i++){
		if (!lnk[getfa(i)]) lnk[fa[i]]=++tot;
		v[lnk[fa[i]]]++;
	}
	f[0]=1;
    for (int i=1;i<=tot;i++) 
    for (int j=allv<<1;j>=v[i];j--) f[j]|=f[j-v[i]];
    for (int i=0;i<=allv;i++){    //挑绝对值最小
    	if (f[allv-i]){printf("%d",allv-i);return 0;}
    	if (f[allv+i]){printf("%d",allv+i);return 0;}
    }
}
```


---

## 作者：Sino_E (赞：11)

k对实力相当的学生显然可用并查集维护，这些学生捆绑在一起成为一个物件。

于是如下方题解所说的，转化成了一道可行性dp题目。

观察到空间复杂度过高，使用滚动数组进行优化。

同时重量相同的物件可能过多导致TLE（比如没有一对实力相当的学生），此时我们使用多重背包下的优化方案，对多个重量相同的物件进行二进制的分解。仔细想了一下，是个比较大的优化？

（然而实际上不加也不会TLE的样子

至少本题数据来看，如此耗时是0ms的。

细节见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e4+10;
bool f[N]; // 可行性dp数组
int fa[N]; // 并查集
int siz[N]; // 并查集大小
int prew[N],w[N],p; // 多重背包预处理用数组和实际用0-1背包数组
inline int Find(int x){
    if(!fa[x]) return x;
    return fa[x]=Find(fa[x]);
}
inline bool Union(int a,int b){
    int af=Find(a),bf=Find(b);
    if(af==bf) return false;
    siz[bf]+=siz[af];
    fa[af]=bf;
    return true;
}

int main(){
    ios::sync_with_stdio(false);
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++) siz[i]=1;
    int u,v;
    for(int i=0;i<k;i++){
        cin>>u>>v;
        Union(u,v);
    }
    for(int i=1;i<=n;i++)
        if(!fa[i]){
            prew[siz[i]]++;
        }
    int pl=1;
    for(int i=1;i<=n;i++){
        pl=1;
        while(prew[i]){
            if(prew[i]&1) w[++p]=pl*i;
            pl<<=1,prew[i]>>=1;
        }
    } // 进行多重背包的2进制分解
    int ans=0x3f3f3f3f,nans=0x3f3f3f3f;
    f[0]=1;
    for(int i=1;i<=p;i++)
        for(int j=n;j>=0;j--){
            if(j>=w[i]) f[j]|=f[j-w[i]];
        } // 进行可行性dp
    for(int i=0;i<=m+nans;i++)
        if(f[i] && abs(m-i)<nans) ans=i,nans=abs(m-i); // 枚举答案
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：彼岸归航 (赞：10)

## 思路：用并查集合并同一水平的人，找出个数（统计？），然后背包

------------
### 并查集部分
这里只要把该合并的合并掉就行。  
**注意：合并完以后，还要把每一个的f更新一遍，不然会挂（比如1的f是2，但2的f是3，统计的时候就会出问题）**
```cpp
int f[20001];
int find(int x)
{
    if(f[x]==x) return f[x];
    f[x]=find(f[x]);
    return f[x];
}
void merge(int x,int y)
{
    f[find(x)]=f[find(y)];
}
```
main函数里的部分：
```cpp
for(int i=1;i<=n;i++) f[i]=i;
for(int i=1;i<=k;i++)
{
    int x,y;
    scanf("%d%d",&x,&y);
    if(find(x)!=find(y)) merge(x,y);
}
for(int i=1;i<=n;i++) f[i]=find(f[i]);//更新f
```
------------
### 统计部分
这里只要按照桶排的思路做就可以了。
```
int t[20001];
int cnt,a[20001];
```
main：
```
for(int i=1;i<=n;i++) t[f[i]]++;
for(int i=1;i<=n;i++)
{
    if(t[i])//过滤不需要的0
    {
        a[++cnt]=t[i];//水平一样的可以看作一个集体，价值就是人数
    }
}
```

------------

### 背包部分
这就没什么好说的了。
```
bool u[20001];
int ans;
```
main：
```
    u[0]=1;
    for(int i=1;i<=cnt;i++)//一共cnt个物品
    {
        for(int j=n-a[i];j>=0;j--)
        {
            if(u[j]) u[j+a[i]]=1;
        }
    }
```


------------

### 求解部分
直接过一遍，反正n只有20000。  
完整代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int f[20001];
int t[20001];
int cnt,a[20001];
bool u[20001];
int ans;
int find(int x)
{
    if(f[x]==x) return f[x];
    f[x]=find(f[x]);
    return f[x];
}
void merge(int x,int y)
{
    f[find(x)]=f[find(y)];
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) f[i]=i;
    for(int i=1;i<=k;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(find(x)!=find(y)) merge(x,y);
    }
    for(int i=1;i<=n;i++) f[i]=find(f[i]);
    for(int i=1;i<=n;i++) t[f[i]]++;
    for(int i=1;i<=n;i++)
    {
        if(t[i])
        {
            a[++cnt]=t[i];
        }
    }
    u[0]=1;
    for(int i=1;i<=cnt;i++)
    {
        for(int j=n-a[i];j>=0;j--)
        {
            if(u[j]) u[j+a[i]]=1;
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(u[i]&&abs(ans-m)>abs(i-m)) ans=i;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Miri (赞：9)

这题真是折磨死我了，先是手残把l打成n，然后把i达成了j，调试了好久好久/哭……我大概是石乐志了吧

这道题的算法好想，但是实现的时候有很多细节容易出错

我看了各位大佬发表的题解，都思路都非常巧妙，本小芋头的找人数方法不是很一样，是在合并的循环里面找，如果并没有合并的话就合并，同时把两者的人数加到爸爸的头上，然后循环找祖先的时候直接让dalao[l++]=人数[i]就行了。要注意的是，一开始大家都是一个人各成一组，所以每一组开始自己叫自己爸爸的时候，组里面赋的初值是1。

然后看看能组成多少种人数，用01背包的方法就可以找全啦！

最后，用能组成的人数去更新ans的值，找出和m相差最小的值就行了。其中，minn存的是和m的最小差值，ans存的是最小差值的情况下选的学霸数。

代码如下：（个人看着有注释的代码感觉有点乱，所以就把注释消了，不知道大家怎么看，大部分思路都写到上面啦！）

```cpp
#include<iostream>
#include<stdlib.h>
#include<climits>
using namespace std;
int p[20001],f[20001],ff[20001],dalao[20001];
int father(int a) {
    if(f[a]!=a)
        f[a]=father(f[a]);
    return f[a];
}
void union_(int a,int b) {
    int f1=father(a),f2=father(b);
    if(f1!=f2)
        f[f1]=f2,p[f2]+=p[f1];
}
int main() {
    int n,m,k,l=0,ans,minn=INT_MAX;
    cin>>n>>m>>k;
    for(int i=1; i<=n; i++)
        p[i]=1,f[i]=i;
    for(int i=1; i<=k; i++) {
        int a,b;
        cin>>a>>b;
        union_(a,b);
    }
    ff[0]=true;
    for(int i=1; i<=n; i++)
        if(f[i]==i)
            dalao[++l]=p[i];  //放入背包
    for(int i=1; i<=l; i++)
        for(int j=n; j>=dalao[i]; j--)
            if(!ff[j]&&ff[j-dalao[i]])
                ff[j]=true;
    for(int i=0; i<=n; i++)
        if(ff[i]&&abs(i-m)<minn) minn=abs(i-m),ans=i;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：青石巷 (赞：5)

01背包+并查集。和搭配购买类似。

因为选了一个人，其他实力相当的人也必须选，是双边依赖关系，所以可以将其看成一件物品。

因为背包的容量不定，要求最为接近m，考虑其最小为0，最大为n，所以**背包容量开到n**，dp之后查找m+1到n之间abs(dp[i]-m)之间的最小值，与(m-dp[m])比较即可。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
const int maxn=20000+10;
int father[maxn],c[maxn],dp[maxn];
int n,m,k;
int find(int x)
{
    if(father[x]<0){return x;}
    else{father[x]=find(father[x]);}
    return father[x];
}
void union_set(int x,int y)
{
    x=find(x);y=find(y);
    if(x==y){return;}
    else if(-father[x]>-father[y])
    {
        father[x]+=father[y];
        father[y]=x;
    }
    else
    {
        father[y]+=father[x];
        father[x]=y;
    }
}
int main()
{
    int i,j,u,v,tot=0,ans1,ans2;
    cin>>n>>m>>k;
    memset(father,-1,sizeof(father));
    for(i=1;i<=k;i++){scanf("%d%d",&u,&v);union_set(u,v);}
    for(i=1;i<=n;i++){if(father[i]<0){c[++tot]=-father[i];}}
    for(i=1;i<=tot;i++)
    {
        for(j=n;j>=c[i];j--)
        {
            dp[j]=max(dp[j],dp[j-c[i]]+c[i]);
        }
    }
    ans1=abs(m-dp[m]);ans2=abs(m-dp[m+1]);
    for(i=m+1;i<=n;i++)
    {
        ans2=min(ans2,abs(m-dp[i]));
    }
    if(ans1<=ans2){cout<<dp[m];}
    else{cout<<m+ans2;}
    return 0;
}
```

---

## 作者：Memorize (赞：4)

这道题就是一道很简单的背包问题了 把实力相同的人捆绑乘一个物品  权重为人数之和 如果没有人和他实力相同则权重为1

最后就是一道装箱问题了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,m,k,x,y,sum=0,k1=0;
int a[20010],head[200010];
bool f[20010],vis[20010];
int ans=0x7f7f7f,kk;
struct node{
    int to,next;
}e[100010];
void add(int u,int v)
{
    e[++k1].next=head[u];
    e[k1].to=v;
    head[u]=k1;
}
int dfs(int x)
{
    vis[x]=true;int sum=1;
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(!vis[v])
        sum+=dfs(v);
    }
    return sum;
}
int main()
{
    memset(f,false,sizeof(f));
    memset(vis,false,sizeof(vis));
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=k;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
    }
    for(int i=1;i<=n;i++) if(!vis[i])
    a[++sum]=dfs(i);
    f[0]=true;
    for(int i=1;i<=sum;i++)
     for(int j=n;j>=1;j--)
      if(j-a[i]>=0&&f[j-a[i]]) f[j]=true;
    for(int i=0;i<=n;i++)   
     if(f[i]&&abs(i-m)<ans) ans=abs(i-m),kk=i;
    printf("%d",kk); 
    return 0;
}
```

---

## 作者：Lucaster_ (赞：4)

其实这道题没啥好写的

主要是思路比较清奇

竟然把并查集都融合到背包里了

代码如下：

```cpp
#include<cmath>
#include<iostream>
#define N 20002
#define M N*2
#define INF 999999999
using namespace std;
int i,j,k,m,n,x,y,f1,f2,c[N],f[M],v[N],fa[N];
 inline int find(int x)
  {return fa[x]==x?x:fa[x]=find(fa[x]);}
int tot=0,ans=INF,minn=INF;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>k;
    for(i=1;i<=n;i++)
     {c[i]=1;fa[i]=i;}
    for(i=1;i<=k;i++)
    {
        cin>>x>>y;
        f1=find(x);f2=find(y);
        if(f1==f2) continue;
        fa[f1]=f2;
        c[f2]+=c[f1];
    }
    for(i=1;i<=n;i++)
     if(fa[i]==i) v[++tot]=c[i];
    for(i=1;i<=tot;i++)
     for(j=2*m;j>=v[i];j--)
      f[j]=max(f[j],f[j-v[i]]+v[i]);
    for(i=1;i<=2*m;i++)
     if(abs(m-f[i])<minn)
     {
     	minn=abs(m-f[i]);
     	ans=f[i];
     }
    if(ans==INF) cout<<'0';
    else cout<<ans;
    return 0;
}
```
主要分为三部分

## 1.采用并查集预处理

因为我们在读入的时候很多人会重复出现

用bool数组判定每个人所在分组太麻烦

于是自然而然的想到并查集来维护团体信息

```
    for(i=1;i<=n;i++)
     {c[i]=1;fa[i]=i;}
    for(i=1;i<=k;i++)
    {
        cin>>x>>y;
        f1=find(x);f2=find(y);
        if(f1==f2) continue;
        fa[f1]=f2;
        c[f2]+=c[f1];
    }
```

c数组是干什么用的

看下头

## 2.将并查集中的信息转化为背包物品的体积

这时候c就有用了

告诉你每个人所在的这个**实力相当**的一部分人中

一共有多少个人

十分巧妙的一个数组

代码也很简单：


```
for(i=1;i<=n;i++)
 if(fa[i]==i) v[++tot]=c[i];
```


## 3.剩下的按背包做就好啦


```
for(i=1;i<=tot;i++)
 for(j=2*m;j>=v[i];j--)
  f[j]=max(f[j],f[j-v[i]]+v[i]);
```

## 4.这道题还没结束

因为我们f中存的是最大“序号”

答案求的是与M差值最小的f值

故用for循环扫一遍

做差看是否能得到更小值

能的话就更新ans

## 5.
### if(ans==INF) cout<<'0';
### else cout<<ans;

tips：小坑点——在枚举容量的时候，要从2 * m开始，否则会得不到正确结果

原因：~~我也不知道等知道了在更新上吧~~

---

## 作者：nekko (赞：2)

（这不是Poj 1112 Team Them Up!超级弱化版么。。。）

由题意可得，如果某些人因为关系而连接在了一起，要么都不选，要么都选。

然后可以用并查集维护这个“关系”，然后将每个集合得size作为贡献。

然后这就是一个判定性01背包得经典模型了，对于每个集合选或不选是否可行进行dp。

滚动数组压一下空间就行了。

时间复杂度？上界是n^2的样子。。。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>

using namespace std;

const int N = 20010;

int fa[N], sz[N];

int get(int x) {
    return x == fa[x] ? x : fa[x] = get(fa[x]);
}

int chose[N], id, f[2][N * 4], p;

int n, m, k;

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 1 ; i <= n ; ++ i) {
        fa[i] = i;
    }
    for(int i = 1, x, y ; i <= k ; ++ i) {
        scanf("%d%d", &x, &y);
        fa[get(x)] = get(y);
    }
    for(int i = 1 ; i <= n ; ++ i) {
        ++ sz[get(i)];
    }
    for(int i = 1 ; i <= n ; ++ i) {
        if(i == get(i)) {
            chose[++ id] = i;
        }
    }
    f[p][N + 0] = 1;
    for(int i = 1 ; i <= id ; ++ i) {
        p ^= 1;
        for(int j = -20000 ; j <= 20000 ; ++ j) {
            f[p][N + j] = f[p ^ 1][N + j - sz[chose[i]]] | f[p ^ 1][N + j];
        }
    }
    for(int i = 0 ; i <= 20000 ; ++ i) {
        if(f[p][N + m - i]) {
            printf("%d\n", m - i);
            break;
        } else if(f[p][N + m + i]) {
            printf("%d\n", m + i);
            break;
        }
    }
}
```

---

## 作者：wwq123 (赞：2)

1.这题是对并查集和01背包的综合运用

2.我们先通过并查集将所有实力相近的学生分成一个一个组，每个组的人数就相当于01背包中物品的价值

3.这题稍微区别裸的01背包的地方就是它取得是最接近m的值，而非小于等于m的最大值，所以我们的dp数组判断的必须是与m差的绝对值，第二重循环也因此变为从n开始，而非从m开始

以下为代码（由于本人实力有限，对于一些冗杂的语句还望见谅）

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=20000+2;
int par[MAXN],rank[MAXN];
int ha[MAXN],fz[MAXN];
int dp[MAXN];
int n,m,k;
int find(int x){
         if(par[x]==x) return x;
         else return par[x]=find(par[x]);
}
void unite(int x,int y){
         x=find(x);
         y=find(y);
         if(x==y) return;
         if(rank[x]<rank[y]) par[x]=y;
         else{
                  if(rank[x]==rank[y]) rank[x]++;
                  par[y]=x;
          }
}
int main(){
          cin>>n>>m>>k;
          for(int i=1;i<=n;i++) par[i]=i;
          for(int i=1;i<=k;i++){
                   int a,b;
                   cin>>a>>b;
                   if(find(a)!=find(b)) unite(a,b);
          }
         for(int i=1;i<=n;i++){
              int k=find(i);
                  ha[k]++;
         }
         int js=0;
         for(int i=1;i<=n;i++){
                  if(ha[i]!=0){
                          fz[js]=ha[i];
                          js++;
                  }
          }
          for(int i=0;i<js;i++){
                   for(int j=n;j>=fz[i];j--){
                            if(abs(m-dp[j])>abs(m-dp[j-fz[i]]-fz[i])) 
                                 dp[j]=dp[j-fz[i]]+fz[i];
                   }
          }
          int mn=99999999;
          for(int i=0;i<=n;i++)
                   if(abs(m-dp[i])<abs(m-mn)) mn=dp[i];
          cout<<mn<<endl;
          return 0;
}
```

---

## 作者：依依 (赞：2)

解：
这题仔细思考还是有结果的 

根据题意可得，对于实力相当的一群人，要么不选，要么都选  
我们就把这一群人看成一个物品，  
跑一边背包，体积范围为 0->m*2  
然后枚举所有体积，找到最合适的答案  


[I like 泡泡糖](http://www.cnblogs.com/adelalove/p/8696354.html)

---

## 作者：Kwork (赞：2)

并查集+DP

首先我们先把所有的人分组，然后把每一组当成一个物品得到每组的人数

然后做一遍DP，由于是与m的差的绝对值最小，所以背包的容量定为2\*m。

然后我们对与f数组按与m的差的绝对值大小做统计，若容量为v的背包里面刚好装了v的物品，那么说明可行，直接输出答案。

-----------------------------------------------------------------------------------------------------------------------------------------


    
```cpp
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
const int maxn=20005;
int n,m,k,tot;
int p[maxn];
int man[maxn];
int f[maxn+maxn];
int find(int x){
    return (x==p[x]?x:p[x]=find(p[x]));
}
void solve(){
    memset(f,0,sizeof(f));
    for(int i=1;i<=tot;i++)
        for(int j=2*m;j>=man[i];j--)
            f[j]=max(f[j],f[j-man[i]]+man[i]);
    for(int i=0;i<=m;i++){
        if(f[m-i]==m-i){
            cout<<m-i<<endl;
            return;
        }
        if(f[m+i]==m+i){
            cout<<m+i<<endl;
            return;
        }
    }
    return;
}
int main(){
    cin>>n>>m>>k;
    int u,v;
    for(int i=1;i<=n;i++)
        p[i]=i;
    for(int i=1;i<=k;i++){
        cin>>u>>v;
        int x=find(u);
        int y=find(v);
        p[x]=y;
    }
    memset(man,0,sizeof(man));
    for(int i=1;i<=n;i++)    
        man[find(i)]++;
    tot=0;
    for(int i=1;i<=n;i++)
        if(man[i]!=0) man[++tot]=man[i];
    solve();
    return 0;
}
```

---

## 作者：tututu (赞：2)

DP+并查集

先用并查集将所有人分组（相同实力一组）

然后将每组视为一件物品，大小就是人数

用DP算出可以组合成的所有种数

（见程序）

穷举一次

找到最接近m的即为答案（相同则取小）

pascal code:

```cpp
var
  n,m,k,i,j,min,x:longint;
  a,b,t,t1,f,ff:array[-1..100002] of longint;
  boo:array[-1..100002] of boolean;
function find(x:longint):longint;//find用来查找祖先……
begin
  while f[x]<>x do x:=f[x];
  exit(x);
end;
begin
  readln(n,m,k);
  for i:=1 to k do readln(a[i],b[i]);//读入实力相同的对
  for i:=1 to n do f[i]:=i;//父亲
  for i:=1 to k do
    f[b[i]]:=f[a[i]];//合并
  for i:=1 to n do inc(ff[find(i)]);//统计每组的人数
  x:=0;//x表示组数
  fillchar(f,sizeof(f),0);//重置f，回收再利用
  for i:=1 to n do if ff[i]>0 then begin inc(x); f[x]:=ff[i]; end;//若某组有人，加入已有‘物品’
  boo[0]:=true;//boo[i]表示能否组合出I个人而实力相同的不遗漏
  for i:=1 to x do
    for j:=n downto f[i] do
      if boo[j-f[i]] then boo[j]:=true;//DP不题
  for i:=1 to n do
    if boo[i] then if abs(i-m)<abs(min-m) then min:=i;//枚举寻找最接近值
  write(min);
end.
```

---

## 作者：木木！ (赞：1)

先用并查集维护连通块，然后背包。（和各位dalao思路一样QwQ）

但是考虑以下数据：

```
20000 10000 0
```

这样能卡掉一些直接暴力枚举连通块做0/1背包的算法（轻松卡成$\Theta(n^2)$）。

为了不被卡，我将同样大小的连通块归到一起，搞个多重背包，加上二进制分解优化，可以做到$\Theta(nlogn)$到$\Theta(n\sqrt{n})$（期望时间复杂度？不会算）

然后，我采用的是先二进制分解完再跑0/1背包，而不是边跑背包边分解。这样做的好处是每种物品最多只有2个，坏处是，时间复杂度没有变化。（该最坏$\Theta(n\sqrt{n})$还是$\Theta(n\sqrt{n})$）

总时间复杂度$\Theta(nlogn)$

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

void chkmin(int& a,int b)
{
	if(b<a)
	{
		a = b;
	}
}

int st[20005];
int siz[20005];

int getfa(int x)
{
	return st[x]==x?x:st[x]=getfa(st[x]);
}

void unio(int a,int b)
{
	if(getfa(a)!=getfa(b))
	{
		if(siz[st[a]] > siz[st[b]])
		{
			siz[st[a]] += siz[st[b]];
			st[st[b]] = st[a];
		}
		else
		{
			siz[st[b]] += siz[st[a]];
			st[st[a]] = st[b];
		}
	}
}

int ni[20005];
int dp[20005];

int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	
	for(int i=1; i<=n; ++i)
	{
		siz[i] = 1;
		st[i] = i;
	}
	
	for(int i=1; i<=k; ++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		unio(a,b);
	}
	
	for(int i=1; i<=n; ++i)
	{
		if(siz[getfa(i)])
		{
			++ni[siz[st[i]]];
			siz[st[i]] = 0;
		}
	}
	
	for(int i=1; i<=n; ++i)
	{
		for(int j=0; ni[i]>(1<<j); ++j)
		{
			++ni[i*(1<<j)];
			ni[i] -= 1<<j;
		}
		if(ni[i]>1)
		{
			int tmp = ni[i]-1;
			++ni[i*(ni[i]-1)];
			ni[i] -= tmp;
		}
	}
	
	int v = min(n,m*2);
	dp[0] = 1;
	
	for(int i=1; i<=n; ++i)
	{
		for(int k=1; k<=ni[i]; ++k)
		{
			for(int j=v-i; j>=0; --j)
			{
				if(dp[j])
				{
					dp[j+i] = 1;
				}
			}
		}
	}
	
	int ans = 0;
	for(int i=0; i<=n; ++i)
	{
		if(dp[i])
		{
			if(abs(m-i)<abs(m-ans))
			{
				ans = i;
			}
		}
	}
	
	printf("%d",ans);
}
```

最后一想，加单调队列优化能做到最好情况$\Theta(n)$的样子……emmmmm……

……反正大家最坏都$\Theta(n\sqrt{n})$

---

## 作者：Linne (赞：1)

这道题大概分为两块：一块是联通块问题，另一块是背包问题，那么我分别讲一个新思路。

------------

1、联通块问题，我们首先想到的就是并查集。然而实际上方法并不止这一种，dfs和bfs都可以。这里我用dfs：先把实力相当的同学两两建边，然后对于每个未被标记的节点（同学），做一遍dfs，然后把所有扩展的节点都标记，这样我们就求出了每一个联通块。

------------

2、背包问题。这里我讲一个神奇的发现：几乎所有背包模型，都可以用二进制的方式优化，使常数变为1/32。那么，具体怎么搞呢？我们开一个bitset b，让每一位对应一个人数。我们把联通块看成一个整体，每读到一个联通块的大小Si，我们就让b左移Si位并位与它自己。这样我们就得到了所有可以拼成的人数集合。

------------

最后一步就是扫一遍，找差的绝对值最小的那个输出。

------------

附AC代码ORZ
```cpp
#include<bits/stdc++.h>
#define N 20005
#define M 200005
using namespace std;
int n,m,k,x,y,tot,ver[M],nxt[M],head[N],c[N],cnt,V[N],ans,minn=INT_MAX;
void add(int x,int y){
    ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;
}
void dfs(int v,int col){
    if(c[v])return;
    c[v]=col;
    for(int i=head[v];i;i=nxt[i]){
        int y=ver[i];
        dfs(y,col);
    }
}
bitset<20005>b;
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m>>k;
    while(k--){
        cin>>x>>y;
        add(x,y);
        add(y,x);
    }
    for(int i=1;i<=n;++i){
        if(c[i])continue;
        dfs(i,++cnt);
    }
    for(int i=1;i<=n;++i){
        V[c[i]]++;
    }
    b[0]=1;
    for(int i=1;i<=cnt;++i){
        b|=b<<V[i];
    }
    for(int i=0;i<=n;++i){
        if(b[i]&&abs(i-m)<minn){
            ans=i;
            minn=abs(i-m);
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：我没有小白 (赞：1)

# 选学霸（并查集+背包）

> 刚考完初赛就来水一发题解$qwq$，找了一道~~水爆的~~题

没那么难，就是把实力相等的人放到一个并查集里，然后跑一边容量为$2\times m$的背包，记住要把每个并查集的容量记录下来，具体可以用size数组，然后跑一边01背包就可以了

具体都放到代码里了，不会的可以DD我

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cstdio>
using namespace std;
const int N = 40000;
int n,m,k;
void read(int &x) {
	int f=1;
	x=0;
	char s=getchar();
	while(s<'0'||s>'9') {
		if(s=='-') f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9') {
		x=x*10+s-'0';
		s=getchar();
	}
	x*=f;
}
int fa[N],size[N],col[N],tot,minn,dp[N+10];
int find(int x) {
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);
}
void uin(int x,int y) {
	int k=find(x),j=find(y);
	if(k!=j) {
		fa[k]=j;
		size[j]+=size[k];
	}
}//并查集+路径压缩 
int main() {
	read(n),read(m),read(k);
	for(int i=1; i<=n; i++)fa[i]=i,size[i]=1;
	for(int i=1; i<=k; i++) {
		int a,b;
		read(a),read(b);
		uin(a,b);//次为合并到一个并查集里的操作 
	}
	memset(dp,0x3f,sizeof(dp));
	for(int i=1; i<=n; i++)
		if(fa[i]==i) col[++tot]=size[i];//寻找并查集大小，tot为并查集个数 
	dp[0]=0;
	for(int i=1; i<=tot; i++) {
		for(int j=m+m; j>=col[i]; j--) {
			dp[j]=min(dp[j],dp[j-col[i]]+col[i]);
		}
	}//01背包部分 
	int l=m,r=m;
	int ans=0x7fffffff;
	while(l>=1&&r<=2*m) {
		if(dp[l]!=1061109567) {
			ans=dp[l];
			printf("%d",ans);
			return 0;
		}
		if(dp[r]!=1061109567) {
			ans=dp[r];
			printf("%d",ans);
			return 0;
		}
		l--,r++;
	}//这一段是按题目要求找最少的学霸 
	puts("0");//这一句话是为了不选学霸而用的 
}
```
管理大大求过

---

## 作者：SofanHe (赞：1)

# 我这里提出一种优化可行性DP的方案,基本思路跟楼下的dalao差不多.

## 问题分析:

由于有些人水平相同,所以如果加入了一个这个水平的人,则一定选与他水平相同的,所以,并查集.

之后就是能不能取到 ** i ** 个人,即可行性DP.

## 基本思路:

输入,相同水平的就加到并查集里面,正常的并查集.

然后,统计选一个父节点需要同时选多少个人.

排序,从小到大,为之后的DP做准备(这边不排可能会慢)[1];

可行性DP,看看能达到什么状态[2].

## 小优化,小细节:

[1] : 排序的时候会出现一堆 0 ,这时候我们就得把这些 0 过滤出去.具体代码如下:

```cpp
sort(px+1,px+n+1);//px记录的是每一个节点如果选,则必须选的其他人的总人数(哎....我这语文,凑活着看吧)
for(po=1;px[po]==0;po++);
```
这样处理完了, po 指向的位置就是第一个不是 0 的数.

[2] 状态这个方程还是比较基本的,状态转换的代码如下:

```cpp
for(;po<=n;po++)
    for(int i=2*m;i>=px[po];i--)
        if(ans[i-px[po]])ans[i]=1;
```
当然,如果 ans 数组初始值均为 0 的话最后是不会有解的,所以

```cpp
ans[0]=1;//取0个人当然是可以达到的.
```
但是这样的话,最后还要扫一下,所以,我们在这里直接记录

```cpp
if(ans[i]==1){if( jdz(m-i) < jdz(m-rans))rans=i;}//rans 为 realanswer 的缩写, jdz(x) 是一个返回 x 的绝对值的函数.
```
** 下面就是我的独家优化了 **

首先,我们考虑:假如我现在的最优绝对值已经是 0 了.那么就不用再搜索了.

现在考虑推广这个概念 : 如果我现在的最优秀的绝对值为 nextem ,那么如果产生更优秀的解的话,一定在 ( m-nextem,m+nextem) 这个区间里面.所以,对可行性 DP 做如下优化:

- 把搜索区间定为 (m-nextem,m+nextem)

- 随时更新 nextem.

具体代码如下:

```cpp
for(;po<=n;po++)
    for(int i=m+nextem-1;i>=px[po] && i>m-nextem;i--){//搜索区间的优化
        if(ans[i-px[po]])ans[i]=1;
        if(ans[i]==1){
                    nextem=m-i;//更新 nextem.
                    if( jdz(m-i) < jdz(m-rans))rans=i;
                }
    }
```
## 全代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,fa[20010],x,y,px[20010],ans[40010],nextem,rans=0x7fffffff;//注意ans开两倍大,当然开一倍也可以.但是我的程序里面初始nextem=m,所以要开两倍.
bool have[20010];int po=1;
int Find(int x){int ef=x,temp;
    while(fa[ef]!=0)ef=fa[ef];
    while(x!=ef){temp=fa[x];fa[x]=ef;x=temp;}
}
void Union(int x,int y){x=Find(x),y=Find(y);if(x==y)return;fa[x]=y;}
int jdz(int x){    return (x < 0 ? -x : x);}
int main(){
    cin>>n>>m>>k;nextem=m;
    for(int i=1;i<=k;i++){scanf("%d%d",&x,&y);Union(x,y);}
    for(int i=1;i<=n;i++){int fan=Find(i);have[fan]=1;px[fan]++;}
    sort(px+1,px+n+1);ans[0]=1;
    for(po=1;px[po]==0;po++);
    for(;po<=n;po++)
        for(int i=m+nextem-1;i>=px[po] && i>m-nextem;i--){
            if(ans[i-px[po]])ans[i]=1;
            if(ans[i]==1){nextem=m-i;if( jdz(m-i) < jdz(m-rans))rans=i;}
        }
    cout<<(rans==0x7fffffff?0:rans);
    return 0;
}
```
## 可行性优化

- 把 ans 优化到一倍,这样,对 m+nextem 进行特判

- 统计ans时,可以考虑不使用全部扫一遍的方法.或许这个可以用双队列实现?


# 我的题解就到这里,有什么不懂得欢迎私信提问或其他方式提问


---

## 作者：czx20030930 (赞：1)

并查集＋可达性DP

先用并查集找出哪几组学生需要一起选，把每一组学生当作一件物品，价值为组里的人数

直接上代码

```cpp
#include <stdio.h>
#include <iostream>
#include <cmath>
using namespace std;
int father[30001],num[30001];//num[i]记录i节点的子孙后代（包括自己）有多少人
bool flag[30001] = {};//flag[i]用于记录能否选出i人
int findfather(int a) {//找到根节点
    if (father[a] == a) return a;
    return father[a] = findfather(father[a]);//路径压缩
}
int main() {
    int n, m, k, a, b, i, j, s1, s2;
    cin >> n >> m >> k;
    flag[0] = true;
    for (i = 1; i <= n; i++) {
        father[i] = i;
        num[i] = 1;//初始化，每个人的宗族最开始只有一个人
    }
    while (k--) {
        cin >> a >> b;
        if (findfather(a) != findfather(b)) {//若a和b还不在同一宗族里
            num[findfather(a)] += num[findfather(b)];//将b的宗族并入a的宗族
            father[findfather(b)] = findfather(a);//修改父节点
        }
    }
    for (i = 1; i <= n; i++)
        if (findfather(i) == i)//只有当一名学生的祖宗就是他自己时，他的num值才恰好是自己整个宗族里的人数
            for (j = n - num[i]; j >= 0; j--)//标准可达性DP
                if (flag[j])
                    flag[j + num[i]] = true;
    for (i = m; !flag[i]; i++);
    s1 = i - m;//找到比m大的最接近的人数
    for (i = m; !flag[i]; i--);
    s2 = m - i;//找到比m小的最接近的人数
    if (s1 >= s2) cout << m - s2 << endl;
    else cout << m + s1 << endl;//输出
    return 0;
}

```

---

## 作者：jun君 (赞：1)

首先，题意：把N个人中某些人绑定，即一团团地选，让选的人尽可能接近M人！求选的人数！

所以我们可以通过并查集，求出每团人的个数。

这时我们可以用两倍背包（即范围为两倍的背包）求能到达的人数

最后，一个枚举求答案

附上代码：
```cpp
#include<iostream>
using namespace std;
int n,m,k,f[20010],fa[20010],F[50010],num[20010],x,y,f1,f2;
int Find(int x)
{
	if (fa[x]==x)return x;
	else return fa[x]=Find(fa[x]);
}
int main()
{
	cin>>n>>m>>k;
	for (int i=1;i<=n;i++)fa[i]=i,num[i]=1;
	for (int i=1;i<=k;i++)
	{
		cin>>x>>y;
		f1=Find(x);
		f2=Find(y);
		if (f1!=f2){
			num[f2]+=num[f1];
			num[f1]=0;
			fa[f1]=fa[f2];
		}
	}
	F[0]=1;
	for (int i=1;i<=n;i++)
	{
		if (fa[i]==i){
			//cout<<i<<"!!!"<<num[i]<<endl;
			for (int j=2*m;j>=num[i];j--){
				if (F[j]==0&&F[j-num[i]]){
					F[j]=1;
				}
			}
		}
	}
	for (int i=0;i<=m;i++){
		if (F[m-i]){
			cout<<m-i<<endl;break;
		}
		
		if (F[m+i]){
			cout<<m+i<<endl;break;
		}
	}
	return 0;
}
```


---

## 作者：xiaohuang (赞：0)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/07/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8F%E6%B4%9B%E8%B0%B7P2170%20%E9%80%89%E5%AD%A6%E9%9C%B8)

### Solution

这题如果选了一个人，那么与他实力相当的人也要选上。所以我们可以把会产生连锁反应的人都捆起来。不难想到用并查集。

然后我们把一捆一捆的总价值记录下来，做一遍`01`背包就好了。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

const int INF = 0x3f3f3f3f, MAXN = 20005;
int n, m, k, u, v, t[MAXN], w[MAXN], dp[MAXN], father[MAXN];
inline int find(int x) {//并查集
    return (x == father[x] ? x : father[x] = find(father[x]));
}
inline void Union(int u, int v) {//合并
    int p = find(u), q = find(v);
    if (p != q) father[p] = q;
}
int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++)
        father[i] = i;
    for (int i = 1; i <= k; i++) {
        scanf("%d%d", &u, &v);
        Union(u, v);//将输入的两个人合并起来
    }
    for (int i = 1; i <= n; i++)
        t[find(i)]++;
    int cnt = 0;
    for (int i = 1; i <= n; i++)
        if (t[i]) w[++cnt] = t[i];//计算价值
    for (int i = 1; i <= cnt; i++)
        for (int j = m << 1; j >= w[i]; j--)
            dp[j] = max(dp[j], dp[j - w[i]] + w[i]);//01背包
    int Min = INF, ans = 0;
    for (int i = 0; i <= m; i++) {
        if (dp[m - i] == m - i) {
            printf("%d\n", m - i);
            return 0;
        }
        if (dp[m + i] == m + i) {
            printf("%d\n", m + i);
            return 0;
        }
    }
    return 0;
}
```

---


# [BJOI2019] 排兵布阵

## 题目描述

小 C 正在玩一款排兵布阵的游戏。在游戏中有 $n$ 座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 $m$ 名士兵，可以向第 $i$ 座城堡派遣 $a_i$ 名士兵去争夺这个城堡，使得总士兵数不超过 $m$。   

如果一名玩家向第 $i$ 座城堡派遣的士兵数**严格**大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得 $i$ 分。  

现在小 C 即将和其他 $s$ 名玩家两两对战，这 $s$ 场对决的派遣士兵方案必须相同。小 C 通过某些途径得知了其他 $s$ 名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。   

由于答案可能不唯一，你只需要输出小 C 总分的最大值。

## 说明/提示

**样例1解释：**  
小 C 的最佳策略为向第 $1$ 座城堡和第 $2$ 座城堡各派遣 $5$ 名士兵。 

**样例2解释：**  
小 C 的最佳策略之一为向第 $1$ 座城堡派遣 $2$ 名士兵，向第 $2$ 座城堡派遣 $5$ 名士兵，向第 $3$ 座城堡派遣 $1$ 名士兵。  

**数据范围：**   
对于 $10\%$ 的数据： $s=1,n \le 3,m \le 10$   
对于 $20\%$ 的数据： $s=1,n \le 10,m \le 100$   
对于 $40\%$ 的数据： $n\le 10,m\le 100$     
对于另外 $20\%$ 的数据： $s=1$     
对于 $100\%$ 的数据：  
$1\le s \le 100$  
$1\le n \le 100$  
$1\le m \le 20000$   
对于每名玩家 $a_i \ge 0$，$\sum\limits_{i=1}^n a_i \le m$   


## 样例 #1

### 输入

```
1 3 10
2 2 6```

### 输出

```
3```

## 样例 #2

### 输入

```
2 3 10
2 2 6
0 0 0```

### 输出

```
8```

# 题解

## 作者：Santiego (赞：94)

[$\text{My Blog}$](https://www.cnblogs.com/santiego/p/11184624.html)

比较好想的DP，设$dp[i][j]$表示第$i$个城堡时，已派出$j$个士兵。决策时，贪心派出恰好严格大于某一玩家派出的数量的两倍（不然浪费）。我们发现又可以排序预处理出$a[i][j]$表示第$i$个城堡，出兵数量第$j$大的人出兵数量（因为这样可以很容易算出贡献，即为$k\times i$）

dp转移方程即为：
$dp[j]=MAX(dp[j-a[i][k]*2-1]+k*i, dp[j]);$


*AC Code:*

```cpp
#include <cstdio>
#include <algorithm>
#define MAX(A,B) ((A)>(B)?(A):(B))
using namespace std;
int s,n,m,dp[20002],a[110][110],ans;
signed main(){
    scanf("%d %d %d", &s, &n, &m);
    for(int i=1;i<=s;++i)
        for(int j=1;j<=n;++j)
            scanf("%d", &a[j][i]);
    for(int i=1;i<=n;++i)
        sort(a[i]+1, a[i]+1+s);
    for(int i=1;i<=n;++i)
        for(int j=m;j>=0;--j) //倒序枚举已派出兵
            for(int k=1;k<=s;++k) //对s个玩家决策
                if(j>a[i][k]*2)
                    dp[j]=MAX(dp[j-a[i][k]*2-1]+k*i, dp[j]);
    for(int i=0;i<=m;++i) ans=MAX(ans, dp[i]);
    printf("%d\n", ans);
    return 0;
}
/*
 dp[i][j]第i个城堡时，已派出j个士兵
 a[i][j]第i个城堡，第j个人出的兵
 */
```

---

## 作者：34ytw8ew7ft (赞：82)

我终于也能做帝都省选的题了！（大雾）

这个题出的真的是非常不错呢，有很多小细节还是要注意的。

## 简明题意

每个人有$m$个士兵，可以把它们随意分配到$i$个城堡里，游戏采用逐个1V1 battle的模式，如果在一次battle中第$i$城堡里你的士兵个数$>$对方士兵个数$*2$，你就获得了$i$分。每次battle的策略必须一致，已知其余玩家的派兵情况，求总得分最大值。

## 解法

乍一看貌似没有思路的亚子，于是我们来模拟一下样例。

首先根据读题明确这样两个事实：  

- 对于玩家$a$而言，攻占第$i$个城堡，需要**至少**派出$2*a_i+1$的兵力

输入#1:  
![1](https://i.loli.net/2019/08/23/HJO3mVY4owWtPI6.png)  
在这种情况下绝对要给城堡1、2各分5个兵力，得3分。  
是不是有点眉目了？我们来看下一个。

输入#2：  
![2](https://i.loli.net/2019/08/22/YB7wfCaQuAncroT.png)  
你可以看到，对于玩家1的所得分数有点不一样，因为在攻占下玩家1后，按照相同的策略，玩家2也自然会被攻占，所以这个地方的所得分数就变成了两倍。  
我们就可以得到一个（显而易见的）事实：

- 如果攻占下一个玩家的城堡，那么出兵更弱的玩家自然也会被攻占

这个事实就非常天后了，他可以让我们忽视所打的轮数，对于每个城堡，我们只要找出攻占的一个玩家，即可得知该城堡的全部所获分数。

根据这个性质，我们可以先对每个城堡的玩家兵力排序，于是就可以简化成：有$i$个城堡，每个城堡有$s$个玩家，攻占一个玩家需要派出$2*i_s+1$的兵力，获得$i*s$的分数。求在有$m$个兵力的情况下，对于**每个城堡**要攻占**哪一个**玩家使得总分最大。

看到这个，有没有想到什么东西？分组背包啊！我们可以把每一个城堡看成一个组，每个玩家是一个组内的物品。物品的价值即为所获分数$i*s$，体积为攻打所需兵力$2*i_s+1$，而背包体积就是兵力$m$。

我们就可以轻松愉悦的写代码了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int s,n,m;
int C[110][110],W[110][110];
int F[20010];

//分组背包板子,V为容量，K为组数，GMC为每组元素个数
void group_package(int V,int K,int GMC)
{
    for(int k=1;k<=K;k++)
        for(int v=V;v>0;v--)
            for(int i=1;i<=GMC;i++//循环三连
                if(v-C[k][i]>=0&&F[v-C[k][i]]+k*i>F[v])
                    F[v]=F[v-C[k][i]]+k*i;
}
int main()
{
    //读入
    cin>>s>>n>>m;
    for(int i=1;i<=s;i++)
        for(int j=1;j<=n;j++)
            cin>>C[j][i];
    //数据预处理
    for(int i=1;i<=n;++i)
    {
        sort(C[i]+1,C[i]+1+s);//先排序
        for(int j=1;j<=s;j++)//排序完把玩家兵力改为攻打兵力
            C[i][j]=C[i][j]*2+1;   
    }
    group_package(m,n,s);
    cout<<F[m]<<endl;
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：36)

这是一道小清新的dp题呢qwq  
同时也是BJOI2019最良心的一题

对于每个城堡，可以看做是一个物品。  
然后可以处理出在每个城堡打败$1$~$n$个玩家分别要用的兵力，和得分   
注意得分是要加起来，而需要的兵力是取$\max$的

然后这就是一个赤裸裸的背包啦~  
时间复杂度$\Theta(nms)$  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 105
#define M 20003
#define reg register
using namespace std;

int a[N][N];
int s,n,m;

namespace qwq{
    struct node{
        int v,w;
        node(int v=0,int w=0):v(v),w(w){}
        bool operator < (const node& nd) const{
            return w < nd.w;
        }
    };
    
    int w[N][N],v[N][N],f[M]; //有n个物品，每个物品有m种选择
    node d[N];
    
    int solve(){
        memset(f,0,sizeof(f));
        int wt,val;
        for(reg int j=1;j<=n;++j){
            for(reg int i=1;i<=s;++i)
                d[i] = node(j,(a[i][j]<<1)|1);
            sort(d+1,d+1+s); //为了方便统计,这里要排个序
            wt = val = 0;
            reg int last,k = 1;
            for(reg int i=1;i<=s;){
                last = k;
                wt = max(wt,d[i].w);
                while(d[k].w==d[i].w){
                    val += d[k].v;
                    ++k;
                }
                for(reg int l=last;l<k;++l){
                    w[l][j] = wt;
                    v[l][j] = val;
                }
                i = k;
            }
        }
        for(reg int k=1;k<=n;++k){ //枚举物品
            for(reg int i=m;i>=1;--i){ //枚举背包容量
                for(reg int j=1;j<=s;++j){ //枚举某个物品的选择
                    if(i<w[j][k]) continue;
                    f[i] = max(f[i],f[i-w[j][k]]+v[j][k]);
                }
            }
        }
        return f[m];
    }
};

inline void read(int &x);
void print(int x);

signed main(){
    int ans;
    read(s),read(n),read(m);
    for(reg int i=1;i<=s;++i)
        for(reg int j=1;j<=n;++j)
            read(a[i][j]);
    ans = qwq::solve();
    print(ans);
    return 0;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }	
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

---

## 作者：nofind (赞：16)

题意:https://www.luogu.org/problem/P5322

初次拿到没有思路,看了眼题解马上明白了

将城堡看成为物品,派出的兵力为代价,获胜的场数*第几个城堡为价值,这就是背包的模型

f[j]表示已经派出j的兵力的最大价值

枚举城堡i,将每个人派出的兵力排序后,记第k个人派出的兵力为a[i][k],由于已经排好序,能打败第k个敌人就能打败第k-1个,因此枚举敌人k,贪心地派出刚好比他的兵力两倍多1的兵力转移

$f[j]=max(f[j],f[j-(2*a[i][k]+1)]+i*k)$

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxs=110;
const int maxn=110;
const int maxm=20010;
int S,n,m,ans;
int a[maxs][maxn],f[maxm];
int main()
{
	scanf("%d%d%d",&S,&n,&m);
	for(int i=1;i<=S;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[j][i]);
	for(int i=1;i<=n;i++)sort(a[i]+1,a[i]+S+1);
	for(int i=1;i<=n;i++)
		for(int j=m;j>=0;j--)
			for(int k=1;k<=S;k++)
				if(j>=2*a[i][k]+1)f[j]=max(f[j],f[j-(2*a[i][k]+1)]+i*k);
	printf("%d",f[m]);
	return 0;
}
```


---

## 作者：李若谷 (赞：14)

## 分组背包

这道题就是一道分组背包的简单变形


------------
#### 首先什么是分组背包？

分组背包就是有n组物品，每组物品中只可以选择一个物品。

每个物品都有体积和价值，求总体积不超过m的情况下的价值最大值。

很显然状态转移方程就是：$f[j] = max(f[j-v[i][k]]+w[i][k])$

分组背包核心代码：
```cpp
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=0;j--)
		{
			for(int k = 1;k<=s[i];k++)
			{
				if(j>=v[i][k])
					f[j] = max(f[j],f[j-v[i][k]]+w[i][k]);
			}
		}
	}

```


------------
#### 这道题怎么转化成分组背包呢？

我们可以把每个城堡看做一组物品。每个人的兵看成体积，把城堡编号看成价值。

但是难点分组背包是每一个组只能选一个，这里是可以打多个对手。

其实可以发现，假设第i个对手派出的兵<第i+1个对手派出的兵，那么如果我们派出的兵可以打赢i+1个对手派出的兵，那么也肯定能打赢第i个对手。

所以，我们可以把每个城堡分别的对手派出的兵数进行排序。状态转移的时候，把分组背包的枚举哪一个物品改成从小到打枚举哪几个物品，这样就可以转化为分组背包。



------------
这题还是有一点细节的。排序的时候由于输入的城堡兵书是从上到下竖着的。我们很难直接排序。所以可以把输入的数组翻转 90° 然后用stl:sort横着排序就行了

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 110,M=20010;
int f[M];
int a[N][N];
int main()
{
	int s,n,m;
	scanf("%d%d%d",&s,&n,&m);
	for(int j=1;j<=s;j++) //输入翻转数组
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i][j]);

	for(int i=1;i<=n;i++) //排序
	{
		sort(a[i]+1,a[i]+1+s);
	}
	for(int i=1;i<=n;i++) //分组背包实现
	{
		for(int j=m;j>=0;j--)
		{
			for(int k=1;k<=s;k++)
			{
				if(j>=2*a[i][k]+1)
					f[j] = max(f[j],f[j-2*a[i][k]-1]  + k*i);
			}
		}
	}
	cout<<f[m]<<endl;
	return 0;
}
```

---

## 作者：nekko (赞：8)

一开始想了个复杂度爆炸的dp……

$f_{i,j}$ 表示前 $i$ 类城堡，获得了 $j$ 个城堡的最小花费

状态数是 $O(n^4)$ 的，转移是 $O(n)$ 的（在这里认为 $n$ 和 $s$ 同阶）

总时间复杂度是 $O(n^5)$ 的，神奇的有 $70pts$……

考虑到 $m$ 只有 $20000$，不妨直接把 $m$ 压进去……

设 $f_{i,j}$ 表示前 $i$ 类城堡，花了 $j$ 个兵，此时获得的最大收益

考虑第 $i$ 类城堡的时候，把所有玩家按照 $a$ 从小到大排序

然后枚举打败了几个玩家，假设打败的玩家中最大的 $a$ 是 $k$，显然只需要 $2k+1$ 个兵就够了

然后跑个背包就行了

时间复杂度是 $O(snm)$ 的，然后由于跑不满于是就过了……

---

## 作者：fscbti (赞：7)

这道题相对于常规省选题来说是个$DP$水题。大体思路很好想，就是枚举，$DP$，当然，需要优化。

首先，$40pts$应该很好码。预处理排$x$个兵，能占领多少城堡，然后枚举城堡($n$)，枚举现在使用多少兵，和前面共使用多少兵，时间复杂度：$O(nm^2)$。代码如下
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map> 
#include<bitset>
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
}
int f[20005],n,m,s,a[105][105],ss,c[105][20005];
signed main(){
	s=read();n=read();m=read();
	for(re i=1;i<=s;i++){
		for(re j=1;j<=n;j++){
			a[i][j]=read();c[j][a[i][j]]++;
		}
	}
	for(re i=1;i<=n;i++){
		for(re j=1;j<=m;j++){
			c[i][j]+=c[i][j-1];//预处理用j个兵，可以占领多少个城堡i
		}
	}
	for(re i=1;i<=n;i++){
		for(re l=m;l>=0;l--){
			for(re j=1;j<=l;j++){
				f[l]=max(f[l],f[l-j]+c[i][(j-1)/2]*i);
                //纯真的背包思想
			}
			ss=max(ss,f[l]);//求最大值
		}
	}
	cout<<ss<<endl;
	return 0;
}
```
至于优化则非常简单，用背包的单调性来思考。倘若一个物品花费比另一个物品高，而价值却一样，那么这个物品就没有意义了。

但要注意，这种优化思路仅可用于部分题目，原因很简单，这道题并非正真的背包，只是把一种安排兵的方法定义为一个背包。是会在其中选最优的。也就是选了其中并列的一个就不能选其它的了。而背包则是皆可以选。而且此题对于耗费值并无要求。价值也不为负。

那么，只要在预处理时，剪去不必要方案。为了方便，直接把剩下的方案记录即可。

这样，时间复杂度为$O(nms)$。代码如下。
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map> 
#include<bitset>
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
}
int f[20005],n,m,s,a[105][105],ss,c[105][20005],t[105],d[105][105][2];
signed main(){
	s=read();n=read();m=read();
	for(re i=1;i<=s;i++){
		for(re j=1;j<=n;j++){
			a[i][j]=read();
			if(a[i][j]*2+1<=m)c[j][a[i][j]*2+1]++;
		}
	}
	for(re i=1;i<=n;i++){
		for(re j=0;j<=m;j++){
			if(c[i][j])d[i][++t[i]][0]=(c[i][j]+c[i][j-1])*i,d[i][t[i]][1]=j;
			if(j)c[i][j]+=c[i][j-1];
		}
	}
	for(re i=1;i<=n;i++){
		for(re l=m;l>=d[i][1][1];l--){
			for(re j=1;j<=t[i]&&d[i][j][1]<=l;j++){
				f[l]=max(f[l],f[l-d[i][j][1]]+d[i][j][0]);
			}
			ss=max(ss,f[l]);
		}
	}
	cout<<ss<<endl;
	return 0;
}
```
所以此题正解的正确性需要有一个严格的思考。

（同时，这是我此号第300个AC的题，第60个蓝题）

---

## 作者：1010000_1001010 (赞：5)

开始看到这道题的时候没什么头绪，后来仔细想想，发现对数据预处理之后就是一个经典的分组背包问题。  
## 	大概思路如下：  
   - 将一个城堡看作一组   
   - 先对每组城堡中的各个玩家的敌人数进行排序   
   - **每个玩家派兵的数量*2+1** 可以看作为物品重量（注意玩家派兵数量可能相同）   
   - 那么 **排序后该玩家敌人数的索引与城堡索引的乘积** 就是物品价值 且每个组内的物品只能选择一次    

### 于是我们就把这个问题转化为了分组背包问题
状态转移方程如下（i代表第几组，j代表该组第几个)
```cpp
f[v]=max(f[v],f[v-weight[i][j]]+value[i][j])
```
剩下的就用套用模板就行了    
 _样例代码_ :
 

------------

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

int main()
{

    int s, n, m; //分别表示除了小C以外的玩家人数、城堡数和每名玩家拥有的士兵数（背包容量）。
    cin >> s >> n >> m;

    int value[n][s], weight[n][s]; //物品个数为n*s
    int f[m + 1];
    memset(f, 0, sizeof(f)); //赋初值
    memset(value, 0, sizeof(value));
    memset(weight, 0, sizeof(weight));

    int data[n][s];
    for (int i = 0; i < s; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> data[j][i];
        }
    }

    for (int i = 0; i < n; i++)
    {                               //第几座城
        sort(data[i], data[i] + s); //拍一个序
        for (int j = 0; j < s; j++)
        {
            if (j == s - 1 || data[i][j] != data[i][j + 1])
            { //防止出现重叠现象
                value[i][j] = (j + 1) * (i + 1);
                weight[i][j] = data[i][j] * 2 + 1;
            }
        }
    }
    //就是一个分组背包问题

    for (int i = 0; i < n; i++)
    {
        for (int v = m; v >= 0; v--)
        {
            for (int j = 0; j < s; j++)
            {
                if (v >= weight[i][j] && weight[i][j] != 0)
                {
                    f[v] = max(f[v], f[v - weight[i][j]] + value[i][j]);
                }
            }
        }
    }
    cout << f[m] << endl;
    system("pause");
    return 0;
}
```


---

## 作者：Fading (赞：3)

有**点**思维含量的背包

其实我觉得这思维含量和$\ NOIP\ D1T2\ $没什么区别，还没有$CF$的少量简单$dp$题难

%%%czxisking，看他切了此题我才去做的（雾

讲讲我的心路历程吧。

怎么数据范围这么小。。。

然后第一反应是贪心，结果发现有很多个对手，然后懵逼了。

仔细一看好像两个对手之间互不干扰，可以对每一个位置$i$,所有对手布下的兵数从小到大排个序

然后总兵量固定是$m$，就想到了背包。

把每一个位置看成一个物品，如果给第$i$个位置布下$x$个兵，就会有

$$i\times \sum_{j=1}^s(2\times a[i][j]<x)$$

个贡献

所以我们可以预处理$m$个物品？

其实大大不必，只要预处理每一个$a[i][j]$交界处的即可。

每一个位置构造$s$个物品

对于排完序后的第$j$个物品,花费为$2\times a[i][j]+1$，价值为$j\times i$

```w[i][j]=2*a[i][j]+1;v[i][j]=j*i;```

然后就是一个分组背包了。以每一个位置为组跑背包就可以了。

~~我不会和你们说我分组背包忘了怎么写是自己现场yy的~~

然后复杂度$O(nms)$居然艹的过去？？？我也不知道为什么。。。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
    ll x=0;char ch=getchar();int f=1;
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
ll n,s,m,v[301][301],w[301][301],f[20003],a[301][301];
int main(){
    s=read(),n=read(),m=read();
    for (int i=1;i<=s;i++){
        for (int j=1;j<=n;j++) a[j][i]=read();
    }
    for (int i=1;i<=n;i++){
        sort(a[i]+1,a[i]+1+s);
        for (int j=1;j<=s;j++){
            w[i][j]=2*a[i][j]+1;v[i][j]=j*i;
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=m;j>=1;j--){
            for (int k=1;k<=s;k++){
                if (j<w[i][k]) continue;
                f[j]=max(f[j],f[j-w[i][k]]+v[i][k]);
            }
        }
    }
    cout<<f[m];
}
```

---

## 作者：fdszlzl (赞：3)

[P5322 [BJOI2019] 排兵布阵](https://www.luogu.org/problemnew/show/P5322)

对于每个城堡，求出部署h兵力能得到的价值g，问题就是分组背包了。

对每个城堡按不同对手的部署兵力由大到小排序。

对于城堡i,如果玩家兵力是j对手的2倍+1，因已经排序，对后续的玩家，2倍+1的兵力也必然能拿到分，所以在i城堡玩家部署2\*对手j兵力+1获得的价值为(s-j+1)\*i，视为i分组的第k件物品，遍历对手，即可拿到i分组的所有物品。

接着就是分组背包了。


```cpp
#include <bits/stdc++.h>
using namespace std;

int a[105][105],b[105][105],f[105][20005],g[105][20005],h[105][20005];

int cmp(int a,int b) {
	return a>b;
}

int main() {
	int s,n,m;
	cin>>s>>n>>m;
	for(int i=1; i<=s; i++) {
		for(int j=1; j<=n; j++) {
			cin>>a[i][j];
			b[j][i]=a[i][j];
		}
	}
	for(int i=1; i<=n; i++) {
		sort(b[i]+1,b[i]+s+1,cmp);
		for(int j=1; j<=s; j++) {
			if(b[i][j]*2+1<=m) {
				g[i][0]++;
				g[i][g[i][0]]=(s-j+1)*i;
				h[i][g[i][0]]=b[i][j]*2+1;
			}
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(g[i][0]==0) f[i][j]=max(f[i][j],f[i-1][j]);
			for(int k=1; k<=g[i][0]; k++) {
				if(h[i][k]>j) f[i][j]=max(f[i][j],f[i-1][j]);
				else {
					f[i][j]=max(f[i][j],max(f[i-1][j],f[i-1][j-h[i][k]]+g[i][k]));
				}
			}
		}
	}
	cout<<f[n][m]<<endl;
	return  0;
}
```


---


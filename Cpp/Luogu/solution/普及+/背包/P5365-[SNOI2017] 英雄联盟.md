# [SNOI2017] 英雄联盟

## 题目描述

正在上大学的小皮球热爱英雄联盟这款游戏，而且打的很菜，被网友们戏称为「小学生」。

现在，小皮球终于受不了网友们的嘲讽，决定变强了，他变强的方法就是：买皮肤！

小皮球只会玩  $\text{N}$ 个英雄，因此，他也只准备给这 $\text{N}$ 个英雄买皮肤，并且决定，以后只玩有皮肤的英雄。

这 $\text{N}$ 个英雄中，第 $\text{i}$ 个英雄有 $K_i$ 款皮肤，价格是每款 $C_i$ Q 币（同一个英雄的皮肤价格相同）。

为了让自己看起来高大上一些，小皮球决定给同学们展示一下自己的皮肤，展示的思路是这样的：对于有皮肤的每一个英雄，随便选一个皮肤给同学看。

比如，小皮球共有 5 个英雄，这 5 个英雄分别有 $\text{0,0,3,2,4}$ 款皮肤，那么，小皮球就有 $3 \times 2 \times 4 = 24$ 种展示的策略。

现在，小皮球希望自己的展示策略能够至少达到  $\text{M}$ 种，请问，小皮球至少要花多少钱呢？

## 说明/提示

**样例解释**

每一个英雄都只有4款皮肤，每款皮肤2 Q币，那么每个英雄买3款皮肤，$3 \times 3 \times 3 \ge 24$，共花费 $6 \times 3$ Q币。

**数据范围**

共 10 组数据，第 $\text{i}$ 组数据满足：$\text{N} \le \max(5, \log_2^4i)$

$\text{100}\%$ 的数据：$\text{M} \le 10^{17}, 1 \le K_i \le 10, 1 \le C_i \le 199$。保证有解。

## 样例 #1

### 输入

```
3 24
4 4 4
2 2 2```

### 输出

```
18```

# 题解

## 作者：LemonChay (赞：98)

## 看着这道题目没有什么人写题解，那我就来一篇...

**题目右转：[题目](https://www.luogu.org/problem/P5365)**

**更好的阅读，请[戳我](https://www.luogu.org/blog/2PXJ/solution-p5365)**

首先我们仔细地看一下题目，题意是让我们在能让展示方案达到M种的情况下花费最少的钱，这就让我~~情不自禁~~地想到了背包问题，那么是什么背包呢？

在接着看，对于每一个皮肤，都有一个数量、一个购买的Q币数(花费)，那么这种有限物品数量的背包问题就是多重背包问题了。

**根据题目要求的量，我们来设计状态。我们看到，方案数量是价值，Q币数量是我们的花费，于是我们用dp[i][j]来表示前i个皮肤的j个花费的最大方案数**

**分析到这里，我们大致地可以把状态转移方程给求出来了：**

```
dp[i][j]=max(dp[i][j],dp[i−1][j−p∗c[i]]∗p)
```
其中p是当前英雄选的皮肤数量，c[i]是题目中的意思。

如果二维数组的内存太大，给人一种 **~~心慌慌~~** 的感觉，那么不妨再分析一下，如何用一维数组来表示状态。

**我们看到，方案数量是根据花费的变化而变化的；换句话说，M和i是没有什么太大的关系。那么我们这么来表示状态：dp[j]表示花费j个Q币的最大方案数量。借鉴二维的状态转移方程，我们 ~~很容易~~ 地得到一维地状态转移方程：**

```cpp
dp[j]=max(dp[j−p∗c[i]]∗p,dp[j])
```
到这里，我们分析的差不多了。核心部分已经解决了，那么细节就自己去抠吧。

## 来，上代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
long long int dp[1000001];//状态数组
long long int k[1000001],c[1000001];//数组意义如题目所述
long long int n,m,qb;
int main()
{
	int i,j,p;
	cin>>n>>m;
	for(i=1;i<=n;i++)//输入
	{
		cin>>k[i];
	}
	for(i=1;i<=n;i++)
	{
		cin>>c[i];
		qb+=c[i]*k[i];//将Q币总量记录下来
	}
	dp[0]=1;//初始化
	for(i=1;i<=n;i++)//枚举皮肤的种类
	{
		for(j=qb;j>=0;j--)//枚举每一“格”Q币数量
		{
			for(p=0;p<=k[i]&&p*c[i]<=j;p++)//枚举当前皮肤的数量
			{
				dp[j]=max(dp[j],dp[j-p*c[i]]*p);//
状态转移方程
			}	
		}
	}
	long long int ans=0;
	while(ans<=qb&&dp[ans]<m) ans++;//找到最小、同时大于M的那一“格”Q币数量
	cout<<ans;
	return 0;
}
```

**第一篇题解，希望管理员通过**

---

## 作者：翼德天尊 (赞：76)

**这是一道标准的背包问题——**

[题目传送门](https://www.luogu.com.cn/problem/P5365)

[更好的阅读体验？](https://www.luogu.com.cn/blog/5y2d1n/solution-p5365)

废话不多说，不会的童鞋们跟我来！$Go!$

------------
### 1.逐步分析

既然是背包问题，最重要的当然就是转移方程了，所以转移方程是什么呢？

题中，我们知道了英雄的数量，每一种英雄的数量以及价值，**没错，这就是所谓的多重背包。**

当然，这道题不同的地方是，我们要求的是最少花费的钱数，**所以我们不妨先在开始读入价钱的时候，将所有的价钱累加起来，算出最多需要花费的钱数，当作总钱数。**

```
//读入部分
cin>>n>>m;
for (int i=1;i<=n;i++) cin>>k[i];
for (int i=1;i<=n;i++) {
    cin>>c[i];
    qm+=c[i]*k[i];//累加	
}
```
而在转移方程中，我们可以用第一维表示取前 $i$ 件物品，第二维表示花费 $j$ Q币，即：

```
dp[i][j]=max(dp[i][j],dp[i][j-x*c[i]]*x);
```

**其中，$x$ 为取第 $i$ 种物品的个数**

而考虑到维度优化，~~根据传统的背包模板~~ 经过思考，我们可以将第一维“取前几件物品”省略，即：

```
dp[j]=max(dp[j],dp[j-x*c[i]]*x);
```

**对了**，花0个Q币的方案数默认为1，即：

```
dp[0]=1;
```

--------------

### 2.AC代码及注释

```
#include<bits/stdc++.h>//万能明星头
using namespace std;
const int N=1000001;
long long n,m,k[N],c[N],qm,dp[N]={1},ans; 
//如题
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);//亲测优化程度基本大于快读
    cin>>n>>m;
    for (int i=1;i<=n;i++) cin>>k[i];
    for (int i=1;i<=n;i++) {
    	cin>>c[i];
		qm+=c[i]*k[i];	
	}//输入部分
    for (int i=1;i<=n;i++){//枚举前i件物品
    	for (int j=qm;j>=0;j--){//倒序枚举花j个Q币
    		for (int x=0;x<=k[i]&&x*c[i]<=j;x++){//枚举买x个皮肤
    			dp[j]=max(dp[j],dp[j-x*c[i]]*x);//转移方程
			}
		}
	}
	while (ans<=qm&&dp[ans]<m) ans++;//满足条件就++
	cout<<ans<<endl;//输出
    return 0;//好习惯要保持
}
```

----------------

### 3.完结撒花！
本次题解就这么愉快地结束啦！感谢您坚持看到了最后！

如果还有什么不懂的问题，欢迎在评论区回复哦，我会第一时间解答哒！

当然，如果您看懂了，就点个赞纪念一下您的成长吧！

---

## 作者：SIXIANG32 (赞：12)

```cpp
cout<<"Good 2020"<<endl;
cout<<"Hello 2021"<<endl;
```
在这 2020 年最后一天发一篇珂爱的题解，欢送 2020，迎接 2021~  
啊，扯远了，好了，闲话少说，切入正题——  

---
显然这是一道 dp，很背包很像的 dp。  
~~然鹅其实窝并没有看出来它和多重背包有很多关系~~

如果你背包做多了，出于一个 OIer 的直觉和做 dp 的经验。肯定会设状态 $f_{p,i}$ 为前 $p$ 个物品花费 $i$ 个 Q 币的最大展览数。  

状态推出来了，我们思考一下状态转移方程。  
1. 我们啥也不干，也就是 $f_{p,i}$ 自己。
2. 我们买 $g$ 个 $p$ 号人物的皮肤，也就是上一个人去掉当前 $i$ 的花费再乘上 $g$，就是 $f_{p-1,i-g\times c_p}\times g$。

那么状态转移方程也就不难写出来啦~  
$f_{p,i}=\max(f_{p,i},f_{p-1,i-g\times c_p}\times g)$。

---
但是，在打代码开数组的那一刻，你会忽然想到——   
诶这个数组是不是太大了呀/fad/fad/fad  
所以，我们要对空间进行优化。  

回想我们是怎么把 01 背包的二维转化成一维的，因为最终的容量和物品没什么关系，所以可以把物品那一维滚掉。

那么这题同理，$M$ 和 $p$ 这一维是没有什么关系的，我们要把 $p$ 滚掉，当然，这里和 01 背包一样 $i$ 要逆序枚举。

那么我们就可以重新写 dp 惹~  

设 $f_i$ 为花费 $i$ 的 Q 币能获得的最大展示数。
状态转移方程基本上可以看成滚掉 $p$ 一维，即：   
$f_i=\max(f_i,f_{i-g\times c_p}\times g)$。  
其实和二维差别不大，就是去掉了一维，仅此而已。
但是尽管如此，它的空间真的小了不少呢/cy/cy/cy

---
最后我们要统计答案了，我们的 $f_i$ 统计的是展示数，又不是 Q 币，我们该如何统计答案呢？  
其实也不难。我们可以从小到大枚举答案 $ans$，什么条件下 $ans$ 要加大呢？无非是当前方案数小于 $M$，也就是 $f_{ans}<M$。  
当然，同时为了防止 $ans$ 过大比需要花费的总钱数还大，应该再加一条 $ans<sq$（$sq$ 是所有 Q 币都买满所需要花费的）。  

（SX 小声 bb：感觉别的题解 $ans\le sq$ 是不是不是太准确，因为 $ans=sq$ 的时候再累加一下就 $ans>sq$ 惹） 

代码如下：  
```cpp
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
int f[1001000],k[1001000],c[1001000],n,m,sq,ans=0;
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int p=1;p<=n;p++)
		cin>>k[p];
	for(int p=1;p<=n;p++)
		cin>>c[p],sq+=k[p]*c[p];
	f[0]=1;//不用花费的话可以不展示，这也是一种方式
	for(int p=1;p<=n;p++)//枚举任务
		for(int i=sq;i>=0;i--)//枚举要花的 Q 币
			for(int g=0;g<=k[p]&&g*c[p]<=i;g++)//枚举选了多少个皮肤
				f[i]=max(f[i],f[i-g*c[p]]*g);//方程
	while(ans<sq&&f[ans]<m)ans++;//统计答案
	cout<<ans<<endl;//输出撒花~
}
```

---
总的来说这题还是挺水的。  
马上 2021 了，祝大家一个个变成 IOIAKer~

---

## 作者：AzzyZhe (赞：11)

## 题解 [P5365 [SNOI2017]英雄联盟](https://www.luogu.com.cn/problemnew/show/P5365)

### 题目分析
----
显而易见，这是一道变形的背包问题

考虑到总组合数取值范围很大，深思熟虑后 ~~(其实蒟蒻这题搞了好久)~~ ，我们选择将花费$j$个Q币时的最大组合数设为状态$F[j]$，转而判断能达到$M$的最小$j$即为答案。

状态转移方程时描述的是每一步的最小的递推关系。我们可以知道当小皮球只有$F[j]$种展示方式时，花费了 $j$ 个Q币,加入一个新英雄 $i$ ，购买了$k$个皮肤之后则有 $F[j]* k$ 种展示方式，花费$j+c[i]* k$个Q币，据此可以得到状态转移方程。没有购买任何英雄皮肤时一共有1种展示方式，据此可以得到初始状态（或者根据状态转移方程也可以得出）。

得出状态转移方程：
$$F[j]=\text{max}(F[j-k*c[i]]*k)$$
其中：
$$\text{第}i\text{个英雄：}i=1...N $$
$$\text{花费}j\text{个Q币：}j\qquad\ \;$$
$$\quad\text{买}k\text{个皮肤：}k=1...k[i]$$

初状态：
$$F[0]=1$$

实现上，正常分组背包dp就行，循环时的最大体积可以置为全英雄全皮肤所需要的Q币数，最后从0网上判断一遍到合法的$i$就输出结束即可。

需要注意的数据范围：

$N_i\le \text{max}(5,log_2^4i)$

$log_2^{4}i$ 也就是 $(log_2i)^4$ 而 $\left \lceil log_2^410\right\rceil=122$

$M\le10^{17}$ 需要开long long

### 代码
----
```cpp
#include<iostream>
using namespace std;
#define MAXN 130 //开大点好哇
typedef unsigned long long uint64;
inline uint64 max(uint64 a,uint64 b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
uint64 F[245000];//F[j]:花费Q币j个最多组合数
//245000 > (pow(log2(10),4)*10*200)
int n[MAXN],c[MAXN];//n[i]为题目中所给k[i]英雄皮肤数，c[i]如题意英雄皮肤价格
int N,tot=0;//tot:如果全部购买需要的Q币总数
uint64 M;//理所当然地，它也要longlong
int mian()
{
    cin>>N>>M;//读入
	for(int i=0;i<N;i++)
		cin>>n[i];
	for(int i=0;i<N;i++)
		cin>>c[i],
		tot+=n[i]*c[i];
	F[0]=1;//初状态
	for(int i=0;i<N;i++)//循环第i个英雄（物品次序）
		for(int j=tot;j;j--)//循环花费j个Q币（背包体积）（一维所以从大到小）
			for(int k=1;k<=n[i];k++)//循环买了k个皮肤（物品个数）
				if(j-k*c[i]>=0)//防止读到花了负数个Q币越界（TX是不会给你送钱的）
				    F[j]=max(F[j],F[j-k*c[i]]*k);
	for(int i=0;;i++)
	    if(F[i]>=M)//从小到大找到满足展示组合数的最低花费
	    {
	        cout<<i;
	        break;
	    }
	return 0；
}

```
(100pts/393ms)

既然大家的题解都已经讲了这些我们哪能就此为止？

总之！让我们来对此寻找一些优化的方案

### 优化
----
首先当一个英雄只买1个皮肤对小皮球装X是没有任何帮助的，可以直接从2开始循环$k$。

对于最后的输出，考虑二分查找，但在这样把结果完全dp出来的情况无法在考虑数据溢出的基础上保证序列单调。

考虑到每次的$F[j]$都是由已经有值的$F[j-x]$推出的，并且最终的答案并不能保证在一个确定的$F[x]$中。我们这里将一维重新打开成二维（其实只是滚动数组），并在更新dp时直接记录答案。
（但在这种滚动数组的思路下，有较多细节需要注意，代码中已注明）

具体实现上，我们使用滚动数组抛开顺序，用一个数组记录需要向上更新（即有值）的状态，并可以直接使用第$i$个英雄的$i$的奇偶进行数组滚动。

### 最终代码：(100pts/144ms)
----
```cpp
#include<iostream>
#define endl '\n' //虽然这里用不上，但endl严重拖慢cout（除非你写交互题）
using namespace std;
#define MAXN 130
typedef unsigned long long uint64;
inline uint64 max(uint64 a,uint64 b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
int dp[245000],cnt=0;//更新队列，由于使用滚动数组，无需注意顺序
uint64 F[2][245000];//滚动数组
int n[MAXN],c[MAXN];
int N,ans=0x7fffffff;
uint64 M;
int mian()
{
    ios::sync_with_stdio(0);//简单的读入常数优化，勿与stdio混用就行
    cin.tie(0);cout.tie(0);
	cin>>N>>M;
	for(int i=0;i<N;i++)
		cin>>n[i];
	for(int i=0;i<N;i++)
		cin>>c[i];
	dp[cnt++]=0;//初始需要从初状态向上更新
	F[0][0]=1;
	for(int i=0,t;i<N;i++)
	    for(int j=0;j<cnt;j++)
	    {
	        t=dp[j]+c[i];//需要更新的具体的状态，此处相当于买1个皮肤，下一层循环内通过加往上增
	    	for(int k=2;k<=n[i];k++)
			{
			    t+=c[i];
			    //i&1和(i&1)^1直接使用i的奇偶进行数组滚动
			    if(F[i&1][dp[j]]*k>F[(i&1)^1][t])//判断是否需要更新状态下的值
			    {
			        if(F[0][t]==0&&F[1][t]==0)//利用F充当vis判断这个状态下是否已经被添加进更新队列
			            dp[cnt++]=t;//如果没有则将其加入
			        F[(i&1)^1][t]=F[i&1][dp[j]]*k;//转移状态
			        if(F[(i&1)^1][t]>=M)//判断是否需要更新答案
			        {
			            ans=min(ans,t);
			            break;
			        }
			    }
			}
			F[(i&1)^1][dp[j]]=max(F[(i&1)^1][dp[j]],F[i&1][dp[j]]);//防止部分状态的值没有被更新而不能被正常传递
	    }
	if(M<=1)//个人理解没有皮肤应该是1种展示方案
		ans=0;
	cout<<ans;
	return 0；
}

```
###### 直接复制代码不是好孩子喔0w0

### 总结
----
一点debug的碎碎念：最重要的M反而忘记longlong了，不过学到了luogu吸氧是可以用来debug的（开了以后大数字读入int也会RE），并且前一种方法空间开始开小了十倍居然没RE

这道题目告诉我们，背包问题除了最常见的01/完全/分组/方案数统计问题以外，还可以有这种乘算等特别的状态转移方式，答案也不一定要设置为状态的值，也可以像本题一样直接设置为状态。而01背包的二维压一维本质上是通过限制顺序实现数组滚动，对此部分保证顺序反而麻烦的情况下可以考虑为了使用相对次的普通滚动数组，同样压缩一部分空间但抛开了顺序限制。还有不用longlong见祖宗。

終わり

---

## 作者：蒟蒻zExNocs (赞：9)

一眼看过去就感觉是背包 ~~（其实就是多重背包啦）~~

因为题中M值过大（所以要注意用long long，不然就会30分QWQ），不适合当背包容量。那么我们把钱当做背包容量，背包容量=全英雄全皮肤总价钱，及 V=$\sum_{i=0}^{n}K_i*C_i$。

定义$ dp[i][j] $ 为选取前i个皮肤花费为j时候的方案数

那么该英雄花费价钱等于上一个英雄花费价钱+该英雄单个皮肤价钱*选取皮肤个数，由价钱得到上个英雄皮肤方案数后再乘以该英雄皮肤的选取个数。那么需要枚举出选取该英雄皮肤的个数。

那么可以写出动态转移方程：

$ dp[i][j]=max(dp[i-1][j-p*c[i]]*p,dp[i][j]) $

其中k[i]和c[i]就是题目描述的$K_i$和$C_i$，p为该英雄选取p个皮肤(p<=k[i])，

很明显可以滚动数组为

$ dp[j]=max(dp[j-p*c[i]]*p,dp[j]) $

初始化$dp[0]=1$


最后输出就枚举出从0到V中第一个比期望W大的数就可以了。

$ACcode:$
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pc(a) putchar(a)
#define ps(a) puts(a)
#define rg register
const ll maxm=5001;
const ll maxn=1000001;
void gc(char &a)
{for(a=getchar();a==' '||a=='\n';a=getchar());}
ll read()//输入 
{
    rg char c;rg ll x=0;bool flag=0;
    for(gc(c);c<'0'||c>'9';gc(c))if(c=='-')flag=1;
    while(c>='0'&&c<='9')
    {x=(x<<1)+(x<<3)+(c^48),c=getchar();}
    return flag? -x:x;
}
void pr(ll x)//输出 
{
    if(x<0){pc('-');x=-x;}
    if(x>9) pr(x/10);
    pc(x%10+48);
}
//--------read-------
ll dp[maxn],k[maxn],c[maxn],n,v,m,ans;
// dp[i]代表花费为i时组合个数 
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	k[i]=read();
	for(int i=1;i<=n;i++)
	c[i]=read(),v+=k[i]*c[i];
	dp[0]=1;
	for(int i=1;i<=n;i++)
	for(int j=v;j>=0;j--)  
	for(int p=1;p<=k[i]&&p*c[i]<=j;p++)
	dp[j]=max(dp[j-p*c[i]]*p,dp[j]);
	while(ans<=v&&dp[ans]<m) ans++;
	pr(ans);
	return 0;
}
```


---

## 作者：lxyguise (赞：6)

考虑到方案数过多，无法作为状态；而总钱数较少，所以可以以此作为状态。
故设f[i][j], f[i][j]表示购买前i种皮肤，花费j元能够得到的最大方案数。那么可以直接枚举每个皮肤购买的数量然后转移。 由于题目只要求判断是否达到m，因此当dp值大于m时直接将其赋为m（因为方案数是单调的，只要达到了m，以后的都会达到），避免高精度。
![](https://cdn.luogu.com.cn/upload/image_hosting/5gkcd1nt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
所以说数组开大点！
```cpp
long long l[125][100010]; 
```
然后上代码
```cpp
#include <bits/stdc++.h>

using namespace std;

long long l[125][100010]; 
long long m;
int a[131] , b[131];
int p;

int main()
{
    int n;
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++ ) 
		cin >> a[i];
		
    	l[0][0] = 1;
    for(int i = 1; i <= n; i++ )
    {
        cin >> b[i];
        
        for(int j = 0; j <= p; j++ ) 
			l[i][j] = l[i - 1][j];
        for(int j = 2; j <= a[i]; j++ )
            for(int k = b[i] * j; k <= p + b[i] * j; k++ )
                l[i][k] = min(m , max(l[i][k], l[i - 1][k - b[i] * j] * j));
        p += b[i] * a[i];
    }
    for(int i = 0; i <= p; i++ )
    {
        if(l[n][i] >= m)
        {
            cout << i << endl;
            return 0;
        }
    }
    return 0;
}
```


---

## 作者：pomelo_nene (赞：5)

## 「SNOI2017」英雄联盟（背包 dp）

$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/P5365)，同步于[动态规划100题 9题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)

$\ \ \ \ \ \ \ $首先说一下哈，这个里面的 $n \leq 10^6$，没这么麻烦。

$\ \ \ \ \ \ \ $做 dp 题都需要简化题意，这道题的意思大概就是展示策略达到 $m$ 种的最小花费。

$\ \ \ \ \ \ \ $我们有 $n$ 个英雄，每个英雄都是有一个皮肤的数量 $k_i$ 和花费 $c_i$ 的。很容易联想到我们的背包。这道题就是把每一个英雄看成一个分组，每组都有一个数量，花费固定。很经典的分组背包问题。我们定义 $dp_{i,j}$ 为买掉 $i$ 个皮肤用掉 $j$ Q 币的最大方案数。有 dp 方程：

$$dp_{i,j}=\max \{ dp_{i-1,j-p \times c_i} \times p \}$$

$\ \ \ \ \ \ \ $其中 $1 \leq p \leq k_i$。注意初始化 $dp_0=1$，因为什么都不买也算作一种方案。

$\ \ \ \ \ \ \ $可以发现我们的二维数组死掉了。考虑优化空间。

$\ \ \ \ \ \ \ $我们看到只需要考虑前 $i-1$ 维，可以考虑滚掉。也可以看到后面一维，实际上这就是一个类似于 01 背包的优化方法。直接暴力滚掉二维，倒序枚举当前的 Q 币数，然后正常背包。dp 式改进为：

$$dp_j=\max \{ dp_{j - p \times c_i} \times p \}$$

$\ \ \ \ \ \ \ $然后枚举花费 Q 币数，如果有 $m \leq dp_q$，输出 $q$。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
long long n,m,dp[1000005],k[1000005],c[1000005],rest;
int main(){
	scanf("%lld %lld",&n,&m);
	for(long long i=1;i<=n;++i)	scanf("%lld",&k[i]);
	for(long long i=1;i<=n;++i)	scanf("%lld",&c[i]),rest+=k[i]*c[i];
	dp[0]=1;
	for(long long i=1;i<=n;++i)	for(long long j=rest;~j;--j)	for(long long l=1;l<=k[i] && l*c[i]<=j;++l)	dp[j]=max(dp[j],dp[j-l*c[i]]*l);
	for(long long i=0;i<=rest;++i)	if(dp[i]>=m)	return printf("%lld",i)&0;
	return 0;
}
```

---

## 作者：神蝶涵光 (赞：4)

```
话说LOL世界比赛，中国已经三次冠军了！！！ 
2018年，中国的duIG战队。
2019年，中国的FPX战队。
2020年，中国投资的DWG战队。 
竟然几块钱就可以买皮肤？
```
```
言归正传，这是一道多重背包问题。
首先， 价格的循环边界应为每个皮肤都要买。
------for(ll j=Q;j>=0;j--) Q为都买时的总价钱。
这里一定要倒这来，否则，嘿嘿，大红。
那还差个大紫，那就是------n<=max(5,log24i),m<=10e17; 
然后，根据模板（详情请见——背包问题九讲），状态转移方程为-----
------f[j]=max(f[j],f[j-kk*c[i]]*kk); kk为买几个，
注意因为题目保证有解，故ans！=0，这时需特判,
if(!ans)
	cout<<1;
不然你试一试---
3 1
1 1 1
1 1 1
直接hack掉大部分方法。
代码及吐槽如下
```

```
#include<bits/stdc++.h>//信奥用了c++，能用万能头和STL 
#define ll long long//一年OI一场空，不开longlong见祖宗并减少敲击键盘的次数
using namespace std;
ll n,m,Q,ans=0;
ll k[1000001],c[1000001],f[1000001];//数据好大
int main()
{
	f[0]=1;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>k[i];
	for(int i=1;i<=n;i++)
		cin>>c[i];//就不能一起输入吗？多写一重循环，麻烦 
	for(int i=1;i<=n;i++)
		Q+=k[i]*c[i];
	for(ll i=1;i<=n;i++)
		for(ll j=Q;j>=0;j--)
			for(ll kk=0;kk<=k[i];kk++)
				if(kk*c[i]<=j)
					f[j]=max(f[j],f[j-kk*c[i]]*kk);//麻烦si我了 
	while(ans<=Q)
		if(f[ans]<=m) 
			ans++;
	if(!ans)
	    cout<<1;
	else
	    cout<<ans;
	return 0;//return好习惯 
}
```

---

## 作者：JeffWang2019 (赞：4)

[P5365 英雄联盟](https://www.luogu.com.cn/problem/P5365)

看到题目就知道是“~~臭名昭著~~”的**背包问题**，并且与全排列有关。

**做题前的一声忠告**：看了下数据范围：$1 <= M <= 10^{17}$ 凭直觉就知道，数据范围这么大，而且涉及到乘法，很容易爆！因此需要开$long long$，数组也得开大。

同时我们注意到$M$很大，即方案太多，但钱很少，作为状态可以省下不少空间。

因此$dp[i][j]$表示前$i$个英雄花了$j$元的展示策略。

可以直接枚举不同英雄购买的皮肤数量来转移，所以这是个经典的**多重背包问题**！

转移方程：
```cpp
dp[i][o]=max(dp[i][o],dp[i-1][o-s]*j);
dp[i][o]=min(dp[i][o],m);

//也可以简化成：dp[i][o]=min(max(dp[i][o],dp[i-1][o-s]*j),m);

```

$dp$过程中为了防止方案数太大的话需要卡上限$M$防止乘爆。

下面是$AC$代码：（$勿抄$）

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
#define ll long long int//省事
ll dp[126][100001]={1}/*初始赋值dp[0][0]=1*/,k[126],c[126];
//经过计算，N最大为125
ll n,m,QB=0;
void d_p()//dp过程
{
    for(int i=1;i<=n;i++)//枚举每种英雄，找方案
    {
        for(int j=0;j<=QB;j++)//状态初始化
        {
            dp[i][j]=dp[i-1][j];
        }
        for(int j=2;j<=k[i];j++)//枚举每个英雄所买的皮肤数
        {
            int s=c[i]*j;
            for(int o=s;o-s<=QB;o++)//枚举可用的Q币数
            {
                dp[i][o]=max(dp[i][o],dp[i-1][o-s]*j);//状态转移方程
                dp[i][o]=min(dp[i][o],m);//题目要求中，只要>=m即可
            }
        }
            
    }
}
int main()
{
    //输入部分
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&k[i]);//输入每个英雄的皮肤数量
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&c[i]);//输入每个英雄的皮肤价格
    }
    for(int i=1;i<=n;i++)
    {
        QB+=k[i]*c[i];//计算总Q币数
    }
    d_p();//dp部分
    //输出部分
    for(int i=0;i<=QB;i++)
    {
        if(dp[n][i]>=m)//只要总展示策略达到要求
        {
            printf("%d",i);//直接输出下标
            break;//满足要求，退出循环，结束程序
        }
    }
    return 0;//结束程序
}
```

### 望通过！

[文末彩蛋](https://www.luogu.com.cn/blog/paiwyz314/)

---

## 作者：issue_is_fw (赞：4)

其实这题就是普通的多重背包啦!!

和以前一样，先枚举物品，再枚举体积，最后枚举每个物品的个数

背包容量是买下所有物品的钱

容易想到，背包价值就是把每个物品的个数乘起来

所以初始化$dp[0]=1$，因为后续我们要一直做乘法

**可能有同学有疑惑，为什么不用二进制优化呢**，我觉得二进制优化在这题是行不通的(~~不会被打脸把~~)

因为普通的背包是做加法，选2个A物品再选3个同种A物品等价与5个A物品

但在这题中，选两个A再选3个A物品相当于$2*3=6$

自己好好体会一下。

**还有一个小细节，其实在$dp[i]$大于m的时候我们就不需要继续更新它了**，因为它已经符合要求。如果数据变态一点，这样一直更新很容易爆掉$long long$，这都是需要注意的。

```cpp
for(int i=1;i<=n;i++)
	for(int q=mm;q>=0;q--)//枚举容量 
		for(int k=1;k<=num[i];k++)//枚举物品种数 
			if(k*v[i]<=q&&dp[q]<m)
				dp[q]=max(dp[q],dp[q-k*v[i]]*k);
```


---

## 作者：LRL65 (赞：3)

这是一道**dp（背包）**


------------


讲之前砸门要看懂这个数据范围:

$n<=max(5,log_2^4i)$，其中 $i$ 最大为10。

那么 $n$ 最大为125（~~其实说真的我也不知道为啥~~）。

然后 $m$ 最大应该为 $10*199*n=1990*125=248750$，所以开个25万就够了。（应该是这样，本蒟蒻太弱，错误请指出）


------------


### 一、二维背包

$f[i][j]$表示 **前 $i$ 个英雄花了 $j$ 个Q币最多有多少展示策略**。

那么就应该分为两种情况：
1. 不选皮肤（表示为$f[i][j]$）	
1. 选p个皮肤（表示为$f[i-1][j-c[i]*p]*p$）

那么状态转移方程应为：

$f[i][j]=max(f[i][j],f[i-1][j-c[i]*p]*p)$

这样的话代码就是这样的:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=126;
long long int n,m,k[MAXN],c[MAXN],f[MAXN][240001],tot=0;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>k[i];//输入
    for(int i=1;i<=n;i++)cin>>c[i],tot+=k[i]*c[i];//输入
    f[0][0]=1;//初始化
    for(int i=1;i<=n;i++) {
        for(int j=0;j<=tot;j++)f[i][j]=f[i-1][j];//初始化
        for(int p=1;p<=k[i];p++)
            for(int j=c[i]*p;j<=tot;j++)f[i][j]=max(f[i][j],f[i-1][j-c[i]*p]*p);
    }
    for(int i=0;i<=tot;i++)
        if(f[n][i]>=m) {//找最小的大于m的输出
            cout<<i<<endl;
            return 0;
        }
}
```
### 二、一维背包

仔细观察二维背包的状态转移方程，发现可以将前面的这个维度滚动掉，变为：

$f[j]=max(f[j],f[j-c[i]*p]*p)$

代码为：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=126;
long long int n,m,k[MAXN],c[MAXN],f[240001],tot=0;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>k[i];
    for(int i=1;i<=n;i++)cin>>c[i],tot+=k[i]*c[i];
    f[0]=1;
    for(int i=1;i<=n;i++) {
        for(int j=tot;j>=0;j--)
            for(int p=0;p<=k[i]&&p*c[i]<=j;p++)f[j]=max(f[j],f[j-c[i]*p]*p);
    }
    for(int i=0;i<=tot;i++)
        if(f[i]>=m) {
            cout<<i<<endl;
            return 0;
        }
}
```



---

## 作者：EDqwq (赞：2)

这一道题作为一个背包题还是很值得用来练手的。

***

### 思路：

可以看出，这是一道多重背包题。

但是，普通的多重背包题要我们求的是用一定的背包容量，选到更有价值的东西，询问最多能得到多少价值的东西。

可这道题不同，它让我们求的是**最少花多少钱（Q币）才能得到m种选皮肤方式。**

选皮肤方式的计算方法是乘法，所以我们得略改一点转移方程——把加价值改为乘以当前枚举的皮肤数量。

原方程：

```cpp
dp[j] = max(dp[j],dp[j - a[i]] + w[i])
```

加入枚举皮肤数量与新的计算价值（秀皮肤种数）的方程如下：

```cpp
dp[j] = max(dp[j],dp[j - k * a[i]] * k)
```
这样一来，我们既可以处理多重背包，又可以处理新的价值计算方式，非常方便。

但是这会超时吗？

如果这么计算，就得套三层循环，有点恐怖。

一看数据范围，计算可得知，n大约为100这个数量级的，于是我们完全不怂。

***

### 代码细节讲解：

仅讲解细节部分。

首先，这道题虽然是个背包，但是仍然需要初始化，不然乘出来全是0。

然后便开始三层循环。第一层如普通背包，从1到n循环。第二层就不一样了，我们需要从**所有物品钱数之和**开始循环。

为何？

你想想，对于普通背包，我们是从m开始的，也就是背包容量，因为我们仅需要得到背包容量那么多的容量。

而这一题不同，我们定义的$dp[m]$为用m元能得到的最多秀皮肤种数。

而我们背包处理完之后，必须从头开始循环判断哪一个能得到足够的秀皮肤种数。所以我们得循环到总价格。

而第三层循环便是枚举物品数量了。我们用一个数组存储物品数量，直接从1开始枚举即可。

***

### 注意事项：

$M <= 10^9 \times 10^8$，所以不开$long long$肯定会见祖宗。

第二层循环要从价格总数循环到0，而不是背包模板的a[i]。

这道题大概不能用二进制优化，也没有必要。

***

### 代码：

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n,m;
int a[100010];
int dp[100010];
int num[100010];
int ans;
int all;

signed main(){
	cin>>n>>m;
	for(int i = 1;i <= n;i ++)num[i] = read();
	for(int i = 1;i <= n;i ++)a[i] = read(),all += a[i] * num[i];
	dp[0] = 1;
	for(int i = 1;i <= n;i ++){
		for(int j = all;j >= 0;j --){
			for(int k = 1;k <= num[i];k ++){
				dp[j] = max(dp[j],dp[j - k * a[i]] * k);
			}
		}
	}
	while(1){
		if(ans > all)break;
		if(dp[ans] >= m)break;
		ans ++;
	}
	cout<<ans;
	return 0;
}
```

---


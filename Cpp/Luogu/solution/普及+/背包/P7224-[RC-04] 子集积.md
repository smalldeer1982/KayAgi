# [RC-04] 子集积

## 题目描述

给出 $n$ 个整数 $a_1\sim a_n$，它们构成的多重集中，有几个子集的元素积大于 $m$？（空集的元素积等于 $1$）

两个子集不同，当且仅当它们中包含元素的 **下标** 不同。

答案很大，因此请输出它对 $998244353$ 取模的值。

## 说明/提示

【样例 $1$ 解释】

以下子集符合要求：$\{a_3,a_4\}$，$\{a_1,a_3,a_4\}$，$\{a_2,a_3,a_4\}$，$\{a_1,a_2,a_3,a_4\}$。

【数据范围】

对于所有数据，$0\le n,m\le 10^6$，$1\le a_i\le 10^6$。

详细数据范围如下表：

| 测试点编号 | $n$ | $m$ | $a_i$ | 每测试点分数 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $=0$ |  |  | $1$ |
| $2$ |  | $=0$ |  | $1$ |
| $3\sim 6$ | $\le 22$ |  |  | $4$ |
| $7\sim 10$ | $\le 1000$ | $\le 1000$ |  | $4$ |
| $11\sim 14$ |  |  | 互不相同 | $4$ |
| $15\sim 19$ | $\le 2\times 10^5$ | $\le 2\times 10^5$ |  | $5$ |
| $20\sim 24$ |  |  |  | $5$ |

## 样例 #1

### 输入

```
4 4
1 1 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
20 123456
1 5 12 24 189893 233333 2 22 134 3284 28456 261 50 10 1 2 2 2 2 22```

### 输出

```
1036360```

# 题解

## 作者：wsyhb (赞：12)

## 分析 + 题解

正难则反，题目需要求有几个子集的元素积 $>m$，我们将其**转化为求有几个子集的元素积** $\le m$。（显然一共有 $2^n$ 个子集）

很明显这是一个背包，考虑暴力加入每个物品，时间复杂度为 $O(\sum_{i=1}^n \lfloor \dfrac{m}{a_i} \rfloor)$。若 $a_i$ 很小，则时间复杂度接近上界 $O(nm)$。

注意到若 $a_i$ 互不相同，$O(\sum_{i=1}^n \lfloor \dfrac{m}{a_i} \rfloor) \le O(\sum_{i=1}^m \dfrac{m}{i})=O(m \ln{m}) $，于是考虑**将 $a_i$ 相同的一起处理**。

具体而言，设 $a_i=j \; (j>1)$ 的 $i$ 有 $k$ 个，则使用 $j,j^2,j^3,\cdots,j^k$ 进行转移，$j^q$ 转移时系数为 $(^k_q)$。特别地，设$a_i=1$ 的 $i$ 有 $k$ 个，则只需将最终答案乘以 $2^k$ 而不作任何转移。

时间复杂度为 $O(\sum_{i=2}^m \sum_{j=1}^{cnt_i} \lfloor \dfrac{m}{i^j} \rfloor)$，由于总共只有不超过 $n$ 项相加，且分母为指数级增长，所以可以将其近似的看成 $O(m \ln{m})$。（其中 $cnt_i$ 表示值 $i$ 的个数，$n$ 和 $m$ 同阶）

## 代码

预处理阶乘及其逆元用于求组合数，然后进行背包即可，代码其实很好写：

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int P=998244353;
inline void add(int &a,int b)
{
	a=a+b-(a+b>=P?P:0);
}
inline void sub(int &a,int b)
{
	a=a-b+(a-b<0?P:0);
}
inline int get_pro(int a,int b)
{
	return 1ll*a*b%P;
}
/*以上为模意义下的运算*/
const int max_n=1e6+5;
int fac[max_n],inv[max_n],inv_fac[max_n];
inline void init(int n)//预处理阶乘 fac, 逆元 inv,以及阶乘的逆元 inv_fac 
{
	fac[0]=inv_fac[0]=1;
	fac[1]=inv[1]=inv_fac[1]=1;
	for(int i=2;i<=n;++i)
	{
		fac[i]=get_pro(fac[i-1],i);
		inv[i]=get_pro(P-P/i,inv[P%i]);
		inv_fac[i]=get_pro(inv_fac[i-1],inv[i]); 
	}
}
inline int C(int n,int m)//组合数 
{
	if(n<0||m<0||n<m)
		return 0;
	return get_pro(fac[n],get_pro(inv_fac[m],inv_fac[n-m]));
}
const int max_a=1e6+5;
int cnt[max_a];
const int max_m=1e6+5;
int dp[max_m];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		int a;
		scanf("%d",&a);
		++cnt[a];
	}
	int mx=0;
	for(int i=2;i<=1e6;++i)
		mx=max(mx,cnt[i]);
	init(mx);//只需预处理最大出现次数即可 
	dp[1]=1;
	for(int i=2;i<=1e6;++i)
	{
		if(cnt[i])//此处应判断是否有值为 i 的元素，否则会跑 m/i 长度的空循环 
		{
			for(int k=m/i;k>=1;--k)
			{
				if(dp[k])//有 dp 值才进行转移，减小常数 
				{
					long long v=i;//注意 v 最大可能为 10^12，开 long long 
					for(int j=1;j<=cnt[i]&&v*k<=m;++j,v*=i)
						add(dp[v*k],get_pro(C(cnt[i],j),dp[k])); 
				}
			}
		}
	}
	int ans=1;
	for(int i=1;i<=n-cnt[1];++i)//ans=2^{n-cnt[1]} 
		add(ans,ans);
	for(int i=1;i<=m;++i)
		sub(ans,dp[i]);
	for(int i=1;i<=cnt[1];++i)//ans*=2^{cnt[1]} 
		add(ans,ans);
	printf("%d\n",ans);
	return 0;
}
```

PS：由于 $\sum_{i=2}^m cnt_i \le n$，所以也可以采用一乘一除的方式求组合数：

$$(^n_m)=\dfrac{n(n-1) \cdots (n-m+1)}{m!}$$

---

## 作者：William_Wang_ (赞：3)

[题目](https://www.luogu.com.cn/problem/P7224)

## P1 背包

子集积 $>m$ 的个数并不好求，考虑子集积 $\le m$ 的个数 $x$，答案即为 $(2^n - x)$。

对于子集积 $\le m$ 的个数，可以化为 0-1 背包问题做，$f_{i,j}$ 表示前 $i$ 个数，子集积为 $j$ 的个数，有：

$f_{i,j}=\sum \limits_{j=1}^{m} f_{i-1,\frac {j} {a_i}}$（$j$ 是 $a_i$ 的倍数）。

背包问题常规地去掉一维：$f_j$ 表示子集积为 $j$ 的个数：

$f_j=\sum \limits_{j=1}^{m} f_{\frac {j} {a_i}}$（$j$ 是 $a_i$ 的倍数）。

```cpp
	cin >> n >> m;
	
	for(int i=1; i<=n; i++) cin >> a[i];
	
	f[1] = 1;
	for(int i=1; i<=n; i++)
		for(int j=(m / a[i]) * a[i]; j>=a[i]; j-=a[i])
			f[j] += f[j / a[i]], f[j] %= mod;
		
	int sum = qpow(2, n);
	for(int i=1; i<=m; i++)
		sum -= f[i],  sum = (sum % mod + mod) % mod;
	cout << sum;
```

时间复杂度 $O( \sum\limits_{i=1}^{n} {\frac {m} {a_i}})$，最坏情况下 $O(nm)$。

## P2 优化

**优化 1**

若序列中有 $100$ 个 $1$，然而任意多个 $1$ 不会对子集积产生影响，我们只需要在方案数中乘以 $2^{100}$ 即可。

```cpp
	...
	int sum = qpow(2, n);
	for(int i=1; i<=m; i++)
		sum -= f[i] * qpow(2, cnt[1]) % mod,  sum = (sum % mod + mod) % mod;
	cout << sum;
```

**优化 2**

时间复杂度高的原因在于重复的计算：若有 $100$ 个 $2$，我们将第 $2,3$ 个 $2$、第 $3,4$ 个 $2$、第 $4,5$ 个 $2$ 等等算了多次。我们应该只关心是几个 $2$，而不关心是哪几个 $2$。

对于任意一个数 $x$，设其出现了 $t$ 次，我们可以对 $x^1,x^2,...,x^t$ 分别计算，使用 $x^i$  计算贡献时乘以 $\binom {t}{i}$， 即 ：

$f_j=\sum\limits_{i=1}^{t} ( f_{\frac {j} {x^i}} \times \binom {t}{i})$（$j$ 是 $x^k$ 的倍数）。


记 $V$ 为值域。时间复杂度在 $a_i$ 各不相同时为 $O(\sum\limits_{i=1}^{V} \frac {V}{i}) = O(V \ln V)$，在 $a_i$ 全部为 $2$ 时为 $O(m \log m)$。$n,m,V$ 同阶时均摊为 $O(n \log n)$。

**注意：** 这里与多重背包的二进制拆分拆成多个物品不同，是优化了对于一个物品的计算方式。

[代码](https://www.luogu.com.cn/paste/r1vgs58r)

---

## 作者：Spook (赞：1)

## 主要思路

一大早刷到一道背包 dp。

看了半天，始终没想出直接求解的 dp 方法（想到了时间也过不去）。

于是就想到了反过来求（即求出子集数和元素积小于等于 $m$ 的子集数）。

子集数挺好求，就是 $2^n$（[证明](https://blog.csdn.net/weixin_43281875/article/details/124379664?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169279175516800180636612%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=169279175516800180636612&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-124379664-null-null.268^v1^koosearch&utm_term=%E6%B1%82%E5%AD%90%E9%9B%86%E4%B8%AA%E6%95%B0%E8%AF%81%E6%98%8E&spm=1018.2226.3001.4450)）。

而元素积小于等于 $m$ 的数量就可以用 dp 完成咧。

#### 定义状态

只需要开一维（别问，问就是 $n$ 和 $m$ 太大力），即元素积为 $j$ 的子集数。

#### 状态转移

我们要让 $j$ 从 $\dfrac{j}{a_i}$ 转移（$j\mid a_i$）只需要枚举 $j$ 就行了（记得要模上 $998244353$）。
```cpp
for(int i=1;i<=n;i++){
	for(int j=m-m%a[i];j>0;j-=a[i]){
		dp[j]+=dp[j/a[i]];
	}
}
```

## 优化（本题的难点）

如果只是 dp 的话，本题是过不了地[~~像我~~](https://www.luogu.com.cn/record/122440021) 。

但是，我们还可以经行一些优化。

例如，$a_i$ 为 $1$ 时，他是不会对元素积产生贡献的，我们只需要在计算答案是将个数乘上 $2^{k}$（$k$ 为 $1$ 的个数）[~~虽然没什么用~~](https://www.luogu.com.cn/record/122455903)。

在计算时，我们发现有许多相同的数，而数的位置与答案无关，我们可以用 $a^1\sim a^{cnt}$（$a$ 为本数，$cnt$ 为本数出现的数量）分别转移 dp 这样就可以大大的减少时间复杂度（在转移时要乘上 $\dbinom{cnt}{k}$（$k$ 为枚举的指数）所以，还要打逆元啊！）。

附上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAX 1000005
#define mod 998244353
using namespace std;
int a[MAX],dp[MAX],f[MAX],inv[MAX],cnt[MAX],maxn,n,m;
int km(int q){//快速幂
	if(q==0)return 1;
	if(q==1)return 2;
	int p=km(q/2)%mod;
	if(q%2)return p*p*2%mod;
	return p*p%mod;
}
int C(int n,int m){//逆元求排列组合
	return (((f[n]*inv[n-m])%mod)*inv[m])%mod;
}
signed main(){
	cin.tie(nullptr);
	cin>>n>>m;
	dp[1]=f[0]=inv[0]=inv[1]=f[1]=1;
	int ans=km(n);
	for(int i=1;i<=n;i++)cin>>a[i],cnt[a[i]]++,maxn=max(a[i],maxn);
	for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=2;i<=n;i++){
		inv[i]=inv[i-1]*inv[i]%mod, 
		f[i]=f[i-1]*i%mod;
	}
	for(int i=2;i<=maxn;i++){
		if(!cnt[i])continue;
		for(int j=m-m%i;j>0;j-=i){//找i的倍数
			int k=1,p=i;
			while(k<=cnt[i]&&!(j%p)){//枚举i^k
				dp[j]+=dp[j/p]*C(cnt[i],k)%mod;
				dp[j]%=mod,k++,p*=i;
			}
		}
	}
	int fa=km(cnt[1]);
	for(int i=1;i<=m;i++){
		ans-=(dp[i]*fa)%mod;
		ans=((ans%mod)+mod)%mod;
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：Fire_Raku (赞：0)

[P7224 [RC-04] 子集积](https://www.luogu.com.cn/problem/P7224)

背包 dp + 复杂度优化

考虑 dp。容易想到背包 dp，设 $f_{i,j}$ 表示考虑了前 $i$ 个，当前乘积为 $j$ 的方案数。枚举 $a_i$ 的倍数转移。

复杂度 $O(\sum\limits_{i=1}^n\frac{m}{a_i})$。如果 **$a_i$ 互不相同**，那么近似于 $O(m\ln m)$。

如果还想要这样的复杂度，可以考虑相同的部分能不能同时处理。假设现在 $a_i$ 有 $k$ 个，那么会组成 $k$ 个不同的 $a_i$ 的乘积（如 $a_i$、$a_i^2$、$a_i^k$）。将这 $k$ 个数作为物品放入序列中，对于物品 $a_i^j$，有 $C(k,j)$ 的系数，每次转移同样是 $\frac{m}{a_i^j}$ 的复杂度。

那么从原来每个相同的 $a_i$ 都是 $O(\frac{m}{a_i})$ 的复杂度，到现在所有相同的 $a_i$ **总复杂度**为 $O(\sum\limits_{j=1}^k\frac{m}{a_{i}^j})$，由于下面是指数增长，所以近似于 $O(\frac{m}{a_i})$。

需要注意的是，对于 $a_i=1$ 的部分需要单独处理，最后将每个状态 $f_i\times 2^{cnt_1}$ 即可。

复杂度 $O(m\ln m)$。

```cpp
#include <bits/stdc++.h>
#define pii std::pair<int, int>
#define mk std::make_pair
#define fi first
#define se second
#define pb push_back

using i64 = long long;
using ull = unsigned long long;
const i64 iinf = 0x3f3f3f3f, linf = 0x3f3f3f3f3f3f3f3f;
const int N = 1e6 + 10, mod = 998244353;
int n, m, cnt[N];
i64 fac[N], inv[N], a[N], f[N];
i64 qpow(i64 a, i64 b) {
	i64 ret = 1;
	while(b) {
		if(b & 1) ret = ret * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ret;
}
void init() {
	fac[0] = 1;
	for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % mod;

	inv[n] = qpow(fac[n], mod - 2);
	for(int i = n - 1; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % mod;
}
i64 C(i64 n, i64 m) {
	if(n < m) return 0;
	return fac[n] * inv[m] % mod * inv[n - m] % mod; 
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
	std::cin >> n >> m;

	init();
	i64 ans = qpow(2, n);

	for(int i = 1; i <= n; i++) {
		std::cin >> a[i];
		cnt[a[i]]++;
	}
	std::sort(a + 1, a + n + 1);
	n = std::unique(a + 1, a + n + 1) - a - 1;

	f[1] = 1;
	for(int i = 1; i <= n; i++) {
		if(a[i] == 1) continue;

		i64 val = 1;
		for(int j = m / a[i]; j >= 1; j--) {
			val = 1;
			for(int k = 1; k <= cnt[a[i]]; k++) {
				val *= a[i];
				if(j * val > m) break;
				f[j * val] = (f[j * val] + f[j] * C(cnt[a[i]], k) % mod) % mod;
			}
		}
	}

	i64 pw = qpow(2, cnt[1]);
	for(int i = 1; i <= m; i++) {
		ans = (ans - f[i] * pw % mod + mod) % mod;
	}

	std::cout << ans << "\n";
	return 0;
}
```

---

## 作者：August_Light (赞：0)

# P7224 [RC-04] 子集积 题解

[题目传送门](https://www.luogu.com.cn/problem/P7224)

## 题意简述

给定一个 $n$ 个元素的多重集 $a$，求 $a$ 有几个子集的元素积大于 $m$。

答案对 $998244353$ 取模。

对于所有数据，$0\le n,m\le 10^6$，$1\le a_i\le 10^6$。

## 解法

（设 $n,m$ 同阶）

大于 $m$ 不好做，做小于等于 $m$。不难发现是一个类似 01 背包的玩意儿。

暴力 01 背包复杂度 $O(n^2)$，过不去。

看到数据范围中有一档部分分为 $a_i$ **各不相同**。发现此时 复杂度被降到调和级数 $O\left(\sum\limits_{a=1}^n \dfrac n a\right) = O(n \log n)$。

考虑把一样的数一起加入背包。

具体来说，假如 $a$ 有 $c$ 个，将 $a^1, a^2, \cdots, a^c$ **分别互不影响地**加入背包（可以使用一个哈希表），且设置每个 $a^i$ 的权值为 $\dbinom c i$，将所得的结果相加。

```cpp
// C(cnt, i) 建议提到第一个循环内计算，防止 TLE
umap<ll, ll> mp;
for (ll i = 1, b = a; i <= cnt && b <= m; i++, b *= a)
    for (ll j = m / b * b; j >= b; j -= b)
        (mp[j] += f[j / b] * C(cnt, i) % MOD) %= MOD;
for (auto [x, y] : mp)
    (f[x] += y) %= MOD;
```

时间复杂度即可保持 $O(n \log n)$。

当然，使用一个 `unordered_map` 十分不优雅，我们可以交换求和顺序：

```cpp
for (ll j = m / a * a; j >= a; j -= a)
    for (ll i = 1, b = a; i <= cnt && j % b == 0; i++, b *= a)
        (f[j] += f[j / b] * C(cnt, i) % MOD) %= MOD;
```

## 代码

```cpp
#include <bits/stdc++.h>
#define umap unordered_map
using namespace std;
typedef long long ll;

const int MAXN = 1e6 + 5;
const ll MOD = 998'244'353;

ll qpow(ll a, ll b) {
    ll ret = 1;
    while (b) {
        if (b & 1)
            (ret *= a) %= MOD;
        (a *= a) %= MOD;
        b >>= 1;
    }
    return ret;
}
ll inv(ll a) {
    return qpow(a, MOD-2);
}
ll fac[MAXN], invfac[MAXN];
void init(ll n) {
    fac[0] = 1;
    for (ll i = 1; i <= n; i++)
        fac[i] = fac[i-1] * i % MOD;
    invfac[n] = inv(fac[n]);
    for (ll i = n; i >= 1; i--)
        invfac[i-1] = invfac[i] * i % MOD;
}
ll C(ll n, ll m) {
    return fac[n] * invfac[m] % MOD * invfac[n-m] % MOD;
}

ll n, m;
ll a[MAXN];
ll buc[MAXN];

ll f[MAXN];

vector<pair<ll, ll>> vec;

int main() { ios::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    init(max(n, m));
    for (int i = 1; i <= n; i++)
        cin >> a[i], buc[a[i]]++;
    for (int j = 1; j <= m; j++)
        if (buc[j])
            vec.emplace_back(j, buc[j]);
    f[1] = 1;
    for (auto [a, cnt] : vec) {
        if (a == 1) continue;
        for (ll j = m / a * a; j >= a; j -= a)
            for (ll i = 1, b = a; i <= cnt && j % b == 0; i++, b *= a)
                (f[j] += f[j / b] * C(cnt, i) % MOD) %= MOD;
    }
    ll s = 0;
    for (int j = 1; j <= m; j++)
        (s += f[j]) %= MOD;
    ll ans = (qpow(2, n) - s * qpow(2, buc[1]) % MOD + MOD) % MOD;
    cout << ans << '\n';
    return 0;
}
```

---


# 小挖的买花

## 题目背景

小挖喜欢买花，但是 ta 太懒了！所以这个任务全权交给了你。

## 题目描述

花店里只有 $n$ 株花，每一株花都有三个属性：价格 $cost_i$、美丽度 $be_i$、新鲜程度 $fr_i$。

小挖每次都有不同的要求。准确来说，对于第 $j$ 次买花，你手里的钱**至多能买下总价为 $c_j$ 的花**。同时，小挖还要求购买花的**新鲜程度总和大于等于 $f_j$**。而小挖希望知道，在满足 ta 给出的条件后，购买**花的美丽度总和**的最大值是多少？


小挖一共要让你买 $q$ 次花，你能否正确回答 ta 的问题呢？询问彼此独立。

## 说明/提示

对于 $20\%$ 的数据，$3\leq n,q\leq 16$。

对于 $40\%$ 的数据，$3\leq n,q\leq 30$，$0\leq c_j,f_j\leq 50$。

对于 $60\%$ 的数据，$3\leq n\leq 100$，$1\leq q\leq 5\times 10^4$，$0\leq cost_i,fr_i,c_j,f_j\leq 100$。

对于另外 $20\%$ 的数据，对于每次买花，都有 $f_j=0$。

对于 $100\%$ 的数据，$3\leq n\leq 500$，$\boldsymbol{1\leq q\leq 10^6}$，$0\leq cost_i,fr_i,c_j,f_j\leq 500$，$1\leq be_i \leq 10^6$。

## 样例 #1

### 输入

```
5 1
2 4 5
4 3 3
1 3 2
3 4 3
3 2 5
10 10
```

### 输出

```
15
```

# 题解

## 作者：After_light (赞：14)


**简介大意**：让你求总价不超过某个数同时新鲜度依次大于等于一个数的最大价值搭配。

一个很典型的**限制性二维体积背包**问题，与 [P1507 NASA的食物计划](https://www.luogu.com.cn/problem/P1507) 不同的是， P1507 的限制都是限制最大值，而本次为限制最小值。那么同 01 背包一样，此题背包自然是 01 背包，但是我们发现对于**限制最小值**操作，空间消耗无法确定，如果直接开肯定 MLE ，这时，发现 $f_j\le 500$ ，所以我们可以将 $\ge500$ 的新鲜度所带来的最优方案都存放到 $501$ 的新鲜度中，这样就解决了空间问题。此时， $q\le10^6$ ，我们要做到 $\mathcal{O}(1)$ 查询，我们就要统计**前缀最大值**和**后缀最大值**。

**后缀最大值**：为了解决**限制最小值**，从大的新鲜度转移到小的新鲜度取最优值，因为价钱一样，而大的新鲜度已经够了小的新鲜度的要求所以可以转移。

**前缀最大值**：为了解决**限制最小值**，从价钱小的转移的价钱大的，因为用的钱本身更多，所以肯定满足比他用了更少钱的，所以可以转移。

Code:

```cpp
#include<bits/stdc++.h>
#define ll int
#define sc(n) scanf("%d",&n)
#define ps(n) printf("%d ",n)
#define pn(n) printf("%d\n",n)
#define FOR(i,a,b) for(ll i=a;i<=b;i++)
#define ROF(i,a,b) for(ll i=a;i>=b;i--)
using namespace std;
const ll N=500+7;
ll n,m,co[N],fr[N],be[N],f[N][N],pre[N][N],upre[N][N];
int main(){
	sc(n),sc(m);
	FOR(i,1,n) sc(co[i]),sc(fr[i]),sc(be[i]);
	FOR(i,0,500){
		FOR(j,0,501){
			f[i][j]=pre[i][j]=upre[i][j]=INT_MIN;
		}
	}
	f[0][0]=0;
	FOR(i,1,500){
		ROF(j,500,co[i]){
			ROF(k,501,501-fr[i]){
				f[j][501]=max(f[j][501],f[j-co[i]][k]+be[i]);
			}
			ROF(k,500,fr[i]){
				f[j][k]=max(f[j][k],f[j-co[i]][k-fr[i]]+be[i]);
			}
		}
	}
	FOR(i,0,500){
		ROF(j,501,0){
			upre[i][j]=max(f[i][j],upre[i][j+1]);
		}
	}
	FOR(i,0,500){
		ROF(j,501,0){
			pre[i][j]=max(upre[i][j],pre[max(0,i-1)][j]);
		}
	}
	while(m--){
		ll x,y;
		sc(x),sc(y);
		pn(pre[x][y]); 
	} 
	return 0;
}
```

---


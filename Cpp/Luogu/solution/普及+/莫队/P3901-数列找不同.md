# 数列找不同

## 题目描述

现有数列 $A_1,A_2,\ldots,A_N$，$Q$ 个询问 $(L_i,R_i)$，询问 $A_{L_i} ,A_{L_i+1},\ldots,A_{R_i}$ 是否互不相同。


## 说明/提示

对于 $50\%$ 的数据，$N,Q  \le 10^3$。  
对于 $100\%$ 的数据，$1 \le N,Q \le 10^5$，$1 \le A_i \le N$，$1 \le L_i \le R_i \le N$。

## 样例 #1

### 输入

```
4 2
1 2 3 2
1 3
2 4```

### 输出

```
Yes
No```

# 题解

## 作者：Misaka_Azusa (赞：152)

## 对于区间查询的问题，提供一种思路：
## 莫队。

莫队是处理区间问题的乱搞神器，尤其是对于离线查询问题，当然也可以做在线查询，比如带修莫队。

对于有的题，莫队是乱搞骗分，而在某些地方，莫队是正解。

这道题来说，可以当做是萌新初学莫队的一个板子，而且莫队也好理
解。线段树树状数组这类也可以做，但是相比莫队而言麻烦些。（个
人见解，不喜勿喷。谢谢）

---------

## 1st.关于莫队的思想:

先明白一点，莫队可以理解成：
### 优雅的暴力。

暴力算法几乎人人都会，所以莫队理解起来好理解。

#### 如果让你暴力的话呢？

我们用一个cnt[ ]数组记录每种元素，用桶排的思想，枚举区间，每遇到一个元素对应的桶++，然后暴力一遍所有的桶，等于1的我们ans就++，这样统计不同的个数，看看是不是等于L到R，然后再清空桶和ans，做下一组询问。


对于一般的暴力算法往往会TLE，那么莫队是怎么做的呢？

首先：考虑我们有两个指针。一个叫做curL，另一个叫curR。他们对应的是所指的数的标号。这样我们可以利用这两个指针进行移动，每次只能向左或向右移动一步。移动的复杂度是O(1)。

eg：![](https://cdn.luogu.com.cn/upload/pic/19569.png)

我们现在处理了curL—curR区间内的数据，现在左右移动，比如curL到curL-1，只需要更新上一个新的3，即curL-1。

那么curL到curL+1，我们只需要去除掉当前curL的值。因为curL+1是已经维护好了的。

curR同理，但是要注意方向哦！curR到curR+1是更新，curR到cur-1是去除。

我们先计算一个区间 [curL curR] 的answer，这样的话，我们就可以用O(1)转移到 [curL-1 curR] [curL+1 curR] [curL curR+1]  [curL curR-1] 上来并且求出这些区间的answer。

我们利用curL和curR，就可以移动到我们所需要求的[L R]上啦~

这样做会快很多，但是......

如果有个**数据，让你在每个L和R间来回跑，而且跨度很大呢？？

我们每次只动一步，岂不是又T了？？

但是这其实就是莫队算法的核心了。我们的莫队算法还有优化。

这就是莫队算法最精明的地方（我认为的qwq）

我们想，因为每次查询是离线的，所以我们先给每次的查询排一个序。

排序的方法是
### 分块。

我们把所有的元素分成多个块（即分块）。分了块跑的会更快。再按照右端点从小到大，左端点块编号相同按右端点从小到大。

### 为什么要这么排序呢？

如果不是按照分块排序，那么一种直观的办法是按照左端点排序，再按照右端点排序。但是这样的表现不好。特别是面对精心设计的数据，这样方法表现得很差。

举个栗子，有6个询问如下：(1, 100), (2, 2), (3, 99), (4, 4), (5, 102), (6, 7)。

这个数据已经按照左端点排序了。用上述方法处理时，左端点会移动6次，右端点会移动移动98+97+95+98+95=483次。

其实我们稍微改变一下询问处理的顺序就能做得更好：(2, 2), (4, 4), (6, 7), (5, 102), (3, 99), (1, 100)。

左端点移动次数为2+2+1+2+2=9次，比原来稍多。右端点移动次数为2+3+95+3+1=104，右端点的移动次数大大降低了。
#### 上面的过程启发我们：我们不应该严格按照升序排序，而是根据需要灵活一点的排序方法

#### 时间复杂度证明

关于时间复杂度的证明：给一个角度，其实从不同的角度看，证法很多： 对于左端点在一个块中时，右端点最坏情况是从尽量左到尽量右，所以右端点跳时间复杂度O(n),左端点一共可以在n^0.5个块中，所以总时间复杂度O(n*n^0.5) = (n^1.5)。

#### 这样，不断地移动端点指针+精妙的排序，就是普通莫队的思想啦~

------------
## 2ec.Code

#### 1.对于每组查询的记录和排序：

l，r为左右区间编号，p是第几组查询的编号（记录下来为了排序后不打乱顺序还按照原查询的顺序输出），bl是分块数。
```
struct query{
    int l, r, p;
}e[maxn];

bool cmp(query a, query b)
{
    return (a.l/bl) == (b.l/bl) ? a.r < b.r : a.l < b.l;
}

```
#### 2.处理和初始变量：

answer就是所求答案， bl是分块数量， a[]是原序列， ans[]是记录原查询序列下的答案， cnt[]是记录对于每个数i， cnt[i]表示i出现过的次数， curL和curR不再解释， nm看题意要求。 add和del每个题有不同的写法。
```
int answer, a[maxn], m, n, bl, ans[maxn], cnt[maxn], k, curL = 1, curR = 0;
void add(int pos)//添加 
{
    //do sth...
}
void del(int pos)//去除 
{
    //do sth...
}
//一般写法都是边处理 边根据处理求答案。cnt[a[pos]]就是在pos位置上原序列a出现的次数。
```
#### 3.主体部分及输出：

预处理查询编号，用四个while移动指针顺便处理。

在这里着重说下四个while

我们设想有一条数轴:
![](https://cdn.luogu.com.cn/upload/pic/19570.png)

当curL < L 时，我们当前curL是已经处理好的了。所以del时先去除当前curL再++

当curL > L 时，我们当前curL是已经处理好的了。所以 add  时先 -- 再加上改后的curL

当curR > R 时，我们当前curR是已经处理好的了。所以del时先去除当前curR再 --

当curR < R 时，我们当前curR是已经处理好的了。所以 add  时先++再加上改后的curR
```
n = read(); m = read(); k = read();
    bl = sqrt(n);

    for(int i = 1; i <= n; i++)
    a[i] = read();
    
    for(int i = 1; i <= m; i++)
    {
        e[i].l = read(); e[i].r = read();
        e[i].p = i;
    }
    
    sort(e+1,e+1+m,cmp);
    
    for(int i = 1; i <= m; i++)
    {
        int L = e[i].l, R = e[i].r;
        while(curL < L)
        del(curL++);  
        while(curL > L)
        add(--curL);
        while(curR > R)
        del(curR--);
        while(curR < R)
        add(++curR);
        ans[e[i].p] = answer;
    }
    for(int i = 1; i <= m; i++)
    printf("%d\n",ans[i]);
    return 0;
```
-------
## 3th.关于这题题解
我的想法还是蛮暴力的，对于出现过的数直接记录下来，answer记录出现了多少个不同的数，如果answer等于现在的R-L+1，那么说明出现的数与L到R相同。
```
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#define ri register 
using namespace std;
const int maxn = 100010;
inline int read()
{
    int k=0;
    char c;
    c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c)){k=(k<<3)+(k<<1)+c-'0';c=getchar();}
    return k;
}
int n, m, bl, answer = 0, curL, curR, cnt[maxn], a[maxn];
bool ans[maxn];
struct Query{
    int l, r, p;
}q[maxn];
bool cmp(const Query &a, const Query &b)
{
    return (a.l/bl) == (b.l/bl) ? a.r < b.r : a.l < b.l;
}
void add(int pos)
{
    if((++cnt[a[pos]]) == 1) ++answer;
}
void del(int pos)
{
    if((--cnt[a[pos]]) == 0) --answer;
}
int main()
{
    n = read();
    m = read();
    bl = sqrt(n);
    for(ri int i = 1; i <= n; i++)
    a[i] = read();

    for(ri int i = 1; i <= m; i++)
    {
        q[i].l = read();
        q[i].r = read();
        q[i].p = i;
    }
    
    sort(q+1,q+1+m,cmp);
    
    for(ri int i = 1; i <= m; i++)
    {
        int L = q[i].l, R = q[i].r;
        while(curL < L) del(curL++);
        while(curL > L) add(--curL);
        while(curR < R) add(++curR);
        while(curR > R) del(curR--);
        if(answer == (R-L+1))
        ans[q[i].p] = 1;
    }
    for(ri int i = 1; i <= m; i++)
    {
        if(ans[i] == 1)
        printf("Yes\n");
        else
        printf("No\n");
    }
    return 0;
}
```
----------
如果对于莫队算法有什么疑问或者对我的题解有什么建议欢迎和我讨论，本人会尽力解答和虚心接受意见的。

[更好的阅读体验](http://www.cnblogs.com/MisakaAzusa/p/8684319.html)

QQ：935145183 or 3203600070

---

## 作者：zjp_shadow (赞：150)

这题其实可以做到$O(n)$预处理，每次$O(1)$查询

根本没有那么复杂……（似乎原来的题不同）


- 问题抽象为在一个序列中是否存在一个数，它的上一个和它相等数是否在序列中。

- 我们就可以用一个$Left$数组记录它上个和它相等的数出现的位置

- 所以我们就可以记录到$i$之前所有$Left$的最大值（$MaxLeft$），因为这个最有可能改变答案。（贡献最大）

- 每次询问$l$到$r$是否存在相同的。我们只要询问$MaxLeft[r]$是否$<$ $l$。如果是，那么答案就是$Yes$否则就是$No$。

- 对于$\le l$的$Left$对答案根本不会产生贡献

附代码：

```cpp
#include <bits/stdc++.h>
#define For(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)
#define Fordown(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)
#define Set(a, v) memset(a, v, sizeof(a))
using namespace std;

bool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}
bool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}

inline int read() {
    int x = 0, fh = 1; char ch = getchar();
    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;
    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');
    return x * fh;
}

const int N = 1e5 + 1e2;
int n, q;
int a[N], Left[N];
int last[N], Max_Left[N];
void input() {
    n = read(); q = read();
    For (i, 1, n)
        a[i] = read();

    For (i, 1, n) {
        Left[i] = last[a[i]];
        last[a[i]] = i;
        chkmax(Max_Left[i], Left[i]);
        chkmax(Max_Left[i], Max_Left[i-1]);
    }
}

void solve() {
    while (q--) {
        int l = read(), r = read();
        puts(Max_Left[r] >= l ? "No" : "Yes");
    }
}

int main () {
    input();
    solve();
    return 0;
}
```
> PS:实测60ms,好像是最快的

---

## 作者：Dark_lightrq (赞：72)

## 这是个O（n）的算法
## **这是篇对萌新友好的题解**
## 大佬直接跳过吧

------------
### 思路

这是一道操作数列的题

易发现下述题目具有的性质
1. 发现这个数列是没有任何修改的
1. 发现这个区间可行性是单调的（即扩展区间答案只可能由Yes变为No，并且一旦No就不可能Yes了）
1. 数列数值是很小的

一些本题解不需要的性质（在其他题里可能很有用的）

- 可以离线

- 数值比N小


### 分析
1. 没有修改说明**可以预处理答案**
1. 单调说明**可以从上个已经求出答案的区间拓展到下一个区间**（其实单调是个好用的性质，最常见的是二分）
1. 数值小**说明可以用桶直接存数值**

### 开切
关键是怎么预处理出答案

因为单调，我们可以确定：

对一个被作为右端点的位置，它的左端点 满足答案为Yes的位置 是有最小值的，在最小值右边都是Yes，左边都是No（二分？不需要）

可以用个数组lm[i]表示以第i个数为右端点时左端点的最小值，显然只要知道这个我们就可以回答所有询问，如果询问的l更小那就是No，否则为Yes


接下来求解所有位置的lm

从左往右求解（拓展区间一般是这样的，如果不行就换个方式）

假设当前处理到了第i个元素

这时我们知道lm[i-1]到i-1是合法的，如果当前位置的元素在之前的lm[i-1]到i-1都没出现过，那直接拓展lm[i]=lm[i-1]，否则就是第i个元素的值上次出现的位置+1

这时就求解完毕了

参考代码（实现略有不同）~~炒鸡短~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int a[N],lm[N],n,q;
int main(){
	scanf("%d%d",&n,&q);
	int k,l,r;
	for(int i=1;i<=n;i++){
		scanf("%d",&k);
		lm[i]=max(lm[i-1],a[k]+1);
		a[k]=i;
	}
	for(int i=1;i<=q;i++){
		scanf("%d%d",&l,&r);
		if(lm[r]<=l)printf("Yes\n");
		else printf("No\n");
	}
	return 0;
} 
```



---

## 作者：yagyagyag (赞：34)

~~巨佬们的代码都好长啊，有个跟我一样长度的，还是双重循环~~

这道题我的代码很短(仅24行)，但我认为它的思维难度较大

首先我们定义一个数组last[x]表示x这个数最近出现的位置，然后定义st[i]表示以第i个数结尾的每个数不同的序列的起始位置，举个例子，1 2 3 4 2  则第5个数，st[5]=3因为从第三个数开始到第五个数组成的序列是没有重复数字的。

那么st[i]怎么求呢，last[x]就派上用场啦！

动态规划思想，假设st[i-1]已经算好了,那么对于第i个数，我们有两种选择

- 选择第i个数连过去。那么st[i]=st[i-1]，很容易理解，因为把第i个数接到第i-1个数后面，它们的起始位置当然是一样的

- 不用管前面的数。因为要求数列不能重复，而last[x]记录的就是x最近出现的位置，所以从last[x]+1开始到i，一定不会有与x重复的数字，所以st[i]=last[x]+1

所以综上：st[i]=max(st[i-1],last[x]+1)

这样一来，万事俱备，只欠判断，对于输入的l，r只要判断st[r]<=l如果是，那就输出Yes,否则就输出No

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5,LogN=20;
int st[MAXN],last[MAXN];
int n,m;
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		st[i]=max(st[i-1],last[x]+1);
		last[x]=i;
	}
	for (int i=1;i<=m;i++){
		int l,r;
		scanf("%d%d",&l,&r);
		if (st[r]<=l)
			cout<<"Yes\n";
		else
			cout<<"No\n";
	}
	return 0;
}
```

完成这道题的童鞋，可以做下这道题，但这里还要结合ST算法和二分思想[与众不同  戳我](http://ybt.ssoier.cn:8088/problem_show.php?pid=1543)

---

## 作者：aserrrre (赞：13)

# 纯暴力，是不是比那些莫队大佬好很多。这是唯一的纯暴力题解，不能说我是重复题解了吧。
~~暴力是OIer进步的阶梯~~

这篇题解针对的是中下层OI选手，省队大佬不宜观看。当然我们不急着讲题目先看看别的，

目的是讲一下如何暴力AC。

## 下面大佬手把手教大家如何卡常数。
一，数据结构方面，数组的查询时间是O(1)，~~这个大家都知道。~~但是很毒瘤的是int比bool还快。指针可以代替数组，但是容易作死。stack和queue是很慢的,可以用数组模拟。

二，输入输出方面加上快速读入优化，轻松加速,当然可以加上位运算优化！输出也是可以快速优化的，在下面，这里不再展开。

三，思维方面，可以不用朴素算法改用线段树进行查询修改，或者是用前缀和优化，预先处理答案输出，还有矩阵加速for循坏~~哦扯远了。~~

四，这是重点~~细节~~方面，吸取各位巨神的精华：函数前面加上inline使函数更快，在常用的变量前面加上register寄存器优化，在寄存器内部其运算效率可以大为加速。但是不要把数组加上这个，register会炸裂。memset居然比for循环慢。还有一个毒瘤的事情大家大多不知道，i++比++i慢，真的！如果快速排序觉得慢，可以用稳定的快速排序~~话说快排不都是不稳定的吗~~

## 接下来献上位运算详解一篇大佬请跳过
先感谢李煜东老师的辛勤劳动，我是借鉴他的成果。
位运算共有4种，它们是与或非和异或~~废话~~

十进制的数不能参与运算，在计算机中是二进制，如果直接对其运算就比十进制块很多。所以说位运算最快，然后是加减，接着是乘除，最慢的是取模，~~慢的一匹~~大家先体验一把位运算，打开手机计算器的科学计数法，然后调成二进制。。。

好，与指的是按照二进制位的两个数字，两位都是1就是1，否则为0，或就是按照二进制位两位有一位是1就为1，两个数位都是0才是0，非就是把每一位都取反，异或是两位相同为0，不同为1。需要注意的是两个数比较时不足位按0计算，直到两个数位数相同。

左移就是直接把每一位都向左移，右移也是这样的。~~随意~~
来举个例子5等于二进制下的101（这个肯定会啊）,左移两位就是10100（低位是0补足），自然是十进制下的20啦！

左移就是乘二右移就是除二，哦我们好像可以用这个优化乘二啊！还有更神奇的事情！n<<1就是乘二，n<<3就是乘8啊，那么加起来不就是乘十了吗？~~这真是激动人心的发现~~
当然同理有的减法也可以用^来优化，或可以用来判断奇数：比如11的二进制是1011，(1011&1)=(1011&0001)=(0001)返回了1！
哇太强了，以后可以用(x&1)判断是不是奇数了,如果用x%2的后果就是x不停的减二。。。一直减到剩下1或者0。

顺便讲一下lowbit运算，这个可吊了。lowbit的定义是整数在二进制下最低位的1及其后边的所有0，lowbit(n)=n&(-n)
这波废话其实意思是说找到最右的1构成的数，比如lowbit(14)=1110,那么lowbit(n)就是2啊！这个详见树状数组。

状态压缩就是将一个长度为m的bool数组换成一个用二进制数存贮的方法。下列是状态压缩的常用表达式：
1,取出n的第k位  (n>>k)&1  就是把n删掉几位或1，简单吧

2，取出n的后k位  n&((1<<k)-1)  这个我也不怎么会

3.把n的第k位赋1  n|(1<<k)  就是制造一个数是2的k次方才能和n进行运算啊，同理有 n^(1<<k) 和 n&(~(1<<k))这个是第k位赋0

接下来是位运算实战！！！大佬勿喷

1，位运算加速快速幂
```
#define int long long
inline int quickpower(int a,int b,int p){
	register int ans=1;
	for (;b;b>>=1){
    	if (b&1)	ans=ans*a%p;
        a=a*a%p;
    }return ans;
}
```
2，最短曼哈顿路径
```
int f[1<<20][20];
inline int hamilton(int n,int weight[20][20]){
	memset(f,0x3fsizeof(f));
    f[1][0]=0;
    for (register int i=1;i<=1<<n;++i)
    for (register int j=0;j<n;++j)
    if (i<<j&1)
    for (register int k=0;k<n;k++)
    if ((i^1<<j)>>k&1)
    f[i][j]=min(f[i][j],f[i^1<<j][k]+weight[k][j]);
    return f[(1<<n)-1][n-1];
}
```
我们到了主题，P3901
这道题一开始把我看得一脸懵逼，最后看懂了，原来是要求出是不是每个数字都不同啊！这是我的题解，自然还能优化，不再细说了。
```
#include<bits/stdc++.h>
using namespace std;
int a[100001],n,q;
bool b[100001];
inline int read(){
	register int x=0;
	register char c=getchar();
	while (!isdigit(c))	c=getchar();
	while (isdigit(c))
    x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
int main(){register bool flag=false;
	n=read(),q=read();
	for (register int i=1;i<=n;i++)
		a[i]=read();
	for (register int i=1,l,r;i<=q;i++){
		l=read(),r=read(),flag=false;
		memset(b,false,sizeof(b));
		for (register int j=l;j<=r;j++)
			if (b[a[j]]){
				flag=true,puts("No");
				break;
			}
			else	b[a[j]]=1;
		if (!flag)	puts("Yes");
	}
	return 0;
}```
望大家给我点赞，谢谢

~~管理员求您审核通过~~

---

## 作者：Lance1ot (赞：8)

这个题我们可以使用树状数组做

啥？ 树状数组？ 那个不是维护前缀和的东西吗？

各位看官，让我慢慢道来。

----------------

首先我们可以想到，对于一个询问$ [l,r] $，只有$[1,r]$中的数可能对这个询问有影响。

这就启示我们可以按照询问的右端点进行一波升序排序。

不过这和树状数组有什么关系呢？

对于同一个数$x$，假设他在$[1,r]$ 出现了若干次。

对于我们的询问$[l,r]$来说，只有最靠近$r$的$x$才最有可能影响到右端点为$r$的询问。

所以，我们就只用记录最靠近$r$的$x$的位置就行了。

-------------
那么我们怎么查询一个区间中不同的个数呢？

上文说道，我们只用记录最靠近当前右端点的每个数的位置了。

我们用一个树状数组维护一下。

树状数组中每一个位置就是输入中每一个数的位置。

对于一个数$x$，他靠近我们当前遍历的右端点的最近一个位置，所对应的树状数组中的数值为1。不是最近的统统为0。

这样的话。对于一个询问$[l,r]$，我们计算一下树状数组中$[l,r]$中的和。如果和是 $(r-l+1)$的话，就说$[l,r]$中所有数都是最靠近$r$的,如果不是的话.则说明有重复出现的。

-------------------
~~真·凭直觉做题（@某月月赛T1）滑稽。我才不会告诉你我是太蒟蒻了导致什么都不会然后来刷黄题的吗？~~

---------------

类似的题目[SDOI2009]HH的项链](https://www.luogu.org/problemnew/show/P1972)

~~这个题被某姓毒名瘤字cz的人加强过（暗地%一%），普通莫队会被卡~~
```cpp
//Lance1ot
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct node//树状数组
{
	int data[101000];
	int num;
	void updata(int pos,int value)
	{
		while(pos<=num&&pos)
		{
			data[pos]+=value;
			pos+=(pos&(-pos));
		}
		return ;
	}
	int sum(int pos)
	{
		int res=0;
		while(pos)
		{
			res+=data[pos];
			pos-=(pos&(-pos));
		}
		return res;
	}
	int check(int l,int r)
	{
		return sum(r)-sum(l-1);
	}
};
node bit;
struct Query
{
	int l;
	int r;
	int num;
}q[101000];//询问
bool compare(const Query &a,const Query &b)
{
	return a.r<b.r;
}
int data[101000];//原数组
int ans[101000];
int last[101000];//最近一次出现的位置
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	bit.num=n;
	for(int i=1;i<=n;i++)
		scanf("%d",&data[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].num=i;//离线处理，是第几个询问。
	}
	sort(q+1,q+1+m,compare);//排序
	int Q=1;
	for(int i=1;i<=n;i++)
	{
		bit.updata(last[data[i]],-1);//撤销上一个记录
		bit.updata(i,1);//更新
		last[data[i]]=i;//保存
		while(q[Q].r==i&&Q<=m)//判断当前右端点是否和某个重合
		{
			if(bit.check(q[Q].l,q[Q].r)==(q[Q].r-q[Q].l+1))//因为是离线算法（fa♂），所以要保存答案
				ans[q[Q].num]=1;
			else
				ans[q[Q].num]=0;
			Q+=1;//写成while保险
		}
	}
	for(int i=1;i<=m;i++)
	{
		if(ans[i]==1)
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}
```
速度还算可以吧。

---

## 作者：LlLlCc (赞：7)

一道区间询问的~~水~~题，题意十分简洁。题目转换一下就是对每个Li到Ri的区间都便利一遍，看看区间内有多少个不同的数，数量是否等于R-L+1。

# 1.暴力

  对于这道题来说，暴力想法还是很容易想到的，每个区间都便利一遍就行了，但复杂度肯定吃不消的，亲测：50 （加氧气：60）
  
代码： （大家应该都会）

```
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;
int n,Q,L,R,tot,a[maxn];
bool vis[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	n=read(),Q=read();
	for (int i=1;i<=n;i++) a[i]=read();
	for (int i=1;i<=Q;i++){
		L=read(),R=read();tot=0;
		memset(vis,0,sizeof vis);
		for (int j=L;j<=R;j++) if (!vis[a[j]]) vis[a[j]]=1,tot++;
	    if (tot^R-L+1) printf("No\n");
	    else printf("Yes\n");
	}
	return 0;
}
```
------------
# 2.莫队 （优雅的暴力）

认真思考后，我们肯定有一个~~玄学~~的想法：

我们可以不用每次都重新便利每一个区间，可以把它们关联起来（也就是说这次的结果可以在上一次结果的基础上修改）。

这个操作该怎么实现呢？

我们用两个指针L和R来表示我们当前已知这个区间有多少种不同的数tot。当我们的L和R移动到问题中的Li和Ri时，tot就是我们想要的答案。

所以我们只有移动这两个指针L和R就能实现区间询问了，对于每个询问，L和R就往问题中的Li和Ri移动，新加一个数就判断是否出现过，出现了tot+1。

不会莫队的看着里（含莫队部分优化）：[莫队入门及优化](https://www.cnblogs.com/WAMonster/p/10118934.html)

代码：

```
#include<bits/stdc++.h>
#define maxn 1000005
using namespace std;
int n,m,a[maxn],L,R,x,y,z,ans[maxn],tot,num,now,s[maxn],vis[maxn],si;
struct lc{
	int L,R,id;
	bool operator <(const lc b)const{return s[L]==s[b.L]?R<b.R:s[L]<s[b.L];}
}Q[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void Del(int x){vis[a[x]]--;if (!vis[a[x]]) now--;}
inline void add(int x){vis[a[x]]++;if (vis[a[x]]==1) now++;}
int main(){
	n=read(),m=read();
	for (int i=1;i<=n;i++) a[i]=read();
	for (int i=1;i<=m;i++) Q[i].L=read(),Q[i].R=read(),Q[i].id=i;
	si=sqrt(n);
	num=ceil((double)n/si);
	for (int i=1;i<=num;i++)
	for (int j=(i-1)*si+1;j<=i*si;j++) s[j]=i;
	sort(Q+1,Q+m+1);
	for (int i=1;i<=m;i++){
		while(L<Q[i].L) Del(L++);
        while(L>Q[i].L) add(--L);
        while(R<Q[i].R) add(++R);
        while(R>Q[i].R) Del(R--);
        if (now==Q[i].R-Q[i].L+1) ans[Q[i].id]=1;
	}
	for (int i=1;i<=m;i++){
	if (!ans[i]) printf("No\n");
	else printf("Yes\n");
}
	return 0;
}
```


------------
# 3.玄学暴力（比莫队还快）

我们再思考一下，题目可以转换为对于Li到Ri的区间的每一个数，和他一样的数的位置是否>=Li。

有了这个想法接下来就很简单了。lst[i]表示上一个和a[i]一样的数所处的位置，
我们只要o(n)预处理一遍lst数组，对于每个i再记录一下1到i最大的那个lst[i]就能做到o(n)预处理，o(1)询问了。

代码：
```
#include<bits/stdc++.h>
#define maxn 1000005
using namespace std;
int lst[maxn],x,lnk[maxn],n,Max[maxn],Mx,Q,L,R,a[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	n=read(),Q=read();
	for (int i=1;i<=n;i++){
		x=read();lst[i]=lnk[x];lnk[x]=i; 
		Mx=max(Mx,lst[i]),Max[i]=Mx;
	}
	for (int i=1;i<=Q;i++){
		L=read(),R=read();
		if (Max[R]>=L) printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```


---

## 作者：NaVi_Awson (赞：7)

其实十万的数据$O(n^2)$的暴力应该是过不了的。

提供一种做法：莫队。

加个标记数组维护该数在区间中出现了几次，再加个变量统计有几个数是重复的。




```cpp
#include<map>
#include<set>
#include<ctime>
#include<cmath>
#include<queue>
#include<stack>
#include<cstdio>
#include<string>
#include<vector>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define LL long long
#define RE register
#define IL inline
using namespace std;
const int N=1e5;
int n,q,lim;
int cnt[N+5],a[N+5];
struct tt
{
    int l,r,id;
}query[N+5];
bool keep[N+5];
IL bool comp(const tt &a,const tt &b) {return a.l/lim==b.l/lim ? a.r<b.r : a.l<b.l;}
int main()
{
    scanf("%d%d",&n,&q);
    lim=sqrt(n);
    for (RE int i=1;i<=n;i++) scanf("%d",&a[i]);
    for (RE int i=1;i<=q;i++) scanf("%d%d",&query[i].l,&query[i].r),query[i].id=i;
    sort(query+1,query+1+q,comp);
    int curl=1,curr=0,ans=0,l,r;
    for (RE int i=1;i<=q;i++)
    {
        l=query[i].l,r=query[i].r;
        while (curl<l) cnt[a[curl]]--,ans-=(cnt[a[curl++]]==1);
        while (curl>l) cnt[a[--curl]]++,ans+=(cnt[a[curl]]==2);
        while (curr<r) cnt[a[++curr]]++,ans+=(cnt[a[curr]]==2);
        while (curr>r) cnt[a[curr]]--,ans-=(cnt[a[curr--]]==1);
        if (!ans) keep[query[i].id]=1;
    }
    for (RE int i=1;i<=q;i++) printf(keep[i] ? "Yes\n":"No\n");
    return 0;
}
```

---

## 作者：基辅迪就是 (赞：5)

## 其实这个题是可以用一个二维数组来优化的
### 而且似乎还比线段树的做法要快.....
————————————————————————————————————————————————
对于每次我们给出的数列，我们用一个结构体来存储它每一个元素所在的位置与值

```cpp
struct a{
    int num;//元素的位置
	int ll;//元素的值
}point[100009];
```
我们再对point进行排序，因为我们存储了point之前所在的位置，那么，在排序之后，我们仍旧可以找到point所在的位置。（注意自编比较结构体排序函数时，应以ll为第一关键字，num为第二关键字升序排序）。
```cpp
int comp(const a & x,const a & y){
	if(x.ll==y.ll)
	return x.num<y.num;
	return x.ll<y.ll;
}
```
并且，在排序之后，相同的元素会被排序到一起，之后，我们再把相同元素的序号存储进same。如果point[i].ll==point[i+1].ll的话，就把point[i].num存进same的第1列，把point[i+1]存进same的第二列。

最后在询问的时候，只需要遍历same数组并判断询问的左端点l——右端点r是否覆盖了same[i][0]——same[i][1]这个区间即可。如果覆盖了，则必有相同元素；没有覆盖，则说明没有相同元素。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std; 
int n;
int q;
struct a{
    int num;
	int ll;	 
}point[100009];
int comp(const a & x,const a & y){
	if(x.ll==y.ll)
	return x.num<y.num;
	return x.ll<y.ll;
}
int same[50000][2];//精华
int main() {
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
	    scanf("%d",&point[i].ll);
		point[i].num=i;	 
	}
	sort(point+1,point+n+1,comp);
	int w=1;
	for(int i=1;i<n;i++){
		if(point[i].ll==point[i+1].ll){
			same[w][0]=point[i].num;
			same[w][1]=point[i+1].num;
			w++;//从1开始存
		}
	}
	int l,r;//查询的左端点与右端点
	for(int i=1;i<=q;i++){
		scanf("%d%d",&l,&r);
		bool flag=true;
		for(int j=1;j<=w;j++){
			if(l<=same[j][0]&&r>=same[j][1]){//覆盖了same中的任意                 printf("No\n");         //一个区间则说明有相同元素
				flag=false;
				break;
			}
		}
		if(flag==true)
			printf("Yes\n");//反之则没有相同元素
	}
	return 0;
}
```
实测 237ms通过，还是比较快的。

---

## 作者：shuiyuhan (赞：5)

这题居然没有p的莫队题解哦！那我来水一发呗

--------------------------------分割线-------------------------

题目描述：求[l,r]中数字是否互不相同

题目思路：发现题目似乎没说强制在线哦，那就可以离线了哎
于是就可以用
莫队
----
来水掉这道题啊

这道题是最基础不带修的序列莫队，适合莫队初学者

有关莫队可以参见我这道题的题解:

小b的询问
https://www.luogu.org/problemnew/show/P2709

代码：
```pascal
var
  n,k,m,l,r,j,i,p:longint;
  ans:int64;
  a,x,y,c,b,f:array[0..500005] of longint;
procedure sort(l,r:longint);
      var
         i,j,xx,yy,yyy:longint;
      begin
         i:=l;
         j:=r;
         xx:=x[(l+r) div 2];
         yy:=y[(l+r) div 2];//多关键字排序
         repeat
           if i div p=j div p then//判断i，j是否在同一块内
           begin
           while (x[i]<xx) do
            inc(i);
           while (xx<x[j]) do
            dec(j);
           if not(i>j) then//别忘记交换3个而不是1个数组
             begin
                yyy:=x[i];
                x[i]:=x[j];
                x[j]:=yyy;
                yyy:=y[i];
                y[i]:=y[j];
                y[j]:=yyy;
                yyy:=c[i];
                c[i]:=c[j];
                c[j]:=yyy;
                inc(i);
                j:=j-1;
             end;
           end else//这部分作用同上
           begin
             while (y[i]<yy) do
            inc(i);
           while (yy<y[j]) do
            dec(j);
           if not(i>j) then
             begin
                yyy:=x[i];
                x[i]:=x[j];
                x[j]:=yyy;
                yyy:=y[i];
                y[i]:=y[j];
                y[j]:=yyy;
                yyy:=c[i];
                c[i]:=c[j];
                c[j]:=yyy;
                inc(i);
                j:=j-1;
             end;
           end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
  readln(n,m);
  p:=trunc(sqrt(n));//把序列分成sqrt(n)块
  for i:=1 to n do read(a[i]);
  for i:=1 to m do
  begin
    readln(x[i],y[i]);
    c[i]:=i;//莫队作为离线算法，当然要保存每个询问啦
  end;
  sort(1,m);
  l:=1;
  r:=0;
  ans:=0;
  fillchar(b,sizeof(b),0);
  for i:=1 to m do
  begin//莫队基本思想(本人喜欢while)
    while l>x[i] do begin dec(l); inc(b[a[l]]); if b[a[l]]=1 then inc(ans); end;
    while r<y[i] do begin inc(r); inc(b[a[r]]); if b[a[r]]=1 then inc(ans); end;
    while l<x[i] do begin dec(b[a[l]]); if b[a[l]]=0 then dec(ans); inc(l); end;
    while r>y[i] do begin dec(b[a[r]]); if b[a[r]]=0 then dec(ans); dec(r); end;
    if ans=r-l+1 then f[c[i]]:=1  else f[c[i]]:=0;//用f数组记录读进来时第1-n个答案
  end;
  for i:=1 to m do if f[i]=1 then writeln('Yes') else writeln('No');
end.
```

最后再给大家推荐几道好题：p2709，p1494







---

## 作者：Manjusaka丶梦寒 (赞：3)

博客了解一下[](https://www.cnblogs.com/rmy020718/p/9439657.html)https://www.cnblogs.com/rmy020718/p/9439657.html

了解过莫队的人应该都清楚，莫队是一个优化的暴力，可以在相对暴力比较优的时间中，求出一段序列内的某些性质(例:数字的种类)

那么这道题就明显是一道模板题了，在l,r(左右段点)移动的过程中，记录数字的种类，若种类数等于R-L+1,那么表明没有重复

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define N int(1e5+2)
#define M int(1e5+2)
using namespace std;
struct ahah{
    int L,R,p,f;
}ask[N];
int answer,n,q,a[N],cnt[N],ans[N],k;
bool cmp(ahah a,ahah b){ return a.p<b.p; }
bool comp(ahah a,ahah b){ return a.L/k==b.L/k?a.R<b.R:a.L<b.L; }
void remove(int pos){ if(--cnt[a[pos]]==0)answer--; }
void add(int pos){ if(++cnt[a[pos]]==1)answer++; }
int main()
{
    scanf("%d%d",&n,&q);
    k=sqrt(n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=q;i++)scanf("%d%d",&ask[i].L,&ask[i].R),ask[i].p=i;
    sort(ask+1,ask+1+q,comp);
    int curl=0,curr=0;
    for(int i=1;i<=q;i++)
    {
        int L=ask[i].L,R=ask[i].R;
        while(curl<L)remove(curl++);
        while(curl>L)add(--curl);
        while(curr<R)add(++curr);
        while(curr>R)remove(curr--);
        answer==R-L+1?ans[ask[i].p]=1:ans[ask[i].p]=0;
    }
    for(int i=1;i<=q;i++)ans[i]==1?printf("Yes\n"):printf("No\n");
}
```

---

## 作者：ferrum_cccp (赞：3)

这题没人用st表吗？我发一个st表的题解。
预处理出每一个数在数列中出现的上一个位置（特别的，第一次出现的数，上一个位置为0）。
那么，一段区间\[L,R\]的数不重复，当且近当每一个数出现的上一个位置小于L，即数出现的上一个位置的**最大值**小于L。
于是我们可以用st表处理出区间最大值。
```
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,q;
int aa[100005];
int ton[100005];
int st[20][100005];
int main(){
	scanf("%d%d",&n,&q);
	rep(i,1,n)scanf("%d",aa+i);
	rep(i,1,n){
		st[0][i]=ton[aa[i]];
		ton[aa[i]]=i;
	}
	rep(i,1,19)rep(j,1,(n-(1<<i)+1))
		st[i][j]=max(st[i-1][j],st[i-1][j+(1<<i-1)]);
	rep(i,0,19){
	//	rep(j,1,(n-(1<<i)+1))cout<<st[i][j]<<" ";;cout<<endl;
	}
	rep(i,1,q){
		int l,r;scanf("%d%d",&l,&r);
		int d=31-__builtin_clz(r-l+1);
		int ans=max(st[d][l],st[d][r-(1<<d)+1]);
		if(ans>=l)printf("No\n");else printf("Yes\n");
	}
	return 0;
}

```

---

## 作者：LCGUO (赞：2)

这道题没有强制在线，所以莫队是可做的。

---

题目给出 $Q$ 组询问，每组询问区间 $[l,r]$ 之间的数是否各不相同。

可以将题目转化为在区间 $[l,r]$ 中，恰好出现了 $r-l+1$ 个数。

用 $cnt_i$ 表示 $i$ 出现的次数，$num$ 表示有多少种不同的数字。

在移动左右端点的时候，如果 $cnt_i=0$ 证明该区间没有数字 $i$ 出现，$num$ 就可以减一。

最后只要比较 $num$ 和 $r-l+1$ 是否相等。相等即代表每个数各不相同，反之则反。

---

插一个和题目没有太大关系的话，在排序时按照块的奇偶性排序可以快很多，但是原因玄学 ~~我也不知道为什么~~。

---

代码如下：

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
inline int read(){
    int s=0,f=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}
    while(c>='0'&&c<='9') s=(s<<1)+(s<<3)+(c^48),c=getchar();
    return f?s:-s;
}
int n,Q,k[100010],cnt[100010],num,ks;
int a[100010],ans[100010];
struct qus{
    int l,r,id;
    friend bool operator <(qus a,qus b){
        return k[a.l]^k[b.l]?k[a.l]<k[b.l]:(k[a.l]&1?a.r<b.r:a.r>b.r);
    }
}q[100010];
void Add(int pos){
    if(!cnt[a[pos]]) ++num;
    ++cnt[a[pos]];
}
void Del(int pos){
    --cnt[a[pos]];
    if(!cnt[a[pos]]) --num;
}
int main(){
    n=read(); Q=read(); ks=sqrt(n);
    for(rint i=1;i<=n;++i) a[i]=read();
    for(rint i=1;i<=n;++i) k[i]=i/ks+1;
    for(rint i=1;i<=Q;++i){
        q[i].l=read();
        q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+1+Q);
    int L=1,R=0;
    for(rint i=1;i<=Q;++i){
        while(q[i].l<L) Add(--L);
        while(q[i].l>L) Del(L++);
        while(q[i].r<R) Del(R--);
        while(q[i].r>R) Add(++R);
        if(num==q[i].r-q[i].l+1) ans[q[i].id]=1;
    }
    for(rint i=1;i<=Q;++i){
        if(ans[i]) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

码风很丑，见谅![QVJIZ6DSFAY9Y0PP@Q_2_8R.gif](https://i.loli.net/2020/04/05/2oPIfqNYSTHRBVk.gif)

---

## 作者：一扶苏一 (赞：2)

##### 重新提交一下，并不存在做法重复，这里统计答案用的是对多个质数取模的方法qwq

---

## Solution

看到这题发现可以用莫队做。然鹅统计区间出现次数平方的题写腻了，而开桶和位向量的做法又很麻烦，于是我就YY了一个~~更加麻烦的~~做法。

发现我们可以在莫队维护区间信息的时候维护区间中所有元素出现次数之积。因为乘1等价于没有乘，我们对于没有出现的元素也乘1。这个值在指针移动时是支持修改的：只要在去掉该位置贡献的时候除掉当前的出现次数，然后将这个位置的出现次数$-1$，再乘回去即可。增加一个位置贡献的方法同理。当询问的区间出现次数积为$1$时，即为没有出现重复，否则为出现重复。

但是考虑这么做在极端数据，比如前$\frac{n}{2}$个数出现了$2$次，后$\frac{n}{2}$个数没有出现的时候，积是$2^{\frac{n}{2}}$次方，显然存不下。这时考虑[NOIP2014解方程](https://www.luogu.org/problemnew/show/P2312)，我们只需要对多个~~形如1\*\*\*\*\*\*7~~的大质数取模，当所有取模后的答案都为$1$是，我们认为积是$1$，否则积显然不是$1$。

于是先$O(n)$筛一下逆元再莫队就好了。

## Code

这个代码写的好丑啊……其实可以美化美化然而我懒得写了

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
#ifdef ONLINE_JUDGE
#define puts(o) \
puts("I am a cheater!")
#define freopen(a,b,c)
#endif
#define rg register
#define ci const int
#define cl const long long

typedef long long int ll;

template <typename T>
inline void qr(T &x) {
	rg char ch=getchar(),lst=' ';
	while((ch > '9') || (ch < '0')) lst=ch,ch=getchar();
	while((ch >= '0') && (ch <= '9')) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(lst == '-') x=-x;
}

namespace IO {
	char buf[120];
}

template <typename T>
inline void qw(T x,const char aft,const bool pt) {
	if(x < 0) {x=-x,putchar('-');}
	rg int top=0;
	do {IO::buf[++top]=x%10+'0';} while(x/=10);
	while(top) putchar(IO::buf[top--]);
	if(pt) putchar(aft);
}

const int maxn = 100010;
const int ccnt = 6;

int n,q;
int MU[maxn],belong[maxn],bk[maxn];
int inv[8][maxn];

struct Ask {
	int l,r,num;
	bool ans;
	inline bool operator<(const Ask &_others) const {
		if(belong[this->l] != belong[_others.l]) return this->l < _others.l;
		if(belong[this->l] & 1) return this->r < _others.r;
		else return this->r > _others.r;
	}
};
Ask ask[maxn];

inline bool cmp(const Ask &_a,const Ask &_b) {
	return _a.num < _b.num;
}

struct C {
	int mod;
	int ans;
	C(int _x=0) {mod=_x,ans=1;}
};
C CU[8];

void GetInv(ci,ci);

int main() {
	freopen("1.in","r",stdin);
	qr(n);qr(q);
	for(rg int i=1;i<=n;++i) qr(MU[i]);
	for(rg int i=1,sn=sqrt(n);i<=n;++i) belong[i]=i/sn;
	for(rg int i=1;i<=q;++i) {
		qr(ask[i].l);qr(ask[i].r);ask[i].num=i;
	}
	CU[1]=C(1000000007);CU[2]=C(1000000009);CU[3]=C(19260817);CU[4]=C(998244353);CU[5]=C(10000007);
	for(int i=1;i<ccnt;++i) GetInv(CU[i].mod,i);
	std::sort(ask+1,ask+1+q);
	int prel=ask[1].l,prer=ask[1].l-1;
#define jd(o) (bk[MU[o]] > 1)
	for(rg int i=1;i<=q;++i) {
		int l=ask[i].l,r=ask[i].r;
		while(prel < l) {
			if(jd(prel)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*inv[j][bk[MU[prel]]]%CU[j].mod;
			}
			--bk[MU[prel]];
			if(jd(prel)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*bk[MU[prel]]%CU[j].mod;
			}
			++prel;
		}
		while(prel > l) {
			--prel;
			if(jd(prel)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*inv[j][bk[MU[prel]]]%CU[j].mod;
			}
			++bk[MU[prel]];
			if(jd(prel)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*bk[MU[prel]]%CU[j].mod;
			}
		}
		while(prer < r) {
			++prer;
			if(jd(prer)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*inv[j][bk[MU[prer]]]%CU[j].mod;
			}
			++bk[MU[prer]];
			if((jd(prer))) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*bk[MU[prer]]%CU[j].mod;
			}
		}
		while(prer > r) {
			if(jd(prer)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*inv[j][bk[MU[prer]]]%CU[j].mod;
			}
			--bk[MU[prer]];
			if(jd(prer)) {
				for(rg int j=1;j<ccnt;++j) CU[j].ans=1ll*CU[j].ans*bk[MU[prer]]%CU[j].mod;
			}
			--prer;
		}
		bool _ans=true;
		for(rg int j=1;j<ccnt;++j) if(CU[j].ans != 1) {
			_ans=false;break;
		}
		ask[i].ans=_ans;
	}
#undef jd
	std::sort(ask+1,ask+1+q,cmp);
	for(rg int i=1;i<=q;++i) 
		if(ask[i].ans) puts("Yes");
		else puts("No");
	return 0;
}

void GetInv(ci mod,ci cur) {
	inv[cur][1]=1;
	for(rg int i=2;i<=n;++i) inv[cur][i]=1ll*(mod-mod/i)*inv[cur][mod%i]%mod;
}
```



## Summary

貌似这次没啥好summary的

---

## 作者：lfxxx (赞：1)

先把问题变成求区间内不同数数量是否等于区间长度。

考虑分块。

发现对于散块可以暴力查询，现在的问题是怎么快速查询连续的整块。

然后其实我们发现因为只要记录每个数是否出现，所以可以用 bitset 来压缩单个块内的信息。

但是查询的时候合并 $\sqrt n$ 个 bitset 不现实，所以考虑 **ST 表**。

显然，是否出现这个信息是可重复贡献的。

那现在发现就只需要在预处理时合并 $\sqrt n \log \sqrt n$ 个 bitset 以及在查询时每次合并一个 bitset 就可以了。

那么复杂度就是 $O(n \sqrt n \times \frac{\log \sqrt n}{w} + \frac{n \times q}{w})$。

卡卡常可以过。

虽然这个算法虽然在这个题目上时间很劣，但是可拓展性很强，比如可以用同样的方法解决两个区间中出现多少种不同的数的问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{
	const int SIZE=1<<21;
	static char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS=obuf,*oT=oS+SIZE-1;
    int qr;
    char qu[55],c;
    bool f;
	#define getchar() (IO::iS==IO::iT?(IO::iT=(IO::iS=IO::ibuf)+fread(IO::ibuf,1,IO::SIZE,stdin),(IO::iS==IO::iT?EOF:*IO::iS++)):*IO::iS++)
	#define putchar(x) *IO::oS++=x,IO::oS==IO::oT?flush():0
	#define flush() fwrite(IO::obuf,1,IO::oS-IO::obuf,stdout),IO::oS=IO::obuf
	#define puts(x) IO::Puts(x)
	template<typename T>
    inline void read(T&x){
    	for(f=1,c=getchar();c<48||c>57;c=getchar())f^=c=='-';
    	for(x=0;c<=57&&c>=48;c=getchar()) x=(x<<1)+(x<<3)+(c&15); 
    	x=f?x:-x;
    }
    template<typename T>
    inline void write(T x){
        if(!x) putchar(48); if(x<0) putchar('-'),x=-x;
        while(x) qu[++qr]=x%10^48,x/=10;
        while(qr) putchar(qu[qr--]);
    }
    inline void Puts(const char*s){
    	for(int i=0;s[i];i++)
			putchar(s[i]);
		putchar('\n');
	}
	struct Flusher_{~Flusher_(){flush();}}io_flusher_;
}
using IO::read;
using IO::write;
const int B = 318;
const int maxn = 1e5+13;
bitset<maxn> st[320][10];
int a[maxn],n,q;
inline void init(){
    for(int i=1;i<=n;i=-~i){
        st[(i-1)/B+1][0][a[i]]=1;
    }
    for(int j=1;j<=9;j=-~j)
        for(int i=1;i+(1<<j)-1<=318;i=-~i)
            st[i][j]=st[i][j-1]|st[i+(1<<(j-1))][j-1];
}
bitset<maxn> ans;
inline void query(int l,int r){
    int bl=(l-1)/B+1;
    int br=(r-1)/B+1;
    if(bl==br){
        for(int i=l;i<=r;i=-~i){
            ans[a[i]]=1;
        }
        return ;
    }
    if(br!=bl+1){
        int k=log2((br-1)-(bl+1)+1);
        ans|=(st[bl+1][k]|st[(br-1)-(1<<k)+1][k]);
    }
    for(int i=l;i<=bl*B;i=-~i){
        ans[a[i]]=1;
    }
    for(int i=r;i>=(br-1)*B+1;--i){
        ans[a[i]]=1;
    }
}
int tot;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    read(n);
    read(q);
    for(int i=1;i<=n;i++){
        read(a[i]);
    }
    init();
    for(int i=1;i<=q;i++){
        int l,r;
        read(l);
        read(r);
        ans.reset();
        query(l,r);
        if(ans.count()==(r-l+1)){
            putchar('Y');
            putchar('e');
            putchar('s');
            putchar('\n');
        }
        else{
            putchar('N');
            putchar('o');
            putchar('\n');
        }
    }
}
```




---

## 作者：Avenoir (赞：1)

$$\color{navy}\text{刚学莫队，略有感触，希望这篇题解能解决一些初学者的疑问}$$


------------

>### 莫队算法`（Mo's Algorithm）`

>众所周知，这是一种~~玄学的暴力骗分~~区间操作算法

>普通莫队是一种离线算法，要处理更高端的问题我们还需要带修莫队/树上莫队等等，这里先不谈

>#### 前置知识：分块，~~不会的可以上b站康康~~

------------

先看本题：

已知一个序列，给出Q次询问，每次询问区间`[L，R]`所有数是否互不相同，如果是输出`“Yes”`，否则输出`“No”`。

很简单的暴力思路就是找出区间`[L，R]`所有互不相同的数的个数k，接着判断k是否等于`R-L+1`即可，接下来就是莫队裸题了。


------------

莫队的处理方法：

举个例子：如图，对于这样一个序列，我们已知一个询问：q[i].l=3，q[i].r=7，我们想知道区间`[3,7]`内有多少个不同的数。

![](https://cdn.luogu.com.cn/upload/image_hosting/dh63z5gz.png)

不妨先定义一个L=1，R=0，Ans=0

![](https://cdn.luogu.com.cn/upload/image_hosting/ot449jxb.png)

接下来我们只需要扫一遍：

```cpp
inline void add(int x){
	cnt[x]++;
	if(cnt[x]==1) Ans++;
}
inline void del(int x){
	cnt[x]--;
	if(cnt[x]==0) Ans--;
}

对于每个询问：
while(L<q[i].l) del(a[L++]);
while(L>q[i].l) add(a[--L]);
while(R<q[i].r) add(a[++R]);
while(R>q[i].r) del(a[R--]);
ans[q[i].id]=Ans;

```
如果L小于所询问的q[i].l的话，L自然需要右移：

![](https://cdn.luogu.com.cn/upload/image_hosting/6xg87n3o.png)

这个时候，旧L对Ans的影响就需要被删去，即：
```cpp
	del(a[L++])
```
而del函数的实现也很容易理解：
cnt[x]表示的是数字x出现的次数，那么cnt[x]--即可

如果cnt[x]等于0的话，就说明目前的`[L，R]`中已经没有x这个数了，那么Ans--

其它几个和这个是同样的道理，理解了这里就很简单了，处理结束后在ans数组中记录Ans即可。

## Code：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int M=1e6;
struct node{
	int l,r,id;
	int ll,rr;
}q[M];
int a[M],cnt[M],n,m,pos[M],ans[M],L=1,R=0,Ans=0,block;
bool cmp(const node &x,const node &y){
	if(pos[x.l]==pos[y.l]) return x.r>y.r;
	return pos[x.l]<pos[y.l];
}
//cmp函数用于排序，不难得知，用这样的方法排序之后算法的扫描次数会大幅降低，时间复杂度也能相应降低
inline void add(int x){
	cnt[x]++;
	if(cnt[x]==1) Ans++;
}
inline void del(int x){
	cnt[x]--;
	if(cnt[x]==0) Ans--;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	block=sqrt(n);
	for(register int i=1;i<=n;i++){
		cin>>a[i];
		pos[i]=i/block;//分块
	}
	for(register int i=1;i<=m;i++){
		cin>>q[i].l>>q[i].r;
		q[i].id=i;
	}
	sort(q+1,q+m+1,cmp);
	for(register int i=1;i<=m;i++){
		while(L<q[i].l) del(a[L++]);
		while(L>q[i].l) add(a[--L]);
		while(R<q[i].r) add(a[++R]);
		while(R>q[i].r) del(a[R--]);
		ans[q[i].id]=Ans;
		q[q[i].id].ll=q[i].l;//得出答案后不要忘记将对应的q[i].l/r存储以便后续比较
		q[q[i].id].rr=q[i].r;
	}
	for(register int i=1;i<=m;i++){
		if(ans[i]==q[i].rr-q[i].ll+1) cout<<"Yes"<<endl;//如果Ans=R-L+1那么输出Yes，否则输出No
		else cout<<"No"<<endl;
	}
	return 0;
}
```

---

## 作者：盧鋅 (赞：1)

## **莫队!!!!**


------------
先说下基本思想吧,就是用l,r两个指针来回扫描,然后在O(1)的时间内完成有一次移动,顺便统计下ins(插入)或者del(删除)的值对区间有无贡献即可.

用 ans 记录总贡献,用 cnt 记录是否重复及重复数量,若重复则无贡献

则[l,r]与询问重合的时候ans即为答案.

但是很明显当询问区间不规律的时候,l和r两个指针就会"左右横跳",然后时间复杂度就会变大.

所以我们要对询问进行~~排序~~(分块),顺便加入玄虚优化,做法是块内按照块的奇偶性进行r随缘排序,块外按照l排序.

块的大小取n的1/4次方到3/4次方为好.通过分块的操作,我们可以是时间复杂度降为O(n的3/2次方).

对询问分块(手动滑稽)
```
struct query{
	int l,r,in,id;
	inline bool operator < (const query &a)const{
	if(!(in^a.in)){
		return (in&1)?r<a.r:r>a.r; 
	}
	return in<a.in;
	}
}q[maxn];
```
ins和del操作

```
inline void ins(int x){
	if(!cnt[a[x]]++)ans++;
}
inline void del(int x){
	if(!--cnt[a[x]])ans--;
}
```

------------
朴素的莫队之间的区别就是ins和del还有ans与cnt了

##### AC代码如下
```
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#include<cmath> 
#define maxn 1001000
using namespace std;
int ans,num[maxn],cnt[maxn],a[maxn];
int n,m,k,len;
#define re register
inline int read(){
	re int x=0;re bool y=0;re char ch;
	while(!isdigit(ch=getchar()))if(ch=='-')y=1;
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return y?-x:x; 
}
inline void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
}
struct query{
	int l,r,in,id;
	inline bool operator < (const query &a)const{
	if(!(in^a.in)){
		return (in&1)?r<a.r:r>a.r; 
	}
	return in<a.in;
	}
}q[maxn];
inline void ins(int x){
	if(!cnt[a[x]]++)ans++;
}
inline void del(int x){
	if(!--cnt[a[x]])ans--;
}
int main(){
//	freopen("p3901.in","r",stdin);
    n=read();m=read();
//    m=read();
//    k=read();
    len=sqrt(n);
    for(register int i=1;i<=n;++i){
        a[i]=read();
    }
    int x,y;
    for(register int i=1;i<=m;++i){
        x=read();
        y=read();
        q[i].l=x;
        q[i].r=y;
        q[i].in=(x-1)/len+1;
        q[i].id=i;
    }
    sort(q+1,q+1+m);
    int l=1,r=0;
    for(register int i=1;i<=m;++i){
        x=q[i].l;
        y=q[i].r;
        while(l<x)del(l++);
        while(l>x)ins(--l);
        while(r<y)ins(++r);
        while(r>y)del(r--);
        num[q[i].id]=ans==(q[i].r-q[i].l+1)?1:0;
    }
    for(register int i=1;i<=m;++i){
    	if(num[i])puts("Yes");
		else puts("No"); 
//        write(num[i]);
//        printf("\n");
    }
    return 0;
}
```


---

## 作者：Fatalis_Lights (赞：1)

这个题大家应该都写的是**莫队**，于是我也来写一个**莫队**。

这个题我直接用标准莫队（不会的可以左转 小Z的袜子 那个板子题）统计出有多少个数（存在ans数组中），同时用tmp[N]数组存下左右端点的差值(r-l+1)。如果说ans[i]=tmp[i];则输出Yes,否则输出No.思路应该挺好想。
    
那么直接上代码吧：
    
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 100005
using namespace std;
struct query{ll l,r,id,pos;} q[N];
ll a[N],n,m,k,cnt[N],ans[N],sz,tmp[N];
bool cmp(const query&a,const query&b){
	return a.pos<b.pos||a.pos==b.pos&&a.r>b.r;
}
int main(){
	cin>>n>>m;
	sz=(ll)sqrt(n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++){
		scanf("%d %d",&q[i].l,&q[i].r); q[i].id=i;
		q[i].pos=(q[i].l-1)/sz+1;
		tmp[i]=q[i].r-q[i].l+1;
	}
	sort(q+1,q+m+1,cmp);
	for(ll i=1,l=1,r=0,res=0;i<=m;i++){
		while(l>q[i].l) res+=(++cnt[a[--l]]==1);
		while(r<q[i].r) res+=(++cnt[a[++r]]==1);
		while(l<q[i].l) res-=(--cnt[a[l++]]==0);
		while(r>q[i].r) res-=(--cnt[a[r--]]==0);
		ans[q[i].id]=res;
	}
	for(ll i=1;i<=m;i++) tmp[i]==ans[i]? puts("Yes"): puts("No");
	return 0;
}
```

---

## 作者：雪风舞者 (赞：1)

首先，我用的是**莫队**，题解中有大佬、包括洛谷日报讲得都很详细了，就不再赘述~~（才不是不会口胡）~~

这里提供一种莫队移动端点时修改的新思路吧，权且当发散思维了……（至少我翻了几页题解，都是有关$r-l+1$的记录方式布拉布拉的）

## 我的思路
考虑在回答为No时，一定有若干个数$cnt\ge 2$；而当回答为Yes时，就没有数$cnt\ge 2$。那么就用变量$now$记录一下当前有多少数的$cnt\ge 2$。

进行莫队的add操作时，如果这个数的$cnt$由1成了2，那么我们就让`now++`；反之，若进行del时，若这个数的$cnt$由2变成了1，那么就让`now--`。

统计答案时，当$now>0$时，回答为No，否则为Yes。

## 代码
（应该不算重复解法吧……）

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn=1e5+5;
int n,m,siz;
struct qt{
	int l,r,p;
  	//用的奇偶性排序
	bool operator <(const qt &rhs)const{
		return (l/siz^rhs.l/siz)?l<rhs.l:((l/siz)&1?r<rhs.r:r>rhs.r);
	}
}q[maxn];
int a[maxn],cnt[maxn],now=0;
bool ans[maxn];
inline void add(int x){
	cnt[a[x]]++;
	if(cnt[a[x]]==2) now++;
}
inline void del(int x){
	cnt[a[x]]--;
	if(cnt[a[x]]==1) now--;
}
int main(){
	scanf("%d%d",&n,&m);
	siz=n/sqrt(m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].p=i;
	}
	sort(q+1,q+m+1);
	int l=0,r=0;
	for(int i=1;i<=m;i++){
		int ql=q[i].l,qr=q[i].r;
		while(l<ql) del(l++);
		while(l>ql) add(--l);
		while(r<qr) add(++r);
		while(r>qr) del(r--);
		ans[q[i].p]=(now==0);
	}
	for(int i=1;i<=m;i++)
		if(ans[i]) printf("Yes\n");
		else printf("No\n");
	return 0;
}
```


---

## 作者：于丰林 (赞：1)

莫队的一道板子题，可以说是目前看到最简单的可以用莫队的题了。

题目大意：

现有数列A1​,A2​,⋯,AN​，Q 个询问(Li​,Ri​)，判断ALi​,ALi+1​,⋯,ARi​ 是否互不相同。（支持离线询问）

首先，我们显然可以看到暴力是一定会超时的，因为暴力的复杂度太大：O(qn)这个直接TLE没商量

我们说一个稍微慢一些但是也能轻松过这道题的算法：莫队（优雅的暴力）

莫队总体可以分为四句话：

1.将整个序列分为若干个块，每一块大小一般都会分为sqrt(n)。

2.对于整个询问进行排序，以左端点所在块的位置作为第一关键字，以右端点位置作为第二关键字，都做升序排序

3.暴力求出第一个块的答案

4.利用已知答案进行转移

可能大家不太明白第四条，在这里我来解释一下：

对于这道题来说，a的大小并不大，那么我们就可以开一个tot数组来记录区间有多少个相同的数x，再开一个sum记录有多少不同的数，每一次转移时分为两种情况：

1.加入一个新元素，我们只要看一下这个数vis数组是否为0，如果为零那么sum++

2.删去一个旧元素，还是要看是否为0，满足则sum--

不难发现这些转移都是O(1)的

那么关于莫队的时间复杂度：

1.对于右端点来说，由于在同一块内是递增的，每次最多转移n次，而有sqrt(n)个块，所以是O(nsqrt(n))

2.对于左端点来说，由于每一个块内最多转移n次，而有sqrt(n)个块，所以也是O(nsqrt(n))

根据加法原理，（这里省略了左端点跨块的复杂度证明，不过也是nsqrt(n)请自行推导）总复杂度为nsqrt(n) （这个是最大复杂度，实际比这个快得多。。。）

好的，莫队到这里就讲完了！

最后，附上本题代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define maxn 100000
using namespace std;

int a[maxn+5];
struct query
{
    int l,r,id,to;
    bool judge;
};
int sum,appear[maxn+5],ans[maxn+5];
query block[maxn+5];

bool cmp(query x,query y)
{
    if(x.id==y.id) return x.r<y.r;
    return x.id<y.id;
}
void add(int x)
{
    if(appear[a[x]]++==0) sum++;
}
void minus(int x)
{
    if(--appear[a[x]]==0) sum--;
}
int main()
{
    int n,q;
    scanf("%d%d",&n,&q);
    for(int i=1; i<=n; i++) scanf("%d",&a[i]);
    int siz=sqrt(n);
    for(int i=1; i<=q; i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        block[i].l=x,block[i].r=y;
        block[i].id=block[i].l/siz;
        block[i].to=i;
    }
    sort(block+1,block+q+1,cmp);
    for(int i=block[1].l; i<=block[1].r; i++)
    {
        if(appear[a[i]]==0) sum++;
        appear[a[i]]++;
    }
    if(sum==block[1].r-block[1].l+1) ans[block[1].to]=1;
    int Li=block[1].l,Ri=block[1].r;
    for(int k=2; k<=q; k++)
    {
        while(block[k].l<Li) add(--Li);
        while(block[k].l>Li) minus(Li++);
        while(block[k].r>Ri) add(++Ri);
        while(block[k].r<Ri) minus(Ri--);
        if(sum==block[k].r-block[k].l+1) ans[block[k].to]=1;
    }
    for(int i=1; i<=q; i++)
    {
        if(ans[i]==1) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```


---

## 作者：木木！ (赞：1)

各位大佬都是莫队/线段树，本蒟蒻瑟瑟发抖……

思路是尺取法，可以做到$\Theta(n)$预处理，$\Theta(1)$查询。

对于每个左端点，右端点尽量向后拓展，直到不能再拓展。因为右端点不可能往回走，因此用尺取法可以做到$\Theta(n)$的效率。200ms左右过，效率还不错。

为了用上bool数组，还加了离散化，实际时间复杂度$\Theta(nlogn)$（因为排序），如果用`bitset<2147483647>`可能会更快（逃

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int ai[100005];
int rnk[100005];
int used[100005];
int itsrnk[100005];
int maxr[100005];

bool cmp(int a,int b)
{
	return ai[a]<ai[b];
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",ai+i);
	}

	for(int i=1; i<=n; ++i)
	{
		rnk[i] = i;
	}
	sort(rnk+1,rnk+1+n,cmp);

	for(int i=1; i<=n; ++i)
	{
		int& tmp = itsrnk[rnk[i]];
		if(ai[rnk[i-1]]==ai[rnk[i]])
		{
			rnk[i] = rnk[i-1];
		}
		tmp = rnk[i];
	}

	//离散化

	int r = 1;
	for(int i=1; i<=n; ++i)
	{
		while(r<=n && !used[itsrnk[r]])
		{
			used[itsrnk[r]] = 1;
			++r;
		}
		maxr[i] = r-1;
		--used[itsrnk[i]];
	}
    
    //尺取，maxr[]代表从该点开始最远能扩展到的长度

	for(int i=1; i<=m; ++i)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%s\n",maxr[l]>=r?"Yes":"No");
	}

	return 0;
}
```

---

## 作者：yzhang (赞：1)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9971041.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P3901)

### 不错的莫队练手题

块数就直接取sqrt（n）

对所有询问进行排序

排序第一关键词：l所在第几块，第二关键词：r的位置

考虑Ai不大，暴力开数组

add时如果加之后的数量是1

总数就加1

del时如果减之后的数量是0

总数就减1

每次比较总数和该次查询区间的长度

相等的话就把 ans[q[i].id]设为真

最后如果ans[i]为真就输出Yes，否则输出No

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define N 100005
using namespace std;
inline int read()
{
	register int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
int v[N],blocksize=0;
struct query{
	int l,r,id,bl;
}q[N];
int sum[N];
bool ans[N];
int cnt=0;
inline void add(register int x)
{
	if(++sum[v[x]]==1)
		++cnt; 
}
inline void del(register int x)
{
	if(--sum[v[x]]==0)
		--cnt;
}
inline bool cmp(register query a,register query b)
{
	return a.bl==b.bl?a.r<b.r:a.bl<b.bl;
}
int main()
{
	memset(sum,0,sizeof(sum));
	int n=read(),m=read();
	blocksize=sqrt(n);
	for(register int i=1;i<=n;++i)
		v[i]=read();
	for(register int i=1;i<=m;++i)
	{
		int l=read(),r=read();
		q[i]=(query){l,r,i,(l-1)/blocksize+1};
	}
	sort(q+1,q+m+1,cmp);
	int l=1,r=0;
	for(register int i=1;i<=m;++i)
	{
		int ll=q[i].l,rr=q[i].r;
		while(l<ll)
			del(l++);
		while(l>ll)
			add(--l);
		while(r<rr)
			add(++r);
		while(r>rr)
			del(r--);
		ans[q[i].id]=(cnt==rr-ll+1)?1:0;
	}
	for(register int i=1;i<=m;++i)
		if(ans[i])
			puts("Yes");
		else
			puts("No");
	return 0;
 } 
```

---

## 作者：redegg (赞：1)

~~不懂啊，我之前提交的写法还没我现在的写法好。~~

$O(N+M)$啊，你只需要知道每个点为右端点时，包含相同数字的左端点最大是多少就可以了，借鉴前缀和思想：

枚举$i$。

转移就是:$b[i]=max(lmax[a[i]],b[i])$

然后更新：$lmax[a[i]]=i$

然后查询就是判断$b[r[i]]$与$l[i]$的大小啊，如果$b[r[i]]$是大于$l[i]$的，那么说明区间里一定有相同的数字嘛，同理，不包括时，因为$b[i]$是最近的相同数字的左端点，那么一定区间里面就没有相同数字嘛。

代码如下：

```
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[100006];
int b[100006];
int k[100006];

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        b[i]=max(b[i-1],k[a[i]]);
        k[a[i]]=i;
    }

    for(int i=1;i<=m;i++)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        if(b[r]>=l&&b[r]!=0)
            printf("No\n");
        else
            printf("Yes\n");
    }

    return 0;
}

```

---

## 作者：嚯呀嚯呀 (赞：1)

**简单的在线分块....**

其是我是从P1972HH的项链那里过来的，在那里写在线分块只有80分（题解有个dalao说加点优化就可一过了，可是绝望的Pascal并不能吸任何氧气或臭氧，最后还是去写了树状数组）

对于pre[i]表示与这个位置数相同的位置在哪里，这个可以O（n）得出


**终于要说到重点了...**

**对于一个询问[l,r]，我们暴力求解块边上的数的pre[i]有没有大于等于l，如果有的话，就说明这种数字出现两次了，不合法**

对于跨过的块，取最大的pre[i]看一下有没有大于等于l(这个要预处理好，因为我是直接从那题过来的，所以用了排序的方法，那题要每个块排序加二分)，和上面同理

蒟蒻代码...（Pascal）:
```
var
  bi:boolean;
  ans:longint;
  a3,a4,ll,rr,mid,a1,a2,tot,block:longint;
  i,j,m,n,k,p:longint;
  happen:array[0..1000005]of longint;
  a,l,r,point,b,pre:array[0..500005]of longint;
procedure qs(ll,rr:longint);
var
  i,j,mid,a1:longint;
begin
  i:=ll; j:=rr;
  mid:=pre[(i+j) div 2];
  repeat
    while pre[i]<mid do inc(i);
    while pre[j]>mid do dec(j);
    if not(i>j) then
      begin
        a1:=pre[i]; pre[i]:=pre[j]; pre[j]:=a1;
        inc(i); dec(j);
      end;
  until i>j;
  if i<rr then qs(i,rr);
  if ll<j then qs(ll,j);
end;
begin
  {assign(input,'11.in');
  assign(output,'11.out');
  reset(input); rewrite(output);}
  readln(n,m);
  block:=trunc(sqrt(n));
  for i:=1 to n do
    begin
      read(a[i]);
      pre[i]:=happen[a[i]]; b[i]:=pre[i];
      happen[a[i]]:=i;
      if i mod block=1 then
        begin
          inc(tot); l[tot]:=i;
        end;
      if i mod block=0 then
        r[tot]:=i;
      point[i]:=tot;
    end;
  readln;
  if r[tot]=0 then r[tot]:=n;
  for i:=1 to tot do
    qs(l[i],r[i]);
  while m<>0 do
    begin
      dec(m);
      readln(a1,a2);
      bi:=true;
      if point[a1]=point[a2] then
        begin
          for i:=a1 to a2 do
            if b[i]>=a1 then
              begin
                bi:=false; break;
              end;
        end
      else
        begin
          for i:=a1 to r[point[a1]] do
            if b[i]>=a1 then
              begin
                bi:=false; break;
              end;
          if bi=true then
          for i:=point[a1]+1 to point[a2]-1 do
            if pre[r[i]]>=a1 then
              begin
               bi:=false; break;
              end;
          if bi=true then
          for i:=l[point[a2]] to a2 do
            if b[i]>=a1 then
              begin
                bi:=false; break;
              end;
        end;
      if bi=true then writeln('Yes')
      else writeln('No');
    end;
  //close(input); close(output);
end.
```
祝大家2018 RP++

---

## 作者：kakakaka (赞：1)

<http://www.cnblogs.com/huangdalaofighting/p/7351682.html

裸的莫队，真的很简单。

按询问排序，按左端点位置分成sqrt(n)份，每份按右端点从小到大排序即可。

然后尺取法就可以了：

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,a[100001],vis[100001],tot,lim,ans[100001];
struct ask
{
    int l,r,id;
}b[100001];
bool cmp(const ask a,const ask b)
{
    if(a.l/lim!=b.l/lim)return a.l/lim<b.l/lim;else return a.r<b.r;
}
int main()
{
    int i,j;
    scanf("%d%d",&n,&m);
    lim=sqrt(n);
    for(i=1;i<=n;i++)
    scanf("%d",&a[i]);
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&b[i].l,&b[i].r);
        b[i].id=i;
    }
    sort(b+1,b+m+1,cmp);
    int left=1,right=0;
    for(i=1;i<=m;i++)
    {
        while(left<b[i].l){if(--vis[a[left]]==0)tot--;left++;}
        while(left>b[i].l){left--;if(++vis[a[left]]==1)tot++;}
        while(right<b[i].r){right++;if(++vis[a[right]]==1)tot++;}
        while(right>b[i].r){if(--vis[a[right]]==0)tot--;right--;}
        ans[b[i].id]=tot==b[i].r-b[i].l+1;
    }
    for(i=1;i<=m;i++)
    {
        if(ans[i])printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：ctq1999 (赞：0)

## 题解

一看数据和要求，就知道可以使用莫队了。

莫队，由国家队队长莫涛发明，故称莫队。

简单的介绍一下基本莫队

* 是一个离线，查询的数据结构。

* 主要查询大量不同区间的信息。

* 算法简析
  * 把所有询问进行排序，以 $l$ 为第一关键字，$r$ 为第二关键字，全部从小到大排序。

  * 排序后，相邻询问的距离会变小。
  
  * 定义当前询问的指针 $l$ 和 $r$ ，暴力算出排序后的第一个询问。
  
  * 对于后面的询问，$l$ 和 $r$ 一个个转移到下一个询问区间并修改。
  
  * 期间记录每个区间修改后的结果
  
  * 输出所以询问的结果
  
这也是本道题的思路了。只要开一个计数数组即可。

这道题也是一道莫队模板。代码其实就是莫队的最简形态了。

#### 小优化

进行排序时可以按奇偶排序。

```
bl = sqrt(n);

bool cmp(Query x, Query y) {
	return x.l / bl ^ y.l / bl ? x.l < y.l : ((x.l / bl) & 1 ? x.r < y.r : x.r > y.r);
}
```

这也 $l$ 指针转移时，$r$ 不用从接近 $n$ 的地方跑回来，会节省一部分时间。

---

时间复杂度 $O(n^{\frac{3}{2}})$。

## 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 100010
#define ll long long

using namespace std;

int n, Q, bl, num;

int a[MAXN], ans[MAXN], cnt[MAXN];

struct Query {
	int l, r, id;
}q[MAXN];

bool cmp(Query x, Query y) {
	return x.l / bl ^ y.l / bl ? x.l < y.l : ((x.l / bl) & 1 ? x.r < y.r : x.r > y.r);
}

void add(int x) {
	if (++cnt[a[x]] == 1) num++;
	return;
}

void del(int x) {
	if (!--cnt[a[x]]) num--;
	return;
}

int main() {
	scanf("%d%d", &n, &Q);
	bl = sqrt(n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	for (int i = 1; i <= Q; i++) {
		scanf("%d%d", &q[i].l, &q[i].r);
		q[i].id = i;
	}
	
	sort(q + 1, q + Q + 1, cmp);
	
	int l = q[1].l, r = l - 1;
	for (int i = 1; i <= Q; i++) {
		while (l < q[i].l) del(l++);
		while (l > q[i].l) add(--l);
		while (r > q[i].r) del(r--);
		while (r < q[i].r) add(++r); 
		if (q[i].r - q[i].l + 1 == num) ans[q[i].id] = 1;
	}
	
	for (int i = 1; i <= Q; i++) {
		if (ans[i]) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```




---

## 作者：Graphcity (赞：0)

这是很典型的一道莫队的模板题。我的分块大小是 $\sqrt n$, 时间复杂度大致应该是 $O(n\sqrt n)$。

说一下我这道题的做法吧：先开一个 cnt 数组，存每种数字的总个数。然后定义了一个 num 变量，初始值为 0 ，表示总数量超过 1 的数值个数。也就是说，扫完某段区间之后，如果 $num \geq 1$，则输出 "No"，反之输出 "Yes"。

在添加完一个数的时候，如果此时那个数值的总数量等于 2，则 num 加上 1；删除完一个数的时候，如果此时那个数值的总数量等于 1，则 num 减去 1.

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,block;
int l=1,r=0,num=0;
int col[100001];
int ans[100001],cnt[100001];

struct query
{
	int l1,r1;
	int id;
};
query q[100001];

bool cmp(query &x,query &y)
{
    if(x.l1/block==y.l1/block)
    {
    	if(x.l1/block%2==0) return x.r1>y.r1;
    	else return x.r1<y.r1;
	}
    return x.l1<y.l1;
}

inline void add(int x)
{
	++cnt[x];
	if(cnt[x]==2) ++num;
}
inline void del(int x)
{
	--cnt[x];
	if(cnt[x]==1) --num;
}

int main()
{
	scanf("%d%d",&n,&m);
	block=sqrt(n);
	for(register int i(1);i<=n;++i)
		scanf("%d",&col[i]);
	for(register int i(1);i<=m;++i)
	{
		scanf("%d%d",&q[i].l1,&q[i].r1);
		q[i].id=i;
	}
	sort(q+1,q+m+1,cmp);
	
	for(register int i(1);i<=m;++i)
	{
		int ll(q[i].l1);
		int rr(q[i].r1);
		
		while(l<ll) del(col[l++]);
		while(l>ll) add(col[--l]);
		while(r<rr) add(col[++r]);
		while(r>rr) del(col[r--]);
		
		ans[q[i].id]=num;
	}
	
	for(register int i(1);i<=m;++i)
	{
		if(ans[i]>=1) printf("No\n");
		else printf("Yes\n");
	}
    return 0;
}

```


---

## 作者：honoka_desu (赞：0)

几乎所有的题解都是使用莫队算法，不过我还是打算使用~~正经~~的算法来做。
考虑一个区间[x,y],其中没有重复数字的充分必要条件是：[x,y]中每一个数上一次出现的位置都在x的左侧。容易想到只需要求出[x,y]上所有数上一次出现位置的最大值即可，这个过程可以使用线段树维护（或者~~鬼畜~~的树状数组区间最大值算法）
实现还是不太复杂

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 100005
int tree[N<<2],a[N],n,m,tot;
struct num
{
    int val,pos;
    bool operator < (const num b )const
    {
        if(val==b.val)return pos < b.pos;
        return val < b.val;
    }
}s[N];
void build(int p,int l, int r)
{
    if(l==r)
    {
    tree[p]=a[l];
    return;
    }
    int mid = (l+r)>>1;
    build(p<<1,l,mid);
    build((p<<1)+1,mid+1,r);
    tree[p]=max(tree[p<<1],tree[(p<<1)+1]);
}
int getmax(int p,int l,int r,int L, int R)
{
    if(r<L||l>R)return 0;
    if(l>=L&&r<=R)return tree[p];
    int mid = (l+r)>>1;
    return max(getmax(p<<1,l,mid,L,R),getmax(((p<<1)+1),mid+1,r,L,R));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i =1 ; i <= n ; i ++)
    {
        scanf("%d",&s[i].val);
        s[i].pos=i;
    }
    sort(s+1,s+1+n);
    for(int i = 1; i <= n ; i++)
    if(s[i].val==s[i-1].val)
    {
        a[s[i].pos]=s[i-1].pos;
    }
    build(1,1,n);
    while(m--)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(getmax(1,1,n,x,y)>=x)
        {
            puts("No");
        }
        else puts("Yes");
    }
}
```

---


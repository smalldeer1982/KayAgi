# [蓝桥杯 2023 国 A] 01 游戏

## 题目描述

小蓝最近玩上了 $01$ 游戏，这是一款带有二进制思想的棋子游戏，具体来说游戏在一个大小为 $N\times N$ 的棋盘上进行，棋盘上每个位置都需要放置一位数字 $0$ 或者数字 $1$，初始情况下，棋盘上有一部分位置已经被放置好了固定的数字，玩家不可以再进行更改。玩家需要在其他所有的空白位置放置数字，并使得最终结果满足以下条件：

1. 所有的空白位置都需要放置一个数字 $0/1$；
2. 在水平或者垂直方向上，相同的数字不可以连续出现大于两次；
3. 每一行和每一列上，数字 $0$ 和数字 $1$ 的数量必须是相等的 (例如 $N=4$，则表示每一行/列中都需要有 $2$ 个 $0$ 和 $2$ 个 $1$)；
4. 每一行都是唯一的，因此每一行都不会和另一行完全相同；同理每一列也都是唯一的，每一列都不会和另一列完全相同。

现在请你和小蓝一起解决 $01$ 游戏吧！题目保证所有的测试数据都拥有一个唯一的答案。

## 说明/提示

**【评测用例规模与约定】**

对于 $60\%$ 的评测用例，$2\le N\le 6$;  
对于所有评测用例，$2\le N\le 10$，$N$ 为偶数。

感谢 @rui_er 提供测试数据。

## 样例 #1

### 输入

```
6
_0____
____01
__1__1
__1_0_
______
__1___
```

### 输出

```
100110
010101
001011
101100
110010
011001
```

# 题解

## 作者：Clare613 (赞：5)

# 题意
找一个符合条件的二维 01 数组。
# 分析
二维 01 数组是可以通过搜索得到的，因此我们搜索出所有情况的 01 数组，然后判断是否成立即可。
# 代码：

```
#include<bits/stdc++.h>
using namespace std;
int n;
int a[15][15];
int c0[15],c1[15];
char b[15][15];
bool flag=0;
bool d1(){
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			bool fl=0;
			for(int k=1;k<=n;k++){
				if(a[i][k]!=a[j][k]){
					fl=1;
					break;
				}
			}
			if(fl==0){
				 return 0;
			}
		}
	}
	return 1;
}
bool d2(){
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			bool fl=0;
			for(int k=1;k<=n;k++){
				if(a[k][i]!=a[k][j]){
					fl=1;
					break;
				}
			}
			if(fl==0){
				 return 0;
			}
		}
	}
	return 1;
}
void dfs(int x,int y){
	if(c0[y]>n/2||c1[y]>n/2) return ;
	if(flag) return ;
	if(x>2){
		if(a[x][y]==a[x-1][y]&&a[x-1][y]==a[x-2][y]){
			return ;
		}
	}
	if(y>2){
		if(a[x][y]==a[x][y-1]&&a[x][y-1]==a[x][y-2]){
			return ;
		}
	}
	if(x==n&&y==n){
		for(int i=1;i<=n;i++){
			int sum0=0,sum1=0;
			for(int j=1;j<=n;j++){
				if(a[i][j]==0) sum0++;
				if(a[i][j]==1) sum1++;
			}
			if(sum0!=sum1||sum0!=n/2){
				return ;
			}
		}
		if(d1()==0||d2()==0) return ;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cout<<a[i][j];
			}
			cout<<"\n";
		}
		flag=1;
		return ;
	}
	x++;
	if(x>n){
		x=1;
		y++;
	}
	if(b[x][y]=='_'){
		a[x][y]=0;
		c0[y]++;
		dfs(x,y);
		c0[y]--;
		c1[y]++;
		a[x][y]=1;
		dfs(x,y);
		c1[y]--;
	}
	else{
		if(b[x][y]=='0'){
			a[x][y]=0;
			c0[y]++;
			dfs(x,y);
			c0[y]--;
		}
		else{
			a[x][y]=1;
			c1[y]++;
			dfs(x,y);
			c1[y]--;
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>b[i][j];
		}
	}
	if(b[1][1]=='_'){
		a[1][1]=0;
		c0[1]++;
		dfs(1,1);
		c0[1]--;
		c1[1]++;
		a[1][1]=1;
		dfs(1,1);
	}
	else{
		if(b[1][1]=='0'){
			c0[1]++;
			a[1][1]=0;
			dfs(1,1);
		}
		else{
			c1[1]++;
			a[1][1]=1;
			dfs(1,1);
		}
	}
	return 0;
}
```

---

## 作者：Rombing (赞：5)

容易想到 DFS，因为题目保证有唯一解，所以我们可以想到给出的输入矩阵一定不会全为 '_'。

将已经填完的数计入用于判断的数组中，在此基础上，再利用题目给出的限制条件进行剪枝，完全可以让 DFS 跑的飞快。

判断每行、每列不重复可以使用类似状压的思想，将其看成一个二进制串，检测该二进制串的值是否重复即可。

做这种限制条件比较多的 DFS，建议单独写一个 check 函数用来判断填数方案是否合法，并且每次填一个数都要判断一次，及早回溯，避免 TLE。



---



代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define N 25

int n;
int a[N][N];
int r[N][2], c[N][2]; //r记录每行0、1个数，c记录每列0、1个数
int vr[N * 100], vc[N * 100]; //vr记录填完的每一行的值，vc记录填完的每一列的值

bool check(int x, int y) {
    if(r[x][0] <= n / 2 && r[x][1] <= n / 2 && c[y][0] <= n / 2 && c[y][1] <= n / 2) {
        if(x == n) {
            if(c[y][0] != n / 2 || c[y][1] != n / 2)return false;
        }
        if(y == n) {
            if(r[x][0] != n / 2 || r[x][1] != n / 2)return false;
        }
        if(x > 2) {
            if(a[x - 1][y] == a[x][y] && a[x - 2][y] == a[x][y])return false;
        }
        if(y > 2) {
            if(a[x][y - 1] == a[x][y] && a[x][y - 2] == a[x][y])return false;
        }
        return true;
    } else
        return false;
}

int get(int x, int opt) {
    int res = 0;
    for(int i = 1; i <= n; i++) {
        if(a[x][i] && opt == 1)res += (1 << i);
        if(a[i][x] && opt == 2)res += (1 << i);
    }
    return res;
}

void dfs(int x, int y) {
    if(x == n + 1) {
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++)
                cout << a[i][j];
            cout << endl;
        }
        exit(0);
    }
    int flag = (a[x][y] == -1);
    for(int i = 0; i <= 1; i++) {
        if(i == a[x][y])continue;
        if(flag) {
            a[x][y] = i;
            r[x][i]++;
            c[y][i]++;
        }
        if(check(x, y)) {
            if(y == n) {
                int sum = get(x, 1);
                if(!vr[sum]) {
                    vr[sum] = 1;
                    dfs(x + 1, 1);
                    vr[sum] = 0;
                }
            } else {
                if(x == n) {
                    int sum = get(y, 2);
                    if(!vc[sum]) {
                        vc[sum] = 1;
                        dfs(x, y + 1);
                        vc[sum] = 0;
                    }
                } else
                    dfs(x, y + 1);
            }
        }
        if(flag) {
            r[x][i]--;
            c[y][i]--;
            a[x][y] = -1;
        }
    }
}

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++) {
            char z;
            cin >> z;
            if(z == '_')a[i][j] = -1;
            else {
                a[i][j] = z - '0';
                r[i][a[i][j]]++;
                c[j][a[i][j]]++;
            }
        }
    dfs(1, 1);
    return 0;
}
```

---

## 作者：xxt0218 (赞：4)

这道题就类似于一个数独呀，而且数据范围不大，还是很好做的，只需要依次处理规则加上 dfs 枚举就行啦。

让我们开始吧！

（下文若无特殊说明，定义 $0$ 的相反的数为 $1$，$1$ 的相反的数为 $0$；表格代指二维数组，每个格子代表二维数组中储存的数）。

## 前置知识
数独基础，dfs，剪枝，模拟。

## 题意

寻找一个符合 4 种规则的表格，进行输出。

## 分析
先来看看它的规则：

* 规则 1：所有的空白位置都需要放置一个数字 $0/1$；这个规则就没那么要紧啦，而且也排除不了什么情况的。

* 规则 2：在水平或者垂直方向上，相同的数字**不可以连续出现大于两次**；这个也是很好实现的啦，对于每一个格子，我们只需要将它的**四个方向**进行枚举，如果有一个格子的**一个方向连续两个数**都是**相同**的，那么这个格子必然填与之相反的数（如图）：
  ![](https://cdn.luogu.com.cn/upload/image_hosting/g10d0iu4.png)
  因为红色格子的左边连续两个数都是 $0$，由于在水平或者垂直方向上，相同的数字不可以连续出现大于两次，所以红色格子只能填 $1$ 了。

  形式化的说，设有一表格 $a$，若 $a_{i + 1,j}$ 与  $a_{i + 2,j}$ 相等，则 $a_{i,j}$ 的值为 $a_{i + 1,j}$ 的相反的数，其它方向亦然。

* 规则 3：每一行和每一列上，数字 $0$ 和数字 $1$ 的数量**必须是相等的** （例如 $N=4$，则表示每一行或列中都需要有 $2$ 个 $0$ 和 $2$ 个 $1$）；这也很好实现啦，我们只需要枚举每一行，若有一行的 $0$ 或 $1$ 的个数占了**总行的一半**，那么剩下的就是其相反的数啦（如图）：
  ![](https://cdn.luogu.com.cn/upload/image_hosting/s5nv9yp6.png)

  因为第一行中 $1$ 的个数**占了一半**，由于每一行和每一列上，数字 $0$ 和数字 $1$ 的数量必须是相等的，所以剩下的三个空就只能填 $0$ 啦。
  
  形式化的说，设有一表格 $a$，若 $a_{i,1},a_{i,2},a_{i,3} ,\dots,a_{i,n} $ 中有 $\frac{n}{2}$ 个数为 $a_{i,m} (0 < m \le n)$ ，那么剩下的数为 $a_{i,m}$ 的相反的数。

* 规则 4，**每一行**都是**唯一**的，因此每一行都**不会**和另一行**完全相同**；同理**每一列**也都是**唯一**的，每一列都**不会**和另一列**完全相同**；这个规则是本题目中最难处理的部分啦。这个只能通过枚举来实现。我们可以通过 dfs 枚举每个空格，然后进行判断，看看是否满足要求，直到找到满足要求的情况，因为这道题保证有唯一解，所以直接输出就可以啦。

## 思路

分析完四条规则，题目就变得十分清晰了。我们只需要先处理规则 2 和 3，把能填的先填了，最后去枚举，枚举到找到要求的情况输出即可。

## 实现代码

首先定义变量 $n$、二维字符数组 $temp$ 和二维数组 $a$。变量 $n$ 储存棋盘大小，二维字符数组 $temp$ 读取题目输入，二维数组 $a$ 储存转换后的题目输入。

```cpp
int n,a[20][20];
char temp[20][20];
```

然后进行输入、转换，为了方便，我们可以把没有填过的空格设为 $-1$；

```cpp
cin >> n;
	
for(int i = 1;i <= n;i ++){
	for(int j = 1;j <= n;j ++){
		cin >> temp[i][j];
		if(temp[i][j] == '0') a[i][j] = 0;
		else if(temp[i][j] == '1') a[i][j] = 1;
		else a[i][j] = -1;
  }
}
```
然后开始处理规则：

先处理规则 2，时间复杂度 $O(n^2)$：

```cpp
for(int i = 1;i <= n;i ++){
	for(int j = 1;j <= n;j ++){
		if(a[i][j] == -1){
            if(j <= n - 2 && a[i][j + 1] == a[i][j + 2] && a[i][j + 1] != -1 && a[i][j + 2] != -1) a[i][j] = (a[i][j + 1] == 1 ? 0 : 1);
            else if(j >= 3 && a[i][j - 1] == a[i][j - 2] && a[i][j - 1] != -1 && a[i][j - 2] != -1) a[i][j] = (a[i][j - 1] == 1 ? 0 : 1);
            else if(i <= n - 2 && a[i + 1][j] == a[i + 2][j] && a[i + 1][j] != -1 && a[i + 2][j] != -1) a[i][j] = (a[i + 1][j] == 1 ? 0 : 1);
            else if(i >= 3 && a[i - 1][j] == a[i - 2][j] && a[i - 1][j] != -1 && a[i - 2][j] != -1) a[i][j] = (a[i - 1][j] == 1 ? 0 : 1);
			}
		}
	}
  ```

这几行信息量较大，就是通过枚举来寻找判断这个格子能否被确定，但整体含义如上文所示，我就不细说啦，你自己看吧。

处理规则3，时间复杂度 $O(n^2)$：
  
```cpp    
for(int i = 1;i <= n;i ++){
  int num_of_0 = 0,num_of_1 = 0,num_of_0_turn = 0,num_of_1_turn = 0;
  //变量num_of_0为每一行中0的数量，变量num_of_1为每一行中0的数量，变量num_of_turn_0为每一列中0的数量，变量num_of_turn_1为每一列中1的数量
  //遍历每一行
  for(int j = 1;j <= n;j ++){
    if(a[i][j] == 0) num_of_0 ++;
    if(a[i][j] == 1) num_of_1 ++;
  }
  //进行修改
  if(num_of_0 >= n / 2)
    for(int j = 1;j <= n;j ++)
      if(a[i][j] == -1) a[i][j] = 1;
  if(num_of_1 >= n / 2)
    for(int j = 1;j <= n;j ++)
      if(a[i][j] == -1) a[i][j] = 0;
  //遍历每一列
  for(int j = 1;j <= n;j ++){
    if(a[j][i] == 0) num_of_0_turn ++;
    if(a[j][i] == 1) num_of_1_turn ++;
  }
  //进行修改
  if(num_of_0_turn >= n / 2)
    for(int j = 1;j <= n;j ++)
      if(a[i][j] == -1) a[j][i] = 1;
  if(num_of_1_turn >= n / 2)
    for(int j = 1;j <= n;j ++)
      if(a[i][j] == -1) a[j][i] = 0;
}
```

代码通过遍历，实现对每一行、每一列 $0$ 和 $1$ 数量的枚举，然后对表格进行处理。有不懂的看代码中的注释。反正大致意思同上就对了嘛。

处理规则4，时间复杂度 $O(2^{n^2})$：

因为 $n$ 的最大值是 $10$，所以显然会超时的，化我们后面再来处理。

先定义一个函数 $isfull$，来判断表格是否被填满。

```cpp
bool isfull(){
	for(int i = 1;i <= n;i ++)//遍历
		for(int j = 1;j <= n;j ++)
			if(a[i][j] == -1) return 0;
	return 1;
}
```

然后定义一个函数 $isok$ 来判断当前表格是否符合要求。这个函数码量就比较大了，要判断当前表格是否满足每个规则。判断其它规则的代码很简单，基本如处理规则的代码一样。那么如何判断是否满足规则 4 呢？

很简单呐。我们可以通过 3 重循环来暴力寻找是否含有重复的行或列，这里定义了 4 个变量来储存行与行、列与列之间连续重复的长度（第 5 行），如果它们之中有一个的值与 $n$（表格每一行、每一列的长度）相等，即发现了重复的行或列，那么当前表格就不满足规则 4。否则就满足规则 4 啦。

**这里有一个小坑**，如图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/1bbmpjxc.png)

（这里暂时无视规则 2）

在这里，红色、绿色两种颜色的框框所框住的数列都会相互被视为**相同的**，而红色、黄色和黄色、绿色的**不会**，因为它们不在同一行、列，因此这里要加以小心。

```cpp
bool isok(){
    //判断是否满足规则4
	for(int i = 1;i <= n;i ++){
		for(int j = i + 1;j <= n;j ++){
			int temp_x = 0,temp_y = 0,temp_turn_x = 0,temp_turn_y = 0;
            //temp_x 表示行与行之间连续重复的数量，temp_y 表示列与列之间连续重复的数量，temp_turn_x表示反着的行与行之间的关系，temp_turn_y表示反着的列与列之间的关系
			for(int k = 1;k <= n;k ++){
				if(a[i][k] == a[j][k] && a[i][k] != -1 && a[j][k] != -1) temp_x ++;
				else break;
			}	
			for(int k = 1;k <= n;k ++){
				if(a[k][i] == a[k][j] && a[k][i] != -1 && a[k][j] != -1) temp_y ++;
				else break;
			}
			for(int k = n;k >= 1;k --){
				if(a[i][k] == a[j][k] && a[i][k] != -1 && a[j][k] != -1) temp_turn_x ++;
				else break;
			}	
			for(int k = n;k >= 1;k --){
				if(a[k][i] == a[k][j] && a[k][i] != -1 && a[k][j] != -1) temp_turn_y ++;
				else break;
			}

			if(temp_x == n || temp_y == n || temp_turn_x == n || temp_turn_y == n) return 0;
		}
	}

    //判断是否满足规则3
	for(int i = 1;i <= n;i ++){
		int num_of_0 = 0,num_of_1 = 0,num_of_0_turn = 0,num_of_1_turn = 0;
		for(int j = 1;j <= n;j ++){
			if(a[i][j] == 0) num_of_0 ++;
			if(a[i][j] == 1) num_of_1 ++;
		}
		for(int j = 1;j <= n;j ++){
			if(a[j][i] == 0) num_of_0_turn ++;
			if(a[j][i] == 1) num_of_1_turn ++;
		}
		if(num_of_0 > n / 2 || num_of_1 > n / 2 || num_of_0_turn > n / 2 || num_of_1_turn > n / 2) return 0;
	}

    //判断是否满足规则2
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= n;j ++){
			if(a[i][j] != -1){
				if(j <= n - 2 && a[i][j] == a[i][j + 1] && a[i][j + 1] == a[i][j + 2]) return 0; 
				else if(j >= 3 && a[i][j] == a[i][j - 1] && a[i][j - 1] == a[i][j - 2]) return 0;
				else if(i <= n - 2 && a[i][j] == a[i + 1][j] && a[i + 1][j] == a[i + 2][j]) return 0; 
				else if(i >= 3 && a[i][j] == a[i - 1][j] && a[i - 1][j] == a[i - 2][j]) return 0;
			}
		}
	}
	return 1;
}
```

然后开始 dfs。

```cpp
//dfs中的两个参数为二维数组a中的下标
void dfs(int x,int y){
  if(isfull()){ //如果被填充满了，那么进行判断，看看是否满足规则。
    if(isok()){ //如果满足规则，那么进行输出
      for(int i = 1;i <= n;i ++){
        for(int j = 1;j <= n;j ++){
          cout << a[i][j];
        }
        cout << endl;
      }
      return;
    }
    else return; //否则直接return;
  }
  //如果这个数字不是 -1，即这个数字已经被确定，那么直接搜索下一个数
  if(a[x][y] != -1){
		if(y == n) dfs(x + 1,1);
        //如果已经搜索到的当前行的最后一个数，那么搜索下一行
		else dfs(x,y + 1);
        //如果当前行还没搜完，那么就继续往下搜
	}

  //如果这个数字是 -1，即这个数字未被确定，那么进行枚举
  if(a[x][y] == -1){
    a[x][y] = 0;//枚举0的情况
    if(y == n) dfs(x + 1,1);//大意同上
    else dfs(x,y + 1);
    a[x][y] = 1;//枚举1的情况
    if(y == n && x != n) dfs(x + 1,1);//大意同上
    else dfs(x,y + 1);
    a[x][y] = -1;//回溯
	}
}
```

代码通过 dfs 搜索，实现对每一个空格的枚举，直到找到满足要求的情况，进行输出。整体含义如之前的分析所示啦。

### 优化

因为 $n \le 10$，显然这样的复杂度是不符合要求的，那么如何进行优化呢？

很简单呀，我们只要在每一次 dfs 的过程中判断当前表格是否满足要求就行了。这样就可以省去很多不必要的搜索哦。

代码如下，时间复杂度不好估计：

```cpp
void dfs(int x,int y){
	if(!isok()) return; //仅仅加了这一行，其余同上
	if(isfull()){
		if(isok()){
			for(int i = 1;i <= n;i ++){
				for(int j = 1;j <= n;j ++){
					cout << a[i][j];
				}
				cout << endl;
			}
			return;
		}
		else return;
	}
	if(a[x][y] != -1){
		if(y == n) dfs(x + 1,1);
		else dfs(x,y + 1);
	}
	if(a[x][y] == -1){
		a[x][y] = 0;
		if(y == n) dfs(x + 1,1);
		else dfs(x,y + 1);
		a[x][y] = 1;
		if(y == n && x != n) dfs(x + 1,1);
		else dfs(x,y + 1);
		a[x][y] = -1;
	}
}
```

到这里，我们的代码就基本结束啦，以下是完整代码（这里把处理规则 2 和 3 的代码合并在了 $ready$ 函数中，因为要多次处理，防止错误。在 dfs 之前调用任意次就可以啦）：

这里说明一下，如果你直接枚举符合要求的表格而不去先处理规则 2 和 3，也是可以的，但复杂度略劣。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[20][20];
char temp[20][20];
int m[20][20];
bool is_full(){
	for(int i = 1;i <= n;i ++)
		for(int j = 1;j <= n;j ++)
			if(a[i][j] == -1) return 0;
	return 1;
}
bool is_now_ok(){
	for(int i = 1;i <= n;i ++){
		for(int j = i + 1;j <= n;j ++){
			int temp_x = 0,temp_y = 0,temp_turn_x = 0,temp_turn_y = 0;
			for(int k = 1;k <= n;k ++){
				if(a[i][k] == a[j][k] && a[i][k] != -1 && a[j][k] != -1) temp_x ++;
				else break;
			}	
			for(int k = 1;k <= n;k ++){
				if(a[k][i] == a[k][j] && a[k][i] != -1 && a[k][j] != -1) temp_y ++;
				else break;
			}
			for(int k = n;k >= 1;k --){
				if(a[i][k] == a[j][k] && a[i][k] != -1 && a[j][k] != -1) temp_turn_x ++;
				else break;
			}	
			for(int k = n;k >= 1;k --){
				if(a[k][i] == a[k][j] && a[k][i] != -1 && a[k][j] != -1) temp_turn_y ++;
				else break;
			}
			if(temp_x == n || temp_y == n || temp_turn_x == n || temp_turn_y == n) return 0;
		}
	}
	for(int i = 1;i <= n;i ++){
		int num_of_0 = 0,num_of_1 = 0,num_of_0_turn = 0,num_of_1_turn = 0;
		for(int j = 1;j <= n;j ++){
			if(a[i][j] == 0) num_of_0 ++;
			if(a[i][j] == 1) num_of_1 ++;
		}
		for(int j = 1;j <= n;j ++){
			if(a[j][i] == 0) num_of_0_turn ++;
			if(a[j][i] == 1) num_of_1_turn ++;
		}
		if(num_of_0 > n / 2 || num_of_1 > n / 2 || num_of_0_turn > n / 2 || num_of_1_turn > n / 2) return 0;
	}
	
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= n;j ++){
			if(a[i][j] != -1){
				if(j <= n - 2 && a[i][j] == a[i][j + 1] && a[i][j + 1] == a[i][j + 2]) return 0; 
				else if(j >= 3 && a[i][j] == a[i][j - 1] && a[i][j - 1] == a[i][j - 2]) return 0;
				else if(i <= n - 2 && a[i][j] == a[i + 1][j] && a[i + 1][j] == a[i + 2][j]) return 0; 
				else if(i >= 3 && a[i][j] == a[i - 1][j] && a[i - 1][j] == a[i - 2][j]) return 0;
			}
		}
	}
	return 1;
}
void ready(){//这里把解决规则2和3的代码合并在了ready函数中
	//解决规则3
	for(int i = 1;i <= n;i ++){
		int num_of_0 = 0,num_of_1 = 0,num_of_0_turn = 0,num_of_1_turn = 0;
		for(int j = 1;j <= n;j ++){
			if(a[i][j] == 0) num_of_0 ++;
			if(a[i][j] == 1) num_of_1 ++;
		}
		if(num_of_0 >= n / 2){
			for(int j = 1;j <= n;j ++){
				if(a[i][j] == -1) a[i][j] = 1;
			}
		}
		if(num_of_1 >= n / 2){
			for(int j = 1;j <= n;j ++){
				if(a[i][j] == -1) a[i][j] = 0;
			}
		}
		for(int j = 1;j <= n;j ++){
			if(a[j][i] == 0) num_of_0_turn ++;
			if(a[j][i] == 1) num_of_1_turn ++;
		}
		if(num_of_0_turn >= n / 2){
			for(int j = 1;j <= n;j ++){
				if(a[j][i] == -1) a[j][i] = 1;
			}
		}
		if(num_of_1_turn >= n / 2){
			for(int j = 1;j <= n;j ++){
				if(a[j][i] == -1) a[j][i] = 0;
			}
		}
	}
	
	//解决规则2
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= n;j ++){
			if(a[i][j] == -1){
				if(j <= n - 2 && a[i][j + 1] == a[i][j + 2] && a[i][j + 1] != -1 && a[i][j + 2] != -1) a[i][j] = (a[i][j + 1] == 1 ? 0 : 1);
				else if(j >= 3 && a[i][j - 1] == a[i][j - 2] && a[i][j - 1] != -1 && a[i][j - 2] != -1) a[i][j] = (a[i][j - 1] == 1 ? 0 : 1);
				else if(i <= n - 2 && a[i + 1][j] == a[i + 2][j] && a[i + 1][j] != -1 && a[i + 2][j] != -1) a[i][j] = (a[i + 1][j] == 1 ? 0 : 1);
				else if(i >= 3 && a[i - 1][j] == a[i - 2][j] && a[i - 1][j] != -1 && a[i - 2][j] != -1) a[i][j] = (a[i - 1][j] == 1 ? 0 : 1);
			}
		}
	}
}

void dfs(int x,int y){
	if(!is_now_ok()) return;
	if(is_full()){
		if(is_now_ok()){
			for(int i = 1;i <= n;i ++){
				for(int j = 1;j <= n;j ++){
					cout << a[i][j];
				}
				cout << endl;
			}
			return;
		}
		else return;
	}
	if(a[x][y] != -1){
		if(y == n) dfs(x + 1,1);
		else dfs(x,y + 1);
	}
	if(a[x][y] == -1){
		a[x][y] = 0;
		if(y == n) dfs(x + 1,1);
		else dfs(x,y + 1);
		a[x][y] = 1;
		if(y == n && x != n) dfs(x + 1,1);
		else dfs(x,y + 1);
		a[x][y] = -1;
	}
	
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= n;j ++){
			cin >> temp[i][j];
			if(temp[i][j] == '0') a[i][j] = 0;
			else if(temp[i][j] == '1') a[i][j] = 1;
			else a[i][j] = -1;
		}
	}
	for(int i = 1;i <= 10;i ++) ready(); //这里调用了10次，其实多少次都可以，主要是防止错误。
	dfs(1,1);
	return 0;
}
```

完结撒花！！

## 后记

这是一道适合练习 dfs 的题目，码量稍大，调试时要有耐心，但没什么算法含金量，想练习算法的可以移步别的题啦。

哦对了，这是我的第一篇题解哦！如有不好或错误之处，还请多多指出，我会继续努力的！

(๑╹ヮ╹๑)ﾉ

---

## 作者：_Kenba_ (赞：3)

这题很简单的就会想到搜索，因为数据范围很小，感觉就像数独问题，不过就是限制条件多了许多，不多无伤大雅，因为是唯一解，所以找到答案后就可以直接输出，不用考虑多解，就可以轻松的建立一个二维的 01 搜索，再把数独的套路搬上去就好啦，下面是详细过程。

首先我们可以不用考虑那么多的限制，哪个好写就先写哪个，例如：在水平或者垂直方向上，相同的数字不可以连续出现大于两次这个可以通过一个计数器实现，又例如：每一行和每一列上，数字 $0$ 和数字 $1$ 的数量必须是相等的；这个可以参考数独里的数字计数方法也很好实现，接下来就是不好实现的部分了，就是每行每列不能是重复的，我第一眼看到这个条件时也不知道如何实现，那就把它放到结果中实现，不用在 DFS 中每次更新 ~~（其实是我不会更新）~~，具体参考代码第 $11$ 行，

特别注意的是：

1.判行和列是否重复时一定要把上一次的字符串清空，（作者就是因为这个 WA 了 $3$ 个点）

2.判断是否连续超过 $2$ 个时，一定要在其不连续是重置计数器，最后取最大值，否则答案是错的。

3.推荐把输入转换成整型，这样比较好写

个人认为这题和数独很像，想做的可以去搜 P1784，P1074，P4573，可以检验一下自己学会了没有。

~~（其实这就是一个爆搜，根本用不到剪枝）~~

最后只能说这题细节很多，但没什么思维含量。
下面是 AC CODE：
```
#include<bits/stdc++.h>
using namespace std;
int n;
char g[23][23];
int h[23][23];
int fx[4][30],fy[4][30];
string sx[30],sy[30];
int v[23][23];
void dfs(int x,int y) {
	if(x==n&&y==n+1) {
		for(int i=1;i<=n;i++){
			sx[i]="";
			sy[i]="";
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) {
				sx[i]+=h[i][j];
				sy[j]+=h[i][j];
			}
		}
		for(int i=1; i<n; i++) {
			for(int j=i+1; j<=n; j++) {
				if(sx[i]==sx[j]) {
					return;
				}
				if(sy[i]==sy[j]) {
					return;
				}
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++) {
				cout<<h[i][j];
			}
			cout<<endl;
		}
		exit(0);
	}
	if(y==n+1) {
		//cout<<1111111;
		dfs(x+1,1);
		return;
	}
	if(h[x][y]==0||h[x][y]==1) {
		dfs(x,y+1);
		return;
	}
	for(int i=0; i<=1; i++) {
		int sum=1,sum1=1;
		//cout<<fx[i][x]<<" "<<fy[i][y]<<" "<<x<<" "<<y<<endl;
		if(fx[i][x]>=n/2||fy[i][y]>=n/2) {
			//cout<<x<<" "<<y<<endl;
			continue;
		}
		h[x][y]=i;
		//cout<<x<<" "<<y;
		int aa=0,bb=0;
		for(int j=2; j<=n; j++) {
			if(h[x][j]==h[x][j-1]&&h[x][j]!=-1) {
				sum++;
				aa=max(aa,sum);
				//cout<<sum<<" "<<x<<" "<<j<<endl;
			}
			if(h[x][j]!=h[x][j-1]){
				sum=1;
			}
			if(h[j][y]==h[j-1][y]&&h[j][y]!=-1) {
				sum1++;
				bb=max(bb,sum1);
			}
			if(h[j][y]!=h[j-1][y]) {
				sum1=1;
			}
		}
		h[x][y]=-1;
		if(aa>2||bb>2) {
			//cout<<"    "<<x<<" "<<y<<endl;
			//cout<<sum<<" "<<sum1;
			continue;
		}
		h[x][y]=i;
		fx[i][x]++;
		fy[i][y]++;
		//cout<<x<<" "<<y<<" "<<h[x][y]<<endl;
//		for(int i=1; i<=n; i++) {
//			for(int j=1; j<=n; j++) {
//				cout<<h[i][j]<<" ";
//			}
//			cout<<endl;
//		}
//		cout<<endl;
		dfs(x,y+1);
		fx[i][x]--;
		fy[i][y]--;
		h[x][y]=-1;
	}
}
int main() {
	cin>>n;
	for(int i=0; i<=11; i++) {
		for(int j=0; j<=11; j++) {
			h[i][j]=-1;
		}
	}
	memset(fx,0,sizeof(fx));
	memset(fy,0,sizeof(fy));
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			cin>>g[i][j];
			if(g[i][j]=='0') {
				fx[0][i]++;
				fy[0][j]++;
				h[i][j]=0;
			} else if(g[i][j]=='1') {
				fx[1][i]++;
				fy[1][j]++;
				h[i][j]=1;
			}

		}
	}
//	for(int i=1;i<=n;i++){
//		for(int j=1;j<=n;j++){
//			cout<<h[i][j];
//		}
//		cout<<endl;
//	}
	dfs(1,1);
	return 0;
}
```

---

## 作者：Ascnbeta (赞：3)

## P10419 [蓝桥杯 2023 国 A] 01 游戏
模拟赛放了爆搜剪枝题，也没有大样例，相当恶心，样例强度也一般。

总之：极其难写。

前置知识：DFS，剪枝，状压，位运算。

## 思路分析
朴素 DFS 非常好想，可以考虑把所有的位置都枚举出来，然后喜提 $\Omicron(2^{n^2})$ 的复杂度，直接 T 飞。

考虑剪枝。很容易想到，我们没必要把盘面都枚举出来，可以在每个位置放数字的时候就判断能放哪个数字。所以我们就可以这么判断：

```cpp
if (x>=2&&mp[x-1][y]==mp[x-2][y]&&mp[x-2][y]==v) return false;
if (x<=n-1&&mp[x+1][y]==mp[x+2][y]&&mp[x+2][y]==v) return false;
if (x>=1&&x<=n&&mp[x-1][y]==mp[x+1][y]&&mp[x+1][y]==v) return false;
if (y>=2&&mp[x][y-1]==mp[x][y-2]&&mp[x][y-2]==v) return false;
if (y<=n-1&&mp[x][y+1]==mp[x][y+2]&&mp[x][y+2]==v) return false;
if (y>=1&&y<=n&&mp[x][y-1]==mp[x][y+1]&&mp[x][y+1]==v) return false;[y+1]&&mp[x][y+1]==v) return false;
```

即以下情况均不合法：（中括号表示要填的位置）
```plain
1[1]1 11[1] [1]11

 1 [1] 1
[1] 1  1
 1  1 [1]
```
注意判断的时候不要越界。

然后我们开两个 $cnt$ 数组统计每一行和每一列的 $0,1$ 个数。如果超过了 $n\div2$ 就不合法：
```cpp
if (cnt[1][x][v]+1 > n / 2) return false;
if (cnt[2][y][v]+1 > n / 2) return false;
```
最后如果这是第 $n$ 行或第 $n$ 列，那么判断这一行是否出现过。这里可以使用状压的方法，因为每一行就是一个最多长 $10$ 的 01 串，我们可以直接压成一个二进制数。如果这个二进制数出现过，那么就不合法：
```cpp
    mp[x][y] = v;
	if (x == n) {
		long long tmp = 0;
		for (int i = 1; i <= n; i++) {
			tmp = tmp | (mp[i][y]<<(i-1));
		}
		if (m1[tmp] == 1) {
			mp[x][y] = -1;
			return false;
		}
		m1[tmp] = 1;
	}
	if (y == n) {
		long long tmp = 0;
		for (int i = 1; i <= n; i++) {
			tmp = tmp | (mp[x][i]<<(i-1));
		}
		if (m2[tmp] == 1) {
			mp[x][y] = -1;
			return false;
		}
		m2[tmp] = 1;
	}
    cnt[1][x][v]++;
	cnt[2][y][v]++;
	return true;
```
这样 `check` 函数就写完了，其实你也就写完的最核心的部分。DFS 函数很好写，所以直接放出。

最后就是一定要有耐心，我调了一个下午才调完……

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int mp[13][13],cnt[3][13][2];
int m1[40000],m2[40000];
inline bool check(int v,int x,int y) {
	//cout << v << x << y << '\n';
	if (x>=2&&mp[x-1][y]==mp[x-2][y]&&mp[x-2][y]==v) return false;
	if (x<=n-1&&mp[x+1][y]==mp[x+2][y]&&mp[x+2][y]==v) return false;
	if (x>=1&&x<=n&&mp[x-1][y]==mp[x+1][y]&&mp[x+1][y]==v) return false;
	if (y>=2&&mp[x][y-1]==mp[x][y-2]&&mp[x][y-2]==v) return false;
	if (y<=n-1&&mp[x][y+1]==mp[x][y+2]&&mp[x][y+2]==v) return false;
	if (y>=1&&y<=n&&mp[x][y-1]==mp[x][y+1]&&mp[x][y+1]==v) return false;
	if (cnt[1][x][v]+1 > n / 2) return false;
	if (cnt[2][y][v]+1 > n / 2) return false;
	mp[x][y] = v;
	if (x == n) {
		long long tmp = 0;
		for (int i = 1; i <= n; i++) {
			tmp = tmp | (mp[i][y]<<(i-1));
		}
		if (m1[tmp] == 1) {
			mp[x][y] = -1;
			return false;
		}
		m1[tmp] = 1;
	}
	if (y == n) {
		long long tmp = 0;
		for (int i = 1; i <= n; i++) {
			tmp = tmp | (mp[x][i]<<(i-1));
		}
		if (m2[tmp] == 1) {
			mp[x][y] = -1;
			return false;
		}
		m2[tmp] = 1;
	}
	cnt[1][x][v]++;
	cnt[2][y][v]++;
	return true;
}
void print() {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cout << mp[i][j];
		}
		cout << '\n';
	}
}
void dfs(int x,int y) {
	//cout << x << ' ' << y << '\n';
	//print();
	if (mp[x][y] != -1) {
		if (x == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[i][y]<<(i-1));
			}
			if (m1[tmp] == 1) {
				return;
			}
			m1[tmp] = 1;
		}
		if (y == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[x][i]<<(i-1));
			}
			if (m2[tmp] == 1) {
				return;
			}
			m2[tmp] = 1;
		}
		if (y != n) dfs(x,y+1);
		else if (x != n) dfs(x+1,1);
		else {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					cout << mp[i][j];
				}
				cout << '\n';
			}
			exit(0);
		}
		if (x == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[i][y]<<(i-1));
			}
			m1[tmp] = 0;
		}
		if (y == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[x][i]<<(i-1));
			}
			m2[tmp] = 0;
		}
		return;
	}
	if (check(0,x,y)) {
		//cout << x << ' ' << y << '\n';
		if (y != n) dfs(x,y+1);
		else if (x != n) dfs(x+1,1);
		else {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					cout << mp[i][j];
				}
				cout << '\n';
			}
			exit(0);
		}
		if (x == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[i][y]<<(i-1));
			}
			m1[tmp] = 0;
		}
		if (y == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[x][i]<<(i-1));
			}
			m2[tmp] = 0;
		}
		mp[x][y] = -1;
		cnt[1][x][0]--;
		cnt[2][y][0]--;
	}
	if (check(1,x,y)) {
		//cout << x << ' ' << y << '\n';
		if (y != n) dfs(x,y+1);
		else if (x != n) dfs(x+1,1);
		else {
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					cout << mp[i][j];
				}
				cout << '\n';
			}
			exit(0);
		}
		if (x == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[i][y]<<(i-1));
			}
			m1[tmp] = 0;
		}
		if (y == n) {
			long long tmp = 0;
			for (int i = 1; i <= n; i++) {
				tmp = tmp | (mp[x][i]<<(i-1));
			}
			m2[tmp] = 0;
		}
		mp[x][y] = -1;
		cnt[1][x][1]--;
		cnt[2][y][1]--;
	}
}
int main () {
	cin >> n;
	for (int i = 0; i <= n+1; i++) {
		for (int j = 0; j <= n+1; j++) {
			mp[i][j] = -1;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			char ch;
			cin >> ch;
			if (ch == '1') {
				mp[i][j] = 1;
				cnt[1][i][1]++;
				cnt[2][j][1]++;

			}else if (ch == '0'){
				mp[i][j] = 0;
				cnt[1][i][0]++;
				cnt[2][j][0]++;
			}
		}
	}
	dfs(1,1);
	return 0;
}
```

---

## 作者：A_small_WA (赞：2)

这题和[数独](https://www.luogu.com.cn/problem/P1784)很像，但规则有点复杂，我们一个一个来分析。

> 所有的空白位置都需要放置一个数字 $0/1$

简单地dfs棋盘的每个格子，如果这个格子是空的，就填入 $0$ 或 $1$。

> 在水平或者垂直方向上，相同的数字不可以连续出现大于两次；

这条一开始我是放在最后判的，但是 [TLE](https://www.luogu.com.cn/record/174987179) 了，所以建议写个 ```check``` 函数每填一个空就判断一次。

> 每一行和每一列上，数字 $1$ 和数字 $1$ 的数量必须是相等的 (例如 $N=4$，则表示每一行/列中都需要有 $2$ 个 $0$ 和 $2$ 个 $1$)；

这个可以用来剪枝，如果当前这个空所在的行或列上的 $0$ 的个数大于等于 $n\div2$，那么就只能填 $1$，反之只能填 $0$。

> 每一行都是唯一的，因此每一行都不会和另一行完全相同；同理每一列也都是唯一的，每一列都不会和另一列完全相同。

这个就真的只能放在最后判断了。

运用以上的方法，基本就能把本题的模板打出来了，但细节部分要处理的还是挺多的（就比如我把横坐标和纵坐标打反了，调了 $20$ 分钟......）

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
//h1,h2,l1,l2分别表示每一行，每一列0的个数和1的个数。
int mp[100][100],n,mx,h1[15],h2[15],l1[15],l2[15];
//判断每行有没有连续三个相同的数（第二条）
bool check(int t){
	int cnt1=0,cnt0=0;
	for(int i=1;i<=n;i++){
		if(mp[t][i]==1) cnt1++,cnt0=0;
		else if(mp[t][i]==0) cnt0++,cnt1=0;
		else cnt0=0,cnt1=0;
		if(cnt1==3||cnt0==3) return 0;
	}
	return 1;
}
//判断每列有没有连续三个相同的数（第二条）
bool check1(int t){
	int cnt1=0,cnt0=0;
	for(int i=1;i<=n;i++){
		if(mp[i][t]==1) cnt1++,cnt0=0;
		else if(mp[i][t]==0) cnt0++,cnt1=0;
		else cnt0=0,cnt1=0;
		if(cnt1==3||cnt0==3) return 0;
	}
	return 1;
}
//判断有没有重复的行（第四条）
bool check2(int a,int b){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(mp[a][i]==mp[b][i]) ans++;
	}
	return ans==n;
}
//判断有没有重复的列（第四条）
bool check3(int a,int b){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(mp[i][a]==mp[i][b]) ans++;
	}
	return ans==n;
}
void dfs(int x,int y){
	if(y>n){
		if(!check(x)) return;
		x++,y=1;
		if(x>n){
			for(int i=1;i<=n;i++){
				if(!check1(i)) return;
				for(int j=1;j<=n;j++){
					if(j!=i){
						if(check2(i,j)) return;
						if(check3(i,j)) return;
					}
				}
			}
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					cout<<mp[i][j];
				}
				cout<<'\n';
			}
			exit(0);
		}
	}
	if((!check(x))||(!check1(y))) return;
	if(mp[x][y]!=-1){
		dfs(x,y+1);
		return;
	}
	if(h1[x]<mx&&l1[y]<mx){
		h1[x]++,l1[y]++;
		mp[x][y]=0;
		dfs(x,y+1);
		h1[x]--,l1[y]--;
		mp[x][y]=-1;
	}
	if(h2[x]<mx&&l2[y]<mx){
		h2[x]++,l2[y]++;
		mp[x][y]=1;
		dfs(x,y+1);
		h2[x]--,l2[y]--;
		mp[x][y]=-1;
	}
	return;
}
int main(){
	cin>>n;
	mx=n/2;
	char c;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>c;
			if(c=='_') mp[i][j]=-1;
			else{
				bool tmp=c-'0';
				if(!tmp){
					h1[i]++,l1[j]++;
					mp[i][j]=0;
				}else{
					h2[i]++,l2[j]++;
					mp[i][j]=1;
				}
			}
		}
	}
	dfs(1,1);
	return 0;
}
```
这是蒟蒻的第 $12$ 篇题解，感谢观看。

---

## 作者：big_super_plum (赞：1)

# 洛谷 P10419 题解

## 前言
[P12139](https://www.luogu.com.cn/problem/P12139) 与此题题意相同，而且只要求填写一个具体例子，便于亲自尝试以思考解法。

讨论区也有该游戏的网站：[01游戏](https://0hh1.com/)，在此一并贴出。
## 题意
[原题链接](https://www.luogu.com.cn/problem/P10419)

填写一个只包含 $0$ 和 $1$ 的数独，要求：

1. 每行、每列中 $0$ 和 $1$ 的数量相等；

2. 同行、同列不能出现连续三个 $0$ 或 $1$；

3. 每一行（列）不与另一行（列）完全相同。

保证答案唯一。

## 分析
简单地看，每个 `_` 只能填 $0$ 或 $1$，因此我们可以枚举出所有的情况，然后再根据要求判断是否成立。但就算 $N \le 10$，指数级算法也还是难以接受。然后我想到了以下办法：
- 预处理

观察输入样例：
```Latex
_0____
____01
__1__1
__1_0_
______
__1___
```
第三列已经有三个 $1$，故剩下的位置只能填 $0$；

第五列出现 `0_0`，由于不能出现连续三个 $0$，故中间的空只能填 $1$；

第六列出现 `_11_`，由于不能出现连续三个 $1$，故左右两边的空只能填 $0$；

也就是说，我们可以用“均等”“不连续”两条规则，先把能确定的空填下来，再去枚举。事实上，这么做直接能够完成样例。

但 [P12139](https://www.luogu.com.cn/problem/P12139) 的例子却不行。可以亲自尝试，发现到某一处时必须先假定填入某个数，在后续的推导中才能发现矛盾。这样看来，预处理的优化并不能起到太多作用，于是我们回到最经典的操作：

- 搜索

题目要求找到唯一的填写方式，故采用 dfs 进行搜索。

下面我们记第 $i$ 行第 $j$ 列的格子为 $(i,j)$。

思路很简单：从 $(1,1)$ 开始，如果此处还没有填，则通过三条要求，判断此处是否可填入 $0$ 或 $1$。如果可填入，再来到下一个格子。如果不可填入，则进行回溯；如果此处已经有数，则直接来到下一个格子。

需要注意的是，当 $j>n$ 时需要跳到下一行的第一位，当 $i>n$ 时需要结算输出。

接下来我们尝试将要求翻译成代码：

1. 该条件对每行（列）中 $0$ 和 $1$ 的数量有要求。

我们可以开四个数组，分别记录各行（列）中 $0$ 和 $1$ 的个数。

假设现在要填 $(x,y)$，先尝试填入 $1$，我们就判断第 $x$ 行中 $1$ 的个数是否小于 $\frac{n}{2}$，以及第 $y$ 列中 $1$ 的个数是否小于 $\frac{n}{2}$。若这两个条件都满足，则第一个要求成立。否则尝试填入 $0$，再不然便回溯；

2. 该条件对 $0$ 和 $1$ 的连续性有要求。

假设现在要填 $(x,y)$，先尝试填入 $1$，我们可以以 $(x,y)$ 为中心，判断它是否在连续的三个格子里：
```Latex
   ?
   ?
??[ ]??
   ?
   ?
```
上图中，`[ ]` 表示 $(x,y)$，`?` 表示一个格子。我们寻找包含 `[ ]` 的所有连续的三个格子，然后逐一验证。具体代码如下：
```cpp
bool is_three(int x,int y,char c){//判断在(x,y)处是否能填入c
    if (mop[x][y-1]==c && mop[x][y-2]==c)// ?
        return true;//                      ?
//                                         [ ]

    if (mop[x][y+1]==c && mop[x][y-1]==c)// ?
        return true;//                     [ ]
//                                          ?

    if (mop[x][y+2]==c && mop[x][y+1]==c)//[ ] 
        return true;//                      ? 
//                                          ?

    if (mop[x-1][y]==c && mop[x-2][y]==c)// ? ? [ ]
        return true;        
    if (mop[x+1][y]==c && mop[x-1][y]==c)// ? [ ] ?
        return true;
    if (mop[x+2][y]==c && mop[x+1][y]==c)// [ ] ? ?
        return true;
    return false;    
}
```
3. 该条件用于判断各行（列）之间的关系。

由于没有限制到具体某个位置，故不必每填到一个新的格子时都判断该要求是否成立。

假设现在要填 $(x,y)$，当 $x=n\space(y=n)$ 时，分别再判断第 $y$ 列（第 $x$ 行）是否与前面的列（行）重复即可。

需要注意的是，即使这个格子已经有数，也需要进行判断。~~（本蒟蒻好几次写挂就是在这里）~~

具体代码如下：
```cpp
bool repeat(int x,int y,char c){//判断在(x,y)处是否能填入c
    if (y==n){//已经填到一行的最后一个，判断是否与前面的行有重复
        for (int i=1;i<=x-1;i++){
            cnt=0;
            for (int j=1;j<=n-1;j++){
                if (mop[x][j]!=mop[i][j])
                    break;//只要有一个不一样，便不重复
                cnt++;//有一个相同便+1
            }
            if (c!=mop[i][n])//判断最后一个
                continue;
            if (cnt==n-1)//前面n-1个都相同，且最后一个也相同
                return true;
        }
    }
    if (x==n){//已经填到一列的最后一个，判断是否与前面的列有重复
        for (int i=1;i<=y-1;i++){
            cnt=0;
            for (int j=1;j<=n-1;j++){
                if (mop[j][y]!=mop[j][i])
                    break;//只要有一个不一样，便不重复
                cnt++;//有一个相同便+1
            }
            if (c!=mop[n][i])//判断最后一个
                continue;
            if (cnt==n-1)//前面n-1个都相同，且最后一个也相同
                return true;
        }
    }
    return false;
}
```
至此，我们完成了对要求的翻译工作。
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,sr1[15],sr0[15],sc1[15],sc0[15];//s代表sum，r代表row，c代表column，sr1[i]代表第i行中1的个数，其余同理
char mop[15][15];//数独
bool repeat(int x,int y,char c){
    if (y==n){
        for (int i=1;i<=x-1;i++){
            cnt=0;
            for (int j=1;j<=n-1;j++){
                if (mop[x][j]!=mop[i][j])
                    break;
                cnt++;
            }
            if (c!=mop[i][n])
                continue;
            if (cnt==n-1)
                return true;
        }
    }
    if (x==n){
        for (int i=1;i<=y-1;i++){
            cnt=0;
            for (int j=1;j<=n-1;j++){
                if (mop[j][y]!=mop[j][i])
                    break;
                cnt++;
            }
            if (c!=mop[n][i])
                continue;
            if (cnt==n-1)
                return true;
        }
    }
    return false;
}
bool is_three(int x,int y,char c){
    if (mop[x][y-1]==c && mop[x][y-2]==c)
        return true;
    if (mop[x][y+1]==c && mop[x][y-1]==c)
        return true;
    if (mop[x][y+2]==c && mop[x][y+1]==c) 
        return true;
    if (mop[x-1][y]==c && mop[x-2][y]==c)
        return true;        
    if (mop[x+1][y]==c && mop[x-1][y]==c)
        return true;
    if (mop[x+2][y]==c && mop[x+1][y]==c)
        return true;
    return false;    
}   
void dfs(int x,int y){
    if (x>n){//已完成
        for (int i=1;i<=n;i++){
            for (int j=1;j<=n;j++){
                cout << mop[i][j];
            }
            cout << endl;
        }
        return;
    }
    if (y>n)//跳到下一行
        dfs(x+1,1);
    if (y==n && mop[x][y]!='_'){//即使已经有数，也需要判断重复性
        for (int i=1;i<=x-1;i++){
            cnt=0;
            for (int j=1;j<=n-1;j++){
                if (mop[x][j]!=mop[i][j])
                    break;
                cnt++;
            }
            if (mop[x][y]!=mop[i][n])
                continue;
            if (cnt==n-1)
                return;
        }
    }
    if (x==n && mop[x][y]!='_'){
        for (int i=1;i<=y-1;i++){
            cnt=0;
            for (int j=1;j<=n-1;j++){
                if (mop[j][y]!=mop[j][i])
                    break;
                cnt++;
            }
            if (mop[x][y]!=mop[n][i])
                continue;
            if (cnt==n-1)
                return;
        }
    }    
    if (mop[x][y]=='0' || mop[x][y]=='1')//这个格子已经有数，去填下一个格子
        dfs(x,y+1);
    if (mop[x][y]=='_'){
        if (sr1[x]<n/2 && sc1[y]<n/2 && !is_three(x,y,'1') && !repeat(x,y,'1')){
            mop[x][y]='1';
            sr1[x]++;
            sc1[y]++;
            dfs(x,y+1);
            sr1[x]--;
            sc1[y]--; 
            mop[x][y]='_';
        }
        if (sr0[x]<n/2 && sc0[y]<n/2 && !is_three(x,y,'0') && !repeat(x,y,'0')){
            mop[x][y]='0';
            sr0[x]++;
            sc0[y]++;
            dfs(x,y+1);
            sr0[x]--;
            sc0[y]--;
            mop[x][y]='_';
        }
    }
}
int main(){
    cin >> n;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            cin >> mop[i][j];
            if (mop[i][j]=='1'){
                sr1[i]++;
                sc1[j]++;    
            }
            if (mop[i][j]=='0'){
                sr0[i]++;
                sc0[j]++;
            }          
        }
    }
    dfs(1,1);
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/226521656)
## PS
此为蒟蒻的第一篇题解，欢迎各位提出改进建议 QAQ。

纯搜索题感觉跟模拟差不多了 QAQ，调了一晚上……

---

## 作者：doby (赞：1)

DFS，然后剪枝。  
首先可以把初始棋盘可以填的地方先填上，比如 $\_11\_$ 填成 $0110$，$1\_1$ 填成 $101$。  
然后，排出长度为 $n$ 并且没有连续三个数字相同的所有 $01$ 串，和初始棋盘的每一行比较之后用 $vector$ 存和已经确定的位置没有冲突的情况。为了方便存取和判断，第 $i$ 列乘上 $2^{n-i}$ 压成一个数。   
最后直接一行行填就行了，边填边统计每一列上 $1$ 的个数，确定无解的时候及时回溯就行了。  
我还记得我在考场上写了个一位位填的DFS，还没剪枝，T得很稳健。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,tot,ok,a[20][20],b[20],p[110],d[110],c[20],l[20],ls[20];
char s[20];
vector<int>ab[20];
void Print()
{
	for(int i=1;i<=n;++i)
	{
		for(int j=n-1;j>=0;--j){printf("%d",(b[i]>>j)&1);}
		puts("");
	}
}
void DFS(int step)
{
	if(step>n)
	{
		for(int i=1;i<=n;++i)
		{
			if(l[i]^(n>>1)){return;}
			ls[i]=0;
		}
		for(int i=1;i<=n;++i)//每列是否重复只能填完再判断
		{
			for(int j=1;j<=n;++j){ls[j]+=((b[i]>>(n-j))&1)<<(i-1);}
		}
		sort(ls+1,ls+n+1);
		for(int i=1;i<n;++i)
		{
			if(ls[i]==ls[i+1]){return;}
		}
		Print();
		exit(0);
	}
	for(int i=0;i<ab[step].size();++i)
	{
		if(d[ab[step][i]]){continue;}//行重复了
		int now=p[ab[step][i]];
		if(step>=3)
		{
			ok=1;
			for(int j=n-1;j>=0;--j)
			{
				if(((b[step-2]>>j)&1)==((b[step-1]>>j)&1)&&((b[step-1]>>j)&1)==((now>>j)&1)){ok=0;break;}
				if(l[n-j]+((now>>j)&1)>(n>>1)||l[n-j]+((now>>j)&1)+(n-step)<(n>>1)){ok=0;break;}//已经确定0/1多了
			}
			if(!ok){continue;}
		}
		for(int j=n-1;j>=0;--j){l[n-j]+=(p[ab[step][i]]>>j)&1;}
		b[step]=now,
		++d[ab[step][i]];
		DFS(step+1);
		for(int j=n-1;j>=0;--j){l[n-j]-=(p[ab[step][i]]>>j)&1;}
		b[step]=0,
		--d[ab[step][i]];
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<(1<<n);++i)
	{
		tot=0;
		for(int j=0;j<n;++j)
		{
			tot+=(i>>j)&1,
			c[j]=(i>>j)&1;
		}
		if(tot==n>>1)
		{
			ok=1;
			for(int j=0;j+2<n;++j)
			{
				if(c[j]==c[j+1]&&c[j+1]==c[j+2]){ok=0;break;}
			}
			if(ok){p[++cnt]=i;}
		}
	}
	for(int i=0;i<=n+2;++i)
	{
		for(int j=0;j<=n+2;++j){a[i][j]=-1;}
	}
	for(int i=1;i<=n;++i)
	{
		scanf("%s",s+1);
		for(int j=1;j<=n;++j)
		{
			if(s[j]>=48&&s[j]<=49){a[i][j]=s[j]&15;}
		}
	}
	for(int k=1;k<=n;++k)//每次填完都可能有新的位置可以填，多填几次
	{
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=n;++j)
			{
				if(a[i][j]==-1){continue;}
				if(a[i][j]==a[i+2][j]){a[i+1][j]=a[i][j]^1;}
				if(a[i][j]==a[i][j+2]){a[i][j+1]=a[i][j]^1;}
				if(a[i][j]==a[i+1][j]){a[i-1][j]=a[i+2][j]=a[i][j]^1;}
				if(a[i][j]==a[i][j+1]){a[i][j-1]=a[i][j+2]=a[i][j]^1;}
			}
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=cnt;++j)
		{
			ok=1;
			for(int k=n-1;k>=0;--k)
			{
				if(a[i][n-k]==-1){continue;}
				if(a[i][n-k]^((p[j]>>k)&1)){ok=0;break;}
			}
			if(ok){ab[i].push_back(j);}
		}
	}
	DFS(1);
	return 0;
}
```

---

## 作者：安洛 (赞：0)

这道题的题目数据比较弱，虽然生成二进制数然后按行填入的方法比较快，但是用一位一位填数的方法也能过洛谷的评测。

剪枝技巧非常简单：
1. 记录每一行和每一列 $0$ 和 $1$ 的个数，仅当有余量的时候允许填 $0$ 或者填 $1$。
2. 在每行填完的时候进行合法性检查：
     1. 检查当前行是否有连续3个 $0$ 或 $1$；
     2. 检查是否有行重复；
     3. 检查已经填入的数字中，是否有某一列出现了重复的 $0$ 或 $1$。

我最开始实现的时候为了追求更快的剪枝，还希望在每填一个数的时候，通过检查该位置前后的数字，来确保该位置只填入合法的数字。比如，如果该位置前面已经有两个 $0$ 了，就直接填 $1$。但是实际实现下来这需要考虑非常多的情况，仅单个数字出现重复的情况就有6种，还要考虑到两个数字都出现重复的情况，比如 $11\_00$。这样子判断条件就很复杂，很容易出错，而且效果不理想。经验教训就是不要考虑太过复杂，收益也不高的剪枝吧。

最后附上代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN = 11;
struct coord
{
    int x, y;
    coord move(int n) const
    {
        if (y < n - 1)
            return {x, y + 1};
        else
            return {x + 1, 0};
    }
};
char a[MAXN][MAXN];
int r[MAXN][2], c[MAXN][2];
int n;
bool checkc()
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < i; j++)
        {
            bool flag = true;
            for (int k = 0; k < n; k++)
            {
                if (a[k][i] != a[k][j])
                {
                    flag = false;
                    break;
                }
            }
            if (flag)
                return false;
        }
    }
    return true;
}
bool checkr(int r)
{
    for (int k = 0; k <= r - 2; k++)
    {
        for (int i = 0; i < n; i++)
            if (a[k][i] == a[k + 1][i] && a[k][i] == a[k + 2][i])
                return false;
    }
    for (int i = 0; i < r; i++)
    {
        if (strcmp(a[i], a[r]) == 0)
            return false;
    }
    for (int j = 0; j < n - 2; j++)
    {
        if (a[r][j + 1] == a[r][j + 2] && a[r][j] == a[r][j + 1])
            return false;
    }
    return true;
}
bool dfs(coord coo)
{
    // 递归出口
    if (coo.x == n && coo.y == 0)
    {
        return checkr(coo.x-1) && checkc();
    }
    // 完成一行，进行行查重
    if (coo.y == 0 && coo.x > 0)
    {
        if (!checkr(coo.x - 1))
            return false;
    }
    // 该位置已固定
    if (a[coo.x][coo.y] != '_')
    {
        return dfs(coo.move(n));
    }
    if (r[coo.x][0]>0 && c[coo.y][0]>0)
    {
        char bak = a[coo.x][coo.y];
        a[coo.x][coo.y] = '0';
        r[coo.x][0]--;
        c[coo.y][0]--;
        if (dfs(coo.move(n)))
            return true;
        r[coo.x][0]++;
        c[coo.y][0]++;
        a[coo.x][coo.y] = bak;
    }
    if (r[coo.x][1]>0 && c[coo.y][1]>0)
    {
        char bak = a[coo.x][coo.y];
        a[coo.x][coo.y] = '1';
        r[coo.x][1]--;
        c[coo.y][1]--;
        if (dfs(coo.move(n)))
            return true;
        r[coo.x][1]++;
        c[coo.y][1]++;
        a[coo.x][coo.y] = bak;
    }
    return false;
}
int main()
{
    cin >> n;
    for (int i = 0; i < n; i++)
        r[i][0] = r[i][1] = c[i][0] = c[i][1] = n / 2;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
            cin >> a[i][j];
            if (a[i][j] == '0')
            {
                r[i][0]--;
                c[j][0]--;
            }
            if (a[i][j] == '1')
            {
                r[i][1]--;
                c[j][1]--;
            }
        }
    dfs({0, 0});
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
            putchar(a[i][j]);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：Error_Eric (赞：0)

### Statement

[Link](https://www.luogu.com.cn/problem/P10419)

### Solution

提供一个 Java 的参考答案。原理和其他题解差不多。

首先预处理可能的行并且压位。

读入地图之后将已经填好 0 和填好 1 的位置分别压位到两个二维数组 ``map0`` 和 ``map1`` 中。然后逐行 dfs。期间用位运算判断合法。注意限制条件有些多不要读题读漏了。

### Code

```java
import java.util.*;
import java.io.*;
import java.math.*;
public class Main{
    private static ArrayList<Integer> L = new ArrayList<Integer>();
    private static ArrayList<Integer> Cmap = new ArrayList<Integer>();
    private static int n = 0, okay = 0;
    private static void dfs1(int pos,int used,int cur){
        //System.out.println("?"+cur);
        if(pos == n && used == (n>>1)){
            L.add(cur);
            return;
        }
        if((n>>1)- used < n - pos && ( (cur&3) !=0||pos<2))
            dfs1(pos+1,used,(cur<<1));
        if(used < (n>>1) && (cur&3)!=3 )
            dfs1(pos+1,used+1,(cur<<1)|1);
    }
    private static void test(){
        for(Integer px: Cmap){
            String curs = Integer.toString(px,2);
            while(curs.length() < n) 
                curs = "0" + curs;
            System.out.println(curs);
        }
    }
    private static boolean check(){
        int[] cnt = new int[n];
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                if((Cmap.get(i) & (1<<j))>0)
                    cnt[j] ++;
        for(int i = 0; i < n; i++){
            if(cnt[i] != (n>>1))
                return false;
        }
        int[] col = new int[n];
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++){
                col[j]<<=1;
                col[j]|=((Cmap.get(i)>>j)&1);
            }
        for(int i = 0; i < n; i++)
            for(int j = 0; j < i; j++)
                if(col[j] == col[i])
                    return false;
        return true;
    }
    private static void dfs2(int pos,int[] map1,int[] map0){
        if(okay == 1)
            return;
        if(pos == n && check()) {
            test();
            okay = 1;
        }
        if(pos == n) return;
        for(Integer lx : L){
            if(Cmap.contains(lx)) continue;
            if((lx&map1[pos])!=map1[pos]) continue;
            if(((~lx)&map0[pos])!=map0[pos]) continue;
            if(pos>=2){
                if((Cmap.get(pos-1) & Cmap.get(pos-2) & lx)>0)
                    continue;
                if((Cmap.get(pos-1) | Cmap.get(pos-2) | lx) != ((1<<n)-1))
                    continue;
            }
            Cmap.add(lx);
            dfs2(pos+1,map1,map0);
            Cmap.remove(pos);
        }
    }
    public static void main(String[] args){
        Scanner cin = new Scanner(System.in);
        n = cin.nextInt(); cin.nextLine();
        dfs1(0, 0, 0);
        int[] mmap1 = new int[n], mmap0 = new int[n];
        for(int i = 0; i < n; i++){
            String mx = cin.nextLine();
            for(int j = 0; j < n; j++){
                mmap1[i]<<=1;
                mmap0[i]<<=1;
                if(mx.charAt(j) == '1')
                    mmap1[i] |=1;
                else if(mx.charAt(j) == '0')
                    mmap0[i] |=1;
            }
        }
        dfs2(0, mmap1, mmap0);
    }
}
```

---

## 作者：andyli (赞：0)

dfs 剪枝，先记录空白位置的坐标。每次依次尝试填入 $0/1$，设填入的坐标为第 $x$ 行第 $y$ 列，对第 $x$ 行和第 $y$ 列分别做如下检查以保证方案合法：  
1. 当前行或列已经填入的 $0/1$ 数量是否超过限制以及最大连续的 $0/1$ 数量是否满足要求。
2. 若当前行或列变为填满状态，检查是否与其他行或列重复。

由于检查行和列的操作实现十分相似，可只实现一次。  

```cpp
int main() {
    dR(int, n);
    dRV(str, s, n);
    vc<pi> empty;
    vi cnt_r(n), cnt_c(n);
    _for (i, n) {
        _for (j, n) {
            if (s[i][j] == '_')
                empty.eb(i, j);
            else {
                cnt_r[i]++;
                cnt_c[j]++;
            }
        }
    }
    auto check = [&](auto&& f, char c) {
        int cnt = 0, max = 0, tot = 0;
        _for (i, n) {
            if (f(i) == c) {
                chkmax(max, ++cnt);
                tot++;
            }
            else {
                cnt = 0;
            }
        }
        return tot <= n / 2 && max <= 2;
    };
    auto check_r = [&](int x) {
        return check([&](int y) { return s[x][y]; }, '0') && check([&](int y) { return s[x][y]; }, '1');
    };
    auto check_c = [&](int y) {
        return check([&](int x) { return s[x][y]; }, '0') && check([&](int x) { return s[x][y]; }, '1');
    };
    std::set<int> r, c;
    auto insert = [&](auto&& st, auto&& f) {
        int x = 0;
        _for (i, n)
            x = x * 2 + (f(i) == '1');
        return st.insert(x).second;
    };
    auto insert_r = [&](int x) {
        return insert(r, [&](int y) { return s[x][y]; });
    };
    auto insert_c = [&](int y) {
        return insert(c, [&](int x) { return s[x][y]; });
    };
    auto erase = [&](auto&& st, auto&& f) {
        int x = 0;
        _for (i, n)
            x = x * 2 + (f(i) == '1');
        return st.erase(x);
    };
    auto erase_r = [&](int x) {
        return erase(r, [&](int y) { return s[x][y]; });
    };
    auto erase_c = [&](int y) {
        return erase(c, [&](int x) { return s[x][y]; });
    };
    auto dfs = [&](auto&& dfs, int k) {
        if (k == len(empty)) {
            print(s);
            return;
        }
        auto [x, y] = empty[k];
        cnt_r[x]++, cnt_c[y]++;
        for (char c: {'0', '1'}) {
            s[x][y] = c;
            if (check_r(x) && check_c(y)) {
                bool full_r = cnt_r[x] == n, full_c = cnt_c[y] == n;
                BLK {
                    if (full_r && !insert_r(x))
                        return;
                    if (full_c && !insert_c(y))
                        return;
                    dfs(dfs, k + 1);
                    if (full_r)
                        erase_r(x);
                    if (full_c)
                        erase_c(y);
                };
            }
        }
        s[x][y] = '_';
        cnt_r[x]--, cnt_c[y]--;
    };
    dfs(dfs, 0);
    return 0;
}
```

---


# [蓝桥杯 2023 国 Python A] 选段排序

## 题目描述

给定一个长度为 $n$ 的序列 $A_i$ 以及两个下标 $p, q(p < q)$。你可以选择任意一个区间 $[L, R]$ 并将序列的这个范围内的元素 $A_L \sim A_R$ 从小到大排序。

求选择一个区间排序后 $A_q − A_p$ 的值最大可以是多少。


## 说明/提示

对于 $20\%$ 的评测用例，$n \le 100 ,A_i \le 200$；

对于 $40\%$ 的评测用例，$n \le 2000 ,A_i \le 3000$；

对于所有评测用例，$1 \le p \le q \le n \le 2 \times 10^5,1 \le A_i \le 10^6$。

## 样例 #1

### 输入

```
5 1 4
4 5 3 3 1
```

### 输出

```
3
```

# 题解

## 作者：cf_x (赞：4)

### 题目大意

给出三个正整数 $n$，$p$，$q$ 和序列 $A_i$，选择一个区间进行排序，求区间排序后 $A_q-A_p$ 最大可以是多少。

### 核心思路

首先我们知道对于区间 $[L,R]$，只要区间没有包含 $p, q$，那么这种排序是无意义的。

因为我们想要让 $A_q-A_p$ 最大，所以我们有两种方式。

- 让 $A_p$ 尽量小。
- 让 $A_q$ 尽量大。

我们先解决让 $A_p$ 尽量小的问题。我们发现对 $[p,r],r\in[p,n]$ 排序是最优的。为什么呢？

- 当最小值的下标在 $[p,n]$ 之间时，如果你排的是 $[p-1,n]$，那么最小值就跑到了 $p-1$ 的位置上，那么答案会变小。所以不是最优的。
- 当最小值的下标在 $[1,p-1]$ 之间时，这个最小值只会在排序区间的最左边，而不能来到 $p$ 的位置上（提示：最小值的下标在 $[1,p-1]$ 之间哦）。

同理，让 $A_p$ 尽量大的问题也是一样的思路。

### 非核心思路

当我们排 $[p, q+1]$ 时。这时，不应该是找最大值，而是次大的，因为最大值在 $q+1$ 上。

其余同理。

### 代码

最后代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5+10;

int n, p, q;
int a[N];
multiset<int, greater<int> > st1; // 可能有重复元素
multiset<int> st2;

signed main() {
    cin >> n >> p >> q;
    for (int i = 1;i<= n;i++) {
        cin >> a[i];
    }
    int ans = a[q]-a[p]; 
    int minn = 2e9;
    for (int i = p;i<= q;i++) {
        minn = min(minn, a[i]);
        st1.insert(a[i]);
        if (i == q) continue;
        ans = max(ans, a[q]-minn);
    } ans = max(ans, (*st1.begin()) - minn);
    int now = *st1.begin();
    for (int i = q+1;i<= n;i++) {
        minn = min(minn, a[i]);
        if (a[i] >= now) {
            ;
        } else {
            st1.insert(a[i]);
            st1.erase(st1.begin());
            now = *st1.begin();
        }
        ans = max(ans, now - minn);
    }
    int maxn = 0;
    for (int i = q;i>= p;i--) {
        maxn = max(maxn, a[i]);
        st2.insert(a[i]);
        if (i == p) continue;
        ans = max(ans, maxn-a[p]);
    } now = *st2.begin();
    ans = max(ans, maxn-now);
    for (int i = p-1;i>= 1;i--) {
        maxn = max(maxn, a[i]);
        if (a[i] <= now) {
        } else {
            st2.insert(a[i]);
            st2.erase(st2.begin());
            now = *st2.begin();
        }
        ans = max(ans, maxn-now);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：yanbinmu (赞：3)

## 题意
给定 $n,p,q$ 和一个数列 $a_i$， 求任选一区间对其进行排序得到的最大 $a_q - a_p$。
## 分析
考虑什么时候能使答案发生改变，显然是 $a_q$ 更大或 $a_p$ 更小。~~废话~~ 

则 $p, q$ 有一个在进行排序的区间里并且刚好在其边缘，即 $l = p$ 或 $r = q$。

那为什么不可以再多几个元素？

先考虑只多一个，即 $l = q - 1$。

如果新加入的元素它比原区间的最小值小，那它只会留在他原本的位置，不会对答案造成影响。

如果比最小值大，那它会使最小值放到它的位置，使答案更劣。

如果它比这个区间的最大值大，那我们期望它会放到 $q$ 上，则为 $r = q$ 的情况。

得证。

## 代码实现
则我们分别固定一个边界，然后去枚举另一个端点，求两个值。

1. 最小值或最大值，我们希望将其放在端点处。
2. 可以放在另一个端点的数，即第 $q - p + 1$ 大或小的数。

### code
Python 题，但是 C++：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[200005];
priority_queue<int, vector<int>, greater<int> > q;
priority_queue<int> Q;
int main() {
	std :: ios :: sync_with_stdio(false);
	std :: cin.tie(nullptr);
	std :: cout.tie(nullptr);
	int n, x, y;
	cin >> n >> x >> y;
	for(int i = 1;i <= n;i ++ ) {
		cin >> a[i];
	}
	int ans = 0;
	int len = y - x + 1;
	int maxn = a[y], minn = a[x];
	Q.push(a[x]);
	for(int i = x + 1;i <= n;i ++ ) {
		minn = min(maxn, a[i]);
		Q.push(a[i]);
		if(Q.size() > len) Q.pop();
		ans = max(ans, Q.top() - minn);
	}
	
	q.push(a[y]);
	for(int i = y - 1;i >= 1;i -- ) {
		maxn = max(maxn, a[i]);
		q.push(a[i]);
		if(q.size() > len) q.pop();
		ans = max(ans, maxn - q.top());
	}
	
	cout << ans;
	return 0;
}
```

---

## 作者：MnZnOIer (赞：2)

#### 前言
真的很水。。。

#### 解题思路
我们想要令 $a_q-a_p$ 尽量的大，显然要么让 $a_q$ 尽量地大，要么让 $a_p$ 尽量地小。我们考虑要排序的区间，一定包括 $p$ 或 $q$，因为如果不包括 $p$ 或 $q$，就跟没操作一样。先考虑包含 $p$ 的区间：要以 $p$ 为左端点，如果不以 $p$ 为左端点，可能会导致 $a_p$ 不小。接下来就是用一个优先队列维护当前区间排序后的 $a_q$ 和 $a_p$ 即可。包含 $q$ 的区间同理。

#### 代码部分

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
priority_queue <int, vector <int>, greater <int> > qn;//小根堆堆顶即为 a[p]。
priority_queue <int> qx;//大根堆堆顶即为 a[q]。
int n, p, q, a[N], ans;
signed main ()
{
    ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
    cin >> n >> p >> q;
    for (int i = 1; i <= n; ++ i)cin >> a[i];
    for (int i = p; i <= n; ++ i)
    {
        qn.push (a[i]);
        if (qx.size () < q - p + 1)qx.push (a[i]);//没有排满区间 [p,q]。
        else if (a[i] < qx.top ())
        {
            qx.pop ();//这个数放进来会导致排序后 a[q] 右移，这样 a[q] 就不在我们的考虑范围内了，出队。
            qx.push (a[i]);
        }
        ans = max (ans, qx.top () - qn.top ());//统计答案。
    }
    while (qx.size ())qx.pop ();//因为要用两次，要记得清空。
    while (qn.size ())qn.pop ();
    for (int i = q; i >= 1; -- i)
    {
        qx.push (a[i]);
        if (qn.size () < q - p + 1)qn.push (a[i]);//同上。
        else if (a[i] > qn.top ())//与上面类似。
        {
            qn.pop ();
            qn.push (a[i]);
        }
        ans = max (ans, qx.top () - qn.top ());
    }
    cout << ans;
    return 0;
}
```
完结撒花！

---

## 作者：fengyaun (赞：2)

##  [P10991  \[蓝桥杯 2023 国 Python A\] 选段排序](https://www.luogu.com.cn/problem/P10991)

### 简化题意

给定 $n, p, q(p < q)$ 对于原数组的连续的一段排序一次，求 $\max(A_q - A_p)$。

### 分析

显然的，$p, q$ 为排序的一段的边界。

因为若 $p, q$ 不为边界，那么原本的最小值便会到第一位，而次小值到第二位，即 $A_p$，显然比原本更劣，证毕。

### 实现

可以考虑到使用优先队列维护。

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;

int n, p, q;

int ans;

int value[N];

int cnt[N];

priority_queue<int> more; // 大根堆

priority_queue<int, vector<int>, greater<int> > Less; // 小根堆

int main()
{   
    cin >> n >> p >> q;
    for (int i = 1; i <= n; i++) // 输入
    {
        cin >> value[i];
        cnt[i] = value[i];
    }
    for (int l = p, r = p, Min = value[l]; r <= n; r++) // 固定左端点枚举
    {
        Min = min(Min, value[r]); // 维护 A[p]
        more.push(value[r]);
        if (more.size() > q - p + 1) // 维护 A[q]
        {
            more.pop();
        }
        ans = max(ans, more.top() - Min); // 求答案
    }
    for (int r = q, l = q, Max = value[r]; l >= 1; l--) // 固定右端点枚举
    {
        Max = max(Max, value[l]); // 维护 A[q]
        Less.push(value[l]);
        if (Less.size() > q - p + 1) // 维护 A[p]
        {
            Less.pop();
        }
        ans = max(ans, Max - Less.top()); // 求答案
    }
    cout << ans; // 输出答案
    return 0;
}

```

---

## 作者：jdfz2251533 (赞：0)

## 题解：P10991 \[蓝桥杯 2023 国 Python A] 选段排序

## 思路

题意已经很简洁明了了，直接说思路。

结论：若最终选择区间是 $\left [ l,r \right]$，则 $l = p$ 或 $r = q$。

**证明**：

若 $l = p$，若 $a_{l-1}$ 是 $\left [ l - 1,r \right]$ 内的最小值，那么排序后的 $a_l$ 不会变，对答案没有贡献，选不选都可以；若 $a_{l-1}$ 不是 $\left [l- 1,r \right]$ 内的最小值，则排序后的 $a_{l-1}$ 是 $\left [ l,r \right]$ 内的最小值，可我们本来想让这个最小值在 $a_l$，那么此时的 $a_l$ 会更大，这会使答案变劣，当然不能选上 $a_{l-1}$。
若 $r = q$，与上同理。

至此，做法就很明确了，分别固定 $l=p$ 和 $r=q$，枚举另一个端点计算答案求最值即可。明确的说，求的是区间最值和区间第 $q-p+1$ 大值。

目前看到的题解都用了优先队列，下面补充一个平衡树的代码，需要实现求区间第 $k$ 大。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e5 + 5;

struct Node {
	int l, r, val, prio, size;
} t[N];
int n, p, q, a[N], ans, cnt, root1, root2;

int new_node(int val) {
	t[++cnt] = {0, 0, val, rand(), 1};
	return cnt;
}

void push_up(int u) {
	t[u].size = t[t[u].l].size + t[t[u].r].size + 1;
}

void split(int u, int x, int &l, int &r) {
	if (!u) {
		l = r = 0;
		return;
	}
	if (t[u].val <= x) {
		l = u;
		split(t[u].r, x, t[u].r, r);
	} else {
		r = u;
		split(t[u].l, x, l, t[u].l);
	}
	push_up(u);
}

void merge(int &u, int l, int r) {
	if (!l || !r) {
		u = l ? l : r;
		return;
	}
	if (t[l].prio > t[r].prio) {
		merge(t[l].r, t[l].r, r);
		u = l;
	} else {
		merge(t[r].l, l, t[r].l);
		u = r;
	}
	push_up(u);
}

void insert(int &root, int val) {
	int l, r;
	split(root, val, l, r);
	merge(l, l, new_node(val));
	merge(root, l, r);
}

int kth(int u, int k) {
	while (u) {
		int left = t[t[u].l].size;
		if (k <= left) {
			u = t[u].l;
		} else if (k == left + 1) {
			return t[u].val;
		} else {
			k -= left + 1;
			u = t[u].r;
		}
	}
	return -1;
}

int main() {
	srand(time(0));
	cin >> n >> p >> q;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = q; i >= p; i--) {
		insert(root1, a[i]);
	}
	if (cnt) {
		ans = kth(root1, cnt) - kth(root1, 1);
	}
	for (int i = p - 1; i >= 1; i--) {
		insert(root1, a[i]);
		int k1 = q - i + 1, k2 = p - i + 1;
		if (k1 > t[root1].size || k2 > t[root1].size) {
			continue;
		}
		ans = max(ans, kth(root1, k1) - kth(root1, k2));
	}
	cnt = 0;
	root2 = 0;
	for (int i = p; i <= q; i++) {
		insert(root2, a[i]);
	}
	if (cnt) {
		ans = max(ans, kth(root2, cnt) - kth(root2, 1));
	}
	for (int i = q + 1; i <= n; i++) {
		insert(root2, a[i]);
		int k = q - p + 1;
		if (k > t[root2].size) {
			continue;
		}
		ans = max(ans, kth(root2, k) - kth(root2, 1));
	}
	cout << ans;
	return 0;
}
```

---

## 作者：_YyD_ (赞：0)

注意到，一定有 $l=p$ 或者 $r=q$。

证明：$l=p-1$，如果 $a_{p-1}$ 小于 $a_p$ 不会产生贡献，否则会使答案更劣。

这样枚举另一个端点，就相当于维护一个集合，每次加入一个元素，求集合内最值和第 $p-q+1$ 最值。

后者可以用一个 priority_queue 维护，加入后若集合大小大于所需值，就 pop 掉。

代码：


```cpp
int n,p,q,k;
int a[N],ans,mx;
priority_queue<int> pq;

void solver(){
	n=read();p=read(),q=read();
	k=q-p+1;
	rep(i,1,n)a[i]=read();
	lep(i,q,1){
		cmax(mx,a[i]);
		pq.push(-a[i]);
		if(pq.size()>k)pq.pop();
		if(i<=p)cmax(ans,mx+pq.top());
	}
	mx=inf;while(pq.size())pq.pop();
	rep(i,p,n){
		cmin(mx,a[i]);
		pq.push(a[i]);
		if(pq.size()>k)pq.pop();
		if(i>=q)cmax(ans,pq.top()-mx);
	}
	write(ans);
}
```

---


# [蓝桥杯 2023 国 Java B] 星球

## 题目描述

小明驾驶飞船对某星系发起攻击。星系中有 $n$ 颗星球，编号依次是 $1, 2, \ldots, n$。第 $i$ 颗星球的坐标为 $(x_i, y_i, z_i)$，且其防御强度为 $w_i$。

小明需要规划出进攻这 $n$ 颗星球的顺序使得其进攻所需能量最少。

对于一个遍历顺序 $p_1, p_2, \ldots, p_n$ 来说，小明进攻需要的能量为 $E = \displaystyle \sum_{i=2}^{n} d(p_{i-1}, p_i) \times w_i$，其中 $d(p_{i-1}, p_i)$ 表示 $p_{i-1}, p_i$ 两颗星球之间的直线距离。小明想知道进攻所需最少能量是多少。

## 说明/提示

### 样例说明

当进攻顺序为 $\{1, 2, 3\}$ 时，所需能量最小，为 $5\sqrt{5} + 3\sqrt{6}$。

### 评测用例规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 8$。
- 对于 $100\%$ 的数据，保证 $n \leq 18$，$0 \leq x_i, y_i, z_i, w_i \leq 100$。

## 样例 #1

### 输入

```
3
4 3 3 5
2 2 3 5
3 1 1 3```

### 输出

```
18.53```

# 题解

## 作者：CommandSR (赞：4)

## 题意简述

我们需要为攻击 $n$ 个星球规划一个顺序，使得总攻击能量最小。总能量的计算方式为：按照攻击顺序，每攻击一个星球时，需要消耗从上一个星球到当前星球的距离乘以当前星球的防御强度。

## 基本思路

首先可以先预处理任意两点间的距离，空间内两点间距离公式 $dis_{i,j} = \sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}$。

注意到 $n \leq 18$，考虑状压 DP。

不妨设 $f_{s,i}$ 为当前状态为 $s$，最后一个到的点为 $i$，所需最少能量是多少。

其中状态 $s$ 是一个 $n$ 位二进制数，对应位为 $1$ 表示到达过，否则表示没到达过。

则状态转移方程：

```cpp
f[s][i] = min(f[s][i], f[s^(1<<i-1)][j]+a[i].w*dis[i][j]);
```

其中 $i,j \in s$ 且 $i \neq j$。

初始状态 $f_{0,0}=0$。

目标状态 $\min{f_{2^n-1, i}}$。

注意特判第一个点，我的处理方式是特判第一个到达的点从 $0$ 转移而来。

## AC Code

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (int i = a; i <= b; ++i)
#define _F(i, a, b) for (int i = a; i >= b; --i)
#define ll long long
#define FULL ((1<<n)-1)
#define inf 1e9
using namespace std;
void rd(ll &x) {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	x = p * f;
}
constexpr int N = 20;
ll n;
struct P {
	ll x, y, z, w;
} a[N];
double dis[N][N];
double calc(int i, int j) {
	return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y)+(a[i].z-a[j].z)*(a[i].z-a[j].z));
}
double f[(1<<18)+5][N];
int main() {
	rd(n); F(i, 1, n) rd(a[i].x), rd(a[i].y), rd(a[i].z), rd(a[i].w);
	F(i, 1, n) F(j, 1, i-1) dis[i][j] = dis[j][i] = calc(i, j);
	F(i, 1, n) dis[0][i] = dis[i][0] = 0;
	F(s, 0, FULL) F(i, 0, n) f[s][i] = inf;
	f[0][0] = 0;
	F(s, 0, FULL) {
		F(i, 1, n) {
			if (!(s&(1<<i-1))) continue ;
			F(j, 0, n) {
				if (!j || (i!=j && (s&(1<<j-1)))) f[s][i] = min(f[s][i], f[s^(1<<i-1)][j]+a[i].w*dis[i][j]);
			}
		}
	}
	double ans = inf;
	F(i, 1, n) ans = min(ans, f[FULL][i]);
	cout << fixed << setprecision(2) << ans << '\n';
	return 0;
}
```

---

## 作者：chen_kun (赞：3)

# 题解：P12220 [蓝桥杯 2023 国 Java B] 星球

## 思路简述

可以看到 $n$ 的范围很小，再好好看看题面，可以发现这是一道典型的旅行商问题变种，只是从二维平面变成了三维立体，考虑使用**状压 DP** 求解。

所谓状压 DP，其精髓在于**状态压缩**，通过将状态转化为二进制的方式进行动态规划，利用二进制中只有 $1$ 和 $0$ 的特性表示某点是否达到某个目的。具体处理不再过多赘述。

定义 $dp_{i,j}$ 为当状态为 $i$，最后到达的点为 $j$ 时的所需的最小能量。通过空间中两点距离公式 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$ 及题目中给到的公式即可得到状态转移方程:

`dp[i][j]=min(dp[i][j],dp[i^(1<<j-1)][k]+dis(a[j].x,a[j].y,a[j].z,a[k].x,a[k].y,a[k].z)*a[j].w);`。

其中 $j$ 代表 $i$ 状态的结束点，$k$ 表示到达 $j$ 之前状态的结束点。

## 代码呈现

### C++


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=20;
int n,m;
double dp[1<<N][N],mmin=DBL_MAX;
struct node{int x,y,z,w;}a[N];
double dis(int x,int y,int z,int xx,int yy,int zz){return sqrt((xx-x)*(xx-x)+(yy-y)*(yy-y)+(zz-z)*(zz-z));}//空间中两点计算公式 
signed main(){
	cin>>n;
    memset(dp,127,sizeof(dp));
	for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y>>a[i].z>>a[i].w,dp[1<<i-1][i]=0;
	dp[0][0];
	int num=1<<n;
	for(int i=0;i<num;i++)
		for(int j=1;j<=n;j++)
			if((i>>j-1)&1)//确保j在状态i中 
				for(int k=1;k<=n;k++)
					if((i>>k-1)&1)//确保k在状态i中 
						dp[i][j]=min(dp[i][j],dp[i^(1<<j-1)][k]+dis(a[j].x,a[j].y,a[j].z,a[k].x,a[k].y,a[k].z)*a[j].w);//利用题目中能量的计算公式进行转移 
    for(int i=1;i<=n;i++) mmin=min(mmin,dp[num-1][i]);//枚举不同的结束点取最小值 
	printf("%.2lf",mmin);
	return 0;
}
```
## The end.

---

## 作者：Tomwsc (赞：3)

# P12220 [蓝桥杯 2023 国 Java B] 星球 题解

## 思路

我们发现 $n$ 的取值很小，所以首先想到的必然是暴力搜索，但经过一番尝试，发现会超时。

此时，如果做过状压 dp 的旅行商问题，则会很容易想到正解——状压 dp。

### 状压 dp

何为状压 dp？即将一些难以存储的状态转换成二进制，用二进制中每一位的 $0/1$ 来表示该位置的状态。然后再把此二进制用十进制存储，这样，我们便可以使用十分迅速的位运算来进行状态转移。

状压 dp 的题目通常具有非常显著的特征。因为二进制能存储的数位很少，所以状压 dp 的数据范围一般都很小，基本上都是十几。

那对于该题，我们如何进行状态压缩呢？

可以这样考虑，设：$dp_{i,j}$ 表示当前攻击到第 $i$ 个点且现在状态为 $j$ 的最少能量。其中 $j$ 是一个二进制转十进制数，如果把它转换成二进制，那么它有 $1$ 的位便表示攻击过，没有则表示还未攻击（该二进制数从低到高位表示星球 $1\sim n$，这是为了方便转移）。举个例子：$110010$ 便表示第二、五和六号星球都攻击过了，而它在 dp 数组中存储的形式便是其十进制形式，即 $50$。

### 状态转移方程

接下来开始推转移方程：

假设将要转移到第 $i$ 号节点。我们不妨借助一下弗洛伊德算法的思想，考虑中间可以到达 $i$ 的点 $j$，且点 $j$ 的状态为 $k$。转移过后，点 $i$ 的状态便为 $k$ 的二进制或第 $i$ 号点所代表的二进制位。注意：$j$ 必须被攻击过，且 $i$ 不能被攻击过。

于是我们便可以得到：

$$dp_{i,k | 2^{i-1}}=\min(dp_{i,k|2^{i-1}},dp_{j,k}+dis(j,i))$$

其中，$dis(a,b)$ 表示 $a$ 到 $b$ 所需要花费的能量。

### dp 的初始化以及最终结果

因为该题目并没有限制第一个需要攻击的星球。所以一开始每个星球的可以做起点。

同理，每个点都可以最终点，所以最后的结果便为 $\min\limits_{1\le i\le n}(dp_{i,2^n-1})$。

为什么最终的状态是 $2^n-1$ 呢？

因为 $2^n-1$ 这个数的二进制从第 $1$ 位到第 $n$ 位都是 $1$，也就是说每个星球都被攻击过。

## 代码

考虑先计算出任意两个星球之间的攻击所需的能量。这可以用空间内两点距离公式实现，即：
$$dis(i,j)=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}$$

不过要记得在这个公式的末尾乘上一个 $w_j$。

接下来就只需要暴力枚举和 dp 了。

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf (1ll << 62)
#define regint register int
#define pb push_back
#define mp make_pair
#define PII pair<int , int>
using namespace std;
const int MAXN = 20;
int n;
double dp[MAXN][1 << 20] , mapp[MAXN][MAXN];
struct Node {
	int x , y , z , w;
};
Node pos[MAXN];

inline double calc(int i , int j) {
	return sqrt(pow(pos[i].x - pos[j].x , 2) + pow(pos[i].y - pos[j].y , 2) + pow(pos[i].z - pos[j].z , 2)) * pos[j].w;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	memset(dp , 0x7f , sizeof(dp));
	cin >> n;
	for(regint i = 1;i <= n;i ++)
		cin >> pos[i].x >> pos[i].y >> pos[i].z >> pos[i].w;
	for(regint i = 1;i <= n;i ++)
		for(regint j = 1;j <= n;j ++)
			if(i != j)
				mapp[i][j] = calc(i , j);
	for(regint i = 1;i <= n;i ++)
		dp[i][1 << i - 1] = 0;
	for(regint k = 1;k <= (1 << n) - 1;k ++)
		for(regint i = 1;i <= n;i ++) {
			if((1 << i - 1) & k)
				continue;
			for(regint j = 1;j <= n;j ++) {
				if(!(1 << j - 1) & k)
					continue;
				dp[i][k | (1 << i - 1)] = min(dp[i][k | (1 << i - 1)] , dp[j][k] + mapp[j][i]);
			}
		}
	double ans = inf;
	for(regint i = 1;i <= n;i ++)
		ans = min(ans , dp[i][(1 << n) - 1]);
	cout << fixed << setprecision(2) << ans;
	return 0; 
}
```

---

## 作者：Liliangxi (赞：2)

# [P12220 [蓝桥杯 2023 国 Java B] 星球](https://www.luogu.com.cn/problem/P12220)

## 1eps 闲话

最近感觉自己的 dp 太弱了，尤其是状压之类的，所以就刷到了这道题，交一发题解记录一下。

## 引

刚看到~~标签~~这道题，联系**数据范围 $1 \le n \le 18$**，以及最终要**所有点都计算**到，即**一个排列**（至于为什么可以，可以参考许多与这道题类似的题：[P10447 最短 Hamilton 路径](https://www.luogu.com.cn/problem/P10447)），可以往状态压缩方面考虑（不知道有没有其他的做法）.

又可以比较容易~~通过标签~~发现对于**一个排列的答案计算，可以将每次拆开来，不需要将排列完全写出来后再计算结果**，这就可以 dp 了（应该可以叫做无后效性），联系前面分析的状态压缩，可以自然想到状态压缩 dp，简称状压 dp。

## 状压 dp

主要是蒟蒻的一些想法，非常入门和基础，大神跳过即可。

刚开始接触到状压 dp，感觉很神奇，可以说是状态压缩和 dp 拼在一起。

比较常见的状态压缩就是二进制状压了，通常情况下可以把题目的一种条件转换成状态，比如 $0$ 代表选，$1$ 代表不选，那么就可以有很多很牛的操作了，比如把一张比较小的二维矩阵转化成一维进行操作，比如这道题：[P10449 费解的开关](https://www.luogu.com.cn/problem/P10449)，同样，也可以利用状态压缩辅助搜索，极大减少空间复杂度。

## solution

前文已经分析了这道题用状压 dp 解决的原因，那么现在具体来分析做法。首先给出 $n$ 维空间下两点的直线距离公式：

对于 $n$ 维空间下的点 $P_1(x_{11}, x_{12}, x_{13}, x_{14}...x_{1n})$ 和点 $P_2(x_{21}, x_{22}, x_{23}, x_{24}...x_{2n})$，两者的直线距离：

$d(P_1, P_2) = \sqrt{\sum_{i=1}^{n} (x_{1i} - x_{2i}) ^ 2}$

注：为了方便，本人以下代码的下标均从 $0$ 开始。

变量用途：

```cpp
constexpr int N = 21;

struct node
{
    int x, y, z;
}a[N];           //存贮每个点的下标
int n;           //点数
int w[N];        //防御强度
dou ans = 1e9;   //最终输出的答案
dou dp[N][1 << N];   //dp[i][j] 表示当前在第 i 个星球，已经访问过的星球集合是 j，此时的最小能量消耗
```


那么，我们可以比较容易的写出题目中式子的前半部分，后半部分在转移的时候乘上就好了：

```cpp
dou get_dis(node x, node y)
{
    return sqrt((x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y) + (x.z - y.z) * (x.z - y.z));
}
```

既然要求最小值，那么先赋最大值：

```cpp
for (int i = 0; i < n; i++)
{
    for (int j = 0; j < (1 << n); j++)
    {
        dp[i][j] = 1e9;
    }
}
```

观察到计算两点之间的能量所乘 $w_i$ 是来自后面一个，这也是前文
> 那么，我们可以比较容易的写出题目中式子的前半部分，后半部分在转移的时候乘上就好了：

这样做的原因。所以初始化当前点且此时只有这个点的状态：

```cpp
for (int i = 0; i < n; i++)
{
    dp[i][(1 << i)] = 0;
}
```

转移：

```cpp
for (int i = 0; i < (1 << n); i++)
{
    for (int s = 0; s < n; s++)
    {
        if(!((i >> s) & 1)) continue;    //剪枝，若状态都不包含这个点，那肯定不行，下同
        for (int t = 0; t < n; t++)
        {
            if(!((i >> t) & 1) || s == t) continue;
            dp[t][i] = min(dp[t][i], dp[s][i - (1 << t)] + get_dis(a[s], a[t]) * (1.00 * w[t]));   //应该不难理解
        }
    }
}
```

注意，此题没有要求最后在哪个点，所以要遍历一遍统计：

```cpp
for (int i = 0; i < n; i++)
{
    ans = min(ans, dp[i][(1 << n) - 1]);
}
cout << fixed << setprecision(2) << ans << endl;
```

输出可以学习以下，本人感觉比较好用。

## Code

纯净版，码风不好看。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define lll unsigned long long
#define dou long double
#define St string
#define pi pair<int, int>
#define mkp make_pair
#define PI acos(-1)
#define eps 1e-10
#define endl "\n"
#define INF 2147483647
#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
using namespace std;

constexpr int N = 21;

struct node
{
    int x, y, z;
}a[N];
int n;
int w[N];
dou ans = 1e9;
dou dp[N][1 << N];


dou get_dis(node x, node y)
{
    return sqrt((x.x - y.x) * (x.x - y.x) + (x.y - y.y) * (x.y - y.y) + (x.z - y.z) * (x.z - y.z));
}

signed main()
{
    IOS;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int x, y, z;
        cin >> x >> y >> z >> w[i];
        a[i] = (node){x, y, z};
    }
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < (1 << n); j++)
        {
            dp[i][j] = 1e9;
        }
    }
    for (int i = 0; i < n; i++)
    {
        dp[i][(1 << i)] = 0;
    }
    for (int i = 0; i < (1 << n); i++)
    {
        for (int s = 0; s < n; s++)
        {
            if(!((i >> s) & 1)) continue;
            for (int t = 0; t < n; t++)
            {
                if(!((i >> t) & 1) || s == t) continue;
                dp[t][i] = min(dp[t][i], dp[s][i - (1 << t)] + get_dis(a[s], a[t]) * (1.00 * w[t]));
            }
        }
    }
    for (int i = 0; i < n; i++)
    {
        ans = min(ans, dp[i][(1 << n) - 1]);
    }
    cout << fixed << setprecision(2) << ans << endl;
    return 0;
}
/*
我是milk dragon
*/
```

## end

感谢能看到这边，点个赞再走吧。

---

## 作者：Ahws_rwhy (赞：2)

### 题意简述

小明需要按最优顺序攻击 $n$ 个星球，使得总能量消耗最小。每个星球有坐标 $(x,y,z)$ 和防御强度 $w$，总能量计算公式为：$
E=\Sigma^{n}_{i=2}d(p_i−1,p_i)×w_i$，其中 $d$ 是两点间欧几里得距离。求最小的 $E$，结果保留两位小数。

### 解题思路:

这是一个经典的旅行商问题（TSP）变种。TSP 问题的核心是找到遍历所有点并回到起点的最短路径，而本题的不同之处在于：

- 不需要回到起点。

- 路径代价不是简单累加距离，而是每个步骤的距离乘以终点的防御强度。


暴力枚举：时间复杂度为 $\mathcal O(n!)$，不能通过此题。

因为这题 $n$ 的值很小，最大只有 $18$，我们可以使用状态压缩动态规划。（简称状压 DP）

用二进制数表示已访问的星球集合，结合动态规划记录中间状态，定义 $dp_{mask,i}$ 表示当前已访问星球集合为 $mask$，且最后访问的星球是 $i$ 时的最小总能量。

对于状态 $dp_{mask,i}$，我们需要枚举上一个访问的星球 $j$，满足 $j$ 必须在 $mask$ 中（即已被访问）且 $j\neq i$。

则状态转移方程为：

$dp_{mask,i}=\min j∈mask,j \neq i\{dp[mask∖{i}][j]+d(j,i)×w_i\}$

$dp_{mask∖i,j}$：表示访问了 $mask$ 中除 $i$ 之外的所有星球，且最后位于 $j$ 的最小能量。

$d(j,i)$：星球 $j$ 到 $i$ 的距离。

$w_i$：星球 $i$ 的防御强度。

时间复杂度：$\mathcal O(n^2×2^n)$，足以通过此题。

代码：

```
#include<bits/stdc++.h>
using namespace std;
struct P {
	int x, y, z, w;
};
double dist(P a, P b) {
	double dx = a.x - b.x;
	double dy = a.y - b.y;
	double dz = a.z - b.z;
	return sqrt(dx * dx + dy * dy + dz * dz);
}
int main() {
	int n;
	cin >> n;
	P* p = new P[n];//优化一下空间
	for (int i = 0; i < n; i++) {
		cin >> p[i].x >> p[i].y >> p[i].z >> p[i].w;
	}
	double** d = new double*[n];
	for (int i = 0; i < n; i++) {
		d[i] = new double[n]();
		for (int j = 0; j < n; j++) {
			if (i != j) {
				d[i][j] = dist(p[i], p[j]);
			}
		}
	}
	int max_s = 1 << n;
	double** f = new double*[max_s];//优化一下空间
	for (int s = 0; s < max_s; s++) {
		f[s] = new double[n];
		for (int i = 0; i < n; i++) {
			f[s][i] = 1e18;
		}
	}
	for (int i = 0; i < n; i++) {
		f[1 << i][i] = 0.0;
	}
	for (int s = 0; s < max_s; s++) {
		for (int i = 0; i < n; i++) {
			if (!(s & (1 << i))) continue;
			for (int j = 0; j < n; ++j) {
				if (i == j || !(s & (1 << j))) continue;
				int t = s ^ (1 << i);
				if (f[t][j] + d[j][i] * p[i].w < f[s][i]) {
					f[s][i] = f[t][j] + d[j][i] * p[i].w;
				}
			}
		}
	}
	double ans = 1e18;
	int full = (1 << n) - 1;
	for (int i = 0; i < n; ++i) {
		if (f[full][i] < ans) {
			ans = f[full][i];
		}
	}
	printf("%.2lf", ans);
	return 0;
}
```


```Java``` 代码：

```java
import java.util.Scanner;
class Main {
    static class Point {
        int x, y, z, w;
        public Point(int x, int y, int z, int w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
    }
    static double distance(Point a, Point b) {
        double dx = a.x - b.x;
        double dy = a.y - b.y;
        double dz = a.z - b.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        Point[] points = new Point[n];
        for (int i = 0; i < n; i++) {
            int x = scanner.nextInt();
            int y = scanner.nextInt();
            int z = scanner.nextInt();
            int w = scanner.nextInt();
            points[i] = new Point(x, y, z, w);
        }
        double[][] dist = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j) {
                    dist[i][j] = distance(points[i], points[j]);
                }
            }
        }
        int maxState = 1 << n;
        double[][] dp = new double[maxState][n];
        for (int s = 0; s < maxState; s++) {
            for (int i = 0; i < n; i++) {
                dp[s][i] = 1e18;
            }
        }
        for (int i = 0; i < n; i++) {
            dp[1 << i][i] = 0.0;
        }
        for (int s = 0; s < maxState; s++) {
            for (int i = 0; i < n; i++) {
                if ((s & (1 << i)) == 0) continue; 
                
                for (int j = 0; j < n; j++) {
                    if (i == j || (s & (1 << j)) == 0) continue; 
                    
                    int prevState = s ^ (1 << i);
                    double newDist = dp[prevState][j] + dist[j][i] * points[i].w;
                    
                    if (newDist < dp[s][i]) {
                        dp[s][i] = newDist;
                    }
                }
            }
        }
        double ans = 1e18;
        int fullState = (1 << n) - 1;
        for (int i = 0; i < n; i++) {
            if (dp[fullState][i] < ans) {
                ans = dp[fullState][i];
            }
        }
        System.out.printf("%.2f", ans);
    }
}
```

---

## 作者：cse071549 (赞：1)

### 题目大意
题目给出 $n$ 颗星球，并给出 $i$ 颗星球的坐标为 $(x_i, y_i, z_i)$，且其防御强度为 $w_i$。要求规划出进攻这 $n$ 颗星球的顺序使得其进攻所需能量最少。

### 题目详解
看到 $$n \leq 18$$，显然这是一道状态压缩动态规划的题，首先此题距离较特殊，是三维的，可以用三维欧几里得距离求解，即 $\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 + (z_1 - z_2)^2}$，并乘以后一个数的防御强度得出两点的进攻能量。

然后我们使用二进制标记星球访问状态，从右往左数第 $i$ 位是真，则说明第 $i$ 位被访问过。我们将 $dp_{i,j}$ 设计为状态是 $i$，并且以 $j$ 为当前星球编号的最小能量。

初始化时，每个点只访问它自己时的最小能量为 $0$，其余应赋值为极大值方便计算最小值。

随后枚举状态 $i$、中间星球 $j$ 和结尾星球 $k$，状态转移方程为 ```dp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+a[j][k])```。目标状态就遍历状态为
$2^n - 1$ 时，结束攻击的星球哪一个的能量最小即可。
### 代码示例
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double b[25][5],dp[9000006][25],a[25][25];
double jl(double x_1,double x_2,double y_1,double y_2,double z_1,double z_2){
	return sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2)+(z_1-z_2)*(z_1-z_2));
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>b[i][0]>>b[i][1]>>b[i][2]>>b[i][3];
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			if(i!=j){
				a[i][j]=jl(b[i][0],b[j][0],b[i][1],b[j][1],b[i][2],b[j][2])*b[j][3];
			}
		}
	}
	int nn=1<<n;
	for(int i=0;i<nn;i++){
		for(int j=0;j<=n;j++){
			dp[i][j]=1e9;
		}
	}
	for(int i=0;i<n;i++){
        dp[1<<i][i]=0;
    }
	for(int i=1;i<=nn;i++){
		for(int j=0;j<n;j++){
			for(int k=0;k<n;k++){
				if(!((1<<k)&i)){
					dp[i+(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+a[j][k]);
				}
			}
		}
	}
	double ans=1e9;
	for(int i=0;i<n;i++){
		ans=min(ans,dp[(1<<n)-1][i]);
	}
	printf("%.2lf",ans);
	return 0;
}
```

---

## 作者：yedalong (赞：1)

很板的一道状压 DP 题。

## Solution

首先我们需要会计算三维空间中两点之间的直线距离，假设有两点 $a$ 和 $b$，它们的直线距离就是 $\sqrt{(x_a-x_b)^2+(y_a-y_b)^2+(z_a-z_b)^2}$，具体解释本题解不过多赘述。

接下来开始设计状态。考虑 $dp_{i,j}$ 表示状态为 $i$，最后一个星球编号为 $j$ 的最小能量。其中状态表示每个星球是否去过。答案其实就是 $\min dp_{2^n-1,i}(i\in[0,n))$。

接下来考虑状态转移。对于状态 $dp_{i,j}$，枚举一个 $k$，可以从 $dp_{i-2^j,k}$ 转移过来，所以转移公式就是

$$
dp_{i,j}=\min(dp_{i,j},dp_{i-2^j,k}+\sqrt{(x_j-x_k)^2+(y_j-y_k)^2+(z_j-z_k)^2}\times w_j)
$$

初始化就是将从每个星球开始的情况赋值为 $0$，其他赋为极大值。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{int x,y,z,w;}a[20];
int n;
double dp[1<<19][20],ans=1e9;
double distance(int x,int y,int z,int xx,int yy,int zz){return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy)+(z-zz)*(z-zz));}
int main(){
	cin>>n;
	for(int i = 0;i<n;i++) cin>>a[i].x>>a[i].y>>a[i].z>>a[i].w;
	for(int i = 0;i<1<<n;i++) for(int j = 0;j<n;j++) dp[i][j]=1e9;
	for(int i = 0;i<n;i++) dp[1<<i][i]=0;
	for(int i = 1;i<1<<n;i++){
		for(int j = 0;j<n;j++){
			if(i&(1<<j)==0) continue;
			for(int k = 0;k<n;k++){
				if(i&(1<<k)==0||j==k) continue;
				dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+distance(a[j].x,a[j].y,a[j].z,a[k].x,a[k].y,a[k].z)*a[j].w);
			}
		}
	}
	for(int i = 0;i<n;i++) ans=min(ans,dp[(1<<n)-1][i]);
	printf("%.2f",ans);
	return 0;
}
```

---

## 作者：huhengrui2013 (赞：1)

### 题解：P12220 [蓝桥杯 2023 国 Java B] 星球

[传送门](https://www.luogu.com.cn/problem/P12220#ide)

### 思路：

正如各位大佬所说，这是一道三维的旅行商问题，考虑用状压 dp 解决。

定义状态 $dp_{s,i}$ 表示已经访问过的星球集合为 $s$，当前位于星球 $i$ 的最小总能量。对于每一个状态 $dp_{s,i}$，尝试访问一个没访问过的星球 $j$，更新状态 $dp_{s|2^n,i}$ 为 $dp_{s,i}+\operatorname{dis}(i,j)\times w_j$。

初始化 $dp_{2^i,i}=0$ 表示从任意一个星球出发到该星球的值为 0,最终结果为所有 $dp_{N,i}$ 最小值，其中 $N=2^n-1$。


### AC Code:
```cpp
#include<bits/stdc++.h> 
using namespace std;
struct node{
    int x,y,z,w;  
}a[20];
double dis(node a,node b){
    return sqrt((a.x-b.x)*1.0*(a.x-b.x)+(a.y-b.y)*1.0*(a.y-b.y)+(a.z-b.z)*1.0*(a.z-b.z));
}//求两个星球之间的直线距离
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i].x>>a[i].y>>a[i].z>>a[i].w;
    }
    const int N=(1<<n)-1;
    double dp[N+1][20];
    //初始化
    for(int i=0;i<=N;i++){
        for(int j=0;j<20;j++){
            dp[i][j]=1e18;
        }
    }
    for(int i=0;i<n;i++) dp[1<<i][i]=0;
    //状压dp
    for(int s=0;s<=N;s++){
        for(int i=0;i<n;i++){
            if(s&(1<<i)){//包含i
                for(int j=0;j<n;j++){
                    if(!(s&(1<<j))){//不包含j
                        int mn=s|(1<<j);
                        double dist=dis(a[i],a[j]);
                        double cnt=dist*a[j].w;
                        dp[mn][j]=min(dp[mn][j],dp[s][i]+cnt);//更新
                    }
                }
            }
        }
    }
    double ans=1e18;
    for(int i=0;i<n;i++){
        ans=min(ans,dp[N][i]);
    }
    printf("%.2lf",ans);
}
```

### Java 代码：


```java
import java.util.Scanner;

public class Main {
    static class Node {
        int x, y, z, w;
    }

    // 求两个星球之间的直线距离
    static double dis(Node a, Node b) {
        return Math.sqrt((a.x - b.x) * 1.0 * (a.x - b.x) + 
                         (a.y - b.y) * 1.0 * (a.y - b.y) + 
                         (a.z - b.z) * 1.0 * (a.z - b.z));
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        Node[] a = new Node[20];
        for (int i = 0; i < 20; i++) {
            a[i] = new Node();
        }
        for (int i = 0; i < n; i++) {
            a[i].x = scanner.nextInt();
            a[i].y = scanner.nextInt();
            a[i].z = scanner.nextInt();
            a[i].w = scanner.nextInt();
        }
        final int N = (1 << n) - 1;
        double[][] dp = new double[N + 1][20];
        // 初始化
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j < 20; j++) {
                dp[i][j] = 1e18;
            }
        }
        for (int i = 0; i < n; i++) {
            dp[1 << i][i] = 0;
        }
        // 状压dp
        for (int s = 0; s <= N; s++) {
            for (int i = 0; i < n; i++) {
                if ((s & (1 << i)) != 0) { // 包含i
                    for (int j = 0; j < n; j++) {
                        if ((s & (1 << j)) == 0) { // 不包含j
                            int mn = s | (1 << j);
                            double dist = dis(a[i], a[j]);
                            double cnt = dist * a[j].w;
                            dp[mn][j] = Math.min(dp[mn][j], dp[s][i] + cnt); // 更新
                        }
                    }
                }
            }
        }
        double ans = 1e18;
        for (int i = 0; i < n; i++) {
            ans = Math.min(ans, dp[N][i]);
        }
        System.out.printf("%.2f", ans);
    }
}
```

---

## 作者：_Deer_Peach_ (赞：1)

题意已经很简洁了不再赘述。

思路：状压板子。先预处理出点 $i$ 到点 $j$ 的距离，在乘上 $w_j$ 就是点 $i$ 到点 $j$ 的花费。

下文的点标号从 $0$ 开始。

定义 $dp_{i,j}$ 为在状态为 $i$ 的情况下最后到点 $j$ 的最小花费。其中状态 $i$ 表示 $i$ 在二进制下，从右往左第 $j$ 位为 $1$ 表示已经进攻过，反之没有。

那么转移方程也很简单，枚举状态 $i$，终点 $j$ 和转移点 $k$，转移就是 $dp_{i,k} \gets \min(dp_{i,j},dp_{i-2^j,k} + dis_{k,j})$。其中 $dis_{i,j}$ 表示从 $i$ 到 $j$ 进攻的花费。

预处理花费：首先三维空间中求两点距离公式为 $\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}$。由题意可得 $dis_{i,j} \gets \sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2} \times w_j$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=20;
const double Max=0x3f3f3f3f3f3f3f3f;
double dis[N][N];
double dp[1<<N][N];
int n;
struct node{
	double x,y,z,w;
}a[N];
inline double Dis(node a,node b){//求花费
	double x=a.x-b.x;
	double y=a.y-b.y;
	double z=a.z-b.z;
	return sqrt(x*x+y*y+z*z)*b.w;
}
signed main(){
	IOS;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i].x>>a[i].y>>a[i].z>>a[i].w;
	}
	for(int i=0;i<n;i++){//预处理
		for(int j=0;j<n;j++){
			dis[i][j]=Dis(a[i],a[j]);
		}
	}
	for(int i=0;i<(1<<n);i++){//初始化，建议别用memset
		for(int j=0;j<n;j++){
			dp[i][j]=Max;
		}
	}
	for(int i=0;i<n;i++)dp[1<<i][i]=0;//每一个点都可以作为起点
	for(int i=0;i<(1<<n);i++){//状态
		for(int j=0;j<n;j++){//终点
			if(((i>>j)&1)==0)continue;//如果j在状态i下没进攻过则不能转移
			for(int k=0;k<n;k++){//转移点
				if(k==j)continue;//重复点跳过
				if(((i>>k)&1)==0)continue;//如果点k在状态i下没进攻过则不能转移
				dp[i][j]=min(dp[i][j],dp[i-(1<<j)][k]+dis[k][j]);//转移
			}
		}
	}
	double res=Max;
	for(int i=0;i<n;i++){//枚举最终终点
		res=min(res,dp[(1<<n)-1][i]);
	}
	printf("%.2lf",res);
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

# P12220 [蓝桥杯 2023 国 Java B] 星球 题解  
显而易见的状压题。  
### 解题思路  
观察发现，$n \le 18$，故想到使用状压来做。令 $dp_{i,j}$ 表示当前经过的节点的状态为 $i$，结束节点为 $j$。显然有对于任意一个 $0\le i< n$，有 $dp_{2^i,i}=0$（开始）。然而对于其他 $dp_{i,j}=\min_{x,y}dp_{i \otimes 2^j,k}+dis_{j,k}\times w_j$，其中 $\otimes$ 表示异或，$x,y$ 是 $i$ 经过的点。定义 $dis_{i,j}=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}$。答案即是 $\min_{0\le i <n} dp_{2^n-1,i}$。  
### AC 代码  

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int n;
double dp[1<<19][20];
double x[20],y[20],z[20],w[20];
inline double cal(int a,int b){
	return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])+(z[a]-z[b])*(z[a]-z[b]));
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>x[i]>>y[i]>>z[i]>>w[i];
	}
	memset(dp,0x7f,sizeof dp);
	for(int i=0;i<n;i++) dp[1<<i][i]=0;
	for(int i=0;i<(1<<n);i++){
		for(int j=0;j<n;j++){
			if(i&(1<<j)){
				for(int k=0;k<n;k++){
					if(k==j || (i&(1<<j)==0)) continue;
					dp[i][j]=min(dp[i][j],dp[i^(1<<j)][k]+cal(j,k)*w[j]);
				}
			}
		}
	}
	double ans=1e9;
	for(int i=0;i<n;i++){
		ans=min(ans,dp[(1<<n)-1][i]);
	}
	printf("%.2lf",ans);
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P12220)

看到 $n=18$，状压 DP 无疑了。

状态是容易的，定义 $f_{S,i}$ 表示经过节点的状压集合为 $S$ 且 $i$ 为经过的最后一个节点。初始化是显然的，令 $f_{0,i}=f_{2^i,i}=0(0\leq i\leq n-1)$，其余取 $\infty$。

考虑转移，这里我采用主动转移，假设 $\Delta$ 为当前要向外转移的状态，我们可以枚举一个未在 $\Delta$ 中出现的点 $k$ 作为下一个到达的点，然后枚举一个在 $\Delta$ 中的点 $j$ 作为 $\Delta$ 最后到达的点，可得：
$$f_{
\Delta|2^k,k}=\min f_{\Delta,j}+w_k\sqrt{(x_k-x_j)^2+(y_k-y_j)^2+(z_k-z_j)^2}$$

答案为 $\min_{i=0}^{n-1}f_{2^n-1,i}$，时间复杂度 $O(2^nn^2)$。

注意 $\Delta$ 枚举顺序要按 $\operatorname{popcount}$ 从小到大进行。

代码很好写。

---

## 作者：细数繁星 (赞：0)

数据范围是 $n\le 18$，$\mathcal{O}(n!)$ 会直接起飞，$\mathcal{O}(2^n)$ 是可以承受的，因此考虑状压 dp。

这道题目中，状态的转移不仅和上一次的状态有关，还和上一次状态中所排的最后一个星球有关，所以状态设为 $f_{i,j}$。其中 $i$ 为状态，用二进制表示，$j$ 表示该状态中，所排的最后一个星球。

状态转移方程，很快啊，就出来了：

$$
f_{i,j}=\min_{1\le k\le n,k\in i}\{f_{i\backslash\{j\},k}+d(j,k)w_j\}
$$

（这里将状态 $i$ 用集合形式表示）

```cpp
#include <bits/stdc++.h>
#define rty printf("Yes\n");
#define RTY printf("YES\n");
#define rtn printf("No\n");
#define RTN printf("NO\n");
#define rep(v,b,e) for(int v=b;v<=e;v++)
#define repq(v,b,e) for(int v=b;v<e;v++)
#define rrep(v,e,b) for(int v=b;v>=e;v--)
#define rrepq(v,e,b) for(int v=b;v>e;v--)
#define stg string
#define vct vector
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

void solve() {
	
}

int n;
double x[20], y[20], z[20], w[20], dp[1 << 19][20];

double dis(int inda, int indb) {
    return sqrt((x[inda] - x[indb]) * (x[inda] - x[indb]) + (y[inda] - y[indb]) *
        (y[inda] - y[indb]) + (z[inda] - z[indb]) * (z[inda] - z[indb]));
}

main() {
//	int t; cin >> t; while (t--) solve();
    memset(dp, 127, sizeof dp);
    cin >> n;
    rep(i,1, n) { 
        cin >> x[i] >> y[i] >> z[i] >> w[i]; 
        dp[1 << i - 1][i] = 0;
    }
    repq(i, 0, 1 << n) {
        rep(j, 1, n) {
            if (i & (1 << j - 1)) {
                rep(k, 1, n) {
                    if (i & (1 << k - 1)) {
                        dp[i][j] = min(
                            dp[i][j],
                            dp[i ^ (1 << j - 1)][k] + dis(j, k) * w[j]
                        ) ;
                    }
                } 
            }
        }
    }
    double ans = 1e18;
    rep(i, 1, n) ans = min(ans, dp[(1 << n) - 1][i]);
    printf("%.2lf", ans);
	return 0;
}

```

---


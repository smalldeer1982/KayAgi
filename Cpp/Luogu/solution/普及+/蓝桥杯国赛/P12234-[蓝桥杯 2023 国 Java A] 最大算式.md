# [蓝桥杯 2023 国 Java A] 最大算式

## 题目描述

给定 $n$ 个非负整数 $A_i$，你可以在不改变这些数顺序的前提下任意在他们之间插入 $\tt{+},\tt{*},\tt{(},\tt{)}$ 四种符号。

请问在得到的算式合法的前提下，算式的结果最大可以是多少？

由于结果很大，你只需要输出答案对 $10^9 + 7$ 取模的结果即可。

## 说明/提示

### 样例说明

$(1 + 2) \times (1 + 1 + 1) \times (2 + 1) = 27$。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$2 \leq n \leq 10^5$，$0 \leq A_i \leq 10^9$。

## 样例 #1

### 输入

```
7
1 2 1 1 1 2 1```

### 输出

```
27```

# 题解

## 作者：yanmingqian (赞：4)

看起来很像动态规划，动态规划或许也能做，但是实际上可以贪心。

正常人都知道通常来说乘是比加更优的。但是样例就能告诉我们并不完全是这样。因为 $1$ 和 $0$ 的存在，这一点不完全正确。$0$ 好说，加上也对答案没有贡献，输入的时候直接丢掉就行。考虑 $1$ 应该怎么办。

假设 $1$ 前面是一个数 $a$，后面是一个数 $b$。贪心考虑，应该把 $1$ 加到 $a$ 和 $b$ 中更小的那个上面。因为 $(a+1)\times b=ab+b$，$a\times(b+1)=ab+a$，所以加到更小的上面增加得更多。

但是前面说的 $a$ 和 $b$ 不一定是紧贴着当前的 $1$ 的，可能中间隔了连续的 $1$。因此我们要记录一下上一个不是 $1$ 的地方，每次遍历到 $a_i=1$ 时将其与 $a_{i+1}$ 进行比较。同时我们不得不考虑一个特殊情况，加到 $2$ 上是可能比加到 $1$ 上更优的，除非有连续三个或以上的 $1$。我们可以通过下面的一组样例理解：

```
7
1 1 2 1 1 1 1
```

正确答案应该是 $18=(1+1)\times(2+1)\times(1+1+1)$，但是如果把第四个位置上的 $1$ 放到了后面，算出来就会变成 $16$。因此我们需要考虑这一点。

根据这个思路我们就能写出代码了。

```cpp
#include<iostream>
using namespace std;
const int mod=1e9+7;
long long a[100010];
int main(){
    int n,m=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        if(x){
            a[++m]=x;  //把0排掉
        }
    }
    int last=0;
    for(int i=1;i<=m;i++){
        if(a[i]==1){
            if(!last){
                if(i<m){  //边界
                    a[i+1]++;
                }
            } 
            else{
                if(i<m){  //边界
                    if(a[last]<=a[i+1]||a[last]==2){  //加到更小的上面，注意判断2的情况
                        a[last]++;
                    }
                    else{
                        a[i+1]++;
                    }
                }
                else{
                    a[last]++;
                }
            }
        }
        else if(a[i]>1){
            last=i;
        } 
    }
    long long ans=1;
    for(int i=1;i<=m;i++){
        ans=(ans*a[i])%mod;
    }
    cout<<ans;
    return 0;
}
```

```java
import java.util.Scanner;
public class Main {
    private static final int mod = (int) 1e9 + 7;
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        long[] a = new long[100010];
        int m = 0;
        for (int i = 1; i <= n; i++) {
            int x = scanner.nextInt();
            if (x != 0) {
                a[++m] = x;
            }
        }
        int last = 0;
        for (int i = 1; i <= m; i++) {
            if (a[i] == 1) {
                if (last == 0) {
                    if (i < m) {
                        a[i + 1]++;
                    }
                } else {
                    if (i < m) {
                        if (a[last] <= a[i + 1] || a[last] == 2) {
                            a[last]++;
                        } else {
                            a[i + 1]++;
                        }
                    } else {
                        a[last]++;
                    }
                }
            } else if (a[i] > 1) {
                last = i;
            }
        }
        long ans = 1;
        for (int i = 1; i <= m; i++) {
            ans = (ans * a[i]) % mod;
        }
        System.out.println(ans);
    }
}
```

---

## 作者：__liujy (赞：0)

裸贪心。

考虑若所有的数都大于一，那么它们乘起来答案最大，这个很好证明。

可还有 $0$ 和 $1$ 的情况，若为 $0$ 直接加 $0$ 即可，重要的是在怎么处理 $1$ 的情况。

我们设 $1$ 前面的数为 $a$，后面的数为 $b$，则有一下两个加法，第一种加到 $a$，第二种加到 $b$，若加到 $a$，则最后的值为 $(a + 1)b$，化简后得 $ab + b$；若加到 $b$，则最后的值为 $a(b + 1)$，化简后得 $ab + a$。

显然只有加到较大数的那边，当前一定是最优解。

不过，若只有 $1$ 个数，那就输出那个数。

```cpp
/*
a(b + 1) = ab + a
(a + 1)b = ab + b
*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
const int MOD = 1e9 + 7;
int n, a[N], pos, b[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	if(n == 1){
		cout << a[1];
		return 0;
	} 
	for(int i = 1; i <= n; i++){
		if(a[i] == 0) continue;
		b[++pos] = a[i];
	}
	int la = 0;
	for(int i = 1; i <= pos; i++){
		if(b[i] == 1){
			if(!la) b[i + 1]++;
			else{
				if(i < pos){
					if(b[la] <= b[i + 1] || b[la] == 2) b[la]++;
					else b[i + 1]++;
				}
				else b[la]++;
			}
		}
		else la = i;
	}
	int ans = 1;
	for(int i = 1; i <= pos; i++) ans = (ans * b[i]) % MOD;
	cout << ans % MOD;
	return 0;
}
```

---


# [蓝桥杯 2024 国 Java B] 背包问题

## 题目描述

神奇商店中一共有 $N$ 种不同的物品，第 $i$ 种物品的重量为 $W_i$，每种物品的数量都是无限个。店主会从中挑选任意种商品，每种商品可以选择任意个并将其装入到一个背包之中，从而可以组合出多种背包（这个背包可以容纳无限多的物品），其中背包的重量就是其中所含物品的重量之和。

小蓝想要的背包中至少要有 $K$ 件物品。小蓝想要知道，在所有满足他要求的背包中，如果将背包重量从小到大排序并去除重复的重量，排名第 $L$ 的重量是多少。

## 说明/提示

### 样例说明

背包中物品个数大于等于 $2$ 时，从小到大依次出现的背包重量为：

$6 = 3 + 3$、$8 = 3 + 5$、$9 = 3 + 3 + 3$、$10 = 5 + 5$、$11 = 3 + 3 + 5$、$12 = 3 + 3 + 3 + 3$、$13 = 3 + 5 + 5$。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$1 \leq W_i \leq 100$，$1 \leq L \leq 10$。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 10$，$1 \leq K \leq 10$，$1 \leq W_i \leq 10^9$，$1 \leq L \leq 10^5$

## 样例 #1

### 输入

```
7 2 7
84 21 12 3 65 5 41```

### 输出

```
13```

# 题解

## 作者：zyzxzhangyi (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P12258)

# 前言
~~本蒟蒻不会楼下大佬的平衡树做法，故发表此篇题解。~~

本题和[这道题](https://www.luogu.com.cn/problem/P2723)类似，做完此题可以把它一起做了。

# 思路
容易发现每次取最小可行的背包重量，然后通过分别加上 $N$ 个商品的重量生成新的背包重量，执行 $L$ 次后就是第 $L$ 小的背包重量。

我们可以用数据结构来维护取最小的背包重量，堆再合适不过了，注意优先队列要存储两个值，一个是背包重量，一个是物品数量，物品数量要大于等于 $K$ 才是可行的。

操作时记得用二维 map 去重。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

long long n, k, l, a[15];
struct note{
	long long v, s;
	bool operator < (note _) const{
		return v > _.v;
	}
}x;
priority_queue <note> q;
map <long long, map <int, bool> > t;

int main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); 
	cin >> n >> k >> l;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) q.push({a[i], 1});
	while(l){
		x = q.top(), q.pop();
		if(x.s >= k) l--;
		for(int i = 1; i <= n; i++)
            if(!t[x.v + a[i]][min(k, x.s + 1)])
                 t[x.v + a[i]][min(k, x.s + 1)] = 1, q.push({x.v + a[i], x.s + 1});//记得取min
	}
	cout << x.v << endl;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/228920709)

时间复杂度：$O(L \log {NL})$。

空间复杂度：$O(NL)$。

---

## 作者：tuboshu666 (赞：2)

## 前置知识：平衡树

## 思路：
本题 $N$ 和 $L$ 较小，可以枚举。问题在于要怎么枚举。

首先想到 bfs。以当前选择物品数为依据，一层层搜索。问题来了——选择物品少并不代表重量和就少，bfs 没有明显单调性，难以确定搜索的结束条件。

于是更近一步，想到**优先队列**。每次搜索都取出重量和最少的方案，枚举下一步要选的物品，再将选择后的重量和压入优先队列。由于优先队列的单调性，若取出的重量和已大于当前第 $L$ 个方案，则显然其再选物品，重量和也一定大于第 $L$ 个，此时退出搜索。

既然得到了搜索思路，接下来还要处理一个问题：我们需要一个能动态插入、查询第 $K$ 小数据的数据结构，于是想到平衡树。

## Solution：
每次取出堆顶，枚举所有物品，将当前重量和加上该物品重量，再压入堆。如果已选物品数小于 $K$，则只需要压入堆，否则还需将该重量和插入平衡树中。去重使用哈希或 ```set``` 即可。

需要注意：在选择物品小于 $K$ 时，不能只针对重量和去重。因为当重量和相同，但选择物品数不同时，选择的物品越多越优。简单去重可能错过更优解。这种情况下要以该二元组为依据去重。

本篇平衡树通过 FHQ Treap 实现。如果对平衡树还不了解，可先移步[平衡树模版](https://www.luogu.com.cn/problem/P3369)。

## Code：
```cpp
#include <iostream>
#include <unordered_map>
#include <queue>
#include <set>
using namespace std;

struct node
{
    int l,r;
    int key,size;
    long long val;
};

typedef pair<long long,int> PII;
const int MAXN = 1e7 + 10;
const int N = 20;
unordered_map<long long,int> mp;
set<PII> st;
priority_queue< PII,vector<PII>,greater<PII> > q;
node tr[MAXN];
int w[N];
int tot,root;
int n,k,l;

void push_up(int p) //size上推
{
    int l = tr[p].l;
    int r = tr[p].r;
    tr[p].size = tr[l].size + tr[r].size + 1;
}

int newnode(long long v) //创建节点
{
    tr[++tot].val = v;
    tr[tot].size = 1;
    tr[tot].key = rand();
    return tot;
}

void split(int p, long long v, int &x, int &y) //分裂
{
    if (p == 0)
    {
        x = y = 0;
        return;
    }
    if (tr[p].val <= v)
    {
        x = p;
        split(tr[x].r,v,tr[x].r,y);
    }
    else
    {
        y = p;
        split(tr[y].l,v,x,tr[y].l);
    }
    push_up(p);
}

int merge(int x, int y) //合并
{
    if (!x || !y) return x + y;
    if (tr[x].key < tr[y].key)
    {
        tr[x].r = merge(tr[x].r,y);
        push_up(x);
        return x;
    }
    else
    {
        tr[y].l = merge(x,tr[y].l);
        push_up(y);
        return y;
    }
}

void insert(long long v) //插入节点
{
    int x,y,z;
    split(root,v,x,y);
    z = newnode(v);
    root = merge(merge(x,z),y);
}

long long get_k(int p, int k) //查询第k小的数
{
    int l = tr[p].l;
    int r = tr[p].r;
    if (p == 0) return 0; //总节点数小于k时，返回无效节点
    if (k <= tr[l].size) return get_k(l,k);
    else if (k == tr[l].size+1) return p;
    else return get_k(r,k-tr[l].size-1);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> k >> l;
    for (int i = 1 ; i <= n ; i++) cin >> w[i];

    //初始化平衡树的无效节点为无穷大，当平衡树节点数小于L时返回极大值，便于处理节点数小于L的情况
    tr[0].val = 9e18;
    q.push({0,0});

    //PII中的first表示选到当前的重量总和，second表示选了多少件物品
    while (!q.empty())
    {
        PII t = q.top();
        q.pop();

        //如果重量和大于第k位，则退出
        if (t.first >= tr[get_k(root,l)].val) break;
        
        for (int i = 1 ; i <= n ; i++)
        {
            long long sum = t.first + w[i];
            int cnt = t.second + 1;

            if (cnt >= k && !mp.count(sum)) //选择物品数达到k
            {
                mp[sum]++;
                insert(sum);
                q.push({sum,cnt});
            }
            if (cnt < k && !st.count({sum,cnt})) //选择物品数未达到k
            {
                q.push({sum,cnt});
                st.insert({sum,cnt});
            }
        }
    }

    cout << tr[get_k(root,l)].val << endl;

    return 0;
}
```

---


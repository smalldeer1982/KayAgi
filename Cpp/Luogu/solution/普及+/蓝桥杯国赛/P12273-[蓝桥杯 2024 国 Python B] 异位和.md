# [蓝桥杯 2024 国 Python B] 异位和

## 题目描述

给定一个数组 $A$，我们称 $A$ 的异位和数组为另一个等长的数组 $B = F(A)$，满足

$$B_i = \sum_{j \neq i} A_j$$

类似地，其二次异位和数组为 $F(F(A))$，三次异位和数组为 $F(F(F(A)))$，以此类推。

给定若干次询问，每次问 $A$ 的 $k_i$ 次异位和数组的第 $x_i$ 个元素的值是多少。输出答案对 $998244353$ 取模后的结果。

## 说明/提示

### 评测用例规模与约定

- 对于 $60\%$ 的评测用例，$1 \leq n, Q, k_i \leq 5000$；
- 对于所有评测用例，$1 \leq n, Q \leq 10^5$，$1 \leq A_i, k_i \leq 10^9$，$1 \leq x_i \leq n$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
4
1 1
2 5
7 3
999 4```

### 输出

```
14
50
49152
781284616```

# 题解

## 作者：LimityZetta (赞：4)

_这题太冷了，也是水一篇题解。_
 
 [P12273](https://www.luogu.com.cn/problem/P12273)

## 题解

对于这类数学题，我们要拿出我们的传统艺能：推规律。

以下我们约定：

$f_i^{(m)}$ 为原序列的 $m$ 次异位和数组的第 $i$ 项，
 $S$ 为原序列的和，即 $\sum_{i=1}^{n}A_i$。

不难推出：

$$
\begin{aligned}
f_i^{(1)}&=S-A_i\\
f_i^{(2)}&=S \cdot n - (\sum_{i=1}^{n}A_i)-(S-A_i)\\
&=(n-1)S - S+A_i\\
\end{aligned}
$$

等等的式子，只需要对上一次的异位和数组求和，再减去上一次异位和数组的对应一项，就都可以推出来。

事实上，通过前四次推导：

$$
\begin{aligned}
f_i^{(1)}&=S-A_i\\
f_i^{(2)}&=(n-1)S - S+A_i\\
f_i^{(3)}&=(n-1)^2S-(n-2)S-A_i\\
f_i^{(4)}&=(n-1)^3S-(n^2-3n+3)S+A_i\\
\end{aligned}
$$

我们能大概得出一个规律：

$$
f_i^{(m)}=(n-1)^{m-1}S-\frac{(n-1)^{m-1}+(-1)^m}{n}\times S+(-1)^m \times A_i
$$

有了这个式子，剩下的只有取模了。

我们不妨把式子拆成前、中、后三部分：

最后一项 $(-1)^m \times A_i$ 直接取模即可。

前面一项 $(n-1)^{m-1}S$ 也不难，在快速幂里取模即可。

剩下一项有点麻烦，需要先对分母 $n$ 求[模逆](https://blog.csdn.net/whiskey_wei/article/details/79461932) ，再乘以分子再取模。

由于 $998244353$ 是质数，这里采用的[费马小定理](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158)求模逆。

最后分段取模后，$ans$ **一定要先加一个模数再取模，不然可能对负数取模，会出错。**

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 998244353
const int mxn=1e5+2;
int n,a[mxn],q;
long long Pow(long long a,long long b,long long p){
	long long base=a,ans=1;
	while(b){
		if(b&1){
			ans*=base;
			ans%=p;
		}
		base*=base,base%=p;
		b>>=1;
	}
	return ans%p;
}
long long s;
int main() {
	scanf("%d",&n);
	long long inv=Pow(n,mod-2,mod);//模逆，这里预计算
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		s+=a[i];
	}
	s%=mod;//sum
	scanf("%d",&q);
	while(q--){
		long long k,x;
		scanf("%lld%lld",&k,&x);
		//(-1)^k
		int sign=(k&1)?-1:1;
		
		long long y=Pow(n-1,k-1,mod);//(n-1)^(k-1)
		long long frac=((y+sign)%mod*inv%mod)%mod;//中间项的分数
		//ans
		long long ans=(s%mod*y)%mod;//前一项
		ans-=(frac*s%mod)%mod;//中间项
		ans+=sign*(a[x]%mod);//最后一项
		printf("%lld\n",(ans+mod*2)%mod);
	}
}
```

---

## 作者：qwqerty (赞：2)

自己推式子比抄题解好玩多了。  
本人第二次不看题解做出绿题。
# 解题思路
首先我们有一个最简单的结论：$F(A)_i=(\sum\limits_{i=1}^n A_i)-A_i$  
我们先推两层，找找规律（令 $s=\sum\limits_{i=1}^n A_i$）：  
$$
F(A)_i=s-A_i\\
F(F(A))_i=(n - 1)s - s + A_i\\
F(F(F(A)))_i=(n - 1) ^ 2s - (n - 1)s + s - A_i
$$
发现规律了吗？这个规律还是很容易证明的，根据递推思想，有 $F^k(A)_i=(\sum\limits_{i=1}^n F^{k-1}(A)_i)-F^{k-1}(A)_i$。如果我们去掉末尾的 $\pm A_i$ 考虑，定义 $f(A)=nA-A=(n-1)A$。那么 $f^k(A)$ 相比 $f^{k-1}(A)$ 的每一项都乘上了 $(n-1)$。接着我们考虑上末尾的 $A_i$，显然它会变成 $s$。套上一层 $F$ 后会在末尾增添一个 $A_i$，我们观察到 $A_i$ 在递推公式前是以减号开头的。根据小学数学知识，括号前是减号拆括号后要变号。所以 $A_i$ 前的加和减是交替的。

把这个结论抽象一下就是当 $k$ 为偶数时，$F^k(A)=-\sum\limits_{i=0}^{k-1} (n-1)^is+A_i$，当 $k$ 为奇数时，$F^k(A)=\sum\limits_{i=0}^{k-1} (n-1)^is-A_i$。把这个结论套进等比数列求和公式里，可得当 $k$ 为偶数时，$F^k(A)=\dfrac{-[(-n+1)^k]s}{n}+A_i$，否则 $F^k(A)=\dfrac{[(-n+1)^k]s}{n}-A_i$。
# 代码
```python
mod = 998244353;   
n = int(input());
A = list(input().split());
A = [int(i) for i in A];
q = int(input());
s = 0;
for i in A: s = s + i;
for i in range(q):
    k, x = map(int, input().split());
    x = x - 1;
    if k % 2 == 0: print((-s * (1 - pow(-(n - 1), k, mod)) * pow(n, mod - 2, mod) + A[x]) % mod);
    else: print((s * (1 - pow(-(n - 1), k, mod)) * pow(n, mod - 2, mod) - A[x]) % mod);
```

---

## 作者：llamn (赞：1)

没有大脑，所以直接矩阵快速幂。

设数组的和为 $sum$，那么异位和一遍之后，原来 $A_{x_i}$ 变为 $sum - A_{x_i}$ （注意这个 $sum$ 是原数组的和），$sum$ 变为 $(n-1)sum$。

所以 $base$ 矩阵为 $\begin{bmatrix} sum & A_{x_i} \end{bmatrix}$，转移矩阵即为 $\begin{bmatrix} n-1 & 1 \\ 0 & -1 \end{bmatrix}$。

```cpp
#include <bits/stdc++.h>
#define _eggy_ using
#define _party_ namespace
_eggy_ _party_ std;
int n,m,i,j,k,x;
long long a[100010], sum;

#define mod 998244353ll
#define ilist initializer_list
struct mat 
{
	long long dt[2][2]; int n,m;
	const long long* operator[](const int& i) const {return dt[i];}
		  long long* operator[](const int& i)       {return dt[i];}
	
	#define cmat const mat&
	mat(){memset(this,0,sizeof(*this));}
	mat(mat&&) = default;
	mat& operator = (mat&&) = default;
	mat(ilist<ilist<long long>>&& l)
	{
		n = l.end() - l.begin(), m = l.begin() -> end() - l.begin() -> begin();
		for (auto i = l.begin(); i != l.end(); ++i)
			for (auto j = i->begin(); j != i->end(); ++j)
				dt[i-l.begin()][j-i->begin()] = *j;
	}
	friend mat operator * (cmat a, cmat b)
	{
		struct mat rt; rt.n = a.n, rt.m = b.m; int i,j,k;
		for (i = 0; i < a.n; i++)
			for (j = 0; j < b.m; j++){
				for (k = 0; k < a.m; k++)
					(rt[i][j] += a[i][k] * b[k][j]) %= mod;
		}return rt;
	}
	friend mat& operator *= (mat& a, cmat b) {return a = a * b;}
} bs,z;

long long& mmod(long long &x)
{
	if (x < 0) x += mod;
	if (x >= mod) x -= mod;
	return x;
}
void fpow(mat& bs, int b)
{
	while(b)
	{
		if (b & 1) bs *= z;
		z *= z; b >>= 1;
	}	
}
int main()
{
    scanf("%d",&n); for (i = 1; i <= n; i++)
	{
		scanf("%lld",a+i);
		mmod(sum += mmod(a[i]));
	}
    scanf("%d",&m); while(m--)
    {
    	scanf("%d%d",&k,&x);
    	bs = {{sum,a[x]}};
		z = {{n-1,1},{0,-1}};
    	fpow(bs,k);
		printf("%lld\n",mmod(bs[0][1]));
	}	
    return 0;
}
```

---

## 作者：DesignDigits (赞：0)

> 我想写一篇题解，完整还原 ***正解是如何一步一步探索出来的过程***。希望大家通过掌握思考路径，获得解决更多同类问题的能力。

我们把 $A$ 的 $i$ 次异位和数组的第 $j$ 项记为 $B_{i, j}.$ 先来 ***把题目的意思用式子表达***：
- $B_{i, j}=\sum _{k\neq j} B_{i-1, k}$
- $B_{0, j}=A_j$

在发现 $B_{i, j}$ 是 $n-1$ 项相加后，我们抓住一种想法：记 $S_i = \sum _k {B_{i, k}}$，于是 $B_{i, j} = S_{i-1} - B_{i-1, j}.$ 我们用一个单独的求和 $(S_{i-1})$ 替代了 $n$ 个不同的求和，***问题被简化了，所以我们倾向于进行这种转化。***

再来 ***关注我们的目标***，求出 $B_{k, x}.$ 用刚才得到的结论，我们可以有这样的思路：

$$\begin{align*}
 B_{k, x} &= S_{k-1} - B_{k-1, x}\\
&=S_{k-1} - (S_{k-2} - B_{k-2, x})\\
&=S_{k-1} - (S_{k-2} - (S_{k-3} - B_{k-3, x}))\\
&=\dotsb \\
&=S_{k-1} - S_{k-2} + S_{k-3} - \dotsb + (-1)^k B_{0, x}
\end{align*} $$

其中，$B_{0, x}$ 就是已知的 $A_x,$ 我们只要算出 $S$ 的各项，就大功告成了。为此我们 ***回到 $S_i$ 的定义来寻找思路，并尝试消掉字母 $B$***，发现：

$$\begin{align*}
S_i &= \sum _k B_{i, k}\\
&= \sum _k (S_{i-1} - B_{i-1, k})\\
&= \sum _k S_{i-1} - \sum _k B_{i-1, k}\\
&= nS_{i-1} - S_{i-1}\\
&= (n-1)S_{i-1}
\end{align*}$$

进而 $S_i = (n-1)^i S_0 = (n-1)^i \sum _k A_k.$ 我们惊喜地发现，要计算的式子符合等比数列求和的形式：如果以 $S_{k-1}$ 为首项，则公比是 $- {1\over {n-1}}$。

推导到此就完成了。用快速幂、逆元等工具计算出上面的式子即可。

### 一些坑（猜猜我为什么知道，这题交了 $6$ 次才过 QwQ）：

- 公比为 $1$ 时，等比数列的求和公式会失效，需要特判。
- $n=1$ 时公比分母为零。也需要特判。

---

## 作者：W_C_B_H (赞：0)

我们设 $f_{k,i}$ 表示 $A$ 的 $k$ 次异位和数组中第 $i$ 个元素的值（$k>0$），$s$ 表示所有 $A_i$ 的和（代码中用 `sum` 表示），手动计算可发现：

$f_{1,i}=s-A_i$

$f_{2,i}=(n-1)s-s+A_i$

$f_{3,i}=(n-1)^2s-(n-1)s+s-A_i$

$f_{4,i}=(n-1)^3s-(n-1)^2s+(n-1)s-s+A_i$

此时规律已经很明显了，由此我们可以得出：

$\begin{aligned}f_{k,i}&=\sum_{j=0}^{k-1}[(-1)^{j+k+1}\times(n-1)^j\times s]+(-1)^kA_i\\
&=s\times\sum_{j=0}^{k-1}[(-1)^{j+k+1}\times(n-1)^j]+(-1)^kA_i\\
&=s\times\sum_{j=0}^{k-1}[(-1)^{k+1}\times(-1)^j\times(n-1)^j]+(-1)^kA_i\\
&=(-1)^{k+1}\times s\times\sum_{j=0}^{k-1}[(-1)^j\times(n-1)^j]+(-1)^kA_i\\
&=(-1)^{k+1}\times s\times\sum_{j=0}^{k-1}(1-n)^j+(-1)^kA_i\end{aligned}$

由等比数列求和公式可得：

$\begin{aligned}\sum_{j=0}^{k-1}(1-n)^j
&=\dfrac{1\times[1-(1-n)^k]}{1-(1-n)}\\
&=\dfrac{1-(1-n)^k}{n}\end{aligned}$

则 $f_{k,i}$ 可进一步化简为：

$\begin{aligned}f_{k,i}&=(-1)^{k+1}\times s\times\dfrac{1-(1-n)^k}{n}+(-1)^kA_i\\
&=(-1)^k\times s\times\dfrac{(1-n)^k-1}{n}+(-1)^kA_i\\
&=(-1)^k\times[s\times\dfrac{(1-n)^k-1}{n}+A_i]\end{aligned}$

使用快速幂并预处理出 $n$ 在模 $998244353$ 意义下的逆元即可在 $O(\log k)$ 时间复杂度内算出答案。总时间复杂度 $O(n+Q\log k)$，可以通过本题。

Code：

```python
mod = 998244353

def qpow(x, y): # 快速幂
    ret = 1
    while y:
        if y & 1:
            ret = ret * x % mod
        x = x * x % mod
        y >>= 1
    return ret

# 输入
n = int(input())
a = list(map(int, input().split()))
Q = int(input())

# 预处理
sum = 0
for i in range(n):
    a[i] %= mod
    sum += a[i]
    sum %= mod
inv = qpow(n, mod - 2)  # 逆元

# 查询
for i in range(Q):
    k, x = map(int, input().split())
    ans = (mod - 1 if k & 1 else 1) * ( sum * (qpow(1 - n, k) - 1) % mod * inv % mod + a[x - 1]) % mod
    print(ans)
```

---


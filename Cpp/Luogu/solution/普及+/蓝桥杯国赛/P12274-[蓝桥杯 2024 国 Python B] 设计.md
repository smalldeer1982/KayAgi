# [蓝桥杯 2024 国 Python B] 设计

## 题目描述

小蓝是 H 市的市长，她正在用设计软件规划 H 市的道路建设。

小蓝可以选定两个地区，用一条双向道路将这两个地区连接。由于预算等因素的动态变化，小蓝经常需要拆除一些已经建设好的道路，同时，她希望知道对于当前的两个地区，是否存在一条由多条道路组成的路径能够连接这两个地区。

## 说明/提示

### 评测用例规模与约定

- 对于 $50\%$ 的评测用例，$n, m \leq 3000$。
- 对于所有评测用例，$1 \leq n, m \leq 300000$，$1 \leq x_i, y_i \leq n$，$x_i \neq y_i$。

## 样例 #1

### 输入

```
2 5
3 1 2
1 1 2
3 1 2
2
3 1 2```

### 输出

```
No
Yes
No```

## 样例 #2

### 输入

```
3 8
1 1 2
1 1 3
1 2 3
2
3 2 3
2
3 1 2
3 2 3```

### 输出

```
Yes
Yes
No```

# 题解

## 作者：Eden_star (赞：5)

## 思路
这道题的难点就在并查集的撤销操作（~~要不然为啥是绿题~~）

首先我们来实现并查集的撤销操作。
1. 撤销操作只要把每一次合并的两个节点的编号记录下来，要撤销时就把编号对应的节点的父亲节点改成自己。
2. 观察到要拆的路是最后一条，所以可以用一个栈来维护。
## 注意
这道题目的优化不能使用路径压缩，所以用按秩合并（按树的高度合并）来优化。
## 代码
```cpp
import sys
n, m = map(int, sys.stdin.readline().split())
fa = [i for i in range(n + 1)]
rank = [0] * (n + 1)
st = []
def find(x):
    while fa[x] != x:
        x = fa[x]
    return x
for _ in range(m):
    line = sys.stdin.readline().split()
    op = int(line[0])
    if op == 1:
        if len(line) == 3:
            x, y = map(int, line[1:])
            if 1 <= x <= n and 1 <= y <= n:
                nx = find(x)
                ny = find(y)
                if rank[nx] < rank[ny]:
                    st.append((nx, ny))
                    fa[nx] = ny
                elif rank[nx] > rank[ny]:
                    st.append((ny, nx))
                    fa[ny] = nx
                else:
                    st.append((nx, ny))
                    fa[nx] = ny
                    rank[ny] += 1
    elif op == 2:
        if len(line) == 1:
            if st:
                nx, ny = st.pop()
                fa[nx] = nx
                fa[ny] = ny
    elif op == 3:
        if len(line) == 3:
            x, y = map(int, line[1:])
            if 1 <= x <= n and 1 <= y <= n:
                if find(x) == find(y):
                    print("Yes")
                else:
                    print("No")
```
最劣解什么实力我不多多说。
## 后记
本蒟蒻由于只会 C++ 但题解要求用 Python 所以输入卡了我 20 分钟

---

## 作者：Zskioaert1106 (赞：4)

题目传送门：[P12274 [蓝桥杯 2024 国 Python B] 设计](https://www.luogu.com.cn/problem/P12274)

@[123456wjc](https://www.luogu.com.cn/user/1079286) 说：“一想到二十年后如果 OI 还在，所有的小孩都必须人手掌握路径压缩和按秩合并，我就感到悲伤。”。

### 题目分析

题目要求查询连通性，所以考虑用并查集维护。

操作 1：合并 $x_i$ 和 $y_i$ 所属的集合。

操作 3：查询 $x_i$ 和 $y_i$ 是否在同一个集合内。

这两个可以轻松用并查集实现，不会的出门右转[模板题](https://www.luogu.com.cn/problem/P3367)。我们的重点在于操作 2，如何实现最近操作的撤销？

定义 $f_x$ 为 $x$ 所在集合的祖先，则合并前 $f_{f_x}=f_x$。发现（在朴素的并查集下），一次合并会使 $f_x \leftarrow y$，因此我们撤销时，只要让它变回自身就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/4qxelh0y.png)

故使用栈维护：存储每次修改的 $f_x$ 位置，合并时入栈，遇到操作 2 就将栈顶的 $f$ 变回自身。特殊地，如果合并前 $x$ 和 $y$ 就在同一集合，则撤销对其没有影响，可以入栈一个特殊值（如 $0$）。

但是这样的并查集是无法路径压缩的，否则正确性就不保了。但朴素的并查集又会超时，于是考虑按秩合并。

> 按秩合并：对于并查集的两个树形集合 $x,y$，维护它们的深度，每次将深度小的合并到深度大的上。这样可以保证查询的最劣复杂度是 $O(\log n)$。

最终复杂度为 $O(n + m\log n)$。

### 代码实现

```cpp
#include<iostream>
#include<stack>
using namespace std;
const int N=300005;
int n,m,f[N],dep[N];
int find(int x){
	if(f[x]==x)return x;
	return find(f[x]);
}
stack<int>t;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)f[i]=i,dep[i]=1;
	while(m--){
		short op;
		int x,y;
		cin>>op;
		if(op==1){
			cin>>x>>y;
			x=find(x),y=find(y);
			if(x!=y){
				if(dep[x]>dep[y])swap(x,y);
				f[x]=y,dep[y]=max(dep[y],dep[x]+1);
				t.push(x);
			}
			else t.push(0);
		}
		else if(op==2){
			if(t.empty())continue;
			x=t.top();
			t.pop();
			if(x)f[x]=x;
		}
		else{
			cin>>x>>y;
			cout<<(find(x)==find(y)?"Yes":"No")<<'\n';
		}
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/220165194)。

---

## 作者：Chase12345 (赞：4)

要维护连通性，首先想到并查集。可是有回退功能，普通并查集无法实现。这里就需要用到可撤销并查集。

可撤销并查集其实是一个并查集的一个更多功能的实现，它能实现并查集的基础功能，也能实现回退功能。例如此题。

我需要回退到上一次操作前的结果，这正是我们需要操作的。

回退功能如何实现呢？首先第一点：**不能路径压缩**。这会导致多个节点被修改，使得最后回退功能时间复杂度爆炸。

其次，不用路径压缩的话必须使用按秩合并优化。即将更小的一个子图挂到一个更大的子图，这样可以证明，树的高度是 $\log$ 级别的，也就是每次查询都能做到 $\log$ 的复杂度。

最后，如何记录上一次操作？只需用一个栈记录上一次修改过的节点修改回来就行了。

每次查询都能做到最坏 $O(\log n)$ 的复杂度。
```cpp
#include <bits/stdc++.h>
using namespace std;
 
const int N = 3e5 + 5;
int fa[N], siz[N];
stack <tuple <int, int, int>> opt;
 
void init(int n) {
    for (int i = 1; i <= n; i++) {
        fa[i] = i;
        siz[i] = 1;
    }
}
 
void del() {
    if (opt.empty())
		return;
    auto [y, old_fa_y, old_siz_x] = opt.top(); 
    opt.pop(); 
    fa[y] = old_fa_y;
    siz[fa[y]] = old_siz_x;
}
 
int find(int x) {
    while (fa[x] != x)
		x = fa[x];
    return x;
}
 
void merge(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) {
        opt.push({-1, -1, -1}); 
        return;
    }
    if (siz[x] < siz[y])
	    swap(x, y);
    opt.push({y, fa[y], siz[x]});
    fa[y] = x;
    siz[x] += siz[y];
}
 
int main() {
    int n, m;
    cin >> n >> m;
    init(n);
    while (m--) {
        int op, x, y;
        cin >> op;
        if (op == 2) {
            del(); 
            continue;
        }
        cin >> x >> y;
        if (op == 1)
            merge(x, y);
        else
            cout << (find(x) == find(y) ? "Yes\n" : "No\n");
    }
    return 0;
}
```
~~另一种方法是可持久化并查集。~~

---

## 作者：wmy18929355137 (赞：2)

# P12274 [蓝桥杯 2024 国 Python B] 设计 | [题目传送](https://www.luogu.com.cn/problem/P12274)
## 前置知识:[并查集](https://oi-wiki.org/ds/dsu/)、[栈](https://oi-wiki.org/ds/stack/)

## 思路:
首先看到操作 $1$ 和操作 $3$ 不难想到要用并查集。
但是操作 $2$ 可以撤销，因此每次进行操作 $1$ 时若合并了 $x,y$ 结点，即 $fa_{find(x)} \gets find(y)$ 时，可以维护此时的 $find(x)$ ，到操作 $2$ 时再将 $fa_{find(x)}$ $\gets find(x)$ 就可以实现操作 $2$ 的效果。

**注意到**，先修建的边一定比后修建的边晚撤销

**也就是说，我们需要用来维护 $find(x)$ 的数据结构要满足先进后出的性质**

很容易想到用**栈**了，代码很好写，**但要注意两点：**

1. 写 $find$ 函数时不能路径压缩！否则进行操作 $2$ 时只会将 $x$ 结点断开连接，不会将 $x$ 的子节点断开！

2. 写并查集连边时，**注意当 $find(x) = find(y)$ 时，也要将 $find(x)$ 压入栈里！**

于是便有了高达 $90$ pts 的代码:
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,f[900005];
stack <int> st; 

int fd(int x) {
	if (f[x] == x) return x;
	return fd(f[x]);
}

void merge(int x,int y) {
	int fx = fd(x),fy = fd(y);
	f[fx] = fy;
	st.push(fx);
}

int query(int x,int y) {
	return fd(x) == fd(y);
}

void undo(int x) {
	while (!st.empty() && x--) {
		int k = st.top();
		st.pop();
		int t = f[k];
		f[k] = k;
	}
}



int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		f[i] = i;
	} 
	while (m--) {
		int op,x,y;
		cin >> op;
		if (op == 1) {
			cin >> x >> y;
			merge(x,y);
		} else if (op == 2) {
			undo(1);
		} else {
			cin >> x >> y;
			cout << ((query(x,y)) ? "Yes\n" : "No\n");
		}
	}
	return 0;
}
```
##### 记录:https://www.luogu.com.cn/record/230808485
为啥会T呢？

这是因为我们把并查集路径合并给删了，变成了朴素的并查集，因此考虑优化并查集。

不难看到在前置知识[并查集](https://oi-wiki.org/ds/dsu/)往下稍微一翻就可以找到[启发式合并](https://oi-wiki.org/ds/dsu/#%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6)，也就是按秩合并。（将结点个数小的连接到结点个数大的）

又看到下面一句话：
> 如果只使用启发式合并，而不使用路径压缩，时间复杂度为 $O(m \log n)$。

因此我们可以再维护并查集中每个点所在的树的大小 $sz_i$，合并时再将 $sz$ 小的合并到大的即可。

### AC 代码:
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,f[900005],sz[900005];
stack <int> st; 

int fd(int x) {
	if (f[x] == x) return x;
	return fd(f[x]);
}

void merge(int x,int y) {
	int fx = fd(x),fy = fd(y);
	if (sz[fx] > sz[fy]) swap(fx,fy); // 按秩合并 
	f[fx] = fy;
	if (fx != fy) sz[fy] += sz[fx];
	st.push(fx);
}

int query(int x,int y) {
	return fd(x) == fd(y);
}

void undo(int x) {
	while (!st.empty() && x--) {
		int k = st.top();
		st.pop();
		int t = f[k];
		if (fd(t) != fd(k)) sz[t] -= sz[k];
		f[k] = k;
	}
}



int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		f[i] = i;
		sz[i] = 1;
	} 
	while (m--) {
		int op,x,y;
		cin >> op;
		if (op == 1) {
			cin >> x >> y;
			merge(x,y);
		} else if (op == 2) {
			undo(1);
		} else {
			cin >> x >> y;
			cout << ((query(x,y)) ? "Yes\n" : "No\n");
		}
	}
	return 0;
}
```
#### 记录:https://www.luogu.com.cn/record/230827157
~~(成功抢到最优解的第17名)~~

---

## 作者：tonghaoxuan (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12274)
### 题意：

$ n $ 个点（城市），$ m $ 个操作，每个操作有建立边（修建道路）、删除最后建立的边（拆除道路）和询问两点之间是否连通三种情况。

### 思路：

看到建边和连通（并和查），我们自然能想到并查集的做法，但并查集并不支持删边操作，这同样也是本题需要攻克的难点。

首先，本题仅涉及删除最后的边，那么我们就可以用栈来维护从后往前的操作，即维护之前的建立边的操作使哪个点指向另一个点，删除时使这个改变的边重新指向自己（如，上一次操作使 ```f[a]=b```，就应该记录下 ```{a,b}```，在删除时使 ```f[a]=a``` 并让这次记录出栈。注意，建立边的时候输入 ```cin>>x>>y```，应该令 ```a=find(x)```,```b=find(y)```），这样做就可以做到类似删除边的功能。

### 问题：

这样做的基础是建立边只影响一个变量，所以缺点是不能路径压缩（因为如果路径压缩，建立一条边对于并查集的改变就不止 ```f[a]``` 一个，会只得到 $ 60 $ 分），这样的时间复杂度最坏就是 $ n ^ 2 $ 级别的（会少几个常数），就可能会 ```TLE```（以下代码），那又该怎么解决呢？

### $ 90 $ 分代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[300005];
struct info{
	int p,q,x;
}a[300005];
stack<int> st;
inline int fd(int x){
	while(f[x]!=x){
		x=f[x];
	}
	return x;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		f[i]=i;
	}
	for(int i=1;i<=m;i++){
		cin>>a[i].x;
		if(a[i].x==3){
			cin>>a[i].p>>a[i].q;
			int fp=fd(a[i].p),fq=fd(a[i].q);
			if(fp==fq){
				cout<<"Yes\n";
			}else{
				cout<<"No\n";
			}
		}else if(a[i].x==2){
			if(!st.empty()){
				f[st.top()]=st.top();
				st.pop();
			}
		}else if(a[i].x==1){
			cin>>a[i].p>>a[i].q;
			int fp=fd(a[i].p),fq=fd(a[i].q);
			st.push(fp);
			f[fp]=fq;
		}
	}
}
```

### 解决方式：

前面说过，不路径压缩的时间复杂度最坏是 $ n ^ 2 $ 级别的，但由于实际会少常数，时间限制又在 $ 3 $ 秒这么长，所以只要我们再减几个常数，就能够 ```AC```。

具体的，由于不能路径压缩，我们可以让一个规模更大的连通块指向规模较小的，这样就可以减少整体的查询的时间复杂度的常数（减的蛮多的）。具体来说，我们用某数组标记每个连通块的点数，比较后再选择改变 ```f[a]=b``` 或是 ```f[b]=a```。

### ```AC``` 代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int b[300005];
int f[300005];
struct info{
	int p,q,x;
}a[300005];
stack<pair<int,int>> st;
inline int fd(int x){
	while(f[x]!=x){
		x=f[x];
	}
	return x;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		f[i]=i;
		b[i]=1;
	}
	for(int i=1;i<=m;i++){
		cin>>a[i].x;
		if(a[i].x==3){
			cin>>a[i].p>>a[i].q;
			int fp=fd(a[i].p),fq=fd(a[i].q);
			if(fp==fq){
				cout<<"Yes\n";
			}else{
				cout<<"No\n";
			}
		}else if(a[i].x==2){
			if(!st.empty()){
				f[st.top().first]=st.top().first;
				b[st.top().first]-=b[st.top().second];
				st.pop();
			}
		}else if(a[i].x==1){
			cin>>a[i].p>>a[i].q;
			int fp=fd(a[i].p),fq=fd(a[i].q);
			if(b[fq]>b[fp]){
				st.push({fp,fq});
				f[fp]=fq;
				b[fp]+=b[fq];
			}else{
				st.push({fq,fp});
				f[fq]=fp;
				b[fq]+=b[fp];
			}
		}
	}
}
```

---


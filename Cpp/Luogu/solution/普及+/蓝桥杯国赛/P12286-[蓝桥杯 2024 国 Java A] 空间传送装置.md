# [蓝桥杯 2024 国 Java A] 空间传送装置

## 题目描述

蓝桥王国拥有 $42$ 座城市以及 $42$ 位骑士。这些骑士按照 $1$ 到 $42$ 的编号顺序，分别居住在对应编号的城市中。即第 $1$ 位骑士居住在城市 $1$，第 $2$ 位骑士居住在城市 $2$，依此类推。

最近，王国中引入了一项革命性技术：空间传送装置。该装置可以根据一个长度为 $42$ 的数字排列 $a$，将所有骑士一次性传送至新的城市。

排列 $a$ 必须由 $1 \sim 42$ 共 $42$ 个数字组成，且每个数字只出现一次。在传送操作中，位于城市 $i$（$i = 1, 2, 3, \cdots, 42$）的骑士会被传送到城市 $a_i$。例如，如果 $a_1$ 的值为 $3$，那么当前位于城市 $1$ 的骑士会被传送至城市 $3$。

为测试技术的可靠性，王国决定连续 $2024$ 天每天使用同一排列 $a$ 进行一次传送操作。

小蓝负责为这次测试设计排列 $a$，她的目标是确保所有骑士在经过 $2024$ 天传送后，都能返回自己的起始城市。而在此之前的任何一天，不会出现所有骑士都回到起始城市的情况。

请问，有多少种不同的数字排列 $a$ 能满足小蓝的需求？由于答案可能很大，因此你只需要将答案对 $10^9 + 7$ 取模后提交即可。

数字排列 $a$ 是由 $1$ 到 $42$ 这 $42$ 个数字按照一定顺序排列而成的序列。每个数字在排列中只能出现一次，且所有数字必须全部包含在排列中。

如果两个排列中至少有一个位置上的数字不同，则这两个排列被视为不同的数字排列。例如，$\{1, 2, 3, \cdots, 42\}$ 和 $\{1, 3, 2, \cdots, 42\}$ 就是不同的数字排列，因为它们在第二个位置上的数不相同。

# 题解

## 作者：Lyx8058 (赞：5)

## 思路：

需要满足其 $42$ 个骑士构成的多个循环的周期的最小公倍数为 $2024$。

那么我们首先将 $2024$ 进行分解：$2024=2^3\times 11\times 23$。

观察以上式子不难发现，我们只能分别构成周期为 $8$，周期为 $11$ 和周期为 $23$ 的三个循环。巧合的是，$8+11+23=42$。

那么由于每一次都需要传送到不同的地方以便于循环的正常运行，要不然就会原地死循环。

那么每一个循环都恰好需要一个与该循环中的城市互不相同的城市，而且仔细读题不难发现不可能有循环的部分城市公共利用。所以得出该题目中的城市循环中每个点相互不相同。

那么结合上面 $8+11+23=42$ 的推理，我们可以发现恰好构成的三个循环又恰好满足以上条件。

## 进一步推导：

我们已知，当循环的周期长度为 $n$ 时，其可选择的方案数为 $(n-1)!$。

而我们又知道，当在 $n$ 个点里面选 $m$ 个不同的点时且不考虑顺序，我们的合法方案数为 $C_m^n=\frac{n!}{m!(n-m)!}$。

结合以上两个条件，我们可以发现，问题转化为在 $42$ 个点里面选 $8$ 个点构成循环，再选 $11$ 个点构成循环，最后将剩下 $23$ 个点构成循环，所得到得方案数。

那么可以推导出公式为 $C_{8}^{42}\times C_{11}^{42-8}\times C_{23}^{42-8-11}\times (8-1)!\times (11-1)! \times (23-1)!$。

化简以上式子得到：$C_{8}^{42}\times C_{11}^{34}\times 7!\times 10! \times 22!$。

展开得到：$\frac{42!}{8!\times 34!}\times \frac{34!}{11!\times 23!}\times 7!\times 10!\times 22!$。

化简得：$\frac{42!}{8\times 11\times 23}$。

所以，答案由上述推导轻松得出：$\frac{42!}{8\times 11\times 23} \bmod 10^9+7$。

## 代码如下：

注：以下代码已经过格式化，放心观看。

```cpp
#include<bits/stdc++.h>

#define int long long
using namespace std;
const int mod = 1e9 + 7;
int ans = 1;
signed main() {
    for (int i = 2; i <= 42; i++) {
        if (i != 8 && i != 11 && i != 23) {
            ans = ans * i % mod;
        }
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：_Null_Ptr (赞：3)

题目大意：找到长度为 $42$ 的排列 $a$，使得 $a$  的最小正周期为$2024$，即 $a$ 可以被分解为若干个循环，这些循环的长度的最小公倍数为 $2024$。

解题思路：首先，为了使循环长度的最小公倍数为 $2024$ 且长度和为 $42$，那么循环长度必须是 $2024$ 小于 $42$ 因数，包括：$1$，$2$，$4$，$8$，$11$，$22$，$23$,所以排列 $a$ 如果要使其长度和为 $42$，就必须由长度为 $8$，$11$ 和 $23$ 的循环组成。

想必到这里就非常简单了，不就是一个简单的排列组合问题吗？我们可以选择 $8$ 个位置来形成长度为 $8$ 的循环，有 $\binom{42}{8}$ 种选择方式。从剩下的 $34$ 个位置中选择 $11$ 个位置来形成长度为 $11$ 的循环，有 $\binom{34}{11}$ 种选择方式。最后，剩下的 $23$ 个位置自然形成长度为 $23$ 的循环，有 $\binom{23}{23}=1$ 种选择方式。

最后，因为对于每个长度为 $k$ 的循环，有 $(k-1)!$ 种不同的排列方式。因此，长度为 $8$ 的循环有 $7!$ 种排列方式，长度为 $11$ 的循环有 $10!$ 种排列方式，长度为 $23$ 的循环有 $22!$ 种排列方式。

综上所述，答案即为：
$$\left(\binom{42}{8}\times\binom{34}{11}\times 7!\times 10!\times 22!\right)\bmod(10^9+7)$$
自己口算一下提交即可。

---

## 作者：caichengyia (赞：2)

原序列可分解为一些循环。骑士第一次都能返回自己的起始城市的时间是循环长度的最小公倍数。因为一个循环里的骑士能在 $n$ 轮返回原处当且仅当循环长度整除 $n$ 。
$$2024=2^3\times11\times23$$
所以满足条件的骑士数最少是 $2^3+11+23=42$ （个）。
\
这使问题变得简单，因为只有一种循环长度分配，即 $8$、$11$、$23$。

而借助圆排列的公式可得 $ans=P^{8}_{42}\times P^{11}_{34}\times P^{23}_{23}\div8\div11\div23$ 。
其中 $P^{8}_{42}\times P^{11}_{34}\times P^{23}_{23}=42!$ ，所以在计算阶乘时，在 $8$、$11$、$23$ 处不做乘法即可。
# java code
```java
import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[]) throws Exception {
        Scanner cin=new Scanner(System.in);
        long ans=1L;
        for(int i=1;i<=42;i++){
            if((i!=8)&&(i!=11)&&(i!=23))ans=ans*i%1000000007;
        }
        System.out.println(ans);
    }
}
```

---

## 作者：caichengyia (赞：0)

原序列可分解为一些循环。骑士第一次都能返回自己的起始城市的时间是循环长度的最小公倍数。因为一个循环里的骑士能在 $n$ 轮返回原处当且仅当循环长度整除 $n$ 。
$$2024=2^3\times11\times23$$
所以满足条件的骑士数最少是 $2^3+11+23=42$ （个）。
\
这使问题变得简单，因为只有一种循环长度分配，即 $8$、$11$、$23$。

而借助圆排列的公式可得 $ans=P^{8}_{42}\times P^{11}_{34}\times P^{23}_{23}\div8\div11\div23$ 。
其中 $P^{8}_{42}\times P^{11}_{34}\times P^{23}_{23}=42!$ ，所以在计算阶乘时，在 $8$、$11$、$23$ 处不做乘法即可。
# java code
```java
import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[]) throws Exception {
        Scanner cin=new Scanner(System.in);
        long ans=1L;
        for(int i=1;i<=42;i++){
            if((i!=8)&&(i!=11)&&(i!=23))ans=ans*i%1000000007;
        }
        System.out.println(ans);
    }
}
```

---


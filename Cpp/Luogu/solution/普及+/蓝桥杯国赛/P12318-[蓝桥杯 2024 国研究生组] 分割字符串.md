# [蓝桥杯 2024 国研究生组] 分割字符串

## 题目描述

给定一个仅含小写字母的字符串 $S$ ，你可将其分割成任意份子串。我们要求分割后任何一段的长度都不大于 $5$ ，且相邻的两个子串不能含有相同的字母。例如 $\tt{abcdae}$ 分割为 $\tt{abcd}$ 和 $\tt{ae}$ 都含 $\tt{a}$，不合法，但可以分割为 $\tt{abcda}$ 和 $\tt{e}$，或者 $\tt{ab}$、$\tt{cd}$、$\tt{ae}$ 等。

问该字符串的所有长度小于等于 $5$ 的本质不同的子串中，哪些在任何分割方案中都没有出现过，按字典序将它们全部输出。


## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$|S| \leq 10$；
- 对于 $60\%$ 的评测用例，$|S| \leq 5000$；
- 对于所有评测用例，$1 \leq |S| \leq 10^5$。

## 样例 #1

### 输入

```
abab```

### 输出

```
4
ab
aba
ba
bab```

# 题解

## 作者：DengDuck (赞：2)

我感觉很简单啊。

就是，你考虑枚举所有的长度小于等于五的子串，然后目标是搞定左右的划分。

我们发现一种最简单有效的划分方法是一个同样字母的区间划分成一段，这样能保证出现的字母尽可能少而且区间长度经可能小，从而尽量满足条件。

我们发现这个方案唯一会导致出错的情况是同字母区间长度大于 $5$，这种本来就没有解，所以这个方案是最佳的。

然后我们只需要记录全局是否有解，没解的话所有枚举的子串都不可能出现在解里面，他们全部退役。否则对于每个枚举的子串，你考虑只要左右不冲突就一定有满足上述条件的方案，所以你 Check 区间 $S[L,R]$ 的时候只需要判断 $S_{L-1},S_{R+1}\in S[L,R]$ 就可以了。

时间复杂度是 $\mathcal O(n\log n)$ 的，因为用了 `set` 和 `map`。

可能没实现好。

```cpp
#include<bits/stdc++.h>
using namespace std;
string S;
int n,Hav;
set<string>Se;
map<string,int>Ma;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>S;
	n=S.size(),S=" "+S;
	for(int i=1;i<=n-5;i++)
	{
		int Flg=1;
		for(int j=1;j<=6;j++)
		Flg&=S[i+j]==S[i];
		Hav|=Flg;	
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=5;j++)
	{
		if(i+j-1>n)break;
		if(Hav)continue;
		int Flg=1;
		if(i!=1)
		for(int x=0;x<j;x++)if(S[i-1]==S[i+x])Flg=0;
		if(i+j-1!=n)
		for(int x=0;x<j;x++)if(S[i+j]==S[i+x])Flg=0;
		if(Flg)Ma[S.substr(i,j)]=1;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=5;j++)
	{
		if(i+j-1>n)break;
		Se.insert(S.substr(i,j));
	}
	vector<string>V;
	for(auto i:Se)
	{
		if(Ma[i])continue;
		V.push_back(i);
	}
	cout<<V.size()<<endl;
	for(auto i:V)
	{
		cout<<i<<endl;
	}
}
```

---

## 作者：YBa2Cu3O7 (赞：0)

贪心，外加一定的暴力。

## 思路
为了避免出现相邻子串内出现相同字符，要么把邻居的拿过来，要么中间再隔一个邻居，而如果出现相同字符相邻的情况，就必须要让它们在同一个子串内。所以存在满足题目条件的分割等价于不能出现连续的 $6$ 个相同字符。

先遍历一遍检查是否存在合法分割，同时暴力地把所有长度不超过 $5$ 的子串全都存在集合中。如果不存在合法分割那么直接输出全部子串即可。

接下来看哪些子串是有可能出现在分割中的。因为已经全局地不存在连续的 $6$ 个相同字符，所以抽掉任何一个子串之后，左右两端子串仍然有合法分割，三段拼起来就是当前问题的一个分割。这样问题就转化为了，对于每一个长度不超过 $5$ 的子串，将它视为某种分割结果的一部分，检查当前分割是否合法。而这一点只需要检查该子串左右两端的相邻字符是否在当前子串内出现，这是因为总可以做分割把两侧的单个字符单独出来。

## 代码
简单用一个类进行了封装，其中 `is_solvable` 表示是否存在合法分割，`pre` 预处理存储所有子串并检查是否存在合法分割，`solve` 函数用来剔除掉不合法的子串，类成员变量使用 `set` 而不是 `unordered_set` 是为了利用到 `set` 的有序性，自动按字典序输出。


```cpp
#include<bits/stdc++.h>
using namespace std;
class Solution {
	string str;
	int is_solvable;
	set<string> st;

	void pre() {
		int n = str.length();
		for (int i = 0; i < n - 5; ++i) {
			int flag = 1;
			for (int j = 0; j < 5; ++j) {
				st.insert(str.substr(i, j + 1));
				if (str[i] != str[i + j]) {
					flag = 0;
				}
			}
			if (str[i] != str[i + 5]) {
				flag = 0;
			}
			if (flag) {
				is_solvable = 0;
			}
		}
		for (int i = n - 5; i < n; ++i) {
            if (i < 0) continue;
			for (int j = 0; j < 5; ++j) {
				if (i + j >= n) break;
				st.insert(str.substr(i, j + 1));
			}
		}
	}

public:
	Solution(string& s) : str(std::move(s)), is_solvable(1) {}

	void solve() {
		pre();
		if (is_solvable == 0) return;
		int n = str.length();
		for (int i = 0; i < n; ++i) {
			unordered_set<char> ust;
			for (int j = 1; j <= 5; ++j) {
				if (i + j > n) {
					break;
				}
				ust.insert(str[i + j - 1]);
				int flag = 1;
				if (i > 0) {
					if (ust.find(str[i - 1]) != ust.end()) {
						flag = 0;
						break;
					}
				}
				if (i + j < n) {
					if (ust.find(str[i + j]) != ust.end()) {
						flag = 0;
					}
				}
				if (flag == 1) {
					st.erase(str.substr(i, j));
				}
			}
		}

	}

	void output() {
		cout << st.size() << '\n';
		for (const auto& s : st) {
			cout << s << '\n';
		}
	}

};


int main() {
	string str;
	cin >> str;
	Solution sol(str);
	sol.solve();
	sol.output();
	return 0;
}
```

---


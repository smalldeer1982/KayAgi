# [蓝桥杯 2025 国 A] 树

## 题目描述

给定一棵树，你需要从树上选择若干个点，使得选择的任意两点之间的距离均大于 $2$。

输出符合条件的选择的方案数（可以选中任意个，但不能不选）。由于答案可能很大，你只需要输出答案对 $998244353$ 取模的结果。

## 说明/提示

**【评测用例规模与约定】**

对于 40% 的评测用例，$1 \leq n \leq 20$；

对于 80% 的评测用例，$1 \leq n \leq 5000$；

对于所有评测用例，$1 \leq n \leq 3 \times 10^5$，$u_i \neq v_i$，$1 \leq u_i, v_i \leq n$。

## 样例 #1

### 输入

```
6
1 2
1 3
3 4
3 5
5 6```

### 输出

```
12```

# 题解

## 作者：sky_cyh (赞：8)

首先，考虑树上计数动规。

设 $dp_{u,0}$ 为选节点 $u$ 的方案数。

设 $dp_{u,1}$ 为不选节点 $u$，选一个子节点的方案数，注意，只能选一个，因为如果选两个及以上 $u$ 的子节点就不满足条件了。

设 $dp_{u,2}$ 为不选节点 $u$，也不选任何 $u$ 的子节点的方案数。

显然，如果选了节点 $u$，那么 $u$ 的子节点和孙子节点都不能选，转移方程为 $dp_{u,0}=\prod_{v\in son(u)}{dp_{v,2}}$。

对于不选节点 $u$，也不选任何子节点的情况，选不选孙子节点不影响，只要不选子节点就行了，转移方程为 $dp_{u,2}=\prod_{v\in son(u)}({dp_{v,1}+dp_{v,2}})$。

对于不选节点 $u$，选一个子节点的情况，我们可以枚举选的那个子节点，其余子节点不选，设选的子节点为 $v$，转移方程为 
$dp_{u,1}=\sum_{v\in\text{son}(u)}\left(dp_{v,0}\times\prod_{\substack{w\in\text{son}(u)\\w\neq v}}(dp_{w,1}+dp_{w,2})\right)
$。

用逆元处理前缀积和后缀积即可。

答案为三种情况数之和再减去全不选的情况。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=998244353;
const int N=300010;
int n;
long long dp[N][3];
vector<int>G[N];
//dp[u][0]：选u。
//dp[u][1]：不选u，选u子节点。
//dp[u][2]：不选u，不选u子节点。
long long qpow(long long x,long long y) {
	x%=mod;
	long long res=1;
	while(y) {
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y/=2;
	}
	return res;
}
long long inv(long long x) {
	x%=mod;
	return qpow(x,mod-2);
}
void dfs(int u,int fa) {
	dp[u][0]=dp[u][2]=1;
	long long res1=1,res2=1;
	for(int v:G[u]) {
		if(v==fa) continue;
		dfs(v,u);
		dp[u][0]=dp[v][2]*dp[u][0]%mod;
		dp[u][2]=(dp[v][1]+dp[v][2])%mod*dp[u][2]%mod;
		res1=res1*(dp[v][1]+dp[v][2])%mod;
	}
	for(int v:G[u]) {
		if(v==fa) continue;
		res1=inv(dp[v][1]+dp[v][2])*res1%mod;
		dp[u][1]=(dp[u][1]+(dp[v][0]*res1%mod*res2)%mod)%mod;
		res2=res2*(dp[v][1]+dp[v][2])%mod;
	}
}
int main() {
	cin>>n;
	for(int i=1; i<n; i++) {
		int u,v;
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1,0);
	cout<<(dp[1][0]+dp[1][1]+dp[1][2]-1+mod)%mod;
	return 0;
}
```

---

## 作者：qiutian120529 (赞：3)

# 洛谷 P12844 题解

## 题意

给定一棵树，你需要从树上选择若干个点，使得选择的任意两点之间的距离均大于 $2$。

输出符合条件的选择的方案数（可以选中任意个，但不能不选）。

## 思路

考虑树上动态规划。

$dp_{i,j}$ 表示子树 $i$ 从下向上走了 $j$ 步。$dp_{i,0}$ 表示当前子树被选的方案数，$dp_{i, 1}$ 表示当前子树往上走 $1$ 步的方案数，$dp_{i, 2}$ 表示当前子树向上走 $2$ 步及以上的方案数。当两个被选的点的距离小于等于 $2$ 时，答案不合法；否则记录答案。所以可以得到以下转移：

$$\left\{\begin{split} &dp_{u,0} = \prod_{v \in son} dp_{v, 2} \\ &dp_{u, 1} = \sum_{v \in son} dp_{v, 0} \times \prod_{t \in son,t \ne v} (dp_{t,1} + dp_{t,2}) \\ &dp_{u,2} = \prod_{v \in son} (dp_{v,1} + dp_{v, 2}) \end{split} \right.$$

我们发现对于累乘，很多工作是重复的所以可以通过前、后缀积优化时间。

## 代码

```cpp
#include<iostream>
#include<vector>
#define int long long
using namespace std;

const int N = 3e5 + 10, mod = 998244353;

int n, dp[N][5], pre[N], nxt[N];

vector<int> g[N];

void dfs(int u, int fa){
  for(auto v : g[u]){
    if(v == fa) continue;
    dfs(v, u);
  }
  dp[u][0] = dp[u][2] = 1;
  for(auto v : g[u]){
    if(v == fa) continue;
    dp[u][0] = dp[u][0] * dp[v][2] % mod;

    dp[u][1] = dp[u][1] * (dp[v][1] + dp[v][2]) % mod;
    (dp[u][1] += dp[u][2] * dp[v][0] % mod) %= mod;

    dp[u][2] = (dp[v][1] + dp[v][2]) % mod * dp[u][2] % mod;
  }
}

signed main(){
  cin >> n;
  for(int i = 1, u, v; i < n; i++){
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs(1, 0);
  cout << (dp[1][0] + dp[1][1] + dp[1][2] - 1 + mod) % mod;//这里要减一是因为不能不选，要减去没选任何点的方案
  return 0;
}

```

---

## 作者：ShwStone (赞：3)

给一个状态设计极简的题解：

记 $f_{i,0/1}$ 表示 $i$ 选或者不选，子树内的方案数。

$f_{i,1}$ 的值是对于所有孙子做乘积： $\prod_{j \in \text{grandson}(i)} f_{j,0}$。所有儿子默认不选。显然是对的。

这个时间复杂度也是对的，因为每个点只有一个爷爷，所以这一步统计总共是 $\mathcal O(n)$ 的。

对于 $f_{i,0}$，儿子可选可不选。但是，因为兄弟之间的距离为 2，所以**至多选一个儿子**。

那就用经典技巧：维护 $f_{\text{son},0}$ 的前缀积和后缀积，如果选取第 $k$ 个儿子，就把 $f_{k,1}$ 和 $k-1$ 前缀、$k+1$ 后缀拼起来。

也可以用逆元处理，但是参考 ICPC 成都，说不定树状 DP 卡零逆元呢。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN(3e5 + 5);
const long long MOD(998244353);

int n;
vector<int> tree[MAXN];

long long dp[MAXN][2];
long long ll[MAXN], rr[MAXN];

void dfs(int u, int f) {
    dp[u][1] = 1;
    int cnt = 0;
    
    for (int v : tree[u]) {
        if (v == f) continue;
        dfs(v, u);
    }
    
    for (int v : tree[u]) {
        if (v == f) continue;
        for (int w : tree[v]) {
            if (w == u) continue;
            (dp[u][1] *= dp[w][0]) %= MOD;
        }
    }
    
    for (int v : tree[u]) {
        if (v == f) continue;
        cnt++;
        ll[cnt] = rr[cnt] = dp[v][0];
    }
    ll[0] = rr[cnt + 1] = 1;
    for (int i = 1; i <= cnt; i++) {
        ll[i] = (ll[i - 1] * ll[i]) % MOD;
    }
    for (int i = cnt; i >= 1; i--) {
        rr[i] = (rr[i + 1] * rr[i]) % MOD;
    }
    dp[u][0] = ll[cnt];
    int id = 0;
    for (int v : tree[u]) {
        if (v == f) continue;
        id++;
        (dp[u][0] += (dp[v][1] * ll[id - 1] % MOD * rr[id + 1]) % MOD) %= MOD;
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    dfs(1, 0);
    cout << (dp[1][0] + dp[1][1] + MOD - 1) % MOD << endl;
    return 0;
}
```

另：我考完用 Copilot 辅助复现了我的代码，结果神人 Copilot 不会写后缀积，写了这么依托：

```cpp
rr[i] = rr[i + 1] * ll[i] % MOD;
```

挂的只剩 30 分。吓我一跳。现在开始后怕，感觉考场上可能会挂一些莫名其妙的分。

---

## 作者：Weekoder (赞：0)

题目要求方案数，考虑树形 DP。

- 状态：设 $dp_{i,0/1}$ 表示在以 $i$ 为根的子树内，点 $i$ 不选或选时的方案数。
- 转移：若 $i$ 选，则 $i$ 的子结点和孙子结点都不能选，子结点不选的状态包括了孙子结点选的状态，不可取；孙子结点不选的状态考虑不到上一层，因此默认子结点不选，其贡献视作 $1$，$dp_{i,1}=\displaystyle\prod_{u\in\text{son}(i)}\prod_{v\in\text{son}(u)}dp_{v,0}$。若 $i$ 不选，则子结点和孙子结点都可以选，考虑到子结点的状态已经包含了孙子结点的状态，转移子结点的状态即可。显然，子结点可以都不选，但至多选一个，因为拥有同一个父结点的兄弟结点之间的距离为 $2$，即 $\text{son}_1\to\text{father}\to\text{son}_2$。因此，$dp_{i,0}=\displaystyle\sum_{u\in\text{son}(i)\cup0}\Big(dp_{u,1}\cdot\prod_{v\in\text{son}(i)\land v\ne u}dp_{v,0}\Big)$，注意搞清楚乘法原理和加法原理的区别。$v$ 在子树内显然连续，用前缀后缀积维护即可。
- 答案：$dp_{i,0}+dp_{i,1}-1$，因为至少要选一个点。

:::info[code]{open}
```cpp
#include <bits/stdc++.h>

#define debug(x) (cout << #x << " " << x << "\n")

using namespace std;

using ll = long long;

const int N = 3e5 + 5, mod = 998244353;

ll n, dp[N][2], lmul[N], rmul[N];

vector<ll> nbr[N];

void dfs(ll cur, ll fa) {
	dp[cur][1] = 1;
	ll cnt = 0;
	for (auto nxt : nbr[cur]) (nxt != fa) && (dfs(nxt, cur), 1);
	for (auto nxt : nbr[cur]) if (nxt != fa) {
		for (auto nnxt : nbr[nxt]) if (nnxt != cur) {
			dp[cur][1] = (dp[cur][1] * dp[nnxt][0]) % mod;
		}
		++ cnt;
		lmul[cnt] = rmul[cnt] = dp[nxt][0];
	}
	lmul[0] = rmul[cnt + 1] = 1;
	for (ll i = 1; i <= cnt; i++) lmul[i] = (lmul[i] * lmul[i - 1]) % mod;
	for (ll i = cnt; i >= 1; i--) rmul[i] = (rmul[i] * rmul[i + 1]) % mod;
	cnt = 0, dp[cur][0] = rmul[1];
	for (auto nxt : nbr[cur]) if (nxt != fa) {
		++ cnt;
		dp[cur][0] = (dp[cur][0] + dp[nxt][1] * lmul[cnt - 1] % mod * rmul[cnt + 1] % mod) % mod;
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	for (ll i = 1, u, v; i < n; i++) {
		cin >> u >> v;
		nbr[u].emplace_back(v);
		nbr[v].emplace_back(u);
	}
	dfs(1, 0);
	ll ans = (dp[1][0] + dp[1][1]) % mod - 1;
	cout << (ans % mod + mod) % mod;
	return 0;
}
```

:::

---

## 作者：_Chronostatis_ (赞：0)

## 题意
给定一棵树，现要求在树上选若干个点（不能不选），使得任意两点间的距离**严格大于 2**，求选择方案数。

## 思路
这题肯定是上位绿了。

考虑树上 dp。题目要求距离严格大于 2，那么也就是距离最小的两个点距离大于 2。考虑 LCA 不为其中之一的两点 $u, v$，如果需要从以 $u, v$ 为根的子树中选点，那么只需求 $u, v$ 间的距离即可。如果这个距离等于 2，那么 $u, v$ 至少有一个不能选，如果大于 2，那么全部可选。

设计状态 $dp_{u, i}$ 表示以 $u$ 为根的子树内，从 $u$ 出发，走 $i$ 步，从 $u$ 开始的前 $i$ 个点均不选的方案数。发现，$i \ge 3$ 的状态都可以扔进 $i = 2$ 里面。所以重新设计状态 $dp_{u, 0/1/2}$ 表示以 $u$ 为根的子树内，从 $u$ 出发，走 $0/1/2$ 步，从 $u$ 开始的前 $0/1/2$ 个点均不选的方案数。
考虑转移：
- $dp_{u, 0}$ 表示从 $u$ 出发走 $0$ 步，从 $u$ 开始的前 $0$ 个都不选的方案数，也即选择 $u$ 的方案数，那么 $dp_{u, 0}$ 应当从 $dp_{v, 2}$ 转移而来，$v$ 为 $u$ 的子节点。那么有

$$
dp_{u, 0} = \prod_{v \in son_s} dp_{v, 2}
$$

- $dp_{u, 1}$ 表示从 $u$ 出发走 $1$ 步，从 $u$ 开始的前 $1$ 个都不选的方案数，也即从以子节点为根的子树中选取节点的方案数。此时，因为距离严格大于 2，所以最多有一个子节点出现。又发现，不选子节点的方案数被 $dp_{u, 2}$ 包含，所以只需计算有一个子节点出现的答案即可。有

$$
dp_{u, 1} = \sum_{v \in son_s} dp_{v, 0} \times \prod_{v' \in (son_s - v)} (dp_{v', 1} + dp_{v', 2})
$$

- $dp_{u, 2}$ 表示从 $u$ 出发走 $2$ 步，从 $u$ 开始的前 $2$ 个都不选的方案数，也即不选 $u$ 和其任何子节点。那么 $dp_{u, 2}$ 应当从 $dp_{v, 1} + dp_{v, 2}$ 转移而来。有


$$
dp_{u, 2} = \prod_{v \in (son_s)} (dp_{v, 1} + dp_{v, 2})
$$

转移时，可以先计算 $dp_{u, 0}, dp_{u, 2}$，在计算 $dp_{u, 1}$ 时，利用 $dp_{u, 2}$ 的答案乘上 $(dp_{v, 1} + dp_{v, 2}) ^ {-1}$ 即可。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAXN = 3e5 + 10, MOD = 998244353;

int n;
ll dp[MAXN][3], pre[MAXN];
ll fac[MAXN], inv[MAXN];
vector<int> g[MAXN];

ll qpow(ll x, ll y) {
  ll res = 1;
  for (; y; y >>= 1, (x *= x) %= MOD) {
    if (y & 1) (res *= x) %= MOD;
  }
  return res;
}

void dfs(int u, int fa) {
  dp[u][0] = dp[u][2] = pre[u] = 1;
  for (int v : g[u]) {
    if (v == fa) continue;
    dfs(v, u);
    (dp[u][0] *= dp[v][2]) %= MOD;
    (dp[u][2] *= dp[v][1] + dp[v][2]) %= MOD;
    (pre[u] *= dp[v][1] + dp[v][2]) %= MOD;
  }
  for (int v : g[u]) {
    if (v == fa) continue;
    (dp[u][1] += dp[v][0] * (pre[u] * qpow(dp[v][1] + dp[v][2], MOD - 2) % MOD) % MOD) %= MOD;
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 1, u, v; i < n; i++) {
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs(1, 0);
  cout << (dp[1][0] + dp[1][1] + dp[1][2] - 1 + MOD) % MOD;
  return 0;
}
```

---

## 作者：yuhong056 (赞：0)

# 题解：P12844 [蓝桥杯 2025 国 A] 树
## 思路分析
首先，我们思考简化版：
> 在一个区间上，找出选择若干个相距超过 $2$ 的数，求这样的方案数有多少。

首先，可以发现这就是一个裸的 dp，设 $dp_{i, 0/1/2}$ 为在前 $i$ 个数中，没有选后 $0/1/\ge 2$ 个数（也就是选了 $i$；没选 $i$，选了 $i - 1$；$i,i - 1$ 都没有选），转移就可以轻松得出：
$$dp_{i, 2} \to dp_{i + 1, 0}$$
$$dp_{i, 0} \to dp_{i + 1, 1}$$
$$dp_{i, 1} + dp_{i, 2} \to dp_{i + 1, 2}$$

接下来，我们考虑将问题换到树上。

首先，这个状态改为 $dp_{u, 0/1/2}$ 为在节点 $u$ 上没有选 $0/1/\ge 2$ 级儿子（也就是选了 $u$；没选 $u$，选了 $u$ 的儿子；没选 $u$ 和其所有儿子）。

接下来，考虑转移：
$$dp_{u, 2} \to dp_{fa, 0}$$
这个转移显而易见。
$$dp_{u, 2} \gets \prod_{son}(dp_{son,1} + dp_{son, 2})$$
这个转移是因为，不包含 $u$ 及其儿子的，前面计算已经满足题目要求，又因为每个子树互相独立，因此应用乘法原理。
$$dp_{u, 1} \gets \sum_{son1}\{dp_{son1, 0} \times \prod_{son2\atop son2 \ne son1}(dp_{son2, 1} + dp_{son2, 2})\}$$
这个转移是因为，仅包含 $u$ 的儿子的，必然只包含其儿子一个，不然不满足题目要求。

接下来选择了一个儿子，剩下的儿子只要不选即可。

因为每个子树互相独立，因此应用乘法原理。
## CODE
```cpp
#include<bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAXN = 3e5 + 35, MOD = 998244353;

int n;
ll dp[MAXN][3];
vector<int>e[MAXN];

void dfs(int u, int fa) {
  for(int v : e[u]) {
    if(v == fa)continue;
    dfs(v, u);
  }
  dp[u][0] = dp[u][2] = 1;
  for(int v : e[u]) {
    if(v == fa)continue;
    dp[u][0] = dp[u][0] * dp[v][2] % MOD;
    dp[u][1] = ((dp[v][1] + dp[v][2]) * dp[u][1] % MOD + dp[u][2] * dp[v][0] % MOD) % MOD;
    dp[u][2] = dp[u][2] * (dp[v][1] + dp[v][2]) % MOD;
  }
}

int main(){
  cin >> n;
  for(int i = 1, u, v; i < n; i++) {
    cin >> u >> v;
    e[u].push_back(v);
    e[v].push_back(u);
  }
  dfs(1, 0);
  cout << (dp[1][0] + dp[1][1] + dp[1][2] - 1 + MOD) % MOD;
  return 0;
}
```

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18934452)

不难发现思路是使用树形动态规划。我们给每个节点维护四种状态：选中该节点、该节点距离最近的已选点是父节点、是祖父节点、以及祖先两级之外都没有已选点。

其中选中状态只能和子节点的**父节点已选**状态匹配，以保证子节点与当前节点距离大于 $2$。

如果当前节点处于与最近已选点距离恰为 $1$ 或恰为 $2$ 的状态，则子节点的状态分别变为距离 $2$ 和无约束。

如果当前节点无约束，则子节点既可以选中（进入选中状态），也可以保持无约束。这样，通过后序遍历累乘合并子树贡献，就能计算出每个节点在四种状态下的方案数。

为了避免递归栈溢出，先用 BFS 确定父子关系与遍历顺序，再按逆序进行 DP 转移。每次处理一个节点时，对它所有子节点的四个状态值进行常数次乘法和加法运算，整体时间复杂度为 $O(n)$。最后在根节点上把“选中”与“无约束”两种状态的方案数相加并减去空集即可得到答案。

[link](https://www.luogu.com.cn/record/220786326)

---

## 作者：xrz114514 (赞：0)

# 洛谷 P12844 题解
## 思路
考虑进行树上 dp。一种思路是定义状态 $dp_{i,j}$ 表示在 $i$ 的子树中选一些点且离 $i$ 最近的选的点离 $i$ 的距离为 $j$ 的方案数。明显，这样的时间复杂度和空间复杂度不允许，但发现当中如果 $j \ge 2$，那对之后的转移完全不影响，因为当我们在合并儿子子树的答案时，由于一个儿子子树的 $j \ge 2$，那其他的儿子子树最坏也到当前节点有 1 的距离，加起来的距离一定大于 $2$，并且，对我当前选不选也无影响。所以，可以重新定义状态：$dp_{i,j}$，其中，$0 \le j \le 3$。
1. $dp_{i,0}$ 表示 $i$ 子树中选 $i$ 的方案数。
2. $dp_{i,1}$ 表示 $i$ 子树中选了 $i$ 的儿子但未选 $i$ 的方案数，即原先状态中的 $dp_{i,1}$。
3. $dp_{i,2}$ 表示原先状态中的 $\sum\limits_{j = 2}^{n} dp_{i,j}$。

考虑转移。
1. 对于 $dp_{i,0}$ 来说，他的所有儿子子树都必须只能为 $dp_{i,2}$，因为这样才能都使距离大于 2。并且，由于所有儿子子树中 $dp_{i,2}$ 互不影响，故 $dp_{i,0} = \prod\limits_{v \in son_i} dp_{v,2}$。
2. 对于 $dp_{i,1}$ 则其只能且必须有一个点为 $dp_{v,0}$，因为一旦有多个，就会导致有两点距离为 2。其他的倒是无所谓，因为这样的距离一定大于 2。故:
    $$dp_{i,1} = \sum\limits_{v_1 \in son_i} (dp_{v_1, 0} \cdot \prod\limits_{v_2 \in son_i \cup v_2 \ne v_1} (dp_{v_2, 1} + dp_{v_2, 2}))$$
   这里可以先求出 $\prod\limits_{v \in son_i } (dp_{v, 1} + dp_{v, 2})$，最后可以用逆元进行求解。
3.  对于 $dp_{i,2}$，其的儿子可以选 $dp_{v,1}$ 或 $dp_{v,2}$，但不能选 $dp_{v,0}$，因为这样距离就为一，不满足状态设计中的定义。故 $dp_{i,2} = \prod\limits_{v \in son_i} (dp_{v,0} + dp_{v,1})$。

时间复杂度： $O(n \log mod)$。  
空间：$O(n)$。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 3e5 + 1, Mod = 998244353;

int n, ans, dp[N][3];
vector<int> g[N];

int Pow(int x, int y){
  int res = 1;
  for(; y; y >>= 1){
    if(y & 1){
      res = 1ll * res * x % Mod;
    }
    x = 1ll * x * x % Mod;
  }
  return res;
}

void dfs(int u, int fa){
  dp[u][0] = dp[u][2] = 1;
  for(int v : g[u]){
    if(v != fa){
      dfs(v, u);
      dp[u][0] = 1ll * dp[u][0] * dp[v][2] % Mod;
      dp[u][2] = 1ll * dp[u][2] * ((dp[v][1] + dp[v][2]) % Mod) % Mod;
    }
  }
  for(int v : g[u]){
    if(v == fa){
      continue;
    }
    dp[u][1] = (dp[u][1] + 1ll * dp[v][0] * dp[u][2] % Mod * Pow((dp[v][1] + dp[v][2]) % Mod, Mod - 2) % Mod) % Mod;
  }
}

int main(){
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for(int i = 1, u, v; i < n; ++i){
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs(1, 0);
  cout << ((((dp[1][2] + dp[1][1]) % Mod + dp[1][0]) % Mod - 1 + Mod) % Mod);
  return 0;
}
```

---


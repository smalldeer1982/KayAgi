# [蓝桥杯 2025 国 Python A] 心意

## 题目描述

小蓝有一个序列 $a$，同时他的朋友小乔有一个序列 $b$。

我们认为两个序列是和谐的，当且仅当存在某个数 $x$，使得对于所有的 $i$ 有 $a_i + x = b_i$。

现在小蓝可以让序列 $a$ 旋转，即通过一次参数为 $k$ 的旋转可以将序列 $a_1, a_2, \cdots, a_n$ 变为 $a_{1+k}, a_{2+k}, \cdots, a_n, a_1, a_2, \cdots, a_k$。

小蓝希望知道，是否存在这样的旋转操作，能够让序列 $a$ 和 $b$ 是和谐的。

输出共一行，一个自然数 $k$ 表示参数为 $k$ 的旋转操作能够让 $a, b$ 是和谐的，如果存在多个这样的 $k$，请输出最小的 $k$，如果不存在这样的 $k$，请输出 $-1$。

## 说明/提示

**【样例说明】**

小蓝可以让序列 $a$ 旋转得到 $3 \ 4 \ 5 \ 2$，根据和谐序列的定义，令 $x = -1$，那么此时 $a, b$ 就是和谐的。

**【评测用例规模与约定】**

对于 $50\%$ 的评测用例，$n \leq 3000$；

对于 $80\%$ 的评测用例，对于任意 $i \neq j$ 有 $a_i \neq a_j$；

对于所有评测用例，$1 \leq n \leq 5 \times 10^5$，$1 \leq a_i, b_i \leq 10^9$。

## 样例 #1

### 输入

```
4
2 3 4 5
2 3 4 1```

### 输出

```
1```

# 题解

## 作者：koukou (赞：5)

## 问题分析

给定两个长度为 $n$ 的数字序列 $a$ 和 $b$。允许的操作是：从序列 $a$ 的末尾截取任意一段移动到开头。操作后得到的新序列记为 $a'$，需要判断是否存在常数 $x$ 使得对于所有 $i \in [1, n]$ 都满足：

$$
a'_i + x = b_i
$$

## 数学建模

设通过将 $a$ 循环右移 $k$ 位得到 $a'$，则有：

$$
a'_i = a_{(i + k - 1) \bmod n + 1}
$$

需要满足的等式关系为：

$$
b_i - a_{(i + k - 1) \bmod n + 1} = x \quad \forall i \in [1, n]
$$

## 差分数组分析

为保证 $x$ 是常数，需要满足相邻元素的差分关系一致。构造：

### 序列 $b$ 的差分数组 $p$

$$
p_i = 
\begin{cases} 
b_{i+1} - b_i & 1 \leq i < n \\ 
b_1 - b_n & i = n 
\end{cases}
$$

### 序列 $a$ 的扩展差分数组 $\text{diff}$（长度为 $2n$）

$$
\text{diff}_i = a_{(i \bmod n) + 1} - a_{i \bmod n} \quad 1 \leq i \leq 2n
$$

## 算法思路

使用 KMP 算法在 $\text{diff}$ 数组中匹配 $p$ 数组：

$$
\text{KMP}(\text{diff}, p) \rightarrow k
$$

若匹配成功，则返回移位参数 $k$，否则返回无解。

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 1;
int n, a[N], b[N], diff[2 * N], p[N], nxt[N];
void get_nxt()
{
    for(int j = 2, i = 0; j <= n; j++)
    {
        while(i > 0 && p[j] != p[i + 1]) i = nxt[i];
        if(p[j] == p[i + 1]) i++;
        nxt[j] = i;
    }
    return;
}
int kmp()
{
    for(int i = 1, j = 1; i < 2 * n;) 
    {
        if(j <= n && diff[i] == p[j]) 
        {
            i++; j++;
            if(j > n) return i - j;
        }
        else if(j > 1) j = nxt[j - 1] + 1;
        else i++;
    }
    return -1;
}
int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) cin >> b[i];
    for(int i = 1; i <= n; i++) 
    {
        int x = (i == n) ? 1 : i + 1;
        p[i] = b[x] - b[i];
    }
    for(int i = 1; i <= 2 * n; i++) 
    {
        int cnt = (i > n) ? i - n : i;
        int x = (cnt == n) ? 1 : cnt + 1;
        diff[i] = a[(i == 2 * n) ? 1 : (i >= n ? x : (cnt + 1))] - a[cnt];
    }
    get_nxt();
    int pos = kmp();
    if(pos != -1) cout << pos % n;
    else cout << -1;
    return 0;
}
```

---

## 作者：CSP_S_2023_T2 (赞：4)

KMP 模板题。

由题意得 $x=\frac{{\sum b_i} - {\sum a_i}}{n}$。

若 $x$ 不为整数，显然不可能。

若 $x$ 为整数，构造出序列 $a$ 的目标序列，记为 $d$（$d_i=b_i-x$）。

若 $a$ 能旋转成为 $d$，则 $d$ 必为 $a$ 重复一遍所得序列（即将 $a$ 接在 $a$ 末尾形成的序列）的**连续子序列**，KMP 即可。

（什么你不会？出门右转[模板题](https://www.luogu.com.cn/problem/P3375)）

找到第一个符合条件的值就可以退出了。

注意未找到要输出 $-1$。

代码如下：

（本人是 C++ 选手码风有点丑请见谅）


```python
a=list(range(1000020))
b=list(range(500010))
need=list(range(500010))
nex=list(range(1000020))
ans=-1

def get_next(n):
    nex[0]=0
    nex[1]=0
    j=0
    for i in range(2,n*2+1):
        while j>0 and a[j]!=a[i-1]:
            j=nex[j]
        if a[j]==a[i-1]:
            j=j+1
        nex[i]=j
        
def kmp(n):
    global ans
    j=0
    for i in range(0,n*2):
        while j>0 and need[j]!=a[i]:
            j=nex[j]
        if need[j]==a[i]:
            j=j+1
        if j==n:
            ans=i
            return
        
n=int(input())
a_input=list(map(int,input().split()))
b_input=list(map(int,input().split()))
cnt1=0
cnt2=0
for i in range(0,n):
    a[i]=a_input[i]
    a[n+i]=a[i]
    cnt1=cnt1+a[i]
for i in range(0,n):
    b[i]=b_input[i]
    cnt2=cnt2+b[i]
if (cnt1-cnt2)%n!=0:
    print(-1)
else:
    k=(cnt1-cnt2)//n;
    for i in range(0,n):
        need[i]=b[i]+k
    get_next(n);
    kmp(n);
    if ans!=-1:
        print(ans-n+1)
    else:
        print(-1)
```

---

## 作者：_LRH_ (赞：3)

- ## 题意

  给出两个数组，可以把其中一个数组 $a$ 进行一次参数为自然数 $k$ 的操作使 $a$ 变为 $a_{1+k}, a_{2+k}, \cdots, a_n, a_1, a_2, \cdots, a_k$。是否存在这样的旋转操作，在操作之后存在某个数 $x$，使得对于所有的 $i$ 有 $a_i + x = b_i$。让我们求这个 $k$ 的最小值。无解输出 $-1$ 。

- ## 思路

  很容易想到应该将 $a$ 数组整体加上一个数等于 $b$ 中的所有元素之间的大小关系是不变的，所以我们可以将 $a，b$ 复制一份然后排序求出 $x$，然后我们可以将原有的 $b$ 整体减去一个 $x$ 问题就变成了操作 $a$ 使 $a$ 和 $b$ 一样。我们可以考虑使用哈希来做这件事。从小到大枚举 $k$ 然后去判它的合法性。不会的同学可以去 [这里](https://www.luogu.com.cn/problem/P3370) 学习一下。

- ## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const long long N = 5e5 + 5, base = 1331, mod = 1e9 + 7;

long long a[N], b[N], A[N], B[N], n;

// A,B为两个用来排序求x的数组
 
ll h1[N], h2, lg[N];

// h1,a数组的哈希值，h2,b的哈希值, lg[i]进制的i次方
 
int main() {
	cin >> n;
	for (long long i = 1; i <= n; i++) {
		cin >> a[i];
		A[i] = a[i];
	}
	for (long long i = 1; i <= n; i++) {
		cin >> b[i];
		B[i] = b[i];
	}
	sort (A + 1, A + 1 + n), sort (B + 1, B + 1 + n);
	long long x = B[1] - A[1];
	for (long long i = 1; i <= n; i++) {
		b[i] -= x;
	} 
	
	//求出x，把b数组整体减去x使“和谐”条件变为完全相等 
	
	lg[0] = 1;
	for (long long i = 1; i <= n; i++) {
		h1[i] = (h1[i - 1] * base + a[i]) % mod;
		lg[i] = (lg[i - 1] * base) % mod; 
		h2 = (h2 * base + b[i]) % mod;
	} 
	
	//求哈希值
	 
	for (long long i = 0; i < n; i++) {
		
		long long cnt = h1[i] + (((((h1[n] - (h1[i] * lg[n - i] % mod)) + mod) % mod) * lg[i]) % mod) % mod;
		
		/*这一行是核心
		   如何去判合法性因为前i个数到了后面，所以它的值还是h1[i]
		   拿h1[n]减去h1[i]的lg[n-i]就是算出后面的哈希值
		   乘上一个lg[i]是因为i个数到了后面会把前面的往前顶 
		*/
		cnt %= mod;
		long long tmp = h2;
		if (cnt == tmp) {
			cout << i;
			return 0;
		}
	}
	cout << -1;
	return 0;
}

---

## 作者：convie (赞：2)

暴力骗分法，首先通过将两个数组进行排序，排序后看看两个数组的对位差值是否相等，不相等直接输出 -1，因为要差值相同就必然是排序后的对位差值相同。

然后再离散变成全排列的模式，因为题目说过任意两个数的值是不相同的，然后再看题目所说的旋转操作，我们发现无论怎么旋转，数组中元素的相对圆排列是不会变的，因此我们只需要在数组 $a$ 的圆排列中找到恰好和 $b$ 一样排序的排列就行了，又因为每个元素都不相同，所以直接暴力枚举就行了，这样可以拿到大部分的分，但是由于数据过水过了，代码如下。
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<stack>
#include<unordered_map>
using namespace std;
#define int long long
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define MAXN 55
#define x first
#define y second
#define debug cout<<"&"<<endl; 
int a[MAXN];
int b[MAXN];
int c[MAXN];
int d[MAXN];
signed main(){
	ios;
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		c[i]=a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		d[i]=b[i];
	}
	sort(c+1,c+1+n);
	sort(d+1,d+1+n);
	for(int i=2;i<=n;i++)
	if(c[i]-d[i]!=c[i-1]-d[i-1]){
		cout<<-1<<endl;
		return 0;
	}
	unordered_map<int,int> mp;
	int cnt=0;
	for(int i=1;i<=n;i++)mp[c[i]]=++cnt;
	for(int i=1;i<=n;i++)a[i]=mp[a[i]];
	cnt=0;
	for(int i=1;i<=n;i++)mp[d[i]]=++cnt;
	for(int i=1;i<=n;i++)b[i]=mp[b[i]];
	for(int i=1;i<=n;i++)a[i+n]=a[i];
	int cn=1;
	int id=1; 
	for(int i=1;i<=2*n;i++){
		if(a[i]!=b[cn]){
			cn=1;
			id=i;
		}else cn++;
		if(cn>n){
			cout<<id<<endl;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```
对于数据中出现的相同元素，我们这时候就必须要用到 KMP 算法了，用解字符串的方式来初始化 $ne$ 数组，正确代码如下。
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<stack>
#include<unordered_map>
using namespace std;
#define int long long
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define MAXN 1000010
#define x first
#define y second
#define debug cout<<"&"<<endl; 
int a[MAXN];
int b[MAXN];
int c[MAXN];
int d[MAXN];
int ne[MAXN]; 
signed main(){
	ios;
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		c[i]=a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		d[i]=b[i];
	}
	sort(c+1,c+1+n);
	sort(d+1,d+1+n);
	for(int i=2;i<=n;i++)
	if(c[i]-d[i]!=c[i-1]-d[i-1]){
		cout<<-1<<endl;
		return 0;
	}
	unordered_map<int,int> mp;
	int cnt=0;
	for(int i=1;i<=n;i++)mp[c[i]]=++cnt;
	for(int i=1;i<=n;i++)a[i]=mp[a[i]];
	cnt=0;
	for(int i=1;i<=n;i++)mp[d[i]]=++cnt;
	for(int i=1;i<=n;i++)b[i]=mp[b[i]];
	for(int i=1;i<=n;i++)a[i+n]=a[i];
  //使用KMP
	for(int i=2,j=0;i<=n;i++){
		while(j&&b[j+1]!=b[i])j=ne[j];
		if(b[j+1]==b[i])j++;
		ne[i]=j;
	}
	for(int i=1,j=0;i<=2*n;i++){
		while(j&&b[j+1]!=a[i])j=ne[j];
		if(b[j+1]==a[i])j++;
		if(j==n){
			cout<<i-j<<endl;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：2)

# P12877 [蓝桥杯 2025 国 Python A] 心意 题解  
来个神异的做法，[最小表示法](https://www.luogu.com.cn/problem/P13270)。  
### 解题思路  
显然，如果“旋转”后，使得 $\forall i\in[1,n)$，有 $a_i-b_i=a_{i+1}-b_{i+1}$，那么肯定是 $a$ 和 $b$ 中排名相等的对上。  

那么我们就可以用最小表示法，现将两个序列都变为字典序最小的同构串，再逐一比较就可以了。  

但是题目只让我们旋转 $a$，好在通过幼儿园大班的知识，我们知道运动是相对的，$b$ 向左移动了 $x$ 位，就等价于 $a$ 向右移动了 $x$ 位。   

设变成字典序最小的同构串 $a$ 向左旋转了 $t_1$ 位，$b$ 向左旋转了 $t_2$ 位，那么答案就是 $(t_1-t_2+n)\bmod n$。  
### AC 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+50;
int n;
int a[N],b[N];
int t1,t2;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1;i<=n;i++) scanf("%d",b+i);
	int i=1,j=2,k=0;
	while(i<=n && j<=n && k<n){
		if(a[(i+k-1)%n+1]==a[(j+k-1)%n+1]) k++;
		else{
			if(a[(i+k-1)%n+1]>a[(j+k-1)%n+1]) i+=k+1;
			else j+=k+1;
			if(i==j) i++;
			k=0;
		}
	}
	t1=min(i-1,j-1);
	i=1,j=2,k=0;
	while(i<=n && j<=n && k<n){
		if(b[(i+k-1)%n+1]==b[(j+k-1)%n+1]) k++;
		else{
			if(b[(i+k-1)%n+1]>b[(j+k-1)%n+1]) i+=k+1;
			else j+=k+1;
			if(i==j) i++;
			k=0;
		}
	}
	t2=min(i-1,j-1);
	int tmp=b[t2%n+1]-a[t1%n+1];
	for(int i=2;i<=n;i++){
		if(a[(i+t1-1)%n+1]+tmp!=b[(i+t2-1)%n+1]){
			printf("-1");
			return 0;
		}
	}
	printf("%d",(t1+n-t2)%n);
}
```

---

## 作者：true_kun (赞：1)

这是一道 KMP 的模版题，因为 $a_i+x=b_i$ 所以我们将 $a$ 数组和 $b$ 数组求和作差，不难得到：
  $$\sum_{i=1}^n a_i+n\times x=\sum_{i=1}^n b_i$$
稍加变形得到：
  $$x=\frac{\sum_{i=1}^n b_i−\sum_{i=1}^n a_i}{n}$$

应用经典的破环成链的思想，那么我们就将原问题转化为，有一个数字串 $c$，其第 $i$ 个位置上的值为 $b_i-x$，我们需要判断数字串 $c$ 是否是 $a+a$ 的子串。（此处 $a+a$ 表示子在 $a$ 后面复制一个 $a$）

自此，问题便变成了一个经典的 KMP 问题，通过字符串匹配便可以线性的通过。

什么？你不会字符串匹配？请移步[这里](https://www.luogu.com.cn/problem/solution/P3375)

最后贴一下代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[5000005],b[5000005],c[5000005];//目标序列
int nxt[500005];
signed main()
{
    //freopen("a.in", "r", stdin);
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin>>n;
    int sum1=0,sum2=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i+n]=a[i];//破环成链
        sum1+=a[i];//求和
    }
    for(int i=1;i<=n;i++){
        cin>>b[i];
        sum2+=b[i];
    }
    int x=(sum2-sum1)/n;
    for(int i=1;i<=n;i++){
        c[i]=b[i]-x;
    }
    int j=0;
    for(int i=2;i<=n;i++){
  //字符串的自我匹配，求解配模式串的border
        while(j&&c[i]!=c[j+1]) j=nxt[j];
        if(c[i]==c[j+1]) j++;
        nxt[i]=j;
    }
    j=0;
    for(int i=1;i<=2*n;i++){
         while(j&&a[i]!=c[j+1]) j=nxt[j];
         if(a[i]==c[j+1]) j++;
         if(j==n){、/求解答案
            cout<<i-n;
            return 0;
         }
    }
    cout<<-1;
   return 0;
}

```

---

## 作者：imnotcfz (赞：0)

# P12877 [蓝桥杯 2025 国 Python A] 心意 题解

这是一篇 Python 的偷鸡做法，看似绿题，**实则绿的点只在于打出 KMP 板子**。由于 Python 已经帮我们造好了轮子，~~我的评价是：建议降红~~。

# 0x01 分析

首先，题目中的旋转，可以注意到其实就是环形地向左平移，于是我们只需要**破环成链**——直接将 $a$ 数组倍长，就可以拿着 $b$ 数组从左往右一个个匹配，时间复杂度为 $O(n^2)$，即使是效率更高的 C++ 也只有 60pts。

考虑如何将**匹配**的复杂度降下来……等等，说到匹配，如果能使用 **KMP 算法**，复杂度就可以降到 $O(n)$。但显然不能直接这么搞，因为题目要求 $a$ 数组加上一个数 $x$ 后才能得到 $b$ 数组，因此我们需要一些**转化**。

仔细再想想这句话，实际上能否匹配成功与 $a$、$b$ 的具体取值**无关**，而在于元素之间的**变化量是否一致**。说到变化量，我们可以使用环形**差分**求出变化量，这样就可以直接通过 KMP 算法找出答案。

# 0x02 实现

> Talk is cheap, show me the code!

Python 中的 KMP 算法实现为`str`类的`find`方法，通过调用内置的`help(str.find)`可以得到相关信息（已翻译）：
```python
find(self, sub[, start[, end]], /) builtins.str 方法
    返回 S 中找到子串 sub 的最小索引，使得 sub 包含在 S[start:end] 之间。

    可选形参 start 和 end 与切片表示法一致。
    失败时返回 -1。
```

码量少，好写，去掉注释和空行仅有 22 行。

```python
n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
# 计算差分数组
differenceA, differenceB = [], []
# 特判第一个数字
differenceA.append(a[0] - a[n - 1])
differenceB.append(b[0] - b[n - 1])
for i in range(1, n):
    differenceA.append(a[i] - a[i - 1])
    differenceB.append(b[i] - b[i - 1])
# 破环成链
differenceA += differenceA
# 为了方便查找，将差分数组转换为字符串
stringA = ','.join(map(str, differenceA))
stringB = ','.join(map(str, differenceB))
# 核心算法：字符串匹配
result = stringA.find(stringB)
if result == -1:  # 若不存在则输出 -1
    print(result)
else:
    # 接下来我们需要找到下标 result 对应的是第几个数字
    currentPosition = 0  # 表示字符串中的位置
    for index, number in enumerate(differenceA):
        if currentPosition == result:
            print(index)
            break
        currentPosition += len(str(number)) + 1
```

# 0x03 总结

最慢时间 720ms，最大内存 145MB。另外，使用 PyPy 3 会负优化 T 掉（我也不知道为啥）。

这题其实不难想，只需要差分转化，正如开头所说，核心其实是 KMP 算法。玩 Python 想要偷鸡，同样需要对内置函数及标准库足够熟悉。如果考场上真忘了怎么用，就打开 Python 安装目录下的`/Doc/html/index.html`吧，尤其是 Library reference 板块，它会告诉你一切的。

---


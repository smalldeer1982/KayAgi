# [蓝桥杯 2025 国 C] 数列染色

## 题目描述

有一个长度为 $n$ 的数列 $(a_1, a_2, \cdots, a_n)$，初始时只有 $a_1$ 和 $a_n$ 是黑色的，其它数都是白色的。小蓝可以选择若干白色的数将其染黑，但是必须满足相邻的两个黑色的数之间最多包含 $k$ 个白色的数，他想让所有黑色的数的和尽可能小，请问他最少可以让所有黑色的数的和为多少。

## 说明/提示

**【样例说明】**

选择染黑 $a_2, a_5$，黑色的数的和为 $5 + 2 + 5 + 7 = 19$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1 \leq n \leq 10$；

对于 $50\%$ 的评测用例，$1 \leq n \leq 5000$；

对于所有评测用例，$0 \leq k < n \leq 10^5$，$1 \leq a_i \leq 10^6$。


## 样例 #1

### 输入

```
8 2
5 2 7 5 5 9 3 7```

### 输出

```
19```

# 题解

## 作者：Mindulle (赞：7)

单调队列优化 DP 板子题。

### 普通 DP 解题步骤：
- 定义状态：我们令 $dp_i$ 表示将 $a_i$ 染黑时，从 $a_1$ 到 $a_i$ 的最小黑数和，且 $a_1$ 必须被染黑。
- 初始条件：$dp_1=a_1$（因为 $a_1$ 初始就是黑的）。
- 转移方程：对于 $i$，我们需要从 $i-k-1$ 到 $i-1$ 的位置中找到一个 $j$，使得 $dp_j$ 最小，则有：
  $$dp_i = \min(dp_i,dp_j + a_i)$$
- 最终答案：由于 $a_n$ 必须被染黑，所以答案是 $dp_n$。

直接按照上述 DP 转移会有一个问题：对于每个 $i$，需要检查 $i-k-1$ 到 $i-1$ 的所有 $j$，这会导致 $O(nk)$ 的时间复杂度，无法通过此题。

如何优化？我们需要一种方法能够快速找到 $[i - k - 1, i - 1]$ 区间内的最小 $dp_j$。这类似于滑动窗口的最小值问题，而单调队列正是解决这类问题的经典方法。

### 单调队列优化的步骤：

- 对于当前的 $i$，首先移除队列中所有 $j < i - k - 1$ 的（因为它们已经超出了窗口范围）。
- 此时队首的 $j$ 就是 $i-k-1$ 到 $i-1$ 中 $dp_j$ 最小的，直接取：
$$dp_i = dp_j + a_i$$
- 然后将 $i$ 加入队列，但在加入之前，移除队列中所有 $dp_j \ge dp_i$ 的 $j$（因为对于后面的 $j$，$i$ 比这些 $j$ 更近且 $dp_i$ 更小，所以这些 $j$ 永远不会被选中）。

### 参考代码

我采用手写队列的方式，如果习惯用 STL 的双端队列，可以参考其他题解。

```cpp
dp[1]=a[1];
q[head=rear=1]=1;
for(int i=2;i<=n;i++){
    while(head<=rear&&q[head]<i-k-1) head++;
    dp[i]=dp[q[head]]+a[i];
    while(head<=rear&&dp[q[rear]]>=dp[i]) rear--;
    q[++rear]=i;
}
cout<<dp[n];
```


### 总结

这是一道很好的单调队列优化 DP 的练手题，类似的题目还有很多，在这里推荐几题：

- [P3572 「POI 2014」PTA-Little Bird](https://www.luogu.com.cn/problem/P3572)
- [P2627 「USACO 2011」Mowing the Lawn](https://www.luogu.com.cn/problem/P2627)
- [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)

最后，希望这篇题解能帮到你！

---

## 作者：Zskioaert1106 (赞：4)

题目传送门：[P12882 [蓝桥杯 2025 国 C] 数列染色](https://www.luogu.com.cn/problem/P12882)

本题考察基础线性动态规划设计和单调队列动态规划优化。

### 题目分析

首先能想到动态规划，定义状态 $f_i$ 表示最后一个黑色位置为 $i$ 时，可能的最小答案。容易想到边界和结果：$f_1=a_1,ans=f_n$。

根据题目约束，两个相邻黑色间距不能大于 $k$，即 $f_i$ 要从往前一个到往前 $k+1$ 个转移来。即：$f_i = \min\{f_j\}+a_i,i-k-1\leqslant j < i$。

暴力转移的复杂度为 $O(nk)$，只能拿 $50$ 分。发现随着 $i$ 的增大，$j$ 的范围是一个滑动的区间。优化转化为滑动窗口问题，可以使用单调队列解决。

> 单调队列是一种快速查找滑动窗口内最值的方法，不会的可以先去[模板题](https://www.luogu.com.cn/problem/P1886)。

这样就能优化到 $O(n)$ 了。

### 代码实现

发现存 $f$ 数组就够了，于是可以读入时直接读到 $f_i$ 里，还省了一个 $a$ 的空间。

最初要把边界 $1$ 放进单调队列。

注意：由于答案可能达到 $\sum a_i = 10^5 \times 10^6$，所以要开 `long long`。

```cpp
#include<iostream>
#include<deque>
using namespace std;
const int N=100005;
int n,k;
long long f[N];
deque<int>q;
int main(){
    cin>>n>>k>>f[1];
    q.push_back(1);
    for(int i=2;i<=n;i++){
        cin>>f[i];
        if(q.front()<i-k-1)q.pop_front();
        f[i]+=f[q.front()];
        while(!q.empty()&&f[q.back()]>=f[i])q.pop_back();
        q.push_back(i);
    }
    cout<<f[n];
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/227290806)。

---

## 作者：__liujy (赞：4)

读完题后，可以很容易的想出动态规划的普通解法。

我们令 $dp_{i}$ 表示前 $i$ 个数并且第 $i$ 个数的颜色是黑色，则我们可以很简单的推出方程 $dp_{i}=\min(dp_{i},x+a_{i})$，其中 $x$ 为 $dp_{\max(1,i-k-1)}$ 到 $dp_{i-1}$ 的最小值。

可这样时间复杂度为 $O(nk)$，明显不能通过。

我们可以用[单调队列](https://www.luogu.com.cn/problem/P1886)优化去优化动态规划。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
typedef long long LL;
int n,k;
LL a[N],dp[N];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	dp[1]=a[1];
	deque<int> dq;
	dq.push_back(1);
	for(int i=2;i<=n;i++)
	{
		while(dq.size()&&dq.front()<i-k-1) dq.pop_front();
		dp[i]=dp[dq.front()]+a[i];
		while(dq.size()&&dp[i]<=dp[dq.back()]) dq.pop_back();
		dq.push_back(i);
	}
	cout<<dp[n]<<'\n';
	return 0;
}
```

---

## 作者：tuboshu666 (赞：2)

## 解法一：
令 $dp_i$ 表示考虑到第 $i$ 个数，并且选择将第 $i$ 个数涂黑的最小代价。

由于相邻黑色数字最多相隔 $k$ 个白色数字，因此在选择第 $i$ 个数字涂黑时，一定要保证前 $k+1$ 个数字中一定有一个数字被选。于是我们枚举这 $k+1$ 个数字，取其中最小即可。转移方程是显然的：

$$
dp_i = \mathop{\min}\limits_{i-k-1 \leq j \leq i-1} dp_j + a_i
$$

dp 部分代码：
```cpp
    memset(dp,0x7f7f7f7f,sizeof(dp));
    dp[1] = a[1];
    for (int i = 2 ; i <= n ; i++)
    {
        for (int j = max(1,i-k-1) ; j < i ; j++)
        {
            dp[i] = min(dp[i],dp[j]+a[i]);
        }
    }
```

该解法复杂度 $O(nk)$，无法通过本题，考虑优化。

## 解法二：

从转移方程下手优化。注意到，我们实际上只关心 $i$ 前面 $k+1$ 个 dp 值的最小值。$dp_i$ 的值就是通过这个最小值转移而来。

于是问题转化为，我们要在一个宽度为 $k+1$ 的滑动窗口快速求最小值。自然想到**单调队列**优化。

若不了解单调队列求最值问题，可先移步模版题：[P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)。

简单概括队首最小的单调队列的实现：

1. 窗口向右移动一格。

2. 删除队首超出窗口范围的元素。

3. 当前队首即是窗口内的最值。

4. 将当前元素与队尾元素比较，若队尾元素大于等于该元素，则将队尾元素删除。重复该操作，直到队尾元素小于当前元素。

5. 将当前元素插入队尾。

于是在单调队列优化 dp 下，本题就迎刃而解了。

## 完整代码：
```cpp
#include <iostream>
#include <queue>
using namespace std;

const int N = 1e5 + 10;
deque<int> q;
long long dp[N];
int a[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n,k;
    cin >> n >> k;
    for (int i = 1 ; i <= n ; i++) cin >> a[i];

    q.push_back(1);
    dp[1] = a[1];
    for (int i = 2 ; i <= n ; i++)
    {
        while (!q.empty() && q.front() < i-k-1) q.pop_front();
        dp[i] = dp[q.front()] + a[i];
        while (!q.empty() && dp[i] <= dp[q.back()]) q.pop_back();
        q.push_back(i);
    }

    cout << dp[n] << endl;

    return 0;
}
```

## 后话：

推荐两道单调队列优化 dp 的经典问题：

[P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)

[P2034 选择数字](https://www.luogu.com.cn/problem/P2034)

---

## 作者：MonKeySort_ZYczc (赞：2)

呕。这道题和 [USACO 单调队列典题](https://www.luogu.com.cn/problem/P2627)有什么大区别。  
唐桥杯不会出题可以不出，不至于**批发**打火机咬。
## 思路流程
贪心显然不行，考虑 dp。  
设 $dp_i$ 代表染黑 $a_i$ 后所有黑色的数的和，由于每 $k+1$ 个数一定要有一个黑色的数，列出转移方程：  
$$
dp_i=\min_{j=\max(0,i-k-1)}^{i-1}(dp_j)+a_i
$$  
由于 $a_1$ 是黑色的，所以边界条件为 $dp_1=a_1$。  
又由于 $a_n$ 是黑色的，答案即为 $dp_n$。  
这个暴力显然是 $O(n^2)$ 写法，由于每次查询的是定长区间最大值，直接上单调队列优化。  
总时间复杂度 $O(n)$，但单调队列会带来一个极小常数。  
## 代码实现
长也不是很长，单调队列优化 dp 典题是这样的。  
手搓单调队列没有用 deque，空间习惯性开 $n\times4$，小一点不知道会不会离奇 WA。  
注意不开 long long 见祖宗，因此挂了一发。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+10;
int n,k,a[N],dp[N],que[N<<2][2],head=1,tail; 
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		while(head<=tail&&que[head][1]<i-k-1) head++;
		dp[i]=que[head][0]+a[i];
		while(head<=tail&&que[tail][0]>=dp[i]) tail--;
		que[++tail][0]=dp[i];que[tail][1]=i;
	}
	cout<<dp[n];
}

```

---

## 作者：hex4C45 (赞：2)

> #Lugou Update

## 题目分析

我们考虑 DP。设 $f_i$ 为 **当这一位被涂黑后，从第一位到这一位所有被涂黑的数的和的最小值** 。然后第 $1$ 位是已经涂黑了的，所以 $f_1=a_1$。

白色的部分长度不能超过 $k$，也就是说，当前第 $i$ 位只能从与它下标差值不超过 $k+1$ 位的 $f_j$ 转移来。则容易列出方程：

$$f_i= \min \limits_{i-j\le k+1} \{ f_j \} +a_i$$

那么答案就是 $f_n$。因为第 $n$ 位也要涂黑。

上式复杂度是 $\mathcal O(nk)$ 的。不能通过。注意到前面那块求最小值可以跑一个单调队列即可 $\mathcal O(n)$。

双倍经验：P2034。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a[114514],f[114514];
int n,k;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    deque<int> q;
    q.push_back(1);f[1]=a[1];
    for(int i=2;i<=n;i++)
    {
        while(!q.empty() and i-q.front()>k+1) q.pop_front(); //不超过反过来就是超过
        f[i]=f[q.front()]+a[i];
        while(!q.empty() and f[q.back()]>=f[i]) q.pop_back();
        q.push_back(i);
    }
    cout<<f[n];
}
```

---

## 作者：Tomwsc (赞：1)

# 题解：P12882 [蓝桥杯 2025 国 C] 数列染色

## 前言

本文中的 $f$ 和 $a$ 数组下标均从 $0$ 开始。

## 思路

考虑 dp。

设 $f_i$ 表示前 $i$ 个数且第 $i$ 个数染成黑色的最小和，那么显然有 $O(nk)$ 的转移方程为：

$$f_i = \min\limits_{\max(0,i-k-1)\le j<i}\{f_j\}+a_i$$

注意到我们只需要知道 $[\max(0,i-k-1),i)$ 中的最小 dp 值即可，这明显是一个滑动窗口，所以考虑单调队列优化。具体地讲，就是每次先将下标小于 $\max(0,i-k-1)$ 的数从队首 ```pop``` 掉，然后使用队首的数更新 $f_i$，最后将队尾的 dp 值大于 $f_i$ 的都从队尾 ```pop``` 掉，再把 $f_i$ ```push``` 进队中。

初始化为 $f_0=a_0$，最终结果便为 $f_{n-1}$。 

## 代码

记得开 ```long long```。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define i128 __int128
#define inf (1ll << 62)
#define pb push_back
#define mp make_pair
#define PII pair<int , int>
#define fi first
#define se second
using namespace std;

inline void solve() {
	int n , k;
	cin >> n >> k;
	vector<int>a(n);
	vector<ll>f(n);
	for(auto &i : a) cin >> i;
	f[0] = a[0];
	vector<int>q(n + 1);
	int head = 1 , tail = 1;
	q[1] = 0;
	for(int i = 1;i < n;i ++) {
		while(head < tail && q[head] < i - k - 1) head ++;
		f[i] = f[q[head]] + a[i];
		while(head < tail && f[q[tail]] > f[i]) tail --;
		q[++ tail] = i;
	}
	cout << f[n - 1] << "\n";
	return;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t = 1;
	// cin >> t;
	while(t --) {
		solve();
	}
	return 0;
}
```

---

## 作者：GreenMelon (赞：1)

DP，单调队列优化。

要使黑色数总和尽可能小，就要让每个要改变成黑色数的值尽可能小，则 $dp_i$ 的值为 $i-k-1$ 到 $i-1$（注意不包括 $i$）之间最小值加上 $a_i$。转移方程如下：

$$dp_i=\min_{i-k-1\le j\le i-1}\{dp_i\}+a_i$$

又由于区间长度相同，可以单调队列优化。

注意：$10^5\times 10^5>2^{31}-1$。

[AC 记录](https://www.luogu.com.cn/record/221413949)

---

## 作者：CommandSR (赞：1)

## 题意

给定一个数列可以给若干个数染成黑色，初始除了 $a_1$ 和 $a_n$ 全是白色，要求相邻的两个黑色的数之间最多包含 $k$ 个白色的数，最小化所有黑色的数的和。

## 题解

考虑 DP。

定义 $f_i$ 表示前 $i$ 个数，将 $i$ 位置的数染成黑色的最小总和。

初始状态 $f_1 = a_1$，答案 $f_n$。

状态转移方程 $f_i = \max_{i-k-1 \leq j \leq i-1} f_j + a_i$。

直接 DP 时间复杂度 $O(n^2)$，实测 60pts。

注意到在一段区间内求最大的 $f_j$ 转移到 $f_i$，可以单调队列优化。

优化之后 $O(n)$ 即可通过本题。

## AC Code

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for (int i = a; i <= b; ++i)
#define _F(i, a, b) for (int i = a; i >= b; --i)
#define ll long long
using namespace std;
ll rd() {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 1e5 + 5;
const ll inf = 1e14;
ll n, k, a[N], f[N];
ll q[N], ff = 1, ee = 0;
int main() {
	n = rd(), k = rd();
	F(i, 1, n) a[i] = rd(), f[i] = inf;
	f[1] = a[1], q[++ee] = 1;
	F(i, 2, n) {
		while (ff <= ee && q[ff] < i-k-1) ++ff;
		f[i] = (ff <= ee ? f[q[ff]] : 0) + a[i];
		while (ff <= ee && f[q[ee]] >= f[i]) --ee; 
		q[++ee] = i;
	}
	cout << f[n] << '\n';
	return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：1)

# P12882 [蓝桥杯 2025 国 C] 数列染色 题解

[题目传送门](https://www.luogu.com.cn/problem/P12882)

## 题目分析

看到题目，我们可以发现这是一个动态规划问题，但是直接求的时间复杂度比较高，所以还需要进行优化。

### 一般方法

我们将 $dp_i$ 定义为以 $a_i(1 \le i \le n)$ **为结尾**（并**涂黑**）时所求之和的最小值。

在进行求解时，对于每一个 $i$，我们可以发现 $dp_i$ 是由**其前面一定范围内**的 $dp_j$ 再加上当前的数得到的。  
根据题目中要求，我们可以求出 $j$ 的取值范围为 $i-k-1 \le j \le i-1$ 且 $j \ge 1$。

又因为我们要求最小值，那么我们就要在范围内选出 $dp_j$ **最小**的 $j$，$dp_i$ 就由它转移得到。

该算法的时间复杂度为 $O(nk)$，在本题中无法完全通过。

### 优化算法

注意观察我们就会发现，每次 $j$ 的取值范围就像一个**滑动窗口**一样，窗口大小固定，每一次的范围都是**由上一次的范围向右滑动一次**得到，并且我们同样要求最值。（详情可见 [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)）

那么这就是标准的**单调队列优化动态规划**了。

于是我们将**单调队列**将上面的动态规划算法套上，就可以在 $O(1)$ 的时间复杂度下求出需要的 $j$ 了。

代码如下：  

```cpp
#include <iostream>
#include <deque>
using namespace std;
long long n,k,dp[100005];
deque <int> dque;

int main(){
	cin >> n >> k >> dp[1];
	dque.push_back(1); // 先把 1 初始化，便于后续计算
	for(long long i = 2,x;i <= n;i++){
		cin >> x;
		while(!dque.empty() && dque.front() < i-k-1) dque.pop_front();
		dp[i] = dp[dque.front()] + x;
		while(!dque.empty() && dp[dque.back()] > dp[i]) dque.pop_back();
		dque.push_back(i);
	}
	cout << dp[n];
	return 0;
}
```

## 总结
本题考察单调队列优化动态规划问题，比较模板。

感谢您的阅读！

---

## 作者：yihang2011 (赞：0)

### [P12882 [蓝桥杯 2025 国 C] 数列染色](https://www.luogu.com.cn/problem/P12882)

单调队列优化 DP。

首先，根据题意，很好想出普通 DP。即记 $f_i$ 为前 $i$ 个数黑色的最小和，其中 $f_1 = a_1$。容易得到状态转移方程 $f_i= \min_{i - k - 1 \le j \le i - 1}\{f_j + a_i\}$，时间复杂度为 $O(n^2)$，无法承受。

考虑优化。观察发现状态转移方程可以转化为 $f_i = \min_{i - k - 1 \le i - 1}\{f_j\} + a_i$，在枚举 $i$ 时只需要 $f$ 数组在 $\left[i - k - 1,i - 1\right]$ 这长度为 $k$ 的区间，而且区间左右端点与 $i$ 一同变化，可以维护一个长度为 $k$ 的滑动窗口维护区间内最小值，使用单调队列实现。在不满足条件的元素出队后进行状态转移，方程为 $f_i = f_{q.front()} + a_i$。然后维护队列单调性，最后将元素入队。

时间复杂度 $O(n)$。不开那个啥还是会[见祖宗](https://www.luogu.com.cn/record/223662481)的。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define mt make_tuple
#define pqueue priority_queue
#define umap unordered_map
#define set(f, x) memset(f, x, sizeof f)
using ll = long long;
ll read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0', ch = getchar();
    }
    return x * f;
}
#define rd read()
void write(ll x) {
    if (x < 0) {
        putchar('-'), x = -x;
    } 
    if (x > 9) {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}
#define wln(x) write(x); putchar('\n');
#define wt(x) write(x); putchar(' ');
#define db(x) printf(#x); putchar(':'); wln(x);

const int N = 1e5 + 10;
ll n, k, a[N], f[N];
deque<int> q;

int main() {
    n = rd, k = rd;
    for (int i = 1; i <= n; i++) {
        a[i] = rd;
    }
    f[1] = a[1];
    q.push_back(1);
    for (int i = 2; i <= n; i++) {
        while (!q.empty() && i - k - 1 > q.front()) {
            q.pop_front();
        }
        f[i] = f[q.empty() ? 0 : q.front()] + a[i];
        while (!q.empty() && f[q.back()] >= f[i]) {
            q.pop_back();
        }
        q.push_back(i);
    }
    wln(f[n])
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/223662623)

---


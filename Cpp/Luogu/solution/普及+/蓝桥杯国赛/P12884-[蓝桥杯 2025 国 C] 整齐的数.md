# [蓝桥杯 2025 国 C] 整齐的数

## 题目描述

小蓝喜欢整齐的数，也就是对于一个数，他喜欢那些所有相邻数位上数字的差的绝对值之和较小的数。

小蓝认为，如果一个数所有的相邻数位之间的差值的绝对值之和不超过 $m$ ，这个数就是整齐的。

给定 $n, m$ ，请你帮小蓝求出 $n$ 以内有多少个非负整数是整齐的。

## 说明/提示

**【样例说明】**

符合输入要求的所有数分别为：

- 0,1,2,3,4,5,6,7,8,9；
- 10,11,12,21,22,23,32,33,34,43,44,45,54,55,56,65,66,67,76,77,78,87,88,89,98,99；
- 100,110,111,112,122,211,221,222,223,233。

**【评测用例规模与约定】**

对于 30% 的评测用例，$1 \leq n \leq 10^6$；

对于所有评测用例，$1 \leq n \leq 10^{18}$，$1 \leq m \leq 200$。

## 样例 #1

### 输入

```
233 1```

### 输出

```
46```

# 题解

## 作者：AmaoFox (赞：9)

喵呜。本喵就大发慈悲地讲解一下这道整齐的数的题解喵。(≧ω≦)

## 大意

给定一个上界数 $n$ 和阈值 $m$，统计 $[0, n]$ 范围内所有**整齐的数**的个数喵。一个数是整齐的，当且仅当它所有相邻数位差的绝对值之和不超过 $m$ 喵。比如数 $123$ 的和是 $|1-2|+|2-3|=2$ 喵。

## 思路

喵哼哼。这种数字统计问题当然要用数位 DP 解决喵。本喵会用一个记忆化搜索来优雅地处理喵。(ฅ´ω`ฅ)

### 状态设计

本喵设计的状态是：`dp[pos][last][sum][tight]`喵～解释一下：

- `pos`：当前处理到第几位；（从高到低喵）
- `last`：上一位的数字；（**如果前面都是 $0$，用 $10$ 表示喵**）
- `sum`：当前相邻数位差的绝对值之和；
- `tight`：是否紧贴上界。（前面选的数都和 $n$ 一样喵）

### 状态转移

分两种情况处理喵：

- 前导零状态（`last == 10`）
  - 选 $0$：保持前导零状态喵。
  - 选非 $0$：结束前导零，更新 `last` 但 `sum` 仍然是 $0$。（因为是第一位喵）
- 正常状态
  - 计算当前位与上一位的差 `diff = abs(last - d)。
  - 如果 `sum + diff > m` 就跳过。否则更新 `sum += diff`。

当处理完所有位数时（`pos == len`），就返回 $1$ 喵。

## 代码

``` cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 20, M = 205;

int dp[N][11][M][2];
string s;
int m;
int len;

int dfs(int pos, int last, int sum, bool tight) {
  if (pos == len) {
    return (sum <= m) ? 1 : 0;
  }
  if (dp[pos][last][sum][tight] != -1) {
    return dp[pos][last][sum][tight];
  }
  int up = tight ? (s[pos] - '0') : 9;
  int res = 0;
  for (int d = 0; d <= up; d++) {
    if (last == 10) {
      int new_last = (d == 0) ? 10 : d;
      int new_sum = sum;
      bool new_tight = tight && (d == up);
      res += dfs(pos + 1, new_last, new_sum, new_tight);
    } else {
      int diff = abs(last - d);
      int new_sum = sum + diff;
      if (new_sum > m) {
        continue;
      }
      bool new_tight = tight && (d == up);
      res += dfs(pos + 1, d, new_sum, new_tight);
    }
  }
  return dp[pos][last][sum][tight] = res;
}

signed main() {
  int n;
  cin >> n >> m;
  s = to_string(n);
  len = s.size();
  memset(dp, -1, sizeof(dp));
  cout << dfs(0, 10, 0, 1);
}
```

喵呜。说实话本喵为了题解写了一些比较“规范”的变量名，看着觉得完全是 AI 写的喵。

由于记忆化的存在，时间复杂度显然和空间复杂度是一样的喵，因为每个状态只计算一次，之后就直接调用了喵。

**很重要的建议喵**！表示当前处于前导 $0$ 的状态，**把 `last` 设置成 $\bold{10}$** 是最方便的做法了喵。真不要和本喵早年一样单开一维然后把自己累死了喵。

---

哼。本喵的讲解就到这里喵。要好好理解状态设计的意义喵，这才是数位 DP 的精髓喵。(๑•̀ㅂ•́)و✧

~~唉我怎么又写了一篇莫名其妙的东西。~~

---

## 作者：cccz (赞：2)

# 这是一道数位 dp 模版题。

如果你不知道什么是数位 dp  ，请先去学习。

这道题的思路很简单，和[P4999 烦人的数学作业](https://www.luogu.com.cn/problem/P4999)有点像，大概思路就是在搜索的时候判断一下绝对值之和是否超过范围，还有就是注意一下前导零，如果有前导零的话，那么第一位非零数字与上一位数字之差为零。

详细请见代码:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,num[20],dp[20][205][10],cnt;
int dfs(int pos,int limit,int lead,int sum,int last){//模版 
	/*
	pos表示还剩几位数字没有搜索，limit表示取值是否有限制，lead记录前导零
	sum记录和，last记录上一位 
	*/ 
	if(sum>m)return 0;//总和超过 m，一定不行，直接结束 
	if(pos==0)return 1;//可以返回1，表示找到一个可行的数字 
	if(!limit&&lead&&dp[pos][sum][last]!=-1)return dp[pos][sum][last];//记忆化 
	int ans=0,up=9;
	if(limit)up=num[pos];//up表示当前位可取的最大数 
	for(int i=0;i<=up;i++){
		int temp;
		if(!lead)temp=0;//temp 用来计算差值，如果lead=0，即有前导零，则差值为零 
		else temp=abs(last-i);
		ans+=dfs(pos-1,limit&&(i==up),lead||i,sum+temp,i);
	}
	if(!limit&&lead)dp[pos][sum][last]=ans;//只有！limit&&lead时dp才会更新 
	return ans;
}
void deal(int x){
	memset(dp,-1,sizeof(dp));//记得初始化 
	cnt=0;
	while(x){
		num[++cnt]=x%10;
		x/=10;
	}
	printf("%lld",dfs(cnt,1,0,0,0));
}
signed main(){
	scanf("%lld%lld",&n,&m);
	deal(n);
	return 0;
}
```

---

## 作者：luckyyunji (赞：1)

~~这么明显的数位 DP。~~

大意：一个数是整齐的，当一个数相邻数位差的绝对值之和不大于 $m$。求 $[1,n]$ 之间有几个数。

记忆化搜索，从高位到低位，每位判断是否超过范围，注意前导零，**如果前一位是前导零**，那么总差值应该为 $0$。

代码如下：

```cpp
// P12884 [??? 2025 ? C] ????
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 20;
// const int MOD=
// bool iscases=0;

int nums[MAXN], dp[MAXN][11][MAXN * 10];

int M;

inline int in() {
	static char c;
	static int r, f;
	r = f = 0;
	while ((c < 48 || c > 57) && c != 45) c = getchar_unlocked();
	if (c == 45) f = 1, c = getchar_unlocked();
	while (c > 47 && c < 58)
		r = (r << 1) + (r << 3) + (c ^ 48), c = getchar_unlocked();
	return f ? -r : r;
}
void out(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x < 10)
		putchar(x + '0');
	else
		out(x / 10), putchar(x % 10 + '0');
}

int dfs(int pos, int pre, int state, bool ismax, bool iszero) {
	/*
	pos 当前位置 cnt~1
	pre 上一位数字
	state 差值总和
	ismax 是否紧贴上界
	iszero 上一位是否为前导零
	*/
	if (state > M) {  // 不符合条件
		return 0;
	}
	if (!pos) {	 // 得到一个答案
		return 1;
	}
	if (!iszero && !ismax && dp[pos][pre][state]) {	 // 记忆化
		return dp[pos][pre][state];
	}
	int m = ismax ? nums[pos] : 9;
	int ans = 0;
	for (int i = 0; i <= m; i++) {
		if (iszero) {  // 如果上一位仍是前导零
			if (i) {   // 如果这一位仍是前导零
				ans += dfs(pos - 1, i, 0, ismax && i == m, 0);
			} else {  // 如果这一位不是前导零
				ans += dfs(pos - 1, 0, 0, 0, 1);
			}
		} else {
			ans += dfs(pos - 1, i, state + abs(pre - i), ismax && i == m, 0);
		}
	}
	if (!ismax && !iszero) {  // 记忆化
		dp[pos][pre][state] = ans;
	}
	// cout<<pos<<' '<<ans<<'\n';
	return ans;
}

int solve(int a) {
	// memset(nums,0,sizeof(nums));
	// memset(dp,-1,sizeof(dp));
	int cnt = 0;
	while (a) {	 // 拆分数字
		nums[++cnt] = a % 10;
		a /= 10;
	}
	return dfs(cnt, 0, 0, 1, 1);
}

void gogogo() {
	int a = 1, b;
	// cin>>a>>b;
	// cin>>b>>M;
	b = in();
	M = in();
	// cout<<solve(b)<<'\n';
	out(solve(b));
}

signed main() {
	// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	// int T=1;
	// if(iscases) cin>>T;
	// while(T--){
	gogogo();
	//}
	return 0;
}
```

---

## 作者：xyx404 (赞：0)

没学过数位 DP 的可以参考 [CSP Wiki](https://csp.wiki/docs/CSP-S/2-DP/04)。

## 思路：

考虑数位 DP。

本题只需要在填数时判断一下当前相邻数位差的绝对值之和有没有大于 $m$ 就行了。

具体地，对于每次填数，我们需要考虑，当前相邻数位差的绝对值之和有没有大于 $m$。

如果大于，返回本次 $0$ 表示没有答案；否则，我们考虑当前数位是否有限制，接着填数，如果最后一位也填了，并且相邻数位差的绝对值之和没有大于 $m$ 就代表本次填的答案是可行的。


## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long
LL n,m;
LL dp[20][300][11];
int a[20];
int cf(LL x){
    int len=0;
    while(x){
        a[++len]=x%10;
        x/=10;
    }
    return len;
}
LL dfs(LL now,bool xz,bool tg,int sum,int las){
    LL ans=0;
    if(sum>m)return 0;
    if(now==0)return 1;
    if(!xz&&!tg&&dp[now][sum][las]!=-1)return dp[now][sum][las];
    int l=0,r=9;
    if(tg)l=1,ans+=dfs(now-1,0,tg,0,-1);
    if(xz)r=a[now];
    for(int i=l;i<=r;i++){
        ans+=dfs(now-1,(i==r&&xz),0,(las!=-1?sum+abs(i-las):0),i);
    }
    if(!xz&&!tg)dp[now][sum][las]=ans;
    return ans;
}
LL ans(LL x){
    int len=cf(x);
    memset(dp,-1,sizeof dp);
    return dfs(len,1,1,0,-1);
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    cout<<ans(n);
    return 0;
}
```

---


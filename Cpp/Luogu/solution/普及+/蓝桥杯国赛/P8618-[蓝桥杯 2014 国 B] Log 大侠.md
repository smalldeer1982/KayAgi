# [蓝桥杯 2014 国 B] Log 大侠

## 题目描述

atm 参加了速算训练班，经过刻苦修炼，对以 $2$ 为底的对数算得飞快，人称 Log 大侠。

一天，Log 大侠的好友 drd 有一些整数序列需要变换，Log 大侠正好施展法力。

变换的规则是：对其某个子序列的每个整数变为 $[\log_2(x)+1]$ 其中 [] 表示向下取整，就是对每个数字求以 $2$ 为底的对数，然后取下整。

例如对序列 $3,4,2$ 操作一次后，这个序列会变成 $2,3,2$。

drd 需要知道，每次这样操作后，序列的和是多少。

## 说明/提示

对于 $30\%$ 的数据，$n,m \le 10^3$。

对于 $100\%$ 的数据，$n,m \le 10^5$。

时限 1 秒, 256M。蓝桥杯 2014 年第五届国赛

官方数据似乎有错。重造数据按照 $1 \leq a_i \leq 10^9$ 设计。

## 样例 #1

### 输入

```
3 3
5 6 4
1 2
2 3
1 3```

### 输出

```
10
8
6```

# 题解

## 作者：墨笙_Mooos (赞：20)

### 思路

注意到 $\lfloor\log_2{a_i} + 1\rfloor = a_i$ 当且仅当 $a_i \in \{1, 2\}$。

若 $a_i = 1$ 则无论怎样操作始终有 $a_i = 1$。

若 $a_i > 1$ 则经过若干次操作后有 $a_i = 2$。考虑操作的次数，当 $a_i = 2^{63}$ 时，只需要 $4$ 次操作就有 $a_i = 2$，因此每个元素的操作次数是极少的，可以直接维护，当 $a_i = 2$ 时删除 $a_i$ 并不再维护。

由此，我们想到可以使用 ```map``` 对其实现删除元素和逐个修改。（都什么年代了还在写传统线段树、传统分块XD）

### 代码

具体实现上，可以维护整个数组的和，每次修改时减去其差值。

```cpp
ll n, m, x, Ans;
__gnu_pbds::tree<ll, ll> Mp; // __gnu_pbds::tree 和 map 等效
decltype (Mp.begin ()) it, Lst; // 定义两个 iterator / 迭代器，作用类似于指针
int main ()
{
	std::cin.tie (nullptr), std::ios::sync_with_stdio (false);
	cin >> n >> m;
	For (i, 1, n)
	{
		cin >> x, Ans += x;
		if (x > 2) Mp.insert ({i, x});
	}
	For (i, 1, m)
	{
		static ll L, R; cin >> L >> R;
		it = Mp.lower_bound (L);
		while (it != Mp.end () && it->first <= R)
		{
			ll Log = log2l (it->second) + 1;
			Ans -= it->second - Log;
			Lst = it, it = next (it);
			if (Log == 2) Mp.erase (Lst);
			else Lst->second = Log;
		}
		cout << Ans << endl;
	}
	return 0;
}
```

---

## 作者：Usada_Pekora (赞：2)

首先我们发现，在给定的范围内， $x=\lfloor\log_2 (x)+1 \rfloor$，当且仅当 $x\in\{1,2\}$。

也就是说，对于 $a_i=1$ 或 $a_i=2$，这个运算是没有必要进行的。

对于每个数，只要在 $O(\log^{*}V)$ 的复杂度就能将其变成 $1$ 或 $2$，其中  $V$ 是值域，$\log^{*}n$ 表示将 $n$ 开对数开到小于等于一的次数。

我们用线段树维护一段区间是不是全部不需要再进行运算了，即区间最大值是否小于等于二，如果一个区间的最大值大于二，则考虑对所有大于二的数进行操作。

看起来很暴力，但是对其进行分析：对每个数进行单次操作的复杂度为 $O(\log n)$，每个数只需要进行 $O(\log^{*} V)$ 次操作，则总复杂度为 $O(n\log n\log^{*}V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int val[N << 2], n, m, a[N];
long long sum;
inline void build(int p, int l, int r) {
	if (l == r) {
		val[p] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(p << 1, l, mid);
	build(p << 1 | 1, mid + 1, r);
	val[p] = max(val[p << 1], val[p << 1 | 1]);
}
inline void modify(int p, int l, int r, int L, int R) {
	if (val[p] <= 2) return;
	if (l == r) {
		int nval = (int)(log2(val[p]) + 1);
		sum -= (val[p] - nval);
		val[p] = nval;
		return;
	}
	int mid = (l + r) >> 1;
	if (L <= mid)
		modify(p << 1, l, mid, L, R);
	if (R > mid)
		modify(p << 1 | 1, mid + 1, r, L, R);
	val[p] = max(val[p << 1], val[p << 1 | 1]);
}
signed main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		sum += a[i];
	}
	build(1, 1, n);
	for (int i = 1; i <= m; i++) {
		int l, r;
		scanf("%d%d", &l, &r);
		modify(1, 1, n, l, r);
		printf("%lld\n", sum);
	}
	return 0;
}
```


---

## 作者：xiezheyuan (赞：0)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p8618.html)

## 简要题意

给你一个长度为 $n$ 的正整数序列 $a$，有 $m$ 个询问，每一个询问给出一个区间 $[l,r]$。定义函数 $f(x)=\lfloor\log_{2}(x)+1\rfloor$。将 $[l,r]$ 的所有元素 $a_p$ 修改为 $f(a_p)$。然后输出序列 $a$ 的全局和。

对于 $100\%$ 的数据，$1 \leq n,m \le 10^5,1 \leq a_i \leq 10^9$。

## 思路

前置知识：线段树。

这一道题是无标记区间修改线段树（我自己取得名字）的模板题。

这道题如果使用普通的线段树区间修改（打标记法），无论是标记下传还是标记永久化，都有一个问题：如何实现区间更新？也就是说知道 $\sum_{i=l}^{r}{a_i}$，如何求 $\sum_{i=l}^{r}{f(a_i)}$？

这不是不好求，是不能求。

那我们考虑回归暴力。暴力思路很简单，在线段树上找到 $[l,r]$ 的所有元素，一一单点更新即可。

接下来见证奇迹的时刻：首先，易证当 $x=1$ 或 $x=2$ 时，$f(x)=x$。

那我们只需要再维护一个区间最大值，如果线段树遍历到的区间最大值 $\leq 2$，那么直接不用更新了，返回。

这样子似乎复杂度没变？不不不，复杂度已经变成了 $O(\alpha(a_i)n)$！

这里给出简单证明过程：首先，$f(i)\approx \log_{2}(i)$，也就是说，单次 $f(i)$ 时缩减到了 $\log(i)$ 级。

所以如果令 $x$ 递归 $k(x)$ 到 $1$。我们发现 $k(x)$ 不太好求，于是我们反过来知道 $x$ 求 $k(x)$：

$$
\underbrace{2^{2^{2^\cdots}}}_{k(x)}=x
$$

下面我们把上式简写为 $2@k(x)=x$。

自然想到阿克曼函数 $A(2,k(x))=2@k(x)=x$。然后 $k(x)$ 就是和 $\alpha(x)$ 同阶了。

均摊时间复杂度分析：由于每一个元素最多被单点修改 $\alpha(10^9)\approx 3$ 次。所以均摊时间复杂度是 $O(3n)$。

这就是无标记区间修改线段树。课后习题还有几道无标记区间修改线段树的题，供大家练习。

课后习题：

- [P4145 上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145)
- [mod 板线段树](https://www.luogu.com.cn/problem/T218729)（学长出的线段树神仙题）

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls (i<<1)
#define rs (i<<1|1)
#define mid ((l+r)>>1)
using namespace std;

int n,m;
const int N = 1e5+5;
struct node{
	int maxt,sumt;
} t[N<<2];

inline void pushup(int i){
	t[i].maxt=max(t[ls].maxt,t[rs].maxt);
	t[i].sumt=t[ls].sumt+t[rs].sumt;
}

void build(int i,int l,int r){
	if(l==r){
		cin>>t[i].maxt;
		t[i].sumt=t[i].maxt;
		return;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(i);
}

inline int magic(int x){
	return floor(log(x)/log(2)+1);	
}

void update(int ql,int qr,int i,int l,int r){
	if(t[i].maxt<=2){
		return;	
	}
	if(l==r){
		t[i].sumt=t[i].maxt=magic(t[i].sumt);
		return;
	}
	if(ql<=mid){
		update(ql,qr,ls,l,mid);
	}
	if(qr>mid){
		update(ql,qr,rs,mid+1,r);
	}
	pushup(i);
}

int query(int ql,int qr,int i,int l,int r){
	if(ql<=l&&r<=qr){
		return t[i].sumt;
	}
	int ret=0;
	if(ql<=mid){
		ret += query(ql,qr,ls,l,mid);
	}
	if(qr>mid){
		ret += query(ql,qr,rs,mid+1,r);
	}
	return ret;
}

signed main(){
	cin>>n>>m;
	build(1,1,n);
	while(m--){
		int l,r;
		cin>>l>>r;
		update(l,r,1,1,n);
		cout<<query(1,n,1,1,n)<<'\n';
	}
	return 0;
}
```

（听说有人抄我的交题解，我劝你善良）

---

## 作者：lrqlrq250 (赞：0)

## 解题思路
和 [GSS4](https://www.luogu.com.cn/problem/SP2713) 有异曲同工之妙。

区间 Log 区间和问题，显然可以使用线段树维护。

观察到当 $a[i] = 1$ 或 $a[i] = 2$ 时，取 $\log$ 的操作并不改变 $a[i]$ 的的值。也就是说当我们想对一个区间取 $\log$ 的时候，如果这个区间里已经都是 $1$ 或 $2$ 了，那我们就进行了一次无意义的操作，浪费了很多时间。

所以我们给线段树里的每个区间设置一个标记，表示这个区间里是否都是 $1$ 或 $2$，如果是的话就不更新它了。

在 `pushup` 操作中可以通过取来合并两个小区间的标记。

`update` 的复杂度看上去每次都是 $O(n)$，但实际加了 $tag$ 后远远达不到上限，因为取 $\log$ 的操作下降速度极快，哪怕是对于 $10^9$，操作 $4$ 次就直接降到 $2$ 了，因此快到飞起。

## AC Code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
struct SegmentTree{
	ll sum;
	bool tg;
}tree[100001 << 2];
int n, m;
ll a[100001];

inline ll read(){
	ll f = 1, x = 0;
	char c = getchar();
	while (!isdigit(c)){f = c == '-' ? -1 : 1; c = getchar();}
	while (isdigit(c)){x = (x << 1) + (x << 3) + (c ^ 48); c = getchar();}
	return f * x;
}

inline void pushup(int p){
	tree[p].sum = tree[p << 1].sum + tree[p << 1 | 1].sum;
	tree[p].tg = tree[p << 1].tg & tree[p << 1 | 1].tg;
}

void Build(int p, int l, int r){
	if (l == r){
		tree[p].sum = a[l];
		tree[p].tg = a[l] == 1 || a[l] == 2;
		return;
	}
	int mid = (l + r) >> 1;
	Build(p << 1, l, mid); Build(p << 1 | 1, mid + 1, r);
	pushup(p);
}

void update(int p, int l, int r, int lpos, int rpos){
	if (l > rpos || r < lpos) return;
	if (l == r){
		tree[p].sum = (int)log2(tree[p].sum) + 1;
		tree[p].tg = tree[p].sum == 1 || tree[p].sum == 2;
		return;
	} 
	int mid = (l + r) >> 1;
	if (lpos <= mid && !tree[p << 1].tg) update(p << 1, l, mid, lpos, rpos);
	if (rpos > mid && !tree[p << 1 | 1].tg) update(p << 1 | 1, mid + 1, r, lpos, rpos);
	pushup(p); 
}

int main(){
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) a[i] = read();
	Build(1, 1, n);
	int op, x, y;
	while (m--){
		x = read(); y = read();
		update(1, 1, n, x, y);
		printf("%lld\n", tree[1].sum);
	}
	return 0;
}
```


---

## 作者：Hanx16Kira (赞：0)

# [蓝桥杯 2014 国 B] Log 大侠

[Luogu P8618](https://www.luogu.com.cn/problem/P8618)

## Solution

这简直就是区间开方换了个表达方式。

可以注意到一个数进行题目中的取 $\log$ 操作只需要大约在 $\log$ 次操作左右就会变成 $2$，而 $2$ 无论如何进行题目中的操作都是 $2$，$1$ 也是同理。因此可以得到一种做法。

将原序列分块（线段树应该也行，做法大同小异），对于每一个块维护一下块内元素的和 $sum$ 和一个标记 $tag$（表示块内是否全部全部元素都是 $1,2$）。对于修改操作，如果一个块被打上了标记，那么就说明这个块无论怎么修改都不会改变，直接跳过这个块就可以。如果这个块没有标记，那么就对这个块进行暴力修改，修改完后看是否需要打标记即可。每次询问都是全局求和，直接将所有块维护的 $sum$ 加起来就可以了（我第一眼没看清楚题就直接写的区间求和，实际上并不需要这么复杂）。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int _SIZE = 1e5, _BLOCK = 1000;
int bl[_BLOCK + 5], br[_BLOCK + 5], len, cnt;
int pos[_SIZE + 5], tag[_SIZE + 5], sum[_SIZE + 5], a[_SIZE + 5];
int n, m;
void init() { // 预处理块的边界和sum
    len = sqrt(n), cnt = (n - 1) / len + 1;
    for (int i = 1; i <= cnt; i++)
        bl[i] = (i - 1) * len + 1, br[i] = min(i * len, n);
    for (int i = 1; i <= cnt; i++)
        for (int j = bl[i]; j <= br[i]; j++)
            pos[j] = i, sum[i] += a[j];
}
void check(int id, int type) { // type=0表示仅检查是否需要打tag，type=1表示先对整块暴力修改再看是否需要打tag
    if (tag[id]) return;
    bool flag = 0;
    sum[id] = 0;
    for (int i = bl[id]; i <= br[id]; i++) {
        if (type == 1) a[i] = __lg(a[i]) + 1;
        if (a[i] > 2) flag = 1;
        sum[id] += a[i];
    }
    if (!flag) tag[id] = 1;
}
void modify(int l, int r) { // 区间修
    if (pos[l] == pos[r]) {
        for (int i = l; i <= r; i++) a[i] = __lg(a[i]) + 1;
        check(pos[l], 0);
    } else {
        if (!tag[pos[l]]) {
            for (int i = l; i <= br[pos[l]]; i++) a[i] = __lg(a[i]) + 1;
            check(pos[l], 0);
        }
        for (int i = pos[l] + 1; i < pos[r]; i++) check(i, 1);
        if (!tag[pos[r]]) {
            for (int i = bl[pos[r]]; i <= r; i++) a[i] = __lg(a[i]) + 1;
            check(pos[r], 0);
        }
    }
}
int query(int l, int r) { // 区间和
    int res = 0;
    if (pos[l] == pos[r]) {
        for (int i = l; i <= r; i++) res += a[i];
    } else {
        for (int i = l; i <= br[pos[l]]; i++) res += a[i];
        for (int i = pos[l] + 1; i < pos[r]; i++) res += sum[i];
        for (int i = bl[pos[r]]; i <= r; i++) res += a[i];
    }
    return res;
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    init();
    for (int i = 1; i <= m; i++) {
        static int l, r;
        cin >> l >> r;
        modify(l, r);
        cout << query(1, n) << '\n';
    }
    return 0;
}
```

---

## 作者：qwqFranzFox (赞：0)

## 题目大意

给出一个长度为 $n$ 的数列，有 $m$ 次操作，每次给出一个区间 $[l,r]$，把这个区间内的数字 $a_i$ 变成 $\lfloor \log_2a_i+1\rfloor$。每次操作后输出数列的和。

## 思路

容易发现

$$\log_2 2 + 1 = 2$$

和

$$\log_2 1 + 1 = 1$$

所以，对一个只有 $1$ 和 $2$ 的区间进行操作之后没有变化。

考虑如何优化掉这类操作。

使用线段树进行维护，除了维护区间和以外，还要维护一个区间最大值，当这个最大值小于等于 $2$ 时就说明这个区间只有小于等于 $2$ 的数，此时就可以停止操作了。

如果不是的话，我们可以直接暴力处理。对于一个小于等于 $10^9$ 的数，对他取 $\log_2$ 进行 $30$ 次必定会变成 $2$。这样可以保证时间复杂度的正确性。

每次操作后输出 `t[1]` （也就是线段树的根，代表区间 $[1,n]$ 的和）即可。

## Code

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read() {
  ll x = 0, f = 1;
  char c = getchar();
  while (c > '9' || c < '0') {
    if (c == '-')
      f = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') {
    x = (x << 1) + (x << 3) + c - '0';
    c = getchar();
  }
  return x * f;
}
const int N = 1E5 + 10;
int n, m;
ll a[N];
const int T = N << 2;
ll sumt[T], maxt[T];
inline int lc(int x) { return x << 1; }
inline int rc(int x) { return x << 1 | 1; }
inline int mp(int l, int r) { return (l + r) >> 1; }
inline void pushUp(int x) {
  sumt[x] = sumt[lc(x)] + sumt[rc(x)];
  maxt[x] = max(maxt[lc(x)], maxt[rc(x)]);
}
void build(int l, int r, int x) {
  if (l == r)
    sumt[x] = maxt[x] = a[l];
  else {
    int mid = mp(l, r);
    build(l, mid, lc(x));
    build(mid + 1, r, rc(x));
    pushUp(x);
  }
}
void update(int L, int R, int l, int r, int x) {
  if (maxt[x] <= 2)
    return;
  if (l == r)
    sumt[x] = floor(log2(sumt[x]) + 1), maxt[x] = sumt[x];
  else {
    int mid = mp(l, r);
    if (L <= mid)
      update(L, R, l, mid, lc(x));
    if (R > mid)
      update(L, R, mid + 1, r, rc(x));
    pushUp(x);
  }
}
int main() {
  n = read(), m = read();
  for (int i = 1; i <= n; i++)
    a[i] = read();
  build(1, n, 1);
  for (int i = 1; i <= m; i++) {
    int l = read(), r = read();
    update(l, r, 1, n, 1);
    cout << sumt[1] << endl;
  }
  return 0;
}
```


---

## 作者：donotctjuntilAFO (赞：0)

### 简化题意

要求一个数据结构，支持区间取 $\log$ 查询全局和。

### 思路

前置知识：线段树。

由于区间取 $\log$ 不能标记下传，那么暴力修改，复杂度为 $O(nm)$ 

考虑优化，类似 [Luogu P4145](https://www.luogu.com.cn/problem/P4145)，我们发现 

$$ 1=\log_2 1+1$$

且

$$ 2=\log_2 2+1 $$

于是当区间最大值小于等于 $2$ 时，直接返回。

一个数取 $\log$ 最多取 $\log^*(V)$ 次，$V$ 为值域。

复杂度 $O(n\log n\log^*(V))$ 可以通过本题。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define f(i,l,r) for(int i=l;i<=r;++i)
#define F(i,r,l) for(int i=r;i>=l;--i)
#define int long long
#define ULL unsigned long long
using namespace std;
const int N=100005;
int n,m,tree[N<<2],mx[N<<2]; 
inline int read(){
    int x=0;
    char c=getchar();
    while(!isdigit(c))
        c=getchar();
    while(isdigit(c))
        x=x*10+c-'0',c=getchar();
    return x;
}
inline void build(int l,int r,int x){
    if(l==r){
        mx[x]=tree[x]=read();
        return ;
    }
    int mid=l+r>>1;
    build(l,mid,x<<1);
    build(mid+1,r,x<<1|1);
    tree[x]=tree[x<<1]+tree[x<<1|1];
    mx[x]=max(mx[x<<1],mx[x<<1|1]);
}
inline void update(int l,int r,int ll,int rr,int x){
    if(mx[x]<=2)
        return ;
    if(ll==rr){
        mx[x]=tree[x]=floor(log2(tree[x])+1.0);
        return ;
    }
    int mid=ll+rr>>1;
    if(l<=mid)
        update(l,r,ll,mid,x<<1);
    if(r>mid)
        update(l,r,mid+1,rr,x<<1|1);
    tree[x]=tree[x<<1]+tree[x<<1|1];
    mx[x]=max(mx[x<<1],mx[x<<1|1]);
}
signed main(){
    n=read();
    m=read();
    build(1,n,1);
    f(i,1,m){
        int l=read(),r=read();
        update(l,r,1,n,1);
        printf("%lld\n",tree[1]);
    } 
    return 0;
}
```

---


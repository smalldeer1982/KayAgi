# [蓝桥杯 2016 国 B] 机器人塔

## 题目描述

X 星球的机器人表演拉拉队有两种服装，A 和 B。

他们这次表演的是搭机器人塔。

类似：

```
     A
    B B
   A B A
  A A B B
 B B B A B
A B A B B A
```

队内的组塔规则是：

A 只能站在 AA 或 BB 的肩上。

B 只能站在 AB 或 BA 的肩上。

你的任务是帮助拉拉队计算一下，在给定 A 与 B 的人数时，可以组成多少种花样的塔。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2016 年第七届

## 样例 #1

### 输入

```
1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3```

### 输出

```
4```

# 题解

## 作者：Kevin911 (赞：10)


貌似题解区里没有这种思路，紧发一波。


## 题面
[戳这里](https://www.luogu.com.cn/problem/P8644)

## 思路
可以利用异或运算的性质来表示 $A$，$B$ 的关系（$A$ 表示 $0$，$B$ 表示 $1$）。

初始状态直接 $O(2^n)$ 枚举就可以了。

因为 $\dfrac{h\times(h+1)}{2}=n+m<231$，所以 $h<21$ 其中 $h$ 为它的层数。

~~勿抄袭~~

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cal(int x)
{
    int res=0;
    for(;x;x-=(x&(-x))) res++;
    return res; 
}
int main()
{
    int n,m,h;
    cin>>n>>m;
    for(int i=1;i<=21;i++)
        if((i*(i+1)/2)==n+m)
        {
            h=i;
            break; 
        }
    int ans=0;
    for(int i=0;i<(1<<h);i++)//位运算枚举底层情况
    {
        int cnt=cal(i),k=i;//统计B的数量即可 
        for(int j=h-1;j>=1;j--)
        {
            k=k^(k>>1);
            k&=((1<<j)-1);
            cnt+=cal(k);
        }
        if(cnt==m) ans++;
    }
    cout<<ans;//完结撒花
}
```

---

## 作者：YangXiaopei (赞：2)

## Solutin:

~~咋没人发打表题解？？？~~

由于 $n + m$ 只有 $231$ 那我们为什么不直接 `dfs` 最下面一层，直接算呢？

自信打好 `dfs` 的暴力代码，一测，最后一个点直接 $T$ 飞了。

再算一下时间复杂度：$\mathcal{O}(2 ^ n \times n ^ 2)$，在极限数据下确实会 $T$ 飞。

但 $n$ 和 $m$ 这么小，于是，打表，启动！

我们就愉快切掉此题了。

## Code:

打表结果太长，就不放了，这里只放 `dfs` 和打表代码。

`dfs`:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m, sum, cnt, p[25][25];
void dfs(int step, int x, int y){
	if(x > n || y > m){
		return;
	}
	if(step > sum){
		int a = x, b = y;
		for(int i = sum - 1; i >= 1; i--){
			for(int j = 1; j <= i; j++){
				if(p[i + 1][j] == p[i + 1][j + 1]){
					p[i][j] = 1;
					a++;
				}
				else{
					p[i][j] = 2;
					b++;
				}
			}
		}
		if(a == n && b == m){
			cnt++;
		}
		return;
	}
	p[sum][step] = 1;
	dfs(step + 1, x + 1, y);
	p[sum][step] = 2;
	dfs(step + 1, x, y + 1);
}
signed main(){
	cin >> n >> m;
	sum = (n + m) * 2;
	sum = floor(sqrt(sum));
	dfs(1, 0, 0);
	cout << cnt;
	return 0;
}
```

打表代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m, sum, cnt, p[25][25];
void dfs(int step, int x, int y){
	if(x > n || y > m){
		return;
	}
	if(step > sum){
		int a = x, b = y;
		for(int i = sum - 1; i >= 1; i--){
			for(int j = 1; j <= i; j++){
				if(p[i + 1][j] == p[i + 1][j + 1]){
					p[i][j] = 1;
					a++;
				}
				else{
					p[i][j] = 2;
					b++;
				}
			}
		}
		if(a == n && b == m){
			cnt++;
		}
		return;
	}
	p[sum][step] = 1;
	dfs(step + 1, x + 1, y);
	p[sum][step] = 2;
	dfs(step + 1, x, y + 1);
}
signed main(){
	int res = 0;
	cout << "    ";
	for(int i = 0; i < 231; i++){
		for(int j = 0; j < 231; j++){
			if(i + j >= 231){
				break;
			}
			n = i;
			m = j;
			sum = (n + m) * 2;
			sum = floor(sqrt(sum));
			if((sum * (sum + 1)) != (n + m) * 2){
				continue;
			}
			cnt = 0;
			dfs(1, 0, 0);
			cout << "a[" << i << "][" << j << "] = " << cnt << ";";
			res++;
			if(res == 10){
				cout << "\n" << "    ";
				res = 0;
			}
		}
	} 
	return 0;
}
```

完结撒花

---

## 作者：jinfanhao (赞：1)

这道题思路：首先我们先把最底下机器人枚举好，然后求出他上面需要的每种机器人数量，在看他是不是和剩余的一样，一样就把答案加一。

---
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100;
int x,y,s,cnt=0;
bool ok[N],op[N];
bool check(int x,int y){
	int n=s;
	for(int i=1; i<=n; ++i)op[i]=ok[i];
	while(--n){
		for(int i=1; i<=n; ++i){
			if(op[i]==op[i+1]){
				op[i]=false;
				--x;
			}
			else{
				op[i]=true;
				--y;
			}
			if(x<0 || y<0)return false;
		}		
	}
	return true;
}
void dfs(int t,int sum,int ans){
	if(sum<0 || ans<0)return;
	if(t==s+1){
		if(check(sum,ans))++cnt;
		return;
	}
	dfs(t+1,sum-1,ans);
	ok[t]=true;
	dfs(t+1,sum,ans-1);
	ok[t]=false;
}
int main(){
	scanf("%d%d",&x,&y);
	s=x+y;
	for(int i=1; i<=50; ++i){
		if(s==i*(i+1)/2){
			s=i;
			break;
		}
	}
	dfs(1,x,y);
	printf("%d",cnt); 
	return 0;
} 
```

---

## 作者：qiuzijin2026 (赞：1)

# P8644 [蓝桥杯 2016 国 B] 机器人塔

## [题面](https://www.luogu.com.cn/problem/P8644)

## 思路

使用枚举。

首先我们设 $A=0$，$B=1$，则题目就是要求 $0$ 的个数等于 $m$，$1$ 的个数等于 $n$。

我们设整个塔的层数为 $c$。

通过一点推导就可以得出：$c=(\sqrt{8\times(n+m)+1}-1)\div2$。

设 $a(i,j)$ 表示第 $i$ 层第 $j$ 个数。

对于 $a(i,j)$ 来说两种规则就相当于 
$a(i,j)=a(i-1,j) \operatorname{xor} a(i-1,j-1)$。

我们直接枚举第 $c$ 层的情况，推算出整个塔的情况，
再判断一下 $0$ 的个数等不等于 $m$，$1$ 的个数等不等于 $n$ 即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int c;
bool a[35][35];
int ans;
int s1,s0;
bool pd(int x){
	memset(a,false,sizeof(a));
	s1=0;
	s0=c;
	int tmp=x;
	int tp=c;
	while(tmp!=0){
		a[c][tp]=tmp%2;
		if(a[c][tp]){
			s1++;
			s0--;
		} 
		tmp/=2;
		tp--;
	}
	if(s0>m || s1>n) return false;
	for(int i=c-1;i>=1;i--){
		for(int j=1;j<=i;j++){
			a[i][j]=a[i+1][j]^a[i+1][j+1];
			if(a[i][j]) s1++;
			else s0++;
		} 
		if(s0>m || s1>n) return false;
	}
	if(s0==m && s1==n) return true;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d%d",&m,&n);
	c=(sqrt(8.0*n+8.0*m+1)-1)/2;
	for(int i=0;i<=(1<<c)-1;i++) if(pd(i)) ans++;
	printf("%d",ans);
	return 0;
}

```

---

## 作者：KidA (赞：1)

容易发现最下面的一层定下之后，

上面所有层就能全部定下，

因此考虑枚举最下面一层的状态。

而观察到只有两类人，不难想到二进制状压。

至于题目中的限制条件，

仅需根据每个二进制位判断其下层相邻的两个数的异或值即可确定。

关于时间复杂度：

设最下面一层有 $x$ 人，则时间复杂度为 $O(2^n \times n)$。

$N+M<231$，而 $\frac{(1+21) \times 21}{2} = 231$，因此最下面一层不超过 $11$ 人，可以通过。

---

## 作者：_yang_yi_bo_ (赞：0)

考虑深搜。

我们只需得出第一列的数，就可以顺推得到所有的数。

我们可以深搜判断所有第一列为 `A` 或 `B` 的情况，每推一层，将剩下所有答案计算出，每计算一次，若机器人 `A` 的个数或 `B` 的个数 $<0$，当前状态不合法，直接退出，若完成最后一层也合法，答案 $+1$。



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long ans;
int k;
bool f[30][30];
void dfs(int h,int a,int b){
	if(a<0||b<0){
		return;
	}if(h==k+1){
		ans++;
		return;
	}int x=a,y=b;
	f[h][1]=0;
	y--;
	for(int i=2;i<=h;i++){
		if(f[h-1][i-1]==1){
			if(f[h][i-1]==0){
				f[h][i]=0;
				y--;
			}else{
				f[h][i]=1;
				x--;
			}
		}else{
			if(f[h][i-1]==1){
				f[h][i]=0;
				y--;
			}else{
				f[h][i]=1;
				x--;
			}
		}
	}dfs(h+1,x,y);
	x=a;y=b;
	f[h][1]=1;
	for(int i=2;i<=h;i++){
		if(f[h-1][i-1]==1){
			if(f[h][i-1]==0){
				f[h][i]=0;
				y--;
			}else{
				f[h][i]=1;
				x--;
			}
		}else{
			if(f[h][i-1]==1){
				f[h][i]=0;
				y--;
			}else{
				f[h][i]=1;
				x--;
			}
		}
	}x--;
	dfs(h+1,x,y);
}
signed main(){
	cin>>n>>m;
	k=floor(sqrt(n+m+n+m));
	dfs(1,n,m);
	cout<<ans;
	return 0;
} 
```

---

## 作者：封禁用户 (赞：0)

我的思路比较直白（傻），二进制枚举，枚举最底下一行的排列状态。最底下一行的排列状态确定后，上面的排列状态也就确定了，所以，只要统计构建的人塔中 `A` 和 `B` 的数量是否与输入相同，相同的话种类数 $+1$。

什么是二进制枚举？以本题为例，每一个位置要么放 `A` 要么放 `B`，这和二进制有点像啊，那就让 `A` 对应 $1$，`B` 对应 $0$。

这样一来，`1 1 0` 什么意思？`A A B` 的意思吧。加入最底下一行有 $3$ 个人，所有的可能，`BBB，BBA，BAB，BAA，ABB，ABA，AAB，AAA，` 对应的二进制为 `000，001，010，011，100，101，110，111`，这不就是 $2^3$ 吗。所以，最后一行的排列状态就可以通过循环表现出来了：`for(int i=0;i<=(1<<3)-1;i++)`。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50;
int dp[N];//用一维数组表示二维状态，有点类似01背包问题优化的思想，但不是01背包！
int main(){
    int n,m,ans=0;
    cin>>m>>n;
    int h=(int)sqrt(2*(m+n));//计算出人塔的行数
    for(int num=0;num<=(1<<h)-1;num++){
        int tmp_h=h,tmp=num,cnt_a=0,cnt_b=0;
        for(int i=tmp_h;i>=1;i--,tmp>>=1){
            dp[i]=tmp&1;//初始化最底下一行
            if(dp[i]) cnt_a++;
            else cnt_b++;
        }

        while(tmp_h--){
            for(int i=1;i<=tmp_h;i++){
                if(dp[i+1] == dp[i]) cnt_a++,dp[i]=1;//set A
                else cnt_b++,dp[i]=0;//set B
            }
        }
        if(cnt_a==m && cnt_b==n) ans++;
    }
    cout<<ans<<endl;
} 
```

---

## 作者：封禁用户 (赞：0)

我的思路比较直白（傻），二进制枚举，枚举最底下一行的排列状态。最底下一行的排列状态确定后，上面的排列状态也就确定了，所以，只要统计构建的人塔中 `A` 和 `B` 的数量是否与输入相同，相同的话种类数 $+1$。

什么是二进制枚举？以本题为例，每一个位置要么放 `A` 要么放 `B`，这和二进制有点像啊，那就让 `A` 对应 $1$，`B` 对应 $0$。

这样一来，`1 1 0` 什么意思？`A A B` 的意思吧。加入最底下一行有 $3$ 个人，所有的可能，`BBB，BBA，BAB，BAA，ABB，ABA，AAB，AAA，` 对应的二进制为 `000，001，010，011，100，101，110，111`，这不就是 $2^3$ 吗。所以，最后一行的排列状态就可以通过循环表现出来了：`for(int i=0;i<=(1<<3)-1;i++)`。

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50;
int dp[N];//用一维数组表示二维状态，有点类似01背包问题优化的思想，但不是01背包！
int main(){
    int n,m,ans=0;
    cin>>m>>n;
    int h=(int)sqrt(2*(m+n));//计算出人塔的行数
    for(int num=0;num<=(1<<h)-1;num++){
        int tmp_h=h,tmp=num,cnt_a=0,cnt_b=0;
        for(int i=tmp_h;i>=1;i--,tmp>>=1){
            dp[i]=tmp&1;//初始化最底下一行
            if(dp[i]) cnt_a++;
            else cnt_b++;
        }

        while(tmp_h--){
            for(int i=1;i<=tmp_h;i++){
                if(dp[i+1] == dp[i]) cnt_a++,dp[i]=1;//set A
                else cnt_b++,dp[i]=0;//set B
            }
        }
        if(cnt_a==m && cnt_b==n) ans++;
    }
    cout<<ans<<endl;
} 
```

---

## 作者：liupei (赞：0)

## 思路
首先，我们可以通过枚举组成的塔的高度来解决这个问题。假设我们现在正在组成一个高为 $h$ 的塔，我们需要知道上一层的组成方式，即上一层由哪些人组成。因为在组成塔的时候，只有两种类型的人，所以上一层就只有两种情况。设 $a_{i,j}$ 表示上一层由 $i$ 个 A 和 $j$ 个 B 组成，当前层为 A 的方案数。同理，设 $a_{i,j}$ 表示上一层由 $i$ 个 A 和 $j$ 个 B 组成，当前层为 B 的方案数。那么当前层的总方案数就是 $a_{i,j}+a_{i,j}$，即上一层可以是 A 也可以是 B。

接下来的问题是如何计算 $a_{i,j}$ 和 $a_{i,j}$。我们可以分情况讨论。


- 上一层由 $i-1$ 个 A 和 $j$ 个 B 组成。

那么我们可以在上一层的每个 A 旁边放一个 A，或者在上一层的每个 B 上放一个 A，因此方案数为 $a_{{i-1},j}+a_{{i-1},j}$。

- 上一层由 $i$ 个 A 和 $j-1$ 个 B 组成。

那么我们可以在上一层的每个 A 上放一个 B，或者在上一层的每个 B 旁边放一个 B，因此方案数为 $a_{i,{j-1}}+a_{i,{j-1}}$。


综上所述，我们可以得到状态转移方程。
$$\begin{aligned} a_{i,j} &= a_{{i-1},j} + a_{{i-1},j} + a_{i,{j-1}} \ a_{i,j} &= a_{i,{j-1}} + a_{i,{j-1}} + a_{{i-1},j} \end{aligned} $$
边界条件为 $a_{1,0}=1$ 和 $a_{0,1}=1$，因为当只有一个 A 或者一个 B 时，只有一种方案。

最终的答案就是 $a_{m,n}+a_{m,n}$，因为最后一层可以是 A 也可以是 B。

---

## 作者：Suite_No1_G (赞：0)

分析：

感觉数据范围很小，根据计算可得出这个塔最高有 $21$ 层。

所以就可以暴力枚举最后一层的状态。

然后从最后一层往上推出所有状态。

然后计算个数即可。

普通的数组模拟会超时，用位运算会快一些。

开个 O2 优化就过了。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int x,y;
int n;
int ans=0;

void check(int xx){
	int cnt0=0,cnt1=0;
	
	for (int wei=n-1;wei>=0;wei--){
		for (int i=0;i<=wei;i++){
			if (xx&(1<<i)) cnt1++;
			else cnt0++; 
		}
		//计算这一层的A B个数
		if (cnt0>x||cnt1>y) return;
				
		int num=0;
		for (int i=0;i<wei;i++){
			int a=xx&(1<<i),b=xx&(1<<(i+1));
			if ((a&&b==0)||(a==0&&b)) num=(num<<1)|1;
			else num=num<<1; 
		}//分情况推出上一层的状态
		
		if (cnt0>x||cnt1>y) return;
		
		xx=num;
	}
	
	if (cnt0==x&&cnt1==y) ans++;
}

int main(){
	scanf("%d%d",&x,&y);
	
	for (int i=0;i<=30;i++){
		if (i*(i+1)/2==x+y){
			n=i;
			break;
		}
	}
	
	for (int i=0;i<(1<<n);i++){//枚举每一种状态
		check(i);
	}
	
	printf("%d",ans);
	return 0;
}
```


---


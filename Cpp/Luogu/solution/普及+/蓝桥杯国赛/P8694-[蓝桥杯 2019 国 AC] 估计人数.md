# [蓝桥杯 2019 国 AC] 估计人数

## 题目描述

给定一个 $N \times M$ 的方格矩阵，矩阵中每个方格标记 `0` 或者 `1` 代表这个方格是不是有人踩过。

已知一个人可能从任意方格开始，之后每一步只能向右或者向下走一格。走了若干步之后，这个人可以离开矩阵。这个人经过的方格都会被标记为 `1`，包括开始和结束的方格。注意开始和结束的方格不需要一定在矩阵边缘。

请你计算至少有多少人在矩阵上走过。

## 说明/提示

对于所有评测用例, $1 \leq N, M \leq 20$, 标记为 `1` 的方格不超过 $200$ 个。

蓝桥杯 2019 年国赛 A 组 G 题（C 组 H 题）。

## 样例 #1

### 输入

```
5 5
00100
11111
00100
11111
00100```

### 输出

```
3```

# 题解

## 作者：Rem_CandleFire (赞：1)

**分析与做法**

若将矩阵上的 $1$ 看做一个有向图，那么问题能转化成有向图上的最小可重链覆盖。

套路地，对于有向图做一个传递闭包（人话就是预处理出任意两点是否可达），这样我们就可以在上面做最小不可重链覆盖。

继续套路，将每个点拆成入点和出点，对于有向图上的一对可互相到达的点 $(u,v)$，连边 $u_{out}$ 和 $v_{in}$，那么二分图每一条边就对应着原图的某条边。

那么根据 [Dilworth 定理](https://www.luogu.com.cn/article/0ftmvbm3) 以及该文中的一些推理，答案就是有向图点数减去最大匹配。那么此题就做完了。

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,m,len;
int f[N][N],mch[N],vis[N];
struct node{ int x,y; } p[N];
vector<int> g[N];
void Add(int u,int v){ g[u].push_back(v),g[v].push_back(u); }
bool Match(int u)
{
	for(auto v:g[u])
	{
		if(vis[v]) continue;
		vis[v]=1;
		if(!mch[v]||Match(mch[v]))
			{ mch[v]=u; return true; }
	}
	return false;
}
int main()
{
	scanf("%d%d",&n,&m); char c;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='1') p[++len]={i,j};
		}
	for(int i=1;i<=len;i++)
		for(int j=i+1;j<=len;j++)
			if(p[i].x==p[j].x&&p[i].y+1==p[j].y||p[i].x+1==p[j].x&&p[i].y==p[j].y) f[i][j]=1;
	for(int k=1;k<=len;k++)
		for(int i=1;i<=len;i++)
			for(int j=1;j<=len;j++)
				f[i][j]|=(f[i][k]&f[k][j]);
	for(int i=1;i<=len;i++)
	{
		for(int j=i+1;j<=len;j++)
			if(f[i][j]) Add(i,j+len);
	}
	int sum=0;
	for(int i=1;i<=len;i++)
	{
		fill(vis,vis+1+len*2,0);
		if(Match(i)) sum++;
	}
	printf("%d",len-sum);

	return 0;
}
```

---

## 作者：沉鸣cmh (赞：1)

其实这题并不需要 Dilworth 定理。

把图看成一个只能向下或向左的有向图之后，其实就变成了最小可重合链覆盖。

普通的二分图匹配只能解决最小不可重链覆盖，我们只需要用 Floyd 跑一遍联通，然后直接跑二分图匹配是等效的。

下面是代码。

```cpp
#include<bits/stdc++.h>
#define N 1005
using namespace std;
int n,m,t,fi[N],cnt,f[N][N],mh[N],ans;
bool vis[N];
struct p{
	int ne,to;
}l[N*N];
struct data{
	int x,y;
}a[N];
char c[N];
inline void add(int x,int y){
	l[++cnt].ne=fi[x];
	l[cnt].to=y;
	fi[x]=cnt;
}
inline int read(){
	int res=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
	while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();
	return res*f;
}
inline bool dfs(int u){
	for(int i=fi[u];i;i=l[i].ne){
		int v=l[i].to;
		if(vis[v])continue;
		vis[v]=1;
		if(!mh[v]||dfs(mh[v])){
			mh[v]=u;
			return 1;
		}
	}
	return 0;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i){
		scanf("%s",c+1);
		for(int j=1;j<=m;++j)
		if(c[j]=='1')a[++t].x=i,a[t].y=j;
	}
	for(int i=1;i<=t;++i)
	for(int j=i+1;j<=t;++j)
	if((a[i].y+1==a[j].y&&a[i].x==a[j].x)||(a[i].y==a[j].y&&a[i].x+1==a[j].x))f[i][j]=1;
	for(int k=1;k<=t;++k)
	for(int i=1;i<=t;++i)
	for(int j=1;j<=t;++j)
	f[i][j]|=f[i][k]&f[k][j];
	for(int i=1;i<=t;++i)
	for(int j=i+1;j<=t;++j)
	if(f[i][j])add(i,j+t);
	for(int i=1;i<=t;++i){
		memset(vis,0,sizeof(vis));
		if(dfs(i))++ans;
	}
	printf("%d\n",t-ans);
	return 0;
}
```


---

## 作者：lyh4 (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P8694)

### 思路：
这道题实际上是最小不可重链覆盖。我们把图看成**只能向下或向左的有向图**，就可用最小不可重链覆盖解决了。
用 Floyd 跑一遍联通，再将其转换为二分图，利用二分图匹配解决最小不可重链覆盖。

---


# [蓝桥杯 2019 国 B] 排列数

## 题目描述

在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。

对于一个 $1 ∼ n$ 的排列，如果可以将这个排列中包含 $t$ 个折点，则它称为一个 $t + 1$ 单调排列。

例如，排列 $(1, 4, 2, 3)$ 是一个 $3$ 单调排列，其中 $4$ 和 $2$ 都是折点。

给定 $n$ 和 $k$，请问 $1 ∼ n$ 的所有排列中有多少个 $k$ 单调排列？


## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq k \leq n \leq 10$;

对于 $40 \%$ 的评测用例, $1 \leq k \leq n \leq 20$; 对于 $60 \%$ 的评测用例, $1 \leq k \leq n \leq 100$;

对于所有评测用例， $1 \leq k \leq n \leq 500$ 。 


蓝桥杯 2019 年国赛 B 组 G 题。

## 样例 #1

### 输入

```
4 2
```

### 输出

```
12
```

# 题解

## 作者：DreamLand_zcb (赞：20)

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P8699)

## 思路

设状态 $dp[i][j]$ 其中 $i$ 表示前 $i$ 个数中，有 $j$ 个**折点**的方案数。

考虑状态转移，显然 $dp[i][j]$ 只能影响到 $dp[i+1][j]$、$dp[i+1][j+1]$、$dp[i+1][j+2]$，证明如下：

首先需要确定，在原序列中插入第 $i + 1$ 个数，这个 $i + 1$ 是所有数中最大的，所以只要**在非头/尾部**插入这个点，这个点一定就是新的折点。

1. $dp[i+1][j]$ 表示插入第 $i + 1$ 个点后没有新增折点：

	例：![](https://huatu.98youxi.com/markdown/work/uploads/upload_16b4e7b0d43cdeb644b4cabd34dd15d0.png)
    
    情况一如图，当 $i + 1$ 插入波峰 $x$ 左右侧时，$x$ 不再是折点，折点变成了 $i + 1$，此时折点数不变。
    
    ![](https://huatu.98youxi.com/markdown/work/uploads/upload_3d9a88cca324cab932e0d8f535543686.png)
    
    情况二如图，当 $i + 1$ 插入序列头尾 $x$ 左右时，$x$ 依然不是折点，序列没有新增折点，此时折点数不变（如果头或尾的点是向下走的那么插入后新增了一个点，不属于该范围，此时只有在其中一边插入 $i + 1$ 才能满足不增加新折点）。
    
    
    总结一下，当 $j$ 为奇数，总共 $\dfrac {j-1}2 \times 2 + 2 = j + 1$ 种可能。当 $j$ 为偶数，总共 $\dfrac {j}2 \times 2 + 1 = j + 1$ 中可能，所以转移方程：
    
    $$dp[i+1][j] = dp[i][j] \times (j + 1)$$
    
    
2. $dp[i+1][j+1]$ 表示插入第 $i + 1$ 个点后新增了一个转折点。

	只有一种情况，即当在序列头和尾向下走时在头和尾前后插入 $i + 1$ 只增加一个转折点，如图，$x$ 为新增的一个转折点。
    
    ![](https://huatu.98youxi.com/markdown/work/uploads/upload_040e678fb67293b57c25d32629a103e7.png)
    
    所以转移方程：
    
    $$dp[i+1][j+1] = dp[i][j] \times 2$$
    
3. $dp[i+1][j+2]$ 表示插入第 $i + 1$ 个点后新增了两个转折点。

	显然在除了以上所有情况，其他地方插入 $i + 1$ 都会新增两个折点，转移方程：
    
    $$dp[i+1][j+2] = dp[i][j] \times (i + 1 - (j + 1) - 2)$$
    
    $$ = dp[i][j] \times (i - j - 2)$$
    
初始值：$dp[1][0] = 1$、$dp[i][0] = 2 (1 < i < n)$。

答案：$dp[n][k-1]$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a))
using namespace std;

const int MOD = 123456;
int n, k;
int dp[505][505];
int mod(int a)
{
	return a % MOD;
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	dp[1][0] = 1;
	for(int i=2;i<n;i++)
	{
		dp[i][0] = 2;
		for(int j=0;j<=i;j++)
		{
			dp[i+1][j] += mod(dp[i][j] * (j + 1));
			dp[i+1][j+1] += mod(dp[i][j] * 2);
			dp[i+1][j+2] += mod(dp[i][j] * (i - j - 2));
		}
	}
	cout << dp[n][k-1] % MOD;
	return 0;
}

```

---

## 作者：Fantasy_Segment_Tree (赞：7)

考虑在 $1$ 至 $i$ 中插入 $i + 1$，则有以下几种情况：

1. 不新增折点。

![](https://cdn.luogu.com.cn/upload/image_hosting/j594d715.png?x-oss-process=image/resize,m_lfit,h_1020,w_1350)

当 $j$ 为奇数时，两头都可以插入 $i + 1$，同时波峰共有 $\frac{j - 1}{2} \times 2$（波峰两端都可以插入）种情况，共 $\frac{j - 1}{2} \times 2 + 2 = j + 1$ 种情况。

当 $j$ 为偶数时，必定两头一上一下，所以只有一端可以插入 $i + 1$，共有 $\frac{j}{2} \times 2 + 1 = j + 1$ 种情况。

综上所述，不新增折点的共有 $j + 1$ 种情况。

2. 新增一个折点

![](https://cdn.luogu.com.cn/upload/image_hosting/7p30ke5w.png?x-oss-process=image/resize,m_lfit,h_1020,w_1350)

这种情况只有当两头均向下的时候在两头插入才会出现。所以共有 $2$ 种。

3. 新增两个折点

对于 $1$ 至 $i$ 的数列，每两个数之间或者数列前后都可以插入，共 $(i - 1) + 2 = i + 1$ 种情况。

除去另外两种情况，共有 $(i + 1) - (j + 1) - 2 = i - j - 2$ 种情况。

所以状态转移方程就是：

1. $f_{i + 1, j} \gets f_{i + 1, j} + (j + 1) \times f_{i, j}$

1. $f_{i + 1, j + 1} \gets f_{i + 1, j + 1} + 2 \times f_{i, j}$

1. $f_{i + 1, j + 2} \gets f_{i + 1, j + 2} + (i - j - 2) \times f_{i, j}$



代码：

```cpp
#include <iostream>
using namespace std;

int dp[505][505], mod = 123456;

int main() {
	int n, k;
	cin >> n >> k;
	dp[1][0] = 1;
	for(int i = 2; i <= n; i++) {
		dp[i][0] = 2;
		for(int j = 0; j <= i; j++) {
			dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * 2 % mod) % mod;
			dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j] * (i - j - 2) % mod) % mod;
			dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (j + 1) % mod) % mod;
		}
	}
	cout << dp[n][k - 1];
}
```

注：状态转移部分是由 $f_{i, j}$ 进行推导，而不是推出 $f_{i, j}$。

---

## 作者：Dovuq (赞：7)

## 前言

~~时隔 $3$ 年，蒟蒻又来发题解啦~~

## 题目概要

[题目传送门](https://www.luogu.com.cn/problem/P8699)

题目大意：

> 给定正整数 $n$ 和 $k$，问 $1 ∼ n$ 的所有排列中有多少个 $k$ 单调排列。
>
> 其中 $k$ 单调排列我是这么理解的：以 $3,5,2,1,4,6$ 为例：
>
> ![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/dbe0hems.png)
>
> 图中数字经历上升、下降、上升三个过程，称为 $3$ 单调排列。
>
> 数据范围：$1\leq k\leq n\leq 500$

## 思路

这道题需要用 dp 做。为什么用 dp 呢？当然是因为 ~~算法标签里写着“动态规划, dp”咯~~ 此题的数据范围 $n\leq500$，用暴力的话显然是要 T 飞的。既然暴力做不了，那么 ~~自然~~ 就想到 dp 了。

不难想到，可以使用 $dp[i][j]$ 表示 $1∼i$ 的排列中 $j$ 单调序列的个数，则答案即为 $dp[n][m]$。

接下来考虑转移，即在 $1∼i$ 的排列中插入数 $i+1$ 后（显然一共有 $i+1$ 种插入方法），对单调序列的影响。而对于一个 $j$ 单调序列，序列的开始（即第一、二个数）是上升还是下降可能会对转移有一定的影响，于是 $dp$ 数组不妨多开一维，令 $dp[i][j][0]$ 表示序列开始处上升的方案数，$dp[i][j][1]$ 表示序列开始处下降的方案数。

接下来考虑 $dp[i][j][k=0/1]$ 对 $dp[i+1][?][?]$ 的贡献

### 1. $j$ 是偶数，$k=0$

抽象的 Example:

![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/ptdmtu0i.png)

1. 考虑将 $i+1$ 插入到哪里，$j$ 的值不变？答案为两个“峰”的前后，共 $4$ 处位置。一般地，$j$ 单调序列有 $\frac j2$ 个“峰”，每个“峰”前后插入 $i+1$ 都不会使 $j$ 变化，且序列开始处仍保持上升，共 $j$ 处位置，故
$$dp[i+1][j][0]\leftarrow dp[i+1][j][0]+dp[i][j][0]\times j$$

2. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $1$？答案为开头和结尾两处，其中开头处会将序列开始处的上升变为下降，而结尾处的不会。一般地，任意 $j$ 单调序列都会有开头和结尾两处使 $j$ 增加 $1$，且开头处改变序列开始的状态，故
$$dp[i+1][j+1][0]\leftarrow dp[i+1][j+1][0]+dp[i][j][0]\\dp[i+1][j+1][1]\leftarrow dp[i+1][j+1][1]+dp[i][j][0]$$

3. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $2$？显然，将 $i+1$ 插入任意位置，$j$ 的值不可能减少，也不可能增加量 $\geq3$，故除去以上两种，剩下的 $(i+1)-j-2=i-j-1$ 个位置都使 $j$ 增加 $2$，且不会改变序列开始处的上升状态，故
$$dp[i+1][j+2][0]\leftarrow dp[i+1][j+2][0]+dp[i][j][0]\times(i-j-1)$$

### 2. $j$ 是偶数，$k=1$

Yet another 抽象的 Example:

![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/yfmk6hoo.png)

1. 考虑将 $i+1$ 插入到哪里，$j$ 的值不变？答案为“峰”的前后，以及整个序列的头尾，共 $4$ 处位置。一般地，$j$ 单调序列有 $\frac j2-1$ 个“峰”，每个“峰”前后及序列头尾插入 $i+1$ 都不会使 $j$ 变化，且序列开始处仍保持下降，共 $j$ 处位置，故
$$dp[i+1][j][1]\leftarrow dp[i+1][j][1]+dp[i][j][1]\times j$$

2. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $1$？答案为第二个位置和倒数第二个位置，共两处，其中第二个位置会将序列开始处的下降变为上升，而结尾处的不会。一般地，任意 $j$ 单调序列都会有这两处使 $j$ 增加 $1$，且位于开头的一处改变序列开始的状态，故
$$dp[i+1][j+1][0]\leftarrow dp[i+1][j+1][0]+dp[i][j][1]\\dp[i+1][j+1][1]\leftarrow dp[i+1][j+1][1]+dp[i][j][1]$$

3. 考虑将 $i+1$ 插入到哪里，$j$ 的值会增加 $2$？同样地，将 $i+1$ 插入任意位置，$j$ 的值不可能减少，也不可能增加量 $\geq3$，故除去以上两种，剩下的 $(i+1)-j-2=i-j-1$ 个位置都使 $j$ 增加 $2$，且不会改变序列开始处的下降状态，故
$$dp[i+1][j+2][1]\leftarrow dp[i+1][j+2][1]+dp[i][j][1]\times(i-j-1)$$

### 3. $j$ 是奇数，$k=0$

### 4. $j$ 是奇数，$k=1$

类似上面的方法，同样可以得出这两种情况下的转移方程，结果与上面的完全相同。

### 小优化

而此时可以发现，$k=0$ 与 $k=1$ 的转移也完全相同，完全可以合并，不需要第三维状态了，省了一半时间/空间。

好啦，写到这里，该分析的也都分析完了，可以~~快乐地~~写代码啦 \\(^O^)/ 还有，不要忘记模 $123456$ 哦！

## Code (超短！)

```cpp
#include <bits/stdc++.h>
#define mod 123456 // 模数
using namespace std;
int n,m,dp[505][505]; // dp 数组
int main ()
{
    scanf ("%d%d",&n,&m); // 输入
    if (n==1) // 因为 dp 是从 2 开始的，所以 n=1 的情况特判一下
    {
        if (m==1) puts ("1");
        else puts ("0");
        return 0;
    }
    dp[2][1]=2; // 初始值，n=2 时不管是 1,2 还是 2,1 都是 1 单调排列
    for (int i=2;i<n;i++)
        for (int j=1;j<=m;j++)
        {
//            printf ("dp[%d][%d]=%d\n",i,j,dp[i][j]); // 调试用
            dp[i+1][j]=(dp[i+1][j]+dp[i][j]*j)%mod; // 转移
            dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j]*2)%mod;
            dp[i+1][j+2]=(dp[i+1][j+2]+dp[i][j]*(i-j-1))%mod;
        }
    printf ("%d\n",dp[n][m]%mod); // 输出
    return 0;
}
```

---

## 作者：elainya_stars (赞：2)

# [P8699 [蓝桥杯 2019 国 B] 排列数](https://www.luogu.com.cn/problem/P8699)

## 思路
考虑动态规划。

### 1.定义
定义 $dp[i][j]$ 表示添加了前 $i$ 个数，且有 $j$ 个折点的方案总数。

### 2.初始化
$dp[i][0]=2(1 < i \le n)$，因为没有折点的话只有单调上升和单调下降两种情况。

$dp[1][0]=1$，因为只有一个数。

### 3. 状态转移
考虑需要在 $i$ 个数 $1 \sim i$ 的基础上添加一个数 $i-1$，折点数 $j$ 的变化情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/5r14rdja.png)

$\color{red}{1.}$ **不增加任何折点**

这种情况会发生条件：插入到“往上扎”折点的两侧，或插入到“往上扎”的两端节点的外侧（图中红色），分 $j$ 为**奇数**和**偶数**两种情况。

当 $j$ 为奇数时：

> ![](https://cdn.luogu.com.cn/upload/image_hosting/9iwds0u9.png)
> 
> 此时，“往上扎”折点有 $\displaystyle \frac{j-1}{2}$ 个（很好理解，因为“下上下上下...”），“往上扎”的两端节点有 $2$ 个，共 $\displaystyle \frac{j-1}{2} \times 2 + 2 = j+1$ 种情况。
> 
> ![](https://cdn.luogu.com.cn/upload/image_hosting/3mqvp0va.png)
> 
> 此时，“往上扎”折点有 $\displaystyle \frac{j}{2} + 1$ 个（很好理解，因为“上下上下上...”），没有“往上扎”的两端节点，共 $(\displaystyle \frac{j}{2} + 1) \times 2 = j+1$ 种情况（因为 $\displaystyle \frac{j}{2}$ 自动下取整）。
>
> 综上，$j$ 为奇数时，共 $j+1$ 种情况。

当 $j$ 为偶数时：

> ![](https://cdn.luogu.com.cn/upload/image_hosting/zqd1tv30.png)
>
> 此时，“往上扎”折点有 $\displaystyle \frac{j}{2}$ 个（更好理解了），“往上扎”的两端节点有 $1$ 个，共 $\displaystyle \frac{j}{2} \times 2 + 1 = j+1$ 种情况。

说了半天，不增加任何折点的情况有 $j+1$ 种。

$$dp[i+1][j] \gets dp[i][j]\times(j+1)$$

-----

![](https://cdn.luogu.com.cn/upload/image_hosting/5r14rdja.png)

$\color{deepskyblue}{2.}$ **增加 $1$ 个折点**

此时最多只有插入最左端和最右端两种情况，共有 $2$ 种情况.

$$dp[i+1][j+1] \gets dp[i][j]\times 2$$

-----

$\color{limegreen}{3.}$ **增加 $2$ 个折点**

这种情况是除了上两种情况的情况，用总共可以插入的点数（图中 $8$ 们）减去前两种情况数，所以共有 $(i+1)-(j+1)-2=i-j-2$ 种情况。

$$dp[i+1][j+2] \gets dp[i][j]\times(i-j-2)$$

综上，状态转移搞定。**记得模 $123456$。**

### 4. 输出

明显的 $dp[n][k-1]$。**记得模 $123456$。**

## code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=505,mod=123456;
int n,k,dp[N][N];

signed main()
{
	scanf("%d%d",&n,&k);
	dp[1][0]=1; // 一个节点只能是"1"
	for(int i=2;i<=n;i++)
	{
		dp[i][0]=2; // 4个节点无折:1234或4321
		for(int j=0;j<=i-2;j++) // 4个节点最多2折:/\/
		{
			dp[i+1][j]+=(dp[i][j]*(j+1))%mod;
			dp[i+1][j+1]+=(dp[i][j]*2)%mod;
			dp[i+1][j+2]+=(dp[i][j]*(i-j-2))%mod;
		}
	}
	return !printf("%d\n",dp[n][k-1]%mod); // k折k+1单调排列
}
```
~~给我赞赞qwq~~

---

## 作者：sacc (赞：2)

## 题目描述
给定整数 $n$ 和 $k$，求 $1 \sim n$ 的所有排列中，恰好有 $k$ 个单调段的排列数量。由于答案可能很大，输出其对 $123456$ 取模的结果。

## 思路

考虑将数字 $i$ 插入到长度为 $i-1$ 的排列中，对单调段数的影响：
1. **不增加折点**：插入到不破坏原有单调性的位置，单调段数不变。贡献为 $dp[i-1][j] \times j$。
2. **增加一个折点**：插入到开头或结尾，形成一个新的折点。贡献为 $dp[i-1][j-1] \times 2$。
3. **增加两个折点**：插入到中间某个位置，同时形成两个新折点。贡献为 $dp[i-1][j-2] \times (i-j)$。

综合得到状态转移方程：
$$
dp[i][j]=(dp[i-1][j] \times j+dp[i-1][j-1] \times 2+dp[i-1][j-2] \times (i-j)) \mod 123456
$$

## 初始状态
- $dp[1][1]=1$：长度为 $1$ 的排列有 $1$ 个单调段。
- $dp[2][1]=2$：排列 $(1,2)$ 和 $(2,1)$ 都有 $1$ 个单调段。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
#define MOD 123456
int dp[505][505];
//dp[i][j]=(dp[i-1][j]*j+dp[i-1][j-1]*(i-j+1))%MOD;
signed main()
{
	//freopen(" .in","r",stdin);
 	//freopen(" .out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n,k;
    cin>>n>>k;
    dp[1][1]=1;
    dp[2][1]=2;
    for(int i=3;i<=n;i++)
    {
        for(int j=1;j<=k;j++)
        {
            dp[i][j]=(dp[i-1][j]*j%MOD/*不增加折点*/+dp[i-1][j-1]*2%MOD/*增加一个折点*/+dp[i-1][j-2]*(i-j)%MOD/*不增加两个折点*/)%MOD;
        }
    }
    cout<<dp[n][k];
    return 0;
}
/*1 2 3 4 5 6
dp[i][j]表示1~i里有几个j单调排列 
*/
```

---

## 作者：Ericnoi (赞：0)

# P8699 题解
[题目传送门](https://www.luogu.com.cn/problem/P8699)

# 思路
不难发现，本题应该用 DP 来做。因此，我们可以尝试几种状态设计：

1. 令 $dp_{i,j,k}$ 表示第 $1 \sim i$ 个数字，第 $i$ 个数字为 $j$，折点数为 $k$ 的方案数。

我们发现这个状态设计有一个致命缺陷：不能保证数字 $1 \sim i$ 不重复出现。根据这个缺陷，我们可以推出状态设计 2.0：

2. 令 $dp_{i,j}$ 表示使用了**数字 $1 \sim i$**，折点数为 $j$ 的方案数。

于是就转化成了这么一个问题：已知一个 $1 \sim i$ 的排列，尝试把 $i + 1$ 插入其中。并且这个状态的定义带给了我们一个重要条件：**当前新加入的数字，一定是所有数字中最大的**。

这里我们采取刷表法。于是我们可以列出状态转移方程的大致形式：插入后的新状态数 $\gets$ 插入后的新状态数 $+$ 插入方法数 $\times$ 插入前的旧状态数。以新折点数为分类依据进行分类讨论：

- 折点数量增加 $0$。

显然是在翘起的两头插入，或者是在波峰的两头插入。注意到总是共有 $j + 1$ 种。

- 折点数量增加 $1$。

显然是在下垂的两头，或者翘起的两头内侧插入。注意到总是共有 $2$ 种。

- 折点数量增加 $2$。

由于共有 $i + 1$ 个位置插入，减去先前的 $j + 1$ 和 $2$，还剩 $i - j - 2$。

总的状态转移方式见代码。初始值：$dp_{2,0} = 2$。$n = 1$ 时直接特判。

# Code

```cpp
#include <bits/stdc++.h>
#define fill(x, y) memset(x, y, sizeof(x))
#define inf (0x3f3f3f3f)
#define pb push_back
#define add(x, y) ((1ll * (x) + (y)) % mod)
#define addto(x, y) ((x) = add((x), (y)))
#define times(x, y) ((1ll * (x) * (y)) % mod)
using namespace std;
int cx = 1;
const int N = 500 + 5;
const int K = 500 + 5;
const int mod = 123456;
int n, k, dp[N][K];
void solve() {
	cin >> n >> k;
	if (n == 1) { // 特判
		cout << (k == 0) << endl;
		return ;
	}
	dp[2][0] = 2;
	for (int i = 2 ; i <= n ; i++) {
		for (int j = 0 ; j <= i ; j++) { // 刷表法所用的状态转移方式
			addto(dp[i + 1][j], times(j + 1, dp[i][j]));
			addto(dp[i + 1][j + 1], times(2, dp[i][j]));
			addto(dp[i + 1][j + 2], times(i - j - 2, dp[i][j]));
		}
	}
	cout << dp[n][k - 1] << endl;
}
signed main() {
	ios :: sync_with_stdio(false), cin.tie(0), cout.tie(0);
	while (cx--) {
		solve();
	}
	return 0;
}
```

---


# [蓝桥杯 2019 国 B] 最优包含

## 题目描述

我们称一个字符串 $S$ 包含字符串 $T$ 是指 $T$ 是 $S$ 的一个子序列，即可以从字符串 $S$ 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 $T$ 完全一样。

给定两个字符串 $S$ 和 $T$，请问最少修改 $S$ 中的多少个字符，能使 $S$ 包含 $T$。

## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq|T| \leq|S| \leq 20$;

对于 $40 \%$ 的评测用例, $1 \leq|T| \leq|S| \leq 100$;

对于所有评测用例, $1 \leq|T| \leq|S| \leq 1000$。

蓝桥杯 2019 年国赛 B 组 F 题。

## 样例 #1

### 输入

```
ABCDEABCD
XAABZ
```

### 输出

```
3
```

# 题解

## 作者：Versed_sine (赞：13)

# P8703 \[蓝桥杯 2019 国 B\] 最优包含 题解

[题目链接](https://www.luogu.com.cn/problem/P8703)

## 分析

对于这类的字符串问题，可以考虑动规。

不妨设 $dp_{i,j}$ 为修改 $s$ 的前 $i$ 个字符、使得 $s$ 的前 $i$ 个字符能够包含 $t$ 的前 $j$ 个字符的最少次数。

此时需要分类讨论 $s_i$ 与 $t_j$ 是否相等的情况。

1. 若 $s_i=t_j$：则不用修改，可以直接 $dp_{i,j}\leftarrow dp_{i-1,j-1}$。（“$\leftarrow$”为赋值的意思，相当于代码中的 `=`）

2. 若 $s_i\ne t_j$：$t_j$ 要么在 $s$ 中已经出现过（$dp_{i,j}\leftarrow dp_{i-1,j}$）；要么在 $s$ 中没出现过，要修改 $s_i$（$dp_{i,j}\leftarrow dp_{i-1,j-1}+1$）。

注意：$dp$ 数组的在初始的时候需要使 $dp_{i,0} (0\le i\le|s|)$ 为 $0$，使 $dp_{i,j} (0\le i\le|s|,1\le j\le |t|)$ 为 $+\infty$，$dp_{i,j}$ 的定义可以解释这一点。

## [AC 代码](https://www.luogu.com.cn/record/106366475)

```
#include <bits/stdc++.h>
using namespace std;

#define inf 0x3f3f3f3f
#define maxn 1010
int dp[maxn][maxn];    //dp[i][j]:修改s的前i个字符、使得s的前i个字符能够包含t的前j个字符的最少次数
string s,t;

int main(){
	cin>>s>>t;
	s = " "+s;t = " "+t;
	memset(dp,inf,sizeof dp);
	for(int i=0;i<=s.size();i++) dp[i][0] = 0;
	for(int i=1;i<=s.size();i++) for(int j=1;j<=s.size();j++){
		if(s[i]==t[j]) dp[i][j] = dp[i-1][j-1];
		else dp[i][j] = min(dp[i-1][j-1]+1,dp[i-1][j]);
	}
	printf("%d",dp[s.size()][t.size()]);
	return 0;
}
```

---

## 作者：liaoxingrui (赞：4)

# [题目](https://www.luogu.com.cn/problem/P8703)

### 思路：

这道题我用的是动态规划算法。这里使用一个二维数组 $dp$，$dp_{i,j}$ 中第一个下标 $i$ 是表示 $S$ 字符串中的第 $i$ 个字符，第二个下标 $j$ 是表示 $T$ 字符串中的第 $j$ 个字符。

如果 $S_{i} = T_{j}$，那么 $dp_{i,j} \gets dp_{i-1,j-1}$。（不修改）

如果 $S_{i} \ne T_{j}$，那么 $dp_{i,j} \gets \operatorname{min}(dp_{i-1,j-1}+1,dp_{i-1,j})$。（修改）

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string S,T;
int dp[1005][1005]; 
int main(){
    cin>>S>>T;
    S=" "+S;
    T=" "+T;
	//在字符串前面加空格。（这个是将i=0变为i=1，将i<lenS变为i<=lenS，因为代码里面有
	//dp[i-1][j-1],S和T可能在i=0或j=0时相等，这是dp[i-1][j-1]中的一个或两个下表为-1）
    int lenS=S.size(),lenT=T.size();
    //lenS是S的长度，lenT是T的长度。 
    memset(dp,0x3f,sizeof(dp));
    for(int i=0;i<lenS;i++)
		dp[i][0]=0;
	//初始化。 
    for(int i=1;i<=lenS;i++)
        for(int j=1;i>=j&&j<=lenT;j++)
        	//i>=j是因为当j>i时，会有几个字符超出字符串的范围。 
            if(S[i]==T[j])
				dp[i][j]=dp[i-1][j-1];
            else
				dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]);
			//核心代码不懂，就看我在上面 ↑的解释。 
    cout<<dp[lenS-1][lenT-1];
    return 0;
}
```

---

## 作者：wuhan1234 (赞：3)

## 1. 编程思路。

采用 DP 进行求解。

设字符串 $S$ 的长度为 $sl$，字符串 $T$ 的长度为 $tl$。

定义 $dp_{i,j}$ 表示让字符串 $T$ 的前 $j$ 个字符成为字符串 $S$ 的前 $i$ 个字符的子序列时需要修改的字符个数。

初始时，所有的 $dp$ 值全设为 $0$。

显然，若 $S_0\ne T_0$，$dp_{0,0}=1$，需要将 $S_0$ 修改为 $T_0$。

之后初始化所有的 $dp_{i,0}(1\le i \le sl-1)$，若 $S_i=T_0$，显然不用修改，置 $dp_{i,0}=0$；否则，可能需要修改，$dp_{i,0}=dp_{i-1,0}$。

再初始化所有的 $dp_{j,j}(1\le j \le tl-1)$，若 $S_j=T_j$，显然不用修改，置 $dp_{j,j}=dp_{j-1,j-1}$；
否则，需要修改，$dp_{j,j}=dp_{j-1,j-1}+1$。

然后，根据下面的状态转移方程求 $dp_{i,j}(1\le j \le tl-1, j+1\le i \le sl)$。这里，字符串 $S$ 的长度必须超过字符串 $T$ 的长度。

若 $S_i=T_j$，当前 $S_i$ 不用修改，$dp_{i,j}=dp_{i-1,j-1}$。

若 $S_i\ne T_j$，当前 $S_i$ 可能需要修改，$dp_{i,j}=\min (dp_{i-1,j},dp_{i-1,j-1}+1)$。

## 2. 源程序。
```c
#include <stdio.h>
#include <string.h>
int min(int a,int b)
{
    return a<b?a:b;
}
int dp[1005][1005]={0};
int main()
{
    char s[1005],t[1005];
    scanf("%s%s",s,t);
    int slen = strlen(s);
    int tlen = strlen(t);
    if (s[0] != t[0])
        dp[0][0] = 1;
    int i,j;
    for (i = 1; i < slen; i++)   // 初始化 dp[i][0]  (0<i<len(s))
    {
        if (s[i] == t[0])
            dp[i][0] = 0;
        else
            dp[i][0] = dp[i - 1][0];
    }
    for (i = 1; i < tlen; i++)    // 初始化dp[i][i]  (0<i<len(t)
        if (s[i] == t[i])
            dp[i][i] = dp[i - 1][i - 1];
        else
            dp[i][i] = dp[i - 1][i - 1] + 1;

    for (j = 1; j < tlen; j++)  // 按状态转移方程求dp[i][j]
        for (i = j + 1; i < slen; i++)
            if (s[i] == t[j])
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + 1);
    printf("%d\n",dp[slen - 1][tlen - 1]);
    return 0;
}

```


---

## 作者：Mier_Samuelle (赞：1)

显然需要进行动态规划。

定义 $dp_{i,j}$ 为将 $S$ 长为 $i$ 的前缀修改为 $T$ 长为 $j$ 的前缀的最少操作次数。

根据 $S_i$ 是否与 $T_j$ 相等，可以得出状态转移方程：

$$dp_{i,j}=\begin{cases}dp_{i-1,j-1} & S_i=T_j \\ \min(dp_{i-1,j-1}+1,dp_{i-1,j}) & S_i \ne T_j\end{cases}$$

答案为 $dp_{|S|,|T|}$。

**解释**

- 若 $S_i=T_j$，不修改即可，直接从 $dp_{i-1,j-1}$ 转移。
- 若 $S_i \ne T_j$，则视情况可能需要修改。若 $S_i$ 已经包含 $T_j$，则无需修改，从 $dp_{i-1,j}$ 转移；否则需要修改，从 $dp_{i-1,j-1}+1$ 转移。

注意由于是要求最少操作次数，因此 $dp$ 初始时应设为 $+\infty$。特别地，$dp_{i,0}$ 应设为 $0$（$0 \le i \le |S|$）。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int dp[1010][1010]; //dp[i][j]表示使得S长为i的前缀包含T长为j的前缀的最少修改次数
int main(){
	memset(dp, 0x3f, sizeof(dp));
	string str1, str2;
	cin >> str1 >> str2;
	int n = str1.size(), m = str2.size();
	str1 = " " + str1; str2 = " " + str2;
	for (int i = 0;i <= n;i++) dp[i][0] = 0;
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++){
			if (str1[i] == str2[j]) dp[i][j] = dp[i - 1][j - 1];
			else dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j]);
		}
	cout << dp[n][m] << endl;
	return 0;
}
```

---

## 作者：Greenqwq (赞：1)

首先，我们那道题我们可以知道的是，这道题只有一种操作——即对数组 $a$ 进行修改。而且本道题尤其是字符串类求方案数的——都是给你两个字符串求方案数这种的我们通常采用 dp。

其实我做这道题，感觉它很像这道题[最短编辑距离](https://www.acwing.com/problem/content/description/904/)，但这道题相较于它少了 2 个操作。因此本道题的状态转移比它容易很多。

****

说了这么多，那本道题改如何做呢？

## 做法（dp）

本道题的状态表示为：集合 $f_{i,j}$ 表示所有把 $a$ 中的前 $i$ 个字母，变成 $b$ 中前 $j$ 个字母的集合的操作（修改）集合。

**状态属性**：数量。

**状态转移方程：**

- 当 $a_i=b_j$ 的时候，此时我们不需要修改，直接继承上一轮的答案。也就是 $f_{i,j}=f_{i-1,j-1}$。

- 当 $a_i\neq b_j$ 的时候，此时我们就得转移了，但此时我们得考虑此刻修改和不修改，如果 $b_j$ 在 $a_i$ 里面出现过，我们就不需要修改了，也就是状态为 $f_{i-1,j}$；如果没有出现过，我们修改，也就是 $f_{i-1,j-1}+1$，这里得取个 $min$，因为我们的状态属性为 $min$。

但我们还得注意的是，它的初始值应该为多少，我们知道，对于这种求最小值的，我们可以把 $f$ 设成无穷，但如果你设成无穷的话，可能无法转移，因此我们再看题目，我们设 $len_a$ 是数组 $a$ 的长度，发现 $f_{i,0}$ $(0 \leq i \leq len_a)$。意思就是：所有把 $a$ 中的前 $i$ 个字母，变成 $b$ 中前 $0$ 个字母的集合的操作（修改）集合，那么这肯定是 $0$，即不需要修改。

那么代码就很好写了。

# AC 代码

```
//有点类似最短编辑距离
//但最短编辑距离是让两个串一模一样
//因此本道题只要修改的操作

#include<iostream>
#include<cstring>

using namespace std;

const int N = 1010;

char a[N],b[N];
int n1,n2;
int f[N][N]; //所有把a中的前i个字母，变成b中前j个字母的集合的操作集合

int main(){
    cin>>(a+1)>>(b+1);
    
    n1=strlen(a+1),n2=strlen(b+1);
    
    memset(f,0x3f,sizeof f);
    
    for(int i=0;i<=n1;i++)f[i][0]=0;
    
    for(int i=1;i<=n1;i++){
        for(int j=1;j<=n2;j++){
            if(a[i]==b[j]){
                f[i][j]=f[i-1][j-1];
            }else{
                f[i][j]=min(f[i-1][j],f[i-1][j-1]+1);
            }
        }
    }
    
    cout<<f[n1][n2];
    
    return 0;
}
```

审核大大辛苦了，希望这能成为我第一篇解题。

---

## 作者：hh20080501hh (赞：1)

# 题目
[题目戳我哦](https://www.luogu.com.cn/problem/P8703)

题面简述：给定两个序列 $S$，$T$ 可以修改 $S$ 中的字符，问最少修改多少次能让 $T$ 成为 $S$ 的子序列（子序列是不需要连续的，子串是需要连续的）。
# 分析
通过观察题目，我们很容易想到这是 DP，~~观察力惊人。~~

考虑如何表示状态：$f_{i,j}$ 表示 $T$ 序列的前 $j$ 个字符是 $S$ 序列的前 $i$ 个字符的子序列的最小修改次数。

考虑状态如何转移：
- 对于 $S_i$ 与 $T_j$ 相等的情况，我们可以从 $f_{i-1,j}$ 转移过来（即不选 $S_i$），或者从 $f_{i-1,j-1}$ 转移过来（即选 $S_i$）。
- 对于 $S_i$ 不等于 $T_j$ 的情况，我们可以从 $f_{i-1,j}$ 转移过来（即不选 $T_j$），或者从 $f_{i-1,j-1}$ 转移过来（即选 $T_j$，不过由于 $S_i$ 不等于 $T_j$，所以我们要增加一次修改次数）。

即 `f[i][j] = min(f[i-1][j-1] , f[i-1][j])` 和 `f[i][j] = min(f[i-1][j] , f[i-1][j-1]+1)`。

此时我们注意到 $S_i$ 的转移只与 $S_{i-1}$ 有关，~~注意力惊人。~~ 所以我们可以使用滚动数组优化。不过现有的题解里面却没有一个这样优化的，不禁让人怀疑是否在用心写题解。

# 代码
代码很简单，也没有什么细节，就是需要注意一下输出的时候是 `t.size()-1`。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;

string S , T;
int f[2][N]; 

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	
	memset (f , 0x3f , sizeof f);
	cin >> S >> T;
	int cur = 0;
	for (int i=0 ; i<s.size() ; i++)
	{
		cur ^= 1;
		memset (f[cur] , 0x3f , sizeof f[cur]);
		f[cur][0] = 0;
		for (int j=0 ; j<t.size() ; j++)
		{
			if (S[i]==T[j]) f[cur][j] = min(f[cur^1][j-1] , f[cur^1][j]);
			else 
			{
				f[cur][j] = min(f[cur^1][j] , f[cur^1][j-1]+1);
			}
		}
	}
	cout << f[cur][T.size()-1];
	return 0;
}

```

---

## 作者：lqsy002 (赞：1)

## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P8703)。

## 解题思路

 **动态规划**

1. 初始化：因为求的是最小值，所以先对所有 $f$ 赋为正无穷，$f_{i,0}$ 代表 $a$ 的前 $i$ 个字符包含 $b$ 的前 $0$ 个字符的操作数,$b$ 的前 $0$ 个字符即空串，因为空串是任意串的子串，不需要进行更改操作，所以操作数为 $0$。

2. 把 $a_{i}$ 改成 $b_{j}$ 之后想要匹配,那么修改这一位之前，$a$ 的前 $i-1$ 个字符应该和 $b$ 的 $j-1$ 个字符相匹配，如果本来 $a_{i}$ 与 $b_{j}$ 就相等，那就不用改，之后取最小值即可解出。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int f[N][N],n,m;
char a[N],b[N];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>(a+1)>>(b+1);
	n=strlen(a+1);
    m=strlen(b+1);
	memset(f,63,sizeof(f));
	for(int i=0;i<=n;++i) 
        f[i][0]=0;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			f[i][j]=min(f[i][j],f[i-1][j]);
			if(a[i]==b[j])	
                f[i][j]=min(f[i][j],f[i-1][j-1]);
			else 
                f[i][j]=min(f[i][j],f[i-1][j-1]+1);
		}
	cout<<f[n][m];
	return 0;
}
```

---

## 作者：_7Mr (赞：1)

# 思路
看到这道题很容易想到动态规划，接下来我们就来定义状态。

我们设 $dp_{i,j}$ 表示 $s$ 的前 $i$ 个字符包含 $t$ 的前 $j$ 个字符。

那么我们的状态转移方程就很好推出来了。

- 当 $s_i = t_j$ 我们这时就不需要改变字符，直接转移 $dp_{i,j}=dp_{i-1,j-1}$。

- 当 $s_i \neq t_j$ 要么我们进行更改，要么直接转移前面的方案数。

# ACcode
```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
#define INF INT_MAX
using namespace std;
const int maxn=1e3+5;
int n,m;
int dp[maxn][maxn];
char s[maxn],t[maxn];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin>>(s+1)>>(t+1);
    n=strlen(s+1);m=strlen(t+1);
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;//初始化
    for(int i=1;i<=n;i++){
    	dp[i][0]=0;
    	for(int j=1;j<=m;j++){
    		if(s[i]==t[j]) dp[i][j]=dp[i-1][j-1];//分类讨论
    		else dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]);
		}
	}
	cout<<dp[n][m]<<endl;
	return 0;
}

```

---

## 作者：Ak_hjc_using (赞：0)

考虑动态规划。

### 思路

- 状态定义：定义 $dp_{i,j}$ 为 $s$ 的前 $i$ 个字符包含 $t$ 的前 $j$ 个字符的最小操作次数。

- 状态转移：

如果当前的字符 $s_{i}$ 与 $t_{j}$ 相等，那么就是

$$dp_{i,j} = dp_{i-1,j - 1}$$

无论如何都有

$$dp_{i,j} = \min (dp_{i,j - 1}, dp_{i - 1,j - 1} + 1, dp_{i - 1,j})$$

- 初始化：由于是求最小值，全部赋值为最大值。

注意：$dp_{i,0}$ 必须赋值为 $0$，它的定义可以说明这一点。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e3 + 1, INF = 1e18;
int dp[N][N];
string s, t;
signed main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> s >> t;
	for (int i = 0;i <= s.size();i ++)
	{
		for (int j = 0;j <= t.size();j ++)
		{
			dp[i][j] = INF;
		}
		dp[i][0] = 0;
	} 
	for (int i = 1;i <= s.size();i ++)
	{
		for (int j = 1;j <= t.size();j ++)
		{
			if(s[i - 1] == t[j - 1])
			{
				dp[i][j] = dp[i - 1][j - 1];
			}
			dp[i][j] = min({dp[i][j], dp[i - 1][j - 1] + 1, dp[i - 1][j]});
		}
	}
	cout << dp[s.size()][t.size()] << endl;
	return 0;
}

```

---

## 作者：sccc_ (赞：0)

## 思路

这道题，我们考虑 dp。

### 状态：

定义 $dp_{i,j}$ 为 $s$ 的前 $i$ 个字符需要包含 $t$ 的前 $j$ 个字符需要修改的最少次数。

### 答案：

$dp_{|s|,|t|}$，这里的 $|s|$ 为 $s$ 的长度。

### 状态转移方程：

这时，我们需要分类讨论情况：

- 若 $s_i = t_j$，即不用更改，$dp_{i,j} = dp_{i-1,j-1}$。

- 若 $s_i ≠ t_j$，这时又有两种状态。如果在 $s$ 中没有出现过，即为 $dp_{i-1,j-1}$；如果在 $s$ 中出现过 $t_j$ 我们不用修改，即为 $dp_{i-1,j}$。

### 初始化：

因为需要求最小值，所以我们应该把 $dp$ 数组设为极大值。

而 $dp_{i,0}$ 应设为 $0$，代表 $s$ 的前 $i$ 个字母，需要包含 $t$ 的前 $0$ 个字母的所需代价为 $0$。

## 代码
```c++
#include <bits/stdc++.h>
using namespace std;

string s, t;
int dp[1005][1005];

int main()
{
	cin >> s >> t;
	memset (dp, 0x3f, sizeof dp);
	int ls = s.size();
	int lt = t.size();
	for (int i = 0; i <= ls; i ++)
		dp[i][0] = 0;
	s = ' ' + s;
	t = ' ' + t;
	for (int i = 1; i <= ls; i ++)
	{
		for (int j = 1; j <= lt; j ++)
		{
			if (s[i] == t[j])
				dp[i][j] = dp[i - 1][j - 1];
			else
				dp[i][j] = min({dp[i][j], dp[i - 1][j], dp[i - 1][j - 1] + 1});
		}
	}
	cout << dp[ls][lt];
	return 0;
}

```

---

## 作者：2b2b2bbb (赞：0)

# 题意简化
给定两个字符串 $S ，T$，问最少修改 $S$ 中的几个字符能使 $S$ 包含 $T$。
# 思路
这道题目是一道典型的 $dp$ 问题。那么我们定义 $dp_{i , j}$ 表示让 $S$ 的前 $i$ 个字符，包含 $T$ 的前 $j$ 个字符的最小修改次数。

那么首先我们的 $dp$ 要先赋值成为极大值，然后我们想想什么情况下要赋值为 $0$ 。根据含义当 $T$ 为空的时候 $S$ 是不是绝对能包含 $T$ 啊。

那么我们就将所有 $T$ 为空的情况赋值为 $0$。

然后我们来考虑一下动态方程是什么。那么，我们就要分成两种思路。

当 $s_i = T_j$ 时，根据含义我们的答案就是 $dp_{i - 1 , j - 1}$ 不用变。

否则，答案要么在 $S$ 中出现了，要么不在 $S$ 中出现。

那么如果出现过了答案就是 $dp_{i - 1 , j}$ ，否则我们就要修改 $S$ 那么答案就是 $dp_{i - 1 , j - 1} + 1$ 。然后要求答案最小我们就取最小值。

最后根据含义我们输出 $dp_{S.size() - 1,T.size() - 1}$ 就可以了。
## code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
int dp[1005][1005];
int main(){
	cin >> s >> t;
	memset(dp , 0x3f , sizeof(dp));
	dp[0][0] = 0;
	s = " " + s;
	t = " " + t;
	for(int i = 0 ; i < s.size() ; i ++){
		dp[i][0] =0;
	}
	for(int i = 1 ; i < s.size() ; i ++){
		for(int j = 1 ; j < t.size() ; j ++){
			if(s[i] == t[j]){
				dp[i][j] = dp[i - 1][j - 1];
			}else{
				dp[i][j] = min(min(dp[i][j] , dp[i - 1][j - 1] + 1) , dp[i - 1][j]);
			}
		}
	}
	cout << dp[s.size() - 1][t.size() - 1];
	return 0;
}

```

---

## 作者：KidA (赞：0)

看到子序列、最少修改次数等关键词，考虑 dp。

状态：令 $dp_{i,j}$ 表示 $S$ 前 $i$ 个字符包含 $T$ 前 $j$ 个字符所需的最少修改次数。

答案：$dp_{n,m}$，其中 $n,m$ 分别为 $S,T$ 的长度。

初始：$dp_{i,0}=0$，其中 $0 \le i \le n$（注意 $i$ 可以为 $0$），其余极大值。

转移（分三类情形）：

- $S_i=T_j$

  无需修改，$dp_{i,j}=dp_{i-1,j-1}$。

- 修改 $S_i$

  $dp_{i,j}=dp_{i-1,j-1}+1$。

- 不修改 $S_i$

  此时需要保证 $S_{1 \sim i-1}$ 能包含 $T_{1 \sim j}$，$dp_{i,j}=dp_{i-1,j}$。


[实现](https://www.luogu.com.cn/paste/4jgvinta)。

---

## 作者：sieve (赞：0)

# 题解：[P8703 [蓝桥杯 2019 国 B] 最优包含](https://www.luogu.com.cn/problem/P8703)

## 思路

我们考虑动态规划。

定义 $dp_{i,j}$ 为 $s$ 的前 $i$ 个字符包含 $t$ 的前 $t$ 个字符的最小操作次数，然后，我们就可以写出状态转移方程：

当 $s_i$ 与 $t_j$ 相等时：

$$
dp_{i,j} = dp_{i-1,j-1}
$$

无论是否相等，都要：

$$
dp_{i,j} = \min(dp_{i,j},dp_{i-1,j-1}+1,dp_{i-1,j})
$$

然后，因为是求最小值，所以要把 $dp$ 数组初始值赋为极大值。然后所有的 $dp_{i,0}$ 要设为 $0$。

## Code:

```cpp

```#include<bits/stdc++.h>
#define int long long
using namespace std;
string s,t;
int n1,n2,dp[1005][1005];
signed main()
{
	memset(dp,0x3f,sizeof(dp));
	cin>>s>>t;
	n1=s.size(),n2=t.size();
	s=' '+s,t=' '+t;
	for(int i=0;i<=n1;++i) dp[i][0]=0;
	for(int i=1;i<=n1;++i) 
	{
		for(int j=1;j<=n2;++j)
		{
			if(s[i]==t[j]) dp[i][j]=dp[i-1][j-1];
			dp[i][j]=min({dp[i][j],dp[i-1][j-1]+1,dp[i-1][j]});
		}
	}
	cout<<dp[n1][n2];
	return 0;
}

---

## 作者：PartiallyCorrect (赞：0)

这道题目是一道经典的动态规划，我们定义 $f_{i, j}$ 表示 $s$ 前 $i$ 个字符包含 $t$ 前 $j$ 个字符，接下来分两种情况:

1.若 $s_{i} = t_{j}$ 这样不用修改，所以 $f_{i, j} = f_{i-1,j-1}$。

2.若 $s_{i} \neq t_{j}$ 碰到这种情况，我们可以将 $s_{i}$ 修改成与 $t_{j}$ 一样，或者用 $s_{i-1}$ 去与 $t_{j}$ 匹配。

注意这道题目初始的时候要使 $f_{i,0}$ 的值为 $0$。具体代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1005;
int f[N][N];
int main()
{
	string s, t;
	cin >> s >> t;
	s = ' ' + s;
	t = ' ' + t;
	memset(f, 0x3f, sizeof f);
	int n = s.size(), m = t.size();
	for(int i = 0 ; i <= n ; i ++)f[i][0] = 0;
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ; j ++)
		{
			if(s[i] == t[j])
				f[i][j] = f[i - 1][j - 1];
			else
				f[i][j] = min(f[i - 1][j - 1] + 1, f[i - 1][j]);
		}
	cout << f[n][m];
   	return 0;
}
```

---

## 作者：hexz01 (赞：0)

## P8703 [蓝桥杯 2019 国 B] 最优包含 题解

[题目传送门](https://www.luogu.com.cn/problem/P8703)

首先看到这类字符串包含的问题，直觉告诉我们它是 `dp`，那就看接下来 $4$ 个步骤：

### 1.状态

借鉴字符串编辑距离类问题，想到用 $dp_{i,j}$ 表示修改 $s$ 串的前 $i$ 个字母，使得 $s$ 串的前 $i$ 个字母包含 $t$ 串的前 $j$ 个字母需要的最小步数。

### 2.转移方程

考虑两种情况：
1. $s_i = t_j$，那么无需修改，从 $dp_{i-1,j-1}$ 直接转移。
2. $s_i \ne t_j$，那么有两种情况：1. 修改 $s_i$，从 $dp_{i-1,j-1}+1$ 转移。2. 把 $s_i$ 算在 $dp_{i, j-1}$ 里面，直接转移。

### 3.初始化

根据状态定义和题目描述，$dp_{i,0}$ 应为 $0$，而其余部分应为正无穷。

### 4.目标状态

根据题意，目标状态为 $dp_{|s|,|t|}$，其中 $|s|$ 为 $s$ 的长度。

### 最后

**code**
```cpp
#include <iostream>
#include <string>
using namespace std;
const int N=1007;
string s, t;
int dp[N][N];
int main(){
	cin>>s>>t;
	int n=s.size(), m=t.size();
	for(int i=0;i<=n;i++)
		for(int j=0;j<=m;j++)
			dp[i][j]=0x3f3f3f3f;
	for(int i=0;i<=n;i++)
		dp[i][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s[i-1]==t[j-1]){
				dp[i][j]=dp[i-1][j-1];
			}else{
				dp[i][j]=min(dp[i-1][j], dp[i-1][j-1]+1);
			}
		}
	}
	cout<<dp[n][m]<<endl;
	return 0;
}
```

---


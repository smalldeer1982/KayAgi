# [蓝桥杯 2021 国 ABC] 异或变换

## 题目描述

小蓝有一个 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$。

以后每个时刻, 小蓝要对这个 01 串进行一次变换。每次变换的规则相同。 对于 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$, 变换后的 01 串 $s^{\prime}=s_{1}^{\prime} s_{2}^{\prime} s_{3}^{\prime} \cdots s_{n}^{\prime}$ 为：

$$
\begin{aligned}
&s_{1}^{\prime}=s_{1} \\
&s_{i}^{\prime}=s_{i-1} \oplus s_{i}
\end{aligned}
$$

其中 $a \oplus b$ 表示两个二进制的异或, 当 $a$ 和 $b$ 相同时结果为 $0$ , 当 $a$ 和 $b$ 不同时结果为 $1$ 。

请问, 经过 $t$ 次变换后的 01 串是什么?

## 说明/提示

**【样例说明】**

初始时为 `10110` , 变换 1 次后变为 `11101` , 变换 2 次后变为 `10011` , 变换 3 次后变为 `11010`。

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例, $1 \leq n \leq 100,1 \leq t \leq 1000$。

对于 $80 \%$ 的评测用例, $1 \leq n \leq 1000,1 \leq t \leq 10^{9}$。

对于所有评测用例, $1 \leq n \leq 10000,1 \leq t \leq 10^{18}$。

蓝桥杯 2021 国赛 A 组 F 题（B 组 G 题，C 组 G 题）。

## 样例 #1

### 输入

```
5 3
10110```

### 输出

```
11010```

# 题解

## 作者：ryf_loser (赞：20)

2024.3.11 添加第二组演示样例。

2024.3.12 修改第一组演示样例，添加一点点证明。

暴力显然寄飞了，考虑优化，这种情况往往是有规律的，我举两个例子样例进行模拟的。

输入 $n=4,t=5$，不难发现，从第 4 次就开始循环了。

$0. 0110 \leftarrow$

$1. 0101$

$2. 0111$

$3. 0100$

$4. 0110 \leftarrow$

用样例再来搞一下，输入 $n=5,t=9$

$0. 10110$

$1. 11101 \leftarrow$

$2. 10011$

$3. 11010$

$4. 10111 $

$5. 11100$

$6. 10010$

$7. 11011$

$8. 10110$

$9. 11101 \leftarrow$

有感觉了么？

那么，最终的规律是当大于等于 $n$ 的一个 2 的整数次幂情况下，必定存在循环。

可以证明，令 $x=2^k$，根据题目。

$s_{x,j}=s_{x-1,j}\oplus s_{x-1,j-1}$

$s_{x-1,j}=s_{x-2,j}\oplus s_{x-2,j-1}$

$s_{x-1,j-1}=s_{x-2,j-1}\oplus s_{x-2,j-2}$

……

由此递推下去，可得。

$s_{x,j}=s_{\frac{x}{2},j}\oplus s_{\frac{x}{2},j-x}$

根据异或性质可以发现，第 $x$ 的序列是由两次 $\frac{x}{2}$ 的序列得来的。

当 $x \geq n$ 时，这种重复操作变得没有意义，准确来说，当 $x \leq n$ 时必定存在与此时字符串 $s$ 完全相同。

时间复杂度为 $O(n \log \min(n,t))$ 级别。秒了。

AC CODE

```c
#include<stdio.h>
long long n,t;
int x=1;
char s[10005];
int main(){
	scanf ("%lld%lld",&n,&t);
	scanf ("%s",s);
	while(x<n)x<<=1;t=t%x;
	for(int i=0;i<t;i++)
		for(int j=n-1;j>=1;j--)
			s[j]=(s[j]-'0')^(s[j-1]-'0')+'0';
	printf ("%s",s);
	return 0;
}
```

---

## 作者：longlong666 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8763)

## 暴力

依题意模拟即可，时间复杂度 $O( n \cdot t )$，由题得 $t \le 10^{18}$，暴力显然寄了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e4+10;
int n,t;
string s;
bool a[maxn];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>t>>s;
	for(int i=0;i<(int)s.size();i++) a[i+1]=s[i]-'0';
	while(t--){for(int i=n;i>=2;i--) a[i]^=a[i-1];}//计算
	for(int i=1;i<=n;i++) cout<<a[i]; cout<<endl;
	return 0;
}
```

## 优化思路

应该是最详细的证明了。

可以证明，必定存在 $2$ 的正整数次幂的周期循环，理由如下。

令 $x = 2 ^ k \ge n$，初始字符串为 $s_0$，其各字符为 $s_{0,j}$ 则：

$$
\because s_{x,j}=s_{x-1,j-1} \oplus s_{x-1,j} \wedge s_{x-1,j-1}=s_{x-2,j-1} \oplus s_{x-2,j-2} \wedge s_{x-1,j}=s_{x-2,j-1} \oplus s_{x-2,j} \text{ ( 已知 ) } \\
\therefore s_{x,j}=s_{x-2,j-1} \oplus s_{x-2,j-2} \oplus s_{x-2,j-1} \oplus s_{x-2,j} \\
\text{又} \because x \oplus x = 0 \\
\therefore s_{x,j}=s_{x-2,j} \oplus s_{x-2,j-2} \\
\therefore s_{x-2,j}=s_{x-4,j} \oplus s_{x-4,j-2} \wedge s_{x-2,j-2}=s_{x-4,j-2} \oplus s_{x-4,j-4} \\
\therefore s_{x,j}=s_{x-4,j} \oplus s_{x-4,j-4} \\
\vdots \\
\therefore s_{x,j}=s_{x-2^k,j} \oplus s_{x-2^k,j-2^k} \\
\text{又} x = 2^k \\
\therefore s_{x,j}=s_{0,j} \oplus s_{0,j-x}\\
\text{又} x \ge n \\
\therefore j \le n \le x \implies j-x \le 0 \implies s_{0,j-x} \text{ 无意义 } \\
\therefore s_{x,j} = s_{0,j} \text{ 产生循环节 }
$$

（注：以上 $\wedge$ 代表且，$\oplus$ 代表异或）。

综上，一定会产生长度为 $2^k (2^k \ge n)$ 的循环节。

于是只需计算出 $x$ 将 $t$ 对 $x$ 取模后暴力模拟即可，暴力见上。

当然，为使时间复杂度最小，这里的 $k,x$ 应尽量最小。

时间复杂度，$O(n \cdot \min(\log n,t))$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e4+10;
int n,x,t;
string s;
bool a[maxn];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>t>>s; x=1;
	while(x<n) x<<=1; t%=x;//计算最少循环节 x 并将运算次数模 x
	for(int i=0;i<(int)s.size();i++) a[i+1]=s[i]-'0';//字符串转 bool
	while(t--){for(int i=n;i>=2;i--) a[i]^=a[i-1];}//暴力运算
	for(int i=1;i<=n;i++) cout<<a[i];//输出
	return 0;
}
```

码风丑陋，还请见谅。

---

## 作者：__CJY__ (赞：2)

## 思路
由于异或操作的性质，经过一定数量的变换后，串可能会回到其初始状态或某个之前的状态。

可以通过模拟或数学分析来找出这个周期。在这个问题中，周期 $x$ 是满足 $2^x \le n$ 的最小整数，可是有可能会重复，这样无意义。时间复杂度 $\Theta(nt)$。特别是当 $t$ 非常大时：$1 \le t \le 10^{18}$，显然会超时。

由于存在周期性，我们不需要实际执行 $t$ 次变换，我们可以计算 $t \bmod x$ 来找出实际需要执行的变换次数，这大大减少了计算量，时间复杂度 $\Theta(n\log n)$。

我们使用一个循环来执行实际需要的变换次数。
在每次变换中，从右向左遍历串，并根据异或规则更新每个元素。

**十年 OI 一场空，不开`long long`见祖宗！**
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,x=1;//分别表示：01串的长度、变换次数、用于计算变换周期的辅助变量
string s;//用于存储输入的01串
int main(){
	cin>>n>>t>>s;
	/*
	计算变换的周期，即找到一个最小的x，使得2^x>=n
	因为异或变换具有周期性，变换x次后会回到初始状态
	所以实际变换次数可以取t对x的模，减少计算量
	*/
	while(x<n) x<<=1;
	t%=x;//计算实际需要进行的变换次数
	//对01串进行t次变换
	for(int i=0;i<t;i++){
		//从右向左遍历01串，根据变换规则更新每个位置的值
		for(int j=n-1;j>=1;j--) s[j]=((s[j]-'0')^(s[j-1]-'0'))+'0';//将字符'0'/'1'转换为整数0/1进行异或运算，然后再转换回字符
	}
	cout<<s;
}
```

---

## 作者：zhouxiaodong (赞：2)

# 思路
暴力出奇迹总不会错。

先求出循环长度，公式是 $n \ge 2^x$，我们要尽量使 $x$ 小，用 $m$ 取模 $x$，使循环次数尽可能少，在循环模拟过程就行了。
# AC Code
``````````cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int n,m,x=1;
string a;
signed main()
{
	cin>>n>>m>>a;
	while(x<n)
	{
		x*=2;
	}
    m%=x;
	for(int i=1;i<=m;i++)
	{
		for(int j=n-1;j>=1;j--)
		{
			a[j]=(a[j]-'0')^(a[j-1]-'0')+'0';
		}
	}
    cout<<a;
	return 0;
}
``````````

---

## 作者：封禁用户 (赞：2)

# [P8763 [蓝桥杯 2021 国 ABC] 异或变换](https://www.luogu.com.cn/problem/P8763) 题解

## 一、题意

要求对 01 串进行变换，每次都需要根据某种固定的规则进行变换。规则是对于给定的 01 串 $s$，变换后的 01 串 $s^\prime$ 满足 $s_1^{\prime}=s_1$，$s_i^{\prime}=s_{i - 1}\oplus s_i$。

## 二、思路

不用想，直接暴力肯定获得 TLE。通过观察和证明可以发现，当变换次数达到某一个值时，结果会重复出现（即出现周期）。通过将长度为 `n` 的二进制数扩大一倍，即找到一个 `x`，使得 `x = 1 << (ceil(log2(n)))`，这样可以确保在 `x` 次变换内一定会出现周期。因此给定的变换次数 `t` 对 `x` 取模，得到变换次数，从后往前遍历字符串，根据变换规则计算每个位置的新值。

## 三、代码

这里使用了 `string` 作为题目中 01 串的类型，因此 `n` 可以替换为 `s.size()`。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace MuguCode
{
    string s;
    long long n, t, x;

    int main()
    {
        cin >> n >> t >> s;
        // 找到一个大于等于 n 的最小的 2 的整数次幂，其中位运算会稍快，左移相当于乘 2
        x = 1;
        while (x < n)
            x = x << 1;
        // 对变换次数取模，推算变换次数
        t = t % x;
        while (t--)
        {
            // 从后往前遍历字符串进行变换，注意 s[0] 不需要进行变换
            for (long long i = n - 1; i >= 1; i--)
                // 根据变换规则计算新值
                s[i] = ((s[i] - '0') ^ (s[i - 1] - '0')) + '0';
        }
        cout << s << endl;
        return 0;
    }
}
int main()
{
    MuguCode::main();
    return 0;
}
```

---

## 作者：Ectau (赞：1)

题目传送门：[P8763 [蓝桥杯 2021 国 ABC] 异或变换](https://www.luogu.com.cn/problem/P8763)

> 小蓝有一个 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$。
>
> 以后每个时刻, 小蓝要对这个 01 串进行一次变换。每次变换的规则相同。 对于 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$, 变换后的 01 串 $s^{\prime}=s_{1}^{\prime} s_{2}^{\prime} s_{3}^{\prime} \cdots s_{n}^{\prime}$ 为：
>
> $$
> \begin{aligned}
> &s_{1}^{\prime}=s_{1} \\
> &s_{i}^{\prime}=s_{i-1} \oplus s_{i}
> \end{aligned}
> $$
> 其中 $a \oplus b$ 表示两个二进制的异或, 当 $a$ 和 $b$ 相同时结果为 $0$ , 当 $a$ 和 $b$ 不同时结果为 $1$ 。
> 
> 请问, 经过 $t$ 次变换后的 01 串是什么?

题解无一例外地注意到了题设中的变换具有循环节，但是如果注意力涣散，注意不到这个性质怎么办？

提供一个注意力涣散的 $O(n^2)$ 解法。

本题中 $n \le 10^4$，$O(n^2)$ 可过。考虑计算每一位对其他位的贡献。

简单打一下表，假设第一次的字符串 $s$ 为 $abcde \dots$，则

第一次后：$a,a\oplus b,b\oplus c,c\oplus d,d\oplus e,\dots$

以下记 $ka$ 为 $k$ 个 $a$ 异或的结果，显然有 
$
ka = \begin{cases}
  0 & 2 \mid  k \\
  a & 2 \nmid k
\end{cases}
$
 。

第二次后：$1a,2a \oplus 1b,1a \oplus 2b \oplus 1c,1b \oplus 2c \oplus 1d,1c \oplus 2d \oplus 1e,\dots$

第三次后：$1a,3a \oplus 1b,3a \oplus 3b \oplus 1c,1a \oplus 3b \oplus 3c \oplus 1d,1b \oplus 3c \oplus 3d \oplus 1e\dots$

$\dots$

在多打几次表之后，我们发现，第 $t$ 次变换后的“系数”恰好是杨辉三角中的第 $t$ 行。（标号从第 $0$ 行起标）

这很好理解。考虑每一项前 $a$ 的系数。

第零次后：$1,0,0,0,0,\dots$

第一次后：$1,1,0,0,0,\dots$

第二次后：$1,2,1,0,0,\dots$

第三次后：$1,3,3,1,0,\dots$

由于每一次，对于 $i>1$，有 $s_i' = s_i \oplus s_{i-1}$，满足杨辉三角的递推式 $C_m^n = C_m^{n-1} + C_{m-1}^{n-1}$，并且初始状态只有一个位置有值，所以可以通过杨辉三角求解本题。

具体的，对于位置 $i$，位置 $j\ (i-j\le t)$ 的贡献就为 $(C_{i-j}^t)s_j$，即 $(C_{i-j}^t \bmod 2)s_j$。

对于组合数的奇偶性，我们可以参照这一题 $O(1)$ 求解：[P1869 愚蠢的组合数](https://www.luogu.com.cn/problem/P1869) 。

题解中写到 $C_k^n \bmod 2 = [n \& k = k]$，我们应用到本题中。（方括号是艾佛森括号，即如果方括号内的条件满足则为 1，不满足则为 0。）

最终代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e4+15;
bool b[N];
char s[N];
int main(){
	int n;
	long long t;
	scanf("%d%lld",&n,&t);
	scanf("%s",s);
	for(int i=0;i<n;i++) b[i]=(s[i]=='1');
	for(int i=0;i<n;i++){
		bool ans=0;
		for(int j=0;j<=i;j++){
			ans ^= b[i-j] & ( (j & (t-j)) == 0 );
		}
		putchar(ans+'0');
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/214355798)

常数小，最后 2 个点都是 36ms，可以通过本题。

---

## 作者：yanzixuan2024 (赞：0)

找规律。

暴力代码模拟一下，会发现当 $x$ 满足 $n \leq 2^x$ 且最小时，$x$ 为一个周期，也就是 每 $x$ 次序列就会回到原来的样子。

所以一开始把 $t$ 替换为 $t \bmod x$，可以减少计算量，时间复杂度从 $O(nt)$ 到了 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long t,x=1;
string s;
int main(){
	cin>>n>>t>>s;
	while(x<n) x<<=1;
	t%=x;
	for(int i=0;i<t;++i){
		for(int j=n-1;j>=1;--j)
            s[j]=(s[j]^'0')^(s[j-1]^'0')^'0';
	}
	cout<<s;
}
```

---

## 作者：elonzhang (赞：0)

# [P8763 [蓝桥杯 2021 国 ABC] 异或变换](https://www.luogu.com.cn/problem/P8763)

## 思路
显而易见这个异或一直进行下去一定是会重复的，然后我们可以达表找规律，发现只要进行最大的 $\le n$ 的最大的二的整数次幂次的操作，就一定会有一个重复的。这一部分可以用 $O(\log n)$ 的时间复杂度暴力枚举，最终总时间复杂度是 $O(n\log n)$。

## ACcode
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
const int N=10001;
int n,t,x=1;
bool a[N];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
//↑以上为初始化↑
//------------------------------
	cin >> n >> t;
	for(int i = 1;i<=n;++i){
		char ch;
		cin >> ch;
		a[i]=(ch=='1');
	}
	while(x<n) x<<=1;
	t%=x;
	for(int i = 1;i<=t;++i){
		for(int j = n;j>1;--j){
			a[j]=a[j-1]^a[j];
		}
	}
	for(int i = 1;i<=n;++i) cout << a[i];
	return 0;
}
```

---


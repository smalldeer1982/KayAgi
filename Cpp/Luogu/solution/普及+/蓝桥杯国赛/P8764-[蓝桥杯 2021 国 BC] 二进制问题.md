# [蓝桥杯 2021 国 BC] 二进制问题

## 题目描述

小蓝最近在学习二进制。他想知道 $1$ 到 $N$ 中有多少个数满足其二进制表示中恰好有 $K$ 个 `1`。你能帮助他吗？

## 说明/提示

对于 $30 \%$ 的评测用例，$1 \leq N \leq 10^{6}, 1 \leq K \leq 10$。

对于 $60 \%$ 的评测用例，$1 \leq N \leq 2 \times 10^{9}, 1 \leq K \leq 30$。

对于所有评测用例，$1 \leq N \leq 10^{18}, 1 \leq K \leq 50$。 

蓝桥杯 2021 国赛 B 组 H 题（C 组 J 题）。

## 样例 #1

### 输入

```
7 2```

### 输出

```
3```

# 题解

## 作者：安安安年 (赞：32)

其它题解都是数位 dp，我来发一篇用组合数的求解。

------------

# 题意
求 $1$ 到 $n$ 中有多少个数满足其二进制表示中恰好有 $k$ 个 $1$。

# 思路
首先我们举一个简单的例子：当二进制下的 $n=10000$， $k=2$ 时，怎么求解答案？

可以发现， $n=10000$ 本身只有一个 $1$，不符合题意，所以现在我们就是要在其它数即 $0000$ 到 $1111$ 找到两个 $1$，答案为 $C_4^2$。

我们再来看一个更一般的例子：当二进制下的 $n=1010100$， $k=3$ 时，怎么求解答案？

同样，我们可以先枚举低六位，在 $000000$ 到 $111111$ 找到三个 $1$；再在 $1000000$ 到 $1001111$ 找到三个 $1$，这其实就相当于枚举低四位，在 $0000$ 到 $1111$ 找到两个 $1$；然后在$1010000$ 到 $1010011$ 找到三个 $1$，这其实就相当于枚举低两位，在 $00$ 到 $11$ 找到一个 $1$，最后再看 $n$ 本身满不满足题意，这样我们就把 $1$ 到 $n$ 中的所有数都枚举了一遍，最终答案为 $C_6^3+C_4^2+C_2^1+1$。

现在我们应该就能发现解决这个问题的一般方法了：从左往右扫 $n$ 的每一位，如果发现该位为 $1$，右边还有 $a$ 位，那么答案贡献为 $C_a^{k-cnt+1}$， $cnt$ 为当前发现为 $1$ 的位数，当然需要满足 $0 \leq k-cnt+1 \leq a$。

# 代码
```cpp
#include <iostream>
#define int long long
using namespace std;
long long C(long long b, long long a) // 计算组合（b在下面，a在上面）
{
    long long sum = 1;
    for (long long i = b, j = 1; j <= a; i--, j++)
        sum = sum * i / j;
    return sum;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    int cnt = 0, ans = 0;
    if (n == k && k == 1)
    {
        ans = 1;
        cout << ans;
        return 0;
    }
    for (int i = 62; i >= 1; --i)
    {
        if (k - cnt + 1 == 0)
            break;
        if ((1ll << i) & n)
        {
            cnt++;
            if (i >= k - cnt + 1)
                ans += C(i, k - cnt + 1);
        }
    }
    if (cnt == k)
        ans++;
    cout << ans;
    return 0;
}
```


---

## 作者：liaoxiyan233 (赞：31)

### 题意
非常明确，求 ${1}$ $\sim$ ${n}$ 在二进制下含有 ${k}$ 个 ${1}$ 的数的个数。
### 思路
此题数据范围 ${n}$ $\leq$ ${1\times10^{18}}$，暴力显然超时 _~~(如果你只想拿 n<=1000000 的 30 分走人当我没说)~~_ 。因此考虑数位DP。

标题点明此题为二进制问题，题面也要求对二进制数进行统计，故我们考虑二进制下的数位DP。


首先预处理出 ${dp[i][j][t]}$，即首位为 ${t}$ 的含有 ${j}$ 个 ${1}$ 的 ${i}$ 位数的个数。


初始化：${dp[1][1][1]=1,dp[1][0][0]=1}$


状态转移方程:


 ${dp[i][j][1]=dp[i-1][j-1][0]+dp[i-1][j-1][1],}$

 ${dp[i][j][0]=dp[i-1][j][0]+dp[i-1][j][1].}$


然后就是统计环节。

首先将 ${n}$ 转化为二进制并用数组 ${num[]}$ 存储，设 ${n}$ 在二进制下的长度为 ${len}$。

显然 ${n}$ 的最高位为 ${1}$，故 ${1}$ $\sim$ ${len-1}$ 位的所有满足要求的数必定包含在其中。

然后求第 ${len}$ 位：从 ${len-1}$ 到 ${1}$ 倒着扫一遍,如果第 ${i}$ 位是  ${0}$ 则跳过，否则加上 ${dp[i][k-t][0]}$，${t}$ 为 ${i+1}$ $\sim$ ${len}$ 位为 ${1}$ 的个数，当 ${t}$ 大于 ${k}$ 时退出循环。

由于此方法统计的是 ${1}$ $\sim$ ${n-1}$，故开始时可将 ${n}$ 加 ${1}$，然后按照上面的方式统计即可。

最后不要忘了开 longlong 喔 qwq。

### 代码


------------

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,k,len;
int num[72];//存二进制下的n 
int dp[72][72][2];//默认初始值为0

inline void Init()//预处理 
{
	dp[1][1][1]=1;
	dp[1][0][0]=1;//初始化 
	for(int i=2;i<=71;i++)//状态转移(从第2位开始) 
	{
		for(int j=0;j<=i;j++)
		{
			if(j>0)dp[i][j][1]=dp[i-1][j-1][0]+dp[i-1][j-1][1];
			dp[i][j][0]=dp[i-1][j][0]+dp[i-1][j][1];
		}
		
	}
}

inline int solve(int len)//求1～(n+1)-1中满足条件的数 
{
	int sum=0;
	for(int i=k;i<len;i++)//统计1～len-1位所有满足的数 
	sum+=dp[i][k][1];
	int t=1;
	for(int i=len-1;i>=1;i--)//统计第len位中满足的数 
	{
		if(!num[i])continue;
		if(t>k)break;//剩下数字含1个数必定大于k,故退出循环。
		sum+=dp[i][k-t][0];
		t++;
	}
	return sum;
}

signed main()
{
	scanf("%lld%lld",&n,&k);
	n++;
	Init();
	while(n)//将n转为2进制 
	{
		num[++len]=n%2;
		n/=2;
	}
	if(k>len) puts("0");//此情况显然不可能有数字满足要求 
	else printf("%lld\n",solve(len));
	return 0;
} 
```


------------
萌新的第一篇题解，求通过(^-^)。

---

## 作者：lottle1212 (赞：20)

# [原题传送门](https://www.luogu.com.cn/problem/P8764)
## Part0：
题目意思十分明确，就是求 $1$ 到 $n$ 的数中在二进制下含有 $k$ 个 $1$ 的数的个数。

## Part1：
由于数据 $1 \leq n \leq 10^{18}$，所以我们很容易想到这是一道数位 DP。

此题让我们求的是二进制状态下 $1$ 的个数为 $k$ 的数，因此，我们可以先把 $n$ 转换成二进制。

接下来对其进行数位 DP。我们首先从最高位做起，通过深搜每一位来枚举所有的数，并统计 $1$ 出现的次数。当所有数位遍历完时，对其进行判断，对符合条件的进行累加。最后，加上记忆化。

千万别忘开 `long long`！

**AC Code：**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, k, f[100][100][2]; int a[100], len;
ll dfs(int w, ll cnt, bool up) {//深搜，up表示前面的数是否占满，用于确定该位数值上限
	if(f[w][cnt][up] ^ -1) return f[w][cnt][up];//记忆化
	if(w > len) return cnt == k;//所有数位遍历完成
	f[w][cnt][up] = 0;
	for(ll i = 0; i <= (up ? a[w] : 1); ++ i)//枚举这个数位上的数
		f[w][cnt][up] += dfs(w + 1, cnt + i, up & i == a[w]);
	return f[w][cnt][up];
}
ll solve(ll x) {
	len = __lg(x); memset(f, -1, sizeof(f));
	for(ll i = 0; i <= len; ++ i) a[i] = (((1ll << i) & x) > 1);//初始化，将x转换为二进制
	reverse(a, a + len + 1);
	return dfs(0, 0, 1); //从首位开始，最初1的个数为0
}
signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> k;
	cout << solve(n);//数位dp
	return 0;
}
```


---

## 作者：Bpds1110 (赞：12)

# [原题传送门](https://www.luogu.com.cn/problem/P8764)
# 题面：
给定一个 $N$ 和 $K$，求 $N$ 以内的数中多少个数的二进制有 $K$ 个 $1$。
# Solution:
数位 DP 水题。因为 $1\leq N\leq10^{18}$，暴力枚举一定会炸，所以考虑用数位 DP。我们先把 $N$ 转换为二进制，存放在数组 $a$ 中，再暴搜每一种可能，如果没有超出原来给定的范围，就再搜下一个点。最后，可以加上记忆化优化。
# Code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=200;
ll n,k,a[N],f[N][2][N];
ll dfs(ll w,ll zt,ll sum)
//w表示当前剩余位数，zt表示当前状态。如果是0表示前面几位并没有满，1则表示前面几位已经满了。
//sum表示到当前位置1的个数 
{
	ll i,ans=0;//ans表示从当前位置的所有可能性总数 
	if(w==0) return (sum==k);//如果每一位都做过，就返回 
	if(f[w][zt][sum]!=-1) return f[w][zt][sum];//如果做过，就返回答案 
	for(i=0;i<2;++i)//每个点有0,1两种可能 
	{
		if(zt&&i>a[w]) break;//如果超出原来的范围就停止 
		ans+=dfs(w-1,zt&&i==a[w],sum+i);//dfs(前一个位置，状态，如果是1则让1的个数增加1)
	}
	return f[w][zt][sum]=ans;//记忆化 
}
ll digit(ll x)
{
	ll cnt=0;//保存转换为二进制的位数 
	memset(f,-1,sizeof(f));//记忆化，清空f数组 
	while(x)//转换二进制 
	{
		a[++cnt]=x%2;
		x/=2;
	}
	return dfs(cnt,1,0);	
}
signed main()
{
	cin>>n>>k;
	cout<<digit(n);//输出N以内有多少个数二进制中有K个1 
}

```

```
提示：不开 long long 见祖宗！
```



---

## 作者：封禁用户 (赞：6)

# 题目大意

求 $1$ 到 $N$ 中有多少个数满足其二进制表示中恰好有 $K$ 个 $1$。

# 题目解法

$1 \le N \le 10^{18} $ ，如果枚举一定会炸，所以用 DP。我们先把 $N$ 转为二进制，再搜每一种可能，如果没有超出范围，就搜下一个点。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k;cin>>n>>k;int cnt=0,num=0;
	for(int i=62;i>=1;--i){
		if(k-cnt+1==0) break;
		if((1ll<<i)&n){
			cnt++;
			if(i>=k-cnt+1){
				long long text=1;
				for(int pre=i,ol=1;ol<=k-cnt+1;pre--,ol++)text=text*pre/ol;
				num+=text;
			}
		}
	}
	if(cnt==k) num++;
	if(n==k==1){
		cout<<1;
		exit(0);
	}
	cout<<num;
	return 0;
}
```
可是结果却：
![](https://cdn.luogu.com.cn/upload/image_hosting/mizhjkmb.png)

这是为什么呢？

不开```long long```见祖宗！

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,k;cin>>n>>k;long long cnt=0,num=0;
	for(long long i=62;i>=1;--i){
		if(k-cnt+1==0) break;
		if((1ll<<i)&n){
			cnt++;
			if(i>=k-cnt+1){
				long long text=1;
				for(long long pre=i,ol=1;ol<=k-cnt+1;pre--,ol++)text=text*pre/ol;
				num+=text;
			}
		}
	}
	if(cnt==k) num++;
	if(n==k==1){
		cout<<1;
		exit(0);
	}
	cout<<num;
	return 0;
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/008wt6h2.png)


---

## 作者：ethan0328 (赞：3)

## 题意

$1$ 到 $N$ 中有多少个数的二进制中有 $K$ 个 $1$。

## 思路

显然用数位 DP。

考虑令 $f_{0/1,i,j}$ 表示一个最高位为 $0$ 或 $1$ 的 $i$ 位二进制数中有 $j$ 个 $1$ 时的情况数。

若最高位为 $0$，则后 $i-1$ 位有 $j$ 个 $1$，所以 $f_{0,i,j}=f_{0,i-1,j}+f_{1,i-1,j}$。

若最高位为 1，则后 $i-1$ 位有 $j-1$ 个 $1$，所以 $f_{1,i,j}=f_{0,i-1,j-1}+f_{1,i-1,j}$。

预处理完后，先把 $n$ 转为二进制，再从最高位向后搜。

如果为 $0$，则直接跳，为 $1$，则答案加上 $f_{0,i,k-x}$，其中 $x$ 为前面已经搜到的数位上 $1$ 的个数。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=70;
int n,k,len,ans,x,n2[N],f[2][N][N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	f[0][1][0]=1;
	f[1][1][1]=1;
	for(int i=2;i<=N;i++)
	{
		for(int j=0;j<=i;j++)
		{
			f[0][i][j]=f[0][i-1][j]+f[1][i-1][j];
			f[1][i][j]=f[1][i-1][j-1]+f[1][i-1][j];
		}
	}
	while(n)
	{
		n2[++len]=n%2;
		n/=2;
	}
	x=0;
	for(int i=len;i;i--)
	{
		if(!n2[i])
		{
			continue;
		}
		ans+=f[0][i][k-x];
		x++;
		if(x>k)
		{
			break;
		}
	}
	cout<<ans;
}
```



---

## 作者：Φρανκ (赞：3)

题意：求满足 $1\le i\le n$ 且 $(i)_2$ 中 $1$ 个数少于 $k$ 个的 $i$ 的个数。

核心思想：数位 DP

解：

首先将 $n$ 二进制转写为 $2^0a_0+2^1a_1+...+2^la_l$ 。（下文中 $i$ 位数表示二进制意义下）

令 $f(i,j,0)$ 表示有 $j$ 个 $1$ 的 $i$ 位数的个数，易得 $f(i,j,0)=C_{i+1}^j$。（组合数定义）

令 $f(i,j,1)$ 表示小于等于 $n$ 的后 $i$ 位的有 $j$ 个 $1$ 的 $i$ 位数的个数，则若 $a_i=0$，$f(i,j,1)=f(i-1.j.1)$（第 $i$ 位只能取 $0$，且之后的位数不能大过 $n$),否则 $f(i,j,1)=f(i-1.j-1.1)+f(i-1,j,0)$（第 $i$ 位取 $0$ 之后可任意取，否则不能过大）。

答案即为 $f(l,k,1)$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long n, k, a[61], b[61][61][2], l=-1;
int main()
{
	cin>>n>>k;
	while(n>0)
	{
		a[++l]=n%2;
		n/=2;
	}//转为二进制
	b[0][0][0]=1;
	b[0][1][0]=1;
	b[0][0][1]=1;
	if(a[0]==1)
		b[0][1][1]=1;//初始化
	for(int i=1; i<=l; i++)
		for(int j=0; j<=i+1; j++)
		{
			b[i][j][0]=b[i-1][j][0]+b[i-1][j-1][0];
			if(a[i]==0)
				b[i][j][1]=b[i-1][j][1];
			else
				b[i][j][1]=b[i-1][j-1][1]+b[i-1][j][0];
		}//转移
	cout<<b[l][k][1];
	return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：2)

数位 DP 板子题。

我们设 $f_{i,j}$ 为当前从左往右枚举到第 $i$ 个数没有枚举时，当前枚举完的 $1$ 的个数为 $j$ 时的能得到的有 $k$ 个 $1$ 的个数。

我们用 `?` 来表示当前点没有填入，假设我们现在从左往右填，当前的状态是 `10101?????`，我们 dfs 完以后，直接存入 $f_{6,3}$ 里，我们要是再枚举到类似 `10011?????` 这种的，我们可以发现，后面问号的可能性是一样的，也就是说，他们得到的答案是一样的，那么我们就可以进行记忆化了。

我们对于给定的 $n$ 按照其他的数位 DP 一样拆成**二进制下**的数，将每一位都存放到 $a_{i}$ 里，也就是说 $a_{i}$ 表示从左往右第 $i$ 个数可以填 $1\sim a_{i}$。

由于这里的情况很少，只有 $0$ 和 $1$，所以可以直接展开循环。

code：

```cpp
#include <bits/stdc++.h>

#define int long long
#define N 100

using namespace std;

int n, k, a[N], f[N][N];//枚举到第i个数当前当前j个1的个数 

inline int dfs(int p, int limit, int cnt)
{
	if( cnt > k ) return 0;
	if(! p) return (cnt == k ? 1 : 0);
	if(! limit && f[p][cnt] != -1) return f[p][cnt];
	int res = 0, flag = (limit ? a[p] : 1);
	res += dfs(p - 1, limit && flag == 0, cnt);
	if(flag) res += dfs(p - 1, limit && flag == 1, cnt + 1);
	if (! limit) f[p][cnt] = res;
	return res;
}

inline int fx(int x)
{
	memset(f, -1, sizeof f);
	int len = 0;
	while(x) a[++ len] = (x & 1), x >>= 1;
	return dfs(len, 1, 0);
}

signed main()
{
	cin >> n >> k;
	cout << fx(n) << endl;
	return 0;
}
```

---

## 作者：Dr_Glitch (赞：1)

### 读题
本题的要求是在 $ 1 \sim {n} $ 的范围内求出含有 $ k $ 个 $ 1 $ 的数的个数。
### 思路
在数字的构造上做文章，考虑采用数位DP。（本人习惯用记忆化的方式写数位DP，正好补充楼上大佬的递推）

首先，对 $ n $ 进行二进制下的数位分离（与直接在十进制下的数位DP类似）；

然后，使用数位DP计算出本题的本题的结果即可；

最后，AC啦，耗时32ms。
### Code
```cpp
#include<bits/stdc++.h>
#define init read()
using namespace std;
typedef long long LL;
const int N=70;
LL n,k;
int f[N][55]; //f数组的两个维度分别为位数和已有的1的个数
int len;
int bit[N];
inline LL read()
{
	LL mmm=0,ff=1;char xx=getchar();
	while((xx<'0'||xx>'9')&&xx!='-')xx=getchar();
	if(xx=='-')ff=-1,xx=getchar();
	while(xx>='0'&&xx<='9')
	mmm=mmm*10+xx-'0',xx=getchar();
	return mmm*ff;
}
LL dfs(int pos,int tot,bool ismax) //经典的数位DP（记忆化实现）
{
	if(pos==0)return tot==k?1:0; //只有到了k个1才能累加
	if(!ismax&&~f[pos][tot])return f[pos][tot];
	int maxn=ismax?bit[pos]:1; //注意：二进制最高位为1
	LL res=0;
	for(int i=0;i<=maxn;i++)
	{
		if(tot==k) //1的个数已经达到k的处理
		{
			res+=dfs(pos-1,tot,ismax&&i==maxn);
			break;
		}
		res+=dfs(pos-1,tot+i,ismax&&i==maxn);
	}
	if(!ismax)f[pos][tot]=res;
	return res;
}
int main()
{
	memset(f,-1,sizeof(f));
	n=init;k=init;LL tmp=n;
	while(tmp) //二进制下的数位拆分
	{
		bit[++len]=tmp&1;
		tmp>>=1;
	}
	printf("%lld\n",dfs(len,0,true));
	return 0;
}
```

---


# [蓝桥杯 2022 国 A] 选素数

## 题目描述

小蓝有一个数 $x$，每次操作小蓝会选择一个小于 $x$ 的素数 $p$，然后在 $x$ 成为 $p$ 的倍数前不断将 $x$ 加 $1$，（如果 $x$ 一开始就是 $p$ 的倍数则 $x$ 不变）。

小乔看到了小蓝进行了 $2$ 次上述操作后得到的结果 $n$，他想知道 $x$ 在一开始是多少。如果有多种可能，他想知道 $x$  一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 $-1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $60\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

蓝桥杯 2022 国赛 A 组 G 题。

## 样例 #1

### 输入

```
22```

### 输出

```
8```

# 题解

## 作者：ChrysanthBlossom (赞：10)

数论好题，练习线性筛~~xxs~~的绝世好题。

### 一次操作的做法

放个结论：当我只有一次操作时，设结果为 $n$ ， $n$ 的最大质因数为 $p$ ，初始值为 $x$ ，则 $x_{min}=n-p+1$ 。

加一不难理解，但是为什么我要减的是最大质因数呢？

~~原因显然。~~

首先，之所以是质因数，是因为~~废话~~我选的是质数且它一定是 $n$ 的因数。

接着，由于我要使值最小，我减的显然得最大，于是就要用**最大质因数**。

因此，当只有一次操作时，我可以直接质因数分解，然后取最大质因数套公式。

时间复杂度 $O(\sqrt{n})$ 

代码不给
### 二次操作的做法

还是看上面那个公式： $x_{min}=n-p+1$ 

不难想到 $x_{max}=n$ 。

那么此时我只要对最小最大之间所有数遍历一遍，每一个找最小值，总的再取最小值即可。

时间复杂度 $O(n\sqrt{n})$ ，显然通不过，故代码不给。

考虑如何筛最大质因数，使复杂度降到 $O(n)$ 。

再来个公式：设两个非 $01$ 自然数为 $n$ 和 $m$ ，一个质数为 $p$ ，满足 $n=m \times p$ ， $f_i$ 表示 $i$ 的最大质因数，那么 $f_n = \max(f_m,p)$ 。

证明也十分简单： $n$ 的质因数显然由 $m$ 的质因数与 $p$ 组成，因此 $n$ 的最大质因数显然等于 $m$ 的质因数与 $p$ 的最大值。

看一看上面那个公式，是不是想到怎么筛了？

没错！~~xxs~~ 线性筛！

线性筛正是用已筛过的数（即上文 $m$ ）乘以已得到的质数（即 $p$ ）来筛其他数（即 $n$ ）!

于是，我们可以就可以用线性筛筛出最大质因数了。

根据线性筛的性质， $p$ 显然是 $n$ 的最小质因数，因此不用再取最大值。

时间复杂度 $O(n)$ ，可以通过此题（话说最优解也就这样了吧）

注意特殊情况需要特判：当 $n$ 是质数（或是 $1$ ）时，最大质因数只能是他自己本身（或没有），而题目要求是 **选一个比 $x$ 小的素数**，不符合题意，直接输出 $-1$ 。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ri register int
#define maxn 1000005
#define inf 0xffffff
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
inline void write(int n){
    if(n<0){
        putchar('-');
        n=-n;
    }
    if(n>9)
        write(n/10);
    putchar(n%10+'0');
}
int n;
int np[maxn];
vector<int>pri;
void init(){
    for(ri i=2;i<=n;i++){
        if(!np[i]){
            pri.push_back(i);
            np[i]=i;
        }
        for(auto j:pri){
            if(i*j>n)break;
            np[i*j]=max(max(np[i*j],j),np[i]);
            if(!(i%j))break;
        }
    }
}
//zy:~~kunkun~~zhiyin(max)(+1)
int zy[maxn];
signed main(){
    n=read();
    init();
    for(ri i=2;i<=n;i++){
        if(np[i]^i)zy[i]=i-np[i]+1;
        else zy[i]=i;
    }
    int mini=inf;
    if(np[n]==n||!np[n])write(-1);
    else{
        for(ri i=n-np[n]+1;i<=n;i++)if(np[i]!=i)mini=min(mini,zy[i]);
        write(mini);
    }
    return 0;
}
```

### 文后赠礼：筛质因数

既然我用可以筛出最大质因数，那我是不是还可以筛质因数？

一个很显然的思路是我在筛的时候把其他质因数都复制过去，这样虽然简单粗暴易懂，但是时间空间复杂度都爆炸，不划算。

但是，用上链表的思想，我是不是可以只表示当前乘上的质数，而用指针指向质数乘上的数的位置？

这样筛下来，由于一个数只能被筛一次，最后会形成 $k$ 棵有根树（其中 $k$ 为小于等于 $n$ 的质数数量），从编号为 $n$ 的节点一直爬到根节点，路径上所有数字之积即为 $n$ ，而路径上的都是 $n$ 的质因数！

于是，我可以实现 $O(n)$ 预处理， $O(q \log n)$ 查询质因数，彻底告别 $O(q \sqrt{n})$ （ $O(q \log n)$ 是最坏情况下的，实际上绝对没有这么大）。

思路放这，代码不给了，有意者~~撕~~私我。

---

## 作者：lemon2021 (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P8795)


------------

## 题目大意
小蓝有一个数字 $x$，要进行如下操作：

首先选出一个**小于等于** $x$ 的**质数** $p$，然后将 $x$ 变成最小的但大于等于 $x$ 的 $p$ 的倍数。也许听上去很绕，举个栗子：当 $x=6$, 则 $p=2,3,5$，所以操作一次 $x$ 将变成 $6,6,10$。

本蒟蒻刚开始还以为这是一道比较简单的数论模拟题，可没想到后面却又来了一个小乔，小乔有一个**操作两次后**的 $x$，他想求出最初小蓝的 $x$ 的**最小**的可能值。原来是让我倒推出小蓝的数字啊！难怪这是绿题啊！完！我都不能用~~暴力+O2优化水过~~了！~~烦死啦~~！这出题人也太欺负我们这些用暴力模拟的蒟蒻了。~~生***气~~！

------------

## 思路
我们先按**正向思路**想，一开始是 $x$，假设操作一次变为 $m$，操作两次变为 $n$。
### • 第一次操作 $x \to m$：
第一次操作选的 $p1$ 需要满足 $m-p1<x \le m$。所以对于一个固定的 $m$，最小的可行 $x$ 为在满足 $p$ 整除 $m$ 时，$m-p+1$ 的**最小值**，即 $x=\min_{p|m}(m-p+1)=m-p_{max}+1$。我们设置一个状态 $f()$, $f(m)=m-p_{max}+1$。

例：当 $m=12$ 时，满足 $p|m$ 的质数 $p=2,3$，则 $p_{max}=3$，则 $x=12-3+1=10$。得：当 $x$ 操作一次为 $12$ 时 $(m=12)$，最小的 $x$ 为 $10$。

------------

### • 第二次操作 $m \to n$：
同理，第二次操作选的 $p2$ 需要满足 $n-p2<m \le n$。我们需要找一个 $f()$ **最小**的 $m$，即答案为 $\min_{p|n}\min_{n-p<m \le n}f(m)$。

例：当 $n=22$ 时，满足 $p|n$ 的质数 $p=2,11$。则 $p_{max}=11$，$n-p=11$，$m=12,14,15,16,18,20,21,22$。则 $x=\min(f(m))=8$ $($ 当 $m=14$ 时 $)$。得：当 $x$ 操作二次为 $22$ 时 $(n=22)$，最小的 $x$ 为 $8$。

------------

## 方法
先使用**线性筛**(也叫欧拉筛)求出 $n$ 内所有合数的**最大质因子**，然后枚举合法状态 $f(m)$ 找出最小的答案即可。如果 $m$ 是质数，则直接跳过，若最终答案从未更新(合法 $m$ 都为质数)，则输出 $-1$。代码复杂度只有 $O(n)$，轻松AC！

------------

## AC代码：
```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1000001;
int n,t;
bool isprime[MAXN];
int prime[MAXN];
int p[MAXN];
int ans=1e9;
int f(int m)
{
	if(isprime[m]==true)
	{
		return 1e9;
	}
	return (m-p[m]+1);
}
void Linear_sieve()//线性筛(欧拉筛)
{
	for(int i=2;i<=n;i++)
	{
		isprime[i]=true;
	}
	for(int i=2;i<=n;i++)
	{
		if(isprime[i])
		{
			t++;
			prime[t]=p[i]=i;
		}
		for(int j=1;j<=t&&i*prime[j]<=n;j++)
		{
			p[i*prime[j]]=max(p[i],prime[j]);
			isprime[i*prime[j]]=false;
			if(i%prime[j]==0)
			{
				break;
			}
		}
	}
}
int main()
{
	cin>>n;
	Linear_sieve();
	for(int i=f(n);i<=n;i++)
	{
		ans=min(ans,f(i));
	}
	if(ans!=1e9)
	{
		cout<<ans<<endl;
	}
	else
	{
		cout<<"-1"<<endl;
	}
	return 0;
}
```


---

## 作者：HHH6666666666 (赞：3)

### 思路：

不难求出只有一次操作时，能够到达已知结果 $n$ 的数 $x$ 的范围：

令 $f_n$ 为 $n$ 的最大质因子，则 $x\in [n-f_n+1, n]$。

证明：

1. 当 $x \in [n - f_n + 1, n]$ 时，选择素数 $p=f_n$ 可将 $x$ 转化为 $n$。

1. 当 $x = n - f_n$ 时，选择 $p=f_n$ 无效，其他素数也无法使 $x'=n$。

1. 当 $x < n - f_n$ 时，可选的素数 $p < f_n$，而选择一个素数 $p$ 进行操作后所得 $x' \in [x,x+p)$， 由此可知恒有 $x' < n$。


于是线性筛求出 $10^6$ 范围内所有合数的最大质因子，枚举第一次转移后的结果即可。线性筛、枚举复杂度均为 $O(n)$。

具体实现见代码：

```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

const int MAXN = 1000010;
const int N = 1000000;

int n;
bool b[MAXN];
int prime[MAXN], idx;
int f[MAXN];
int ans = INT_MAX;

inline int get(int x){
	if (!b[x]) return INT_MAX;
	return x - f[x] + 1;
}

int main(){
	scanf("%d", &n);
	for (int i = 2; i <= N; ++i){
		if (!b[i]) prime[++idx] = f[i] = i;
		for (int j = 1; j <= idx && (ll) i * prime[j] <= N; ++j){
			b[i * prime[j]] = true;
			f[i * prime[j]] = max(f[i], prime[j]);
			if (i % prime[j] == 0) break;
		}
	}
	for (int i = get(n); i <= n; ++i)
		ans = min(ans, get(i));
	if (ans == INT_MAX) puts("-1");
	else printf("%d\n", ans);
	return 0;
}

```




---

## 作者：TianLuen (赞：3)

# P8795 C++ 题解

**UPDATED on 2022-11-18 修正了一处笔误，感谢 @行吟啸九州 指正**

## 题意简述

- 对于一个数 $x$，可以选定一个质数 $p (p<n)$，将 $x$ 转化为 $p\cdot\lceil\dfrac{x}{p}\rceil$。
- 给定 $n(n\le 10^6)$，求最小的整数 $x$，使得进行两次上述操作后，$x$ 能被修改为 $n$。
- 无解输出 $-1$。 

## 题意分析

首先要发现上述操作的一个关键的性质。这是这道题的突破口。

**关键性质：** 对于 $x$ 转化到 $y$，在 $y$ 为相同的合数的情况下，$x$ 的最小值为 $y-z+1$，其中 $z$ 为 $y$ 的最大质因子。


显然，对 $n$ **直接连用**两次关键性质,是**不可行**的，这样不一定能找到最优解。

举例：$14$。连用两次关键性质的过程是 $14 \rightarrow 8\rightarrow 7$，但实际上的答案是 $6$，因为 $6\rightarrow 10\rightarrow 14$ 且没有更优秀的答案。

但是，我们可以枚举 $i\in(n-z,n)$（同样地，$z$ 代表着 $n$ 的最大质因子），对于 $i$ 用关键性质，取个最小值即可。

无解的判断也很简单，如果 $n$ **不是合数**，就无解。

具体做法如下：

1. 筛出所有不超过 $1000$ 的质数。$n$ 最大是 $10^6$，于是任意一个 $n$ 的质因子（除了最大质因子）都不超过 $1000$，而最大质因子可以通过除去其余所有质因子得到，故上界到 $1000$ 即可。
2. 对于 $n$ 进行质因数分解，得到 $n$ 的最大质因子 $z$。
3. 若 $z=n$，则 $n$ 不是合数，无解。
3. 枚举 $i\in (n-z,n)$，对 $i$ 进行质因数分解，如果 $i$ 是合数，答案为 $i$ 减去其最大质因子再加上 $1$，取个最小值；如果 $i$ 是质数，则跳过。

质数筛的时间可以忽略不计，分解质因数的时间复杂度为 $\Theta(\sqrt n)$，枚举 $i$ 的时间复杂度为 $\Theta(\sqrt n)$，故总时间复杂度为 $\Theta(n)$，能过。

## 代码

有些地方写得不够优秀，仅供参考。

```
#include<bits/stdc++.h>
using namespace std;
int pr[1000010],tot;
bool pr2[1000010];
void mp()
{
	pr[0]=2;
	tot=0;
	for(int i=3;i<=1000;i+=2)
	{
		if(!pr2[i])
		{
			pr[++tot]=i;
			for(int j=i+i;j<=1000;j+=i)
				pr2[j]=1;
		}
	}
}
int main()
{
	mp();
	int n;
	scanf("%d",&n);
	int t=n,maxp=-1;
	for(int i=0;pr[i]<=sqrt(t);i++)
	{
		if(t%pr[i]==0)
		{
			t/=pr[i];
			maxp=pr[i];
			i--;
		}
	}
	if(t)
		maxp=t;
	if(maxp==n)
		return printf("-1")&0;
	int ans=2147483647;
	for(int i=n-maxp+1;i<n;i++)
	{
		int maxpp=-1,tt=i;
		for(int j=0;pr[j]<=sqrt(tt);j++)
		{
			if(tt%pr[j]==0)
			{
				tt/=pr[j];
				maxpp=pr[j];
				j--;
			}
		}
		if(tt)
			maxpp=tt;
		if(maxpp==i)
			continue;
		ans=min(ans,i-maxpp+1);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 关键性质的证明：

记 $y$ 的质因子从小到大依次为 $a_1,a_2,\cdots,a_k$，记 $A={a_1,a_2,\cdots,a_k}$。

显然，当 $y$ 不是合数的时候，不存在能转化为 $y$ 的数。

若操作时选定的质数 $p$ 不是 $y$ 的质因子，则 $x$ 不可能转化到 $y$。因此 $x$ 转化到 $y$ 必然是选定 $p\in A$。 

假设 $x\le y-a_k$，任选 $p\in A$，必然存在一个数 $x_0=y-p=p\times(\dfrac{y}{p}-1)\ge y-a_k \ge x$，使得 $x$ 最多可能转化到 $x_0$ ，而无法转化到 $y$。

而当 $x=y-a_k+1$ 的时候，选择 $p=a_k$，由于 $y-x<p$，则 $x$ 转化后必然变为 $y$。

得证。

**注：写得比较仓促，如果哪边写错了，请及时指出。**

---

## 作者：__Emerald__ (赞：2)

首先操作里有一个关键，也是突破口：
- 对于 $x$ 转化到 $y$，在 $y$ 为相同合数的情况下 $x_{\text{min}}=y-z+1$，其中 $z$ 为 $y$ 的最大质因子。

但是，显然对 $n$ 直接连续用两次这个东西是不行的，因为这可能不是最优解。

举例：$14$，连续用两次这个东西得到的答案为 $14\rightarrow8\rightarrow7$，但是实际答案为 $6$，即 $6\rightarrow10\rightarrow14$。

但是我们可以枚举 $i$ 在 $n-z$ 到 $n$ 间，对 $i$ 使用这个关键，取最小值即可。

当然，其实无解的情况的判断也很简单：
- 如果  $n$ 不是合数就无解。

时间复杂度为 $O(n)$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int pr[1000010],tot,n,t,maxp;
bool pr2[1000010];
void init(){
	pr[0] = 2,tot=  0;
	for (int i = 3;i <= 1000;i += 2) if (!pr2[i]){
		pr[++tot] = i;
		for (int j = i + i;j <= 1000;j += i) pr2[j]=1;
	}
}
int main(){
	init();
	cin >> n;
	t = n,maxp = -1;
	for (int i = 0;pr[i] <= sqrt(t);i++) if (t % pr[i] == 0) t /= pr[i],maxp = pr[i],i--;
	if (t) maxp = t;
	if (maxp == n) return printf("-1") & 0;
	int ans = 2147483647;
	for (int i = n - maxp + 1;i < n;i++){
		int maxpp = -1,tt = i;
		for (int j = 0;pr[j] <= sqrt(tt);j++) if (tt % pr[j] == 0) tt /= pr[j],maxpp = pr[j],j--;
		if (tt) maxpp = tt;
		if (maxpp == i)
			continue;
		ans = min(ans,i - maxpp + 1);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Waving (赞：2)

  Java 版的题解 
这个题主要考察**质因数分解**和**质数判断**

首先质数的判断，这个太常见了，这里就不多赘述了。
```java
 private static boolean isPrime(int n){
        if (n<2)return false;
        if (n==2||n==3)return true;
        if (n%6!=1&&n%6!=5)return false;
        for (int i = 5; i*i<= n ; i+=6) {
            if (n%i==0||n%(i+2)==0){
                return false;
            }
        }
        return true;
    }
```
然后是质因数分解，这里用了 List 集合去装分解出来的质数
```java
 private static List<Integer> prime(int n){
        List<Integer> ans  = new LinkedList<>();
        for(int i = 2; i <= n/i ; i++){//判断条件用n/i，以防i*i<=n发生溢出
            int a = 0;//每次循环都要清零
            while(n % i == 0){
                n /= i;
                a++;
            }
            if(a > 0)
                ans.add(i);
        }
        //若该数是质数，那么应该将自身(n)也加入
        if(n > 1) ans.add(n);
        return ans;
    }
```
最后就是根据题意进行模拟，$a_0$ $\to$ $a_1$ $\to$ $a_2$  (依次进行第一次操作、第二次操作）。直接上代码。
```java

import java.util.*;//导入万能类 当然也不是很万能
public class Main {
    static List<Integer> oList = new LinkedList<>();//需要用到的集合
    public static void main(String[] args) {
    //标准输入 一个n
       Scanner sc  = new Scanner(System.in);
       int n = sc.nextInt();
       
        if (isPrime(n)){
        //如果输入数为质数，那么打印-1。因为我们的n应该是质数的倍数，且必须至少为2倍（题目中说了选择一个小于x的素数p，所以至少是2倍）。
            System.out.println("-1");
        }else {
            oList = prime(n);
            //对其质因数分解,并用集合装好
            int minstart = Integer.MAX_VALUE;//定义所求的最小开始的a0,赋值为Integer最大值，为了后面获取最小值
            for (int i = 0; i < oList.size(); i++) {
            //遍历质因数集合
                int last_left = n-oList.get(i);
                //下面对第一次操作后可能的数组遍历
                for (int j = last_left+1; j <= n ; j++) {
                //这里的范围为什么是从last_left+1到n
                //假设第二次操作选择的是oList.get(i)作为质数，那么第二次操作前的数(a1)不会小于n-oList.get(i)
                //上次操作前的数字（a1）必然在左边界加1和n之间。（为什么是n？因为n可能本身就是某个质数的倍数，然后这次操作又选了该质数，则n不变）
                    if (isPrime(j)){
                        continue;
                        //跟上面一样，不可能是质数。
                    }
                    List<Integer> temp = prime(j);//继续对上个数进行质因数分解
                    int max = Collections.max(temp);
                    //找出最大的质因数作为第一次操作选择的质数，这样能使起始数字(即a0)尽可能小
                    minstart = Math.min(j-max+1,minstart);//更新维护最小数字
                   
                }
            }
            if (minstart==Integer.MAX_VALUE){
                System.out.println("-1");
            }else {
                System.out.println(minstart);
            }
        }

    }
    //质数的判断
    private static boolean isPrime(int n){
        if (n<2)return false;
        if (n==2||n==3)return true;
        if (n%6!=1&&n%6!=5)return false;
        for (int i = 5; i*i<= n ; i+=6) {
            if (n%i==0||n%(i+2)==0){
                return false;
            }
        }
        return true;
    }
    //对n进行质因数分解
    private static List<Integer> prime(int n){
        List<Integer> ans  = new LinkedList<>();
        for(int i = 2; i <= n/i ; i++){//判断条件用n/i，以防i*i<=n发生溢出
            int a = 0;//每次循环都要清零
            while(n % i == 0){
                n /= i;
                a++;
            }
            if(a > 0)
                ans.add(i);
        }
        //若该数是质数，那么应该将自身(n)也加入
        if(n > 1) ans.add(n);
        return ans;
    }
}

```
























---

## 作者：zhangbo1000 (赞：0)

update 2024.3.21 重新提交以去除旧博客分类。

~~蒟蒻也想写丰富的开头，可惜没有能力。~~

[P8795 蓝桥杯 2022 国 A 选素数 题目传送门](https://www.luogu.com.cn/problem/P8795)

## 算法分析

设 $f_i$ 表示 $i$ 的最大质因数，由题意可知若 $y$ 可变为 $i$ 则 $y \ge i-f_i+1$，因为当 $y<i-f_i+1$ 时：

*  若选择的质数 $p=f_i$，则 $y$ 将变为 $i-f_i$。

*  若选择的质数 $p<f_i$，则由 $f_i$ 的定义可知 $y$ 变为的数最大为 $i-p\ge i-f_i+1$。

所以 $n$ 一次操作前不小于 $n-f_n+1$。那么我们可以直接枚举所有的 $i\in [n-f_n+1,n)$，答案就是对于所有的合数 $i,i-f_i+1$ 的最大值。

至于怎么求出 $f_i$，也很简单。

对于一个数 $n$：

*  若 $n$ 为质数，明显 $f_n=n$（就这一个质因数还能是几啊）。

*  若 $n$ 为合数，应存在一个质数 $i$ 使 $i\mid n$（即 $i$ 为 $n$ 的因数），且必定会存在一个数 $j$ 使 $i \times j=n$，考虑到 $j$ 可能是合数，$f_n=\max(i,f_j)$。

接下来是无解的情况，其实很简单，$n$ 是质数或 $n<2$ 就无解，因为由上述分析可知合数且只有合数能通过某个数变来。

等等，$n$ 为合数而所有 $i\in [n-f_n+1,n)$ 都是质数不也无解吗？

事实上，这种情况并不会出现，证明如下：

*  当 $n=4$ 时有解，为 $3$。

*  当 $n>4$ 时，则 $f_n$ 最小为 $2$，则 $[n-f_n+1,n)$ 中必有非 $2$ 的偶数，而非 $2$ 的偶数都是合数。

## 复杂度分析

* 需要数组存下所用 $f_i$ 和线性筛时需要的 $n$ 以内的质数，空间复杂度 $\Theta(n)$。

* 需要枚举所有 $i\in [n-f_i+1,n)$ 和线性筛质数同时预处理 $f_i$，时间复杂度 $\Theta(n)$。

## 代码和说明

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
using namespace std;
#define N 1000000
int f[N+1];
int pri[N>>3],now;
void shai(int n){
    for(register int i=2;i<=n;i++){
        if(!f[i])
            pri[now++]=i,f[i]=i;
        for(register int j=0;j<now&&i*pri[j]<=n;j++){
            f[pri[j]*i]=max(f[i],pri[j]);
            if(!(i%pri[j]))break;
        }
    }
}
int main(){
    int n,ans=0x7fffffff;
    cin>>n;
    shai(n);
    if(f[n]==n||!f[n]){
        cout<<-1<<'\n';
        return 0;
    }
    int tmp=n-f[n]+1;
    for(register int j=n;j>=tmp;j--){
        if(f[j]!=j){
            ans=min(ans,j-f[j]+1);
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```

说明：

* 这里质数数组开了 $n/8$ 大小，实测够用，考试时没把握应开 $n$，保证没问题的。

* ```register``` 在 c++14 被弃用，c++17 被移除，可稍微加快运行速度。

* 答案变量（$ans$）初值为 ```int``` 型最大值，请注意这种写法不能应对答案修改需做加法的情况，不要什么题拿过来就用。

* 注意数据范围和常数因子对程序运行的影响，什么题上来就

```#define int long long```

会玩脱的拉。（TLE，MLE 等着你呢 $\sim\sim$。）

update 2022.11.4：

* 微调代码，使变量名更贴近分析，便于理解。

* 增加了少量说明。

* 给之前落下的地方加了 Latex。

update 2022.11.10：

* 修正了写错的证明。

---

## 作者：whx2009 (赞：0)

## 本题思路：
这道题我们用到的知识点只有线性筛，还算简单。

我们可以先跑一遍线性筛，把 $n$ 以内的质数全部筛出来，顺便把每一个数之下的最大质数给找出来。

然后我们就可以有一个贪心的思路了，我们先倒着想，只要每一个操作都选的是他之下的最大质数那么结果肯定最大。那么我们就可以把中间的数的范围给找出来了，就是 $n$ 之下的最大质数到 $n$。这样我们就可以直接写过了。

不行的情况那就只有 $n$ 是一个大质数的时候了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int zs[1000001],cnt,pd[1000001],a[1000001],ans[1000001];
void xs(int n)
{
	for(int i=2;i<=n;i++)
	{
		if(pd[i]==0) {zs[++cnt]=i;a[i]=1;ans[i]=i;} 
		for(int j=1;j<=cnt && zs[j]*i<=n;j++)
		{
			ans[zs[j]*i]=max(zs[j],ans[i]);
			pd[zs[j]*i]=1;
			if(i%zs[j]==0) break;
		}
	}
}
int gg(int n)
{
	if(a[n]) return 1000000001;
	return n-ans[n]+1;
}
int main()
{
	int n,ans1=1000000001;
	cin>>n;
	xs(n);
	if(a[n]==1) return cout<<"-1",0;
	for(int i=gg(n);i<=n;i++)
	{
		ans1=min(ans1,gg(i));
	}
	cout<<ans1;
	return 0;
}
```

---

## 作者：千早爱音 (赞：0)

发现有篇题解的复杂度分析错了，所以补一个。

首先考虑如果只进行一次操作怎么做。

如果选取的质数是 $ a $，则显然初始值为 $ n-a+1 $，那么为了使得 $ n-a+1 $ 最小，我们应该选取最大的 $ a $，即为 $ n $ 的最大质因子。

但是连续两次贪心不一定最优，原理其他题解已经提及过。于是考虑暴力枚举 $ [n-a+1,n] $ 里的数，对每个数计算一遍答案之后取较小值。

考虑到 $ a $ 最差是 $ \mathcal{O}(n) $ 级别，暴力质因数分解的复杂度是 $ \mathcal{O}(n^\frac{3}{2}) $，加上线性筛优化之后是 $ \mathcal{O}(\frac{n^\frac{3}{2}}{\ln{n}}) $，还是不够优秀。所以最后一篇题解分析的复杂度实际上是错的。

显然可以线性筛筛出最大质因子，但是这个我不会做，于是考虑对质因子分解优化，直接暴力 Pollard-rho 分解出所有质因子之后取最大值即可，单次操作的复杂度为 $ \mathcal{O}(n^\frac{1}{4}) $，于是总时间复杂度 $ \mathcal{O}(n^\frac{5}{4}) $，可以通过。

[Pollard-rho 模板代码](https://www.luogu.com.cn/paste/cpc2see7)，因为太长不会在最终代码里展示。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
/*模板*/
int main()
{
	uint64_t n;
	cin>>n;
	uint64_t maxn=0;
    auto map = OY::Pollard_Rho::decomposite(n);
    for(auto x:map)
    maxn=max(maxn,x.prime);
	if(maxn==n)
	return !puts("-1");
	uint64_t ans=2e9;
	for(uint64_t i=n-maxn+1;i<n;i++)
	{
		uint64_t maxn=0;
        auto map = OY::Pollard_Rho::decomposite(i);
        for(auto x:map)
        maxn=max(maxn,x.prime);
		if(maxn==i)
			continue;
		ans=min(ans,i-maxn+1);
	}
	cout<<ans;
}
```


---

## 作者：ztntonny (赞：0)

补一下楼上的方法理解证明和代码。

先来~~最诱人的~~：超级短还超级快（$30ms$）的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x , ans = 1e13;
bool jug( ll x )
{
	if ( x == 1 || x == 0 )	return 0;
	for ( int i = 2; i * i <= x ; i++ )
		if ( x % i == 0 )	return 0;
	return 1;
}
void subdosth( ll p )
{
	for ( ll i = ( p + 1 ) / 2; i < p; i++ )
	if ( jug( i ) )	{	ans = min( ans , i + 1 );	break;}
}
void dosth( ll pr )
{
	if ( jug( pr ) )	subdosth( ( x / pr - 1 ) * pr + 1 );
	if ( jug( x / pr ) )	subdosth( ( pr - 1 ) * x / pr + 1 );
}
int main()
{
	cin >> x;
	for ( int i = 2; i * i <= x; i++ )	if ( x % i == 0 )	dosth( i ) , dosth( x / i );
	if ( ans != (ll)1e13 )	cout << ans << endl;
	else	cout << -1 << endl;
	return 0;
}
```


## 理解+证明

$\mathcal{Part1}$：分解质因数。为什么？答案很显然，题目中说要最后成为 $p_1$ 的倍数，也就是说 $p_1\mid n_1$，于是可以通过分解质因数枚举 $p_1$。具体是枚举因子，然后判定是不是质数，可以用最简单粗暴的都根本不会TLE。

```cpp
bool jug( ll x )//判断质数
{
	if ( x == 1 || x == 0 )	return 0;
	for ( int i = 2; i * i <= x ; i++ )
		if ( x % i == 0 )	return 0;
	return 1;
}

for ( int i = 2; i * i <= x; i++ )//枚举模块
	if ( x % i == 0 )
		dosth( i ) , dosth( x / i );
```

那么实际就应该是 $n_2=[((n_1-1)\div p_1)\times p_1+1,n_1]$。

$\mathcal{Part2}$：对于每一个 $n_2$，显然 $n\div p_2=2$ 下 $n_2$ 最小，考虑 $p_2$ 最小才能使 $n_2$ 最小，从 $(n_2-1)\div 2)$ 开始向上枚举直到找到大于其且小于 $n_2$ 的质数就是 $p_2$ 最小值，那么初始值 $n_3$ 对应就是 $p_2+1$，更新输出并 $break$。

```cpp
void subdosth( ll p )//考虑p_2
{
	for ( ll i = ( p + 1 ) / 2; i < p; i++ )
	if ( jug( i ) )	{	ans = min( ans , i + 1 );	break;}
}
void dosth( ll pr )//考虑n_2
{
	if ( jug( pr ) )	subdosth( ( x / pr - 1 ) * pr + 1 );
	if ( jug( x / pr ) )	subdosth( ( pr - 1 ) * x / pr + 1 );
}
```

---

## 作者：氧少Kevin (赞：0)

## 洛谷 8795(CF923A) - 蓝桥杯 22 国 A - 选素数

https://www.luogu.com.cn/problem/P8795
https://codeforces.com/problemset/problem/923/A

难度：*1700


### 题意
给出一个数字 $x(x\leq 10^6)$，进行如下操作两次：

- 选一个质数 $p$ 满足 $p\leq x$，然后将 $x$ 变为最小的、比 $x$ 大的、是 $p$ 的倍数的数字。

现在给出操作两次后的 $x$，求最初 $x$ 的最小的可能值。

### 思路
设 $x=$ 最初的数字，$y=$ 操作第一次后的数字，$z=$ 最终的数字。

**考虑 $y$ 变到 $z$ 的过程**

选的数字要求是质数，并且又能被 $z$ 整除。

显然，选的数字一定是 $z$ 的质因子。

所以，$y\in [z-p_{\max}+1,z]$，$p_{\max}$ 是 $z$ 的最大质因子。

能发现，只要 $y$ 落在此区间内，$y$ 一定能变成 $z$。


**考虑 $x$ 变到 $y$ 的过程**

显然，选的数字一定是 $y$ 的质因子。

所以，答案就是：$x=y-p_{\max}+1$，$p_{\max}$ 是 $y$ 的最大质因子。

---


# [蓝桥杯 2022 国 B] 费用报销

## 题目描述

小明在出差结束后返回了公司所在的城市，在填写差旅报销申请时，粗心的小明发现自己弄丢了出差过程中的票据。

为了弥补小明的损失，公司同意小明用别的票据进行报销，但是公司财务要求小明提交的票据中任意两张的日期差不小于 $K$ 天，且总金额不得超过实际差旅费用 $M$。

比如财务要求 $K=7$ 时，若小明提交了一张 1 月 8 日的票据，小明就不能提交 1 月 2 日至 1 月 14 日之间的其他票据，1 月 1 日及之前和 1 月 15 日及之后的票据则可以提交。

公司的同事们一起给小明凑了 $N$ 张票据，小明现在想要请你帮他整理一下，从中选取出符合财务要求的票据, 并使总金额尽可能接近 $M$ 。

需要注意，由于这些票据都是同一年的，因此 12 月底的票据不会影响到 1 月初票据的提交。这一年不是闰年。

## 说明/提示

**【样例说明】**

选择 1 月 3 日和 1 月 6 日的票据

**【评测用例规模与约定】**

对于 $100 \%$ 的评测用例, $1 \leq N \leq 1000,1 \leq M \leq 5000,1 \leq K \leq 50,1 \leq m_{i} \leq$ $12,1 \leq d_{i} \leq 31,1 \leq v_{i} \leq 400$

日期保证合法。 


蓝桥杯 2022 国赛 B 组 F 题。

## 样例 #1

### 输入

```
4 16 3
1 1 1
1 3 2
1 4 4
1 6 8```

### 输出

```
10```

# 题解

## 作者：_lqs_ (赞：29)

更新于 2025.6.8：经评论区用户指出，这个两年前的题解存在许多问题，现予以修复。且两年前并未发现这个 dfs 优化没有正确性，现已删除。同时更新了部分内容。

---

其实我们可以发现这个题很像背包问题，那么就可以开一个 $f$ 数组，其中 $f_{i,j}$ 表示前 $i$ 个票据占用 $j$ 的背包的最大价值。

我们先预处理每一个票据离它最近的且合法的票据的位置，这个过程是容易 $\mathcal {O}(n^2)$ 处理的，我们把它存到 $lst$ 数组中去。

对于每一个票据也是有选或不选两种选择，那么我们可以得出以下方程：
$$f_{i,j}=\max(f_{i-1,j},f_{lst_{i},j-d_{i}.v}+d_{i}.v)$$

最后我们输出 $f_{n,m}$ 即可，综合时间复杂度为 $\mathcal {O}(nm)$。

对于用户指出的一组数据：

```cpp
9 647 10
1 10 255
3 17 13
4 19 106
9 7 140
10 3 196
10 6 393
11 2 219
11 13 319
11 30 224
```
正确输出是 ```644```。

dp 代码跑出了错误答案，原因在于，枚举背包体积的一维并没有转移完，对于 $j<v$ 的部分仍需要继承 $i-1$ 的所有答案，因此把背包体积枚举到 $0$ 即可。代码已更新。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,ans,k1,sum;
struct ren{
	int m,d,v,t;
}d[1005];
int f[1005][5005],s[1005],lst[1005];
bool cmp(ren a,ren b){
	return a.t<b.t;
} 
int dx[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int main(){
	scanf("%d%d%d",&n,&m,&k1);
	for(i=2;i<=12;i++) s[i]=s[i-1]+dx[i-1];
	for(i=1;i<=n;i++){
		scanf("%d%d%d",&d[i].m,&d[i].d,&d[i].v);
		d[i].t=s[d[i].m]+d[i].d;
	} 
	sort(d+1,d+1+n,cmp);
	for(i=1;i<=n;i++){
		for(j=0;j<i;j++){
			if(d[i].t-d[j].t>=k1) lst[i]=j;//预处理离第i个票据最近的票据的位置
		}
	}
	for(i=1;i<=n;i++){
		for(j=m;j>=0;j--){
			f[i][j]=f[i-1][j];
			if(j>=d[i].v) f[i][j]=max(f[i][j],f[lst[i]][j-d[i].v]+d[i].v);
		}
	}
	printf("%d",f[n][m]);
	return 0;
}
```

当然，如果你一时脑抽没有想到预处理最近转移点，然后继承前面所有答案的话，你依然可以数据结构优化，前提是你依旧需要找出最近转移点。

那么你的所有转移点就是 $1 \sim lst[i]$，转移的体积是固定的。因此你对每个体积值开一棵线段树，下标存的是第 $i$ 位上的 dp 值，那么你每次查询就查 $j-v$ 这一棵上 $[1,lst[i]]$ 这个区间的答案的最大值即可。

复杂度是 $O(nm \log n)$ 的，看上去很蠢。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 5005
#define M 1005
int n,m,i,j,ans,k1,sum;
struct ren{
	int m,d,v,t;
}d[M];
int f[M][N],s[M],lst[M];
bool cmp(ren a,ren b){
	return a.t<b.t;
} 
int dx[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
struct seg{
	int d[M<<2];
	void upd(int l,int r,int p,int k,int c){
		if(l==r){
			d[p]=c;
			return;
		}
		int mid=(l+r)>>1;
		if(mid>=k) upd(l,mid,p<<1,k,c);
		else upd(mid+1,r,p<<1|1,k,c);
		d[p]=max(d[p<<1],d[p<<1|1]);
	}
	int qry(int l,int r,int p,int s,int t){
		if(s>t) return 0; 
		if(l>=s && r<=t) return d[p];
		int mid=(l+r)>>1,res=0;
		if(mid>=s) res=max(res,qry(l,mid,p<<1,s,t));
		if(mid<t) res=max(res,qry(mid+1,r,p<<1|1,s,t));
		return res;
	}
}tr[N];
int main(){
	scanf("%d%d%d",&n,&m,&k1);
	for(i=2;i<=12;i++) s[i]=s[i-1]+dx[i-1];
	for(i=1;i<=n;i++){
		scanf("%d%d%d",&d[i].m,&d[i].d,&d[i].v);
		d[i].t=s[d[i].m]+d[i].d;
	} 
	sort(d+1,d+1+n,cmp);
	for(i=1;i<=n;i++){
		for(j=0;j<i;j++){
			if(d[i].t-d[j].t>=k1) lst[i]=j;
		}
	}
	for(i=1;i<=n;i++){
		for(j=m;j>=0;j--){
			f[i][j]=f[i-1][j];
			if(j>=d[i].v) f[i][j]=max(f[i][j],d[i].v); 
			if(j>d[i].v) f[i][j]=max(f[i][j],tr[j-d[i].v].qry(1,n,1,1,lst[i])+d[i].v);
			tr[j].upd(1,n,1,i,f[i][j]);
		}
	}
	printf("%d",f[n][m]);
	return 0;
}
```

---

## 作者：KawaragiMomoka (赞：14)

# Solution：动态规划

这道题看起来就很背包。由于每个票据只选一次，我们可以按照 01 背包的思路来解决这个问题。

## 第一个问题：日期

题目给出的日期是以**几月几号**的形式给出的，所以我们要把月份转换成天数，统一按天来处理。

数据可以直接算出来：

```cpp
const int month[13] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
```

当月为 $m$，日为 $d$ 时，那么日期就是 $month_{m-1}+d$（为什么 $m$ 要减一？你在 1 月 14 号的时候，1 月只过去了 14 天）。

## 第二个问题：小明提交的票据中任意两张的日期差不小于  *K*  天

这个问题是做这道题的关键，但并不难。

首先我们把所有的票据按时间顺序排个序，然后对于每个票据，我们向前寻找第一个可以使用的票据，并把它记录下来。

定义 $last[i] = j$ 表示第 $i$ 个票据之前第一个可以使用的票据是第 $j$ 个票据。

代码很好写。

```cpp
sort(bills + 1, bills + 1 + n, compare); // 按时间排序
for (int i = 1; i <= n; i++) {
    for (int j = i - 1; j >= 0; j--) {
        if (bills[i].date - bills[j].date >= k) {
            last[i] = j;
            break;
        }
    }
}
```

## 最后：动态规划

我们定义状态 $f_{i,\:j}$ 为前 $i$ 个物品在容量为 $j$ 的背包中所能占的最大值。

由第二个问题里的 $last$ 数组，我们不难得出转移方程：
$$
f_{i,j} = \max(f_{i-1,j},f_{last_i,j-value_i}+value_i)
$$
$f_{i-1,j}$ 和 $f_{last_i,j-value_i}+value_i$ 分别代表选或者不选：

1. 不选第 $i$ 件：直接继承 $i-1$ 的状态。
2. 选择第 $i$ 件：由于前面一个或者几个票据我们都不一定选择，这个时候 $last$ 数组就发挥作用了，我们直接通过 $last_i$ 来转移。

## 代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

struct Bill {
    int date, value;
};

const int maxn = 1005;
const int maxm = 5005;
const int month[13] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
int n, m, k;
int f[maxn][maxm];
int last[maxn];
Bill bills[maxn];

inline bool compare(const Bill &b1, const Bill &b2) {
    return b1.date < b2.date;
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++) {
        int mon, d, v;
        scanf("%d%d%d", &mon, &d, &v);
        bills[i].date = month[mon - 1] + d;
        bills[i].value = v;
    }
    sort(bills + 1, bills + 1 + n, compare); // 按时间排序
    for (int i = 1; i <= n; i++) {
        for (int j = i - 1; j >= 0; j--) {
            if (bills[i].date - bills[j].date >= k) {
                last[i] = j;
                break;
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= bills[i].value; j--) {
            f[i][j] = max(f[i - 1][j], f[last[i]][j - bills[i].value] + bills[i].value);
        }
    }
    printf("%d", f[n][m]);
    return 0;
}

```



## 复杂度

处理 $last$ 的复杂度为 $O(n^2)$，最后的 dp 复杂度为 $O(nm)$。

~~第一次写题解，手比较生，退回好几遍了，希望这次没有问题了。~~

---

## 作者：行吟啸九州 (赞：10)

不考虑 $K$ 的限制，这个题是一个非常板子的背包问题。

先将所有的票据按照时间排序，以下所说的第 $i$ 个票据含义为按时间升序排序的排名为 $i$ 的票据。

如果我们暴力地考虑 $K$ 的影响，定义 $dp[i][j][k] = 0 / 1$ 表示前 $i$ 个票据，上一个使用的票据是第 $j$ 个票据，是否能使所用票据总金额为 $k$。这个 dp 的转移是容易的，复杂度 $O(N^2M)$。

由于 $N$ 很小，我们可以简单的求得对于每个票据，前一个可以和这个票据一起使用的票据，这个过程 $O(N^2)$。如果把 $N$ 改大一点，二分一下也行。我们定义 $f[i]$ 为时间最晚的可以和第 $i$ 个票据一起使用的票据的编号。

定义 $a[i].v$ 为第 $i$ 个票据的金额，$dp[i][j] = 0 / 1$ 表示前 $i$ 个票据，是否能使所用票据总金额为 $j$。考虑转移，如果不选第 $i$ 个票据，有 $dp[i][j] = dp[i - 1][j]$，如果选第 $i$ 个票据，有 $dp[i][j] = dp[f[i]][j-a[i].v]$，则有 $dp[i][j] = \max(dp[i - 1][j], dp[f[i]][j-a[i].v])$，复杂度 $O(NM)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1005
#define M 5005
#define int long long
#define Fol(i, j, n) for(int i = j ; i >= n ; --i)
#define For(i, j, n) for(int i = j ; i <= n ; ++i)
int h, n, m, k, y, ans, f[N], s[N], dp[N][M];
struct node{ int d, v; }a[N];
inline bool cmp(node x, node y){ return x.d < y.d; }

inline int setup(){
	s[1] = 0;
	s[2] = 31;
	s[3] = 59;
	s[4] = 90;
	s[5] = 120;
	s[6] = 151;
	s[7] = 181;
	s[8] = 212;
	s[9] = 243;
	s[10] = 273;
	s[11] = 304;
	s[12] = 334;
}
inline int date(int month, int day){ return s[month] + day; }

signed main(){
	setup();
	scanf("%lld %lld %lld", &n, &m, &k);
	For(i, 1, n) scanf("%lld %lld %lld", &h, &y, &a[i].v), a[i].d = date(h, y);
	sort(a + 1, a + n + 1, cmp);
	a[0].d = -1000000;
	For(i, 1, n){
		Fol(j, i, 0){
			if(a[i].d - a[j].d >= k){
				f[i] = j;
				break;
			}
		}
	}
	dp[0][0] = 1;
	For(i, 1, n){
		For(j, 0, m) dp[i][j] = dp[i - 1][j];
		For(j, a[i].v, m) dp[i][j] = max(dp[i][j], dp[f[i]][j - a[i].v]);
	}
	For(i, 0, m) ans = max(ans, i * dp[n][i]);
	printf("%lld", ans);
	return 0;
}

---

## 作者：xxseven (赞：4)

目前题解区两个 bitset 做法的复杂度都是 $O(\frac{n^2m}{w})$，我来讲解一个 $O(\frac{nm}{w})$ 的做法，目前最优解第四。

我们令 $b_{i,j}$ 表示前 $i$ 个物品中，必须选第 $i$ 个物品，能否获得 $j$ 的价值。

在满足转移条件，即两个物品时间差大于 $k$ 时，转移用 bitset 可以写成 `b[i]|=b[j]|(b[j]<<v[i])`，其中 $v_i$ 为第 $i$ 件物品的价值。

那么我们按时间对物品排序，发现对于任意一个物品，能转移到它的物品为序列的一个前缀。根据按位或运算的性质，将前缀的所有 bitset 先按位或起来，不影响答案正确性。

我们可以使用前缀或，或者直接利用时间的单调性，在转移过程中顺便双指针解决。

每次转移只用进行一次 bitset 的或操作，时间复杂度为 $O(\frac{nm}{w})$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=365;
int d[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int n,m,k,t[N],v[N],a[N];
bitset<5005> b[N],now;
bool cmp(int x,int y){//按照日期进行排序
	return t[x]<t[y];
}
int main(){
	for(int i=1;i<=12;++i) d[i]+=d[i-1];
	cin>>n>>m>>k;
	for(int x,y,i=1;i<=n;++i){
		cin>>x>>y>>v[i]; a[i]=i;
		t[i]=d[x-1]+y;//将日期全部转换为天数
	}
	now.set(0); t[n+1]=1e9; a[n+1]=n+1;
	sort(a+1,a+n+1,cmp);
	for(int pos=1,i,j=1;j<=n+1;++j){
		i=a[j];
		while(t[a[pos]]+k<=t[i]) {
			now|=b[a[pos]]; pos++;
		}//双指针求出当前需要的前缀或
		b[i]=now|(now<<v[i]);
	}
    //设置n+1为哨兵节点，那么转移n+1时一定用到了1到n的前缀或，直接寻找答案并输出即可
	for(int i=m;i>=0;--i){
		if(now.test(i)) {
			cout<<i; return 0;
		}
	} 
	return 0;
}

```

希望这篇题解能够帮到你！

---

## 作者：__ex (赞：4)

本题解介绍一种没有说到的 $O(\dfrac{n^2m}{w})$ 的科技做法。

参考背包，设置状态 $dp_{i,j}\in\{0,1\}$ 代表必选物品 $i$，在前 $i$ 个物品中能否达到 $j$ 元。

就得到了一种 $O(n^2m)$ 的做法：

- 对每个物品按时间轴排序。
- 枚举每个物品，用类似单调队列的东西维护出该物品可以被哪些更新（可以换成二分）。
- 枚举可以更新当前物品的物品，然后将它的 $m$ 个状态全部更新至该物品。
- 统计答案，找到最大的 $i$ 使得 $dp_{j,i}=1$ ，$i$ 即最后答案。

然后发现在枚举 $o$ 的 $m$ 个状态时

`dp[i][j]|=dp[o][j-a[i].v]`

`a[i].v` 是定值，且 $dp_{i,j}\in\{0,1\}$，可以用 bitset 优化。

不用枚举 $m$ 个状态，直接 `dp[i]|=dp[o]<<a[i].v` 即可。

时间复杂度 $O(\dfrac{n^2m}{w})$，跑不满，可过。

**code**

注释部分为 $O(n^2m)$。

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
template<typename T>inline T read(){
	T a=0;bool s=0;
	char ch=getchar();
	while(ch>'9' || ch<'0'){
		if(ch=='-')s^=1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		a=(a<<3)+(a<<1)+(ch^48);
		ch=getchar();
	}
	return s?-a:a;
}
const int mn=5e3+10;
bitset<mn> dp[mn];
int n,m,k,l=1,r,mth[15]={0,31,28,31,30,31,30,31,31,30,31,30,31};
struct L{int m,d,v;}a[mn];
L ddq[mn];
inline int calc(L a,L b){
	int ans=0;
	for(int i=a.m;i<b.m;i++)
		ans+=mth[i];
	ans-=a.d;ans+=b.d;
	return ans;
}
inline bool cmp(L a,L b){
	if(a.m<b.m)return 1;
	if(a.m>b.m)return 0;
	return a.d<b.d;
}
int main(){
	n=read<int>();m=read<int>();k=read<int>();
	for(int i=1;i<=n;i++){
		int m=read<int>(),d=read<int>(),v=read<int>();
		a[i]=(L){m,d,v};
	}
	sort(a+1,a+n+1,cmp);
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		while(l<=r && calc(ddq[l],a[i])>=k)l++;
		for(int o=0;o<l;o++)
//			for(int j=a[i].v;j<=m;j++)
//				dp[i][j]|=dp[o][j-a[i].v];
			dp[i]|=dp[o]<<a[i].v;
		ddq[++r]=a[i];
	}
	for(int i=m;i>=0;i--)
		for(int j=0;j<=n;j++)
			if(dp[j][i]){
				printf("%d\n",i);
				return 0;
			}
	return 0;
}
```



---

## 作者：Wing_ (赞：3)

# P8803 [蓝桥杯 2022 国 B] 费用报销

## 前言

当时想了个 DP 一直调不出来，翻了翻题解发现没有跟自己思路一样的，最后自力更生调出来了，就交一发题解纪念一下。

与其它题解的显著区别是**不需要 $lst$ 数组**，但复杂度没有更优秀。

WA 的教训：**DP 注意初始化！**

## 题目大意

有 $N$ 张票据，每张有日期和价值，选取一些票据，满足：

1. 日期差不超过 $K$；
2. 价值总和不超过 $M$。

在满足条件的前提下，使价值最大。

该年**不是闰年**。

## 题目分析

### 输入及处理

首先月和日是分开的，这非常讨厌，我们可以把它们都转成日，记为 $d_i$，再**按日从小到大排序**。具体见代码。

### 状态设计

看到 $N \le 1000$，$M \le 5000$，容易想到 $O(nm)$ 的做法是可以通过的。

那么就设计出一个二维状态：$f_{i,j}$ 表示考虑了前 $i$ 张票据，已经选取的费用为 $j$ 时的状态。里面存的是什么呢？由于我们的状态转移跟日期有关，而我们的答案是费用，已经被考虑到状态中，所以 $f_{i,j}$ 中存的就是日期。因为当费用相同时，**被选票据的最晚日期越小**，后面的票据就越有机会被选，所以，完整的状态表示是：

$f_{i,j}$ 表示在满足条件的前提下，考虑了前 $i$ 张票据，已经选取的费用为 $j$ 时，**最小的被选票据最晚日期**。

### 状态转移

我们就可以用 **01 背包**的思路推出状态转移方程，即考虑每张票据选还是不选。

不选第 $i$ 张票据，则 $f_{i,j}$ 直接由 $f_{i-1,j}$ 转移而来。

选第 $i$ 张票据，需要 $j-v_i \ge 0$ 且 $d_i - f_{i-1,j-a_i} \ge K$，此时由于已经按 $d_i$ 从小到大排过序，最晚日期一定是 $d_i$，所以 $f_{i,j}$ 由 $d_i$ 转移而来。

两者取最小值即可。

### 初始化

考虑 $i=0$ 时每个 $f_{i,j}$ 的值，从状态设计出发，发现只有 $f_{0,0}$ 表示考虑了 $0$ 个票据，价值为 $0$ 的状态，是有意义的。其它状态无意义。

因为 $f$ 数组存的是最小值，所以无意义和不可达的状态都赋为**正无穷**。

而 $f_{0,0}$，我一开始设置为了 $0$，结果 WAWA 大哭。

但仔细思考后发现，如果将它设为 $0$，那用它更新时，只能更新到 $d_i \ge K$ 的状态，但实际上，总价值为 $0$，即什么也没选的时候，接下来选任意一张票据都是可以的。

所以应将 $f_{0,0}$ 初始化为**负无穷**，这样对于任意 $d_i$，一定满足 $d_i - f_{0,0} \ge K$，不会出现问题。

### 统计答案

从 $M$ 倒着枚举 $j$，第一个可达的状态（值不是正无穷）的 $j$ 就是答案，输出并结束循环。

## 代码


```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1010, M=5010, INF=0x3f3f3f3f;
const int mon[13]{0,31,28,31,30,31,30,31,31,30,31,30,31}; //12个月的天数 
int sum[13];
int n, m, K;
int f[N][M];
struct Node
{
	int d, v;
}pj[N]; //pj是票据的意思QAQ 

bool cmp(Node x, Node y) {return x.d<y.d;}

int main()
{
	//处理天数 
	for (int i = 1; i <= 12; i++) sum[i]=sum[i-1]+mon[i];
	scanf("%d%d%d",&n,&m,&K);
	for (int i = 1; i <= n; i++)
	{
		int month, day;
		scanf("%d%d%d",&month,&day,&pj[i].v);
		pj[i].d=sum[month-1]+day; //这个月前面的月份的天数总和+在这个月过的天数 
	}
	sort(pj+1,pj+n+1,cmp);
	memset(f,0x3f,sizeof f);
	f[0][0]=-INF; //WA的教训
	// DP 过程 
	for (int i = 1; i <= n; i++)
	{
		for (int j = 0; j <= m; j++)
		{
			f[i][j]=f[i-1][j];
			if (j>=pj[i].v&&pj[i].d-f[i-1][j-pj[i].v]>=K) f[i][j]=min(f[i][j],pj[i].d);
		}
	}
	// 输出答案 
	for (int j = m; j >= 0; j--)
		if (f[n][j]<INF)
		{
			printf("%d",j);
			break;
		}
	return 0;
}
```

其实也可以用滚动数组优化空间，但是我懒 qwq。

## 总结

**细节决定成败**。

在 DP 的时候要注意**初始化** QAQ，也许一个细节上的疏忽就会满盘皆输。

有不完善的地方请指出，谢谢！

---

## 作者：OKC__THUNDER (赞：2)

# P8803[蓝桥杯2022国B]费用报销 题解

~~废话部分：这是本蒟蒻第二篇题解，第一篇在小号上。~~

## 本题方法：01 背包 DP

本题为 01 背包 DP，只需进行预处理即可。

好，我们开始，一步一步解释吧：

### 输入预处理
由于题目中每张票据输入的是对应的月、日，所以我们应把日期变为**当日是今年的第几天**。

首先是预处理数组：
```cpp
int ycl[22]={0,31,59,90,120,151,181,212,243,273,304,334,365},gsw[1111],dp[1111][5555];//gsw也是一个预处理数组，后续使用
```
其中 $ycl_i$ 是指当日期的月份 $mi$ 为 $i+1$ 时，全年前 $i$ 个月共有多少天。所以只需再加上第 $i+1$ 月的日子 $di$ 就能完成输入预处理。

```cpp
struct P{int r,v;}a[1111];//r日期，v为面值
```
为了方便后续排序，使用结构体将每张票据的信息合并到一起。

输入：
```cpp
int n,m,k;
cin>>n>>m>>k;//题目要求
for(int i=1;i<=n;i++)
{
	int mi,di;
	cin>>mi>>di>>a[i].v;
	a[i].r=ycl[mi-1]+di;//见上
}
```

进一步预处理：
```cpp
sort(a+1,a+n+1,cmp);//排个序
for(int i=1;i<=n;i++) for(int j=0;j<i;j++) if(a[i].r-a[j].r>=k) gsw[i]=j;//见下
```
这里是要将排完序的数组预处理。根据题目，小明提交的票据中任意两张的日期差应不小于 $k$ 天，而后续 DP 中的 $i-1$ 无法满足条件，故使用数组 $gsw$，来记录第 $i$ 张票据之前最大的满足条件的票据 $j$。

### 01 背包 DP
正常 01 背包 DP 即可。
```cpp
for(int i=1;i<=n;i++)//二维01背包，dp[i][j]代表第i张票据，当最大可装价值为j时，可凑出的最大金额
{
  for(int j=0;j<=m;j++)
  {
    dp[i][j]=dp[i-1][j];
    if(j>=e[i].v) dp[i][j]=max(dp[i][j],dp[gsw[i]][j-e[i].v]+e[i].v);//不要忘了用gsw
  }
}
cout<<dp[n][m];
```

### 祭出 [AC 记录](https://www.luogu.com.cn/record/219640257)和 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct P{int r,v;}a[1111];
int ycl[22]={0,31,59,90,120,151,181,212,243,273,304,334,365},gsw[1111],dp[1111][5555];
bool cmp(P x,P y){return x.r<y.r;}
int main()
{
	int n,m,k,mx=0;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		int mi,di;
		cin>>mi>>di>>a[i].v;
		a[i].r=ycl[mi-1]+di;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) for(int j=0;j<i;j++) if(a[i].r-a[j].r>=k) gsw[i]=j;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			dp[i][j]=dp[i-1][j];
			if(j>=a[i].v) dp[i][j]=max(dp[i][j],dp[gsw[i]][j-a[i].v]+a[i].v);
		}
	}
	cout<<dp[n][m];
	return 0;
}
```
希望管理员通过 ^o^

---

## 作者：0x282e202e2029 (赞：2)

题目：[P8803](https://www.luogu.com.cn/problem/P8803)

## 思路

容易发现本题为经典的背包问题。

背包问题可描述为**利用有限的总资源，合理选取需要消耗资源的对象，以达到最大的总收益**。在本题中，「有限的总资源」即为实际差旅费用 $M$，「消耗资源的对象」即为 $N$ 张票据。

本题明显为最经典的 0-1 背包问题，且每张票据占用的体积与产生的价值均为 $v$。

以下对状态转移方程进行分析。

我们令 $dp_{i,j}$ 为前 $i$ 张票据最多占用 $j$ 体积时选取的最大价值，则答案即为 $dp_{N, M}$。

显然，$dp_{i,j}$ 有两种可能性。

其一，不选第 $i$ 张票据，则此时最优解为 $dp_{i - 1, j}$。

其二，选第 $i$ 张票据，此时最优解为 $dp_{pre, j - v_i} + v_i$，其中 $pre$ 为日期离第 $i$ 张票据最近且在第 $i$ 张票据前的合法（即提交第 $i$ 张票据时仍能提交的）票据，例如，对于样例而言，第 $3$ 张票据的 $pre = 1$，如果不存在即为 $0$。

综合而言，即为 `dp[i][j] = max(dp[i - 1][j], dp[pre][j - v[i]] + v[i])`。

对于每张票据的 $pre$，由于数据并未按顺序给出（别被样例骗了！），因此先对所有票据按时间顺序排序，再用 `while` 循环求出。

到了这里，请尝试自己写出代码。

## AC 代码

```cpp
#include <algorithm> //sort, max
#include <cstdio>
#define qaq printf("QAQ");
using namespace std;
const int MAXN = 1e3 + 7, MAXM = 5e3 + 7;
const int days[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; //处理每月之前的天数，方便计算
struct Bill //票据
{
    int date, value; //时间（距离去年 12 月 31 日）及价值
    void input()
    {
    	int m, d;
    	scanf("%d%d%d", &m, &d, &value);
    	date = days[m - 1] + d;
	}
} b[MAXN];
int cmp(Bill x, Bill y)
{ 
	return x.date < y.date; //按时间顺序排序
}
int n, m, k;
int dp[MAXN][MAXM], pre, p[MAXN];
int main()
{
	//输入
	scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++)
    {
        b[i].input();
    }
    
    //计算
    sort(b + 1, b + n + 1, cmp);
    for (int i = 1; i <= n; i++)
    {
    	pre = i - 1;
    	while (b[i].date - b[pre].date < k && pre) //确保 pre >= 0，避免 RE
    	{
    		pre--; 
		} //求出离第 i 张票据最近且在第 i 张票据前的合法票据
        for (int j = m; j >= b[i].value; j--) //0-1 背包要倒序枚举
        {
            dp[i][j] = max(dp[i - 1][j], dp[pre][j - b[i].value] + b[i].value); //状态转移方程
		}
	}
    
	//结果
	printf("%d", dp[n][m]);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/114784180)

---

## 作者：vegetableYe (赞：1)

# 类似背包的 dp

看了一眼现有的题解感觉或许思路上都多少有点困难，这里给出一个简单的状态定义：  
$dp[i, j]$ 表示考虑前 $i$ 天报销了 $j$ 元的状态，是否可达。  
这样定义的好处是，转移十分容易，并且复杂度也是稳定的：$O(n \cdot m)$,具体的看代码吧（有注释）
```cpp
int n, m, k;
int dp[444][5050]; // 考虑前 i 天，报销总数为 j 的状态是否可达
int pre[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

void solve() {
    cin >> n >> m >> k;
    vector<vector<int>> a(366); // 每天的票据
    for(int i = 1, mon, d, v; i <= n; i++) {
        cin >> mon >> d >> v;
        d += pre[(mon - 1)];
        a[d].emplace_back(v);
    }
    dp[0][0] = 1;
    for(int i = 1; i <= 365; i++) {
        for(int j = 0; j <= m; j++) { // 第 i 票据不报销，可以直接继承上一天的状态
            dp[i][j] |= dp[i - 1][j];
        }
        for(auto & v : a[i]) { // 单独报销第 i 天票据
            dp[i][v] = 1;
        }
        if(i >= k) { // 满足 k 的限制的话，可以从 [i - k, j - 票价] 的状态用 or 运算的方式转移
            for(auto & v : a[i]) {
                for(int j = v; j <= m; j++) {
                    dp[i][j] |= dp[i - k][j - v];
                }
            }
        }
    }
    int ans = 0;
    for(int j = m; j >= 0; j--) {
        if(dp[365][j]) {
            ans = max(ans, j);
        }
    }
    cout << ans << endl;
}
```

---

## 作者：dcc2012 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P8803)
# 题意
现在有 $N$ 张票据，每张票据有日期和面值。从中选取出任意两张日期差不小于 $k$ 天的票据，并使总金额尽可能接近 $M$，且不超过 $M$。  
**需要注意：这一年不是闰年。**
# 思路
我们发现这个题是一个背包问题，定义布尔类型数组 $dp$，容易发现 $dp_{i,j}$ 表示前 $i$ 个票据，能否使票据总金额为 $j$。

这时考虑两种情况：
- 不选第 $i$ 张票据。  
容易得出 $dp _ {i,j}=dp _ {i,j}+dp _ {i-1,j}$。
   
- 选第 $i$ 张票据。  
发现上一张票据必须是日期至少相差 $k$ 天，这个 $k$ 想要处理十分麻烦，这里定义一个 $last\_date$ 数组，记录满足条件的上一个票据。这时答案显而易见 $dp _ {i,j}=dp _ {i,j}+dp _ {last\_date _ {i},j-a _ {i}.money}$。

最后输出 $dp _ {n,i}$ 的最大值即可。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1002,M=5002;
int month_date[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};
int n,m,k;
int dp[N][M];
int last_date[M];
int ans;
struct node{
	int date,money;//第i张票据的日期和面值 
}a[M];
bool cmp(node x,node y){
	return x.date<y.date;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++){
		int mth,dt;
		scanf("%d%d%d",&mth,&dt,&a[i].money);
		a[i].date=month_date[mth-1]+dt;//记录第i个票据的日期 
	}
	sort(a+1,a+n+1,cmp);//按照日期升序排序 
	for(int i=1;i<=n;i++){
		for(int j=i;j>=0;j--){
			if(a[i].date-a[j].date>=k){
				last_date[i]=j;//求出满足条件的上一个票据 
				break;
			}
		}
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			dp[i][j]|=dp[i-1][j];
			if(j>=a[i].money){
				dp[i][j]|=dp[last_date[i]][j-a[i].money];
			} 
		}
	}
	for(int i=0;i<=m;i++){
		if(dp[n][i]){
			ans=i;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zxr123_is_dd (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8803)

方法一：

将票据按时间排序。对于每一张票据我们可以求出最近的时间差大于 $k$ 的票据，记为 $lst_i$。

然后考虑 dp。

用 $f_{i,j}$ 表示前 $i$ 个票据，票据总额为 $j$ 元。

那我们从最近的时间差不小于 $k$ 的票据转移显然比从其他的票据更优。

对与每个 $i$，选或不选，可得到一下转移方程
$$
f_{i,j}=\max(f_{i-1,j},f_{lst_i,j-v_i})
$$
时间复杂度 $O(nm)$。

```cpp
const int maxn = 1e3 + 10;
const int maxm = 5e3 + 10;

struct Z {
	int d, val;
} a[maxn];
int mth[14] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int f[maxn][maxm], lst[maxn];

bool cmp(Z A, Z B) {
	return A.d < B.d;
}

int main() {
	int n = read(), m = read(), k = read();
	for (int i = 1; i <= 12; i++) {
		mth[i] += mth[i - 1];
	}
	for (int i = 1; i <= n; i++) {
		int m = read(), d = read();
		a[i].d = mth[m - 1] + d;
		a[i].val = read();
	}
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			if (a[i].d - a[j].d >= k) {
				lst[i] = j;
			}
		}
	}
	f[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = m; j >= 0; j--) {
			f[i][j] = f[i - 1][j];
		}
		for (int j = m; j >= a[i].val; j--) {
			f[i][j] = max(f[i - 1][j], f[lst[i]][j - a[i].val]);
		}
	}
	int ans = 0;
	for (int i = m; i >= 0; i--) {
		if (f[n][i] > 0) {
			ans = max(ans, i);
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

方法二：

科技做法，bitset 大法（主要是 bitset 用多了，都傻了）。

如果没有想到 $lst$ 数组，还有比较简单的做法。

定义一个 $f_{i,j}$ 表示和上面相同。

如果没有 $lst$，直接转移，转移方程为：
$$
f_{i,j}=\max^{i-1}_{t=1,d_i-d_t \geq k} \ {f_{k,j-v_i}}
$$
时间复杂度为 $O(n^2m)$，显然会超时。

此时可以用 bitset 优化为 $O(\frac {n^2m} {w})$。

```cpp
const int maxn = 1e3 + 10;
const int maxm = 5e3 + 10;

struct Z {
	int d, val;
} a[maxn];
int mth[14] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
bitset<maxm> f[maxn];

bool cmp(Z A, Z B) {
	return A.d < B.d;
}

int main() {
	int n = read(), m = read(), k = read();
	for (int i = 1; i <= 12; i++) {
		mth[i] += mth[i - 1];
	}
	for (int i = 1; i <= n; i++) {
		int m = read(), d = read();
		a[i].d = mth[m - 1] + d;
		a[i].val = read();
	}
	sort(a + 1, a + n + 1, cmp);
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		f[i][0] = 1;
		f[i] |= f[i] << a[i].val;
		for (int j = 1; j < i; j++) {
			if (a[i].d - a[j].d >= k) {
				f[i] |= f[j] << a[i].val;
			}
		}
		for (int j = m; j > ans; j--) {
			if (f[i][j]) {
				ans = j;
			}
		}
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：Delete_error (赞：0)

这很背包。

精简一下就是装体积和价值相同的物体的背包，设 $f_{i,j}$ 为装前 $i$ 个物品装了体积为 $j$ 的最大价值，选或不选当前这件物品，转移方程为：
$$
f_{i,j}=\max(f_{i-1,j},f_{pos,j-v}+v) 
$$
其中 $v$ 为当前物体体积，$pos$ 满足 $day_i-day_{pos}\ge k$，$day_i$ 为第 $i$ 件物品的日期。

$day$ 数组算一下过了的月份加上当前月份日期就做好了。

接下来是维护 $pos$，先排个序保证对于每个 $j<i$ 的两件物品 $day_i\ge day_j$，然后直接向前找每个点对应的满足 $day_i-day_{pos}\ge k$ 的 $pos$，由于设计状态是前 $i$ 个，所以找到满足且最大的 $pos$ 就做好了。

最后找满足 $0\le i\le m$ 的 $f_{n,i}$ 的最大值就做完了。
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
const int MAXN=5e3+5;
ll N,M,K,f[MAXN][MAXN],pre[MAXN],lst[MAXN],Max;
ll q[MAXN]={0,31,28,31,30,31,30,31,31,30,31,30,31};
struct Node{
	ll m,d,v,w;
}stu[MAXN];
bool cmp(Node a,Node b){
	return a.w<b.w;
}
int main(){
	cin>>N>>M>>K;
	for(int i=1;i<=12;i++) pre[i]=pre[i-1]+q[i-1]; 
	for(int i=1;i<=N;i++){
		cin>>stu[i].m>>stu[i].d>>stu[i].v;
		stu[i].w=pre[stu[i].m]+stu[i].d;
	}
	sort(stu+1,stu+N+1,cmp);
	for(int i=1;i<=N;i++){
		for(int j=i-1;j>=1;j--){
			if(stu[i].w-stu[j].w>=K){
				lst[i]=j;
				//cout<<stu[i].w<<" "<<j<<endl;
				break;
			}
		}
	}
	for(int i=1;i<=N;i++){
	    for(int j=0;j<=M;j++) f[i][j]=f[i-1][j];
		for(int j=M;j>=stu[i].v;j--){
			f[i][j]=max(f[i][j],f[lst[i]][j-stu[i].v]+stu[i].v);
		}
	}
	for(int i=0;i<=M;i++) Max=max(Max,f[N][i]);
	cout<<Max;
	return 0;
}
```
有问题私信。

---


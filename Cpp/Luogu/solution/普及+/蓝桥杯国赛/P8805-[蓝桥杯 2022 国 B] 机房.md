# [蓝桥杯 2022 国 B] 机房

## 题目描述

这天，小明在机房学习。

他发现机房里一共有 $n$ 台电脑，编号为 $1$ 到 $n$，电脑和电脑之间有网线连接，一共有 $n-1$ 根网线将 $n$ 台电脑连接起来使得任意两台电脑都直接或者间接地相连。

小明发现每台电脑转发、发送或者接受信息需要的时间取决于这台电脑和多少台电脑直接相连，而信息在网线中的传播时间可以忽略。比如如果某台电脑用网线直接连接了另外 $d$ 台电脑，那么任何经过这台电脑的信息都会延迟 $d$ 单位时间（发送方和接收方也会产生这样的延迟，当然如果发送方和接收方都是同一台电脑就只会产生一次延迟）。

小明一共产生了 $m$ 个疑问：如果电脑 $u_{i}$ 向电脑 $v_{i}$ 发送信息，那么信息从 $u_{i}$ 传到 $v_{i}$ 的最短时间是多少?

## 说明/提示

**【样例说明】**

这四台电脑各自的延迟分别为 $2,2,1,1$。

对于第一个询问, 从 $2$ 到 $3$ 需要经过 $2,1,3$, 所以时间和为 $2+2+1=5$。对于第二个询问，从 $3$ 到 $4$ 需要经过 $3,1,2,4$，所以时间和为 $1+2+2+1=6$。

对于第三个询问，从 $3$ 到 $3$ 只会产生一次延迟，所以时间为 $1$。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，保证 $n, m \leq 1000$；

对于 $100 \%$ 的数据，保证 $n, m \leq 10^5$。

蓝桥杯 2022 国赛 B 组 H 题。

## 样例 #1

### 输入

```
4 3
1 2
1 3
2 4
2 3
3 4
3 3```

### 输出

```
5
6
1```

# 题解

## 作者：_JF_ (赞：17)

## P8805 [蓝桥杯 2022 国 B] 机房 

这题就是树上前缀和的板子。

要想掌握这一题，就需要先学会 LCA 和前缀和。

[LCA学习笔记](https://www.luogu.com.cn/blog/QWE78/lca-xue-xi-bi-ji)

首先，在树里面，任意两个结点之间有且只有一条路径。而这一条路径的“转折点”，就是这两个点的最近公共祖先。所以我们就可以拆分成两条链去想。设有两点 $[p,q]$ ，那么一条是 $[p,lca(p,q)]$，另一条是$[q,lca(q,p)]$。

题目之中的“延迟”，也就是经过一个点的所需时间且不变，这就是点权。而要快速查询链上某一段区间的和，前缀和就是不二之选。我们从根节点开始往下遍历，设 $sum[i]$ 表示从根节点到 $i$ 结点之间的延迟总和。可以通过遍历求解。

在查询的时候，其实就是 $sum[p]+sum[q]$，但是 $sum[lca(q,p)]$ 这个地方我们加了两次且这一段我们是不需要的，所以要减去。但是这样会减去 $lca(q,p)$ 的点权。但是在 $p$ 和 $q$ 的路径中，会经过 $lca(p,q)$，所以我们还要加上 $lca(q,p)$ 的点权。

我们用 $a$ 数组表示点权，那就应该是：

$$ans=sum[p]+sum[q]-2\times sum[lca(q,p)]+a[lca(q,p)]$$

$Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
vector<int> g[N<<1];
int sum[N],a[N],dep[N],fa[N][20],n,m;
inline int read(){
  	int x=0,w=1;char ch=0;
  	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
  	while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
  	return x*w;
}

inline void write(int x){
  	static int sta[35];int top=0;
  	do{sta[top++]=x%10,x/=10;}while (x);
  	while(top)putchar(sta[--top]+48);
}
void dfs(int u,int fath)
{
	dep[u]=dep[fath]+1;
	fa[u][0]=fath;
	for(int i=1;(1<<i)<=dep[u];i++)
		fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(v==fath)
			continue;
		sum[v]=sum[u]+a[v];
		dfs(v,u);
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])
		swap(x,y);
	int d=dep[x]-dep[y];
	for(int i=0;i<=log2(n);i++)
		if((1<<i)&d)
			x=fa[x][i];
	if(x==y)
		return x;
	for(int i=log2(n);i>=0;i--)
	{
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	}
	return fa[x][0];
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>m;
	for(int i=1,u,v;i<n;i++)
		cin>>u>>v,g[u].push_back(v),g[v].push_back(u);
	for(int i=1;i<=n;i++)
		a[i]=g[i].size(),sum[i]=g[i].size();
	dfs(1,0);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
//		cout<<sum[u]<<" "<<sum[v]<<" "<<sum[lca(u,v)]<<" "<<a[lca(u,v)]<<endl;
		cout<<sum[u]+sum[v]-2*sum[lca(u,v)]+a[lca(u,v)]<<endl;
	}
	return 0;
}


```


---

## 作者：2021sunzishan (赞：16)

##  题目大意：

给定有 $n$ 个节点的一棵树，每个节点的点权为此点的度，现有 $m$ 个询问，求任意两点间的最小点权和。


## 思路：
很明显，这题求最近公共祖先。

每一次询问，可以拆成两个点分别到他们最近公共祖先的点权和。

而本篇题解的不同之处在于，本蒟蒻是用tarjan求最近公共祖先。~~因为只会tarjan。~~

## 会tarjan的大佬可以跳过以下部分：

怎么用tarjan求最近公共祖先？

首先，tarjan是一种用并查集求的方法，且离线。

读入时，先将所有询问都读入进来。

在遍历每个节点 $u$ 的时候，更新 $f[u]$ 为 $u$ 的父节点。

然后遍历有关 $u$ 点的询问。若与 $u$ 配对的节点 $v$ 已经被访问过了，那么他们的最近公共祖先就是 $find(v)$。

问题来了：

## 怎么求距离？

首先dfs预处理出每个点到根节点 $1$ 的点权和。设 $i$ 到 $1$ 的点权和为 $dp[i]$ ,点权为 $a[i]$;$u$ 与 $v$ 的最近公共祖先为 $kk$，点权和为 $ans[i]$,则不难推出关系式：


$ans[i]=dp[u]+dp[v]-2\times dp[kk]+a[kk]$

这样这一题就基本解决了。


 如果还是看不懂，那就看代码吧！

### 切勿抄袭！！！


```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() { //快读
	int a=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9') {
		if  (c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		a=a*10+(c-'0');
		c=getchar();
	}
	return f*a;
}
int n,m,f[1000005],s,head[1000005],cnt1=0,dp[1000005];
int head1[1000005],cnt=0,vis[1000005],ans[500005],a[1000005];
struct edge {
	int to,next,id;
} edge[1000005],edge1[1000005];
void addedge(int a,int b) {
	edge[++cnt].to=b;
	edge[cnt].next=head[a];
	head[a]=cnt;
}
void addedge1(int a,int b,int id) {
	edge1[++cnt1].to=b;
	edge1[cnt1].next=head1[a];
	edge1[cnt1].id=id;
	head1[a]=cnt1;
}
//链式前向星存储
//edge存边，edge1存询问
int find(int x) {
	if (f[x]!=x) 
		f[x]=find(f[x]);
	return f[x];
}//并查集标程
void tarjan(int u,int fa) {
	vis[u]=1;//置为访问
	for (int i=head[u]; i; i=edge[i].next) { //遍历每个和u相邻的节点
		int v=edge[i].to;
		if(v!=fa) 
			tarjan(v,u); 
	}
	for (int i=head1[u]; i; i=edge1[i].next) { //遍历每个关于u的询问
		int v=edge1[i].to;
		if(vis[v]) { //如果已经访问过了
			int kk=find(v); //求u,v的最近公共祖先
			ans[edge1[i].id]=dp[u]+dp[v]-dp[kk]*2+a[kk];//求出距离
		}
	}
	f[u]=fa; //更新父节点
}
void dfs(int u,int fa) { //预处理出u到 1的距离
	for(int i=head[u]; i; i=edge[i].next) {
		int v=edge[i].to;
		if(v!=fa){
			dp[v]=dp[u]+a[v]; //很简单，推推就知道
			dfs(v,u);
		}
	}
}
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	m=read();
	for(int i=1; i<=n-1; i++) { //读入边
		int u,v;
		u=read();
		v=read();
		addedge(u,v);
		addedge(v,u);
		a[u]++;
		a[v]++;//记录点权
	}
	for(int i=1; i<=m; i++) { //读入询问
		int u,v;
		u=read();
		v=read();
		addedge1(u,v,i);
		addedge1(v,u,i); //这里要记录一下询问编号，因为tarjan是离线处理
	}
	for(int i=1; i<=n; i++)
		f[i]=i; //初始化父数组
	dfs(1,0); 
	tarjan(1,0);
	for (int i=1; i<=m; i++)
		printf("%d\n",ans[i]); //输出就over了
	return 0;
}


```
完结 ~

---

## 作者：Lantrol (赞：8)

前置知识：[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

### 题目描述

[P8805 [蓝桥杯 2022 国 B] 机房](https://www.luogu.com.cn/problem/P8805)

给定一棵 $n$ 个结点的无根树，每点的点权即该点的度数。 $m$ 组询问，每组询问求树上两点最短路径上的点权和。

### 思路
考虑把树上两结点 $x,y$ 间的最短路径拆成 $x \to $ LCA $ \to y$ 两段。最终答案就是两段的点权和相加，再减去 LCA 的点权。实现方法就是在倍增求 LCA 的预处理过程中，把点 $x$ 到它第 $2^i$ 个父结点的点权和也预处理出来。在求 LCA 时随着两点上跳，同时累加答案。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define ioc ios::sync_with_stdio(0)
using namespace std;
const int MAXN=1e5+5;
int n,q,to[MAXN<<1],nxt[MAXN<<1],head[MAXN],tot,val[MAXN],sum[MAXN][31],fa[MAXN][31],dep[MAXN];
void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
	val[u]++;
}
void dfs(int u,int f){
	fa[u][0]=f;
	dep[u]=dep[f]+1;
	sum[u][0]=val[u];
	for(int i=1;i<31;i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
		sum[u][i]=sum[fa[u][i-1]][i-1]+sum[u][i-1];
	}
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		if(v==f) continue;
		dfs(v,u);
	}
}
int lca(int x,int y){
	if(dep[x]>dep[y]) swap(x,y);
	int tmp=dep[y]-dep[x],ans=0;
	for(int j=0;tmp;++j,tmp>>=1){
		if(tmp&1) ans+=sum[y][j],y=fa[y][j];
	}
	if(y==x) return ans+val[y];
	for(int j=30;j>=0&&y!=x;j--){
		if(fa[x][j]!=fa[y][j]){
			ans+=sum[x][j]+sum[y][j];
			x=fa[x][j];
			y=fa[y][j];
		}
	}
	ans+=sum[x][0]+sum[y][0]+sum[fa[x][0]][0];
	return ans;
}
int rt;
signed main(){
	rt=1;
	ioc;
	cin>>n>>q;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs(rt,0);
	while(q--){
		int x,y;
		cin>>x>>y;
		cout<<lca(x,y)<<"\n";
	}
}
```


---

## 作者：RNTBW (赞：7)

### 序
看看我可怜的社贡，赶紧来水一篇...
## 题意
给定一棵树，每个点的权值为它的出度。

$q$ 次询问，每次两个数 $u,v$，求一条经过的点权值和最小的从 $u$ 到 $v$ 的路径，输出路径长度。
## 思路
一眼看，多测。

最短路肯定行不通，怎么做呢？

_给定一棵树。_

LCA 呀！

如果有不懂 LCA 的右转[这篇博客](https://blog.csdn.net/qq_37957064/article/details/111560301?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166814122916782391879813%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166814122916782391879813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-111560301-null-null.142^v63^control,201^v3^control_2,213^v2^t3_control2&utm_term=LCA&spm=1018.2226.3001.4187)，接下来我就默认你们都懂 LCA 的倍增算法了哈。

按照倍增的思想，我们可以定义一个数组 $val[i][j]$ 表示从第 $i$ 个点开始，向上 $2^j$ 个点的权值和。

画个图吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/libtl9le.png)

在这张图中：

$val[4][0]=a_4$，也就是它本身的权值。

$val[4][1]=a_{4,3}$。

$val[4][2]=a_{4,3,2,1}$。

因为在寻找 LCA 的途中走过的路径都是 $u$ 到 $v$ 最短路径上的点，我们就可以在过程中随着 $u$ 和 $v$ 的变化而累加 $ans$。

即：

```cpp
ans+=val[u][i];
u=dp[u][i];
//或
ans+=val[u][i]+val[v][i];
u=dp[u][i];v=dp[v][i];
```

但是，我们会发现一个问题：

在上面那幅图中，$dp[4][1]=2$，$val[4][1]=a_3+a_4$，漏了一个 $a_2$。

也就是说，倍增代码会漏掉 $u,v$ 最终停留的点的权值。

而最后会是这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ld7o1sa8.png)

如图所示，我们再把 $val[u][0]$，$val[v][0]$ 和 $val[dp[u][0]][0]$ 加上去就行。

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mx 100001
int f[mx][21],d[mx][21];
int head[mx],dp[mx];//这里的dp和上文的dp不一哟
//这里的f是上文的dp,d是上文的val
int n,m,i,j,k,s,cnt;
struct eve
{
	int to,nxt;
} ed[mx<<1];
bool r[mx];
void add(int x,int y)
{
	ed[++cnt].nxt=head[x];
	head[x]=cnt;
	ed[cnt].to=y;
}
void dfs(int nr,int fa)
{
	dp[nr]=dp[fa]+1;
	f[nr][0]=fa;//预处理出深度以及f数组
	for(int i=head[nr];i;i=ed[i].nxt)
	{
		int v=ed[i].to;
		if(v!=fa)dfs(v,nr);
	}
}
int LCA(int u,int v)
{
	int ans=0;
	if(dp[u]<dp[v])swap(u,v);
	for(i=20;i>=0;i--)
		if(dp[f[u][i]]>=dp[v])ans+=d[u][i],u=f[u][i];
	if(u==v)return ans+d[u][0];//如果u=v证明u是LCA，加上最后停留的u点权值即可
	for(i=20;i>=0;i--)
		if(f[u][i]!=f[v][i])
		{
			ans+=d[u][i]+d[v][i];
			u=f[u][i];v=f[v][i];//先加权值后变u,v
		}
	return ans+d[u][0]+d[v][0]+d[f[u][0]][0];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(i=1;i<n;i++)
	{
		scanf("%d%d",&k,&s);
		add(k,s);add(s,k);r[s]=1;
		d[k][0]++;d[s][0]++;
	}
	for(i=1;i<=n;i++)
		if(!r[i])break;//找根
	dfs(i,0);
	for(j=1;j<20;j++)
		for(i=1;i<=n;i++) f[i][j]=f[f[i][j-1]][j-1],d[i][j]=d[f[i][j-1]][j-1]+d[i][j-1];
	while(m--)
	{
		scanf("%d%d",&k,&s);
		printf("%d\n",LCA(k,s));
	}
	return 0;
}
```


---

## 作者：xixisuper (赞：3)

# P8805 [蓝桥杯 2022 国 B] 机房

遇见树上的路径操作，果断选择树链剖分。

## 1.读题

简化一下题意：

- 给出一个有 $n$ 个结点的树。
- 每个节点上的点权等于每个节点的出度入度之和。
- 有 $m$ 次询问，每次在树上查询从点 $u$ 到点 $v$ 的点权值和。

## 2.解题

前置知识：[前缀和](https://blog.csdn.net/weixin_52477733/article/details/121739364)，[树链剖分](https://blog.csdn.net/a_forever_dream/article/details/80651308)。

这里默认大家都会树链剖分。

本题可以采用最经典的树剖做法，用线段树去维护，但是我们发现，本题并没有修改点权的操作，所以我们可以直接维护一个前缀和数组，这样求和的操作就是 $O(1)$ 的了。

将树剖成链之后，一边跳链一边利用前缀和求和。

采用线段树的时间复杂度：$O(n\log^2 n)$。

采用前缀和的时间复杂度：$O(n\log n)$。

## 3.代码

蒟蒻代码技术不高，不喜勿喷。

采用的是前缀和维护。

```cpp
#include <iostream>
#include <vector>
#define ll long long
using namespace std;
const ll N=1e6;
ll seg[N],rev[N],top[N],p[N],tot=1;
ll son[N],size[N],fa[N],dep[N];
vector<ll> a[N];
void dfs1(ll u,ll f){
	fa[u]=f;
	dep[u]=dep[f]+1;
	size[u]=1;
	for(int i=0;i<a[u].size();i++){
		ll v=a[u][i];
		if(v==f) continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]]) son[u]=v; 
	}
}
void dfs2(ll u,ll f){
	if(son[u]){
		seg[son[u]]=++tot;
		rev[tot]=son[u];
		top[son[u]]=top[u];
		dfs2(son[u],u);
	}
	for(int i=0;i<a[u].size();i++){
		ll v=a[u][i];
		if(!top[v]&&v!=f){
			top[v]=v;
			seg[v]=++tot;
			rev[tot]=v;
			dfs2(v,u);
		}
	} 
}
//以上部分为树链剖分初始化
ll n,m;
ll sum[N];
ll ask(ll x,ll y){
	ll fx=top[x];
	ll fy=top[y];
	ll ans=0;
	while(fx!=fy){
		if(dep[fx]<dep[fy]) swap(fx,fy),swap(x,y);
		ans+=(sum[seg[x]]-sum[seg[fx]-1]);
		x=fa[fx],fx=top[x]; 
	}
	if(dep[x]>dep[y]) swap(x,y);
	ans+=(sum[seg[y]]-sum[seg[x]-1]);
	return ans;
}
//边跳链便计算加和
int main(){
	cin>>n>>m;
	ll x,y;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		p[x]++;
		p[y]++;//计算点权
		a[x].push_back(y);
		a[y].push_back(x);
	}
	dfs1(1,0);
	seg[1]=rev[1]=top[1]=1;
	dfs2(1,0);
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+p[rev[i]];
	while(m--){
		cin>>x>>y;
		cout<<ask(x,y)<<endl;
	} 
	return 0;
} 
```
$upd$：

2023.1.2 根据审核要求修改  $\LaTeX$，顺便将一些句末未加的标点补上。


---

## 作者：GoodCoder666 (赞：2)

## 题意

给定一棵 $n$ 个结点的树，每个结点的入度/出度即为其权值。一条路径的长度定义为**经过所有结点的权值总和**（包括起始和终止结点）。

回答 $m$ 个询问，对于 $i=1,2,\dots,m$：
- 结点 $u_i$ 和 $v_i$ 之间的最短路径长度是多少？

$1\le n,m\le 10^5$。

## 分析

首先考虑最短路的方法，$\mathcal O(n^3+m)$ 的 Floyd 和 $\mathcal O(nm)$ 的 DFS 肯定不行。

树上的路径问题一般使用 LCA，没学过的可以先看[OI Wiki上的介绍](https://oi-wiki.org/graph/lca/)。本题解中 LCA 使用预处理 $\mathcal O(n\log n)$，查询 $\mathcal O(\log n)$ 的**倍增算法**。

思路很明确：

- 预处理出从根结点开始，到每个结点 $u$ 的路径长度 $\mathrm{dis}_u$。根结点任意，但**必须与LCA所使用的根结点相同**。

- 对于一次查询 $u\to v$，令 $f=\mathrm{LCA}(u,v)$。

- 此时，$u\to v$ 的最短路径肯定是 $u\to f\to v$。
  - $u\to f$ 的路径长度（不包括 $f$）为 $\mathrm{dis}_u-\mathrm{dis}_f$。
  - $v\to f$ 的路径长度（不包括 $f$）为 $\mathrm{dis}_v-\mathrm{dis}_f$。

- 于是，答案为 $\mathrm{dis}_u-\mathrm{dis}_f+\mathrm{dis}_v-\mathrm{dis}_f+\mathrm{cost}(f)=\mathrm{dis}_u+\mathrm{dis}_v-2\mathrm{dis}_f+\mathrm{cost}(f)$。

**注意计算答案时不要忘记加上$f$的权值。**

由于所有权值的和为 $2(N-1)$，肯定不会爆 `int`，所以直接使用 `int` 即可。

## 代码

[提交记录传送门](https://www.luogu.com.cn/record/98500834)

跑得挺快的，没开 `O2`，$10$ 个点总共 $807\text{ms}$。

```cpp
#include <cstdio>
#include <vector>
#define maxn 100005
using namespace std;

vector<int> G[maxn];
int depth[maxn], fa[maxn][17]; // 2^17=131072
int dis[maxn];

#define cost(v) (int)G[v].size()
void dfs(int v, int par)
{
	int d = depth[v] + 1;
	fa[v][0] = par;
	for(int i=1; (1<<i)<d; i++)
		fa[v][i] = fa[fa[v][i - 1]][i - 1];
	dis[v] += cost(v);
	for(int u: G[v])
		if(u != par)
		{
			dis[u] = dis[v];
			depth[u] = d;
			dfs(u, v);
		}
}

int lca(int u, int v)
{
	if(depth[u] < depth[v])
		u ^= v ^= u ^= v;
	int m = depth[u] - depth[v];
	for(int i=0; m; i++, m>>=1)
		if(m & 1)
			u = fa[u][i];
	if(u == v) return u;
	for(int i=__builtin_log2(depth[u]); i>=0; i--)
		if(fa[u][i] != fa[v][i])
			u = fa[u][i], v = fa[v][i];
	return fa[u][0];
}

int main()
{
	int n, q;
	scanf("%d%d", &n, &q);
	for(int i=1; i<n; i++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		G[--x].push_back(--y);
		G[y].push_back(x);
	}
	dfs(0, -1);
	while(q--)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		int f = lca(--u, --v);
		printf("%d\n", dis[u] + dis[v] - 2 * dis[f] + cost(f));
	}
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：2)

看到题大家想到了什么呢？没错，就是纯纯的最近公共祖先。

这是一棵树，所以首先就直接存双向边，并且给这条边对应的两个节点的点权加 $1$，表示和另一台电脑相连。输入边结束后，每个点的点权就已经找到了，接下来我们只需要针对每一个询问进行回答就可以了。

这个回答非常简单，在求到两个节点 $x,y$ 的最近公共祖先 $r$ 后，我们不难想到一种前缀和思想，设 $f_u$ 表示从 $u$ 开始一直找祖先直到根节点的过程中的点权之和，所有的 $f_u$ 我们可以利用搜索进行简单求解。那么输出答案的时候，就直接输出 $f_x+f_y-2\times f_{father_r}-val_r$，其中 $father_r$ 表示 $r$ 的父亲节点，$val_r$ 表示 $r$ 的点权。解释一下，这个式子就代表两个前缀和加起来过后，减去 $r$ 上面的节点的两倍，因为这个我们求的路径上不包含这些节点，最后减去 $val_r$ 是因为 $val_r$ 在两次前缀和算了两次，需要减去一次。

代码如下：

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int MAXN=1e5+5;
int to[MAXN<<1],head[MAXN],nxt[MAXN<<1],tot;
int val[MAXN];
void add(int x,int y)
{
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
} 
int depth[MAXN],dp[MAXN][21];
int lg[MAXN];
int n,m;
void dfs(int now,int fa)
{
	dp[now][0]=fa;
	depth[now]=depth[fa]+1;
	for(int i=1;i<=lg[depth[now]];i++)	dp[now][i]=dp[dp[now][i-1]][i-1];
	for(int i=head[now];i;i=nxt[i])
	{
		if(to[i]==fa)	continue;
		dfs(to[i],now);
	}
}
int LCA(int x,int y)
{
	if(depth[x]<depth[y])	swap(x,y);
	while(depth[x]>depth[y])	x=dp[x][lg[depth[x]-depth[y]]-1];
	if(x==y)	return x;
	for(int i=lg[depth[x]]-1;i>=0;i--)
	{
		if(dp[x][i]!=dp[y][i])	x=dp[x][i],y=dp[y][i];
	}
	return dp[x][0];
}
int f[MAXN];
void dfs2(int now,int fa)
{
	f[now]=f[fa]+val[now];
	for(int i=head[now];i;i=nxt[i])
	{
		if(to[i]==fa)	continue;
		dfs2(to[i],now);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y),add(y,x);
		val[x]++,val[y]++;
	}
	for(int i=1;i<=n;i++)	lg[i]=lg[i-1]+(1<<lg[i-1]==i);
	dfs(1,0);
	dfs2(1,0);
	while(m--)
	{
		int x,y;
		cin>>x>>y;
		int r1=LCA(x,y);
		cout<<f[x]+f[y]-2*f[dp[r1][0]]-val[r1]<<endl;
	}
	return 0;
}
```

---

## 作者：BFSDFS123 (赞：2)

大家好，我是忠实的树剖选手，所以我用树剖过了此题。

----

考虑对这棵树进行树链剖分。

一般的树剖操作都是在跳路径的时候进行线段树上的查找。这固然能做，不过 $O(n \log^2 n)$ 有些没必要。
 
我们发现，这道题没有修改操作。我们可以考虑对球出来的每个点的 dfs 序的位置上的权值进行前缀和，然后在每次查找的时候用前缀和求出答案。

时间复杂度 $O(n \log n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=1e5+10;
int siz[Maxn],son[Maxn];
int dep[Maxn],fat[Maxn];
int Top[Maxn],dfn[Maxn],dfsTime;
int head[Maxn],tot;
struct Edge{
    int to;
    int nxt;
}E[Maxn<<1];
void addedge(int u,int v)
{
    tot++;
    E[tot].to=v;
    E[tot].nxt=head[u];
    head[u]=tot;
}
void dfs1(int u,int fa)
{
    fat[u]=fa;
    dep[u]=dep[fa]+1;
    siz[u]=1;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].to;
        if(v==fa) continue;
        dfs1(v,u);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]])
        {
            son[u]=v;
        }
    }
}
void dfs2(int u,int tp)
{
    Top[u]=tp;
    dfn[u]=++dfsTime;
    if(!son[u])
    {
        return ;
    }
    dfs2(son[u],tp);
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].to;
        if(v==fat[u] || v==son[u]) continue;
        dfs2(v,v);
    }
}
int pre[Maxn];
int Ar[Maxn];
int deg[Maxn];
int query(int dfnu,int dfnv)
{
    return pre[dfnv]-pre[dfnu-1];
}
int querypath(int u,int v)
{
    int ans=0;
    while(Top[u]!=Top[v])
    {
        if(dep[Top[u]]<dep[Top[v]])
        {
            swap(u,v);
        }
        ans+=query(dfn[Top[u]],dfn[u]);
        u=fat[Top[u]];
    }
    if(dep[u]>dep[v])
    {
        swap(u,v);
    }
    ans+=query(dfn[u],dfn[v]);
    return ans;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);
        addedge(v,u);
        deg[u]++;
        deg[v]++;
    }
    dfs1(1,0);
    dfs2(1,1);
    for(int i=1;i<=n;i++)
    {
        Ar[dfn[i]]=deg[i]; // 对对应 dfs 序的值的位置上赋值
        //cout<<deg[i]<<" ";
    }
    for(int i=1;i<=n;i++)
    {
        pre[i]=pre[i-1]+Ar[i]; // 求出前缀和
    }

    while(m--)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        printf("%d\n",querypath(u,v));
    }
    return 0;
}
```




---

## 作者：Bulyly (赞：1)

### 前言
对比了各位大佬的做法后，我认为有些题解的地方有些多余，接下来说下我的做法，蒟蒻认为很好写，也很好想。
### 解析
- 记录一个前缀和数组，用来存储任一点到树根节点的距离。这里就存在对比与其他题解，我不同的看法了。我认为没有必要找到树根，任意一点都可以是树根。

- 接下来就是朴素的倍增做法求 LCA了。结合以上两点，可以考虑用 bfs 和 dfs。但个人推荐 bfs 不容易暴栈。

```
talk is cheap,give me your code !!!
```

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;
const int N=100010,M=N*2;

int depth[N],f[N][21];
int h[N],ne[M],e[M],w[N],dist[N];
bool st[N];
int n,m,idx;

void add(int a,int b)
{
	e[++idx]=b,ne[idx]=h[a],h[a]=idx,w[a]++;
}

void bfs(int root)
{
	memset(depth,0x3f,sizeof depth);
	depth[0]=0,depth[root]=1;
	queue<int> q;
	q.push(root);
	while(q.size())
	{
		int t=q.front();
		q.pop();
		for(int i=h[t];i;i=ne[i])
		{
			int j=e[i];
			if(depth[j]>depth[t]+1)
			{
				depth[j]=depth[t]+1;
				q.push(j);
				f[j][0]=t;
				dist[j]=dist[t]+w[j];
				for(int k=1;k<=20;k++)
				    f[j][k]=f[f[j][k-1]][k-1];
			}
		}
	}
}

int lca(int a,int b)
{
	if(depth[a]<depth[b])  swap(a,b);
	int ans=0;
	for(int k=20;k>=0;k--)
	{
		if(depth[f[a][k]]>=depth[b])
		   a=f[a][k];
	}
	if(a==b)  return a;
	for(int k=20;k>=0;k--)
	{
		if(f[a][k]!=f[b][k])
		{
			a=f[a][k];
			b=f[b][k];
		}
	}
	return f[a][0];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b),add(b,a);
	}
	dist[1]=w[1];
	bfs(1);
	while(m--)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		int anc=lca(a,b);
		cout<<dist[a]+dist[b]-dist[anc]*2+w[anc]<<'\n'                                                                ;
	}
	return 0;
} 
```
完结撒花~



---

## 作者：Lyu_echo (赞：0)

## 前置芝士:

树上最近公共祖先的倍增求法或 Tarjan 求法。

参考博客：[树上倍增法求最近公共祖先](https://blog.csdn.net/m0_62021646/article/details/124028235)

参考题目：[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

由于 Tarjan 求法比较巨,这里不提供 Tarjan 求法的参考博客。

## 序:

规定在下文中：

* $root$ 表示树的根节点。

* $(u,v)$ 表示点 $u$ 至点 $v$ 的路径。

* $\operatorname{lca}(u,v)$ 表示点 $u$ 和点 $v$ 的最近公共祖先。

* $dis_{u,v}$ 表示 $(u,v)$ 上点权值和。

* $sum_u$ 表示树的根节点到点 $u$ 的路径上点权之和，即 $dis_{root,u}$。

* $degree_u$ 表示点 $u$ 的度，在此题中即为点 $u$ 的权值。

## 题目大意:

给定一颗树，每个点的点权即为该点的度。

共 $m$ 次询问，每次询问给定两个节点 $u,v$，求 $u$ 到 $v$ 最短路径上的权值之和。

## 解题思路:
- 题目给定了一棵树，同时树上路径唯一，所以并不存在树上 "最短路径" 说法。树上两点之间的唯一路径即为两点的最短路径。

- 不难发现：树上两点 $u$ 至 $v$ 的路径中必然经过 $u,v$ 两点的最近公共祖先。

  即：可以将 $(u,v)$ 拆分成 $(u,\operatorname{lca}(u,v))$ 和 $(\operatorname{lca}(u,v),v)$。

  同时，$dis_{u,v}$ 也被拆分成 $dis_{u,\operatorname{lca}(u,v)} + dis_{\operatorname{lca}(u,v),v}$。

- 此时，点 $u$ 到点 $\operatorname{lca}(u,v)$ 的距离为根节点到点 $u$ 的距离减去根节点到点 $\operatorname{lca}(u,v)$的距离，即：

    - $dis_{u,\operatorname{lca}(u,v)} = dis_{root,u} - dis_{root,\operatorname{lca}(u,v)} = sum_u - sum_{\operatorname{lca}(u,v)}$

  同理可得：

    - $dis_{\operatorname{lca}(u,v),v} = dis_{root,v} - dis_{root,\operatorname{lca}(u,v)} = sum_v - sum_{\operatorname{lca}(u,v)}$

  综上所述：

    - $dis_{u,v} = sum_u + sum_v - 2\times sum_{\operatorname{lca}(u,v)} + degree_{\operatorname{lca}(u,v)}$

  因为在进行处理时，并没有将 $\operatorname{lca}(u,v)$ 的点权值算上，所以此处不要忘记加上 $degree_{\operatorname{lca}(u,v)}$。

- 对于维护 $sum$ 数组的问题，我们使用树上前缀和，有如下递推式：
   
    - $sum_u = sum_{u_{father}} + degree_u$
  
  其中：$u_{father}$ 表示树上点 $u$ 的父亲节点。
  
上述所有公式读者不难自证，此处仅提供思路不提供证明。

程序实现中：

* 使用倍增法
	
    - 使用 DFS 预处理出树上前缀和 $sum$ 数组和任意点的深度 $depth$ 数组。
	
    - 使用倍增法求得任意一次询问的最近公共祖先，使用上述公式求得答案。

* 使用tarjan
	
    - 因为 Tarjan 是离线算法，在输入询问中要记录每次询问的两个点。
    
    - 正常的 Tarjan 操作 + DfS 中求得树上前缀和 $sum$ 数组。
    
## 代码:

这里仅给出 Tarjan 得求法 ~~（因为倍增太复杂了不想写~~

```cpp
#include<bits/stdc++.h>
// #include<bits/extc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/hash_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
struct Edge{
	int v,nxt;
}edge[1000010];
struct Edge_ask{
	int pos,v,nxt;
}ask_edge[1000010];
int n,m,s;
int edge_cnt,ask_edge_cnt;
int fa[500010],book[500010],lca[500010],pre[500010],to[500010],degree[500010],sum[500010];
int head[1000010],ask_head[1000010];
void add(int u,int v){
	edge[++edge_cnt].v=v;
	edge[edge_cnt].nxt=head[u];
	head[u]=edge_cnt;
}
void add_ask(int u,int v,int pos){
	ask_edge[++ask_edge_cnt].pos=pos;
	ask_edge[ask_edge_cnt].v=v;
	ask_edge[ask_edge_cnt].nxt=ask_head[u];
	ask_head[u]=ask_edge_cnt;
}
int find(int root){
	return fa[root]==root?root:fa[root]=find(fa[root]);
}
void merge(int x,int y){
	int fx=find(x);
	int fy=find(y);
	if(fx==fy) return ;
	fa[fy]=fx;
}
void tarjan(int u,int u_fa){
	book[u]=1;
	sum[u]=sum[u_fa]+degree[u];
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].v;
		if(book[v]) continue ;
		tarjan(v,u);
		merge(u,v);
	}
	book[u]=2;
	for(int i=ask_head[u];i;i=ask_edge[i].nxt){
		int v=ask_edge[i].v;
		if(book[v]==2) lca[ask_edge[i].pos]=find(v);
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);

	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
		degree[u]++;
		degree[v]++;
	}
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		pre[i]=u;
		to[i]=v;
		add_ask(u,v,i);
		add_ask(v,u,i);
	}
	tarjan(1,0);
	for(int i=1;i<=m;i++) cout<<sum[pre[i]]+sum[to[i]]-2*sum[lca[i]]+degree[lca[i]]<<endl;

	return 0;
}
```




---

## 作者：孤芒星河233 (赞：0)

# P8805 [蓝桥杯 2022 国 B] 机房

[洛谷题面](https://www.luogu.com.cn/problem/P8805)

## 题意

  给出一颗大小为 $n$ 的树和 $m$ 次询问，每个点的权值为它的边数。每次询问输入两个正整数 $u,v$，输出 $u$ 到 $v$ 的路径大小。

  数据范围：$n,m\leq 10^5$

## 思路

  题目虽然说是求 $u$ 到 $v$ 的最短路径，但对于一颗树来说，只需要保证不重复经过边即可保证这点。也就是说只要能把点权转化一下，这道题就变成了LCA的模板题了。（不会LCA？[这里有模板](https://www.luogu.com.cn/problem/P3379)）

  将点权作为这个点与它的父亲的边权，用LCA算出路径的长度之后，会发现LCA处的点权被抵消了，再加上LCA处的点权即为答案。

  举一个例子来说明一下：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/qzieftgx.png)
  
  先把点权转化为边权，计算出所有点到根节点 $1$ 的距离 $dis$。对应代码`dis[v]=dis[u]+a[v];`
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/26tws6ft.png)
  
  若要计算节点 $6$ 与 $7$ 的距离，可以发现它们路径上深度最小的点便是它们的最近公共祖先。节点 $6$ 和 $7$ 到根节点 $1$ 的路径合并后，多余的地方便是它们的LCA节点 $3$ 到根节点的距离乘二。此时节点 $3$ 的点权没被计算到，加上就行了。
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/qwmv1a29.png)

  其他细节见代码。

## 代码

  ``` cpp
  #include<bits/stdc++.h>
  using namespace std;
  
  const int N=1e5+9;
  int n,m,a[N],fa[N][21],dep[N],dis[N];
  vector<int> e[N];
  
  void dfs(int u,int f){
      fa[u][0]=f;
      dep[u]=dep[f]+1;
      for(int i=1;i<=20;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
      for(int v:e[u]){
          if(v==f) continue;
          dis[v]=dis[u]+a[v];//a[v]即为u,v边权，dis[v]为v与根节点的距离
          dfs(v,u);
      }
  }
  int lca(int u,int v){//倍增求lca
      if(dep[u]<dep[v]) swap(u,v);
      for(int i=20;i>=0;i--){
          if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
      }
      if(u==v) return u;
      for(int i=20;i>=0;i--){
          if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
      }
      return fa[u][0];
  }
  
  int main(){
      scanf("%d%d",&n,&m);
      int u,v;
      for(int i=1;i<n;i++){
          scanf("%d%d",&u,&v);
          e[u].push_back(v);
          e[v].push_back(u);
          a[u]++,a[v]++;//点权
      }
      dfs(1,0);
      while(m--){
          scanf("%d%d",&u,&v);
          int d=lca(u,v);
          printf("%d\n",dis[u]+dis[v]-2*dis[d]+a[d]);//路径长度+lca处点权
      }
      return 0;
  }
  ```

---


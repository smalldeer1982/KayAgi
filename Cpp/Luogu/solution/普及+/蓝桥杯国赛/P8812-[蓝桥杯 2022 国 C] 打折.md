# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# 题解

## 作者：Graph (赞：21)

解题思路:
记录所有物品在哪一天开始打折，在哪一天结束打折。

离散化所有时间，先暴力所有物品未打折的最小值（使用 multiset 快速找出），再枚举每一天，计算贡献，快速得出当天花费的最小值，最终即可得出答案。

代码有注释。

注意事项:
打折时间为 $[s,t]$，意味着第 $t+1$ 天才结束打折。

参考代码:

```
#include <bits/stdc++.h>
using namespace std;
 
// 2023 OneWan
 
const int MAXM = 100000 + 5;
int s[MAXM], t[MAXM], p[MAXM], c[MAXM]; // 对应题目输入的各数组
multiset<long long> st[MAXM]; // st[i] 为 物品 i 在所有商店的价格
vector<vector<pair<int, int>>> v(MAXM); // v[i][j] 为 商店 i 出售的 第 j 个物品

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    vector<int> time; // 用于离散化 时间
    for (int i = 0 ; i < m ; i++) {
        cin >> s[i] >> t[i] >> p[i] >> c[i];
        time.emplace_back(s[i]);
        time.emplace_back(t[i] + 1); // 打折是闭区间 所以需要+1才是没有打折截止
        for (int j = 0 ; j < c[i] ; j++) {
            int a, b; // 物品编号及原价
            cin >> a >> b;
            v[i].emplace_back(a, b);
        }
    }
    sort(time.begin(), time.end()); // 排序时间
    time.resize(unique(time.begin(), time.end()) - time.begin()); // 离散化时间
    auto get = [&](int t) {
        return lower_bound(time.begin(), time.end(), t) - time.begin();
    }; // 获取离散化后的下标
    int len = time.size();
    vector<vector<pair<int, int>>> startD(len), endD(len);
    // startD[i] 为 第 i 天 开始打折的物品编号 和 打折后的价格
    // endD[i] 为 第 i 天 结束打折的物品编号 和 打折后的价格
    for (int i = 0 ; i < m ; i++) {
        int starts = get(s[i]), ends = get(t[i] + 1); // 获取打折开始与结束时间离散化后的下标
        for (auto& [x, y] : v[i]) {
            int t = 1LL * y * p[i] / 100; // 打折后的价格
            st[x].insert(y); // 把物品原价放入
            startD[starts].emplace_back(x, t);
            endD[ends].emplace_back(x, t);
        }
    }
    long long temp = 0; // 用于存每天购买所有物品所用的价格
    for (int i = 1 ; i <= n ; i++) temp += *st[i].begin(); // 计算不进行打折时购买所有物品所用的价格
    long long ans = temp;
    for (int i = 0 ; i < len ; i++) {
        long long k = 0; // 打折与不打折对价格的贡献
        for (auto& [x, y] : startD[i]) { // 遍历当天所有开始打折的物品 打折前价格最小值为a, 打折后价格最小值为b, 贡献为b - a
            k -= *st[x].begin();
            st[x].insert(y);
            k += *st[x].begin();
        }
        for (auto& [x, y] : endD[i]) { // 遍历当天所有结束打折的物品 打折前价格最小值为a, 打折后价格最小值为b, 贡献为b - a
            k -= *st[x].begin();
            int t = st[x].count(y);
            st[x].erase(y);
            for (int j = 1 ; j < t ; j++) st[x].insert(y);
            k += *st[x].begin();
        }
        temp += k; // 加上贡献, 由前一段转移到后一段
        ans = min(ans, temp); // 找花费最小
    }
    cout << ans;
    return 0;
}
  ```
  
----------------

不喜勿喷！

---

## 作者：Sweet_2013 (赞：3)

- 首先**贪心**：最后选择的时间点一定为**某一个物品的打折开始时间点**。因为如果我们选择的时间点，不是任何一个时间的打折点那么我们可以让这个时间前移答案至少不会变坏。
- 每一个物品在当前可以购买的价格可以用一棵**平衡树维护**，表示在当前时间点每个物品的可以选择的价格集合。
- 考虑时间点的右移，我们只需要记录当前物品 $i$ 原来的价格为 $p$ 现在价格为 $q$，那么只需要在平衡树 $i$ 中删除一个 $p$ 价格并插入一个 $q$ 价格即可。
- 物品**都需要买一个**，所以根据贪心我们在每棵平衡树中都要选择最小值，我们使用一棵树状数组维护即可。即每次平衡树变化时我们先记录这颗平衡树的最小值在与修改后的最小值进行比较如果发生了变化就修改树状数组。

---

## 作者：whx2009 (赞：0)

## 本题思路：
这道题我们看到每个点打折分别是一些时间段，那么可以考虑给时间离散化之后枚举每个时间点的花费，取最小值。

每一件商品我们可以分别开一棵平衡树维护最小值是多。我们把商店打折区间离线下来做扫描线，当扫到左端点时把该商店卖的商品的打折价分别插入对应的平衡树中，右端点时踢出就可以了。
## 本题代码：
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ls tr[p].ch[0]
#define rs tr[p].ch[1]
using namespace std;
struct f{int rnd,ch[2],sum,mi,num;}tr[2000005];
void wei(int p){tr[p].mi=min(tr[ls].mi,min(tr[rs].mi,tr[p].num));}
void split(int p,int &x,int &y,int k){
	if(!p){x=y=0;return;}
	if(tr[p].sum<=k){x=p;split(rs,rs,y,k);wei(x);}
	else y=p,split(ls,x,ls,k),wei(y);
}
void merge(int &p,int x,int y){
	if(!x||!y){p=x+y;return;}
	if(tr[x].rnd<=tr[y].rnd) p=x,merge(rs,rs,y);
	else p=y,merge(ls,x,ls);
	wei(p);
}
int cnt;
int add(int k,int id){
	++cnt;tr[cnt].sum=id,tr[cnt].num=tr[cnt].mi=k;
	tr[cnt].rnd=rand();return cnt;
}
struct f1{
	int l,r,p,id;
}a[200005];
int b[200005],cnts,us[200005],vs[200005];
int root[200005];
vector<pair<int,int> >s[200005];
vector<int>v[200005];
bool cmp(f1 x,f1 y){return x.l<y.l;}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	srand(time(0));
	tr[0].mi=INT_MAX;
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++) us[i]=INT_MAX;
	for(int i=1;i<=m;i++){
		cin>>a[i].l>>a[i].r>>a[i].p,a[i].id=i;
		b[++cnts]=a[i].l,b[++cnts]=a[i].r;
		int cnt1=0,k;cin>>k;
		for(int j=1;j<=k;j++){
			int x,y;cin>>x>>y;
			if(us[x]==INT_MAX)vs[++cnt1]=x;
			us[x]=min(us[x],y);
		}
		for(int j=1;j<=cnt1;j++){
			int y=us[vs[j]],x=vs[j];us[x]=INT_MAX;
			s[i].push_back(make_pair(x,y));
			merge(root[x],root[x],add(y,i));
		}
	}
	sort(b+1,b+1+cnts);
	for(int i=1;i<=m;i++){
		a[i].l=lower_bound(b+1,b+1+cnts,a[i].l)-b;
		a[i].r=lower_bound(b+1,b+1+cnts,a[i].r)-b;
	}
	long long ans=0,ans1=0;
	for(int i=1;i<=n;i++){ans1+=tr[root[i]].mi;}
	ans=ans1;int l=1;
	sort(a+1,a+1+m,cmp);
	for(int i=1;i<=cnts;i++){
		while(a[l].l==i){
			v[a[l].r+1].push_back(a[l].id);
			int x,y,z;
			for(int j=0;j<s[a[l].id].size();j++){
				int kx=s[a[l].id][j].first,ks=s[a[l].id][j].second;
				ans1=ans1-tr[root[kx]].mi;
				split(root[kx],x,y,a[l].id);
				split(x,x,z,a[l].id-1);
				merge(x,x,add(1ll*ks*a[l].p/100,a[l].id));
				merge(root[kx],x,y);
				ans1+=tr[root[kx]].mi;
			}
			l++;
		}
		for(int j=0;j<v[i].size();j++){
			int ys=v[i][j];
			int x,y,z;
			for(int j=0;j<s[ys].size();j++){
				int kx=s[ys][j].first,ks=s[ys][j].second;
				ans1=ans1-tr[root[kx]].mi;
				split(root[kx],x,y,ys);
				split(x,x,z,ys-1);
				merge(x,x,add(ks,ys));
				merge(root[kx],x,y);
				ans1+=tr[root[kx]].mi;
			}
		}
		ans=min(ans,ans1);
	}cout<<ans;
	return 0;
}
```

---


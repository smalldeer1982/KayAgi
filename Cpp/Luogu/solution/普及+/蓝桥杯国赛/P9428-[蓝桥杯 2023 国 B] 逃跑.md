# [蓝桥杯 2023 国 B] 逃跑

## 题目描述

小明所在星系有 $n$ 颗星球，编号为 $1$ 到 $n$。这些星球通过 $n-1$ 条无向边连成一棵树。根结点为编号为 $1$ 的星球。

为了在星际战争到来时逃到其他星系，小明在根结点设置了逃离用的传送门。每个星球的人只需要一直往父结点星球移动就可以抵达根结点。为了方便各个星球的人去往根结点，小明将其中 $m$ 个星球设置为了跳板星球。在从某个星球去往根结点的路径上，当一个人经过任意星球（包括起点星球）时，他可以尝试直接跳跃到 **其前往根结点路径上的除当前星球以外的第一个跳板星球**，其时间花费和走到父结点星球的时间花费相同，都是 $1$ 单位时间。

然而，因为技术问题，向跳板星球的跳跃并不一定成功，每一次跳跃都有 $p$ 的概率失败，并转而跳跃到当前星球的父结点星球（相当于直接走到父结点星球）；同时此跳板星球失效，将 **不再视为跳板星球**。

为了衡量移动效率，小明想知道，如果一个人在这 $n$ 颗星球中随机选择一颗出发前往根结点，其花费的最短时间的期望是多少单位时间？

## 说明/提示

### 样例说明

从 $1$ 号星球出发的时间花费为 $0$；  
从 $2$ 号星球出发的时间花费为 $1$；  
从 $3$ 号星球出发的时间花费为 $2$；  
从 $4$ 号星球出发的时间花费为 $0.8 \times 2 + 0.2 \times 3 = 2.2$。

所以期望时间为 $\dfrac{0+1+2+2.2}{4}=1.3$。

### 评测用例规模与约定

 - 对于 $30\%$ 的数据，保证 $1 \le n \le 2000$。
 - 对于 $100\%$ 的数据，保证 $1 \le n \le 10^6$，$1 \le m \le n$，$0 < p < 1$。
 
 第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 J 题

## 样例 #1

### 输入

```
4 1 0.2
1 2
2 3
3 4
2```

### 输出

```
1.30```

# 题解

## 作者：BaiBaiShaFeng (赞：7)

## 题解：P9428 [蓝桥杯 2023 国 B] 逃跑

高一蒟蒻刚学完概率期望，整篇简单题。

### 题意：

要去根节点，中途有跳板星球可以直接跳到跳板星球，但有一定概率失败，求**最短时间期望**。

想必能到这里大概都对于期望有一定了解，若不会建议先去学学。依照我的见解，概率动态规划仅仅是套了个概率论的包装罢了，我们利用它解决问题即可。

[OIWIKI](https://oiwiki.org/math/probability/exp-var/)

### 思路

$n$ 点 $n-1$ 条边，显然这是个**树**。

存图我们就不多说了，这里我使用的是我最喜欢的链式前向星存图。

为了让大家更好理解样例，我决定手模一下。

所给样例↓

```
4 1 0.2
1 2
2 3
3 4
2
```

所给树拥有四个点，形成了一条链，我们正好方便分析。

- 从 $1$ 号星球出发，不需要移动，时间花费为 $0$。

- 从 $2$ 号星球出发，直接到根结点，时间花费为 $1$。

- 从 $3$ 号星球出发，先到 $2$ 号星球，再到 $1$ 号星球，时间花费为 $2$。

- 从 $4$ 号星球出发：有 $0.8$ 的概率成功跳到 $2$ 号星球，再到 $1$ 号星球，时间花费为 $2$。还有 $0.2$ 的失败概率，先到 $3$ 号星球，再到 $2$ 号星球，最后到 $1$ 号星球，时间花费为 $3$。期望时间为 $0.8×2+0.2×3=2.2$。

最后咱们再汇总一下。

得出答案为 $\frac{0+1+2+2.2}{4}=1.30$。

我们可以很轻易地用动态规划轻易求解出每个节点的期望时间。

- 若当前的点是跳板星球，则下一个点的动态规划值直接为当前点的动态规划值加一即可。

这个好理解，跳不跳无人在意，没有任何区别。

- 若当前的点不是跳板星球，则下一个点的动态规划值为当前节点的动态规划值等于当前节点的动态规划值加上 $p^{num}$，其中 $p$ 是跳跃失败的概率，$num$ 是从当前星球到根结点路径上的跳板星球数量。

这个有一点难想，当从下一个点出发前往根时，因为当前星球不是跳板星球，所以下一个节点必须先到达当前节点，这一步的时间花费包含在当前节点的动态规划值里。接下来，从当前节点继续前往根结点的过程中，会遇到路径上的 $num$ 个跳板星球。对于每一个跳板星球，都存在成功和失败两种情况。要想让从下一个节点到根结点的时间最短，最好的情况是在经过所有跳板星球时都能成功跳跃。但实际上，每次跳跃都有 $p$ 的概率失败。

如果在经过跳板星球时至少有一次成功跳跃，那么花费的时间不会超过直接走到父结点再到根结点的时间，因为成功跳跃相当于抄近路，所以这种情况对最短时间期望的额外增加时间为 $0$。

由于每次跳跃失败的事件是相互独立的，根据乘法原理，连续 $num$ 次跳跃都失败的概率就是 $p^{num}$。

当连续 $num$ 次跳跃都失败时，就相当于没有利用任何跳板星球的跳跃功能，只能一步步地从当前星球走到父结点，最终到达根结点。这种情况下，相对于成功利用跳板星球跳跃的理想情况，额外多花费的时间期望就是 $p^{num}$。

本人第一篇题解，求通过。

若讲的哪里不清楚请评论留言，会更改。

具体的 dfs 相信大家都明白，就不说了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MN=5e6+116;
struct Node{int nxt, to;}node[MN];
int head[MN], tottt, n, m;
inline void insert(int u, int v){
    node[++tottt].to=v;
    node[tottt].nxt=head[u];
    head[u]=tottt;
}
double p, dp[MN];
int gogogo[MN], num;
double quick_power(double a, int b){
    double res=1;
    while(b){
        if(b&1) res*=a;
        a*=a; b>>=1;
    }return res;
}
void dfs(int u, int father){
    if(gogogo[u]) ++num;
    for(int i=head[u];i;i=node[i].nxt){
        int v=node[i].to;
        if(v==father) continue;
        if(gogogo[u]) dp[v]=dp[u]+1;
        else dp[v]=dp[u]+quick_power(p,num);
        dfs(v,u);
    }if(gogogo[u]) num--;
}
int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); cin>>n>>m>>p;
    for(int i=1,u,v; i<n; ++i){
        cin>>u>>v; insert(u,v); insert(v,u);
    }for(int i=1,point; i<=m; ++i){
        cin>>point; gogogo[point]=1;
    }
    dfs(1,0);
    double ans=0;
    for(int i=1; i<=n; ++i){
        ans+=dp[i];
    }
    cout<<fixed<<setprecision(2)<<ans/n<<'\n';
    return 0;
}
```

---

## 作者：wwt100127 (赞：3)

## 题目注意
尝试后跳板**不再视为**跳板。

## 思路
首先，要求任意一个出发的期望，其实也就是求从每个点出发，最短时间期望的平均值。

不妨设 $dp_i$ 表示起点为 $i$ 的最短时间期望，$Fail_i$ 表示 $i$ 为起点，跳失败的概率。

分成三种情况：

- 如果 $i=1$，则 $Fail_i = 1,dp_i = 0$。
- 如果 $father_i$ 是“跳板”，显然不跳是较优的，这里和后面的点失败的概率也会增加，则 $Fail_i = Fail_{father_i} \times P,dp_i = dp_{father_i} + 1$。
- 如果 $father_i$ 不是“跳板”，显然跳较优，那么从 $i$ 跳成功了和从 $father_i$ 跳成功是一样的，不成功则转化为 $dp_{father_i}$，则 $Fail_i = Fail_{father_i},dp_i = dp_{father_i} + Fail_i$。

~~目前最优解的~~代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,m;
double P;
bool Jump[N];

namespace Graph
{
	int head[N],tot_edge;
	struct edge
	{
		int v,next;
	}e[N<<1];
	void G_init()
	{
		memset(head,-1,sizeof(head));
		tot_edge=-1;
	}
	void add(int u,int v)
	{
		e[++tot_edge]=(edge){v,head[u]};
		head[u]=tot_edge;
	}
	void add_edge(int u,int v)
	{
		add(u,v),add(v,u);
	}
} using namespace Graph;

double dp[N];
double Fail[N];
void dfs(int x,int fa)
{
	int i;
	for(i=head[x];~i;i=e[i].next)
	{
		int y=e[i].v;
		if(y==fa)
		continue;
		if(Jump[x]==0) dp[y]=dp[x]+(Fail[y]=Fail[x]);
		else Fail[y]=Fail[x]*P,dp[y]=dp[x]+1;
		dfs(y,x);
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int i,u,v;
	cin>>n>>m>>P;
	G_init();
	for(i=1;i<=n-1;i++)
	{
		cin>>u>>v;
		add_edge(u,v);
	}
	for(i=1;i<=m;i++)
	{
		cin>>u;
		Jump[u]=1;
	}
	Fail[1]=1;
	dfs(1,0);
	
	double ans=0; for(i=1;i<=n;i++) ans+=dp[i];
	cout<<fixed<<setprecision(2)<<(ans/n)<<'\n';
	return 0;
}
```

---

## 作者：JPGOJCZX (赞：2)

节选自：[DP做题记录（三）（2025.4.5 - 2025.4.19）](https://www.luogu.com.cn/article/tobtmxka)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18841176)

这道题代码难度只有红，但思维难度直接把这道题提升到了绿。

我们设 $dp_i$ 表示从第 $i$ 个星球出发到根节点花费的最短时间的期望。

显然，如果一个星球 $v$ 的父亲节点 $u$ 是跳板星球，那么直接跳跃与往上走父亲是一样的效果，因此 $dp_v = dp_u + 1$。

那么如果 $v$ 的父亲节点 $u$ 不是跳板星球，那么此时直接跳跃肯定要更优秀一些。假设我们有至少一次跳成功了，那么这种情况的时间一定在 $u$ 已经考虑过了（如果 $v$ 跳成功，就钦定 $u$ 这次一定跳成功；如果 $v$ 失败了，就钦定 $u$ 这次也失败了，这样一定能保证 $u$ 和 $v$ 到达根的时间一样）。唯一一种 $u$ 无法复制的情况就是 $v$ 每次跳跃都失败了，此时它就会多走一条 $v$ 到 $u$ 的边，概率是 $p^{cnt}$（$cnt$ 是 $v$ 到根路径上跳板星球的数量），因此对答案的贡献就会家上 $p^{cnt}$，因此 $dp_v = dp_u + p^{cnt}$，那么这道题就做完了。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 9;
struct Edge{
	int v, nex;
} e[N << 1], e2[N];
int head[N], ecnt;
void addEdge(int u, int v){
	e[++ecnt] = Edge{v, head[u]};
	head[u] = ecnt;
}
int flag[N], n, m;
double dp[N], p, ans;
void dfs(int u, int fa, double pp){
	if(flag[fa])
		pp *= p;
	if(u != 1){
		if(flag[fa])
			dp[u] = dp[fa] + 1;
		else
			dp[u] = dp[fa] + pp;
	}
	ans += dp[u];
	for(int i = head[u]; i; i = e[i].nex){
		int v = e[i].v;
		if(v == fa)
			continue;
		dfs(v, u, pp);
	}
	pp /= p;
}
int main(){
	scanf("%d%d%lf", &n, &m, &p);
	for(int i = 1; i < n; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		addEdge(u, v);
		addEdge(v, u);
	}
	for(int i = 1; i <= m; i++){
		int u;
		scanf("%d", &u);
		flag[u] = true;
	}
	dfs(1, 0, 1);
	printf("%.2lf", ans / n);
	return 0;
}
```

---

## 作者：_std_O2 (赞：2)

# P9428 [蓝桥杯 2023 国 B] 逃跑题解
## 坑点：
1. 跳跃是向跳板星球的。
2. 其**前往根结点路径上**的除当前星球以外的**第一个**跳板星球。
3. 求的是其花费的**最短时间**的期望。
## 思路
考虑递推，设当前节点为 $u$，它的子节点为 $v$。

易发现当 $u$ 为跳板星球时，$dp_{v}=dp_{u}+1$。因为我们是求的其花费的**最短时间**的期望。

又因 $0<p<1$ 所以不跳是更优的。

当 $u$ 不为跳板星球时，计 $cnt$ 为当前节点**前往根结点路径上**的跳板星球的个数。

有 $dp_{v}=dp_{u}+p^{cnt}×1$。

又因求其花费的**最短时间**的期望，所以要跳就一直跳，要么不跳，走到父节点。

## Code

```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
const int N=1e6+6;
vector<int> g[N];
bool is[N];
int n,m,cnt;
double dp[N];
double p;
void dfs(int x,int fa,int cnt){
	if(is[x]) cnt++;
	for(int y:g[x]){
		if(y==fa) continue;
		if(is[x]) dp[y]=dp[x]+1;
		else dp[y]=dp[x]+pow(p,cnt);
		dfs(y,x,cnt);
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); 
	cin>>n>>m>>p;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		is[x]=1;
	}
	dfs(1,0,0);
	double sum=0;
	for(int i=1;i<=n;i++) sum+=dp[i];
	double ans=sum/n;
	printf("%.2Lf",ans);
} 
```

---


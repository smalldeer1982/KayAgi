# [蓝桥杯 2024 省 A] 团建

## 题目描述

小蓝正在和朋友们团建，有一个游戏项目需要两人合作，两个人分别拿到一棵大小为 $n$ 和 $m$ 的树，树上的每个结点上有一个正整数权值。  
两个人需要从各自树的根结点 $1$ 出发走向某个叶结点，从根到这个叶结点的路径上经过的所有结点上的权值构成了一个正整数序列，两人的序列的最长公共前缀即为他们的得分。给出两棵树，请计算两个人最多的得分是多少。

## 说明/提示

对于 $20\%$ 的评测用例，$1 ≤ n, m ≤ 500 $；  
对于所有评测用例，$1 ≤ n, m ≤ 2 × 10^5，1 ≤ c_i
, d_i ≤ 10^8 ，1 ≤ u_i
, v_i ≤ n ，
1 ≤ p_i
, q_i ≤ m $，对于任意结点，其儿子结点的权重互不相同。

## 样例 #1

### 输入

```
2 2
10 20
10 30
1 2
2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 4
10 20 30 40 50
10 40 20 30
1 2
1 3
2 4
3 5
1 2
1 3
3 4```

### 输出

```
2```

# 题解

## 作者：happy_lazier (赞：4)

题目大意：在两棵树上分别找到一条路径使公共前缀最大。那么可以考虑把其中一棵树制作成类似于字典树的形式，但是值域有点大，所以对于字典树的节点考虑用 map 记录，之后就是在另一棵树上遍历去更新答案了，代码如下
```cpp
#define  _CRT_SECURE_NO_WARNINGS
#include <bits/stdc++.h>
#include<cstdio>
#include<random>
#include<cstdlib>
#include<algorithm>
#include<array>
#include<chrono>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> PII;
#define fi first
#define sc second
#define inf 0x3f3f3f3f3f
#define all(x) x.begin(),x.end()
#define YES cout<<"YES"<<'\n';
#define NO cout<<"NO"<<'\n';
#define Yes cout<<"Yes"<<'\n';
#define No cout<<"No"<<'\n';
#define rep(i, l, r) for (ll i = (l); i <= (r); ++i)
#define rep_(i, l, r) for (ll i = (l); i >= (r); --i)
using namespace std;
std::mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());//ull x=rng()
const ll P = 1e9 + 7;
const ll Inf = 2e18;
const ll M = 1e5 + 7;
const ll N = 2e5 + 7;
const int dx[5] = { 0,1,0,-1,0 }, dy[5] = { 1,0,-1,0,0 };
const double eps = 1e-6;
long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}
long long qmin(long long a, long long b) {
    long long res = 1;
    a %= P;
    while (b) {
        if (b & 1)res = res * a % P;
        b >>= 1;
        a = a * a % P;
    }
    return res;
}
long long inv(long long x) {
    return qmin(x, P - 2);
}
inline ll read()
{
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch>'9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar(), x %= P;
    return x * f;
}
//char* p1, * p2, buf[1 << 20];
//inline char gc() { if (p1 == p2)p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin); return p1 == p2 ? ' ' : *p1++; }
//inline long long read() {
//    register long long s = 0; register char c = gc();
//    while (c < '0' || c>'9') c = gc();
//    while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = gc();
//    return s;
//}
ll lowbit(ll x) {
    return x & (-x);
}
struct fenwick {
    vector<int>tr;
    int n;
    fenwick(int mx = 0) {
        n = mx;
        tr.assign(n + 10, 0);
    }
    void init(int mx) {
        n = mx;
        tr.assign(n + 10, 0);
    }
    void add(int x, int v) {
        for (int i = x; i <= n; i += i & (-i)) {
            tr[i] += v;
        }
    }
    int sum(int x) {
        int ans = 0;
        for (int i = x; i; i -= i & (-i)) {
            ans += tr[i];
        }
        return ans;
    }
    int rangeSum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
};
int c[N], d[N];
vector<int>g1[N], g2[N];
map<int, int>mp[N];
int cnt;
void dfs(int u, int v, int rt) {
    for (auto x : g1[u]) {
        if (x == v)continue;
        if (!mp[rt].count(c[x])) {
            mp[rt][c[x]] = ++cnt;
        }
        dfs(x, u, mp[rt][c[x]]);
    }
}
int dfs2(int u, int v, int dep, int rt) {
    int ans = dep;
    for (auto x : g2[u]) {
        if (x == v)continue;
        if (mp[rt].count(d[x])) {
            ans = max(ans, dfs2(x, u, dep + 1, mp[rt][d[x]]));
        }
    }
    return ans;
}
void solve() {
    int n, m;
    cnt = 0;
    cin >> n >> m;
    rep(i, 1, n)cin >> c[i];
    rep(i, 1, m)cin >> d[i];
    int u, v;
    rep(i, 2, n) {
        cin >> u >> v;
        g1[u].push_back(v);
        g1[v].push_back(u);
    }
    rep(i, 2, m) {
        cin >> u >> v;
        g2[u].push_back(v);
        g2[v].push_back(u);
    }
    int ans = 0;
    dfs(1, 0, 0);
    if (d[1] != c[1]) {
        cout << 0;
        return;
    }
    ans = dfs2(1, 0, 1, 0);
    cout << ans;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t = 1;
    //cout << fixed << setprecision(3);
    //cin >> t;
    //t = read();
    while (t--) solve();
    return 0;
}
```

---

## 作者：Genius_Star (赞：3)

### 思路：

看到某群在评论这题，闲的没事来写一下。

考虑枚举两个序列的最大前缀并进行判断，设我们枚举 $T_2$ 中 $1 \sim u$ 的路径，那么只需要存在一个 $T_1$ 中 $1 \sim v$ 的路径使得两个路径点权序列相等即可。

序列间判断是否相等，哈希即可。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define add(x, y) ((x + y >= mod) ? (x + y - mod) : (x + y))
#define dec(x, y) ((x - y < 0) ? (x - y + mod) : (x - y))
#define ctz(x) __builtin_ctz(x)
#define popcnt(x) __builtin_popcount(x)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2e5 + 10;
const ull base = 127;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
mt19937 R(time(0));
ull C;
int n, m, ans;
ull a[N], b[N], w[N];
set<ull> S;
vector<int> A[N], B[N];
inline void adda(int u, int v){
	A[u].push_back(v);
	A[v].push_back(u);	
}
inline void addb(int u, int v){
	B[u].push_back(v);
	B[v].push_back(u);	
}
inline void dfs1(int u, int fa){
	w[u] = 1ull * w[fa] * base + a[u];
	S.insert(w[u]);
	for(auto v : A[u]){
		if(v == fa)
		  continue;
		dfs1(v, u);
	}
}
inline void dfs2(int u, int fa, int dep){
	w[u] = 1ull * w[fa] * base + b[u];
	if(S.count(w[u]))
	  ans = max(ans, dep);
	for(auto v : B[u]){
		if(v == fa)
		  continue;
		dfs2(v, u, dep + 1);
	}
}
bool End;
int main(){
	C = R();
	n = read(), m = read();
	for(int i = 1; i <= n; ++i)
	  a[i] = read() + C; 
	for(int i = 1; i <= m; ++i)
	  b[i] = read() + C;
	for(int u, v, i = 1; i < n; ++i){
		u = read(), v = read();
		adda(u, v);
	}
	for(int u, v, i = 1; i < m; ++i){
		u = read(), v = read();
		addb(u, v);
	}
	dfs1(1, 0);
	dfs2(1, 0, 0);
	write(ans + 1);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：sLMxf (赞：1)

这个问题有点类似 01Trie 求异或最大的问题，你把它改成求且就几乎一模一样了。

将任意一棵树建立字典树，但值域 $10^8$，考虑使用 unordered_map：

然后查询就比较类似 01Trie 的查询。


注意到这种做法不会计算根，特判即可：
```cpp line-numbers
#include<bits/stdc++.h>
#define int long long
using namespace std;
int c[200005],d[200005];
unordered_map<int,int>trie[200005];
vector<int>G[200005],T[200005];
void init(int x=1,int fa=0)
{
	for(auto v:G[x])
	{
		if(v==fa) continue;
		trie[x][c[v]]=v;
		init(v,x);
	}
}
int solve(int x=1,int fa=0,int get=1)
{
	int ans=0;
	for(auto v:T[x])
	{
		if(v==fa) continue;
		if(trie[get][d[v]])
			ans=max(ans,solve(v,x,trie[get][d[v]])+1);
	}
	return ans;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m,u,v;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=m;i++) cin>>d[i];
	for(int i=1;i<n;i++)
	{
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for(int i=1;i<m;i++)
	{
		cin>>u>>v;
		T[u].push_back(v);
		T[v].push_back(u);
	}
	init();
	if(c[1]==d[1]) cout<<solve()+1;
	else cout<<0;
	return 0;
}
```
时间复杂度 $O(n)$。

---

## 作者：tonghaoxuan (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10388)

### 前言 ~~（废话）~~

本蒟蒻本想用暴力模拟骗分，没想到剪枝以下就过了？就挺突然的。看了眼标签，我寻思着我也没用哈希啊？也许是数据太弱，随便造一个数据就能 hack 掉我的代码？看了眼题解，似乎没有我的思路，那就写一篇题解吧！

### 思路：

我一个小蒟蒻能有什么思路，就**模拟+贪心+剪枝**。

首先，因为题目要求公共权值前缀最长，那么一旦出现不一样的权值，之后是不可能让公共前缀再变长了。（贪心）

那么，我们就可以只寻找公共路径。（剪枝）

（如图，蓝色、绿色、黑色为三种不同的公共路径）

（节点上的数字为权值非编号）
![解释](https://cdn.luogu.com.cn/upload/image_hosting/z32kiti0.png)

看哪一个公共路径的节点最深（bfs 或 dfs 均可）（模拟）。

### 做法：

好，那么怎样才能快速寻找所有公共路径呢？

我们可以提前对于每个节点的子节点根据权值排序（递增或递减均可），这样我们便可以用双指针，以达到快速寻找所有权值相同的子节点（不要忘了判断非父节点），进而快速找到所有公共路经。

具体的双指针实现，我的做法是两个变量（记录下标，类似指针的作用）都从第 $ 0 $ 个子节点，开始，每次对比两个子节点的权值，如果相等，就往队列里增加一项（这是 bfs 的做法，如果是 dfs 就开启递归，但我不确定会不会 ```MLE```），如果不相等就根据前面排序的逻辑增加两个变量中的一个，然后再判断，直到某一变量超出了所有子节点（```while(i<v_1[now.id_1].size()&&j<v_2[now.id_2].size())```，其中 ```now.id_1``` 是当前节点在大小为 $ n $ 的树上的编号，```now.id_2``` 是当前节点在大小为 $ m $ 的树上的编号。）

那就说完了，给代码吧。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
vector<int> v_1[200005],v_2[200005];
int c[200005],d[200005];
bool vis_1[200005],vis_2[200005];
inline bool cmp_1(const int &x,const int &y){
	return c[x]<c[y];
}
inline bool cmp_2(const int &x,const int &y){
	return d[x]<d[y];
}
struct info{
	int id_1,id_2,dp;
};
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=m;i++){
		cin>>d[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		v_1[u].push_back(v);
		v_1[v].push_back(u);
	}
	for(int i=1;i<m;i++){
		int p,q;
		cin>>p>>q;
		v_2[p].push_back(q);
		v_2[q].push_back(p);
	}
	for(int i=1;i<=n;i++){
		sort(v_1[i].begin(),v_1[i].end(),cmp_1);
	}
	for(int i=1;i<=m;i++){
		sort(v_2[i].begin(),v_2[i].end(),cmp_2);
	}
	queue<info> q;
	int ans=0;
	if(c[1]!=d[1]){
		cout<<0;
		return 0;
	}
	q.push({1,1,1});
	while(!q.empty()){
		auto now=q.front();
		q.pop();
		ans=max(ans,now.dp);
		vis_1[now.id_1]=1;
		vis_2[now.id_2]=1;
		int i=0,j=0;
		while(i<v_1[now.id_1].size()&&j<v_2[now.id_2].size()){
			if(c[v_1[now.id_1][i]]<d[v_2[now.id_2][j]]){
				i++;
			}else if(c[v_1[now.id_1][i]]>d[v_2[now.id_2][j]]){
				j++;
			}else if(c[v_1[now.id_1][i]]==d[v_2[now.id_2][j]]){
				if(vis_1[v_1[now.id_1][i]]==0&&vis_2[v_2[now.id_2][j]]==0){
					q.push({v_1[now.id_1][i],v_2[now.id_2][j],now.dp+1});
				}
				i++;
				j++;
			}
		}
	}
	cout<<ans;
}
```

### 结尾：

最后，我觉得我的思路和代码可能都还有问题（毕竟我把权值和编号搞混都过了），欢迎指出问题，hack 掉我的题解。

（第四次修改，因为没打空格）

---

## 作者：cxjy (赞：1)

### P10388 [蓝桥杯 2024 省 A] 团建



​	首先肯定想到 dfs，但是注意到，这里需要在快速找到一颗树中权值为某个数的子节点，所以想到预处理排序再加上二分查找。对第二颗树的每个节点的孩子按照权值的大小排序，然后 dfs 的时候遍历第一颗树中的每个节点，查询第二颗树中是否存在权值与之相等的子节点，如果存在就继续 dfs，每个节点返回当前节点可到达的最大深度即可。这里注意判断子节点可能是当前节点的父节点的特例。

​	时间复杂度 $O(n\log m + m\log m)$。



##### code

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
using i64 = long long;
using pii = std::pair<int, int>;
#define debug(x) std::cerr << #x << '=' << x <<"\n"
#define println(...) fprintf(stderr,__VA_ARGS__)
const int maxn = 2e5 + 9;
template<class T1, class T2>void cmax(T1 &a, T2 b) {
    if(a < b) a = b;
}

int c[maxn], d[maxn];
std::vector<int> e0[maxn], e1[maxn];
int n, m;

int dfs(int x0, int x1, int fa0, int fa1) {
    int ans = 1;
//    println("x0 = %d, x1 = %d, fa0 = %d, fa1 = %d\n", x0, x1, fa0, fa1);
	if(x0 >= maxn) return ans;
    for(int i = 0; i < e0[x0].size(); i++) {
        int u = e0[x0][i], w = c[u];
        if(u == fa0) continue;
        if( x1 >= maxn || e1[x1].size() == 0) continue; 
		int l = -1, r = e1[x1].size(), mid;
		while(l < r - 1) {
			mid = l + r >> 1;
			// println("d[e1[x1][mid]] = %d, w = %d\n", d[e1[x1][mid]], w);
			if(d[e1[x1][mid]] < w) {
				l = mid;
			} else {
				r = mid;
			}
		}
		int t = r;
        if(t < e1[x1].size() && d[e1[x1][t]] == w) {
            int uu = e1[x1][t];
            if(uu != fa1) {
                cmax(ans, 1 + dfs(u, uu,x0, x1));
            } else {
            	t++;
            	if(t != e1[x1].end() - e1[x1].begin() && d[e1[x1][t]] == c[u]) {
            		uu = e1[x1][t];
            		cmax(ans, 1 + dfs(u, uu,x0, x1));
				}
			}
        }
    }
    return ans;
}

signed main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
	// freopen("in.txt", "r", stdin);
	// freopen("out.txt", "w", stdout);


    std::cin >> n >> m;
    for(int i = 1; i <= n; i++) std::cin >> c[i];
    for(int j = 1; j <= m; j++) std::cin >> d[j];
    for(int i = 0; i < n - 1; i++) {
        int u, v;
        std::cin >> u >> v;
        e0[u].push_back(v);
        e0[v].push_back(u);
    }
    for(int i = 0; i < m - 1; i++) {
        int u, v;
        std::cin >> u >> v;
        e1[u].push_back(v);
        e1[v].push_back(u);
    }
    
    for(int i = 1; i <= n; i++) std::sort(e0[i].begin(), e0[i].end(), [&](int a, int b) {
        return c[a] < c[b];    
    });
    for(int j = 1; j <= m; j++) {
        std::sort(e1[j].begin(), e1[j].end(), [&](int a, int b) {
            return d[a] < d[b];    
        });
    } 
    if(c[1] != d[1]) {
        std::cout << 0 << "\n";
    } else {
        std::cout << dfs(1, 1, 0, 0)  << "\n";
    }
    return 0;
}
```

---


# [蓝桥杯 2024 省 A] 零食采购

## 题目描述

小蓝准备去星际旅行，出发前想在本星系采购一些零食，星系内有 $n$ 颗星球，由 $n-1$ 条航路连接为连通图，第 $i$ 颗星球卖第 $c_i$ 种零食特产。小蓝想出了 $q$ 个采购方案，第 $i$ 个方案的起点为星球 $s_i$ ，终点为星球 $t_i$ ，对于每种采购方案，小蓝将从起点走最短的航路到终点，并且可以购买所有经过的星球上的零食（包括起点终点），请计算每种采购方案最多能买多少种不同的零食。

## 说明/提示

第一个方案路线为 $\{4, 2, 1, 3\}$，可以买到第 $1, 2, 3$ 种零食；  
第二个方案路线为 $\{1, 2, 4\}$，可以买到第 $1, 2$ 种零食。

对于 20% 的评测用例，$1 ≤ n, q ≤ 5000 $；    
对于所有评测用例，$1 ≤ n, q ≤ 10^5，1 ≤ c_i ≤ 20，1 ≤ u_i
, v_i ≤ n，1 ≤ s_i
, t_i ≤ n$。

## 样例 #1

### 输入

```
4 2
1 2 3 1
1 2
1 3
2 4
4 3
1 4```

### 输出

```
3
2```

# 题解

## 作者：Breath_of_the_Wild (赞：9)

题目要我们求 $s_i$ 至 $t_i$ 的路径，让我们很容易想到先求出它们的 LCA，然后再去做一些操作。

我的做法：先预处理出一个 $cnt$ 的二维数组，其中 ``cnt[i][j]`` 表示从根节点（自己设定）出发，到 $i$ 这个点这条路上 $j$ 这种商品的出现个数。

这个 $cnt$ 用一趟 DFS 就求好了。DFS 到 $x$ 这个点时，枚举它的所有子节点 $u$。先把它的父节点（$x$）的 $cnt$ 复制过来，再加上 $u$ 自己的商品。即：
```cpp
for(int i=1;i<=22;i++){
    cnt[u][i]=cnt[x][i];
}
cnt[u][c[u]]++;
```
接着就是重点了。我们求 $x$ 到 $y$ 这条路上的答案，可以用到类似树上差分的做法。记 $q=\operatorname{lca}_{x,y}$ 自己手推一下，可以发现答案为：
$$cnt_{x,i}+cnt_{y,i}-2\times cnt_{\operatorname{t},i}+[c_t=i]$$
其中 $i$ 是需要枚举的，从 $1$ 到 $20$。上面公式中的中括号是判断 $x$ 与 $y$ 的 LCA 是否正好有这个商品，如果有就得加 $1$。这算是一种特殊情况。

不会 LCA 的请移步 [P3379](https://www.luogu.com.cn/problem/P3379)。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5,K=22;
int n,q,c[N],u,v,s,t,st[N][K+2],dep[N],cnt[N][K+2];
vector<int> g[N];
void dfs(ll x,ll fx){
    dep[x]=dep[fx]+1,st[x][0]=fx;
    for(ll i=1;i<=K;i++){
        st[x][i]=st[st[x][i-1]][i-1];
    }
    for(ll u:g[x]){
        if(u!=fx) dfs(u,x);
    }
}
int LCA(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    for(ll i=K;i>=0;i--){
        ll fx=st[x][i];
        if(dep[fx]>=dep[y]) x=fx;
    }
    if(x==y) return x;
    for(int i=20;i>=0;i--){
        ll fa=st[x][i],fb=st[y][i];
        if(fa!=fb) x=fa,y=fb;
    }
    return st[x][0];
}
void DFS(int x,int fx){
    for(int u:g[x]){
        if(u==fx||u==x) continue;
        for(int i=1;i<=22;i++){
            cnt[u][i]=cnt[x][i];
        }
        cnt[u][c[u]]++;
        DFS(u,x);
    }
}
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>c[i];
    }
    for(int i=1;i<n;i++){
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1,1);
    cnt[1][c[1]]++;
    DFS(1,1);
    while(q--){
        cin>>s>>t;
        int ans=0,lc=LCA(s,t);
        for(int i=1;i<=22;i++){
            int tt=0;
            if(c[lc]==i) tt=1;
            if(cnt[s][i]+cnt[t][i]-2*cnt[lc][i]+tt>0) ans++;
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：HYdroKomide (赞：8)

### 题意：
给定一棵树，每个点有点权，求任意两点 LCA 路径经过的不同点权数量。

### 思路：
观察到零食种类非常少，可以使用**状压**结合 LCA。

朴素的 LCA 算法基于倍增的 $fa$ 数组，$fa_{u,k}$ 表示从结点 $u$ 开始向根的方向走 $2^k$ 步到达的点。

我们同时维护一个倍增的 $buc$ 桶数组，$buc_{u,k}$ 表示从点 $u$ 开始向根的方向走 $2^k$ 步，经过点的集合。

查询时，在计算 LCA 的同时取所有桶的并集即可（使用 `|` 运算符求并集）。类似 bitset 的算法但更快。

### 程序如下：
```cpp
#include<cstdio>
#include<vector>
using namespace std;
const int LG=20,N=1e5+5;
int n,q,val[N],fa[N][LG],buc[N][LG],dep[N];
vector<int>g[N];
void dfs(int u,int f){
	dep[u]=dep[f]+1;
	fa[u][0]=f;//第一遍dfs找父节点与第一层桶
	buc[u][0]=(1<<(val[u]-1));
	if(f!=0)buc[u][0]|=(1<<(val[f]-1));
	for(auto v:g[u]){
		if(v==f)continue;
		dfs(v,u);
	}
}
int lca(int x,int y){
	int ret=0;
	if(x==y)return 1;//没有覆盖相等的情况，需要特判
	if(dep[x]<dep[y])swap(x,y);
	for(int k=15;k>=0;k--){
		if(dep[fa[x][k]]>=dep[y]){
			ret|=buc[x][k];//正常LCA的同时取并集即可
			x=fa[x][k];
		}
	}
	if(x==y)return ret;
	for(int k=15;k>=0;k--){
		if(fa[x][k]!=fa[y][k]&&fa[x][k]!=0&&fa[y][k]!=0){
			ret|=buc[x][k];
			ret|=buc[y][k];
			x=fa[x][k];
			y=fa[y][k];
		}
	}
	ret|=(buc[x][0]|buc[y][0]);
	return ret;
}
int count(int x){//计算不同元素个数
	int ret=0;
	while(x){
		if(x%2==1)ret++;
		x=x/2;
	}
	return ret;
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)scanf("%d",&val[i]);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);
	for(int k=1;k<=15;k++){
		for(int i=1;i<=n;i++){//预处理倍增数组
			fa[i][k]=fa[fa[i][k-1]][k-1];
			buc[i][k]=(buc[i][k-1]|buc[fa[i][k-1]][k-1]);//桶合并
		}
	}
	while(q--){
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%d\n",count(lca(x,y)));
	}
	return 0;
}
```

### THE END

---

## 作者：JSD_ (赞：6)

[原题链接](https://www.luogu.com.cn/problem/P10391)

## 思路分析

看到树与路径，不难想到本题的解法是 LCA。

如果您还不知道什么是 LCA，请先尝试这道题目：

[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

本题与模板的区别仅仅在于，寻找最近公共祖先的同时还需要记录零食的种类。

以倍增 LCA 为例，在倍增 LCA 中，一个节点的 $2^{k}$ 级祖先可以由该节点 $2^{k-1}$ 级祖先的 $2^{k-1}$ 级祖先推出。

以此类推，从一个节点到其 $2^{k}$ 级祖先节点的路径上的零食种类，可以分解为以下两段：

* 从该节点到其 $2^{k-1}$ 级祖先节点的路径上的零食种类。

* 从第一段末尾的节点到该节点 $2^{k-1}$ 级祖先节点的路径上的零食种类。

如何合并这两段路径的零食种类？

观察数据范围，发现零食种类数 $1≤c_i≤20$，考虑用二进制维护，每一位表示一种不同的零食。

这样，两段路径的合并就可以简单地用 $\operatorname{or}$ 运算来完成了，最终的零食种类数就是二进制中含有 $1$ 的个数。

初始化时间复杂度 $O(n\log{n})$，单次询问时间复杂度 $O(\log{n})$。

代码实现不难，一些细节在代码中解释。

## 代码

```cpp
#include <bits/stdc++.h>
typedef unsigned long long ull;
typedef long long ll;
using namespace std;

vector<int> edge[100005];
int num[100005];//零食编号
int fa[100005][25][2];
//fa[i][j][k]中i表示节点编号，j表示i的第2^j级祖先，k为0表示2^j级祖先节点编号，k为1表示该路径上的零食种类的二进制
int d[100005];//节点深度
int n,q;

void dfs(int u,int v){
    d[u]=d[v]+1;
    fa[u][0][0]=v;
    fa[u][0][1]=num[v];
    for(int p:edge[u]){
        if(p==v) continue;
        dfs(p,u);
    }
}

void init(){
    for(int i=1;i<20;i++){
        for(int j=1;j<=n;j++){
            fa[j][i][0]=fa[fa[j][i-1][0]][i-1][0];
            fa[j][i][1]=fa[fa[j][i-1][0]][i-1][1]|fa[j][i-1][1];//合并操作
        }
    }
}
//记录二进制中1个数
int cnt(int x){
    int r=0;
    while(x){
        if(x&1) r++;
        x>>=1;
    }
    return r;
}
//倍增求LCA
int lca(int a,int b){
    int tmp=num[a]|num[b];//需要注意，起点和终点在倍增的过程中没有被统计，需要手动添加
    if(d[a]<d[b]) swap(a,b);
    for(int i=19;i>=0;i--){
        if(d[fa[a][i][0]]>=d[b]){
            tmp|=fa[a][i][1];//合并操作
            a=fa[a][i][0];
        }
    }
    if(a==b) return cnt(tmp);
    for(int i=19;i>=0;i--){
        if(fa[a][i][0]!=fa[b][i][0]){
            tmp|=fa[a][i][1];
            tmp|=fa[b][i][1];
            //合并操作
            a=fa[a][i][0];
            b=fa[b][i][0];
        }
    }
    tmp|=fa[a][0][1];//需要注意此时公共祖先是a，b的父节点，需手动添加公共祖先的值
    return cnt(tmp);
}

void solve(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        int t;
        cin>>t;
        num[i]=1<<(t-1);
    }
    for(int i=1;i<n;i++){
        int a,b;
        cin>>a>>b;
        edge[a].push_back(b);
        edge[b].push_back(a);
    }
    dfs(1,0);
    init();//预处理
    for(int i=0;i<q;i++){
        int a,b;
        cin>>a>>b;
        cout<<lca(a,b)<<"\n";
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int _=1;
    // cin>>_;
    while(_--){
        solve();
    }
    return 0;
}
```

---

## 作者：zhujiangyuan (赞：3)

[Problem](https://www.luogu.com.cn/problem/P10391)

luogu 第 $7$ 个通过，纪念一下。

前置知识：最近公共祖先，bitset。

仿照 $f_{i,j}$ 的定义，用 $b_{i,j}$ 表示从编号为 $i$ 的节点向上跳 $2^j$ 个点所能买到的零食的种类集合（包括编号为 $b$ 的点，但不包括终点），由于 $c_i$ 只有 $20$，考虑用 bitset 维护 $b_{i,j}$。在预处理 $f_{i,j}$ 时顺便处理 $b_{i,j}$ 即可。

转移：
```cpp
b[x][i] = b[x][i - 1] | b[f[x][i - 1]][i - 1];
```

然后查询 lca 时顺便计一个 $ans$ 更新答案即可。

**坑点：找到 lca 时用祖先节点的种类更新一下答案。**

完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2e5 + 10;
int n, m, c[N], d[N], f[N][22];
bitset <25> b[N][22];
vector <int> G[N];
void dfs (int x, int fa)
{
	d[x] = d[fa] + 1;
	f[x][0] = fa;
	b[x][0].set (c[x], 1);
	for(int i = 1; i <= 20; i++) {
		f[x][i] = f[f[x][i - 1]][i - 1];
		b[x][i] = b[x][i - 1] | b[f[x][i - 1]][i - 1];
	}
	for (auto y : G[x])
		if (y != fa) dfs(y, x);
}
int work (int x, int y)
{
	bitset <25> ans, b1, b2;
	if (d[x] > d[y]) swap(x, y);
	for (int i = 20; i >= 0; i--)
		if (d[f[y][i]] >= d[x]) b2 |= b[y][i], y = f[y][i];
	if (x == y) {
		b2 |= b[y][0]; // 坑点
		return b2.count();
	}
	for (int i = 20; i >= 0; i--)
		if (f[x][i] != f[y][i]) b1 |= b[x][i], b2 |= b[y][i], x = f[x][i], y = f[y][i];
	b1 |= b[x][0], b2 |= b[y][0];
	ans = b1 | b2;
	ans[c[f[x][0]]] = 1; // 坑点
	return ans.count();
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		G[u].emplace_back (v);
		G[v].emplace_back (u);
	}
	dfs (1, 0);
	while (m--) {
		int u, v;
		cin >> u >> v;
		cout << work (u, v) << '\n';
	}
	return 0;
}
```

---

## 作者：Wei_Han (赞：3)

~~面向数据编程~~

注意到 $c_i\leq20$，我们就可以暴力处理每个点到根所有颜色的数量，两点之间路径信息维护就是很板的 LCA 了。记 $pre_{i,j}$ 表示 $i$ 号点到根的 $j$ 颜色的数量，那么我们要统计的就是:
$$\sum\sum[pre_{s_i,j}+pre_{t_i,j}-2\times pre_{lca,j}+c_{lca}>0]$$
也就是 $t_i$ 和 $s_i$ 的前缀和的加和去掉两次 LCA 的前缀和之后（就是 $t_i$ 到 $s_i$ 的路径上）还存在多少数为正（还剩多少颜色）。

时间复杂度 $(m\log n+cm)$。
### Code
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define pr printf("\n")
#define pp printf(" ")
#define pii pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(ll i = a ; i <= b ; i ++ )
#define Fo(a,i,b) for(ll i = a ; i >= b ;-- i  )
#define bug(x,y) (x<1||y<1||x>15||y>15)
using namespace std;
typedef long long ll;
typedef double db;
const int N=3e5+5,M=1e7+5;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
ll n,q,c[N],head[N],tot,pre[25][N];
ll id[N],w[N],siz[N],dep[N],fa[N],son[N],top[N],rb[N],cnt;
struct Graph{ll ver,nxt;}g[N<<1];
inline void add(ll x,ll y){g[++tot].ver=y,g[tot].nxt=head[x];head[x]=tot;}
inline void dfs1(ll x,ll father,ll depth){
	dep[x]=depth,fa[x]=father,siz[x]=1;
	ll zson=-1;
	for(ll i=head[x];i;i=g[i].nxt){
		ll y=g[i].ver;if(y==father) continue;
		fo(1,j,20) pre[j][y]=pre[j][x];
		pre[c[y]][y]++;
		dfs1(y,x,depth+1);siz[x]+=siz[y];
		if(siz[y]>zson) zson=siz[y],son[x]=y;
	}
}
inline void dfs2(ll x,ll nowtop){
	top[x]=nowtop;id[x]=++cnt,w[cnt]=x;
	if(!son[x]){rb[x]=cnt;return;}
	dfs2(son[x],nowtop);
	for(ll i=head[x];i;i=g[i].nxt){
		ll y=g[i].ver;if(y==fa[x]||y==son[x]) continue;
		dfs2(y,y);
	}
	rb[x]=cnt;
}
inline ll lca(ll x,ll y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);return y;
}
signed main(){
	read(n),read(q);
	fo(1,i,n) read(c[i]);
	fo(1,i,n-1){ll u,v;read(u),read(v);add(u,v),add(v,u);}
	pre[c[1]][1]++;
	dfs1(1,0,1);dfs2(1,0);
	ll ans1[25]={0},ans2[25]={0};
	fo(1,i,q){
		ll u,v,ans=0;read(u),read(v);
		ll LCA=lca(u,v);
		fo(1,j,20) ans1[j]=0;
		fo(1,j,20) ans1[j]+=pre[j][u]+pre[j][v]-2*pre[j][LCA];
		ans1[c[LCA]]++;
		fo(1,j,20) if(ans1[j]) ans++;
		// ll LCA=lca(u,v);
		wr(ans);pr;
	}
	return 0;
}
``````

---

## 作者：SamHH0912 (赞：2)

### 题目简述

给定一棵含 $n$ 个节点的树，点 $i$ 有点权 $c_i$，$q$ 次询问，每次询问从 $s_i$ 到 $t_i$ 路径上不同数的个数。

数据规模：$1\le n,q\le 10^5$，$1\le c_i\le 20$。

### 题目分析

本题询问路径上的信息，可以用树链剖分解决本题。笔者在本题中使用的是重链剖分。

[OI Wiki - 树链剖分](https://oi-wiki.org/graph/hld/)

[树链剖分模板题（P3384）](https://www.luogu.com.cn/problem/P3384)

在使用重剖将树剖分为若干重链后，我们可以使用线段树存储信息，以方便查询。

注意到本题中的特殊限制：

> $1\le c_i\le 20$。

于是我们可以用一个整数 $st$ 表示一段路径上的“状态”：**将 $st$ 转为二进制后，右起第 $(i+1)$ 位为 $1$ 表示这段路径中存在以 $i$ 为点权的点，为 $0$ 表示不存在。**

在上传标记和查询时，父节点的 $st$ 值就是子节点的两个 $st$ 值执行或运算后的结果（或运算：若两个数的对应二进制位中有至少一个数为 $1$，则结果的此位也为 $1$）。在用重剖查询时，只需将各小段的 $st$ 值全部或起来后，数一下结果转成二进制后有多少位为 $1$ 即可。

### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100007;
int c[N];//点权

int cnt,head[N];
struct qwq{int v,nxt;}edge[N<<1];
inline void AddE(int u,int v){
	edge[++cnt]={v,head[u]};
	head[u]=cnt;
}//链式前向星存边

int dep[N],fa[N],sz[N],hson[N];
int cc,h[N],s[N],nxt[N];

inline void dfs1(int x){
	for(int i=head[x];i;i=edge[i].nxt){
		int y=edge[i].v;if(dep[y]) continue;//不要搜父节点
		dep[y]=dep[x]+1,fa[y]=x;
		s[++cc]=y,nxt[cc]=h[x],h[x]=cc;//把连向子节点的边再存一遍
		dfs1(y);sz[x]+=sz[y]+1;
		if(sz[y]>sz[hson[x]]) hson[x]=y;
	}
}

int ctr,dfn[N],top[N],rnk[N];

inline void dfs2(int x,int t){
	dfn[x]=++ctr,top[x]=t,rnk[ctr]=x;
	if(hson[x]) dfs2(hson[x],t);
	for(int i=h[x];i;i=nxt[i]){//还是链式前向星
		int y=s[i];
		if(y!=hson[x]) dfs2(y,y);
	}
}
  
//以上为重剖代码

struct node{int l,r,st;}t[N<<2];
#define L(x) x<<1
#define R(x) x<<1|1

inline void build(int x,int l,int r){//建立线段树
	t[x]={l,r,0};
	if(l==r) {t[x].st=1<<c[rnk[l]];return;}
	int mid=(l+r)>>1;
	build(L(x),l,mid),build(R(x),mid+1,r);
	t[x].st=t[L(x)].st|t[R(x)].st; //父节点的 st 值为两子节点的 st 值执行或运算后的结果
}

inline int query(int x,int l,int r){//线段树查询
	if(l<=t[x].l&&t[x].r<=r) return t[x].st;
	int mid=(t[x].l+t[x].r)>>1,st=0;
	if(l<=mid) st|=query(L(x),l,r);
	if(r>mid) st|=query(R(x),l,r);//查询时，只需将左右两区间的查询结果或起来即可
	return st;
}

//以上为线段树代码

inline int Query(int x,int y){//查询从 x 到 y 的路径中，不同数的个数
	int st=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		st|=query(1,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	st|=query(1,dfn[x],dfn[y]);
	int ans=0;
	while(st) ans+=st&1,st>>=1;//数二进制下 st 中 1 的个数
	return ans;
}

int solve(){
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		AddE(u,v),AddE(v,u);
	}
	
	sz[0]=-1,dep[1]=1;//这一行必须要有
	dfs1(1);dfs2(1,1);
	build(1,1,n);//不要忘了建线段树
	
	while(q--){
		int x,y;
		cin>>x>>y;
		cout<<Query(x,y)<<'\n';
	}
	
	return 0;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	
	solve();
	
	return 0;
}
```

---

## 作者：FFTotoro (赞：2)

简单树链剖分 + ST 表题。

因为 $c_i$ 很小，所以考虑状态压缩，用一个二进制数表示一条路径上的 $c_i$ 构成的集合，如果第 $i$ 位为 $1$ 就代表第 $c_i-1$ 种零食包含在该路径上；于是查一条路径上的并集就变成了查一条路径上所有二进制数按位或（$\mathrm{or}$）的 $\mathrm{popcount}$（$\mathrm{popcount}$ 表示一个二进制数中 $1$ 的个数，这里的含义即为该路径上包含的零食种类数）。

树上路径查询考虑用树链剖分维护，而 $\mathrm{or}$ 操作满足消去律，所以静态区间 $\mathrm{or}$ 可以使用 ST 表维护。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int op(int x,int y){return x|y;}
// 按位或操作
namespace IAOI_lib{
  template<typename T,T(*op)(T,T)> class sparse_table{
    private:
      vector<vector<T> > s;
    public:
      void reset(vector<T> a){
        int k=__lg(a.size());
        s.resize(a.size(),vector<T>(k+1));
        for(int i=0;i<a.size();i++)
          s[i][0]=a[i];
        for(int i=1;i<=k;i++)
          for(int j=0;j+(1<<i)<=a.size();j++)
            s[j][i]=op(s[j][i-1],s[j+(1<<i-1)][i-1]);
      }
      sparse_table(){}
      sparse_table(vector<T> a){reset(a);}
      T query(int l,int r){
        int k=__lg(r-l+1);
        return op(s[l][k],s[r-(1<<k)+1][k]);
      }
  };
} // ST 表模板
class hld{
  private:
    int n;
    vector<int> f,d,e,l,h,t;
    IAOI_lib::sparse_table<int,op> s;
  public:
    hld(vector<vector<int> > &g,vector<int> &w){
      n=w.size(),f.resize(n),d.resize(n),e.resize(n,1);
      h.resize(n,-1),t.resize(n),l.resize(n);
      function<void(int,int)> dfs=[&](int u,int p){
        f[u]=p,d[u]=d[p]+1; int mx=0;
        for(int i:g[u])
          if(i!=p)if(dfs(i,u),e[u]+=e[i];e[i]>mx)mx=e[i],h[u]=i;
      };
      vector<int> a;
      function<void(int,bool)> decomp=[&](int u,bool b){
        t[u]=(b?t[f[u]]:u),l[u]=a.size(),a.emplace_back(w[u]);
        if(~h[u])decomp(h[u],true);
        for(int i:g[u])
          if(i!=f[u]&&i!=h[u])decomp(i,false);
      };
      dfs(0,0),decomp(0,false),s.reset(a);
    }
    inline int query(int u,int v){
      int c=0;
      while(t[u]!=t[v]){
        if(d[t[u]]>d[t[v]])swap(u,v);
        c|=s.query(l[t[v]],l[v]);
        v=f[t[v]];
      }
      if(d[u]>d[v])swap(u,v);
      return c|s.query(l[u],l[v]);
    } // 链查询
}; // 树链剖分模板
int main(){
  ios::sync_with_stdio(false);
  int n,q; cin>>n>>q;
  vector<int> w(n);
  for(auto &i:w)cin>>i,i=1<<i-1;
  // 初始化所有结点的值
  // 第 i 个结点的值为 1<<(c[i]-1)
  vector<vector<int> > g(n);
  for(int i=1;i<n;i++){
    int u,v; cin>>u>>v;
    g[--u].emplace_back(--v);
    g[v].emplace_back(u);
  }
  hld h(g,w);
  while(q--){
    int u,v; cin>>u>>v;
    cout<<__builtin_popcount(h.query(u-1,v-1))<<'\n';
  } // 处理查询
  return 0;
}
```

---

## 作者：sansesantongshun (赞：1)

~~本题解做法为树上莫队，不是出题人本意，想要学习此题标准做法的巨佬请飘过。~~

本蒟蒻做完[树上莫队模版题](https://www.luogu.com.cn/problem/SP10707)，发现有一个弱化版，就把此题 AC，顺便写个题解巩固以下。

本题询问的是路径颜色数，我们发现在序列上这个东西用莫队很容易维护。怎么把莫队搬到树上呢？我们需要一个叫欧拉序的东西。

欧拉序是什么？就是这个：
```cpp
void dfs1(int x,int f)
{
	int y;
	p[x][0]=++cnt;//节点第一次出现的位置
	aa[cnt]=x;//这个位置是哪个节点
	for (int i=head[x];i;i=edge[i].next)
	{
		y=edge[i].to;
		if (y!=f)
        dfs1(y,x);
	}
	p[x][1]=++cnt;//节点第二次出现的位置
	aa[cnt]=x;
}
```
我们举个例子，比如样例中树的欧拉序就是 $12442331$。

那么如何用欧拉序把树上问题转化到序列上呢？我们分两种情况：

如果两个路径端点的 lca 是其中一个端点，那么查询的区间就是两者第一次出现位置中间。比如查询 $1$ 到 $3$，求出的区间就变成 $124423$，其中 $1$、$3$ 出现一次，我们需要计算它的贡献；而 $2$、$4$ 出现两次，我们需要把它们忽略，不计算贡献。

如果两个路径端点的 lca 不是其中任何一个端点，那么查询的区间就是前面的点第二次出现的位置和后面的点第一次出现的位置中间。比如查询 $3$ 到 $4$，求出的区间就变成 $423$，由于都出现一次都需要计算，但落掉了 lca $1$，所以还要把 lca 的贡献也加上。

然后就可以愉快地跑莫队了。

代码较长，细节较多，注意不要弄错弄混。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],x,y,z,head[100005],cnt0=0,b[100005],c[100005],d[100005],e[100005],f[100005],cnt=0,p[100005][2],nm,aa[200005],bb[200005],dd[100005],ee[100005],l=1,r=0,aans=0,ans[100005];
struct node1
{
	int next,to;
} edge[200005];//链式前向星存图
void add(int from,int to)
{
	edge[++cnt0]=(node1){head[from],to};
	head[from]=cnt0;
}
struct node2
{
	int id,l,r,lca;
} cc[100005];//莫队
bool operator<(node2 x,node2 y)
{
	return bb[x.l]==bb[y.l]?(bb[x.l]&1?x.r<y.r:x.r>y.r):x.l<y.l;
}//奇偶排序
void dfs1(int x,int f)
{
	int y;
	b[x]=f;
	c[x]=c[f]+1;
	d[x]=1;
	p[x][0]=++cnt;
	aa[cnt]=x;
	for (int i=head[x];i;i=edge[i].next)
	{
		y=edge[i].to;
		if (y!=f)
		{
			dfs1(y,x);
			d[x]+=d[y];
			if (d[y]>d[e[x]])
			e[x]=y;
		}
	}
	p[x][1]=++cnt;
	aa[cnt]=x;
}//求欧拉序和重儿子
void dfs2(int x)
{
	int y;
	if (x==e[b[x]])
	f[x]=f[b[x]];
	else
	f[x]=x;
	if (e[x])
	{
		dfs2(e[x]);
		for (int i=head[x];i;i=edge[i].next)
		{
			y=edge[i].to;
			if (y!=b[x] && y!=e[x])
			dfs2(y);
		}
	}
}//求链顶
int lca(int x,int y)
{
	while (f[x]!=f[y])
	{
		if (c[f[x]]<c[f[y]])
		swap(x,y);
		x=b[f[x]];
	}
	if (c[x]>c[y])
	swap(x,y);
	return x;
}//树剖求lca
void add2(int x)
{
	if (ee[x]==0)
	++aans;
	++ee[x];
}//添加颜色
void del2(int x)
{
	--ee[x];
	if (ee[x]==0)
	--aans;
}//删除颜色
void add(int x)
{
	++dd[x];
	if (dd[x]==2)
	del2(a[x]);
	else
	add2(a[x]);
}//添加节点，出现2次要抵消掉
void del(int x)
{
	--dd[x];
	if (dd[x]==1)
	add2(a[x]);
	else
	del2(a[x]);
}//删除节点，出现1次要把贡献加回去
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;++i)
    scanf("%d",&a[i]);
	for (int i=1;i<n;++i)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs1(1,0);
	dfs2(1);
	nm=max(1,(int)round((n<<1)/sqrt(m)));
	for (int i=1;i<=n<<1;++i)//n记得乘2！乘2！乘2！
	bb[i]=(i-1)/nm+1;
	for (int i=1;i<=m;++i)
	{
		scanf("%d%d",&x,&y);
		if (p[x][0]>p[y][0])
		swap(x,y);
		cc[i].id=i;
		z=lca(x,y);
		if (x==z || y==z)//处理2种情况
		{
			cc[i].l=p[x][0];
			cc[i].r=p[y][0];
		}
		else
		{
			cc[i].l=p[x][1];
			cc[i].r=p[y][0];
			cc[i].lca=z;//需要记录lca
		}
	}
	sort(cc+1,cc+m+1);
	for (int i=1;i<=m;++i)//正常莫队操作
	{
		while (l<cc[i].l)
		del(aa[l++]);
		while (l>cc[i].l)
		add(aa[--l]);
		while (r<cc[i].r)
		add(aa[++r]);
		while (r>cc[i].r)
		del(aa[r--]);
		if (cc[i].lca)//需要加上lca的贡献
		add(cc[i].lca);
		ans[cc[i].id]=aans;
		if (cc[i].lca)
		del(cc[i].lca);
	}
	for (int i=1;i<=m;++i)
	cout<<ans[i]<<'\n';
}
```

---

## 作者：toolong114514 (赞：1)

# P10391 [蓝桥杯 2024 省 A] 零食采购 题解
## 题面大意
给定一棵树，$m$ 次询问，每次求一条树上路径上的不同颜色个数，$1\le m\le 10^5$。
## 解题思路
看上去是一道树上莫队板子的双倍经验，于是你复制了代码交到这题来，然后 ```TLE``` 了……

这题的时限对于莫队是很不友好的，~~卡卡常应该能艹过去。~~

注意到颜色编号 $1\le c_i\le 20$，这个时间复杂度一眼就是状压。

我们考虑将每个颜色是否存在压成一个 32 位整数，对于单点直接对应的位改成 1，询问时将路径上所有点的状态按位或起来（算并集），统计一下 1 的个数即可。

求树上路径或和可以写 ST 表或树剖 RMQ，两种做法的最优时间复杂度均为 $O(n\log n)$，可以通过本题。
## 参考代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
const int N=1e5+10;
struct node{
	int to,nxt;
}edge[2*N];
int head[N];
int cnt;
void add(int u,int v){
	edge[++cnt]={v,head[u]};
	head[u]=cnt;
}
int dep[N],st[N][30],rd_val[N][30],pv[N];
void dfs(int x,int last){
	dep[x]=dep[last]+1;
	st[x][0]=last;
	rd_val[x][0]=pv[x]|pv[last];
	for(int i=head[x];i!=-1;i=edge[i].nxt){
		if(edge[i].to==last) continue;
		dfs(edge[i].to,x);
	}
}
int n,q;
void build_st(){
	for(int j=1;j<=20;j++){
		for(int i=1;i<=n;i++){
			rd_val[i][j]=rd_val[i][j-1]|rd_val[st[i][j-1]][j-1];
			st[i][j]=st[st[i][j-1]][j-1];
		}
	}
}
int count(int x){
	int res=0;
	for(int i=0;i<=20;i++){
		if(x&(1<<i)) res++;
	}
	return res;
}
int ask(int x,int y){
	int res=0;
	if(x==y) return 1;
	if(dep[x]<dep[y]) swap(x,y);
	for(int j=20;j>=0;j--){
		if(dep[st[x][j]]>=dep[y]){
			res|=rd_val[x][j];
			x=st[x][j];
		}
	}
	if(x==y) return count(res);
	for(int j=20;j>=0;j--){
		if(st[x][j]!=st[y][j]){
			res|=rd_val[x][j]|rd_val[y][j];
			x=st[x][j];y=st[y][j];
		}
	}
	return count(res|rd_val[x][0]|rd_val[y][0]);
}
int main(){
	memset(head,-1,sizeof(head));
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>pv[i];
		pv[i]=1<<(pv[i]-1);
	}
	for(int i=1;i<n;i++){
		int uu,vv;
		cin>>uu>>vv;
		add(uu,vv);
		add(vv,uu);
	}
	dfs(1,0);
	build_st();
	while(q--){
		int ss,tt;
		cin>>ss>>tt;
		cout<<ask(ss,tt)<<'\n';
	}
	return 0;
}
```
[本代码可以通过洛谷评测。](https://www.luogu.com.cn/record/171037182)

Written by [toolong114514](https://www.luogu.com/user/477821) on 2024/8/7.

---

## 作者：cheng2010 (赞：1)

# 零食采购
## 思路
树上莫队板子题，没有绑定 spoj 的可以用这题练手。

首先，莫队是用来处理区间问题的，那么把路径怎么变成区间？

**欧拉序。**

就是对于一个节点，遍历它子树前把它加入队列，遍历它子树后再把它加入队列，这样你对发现两个节点的路径中只出现了一次的数就是它们路径上的点，用打标记的方法处理了。

- ### 注意

1. 它们的 LCA 并不会被记录（除非一个是另一个的祖先）要特判。

2. 欧拉序长度是 $2n$ 所以块长要设为 $\sqrt{2n}$。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7;
int n,m;
int a[N],b[N];
struct EDGE
{
	int frm,to;
}edge[N];
struct Node
{
	int l,r,id,lca;
}q[N];
int head[N],cnt;
int first[N],second[N];
inline void add(int x,int y)
{
	edge[++cnt].to=y;
	edge[cnt].frm=head[x];
	head[x]=cnt;
}
int ol[N],cnto;
int dep[N],siz[N],fa[N];
int son[N],top[N];
int dfn[N],id;
inline void dfs1(int x,int f)
{
	ol[++cnto]=x;
	first[x]=cnto;
	siz[x]=1;
	for(int i=head[x];i;i=edge[i].frm)
	{
		int v=edge[i].to;
		if(v==f) continue;
		dep[v]=dep[x]+1;
		fa[v]=x;
		dfs1(v,x);
		if(siz[son[x]]<siz[v])
			son[x]=v;
		siz[x]+=siz[v];
	}
	ol[++cnto]=x;
	second[x]=cnto;
}
inline void dfs2(int x,int tp)
{
	dfn[x]=++id;
	top[x]=tp;
	if(son[x]) dfs2(son[x],tp);
	for(int i=head[x];i;i=edge[i].frm)
	{
		int v=edge[i].to;
		if(v==fa[x]||v==son[x]) continue;
		dfs2(v,v);
	}
}
inline int lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]>dep[y]?y:x;
}
int base;
int cct[N];
bool vis[N];
int ans[N];
inline int work(int x)
{
	int res=(vis[x]?((!--cct[a[x]])*(-1)):(!cct[a[x]]++));
	vis[x]^=1;
	return res;
}
inline bool cmp(Node A,Node B){return A.l/base==B.l/base?A.r/base<B.r/base:A.l/base<B.l/base;}
int main()
{
	scanf("%d %d",&n,&m);
	base=sqrt(2*n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+1+n);
	int le=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++)
	{
		a[i]=lower_bound(b+1,b+1+le,a[i])-b;
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dep[1]=1;
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&q[i].l,&q[i].r);
		if(first[q[i].l]>first[q[i].r]) swap(q[i].l,q[i].r);
		int l=lca(q[i].l,q[i].r);
		
		if(l==q[i].l)
		{
			q[i].l=first[q[i].l];
			q[i].r=first[q[i].r];
		}
		else
		{
			q[i].l=second[q[i].l];
			q[i].r=first[q[i].r];
			q[i].lca=l;
		}
		q[i].id=i;
	}
//	cout<<"eawf:::\n";
//	for(int i=1;i<=n;i++)
//	{
//		cout<<first[i]<<" "<<second[i]<<endl;
//	}
//	puts("");
	sort(q+1,q+1+m,cmp);
	int l=1,r=0,now=0;
	for(int i=1;i<=m;i++)
	{
		int ql=q[i].l,qr=q[i].r,llca=q[i].lca;
//		cout<<ql<<" "<<qr<<" "<<llca<<endl;
		while(l<ql) now+=work(ol[l++]);
		while(l>ql) now+=work(ol[--l]);
		while(r<qr) now+=work(ol[++r]);
		while(r>qr) now+=work(ol[r--]);
		if(llca) now+=work(llca);
		ans[q[i].id]=now;
		if(llca) now+=work(llca);
	}
	for(int i=1;i<=m;i++)
	{
		printf("%d\n",ans[i]);
	}
}
```

---

## 作者：神仙酱 (赞：1)

太菜了，考场上唯一一道有把握的题，考到题目之后立刻就想到了树上莫队（因为真的很裸，完全不需要思考），直接就切了（然而最后省三，我不会就做对了这一题吧）。

### 前言
莫队是一种奇妙的算法，可以在 $O(n\sqrt{n})$ 的时间解决有多组询问的区间查询题目，它不一定是正解，但是足够暴力和好想。只要答案可以以 $O(1)$ 的复杂度，通过左移右移一次查询的区间端点统计出来，就满足莫队的使用条件。如果你还不会莫队，我强烈建议你参考莫队的神之入门教程[莫队算法——从入门到黑题](https://www.cnblogs.com/WAMonster/p/10118934.html)

### 思路与注意事项
我还是简单介绍一下树上莫队的基本过程：

1. DFS 统计出每个结点的高度 `dep` 和即将用于求 LCA 的倍增祖先数组 `fa`，还需要求出欧拉序 `id` 和每个结点在欧拉序中管辖的范围 `in` 和 `out`。
2. 读入查询，分块、排序（莫队基本操作，尤其注意块大小是 `n << 1`）。由于树上莫队实际上是在欧拉序上进行的，因此要把读入的查询从结点编号变换到其在欧拉序上的位置。
3. 根据排好的顺序依次处理每一个查询，这已经是很裸的莫队了。非常有趣的一点是，[SP10707](https://www.luogu.com.cn/problem/SP10707) 除了数据范围很大必须用莫队做之外，其他地方其实是**一模一样**的
4. 根据读入的顺序输出每一个查询的结果。

在这里我要再强调一下树上莫队与普通莫队的不同点。
- 欧拉序的长度是结点长度的两倍，因此分块大小是 `sqrt(n << 1)`。
- 只需要使用一个 `vis[i]` 数组记录第 `i` 个位置（欧拉序的下标）是否被访问过，就可以只写一个 `add` 而不需要写 `del`。这是得益于欧拉序的美好性质。
- 要把读入的查询从结点编号变换到其在欧拉序上的位置。为了保证变换后的位置 `l < r`，如果第一个所要查询结点的`in` 大于第二个所要查询结点的 `in`，要交换这两个结点。
- 在第三步中，**不要忘记统计来自 LCA 的答案**。

### AC代码
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = N << 1;
int e[M], h[N], nxt[M], idx = 1, c[N];
int in[N], out[N], id[N << 1], dfn;
int dep[N], fa[N][22], bsz, ans[N];
int ht[30], vis[N], now;

int n, m;
struct query_t {
    int l, r, id;
    bool operator<(const query_t& rhs) const {
        return l / bsz != rhs.l / bsz ? l < rhs.l : (l / bsz & 1) ? r < rhs.r : r > rhs.r;
    }
} q[M];

void add(int a, int b) {
    e[idx] = b, nxt[idx] = h[a], h[a] = idx++;
}

void add(int x) {
    if (vis[x])
        now -= !--ht[c[x]];
    else
        now += !ht[c[x]]++;
    vis[x] ^= 1;
}

void dfs(int u, int pa) {
    id[in[u] = ++dfn] = u;
    dep[u] = dep[pa] + 1;
    fa[u][0] = pa;
    for (int i = h[u]; i; i = nxt[i]) {
        int son = e[i];
        if (son == pa)
            continue;
        dfs(son, u);
    }
    id[out[u] = ++dfn] = u;
}

int lca(int x, int y) {
    if (dep[x] > dep[y])
        swap(x, y);
    for (int i = 20; i + 1; i--) {
        if (dep[y] - (1 << i) >= dep[x])
            y = fa[y][i];
    }
    if (x == y)
        return x;
    for (int i = 20; i + 1; i--)
        if (fa[x][i] != fa[y][i])
            x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}
int main() {
    cin >> n >> m;
    bsz = sqrt(n << 1);
    for (int i = 1; i <= n; ++i)
        cin >> c[i];
    for (int i = 1; i < n; ++i) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    dfs(1, 0);
    for (int j = 1; j <= 20; j++) {
        for (int i = 1; i <= n; ++i)
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
    }
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        if (in[a] > in[b])
            swap(a, b);

        int l = lca(a, b) == a ? in[a] : out[a];
        int r = in[b];

        q[i] = { l, r, i };
    }
    sort(q + 1, q + 1 + m);
    int l = 1, r = 0;
    for (int i = 1; i <= m; ++i) {
        while (r < q[i].r)
            add(id[++r]);
        while (l > q[i].l)
            add(id[--l]);
        while (r > q[i].r)
            add(id[r--]);
        while (l < q[i].l)
            add(id[l++]);
        int x = id[l], y = id[r];
        int ca = lca(x, y);
        if (x != ca && y != ca) {
            add(ca);
            ans[q[i].id] = now;
            add(ca);
        }
        else
            ans[q[i].id] = now;
    }
    for (int i = 1; i <= m; ++i)
        cout << ans[i] << "\n";
}
```

---

## 作者：shiranai (赞：0)

## 思路
&emsp;&emsp;可以用 LCA 求解。不妨设 $f[i][j]$ 是结点 $j$ 向**祖先方向**前进 $2^i$ 步到达的结点编号，而 $g[i][j]$ 统计了这个前进过程经过的所有结点的零食种类。显然有下面的递推方程：
$$\begin{cases}f[i][j]=f[i-1][f[i-1][j]]\\
g[i][j]=g[i-1][j] | g[i-1][f[i-1][j]]\end{cases}$$

&emsp;&emsp;初始化操作的时间复杂度是 $O(n\log n)$。对于每一次询问，用 $O(n\log n)$ 的复杂度查询出结果，所以总的时间复杂度就是 $O(nq\log n)$。 
## 参考代码
&emsp;&emsp;具体的代码参考如下：
```cpp
#include<iostream>
using namespace std;

const int N = 100005;

int n,q,ecnt = 1,fedge[N],ledge[N],layer[N],color[N],f[20][N],g[20][N];
struct {
	int end,next;
}edge[2*N];

// 构建树的边,begin -> end。
void buildarc(int begin,int end){
	if(!begin)
		return;
	if(!fedge[begin])
		fedge[begin]=ledge[begin]=ecnt;
	else{
		edge[ledge[begin]].next=ecnt;
		ledge[begin]=ecnt;
	}
	edge[ecnt++].end=end;
}

// cur:当前结点,l:当前层数,fa:父亲结点 
void dfs(int cur,int l,int fa){
	layer[cur] = l;
	for(int e = fedge[cur];e;e = edge[e].next){
		if(edge[e].end == fa)
			continue;
		f[0][edge[e].end] = cur;
		g[0][edge[e].end] = color[cur] | color[edge[e].end];// 顺便初始化了一下 g[0][...]
		dfs(edge[e].end,l + 1,cur);
	}
}

// 这个函数用于求从 a 到 b 的路径上所有的小礼物，用状态压缩表示，一个二进制位代表一种礼物。是 LCA 的核心算法。
int look(int a,int b){
	int ans = 0;
	//节点 a 在更浅的层 
	int temp = layer[b] - layer[a];
	for(int base = 0;temp;base++,temp >>= 1)
		if(temp & 0x1){
			ans |= g[base][b];
			b = f[base][b];
		}
	if(a == b)
		return ans | color[a];
	temp = 19;
	while(true){
		while(temp >= 0 && f[temp][a] == f[temp][b])
			temp--;
		if(temp == -1)
			return g[0][a] | g[0][b] | ans;
		ans |= g[temp][a] | g[temp][b];
		a = f[temp][a];
		b = f[temp][b];
	}
}

// 求一个数 num 二进制表示中 1 的个数
int cnt(int num){
	int ret = 0;
	while(num){
		ret += num & 0x1;
		num >>= 1;
	}
	return ret;
}

int main(){
	int u,v,ans;
	cin>>n>>q;
	for(int i = 1;i <= n;i++){
		scanf("%d",&u);
		color[i] = 1 << u;
	}
	for(int i = 1;i < n;i++){
		scanf("%d%d",&u,&v);
		buildarc(u,v);
		buildarc(v,u);
	}
	dfs(1,1,0); // 获取每个节点所在的层 
	for(int i = 1;i <= 19;i++)
		for(int j = 1;j <= n;j++){
				f[i][j] = f[i-1][f[i-1][j]];
				g[i][j] = g[i-1][j] | g[i-1][f[i-1][j]];
		}
	for(int i = 1;i <= q;i++){
		scanf("%d%d",&u,&v);
		if(layer[u] > layer[v])
			ans = look(v,u);
		else
			ans = look(u,v);
		printf("%d\n",cnt(ans));
	}
	return 0;
} 
```
> 蒟蒻的码风可能有点丑，请见谅。

---

## 作者：_zuoqingyuan (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/P10391)

# 题意简述
> 给定一棵 $n$ 个节点的无根树，树上的任意节点 $x$ 都有一个颜色 $c_x$。
>
> 有 $q$ 次询问，每次给出树上两节点 $s,t$。询问 $s,t$ 之间路径上有多少中不同颜色的节点。
>
> $1\le n,q\le 10^5,1\le c_x\le 20$

# 思路分析

这道题有两种做法的，分别是树上 LCA 或树链剖分，这里我用的是树链剖分。

注意到颜色的种类很少（最多 $20$ 种），且没有修改操作，我们可以建立 $20$ 个 ST 表，用 $f_{c,i,j}$ 表示 $[i,i+2^j-1]$ 之间是否有颜色为 $c$ 的节点。

接下来就是经典操作，进行两遍 DFS。把树上的节点转化为序列。每次询问，我们跑 $20$ 次查询，最后统计答案。

本题还可以用状态压缩来优化，因为种类很少，压缩成串表示某种情况的是否拥有。

DFS 时间复杂度 $O(n)$。建立 ST 表时间复杂度 $O(n\log n)$。单次查询时间复杂度 $O(\log n)$。

实测 376 ms，空间 17.39 MB，两个方面都是目前最优解。

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
const int N=1e5+10,M=2*N;
int idx,to[M],nxt[M],ver[N],n,q,fa[N],de[N],siz[N],son[N],dfn[N],top[N],tot,c[N],st[N][18];
void read(int &a){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    a=x*f;return;
}
void add(int x,int y){
    to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx;
}
int num(int x){
    int cnt=0;
    while(x)x-=(x&-x),cnt++;
    return cnt;
}
int ask(int l,int r){
    int t=log2(r-l+1);
    return (st[l][t]|st[r-(1<<t)+1][t]);
}
void dfs1(int x,int f){
    fa[x]=f,de[x]=de[f]+1,siz[x]=1;
    for(int i=ver[x];i;i=nxt[i]){
        if(to[i]==f)continue;
        dfs1(to[i],x);
        siz[x]+=siz[to[i]];
        if(siz[to[i]]>siz[son[x]])son[x]=to[i];
    }
    return;
}
void dfs2(int x,int f,int ce){
    top[x]=ce,dfn[x]=++tot,st[dfn[x]][0]=(1<<(c[x]-1));
    if(!son[x])return;
    dfs2(son[x],x,ce);
    for(int i=ver[x];i;i=nxt[i]){
        if(to[i]==f||to[i]==son[x])continue;
        dfs2(to[i],x,to[i]);
    }
    return;
}
int main(){
    read(n),read(q);
    for(int i=1;i<=n;i++)read(c[i]);
    for(int i=1,u,v;i<n;i++){
        read(u),read(v);
        add(u,v),add(v,u);
    }
    dfs1(1,0);
    dfs2(1,0,1);
    for(int j=1;j<=17;j++){
        for(int i=1;i+(1<<j)-1<=n;i++){
            st[i][j]=(st[i][j-1]|st[i+(1<<(j-1))][j-1]);
        }
    }
    while(q--){
        int a,b,f=0;
        read(a),read(b);
        while(top[a]!=top[b]){
            if(de[top[a]]<de[top[b]])swap(a,b);
            f=(f|ask(dfn[top[a]],dfn[a]));
            a=fa[top[a]];
        }
        if(de[a]>de[b])swap(a,b);
        f=(f|ask(dfn[a],dfn[b]));
        printf("%d\n",num(f));
    }
    return 0;
}
```

---


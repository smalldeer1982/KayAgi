# [蓝桥杯 2024 省 Java B] 拼十字

## 题目背景

备注：原题（Java）时间限制 3.0s，空间限制 512 MB。

## 题目描述

在 LQ 国神秘的古老森林，有一座被称为 “拼十字” 的神秘遗迹。据传， “拼十字” 是由古代文明建造的，它是一个巨大的石头结构，由两个巨大的矩形交叉叠放在一起，形成了一个庄严而神秘的十字形状。这个遗迹被认为是连接人类和神灵之间的通道，拥有神秘的力量和能量。

![](https://cdn.luogu.com.cn/upload/image_hosting/qn9sqnae.png)

现在给出 $N$ 个矩形，其中第 $i$ 个矩形的长度和宽度分别为 $l_i$，$w_i$，并且矩形的颜色 $c_i$ 为红 $(0)$、黄 $(1)$、蓝 $(2)$ 中的一种。现在小蓝想知道在这 $N$ 个矩形中有多少对可以“拼十字”？

两个矩形可以“拼十字”的充要条件是：

1. 两个矩形的颜色不同；
2. 矩形 $1$ 的长度严格大于矩形 $2$ 的长度并且矩形 $1$ 的宽度严格小于矩形 $2$ 的宽度。

注意，矩形长度和宽度属性是固定的，是不可以通过旋转矩形而发生转变的。

## 说明/提示

【样例解释】

第 $3$ 个矩形可以和第 $1$ 个矩形拼十字，第 $3$ 个矩形也可以和第 $4$ 个矩形拼十字。所以一共有两对矩形可以拼十字，答案为 $2$。

【数据范围】

- 对于 $30\%$ 的评测用例：$1 \leq N \leq 5000$。
- 对于 $100 \%$ 的评测用例：$1 \leq N \leq 10^5$，$1 \leq l,w \leq 10^5$，$0 \leq c \leq 2$。

## 样例 #1

### 输入

```
5
1 10 0
6 6 0
8 6 1
6 10 0
1 2 1```

### 输出

```
2```

# 题解

## 作者：Lysea (赞：3)

提供一种双指针二位偏序写法。

首先分三类讨论，将颜色 $0$、$1$、$2$ 分开来，避免多统计。

接着我们考虑将当前颜色矩阵与非当前颜色矩阵都按照 $l$ 从小到大排序，这样后满足 $l_i< l_j$ 的 $j$ 指针就可以做到单调不降了。

至于 $c_i>c_j$，用树状数组维护即可。

注意取模，注意不取等。

代码：


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
#define INF 1e18
#define lowbit(x) (x&(-x))
using namespace std;
struct node{
	int l,w;
}e[N],d[N];
const int mx=1e5,M=1e9+7;
int n,l[N],w[N],c[N],cnte,cntd,t[N],ans;
bool cmp(node x,node y){
	return x.l<y.l;
}
void add(int x,int y){
	for(int i=x;i<=mx;i+=lowbit(i)) t[i]+=y;
}
int query(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i)) res+=t[i];
	return res;
}
void solve(int x){
	cnte=cntd=0;
	for(int i=1;i<=n;i++){
		if(c[i]==x) e[++cnte]={l[i],w[i]};
		else d[++cntd]={l[i],w[i]};
	}
	sort(d+1,d+cntd+1,cmp),sort(e+1,e+cnte+1,cmp);
	int j=1;
	for(int i=1;i<=cnte;i++){
		while(j<=cntd&&d[j].l<e[i].l) add(d[j].w,1),j++;
		ans=(ans+query(mx)-query(e[i].w))%M;
	}
	for(int i=1;i<j;i++) add(d[i].w,-1);
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>l[i]>>w[i]>>c[i];
	for(int T=0;T<=2;T++) solve(T);
	cout<<ans;
	return 0;
}

```

---

## 作者：Aventurine_stone (赞：3)

## 1. 题目分析
很显然，$O(n^2)$ 暴力可以轻松骗到 30 分，想要拿到 100 分只需要加一个简单的数据结构优化就行了。~~不会树状数组，就用线段树写了。~~
## 2. 题目做法
我们先将输入的所有矩形分成三种颜色存放在三个数组中。  
我们发现，如果不经处理，直接用线段树维护矩形的长和宽是不太现实的。  
我们只需要将每种颜色的矩形按长从小到大排序，这样每次计算两种颜色间组合方案时长具有单调性，就不需要用数据结构维护了。矩形的宽也只需要用一个权值线段树维护就行了。  
最后一点，在每次颜色间计算结束后，一定要正确地清空，不然很可能算出负数。  
总时间复杂度 $O(n\log{n})$。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010,mod=1e9+7;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int n,cnt[3];
struct F{
	int l,w;
}a[3][N];
inline bool cmp(F a1,F a2)
{
	return a1.l<a2.l;
}
struct tree{
	int idx,l,r,s;
}t[N<<2];
inline void build(int idx,int l,int r)
{
	t[idx].l=l,t[idx].r=r;
	if(l==r)
		return ;
	int mid=(l+r)>>1,u=idx<<1;
	build(u,l,mid);
	build(u+1,mid+1,r);
}
inline void add(int idx,int x)
{
	if(t[idx].l==t[idx].r)
	{
		t[idx].s++;
		return ;
	}
	int u=idx<<1;
	if(x<=t[u].r)
		add(u,x);
	else
		add(u+1,x);
	t[idx].s++;
}
inline void del(int idx,int x)
{
	if(t[idx].l==t[idx].r)
	{
		t[idx].s--;
		return ;
	}
	int u=idx<<1;
	if(x<=t[u].r)
		del(u,x);
	else
		del(u+1,x);
	t[idx].s--;
}
inline int ask(int idx,int l,int r)
{
	if(t[idx].r<l||t[idx].l>r)
		return 0;
	if(t[idx].l>=l&&t[idx].r<=r)
		return t[idx].s;
	int u=idx<<1;
	return ask(u,l,r)+ask(u+1,l,r);
}
int x,y,z;
long long sum;
int main()
{
	n=read();
	while(n--)
	{
		x=read(),y=read(),z=read();
		a[z][++cnt[z]]={x,y};
	}
	sort(a[0]+1,a[0]+cnt[0]+1,cmp);
	sort(a[1]+1,a[1]+cnt[1]+1,cmp);
	sort(a[2]+1,a[2]+cnt[2]+1,cmp);
	build(1,1,100000);
	x=1;
	for(int i=1;i<=cnt[1];i++)
		add(1,a[1][i].w);
	for(int i=1;i<=cnt[0];i++)
	{
		while(a[0][i].l>=a[1][x].l&&x<=cnt[1])
			del(1,a[1][x].w),x++;
		sum+=ask(1,1,a[0][i].w-1);
	}
	for(int i=x;i<=cnt[1];i++)
		del(1,a[1][i].w);
	x=1;
	for(int i=1;i<=cnt[2];i++)
		add(1,a[2][i].w);
	for(int i=1;i<=cnt[0];i++)
	{
		while(a[0][i].l>=a[2][x].l&&x<=cnt[2])
			del(1,a[2][x].w),x++;
		sum+=ask(1,1,a[0][i].w-1);
	}
	for(int i=x;i<=cnt[2];i++)
		del(1,a[2][i].w);
	x=1;
	for(int i=1;i<=cnt[0];i++)
		add(1,a[0][i].w);
	for(int i=1;i<=cnt[1];i++)
	{
		while(a[1][i].l>=a[0][x].l&&x<=cnt[0])
			del(1,a[0][x].w),x++;
		sum+=ask(1,1,a[1][i].w-1);
	}
	for(int i=x;i<=cnt[0];i++)
		del(1,a[0][i].w);
	x=1;
	for(int i=1;i<=cnt[2];i++)
		add(1,a[2][i].w);
	for(int i=1;i<=cnt[1];i++)
	{
		while(a[1][i].l>=a[2][x].l&&x<=cnt[2])
			del(1,a[2][x].w),x++;
		sum+=ask(1,1,a[1][i].w-1);
	}
	for(int i=x;i<=cnt[2];i++)
		del(1,a[2][i].w);
	x=1;
	for(int i=1;i<=cnt[0];i++)
		add(1,a[0][i].w);
	for(int i=1;i<=cnt[2];i++)
	{
		while(a[2][i].l>=a[0][x].l&&x<=cnt[0])
			del(1,a[0][x].w),x++;
		sum+=ask(1,1,a[2][i].w-1);
	}
	for(int i=x;i<=cnt[0];i++)
		del(1,a[0][i].w);
	x=1;
	for(int i=1;i<=cnt[1];i++)
		add(1,a[1][i].w);
	for(int i=1;i<=cnt[2];i++)
	{
		while(a[2][i].l>=a[1][x].l&&x<=cnt[1])
			del(1,a[1][x].w),x++;
		sum+=ask(1,1,a[2][i].w-1);
	}
	printf("%d",sum%mod);
	return 0;
}
```

---

## 作者：Chiesl (赞：2)

## 题意简述

给定 $n$ 个三元组，第 $i$ 个三元组为 $(l_i, w_i, c_i)$，求所有二元组 $(i, j)$ 中，满足 $i < j$ 且 $l_i < w_i$ 且 $l_i > w_i$ 的个数 $(1 \le i, j \le n)$。

## 思路（前半段为错解，故较为简略）

直接怼着题做可能没发现啥，但是稍稍转换一下思路，你就会发现：这不就是逆序对吗？

先考虑逆序对怎么做：

问题：对于序列 $\{a\}$，求 $a_i > a_j$ 且 $i < j$ 的数对个数。

使用树状数组求解该问题，不知道如何做的可以去 [P1908](https://www.luogu.com.cn/problem/P1908) 学习一下。

**为什么选择使用树状数组**：可能做过 P1908 的人知道逆序对还有使用归并排序的方法，但是在本题中，使用树状数组将会方便我们对每一个数进行分类讨论，使用归并排序将会非常繁杂。

## 实现，但是是错解

对 3 个颜色各开一个树状数组进行维护，同时本题有一个细节，就是逆序对中，下标不可能相等，但是本题我们使用 $l$ 或 $w$ 来代替下标工作，则需考虑判重问题，详见代码：

## 100 分代码，但是错解


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, p = 1e9 + 7;
inline int lowbit (int x) {return x & -x;}
struct node {
	int l, w, c, num;
} a[N];
bool cmp1 (node x, node y) {return x.l < y.l;}
bool cmp2 (node x, node y) {return x.w == y.w ? x.num < y.num : x.w < y.w;}
int n, tr[3][N], mp[N], cnt[3], ans, to[N];
inline void add (int x, int y, int opt) {
	while (x <= n) tr[opt][x] = (tr[opt][x] + y) % p, x += lowbit(x);
}
inline int query (int x, int opt) {
	int res = 0;
	while (x) res = (tr[opt][x] + res) % p, x -= lowbit(x);
	return res;
}//树状数组模板，不过多赘述
int main () {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &a[i].l, &a[i].w, &a[i].c);
	sort(a + 1, a + 1 + n, cmp1);//用 l 的值从小到大的排名代替逆序对中的下标
	for (int i = 1; i <= n; i++) {
		if (a[i].l == a[i - 1].l) to[i] = to[i - 1] + 1;
		if (!a[i].c) {
			for (int j = i - to[i]; j < i; j++) {
				if (a[j].w > a[i].w && a[j].c) ans--;
			}
		} else if (a[i].c == 1) {
			for (int j = i - to[i]; j < i; j++) {
				if (a[j].w > a[i].w && a[j].c != 1) ans--;
			}
		} else if (a[i].c == 2) {
			for (int j = i - to[i]; j < i; j++) {
				if (a[j].w > a[i].w && a[j].c != 2) ans--;
			}
		}//暴力判重（可能会寄，如果出题人精心构造了数据）	
		a[i].num = i;
	}
	sort(a + 1, a + 1 + n, cmp2);
	for (int i = 1; i <= n; i++) mp[a[i].num] = i;
	for (int i = 1; i <= n; i++) {
		int opt = a[mp[i]].c;
		cnt[opt]++, add(mp[i], 1, opt);
		if (!opt) ans = (ans + cnt[1] - query(mp[i], 1) + cnt[2] - query(mp[i], 2)) % p;
		else if (opt == 1) ans = (ans + cnt[0] - query(mp[i], 0) + cnt[2] - query(mp[i], 2)) % p;
		else ans = (ans + cnt[0] - query(mp[i], 0) + cnt[1] - query(mp[i], 1)) % p;//判断，颜色不同就累加答案
	}
	printf("%d", ans);
	return 0;
}
```
对于一道黄色难度的题，这样的做法是 ok 的（随机数据）。

**然而**，此代码可被 $n$ 个一致的输入（比如 $n$ 个 $1, 1, 1$）卡 TLE qwq，最坏情况下的时间复杂度高达 $O(n ^ 2)$。

如果想要正解，就需要将暴力判重给优化掉。

## 优化 + 正解

如何优化呢？我们观察到 $l$ 和 $w$ 的取值范围和 $n$ 一样，所以我们记录排名离散化的行为就完全没有必要。

此处可以将 $l$ 按从大到小的顺序排序，然后按顺序往树状数组里的第 $cnt[w[now]][c[now]]$ 的值增加一。

然后每次让答案加上 $sum[w[now] - 1][color] (color \neq c[now])$。

其中，$sum[n][color] = \sum\limits_{i = 1} ^ n cnt[i][color]$, $cnt[i][color]$ 表示颜色为 $color$ 且 $w = i$ 的矩形的数量。

那么 $sum[w[now] - 1][color] (color \neq c[i])$ 也就是所有满足 $l_i > l_{now}$ 且 $w_i \le w_{now} - 1$ 且 $c_i \neq c_{now}$ 且 $1 \le i \le n$ 的 $i$ 的总数。

用树状数组维护 $sum$，因为可以动态修改。

但是这样依然不够，聪明的你肯定发现了，我们之前的代码之所以需要暴力去重，就是 $l$ 的值可能一样，刚刚所说并未解决该问题。

但是聪明的你也应该可以想到，只要不每次都更新树状数组，等到 $l[now]$ 与 $l[now + 1]$ 不相等时再更新，就解决了 $l$ 相等的问题，且这样做的时间复杂度就是 $O(n)$，完全可过。

## 代码（正解）


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, p = 1e9 + 7;
inline int lowbit (int x) {return x & -x;}
struct node {
	int l, w, c;
} a[N];
bool cmp (node x, node y) {return x.l > y.l;}
int n, tr[3][N], ans, last;
inline void add (int x, int y, int opt) {
	while (x <= N) tr[opt][x] = (tr[opt][x] + y) % p, x += lowbit(x);
}
inline int query (int x, int opt) {
	int res = 0;
	while (x) res = (tr[opt][x] + res) % p, x -= lowbit(x);
	return res;
}//树状数组模板，不过多赘述
int main () {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &a[i].l, &a[i].w, &a[i].c);
	sort(a + 1, a + 1 + n, cmp);
    for(int i = 1; i <= n; i++) {
      for(int j = 0; j <= 2; j++) {
            if (j != a[i].c) ans = (ans + query(a[i].w - 1, j)) % p;
        }
        if(a[i + 1].l < a[i].l) {//l 不相等再更新前缀和
            for(int j = last + 1; j <= i; j++) add(a[j].w, 1, a[j].c);  //一次性将之前没加入的全部加入 
            last = i; 
        }
    }
    printf("%d", ans);
	return 0;
}
```

同时，希望加强本题数据。

~~毕竟我的错解一不小心就卡过去了。~~

审核大大辛苦了，求过 qwq。

---

## 作者：Forge_Unique (赞：1)

## 思路

以每种颜色为十字的第一个矩阵，枚举每种与当前颜色匹配的矩形，计入答案。

## 代码

用两个数组分别存入当前颜色的所有矩形的信息。

按长宽排序后，一次枚举当前颜色的矩形，双指针和树状数组来维护可以拼几个十字。

[code](https://www.luogu.com.cn/paste/fbps8pk5)

---

## 作者：Rindong (赞：0)

# 思路

对于第 $i$ 个矩形，问存在多少个矩形 $j$ 满足:

$$
c_j \neq c_i, \\
l_j > l_i, \\
w_j < w_i
$$

我们可以使用 [CDQ 分治](http://oi-wiki.com/misc/cdq-divide/)的思想求一个二维偏序，首先按 $l$ 为第一关键字排序，再按 $w$ 做第二关键字排序。但是注意到 $l_i = l_j$ 时会出现计算不正确的情况，并且去重不太好处理，因此考虑容斥。

首先对于每个 $i$ 计算出满足：

$$
c_j \neq c_i, \\
l_j \geq l_i, \\
w_j < w_i
$$

的数量，再减去满足：

$$
c_j \neq c_i, \\
l_j = l_i, \\
w_j < w_i
$$

的数量即可。

# 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010, MOD = 1000000007;
int trval[3][N] = { 0 };
inline int lowbit(int i) { return i & (-i); }
inline void update(int tr[], int i, int val) {
	while (i < N) tr[i] += val, i += lowbit(i);
}
inline int query(int tr[], int i) {
	int ret = 0;
	while (i) ret = (ret + tr[i]) % MOD, i -= lowbit(i);
	return ret;
}
struct Ele {
	int l, w, c;
	bool operator< (const Ele& other) const {
		if (l != other.l) return l > other.l;
		return w < other.w;
	}
} ele[N], tmp[N];
int ans = 0;
void merge_sort(int l, int r) {
	if (l >= r) return;
	int mid = l + r >> 1;
	merge_sort(l, mid), merge_sort(mid + 1, r);
	int i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r)
		if (ele[i].w < ele[j].w) 
			update(trval[ele[i].c], ele[i].w, 1), tmp[k++] = ele[i++];
		else {
			for (int c = 0; c < 3; c++)
				if (c != ele[j].c)
					ans = (ans + query(trval[c], ele[j].w - 1)) % MOD;
			tmp[k++] = ele[j++];
		}
	while(i <= mid)
		update(trval[ele[i].c], ele[i].w, 1), tmp[k++] = ele[i++];
	while (j <= r) {
		for (int c = 0; c < 3; c++)
			if (c != ele[j].c)
				ans = (ans + query(trval[c], ele[j].w - 1)) % MOD;
		tmp[k++] = ele[j++];
	}
	for (i = l; i <= mid; i++) update(trval[ele[i].c], ele[i].w, -1);
	for (i = l, j = 0; j < k; i++, j++) ele[i] = tmp[j];
}
void sub(int n) {
	int las = -1;
	for (int i = 1; i <= n; i++) {
		if (ele[i].l != las) {
			int cnt = 0;
			for (int j = i; j <= n; j++)
				if (ele[j].l == ele[i].l) {
					update(trval[ele[j].c], ele[j].w, 1);
					cnt++;
				}
				else break;
			for (int j = i, k = 0; k < cnt; j++, k++)
				for (int c = 0; c < 3; c++)
					if (c != ele[j].c)
						ans = (ans - query(trval[c], ele[j].w - 1) + MOD) % MOD;
			for (int j = i, k = 0; k < cnt; j++, k++)
				update(trval[ele[j].c], ele[j].w, -1);
		}
		las = ele[i].l;
	}
}
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) 
		scanf("%d%d%d", &ele[i].l, &ele[i].w, &ele[i].c);
	sort(ele + 1, ele + 1 + n);
	merge_sort(1, n);
	sort(ele + 1, ele + 1 + n);
	sub(n);
	printf("%d", ans);
	return 0;
}
```

---

## 作者：chengjindong (赞：0)

[题目](https://www.luogu.com.cn/problem/P11048)

排序矩形，用线段树维护每个宽度，矩形的数量。注意，排序后的矩形，只能保证：靠前的矩形的长度**不大于**靠后的矩形的长度，但**长度相等**是不能拼十字，所以要延迟更新，把所有**长度相同**的矩形，对答案的贡献计算完之后再插回去。三种颜色，要分别用三个线段树存储。

---

## 作者：ELECTRODE_kaf (赞：0)

根据长度对矩形排序，然后用线段树维护每种宽度的矩形数量即可。

维护时注意排序后的矩形只能保证靠前的矩形的长度不大于靠后的矩形的长度，但长度相等的情况也不能“拼十字”，所以要延迟更新，将所有相同长度的矩形对答案的贡献计算完之后再将这些矩形插入。

对三种颜色开三个线段树分别存储，配对时配对异色的矩形就好。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define rep(i,x,y) for(ll i=x;i<=y;i++)
#define pause system("pause")

const ll N=1e5+10,mod=1e9+7;
ll n,sgtr[3][N<<2];
short oth[3][2]= {1,2,0,2,0,1};

struct sq {
	ll x,y;
	short c;
} a[N];

ll ls(ll p) {
	return p<<1;
}

ll rs(ll p) {
	return p<<1|1;
}

void pushup(ll no,ll p) {
	sgtr[no][p]=(sgtr[no][ls(p)]+sgtr[no][rs(p)])%mod;
}

void upd(short no,ll p,ll l,ll r,ll ql) {
	if(ql<l or ql>r) return;

	if(l==r) {
		sgtr[no][p]++;
		sgtr[no][p]%=mod;
	} else {
		ll mid=l+r>>1;

		if(ql<=mid) upd(no,ls(p),l,mid,ql);
		else upd(no,rs(p),mid+1,r,ql);

		pushup(no,p);
	}
}

ll query(short no,ll p,ll l,ll r,ll ql,ll qr) {
	if(qr<l or ql>r) return 0;

//	cout<<l<<' '<<r<<'\n';

	if(ql<=l and qr>=r) return sgtr[no][p];

	ll mid=l+r>>1;

	return (query(no,ls(p),l,mid,ql,qr)+query(no,rs(p),mid+1,r,ql,qr))%mod;
}

bool cmp(sq x,sq y) {
	return x.x<y.x;
}

int main() {
	cin>>n;

	rep(i,1,n) cin>>a[i].x>>a[i].y>>a[i].c;

	sort(a+1,a+n+1,cmp);
//	cout<<'\n';
//
//	rep(i,1,n) cout<<a[i].c<<' '<<a[i].x<<' '<<a[i].y<<'\n';
//
//	pause;
	ll ans=0,cur=1;

	rep(i,1,n) {
//		cout<<"i="<<i<<'\n';
//		cout<<"ql="<<a[i].y+1<<",qr="<<N-10<<'\n';
//		pause;
		ans=(ans+query(oth[a[i].c][0],1,1,N-10,a[i].y+1,N-10))%mod;
		ans=(ans+query(oth[a[i].c][1],1,1,N-10,a[i].y+1,N-10))%mod;
//		cout<<"query complete\n";

		if(a[i].x<a[i+1].x) {
			for(;cur<=i;cur++) upd(a[cur].c,1,1,N-10,a[cur].y);
		}
		
//		cout<<"ans="<<ans<<'\n';
	}

	cout<<ans;
}

```

---

## 作者：seika27 (赞：0)

### 分析
前置知识：[二维偏序/二维数点](https://www.luogu.com.cn/problem/P2163)

每个元素有三个限制 $c$，$l$，$w$。

能拼一个十字要求 $c_i\neq c_j$ 且 $l_i>l_j$ 且 $w_i<w_j$。

对于颜色，由于一共只有三种，我们可以直接进行分类。

接下来就是一个 $l_i>l_j$ 且 $w_i<w_j$。

一个十分常规的二维偏序，需要注意的是统计的时候要进行清空。

---

## 作者：39xiemy (赞：0)

## 题目大意

给出 $n$ 个长为 $l_i$，宽为 $w_i$，颜色为 $c_i$ 的矩形，其中 $c_i \in \{0,1,2\}$。求 $\sum_{i=1}^n \sum_{j=1}^n [l_i > l_j] \And [w_i < w_j] \And [c_i \ne c_j]$ 的值。

## 分析

可以先考虑满足 $l_i > l_j$ 这一个条件的矩形有多少对。

要解决这个问题，按 $l_i$ 从小到大排序即可，现在考虑增加 $w_i < w_j$ 这个条件。由于 $l_i > l_j$ 已经满足，并且 $w_i \le 10^5$，可以写一颗权值线段树~~或树状数组~~来维护 $w_i$。

最后考虑 $c_i \ne c_j$ 这个条件。由于 $c_i$ 只有三种取值，在线段树中将 $w_i$ 分颜色来存储答案即可，详见代码。

## 代码

```cpp
#include<bits/stdc++.h>
#define mid (tr[n].l+tr[n].r)/2
using namespace std;
int a,l,w,c,mod=1e9+7,t=1,mx=-1,ans;
struct nod{
	int l,w,c;
}b[100001];
struct node{
	int l,r,w[3]; 
}tr[400001];
inline bool cmp(nod x,nod y){return x.l<y.l;}
inline void add(int n,int l,int r)
{
	tr[n].l=l,tr[n].r=r,tr[n].w[0]=tr[n].w[1]=tr[n].w[2]=0;
	if(l==r) return;
	add(n*2,l,mid),add(n*2+1,mid+1,r);
	return;
}
inline void be(int n,int l,int k)
{
	if(tr[n].l==tr[n].r)
	{
		for(int i=0;i<=2;i++) if(i!=k) tr[n].w[i]=(tr[n].w[i]+1)%mod;//对不同颜色的答案才产生贡献 
		return;
	}
	if(l<=mid) be(n*2,l,k);
	else be(n*2+1,l,k);
	for(int i=0;i<=2;i++) tr[n].w[i]=(tr[n*2].w[i]+tr[n*2+1].w[i])%mod;
}
inline int ask(int n,int l,int r,int k)
{
	if(tr[n].l>=l&&tr[n].r<=r) return tr[n].w[k];//返回相对应的颜色的答案 
	int sum=0;
	if(l<=mid) sum=ask(n*2,l,r,k);
	if(r>mid) sum=(sum+ask(n*2+1,l,r,k))%mod;
	return sum;
}
int main()
{
	cin>>a;
	for(int i=1;i<=a;i++) scanf("%d%d%d",&b[i].l,&b[i].w,&b[i].c),mx=max(mx,b[i].w); 
	sort(1+b,1+b+a,cmp);
	add(1,1,mx);
	for(int i=2;i<=a;i++)
	{
		if(b[i].l!=b[i-1].l)//当l_i与l_{i-1}不相等时，就将所有和l_{i-1}长度相等的矩形的宽加入线段树，因为长度是严格大于的 
		{
			for(int j=t;j<i;j++) be(1,b[j].w,b[j].c);
			t=i;
		}
		ans=(ans+ask(1,b[i].w+1,mx,b[i].c))%mod;//查询时要从w_i+1开始，因为宽度是严格小于的 
	}
	cout<<ans;
	return 0;
}
```

---


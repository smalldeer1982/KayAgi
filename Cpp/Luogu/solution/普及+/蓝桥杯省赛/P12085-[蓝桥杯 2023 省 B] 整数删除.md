# [蓝桥杯 2023 省 B] 整数删除

## 题目描述

给定一个长度为 $N$ 的整数数列：$A_{1},A_{2},\ldots,A_{N}$。你要重复以下操作 $K$ 次：

每次选择数列中最小的整数（如果最小值不止一个，选择最靠前的），将其删除。并把与它相邻的整数加上被删除的数值。

输出 $K$ 次操作后的序列。

## 说明/提示

**【样例说明】**

数列变化如下，中括号里的数是当此操作中被选择的数：
```plain
[1] 4 2 8 7
5 [2] 8 7
[7] 10 7
17 7
```
**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$1 \leq K<N \leq 10^4$。

对于 $100 \%$ 的数据，$1 \leq K<N \leq 5 \times 10^{5}$，$0 \leq A_{i} \leq 10^{8}$。 

蓝桥杯 2023 省赛 B 组 H 题。

## 样例 #1

### 输入

```
5 3
1 4 2 8 7```

### 输出

```
17 7```

# 题解

## 作者：fish_love_cat (赞：8)

~~可删堆会写吧？链表会写吧？那么做完了。~~

上面是我在通过此题前写的一句话题解。

然后发现小模拟调不出来，[呜呜](https://www.luogu.com.cn/record/list?pid=P12085&user=754021) /ll

---

首先要求动态最小值及其下标，可以利用堆来做。

注意可删堆同时要维护一个数据版本用于更新，每次遇到过期数据都要立刻扔掉。

然后对于每一个取出来的点，用链表维护出上下的点，然后对其更新。

**对于不存在的点请不要处理。**

直接模拟删除过程就做完了，注意要给删掉的点打标记。

---

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int n,k;
struct fish{
    int x,lst,nxt,id;
    int rk;
    bool operator <(fish a)const{
        if(x==a.x)return id>a.id;
        return x>a.x;
    }
}a[500005];
struct delete_Q{
    priority_queue<fish>q1,q2;
    void push(fish x){
        q1.push(x);
    }
    void pop(fish x){
        q2.push(x);
    }
    fish top(){
        while(!(a[q1.top().id].rk==q1.top().rk&&(q2.empty()||a[q2.top().id].rk==q2.top().rk&&q1.top().id!=q2.top().id))){
            while(a[q1.top().id].rk!=q1.top().rk)q1.pop();
            while(!q2.empty()&&a[q2.top().id].rk!=q2.top().rk)q2.pop();
            if(q2.empty())break;
            if(q1.top().id==q2.top().id)q1.pop(),q2.pop();
        }
        return q1.top();
    }
}q;
void del(fish x){
    if(x.lst!=0){
        fish flc=a[x.lst];
        q.pop(flc);
        flc.nxt=x.nxt;
        flc.x+=x.x;
        flc.rk++;
        a[flc.id]=flc;
        q.push(flc);
    }
    if(x.nxt!=n+1){
        fish flc=a[x.nxt];
        q.pop(flc);
        flc.lst=x.lst;
        flc.x+=x.x;
        flc.rk++;
        a[flc.id]=flc;
        q.push(flc);
    }
    a[x.id].x=-1;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(),cout.tie();
    cin>>n>>k;
    for(int i=1;i<=n;i++)
    cin>>a[i].x,a[i].lst=i-1,a[i].nxt=i+1,a[i].id=i,a[i].rk=0,q.push(a[i]);
    while(k--){
        fish flc=q.top();
        q.pop(flc);
        del(flc);
    }
    for(int i=1;i<=n;i++)
    if(a[i].x!=-1)cout<<a[i].x<<' ';
    return 0;
}
```

截至目前运行时长位列倒二，人傻常数大。

---

## 作者：_Supernova (赞：6)

### 朴素思路

首先我们根据题意模拟出朴素思路：每次操作时，

找到最小数：遍历数组，找到最小中最靠前的数，记录 $flag_i$ 表示 $A_i$ 是否已经被删除；删除：标记 $flag_i$ 的值；修改操作：往左边和右边寻找相邻数加上自身权值。

时间复杂度为 $O(nk)$，无法接受。

### 第一步优化

最外层的 $O(k)$ 显然已经无法优化，考虑优化每次操作，即内层。为了~~偷懒~~方便叙述，下文复杂度皆为单次操作的时间复杂度。

对于第一步，找到最小中最可靠前的数，遍历的时间复杂度为 $O(n)$，而我们如果记录一个优先队列来维护数组中未被删除的元素中最小且最靠前的数，就能将这一步优化到 $O(\log n)$。

对于第二步，我们的操作便是弹出队首即可。时间复杂度为 $O(1)$。

对于第三步，如何快速找到左右两边未被删除的相邻数？分析问题，我们发现需要一种支持快速删除以及快速前后查找的数据结构——链表。

于是我们一开始维护一个双向链表，初始时 $i$ 的 $left$ 指向 $i-1$，$i$ 的 $right$ 指向 $i+1$。每次删除节点时，将节点左边与右边相连即可。

于是我们做到了 $O(1)$ 左右寻找与删除。

### 最后一步优化

注意到第三步操作中，我们需要把 $left$ 和 $right$ 修改后的权值加入优先队列，这很方便。

然而，我们需要将队列中 $left$ 和 $right$ 原来的权值删除，这需要遍历整个优先队列去查找，时间复杂度 $O(n)$，功亏一篑。

遇到这种情况，我们先无脑将新权值加入队列，再想这个问题。

有没有什么简便的方法知道区分队列中相同 $i$ 对应权值的新旧性？

我们对每个加入的权值记录一个变量，表示**这个权值的版本**。越后操作修改的权值版本越新，同时我们记录全局数组 $version_i$ 表示 $A_i$ 的版本，这样，对于队列的每个队首，我们只需判断队首权值的版本是否与全局版本一致，单次判断时间复杂度 $O(1)$。

至此，本题全部结束。总时间复杂度为 $O(n\log n)$。

以下为代码。

### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 500005;
int n, k;
ll a[N];
struct List {
	int l, r;
} lst[N]; // 链表的维护
struct Node {
	int id;
	ll val;
	int vrs; // 天才做法！定义数据版本！
	bool operator < (const Node cmp) const {
		return (val == cmp.val ? id > cmp.id : val > cmp.val);
	}
};
priority_queue <Node> pq; // 优先队列，维护最小值
int version[N]; 
bool flag[N];
int main(void) {
	cin.tie(0), cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
		pq.push((Node){i, (ll)a[i], 0});
		lst[i].l = i-1, lst[i].r = i+1; // 链表的初始化
	}
	lst[1].l = lst[n].r = -1;
	for (int tim = 1; tim <= k; ++tim) { // 版本迭代
		while (!pq.empty() && pq.top().vrs != version[pq.top().id]) pq.pop(); // 弹出旧数据
		Node top = pq.top();
		pq.pop();
		int id = top.id;
		flag[id] = true; // 标记是否被删除
		ll val = top.val;
		int left = lst[id].l, right = lst[id].r;
		if (left != -1) { // 记得特判
			lst[left].r = right;
			a[left] += val;
			pq.push((Node){left, a[left], tim});
			version[left] = tim; // 更新版本
		}
		if (right != -1) { // 记得特判！
			lst[right].l = left;
			a[right] += val;
			pq.push((Node){right, a[right], tim});
			version[right] = tim; //  更新版本
		}
	}
	for (int i = 1; i <= n; ++i) {
		if (!flag[i]) {
			cout << a[i] << ' ';
		}
	}
	return 0;
}
```

别忘记点个赞呀。

---

## 作者：jaiy_cqg (赞：3)

### 思路
把初始元素保存成 $val,id$ 的结构体变量，放入优先队列，每次从优先队列弹出最小值，看它是否和结构体中的 $val$ 一致，如果一致说明是新的，否则跳过根据它的 $id$ 找到左边和右边，加和，更新结构体中的值，放入优先队列。
### 做法
双向链表 $l$ 和 $r$ 维护相邻关系优先队列实现最小堆，自定义比较运算符处理相同值情况。初始化时建立双向链表连接。每次从堆顶取出有效最小值（跳过已删除元素），更新左右邻居的值并调整链表结构，将更新后的邻居重新入堆。最后遍历存活节点时通过链表指针跳转，自动跳过被删除的节点。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 5e5 + 10;

struct node {
    ll val;//值
    int id;//下标
} a[N];
priority_queue<node>q;
int l[N], r[N], n, m;

int vis[N];//表示某个节点是否被删掉
bool operator < (node other, node top) {
    //按val小的优先，val相等按id小的优先
    if (other.val == top.val)
        return top.id < other.id;
    return top.val < other.val;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].val;
        a[i].id = i;
        q.push(a[i]);
    }

    //0作为头结点，n+1作为尾节点
    r[0] = 1, l[n + 1] = n;
    for (int i = 1; i <= n; i++) {//双向链表初始化
        l[i] = i - 1, r[i] = i + 1;
    }
    while (m--) { //      根据下标找到的val和队列的val不一致 或已经被删除过了
        while (a[q.top().id].val != q.top().val || vis[q.top().id]) {
            q.pop();
        }
        auto p = q.top().id; //这个一定是最新的
    //    cout << a[p].val << "<-val \n";
        q.pop();
        int left = l[p], right = r[p];
        a[left].val += a[p].val, a[right].val += a[p].val; //左右加和
        vis[p] = 1;
        r[left] = right, l[right] = left; //链表的更新
        if (left >= 1)
            q.push(a[left]);//不是虚拟节点
        if (right <= n)
            q.push(a[right]);//不是虚拟节点
    }
    int p = r[0];
    while (p != n + 1) {
        cout << a[p].val << " ";
        p = r[p];
    }
}
```

---

## 作者：HZY1618yzh (赞：3)

先读题目：把给出的数列的最小值删移，并把它左右两边数相加这个数，重复 $k$ 次，最后输出数列。  

思路
---
循环 $k$ 次，把每个最小值删移，给左右两边的数加上这个数。  
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int>a(100001);
int main(){
	cin>>n;
	a[0]=INT_MAX;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=k;i++){
		int x,minn=INT_MIN;
		for(int i=1;i<=a.size();i++)
			if(a[i]>minn)minn=a[i],x=i;
		a[x-1]+=a[x];
		a[x+1]+=a[x];
		a.erase(a.begin()+x;
	}
	for(int i=1;i<=n;i++)
		cout<<a[i];
	return 0;
}
```
**TLE！**  

优化
---
用优先队列（`priority_queue`）求最小值。

拓展：  
在 C++ 中，`priority_queue` 是一个模板类，定义在头文件中，有三个模板参数：元素类型、容器类型和比较函数类型（可选）。默认情况下，它使用 `std::vector` 作为其底层容器。

优先队列会打乱顺序，所以要用 `vector<pair<ll,int>>` 记录顺序和值。  
可给左右两边的数加上这个数怎么办？可以用数组存编号啊！

总结
---
大模拟+堆+链表的好题。

下面来看看 c++STL 库的魅力。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 5e5 + 10;
typedef pair<ll, int> pii;
ll a[MAXN];
int ln[MAXN], rn[MAXN];
bool d[MAXN];
int n,k;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //输入
	cin>>n>>k;
    priority_queue<pii, vector<pii>, greater<pii>> pq;// 堆/优先队列
    for (int i=1;i<=n;i++) {
        cin>>a[i];//输入
        pq.emplace(a[i], i);//放入优先队列
        //数组记录
        ln[i] = i - 1;
        rn[i] = i + 1;
    }
    //开头和结尾的修正
    ln[1]=-1;
    rn[n]=-1;
    while (k--) {
        pii c;
        do {
            c = pq.top();
            pq.pop();
        } while (d[c.second] || a[c.second] != c.first);//没走过或对不上
        //方便计算
        int p = c.second;
        ll val = c.first;
        //调整左右
        //不是第一个，就把左边增加和调整
        if (ln[p] != -1) {
            int left_pos = ln[p];
            a[left_pos] += val;
            pq.emplace(a[left_pos], left_pos);
            rn[left_pos] = rn[p];
        }
        //不是最后一个，就把右边增加和调整
        if (rn[p] != -1) {
            int right_pos = rn[p];
            a[right_pos] += val;
            pq.emplace(a[right_pos], right_pos);
            ln[right_pos] = ln[p];
        }
        d[p] = true;//标记
    }
    vector<ll> res;
    for (int i = 1; i <= n;i++) 
        if (!d[i])//没有被标记就是没有删除，所以加入答案
            res.push_back(a[i]);
    //输出
    for (size_t i=0;i<res.size();i++) {
        if (i!=0) cout<<" ";
        cout<<res[i];
    }
    cout<<endl;//末尾换行
    return 0;//完结散花
}
```

---

## 作者：ZhaoV1 (赞：1)

这题考察的是优先队列和模拟双链表的思维，其实一步步分析过来还是很简单易懂的。

首先，数组长度为 $1≤n≤5×10^5$，所以对于本题应当采用小于或等于 $O(n\log n)$ 时间复杂度的方式解决，这时我们结合条件，即每次对数组中最小值进行操作，我们可以联想到使用优先队列来维护。而最大的问题是经过不断的消除数字，对于当前将要消除的数，它的左右两边是无法简单判断。

而当我们用双向链表的思维维护每个数届时的两边，会发现当一个数被消除，它的左边有效数的右边有效数应当更换为当前数的右边有效数，它的右边即同理。

所以在消除一个数的时候，我们应当让它的左右两边有效数的右边和左边分别重新赋值：


```cpp
			ri[le[tt.idx]] = ri[tt.idx];
			le[ri[tt.idx]] = le[tt.idx];
```
当然，在处理最小数时，因为堆无法实时更新该值，所以可能实际上这个值并非该数组剩余数的最小值，所以用 $plu$ 数组来存放该数的额外增加值，如果 $plu_i>0$，那么应当将重新赋值后的元素放回堆中：


```cpp
		if(plu[tt.idx]){
			que.push({tt.x+plu[tt.idx],tt.idx});
			plu[tt.idx] = 0;
		}
```

完整代码：

Code
---


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> pi;
typedef long long LL;
const int N = 5e5+5;
int t,n,k;
struct inner{
	int x,idx;
	bool operator < (const inner &b) const{
		if(this->x != b.x) return this->x > b.x;
		else return this->idx > b.idx;
	}
};
priority_queue<inner> que;
int a[N], plu[N], sum[N];
int le[N], ri[N];
bool b[N];
void solve(){
	cin >> n >> k;
	for(int i=1;i<=n;i++){
		cin >> a[i];
		que.push({a[i],i});
		le[i] = i-1;
		ri[i] = i+1;
	}
	for(int i=1;i<=k;i++){
		auto tt = que.top();
		que.pop();
		if(plu[tt.idx]){
			que.push({tt.x+plu[tt.idx],tt.idx});
			plu[tt.idx] = 0;
			i--;//并未操作
		}else{
			ri[le[tt.idx]] = ri[tt.idx];
			le[ri[tt.idx]] = le[tt.idx];
			plu[le[tt.idx]] += tt.x;
			plu[ri[tt.idx]] += tt.x;
			sum[le[tt.idx]] += tt.x;
			sum[ri[tt.idx]] += tt.x;
			b[tt.idx] = true;
		}
	}
	for(int i=1;i<=n;i++){
		if(!b[i]){
			cout << a[i]+sum[i] << " ";
		}
	}cout << '\n';
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	t = 1;
	while(t--){
		solve();
	}
	return 0;
}

```

---

## 作者：ylch (赞：1)

考虑用堆存储每个结点的权值和位置，按照题目中说的顺序升序排序。

然后进行 $k$ 次操作，每次修改取出最小结点，修改其前驱和后继结点的值，然后删除此结点。不难想到用链表维护。

注意开 long long。

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
typedef long long ll;
const int maxn = 5e5 + 7;

struct Node{
	int val, id;
	Node(int v, int i) : val(v), id(i){}
};

struct cmp{
	bool operator()(const Node& a, const Node& b) const{
		if(a.val != b.val) return a.val > b.val;
		return a.id > b.id;  // 值相同时选原位置靠前的
	}
};

int a[maxn]; // 结点当前值
int pre[maxn], nxt[maxn]; // 每个结点的前驱、后继
bool del[maxn]; // 每个节点是否被删除

void solve()
{
	int n, k; cin >> n >> k;
	
	// 链表初始化
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		pre[i] = i - 1, nxt[i] = i + 1;
	}
	pre[1] = -1, nxt[n] = -1;
	
	// 优先队列初始化
	priority_queue<Node, vector<Node>, cmp> Q;
	for(int i = 1; i <= n; i ++){
		Q.push({a[i], i});
	}
	
	for(int i = 1; i <= k; i ++){
		while(!Q.empty()){
			auto [u, id] = Q.top(); Q.pop();
			
			// 确保结点还存在
			if(del[id] || a[id] != u) continue;
			
			// 删除当前节点
			del[id] = true;
			if(pre[id] != -1) nxt[pre[id]] = nxt[id];
			if(nxt[id] != -1) pre[nxt[id]] = pre[id];
			
			// 更新
			if(pre[id] != -1 && !del[pre[id]]){
				a[pre[id]] += u;
				Q.push({a[pre[id]], pre[id]});
			}
			if(nxt[id] != -1 && !del[nxt[id]]){
				a[nxt[id]] += u;
				Q.push({a[nxt[id]], nxt[id]});
			}
			
			break; // 结束本次操作
		}
	}
	
	// 输出结果
	vector<int> ans;
	for(int i = 1; i <= n; i ++){
		if(!del[i]) ans.push_back(a[i]);
	}
	for(auto it : ans) cout << it << ' ';
}

signed main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

---

## 作者：MonKeySort_ZYczc (赞：1)

## 思路流程

不太懂为啥是绿，思路比较一眼。   
对于要快速查询某下标相邻的数与删除某下标的数据结构，比较明显可以采用链表。   
由于左右两边的数都要查询，故采用双向链表。   
对于数列中的最小值，优先队列是一个不错的选择。   
由于优先队列不支持快速修改某数，我们尝试使用懒操作。   
对于每次操作，先找到优先队列中最小值并弹出。   

- 若这个值与现在数列中的值不同，将新的值重新放入优先队列。
- 否则，进行修改。

小技巧：由于 STL 的模板中 priority_queue 默认支持从大到小排列，我们可以通过加上负号让其变为从小到大。   
~~但是不是有个东西叫做 greater < int >。~~   
最后不开什么什么见祖宗就不再强调了。  

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mp(a,b) make_pair(a,b)
const int N=5e5+10;
int lst[N][2],n,k,a[N];
priority_queue<pair<int,int> >Q;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		Q.push(mp(-a[i],-i));
		lst[i][0]=i-1;lst[i][1]=i+1;
	}
	lst[0][1]=1;
	lst[n][1]=0;
	for(int i=1;i<=k;i++)
	{
		int t;
		while(a[(t=-Q.top().second)]!=-Q.top().first) 
		{
			Q.pop();Q.push(mp(-a[t],-t));
		}
		Q.pop();
		a[lst[t][0]]+=a[t];a[lst[t][1]]+=a[t];
		lst[lst[t][1]][0]=lst[t][0];
		lst[lst[t][0]][1]=lst[t][1];
		//i++;
	}
	int t=lst[0][1];
	while(t)
	{
		cout<<a[t]<<' ';t=lst[t][1];
	}
}


```

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12085)

## 题目大意：

有一个有 $N$ 个数的数列 $A$，执行 $K$ 次操作，每次操作找出 $A$ 中的最小值中最靠前的一个，把它相邻的两个数加上它的值，然后把它删除，求 $K$ 次操作后的数列 $A$。

## 思路：

显然这题的操作可以分成三个步骤：

1. 找到 $A$ 中的最小值。
2. 把 $A$ 最小值旁边的两个数加上 $A$ 的最小值
3. 删除 $A$ 中的最小值。

### 步骤一：

可以用一个堆来维护，也就是 
```cpp
priority_queue<pair<long long,long long>,vector<pair<long long,long long> >,greater<pair<long long,long long> > >q;
```
二元组的第一个元素储存这个位置的值，第二个元素储存编号，STL 中的优先队列使用二元组时会按第一个元素为第一关键词，第二个元素为第二关键词来排序，注意是小根堆不是大根堆。

最小值就是堆顶元素。

注意堆顶元素的位置上有标记时要加上标记值后重新压回堆里面，清空标记。

### 步骤二：

找前驱后继有一个很方便的数据结构，也就是双链表，用双链表维护前驱后继的指针即可：


```cpp
long long sum[1000005],last[1000005],nextt[1000005];//sum为位置，last为前驱，nextt为后继，注意一下next是不能当变量名的
```
然后只需要给前驱后继上的值打标记就可以。

### 步骤三：

直接用布尔型数组记录有没有被删除过即可。

### 统计答案：

把堆里的剩余元素取出，按照位置顺序排序再输出即可，注意取出前最后还要下传一次标记，而堆是从小到大排序的，为了防止加上标记压回后重复取出，可以给每个值加一个 $10^{10}$ 的附加值，最后输出时减去即可。

## 完整代码：

注意要开 **long long**。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y;
long long tag[1000005];//标记
bool f[1000005];
priority_queue<pair<long long,long long>,vector<pair<long long,long long> >,greater<pair<long long,long long> > >q;//小根堆 
struct node{
	long long bh;
	long long v;
}da[1000005];
bool cmp(node q,node p){
	return q.bh<p.bh;
}
long long sum[1000005],last[1000005],nextt[1000005];//sum为位置，last为前驱，nextt为后继，注意一下next是不能当变量名的 
int main(){
	f[0]=true;
	cin>>x>>y;
	for(long long i=1;i<=x;i++){
		sum[i]=i;
		last[i]=i-1;
		nextt[i]=i+1;
	}
	f[x+1]=true;
	for(long long i=1;i<=x;i++){
		long long a;
		cin>>a;
		q.push(make_pair(a,i));
	}
	long long us=0;
	for(;;){
		if(us==y) break;
		long long u=q.top().first;
		long long c=q.top().second;
		q.pop();
		if(tag[c]!=0){
			q.push(make_pair(u+tag[c],c));
			tag[c]=0;
			continue;
		}
		f[c]=true;
		if(f[last[c]]==false) tag[last[c]]+=u;
		if(f[nextt[c]]==false) tag[nextt[c]]+=u;
		nextt[last[c]]=nextt[c];
		last[nextt[c]]=last[c];
		us++;
	}
	long long qs=q.size();
    for(long long i=1;i<=qs;i++){
    	long long u=q.top().first;
		long long c=q.top().second;
		q.pop();
		q.push(make_pair(u+tag[c]+10000000000,c));
		tag[c]=0; 
	}
	
	long long s=0;
	while(!q.empty()){
		s++;
		da[s].v=q.top().first;
		da[s].bh=q.top().second;
		q.pop();
	}
	sort(da+1,da+1+s,cmp);
	for(long long i=1;i<=s;i++){
		cout<<da[i].v-10000000000<<" ";
	}
	return 0; 
}

```

[通过记录](https://www.luogu.com.cn/record/212799334)

---

## 作者：haoyan1103 (赞：0)

## 题目解析
题目要求操作一个数列。

每次删除数列中最小的数，并将这个数左右两边的数加上这个数。

## 思路
考虑用链表维护。

链表可以很轻松的处理删除数，并将左右两边的数加上某个值。

那么我们现在要考虑如何快速找出数列中最小的数。

数列中最小的数会随着每次操作而变化，所以我们要用动态的优先队列（也就是堆）来维护。

注意要开 `long long`。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node
{
	int date;
	int l,r;
}List[500005];//链表
struct nod
{
	int id,x;
};
struct cmp
{
	bool operator()(nod a,nod b)
	{
		if(a.x!=b.x)return a.x>b.x;
		return a.id>b.id;
	}
};
int n,k;
bool vis[500005];//记录是否删除
priority_queue<nod,vector<nod>,cmp> q;//优先队列（堆）
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>List[i].date;
		List[i].l=i-1;List[i].r=i+1;//建立链表
		q.push((nod){i,List[i].date});//插入堆
	}
	List[0].r=1;//别忘了 0 号结点的右指针指向 1
	vis[0]=vis[n+1]=1;
	while(k--)
	{
		nod t=q.top();q.pop();
		while(t.x!=List[t.id].date || vis[t.id]==1)t=q.top(),q.pop();
        //因为每次插入不会覆盖之前的值，所以要将未更新的值全部去除
		List[List[t.id].l].r=List[t.id].r;
		List[List[t.id].r].l=List[t.id].l;
        //删除当前项
		List[List[t.id].l].date+=List[t.id].date;
		List[List[t.id].r].date+=List[t.id].date;
        vis[t.id]=1;//标记
		if(!vis[List[t.id].l])q.push((nod){List[t.id].l,List[List[t.id].l].date});
		if(!vis[List[t.id].r])q.push((nod){List[t.id].r,List[List[t.id].r].date});
        //插入堆
	}
	int head=List[0].r;
	while(head!=n+1)
	{
        if(vis[head])break;
		cout<<List[head].date<<" ";
		head=List[head].r;
	}
	return 0;
}
```

---

## 作者：wjr_jok (赞：0)

按题意操作即可。

快速求序列最小值，用小根堆。

有删除操作，用链表维护左右关系。

删除的同时要对左右的数值进行加操作，这会改变序列最小值，但堆是不能直接访问到指定位置的元素的，考虑存下来，访问到这个值的时候再修改。

具体的，用一个数组记录每个数被加了多少，每次访问堆顶元素时把它加上，再跟堆中下一个元素比较，如果它更优就删除，反之更新数值后重新加入堆。

加操作最多进行 $2k$ 次，所以重新加入堆的次数最多进行 $2k$ 次，故复杂度为 $O(k\log n)$。

最后把堆中剩余的数值还原到原数组输出即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+1;
struct jgt{
	int x,y;
	bool operator<(const jgt &top)const{
		if(x==top.x) return y>top.y;
		return x>top.x;
	}
} t;
int n,k,x;
int l[N],r[N],cc[N],flag[N],sc[N];
priority_queue<jgt> s;
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>x,s.push({x,i}),l[i]=i-1,r[i]=i+1;
	for(int i=1;i<=k;i++){
		t=s.top(),s.pop();
		if(t.x+cc[t.y]>s.top().x||(t.x+cc[t.y]==s.top().x&&t.y>s.top().y)){//用更新后的值与堆中下一个值比较，记得还要比较前后关系
			s.push({t.x+cc[t.y],t.y}),cc[t.y]=0,i--;//不是当前最优的，更新后重新添加到堆中
			continue;
		}
		cc[l[t.y]]+=t.x+cc[t.y],cc[r[t.y]]+=t.x+cc[t.y],r[l[t.y]]=r[t.y],l[r[t.y]]=l[t.y];//删除当前值并对左右进行加操作
	}
	while(!s.empty()) t=s.top(),s.pop(),flag[t.y]=1,sc[t.y]=t.x+cc[t.y];//还原数组
	for(int i=1;i<=n;i++) if(flag[i]) cout<<sc[i]<<" ";
	return 0;
}
```

---


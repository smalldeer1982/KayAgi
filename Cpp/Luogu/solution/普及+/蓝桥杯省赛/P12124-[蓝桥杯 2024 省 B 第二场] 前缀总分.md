# [蓝桥杯 2024 省 B 第二场] 前缀总分

## 题目描述

给定 $n$ 个由小写英文字母组成的字符串 $s_1, s_2, \dots , s_n$，定义前缀总分为：

$$V=\sum_{i<j} P(s_i,s_j)$$

其中 $P(s_i, s_j)$ 表示 $s_i, s_j$ 的最长公共前缀的长度。

小蓝可以选择其中一个字符串，并修改其中的一个字符。请问修改后前缀总分最大为多少？

## 说明/提示

### 样例说明

将第二个字符串改为 $\tt{abb}$ ，得分为 $P(\tt{aab}, \tt{abb})+P(\tt{aab}, \tt{abb})+P(\tt{abb}, \tt{abb}) = 1 + 1 + 3 = 5$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 20$；
- 对于所有评测用例，$1 \leq n \leq 200$，$1 \leq |s_i| \leq 200$，其中 $|s_i|$ 表示 $s_i$ 的长度。


## 样例 #1

### 输入

```
3
aab
bbb
abb```

### 输出

```
5```

# 题解

## 作者：FJ_EYoungOneC (赞：5)

下文中记 $C = 26$，表示字符种类的数量。

### 暴力解法 $O(Cn^5)$

枚举将第 $i$ 个字符串的第 $j$ 个字符改为 $c$ 的所有方案，时间复杂度 $O(Cn^2)$，修改并计算总分，$O(n^3)$。

### 暴力优化 $O(Cn^3\log n)$

我们可以使用**字符串哈希**来优化判断两个字符串是否相等。

另外，可以用**二分**来优化求两个字符串的最大前缀。

枚举所有方案的时间复杂度为 $O(Cn^2)$，处理修改以及计算总分的复杂度为 $O(n\log n)$。

### 再优化 $O(Cn^3)$

首先，我们依旧使用上述**暴力解法**中的枚举方式——所有将第 $i$ 个字符串的第 $j$ 个字符改为 $k$，时间复杂度 $O(Cn^2)$。

接下来我们考虑，如果用不大于 $O(n)$ 的时间去完成计算一个枚举的分数。

将第 $i$ 个字符串的第 $j$ 个字符改为 $k$ 时，所影响答案的只有 $P(s_1, s_i), P(s_2, s_i), P(s_3, s_i), \dots, P(s_n, s_i)$。

所以我们可以计算出未修改时的总得分的 $tot$，计算出未修改时第 $i$ 个字符串对答案的贡献 $g[i]$。设修改之后第 $i$ 个字符串对答案的贡献为 $res$，那么修改之后的答案即为 $tot - g[i] + res$。

那么接下来，我们要尝试处理计算，将第 $i$ 个字符串的第 $j$ 个字符改为 $k$ 之后，第 $i$ 个字符串对答案的贡献。

那么显而易见，我们需要计算修改之后的第 $i$ 字符串与剩下 $n-1$ 个字符串的最大前缀。

设其中一个字符串为 $s_u$，计算修改之后的 $s_i$ 与修改之前，只有第 $j$ 个字符被改变，$j$  左侧的字符，以及右侧的字符均为改变。

那么我们可以尝试比较修改前的 $s_i$ 与 $s_u$ 从 $0$ 开始的最大前缀长度 $left$：
- 若 $left < j - 1$，那么 $s_i$ 与 $s_u$ 的最大前缀长度即为 $left$。
- 若 $left \geq j - 1$，那么说明 $s_i$ 与 $s_u$ 的前 $j - 1$ 个字符相等，此时我们需要判断**修改之后**的第 $j$ 个字符是否相等：
  - 若第 $j$ 个字符相等，则 $s_i$ 与 $s_u$ 的最大前缀即为 $left + 1 +$（$s_i$ 与 $s_j$ 的第 $j + 1$ 个字符开始的最大前缀）。
  - 若第 $j$ 个字符不相等，则 $s_i$ 与 $s_u$ 的最大前缀即为 $left$。

上述分析中，我们多次需要用到第 $i$ 个字符串与第 $j$ 个字符串从 $k$ 开始的最大前缀。

考虑动态规划：$f[i][j][k]$ 表示第 $i$ 个字符串与第 $j$ 个字符串从 $k$ 开始的最大前缀长度。

考虑动态转移：

- 若 $s[i][k] = s[j][k]$，则 $f[i][j][k] = f[i][j][k + 1] + 1$。
- 若 $s[i][k] \neq s[j][k]$，则 $f[i][j][k] = 0$。

由于计算 $f[i][j][k]$ 时，需要用到 $f[i][j][k + 1]$，故预处理 $f$ 数组时需要倒序处理。
### 暴力优化 $O(Cn^3\log n)$

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 2e2 + 10, P = 131;

typedef unsigned long long ULL;

int n;
string str[N];
ULL f[N][N], p[N];
int g[N];
int tot;

ULL query(int u, int l, int r)
{
    return f[u][r] - f[u][l - 1] * p[r - l + 1];
}

int calc(int u, bool flag)
{
    int res = 0;
    for (int i = 1; i <= n; ++ i )
        if (i != u)
        {
            int l = 1, r = min(str[u].size() - 1, str[i].size() - 1);
            while (l < r)
            {
                int mid = l + r + 1 >> 1;
                if (query(i, 1, mid) == query(u, 1, mid))
                    l = mid;
                else
                    r = mid - 1;
            }
            if (query(i, 1, l) == query(u, 1, l))
                res += l;
        }
    
    if (flag)
    {
        g[u] = res;
        tot += res;
    }
    
    return res;
}

int modify(int u, int k, int c)
{
    char t = str[u][k];
    str[u][k] = 'a' + c;
    
    for (int i = 1; i < str[u].size(); ++ i )
        f[u][i] = f[u][i - 1] * P + str[u][i];

    int res = tot - g[u] * 2 + calc(u, false) * 2;
    
    str[u][k] = t;
    
    for (int i = 1; i < str[u].size(); ++ i )
        f[u][i] = f[u][i - 1] * P + str[u][i];
    
    return res / 2;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n;
    for (int i = 1; i <= n; ++ i )
    {
        cin >> str[i];
        str[i] = ' ' + str[i];
    }
    
    p[0] = 1;
    for (int i = 1; i < N; ++ i )
        p[i] = p[i - 1] * P;
    
    for (int i = 1; i <= n; ++ i )
        for (int j = 1; j < str[i].size(); ++ j )
            f[i][j] = f[i][j - 1] * P + str[i][j];
    
    for (int i = 1; i <= n; ++ i )
        calc(i, true);
    
    int res = 0;
    for (int i = 1; i <= n; ++ i )
        for (int j = 1; j < str[i].size(); ++ j )
            for (int k = 0; k < 26; ++ k )
                res = max(res, modify(i, j, k));
    
    cout << res << endl;
    
    return 0;
}
```

### 再优化 $O(Cn^3)$

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 2e2 + 10;

int n;
string str[N];
int g[N];
int tot;
int f[N][N][N];     //  [i, j, k] 第i个字符串和 第j个字符串 k个字符起最大连续数量

void init()
{
    for (int i = 1; i <= n; ++ i )
        for (int j = i + 1; j <= n; ++ j )
        {
            int mn = min(str[i].size(), str[j].size());
            for (int k = mn - 1; k >= 0; -- k )
                if (str[i][k] == str[j][k])
                    f[i][j][k] = f[j][i][k] = f[i][j][k + 1] + 1;
        }
    
    for (int i = 1; i <= n; ++ i )
    {
        for (int j = 1; j <= n; ++ j )
            g[i] += f[i][j][0];
        tot += g[i];
    }
    
    tot /= 2;
}

int modify(int u, int k, int c)
{
    int res = 0;
    for (int i = 1; i <= n; ++ i )
        if (i != u)
        {
            int left = min(f[u][i][0], k);
            res += left;
            
            if (left == k && str[i].size() > k && str[i][k] - 'a' == c)
            {
                res ++;
                res += f[u][i][k + 1];
            }
        }
    
    return tot - g[u] + res;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n;
    for (int i = 1; i <= n; ++ i )
        cin >> str[i];
    
    init();
    
    int res = 0;
    for (int i = 1; i <= n; ++ i )
        for (int j = 0; j < str[i].size(); ++ j )
            for (int k = 0; k < 26; ++ k )
                res = max(res, modify(i, j, k));
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：szh_AK_all (赞：2)

先预处理出每对字符串间从对应下标开始的最大公共子串，也就是设 $f_{i,j,k}$ 表示从 $s_{i,k},s_{j,k}$ 开始向后延伸，使 $s_{i,k+p}=s_{j,k+p}(p\le now)$ 的最大 $now$。

那么起初每对字符串的最长公共前缀之和显然为 $\sum_{i<j} f_{i,j,1}$。

然后枚举每个字符串的每一位改成每一个字符，考虑其贡献。假设当前修改的是第 $i$ 个字符串的第 $j$ 位，将其改成了 $e$，枚举其他字符串 $s_k$，考虑修改后 $s_i,s_k$ 的最长公共前缀为多少。设 $u=f_{i,k,1},uu=f_{i,k,u+2}$，则分为如下几种情况：

- $s_k=e$ 且 $j=u+1$，那么此时 $s_i,s_k$ 的最长公共前缀为 $u+1+uu$。

- $s_k=e$ 且 $j\ne u+1$，没有影响，最长公共前缀仍为 $u$。

- $s_k\ne e$ 且 $j>u$，显然也没有影响。

- $s_k\ne e$ 且 $j\le u$，此时最长公共前缀为 $j-1$。

如此统计答案即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
string s[205];
int f[205][205][205];

int main() {
	int n;
	cin >> n;
	int da = 0;
	for (int i = 1; i <= n; i++) {
		cin >> s[i];
		s[i] = " " + s[i];
		for (int j = 1; j < i; j++) {
			int now = 1;
			while (1) {
				int nn = now - 1;
				while (nn + 1 <= min(s[i].size(), s[j].size() - 1) && s[i][nn + 1] == s[j][nn + 1])
					nn++;
				for (int k = now; k <= nn; k++)
					f[i][j][k] = nn - now + 1;
				now = nn + 2;
				if (now > min(s[i].size(), s[j].size()))
					break;
			}
			da += f[i][j][1];
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < (int)s[i].size(); j++) {
			for (int k = 1; k <= 26; k++) {
				char e = 'a' + k - 1;
				int tmp = 0;
				for (int y = 1; y <= n; y++) {
					if (y == i || j > s[y].size() - 1)
						continue;
					int u = f[max(y, i)][min(y, i)][1], uu = f[max(y, i)][min(y, i)][u + 2];
					tmp -= u;
					if (s[y][j] == e) {
						if (j == u + 1)
							tmp += u + 1 + uu;
						else
							tmp += u;
					} else {
						if (j > u)
							tmp += u;
						else
							tmp += j - 1;
					}
				}
				ans = max(ans, da + tmp);
			}
		}
	}
	cout << ans;
}
```

---

## 作者：SFlyer (赞：1)

~~没 AC$\neq$不能写题解。~~

$n,|s_i|$ 同阶。

首先求出 $P(s_i,s_j)$ 可以在 $\mathcal{O}(n^3)$ 简单做到。为了方便，可以先求出 $\sum_{i,j}P(s_i,s_j)$。

考虑如果修改第 $x$ 个串，那么 $\sum_{i,j\neq x}P(s_i,s_j)$ 不变，只需要考虑 $\sum_{i} P(s_x,i)$ 最大是多少就可以了。

可以预处理对所有串建出一个 trie（$\mathcal{O}(n^2)$），边权为有多少个串经过。对于枚举的 $x$，每一个结点到根的边权和（特殊减去 $x$ 自己的）就是修改后的值，判断一下能不能一步到达即可。

总复杂度 $\mathcal{O}(n^3)$，和 $\mathcal{O}(n^3\cdot \sum)$ 区别就是，目前没有修改的可以“一起走”，“单独走”会浪费复杂度。

---

## 作者：zyxjeek (赞：0)

## 题意简述

给定 $n$ 个字符串 $s_{1 \sim n}$ ，修改某字符串的某个字符，使 $\sum_{i<j} \operatorname{LCP}(s_i,s_j)$ 最大。$\operatorname{LCP}(p, q)$ 为字符串 $p, q$ 的最长公共前缀长度。

## 思路

考虑 dp。定义 $f_{i, j, k}$ 表示 $s_i$ 和 $s_j$ 从第 $k$ 位开始到结尾的子串的最长公共前缀长度。

状态转移：
$$
f_{i, j, k} = 
\begin{cases}
0, & s_{i, k} \neq s_{j, k}\\
f_{i, j, k+1} + 1, & s_{i, k} = s_{j, k}
\end{cases}
$$
统计答案时，我们枚举要修改的字符串编号 $i$，修改字符的下标 $k$ 和修改后的字符 $c$。记这次修改可以使答案增加 $d$。对于所有 $j \neq i$，有以下两种情况使答案变动：

- 如果 $f_{i, j, 1} = k-1$ 且 $c = s_{j,k}$，这说明原本 $s_i$ 和 $s_j$ 相等的部分在第 $k$ 位这里断开了，修改之后可以给它接上。$d \gets d + f_{i,j,k+1}+1$。

- 如果 $f_{i,j,1} \ge k$ 且 $c \neq s_{j,k}$，这说明原本 $s_i$ 和 $s_j$ 有一个较长的最长公共前缀，我们这次修改给它破坏了。$d \gets d - (f_{i,j,1}-k+1)$。

记原本不加修改的答案为 $ans$。则 $ans + \max\{d\}$ 即为最终答案。时间复杂度 $\mathcal O(n^2|s_i||\sum|)$，其中 $|\sum| = 26$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 205;
string s[N];
int f[N][N][N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
        s[i] = " " + s[i];
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            for (int k = min(s[i].size(), s[j].size())-1; k >= 1; k--)
                if (s[i][k] == s[j][k])
                    f[i][j][k] = f[i][j][k+1] + 1;
    int ans0 = 0;
    for (int i = 1; i <= n; i++)
        for (int j = i+1; j <= n; j++)
            ans0 += f[i][j][1];
    int ans = ans0;
    for (int i = 1; i <= n; i++) {
        for (int k = 1; k < s[i].size(); k++) {
            for (char c = 'a'; c <= 'z'; c++) {
                int add = 0;
                for (int j = 1; j <= n; j++) {
                    if (j == i || k >= s[j].size()) continue;
                    if (f[i][j][1] == k-1 && c == s[j][k])
                        add += f[i][j][k+1]+1;
                    if (f[i][j][1] >= k && c != s[j][k])
                        add -= f[i][j][1]-k+1;
                }
                ans = max(ans, ans0+add);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

---


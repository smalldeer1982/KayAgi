# [蓝桥杯 2024 省 B 第二场] 遗迹（加强版）

## 题目背景

与原题相比，去除了【数据保证随机】。

## 题目描述

小蓝找到了一个外星文明留下来的遗迹，遗迹大门的屏幕上有一个长度为 $m$ 的字符串 $t$ 和一个输入框，下面还有一个键盘，键盘为一个长度为 $n$ 的字符串 $s$ ，由一个可以横向移动的指针来敲击键盘，指针可以向左移或向右移，不能移出键盘。

小蓝需要在键盘字符串 $s$ 上先指定指针初始位置然后不断移动指针的位置，过程中通过敲击指针所在的字符来进行输入。然而，指针最多只能移动 $L$ 的距离，小蓝想输入一个尽可能长的一个 $t$ 的前缀，请问他最多能输入多少位。

## 说明/提示

### 样例说明

初始选择指针位于键盘 $\tt{abc}$ 上的 $\tt{a}$，输入 $\tt{acbbac}$ 这 $6$ 个字符分别需要指针移动 $0, 2, 1, 0, 1, 2$ 的距离，而最大移动距离为 $5$，所以最多输入 $5$ 个字符，移动 $0 + 2 + 1 + 0 + 1 = 4$ 的距离。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq m \leq 20$；
- 对于所有评测用例，$1 \leq n \leq 10^3$，$1 \leq m \leq 10^5$，$1 \leq L \leq 10^9$ 且 $s, t$ 中只包含小写字母，且 $s$ 中一定包含所有 $t$ 中出现过的字母。

## 样例 #1

### 输入

```
3 6 5
abc
acbbac```

### 输出

```
5```

# 题解

## 作者：chzhh_111 (赞：2)

~~前情提要：由于两个字符串数组大小写反，硬控我半个小时。~~

考虑动态规划。

我们设一个状态 $dp_{i,j}$，用来表示此时此刻，这个指针处于键盘的第 $i$ 位的时候已经打到了字符串 $t$ 的第 $j$ 位所需的最小步数，很显然如果 $\min(dp_{i,j}) \le L$ 的话，这个长度为 $j$ 的前缀就是能够到达的，即我们可以更新答案。

那该怎么转移呢？

对于一个位置 $k$ 肯定是从它的左边或者右边过来，所以我们就可以用两次循环来解决这个问题。我们每一次都去寄存从它左边或者从它右边过来到这个位置的最小值，这里可以用一个单调栈来解决。但是可能有人会对此有疑问，大致可能就是光去寄存 $dp_{i,j-1}$ 最小值还远远不够。因为从位置 $i$ 转移到位置 $k$ 还有路径贡献，也就是还有转移路径。那为什么可以直接统计呢？那是因为我们可以发现，转移路径的步数增加是对所有转移的结果，即现在更优的在以后也肯定更优。

所以我们就可以写出动态转移方程：$dp_{k,j}= \min(dp_{i,j-1}+len(i,k))$，其中 $len(i,k)$ 表示，从位置 $i$ 走到位置 $k$ 所需要的步数。

虽然这样子的时间复杂度是 $O(nm)$，但是由于还要加上进栈和退栈的时间，所以可能常数比较大，无法通过此题，只能得到 $85$ 分。所以我们就要考虑优化常数。我们可以发现上述过程可以只用一个变量来统计，对于每一个即将进栈的数，我们直接比大小就行了，于是就可以通过此题了。

代码部分：
```cpp
// dp数组用滚动数组优化内存
//如果无法到达，就用无穷大来代替这个状态
//minx就是充当单调栈的作用
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e3+1,M=1e5+1;
int n,m,L,dp[2][N],tot,ans;
char s[N],t[M];
signed main()
{
	scanf("%lld%lld%lld\n%s\n%s",&n,&m,&L,s+1,t+1);
	for(register int i=1;i<=m;i++)
	{
		int tott=tot^1,mini=1ll<<31,minx=1ll<<31;
		memset(dp[tott],127/3,sizeof(dp[tott]));
		for(int j=1;j<=n;j++)
		{
			minx=min(minx,dp[tot][j]);
			if(s[j]==t[i])
			{
				dp[tott][j]=min(dp[tott][j],minx);
				mini=min(mini,dp[tott][j]);
			}
			minx++;
		}
		for(int j=n;j>=1;j--)
		{
			minx=min(minx,dp[tot][j]);
			if(s[j]==t[i])
			{
				dp[tott][j]=min(dp[tott][j],minx);
				mini=min(mini,dp[tott][j]);
			}
			minx++;
		}
		tot=tott;
		if(mini<=L) ans=i;
		else break;
	}
	printf("%lld",ans);
	return 0;
}
```
如有更优做法，欢迎提供。

---

## 作者：Imerance1018 (赞：2)

### Description

[传送门](https://www.luogu.com.cn/problem/P12129)

### Solution

考虑 DP。

定义 $f_{i,j}$ 表示当前在键盘的第 $i$ 个位置，打印到第 $j$ 个前缀的最小移动距离，然后取最大的 $j$ 满足存在 $1 \le i \le n$ 是 $f_{i,j} \le l$ 即可。

使用刷表法，显然有 $f_{k,j+1}=\min {f_{i,j}+|k-i|}$，满足 $s_k=t_j+1$，时间复杂度为 $O(mn^2)$。


注意到只有当 $s_i=t_j$ 时状态才有意义，所以定义 $pos_{j,i}$ 为在 $s$ 中从左往右第 $i$ 个元素使 $t_j=s_i$，然后将状态改为 $f_{i,j}$ 表示在位置 $pos_{j,i}$ 上填前 $j$ 位的花费，这样状态就少多了。（当然实际写的时候可以改成类似 ASCII 码的形式）

但此时时间复杂度并未降低，仍为 $O(mn^2)$。~~但可以拿到 75 分的好成绩~~。

注意到，对于第 $i$ 个位置只会转移到它左右最近的两个 $k$。（可以证明转移到其他的 $k$ 一定不优于这两个 $k$）

那么又因为 $pos_j$ 单调递增，在枚举 $i$ 时维护一下不大于 $pos_{j,i}$ 的 $pos_{j+1,k}$ 使 $k$ 最大即可，而这的复杂度是均摊 $O(1)$ 的。

所以时间复杂度就被降到了 $O(mn)$，滚动数组将空间降到 $O(n)$，可过。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,m,l,ans;
string x,y;
vector<int>pos[26];
vector<int>f[2];
signed main()
{
	cin>>n>>m>>l>>x>>y;
	x='*'+x;
	y='*'+y;
	for(int i=1;i<=n;i++)pos[x[i]-'a'].emplace_back(i);//注意这里维护字母的 ASCII 值，更方便
	for(int i=0;i<2;i++)
		for(int j=1;j<=n;j++)
			f[i].emplace_back(1e18);
	for(int i=0;i<pos[y[1]-'a'].size();i++)
		f[1][i]=0;
	for(int j=1;j<m;j++)
	{
		int pos1=-1;
		for(int i=0;i<pos[y[j]-'a'].size();i++)
		{
			if(f[j&1][i]==1e18)continue;
			while(pos1+1<pos[y[j+1]-'a'].size()&&pos[y[j+1]-'a'][pos1+1]<=pos[y[j]-'a'][i])pos1++;
			if(pos[y[j+1]-'a'][0]<=pos[y[j]-'a'][i])
			{
				int k=pos1;
				f[(j+1)&1][k]=min(f[(j+1)&1][k],f[j&1][i]+abs(pos[y[j]-'a'][i]-pos[y[j+1]-'a'][k]));
			}
			if(pos[y[j+1]-'a'][pos[y[j+1]-'a'].size()-1]>pos[y[j]-'a'][i])
			{
				int k=pos1+1;
				f[(j+1)&1][k]=min(f[(j+1)&1][k],f[j&1][i]+abs(pos[y[j]-'a'][i]-pos[y[j+1]-'a'][k]));
			}
			if(f[j&1][i]<=l)ans=max(ans,j);
			f[j&1][i]=1e18;
		}
	}
	for(int i=0;i<pos[y[m]-'a'].size();i++)
		if(f[m&1][i]<=l)ans=m; 
	cout<<ans;
	return 0;	
}
``````

---

## 作者：ZinfI_Sh (赞：1)

读完题目，我们可以想到一个很朴素的 dp 式，即：

$$dp_{i,j(s_j=t_i)}=\displaystyle\min_{s_k=t_{i-1},dp_{i-1,k}+|j-k|\le L}\{dp_{i-1,k}+|j-k|\}$$

$dp_{i,j}$ 表示要输入 $t$ 的第 $i$ 位时，指针最后指向第 $j$ 位，注意一下要滚动数组优化，不然空间开不了。具体的答案判断是如果枚举到的 $i$，没有一个 $dp$ 可以转移，那么答案就是 $i-1$。时间复杂度是 $O(mn^2)$ 的，简单优化一下可以干到 $75$ 分。

我们来看一下，这样做会枚举哪几层：

第一层：枚举 $i$，这很大概率不能优化了。

第二层：枚举 $j$，也很大概率不能优化。

那么集中在第三层，发现：此时枚举的 $j$ 所针对的 $dp_{i-1}$ 都是一样的；看到 dp 式中的绝对值，我们可以想到：分别从左和从右枚举两次，那么比如在从左往右的枚举中：

若 $j_1$ 对应的最小 $dp_{i-1,k}$ 是 $k_1$，$j_2$ 对应着 $k_2$，且 $j_2\gt j_1$，那么一定会有 $k_2\ge k_1$。

为什么呢？很简单，若 $k_2\lt k_1$，那么此时 $dp_{i-1,k_2}$ **肯定** $dp_{i-1,k1}$ 优，即 $j_1$ 也就会对应到 $k_2$ 上了。这个表粗的**肯定**其实还隐藏着一个原因：从左到右枚举，指针移动的步数是逐步累加的。

那么我们可以记一个 $best$，从左到右枚举时，若 $dp_{i-1,j}<dp_{i-1,best}+j-best$，那么就将 $best$ 设为 $j$。$j-best$ 是指若当前 $j$ 对应到之前的 $best$ 上，那么指针走的步数就是 $j-best$。

总时间复杂度 $O(nm)$，常数为 $2$ 或 $3$。

_注：但不知道为什么我的代码会卡到 4 秒左右。_

```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = {0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
const int HASHMOD = 8;
const int HASHBASE = 3000;
const int HASHITEM = 999997;
int dp[2][1101];
char s[1001], t[100001];
signed main()
{
    int n, m, l;
    scanf("%Ld%Ld%Ld\n%s\n%s", &n, &m, &l, s + 1, t + 1);
    int f = 0, ans = 1;
    bool check = 1;
    for (int i = 1; i <= n; i++)
    {
        dp[0][i] = dp[1][i] = INT_MAX;
        if (s[i] == t[1])
        {
            dp[0][i] = 0;
        }
    }
    for (int i = 2; i <= m; i++)
    {
        int tmp = INT_MAX, best = 0;
        check = 0;
        memset(dp[f ^ 1], 0x3f, sizeof(dp[f ^ 1]));
        dp[f][best] = dp[f][n + 1] = INT_MAX;
        for (int j = 1; j <= n; j++)
        {
            if (s[j] == t[i - 1])
            {
                if (dp[f][j] < dp[f][best] + j - best)
                {
                    best = j;
                }
            }
            if (s[j] == t[i] && dp[f][best] + j - best <= l)
            {
                dp[f ^ 1][j] = min(dp[f ^ 1][j], dp[f][best] + j - best);
                tmp = min(tmp, dp[f ^ 1][j]);
                check = 1;
            }
        }
        best = n + 1;
        for (int j = n; j >= 1; j--)
        {
            if (s[j] == t[i - 1])
            {
                if (dp[f][j] < dp[f][best] + best - j)
                {
                    best = j;
                }
            }
            if (s[j] == t[i] && dp[f][best] + best - j <= l)
            {
                dp[f ^ 1][j] = min(dp[f ^ 1][j], dp[f][best] + best - j);
                tmp = min(tmp, dp[f ^ 1][j]);
                check = 1;
            }
        }
        f ^= 1;
        if (!check)
        {
            break;
        }
        ans = i;
    }
    cout << ans;
}
```

_笑点解析：$$O(mn^2)$$ 的代码调了一个上午全 WA，一看发现语言选到 PHP 了……_

---


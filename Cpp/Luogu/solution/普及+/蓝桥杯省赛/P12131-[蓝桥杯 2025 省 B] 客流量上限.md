# [蓝桥杯 2025 省 B] 客流量上限

## 题目描述

一家连锁旅馆在全国拥有 $2025$ 个分店，分别编号为 $1$ 至 $2025$。随着节日临近，总部决定为每家分店设定每日客流量的上限，分别记作 $A_1, A_2, \dots , A_{2025}$。这些上限并非随意分配，而是需要满足以下约束条件：
1. $A_1, A_2, \dots , A_{2025}$ 必须是 $1$ 至 $2025$ 的一个排列，即每个 $A_i$ 均是 $1$ 至 $2025$ 之间的整数，且所有 $A_i$ 互不相同。
2. 对于任意分店 $i$ 和 $j$（$1 \leq i, j \leq 2025$，$i$ 可等于 $j$），它们的客流量上限 $A_i$ 和 $A_j$ 的乘积不得超过 $i \times j + 2025$。

这些约束旨在平衡各分店客流压力，确保服务质量和运营稳定性。

现在，请你计算这样的分配方案究竟有多少种。由于答案可能很大，你只需输出其对 $10^9 + 7$ 取余后的结果即可。

# 题解

## 作者：brofea5 (赞：33)

# 题意

求 $1～2025$ 的排列 $A_{1}～A_{2025}$ 使得任意的 $1\le i\le j \le 2025$ ，$A_i\times A_j \le i\times j +2025$ 都成立的合法排列数量

答案取模 $1\times10^9+7$

# 思路

当 $i=j$ 时，$A_i^2 \le \lfloor i^2 +2025\rfloor$，跑一次循环可知当 $1013\le i\le 2025$ 时，$A_i\le i$

且由于 $A_{1～1012}$ 都小于 $1013$，所以 $A_{1～1013}$ 就会把 $1～1013$ 都占用完，所以 $A_{1014}$ 只能等于 $1014$，$A_{1015}$ 只能等于 $1015$……以此类推可以得到：

$$
A_i=i~(1014\le i\le 2025)
$$

对于任意的 $1\le i\le 1012,1014\le j\le 2025$，都满足：$A_iA_j=A_ij\le ij+2025$，两边同除 $j$ 即：$A_i\le \lfloor i+2025/j\rfloor$，任意 $j$ 都要满足此式，所以根据 $j$ 的范围可以得到

$$
A_i\le  i+1~(1\le i\le 1012)
$$

我们可以看看在此式下是不是满足题目条件：$(1\le i\le 1012)$

$$
A_i A_j \le (i+1)(j+1)=ij+i+j+1\le ij +2025
$$

由于 $i+j+1\le1012+1012+1=2025$ 所以满足题目条件

也就是说：

- $A_1$ 可以取 $1,2$
- $A_2$ 可以取 $1,2,3$
- $A_3$ 可以取 $1,2,3,4$
    
    **……**
    
- $A_{1012}$ 可以取 $1,2,3,4......1013$
- $A_{1013}$ 可以取 $1,2,3,4......1013$

那么 $A_1$  取法有 $2$ 种，取了一个后 $A_2$ 取法有 $2$ 种……取了 $1011$ 个后 $A_{1012}$ 取法有两种，而 $A_{1013}$  只能取 $A_{1012}$ 取剩下的

总共 $2^{1012}$ 种，使用快速幂或者暴力解都行

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
int qmi(int m, int k, int p) {
  long long t = m, res = 1;
  while (k ) {
    if (k&1) res = res*t%p;
    t = t*t%p;
    k >>=1;
  }
  return res;
}
int power(int m, int k, int p) {
  int res = 1;
  while (k--)
    res = res * m % p;
  return res;
}
signed main() {
  cout << qmi(2, 1012, MOD) << "\n";
  cout << power(2, 1012, MOD) << "\n";
  return 0;
}
```

---

## 作者：sunkuangzheng (赞：14)

首先可以根据 $i=j$ 时的限制计算出一个上界 $a_i \le \sqrt{i^2+2025}$，但是这个条件并不是充分的。不过它引出了一个重要观察：当 $i \ge 1013$ 时一定有 $a_i \le i$。

注意到 $1$ 位置只可以填 $1,2$，考虑每个位置和 $2025$ 的限制，有 $2025a_i \le 2025i+2025$，即 $a_i \le i + 1$。

接下来我们证明 $a_i \le \min(\sqrt{i^2+2025},i+1)$ 就是充要条件，必要性已经在前面完成证明。此时会有 

$$a_i \le  \begin{cases} i+1 & i < 1013\\ i & i \ge 1013\end{cases}$$

将 $i,j(i \le j)$ 分为三类：

- $i,j \ge 1013$，此时 $a_ia_j \le ij \le ij + 2025$。
- $i < 1013 \le j$，此时 $a_ia_j \le (i+1)j = ij + j \le ij+2025$。
- $i,j < 1013$，此时 $a_ia_j \le (i+1)(j+1)=ij+i+j+1\le ij+2025$。

因此上述条件是充要的。

计数部分考虑从 $1 \to 2025$ 一个一个填，$1 \sim 1012$ 每个位置都只有两个选法，$1013 \sim 2025$ 每个位置只有唯一填法。因此答案是 $2^{1012} \equiv 781448427 \pmod {10^9+7}$。

---

## 作者：cxy_chen0 (赞：4)

# 解题思路

## 1. 初始观察与微扰分析

我们首先发现：当 $i = a_i$ 时，条件一定成立。\
进一步思考是否可以通过微扰（如交换相邻两个数）来扩展可行解集。

考虑交换相邻两个元素 $i$ 和 $i+1$，即：

- 原来是 $a_i = i$ , $a_{i+1} = i + 1$
- 交换后变成 $a_i = i+1$ , $a_{i+1} = i$

此时判断交换后是否满足条件：

$$
a_i \times a_j \le i \times j + 2025
$$

代入得：

$$
(i+1) \cdot i \leq i \cdot (i+1) + 2025
$$

显然成立。更大范围因为没有交换，所以也一定成立，但我们要考虑更严苛的情况，即取 $i = j$ 时：

$$
a_i^2 = (i + 1)^2 \le i^2 + 2025
$$

化简得到：

$$
i \le 1012
$$

因此可以得出结论：

> 当 $i \ge 1013$ 时，连最小影响的交换（冒泡交换）都不满足条件，更大距离的交换更不可能成立（贪心思想）。

- [图 1：对于冒泡排序 $i \le 1012$ 的想法和证明](https://cdn.luogu.com.cn/upload/image_hosting/avok4y7s.png)

## 2. 排除相邻交换以外的情况

我们接下来证明：**当 $i \le 1012$ 时，交换不相邻的两个数一定不能满足条件**。

使用数学归纳法进行证明：

设交换的两个位置间隔为 $k$，其中 $k \in \mathbb{Z}^+$。
选取最极端情况 $j = 2025$ 验证，我们尝试验证如下不等式是否成立：

$$
(i + k) \cdot 2025 \leq i \cdot 2025 + 2025
$$

化简得：

$$
k \cdot 2025 \leq 2025 \Rightarrow k \leq 1
$$

这说明只有当 $k = 1$（即相邻交换）时才有可能成立，其余情况均不成立。

> **仅允许相邻交换**，其它交换方式都会导致条件不成立。

- [图 2：数学归纳法证明交换的两个数必须是相邻的](https://cdn.luogu.com.cn/upload/image_hosting/63nsthdx.png)

## 3. 相邻交换重叠情况不影响最终结果

我们进一步分析多个相邻交换叠加的情况：
直接从最极端情况分析，假设从位置 1 到 1012 每个位置都进行一次相邻交换，则最终序列变为：

```
{2, 3, 4, ..., 1012, 1, 1013, 1014, ..., 2025}
```

观察该序列：

- 所有位置 $i \le 1012$ 都错开了一个位置；
- 最后一个被交换的是 1 ，它位于第 1012 位；
- 计算其乘积 $1012 \times 1$ 显然小于 $1011 \times 1012 + 2025$。
- 接着计算 $1011 \times 1012$ $\le$ $1010 \times 1011 + 2025$。
- $1010 \times 1011$ $\le$ $1009 \times 1010 + 2025$。
- 推出 $(i + 1) \times (i + 2)$ $\le$ $i \times (i + 1) + 2025$。$(1 \le i \le 1011)$

因此可以得出：

> 即使多个相邻交换重叠，也不会破坏条件，所有这样的排列都是合法的。

由于每个位置 $i \le 1012$ 都可以选择“交换” 或“不交换”，所以总共有：$2^{1012} \bmod (10^9 + 7)$ 种合法排列。

- [图 3：证明重叠的交换情况不影响结果](https://cdn.luogu.com.cn/upload/image_hosting/axw3oqww.png)

---

推导完成后代码就简单了

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1e9 + 7;

ll fast_pow(ll a, ll b, int mod)
{
    ll ans = 1;
    while (b)
    {
        if (b & 1) ans = (ans * a) % mod;
        b >>= 1;
        a = (a * a) % mod;
    }
    return ans;
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    cout << fast_pow(2, 1012, MOD);
    return 0;
}
```

---

## 作者：yongqian123 (赞：3)

## 题目简述
应该都能理解，就不多说了。

## 题目分析
针对一句话：

对于任意分店 $i$ 和 $j(1\le i,j\le2025)$，它们的客流量上限 $A_i$ 和 $A_j$ 的乘积不得超过 $ij+2025$。

所以，对于任意分店 $i(1\le i\le2025)$，它的客流量上限 $(A_i)^2$ 不得超过 $i^2+2025$。

$$(A_i)^2\le i^2+2025$$
$$A_i\le\sqrt{i^2+2025}$$

很容易想到打表：

```cpp
for (int i = 1; i <= 2025; i++) cout << i << ':' << (int)sqrt(i * i + 2025) << '\n';
```

打表发现：

$$A_i\le i(i\ge1013)$$

因为 $A_{1\sim1012}\le1012$，已经把 $1\sim1012$ 占满了，所以 $A_{1013\sim2025}$ 只有唯一解，即 $A_i=i(1013\le i\le2025)$。

那么当 $1\le i<1013\le j\le2025$ 时，
$$A_iA_j=A_ij$$
$$A_iA_j\le ij+2025$$

则，

$$A_ij\le ij+2025$$
$$A_i\le i+\frac{2025}{j}$$
$$A_i\le\lfloor i+\frac{2025}{j}\rfloor$$
$$A_i\le i+\lfloor\frac{2025}{j}\rfloor$$

由于 $1013\le j\le2025$，所以，

$$A_i\le i+1$$
$$A_i\in[1,i+1]$$

根据此式，得出：

$A_1$ 有 $1+1=2$ 种选择；

$A_2$ 选的不与 $A_1$ 选的重复，有 $2+1-1=2$ 种选择；

$A_3$ 选的不与 $A_{1\sim2}$ 选的重复，有 $3+1-2=2$ 种选择；

……

$A_i$ 选的不与 $A_{1\sim i-1}$ 选的重复，有 $i+1-(i-1)=2$ 种选择。

所以答案就是 $2^{1012}\mod(10^9+7)$。

## 重点代码
`pw` 函数递归调用求 $2$ 的幂。

个人认为，位运算比乘除法更省时间，能省一点是一点（普通的方法，` << 1` 可以改成 ` * 2`）。

```cpp
int pw(int x){
	if (!x) return 1;
	return (pw(x - 1) << 1) % MOD;
}
```

---


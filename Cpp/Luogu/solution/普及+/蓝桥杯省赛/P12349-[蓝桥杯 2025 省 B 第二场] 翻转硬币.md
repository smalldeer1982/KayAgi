# [蓝桥杯 2025 省 B 第二场] 翻转硬币

## 题目描述

给定 $n$ 行 $m$ 列共 $n \times m$ 个硬币，对于任意一个硬币，我们将其价值视为与其相邻（指上、下、左、右相邻）的硬币中与其正反相同的硬币数的平方。

你可以进行任意次操作，每次可以选择任意一行并将该行的硬币全部翻转。

求所有硬币的价值之和最大可能是多少。

## 说明/提示

### 样例说明

如图，实线表示正面，虚线表示反面，翻转最后一行可以得到最大价值和：

![](https://cdn.luogu.com.cn/upload/image_hosting/207dpqzp.png)

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n, m \leq 20$；
- 对于所有评测用例，$1 \leq n, m \leq 1000$。

## 样例 #1

### 输入

```
4 4
1010
1111
1011
1100```

### 输出

```
68```

# 题解

## 作者：KK_luck (赞：6)

# P12349 题解
## 思路
考虑动态规划。我们可以观察到，硬币翻转只与其上下的硬币是否翻转有关，与左右是否翻转无关，且每一行的硬币的贡献只与其上下行的贡献有关，我们可以考虑每一行的局部最优从而决定全局最优。
## 状态定义
由于每一行的贡献取决于其上下两行的贡献，所以我们必须枚举到第 $i+1$ 行，才能求出第 $i$ 行的最大贡献，那么，该怎么记录每一行的状态呢？可以想到，用 `dp[i+1][j][k]` 记录状态，其中 $j$ 表示 $i+1$ 行翻不翻，$k$ 表示其 $i$ 行翻不翻，我们用该式记录的是 $i$ 行的最大值，已经有了第 $i+1$ 和 $i$ 行的状态了，怎么知道 $i-1$ 行的状态呢？没错，`dp[i][j][k]` 中的 $k$ 即是 $i-1$ 行的状态。
## 转移方程
由于我们知道了 $i-1$ 行和 $i$ 行的状态，所以只要取 $i-2$ 行的两个状态的最大值加上状态约束下的值就行了。某一状态的转移方程为：$$dp[i][0][0] = \max 
\left\{ \begin{aligned} &dp[i-1][0][1] + \operatorname{val}(i-1, 1, 0, 0), \\ 
&dp[i-1][0][0] + \operatorname{val}(i-1, 0, 0, 0) 
\end{aligned} 
\right\}$$。
## 代码思路
根据状态转移方程，枚举每一行四种状态的最大值，最后从最后一行的四种状态中选出最大值输出。
```C++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6;
int graph[1010][1010], dp[1010][2][2], n, m;
int dx[4] = {0,0,1,1}, dy[4] = {0,1,0,1};//四种状态
int com(int x, int pre, int now, int nex) //计算在状态约束下当前行的贡献，pre 表示前行约束，now 表示当前行，nex 表示下一行。
{
	int res = 0;
	for (int r = 1; r <= m; r++){
		int t = 0;
		if(graph[x][r] == graph[x][r - 1]) t++;
		if(graph[x][r] == graph[x][r + 1]) t++;
		if(x - 1 > 0)
			if(!(now == pre ^ graph[x][r] == graph[x-1][r]))
				t++;
		if(x + 1 <= n)
			if(!(now == nex ^ graph[x][r] == graph[x+1][r]))
				t++;
		res += t* t;
	}
	return res;
}
int main()
{
	cin >> n >> m;
	memset(graph, -1, sizeof(graph)); 
	for(int i = 1; i <= n; i++){   //建图
		string t; cin >> t;
		for (int j = 1; j <= m; j++)
			graph[i][j] = t[j - 1] - '0';
	}
	for (int i = 0; i < 4; i++)  //初始化dp数组
		dp[2][dx[i]][dy[i]] = com(1,0,dy[i],dx[i]);
	for (int i = 3; i <= n + 1; i++){  //枚举每一行
		for (int j = 0; j < 4; j++)  //枚举四种状态
			dp[i][dx[j]][dy[j]] = max(dp[i-1][dy[j]][0] + com(i-1,0,dy[j],dx[j]), dp[i-1][dy[j]][1] + com(i-1,1,dy[j],dx[j]));
	}
	cout << max({dp[n + 1][0][0],dp[n + 1][0][1],dp[n + 1][1][0],dp[n + 1][1][1]});
	return 0;
 }
```

---

## 作者：vegetableYe (赞：3)

## 翻转硬币

这套蓝桥杯题里最像题的一个题。    



对于 $n, m \leq 20$ 的数据范围，理论上我们应该枚举每一行是否翻转，这样一来是 $2^n$ 的复杂度，对于每个状态我们再统计一遍答案取最大值即可。  

但这里出题人设置的数据范围就非常迷，上述的做法，在统计答案时是 $O(n\times m)$ 的，因此在 $n=20,m=20$ 的情况下，实际上是：$O(2^n \times n \times m \times 4)$ 的，再乘 $4$ 是因为统计答案时要枚举四个方向。这样一来大概率是会 TLE 的，所以这个数据范围就很奇怪。  

  

**正解**

我们注意到，实际上对于每一行是否翻转，对总代价的影响实际上最多只有相邻的上下两行，也就是说翻转一行只影响最多 $3$ 行，那么我们在考虑 $i-2, i-1, i$ 这三行时，只需要一个 $2^3$ 去枚举这三行是否翻转的状态以后，在 $i-2$ 行之前的答案，就不会再改变了。

**换句话说如果我们已经记录好了前 $i-3$ 行的最优答案，那么因为这个最优答案不会再受后面行是否翻转的影响，因此直接取这个最优值即可。（也就是说可以从这里直接转移）**  

上述分析过程，实际上就是启发我们想到本题的 "无后效性" 的一个想法。  

因此我们不妨考虑一个 $dp$：  

$dp_{i, 0/1, 0/1}$ 表示考虑了前 $i$ 行，第 $i$ 行是否翻转，第 $i-1$ 行是否翻转的最大总价值。  

但这样的状态设置会产生问题，我们会发现第 $i$ 行的所有硬币，它们产生的贡献是和 $i+1$ 行的硬币相关的，而我们枚举到第 $i$ 行肯定是没法确定 $i+1$ 以后的事情的。  

因此，这里我们需要一点变化，即我们将 $dp$ 表示的总价值往前移动一行，即：  

$dp_{i, 0/1, 0/1}$ 表示："考虑了前 $i$ 行，第 $i$ 行是否翻转，第 $i-1$ 行是否翻转"，这样的状态下，$1$ 到 $i-1$ 行的这些硬币产生的总代价的最大值。  

这样一来，第 $i-1$ 行产生的价值我们就可以计算了，因为此时我们已经知道了第 $i$ 行的状态（翻或者没翻）。  



状态设置搞定了，接下来是转移，这一部分就比较简单了，我们考虑从 $i-1$ 转移到 $i$，那多的代价其实只有第 $i-1$ 行产生的，而这一行产生的代价和上下两行都有关，因此我们枚举 $i-2,i-1,i$ 这 $3$ 行的所有状态（分别记作：$lst, k, j$），枚举一行的硬币 $O(m)$ 计算价值即可。

计算出价值记作 $sum$，则转移直接：$dp_{i,j,k}=\max(dp_{i,j,k},dp_{i-1,k,lst}+sum)$。



接下来是初始化，这一部分比较特殊，因为第一行不存在上一行，因此我们需要特殊的初始化，实际上过程和上述转移是类似的，我们直接 $O(2^2)$ 枚举第一行和第二行的状态，计算即可。（具体见代码）



最后，是最终的答案统计，在大部分 $dp$ 题中实际上这部分直接取 $dp_{n}$ 的状态取 $\max$ 之类的作为答案即可。但在本题中，我们需要注意 $dp_{n}$ 的定义，根据定义我们会发现，第 $n$ 行的贡献其实还没有计算。因此我们还需要做一个类似初始化的操作，枚举 $dp_n$ 的所有状态，来单独计算第 $n$ 行的贡献。

**代码：**

```cpp
#include<bits/stdc++.h>
#define x first
#define y second
#define endl '\n'
#define int long long
#define ll long long 
#define P pair<int, int>
using namespace std;

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

const int mod = 1e9 + 7;
const int MOD = 998244353;

void solve() {
	int n, m;
	cin >> n >> m;
	vector<string> g(n);
	for(int i = 0; i < n; i++) {
		cin >> g[i];
	}
	if(n <= 10) { // 我赛时写的20，写20会T的哎哎
		int ans = 0;
		for(int S = 0; S < (1 << n); S++) {
			vector<string> a;
			for(int j = 0; j < n; j++) {
				if(S >> j & 1) {
					a.emplace_back(g[j]);
				} else {
					string t;
					for(int k = 0; k < m; k++) {
						t += (g[j][k] ^ 1);
					}
					a.emplace_back(t);
				}
			}
			int s = 0;
			for(int i = 0; i < n; i++) {
				for(int j = 0; j < m; j++) {
					int c = 0;
					for(int k = 0; k < 4; k++) {
						int nx = i + dx[k], ny = j + dy[k];
						if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
						c += (a[nx][ny] == a[i][j]);
					}
					s += c * c;
				}
			}
			ans = max(ans, s);
		}
		
		cout << ans << endl;
	} else {
		vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(2)));
		for(int x = 0; x < 2; x++) {
			for(int y = 0; y < 2; y++) {
				int sum = 0;
				string a = g[0], b = g[1];
				if(y == 1) {
					for(auto & c : a) {
						c ^= 1;
					}
				}
				if(x == 1) {
					for(auto & c : b) {
						c ^= 1;
					}
				}
				
				for(int i = 0; i < m; i++) {
					int c1 = 0;
					if(i >= 1) {
						if(a[i - 1] == a[i]) {
							c1++;
						}
					}
					if(b[i] == a[i]) {
						c1++;
					}
					if(i + 1 < m) {
						if(a[i + 1] == a[i]) {
							c1++;
						}
					}
					sum += c1 * c1;
				}
				
				dp[1][x][y] = sum;
			}
		}
		
		for(int i = 2; i < n; i++) {
			for(int x = 0; x < 2; x++) {
				for(int y = 0; y < 2; y++) {
					for(int lst = 0; lst < 2; lst++) {
						int sum = 0;
						string a = g[i], b = g[i - 1], c = g[i - 2];
						if(y == 1) {
							for(auto & ch : a) {
								ch ^= 1;
							}
						}
						if(x == 1) {
							for(auto & ch : b) {
								ch ^= 1;
							}
						}
						if(lst == 1) {
							for(auto & ch : c) {
								ch ^= 1;
							}
						}
						
						for(int j = 0; j < m; j++) {
							int cnt = 0;
							if(j >= 1) {
								if(b[j - 1] == b[j]) {
									cnt++;
								}
							}
							if(b[j] == a[j]) {
								cnt++;
							}
							if(b[j] == c[j]) {
								cnt++;
							}
							if(j + 1 < m) {
								if(b[j + 1] == b[j]) {
									cnt++;
								}
							}
							sum += cnt * cnt;
						}
						
						dp[i][x][y] = max(dp[i][x][y], dp[i - 1][lst][x] + sum);
				}
			}
		}
		
		int ans = 0;
		for(int x = 0; x < 2; x++) {
			for(int y = 0; y < 2; y++) {
				string a = g[n - 2], b = g[n - 1];
				if(x == 1) {
					for(auto & ch : a) {
						ch ^= 1;
					}
				}
				if(y == 1) {
					for(auto & ch : b) {
						ch ^= 1;
					}
				}
				
				int sum = 0;
				for(int j = 0; j < m; j++) {
					int cnt = 0;
					if(j >= 1 && b[j] == b[j - 1]) {
						cnt++;
					}
					if(j + 1 < m && b[j] == b[j + 1]) {
						cnt++;
					}
					if(a[j] == b[j]) {
						cnt++;
					}
					sum += cnt * cnt;
				}
				ans = max(ans, dp[n - 1][x][y] + sum);
			}
		}
		
		cout << ans << endl;
	}
}

/*

4 4
1010
1111
1011
1100


*/

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int _ = 1;
//	cin >> _;
	while(_--) {
		solve();
	}
	return 0;
} 
```

时间复杂度：$O(n\times m \times 8)$。（$8$ 的复杂度来自于转移时枚举三行的状态。）

---

## 作者：dengyoukang (赞：2)

# 40pts
首先考虑部分分，对于 $n,m\le20$，我们可以考虑枚举每一排是否翻转，显然大于一次的翻转是无效的，可以的出时间复杂度为 $O(m\times2^n)$（如果使用dfs的话可以通过，数组形式会凭空多一个 $n$ 的复杂度）。

# 正解
我们可以注意到对于左右的无论怎么翻转都可行，我们只需要枚举上下即可确定固定的贡献值。所以我们可以枚举 $i+1$ 行来计算第 $i$ 行的贡献。我们从第 $i$ 行的 dp 可以知道上一行的状态，枚举 $i+1$ 和 $i+2$ 行得到答案。其中 $dp_{i+1,j,k}$ 表示 dp 到第 $i+1$ 行这一行状态为 $j$ ，上一行状态为 $k$ 的答案。
  
## 转移方程
$$
dp_{i,0,0}=\max(dp_{i-1,0,0}+getval(i-1,0,0,0),dp_{i-1,0,1}+getval(i-1,1,0,0))\\
dp_{i,0,1}=\max(dp_{i-1,1,0}+getval(i-1,0,1,0),dp_{i-1,1,1}+getval(i-1,1,1,0))\\
dp_{i,1,0}=\max(dp_{i-1,0,0}+getval(i-1,0,0,1),dp_{i-1,0,1}+getval(i-1,1,0,1))\\
dp_{i,1,1}=\max(dp_{i-1,1,0}+getval(i-1,0,1,1),dp_{i-1,1,1}+getval(i-1,1,1,1))
$$

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int dp[N][2][2],n,m;
int a[N][N];
int getval(int w,int x,int y,int z){
	int res=0;
	for(int i=1;i<=m;i++){
		int cnt=0;
		if(i>1&&a[w][i]==a[w][i-1])
			cnt++;
		if(i<m&&a[w][i]==a[w][i+1])
			cnt++;
		if(w>1){
			if(!(y==x^a[w][i]==a[w-1][i]))
				cnt++;
		}
		if(w<=n-1){
			if(!(y==z^a[w][i]==a[w+1][i]))
				cnt++;
		}
		res+=cnt*cnt;
	}
	return res;
}
int main(){
	cin>>n>>m;
	for(int i=1,s1;i<=n;i++){
		string s;
		cin>>s;
		s1=s.size();
		for(int j=1;j<=s1;j++){
			a[i][j]=s[j-1]-'0';
		}
	}
	dp[2][0][0]=getval(1,0,0,0);
	dp[2][0][1]=getval(1,0,1,0);
	dp[2][1][0]=getval(1,0,0,1);
	dp[2][1][1]=getval(1,0,1,1);
	for(int i=3;i<=n+1;i++){
		dp[i][0][0]=max(dp[i-1][0][0]+getval(i-1,0,0,0),dp[i-1][0][1]+getval(i-1,1,0,0));
		dp[i][0][1]=max(dp[i-1][1][0]+getval(i-1,0,1,0),dp[i-1][1][1]+getval(i-1,1,1,0));
		dp[i][1][0]=max(dp[i-1][0][0]+getval(i-1,0,0,1),dp[i-1][0][1]+getval(i-1,1,0,1));
		dp[i][1][1]=max(dp[i-1][1][0]+getval(i-1,0,1,1),dp[i-1][1][1]+getval(i-1,1,1,1));
	}
	int ans=0;
	ans=max(dp[n+1][0][0],max(dp[n+1][0][1],max(dp[n+1][1][0],dp[n+1][1][1])));
	cout<<ans<<"\n";
}
```

---

## 作者：01bit (赞：1)

设定 DP 状态 $f_{i,j,k}$ 为前 $i-1$ 行所有硬币的价值，其中 $i$ 为当前行数，$j,k\in\{0,1\}$ 表示第 $i$ 和 $i-1$ 行是否翻转。

每次从第 $i-1$ 行转移到第 $i$ 行时枚举第 $i-2$ 行是否翻转，并将第 $i-1$ 行硬币根据状态计入答案，取答案最大的状态即可。

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
const int N = 1000 + 5;
int n, m;
char s[N][N];
int f[N][2][2];
int val(int i, int x, int y, int z) {
    int res = 0;
    for (int j = 0; j < m; j++) {
        int cnt = 0;
        if (j > 0 && s[i][j] == s[i][j - 1])
            cnt++;
        if (j < m - 1 && s[i][j] == s[i][j + 1])
            cnt++;
        if (i > 0)
            cnt += (s[i][j] == s[i - 1][j]) ^ x ^ y;
        if (i < n - 1)
            cnt += (s[i][j] == s[i + 1][j]) ^ y ^ z;
        res += cnt * cnt;
    }
    return res;
}
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        cin >> s[i];
    for (int i = 1; i <= n; i++) {
        f[i][0][0] = max(f[i - 1][0][0] + val(i - 1, 0, 0, 0),
                         f[i - 1][0][1] + val(i - 1, 1, 0, 0));
        f[i][0][1] = max(f[i - 1][1][0] + val(i - 1, 0, 1, 0),
                         f[i - 1][1][1] + val(i - 1, 1, 1, 0));
        f[i][1][0] = max(f[i - 1][0][0] + val(i - 1, 0, 0, 1),
                         f[i - 1][0][1] + val(i - 1, 1, 0, 1));
        f[i][1][1] = max(f[i - 1][1][0] + val(i - 1, 0, 1, 1),
                         f[i - 1][1][1] + val(i - 1, 1, 1, 1));
    }
    cout << max(f[n][0][0], max(f[n][0][1], max(f[n][1][0], f[n][1][1])));
    return 0;
}
```

---

## 作者：maxiaomeng (赞：0)

# P12349 [蓝桥杯 2025 省 B 第二场] 翻转硬币

考虑 DP，在前 $i-1$ 行确定的基础上，增加新一行会使新行和上一行中硬币的贡献发生改变，所以需要知道上一行取不取反。

新行之前没有贡献，但上一行之前有贡献，所以要知道上一行原来的贡献，所以也得知道上上行的值。

所以状态可以表示为：$f_{i,j,k}$，$i$ 表示第 $i$ 行，$j$ 表示第 $i-1$ 行取不取反，$k$ 表示第 $i$ 行取不取反，转移方程如下：
$$f_{i,k,l}=\max_{j=0}^1{f_{i-1,j,k}+calc(i-1,j,k,l)}$$

其中 $calc(i,j,k,l)$ 计算贡献变化量，$j$ 表示第 $i-1$ 行取不取反，$k$ 表示第 $i$ 行取不取反，$l$ 表示第 $i+1$ 行取不取反。$calc(i,j,k,l)$ 的实现详见代码。

这样就能在 $O(nm)$ 的时间复杂度解决这道题。

```cpp
#include<bits/stdc++.h>
#define int long long
#define __builtin_popcount __builtin_popcountll
#define endl '\n'
using namespace std;
const int N=1005;
int n,m,a[N][N],f[N][2][2];
inline int calc(int l,int x,int y,int z){
	int pr=0,nr=0; // pr 表示旧贡献，nr 表示新贡献
	if(l){
		for(int i=1;i<=m;i++){ // 统计上行（第l行）旧贡献
			int zz=0;
			if(i!=1)zz+=(a[l][i-1]==a[l][i]);
			if(i!=m)zz+=(a[l][i+1]==a[l][i]);
			if(l!=1)zz+=((a[l-1][i]^x)==(a[l][i]^y));
			pr+=zz*zz;
		}
		for(int i=1;i<=m;i++){ // 统计上行新贡献
			int zz=0;
			if(i!=1)zz+=(a[l][i-1]==a[l][i]);
			if(i!=m)zz+=(a[l][i+1]==a[l][i]);
			if(l!=1)zz+=((a[l-1][i]^x)==(a[l][i]^y));
			if(l!=n)zz+=((a[l+1][i]^z)==(a[l][i]^y));
			nr+=zz*zz;
		}
	}
	for(int i=1;i<=m;i++){ // 统计这行（第l+1行）旧贡献
		int zz=0;
		if(i!=1&&l!=n)zz+=(a[l+1][i-1]==a[l+1][i]);
		if(i!=m&&l!=n)zz+=(a[l+1][i+1]==a[l+1][i]);
		if(l!=n&&l>0)zz+=((a[l][i]^y)==(a[l+1][i]^z));
		nr+=zz*zz;
	}
	return nr-pr;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			a[i][j]=(c&1);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=1;j++){
			for(int k=0;k<=1;k++){
				for(int l=0;l<=1;l++){
					f[i][k][l]=max(f[i][k][l],f[i-1][j][k]+calc(i-1,j,k,l));
				}
			}
		}
	}
	int r=0;
	for(int i=0;i<=1;i++){
		for(int j=0;j<=1;j++)r=max(r,f[n][i][j]);
	}
	cout<<r;
    return 0;
}
```

---

## 作者：Aristocrat (赞：0)

## **预处理**
- 读题后不难发现，由于只会翻转同一行的硬币，则对于同一枚硬币（设其坐标为$(i,j)$）左右两边与其正反相同的硬币数不会发生改变，将这个值存为 ```hang[i][j]```。
- 将两行间**只有一行**发生了翻转时的状态记作 $0$，将两行间**没有行或两行都**发生了翻转时的状态记作 $1$。
- 通过函数 $f(i,flag1,flag2)$ 计算出当第 $i$ 行和第 $i-1$ 行间的状态为 $flag1$、第 $i$ 行和第 $i+1$ 行间的状态为 $flag2$ 时第 $i$ 行所有硬币的价值之和。
## **动态规划**
考虑数组 ```dp[i][0/1]```，含义如下：
- ```dp[i][0]``` :当第 $i$ 行与第 $i-1$ 行间处于状态 $0$ 时第 $1$ 行到第 $i-1$ 行所有硬币价值之和的最大值。
- ```dp[i][1]``` :当第 $i$ 行与第 $i-1$ 行间处于状态 $1$ 时第 $1$ 行到第 $i-1$ 行所有硬币价值之和的最大值。

转移方程为：

$dp[i][0]=\max\Bigg\{\begin{aligned}
  dp[i-1][0]+f(i-1,0,0), \\ dp[i-1][1]+f(i-1,1,0)
\end{aligned}\Bigg\}。$

$dp[i][1]=\max\Bigg\{\begin{aligned}
  dp[i-1][0]+f(i-1,0,1), \\ dp[i-1][1]+f(i-1,1,1)
\end{aligned}\Bigg\}。$

## **特殊情况**
- 当 $n=1$ 时，直接输出所有 
```hang[1][j]```
 的平方和。
- 当 $i=1/n$ 时需修改 $f$ 函数的参数 $flag1/flag2$ 为 $-1$。
## **代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,dp[1005][2],hang[1005][1005];
char c[1005][1005];
int pf(int x) 
{
	return x*x;
}
int f(int hs,int flag1,int flag2)
{
	int sum=0;
	for(int i=1;i<=m;i++)
	{
		sum+=pf(hang[hs][i]+((c[hs][i]==c[hs-1][i])==flag1)+((c[hs][i]==c[hs+1][i])==flag2));
	}
	return sum;
}
int main()
{
	cin >> n >> m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin >> c[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(j!=1) hang[i][j]+=c[i][j]==c[i][j-1];
			if(j!=m) hang[i][j]+=c[i][j]==c[i][j+1];
		}
	}
	if(n==1)
	{
		int sum=0;
		for(int i=1;i<=m;i++)
		{
			sum+=pf(hang[1][i]);
		}
		cout << sum << endl;
		return 0;
	}
	dp[2][0]=f(1,-1,0);
	dp[2][1]=f(1,-1,1);
	for(int i=3;i<=n;i++)
	{
		dp[i][0]=max(dp[i-1][0]+f(i-1,0,0),dp[i-1][1]+f(i-1,1,0));
		dp[i][1]=max(dp[i-1][0]+f(i-1,0,1),dp[i-1][1]+f(i-1,1,1));
	}
	cout << max(dp[n][0]+f(n,0,-1),dp[n][1]+f(n,1,-1)) << endl;
	return 0;
}
```

---


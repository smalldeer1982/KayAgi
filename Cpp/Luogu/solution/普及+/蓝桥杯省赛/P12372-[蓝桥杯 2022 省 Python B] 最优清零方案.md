# [蓝桥杯 2022 省 Python B] 最优清零方案

## 题目描述

给定一个长度为 $N$ 的数列 $A_1, A_2, \cdots, A_N$。现在小蓝想通过若干次操作将这个数列中每个数字清零。

每次操作小蓝可以选择以下两种之一：

1. 选择一个大于 $0$ 的整数，将它减去 $1$；
2. 选择连续 $K$ 个大于 $0$ 的整数，将它们各减去 $1$。

小蓝最少经过几次操作可以将整个数列清零？

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq K \leq N \leq 10$。
- 对于 $40\%$ 的评测用例，$1 \leq K \leq N \leq 10^{2}$。
- 对于 $50\%$ 的评测用例，$1 \leq K \leq N \leq 10^{3}$。
- 对于 $60\%$ 的评测用例，$1 \leq K \leq N \leq 10^{4}$。
- 对于 $70\%$ 的评测用例，$1 \leq K \leq N \leq 10^{5}$。
- 对于所有评测用例，$1 \leq K \leq N \leq 10^{6}$，$0 \leq A_i \leq 10^{6}$。

## 样例 #1

### 输入

```
4 2
1 2 3 4```

### 输出

```
6```

# 题解

## 作者：Loyal_Soldier (赞：2)

前置知识：线段树。

### 思路

很明显，第 $2$ 种操作肯定比第 $1$ 种更优，我们要尽可能多的进行第 $2$ 种操作。

那么，对于每个长度为 $k$ 的区间，需要将每个数减去区间中最小的数，最后再计算剩余每个数的和。

显然，区间修改和区间最小值，就是线段树。于是，可以用线段树维护区间最小值和区间修改，时间复杂度 $O(n \log n)$，可以通过。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 10;
int a[N], w[N * 4], lzy[N * 4];//w 数组维护区间最小值，lzy 数组是懒标记
int n, m, ans;
void pushup(int u)
{
	w[u] = min(w[u * 2], w[u * 2 + 1]);
}
void build(int u, int l, int r)
{
	if(l == r)
	{
		w[u] = a[l];
		return;
	}
	int mid = (l + r) / 2;
	build(u * 2, l, mid);
	build(u * 2 + 1, mid + 1, r);
	pushup(u);
}//建树
void maketag(int u, int x)
{
	w[u] -= x;
	lzy[u] += x;
}
void pushdown(int u)
{
	maketag(u * 2, lzy[u]);
	maketag(u * 2 + 1, lzy[u]);
	lzy[u] = 0;
}
bool In(int L, int R, int l, int r)
{
	return (L >= l) && (R <= r);
}
bool Outof(int L, int R, int l, int r)
{
	return (L > r) || (R < l);
}
int query(int u, int L, int R, int l, int r)
{
	if(In(L, R, l, r)) return w[u];
	else if(!Outof(L, R, l, r))
	{
		int mid = (L + R) / 2;
		pushdown(u);
		return min(query(u * 2, L, mid, l, r), query(u * 2 + 1, mid + 1, R, l, r));
	}
	else return INT_MAX;
}//查询区间最小值
int Query(int u, int L, int R, int p)
{
	if(L == R) return w[u];
	int mid = (L + R) / 2;
	pushdown(u);
	if(p <= mid) return Query(u * 2, L, mid, p);
	else return Query(u * 2 + 1, mid + 1, R, p);
}//查询 p 位置的值
void update(int u, int L, int R,int l, int r, int x)
{
	if(In(L, R, l, r)) maketag(u, x);
	else if(!Outof(L, R, l, r))
	{
		int mid = (L + R) / 2;
		pushdown(u);
		update(u * 2, L, mid, l, r, x);
		update(u * 2 + 1, mid + 1, R, l, r, x);
		pushup(u);
	}
}//区间修改
signed main()
{
	cin >> n >> m;
	for(int i = 1;i <= n;i ++) cin >> a[i];
	build(1, 1, n);
	for(int i = 1;i + m - 1 <= n;i ++)
	{
		int qwq = query(1, 1, n, i, i + m - 1);//查询区间最小值
		ans += qwq;//增加答案
		update(1, 1, n, i, i + m - 1, qwq);//区间修改 
	}
	for(int i = 1;i <= n;i ++) ans += Query(1, 1, n, i);//累加剩余的数
	cout << ans;
	return 0;
}
```

---

## 作者：huhengrui2013 (赞：2)

### 题解：P12372 [蓝桥杯 2022 省 Python B] 最优清零方案

[传送门](https://www.luogu.com.cn/problem/P12372)

### 思路：

显然，操作 2 优于操作 1，而区间最小值则是这个区间能执行操作 2 的次数，所以我们可以枚举区间左端点，以 $k$ 为长度，用线段树计算这个区间能执行操作 2 的次数，再计算剩余需要执行操作 1 的次数即可。

### AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,k,a[N];
int tr[4*N],tag[N*4];//4倍空间线段树

//线段树模板
void p_b(int p,int l,int r){
    if(tag[p]){
        int mid=(l+r)/2;
        tag[2*p]+=tag[p];
        tag[2*p+1]+=tag[p];
        tr[2*p]+=tag[p];
        tr[2*p+1]+=tag[p];
        tag[p]=0;
    }
    return;
}
void build(int x,int l,int r){
    if(l==r){
        tr[x]=a[l];
        return ;
    }
    int mid=(l+r)/2;
    build(x*2,l,mid);
    build(x*2+1,mid+1,r);
    tr[x]=min(tr[x*2+1],tr[x*2]);
}
void upd(int p,int l,int r,int lx,int rx,int v){
    if(l>=lx&&r<=rx){
        tr[p]+=v;
        tag[p]+=v;
        return ;
    }
    p_b(p,l,r);
    int mid=(l+r)/2;
    if(lx<=mid) upd(p*2,l,mid,lx,rx,v);
    if(rx>=mid+1) upd(p*2+1,mid+1,r,lx,rx,v);
    tr[p]=min(tr[p*2+1],tr[p*2]);
}
int query(int x,int l,int r,int xl,int xr){
    if(xl<=l&&xr>=r){
        return tr[x];
    }
    p_b(x,l,r);
    int mid=(l+r)/2,ans=1e9;
    if(xl<=mid){
        ans=min(ans,query(x*2,l,mid,xl,xr));
    }
    if(xr>mid){
        ans=min(ans,query(x*2+1,mid+1,r,xl,xr));
    }
    return ans;
}
long long int ans;
signed main(){
    cin>>n>>k;    
    for(int i=1;i<=n;i++){
        cin>>a[i];
        ans+=a[i];
    }
    build(1,1,n);
    //遍历每个元素，计算当前元素需要被减的次数。
    for(int i=1;i<=n-k+1;i++){
        int minn=query(1,1,n,i,i+k-1);
        /*使用线段树查询当前位置开始的 K 个元素的最小值，
确定可以使用区间减的次数。*/
        if(minn){
            //计算剩余需要单减的次数。
            ans-=minn*(k-1);
            //更新线段树，执行区间减操作。
            upd(1,1,n,i,i+k-1,-minn);
        }
    }
    cout<<ans;
}
```

---

## 作者：Chaser_of_light (赞：2)

### 题意简述：
提供一个序列 $a$ 和两种操作方案，第一种一个数**单独**减一，第二种一个长度为 $k$ 的区间**同时**减一，问至少进行几次操作将序列清零。
### 思路：  
操作一明显会比操作二更**劣**，所以我们要进行**尽可能多**的进行**操作二**。

明显操作二肯定是一个区间**进行多次**，同时不能减成负的，我们就需要一个**最小值** $m$，从而直接进行 $m$ 次操作二，还需要操作完后进行**区间修改**。

**区间**的**修改**和**查询**让我们想到什么？ 

**线段树！！[不会先做这个](https://www.luogu.com.cn/problem/P3372)**。

线段树是一个维护区间，用类似二分的方式达到 $\log_2n$ 复杂度查询或修改区间的数据结构，然后我们就用**线段树**维护一个**区间最小值**，然后遍历序列中长度为 $k$ 的区间。如果这个最小值**不等于零**的话，就直接整个区间**减去**这个最小值。

同时，我们**没有必要**再写一个区间和，因为答案明显是序列和（全部用操作一的操作数）减去操作二**优化**的次数，因为相当于**每做一次**操作二都多做了 $k-1$ 的操作一，若令 $\text{query}(x,y)$ 表示查询区间 $[x,y]$ 的最小值，则总优化次数显而易见为：  
$$
sum = \sum_{i = 1}^{n-k+1} \text{query}(i,i+k-1)\times(k - 1)
$$   
所以，   
$$
ans = (\sum_{i = 1}^{n} a_i) -sum
$$  
复杂度 $O(n\log_2n)$。    
### Code
`````cpp
#include<bits/stdc++.h>
#define ls id*2
#define rs id*2+1
using namespace std;
int tr[5000005],lazy[5000005],a[1000005];
void push_up(int id){
    tr[id]=min(tr[ls],tr[rs]);
}
void push_down(int id,int l,int r){
    if(lazy[id]){
        //int mid=(l+r)/2;
        tr[ls]+=lazy[id];
        tr[rs]+=lazy[id];
        lazy[ls]+=lazy[id];
        lazy[rs]+=lazy[id];
        lazy[id]=0;//记得赋值成0！！
    }
}
void build(int id,int l,int r){
    int mid=(l+r)/2;
    if(l==r){
        tr[id]=a[l];
        return ;
    }
//二分递归建树
    build(ls,l,mid);
    build(rs,mid+1,r);
    push_up(id);
}
void update(int id,int val,int x,int y,int l,int r){
    if(l>=x&&r<=y){
        tr[id]+=val;
        lazy[id]+=val;
        return ;
    }
    push_down(id,l,r);
    int mid=(l+r)/2;
//二分递归修改
    if(x<=mid)update(ls,val,x,y,l,mid);
    if(y>mid)update(rs,val,x,y,mid+1,r);
    push_up(id);
}
int query(int id,int x,int y,int l,int r){
    if(l>=x&&r<=y){
        return tr[id];
    }
    push_down(id,l,r);
    int ans=INT_MAX,mid=(l+r)/2;
    if(x<=mid)ans=min(ans,query(ls,x,y,l,mid));
    if(y>mid)ans=min(ans,query(rs,x,y,mid+1,r));
    return ans;
}
int n,k;
long long res;
int main()
{
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        res+=a[i];
    }
    build(1,1,n);
    for(int i=1;i<=n-k+1;i++){
        int Max=query(1,i,i+k-1,1,n);
        //printf("%d\n",Max);
        if(Max){
            res-=Max*(k-1);
            update(1,-Max,i,i+k-1,1,n);
        }
    }
    //ans+=qs();
    printf("%lld",res);
    return 0;
}
````` 
[ AC 记录。](https://www.luogu.com.cn/record/215610505)

---

## 作者：AFO_Lzx (赞：2)

一道线段树的题目，感谢 @[Terrible](https://www.luogu.com.cn/user/195942) 和 @[zwxadz](https://www.luogu.com.cn/user/694647) 的帮助，使我感受到我自己的做法有多么暴力，难怪 TLE 那么多。

线段树不多说了，不会的请转 [P3372](/problem/P3372)。

原本的思路是先将序列的总和算出来，设其为 $s$，则当 $s>0$ 时一直不断寻找区间更新。[code](https://www.luogu.com.cn/paste/h9vvpb0b) & [record](https://www.luogu.com.cn/record/215333735) 在此，请自行观赏。

发现这种方法不行，跑得很慢，考虑一种贪心的思路，还是先把总和计算出来，然后先把所有的能操作的长度为 $k$ 的区间都操作完，每次直接减去区间最小值，答案 $ans$ 直接加上最小值，把 $s$ 也减去这个最小值。最后剩下的肯定就是一个个减去。所以最后还要将 $ans$ 加上 $s$ 才是最终的答案。

省流：[交了 $20$ 发终于过了](https://www.luogu.com.cn/record/list?pid=P12372&user=1030381)。

### Code

```cpp
#include<bits/stdc++.h>
#define ls u<<1
#define rs u<<1|1
#define int long long
using ll = long long;
using namespace std;

const int N = 1e6 + 5;
typedef long long ll; 

struct node {
	int l, r;
	ll mi, lazy;
} tree[N << 2];

ll a[N];

inline void pushup(int u) {
	tree[u].mi = min(tree[ls].mi, tree[rs].mi);
	return;
}

inline void pushdown(int u) {
	tree[ls].lazy += tree[u].lazy;
	tree[rs].lazy += tree[u].lazy;
	tree[ls].mi += tree[u].lazy;
	tree[rs].mi += tree[u].lazy;
	tree[u].lazy = 0;
	return;
}

void build(int u, int l, int r) {
	tree[u].l = l, tree[u].r = r;
	tree[u].lazy = tree[u].mi = 0;
	if (l == r) {
		tree[u].mi = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	pushup(u);
}

void update(int u, int x, int y, ll k) {
	if (tree[u].l >= x && tree[u].r <= y) {
		tree[u].mi += k;
		tree[u].lazy += k;
		return;
	}
	if (tree[u].lazy) pushdown(u);
	int mid = (tree[u].l + tree[u].r) >> 1;
	if (x <= mid) update(ls, x, y, k);
	if (y > mid) update(rs, x, y, k);
	pushup(u);
}

ll query(int u, int L, int R) {
	if (tree[u].l >= L && tree[u].r <= R) return tree[u].mi;
	ll ans = 1e18, mid = (tree[u].l + tree[u].r) >> 1;
	if (tree[u].lazy) pushdown(u);
	if (L <= mid) ans = min(ans, query(ls, L, R));
	if (R > mid) ans = min(ans, query(rs, L, R));
	return ans;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int n, k;
	ll s = 0;
	cin >> n >> k;
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		s += a[i];
	}
	
	build(1, 1, n);
	
	ll ans = 0;
	for (int i = 1; i <= n - k + 1; i++) {
		int x = query(1, i, i + k - 1);
		if (x != 0) {
			ans += x, s -= 1ll * x * k;
			update(1, i, i + k - 1, -x);
		}
	}
	
	cout << ans + s << '\n';
	return 0;
}
```

完结，发现这题还是挺板的。

---

## 作者：yeziling (赞：1)

### 题解：P12372 [蓝桥杯 2022 省 Python B] 最优清零方案

[传送门](https://www.luogu.com.cn/problem/P12372)
### 题目分析：
我们需要将数组中的所有元素清零，有两种操作 $:$   

操作 $1$：将某个位置上的数减 $1$。

操作 $2$：将连续 $k$ 个位置上的数各减 $1$。

目标是使用尽可能少的操作次数将所有元素清零。
### 思路：
这道题是一个线段树板子题，我们可以从右向左处理数组，每次在当前可操作的连续 $k$ 个元素中使用尽可能多的第二种操作，当不满足连续 $k$ 个时，剩余部分用第一种操作补充。

### Code:

```cpp
#define IOSO ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#include<bits/stdc++.h>
#define ll long long
#define QwQ return 0;
using namespace std;
const int N=1e7+10;
int n,k;
ll a[N];
ll dis[N*4],lan[N*4];//dis=线段树数组，lan=懒标记数组
void add(int p){
    dis[p]=min(dis[p<<1],dis[p<<1|1]);
}
void build(int p,int l,int r){
    if(l==r){
        dis[p]=a[l];
        return ;
    }
    int mid=(l+r)/2;
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    add(p);//更新当前节点的值
}
//下推懒标记
void push_down(int p,int l,int r){
	if(lan[p]){//如果存在懒标记
		int mid=(l+r)/2;
		dis[p<<1]+=lan[p];
		lan[p<<1]+=lan[p];
		dis[p<<1|1]+=lan[p];
		lan[p<<1|1]+=lan[p];
		lan[p]=0;
		//清除当前节点的懒标记
	}
	return ; 
}
void modify(int p,int l,int r,int lx,int rx,int x){
    if(lx<=l&&r<=rx){
        dis[p]+=x;
        lan[p]+=x;
        return ;
    }
    push_down(p,l,r);
    int mid=(l+r)/2;
    //递归修改左右子树
    if(lx<=mid) modify(p<<1,l,mid,lx,rx,x);
    if(mid<rx) modify(p<<1|1,mid+1,r,lx,rx,x);
    add(p);
    return ;
}
ll query(int p,int l,int r,int lx,int rx){
    if(lx<=l&&r<=rx){
        return dis[p];//直接返回当前节点值
    }
    push_down(p,l,r);
    int mid=(l+r)/2;
    ll ans=LLONG_MAX;
    if(lx<=mid) ans=min(ans,query(p<<1,l,mid,lx,rx));
    if(mid<rx) ans=min(ans,query(p<<1|1,mid+1,r,lx,rx));
    return ans;
}
int main(){
	IOSO;
	cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    ll ans=0;
    build(1,1,n);
    for(int l=n-k+1;l>=1;l--){
    	//查询当前区间[l,l+k-1]的最小值
        ll top=query(1,1,n,l,l+k-1);
        ans+=top;
        //将区间内所有元素减去这个最小值
        modify(1,1,n,l,l+k-1,-top);
    }
    //累加剩余未被完全覆盖的元素
    for(int i=1;i<=n;i++){
        ans+=query(1,1,n,i,i);
    }
    cout<<ans;
	QwQ;
}
```

---

## 作者：Lyw_and_Segment_Tree (赞：1)

前言：跟 @[wwqwq](https://www.luogu.com.cn/user/669919) 随机选到这题，我用时 18min，wwq 用时 15min，被踩爆了，膜拜 wwq！

首先，容易发现由于 $k \ge 1$，所以使用 2 操作一定不会比使用 1 操作差，同时，由于只能减，所以我们在操作过程中不能让序列中任何一个值小于 $0$。

然后，容易发现对于一个区间 $[i, i + k - 1]$，能使用 2 操作的次数取决于区间中的最小值，所以我们从前往后扫，对每个区间 $[i, i + k - 1]$，记 $mn$ 表示 $[i, i + k - 1]$ 的最小值，区间减即可，容易发现在扫的过程中一定可以把 2 操作次数最大化，所以是最优的，我们发现每次算出来的 $mn$ 就是这个区间用 2 操作的操作次数，所以每次让 $ans \leftarrow ans + mn$ 即可，由于最后可能还有一些数没被减完，所以再对 $[1, n]$ 求一个区间和，让 $ans$ 加上这个和即可。

做完了。

[record](https://www.luogu.com.cn/record/226972753)

code : 

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define endl "\n"

#define ls (u << 1)
#define rs (u << 1 | 1)

using namespace std;

ll n, k, a[1000005], ans = 0;

struct segment {
	ll l, r, len, sum, mn, lzy = 0;
} w[4000005] ;

void pushup(ll u) {
	w[u].sum = w[ls].sum + w[rs].sum;
	w[u].mn = min(w[ls].mn, w[rs].mn);
}

void build(ll u, ll l, ll r) {
	w[u].l = l, w[u].r = r, w[u].len = r - l + 1;
	
	if (l == r) {
		w[u].sum = w[u].mn = a[l];
		
		return ;
	}
	
	ll md = l + ((r - l) >> 1);
	
	build(ls, l, md), build(rs, md + 1, r);
	
	pushup(u);
}

void maketag(ll u, ll x) {
	w[u].sum += w[u].len * x, w[u].lzy += x, w[u].mn += x;
}

void pushdown(ll u) {
	maketag(ls, w[u].lzy), maketag(rs, w[u].lzy);
	
	w[u].lzy = 0;
}

ll qmn(ll u, ll l, ll r) {
	if (l <= w[u].l && w[u].r <= r) {
		return w[u].mn;
	}
	
	ll md = w[u].l + ((w[u].r - w[u].l) >> 1), res = LLONG_MAX;
	
	pushdown(u);
	
	if (l <= md) res = min(res, qmn(ls, l, r));
	
	if (r > md) res = min(res, qmn(rs, l, r));
	
	return res;
}

ll qsum(ll u, ll l, ll r) {
	if (l <= w[u].l && w[u].r <= r) {
		return w[u].sum;
	}
	
	ll md = w[u].l + ((w[u].r - w[u].l) >> 1), res = 0;
	
	pushdown(u);
	
	if (l <= md) res += qsum(ls, l, r);
	
	if (r > md) res += qsum(rs, l, r);
	
	return res; 
}

void update(ll u, ll l, ll r, ll x) {
	if (l <= w[u].l && w[u].r <= r) {
		maketag(u, x); return ;
	}
	
	ll md = w[u].l + ((w[u].r - w[u].l) >> 1);
	
	pushdown(u);
	
	if (l <= md) update(ls, l, r, x);
	
	if (r > md) update(rs, l, r, x);
	
	pushup(u);
} 

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> k;
	
	for (ll i = 1; i <= n; i++) {
		cin >> a[i];
	}
	
	build(1, 1, n);
	
	for (ll i = 1; i <= n - k + 1; i++) {
		ll mn = qmn(1, i, i + k - 1);
		
		update(1, i, i + k - 1, -mn), ans += mn;
	}
	
	ans += qsum(1, 1, n);
	
	cout << ans << endl;
}
```

---

## 作者：nytyq (赞：1)

## 思路

注意这道题的区间修改，于是考虑线段树区间修改，由于题目中的可减区间都是一下将他们单个减去 $1$，那么操作 $k$ 次，相当于区间直接减 $k$，操作次数加 $k$。考虑有的数字在集体相减之后还会有剩余，于是考虑剩下的单个减去即可。

## Code

```
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+10;

#define int long long 

struct node{
	int l,r;
	int minn,tag;
}tr[N<<2];

int a[N],n,k,sum;

void pushdown(int u){
	if(tr[u].tag){
		int d=tr[u].tag;
		tr[u<<1].minn+=d;
		tr[u<<1].tag+=d;
		tr[u<<1|1].minn+=d;
		tr[u<<1|1].tag+=d;
		tr[u].tag=0;
	}
}

void pushup(int u){
	tr[u].minn=min(tr[u<<1].minn,tr[u<<1|1].minn);
}

void build(int u,int l,int r){
	tr[u]=(node){l,r};
	if(l>=r){
		tr[u]=(node){l,l,a[l],0};
		return ;
	}
	int mid=l+r>>1;
	build(u<<1,l,mid),build(u<<1|1,mid+1,r);
	pushup(u);
}

void modify(int u,int l,int r,int v){
	if(tr[u].l>=l && tr[u].r<=r){
		tr[u].minn+=v;
		tr[u].tag+=v;
		return ;
	}
	int mid=tr[u].l+tr[u].r>>1;
	pushdown(u);
	if(l<=mid) modify(u<<1,l,r,v);
	if(r>mid) modify(u<<1|1,l,r,v);
	pushup(u);
}

int query(int u,int l,int r){
	if(tr[u].l>=l && tr[u].r<=r){
		return tr[u].minn;
	}
	int ans=1e18;
	int mid=tr[u].l+tr[u].r>>1;
	pushdown(u);
	if(l<=mid) ans=min(ans,query(u<<1,l,r));
	if(r>mid) ans=min(ans,query(u<<1|1,l,r));
	return ans;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
	build(1,1,n);
	int cnt=0ll;
	for(int i=1;i<=n-k+1;i++){
		int res=query(1,i,i+k-1);
		if(res!=0){
			cnt+=res,sum-=1ll*res*k;
			modify(1,i,i+k-1,-res);
		}
	}
	cout<<cnt+sum;
	return 0;
}
```

---

## 作者：wwqwq (赞：1)

和@[Lyw_and_segment_tree](https://www.luogu.com.cn/user/833737) duel这题，15min险胜。

注意到肯定要多用 2 操作，所以从左往右扫，只要能用 2 操作就用，一个区间使用 2 操作的次数为这个区间中的最小值，可以用线段树维护区间最小值和区间减。而剩下的数的和就是用 1 操作的次数。详见代码。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define endl '\n'

int n, k, a[1000005], ans, sum;
struct node {int l, r, Min, lazy;} t[4000005];

void pushup(int xb) {t[xb].Min = min(t[xb * 2].Min, t[xb * 2 + 1].Min);}
void pushdown(int xb) {
	if (t[xb].lazy) {
		int s = t[xb].lazy;
		t[xb * 2].lazy += s; t[xb * 2 + 1].lazy += s;
		t[xb * 2].Min -= s; t[xb * 2 + 1].Min -= s; 
		t[xb].lazy = 0;
	}
}

void buld(int xb, int l, int r) {
	t[xb].l = l; t[xb].r = r; t[xb].lazy = 0;
	if (l == r) {t[xb].Min = a[l]; return ;}
	int mid = (l + r) / 2;
	buld(xb * 2, l, mid); buld(xb * 2 + 1, mid + 1, r);
	pushup(xb);
}
void change_(int xb, int l, int r, int s) {
	if (l <= t[xb].l && t[xb].r <= r) {
		t[xb].lazy += s;
		t[xb].Min -= s;
		return ;
	}
	pushdown(xb);
	int mid = (t[xb].l + t[xb].r) / 2;
	if (l <= mid) change_(xb * 2, l, r, s);
	if (r > mid) change_(xb * 2 + 1, l, r, s);
	pushup(xb);
}
int Ask(int xb, int l, int r) {
	if (l <= t[xb].l && t[xb].r <= r) return t[xb].Min;
	pushdown(xb);
	int mid = (t[xb].l + t[xb].r) / 2, res = 2147483647;
	if (l <= mid) res = min(res, Ask(xb * 2, l, r));
	if (r > mid) res = min(res, Ask(xb * 2 + 1, l, r));
	return res;
}

signed main() {
	std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i], sum += a[i];
	buld(1, 1, n);
	for (int i = 1; i <= n - k + 1; i++) {
		int res = Ask(1, i, i + k - 1);
		change_(1, i, i + k - 1, res);
		ans += res; sum -= res * k;
	}
	ans += sum;//操作 1
	cout << ans << endl;
	return 0;
}
```

---

## 作者：_std_O2 (赞：1)

# 蓝桥杯2022省赛PythonB组 - 最优清零方案 题解

## 题目描述
给定长度为 $N$ 的数列，每次操作可选择：
1. 单点减 $1$ （操作代价1）
2. 连续 $K$ 个数各减 $1$ （操作代价1）

求将整个数列清零的最少操作次数。

## 思路
因为 $K \ge 1$ 所以多用操作 $2$ 更优。

对于每个长度为 $K$ 的区间，都用操作 $2$ 操作这个区间所有的数的最小值次（用线段树维护）。

最后再将操作后剩下的所有数加起来就行了。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int a[N];
struct node{
	int ls,rs,sum,add,mx,mn;
	#define l(x) tr[x].ls
	#define r(x) tr[x].rs
	#define mn(x) tr[x].mn
	#define mx(x) tr[x].mx
	#define sum(x) tr[x].sum
	#define add(x) tr[x].add
}tr[N*4];
void build(int p,int l,int r){
	l(p)=l,r(p)=r;
	if(l==r){
		sum(p)=a[l];
		mn(p)=mx(p)=a[l];
		return; 
	} 
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	sum(p)=sum(p*2)+sum(p*2+1);
	mn(p)=min(mn(p*2),mn(p*2+1));
	mx(p)=max(mx(p*2),mx(p*2+1));
}
void spread(int p){
	if(add(p)){
		sum(p*2)+=add(p)*(r(p*2)-l(p*2)+1);
		mx(p*2)+=add(p),mn(p*2)+=add(p); 
		add(p*2)+=add(p);
		sum(p*2+1)+=add(p)*(r(p*2+1)-l(p*2+1)+1);
		mx(p*2+1)+=add(p),mn(p*2+1)+=add(p); 
		add(p*2+1)+=add(p);
		add(p)=0;
	}
}
void change(int p,int l,int r,int d){
	if(l(p)>=l && r(p)<=r){
		sum(p)+=(r(p)-l(p)+1)*d;
		add(p)+=d;
		mn(p)+=d,mx(p)+=d;
		return;
	}
	int mid=l(p)+r(p)>>1;
	spread(p);
	if(l<=mid) change(p*2,l,r,d);
	if(r>mid)  change(p*2+1,l,r,d);
	sum(p)=sum(p*2)+sum(p*2+1);
	mn(p)=min(mn(p*2),mn(p*2+1));
	mx(p)=max(mx(p*2),mx(p*2+1));
}
int ask(int p,int l,int r){
	if(l(p)>=l && r(p)<=r){
		return mn(p);
	}
	spread(p);
	int mid=l(p)+r(p)>>1;
	int ans=2e9;
	if(l<=mid) ans=min(ans,ask(p*2,l,r));
	if(r>mid)  ans=min(ans,ask(p*2+1,l,r));
	return ans;
}
int ask2(int p,int l,int r){
	if(l(p)>=l && r(p)<=r){
		return sum(p);
	}
	spread(p);
	int mid=l(p)+r(p)>>1;
	int ans=0;
	if(l<=mid) ans+=ask2(p*2,l,r);
	if(r>mid)  ans+=ask2(p*2+1,l,r);
	return ans;
}
int k,ans=0;
signed main(){
	int n,m;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	build(1,1,n);
	for(int i=1;i<=n-k+1;i++){
		int maxx=ask(1,i,i+k-1);
		ans+=maxx;
		if(maxx>0) change(1,i,i+k-1,-maxx); 
	}
	ans+=ask2(1,1,n);
	cout<<ans;
}

---

## 作者：tiantianyang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12372)

### 题目大意

给你一个数列 $A$，然后给你两个操作：

- 选择一个大于 $0$ 的数，将其减 $1$。
- 选择连续的 $k$ 个大于 $0$ 的数，将其减 $1$。

问最少多少次操作，使数列清 $0$。

### 思路

我们可以发现第二种操作明显更优**就是区间修改**，然后可以发现我们减掉的数是这个数列的最小值**就是区间最小值**。这两个操作在一起很轻松就可以发现这是线段树，那我们直接套板子。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,INF=LONG_LONG_MAX;
int n,k,ans,sum;
int tree[N*4],tag[4*N];
int sonl(int p) {return p*2;}
int sonr(int p) {return p*2+1;}
void push_up(int p) {tree[p]=min(tree[sonl(p)],tree[sonr(p)]);}
void addtag(int p,int k){tag[p]+=k;tree[p]-=k;}//记的是最小值就不用全部减
void push_down(int p){
	if(tag[p]){
		addtag(sonl(p),tag[p]);addtag(sonr(p),tag[p]);
		tag[p]=0;
	}
}
void build(int p,int pl,int pr){
	if(pl==pr) {cin>>tree[p];sum+=tree[p];return ;}
	int mid=(pl+pr)/2;
	build(sonl(p),pl,mid);build(sonr(p),mid+1,pr);
	push_up(p);
}
void update(int p,int l,int r,int pl,int pr,int k){
	if(l<=pl&&pr<=r) {addtag(p,k);return ;}
	push_down(p);
	int mid=(pl+pr)/2;
	if(l<=mid) update(sonl(p),l,r,pl,mid,k);
	if(r>mid) update(sonr(p),l,r,mid+1,pr,k);
	push_up(p);
}
int get_min(int p,int l,int r,int pl,int pr){
	if(l<=pl&&pr<=r) return tree[p];
	push_down(p);
	int mid=(pl+pr)/2,res=INF;//记得附上最大值
	if(l<=mid) res=min(get_min(sonl(p),l,r,pl,mid),res);
	if(r>mid) res=min(get_min(sonr(p),l,r,mid+1,pr),res);
	return res;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0); 
	cin>>n>>k;
	for(int i=1;i<=4*n;i++) tree[i]=INF;
	build(1,1,n);
	for(int i=1;i<=n-k+1;i++){
		int mint=get_min(1,i,i+k-1,1,n);
		ans+=mint;sum-=mint*k;//记录总值与操作数
		if(mint) update(1,i,i+k-1,1,n,mint);
	}
	cout<<ans+sum;
	return 0;//完美收官
}
```

---

## 作者：CandyGodOfWar (赞：1)

一道不是很板子的线段树板子题。

显然第二种操作比第一种操作更优，因此我们尽可能多的执行第二种操作，最后在执行第二种操作。

考虑对于 $i$ 到 $i+k-1$ 进行操作二，显然执行次数为该区间的最小值，执行完看有没有剩下的，再进行操作一。

区间最小值、区间更改，线段树这不就出来了吗？

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
typedef long long LL;
typedef unsigned int UI;
typedef unsigned long long ULL;
int n,k,a[N];
LL ans,sum;
struct SegmentTree
{
	int l,r,add,mi;
	#define l(p) tr[p].l
	#define r(p) tr[p].r
	#define mi(p) tr[p].mi
	#define add(p) tr[p].add
}tr[N<<2];
inline int ls(int x){return x<<1;}
inline int rs(int x){return x<<1|1;}
inline void build(int p,int l,int r)
{
	l(p)=l,r(p)=r;
	if(l==r)
	{
		mi(p)=a[l];
		return;
	}
	int mid=l+((r-l)>>1);
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	mi(p)=min(mi(ls(p)),mi(rs(p)));
}
inline void spread(int p)
{
	if(add(p)==0) return;
	mi(ls(p))+=add(p);
	mi(rs(p))+=add(p);
	add(ls(p))+=add(p);
	add(rs(p))+=add(p);
	add(p)=0;
}
inline void Add(int p,int l,int r,int k)
{
	if(l<=l(p)&&r(p)<=r)
	{
		add(p)+=k;
		mi(p)+=k;
		return;
	}
	spread(p);
	int mid=l(p)+((r(p)-l(p))>>1);
	if(l<=mid) Add(ls(p),l,r,k);
	if(mid<r) Add(rs(p),l,r,k);
	mi(p)=min(mi(ls(p)),mi(rs(p)));
}
inline int getmin(int p,int l,int r)
{
	if(l<=l(p)&&r(p)<=r) return mi(p);
	int mid=l(p)+((r(p)-l(p))>>1),ans=INT_MAX;
	spread(p);
	if(l<=mid) ans=min(ans,getmin(ls(p),l,r));
	if(mid<r) ans=min(ans,getmin(rs(p),l,r));
	return ans;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) sum+=a[i];
	build(1,1,n);
	for(int i=1;i<=n-k+1;i++)
	{
		int tmp=getmin(1,i,i+k-1);
		ans+=tmp;
		sum-=tmp*k;
		if(tmp) Add(1,i,i+k-1,-tmp);
	}
	cout<<ans+sum<<'\n';
	return 0;
}
```

---

## 作者：StormWhip (赞：1)

## 思路
操作 2 显然要优先执行，因此可以从左向右扫一遍长度为 $k$ 的区间，对于每个区间操作到不能操作为止，最后对剩下的点执行操作 1。  
不难发现我们需要进行的操作有区间加、区间查询最小值和区间和，可以用线段树，这里用分块实现。  
## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,M=1e3+5;
int ans,n,k,a[N],len,tot,L[M],R[M],minn[M],dis[M],lazy[M],bel[N];
void Build()
{
	len=sqrt(n);
	tot=ceil(1.0*n/len);
	for(int i=1;i<=tot;i++) L[i]=(i-1)*len+1,R[i]=i*len,minn[i]=1e9;
	R[tot]=n;
	for(int i=1;i<=n;i++) bel[i]=(i-1)/len+1,dis[bel[i]]+=a[i],minn[bel[i]]=min(minn[bel[i]],a[i]);
}
void Update(int l,int r,int k)
{
	int x=bel[l],y=bel[r];
	if(x==y)
	{
		for(int i=l;i<=r;i++) a[i]+=k,dis[x]+=k;
		minn[x]=1e9;
		for(int i=L[x];i<=R[x];i++) minn[x]=min(minn[x],a[i]);
		return;
	}
	for(int i=l;i<=R[x];i++) a[i]+=k,dis[x]+=k;
	for(int i=x+1;i<y;i++) lazy[i]+=k;
	for(int i=L[y];i<=r;i++) a[i]+=k,dis[y]+=k;
	minn[x]=minn[y]=1e9;
	for(int i=L[x];i<=R[x];i++) minn[x]=min(minn[x],a[i]);
	for(int i=L[y];i<=R[y];i++) minn[y]=min(minn[y],a[i]);
}
int QueryMin(int l,int r)
{
	int x=bel[l],y=bel[r],ans=1e9;
	if(x==y)
	{
		for(int i=l;i<=r;i++) ans=min(ans,a[i]+lazy[x]);
		return ans;
	}
	for(int i=l;i<=R[x];i++) ans=min(ans,a[i]+lazy[x]);
	for(int i=x+1;i<y;i++) ans=min(ans,minn[i]+lazy[i]);
	for(int i=L[y];i<=r;i++) ans=min(ans,a[i]+lazy[y]);
	return ans;
}
int QuerySum(int l,int r)
{
	int x=bel[l],y=bel[r],ans=0;
	if(x==y)
	{
		for(int i=l;i<=r;i++) ans+=a[i]+lazy[x];
		return ans;
	}
	for(int i=l;i<=R[x];i++) ans+=a[i]+lazy[x];
	for(int i=x+1;i<y;i++) ans+=dis[i]+lazy[i]*len;
	for(int i=L[y];i<=r;i++) ans+=a[i]+lazy[y];
	return ans;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	Build();
	for(int i=1;i+k-1<=n;i++) 
	{
		int t=QueryMin(i,i+k-1);
		if(t!=0) ans+=t,Update(i,i+k-1,-t);
	}
	cout<<ans+QuerySum(1,n)<<"\n";
	return 0;
}
```

---

## 作者：Eden_star (赞：1)

## 思路
这道题就是求区间最小值。

这道题很明显的优先执行操作 2，就先从左边开始往右扫，查找 $k$ 个数的最小值，如果大于 0 把每个数减去这个最小值。

最后在扫一遍将每个修改后数的值加上就行了。
## 代码
因为我菜，所以写出来的 Python 会 TLE。 但是 C++ 最慢的点却只有 925ms, 求大佬帮我调。\
**Python**：
```python
# 这个代码会时间超限！！
def ls(k):
    return k << 1
def rs(k):
    return k << 1 | 1
def push_up(tr, k):
    tr[k] = min(tr[ls(k)], tr[rs(k)])
def push_down(tr, lazy, k, l, r):
    if lazy[k]:
        mid = (l + r) // 2
        tr[ls(k)] += lazy[k]
        lazy[ls(k)] += lazy[k]
        tr[rs(k)] += lazy[k]
        lazy[rs(k)] += lazy[k]
        lazy[k] = 0
def build(tr, lazy, a, k, l, r):
    lazy[k] = 0
    if l == r:
        tr[k] = a[l - 1]
        return
    mid = (l + r) // 2
    build(tr, lazy, a, ls(k), l, mid)
    build(tr, lazy, a, rs(k), mid + 1, r)
    push_up(tr, k)
def update(tr, lazy, k, l, r, ql, qr, val):
    if l >= ql and r <= qr:
        tr[k] += val
        lazy[k] += val
        return
    push_down(tr, lazy, k, l, r)
    mid = (l + r) // 2
    if ql <= mid:
        update(tr, lazy, ls(k), l, mid, ql, qr, val)
    if qr > mid:
        update(tr, lazy, rs(k), mid + 1, r, ql, qr, val)
    push_up(tr, k)
def query(tr, lazy, k, l, r, ql, qr):
    if l >= ql and r <= qr:
        return tr[k]
    push_down(tr, lazy, k, l, r)
    mid = (l + r) // 2
    ans = float('inf')
    if ql <= mid:
        ans = min(ans, query(tr, lazy, ls(k), l, mid, ql, qr))
    if qr > mid:
        ans = min(ans, query(tr, lazy, rs(k), mid + 1, r, ql, qr))
    return ans
n, m = map(int, input().split())
a = list(map(int, input().split()))
tr = [0] * (4 * n)
lazy = [0] * (4 * n)
build(tr, lazy, a, 1, 1, n)
ans = 0
for i in range(1, n - m + 2):
    val = query(tr, lazy, 1, 1, n, i, i + m - 1)
    if val > 0:
        ans += val
        update(tr, lazy, 1, 1, n, i, i + m - 1, -val)
for i in range(1, n + 1):
    ans += query(tr, lazy, 1, 1, n, i, i)
print(ans)
```
**C++**：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,m,ans=0;
int a[N];
struct kkk{
	int l,r,dt,lz;
}tr[4*N];
int ls(int k){return k<<1;}
int rs(int k){return k<<1|1;}
int query(int ,int ,int );
void push_up(int );
void push_down(int );
void build(int ,int ,int );
void update(int ,int ,int ,int );
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	build(1,n,1);
	for(int i=1;i<=n-m+1;i++){
		int val=query(i,i+m-1,1);
		if(val>0){
			ans+=val;
			update(i,i+m-1,1,-val);
		}
	}
	for(int i=1;i<=n;i++){
		ans+=query(i,i,1);
	}
	cout<<ans;
}
void push_up(int k){
	tr[k].dt=min(tr[ls(k)].dt,tr[rs(k)].dt);
}
void push_down(int k){
	if(tr[k].lz){
		tr[ls(k)].lz+=tr[k].lz;
		tr[ls(k)].dt+=tr[k].lz;
		tr[rs(k)].lz+=tr[k].lz;
		tr[rs(k)].dt+=tr[k].lz;
		tr[k].lz=0;
	}
}
void build(int l,int r,int k){
	tr[k].l=l;tr[k].r=r;tr[k].lz=0;
	if(l==r){
		tr[k].dt=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls(k));
	build(mid+1,r,rs(k));
	push_up(k);
}
int query(int l,int r,int k){
	if(tr[k].l>=l&&tr[k].r<=r) return tr[k].dt;
	push_down(k);
	int mid=(tr[k].l+tr[k].r)>>1;
	int rans=INT_MAX;
	if(l<=mid) rans=min(rans,query(l,r,ls(k)));
	if(r>mid) rans=min(rans,query(l,r,rs(k)));
	return rans;
}
void update(int l,int r,int k,int x){
	if(tr[k].l>=l&&tr[k].r<=r){
		tr[k].dt+=x;
		tr[k].lz+=x;
		return;
	}
	else{
		push_down(k);
		int mid=(tr[k].l+tr[k].r)>>1;
		if(l<=mid) update(l,r,ls(k),x);
		if(r>mid) update(l,r,rs(k),x);
		push_up(k);
		return;
	}
}
```

---

## 作者：__liujy (赞：0)

枚举 $1$ 到 $n-k+1$，当枚举到第 $i$ 时，去判断 $i$ 到 $i+k-1$ 的最小值，然后将这个区间减去这个值，这样就完成了操作二；操作一只在进行完所有操作二后还有数大于 $0$ 时进行，并用线段树维护。

来证明一下为什么操作二比操作一更优：当你有 $m$ 个数并且都要对这些数减一的时候，如果用操作一需要 $m$ 次，操作二只用一次。

---

## 作者：细数繁星 (赞：0)

线段树板子题。

注意到第二种操作显然比第一种操作更优，那么肯定优先采用第二种操作。显而易见，区间修改顺序是不影响答案的。

可以求所有满足 $l+k-1\le n$ 的 $\min_{l\le i\le l+k-1}a_{i}$，并将这个区间内的所有数减去该值，答案加上该值。对于剩余部分，采用第一种操作，即为它们的和。区间查询区间修改，很容易想到线段树。

代码如下：

```cpp
#include <bits/stdc++.h>
#define rty printf("Yes\n");
#define RTY printf("YES\n");
#define rtn printf("No\n");
#define RTN printf("NO\n");
#define rep(v,b,e) for(int v=b;v<=e;v++)
#define repq(v,b,e) for(int v=b;v<e;v++)
#define rrep(v,e,b) for(int v=b;v>=e;v--)
#define rrepq(v,e,b) for(int v=b;v>e;v--)
#define stg string
#define vct vector
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

void solve() {
	
}

#define int ll
const int N = 1e6 + 5;

struct tree {
    int l, r;
    ll data, lazy;
}tree[N * 4];

ll arr[N];
void pushUp(int i) {
    tree[i].data = min(tree[i * 2].data, tree[i * 2 + 1].data);
}

void pushDown(int i) {
    if (tree[i].lazy) {
        int mid = (tree[i].l + tree[i].r) >> 1;
        tree[i * 2].data += tree[i].lazy;
        tree[i * 2].lazy += tree[i].lazy;
        tree[i * 2 + 1].data += tree[i].lazy;
        tree[i * 2 + 1].lazy += tree[i].lazy;
        tree[i].lazy = 0;
    }
}

void build(int p, int l, int r) {
    tree[p].l = l;
    tree[p].r = r;
    if (l == r) {
        tree[p].data =arr[l];
        return;
    }
    int mid = l + r >> 1;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    pushUp(p);
}

void update(int p, int l, int r, ll k) {
    if (l <= tree[p].l && r >= tree[p].r) {
        tree[p].data += k;
        tree[p].lazy += k;
        return;
    }
    pushDown(p);
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (l <= mid) update(p * 2, l, r, k);
    if (r > mid) update(p * 2  + 1, l, r, k);
    pushUp(p);
}

ll query(int p, int l, int r) {
    if (l <= tree[p].l && tree[p].r <= r) {
        return tree[p].data;
    }
    pushDown(p);
    ll ans = 1e18;
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (l <= mid) ans = min(ans, query(p * 2, l, r));
    if (r > mid) ans = min(ans, query(p * 2 + 1, l, r));
    return ans;
}

main() {
//	int t; cin >> t; while (t--) solve();
    int n, k;
    cin >> n >> k;
    rep(i, 1, n) {
        cin >> arr[i];
    }
    build(1, 1, n);
    ll ans = 0;
    rep(l, 1, n - k + 1) {
        int r = l + k - 1;
        ll tmp = query(1, l, r);
        ans += tmp;
        update(1, l, r, -tmp);
    }
    rep(i, 1, n) {
        ans += query(1, i, i);
    }
    cout << ans;
	return 0;
}
```

---

## 作者：lichengze123456 (赞：0)

# 题解：P12372 [蓝桥杯 2022 省 Python B] 最优清零方案
### 思路
本题一眼是线段树。

首先我们发现本体的两个操作，第一个关于单点的，第二个是关于区间的。且都是减 $1$ 的。

然后我们发现，第二个比第一个有效，要使操作数最少，必然先考虑第二个操作。

所以我们实际上区间减法只需要用线段树来维护就可以了。

然后我们可以看出每次可以枚举区间，因为区间长度是固定的 $k$，每一个区间减去此区间的最小值，这样可以避免变成负数 ，且这样我们发现只用减去一次就可以到位。

最后多出来的无法区间减 $1$，所以直接求整个数列的和加进答案里面就可以了。

所以只需要 $O(n\times\log{n})$ 的时间复杂度就可以完成此题目。

### 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Tree{
	struct S{
		long long l,r,lz_plas,s,m,lz_all;
		bool flag;
	}tr[10000000];
	void uplz_plas(long long p,long long lz_plas){
		tr[p].lz_plas+=lz_plas;
		tr[p].s+=(tr[p].r-tr[p].l+1)*lz_plas;
		tr[p].m+=lz_plas;
	}
	void uplz_all(long long p,long long lz_plas){
		tr[p].lz_all=lz_plas;
		tr[p].flag=1;
		tr[p].lz_plas=0;
		tr[p].s=(tr[p].r-tr[p].l+1)*lz_plas;
		tr[p].m=lz_plas;
	}
	void pushdown(long long p){
		if(tr[p].flag){
			uplz_all(p<<1,tr[p].lz_all);
			uplz_all(p<<1|1,tr[p].lz_all);
			tr[p].lz_all=0;
			tr[p].flag=0;
		}
		if(tr[p].lz_plas!=0){
			uplz_plas(p<<1,tr[p].lz_plas);
			uplz_plas(p<<1|1,tr[p].lz_plas);
			tr[p].lz_plas=0;
		}
	}
	void build(long long p,long long l,long long r){
		tr[p].l=l;tr[p].r=r;tr[p].s=0;tr[p].lz_plas=0;tr[p].lz_all=0;tr[p].flag=0;tr[p].m=0;
		if(l==r)return;
		long long mid=(l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void modify_plas(long long p,long long l,long long r,long long b){
		if(tr[p].l>r||tr[p].r<l)return;
		if(tr[p].l>=l&&tr[p].r<=r){
			uplz_plas(p,b);
			return;
		}
		pushdown(p);
		modify_plas(p<<1,l,r,b);
		modify_plas(p<<1|1,l,r,b);
		tr[p].s=tr[p<<1].s+tr[p<<1|1].s;
		tr[p].m=min(tr[p<<1].m,tr[p<<1|1].m);
	}
	void modify_all(long long p,long long l,long long r,long long b){
		if(tr[p].l>r||tr[p].r<l)return;
		if(tr[p].l>=l&&tr[p].r<=r){
			uplz_all(p,b);
			return;
		}
		pushdown(p);
		modify_all(p<<1,l,r,b);
		modify_all(p<<1|1,l,r,b);
		tr[p].s=tr[p<<1].s+tr[p<<1|1].s;
		tr[p].m=min(tr[p<<1].m,tr[p<<1|1].m);
	}
	long long query_sum(long long p,long long a,long long b){
		if(tr[p].l>b||tr[p].r<a)return 0;
		if(tr[p].l>=a&&tr[p].r<=b){
			return tr[p].s;
		}
		pushdown(p);
		return query_sum(p<<1,a,b)+query_sum(p<<1|1,a,b);
	}
	long long query_min(long long p,long long a,long long b){
		if(tr[p].l>b||tr[p].r<a)return 0x3f3f3f3f3f3f3f3f;
		if(tr[p].l>=a&&tr[p].r<=b){
			return tr[p].m;
		}
		pushdown(p);
		return min(query_min(p<<1,a,b),query_min(p<<1|1,a,b));
	}
};
long long n,m,ans;
Tree z;
int main(){
    cin>>n>>m;
    m--;
    z.build(1,1,n);
    for(long long i=1,a;i<=n;i++){
    	cin>>a;
    	z.modify_all(1,i,i,a);
	}
	for(long long i=1,a;i+m<=n;i++){
		a=z.query_min(1,i,i+m);
		if(a){
			ans+=a;
			z.modify_plas(1,i,i+m,-a);
		}
	}
	ans+=z.query_sum(1,1,n);
	cout<<ans;
    return 0; 
}
```
撒花完结

---

## 作者：__mutsumi__ (赞：0)

线段树裸题。

很显然执行操作 $2$ 比执行操作 $1$ 更优。

可以直接循环找长度为 $k$ 的区间的最小值加上再把整个区间减去最小值，最后再把没减完的加上就行。

```
#include<bits/stdc++.h>
#define lc p<<1
#define rc lc|1
#define ll long long
#define f(a,b,c) for(int a=b;a<=c;a++)
//#define gc _getchar_nolock()//Windows
#define gc getchar_unlocked()//Linux
using namespace std;
const int N=1e6+5;
struct tree{
	int l,r,s,mi;ll chg,sum;
}t[N*4];
ll ans;
int n,k,a[N],z;
void pushup(int p){
	t[p].sum=t[lc].sum+t[rc].sum;
	t[p].mi=min(t[lc].mi,t[rc].mi);
}
void pushdown(int p){
	t[lc].sum+=t[lc].s*t[p].chg,t[rc].sum+=t[rc].s*t[p].chg;
	t[lc].chg+=t[p].chg,t[rc].chg+=t[p].chg;
	t[lc].mi+=t[p].chg,t[rc].mi+=t[p].chg;
	t[p].chg=0;
}
void build(int p,int l,int r){
	t[p]={l,r,r-l+1,a[l],0,a[l]};
	if(l==r)return;
	int mid=(l+r)/2;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
}
void change(int p,int x,int y,int k){
	if(x>t[p].r||y<t[p].l)return;
	if(x<=t[p].l&&y>=t[p].r){
		t[p].sum+=t[p].s*k,t[p].mi+=k,t[p].chg+=k;
		return;
	}
	pushdown(p);
	change(lc,x,y,k);
	change(rc,x,y,k);
	pushup(p);
}
ll querymi(int p,int x,int y){
	if(x>t[p].r||y<t[p].l)return 1e18;
	if(x<=t[p].l&&y>=t[p].r)return t[p].mi;
	pushdown(p);
	return min(querymi(lc,x,y),querymi(rc,x,y));
}
ll querysum(int p,int x,int y){
	if(x>t[p].r||y<t[p].l)return 0;
	if(x<=t[p].l&&y>=t[p].r)return t[p].sum;
	pushdown(p);
	return querysum(lc,x,y)+querysum(rc,x,y);
}
void in(int &x){
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9')f=(c=='-'?-1:1),c=gc;
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+c-'0',c=gc;
	x*=f;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	in(n),in(k);
	f(i,1,n)in(a[i]);
	build(1,1,n);
	f(i,1,n-k+1){
        z=querymi(1,i,i+k-1),ans+=z;
        if(z)change(1,i,i+k-1,-z);
    }
    ans+=querysum(1,1,n);
	cout<<ans;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/215500651)

---


# [蓝桥杯 2023 省 Python B] 树上选点

## 题目描述

给定一棵树，树根为 $1$，每个点的点权为 $V_i$。

你需要找出若干个点 $P_i$，使得：

1. 每两个点 $P_x,P_y$ 互不相邻；
2. 每两个点 $P_x,P_y$ 与树根的距离互不相同；
3. 找出的点的点权之和尽可能大。

请输出找到的这些点的点权和的最大值。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 2 \times 10^5$，$1 \leq F_i < i$，$1 \leq V_i \leq 10^4$。

## 样例 #1

### 输入

```
5
1 2 3 2
2 1 9 3 5```

### 输出

```
11```

# 题解

## 作者：esolreven (赞：5)

不懂为什么题解区都写的这么复杂。来一种思路和代码都很清新的做法。

#### solution

感觉这玩意在树上 dp 是不好设计状态的，考虑把树当成序列来做。

具体的，一个自然的思路是按照深度 dp。我们设 $f_{i}$ 表示从根往下，已经考虑到节点 $i$ 的最大值。

转移是简单的，可以从深度为 $1 \sim dep_{i}-1$ 的任何一个点转移过来，除了父亲。

即 $f_{i}=\max\limits_{j\neq fa_{i}}\{f_{j}\}$。

那么维护一个全局最大值和全局次大值即可，复杂度 $O(n)$。

代码不到 800B。

#### code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
#define pb push_back
int n,m,i,j,ans,x,mxd,v[N],f[N];
int mx,cmx,val[N],dep[N],fa[N];
std::vector<int>G[N],pt[N];
void dfs(int x,int k){
	dep[x]=dep[k]+1,mxd=max(mxd,dep[x]);
	pt[dep[x]].pb(x),fa[x]=k;
	for(int y:G[x]){
		if(y==k) continue;
		dfs(y,x);
	}
}
int main(){
	scanf("%d",&n);
	for(i=2;i<=n;i++){
		scanf("%d",&x);
		G[i].pb(x),G[x].pb(i);
	}
	for(i=1;i<=n;i++) scanf("%d",&v[i]);
	dfs(1,0),f[1]=v[1],mx=v[1];
	for(i=2;i<=mxd;i++){
		for(int k:pt[i]){
			if(f[fa[k]]==mx) f[k]=cmx+v[k];
			else f[k]=mx+v[k];
		}
		for(int k:pt[i]){
			if(f[k]>mx) cmx=mx,mx=f[k];
			else if(f[k]>cmx) cmx=f[k];
		}  
	}
	for(i=1;i<=n;i++) ans=max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 前言
很不寻常的树形 dp，调了我两小时。

---
### 思路
先看第二点要求：任意两点 $P_x,P_y$ 到根的距离不相同。  
意思就是说选的点的深度必须互不相同，即树的每一层最多只能选 $1$ 个点。  

再看第一点要求：任意两点 $P_x,P_y$ 不相邻，也就是说选了儿子就不能选父亲。  

显然层是状态，我们应当从叶子开始，逐步递推到根。  
我设计 $dp_{i,j}$ 表示选择了第 $i$ 层的第 $j$ 个点时，最大点权和。特别地，$dp_{i,0}$ 表示不在第 $i$ 层选点。  

接下来考虑转移，比较简单。如果我们想选第 $i$ 层的第 $j$ 个点，那么它的儿子都不能选。  
如果把第 $i+1$ 层的所有点都依照 dfs 序排出来，那么它的儿子们是连续的一段区间。于是转移的时候，就是在整个序列中扣掉它的“儿子区间”，求最大值。  
这可以用前后缀最大值来解决。  


无论是 dfs 预处理，还是 dp 过程，每个点都只会被处理常数次，所以时间复杂度为 $O(n)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int>dp[200003];//[点的深度][深度为i的点中选的哪个点] 
vector<int>edg[200003];
vector<int>rid[200003];//第i层第j个点的原始编号是多少 
int v[200003];
int id[200003],idl[200003];
//在深度为i的点中的编号，深度为i的点的数量 
int lr[200003][2];
int depmax;

void dfs(int p,int dep){
	id[p]=++idl[dep];
	if(rid[dep].size()==0)rid[dep].push_back(0);
	rid[dep].push_back(p);
	for(auto i:edg[p]){
		dfs(i,dep+1);
		if(!lr[p][0])lr[p][0]=id[i];
		lr[p][1]=id[i];
	}
	depmax=max(depmax,dep);
}

int mx[2][200003];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;i++){
		int f;cin>>f;
		edg[f].push_back(i);
	}
	for(int i=1;i<=n;i++)cin>>v[i];
	dfs(1,1);
	for(int i=0;i<=depmax;i++){
		for(int j=0;j<=idl[i];j++)dp[i].push_back(0);
	}
	for(int i=0;i<=idl[depmax];i++){
		dp[depmax][i]=v[rid[depmax][i]];
	}
	
	for(int i=depmax-1;i>0;i--){
		for(int j=1;j<=idl[i+1];j++)mx[0][j]=mx[1][j]=0;
		mx[0][1]=dp[i+1][1];
		for(int j=2;j<=idl[i+1];j++)mx[0][j]=max(mx[0][j-1],dp[i+1][j]);//前缀最大值
		
		mx[1][idl[i+1]]=dp[i+1][idl[i+1]];
		for(int j=idl[i+1]-1;j>=0;j--)mx[1][j]=max(mx[1][j+1],dp[i+1][j]);//后缀最大值 
		
		dp[i][0]=max(mx[1][1],dp[i+1][0]);
		for(int j=1;j<=idl[i];j++){
			int add=0;
			if(lr[rid[i][j]][0]>1)add=max(add,mx[0][lr[rid[i][j]][0]-1]);
			if(lr[rid[i][j]][1]<idl[i+1])add=max(add,mx[1][lr[rid[i][j]][1]+1]);
			dp[i][j]=v[rid[i][j]]+max(add,dp[i+1][0]);
		}
	}
	cout<<max(dp[1][1],dp[1][0]);
	return 0;
}
```

---

## 作者：Sliarae (赞：2)

设 $\text{dep}_i$ 表示树上结点 $i$ 的深度，$\text{fa}_i$ 表示 $i$ 的父亲。

考虑将树上所有点按 $\text{dep}$ 分层，条件 $2$ 可以被转化为每层最多选一个点。

在这个结构上 dp。设 $f_{i, x}$ 表示考虑完所有 $\text{dep} \le i$ 的点，在 $\text{dep} = i$ 这一层选了一个点 $x$，若 $x = 0$ 表示在 $\text{dep} = i$ 层一个点都没选。

每个 $x$ 只会对应到一个 $i$，所以状态数是 $O(n)$ 的。考虑转移，求 $f_{i, x}$ 时枚举在 $\text{dep} = i - 1$ 层选了一个点 $y$，若 $y \neq \text{fa}_x$，则有转移 $f_{i, x} \gets f_{i - 1, y} + val_x$。时间复杂度 $O(n^2)$，需要优化。

我们发现 $val_x$ 是定值，在计算 $f_{i, x}$ 只需选定一个 $y$ 使得 $f_{i - 1, y}$ 最大，且满足 $y \neq \text{fa}_x$，说明我们只需要记录 $f_{i - 1, y}$ 最大和次大的 $y$，其中必有一个满足 $y \neq \text{fa}_x$，这样单次转移是 $O(1)$ 的。

时间复杂度 $O(n)$。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using Pii = pair<int, int>; 

const int kN = 2e5 + 5; 
const int Inf = 2e9;
const Pii Empty = {-Inf, 0};

int n;
int fa[kN], dep[kN], val[kN];
vector<int> vec[kN];

int main () {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n;
  for (int i = 2; i <= n; ++i) {
    cin >> fa[i];
    dep[i] = dep[fa[i]] + 1;
    vec[dep[i]].push_back(i);
  }
  for (int i = 1; i <= n; ++i) cin >> val[i];
  Pii dp[2] = {{val[1], 1}, {0, 0}};
  for (int d = 1; d <= n; ++d) {
    if (vec[d].empty()) break;
    Pii next_dp[2] = {{dp[0].first, 0}, Empty};
    for (auto i : vec[d]) {
      Pii ths = {-Inf, i};
      for (int j = 0; j < 2; ++j) {
        if (dp[j].second != fa[i]) {
          ths.first = max(ths.first, dp[j].first + val[i]);
        }
      }
      if (ths > next_dp[0]) {
        next_dp[1] = next_dp[0], next_dp[0] = ths;
      }
      else {
        next_dp[1] = max(next_dp[1], ths);
      }
    }
    copy(next_dp, next_dp + 2, dp);
  }
  cout << dp[0].first << '\n';
  return 0; 
}
```

---

## 作者：wangboyue_740325 (赞：1)

# 思路
优先考虑深度的限制，再考虑互不相邻的限制。  
定义 $dp_i$ 表示选择点 $i$ 和深度更浅的点（可能没有）时的最大点权和。答案明显为所有 $dp_i$ 中的最大值。转移时，设 $max$ 为比点 $i$ 浅且除点 $i$ 的父亲外的所有点的最大 $dp$ 值，则 $dp_i=max+v_i$。详见代码。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=2e5+5;
int n,v[N],dp[N],t[N],f[N],dep[N];
vector<int> nbr[N];
void dfs(int cur,int fa){
	dep[cur]=dep[fa]+1;
	for(int nxt:nbr[cur]){
		if(nxt==fa){
			continue;
		}
		dfs(nxt,cur);
	}
	return;
}
signed main(){
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>f[i];
		nbr[f[i]].push_back(i);
		nbr[i].push_back(f[i]);
	}
	for(int i=1;i<=n;i++){
		cin>>v[i];
		t[i]=i;
	}
	dfs(1,0);
	sort(t+1,t+1+n,[](int a,int b){
		return dep[a]<dep[b];
	});
	int ldep=0,max1=0,max2=0,lmx1,lmx2;
	for(int _=1;_<=n;_++){
		int cur=t[_];
		if(dep[cur]!=ldep){
			lmx1=max1;
			lmx2=max2;
			ldep=dep[cur];
		}
		if(dp[f[cur]]==lmx1){
			dp[cur]=lmx2+v[cur];
		}
		else{
			dp[cur]=lmx1+v[cur];
		}
		if(dp[cur]>max1){
			max2=max1;
			max1=dp[cur];
		}
		else if(dp[cur]>max2){
			max2=dp[cur];
		}
	}
	cout<<max1;
	return 0;
}
```

---

## 作者：Epitome (赞：1)

## 闲话

**WXH 是世界上最美的女孩子！**

## 题意

选出若干个点，同一层最多选一个，父亲儿子最多选一个，最大化点权和。

## 解法

设 $dp_x$ 表示 $x$ 及在树中深度 $ \leq x$ 的深度的节点的最大点权和，转移非常简单：$dp_x = \max\limits_{v \not = fat_x}\{dp_v\} + v_x$，这个直接按深度排序后双指针或者各类 ds 搞一下就行了，然后记录前两大值可以很好的应对父亲儿子最多选一个的限制。

## 代码

```cpp
// 39 X 03

#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

struct Node {
  int v, dep, fat, id;
} t[N];

int n, dp[N], ans;

vector<int> g[N];

void s( int x, int fa ) {
  t[x].dep = t[fa].dep + 1; 
  t[x].fat = fa;
  for (auto to : g[x]) {
    if (to ^ fa) {
      s (to, x);
    }
  }
}

int main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 2, x; i <= n; ++i) {
    cin >> x, g[x].push_back(i);g[i].push_back(x);
  }
  for (int i = 1; i <= n; cin >> t[i++].v) {
    t[i].id = i;
  }
  s (1, 0);
  sort (t + 1, t + n + 1, [] ( Node &i, Node &j ) { return i.dep < j.dep; });
  for (int i = 1, j = 1, id = 0, max1 = 0, max2 = 0; i <= n; ++i) {
    for (; t[j].dep < t[i].dep; ++j) {
      if (dp[j] > max1) {
        max2 = max1, max1 = dp[j], id = t[j].id;
      } else if (dp[j] > max2) {
        max2 = dp[j];
      }
    }
    dp[i] = (id == t[i].fat ? max2 : max1) + t[i].v;
    ans = max (ans, dp[i]);
  }
  return cout << ans, 0;
}
```

---

## 作者：Ak_hjc_using (赞：1)

## 题目描述

给定一棵树，树根为 $1$，每个点的点权为 $V_i$。

你需要找出若干个点 $P_i$，使得：

1. 每两个点 $P_x,P_y$ 互不相邻；
2. 每两个点 $P_x,P_y$ 与树根的距离互不相同；
3. 找出的点的点权之和尽可能大。

请输出找到的这些点的点权和的最大值。

## 思路

我们可以按照这几个条件进行分析，第一，$P_x$ 与 $P_y$ 互不相邻，就说明，$P_x$ 与 $P_y$ 一定不为父子节点关系，也就是父亲选了，那么儿子就必定不能选，反之亦然。第二，每两个点 $P_x,P_y$ 与树根的距离互不相同，说明两个节点的深度必定不相同，也就是不在同一层。

这就很容易使我们想到树形 DP 的做法了，首先很简单可以先定义出一个状态，也就是 $dp_i$ 表示到第 $i$ 个节点的最大价值，根据上面的不同层和不互为父子节点的信息，我们可以很轻松的列出转移式，也就是 $dp_i$ 可以从所有 $i$ 的处父亲节点以外的祖先节点转移过来，如果我们这么直接转移，那么时间复杂度就是 $O(n^2)$，所以我们可以定义一个 $mx$ 与 $cmx$ 分别表示最大值和次大值，之所以需要定义次大值，是因为如果**最大值就是它的父亲**，那么必定不可以转移，所以如果在这种情况下，我们直接将 $dp_i = cmx + v_i$ 即可。

那么代码实现就非常简单了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int n,f[N],dep[N],maxn,dp[N],v[N],mx,cmx,ans;
vector<int>g[N],e[N];
void dfs(int x,int fa)
{
    dep[x]=dep[fa]+1,maxn=max(maxn,dep[x]);
    e[dep[x]].push_back(x);
    f[x]=fa;
    for(auto i:g[x])
    {
        if(i==fa)continue;
        dfs(i,x);
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=2,x;i<=n;i++)
    {
        cin>>x;
        g[x].push_back(i),g[i].push_back(x);
    }
    for(int i=1;i<=n;i++)cin>>v[i];
    dfs(1,0);
    dp[1]=v[1],mx=v[1];
    for(int i=2;i<=maxn;i++)
    {
        for(auto i:e[i])
        {
            if(dp[f[i]]==mx)dp[i]=v[i]+cmx;
            else dp[i]=v[i]+mx;
        }
        for(auto i:e[i])
        {
            if(dp[i]>mx)cmx=mx,mx=dp[i];
            else if(dp[i]>cmx)cmx=dp[i];
        }
    }
    for(int i=1;i<=n;i++)ans=max(ans,dp[i]);
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：chzhh_111 (赞：1)

## 分析

首先我们可以将题目当中的**每两个点与树根的距离都互不相同**，看做成每一个点的深度都不一样，即对于树的每一层，都只能选一个点。

那么我们现在就以深度为基础，设计一个状态为 $dp1_{i}$，表示对于深度为 $i$ 的这一层（即第 $i$ 层），不选择这一层任何点，只选择这一层以下的点的最大点权和（这一层以上点也不选）。

但是我们现在发现，每一层选哪一个点都有影响，因为题目当中有一个**每两个点都不能相邻**的限制，所以我们现在在设计一个状态为 $dp2_{i}$，表示在点 $i$ 所处的层中，选择点 $i$，并再选择这一层以下的点的最大点权和（同样，这一层以上的点也不选）。

所以在转移 $dp1_{i}$ 的过程中，可以直接枚举第 $i+1$ 层每一个点 $j$ 的 $dp2_{j}$（即在第 $i+1$ 层选择点），也可以从第 $i+1$ 层的 $dp1_{i+1}$ 直接转移过来（即在第 $i+1$ 层不选点）。

所以此状态的状态转移方程为：

$$
dp1_{i} = \max(dp1_{i+1},maxi)
$$

此处 $maxi$ 表示在第 $i+1$ 层最大的 $dp2_{j}$。

而在转移 $dp2_{i}$ 的过程中，如果点 $i$ 处于第 $k$ 层，那么对于第 $k+1$ 层我们就可以选择选点或不选点。不选点的情况非常好做，就是 $dp1_{k+1}$，而在选点的情况中，我们就不能选择点 $i$ 的儿子，因为**每两个点都不能相邻**，所以我们就要把点 $i$ 的儿子给剔除在外，再选择余下点 $j$ 的 $dp2_{j}$ 的最大值。但就是这个过程，如果我们直接暴力枚举，这个时间复杂度是肯定不允许的，那我们就需要一些手段来优化一下。

可以想到用权值线段树来做这件事情，因为剔除儿子的操作可以相当于在权值线段树上进行单点修改，查询最大值的这个操作就相当于在权值线段树上找到最后一个点的值不为 $0$ 的位置。这都可以在 $O(\log n)$ 的时间复杂度内完成，这是我们可允许的。不过要注意的是转移完后，要将剔除的点 $i$ 的儿子再重新加进去，因为在这一层的其他点的转移要用到这些点。

所以此状态的状态转移方程为：

$$
dp2_{i} = \max(dp1_{k+1},maxi)
$$

此处 $maxi$ 表示在第 $k+1$ 层除去点 $i$ 的儿子，最大的 $dp2_{j}$。

但上文提到的权值线段树的值域可能有点太大了。所以考虑将 $dp2_{i}$ 离散化，同时我们用一个 $r$ 数组去记载这些 $dp2_{i}$ 原本的值，那到时候权值线段树查询的离散化的值就可以用 $r$ 数组转换了。

还有就是如果对于每一层都开个权值线段树，空间肯定会爆。但是我们可以发现修改的所有操作，全部都在原本就出现过的值上进行的，也就是不会再出现新的值，那我们就可以将需要用的点记录下来，不需要的点就不用浪费内存去用记录了，也就是动态开点。

最后的答案就是 $\max(dp2_{1},dp1_{1})$，就表示选择根节点或者不选择根节点中的最大值。

可以分析一下时间复杂度：首先每一个点只会被经历常数次（应该是 $5$ 次），再加上线段树的 $O(\log n)$ 和离散化的 $O(n \log n)$，总时间复杂度应该就是 $O(n \log n)$，可以通过此题。

## 代码部分

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lc(x) tr[x].lson
#define rc(x) tr[x].rson
#define sum(x) tr[x].sum
const int N=2e5+10;
int n,val[N],head[N],ls,maxdep;
int la,r[N],maxval;
int root[N],tot,dp1[N],dp2[N];//root[i]是第 i 层的权值线段树的根节点是什么
vector<int>nodesum[N];//寄存的是每一层有哪些点
struct lsh{//离散化
	int val,rank;
}a[N];
struct bian{
	int to,net;
}s[N];
struct tree{
	int lson,rson,sum;
}tr[N<<5];
bool cmp(lsh aa,lsh bb) {return aa.val<bb.val;}
void dfs(int x,int dep)//先处理出每一层有哪些点
{
	maxdep=max(maxdep,dep);
	nodesum[dep].push_back(x);
	for(int i=head[x];i;i=s[i].net)
	{
		int u=s[i].to;
		dfs(u,dep+1);
	}
}
void insert(int k,int l,int r,int x)
{
	sum(k)++;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		if(!lc(k)) lc(k)=++tot;
		insert(lc(k),l,mid,x);
	}
	else
	{
		if(!rc(k)) rc(k)=++tot;
		insert(rc(k),mid+1,r,x);
	}
}
void change(int k,int l,int r,int x,int v)//单点修改
{
	sum(k)+=v;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(x<=mid) change(lc(k),l,mid,x,v);
	else change(rc(k),mid+1,r,x,v);
}
int query(int k,int l,int r,int sum,int x)//查询最大值
{
	if(l>r||!x) return 0;
	if(l==r) return l;
	int mid=(l+r)>>1;
	if(sum+sum(lc(k))<x) return query(rc(k),mid+1,r,sum+sum(lc(k)),x);
	  else return query(lc(k),l,mid,sum,x);
}
void DP(int dep,int node)//转移 dp2[i]
{
	int sum=0;
	for(int i=head[node];i;i=s[i].net)
	{
		int u=s[i].to;
		change(root[dep],1,maxval,dp2[u],-1);//剔除点 i 的儿子
		sum++;
	}
	int maxi=r[query(root[dep],1,maxval,0,nodesum[dep].size()-sum)];
	dp2[node]=val[node]+max(dp1[dep],maxi);//转移 dp2[i]
	a[++la]=(lsh){dp2[node],node};
	for(int i=head[node];i;i=s[i].net)
	{
		int u=s[i].to;
		change(root[dep],1,maxval,dp2[u],1);//再加入点 i 的儿子
	}
}
signed main()
{
	scanf("%lld",&n);
	for(int i=2;i<=n;i++)
	{
		int f;
		scanf("%lld",&f);
		s[++ls]=(bian){i,head[f]},head[f]=ls;
	}
	for(int i=1;i<=n;i++) scanf("%lld",&val[i]);
	dfs(1,1);
	for(int i=maxdep,maxi=0;i>=1;i--)
	{
		dp1[i]=max(dp1[i+1],maxi);//转移 dp1[i]
		la=0;
		for(int j:nodesum[i]) DP(i+1,j);//转移 dp2[i]
		sort(a+1,a+1+la,cmp);
		maxi=a[la].val;
		maxval=0;
		for(int j=1;j<=la;j++)
		{
			maxval+=(a[j].val!=a[j-1].val);
			r[maxval]=dp2[a[j].rank];//记录 dp2[i] 真实的值
			dp2[a[j].rank]=maxval;
		}
		root[i]=++tot;
		for(int j=1;j<=la;j++) insert(root[i],1,maxval,dp2[a[j].rank]);
	}
	printf("%lld",max(r[dp2[1]],dp1[1]));
	return 0;
}
```

如有错误，欢迎指出。

---

## 作者：KidA (赞：0)

比较具有启发性的树形 dp。

若按照常规的做法，按照 dfs 序转移，则第一个要求容易实现，但第二个是不好实现的。

考虑转换角度，我们不妨令 $dp_i$ 表示节点 $i$ 所在深度，且当前深度选的点权最大值。这样按照深度转移，则第二个要求容易实现。那么第一个呢？对于每个节点 $i$，它当然从上方深度的最大值转移而来。如果它前面的最大值正好是它的父节点，则选取次大值即可。

这样的时间复杂度与常规做法相同，均为 $\mathcal{O}(n)$。

总结：树形 dp 也可以按照层序转移。

[实现](https://www.luogu.com.cn/paste/ukkyopda)。

---

## 作者：Inter12 (赞：0)

## 题意：

> 在一棵树上找若干个点 $P_i$，保证这些点两两不相邻（不存在有边直接相连），同一深度只选一个点。\
> \
> 目标：求出 $\max \sum V_i$。\
> \
> 数据范围：$1 \le n \le 2 \times 10^5, 1 \le V_i \le 10^4$。

## 分析：

### 常规想法

根据树的背景和 $P_i, P_j$ 两两不相邻的条件，不难想到方法：常规树状 DP 求最大值。

> 状态：$dp_{i, 0/1}$ 表示以 $i$ 为根的子树中，选或不选 $i$ 的最大点权和；\
> \
> 答案：$\max dp_{1, 0}, dp_{1, 1}$；\
> \
> 初始状态：$dp_{i, 1} = V_i$

对于 $P_i, P_j$ 不能相邻，当转移时选了 $cur$ 这个点，则他的子节点 $nxt$ 和父节点 $fa$ 都不能选，由于从下到上递归，无需考虑 $fa$ 节点。

然而，对于同一深度内只能有一个 $P_i$，就会有一些麻烦了。因为深度相同的情况下，可能会牵扯到其他子树，贸然转移会出现矛盾，导致结果不合法（~虽然我觉得硬要做这种做法也能做出来~）。

这个时候，我们就需要转移优先取舍。

### 换思路想法

想看正解思路的可以跳过。

通常情况下，当一个做法可能性较小或者写不出来的时候，可以关注题目的限制，**转化优先的条件**。

比如，常规写法是**优先考虑如何处理父子节点**，我们可以**换成优先考虑同一层节点**。

有一些题目是两个考虑方向都正确的，如 [Peaks](https://www.luogu.com.cn/problem/P4197)，可以优先处理每个询问的 $x$，也可以优先预处理边权。

### 最终想法

可以按深度建立权值线段树（略）

> 状态：$dp_i$ 表示选了 $i$ 的最大点权和；\
> \
> 答案：$\max dp_i$；\
> \
> 转移：按深度上往下转移，每次取上一层最大的值进行转移，在要注意不能是父节点，所以要维护一个次大值，如果最大值是父节点，那么就继承次大值。总之就是 $dp_i = V_i + \max\limits_{j \ne fa_i} dp_j$。\
> \
> 初始状态：$dp_i = 0$。

## 总结

优先考虑的问题十分重要，在一个优先考虑的可能性想不通时，试试换一种优先方式做题。

## 代码（部分）

```cpp
// 继承上一层的最大值，次大值 
int tpmaxi = maxi, tpcmaxi = cmaxi;
for(auto nxt : point[d]) // 枚举深度为d的点
{
	if(dp[fa[cur]] < maxi) dp[cur] = maxi + v[cur];
	else dp[cur] = cmaxi + v[cur];
	// 更新这一层临时的最大值，次大值 
	if(dp[cur] > tpmaxi) tpcmaxi = tpmaxi, tpmaxi = dp[cur];
	else if(dp[cur] > tpcmaxi) tpcmaxi = dp[cur];
} 
// 刷新上一层到这一层的最大值，次大值
maxi = tpmaxi, cmaxi = tpcmaxi; 
```

---

## 作者：Stars_visitor_tyw (赞：0)

## 题解：P12382 [蓝桥杯 2023 省 Python B] 树上选点
### 分析
有一种朴素的做法。定义 $dp_{i,0/1}$ 表示以 $i$ 为根的子树并且点 $i$ 不选或选的最大点权和，答案即为 $\max{dp_{1,0},dp_{1,1}}$。但是这种方法转移比较难处理。

另外一种做法，优先考虑深度限制。定义状态 $dp_i$ 表示从上到下选，且点 $i$ 必须选的最大点权和。答案即为 $\max(dp_i)$。现在考虑转移，设点 $i$ 的深度为 $d$，那么 $dp_i$ 等于前 $d-1$ 层中的 $dp$ 最大值加上它自己的点权 $V_i$。维护前 $d-1$ 层 $dp$ 数组的最大和次大值，若最大值是 $F_i$，那么 $dp_i$ 从次大转移。要注意当第 $d$ 层的所有 $dp$ 都维护完后才可以维护最大值和次大值。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int maxi, smaxi, n, fa[200005], v[200005], dp[200005];
vector<int> nbr[200005], level[200005];
void dfs(int cur, int dep)
{
	level[dep].push_back(cur);
	for(int nxt:nbr[cur])
	{
		dfs(nxt,dep+1);
	}
}
void work()
{
	for(int i=1;i<=n;i++)
	{
		int tmax=maxi, smax=smaxi;
		for(int cur:level[i])
		{
			if(dp[fa[cur]]<maxi)dp[cur]=maxi+v[cur];
			else dp[cur]=smaxi+v[cur];
			if(dp[cur]>tmax)
			{
				smax=tmax;tmax=dp[cur];
			}
			else if(dp[cur]>smax)smax=dp[cur];
		}
		maxi=tmax,smaxi=smax;
	}
}
signed main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		cin>>fa[i];
		nbr[fa[i]].push_back(i);
	}
	for(int i=1;i<=n;i++)cin>>v[i];
	dfs(1,1);
	work();
	cout<<maxi;
}

---

## 作者：yr409892525 (赞：0)

由于取出来的节点深度不能相同，考虑分层转移。                  
对于第 $x$ 的节点 $y$ 来说，有两种转移。               
1. 选 $x-1$ 这层的节点，则 $f_y$ 等于 $x-1$ 这层除了 $y$ 父亲节点的最大值。
2. 不选 $x-1$ 这层的节点，则 $f_y$ 等于层数小于 $x-1$ 的最大值。

对于第 $1$ 种转移，可以记录每一层的最大值和次大值。                       
对于第 $2$ 种转移，可以用 $s_i$ 表示前 $i$ 层中的最大值。                      


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n;
struct V{
	int v,x,d,f;
	vector<int> e;
}v[N];
int d,m[N][3];
int main(){
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>v[i].f;
	}
	for(int i=1;i<=n;i++){
		v[v[i].f].e.push_back(i);
		cin>>v[i].v;
	}
	queue<int> q;
	v[0].d=2;
	for(q.push(0);q.size();q.pop()){
		int x=q.front();
		if(d!=v[x].d){
			m[d][2]=max(m[d-1][2],m[d][0]);
			d=v[x].d;
		}
		if(v[v[x].f].x==m[d-1][0]){
			v[x].x=m[d-1][1];
		}else{
			v[x].x=m[d-1][0];
		}
		v[x].x=max(v[x].x,m[d-2][2])+v[x].v;
		if(v[x].x>m[d][0]){
			m[d][1]=m[d][0];
			m[d][0]=v[x].x;
		}else if(v[x].x>m[d][1]){
			m[d][1]=v[x].x;
		}
		for(int i:v[x].e){
			v[i].d=d+1;
			v[i].f=x;
			q.push(i);
		}
	}
	cout<<max(m[d-1][2],m[d][0]);
	return 0;
}
```

---

## 作者：Aliadgnus (赞：0)

## 题目大意
其实和“没有上司的舞会”挺像的，输出找到的满足条件这些点的点权和的最大值。
## 思路
记录一下以当前节点为根的子树，选择该节点与不选择该节点的答案最大值。

- 选择该点，需要把选择该点的子节点的最大值排除掉，选择剩下的最大值。
- 要是不选该点，就是下一层的所有值的最大值。

**一个小优化**：求最大值时，将该层的下一层所有选或不选该点的所有值加入数组，随后进行由大到小排序，这样便于处理。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000005
#define maxa 1005
#define int long long 
#define repr(i,a,b) for(int i = a;i <= b;i++)
#define repd(i,a,b) for(int i = a;i >= b;i--)
struct node{
    int wei/*最大值*/,fa/*父节点*/,check/*是否选择当前点*/;
    bool operator<(const node& a)const{
    	return wei > a.wei; 
	}
};
struct node1{
	int wei;
	int next;
	int to;
}edge[maxn];
int head[maxn];
int cnt;
int n,w[maxn],fa[maxn];
int dp[maxn][10];
vector<int> v[maxn];
int low;
void add(int u,int v){
    edge[++cnt].next = head[u];
	edge[cnt].to = v;
	head[u] = cnt;
}
void dfs(int u,int fa){
    v[fa].push_back(u);
    low = max(low,fa);
    for(int i = head[u];i != 0;i = edge[i].next){
        int j = edge[i].to;
        dfs(j,fa+1);
    }
    return;
}
signed main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cout.tie(0);
    cin>>n;
    repr(i,2,n){
        int a;
        cin>>a;
        add(a,i);
        fa[i] = a;
    }
    repr(i,1,n) cin>>w[i];
    dfs(1,1);
    //从当前深度开始遍历
    repd(i,low,1){
        vector<node> m;
        for(int k = 0;k < v[i+1].size()&&i <= low;k++){
            int u = v[i+1][k];
            m.push_back({dp[u][0],fa[u],0});
            m.push_back({dp[u][1],fa[u],1});
        }
        sort(m.begin(),m.end());
        for(int j = 0;j < v[i].size();j++){
            int num = v[i][j];
            //记得加上点权
            dp[num][1] = w[num];
            int res = 0;
            for(int k = 0;k < m.size();k++){
                if(m[k].fa==num&&m[k].check==1){
                    continue;
                }
				else{
                    res = m[k].wei;
                    break;
                }
            }
            dp[num][1] += res;
            if(!m.empty()) dp[num][0] = m.front().wei;
        }
    }
    cout<<max(dp[1][0],dp[1][1])<<endl;
    return 0;
}


```

---


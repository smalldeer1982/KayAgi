# [蓝桥杯 2023 省 Python B] 混乱的数组

## 题目描述

给定一个正整数 $x$，请找出一个尽可能短的仅含正整数的数组 $A$ 使得 $A$ 中恰好有 $x$ 对 $i, j$ 满足 $i < j$ 且 $A_i > A_j$。

如果存在多个这样的数组，请输出字典序最小的那个。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$x \leq 10$；
- 对于 $60\%$ 的评测用例，$x \leq 100$；
- 对于所有评测用例，$1 \leq x \leq 10^9$。

## 样例 #1

### 输入

```
3```

### 输出

```
3
3 2 1```

# 题解

## 作者：Heyg_future (赞：4)

# [蓝桥杯 2023 省 Python B] 混乱的数组
## [题目传送门](https://www.luogu.com.cn/problem/P12386)

## Solution
看到本题，先来一发打表。
毕竟是构造题，必须要找找规律。
```cpp
4:  2 2 1 1 
5:  3 2 1 1
6:  4 3 2 1 
 
7:  2 3 2 1 1
8:  3 2 2 1 1
9:  4 3 2 1 1
10:  5 4 3 2 1
 
11:  2 4 3 2 1 1
12:  3 3 2 2 1 1 
13:  4 3 2 2 1 1
14:  5 4 3 2 1 1
15:  6 5 4 3 2 1
 
16:  2 5 4 3 2 1 1
17:  3 4 3 2 2 1 1
18:  4 3 3 2 2 1 1 
19:  5 4 3 2 2 1 1
20:  6 5 4 3 2 1 1
21:  7 6 5 4 3 2 1
 
22:  2 6 5 4 3 2 1 1 
23:  3 5 4 3 2 2 1 1 
24:  4 4 3 3 2 2 1 1
25:  5 4 3 3 2 2 1 1
26:  6 5 4 3 2 2 1 1
27:  7 6 5 4 3 2 1 1
28:  8 7 6 5 4 3 2 1
```
然后惊人地发现竟然对于所有最优解为 $n$ 位的数，对应的答案相同位数的个数竟然都为 $n-1$ 个，并且 $n$ 位可构成逆序对数最多为 $x=\dfrac{n(n-1)}{2}$。

证明一下，当每一位都与其前面的全部位数构成逆序对时，其逆序对数 $x$ 可表示为如下式子。
$$
x=\sum_{i = 1}^{n-1} i=\dfrac{n(n-1)}{2}
$$
那么贪心地，则可以找出可以拼出最多的逆序对的 $n$ 使这个最多逆序对数刚好不小于 $x$。
```cpp
long long n=1;
while(n*n-n<2*x) n++;
```
那么这个临界值可以特判输出，它们刚好是一个递减等差数列，首项为 $n$。
```cpp
if((n*n-n)/2==x){
	cout<<n<<"\n";
	for(int i=n;i>=1;i--) 
		cout<<i<<" ";
}
```

然后再仔细观察可以发现，对于每组答案数列来说，有一部分里的数从第一个开始单调递减，有一部分，从第二个数开始单调递减。

### 第一种情况。
此部分的 $x$ 的范围为 $\dfrac{n(n-1)}{2}-\dfrac{(n+1)}{2}<x\leq \dfrac{n(n-1)}{2}$。

因为，每次将第 $i$ 个数以前的数全部减 $1$ 就刚好使组成的逆序对减 $1$。所以直接将后面的一直减直至组成的逆序对数为 $x$ 时停止。特别地，当一个数出现超过两次时，它每多出现一次就会让前方需要多加一点，使整体的字典序变大，所以要保证一个数最多出现两次。再以此贪心即可。

### 第二种情况。
此部分的 $x$ 的范围为 $\dfrac{(n-1)(n-2)}{2}<x\leq \dfrac{n(n-1)}{2}-\dfrac{(n+1)}{2}$。

和上一种一样，只是将 $\dfrac{n}{2}-(\dfrac{n(n-1)}{2}-\dfrac{(n+1)}{2}-x)$ 放在数列开头即可，后面做与前一种一样的操作。

简单证明一下。因为在临界情况 $x=\dfrac{n(n-1)}{2}-\dfrac{(n+1)}{2}$ 时，已经是该长度整个数列全是单调递减的数的情况下字典序较小时可以表示的最小的答案了，再按方案一那样做会使字典序变大，所以要进行调整。所以我们在不浪费任意一个数所带来的贡献的情况下，加一个较小的数使前两位成为一个逆序对，再在后面进行简单调整，就可以实现在不影响字典序的情况下，将逆序对减少。非常容易证明，当取来放在开头的数为 $\dfrac{n}{2}-(\dfrac{n(n-1)}{2}-\dfrac{(n+1)}{2}-x)$ 时刚好可以使逆序对数为答案所求。调整部分与情况一一样。

最终代码如下。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long x,a[N];
int main(){
	cin>>x;
	long long n=1;
	while(n*n-n<2*x) n++;
	if((n*n-n)/2==x){
		cout<<n<<"\n";
		for(int i=n;i>=1;i--) 
			cout<<i<<" ";
	}
	else {
		cout<<n<<"\n";
      //n为数列长度
		int p=(n+1)/2,d=(n*n-n)/2,tp=0;
		for(int i=1;i<=n;i++){
			if(i%2) tp++;
			a[i]=tp;
		}
		if(x>=d-p){
			int t=d-x;
			for(int i=1;i<=n;i++)
				if(a[i]>d-x) a[i]=++t;
		}
		else {
			a[n]=n/2-(d-p-x);
			int t=a[n-1]+d-p-x;
			for(int i=n-1;t>a[i-1]&&t>1;i--)
				a[i]=t--;
		}
		for(int i=n;i>=1;i--)
			cout<<a[i]<<" ";
	}
    return 0;
}
```
这样即可通过此题。

---

## 作者：Sliarae (赞：3)

对着想了半天，感觉还是打表找规律题。

首先考虑如果要求 $A$ 为排列怎么做。找到一个最小的 $n$，使得序列 $[n, n - 1, \ldots, 1]$ 的逆序对数 $\frac{n(n - 1)}{2} \ge x$，然后将数字 $v = n - (\frac{n(n - 1)}{2} - x)$ 交换到位置 $A_1$。这样可以使得 $A$ 的字典序最小。

现在去掉 $A$ 为排列的性质，显然 $n$ 是不变的。但按上面方法构造 $A$ 会出现问题。比如 $x = 7$ 时答案为 $[2, 3, 2, 1, 1]$，而前面的方法会求出 $[2, 5, 4, 3, 1]$。

我们尝试对 $A$ 为排列的构造进行调整，比如 $[2, 5, 4, 3, 1]$，我们将 $A_4 = 3$ 修改为 $1$ 变成 $[2, 5, 4, 1, 1]$，发现少了一个逆序对（这里用下标二元组表示）$(4, 5)$，但又多了一个 $(1, 4)$，于是总逆序对数不变。最后再对前面进行微调得到 $[2, 3, 2, 1, 1]$。

可以再尝试几种情况，比如 $[2, 6, 5, 4, 3, 2] \rightarrow [2, 4, 3, 2, 1, 1], [3, 6, 5, 4, 2, 1] \rightarrow [3, 3, 2, 2, 1, 1]$。可以发现答案形如 $[v, \ldots, v + 1, v, v - 1, v - 1, \ldots, 2, 2, 1, 1]$。

然后前面其实是 $v \le \frac{n}{2}$ 的情况，$v > \frac{n}{2}$ 是差不多的。比如 $[4, 6, 5, 3, 2, 1] \rightarrow [4, 3, 2, 2, 1, 1]$。大概就是构造形如 $[v, v - 1, \ldots, k + 2, k + 1, k, k, \ldots, 2, 2, 1, 1]$ 的序列。

```cpp
#include <iostream>

using namespace std;

int main () {
  cin.tie(0)->sync_with_stdio(0);
  int x, n = 2;
  cin >> x;
  for (; n * (n - 1) / 2 < x; ++n);
  cout << n << '\n';
  int v = 1 + x - (n - 1) * (n - 2) / 2;
  const static int kN = 2e5 + 5; 
  static int a[kN]; 
  a[1] = v;
  if (v <= n / 2) {
    int i = n; 
    for (int j = 1; j < v; i -= 2, ++j) a[i] = a[i - 1] = j; 
    a[i--] = v; 
    for (int j = v + 1; i > 1; --i, ++j) a[i] = j; 
  }
  else {
    for (int i = n, j = 1; i > 1; ++j) {
      if (i - 1 != v - j) a[i] = j, --i;
      a[i] = j, --i;
    } 
  }
  for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
  cout << '\n';
  return 0; 
}
```

---

## 作者：Aliadgnus (赞：1)

## 前提概要
 使得 $A$ 中恰好有 $x$ 对 $i, j$ 满足 $i < j$ 且 $A_i > A_j$，等价于使得 $A$ 中有 $x$ 对逆序对。

## 题目大意
求的是找出含 $x$ 个逆序对的最小数组。
## 解题思路
首先考虑其中的特殊情况，如果构造的序列是单调递减的，那么这里逆序对数量就是 $C_{n}^{2}$，其中 $n$ 是序列长度，由于组合数是单调递增的，这样我们就可以通过 $x$ 确定要构造的序列的长度。

那么就是在长度为 $len$ 的数组中选一对逆序对的情况小于 $x$。

即 $C_{len}^{2} < x$。

解这个方程，负根舍去，得到 $len \geq \frac{1+\sqrt{1+8x}}{2}$。

那么 $len = \lceil\frac{1+\sqrt{1+8x}}{2}\rceil$。

接着，我们试着去构造一些合法的序列。

```cpp
x = 21 a = [7 6 5 4 3 2 1]
x = 22 a = [2 6 5 4 3 2 1 1]
x = 23 a = [3 5 4 3 2 2 1 1]
x = 24 a = [4 4 3 3 2 2 1 1]
x = 25 a = [5 4 3 3 2 2 1 1]
x = 26 a = [6 5 4 3 2 2 1 1]
x = 27 a = [7 6 5 4 3 2 1 1]
x = 28 a = [8 7 6 5 4 3 2 1]
```
不难发现，当 $x = C_{len}^{2}$ 时，我们可以直接去构造一个单调递减的序列。

当 $C_{len}^{2}-x \leq \lfloor \frac{len}{2} \rfloor$ 的时候，这后面的 $(C_{len}^{2}-x) \times 2$ 个是从 $1$ 开始的单调递增的序列，这其中每两个是同一个数字，剩余前面的数字继续递增。剩余的情况里，后面 $(x- C_{len-1}^{2}) \times 2$ 个是从 $1$ 开始的递增序列，每两个是同一个数字，剩余除了第一个数字继续递增，但是这里第一个数字是比较特殊的，是 $x-C_{len-1}^{2}+1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 1000005
#define maxa 1005
#define repr(i,a,b) for(int i = a;i <= b;i++) 
#define int long long
vector<int> v;
int x,len;
signed main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cout.tie(0);
    cin>>x;
    int len = ceil((1+sqrt(1+8*x))/2);
    cout<<len<<endl;
    if(x==len*(len-1)/2){
        for(int i = len;i > 0;i--){
            cout<<i<<" ";
        }
        return 0;
    }
    else{
        int u = 1;
        if(len*(len-1)/2<=x+len/2){
            while(u<=len*(len-1)/2-x){
                v.push_back(u);
                v.push_back(u);
                u++;
            }
            while(v.size()<len){
                v.push_back(u++);
            }
        }
        else{
            while(u<=x-(len-1)*(len-2)/2){
                v.push_back(u);
                v.push_back(u);
                u++;
            }
            while(v.size()<len-1){
                v.push_back(u++);
            }
            v.push_back(x-(len-1)*(len-2)/2+1);
        }
    }
    reverse(v.begin(),v.end());
    for(auto ans:v){
        cout<<ans<<" ";
    }
    return 0;
}

```

---

## 作者：swate114514 (赞：1)

第一个绿题最优解！

## 题意
我们需要构造一个尽可能短的数组 $A$，使得其中恰好有 $x$ 对逆序对（$i < j$ 且 $A_i > A_j$），且字典序最小。核心问题在于如何通过数学构造满足条件的数组，并证明其最优性。

## 思路
我们来确定数组长度 $n$，因为逆序对的最大数量为完全逆序数组的逆序对数，即 $\frac{n(n-1)}{2}$。因此，最小的 $n$ 需满足：
$$\frac{n(n-1)}{2} \geq x$$
   解得：
$$n = \left\lceil \frac{1 + \sqrt{1 + 8x}}{2} \right\rceil$$

若 $x = \frac{n(n-1)}{2}$，则数组为完全逆序排列，例如 $[n, n-1, \dots, 1]$。  

若 $x < \frac{n(n-1)}{2}$，则需分两部分构造数组：

1. 前半部分：通过两两递增的方式生成部分逆序对。例如，形如 $[a_1, a_1, a_2, a_2, \dots]$ 的序列，每对重复元素贡献 1 个逆序对。  
2. 后半部分：以降序排列补充剩余逆序对。  

   设中间分割点为 $mid$，其值由以下公式确定：
$$mid = \begin{cases}
   2 \cdot (x - \frac{(n-1)(n-2)}{2}) & \text{if } x - \frac{(n-1)(n-2)}{2} \leq \frac{n-1}{2} \\
   2 \cdot (\frac{n(n-1)}{2} - x) & \text{otherwise}
   \end{cases}$$


字典序最小的要求意味着数组应尽可能靠前的位置出现较小值，所以我们先构造初始数组，再将数组反转以使得较小的元素尽可能靠前。 

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    LL x;
    cin >> x;

    LL s = sqrt(1 + 8 * x);
    if (s * s < 1 + 8 * x) s++;
    LL n = (1 + s) / 2;
    while (n * (n - 1) / 2 < x) n++;

    LL Cn2 = n * (n - 1) / 2;
    LL Cnn2 = (n - 1) * (n - 2) / 2;

    LL mid;
    if (x - Cnn2 <= (n - 1) / 2) {
        mid = 2 * (x - Cnn2);
    } else {
        mid = 2 * (Cn2 - x);
    }

    LL ans[n + 1];
    for (int i = 1; i <= mid; ++i) {
        ans[i] = (i + 1) / 2;
    }
    for (int i = mid + 1; i <= n; ++i) {
        ans[i] = mid / 2 + (i - mid);
    }
    
    ans[n] = x - Cnn2 + 1;

    reverse(ans + 1, ans + n + 1);

    cout << n << '\n';
    for (int i = 1; i <= n; ++i) {
        cout << ans[i] << ' ';
    }

    return 0;
}
```

---


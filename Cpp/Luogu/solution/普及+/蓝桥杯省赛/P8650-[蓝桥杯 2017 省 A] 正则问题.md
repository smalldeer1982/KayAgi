# [蓝桥杯 2017 省 A] 正则问题

## 题目描述

考虑一种简单的正则表达式：

只由 `x` `(` `)` `|` 组成的正则表达式。

小明想求出这个正则表达式能接受的最长字符串的长度。  

例如 `((xx|xxx)x|(x|xx))xx` 能接受的最长字符串是： `xxxxxx`，长度是 $6$。


## 说明/提示

蓝桥杯 2022 省赛 A 组 G 题。

## 样例 #1

### 输入

```
((xx|xxx)x|(x|xx))xx  ```

### 输出

```
6```

# 题解

## 作者：Patpowder (赞：24)

# P8650 [蓝桥杯 2017 省 A] 正则问题
既然标签是递归，那就来一个递归的题解吧！

tips:本题解与其他题解代码相似，主要是思维解释。

## AC Code:
~~省的你们翻得累死。~~
```cpp
#include <bits/stdc++.h>
using namespace std;
int re(int ans){
	char c;
	while(cin>>c){
		if(c == '\r' || c == '\n') return ans;
		else if(c == 'x') ans ++;
	   else if(c == '(') ans += re(0);
		else if(c == ')') return ans;
		else if(c == '|') return max(ans, re(0));
	}
	return ans;
} 
int main() {
	cout<<re(0);
	return 0;
}
//很短，对吧
```

## 解释

首先要有对递归的思路：

定义操作：``re(int ans) `` 函数；

必要参数：``int ans`` 用来记录当前的答案；

子操作：

循环输入字符，每输入一个字符就判断这个字符是什么? 

1. 是 ``x`` 则将  $ans$ 增加；

2. 是 ``(`` 则进入递归，统计括号内的字符数，也就是 $re(0)$，同时将答案增加返回值；

3. 是 ``)`` 则将当前答案返回；

4. 是 ``|`` 则计算当前的答案和接下来的答案的最大值，也就是 $ans + f(0)$。

边界：输入完了，退出。

---

**补充一下 ``|`` 的芝士：**

返回 ``|`` 左边和右边的答案的最大值，比如 ``xxxx|xxxxxxxxx`` 就会返回 $9$。



---

## 作者：封禁用户 (赞：10)

# 题目大意

给出一个只由 `x` `(` `)` `|` 组成的正则表达式。求这个正则表达式能接受的最长字符串的长度。

# 题目解法

用递归的方法求解。

对于正则表达式的四种元素 `x` `(` `)` `|`，有四种情况：

- $x$，长度为 $1$。

- `(`，调用函数来计算子正则表达式的最长长度。

- `)`，返回当前子正则表达式的最长长度。

- `|`，计算两个子正则表达式的最长长度，取较大值。

最终将 $1$ 带入函数中即可。

献上我的丑陋代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int func(int j){
    char c;
    while(cin>>c){
        if(c=='x')
			j++;
        	else
				if(c=='(')
					j+=func(0);
        				else
							if(c=='|')
								return max(j,func(0));
        							else
										if(c==')')
											return j;
    }
    return j;
}
int main(){
    cout<<func(0);
    return 0;
}
```


---

## 作者：XIxii (赞：2)

遇到括号匹配类似的问题，首先想到的就是用栈。

如果用栈的话有两种：第一种是递归用系统栈；第二种是自定义栈用迭代。

这里我们通过递归来实现。

这道题是想让我们求最长的 $x$ 字符串长度，所以其实我们可以直接递归求长度，不再用字符串做计算了。

首先我们需要遍历整个字符串，由于是递归遍历，所有我们需要定义一个全局变量 $pos$ 表示当前遍历到的位置索引。

然后我们先来考虑遇到 ```|``` 符号：```|``` 肯定连接了两个 $x$ 字符串，我们要求其中最大的那个，所以需要定义两个变量：$tmp$ 和 $res$，分别表示 ```|``` 左边的 $x$ 串和右边的 $x$ 串长度。

初始化 $tmp$ 和 $res$ 都是 $0$，然后遇到 $x$ 时令 $pos$ 加 $1$,$tmp$ 也加一。

此时如果遇到 ```|``` ，此时我们让 $res = \max(res,tmp)$，然后置 $tmp$ 为 $0$，代表 $tmp$ 要计算 ```|``` 后面的长度。

如果遇到 ```)```，同样也让 $res = \max(res,tmp)$，然后返回 $res$。

如果遇到 ```(```，那么应该先累加 $pos$，然后开启一个新的递归。

下面是代码：

```
#include <bits/stdc++.h>
using namespace std;
char s[1001];
int len,pos=0;
int fun()
{
	int res=0,tmp=0;
	while(pos<len)
	{
		switch(s[pos]) 
		{
			case '(':
			{
				pos++;
				tmp+=fun();
				break;
			}
			case ')':
			{
				pos++;
				res=max(res,tmp);
				return res;
			}
			case 'x':
			{
				pos++;
				tmp++;
				break;
			}
			case '|':
			{
				pos++;
				res=max(res,tmp);
				tmp=0;
				break;
			}
		}
	}
	res=max(res,tmp);
	return res;
}
int main()
{
	cin>>s;
	len=strlen(s);
	cout<<fun()<<endl;
	return 0;
} 

```



---

## 作者：highkj (赞：2)

# 思路
这道题总体来说很简单，只需要将每一种操作分开即可，我们对于每一种符号进行分类讨论即可，我们定义一个函数来单独计算，每次遇到一个左括号我们就可以重新进行计算若遇到了右括号则直接返回当时计算出来的值，若遇到了一个字符直接将当前答案加一即可若遇到了或也可以用当前的答案和或的另一边的值取最大值即可。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rep1(i,x,y) for(int i=x;i>=y;--i)
string s;
int dfs() {
	char c;
	int res=0;
	while(cin>>c) {
		if(c=='x') res++; //将当前答案加一
		else if(c=='(') res+=dfs(); //将括号中的相加
		else if(c==')') return res; //直接返回
		else if(c=='|') return max(res,dfs());
	}
	return res;
}
signed main() {
	cout<<dfs()<<endl;
	return false;
}
```

---

## 作者：Neilchenyinuo (赞：1)

- 本题核心思想为递归。

## 题目大意

给出一个只由 `x` `(` `)` `|` 组成的正则表达式。求这个正则表达式能接受的最长字符串的长度。

## Solution

1. $x$，表示长度加一。

2. `(` 调用函数来计算子正则表达式的最长长度。

3. `)` 直接返回当时计算出来的值。

4. `|` 要加上前面和后面之间的最大值，也就是分两边递归。

5. 跟着分析模拟即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int dfs()
{
	char c;
	int cnt=0;
	while(cin>>c)
	{
		if(c=='x')
			cnt++;//长度加一
		else if(c=='(')	
			cnt+=dfs();计算最长长度，并加进去
		else if(c==')')
			return cnt;//直接返回最长长度
		else if(c=='|')
			return max(cnt,dfs());//去找出最大值分两边递归
	}
	return cnt;
}
int main()
{
	cout<<dfs();
	return 0;
}
```


---

## 作者：Dr_Octopus (赞：1)

## P8650 [蓝桥杯 2017 省 A] 正则问题 题解

### 题目分析

首先，对于题目给出的正则表达式，其中存在着多重括号。

那么对于一个式子，就必然需要回溯来对上一层括号中的内容进行反馈。

于是想到用搜索来求解本题。

接着，再看一眼数据范围，要求输入字符串的长度不超过 100，搜索是适用的。

然后， 就可以用搜索对本题进行分析，构造代码。


------------


### 思路

我们可以定义两个变量：num 和 ans 来表示当前遍历某个连续 × 串的长度和当前遍历连续串的最大长度。

遇到 ( 时，我们就需要进行一次 dfs，来确定在当前这对括号中所能接受字符串的最大长度。

遇到 ) 时，就说明已经将当前一对 ( ) 遍历完毕，接下来直接返回遍历的结果即可。

遇到 | 时，我们就比较当前的 num 和 ans：

如果  num > ans，就更新 ans；否则 ans 不变，令 num = 0。


------------


### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

string str;

int dfs() {
	
    int num = 0, ans = 0;
	
    while (pos < len) {
        if (str[pos] == '(') {
            pos ++;
	    num += dfs();
	}
	else if (str[pos] == ')') {
            pos ++;
            break;
	}
	else if (str[pos] == '|') {
	    pos ++;
	    ans = max(num, ans);
	    num = 0;
	}
	else {
	    pos ++;
	    num ++;
	}
    }
    ans = max(num, ans);
	
    return ans;
    
}

 
int main() {
	
    cin >> str;
    int pos = 0; 
    int len = str.length();
    
    cout << dfs();
	
    return 0;
}

```



---

## 作者：5k_sync_closer (赞：1)

递归。令 `D()` 返回接下来的一个子表达式的答案。

考虑下一个字符：

- `x`：答案接上 `x`，答案加一。
- `(`：答案接上下一个子表达式，答案加 `D()`。
- `)`：该子表达式结束，返回答案。
- `|`：答案与下一个子表达式取 $\max$ 后该子表达式结束，返回答案与 `D()` 的最大值。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int D()
{
    char c;
    int q = 0;
    while (~(c = getchar()))
        switch (c)
        {
        case 'x':
            ++q;
            break;
        case '(':
            q += D();
            break;
        case ')':
            return q;
        case '|':
            return max(q, D());
        }
    return q;
}
int main()
{
    return !printf("%d", D());
}
```


---

## 作者：YangXiaopei (赞：0)

## 题目大意:
给出一个只由 `x ( ) |` 组成的正则表达式。求这个正则表达式能接受的最长字符串的长度。

## Solution：
一个比较 ~~简单~~ 的模拟。

用递归的方法求解。

对于正则表达式的四种元素 `x ( ) |`，有四种情况：

* `x`，长度加 1。

* `(`，调用函数来计算子正则表达式的最长长度。

* `)`，返回当前子正则表达式的最长长度。

* `|`，计算两个子正则表达式的最长长度，取较大值。

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int cz(int j){
    char c;
    while(cin >> c){
        if(c == 'x'){
			j++;
		}
        else{
			if(c == '('){
				j += cz(0);
			}
        	else{
				if(c == '|'){
					return max(j, cz(0));
				}
        		else{
					if(c == ')'){
						return j;
					}
				}
			}
		}
    }
    return j;
}
int main(){
    cout << cz(0);
    return 0;
}
```
PS : 个人爱打空格,请见谅。

---

## 作者：zwyyy (赞：0)

### [原题传送门](https://www.luogu.com.cn/problem/P8650)

# 本文主要讲解思路

## 思路
~~可以看到题目标签里有一个递归的标签~~

通过仔细思考可得此题使用递归的方法。

括号里的表达式先处理，`|` 表示选出两侧字符串中较长的一个。

- 处理到 `x` 时增加计数变量 $ans$；
- 处理到 `(` 时调用递归函数；
- 处理到 `|` 时调用递归函数，比较返回值与 $ans$ 并返回较大的值；
- 处理到 `)` 时返回 $ans$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dg(int ans){
	char n;
	while(1){
		scanf("%c", &n);
		if(n == 'x')	++ans;
		else if(n == '(')	ans += dg(0);
		else if(n == '|')	return max(ans, dg(0));
		else if(n == ')')	return ans;
		else	break;
	}
	return ans;
}
int main(){
	printf("%d", dg(0));
	return 0;
}
```
[AC](https://www.luogu.com.cn/problem/P8650)

---

## 作者：StarRain3 (赞：0)

讲一种与众不同的栈做法。

看到这题，我们就能联想到表达式那类问题的做法，于是按照表达式求值对括号的处理思路对本题进行求解，具体的思路就不说了，核心的思想是栈遇到 `)` 则对当前括号进行处理，否则入栈。

有几个要注意的地方：第一是不要忘了把左括号取出来，第二是一个括号里可能有多个 `|`，要选择合适的做法去得到当前括号最大长度，第三是最后要再查找一次，因为可能此时栈里可能还有 `|`，最后栈的长度，就是我们的答案了。

需要注意的是，查找时统计现在这个括号里的最大值，注意括号里可能没有 `|`，但也可能有多个 `|`。

#### 核心代码


```
void count(){ 
    int n1 = 0, max_n = 0;
    while(stk.size() && stk.top() != '('){
        char top_ch = stk.top();
        stk.pop();
        if(top_ch == 'x'){
            n1++;
        }else{
            maxn = max(maxn, n1);
            n1 = 0;
        }
    }
    maxn = max(maxn, n1);
    if(stk.size()) stk.pop();

    for(int j = 0; j < maxn; j++){
        stk.push('x');
    }

}
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

## P8650 [蓝桥杯 2017 省 A] 正则问题 题解

### 题目分析

递归练习题。

我们可以先定义一个 $ans$，用来计数。然后扫一遍字符串。如果 $s_i$ 是 `a`，$ans$ 就加上 $1$。如果 $s_i$ 是 `(`，$ans$ 要加上括号里面的结果，要递归调用函数。如果 $s_i$ 是 `)`，这一层递归结束，返回当前函数的值。如果 $s_i$ 是 `|`，$ans$ 要加上前面和后面之间的最大值，也就是分两边递归。递归完后输出 $ans$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define qwq ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
const int N = -1;
char c;

int solve(int ans)
{
	while (cin >> c)
	{
		if (c == 'x')
			++ ans;
		else if (c == '(')
			ans += solve(0);
		else if (c == '|')
			return max(ans, solve(0));
		else if (c == ')')
			return ans;
	}
	return ans;
}

signed main()
{
	qwq;
	cout << solve(0 xor 0 bitand 0);
	return 0;
}
```


---

## 作者：fish_love_cat (赞：0)

注：本题解将视大家都看过 P3719 题面，各位都明白那些奇奇怪怪的符号的含义，以此为基础解题。

---

~~言简是真的，意思表达的嘛……~~

[题面更详尽的双倍经验。（P3719）](https://www.luogu.com.cn/problem/P3719#submit)

**思路：**

核心思想：```递归```

定义一个计数的函数，一路读入下去。

如果碰上 ```a```，计数的变量就加一。

如果碰上 ```(```，计数的变量就要加上括号里面的结果，也就是递归，重新调用计数函数求括号里式子的值。

如果碰上 ```)```，返回这个括号里的值，也就是返回当前计数函数统计出来的值。

如果碰上 ```|```，返回前面式子和后面式子之间的最大值，而后面式子照样调用计数函数统计。

如果输入到头了，返回答案即可。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ji(){
    long long ans=0;
    char c;
    while(cin>>c){
        if(c=='x') ans++;
        if(c=='(') ans+=ji();
        if(c==')') return ans;
        if(c=='|') return max(ans,ji());
    }
    return ans;
}
int main(){
    cout<<ji();
    return 0;
}
```


---

## 作者：CQ_Bab (赞：0)

# 思路
这道题我们可以把它给拆开来看，那么我们就定义一个函数为 $f$ 来分别求值然后我们就将每一个符号进行求职即可，那么我们分别对四种符号进行求值，我们可以发现对于或的话就是前面和后面的最大值，然后对于字符就直接加一，前括号就等于要算括号内的值那么就再进行 $f$ 然后在后括号时返回当前值即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int j){
    char c;
    while(cin>>c){
        if(c=='x') j++;
        else if(c=='(') j=j+f(0);
        else if(c=='|') return max(j,f(0));
        else if(c==')') return j;
    }
    return j;
}
int main(){
    cout<<f(0);
    return false;
}
```


---

## 作者：Silencer_jin (赞：0)

## [题干](https://www.luogu.com.cn/problem/P8650)
思路不用多说，~~明摆着标签给你看~~，是**递归**。


------------

### 题目解析：

正则表达式中一共有 4 种元素 ```x```，```(```，```)``` 和 ```|```。

代表的含义如下：

```x```：字符。

```(```：计算被包裹的子正则表达式的最长长度。

```)```：返回子正则表达式的最长长度。

```|```：返回左右两边长度的较大值。

------------

```
#include<bits/stdc++.h>
using namespace std;
int p(){
	char c;
	int ans=0;
	while(cin >> c){//输入
		if(c=='x')ans++;//如果字符为 x，长度改变
		if(c=='(')ans+=p();//计算长度
		if(c==')')return ans;//返回长度
		if(c=='|')return max(p(),ans);左右两边寻找较大值
	}
	return ans;//返回
}
int main(){
    cout << p();//递归
    return 0;
}
```


------------

思路不难想到，是练习递归的~~水题~~好题。

个人认为代码风格挺简洁，~~顺带多嘴一句~~，送一个[双倍经验](https://www.luogu.com.cn/problem/P8650)，慢走不谢！（逃。

---


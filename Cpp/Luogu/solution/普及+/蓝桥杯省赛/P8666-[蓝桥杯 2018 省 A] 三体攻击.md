# [蓝桥杯 2018 省 A] 三体攻击

## 题目描述

三体人将对地球发起攻击。为了抵御攻击，地球人派出了 $A\times B\times C$ 艘战舰，在太空中排成一个 $A$ 层 $B$ 行 $C$ 列的立方体。其中，第 $i$ 层第 $j$ 行第 $k$ 列的战舰（记为战舰 $(i, j, k)$）的生命值为 $d(i, j, k)$。

三体人将会对地球发起 $m$ 轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。具体地，第 $t$ 轮攻击用 $7$ 个参数 $la_t, ra_t, lb_t, rb_t, lc_t, rc_t, h_t$ 描述；

所有满足 $i\in [la_t, ra_t],j\in [lb_t, rb_t],k\in [lc_t, rc_t]$ 的战舰 $(i, j, k)$ 会受到 $h_t$ 的伤害。如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。

地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。


## 说明/提示

**【样例解释】**

在第 $2$ 轮攻击后，战舰 $(1,1,1)$ 总共受到了 $2$ 点伤害，超出其防御力导致爆炸。

**【数据约定】**

对于 $10\%$ 的数据，$B = C = 1$；

对于 $20\%$ 的数据，$C = 1$；

对于 $40\%$ 的数据，$A\times B \times C, m\le10000$；

对于 $70\%$ 的数据，$A, B, C \le 200$；

对于所有数据，$1\le A\times B\times C \le 10^6$，$1\le m \le 10^6$，$0 \le  (i, j, k)$, $h_t\le 10^9$。

## 样例 #1

### 输入

```
2 2 2 3
1 1 1 1 1 1 1 1
1 2 1 2 1 1 1
1 1 1 2 1 2 1
1 1 1 1 1 1 2```

### 输出

```
2```

# 题解

## 作者：GUO120822 (赞：18)

在 12 月 30 日更新。

先看下[题目](https://www.luogu.com.cn/problem/P8666)。

- 题目大意

这题其实就是一个修改问题，每次修改一个部分，看第几次有一个战舰累计受到的总伤害超过其防御力，就输出这个攻击的轮数。

- 思路

我们读完题，会发现这道题其实具有单调性。为什么呢？因为操作轮数越多，有某一个船爆炸的概率就越大。所以可以二分答案。
```cpp
l=1;
r=m;
while (l<=r)
{
    mid=l+r>>1;
    if (check(mid)) r=mid-1;
    else l=mid+1;
}
```
那么怎么检查呢？这就用到了三维差分。

三维差分怎么做？我们先来看看一维和二维的我们是怎么做的。

一维：
```cpp
a[s]+=h;
a[t+1]-=h;
```
二维（奇减偶加）：
```cpp
b[sx][sy]+=h;
b[sx][ty+1]-=h;
b[tx+1][sy]-=h;
b[tx+1][ty+1]+=h;
```
由此，我们根据容斥原理，发现三维的是奇加偶减，可得三维差分公式：
```cpp
c[calc(sx,sy,sz)]+=h;
c[calc(tx+1,sy,sz)]-=h;
c[calc(sx,ty+1,sz)]-=h;
c[calc(sx,sy,tz+1)]-=h;
c[calc(sx,ty+1,tz+1)]+=h;
c[calc(tx+1,sy,tz+1)]+=h;
c[calc(tx+1,ty+1,sz)]+=h;
c[calc(tx+1,ty+1,tz+1)]-=h;
```
在做完差分后，再求前缀和（容斥原理，奇加偶减）。
```cpp
c[calc(i,j,k)]+=
c[calc(i-1,j,k)]
+c[calc(i,j-1,k)]
+c[calc(i,j,k-1)]
-c[calc(i-1,j-1,k)]
-c[calc(i-1,j,k-1)]
-c[calc(i,j-1,k-1)]
+c[calc(i-1,j-1,k-1)];
```
计算函数指的是把三维压成一维，映射它在一维数组中的位置。
```cpp
int calc(int a,int b,int c)
{
    return max(0ll,((a-1)*B+(b-1))*C+(c-1)+1);
    			|
          防越界
}
```
最后，[展示](https://www.luogu.com.cn/record/196627917)。

注意 HACK 数据。

- 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
int A,B,C,m,i,j,k,a[N],c[N];
int sx[N],sy[N],sz[N],tx[N],ty[N],tz[N],h[N];
int l,r,mid;
int calc(int a,int b,int c)
{
	return max(0ll,((a-1)*B+(b-1))*C+(c-1)+1);
}
void cf(int sx,int sy,int sz,int tx,int ty,int tz,int h)
{
	c[calc(sx,sy,sz)]+=h;
	c[calc(tx+1,sy,sz)]-=h;
	c[calc(sx,ty+1,sz)]-=h;
	c[calc(sx,sy,tz+1)]-=h;
	c[calc(sx,ty+1,tz+1)]+=h;
	c[calc(tx+1,sy,tz+1)]+=h;
	c[calc(tx+1,ty+1,sz)]+=h;
	c[calc(tx+1,ty+1,tz+1)]-=h;
}
bool check(int mid)
{
	memset(c,0,sizeof(c));
	int i,j,k;
	for (i=1;i<=mid;i++) cf(sx[i],sy[i],sz[i],tx[i],ty[i],tz[i],h[i]);
	for (i=1;i<=A;i++)
	{
		for (j=1;j<=B;j++)
		{
			for (k=1;k<=C;k++)
			{
				c[calc(i,j,k)]+=
    			c[calc(i-1,j,k)]
    			+c[calc(i,j-1,k)]
    			+c[calc(i,j,k-1)]
    			-c[calc(i-1,j-1,k)]
    			-c[calc(i-1,j,k-1)]
    			-c[calc(i,j-1,k-1)]
    			+c[calc(i-1,j-1,k-1)];
				if (c[calc(i,j,k)]>a[calc(i,j,k)]) return true; 
			}
		}
	}
	return false;
}
signed main()
{
	scanf("%lld%lld%lld%lld",&A,&B,&C,&m);
	for (i=1;i<=A;i++)
	{
		for (j=1;j<=B;j++)
		{
			for (k=1;k<=C;k++) scanf("%lld",&a[calc(i,j,k)]);
		}
	}
	for (i=1;i<=m;i++) scanf("%lld%lld%lld%lld%lld%lld%lld",&sx[i],&tx[i],&sy[i],&ty[i],&sz[i],&tz[i],&h[i]);
	l=1;
	r=m;
	while (l<=r)
	{
		mid=l+r>>1;
		if (check(mid)) r=mid-1;
		else l=mid+1;
	}
	printf("%lld",l);
	return 0;
}
```

---

## 作者：Cuxhin (赞：6)

# P8666 [蓝桥杯 2018 省 A] 三体攻击 细节诠释
> 真的实在找不到哪里的LaTeX格式有问题了（

本题的主要思路是 三维差分 + 二分优化 + 压维，这篇题解主要是对一些概念做出解释，希望想理解这题做法的人能一遍看懂，然后码字一遍过。

## 三维差分

差分是什么？可以理解为**前缀和的逆运算**。我们用前缀和来获取前几个元素的和，差分则是反过来，用前缀和获取第几个元素的和。差分适合区间修改和单次的查询。
![](https://cdn.luogu.com.cn/upload/image_hosting/i2sl3dfs.png)
> 区间修改范围为 $[4,6]$， ST 指刚进入修改区间的线，终点坐标为 $4$， ED 指刚离开修改区间的线，终点坐标为 $7$。

我们先从一维差分开始。我们想象一条线出来，我们随便给线上一段染色，同时，我们从这条线的起点再平行拉一条新的线。染色对应的是刚才提到的**区间修改**，拉的线代表**差分数组的前缀和**，而我们的目的就是修改一个**差分数组**来让这个数组的前缀和能代表第几个元素的值。我们可以发现，当我们的线刚拉到染色那一段的时候，我们这条线的终点就来到了染色的地方，这个时候终点元素的值就被修改区间的时候修改了，于是，我们需要**修改刚好进入区间的那个元素（区间的头），在这里加区间修改的值**。然后我们刚好拉出染色那一段时，线的终点过了染色区，终点元素不在这个区间修改的范围了，于是，我们**需要修改在刚好走出区间的那个元素（区间的尾 $+1$，因为要刚好走出区间），在这里减区间修改的值**。至此，一个区间修改中，我们需要修改差分数组的两个地方就找出来了，一个是区间头，一个是区间尾 $+1$，挺像半开区间 $[a,b)$。如果还有多个区间需要修改，我们重复刚才的过程，不断在差分数组上叠加就可以了。
![](https://cdn.luogu.com.cn/upload/image_hosting/o8jl2xaq.png)
> 橙色代表差分数组前缀和，绿色代表修改区间（线是方便定位坐标拉的），蓝色代表加的点，紫色代表减的点，褐色代表差分数组前缀和与修改区间的重叠部分。

其次我们来到了二维，我们的染色变成了一个平面，我们拉线也变成了从起点拉一个矩形出来。跟一维一样，我们需要保证我们的**差分数组的前缀和**（此处是一个矩形，一维是条线），在进入**修改区间**（这里是一个矩形）要加上区间修改的值，在刚好走出去区间时要减去区间修改的值。但是我们发现，当我们拉出来的矩形在刚好完全覆盖这个矩形后，减了两次区间修改的值，却增加了一次。那我们后面统计前缀和的同时，就永远减去了这个区间修改的值。这如何是好？我们便仿照刚才刚好出区间减区间值，**在刚好完全覆盖区间并走出去时，加上区间值来补偿之前多减的一次**。我们补偿的地方同样是这个区间的外面。还是与半开区间 $[a,b)$ 相似。

![](https://cdn.luogu.com.cn/upload/image_hosting/13olvbj9.png)
> 绿色代表修改区间，橙色代表差分数组前缀和，蓝色是加的点（用一个立方体代替了），紫色是减的，最后两个图叠在一起就是总共要改的点。

最后我们升维到三维空间，我们有更多的点需要修改，这如何是好？其实我们只需要仿照刚才推理的过程，从起点拉一个立方体作为**差分数组的前缀和**，当我们进入**修改区间**（也是一个空间内的立方体）时，我们加上区间修改值；刚好走出去时，减去区间修改值。我们从不同方向 $(x,y,z)$ 扩展我们的立方体前缀和，当我们发现走出立方体却多减了区间修改值时，我们再补偿回来，加上区间修改值。最后我们得到的修改点，很像将二维的平面图像中的四个点（进入时加的点，两个出去时减去的点，一个补偿点）旋转，拼贴成的。

整理下我们得到三维修改区间时要改的差分数组的位置。

```cpp
// d 是差分数组， d 的前缀和代表第几个元素的值
// findit 是我的压维函数，可以暂时不用理，后面 xyz 是坐标，理解成 d[x][y][z] 就行
//x1,y1,z1是代表修改区间的立方体中最靠近起始点的端点
//x2,y2,z2是代表修改区间的立方体中最远离起始点的端点
d[findit(x1[i],y1[i],z1[i])]+=h[i];
d[findit(x2[i]+1,y1[i],z1[i])]-=h[i];
d[findit(x1[i],y2[i]+1,z1[i])]-=h[i];
d[findit(x2[i]+1,y2[i]+1,z1[i])]+=h[i];
d[findit(x1[i],y1[i],z2[i]+1)]-=h[i];
d[findit(x2[i]+1,y1[i],z2[i]+1)]+=h[i];
d[findit(x1[i],y2[i]+1,z2[i]+1)]+=h[i];
d[findit(x2[i]+1,y2[i]+1,z2[i]+1)]-=h[i];
```

到这里我们就理解了三维差分的修改逻辑了。当我们得到一个修改区间时，我们把差分数组中它的八个修改点都进行区间值的加加减减就行，然后我们进入统计前缀和。

一维的前缀和很好理解，就是从起点到终点，不断把前一个值往后面加，$a[1]$ 的值加到 $a[2]$，然后 $a[2]$ 的值连同了 $a[1]$ 的值再加到 $a[3]$，以此类推。二维呢？我们可以通过逆推，我们刚才时候发现区间修改需要更正的点（$2$ 加 $2$ 减），我们把这个点到起点的面积，减去旁边两个位置到起点的面积，然后我们多减了一块面积，再补回去。（此处无图，用公式代替：$a[i][j]=s[i][j]-s[i-1][j]-s[i][j-1]+s[i-1][j-1]$）。

但是我们还有另一种方法，我们类推一维前缀和中，将前一个值不断往后加。我们想到：**先把一个方向的值往后不断累加，再从另一个方向把值不断累加**。接下来举个例子。

原二维数组。

| 1    | 1    | 1    |
| ---- | ---- | ---- |
| 1    | 1    | 1    |
| 1    | 1    | 1    |

横向累加。

| 1    | 2    | 3    |
| ---- | ---- | ---- |
| 1    | 2    | 3    |
| 1    | 2    | 3    |

纵向累加。

| 3    | 6    | 9    |
| ---- | ---- | ---- |
| 2    | 4    | 6    |
| 1    | 2    | 3    |

如何？二维我们姑且可以直接用面积推导公式，但是三维的时候，想用公式推前缀和会比较麻烦。我们就可以用这样把方向拆分，分开累加的方式，三维无非就是多了一个方向而已，代码实现大概如下。

```cpp
// d 是差分数组，findit 差分数组可忽略，ijk 分别对应 xyz
for(int i=1;i<=A;i++)
	for(int j=1;j<=B;j++)
		for(int k=2;k<=C;k++)
			d[findit(i,j,k)]+=d[findit(i,j,k-1)];
	
for(int i=1;i<=A;i++)
	for(int k=1;k<=C;k++)
		for(int j=2;j<=B;j++)	
			d[findit(i,j,k)]+=d[findit(i,j-1,k)];
				
for(int j=1;j<=B;j++)
	for(int k=1;k<=C;k++)
		for(int i=2;i<=A;i++)
			d[findit(i,j,k)]+=d[findit(i-1,j,k)];
```

总结下，我们通过修改八个端点来实现区间修改投射到差分数组的修改，通过分开方向递推累加实现了统计前缀和。

## **二分优化**

我们可以发现舰队攻击造成伤害只会越来越多，而题目要我们找一个临界点，刚好有舰队炸了的临界点。

我们先明确我们区间的定义。

> $[L,R]$（即 $L\le R$ ），二分停止时 $R$ 在 $L$ 左边一个值：$[L,R]$ 内的任意一次攻击不会有舰队爆炸，$[L,m]$ 内的任意一次攻击后，存在爆炸的舰队。
>
>  $mid$ 次攻击时如果存在舰队爆炸，则 $mid$ 及之后攻击都存在舰队爆炸，根据 $[1,R]$ 的定义，$R=mid-1$。
>
>  $mid$ 次攻击时如果不存在舰队爆炸，则 $mid$ 及之前攻击都不存在舰队爆炸，根据 $[L,m]$ 的定义，$R=mid+1$。
>
> 题目要我们找刚好舰队炸了的临界点，则 $L$ 刚好是这个临界点，$L$ 就是我们的答案，也可以是 $R+1$。

我们通过明确的定义将二分区间 $[L,R]$，端点修改，和答案的值。

[如果你还想对二分的细节有更多了解可以学习这篇（不是广告，推荐好文）。](https://leetcode.cn/circle/discuss/ooxfo8/)

```cpp
int L=1,R=m;
while(L<=R){
	int mid=(L+R)>>1;
	if(check(mid)) R=mid-1;//check为true代表存在舰队爆炸
	else L=mid+1;
}
printf("%d\n",L);
```
如果你习惯半开半闭（$l<r$）也可以这么写，具体定义就不赘述了。
```cpp

while(L<R){
	int mid=(L+R)>>1;
	if(check(mid)) R=mid;
	else L=mid+1;
}

printf("%d\n",R);
```
## 压维

> 蒟蒻码完题解才发现原来题目有给压维的公式，哭了。

我们发现题目 $1 \le A+B+C \le 100000$，我们肯定不能 $d[100000][100000][100000]$ 来定义我们的数组，这太大了。但是我们可以利用 $A+B+C$ 的和确定来压缩我们的差分数组，让我们能通过差不多 $d[100000]$ 的空间来存三维空间的点。

例如 $d[a][b][c]$（ $a$ 最大值为 $A$，$b$ 最大值为 $B$，$c$ 最大值为 $C$）因为按顺序 $a$ 在 $b$ 前， $b$ 在 $c$ 前，我们得沿着这个顺序来推理我们的压维方式。我们想象一个 $a$ 层高， $b$ 格宽， $c$ 格长的立方体。每一层总共有 $B\times C$ 个格子，每一层中每一行都有 $C$  格格子，每一层中每一行中每一列都有一个格子。我们先把这个立方体每层平摊到一个平面上，按顺序整齐一条线排列，然后把这个平面每一行都拆开，挤在同一行中。好的，我们就完成了压维。如何查询呢？不妨回到刚刚的压维过程中每一层，每一层中每一行的格子数量，**我们将层数乘以每一层的格子数，行数乘以每一层中每一行的数量，列数不动**，就能找到压维前的坐标了。但是我们的层数，行数，列数都需要减一。例如一层二行三列中查找 $d[1][1][1]$，如果我们不减一，那么我们就从 $1\times2\times3+1\times3+1=10$ 开始存了，浪费了一段空间，所以 $-1$ 来查找。

```cpp
int findit(int x,int y,int z){
	if(x>A or y>B or z>C) return 0;
    return (x-1)*B*C+(y-1)*C+(z-1)+1;//细节-1。
    //(+1是因为我喜欢下标从1开始，如果你从0开始可不写)
}
```
具体代码可以参考其他题解，都大差不差。理解思路是最主要的。

这里就剧终了，谢谢观看。

> Cuxhin、初心

---

## 作者：新哲 (赞：3)

# 题解：P8666 [蓝桥杯 2018 省 A] 三体攻击
题目：<https://www.luogu.com.cn/problem/P8666>

## 分析过程
- 首先，我们想到的是暴力差分，可是 $O(ABC)$ 的复杂度会超时，因此我们可以继续优化，使用二分答案计算出结果。
- 然后，$10^6$ 的数据范围不能直接存储。于是我们看着题目中给出的压维公式。封装为函数如下：
```c++
int func(int a, int b, int c)
{
    return max(0ll, ((a - 1) * B + (b - 1)) * C + (c - 1) + 1);
}
```
- 虽然要结合差分算法，但三维差分也是必不可少的：
```c++
c[func(sx[i], sy[i], sz[i])] += h[i];
c[func(tx[i] + 1, sy[i], sz[i])] -= h[i];
c[func(sx[i], ty[i] + 1, sz[i])] -= h[i];
c[func(sx[i], sy[i], tz[i] + 1)] -= h[i];
c[func(sx[i], ty[i] + 1, tz[i] + 1)] += h[i];
c[func(tx[i] + 1, sy[i], tz[i] + 1)] += h[i];
c[func(tx[i] + 1, ty[i] + 1, sz[i])] += h[i];
c[func(tx[i] + 1, ty[i] + 1, tz[i] + 1)] -= h[i];
```
- 还有二分算法必备的常见写法啦：
```c++
while (l <= r)
{
    int mid = (l + r) / 2;
    if (check(mid))
    {
        r = mid - 1;
    }

    else
    {
        l = mid + 1;
    }
}
cout << l;
```
- 最后拼拼凑凑，一道绿题就 AC 了！
## AC Code
```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int A, B, C, m, i, j, k, a[1000010], c[1000010];
int sx[1000010], sy[1000010], sz[1000010], tx[1000010], ty[1000010], tz[1000010], h[1000010];
int func(int a, int b, int c)
{
    return max(0ll, ((a - 1) * B + (b - 1)) * C + (c - 1) + 1);
}
bool check(int mid)
{
    memset(c, 0, sizeof(c));
    int i, j, k;
    for (i = 1; i <= mid; i++) {
        c[func(sx[i], sy[i], sz[i])] += h[i];
        c[func(tx[i] + 1, sy[i], sz[i])] -= h[i];
        c[func(sx[i], ty[i] + 1, sz[i])] -= h[i];
        c[func(sx[i], sy[i], tz[i] + 1)] -= h[i];
        c[func(sx[i], ty[i] + 1, tz[i] + 1)] += h[i];
        c[func(tx[i] + 1, sy[i], tz[i] + 1)] += h[i];
        c[func(tx[i] + 1, ty[i] + 1, sz[i])] += h[i];
        c[func(tx[i] + 1, ty[i] + 1, tz[i] + 1)] -= h[i];
    }
        
    for (i = 1; i <= A; i++)
    {
        for (j = 1; j <= B; j++)
        {
            for (k = 1; k <= C; k++)
            {
                c[func(i, j, k)] +=
                    c[func(i - 1, j, k)] + c[func(i, j - 1, k)] + c[func(i, j, k - 1)] - c[func(i - 1, j - 1, k)] - c[func(i - 1, j, k - 1)] - c[func(i, j - 1, k - 1)] + c[func(i - 1, j - 1, k - 1)];
                if (c[func(i, j, k)] > a[func(i, j, k)])
                {
                    return true;
                }
            }
        }
    }
    return false;
}
signed main()
{
    cin >> A >> B >> C >> m;
    for (i = 1; i <= A; i++)
    {
        for (j = 1; j <= B; j++)
        {
            for (k = 1; k <= C; k++)
            {
                cin >> a[func(i, j, k)];
            }
        }
    }
    for (i = 1; i <= m; i++)
        cin >> sx[i] >> tx[i] >> sy[i] >> ty[i] >> sz[i] >> tz[i] >> h[i];
    int l = 1, r = m;
    while (l <= r)
    {
        int mid = (l + r) / 2;
        if (check(mid))
        {
            r = mid - 1;
        }

        else
        {
            l = mid + 1;
        }
    }
    cout << l;
    return 0;
}
```

---

## 作者：sxwgysh (赞：2)

## 题目分析：
本题的核心任务是模拟三体人对地球战舰的多次攻击过程，每次攻击会对一个小立方体范围内的战舰造成相同伤害。我们需要找出第一艘因累计伤害超过其生命值而爆炸的战舰，并确定它是在哪一轮攻击后爆炸的。
## 解题思路：
这道题很明显不可以直接暴力枚举会超时。这时候我们可以二分优化，可是这也优化不了多少啊，这时候我们就可以三维差分。  
直接模拟每次攻击并检查所有受影响战舰的生命值，时间复杂度会很高，因此可以采用二分查找+三维差分的方法来优化。  
### 二分查找：

```cpp
ll l = 1, r = m, ans;
while(l < r) {
	ll mid = (l + r) >> 1;
	if(check(mid)) {
		r = mid;
		ans = mid;
	}
	else l = mid + 1;
}
```
但是我们不可能开一个 $10^6 \times 10^6 \times 10^6$ 的数组，所以需要三维转一维。
### 三维转一维：

```cpp
ll num(ll x, ll y, ll z) {
	if(x > a || y > b || z > c) return 0;
	return ((x - 1) * b + (y - 1)) * c + (z - 1) + 1;
}
```

### 三维差分：

```cpp
D[num(a1[i], b1[i], c1[i])] += d[i];
D[num(a2[i] + 1, b2[i] + 1, c1[i])] += d[i];
D[num(a2[i] + 1, b1[i], c2[i] + 1)] += d[i];
D[num(a1[i], b2[i] + 1, c2[i] + 1)] += d[i];
D[num(a2[i] + 1, b1[i], c1[i])] -= d[i];
D[num(a1[i], b2[i] + 1, c1[i])] -= d[i];
D[num(a1[i], b1[i], c2[i] + 1)] -= d[i];
D[num(a2[i] + 1, b2[i] + 1, c2[i] + 1)] -= d[i];
```


## 代码实现：

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const ll N = 1e6 + 10;

ll a, b, c, m, n;
ll D[N], a1[N], a2[N], b1[N], b2[N];
ll c1[N], c2[N], d[N], s[N];

ll num(ll x, ll y, ll z) {
	if(x > a || y > b || z > c) return 0;
	return ((x - 1) * b + (y - 1)) * c + (z - 1) + 1;	
}

bool check(ll x) {
	for(ll i = 1; i <= n; ++ i) 
		D[i] = 0;
	for(ll i = 1; i <=x; ++ i) {
		D[num(a1[i], b1[i], c1[i])] += d[i];
		D[num(a2[i] + 1, b2[i] + 1, c1[i])] += d[i];
		D[num(a2[i] + 1, b1[i], c2[i] + 1)] += d[i];
		D[num(a1[i], b2[i] + 1, c2[i] + 1)] += d[i];
		D[num(a2[i] + 1, b1[i], c1[i])] -= d[i];
		D[num(a1[i], b2[i] + 1, c1[i])] -= d[i];
		D[num(a1[i], b1[i], c2[i] + 1)] -= d[i];
		D[num(a2[i] + 1, b2[i] + 1, c2[i] + 1)] -= d[i];
	}
	for(ll i = 1; i <= a; ++ i)
		for(ll j = 1; j <= b; ++ j)
			for(ll k = 1; k < c; ++ k)
				D[num(i, j, k + 1)] += D[num(i, j, k)];
	for(ll i = 1; i <= a; ++ i)
		for(ll k = 1; k <= c; ++ k)
			for(ll j = 1; j < b; ++ j)
				D[num(i, j + 1, k)] += D[num(i, j, k)];
	for(ll j = 1; j <= b; ++ j)
		for(ll k = 1; k <= c; ++ k)
			for(ll i = 1; i < a; ++ i)
				D[num(i + 1, j, k)] += D[num(i, j, k)];
	for(ll i = 1; i <= n; ++ i)
		if(D[i] > s[i])
			return true;
	return false;
}

signed main() {
    cin >> a >> b >> c >> m;
    n = a * b * c;
    for(ll i = 1; i <= n; ++ i)
    	cin >> s[i];
    for(ll i = 1; i <= m; ++ i)
    	cin >> a1[i] >> a2[i] >> b1[i] >> b2[i] >> c1[i] >> c2[i] >> d[i];
	ll l = 1, r = m, ans;
	while(l < r) {
		ll mid = (l + r) >> 1;
		if(check(mid)) {
			r = mid;
			ans = mid;
		}
		else l = mid + 1;
	}
	cout << r << "\n";
	return 0;
}
```

---

## 作者：OIerGuo (赞：2)

~~题号 8666 好评。~~

考虑二分第一艘战舰爆炸的时间。因为第 $1\sim m$ 次攻击之间总会有一个临界点，在临界点前没有战舰爆炸，在临界点后就出现了负值。

二分的过程就是用一个三维差分数组记录每次区间修改，然后向三个方向累加攻击值。最后判断每个战舰的攻击值是否大于生命值。

注意本题的数据范围只是说了 $A\times B\times C\le 10^{6}$，却并没有说明 $A,B,C$ 的范围，所以要用离散化。

时间复杂度 $O(A\times B\times C\times\log_{2}m)$，可以通过本题。

```cpp
#include<iostream>
using namespace std;
#define int long long
int A,B,C,n,m;
const int N=1000005;
int s[N];
int D[N],d[N];
int x1[N],y1[N],z1[N];
int x2[N],y2[N],z2[N];
int num(int x,int y,int z){
    if(x>A||y>B||z>C) return 0;
	return ((x-1)*B+(y-1))*C+(z);
}
bool check(int x){
	for(int i=1;i<=n;++i){
		D[i]=0;
	}
	for(int i=1;i<=x;++i){
		D[num(x1[i],  y1[i]  ,z1[i]  )]+=d[i];
		D[num(x2[i]+1,y1[i]  ,z1[i]  )]-=d[i];
		D[num(x1[i],  y1[i]  ,z2[i]+1)]-=d[i];
		D[num(x2[i]+1,y1[i]  ,z2[i]+1)]+=d[i];
		D[num(x1[i],  y2[i]+1,z1[i]  )]-=d[i];
		D[num(x2[i]+1,y2[i]+1,z1[i]  )]+=d[i];
		D[num(x1[i],  y2[i]+1,z2[i]+1)]+=d[i];
		D[num(x2[i]+1,y2[i]+1,z2[i]+1)]-=d[i];
	}
	for(int i=1;i<=A;++i){
		for(int j=1;j<=B;++j){
			for(int k=1;k<C;++k){
				D[num(i,j,k+1)]+=D[num(i,j,k)];
			}
		}
	}
	for(int i=1;i<=A;++i){
		for(int k=1;k<=C;++k){
			for(int j=1;j<B;++j){
				D[num(i,j+1,k)]+=D[num(i,j,k)];
			}
		}
	}
	for(int j=1;j<=B;++j){
		for(int k=1;k<=C;++k){
			for(int i=1;i<A;++i){
				D[num(i+1,j,k)]+=D[num(i,j,k)];
			}
		}
	}
	for(int i=1;i<=n;++i){
		if(D[i]>s[i]){
			return 1;
		}
	}
	return 0;
}
signed main(){
	cin>>A>>B>>C>>m;
	n=A*B*C;
	for(int i=1;i<=n;++i) cin>>s[i];
	for(int i=1;i<=m;++i){
		cin>>x1[i]>>x2[i]>>y1[i]>>y2[i]>>z1[i]>>z2[i]>>d[i];
	}
	int l=1,r=m;
	while(l<r){
		int mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	cout<<r<<endl;
	return 0;
}
```

---

## 作者：肖翔 (赞：1)

前言：本题解提供了一个做高维差分时，复杂度比容斥更优的解法，详细可以看 [囧仙的日报](https://www.luogu.com.cn/blog/over-knee-socks/post-difference)

首先考虑修改操作，相当于在三维空间里每次指定一个立方体，对其内部点加上某个值

容易想到用三维差分维护

可以发现，每艘战舰随时间增加收到的伤害是不减的

故记答案为 $ m $，则 $ m $ 以前的时刻都合法，$ m $ 及其后面的时刻都不合法

这个显然可以二分答案


------------


Q1： 为什么不一边暴力操作一边找到 $ m $ 呢？

A1： 因为这样复杂度会是立方体边长的立方量级，不太可接受。

Q2： 为什么一定要二分呢？

A2： 因为差分给到的是一个快速修改的手段，前缀和还原再  check  是很低效的。倘若一边修改一边 check，复杂度还不如暴力。差分+二分虽然多次重复了前面的某些修改，但它降低了 check 的次数。对于本题是一个很不错的选择。

（有点像某些分块的思想，都是平衡查询与询问的复杂度，降低整体的复杂度，但有点不一样）

Q3：不能用倍增避开重复吗？

A3：倍增跳过头的话需要一个还原的步骤，还是会"重复"，而且写起来麻烦。

------------


总而言之，我们确定了差分+二分的做法

二分一个时间 $ T $，把它前面的操作都做了，再做一次 check，看看是否有战舰爆炸

接下来就是差分板子了

但是大多数同学写的都是容斥做差分

记差分维数为 $ n $，操作数为 $ m $，立方体边长为 $ a $ (假设等边，只看量级)

则容斥做法的复杂度为 $ O(m \times 2^n+a^n \times2^n) $

多次差分的复杂度可以做到 $ O(m \times 2^n+a^n \times n) $


（多项式两项分别为修改和查询复杂度）

（其实在 $  n  $  比较小的时候没太大区别）

多次差分的思想大概是对着 $ z $ 方向，$ y $ 方向，$ x $ 方向分别差分一次

最后做三次前缀和就合起来了

避免了容斥系数的讨论，不失为一个兼具效率与好写的做法

（具体内容在日报里有图示，不再过多展开）

贴代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e7+10;
int s1[maxn],s2[maxn],s3[maxn],ans[maxn];
int A,B,C;
inline int rd(){
	int x=0;char c=getchar();int f=1;
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
inline int getid(int x,int y,int z){
	return ((x-1)*B+(y-1))*C+z;
}
struct node{
	int a1,b1,c1,a2,b2,c2,val;
}at[maxn];
int d[maxn];
int m;
inline void up3(int a1,int b1,int c1,int a2,int b2,int c2,int val){
	s3[getid(a1,b1,c1)]+=val;
	s3[getid(a1,b1,c2+1)]-=val;
	return;
}
inline void up2(int a1,int b1,int c1,int a2,int b2,int c2,int val){
	up3(a1,b1,c1,a1,b1,c2,val);
	up3(a1,b2+1,c1,a1,b2+1,c2,-val);
	return;
}
inline void up1(int a1,int b1,int c1,int a2,int b2,int c2,int val){
	up2(a1,b1,c1,a1,b2,c2,val);
	up2(a2+1,b1,c1,a2+1,b2,c2,-val);
	return;
}
inline bool check(int T){
	memset(s1,0,sizeof(s1));memset(s2,0,sizeof(s2));memset(ans,0,sizeof(ans));memset(s3,0,sizeof(s3));
	for(int i=1;i<=T;i++)up1(at[i].a1,at[i].b1,at[i].c1,at[i].a2,at[i].b2,at[i].c2,at[i].val);
	for(int i=1;i<=A;i++){
		for(int j=1;j<=B;j++){
			for(int k=1;k<=C;k++)
			s2[getid(i,j,k)]=s2[getid(i,j,k-1)]+s3[getid(i,j,k)];
		}
	}
	memset(s3,0,sizeof(s3));
	for(int i=1;i<=A;i++){
		for(int j=1;j<=B;j++){
			for(int k=1;k<=C;k++){
				s3[getid(i,j,k)]=s3[getid(i,j-1,k)]+s2[getid(i,j,k)];
			}
		}
	}	
    for(int i=1;i<=A*B*C;i++)s2[i]=s3[i];
//	memset(s1,0,sizeof(s1));
//	for(int i=1;i<=A;i++){
//		for(int j=1;j<=B;j++){
//			for(int k=1;k<=C;k++){
//				s1[getid(i,j,k)]=s1[getid(i,j-1,k)]+s2[getid(i,j,k)];
//			}
//		}
//	}
//	for(int i=1;i<=A*B*C;i++)s2[i]=s1[i];
	for(int i=1;i<=A;i++)
		for(int j=1;j<=B;j++)
			for(int k=1;k<=C;k++){
			s2[getid(i,j,k)]+=s2[getid(i-1,j,k)];
	}
	for(int i=1;i<=A;i++){
		for(int j=1;j<=B;j++){
			for(int k=1;k<=C;k++){
				if(s2[getid(i,j,k)]>d[getid(i,j,k)])return 1;
			}
		}
	}
	return 0;
}
int main(){
	A=rd();B=rd();C=rd();m=rd();
	for(int i=1;i<=A*B*C;i++)d[i]=rd();
	for(int i=1;i<=m;i++){
		at[i].a1=rd();at[i].a2=rd();
		at[i].b1=rd();at[i].b2=rd();
		at[i].c1=rd();at[i].c2=rd();
		at[i].val=rd();
	}
	int l=0,r=m+1,mid;
	while(l+1!=r){
		mid=l+r>>1;
		if(!check(mid))l=mid;
		else r=mid;
	}
	printf("%d\n",r);
}
```

彩蛋：

可能是因为数据的锅或边界问题，数组大小开到 $10^7$ 都会越界访问，所以如果你把 s1,s2 和 ans 数组删掉，那么这份代码就过不了了

或者要把数组开到 $ 4 \times 10^7 $

但它报的是 WA 而不是 RE ，这玩意我从4月调到现在才知道。。。

ps：

因为函数调用太多的问题，这玩意跑得比容斥慢（笑）

但在高维情况下这个做法优势很大，具体去看 sosdp 相关内容，不多赘述

---

## 作者：Charles_with_wkc (赞：0)

# 思路
首先发现，轰炸次数越多，击中概率越大，可以枚举。
# 优化
很明显，这道题不可以直接暴力枚举会超时。这时候我们可以用**二分**优化算法，可是这也优化不了多少啊，这时候我们需要另外一个优化就是**三维差分**。  
所以本题核心为**二分和三维差分**。
# 二分
```cpp
int binary(int l,int r){
	int mid=0;
	while(l<=r){
		mid=(l+r)>>1;
		if(cheak(mid)) r=mid-1;
		else l=mid+1;
	}
	return l;
}
```
# 差分
一维差分
```cpp
c[s]+=h;
c[t+1]-=h;
```
二维差分
```cpp
c[sx][sy]+=h;
c[sx][ty+1]-=h;
c[tx+1][sy]-=h;
c[tx+1][ty+1]+=h;
```
三维差分
```cpp
c[sx][sy][sz]+=h;
c[tx+1][sy][sz]-=h;
c[sx][ty+1][sz]-=h;
c[sx][sy][tz+1]-=h;
c[sx][ty+1][tz+1]+=h;
c[tx+1][sy][tz+1]+=h;
c[tx+1][ty+1][sz]+=h;
c[tx+1][ty+1][tz+1]-=h;
```
但是，我们不确定 $A B C$ 的具体大小，只知道乘积，不可能开一个 $10^{6} \times 10^{6} \times 10^{6}$ 的数组，我们需要压维，是**三维转一维**。
# 三维转一维
二维转一维
```cpp
int zip(int x,int y){
	return (x-1)*B+y;
}
```
三维转一维
```cpp
int zip(int x,int y,int z){
	return (x-1)*B*C+(y-1)*C+z;
}
```
# 判断函数二分
首先我们 $mid$ 是指在第 $mid$ 次轰炸以后能否成立。    
因此我们需要存储每一个过程。
# 求三维差分
```cpp
c[zip(i,j,k)]=c[zip(i-1,j,k)]
			+c[zip(i,j-1,k)]
			+c[zip(i,j,k-1)]
    		-c[zip(i-1,j-1,k)]
			-c[zip(i-1,j,k-1)]
			-c[zip(i,j-1,k-1)]
    		+c[zip(i-1,j-1,k-1)]
			+c[zip(i,j,k)];
```
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N=2e6+5;
int A,B,C,m;
int c[N],a[N],sx[N],sy[N],sz[N],tx[N],ty[N],tz[N],h[N];
int zip(int x,int y,int z){
	return max(0ll,(x-1)*B*C+(y-1)*C+z);
}
void cf(int sx,int sy,int sz,int tx,int ty,int tz,int h){
	c[zip(sx,sy,sz)]+=h;
	c[zip(tx+1,sy,sz)]-=h;
	c[zip(sx,ty+1,sz)]-=h;
	c[zip(sx,sy,tz+1)]-=h;
	c[zip(sx,ty+1,tz+1)]+=h;
	c[zip(tx+1,sy,tz+1)]+=h;
	c[zip(tx+1,ty+1,sz)]+=h;
	c[zip(tx+1,ty+1,tz+1)]-=h;
	return ;
}
bool cheak(int mid){
	memset(c,0,sizeof(c));
	for(int i=1;i<=mid;i++) cf(sx[i],sy[i],sz[i],tx[i],ty[i],tz[i],h[i]);
	for(int i=1;i<=A;i++)
		for(int j=1;j<=B;j++)
			for(int k=1;k<=C;k++){
				c[zip(i,j,k)]=c[zip(i-1,j,k)]
							+c[zip(i,j-1,k)]
							+c[zip(i,j,k-1)]
				    		-c[zip(i-1,j-1,k)]
							-c[zip(i-1,j,k-1)]
							-c[zip(i,j-1,k-1)]
				    		+c[zip(i-1,j-1,k-1)]
							+c[zip(i,j,k)];
				if(c[zip(i,j,k)]>a[zip(i,j,k)]) return 1;
			}
	return 0;
}
int binary(int l,int r){
	int mid=0;
	while(l<=r){
		mid=(l+r)>>1;
		if(cheak(mid)) r=mid-1;
		else l=mid+1;
	}
	return l;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>A>>B>>C>>m;
	for(int i=1;i<=A;i++)
		for(int j=1;j<=B;j++)
			for(int k=1;k<=C;k++) cin>>a[zip(i,j,k)];
	for(int i=1;i<=m;i++) cin>>sx[i]>>tx[i]>>sy[i]>>ty[i]>>sz[i]>>tz[i]>>h[i];
	cout<<binary(1,m);
	return 0;
}
```

---

## 作者：_O_v_O_ (赞：0)

### 初步思想：

拿三维数组存，每次暴力加，在看所有战舰是否有爆炸的。

但这时间复杂度是 $O(A\times B\times C\times m)$，空间复杂度是 $({10^6})^3$（三维，每维是 $10^6$），明显会爆。

### 优化：

注意到题面“输入格式”里有一句话：

>第二行包含 $A\times B\times C$ 个整数，其中第 $((i-1)\times B+(j-1))\times C+(k-1)+1$ 个数为 $d(i,j,k)$。

我们就可以用这句话把数组压缩成一维的，原来 $d(x,y,z)$ 现在就是 $d_{((x-1)\times B+(j-1))\times C+(k-1)+1}$。

但这样子时间复杂度没变，还是会爆。

### 再优化：

我们可以参考 [P1083](https://www.luogu.com.cn/problem/P1083) 一题，用**二分答案**和在检查函数内用**差分**的方式。

借教室是一维差分，而这个是三维差分，只用把三维差分的数组按照上述防式转化成一维就行了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e7+5;
int a,b,c,m,d[N],cf[N];
int la[N],lb[N],lc[N],ra[N],rb[N],rc[N],h[N];

int QwQ(int x,int y,int z){
	return ((x-1)*b+(y-1))*c+z;
}

bool check(int x){
	memset(cf,0,sizeof(cf));
	for(int i=1;i<=x;i++){
		cf[QwQ(la[i],lb[i],lc[i])]+=h[i];
		cf[QwQ(ra[i]+1,lb[i],lc[i])]-=h[i];
		cf[QwQ(la[i],rb[i]+1,lc[i])]-=h[i];
		cf[QwQ(la[i],lb[i],rc[i]+1)]-=h[i];
		cf[QwQ(la[i],rb[i]+1,rc[i]+1)]+=h[i];
		cf[QwQ(ra[i]+1,lb[i],rc[i]+1)]+=h[i];
		cf[QwQ(ra[i]+1,rb[i]+1,lc[i])]+=h[i];
		cf[QwQ(ra[i]+1,rb[i]+1,rc[i]+1)]-=h[i];
	}
	for(int i=1;i<=a;i++){
		for(int j=1;j<=b;j++){
			for(int k=1;k<=c;k++){
				cf[QwQ(i,j,k)]+=cf[QwQ(i-1,j,k)]+cf[QwQ(i,j-1,k)]+cf[QwQ(i,j,k-1)]-cf[QwQ(i-1,j-1,k)]-cf[QwQ(i-1,j,k-1)]-cf[QwQ(i,j-1,k-1)]+cf[QwQ(i-1,j-1,k-1)];
				if(cf[QwQ(i,j,k)]>d[QwQ(i,j,k)]) return true;
			}
		}
	}
	return false;
}

signed main(){
	ios::sync_with_stdio(0);cin.tie(nullptr);
	cin>>a>>b>>c>>m;
	for(int i=1;i<=a;i++){
		for(int j=1;j<=b;j++){
			for(int k=1;k<=c;k++){
				cin>>d[QwQ(i,j,k)];
			}
		}
	}
	for(int i=1;i<=m;i++){
		cin>>la[i]>>ra[i]>>lb[i]>>rb[i]>>lc[i]>>rc[i]>>h[i];
	}
	int l=0,r=m+1;
	while(l+1<r){
		int mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid;
	}
	cout<<r;
	return 0;
}
```

upd：修改了代码。

---

## 作者：OIer_ACMer (赞：0)

# 自然选择，前进四！！！

注意：本题部分灵感来自[大佬的差分详解](https://blog.csdn.net/weixin_73470348/article/details/136085843?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-136085843.142^v100^pc_search_result_base4&spm=1018.2226.3001.4187)，以及素材和图片[另一位](https://blog.csdn.net/qq_63786973/article/details/127667301?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172131389416800226554645%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172131389416800226554645&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127667301-null-null.142^v100^pc_search_result_base4&utm_term=%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86&spm=1018.2226.3001.4187)，感兴趣的小伙伴可以点击链接去学习一下。

------------
## 题目解析

本题我们很容易发现，其实暴力没有什么用，主要是时间复杂度太高，那么，怎么办呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/8gnd8xwd.png)

很明显，我们要从三维差分着手，其实，三维差分和二位查分十分相似，根据容斥原理中的区间排斥的定义，我们可以将攻击范围扩展为图片的大小，尽管不是四倍大，**然后以二维差分为蓝本，将二维扩展纵向扩展，即可得出公式**。

![](https://cdn.luogu.com.cn/upload/image_hosting/31ffyf8v.png)

再说的通透点，我们其实可以找规律，一维是首位加，最后一位减，二维**则是在一维的基础之上，将横向与纵向的操作变为和一维的操作，然后再加上扩倍之后的未加上的部分（也就是奇偶相加）**，而三维呢，其实就是在二维的基础上，从上图中的黑色块着手，**将黑色块作为每一层的起始点，蓝色木块为当前层的起始点，同时将一整个木块分成 $k$ 层，每一层进行计算，之后就像二维差分一样，对横的和竖着的行和列进行二维差分操作**，最后，从最底层依次向上加，我们可以推导出是奇加偶减。由此，我们根据容斥原理，发现三维的是奇加偶减，可得三维差分公式。

最后，再说几个点，一个是我们如果多维数组不好操作，我们可以利用题目中的公式，也就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/2m8js6vo.png)

写一个函数封装起来，方便我们利用。同时，我们可以在最后分开计算每一艘战舰的血量值，分开有利于我们调试代码。

最后的最后，一定要用二分，不然就会直接爆零！！！

------------
## 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 2e6 + 10;
int A, B, C, m;
int s[N], b[N], op[N / 2][7], tmp[N];
int id(int i, int j, int k)
{
    return (i * B + j) * C + k;
}
void pre(int x1, int x2, int y1, int y2, int z1, int z2, int c)
{
    b[id(x1, y1, z1)] += c;
    b[id(x1, y1, z2 + 1)] -= c;
    b[id(x1, y2 + 1, z1)] -= c;
    b[id(x1, y2 + 1, z2 + 1)] += c;
    b[id(x2 + 1, y1, z1)] -= c;
    b[id(x2 + 1, y1, z2 + 1)] += c;
    b[id(x2 + 1, y2 + 1, z1)] += c;
    b[id(x2 + 1, y2 + 1, z2 + 1)] -= c;
}
void jian(int x1, int x2, int y1, int y2, int z1, int z2, int c)
{
    tmp[id(x1, y1, z1)] -= c;
    tmp[id(x1, y1, z2 + 1)] += c;
    tmp[id(x1, y2 + 1, z1)] += c;
    tmp[id(x1, y2 + 1, z2 + 1)] -= c;
    tmp[id(x2 + 1, y1, z1)] += c;
    tmp[id(x2 + 1, y1, z2 + 1)] -= c;
    tmp[id(x2 + 1, y2 + 1, z1)] -= c;
    tmp[id(x2 + 1, y2 + 1, z2 + 1)] += c;
}

bool check(int mid)
{
    memcpy(tmp, b, sizeof b);
    for (int i = 0; i < mid; i++)
    {
        int x1 = op[i][0], x2 = op[i][1], y1 = op[i][2], y2 = op[i][3], z1 = op[i][4], z2 = op[i][5], c = op[i][6];
        jian(x1, x2, y1, y2, z1, z2, c);
    }
    memset(s, 0, sizeof s);
    for (int i = 1; i <= A; i++)
    {
        for (int j = 1; j <= B; j++)
        {
            for (int k = 1; k <= C; k++)
            {
                s[id(i, j, k)] = tmp[id(i, j, k)] + s[id(i - 1, j, k)] + s[id(i, j - 1, k)] - s[id(i - 1, j - 1, k)] + s[id(i, j, k - 1)] - s[id(i - 1, j, k - 1)] - s[id(i, j - 1, k - 1)] + s[id(i - 1, j - 1, k - 1)];
                if (s[id(i, j, k)] < 0)
                {
                    return true;
                }
            }
        }
    }
    return false;
}
int main()
{
    cin >> A >> B >> C >> m;
    for (int i = 1; i <= A; i++)
    {
        for (int j = 1; j <= B; j++)
        {
            for (int k = 1; k <= C; k++)
            {
                cin >> s[id(i, j, k)];
                pre(i, i, j, j, k, k, s[id(i, j, k)]);
            }
        }
    }
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < 7; j++)
        {
            cin >> op[i][j];
        }
    }
    int l = 1, r = m, ans = 0;
    while (l <= r)
    {
        int mid = l + r >> 1;
        if (check(mid))
        {
            ans = mid;
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    cout << ans << endl;
    return 0;
}


```

---

## 作者：Frictional (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P8666)

## 题意
有一个 $A\times B\times C$ 的立方体。其中的每个点都有一个防御力  $d$。有 $m$ 次操作，每次操作给你左上角和右下角的坐标（三维的），给其间的所有数都减掉上 $h$。求第一次有数变成非正数是第几次操作。
## 思路
这道题先想到的是三维差分，但我调了 1 个多小时一直 RE。突然发现数据只保证了 $A\times B\times C\leqslant 1\times 10^6$ 但没保证 $A,B,C$ 的值的范围，所以我 RE 了。于是，就把三维转化成一维就好了。实际上还是三维的，就像输入那样。通过题面中的 $((i-1)\times B+(j-1))\times C+(k-1)+1$ 可以把三维的转换成一维的。

之后，我们可以二分答案来二分第几次操作的时候第一次有战舰爆炸。如果没有战舰爆炸就左端点拓展，否则右端点拓展。二分经常写挂的可以去看看这个[视频](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=26426bc8969fc4f270d77361c9850948)，讲的很详细。
## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
using namespace std;
int rd(){
    int x=0,f=1; 
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
const int M=2e6+6;
int l,r,mid;
int a,b,c,m;
int f[M];
int la[M],ra[M],lb[M],rb[M],lc[M],rc[M];
int h[M],cf[M];
int three_one(int x,int y,int z){
	if(x>a||y>b||z>c)return 0;
	return ((x-1)*b+y-1)*c+z;
}
bool pre(){
    FOR(i,1,a) FOR(j,1,b) FOR(k,1,c) cf[three_one(i,j,k+1)]+=cf[three_one(i,j,k)];
    FOR(i,1,a) FOR(k,1,c) FOR(j,1,b) cf[three_one(i+1,j,k)]+=cf[three_one(i,j,k)]; 
    FOR(j,1,b) FOR(k,1,c) FOR(i,1,a) cf[three_one(i,j+1,k)]+=cf[three_one(i,j,k)]; 
    FOR(i,1,a*b*c)
		if(cf[i]>f[i])return 1;
	return 0;
}
bool judge(int x){
	memset(cf,0,sizeof(cf));
	for(int i=1;i<=x;i++){
        cf[three_one(la[i],lb[i],lc[i])]+=h[i];
        cf[three_one(ra[i]+1,lb[i],lc[i])]-=h[i];
        cf[three_one(la[i],lb[i],rc[i]+1)]-=h[i];
        cf[three_one(ra[i]+1,lb[i],rc[i]+1)]+=h[i];
        cf[three_one(la[i],rb[i]+1,lc[i])]-=h[i];
        cf[three_one(ra[i]+1,rb[i]+1,lc[i])]+=h[i];
        cf[three_one(la[i],rb[i]+1,rc[i]+1)]+=h[i];
        cf[three_one(ra[i]+1,rb[i]+1,rc[i]+1)]-=h[i];
	}
	return pre();
}
signed main(){
    cin>>a>>b>>c>>m;
    FOR(i,1,a*b*c) cin>>f[i];
    FOR(i,1,m) cin>>la[i]>>ra[i]>>lb[i]>>rb[i]>>lc[i]>>rc[i]>>h[i];
    l=0,r=m+1;
    while(l+1!=r){
        mid=(l+r)/2;
        if(judge(mid)) r=mid;
        else l=mid;
    }
    cout<<r;
    return 0;
}

```


---


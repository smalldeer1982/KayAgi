# [蓝桥杯 2020 省 AB1] 网络分析

## 题目描述

小明正在做一个网络实验。

他设置了 $n$ 台电脑，称为节点，用于收发和存储数据。

初始时，所有节点都是独立的，不存在任何连接。

小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信了。两个节点如果存在网线连接，称为相邻。

小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储下来。一条信息只存储一次。

给出小明连接和测试的过程，请计算出每个节点存储信息的大小。

## 说明/提示

对于 $30\%$ 的评测用例，$1 ≤ n ≤ 20$，$1 ≤ m ≤ 100$。

对于 $50\%$ 的评测用例，$1 ≤ n ≤ 100$，$1 ≤ m ≤ 1000$。

对于 $70\%$ 的评测用例，$1 ≤ n ≤ 1000$，$1 ≤ m ≤ 10000$。

对于所有评测用例，$1 ≤ n ≤ 10000$，$1 ≤ m ≤ 10^5$ ，$1 ≤ t ≤ 100$。

蓝桥杯 2020 第一轮省赛 A 组 J 题（B 组 J 题）。

## 样例 #1

### 输入

```
4 8
1 1 2
2 1 10
2 3 5
1 4 1
2 2 2
1 1 2
1 2 4
2 2 1```

### 输出

```
13 13 5 3```

# 题解

## 作者：Yashajin_Ai (赞：16)

发现一个性质：最多只会合并 $n-1$ 次（类似树只有 $n-1$ 条边）。

于是在合并的时候暴力统计即可。

时间复杂度 $O(n^2+m)$。

建议使用路径压缩和启发式合并。

```cpp
# include <bits/stdc++.h>
using namespace std;
const int N=10000;
int f[N+10],siz[N+10];
int find(int x){
	if(f[x]==x){
		return x;
	}
	return f[x]=find(f[x]);
}
int val [N + 10], ans [N + 10];
int main () {
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		f[i]=i;
		siz[i]=1;
	}
	while(m--){
		int op,x,y;
		cin>>op>>x>>y;
		switch(op){
			case 1:{
				x=find(x);
				y=find(y);
				if(x!=y){
					for(int i=1;i<=n;++i){
						ans[i]+=val[find(i)];
					}
					for(int i=1;i<=n;++i){
						val[i]=0;
					}
					if(siz[x]>siz[y]) {
						swap(x,y);
					}
					f[x]=y;
					siz[y]+=siz[x];
				}
				break;
			}
			case 2:{
				x=find(x);
				val[x]+=y;
				break;
			}
		}
	}
	for(int i=1;i<=n;++i) {
		cout<<ans[i]+val[find(i)]<<" ";
	}
	return 0;
}
```

---

## 作者：jijidawang (赞：8)

既然开题解了我肯定要宣传重标号啊！

最开始我给一道题想了这个重标号（然而后面假了变成了 P8969），给 joke3579 看了一眼，然后拿这个问 Kaguya，Kaguya 直接就把这个重标号给看出来了，很强啊 .

***

只有连边操作，考虑将结点重新标号使得任意时刻同一连通块内结点标号连续 .

一种做法是首先把询问离线下来跑一遍，先用并查集维护，每个并查集维护集合内元素的一个双向链表，只需要记头指针和尾指针，合并两个并查集的时候按顺序连上指针，最后遍历一遍链表即完成重标号，重复此过程即可得到每个时刻连通块表示的区间 .

另一种做法是同样先把首先把询问离线下来跑一遍，也是先用并查集维护，合并两个集合 $A,B$ 时，首先找到并查集中 $A,B$ 表示的结点 $a,b$，然后建一个虚拟点 $u$，连 $(a,u),(b,u)$，则形成的树的 DFS 序即为重标号序（有点 Kruskal 重构树的感觉）（这个是 Kaguya 提出的）.

以上方法已经把问题变为序列上的问题，差分即可解决 .

时空复杂度 $\Theta(n+q)$ .

代码如下：
```cpp
const int N = 222222;
int n, q, a[N], nxt[N], lst[N], id[N];
bool uok[N];
struct Query{int opt, u, v;}que[N];
struct dsu
{
	int fa[N];
	dsu(){clear();}
	int get(int x){return x == fa[x] ? x : fa[x] = get(fa[x]);}
	inline void merge(int u, int v)
	{
		u = get(u); v = get(v);
		if (u == v) return ;
		nxt[lst[u]] = v; lst[u] = lst[v];
		fa[v] = u;
	}
	inline void clear(){iota(fa, fa+N, 0);}
}D;
int main()
{
	scanf("%d%d", &n, &q);
	memset(nxt, -1, sizeof nxt); iota(lst, lst+1+n, 0);
	for (int i=1; i<=q; i++)
	{
		scanf("%d%d%d", &que[i].opt, &que[i].u, &que[i].v);
		if (que[i].opt == 1) D.merge(que[i].u, que[i].v);
	}
	for (int i=1; i<=n; i++) uok[nxt[i]] = true;
	int cc = 0;
	for (int i=1; i<=n; i++)
	{
		if (uok[i]) continue;
		int u = i; id[u] = ++cc;
		while (~nxt[u]){u = nxt[u]; id[u] = ++cc;}
	}
	D.clear(); memset(nxt, -1, sizeof nxt); iota(lst, lst+1+n, 0);
	for (int i=1; i<=q; i++)
	{
		if (que[i].opt == 1) D.merge(que[i].u, que[i].v);
		else{int L = D.get(que[i].u), R = lst[L]; a[id[L]] += que[i].v; a[id[R] + 1] -= que[i].v;}
	}
	for (int i=1; i<=n; i++) a[i] += a[i-1];
	for (int i=1; i<=n; i++) printf("%d ", a[id[i]]);
	puts("");
	return 0;
}
```

---

## 作者：Maysoul (赞：6)

提供一种拓扑排序+并查集的解法。

## 简化题意：

给定两种操作：

1. 将两个点纳入一个连通块。

2. 将这个点所在的连通块的值 $+t$。

## 简述思路：

第一种操作自然让人想到并查集，重点看第二种操作。

我们想要对一整块序列都进行加和操作，回想我们之前学到过的数据结构，对于区间的操作下，可以通过维护懒标记来简化操作。

同理，我们大概也能把所需要加的值放在一个点上，等到必要的时候下放。

我们知道，并查集是一种树形结构，对于每一个并查集的合并，实际上是对根节点的嫁接，所以我们可以把懒标记先放在根节点上。

什么时候下放懒标记呢？最后结算答案的时候当然要下放。

那么中间操作的时候什么时候下放呢？我们可以思考合并的过程。前文已经提到，并查集的合并，是一个根节点接到另一个根节点上，那么新成为的那个根节点，下放标记的时候，显然不能传递到新增的那些节点上。所以我们要在合并之前，将即将成为新根节点的节点下放。

为了便于操作，我们直接把并查集的结构直接存成一个自根节点向下的有向图，然后，我们借助并查集将环结构略去，这样就成了一个 DAG。

发现这个性质之后，我们在最后直接拓扑排序下放懒标记即可。

```cpp
//2023/9/23
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num,ans;
int fa[MAXN];
int find(int x)
{
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);
}
struct linkstar{
	int from,to,next;
}edge[2*MAXN];
struct node{
	int mark,val;
	node(){mark=val=0;}
}point[MAXN];
int escnt,n,m;
int head[MAXN],du[MAXN];
void add(int from,int to)
{
	edge[++escnt].from=from;
	edge[escnt].to=to;
	edge[escnt].next=head[from];
	head[from]=escnt;
}
void pushdown(int x)//下放懒标记
{
	for (int i=head[x];i!=-1;i=edge[i].next){
		int y=edge[i].to;
		point[y].mark+=point[x].mark;
		point[y].val+=point[x].mark;
	}
	point[x].mark=0;
}
void toposort()//拓扑排序下放
{
	queue<int> que;
	for (int i=1;i<=n;i++){
		if(du[i]==0) que.push(i);
	}
	while(!que.empty()){
		int x=que.front();
		que.pop();
		for (int i=head[x];i!=-1;i=edge[i].next){
			int y=edge[i].to;
			du[y]--;
			point[y].mark+=point[x].mark;
			point[y].val+=point[x].mark;
			if(du[y]==0) que.push(y);
		}
		point[x].mark=0;
	}
}
int main()
{
	std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	memset(head,-1,sizeof(head));
	cin>>n>>m;
	int opt,p,t;
	for (int i=1;i<=n;i++) fa[i]=i;
	for (int i=1;i<=m;i++){
		cin>>opt>>p>>t;
		if(opt==1){
			t=find(t),p=find(p);
			if(t==p) continue;//取消环的影响
			if(t<p) swap(t,p);
			fa[t]=p;
			du[t]++;
			pushdown(p);//下放新根节点的懒标记
			add(p,t);//直接建立树形结构，便于拓扑排序
		}
		if(opt==2){
			p=find(p);//维护当前块的懒标记
			point[p].mark+=t;
			point[p].val+=t;
		}
	}
	toposort();
	for (int i=1;i<=n;i++) cout<<point[i].val<<" ";
	return 0;
}
```




---

## 作者：strcmp (赞：5)

题目大意：给定 $n$ 个元素和 $m$ 个操作，每次操作有两种情况：

- `1 x y` 将 $x$ 元素和 $y$ 元素**所在的联通块合并。**

- `2 x y` 将 $x$ 所在的联通块的所有元素加 $y$。

### Solution

首先，排除掉 Top-tree、ETT 等一系列不正常做法，似乎很像并查集，考虑只用并查集怎么做。

考虑带权并查集，显然我们**需要维护各个联通块之间的父子关系**，否则如果父子关系乱序，就会导致我们难以取出每个修改操作所影响到的结点。而路径压缩会破坏原并查集父子关系，不方便处理这个信息。考虑启发式合并优化，可以做到在 $\Theta(n \log_2 n)$ 的时间复杂度完成并查集的所有操作且不会破坏父子关系。

这样我们就有了一个**初步的想法：** 使用启发式合并优化并查集，**对每个结点维护 $\operatorname{tge}$ 表示其懒标记**，同时用左儿子右兄弟表示法维护每个结点的儿子，修改时直接修改懒标记，合并直接合并。最后直接搜索将懒标记递归下去即可。

可惜最后我们发现，这个做法将样例中的第三个元素的值错误的输出了。

观察出问题的地方：

![](https://cdn.luogu.com.cn/upload/image_hosting/ducj48q8.png)

可以看到，如果父亲 $b$ 之前已经有过一个懒标记了，则如果我们不 pushdown 下去这个懒标记，那么这个懒标记就会“污染”合并上来的 $a$，导致答案偏大。

很显然我们可以直接 pushdown 结点 $b$，但可惜的是**并查集中结点的儿子数量没有限制**，所以如果直接暴力 pushdown 结点 $b$ 会被 

```
2 1 1
1 1 2
2 2 1
1 2 3
...
2 i 1
1 i i+1
```

这样的数据卡 T 飞，显然不能这样做。

upd：实际上可以在结点 $a$ 上打一个减法标记减去多的值，但是四周看了一眼基本都是这个做法，~~所以后面的就当做提供一个新做法了~~。

换一种想法，考虑减少其儿子数量。

考虑像 $\text{Kruskal}$ 重构树一样每次合并时增加虚点 $u$，每次合并 $a,b$ 所在的联通块，其左儿子维护 $a$，右儿子维护 $b$ 即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/3g08uvbn.png)

此时将不再出现懒标记的污染现象。

这样每次合并直接在并查集上查找虚点，然后合并即可。

现在出现了一个小问题：合并的次数最多是 $\Theta(m)$ 的，而增加虚点破坏了启发式优化下的并查集高度 $\Theta(\log_2 n)$ 的上限，这样很容易被单链的数据卡死。

实际上，我们不需要显性的维护虚树，在每个并查集的根结点上维护虚点根节点即可。对每个结点，查找出其根节点维护的虚点根节点，直接递归下传懒标记，时间复杂度 $\Theta((n+m) \log_2 n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
#define re register
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
int fa[maxn], ls[maxn], rs[maxn], siz[maxn], vf[maxn], cnt, n, m; ll tge[maxn];
//真实父亲；虚点左儿子，右儿子；启发式合并维护的结点子树数目；虚树根结点和结点数目
//tge 为懒标记
int find(int x) {
    if (!fa[x])return x;
    else return find(fa[x]);
    //不能写 fa[x] = find(fa[x])，否则会破坏父子关系
}
inline void merge(int x, int y) {
    x = find(x); y = find(y); 
    if (x == y)return;
    if (siz[x] < siz[y])swap(x, y);
    fa[y] = x; siz[x] += siz[y]; 
    //启发式合并过程
    int u = ++cnt; ls[u] = vf[x]; rs[u] = vf[y];
    vf[x] = vf[y] = u; 
    //维护虚点
}
void dfs(int u) {
    if (u <= n)return;
    tge[ls[u]] += tge[u];
    tge[rs[u]] += tge[u]; tge[u] = 0;
    dfs(ls[u]); dfs(rs[u]);
    //直接在虚点上递归即可
}
int vis[maxn];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(); cout.tie(); cin >> n >> m; cnt = n;
    for (int i = 1; i <= n; i++)siz[i] = 1, vf[i] = i; int x, a, b;
    for (int i = 1; i <= m; i++) {
        cin >> x >> a >> b;
        if (x == 1)merge(a, b);
        else {
            int p = vf[find(a)];
            tge[p] += (ll)b;
        }
    }
    for (int i = 1; i <= n; i++) { 
        int f = vf[find(i)];
        if (!vis[f])dfs(f), vis[f] = 1;
        //显然不能重复递归一个虚根结点
    }
    for (int i = 1; i <= n; i++)cout << tge[i] << " ";
    return 0;
}
```


---

## 作者：Chenyichen0420 (赞：3)

## 思路分析

下传懒标记。一种神奇的并查集写法。

我们在每个并查集的代表节点上记录一个值，表示这一坨存有多大的数据。

而很显然，我们合并的时候，如果令 $f_l=r$ 的话，那我们就令 $v_l-=v_r$，最后再跑一遍树上前缀和不就是答案了吗？

所以为什么非得减一下呢？是因为只有在合并之后父节点的增量才是你也有的增量。之前的影响不应被计入。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, f[10005], v[10005], sz[10005], ans[10005]; vector<int>son[10005];
inline int find(int p) {
	return f[p] ? find(f[p]) : p;
}
inline void merge(int l, int r) {
	l = find(l); r = find(r);
	if (l == r) return;
	if (sz[l] < sz[r]) swap(l, r);
	sz[l] += sz[r]; sz[r] = 0;
	f[r] = l; v[r] -= v[l];
}
inline void dfs(int p, int d) {
	ans[p] = d + v[p];
	for (int sp : son[p]) dfs(sp, ans[p]);
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) sz[i] = 1;
	for (int i = 1, t, l, r; i <= m; ++i)
		if (cin >> t >> l >> r, t & 1)
			merge(l, r);
		else v[find(l)] += r;
	for (int i = 1; i <= n; ++i)
		son[f[i]].emplace_back(i);
	dfs(0, 0);
	for (int i = 1; i <= n; ++i) cout << ans[i] << " ";
}
```

---

## 作者：piano_pei (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P8710)

### 思路

使用并查集，设 $qwq_i$ 为 $i$ 的权值。

每次操作 $2$，都在根上的 $qwq$ 加，不难发现这样处理会算重一部分，所以我们需要每次合并的时候新建一个根节点，这样 $qwq$ 为 $0$。$i$ 的答案就是 $i$ 到根的 $qwq$ 之和。这样做虽然看似 $O((n+m)\log n)$，但实际上会退化到 $O(n^2+m)$， 能骗 $80pts$。

正解很简单，不用新建结点，把 $qwq$ 算重的那部分在合并的时候减掉就行，然后就能启发式合并了，复杂度 $O((n+m)\log n)$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
const int N = 2e4 + 10;
int f[N], siz[N], qwq[N], n, m, sumn;
il int find(int x)
{
	if(f[x] != x) return find(f[x]);
	return x;
}
il int F(int x)
{
	if(f[x] == x) return qwq[x];
	return qwq[x] + F(f[x]);
}
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= n;++i)
		f[i] = i, siz[i] = 1;
	int op, x, y;
	while(m--)
	{
		scanf("%d%d%d", &op, &x, &y);
		if(op == 1)
		{
			int r1 = find(x), r2 = find(y);
			if(r1 == r2) continue;
			if(siz[r1] > siz[r2]) f[r2] = r1, qwq[r2] -= qwq[r1], siz[r1] += siz[r2];
			else f[r1] = r2, qwq[r1] -= qwq[r2], siz[r2] += siz[r1];
		}
		else
			qwq[find(x)] += y;
	}
	for(int i = 1;i <= n;++i)
		cout << F(i) << " ";
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：2)

我选择用 `bitset` 维护集合，用并查集合并。

然后根据树只有 $n-1$ 条边，所以**有效合并**只有 $O(n)$ 次。

如果查询操作都在修改操作后面，我们可以直接把每个点的储存信息的大小都存在并查集根节点上。

这样对于一个点的查询，可以直接找并查集根节点的答案。

如果修改在中间怎么办。

拆！拆成 $O(n)$ 个没有有效合并的小段。

对于小段，可以直接像我们那样处理。

对于每次**有效合并**，小段结束，我们支持 $O(n)$ 的统计答案。

于是做完了，题解区应该是最简短的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,fa[10010],ans[10010],w[10010];
inline int find(int x){return x==fa[x] ? x : fa[x]=find(fa[x]);}
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
	while(m--){
		int opt,x,y;
		cin>>opt>>x>>y;
		if(opt==1 && x!=y){
			for(int i=1;i<=n;i++) ans[i]+=w[find(i)];
			memset(w,0,sizeof w),fa[find(y)]=find(x);
		}
		if(opt==2) w[find(x)]+=y;
	}
	for(int i=1;i<=n;i++) cout<<ans[i]+w[find(i)]<<" ";
	return 0;
}
```

---

## 作者：lzj666_luogu (赞：2)

一个比较直接的想法：我们看见连通块整体加，所以我们可以直接写一个带权并查集。

但是一个比较好的问题是该怎么给它赋权，所以想到令一个节点的权值加上它到根这一条链的权值为它的真实权值。然后每次加就是在根节点加就行了，路径压缩时特判是不是根下面第一个。最后输出时先路径压缩一下，它到根的链就是只有它自己和根了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N = 1e6 + 10, M = 1e6 + 10;
int fa[N], t[N];
int find(int x) {
	if (fa[x] == x) return x;
	int k = fa[x], ret = find(fa[x]);
	if (k ^ ret) t[x] += t[k];
	return fa[x] = ret;
}
signed main() {
	cin.tie(0)->sync_with_stdio(false);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) fa[i] = i;
	while (m--) {
		int opt, a, b;
		cin >> opt >> a >> b;
		if (opt == 1) {
			int x = find(a), y = find(b);
			if (x ^ y) t[x] -= t[y];
			fa[x] = y;
		}
		else t[find(a)] += b;
	}
	int l;
	for (int i = 1; i <= n; ++i) {
		l = find(i);
		cout << (i ^ l ? t[l] : 0) + t[i] << ' ';
	}
	return 0;
}
```

---


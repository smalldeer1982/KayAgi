# [蓝桥杯 2020 省 AB2] 字串排序

## 题目描述

小蓝最近学习了一些排序算法, 其中冒泡排序让他印象深刻。

在冒泡排序中, 每次只能交换相邻的两个元素。

小蓝发现, 如果对一个字符串中的字符排序, 只允许交换相邻的两个字符, 则在所有可能的排序方案中, 冒泡排序的总交换次数是最少的。

例如, 对于字符串 lan 排序, 只需要 $1$ 次交换。对于字符串 qiao 排序, 总共需要 $4$ 次交换。

小蓝的幸运数字是 $V$, 他想找到一个只包含小写英文字母的字符串, 对这个串中的字符进行冒泡排序, 正好需要 $V$ 次交换。请帮助小蓝找一个这样的字符串。如果可能找到多个, 请告诉小蓝最短的那个。如果最短的仍然有多个, 请告诉小蓝字典序最小的那个。请注意字符串中可以包含相同的字符。


## 说明/提示

对于 $30 \%$ 的评测用例, $1 \leq V \leq 20$。

对于 $50 \%$ 的评测用例, $1 \leq V \leq 100$。

对于所有评测用例, $1 \leq V \leq 100000$。

蓝桥杯 2020 第二轮省赛 A 组 J 题（B 组 J 题）。

## 样例 #1

### 输入

```
4```

### 输出

```
bbaa```

## 样例 #2

### 输入

```
100```

### 输出

```
jihgfeeddccbbaa```

# 题解

## 作者：梅子酒 (赞：10)

根据题目意思，我们构造的字符串需要满足冒泡排序交换次数为 $V$ 次，越短越好的情况下输出字典序最小的那一个。于是我们先从字符串的长度开始考虑。

1. 如何求字符串的最短长度是多少

设字符串长度为 $len$，若该长度的字符串能构造出的最大交换数 $\geq V$，就代表该长度的字符串一定能恰好构造出交换数为 $V$ 的。于是我们首先要求的是长度为 $i$ 的字符串能构造出的的最大交换数 $f_i$ 是多少。

在求最大交换数之前，我们需要知道冒泡排序的一个性质：最大交换数 $=$ 逆序对的个数（下文中就用逆序对数代替最大交换数），长度 $len \leq 26$ 的字符串的最大构造方法显然是前 $len$ 个字符按逆序排列，这样逆序对的个数就是 $f_{len} = len \cdot (len - 1) / 2$，这样构造的最大交换数在 $len = 26$ 时取得 $f_{26} = 325$。当要求的逆序对数 $\geq 325$ 时怎么办呢？我们考虑字符串的长度每增加一个字符相当于在任意位置插入一个字符，那么最多能得到的新增逆序对数为：原字符串中与新增字符不同的字符个数。

例如：$\verb!cbbaa!$ 新增一个字符，显然是插入一个 $\verb!c!$ 在原来的 $\verb!c!$ 周围最优。我们可以得出结论：**字符串中所有字符数量越接近越好，在字符数 $\geq 26$ 以后就又是以 $\verb!abc!$ 的顺序开始新增（满足字典序小），每次插入新字符增加的逆序对即为原字符长度 $-$ 与自己相等的字符数量。**

我们可以递推求解长度为 $i$ 的字符串能构造的最大逆序对数为 $f_i$。在确定最短长度后开始考虑其他条件。

2. 如何使得字符串中的逆序对个数恰好为 $V$ 的同时，使得字典序最小

同样利用上述构造最大逆序对的贪心策略，我们从前向后暴力枚举该位的字符（从 $\verb!a!$ 开始枚举，满足字典序最小），剩下的字符按照逆序对最大的方法进行构造能否使得逆序对数 $f_i \geq V$，如果能就选定该字符，否则就枚举紧接着的下一位字符（具体见代码及注释）。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
/*  
贪心的思想，增加字符串长度相当于插入一个字符，增加的逆序对 = 大于自己 + 小于自己的，
最大构造逆序对的情况即不等于自己的字符数，于是有字符串中所有字符数量越接近越好，
在字符数 > 26 以后就又是从abc的顺序开始新增（满足字典序小）,每次插入新字符增加的逆序对即为原字符长度 - 与自己相等的字符数量
于是我们可以暴力枚举字符，判断在选择此字符的情况下能否构造出逆序对数 >= n的
*/
int f[1010];
int get_max(){ // 获取长度为m的字符串的最大逆序对数
    for(int i = 2; i <= 26; i ++) f[i] = f[i - 1] + i - 1; // 长度小于26的字符串最大逆序对数
    int sum = 26, vis[30];
    for(int i = 0; i < 26; i ++) vis[i] = 1; // 记录当前字符串已经各个字符串各一个了
    for(int i = 27; f[i - 1] < n; i ++, sum ++){ 
        int ch = (i % 26 - 1 + 26) % 26; // 新增的字符按abc……的顺序新增，插入到逆序的位置，例如zyx……a,下一个接着插入a zyx……aa
        f[i] = f[i - 1] + sum - vis[ch]; vis[ch] ++; //新增逆序对字符总数 - 和自己相同的字符数
    }
}

int cnt[30], vis[30]; // cnt 代表已经确定的构造字符，vis代表后续按最大方法构造的字符
int get_add(int ch){
    int add = 0;
    for(int i = 0; i < ch; i ++) add += vis[i]; // vis 是还未确定的可以按任意顺序排列所以都可以计算进来
    for(int i = ch + 1; i < 26; i ++) add += cnt[i] + vis[i]; // 因为cnt已经确定了，后续字符只能在其后，所以新增的只能是 > ch 的字符数
    return add; 
}
bool check(int id, int m, int ch, int sum){
    for(int i = id + 1; i <= m; i ++){
        int maxadd = 0, ch1 = 0;
        for(int j = 0; j < 26; j ++){ // 和上述fi的求解过程同理，只是枚举字符选择最优解的那一个
            int add = get_add(j);
            if(maxadd < add){
                maxadd = add;
                ch1 = j;
            }
        }
        vis[ch1] ++;
        sum += maxadd;
    }
    memset(vis, 0, sizeof vis);
    if(sum >= n) return true; // 当剩余字符能构造出 >= n 的即返回true
    return false;
}

void solve(int m){
    int sum = 0;
    string ans;
    for(int i = 1; i <= m; i ++){
        for(int j = 0; j < 26; j ++){ // 每个位置都从'a' 开始枚举，看是否剩下的字符最大情况下仍然能构造出大于等于n的字符，若可以则使用当前的ch
            int initadd = get_add(j);
            cnt[j] ++;
            sum += initadd;
            if(check(i, m, j, sum)){
                ans += ('a' + j);
                break;
            }
            cnt[j] --; // 不满足，于是回溯枚举新的字符
            sum -= initadd;
        }
    }
    cout << ans;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);

    cin >> n;
    get_max();
    for(int i = 2; i <= n; i ++){
        if(f[i] >= n){
            solve(i);
            break;
        }
    }
    return 0;
}
```

一个贪心的构造题，使用暴力的方法实现，思维确实挺巧妙的。

---

## 作者：huyangmu (赞：9)

这道题的意思可以简化为：找一个逆序对个数为 $V$ 的字典序最小的字符串。

这个问题可以转化为两个小问题来解决：先找到满足要求的字符串的最小长度，再往字符串里面填字母，确定字典序最小的字符串。

对于第一个问题，我们可以尝试找规律，如果要插入一个字符，使得字符串 `ccbba` 逆序对个数最多，应该在最后面插入一个 `a`。如果要插入一个字符，使得字符串 `cbbaa` 逆序对个数最多，应该在最前面插入一个 `c`。

我们可以发现一个规律，如果要让一个长度为 $len$ 的字符串逆序对最大，应该让每个字符出现的次数差不多多。又因为题目要求字典序最小，所以出现次数多的字母字典序肯定较小，出现次数为 $len \div 26 + 1$ 的字母共有 $len\bmod 26$ 个，形成的逆序对个数为 $len - (len \div 26 + 1)$ 个，出现次数为 $len \div 26$ 的字母共出现 $26 - (len \bmod 26)$ 个，形成的逆序对个数为 $len - (len \div 26)$ 个，所以长度为 $len$ 的字符串形成的最多逆序对个数的公式就推出来了。

```cpp

int tmp = ((x - (x / 26 + 1)) * (x / 26 + 1) * (x % 26) + (x - x / 26) * (x / 26) * (26 - x % 26) ) >> 1;
```

求出了长度之后我们可以从 $1$ 到 $len$ 枚举每个位置，对于每一个位置从小到大枚举每个字母，并判断当前位置放这个字母是否可行。

如何判断呢？设当前位置为 $pos$，我们要先计算出从 $1$ 到 $pos-1$ 形成的逆序对个数，再求出当前位置放字母 $j$ 形成的逆序对个数，后面的 $len-j$ 个位置最多能产生的逆序对个数。

如果三者加起来超过了 $v$ 则可行，前面位置形成的逆序对的和加上当前位置形成的逆序对数量，否则不可行。

### AC Code
```cpp

#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n,tmp = 1,sum3 = 0;
string s = "";
map <int,int> mp;
map <int,int> mp2;
bool check (int x){
	int tmp = ((x - (x / 26 + 1)) * (x / 26 + 1) * (x % 26) + (x - x / 26) * (x / 26) * (26 - x % 26) ) >> 1;
	return tmp < n;	
}
bool check2 (int x,int len){
	mp2.clear();
	int sum1 = 0,sum2 = 0;
	for (int i = 26; i >= x + 1; --i) sum1 += mp[i];
	++mp[x];
	for (int i = 1; i <= len; ++i){
		int maxn = -1,pos,sum = 0;
		for (int j = 26; j >= 1; --j){
			if (i - 1 - mp2[j] + sum > maxn){
				maxn = i - 1 - mp2[j] + sum;
				pos = j;
			} 
			sum += mp[j];
		}
		sum2 += maxn;
		++mp2[pos];
	}
	int tmp = sum1 + sum2 + sum3;
	if (tmp >= n){
		sum3 += sum1;
		return 1;
	}else{
		--mp[x];
		return 0;
	}
}
signed main (){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n;
	while (check(tmp)) ++tmp;
//	cout << tmp << '\n';
	for (int len = 1; len <= tmp; ++len){
		for (int i = 1; i <= 26; ++i){
			if (check2(i,tmp - len)){
				char x = char (i + 96);
				s += x;
				break;
			}
		}
	}
	cout << s << '\n';
	return 0;
}


---

## 作者：StarRain3 (赞：3)

讲一个较为简单的方法。

首先根据题意可以发现，当输入数字 $n$ 为等差数列的前缀和数字时，输出字符串恰好不重复，且输出字符串的长度 $m$ 恰好等于前缀和是 $s_{m-1}$ 的值。但最后根据错误案例可以看出该方案的局限性，只适用于 $m$ 不超过 $26$。

讲完了大体流程，我们细说一下。首先我们要特判 $n$ 为 $0$ 的情况，然后计算数列前缀和，通过比较，得到输出字符串的长度，我们把它计为 $f$，再计算出重复字符串的长度，判断 $f$ 是否处于两个相邻前缀和中间，如果小于中间的话，又是一种情况，可以根据输出找规律。

#### 核心代码

其余代码为输入输出等内容，想要完整代码同学私信。

```
 if (!t)
    {
        for (int i = m; i > 0; i--)
        {
            str += char(i + 'a' - 1);
        }
    }
    else if(t <= 0.5 * (s[m] - s[m - 1]))
    {
        for (int i = m - 2 * t; i > 0; i--)
        {
            str += char(i + t + 'a' - 1);
        }
        for (int i = t; i > 0; i--)
        {
            str += char(i + 'a' - 1);
            str += char(i + 'a' - 1);
        }
    }
    else
    {
        t = n - s[m - 1];
        str += char('a' + t);
        for(int i = m - 2*t - 1;i > 0; i--)
        {
            str += char(i + t + 'a' - 1);
        }
        for (int i = t; i > 0; i--)
        {
            str += char(i + 'a' - 1);
            str += char(i + 'a' - 1);
        }

    }


```

---

## 作者：DailyPracticeAnn (赞：3)

更好的阅读体验：<https://www.luogu.com.cn/blog/377493/solution-p8719>
- 主要思路：贪心。
- 先确定所需要的字母个数，确定所需字母个数方法比较简单，就是给定一个长度一定字符串最多的冒泡次数。而这是另一种贪心策略了，即往里面插数，往字符串里插入一个字母 $x$,可以达到的最大冒泡数，即字符串中的字符数减去与字符串中与 $x$ 相同的个数。
- 在确定长度后，就开始主贪心策略了，从头到尾贪心。主贪心策略的方法为：给定一个固定的开头（前缀）在剩余的确定的字符位数下使得冒泡次数最多。可以先说明这种方法开头从 ```a``` 往 ```z``` 贪心，处理出来的结果一定是字典序最小的。
- 先开一个数组存储前缀的 $26$ 个字母的个数和前缀的冒泡次数。
- 先把前缀遮住，然后往后缀（即我们要来处理的后续字符串）中一个一个插入字符，最大的冒泡数应该是后缀的字符数减去与后缀中与 $x$ 相同的个数，然后揭开前缀。
- 然后不断贪心累加计数器就可以得到给定一个固前缀在剩余的确定的字符位数下冒泡的最大次数。
- 最后上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
string str;
int V, sum[26];
int let_num;
int now;
int now1,now2;

bool max_mod(int let,int rem) {
	now1 = 0;now2 = 0;
	for (int i = let + 1;i < 26;i++) now1 += sum[i];
	sum[let]++;
	int tmpsum[26];
	memset(tmpsum, 0, sizeof(tmpsum));
	for(int i = 0;i < rem;i++) {
		int max = -1, tmp1 = 0,ops = 0;
		for (int j = 25;j >= 0;j--) {
			if (i - tmpsum[j] + tmp1 > max) {
				max = i - tmpsum[j] + tmp1;
				ops = j; 
			}
			tmp1 += sum[j];
		}
		now2 += max;
		tmpsum[ops]++;
	}
	if (now + now1 + now2 >= V) {
        now += now1;
        return 1;
    }
    else {
        sum[let]--;
        return 0;
    }
}

void getlen() {
	int tmp1 = 0,tmp2=0,tmp3=0;
	while (1) {
		tmp2 = tmp3;
		tmp3 += (2 * tmp1 + 25) * 13;
		if(tmp3 >= V) break;
		tmp1 += 25;
	}
	int num = tmp1 / 25 * 26;
	for (; tmp2 < V; tmp1++) {
		tmp2 += tmp1;
		num++;
	}
	let_num = num;
}

int main() {
	cin >> V;
	getlen();
	for (int i = 0;i < let_num;i++) {
		for (int j = 0;j < 26;j++) {
			if (max_mod(j, let_num - i - 1)) {
				string s;
				s.push_back(j + 'a');
				str = str + s;
				break;
			}
		}
	}
	cout << str;
	return 0;
}
```


---


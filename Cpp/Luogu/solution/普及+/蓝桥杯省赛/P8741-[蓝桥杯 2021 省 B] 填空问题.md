# [蓝桥杯 2021 省 B] 填空问题

## 题目描述


## 试题 A ：空间

### 【问题描述】

小蓝准备用 $256 \mathrm{MB}$ 的内存空间开一个数组，数组的每个元素都是 $32$  位二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问 $256 \mathrm{MB}$ 的空间可以存储多少个 $32$  位二进制整数?

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 B ：卡片

### 【问题描述】

小蓝有很多数字卡片，每张卡片上都是数字 $0$  到 $9$ 。

小蓝准备用这些卡片来拼一些数，他想从 $1$  开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。

小蓝想知道自己能从 $1$  拼到多少。

例如，当小蓝有 $30$  张卡片，其中 $0$  到 $9$  各 $3$  张，则小蓝可以拼出 $1$  到 $10$ ，但是拼 $11$  时卡片 $1$  已经只有一张了，不够拼出 $11$ 。

现在小蓝手里有 $0$  到 $9$  的卡片各 $2021$  张，共 $20210$  张，请问小蓝可以从 $1$  拼到多少?

提示：建议使用计算机编程解决问题。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 C ：直线

### 【问题描述】

在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，那么这些点中任意两点确定的直线是同一条。

给定平面上 $2 \times 3$ 个整点 $\{(x,y) \mid 0 \leq x<2,0 \leq y<3,x \in \mathbb{Z},y \in \mathbb{Z}\}$，即横坐标是 $0$  到 $1$  (包含 $0$  和 $1$ ) 之间的整数、纵坐标是 $0$  到 $2$  (包含 $0$  和 $2$  ) 之间的整数的点。这些点一共确定了 $11$  条不同的直线。

给定平面上 $20 \times 21$ 个整点 $\{(x,y) \mid 0 \leq x<20,0 \leq y<21,x \in \mathbb{Z},y \in \mathbb{Z}\}$，即横坐标是 $0$  到 $19$  (包含 $0$  和 $19$ ) 之间的整数、纵坐标是 $0$  到 $20$  (包含 $0$  和 $20$ ) 之间的整数的点。请问这些点一共确定了多少条不同的直线。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 D ：货物摆放

### 【问题描述】

小蓝有一个超大的仓库，可以摆放很多货物。

现在，小蓝有 $n$ 箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、 宽、高。

小蓝希望所有的货物最终摆成一个大的立方体。即在长、宽、高的方向上分别堆 $L 、 W 、 H$ 的货物，满足 $n=L \times W \times H$。

给定 $n$，请问有多少种堆放货物的方案满足要求。

例如，当 $n=4$ 时，有以下 $6$  种方案：$1 \times 1 \times 4 、 1 \times 2 \times 2 、 1 \times 4 \times 1 、 2 \times 1 \times 2$ 、 $2 \times 2 \times 1 、 4 \times 1 \times 1$

请问，当 $n=2021041820210418$ (注意有 $16$  位数字) 时，总共有多少种方案?

提示：建议使用计算机编程解决问题。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 E ：路径

### 【问题描述】

小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图中的最短路径。

小蓝的图由 $2021$  个结点组成，依次编号 $1$  至 $2021$ 。

对于两个不同的结点 $a,b$，如果 $a$ 和 $b$ 的差的绝对值大于 $21$ ，则两个结点之间没有边相连; 如果 $a$ 和 $b$ 的差的绝对值小于等于 $21$ ，则两个点之间有一条长度为 $a$ 和 $b$ 的最小公倍数的无向边相连。

例如：结点 $1$  和结点 $23$  之间没有边相连; 结点 $3$  和结点 $24$  之间有一条无向边，长度为 $24$  ; 结点 $15$  和结点 $25$  之间有一条无向边，长度为 $75$ 。

请计算，结点 $1$  和结点 $2021$  之间的最短路径长度是多少。

提示：建议使用计算机编程解决问题。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
        "The answer of task C", // 双引号中替换为 C 题的答案
        "The answer of task D", // 双引号中替换为 D 题的答案
        "The answer of task E", // 双引号中替换为 E 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

# 题解

## 作者：cirrationaler (赞：8)

## 试题 A ：空间

### 解析

本题考察计算机存储的基础知识，只要掌握空间存储的换算方法，就能够算出答案。

### 程序

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    printf("%d\n", 256 * 8 / 32 * 1024 * 1024);
    return 0;
}
```

### 答案

`67108864`

## 试题 B ：卡片

### 解析

这道题应该先定义一个长度为 $10$ 的数组，用来存放数字 $0 \sim 9$ 的卡片数，下标则代表数字，元素代表卡片已经使用的张数，初始值为 $0$ ，每种卡片如果使用超过 $2021$ 张，则输出结果。

程序从 $1$ 开始递增遍历，当遍历到某个数时，将拼成该数所需的所有卡片类型数增加，随后判断数组中每种卡片是否被用完，如果用完则退出循环。

### 程序

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[10];

int main()
{
    for (int s = 1;; s++)
    {
        int temp = s;
        while (temp)
        {
            a[temp % 10]++;
            temp /= 10;
        }
        for (int i = 1; i < 10; i++)
        {
            if (a[i] > 2021)
            {
                printf("%d\n", s - 1);
                // 减1是因为这一张无法凑出
                return 0;
            }
        }
    }
    return 0;
}
```

### 答案

`3181`

## 试题 C ：直线

### 解析

本题很容易让人想到枚举和去重，本人代码就是用枚举和去重来实现的。

为了储存 $3$ 个数，本人采取了 $\operatorname{STL}$ 中 $\operatorname{pair}$ 类来表示，为了去重，本人采取了 $\operatorname{STL}$ 中的 $\operatorname{set}$ 集合 ~~（如果没学过，请自行查阅资料）~~。

### 程序

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> PII;
typedef pair<PII, int> PIII;

set<PIII> s;

vector<PII> vec;

int gcd(int a, int b)
{
    if (b == 0)
    {
        return a;
    }
    return gcd(b, a % b);
}

int main()
{
    for (int i = 0; i < 20; i++)
    {
        for (int j = 0; j < 21; j++)
        {
            vec.push_back({i, j});
        }
    }
    for (int i = 0; i < vec.size(); i++)
    {
        for (int j = i + 1; j < vec.size(); j++)
        {
            int x1 = vec[i].first, y1 = vec[i].second;
            int x2 = vec[j].first, y2 = vec[j].second;
            int A = x2 - x1, B = y1 - y2, C = x1 * y2 - x2 * y1;
            int gcdd = gcd(gcd(A, B), C);
            s.insert({{B / gcdd, A / gcdd}, C / gcdd});
        }
    }
    cout << s.size() << endl;
    return 0;
}
```

### 答案

`40257`

## 试题 D ：货物摆放

### 解析

本题根据题意，要满足 $\operatorname{n}=\operatorname{x}\times \operatorname{y}\times \operatorname{z}$ 的所有情况，首先想到枚举法，分为两步：

- 找出 $n$ 的所有因子。
- 对所有因子进行暴力枚举。

### 程序

```cpp
#include <bits/stdc++.h>

using namespace std;

long long a[100];
long long n = 2021041820210418;

int len;

int main()
{
    for (long long i = 1; i * i <= n; i++)
    {
        if (n % i == 0)
        // i是约数
        {
            a[len++] = i;
            // 将约数放入数组
            if (n / i != i)
            // n/i也是约数
            {
                a[len++] = n / i;
            }
        }
    }
    int ans = 0;
    for (int i = 0; i < len; i++)
    {
        for (int j = 0; j < len; j++)
        {
            for (int k = 0; k < len; k++)
            {
                if (a[i] * a[j] * a[k] == n)
                {
                    ans++;
                }
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

### 答案

`2430`

## 试题 E ：路径

### 解析

本题题意比较直接，通过题意就可以知道题目考查图的最短路径算法，本人则使用了 $\operatorname{Dijkstra}$ 算法直接计算 ~~（如果没学过，请自行查阅资料并学习）~~。

### 程序

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 2022;

int edges[MAXN][MAXN];
int d[MAXN];

bool visited[MAXN];

int gcd(int u, int v)
{
    int temp = u % v;
    while (temp > 0)
    {
        u = v;
        v = temp;
        temp = u % v;
    }
    return v;
}
int lcm(int u, int v)
{
    return (u * v / gcd(u, v));
}

int main()
{
    memset(edges, 0x3f3f3f, sizeof(edges));
    for (int i = 1; i <= 2021; i++)
    {
        edges[i][i] = 0;
        for (int j = i + 1; j <= 2021; j++)
        {
            if (j - i <= 21)
            {
                edges[i][j] = edges[j][i] = lcm(j, i);
            }
            else
            {
                break;
            }
        }
    }
    memset(d, 0x3f3f3f, sizeof(d));
    memset(visited, false, sizeof(visited));
    d[1] = 0;
    for (int i = 1; i < 2021; i++)
    {
        int x = 0;
        for (int j = 1; j < 2021; j++)
        {
            if (!visited[j] && d[j] < d[x])
            {
                x = j;
            }
        }
        visited[x] = 1;
        for (int j = max(1, x - 21); j <= min(2021, x + 21); j++)
        {
            d[j] = min(d[j], d[x] + edges[x][j]);
        }
    }
    printf("%d\n", d[2021]);
    return 0;
}
```

### 答案

`10266837`

---

## 作者：4041nofoundGeoge (赞：4)

本题建议评绿，因为涉及到 `set` 和 `Dijkstra` 算法，都是提高组会涉及的内容。

## problem 1

难度对标 CSP-J ，$2020$ 年就考过类似的题。

复习一下刚学 c++ 时我们记的笔记：

> 1. 整型 `int`：占用 $4$ 个字节，可存储 $-2^{31}\sim 2^{31}-1$ 的范围。

所以依题意列出算试：$256\times1024\times1024÷4$，用计算器算一下等于 $67108864$。

## problem 2

难度差不多为 $\colorbox{orange}{\color{white}{普及-}}$，模拟题。

其核心就是模拟用了多少个数，当数大于 $2021$ 时就输出答案。

核心代码：

```cpp
#include<iostream>
using namespace std;
int cnt[15];
int main() {
	for(int i=1;;++i){
		int j=i;
		while(j){
			cnt[j%10]++;
			j/=10;
		}
		for(int k=0;k<=9;k++){
			if(cnt[k]>2021){
				int ansb=i-1;
				cout<<ansb;
				return 0;
			}
		}
	}
    return 0;
}
```

## problem 3

难度理论上来说为 $\colorbox{green}{\color{white}{普及+/提高}}$，因为涉及 `set` 这个 STL 容器，但论难度因该在 $\colorbox{yellow}{\color{black}{普及/提高-}}$。

此题的难点就在于去重，刚好 `set` 是可以去重的容器，具体详见[这里](https://oi-wiki.org/lang/csl/associative-container/)。然后在矩阵中建立平面直角坐标系，每一个点都有一个唯一的坐标。左下角的点设为 $(0,0)$。然后把每两点之间的函数表示出来，通过斜率就可以算了。设两点坐标为 $x_1,y_1,x_2,y_2$，则表达式为：

$$
\begin{cases}
 kx_1+b=y_1 \\
 kx_2+b=y_2
\end{cases}
$$

通过斜率 $\frac{y_2-y_1}{x_2-x_1}=k$ 的公式可以得到 $b=\frac{x_1\times y_2-x_2\times y_1}{x_2-x_1}$ 其中 $x_1<x_2,y_1<y_2$。
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<pair<int,int>>v;
set<pair<pair<int, int>, int>> st;
int gcd(int a,int b){
	if(b==0)return a;
	return gcd(b,a%b);
}
int main(){
	for(int i=0;i<20;++i){
		for(int j=0;j<21;++j){
			v.push_back({i,j});
		}
	}
	int n=v.size();
	for(int i=0;i<n;++i){
		for(int j=i+1;j<n;++j){
			int x1=v[i].first,y1=v[i].second;
			int x2=v[j].first,y2=v[j].second;
			int a=x2-x1,b=y2-y1,c=x1*y2-x2*y1;
			int ans=gcd(gcd(a,b),c);
			st.insert({{b / ans, a / ans}, c / ans});
		}
	}
	cout<<st.size();
	return 0;
}
```

输出结果 $40257$。

## problem 4

难度为 $\colorbox{orange}{\color{white}{普及-}}$。
拆出 $2021041820210418$ 的因数，然后排列组合就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n=2021041820210418;
long long p[1005];
int main(){
	int cur=0;
	for(long long i=1;i*i<=n;++i){
		if(n%i==0){
			p[++cur]=i;
			if(i*i!=n)p[++cur]=n/i;
		}
	}
	long long ans=0;
	for(long long i=1;i<=cur;++i){
		for(long long j=1;j<=cur;++j){
			for(long long k=1;k<=cur;++k){
				if(p[i]*p[j]*p[k]==n){
					++ans;
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

答案：$2430$。

## problem 5

难度为 $\colorbox{green}{\color{white}{普及+/提高}}$，用到了 `Dijkstra` 算法（也叫做最短路），是道模板题，不会看[这里](https://oi-wiki.org/graph/shortest-path/)。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct Edge {
    int to, weight;
};
int gcd(int a,int b){
	if(b==0)return a;
	return gcd(b,a%b);
}
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
int main() {
    const int N = 2021;
    vector<vector<Edge>> graph(2025); 
    for (int i = 1; i <= N; ++i) {
        for (int j = max(1, i - 21); j <= min(N, i + 21); ++j) {
            if (i != j) {
                graph[i].push_back({j, lcm(i, j)});
            }
        }
    }
    // Dijkstra 算法
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    vector<int> dist(N + 1, INT_MAX);
    dist[1] = 0;
    pq.push({0, 1});
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        if (u == 2021) break;
        for (const auto& edge : graph[u]) {
            int v = edge.to, w = edge.weight;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    cout << dist[2021] << endl;
    return 0;
}
```

答案：$10266837$。

最后的最后，用题目给的代码填上得到：

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "67108864", 
        "3181", 
        "40257", 
        "2430", 
        "10266837", 
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

是不是很简单？

完工于 $2024$ 年 $9$ 月 $15$ 日。

---

## 作者：Plenilune_Dreamer (赞：1)

#### 注意，本蒟蒻很蒻！若有不足之处请提出，谢谢！

## A 空间
这题考的是计算机储存知识。

众所周知，一个 32 位的整数占 4B，so 这题答案用 $256 × 1024 × 1024 ÷ 4$ 即可求出。

答案为 67108864。

## B 卡片
一看就是暴力枚举（本人认为）。

定义一个长度为 10 的计数器，分别存 0 至 9，然后一个个枚举方案即可。

注意！若每种的卡片超过了 2021，结果则需减一。

答案为 3181。

## C 直线

纯数学，只要求出所有与矩形相割的的直线，且在格子上的直线个数即可。

答案为 40257。

## D 货物摆放

还是暴力枚举，先求 $n$ 的所有因数，再三重循环，一个一个枚举组合，若三数乘积等于 $n$ ，方案数就要加一（因有一个三数相乘）。

答案为 2430。

## E 路径

主要内容为图的最短路径，用 Dijkstra 算法来解决即可，用 Dijkstra 函数直接求出节点 1 到节点 2021 的最短路径。

[~~隆重推出~~ Dijkstra 算法](https://zhuanlan.zhihu.com/p/338414118)

答案为 10266837。

### 到此所有题目完成，套入框架即可 AC。
------------

## 代码:
```cpp
#include<iostream>
using namespace std;
int main(){
    string ans[]={
        "67108864", 
        "3181", 
        "40257", 
        "2430",
        "10266837",
    };
    char T;
    cin>>T;
    cout<<ans[T-'A']<<endl;
    return 0;
}
```
最后：

感谢各位观看蒟蒻题解。

---

## 作者：xler0915 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8741) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p8741)

### A 空间
答案：$67108864$。

注意到 $1\text{ MB}=2^{20}\text{ B}$，$32$ 位整数占 $4 \text{ B}$，故可存储 $256 \times 2^{20} \div 4 = 67108864$ 个 $32$ 位整数。

### B 卡片
答案：$3181$。

我们可以开一个桶 $card_i$ 表示卡片 $i$ 剩余的张数（$0 \le i \le 9$），则可顺序枚举每一个整数 $x$，将其分离数位，对于每一个数位，令其对应的 $card$ 数组自减 $1$，当发现某一个 $card$ 值小于 $0$，则答案即为 $x-1$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int card[10];
	for(int i = 0; i <= 9; i++)
		card[i] = 2021;
	for(int i = 1; ; i++) {
		int x = i;
		while(x) {
			card[x % 10]--;
			if(card[x % 10] < 0) {
				printf("%d", i - 1);
				return 0;
			} 
			x /= 10;
		}
	}
	return 0;
}
```

### C 直线
答案：$40257$。

首先将这 $420$ 个点压缩成一维。因为直线可以由其斜率和截距唯一确定，且斜率和截距一定只对应一条直线，所以可以枚举两个点 $i$ 和 $j$，将这两个点所组成的直线的斜率和截距压入集合中，最后集合的长度就是答案。**竖向和横向的直线单独计数。**

现在推导二维平面中两点 $A(x_1,y_1)$ 和 $B(x_2,y_2)$ 组成的直线 $AB$ 的斜率及截距，设 $AB:y=kx+b$，将 $A$、$B$ 两点代入得

$$\begin{cases}kx_1+b=y_1\\kx_2+b=y_2\end{cases}$$

解得 

$$\begin{cases}k=\dfrac{y_1-y_2}{x_1-x_2}\\b=\dfrac{x_1 \times y_2-x_2 \times y_1}{x_1-x_2}\end{cases}$$

```cpp
#include <bits/stdc++.h>
using namespace std;

int x[450], y[450];
set<pair<double, double>> s;

int main() {
	for(int i = 0; i < 20; i++) {
		for(int j = 0; j < 21; j++) 
			x[i * 21 + j + 1] = i, y[i * 21 + j + 1] = j;
	}	
	for(int i = 1; i <= 20 * 21; i++) {
		for(int j = 1; j <= 20 * 21; j++) {
			if(x[i] == x[j] || y[i] == y[j]) continue;
			double k = 1.0 * (y[i] - y[j]) / (x[i] - x[j]);
			double b = 1.0 * (x[i] * y[j] - x[j] * y[i]) / (x[i] - x[j]);
			s.insert({k, b});
		}
	}
	printf("%d\n", s.size() + 21 + 20);
	return 0;
}
```

### D 货物摆放
答案：$2430$。

将数 $n=2021041820210418$ 分解因数得因子 $f$，接着枚举 $i,j,k$，若 $f_i \times f_j \times f_k=n$ 则答案自增 $1$。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll n = 2021041820210418ll;
ll f[205], sz = 0, ans = 0;

void get() {
	for(ll i = 1; i * i <= n; i++) {
		if(n % i == 0) {
			f[++sz] = i;
			if(i * i != n)
				f[++sz] = n / i;
		}
	}
}

int main()
{
	get();
	for(ll i = 1; i <= sz; i++) {
		for(ll j = 1; j <= sz; j++) {
			for(ll k = 1; k <= sz; k++) {
				if(f[i] * f[j] * f[k] == n)
					ans++;
			}
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

### E 路径
答案：$10266837$。

显然可以很轻松地把图建好，使用 $\text{Dijkstra}$ 算法即可得到 $1$ 到 $2021$ 的最短路。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2025;
int n = 2021;
int g[N][N], d[N], vis[N];

int lcm(int x, int y) {
	return x * y / __gcd(x, y);
} 
void dijkstra(int s) {
	memset(d, 0x3f, sizeof(d));
	d[s] = 0;
	memset(vis, 0, sizeof(vis));
	for(int i = 1; i < n; i++) {
		int x = -1;
		for(int j = 1; j <= n; j++) {
			if(!vis[j] && (x == -1 || d[j] < d[x])) 
				x = j;
		}
		vis[x] = 1;
		for(int y = 1; y <= n; y++) {
			d[y] = min(d[y], d[x] + g[x][y]);
		}
	}
}

int main() {
	memset(g, 0x3f, sizeof(g));
	for(int i = 1; i <= n; i++) {
		for(int j = i; j <= n; j++) {
			if(i == j) g[i][j] = 0;
			else {
				if(abs(i - j) <= 21)
					g[i][j] = g[j][i] = lcm(i, j);
			} 
		}
	}
	dijkstra(1);
	printf("%d", d[n]);
	return 0;
}
```

### 总代码

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "67108864", 
        "3181", 
        "40257", 
        "2430", 
        "10266837", 
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

---

## 作者：Leaves_xw (赞：1)

A 题：一个三十二位整数占 $4\text{B}$，所以答案为 $256\times1024\times1024$ 再除以 $4$，答案为 $67108864$。

B 题：

定义 $10$ 个计数器，然后暴力枚举，枚举到的每一位数对应的 $cnt_i-1$，如果不够减，答案就是枚举到的 $a_i$ 再减一
，答案为 $3181$。

C 题：

画出所有与矩形相割的的直线且在格子上，答案就是直线的个数，答案为 $40257$。

D 题：

求出 $2021041820210418$ 的所有因数，使用 `a` 数组储存起来，接着需要枚举因数，循环时需要判断三个因数的乘积 $=2021041820210418$ 时 $ans+1$。
答案 $2430$。

E 题：

考察图的最短路径算法（建议使用 Dijkstra 算法），若没学过知识点请自行查阅，调用 Dijkstra 函数求出结点 $1$ 到结点 $2021$ 的最短路径长度。答案 $10266837$。

**代码：**

```
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "67108864", 
        "3181", 
        "40257", 
        "2430", 
        "10266837", 
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

---

## 作者：zhoujunchen (赞：0)

这题哪有绿的难度，最短路板子都只有黄。


试题 A ：空间
--
初赛知识，简单的单位换算。

$$1\mathrm {MB}=1024\mathrm{KB}=1048576\mathrm{B}=8388608\mathrm{b}\\ \frac{256\times8388608}{32}=67108164$$

答案为 $67108864$。

试题 B ：卡片
--

开一个数组统计每种卡片用到了多少，再从 $1$ 开始，判断卡片是否够用，若不够用输出结果即可。



```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt[13];
int main(){
	for(int i=1;;i++){
		int tmp=i;
		while(tmp)cnt[tmp%10]++,tmp/=10;
		for(int x=0;x<=9;x++)if(cnt[x]>2021)return cout<<i-1,0;
	}
	return 0;
}
```

得到答案 $3181$。

试题 C ：直线
--

枚举每一种组合，然后去重。

去重可以使用红黑树，即 `set`。



```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
};
vector<node> v;
set<tuple<int,int,int>> s;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for(int i=1;i<=20;i++)for(int j=1;j<=21;j++)v.push_back({i,j});
	for(int i=0;i<v.size()-1;i++){
		for(int j=i+1;j<v.size();j++){
			int x1=v[i].x,y1=v[i].y,x2=v[j].x,y2=v[j].y;
			int a=x2-x1,b=y1-y2,c=x1*y1-x2*y2;
			int gcd=__gcd(__gcd(a,b),c);
			s.insert({b/gcd,a/gcd,c/gcd});
		}
	}
	cout<<s.size();
	return 0;
}
```

答案为 $40257$。

试题 D ：货物摆放
--

枚举 $n$ 的所有因数，并将它们存储起来，在枚举所有的组合，如果相乘等于 $n$，答案就加一。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
vector<int> v;
int ans,n=2021041820210418;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for(int i=1;i*i<=n;i++)
		if(n%i==0){
			v.push_back(i);
			if(i*i!=n)v.push_back(n/i);
		}
	for(int x:v)
	for(int y:v)
	for(int z:v)
	if(x*y*z==n)ans++;
	cout<<ans;
	return 0;
}
```

得到答案 $2430$。

试题 E ：路径
--

[前置芝士。](https://www.luogu.com.cn/problem/P4779)

首先按照题目要求建边，然后最短路板子即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define pr pair<int,int> 
#define int long long
int n=2021,dis[2024],vis[2024];
int lcm(int a,int b){
	return a/__gcd(a,b)*b;
}
struct edge{
	int v,w;
};
vector<edge> g[2024];
void dijkstra(){
	priority_queue<pr,vector<pr>,greater<pr> > q;
	q.push({0,1});
	for(int i=1;i<=n;i++)dis[i]=0x3f3f3f3f;
	dis[1]=0;
	while(q.size()){
		int u=q.top().second;
		q.pop();if(vis[u])continue;
		vis[u]=1;
		for(auto x:g[u]){
			int v=x.v,w=x.w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push({dis[v],v});
			}
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for(int i=1;i<=n;i++)
        for(int j=max(1ll,i-21);j<=min(n,i+21ll);j++)
            if(i!=j)g[i].push_back({j,lcm(i,j)});
	dijkstra();
	cout<<dis[n]<<"\n";
	return 0;
}
```

得到答案 $10266837$。

全部代码。
--


```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "67108864",
        "3181",
        "40257",
        "2430",
        "10266837",
    };
    char T;
    cin>>T;
    cout<<ans[T-'A']<<"\n";
    return 0;
}
```

---

## 作者：Francium_ (赞：0)

## 试题 A：空间
这题比较水，只要学过空间换算的应该都知道一个 $32$ 位二进制整数的存储空间是 $4$ 个字节，而且 $1 \mathrm{MB} = 1024 \mathrm{KB} = 1024 \mathrm{B}$，那我们就可以直接算出答案为 $67108864$。

## 试题 B：卡片
注意到题目中提示我们要打代码，那我们就暴力枚举每一个数字，直到拼不出来为止，对于每一个数字，先数位分离，再使用桶计数，如果有计数器超过 $2021$ 的，那就输出结束，注意每次不用清空。
最后得到答案是 $3181$。

## 试题 C：直线
两重循环枚举每个点所确定的直线，然后把数据扔到集合中进行去重，最后答案可得 $40257$。

## 试题 D：货物摆放
先记录 $n$ 的所有因数，三重循环枚举 $L$，$W$，$H$，最后统计的答案为 $2430$。

## 试题 E：路径
依据题目模拟建图之后跑最短路即可得到答案 $10266837$。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

string ans [] = {
	"67108864",
	"3181",
	"40257",
	"2430",
	"10266837",
};

int main() {
	char T;
	cin >> T;
	cout << ans[T - 'A'];
	return 0;
}
```

---

## 作者：xzz_0611 (赞：0)

[题目传送门](/problem/P8741)
## 题目分析
### A 空间
简单的单位换算题：
$$
1\text{MB}=1024\text{KB}=1048576\text{B}=8388608\text b\\
256\times8388608\div32=67108864
$$
故答案为 $67108864$。
### B 卡片
用一个数组存储每种卡片剩余的数量，再从 $1$ 开始，一个个判断每个数需要的卡片是否够用，如果不够用了就输出结果。最终可以得到答案为 $3181$。
### C 直线
枚举每一种组合然后去掉重复的部分即可。

对于去重，可以使用 `set` 来实现。

代码如下：
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
using namespace std;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	vector<pair<int,int>>vec;
	set<pair<pair<int,int>,int>>ans;
	for(int i=1;i<=20;++i) for(int j=1;j<=21;++j) vec.push_back({i,j});//枚举组合
	for(int i=0;i<vec.size()-1;++i)
		for(int j=i+1;j<vec.size();++j) {
			int x1=vec[i].first,y1=vec[i].second,x2=vec[j].first,y2=vec[j].second;
			int a=x2-x1,b=y1-y2,c=x1*y1-x2*y2;
			int gcd=__gcd(__gcd(a,b),c);
			ans.insert({{b/gcd,a/gcd},c/gcd});//去重
		}
	cout<<ans.size();//输出答案
	return 0;
}
```
得到答案为 $40257$。
### D 货物摆放
计算出 $n$ 的所有因数储存起来，再枚举所有的组合，如果乘积刚好等于 $n$，就累加答案。最终可以得到答案为 $2430$。
### E 路径
就是一个求最短路径的板子题，可以使用 [Dijkstra 算法](https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989)。最终得到答案是 $10266837$。
## Code
```cpp
#include<iostream>
using namespace std;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	string ans[]={
		"67108864",
		"3181",
		"40257",
		"2430",
		"10266837"
	};
	cout<<ans[getchar()-'A'];
	return 0;
}
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

# P8741 [蓝桥杯 2021 省 B] 填空问题 题解

## problem A

只需懂一点计算机存储知识，考点是空间换算，答案是 $256 \times 8 \div 32 \times 1024^2$。

答案：$67108864$。

## problem B

枚举题。

我们首先定义一个长度为 $10$ 的计数数组 $\texttt{dgt}$（初始值为 $0$），来存放数字 $0 \sim 9$ 的卡片数。每一次存放完后就遍历一遍，如果 $dgt_i > 2021$，那么输出 $i - 1$ 后程序结束。

核心代码：

```cpp
for (int i = 1; i; ++ i) { // 枚举卡片
  int n = i;
  for (; n; n /= 10) { // 存放
    ++ dgt[n % 10];
  }
  for (int j = 1; j <= 9; ++ j) { // 遍历
    if (dgt[i] > 2021) {
      cout << i - 1 << '\n';
      return 0;
    }
  }
}
```
答案：$3181$。

## problem C

数学题。

我们可以求出所有与矩形相割的的直线且在格子上的直线个数，答案就是这个。

答案：$40257$。

## problem D

枚举题。

首先我们定义一个数组 $b$，然后枚举 $2021041820210418$ 的所有因子，找到一个就存储在 $b$ 中。存储完后就可以枚举因数，因为要满足 $a \times b \times c = n$，所以三重循环枚举，如果 $b_i \times b_j  \times b_k = n$，则 `++ ans`。

核心代码（其实很简单）：

```cpp
ll ans = 0; // 防止爆 int
/*三重循环枚举*/
for (int i = 1; i <= idx; ++ i) {
  for (int j = 1; j <= idx; ++ j) {
    for (int k = 1; k <= idx; ++ k) {
      if (b[i] * b[j] * b[k] == n) { // 如符合要求
        ++ ans;
      }
    }
  }
}
```
## problem E

最短路题。

直接求最短路径即可。这里我们使用 Dijkstra 算法（时间复杂度 $O(n^2)$）来解决，直接调用函数求出结点 $1 \sim 2021$ 的最短路径。

答案：$10266837$。

## code

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "67108864", // 双引号中替换为 A 题的答案
        "3181", // 双引号中替换为 B 题的答案
        "40257", // 双引号中替换为 C 题的答案
        "2430", // 双引号中替换为 D 题的答案
        "10266837", // 双引号中替换为 E 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}

```


---

## 作者：XBaiC (赞：0)

### A 空间

考察计算机基础知识。换算后可以得到答案。

$32$ 位整数是 $4\operatorname{B}$ 的空间， $256\operatorname{MB}=256 \times 1024\times 1024\operatorname{B}$。

通过以上式子得出答案是 $256 \times 1024\times 1024 \div 4$。

**CODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	cout << 256 * 1024 * 1024 / 4;
	return 0;
}
```

得到答案 $67108864$。

### B 卡片

暴力枚举即可。

这道题应该先定义一个长度为 $10$ 的计数器，用来存放数字 $0 \sim 9$ 的卡片数，初始值为 $0$，如果每种卡片超过 $2021$，则输出结果减 $1$ 即可。

**CODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[11];
int main()
{
    for( int i = 0; ; i++ )
    {
        int t = i;
        while( t )
        {
            a[t % 10]++;
            t /= 10;
        }
        for( int j = 0; j < 9; j++ )
        {
            if( a[j] > 2021 )
            {
                cout << i - 1;
                return 0;
            }
        }
    }
    return 0;
}
```

得到答案 $3181$。

### C 直线

#### C++：

因 C++ 无控制 `double` 变量小数位数的函数，所以要注意截距 $b$ 在计算时不可直接用上述算出的 $k$ 来直接带入计算，因为 `double` 本身取值会造成误差，带入计算则会造成二次误差，影响结果。在这里对 $b$ 的计算进行化简合并：

$b=y-k\times x= yl - \frac{\Delta y}{\Delta x} \times x1=\frac{y1 \times (x2-x1)}{x2-x1} - \frac{x1 \times (y2-y1)}{x2-x1} = \frac{y1x2-y2x2}{x2-x1}$

**C++ CODE**

```cpp
#include <bits/stdc++.h>
#define line pair<double, double>
using namespace std;
struct node 
{
    double x , y;
}p[25 * 25];
set<line> st;
long long ans = 0;
int main() 
{
    int m = 20 , n = 21;
    int cnt = 0;
    for( int i = 0; i < m; i++ ) 
	{
        for( int j = 0; j < n; j++ ) 
		{
            p[cnt].x = i;
            p[cnt].y = j;
            cnt++;
        }
    }
    for( int i = 0; i < cnt; i++ ) 
	{
        for( int j = 0; j < cnt; j++ ) 
		{
            if ( p[i].x == p[j].x || p[i].y == p[j].y )
            {
                continue;
            }
            double k = ( p[j].y - p[i].y ) / ( p[j].x - p[i].x );
            double b = ( p[j].x * p[i].y - p[j].y * p[i].x ) / ( p[j].x - p[i].x );
            st.insert( { k , b } );
        }
    }
    cout << m + n + st.size();
    return 0;
}
```

#### Python：

因为这题是填空题，我们当然没必要执意使用 C++ 来给自己找麻烦，用 Python 会更加方便。

**Python CODE**

```python
st = set()
p = []
m = 20
n = 21
for i in range( m ):
    for j in range( n ):
        p.append( [i , j] )
for i in p:
    for j in p:
        if i[0] == j[0] or i[1] == j[1]:
            continue
        k = ( j[1] - i[1] ) / ( j[0] - i[0] )
        b = i[1] - k*i[0]
        k = round( k , 4 )
        b = round( b , 4 )
        st.add( ( k , b ) )
print( m + n + len( st ) )
```

得到答案 $40257$。

### D 货物摆放

#### C++：

本题用暴力解法即可求出结果，先求 $n$ 的所有因数（即约数），然后三重 `for` 循环，枚举每一种三个约数组合，若三个约数相乘等于 $n$，就方案数加 $1$。

**C++ CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<long long> v;
long long n = 2021041820210418;
int main()
{
	for( long long i = 1; i * i < n; i++ )
	{
		if( n % i == 0 ) 
		{
			v.push_back( i );
			if( n / i != i ) 
			{
				v.push_back( n / i );
			}
		}
	}
	int res = 0;
	for( int i = 0; i < v.size(); i++ )
	{
		for( int j = 0; j < v.size(); j++ )
		{
			for( int k = 0; k < v.size(); k++ )
			{
				if( v[i] * v[j] * v[k] == n )
				{
					res++; 
				} 
			}
		}
	}
	cout << res;
}
```

#### Python：

长宽高，三重循环，枚举暴力。

两个知识点：约数和集合。

1. 判断约数算法：$n \bmod i = 0$。约数指的是被整除后没有余数的数。举个栗子：$3 \bmod 1 = 0$，$3 \bmod 3 = 0$。$1$ 和 $3$ 就是 $3$ 的约数。

2. 创建集合容器方法：`docker = set()`。选用集合作为容器存放数据，是因为集合的数据不会重复。相同的数据不会重复添加。

**Python CODE**

```python
n = 2021041820210418
cnt = 0
docker = set()
for i in range( 1 , int( n ** 0.5 ) + 1 ):
    if n % i == 0:
        docker.add( i )
        docker.add( n // i ) 
for i in docker:
    for j in docker: 
        for k in docker:
            if i * j * k == n:
                cnt += 1
print( cnt )
```

得到答案 $2430$。

### E 路径

主要思路就是求最短路径，而求最短路及可以用 Dijkstra 迪杰斯特拉算法。先结合题意，求出结点之间的直接距离，这里还涉求最大公因数和最小公倍数，然后调用 Dijkstra 函数求出结点 $1$ 到结点 $2021$ 的最短路径长度。

[迪杰斯特拉算法](https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989?fromtitle=%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95)。

**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2201;
int g[N][N];
int dist[N];
bool vis[N];
int n = 2021;
int gcd( int a , int b )
{
    return b ? gcd( b , a % b ) : a;
}
int lcm( int a , int b )
{
    return a * b / gcd( a , b );
}
int dijkstra()
{
    memset( dist , 0x3f3f3f3f , sizeof dist );
    memset( vis , false , sizeof( vis ) );
    dist[1] = 0;
    for( int i = 1; i <= n; i++ )
	{
        int minx = 0x3f3f3f3f;
        int minmark;
        for( int j = 1; j <= n; j++ )
		{
            if( vis[j] == false && dist[j] <= minx )
			{
            	minx = dist[j];
            	minmark = j;
			}
        }
        vis[minmark] = true;
        for( int j = 1; j <= n; j++ )
		{
        	if( vis[j] == false && dist[j] > dist[minmark] + g[minmark][j] )
        	{
                dist[j] = dist[minmark] + g[minmark][j];
            }
        }
    }
    return dist[n];
}

int main()
{
    for( int i = 1; i <= n; i++ )
    {
        for( int j = 1; j <= n; j++ )
		{
            if( i != j )
			{
                if( fabs( i - j ) <= 21 )
				{
                    g[i][j] = lcm( i , j );
                    g[j][i] = lcm( i , j ); 
                }
                else
				{
                    g[i][j] = 0x3f3f3f3f;
                    g[j][i] = 0x3f3f3f3f;
                }
            }
        }
    }
    cout << dijkstra();
    return 0;
}
```

得到答案 $10266837$。

### AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string ans[5] = { "67108864" , "3181" , "40257" , "2430" , "10266837" };
    char T;
    cin >> T;
    cout << ans[T - 'A'];
    return 0;
}
```


---

## 作者：Vct14 (赞：0)

### 空间

首先，我们要先了解计算机存储单位及它们之间的进率，见[此](https://www.luogu.com.cn/paste/4145xqjl)。

本题，我们要了解以下单位之间的转换：

- $1 \mathrm{MB}=1024 \mathrm{KB}$
- $1 \mathrm{KB}=1024 \mathrm{B}$

由于每个 $32$ 位二进制整数会占用 $4 \mathrm{B}$ 的空间，而 $256 \mathrm{MB}$ 中共有 $256\times1024\times1024 \mathrm{B}$，所以共可以存储 $256\times1024\times1024\div4=67108864$ 个 $32$ 位二进制整数。


### 卡片

我们需要一个数组来存储每种卡片还剩多少张。

然后从 $1$ 开始枚举自然数，每枚举到一个数就对它进行数位分解，将需要用到的卡片的数量减 $1$。

最后判断每种卡片的数量是否小于 $0$ 即可。

```c++
#include <bits/stdc++.h>
using namespace std;

int a[10];

int main(){
	int ans=1; 
	for(int i=0; i<10; i++) a[i]=2021;
    while(1){
        int k=ans;
        while(k){
            a[k%10]--;
            k/=10;
        }
        for(int i=1; i<10; i++){
            if(a[i]<0){
                cout<<ans-1;
                return 0;
            }
        }
        ans++;
    }
    return 0;
}
```

### 直线

我们可以枚举所有两个点的组合，这样就可以确定一条直线，然后判断这条直线是否已经枚举过。

对于两条直线 $l_1,l_2$，设已知 $l_1$ 过点 $P_1$ 和 $P_2$，$l_2$ 过点 $P_3$ 和 $P_4$，则当 $l_1$ 过点 $P_3,P_4$ 时，两条直线为同一条。

因为我们已知 $P_1,P_2$ 的位置，所以我们可以计算出 $P_1,P_2,P_3$ 互相之间的距离，再判断较小的两个距离之和是否等于最大的距离即可。

可以用勾股定理来求两点间的直线距离。若两点坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$，则两点间距离为 $\sqrt{\mid x_1-x_2\mid^2+\mid y_1-y_2\mid^2}=\sqrt{( x_1-x_2)^2+(y_1-y_2)^2}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/k46ah8hx.png)

```c++
#include<bits/stdc++.h>
using namespace std;
#define ui unsigned int

struct Point{
	int x,y;
	Point(){}
	Point(int x,int y){
    	this->x=x;
    	this->y=y;
	}
};

struct Line{
	Point a,b;
	Line(Point a, Point b) {
    	this->a=a;
    	this->b=b;
	}
};

vector<Point> pointList;//点 
vector<Line> lineList;//线 

double Distance(Point p1, Point p2){//距离 
	return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

bool CheckPointInLine(Line x,Point p){//直线 x 是否过点 p
	double dis[3];
	dis[0]=Distance(x.a,x.b);
	dis[1]=Distance(x.a,p);
	dis[2]=Distance(x.b,p);
	sort(dis,dis+3);
	if(fabs(dis[0]+dis[1]-dis[2])<1e-5) return true;
	else return false;
}

bool CheckLineRepeat(Line cur){//是否重合 
  	for(ui i=0; i<lineList.size(); i++) if(CheckPointInLine(lineList[i],cur.a) && CheckPointInLine(lineList[i],cur.b)) return true;
  	return false;
}

int main(){
  	for(int i=0; i<20; i++) for(int j=0; j<21; j++) pointList.push_back(Point(i,j)); 
  	int sum=0;
  	for(ui i=0; i<pointList.size(); i++){
	    for(ui j=i+1; j<pointList.size(); j++) {
	      	Line curLine=Line(pointList[i],pointList[j]);
	      	if(!CheckLineRepeat(curLine)){
	        	sum++;
	        	lineList.push_back(curLine);
	      	}
	    }
  	}
  	cout<<sum;
  	return 0;
}
```

答案为 $40257$。

### 货物摆放

已知 $n=2021041820210418$，且 $L,W,H$ 为正整数，求满足 $n=L\times W\times H$ 的方案总数。

首先[质因数分解](https://zh.numberempire.com/numberfactorizer.php?number=2021041820210418&_p1=2091) $n$，得 $n=2\times3^3\times17\times131\times2857\times5882353$。

对于除了 $3$ 以外的其它 $5$ 个质因数，分给 $L,W,H$ 三个位置共有 $3^5=243$ 种方案。

而对于质数 $3$，则可以枚举出 $10$ 种可能。

所以答案为 $243\times 10=2430$ 种方案。

### 路径

本题可以使用 Floyd 算法，即[插点法](https://baike.baidu.com/item/Floyd%E7%AE%97%E6%B3%95/291990)。

这里给出核心代码。

```c++
void Floyd(){
  	memset(dis,0x3f3f3f3f,sizeof(dis));
  	for(ui i=1; i<=2021; i++) for(ui j=0; j<v[i].size(); j++) dis[i][u[i][j]]=dis[u[i][j]][i]=v[i][j];//v[i][j] 表示 i 的第 j 条边的长度
  	for(int k=1; k<=2021; k++) for(int i=1; i<=2021; i++) for (int j=1; j<=2021; j++) dis[i][j]=dis[j][i]=min(dis[i][j],dis[i][k]+dis[k][j]);
  	cout<<dis[1][maxn];
}
```

答案为 $10266837$。

### 代码

```c++
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "67108864", 
        "3181", 
        "40257", 
        "2430", 
        "10266837", 
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

---


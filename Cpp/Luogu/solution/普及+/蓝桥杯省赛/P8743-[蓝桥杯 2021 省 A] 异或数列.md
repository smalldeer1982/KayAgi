# [蓝桥杯 2021 省 A] 异或数列

## 题目描述

Alice 和 Bob 正在玩一个异或数列的游戏。初始时，Alice 和 Bob 分别有一个整数 $a$ 和 $b$, 有一个给定的长度为 $n$ 的公共数列 $X_{1}, X_{2}, \cdots, X_{n}$ 。

Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种:

选项 1: 从数列中选一个 $X_{i}$ 给 Alice 的数异或上, 或者说令 $a$ 变为 $a \oplus X_{i}$ 。（其中 $\oplus$ 表示按位异或）

选项 2: 从数列中选一个 $X_{i}$ 给 Bob 的数异或上，或者说令 $b$ 变为 $b \oplus X_{i}$ 。

每个数 $X_{i}$ 都只能用一次, 当所有 $X_{i}$ 均被使用后（$n$ 轮后）游戏结束。游戏结束时, 拥有的数比较大的一方获胜，如果双方数值相同，即为平手。

现在双方都足够聪明，都采用最优策略，请问谁能获胜?

## 说明/提示

对于所有评测用例, $1 \leq T \leq 2\times 10^5,1 \leq \sum\limits_{i=1}^{T} n_{i} \leq 2\times10^5,0 \leq X_{i}<2^{20}$ 。 

蓝桥杯 2021 第一轮省赛 A 组 G 题。

## 样例 #1

### 输入

```
4
1 1
1 0
2 2 1
7 992438 1006399 781139 985280 4729 872779 563580```

### 输出

```
1
0
1
1```

# 题解

## 作者：Demeanor_Roy (赞：21)

- [原题链接](https://www.luogu.com.cn/problem/P8743)

- 听说考前写题解能rp++?


------------

首先我们考虑平局的情况，一个比较自然的想法就是所有数异或和为零就平局，而这个结论确实也是对的，下面简单证明一下：

- 必要性：因为Alice和Bob最后会打成平局，自然有 $a = b$，所以无论如何 $a \  xor \  b = 0$ 都成立，必要性得证。

- 充分性：因为所有数异或和为零，那么将所有数任意划分为两个非空集合，这两个集合内部的元素的异或和都应该相等，那自然无论Alice和Bob怎么选数，都会形成平局，充分性得证。

那么我们就可以首先将平局的情况判断掉，下面的情况Alice不胜则负。

因为进行的是异或运算，很容易想到贪心地从高到低一位一位地考虑。假设当然在考虑第 $i$ 位，有 $x$ 个数当前这一位为 $1$ 。那么就有以下三种情况：

1. $x=1$ : 我们发现，因为我们是贪心地从高位到低位考虑，那能考虑到当前位的前提就是更高位分不出胜负，那么既然只有一个数这一位是 $1$ ，那么Alice只需要先选择这个数，那当前位一定是Alice获胜，更低位不影响胜负，则Alice必胜。

2. $x$ 为偶数：利用前面证明充分性时的技巧，我们发现因为一共有偶数个数这一位为 $1$ ，而一个偶数只能拆分成两个奇偶性相同的非负整数，那么无论对所有数怎样划分，当前这一位一定是平局。

3. $x \neq 1$ 且 $x$ 为奇数：同理，一个奇数只能拆分成两个奇偶性不同的非负整数，那么当前这一位一定能分出胜负。考虑谁能获胜，显然是拿到奇数个这一位为 $1$ 的数的人，如果所有数这一位都为 $1$ ，显然先手胜，但因为有这一位为 $0$ 的数，那拿这些数显然能使先后手顺序交换，所以可得结论：若 $n-x$ 为偶数则先手最终还是先手，Alice胜，否则Bob胜。

下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=21;
int T,n,cnt[M];
int main()
{
	scanf("%d",&T);
	while(T--)
	{		
		memset(cnt,0,sizeof cnt);
		scanf("%d",&n);
		int sum=0;
		for(int i=1;i<=n;i++)
		{
			int x;
			scanf("%d",&x);
			sum^=x;
			for(int j=0;j<M;j++)	cnt[j]+=(x>>j)&1;
		}
		if(!sum)	puts("0");
		else
		{
			for(int i=20;i>=0;i--)
			{
				if(!(cnt[i]&1))	continue;
				else if(cnt[i]==1)	puts("1");
				else if((n-cnt[i])&1)	puts("-1");
				else puts("1");
				break;
			}
		}
	}
	return 0;
}
```

- 完结撒花~



---

## 作者：hytree (赞：7)

# 竞技规则
每次可以进行一个异或操作,使自己的数变得大于对方,或者是对方的数小于自己,最后比谁的数比较大.
# 最优策略
根据位运算的原则,我们首先得清楚 **当前可操作数当中位为0的位对我们的数并没有影响** ,原理很简单就是 $0\oplus 1=1$ ，$0\oplus 0=0$ , $0$ 与任何数做异或不会改变我们的数,只是在平白浪费我们的操作次数.

**那么只有位为 $1$ 的位对我们的数产生贡献**

于是贪心策略就产生了,

**我们能否通过控制操作数来控制我们当前的最高位,使自己的最高位大于对方的最高位呢?**

显然这是可以的,于是我们聪明的 _Alice_ 和 _Bob_ 都会尝试争抢最高位为 $1$ 的那些数,由于他们都是一样聪明的,所以若当前最高位为 $1$ 的数有偶数个,那么他们在当前这一位上的较量会平局,他们就只能争抢下一位了。

**一直持续到持有当前最高位的数只有奇数个了,那么战局的结果就明了了**
当持有当前最高位的数只有 $1$ 个,那么先手的 _Alice_ 就可以占得先机,赢下比赛.
但是如果持有当前最高位的数不止 $1$ 个,而是 $3$ 个, $5$ 个..等等呢?那么之前毫无贡献的0就会出手,因为我们每使用了一个 $0$ ,都等于浪费了我们先手的机会,则战局的情况就逆转了.

**所以只要还剩下奇数个 $0$ ,则Alice的先手优势就反转成为后手了,Bob赢**

**如果还剩下偶数个 $0$ ,那么战局就还没有逆转** , _Alice_ 将抓住最后的主动权夺下最后一个当前最高位为 $1$ 的数,赢下比赛

"那么,这一次,是我先下一城了!"( _Alice_ 抱拳)

# 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200010],n,t,cnt[22];
void count(int x)
{
	int a=0;
	while(x)
	{
		if(x&1)++cnt[a];
		x>>=1;++a;
	}
}
int main()
{
	//0对我们的大小改变是没有贡献的
	//因为0^已经是1的部分答案不变,^已经是0的地方答案也不变.
	//只有当前位为1的数才会对我们的数的大小产生贡献.
	//所以策略就为尝试让自己的数变大,或者让对方的数变小.
	//至于到底是让自己的数变大,还是让对方的数变小
	//则是贪心的取决于此次改动是否会是自己与对方的地位逆转
	//如果当前有奇数个1,则看还有多少0
	//每个0都在交换先后手,不交换,在奇数1的情况下A赢,交换则B赢,除非只有一个1了,A赢
	scanf("%d",&t);
	while(t--)
	{
		memset(cnt,0,sizeof(cnt));
		int flag=0;
		scanf("%d",&n);
		for(int i=1;i<=n;++i)
		scanf("%d",a+i),count(a[i]);
		for(int i=20;i>=0;--i)
		{
			if(!(cnt[i]&1)) continue;
			if(cnt[i]==1) {puts("1");flag=1;break;}
			if((n-cnt[i])&1) {puts("-1");flag=1;break;}	
			puts("1"),flag=1;
			break;
		}
		if(!flag) puts("0");
	}
	return 0;	
}
```


---

## 作者：氧少Kevin (赞：3)

## 洛谷8743 - 异或数列

https://www.luogu.com.cn/problem/P8743
蓝桥杯 2021 省赛A组

### 题意

Alice 和 Bob 手中各有一个数字，设分别为$a,b$，初始均为 $0$。
另给出一个序列 $a_i$
Alice 先手，每次可以从以下操作中任选一个：

- 从序列中任选一个之前没被任何人选过的数字 $a_i$，并令 $a\rightarrow a\bigoplus a_i$。
- 从序列中任选一个之前没被任何人选过的数字 $a_i$，并令 $b\rightarrow b\bigoplus a_i$。

$n$ 轮后游戏结束，手里数字大的一方获胜，相等则平局。现在双方均采用最优策略，问谁赢。

### 思路

需要按位分奇偶讨论，从高位到低位分析。

#### 第 $k$ 位为 $1$ 的有偶数个
那么这一位对胜负没有影响。因为不管怎么划分，Alice 和 Bob 两个集合都是偶数个。
#### 第 $k$ 位为 $1$ 的有奇数个
现在不管怎么划分，Alice 和 Bob 两个集合都是一奇一偶，必分胜负。

- 如果第 $k$ 位为 $1$ 的只有 $1$ 个，那么 Alice 必赢。
- 否则，注意**第 $k$ 位为 $0$ 的数字**的影响。
    - 如果某个人选了第 $k$ 位为 $0$ 的数字，相当于**跳过本次选择**，也相当于交换了先后手。
    - 为什么相当于交换了先后手呢？
        - 假如 Alice 进行完操作后，Alice 占上风，轮到 Bob 时 Bob 选择跳过。
        - 接下来再次轮到 Alice 时，相当于**帮 Bob 操作**。
        - 接下来轮到 Bob 时，Bob 担当了之前 Alice 的角色。
    - 所以，第 $k$ 位为 $0$ 的数字有奇数个，Bob 赢；否则，Alice 赢。


---

## 作者：251Sec (赞：2)

一个重要的观察是，记所有数的异或和为 $s$，则两人谁获胜只与 $s$ 的最高位有关，即设 Alice 最后的数值为 $x$，则 Bob 最后的值为 $x \bigoplus s$，而这两个数在 $s$ 为 $0$ 的位一定相同，在 $s$ 为 $1$ 的位一定不同，因此某个数较大等价于它在 $s$ 的最高位对应的一位为 $1$。注意 $s=0$ 的时候为平局。

因此，我们可以规约出这样一个问题，即原问题只有 $1$ 和 $0$ 的版本，我们只需要令每个数为它在 $s$ 最高位处的值就可以了。对于只有 $1$ 和 $0$ 的问题，一个观察是：我们可以把 $0$ 的个数对 $2$ 取模，因为如果一个人选择一个 $0$（代表「停一个回合」），那么另一个人如果可以也一定会这么做。于是我们只需要考虑没有 $0$ 和有一个 $0$ 的情况。注意到我们已经去掉了所有数异或和为 $0$ 的情况，因此我们可以假定 $1$ 的个数为奇数。

首先是没有 $0$ 的情况，可以发现最后一个取数的人（即 Alice）一定是获胜的，因为他可以选择让自己或对方异或上 $1$，而这两种情况恰好有一种是他可以取胜的。

然后是有 $0$ 的情况，此时最后一个取数的人是 Bob，如果最后剩下了一个 $1$ 那么根据上一种情况，他就是可以赢的。所以 Alice 先手取掉一个 $1$ 之后，Bob 取掉一个 $0$，剩下一堆 $1$，就可以赢。但是注意一个边界：如果只有一个 $1$，那么 Bob 取掉一个 $0$ 之后不会剩下 $1$，他就输了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n;
int b[20], s;
int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d", &n);
		memset(b, 0, sizeof(b));
		s = 0;
		for (int i = 1, w; i <= n; i++) {
			scanf("%d", &w), s ^= w;
			for (int j = 0; j < 20; j++) {
				if (w >> j & 1) b[j]++;
			}
		}
		if (!s) {
			puts("0");
			continue;
		}
		int c1, c0;
		for (int i = 19; ~i; i--) {
			if (s >> i & 1) {
				c1 = b[i], c0 = n - c1;
				break;
			}
		}
		c0 &= 1;
		if (!c0) puts("1");
		else puts(c1 == 1 ? "1" : "-1");
	}
	return 0;
}
```

---

## 作者：woshishabi11451444 (赞：2)

对于二进制的贪心，普遍是对每一位进行考虑。

从高到低进行考虑（如果胜负已经分出来了就没必要考虑）：

如果第 $i$ 位为 $1$ 的数量是偶数，显然 Alice 和 Bob 这一位不管怎么选都是 $0$。

如果第 $i$ 位为 $1$ 的数量是 $1$，由于 Alice 先手所以一定是 Alice 赢。

如果第 $i$ 位为 $1$ 的数量是奇数，由于直接判断稍微复杂，而正难则反，所以我们考虑第 $i$ 位为 $0$ 的数量，如果为奇数，则 Alice 这一位会是 $1$，Bob 这一位会是 $0$，所以 Alice 会赢。如果为偶数，则 Bob 这一位会是 $1$, Alice 这一位会是 $0$，所以 Bob 会赢。

时空复杂度：

令 $V = \max \{ x_i \}$。

时间复杂度：$O(T \times n \times \log_{2} V)$。

空间复杂度：$O(\log_{2} V)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

int T, n, sum, cnt[25];

int Solve(){
	cin >> n;
	for(int i = 1, x; i <= n; i++){
		cin >> x;
		for(int j = 0; j < 21; j++){
			cnt[j] += ((x >> j) & 1);
		}
	}
	for(int i = 20; i >= 0; i--){
		if(cnt[i] % 2 == 0){
			continue;
		}
		if(cnt[i] == 1){
			return 1;
		}
		else{
			return ((n - cnt[i]) & 1 ? -1 : 1);
		}
	}
	return 0;
}

int main(){
	for(cin >> T; T--; ){
		cout << Solve() << '\n';
	}
	return 0;
}
```

切勿抄袭。

---

## 作者：jiayixuan1205 (赞：1)

## 题解：P8743 [蓝桥杯 2021 省 A] 异或数列
### 题目大意
给出一个数列，双方初始值为 $0$，每次为自己或对方的值异或上一个数列中的数，最后值大者获胜，求问最优策略下哪方获胜。
### 分析
首先由于题目中提到了都采取最优策略，那么可以想到每个人操作时会尽可能的希望将差距减到最小，所以如果能达到平局，则一定是平局，于是我们先判断什么时候可以达到平局。

- 平局时：当数列中所有数异或和为 $0$ 时，由于每个人都会尽可能的希望缩小之前产生的差距，又因为异或和为 $0$，所以可以达到两者相同。容易想到除了这种情况，其余都无法使得两者相同。

由于是异或，我们可以贪心的从高位向低位考虑。考虑异或一个数时对每一位产生的影响，用一个数组 $cnt$ 来记录每一位上异或产生的 $1$ 的个数，接下来进行分类讨论。

- 如果某一位上 $cnt$ 为 $1$，那么先手可以抢先选走这一位，由于我们是从高到低选取的，那么后手再怎么选都不会更优。
- 如果某一位上 $cnt$ 为偶数，那么先手总能通过最优策略使这一位上达到平局，因此这种情况不用考虑。
- 如果某一位上为不为 $1$ 的奇数。容易发现只有取得奇数个的可以获胜。但是除去选择 $1$ 外，在这一位上还有 $n-cnt$ 个 $0$ 可以选择。正常选取 $1$ 时，必然是先手会取得奇数个。但是当选取到 $0$ 时，相当于先后手互换，我们就可以判断出仅当 $n-cnt$ 为偶数时，先手仍然是先手，可以获胜。
### 代码展示
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e5+10;
const int M = 30;
int T;
int n;
int x,cnt[M];
int tot;
int res;

int main()
{
	cin>>T;
	while(T--)
	{
		memset(cnt,0,sizeof(cnt));
		res=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>x;
			res^=x;
			for(int j=0;j<=20;j++) if(x&(1<<j)) cnt[j]++;
		}
		if(res==0)
		{
			cout<<0<<endl;
			continue;
		}
		for(int i=20;i>=0;i--)
		{
			if(cnt[i]%2==0) continue;
			else if(cnt[i]==1) cout<<1<<endl;
			else if((n-cnt[i])%2==1) cout<<-1<<endl;
			else cout<<1<<endl;
			break;
		}
	}
	return 0;
}
```

---

## 作者：__Ginka__ (赞：0)

## 问题分析

Alice 和 Bob 在游戏中轮流选择数列中的元素进行异或操作，最终比较他们的值来决定胜负。

Alice 总是先手，因此她在每一步都有主动选择的机会。游戏的胜负取决于最终的数值和**每个数的二进制位**。

如果在所有操作结束后，两人的值相等，则为平局（输出 $0$）。

## 思路细化

### 异或的基本性质：相同为 $0$，不同为 $1$。

在整个游戏中，若最后状态下 $a \oplus b =0$，则说明 Alice 和 Bob 的最终值相同，游戏平局。

计算异或总和：

遍历数列，计算所有数的异或值 $s = X_1 \oplus X_2 \oplus ... \oplus X_n$。

如果 $s = 0$，直接输出平局。

统计每一位的 $1$ 的个数：

创建一个数组 $num$ 来统计每一位中 $1$ 的出现次数（**从低位到高位**）。

对于每个数，通过逐位检查更新 $num$。

判断胜负的规则：

### 从最高位到最低位依次检查：

**若该位的 $1$ 的个数为 1**：Alice 胜。

**若该位的 $1$ 的个数为奇数**：

- 如果总数 $n$ 为奇数： Alice 胜。

- 如果总数 $n$ 为偶数： Bob 胜。

**若该位的 $1$ 的个数为偶数**：继续检查下一位。

时间复杂度：$O ( T \times n )$。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,n,num[233],t,s;
//cl:更新num数组，统计每一位中1的出现次数。
void cl(long long a)
{
    int c=1;//位计数器，从1开始。
    while(a)
	{
        if(a&1)//如果当前位为1。
            num[c]++;//该位的1的计数加1。
        c++;
        a>>=1;
    }
}
int main()
{
    cin>>t;
    while(t--)
	{
        memset(num,0,sizeof(num));
        s=0;//初始化异或总和 s 。
        cin>>n;
        for(int i=0;i<n;i++)
		{
            cin>>a;
            cl(a); // 更新 num 数组。
            s=s^a;
        }
        // 如果异或总和为0，输出平局。
        if(!s) cout<<0<<endl;
        else
		{
            for(int i=20;i>0;i--)
			{
                if(num[i] ==1)
				{//如果该位中1的个数为1。
                    cout<<1<<endl;//Alice胜利。
                    break;
                }else if(num[i]%2==1)
				{//如果该位中1的个数为奇数。
                    if(n%2==1)
					{
                        cout<<1<<endl;//Alice胜利。
                        break;
                    }else if(n%2==0)
					{
                        cout<<-1<<endl; //Bob胜利。
                        break;
                    }
                }
            }
        }
    }
    return 0;
}

```

---

## 作者：jr_inf (赞：0)

题意补充：初始 $a,b$ 均为 $0$。

位越高对 $a,b$ 的贡献越大，所以从高位往低位考虑。给几组样例以便分析：

`1 0 0 0 0`

`1 1 0 0 0`

`1 1 1 0 0`

`1 1 1 0`

答案分别是 $1,0,-1,1$。

设当前位有 $x$ 个 $1$，有 $y$ 个 $2$。

- 如果 $x=1$，Alice 必胜。
- 如果 $2|x$，当前位无法判断。
- 如果 $x \neq 1$ 且 $2|x+1$，如果 $2|y$，Alice 必胜，否则 Bob 必胜。

对于第二种情况，无论如何选择，Alice 和 Bob 选择的 $1$ 的个数的奇偶性相同；对于第三种情况，双方同时选 $0$ 的情况不会影响答案，可以将 $y$ 视为 $y \% 2$。选了奇数个 $1$ 的人才能得到贡献，所以如果 $y=0$，Alice 必败，否则 ta 可以通过选 $0$ 来夺回优势。

按照上述思路从高位往低位分析即可。

code：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=2e5+10;
int t,n,c[N],maxn;
int get(int x)
{
	int cnt=0;
	while(x)x/=2,cnt++;
	return cnt;
}
int work()
{
	for(int i=get(maxn);i>=0;i--)
	{
		int cnt=0;//文中 x
		for(int j=1;j<=n;j++)cnt+=bool((c[j]>>i)%2);
		if(cnt==1)return 1;
		else if(cnt%2)return(n-cnt)%2?-1:1;
	}
	return 0;
}
signed main()
{
	scanf("%d",&t);
	while(t--)
	{
		maxn=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&c[i]),maxn=max(maxn,c[i]);
		printf("%d\n",work());
	}
}

```


---

## 作者：Φρανκ (赞：0)

题意：给定 $n$ 个数，对于每个数，A 与 B 轮流选择自己获得或给予对方。最终自己所有数异或和最大者胜利。求有必胜策略者。

核心思想：按位求解

解：

根据异或运算的定义，可知对于每一位而言，若一方得到了奇数个数在该处为 $1$ 而另一方得到偶数个，则前一方胜。在最高一位胜的一方也取得整局游戏的胜利。

在每一位上，若有偶数个 $1$，则双方得到的 $1$ 个数的奇偶性必然相同，即平局。若有奇数个，则考虑 $0$ 的个数：若无 $0$，显然先手能取得胜利。若有，遇到一次 $0$ 就相当于浪费一次选择机会，有奇数个 $0$ 就相当于交换先后手。所以此时后手会胜利。否则先手胜利。

因此，对于每个询问统计出每位上 $0,1$ 分别出现次数并判断即可。注意所有位置都平局的情况需要特判。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long t, n, x, a[21], pw[21], flag;
int main()
{
	cin>>t;
	pw[0]=1;
	for(int i=1; i<=20; i++)
		pw[i]=pw[i-1]*2;
	for(int i=1; i<=t; i++)
	{
		cin>>n;
		flag=0;
		memset(a, 0, sizeof(a));
		for(int j=1; j<=n; j++)
		{
			cin>>x;
			for(int k=0; k<=19; k++)
				if(x%pw[k+1]>=pw[k])
					a[k]++;
		}//按位统计
		for(int j=19; j>=0; j--)
			if(a[j]%2!=0)
			{
				if((n%2==1 || a[j]==1)
					cout<<1<<endl;
				else
					cout<<-1<<endl;
				flag=1;
				break;
			}//奇数情况
		if(flag==0)
			cout<<0<<endl;//特判平局
	}
	return 0;
}

```

---


# [蓝桥杯 2023 省 A] 异或和之和

## 题目描述

给定一个数组 $A_i$，分别求其每个子段的异或和，并求出它们的和。或者说，对于每组满足 $1 \leq L \leq R \leq n$ 的 $L,R$，求出数组中第 $L$ 至第 $R$ 个元素的异或和。然后输出每组 $L,R$ 得到的结果加起来的值。

## 说明/提示

#### 【评测用例规模与约定】

对于 $30 \%$ 的评测用例，$n \leq 300$；

对于 $60 \%$ 的评测用例，$n \leq 5000$;

对于所有评测用例，$1 \leq n \leq 10^5$，$0 \leq A_i \leq 2^{20}$。

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
39```

# 题解

## 作者：w9095 (赞：49)

[P9236 [蓝桥杯 2023 省 A] 异或和之和](https://www.luogu.com.cn/problem/P9236)

首先，异或有一个重要的性质：

$$a\oplus b \oplus b=a$$

因为 $b$ 的二进制位一定与自己一样，根据异或的定义，得出 $b\oplus b=0$，进而推出这个式子。

有了这个式子，区间异或和就可以像前缀和一样处理了。

我们可以求出每一项的前缀异或和，记作 $q_i$，根据上面那条性质，可以仿照前缀和的形式写出区间 $[l,r]$ 的异或和（记作 $S_{l,r}$）的 $O(1)$ 求法式子：（下标均从 $1$ 开始）

$$S_{l,r}=p_r\oplus p_{l-1}$$

所以，我们用这个式子来求解每个区间的异或和，可以把每个子段的异或和的和转变为下面式子：（这里 $p_0$ 默认取 $0$ 值，因为还需要查询类似 $[1,i]$ 这种区间的值）

$$\sum_{i=1}^{n}\sum_{j=0}^{i-1}p_i\oplus p_j$$

但这个做法的复杂度是 $O(n^2)$，不够通过本题的数据范围，所以我们还需要在这个基础上继续优化。

在这个式子中，我们可以观察到，对于每一对 $i,j$ 不相等的有序数对 $(i,j)$，$p_i,p_j$ 都恰好只互相异或了一次。所以，问题又转化为了 $n$ 个数，其中两两异或的求和。

这个时候会发现推式子已经到达尽头了，再怎么推也不会得到新的结论。必须从其他方面考虑问题，比如异或运算的计算原理的方面。可以考虑把每个数按二进制拆分，在每一位上统计该位的贡献。由于最后是两两异或的求和，所以二进制拆分后打乱不会影响结果。

由于异或的运算法则是如果同位数字不同，那么运算结果的这一位为 $1$。我们知道，只有二进制位为 $1$ 对最终的结果（加和）有贡献，所以我们可以统计二进制结果为 $1$ 的情况。

对于每一个 $p_i$，我们将其按位拆分，并将结果存入计数数组 $w_{i,j}$ 中。其中 $i$ 表示第 $i$ 个二进制位，$j$ 表示这一位上为 $j$（只能为 $0$ 或 $1$），$w_{i,j}$ 表示在所有数中，第 $i$ 个二进制位上为 $j$ 的有 $w_{i,j}$ 个。

由于这些数中必定两两异或，所以可以直接用乘法原理，求出该位最终为 $1$ 的个数，最后乘上该位的权值就可以了。所以最后的答案为：（公式中 $i$ 的范围上界到 $20$ 是因为题目中说 $A_i\le2^{20}$，最多只有 $21$ 个二进制位）

$$\sum_{i=0}^{20}w_{i,0}\times w_{i,1}\times 2^i$$

时间复杂度 $O(n)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[100010],q[100010],w[100010][2],ans=0;
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)q[i]=q[i-1]^a[i];
    for(int i=0;i<=n;i++)
        for(int j=20;j>=0;j--)
	        w[j][(q[i]>>j)&1]++;
	for(int i=0;i<=20;i++)
	    ans+=w[i][0]*w[i][1]*(1<<i);
	printf("%lld",ans);
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/109485987)

---

## 作者：览遍千秋 (赞：23)

蓝桥杯赛场上看到这个巨大典题实在没蚌住。

首先，由于位运算是位独立的，我们可以把它按二进制拆分为 $0,1$ 的序列 $b_i$。

由于异或具有自反性，类比前缀和，记 $S_i = b_1 \oplus b_2 \oplus \cdots \oplus b_i$，那么 $[l,r]$ 内的数的异或值则为 $S_r \oplus S_{l-1}$。

如果这个区间对最终的答案有贡献，那么 $S_r \oplus S_{l-1}=1$，即这两个数不同。任意两个 $0,1$ 都将构成一个这样的区间。

记 $Z$ 为 $S[0\cdots N]$ 中 $0$ 的个数，$O$ 为 $S[0 \cdots N]$ 中 $1$ 的个数，答案即为 $O \times Z \times 2^p$，$p$ 为当前位数。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int N, a[100000 + 7];
int S[100000 + 7], cnt[2], sum;

signed main() {
	cin >> N;
	for(int i = 1; i <= N; i++) cin >> a[i];
	for(int i = 0; i <= 20; i++) {
		for(int j = 1; j <= N; j++) {
			if((a[j] >> i) & 1) S[j] = S[j - 1] ^ 1;
			else S[j] = S[j - 1];
		}
		cnt[0] = cnt[1] = 0;
		for(int j = 0; j <= N; j++) {
			cnt[S[j]]++;
		}
		sum += (1ll << i) * cnt[0] * cnt[1];
	}
	cout << sum << endl;
}
```

---

## 作者：TernaryTree (赞：11)

典。

首先前缀异或和，记 $B_i=\bigoplus\limits_{j=1}^{i}A_i$。根据异或性质 $x\bigoplus x=0$，有 $\bigoplus\limits_{j=l}^rA_i=B_r\bigoplus B_{l-1}$，于是问题转换为了求

$$\sum\limits_{i=0}^n\sum\limits_{j=i+1}^n B_{i}\bigoplus B_{j}$$

异或求和相关的，经典套路是拆位。考虑当前位 $d$，设 $B_{0\sim n}$ 中有 $C_i$ 个二进制第 $d$ 位为 $i$ 的（$i\in \{0,1\}$），贡献为

$$C_0\times C_1\times 2^d$$

然后从 $0$ 开始枚举 $d$ 就做完了。时间复杂度 $\Theta(n\log V)$。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e5 + 10;

int n, ans;
int a[maxn];

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i], a[i] ^= a[i - 1];
    for (int d = 0; d < 31; d++) {
        int c[2] = {0, 0};
        for (int i = 0; i <= n; i++) ++c[a[i] >> d & 1];
        ans += (1 << d) * c[0] * c[1];
    }
    cout << ans;
    return 0;
}

```

---

## 作者：liuyi0905 (赞：3)

在做此题之前，我们得先知道 $\oplus$ 拥有这样一个性质——自反性：
$$a\oplus b\oplus b=a$$
如果是算 $L$ 到 $R$ 之间的元素之和，立即可以想到前缀和。应为异或有自反性，所以异或也可以用前缀和，就记 $pre_i$ 为 $A$ 的前 $i$ 个元素的异或值。如果 $pre_l\oplus pre_r=1$，也就是说任意两个 $0$ 和 $1$ 都可以构成这样的一个区间。

所以我们最后的答案为 $pre[0,N]$ 中 $0$ 的个数去乘 $pre[0,N]$ 中 $1$ 的个数再乘 $2^p$，$p$ 为当前的位数。

下面给出代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
int n,a[N],S[N],cnt[2],sum;//cnt是统计0和1的个数
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=0;i<=20;i++){
		for(int j=1;j<=n;j++)
			if((a[j]>>i)&1)S[j]=S[j-1]^1;//计算异或前缀和
			else S[j]=S[j-1];
		cnt[0]=cnt[1]=0;//记住每次都要归0
		for(int j=0;j<=n;j++)cnt[S[j]]++;//统计0和1
		sum+=(1ll<<i)*cnt[0]*cnt[1];//累加答案
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：SunnyYuan (赞：2)

## 思路

题目给我们一个数组 $a$，那么我们可以算出其异或前缀和 $sum$。

我们知道，算出 $[l, r]$ 的异或和可以这样计算：$sum_r \oplus sum_{l - 1}$。

那么问题就转换为了 $sum_{0\sim n}$ 这 $n + 1$ 个数字两两异或之和（当然 $sum_i \oplus sum_j$ 和 $sum_j\oplus sum_i$ 是一样的，不重复计算）。

那我们遍历 $sum$ 数组，然后计算出 $w_{i, j}$ 数组表示所有数字在二进制表示下第 $i$ 位为 $j$ 的数字个数（$0 \le i \le 20, 0 \le j \le 1$）。

对于第 $i$ 位，如果有两个数字的第 $i$ 位分别为 $0, 1$，那么就可以贡献 $2^i$ 的和。

根据乘法原理，对于第 $i$ 位可以凑出 $w_{i, 0}\cdot w_{i, 1}$ 这么多对可以对答案有贡献的组合，它们的贡献都是 $2 ^ i$，所以可以让 $ans$ 加上 $w_{i, 0}\cdot w_{i, 1}\cdot2^i$。

## 代码

注意要开 `long long`。

```cpp
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

const int N =  100010, M = 25;

int n;
int a[N];
int w[M][2];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i], a[i] ^= a[i - 1];

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j < M; j++) {
            w[j][a[i] >> j & 1] ++;
        }
    }

    i64 ans = 0;

    for (int i = 0; i < M; i++) ans += (1ll * w[i][0] * w[i][1] * (1 << i));
    cout << ans << '\n';
    return 0;
}
```

---

**参考文献：**

https://www.luogu.com.cn/blog/w9095/solution-p9236

---

## 作者：Bulyly (赞：2)

确实没有想到这种比赛里会出这么经典的题。


------------
- 核心是利用位的独立性。分别计算二进制下每一位产生的贡献。对于一个区间，二进制下的第 $i$ 位能够产生贡献说明该区间异或和 $S$ 的第 $i$ 位为 $1$。

- 对于每一位考虑使用前缀和的思想。显然一个区间在某位的异或值为 $1$，端点对应的值应该不同。即对于每一位统计 $0/1$ 的个数。相乘即为区间数。记得考虑前缀和中的第 $0$ 项。

下附代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=1e5+10;
int n;
int a[N],f[32],d[32];
ll res;

int main() {
	
	scanf("%d",&n);
	for(int i=1;i<=n;i++)  scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) {
		for(int j=31;j>=0;j--) {
			if((a[i]>>j)&1) 	f[j]^=1;
			if(f[j]==1)  d[j]++;
		}
			
	}
	for(int i=0;i<=31;i++) res+=1ll*(1<<i)*d[i]*(n-d[i]+1); 
	printf("%lld\n",res);
	return 0;
}
```
完结撒花~

---

## 作者：Bi_Byron (赞：2)

# P9236题解

[P9236 [蓝桥杯 2023 省 A]](https://www.luogu.com.cn/problem/P9236)

## 解法说明：
本题主要的思路是依据位运算的性质进行优化：
 
以01组成的子段为例：令sum为异或和：

 $sum =  a_1 \bigoplus a_2 \bigoplus a_3 ..... \bigoplus a_n$

p为子段项数，则有:

 $sum_p = sum_{p-1} \bigoplus a_p$


而对于区间[l,r],若 区间[l,r]的异或和为1，则对最终的结果有贡献。

依据异或的自反性质，区间[l,r]的异或和即为 

$sum_r \bigoplus sum_{l-1}$ ;


和前缀和类似；

接下来的问题就是要把非01的子段转化为01的子段，

于是就有按照二进制位拆分来算异或的想法

于是就可以按照位置进行拆分，依次求出每一位的1与0的个数，以pos与inp分别表示1和0的个数，于是就有了以下公式

 $  res =  \sum\limits_{i=0}^{n(20)} {inp \cdot pos \cdot 2^i } $ 

### 最后代码如下：

``` cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,res,temp;
ll a[1000007];//记录所有的数字
ll s[1000007];//异或和
ll pos,inp;//记录每一个二进制位0,1的个数
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> a[i];
	}
	for(int p=0;p<=20;p++){        //按二进制位拆分
		for(int j=1;j<=n;j++){      //遍历每一个数
			temp = (a[j] >> p); 
			if(temp & 1) s[j] = s[j-1] ^ 1; //异或和
			else s[j] = s[j-1]; 
		}
	    pos = inp = 0;
	    for(int j=0;j<=n;j++){
			if(s[j]) pos++; //记录0,1的个数
			else inp ++;
		}
		res += (1 << p) * pos * inp; //1 << p 表示 2的p次方
	}
	cout << res;
	return 0;
}
```
---
## [AC记录](https://www.luogu.com.cn/record/112007604)

---

## 作者：bochibochi (赞：2)

由异或操作可以想到拆位，对于数的每一位计算异或和。显然，如果第 $k$ 位有 $x$ 个区间异或和是 $1$，那么对答案的贡献就是 $x\times 2^k$。

某个区间异或和为 $1$ 等价于这个区间中存在奇数个 $1$，因此只需要对于每个位置 $i$ 计算 $S_i=\sum_{j=1}^ia_j$，然后统计奇偶性不同的数对 $S_i,S_j$ 数量即可。

```cpp
#include<iostream>
using namespace std;
int a[100005];
int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    long long ans = 0;
    for(int k = 0; k <= 22; k++)
    {
        int x = 1, y = 0, s = 0;
        long long res = 0;
        for(int i = 0; i < n; i++)
        {
            if(a[i] & (1<<k)) s ^= 1;
            if(s) res += x, y++;
            else res += y, x++;
        }
        ans += res<<k;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

给定一个数组 $a$，求出每个子段的异或和的和。

### 题目分析

首先来想暴力，枚举 $l, r$ 然后计算这一段的异或和。

时间复杂度是 $\mathcal O(n ^ 3)$ 的。

根据异或的性质，$b = (a\oplus b) \oplus a$，于是，我们可以用类似前缀和的方法来处理，我们记 $s_i = \bigoplus\limits_{j = 1}^{j \le i} a_i$ 那么 $\bigoplus\limits_{i = l}^{i \le r} a_i = s_r \oplus s_l$。这样时间复杂度就可以优化到 $\mathcal O(n ^ 2)$ 了。

我们发现，$a_i \le 2^ {20}$，于是想到可以按二进制的每一位来算。

对于某一位的一段区间 $b_l \sim b_r$，如果它要在最后的答案中做出贡献，那么一定要满足 $\bigoplus\limits_{i = l}^{i \le r}b_i = 1 \to s(b)_l \oplus s(b)_r = 1$，也就是说 $s(b)_l$ 和 $s(b)_r$ 中一个为 $1$，一个为 $0$。

设第 $i$ 位前缀和为 $1$ 的数量为 $c_{i,1}$，为 $0$ 的数量为 $c_{i,0}$。根据排列组合，能够做出贡献的就是 $c_{i,1} \times c_{i,0}$。于是，最终答案就是 $\sum\limits_{i = 0}^{i \le 20} c_{i,1} \times c_{i,0} \times 2^i$

最终的时间复杂度就可以优化到 $\mathcal O(n \times V)$（$V$ 为 $a_i$ 在二进制中的有效位数，本题中为 $20$）。

> PS：十年 $\operatorname{OI}$ 一场空，不开 $\operatorname{long~long}$ 见祖宗。记得开 $\operatorname{long~long}$。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <map>
#include <cstring>
#include <algorithm>
#define int long long

using namespace std;

int n, a, s[25], sum[25], ans;

signed main()
{
	scanf("%lld", &n);
	for(int i = 1;i <= n;i++)
	{
		scanf("%lld", &a);
		for(int j = 0;j <= 20;j++)
		{
			s[j] ^= (a & (1 << j)) ? 1 : 0;
			sum[j] += (s[j] == 1 ? 1 : 0);
		}
	}
	for(int i = 0;i <= 20;i++)
		ans += (1 << i) * sum[i] * (n - sum[i] + 1);
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：
#### 1.前缀和：
异或其实和加法差不多，用前缀和 $O(N)$ 预处理，$n^2$ 枚举 $L$ 和 $R$ 过 60pts 跑路。

减去之前异或过的数，相当于在异或一遍，两次异或 = 异或 $0$。

$$ans_{L,R}=pre_R^{pre_{L-1}}$$

#### 2.按位计算贡献+前缀和
按每个二进制位 $i$ 考虑，从而转化为 $0,1$ 序列的问题。

一个子段 $[L,R]$ 在第 $i$ 位有贡献，当且仅当 $[L,R]$ 内第 $i$ 位出现的次数为奇数次。

前缀和做差 $[L,R]=[1,R]-[1,L-1]$，所以维护当前有多少个前缀是奇数，有多少个前缀是偶数。

$[L,R]$ 为奇数，若 $[L,R]$ 为偶数则要求 $[1,L-1]$ 为奇数，反之同理。

枚举每个右端点，统计与其对应的有贡献的左端点，计算答案。
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
int n,a[N],sum[2];
ll ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  scanf("%d",&a[i]);
	for(int i=0;i<=20;++i){
		sum[0]=1,sum[1]=0;
		int t=0;
		ll x=0;
		for(int j=1;j<=n;++j){
			int v=a[j]>>i&1;
			t^=v;
			x+=sum[t^1];
			sum[t]++;
		}
		ans+=x*(1ll<<i);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：cppcppcpp3 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9236)。

题面简述：给出数组 $a$，令 $s$ 为其前缀异或数组，求 $\sum\limits_{i=1}^{n}\sum\limits_{j=i}^{n} s_{i-1} \oplus s_j$。

## Solution

异或运算每一位相互独立，所以套路地考虑拆开每一位计算贡献。

可以知道，区间 $[l,r]$ 在第 $k$ 位上有贡献，当且仅当在 $s_r$ 和 $s_{l-1}$ 中恰有 $1$ 个数在第 $k$ 位上为 $1$。

所以记 $tot_k$ 为 $s_0,s_1,\cdots,s_n$ 中第 $k$ 位为 $1$ 的个数。则第 $k$ 位为 $0$ 的有 $n+1-tot_k$ 个。贡献就是 $tot_k \times(n+1-tot_k)\times 2^k$。

```cpp
#include<bits/stdc++.h>
#define il inline
#define int long long
using namespace std;
const int N=2e5+5;
const int inf=1e9+7;

il int wrd(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
	while(isdigit(c)){x=x*10+c-48,c=getchar();}
	return x*f;
}

int n,s,b[N];
int ans,tot[N];

main(){
	n=wrd(),b[0]=1;
	for(int i=1;i<=20;++i) b[i]=b[i-1]<<1; 
	for(int i=1;i<=n;++i){
		s^=wrd();
		for(int j=0;j<=20;++j) tot[j]+=((s>>j)&1);
	}
	
	for(int i=0;i<=20;++i) ans+=(tot[i]*(n+1-tot[i])*b[i]);
	return printf("%lld",ans),0;
}
```

---


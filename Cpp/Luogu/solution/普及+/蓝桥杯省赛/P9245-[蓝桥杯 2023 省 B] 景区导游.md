# [蓝桥杯 2023 省 B] 景区导游

## 题目描述

某景区一共有 $N$ 个景点，编号 $1$ 到 $N$。景点之间共有 $N-1$ 条双向的摆渡车线路相连，形成一棵树状结构。在景点之间往返只能通过这些摆渡车进行，需要花费一定的时间。

小明是这个景区的资深导游，他每天都要按固定顺序带客人游览其中 $K$ 个景点：$A_{1},A_{2},\ldots,A_{K}$。今天由于时间原因，小明决定跳过其中一个景点，只带游客按顺序游览其中 $K-1$ 个景点。具体来说，如果小明选择跳过 $A_{i}$，那么他会按顺序带游客游览 $A_{1},A_{2},\ldots,A_{i-1},A_{i+1},\ldots,A_{K}(1 \leq i \leq K)$。

请你对任意一个 $A_{i}$，计算如果跳过这个景点，小明需要花费多少时间在景点之间的摆渡车上？

## 说明/提示

**【样例说明】**

原路线是 $2 \rightarrow 6 \rightarrow 5 \rightarrow 1$。

当跳过 $2$ 时，路线是 $6 \rightarrow 5 \rightarrow 1$，其中 $6 \rightarrow 5$ 花费时间 $3+2+2=7$，$5 \rightarrow 1$ 花费时间 $2+1=3$，总时间花费 $10$。

当跳过 $6$ 时，路线是 $2 \rightarrow 5 \rightarrow 1$，其中 $2 \rightarrow 5$ 花费时间 $1+1+2=4$，$5 \rightarrow 1$ 花费时间 $2+1=3$，总时间花费 $7$。

当跳过 $5$ 时，路线是 $2 \rightarrow 6 \rightarrow 1$，其中 $2 \rightarrow 6$ 花费时间 $1+1+2+3=7$，$6 \rightarrow 1$ 花费时间 $3+2+1=6$ ，总时间花费 $13$。

当跳过 $1$ 时，路线时 $2 \rightarrow 6 \rightarrow 5$，其中 $2 \rightarrow 6$ 花费时间 $1+1+2+3=7$，$6 \rightarrow 5$ 花费时间 $3+2+2=7$ ，总时间花费 $14$。


**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$2 \leq K \leq N \leq 100$。

对于 $40 \%$ 的数据，$2 \leq K \leq N \leq 10^{4}$。

对于 $100 \%$ 的数据，$2 \leq K \leq N \leq 10^{5}$，$1 \leq u,v,A_{i} \leq N$，$1 \leq t \leq 10^{5}$。保证 $A_{i}$ 两两不同。 

蓝桥杯 2023 省赛 B 组 I 题。

## 样例 #1

### 输入

```
6 4
1 2 1
1 3 1
3 4 2
3 5 2
4 6 3
2 6 5 1```

### 输出

```
10 7 13 14
```

# 题解

## 作者：kouki_hash (赞：6)

最近正在学 LCA，正好看到蓝桥杯省赛这题，似乎刚放上去还没有题解，正好作为本蒟蒻第一篇题解练练手~~结果发现不会写题解~~。

## 题意分析
题意比较简单，在一棵有 $N$ 个点的无向有权树上选出 $K$ 个点，随后有 $K$ 个询问，每次询问会跳过一个点，跳过的点从1、2、3依次到 $K$，求每次依次访问剩余点的路径权值和最小值。

## 解题思路
首先很容易得出：由于访问顺序固定，任意连续访问点之间的路径权值和都要最小，这样按顺序访问所有点后的路径权值和一定最小。而一棵无向树上任意两点的最短路径有且只有一条，并且经过这两点的 LCA 即最近公共祖先（不管边带不带权都一样）。这样的最短路径很好求得，用树上前缀和 sum[i] 表示树根到结点i的路径权值和，那么任意两点 a 和 b 的最短路径为
$$dis(a,b)=sum[a]+sum[b]-2 \times \operatorname{LCA}(a,b)$$
再求出按原访问顺序的路径权值前缀和，对于 $A _ {i}$ 有
$$ans[i]=dis(A _ {1},A _ {2})+dis(A _ {2},A _ {3})+\dots+dis(A _ {i-1},A _ {i})(2 \le i \le K)$$
那么当跳过 $A _ {i}$ 时，答案就是
$$\begin{cases} ans[K]-ans[2] & i = 1 \\ ans[i-1]+dis(a[i-1],a[i+1])+ans[K]-ans[i+1] & 2 \le i \le K-1 \\ ans[K-1] & i = K \end{cases}$$
那么问题来到如何求出一些给定点对的 LCA。这里本蒟蒻用了离线算法 Tarjan 算法，~~因为懒得写倍增~~因为赛时可以比较快捷地实现。

简单来说，此题需要以下步骤：读入树后，进行一次 DFS 预处理出所有结点的树上前缀和 sum[i]。读入游览线路，记录下相邻数对和间隔数对。跑一遍 Tarjan 算法，求出按照原访问顺序的路径权值前缀和，求出答案。时间复杂度为 $O\left(m\,\alpha(m+n, n) + n\right)$。

## 具体代码
```cpp
#include <bits/stdc++.h>
using namespace std;

long long a[100005];

bool vis1[100005];
long long sum[100005];

bool vis2[100005];
long long fa[100005];
vector<long long>q[100005];//保存要查询的点对，离线查询

map<pair<long long, long long>, long long>ma;//保存点对及其LCA

long long ans[100005];

struct node {
	long long v;
	long long t;
} edge;

vector<struct node>g[100005];

long long find(long long x) {
	if (fa[x] == x) {
		return x;
	} else {
		return fa[x] = find(fa[x]);
	}
}

void dfs(long long x) {//预处理求出树上前缀和
	vis1[x] = true;

	for (long long i = 0; i < g[x].size(); i++) {
		if (vis1[g[x][i].v] != true) {
			sum[g[x][i].v] = g[x][i].t + sum[x];
			dfs(g[x][i].v);
		}
	}
	return;
}

void tarjan(long long x) {//标准tarjan模板
	vis2[x] = true;

	for (long long i = 0; i < g[x].size(); i++) {
		if (vis2[g[x][i].v] == false) {
			tarjan(g[x][i].v);
			fa[g[x][i].v] = x;
		}
	}

	for (long long i = 0; i < q[x].size(); i++) {
		if (vis2[q[x][i]] == true) {
			ma[ {x, q[x][i]}] = find(q[x][i]);
			ma[ {q[x][i], x}] = find(q[x][i]);
		}
	}
	return;
}

long long get_dis(long long x, long long y) {//求出树上两点最短路径
	return sum[x] + sum[y] - 2 * sum[ma[ {x, y}]];
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	long long n, k;
	cin >> n >> k;

	for (long long i = 1; i < n; i++) {
		long long u, v, t;
		cin >> u >> v >> t;

		g[u].push_back({v, t});
		g[v].push_back({u, t});
	}

	dfs(1);//预处理出树上前缀和

	for (long long i = 1; i <= k; i++) {//离线保存所需查询
		cin >> a[i];
		if (i >= 2) {//相邻点对
			q[a[i]].push_back(a[i - 1]);
			q[a[i - 1]].push_back(a[i]);
		}
		if (i >= 3) {//间隔点对
			q[a[i]].push_back(a[i - 2]);
			q[a[i - 2]].push_back(a[i]);
		}
	}

	for (long long i = 1; i <= n; i++) {//tarjan算法初始化
		fa[i] = i;
	}

	tarjan(1);//预处理出所求LCA

	for (long long i = 2; i <= k; i++) {//按原访问顺序的路径权值前缀和
		ans[i] = ans[i - 1] + get_dis(a[i], a[i - 1]);
	}

	for (long long i = 1; i <= k; i++) {//分段得出答案
		if (i == 1) {
			cout << ans[k] - ans[2] << " ";
		} else if (i == k) {
			cout << ans[k - 1] << " ";
		} else {
			cout << ans[i - 1] + get_dis(a[i - 1], a[i + 1]) + ans[k] - ans[i + 1] << " ";
		}
	}
	return 0;
}
```

提交，AC，然后这篇题解就结束了~~果然写题解好难~~。

---

## 作者：liumuyunC2026 (赞：2)

经过同机房大佬 [yuruilin2026](https://www.luogu.com.cn/user/1294410) 和 [Hootime](https://www.luogu.com.cn/user/1275540 ) 的帮助下成功 **AC** 了这道题。

# 做题思路

这道题是一道求树的点与点之间边的长度的题，很容易想到用 **LCA** 求解。

统计时，先按顺序将点队之间距离累加，记做 $ans$。$dist(i,j) = dist[i] + dist[j] - 2 \times dist[lca(i,j)]$ 。

遍历一遍。

1. 当 $i = 1$ 时，$ans = cnt- dist[1] - dist[2] + 2  \times dist[lca(1,2)]$。

2. 当 $i > 1$ 且 $i < k$ 时，$ans = cnt - 2 \times dist[i] + 2 \times dist[lca(i-1,i)] + 2 \times dist[lca(i,i+1)] - 2 \times dist[lca(i-1,i+1)]$。

3. 当 $i = k$ 时，$ans = cnt - dist[k-1] - dist[k] + 2 \times dist[lca(k-1,k)]$。

# 代码实现


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
struct Edge{
	int to,w,next;
}e[N];
int head[N],d[N],dist[N],st[N][21],x[N];
int n,k,u,v,w,cnt;
void dfs(int u)
{
	for(int j=1;j<=20;j++) st[u][j]=st[st[u][j-1]][j-1];
	for(int i=head[u];~i;i=e[i].next)
	{
		int v=e[i].to,w=e[i].w;
		if(v==st[u][0]) continue;
		st[v][0]=u,d[v]=d[u]+1,dist[v]=dist[u]+w;
		dfs(v);
	}
}
void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}
int lca(int x,int y)
{
	int k=log2(n);
	if(d[x]>d[y]) swap(x,y);
	for(int i=k;i>=0;i--)
	{
		if(d[st[y][i]]>=d[x]) y=st[y][i];
	}
	if(x==y) return x;
	for(int i=k;i>=0;i--)
	{
		if(st[x][i]!=st[y][i]&&st[x][i]&&st[y][i]) x=st[x][i],y=st[y][i];
	}
	return st[x][0];
}
signed main()
{
	memset(head,-1,sizeof(head));
	memset(dist,0,sizeof(dist));
	memset(d,0,sizeof(d));
	
	cin>>n>>k;
	for(int i=1;i<n;i++)
	{
		cin>>u>>v>>w;
		add(u,v,w),add(v,u,w);
	}
	d[1]=1;
	dfs(1);
	int ans=0;
	for(int i=1;i<=k;i++) cin>>x[i];
	for(int i=2;i<=k;i++) ans=ans+dist[x[i-1]]+dist[x[i]]-2*dist[lca(x[i-1],x[i])];
	for(int i=1;i<=k;i++)
	{
		if(i==1) cout<<ans-dist[x[1]]-dist[x[2]]+2*dist[lca(x[1],x[2])]<<" ";
		else if(i!=k)
			cout<<ans-dist[x[i-1]]-2*dist[x[i]]-dist[x[i+1]]+2*dist[lca(x[i],x[i-1])]+2*dist[lca(x[i],x[i+1])]+dist[x[i-1]]+dist[x[i+1]]-2*dist[lca(x[i-1],x[i+1])]<<" ";
		else cout<<ans-dist[x[k-1]]-dist[x[k]]+2*(dist[lca(x[k-1],x[k])]);
	}
}
```

---

## 作者：Erik_Aoi (赞：2)

### 题意：
给出一个 $n$ 节点的带权树和一个长度为 $k$ 的原始路径 $route$，要求对于路径中每个点 $i$，求移去该点时所需的总代价。 

### 思路：
1. 注意到数据规模为 $10^5$，因此当算法时间复杂度为 $O(n\log n)$ 时可以解决问题。  
   对于一个含 $k$ 个路径点的路径，对每个路径点 $i$，只需计算：
   - 相邻的 $route[i-1]$ 到 $route[i]$ 的距离 $cost[i]$；
   - 跳过中间点（即 $route[i-2]$ 直接到 $route[i]$）的距离 $jump[i]$。

2. 这时候遍历每个路径点 $route[i]$ 时，就可以分三种情况计算总代价：
   $$ans(i)=\begin{cases}
   \sum_{j=3}^{k} cost[j], &i=1,\\
   \sum_{j=2}^{k-1} cost[j], &i=k,\\
   \sum_{j=2}^{i-1} cost[j]+jump[i+1]+\sum_{j=i+2}^{k} cost[j], &2\le i\le k-1.
   \end{cases}$$

3. 为了高效计算区间内 $cost$ 的累加和：
   - 构造前缀和数组 $pre$，使得查询区间和的时间复杂度为 $O(1)$。
   - 使查询两点间距离的复杂度为 $O(\log n)$，总体时间复杂度为 $O(k\log n)$。

4. 因此，使用**倍增**求解最近公共祖先和两点距离：
   - 选取任意节点（这里选节点 $1$）作为根节点，通过 DFS 计算每个节点到根节点的总距离 $dis[i]$。
   - 构造倍增数组，其转移方程为：  
     $$fa[cur][i]=fa[fa[cur][i-1]][i-1]$$
   - 两点 $u$ 和 $v$ 的距离为：  
     $$dis[u]+dis[v]-2\cdot dis[LCA(u,v)]$$
   - 构造倍增数组时间复杂度为 $O(n\log n)$，查询复杂度为 $O(k\log n)$，总时间复杂度为 $O((n+k)\log n)$。


```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define int long long

using namespace std;

vector<pair<int, int>> e[100005];
int n, m, k;
int fa[100005][25] = { 0 };
int dep[100005] = { 0 };

int route[100005] = { 0 };
int dis[100005] = { 0 };
int jump[100005] = { 0 };
int pre[100005] = { 0 };

void dfs(int cur, int from) {
    fa[cur][0] = from;
    dep[cur] = dep[from] + 1;

    for (int i = 1; i <= 24; i++) {
        fa[cur][i] = fa[fa[cur][i - 1]][i - 1];
    }

    for (auto [u, w] : e[cur]) {
        if (u == from) continue;
        dis[u] = dis[cur] + w;
        dfs(u, cur);
    }
}

int lca(int x, int y) {
    if (dep[x] > dep[y]) swap(x, y);
    int dis = dep[y] - dep[x];
    for (int i = 0; dis; i++, dis >>= 1) {
        if (dis & 1) y = fa[y][i];
    }
    if (x == y) return y;
    for (int i = 24; i >= 0; i--) {
        if (fa[x][i] != fa[y][i]) {
            x = fa[x][i], y = fa[y][i];
        }
    }
    return fa[y][0];
}

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> k;
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({ v,w });
        e[v].push_back({ u,w });
    }
    for (int i = 1; i <= k; i++) cin >> route[i];
    dfs(1, 1);

    //pre[i]表示从route[1]依次到route[i]的总花费，jump[i]表示从route[i-2]跳到route[i]的花费。
    for (int i = 2; i <= k; i++) {
        int x = route[i - 1], y = route[i];
        int fa = lca(x, y);
        pre[i] = pre[i - 1] + dis[x] + dis[y] - 2 * dis[fa];
        if (i + 1 <= k) {
            int z = route[i + 1];
            fa = lca(x, z);
            jump[i + 1] = dis[x] + dis[z] - 2 * dis[fa];
        }
    }

    for (int i = 1; i <= k; i++) {
        int ans = 0;
        if (i == 1) ans = pre[k] - pre[2];
        else if (i == k) ans = pre[k - 1];
        else ans = pre[i - 1] + jump[i + 1] + pre[k] - pre[i + 1];
        cout << ans << " ";
    }

    return 0;
}

```
### 关于优化（主要集中在 LCA）：

可以使用**欧拉序列 RMQ** 来 $ O(1) $ 查找父亲节点。因为本蒟蒻只会 ST 表，时间复杂度约为 $ O(n \log n + k) $；又因为该欧拉序列的大小是 $ 2n $，而 $ k\leq n $，因此反倒会因为常数较大比倍增慢。

**欧拉序列**：[提交记录](https://www.luogu.com.cn/record/209430738)

**朴素 tarjan 并查集**能做到比倍增更优，但同欧拉序列一样，常数较大，不如重链剖分：[提交记录](https://www.luogu.com.cn/record/209624695)

**重链剖分**可以把时间复杂度降到 $ O(n + k\log n) $：[提交记录](https://www.luogu.com.cn/record/209576509)

最后，**不必构建前缀和数组**。只需先求出完整走完的总花费，然后求移去某个节点后变化的花费即可。

以下是重链剖分且省去前缀和数组的代码，代码复杂度、时间复杂度和空间复杂度都较优：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#define int long long

using namespace std;

vector<pair<int, int>> e[100005];
int n, m, k;
int dep[100005] = { 0 };
int fa[100005] = { 0 };
int siz[100005] = { 0 };
int son[100005] = { 0 };
int top[100005] = { 0 };

int route[100005] = { 0 };
int dis[100005] = { 0 };
int jump[100005] = { 0 };
int to[100005] = { 0 };

void dfs1(int cur) {
    siz[cur] = 1;
    for (auto [u, w] : e[cur]) {
        if (dep[u]) continue;
        dis[u] = dis[cur] + w;
        dep[u] = dep[cur] + 1;
        fa[u] = cur;
        dfs1(u);
        siz[cur] += siz[u];
        if (siz[u] > siz[son[cur]]) son[cur] = u;
    }
}

void dfs2(int cur, int t) {
    top[cur] = t;
    if (!son[cur]) return;
    dfs2(son[cur], t);
    for (auto [u, w] : e[cur]) {
        if (u != son[cur] and u != fa[cur]) dfs2(u, u);
    }
}

int lca(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]]) x = fa[top[x]];
        else y = fa[top[y]];
    }
    return dep[x] < dep[y] ? x : y;
}

int getsum(int x, int y) {
    int fa = lca(x, y);
    return dis[x] + dis[y] - 2 * dis[fa];
}

signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> k;
    for (int i = 1; i <= n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({ v,w });
        e[v].push_back({ u,w });
    }
    for (int i = 1; i <= k; i++) cin >> route[i];
    dep[1] = 1;
    dfs1(1);
    dfs2(1, 1);

    int sum = 0;

    for (int i = 2; i <= k; i++) sum += to[i] = getsum(route[i - 1], route[i]);
    
    for (int i = 1; i <= k; i++) {
        int ans = 0;
        if (i == 1) ans = sum - to[i + 1];
        else if (i == k) ans = sum - to[i];
        else ans = sum - to[i] - to[i + 1] + getsum(route[i - 1], route[i + 1]);
        cout << ans << " ";
    }
    return 0;
}

```

---

## 作者：collegiate (赞：1)

### Soulution

首先我们先从数据开始模拟，我们把树画下来：

![](https://cdn.luogu.com.cn/upload/image_hosting/wztstltd.png)

我们知道，对于一个树上的**边类型**的前缀和，节点 $x$ 到节点 $y$ 的计算公式为：

$$dis_{x \to y} = sum_x + sum_y - 2sum_{LCA_{x,y}}$$

而这道题的答案 $ans_i$ 我们可以写为：

$$ans_i = dis_{1 \to 2} + dis_{2 \to 3} + \cdots + dis_{i-2 \to i-1} + dis_{i-1 \to i+1} + \cdots + dis_{k-1 \to k} $$

可以发现，累加的时候是跳过了 $dis_{i-1 \to i} + dis_{i \to i+1}$ 的，因为题目要求，那么我们就可以考虑先算出所有路径之和，再算答案就可以了。

我们记所有路径的和为 $cnt$，那么对于一个 $ans_i$，我们就可以得出：

$$ans_i = cnt - (dis_{i-1 \to i} + dis_{i \to i+1}) + dis_{i-1 \to i+1}$$

**但是请注意**！当 $i=1$ 或者 $i=k$ 的时候，**只用删减一条边**即可！

所以综上所述，对于 $ans_i$ 有：

$$ans_i = \begin{cases}
cnt -  dis_{1 \to 2} , & a = 1 \\
cnt - (dis_{i-1 \to i} + dis_{i \to i+1}) + dis_{i-1 \to i+1} ,& 1 < n < k \\
cnt -  dis_{k-1 \to k} , & i=k
\end{cases}$$

所以代码就可以写出来了，但是建议写一个函数计算两个节点之间的距离，否则很难调代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
struct node{
	ll next,to,dis;
}edge[N<<1];
ll head[N],cnt;
ll p[N],dep[N],sum[N];
ll fa[N][25];
ll n,k,x,y,z,ans,out;

void add(ll from,ll to,ll dis){
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].dis=dis;
	head[from]=cnt;
}
void dfs(ll x,ll father){
	dep[x]=dep[father]+1;
	fa[x][0]=father;
	for(int i=1;i<=20;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i=head[x];i;i=edge[i].next){
		if(edge[i].to==father) continue;
		sum[edge[i].to]=sum[x]+edge[i].dis;//处理前缀和
	    dfs(edge[i].to,x);
	} 
	return ;
}
ll LCA(ll x,ll y){//LCA模板
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) if(dep[x]-dep[y]>=(1<<i)) x=fa[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
ll dist(ll x,ll y){
	return sum[x]+sum[y]-2*sum[LCA(x,y)];
}
int main(){
	cin>>n>>k;
	for(int i=1;i<n;i++){
		cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z);
	}
	dep[1]=1;
	dfs(1,0);
	for(int i=1;i<=k;i++) cin>>p[i];
//	for(int i=1;i<=n;i++) cout<<sum[i]<<' ';
	
	for(int i=2;i<=k;i++){
		ans+=dist(p[i], p[i-1]);//统计原本路径和
//		cout<<dist(p[i], p[i-1])<<' '<<sum[p[i]]+sum[p[i-1]]-2*sum[LCA(p[i],p[i-1])]<<endl;
	} 
	for(int i=1;i<=k;i++){
		if(i==1) out=ans-dist(p[1],p[2]);
		else if(i!=k) out=ans-dist(p[i],p[i-1])-dist(p[i],p[i+1])+dist(p[i-1],p[i+1]);
		else out=ans-dist(p[k-1],p[k]);
		cout<<out<<' ';
	}
	return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：0)

# P9245 [蓝桥杯 2023 省 B] 景区导游 题解

[题目传送门](https://www.luogu.com.cn/problem/P9245)

## 题目分析

我们可以先将不跳过任何一点的时间算出来。对于一个被跳过的点 $A_i$，总时间就会减去 $A_{i-1}$ 到 $A_i$ 和 $A_i$ 到 $A_{i+1}$ 的时间并加上 $A_{i-1}$ 到 $A_{i+1}$ 的时间。因为跳过一个点**仅会导致**它前后的点发生变化。

### 求总时间
我们可以知道，在树上任意两点间的路径是**唯一**的。

所以在求两点间的距离时，我们可以先用 DFS 将每一个点到根结点（任意一个结点都可以作为根）的距离（即时间），并求出两点的 LCA（最近公共祖先）。

通过计算，我们可以得到以下公式：（$dis$ 为两点间距离，$len$ 为到根结点的距离，$A$ 为两点的 LCA）  
$$dis_{u \to v} = len_u + len_v - 2 \times len_A$$

代码如下：  

```cpp
void dfs(int u,int f){ // prt[u][p] 表示 u 点的上 2^p 代祖先
	prt[u][0] = f,dep[u] = dep[f] + 1;
	for(int p = 1;(1 << p) <= dep[u];p++)
		prt[u][p] = prt[ prt[u][p-1] ][p-1]; // 倍增求出

	for(int i = head[u];i;i = edges[i].nxt){
		int v = edges[i].v,w = edges[i].w;
		if(v == f) continue; 
		len[v] = len[u] + w; // 到根结点的距离
		dfs(v,u);
	}
}

inline int get_lca(int u,int v){ // 倍增求 LCA
	if(dep[u] < dep[v]) swap(u,v);
	for(int p = 18;p >= 0;p--)
		if(dep[u] - dep[v] >= (1 << p)) u = prt[u][p];
	if(u == v) return u;

	for(int p = 18;p >= 0;p--)
		if(prt[u][p] != prt[v][p]) u = prt[u][p],v = prt[v][p];
	return prt[u][0];
}

inline int dist(int u,int v){ return len[u] + len[v] - 2*len[get_lca(u,v)]; } // 求两点距离

```

### 跳过一点
在开始我们就提到了，跳过一点仅会改变它前后的距离。

对于开始与结束的两个点，我们要特殊操作：  
* 对于开始的点 $A_1$，我们**仅**会减去 $A_1$ 到 $A_2$ 的距离。
* 对于结束的点 $A_K$，我们**仅**会减去 $A_{K-1}$ 到 $A_K$ 的距离。

而其它的点 $A_i(2 \le i \le k-1)$ 则会减去 $A_{i-1}$ 到 $A_i$ 和 $A_i$ 到 $A_{i+1}$ 的时间并加上 $A_{i-1}$ 到 $A_{i+1}$ 的时间。

代码如下：  

```cpp
for(int i = 1;i <= m;i++)
		cout << sum -((i == m)? 0: dist(a[i],a[i+1]))
					-((i == 1)? 0: dist(a[i-1],a[i]))
					+((i == 1 || i == m)? 0: dist(a[i-1],a[i+1])) << " ";
	
```


## 总结
本题考察 LCA 算法以及处理树上点的距离。

感谢您的阅读！

---

## 作者：LittleAcbg (赞：0)

题目意思还是很简单的。

首先，我们考虑一个原题简化的问题：如何求游览 $A_1,A_2,\dots,A_K$ 需要的摆渡车时间？

这个问题是比较简单的，先维护有边权的树上距离。首先，将题目的无根树转化为一棵有根树，可以直接以 $1$ 为根。

接着，我们 DFS 处理 $d[u]$，表示从根到 $u$ 的这条路径上所有边的边权和。考虑维护 LCA，那么树上距离的表达式就可以写成 $\operatorname{dist}(u,v)=d[u]+d[v]-2d[\operatorname{lca}(u,v)]$。

于是，游览 $A_1,A_2,\dots,A_K$ 需要的摆渡车时间就是 $\operatorname{dist}(A_1,A_2)+\operatorname{dist}(A_2,A_3)+\dots+\operatorname{dist}(A_{K-1},A_K)$。

处理该问题的时间复杂度为 $O(K\log N)$。

接下来我们就可以处理原问题了。

如果删除 $A_i$，考虑新的时间与原时间的差值，容易得到 $\operatorname{dist}(A_{i-1},A_{i+1})-\operatorname{dist}(A_{i-1},A_i)-\operatorname{dist}(A_i,A_{i+1})$。

特别地，$i=1$ 时差值为 $-\operatorname{dist}(A_1,A_2)$，$i=K$ 时差值为 $-\operatorname{dist}(A_{K-1},A_K)$。

每次的时间复杂度都是 $O(\log N)$，总时间复杂度 $O(K\log N)$，于是这道题就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; // 答案可能超出 int 的范围
const int N = 1e5+9;
int n,k,a[N],nE,hd[N],L,d[N],p[N][20],dep[N];
struct Edge {int to,w,nxt;} e[N * 2]; // 无向边，空间开两倍
void add(int u, int v, int w) // 链式前向星加边
{
    e[++nE] = (Edge){v, w, hd[u]};
    hd[u] = nE;
}
void dfs(int u, int fa) // DFS 预处理 d,p,dep
{
    dep[u] = dep[fa] + 1; // 处理深度
    p[u][0] = fa; // 存父节点
    for (int i = 1; i <= L; ++i) p[u][i] = p[p[u][i - 1]][i - 1]; // 处理倍增
    for (int i = hd[u]; i; i = e[i].nxt) // 枚举所有边
    {
        int v = e[i].to,w = e[i].w;
        if (v == fa) continue; // 不能向父节点递归
        d[v] = d[u] + w; // 处理 d 数组
        dfs(v, u); // 递归
    }
}
int LCA(int u, int v) // 倍增求 LCA 模板
{
    if (dep[u] < dep[v]) swap(u, v); // 令 u 为更深的节点
    int diff = dep[u] - dep[v]; // 深度差
    for (int i = L; i >= 0; --i) if (diff >> i & 1) u = p[u][i]; // 先让 u 和 v 在同一深度
    if (u == v) return u; // 同一位置时直接跳出
    for (int i = L; i >= 0; --i) if (p[u][i] != p[v][i]) u = p[u][i], v = p[v][i]; // 贪心爬树
    return p[u][0]; // 两个结点的父节点相同，即为答案
}
int dist(int u, int v) {return d[u] + d[v] - 2 * d[LCA(u, v)];} // 树上距离
int main()
{
    scanf("%d%d", &n, &k); // 输入 N,K
    for (int i = 1,u,v,t; i < n; ++i) // n-1 条边
    {
        scanf("%d%d%d", &u, &v, &t); // 输入两端和时间
        add(u, v, t); // 加双向边
        add(v, u, t);
    }
    for (int i = 1; i <= k; ++i) scanf("%d", &a[i]); // 输入景点
    L = log(n) / log(2); // 存储 log2(n) 的值
    dfs(1, 0); // DFS 预处理 d,p,dep
    ll sum = 0; // 先算不删除景点的答案（即原答案）
    for (int i = 1; i < k; ++i) sum += dist(a[i], a[i + 1]);
    for (int i = 1; i <= k; ++i) // 枚举删除的景点
    {
        int delta; // 定义差量
        if (i == 1) delta = -dist(a[1], a[2]);
        else if (i == k) delta = -dist(a[k - 1], a[k]); // 两种特殊情况处理
        else delta = dist(a[i - 1], a[i + 1]) - dist(a[i - 1], a[i]) - dist(a[i], a[i + 1]);
        printf("%lld ", sum + delta); // 用原答案加上差量就是新问题的答案
    }
    return 0;
}
```

---

## 作者：yihang2011 (赞：0)

### [P9245 [蓝桥杯 2023 省 B] 景区导游](https://www.luogu.com.cn/problem/P9245)

LCA 求树上距离板子题。

前备知识：LCA 最近公共祖先。

题意：给定一棵 $N$ 个节点带边权的树以及一条树上的包含 $K$ 路径，第 $i$ 次询问需要跳过路径上的第 $i$ 个点，求剩下路径最小边权和。

首先需要知道对于树上点 $u$ 到点 $v$ 的距离，记 $dis_i$ 为第 $1$ 个点到第 $i$ 个点的最短距离，可以在 `dfs` 时与深度一同求出，记 $\text{lca}(u, v)$ 为点 $u$ 与点 $v$ 的最近公共祖先。那么点 $u$ 到点 $v$ 的距离 $\text{dist}(u, v) = dis_u + dis_v - 2 \times dis_{\text{lca}(u, v)}$。

对于第 $i$ 次询问，即跳过点 $a_i$，路径变为 $a_1 \rightarrow a_2 \rightarrow \cdots \rightarrow a_{i - 1} \rightarrow a_{i + 1} \rightarrow \cdots \rightarrow a_k$，对比原本路径 $a_1 \rightarrow a_2 \rightarrow \cdots \rightarrow a_{i - 1} \rightarrow a_i \rightarrow a_{i + 1} \rightarrow \cdots \rightarrow a_k$ 可以发现，新路径比原路径少了 $a_{i - 1} \rightarrow a_i$ 和 $a_i \rightarrow a_{i + 1}$ 两条边，多了 $a_{i - 1} \rightarrow a_{i + 1}$ 一条边，设 $sum$ 为原本路径花费的时间，即 $\text{dist}(a_1, a_2) + \text{dist}(a_2, a_3) + \cdots + \text{dist}(a_{k - 1}, a_k)$，则第 $i$ 次询问的答案为 $sum - \text{dist}(a_{i - 1}, a_i) - \text{dist}(a_i, a_{i + 1}) + \text{dist}(a_{i - 1}, a_{i + 1})$。

特别地，对于第 $1$ 次询问，直接输出 $sum - \text{dist}(a_1, a_2)$；对于第 $k$ 次询问，直接输出 $sum - \text{dist}(a_{k - 1}, a_k)$。

时间复杂度 $\mathcal{O}(n \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e5 + 10;

int n, k;
int a[N];
struct edge {
	int to, nxt, w;
} e[2 * N];
int head[N], dep[N], f[N][25], dis[N];
int tot, sum;

void add_edge(int u, int v, int w) {
	e[++tot].to = v;
	e[tot].w = w;
	e[tot].nxt = head[u];
	head[u] = tot;
}

void dfs(int u, int pa, int w) {
	dis[u] = dis[pa] + w;
	dep[u] = dep[pa] + 1;
	f[u][0] = pa;
	for (int i = 1; i <= 20; i++) {
		f[u][i] = f[f[u][i - 1]][i - 1];
	}
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (v == pa) {
			continue ;
		}
		dfs(v, u, e[i].w);
	}
}

int lca(int u, int v) {
	if (dep[u] < dep[v]) {
		swap(u, v);
	}
	for (int i = 20; i >= 0; i--) {
		if (dep[f[u][i]] >= dep[v]) {
			u = f[u][i];
		}
	}
	if (u == v) {
		return u;
	}
	for (int i = 20; i >= 0; i--) {
		if (f[u][i] != f[v][i]) {
			u = f[u][i], v = f[v][i];
		}
	}
	return f[u][0];
}

int dist(int u, int v) {
	int a = lca(u, v);
	return dis[u] + dis[v] - 2 * dis[a];
}

signed main() {
	cin >> n >> k;
	for (int i = 1, u, v, w; i < n; i++) {
		cin >> u >> v >> w;
		add_edge(u, v, w);
		add_edge(v, u, w);
	}
	dfs(1, 0, 0);
	for (int i = 1; i <= k; i++) {
		cin >> a[i];
	}
	for (int i = 2; i <= k; i++) {
		sum += dist(a[i], a[i - 1]);
	}
	cout << sum - dist(a[1], a[2]) << " ";
	for (int i = 2; i < k; i++) {
		cout << sum - dist(a[i - 1], a[i]) - dist(a[i], a[i + 1]) + dist(a[i - 1], a[i + 1]) << " ";
	}
	cout << sum - dist(a[k - 1], a[k]) << endl;
	return 0;
}
```

[十年 OI 一场空，不开 `long long` 见祖宗。](https://www.luogu.com.cn/record/218649856)

[AC Record](https://www.luogu.com.cn/record/218652553)

---

## 作者：Meickol (赞：0)

挺简单的题，十五分钟切了。

LCA + 树上前缀和 + 枚举，按题意模拟即可。

先算出原本游览 $k$ 个景点需要的总时间记为 $sum$。

然后依次枚举跳过 $i$ 号景点，更新一下距离即可。

比较简单就不多作解释了，计算两点之间的时间使用的是树上前缀和思想统计两点间的边前缀和，$dist_i$ 表示从 $1$ 号点出发到达 $i$ 号点的距离前缀和。

具体思路实现可见代码。

时间复杂度 $\mathcal O(n \log n)$。

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
typedef long long LL;
const int N=1e5+5,M=N*2;
int n,k;
int e[M],ne[M],h[N],w[M],idx;
void add(int a,int b,int c){
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
int order[N];
int dep[N],fa[N][25];
LL dist[N];
void dfs(int u,int father){
	if(father==-1) dep[u]=1;
	else dep[u]=dep[father]+1,fa[u][0]=father;
	rep(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(j==father) continue;
		dist[j]=dist[u]+w[i];
		dfs(j,u);
	}
}
int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	per(i,20,0) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	if(u==v) return v;
	per(i,20,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
void solve(){
	memset(h,-1,sizeof h);
	cin>>n>>k;
	rep(i,1,n-1){
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c);
		add(b,a,c);
	}
	dfs(1,-1);
	rep(i,1,k) cin>>order[i];
	LL sum=0;
	rep(i,1,k-1){
		int x=order[i],y=order[i+1];
		int anc=lca(x,y);
		int d=dist[x]+dist[y]-dist[anc]*2;
		sum+=d;
	}
	rep(i,1,k){ // 跳过 i 点
		LL tmp=sum;
		if(i-1>=1){
			int x=order[i];
			int y=order[i-1];
			int anc=lca(x,y);
			LL d=dist[x]+dist[y]-dist[anc]*2;
			tmp-=d;
		}
		if(i+1<=k){
			int x=order[i];
			int y=order[i+1];
			int anc=lca(x,y);
			LL d=dist[x]+dist[y]-dist[anc]*2;
			tmp-=d;
		}
		if(i-1>=1 && i+1<=k){
			int x=order[i-1];
			int y=order[i+1];
			int anc=lca(x,y);
			LL d=dist[x]+dist[y]-dist[anc]*2;
			tmp+=d;
		}
		cout<<tmp<<" ";
	}
}
```

---


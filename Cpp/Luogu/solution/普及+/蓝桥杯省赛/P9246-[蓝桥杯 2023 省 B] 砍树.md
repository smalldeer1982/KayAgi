# [蓝桥杯 2023 省 B] 砍树

## 题目描述

给定一棵由 $n$ 个结点组成的树以及 $m$ 个不重复的无序数对 $\left(a_{1},b_{1}\right),\left(a_{2},b_{2}\right),\ldots,\left(a_{m},b_{m}\right)$，其中 $a_{i}$ 互不相同，$b_{i}$ 互不相同，$a_{i} \neq b_{j}(1 \leq i,j \leq m)$。

小明想知道是否能够选择一条树上的边砍断，使得对于每个 $\left(a_{i},b_{i}\right)$ 满足 $a_{i}$ 和 $b_{i}$ 不连通，如果可以则输出应该断掉的边的编号 (编号按输入顺序从 $1$ 开始)，否则输出 `-1`。


## 说明/提示

**【样例说明】**

断开第 $2$ 条边后形成两个连通块：$\{3,4\},\{1,2,5,6\}$，满足 $3$ 和 $6$ 不连通，$4$ 和 $5$ 不连通。

断开第 $4$ 条边后形成两个连通块：$\{1,2,3,4\},\{5,6\}$，同样满足 $3$ 和 $6$ 不连通，$4$ 和 $5$ 不连通。

$4$ 编号更大，因此答案为 $4$。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，保证 $1<n \leq 10^3$。

对于 $100 \%$ 的数据，保证 $1<n \leq 10^{5}$，$1 \leq m \leq \frac{n}{2}$。

蓝桥杯 2023 省赛 B 组 J 题。

## 样例 #1

### 输入

```
6 2
1 2
2 3
4 3
2 5
6 5
3 6
4 5
```

### 输出

```
4```

# 题解

## 作者：_LogicFish_ (赞：7)

这道题挺不错的，我尽量简洁易懂地把这题讲清楚。
## 题意简述
给定 $n$ 个节点组成的树和 $m$ 个点对，去掉树上的一条边使这 $m$ 组点不连通，输出这条边的编号。如果多条边都可行，输出编号最大的。  
## 思路分析
先把树画出来，再把 $m$ 组点之间的路径描出来，就会发现问题的关键点：
**连接两个点的路径一定经过它们的 LCA**。  
再重新读题，注意到只需**一条边**就可以切断 $m$ 条路径，换句话说，
**这 $m$ 条路径都经过了这条边**。  
那么我们要做的就很简单了，统计每条边都被经过了多少次，输出经过次数等于 $m$ 的所有边中，编号最大的那条。  
可是一条边一条边的计数会跑到 $O(nm)$ ，炸的没边。我们需要一种一次就可以处理出来所有边的算法：**树上差分**。
### 前置内容：LCA
LCA 可以用倍增快速得到。概括来说就是先让两个点跳到同一深度，之后一起往上跳，如果节点往上跳 $2^i$ 个节点后仍不一样就跳，否则不动。最后，两个点一定会停在它们的 LCA 的子节点上，返回它们的父节点即可。
```cpp
int LCA(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--) //往上跳2^i步
		if(dep[x]-(1<<i)>=dep[y]) //x的深度还是深于y
			x=fa[x][i]; //跳
	if(x==y) return x; //特判
	for(int i=20;i>=0;i--) //一起跳
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
```
### （边的）树上差分
对边树上差分和对点差分略微不同。对于边，我们用 $tag_i$ 表示从根节点到第 $i$ 号节点的路径数。  
容易得到：新增一条从 $u$ 到 $v$ 的路径，只需要 $tag_u+1, tag_v+1, tag_{LCA(u,v)}-2$ 即可，如下图，蓝边表示加路径，红边表示减，对应了我们对 $tag$ 数组的加减操作：
![](https://cdn.luogu.com.cn/upload/image_hosting/me2hxvwq.png)  
不难发现，从 $u$ 到 $v$ 的路径与根节点到这两点的路径和之间，只多了根节点到它们的 LCA 的路径的两倍，减去即可。最后，只需要从根节点开始往上累加就能得到经过这条边的次数，就像对普通差分数组累和求得原来的数字一样。
## 完整代码
其它细节见注释
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
#define pii pair<int,int>
const int MAX = 1e5+5;

int n,m,ans=-1;
//邻接表存图，第一个数是点,第二个数是边的编号
vector<pii>mp[MAX];
//tag[]用于差分, dep[]存节点深度, fa[i][j]表示i号点往上跳2^j的点
int tag[MAX],dep[MAX],fa[MAX][25];
//sideid[a]=b表示第b条边的儿子是a, 这样存储具有唯一性
int sideid[MAX];
//dfn[i]=x:DFS序(搜索到的第x号点编号为i), nfd将dfn的键值反过来存
int dfn[MAX],nfd[MAX],ord;
void dfs(int x,int pre);
int LCA(int x,int y);
signed main(){
    while(1) RP++;
	cin>>n>>m;
	int m2=m;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
        //无向图
		mp[u].push_back(pii(v,i)),mp[v].push_back(pii(u,i));
	}
    //建树
	dfs(1,0);
	while(m--){
		int u,v;
		cin>>u>>v;
		int lca=LCA(u,v);
        //差分
		tag[u]++,tag[v]++,tag[lca]-=2;
	}
    //直接对tag[]数组前缀和
    //最后搜索到的点一定是叶子,所以按DFS序的逆序操作
	for(int i=n;i>0;i--){
		int id=nfd[i];
        //父节点的值 加上 它的子节点的值
		tag[fa[id][0]]+=tag[id];
	}
	for(int i=1;i<=n;i++)
		if(tag[i]==m2) //符合条件的边
			ans=max(ans,sideid[i]);
	cout<<ans;
 	return 0;
}
void dfs(int x,int pre){
    //预处理部分
	dep[x]=dep[pre]+1,fa[x][0]=pre;
	dfn[x]=++ord;nfd[ord]=x;
	for(int i=1;i<=20;i++)
		fa[x][i]=fa[fa[x][i-1]][i-1];
	for(pii y:mp[x]){
		if(y.first==pre) continue;
        //按子节点编号 存储 边的编号
		sideid[y.first]=y.second;
		dfs(y.first,x);
	}
}
int LCA(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--)
		if(dep[x]-(1<<i)>=dep[y])
			x=fa[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
/*
附赠额外数据(Ans = 7)
8 4
1 2
1 8
2 3
3 5
3 6
7 4
2 4

7 2
3 7
4 5
6 7
*/
```

---

## 作者：_xzhdsnh1364 (赞：3)

# SOLUTION
这道题和[松鼠的新家](https://www.luogu.com.cn/problem/P3258)都是树上差分，只不过松鼠的新家是基于点的，这道题是基于边的，那这样，显而易见的，差分数组的变化就会不一样，只要这两个点公共祖先代表的差分数组减 $2$ 就行了，因为和基于点的不一样，边不用考虑重复的问题。

回到本题，这题我们先把 $a_i$ 和 $b_i$ 之间的路进行差分处理，然后遍历还原，最后对几条边进行遍历，如果它被 $m$ 条路径覆盖了，则统计，没有任何满足的边，就输出 $-1$。

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n , m , a[N] , b[N] , x[N] , y[N] , dep[N] , fa[N][20] , ans[N] , id[N];
vector<int>g[N];
void dfs(int x , int fat){
    fa[x][0] = fat;
    dep[x] = dep[fat] + 1;
    for(int i = 1;i <= 19;i++)fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for(int i = 0;i < g[x].size();i++){
        if(g[x][i] == fat)continue;
        dfs(g[x][i] , x);
    }
}
int LCA(int a , int b){
    if(dep[a] < dep[b])swap(a , b);
    for(int i = 19;i >= 0;i--){
        if(dep[fa[a][i]] >= dep[b])a = fa[a][i];
    }
    if(a == b)return a;
    for(int i = 19;i >= 0;i--){
        if(fa[a][i] == fa[b][i])continue;
        a = fa[a][i] , b = fa[b][i];
    }
    return fa[a][0];
}
void fans(int x , int fat){
	for(int i = 0;i < g[x].size();i++){
        if(g[x][i] == fat)continue;
        fans(g[x][i] , x);
        ans[x] += ans[g[x][i]];
    }
}
int main(){
	cin >> n >> m;
	for(int i = 1;i < n;i++){
		cin >> x[i] >> y[i];
		g[x[i]].push_back(y[i]);
		g[y[i]].push_back(x[i]);
	}
    for(int i = 1;i <= m;i++)cin >> a[i] >> b[i];
	dfs(1 , 0);
	for(int i = 1;i <= m;i++){
		int x = a[i] , y = b[i];
		int z = LCA(x , y);
		ans[z] -= 2;
		ans[x]++;
		ans[y]++;
	}
	fans(1 , 0);
	for(int i = n - 1;i;i--){
        if(fa[x[i]][0] == y[i]){
            if(ans[x[i]] == m){
                cout << i;
                return 0;
            }
        }else{
            if(ans[y[i]] == m){
                cout << i;
                return 0;
            }
        }
    }
    cout << -1;
	return 0;
}

---

## 作者：lht006128 (赞：2)

### 题解

**首先分析题目**
+ 要求我们判断删掉树上的一条边，使得所有的 $a$ 与对应的 $b$ 不连通。

我们看看删掉边的情况：
1. 所有的 $a$ 和 $b$ 不在一个子树，删掉其中一个子树上面的边可以分开。
2. $a$ 和 $b$ 在一个子树，则删掉中间 $ab$ 相接的那条边（这里需要 $a$ 与 $a$ 连在一起（$a$ 和 $a$ 连的方式可以在一个子树，也可以分开，不影响），否则无解）。

![1744175127469.png](https://pic.yearcode.cn/i/2025/04/09/67f5ffa102ee7.png)

![1744174682618.png](https://pic.yearcode.cn/i/2025/04/09/67f5fde47208d.png)

我们可以发现，当删除某一条边时，它下方连接的子树必须包含所有的 $a$ 或者所有的 $b$，并且不能混合。那么我们可以如何表示呢？  

我们可以给每个节点赋值：  
- 若节点是 $a$，则 $\text{val} = 1$；  
- 若节点是 $b$，则 $\text{val} = -1$；  
- 否则 $\text{val} = 0$。  

然后进行树形 DP（动态规划），设 $\text{dp}[u]$ 表示以 $u$ 为根的子树的所有节点 $\text{val}$ 之和，即：  
$$
\text{dp}[u] = \text{val}[u] + \sum_{v \in \text{children}(u)} \text{dp}[v]
$$  
当且仅当 $|\text{dp}[u]| = m$（即子树全是 $a$ 或全是 $b$）时，该节点 $u$ 到其父节点的边可以被删除。最终我们取满足条件的边中编号最大的一个。

代码如下：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
int dp[100010];
int num[100010];
int f;
int ans = -1;
struct Node
{
    int t;
    int id;
};
vector<Node> shu[100010];

void dfs(int t, int fa)
{
    dp[t] = 0;
    if (num[t] != 0)
        dp[t] = num[t];

    for (int i = 0; i < shu[t].size(); i++)
    {
        int j = shu[t][i].t;
        if (j == fa)
            continue;
        dfs(j, t);

        dp[t] += dp[j];
    }

    if (abs(dp[t]) == m)
    {
        f = 1;

        for (int i = 0; i < shu[t].size(); i++)
        {
            int j = shu[t][i].t;
            if (j == fa)
            {
                // cout << shu[t][i].id << " " << t;
                ans = max(ans, shu[t][i].id);
                break;
            }
        }
    }
}
signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n - 1; i++)
    {
        int x, y;
        cin >> x >> y;

        shu[x].push_back({y, i});
        shu[y].push_back({x, i});
    }
    int tm = m;
    while (tm--)
    {
        int x, y;
        cin >> x >> y;
        num[x] = 1;
        num[y] = -1;
    }

    dfs(1, 0);
    cout << ans;
    return 0;
}

---

## 作者：litangzheng (赞：2)

### 前言：  

你需要先做 P10931。

### 思路：  

很显然，在树上割断一条边要使两个点不连通，必须要割断两个点路径上的边（路径指两个点的最短路径，也就是从出发点到两个点的 LCA，再到终点）。  
于是我们考虑暴力：将所有点对路径上的边都加一，最后哪条边被加了 $m$ 次就是我们想要的答案。  
可是这样肯定超时，又注意到这个过程能用树上差分优化，于是这题就变成了边差分的模板。  

### 代码：  


```cpp
#include<bits/stdc++.h>
#define N 100005
#define MAXN 20
using namespace std;
int n,m,head[N],cnt=1,sum[N],cha[N],fa[N][MAXN],deep[N],ans;
bool vis[N];
struct Edge{
	int to,nxt;
}edge[N*2];
void addedge(int u,int v){
	edge[cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt++;
}
void dfs(int x,int fath){
	vis[x]=1;
	deep[x]=deep[fath]+1;fa[x][0]=fath;
	for(int i=1;i<=MAXN;i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
	for(int i=head[x];i;i=edge[i].nxt){
		if(!vis[edge[i].to]) sum[edge[i].to]=(i+1)/2;//好好想想为什么可以(i+1)/2得出边的编号。
		if(!vis[edge[i].to]) dfs(edge[i].to,x);
	}
}
int LCA(int x,int y){
	if(deep[x]<deep[y]) swap(x,y);
	for(int i=MAXN-1;i>=0;i--) if(deep[fa[x][i]]>=deep[y]) x=fa[x][i];
	if(x==y) return y;
	for(int i=MAXN-1;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}//LCA
void dfs2(int x,int fath){
    for(int i=head[x];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(to==fath) continue;
        dfs2(to,x);
        cha[x]+=cha[to];
    }
    if(cha[x]==m&&x!=1) ans=max(ans,sum[x]);//注意1不算。
}//最后的统计
int main(){
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		addedge(u,v);addedge(v,u);
	}
	dfs(1,0);
	for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		int l=LCA(a,b);
		cha[a]++;
		cha[b]++;
		if(l!=1) cha[l]-=2;
		else cha[l]--;//边差分与点差分的不同点。
	}
	dfs2(1,0);
    if(ans==0) cout<<-1;//如果没有答案输出负1。
	else cout<<ans;
}
```

---

## 作者：gghack_Nythix (赞：2)

## 前言：

不知道。

## 分析：

注意到对于一条边，如果其被所有路径经过，则说明这一条边满足题目要求。当然这个路径是简单路径。

那么考虑怎么维护每个边被经过的次数，容易想到可以对边进行树上差分，具体的，对于一个二元组 $(a_i,b_i)$，对他们所在的边进行差分，当然对于一个点 $i$，这个边应该是 dfs 序更小的那个和 $i$ 直接连接的点 $j$ 与 $i$ 组成的边。

那么你就这样差分一下再树上前缀和统计一下答案就做完了。

```cpp
# include <bits/stdc++.h>
# define pb push_back
using namespace std;
const int N = 2e5 + 5;
int n , m , dis[N] , f[21][N] , dep[N] , cur , df[N] , rm;
vector <int> g[N];
map <pair<int , int> , int> mp , id;
map < int , pair<int , int> > mp2;
int getid (int x) { return mp[{x , f[0][x]}]; }
void prd (int now , int fa) {
    mp[{now , fa}] = mp[{fa , now}] = ++cur , mp2[cur] = {now , fa};
    dis[now] = dis[fa] + g[now].size() , dep[now] = dep[fa] + 1;
    f[0][now] = fa;
    for (int j = 1;j <= 20;++j) f[j][now] = f[j - 1][f[j - 1][now]];
    for (auto x : g[now]) if (x != fa) prd (x , now);
}
int LCA (int x , int y) {
    if (dep[x] < dep[y]) swap (x , y);
    for (int j = 20;j >= 0;--j) if ((dep[x] - dep[y]) >> j & 1) x = f[j][x];
    if (x == y) return x;
    for (int j = 20;j >= 0;--j) if (f[j][x] != f[j][y]) x = f[j][x] , y = f[j][y];
    return f[0][x];
}
void sb (int now , int fa) { for (auto x : g[now]) if (x != fa) sb (x , now) , df[getid(now)] += df[getid(x)]; }
signed main () {
    cin >> n >> m , rm = m;
    for (int i = 1;i < n;++i) {
        int u , v;
        cin >> u >> v , g[u].pb (v) , g[v].pb (u) , id[{v , u}] = id[{u , v}] = i;
    }
    prd (1 , 0);
    while ( m-- ) {
        int u , v;
        cin >> u >> v;
        df[getid(u)] ++ , df[getid(v)] ++;
        df[getid(LCA(u , v))] -= 2;
    }
    sb (1 , 0);
    int ans = -1;
    for (int i = 2;i <= cur;++i) if (df[i] == rm) ans = max (ans , id[mp2[i]]);
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：Sunset_afterglow (赞：1)

很水的题目。

# 题目大意

找一条边使得所有的 $a_i$ 到 $b_i$ 的路径中一定包含了这条边。

# 思路

树上差分秒了，这边建议先写一下树上差分的 [板子](https://www.luogu.com.cn/problem/P3258)。  
把从 $a_i$ 到 $b_i$ 的路径上经过的点的权值都加上 $1$，最有判断每一条边的左右端点权值是否都等于 $m$，若都等于 $m$，那说明这条边符合最终答案的设定。加上 $1$ 的这一过程很明显是一个树上差分，因为他只有最后的一次询问，在线的话，建议树链剖分。好的，差分的时间复杂度明显是正确的，所以写代码吧。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
  int x = 0 ,f = 1;
  char ch = getchar();
  while(ch < '0' || ch > '9') {
    if(ch == '-')f = -1;
    ch = getchar();
  }
  while(ch >= '0' && ch <= '9') {
    x = (x << 3) + (x << 1) + (ch & 15);
    ch = getchar();
  }
  return x * f;
}
const int N = 4e5 + 5;
int n ,m ,q ,fa[N][35] ,dep[N] ,a[N] ,num[N];
vector<int> vt[N];
void dfs(int x ,int father) {
  dep[x] = dep[father] + 1;
  fa[x][0] = father;
  for(int i = 1;i <= 30;++ i) fa[x][i] = fa[fa[x][i - 1]][i - 1];
  for(auto i: vt[x]) {
    if(i == father) continue;
    dfs(i ,x);
  }
  return ;
}
int LCA(int x ,int y) {
  if(dep[x] < dep[y]) swap(x ,y);
  for(int i = 30;i >= 0;-- i) {
    if(dep[fa[x][i]] >= dep[y]) {
      x = fa[x][i];
    }
  }
  if(x == y) return x;
  for(int i = 30;i >= 0;-- i) {
    if(fa[x][i] != fa[y][i]) {
      x = fa[x][i];
      y = fa[y][i];
    }
  }
  return fa[x][0];
}
void getsum(int u ,int father) {
  for(auto i: vt[u]) {
    if(i == father) continue;
    getsum(i ,u);
    num[u] += num[i];
  }
  return ;
}
map<int ,pair<int ,int> >mp;
signed main() {
  n = read() ,m = read();
  for(int i = 1 ,u ,v ,w;i < n;++ i) {
    u = read() ,v = read();
    vt[u].push_back(v);
    vt[v].push_back(u);
    mp[i] = make_pair(u ,v);
  }
  dfs(1 ,0);
  for(int i = 1 ,x ,y;i <= m;++ i) {
    x = read() ,y = read();
    int lt = LCA(x ,y);
    -- num[fa[lt][0]];
    -- num[lt];
    ++ num[x];
    ++ num[y];
  }
  getsum(1 ,0);
  for(int i = n - 1;i >= 1;-- i) {
    if(num[mp[i].first] == m && num[mp[i].second] == m) {
      cout << i;
      return 0;
    }
  }
  cout << -1;
  return 0;
}
```

---

## 作者：ZZA000HAH (赞：1)

# 砍树

## 题目大意

给出一棵树（$n$ 个顶点，$n-1$ 条边）和一些无序数对 $(a_i,b_i),a_i,b_i \in [1,n]$，其中 $a_i,b_i$ 是树上的顶点，让找出一条编号最大的边，满足删去后所以无序数对中的 $a_i$ 顶点与 $b_i$ 顶点不相连通，不能相互到达。

## 题目分析

解决思路：直观分析，找出所有（最短）路径 $a_i \to b_i \text{或} b_i \to a_i $ 都经过的边即可。

这里用到的算法为**最近公共祖先（LCA）**和**树上差分**。

## 最近公共祖先 LCA

基础知识见：[LCA](https://oi-wiki.org/graph/lca/)。

建议先完成：[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)。

### 最近公共祖先的用处

要找出**最短**路径 $a_i \to b_i \text{或} b_i \to a_i $，就要找到 $a_i$ 和 $b_i$ 的最近公共祖先，因为最短路径即 $a_i \to lca(a_i,b_i) + lca(a_i,b_i) \to b_i \text{或} b_i \to lca(a_i,b_i) + lca(a_i,b_i) \to a_i$。

### 树上差分

基础知识见：[差分--树上差分](https://blog.csdn.net/ID246783/article/details/125014484?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522c4b9f978440a1013e07149333b8ef34e%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=c4b9f978440a1013e07149333b8ef34e&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-2-125014484-null-null.142^v102^pc_search_result_base9&utm_term=%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86&spm=1018.2226.3001.4187)。

树上差分（边差分）算法：

$$ c_i = c_i + w , c_j = c_j + w $$

$$c_{lca(i,j)} = c_{lca(i,j)} - 2 \times w $$

其中，$ c_x $ 数组表示节点 $x$ 与其父节点相连的边出现的次数，记为这条边的边权。

对于本题就是：

$$ c_i = c_i + 1 , c_j = c_j + 1 $$

$$c_{lca(i,j)} = c_{lca(i,j)} - 2 $$

但我们可以改变一下，使用 $e_x$ 数组记录节点 $x$ 的出现次数，用 $c_x$ 数组记录节点 $x$ 与其父节点相连的边的出现次数，由恒成立关系 $c_x = e_x$ 我们可以对点权进行加减操作，再赋值给边权，即

$$ e_i = e_i + 1 , e_j = e_j + 1 $$

$$ e_{lca(i,j)} = e_{lca(i,j)} - 2 $$

$$ e_{fa_i} = e_{fa_i} + e_i $$

$$ c_i = e_i $$

其中，$fa_i$ 表示节点 $i$ 的父节点。

差分后可以通过 dfs 遍历树来求每条边的边权，但差分后往回加应该是父节点加子节点的点权，子节点的点权转移到与父节点相连的边的边权上。

也可以通过每个点的深度来判断父子关系，从而使（同上）父节点加子节点的点权，子节点的点权转移到与父节点相连的边的边权上。

最后，边权等于 $m$ 且编号最大的边即为所求，$ans$ 初始化为 $-1$ 更方便。

### AC Code 记录深度

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int n,m,t,f[N][25],d[N],c[N],e[N],p[N],ans=-1;//c[]--边权,e[]--点权,d[]--深度,p[]--与父节点相连的边的编号
vector<pair<int,int>>G[N];
vector<int>k;
queue<int>q;
void bfs()
{
	q.push(1);//根节点指定为 1 即可
	d[1]=1;
	while (q.size()>0)
	{
		int x=q.front();
		q.pop();
		for (auto [y,id] : G[x])
			if (!d[y])
			{
				d[y]=d[x]+1;
				f[y][0]=x;
				p[y]=id;
				for (int j=1; j<=t; j++)
					f[y][j]=f[f[y][j-1]][j-1];//lca 预处理
				q.push(y);
			}
	}
}
int lca(int x,int y)
{
	if (d[x]>d[y]) swap(x,y);
	for (int i=t; i>=0; i--)//需要逆向进行
		if (d[f[y][i]]>=d[x])
			y=f[y][i];
	if (x==y) return x;//注意返回
	for (int i=t; i>=0; i--)
	{
		if (f[y][i]!=f[x][i])//不等于,下面返回 f[x][0]
			y=f[y][i],x=f[x][i];
	}
	return f[x][0];
}
int main()
{
	scanf("%d%d",&n,&m);
	t=ceil(log(n)/log(2));//亦可 ceil(log2(n))
	for (int i=1; i<n; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back({y,i});
		G[y].push_back({x,i});
	}
	memset(d,0,sizeof d);
	bfs();
	for (int i=0; i<m; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		e[x]++,e[y]++;
		e[lca(x,y)]-=2;//边差分
	}
	for (int i=1; i<=n; i++) k.push_back(i);
	sort(k.begin(),k.end(),[&](int x,int y){return d[x]>d[y];});//深度排序
	for (int i : k)
	{
		if (i==1) continue;
		e[f[i][0]]+=e[i];//父节点加子节点点权
		c[p[i]]=e[i];//子节点点权转移到与父节点相连的边的边权上
	}
	for (int i=1; i<n; i++)//可逆向,找到立即 break
		if (c[i]==m) ans=i;
	printf("%d",ans);
	return 0;
}
```

### AC Code dfs


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int n,m,t,f[N][25],d[N],c[N],e[N],ans=-1;//c[]--边权,e[]--点权,d[]--深度
vector<int>G[N];
queue<int>q;
map<string,int>mp;//存边的编号
void bfs()
{
	q.push(1);//根节点指定为 1 即可
	d[1]=1;
	while (q.size()>0)
	{
		int x=q.front();
		q.pop();
		for (int y : G[x])
			if (!d[y])
			{
				d[y]=d[x]+1;
				f[y][0]=x;
				for (int j=1; j<=t; j++)
					f[y][j]=f[f[y][j-1]][j-1];//lca 预处理
				q.push(y);
			}
	}
}
int lca(int x,int y)
{
	if (d[x]>d[y]) swap(x,y);
	for (int i=t; i>=0; i--)//需要逆向进行
		if (d[y]-d[x]>>i&1) 
			y=f[y][i];
	if (x==y) return x;//注意返回
	for (int i=t; i>=0; i--)
	{
		if (f[y][i]!=f[x][i])//不等于,下面返回 f[x][0]
			y=f[y][i],x=f[x][i];
	}
	return f[x][0];
}
void dfs(int x,int fa)
{
	for (int y : G[x])
	{
		if (y==fa) continue;//由 fa 转移来的
		dfs(y,x);//先递归
		e[x]+=e[y];//父节点加子节点点权
		c[mp[to_string(x)+"to"+to_string(y)]]=e[y];//子节点点权转移到与父节点相连的边的边权上
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	t=ceil(log2(n));
	for (int i=1; i<n; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);//正反存图
		mp[to_string(x)+"to"+to_string(y)]=i;
		mp[to_string(y)+"to"+to_string(x)]=i;
	}
	bfs();
	for (int i=0; i<m; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		e[x]++,e[y]++;
		e[lca(x,y)]-=2;//边差分
	}
	dfs(1,0);
	for (int i=1; i<n; i++)//可逆向,找到立即 break
		if (c[i]==m) ans=i;
	printf("%d",ans);
	return 0;
}
```

---

#### TLE LCA 朴素 dfs 求边权

~~（初代代码）~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int n,m,f[N][25],d[N],ind[N],root,a[N],b[N],fl,ans=-1,t;
vector<int>G[N],k;
queue<int>q;
map<string,int>mp1,mp2;
void bfs_root()
{
	for (int i=1; i<=n; i++)
		if (ind[i]==1) q.push(i),ind[i]--;
	while (q.size()>0)
	{
		int x=q.front();
		q.pop();
		root=x;
		for (int y : G[x])
			if (--ind[y]==1) q.push(y);
	}
}
void bfs()
{
	q.push(root);
	d[root]=1;
	while (q.size()>0)
	{
		int x=q.front();
		q.pop();
		for (int y : G[x])
			if (!d[y])
			{
				d[y]=d[x]+1;
				f[y][0]=x;
				for (int j=1; j<=t; j++)
					f[y][j]=f[f[y][j-1]][j-1];
				q.push(y);
			}
	}
}
int lca(int x,int y)
{
	if (d[x]>d[y]) swap(x,y);
	for (int i=t; i>=0; i--)
		if (d[y]-d[x]>>i&1)
			y=f[y][i];
	if (x==y) return x;
	for (int i=t; i>=0; i--)
	{
		if (f[y][i]!=f[x][i])
			y=f[y][i],x=f[x][i];
	}
	return f[x][0];
}
void dfs(int x,int fa,int tar)
{
	if (x==tar)
	{
		for (int i=1; i<=n; i++)
			b[i]+=a[i];
		fl=1;
		return;
	}
	for (int y : G[x])
	{
		if (fl) return;
		if (y==fa) continue;
		a[mp1[to_string(x)+"to"+to_string(y)]]++;
		dfs(y,x,tar);
		a[mp1[to_string(x)+"to"+to_string(y)]]--;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	t=ceil(log(n)/log(2));
	for (int i=1; i<n; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
		ind[x]++,ind[y]++;
		mp1[to_string(x)+"to"+to_string(y)]=i;
		mp1[to_string(y)+"to"+to_string(x)]=i;
	}
	bfs_root();
	//printf("%d",root);
	//memset(f,-1,sizeof f);
	memset(d,0,sizeof d);
	//q.clear();
	bfs();
	int tem=0,now;
	for (int i=0; i<m; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		k.push_back(x);
		k.push_back(y);
		now=lca(x,y);
		if (tem==0) tem=now;
		else tem=lca(tem,now);
	}
	for (int tar : k)
	{
		fl=0;
		memset(a,0,sizeof a);
		dfs(tem,0,tar);
	}
	for (int i=1; i<=n; i++)
	{
		//printf("%d\n",b[i]);
		if (b[i]==m&&i>ans) ans=i;
	}
	printf("%d",ans);
	return 0;
}
```

##### End。

---

## 作者：I_like_magic (赞：1)

这道题其实不难。

前置知识：LCA、树上差分。

我们发现，切断一条边即可断开所有点对的连接，那么断开的这条边一定是 $m$ 个点对的最短路径都经过的。

我们对每一对点对都求出 LCA，然后使用树上差分将 $a$ 与 $\text{lca}(a, b)$ 和 $a$ 与 $\text{lca}(a, b)$ 之间的路径的每一条边都 $cnt$ 加一。

最后我们只需要遍历这颗树。对每条 $cnt$ 等于 $m$ 的边的 $id$ 与 $ans$ 取最大值即可。

$ans$ 初始为 $-1$。

这里我使用树链剖分求解 LCA。

然后就是两个模板。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100005;
int n, m;
struct edge {
	int v, id;
};
vector<edge> vec[N];
int fa[N], son[N], deep[N], sz[N], top[N], cnt;
void dfs1(int u, int F, int d);
void dfs2(int u, int F, int s);
int lca(int a, int b);
int tree[N];
int ans = -1;
int dfs(int u, int F);
int main() {
	cin >> n >> m;
	for(int i = 1; i < n; i ++) {
		int u, v;
		cin >> u >> v;
		vec[u].push_back({v, i});
		vec[v].push_back({u, i});
	}
	dfs1(1, 0, 1);
	dfs2(1, 0, 0);
	for(int i = 1; i <= m; i ++) {
		int a, b;
		cin >> a >> b;
		int lc = lca(a, b);
		tree[lc] -= 2;
		tree[a] ++;
		tree[b] ++;
	}
	dfs(1, 0);
	cout << ans << "\n";
	return 0;
}
void dfs1(int u, int F, int d) {
	sz[u] = 1;
	deep[u] = d;
	fa[u] = F;
	int ma = 0;
	for(edge i : vec[u]) {
		int v = i.v;
		if(v == F) continue;
		dfs1(v, u, d + 1);
		sz[u] += sz[v];
		if(sz[v] > ma) {
			ma = sz[v];
			son[u] = v;
		}
	}
	return ;
}
void dfs2(int u, int F, int s) {
	if(s) top[u] = top[F];
	else top[u] = u;
	if(son[u]) {
		dfs2(son[u], u, 1);
	}
	for(edge i : vec[u]) {
		int v = i.v;
		if(v == F || v == son[u]) continue;
		dfs2(v, u, 0);
	}
	return ;
}
int lca(int a, int b) {
	while(top[a] != top[b]) {
		if(deep[top[a]] < deep[top[b]]) {
			swap(a, b);
		}
		a = fa[top[a]];
	}
	if(deep[a] < deep[b]) swap(a, b);
	return b;
}
int dfs(int u, int F) {
	int cnt = tree[u];
	for(edge i : vec[u]) {
		int v = i.v;
		if(v == F) {
			continue;
		}
		int k = dfs(v, u);
		if(k == m) ans = max(ans, i.id);
		cnt += k;
	}
	return cnt;
}
```

---

## 作者：Adam1101 (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P9246)

### 题意简述
给定一棵树和若干个数对 $ \left(a_i, b_i\right) $，要求删除**一条边**使得对于任意一个数对都有 $ a_i $ 和 $ b_i $ 不连通，不存在输出 `-1`。

### 思路
使 $ a_i $ 和 $ b_i $ 不连通的意思就是断开的那条边在 $ a_i $ 和 $ b_i $ 的简单路径上，于是我们在树上把每对
$ a_i $ 和 $ b_i $ 的简单路径上的每一条边都标记一次，最后选取一条被标记 $ n $ 次的编号最大的边即可。

### 怎么标记
用一个 **LCA + 树上差分** 即可，不懂的可以自行搜索。

### 接下来上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e5 + 10;
struct Edge { //链式前向星
    int to, nxt;
}e[N * 2];
int head[N];
int E;
int d[N]; //差分
int sum[N]; //前缀和
int mb[N]; //把边对应到点上
int dep[N]; //深度
int siz[N]; //子树大小
int f[N]; //父节点
int hson[N];
int top[N]; 
int D;

void add(int x, int y) { //连边
    E++;
    e[E].to = y;
    e[E].nxt = head[x];
    head[x] = E;
}

void dfs(int x, int fa) { //树剖
    f[x] = fa;
    dep[x] = dep[fa] + 1;
    siz[x] = 1;
    int maxn = 0;
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if (y == fa) continue;
        mb[y] = (i + 1) / 2;
        dfs(y, x);
        siz[x] += siz[y];
        if (siz[y] > maxn) {
            hson[x] = y;
            maxn = siz[y];
        }
    }
}

void dfs2(int x, int fa, int tp) { //树剖
    top[x] = tp;
    if (hson[x]) dfs2(hson[x], x, tp);
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if (y != hson[x] && y != fa) {
            dfs2(y, x, y);
        }
    }
}

void dfs_sum(int x, int fa) { //前缀和
    sum[x] = d[x];
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if (y == fa) continue;
        dfs_sum(y, x);
        sum[x] += sum[y];
    }
}

int LCA(int x, int y) { //LCA（我这里用的是树剖，大家也可以用倍增等其他方法）
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        x = f[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}

signed main() {
    int n, m, r = 1;
    cin >> n >> m;
    for (int i = 1; i < n; i++) {
        int x, y;
        cin >> x >> y;
        add(x, y);
        add(y, x);
    }
    dfs(r, 0);
    dfs2(r, 0, r);
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        int z = LCA(x, y);
        d[x]++; //差分
        d[z]--;
        d[y]++;
        d[z]--;
    }
    dfs_sum(r, 0);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (sum[i] > m || sum[i] == m && mb[i] > mb[ans]) ans = i;
    }
    if (ans == 0) { //不存在
        cout << -1 << "\n";
        return 0;
    }
    cout << mb[ans] << "\n"; //输出边的编号
    return 0;
}
```

---

## 作者：Meickol (赞：0)

不难发现，对于一棵树而言，若点 $a$ 和 $b$ 的路径上有任意一条边断开，那么 $a$ 和 $b$ 将不连通。

因此我们可以对这 $m$ 个无序数对 $(a_i,b_i)$，将点 $a_i$ 和 $b_i$ 的路径上所有的边都标记一次。

最后我们只需要在这棵树上找到一条边，如果这条边被标记了 $m$ 次，那么说明这条边是这 $m$ 个无序对对应路径都经过的边，将这条边断开即可保证这 $m$ 个无序数对每个 $\left(a_{i},b_{i}\right)$ 满足 $a_{i}$ 和 $b_{i}$ 不连通。

标记路径上的点可以使用树上差分，所以本题唯一难点就是如何求我们需要的那条边的编号。

本题由于是一棵树，因此对于每个结点而言只有一个父结点。

然后由于对边差分是将边**下放**到点上，因此如果点 $i$ 可行，则说明点 $i$ 和点 $i$ 父结点构成的边可行，那么你需要求的就是点 $i$ 和点 $i$ 父结点构成的边对应的输入编号。你会发现链式前向星在存图的过程中 $idx$ 其实就记录了边的编号。因此点 $i$ 和点 $i$ 父结点构成的边对应的输入编号可以在 LCA 前的 DFS 函数遍历边时记录。

程序实现如下
```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
const int N=1e5+5,M=N*2;
int n,k;
int e[M],ne[M],h[N],idx;
void add(int a,int b){
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int dep[N],fa[N][25];
int e_num_id[N]; // e_num_id[i] 记录 i 的父结点走向 i 的那条边是输入的第几条边
void dfs1(int u,int father){
	if(father==-1) dep[u]=1;
	else dep[u]=dep[father]+1,fa[u][0]=father;
	rep(i,1,20) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=h[u];~i;i=ne[i]){
		int j=e[i];
		if(j==father) continue;
		e_num_id[j]=(i+2)/2; // 记录走向 j 的边对应是输入的第几条边
		dfs1(j,u);
	}
}
int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	per(i,20,0) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	if(u==v) return v;
	per(i,20,0) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
int power[N]; // 记录点i与点i的父结点相连的边被无序数对覆盖的数量
void dfs2(int u,int father){
	for(int i=h[u];~i;i=ne[i]){
		int v=e[i];
		if(v==father) continue;
		dfs2(v,u);
		power[u]+=power[v];
	}
}
void solve(){
	memset(h,-1,sizeof h);
	cin>>n>>k;
	rep(i,1,n-1){
		int a,b;
		cin>>a>>b;
		add(a,b);
		add(b,a);
	}
	dfs1(1,-1);
	rep(i,1,k){ // 树上差分，每次将点x和点y路径上的点+1
		int x,y;
		cin>>x>>y;
		int anc=lca(x,y);
		power[x]++,power[y]++,power[anc]-=2;
	}
	dfs2(1,-1);
	int ans=-1;
	rep(i,2,n){
		if(power[i]==k) ans=e_num_id[i];
	}
	cout<<ans;
}
```

---

## 作者：algo_h (赞：0)

挺有意思的一题，目前还没有题解，写一个简要的题解吧。

树上任意两点之间的关键路径是唯一的且经过二者的 LCA。故切断两点之间的通路就是要在这条唯一的路径之上任意选择一条边进行切断。题中有多对点需要满足不连通条件，那么可行的断边方案就是每对点可行的断边方案的交集。考虑统计在题中 $m$ 条不连通点对约束下，每条边作为可行解的总次数，如果该次数等于 $m$，则该条边属于最终的可行解集，反之亦然。

计算 LCA 可以使用倍增或树剖（$O(n\log n)$）或 $O(n)$ 离线算法，统计次数（求交集）可以在树剖后使用树状数组/线段树（$O(m\log^2n)$），或使用树上差分（$O(n)$，不依赖于具体的 LCA 方案）。本题解以 树剖 + 树状数组 方案为例。

```c++
#include <iostream>
#include <vector>

using namespace std;

int n;
vector<vector<pair<int, int>>> neigh;
vector<int> eid, depth, parent, child, nmemb, id, head;

template<class T>
void reorder(vector<T> &v)
{
  int nv = v.size();
  vector<T> u(nv);
  for(int i = 0; i < nv; ++i) swap(u[id[i]], v[i]);
  swap(v, u);
}

void renumber(vector<pair<int, int>> &v)
{
  for(auto &[i, ei] : v) {
    if(i >= 0) i = id[i];
  }
}

void renumber(vector<int> &v)
{
  for(int &i : v) {
    if(i >= 0) i = id[i];
  }
}

void renumber()
{
  reorder(neigh);
  for(auto &v : neigh) renumber(v);
  reorder(eid);
  reorder(depth);
  reorder(parent), renumber(parent);
  reorder(child), renumber(child);
  reorder(nmemb);
  reorder(head), renumber(head);
}

void build_tree(int i, int p)
{
  depth[i] = p < 0 ? 0 : depth[p] + 1;
  parent[i] = p;
  child[i] = -1;
  nmemb[i] = 1;
  for(auto [j, ei] : neigh[i]) {
    if(j == p) continue;
    eid[j] = ei;
    build_tree(j, i);
    if(child[i] < 0 || nmemb[child[i]] < nmemb[j]) child[i] = j;
    nmemb[i] += nmemb[j];
  }
}

void build_head(int i)
{
  static int seq;
  id[i] = seq++;
  head[i] = i;
  if(parent[i] >= 0 && i == child[parent[i]]) head[i] = head[parent[i]];
  if(child[i] >= 0) build_head(child[i]);
  for(auto [j, ei] : neigh[i]) {
    if(j == parent[i]) continue;
    if(j == child[i]) continue;
    build_head(j);
  }
}

class BIT {
public:
  BIT() { }
  BIT(int nv) { v.resize(nv + 1); }
  void Add(int i, int a)
  {
    for(++i; i <= n; i += (i & -i)) v[i] += a;
  }
  int Sum(int i) const
  {
    int s = 0;
    for(++i; i; i &= (i - 1)) s += v[i];
    return s;
  }

private:
  vector<int> v;
};

BIT bit;

void inc(int i, int j)
{
  bit.Add(i, 1);
  if(j + 1 < n) bit.Add(j + 1, -1);
}
int get(int i) { return bit.Sum(i); }

void mark_disconn(int u, int v)
{
  while(head[u] != head[v]) {
    if(depth[head[u]] >= depth[head[v]]) {
      inc(head[u], u);
      u = parent[head[u]];
    } else {
      inc(head[v], v);
      v = parent[head[v]];
    }
  }
  if(u == v) return;
  if(u > v) swap(u, v);  // u < v
  inc(u + 1, v);
}

int main()
{
  int m;
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> m;

  neigh.resize(n);
  for(int i = 0; i < n - 1; ++i) {
    int u, v;
    cin >> u >> v, --u, --v;
    neigh[u].emplace_back(v, i), neigh[v].emplace_back(u, i);
  }
  eid.resize(n), depth.resize(n), parent.resize(n), child.resize(n), nmemb.resize(n), id.resize(n), head.resize(n);
  build_tree(0, -1);
  build_head(0);
  renumber();

  bit = BIT(n);
  for(int i = 0; i < m; ++i) {
    int u, v;
    cin >> u >> v, --u, --v, u = id[u], v = id[v];
    mark_disconn(u, v);
  }

  int ans = -1;
  for(int i = 1; i < n; ++i) {
    if(get(i) != m) continue;
    ans = max(ans, eid[i] + 1);
  }
  cout << ans << endl;
  return 0;
}
```

由于上面对数状数组的访问中修改和查询是完全分开的，故也可以直接使用普通数组替换。

---


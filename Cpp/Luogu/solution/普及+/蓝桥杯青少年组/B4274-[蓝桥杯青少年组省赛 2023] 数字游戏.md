# [蓝桥杯青少年组省赛 2023] 数字游戏

## 题目背景

我觉得这题数据造的可能有问题，欢迎贡献正确的 std 和更强的数据。

## 题目描述

老师给出了一组数，要求小蓝对这组数进行调整，调整的规则如下：  
1. 第 $1$ 次，从这组数中选出一个最小的数，把它调整为和第二小的数一样大；  
2. 第 $2$ 次，再从这组数中选出一个最大的数，把它调整为和第二大的数一样大；  
3. 重复执行 $1$、$2$ 步骤；  
4. 当这组数中所包含的不同的数少于 $3$ 个时，结束调整。  

现在给定了一组数，请帮小蓝编写程序计算出总共的调整次数，以及调整结束时这组数中的最小数和最大数。  

**例 1：**  

当这组数是 $2,2,2,2$ 时，这组数中所包含的不同的数少于 $3$ 个（只有 $2$ 这一种数），无需调整，最后输出：

$$\boxed{0\quad 2\quad 2}$$

**例 2：**  

当这组数是 $1,3,4,2$ 时，调整过程如下：  
1. 先将这组数中最小的数 $1$，改成 $2$，这组数变为：$2,3,4,2$；
2. 再将这组数中最大的数 $4$，改成 $3$，这组数变为：$2,3,3,2$；

这时，这组数中只包含 $2$、$3$ 两个数了，满足规则 $4$，调整结束，总共调整了 $2$ 次，故最后输出：  

$$\boxed{2\quad 2\quad 3}$$

## 样例 #1

### 输入

```
4
1 3 4 2```

### 输出

```
2 2 3```

# 题解

## 作者：Yxa_Sheep (赞：8)

## 题意
操作一：将最大值变成次大值，操作二：将最小值变成次小值。重复执行这两个操作，直到只剩两个不同数字。
## 思路
一开始我用模拟，TLE 了，[30](https://www.luogu.com.cn/record/220540067)。然后在 dalao 的提示下想到先用结构体存储每个数组出现的次数，然后在一次清空所有最大值与最小值。首先将每个数出现的次数存入 $book$ 数组（和桶排序差不多），然后用一个结构体存储每个数组和他的出现次数，把 $book$ 数组的内容转移过来，方便查找。用 $x$ 表示结构体中第一个数字的下标，用 $y$ 表示结构体中最后一个数字的下标，每次清空的时候就把 $x$ 向后移一项或者把 $y$ 向前移一项，直到只剩下 $x$ 所指向的数和 $y$ 所指向的数就可以结束并输出答案了。细节看代码。 
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, x = 1, y, k, book[1000010];//x为结构体a的起始位置(1),y为结构体的结束位置(长度)
long long ans;
struct node { int num, cnt; } a[1000010];//num存储这个数字,cnt存储这个数字出现的次数
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
		scanf("%d", &k), book[k]++;//数字k的出现次数加1
    for (int i = 1; i <= 1000000; i++)
        if (book[i])
            a[++y].num = i, a[y].cnt = book[i];//将book数组里的数据移到a里，在无形中排好序了
    while (y - x + 1 > 2)//如果a的长度(不同数字)大于2就继续
    {
        k = min(a[x].cnt, a[y].cnt);
        a[x].cnt -= k, a[x + 1].cnt += k, ans += k;//一次减去k个数，这里注意最小值减k个，而次小值要加k个，因为最小值变成次小值了
        if (!a[x].cnt)//如果最小值被减完了
        {
            x++;//移到下一位(原来的次小值)
            if (y - x + 1 <= 2)//如果a的长度(不同数组)小于等于2
            {
                printf("%lld %d %d", ans + k - 1, a[x].num, a[y].num);//输出答案，这里ans要加k减1，因为操作一和操作二是交替进行的
                return 0;//完美结束
            }
        }
        a[y].cnt -= k, a[y - 1].cnt += k, ans += k;//最大值的数量也减去k个
        if (!a[y].cnt)//如果最小值被减完了(原来的次大值)
        {
            y--;//移到前一位
            if (y - x + 1 <= 2)
			{
				printf("%lld %d %d", ans, a[x].num, a[y].num);//输出答案
				return 0;//完美结束
			}
        }
    }
    return 0;
}
```

完结!!!题解来之不易，且看且珍惜。

---

## 作者：rabbit_mygo (赞：4)

## 前言
提供一个二分的思路。
## 题目描述
给定有 $n$ 个元素的序列 $a$。  
按如下顺序操作：  
选取一个**最小**的数，将它变为**次小**的数。  
选取一个**最大**的数，将它变为**次大**的数。  
求使序列中不同元素小于 $3$ 个的最小操作次数。  
数据范围：$1 \leq n,a_i \leq 1e6$
## 思路分析
先排序。  
我们可以把相同元素合并，并维护他们的出现次数。  

答案是满足单调性的，即操作次数越多越容易满足题目要求，考虑二分操作次数，判断二分的操作次数是否合法。

试图维护 $C_i$ 表示转移到第 $i$ 个元素的前缀代价，$D_i$ 为转移到第 $i$ 个元素的后缀代价（分别对应第一个操作和第二个操作，同时这里的元素是合并后的元素，所有元素的大小均不同）。  
发现如果维护前缀出现次数 $A_i$，后缀出现次数 $B_i$，那么有转移：$C_i = C_{i-1}+A_{i-1}$，$D_i = D_{i+1}+B_{i+1}$。  
以前缀为例，比如说已经转移到第 $i-1$ 个元素，现在要转移到第 $i$ 个元素，那么第 $i-1$ 个元素之前的元素应该都被操作 $1$ 变成第 $i-1$ 个元素那么大了，所以答案会多累加 $A_{i-1}$。  
后缀同理。  

时间复杂度 $O(n \log n+ \log L \log n)$，其中 $L$ 为答案的值域。  
由于$1 \leq a_i \leq 1e6$，也可以用桶排可以优化到 $O(n+S+ \log L \log n)$，其中 $S = \max_{1 \leq i \leq n}\{a_i\}$。

具体细节看代码吧。
## 代码实现
```cpp
#include <cstdio>
#include <algorithm>
typedef long long ll;
inline void output(ll x){// 快输 
	if(x>9)output(x/10);
	putchar(x%10^48);
}
inline int readx(){// 快读 
	int x = 0,y = 1;char c = getchar();
	for(;c<48||c>58;c = getchar())if(c=='-')y = -1;
	for(;c>=48&&c<=58;c = getchar())x = (x<<1)+(x<<3)+(c^48);
	return x*y; 
} 
const int N = 1e6+10;
int a[N],b[N],n,i,j,mx,g[N];
int A[N],B[N];
ll C[N],D[N];
bool flg;
inline bool check(ll mid){
	i = std::lower_bound(C+1,C+1+mx,mid)-C,j = std::lower_bound(D+1,D+1+mx,mid)-D;
	//查找当前操作次数左边最多能到达第几个元素，右边最多能到达第几个元素 
	if(mid<C[i]&&i>1)--i;if(mid<D[j]&&j>1)--j;// 细节：调整下标
	j = mx-j+1;// 翻转下标对应后缀位置 
	if(j-i<2){// 细节：若当前操作次数合法，尝试减少 1 次操作 2 
		mid -= 1;
		int tj = std::lower_bound(D+1,D+1+mx,mid)-D; 
		if(mid<D[tj]&&tj>1)--tj;
		tj = mx-tj+1;
		flg = tj-i<2;
		if(flg)j = tj;
	}
	return j-i<2;
}
inline void ckmax(int& x,int y){x<y&&(x=y);}// 取最大值
int main(){
//	if(freopen("soyo1","r",stdin)==NULL)puts("err");
	n = readx();

	for(int i = 1;i <= n;i++)a[i] = readx();
	std::sort(a+1,a+1+n);
	for(int i = 1,pre = -1;i <= n;i++){
		if(pre!=a[i])++mx,pre = a[i];
		b[mx]++;
	}

//  桶排的输入 
//	int tmx=0;
//	for(int i = 1,t;i <= n;i++)a[t=readx()]++,ckmax(tmx,t);
//	for(int i = 1;i <= tmx;i++)if(a[i])b[++mx] = a[i],g[mx] = i;

  // 前缀和预处理 
	for(int i = 1;i <= mx;i++)A[i] = A[i-1]+b[i];//前缀出现次数
	for(int i = 1;i <= mx;i++)C[i] = C[i-1]+A[i-1];//前缀代价
	// 后缀和预处理 
	for(int i = mx;i >= 1;i--)B[i] = B[i+1]+b[i];
	for(int i = mx;i >= 1;i--)D[i] = D[i+1]+B[i+1];
	std::reverse(D+1,D+1+mx);// 翻转后缀数组以方便查找
	// 二分答案
	ll dl = 0,dr = C[mx]+1>>1,mid,ans,ti,tj;
	bool ansflg;
	while(dl<=dr){
		mid = dl+dr>>1;
		if(check(mid))ti = i,tj = j,ans = mid,ansflg = flg,dr = mid-1;
		else dl = mid+1;
	}
	// 输出答案 
	output((ans<<1)-ansflg),putchar(' '),output(a[A[ti]]),putchar(' '),output(a[A[tj]]);

	//桶排的输出 
	//output((ans<<1)-ansflg),putchar(' '),output(g[ti]),putchar(' '),output(g[tj]);

	return 0;
}
````
最后祝您：万事如意！（q'w'q）

---

## 作者：CRZ_AK_DZG (赞：4)

# B4274 数字游戏
## 1. 思路分析
### 题目大意：
进行若干次操作，第一次将 $1$ 个最大值变为次大值，第二次将 $1$ 个最小值变为次小值，直到不同的数少于 $3$ 个时，输出操作次数、剩下最大值和剩下最小值。

由于数字会重复出现，我们可以同时改变多个最大值和最小值代替模拟一次次操作，以此减轻时间复杂度。


---


## 2. 时间复杂度分析
最坏情况：当 $N=10^6$  ，且每一个数不一样，每次同时改变 $1$ 个最大值和 $1$ 个最小值，需要操作 $\frac{N-2}{2}=499,999$ 次，不难看出时间复杂度为 $O(n)$ ，简直完美。


---


## 3. 代码细节
1. 由于题目优先改变最大值，所以要注意当仅有 $1$ 个最大值和 $2$ 种不同的数时，无需同时与最小值一起改变，只需单独改变最大值即可。（详情见代码特判部分）
2. **十年 OI 一场空，不开 long long 见祖宗**。当 $N=10^6$ 且每一个数不一样时，答案约为 
$$2\sum_{i=1}^{\frac{N-2}{2}}i=2\times\frac{(5\times 10^5-1)\times5\times10^5}{2}$$
$$=25\times10^{10}-5\times10^5$$
明显超过 int 类型的最大值 $2^{31}-1$ 即 $2147483647$ ，所以使用 long long 存答案。

 
### 代码:
```cpp
#include<bits/stdc++.h>
#define int long long //无脑 long long 太爽了
using namespace std;
const int N = 1e6+5;
int n, m, idx, ans, vis[N];
struct node{
	//x为数值 t为次数的出现次数
	int x, t;
} a[N];
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> m;
		vis[m]++; //同标记出现次数
	}
	for(int i = 1; i <= 1e6; i++){
		//用vis数组维护a
		if(vis[i]) idx++, a[idx].x = i, a[idx].t = vis[i];
	}
	int l = 1, r = idx;
	while(r-l+1 >= 3){
		int tmp = min(a[l].t, a[r].t); //取左右出现次数最小值
		a[l].t -= tmp, a[l+1].t += tmp, ans += tmp; //左边减去最小值，并维护ans
		if(a[l].t == 0){ //当 a[l].t > a[r].t 时减去剩余的
			l++;
			if(r-l+1 < 3){//特判
				ans+= tmp-1;
				break;
			}
		}
		//右边同理
		a[r].t -= tmp, a[r-1].t += tmp, ans += tmp;
		if(a[r].t == 0){
			r--;
			if(r-l+1 < 3) break;
		}
	}
	cout << ans << ' ' << a[l].x << ' ' << a[r].x; //输出答案，收工~
	return 0;
}
```

---


# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$，$0\leq t,x_{i1},y_{i1},x_{i2},y_{i2},x_{i3},y_{i3},T_i\leq 500$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# 题解

## 作者：_jimmywang_ (赞：68)

### ~~口胡五分钟，代码两小时！~~

这个题啊，真是好写，也不好写。

好写呢，在于建个图，再跑一遍$Floyd$，比较最小值，就没了

不好写呢，就在于：

1.每个矩形只给了3个点.....

2.代码长（可能不是），相近的变量多（这是我）等等

来一步一步分析吧。。。

### $0.$题意:

~~（略）~~

### $1.$建图

#### $(1).$找到矩形的另外$1$个点

这个东西咋找呢？用亿点初中几何知识知道矩形是平行四边形，而平行四边形是对角线互相平分的。

如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ohht6xr0.png)

其中，点$A,B,C$为输入的点，$D$是所求的点，对角线交点为$P$

这个例子中，$BC$是一条对角线，$AD$是另一条。根据中点公式，可以得到

 $$\begin{cases}x_P=\dfrac{x_B+x_C}{2}\\x_P=\dfrac{x_A+x_D}{2}\end{cases}$$
$$\begin{cases}y_P=\dfrac{y_B+y_C}{2}\\y_P=\dfrac{y_A+y_D}{2}\end{cases}$$

所以可得
$$\begin{cases}x_D=x_B+x_C-x_A\\y_D=y_B+y_C-y_A\end{cases}$$

于是， 我们再用勾股定理判断一下哪两个点构成对角线，然后就能求出这个点啦！

#### $(2).$建图
这里我们发现题目给了两种路线，一种是城市之间的航空路线，一种是城市内部的公路。

所以建图的主要问题就在于判断两个点是否在同一城市内。

这个问题，要靠你标点的方式确定，此处就举本人的例子来说明。

我的想法是第$1$个城市标号$1,2,3,4$,第$2$个城市标号$5,6,7,8$,以此类推。

那么这些点的标号与对应的城市号有什么关系呢？

经过研究发现，若点的编号为$i$,则它对应的城市编号即为$(i-1)/4$（下取整）

于是这样就行了。

### $2.$最短路

$emmm$，一看数据范围，$s \leq 100$

所以最多只有$400$个点，$O(n^3)$都能过。

那么$O(n^3)$的最短路是啥？$Floyd$啊~

跑一遍$Floyd$，然后求一下$A$的每个机场到$B$的每个机场的最小值就过了~


完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
const ll inf=0x7f7f7f7f;
ll s,A,B,TTT;
double ans=inf,t,dis[410][410];
double x[410],y[410],T[110];
double diss(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double ds(double x1,double y1,double x2,double y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}
int main() {
    scanf("%lld",&TTT);
    while(TTT--){
        memset(dis,0,sizeof(dis)),ans=inf;
        scanf("%lld%lf%lld%lld",&s,&t,&A,&B);
        f(i,1,s){
            scanf("%lf%lf%lf%lf%lf%lf%lf",&x[(i-1)*4+1],&y[(i-1)*4+1],&x[(i-1)*4+2],&y[(i-1)*4+2],&x[(i-1)*4+3],&y[(i-1)*4+3],&T[i]);
            double dab=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+2],y[(i-1)*4+2]);
            double dac=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+3],y[(i-1)*4+3]);
            double dbc=ds(x[(i-1)*4+2],y[(i-1)*4+2],x[(i-1)*4+3],y[(i-1)*4+3]);
            if(dab+dac==dbc)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+3]-x[(i-1)*4+1],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+3]-y[(i-1)*4+1];else
            if(dab+dbc==dac)x[i*4]=x[(i-1)*4+1]+x[(i-1)*4+3]-x[(i-1)*4+2],y[i*4]=y[(i-1)*4+1]+y[(i-1)*4+3]-y[(i-1)*4+2];else
            if(dbc+dac==dab)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+1]-x[(i-1)*4+3],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+1]-y[(i-1)*4+3];
        }
        f(i,1,s*4)f(j,1,s*4)if(i!=j){
                if((i-1)/4!=(j-1)/4)dis[i][j]=t*diss(x[i],y[i],x[j],y[j]);
                else dis[i][j]=T[(i-1)/4+1]*diss(x[i],y[i],x[j],y[j]);
            }
        f(k,1,s*4)f(i,1,s*4)f(j,1,s*4)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        f(i,1,4)f(j,1,4)ans=min(ans,dis[(A-1)*4+i][(B-1)*4+j]);
        printf("%.1lf\n",ans);
    }
	return 0;
}

```



---

## 作者：ShineEternal (赞：19)

这道题代码可真的不简单。。

## 题目链接：
https://www.luogu.org/problem/P1027

## 分析：

**注：这里面的点指机场而非城市**

这道题乍一看题目描述不难，其实就是一个最短路问题，不过就是起点可能有多个，终点也有多个，所以我们跑个Floyd就行。

- 但因为我怕$O(n^3)$跑不起，所以换成了$n$遍$dijkstra$(这里n☞点数)

所以时间复杂度为：$O(n^2log_n)$

- (dij用了堆优化

### 然后我们来到样例，发现还有毒瘤的预处理。

样例无良的给了矩形的三个点，说明第四个点可以根据前三个求出。

- 于是我们考虑到运用矩形对角线的一些性质。

- 首先找出距离最远的两个点（三个点中）

- 然后连线取中点（当然编程中不用连线那一步操作）

- 再将另外的第3个点（不在连线的两端）向中点连线，延长即可

```cpp
void find(double a,double b,double c,double d,double e,double f)//读入三个点的坐标，跑完函数就把第四个点的值赋完了
{
	cnt++;
	dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
	dis[1].id=1;
	dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
	dis[2].id=2;
	dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
	dis[3].id=3;
	sort(dis+1,dis+4,cmp);
	if(dis[1].id==1)
	{
		double x=min(a,c)+Abs(a-c)/2;
		double y=min(b,d)+Abs(b-d)/2;
		double xn=x+x-e;
		double yn=y+y-f;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==2)
	{
		double x=min(c,e)+Abs(e-c)/2;
		double y=min(f,d)+Abs(f-d)/2;
		double xn=x+x-a;
		double yn=y+y-b;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==3)
	{
		double x=min(a,e)+Abs(a-e)/2;
		double y=min(b,f)+Abs(b-f)/2;
		double xn=x+x-c;
		double yn=y+y-d;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
}
```

这样，就处理完了，最后，我们发现其实任意两点都有连接（要不航线要不铁路），所以处理出距离，在判断是否在一个城市，就可以找到每条路的价值。

- 跑dij即可


- 别忘了给点所在的城市打标记，这样最后方便找A和B

**这里引申出了一个惨痛的教训：结构体的存储方式要想好**

刚开始我是以一个城市为一个结构体，然后就特别难写，最后只好重构代码

## $code:$

```cpp
#include<cstdio>
#include<cmath>
#include<map>
#include<cstring>
#include<queue> 
#include<algorithm>
using namespace std;
#define pa pair<double,int>
int vis[4005];
priority_queue<pa,vector<pa>,greater<pa> > q;
struct point
{
	double x,y,T;
	int id;
}p[4005];
struct D
{
	double id;
	double num;
}dis[4];
double Sqr(int x)
{
	return x*x;
}
double cmp(const D &a,const D &b)
{
	return a.num>b.num;
}
double Abs(double x)
{
	if(x<0)return -x;
	return x;
}
int cnt=0;
void find(double a,double b,double c,double d,double e,double f)
{
	cnt++;
	dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
	dis[1].id=1;
	dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
	dis[2].id=2;
	dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
	dis[3].id=3;
	sort(dis+1,dis+4,cmp);
	if(dis[1].id==1)
	{
		double x=min(a,c)+Abs(a-c)/2;
		double y=min(b,d)+Abs(b-d)/2;
		double xn=x+x-e;
		double yn=y+y-f;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==2)
	{
		double x=min(c,e)+Abs(e-c)/2;
		double y=min(f,d)+Abs(f-d)/2;
		double xn=x+x-a;
		double yn=y+y-b;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
	if(dis[1].id==3)
	{
		double x=min(a,e)+Abs(a-e)/2;
		double y=min(b,f)+Abs(b-f)/2;
		double xn=x+x-c;
		double yn=y+y-d;
		p[cnt].x=xn;
		p[cnt].y=yn;
	}
}
double d[405][405],dist[405][405];
void dijkstra(int s)
{
	memset(vis,0,sizeof(vis));
	d[s][s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int x=q.top().second;
        q.pop();
        if(vis[x]==1)
        continue;
        vis[x]=1;
        for(int i=1;i<=cnt;i++)
        {
            if(d[s][x]+dist[x][i]<d[s][i])
            {
                d[s][i]=d[s][x]+dist[x][i];
                q.push(make_pair(d[s][i],i));
            }
        }
    }
}
int main()
{
	double t;
	int N,A,B,s;
	scanf("%d",&N);
	while(N--)
	{
		cnt=0;
		scanf("%d%lf%d%d",&s,&t,&A,&B);
		int city=0;
		for(int i=1;i<=s;i++)
		{
			city++;
			for(int j=1;j<=3;j++)
			{
				cnt++;
				scanf("%lf%lf",&p[cnt].x,&p[cnt].y);
				p[cnt].id=city;
			}
			scanf("%lf",&p[cnt].T);
			p[cnt-2].T=p[cnt].T;
			p[cnt-1].T=p[cnt].T;
			p[cnt+1].T=p[cnt].T;
			//printf("%lf %lf\n",p[cnt-j+1].x,p[cnt-j+1].y);
			find(p[cnt-2].x,p[cnt-2].y,p[cnt-1].x,p[cnt-1].y,p[cnt].x,p[cnt].y);
			p[cnt].id=city;
			//printf("i=%lf %lf\n",p[cnt].x,p[cnt].y);
		}
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
			{
				double tmp=sqrt(Sqr(p[i].x-p[j].x)+Sqr(p[i].y-p[j].y));
				if(p[i].id==p[j].id)
				{
					dist[i][j]=tmp*p[i].T;
				}
				else
				{
					dist[i][j]=tmp*t;
				}
			}
		}
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
			{
				d[i][j]=2147483640;
			}
		}
		for(int i=1;i<=cnt;i++)
		{
			dijkstra(i);
		}
		double ans=2147483640;
		for(int i=1;i<=cnt;i++)
		{
			for(int j=1;j<=cnt;j++)
			{
				if(p[i].id==A&&p[j].id==B)
				{
					if(d[i][j]<ans)
					{
						ans=d[i][j];
					}
					//ans=min(ans,d[i][j]);
				}
			}
		}
		printf("%.1lf\n",ans);
	}		
	return 0;
}
```




---

## 作者：DyingEncoder (赞：6)

2025.6.5update 更新图片，求管理员高抬贵手帮助通过

---


# 题目大意
1. 城市内部有若干点，用道路连接。

2. 城市之间的点用航线连接。

---
# 题目分析
## 1.难点一：存储方式
1. 要存城市 $city$ 数组：为了分组 $A,B$ 的处理。

2. 要给所有节点编号，汇总成一个大的数组：为了套用 dijkstra 模板。
```cpp
struct ap{
	double x,y;
	int city,pos;
}aps[N<<2];//N是城市数的上限常数110
vector<ap> city[N];
```
---
## 2.城市出发的点有四个，怎么使用**单源**最短路？

这里就需要引入一个**虚拟原点**。

从虚拟原点向起点城市的四个节点引一条权值为 $0$ 的边，我们发现：起点城市到终点城市各节点的距离，与虚拟原点到终点城市各节点的距离**一一对应**。

![图例](https://cdn.luogu.com.cn/upload/image_hosting/yz3tdgyn.png)
因此我们在 dijkstra 算法中添加 $0$ 边权：

```cpp
#define PII pair<double,int>//构造优先队列中的pair结构
//提示：greater<PII>将会按照先first排序，再second排序的原则，因此我们在first放距离，second放节点编号
bool st[N<<2];//标记当前节点是否是已经用过的
double dist[N<<2];//标记节点到虚拟原点的距离
//堆优化的dijkstra

priority_queue<PII,vector<PII>,greater<PII> > q;
void dijkstra(){
	for(ap i:city[A]){
		dist[i.pos]=0;
		q.push({0,i.pos});// 0 边权添加
	}
	while(q.size()){
		double dis;int t;
		PII cur=q.top();dis=cur.first;t=cur.second;
		q.pop();
		if(st[t]){//重复节点的剪枝
			continue;
		}
		st[t]=1;
		for(int c=1;c<=S;c++){
			for(ap j:city[c]){
				if(dist[j.pos]>calc(t,j.pos)+dis){
					dist[j.pos]=calc(t,j.pos)+dis;
					q.push({dist[j.pos],j.pos});
				}
			}
		}
	}
```
---
## 3.难点二：第四个点的寻找
我的处理方法：因为三个点构成直角三角形，因此可以找到最长的边为斜边，按照斜边讨论第四点的位置
```cpp
void add(int i,double x1,double x2,double x3,double y1,double y2,double y3){
    //添加已知的三个点到城市city、以及节点汇总表airports(aps)，idx表示节点编号
	city[i].push_back({x1,y1,i,idx});aps[idx]={x1,y1,i,idx};idx++;
	city[i].push_back({x2,y2,i,idx});aps[idx]={x2,y2,i,idx};idx++;
	city[i].push_back({x3,y3,i,idx});aps[idx]={x3,y3,i,idx};idx++;
	double l1,l2,l3,maxl;
	l1=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);l2=(x3-x2)*(x3-x2)+(y3-y2)*(y3-y2);
	l3=(x1-x3)*(x1-x3)+(y1-y3)*(y1-y3);maxl=max(max(l1,l2),l3);
	if(l1==maxl){
		city[i].push_back({(x1+x2-x3),(y2+y1-y3),i,idx});
		aps[idx]={(x1+x2-x3),(y2+y1-y3),i,idx};
		idx++;
	}else if(l2==maxl){
		city[i].push_back({(x2+x3-x1),(y2+y3-y1),i,idx});
		aps[idx]={(x2+x3-x1),(y2+y3-y1),i,idx};
		idx++;
	}else{
		city[i].push_back({(x1+x3-x2),(y1+y3-y2),i,idx});
		aps[idx]={(x1+x3-x2),(y1+y3-y2),i,idx};
		idx++;
	}
}
```
## 4.注意点：
**1. `y1` 是 `<bits/stdc++.h>` 里的特殊变量名，防止冲突可以换成`_y1`，或者不使用万能头文件，单独引入**
```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#include<cmath>
```
**2.每次重新开始一组时，所有数组要赋初值。**

`double`类型数组的最大值赋值不能用`memset()`!
```cpp
//错误做法：memset(dist,0x3f,sizeof 0x3f);
//正确做法：for
for(int i=1;i<(N<<2);i++){
    dist[i]=0x3f3f3f3f;
}
```

## 最后汇总一下代码就可以了~
```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#include<cmath>
using namespace std;
const int N=110;
#define PII pair<double,int>

int S,T,A,B,idx=1,Tr[N];//Tr[i]存放第i个城市内的道路费
struct ap{
	double x,y;
	int city,pos;
}aps[N<<2];
vector<ap> city[N];
//添加城市内机场节点
void add(int i,double x1,double x2,double x3,double y1,double y2,double y3){
	city[i].push_back({x1,y1,i,idx});aps[idx]={x1,y1,i,idx};idx++;
	city[i].push_back({x2,y2,i,idx});aps[idx]={x2,y2,i,idx};idx++;
	city[i].push_back({x3,y3,i,idx});aps[idx]={x3,y3,i,idx};idx++;
	double l1,l2,l3,maxl;
	l1=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);l2=(x3-x2)*(x3-x2)+(y3-y2)*(y3-y2);
	l3=(x1-x3)*(x1-x3)+(y1-y3)*(y1-y3);maxl=max(max(l1,l2),l3);
	if(l1==maxl){
		city[i].push_back({(x1+x2-x3),(y2+y1-y3),i,idx});
		aps[idx]={(x1+x2-x3),(y2+y1-y3),i,idx};
		idx++;
	}else if(l2==maxl){
		city[i].push_back({(x2+x3-x1),(y2+y3-y1),i,idx});
		aps[idx]={(x2+x3-x1),(y2+y3-y1),i,idx};
		idx++;
	}else{
		city[i].push_back({(x1+x3-x2),(y1+y3-y2),i,idx});
		aps[idx]={(x1+x3-x2),(y1+y3-y2),i,idx};
		idx++;
	}
}
//计算边权
double calc(int a,int b){
	double res=sqrt((aps[a].x-aps[b].x)*(aps[a].x-aps[b].x)+(aps[a].y-aps[b].y)*(aps[a].y-aps[b].y));
	if(aps[a].city!=aps[b].city){
		res*=T;
	}else{
		res*=Tr[aps[a].city];//Tr[i]存放第i个城市内的道路费
	}
	return res;
}

bool st[N<<2];
double dist[N<<2];
priority_queue<PII,vector<PII>,greater<PII> > q;
//堆优化的dijkstra
void dijkstra(){
	for(ap i:city[A]){
		dist[i.pos]=0;
		q.push({0,i.pos});
	}
	while(q.size()){
		double dis;int t;
		PII cur=q.top();dis=cur.first;t=cur.second;
		q.pop();
		if(st[t]){
			continue;
		}
		st[t]=1;
		for(int c=1;c<=S;c++){
			for(ap j:city[c]){
				if(dist[j.pos]>calc(t,j.pos)+dis){
					dist[j.pos]=calc(t,j.pos)+dis;
					q.push({dist[j.pos],j.pos});
				}
			}
		}
	}
	
	double ans=0x3f3f3f3f;
	for(ap i:city[B]){
		ans=min(ans,dist[i.pos]);
	}
	printf("%.1f",ans);
}
//每组数据的处理（记得初始化！！！）
void solve(){
	idx=1;memset(st,0,sizeof st);
	for(int i=1;i<(N<<2);i++){
		dist[i]=0x3f3f3f3f;
	}
	cin>>S>>T>>A>>B;
	for(int i=1;i<=S;i++){
		double x1,x2,x3,y1,y2,y3;
		cin>>x1>>y1>>x2>>y2>>x3>>y3>>Tr[i];
		city[i].clear();
		add(i,x1,x2,x3,y1,y2,y3);
	}
	
	dijkstra();
}

int n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		solve();
	}
	return 0;
} 
```

---

## 作者：LiJunze0501 (赞：5)

# 我的算法
因为 $s \leqslant 100$，所以直接采用 Floyd。
# 题目分析
这道题重难点在哪里呢？就是通过矩阵三个点的坐标求出第四个点的坐标。  
这里查了很久，先求出直角点（可以通过勾股求），设 1 点为直角点，那么第四个点的坐标就可以这么求：
$x4=x2+x3-x1$，$y4=y2+y3-y1$。  
下面具体说一下怎么求直角点：  
先定义几个变量：  
- $d12$：1 号点到 2 号点的距离；  
- $d23$：2 号点到 3 号点的距离；  
- $d13$：1 号点到 3 号点的距离；

然后给出判断：
$
\begin{cases}
\begin{cases}
x4=x2+x3-x1\\y4=y2+y3-y1
\end{cases} & d12+d13=d23，\text{即 1 号点是直角点}\\
\begin{cases}
x4=x1+x3-x2\\y4=y1+y3-y2
\end{cases} & d12+d23=d13，\text{即 2 号点是直角点}\\
\begin{cases}
x4=x1+x2-x3\\y4=y1+y2-y3
\end{cases} & d23+d13=d12，\text{即 3 号点是直角点}\\
\end{cases}
$
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,t,a,b;
double Tp[101];
struct ap{
	double x,y;
}air[401];
int pf(int x){//平方
	return x*x;
}
double dis(int xx,int yy){//求距离
	return sqrt(pf(air[xx].x-air[yy].x)+pf(air[xx].y-air[yy].y));
}
void getair4(int id){//求第四个机场的坐标
	double d12=pf(air[4*(id-1)+1].x-air[4*(id-1)+2].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+2].y);
	double d23=pf(air[4*(id-1)+2].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+2].y-air[4*(id-1)+3].y);
	double d13=pf(air[4*(id-1)+1].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+3].y);
	if(d12+d13==d23){//1是直角点
		air[4*id].x=air[4*(id-1)+2].x+air[4*(id-1)+3].x-air[4*(id-1)+1].x;
		air[4*id].y=air[4*(id-1)+2].y+air[4*(id-1)+3].y-air[4*(id-1)+1].y;	
	}
	if(d12+d23==d13){//2是直角点
		air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+3].x-air[4*(id-1)+2].x;
		air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+3].y-air[4*(id-1)+2].y;	
	}
	if(d23+d13==d12){//3是直角点
		air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+2].x-air[4*(id-1)+3].x;
		air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+2].y-air[4*(id-1)+3].y;	
	}
}
double cost[401][401];
int main(){
	cin>>n;
	while(n--){
		cin>>s>>t>>a>>b;
		//第i个市的第j机场，4*(i-1)+j
		for(int i=1;i<=4*s;i++)
			for(int j=1;j<=4*s;j++)
				if(i!=j) cost[i][j]=INT_MAX;
		//花费初始化为最大值 
		for(int i=1;i<=s;i++){
			cin>>air[4*(i-1)+1].x>>air[4*(i-1)+1].y;
			cin>>air[4*(i-1)+2].x>>air[4*(i-1)+2].y;
			cin>>air[4*(i-1)+3].x>>air[4*(i-1)+3].y;
			cin>>Tp[i-1];
			getair4(i);
		}
		//把机场坐标求出后，就可以初始化了
		for(int i=1;i<=4*s;i++)
			for(int j=1;j<=4*s;j++)
				if(i!=j) cost[i][j]=cost[j][i]=((i-1)/4==(j-1)/4)?dis(i,j)*Tp[(i-1)/4]:dis(i,j)*t;//条件成立时，是同一座城市的机场，不成立时则不是同一座城市中的机场 
		for(int k=1;k<=4*s;k++)
			for(int i=1;i<=4*s;i++)
				for(int j=1;j<=4*s;j++)
					if(i!=j&&j!=k&&i!=k) cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);//从i机场经过k机场到达j机场更省钱
		double ans=INT_MAX;
		for(int i=1;i<=4;i++)
			for(int j=1;j<=4;j++) ans=min(ans,cost[4*(a-1)+i][4*(b-1)+j]);//a城市的第i座机场到b城市的第j座机场中的最小价钱
		printf("%.1lf\n",ans);
	}
}
```

---

## 作者：Vector_net (赞：5)

本题属于计算几何题，建议搭配草稿纸食用。

看见这句话：“找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。”我们便可以考虑最短路。

### Part-1 建边：
简单理解一下题意，我们发现这张图的边只有两种：城市中间的高铁边与连接城市的飞机边。边权分别是 $len \cdot T_i$ 与 $len \cdot t$，我们可以分开考虑。

这时，一个问题来了，我们只知道矩形的三个点，如何计算第四个点？实际上，这个问题十分简单，只要找到矩形上那个两线垂直的顶点，则有另外两个点的中点与该顶点与未知点的中点相同，由此即可计算了。而垂直可以使用 $k_1 \cdot k_2=-1$ 来判断，当然要特判没有斜率的情况。

好了，于是，现在我们只需要对一个城市的四个点进行枚举并建边，再枚举每个城市，嵌套枚举四个点建边即可。

### Part-2 计算答案：
建好边后，我们可以使用 SPFA 算法计算最短路，这道题目数据极小，显然是不会被卡的。为了方便，我们用超级源点与超级汇点连接 A、B 中的每个点，这样就可以直接刷 SPFA 算法了。

### Part-3 Show the code.
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=405,maxe=400005;
const double INF=1e100;
int T,n,t,A,B,tot,son[maxe],nxt[maxe],lnk[maxn],que[maxn];
double w[maxe],dis[maxn];
bool vis[maxn];
struct ZYX{
	int x[5],y[5],w;
}a[105];

inline int read(){//快读
	int ret=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-f;c=getchar();}
	while(isdigit(c)){ret=ret*10+c-'0';c=getchar();}
	return ret*f;
}

inline double slope(int a,int b,int c,int d){//计算斜率
	if(a==c)return INF;//特判斜率不存在
	return (double)(b-d)/(a-c);
}

inline double Get(int a,int b,int c,int d){return sqrt((a-c)*(a-c)+(b-d)*(b-d));}//计算两点间距离

inline void add_e(int x,int y,double z){son[++tot]=y,w[tot]=z,nxt[tot]=lnk[x],lnk[x]=tot;}//建边，这里使用链式前向星存图

inline double spfa(){//简单易懂的SPFA算法
	for(int i=0;i<maxn;i++)dis[i]=INF;
	int hed=0,til=1;
	que[1]=0,vis[0]=1,dis[0]=0;
	while(hed!=til){
		hed=(hed+1)%maxn;vis[que[hed]]=0;
		for(int j=lnk[que[hed]];j;j=nxt[j]){
			if(dis[que[hed]]+w[j]>=dis[son[j]])continue;
			dis[son[j]]=dis[que[hed]]+w[j];
			if(!vis[son[j]]){vis[son[j]]=1;til=(til+1)%maxn;que[til]=son[j];}
			int now=(hed+1)%maxn;
			if(dis[que[now]]>dis[que[til]])swap(que[now],que[til]);
		}
	}
	return dis[4*n+1];
}

int main(){
	T=read();
	while(T--){
		n=read(),t=read(),A=read(),B=read();
		memset(lnk,0,sizeof lnk);tot=0;//初始化

		for(int i=1;i<=n;i++){
			a[i].x[1]=read(),a[i].y[1]=read();
			a[i].x[2]=read(),a[i].y[2]=read();
			a[i].x[3]=read(),a[i].y[3]=read();
			if(slope(a[i].x[1],a[i].y[1],a[i].x[2],a[i].y[2])*slope(a[i].x[1],a[i].y[1],a[i].x[3],a[i].y[3])==0&&(slope(a[i].x[1],a[i].y[1],a[i].x[2],a[i].y[2])==INF||slope(a[i].x[1],a[i].y[1],a[i].x[3],a[i].y[3])==INF)||slope(a[i].x[1],a[i].y[1],a[i].x[2],a[i].y[2])*slope(a[i].x[1],a[i].y[1],a[i].x[3],a[i].y[3])==-1)a[i].x[4]=-a[i].x[1]+a[i].x[2]+a[i].x[3],a[i].y[4]=-a[i].y[1]+a[i].y[2]+a[i].y[3];
			if(slope(a[i].x[1],a[i].y[1],a[i].x[2],a[i].y[2])*slope(a[i].x[2],a[i].y[2],a[i].x[3],a[i].y[3])==0&&(slope(a[i].x[1],a[i].y[1],a[i].x[2],a[i].y[2])==INF||slope(a[i].x[2],a[i].y[2],a[i].x[3],a[i].y[3])==INF)||slope(a[i].x[1],a[i].y[1],a[i].x[2],a[i].y[2])*slope(a[i].x[2],a[i].y[2],a[i].x[3],a[i].y[3])==-1)a[i].x[4]=-a[i].x[2]+a[i].x[1]+a[i].x[3],a[i].y[4]=-a[i].y[2]+a[i].y[1]+a[i].y[3];
			if(slope(a[i].x[3],a[i].y[3],a[i].x[2],a[i].y[2])*slope(a[i].x[1],a[i].y[1],a[i].x[3],a[i].y[3])==0&&(slope(a[i].x[3],a[i].y[3],a[i].x[2],a[i].y[2])==INF||slope(a[i].x[1],a[i].y[1],a[i].x[3],a[i].y[3])==INF)||slope(a[i].x[3],a[i].y[3],a[i].x[2],a[i].y[2])*slope(a[i].x[1],a[i].y[1],a[i].x[3],a[i].y[3])==-1)a[i].x[4]=-a[i].x[3]+a[i].x[2]+a[i].x[1],a[i].y[4]=-a[i].y[3]+a[i].y[2]+a[i].y[1];
            //计算第四个点的位置
			a[i].w=read();
		}

		add_e(0,4*(A-1)+1,0);add_e(0,4*(A-1)+2,0);
		add_e(0,4*(A-1)+3,0);add_e(0,4*(A-1)+4,0);
		add_e(4*(B-1)+1,4*n+1,0);add_e(4*(B-1)+2,4*n+1,0);
		add_e(4*(B-1)+3,4*n+1,0);add_e(4*(B-1)+4,4*n+1,0);
        //建立源点与汇点
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				int M=i==j?a[i].w:t;
				for(int p=1;p<=4;p++)
					for(int q=1;q<=4;q++)add_e(4*(i-1)+p,4*(j-1)+q,Get(a[i].x[p],a[i].y[p],a[j].x[q],a[j].y[q])*M);
			}
		}
        //建边，由于枚举中包含了i=j的情况，因此包含了城内情况
		printf("%.1lf\n",spfa());//输出答案，完美收尾！
	}
	return 0;
}
```

---

## 作者：weiy_ (赞：4)

思路不用讲，就是简单的 spfa 求单源最短路，但这道题恶心的点就在于如何用矩阵中已知的三点求出第四点坐标。

如图

![如图](https://cdn.luogu.com.cn/upload/image_hosting/i0qezl4r.png)

由平行四边形对角线互相平分，可知两对角线交点就是对角线两端点的中点，由中点坐标公式得 $x_E=(x_A+x_D)/2=(x_C+x_B)/2$ , $y_E=(y_A+y_D)/2=(y_C+y_B)/2$ ，那么我们只要知道三点的坐标，并且知道三点连接成的直角三角形中的直角顶点，就可以求出第四点的坐标。

以上图为例，给出 $A(0,2),B(8,0),C(1,6)$  三点坐标，根据勾股定理：
$$
\begin{cases}
AB^2=(x_A-x_B)^2+(y_A-y_B)^2=68 \\
AC^2=(x_A-x_C)^2+(y_A-y_C)^2=17 \\
BC^2=(x_B-x_C)^2+(y_B-y_C)^2=85
\end{cases}
$$
因为 $AB^2+AC^2=BC^2$ ,所以 A 是直角顶点，点 D 与 A 在同一条对角线上，再套用之前的公式得出 $x_D=x_B+x_C-x_A,y_D=y_B+y_C-y_A$ ,就得到了点 D 的坐标。

知道了所有点的坐标，那么这就是一道裸的 spfa 了，下面放上代码

```
#include<bits/stdc++.h>
using namespace std;
int k,s,t,a,b,T;
int vis[405],zb[105][4][2];
double d[405][405],dis[405];
struct node{
	int x,y;
};
bool cmp(node a,node b){
	return a.y>b.y;
}
void spfa(int x){
	for(int i=1;i<=s*4;i++) dis[i]=999999.9999; 
	memset(vis,0,sizeof vis);
	queue<int> q;
	q.push(x);
	vis[x]=true,dis[x]=0;
	while(!q.empty()){
		int u=q.front();
		for(int i=1;i<=s*4;i++){
			if(u==i) continue;
			if(d[u][i]!=0&&dis[i]>dis[u]+d[u][i]){
				dis[i]=dis[u]+d[u][i];
				if(!vis[i]){
					q.push(i);
					vis[i]=true;
				}
			}
		}
		vis[q.front()]=false;
		q.pop();
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>k;
	while(k--){
		cin>>s>>t>>a>>b;
		for(int i=1;i<=s;i++){
			node e[5];
			for(int j=1;j<=3;j++)
				cin>>e[j].x>>e[j].y;
			cin>>T;
			double ab=pow(e[1].x-e[2].x,2)+pow(e[1].y-e[2].y,2);//a
			double ac=pow(e[1].x-e[3].x,2)+pow(e[1].y-e[3].y,2);//b
			double bc=pow(e[2].x-e[3].x,2)+pow(e[2].y-e[3].y,2);//c
			if(ab+ac==bc){
				e[4].x=e[2].x+e[3].x-e[1].x;
				e[4].y=e[2].y+e[3].y-e[1].y;
			}
			if(ab+bc==ac){
				e[4].x=e[1].x+e[3].x-e[2].x;
				e[4].y=e[1].y+e[3].y-e[2].y;
			}
			if(ac+bc==ab){
				e[4].x=e[1].x+e[2].x-e[3].x;
				e[4].y=e[1].y+e[2].y-e[3].y;
			}
			for(int n=1;n<=4;n++){
			    zb[i][n-1][0]=e[n].x;
				zb[i][n-1][1]=e[n].y;
				for(int m=1;m<=4;m++){
					d[(i-1)*4+n][(i-1)*4+m]=d[(i-1)*4+m][(i-1)*4+n]=(double)sqrt(pow(e[n].x-e[m].x,2)+pow(e[n].y-e[m].y,2))*T;
				}
			}
		}
		for(int i=1;i<=s;i++){
			for(int j=1;j<=s;j++){
				if(i==j) continue;
				for(int n=0;n<4;n++){
					for(int m=0;m<4;m++){
						d[(i-1)*4+n+1][(j-1)*4+m+1]=sqrt(pow(zb[i][n][0]-zb[j][m][0],2)+pow(zb[i][n][1]-zb[j][m][1],2))*t;
						d[(j-1)*4+m+1][(i-1)*4+n+1]=sqrt(pow(zb[i][n][0]-zb[j][m][0],2)+pow(zb[i][n][1]-zb[j][m][1],2))*t;
					}
				}
			}
		}
		double minn=999999.9999;
		for(int i=0;i<4;i++){
			spfa((a-1)*4+i+1);
			for(int j=0;j<4;j++){
				minn=min(minn,dis[(b-1)*4+j+1]);
			}
		}
		cout<<fixed<<setprecision(1)<<minn<<"\n";
	}
	return 0;
}
```

---

## 作者：rediserver (赞：3)

## 思路



用Airport结构体存储机场的x,y坐标，用`airports_`数组存储所有机场。顺序为先存储第0个城市的4个机场，然后第1个城市的4个机场。。。最后一个城市的4个机场。所以`airports_[i]`机场所在的城市编号为`i / 4`。而`第i个城市的第j个机场`，在`airports_`中的编号则为`i * 4 +ｊ`。这两个换算定义成了宏。

输入时通过每个城市的前三个机场坐标计算最后一个机场坐标。

用dijkstra计算起点到终点的最短路径。注意：

* dijkstra算法只有一个源，而在这里起点城市的4个机场均可作为起点，故将这4个机场与源的距离设为0。

* 只要收录的机场所在城市为终点城市，则达到目的地。

* 整个程序没有存储具体的图，对于每次收录的机场来讲，任何其他未收录的机场均为邻接点，计算它们的直线距离，此时若它们在同一城市，则它们之间的费用为直线距离乘以该城市的铁路费，否则费用为直线距离乘以航线费。

## 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <math.h>
using namespace std;

#define N_AIRPORTS_PER_CITY 4 //每个城市的机场数
#define GET_CITY_INDEX(airport_idx) ((airport_idx) / N_AIRPORTS_PER_CITY) //得到一个机场所属的城市编号
#define GET_AIRPORT_INDEX(city_idx, i) ((city_idx) * N_AIRPORTS_PER_CITY + (i)) //得到一个城市第i个机场的编号
#define NO_VALUE -1

class CarRoute {
public:
    CarRoute() {}
    ~CarRoute() {}

    void solve(); //主函数

private:
    struct Airport {
        //机场的坐标
        int x; 
        int y;
    };

    int square(int x) { return x * x; }

    /* 返回两个机场间的直线距离 */
    float getAirportDist(Airport& a, Airport& b);

    /* 用dijkstra求最短路 */
    float dijkstra(int src_city, int des_city);

    int nAirports_; //总机场数量
    Airport *airports_; //机场数组，依次存储第0个，第1个。。。城市的4个机场

    int cost_air_; //航线单位里程的价格
    int *cost_train_; //cost_train_[i]为第i个城市中高速铁路的单位里程价格
};

void CarRoute::solve() {
    int nCities, src_city, des_city; //城市数，起点，终点
    scanf("%d %d %d %d", &nCities, &cost_air_, &src_city, &des_city);
    src_city--; //改为从0开始编号
    des_city--;
    nAirports_ = nCities * N_AIRPORTS_PER_CITY;
    airports_ = new Airport[nAirports_];
    cost_train_ = new int[nCities];
    for (int i = 0; i < nCities; i++) {
        int ax, ay, bx, by, cx, cy, dx, dy;
        //输入每个城市前三个机场
        scanf("%d %d %d %d %d %d %d", &ax, &ay, &bx, &by, &cx, &cy, cost_train_ + i);
        airports_[GET_AIRPORT_INDEX(i, 0)].x = ax;
        airports_[GET_AIRPORT_INDEX(i, 0)].y = ay;
        airports_[GET_AIRPORT_INDEX(i, 1)].x = bx;
        airports_[GET_AIRPORT_INDEX(i, 1)].y = by;
        airports_[GET_AIRPORT_INDEX(i, 2)].x = cx;
        airports_[GET_AIRPORT_INDEX(i, 2)].y = cy;
        int abSquare = square(ax - bx) + square(ay - by);
        int acSquare = square(ax - cx) + square(ay - cy);
        int bcSquare = square(bx - cx) + square(by - cy);
        if (abSquare == acSquare + bcSquare) { //c为直角顶点
            dx = ax + bx - cx;
            dy = ay + by - cy;
        }
        else if (acSquare == abSquare + bcSquare) { //b为直角顶点
            dx = ax + cx - bx;
            dy = ay + cy - by;
        }
        else { //a为直角顶点
            dx = bx + cx - ax;
            dy = by + cy - ay;
        }
        //最后一个机场的坐标已确定
        airports_[GET_AIRPORT_INDEX(i, 3)].x = dx;
        airports_[GET_AIRPORT_INDEX(i, 3)].y = dy;
    }
    float minCost = dijkstra(src_city, des_city); //计算最短路
    printf("%.1f\n", minCost);
    free(airports_);
    free(cost_train_);
}

float CarRoute::getAirportDist(Airport & a, Airport & b) {
    return sqrt(square(a.x - b.x) + square(a.y - b.y));
}

float CarRoute::dijkstra(int src_city, int des_city) {
    float *cost = new float[nAirports_]; //cost[i]表示从起点到第i个机场的当前最小费用
    bool *collected = new bool[nAirports_];
    fill(cost, cost + nAirports_, NO_VALUE);
    fill(collected, collected + nAirports_, false);
    for (int i = 0; i < 4; i++) //将起点城市的4个机场的cost设为0
        cost[GET_AIRPORT_INDEX(src_city, i)] = 0;
    while (true) {
        int minV = NO_VALUE;
        float minCost = NO_VALUE;
        //在未收录机场中找到cost最小的
        for (int i = 0; i < nAirports_; i++)
            if (!collected[i] && cost[i] != NO_VALUE && (cost[i] < minCost || minCost == NO_VALUE)) {
                minV = i;
                minCost = cost[i];
            }
        int minCity = GET_CITY_INDEX(minV); //minCity为最小cost机场minV所在城市
        if (minCity == des_city) { //若与终点在同一城市
            free(cost);
            free(collected);
            return minCost;
        }
        if (minV == NO_VALUE) break;
        collected[minV] = true; //收录minV
        for (int i = 0; i < nAirports_; i++) 
            if (!collected[i]) {
                float dist = getAirportDist(airports_[minV], airports_[i]); //dist为minV到i的直线距离
                //若minV与i在同一城市中，则从minV到i的费用为dist乘以该城市的铁路费用，否则为dist乘以航线费用
                float cost_tmp = GET_CITY_INDEX(i) == minCity ? dist * cost_train_[minCity] : dist * cost_air_;
                if (minCost + cost_tmp < cost[i] || cost[i] == NO_VALUE) { //若通过minV使cost[i]变小
                    cost[i] = minCost + cost_tmp; //更新
                }
            }
    } //while
    free(cost);
    free(collected);
    return NO_VALUE;
}


int main() {
    CarRoute carRoute;
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        carRoute.solve();
    }
    return 0;
}
```


---

## 作者：lzh301 (赞：3)

# Solution

这是一道最短路题，发现点数最多只有 $S \times 4=400$ 个，可以用 Floyd 轻松通过。
## 细节

1. 每个城市只给了三个点，还有一个需要自行求出。
2. 需要自己建边。
3. 变量较多，记得起好自己能记住的名字。
4. 因为要求两点间距离，所以要记住尽量避免精度问题。

其他的应该没有什么问题了。
# Code

```cpp
#include<bits/stdc++.h>
#define inf 1e18
using namespace std;
double dis[550][550];
double disq(int x1,int y1,int x2,int y2){
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}
double dist(int x1,int y1,int x2,int y2){
	return sqrt(disq(x1,y1,x2,y2));
}
int main(){
	int n;
	cin>>n;
	while(n--){
		int S,t,A,B;
		cin>>S>>t>>A>>B;
		memset(dis,0x3f,sizeof dis);
		int x[550],y[550],T[550];
		double ans=inf;
		for(int i=1;i<=S;i++){
			cin>>x[i*4-3]>>y[i*4-3];
			cin>>x[i*4-2]>>y[i*4-2];
			cin>>x[i*4-1]>>y[i*4-1];
			cin>>T[i];
			//求第四个点 
			double d12=disq(x[i*4-3],y[i*4-3],x[i*4-2],y[i*4-2]); 
			double d13=disq(x[i*4-3],y[i*4-3],x[i*4-1],y[i*4-1]);
			double d23=disq(x[i*4-1],y[i*4-1],x[i*4-2],y[i*4-2]);
			if(d12+d13==d23)x[i*4]=x[i*4-2]+x[i*4-1]-x[i*4-3],y[i*4]=y[i*4-2]+y[i*4-1]-y[i*4-3];
			if(d12+d23==d13)x[i*4]=x[i*4-1]+x[i*4-3]-x[i*4-2],y[i*4]=y[i*4-1]+y[i*4-3]-y[i*4-2];
			if(d13+d23==d12)x[i*4]=x[i*4-2]+x[i*4-3]-x[i*4-1],y[i*4]=y[i*4-2]+y[i*4-3]-y[i*4-1];
		}
		for(int i=1;i<=4*S;i++){//建边 
			for(int j=1;j<=4*S;j++){
				if(i!=j){
					if((i-1)/4!=(j-1)/4){
						dis[i][j]=t*dist(x[i],y[i],x[j],y[j]);
					}else{
						dis[i][j]=T[(i-1)/4+1]*dist(x[i],y[i],x[j],y[j]);
					}
				}
			}
		}
		for(int k=1;k<=4*S;k++){
			for(int i=1;i<=4*S;i++){
				for(int j=1;j<=4*S;j++){
					dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
				}
			}
		}
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++){
				ans=min(ans,dis[(A-1)*4+i][(B-1)*4+j]);
			}
		}		
		printf("%.1lf",ans);
		cout<<endl;	
	}
}
```

---

## 作者：shandianhailan (赞：2)

# 概述
题目的大意是说，每个城市有四个机场，分布在矩形的四个顶点上。但输入只给出三个点，第四个点需要自己计算。然后，同一城市的机场之间需要计算高铁的费用，不同城市之间则是飞机。我们需要找到从起点城市 a 到终点城市 b 的最短路径。
# 建模
很显然，过路的票价就是所谓的边权，那么建图就很好完成了。题目要求从 A 到 B 的最小花费，定义：$dp[i][j]$ 表示从  $i$ 城市到  $j$ 城市的花费，注意到数据范围，很明显是采用 Floyd 配合动态规划完成。
# 细节
- 使用浮点数运算判断直角时，可能因精度损失导致条件判断失败。建议改用整数运算或引入误差容忍度。对于这一点，笔者手动实现了几个库函数，因为没有注意到编译环境及编程语言带来的先天特性，调试了很久很久。警示后人！
- 若代码中使用 memset 将 dp 数组初始化为极大值，但未显式设置 $dp[i][i]=0$（机场到自身的距离应为 0）。这可能导致 Floyd 算法中路径计算错误，这在多测时应特别注意。
- 理解题目，最好手动模拟一遍。这里怎样找到四个顶点的关系？这里由于矩形的几何性质，横坐标之差对应相等，纵坐标同理，再通过勾股定理判定是否是直角顶点。
# 标程

```cpp
#include<iostream>
#include<cmath>
#define x first 
#define y second
using namespace std;
typedef pair<int,int> pii;//等效结构体
const int N=105*4;//矩形是四个顶点
const double INF=1e18;
pii p[N];
int T[N];
double dp[N][N];
inline double sqr(pii a,pii b)
{
	int dx=a.x-b.x,dy=a.y-b.y;
	return dx*dx+dy*dy;
}//这里需要特别注意精度问题，尽量减少运算，能整数运算就不要浮点数运算
inline double dis(pii a,pii b) {return sqrt(sqr(a,b));}//只进行一次浮点数运算
inline double cmin(double a,double b)
{
	if(a>b) return b;
	else return a;
}//手动实现库函数
int main()
{
	int n;
	cin>>n;
	while(n--)//多测
	{
		int s,t,a,b;
		cin>>s>>t>>a>>b;
		for(int i=1;i<=s*4;i++)
		    for(int j=1;j<=s*4;j++)
		        if(i!=j) dp[i][j]=INF;
		        else dp[i][j]=0;
		for(int i=1;i<=s;i++)
		{
			cin>>p[i*4-3].x>>p[i*4-3].y;
			cin>>p[i*4-2].x>>p[i*4-2].y;
			cin>>p[i*4-1].x>>p[i*4-1].y;
			cin>>T[i];
			double d12=sqr(p[i*4-3],p[i*4-2]);
			double d13=sqr(p[i*4-3],p[i*4-1]);
			double d23=sqr(p[i*4-2],p[i*4-1]);
			if(d12+d13==d23) p[i*4].x=p[i*4-2].x+p[i*4-1].x-p[i*4-3].x, p[i*4].y=p[i*4-2].y+p[i*4-1].y-p[i*4-3].y;
			if(d12+d23==d13) p[i*4].x=p[i*4-1].x+p[i*4-3].x-p[i*4-2].x, p[i*4].y=p[i*4-1].y+p[i*4-3].y-p[i*4-2].y;
			if(d13+d23==d12) p[i*4].x=p[i*4-2].x+p[i*4-3].x-p[i*4-1].x, p[i*4].y=p[i*4-2].y+p[i*4-3].y-p[i*4-1].y;
		}	//这里手动模拟，最好画图
		for(int i=1;i<=4*s;i++)
			for(int j=1;j<=4*s;j++)
			if(i!=j) 
			{
				if((i-1)/4!=(j-1)/4) dp[i][j]=t*dis(p[i],p[j]);//不在同一座城市 
				else dp[i][j]=T[(i-1)/4+1]*dis(p[i],p[j]); 
			}//注意映射关系
		//floyd	
		for(int k=1;k<=4*s;k++) 		
		    for(int i=1;i<=4*s;i++)	    
		    for(int j=1;j<=4*s;j++)	
		    dp[i][j]=cmin(dp[i][k]+dp[k][j],dp[i][j]);
		double ans=INF;
		for(int i=1;i<=4;i++) for(int j=1;j<=4;j++) ans=cmin(ans,dp[(a-1)*4+i][(b-1)*4+j]);
		printf("%.1lf\n",ans);
	}
	return 0;
}
```
鸣谢思路提供者：@lzh301。

---

## 作者：cybermage_liu (赞：2)

# 思路
给了三个点的坐标，首先肯定要把第四个点算出来。

因为矩形的两条对角线的中点为同一个点，所以可以根据对角线上的两个点求出中点，再根据第三个点和中点求出第四个点。

设已知的对角线上两个点为 $(x_0,y_0)$ 和 $(x_2,y_2)$，另一个点为 $(x_1,y_1)$，要求 $(x_3,y_3)$。

易得：

$$
\begin{cases}
x_3=\frac{x_0+x_2}{2}\times2-x_1=x_0+x_2-x_1
\\
y_3=\frac{y_0+y_2}{2}\times2-y_1=y_0+y_2-y_1
\end{cases}
$$

因为四个机场围成矩形，所以判断对角线可以用勾股定理。求出三个点围成的三角形的三条边，若满足 $a^2+b^2=c^2$，则与边 $c$ 相对的角是直角，边 $c$ 就是矩形的对角线。

然后预处理出任意两个点间的直达花费，求最短路，数据范围不大，Floyd 就足够了。

* 将第 $i$ 个城市的四个机场（$i\times 4-3,i\times 4-2,i\times 4-1,i\times 4$）与前 $i-1$ 个城市的所有机场（$1 \le j \le (i-1)\times 4$）两两建立航线，$\lfloor \frac{j-1}{4}\rfloor+1$ 判断属于哪个城市，$(j-1) \bmod 4$ 判断是第几个机场，将两点距离乘上 $t$ 得到两个机场的直达花费。

* 将第 $i$ 个城市的四个机场两两建立铁路，将两点距离乘上 $T_i$ 得到两个机场的直达花费。

每个城市有四个机场，Floyd 数组每维要开四倍空间，也就是十六倍空间。

最后要将 $A$ 的每一个机场和 $B$ 的每一个机场间的最短路求 $\min$ 就是答案。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
inline int dis(int x,int y,int xx,int yy){
	return (x-xx)*(x-xx)+(y-yy)*(y-yy);
}//注意这是两点间距离的平方
const int N=103;
int x[N][4],y[N][4],W[N];
double f[N<<2][N<<2];//注意十六倍空间和 double
int main(){
	int T,n,w,s,t;
	cin>>T;
	while(T--){
		double ans=inf;
		scanf("%d%d%d%d",&n,&w,&s,&t);
		for(int i=1;i<=n;i++){
			scanf("%d%d%d%d%d%d%d",&x[i][0],&y[i][0],
			&x[i][1],&y[i][1],&x[i][2],&y[i][2],&W[i]);
			int a=dis(x[i][0],y[i][0],x[i][1],y[i][1]);
			int b=dis(x[i][1],y[i][1],x[i][2],y[i][2]);
			int c=dis(x[i][2],y[i][2],x[i][0],y[i][0]);
			//三点距离平方和，不满足勾股定理就交换
			if(a+c==b) swap(x[i][0],x[i][1]),swap(y[i][0],y[i][1]);
			if(b+c==a) swap(x[i][1],x[i][2]),swap(y[i][1],y[i][2]);
			//求第四个点
			x[i][3]=x[i][0]+x[i][2]-x[i][1];
			y[i][3]=y[i][0]+y[i][2]-y[i][1];
			for(int j=0;j<(i-1)*4;j++){
				//航线
				//j 整体减一更方便操作
				f[i*4-3][j+1]=f[j+1][i*4-3]=sqrt(dis(x[j/4+1][j%4],y[j/4+1][j%4],x[i][0],y[i][0]))*w;
				f[i*4-2][j+1]=f[j+1][i*4-2]=sqrt(dis(x[j/4+1][j%4],y[j/4+1][j%4],x[i][1],y[i][1]))*w;
				f[i*4-1][j+1]=f[j+1][i*4-1]=sqrt(dis(x[j/4+1][j%4],y[j/4+1][j%4],x[i][2],y[i][2]))*w;
				f[i*4][j+1]=f[j+1][i*4]=sqrt(dis(x[j/4+1][j%4],y[j/4+1][j%4],x[i][3],y[i][3]))*w;
			}
			for(int j=0;j<=3;j++)
				for(int k=0;k<=3;k++)
				//铁路
					f[i*4-j][i*4-k]=sqrt(dis(x[i][j],y[i][j],x[i][k],y[i][k]))*W[i];
		}
		int m=4*n;//Floyd
		for(int k=1;k<=m;k++)
			for(int i=1;i<=m;i++)
				for(int j=1;j<=m;j++)
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
		for(int i=0;i<=3;i++)
			for(int j=0;j<=3;j++)
				ans=min(ans,f[s*4-i][t*4-j]);
		//所有从 s 到 t 的最短路求 min
		printf("%.1lf\n",ans);
	}
}
```

---

## 作者：licone (赞：2)

SPFA+数论~

应该是最简短清晰的代码了，判断第四个点用了求斜边对应点的方法，类似向量~








```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<queue>
using namespace std;
int n,s,t,A,B,fi[401],w[340001],ne[340001],cnt,x[5][401],y[5][401],val;
double v[340001],dis[401],minn;
bool b[401];
queue<int> q;
void add(int u,int vv,double val1)
{
    w[++cnt]=vv;v[cnt]=val1;ne[cnt]=fi[u];fi[u]=cnt;
}
double cal(double x1,double y1,double x2,double y2)
{
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
double cal2(int x1,int y1,int x2,int y2)
{
    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}
void getn(int u)
{
    double k[4]={0,cal2(x[1][u],y[1][u],x[2][u],y[2][u]),
                   cal2(x[2][u],y[2][u],x[3][u],y[3][u]),
                   cal2(x[3][u],y[3][u],x[1][u],y[1][u])},tot=k[1]+k[2]+k[3];
    int fre,num[3]={0};
    for(int i=1;i<=3;i++)
      if(k[i]*2==tot) fre=(i==1 ? 3:i-1);
      else num[++num[0]]=(i==1 ? 3:i-1);
    x[4][u]=x[num[1]][u]+x[num[2]][u]-x[fre][u];
    y[4][u]=y[num[1]][u]+y[num[2]][u]-y[fre][u];
}
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d%d%d%d",&s,&t,&A,&B);minn=999999999;
        memset(fi,0,sizeof(fi));cnt=0;
        for(int k=1;k<=s;k++)
        {
            scanf("%d%d%d%d%d%d%d",&x[1][k],&y[1][k],&x[2][k],&y[2][k],&x[3][k],&y[3][k],&val);
            getn(k);
            for(int i=1;i<=3;i++)
              for(int j=i+1;j<=4;j++)
              {
                  double kkz=cal(x[i][k],y[i][k],x[j][k],y[j][k])*(double)val;
                  add(4*k+i-4,4*k+j-4,kkz);add(4*k+j-4,4*k+i-4,kkz);
              }
        }
        for(int k1=1;k1<s;k1++)
          for(int k2=k1+1;k2<=s;k2++)
            for(int i=1;i<=4;i++)
                for(int j=1;j<=4;j++)
                {
                    double kkz=cal(x[i][k1],y[i][k1],x[j][k2],y[j][k2])*(double)t;
                    add(4*k1-4+i,4*k2-4+j,kkz);add(4*k2-4+j,4*k1-4+i,kkz);
              }
        for(int i=1;i<=4;i++)
        {
            memset(dis,127,sizeof(dis));
            q.push(A*4-4+i);b[A*4-4+i]=1;dis[A*4-4+i]=0;
            while(!q.empty())
            {
                int k=q.front();q.pop();b[k]=0;
                for(int j=fi[k];j;j=ne[j])
                  if(dis[w[j]]>dis[k]+v[j])
                  {
                    dis[w[j]]=dis[k]+v[j];
                    if(!b[w[j]])
                    {
                        b[w[j]]=1;q.push(w[j]);
                    }
                  }
            }
            for(int j=1;j<=4;j++)
              if(dis[B*4-4+j]<minn) minn=dis[B*4-4+j];
        }
        printf("%.1lf\n",minn);
    }
    return 0;
}
```

---

## 作者：zhou2414 (赞：1)

~~一道毒瘤题~~。
# 思路
毒瘤出题人只给了三个机场的位置，需要我们自行求出第四个机场的位置。

用~~小学二年级学过~~的三角形相关知识可知，构成对角线的两个点之间的距离最远。所以我们可以通过~~小学二年级学过~~的勾股定理求出两个点之间的距离，然后判断是否为对角线。

那么问题就转换为了：设四个机场的编号分别为 $0$ 到 $3$，已知前两个为对角线机场，求第四个机场的坐标。

由~~小学二年级学过~~的知识可以知道，$3$ 号机场与 $2$ 号机场关于对角线中点对称。那么便可以利用**中点坐标公式** $d_{mid}(\frac{x_0+x_1}{2},\frac{y_0+y_1}{2})$ 得到中点坐标，然后再反过来推出 $3$ 号机场坐标即可。

~~然后就可以愉快地 AC 啦！~~

最短路呢？建完全图套个 floyd 就行了，~~这还用讲~~？
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define dd double
inline ll read() {
	ll x = 0, f = 1;
	char ch;
	while (((ch = getchar()) < 48 || ch > 57)&&ch!=EOF)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
const ll N=409,INF=1e9;
ll n,s,t,a,b;
dd tu[N][N];
dd ans;
struct NODE{
	dd x,y;
}node[N];
inline void clear(){
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			tu[i][j]=INF;
		}
		tu[i][i]=0;
	}
	ans=INF;
}
inline dd ju(dd x1,dd y1,dd x2,dd y2){
	return sqrt(fabs(x1-x2)*fabs(x1-x2)+fabs(y1-y2)*fabs(y1-y2));
}
inline void init(){
	s=read(),t=read(),a=read(),b=read();
	for(int k=1;k<=s;k++){
		dd x[4],y[4],t;
		for(int i=0;i<3;i++){
			x[i]=read(),y[i]=read();
		}
		t=read();
		if(x[0]>x[2])swap(x[0],x[2]),swap(y[0],y[2]);
		if(x[0]>x[1])swap(x[0],x[1]),swap(y[0],y[1]);
		if(x[1]>x[2])swap(x[1],x[2]),swap(y[1],y[2]);
		dd d[4];
		for(int i=0;i<3;i++){
			d[i]=ju(x[i],y[i],x[(i+1)%3],y[(i+1)%3]);
		}
		dd xn,yn;
		if(d[0]>d[1]){
			if(d[0]>d[2]){
				xn=(x[0]+x[1])/2;
				yn=(y[0]+y[1])/2;
				x[3]=2*xn-x[2];
				y[3]=2*yn-y[2];
			}else{
				xn=(x[0]+x[2])/2;
				yn=(y[0]+y[2])/2;
				x[3]=2*xn-x[1];
				y[3]=2*yn-y[1];
			}
		}else{
			if(d[1]>d[2]){
				xn=(x[1]+x[2])/2;
				yn=(y[1]+y[2])/2;
				x[3]=2*xn-x[0];
				y[3]=2*yn-y[0];
			}else{
				xn=(x[0]+x[2])/2;
				yn=(y[0]+y[2])/2;
				x[3]=2*xn-x[1];
				y[3]=2*yn-y[1];
			}
		}
		for(int i=0;i<=3;i++){
			for(int j=0;j<=3;j++){
				if(i==j)continue;
				tu[(k-1)*4+i][(k-1)*4+j]=ju(x[i],y[i],x[j],y[j])*t;
			}
		}
		for(int i=0;i<=3;i++){
			node[(k-1)*4+i].x=x[i];
			node[(k-1)*4+i].y=y[i];
		}
	}
	for(int i=0;i<s*4;i++){
		for(int j=0;j<s*4;j++){
			if(i==j||i/4==j/4)continue;
			tu[i][j]=ju(node[i].x,node[i].y,node[j].x,node[j].y)*t;
		}
	}
}
inline void floed(){
	for(int k=0;k<s*4;k++){
		for(int j=0;j<s*4;j++){
			for(int i=0;i<s*4;i++){
				if(i==j||j==k||i==k)continue;
				tu[i][j]=min(tu[i][j],tu[i][k]+tu[k][j]);
			}
		}
	}
}
int main(){
	n=read();
	while(n--){
		clear();
		init();
		floed();
		for(int i=0;i<=3;i++)
			for(int j=0;j<=3;j++)
				ans=min(ans,tu[(a-1)*4+i][(b-1)*4+j]);
		printf("%.1lf\n",ans);
//		for(int i=0;i<s*4;i++){
//			for(int j=0;j<s*4;j++){
//				cout<<tu[i][j]<<' ';
//			}
//			cout<<endl;
//		}
	}
	return 0;
}
```

---

## 作者：liheyang123 (赞：0)

一种很显然的做法，注意到数据规模 $S \le 100$，在一座城市中最多有 $4$ 种不同的状态（矩形的四个顶点）。

考虑拆点，拆点后最多只有 $400$ 个点，考虑用邻接表与 floyd 算法解决此题。

但是由于题目只给出了矩形的三个顶点的坐标，第四个顶点应该自己计算。

假设第一个点是 $A(x_1, y_1)$，第二个点是 $B(x_2, y_2)$，第三个点是 $C(x_3, y_3)$，第三个点是 $D(x_4, y_4)$。

有如下三种情况：
- $AB^2 + AC^2 = BC^2$，此时 $x_4 = x_2 + x_3 - x_1$，$y_4 = y_2 + y_3 - y_1$，$D(-x_1 + x_2 + x_3, -y_1 + y_2 + y_3)$。

  不难证明，因为 $AB$，$AC$ 是直角边，因此 $\mathbf{AB} = \mathbf{CD}$，由于 $\mathbf{AB} = (x_2 - x_1, y_2 - y_1)$，$C(x_3, x_4)$，所以 $D = C + \mathbf{AB}$。
  
- 同理，$AB^2 + BC^2 = AC^2$ 时，$D(x_1 - x_2 + x_3, y_1 - y_2 + y_3)$。

- $AC^2 + BC^2 = AB^2$ 时，$D(x_1 + x_2 - x_3, y_1 + y_2 - y_3)$。

剩下的很显然，计算同一个矩形中两点间的“高速公路”的边权并记录，计算不同矩形的两点间的“航线”的边权并记录，跑 floyd 即可，最后枚举起点与终点的状态。时间复杂度：拆点 $O(T\times S)$，建边 $O(T\times S^2)$，floyd$O(T\times S^3)$，总复杂度 $O(T\times S^3)$。

代码
```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;

// 快速读入整数的函数
inline int read() {
    int f = 1, x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

typedef long long ll;
const ll INF = 0x7f7f7f7f; // 用于表示无穷大
const int N = 410;         // 最大点数

// 变量定义
ll s, A, B, T; // s: 矩形数量, A 和 B: 起点和终点矩形编号, T: 测试用例数量
double ans, t, dis[N][N]; // ans: 最终答案, t: 普通路径的权重, dis: 距离矩阵
double x[N], y[N], w[110]; // x, y: 点的坐标, w: 矩形的权重

// 计算两点之间的欧几里得距离
double getDistance(double x1, double y1, double x2, double y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

// 计算两点之间的平方距离（避免开方，提高效率）
double squaredDistance(double x1, double y1, double x2, double y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

int main() {
    T = read(); // 读取测试用例数量
    while (T--) {
        memset(dis, 0, sizeof(dis)); // 初始化距离矩阵为0
        ans = INF;                   // 初始化答案为无穷大

        // 读取输入数据
        s = read(); // 矩形数量
        t = read(); // 普通路径的权重
        A = read(); // 起点矩形编号
        B = read(); // 终点矩形编号

        // 输入每个矩形的四个点和权重
        for (int i = 1; i <= s; i++) {
            // 读取矩形的三个点的坐标
            x[(i - 1) * 4 + 1] = read();
            y[(i - 1) * 4 + 1] = read();
            x[(i - 1) * 4 + 2] = read();
            y[(i - 1) * 4 + 2] = read();
            x[(i - 1) * 4 + 3] = read();
            y[(i - 1) * 4 + 3] = read();
            w[i] = read(); // 读取矩形的权重

            // 计算三个边的平方距离
            double disAB = squaredDistance(x[(i - 1) * 4 + 1], y[(i - 1) * 4 + 1],
                                           x[(i - 1) * 4 + 2], y[(i - 1) * 4 + 2]);
            double disAC = squaredDistance(x[(i - 1) * 4 + 1], y[(i - 1) * 4 + 1],
                                           x[(i - 1) * 4 + 3], y[(i - 1) * 4 + 3]);
            double disBC = squaredDistance(x[(i - 1) * 4 + 2], y[(i - 1) * 4 + 2],
                                           x[(i - 1) * 4 + 3], y[(i - 1) * 4 + 3]);

            // 根据三个边的关系计算第四个点的坐标
            if (disAB + disAC == disBC) {
                x[i * 4] = x[(i - 1) * 4 + 2] + x[(i - 1) * 4 + 3] - x[(i - 1) * 4 + 1];
                y[i * 4] = y[(i - 1) * 4 + 2] + y[(i - 1) * 4 + 3] - y[(i - 1) * 4 + 1];
            } else if (disAB + disBC == disAC) {
                x[i * 4] = x[(i - 1) * 4 + 1] + x[(i - 1) * 4 + 3] - x[(i - 1) * 4 + 2];
                y[i * 4] = y[(i - 1) * 4 + 1] + y[(i - 1) * 4 + 3] - y[(i - 1) * 4 + 2];
            } else if (disBC + disAC == disAB) {
                x[i * 4] = x[(i - 1) * 4 + 2] + x[(i - 1) * 4 + 1] - x[(i - 1) * 4 + 3];
                y[i * 4] = y[(i - 1) * 4 + 2] + y[(i - 1) * 4 + 1] - y[(i - 1) * 4 + 3];
            }
        }

        // 初始化距离矩阵
        for (int i = 1; i <= s * 4; i++) {
            for (int j = 1; j <= s * 4; j++) {
                if (i != j) {
                    if ((i - 1) / 4 != (j - 1) / 4) {
                        // 如果点i和点j不属于同一个矩形，使用普通路径权重t
                        dis[i][j] = t * getDistance(x[i], y[i], x[j], y[j]);
                    } else {
                        // 如果点i和点j属于同一个矩形，使用该矩形的权重w
                        dis[i][j] = w[(i - 1) / 4 + 1] * getDistance(x[i], y[i], x[j], y[j]);
                    }
                }
            }
        }

        // 使用Floyd-Warshall算法计算所有点对之间的最短路径
        for (int k = 1; k <= s * 4; k++) {
            for (int i = 1; i <= s * 4; i++) {
                for (int j = 1; j <= s * 4; j++) {
                    // 更新最短路径
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }

        // 计算从起点矩形A到终点矩形B的最短路径
        for (int i = 1; i <= 4; i++) {
            for (int j = 1; j <= 4; j++) {
                // 遍历起点矩形A和终点矩形B的所有四个点，找到最短路径
                ans = min(ans, dis[(A - 1) * 4 + i][(B - 1) * 4 + j]);
            }
        }

        // 输出结果，保留一位小数
        printf("%.1lf\n", ans);
    }
    return 0;
}
```
声明：为了提高代码可读性，此代码采用了 AI 重构。

---

## 作者：chrispang (赞：0)

### 前言

好久没有写题解了，上一次写题解的时间还是在七十多天前。趁今天是 5 月 20 日，赶紧写篇题解增加福气。

## 题目大意

给定 $S$ 个城市，每个城市有四个机场，四个机场是一个矩形的四个端点。

之后给定每个城市中的三个机场的坐标，并且给出每个城市高铁单位里程 $t$。

接着给出所有城市的飞机单位里程 $t$。

最后给出两个城市 $A,B$，求出从 $A$ 出发，终点为 $B$，求需要耗费的最小发费是多少。

## 题目分析

这个题目很欠，只给了一个城市中三个机场的坐标，因此我们要根据这三个机场坐标求出第四个机场坐标。

之后，开始建图。

为了防止混淆，第 $i$ 个城市的高铁单位里程我们使用 $t_i$ 来表示，所有城市的飞机单位里程我们使用 $t$ 来表示。

我们枚举每个**机场**，对它们标上距离。如果是同一个城市的，则使用 $t_i$ 作单位。否则使用 $t$ 作单位。

当建图完之后，我们枚举 $A$ 城市的每个机场到达 $B$ 城市的最短距离，期间只有跑几遍最短路即可。

## 代码实现

```cpp
#include <bits/stdc++.h>
#define maxn 110
#define inf 1e9
using namespace std;

int hs(int x1, int y1, int x2, int y2) { return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); }

double jl(double x1, double x2, double y1, double y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

int cnt = 0, s, t, A, B;
struct edge {
    int v;
    double w;
};

struct node {
    int x, y, t;
    vector<edge> linker;
} a[maxn * 4];

double ans = inf, dis[maxn * 4];
void spfa(int x) {
    memset(dis, 0x7f, sizeof(dis));
    queue<int> q;
    q.push(x);
    dis[x] = 0;
    while (!q.empty()) {
        int now = q.front();
        q.pop();
        //		if(x == 1) cout << "yes" << endl;
        for (auto i : a[now].linker) {
            int v = i.v;
            double w = i.w;
            if (dis[v] > dis[now] + w) {
                dis[v] = dis[now] + w;
                q.push(v);
            }
        }
    }
    //	cout << "------------" << endl;
    //	for (int i = 1; i <= cnt; i++) cout << dis[i] << endl;
}

void solve() {
    cnt = 0;
    memset(a, 0, sizeof(a));
    cin >> s >> t >> A >> B;
    for (int i = 1; i <= s; i++) {
        int x1, y1, x2, y2, x3, y3, x4, y4, t;
        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> t;
        int c12 = hs(x1, y1, x2, y2), c13 = hs(x1, y1, x3, y3), c23 = hs(x2, y2, x3, y3);
        if (c12 + c13 == c23)
            x4 = x3 + x2 - x1, y4 = y3 + y2 - y1;
        if (c12 + c23 == c13)
            x4 = x3 + x1 - x2, y4 = y3 + y1 - y2;
        if (c13 + c23 == c12)
            x4 = x1 + x2 - x3, y4 = y1 + y2 - y3;
        a[++cnt] = { x1, y1, t };
        a[++cnt] = { x2, y2, t };
        a[++cnt] = { x3, y3, t };
        a[++cnt] = { x4, y4, t };
    }
    int n = cnt;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            if (i == j)
                continue;
            if ((i - 1) / 4 == (j - 1) / 4)
                a[i].linker.push_back({ j, jl(a[i].x, a[j].x, a[i].y, a[j].y) * a[i].t });
            else
                a[i].linker.push_back({ j, jl(a[i].x, a[j].x, a[i].y, a[j].y) * t });
        }
    //	for (int i = 1; i <= n; i++)
    //		for (auto k:a[i].linker)
    //			cout << i << " " << k.v << " " << k.w << endl;
    for (int i = A * 4 - 3; i <= A * 4; i++) {
        spfa(i);
        for (int j = B * 4 - 3; j <= B * 4; j++) ans = min(ans, dis[j]);
    }
    printf("%.1f\n", ans);
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 作者：Chenaknoip (赞：0)

一道很好的计算几何题目。
### 思路分析
题目要求计算从 A 到 B 的最少花费，这让我们想到了最短路。可以将每个城市的四个机场看成是四个节点，将经过航线和铁路的花费看成边权，形成一张无向连通图。为了方便统计答案，可以开两个“虚拟点”代表 A、B 两城市，分别向它们的机场连一条边权为 $0$ 的边，然后以 A 城市的虚拟点为起点跑最短路。下面将航线和铁路统称为“路”。

如果已知某条路的起点和终点坐标，那么计算长度可以使用距离公式：
$$d_{i,j}=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$$
，接着乘单位里程的价格就能得到边权。由于 $S \le 100$，直接 $\mathcal{O}(S^2)$ 枚举两点暴力建边即可。

但输入数据并没有直接给出每个城市四个机场的坐标，只给了其中三个。因此需要根据三个机场的坐标计算出第四个坐标。已知四个机场分别位于同一矩形的四顶点，所以问题转化为已知矩形三顶点求第四个。这个问题有多种解法，这里采取一种比较好理解的方法。

首先，将已知的三点两两连接，得到三条线段；再根据垂直直线的性质——斜率之积为 $-1$，找到两条垂直的线段和它们的公共短点；最后利用“矩形对边平行且相等”的性质得到第四个点的坐标。

最后计算最短路的方法有多种，这篇题解的代码使用了 Dijkstra 算法。

于是这道题就被愉快地解决了。不懂的地方可以参考代码理解。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Airport {
	int x, y;
};
struct City {
	Airport a[5];
} c[110];
int S, t, A, B, T[110], n;
bool isZhi(int num, int por) {
	int dx1, dx2, dy1, dy2;
	if (por == 1) {
		dx1 = c[num].a[2].x - c[num].a[1].x, dx2 = c[num].a[3].x - c[num].a[1].x;
		dy1 = c[num].a[2].y - c[num].a[1].y, dy2 = c[num].a[3].y - c[num].a[1].y;
	} else if (por == 2) {
		dx1 = c[num].a[1].x - c[num].a[2].x, dx2 = c[num].a[3].x - c[num].a[2].x;
		dy1 = c[num].a[1].y - c[num].a[2].y, dy2 = c[num].a[3].y - c[num].a[2].y;
	} else {
		dx1 = c[num].a[1].x - c[num].a[3].x, dx2 = c[num].a[2].x - c[num].a[3].x;
		dy1 = c[num].a[1].y - c[num].a[3].y, dy2 = c[num].a[2].y - c[num].a[3].y;
	}
	if (dx1 * dx2 < 0) { // change sign
		dx2 = -dx2;
		dy2 = -dy2;
	}
	return dy1 * dy2 == -dx1 * dx2;
}
Airport findAir(int num, int zhiPor) {
	int dx, dy;
	if (zhiPor == 1) {
		dx = c[num].a[2].x - c[num].a[1].x;
		dy = c[num].a[2].y - c[num].a[1].y;
		return (Airport) {c[num].a[3].x + dx, c[num].a[3].y + dy};
	} else if (zhiPor == 2) {
		dx = c[num].a[1].x - c[num].a[2].x;
		dy = c[num].a[1].y - c[num].a[2].y;
		return (Airport) {c[num].a[3].x + dx, c[num].a[3].y + dy};
	} else {
		dx = c[num].a[1].x - c[num].a[3].x;
		dy = c[num].a[1].y - c[num].a[3].y;
		return (Airport) {c[num].a[2].x + dx, c[num].a[2].y + dy};
	}
}
struct Edge {
	int y;
	long long w;
};
struct Node {
	int y;
	long long d;
	bool operator < (const Node &n1) const {
		return d > n1.d;
	}
};
const int inf = 0x3f3f3f3f3f3f3f3f;
const int N = 510;
long long d[N];
vector<Edge> g[N];
bool vis[N];
void dijkstra(int v0) {
	priority_queue<Node> q;
	for (int i = 1; i <= 500; i++) d[i] = inf;
	memset(vis, false, sizeof(vis));
	d[v0] = 0;
	q.push((Node) {v0, 0});
	while (!q.empty()) {
		Node n1 = q.top();
		q.pop();
		int x = n1.y;
		if (vis[x]) continue;
		vis[x] = true;
		for (int j = 0; j < g[x].size(); j++) {
			Edge next = g[x][j];
			int y = next.y, w = next.w;
			if (vis[y]) continue;
			if (d[x] + w < d[y]) {
				d[y] = d[x] + w;
				q.push((Node) {y, d[y]});
			}
		} 
	}
}
int main() {
	scanf("%d", &n);
	while (n--) {
		scanf("%d%d%d%d", &S, &t, &A, &B);
		for (int i = 1; i <= S; i++) {
			for (int j = 1; j <= 3; j++) {
				scanf("%d%d", &c[i].a[j].x, &c[i].a[j].y);
			}
			scanf("%d", &T[i]);
			for (int j = 1; j <= 3; j++) {
				if (isZhi(i, j)) { // 找到垂直线段的公共端点
					c[i].a[4] = findAir(i, j); // 求第四机场坐标
					break;
				}
			}
			for (int j = 1; j <= 4; j++) {
				for (int k = j + 1; k <= 4; k++) { // 建边（铁路）
					g[i * 4 + j].push_back((Edge){i * 4 + k, 
										1000 * T[i] * sqrt((c[i].a[j].x - c[i].a[k].x) * (c[i].a[j].x - c[i].a[k].x) + (c[i].a[j].y - c[i].a[k].y) * (c[i].a[j].y - c[i].a[k].y))
												});
					g[i * 4 + k].push_back((Edge){i * 4 + j, 
										1000 * T[i] * sqrt((c[i].a[j].x - c[i].a[k].x) * (c[i].a[j].x - c[i].a[k].x) + (c[i].a[j].y - c[i].a[k].y) * (c[i].a[j].y - c[i].a[k].y))
												});
				}
			}
		}
		for (int i = 1; i <= S; i++) { // 建边（航线）
			for (int j = i + 1; j <= S; j++) {
				for (int k = 1; k <= 4; k++) {
					for (int l = 1; l <= 4; l++) {
						g[i * 4 + k].push_back((Edge){j * 4 + l, 
										1000 * t * sqrt((c[i].a[k].x - c[j].a[l].x) * (c[i].a[k].x - c[j].a[l].x) + (c[i].a[k].y - c[j].a[l].y) * (c[i].a[k].y - c[j].a[l].y))
						});
						g[j * 4 + l].push_back((Edge){i * 4 + k, 
										1000 * t * sqrt((c[i].a[k].x - c[j].a[l].x) * (c[i].a[k].x - c[j].a[l].x) + (c[i].a[k].y - c[j].a[l].y) * (c[i].a[k].y - c[j].a[l].y))
						});
					}
				}
			}
		}
		for (int i = 1; i <= 4; i++) { // 建虚拟点 A
			g[1].push_back((Edge){A * 4 + i, 0});
		}
		for (int i = 1; i <= 4; i++) { // 建虚拟点 B
			g[B * 4 + i].push_back((Edge){2, 0});
		}
		dijkstra(1); // 求最短路
		printf("%.1lf\n", d[2] / 1000.0);
	}
	return 0;
}
```

---


# [JSOI2004] 平衡点 / 吊打XXX

## 题目描述

如图，有 $n$ 个重物，每个重物系在一条足够长的绳子上。

每条绳子自上而下穿过桌面上的洞，然后系在一起。图中 $x$ 处就是公共的绳结。假设绳子是完全弹性的（即不会造成能量损失），桌子足够高（重物不会垂到地上），且忽略所有的摩擦，求绳结 $x$ 最终平衡于何处。

**注意**：桌面上的洞都比绳结 $x$ 小得多，所以即使某个重物特别重，绳结 $x$ 也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。

![](https://cdn.luogu.com.cn/upload/image_hosting/u20jvui9.png)

## 说明/提示

数据保证平衡点是唯一的，也就是说形如 $n=2$ 且两个物品质量相等的情况不会出现。

## 样例 #1

### 输入

```
3
0 0 1
0 2 1
1 1 1```

### 输出

```
0.577 1.000```

# 题解

## 作者：99NL (赞：236)

# 模拟退火学习笔记

## 1.关于模拟退火

  应该有不少小伙伴们还不知道什么是模拟退火吧，那我今天就来给大家科普科普。
  ### 定义
  模拟退火算法（Simulate Anneal，SA）是一种通用概率演算法，用来在一个大的搜寻空间内找寻命题的最优解。模拟退火是由S.Kirkpatrick, C.D.Gelatt和M.P.Vecchi在1983年所发明的。V.Čern&yacute;在1985年也独立发明此演算法。模拟退火算法是解决TSP问题的有效方法之一。
  
  模拟退火的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法是一种通用的优化算法，其物理退火过程由加温过程、等温过程、冷却过程这三部分组成。
            
                             --------来自百度百科
  ### 说明
  对于百度百科的定义，我也看不大懂，（可能是我太菜了吧）但实际上模拟退火是一个很好理解的东西。简单地说，就是将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。演算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。
## 2.模拟退火的基本要素
### 状态空间与状态产生函数
   (1).搜索空间（又叫状态空间）。一般范围比较大，事我们自定义的可行解的集合。
   
   (2).状态函数。状态函数将决定你是否要选用当前的解，对于一个好的退火来说，状态函数的搜索空间应该足够大。
   
   (3).候选解。一般采用随机数来在一定密度内随机选取。
   
   (4).概率分布。大多采取均匀分布或指数分布。
 ### 状态转移概率
   (1).状态转移概率是指从一个状态向另一个状态的转移概率。
   
   (2).通俗的理解是接受一个新解为当前解的概率。
   
   (3).它与当前的温度参数T有关，随温度下降而减小。
   
   (4).一般采用Metropolis准则。
 ## 3.模拟退火模型
   第一步是由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。
   
   第二步是计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。
   
   第三步是判断新解是否被接受，判断的依据是一个接受准则，最常用的接受准则是Metropolis准则: 若Δt′<0则接受S′作为新的当前解S，否则以概率exp(-Δt′/T)接受S′作为新的当前解S。
   
   第四步是当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。
   
   模拟退火算法与初始值无关，算法求得的解与初始解状态S(是算法迭代的起点)无关；模拟退火算法具有渐近收敛性，已在理论上被证明是一种以概率收敛于全局最优解的全局优化算法；模拟退火算法具有并行性。
   
## 4.参数控制

  模拟退火算法的应用很广泛，可以求解NP完全问题，但其参数难以控制，其主要问题有以下三点：
  
(1) 温度T的初始值设置问题。
温度T的初始值设置是影响模拟退火算法全局搜索性能的重要因素之一、初始温度高，则搜索到全局最优解的可能性大，但因此要花费大量的计算时间；反之，则可节约计算时间，但全局搜索性能可能受到影响。实际应用过程中，初始温度一般需要依据实验结果进行若干次调整。

(2) 退火速度问题。
模拟退火算法的全局搜索性能也与退火速度密切相关。一般来说，同一温度下的“充分”搜索(退火)是相当必要的，但这需要计算时间。实际应用中，要针对具体问题的性质和特征设置合理的退火平衡条件。

(3) 温度管理问题。
温度管理问题也是模拟退火算法难以处理的问题之一。实际应用中，由于必须考虑计算复杂度的切实可行性等问题，常采用如下所示的降温方式：式中k为正的略小于1.00的常数，t为降温的次数。
!

[模拟退火流程图](https://baike.baidu.com/pic/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/8664695/0/7aec54e736d12f2e13f34c9b4ec2d56284356853?fr=lemma&ct=single)

## 5.算法改进

（1）设计合适的状态产生函数，使其根据搜索进程的需要表现出状态的全空间分散性或局部区域性；

（2）设计高效的退火策略；

（3）避免状态的迂回搜索；

（4）采用并行搜索结构；

（5）为避免陷入局部极小，改进对温度的控制方式；

（6）选择合适的初始状态；

（7）设计合适的算法终止准则。

## 6.实战演练

[P1337 [JSOI2004]平衡点 / 吊打XXX](https://www.luogu.org/problemnew/show/P1337)

## 7.代码实现
```cpp
#include <bits/stdc++.h>
#define down 0.996//徐徐降温 

using namespace std;

int n;
struct node{
int x;
int y;
int w;
}object[2005];//存下物体的坐标 
double ansx,ansy,answ;//最终答案 
double energy(double x,double y)//根据物理学知识,能量总和越小越稳定 
{
   double r=0,dx,dy;
   for (int a=1;a<=n;a++)
   {
      dx=x-object[a].x;
      dy=y-object[a].y;
      r+=sqrt(dx*dx+dy*dy)*object[a].w;
   }
      return r;
}
void sa()//模拟退火 
{
   double t=3000;//温度要足够高 
   while (t>1e-15)//略大于0 
   {
      double ex=ansx+(rand()*2-RAND_MAX)*t;//随机产生新的答案 
      double ey=ansy+(rand()*2-RAND_MAX)*t;
      double ew=energy(ex,ey);
      double de=ew-answ;
      if (de<0)//如果此答案更优，就接受 
      {
         ansx=ex;
         ansy=ey;
         answ=ew;
      }
      else if(exp(-de/t)*RAND_MAX>rand())//否则根据多项式概率接受 
      {
         ansx=ex;
         ansy=ey;
      }
      t*=down;
   }
}
void solve()//多跑几遍退火,增加得到最优解的概率 
{
   sa();
   sa();
   sa();
   sa();
}
int main() {
cin>>n;
for (int a=1;a<=n;a++)
{
   scanf("%d%d%d",&object[a].x,&object[a].y,&object[a].w);
   ansx+=object[a].x;
   ansy+=object[a].y;
}
ansx/=n;//以平均数作为初始答案 
ansy/=n;
answ=energy(ansx,ansy);
solve();
printf("%.3lf %.3lf\n",ansx,ansy);//华丽的输出 
    return 0;
}
```

---

## 作者：jiuguaiwf (赞：212)

#### 一道2.7K通过的题愣是没啥新点子

题解无非两类：退火和几何（wustdio独树一帜nb）。

那我来写一个三分套三分：咦，一发A掉？？？

想那个经典问题：二维平面上有n个点，求平面中的一个点（这个点不一定与给出的n个点重合），使其到所有点的距离和最小。

#### 我不会证明但需要记住的结论：确定x坐标时，关于y坐标的函数是单峰函数；确定y坐标时，关于x的函数是单峰的。

单峰函数-->三分

回到本题，当质点稳定时我们不妨列一个受力平衡的柿子，发现其实就是势能最小时。

咦，经典问题是求dis,现在是求Wi*dis，不一样吧？

你想成有Wi个点坐标相同重合不就完了2333

所以三分个X，三分个Y，AC走人~

复杂度有保证~

#### 鉴于有人拿这道题当模拟退火模板题：单峰函数真的证明不了你的退火强劲与否啊！！！



```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<queue>
typedef double DB;
using namespace std;
DB ly,ry,x[1005],y[1005],w[1005];
int n;
DB dis(DB a,DB b,DB c,DB d)
{
	return sqrt((c-a)*(c-a)+(d-b)*(d-b));
}
DB work(DB X,DB Y)
{
	DB num=0;
	for (int i=1;i<=n;++i)
	  num+=w[i]*dis(X,Y,x[i],y[i]);
	return num;
}
DB thre(DB X)//三分Y
{
	ly=-10000.0;
	ry=10000.0;
	for (int i=1;i<=100;++i)
	{
		DB del=(ry-ly)/3.0;
		DB m1=ly+del;
		DB m2=ry-del;
		DB w1=work(X,m1);
		DB w2=work(X,m2);
		if (w2<w1) ly=m1;
		else ry=m2;
	}
	return work(X,ly);
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;++i)
	  scanf("%lf%lf%lf",&x[i],&y[i],&w[i]);
	DB lx=-10000.0;
	DB rx=10000.0;
	for (int i=1;i<=100;++i)//三分X
	{
		DB del=(rx-lx)/3.0;
		DB m1=lx+del;
		DB m2=rx-del;
		DB w1=thre(m1);
		DB w2=thre(m2);
		if (w2<w1) lx=m1;
		else rx=m2;
	}
	printf("%.3lf %.3lf",lx,ly);
	return 0;
}

```
NOI2019 Bless all !

---

## 作者：wucstdio (赞：166)

最近几天一直在怼计算几何……

这道题为什么要用模拟退火？明明是个：

## 二分！

假设我们已经确定了平衡点在下面的多边形内，那么在多边形内部选一个尽量靠近中间的点，然后确定受力方向：

![](https://cdn.luogu.com.cn/upload/pic/46086.png)

然后我们发现，平衡点只能在黄色的新多边形内！

所以思路就出来了：先加上几个无穷远的点，然后不断用一个半平面去切割一个凸包得到一个新的凸包，进行二分，二分几十次后多边形会非常小，这时任意选一个顶点就是答案了，时间复杂度大概是$O(kn)$，$k$是二分次数，取到60就能AC。

关键问题有两个：确定受力方向和半平面切割凸包。

每一个问题很简单，用每一个点和中心形成的单位向量乘质量，然后向量相加就行了。

对于第二个问题(convexcut)，我们可以顺次枚举原凸包上的点，如果这个点在半平面内部就加入到新的凸包，然后看这个点和下一个点形成的线段和半平面是否有交，如果有交就把交点加到新的凸包里面。

具体实现看代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=1e-9;
int sign(double a){return a<-eps?-1:a>eps;}//带eps的实数比较
struct Point
{
    double x,y;
    Point(double xx=0,double yy=0){x=xx,y=yy;}
    Point operator+(Point p){return Point(x+p.x,y+p.y);}
    Point operator-(Point p){return Point(x-p.x,y-p.y);}
    Point operator*(double d){return Point(x*d,y*d);}
    Point operator/(double d){return Point(x/d,y/d);}
    double dot(Point p){return x*p.x+y*p.y;}//点乘
    double det(Point p){return x*p.y-y*p.x;}//叉乘
    double abs2(){return x*x+y*y;}
    double abs(){return sqrt(abs2());}
    Point unit(){return sign(abs())==0?Point(0,0):(*this)/abs();}//单位向量，注意0向量的情况
    Point rot90(){return Point(y,-x);}//旋转90度，用来把受力方向转变成半平面
}p[1005],last[1005],ans[1005];
int n,w[1005],top_last,top_ans;
double cross(Point p1,Point p2,Point q)
{
    return (p2-p1).det(q-p1);
}
int crossOp(Point p1,Point p2,Point q){return sign(cross(p1,p2,q));}//用于判断q是否在p1p2的左侧
Point isLL(Point p1,Point p2,Point q1,Point q2)//直线交点
{
    double x=(p2-p1).det(q2-p1);
    double y=(q1-p1).det(p2-p1);
    return q1+(q2-q1)/(x+y)*y;
}
void cut(Point q1,Point q2)//半平面切凸包
{
    top_ans=0;
    int n=top_last;
    for(int i=1;i<=n;i++)
    {
        Point p1=last[i],p2=last[i%n+1];
        int d1=crossOp(q1,q2,p1),d2=crossOp(q1,q2,p2);//看这两个点与半平面的位置关系
        if(d1>=0)ans[++top_ans]=p1;
        if(d1*d2<0)ans[++top_ans]=isLL(p1,p2,q1,q2);
    }
    for(int i=1;i<=top_ans;i++)last[i]=ans[i];
    top_last=top_ans;
}
void work()
{
    int m=top_last;
    Point o(0,0);
    for(int i=1;i<=m;i++)o=o+last[i];
    o=o/m;//求的中心点，不知道有没有更优的取法，反正这样能AC
    Point P(0,0);
    for(int i=1;i<=n;i++)
        P=P+(p[i]-o).unit()*w[i];//p是受力方向
    if(P.abs()<=eps)//update
    {
    	printf("%.3lf %.3lf\n",o.x,o.y);
    	exit(0);
	}
    P=o+P.rot90();
    cut(o,P);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      scanf("%lf%lf%d",&p[i].x,&p[i].y,&w[i]);
    last[1]=Point(-10000,-10000);
    last[2]=Point(10000,-10000);
    last[3]=Point(10000,10000);
    last[4]=Point(-10000,10000);
    top_last=4;
    for(int i=1;i<=60;i++)//二分
      work();
    printf("%.3lf %.3lf\n",last[1].x,last[1].y);
    return 0;
}
```

update：

一年过去了竟然又发现了一个锅（已经修正）

感谢评论区提醒。

我们注意到，每次需要求出受力方向。而如果受力刚好是 $0$ 那么我们发现就无法切割凸包。

加一句特判就好了。如果受力等于 $0$ 直接输出中心点。

---

## 作者：宁_缺 (赞：150)

# 目前最短代码，没有之一
(其他人行数看不到，但**550B**的代码量在本题的AC记录里是妥妥**rank1**的（绝大多数都在1000B以上），而且**时效也不差**（**28~29ms**）)

好了，下面步入正题

本题用不着任何玄学算法，每次给绳结算一下合力，然后沿着合力方向移动一下。

因为绳结不断移动的过程中，系统是不断趋向平衡的，因此每次移动的长度会不断缩小，当移动长度缩小到无法改变最终结果时输出当前位置，结束

这样也省的算重力势能啥的了（~~事实上初二下物理都没学的我也不会~~）

_当然，你说你厉害，用SA,PSO这些算法能吊打我……怎么说呢，个人想要时间复杂度和编程复杂度都小，你要是觉得这样有意思，我也无话可说_

最后，附上25行的代码
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define E(x) ((x)*(x))
const int N=1009;
int n,px[N],py[N],pw[N];
double x,y,lon=10000.0;//初始移动长度
void move(double l){
	double sx=0,sy=0,g;
	for(int i=1;i<=n;i++){//将绳结上的力正交分解，横向的加给sx，纵向加给sy
		g=sqrt(E(px[i]-x)+E(py[i]-y));
		if(g==0)continue;
		sx+=pw[i]/g*(px[i]-x);
		sy+=pw[i]/g*(py[i]-y);
	}
	g=sqrt(sx*sx+sy*sy);//算出合力大小
	x+=l/g*sx,y+=l/g*sy;//向合力方向移动l
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&px[i],&py[i],&pw[i]);
	while(lon>4e-4)
		move(lon),lon*=0.618;//lon乘多少随你定，不是太小都能过
	printf("%.3f %.3f\n",x,y),exit(0);
}
```
_告辞_

---

## 作者：Snitro (赞：111)

# [http://blog.csdn.net/fine\_rose/article/details/78210657](http://blog.csdn.net/fine\_rose/article/details/78210657)


我们可以确定一个原点，将所有的力在这个原点上正交分解，最终我们可以得到所有的力的一个合力，而真正的平衡点一定在合力所指向的方向


每当分得到一个合力之后，将原点在合力的方向上位移一定的距离。每当原点位移的方向发生了改变的时候，缩小以后操作的位移距离。例如：上次操作是将原点像 x 轴正方向移动，而当前移动是将原点像 x 轴负方向上移动，这说明原点的横坐标一定在这两次假设的原点的横坐标中间，因此我们缩小以后原点移动的距离。


当两次移动的坐标差在一定的范围之内时，说明我们得到了解，输出即可(注意：规定的范围一定要小于题目所要求的精度范围)


可以通过代码理解



















```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#define abs(x) ((x) >= 0 ? (x) : (-(x)))
using namespace std;
int n;
double x, y;
bool XF = true, YF = true;//原点移动的方向 true 代表正方向，false 代表负方向
struct Position {
    int x;
    int y;
    int power;
} positions[1005];
void solve(double move) {
    double X, Y, temp;
    X = Y = 0;
    for (int i = 1; i <= n; i++) {
        temp = sqrt((x - positions[i].x) * (x - positions[i].x) + (y - positions[i].y) * (y - positions[i].y));//记录该点到原点的欧几里得距离
        if (temp == 0)//判断是否与原点重合
            continue;
        //若不重合则进行正交分解
        X += positions[i].power / temp * (positions[i].x - x);
        Y += positions[i].power / temp * (positions[i].y - y);
    }
    temp = sqrt(X * X + Y * Y);//计算正交分解后的合力
    //将原点在合力方向上位移一定距离
    x += move / temp * X;
    y += move / temp * Y;
}
int main() {
    freopen("in.txt", "r", stdin);
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d%d%d", &positions[i].x, &positions[i].y, &positions[i].power);
    //move：移动的步长  tx ty 保存移动前的原点的位置
    double move = 5000, tx, ty;
    while (true) {
        //记录移动前原点的位置
        tx = x;
        ty = y;
        solve(move);//按照步长移动原点
        if (abs(tx - x) < 0.00001 && abs(ty - y) < 0.00001)//判断是否满足要求
            break;
        if ((XF != (x > tx)) || (YF != (y > ty))) {//如果移动方向发生改变
            //记录移动方向
            XF = !x > tx;
            YF = !y > ty;
            move = move * 0.9;//缩小移动方向
        }
    }
    printf("%.3f %.3f", x, y);
    return 0;
}
```

---

## 作者：SuperJvRuo (赞：90)

前面的几篇题解似乎都没有重点说模拟退火的算法。

## 一、模拟退火步骤

选定一个初始状态（比如选定所有点坐标的平均数），选定一个初始温度T。

当温度大于一个边界值时：
```
{
　　随机变化坐标，变化幅度为 T 。

　　计算新解与当前解的差 DE。

　　如果新解比当前解优(DE > 0)，就用新解替换当前解。

　　否则以 exp(DE / T) 的概率用新解替换当前解。

　　温度乘上一个小于1的系数，即降温。
}
```
这样，随着温度不断降低，变化幅度也越来越小，接受一个更劣的解的概率也越来越小。

## 二、模拟退火注意事项

1. 温度T的初始值设置问题。
初始温度高，则搜索到全局最优解的可能性大，但因此要花费大量的计算时间；反之，则可节约计算时间，但全局搜索性能可能受到影响。

2. 退火速度问题。
模拟退火算法的全局搜索性能也与退火速度密切相关。同一温度下的“充分”搜索(退火)是相当必要的，但这需要计算时间。

3. 温度管理问题
降温系数应为正的略小于1.00的常数。

关于这道题，一切自然变化进行的方向都是使能量降低，因为能量较低的状态比较稳定。

因为物重一定，绳子越短，重物越低，势能越小，势能又与物重成正比，所以，只要使得$\sum_{i=1}^ndist[i]*weight[i]$也就是总的重力势能最小，就可以使系统平衡

```
#include<cstdio>
#include<cctype>
#include<cmath>
#include<cstdlib>

int Read()
{
	int x=0,y=1;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
		{
			y=-1;
		}
		c=getchar();
	}
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x*y;
}

struct Node
{
	int x,y,weight;
}node[10005];
int n;

double potential_energy(double nowx,double nowy)
{
	double sum=0;
	for(int i=1;i<=n;i++)
	{
		double delx=nowx-node[i].x;
		double dely=nowy-node[i].y;
		sum+=(sqrt(delx*delx+dely*dely))*node[i].weight;
		//物重一定，绳子越短，重物越低，势能越小 
		//势能又与物重成正比 
	}
	return sum;//在(nowx,nowy)处的总势能 
}

double xans,yans;//最终答案 
double ans=1e18+7,t;//势能与温度
const double delta=0.993;//降温系数

void simulate_anneal()
{
	double xx=xans;//钦定一个初始位置
	double yy=yans;
	t=1926;//t是温度
	while(t>1e-14)
	{
		double xtemp=xans+(rand()*2-RAND_MAX)*t;
		double ytemp=yans+(rand()*2-RAND_MAX)*t;
		//随机一个新的坐标，变化幅度为t
		//这里要注意rand()和rand()*2-RAND_MAX的区别
		//rand()的范围是0~RAND_MAX-1
		//rand()*2-RAND_MAX的范围是-RAND_MAX到RAND_MAX-1 
		
		double new_ans=potential_energy(xtemp,ytemp);//计算当前解的势能 
		double DE=new_ans-ans;
		if(DE<0)//如果是一个更优解
		{
			xx=xtemp;
			yy=ytemp;//就接受
			xans=xx;
			yans=yy;
			ans=new_ans;
		}
		else if(exp(-DE/t)*RAND_MAX>rand())//能否接受这个差 
		{
			//更新坐标
			xx=xtemp;
			yy=ytemp;
		}
		t*=delta;//降温 
	}
}

void SA()//洗把脸就AC了 
{
	simulate_anneal();
	simulate_anneal();
	simulate_anneal();
}

int main()
{
	n=Read();
	for(int i=1;i<=n;i++)
	{
		node[i].x=Read();
		node[i].y=Read();
		node[i].weight=Read();
	}
	SA();
	printf("%.3lf %.3lf",xans,yans);
	return 0;
}
```

---

## 作者：pengym (赞：32)

**[原题链接](https://www.luogu.org/problemnew/show/P1337)**

**关于模拟退火的详细介绍，可以[peng-ym](https://www.cnblogs.com/peng-ym/p/9158909.html)关于模拟退火的介绍。**

## 题目描述
- 如图：有n个重物，每个重物系在一条足够长的绳子上。每条绳子自上而下穿过桌面上的洞，然后系在一起。图中X处就是公共的绳结。假设绳子是完全弹性的（不会造成能量损失），桌子足够高（因而重物不会垂到地上），且忽略所有的摩擦。
- 问绳结X最终平衡于何处。
- 注意：桌面上的洞都比绳结X小得多，所以即使某个重物特别重，绳结X也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。

## 输入输出格式
- 输入格式：
文件的第一行为一个正整数n（1≤n≤1000），表示重物和洞的数目。接下来的n行，每行是3个整数：Xi.Yi.Wi，分别表示第i个洞的坐标以及第 i个重物的重量。(-10000≤x,y≤10000, 0<w≤1000 )
- 输出格式：
你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结X的横坐标和纵坐标。两个数以一个空格隔开。

## 解题思路
- 这题怕不是OI中为数不多的与物理有关系的题。~~（233）~~
- 题目询问的是绳结最终平衡于何处？
- 根据物理的知识，当系统处于平衡状态时，系统的总能量最小。
- 又此时系统的总能量是等于各个物体的重力势能，在质量一定时，即要求物体离地最近，离桌子最远。
- 那么，也就是绳子在桌子上的距离尽量的小。即：$\sum_{i=1}^{n}m_i*dist_{i,x}$最小。
- 模拟退火要解决的问题就是找到这一个点的位置。
- 模拟退火最主要的参数有几个：$T_0$初始温度，$t$每一次下降的温度，$ans$目前为止最优的答案，$now$新的状态，$delta$当前答案与最优答案的差值。
- 在扩展状态时有一个小方法：$(rand()*2-RANDMAX)*T$。这样的原理是$(rand()*2-RANDMAX)$的范围是从负数到正数的，这样子在扩展坐标的时候就可以多方向扩展，不会只在一个方向上更新。
- （PS：还有一个很重要的问题，玄学调参。这种问题最好在可以看到评测结果的OJ上交，不然你不会知道是自己打错了，还是参数没调好。。。。。。）

## 直接上代码： 
```cpp
#include<bits/stdc++.h>
#define N 2000
using namespace std;
template<typename T>inline void read(T &x)
{
    x=0;
    static int p;p=1;
    static char c;c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c-48);c=getchar();}
    x*=p;
}
struct node
{
    double x,y,w;
}e[N];
int n;
double ansx,ansy;
const double eps=1e-15;
double f(double x,double y)
{
    double tot=0;
    for(int i=1;i<=n;i++)
    {
        double delx=x-e[i].x;
        double dely=y-e[i].y;
        tot+=sqrt(delx*delx+dely*dely)*e[i].w;
    }
    return tot;
}
void mnth()
{
    double T=200;
    while(T>eps)
    {
        double nowx=ansx+(rand()*2-RAND_MAX)*T;
        double nowy=ansy+(rand()*2-RAND_MAX)*T;
        double delta=f(nowx,nowy)-f(ansx,ansy);
        if(delta<0)ansx=nowx,ansy=nowy;
        else if(exp(-delta/T)*RAND_MAX>rand())ansx=nowx,ansy=nowy;
        T*=0.998;
    }
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("mnth.in","r",stdin);
    freopen("mnth.out","w",stdout);
#endif
    srand((int)time(NULL));
    read(n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf%lf",&e[i].x,&e[i].y,&e[i].w);
        ansx+=e[i].x;ansy+=e[i].y;
    }
    ansx/=(double)n;ansy/=(double)n;
    mnth();
    printf("%.3lf %.3lf\n",ansx,ansy);
    return 0;
}
```

---

## 作者：FlashHu (赞：31)

很可惜，充满Mo力的Mo拟退火并不是正解。不过这是一道最适合开始入手Mo拟退火的好题。

对模拟退火还不是很清楚的可以[看一下](http://www.cnblogs.com/flashhu/p/8884132.html)

这道题还真和能量有点关系。达到平衡稳态的时候，物体的总能量应该是最小的。而总的能量来源于每个物体的重力势能之和。要想让某个物体势能减小，那就让拉着它的绳子在桌面下方的长度尽可能的长，也就是桌面上的要尽可能短。由此看来，某个物体的势能与桌面上的绳子的长度、物体重量都成正比。

于是，为了找到平衡点，我们要找一个点使得$\sum_{i=1}^n d_i*w_i$最小（$d_i$为$i$点到该点的距离）。

函数已经求出来了，接下来就是正常的模拟退火过程。注意一些细节就好了。

首先，初始解可以设成$({\sum_{i=1}^n x_i\over n},{\sum_{i=1}^n y_i\over n})$，可以更接近正解

解变动值最好随机两个值，$\Delta x$和$\Delta y$。随机变动距离和角度可能常数有点大。

然后是写法问题。蒟蒻又学习了一招，知道有一个常数叫RAND_MAX，用于生成$[0,1)$的随机值还是很方便的，在不同机子下可移植性也很强。（难怪Windows上rand出来的都是短整形数）

另外，因为退火的时候有可能本来找到了最优解，但后来接受了较劣解并逐步降温稳定了，那么也就是说本来找到的最优解到最后却给弄丢了。

为了避免这种情况，蒟蒻参考YL的做法，设一个全局最优解best，它只接受比自己更优的解。

而且这样还有一个好处，就是进行多次退火的过程中，也能保证best是单调递减的，无论如何也不会变劣。

最后就是调参数的问题了。

发现自己写了个假的模拟退火以后，蒟蒻马上一改，却发现参数又需要重新调。。。。。。（YL据老也背了锅）

拼命的二分，二分。。。。。。参数大得都要TLE了还是不能保证正确率？！

结果小号提交记录第二次刷屏了（第一次还是打表过洛谷愚人节T3。。。。。。）

后来突然猛地一想：$n,x,y,w$都不小，乘来乘去不会掉精度了吧？

于是改用long double继续，情况好多了

下面的参数可供参考

```cpp
#include<cstdio>
#include<cmath>
#include<ctime>
#include<cstdlib>
#define RG register
#define R RG long double
#define RD T*(rand()*2-RAND_MAX)//生成一个-T到T的随机变动距离
//以前写的是T*((double)rand()/RAND_MAX*2-1)，总是WA（可能是先除后乘掉精度了），然后就参考了YL的写法
const int N=1009;
const long double D=0.97,EPS=1e-14;//更新后二分出了保证极高正确率和较高效率的参数
double x[N],y[N],w[N];
int n;
inline long double calc(R x0,R y0){
    R res=0,dx,dy;
    for(RG int i=1;i<=n;++i){//函数求值
        dx=x[i]-x0;dy=y[i]-y0;
        res+=sqrt(dx*dx+dy*dy)*w[i];
    }
    return res;
}
int main(){
    R T,x0,y0,x1,y1,res,ans,best,bx=0,by=0;
    RG int i,times=1;//一次的正确率很高的，不放心也可以调大
    scanf("%d",&n);
    for(i=1;i<=n;++i){
        scanf("%lf%lf%lf",&x[i],&y[i],&w[i]);
        bx+=x[i];by+=y[i];
    }//初始横纵坐标均选择平均值
    best=ans=calc(bx/=n,by/=n);
    srand(time(NULL));
    while(times--/*clock()<CLOCKS_PER_SEC*0.9*/){//比赛的时候试试注释里写的，卡时还是靠谱些
        ans=best;x0=bx;y0=by;
        for(T=100000;T>EPS;T*=D){
            x1=x0+RD;y1=y0+RD;
            res=calc(x1,y1);
            if(best>res)
                best=res,bx=x1,by=y1;//更新最优答案
            if(ans>res||exp((ans-res)/T)>(long double)rand()/RAND_MAX)
                ans=res,x0=x1,y0=y1;//接受新解
        }
    };
    printf("%.3Lf %.3Lf\n",bx,by);
    return 0;
}
```

---

## 作者：QwQ蒟蒻wjr (赞：15)

>> 题目链接：[[JSOI2004]平衡点 / 吊打XXX](https://www.luogu.org/problem/P1337)

这篇题解原发于[我的blog](https://wangjunrui.netlify.com/2019/10/25/%E6%B4%9B%E8%B0%B7-p1337-jsoi2004-%E5%B9%B3%E8%A1%A1%E7%82%B9-%E5%90%8A%E6%89%93xxx/)
据说这是一道模拟退火的题

那我也来做一做~~乱搞~~

模拟退火模板
```cpp
t=初始温度;
while(t>eps)
{
  tmp=从当前找到的最优转态随机找到的一个转态;
  d=calc(now)-calc(ans);
  if(d<0)
    ans=tmp;
  else if(exp(d/t)*RAND_MAX>rand())
    ans=now;
  t*=cold;
}
```
总之这个算法全靠$rp++$

~~理论上运气好的话你可以AK~~

![蒟蒻调试代码](https://cdn.luogu.com.cn/upload/image_hosting/4a42etnm.png)

~~蒟蒻调试的代码不堪入目~~

### 接下来讨论此题：

当解最优时

所算的势能
$$\sum^{n}_{i=1}\sqrt {(ans_x-x[i])^2+(ans_y-y[i])^2}*w[i]$$

一定尽量小

于是乎，就可以调模拟退火了

总之
模拟退火是一个极为玄学的算法，全靠$rp$    ！！！

最后贴上代码~~知道你们只看这个~~：
```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
template<typename T>
inline void read(T&x)
{
	x=0;
	char s=getchar();
	bool f=false;
	while(!(s>='0'&&s<='9'))
	{
		if(s=='-')
			f=true;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<1)+(x<<3)+s-'0';
		s=getchar();
	}
	if(f)
		x=(~x)+1;
	return;
}
#define re register
#define temperature 1e5
#define cold 0.996 
const int N=1e3+10;
int n;
double ans,ansx,ansy;
struct node
{
	int x,y,w;
} a[N];
inline double calc(double x,double y)//计算势能，势能越小解越优
{
	double energy=0.0;
	for(re int i=1; i<=n; i++)
		energy+=sqrt((x-a[i].x)*(x-a[i].x)+(y-a[i].y)*(y-a[i].y))*a[i].w;
	return energy;
}
inline void solve()
{
	double t=temperature;
	while(t>1e-18)
	{
		double tmpx=ansx+(rand()+rand()-RAND_MAX)*t,tmpy=ansy+(rand()+rand()-RAND_MAX)*t;
		double tmp=calc(tmpx,tmpy);
		double d=tmp-ans;
		if(d<0.0)
			ans=tmp,ansx=tmpx,ansy=tmpy;
		else if(exp(-d/t)*RAND_MAX>rand())
			ansx=tmpx,ansy=tmpy;
		t*=cold;
	}
}
int main()
{
	srand(rand());
	read(n);
	for(re int i=1; i<=n; i++)
	{
		read(a[i].x),read(a[i].y),read(a[i].w);
		ansx+=a[i].x;
		ansy+=a[i].y;
	}
	ansx/=n,ansy/=n,ans=calc(ansx,ansy);//乱搞一个初始值
	for(re int i=1; i<=4; i++)//多搞几次
		solve();
	printf("%.3lf %.3lf\n",ansx,ansy);
	return 0;
}
```
~~马蜂差评~~

~~建议大家请别忙着抄，因为管理员可能会加强数据，程序还要自己打，但是我的代码确实是$AC$代码。~~

---

## 作者：干物国大皇帝 (赞：13)

最近练模拟退火ing，参考Flash_Hu大犇的博客后根据自己理解，对《平衡点/吊打XXX》这个题整理出了一份题解。至于讲解嘛，就用胡犇的博客吧，写不到那么好呀（~~主要是懒？~~），我就简单提一下。

------------
当时见到这个题的题干，真是帅脸懵B，在想算法之前就死在了读题上（~~你体会过绝望吗~~）。后来得高人指点，他告诉我这是一道~~物理~~逻辑题，最终我得到如下思路：

坐标稳定 ——> 能量稳定 ——> 势能总和最小 ——> E=mgh ——>( 重物高度 x 对应M)最低 ——> (桌下的绳子长度 x 对应M)最大 ——> (桌面上的绳长 x 对应M)最小

------------
**讲解戳这里** ：http://www.cnblogs.com/flashhu/p/8884132.html


**代码看下面**：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define RD T*(rand()*2-RAND_MAX)
//生成[-T*RAND_MAX,T*RAND_MAX)的随机变动范围（rand():[0,RAND_MAX)）
#define ld long double
#define il inline

const ld D = 0.99, EPS = 1e-15;//D:温度变化率
const int N = 1005;
ld best, ans, bx, by, res;//bx:best_x, by:best_y
double x[N], y[N], w[N];
int n;


il ld calc(ld x0, ld y0)  {//求总势能 
  ld dx, dy, res = 0;
  for(int i = 1; i <= n; ++i)  {
  	dx = x[i]-x0;  dy = y[i]-y0;
  	res += sqrt(dx*dx+dy*dy)*w[i];//三角函数都会吧
  }
  return res;
}


int main()  {
  ld x0, y0, x1, y1;//注意：这几个函数名不能用作全局变量
  
  scanf("%d", &n);
  for(int i = 1; i <= n; ++i)  {
  	scanf("%lf%lf%lf", x+i, y+i, w+i);
  	bx+=x[i], by+=y[i];
  }
  best = ans = calc(bx/=n,by/=n);//初始横纵坐标均选择平均值
  
  srand(20020202);//这里最好不要用time(NULL)，否则可能同组输入数据得到不同答案，被评测机WA掉。
  
/*******祝她17岁生日快乐*******/
  
  int tim = 1;
//一般模拟退火只要温度和降温率对一次就够了（非酋除外）
  while(tim--)  {
  	ans = best;
	x0 = bx, y0 = by;
	for(ld T=1000000; T>EPS; T*=D)  {
	  x1 = x0+RD, y1 = y0+RD;
	  res = calc(x1,y1);
	  if(best > res)//更新最优答案
	    best = ans, bx = x1, by = y1;
	  if(ans>res || exp((ans-res)/T) > (ld)rand()/RAND_MAX)//exp:返回e的 n次幂(e^n)
        ans = res, x0 = x1, y0 = y1;//接受新解
	}
  }
  
  printf("%.3Lf %.3Lf", bx, by);//注意空格哈
  
  return 0;
}
//祝各位OIer们新年快乐！
```

---

## 作者：xiaoniu142857 (赞：5)

## 0x01 梯度下降的算法思想
梯度下降（Gradient Descent）是一种通用的优化算法，能够为大范围的问题找到最优解。梯度下降的核心思想就是通过沿着目标函数的梯度负方向不断迭代更新参数从而使目标函数最小化。该算法被广泛应用于机器学习和 AI 中。

若将目标函数视为一个超曲面，梯度下降的过程即为从曲面上的某一点出发，沿着坡度最陡的下坡方向一步步移动，直到接近最低点。

假设目标函数为 $J(\theta)$，其中 $\theta=(\theta_1, \theta_2, \dots, \theta_n)$ 是待优化的参数组成的向量。首先，梯度下降使用一个按一定规则初始化的 $\theta$ 值，然后逐步改进，每次走出一步，尝试降低一点 $J(\theta)$ 的值，直到算法收敛。
## 0x02 参数更新过程
梯度 $\nabla_\theta J(\theta)$ 是一个向量，其每个分量为函数对相应参数的偏导数，即：
$$
\nabla_\theta J(\theta)=\left(\frac{\partial J(\theta)}{\partial \theta_1},\frac{\partial J(\theta)}{\partial\theta_2},\dots, \frac{\partial J(\theta)}{\partial \theta_n} \right)
$$
梯度的方向表示函数在该点增长最快的方向，而梯度的负方向则是函数值下降最快的方向。在每次迭代中，参数按如下公式更新：
$$
\theta_{t+1}=\theta_t-\eta\cdot\nabla_\theta
$$
其中：
-   $\theta_t$ 是第 $t$ 次迭代后的参数值。
-   $\eta$ 是学习率（Learning Rate），控制每次更新的步长。

![](https://cdn.luogu.com.cn/upload/image_hosting/z1pgk8d2.png)

若学习率过低，算法要经过大量迭代才能收敛，耗费大量时间。

![](https://cdn.luogu.com.cn/upload/image_hosting/c3qdms1p.png)

若学习率过高，算法可能直接越过极小值，会导致算法震荡或发散。

![](https://cdn.luogu.com.cn/upload/image_hosting/ijslfak2.png)

并不是所有目标函数都是碗状的。有些函数的形状可能会导致算法很难找到最小值。如果从下图的左边出发会陷入局部极小值。从右侧出发则会经过很长时间才能穿越整片高原。

![](https://cdn.luogu.com.cn/upload/image_hosting/k0q2lios.png)
## 0x03 梯度下降的分类
在机器学习中，根据每次迭代使用的样本量，梯度下降可分为三类：
|类型|定义与特点|优缺点|
|:-:|:-:|:-:|
|批量梯度下降（BGD）| 每次迭代使用全部训练数据计算梯度，更新参数。|收敛方向稳定，但数据量庞大时计算成本高，迭代速度慢。|
|随机梯度下降（SGD）| 每次迭代仅使用一个样本计算梯度，更新参数。| 计算效率高，更新频繁但方向随机性大，可能震荡或在最小值附近波动，但具有随机性，有助于跳出局部最小值。|
|小批量梯度下降（MBGD）| 每次迭代使用一小批样本计算梯度，更新参数。| 结合 BGD 和 SGD 的优点，既保证收敛稳定性，又提高计算效率，实际中最常用。|
## 0x04 例题：[P1337 [JSOI2004] 平衡点 / 吊打XXX](https://www.luogu.com.cn/problem/P1337)
### 题目大意
给定平面上 $n$ 个点，求它们的带权费马点。即求一个绳结所在点 $(x,y)$ 使得 $\sum_{i=1}^n w_i\sqrt{(x_i-x)^2+(y_i-y)^2}$（绳结位置到所有点的加权欧拉距离之和）最小。这一点可以参考其他题解的物理分析，这里就不再赘述。
### Solution
这道题明明是裸的梯度下降呀！参数向量 $\theta$ 即为绳结坐标 $(x,y)$，目标函数 $J(x,y)=\sum_{i=1}^n w_i\sqrt{(x_i-x)^2+(y_i-y)^2}$（上面的柿子）。先画个图看一下每一项。

![](https://cdn.luogu.com.cn/upload/image_hosting/ist41opr.png)

它是一个倒立的圆锥，是单谷函数。因此整个目标函数也是单谷函数，梯度下降保证收敛到全局最小值。注意到，该函数在极小值处不可导，因此应该忽略这样的不可导项。

求出偏导数：
$$
\frac{\partial J(x,y)}{\partial x}=\sum_{i=1}^n w_i \cdot\frac{x-x_i}{\sqrt{(x-x_i)^2+(y-y_i)^2}} \\
\frac{\partial J(x,y)}{\partial y}=\sum_{i=1}^n w_i \cdot\frac{y-y_i}{\sqrt{(x-x_i)^2+(y-y_i)^2}}
$$

最后，我们需要在算法执行过程中动态调整学习率来达到较好的效果，这被称为**学习率调度**。这里采用如下方式进行学习率调度：设 $\eta_t$ 为第 $t$ 次迭代后的学习率，则 $\eta_{t+1}=r\cdot\eta_t$，其中 $0<r<1$，为学习率衰减因子，而初始学习率 $\eta_0$ 为定值。不断迭代直到 $\eta<eps$ 或 $|\nabla_\theta J(\theta)|<eps$（即梯度向量的长度小于 $eps$）。这样一开始利用了较大学习率收敛快的优点，执行到后面学习率逐渐减小，有助与提高精度，收敛到极小值。这样很好地平衡了不同学习率的优缺点。
### Code
这里取 $\eta_0=100,r=0.99,eps=10^{-6}$。
```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;
constexpr int N=1005;
constexpr double LR=100.0,DECAY=0.99,EPS=1e-6;  // 梯度下降超参数：初始学习率、衰减因子、精度
double x[N],y[N],w[N];
int n;
pair<double,double> gradient(double curX,double curY){  // 计算梯度
    pair<double,double> grad={0.0,0.0};
    for(int i=0;i<n;++i){
        double dx=curX-x[i];
        double dy=curY-y[i];
        double dist=sqrt(dx*dx+dy*dy);
        if(dist<EPS) continue;  // 避免除零错误
        grad.first+=w[i]*dx/dist;
        grad.second+=w[i]*dy/dist;
    }
    return grad;
}
int main(){
    cin.tie(0)->sync_with_stdio(0);
    double curX=0.0,curY=0.0,sumW=0.0,lr=LR;
    cin>>n;
    for(int i=0;i<n;++i){
        cin>>x[i]>>y[i]>>w[i];
        curX+=x[i],curY+=y[i],sumW+=w[i];
    }
    curX/=sumW,curY/=sumW;  // 初始化为所有点加权平均位置（玄学优化）
    while(lr>EPS){
        pair<double,double> grad=gradient(curX,curY);  // 计算梯度向量
        double gradLen=sqrt(grad.first*grad.first+grad.second*grad.second);  // 梯度向量的长度
        if(gradLen<EPS) break;  // 梯度足够小，已收敛
        curX-=lr*grad.first;
        curY-=lr*grad.second;
        lr*=DECAY;  // 学习率调度
    }
    cout<<fixed<<setprecision(3)<<curX<<' '<<curY;
    return 0;
}
```
Update 2025.6.16：修改一处公式错误。

---

## 作者：Indigo_Boy (赞：4)

前几天心血来潮，就~~趁语文课~~搞了一张任务清单（淦！还不是因为我找不到$lin $ _ $toto$的“洛咕超级任务清单” $ js $ 脚本了）然后脑子一抽，就把**模拟退火**工工整整的写上去了，学了好久看了好多外国的视频才懂，我太南了。
# 一道小题目
如图：有$n$个重物，每个重物系在一条足够长的绳子上。每条绳子自上而下穿过桌面上的洞，然后系在一起。图中$X$处就是公共的绳结。假设绳子是完全弹性的（不会造成能量损失），桌子足够高（因而重物不会垂到地上），且忽略所有的摩擦。

问绳结X最终平衡于何处。

注意：桌面上的洞都比绳结$X$小得多，所以即使某个重物特别重，绳结$X$也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。

![](https://cdn.luogu.com.cn/upload/pic/148.png)

### 输入格式
文件的第一行为一个正整数$n$$（1≤n≤1000）$，表示重物和洞的数目。接下来的$n$行，每行是3个整数：$Xi.Yi.Wi$，分别表示第i个洞的坐标以及第 $i$个重物的重量。$(-10000≤x,y≤10000, 0<w≤1000 ) $

### 输出格式
你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结X的横坐标和纵坐标。两个数以一个空格隔开。

# 什么 事 模拟退火啊
事实证明看百度百科是会看傻的，$OI$的退火和分子热运动没多大关系。  

### 小思考问题
我们知道了全国某几个城市的坐标，求一条路线使得从北京出发经过所有城市的路径最短且每条路只走一次  

这道题要是直接暴搜的话……  
如果有25座城市，而且你的$PC$强大到一秒1e8次运算，宁得日夜不停的算大概**四十九亿年**，可怕吗  
但是用模拟退火，可以飞快地算出答案。

模拟退火是用来求**多峰函数**的**极值**的 （尽管通常并不会将多峰函数体现出来，需要宁自己想），设置合适的参数可以在很快的速度里求得**近似**的最优解，所以说这个算法不一定得满分，但是可以很容易的得一个高分。

在此以做上边题的亲身经历说明一下  
![](https://cdn.luogu.com.cn/upload/image_hosting/qp09a63g.png)
(![](https://cdn.luogu.com.cn/upload/image_hosting/6lxg6xu3.png)

### 先说几个概念
$T$ : 初始温度，是一个自己看心情和题目设定的量，这个数越大，正解概率越高，但是耗时越长。  

$down$ : 降温系数，设置这个系数的目的是让$T$能以一个合适的速度减小，使得当$T$在到达边界时我们已经尝试了足够多组解来使最终解接近最优解。指数函数的增长速度是极其迅速的，所以我们可以给$down$附一个很小的值，通常在$0.98 - 0.995$
之间酌情瞎搞，越大约不准确，但越快。

$exp( n )$ ：c++一个函数，计算$e ^ n$,其中$e$为自然对数。  

$de$ : 这次得到的解和之前求到的最优解的差值，有点类似于化学里的**熵变**，用来评价这次的解是否更优。  

$RAND$_ $MAX$ ~~（这个为什么这么大）~~:c++能生成的最大的随机数，即32767。  

$rand()$ ：c++函数，生成随机数。

### 怎么退火呢？  
举个烂大街的栗子：

贪心算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是贪心，它不能保证局部最优值就是全局最优值。   

模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。

一张图骗：
![](https://images2018.cnblogs.com/blog/1200714/201803/1200714-20180331070457230-679205132.gif)
可以看到它是逐渐趋近于最优解的

本题为例的伪代码:
```cpp
int T = 233;
int tempx, tempy, tempans, de;
//下面的x, y, ans为临时最优解
while( T > 1e-15 ){  //T十分接近零
	tempx = x + (rand() * 2 - RAND_MAX) * T;
	tempy = y + (rand() * 2 - RAND_MAX) * T;
	//以本题为例，rand() * 2 - RAND_MAX是一个小套路，这样可以生成从 -32767 到 32767 的随机数，以让坐标点转移到一个随机位置，随着不断降温，T会越来越小，所以坐标点转移的范围也会越来越小，逐渐逼近最优点
	tempans = solve( tempx, tempy )
	//solve是你用来求距离的函数
	de = tempans - ans;
	if( de < 0 ){//是大于还是小于具体问题判断   
		x = tempx;
		y = tempy;
		w = tempw;
	} else if( exp( -de / T ) * RAND_MAX > rand() ){//以一个概率选择是否接受，但是就算是接受，我们也不会用它来更新最优解，因为我们当前的最优解比它优秀。de的正负性具体题目具体分析，也可以两个都试一下，看哪个输出正确样例	
		x = tempx;
		y = tempy;	
	}
	T *= down;//降温
}
```



# 题目分析
我最开始想的是受力分析然后搞个合力，最后物体在合力方向上移动，但是一想，合力方向似乎会变，然后就没想法了（俺太弱了$QWQ$  
看讨论区有人说用质心公式搞？？？我不太懂，没搞。  
最后用模拟退火瞎搞出来的，看题解还有大佬用凸包什么的搞出来了，反正我不会。

然后就模拟退火搞呗，考虑到重力势能是趋近于系统重力势能最小的，所以当绳子的结点静止时，重力势能之和最小，那么我们可以求出在每个点时的重力势能大小，以此来比较当前解和最优解。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define down //请自己尝试

int de;
int n;
double ansx, ansy, answ;
struct node{
	int x, y, w;
}a[1050];

inline int read( void ){
	int re = 0, f = 1;
	char ch = getchar();
	while( ch > '9' || ch < '0' ){
		if( ch == '-' ) f = -1;
		ch = getchar();
	}
	while( ch >= '0' && ch <= '9' ){
		re = re * 10 + ch - '0';
		ch = getchar();
	}
	return re * f;
}
inline double init( double x, double y ){
	double re = 0.0, d1, d2;
	for( rint i = 1; i <= n; i++ ){
		d1 = x - a[i].x, d2 = y - a[i].y;
		re += sqrt( d1 * d1 + d2 * d2 ) * a[i].w;
	}
	return re;
}
inline void SA(){
	double T = //请自己尝试
	double de, tw, tx, ty;
	while( T > 1e-15 ){
		//cout << T << endl;
		tx = ansx + ( rand() * 2 - RAND_MAX ) * T;
		ty = ansy + ( rand() * 2 - RAND_MAX ) * T;
		tw = init( tx, ty );
		de = tw - answ;
		if( de < 0 ){
			ansx = tx;
			ansy = ty;
			answ = tw;
		} else if( exp( -de / T ) * RAND_MAX > rand() ){	
			ansx = tx;
			ansy = ty;	
		}
		T *= down;
	}
}
int main( void ){
	n = read();
	for( rint i = 1; i <= n; i++ ){
		a[i].x = read(); a[i].y = read(); a[i].w = read();
		ansx += a[i].x, ansy += a[i].y;
	}
	ansx /= n, ansy /= n;
	answ = init( ansx, ansy );
	//cout << ansx << ' ' << ansy;
	SA();
	SA();
	SA();
	SA();
	SA();
	printf( "%.3lf %.3lf", ansx, ansy );
	return 0;
}
```

---

## 作者：三水 (赞：4)

/\*膜...膜拟退火\*/

关键是esp往小里设

ans初值往大里设

其他的差不多就行










```cpp
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int MAXN=10005;
const int MAXM=8;
struct node{int x,y,w;}gty[MAXN];
int n;
double get_ans(double x_x,double x_y)
{
    double sum=0;
    for(int i=1;i<=n;i++)
    {
        double dxx=x_x-gty[i].x;
        double dyy=x_y-gty[i].y;
        sum+=(sqrt(dxx*dxx+dyy*dyy))*gty[i].w;
    }
    return sum;
}
double xans=gty[1].x;
double yans=gty[1].y;
double ans=1e18+7;
double t;
const double delta=0.993;
const double esp=1e-15;
bool accept(double del)
{
    if(del<0)return 1;
    double rate=exp(-del/t)*RAND_MAX;
    if(rate>rand())return 1;
    return 0;
}
void search()
{
    double xx = xans;
    double yy = yans;
    t=100;
    while(t>esp)
    {
        double xtemp=xx+(rand()*2-RAND_MAX)*t;
        double ytemp=yy+(rand()*2-RAND_MAX)*t;
        double temp=get_ans(xtemp,ytemp);
        if(accept(temp-ans))
        {
            xx=xtemp;
            yy=ytemp;
            if(ans>temp)
            {
                xans=xx;
                yans=yy;
                ans=temp;
//                    printf("%.3lf %.3lf %lf\n",xans,yans,t);
            } 
        }
        t*=delta;
    }
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        gty[i].x=read();
        gty[i].y=read();
        gty[i].w=read();
    }
    for(int i=1;i<=MAXM;i++)search();
    printf("%.3lf %.3lf",xans,yans);
    return 0;
}

```

---

## 作者：Starlight237 (赞：4)

这道题作为模拟退火的板子，缘于评价函数是一个单峰函数，故模拟退火AC率较高。而在相同时间内，粒子群算法的正确率是高于模拟退火的。

但是粒子群算法有一个缺点，在后期如果陷入了局部最优，就不容易调整。

所以我们可以将粒子群算法和模拟退火结合！这样粒子有一定概率跳出当前解，从而获得更优秀的全局搜索性。

注：因为这个算法跑得还是比较快的，可以多跑几遍pso增加正确率。

update 2019/7/23 20:51：**粒子初始位置随机分布确实会增加AC率**，更新了代码。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define PSO_NUM 20
static int n,xx[1001],yy[1001],W[1001];
double T,w,bstans,gbx,gby,X1,Y1,r1,r2,f1,f2,dc;
struct obj{
    double x,y,vx,vy,pbx,pby,bstans;
}obs[PSO_NUM|1];
inline double F(double x,double y){
    double ans=0,dx,dy;
    for(reg int i=1;i<=n;++i)
        dx=x-xx[i],dy=y-yy[i],ans+=W[i]*sqrt(dx*dx+dy*dy);
    return ans;
}
inline void pso(){
    obs[1].x=gbx,obs[1].y=gby,obs[1].bstans=bstans;
    for(reg int i=2;i<=PSO_NUM;++i)
        obs[i].x=gbx+double((rand()<<1)-RAND_MAX)/RAND_MAX*10000,
        obs[i].y=gby+double((rand()<<1)-RAND_MAX)/RAND_MAX*10000,
        obs[i].bstans=F(obs[i].x,obs[i].y);
    for(T=1000,w=0.7;T>1e-6;T*=0.92,w=max(0.0,w-0.005))
        for(reg obj *i=obs+1,*j=obs+PSO_NUM+1;i!=j;++i)
            r1=(double)rand()/RAND_MAX,r2=(double)rand()/RAND_MAX,
            i->vx=w*i->vx+2*r1*(i->pbx-i->x)+2*r2*(gbx-i->x),
            r1=(double)rand()/RAND_MAX,r2=(double)rand()/RAND_MAX,
            i->vy=w*i->vy+2*r1*(i->pby-i->y)+2*r2*(gby-i->y),
            i->x+=i->vx,i->y+=i->vy,
            f1=F(i->x,i->y),
            f1<i->bstans&&(i->bstans=f1,i->pbx=i->x,i->pby=i->y),
            f1<bstans&&(bstans=f1,gbx=i->x,gby=i->y),
            X1=i->x+double((rand()<<1)-RAND_MAX)/RAND_MAX*T,
            Y1=i->y+double((rand()<<1)-RAND_MAX)/RAND_MAX*T,
            f2=F(X1,Y1),
            dc=f2-f1,
            dc<0?i->x=X1,i->y=Y1:(
            r1=(double)rand()/RAND_MAX,
            r1<min(1.0,exp(-dc/T))&&(i->x=X1,i->y=Y1)
            ),
            f2<i->bstans&&(i->bstans=f2,i->pbx=X1,i->pby=Y1),
            f2<bstans&&(bstans=f2,gbx=X1,gby=Y1)
            ;
}
int main(){
    srand(time(0));
    srand(rand()^rand());
    scanf("%d",&n);
    for(reg int i=1;i<=n;++i)
        scanf("%d%d%d",xx+i,yy+i,W+i),gbx+=xx[i],gby+=yy[i];
    gbx/=n,gby/=n;
    bstans=F(gbx,gby);
    pso(),pso(),pso();
    printf("%.3lf %.3lf",gbx,gby);
    return 0;
}
```

---

## 作者：plane (赞：3)

大体思想是这样的：假设一个平衡点，将力正交分解，计算出在此点时的合力。这时将这个合力与一个已经设定好的“尺度”进行比较。如果这时的合力大于这个尺度，我们就对这个已经设定好的平衡点进行调整，让它更加接近真实的平衡点。当合力在尺度以内或者调整一定次数以后，我们减小尺度，再次进行调整。通过不断缩小尺度，将得到的平衡点的精度范围缩小到一定的区域。当精度到达要求值的时候我们就可以输出解了。

 
在我的程序里，我用xa,ya表示当前的平衡点位置，fx,fy表示力分解到x轴和y轴的分力，fn是合力的大小，k表示当前的尺度。

 
其他的说明在代码里已经体现。而对于q循环和i循环的次数，理论上次数越多精度越高。所以在时间允许的情况下应该尽量增加q和i的循环次数。


```delphi


var x,y,v:array[0..1001]of longint;
    xa,ya,xx,yy,k,fx,fy,fn,dx,dy,ft:double;
    i,j,q:longint;
    n:longint;
begin
  readln(n);
  for i:=1 to n do readln(x[i],y[i],v[i]);
  k:=100;
  xa:=0;
  ya:=0;
  for i:=1 to 100 do
    begin
      xx:=xa;
      yy:=ya;
      for q:=1 to 200 do
        begin
          fx:=0;
          fy:=0;
          for j:=1 to n do
            begin
              dx:=x[j]-xx;  //分到x轴的比例
              dy:=y[j]-yy;  //分到y轴的比例
              ft:=sqrt(dx*dx+dy*dy);
              if ft>0
              then  //作用点与平衡位置重合时不能够分解
                begin
                  fx:=fx+dx/ft*v[j];
                  fy:=fy+dy/ft*v[j];
                end;
            end;
          fn:=sqrt(fx*fx+fy*fy);
          if fn<=k then break;  //小于尺度就跳出
          xx:=xx+fx/fn*k;  //调整平衡点的位置
          yy:=yy+fy/fn*k;
        end;
      xa:=xx;
      ya:=yy;
      k:=k*0.4;  //减小尺度
    end;
  writeln(xa:0:3,' ',ya:0:3);
end.


```

---

## 作者：金银岛 (赞：3)

# 几何二分解法
看题解区基本全是写模拟退火的大佬

仍是绿名的我表示完全不懂

于是我就尝试写了下几何二分

### 具体思想

首先定义一个矩形，表示结点平衡位置所处的范围

每次都假设该矩形中心点为绳结

通过正交分解（如果不知道的话可以百度一下，这里不过多赘述）求出此时合力的方向

我~~由于不会传送图片冒着被骂的风险选择了~~用如下方式表达一下接下来如何二分

| \ |  |  |  | 1 |  |  |  | / |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|  | \ |  |  |  |  |  | / |  |
|  |  | \ |  |  |  | / |  |  |
|  |  |  | \ |  | / |  |  |  |
| 4 |  |  |  | 结点 |  |  |  | 2 |
|  |  |  | / |  | \ |  |  |  |
|  |  | / |  |  |  | \ |  |  |
|  | / |  |  |  |  |  | \ |  |
| / |  |  |  | 3 |  |  |  | \ |

（所有斜线均为45°）

如果合力方向在1号区域，则将范围缩小到上半个矩形

同理在2号区域则缩小到右半个矩形

3号->下半个矩形

4号->左半个矩形
      
重复上述过程

最后输出最后一个矩形的中心点（至于为什么不随便选一个顶点……你可以想象一下最后剩一个~~线段~~宽度几乎为0的矩形的情况）

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[1010],y[1010],w[1010];
double zx[2]={-10000,-10000},         ys[2]={10000,10000};
// 矩形左下点坐标([0]为 x,[1]为 y)     右上点 
int judge(double midx,double midy)
{
	double shuiping=0,shuzhi=0;
	for(int i=1;i<=n;i++)
	{
		double xiebian=sqrt((midx-x[i])*(midx-x[i])+(midy-y[i])*(midy-y[i])),
			shuipingbian=x[i]-midx,shuzhibian=y[i]-midy;
		if(xiebian!=0)//斜边为零说明这个点和这个洞口位置相同，该力可以跳过 ， 
		{
			shuiping+=w[i]/xiebian*shuipingbian;
			shuzhi+=w[i]/xiebian*shuzhibian;	
		}
	}//对所有力正交分解 
	if(shuzhi>0&&shuzhi>abs(shuiping))//合力方向偏上 
		return 1;
	if(abs(shuzhi)<=shuiping&&shuiping>0)//偏右 
		return 2;
	if(shuzhi<=0&&-shuzhi>abs(shuiping))//偏下 
		return 3;
	if(abs(shuzhi)<=-shuiping&&shuiping<=0)//偏左
		return 4;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>x[i]>>y[i]>>w[i];
	for(int i=1;i<=200;i++)//  20000/2^200我就不信了精度不够
	{
		double mid[2]={(zx[0]+ys[0])/2,(zx[1]+ys[1])/2};//矩形中心坐标 
		switch(judge(mid[0],mid[1]))//若绳结在该点上，判断合力方向 
		{				//					   ___
			case 1:zx[1]=(zx[1]+ys[1])/2;//   |_|_|
				   break;	      		 //   |___|
				   	         			//	   ___
			case 2:zx[0]=(zx[0]+ys[0])/2;//   | |_|		两个小正方形为缩小后的区域(其实是长方形，近似理解下) 
				   break;	 			//	  |_|_|
						     			 //    ___
			case 3:ys[1]=(zx[1]+ys[1])/2;//	  |___|
				   break;	             //   |_|_|
				   		     			 //    ___
			case 4:ys[0]=(zx[0]+ys[0])/2;//   |_| |
				   break;	             //   |_|_| 分别向对应方向二分缩小矩形边长
		}
	}
	printf("%.3f %.3f",(zx[0]+ys[0])/2,(zx[1]+ys[1])/2);//输出最后矩形的中心点 
	return 0;
}
```


---

## 作者：Aurie (赞：2)

提供一种梯度下降的做法！

# 梯度下降算法

梯度下降算法可以用来求函数的极值（函数谷的位置或函数峰）的位置。

若要求 $G(x)$ 的最小值对应的横坐标，可以对 $G(x)$ 求导得到 $G'(x)$，然后解方程 $G'(x)=0$。若该方程不能被轻易的解出来怎么办？此时就要用到梯度下降算法。

先估计 $G(x) $ 最小值的位置为 $x'$ 尝试通过某种方式去更新迭代 $x'$ 使得其靠近正确答案。

若 $G(x)$ 是一个较为理想的函数：

![](https://cdn.luogu.com.cn/upload/image_hosting/nc55bz46.png)

可以发现：
* 若将 $x'$ 估计在最小值右侧，则 $G'(x_0),G'(x_1) > 0$。此时应将 $x'$ 向左移。

* 若将 $x'$ 估计在最小值左侧，则 $G'(x_2) < 0$。此时应将 $x'$ 向右移。

现在已经可以确定 $x'$ 需要移动的方向了，那么移动多远呢？通过考虑这个问题又可以发现：

* 若 $x'$ 离最小值越远那么其导数的绝对值越大，其需要移动的距离也就越远。如图所示 $|G'(x_0)| < |G'(x_1)|$。

综上所示，可以令迭代后的 $x'$ 也就是 $x''=x'-G'(x')$。这不仅保证了 $x'$ 移动方向的正确性，也保证了移动距离的正确性。

在实际应用该算法的过程中，为了防止 $x'$ 移的太远太快，通常会让 $x'' = x' - learingRate \times G'(x')$。$learingRate$ 通常是个大于 $0$ 小于 $1$ 的实数，需人为设定，并根据实际情况动态调整。

# 问题转化

需将本题转化为一个求函数最小值的问题。

首先要估计该问题的答案，估计绳结的位置为 $(x',y')$。

求此时绳结的受力 $F$。直接求并不好求，考虑到题目给出的信息是各个洞的坐标，那么就把力水平、竖直分解，分开求：

（这部分属于物理知识。）

记 $d_i = \sqrt{(x_i-x')^2+(y_i-y')^2}$。

$F_x=\sum\limits_{i=1}^{n}(\frac{x_i - x}{d_i}\times w_i \times g)$

$F_y=\sum\limits_{i=1}^{n}(\frac{y_i - y}{d_i}\times w_i \times g)$

$g$ 是一个常量，对该问题答案没有影响，为了简化问题将 $g$ 去掉。式子中应写 $x_i-x$ 还是 $x - x_i$ 也不重要，对后期梯度下降算法没有影响，只要保证形式统一即可。

$F_x=\sum\limits_{i=1}^{n}(\frac{x_i - x}
{d_i}\times w_i)$

$F_y=\sum\limits_{i=1}^{n}(\frac{y_i - y}{d_i}\times w_i)$

这时问题就被转化为了调整 $x',y'$ 的值使 $F_x,F_y$ 均为 $0$。

那么可以构造函数 $f(x,y)=F_x^2 + F_y^2$。

对于该函数，当且仅当 $F_x,F_y$ 均为 $0$ 时，该函数取到最小值 $0$。此时将问题转化为了求函数最小值的问题。但与上文梯度下降算法示例函数不同的是，这个函数有两个变量。因此不能通过简单的求导来解决这个问题，而是要通过求偏导解决。通俗来讲，就是分别求 $f(x,y)$ 关于 $x$ 的导数，记为 $\frac{\partial f}{\partial x}$，和关于 $y$ 的导数，记为 $\frac{\partial f}{\partial y}$。在求 $f(x,y)$ 关于 $x$ 的导数  时，将 $y$ 视为常量即可，$y$ 同理。

整理出该函数：

$f(x,y)=(\sum\limits_{i=1}^n(\frac{x_i-x}{\sqrt{(x_i-x)^2+(y_i-y)^2}}\times w_i))^2+(\sum\limits_{i=1}^n(\frac{y_i-y}{\sqrt{(x_i-x)^2+(y_i-y)^2}}\times w_i))^2$

然后利用导数的和、积、比，以及复合函数求导相关性质求偏导：

（这部分属于数学知识。）

$
\frac{\partial f}{\partial x} = 2 \left( \sum_{i=1}^n \frac{x_i - x}{d_i} w_i \right) \times \left( \sum_{i=1}^n \frac{ - (y_i - y)^2 - 2(x_i - x)^2 }{d_i^3} w_i \right) + 2 \left( \sum_{i=1}^n \frac{y_i - y}{d_i} w_i \right) \times \left( \sum_{i=1}^n \frac{ (x_i - x)(y_i - y) }{d_i^3} w_i \right)
$

$
\frac{\partial f}{\partial y} = 2 \left( \sum_{i=1}^n \frac{x_i - x}{d_i} w_i \right) \times \left( \sum_{i=1}^n \frac{ (x_i - x)(y_i - y) }{d_i^3} w_i \right) + 2 \left( \sum_{i=1}^n \frac{y_i - y}{d_i} w_i \right) \times \left( \sum_{i=1}^n \frac{ - (x_i - x)^2 - 2(y_i - y)^2 }{d_i^3} w_i \right)
$

最终附上代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long double db;
const int N = 1e3 + 10;

int n;

db x[N], y[N], w[N], xx , yy, d[N], wdd3[N];

void calc(register int t, const db& Rate) {
	while (t--) {
        // 求偏导。
        for (register int i = 1; i <= n; i++) {
            d[i] = sqrtl((x[i] - xx) * (x[i] - xx) + (y[i] - yy) * (y[i] - yy));
            wdd3[i] = w[i] / (d[i] * d[i] * d[i]);
        }
        register db ax = 0, bx = 0, ay = 0, by = 0, c = 0;
        for (register int i = 1; i <= n; i++) {
            ax += (x[i] - xx) / d[i] * w[i];
            bx += (
                (yy - y[i]) * (y[i] - yy) + 2 * (xx - x[i]) * (x[i] - xx)
                ) * wdd3[i];
            ay += (y[i] - yy) / d[i] * w[i];
            by += (
                (xx - x[i]) * (x[i] - xx) + 2 * (yy - y[i]) * (y[i] - yy)
                ) * wdd3[i];
            c += (x[i] - xx) * (y[i] - yy) * wdd3[i];
        }
        // 迭代答案。
        xx -= (ax * bx + c * ay) * Rate;
        yy -= (ay * by + c * ax) * Rate;
    }
}
template<typename T>
void read(T &x) {
    x = 0;
    char ch = getchar();
    int f = 1;
    while (!isdigit(ch)) {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 0x30);
        ch = getchar();
    }
    x *= f;
}
int main() {
	srand(time(0));
    int in;
    read(n);
    for (int i = 1; i <= n; i++) {
        read(in); x[i] = in;
        read(in); y[i] = in;
        read(in); w[i] = in;
        // 将初始值设为所有点坐标的平均数。
        xx += x[i] / n;
		yy += y[i] / n;
    }
    // 微调初始值，不建议将初始值直接设为 0。
    xx += (db)(rand() - RAND_MAX / 2) / (RAND_MAX / 5);
    yy += (db)(rand() - RAND_MAX / 2) / (RAND_MAX / 5);
    if (n == 1) { // 特殊情况特判。
        xx = x[1];
        yy = y[1];
    } else {
        calc(1e3, 0.1);
    	calc(5e3, 0.01);
    	calc(5e4, 0.0001); // 不 TLE 的前提下保证精度。
    }
    printf("%.3lf %.3lf", (double)xx, (double)yy);
    return 0;
}
```

---

## 作者：Little_Ming (赞：2)

看各位大佬在力变向或力大小过小时减小步伐，有点麻烦，本蒟蒻来一个**步伐固定减小**的方法：

对力进行正交分解，如果力不为**0**，直接把位移长度设为`0`~`步伐`间的**随机数**，无需考虑原本力的大小。

当然，这个方法的调参有点玄学……



再注意一下常数与浮点精度，就[AC](https://www.luogu.org/record/show?rid=10414990)啦！(最慢点328ms)

**以下是代码**(写得~~很~~有点奇怪)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define F(i) for(int i=0;i<n;i++)
const double eps=1e-10;
inline int cmp(double x,double y=0){
	if(fabs(x-y)<eps)return 0;
	return x>y?1:-1;
}
inline double sqr(double x){
	return x*x;
}
inline double dis(double x,double y){
	return sqrt(sqr(x)+sqr(y));
}
double x[1010],y[1010],w[1010];
int main(){
	int n;
	cin>>n;
	F(i)cin>>x[i]>>y[i]>>w[i];
	double sum=0.0;
	double sx=0,sy=0;
	F(i)sum+=w[i];
	F(i)sx+=x[i]*w[i];
	double avgx=sx/sum;//平均X坐标
	F(i)sy+=y[i]*w[i];
	double avgy=sy/sum;//平均Y坐标
	F(i)w[i]/=sum;//质量归一化
	double nx=avgx,ny=avgy;//坐标
	double t=20.0;//步伐大小
	//int dog=0;(循环计数器，控制常数)
	while(t>1e-8){
		//dog++;
		double fx=0,fy=0;//普通的力
		double mf=0;//往洞里拉的力
		F(i){
			double dx=x[i]-nx,dy=y[i]-ny;
			if(cmp(dis(dx,dy))==0)
				mf+=w[i];//往洞里拉
			else{
				double d1=1.0/dis(dx,dy)*w[i];//减少计算量
				fx+=dx*d1;
				fy+=dy*d1;
			}
		}
		double sf=dis(fx,fy);
		//printf("mf=%.3lf fx=%.3lf fy=%.3lf\n",mf,fx,fy);
		if(cmp(mf,sf)>=0){
        	//   洞里的力大于等于向外拉的力:卡洞里
            //or 此刻受力为0:就是这里
			t=0;
			break;
		}
		double b=t*t*((double)rand()/RAND_MAX)/sf;
		fx*=b;
		fy*=b;
		nx+=fx;
		ny+=fy;
		t*=0.9995;//每次步伐都乘0.9995
	}        
	//cout<<dog<<endl;
	printf("%.3lf %.3lf",nx,ny);
}
```

---

## 作者：Luan_233 (赞：2)

打一个将就可以出样例的程序就交一下试一试吧。结果过了。

## Solution

+ ~~身为竞赛班蒟蒻，旁边有那么多物竞巨佬，随时随地都受着熏陶~~

+ 回归正题，此题无论怎样都有一些模拟退火的成分在里面，但是我的方法类似却不一样。

+ 首先确定一个点，在这个点上进行正交分解，找出合力的方向，将一个数值带入这个方向进行位移，若移动完以后合力方向改变则“降温”，给这个步伐大小值乘上一个小于一的系数，因为下一步要移动的步伐就一定要比当前小。否则就继续在这个方向上移动，直到合力方向改变，进行“降温”，直到步伐小于精度为止。

## Code

```
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 1005
using namespace std;
const double eps=1e-6;
int n;
double x[maxn],y[maxn],wi[maxn],ppap=1005,k=0.9;
double ansx,ansy,dx,dy,prex,prey;
inline bool equal(double a,double b){
    return fabs(a-b)<eps;
}
inline double pow(double val){ return val*val; }
inline void divide(){//正交分解
    dx=dy=0;
    double dis,mx,my;
    for(int i=1;i<=n;i++){
        dis=sqrt(pow(ansx-x[i])+pow(ansy-y[i]));
        if(fabs(dis)<eps) continue ;
        dx+=(x[i]-ansx)/dis*wi[i];
        dy+=(y[i]-ansy)/dis*wi[i];
    }
}
inline void move(double step){//在这个方向上进行移动
    double dis=sqrt(pow(dx)+pow(dy));
    if(fabs(dis)<eps) return ;
    ansx+=dx/dis*step;
    ansy+=dy/dis*step;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x[i]>>y[i]>>wi[i];
    }
    while(ppap>0.0001){
        divide();
        move(ppap);
        if((!equal(prex,dx))||(!equal(prey,dy))){
            ppap*=k;
        }//步伐不一样，进行“降温”
        prex=dx,prey=dy;
        /*cout<<dx<<" "<<dy<<endl;
        cout<<ansx<<" "<<ansy<<endl;
        system("pause");*/
    }
    printf("%.3f %.3f",ansx,ansy);
    return 0;
}
```

---

## 作者：牧牧大魔王 (赞：2)

模拟退火最重要的就是判断那种情况是最优的，所以我们需要找到一个标准来判断当前情况的最优率为多少。

此题的最优情况是，\sum所选点到重物点的距离*重物的重量，最小即最优。就是代码中的energy函数。

```
#include <bits/stdc++.h>
#define down 0.996 // 徐徐降温
 
using namespace std;
 
struct node {
    int x,y,w;
}object[2005];// 存物体的坐标和重量
int n;
double ansx,ansy,answ; // 最终答案
 
double energy( double x, double y )//根据题意变化, 能量总和越小越稳定( 即越接近正确答案 )
{
    double r=0,dx,dy;
    for ( int i=1; i<=n; i++ ) {
        dx = x-object[i].x;
        dy = y-object[i].y;
        r += sqrt(dx*dx+dy*dy)*object[i].w;
    }
    return r;
}
 
void sa()
{
    double t = 3000; // 温度足够高
    while ( t>1e-15 ) {
        double ex = ansx + (rand()*2-RAND_MAX)*t; // 随机产生新答案.
        double ey = ansy + (rand()*2-RAND_MAX)*t;
        double ew = energy(ex,ey);
        double de = ew - answ;
        if ( de<0 ) { // 新答案能量低，更稳定
            ansx = ex;
            ansy = ey;
            answ = ew;
        }
        else if ( exp(-de/t)*RAND_MAX>rand() ) { // 否则根据多项式概率接受
            ansx = ex;
            ansy = ey;
        }
        t *= down;
    }
}
 
void solve() // 多跑几遍退火，增加得到最优解的概率
{
    sa();sa();sa();sa();
}
 
int main()
{
    cin >> n;
    for ( int i=1; i<=n; i++ ) {
        scanf("%d %d %d",&object[i].x,&object[i].y,&object[i].w);
        ansx += object[i].x;
        ansy += object[i].y;
    }
    ansx/=n; ansy/=n; // 以平均值作为初始答案
    answ = energy(ansx,ansy);
    solve();
    printf("%.3f %.3f\n",ansx,ansy);
 
    return 0;
}
```





---

## 作者：wanyaxin (赞：2)

- 如果只有两个方向相反，在一条直线上的力，那么平衡点就在支点上。
- 所以，用初中知识理解的话，这道题其实就是一个有很多力臂的“杠杆”，只要找到它的支点就可以了。
- 那么只要*L1F1+L2F2+L3F3+...LNFN=0*即可。
- 所以，可以用模拟退火的方法，不断更新，找到*L1F1+L2F2+L3F3+...LNFN*趋近于0的情况。
```cpp
#include<bits/stdc++.h>
#define maxn 1010
using namespace std;
int x[maxn];
int y[maxn];
int w[maxn];
int n;
double xl=-10000.0,xr=10000.0,yl=-10000.0,yr=10000.0,xans,yans,rst;
double f(double xx,double yy)
{
	int i;
	double sum=0.0;
	for(i=1;i<=n;i++)
	{
		double t=(xx-x[i])*(xx-x[i])+(yy-y[i])*(yy-y[i]);
		t=sqrt(t);
		t*=w[i];
		sum+=t;
	}
	return sum;
}
int sa()
{
	double t=500.0,step=0.98,x1,y1;
	double len=xr-xl;
	while(t>=1e-10)
	{
		double p=len*t*(rand()%100+1)/100/1000;
		x1=xans-p;
		y1=yans-p;
		if(x1>=xl&&y1>=yl)
		{
			double k=f(x1,y1);
			if(k<rst)
			{
				rst=k;
				xans=x1;
				yans=y1;
			}
		}
		x1=xans+p;
		y1=yans+p;
		if(x1<=xr&&y1<=yr)
		{
			double k=f(x1,y1);
			if(k<rst)
			{
				rst=k;
				xans=x1;
				yans=y1;
			}
		}
		
		x1=xans+p;
		y1=yans-p;
		if(x1<=xr&&y1>=yl)
		{
			double k=f(x1,y1);
			if(k<rst)
			{
				rst=k;
				xans=x1;
				yans=y1;
			}
		}
		
		x1=xans-p;
		y1=yans+p;
		if(x1>=xl&&y1<=yr)
		{
			double k=f(x1,y1);
			if(k<rst)
			{
				rst=k;
				xans=x1;
				yans=y1;
			}
		}
		t*=step;
	}
}
int main()
{
	int i;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&w[i]);
	}
	xans=(xl+xr)/2;
	yans=(yl+yr)/2;
	rst=f(xans,yans);
	sa();
	sa();
	sa();
	printf("%.3lf %.3lf",xans,yans);
}
```

---

## 作者：G_A_TS (赞：2)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10360087.html)  

------------
本题的正解是———  
是什么呢？  
~~我也不知道~~  
但这确实是道入手~~mo你~~模拟退火的好题  
原题链接：[here](https://www.luogu.org/problemnew/show/P1337)  
首先澄清一下，模拟退火**不是正解!不是正解!不是正解!**  
ta是用来骗分的~~，而且这道题能骗到满分~~  
![提交记录](https://i.loli.net/2019/02/10/5c5ffe3851789.png)  
辣鸡mo你退火毁我青春↑(前面还有一排89分。。。)  
为什么基本一样的程序会得分不同呢？所以先看mo你退火的概念  
首先了解[金属退火](https://baike.baidu.com/item/%E9%80%80%E7%81%AB/1039313?fr=aladdin)(or you won't understand 'temperature')  
~~说人话~~就是高温向低温冷却，同时~~瞎跳~~，**温度越高跳率越大，跳的越远**，最后停在某高峰如下图所示↓  
![流程](https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif)  
设xs为降温系数('X'i 'S'hu)每次温度乘上xs(xs一般略小于1)  
当温度小于一个常数(大于0)时终止  
中间需要引入[随机数](https://www.cnblogs.com/vectors07/p/8185215.html)  
如果当前跳到的值优于最优解，则正式跳到这来(下一步从这里跳)  
否则以**一定概率**跳到那里(最好结合当前温度)  
因为是随机算法，所以可以肆无忌惮地~~瞎~~搞比如多跑几遍%你退火  
现在知道该算法为什么是rp算法了吧  

------------
然后模拟退火最玄学的地方就浮出水面了  
既然拼rp，总要~~有个下限~~保证正确率吧  
**所以我们调整参数**  
增加正确率的办法  
- 调大降温系数(但还是要小于1)  

- 增高初始温度  

- 减小结束温度(但还是要大于0)  

- 多跑几遍SA(即模拟退火)  

- QwQ  

不过相应时间复杂度会提高，所以  
**道路千万条，防TLE第一条，不想卡时限，TLE两行泪**  
卡时限方法:( _MAXTIME_ 系寄几定义的变量，**一般0.7-0.9**)  

------------
```cpp
while ((double)clock()/CLOCKS_PER_SEC<MAXTIME)
	SA();
```

------------

实在是AC不了也可以更换随机数种子  
甚至直接：  

------------
```cpp
srand(time(NULL));//srand(xxxxx);srand(rand());
```

------------
Q:如果您都试过了，还是AC不了，怎么办？  

A:做题前洗脸洗手，扶老奶奶过马路，~~rp++~~ 

Q:如果您还是AC不了，怎么办？  

A:那您还是打正解吧  

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int x[1010],y[1010],w[1010];
double ansx,ansy,ans=1000000000001,temperature;
double xs=0.995;
int tmpx,tmpy;
double calc(double x0,double y0)//计算器
{
    double res=0,dx,dy;
    for(int i=1;i<=n;++i)
	{
        dx=x[i]-x0;dy=y[i]-y0;
        res+=sqrt(dx*dx+dy*dy)*w[i];
    }
    return res;
}
int SA()//模拟退火
{
	double tx=ansx,ty=ansy;
	temperature=10000;
	while(temperature>0.0000000000001)
	{
		double X=tx+temperature*(rand()*2-RAND_MAX);
		double Y=ty+temperature*(rand()*2-RAND_MAX);//一个可负可正可零的随机数
		double now=calc(X,Y)-ans;
		if(now<0)
		{
			tx=X;
			ty=Y;
			ans=calc(X,Y);
			ansx=X;
			ansy=Y;
		}
		else
		{
			if(exp(-now/temperature)*RAND_MAX>rand())
			{
				tx=X,ty=Y;
			}
		}
		temperature*=xs;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i]>>w[i];
		tmpx+=x[i];
		tmpy+=y[i];
	}
	srand(time(NULL));//玄学种子
	ansx=(double)tmpx/n;
	ansy=(double)tmpy/n;//据说从平均值开始会快一些？
	SA();
	SA();
	SA();//多跑几遍SA提正确率
	printf("%.3lf %.3lf\n",ansx,ansy);
}
```

---

## 作者：凉如水 (赞：2)

题目：[吊打xxx](https://www.luogu.org/problemnew/show/P1337)

**这篇题解宜搭配专业[模退](https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/8664695?fr=aladdin)讲解食用**

![退火大致过程](https://upload-images.jianshu.io/upload_images/4378213-8fa474ef70c91b70.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)

先上代码
```cpp
#include<bits/stdc++.h>
#define re return
#define st static
#define mem(a,b) memset((a),(b),sizeof(a))
#define inc(i,l,r) for(register int i=l;i<=r;++i)
#define dec(i,l,r) for(register int i=l;i>=r;--i)

using namespace std;
int n,x[1005],y[1005],w[1005];
double EPS=10e-15,D=0.975;
	//玄学设参，EPS即T（温度）目标范围
//（越小，运行次数（耗时）越多，精度越高，越接近正确答案）
	//D即温度变化率，徐徐降温过程~（越大，
//温度改变越小（耗时越多），精度越高），一般0.95~0.99

double calc(double x0,double y0)
{
    double res=0;
    inc(i,1,n)res+=sqrt((x[i]-x0)*(x[i]-x0)+(y[i]-y0)*(y[i]-y0))*w[i];
    re res;
}
//重力势能计算，孤de物理?404：(孤表示）先秦之人不需要学物理
//不再赘述

int main()
{
//	freopen("in.txt","r",stdin);
    double x1=0,y1=0,x0,y0,bx,by,res,ans,best,time=2;
    //time 一般来说模退跑一遍就可以了
    //如果实在不放心，像孤一样跑两遍也未尝不可
    scanf("%d",&n);
    inc(i,1,n){
        scanf("%d%d%d",&x[i],&y[i],&w[i]);
        bx+=x[i];by+=y[i];
    }
    
    best=calc(bx/=n,by/=n);
    //求取坐标平均值：bx,by;想来与结果应是相差不大
    
    srand(20130618);
    //随机种子（随机范围），玄学（个人幸运数字不方为一极好选择）
    //或者古老东方某神秘八位质数19260817
    
    while(time--)
    {
        x1=bx,y1=by,ans=best;
        for(double T=100000;T>EPS;T*=D)
        {
            x0=x1+T*(2*rand()-RAND_MAX);y0=y1+T*(2*rand()-RAND_MAX);
            //rand（）一个随机数，RAND_MAX随机范围内最大值
            //(2*rand()-RAND_MAX)范围[-RAND_MAX,RANDMAX]
            
            res=calc(x0,y0);
            if(res<best){best=res;bx=x0;by=y0;}
            //保留最优值，一般来说不用
            //万一就错过了呢？小生恰是一个胆子极小de人
            if(res<ans||exp((ans-res)/T)>(double)(rand())/RAND_MAX)
            //exp指数函数，ans-res<0,<0rand()/RAND_MAX<=1
            //随着T逐渐减小，exp((ans-res)/T)>(double)(rand())/RAND_MAX)机率越来越小
            {ans=res;x1=x0;y1=y0;}
        }
    }
    printf("%.3lf %.3lf",bx,by);
    re 0;
}

```

---

## 作者：Seanq (赞：2)

**P1337 [JSOI2004]平衡点 / 吊打XXX**  
P1337 [JSOI2004]平衡点 / 吊打XXX题解  
**！模拟退火！**  
讲讲模拟退火是个啥  
模拟退火：  
用了模拟退火过程的思想  
所以······  
TA是模拟  
所以······  
普及组可以考  
所以······  
大家快学呀！   


------------

模拟退火  
3 2 1 START！
--

其实就是类似二分查找。  
不同的是：  
没有单调性Ta也可以工作！  
具体流程（伪代码）：  
```cpp

while(没到边界){
	//搞个随机数
   cal();//计算新的答案
   change();//更新
   T*=0.999;//退火
}

```

大家自己看博客吧  
我太蒟蒻了  
上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
#define cdb const double
const int N=3005;
struct node{
    db x;
    db y;
    db w;
}s[N];
int n;
db ansx,ansy;
cdb cnt=1e-15;//超级小的常数 
inline void OJ(){
    freopen("DDXXX.in","r",stdin);
    freopen("DDXXX.out","w",stdout); 
}
db F(db x,db y){//计算力的大小 
    db tot=0;
    for(int i=1;i<=n;i++){
        db dx=x-s[i].x;
        db dy=y-s[i].y;
        tot+=sqrt(dx*dx+dy*dy)*s[i].w;//勾股定理算距离 
    }
    return tot;
}
inline void work(){
    db T=200;//随机选操作次数
    while(T>cnt){
        db nx=ansx+(rand()*2-RAND_MAX)*T;
        db ny=ansy+(rand()*2-RAND_MAX)*T;
        db delta=F(nx,ny)-F(ansx,ansy);//蛋挞 
        if(delta<0) ansx=nx,ansy=ny;//更新 
        else if(exp(-delta/T)*RAND_MAX>rand()) ansx=nx,ansy=ny;
        T*=0.998;
    } 
}
int main(){
    srand((int)time(NULL));
    cin >> n;
    for(int i=1;i<=n;i++){
        scanf("%lf%lf%lf",&s[i].x,&s[i].y,&s[i].w);
        ansx+=s[i].x;
        ansy+=s[i].y;
    }
    //模拟退火step1:随机选起点 
    ansx/=(db)n;
    ansy/=(db)n;
    work();
    printf("%.3lf %.3lf\n",ansx,ansy);
    return 0;
} 
```

---

## 作者：lyx128 (赞：1)

提供一种新颖的思路，考虑使用三分的思路。

但是，不同于其他题解的是，我将 $1$ 个大矩形分割为了 $9$ 个矩形，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/u0y8bzm1.png)

我们对 $9$ 个子矩形在大矩形内的 $4$ 个交点进行比大小操作，并选出最小的一个点。

本题的可以理解为将一个分了 $n$ 个岔的绳子穿过 $n$ 个的已知的点并绑上重物，最后绳子绷直后所有岔的贴紧平面的交叉点便是答案，所有就是求出一个点到给出的 $n$ 个点的距离乘以权值的最小值。

最后进行矩形缩小操作。例如 `lr` 点是最小的，那么因将矩阵的右下角缩小至 `rl`，并继续三分。

这种方法的速度比较快，相比模拟退火快了很多，跑出了 $33$ 毫秒的速度。

实现代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db long double
const int N=1000;
int n;
db x[N+5],y[N+5],w[N+5];
db f(db px,db py){
	db res=0;
	for(int i=1;i<=n;i++)
		res+=sqrtl((px-x[i])*(px-x[i])+(py-y[i])*(py-y[i]))*w[i];
	return res;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>x[i]>>y[i]>>w[i];
	db lx=*min_element(x+1,x+n+1),rx=*max_element(x+1,x+n+1),ly=*min_element(y+1,y+n+1),ry=*max_element(y+1,y+n+1);
	while((rx-lx)>=1e-4||(ry-ly)>=1e-4){
		db lenx=(rx-lx)/3;
		db llx=lx+lenx;
		db rrx=rx-lenx;
		db leny=(ry-ly)/3;
		db lly=ly+leny;
		db rry=ry-leny;

		db ll=f(llx,lly);
		db lr=f(llx,rry);
		db rl=f(rrx,lly);
		db rr=f(rrx,rry);

		if(ll<lr&&ll<rl&&ll<rr)
			ry=rry,rx=rrx;
		else if(lr<ll&&lr<rl&&lr<rr)
			ly=lly,rx=rrx;
		else if(rr<ll&&rr<lr&&rr<rl)
			ly=lly,lx=llx;
		else
			ry=rry,lx=llx;
	}
	cout<<fixed<<setprecision(3)<<rx<<" "<<ry<<"\n";
	return 0;
}
```

---

## 作者：Binah (赞：1)

~~不会退火也能做的退火题~~

被同机房的$\color{red}{F}\color{black}{lamire}$推荐了这么一道题

然后我作为不会退火的垃圾,开始按题意模拟

思路:每一次向合力方向移动,直到平衡

首先就是写了一地的函数
```cpp
struct point
{
    double x,y;
    friend point operator + (point a,point b)
    {
        point c;
        c.x=a.x+b.x;
        c.y=a.y+b.y;
        return c;
    }
    void read(int a,int b)
    {
        x=a;
        y=b;
    }
    void print()
    {
        printf("point:%lf %lf\n",x,y);
    }
} p[1001];
double point_dis(point a,point b)//point_dis指点间距离
{
    double d1=a.x-b.x;
    double d2=a.y-b.y;
    return sqrt(d1*d1+d2*d2);
}
double point_cos(point a,point b)
{
    return (b.x-a.x)/point_dis(a,b);
}
double point_sin(point a,point b)//,point_cos/sin描述两点间角度的余弦/正弦
{
    return (b.y-a.y)/point_dis(a,b);
}
point point_force(point s,point t,double w)s受到t方向w的力,分解为两个方向
{
    point c;
    c.x=point_cos(s,t)*w;
    c.y=point_sin(s,t)*w;
    return c;
}
```
然后开始调主函数
一代目:
```cpp
for(int i=1; i<=10000; i++)
    {
        mv.read(0,0);
        for(int j=1; j<=n; j++)
        {
            if(now.x==p[j].x && now.y==p[j].y)
            {
                if(abss(now.x)<=0.001)
                {
                    now.x=0;
                }
                if(abss(now.y)<=0.001)
                {
                    now.y=0;
                }
                printf("%.3lf %.3lf\n",now.x,now.y);
                return 0;
            }
            mv=mv+point_force(now,p[j],w[j]);
        }
        now=now+mv;
    }
```
此时mv(即合力)过大,导致维护的当前位置经常在两点间左右横跳

所以得到二代目:
```cpp
for(int i=1; i<=10000; i++)
    {
        mv.read(0,0);
        for(int j=1; j<=n; j++)
        {
            if(now.x==p[j].x && now.y==p[j].y)
            {
                if(abss(now.x)<=0.001)
                {
                    now.x=0;
                }
                if(abss(now.y)<=0.001)
                {
                    now.y=0;
                }
                printf("%.3lf %.3lf\n",now.x,now.y);
                return 0;
            }
            mv=mv+point_force(now,p[j],w[j]);
        }
        mv.x/=100;
        mv.y/=100;
        now=now+mv;
    }
```
想都别想,不是步数内爬不完就是TLE

最后就按照前一些步数加速爬行,后面逐渐放缓,成功[AC](https://www.luogu.com.cn/record/29213703)

最后贴上代码,完结撒花
```cpp
#include <bits/stdc++.h>
//#include <windows.h>
//#define int long long
using namespace std;
struct point
{
    double x,y;
    friend point operator + (point a,point b)
    {
        point c;
        c.x=a.x+b.x;
        c.y=a.y+b.y;
        return c;
    }
    void read(int a,int b)
    {
        x=a;
        y=b;
    }
} p[1001];
int x[1001];
int y[1001];
int w[1001];
int n;
double point_dis(point a,point b)
{
    double d1=a.x-b.x;
    double d2=a.y-b.y;
    return sqrt(d1*d1+d2*d2);
}
double point_cos(point a,point b)
{
    return (b.x-a.x)/point_dis(a,b);
}
double point_sin(point a,point b)
{
    return (b.y-a.y)/point_dis(a,b);
}
point point_force(point s,point t,double w)
{
    point c;
    c.x=point_cos(s,t)*w;
    c.y=point_sin(s,t)*w;
    return c;
}
point now;
point mv;
point org;
double sum;
double qwq;
double abss(double a)
{
	return a<0?-a:a;
}
int main()
{
    org.read(0,0);
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
        scanf("%d%d%d",&x[i],&y[i],&w[i]);
        sum+=w[i];
        p[i].read(x[i],y[i]);
    }
    srand(time(0));
    now.x=rand()%2000;
    now.y=rand()%2000;
    now.x-=1000;
    now.y-=1000;
    for(int i=1; i<=10000; i++)
    {
        mv.read(0,0);
        for(int j=1; j<=n; j++)
        {
            if(now.x==p[j].x && now.y==p[j].y)
            {
                if(abss(now.x)<=0.001)
                {
                    now.x=0;
                }
                if(abss(now.y)<=0.001)
                {
                    now.y=0;
                }
                printf("%.3lf %.3lf\n",now.x,now.y);
                return 0;
            }
            mv=mv+point_force(now,p[j],w[j]);
        }
        qwq=point_dis(mv,org);
        if(i>=2000)
        {
            mv.x/=(i/2)-999;
            mv.y/=(i/2)-999;
        }
        else if(qwq>=sum*7/8)
        {
        	mv.x*=10;
        	mv.y*=10;
		}
		else if(qwq>=sum*3/4)
		{
			mv.x*=2;
			mv.y*=2;
		}
        now=now+mv;
    }
    if(abss(now.x)<=0.001)
    {
        now.x=0;
    }
    if(abss(now.y)<=0.001)
    {
        now.y=0;
    }
    printf("%.3lf %.3lf\n",now.x,now.y);
    return 0;
}

```


---

## 作者：1xijing (赞：1)

## 关于模拟退火
##### 简介
模拟退火是一种随机化算法。  
对于一个当前最优解附近的非最优解，爬山算法直接舍去了这个解。而很多情况下，我们需要去接受这个非最优解从而跳出这个局部最优解，即为模拟退火算法。  
当一个问题的方案数量**极大**（甚至是无穷的）而且**不是一个单峰函数**时，常使用模拟退火求解。
##### 实现
如果新状态的解更优则修改答案，否则以一定概率接受新状态。  

模拟退火时有三个参数：初始温度`$T_0$`，降温系数`$d$` ，终止温度`$T_k$`。
`$T_0$`是一个比较大的数（至少需要大于搜索范围）  
`$d$` 是一个非常接近1但是小于1的数  
`$T_k$`是一个接近0的正数  
定义当前温度为`$T$`，新状态与已知状态（由已知状态通过随机的方式得到）之间的能量差为`$\Delta E$`，（当要求的`$E$`为最大值时）发生状态转移（修改最优解）的概率为  
`$P(\Delta E)=\begin{cases}1,\quad \Delta E>0\\e^{\frac{\Delta E}{T}},\quad \Delta E\leq 0\end{cases}$`  
首先让温度`$T=T_0$`，进行转移尝试，再让`$T=T*d$`。当`$T<T_k$`时模拟退火过程结束，当前最优解即为最终的最优解。  
有时为了使得到的解更有质量，会在模拟退火结束后，以当前温度在得到的解附近多次随机状态，尝试得到更优的解（其过程与模拟退火相似）。

如图随着温度的降低，跳跃越来越不随机，最优解也越来越稳定  
![image](https://oi-wiki.org/misc/images/simulated-annealing.gif)

## 关于本题
虽然模拟退火不是正解，但是可以AC!  
而且本题也是一道非常优秀的模拟退火例题!

当重力势能最小时稳定，将物理模型简化  
设桌子的高度为`$h$`，绳子的长度为`$l$`,每个点到`$x$`的距离为`$dis[i]$`  
重力势能为`$\sum_{i=1}^{n}(h-(l-dis[i]))*W[i]=\sum_{i=1}^{n}(h-l+dis[i])*W[i]$`  
由于`$h-l$`为定值，所以重力势能最小的情况等价于`$\sum_{i=1}^{n}dis[i]*W[i]$`最小  
即 求`$n$`个点的带权费马点

###### Code:
```
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a),i##_=(b);i<=i##_;++i)
#define M 1005
#define db double
using namespace std;
int X[M],Y[M],W[M],n;
db ans,ansx,ansy;
db Pow(db x){
	return x*x;
}
db Dis(db x,db y){
	return sqrt(Pow(x)+Pow(y));
}
db Rand(){
	return (db)rand()/RAND_MAX;//返回一个[0,1]之前的小数
}
db Cal(db x,db y){
	db res=0;
	For(i,1,n)res+=Dis(x-X[i],y-Y[i])*W[i];
	//在Cal中更新答案
	if(res<ans)ans=res,ansx=x,ansy=y;
	return res;
}
void SimulateAnneal(){
	db T0=100000,Tk=0.001,d=0.97;
	db nowx=ansx,nowy=ansy,T=T0;
	while(T>Tk){
	    //Rand()*2-1 返回一个[-1,1]之间的数
		db nxtx=nowx+T*(Rand()*2-1);
		db nxty=nowy+T*(Rand()*2-1);
		db tmp=Cal(nxtx,nxty)-Cal(nowx,nowy);
		//tmp<0 即新解更优，那么一定接受新解
		//否则 以一定概率接受新解
		if(tmp<0||exp(-tmp/T)>Rand())nowx=nxtx,nowy=nxty;
		T*=d;
	}
	//以当前温度在得到的解附近多次随机状态，尝试得到更优的解
	int t=1000;
	For(i,1,t){
		db nxtx=ansx+T*(Rand()*2-1);
		db nxty=ansy+T*(Rand()*2-1);
		Cal(nxtx,nxty);
	}
}
int main(){
	srand(19260817);
	scanf("%d",&n);
	For(i,1,n){
		scanf("%d%d%d",&X[i],&Y[i],&W[i]);
		ansx+=X[i],ansy+=Y[i];
	}
	//初始值可以随机，在本题中采用所有点坐标的平均值
	ansx/=n,ansy/=n;
	ans=Cal(ansx,ansy);
	SimulateAnneal();
	printf("%.3f %.3f\n",ansx,ansy);
	return 0;
}
//这份代码不保证一次AC哦！
//可以手调参数来加深理解哦！
```

---

## 作者：Nero_Claudius (赞：1)

这道题调了好久，果然非洲人是得不到眷顾的吗。。。

------------

本题采用模拟退火解决。

模拟退火是一种简洁明了而又高效的近似算法，基本上可以套到任何求最优解的题目上去。

它的原理是模拟物理中金属退火的现象，凭借选手逆天的RP跳出局部最优解，来到全局最优解。

比较常用的近似算法还有爬山和遗传，但是我个人觉得没太大必要掌握（像我这种脸黑的选手有一次遗传算法WA52。。）。

------------

模拟退火总体就是一个持续降温的流程。

在降温的过程中，坐标随机跳动的范围会越变越小。

当然，为了防止搞错，我们每一次都会以一定概率接受一个比较奇怪的解，这一点有些类似遗传算法中的突变。

```cpp
inline void simulateAnneal(){
	double x=ansx,y=ansy;t=5000;
	while(t>1e-14){
		double X=x+((rand()<<1)-RAND_MAX)*t,Y=y+((rand()<<1)-RAND_MAX)*t;
		double now=calcEnergy(X,Y),dist=now-ans;
		if(dist<0){
				ansx=x=X,ansy=y=Y,ans=now;
		}else if(exp(-dist/t)*RAND_MAX>rand())x=X,y=Y;
		t*=delta;
	}
}
```

这里t代表温度，它会一直递减。

然后每一次我们会根据t的值（控制范围）随机跳一个新的解。

求一下它的值，看一下值能不能接受。

假如这个值不能接受，那就以一定概率接受一个奇奇怪怪的解，选择解的方法遵循Metropolis准则（我也不知道这是什么玩意别问我）。

求值的流程因题而异，总之就是一个衡量解的标准。

```cpp
template<typename T>inline T calcEnergy(T x,T y){
	T tmp=0;
	for(register int i=1;i<=n;++i){
		T disx=x-a[i].x,disy=y-a[i].y;
		tmp+=sqrt(disx*disx+disy*disy)*a[i].val;
	}
	return tmp;
}
```

------------

主要的部分大概就这么多了，其他要注意的无非就是常数什么的了。

M_sea大佬用的常数是

```
delta=0.993
t=2000
loop=5
```

（loop指的是运行次数）

然而这个常数对于脸黑的我来说比较窒息，所以做了一点小调整，最后是

```
delta=0.9932
t=5000
loop=5
```

最后，AC代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstdlib>
using namespace std;
namespace StandardIO{
	template<typename T>inline void read(T &x){
		x=0;T f=1;char c=getchar();
		for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
		x*=f;
	}
	template<typename T>inline void write(T x){
		if(x<0)putchar('-'),x*=-1;
		if(x>=10)write(x/10);
		putchar(x%10+'0');
	}
}
using namespace StandardIO;
namespace Solve{
	const int N=1010;
	const double delta=0.9932;
	
	struct SA{
		private:
			int n,sumx,sumy;
			double ans=1e18,t;
			struct node{
				int x,y,val;
			}a[N];
			template<typename T>inline T calcEnergy(T x,T y){
				T tmp=0;
				for(register int i=1;i<=n;++i){
					T disx=x-a[i].x,disy=y-a[i].y;
					tmp+=sqrt(disx*disx+disy*disy)*a[i].val;
				}
				return tmp;
			}
			inline void simulateAnneal(){
				double x=ansx,y=ansy;t=5000;
				while(t>1e-14){
					double X=x+((rand()<<1)-RAND_MAX)*t,Y=y+((rand()<<1)-RAND_MAX)*t;
					double now=calcEnergy(X,Y),dist=now-ans;
					if(dist<0){
						ansx=x=X,ansy=y=Y,ans=now;
					}else if(exp(-dist/t)*RAND_MAX>rand())x=X,y=Y;
					t*=delta;
				}
			}
			
		public:
			SA(){}
			~SA(){}
			
			double ansx,ansy;
			inline void init(){
				srand(19260817),srand(rand()),srand(rand());
				read(n);
				for(register int i=1;i<=n;++i){
					read(a[i].x),read(a[i].y),read(a[i].val);
					sumx+=a[i].x,sumy+=a[i].y;
				}
			}
			template<typename T>inline void SimulateAnneal(T times){
				ansx=(double)sumx/n,ansy=(double)sumy/n;
				for(register int i=1;i<=times;++i)simulateAnneal();
			}
	}ljz;
	
	inline void solve(){
		ljz.init();
		ljz.SimulateAnneal(5);
		printf("%.3lf %.3lf",ljz.ansx,ljz.ansy);
	}
}
using namespace Solve;
int main(){
	solve();
}

```

---

## 作者：hicc0305 (赞：1)

## 吐槽
模拟退火。。一个神奇的算法。。

（这道题目其实叫被XXX吊打）

这个算法靠随机。。也就是靠你的脸。。脸白一点，参数用得优秀一点就过了。。。（比如我把参数从2000换成2333就过了orz）

然后。。正式介绍一下

## 模拟退火（SA）
可以去看看这一篇讲稿：https://www.cnblogs.com/rvalue/p/8678318.html

解释一下温度是什么东西：其实就是控制随机波动大小的参数，越接近最优解，你就要降温，也就是让T温度变小，这样就可以让随机的幅度变小，不断逼近最优解。

温度不能取太小，不然会被困在局部最优解。

根据图感性理解一下：

![](http://yingzf.applinzi.com/cloud/index.php?user/publicLink&fid=27392x7rRqdDW_VWk2Jb2tPZX0MLCAUIiWQHkCa0h2nGp1wIxr3Fi0Ti38B5Ez1zDo47zj3c3EDXKwNVWo75OeEAHOmGIWgH_qJs7fjvCUDMalwh016SgN07BMdLvukHcu8PXCFVTEI1l_DACWXY-ab01_gA6DUHY6qT7wvOGhfrfYDKGpQOr0BJDg&file_name=/1200714-20180331070457230-679205132.gif)

那么为什么叫温度呢。。因为这个东西和热力学有关orz

引用一下我发的连接里面的大佬说的：

根据热力学规律并结合计算机对离散数据的处理, 我们定义: 如果当前温度为 T , 当前状态与新状态之间的能量差为 ΔE , 则发生状态转移的概率为:

P(ΔE)=e^(ΔE/kT) 显然如果 ΔE 为正的话转移是一定会成功的, 但是对于 ΔE< 我们则以上式中计算得到的概率接受这个新解。

也就是说，更优的解一定要，不优的解也不能完全不要。

我们对于不优的解，我们也要去拓展一下，不能一味取最优解，不然很容易被困在局部最优解。

## 解法
一个重物的重力势能是和它的离地距离成正比的，因为绳长和桌面离地高度是不变的，我们可以转化为绳结到洞的距离和重力势能成正比。在比较解是否更优时，我们算出总的重力势能（可以拿距离*重力），当然是重力势能小的更优。

剩下的。。就是套模拟退火了

## 程序
```cpp
#include<ctime>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
double T;
struct node
{
	double x,y,w;
}p[1100];
double x,y;
double GPE(double ux,double uy)//重力势能计算
{
	double sum=0;
    for(int i=1;i<=n;i++)
        sum+=sqrt((ux-p[i].x)*(ux-p[i].x)+(uy-p[i].y)*(uy-p[i].y))*p[i].w;
    return sum;
}
void SA()
{
	T=2333.0;//信仰2333吧
	double xx=x,yy=y;
	while(T>1e-16)//小于终温就退出，终温是控制精度的
	{
		double vx=xx+(2.0*rand()-RAND_MAX)*T,vy=yy+(2.0*rand()-RAND_MAX)*T;//波动区间在-RAND_MAX*T ~ RAND_MAX*T
		double del=GPE(vx,vy)-GPE(xx,yy);//gravitational potential energy
		if(del<0) x=xx=vx,y=yy=vy;
		else if(exp(-del/T)*RAND_MAX>rand()) xx=vx,yy=vy;//相乘比较的精度会高一些
		T*=0.997;//乘上降温系数
	}
}
int main()
{
	srand(time(NULL));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf%lf",&p[i].x,&p[i].y,&p[i].w),x+=p[i].x,y+=p[i].y;
	x/=(double)n,y/=(double)n;//取平均值好一些
	SA(),SA();
	printf("%.3lf %.3lf",x,y);
	return 0;
}
```

## 忠告

~~如果总有一两个点过不了，换一些玄学的参数~~

~~还是过不了，那是你脸太黑了。。让欧洲人帮你改参数、交代码吧。。。~~

 如果发现经常陷入局部最优解的话考虑增大初始的T和降温系数 , 如果发现最终精度不够的话考虑减小终温

---


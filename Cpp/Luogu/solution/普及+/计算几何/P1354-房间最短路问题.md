# 房间最短路问题

## 题目描述

在一个长宽均为 $10$，入口、出口分别为 $(0,5)$、$(10,5)$ 的房间里，有几堵墙，每堵墙上有两个缺口，求入口到出口的最短路经。

![](https://cdn.luogu.com.cn/upload/image_hosting/i929rz3l.png)

## 样例 #1

### 输入

```
2
4 2 7 8 9
7 3 4.5 6 7
```

### 输出

```
10.06
```

# 题解

## 作者：24680esz (赞：20)

%%%%%%%%楼下大佬，代码写得那么长，连300多行的代码都出来了，一看到的时候确实吓了一跳。

这题的思路和算法楼下已经说得很清楚了，在每一个点之间利用一次函数判断后建边，最后跑最短路

这里只在代码风格上做一些小优化

1.zhengrunzhe你就不能用循环吗？29行的建边！！！！！！

2.就这题n<=20的数据量，真搞不懂为什么要写dijkstra，还带优化…………

直接写floyd不久好了么？？？

上代码（46行）

```cpp
#include <bits/stdc++.h>
using namespace std;
struct wall
{
    double x,z[5];//存储墙的横坐标与每个点的纵坐标
}w[22];
int n;
double e[101][101];
bool hathes(int a,int b,int w1,int w2)
{
    if (b-a<2) return 1;
    double x1=w[a].x,x2=w[b].x,y1=w[a].z[w1],y2=w[b].z[w2];
    double k=(y1-y2)/(x1-x2),t=y1-x1*k;
    for (int i=a+1;i<b;i++)
    {
        double y=k*w[i].x+t;
        if (y<w[i].z[1]||y>w[i].z[2]&&y<w[i].z[3]||y>w[i].z[4]) return 0;
    }
    return 1;
}
void addedge(int a,int b,int w1,int w2)
{
    if (!hathes(a,b,w1,w2)) return;//判断中间是否有墙阻挡
    double x1=w[a].x,x2=w[b].x,y1=w[a].z[w1],y2=w[b].z[w2];
    e[a*4+w1][b*4+w2]=e[b*4+w2][a*4+w1]=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));//计算两点间距离，建边
}
int main()
{
    cin>>n;
    memset(e,127,sizeof(e));
    for (int i=1;i<=n;i++)
    {
        cin>>w[i].x;
        for (int j=1;j<5;j++) cin>>w[i].z[j];
    }
    w[0].x=0;w[++n].x=10;
    for (int i=1;i<5;i++) w[0].z[i]=w[n].z[i]=5;//初始化起点与终点
    for (int i=0;i<n;i++) for (int j=i+1;j<=n;j++) for (int k=1;k<5;k++) for (int l=1;l<5;l++) addedge(i,j,k,l);//循环建边
    for (int i=0;i<101;i++) e[i][i]=0;
    for (int k=1;k<=n*4+4;k++)
      for (int i=1;i<=n*4+4;i++)
        for (int j=1;j<=n*4+4;j++)
          e[i][j]=min(e[i][j],e[i][k]+e[k][j]);//floyd
    printf("%.2f\n",e[1][n*4+1]);
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：9)


   
   
   
既然这是一道图论题，那我们就要考虑建图。  
这里把图搬出来：   

![](https://cdn.luogu.com.cn/upload/pic/141.png)   

虽然在这个房间里可以用很多种走法，但实际上图的节点只有墙壁的端点和始末点就行了。    
就比如 $(4,2),(4,7),(4,9),(7,4.5)$ 等点，然后把这些点相连建图即可。     

光是这样还不行的，我们注意到有一些节点之间连成的线段是被墙隔断的。那我就需要写一个函数，来判断一条线段是否与一条平行于 $y$ 轴的线段（也就是墙壁）有交点。   
    
设线段的两端点分别为 $(x_1,y_1)$ 和 $(x_2,y_2)$，可以得出其所在直线的方程（由于 $x_2\neq x_1$ 所以可以这样写）：

$$y = \frac{y_2-y_1}{x_2-x_1}(x-x_1)+y_1$$
那么只需要令 $x$ 为墙壁所在的横坐标，判断 $y$ 值是否在墙壁的两端之间。

建图的问题也解决了，由于数据范围很小，随便选择一种最短路算法都能通过。  

参考代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#define inf 0x3f3f3f3f
#define ll long long
#define N 1003
#define M 24
using namespace std;

struct edge{//求最短路用,图的边,w即距离
    int v;
    double w;
    edge(int v=0,double w=0):v(v),w(w){}
};

struct node{//求最短路用,图的节点,d为到源点距离
    int id;
    double d;
    node(int id=0,double d=0):id(id),d(d){}
    bool operator < (const node& n1) const{
        return d > n1.d;
    }
};

struct point{//平面直角坐标系中的一个点
    double x,y;
    point(double x=0,double y=0):x(x),y(y){}
};

struct wall{//记录一堵墙,y1,y2分别为墙的上、下纵坐标
    double x,y1,y2;
    wall(double x=0,double y1=0,double y2=0):x(x),y1(y1),y2(y2){}
};

double d[N];
point pt[M*4];
wall wl[M*3];
double x,a1,b1,a2,b2;
vector<edge> adj[N]; //vector存图
int n,m = 0,s,wallCount;
//n为节点数,m为边数,s为源节点(也就是1号节点,入口)

inline double dis(double x1,double y1,double x2,double y2){
    //计算平面直角坐标系中两点距离
    return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}

inline bool intersect(point pt1,point pt2,wall wal){
    //判断路径是否与墙相交
    double wlx = wal.x,y1 = wal.y1,y2 = wal.y2;
    if(pt1.x==pt2.x) return true;
    double k = (pt1.y-pt2.y)/(pt1.x-pt2.x);
    double b = pt1.y-k*pt1.x;
    double wyy = k*wlx+b; //wyy可爱。
    return (wyy<y1 && wyy>y2 && pt1.x<wlx && pt2.x>wlx);
    //交点在墙上,也在路径上
}

void dijkstra(){
    //dijkstra求最短路,SPFA已死
    s = 1;
    for(int i=1;i<=n;++i) d[i] = inf;
    d[s] = 0;
    priority_queue<node> q;
    q.push(node(s,0));
    while(!q.empty()){
        int u,v,l;
        u = q.top().id;
        double du = q.top().d;
        q.pop();
        if(du>d[u]) continue;
        l = adj[u].size();
        double w;
        for(int i=0;i<l;++i){
            w = adj[u][i].w;
            v = adj[u][i].v;
            if(du+w>=d[v]) continue;
            d[v] = du+w;
            q.push(node(v,d[v]));
        }
    }
}

inline void build(int from,point pt1){
    //剪枝:从from号点建边,之前的都不用考虑,因为一定不相交
    point pt2;
    //pt1为起点,pt2为终点
    for(int i=from+1;i<=n;++i){
        bool connect = true;
        pt2 = pt[i];
        for(int j=1;j<=wallCount;++j){
            //遍历所有墙,判断是否连通
            if(!intersect(pt1,pt2,wl[j])) continue;
            connect = false;
            break;
        }
        if(!connect) continue;
        adj[from].push_back(edge(i,dis(pt1.x,pt1.y,pt2.x,pt2.y)));
        ++m;
    }
}

int main(){
    scanf("%d",&n);
    wallCount = n*3;
    //墙的数量一定是n*3
    pt[1] = point(0,5); //起点
    int t = 2; //t记录当前节点数-1
    for(int i=1;i<=n;++i){
        scanf("%lf%lf%lf%lf%lf",&x,&a1,&b1,&a2,&b2);
        wl[(i-1)*3+1] = wall(x,10,b2);
        wl[(i-1)*3+2] = wall(x,a2,b1);
        wl[(i-1)*3+3] = wall(x,a1,0);
        pt[t] = point(x,a1);
        pt[t+1] = point(x,b1);
        pt[t+2] = point(x,a2);
        pt[t+3] = point(x,b2);
        t += 4;
    }
    pt[t] = point(10,5); //终点
    n = t;
    for(int i=1;i<n;++i) build(i,pt[i]);
    dijkstra();
    printf("%.2lf",d[n]);
}
```

---

## 作者：zhylj (赞：7)

玄学AC（速度是所有提交中最慢的）

但是……这题n<=20，为什么要建图呢？（其实我也想不出来图怎么建233333）

由题目可以想到DP状态f[i][j]为第i堵墙坐标为j时的最短路

由于j是实数，所以需要做一些处理

我们就选择枚举0.00、0.01...10.00为j

为了避免精度问题，我们将在大部分时候将j置于整数

于是我们从0到1000枚举，运算的时候再/100就可以实现了

故得出方程

假如f[i][j]表示到第i堵墙，纵坐标为j时的最短路,a[i]表示第i堵墙的横坐标，dis(x1,y1,x2,y2)表示(x1,y1)和(x2,y2)的距离

f[i][j]=min{f[i-1][k]+dis(a[i],j,a[i-1],k)...f[i-1][k]+dis(a[i],j,a[i-1],k)};

(保证所有的点k都可以到达f[i][j])

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n;
    double wall[25][5],f[20][2005]; //wall代表每一堵墙，
    double dis(double x1,double y1,double x2,double y2)//距离函数
    {
        return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));  //勾股定理
    }
    int main()
    {
        memset(f,0x7f,sizeof(f));  //先把所有都置成无限大
        for(int i=0;i<2005;i++)  //到墙0（起点）的距离为0
            f[0][i]=0;
        cin>>n;  //读入n
        wall[0][0]=0;
        //初始化起点，把起点看成横坐标为0的只有一个洞的墙
        wall[0][1]=wall[0][3]=wall[n+1][1]=wall[n+1][3]=5;
        //终点也是，把终点也看成只有一个洞的墙
        wall[0][2]=wall[0][4]=wall[n+1][2]=wall[n+1][4]=5;
        wall[n+1][0]=10;  //设置终点的横坐标
        for(int i=1;i<=n;i++)
            cin>>wall[i][0]>>wall[i][1]>>wall[i][2]>>wall[i][3]>>wall[i][4];  //读入题目要求的x，a1，b1，a2，b2
        for(int i=1;i<=n+1;i++)  //依次枚举每一面墙，这里到墙0（起点）的距离已经设置好了
            for(int j=0;j<=1000;j++) //枚举j
                if((j/100.0>=wall[i][1]&&j/100.0<=wall[i][2])||(j/100.0>=wall[i][3]&&j/100.0<=wall[i][4]))  //如果枚举的j不再墙上
                    for(int k=0;k<=1000;k++)  //枚举k
                        if((k/100.0>=wall[i-1][1]&&k/100.0<=wall[i-1][2])||(k/100.0>=wall[i-1][3]&&k/100.0<=wall[i-1][4]))  //如果k不在墙上
                            f[i][j]=min(f[i-1][k]+dis(wall[i][0],j/100.0,wall[i-1][0],k/100.0),f[i][j]);  //找最优解
        printf("%.2lf\n",f[n+1][500]);  //输出
        return 0;  //返回0
}
```

---

## 作者：zhengrunzhe (赞：5)

貌似没有C++的题解，所以:

思路/算法：最短路

坑点：小数、麻烦的建边

我们把起点终点和每堵墙的a1,b1,a2,b2都看做点

一开始我把n先加上2，即把起点和终点所在的直线看作一堵墙

令起点的编号为1，得出a1[i]的编号为(i-2)\*4+2,b1[i]即(i-2)\*4+3,a2[i]即(i-1)\*4,b2[i]即(i-1)\*4+1，终点即(n-2)\*4+2

然后判断两点间是否无阻拦

利用一次函数，求出连结两点的线段与每堵墙所在直线的交点

然后判断交点是否在墙洞，

如果都不会被所有墙挡，那么这两个点就可以建一条边

该边的权值就是这两点之间的距离，可以通过公式求出

最后跑一遍最短路，我是用Dijkstra+Heap优化

更多解释见代码：

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#define end (n-2)*4+2  //为了方便，这是终点的编号 
using namespace std;
typedef double dou;  //为了方便… 
const int N=23,M=16*(N-1)*N;  //M是边的最大数量 (当然应该也是开多了)
const dou INF=233333333.0;  //搞个笑，其实没必要开这么大 
int n,head[N*4],num;
struct wall{dou x,a1,b1,a2,b2;int p1,p2,p3,p4;}a[N];  //存每一堵墙的信息，p1~p4表示a1~b2的节点编号 
struct edge{dou w;int to,next;}e[M];  //存边，采用邻接表 
bool check(dou xa,dou ya,dou xb,dou yb,dou xx,dou aa,dou ba,dou ab,dou bb)  //判断交点是否不被堵 
{
    //说明一下那一大串变量，按顺序分别表示：
    //两点中其中一点的横坐标，纵坐标，另一点的横坐标，纵坐标，墙的横坐标，墙的a1~b2 
    dou k=(ya-yb)/(xa-xb);  //计算斜率 
    dou b=ya-xa*k; //计算截距 
    dou yy=k*xx+b;  //计算与墙的交点的纵坐标 
    if ((yy>=aa&&yy<=ba)||(yy>=ab&&yy<=bb))return 1; //如果在墙窟窿中就说明没被堵 
    return 0;  //否则就不行 
}
void addedge(int u,int v,dou c)  //建一条边 
{
    e[++num].next=head[u];
    e[num].to=v;
    head[u]=num;
    e[num].w=c;
}
void addonce(int p,int q,dou xp,dou yp,dou xq,dou yq,int posp,int posq)  //判断能否搭边后再搭边 
{
    //再解释一下那一堆变量，按顺序分别为：
    //一点编号，另一点编号，一点的横纵坐标，另一点的横纵坐标，一点所在的墙的编号(下标)，另一点所在的墙的编号 
    bool flag=0;
    for (int o=posp+1;o<posq;o++) 
        if (!check(xp,yp,xq,yq,a[o].x,a[o].a1,a[o].b1,a[o].a2,a[o].b2))
            {flag=1;break;}
    dou dis=sqrt((xp-xq)*(xp-xq)+(yp-yq)*(yp-yq));  //计算两点间距离 
    if (!flag)addedge(p,q,dis),addedge(q,p,dis);  //如果可以建就建边 
}
void add(int l,int r)  //建出两堵墙的所有点之间的边，l，r分表表示两堵墙的编号 
{
    if (l>1&&r<n)  //如果不是起点所在的墙或终点所在的墙(是不是很可怕233333333) 
        addonce(a[l].p1,a[r].p1,a[l].x,a[l].a1,a[r].x,a[r].a1,l,r),
        addonce(a[l].p1,a[r].p2,a[l].x,a[l].a1,a[r].x,a[r].a2,l,r),
        addonce(a[l].p1,a[r].p3,a[l].x,a[l].a1,a[r].x,a[r].b1,l,r),
        addonce(a[l].p1,a[r].p4,a[l].x,a[l].a1,a[r].x,a[r].b2,l,r),
        addonce(a[l].p2,a[r].p1,a[l].x,a[l].a2,a[r].x,a[r].a1,l,r),
        addonce(a[l].p2,a[r].p2,a[l].x,a[l].a2,a[r].x,a[r].a2,l,r),
        addonce(a[l].p2,a[r].p3,a[l].x,a[l].a2,a[r].x,a[r].b1,l,r),
        addonce(a[l].p2,a[r].p4,a[l].x,a[l].a2,a[r].x,a[r].b2,l,r),
        addonce(a[l].p3,a[r].p1,a[l].x,a[l].b1,a[r].x,a[r].a1,l,r),
        addonce(a[l].p3,a[r].p2,a[l].x,a[l].b1,a[r].x,a[r].a2,l,r),
        addonce(a[l].p3,a[r].p3,a[l].x,a[l].b1,a[r].x,a[r].b1,l,r),
        addonce(a[l].p3,a[r].p4,a[l].x,a[l].b1,a[r].x,a[r].b2,l,r),
        addonce(a[l].p4,a[r].p1,a[l].x,a[l].b2,a[r].x,a[r].a1,l,r),
        addonce(a[l].p4,a[r].p2,a[l].x,a[l].b2,a[r].x,a[r].a2,l,r),
        addonce(a[l].p4,a[r].p3,a[l].x,a[l].b2,a[r].x,a[r].b1,l,r),
        addonce(a[l].p4,a[r].p4,a[l].x,a[l].b2,a[r].x,a[r].b2,l,r); //各种排列，共16种(其实如果用数组存，一遍for可能就可以了) 
    if (l==1&&r<n) //如果一堵墙是起点的墙，而另一点不是终点的墙 
        addonce(1,a[r].p1,0,5,a[r].x,a[r].a1,1,r),
        addonce(1,a[r].p2,0,5,a[r].x,a[r].a2,1,r),
        addonce(1,a[r].p3,0,5,a[r].x,a[r].b1,1,r),
        addonce(1,a[r].p4,0,5,a[r].x,a[r].b2,1,r); //共四种 
    if (r==n&&l>1)  //如果一堵墙是终点所在的墙，而另一点不是起点的墙 
        addonce(a[l].p1,end,a[l].x,a[l].a1,10,5,l,n),
        addonce(a[l].p2,end,a[l].x,a[l].a2,10,5,l,n),
        addonce(a[l].p3,end,a[l].x,a[l].b1,10,5,l,n),
        addonce(a[l].p4,end,a[l].x,a[l].b2,10,5,l,n); //共四种 
    if (l==1&&r==n) //如果两堵墙就是起点终点 
        addonce(1,end,0,5,10,5,1,n);  //就一种 
}
struct heap //堆的形式 
{
    int id,dis;
    bool operator<(const heap &doby)
    const
    {
        return dis>doby.dis;
    }
};
typedef heap h;  //为了方便 
priority_queue<h>q; //建立堆 
dou d[N*4];
bool f[N*4];
dou dijkstra()  //迪杰斯特拉，不解释 
{
    for (int i=2;i<=end;i++)d[i]=INF;
    q.push((h){1,0});
    while (q.size())
    {
        int p=q.top().id;q.pop();
        if (f[p])continue;f[p]=1;
        for (int i=head[p];i;i=e[i].next)
            if (d[p]+e[i].w<d[e[i].to]&&!f[e[i].to])
                d[e[i].to]=d[p]+e[i].w,
                    q.push((h){e[i].to,d[e[i].to]});
    }
    return d[end]; //最终返回的是终点编号的d，而不是d[n] (终点所在的墙的编号的d)
}
int main()
{
    scanf("%d",&n);n+=2; //把n加上了2，因为我搞了一个起点和终点的墙 
    for (int i=2;i<n;i++)
        scanf("%lf%lf%lf%lf%lf",&a[i].x,&a[i].a1,&a[i].b1,&a[i].a2,&a[i].b2),
        a[i].p1=(i-2)*4+2,a[i].p2=(i-2)*4+3,a[i].p3=(i-1)*4,a[i].p4=(i-1)*4+1;
    for (int i=1;i<n;i++)
        for (int j=i+1;j<=n;j++)
            add(i,j);
    printf("%.2lf",dijkstra());
    return 0;
}  //共111行(包含注释所占的行)
```

---

## 作者：NekoPass (赞：4)

# 思路：建图，跑最短路

刚看到这道题，看标签，计算几何，~~好的再见我不做了~~

首先我们发现，这道题目绝对不会让你走曲线 ~~比如椭圆、双曲线、抛物线、bulabulabula~~ ，毕竟两点之间线段最短。

![](https://cdn.luogu.com.cn/upload/pic/141.png)

再看一下样例的图我们发现，有效的点似乎只有墙的两端？这是为什么喵？

>这里我们称有效的点为一个折线段上的折点（如图中点(7,4.5)就是一个有效点）。

想象一根毛线，将它随意地穿过样例的图，然后用力拉直。除了被墙顶住的点，其他点显然都不是有效的点。

所以我们可以将每个墙边缘的点视为有效点，然后连边建图。

但是两个点之间的路径可能会被墙挡住，这时我们就需要判断是否需要添加这条边了。

设A(ax,ay)和B(bx,by)以及一堵在横坐标在ax-bx之间的墙，如果存在交点(x,y)有

>$$\frac{y-a{}_{y}}{x-a{}_{x}}\qquad=\frac{y-b{}_{y}}{x-b{}_{x}}\qquad$$

化简可得：

>$$y = \frac{(x-a{}_{x})b{}_{y}-(x-b{}_{x})a{}_{y}} {b{}_{x}-a{}_{x}} \qquad$$

x是墙的横坐标，我们可以借此求出y，当y在这堵墙内时，则无法连接A到B的连边。

对每一对点进行连边Link操作，其中当两点的横坐标相同时，直接连接（因为即使这两点中间有墙也可以极限擦墙走）

最后在新建的图上跑一边最短路，这题最多只有20 * 4 = 80个点，所以用floyd也是可以的。

所以我们可以很快地打出一个不算很长的代码，码风很丑，所以与其照着这个打还不如看完上面的思路后自己打一遍喵OvO~

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
using namespace std;
struct _Wall{
	float x,up,down;
	int p;
};//墙壁 x：横坐标 down：下端的纵坐标 up：上端的总坐标
_Wall make(float x,float down,float up){
	_Wall w;
	w.x=x;w.up=up;w.down=down;
	return w;
}
struct point{
	float x,y;
}pt[200];
point PT(float x,float y){
	point a;
	a.x=x;a.y=y;
	return a;
}
_Wall wall[200][10];
int n,pn;
float mp[200][200];
inline float Link(int u,int v){//判断是否可连边，否则返回0
	if(pt[u].x==pt[v].x) return abs(pt[u].y-pt[v].y);
	for(int i=1;i<=n;++i){
		float X=wall[i][1].x,Y;
		if(X<=pt[u].x||X>=pt[v].x) continue;
		Y=((X-pt[u].x)*pt[v].y-(X-pt[v].x)*pt[u].y)/(pt[v].x-pt[u].x);
		for(int w=1;w<=3;++w)
		if(Y>=wall[i][w].down&&Y<=wall[i][w].up) return 0;
	}
	float delx=pt[v].x-pt[u].x,dely=pt[u].y-pt[v].y;
	return sqrt(delx*delx+dely*dely);
}
int main(){
	float x,a1,a2,b1,b2;
	scanf("%d",&n);
	pt[++pn]=PT(0,5);//起点
	for(int i=1;i<=n;++i){
		cin>>x>>a1>>b1>>a2>>b2;
		wall[i][1]=make(x,0,a1);pt[++pn]=PT(x,a1);
		wall[i][2]=make(x,b1,a2);pt[++pn]=PT(x,b1);pt[++pn]=PT(x,a2);
		wall[i][3]=make(x,b2,10);pt[++pn]=PT(x,b2);
	}
	pt[++pn]=PT(10,5);//终点
	for(int i=1;i<=pn;++i)
	for(int j=i+1;j<=pn;++j) mp[i][j]=mp[j][i]=Link(i,j);
	for(int k=1;k<=pn;++k)
	for(int i=1;i<=pn;++i)
	for(int j=1;j<=pn;++j)
	if(i!=k&&j!=k&&i!=j)
	if(mp[i][k]!=0&&mp[k][j]!=0){
		if(mp[i][j]==0) mp[i][j]=mp[i][k]+mp[k][j];
		else mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);
	}
	printf("%.2f\n",mp[1][pn]);
	return 0;
}
```


---

## 作者：plane (赞：3)

把所有墙的顶点都提出来，如果两点之间没有任何点的阻挡，那么建边，最后最短路即可。


```delphi


type
 q=record
    t1,t3:longint;
    t2:real;
   end;
var
 n,i,total,sum,j,k:longint;
 data:array[1..20,1..5] of real;
 save:array[1..1000] of q;
 map,queue:array[1..100] of longint;
 dist:array[1..100] of real;
 flag:array[1..100] of boolean;
 len:real;
 p:array[1..100,1..2] of real;
procedure add(a,b:longint;l:real);
begin
 inc(total);
 save[total].t1:=b;
 save[total].t2:=l;
 save[total].t3:=map[a];
 map[a]:=total;
end;
procedure spfa;
var
 now,next,head,tail,x:longint;
begin
 for i:=1 to sum do
  dist[i]:=100000000;
 dist[1]:=0;
 flag[1]:=true;
 head:=0;
 tail:=1;
 queue[1]:=1;
 while head<>tail do
  begin
   head:=(head mod 100)+1;
   now:=queue[head];
   flag[now]:=false;
   x:=map[now];
   while x<>-1 do
    begin
     next:=save[x].t1;
     if dist[next]>dist[now]+save[x].t2 then
      begin
       dist[next]:=dist[now]+save[x].t2;
       if not(flag[next]) then
        begin
         flag[next]:=true;
         tail:=(tail mod 100)+1;
         queue[tail]:=next;
        end;
      end;
     x:=save[x].t3;
    end;
  end;
end;
function check(i,j:longint):boolean;
var
 l1,l2,k:longint;
 temp,slope,inter:real;
begin
 if i=1 then
  l1:=0
 else
  l1:=(i+2) div 4;
 l2:=(j+2) div 4;
 if l2=l1+1 then
  exit(true);
 slope:=(p[j,2]-p[i,2])/(p[j,1]-p[i,1]);
 inter:=p[i,2]-slope*p[i,1];
 for k:=l1+1 to l2-1 do
  begin
   temp:=slope*data[k,1]+inter;
   if (temp<=data[k,2]) or ((temp>=data[k,3]) and (temp<=data[k,4])) or
      (temp>=data[k,5]) then
    exit(false);
  end;
 exit(true);
end;
begin
 assign(input,'door.in');
 assign(output,'door.out');
 reset(input);
 rewrite(output);
 readln(n);
 fillchar(map,sizeof(map),$ff);
 for i:=1 to n do
  readln(data[i,1],data[i,2],data[i,3],data[i,4],data[i,5]);
 inc(sum);
 p[sum,1]:=0;
 p[sum,2]:=5;
 for i:=1 to n do
  begin
   inc(sum);
   p[sum,1]:=data[i,1];
   p[sum,2]:=data[i,2];
   inc(sum);
   p[sum,1]:=data[i,1];
   p[sum,2]:=data[i,3];
   inc(sum);
   p[sum,1]:=data[i,1];
   p[sum,2]:=data[i,4];
   inc(sum);
   p[sum,1]:=data[i,1];
   p[sum,2]:=data[i,4];
  end;
 inc(sum);
 p[sum,1]:=10;
 p[sum,2]:=5;
 for i:=1 to sum-1 do
  for j:=i+1 to sum do
   begin
    if (i=1) or (((i+2) div 4)<>((j+2) div 4)) then//注意这个点所属的墙的编号为(k+2) div 4，开始傻X了。。。
     begin
      if check(i,j) then
       begin
        len:=sqrt(sqr(p[i,1]-p[j,1])+sqr(p[i,2]-p[j,2]));
        add(i,j,len);
       end;
     end;
   end;
 spfa;
 writeln(dist[sum]:0:2);
end.


```

---

## 作者：Diaоsi (赞：2)

## 题目链接：[传送门](https://www.luogu.com.cn/problem/P1354)
## 思路：
在阅读题目的过程中我们会发现，最短路径一定是一条折线或者是线段，因为两点之间线段最短。也就是说，最短路径会经过墙缺口处的点。

由于这个特殊性质，且起点终点固定，我们可以将问题转换成单元最短路径问题，采用堆优化的 Dijkstra 算法解决。

我们可以将墙缺口处的点作为有向图中的节点，两点之间的距离为边权，在建边之前判断两个点之间是否有被墙体阻拦。

两点之间距离公式：

$$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$

对于判断两个点之间是否有墙体阻拦，我们可以将两个点之间的连线看作一次函数，如果与墙体有交点则无法建边，反之亦然。

设起点为 $(x_1,y_1)$ ，终点为 $(x_2,y_2)$ ，与墙体的交点为 $(x,y)$ 

则斜率 $k$ 为：

$$\frac{y_2-y_1}{x_2-x_1}$$

同理：

$$\frac{y-y_1}{x-x_1}=\frac{y_2-y}{x_2-x}$$

将 $y$ 提出有：

$$y=\frac{xy_2-x_1y_2-xy_1+x_2y_1}{x_2-x_1}$$

至此，我们只需要枚举两个端点之间的墙体并进行判断即可。

## 代 码 放 送：

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$
```cpp
#include<bits/stdc++.h>
#define Max(a,b) (a>b?a:b)
#define Min(a,b) (a<b?a:b)
#define l(a,b,c,d) sqrt((a-c)*(a-c)+(b-d)*(b-d))
using namespace std;
const int N=100010,M=1000010,INF=0x3f3f3f3f;
int head[N],ver[M],Next[M],tot;
double edge[M],d[N];
bool v[N];
int n,cnt=1;
priority_queue< pair<double, int> > q;
struct Point{
	int id;
	double x,y;
}p[N][10];
void add(int x,int y,double z){
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
}
void init(){
	for(int i=1;i<=4;i++)
		p[0][i].x=0,p[0][i].y=5,p[n+1][i].x=10,p[n+1][i].y=5;
	for(int i=1;i<=n;i++){
		cin>>p[i][0].x;
		for(int j=1;j<=4;j++)
			cin>>p[i][j].y,p[i][j].x=p[i][0].x;
	}
	for(int i=1;i<=4;i++)
		p[0][i].id=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=4;j++)
			p[i][j].id=++cnt;
	for(int i=1;i<=4;i++)
		p[n+1][i].id=cnt+1; 
}
bool Check(int i,int j,double sx,double sy,double ex,double ey){
	if(j-i<2)return 1;
	for(int k=i+1;k<j;k++){
		double x=p[k][1].x;
		double y=((x-sx)*ey-(x-ex)*sy)/(ex-sx);
		if(!(y>=p[k][1].y&&y<=p[k][2].y)&&!(y>=p[k][3].y&&y<=p[k][4].y))return 0;
	}
	return 1;
}
void dijkstra(){
	for(int i=1;i<=N;i++)d[i]=INF;
	memset(v,0,sizeof(v));
	d[1]=0;
	q.push(make_pair(0,1));
	while(q.size()){
		int x=q.top().second;q.pop();
		if(v[x])continue;v[x]=1;
		for(int i=head[x];i;i=Next[i]){
			int y=ver[i];
			double z=edge[i];
			if(d[y]>d[x]+z){
				d[y]=d[x]+z;
				q.push(make_pair(-d[y],y));
			}
		}
	}
}
int main(){
	scanf("%d",&n);
	init();
	if(Check(0,n+1,0,5,10,5)){puts("10.00");return 0;}
	for(int i=0;i<=n;i++)
		for(int j=i+1;j<=n+1;j++)
			for(int l1=1;l1<=4;l1++)
				for(int l2=1;l2<=4;l2++)
					if(Check(i,j,p[i][l1].x,p[i][l1].y,p[j][l2].x,p[j][l2].y))
						add(p[i][l1].id,p[j][l2].id,l(p[i][l1].x,p[i][l1].y,p[j][l2].x,p[j][l2].y));
	dijkstra();
	printf("%.2lf\n",d[cnt+1]);
	return 0;
}
```


---

## 作者：VenusM1nT (赞：2)

$\text{DP}$。这道题的迷惑性很强，第一眼看上去像计算几何，仔细观察后可以想出**最短路**的做法，但是计算几何的本质还在，在连边时需要判断中间是否有墙阻挡，不是很好写，但 $\text{DP}$ 则不难想到，且非常好写。

我们设置 $f[i][j]$ 表示 **当前为第 $i$ 堵墙，垂直位置为 $j$ 时的最短路径长度**。显然，垂直位置是一个实数，所以我们将它 $\times100$（由于保留两位小数，所以只保留两位即可），就可以表示了。

在每次转移时，我们从当前这面墙的两个空缺上扫过去，然后从上一面墙的两个空缺上转移过来即可。

为了更方便的转移，我们设开始墙为 $0$ ，结束墙为 $n+1$，空缺为 $(5,5)\ (5,5)$。

伪代码如下。

```cpp
	for i=1 to n+1
        for j=i_a1 to i_b1
            for k=i-1_a1 to i-1_b1
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
            for k=i-1_a2 to i-1_b2
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
        for j=i_a2 to i_b2
            for k=i-1_a1 to i-1_b1
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
            for k=i-1_a2 to i-1_b2
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
```

$\text{TIP : }$ $j$ 和 $k$ 都是实数类型。$i$ 为整型。

初值为全部设为 $\infty$ ，然后把 $f[0]$ 这一维设成 $0$。答案在 $f[n+1][500]$ 的位置。

---

## 作者：散华礼弥 (赞：2)

### 神奇DP

把房高$10$米拆成$2001(0$~$2000)$个点，$dp[i][j]$表示做第$i$堵墙的第$j$个位置的最短路，则起点为$dp[0][1000]=0$，每次先枚举这个墙上的缺口，再枚举上一层两个缺口转移（这是因为两堵墙之间一定可以通过缺口看到的）

然后我们就可以通过上一层的最短路，加上勾股定理求得两点间的直线距离来转移啦，最后答案的就是$dp[n+1][1000]$，点做的时候别忘了要除以$200$

因为想的时候是从后往前着想的，所以dp也是从后往前倒着做的啦，具体细节就看代码吧（看题解里面也有拆成$1000$的，是不是会更快啊qwq）

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>

#define Sqr(x) (x) * (x)
#define Dis(x1, y1, x2, y2) sqrt(Sqr(x1 - x2) + Sqr(y1 - y2))

int n;
double dp[22][2001];

struct Wall
{
	double x, a1, b1, a2, b2;
} a[22];

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
		scanf("%lf%lf%lf%lf%lf", &a[i].x, &a[i].a1, &a[i].b1, &a[i].a2, &a[i].b2);
	a[0].x = 0, a[0].a1 = a[0].b1 = a[0].a2 = a[0].b2 = 5;
	a[++n].x = 10, a[n].a1 = a[n].b1 = a[n].a2 = a[n].b2 = 5;
	memset(dp, 0x4f, sizeof dp);
	dp[n][1000] = 0;
	double a1, a2, b1, b2;
	for (int i = n - 1; i >= 0; --i)
	{
		Wall tmp = a[i];
		a1 = tmp.a1, a2 = tmp.b1;
		for (int j = a1 * 200; j <= a2 * 200; ++j)
		{
			b1 = a[i + 1].a1, b2 = a[i + 1].b1;
			for (int k = b1 * 200; k <= b2 * 200; ++k)
				dp[i][j] = std::min(dp[i][j], Dis(tmp.x, j / 200.0, a[i + 1].x, k / 200.0) + dp[i + 1][k]);
			b1 = a[i + 1].a2, b2 = a[i + 1].b2;
			for (int k = b1 * 200; k <= b2 * 200; ++k)
				dp[i][j] = std::min(dp[i][j], Dis(tmp.x, j / 200.0, a[i + 1].x, k / 200.0) + dp[i + 1][k]);
		}
		a1 = tmp.a2, a2 = tmp.b2;
		for (int j = a1 * 200; j <= a2 * 200; ++j)
		{
			b1 = a[i + 1].a1, b2 = a[i + 1].b1;
			for (int k = b1 * 200; k <= b2 * 200; ++k)
				dp[i][j] = std::min(dp[i][j], Dis(tmp.x, j / 200.0, a[i + 1].x, k / 200.0) + dp[i + 1][k]);
			b1 = a[i + 1].a2, b2 = a[i + 1].b2;
			for (int k = b1 * 200; k <= b2 * 200; ++k)
				dp[i][j] = std::min(dp[i][j], Dis(tmp.x, j / 200.0, a[i + 1].x, k / 200.0) + dp[i + 1][k]);
		}
	}
	printf("%.2lf\n", dp[0][1000]);
	return 0;
}
```

---

## 作者：Liweiz (赞：1)

条件挺多的，改了很多次，加了很多条件判断才改对。
首先这个图的所有点要进行记录，我用的是p数组存一个点的x，y，用d数组来存每一个墙的数据，把所有的点存完之后，从第一个点开始和后面的点比较，判断两点之间是否有墙阻碍，没有就建边，最后由于数据较小，floyed搜一遍结束。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
#include <cmath>
#define inf 0x3f3f3f3f
using namespace std;
int n;
double dis[1005][1005];
struct sa1
{
    double x,a1,b1,a2,b2;
} d[1005];
struct sa2
{
    double x,y;
} p[1005];
int judge(double x1,double y1,double x2,double y2,int p1,int p2)//判断两点之间是否有阻碍
{
    if(x1==x2)return 0;
    else
    {
        double k=(y2-y1)/(x2-x1);//两点间斜率
        for(int i=p1/4+1; i<=(p2-1)/4+1; i++)
        {
            double z=k*(d[i].x-x1)+y1;//两点组成直线在墙处的y值
            if(!((z>=d[i].a1&&z<=d[i].b1)||(z>=d[i].a2&&z<=d[i].b2)))
                return 0;
        }
        return 1;
    }
}
int main()
{
    while(scanf("%d",&n)!=-1)
    {
        int num=0;
        p[num].x=0,p[num].y=5,num++;//起点
        for(int i=1; i<=n; i++)
        {
            scanf("%lf%lf%lf%lf%lf",&d[i].x,&d[i].a1,&d[i].b1,&d[i].a2,&d[i].b2);
            p[num].x=d[i].x,p[num].y=d[i].a1,num++;
            p[num].x=d[i].x,p[num].y=d[i].b1,num++;
            p[num].x=d[i].x,p[num].y=d[i].a2,num++;
            p[num].x=d[i].x,p[num].y=d[i].b2,num++;
        }
        d[n+1].x=10,d[n+1].a1=0,d[n+1].b1=10,d[n+1].a2=10,d[n+1].b2=10;//把最右边的墙看作一次阻碍，否则最后一个点难判断
        p[num].x=10,p[num].y=5;//终点
        for(int i=0; i<=num; i++)
            for(int j=0; j<=num; j++)dis[i][j]=inf;//初始化
        for(int i=0; i<num; i++)
            for(int j=i+1; j<=num; j++)
                if(judge(p[i].x,p[i].y,p[j].x,p[j].y,i,j))
                    dis[i][j]=sqrt((p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));
        for(int i=0; i<=num; i++)
            for(int j=0; j<=num; j++)
                for(int k=0; k<=num; k++)
                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
        printf("%.2lf\n",dis[0][num]);
    }
    return 0;
}


```

---

## 作者：doby (赞：0)

楼下dalao思路很机智，搞出点和路，建图跑最短路……

结果题解的大体思路都在往这方面跑……

可是就我一个人走了弯路……

重点在于处理墙的几个隔开的点连出的边是否会和其他的墙相撞的问题……

大量的代码都在处理这个问题，实在浪费啊……

处理出一个之后后面都是ctrl+c与ctrl+v再带上一些微小的修改了……

但是其实放到循环和函数里之后代码量会迅速减少……

-------------------------------------------分割线-------------------------------------------

起点终点和每堵墙的a1,b1,a2,b2都看做点

首先赋点，这个随意了，能出结果就行

然后最坑的就是判任意两点间

首先是起点终点，能连上就不用继续了，直接输出10.00

然后起点终点和1-n的a1,a2,b1,b2

最后1-n任意两点还要连……

这个就用类似一次函数的方法，看一下当连的边与当前的墙所在直线相交的点是否是墙

边权也挺好求的，baidu两点间距离公式就好了……

最后最短路，dijkstra+优先队列(可有可无)

想要更详细一点的可以看楼下那位的代码

```cpp
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
int n,count=2,cnt=0,pd,p,q,n1[30],n2[30],n3[30],n4[30],head[10010];
float xx,yy,x[30],a1[30],a2[30],b1[30],b2[30],dis[10010];
bool done[10010];
struct Edge//图
{
    int to,next;
    float dis;
}e[10010];
struct Heap
{
    int id;
    float dis;
    bool operator<(const Heap &h1)const
    {
        return dis>h1.dis;
    }
};
void add(int x,int y,float z)//连边
{
```
cnt++,
```cpp
    e[cnt].next=head[x],
    e[cnt].to=y,
    e[cnt].dis=z,
    head[x]=cnt;
}
void Dijkstra(int s)//dijkstra+优先队列优化(其实点很少，优化可有可无)
{
    priority_queue<Heap> h;
    for(int i=1;i<=count;i++){dis[i]=2333333.000;}
    dis[s]=0;
    Heap x;
    x.dis=0,x.id=s;
    h.push(x);
    while(!h.empty())
    {
        x=h.top();
        h.pop();
        p=x.id;
        if(done[p]){continue;}
        done[p]=1;
        for(int i=head[p];i!=0;i=e[i].next)
        {
            q=e[i].to;
            if(dis[p]+e[i].dis<dis[q])
            {
                dis[q]=dis[p]+e[i].dis,
                x.dis=dis[q],
                x.id=q;
                h.push(x);
            }
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){scanf("%f%f%f%f%f",&x[i],&a1[i],&a2[i],&b1[i],&b2[i]);}
    for(int i=1;i<=n;i++)
    {
        n1[i]=count,count++,
        n2[i]=count,count++,
        n3[i]=count,count++,
        n4[i]=count,count++;//顶点标号，出发点为1，结束点即为最后的count的值
    }
    pd=0;//如果能直接到就不用跑一遍图了
    for(int i=1;i<=n;i++)
    {
        if(!((a1[i]<=5.000&&a2[i]>=5.000)||(b1[i]<=5.000&&b2[i]>=5.000))){pd++;break;}
    }
    if(!pd)
    {
        printf("10.00");
        return 0;
    }
    for(int i=1;i<=n;i++)//起点终点分别和每个点链接，不具体做解释了
    {
        pd=0;
        for(int j=1;j<i;j++)
        {
            xx=x[j],yy=((a1[i]-5.000)/x[i])*x[j]+5.000;//类似一次函数的方法，处理出纵坐标，有点麻烦
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(1,n1[i],sqrt(x[i]*x[i]+abs(a1[i]-5.000)*abs(a1[i]-5.000)));
            add(n1[i],1,sqrt(x[i]*x[i]+abs(a1[i]-5.000)*abs(a1[i]-5.000)));
        }
        pd=0;
        for(int j=1;j<i;j++)
        {
            xx=x[j],yy=((a2[i]-5.000)/x[i])*x[j]+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(1,n2[i],sqrt(x[i]*x[i]+abs(a2[i]-5.000)*abs(a2[i]-5.000)));
            add(n2[i],1,sqrt(x[i]*x[i]+abs(a2[i]-5.000)*abs(a2[i]-5.000)));
        }
        pd=0;
        for(int j=1;j<i;j++)
        {
            xx=x[j],yy=((b1[i]-5.000)/x[i])*x[j]+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(1,n3[i],sqrt(x[i]*x[i]+abs(b1[i]-5.000)*abs(b1[i]-5.000)));
            add(n3[i],1,sqrt(x[i]*x[i]+abs(b1[i]-5.000)*abs(b1[i]-5.000)));
        }
        pd=0;
        for(int j=1;j<i;j++)
        {
            xx=x[j],yy=((b2[i]-5.000)/x[i])*x[j]+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(1,n4[i],sqrt(x[i]*x[i]+abs(b2[i]-5.000)*abs(b2[i]-5.000)));
            add(n4[i],1,sqrt(x[i]*x[i]+abs(b2[i]-5.000)*abs(b2[i]-5.000)));
        }
        pd=0;
        for(int j=n;j>i;j--)
        {
            xx=x[j],yy=((a1[i]-5.000)/(10.000-x[i]))*(10.000-x[j])+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(count,n1[i],sqrt((10.000-x[i])*(10.000-x[i])+abs(a1[i]-5.000)*abs(a1[i]-5.000)));
            add(n1[i],count,sqrt((10.000-x[i])*(10.000-x[i])+abs(a1[i]-5.000)*abs(a1[i]-5.000)));
        }
        pd=0;
        for(int j=n;j>1;j--)
        {
            xx=x[j],yy=((a2[i]-5.000)/(10.000-x[i]))*(10.000-x[j])+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(count,n2[i],sqrt((10.000-x[i])*(10.000-x[i])+abs(a2[i]-5.000)*abs(a2[i]-5.000)));
            add(n2[i],count,sqrt((10.000-x[i])*(10.000-x[i])+abs(a2[i]-5.000)*abs(a2[i]-5.000)));
        }
        pd=0;
        for(int j=n;j>1;j--)
        {
            xx=x[j],yy=((b1[i]-5.000)/(10.000-x[i]))*(10.000-x[j])+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(count,n3[i],sqrt((10.000-x[i])*(10.000-x[i])+abs(b1[i]-5.000)*abs(b1[i]-5.000)));
            add(n3[i],count,sqrt((10.000-x[i])*(10.000-x[i])+abs(b1[i]-5.000)*abs(b1[i]-5.000)));
        }
        pd=0;
        for(int j=n;j>1;j--)
        {
            xx=x[j],yy=((b2[i]-5.000)/(10.000-x[i]))*(10.000-x[j])+5.000;
            if(!((yy>=a1[j]&&yy<=a2[j])||(yy>=b1[j]&&yy<=b2[j]))){pd++;break;}
        }
        if(!pd)
        {
            add(count,n4[i],sqrt((10.000-x[i])*(10.000-x[i])+abs(b2[i]-5.000)*abs(b2[i]-5.000)));
            add(n4[i],count,sqrt((10.000-x[i])*(10.000-x[i])+abs(b2[i]-5.000)*abs(b2[i]-5.000)));
        }
    }
    for(int i=2;i<=n;i++)//中间的点两两链接，不多做解释了
    {
        for(int j=i-1;j<i;j++)//绝对不能是同一堵墙上的点啊，这就没意义了
        {
            if(i!=j)
            {
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a1[i]-a1[j])/(x[i]-x[j]))*(x[i]-x[k])+a1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n1[i],n1[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-a1[j])*abs(a1[i]-a1[j])));
                    add(n1[j],n1[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-a1[j])*abs(a1[i]-a1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a1[i]-a2[j])/(x[i]-x[j]))*(x[i]-x[k])+a2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n1[i],n2[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-a2[j])*abs(a1[i]-a2[j])));
                    add(n2[j],n1[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-a2[j])*abs(a1[i]-a2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a1[i]-b1[j])/(x[i]-x[j]))*(x[i]-x[k])+b1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n1[i],n3[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-b1[j])*abs(a1[i]-b1[j])));
                    add(n3[j],n1[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-b1[j])*abs(a1[i]-b1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a1[i]-b2[j])/(x[i]-x[j]))*(x[i]-x[k])+b2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n1[i],n4[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-b2[j])*abs(a1[i]-b2[j])));
                    add(n4[j],n1[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a1[i]-b2[j])*abs(a1[i]-b2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a2[i]-a1[j])/(x[i]-x[j]))*(x[i]-x[k])+a1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n2[i],n1[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-a1[j])*abs(a2[i]-a1[j])));
                    add(n1[j],n2[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-a1[j])*abs(a2[i]-a1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a2[i]-a2[j])/(x[i]-x[j]))*(x[i]-x[k])+a2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n2[i],n2[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-a2[j])*abs(a2[i]-a2[j])));
                    add(n2[j],n2[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-a2[j])*abs(a2[i]-a2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a2[i]-b1[j])/(x[i]-x[j]))*(x[i]-x[k])+b1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n2[i],n3[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-b1[j])*abs(a2[i]-b1[j])));
                    add(n3[j],n2[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-b1[j])*abs(a2[i]-b1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((a2[i]-b2[j])/(x[i]-x[j]))*(x[i]-x[k])+b2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n2[i],n4[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-b2[j])*abs(a2[i]-b2[j])));
                    add(n4[j],n2[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(a2[i]-b2[j])*abs(a2[i]-b2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b1[i]-a1[j])/(x[i]-x[j]))*(x[i]-x[k])+a1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n3[i],n1[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-a1[j])*abs(b1[i]-a1[j])));
                    add(n1[j],n3[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-a1[j])*abs(b1[i]-a1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b1[i]-a2[j])/(x[i]-x[j]))*(x[i]-x[k])+a2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n3[i],n2[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-a2[j])*abs(b1[i]-a2[j])));
                    add(n2[j],n3[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-a2[j])*abs(b1[i]-a2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b1[i]-b1[j])/(x[i]-x[j]))*(x[i]-x[k])+b1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n3[i],n3[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-b1[j])*abs(b1[i]-b1[j])));
                    add(n3[j],n3[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-b1[j])*abs(b1[i]-b1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b1[i]-b2[j])/(x[i]-x[j]))*(x[i]-x[k])+b2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n3[i],n4[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-b2[j])*abs(b1[i]-b2[j])));
                    add(n4[j],n3[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b1[i]-b2[j])*abs(b1[i]-b2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b2[i]-a1[j])/(x[i]-x[j]))*(x[i]-x[k])+a1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n4[i],n1[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-a1[j])*abs(b2[i]-a1[j])));
                    add(n1[j],n4[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-a1[j])*abs(b2[i]-a1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b2[i]-a2[j])/(x[i]-x[j]))*(x[i]-x[k])+a2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n4[i],n2[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-a2[j])*abs(b2[i]-a2[j])));
                    add(n2[j],n4[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-a2[j])*abs(b2[i]-a2[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b2[i]-b1[j])/(x[i]-x[j]))*(x[i]-x[k])+b1[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n4[i],n3[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-b1[j])*abs(b2[i]-b1[j])));
                    add(n3[j],n4[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-b1[j])*abs(b2[i]-b1[j])));
                }
                pd=0;
                for(int k=j+1;k<i;k++)
                {
                    xx=x[k],yy=((b2[i]-b2[j])/(x[i]-x[j]))*(x[i]-x[k])+b2[j];
                    if(!((yy>=a1[k]&&yy<=a2[k])||(yy>=b1[k]&&yy<=b2[k]))){pd++;break;}
                }
                if(!pd)
                {
                    add(n4[i],n4[j],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-b2[j])*abs(b2[i]-b2[j])));
                    add(n4[j],n4[i],sqrt((x[i]-x[j])*(x[i]-x[j])+abs(b2[i]-b2[j])*abs(b2[i]-b2[j])));
                }
            }
        }
    }
    Dijkstra(1);
    printf("%.2f\n",dis[count]);
    return 0;
}
```

---


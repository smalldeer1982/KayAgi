# 无线电测向

## 题目描述

有天线定位装置的船能通过接收当地灯塔信号来确定自己的位置。每个灯塔固定在已知点上并发出特有的信号。当船检测到信号，它可通过旋转天线直到信号达到最大强度。这样就可确定自身与该灯塔的位置关系。只要接收到两个灯塔的信息，就有可能确定船当前的位置。

编程任务：通过一对灯塔信息来确定船的位置。

灯塔和船的位置被确定在一个直角坐标系内。$x$ 轴正向指向东，$y$ 轴正向指向北。船的航行路线从正北开始按顺时针用度表示。北是 $0^\circ$，东是 $90^\circ$，南是 $180^\circ$，西是 $270^\circ$。灯塔与船的位置关系用相对于船的航行方向顺时针用度表示。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 30$，灯塔名称是 $20$ 个以下的字母。


## 样例 #1

### 输入

```
5
a 1 5
b 1 1000
c 2 4
d 51 60
e 153 79
30
e 160
d 210```

### 输出

```
160.83 123.41```

# 题解

## 作者：_MRCMRC_ (赞：10)

## 计算几何~~水~~好题
### 读明题意后，我们可以画出以下这张图(借用样例说明)：

![](https://cdn.luogu.com.cn/upload/pic/56607.png)

##### (其中，蓝色的直线为船的航线所在的直线
##### 紫色与红色为灯塔相对于船的方位)

## 不难看出，其实就是已知两条直线，求出直线的交点，即为船当前的位置！！

#### 由平面几何中直线的定义，我们知道，对于函数$f(x)$，它有一种形式叫做点斜式；
#### 然后根据斜率的定义，我们可以求得一条直线的斜率可以以两个直线上的点的坐标决定：
#### 那么则有：
$$ tanα=\frac{y_1-y}{x_1-x} $$
$$ (x_1-x)\cdot tanα=y_1-y  $$
$$ y=y_1-(x_1-x)\cdot tanα  $$

#### 将$y$分别由$x_1$，$y_1$，$x_2$，$y_2$表示得：

$$ \left\{\begin{matrix}y=y_1-(x_1-x)\cdot tan\alpha &\\y=y_2-(x_2-x)\cdot tan\beta &\end{matrix}\right. $$

#### 联立，得：
$$ y_1-(x_1-x)=y_2-(x_2-x) $$

#### 移项，得：
$$ y_1-x_1tan\alpha+xtan\alpha=y_2-x_2tan\beta+xtan\beta $$
$$ x(tan\alpha-tan\beta)=y_2-y_1+x_1tan\alpha-x_2tan\beta$$
$$ x=\frac{y_2-y_1+x_1tan\alpha-x_2tan\beta}{tan\alpha-tan\beta}$$
##### 所以，我们只需要对于每条直线，处理出它们的斜率(即$tan\alpha$，$\alpha$为直线与$x$轴倾斜角)

 我们知道，题目给出的是航线与直线的夹角，而航线的方位是相对于$y$轴的夹角：
#### 我们只需要求得该夹角的余角，即$90^{\circ}-\theta$($\theta$为给出的夹角)。
 同时，对于直线的倾斜角，我们处理它对于$x$轴的夹角时，是允许存在第四象限角的，即斜率为负。
### 所以我们这样处理：

```cpp
double beta=180-an-an2;

```
 其中$an$为航线的倾斜角，$an1$，$an2$分别表示两条位置所在的直线的夹角；

另外，当两直线斜率相同，则无解。
# 完整代码：
```cpp
#include<bits/stdc++.h>
#define in inline
#define reg register
#define int long long
#define MAX 20030813
#define pi acos(-1)
using namespace std;
namespace qwq{
	in int read(int &o)
	{
		o=0;
		int w=1;
		char c=getchar();
		while(c<'0'||c>'9')
		{
			if(c=='-')w=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9')
		{
			o=(o<<3)+(o<<1)+(c^48);
			c=getchar();
		}
		return o*w;
	}
	in void write(int x)
	{
    	if(x>9)write(x/10);
    	putchar(x%10+48);
	}
	in int max(int x,int y)
	{
		return x>y?x:y;
	}
	in int min(int x,int y)
	{
		return x<y?x:y;
	}
}
using namespace qwq;
int n;
class Tower
{
public:
	int x,y;
	char cnt;
}tow[MAX];
char c1,c2;
double _x1_,_x2_,_y1_,_y2_,x,y;
int alpha,beta,an,an1,an2;
signed main()
{
	read(n);
	for(reg int i=1;i<=n;++i)
	{
		cin>>tow[i].cnt;
		read(tow[i].x),read(tow[i].y);
	}
	read(an);
	an-=90;
	cin>>c1,read(an1);
	alpha=180-an-an1;
	cin>>c2,read(an2);
	beta=180-an-an2;  
        if(tan(pi/180*alpha)==tan(pi/180*beta))
        {
        	puts("NO ANSWER");return 0;
        }
	for(reg int i=1;i<=n;++i)
	{
		if(c1==tow[i].cnt)_x1_=tow[i].x,_y1_=tow[i].y;
		if(c2==tow[i].cnt)_x2_=tow[i].x,_y2_=tow[i].y;
	}
	x=((_y2_-_y1_)+_x1_*tan(pi/180*alpha)-_x2_*tan(pi/180*beta))/(tan(pi/180*alpha)-tan(pi/180*beta));
	y=_y1_+(x-_x1_)*tan(pi/180*alpha);
	printf("%.2lf %.2lf\n",x,y);
	return 0;
}
```
#### 在楼上两篇大佬的题解里，对于灯塔位置的映射是用$map$实现的，然而此题灯塔数量$n\leq30$，在下认为是不需要$map$的，直接 $\Theta (n)$扫描不就好啦？
## 若路过大佬在此停留，指点一二，蒟蒻不胜感激

Update in 19.8.15：感谢@RsXxy对于本文错误的指正。


---

## 作者：NXYorz (赞：7)

[题目连接](https://www.luogu.com.cn/problem/P2013)

终于找到一道题可以练习自己的~~LaTeX~~计算几何能力啦。

首先发现这么多灯塔实际上之后最后那两条是我们所关心的emmmm

对于笛卡尔坐标系上的一条直线，如果知道该直线的斜率$k$并且和任意两点$(x_0,y_0)$。就可以把这条直线表示为$l:y-y_0=k\times (x-x_0)$

给它变形一下：$l:y=k\times x+(y_0-k\times x_0)$

那么我们就可以直接求出来这两条直线啦！$l_1:y=k_1\times x+(y_1-k_1\times x_1),l_2:y=k_2\times x+(y_2-k_2\times x_2)$

求这两条直线的交点，联立一下，先把$x$解出来：
$x=\frac{y_2-y_1+k_1\times x_1-k_2\times x_2}{k_1-k_2}$

最后把$x$带入任意一条直线即可。

---------

但是实现起来小细节较多，例如：

- 如果比较懒，可以先把所有的度数统一成我们习惯的$x$轴，当然不统一貌似应该也没什么影响。

- 如果求斜率要调用```cmath```的话，要注意斜率不存在的情况，并且要统一成弧度制。

- 不存在的情况貌似就是三点共线的时候。

### $Code$

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<map>

using namespace std;

const double pi = 3.1415926535;

int n;
double x,y,dir,k[3];
string id[3];
map<string , int> q;

struct Boat
{
	double x;
	double y;
	string name;
}b[31];

void Turn(double &x)
{
	if(x <= 90) x = 90 - x;
	else x = 360 - (x - 90);
}

void cl(int A , int B)
{
	int num1 = q[id[A]] , num2 = q[id[B]];
	x = b[num2].x; y = k[A] * x + (b[num1].y - k[A] * b[num1].x);
	printf("%.2lf %.2lf",x,y);
}

int main()
{
	freopen("aa.in","r",stdin);
	scanf("%d",&n);
	for(int i = 1; i <= n; i++)
		cin>>b[i].name>>b[i].x>>b[i].y , q[b[i].name] = i;
	cin>>dir;
	for(int i = 1; i <= 2; i++)
	{
		cin>>id[i]>>k[i];
		k[i] += dir;Turn(k[i]);
		if(k[i] != 90) k[i] = tan(k[i] * pi / 180);
	}
	if(k[1] == k[2]) {printf("NO ANSWER");return 0;}
	if(k[1] == 90 || k[2] == 90)
	{
		if(k[1] == 90) cl(2 , 1);
		else cl(1 , 2);
		return 0;
	}
	int num1 = q[id[1]] , num2 = q[id[2]];
	x = (b[num2].y - b[num1].y + k[1] * b[num1].x - k[2] * b[num2].x) / (k[1] - k[2]);
	y = k[1] * x + (b[num1].y - k[1] * b[num1].x);
	printf("%.2lf %.2lf",x,y); return 0;
}
```

---

## 作者：Leap_Frog (赞：4)

### P.S.
计算几何思博题，随机跳题跳到的。  
这篇题解可以帮你迅速提高语文成绩（大雾  
实在很抱歉不方便使用画图工具，于是，下面全是干货。  

### Problem.
给你$n$个灯塔，然后其中选出两个灯塔，用这两个灯塔确定出船的位置。  
具体测定位置方法参见中文的题面。  

### Tags.
- 字典树（大雾
- 后缀自动机（弥天大雾
- 字符串Hash（超大雾
- 初中数学知识
- 基本C++语言

### Solution.
首先，我们发现，真正确定船的位置的只有两个灯塔。  
那么其他的灯塔都不需要考虑。  

然后，船相对于灯塔的前进方向为船的前进方向和船到灯塔连线的夹角（有方向。  
那么就很思博了。  

对于一个灯塔，它与船的连线的和正北方向直线的交角为船前进方向夹角与正北方向直线夹角和船前进方向夹角和船和灯塔的连线的夹角之和。（于是，笔者被绕晕了![](https://upload.orzsiyuan.com/images/emotions/kel.png)  
对于一个灯塔，[(它与船的连线)和(正北方向直线)的交角]为[(船前进方向夹角)与（正北方向直线)的夹角]和[(船前进方向)和(船和灯塔的连线)的夹角]之和。  

同时，(一条直线在顺时针旋转方向下和正北方向的夹角)与(一条直线在逆时针旋转方向下和正东方向的夹角)之和为450。（这个感性理解或者打个表就能证明  

同时，初中知识告诉我们，一条直线的斜率是这条直线和正东方向（即x轴正方向）夹角的$\tan$。  

于是我们就得到了两条直线的斜率。  
同时我们又知道这两条直线经过两个点，这样我们就能求出这两条直线的解析式。  
我们求出这两条直线的交点，交点即为船的位置。  

最后别忘了特判一下两条直线平行的情况（即分母为0的情况。  

完结散花，剩下的直接看代码。  

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;const double pi=3.1415926535;
map<string,pair<double,double> >m;int n,d,d1,d2;string s;pair<double,double>a1,a2;
int main()
{
	ios::sync_with_stdio(false),cin>>n;double x,y;//读入
	for(int i=1;i<=n;i++) cin>>s>>x>>y,m[s]=make_pair(x,y);//读入灯塔位置
	cin>>d>>s>>d1,a1=m[s],cin>>s>>d2,a2=m[s],(d1+=d)%=360,(d2+=d)%=360;//读入关键的两个灯塔位置
	if(d1==d2||d1+180==d2||d2+180==d1) return puts("NO ANSWER"),0;else d1=(450-d1)%360,d2=(450-d2)%360;//特判是否平行，然后变成与东方的夹角
	double k1=tan(d1*pi/180),b1=a1.second-k1*a1.first;//求出第一个直线的解析式为y=k1*x+b1
	double k2=tan(d2*pi/180),b2=a2.second-k2*a2.first;//求出第二个直线的解析式为y=k2*x+b2
	x=(b1-b2)/(k2-k1),y=k1*x+b1;//解上面的方程组，求出交点坐标（初中数学知识
	return printf("%.2lf %.2lf\n",x,y),0;//输出答案，完结撒花
}
```

---

## 作者：SyntaxErr0r (赞：1)

##### ~~复习一下高中数学直线联立~~

[P2013 无线电测向](https://www.luogu.com.cn/problem/P2013)
#### ~~翻译~~题意

在平面直角坐标系上，给出目标点的朝向角度与 $n$ 个点的坐标，再针对某两个点给出一些~~诡异的数据~~，分别获取两点与目标点所成直线的倾斜角。求两直线交点坐标。

#### 分析

##### Section 1

首先，以目标点为研究对象。已知给出了目标点的朝向角度 $\alpha_1$。需要注意的是，朝向角度 $\alpha_1$ 是绕 $y$ 轴正半轴旋转的角度，于是我们需要把 $\alpha_1$ 转换为朝向与 $x$ 轴的夹角 $\alpha$。

感性理解一下，因为 $\alpha$ 的增加方向（逆时针）与 $\alpha_1$ 的增加方向（顺时针）相反，且 $\alpha_1$ 的相对初始值比 $\alpha$ 大 $90\degree(\angle xOy=90\degree)$，所以可以粗糙地得出以下推导：~~（其实脑内打表也可~~
$$
\alpha = 90\degree-\alpha_1
$$

##### Section 2

再对给定的两个点为研究对象。其实有了第一步的分析，下面就不难了。设两点分别与目标点确定的直线为 $l_1,l_2$，又给定了两条直线与目标点朝向的到角 $\beta_1,\beta_2$，容易计算 $l_1,l_2$ 与 $x$ 轴的夹角。若夹角相等，则说明没有交点，输出 `NO ANSWER` 。
$$
\theta_1 = \alpha-\beta_1,\quad\theta_2=\alpha-\beta_2
$$
进一步，斜率也可以确定。需要注意的是，`c++` 自带的 `tan()` 接受参数为弧度制，所以还要手动转换一下：$1\degree = \pi/180$。
$$
k_1 = \tan(\theta_1),\quad k_2 = \tan(\theta_2)
$$
现在我们有了两直线的斜率与直线上一点，可以采用点斜式联立求交点。设两点为 $a(x_1,y_1),b(x_2,y_2)$。有
$$
\begin{cases}{}
y-y_1=k_1(x-x_1) \\
y-y_2=k_2(x-x_2)
\end{cases}
$$
两式相减，有 $y_2-y_1=(k_1-k_2)x-k_1x_1+k_2x_2$。

整理得
$$
x = \frac{y_2-y_1-k_2x_2+k_1x_1}{k_1-k_2}
$$
带入回 $(1)$ 式，有 $y=k_1(x-x_1)+y_1$。

输出 `x y` 即可。注意 $\pi$ 的精度选取和输出精度保留。

#### $Code$

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;

const double pi = 3.1415926535; // 建议选取较高精度
int n;
map<string,pii> mp;

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        int x, y;
        string name;
        cin >> name >> x >> y;
        mp.insert(make_pair(name,make_pair(x,y)));
    }
    string s1, s2;
    double angleShip, angle1, angle2;
    cin >> angleShip;
    angleShip = 90-angleShip; // 转化为与 x 轴的夹角
    cin >> s1 >> angle1;
    cin >> s2 >> angle2;
    double x1 = mp[s1].first, y1 = mp[s1].second;
    double x2 = mp[s2].first, y2 = mp[s2].second;
    angle1 = 1.0*(angleShip-angle1)*pi/180; // x 轴夹角转换与弧度制转换
    angle2 = 1.0*(angleShip-angle2)*pi/180;
    if (angle1 == angle2) { // 判断夹角
        cout << "NO ANSWER";
        return 0;
    }
    double k1 = tan(angle1), k2 = tan(angle2); // 计算斜率，传参弧度制
    double x = (y2-y1-k2*x2+k1*x1)/(k1-k2); // 套上述结论
    double y = k1*(x-x1)+y1;
    printf("%.2lf %.2lf",x,y); // 保留两位小数
    return 0;
}

```



---

## 作者：Microperson (赞：1)

# 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P2013)
# 腐朽的思路
当你上高中时，你会学到直线的方程，点斜式（知道倾斜角，和某个点就可以求直线方程），当直线方程求出后，就可以联立两个方程求交点了。注意当斜率相等时就没有交点（两直线平行）。
# 新鲜出炉的code：
```
#include<iostream>
#include<cstdio>
#include<cmath>
#define PI 3.1415926535897932384626433832795
using namespace std;
int n,dian1,dian2;
int aerf,jiao1,jiao2;
double x,y,cnt1,cnt2;
string a,b;

struct zhs{
	string s;
	double x,y;
}t[1000010];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>t[i].s>>t[i].x>>t[i].y;
	}
	cin>>aerf;
	cin>>a>>jiao1;
	cin>>b>>jiao2;
	for(int i=1;i<=n;i++)
	{
		if(t[i].s==a) dian1=i,cnt1=tan(((270-jiao1-aerf)*PI)/180);
		if(t[i].s==b) dian2=i,cnt2=tan(((270-jiao2-aerf)*PI)/180);
	}
	if(cnt1==cnt2) cout<<"NO ANSWER"<<endl;
	x=1.0*(t[dian1].y-t[dian2].y+cnt2*t[dian2].x-cnt1*t[dian1].x)/(cnt2-cnt1);
	y=(cnt1*(x-t[dian1].x))+t[dian1].y;
	printf("%.2lf %.2lf",x,y);
}
```


---

## 作者：Mingoal (赞：1)

人生中A的第一道CTSC难度的题

其实这题的本质就是计算几何，求两直线的交点，并不难

···cpp

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long double ld;//long double 精度高一点，当然这题并不需要这么高的精度
const ld pi=acos(-1.0);//acos是cos的反函数，因为cos(pi)=-1，所以acos(-1)=pi
struct kk{
    int x,y;
}x;
map<string,kk>ha;//映射，把灯塔名称映射成灯塔方位
string s;
int n,m,i,an;
ld b1,b2,k1,k2,xx,yy;
ld f(int an){
    an=(an+m+180)%360;
//把灯塔相对于船的位置转化成船相对于灯塔的位置
//这样便于计算两直线的交点
    if (an<90) an=90-an;
    else an=450-an;
//把题目中的角度定义转化成数学中的定义
//题目：y轴的非负半轴为始边，顺时针旋转
//数学：x轴的非负半轴为始边，逆时针旋转
    return tan(an*pi/180);//这里要把角度转化为弧度，然后计算直线的斜率=tan(x)
}
int main(){
    cin>>n;
    for (i=1;i<=n;i++) cin>>s,scanf("%d%d",&x.x,&x.y),ha[s]=x;
    cin>>m;
    cin>>s>>an;
    k1=f(an);
    b1=ha[s].y-ha[s].x*k1;
//因为y0=kx0+b，所以b=y0-k*x0
    cin>>s>>an;
    k2=f(an);
    b2=ha[s].y-ha[s].x*k2;
    if (k1==k2) printf("NO ANSWER");
//因为两直线斜率相同，所以两直线要么重合要么没有交点
//而且这时k1-k2=0，除不了
    else{
        xx=(b2-b1)/(k1-k2);
//设相交的点为(xx,yy)，该点同时满足yy=k1*xx+b1和yy=k2*xx+b2
//解得xx=(b2-b1)/(k1-k2)
        yy=k1*xx+b1;
//把xx的值代入
        printf("%.2Lf %.2Lf",xx,yy);//用printf()输出long double时要注意"l"要大写（这题没事）
    }
}
```
```cpp

---

## 作者：laialaodi (赞：0)

# P2013 无线电测向

题目省流：求两条直线交点坐标

使用样例数据作出下图：

![](https://cdn.luogu.com.cn/upload/pic/56607.png)

（图片来自@\_MRCMRC\_）

图中红线和紫线为灯塔与船的连线，蓝线为船的航线。

由输入可以知道灯塔 A、B 相对于 $x$ **正半轴**的角度 $\theta_A$、$\theta_B$**（逆时针方向）** 和它们分别的坐标 $(x_A, y_A)$、$(x_B, y_B)$。

设灯塔 A 与船的连线为 $l_1: y = k_Ax + b_A$，灯塔 B 与船的连线为 $l_2: y = k_Bx + b_B$。

我们用待定系数法，先用 $\tan$ 求出 $k_A$，有

$$k_A = \frac{\Delta y}{\Delta x} = \tan \theta_A$$

再代入 $x = x_A, y = y_A$，解一元一次方程

$$y = k_Ax + b_A$$
$$\to y_A = k_Ax_A + b_A$$
$$\to b_A = y_A - k_Ax_A$$

所以得出 $l_1$ 的表达式 $y = k_Ax + b_A$（这里 $k_A$ 和 $b_A$ 已求得）。

同理，我们可以求出 $l_2$ 的表达式 $y = k_Bx + b_B$，其中 $k_B = \tan \theta_B$，$b_B = y_B - k_Bx_B$。

接下来求交点坐标，因为交点既在 $l_1$ 上也在 $l_2$ 上，所以联立两个表达式得出方程：

$$

    \left\{
        \begin{array}{ll}
            y = k_Ax + b_A \textcircled{1}\\
            y = k_Bx + b_B \textcircled{2}
        \end{array}
    \right.

$$

$\textcircled{2} - \textcircled{1}$：

$$b_A - b_B = (k_B - k_A)x$$

解得

$$

    \left\{
        \begin{array}{ll}
            x = \frac{b_A - b_B}{k_B - k_A}\\
            y = k_Ax + b_A
        \end{array}
    \right.

$$

求得交点 $(x, y)$，即船的坐标。

**还有记得转弧度制！！！**

AC Code:

```cpp
#include <bits/stdc++.h>

using namespace std;

const double pi = 3.1415926535;

struct beacon // 灯塔
{
    string name;
    double x, y;
};

int main()
{
    int n;
    cin >> n;
    beacon a[n];
    for (int i = 0; i < n; ++i)
    {
        cin >> a[i].name >> a[i].x >> a[i].y;
    }
    double ship_angle, angle1, angle2;
    beacon beacon1, beacon2;
    cin >> ship_angle >> beacon1.name >> angle1 >> beacon2.name >> angle2;
    for (int i = 0; i < n; ++i)
    {
        if (a[i].name == beacon1.name)
        {
            beacon1 = a[i];
        }
        if (a[i].name == beacon2.name)
        {
            beacon2 = a[i];
        }
    }
    angle1 += ship_angle;
    angle2 += ship_angle;

    double k1 = tan((90 - angle1) * pi / 180);
    double b1 = beacon1.y - k1 * beacon1.x;
    double k2 = tan((90 - angle2) * pi / 180);
    double b2 = beacon2.y - k2 * beacon2.x;

    double x = (b2 - b1) / (k1 - k2);
    double y = k1 * x + b1;
    printf("%.2lf %.2lf", x, y);
    return 0;
}
```

---

## 作者：Eltaos_xingyu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2013)

难度不大的一道计算几何题。具体来说就是通过斜率加一个点求直线解析式，然后两直线求交点就行了。

用一个 `unordered_map` 记录灯塔的名称，然后找到要询问的两个灯塔。

浅推一下算斜率的式子：

$$
k=\tan(\text{直线的极角})=\tan((180\degree-(\alpha_{\text{灯塔}}+\alpha_{\text{船}}-90\degree))\times\frac{\pi}{180\degree})
$$

然后将原来的点带入斜率得到直线，最后求两直线交点即可。

注意斜率相等时要输出 `NO ANSWER`。

代码：

```cpp
#include<bits/stdc++.h>
#define ld long double
const ld Pi=acos(-1);
using namespace std;
unordered_map<string,pair<int,int> > mp;
int main()
{
	ios::sync_with_stdio(false);
	string s,s1,s2;
	int n,x,y;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s>>x>>y;
		mp[s]=make_pair(x,y);
	}
	int tangle,t1,t2;
	cin>>tangle;
	cin>>s1>>t1>>s2>>t2;
	ld _x_1=mp[s1].first;
	ld _y_1=mp[s1].second;
	ld _x_2=mp[s2].first;
	ld _y_2=mp[s2].second;
	ld k1=tan(1.0*(180-(tangle+t1-90))/180*Pi);
	ld k2=tan(1.0*(180-(tangle+t2-90))/180*Pi);
//	cout<<k1<<" "<<k2<<" "<<(180-(tangle+t1-90))<<" "<<(180-(tangle+t2-90))<<endl;
	if(k1==k2){
		cout<<"NO ANSWER";
		return 0;
	}
	ld xx=(_y_2-_y_1+_x_1*k1-_x_2*k2)/(k1-k2);
	ld yy=k1*(xx-_x_1)+_y_1;
	cout<<fixed<<setprecision(2)<<xx<<" "<<yy; 
	return 0;
}
```

---

## 作者：cyx20080216 (赞：0)

## 题目分析
读完题后，很容易就能看出来，这道题的核心是**求两直线交点**

在这之前，我们要先算出这两条直线

显然，这两条直线是给定的两座灯塔与船的连线（~~废话~~），可惜我们不知道船的位置

我们虽然不知道船的具体位置，但是题目给了我们足以算出船相对与灯塔的方向的信息。所以，我们可以在这个方向或是反方向上取任意一点，因为**同一直线上取任意两点计算得到的直线都是原直线**
## 具体步骤如下
这里以灯塔1为例

我们用斜截式 $y=ax+b$ 表示该直线

用 $x_{Light}$ 和 $y_{Light}$ 表示灯塔1的坐标

用 $\theta_{Boat}$ 表示船的航向

用 $\theta_{BoatToLight}$ 分别表示以船的航向为 $0^{\circ}$ 下的灯塔相对于船的方向

用 $\theta_{LightToBoat}$ 分别表示的船相对于灯塔的方向

用 $x_{FrontOfLight}$ 和 $y_{FrontOfLight}$ 表示位于灯塔1 $\theta_{LightToBoat}$ 方向1单位长度的点的坐标

画画图就可以轻易推出 $\theta_{LightToBoat}=\theta_{Boat}+\theta_{BoatToLight}+180^{\circ}$

利用 $\theta_{LightToBoat}$ 我们又可以求出 $x_{FrontOfLight}=x_{Light}+sin\theta_{LightToBoat}$ 和 $y_{FrontOfLight}=y_{Light}+cos\theta_{LightToBoat}$

注：这里其实跟极坐标系差不多，只不过**方向不一样**

所以， $a=\frac{y_{Light}-y_{FrontOfLight}}{x_{Light}-x_{FrontOfLight}}$ $b=y_{Light}-ax_{Light}$

## Code
```cpp
#include<bits/stdc++.h>
#define Pi 3.1415926535897932384626
using namespace std;
struct Point
{
	double x,y;
	Point(const double &x=0.0,const double &y=0.0):
		x(x),
		y(y)
	{
	}
};
struct Line
{
	double a,b;
	Line(const double &a=0.0,const double &b=0.0):
		a(a),
		b(b)
	{
	}
};
inline Line twoPointToLine(const Point &a,const Point &b)
{
	return Line((a.y-b.y)/(a.x-b.x),a.y-(a.y-b.y)/(a.x-b.x)*a.x);
}
inline Point twoLineToPoint(const Line &a,const Line &b)
{
	return Point(-(a.b-b.b)/(a.a-b.a),-a.a*(a.b-b.b)/(a.a-b.a)+a.b);
}
Point light1,light2;
double boatFOV;
double light1FOV,light2FOV;
inline void init()
{
	int n;
	map<string,Point> light;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		string lightName;
		Point point;
		cin>>lightName;
		scanf("%lf %lf",&point.x,&point.y);
		light.insert(make_pair(lightName,point));
	}
	scanf("%lf",&boatFOV);
	string lightName;
	cin>>lightName;
	light1=light.at(lightName);
	scanf("%lf",&light1FOV);
	cin>>lightName;
	light2=light.at(lightName);
	scanf("%lf",&light2FOV);
}
inline void solve()
{
	Point frontOfLight1(light1.x+sin((boatFOV+light1FOV+180)*Pi/180.0),light1.y+cos((boatFOV+light1FOV+180)*Pi/180.0));
	Point frontOfLight2(light2.x+sin((boatFOV+light2FOV+180)*Pi/180.0),light2.y+cos((boatFOV+light2FOV+180)*Pi/180.0));
	Line light1ToBoat(twoPointToLine(light1,frontOfLight1));
	Line light2ToBoat(twoPointToLine(light2,frontOfLight2));
	if(light1ToBoat.a!=light2ToBoat.a)
	{
		Point boat(twoLineToPoint(light1ToBoat,light2ToBoat));
		printf("%.2lf %.2lf\n",boat.x,boat.y);
	}
	else
		printf("NO ANSWER\n");
}
int main()
{
	init();
	solve();
	return 0;
}

```

---

## 作者：Genius (赞：0)

用点斜式推导位置。计算几何基础。

```cpp

#include <cstdio>
#include <map>
#include <cmath>

using namespace std;

int main()
{
    map<char,int> xm,ym;
    int n,x,y,d1,d2;
    scanf("%d",&n);
    char c;
    for (int i=0;i<n;i++)
    {
        scanf("\n%c%d%d",&c,&x,&y);
        xm[c]=x;
        ym[c]=y;
    }
    
    int x1,y1,x2,y2;
    double k1,k2,ax,ay;
    scanf("%d",&n);
    n-=90;
    scanf("\n%c",&c);
    x1=xm[c];y1=ym[c];
    scanf("%d",&d1);
    d1=180-n-d1;
    k1=tan(3.141592653589793/180*d1);
    
    scanf("\n%c",&c);
    x2=xm[c];y2=ym[c];
    scanf("%d",&d2);
    d2=180-n-d2;
    k2=tan(3.141592653589793/180*d2);
    ax=(y2-y1+k1*x1-k2*x2)/(k1-k2);
    ay=k1*(ax-x1)+y1;
    printf("%.2lf %.2lf\n",ax,ay);
}

```

---


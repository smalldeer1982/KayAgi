# 物理1（phsic1）- 磁通量

## 题目背景

蒟蒻 HansBug 在物理考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在 HansBug 蒟蒻面前的是一个奇怪的磁场，形状为多边形，可以描述为 $N$ 个点构成的序列，这些点即依次为该磁场的各个顶点。于是现在蒟蒻 HansBug 想要知道该磁场的磁通量为多少。可是他脑细胞和 RP 已经消耗殆尽，所以这个高端的任务就交给你们啦。

## 说明/提示

磁通量 $=$ 磁感应强度 $\times$ 磁场区域面积。

![](https://cdn.luogu.com.cn/upload/pic/2219.png)

$0\lt B\le 10$。

## 样例 #1

### 输入

```
3 1
0 0
1 0
0 2
```

### 输出

```
1.0000```

## 样例 #2

### 输入

```
4 1
1 1
1 -1
-1 -1
-1 1
```

### 输出

```
4.0000```

# 题解

## 作者：Johnson_sky (赞：10)

# 题目大意


给出一些点的坐标，求它们依次连接形成的多边形的面积，根据面积进行计算。


# 思路


首先我们看一下一个简单凸多边形的计算方法。



 ![](https://cdn.luogu.com.cn/upload/pic/11473.png) 

很显然，它可以划分为好几个三角形来计算。



 ![](https://cdn.luogu.com.cn/upload/pic/11476.png) 

但是，凹多边形就不能用三角形划分的方法来计算。



 ![](https://cdn.luogu.com.cn/upload/pic/11474.png) 

因为：



 ![](https://cdn.luogu.com.cn/upload/pic/11475.png) 

这时，我们需要用到任意多边形的面积公式。


$$ S=\frac{1}{2}(|\sum_{i=1}^{n-1}(x_iy_{i+1}-x_{i+1}y_i)|+|x_ny_1-x_1y_n|) $$

于是，就可以根据这个公式来计算啦~


# 代码


```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
double b, stx, sty, lstx, lsty, nowx, nowy, s;

int main()
{
    scanf("%d %lf", &n, &b);
    scanf("%lf %lf", &lstx, &lsty);
    stx = lstx, sty = lsty;
    for(int i = 2; i <= n; ++i){
        scanf("%lf %lf", &nowx, &nowy);
        s += (lstx * nowy - nowx * lsty);
        lstx = nowx, lsty = nowy;
    }
    nowx = stx, nowy = sty;
    s += (lstx * nowy - nowx * lsty);
    printf("%.4lf\n", fabs(0.5 * s * b));
    return 0;
}
```

# 参考资料




[Wiki - Area](https://en.wikipedia.org/wiki/Area)

[Wiki - Shoelace\_formula](https://en.wikipedia.org/wiki/Shoelace\_formula)

# [My Blog](https://johnsonsky.github.io/2017/12/01/Luogu%20P2785%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/index/)


---

## 作者：Point_Nine (赞：9)

# P2785

### 前置知识

 计算几何基础公式：向量叉乘，两点距离公式。

向量叉乘：模长等于两个向量围成平行四边形面积，实际上是计算三维向量（本题只使用本公式计算面积）。

代码片段：
```cpp
double vec_ch(node a1,node a2)
{
	   return a1.x*a2.y-a2.x*a1.y;
}
```

两点距离公式：用勾股定理求解，x轴距离平方与y轴距离平方开根号。

代码片段：
```cpp
double dis(node a,node b)
{
	return sqrt(pow(b.y-a.y,2)+pow(b.x-a.x,2));
}
```

###  基本思想：求得四边形面积，然后乘磁通量求解。
 分情况讨论：

 凸多边形。

![](https://cdn.luogu.com.cn/upload/image_hosting/g5jnpxja.png)


 要求凸多边形面积，仅需以一个端点开始，将n边形分割为（n-2）个三角形，用向量叉乘求面积，累加面积。


------------


 凹多边形![](https://cdn.luogu.com.cn/upload/image_hosting/0iy98ikr.png)

 类似凸多边形，现将编号以此排序然后，一条一条边枚举，如果逆时针转就面积加，逆时针就减去该面积，容斥之后为凹边形面积，不过无需另外计算旋转方向，因为叉乘时已经计算方向，直接累加即可。

#### 面积累加代码实现：
```cpp
double ans=0;
    for(int i=3;i<=n;i++)
    {
    	cin>>p[i].x>>p[i].y;
        line[i-1].x=p[i].x-p[1].x;
        line[i-1].y=p[i].y-p[1].y;
        ans+=vec_ch(line[i-1],line[i-2])/2;
	}
```
 tips:叉乘求得面积是向量围成平行四边形面积，所以面积除以二才为三角形面积。
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
       double x,y;
}p[110000],s[110000],line[110000];
void swap(node &a,node &b)
{
	 node mid;
	 mid=a;
	 a=b;
	 b=mid;
}
double vec_ch(node a1,node a2)
{
	   //printf("%.3lf\n",a1.x*a2.y-a2.x*a1.y);
	   return a1.x*a2.y-a2.x*a1.y;
}
double dis(node a,node b)
{
	return sqrt(pow(b.y-a.y,2)+pow(b.x-a.x,2));
}
int main()
{
    int n;
    double m;
    cin>>n>>m;
    cin>>p[1].x>>p[1].y;
    cin>>p[2].x>>p[2].y;
    line[1].x=p[2].x-p[1].x;
    line[1].y=p[2].y-p[1].y;
    double ans=0;
    for(int i=3;i<=n;i++)
    {
    	cin>>p[i].x>>p[i].y;
        line[i-1].x=p[i].x-p[1].x;
        line[i-1].y=p[i].y-p[1].y;
        ans+=vec_ch(line[i-1],line[i-2])/2;
	}
    printf("%.4lf",abs(ans)*m);
}
```



---

## 作者：斯德哥尔摩 (赞：5)

题目要求：给出一堆点，求围成的平面多边形的面积。

首先看一下三角形的面积怎么求：$S=\frac{1}{2}|cross(a,b)|$

其中$a,b$是三角形的两条向量边，$cross(a,b)$是向量$a,b$的叉积。

叉积怎么写？

```cpp
struct point{
	double x,y;
};
inline double cross(const point p,const point q){
	return p.x*q.y-p.y*q.x;
}
```
然后扩展到多边形：

我们知道任何一个**凸多边形**都可以分割成许多个三角形，这个问题好解决。

那么凹多边形呢？

我们知道如果没有绝对值，三角形的面积可以为负值。

那么我们就可以想出一个思路：

假设我们一共分出了$n$个三角形，则有：
$$S=\sum_{i=1}^{n}S_i$$

而$S_i=\frac{1}{2}cross(a,b)$

于是这个问题就解决了。

注：楼上配的的那个图蛮好的。。。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define MAXN 100010
using namespace std;
int n;
double ans=0.00,s;
struct point{//点
	double x,y;
}a[MAXN];
inline double cross(const point p,const point q){//叉积
	return p.x*q.y-p.y*q.x;
}
int main(){
	scanf("%d%lf",&n,&s);
	for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y);
	a[0]=a[n];//注意，头尾还要再加一次叉积
	for(int i=1;i<=n;i++)ans+=cross(a[i-1],a[i]);
	printf("%.4lf\n",fabs(0.50000*ans*s));//记得加绝对值
	return 0;
}

```

---

## 作者：Grisses (赞：4)

[题面](https://www.luogu.com.cn/problem/P2785)

一道计算几何的题目。对于一个简单多边形 $P$，我们设其顶点序列为 $p_1(x_1,y_1),p_2(x_2,y_2)\cdots p_n(x_n,y_n)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/29f7e64z.png)

上图是一个有 5 个顶点的简单多边形（$A,B,C,D,E$），$F$ 是一个任意的点，不难发现 $S_{\triangle AFB}+S_{\triangle BFC}+S_{\triangle CFD}+S_{\triangle DFE}+S_{\triangle EFA}=S_{ABCDE}$（均为有向面积）。

那么，怎么求有向面积呢？当然是 **向量叉积** 啦！

**向量叉积（cross product）**，是向量运算的一种，不同于向量点积，向量叉积的结果还是一个向量。

对于向量 $\vec a$ 与向量 $\vec b$，它们的叉积是 $\vec a\times \vec b$，向量的模 $|\vec a\times\vec b|=|\vec a|\cdot |\vec b|\cdot\sin<a,b>$，即 $\vec a$ 与 $\vec b$形成的平行四边形的有向面积。

如果向量的起点都是原点，那么对于 $\vec a=(x_1,y_1),\vec b=(x_2,y_2)$，$\vec a\times\vec b=(x_1\times y_2,y_1\times x_2)$。

代码：
```cpp
  #include <bits/stdc++.h>
  using namespace std;
  int n;
  double B,S;//S表示2倍面积，n，B同题目
  struct node{
      double x,y;
  }a[100005];//储存点
  double CPr(node a,node b){return a.x*b.y-a.y*b.x;}//（Cross Product）
  int main()
  {
      scanf("%d%lf",&n,&B);
      for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y);
      for(int i=1;i<=n;i++)S+=CPr(a[i],a[i%n+1]);//求S（因为任意点都满足上文中的结论，为了方便，取原点）
      printf("%.4lf",fabs(S/2*B));//因为是有向面积，所以要取绝对值
      return 0;
  }
```

---

## 作者：Unordered_OIer (赞：4)

# P2785 题解
**题目大意**：求多边形的面积再乘上一个数，over~  

方法：外积/叉积。  
可能很多人都不知道这个东西，那么就普及一下。

我们来看一看度娘的解释：  
>   向量积，数学中又称外积、叉积，物理中称矢积、叉乘，是一种在向量空间中向量的二元运算。与点积不同，它的运算结果是一个向量而不是一个标量。并且两个向量的叉积与这两个向量和垂直。其应用也十分广泛，通常应用于物理学光学和**计算机图形学**中。

外积的坐标表示：  
$\ \ \ \ (x_1,y_1,z_1)×(x_2,y_2,z_2)$  
$=(y_1z_2-y_2z_1,z_1x_2-z_2x_1,x_1y_2-x_2y_1)$

理解了这个，应该没什么人想不到用外积/叉积了吧。  
并且要注意的是：在计算叉积/外积的时候一定要把最终的结果**取绝对值**（一大坑点）。

好吧，上代码：  
叉积/外积
```cpp
    double chaji(node a1,node a2,node b1,node b2)
    { // 外积，或者叫叉积
        return (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);
    }
```
计算
```cpp
    void getans()
    {
        for(int i=2;i<=n-1;i++)
            ans+=chaji(p[1],p[i],p[1],p[i%n+1]);
        printf("%.4lf\n",abs(ans)*b/2.);
    }
```
放出完整代码：
```cpp
#include<bits/stdc++.h>
#define SZ 1000005
using namespace std;
namespace magnetic_flux{
    struct node{double x,y;}p[SZ];
    int n;
    double ans,b;
    double chaji(node a1,node a2,node b1,node b2)
    { // 外积，或者叫叉积
        return (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);
    }
    void init()
    {
        scanf("%d%lf",&n,&b);
        for(int i=1;i<=n;++i)
            scanf("%lf%lf",&p[i].x,&p[i].y);
    }
    void getans()
    {
        for(int i=2;i<=n-1;i++)
            ans+=chaji(p[1],p[i],p[1],p[i%n+1]);
        printf("%.4lf\n",abs(ans)*b/2.);
    }
    int _main()
    {
        init();
        getans();
        return 0;
    }
}
using namespace magnetic_flux;
int main(){
    _main();
}
```

---

## 作者：Betrayer_of_love (赞：3)

## 题面

给出 $N$ 个点依次构成多边形的顶点，$1 \le N \le 1000000$。

$B$ 为磁感应强度，求区域的磁通量。

## 分析：
磁通量 $=BS$，所以问题的关键是用这 $N$ 个点求出多边形。

这里涉及到多边形的面积算法，一般采用向量外积。
因为向量 $| \overrightarrow{a} \times \overrightarrow{b} |= a$ 和 $b$ 向量构成平行四边形的面积，所以可用这个来计算三角形面积。将原本的多边形用某个点 $K$ 进行划分，构成一系列三角形即可。其中，这些三角形的一个顶点是 $K$，另外两个顶点是相邻的两个多边形顶点。

同时，这个面积是有方向性的，也就是说对于一些凹多边形，这个方式计算出来的结果会抵消不属于多边形的部分，但同时要求计算保证多边形上顶点取的顺序性。

点 $K$ 可随便取，取一个多边形上的顶点也是可以的。

![](https://cdn.luogu.com.cn/upload/image_hosting/yqkvzxaf.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/f1wyvram.png)

看代码吧！！！

### CODE

```c
#include<bits/stdc++.h>
using namespace std;
double x[100005], y[100005];//存所有的点x,y坐标
int main(){
	ios::sync_with_stdio(false);
	int n;
	double B,ans=0.0;
	cin >> n >> B;
	if (n <= 2) { cout << "0.0000";return 0; }
	for (int i = 0; i < n; i++){
		cin >> x[i] >> y[i];
	}
	double a1, b1, a2, b2;//vector
	for (int i = 1; i < n-1; i++){
		a1 = x[i] - x[0];//取x[0],y[0]为上面的K点
		b1 = y[i] - y[0];
		a2 = x[i + 1] - x[0];
		b2 = y[i + 1] - y[0];//计算出向量
		ans += a1 * b2 - b1 * a2;
	}
	if (ans < 0)ans = -ans;
	ans *= B*0.5;
	cout <<fixed<< setprecision(4) << ans;
	return 0;
}
```


**完结撒花，谢谢**

---

## 作者：zhangslover (赞：3)

## P2785
作为一名 SD 初二物理竞赛牲，我表示，这是一道包着“物理”外皮的数学题。

~~（怀疑出题人是不是出错题了）~~

（求管理大大审核通过）

题目传送门：[p2785](https://www.luogu.com.cn/problem/P2785)

------------
### 核心知识：多边形面积公式。


## 也就是 Shoelace Theorem
也就是我们熟知的鞋带定理。

~~(也有可能不熟知）~~

定义式如下:

$$S = \frac{1}{2}|\sum_{i = 1}^{n} \ (x_iy_{i+1}-x_{i+1}y_i)|$$
得到了这个公式 我们就可以利用题意开始做题了。

题意公式：磁通量 = 磁感应强度 × 磁场区域面积。

不过我们还要注意，因为这个图形是首尾相连的，所以第一个点和最后一个点我们要单独处理。

code：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n;
double b,bx,by,lx,ly,x,y;
double a ns;
int main(){
    cin>>n>>b;
    cin>>bx>>by;//第一个点
    lx=bx;//刚刚的那个点
    ly=by;
    for(int i=2;i<=n;i++){
        cin>>x>>y;//现在处理的点
        ans+=(lx*y-x*ly);
        lx=x,ly=y;
    }
    x=bx,y=by;//闭合图形
    ans+=(lx*y-ly*x);
    ans/=2.0;
    printf("%.4lf\n",abs(ans*b));//结合题目
    return 0;//好习惯++
}
```


------------
附录：

## 证明鞋带定理

### 前置知识：向量叉乘（主要）、向量点乘

具体不会向量点乘的参见[向量点乘（摘自知乎@双木止月Tong）](https://zhuanlan.zhihu.com/p/66674587)。

在这里就不过多浪费空间了。



------------
在证明鞋带定理之前，让我们先来浅浅看一下向量叉乘的知识。


这里我们在定义一个向量叉乘，   

$\overrightarrow{a} \times\overrightarrow{b} =  \vert\overrightarrow{a} \vert \cdot \vert \overrightarrow{b} \vert \cdot\sin< \overrightarrow{a},  \overrightarrow{b}> \cdot \overrightarrow{n}$

其中 $\overrightarrow{n}$ 是一个单位向量，其方向是垂直 $ \overrightarrow{a}$ ,   $\overrightarrow{b}$ 向量所成的平面的法向量的方向。

如下图（炸裂手绘版）：
![](https://cdn.luogu.com.cn/upload/image_hosting/wl2j2ldp.png)

如果是 $\overrightarrow{b} \times\overrightarrow{a} $，那么方向就跟     $\overrightarrow{a} \times\overrightarrow{b} $
方向相反。

那么向量叉乘怎么算呢？直接上公式！！！

如果

 $\overrightarrow{a} = a_{1} \overrightarrow{i}+a_{2}
\overrightarrow{j}+a_{3} \overrightarrow{k}$，$ \overrightarrow{b}=b_{1}
\overrightarrow{i}+b_{2} \overrightarrow{j}+b_{3} \overrightarrow{k}$ ,

那么,

 $\overrightarrow{a} \times \overrightarrow{b}=(a_2b_3-a_3b_1)\overrightarrow{i}-(a_1b_3-a_3b_2) \overrightarrow{j} -(a_1b_2-a_2b_1) \overrightarrow{k}$ 。

到此为止，我们已经说了这么多向量叉乘，那么这跟面积有什么关系呢？

在这里我们有一个面积公式：

$$S=\frac{1}{2}ab \sin C$$

推理过程也很简单：

![](https://cdn.luogu.com.cn/upload/image_hosting/l3q96caj.png)

比较一下这两个公式，我们发现 $ \vert \overrightarrow{a} \times \overrightarrow{b} \vert = \vert  \vert \overrightarrow{a} \vert \cdot \vert \overrightarrow{b} \vert \cdot \sin< \overrightarrow{a}, \overrightarrow{b}> \cdot \overrightarrow{n} \vert$ 
就是以 $ \overrightarrow{a}$ , 
 $\overrightarrow{b}$ 两个向量所构成的平行四边形面积，再除以 $2$ ，就是所求的三角形面积。



------------
### 接下来我们就用数学归纳法来证明Shoelace Theorem

**1.证明三角形时成立：**

已知平面直角坐标系上三个点  $A(x_1,y_1),B(x_2,y_2),C(x_3,y_3)$ ，我们可以
把这三个顶点放到三维空间中，并把点 $A$ 移到原点 $A'(0,0,0)$ ,那么， $B(x_2-x_1,y_2-y_1,0)$ ,  $C(x_3-x_1,y_3-y_1,0)$ 。

于是，根据向量叉乘的几何意义可知：

 $S_{ \bigtriangleup ABC} = \frac{ \vert \overrightarrow{AB} \times \overrightarrow{AC} \vert}{2}$

$= \frac{x_1y_2+x_2y_3+x_3y_1-x_1y_3-x_2y_1-x_3y_2}{2}$。

**2.假设 $n$ 边形成立，推导 $(n+1)$ 边形成立：**

已知条件 $n$ 边形时成立，则有 $S_{A_1A_2 \ldots A_n}= \frac{1}{2} \sum_{i=1}^{n} (x_iy_{i+1}-x_{i+1}y_{i})$,

其中 $x_{n+1}=x_1,y_{n+1}=y_1$ 。

对于顶点 $A_1A_2 \ldots A_{n+1}$ 的 $n$ 多边形，可以分为 $(n+1)$ 边形，可以分为 $n$ 边形与一个三角形之和.

 $S_{A_1A_2\ldots A_{n+1}}=S_{A_1A_2\ldots A_{n}}+S_{A_1A_nA_{n+1}}$ ,

 $S_{A_1A_2\ldots A_{n+1}}=\frac{1}{2} \sum_{i+1}^{n}(x_iy_{i+1}-x_{i+1}y_i)$ ,

 $S_{A_1A_nA_{n+1}} = \frac{1}{2}(x_1y_n+x_ny_{n+1} + x_{n+1}y_1-x_1y_{n+1}-x_ny_1-x_{n+1}y_{n})$ ,

于是则有，

 $S_{A_1A_2\ldots A_{n+1}} = \frac{1}{2}((x_1y_2+\ldots+x_ny_1) - (y_1x_2+\ldots+y_nx_1) + (x_1y_n+x_ny_{n+1}+x_{n+1}y_1) -(y_1x_n+y_nx_{n+1}+y_{n+1}x_1))$ 

 $ = \frac{1}{2}((x_1y_2+\ldots+x_ny_{n+1} + x_{n+1}y_1)-(y_1x_2+\ldots+y_{n+1}x_1))$

 $=\frac{1}{2} \sum_{i = 1}^{n+1} \ (x_iy_{i+1} - x_{i+1}y_i)$,

其中， $x_{n+2} = x_1,y_{n+2} = y_1$ 。

证毕。

至此，关于鞋带定理的证明已经完成。

------------



~~(一个证明过程从晚上9点写到11点40，困死我了）~~

------------

————*BY* *Zhangs_lover* 

---

## 作者：Tracy_Loght (赞：1)

**前置知识**：一个简简单单的求面积方法。

## 题目描述：

额，囧是给你一堆二维平面上的点求面积并乘上一个数。

## 如何求面积？

三种方法。

### 向量与线段~~的爱情~~

咳咳咳，不多说了，就是用公式求出每一条边的长度再划分为多个小的三角形。

### 内外点

小学的时候讲过一个方法，数一下刚刚好在图形边上的点，和被包在图形内的点，经过一个公式可以求出来。~~（啊，不记得了）~~

### 专用于平面坐标求图形的公式

**简称**：公式。

自己看吧，我不知道怎么描述了：

```cpp
ft area=0.0;//应用Shoelace公式计算面积
for(int i=1;i<=x;++i) {
    int j=i%x;// 下一个顶点的索引
    area+=hh[j].aa*hh[i-1].bb;
    area-=hh[j].bb*hh[i-1].aa;
}
area=abs(area)/2.0;//最终取绝对值并除以2
return area;
```

数组内放的是一个有顺序的坐标。

然后，就没了，不算是蓝吧......

### 代码

```cpp
#include<bits/stdc++.h>
#define lg double
using namespace std;
lg n,m;
struct{lg a,b;}hh[100000];
lg DBV(int x,lg b){
	lg area=0.0;
    for(int i=1;i<=x;++i){
        int j=i%x;
        area+=hh[j].a*hh[i-1].b;
        area-=hh[j].b*hh[i-1].a;
    }
    area=abs(area)/2.0;
    printf("%.4lf",area*b);
    return 0;
} 

int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n>>m;
	for(int i=0;i<n;i++)
        cin>>hh[i].a>>hh[i].b;
	DBV(n,m);
	return 0;
}

```

就这些，一共才三分钟左右就写完了。

---

## 作者：luuia (赞：1)

### 题目大意

给定一个 $n$ 边形的各顶点坐标，求这个多边形的面积。

### 前置知识：向量叉积

对于向量 $\overrightharpoon{a}$ 与向量 $\overrightharpoon{b}$，$\overrightharpoon{a}$ 与 $\overrightharpoon{b}$ 的叉积为 $\overrightharpoon{a} \times \overrightharpoon{b}$，向量叉积的结果依然是一个向量，它的模长表示 $\overrightharpoon{a}$ 与 $\overrightharpoon{b}$ 形成的平行四边形的有向面积。

设 $\overrightharpoon{a} = (x_1,y_1)$，$\overrightharpoon{b} = (x_2,y_2)$，那么 $\overrightharpoon{a} \times \overrightharpoon{b} = (x_1y_2,y_1x_2)$。

那么如何用叉积来求多边形面积呢？

我们从三角形入手，先给出一个公式：

设 $A(x_1,y_1),B(x_2,y_2),C(x_3,y_3)$，那么：

$S_{\vartriangle ABC} = \frac{1}{2} |x_1y_2+x_2y_3+x_3y_1-x_2y_1-x_3y_2-x_1y_3|$

我们来证明这个公式：

$$\overrightharpoon{AB} = (x_2-x_1,y_2-y_1),\overrightharpoon{AC} = (x_3-x_1,y_3-y_1)$$

$$
\begin{aligned}
S_{\vartriangle ABC} &= \frac{1}{2} |\overrightharpoon{AB} \times \overrightharpoon{AC}| \\ 

&= \frac{1}{2}|(x_2-x_1)(y_3-y_1) - (y_2-y_1)(x_3-x_1)| \\

&=\frac{1}{2} |x_1y_2+x_2y_3+x_3y_1-x_2y_1-x_3y_2-x_1y_3|
\end{aligned}
$$

因此，我们把多边形分解成 $(n-2)$ 个三角形，得到多边形面积公式为：

$$S=\frac{1}{2}|\sum_{i=2}^n(x_{i-1}y_i - x_iy_{i - 1}) + (x_ny_1-x_1y_n)|$$

我们根据这个公式来计算面积，最后乘以磁感应强度 $B$ 即可。

### 代码

[AC 记录](https://www.luogu.com.cn/record/147246467)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
struct NODE
{
	double x,y;
}node[N]; 

int n;
long double b,ans;

int main()
{
	cin >> n >> b;
	for(int i = 1;i <= n;i++)
	{
		cin >> node[i].x >> node[i].y;
	}
	for(int i = 1;i <= n;i++)
	{
		if(i == n)
		{
			ans += node[i].x * node[1].y;
			continue; 
		}
		ans += node[i].x * node[i + 1].y;
	}
	for(int i = 1;i <= n;i++)
	{
		if(i == 1)
		{
			ans -= node[i].x * node[n].y;
			continue;
		}
		ans -= node[i].x * node[i - 1].y;
	}
	if(ans < 0) ans = -ans;
	ans *= 0.5;ans *= b;
	cout << fixed << setprecision(4) << ans << endl;
	return 0;
}

```

---

## 作者：henry_qwh (赞：1)

**[题目传送门](https://www.luogu.com.cn/problem/P2785)**

### 题目大意
给出若干个点组成的点列，这些点列围成了一个多边形。求这个多边形的面积乘上一个给定的常数 $B$ 的结果。

### 题目思路
这是一道计算几何题。显然，本题的难点在于如何求多边形面积。这时候，我们需要用到向量的叉乘运算（外积）。

两个向量的外积为一个数值，并记为 $\overrightharpoon{a}\times\overrightharpoon{b}$。定义向量 $\overrightharpoon{a}$ 与向量 $\overrightharpoon{b}$的夹角为 $\theta$。

向量 $\overrightharpoon{a}$ 与向量 $\overrightharpoon{b}$ 的外积为
$$
|\overrightharpoon{a}\times\overrightharpoon{b}|=|\overrightharpoon{a}||\overrightharpoon{b}|\sin\theta
$$

可以联想到三角形的面积公式 $S=\frac{1}{2}ab\sin\theta$，注意到两者为二倍关系，则向量外积的几何意义为以两向量为邻边的平行四边的面积。

这一定理还可以推广到任意的 $n$ 边形。我们可以任选一个辅助点 $O$，将该点列按逆时针标记为 $p_1,p_2,\dots,p_n$，记向量 $\overrightharpoon{v_i}=p_i-O$，则该点列围成的 $n$ 边形的面积为
$$
S=\frac{1}{2}|\sum_{i=1}^n\overrightharpoon{v_i}\times\overrightharpoon{v_{(i\mod n)+1}}|
$$

若将向量外积的公式用坐标的形式写出，那么向量 $\overrightharpoon{a}=(x_1,y_1)$ 和向量 $\overrightharpoon{b}=(x_2,y_2)$ 的外积为
$$
\overrightharpoon{a}\times\overrightharpoon{b}=
\begin{vmatrix}
x_1&x_2\\
y_1&y_2
\end{vmatrix}=x_1y_2-x_2y_1
$$

借助以上公式，我们便可以轻松地做出此题，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

### 参考代码
**[AC记录](https://www.luogu.com.cn/record/163091929)**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
double xx,yy,x,y,mx,my,ans = 0,b;

int main()
{
	cin >> n >> b >> mx >> my;
	xx = mx,yy = my;
	for (int i = 2;i <= n;i++)
	{
		cin >> x >> y;
		ans += (xx*y-yy*x);
		xx = x,yy = y;
	}
	x = mx,y = my;
	ans += (xx*y-yy*x);
	ans /= 2.0;
	cout << fixed << setprecision(4) << abs(ans*b) << endl;
	
	return 0;
}
```

---

## 作者：IcyFoxer_XZY (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2785)

这道题本质上就是让我们计算四边形面积，可以用到叉积来解决。

设矢量 $P=(x_1,y_1)$，$Q=(x_2,y_2)$，则叉积为：$P\times Q=x_1\times y_2-x_2\times y_1$，其结果是一个标量，叉积的绝对值是一个平行四边形面积。

还有一个非常重要性质是：叉积可以通过它的符号（正负）判断两矢量相互之间的顺逆时针关系。

最后，了解了这些再来计算多边形面积就很简单了。

计算过程中不区分正负面积，能保证抵消。

所有面积加和完成后进行一次绝对值计算，使有向面积变成绝对值。

将所得答案加绝对值再乘上磁感应强度 $B$ 输出即可。

注意答案一定要加绝对值。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double B,ans,x[100010],y[100010];
double work(int i,int j){return (x[i]-x[1])*(y[j]-y[1])-(x[j]-x[1])*(y[i]-y[1]);}//叉积计算方法 
int main() {
	scanf("%d%lf",&n,&B);
	for(int i=1;i<=n;++i)scanf("%lf%lf",&x[i],&y[i]);
	for(int i=2;i<=n;++i){
		double w=work(i,i-1);
		ans=ans+w;
	}
	ans=ans+work(n,1);
	printf("%.4lf",abs(ans)/2*B);//记得加绝对值 
	return 0;
}
```
Bye！

---

## 作者：小小小朋友 (赞：1)

## 题目大意

这是一道神奇的题目……

我看了半天，发现有这样一句话:
![图片.png](https://i.loli.net/2020/01/04/Qm4vBYAaqp2UtWj.png)(ΩДΩ)

反正就是求一个多边形的面积，再乘上一个数即可。

## 思路

如果是凸多边形的话，我们可以将其分成许多个三角形计算。

**我们知道**~~逃~~，**三角形的面积等于向量外积的绝对值的一半**。

这是因为平行四边形的面积在数值上等于两边的向量的外积。

但是还有凹多边形的情况，我们想想后会发现，有的外积是正的，有的是负的，它们正好可以把多余的部分抵消！

## 代码
一不小心写长了……
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
struct point{double x,y;}p[100005];
int n;
double ans,b;
inline double cj(point a1,point a2,point b1,point b2){
	return (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);
}//外积
int main(){
	scanf("%d%lf",&n,&b);
	for(int i=1;i<=n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);//输入
	for(int i=2;i<=n-1;i++)
		ans+=cj(p[1],p[i],p[1],p[i%n+1]);
	printf("%.4lf\n",fabs(ans*b/2.));//最后再求绝对值
	return 0;
}

```

---

## 作者：gavinliu266 (赞：0)

# 思路
可以先看一下 [P1183](https://www.luogu.com.cn/problem/P1183)，是一个求多边形面积的题，题解中也有很多详细的的解释及推导。

这题就是求完面积之后再乘上 $B$，只需要最后乘上就可以了。

有几点需要注意的：

- $B$ 是实数，需要用浮点数保存。
- 坐标也是实数，也需要用浮点数。
- 最后最好还是绝对值一下，以防万一。

# 代码实现
```cpp
#include <cmath>
#include <cstdio>
using namespace std;
int n;
double B, a[100005], b[100005], ans;  // 实数，要用浮点数保存
int main() {
    scanf("%d%lf", &n, &B);
    for(int i = 1; i <= n; ++i)
        scanf("%lf%lf", &a[i], &b[i]);
    for(int i = 1; i < n; ++i)
        ans += a[i] * b[i + 1] - b[i] * a[i + 1];
    ans += a[n] * b[1] - b[n] * a[1];
    printf("%.4lf\n", fabs(ans / 2 * B)); // 保险还是取一下绝对值，答案不要忘记除以二
}
```

---

## 作者：Ekennis (赞：0)

计算多边形的面积是可以使用叉乘法推出公式的。

[一个含有中文证明的参考链接](https://zhuanlan.zhihu.com/p/110025234)

[维基百科 - Shoelace formula](https://en.wikipedia.org/wiki/Shoelace_formula)

使用这个 Shoelace formula 就可以愉快的计算任意多边形的面积啦\~


**对于任意一个多边形，如果已知各个顶点的坐标**
$A_1(x_1,y_1),A_2(x_2,y_2),...,A_n(x_n,y_n)$，**那么这个多边形的面积为：**
$$
S={1\over2}|\sum_{i=1}^{n}(x_iy_{i+1}-x_{i+1}y_i)|
$$
**其中** $x_{n+1}=x_1,y_{n+1}=y_1$.

公式虽好，不要忘记条件：给定的点必须是顺时针或者逆时针给出，否则计算出来的面积是不对的。其实应该是要以一个点为基准点，极角排序一下才正确的。

可惜这题好像没有随机给点的数据，所以不排序也能水过去（

```cpp
#include <bits/stdc++.h>
const double eps = 1e-6;
const int maxn = 114514;
using namespace std;
struct Point {
    double x, y;
};
typedef Point Vector;
double Cross(const Vector& v1, const Vector& v2) {
    return v1.x * v2.y - v2.x * v1.y;
}
double len(const Vector& v) {
    return sqrt(v.x * v.x + v.y * v.y);
}
Point p[maxn];
int main() {
    int n;
    double B;
    scanf("%d%lf", &n, &B);
    for (int i = 0; i < n; ++i) {
        scanf("%lf%lf", &p[i].x, &p[i].y);
    }
    double ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += Cross(p[(i + 1) % n], p[i]);
    }
    printf("%.04f", fabs(ans) / 2 * B);
}
```


---

## 作者：Prean (赞：0)

不是啊我今天晚上想找一下有难度的几何题，结果找到了一道大水题？？？？？？

题目大意：给一个多边形，求它的面积乘上某一个数。

众所周知一个多边形的面积等于：相邻两个点的叉积之和的一半的绝对值。

然后就没什么可说的了。。。

代码：
```cpp
#include<cstdio>
#include<cmath>
typedef double db;
struct vector{
    db x,y;
    vector(db x=0,db y=0):x(x),y(y){}
    friend inline db operator*(vector a,vector b){
        return a.x*b.y-a.y*b.x;
    }
}a[100005];
int n;
db b,ans;
signed main(){
    int i;
    scanf("%d%lf",&n,&b);
    for(i=1;i<=n;++i)scanf("%lf%lf",&a[i].x,&a[i].y);
    a[n+1]=a[1];//最后一个点要和第一个点做叉积，所以要加上
    for(i=1;i<=n;++i)ans+=a[i]*a[i+1];
    printf("%.4lf",fabs(ans*b/2));//注意加绝对值
}
```
P.S.：作为一道蓝题也太水了吧？？？

---


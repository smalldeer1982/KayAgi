# 偷上网

## 题目描述

Alice 和 Bob 生活在一个 $l \times l$ 的正方形房子里，由于 Bob 最近沉迷隔膜，Alice 决定要限制 Bob 上网的频率。

Alice 建造了 $n$ 个无线信号屏蔽器，第 $i$ 个位于 $(x_i, y_i)$，屏蔽范围为 $\frac{l}{n}$。

Bob 网瘾发作按捺不住上网的冲动，找到了你，帮他找到一个位置 $(x, y)$，使得没有被 Alice 的无线信号屏蔽器覆盖。

## 样例 #1

### 输入

```
1 1
0.000 0.000```

### 输出

```
0.999 0.999```

## 样例 #2

### 输入

```
1 2
1.000 1.000```

### 输出

```
GG```

## 样例 #3

### 输入

```
2 2
0.000 0.000
2.000 2.000```

### 输出

```
1.000 1.000```

# 题解

## 作者：Garen (赞：18)

## 洛谷5月月赛的T2。让我大开眼界！

---

Drench大佬这么说的：

---

## B. 偷上网

如果 $n = 1$，则枚举一下四个角，如果都不可行，一定无解，否则就找到了合法点。

如果 $n \geq 2$ ，则圆的总面积一定小于正方形的面积，每次随机一个点，判断是否可行。显然随机次数不会太多就会找到合法解。

---

所以有一种几乎不会被hack的算法，叫做**随机算法**！！！

### 如何取随机数？

只需要include进cstdlib，srand一个种子之后，就可以用rand()取随机数啦！

随机算法的优点是随机！我设计这种算法，即使运算100000次也根本不会超时，发现100000次还WA了一个点，直接再添一个0就可以了，并不会慢太多。时限很轻松。

### srand的种子要取什么？

随缘！比如19260817、你自己的手机号、你基友的生日等等都可以。

这么多种子随便取，导致出题人都没办法hack你！

代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn = 15;
double x[maxn], y[maxn];
double n, l;
int main()
{
	srand(19260817);
	scanf("%lf%lf", &n, &l);
	for(int i = 1; i <= n; i++) scanf("%lf%lf", &x[i], &y[i]);
	for(int i = 1; i <= 1000000; i++)
	{
		double tx = rand(), ty = rand();
		while(tx > l) tx /= 10;
		while(ty > l) ty /= 10;
		bool ok = true;
		for(int j = 1; j <= n; j++)
		{
			if(pow(tx - x[j], 2) + pow(ty - y[j], 2) < pow(l / n, 2))
			{
				ok = false;
				break;
			}
		}
		if(ok)
		{
			printf("%.3lf %.3lf\n", tx, ty);
			return 0;
		}
	}
	printf("GG\n");
	return 0;
}
```

---

## 作者：破壁人五号 (赞：7)

[博客](https://wallbreaker5th.github.io/)

这道题当时居然因为某些细节没有AC，之后看到错因才发现问题orz。

听说标算是先判断n=1，只有n=1并且四个顶点都被覆盖才可能GG。 否则不断在边界上随机取点，因为边界不可能全被覆盖。

下面进入正文：

题目链接： [https://www.luogu.org/problemnew/show/T29693](https://www.luogu.org/problemnew/show/T29693)

题目大意：在一个l*l的正方形里有n个半径为l/n的圆， 求一个不在任何一个圆里面的点。

看到这道题，第一反应：毒瘤计算几何，这辈子都别想写出标算。

然而我灵光一现，想出了一种奇葩解法：

首先把很多个Bob随机扔进房间，然后想象这些Bob被屏蔽器“挤开”。

多“挤”几次之后就很可能出现成功躲开的Bob，如果没有就认为GG。

然后我把这个思路抽象出来：

首先在正方形里面随机生成N个点，然后做T次以下操作：

遍历每一个点，判断它是不是在某一个圆内部。 如果是，求出该圆圆心到这个点的向量， 乘以一个倍数使得这个点沿着这个向量移动之后刚好脱离屏蔽器的距离。

把一个点所有向量加起来，让这个点移动。 如果出了房间或者出现NaN，让它重新在正方形里面随机选一个点。

最后输出一个不在圆中的点，如果没有，输出GG。

举一个例子：

![一个例子](https://wallbreaker5th.github.io/img/0000.PNG)

时间复杂度：$O(NTn)$（事实证明N与T调整得足够好的话可以达到0msAC）

算法正确性：看脸

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10,T=100;
const double eps=0.0000015;
int n,l;
struct point{
    double x,y; 
    void init(){
        x=rand()*rand()%(l*10)/10.0;
        y=rand()*rand()%(l*10)/10.0;
    }
};
point pb[20];
point p[N];
int main(){
    srand(time(NULL));
    double fw;
    cin>>n>>l;
    for(int i=0;i<N;i++)p[i].init();
    fw=l*1.0/n;
    for(int i=0;i<n;i++){
        cin>>pb[i].x>>pb[i].y;
    }
    for(int i=0;i<T;i++){
        for(int j=0;j<N;j++){
            double ax=0,ay=0;
            for(int k=0;k<n;k++){
                double dis=sqrt((p[j].x-pb[k].x)*(p[j].x-pb[k].x)+(p[j].y-pb[k].y)*(p[j].y-pb[k].y));
                if(dis-fw<eps){
                    double xx=(p[j].x-pb[k].x)/dis*(fw+eps),yy=(p[j].y-pb[k].y)/dis*(fw+eps);
                    ax+=xx-(p[j].x-pb[k].x);
                    ay+=yy-(p[j].y-pb[k].y);
                }
            }
            p[j].x+=ax;
            p[j].y+=ay;
            if(p[j].x<0||p[j].x>l||isnan(p[j].x)){
                p[j].init();
            }
            if(p[j].y<0||p[j].y>l||isnan(p[j].y)){
                p[j].init();
            }
            
        }
    }
    for(int i=0;i<N;i++){
        bool ok=(p[i].x>=0&&p[i].y>=0&&p[i].x<=l&&p[i].y<=l);
        for(int j=0;j<n;j++){
            if(sqrt((p[i].x-pb[j].x)*(p[i].x-pb[j].x)+(p[i].y-pb[j].y)*(p[i].y-pb[j].y))-fw<eps)ok=false;
        }
        if(ok){
            cout<<fixed<<setprecision(8)<<p[i].x<<" "<<p[i].y;
            return 0;
        }
    }
    cout<<"GG";
    return 0;
}
```

[0msAC链接](https://www.luogu.org/record/show?rid=7915475)

---

## 作者：zjh111111 (赞：2)

很久以前的月赛题了吧，写篇题解怀念一下

题面意思表达很清楚了。

【思路】

观察一下范围，发现 n 很小，同样整个被覆盖的区域也很小。

故采用随机化，随机一个点，判断这个点是否被覆盖。

这样子随机到答案的概率是很大的。

复杂度(p是随机次数)

$$\mathcal{O(n*p)}$$

这里给出 Pascal 的随机化方式。

【代码】

解释
```pascal
function ran(y,z:real):boolean;
var
  j:longint;
begin
  for j:=1 to n do
    if sqrt(sqr(y-a[j])+sqr(z-b[j]))<=(m/n+1e-6) then exit(false);
//曼哈顿距离，如果在范围内说明被覆盖，不合法
  exit(true);
end;
begin
  randomize;
//Pascal随机前必须初始化随机函数发生器，不然random(x)，x相同随机出来的是同一个数
  readln(n,m);
  for i:=1 to n do readln(a[i],b[i]);
  for i:=1 to p do
    begin
      x:=random(m*1000)+1;
      y:=random(m*1000)+1;
      if ran(x/1000,y/1000) then
//比较套路，在[1,m]里随机x位小数，就先把m扩大10^x倍后随机，再除以(10^x)，需要注意的是可能会爆范围（当然这题不会
        begin
          write(x/1000:0:3,' ',y/1000:0:3);
          exit;
        end;
    end;
  write('GG');//上面已经结束程序，做到这里就是无解。
end.
```

完整

```pascal
const
  p=1000000;
var
  n,m,x,y,i,k:longint;
  a,b:array[0..11] of real;
function ran(y,z:real):boolean;
var
  j:longint;
begin
  for j:=1 to n do
    if sqrt(sqr(y-a[j])+sqr(z-b[j]))<=(m/n+1e-6) then exit(false);
  exit(true);
end;
begin
  randomize;
  readln(n,m);
  for i:=1 to n do readln(a[i],b[i]);
  for i:=1 to p do
    begin
      x:=random(m*1000)+1;
      y:=random(m*1000)+1;
      if ran(x/1000,y/1000) then
        begin
          write(x/1000:0:3,' ',y/1000:0:3);
          exit;
        end;
    end;
  write('GG');
end.

C艹大家都写了，解释得也清楚。所以来份Pascal。


```

---

## 作者：千城_Dhmc (赞：1)

### 本题思路：

这一题要用到**随机数**，题意是输出在 n 个屏蔽器的范围外的点，因为是随机数，可能要不停的调范围，所以做这题时要有耐心，不断尝试调他的范围。

思路就是在这个房间里**随机枚举位置**，直到**找到没有屏蔽器覆盖的点**的坐标。

### 下面附上AC代码：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
double dis(double a,double b,double c,double d){
return sqrt((a-c)*(a-c)+(b-d)*(b-d));
}//长度函数
int main(){
double n,l,r,x[15],y[15];
cin>>n>>l;//输入
for(int i=1;i<=n;i++){
    cin>>x[i]>>y[i];    
}   
r=l/n;//半径
for(int i=1;i<5000000;i++){//五百万个随机点里找正确得点
    double a=rand();
    double b=rand();
    while(a>l){
        a/=5;
    }
    while(b>l){
        b/=5;
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(dis(a,b,x[i],y[i])>r+0.00001){
            cnt++;
        }
    }
    if(cnt==n){
        printf("%.3lf %.3lf",a,b);//输出
        return 0;
    }
}
cout<<"GG";
return 0;
}
```
别作弊，棕名警告！

---

## 作者：Leap_Frog (赞：1)

# P4703偷上网（题解）

### PS.~~随机大法好用~~

### 题目大意
就是给你$\texttt{n}$个圆，然后让你找出一个点，使它没被任何圆覆盖。  
输出这个点的坐标，没有则输出$\texttt{GG}$。

### 代码分析
~~没什么好分析的~~  
直接暴力随机这个点的坐标，然后判断这个点是否在圆内。  
那么如何判断这个点是否在圆内呢？ [不会的点我](https://www.luogu.org/problem/P1652)  
具体详情请看代码。

### 关于此题
我做这道题，刚开始忘了可能有无解情况，$\texttt{T}$了$\texttt{4}$个点，~~说明无解的就四个点~~  
然后，又过了一段时间，终于把代码构对了后，发现随机种子也很重要。  
刚开始，我用$\texttt{time(0)}$来当随机种子，$\texttt{Wa}$了一个点。  
后来用其他的一些随机种子，结果都$\texttt{Wa}$了那一个点。  
一气之下，我翻了一下题解，抄了楼上的$\texttt{19260817}$作为随机种字，莫名其妙就对了。  
我感到特别玄学

### 不说了，上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=15;
struct point{double x,y;}a[N];	//点的结构体
int n,l,m=1e7;	//m表示随机次数
inline point Rand()		//生成平面上的随机一个点
{
	double x=rand(),y=rand();
	while(x>l) x/=10;
	while(y>l) y/=10;
	return (point){x,y};
}
inline double sqr(double x) {return x*x;}	//平方函数
inline char check(point b)		//判断这个点是否在一个圆里面
{
	for(int i=1;i<=n;i++)
		if(sqr(b.x-a[i].x)+sqr(b.y-a[i].y)<sqr(double(l)/n))
			return 1;
	printf("%.3lf %.3lf\n",b.x,b.y);
	return 0;
}
int main()
{
	srand(19260817);	//玄学的随机种字
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
	while(check(Rand())&&m--);	//不断随机点，判断
	if(m==-1) puts("GG");	//判断不可行解
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

造了个数据，Hack 掉了所有使用随机化的题解（似乎 $n=1$ 的时候是可以退火的，但我没试），所以我写一篇题解。

### 思路

首先，问题可以转化为在一个边长为 $l$ 的正方形内选出一个点，使得这个点没被 $n$ 个圆中的任何一个覆盖，如果找不到就输出 `GG`。

我们可以分类讨论一下。

- 当 $n=1$ 时，圆的半径为 $l$，直径为 $2l$，大于正方形的对角线长度 $\sqrt{2}l$。因此，要么圆覆盖整个正方形，要么至少有一个正方形的顶点没被覆盖（因为圆是凸图形，所以不可能正方形所有顶点都被覆盖而存在其他点没被覆盖）。所以，我们可以直接判断四个顶点是否满足条件，如果没有满足条件的顶点输出 `GG`。
- 当 $n\ge4$ 时，圆的总面积 $n\pi(\frac{l}{n})^2= \frac{\pi}{n}l^2$ 小于正方形的面积 $l^2$，不可能覆盖整个正方形，所以我们完全可以在正方形内随机取点，直到不被任何一个圆覆盖为止。
- 当 $n=3$ 时，$3$ 个直径为 $\frac{2}{3}l$ 的圆是不可能覆盖边长为 $l$ 的正方形的，因为如果可以覆盖，那么根据抽屉原理，至少有 $1$ 个圆覆盖正方形的 $2$ 个顶点，这样圆的直径至少是 $l$，矛盾，所以不能覆盖。这样就可以转化成 $n\ge4$ 的情况，随机取点。
- 当 $n=2$ 时，$2$ 个直径为 $l$ 的圆也是不可能覆盖边长为 $l$ 的正方形的。假设可以覆盖，则要么有一个圆覆盖正方形至少 $3$ 个顶点（这要求圆的直径至少是 $\sqrt{2}l$，矛盾），要么两个圆分别覆盖正方形的两个相邻的顶点（这要求两个圆心分别在对边中点，很明显覆盖不了整个正方形）。所以 $n=2$ 的情况仍然可以随机取点。

综上，当 $n=1$ 时，判断正方形四个顶点（$(0,0)$、$(0,l)$、$(l,0)$、$(l,l)$）即可，当 $n\ge2$ 时，在正方形内随机取点直到满足条件即可。

这里随机种子可以任意取，我这里用的系统时间戳。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using lf=long double;
const lf EPS=1e-6l;
lf dis(lf x1,lf y1,lf x2,lf y2){
    return sqrtl((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
mt19937_64 r(time(0));
lf x[11],y[11];
int main(){
    int n;lf m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
    if(n==1){
        for(int i=1;i<=2;i++){
            for(int j=1;j<=2;j++){
                lf xx,yy;
                if(i==1)xx=0;
                else xx=m;
                if(j==1)yy=0;
                else yy=m;
                if(dis(xx,yy,x[1],y[1])>=(m/n)+EPS){cout<<setprecision(12)<<xx<<" "<<setprecision(12)<<yy;return 0;}
            }
        }
        cout<<"GG";
        return 0;
    }
    while(1){
        lf xx=(lf(r())/ULLONG_MAX)*m,yy=(lf(r())/ULLONG_MAX)*m;
        for(int i=1;i<=n;i++){
            if(dis(xx,yy,x[i],y[i])<(m/n)+EPS)break;
            if(i==n){cout<<setprecision(12)<<xx<<" "<<setprecision(12)<<yy;return 0;}
        }
    }
}
```

---


# [蓝桥杯 2023 国 Java A] 连续数组

## 题目描述

小蓝对连续数组很感兴趣，对于一个长度为 $N$ 的连续数组 $nums$，$nums$ 中的元素取值范围为 $1 \sim N$，且 $nums$ 中不存在重复元素，每两个相邻的数组元素 $nums[i]$、$nums[i + 1]$ 之间都存在关系($1 \leq i \leq N - 1$)，且只可能是以下两种关系中的一种:

1. 连续，此时 $nums[i + 1]$ 等于 $nums[i] + 1$;
2. 不连续，此时 $nums[i + 1]$ 不等于 $nums[i] + 1$。

现在给出一个长度为 $N$ 的数组中任意相邻的数组元素之间的关系，请问共有多少种满足条件的连续数组？

## 说明/提示

### 样例说明

符合条件的连续数组有：$[1, 5, 2, 3, 4]$、$[2, 1, 3, 4, 5]$、$[5, 4, 1, 2, 3]$。

### 评测用例规模与约定

对于 $30\%$ 的评测用例，$1 \leq N \leq 10$；

对于所有评测用例，$1 \leq N \leq 15$。

## 样例 #1

### 输入

```
5
0 0 1 1```

### 输出

```
3```

# 题解

## 作者：guoshengyu1231 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P12236)
# 题意分析
通过读题，我们可以知道题目是要求我们构造出一个由数字 $1$ 到 $n$ 组成的序列，使得数列中每两个相邻的数满足以下两个条件之一：$\\$
1. 满足 $a_{i+1}=a_i+1$。
2. 满足 $a_{i+1}\ne a_i+1$。

当接下来输入的 $s_i$ 等于 $1$ 时，则需要 $a_{i+1}$ 满足条件 $1$，否则满足条件 $2$。

 $\\$
考虑到对于所有评测用例，满足 $1\le n\le 15$，那应该要么是记忆化搜索，要么是状态压缩 dp（其实都是 dp 的思想，只是求解方向不同）。 
## 状态压缩简介
假设现在有一个集合，集合内有 $n$ 个元素，分别对应 $n$ 个物品。对于每个物品，我们可以是选或不选，用数字 $0$ 和 $1$ 表示。这样我们就可以得到一个由数字 $0$ 和 $1$ 组成的集合。这个集合里的元素**要么是 $0$，要么是 $1$**。$\\$
**要么是 $0$，要么是 $1$**……这不就是二进制吗！所以我们就可以用一个二进制数来存储这些状态。用**一个**数来存储**一些**状态，这就是状态压缩的根本原理。
 $\\$
 
既然提到了状态压缩 dp，那我就顺便讲一下状态压缩 dp 里一些常见的基本操作吧。
- 查询集合 $S$ 的第 $i$ 位是否为 $1$（从 $0$ 开始）：`(S>>i)&1`或`S&(1<<i)`。
- 将集合 $S$ 的第 $i$ 位置 $0$（从 $0$ 开始）：`S^(1<<i)`或`(S>>i)^1`。
- 将集合 $S$ 的第 $i$ 位置 $1$（从 $0$ 开始）：`S|(1<<i)`或`(S>>i)|1`。

其实有关状态压缩的二进制操作就这么些，关键是如何运用这些操作来解决问题。这些操作只是来帮助你解决问题的，所以关键还是具体思路。
# 具体思路
虽然是叫状态压缩 dp，但是他的本质依然是 dp。万变不离其宗，既然是 dp，那三要素可不能少。
## 状态
首先不难想到用一个二进制状态来表示选了哪些数字，但接下来我们还需要什么呢？当你实在想不到还需要什么时，你可能会认为应该没有了。但当你再一次读题时，你发现你还忽略了一个限制条件，那就是相邻两个数的限制。那这该怎么办呢？既然是相邻两个数，那必然有前一个数和后一个数，所以我们还得再设一个状态 $last$ 表示最后一个数是多少。这下应该是可以了。
## 边界
不难想到，当只有一个数的时候，此时肯定只要一种方案，所以可以很容易确定边界：
 $$dp_{2^{i-1},i}=1$$
## 转移
接下来来到最难的一步：转移。我们知道，这题只限制相邻两个数，那我们已经知道了前一个数，只需要枚举后一个数就行了。
$\\$

具体的，枚举 $next$ 为下一个数，当然，这个数肯定不是出现在原集合中的，如果 $last$ 和 $next$ 满足条件，那么就定义新集合 $newS=S+next$，让 $dp_{newS,next}$ 加上 $dp_{S,last}$ 就行啦！
# 参考代码

```cpp
#include<bits/stdc++.h>
#define int long long//不开long long见祖宗
using namespace std;
int n,a[20];
int dp[1<<20][20];
int pop_count(int x)
{
    int cnt=0;
    while(x)
     {
        if(x&1) cnt++;
        x>>=1;
     }
    return cnt;
}//统计二进制数中1的数量
signed main()
{
    cin>>n;
    for(int i=1;i<n;i++) cin>>a[i]; //输入
    for(int i=1;i<=n;i++) dp[1<<i-1][i]=1;//边界（初始化）
    for(int s=1;s<(1<<n)-1;s++)
     for(int i=1;i<=n;i++)//同题解中的last
      if((s>>i-1)&1)//如果i属于s 
       {
           int k=pop_count(s);//计算i是第几位
           for(int j=1;j<=n;j++)//同题解中的next
            if(!((s>>j-1)&1))//如果j不属于s
             {
                if(a[k]^(i+1==j)) continue;//如果不满足条件限制，则重开
                int new_s=s|(1<<j-1);
                dp[new_s][j]+=dp[s][i];//状态转移
             }
       }
    int ans=0;
    for(int i=1;i<=n;i++) ans+=dp[(1<<n)-1][i];//计算答案
    cout<<ans;
    return 0;
}
```

---

## 作者：jzl_1210 (赞：1)

此题注意到数据范围 $1 \le N \le 15$，且最后的问题是有多少种满足条件的连续数组，于是容易想到状压 DP。

# 解题过程

首先我们想该如何设计状态呢？首先第一维 $i$ 想表示的是用到了哪些数，所以用 $i$ 的二进制来表示这些状态。那么会不会有第二维呢？因为题目中还规定了两个相邻的数组元素的关系，所以还要有第二维 $j$ 表示的是以 $j$ 为结尾。于是就确定了状态：$dp_{i,j}$ 表示在 $i$ 的二进制下用到了一些数，并以 $j$ 为结尾，这样子有多少种满足条件的连续数组。

确定状态是较难的一步，接下来就还好了。如何初始化？显然初始化只用一个数的情况，十分容易。

接下来就到了状态转移，我们先枚举 $i$ 和 $j$，注意 $j$ 在先前是要用到的，再枚举一个数 $k$ 为 $j$ 后面相邻的数（需要注意 $k$ 在先前没有用到），当 $k$ 满足相邻元素的关系时，就可以进行状态转移，令加入 $k$ 后的状态压缩成二进制后变成了 $x$，就可以进行状态转移：
$$
dp_{x,k} = dp_{x,k} + dp_{i,j}
$$
最后答案就是把所有数字结尾的情况相加即可。

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 15;
int n;
ll dp[1 << N][N + 5];
bool pd[N + 5];
int js(int x){//计算x的二进制下有多少个1 
	int ct = 0;
	while(x){
		if(x & 1) ct++;
		x >>= 1;
	}
	return ct;
}
int main(){
	cin >> n;
	for(int i = 1;i < n;i++) cin >> pd[i];
	//初始化 
	for(int i = 0;i < n;i++) dp[1 << i][i] = 1;
	int z = 1 << n;
	for(int i = 1;i < z;i++){//第一层循环i 
		for(int j = 0;j < n;j++){//第二层循环j 
			if(!(i & (1 << j))) continue;//j一定是用到的，不满足条件就到不了下一层循环 
			int wz = js(i);//这是为了算一共用了几个数 
			for(int k = 0;k < n;k++){//枚举k 
				//条件1：k在先前没有出现
				//条件2：满足这两个元素之间的关系 
				if(!(i & (1 << k)) && (pd[wz] == 1 && k == j + 1 || pd[wz] == 0 && k != j + 1)){
					dp[i | (1 << k)][k] += dp[i][j];//状态转移 
				}
			}
		}
	}
	ll ans = 0;
	//统计答案 
	for(int i = 0;i < n;i++) ans += dp[z - 1][i];
	cout << ans;
	return 0;
}
```

---

## 作者：yedalong (赞：1)

## Solution

这道题目有点难看出该如何设计状态。但是我们注意到题目中所说的 $nums$ 中的元素取值范围为 $1∼N$，就发现我们的状态 $i$ 其实表示一个数字是否用过，然后还要另有一个状态 $j$ 表示最后一个用到的数字，那么这道题目就很简单了。另外枚举一个数字 $k$，可得出状态转移方程，读者自证不难。

$$
dp_{i,j}=dp_{i,j}+dp_{i-2^j,k}
$$

但这个方程并不是随便乱用的，还得符合题目要求。还得判断 $j$ 和 $k$ 是有序还是无序，具体的可以看代码。

至于初始化，当然是以每个数字开头的情况赋值为 $1$，其他的为 $0$。答案的话，就是

$$\sum_{i=0}^{n-1}{dp_{2^n-1,i}}$$

将以不同数字结尾的每种情况统计起来即可。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,a[16],dp[1<<16][16];
int num(int x){//这个num是用于计算一个数字在二进制下有多少个 1
	int res=0;
	while(x){
		x-=x&(-x);
		res++;
	}
	return res;
}
signed main(){
	cin>>n;
	for(int i = 1;i<n;i++) cin>>a[i];
	for(int i = 0;i<n;i++) dp[1<<i][i]=1;
	for(int i = 1;i<1<<n;i++){
		for(int j = 0;j<n;j++){
			if(i&(1<<j)==0) continue;
			for(int k = 0;k<n;k++){
				if(j==k||i&(1<<k)==0) continue;
				if(a[num(i)-1]==0&&j==k+1) continue;
				if(a[num(i)-1]&&j!=k+1) continue;
				dp[i][j]+=dp[i^(1<<j)][k];
			}
		}
	}
	int ans=0;
	for(int i = 0;i<n;i++) ans+=dp[(1<<n)-1][i];
	cout<<ans;
	return 0;
}
```

---

## 作者：chen_kun (赞：1)

# 题解：P12236 [蓝桥杯 2023 国 Java A] 连续数组

## 思路简述

题意很好理解，不再过多赘述。

看到 $n$ 的取值范围那么小，第一时间想到记忆化搜索，但仔细审完题发现状压 DP 更简单。

理论上来看题解的应该都知道什么是状压 DP，但还是简单介绍一下。

所谓状压 DP，其精髓在于状态压缩，通过将状态转化为二进制的方式进行动态规划，利用二进制中只有 $1$ 和 $0$ 的特性表示某点是否达到某个目的。

定义 $dp_{i,j}$ 为当使用的状态为 $i$，最后用的一个数为 $j$ 时共有几种方案。其中状态 $i$ 中 $1$ 为用过，$0$ 为没用过。

接下来很简单了，遍历所有状态，记录下每种状态中用了几个数，用变量 $pos$ 记下来。再枚举数字 $j$ 和 $k$，表示当前状态下最后一个用的数为 $j$，下一个要用的数为 $k$。转移也很简单，无非是 `dp[i|(1<<k-1)][k]+=dp[i][j];`。转移之前记得判一下 $a_{pos}$ 是 $1$ 还是 $0$。根据题目条件，如果是 $0$ 只有 $k=j+1$ 时才可以转移，否则只有 $k\ne j+1$ 时才可转移。我的代码里使用三目运算符来判断的，如果太丑的话注释里的内容是等价的。

## 代码呈现

### C++


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=16;
int n,a[N],dp[1<<N][N],ans;
signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++) cin>>a[i],dp[1<<i-1][i]=1;//输入的同时初始化 
	dp[1<<n-1][n]=1; 
	int num=1<<n;
	for(int i=0;i<num;i++){
		int pos=0,temp=i;
		while(temp){
			pos+=(temp&1);//计算已用过的数字的数量 
			temp=temp>>1;
		}
		for(int j=1;j<=n;j++){
			if(!(i>>j-1)&1) continue;//确保j在i中 
			for(int k=1;k<=n;k++){
				if((i>>k-1)&1) continue;//确保k不在i中 
				if(a[pos]) dp[i|(1<<k-1)][k]+=(k==(j+1)?dp[i][j]:0);//转移方程，注释中的代码作用相同 
				else dp[i|(1<<k-1)][k]+=(k!=(j+1)?dp[i][j]:0);
				/*
				if(a[pos]){
					if(k==j+1) dp[i|(1<<k-1)][k]+=dp[i][j];
				}
				else{
					if(k!=j+1) dp[i|(1<<k-1)][k]+=dp[i][j];
				}
				*/
			}
		}
	}
	for(int i=1;i<=n;i++) ans+=dp[num-1][i];//累加不同数字作为末尾时的方案数 
	cout<<ans;
	return 0;
}
```
### Java
```java
import java.util.Scanner;
public class Main {
    static final int N=16;
    static int n,a[]=new int[N];
    static long dp[][]=new long[1<<N][N],ans;
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        n=sc.nextInt();
        for(int i=1;i<n;i++){a[i]=sc.nextInt();dp[1<<i-1][i]=1;}
        dp[1<<n-1][n]=1;
        int num=1<<n;
        for(int i=0;i<num;i++){
            int pos=0,temp=i;
            while(temp!=0){pos+=(temp&1);temp>>=1;}
            for(int j=1;j<=n;j++){
                if(((i>>j-1)&1)==0)continue;
                for(int k=1;k<=n;k++){
                    if(((i>>k-1)&1)!=0)continue;
                    if(a[pos]!=0)dp[i|(1<<k-1)][k]+=(k==j+1?dp[i][j]:0);
                    else dp[i|(1<<k-1)][k]+=(k!=j+1?dp[i][j]:0);
                }
            }
        }
        for(int i=1;i<=n;i++)ans+=dp[num-1][i];
        System.out.println(ans);
    }
}
```

## The end.

---

## 作者：Suite_No1_G (赞：1)

~~时隔大半年再次写题解~~

我们首先观察数据范围，发现 $N ≤ 15$，又发现题目是一个计数题，我们会很自然的想到状态压缩动态规划。

我们设计如下状态：$dp_{status},_{end}$ 表示目前元素的二进制使用情况为 $status$，当前最后一个元素为 $end$。使用情况具体为用过为 $1$，没有用过为 $0$。

进行动态规划转移前我们需要初始化。由于第一个元素没有限制，任何一个数都可以作为第一个数组元素，所以 $dp_{2^i},_i=1$，$i$ 在 $0$ 到 $N-1$ 区间内。为了方便起见我把每一个元素都减去了 $1$，所以任何下标和数都是从 $0$ 开始的。

此时我们枚举接下来的一个元素，令其为 $nxt$。我们首先要确定这个元素没有被使用过，即在 $status$ 中的 $nxt$ 位是 $0$。我们还需要根据输入的数组来判断此时是否需要连续。如果满足要求，则进行转移。

最后，我们计算答案。由于每一个数都被用过了，所以状态必然为 $2^N-1$，但是我们不知道最后一个元素是什么，所以我们需要枚举每一种情况，并把所有可行的方案数相加从而得到最后答案。

总的时间复杂度为 $O(2^N×N^2)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=17;
int a[maxn];
int dp[1<<maxn][maxn];

signed main(){
	int n;
	scanf("%lld",&n);
	for (int i=0;i<n-1;i++) scanf("%lld",&a[i]);
	
	for (int i=0;i<n;i++) dp[1ll<<i][i]=1;
	
	for (int status=0;status<(1ll<<n);status++){
		int len=0;//len用来统计目前是第几个元素
		
		for (int i=0;i<n;i++){
			if ((status&(1ll<<i))) len++;//数已经用过了几个数
		}
		len--;
		
		for (int end=0;end<n;end++){
			if ((status&(1ll<<end))==0) continue;
			
			for (int nxt=0;nxt<n;nxt++){
				if ((status&(1ll<<nxt))) continue;
				
				if (a[len]==0){
					if (nxt!=end+1) dp[status|(1ll<<nxt)][nxt]+=dp[status][end];
				}else{
					if (nxt==end+1) dp[status|(1ll<<nxt)][nxt]+=dp[status][end];
				}
			}
		}
	}
	
	int sum=0;
	for (int i=0;i<n;i++) sum+=dp[(1<<n)-1][i];
	printf("%lld\n",sum);
	return 0;
} 
```

---


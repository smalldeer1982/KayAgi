# 伊甸园日历游戏

## 题目描述

Adam 和 Eve 玩一个游戏，他们先从 $1900.1.1$ 到 $2006.11.3$ 这个日期之间随意抽取一个日期出来。然后他们轮流对这个日期进行操作：

1. 把日期的天数加 $1$，例如 $1900.1.1$ 变到 $1900.1.2$；
2. 把月份加 $1$，例如：$1900.1.1$ 变到 $1900.2.1$。

其中如果天数超过应有天数则日期变更到下个月的第 $1$ 天。月份超过 $12$ 则变到下一年的 $1$ 月。而且进行操作二的时候，如果有这样的日期：$1900.1.31$，则变成了 $1900.2.31$，这样的操作是非法的，我们不允许这样做。而且所有的操作均要考虑历法和闰年的规定。

谁先将日期变到 $2006.11.4$ 谁就赢了。如果超越了指定日期不算获胜。

每次游戏都是 Adam 先操作，问他有没有必胜策略？

## 说明/提示



------------
2024/1/31 添加一组 hack 数据。

## 样例 #1

### 输入

```
3
2001 11 3
2001 11 2
2001 10 3
```

### 输出

```
YES
NO
NO
```

# 题解

## 作者：_Luminous (赞：28)

#### · 题意


------------
有t组数据，每次给定一个日期，两个人轮流对这个日期进行操作：天数+1或月份+1。先到达2006.11.4者赢。

#### · 解题思路 & 方法


------------
- 方法一：**记忆化搜索 + 简单博弈论**

~~提示是个好东西~~：
```
说明/提示
建议先把所有情况都算出来^_^
```
因此，我们可以用记搜来求出所有的情况——

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int t,x,y,z,f[2007][15][35],m[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
//，m数组存储每个月有多少天
bool vis[2007][15][35];
bool check(int year,int month,int day){//判断是否超过目标日期
	if(year<2006)
		return true;
	if(year==2006 && month<11)
		return true;
	if(year==2006 && month==11 && day<4)
		return true;
    return false;
}
int dfs(int year,int month,int day){
    if((year%4!=0 || year==1900) && month==2 && day==29)
		return 1;
    if(day>m[month])//若天数超过当前月的，则说明到了下一个月
		month++,day=1;//月份++，从1号重新开始
    if(month>12)//若已经超过了12个月，说明到了下一年
		year++,month=1;//年份++，从1月重新开始
    //说句闲话：相当于进位（？）
    if(vis[year][month][day])//如果已经查找过直接返回结果即可
		return f[year][month][day];
	vis[year][month][day]=1;//标记为已查找
    if(day<=m[month+1] && check(year,month+1,day))//注意，这里有个小细节：如果要改变月份，应先判断一下当前天数是否下一个月的天数（因为每个月的天数不一样）
		f[year][month][day]=((dfs(year,month+1,day))^1);//^1相当于取反，若是为1则返回0，若是为0则返回1
    if(check(year,month,day+1))
		f[year][month][day]|=((dfs(year,month,day+1)^1));
    return f[year][month][day];
}

int main(){
    f[2006][11][3]=1;
    dfs(1900,1,1);//从1900年1月1日开始搜索
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&x,&y,&z);
        if(f[x][y][z])
        	printf("YES\n");
        else
        	printf("NO\n");
    }
    return 0;
}
```
- 方法二：**DP + 逆推**

------------
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int t,x,y,z,f[2007][13][32],m[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
void dp(){
    int year=2006,month=11,day=4;//从目标日期开始逆推
    f[2006][11][4]=1;//注意，这里要赋值为1，不然会玄学WA（别问我咋知道的
    while(!(year==1900 && month==1 && day==1)){
        int y1=year,m1=month,d1=day;
        day--;
        if(day==0){//说明这一个月已经推完了
        	month--;//继续倒着推上一个月
            if(month==0)//若是这一年都推完了
            	month=12,year--;//（同理）
        	day=m[month];
        	if(((year%4==0 && year%100!=0) || year%400==0) && month==2)
				day++;//若是闰年的二月份，天数++
        } 
        if(f[y1][m1][d1]==1){//如果当前这个日期不满足
			f[year][month][day]=2;//则说明上一个（因为是逆推）日期满足
			continue;         //因为是这两个人轮流进行操作
		}
    	y1=year;m1=month+1;d1=day;
    	if(m1==13)//（进位~）
        	y1++,m1=1;
        if(f[y1][m1][d1]==1)//同上
        	f[year][month][day]=2;
        else
			f[year][month][day]=1;
    } 
}
int main(){
    dp();
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&x,&y,&z);
        if(f[x][y][z]==2)
        	printf("YES\n");
        else
        	printf("NO\n");
    }
    return 0; 
}
```
- 方法三：**规律**

------------
首先不看年份，每次操作必定会使日期和月份的和的奇偶性发生变化。目标日期11.4（11+4=15）是奇数。而天数或月份+1都会导致其和的奇偶性发生改变。

但是要注意两个特殊的日期 ：9月30日(日+1为10.1，月+1为10.30)和11月30日（日+1为12.1，月+1为12.30），奇偶性可能是保持不变的，但是因为Adam足够聪明（），所以可以通过加月份来避开这一天，因此若是日期一开始是偶数或者是这两天，先者赢，否则后者赢。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int t,x,y,z;
int main(){
	scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&x,&y,&z);
		if((y==9 && z==30) || (y==11 && z==30) || (y+z)%2==0)
        	printf("YES\n");
		else
        	printf("NO\n");
    }
	return 0;
}
```


---

## 作者：SIXIANG32 (赞：14)

这是一道非常好玩的题目。  
闲话少说，切入正题——

---
第一眼看上去：诶这不是博弈论吗？   
完了博弈论我不会（准备继续找题）。  
看看标签：模拟？搜索？数论？记搜？  
（吓得我吃了一惊.jpg）  
作为一个菜菜的 OIer，我决定找找规律。

---

所以说这道题我们应该认真的分析一下。  
首先，显然 2006/11/4 是必败的，因为怎么动也动不了。  
那么，2006/11/3 就是必胜。  
2006/11/2 就是必败。  
然后就以此类推不拉不拉不拉  

在我们这样近似于找规律的方法中，我们会发现，当 $(m+d)\mod 2=0$ 时（$m$ 为月份，$d$ 为天），必胜；$(m+d)\mod 2=1$ 时，必败。这是因为在我们找规律的时候，开始 $(m+d)\mod 2=1$，而且没倒推一次情况发生改变。那么就可以得出以上结论。  

然后你就可以愉快的写代码啦~  

---
But！我们还要手动模拟一些极端情况来验证啊。  
这里的极端情况显然是月末天数 $+1$。  
通过手动验算，我们会发现两个特例独行的日期，那就是 **9/30** 和 **11/30**。  

为什么呢？因为在八月份的时候，就很不规矩的变成了和七月份一样的 31 天，规律被打破，本来的 $+1$ 天规律的月份就被取反，这个时候，月份加 1 可以变成必胜。  
（感性理解）

---
好啦，我们梳理一下：  
1. 特判 $m=9,d=30$，此时为必胜。
2. 特判 $m=11,d=30$，此时为必胜。
3. 判断 $(m+d)\mod 2=0$ 此时为必胜

```cpp
#include<cstdio>
int main()
{
	int n,x,y,z;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d%d",&x,&y,&z);
		if((y==9&&z==30)||(y==11&&z==30)||((y+z)%2==0))puts("YES");
		else puts("NO");
	}
}
```

---

## 作者：tjtdrxxz (赞：9)

看到数据范围，先写暴搜试试。

首先，我们肯定是要把每月的天数给打出来（因为二月的天数在闰年的时候会变）。

```cpp
int day[2][13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 
0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

好，那我们每次往下递归的时候就把日期或者月份加一，注意边界判断（在每年，每月的变化时）。

但是只有这样是不够的，经过一顿暴搜，可以发现我们经常会递归到重复的月份，而我们是知道从这些月份开始的胜负的，但只记录胜负情况是不够的，我们应该记录的是当前是谁先手，如果先手能赢，那后手就不能赢，按照这个思路，我们可以轻松打出记忆化后的代码（小提醒，如果年份能被 $ 100 $ 整除，那他需要能被 $ 400 $，整除才行捏。）。

```cpp
int dfs(int y, int m, int d, int p){
    if(y > 2006) return -1;
    if(y == 2006 && m > 11) return -1;
    if(y == 2006 && m == 11 && d > 4) return -1; //超过范围了，直接返回。
    if(~f[y - 1900][m][d][p]) return f[y - 1900][m][d][p];// y - 1900 是为了省空间
     
    int res = -1;
    if(day[year(y)][m] > d){ // year(y) 是判断当前是否是闰年。
        res = check(res, dfs(y, m, d + 1, p ^ 1), p);
    }//如果不是本月最后一天，d 直接 +1。
     
    else if(m == 12){
        res = check(res, dfs(y + 1, 1, 1, p ^ 1), p);
    } //现在是 12 月，直接下一年。
     
    else{
        res = check(res, dfs(y, m + 1, 1, p ^ 1), p);
    }//只是下一月。
     
    if(m == 12){
        res = check(res, dfs(y + 1, 1, d, p ^ 1), p);
    }当前是 12 月，直接下一年，天数不变。
     
    else if(day[year(y)][m + 1] >= d){
        res = check(res, dfs(y, m + 1, d, p ^ 1), p);
    }//如果下一月的天数大于现在的天数再往下递归，不然会出现 2 月 31 号这种逆天日期。
     
    return f[y - 1900][m][d][p] = res;
}
```
完结撒花！

---

## 作者：ChampionCyan (赞：3)

~~一个找找规律就能做的水题。~~

先放码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
	scanf("%d", &t);
    while(t--){
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
		if((y == 9 && z == 30) || (y == 11 && z == 30) || (y + z) % 2 == 0)
            printf("YES\n");
		else
            printf("NO\n");
    }
	return 0;
}
```

目标日期月和日的是奇数，不难发现**大部分情况下**双方各操作一回合后奇偶性仍然不变，因此**大部分情况下**若开始时月和日的和为奇数 Adam 必败，为偶数 Adam 必胜。

但是有两个特殊日期：$9$ 月 $30$ 日和 $11$ 月 $30$ 日，此时加日奇偶性不变！

所以让我们思考以下内容：

若开始时月和日的和为偶数，Adam 可以通过加月份避免操作后奇偶性不变导致必败，所以若月和日的和已经是偶数可以不管这个条件，还是 Adam 必胜。但是若开始时就是这两个日期，Adam 加日就能避免操作后奇偶性变化保证必胜。

总而言之：

开始时日期月和日的和为偶数、正好是 $9$ 月 $30$ 日或者 $11$ 月 $30$ 日三个满足其中一个则 Adam 必胜，否则必败。

---

## 作者：_CHO (赞：3)

这题在我的任务计划里吃灰了大半年

因为感觉这题很数学

最近重新看了看发现这不就是个大爆搜吗？？

------------

这题的基本思路是预处理出所有日期的输赢策略，然后$O(1)$回答每个询问。

首先我们从1900年1月1日搜起，访问日期的每一个**合法**的后继状态。关于判断某个即将访问的日期是否合法，可以用一个$check$函数判断。

需要判断的条件有

1. 平年的二月份有28天，闰年有29天

2. 这一月份的这一天是否存在，例如，6.31就不是一个合法的日期，需要返回$false$

3. 当前日期是否超过了2006.11.4.


当然我们需要注意日期的进位问题，例如当出现日期为1900.12.31或1900,13,1应立刻将其进为1901,1,1.

~~当然这些都是代码细节很简单的~~

一旦搜到目标日期就立刻停止。同时返回假。（这很显然，因为如果游戏从2006,11,4开始，Adam还没有开始操作游戏就结束了，则根据题意和我们的搜索过程应当为Adam输）。又显然其前驱状态应为真，即Adam必赢。所以我们可以用异或来联系相邻两个日期的胜负状态。


Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p[14]={0,31,29,31,30,31,30,31,31,30,31,30,31,31};
bool f[2020][13][32];
bool vis[2020][13][32];
inline bool check(int y,int m,int d){
	if(d>p[m]) d=1,++m;
	if(m>12) m=1,++y;
	if(y>2016) return false;
	if(y==2016&&m>11) return false;
	if(y==2016&&m==11&&d>4) return false;
	if((y%4!=0||y==1900)&&m==2&&d>28) return false;
	return true;
}
inline bool dfs(int y,int m,int d){
	if(d>p[m]){
		d=1;++m;
	}
	if(m>12){
		m=1,++y;
	}
	if(y==2016&&m==11&&d==4) return false;
	if(vis[y][m][d]) return f[y][m][d];
	vis[y][m][d] = true;
	if(d<=p[m+1]) if(check(y,m+1,d))f[y][m][d] |= dfs(y,m+1,d)^1;
	if(check(y,m,d+1)) f[y][m][d] |= dfs(y,m,d+1)^1;
	return f[y][m][d];
}
int main(){
	dfs(1900,1,1);
	int n;
	cin>>n;
	while(n--){
		int y,m,d;
		cin>>y>>m>>d;
		printf("%s\n",f[y][m][d]?"YES":"NO");
	}
	return 0;
}
```

---

## 作者：Buried_Dream (赞：2)

## 题意：

多组数据，每组数据都会给定一个合法的日期，有两种操作方案，一种是天数加 $1$，另一种是月份加 $1$, 当有人操作后的日期为不合法的时候游戏结束，此时这人输了。

## 思路：

正常思路的话应该是记忆化搜索，但标签里带着数论，那就用数学方法来做。

首先想想什么时候操作下一步会输，首先年份对其没有影响，只有月份和日期会对答案产生影响，那就只考虑月份和日期，题目规定是 `Adam` 先手操作，当天数和日期加起来时为偶数，此时必胜，奇数必败，$9$ 月 $30$ 和 $11$ 月 $30$号都是必胜的。

## 证明：

首先先来证明为什么天数和日期加起来为偶数时必胜。

因为 $2001.11.4$ 是必败的，因为已经到了最后一天，无法操作了，所以说当他操作到 $2001.11.3$ 时是必胜的，那 $2001.11.2$ 就是必败的，以此类推……

因为前面说到了年份并没有影响，所以只考虑月份和日期。

|  必胜 | 必败  |
| :----------: | :----------: |
|  11.3 |  11.4 |
|  11.1 |  11.2 |
|  10.30|  10.31|
|  10.28|  10.29|
|  10.26|  10.27|

### 由此可以推出：

当月份加日期和为偶数时必胜，月份加日期和为奇数时必败。

于是交上去会发现只有 $50$ 分，因为只有两个测试点，也就是说有特殊情况没有考虑到。

当 $9.30$ 和 $11.30$ 时，日期加 $1$ 是 $10.1$ 和 $12.1$, 月份加 $1$ 是
$10.30$ 和 $12.30$,此时可以通过月份加 $1$ 来避开这两天，所以只需要多打个特判就可以了。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e7 + 10;
const int MAXN = 1e3 + 32;

int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(ch  < '0' || ch > '9') {if(ch == '-') w = -1;ch = getchar();}
	while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
	return s * w;
}
int stc[maxn], sc = 0;
int main() { 
	int n = read();
	for(int i = 1; i <= n; i++) {
		int a = read(), b = read(), c = read();
		if(b == 9 && c == 30 || b == 11 && c == 30 || (b + c) % 2 == 0) stc[++sc] = 1;
		else stc[++sc] = 0;
}
	for(int i = 1; i <= sc; i++) {
		if(stc[i] == 1)	{
			cout << "YES\n";
		}
		else cout <<"NO\n";
	}
return 0;
}
```


---

## 作者：xinxin2022 (赞：1)

明显的博弈论。

首先年份没用，两个人可以一人一个月的取，因为一年的月数是偶数，所以在若干个完整的回合后一定可以将日期变为 $2006.y.z$。

然后就是考虑月和日对胜负的影响。

发现无论对月份操作还是对天数操作，操作完后都会月份与天数之和的奇偶性发生变化，因此现在题目变成了判断 $y+z$ 的奇偶性。

显然，当 $y+z \bmod 2 = 0$ 时，由于 `Adam` 是先手，因此 `Adam` 必胜，反之则必败。

然后你交上了 ~~die~~ 代码，然后[ WA 了](https://www.luogu.com.cn/record/173595073)。

显然有些东西我们没考虑到，写个程序循环一年里所有可能的操作，发现 $9.30$ 和 $11.30$ 这两天如果使天数加一，那么月份与天数之和的奇偶性并不会改变，此时 `Adam` 便可以利用这两天反败为胜。

特判一下就[ AC 啦](https://www.luogu.com.cn/record/173603592)。

附上超短代码：


```cpp
#include<iostream>
int t,x,y,z;
int main(){
    std::cin>>t;
    while(t--){
        std::cin>>x>>y>>z;
        std::cout<<(((y+z)%2==0||(y==9&&z==30)||(y==11&&z==30))?"YES\n":"NO\n");
    }
}
```

---

## 作者：O_v_O (赞：0)

## 题意

Adam 和 Eve 玩一个游戏，他们先从 $1900.1.1$ 到 $2006.11.3$ 这个日期之间随意抽取一个日期出来。然后他们轮流对这个日期进行操作：

1. 把日期的天数加 $1$，例如 $1900.1.1$ 变到 $1900.1.2$；
2. 把月份加 $1$，例如：$1900.1.1$ 变到 $1900.2.1$。

其中如果天数超过应有天数则日期变更到下个月的第 $1$ 天。月份超过 $12$ 则变到下一年的 $1$ 月。而且进行操作二的时候，如果有这样的日期：$1900.1.31$，则变成了 $1900.2.31$，这样的操作是非法的，我们不允许这样做。而且所有的操作均要考虑历法和闰年的规定。

谁先将日期变到 $2006.11.4$ 谁就赢了。如果超越了指定日期不算获胜。

每次游戏都是 Adam 先操作，问他有没有必胜策略？

## 思路

我们看到这道题第一想法就是对其搜索，因为题目中给出了两种变法，由于这道题的拓扑序不明显，所以我们采用记忆化搜索即可，然后在按照题目要求模拟。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int t;
int sum[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
bool dp[2007][12][32], vis[2007][12][32];

bool check(int year, int month, int day) { // 检查是否超过了规定年份
  if (year < 2006)
    return 1;
  if (year == 2006 && month < 11)
    return 1;
  if (year == 2006 && month == 11 && day < 4)
    return 1;
  return 0;
}

bool dfs(int year, int month, int day) {
  if ((year % 4 != 0 || year == 1900) && month == 2 && day == 29) 
    return 1;
  if (day > sum[month]) 
    day = 1, month++;
  if (month > 12)
    month = 1, year++;
  if (vis[year][month][day]) // 记忆化
    return dp[year][month][day];
  vis[year][month][day] = 1;
  // 两种情况
  if (day <= sum[month + 1] && check(year, month + 1, day)) 
    dp[year][month][day] |= dfs(year, month + 1, day) ^ 1;
  if (check(year, month, day + 1))
    dp[year][month][day] |= dfs(year, month, day + 1) ^ 1;
  return dp[year][month][day];
}

int main() {
  dp[2006][11][3] = 1;
  dfs(1900, 1, 1);
  int t;
  cin >> t;
  while (t--) {
    int x, y, z;
    cin >> x >> y >> z;
    cout << (dp[x][y][z] ? "YES" : "NO") << endl;
  }
  return 0;
}
```

---

## 作者：xuan_gong_dong (赞：0)

## 题面

[P1512 伊甸园日历游戏](https://www.luogu.com.cn/problem/P1512)

## 分析

考虑最后状态 $11$ 月 $4$ 日中 $11+4=15$ 为奇数，并且该题正常情况下月份与日期的增加会使得日期加月份的和发生奇变偶，偶变奇的变化。则：一般地，当输入的日期与月份的和为偶数时，后手赢，反之先手赢。

考虑特殊情况 

- $4$ 月 $30$ 日和 $6$ 月 $30$ 日加一天仍然为偶数，不过显然月份加一再操作就行了，此时仍为后手赢。

- $2$ 月 $28$ 日加一天为偶数，与上述特殊情况同理，仍为后手赢。

- $9$ 月 $30$ 日和 $11$ 月 $30$ 日后手可以避免先手赢，此特殊情况后手赢。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
//	freopen("cal.in","r",stdin);
//	freopen("cal.out","w",stdout);
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if((y+z)&1)
		{
			if(y==9||y==11)
			{
				if(z==30)
				{
					puts("YES");
					continue;
				}
			}
			puts("NO");
			continue;
		}
		puts("YES");
	}
	return 0;
}
```

---

## 作者：Special_Tony (赞：0)

### 思路：

很明显是博弈论，我们可以找规律求解。

考虑月份和日期，题目规定是  ```Adam``` 先手操作，所以可以得出以下规律：

1. 月数 $+$ 日数为奇数时必败，偶数时必胜。

2. $9$ 月 $30$ 日与 $11$ 月 $30$ 日必败。

这道题就做完了。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,a,b,c;
void solve(){
	cin>>a>>b>>c;
	if(b==9&&c==30||b==11&&c==30||(b+c)%2==0) cout<<"YES"<<endl;
	else cout<<"NO"<<endl;
}
int main(){
    ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--) solve();
 	return 0;
}
```

---

## 作者：_Lightning_ (赞：0)

### 题目大意

两人轮流，每次可加一年或一月，问先手是否有必胜策略。

### 分析

这道题问必胜策略，很明显是博弈论。什么是博弈论？我们来举一个简单的例子：

$A$ 和 $B$ 玩一个游戏，由 $A$ 先指定一个 $\le 5$ 的数，然后从 $B$ 开始，每次加 $1 \sim 3$，谁先加到 $15$，谁就获胜了。

在上述游戏中，很明显我们加到 $15$，就获胜了，我们先把 $15$ 称为 “必胜态”。那换而言之，让对手加到 $15$，我们就必败了，称为 “必败态”。加到 $15$ 的必败态有：

$12,13,14$

这时，我们又发现，$11$ 可以加到所有的必败态，这说明什么？我们到 $11$ 后，对手不管加几，我们都可以加到 $15$！那么，$11$ 就也是必胜态。

那么，你们发现规律了吗？从 $15$ 开始，每减去 $4$，就会产生一个必胜态，减到最后会剩下一个 $3$，说明 $3$ 是必胜态，所以，$A$ 只要指定 $3$，再与 $B$ 加的数凑 $4$，$A$ 就必胜。

读到这，相信你对博弈论已经有了一个初步的认识了。我们再回到这题，这题中 $2006.11.4$ 必胜（你都到了，还不赢就离谱），$11.3$ 必败，以此类推。

不过，这道题稍微麻烦，要判断闰年、大月、小月等一些~~恶心~~重要的细节，得多费点心思。

### 总结

我的方法就是把所有日期是必胜态还是必败态算出，希望能对观众老爷们有一些帮助。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int T, y, m, d;
int main()
{
    cin >> T;
    while(T--)
    {
        cin >> y >> m >> d;
        if(m == 9 && d == 30 || m == 11 && d == 30 || !((m + d) & 1))
			cout << "YES" << endl;
        else 
			cout << "NO" << endl;
    }
    return 0;
}
```

---

## 作者：MattL (赞：0)

[链接](https://www.luogu.com.cn/problem/P1512)

博弈&数论题

---

**题意：**

>有 $n$ 个日期，两个人每次把月份或日数 $+1$，超过变成下一年或月，$2006$ 年 $11$ 月 $4$ 日赢，问先手能否必胜？

---

**解题：**

我们从 $2006$ 年 $11$ 月 $4$ 日开始倒推。

则 $2006$ 年 $11$ 月 $3$ 日与 $2006$ 年 $10$ 月 $4$ 日必胜。

$2006$ 年 $11$ 月 $2$ 日与 $2006$ 年 $10$ 月 $3$ 日与 $2006$ 年 $11$ 月 $2$ 日必败。

容易看出，月数 $+$ 日数为奇数时必败，偶数时必胜。

但是，由于 $7$ 月和 $8$ 月是连续的大月，所以后面情况相反，特判 $9$ 月 $30$ 日与 $11$ 月 $30$ 必败。

总结：

1. 月数 $+$ 日数为奇数时必败，偶数时必胜
2. $9$ 月 $30$ 日与 $11$ 月 $30$ 必败

---

**代码：**

博弈题代码极短！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,y,m,d;
int main()
{
    cin>>n;
    while(n--)
    {
        cin>>y>>m>>d;
        if(m==9&&d==30||m==11&&d==30||!((m+d)&1))cout<<"YES\n";
        else cout<<"NO\n";
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

我看题时第一个想到的就是找规律，事实证明我想的没错。

### 问题摘要

有多组数据，每组数据都会给定一个合法的日期，有两种操作方案，一种是天数加 $11$，另一种是月份 $11$， 当有人操作后的日期为不合法的时候游戏结束，此时这人输了。

### 思路

首先不看年份，每次操作必定会使日期和月份的和的奇偶性发生变化。目标日期 $11.4$（$11+4 = 15$）是奇数。而天数或月份 $+1$ 都会导致其和的奇偶性发生改变。

但是要注意两个特殊的日期：$9$ 月 $30$ 日（日 $+1$ 为 $10.1$，月 $+1$ 为 $10.30$）和 $11$ 月 $30$ 日（日 $+1$ 为 $12.1$，月 $+1$ 为 $12.30$），奇偶性可能是保持不变的，但是因为Adam足够聪明，所以可以通过加月份来避开这一天，因此若是日期一开始是偶数或者是这两天，先者赢，否则后者赢。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int t;

int main() {
    scanf("%d", &t);
    while (t--) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        if ((y == 9 && z == 30) || (y == 11 && z == 30) || (y + z) % 2 == 0)
            printf("YES\n");
        else
            printf("NO\n");
    }
}
```


---


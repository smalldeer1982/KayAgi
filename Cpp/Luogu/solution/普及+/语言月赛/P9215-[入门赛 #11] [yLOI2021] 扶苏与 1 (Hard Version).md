# [入门赛 #11] [yLOI2021] 扶苏与 1 (Hard Version)

## 题目背景

**本题与 Easy Version 的区别是：$x$ 的范围不同，$y$ 的长度限制不同**。

**请注意 Easy Version 和 Hard Version 不是严格的包含关系。**

扶苏在 ICPC2022 EC Final 的比赛里，开局不到五分钟，就读假了一道题，把一道数位 DP 开成了简单签到，狠狠地演了队友一把。

为了不让读假了的题被浪费，所以这道题出现在了这里。

## 题目描述

扶苏给了你一个数字 $x$，你需要给她一个数字 $y$，使得在列竖式计算 $x + y$ 时，能恰好产生 $k$ 个进位。

**你给出的 $y$ 的长度不能超过 $x$ 的长度。**（注意，这条要求与 Easy Version 不同）

**进位**的含义是：在进行竖式加法运算时，如果位于同一列上的数字之和（加上低位向上可能存在的进位）比 $9$ 大，则在结果的这一列上只保留这个和的个位数字，同时称这一位向它的高位产生了一个**进位**。

下图是一个竖式加法的例子，结果中标红的两位都向上产生了进位。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxkzrk4i.png)

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $0 \leq x < 10^{(10^4)}$，$1 \leq T \leq 5000$，$1 \leq k \leq 1+\log_{10}\max(1,x)$。输入的 $x$ 不含前导 $0$。

### 提示

输入的 $x$ 可能会很大。如果说 $x < 10^t$，则输入 $x$ 的**长度**不会超过 $t$。数据规模中式子 $k \leq 1 + \log_{10}\max(1,x) $ 的含义是：$k$ 不会超过 $x$ 的长度。

## 样例 #1

### 输入

```
5
1
1
14
1
514
2
1234
1
123456
6```

### 输出

```
9
8
516
7
877777```

# 题解

## 作者：Big_Dinosaur (赞：7)

### 题意
给出 $x$ ，要求你构造出一个长度不超过 $x$ 的整数 $y$ ，使计算 $x+y$ 时出现 $k$ 个进位。
### 核心思路
因为 $0$ 不能进位，其它数字可以。所以，我们可以把 $x$ 末尾的 $0$ 删掉，并统计个数，放在变量 $a$ 个 中，继续。

删掉 $0$ 之后，如果位数 $<k$ ，就输出 $-1$ 。

否则，建立 $s$ 字符串，如果 $x$ 包含非零数个数 $<k$ ，将非零数在 $s$ 字符串中对应位设 $9$ ,否则设 $0$ ，每设一个 $9$ ， $k$ 减 $1$ 。

接下来，在非零数之前的 $0$ ，因进位变成了 $1$ ，将对应位设 $9$ ，又产生进位，同时如果它前面有 $0$ ，那个 $0$ 变成了 $1$ ，加 $9$ 又会进位。所以，将后 $k$ 个 $0$ 对应位变成 $9$ ，就可以了。

如果 $x$ 包含非零书个数 $\ge k$ ，将前 $k$ 个非零数在 $s$ 字符串中对应位设 $9$ ,否则设 $0$ 。

最后，对于没有输出 $-1$ 的情况下，输出 $a$ 个 $0$ ，一组数据处理完成。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,k,a;string x,s;
void doit(){
	s="";a=0;
	while(x[x.size()-1]=='0'){
		x.erase(x.size()-1);++a;
	}
	if(x.size()<k){
		puts("-1");return;
	}
	for(int i=0;i<x.size();++i)if(x[i]=='0'||!k)s+='0';else{
		s+='9';--k;
	}
	for(int i=x.size()-1;i>=0;--i)if(x[i]=='0'&&k){
		s[i]='9';--k;
	}
	cout<<s;
	for(int i=1;i<=a;++i)putchar('0');puts("");
}
int main(){
	scanf("%d",&t);
	while(t--){
		cin>>x>>k;
		doit();
	}
}
```

---

## 作者：一扶苏一 (赞：6)

# 【构造】【P9215】扶苏与 1

## Description

给出一个数字串 $x$，求一个长度不超过 $x$ 长度的数字串 $y$，使得 $x + y$ 的竖式计算有恰好 $k$ 个进位，或报告无解。

$5000$ 组数据，$0 \leq x < 10^{(10^4)}$，$k$ 不超过 $x$ 的长度。

## Analysis

接下来我们称 $x$ 的最高位是第 $1$ 位，最低位是第 $n$ 位。『第 $i$ 位』指的是从左到右数第 $i$ 个位置。

首先能观察到一个简单的事实：如果第 $k$ 位不为 $0$，那么可以简单地构造一个前 $k$ 位是 $9$、后 $n - k$ 位是 $0$ 的数字 $y$ 来做到恰好 $k$ 个进位。例如，若 $x = 10101$，$k = 3$，那么构造 $y = 99900$ 可以在第 $1,2,3$ 位上构造出进位。

**证明**：  
首先第 $k$ 位之后都是 $0$，这些位置不会有进位。  
$x$ 的第 $k$ 位不为 $0$，加上 $9$ 一定会有 $1$ 的进位；  
假设第 $i$ 位（$1 < i \leq k$）产生了 $1$ 的进位，考虑 $y$ 的第 $i$ 位是 $9$，加上进上来的 $1$，再加上 $x$ 对应位的原数，得数一定不小于 $10$，所以一定会产生 $1$ 的进位。  
根据归纳假设，第 $1 \sim k$ 位都会产生进位，$k + 1\sim n$ 位没有进位，得证。

接下来考虑第 $k$ 位为 $0$ 时应该如何构造：

找到第 $k$ 位之前最后一个不为 $0$ 的位置 $p$（显然存在），然后根据上面的方法我们可以构造 $p$ 个进位。考虑构造剩下的 $k - p$ 个进位。

找到第 $k$ 位之后第一个不为 $0$ 的位置 $q$。如果这样的 $q$ 不存在，说明我们不能构造更多的进位，此时显然无解。

如果 $q$ 存在，我们来证明 $[p + 1, q - 1]$ 这段区间（显然这段区间里全部都是 $0$）的长度不小于 $k - p$。：  
这段区间的长度是 $q - 1 - (p + 1) + 1 = q - p - 1$。因为 $q > k$，所以 $q - p > k - p$。所以 $q - p - 1 \geq k - p$。

我们从第 $q$ 位起，向前填充 $k - p$ 个 $9$。也就是给 $[q - (k - p) + 1, q]$ 这段区间填充上 $9$。且给 $q - (k - p)$ 这个位置填充上 $0$。我们来证明这样构造出了 $k - p$ 个进位：  
因为 $x$ 第 $q$ 位不为 $0$，加上 $9$ 一定不小于 $10$，产生了一个进位。再用与前面类似的归纳，假设下一位产生了进位，那么加上 $y$ 这一位的 $9$，一定有进位。因为一共有 $k - p$ 个 $9$，所以一共构造出来了 $k - p$ 个进位。特别的，$q - (k - p) = p + (q - k) \geq p + 1 \in [p + 1, q - 1]$，所以 $x$ 第 $q - (k - p)$ 位也是 $0$，$y$ 的这一位也是 $0$，加上第 $q - (k - p) + 1$ 位的进位也不会有新的进位。所以我们恰好构造了 $k - p$ 个进位。

这样，我们在 $[1, p]$ 区间上构造了 $p$ 个进位，$[q - (k - p) + 1, q]$ 区间上构造了 $k - p$ 个进位。一共构造出了 $k$ 个进位。其他位置上全填充 $0$，不会产生新的进位。

以下两张图分别是 $k = 5$ 和 $k = 8$ 的例子，可以结合图片来理解构造方法。

![](https://cdn.luogu.com.cn/upload/image_hosting/m54hwvxo.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ltnr0l6l.png)

## Code

在实现上，因为字符串下标是从 $0$ 开始的，所以一些位置有减去 $1$ 的操作。

```cpp
#include <assert.h>
#include <string>
#include <iostream>
#include <algorithm>

int T;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (std::cin >> T; T; --T) {
    int k;
    std::string s; std::cin >> s >> k;
    if (s == "0") {
      std::cout << "-1\n";
      continue;
    }
    std::string ans;
    assert(k <= s.length());
    int endp = k - 1;
    while (s[endp] == '0') --endp;
    for (int i = 0; i <= endp; ++i) {
      ans.push_back('9');
    }
    if (endp != k - 1) {
      int q = k - 1;
      while (q < s.size() && s[q] == '0') ++q;
      if (q == s.size()) {
        std::cout << "-1\n";
        continue;
      }
      int p = k - endp - 1;
      p = q - p + 1;
      for (int i = endp + 1; i < p; ++i) ans.push_back('0');
      for (int i = p; i <= q; ++i) ans.push_back('9');
      
    }
    while(s.size() > ans.size()) ans.push_back('0');
    std::cout << ans << '\n';
  }
}
```

---

## 作者：离散小波变换° (赞：5)

## 题解

首先考虑一个简单的问题：怎么样使得进位的数字最多。

非常暴力且偷懒的想法是，构造 $y=\overline{999\cdots 999}$ 即可使得进位的数字最多。容易发现发生进位的数量就是 $x$ 除去末尾的 $0$ 之后的长度。记最多的次数为 $m$，那么显然 $m<k$ 就无解。

现在 $m\ge k$，设法构造一个解出来。

一个朴素的想法是将 $y$ 末尾的一些 $9$ 全变成 $0$，也就是保留最前面的 $k$ 个 $9$。很不幸，这种构造做法会在 $x$ 内部出现 $0$ 的时候发生一点小问题，进不了位。例如，下面这个例子，$m=10$，$k=6$。

$$\begin{aligned}
x&=10001\textcolor{red}010110000\cr
y&=99999\textcolor{red}900000000
\end{aligned}$$

不过这启发我们将 $x$ 按照 $0$ 分段。还是上面那个例子：

$$x=\textcolor{red}{\underline{1}}\textcolor{blue}{\underline{0001}}\textcolor{red}{\underline{01}}\textcolor{blue}{\underline{01}}\textcolor{red}{\underline{1}}0000$$

除了第一段没有 $0$ 以外，每一段都分成至少一个 $0$ 加上恰好一个非 $0$ 数的形式。假设第 $i$ 段长度为 $l_i$。那么总是可以找到一个最大的 $p$，使得 $l_1+l_2+\cdots+l_{p-1}\le k$，$l_1+l_2+\cdots+l_p> k$。对于前 $p-1$ 段，我们让这些段全部都发生进位，也就是塞上一大堆的 $9$；对于第 $p$ 段，我们要进位恰好 $k-(l_1+l_2+\cdots+l_{p-1})$ 次，那就塞上形如 $\overline{00\cdots 099\cdots 9}$ 的东西就行。

## 代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
int qread(){
    int w = 1, c, ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
const int MAXN = 1e4 + 3;
char S[MAXN]; int n, k;
int main(){
    up(1, qread(), _){
        scanf("%s", S + 1), n = strlen(S + 1);
        k = qread(); int f = n, t = 1;
        while(S[f] == '0') -- f;
        if(f < k) puts("-1"); else {
            while(k > 0){
                int p = 1;
                while(S[t] == '0') ++ t, ++ p;
                if(p <= k){
                    up(1, p, i) putchar('9');
                } else {
                    up(1, p - k, i) putchar('0');
                    up(1, k, i) putchar('9');
                }
                k -= p, ++ t;
            }
            up(t, n, i) putchar('0');
            puts("");
        }
    }
    return 0;
}
```

---

## 作者：Flanksy (赞：3)

### 构造，贪心

------------

#### 初步分析

以下认为输入的数字是一个字符串 $S$，字符串第 $i$ 位为 $S_i$。

首先，不能产生进位的部分只有 $S$ 结尾的连续 $0$ 串。所以当 $|S|$ 减去结尾连续 $0$ 串长度小于目标进位次数时，判定无解。

考虑贪心。构造形如 $99999$ 的字符串可以取得最大进位，如果要进位 $k$ 次，那么构造由 $k$ 个 $9$、$|S|-k$ 个 $0$ 拼接而成的字符串（构造一个和 $S$ 等长的字符串并且默认所有位都为 $0$，然后将一些位置设为 $9$ 来进位）。

当 $S_k \neq 0$ 时显然可行，不加以讨论。

------------

#### 完善解法

如果 $S_k=0$，那么无法取得 $k$ 次进位，部分题解因此受到启发按照 $0$ 来划分字符串以构造，然而笔者照着这个思路写 WA 了（菜死了）。

转换思路，因为 $S$ 不含前导 $0$，所以一定存在至少一个 $i \leq k$ 且 $S_i \neq 0$。找到最大的符合条件的 $i$，将构造的字符串第 $1$ 到第 $i$ 位置为 $9$，此时必定产生 $i$ 次进位。

然后找到最小的符合 $j \geq k$ 且 $S_j \neq 0$ 的 $j$，将构造的字符串第 $j-(k-i)+1$ 到第 $j$ 都置为 $9$，输出。

$S$ 第 $i+1$ 位到第 $j$ 位构成的子串为显然是数个前导 $0$ 后拼接一个不为 $0$ 的字符 $S_j$ 构成的。

为什么可以补上剩余的 $k-i$ 次进位？

**前导 $0$ 数量必定大于等于 $i-k$。** 如果前导 $0$ 数量小于 $i-k$，则可以推出 $j \leq k$，矛盾。由于 $S_j \neq 0$，所以一定能进位，再加上构造给出的 $9$ 可以连续进位，所以这样做是对的。

------------

#### 总结

- 输入字符串 $S$，判断是否无解，如果无解，输出 $-1$，结束。
- 如果 $S_k \neq 0$，先后输出 $k$ 个 $9$ 和 $|S|-k$ 个 $0$，结束。
- 否则找到 $i$ 和 $j$，输出第 $1$ 位到第 $i$ 位为 $9$，第 $j-(k-i)+1$ 到第 $j$ 位为 $9$，其余位为 $0$ 的字符串，结束。

---

## 作者：MornStar (赞：3)

# P9215 [入门赛 #11] [yLOI2021] 扶苏与 1 (Hard Version)
ps：一道好题（自己认为）。

pps：~~还是第一次遇到入门赛有构造题。~~

好，回归主题。

## 题目大意
给定一个数 $a$，构造一个位数不超过 $a$ 且两者相加刚好有 $k$ 次进位的数，不存在输出 $-1$。

## 解题思路

首先，思考长度问题，要想能够更好的满足条件，最大进位个数越大越好，即构造字符串的长度越长越好，所以直接将构造字符串的长度定义为原字符串的长度，岂不美哉？

还是继续延续 Easy Version 的思想，从前往后扫一遍（或许从后往前也行？），能进位就进位，因为长度不会超过原字符串，很明显，这种思想的最大进位个数就是原数中的非零位。

很容易，我们就可以写出以下的**错误**代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		string s,y="";
		int k;
		cin>>s>>k;
		for(int i=0;i<s.length();i++){
			if(k!=0){
				y+=char(10-(s[i]-48)+48);	//只要进位就行，所以构造 10-s[i]。
				k--;
			}else{
				y+='0';
			}
		}
		if(!k)	cout<<y<<endl;
		else cout<<-1<<endl;
	}
}
```
很明显，这个代码是不能通过这道题的。

因为当遇到 $0$ 时，我们会判定其不能够进位，实际上 $0$ 却是可以进位的。

我们看到以下情况（点代表进位）：
```
 ... .
 300205
+199805
-------
 500010
```
哪怕原数只有三个非零数，却仍然有四次进位，说明我们当遇到 $0$ 时，还可以将这一位加上 $9$，并在后面构造进位，在理想状态下，这种方法最大进位次数是原数的位数。

但是，在末尾的连续零，是无法通过这种方式进位的（比如 $1023000$ 最多只能进位四次），所以还是会有无解的情况发生。

据此我们可以写出如下代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		string s,y="";
		int k;
		cin>>s>>k;
		for(int i=0;i<s.length();i++){
			if(s[i]=='0'){
				bool flag=1;
				for(int j=i+1;j<s.length();j++){//找非零数构造连续进位
					if(s[j]!='0'){
						if(j-i+1<=k){//判断进位个数是否超过。
							flag=0;
							k-=(j-i+1);
							for(int l=i;l<j;l++)	y+='9';
							y+=char(10-(s[j]-48)+48);
							i=j;
						}
						break;//找到非零数，连续零段结束。
					}
				}
				if(flag)	y+='0';//没找到非零数或连续零段太长。
			}else if(k!=0){
				y+=char(10-(s[i]-48)+48);			
				k--;
			}else{
				y+='0';
			}
		}
		if(k)	cout<<"-1"<<endl;
		else cout<<y<<endl;
	}
}
```
代码总体还有可以优化或有瑕疵的部分，希望大家多多指正。






---

## 作者：lbh666 (赞：2)

## 题目大意
给出两个数 $x$ 和 $k$，请构造一个数 $y$，使 $x + y$ 发生 $k$ 次进位，如果不能实现则输出 $-1$。

## 思路分析
- 考虑每一位加 $9$，就可以进位。
- 但 $0$ 不会发生进位，所以第一步先把 $x$ 的后导 $0$ 的个数统计一下。
- 不属于后导 $0$ 的 $0$，他们有可能因为后一位进了 $1$，再加上之前的 $9$，就可以进位了，后导 $0$ 无论怎么加，也不能进位。
- 如果除去后导 $0$ 的数字个数 $< k$，就发生不了 $k$ 次进位，这时候无解，直接输出 $-1$。
- 接下来，我们考虑构造 $y$，先统计一下 $x$ 中的非零数，有多少个非零数，就可以构造出多少个 $9$，至于不为后导 $0$ 的 $0$，他们暂时用一个 $0$ 来占位。
- 用一个字符串 $s2$ 来记录构造的数字。
- 如果非零数够进位的话，直接输出 $s2$ 及后导 $0$ 即可。
- 如果不够，再来考虑 $0$，$0$ 的情况较为复杂，举个例子：当 $x = 1001$，$k = 3$ 时，有如下两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/2ov7pabn.png)

这种情况是从前往后，将 $0$ 换为 $9$，但只进了两位，不行。

![](https://cdn.luogu.com.cn/upload/image_hosting/lpns06tj.png)

这次是从后往前将 $0$ 改为 $9$，进了三位，行。
- 结论：非零数不够进位的时候，就要把那些 $0$ 从后往前跟非零数一样改成 $9$。原因：从后往前的时候，那些 $0$ 的右边一定有一个非零数，就算右边是一个 $0$，右边的 $0$ 也会受到它右边的非零数的影响，这样它们都能变成 $9$ 了。

- 从前往后考虑是不行的，你不知道它后面有没有进位，所以从后往前考虑是最优的。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
int k,t;

int main(){
	cin>>t;
	while(t--){
		int tot=0,p;
		string s2="";  //用s2拿去构造 
		cin>>s>>k; //对于每次询问的输入   
		p=s.size()-1; 
		while(s[p]=='0'){   //记录后导0个数 
			++tot;
			--p;
		}
		if(s.size()-tot<k){     //如果s的非零数<k 
			cout<<"-1\n";        //输出-1 
			continue;          //开始下次询问 
		}
		for(int i=0;i<s.size()-tot;++i){   //枚举除去后导0的s 
			if(s[i]!='0' && k){     //如果它是非零数且进位的次数还有 
				s2+="9";     //构造一个9 
				--k;      //次数-1 
			}else s2+="0";    //否则填0占位 
		}
		for(int i=s2.size()-1;i>=0;--i){   //从后往前倒着枚举 
			if(!k)break;       //如果次数用完了，跳出循环去输出 
			if(s2[i]=='0'){       //如果是0 
				s2[i]='9';      //把对应位改成9 
				--k;        //次数-1 
			}
		}
		cout<<s2;      //输出构造好的s2 
		for(int i=1;i<=tot;++i)cout<<"0";    //输出后导0 
		cout<<"\n";        //换行别忘记 
	}
	return 0;
} 
```

---

## 作者：5k_sync_closer (赞：2)

按 $0$ 的连续段“分块”，记第 $i$ 个 $0$ 的连续段的左端点为 $l_i$（$l_0=1$），则第 $i$ 块为 $[l_{i-1},l_i)$，

即每一块为 $0\cdots 0+s$ 的形式，其中 $s$ 为任意不含 $0$ 的串。

容易发现块内塞满 $9$ 可以产生块长次进位，所以把前若干个整块塞满 $9$。

然后发现块内长度为 $x$ 的后缀塞满 $9$ 可以产生 $x$ 次进位，所以把剩下一个散块的后缀塞满 $9$。

所有块长之和 $<k$ 无解。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int T, n, k, f, t, z;char s[10050];
int main()
{
	scanf("%d", &T);while(T--)
	{
		scanf("%s%d", s + 1, &k);f = n = strlen(s + 1);
		while(s[f] == '0') --f;if(f < k) {puts("-1");continue;}t = 1;
		while(k)
		{
			z = 1;while(s[t] == '0') ++t, ++z;
			for(int i = 0;i < z - k;++i) putchar('0');
			for(int i = 0;i < min(z, k);++i) putchar('9');
			k -= min(z, k);++t;
		}
		for(int i = t;i <= n;++i) putchar('0');puts("");
	}
	return 0;
}
```


---

## 作者：shiranui (赞：1)

~~谨以此题解纪念我的20次提交~~。

[博客内食用体验更嘉(?)](https://www.cnblogs.com/shiranui/p/17361083.html)

## 题目大意

给一个整数 $x$ 和 进位次数 $k$，求一个数 $y$ 使得列竖式计算 $x+y$ 时正好产生 $k$ 次进位。

## 思路

~~（最开始是想正着搞的，但是怎么也调不出来）~~提供一种倒着做的做法。

首先有几个结论：

- 产生进位 $=$ 给前一位 $+1$。

- 对于 $99\cdots999$，当最后一位发生进位时，会引发连环进位，总进位次数为连续 $9$ 的个数。

- $0$ 无法产生进位。

应该挺显然的吧（）。

然后从后往前每一位考虑。

- 如果这一位是 $0$。
无论如何它都不会产生进位，所以随便丢个数字给它。

- 如果这一位不是 $0$。
也就是它**可以**产生进位。这时候就要抉择它要不要进位了。
肯定是能进位就进位，但什么时候不能进位呢？
如果它进位引发的连环进位总次数超过了剩下的进位次数 $k'$，那么它不可以进位。

由于 $x$ 的位数不会超过 $10^4$， 所以可以暴力进位。

~~不知道为什么不用 `cin` `cout` TLE 了。~~

## 代码

```cpp
const int N = 10010;
int t, n, k, ans[N], a[N];
int p[N]; //连续 9 的个数
char s[N];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> t;
    for (int I = 1; I <= t; I++) {
        cin >> s + 1;
        n = strlen(s + 1);
        for (int i = 1; i <= n; i++) ans[i] = 0;
        for (int i = 1; i <= n; i++) a[i] = s[i] ^ 48;
        for (int i = 1; i <= n; i++) //统计连续 9 的个数
            if (a[i] == 9) p[i] = p[i - 1] + 1;
            else p[i] = 0;
        cin >> k;
        for (int i = n; i >= 1; i--) {
            if (a[i] == 0) {
                ans[i] = 0;
                continue;
            }
            if (p[i - 1] + 1 > k) ans[i] = 0; //i 位进位会导致的一连串进位数量超过 k
            else {
                ans[i] = 10 - a[i]; //加上任意一个大于等于 (10-a[i]) 的数都可以
                a[i] += ans[i];
                int l = i;
                while (a[l] > 9) { //进行连环进位
                    a[l - 1] += a[l] / 10, a[l--] %= 10, k--; l++;
                    if (a[l] == 9) p[l] = p[l - 1] + 1; //新产生的 9 要加进连续 9 的计数中
                }
                i = l; //一串 9 连环进位以后会变成一串 0, 显然都不会产生贡献, 直接跳掉就可以了 (这个优化不加也能过)
            }
        }
        if (k) cout << "-1\n";
        else {
            int l = 1;
            while (ans[l] == 0 && l <= n) l++;
            for (int i = l; i <= n; i++) cout << ans[i];
            cout << '\n';
        }
    }
	return 0;
}
```

---

## 作者：DFM_O (赞：0)

### 题目大意
给出一个非负整数 $x$，请构造一个长度不超过 $x$ 的整数 $y$，使 $x$ 与 $y$ 竖式计算时产生 $k$ 个进位。

### 解题思路
因为单独的 $0$ 不能进位，所以 $x$ 末尾的 $0$ 没有用可以删去。

但是若 $0$ 所在的数位的上一位有进位，那么在此数位上添加 $9$ 就可以产生进位。

现在 $x$ 的位数就是 $x$ 与 $y$ 竖式计算时产生进位个数的最大值。若 $k>$ 此时 $x$ 的位数，输出 $-1$。

然后在 $x$ 的每一个非 $0$ 数位上添加 $9$，使其产生进位。若此时进位此数仍小于 $k$，则在剩余的数位上添加 $9$（前提是该数位的上一位有进位，否则无法产生进位），直到满足要求为止。

最后，若未输出 $-1$，就在 $y$ 的末尾补 $0$，使 $y$ 的长度与 $x$ 的长度相等，并输出 $y$。

### Code
```cpp
#include<bits/stdc++.h>//c++万能头
using namespace std;
int main()
{
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		string x,y="";//注意y要赋初值
		int k,s0=0,lenx;
		cin>>x>>k;
		lenx=x.size();
		for(int j=lenx-1;j>=0;j--)
		{
			if(x[j]=='0')
				s0++;//统计x末尾0的个数
			else
				break;
		}
		x=x.substr(0,lenx-s0);
		lenx=x.size();
		if(k>lenx)//判断k是否大于此时x的位数
		{
			cout<<-1<<"\n";
			continue;//终止本次循环
		}
		for(int j=0;j<lenx;j++)
		{
			if(x[j]!='0')//判断x的这一位是否为0
			{
				if(k!=0)
				{
					y+='9';//y的对应位赋值为9
					k--;
				}
				else
					y+='0';
			}
			else
				y+='0';
		}
		for(int j=lenx-1;j>=0;j--)
		{
			if(x[j]=='0')
			{
				if(k!=0)//判断k是否为0
				{
					y[j]='9';
					k--;
				}
				else
					break;//若k为0，则退出循环
			}
		}
		for(int j=1;j<=s0;j++)//在y的末尾补0
			y+='0';
		cout<<y<<"\n";
	}
	return 0;
}
```

---

## 作者：XRRRRcode (赞：0)

## 题意介绍
本题在绿题里总的来说还是比较简单的，题目类似于要求构造一个高精度加法，关键字是进位数并且不能超过长度限制。
## 题解
1. 末尾的 $0$ 直接去掉（因为没用），然后计算长度，特判一下无解的情况（输出 $-1$）；
2. 再把非零的数的末尾改成 $9$ 或 $0$（根据数据的位数进行判断，虽然有点投机取巧，但 OI 竞赛是面向结果编程）；
3. 最后把前 $x$ 个非零的数改为 $9$（用于保证进位，同时可以防止出现前导零）；
4. 重复 $2$ 步骤，直到处理完成。

这里再说一下为什么使用 $9$ 作为填充数，因为 $9$ 具有以下性质：

1. 不等于 $0$；
2. 两个数字全为 $9$ 即可进位；
3. 上一位进位并且当前位为 $9$ 就可以进位；
4. 无论如何也无法进 $2$ 位。

因为本题 Special Judge，所以骚点就骚点吧。该写的注释里都写了，也不赘述了。

## 代码
```cpp
#include<iostream>
#include<string>
using namespace std;
int a,x,t;
string s,b;
void solve()
{
    int i,k=b.size();
    a=0;
	s="";//不初始化见祖宗
	while('0'==b[k-1])//抹除末尾的0
		b.erase(k-1),a++;//string类的erase的作用是去除第n位的字符
	if(k<x)//特判一下无解的情况
    {
		cout<<-1<<endl;//输出-1，直接退出
        return;
	}
	for(i=0;i<k;i++)
        if('0'==b[i]||!x)//判断应该在末位加入0还是9
            s+='0';
        else
		    s+='9',x--;//改成9的话记得把数位减去1
	for(i=k-1;i>=0;i--)//将前x个非零数设为9
        if('0'==b[i]&&x)
		    s[i]='9',x--;
	cout<<s;
	for(i=0;i<a;i++)//用0补一下位
        cout<<'0';
    cout<<endl;
}
int main()
{
    int i;
	cin>>t;//数据组数
	for(i=0;i<t;i++)
    {
		cin>>b>>x;//读入一组数据
		solve();//对应输出
	}
    return 0;
}
```


---


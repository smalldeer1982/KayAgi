# [蓝桥杯 2023 国 Java A] 质数排序

## 题目描述

我们定义质数排序为将一个序列中的所有下标为质数的位置进行升序排序，其它位置上的数不变。

例如，对 $8, 7, 6, 5, 4, 3, 2, 1$ 进行质数排序会得到 $8, 2, 4, 5, 6, 3, 7, 1$。给定 $n$，求 $1 \sim n$ 的每个排列进行质数排序后的逆序对的数量的和。由于结果很大，你只需要输出答案对 $998244353$ 取模的结果即可。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$n \leq 10$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
3```

### 输出

```
6```

# 题解

## 作者：CChord (赞：2)

## 整体思路
为表述方便，记：质数下标元素集合为 $P$，非质数下标元素集合为 $C$，且元素个数分别为 $p$，$c$。

由于 $P$ 已经升序，内部不存在逆序对，因此我们只需要分别求出：

1. $C$ 内部的逆序对总数。
2. $C$ 与 $P$ 之间的逆序对总数。

### 一、$C$ 内部的逆序对

共有 $n!$ 个排列，每个排列中，$C$ 内部有 $\frac{c(c-1)}{2}$ 个数对，每个数对是逆序对的期望为 $\frac{1}{2}$，因此 $C$ 内部的逆序对总数为：
$$
n!\times\frac{c(c-1)}{2}\times\frac{1}{2}=\frac{c(c-1)n!}{4}
$$

### 二、$C$ 与 $P$ 之间的逆序对

考虑非质数下标位置 $i$ 的贡献，不妨记该位置前有 $k$ 个质数下标元素，则该位置后有 $p-k$ 个质数下标元素。

考虑 $a_i$ 在集合 $\{a_i\} + P$ 升序排列后所处的位置，显然排在各位置的概率相同，均为 $\frac{1}{p+1}$，若排在第 $j$ 位 $(j=0,1,\cdots,p)$，那么 $a_i$ 与 $P$ 中的所有元素形成的逆序对数量为 $|j-k|$。

因此位置 $i$ 的总贡献为：
$$
\frac{n!}{p+1}\sum_{j=0}^{p}|j-k|=\frac{n!}{p+1}\left(\frac{k(k+1)}{2}+\frac{(p-k)(p-k+1)}{2}\right)
$$

将每个位置 $i$ 的贡献累加即可。

## 代码实现
```
#include<bits/stdc++.h>
#define int long long
using namespace std;

constexpr int mod = 998244353;

struct Euler{
	vector<int>primes;
	vector<bool>comp;
	
	Euler(int n){
		comp.resize(n + 1);
		for(int i = 2; i <= n; i++){
			if(!comp[i]) primes.emplace_back(i);
			for(int j = 0; i * primes[j] <= n; j++){
				comp[i * primes[j]] = true;
				if(!(i % primes[j])) break;
			} 
		}
	}
};

int qmi(int a, int k, int p){
    int res = 1;
    while(k){
        if(k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}

int inv(int a){
    return qmi(a, mod - 2, mod);
}

constexpr int M = 1e6 + 10;
vector<int> fact(M);
void init(){
    fact[0] = 1;
    for(int i = 1; i < M; i++){
        fact[i] = fact[i - 1] * i % mod;
    }
}

void solve(){
    int n; cin >> n;
    Euler sieve(n);
    int p = sieve.primes.size();
    int c = n - p;

    int res = 0;

    int k = 0;
    for(int i = 0; i < n; i++){
        if(i == 0 || sieve.comp[i + 1]){
            res += (k * (k + 1) / 2 + (p - k) * (p - k + 1) / 2) % mod;
            res %= mod;
        }
        else k++;
    }
    res *= fact[n] * inv(p + 1) % mod;
    res %= mod;

    res += c * (c - 1) % mod * inv(4) % mod * fact[n] % mod;
    res %= mod;

    cout << res << '\n';
}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    init();
    solve();
    return 0;
}
```

---

## 作者：kaederei7 (赞：1)

对于 $n \le 10^6$ ，显然无法对每个排列计算其逆序对来求得答案。

因此我们不妨考虑任意一个排列 $p$ ，一对 $(i, j), i < j$ 能成为逆序对的概率，将其乘上 $n!$ 即为 $(i, j)$ 对于答案的贡献。

分类讨论 $i, j$ 的位置是否为质数位：

1. $i, j$ 均为质数，经过排序后显然有 $p_i < p_j$ ，因此概率为0。

2. $i, j$ 均非质数，相当于考察普通排列中 $(i, j)$ 为逆序对的概率。此时要么 $p_i > p_j$，要么 $p_i < p_j$，并且两种情况的概率是相等的。即概率为 $\frac{1}{2}$ 。	

通过线性筛得出 $1\sim n$ 的质数个数，记质数的个数为 $m$ ，则非质数的个数为 $n - m$，非质数数对的数量为 $C_{n - m}^2$。

以上两种情况都容易想到，也很好求，考虑最复杂的情况。


3. $i, j$ 一个为质数，一个为非质数。

首先，我们不妨令 $j$ 为质数，且为第 $k$ 个质数。经过排序后，其值 $p_j$​ 在所有原来落在质数位的数中为第 $k$ 小。

接下来，将 $i$ 和所有质数集合看作是一个整体的，大小为 $m + 1$ 的集合 $S$ 。这 $m+1$ 个位置上各自拿到的数，是从 $\{1,\dots,n\}$ 中随机抽取的 $m+1$ 个不同数，并且在这 $m+1$ 个位置上的初始分配是等可能的。

对于 $i$ 的取值，可以发现：

如果 $p_i$ 是集合第 $l$ 小的数，且 $l > k$，经过排序后， $p_j$​ 会是集合 $S$ 中第 $k$ 小的数，此时 $(i, j)$ 构成一对逆序对。


否则，$p_j$​ 会是集合 $S$ 中第 $k+1$ 小的数，此时 $(i, j)$ 不构成逆序对。

因此 $(i, j)$ 为逆序对的概率，即为 $p_i$ 是集合中大于第 $k$ 小的数的概率。根据前文提到的 $S$ 中 $m+1$ 个位置上各自拿到的数的性质，容易得出这个概率即为 $\frac{m+1-k}{m+1}$。根据这个式子也能看出，当 $j$ 固定时，$i$ 的取值对于概率是无影响的。

统计出满足上述条件的所有的数对以及它们成为逆序对的概率，相当于求一遍加权平均和。对于 $1 \sim j$ 中的所有数，已知 $j$ 为第 $k$ 个质数，意味着 $1 \sim j$ 中有 $j-k$ 个数不是质数。简而言之，这个求和结果为：
$$
\sum_{k=1}^m\;\;\sum_{1 \le i < j，且i为非质数}\frac{m+1-k}{m+1}=\sum_{k=1}^m(j-k)\;\frac{m+1-k}{m+1}
$$
（如果你的质数数组为 $prime$ ，且下标从1开始，$j$ 即为 $prime_k$）

当 $i$ 为第 $k$ 个质数，$j$ 不是质数时，同理可得，最终概率的求和结果为：

$$
\sum_{k=1}^m\bigl((n - i) - (m-k)\bigr)\;\frac{k}{m+1}
$$

综上所述，对所有 $(i, j)$ 能成为逆序对的概率求和后，乘上 $n!$ 即为最终答案。

---


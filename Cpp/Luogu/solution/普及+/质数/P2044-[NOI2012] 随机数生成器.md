# [NOI2012] 随机数生成器

## 题目描述

栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随机数列，这种方法需要设置四个非负整数参数 $m,a,c,X_0$，按照下面的公式生成出一系列随机数 $\{X_n\}$：
$$X_{n+1}=(aX_n +c)\bmod m$$

其中 $\bmod m$ 表示前面的数除以 $m$ 的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。

用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的 C++ 和 Pascal 的产生随机数的库函数使用的也是这种方法。

栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道 $X_n$ 是多少。由于栋栋需要的随机数是 $0,1,\dots,g-1$ 之间的，他需要将 $X_n$ 除以 $g$ 取余得到他想要的数，即 $X_n \bmod g$，你只需要告诉栋栋他想要的数 $X_n \bmod g$ 是多少就可以了。


## 说明/提示

计算得 $X_n=X_5=8$，故$(X_n \bmod g) = (8 \bmod 3) = 2$。

对于 $100\%$ 的数据，$n,m,a,c,X_0\leq 10^{18}$，$1\leq g\leq 10^8$，$n,m\geq 1$，$a,c,X_0\geq 0$。


## 样例 #1

### 输入

```
11 8 7 1 5 3```

### 输出

```
2```

# 题解

## 作者：Diamiko (赞：41)

## 矩阵快速幂 + 龟速乘

$$ X_{n+1}=(aX_n+c) \mod m $$

题目给了我们一个递推式，让我们求$X_n$.

看到$1e18$的数据范围，明显是不能直接递推的，考虑矩阵加速。

-------------------------

### 构造矩阵

首先设初始矩阵为

$$\begin{bmatrix}

X_{i-1} \\

c

\end{bmatrix}$$

要求一个转移矩阵使得相乘之后可得到

$$\begin{bmatrix}

X_i\\

c

\end{bmatrix}$$

（以下暂不考虑取模）

$$X_i=a×X_{i-1}+1×c$$

$$c=0×X_{i-1}+1×c$$


那么容易得出转移矩阵为

$$\begin{bmatrix}

a & 1\\

0 & 1

\end{bmatrix}$$

在本题中，初始矩阵即为

$$\begin{bmatrix}

X_0\\

c

\end{bmatrix}$$

经过一次转移

$$\begin{bmatrix}

a & 1\\

0 & 1

\end{bmatrix} 

×

\begin{bmatrix}

X_0\\

c

\end{bmatrix}

=

\begin{bmatrix}

X_1\\

c

\end{bmatrix}

$$ 

显然，对于 $n$ 次转移，得到的矩阵就是

$$

\begin{bmatrix}

X_n\\

c

\end{bmatrix}

$$ 

-----------------------


那么 $n$ 次转移后得到的矩阵的第一行第一列位置的数，就是我们要求的答案，最后对 $g$ 取模。

由于矩阵乘法满足结合律，所以先把转移矩阵进行矩阵快速幂 $n$ 次方，然后乘上初始矩阵。

-------------------------------

但是仅仅打上一个矩阵快速幂是无法$\color{green}AC$此题的，考虑到数据范围过大以至于会爆掉$longlong$，~~可以写高精~~，可以使用龟速乘。

---------------------------

### 龟速乘

顾名思义，龟速乘就是一种速度超慢的乘法，但是可以保证不爆$longlong$.

首先考虑为什么我们每一步都取模还是会爆呢？那就是因为我们在乘的时候先乘再取模，还没等到取模就已经溢出了，然后再执行取模，就相当于亡羊补牢。

龟速乘的原理是什么呢？

考虑乘法的本质。大家都学过，乘法就是连加的一种缩写。

举个栗子， 

$5×4=5+5+5+5$

$3×6=3+3+3+3+3+3$

那我们如果对于 $x × y$，循环 $y$ 次，累加 $y$ 个 $x$ ，每一步都取模，不就可以避免这个问题了吗？

确实，但很慢……肯定是不行的。

使用和快速幂相似的思想，对乘法进行拆分。

对于 $a × b$，

当 $a$ 为偶数时，$a × b = a × (b÷2) + a × (b÷2)$

当 $a$ 为奇数时，$a × b = a × (b÷2) + a × (b÷2)+a$

跟快速幂像极了……

```cpp
long long Wuguidechengfa(long long x,long long y)
{
	long long ans=0;
	while(y)
	{
		if(y&1) (ans+=x)%=mod;
		(x+=x)%=mod;
		y>>=1;
	}
	return ans;
}
```

这样就解决了长整型溢出的问题。

-----------------------------

完整代码

```cpp
#include<bits/stdc++.h>
#define mul(x,y) Wuguidechengfa(x,y)
using namespace std;
typedef long long ll;
const int N=40;
inline ll read()
{
	char c;ll res=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())res=(res<<3)+(res<<1)+(c^48);
	return res;
}
ll mod,a,c,x0,n,g;
ll Wuguidechengfa(ll x,ll y)
{
	ll ans=0;
	while(y)
	{
		if(y&1) (ans+=x)%=mod;
		(x+=x)%=mod;
		y>>=1;
	}
	return ans;
}
//龟速乘
struct Mat
{
	ll a[N][N];
	//矩阵
	int n,m;
	//行、列
	Mat(){n=m=0;memset(a,0,sizeof a);}
	//构造空矩阵
	Mat(int k){n=m=k;memset(a,0,sizeof a);for(int i=1;i<=k;i++)a[i][i]=1;}
	//构造k*k的单位矩阵
	Mat(int x,int y){n=x,m=y;memset(a,0,sizeof a);}
	//构造x*y的空矩阵
	Mat operator *(Mat b)
	{
		Mat c(n,b.m);
		for(int i=1;i<=c.n;i++)
		{
			for(int j=1;j<=c.m;j++)
			{
				for(int k=1;k<=m;k++)
				{
					c.a[i][j]=(c.a[i][j]+mul(a[i][k],b.a[k][j]))%mod;
					//注意这里用龟速乘而不是直接写乘号
				}
			}
		}
		return c;
	}
	Mat operator *=(Mat b)
	{
		return *this=*this*b;
	}
	//重载乘法
	Mat operator ^(ll k)
	{
		Mat ans(n),t=*this;
		while(k)
		{
			if(k&1) ans*=t;
			t*=t;
			k>>=1;
		}
		return ans;
	}
	Mat operator ^=(ll k)
	{
		return *this=*this^k;
	}
	//矩阵快速幂
};
int main()
{
	mod=read();a=read();c=read();x0=read();n=read();g=read();
	if(!n)return printf("%d\n",x0)&0;
	//特判n==0的情况
	Mat res(4,4);
	res.a[1][1]=a,res.a[1][2]=1,res.a[2][2]=1;
	//构造转移矩阵
	Mat p(2,1);
	p.a[1][1]=x0,p.a[2][1]=c;
	//构造初始矩阵
	res^=n;
	res*=p;
	//注意乘法顺序，矩阵乘法不满足交换律
	printf("%lld\n",res.a[1][1]%g);
	//注意答案对g取模
    return 0;
}
```
结束！

---

## 作者：qqvq (赞：28)

#### 一个我觉得比较好理解的思路

首先按照递推式推几个

$x[1] = (ax[0] + c) \pmod m$

$x[2] = a((ax[0] + c)+c) = a^2x[0] + ac + c \pmod m$

$x[3] = a(a^2x[0] + ac + c)+c = a^3x[0] + a^2c + ac + c \pmod m$

发现什么了吗？

$x[i]$的第一项是$a^ix[0]$ 后面是一个首项为$c$ 公比为$a$的等比数列

---

- ### 第一项可以用快速幂解决

- ### 如何对一个等比数列求和+取模？看下面

-  求公比为k的等比数列之和$Sum(n)$

- - #### n为偶数  $Sum(n) = Sum(n/2) * Pow(k, n/2)$

- - #### n为奇数 $Sum(n) = Sum(n/2) * Pow(k, n/2) + $数列第n项的值

- #### 发现这个也可以用递归解决

----

于是我们有了85pts 最后15分是对爆long long乘法的取模，用**龟速**乘法就可以了

代码


```cpp
#include <bits/stdc++.h>
typedef unsigned long long ull;
using namespace std;
ull mod, a, c, x, n, g, mod1, m;
ull ret, ans;
inline ull mul(ull x,ull y) {//龟速乘法
  for(ret = 0; y; y >>= 1) {
    if (y & 1) ret = (ret + x) % mod;
    x = (x + x) % mod;
  }
  return ret;
}

ull Pow(ull a,ull k) {//快速幂
  ull x = a;
  for(ans = 1; k; k >>= 1) {
    if (k & 1) ans = mul(ans, x);
    x = mul(x, x);
  }
  return ans;
}

ull Sum(ull n,ull t) {//n是长度 t是首项 m是公比
  if (n == 1) return t;
  ull ret = Sum(n/2, t);
  ret = (ret + mul(ret, Pow(m, n/2))) % mod;
  if (n & 1) ret = (ret + mul(Pow(m, (n-1)), t))%mod;
  return ret;
}

int main() {
  cin >> mod >> m >> c >> x >> n >> mod1;
  ull ans = Pow(m, n);
  ans = mul(ans, x);
  ans = (ans + Sum(n, c)) % mod;
  cout << ans % mod1;
  return 0;
}
```

---

## 作者：zzqDeco (赞：19)

大多数的题解都把具体实现讲的很清楚了，但是相较不足的是对于初始矩阵的转移矩阵的解释（第一篇题解的暴力化简真的秀到我了）

这篇题解主要是解决简单的递推式矩阵建模的

首先我们考虑矩阵乘法的实际意义

大多数情况下我们都可以将矩阵的乘法看作是依照方程的转移

在这种情况下，我们将方程中的元抽象为矩阵的每一项，更具体的来说，称为连续的几项的时候，就会发现他们有依照方程转移的特性

（这个地方讲的不是特别详细，如果是对矩阵一知半解的话，可以看一下我的这个[blog](https://www.cnblogs.com/zzqdeco/p/12599296.html)）

有了方程的思想，我们自然用方程的想法来看待矩阵，就会发现矩阵满足结合律不满足交换律

同时，当我们了解的这些过后，就会考虑方阵这种往往在OI中用得多的东西

方阵的优势在于，或者说，我们用方阵的原因在于，大多数情况下的递推式都是固定的依赖于前面的 $x$ 项

这也是我们为啥可以矩阵快速幂的原因，但是我们现在从这个思路中调出来

现在回到这个问题，与一般的递推式不同，这里带有常数项，实际上这完全是一样的

我们换个方向考虑，实际上在一般的题中，我们的元并不要看作是一个递推式的连续不同项，而可以看作是长得一样的递推式的某些项分别转移成下一项的相互影响

我们用列矩阵来表示初始状态（也是方程的思想），在矩阵转化过程中无非就是元之间的互相影响（也就是我们脱离了递推式，而是从更加普遍的方面看这个问题）

我们也就是可以把所有的相互影响的量，都看作元

那我们对于两个递推式的合并
$$
f(x)=a\times g_1(x)+b\times g_2(x)
$$
只要把$g_1$, $g_2$ ，分别看作两个元，就很好解决了（在实际当中，我们不一定要之间维护$g_1$, $g_2$ 这样的元，而是我们找到维护这样的元的方法就好了）

这样的东西就游刃有余了，我们只要在转移时分别维护 $g_1$, $g_2$ ，就可以算出 $f(x)$

针对于这道题来说就是
$$
f(x)=f(x-1)+c
$$
你将 $c$ 看作一个常数列的，得到她的递推式，也就可以向上面那样合并，只不过这里由于 $f(x)$ 和 $f(x-1)$ 本质上是连续的，就不用当作两个元来考虑，只需要当作不同时间的一个元来考虑

有了上面的思想，其实对于这样基于递推式的矩阵加速的题都可以很快的解决了

也就是，针对
$$
f(x)=a\times g_1(x)+b\times g_2(x)
$$
考虑元的维护

#### 结语
这篇题解更像是对于这一类题目的一个引子

在我刚开初学矩阵的时候，就是半懂不懂的样子，完全也是连蒙带猜的推转移矩阵，希望这篇题解能被更多人看到，能让更多人少走弯路

（题解被压在下面一定没几个人看到吧）

---

## 作者：XY_ATOE (赞：12)

这道题题目给出了一个递推式，所以可以用矩阵乘法进行加速递推的过程。设初始矩阵为a，转移矩阵为b，则有

 ![](https://cdn.luogu.com.cn/upload/pic/8924.png)  

 ![](https://cdn.luogu.com.cn/upload/pic/8925.png) 

因为X[n+1]只由一个数X[n]递推出来，所以a矩阵中只需要有一个X[n]就够了。

这样求出a\*b

 ![](https://cdn.luogu.com.cn/upload/pic/8926.png) 

如果要保证转移，a\*b的矩阵中除了原来X{n]以外，其他项都要对应相等。

可得:


```cpp
X[n]*B[1][1]+A[1][2]*B[2][1]=X[n+1]=a*X[n]+c
X[n]*B[1][2]+A[1][2]*B[2][2]=A[1][2]
A[2][1]*B[1][1]+A[2][2]*B[2][1]=A[2][1]
A[2][1]*B[1][2]+A[2][2]+B[2][2]=A[2][2]
```
显然可以看出，B[1][1]=a，A[1][2]\*B[2][1]=c。
B[1][2]=0，B[2][2]=1，

把a\*b化简一下可得

 ![](https://cdn.luogu.com.cn/upload/pic/8927.png) 

所以此时A[1][2]=1，B[2][1]=c或A[1][2]=c，B[2][1]=1。

不论哪种情况观察可得，A[2][1]和A[2][2]都应该等于0

当A[1][2]=1，B[2][1]=c时

 ![](https://cdn.luogu.com.cn/upload/pic/8935.png) 

当A[1][2]=c，B[2][1]=1时

 ![](https://cdn.luogu.com.cn/upload/pic/8936.png) 

无论选用哪种情况，都是可以的

另外需要注意的时，根据数据范围，会出现成起来超long long 的情况所以承德时候需要用到快速乘

一下给出第一种情况的代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
struct s
{
    long long a[3][3];
}A,B;
long long n,mod,t,c,x0,g,b;
long long mul(long long a,long long b)
{
    long long res=0;
    for(;b;b>>=1) 
    {
        if(b&1)res=(res+a)%mod;
        a=(a<<1)%mod;
    }
    return res;
}
s ml(s t1,s t2)
{
    s t3;
    memset(t3.a,0,sizeof(t3.a));
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            for(int k=1;k<=2;k++)
            {
                t3.a[i][j]+=(mul(t1.a[i][k],t2.a[k][j]))%mod;
                t3.a[i][j]%=mod;
                if(t3.a[i][j]<0)t3.a[i][j]+=mod;
            }
    return t3;
}
s ksm(long long t)
{
    s C;
    memset(C.a,0,sizeof(C.a));
    for(int i=1;i<=2;i++)C.a[i][i]=1;
    while(t)
    {
        if(t&1)C=ml(C,B);
        B=ml(B,B);
        t>>=1;
    }
    return C;
}
int main()
{
    cin>>mod>>t>>c>>x0>>n>>g;
    A=(s){{{},{0,x0,1},{0,0,0}}};
    B=(s){{{},{0,t,0},{0,c,1}}};
    B=ksm(n);
    A=ml(A,B);
    cout<<A.a[1][1]%g;
    return 0;
}
```

---

## 作者：leozhang (赞：9)

看到全是矩阵的题解，我来一发递推+分治

其实这题一半和poj1845很像（或是1875？一个叫Sumdiv的题）

言归正传，我们看看怎么由f(0)推出f(n)

我们发现，题目中给出了f(n)=af(n-1)+c（取模略过）

那么顺着递推，可得：f(n-1)=af(n-2)+c

代入，得：

f(n)=a^2 f(n-2)+(a+1)c

继续递推，得：

f(n)=a^n f( 0 )+(a^ (n-1)+a^ (n-2)+...+1) c


------------


左半部分，我们可以直接快速幂求a^n，再乘f(0)即可


------------


右半部分，我们可以分治求出系数和。

怎么求？

我们发现，a^3+a^2+a+1=(a^2+1)(a+1)

那么对于任意奇次的推广，我们都可以如此因式分解，同时左半侧快速幂，右半侧递归求解即可。

而对于偶次，仅需将最高次项单独计算，剩下项继续递归即可


------------


但要注意本题模数太大，乘法会直接爆long long，所以需要用到快速加（将乘法转化成加法快速幂的思想）

（PS：其实右半部分的分治可以用等比数列求和公式解决，但好像需要求逆元，会增大算法难度，所以直接分治解决就好）

贴代码
```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
ll m,a,c,x0,n,g;
ll pow_add(ll x,ll y)
{
	ll ans=0;
	while(y)
	{
		if(y%2)
		{
			ans=(ans+x)%m;
		}
		x=(x+x)%m;
		y/=2;
	}
	return ans%m;
}
ll pow(ll x,ll y)
{
    ll ans=1;
    while(y)
    {
        if(y%2==1)
        {
            ans=pow_add(ans,x);
        }
        x=(ll)pow_add(x,x)%m;
        y/=2;
    }
    return ans%m;
}
ll quick_sum(ll x,ll y)
{
	if(y==1)
    {
        return (x+1)%m;
    }
    if(y==0)
    {
        return 1;
    }
    if(y%2)
    {
        return pow_add((pow(x,y/2+1)%m+1)%m,quick_sum(x,y/2)%m)%m;
    }
    return pow(x,y)%m+pow_add((pow(x,y/2)+1)%m,quick_sum(x,y/2-1)%m)%m;
}
int main()
{
	scanf("%lld%lld%lld%lld%lld%lld",&m,&a,&c,&x0,&n,&g);
	x0%=m;
    ll a0=pow(a,n)%m;
    ll temp1=pow_add(a0,x0)%m;
    ll temp2=pow_add(quick_sum(a,n-1)%m,c%m)%m;
	ll ret=(temp1+temp2)%m%g;
    printf("%lld\n",ret);
    return 0;
}
```

---

## 作者：hwk0518 (赞：7)

着重介绍一下求数列通项的**不动点法**。

形如$x_{n+1}=ax_n+c$的递推式是不动点法最简单且最经典的应用。

设不动点为$k$。

$k$必须满足$x_{n+1}+k=a(x_n+k)$。

展开得$x_{n+1}=ax_n+k(a-1)$。

比较系数，得$c=k(a-1)$

于是$k=\frac{c}{a-1}$

这样$x_n+k$就是一个等比数列，求通项得：

$x_n+k=a^n(x_0+k)$

$x_n=a^nx_0+(a^n-1)k$

$x_n=a^nx_0+\frac{(a^n-1)c}{a-1}$

接下来的问题是如何求$\frac{(a^n-1)c}{a-1} \space \space mod \space \space m$ .

展开得$\frac{(a^n-1)c}{a-1}=c*\sum_{i=0 \to {n-1}}a^i$

只要求$\sum_{i=0\to {n-1}}a^i$即可。

$\sum_{i=0 \to {n-1}}a^i$

$=\sum_{i=0 \to {\frac{n-1}{2}}}a^i+\sum_{i={\frac{n-1}{2}+1} \to {n-1}}a^i$

$=(1+a^{\frac{n+1}{2}})\sum_{i=0 \to {\frac{n-1}{2}}}a^i$

递归求解即可。其中乘法部分要用龟速乘。

代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

long long mod,n,a,c,x,g;

long long mul(long long x,long long y)
{
	long long ret=0,bas=x;
	while(y)
	{
		if(y&1)
		{
			ret+=bas;
			if(ret>=mod) ret-=mod;
		}
		bas+=bas;if(bas>=mod) bas-=mod;
		y>>=1;
	}
	return ret;
}

long long F_p(long long x,long long y)
{
	long long ret=1,bas=x;
	while(y)
	{
		if(y&1) ret=mul(ret,bas);
		bas=mul(bas,bas);
		y>>=1;
	}
	return ret;
}

long long solve(long long mx)
{
	if(!mx) return 1;
	long long tt=solve(mx>>1);
	long long pp=mul(tt,F_p(a,(mx>>1)+1));
	tt+=pp;if(tt>=mod) tt-=mod;
	
	if(!(mx&1))
	{
		tt-=F_p(a,mx+1);
		if(tt<0) tt+=mod;
	}
	return tt;
}

int main()
{
	scanf("%lld%lld%lld%lld%lld%lld",&mod,&a,&c,&x,&n,&g);
	
	a%=mod,c%=mod,x%=mod;
	
	long long fz=solve(n-1);
	fz=mul(fz,c);
		
	x=mul(x,F_p(a,n));
		
	x+=fz;if(x>=mod) x-=mod;
	
	printf("%lld\n",x%g);
	return 0;
}

```

---

## 作者：Refined_heart (赞：5)

蒟蒻学了下矩阵运算，就来水题解啦……（轻喷）

对于本题，已经有了题目给出的递推式对吧：

$$X_n=(aX_{n-1}+c)\mod{m}$$

那么显然可以矩阵优化递推。(不优化也不行啊……$qwq$)

记得入门时的斐波那契数列吗？其实本题是一样的推法。

因为$X_{n}$要由$a,c,m,X_{n-1}$推过来，那我们的转移矩阵里面就得有这些玩意。

显然，可以设初始矩阵为：

$$
\left[
  \begin{matrix}
    X_{n-1}&c\\              
  \end{matrix}
\right]
$$

那么，我们的目标矩阵就是：

$$
\left[
	\begin{matrix}
    X_n&c\\
   \end{matrix}
\right]
$$

那，怎么转移捏？

根据题目给出的递推式（可以暂时忽略模数，矩阵乘的时候一起模即可）：

$$X_{n}=aX_{n-1}+c$$

根据矩阵乘法定义（行乘列），可以推得转移矩阵：

$$
\left[
	\begin{matrix}
    a&0\\
    1&1\\
   \end{matrix}
\right]
$$

不太明白的也可以手算一算，这里大概说一下：

对应的初始矩阵第一行乘以转移矩阵第一列就是目标矩阵第一行第一列元素，即：

$goal_{1,1}=X_{n-1}*a+c*1$

推算下去会发现，这个转移矩阵刚好满足。

剩下的就是一个矩阵快速幂板子了。

注意题目数据范围较大，所以需要快速加来防止爆$long$ $long$.

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
ll m,mod,F,A,C,n;
inline ll mul(ll a,ll b){
	ll R=0;
	while(b){
		if(b&1)R+=a,R%=mod;
		a+=a;b>>=1;a%=mod;	
	}
	return R;
}
struct matrix{
	ll a[4][4];
	matrix(){memset(a,0,sizeof(a));}
	matrix operator*(const matrix&x)const{
		matrix res;
		for(int i=1;i<=2;++i)
			for(int j=1;j<=2;++j)
				for(int k=1;k<=2;++k)
					res.a[i][j]=(res.a[i][j]+mul(a[i][k],x.a[k][j]))%mod;
		return res;
	}
}base,ans;
inline void Init(){
	ans.a[1][1]=F;
	ans.a[1][2]=C;
	base.a[1][1]=A;
	base.a[2][1]=base.a[2][2]=1;
}
void qpow(ll b){
	while(b){
		if(b&1)ans=ans*base;
		base=base*base;b>>=1;
	}
}
int main(){
	scanf("%lld%lld%lld%lld%lld%lld",&mod,&A,&C,&F,&n,&m);
	Init();
	qpow(n);
	printf("%lld\n",ans.a[1][1]%m);
	return 0;
}
```
不懂请私信。

---

## 作者：cirnovsky (赞：3)

## 题意简述

给你一个递推式，让你求某一项的值模上 $g$。

## 题解

这道题正解是矩阵。我这里给出一种分治的做法。

题目中说

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $X_{i}=(a\times X_{i-1}+c)\ \mathrm{mod}\ m$

我们先往下推一步

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $X_{i-1}=(a\times X_{i-2}+c)\ \mathrm{mod}\ m$

我们把这个式子代入到原式，得到

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $X_{i}$

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $=(a\times X_{i-1}+c)\ \mathrm{mod}\ m$

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $=(a\times(a\times X_{i-2}+c)+c)\ \mathrm{mod}\ m$

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $=a^{2}\times X_{i-2}+c\times(a+1)\ \mathrm{mod}\ m$

按照这个套路推下去，最后得到：

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $X_{i}=a^{i}\times X_{0}+c\times(a^{i-1}+a^{i-2}+\cdots+a+1)$

$a^{i}\times X_{0}$ 很好得到，直接大力快速幂，再乘上 $X_{0}$ 即可。

我们接着来看后面的

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $c\times(a^{i-1}+a^{i-2}+\cdots+a+1)$

先不要看 $c$，即。

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $a^{i-1}+a^{i-2}+\cdots+a+1$

相信大家都学过因式分解，对于这样的式子进行因式分解简直再容易不过了。如果最高次为奇数次，那么我们可以直接两两分组，就可以提出来，即：

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $a^{i-1}+a^{i-2}+\cdots+a+1$

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $=(a^{i-1}+a^{i-2})+(a^{i-3}+a^{i-4})+\cdots+(a+1)$

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $=a^{i-2}\times(a+1)+a^{i-4}\times(a+1)+\cdots+(a+1)$

$\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ $ $=(a+1)\times(a^{i-2}+a^{i-4}+\cdots+a^{2}+1)$

这样我们就可以一直递归分治下去解决问题了，最后再乘上一个 $C$ 即可。

至于最高次为偶次就直接单独提出来大力快速幂即可。

还有一个细节，这道题的乘法常数过大，需要用“快速乘”。其实跟快速幂差不多。

```cpp
#include <cstdio>

char buf[1 << 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is_number (ch >= '0' && ch <= '9')

template < typename Type >
void read(Type& a) {
	a = 0; bool f = 0; char ch;
	while (!(ch = gc(), is_number)) if (ch == '-') f = 1;
	while (is_number) a = (a << 3) + (a << 1) + (ch ^ '0'), ch = gc();
	a = (f ? -a : a);
}

template < typename Type, typename... Args >
void read(Type& t, Args&... args) {
	read(t), read(args...);
}

typedef long long LL;
LL MOD, a, c, X0, n, g;

LL fast_mul(LL x, LL y) {
	LL res = 0;
	for (; y; y >>= 1, x = (x + x) % MOD)
		if (y & 1) res = (res + x) % MOD;
	return res % MOD;
}

LL fast_pow(LL x, LL y) {
	LL res = 1;
	for (; y; y >>= 1, x = fast_mul(x, x))
		if (y & 1) res = fast_mul(res, x);
	return res % MOD;
}

LL get_sum(LL x, LL y) {
	if (y == 0) return 1;
	else if (y == 1) return (x + 1) % MOD;
	else if (y & 1) return fast_mul((fast_pow(x, (y >> 1) + 1) % MOD + 1) % MOD, get_sum(x, y >> 1) % MOD) % MOD;
	else return fast_mul((fast_pow(x, y >> 1) + 1) % MOD, get_sum(x, (y >> 1) - 1) % MOD) % MOD + fast_pow(x, y) % MOD;
}

signed main() {
	read(MOD, a, c, X0, n, g);
	X0 %= MOD;
	printf("%lld\n", (fast_mul(fast_pow(a, n) % MOD, X0) % MOD + fast_mul(get_sum(a, n - 1) % MOD, c % MOD) % MOD) % MOD % g);
	return 0;
}
```

---

## 作者：XSZCaesar (赞：2)

## 诸位大佬都好强啊

其实蒟蒻的我看到题的第一眼想法就是矩乘啊

后来~~懒惰~~求知欲强的我就抱着学习~~yy~~一下的心理看一看题解

。。。。。。

。。。。。。

~~看不懂~~ 自己推吧

就把那个乘上那个，和那个，这个，那样一下就好了。

~~咳咳~~

就这样吧：



------------

![](https://cdn.luogu.com.cn/upload/pic/54356.png )



------------

对于蒟蒻的我来说矩乘和快速幂还是可以的：~~乘号写成加号什么的~~



------------

```cpp
#include<bits/stdc++.h>

using namespace std;

struct node
{
    int x,y;
    long long s[4][4];
};
long long n,m,a,c,g,x0;
node ans,onc;
node multi(node x,node y)
{
    node z;
    z.x=x.x,z.y=y.y;
    for(register int i=1;i<=z.x;i++)
    {
        for(register int j=1;j<=z.y;j++)
        {
            z.s[i][j]=0;
            for(register int k=1;k<=x.y;k++)z.s[i][j]=(z.s[i][j]%m+x.s[i][k]%m*y.s[k][j]%m)%m;
        }
    }
    return z;
}
void quick_pow(long long p)
{
    while(p!=0)
    {
        if(p%2==1)ans=multi(ans,onc);
        onc=multi(onc,onc);
        p=p/2;
    }
}
int main()
{
    scanf("%lld%lld%lld%lld%lld%lld",&m,&a,&c,&x0,&n,&g);
    ans.x=1,ans.y=2;
    ans.s[1][1]=x0,ans.s[1][2]=1;
    onc.x=2,onc.y=2;
    onc.s[1][1]=a,onc.s[1][2]=0,onc.s[2][1]=c,onc.s[2][2]=1;
    quick_pow(n);
    printf("%lld",ans.s[1][1]%g);
    return 0;
}
```



------------

而后狂 WA 不止

还是题解强

要快速乘防炸的



------------

```cpp
#include<bits/stdc++.h>

using namespace std;

struct node
{
    int x,y;
    long long s[4][4];
};
long long n,m,a,c,g,x0;
node ans,onc;
long long quick_mul(long long a,long long b,long long p)
{
    long long ret=0;
    while(b)
    {
        if(b&1)ret=(ret+a)%p;
        a=2*a%p;
        b>>=1;
    }
    return ret;
}
node multi(node x,node y)
{
    node z;
    z.x=x.x,z.y=y.y;
    for(register int i=1;i<=z.x;i++)
    {
        for(register int j=1;j<=z.y;j++)
        {
            z.s[i][j]=0;
            for(register int k=1;k<=x.y;k++)z.s[i][j]=(z.s[i][j]%m+quick_mul(x.s[i][k]%m,y.s[k][j]%m,m))%m;
        }
    }
    return z;
}
void quick_pow(long long p)
{
    while(p!=0)
    {
        if(p%2==1)ans=multi(ans,onc);
        onc=multi(onc,onc);
        p=p/2;
    }
}
int main()
{
    scanf("%lld%lld%lld%lld%lld%lld",&m,&a,&c,&x0,&n,&g);
    ans.x=1,ans.y=2;
    ans.s[1][1]=x0,ans.s[1][2]=1;
    onc.x=2,onc.y=2;
    onc.s[1][1]=a,onc.s[1][2]=0,onc.s[2][1]=c,onc.s[2][2]=1;
    quick_pow(n);
    printf("%lld",ans.s[1][1]%g);
    return 0;
}
```


------------

就这样，谢谢啦

---

## 作者：wwyx2001 (赞：2)

一个自认为很优美的代码（划）

矩阵快速幂裸题？

初始化的矩阵|x0   c|
准备乘的矩阵|a    0|
                     |1    1|
这样就会发现是正确的

最后两个点是爆longlong的，乘的时候需要用快速乘（与快速幂不同的地方就是把\*变成+）

还有一件事，你只需要把矩阵求出来最后的最后%g，中间一直要%m（kp）

代码：

>#include <cstdio>
```cpp
#include <cstring>
#define LL long long
using namespace std;
LL m,aa,c,n,g,x;
struct hh{LL sq[5][5];void cl(){memset(sq,0,sizeof(sq));}}ans,mult,a;
LL mul(LL a,LL b){
    LL res=0;
    for(;b;b>>=1,a=(a+a)%m) if(b&1) res=(res+a)%m;
    return res;
}
hh work(hh a,hh b)
{
    int i,j,k;
    hh c;c.cl();
    for (i=1;i<=2;i++)
      for (j=1;j<=2;j++)
        for (k=1;k<=2;k++)
          c.sq[i][j]=(c.sq[i][j]+mul(a.sq[i][k],b.sq[k][j])%m)%m;
    return c;
}
hh ksm(LL k)
{
    hh a;a=mult;
    for (;k;k>>=1,a=work(a,a))
      if (k&1) mult=work(mult,a);
    return mult;
}
int main()
{
    int i,j,k;
    scanf("%lld%lld%lld%lld%lld%lld",&m,&aa,&c,&x,&n,&g);
    a.sq[1][1]=x; a.sq[1][2]=c;
    mult.sq[1][1]=aa; mult.sq[1][2]=0; mult.sq[2][1]=1; mult.sq[2][2]=1;
    if (n>1) mult=ksm(n-1);
    for (i=1;i<=1;i++)
      for (j=1;j<=2;j++)
        for (k=1;k<=2;k++)
          ans.sq[i][j]=(ans.sq[i][j]+mul(a.sq[i][k],mult.sq[k][j])%m)%m;
    printf("%lld",ans.sq[1][1]%g);
}
```

---

## 作者：Missa (赞：1)

这么标准的不动点居然只有一篇不动点题解？

而且唯一的不动点题解关于不动点的描述还是错的？

所以，来写一篇题解讲讲，MO 中是怎么弄这种一阶线性递推式的。

单个数，虽然省常数，却难以取膜。

----------------

让我们对形如 $x_{n+1} = f(x_n)$ 的式子求出通项，其中 $f(x_n)$ 是一个关于 $x_n$ 的一次函数。

左右两边都是一次的，但是一次项的系数有差距。所以我们可以知道这东西到后面是以指数增长的。

如果这样的式子的 $x_{n+1} = k \cdot x_n$ 的，我们就能立刻知道 $x_{n+1} = k^n \cdot x_1$。换而言之，重要的是消除常数项在递推中的影响，这可以通过换元实现。

尝试以 $x-c$ 代 $x$，使得 $x'_{n+1} = k \cdot x'_n$。

写开，

$$
\begin{aligned}
x_{n+1} - c &=& k \cdot x_n - c \cdot k \\
x_{n+1} &=& k \cdot x_n + c \cdot (1-k)
\end{aligned}
$$

若原递推式为 $x_{n+1} = a \cdot x_n + b$，对比系数知 $k = a, c = \dfrac{b}{1-a}$。于是我们就有 $x_{n+1} - \dfrac{b}{1-a} = a \cdot (x_n - \dfrac{b}{1-a})$。这是一个漂亮的结果，借助它，我们能进行快速幂运算。

这里我们求出的 $c$ 叫不动点，意义很简单：使 $f(c) = c$ 的点，在迭代中不动的点。熟知 $x-t$ 整除 $f(x)$ 等价于 $f(t)=0$。我们能发现 $f(x)-c=x-c$，此时 $f(x)-c$ 含有 $x-c$ 这个因式，所以一边出现了 $x_{n+1}-c$，一边出现了 $x_n-c$。

这里的不动点，用处就是平移图像以消去常数项。

代码难写处在于 $a-1$ 不一定有逆元，这个的处理方式 [这篇题解](https://www.luogu.com.cn/blog/user31435/solution-p2044) 的最后有提到。需要提起的是，这篇题解关于不动点的定义是错误的，这也是我写这篇题解的意义。

---

## 作者：BreakPlus (赞：1)

简单的矩阵加速题。

乍一看，这个式子有点复杂。因为矩阵快速幂的时候管不到 $c$ ，所以我们得把 $c$ 加入矩阵。结合必要的 $x_0$，初始矩阵里面一共有两个元素 $x_0,c$。

来看一下转移，不难得到：

$x_i=ax_{i-1} + c$

$c=c$

把它转化为矩阵：

$ \ \ \ \ \ \ \ \ \  x_i \ \ \ \ c$

$ x_{i-1} \ \ a \ \ \ \ \ 0$

$ c \ \ \ \ \ \ \ \ 1 \ \ \ \ \ 1$

清楚一点就是：

$\left[ \begin{array}{ccc} a \\ 1\end{array} \begin{array}{ccc} 0 \\ 1\end{array} \right]$

要注意一下几点：

1. 要用龟速乘，不然会爆 long long

2. 注意取模

以下是我几个月前的代码（马蜂不好勿喷）

```cpp
#include<cstdio>
using namespace std;
long long m,A,c,x0,n,g;
struct mat
{
    long long a[5][5];
};
long long unqtimes(long long L,long long R)
{
    long long ans=0,base=L,b=R;
    while(b)
    {
        if(b&1) ans=(ans+base)%m;
        base=(base+base)%m;
        b/=2;
    }
    return ans;
}
void clean(mat &z)
{
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++) z.a[i][j]=0;
}
mat operator* (mat A,mat B)
{
    mat sum,p=A,q=B;
    clean(sum);
    for(int i=1;i<=2;i++)
        for(int j=1;j<=2;j++)
            for(int k=1;k<=2;k++) sum.a[i][j]=(sum.a[i][j]+1ll*unqtimes(p.a[i][k],q.a[k][j])%m)%m;
    return sum;
}
mat poww(mat status,mat A,long long p)
{
    mat ans=status,base=A;
    long long b=p;
    while(b)
    {
        if(b&1) ans=ans*base;
        base=base*base;
        b/=2;
    }
    return ans;
}
int main()
{
    scanf("%lld%lld%lld%lld%lld%lld",&m,&A,&c,&x0,&n,&g);
    mat first;clean(first);
    first.a[1][1]=x0;first.a[1][2]=c;
    mat base;clean(base);
    base.a[1][1]=A;base.a[2][1]=1;base.a[2][2]=1;
    printf("%lld",((poww(first,base,n)).a[1][1])%g);
    return 0;
}

```

---

## 作者：why_always_china (赞：0)

思路和楼下大体相同，但略有区别。

构造初始矩阵|xn, c|,则乘上
|a 0|
|1 1|
变成|x(n+1), c|
现在我们只考虑这个2\*2的矩阵，对其做快速幂。

然后发现右上角似乎一直是0?右下角似乎一直是1?

于是矩阵只需保留两项。代码清新多了---

long long取模用快速乘。

```cpp
#include<cstdio>
#define LL long long
using namespace std;
struct arr{LL a, c;};
const arr zero = (arr){1, 0};
LL m, a, c, x, n, g;
LL mm(LL x, LL y){
    if (!y) return 0;
    LL ans = mm(x, y >> 1) << 1;
    if (y & 1) ans += x;
    while (ans >= m) ans -= m;
    return ans;
}
inline arr mul(arr a, arr b){return (arr){mm(b.a, a.a),(mm(b.a, a.c) + b.c)%m};}
arr self_GO(arr a, LL t){
    if (!t) return zero;
    arr p = self_GO(a, t >> 1);
    p = mul(p, p);
    if (t&1) return mul(a, p);
    else return p;
}
int main(){
    scanf("%lld%lld%lld%lld%lld%lld", &m, &a, &c, &x, &n, &g);
    arr s = (arr){a, 1}, p = self_GO(s, n);
    printf("%lld", (mm(p.a, x) + mm(p.c, c))%m%g);
    return 0;
}

```

---

## 作者：hahalidaxin2 (赞：0)

【思路】

矩阵乘法+处理long long相乘。

初始矩阵为：

| xn , 1|
转移矩阵为：

| a, 0 |
| c, 1 |
Longlong相乘的处理大体思路是化除为乘。

【代码】

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

typedef long long LL;
LL n,a,c,g,x0,m;

LL multi( LL y , LL cnt ) {
    if ( ! cnt ) return 0 ;
    if ( cnt == 1 ) return y % m ;
    LL rec = multi( y , cnt / 2 ) ;
    rec = ( rec + rec ) % m ;
    if ( cnt % 2 ) rec = ( rec + y ) % m ;
    return rec ;
}
struct Matrix{
    int r,c;
    LL N[5][5];
    void init(int r,int c) {
        this->r=r, this->c=c;
        memset(N,0,sizeof(N));
    }
    Matrix operator*(Matrix& B)const{
        Matrix C;
        C.init(r,B.c);
        for(int i=0;i<C.r;i++)
           for(int j=0;j<C.c;j++)
           {
              for(int k=0;k<c;k++) C.N[i][j] += multi(N[i][k],B.N[k][j]);
              C.N[i][j]%=m;
          }
        return C;
    }
    Matrix pow(LL p) {
        Matrix tmp=*this;
        Matrix ans;
        ans.init(r,r);
        for(int i=0;i<r;i++) ans.N[i][i]=1;
        while(p) {
            if(p&1) ans=ans*tmp;
            tmp=tmp*tmp;
            p>>=1;
        }
        return ans;
    }
};
Matrix ans,T;

int main() {
    ios::sync_with_stdio(false);
    cin>>m>>a>>c>>x0>>n>>g;
    ans.init(1,2);
    ans.N[0][0]=x0,ans.N[0][1]=1;
    T.init(2,2);
    T.N[0][0]=a,T.N[0][1]=0,T.N[1][0]=c,T.N[1][1]=1;
    T=T.pow(n);
    ans=ans*T;
    cout<<ans.N[0][0]%g;
    return 0;
}


```

---


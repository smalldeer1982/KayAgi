# 数字游戏

## 题目描述

KC 邀请他的两个小弟 K 和 C 玩起了数字游戏。游戏是 K 和 C 轮流操作进行的，K 为先手。KC 会先给定一个数字 $Q$，每次操作玩家必须写出当前数字的一个因数来代替当前数字，但是这个因数不能是 $1$ 和它本身。例如当前数字为 $6$，那么可以用 $2, 3$ 来代替，但是 $1$ 和 $6$ 就不行。现在规定第一个没有数字可以写出的玩家为胜者。K 在已知 $Q$ 的情况，想知道自己作为先手能不能胜利，若能胜利，那么第一次写出的可以制胜的最小数字是多少呢？整个游戏过程我们认为 K 和C用的都是最优策略。

## 说明/提示

对于 $30 \%$ 的数据，$Q \le 50$；  
对于 $100 \%$ 的数据，$2 \le Q \le {10}^{13}$。

## 样例 #1

### 输入

```
6
```

### 输出

```
2
```

## 样例 #2

### 输入

```
30
```

### 输出

```
1
6
```

# 题解

## 作者：hsfzLZH1 (赞：25)

小K的策略：令对方不得不选择一个质数，令自己胜利。

这样小K只能选择Q的两个质因数的乘积。

由于要求可以制胜的数字最小，我们只需知道Q的两个最小质因数。

分类讨论：

1.Q是1或质数，此时小K只能选0，胜利。

2.Q是两个质数的积，小K只能选1或质数，对方选0，对方胜利。

3.Q是多个质数的积，小K有必胜策略（见上），胜利。

博弈论的部分结束了，现在我们要处理如何进行质因数分解的问题了。

对于Q，我们对于所有小于Q而大于1的正整数X，看Q能否整除X，如果可以X就是Q的因数。

如果我们在Q整除X时，Q=Q/X，再次判断Q能否整除X，这样就可以达到转化问题的效果，并且可以保证，对于每次分解出来的X，必然有X是质数，因为如果X不是质数，其必然有质因数，而这因数必然在之前已经分解掉了，所以分解出来的一定是X。

然而这样仍然会超时，我们需要考虑如何加快时间，减小时间复杂度。我们肯发现对于所有的X<=sqrt(Q)，即X\*X<=Q，如果没有X能整除Q，必然有Q是质数，通过这一点，我们就可以把以上的“对于所有小于Q而大于1的正整数X”改为“对于所有小于根号Q而大于1的正整数x”，达到优化时间复杂度的目的。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;//注意一定要long long类型
ll n,ans;
queue<ll>q;//用队列来存储Q的质因数，方便加入元素，访问大小和前面（最小）元素
int main()
{
    scanf("%lld",&n);
    for(ll i=2;i*i<=n;i++)while(n%i==0)q.push(i),n/=i;//分解质因数
    if(n!=1)q.push(n);//加入最大的因子
    if(q.size()==2)printf("2\n");
    else if(q.size()==1)printf("1\n0\n");
    else
    {
        printf("1\n");
        ans=q.front();
        q.pop();
        printf("%lld\n",ans*q.front());
    }//分类讨论，具体见上
    return 0;
}
```

---

## 作者：Laser_Crystal (赞：16)

## 主要还是博弈论思想的理解和运用

拿到题目，我们首先分析，两个人所用的都是最优策略，通俗点，就是**能够一步干掉对手的，就一步干掉，如果干不掉对手，就往干掉他的路上走一步**

### Step 1 

我们先来考虑，就是怎样的数字可以做到一步杀呢？（其实也就是满足题目中输出```1 \n 0```的数字）

答案很简单，就是质数啊！题目中 `每次操作玩家必须写出当前数字的一个因数来代替当前数字，但是这个因数不能是1和它本身` 就是要求这是一个质数嘛！

### Step 2

然后我们再来考虑，怎样的数字可以让对手把自己弄掉呢？

这就要求我面对的是一个质数了呗~~~

所以，对手只需要把他面前的那个数替代成一个质数，你就挂了（

### Step 3

从总的大局开始考虑了，如果输入的是一个由多个质数相乘得到的合数，我们该怎么办呢？

从Step2推来，我们应该做的，就是把这个数替代成为有两个数质数作为因数的数字咯，这样子我们就可以赢定了qwq

为什么是要两个质数的数呢？因为两个人都很聪明啊！你如果给对方的不是仅有两个质因数的数，那么下一个挂掉的就是你了。对方可以给你一个仅有两个质因数的数，然后你只能选一个质数写出来，然后对方赢了（

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000005];
long long cnt=0;
int main()
{
	long long q;
	cin>>q;
	for(register long long i=2;i*i<=q;i++) while(q%i==0) a[++cnt]=i,q/=i;//分解质因数
	if(q!=1)  a[++cnt]=q;
	if(cnt==1) cout<<"1\n0";//step 1
	else if(cnt==2) cout<<"2";//step 2
	else cout<<"1"<<endl<<a[1]*a[2]; //step 3
	return 0;
}
```

喵呜~

---

## 作者：Yeji_ (赞：6)

这道题目应该是博弈论中最基础的类型了

## 考点：博弈论

### 具体思路：
1.若这个数是一个素数，那么如题目所说，直接输出。

2.若这个数可以分解成两个素数的乘积，那么一定会输。

3.若这个数比较复杂，可以分解成多个数，那么就输出最小的两个质因数的乘积。


### 队列
因为本文中会有队列的运用。

如果大家有看不懂stl的，那我就给大家讲一讲stl的队列了（~~是讲给初学者听的，大佬自动跳过~~）

    queue<> 这个意思是建立一个队列，
    
    大于小于号之前可以用int，long long等、后面接一个变量名。
    
    q.front() 将第一个数取出
    
    q.push() 将一个数加入队列
    	
    q.pop()  将第一个数移除
    
    q.back(） 将最后一个数取出


#### 思路讲完了，现在来讲一讲代码实现

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
long long q,x,y;
queue<int> que;
int main()
{
    scanf("%lld",&q);
    for(long long i=2;i*i<=q;i++)
    {
        while(q%i==0)
        {
            que.push(i);
            q/=i;
        }
    }
    if(q!=1)
        que.push(q);
    int num=que.size();
    if (num==2)
    {
        printf("2");
        return 0;
    }
    if (num==1)
    {
        printf("1\n0");
        return 0;
    }
    x=que.front();
    que.pop();
    y=que.front();
    printf("1\n%d",x*y);
}
```

解释如上




---

## 作者：SunsetSamsara (赞：3)

在这题中，如果要让 K 赢，就不能让 C 拿到质数。

那么，什么时候只能让 K 必输呢？

就是在 K 能取的数只有质数，就是当 $Q = p \times q$ 时 C 一定会拿到质数，小 K 必败。

**所以，小 K 要取两个质数的乘积才能必胜**。证明如下：

如果小 K 取的不是两个质数乘积（当然也不是质数），

那么小 C 就可以取两个质数乘积让小 K 只能取质数，

小 K 必败，所以小 K 只能取两质数乘积。证毕。

如果 $Q = p \times q$ 时输出小 C 必胜，

否则因为题目要求的是**最小的**符合要求的数，所以取在 $Q$ 的质因数分解中最小的两个**可以相同**的质数 $p,q$ 的乘积 $p \times q$ 就是答案。

分解质因数时，如果直接枚举$2\to Q$就会超时，

但是发现 $Q$ 的大部分质因数都要小于等于 $\sqrt Q$，

最后只可能剩下一个大于等于的 $\sqrt Q$ 的质因数，最后除完其它数后特判 $Q$ 是否等于 $1$ 即可。

最后是令人兴奋的代码环节~

```cpp
#include<stdio.h>
int main(){
	long long Q;
	scanf("%lld",&Q);
	int cnt=0;
	long long ps[1001];
	/*分解质因数环节*/
	for(long long i=2;i*i<=Q;++i)//只需枚举小于sqrt(Q)的i即可 
		while(Q%i==0)
			ps[++cnt]=i,Q/=i;
	if(Q!=1)ps[++cnt]=Q;//重要的事情说三遍,一定要特判、一定要特判、一定要特判！
	if(cnt==2){//只有两个质因数 
		printf("2\n");
		return 0;
	}
	printf("1\n");
	if(cnt==1)printf("0\n");//第一次就不能写数字
	else printf("%lld\n",ps[1]*ps[2]);//最小两个数字的乘积 
	return 0;
}
```

---

## 作者：星辰劫难之初 (赞：3)

**~这道题，题目给了很多条件，所以我们要耐心读题**

最后判断出这三种情况：
1. Q是1或质数，此时小K只能选0，胜利。
2. Q是两个质数的积，小K只能选这两个质数中的一个，对方无法写出，对方胜利。
3. Q是多个质数的积，小K有必胜策略，胜利。（当Q=3×5×2=30时，小K选6，对方选择5，小K无法选择，胜利）

（这道题用上[queue队列](https://blog.csdn.net/qq_43678290/article/details/85858650)很方便）
### ~直接上代码

```cpp
#include<bits/stdc++.h>//万能头
#define ll long long
using namespace std;
ll n,ans;
queue<ll>k;//申请队列，不多说
int main()
{
    cin>>n;
    for(ll i=2;i*i<=n;i++)
		while(n%i==0)
			k.push(i),n/=i;
    if(n!=1)
		k.push(n);//如果n不等于一，把n挤到队列中
    if(k.size()==2)
		cout<<2<<endl;
    else if(k.size()==1)
		cout<<1<<endl<<0<<endl;//新手都懂（暗示）
    else
    {
        cout<<1<<endl;
        ans=k.front();
        k.pop();
        printf("%lld\n",ans*k.front());
    }
    return 0;
}
```
这是我的~~第一篇题解~~，若有错请大家多多包涵，我会尽快改正。多谢支持。

---

## 作者：loi_wzhd (赞：3)

总算通过了。发一个c++的题解。

吐下槽，楼下pascal代码完全可以卡掉。

首先分3种情况。

1：n为质数，这样第一次只能选0；

2：n的因子个数为2，这样第一次选完之后只剩下一个指数，对方选0，我方败；

3：n的因子个数 > 3保证选完之后让对方面对情况2，即选最小的两个因子的积。

这里有一个小技巧，筛质数时不必筛到n，筛到根号n就可以，显然，n不会同时存在两个大于根号n的因子。

如果n在除完所有的因子后还剩下数，那么这一定是个质数。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long n,n2;
int pri[10000005],cnt,ji,ans = 1;
bool qu[10000005];
long long min(long long a,int b)
{
    return a < (long long)b ? a : b;
}
int main()
{
    scanf("%lld",&n);n2 = n;
    for(int i = 2;(long long)i * i<= n;i ++)
    {
        if(!qu[i]) pri[++cnt] = i;
        for(int j = 1;j <= cnt;j ++)
        {
            if(pri[j] * i >= min(n,1e7)) break;
            qu[pri[j]*i] = 1;
            if(i % pri[j] == 0) break;
        }
    }
    for(int i = 1;i <= cnt;i ++)
    {
        while(n&&n % pri[i] == 0&&ji < 2) ji ++,ans *= pri[i],n /= pri[i];
        if(n&&n % pri[i] == 0)
        {
            printf("1\n%d",ans);
            return 0;
        }
        if(!n) break;
    }
    if(n2 == n&&n > 1)    printf("1\n0");
    else if(ji == 2&&n > 1) printf("1\n%d",ans);
    else printf("2");
}
```

---

## 作者：tututu (赞：3)

这道题分为三种情况，

1：n为质数，writeln(1); write(0);

2：n为两个质数的乘积（两个质数可以相等），write(2)

3：n很复杂，则输出n最小的两个质因数（可以相等，即n=k\*t\*t，    t为此质因数）的积

还有此题数据有bug，输入数据中没有像8这样最小质因数的指数>=3的数据



```cpp
var
  i,s:longint;
  n,t,n1:int64;
begin
  readln(n);
  n1:=n;
  for i:=2 to trunc(sqrt(n-0.00001)) do
    while n mod i=0 do begin inc(s); n:=n div i; end;
  if trunc(sqrt(n))=sqrt(n) then inc(s);
  n:=n1;
  if s=0 then begin writeln(1); write(0); end
    else
  if s=1 then write(2)
    else
  begin
    t:=1;
    writeln(1);
    for i:=2 to trunc(sqrt(n)) do
      while n mod i=0 do begin t:=t*i; n:=n div i; if t<>i then begin write(t); halt; end; end;
  end;
end.
```

---

## 作者：decoqwq (赞：3)

~~这是一道超级大水题~~

首先如果$Q$是质数就输出$0$就好$\text{qwq}$

如果$Q$是$1$也一样

如果$Q$的质因子个数小于$4$就肯定输了$\text{qaq}$，简单证明一下

设$f(Q)$代表$Q$的因子个数$(2 \leq Q \text{且}!isprime(Q))$

所以$f(Q)=3$，而除了$Q$和$1$，他只剩下一个质因子$(\text{否则}f(Q)!=3)$

而当他选了这个质数时，另外一个人就选不了了，就赢了

所以$f(Q)$不能小于$4$

而当$4 \leq f(Q)$时，就肯定可以了

为了保证**对面选完了我们就一定选不了了**，所以对面能够选择的数一定是质数

那只要剩下的数是两个质数乘积就好啦$(\text{该乘积必须是Q因数})$

上代码$\text{qwq}$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
vector<int> vc;
int flag=1;
int yueshu(int x)
{
    int cnt=1;
    for(int i=2;i*i<=x;i++)
    {
        int l=x;
        while(l%i==0)
        {
            if(vc.size()<2)
            {
                vc.push_back(i);
            }
            if(vc.size()==2&&cnt>=4)
            {
                printf("1\n%lld",vc[0]*vc[1]);
                flag=0;
                return 0;
            }
            if(i*i!=x)
            {
                cnt+=2;
            }
            l/=i;
        } 
    }
    if(cnt<4)
    {
        return 0;
    }
    return 1;
}
main()
{
    int n;
    cin>>n;
    if(yueshu(n))
    {
        printf("1\n%lld",vc[0]*vc[1]);
    }
    else
    {
        if(!flag)
        {
            return 0;
        }
        if(vc.size()==0)
        {
            cout<<1<<endl<<0;
            return 0;
        }
        else
        {
            printf("2");
            return 0;
        }
    }
}
```

---

## 作者：陈雪森 (赞：2)

# 	**题解**


这题乍一看是个筛素数的题,经过片刻思考后发现质因数分解更有利于解决此题。此题还用到了博弈论的知识。
## 质因数分解
```cpp
void divide(ll x){
	ll len=sqrt(x);//枚举到sqrt(n)即可;
	for(int i=2;i<=len;i++){
		if(x%i==0){
			p[++tot]=i;
			while(x%i==0) x/=i,sum++,c[tot]++;
            //c数组用来判断最小质因子有几个,
            sum用来记录总共质因子个数。
		}
	}
	if(x>1) p[++tot]=x,sum++,c[tot]++;
}
```
质因数分解后,再考虑本题的要求.kc先给数。对手取数，自己取数，依次进行.(**注意不能取此数本身和1**)最后谁先不能取数,谁就获胜.
分三种情况考虑。

	1.这个数是1或是质数，此时kc只能取0，取得胜利。
	2.这个数是两个数的乘积，kc只能选1或质数，对方选0，获得胜利。
	3.这个数由多个质数构成。由1、2、得kc有必胜策略。
   sum是用来统计因子个数的;
##    博弈部分
```cpp
	//分类讨论;
	if(sum==2) printf("2");//这个数是两个数的乘积,对手必胜.
	else if(sum==1) printf("1\n0");//kc取0，获得胜利。
	else if(c[1]>1) printf("1\n%lld",p[1]*p[1]);//有两个相同的最小质因子。
	else printf("1\n%lld",p[1]*p[2]);//有两个不同的小的质因子
```
## 代码
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
#define N 5001040
#define ll long long
ll n,tot,p[N],c[N],sum;
void divide(ll x){
	ll len=sqrt(x);
	for(int i=2;i<=len;i++){
		if(x%i==0){
			p[++tot]=i;
			while(x%i==0) x/=i,c[tot]++,sum++;
		}
	}
	if(x>1) p[++tot]=x,c[tot]++,sum++;
}
int main(){
	scanf("%lld",&n);
	divide(n);
	if(sum==2) printf("2");
	else if(sum==1) printf("1\n0");
	else if(c[1]>1) printf("1\n%lld",p[1]*p[1]);
	else printf("1\n%lld",p[1]*p[2]);
	return 0;
}
```





---

## 作者：asdfghjkl123 (赞：2)

这题比较简单（虽然我交了好几次90分……），找到胜利策略是关键。由于剩余这个数可写为两个质数相乘时，进行选择的人一定会输，所以只需让甲第一次选择一个仅可写为两个质数相乘的数即可。

所以，问题就转化为了，求一个数是否可以写成仅由两个质数相乘的形式。如果能，输出2.如果本身是质数，则输出1\n0.否则输出1以及其最小两个质因数（可相同）的积。楼上用了一个队列，但是由于个人对于STL的恐惧……

从小到大筛它的质因数（当然，一个质因数可被多次除去，这也是代码中i--的原因）。筛出质数并记录。如果在1到√n只筛出了一个质数，那么就可以说它只能整除两个质数。

具体的记录细节看代码……
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
long long q;
bool fa,fb,fc;int ta,tb;
int main()
{
	cin>>q;
	for(long long i=2;i*i<=q;i++)
	{
		if(q%i==0)
		{
			q/=i;
			if(fa==false)fa=true,ta=i;
			else if(fb==false)fb=true,tb=i;
			i--;
		}
	}
	if(fb==1)cout<<1<<endl<<ta*tb<<endl;
	else if(fa==false)printf("1\n0\n");
	else printf("2\n");
	return 0;
}
```


---

## 作者：Misaka_Mik0t0 (赞：1)

这道题，分为好几种情况。我们慢慢来讨论。

1. 首先，若 $Q$ 为质数，则先手胜。因为他一开始就无法写数字。
2. 若 $Q$ 为一个质数的平方，或两个质数的积，则后手胜。因为先手第一轮只能写出一个质数，归为情况1。
3. 若 $Q$ 为某个质数的高次方（次数 $\ge 2$），先手胜，因为先手可以写出这个质数的平方，归为情况2。
4. 否则，先手胜。因为先手能写出这个数的两个不同质因子（不妨设为最小两个）的乘积，归为情况2。

综上，只要分解质因数再讨论就行了。这里其实不用全部分解完，分解出前两个就行了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	char ch=getchar();int res=0,k=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-')k=-1;else k=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+ch-'0';
		ch=getchar(); 
	}
	return res*k;
}//速读
long long q,num[10],s[10],k,t;
//num为质因数，sum为次数，k为目前不同质因数个数，t为总质因数个数
int main(){
	scanf("%lld",&q);
	if(q==1){
		printf("2");
		return 0;
	}//放毒瘤数据。本题没有q=1，次数可省
	for(long long i=2;i*i<=q;++i){
		if(q%i==0){
			num[++k]=i;s[k]=1;q/=i;++t;
			while(q%i==0)++s[k],++t,q/=i;
			if(t>=3){
				puts("1");
				if(s[1]>=2)printf("%lld",num[1]*num[1]);
				else printf("%lld",num[1]*num[2]);
				return 0;
			}
		}
	}
	if(q!=1){
		num[++k]=q;s[k]=1;++t;
		if(t>=3){
			puts("1");
			if(s[1]>=2)printf("%lld",num[1]*num[1]);
			else printf("%lld",num[1]*num[2]);
			return 0;
		}
	}
	if(t==1)printf("1\n0");
	else printf("2");
	return 0;
} 
```

---

## 作者：Marginal_world (赞：0)

算法思想：博弈论+质因数分解。

存在必胜策略：对方不得不选择一个质数，自己胜利。

这样只能选择两个质因数的乘积。

由于要求可以制胜的数字最小，我们只需知道两个最小质因数即可。

分类讨论：

给定数是一或质数，此时只能选零，胜利。

给定数是两个质数的积，只能选一或质数，对方选零，对方胜利。

给定数是多个质数的积，有必胜策略，胜利。

博弈论的部分结束了，现在我们要处理如何进行质因数分解的问题了。

对于给定数，我们对于所有小于给定数而大于一的正整数，看 给定数能否整除该整数，如果可以就是给定数的因数。

如果我们在给定数整除正整数时，再次判断给定数能否整除 正整数，这样就可以达到转化问题的效果，并且可以保证，对于每次分解出来的正整数，必然有该整数是质数，因为如果该整数不是质数，其必然有质因数，而这因数必然在之前已经分解掉了，所以分解出来的一定是该整数。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,cnt,p[10000005];
ll check(ll n){
	for(ll i=2;i*i<=n;i++)//最好不要使用sqrt，对时间上有一定影响
	if(n%i==0)return 0;
	return 1;
}
void divide(ll n){//质因数分解部分
	for(ll i=2;i*i<=n;i++)
	while(n%i==0)
	p[++cnt]=i,n/=i;
	if(n!=1)
	p[++cnt]=n;
}
int main(){
	cin>>n;
	if(check(n)){
		cout<<"1\n0";
		return 0;
	}
	divide(n);
	if(cnt==2){
		cout<<"2";
		return 0;
	}
	else{
		cout<<"1\n"<<p[1]*p[2];
	}
	return 0;
}
```

以上就是我对本题的一些理解，希望能帮助到大家。

---


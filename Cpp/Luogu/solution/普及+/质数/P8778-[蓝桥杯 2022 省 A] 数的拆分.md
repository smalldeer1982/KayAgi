# [蓝桥杯 2022 省 A] 数的拆分

## 题目描述

给定 $T$ 个正整数 $a_{i}$，分别问每个 $a_{i}$ 能否表示为 $x_{1}^{y_{1}} \cdot x_{2}^{y_{2}}$ 的形式，其中 $x_{1}, x_{2}$ 为正整数，$y_{1}, y_{2}$ 为大于等于 $2$ 的正整数。

## 说明/提示

**【样例说明】**

第 $4,5,7$ 个数分别可以表示为:

$$
\begin{aligned}
&a_{4}=2^{2} \times 1^{2} ; \\
&a_{5}=2^{3} \times 1^{2} ; \\
&a_{7}=2^{3} \times 3^{2} 。
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $10 \%$ 的评测用例，$1 \leq T \leq 200, a_{i} \leq 10^{9}$;

对于 $30 \%$ 的评测用例，$1 \leq T \leq 300, a_{i} \leq 10^{18}$;

对于 $60 \%$ 的评测用例，$1 \leq T \leq 10000, a_{i} \leq 10^{18}$;

对于所有评测用例，$1 \leq T \leq 100000,1 \leq a_{i} \leq 10^{18}$ 。 

蓝桥杯 2022 省赛 A 组 I 题。

## 样例 #1

### 输入

```
7
2
6
12
4
8
24
72```

### 输出

```
no
no
no
yes
yes
no
yes```

# 题解

## 作者：Lord_Sky2048 (赞：20)

首先将 $a$ 进行素因子分解 $p_1^{q_1} p_2^{q_2}$......$ p_n^{q_n}$

$∀q_i\geq2$,要拆分成 $k_1 \times y_1 + k_2 \times y_2 = q_i,k_1,k_2\geq0,y_1,y_2\geq2$

$y1=2,y2=3$ 可以保证对于 $∀q_i\geq2$,均有正整数解(也含0)

所以问题就被我们转换为：

$a$ 能否变为 $t_1^2t_2^3$

因为 $a\leq10^{18}$  所以  $t_1^2t_2^3\leq10^{18}$ 。

所以只需要暴力判断 $4000$ 以内的素因子，对于大于 $4000$ 的 $p$ ，指数只可能是 $2 , 3 , 4$ ，即判断一下是否为平方数或者立方数即可。

时间复杂度 $O(T)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;
template <typename T>
inline T read(T& x) {
  x = 0;
  T w = 1;
  char ch = 0;
  while (ch < '0' || ch > '9') {
    if (ch == '-') w = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = x * 10 + (ch - '0');
    ch = getchar();
  }
  return x * w;
}

bool not_prime[4010];
int prime[4010], tot;
void init(int n)
{
    for(int i = 2; i <= n; i++)if(!not_prime[i])
    {
        prime[++tot] = i;
        for(int j = i + i; j <= n; j += i)
            not_prime[j] = 1;
    }
}
inline bool check(ll x)
{
    ///检查平方数
    ll y = pow(x, 0.5);
    if(y * y == x || (y + 1) * (y + 1) == x)
        return true;
    ///检查立方数
    y = pow(x, 1.0 / 3);
    if(y * y * y == x || (y + 1) * (y + 1) * (y + 1) == x || (y + 2) * (y + 2) * (y + 2) == x)
        return true;
    return false;
}
int main()
{
    init(4000);
    int T;
    read(T);
    while(T--)
    {
        ll x;
        read(x);
        if(check(x))
        {
            puts("yes");
            continue;
        }
        bool flag = true;
        for(int i = 1; i <= tot; i++)if(x % prime[i] == 0){
            int now = 0;
            while(x % prime[i] == 0)
            {
                now++;
                x /= prime[i] ;
            }
            ///cout<<prime[i]<<" "<<now<<endl;
            if(now == 1)
            {
                flag = false;
                break;
            }
        }
        if(flag & check(x))
        {
            puts("yes");
            continue;
        }
        else
        {
            puts("no");
        }
    }
    return 0;
}

```


---

## 作者：BqtMtsZDnlpsT (赞：14)

？题。

把每一次询问的数记为 $n$。

- 引理：如果能把一个数表示为 $x_1^{y_1}\cdot x_2^{y_2} (y_1,y_2\ge2,y_1,y_2\in\mathbb N)$ 的形式，那么一定可以表示为 $u^2\cdot v^3$ 的形式。

	证明：
    
	因为如果 $y_1$ 是 $\ge1$ 的奇数，那么 $y_1$ 可以表示为 $3+2k$，即 $x_1^{y_1}=x_1^3\cdot \left(x_1^{\frac{y_1-3}2}\right)^2$。

	如果 $y_1$ 是偶数， $x_1^{y_1}=\left(x_1^{\frac{y_1}2}\right)^2$。

	同理，$y_2$ 也能如此表示。
    
钦定 $x_1\le x_2$，$y_1,y_2\in\{2,3\}(y_1\neq y_2)$。    

所以，对于一组合法的 $x_1,x_2,y_1,y_2$，$x_1^5\le x_1^{y_1}x_2^{y_2}$，$x_1\le\sqrt[5]{n}$。

所以考虑枚举 $x_1,y_1$，可以得到 $O(T\sqrt[5]{n})$ 的做法。

但是还不够。


把 $n$ 表示为 $\prod_i p_i^{k_i}(p_i\in\mathbb P,k_i\in \mathbb N^*)$ 的形式。

如果存在 $i$ 使得 $k_i=1$，那么答案一定是 `no`，因为这个 $p_i$ 无法分到 $x_1$ 或 $x_2$ 中。

对于 $k_i> 1$，一定可以按照引理证明中的拆分方法分到 $x_1$、$x_2$ 中。

所以我们枚举 $\sqrt[5]{n}$ 内的所有质数 $p$，记其最多能整除的次数为 $k$：

- 如果 $k=0$，跳过。
- $k=1$，无解。
- $k\ge 2$，将 $n$ 除以 $p^k$。

不难发现，最后 $n$ 剩下的部分中 $x_1$ 已经被除干净了。

只需判断其是否能表示为 $a^m(a\ge1,m\ge2,a,m\in\mathbb N)$ 即可。

先特判 $a=1$，再考虑到 $a\ge2$ 时，$m\le 60$，枚举 $m$ 二分或者硬算即可。

复杂度 $O(T\pi(\sqrt[5]{n})+60T)$，$\pi(\sqrt[5]{10^{18}})=549$。

----

upd：我好像好像了。

最后一个数一定可以表示为 $a^2$ 或 $a^3$。

所以不用那么麻烦。

```cpp
    ll n=read<ll>();
    For(i,1,t){
        ll u=1ll*p[i]*p[i];
        if(!(n%u))
            while(!(n%p[i]))n/=p[i];
        else if(n%u&&!(n%p[i]))return puts("no");
        if(n==1)return puts("yes");
    }
    ll x=cbrtl(n);if(x*x*x==n)return puts("yes");
    x=sqrtl(n);if(x*x==n)return puts("yes");
    return puts("no");
```

---

## 作者：王熙文 (赞：9)

## 思路

结论：如果一个数 $a=x_1^{y_1} \times x_2^{y_2}$，$x_1,y_1,y_1,y_2 \ge 2$，则 $a$ 一定能表示成 $x^k$，$k \ge 2$ 或 $x^2 \times y^3$ 的形式。

证明：我们可以通过类似辗转相除的方式将 $y_1,y_2$ 变小。设 $y_1 \le y_2$。首先，若 $y_1=y_2$，则 $a=(x_1x_2)^{y_1}$。否则，若 $y_2-y_1 \not= 1$，则 $a=(x_1x_2)^{y_1} \times x_2^{y_2-y_1}$。最后，当 $y_2-y_1=1$ 时，一定有一个数是偶数。这样将偶数的那个数的底数变成平方，指数除以二就可以继续变小了。最后一定可以变成 $x^k$ 或 $x^2 \times y^3$ 的形式。

有了这个结论，就可以做了。首先判断 $a=x^k$ 的形式。可以枚举 $k$（$k$ 一定是 $\log$ 级别的），接下来判断 $\lfloor \sqrt[k]{a}\rfloor^k$ 是否等于 $a$ 即可。

接下来判断是否 $a=x^2 \times y^3$。注意到这两个的指数之和为 $5$，所以 $\min(x,y) \le \sqrt[5]{10^{18}} \approx 4000$。我们可以枚举 $1 \sim 4000$ 中的数 $b$。如果 $b$ 是平方数且 $\dfrac{a}{b}$ 是立方数，或者 $b$ 是立方数且 $\dfrac{a}{b}$ 是平方数，则成立。

但是这样并不能过。可以发现 $1\sim 4000$ 里面 $x^2 \mid a$ 或 $x^3 \mid a$ 的数并不多，所以可以直接求出来 $a$ 在 $\le 4000$ 中的质数以及指数，然后通过 dfs 凑出 $x^2$ 或者 $y^3$。之后暴力判断。这种方式比较暴力，但好想且能过。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a;
int qpow(int a,int b)
{
	if(b<=3) return b==2?a*a:a*a*a;
	int ans=1;
	while(b)
	{
		if(b&1) ans*=a;
		a*=a;
		b>>=1;
	}
	return ans;
}
bool checkpow(int a,int k) // a 是否为某个数的 k 次方
{
	int x=pow(a,1.0/k)+1e-5;
	return qpow(x,k)==a;
}
int tot=0,prime[1010]; bool vis[4010];
int cnt; pair<int,int> zys[1010];
bool flag;
void dfs(int now,int nowx,bool op)
{
	if(flag || nowx>4000) return;
	if(now==cnt+1)
	{
		if(!op)
		{
			if(a%(nowx*nowx)==0 && checkpow(a/nowx/nowx,3)) flag=1;
		}
		else
		{
			if(a%(nowx*nowx*nowx)==0 && checkpow(a/nowx/nowx/nowx,2)) flag=1;
		}
		return;
	}
	for(int i=0; i<=zys[now].second/(!op?2:3) && nowx<=4000; ++i) // 因为要求平方/立方之后还能整除，所以指数只能取到一半/三分之一
	{
		dfs(now+1,nowx,op);
		nowx*=zys[now].first;
	}
}
signed main()
{
	for(int i=2; i<=4000; ++i)
	{
		if(!vis[i])
		{
			prime[++tot]=i;
			for(int j=i*i; j<=4000; j+=i) vis[j]=1;
		}
	}
	int t; cin>>t; while(t--)
	{
		cin>>a;
		flag=0;
		for(int k=2; k<=60; ++k)
		{
			if(checkpow(a,k)) { flag=1; break; }
		}
		if(flag) { puts("yes"); continue; }
		int tmp=a; cnt=0;
		for(int i=1; i<=tot; ++i)
		{
			if(tmp%prime[i]==0)
			{
				zys[++cnt]={prime[i],0};
				while(tmp%prime[i]==0) ++zys[cnt].second,tmp/=prime[i];
			}
		}
		dfs(1,1,0);
		// 注释的是暴力判断
		// for(int i=2; i<=4000 && i*i<=a; ++i)
		// {
			// if(a%(i*i)==0 && checkpow(a/i/i,3)) { flag=1; break; }
		// }
		if(flag) { puts("yes"); continue; }
		dfs(1,1,1);
		// for(int i=2; i<=4000 && i*i*i<=a; ++i)
		// {
			// if(a%(i*i*i)==0 && checkpow(a/i/i/i,2)) { flag=1; break; }
		// }
		puts(flag?"yes":"no");
	}
	return 0;
}
```

---

## 作者：panyanppyy (赞：7)

这只有黄题？
## Solution

考虑一些神秘的性质：

如果 $n$ 合法，那一定能被拆成 $x^2\times y^3$ 的形式。

如果有一个数 $a$ 在 $n$ 中有 $x(x>1)$ 次，那一定能拆成 $x=2A+3B$。

$x$ 是偶数显然能变成 $2A$，如果是奇数那一定能变成 $2A+3B$。

所以直接 $\sqrt[5]{n}$ 筛以内的素数，然后如果有 $x=1$ 直接判无解，否则看能不能拆成平方式或者立方式就可以了。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ri register
#define all(x) (x).begin(),(x).end()
using namespace std;
template<typename T_>void operator+=(vector<T_>&x,const T_&y){x.push_back(y);}
const int M=4007;
bool f[M];
vector<int>s;
int T;
ll n;
void ss(){
	memset(f,1,sizeof(f)),*f=f[1]=0;
	for(int i=2;i<M;i++)if(f[i]){
		s+=i;
		for(int j=i;j<M;j+=i)f[j]=0;
	}
}
ll cbr(int x){return 1ll*x*x*x;}
bool check(ll x){
	int y=sqrt(x);
	if(1ll*y*y==x)return 1;
	y=cbrt(x);
	if(cbr(y)==x||cbr(y+1)==x||cbr(y-1)==x)return 1;
	return 0;
}
void work(){
	cin>>n;
	for(int i:s)
		if(n%i==0){
			int x=0;
			while(n%i==0)n/=i,x++;
			if(x==1)return cout<<"no\n",void();
		}
	cout<<(check(n)?"yes\n":"no\n");
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	ss();
	cin>>T;
	while(T--)work();
	return 0;
}
```

---

## 作者：ylch (赞：3)

[Luogu - P8778 数的拆分](https://www.luogu.com.cn/problem/P8778)

## Begining
感觉这题评黄少了，至少得是道绿题。

这篇题解记录了我一下午做题的心路历程，可能有点兀长，也有很多没用的内容，但或许可以加深对题目的理解。

有错误欢迎指出！本蒟蒻一定虚心接受。

提示：题解中有 4 个结论，代表 4 个可行的判定，是有连贯关系的，可以着重理解。

## Description

给定 $T$ 个正整数 $a_{i}$，分别问每个 $a_{i}$ 能否表示为 $a_i={x_1}^{y_1} \cdot {x_2}^{y_2}(x_1,y1 \in \mathbb{N^+},\ y1,y2 \ge 2)$ 的形式。

## Analysis

首先对 $a_i$ 进行质因子分解：$a_i={p_1}^{c_1} \times {p_2}^{c_2} \times \cdots$

然后，我们只需要考虑把 $a_i$ 的幂次拆成一个 $y_1$ 的倍数加上 $y_2$ 的倍数的形式，即对于 $a_i=p^y$，$y = k_1 \times y_1 + k_2 \times y_2$。

以 $5^7$ 为例，它可以拆成 $(5^2)^2 \times (5^1)^3$，也就是 $5^{2 \times 2} \times 5^{1 \times 3}$，而 $2 \times 2 + 1 \times 3=7$。

那么我们只要合理构造出 $y_1$ 和 $y_2$ 就行了。在刹那间，你的脑电波和大神欧拉对上了，他给你一条重要信息：$2,3$ 是一对万能构造数！

即我们一定可以把 $a_i$ 的幂次拆成 $2k_1+3k_2$ 的形式。

------------

简单证明一下：

对于所有偶数，因为偶数一定是 $2$ 的倍数，所以只要把 $k_2$ 的系数设为 $0$ 即可；

对于所有 $\ge 3$ 的奇数，因为奇数 = 偶数 + 奇数，而相邻的奇数之间的最小差值为 $2$，所以用 $2k_1$ 表示偶数部分，$3k_2$ 表示奇数部分，一定可以凑成一个奇数。

凑不出来的只有 $1$，但这道题里面没有 $1$，所以该结论成立。


------------

**结论 1**：
> 拆分 $a_i$ 的质因子一定**不能有** $1$ 次幂，这一定凑不出来。

这条结论非常重要，直接决定了我们以后的做题方向。But，$T \le 10^5,a_i \le 10^{18}$，直接看有没有 $1$ 次幂会超时。

那么，我们可以先判断 $a_i$ 是不是完全平方数或完全立方数，如果是，那么它的幂次一定可以拆成 $2k_1$ 或 $3k_2$ 的形式。

> 若 $\lfloor \sqrt{a_i} \rfloor \times \lfloor \sqrt{a_i} \rfloor = a_i$，则 $a_i$ 是完全平方数；\
> 若 $\lfloor \sqrt[3]{a_i} \rfloor \times \lfloor \sqrt[3]{a_i} \rfloor \times \lfloor \sqrt[3]{a_i} \rfloor = a_i$，则 $a_i$ 是完全立方数。

（这样投机取巧应该也能骗到不少分）

然后，因为现在 $a_i$ 既不是完全平方数，也不是完全立方数，那么其一定可以表示成 $n^2 \times m^3$ 的形式，其中 $n,m \gt 1$。

那它又一定可以转化为 $(n \times m)^2 \times m$。

**结论 2**：于是乎，我们又有了一个重大发现：
> 若 $a_i=n^2 \times m^3$，则分解质因数时筛掉 $\le n(n \le 10^9)$ 的数后剩下的 $a_i$ 一定是一个**完全平方数**；分解质因数时筛掉 $\le m(m \le 10^6)$ 的数后剩下的 $a_i$ 一定是一个**完全立方数**！

可知 $m \le \sqrt[3]{a_i}$，即 $m \le 10^6$，则又可以枚举 $m$ ，这样枚举立方以下的，又能降一点时间复杂度。

But，这样复杂度为 $\text{O}(Tm)$，超时在所难免。

------------

题目做到这里，基本上人已经懵了。但有句话说得好：“不忘初心，牢记使命！”我们的“初心”是什么？——是**找 $a_i$ 分解质因数后有没有一次方的质因数**。我们的“使命”是什么？——是 AC 这道题。

所以，我们不能就此放弃。回想我们最初的目的是找有没有一次方的质因数，那我们就可以把 $\sqrt[3]{a_i}$ 以内（即 $10^6$ 以内）的质数先筛出来。

那它剩下的质因数一定都是 $\gt 10^6$ 的数，大于 $\sqrt{a_i}=10^9$ 的质因数一定最多只有 $1$ 个（它自然是一次的），那么在 $10^6 \sim 10^9$ 这个区间里的质因子就最多有 $2$ 个。

**结论 3**：
> 如果有 $\gt 10^9$ 的质因子，那么它一定是**一次方**的，这就找到了。

------------

那除了上述之外，还能怎么优化呢？

再回到最初的起点，是一个 $n^2 \times m^3$ 的情况，根据我们敏锐的数感，聪明的你会发现，这个 $n$ 一定是很小的，因为过大的 $n$ 一定组不成这种形式。

假如 $n= m = 1000$，那么 $1000^2 \times 1000^3=10^{15}$，已经很大了；当 $n=m=3000$ 时，$3000^2 \times 3000^3=2.43 \times 10^{17}$，已经十分接近。

所以 $n=m=4000$ 的时候，$n^2 \times m^3$ 一定 $\gt 10^{18}$。

**结论 4**：
> $n^2 \times m^3$ 中 $n,m$ 最多只有 $4000$。


------------
**正解：**

综上，只要去枚举 $4000$ 以内的质数（结论 4），看里面有没有是一次方的质因数（结论 1）；同时把质因数给 $a_i$ 除进去，看最后剩下的 $a_i$ 是不是完全平方数或完全立方数即可（结论 2）。

这样去枚举，则不算预处理素数的复杂度是 $\text{O}(T \sum\limits_{i=1}^{T} \sqrt{a_i})$，可以通过。

## Code

注意系统自带的 `sqrt` 函数和 `cbrt` 函数可能存在精度误差（见 [P10373立方根](https://www.luogu.com.cn/problem/P10373) 题目背景）。

在 P10373 中给出了修复方法，但那不是很准确。发现整型向下取整误差一定不超过 $1$，所以可以把分解完质因数后的 $a_i$ 分别尝试 $a_i \pm 1$ 是否可行，以此修复误差。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxp = 4500;

int vis[maxp + 5], prime[maxp + 5], len;

// 用埃氏筛筛出4500以内的素数
void getPrime()
{
    for(int i = 2; i <= maxp; i ++){
        if(!vis[i]) prime[len ++] = i;
        for(int j = 2 * i; j <= maxp; j += i) vis[j] = 1;
    }
}

// 判断x是不是完全平方数或完全立方数
bool check(ll x)
{
    ll sq = sqrtl(x);
    if(sq*sq==x || (sq+1)*(sq+1)==x || (sq-1)*(sq-1)==x){ // 避免有误差，这个误差确定不超过1
        return true;
    }
    
    ll cb = cbrtl(x);
    if(cb*cb*cb==x || (cb+1)*(cb+1)*(cb+1)==x || (cb-1)*(cb-1)*(cb-1)==x){
        return true;
    }
    
    return false;
}

void solve()
{
    ll a;
    cin >> a;
    
    // 是完全平方数或完全立方数直接yes
    if(check(a)){
        cout << "yes\n";
        return ;
    }
    
    // 下面分解质因数
    bool flag = true;
    for(int i = 0; i < len; i ++){
        int cnt = 0;
        int p = prime[i];
        while(a % p == 0){
            cnt ++;
            a /= p;
        }
        // 出现1次方，不合法
        if(cnt == 1){
            cout << "no\n";
            return ;
        }
    }
    
    // 最后再判断一遍分解完的即可
    if(check(a)) cout << "yes\n";
    else cout << "no\n";
}

signed main()
{
    ios :: sync_with_stdio(false), cin.tie(0), cout.tie(0);
    getPrime();
    int T; cin >> T;
    while(T --) solve();
    return 0;
}
```

## Ending

管理员大大辛苦啦~

这里是 [YLCHUP](https://www.luogu.com.cn/blog/YLCHUP/)，谢谢大家！。

---

## 作者：ethanhyz (赞：1)

# P8778 [蓝桥杯 2022 省 A] 数的拆分 题解

## 基本思路

看到题面中，要把一个数拆分成 $x_1^{y_1} \times x_2^{y_2}$ 的形式，立即就能想到质因数分解：

$$a = p_1^{q_1} \times p_2^{q_2} \times p_3^{q_3} \times \cdots$$

为了更贴近 $x_1^{y_1} \times x_2^{y_2}$ 的形式，可以将 $q_i$ 拆成 $m_i \times y_1 + n_i \times y_2$, 其中 $y_1,y_2 \geq 2$

考虑最小的 $y_1$、$y_2$，分别为 $2$ 和 $3$：

注意到：恰好，对于 $\forall x \in \Z$ 且 $x \in [2,+ \infin)$，有 $x=2m+3n \text{ } ( m,n \in \N )$

证明如下：

- 若 $x$ 为偶数，则 $x=2 \times (x \div 2)$，满足；
- 若 $x$ 为奇数，则 $x=2 \times ((x-3) \div 2)+3$，满足。

因此，对于 $a = p_1^{q_1} \times p_2^{q_2} \times p_3^{q_3} \times \cdots$，只要对于 $\forall q_i$ 都有 $q_i \geq 2$，$a$ 就能表达为 $x_1^2 \times x_2^3$，满足题意。

所以，我们只需要对每个 $a_i$ 分解质因数，判断其中有没有质因数指数为 $1$ 即可，若有则不符合，若无则符合。

## 优化

然而，朴素的质因数分解的时间复杂度高达 $O(\sqrt a)$，对于 $a \in \left( 1,10^{18} \right)$ 和多达 $100000$ 组的多测组数，这样做必然会 $\texttt{TLE}$。

不难发现，$10^{18} \geq a=x_1^2 \times x_2^3 \geq (\min{(x1,x2)})^5$，

因此 $\min{(x1,x2)} \leq (10^{18})^{\frac{1}{5}}<4000$

所以，可以将 $a$ 在 $4000$ 内分解质因数，即 $a = k \times p_1^{q_1} \times p_2^{q_2} \times p_3^{q_3} \times \cdots$，其中 $p_i \leq 4000$，就可以保证 $a$ 的因数 $\min{(x1,x2)}$ 已被除尽。

多说一句，$4000$ 是绝对保险的，但经过实测发现对于本题数据 $500$ 都可以过。

同时，$k$ 必须是平方数（可并入 $x_1^2$）或立方数（可并入 $x_2^3$）。

判断平方数、立方数可以这样：

- 若 $\lfloor \sqrt{k} \rfloor ^ 2 = k$ 则 $k$ 为平方数；
- 若 $\lfloor \sqrt[3]{k} \rfloor ^ 3 = k$ 则 $k$ 为立方数。

因此，$a = k \times p_1^{q_1} \times p_2^{q_2} \times p_3^{q_3} \times \cdots$（其中 $p_i \leq 4000$）符合题意的充要条件是：

对于 $\forall i$ 有 $q_i \neq 1$ 且 $k$ 为平方数或立方数。

由此即可写出代码：

## Code

```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 4000
using namespace std;
ll t,a,p[4005],k,cnt,flag;
bool ip[4005];
int main()
{
	ip[0]=ip[1]=1;
	for(int i=2;i<=sqrt(N);i++)
		if(!ip[i])
			for(int j=2;i*j<=N;j++)
				ip[i*j]=1;
	//上面是朴素素数筛，i为素数则ip[i]=0			
	for(int i=1;i<=N;i++)
		if(!ip[i]) p[++k]=i;
	//p存储4000内的所有素数，k为个数	
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld",&a);
		flag=0;
		//flag=1为无解
		for(int i=1;i<=k;i++)
		{
			if(a==1) break;
			cnt=0;
			while(a%p[i]==0)
			{
				a/=p[i];
				cnt++;
				//cnt为该质数的指数
			}
			if(cnt==1) 
			//如果存在某质数指数为1则无解
			{
				flag=1;
				break;
			}
		}
		ll sr=sqrt(a)+0.0000001,cr=pow(a,1.0/3)+0.0000001;
		//sqrt和pow有精度问题，要加一个小量
		if(sr*sr!=a&&cr*cr*cr!=a&&a!=1) flag=1;
		//k不为平方数、立方数则无解
		if(flag) puts("no");
		else puts("yes");
	}
	return 0;
}
```

## 完结撒花～

---

## 作者：qwq___qaq (赞：1)

这题只有黄？

前言：本题数据不强，放了 $O(T\dfrac{\sqrt[3]V}{\ln\sqrt[3]V})$ 过，卡法是塞一堆大质数。

拿到本题，首先想到的应该是质因数分解，得到 $p_1^{m_1}p_2^{m_2}\cdots p_k^{m_k}$，显然有如果 $\exists i\in[1,k],m_i=1$，那么无解。

**Lamma**：如果有解，一定可以表示成 $x^2y^3$ 的形式。

**Proof**：对每个 $m\bmod 3$ 进行分类讨论。

- $m\bmod 3=0$，可以表示成 $3k$ 的形式。

- $m\bmod 3=1$，因为 $m>1$，所以可以表示成 $2\times 2+3k$ 的形式。

- $m\bmod 3=2$，可以表示成 $2+3k$ 的形式。

同时，我们也证明了，无解的充要条件就是 $\exists i\in[1,k],m_i=1$。

此时显然枚举 $y$ 就能做到 $O(T\sqrt[3]V)$ 的解法，但显然过不了。

把 $a_i$ 筛掉 $[1,\sqrt[3]V]$ 中的因子，如果有 $m=1$ 就报告无解，那么此时剩下的因子都是 $>\sqrt[3]V$ 的，那么它只会以平方的形式出现，并且不会同时出现两个，那么只需要判断剩下一个数是否是完全平方数即可。显然筛因子的一步只需要筛质因子即可，可以做到 $O(T\dfrac{\sqrt[3]V}{\ln\sqrt[3]V})$，但这并不是我们想要的。

能想到筛立方判平方，为什么就不能筛四次方判立方呢？所以可以筛掉 $[1,\sqrt[4]V]$ 中所有质因子，这样剩下的只会是一个完全平方数或完全立方数。更进一步地，你会发现只需要筛出 $[1,\sqrt[5] V]$ 即可，因为剩下的如果 $x,y$ 都有值的话，你会有 $x^2y^3>\sqrt[5]V^2\sqrt[5]V^3=V$，显然是不行的，所以就只需要判完全平方数或完全立方数即可，这样就可以得到 $O(T\dfrac{\sqrt[5]V}{\ln\sqrt[5]V})$ 的做法。

---

## 作者：Super_Cube (赞：1)

# Solution

模拟赛签到题，给我整自闭了。

为了把 $n$ 分解为 $a^xb^y$ 的形式，而 $a,b$ 可以为 $1$，所以其实是判断 $n$ 是否可以表示为 $a^2b^3$。证明？对 $n$ 进行质因数分解，如果某个质因子指数为 $2,3$ 那在对应位置上累乘，如果大于 $3$ 一定可以拆成一堆二加一个三的形式，也在对应位置乘上就行。所以无解的情况即为存在某个质因子的指数为 $1$，这样它无处安放。

这个时候已经有一个无脑的 $O(TV^{0.25})$ 的做法，即利用 Pollard-Rho 算法快速分解质因数，很遗憾无法通过。

注意到若有一个质因子的指数不小于 $5$，那么该质因子不大于 $V^{0.2}\approx4000$。所以先用不超过 $4000$ 的质数对 $n$ 进行分解，如果此时已出现指数为 $1$ 的情况直接无解；否则只会剩下至多一个质因子，且其指数为 $2$ 或 $3$，稍微判断下即可。

# Code

```cpp
#include<bits/stdc++.h>
typedef long long ll;
inline bool check(ll n){
	ll x=sqrt(n);
	if((x-1)*(x-1)==n||x*x==n||(x+1)*(x+1)==n)return true;
	x=pow(n,1.0/3);
	return (x-1)*(x-1)*(x-1)==n||x*x*x==n||(x+1)*(x+1)*(x+1)==n;
}
const int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989};
int T,ok,cnt;
ll n;
int main(){
//	freopen("number.in","r",stdin);
//	freopen("number.out","w",stdout);
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(0);std::cout.tie(0);
	std::cin>>T;
	while(T--){
		std::cin>>n;
		if(check(n)){
			std::cout<<"yes\n";
			continue;
		}
		ok=1;
		for(int i=0,c;i<550;++i)
			if(!(n%prime[i])){
				for(c=0;!(n%prime[i]);++c)n/=prime[i];
				if(c==1)ok=0,i=550;
			}
		if(!ok){
			std::cout<<"no\n";
			continue;
		}
		std::cout<<(check(n)?"yes":"no")<<'\n';
	}
	return 0;
}
```

---

## 作者：Lisbourg (赞：0)

### 题目分析
公式 ${x_1}^{y_1} \times {x_2}^{y_2}$ 可以进行如下变形。
- 如果 $y_1$ 为偶数，则前半部分可以表示为 $({x_1}^{\frac{y_1}{2}})^2 \times 1^3$。
- 如果 $y_1$ 为奇数**且不为** $1$，则前半部分可以表示为 $({x_1}^{\frac{{y_1}-3}{2}})^2 \times {x_1}^3$。

因此，原式可以表示为 $n = a^2 \times b^3$。由于 $n \leq 10^{18}$，我们可以得出结论 $\min(a,b)\leq 10^{\frac{18}{5}}\approx4000$。

因此，只需用 $4000$ 以内的素数一一判断，若是其因数，则判断能被除几次，只要不是 $1$ 就继续，因为能分成 $a^2\times b^3$，否则结果为 no，最后判断剩余的数是否为平方数或立方数即可。
### 代码
因此，核心代码如下。

```cpp
if(check(n)){//check用来检查是否为平方或立方数
	cout<<"yes\n";
	continue;
}
for(int i=1;i<=sum;i++){//sum为素数个数
	if(n%ss[i]!=0) continue;
	int gs=0;
	while(n%ss[i]==0){
		gs++;
		n/=ss[i];
	}
	if(gs==1){
		cout<<"no\n";
		goto q;
	}
}
if(check(n)) cout<<"yes\n";
else cout<<"no\n";
q:;
```

**温馨提醒**，自带的开方函数等有误差。

[一个流程图，太丑不强迫看](https://cdn.luogu.com.cn/upload/image_hosting/y911esm9.png)。

解释，对于为什么最后剩下的数必须为平方数或立方数，其实很好理解，如果有剩余，那么这个数必然为一个或多个大于 $4000$ 的一个素数的 $1$ 次方，$2$ 次方，$3$ 次方或 $4$ 次方（因为数据范围，所以不可能大于 $4$ 次），其中 $4$ 次方可理解为 $2$ 次方的平方，因此只需判断是否为平方数或立方数，如果不是就会被分成 $a^2\times b^3\times k$，$k$ 为一堆大于 $4000$ 的素数。

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

给出一个正整数 $n$，询问 $n$ 是否能被表示为 $x_1^p\times x_2^q$ 的形式。

### 2. 思路

首先我们对 $n$ 进行质因数分解：$n=\prod\limits p_i^{a_i}$。

这里我们有一个引理：任意大于 $1$ 的正整数都可以表示为 $2\times a+3\times b$ 的形式。

证明不难，假如这个正整数为偶数，则其一定可以被表示为若干个 $2$ 的和，否则去掉其中一个 $2$ 替换成 $3$ 即可。

由这个引理，我们发现，只要 $\prod\limits p_i^{a_i}$ 中所有 $a_i>1$，就一定可以将 $a_i$ 分解为 $2\times a+3\times b$ 的形式。

从而 $n$ 也就一定能被表示为 $x^2y^3$ 的形式。

因此我们枚举 $n$ 的质因数，判断其中是否有一次即可。

然而这样会 TLE。

注意到 $x^2y^3$ 的指数为 $5$ ，因而 $x$ 和 $y$ 中较小的那一个一定不超过 $n^{\frac{1}{5}}$，而 $n$ 的最大值为 $10^{18}$，因而 $x$ 和 $y$ 中较小的一个一定不超过 $10^{\frac{18}{5}}\approx 4000$。

所以我们考虑预处理 $4000$ 以下的质数，然后用 $n$ 去试除，假如能整除就除并让指数加一，假如指数为一就跳出循环并标记这个数。

假如循环正确结束，我们判断最后的 $n$ 是否为平方数或立方数，假如是就输出 `yes`，否则输出 `no`。

最后一点，在判断是否为平方数或立方数时，需要对平方根和立方根加一避免误差。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,flag,prime[550]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989};
bool check(int x){
	int p=pow(x,0.5),q=pow(x,1.0/3);
	if(p*p==x||q*q*q==x||(p+1)*(p+1)==x||(q+1)*(q+1)*(q+1)==x||(q+2)*(q+2)*(q+2)==x){
		return true;
	}
	else{
		return false;
	}
}
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		flag=0;
		for(int i=0;i<550;i++){
			int cnt=0;
			while(n%prime[i]==0){
				n/=prime[i];
				cnt++;
			}
			if(cnt==1){
				flag=1;
				break;
			}
		}
		if(!flag&&check(n)){
			cout<<"yes"<<endl;
		}
		else{
			cout<<"no"<<endl;
		}
	}
	return 0;
}

```

---

## 作者：chlchl (赞：0)

有点逆天了，建议升绿。

## Solution
首先有个小奥结论：仅用若干个 $2$ 和 $3$ 求和是可以凑出 $\ge 2$ 的所有数的。

构造是选尽可能多的 $2$，能凑出所有偶数；最后如果剩下 $1$，撤走一个 $2$，换成一个 $3$ 就行了。

因此，对于任意 $p=\prod p_i^{k_i},k_i\ge 2$，由于每个 $k_i$ 都可以表示成一堆 $2$ 和一堆 $3$ 的和，我们一定可以把 $p$ 改写成 $x_1^2x_2^3$ 的形式。

所以题目等价于求 $a_i$ 是否可以被写成 $x_1^2x_2^3$ 的形式，其中 $x_1,x_2$ 是正整数。

然后考虑，若 $a_i=x_1^2x_2^3$，则 $\min(x_1,x_2)\le\sqrt[5]{a_i}$，当且仅当 $a_i=p^5$，$p$ 是质数时取等。这个应该很显然吧。

虽然 $x_1,x_2$ 没有要求是质数，但是其一定可以被表示成若干质数的乘积。因此，直接筛出 $\sqrt[5]{a_i}$ 内的质数 $p_i$，依次检查 $p_i^2$ 能否整除 $a_i$，如果能就让它一直 $\div a_i$。

这样做完之后，$a_i'$ 中剩下的质因数必然 $>\sqrt[5]{a_i}$，如果 $a_i$ 是合法的，这类质因数不可能出现多于两种。

分类讨论一下，发现合法的 $a_i'$ 一定能表示成 $v^2$ 或 $v^3$ 或 $v^4$ 的形式（$v$ 是正整数）。这个可以 $O(1)$ 判断。

由于 $n$ 以内质数的个数趋近于 $O(\dfrac{n}{\ln n})$，因此单词询问的时间复杂度是 $O(\sqrt[5]{V}+\sqrt[5]{\frac{V}{\ln V}})$。多测把筛质数提到外面去就行了。

时间复杂度 $O(\sqrt[5]{V}+T\sqrt[5]{\frac{V}{\ln V}})$。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 40000 + 10;
int T, len;
ll n, p[N];
bool isp[N];

void getprime(int n){
	for(int i=2;i<=n;i++){
		if(!isp[i])
			p[++len] = i;
		for(int j=1;j<=len&&i*p[j]<=n;j++){
			isp[i * p[j]] = 1;
			if(i % p[j] == 0)
				break;
		}
	}
}

ll exp(ll a, int b){
	ll cnt = 1;
	while(b){
		if(b & 1)
			cnt *= a;
		a *= a, b >>= 1;
	}
	return cnt;
}

void solve(){
	scanf("%lld", &n);
	ll m = n;
	ll lim = ceil(pow(m, 0.2)) + 2;
	for(int i=1;i<=len&&p[i]<=lim;i++){
		ll pp = p[i] * p[i];
		if(m % pp == 0){
			m /= pp;
			while(m % p[i] == 0)
				m /= p[i];
			lim = ceil(pow(m, 0.2)) + 2;
		}
	}
	//m 此时若合法，其必定只能表示为一个大数的 k 次方（k<=4）
	for(int i=2;i<=4;i++){
		ll lg = ceil(pow(m, 1.0 / i));
		if(exp(lg, i) == m)
			return printf("yes\n"), void();
	}
	printf("no\n");
}

int main(){
	scanf("%d", &T);
	getprime(N - 10);
	while(T--)
		solve();
	return 0;
}
```

---


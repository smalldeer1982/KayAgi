# [常州市赛 2023] ABC 字符串

## 题目背景

搬运自 <http://czoj.com.cn/p/675>。数据为民间数据。

## 题目描述

小 Y 给了小 X 一个长度为 $n$ 的只包含大写字母 $\tt{A,B,C}$ 的字符串。你可以对这个字符串进行如下操作：将子串 $\tt{ABC}$ 变成 $\tt{BCA}$。 小 X 想知道这个字符串最多能进行多少次操作。 一个字符串的子串是把这个字符串通过删去头部和尾部若干个字符形成的字符串。例如：$\tt{A,B,BB,AB,ABB}$ 是 $\tt{ABB}$ 的子串，$\tt{ABA}$ 不是 $\tt{ABBA}$ 的子串。

## 说明/提示

对于全部测试点：$1\le n \le 2\times10^5$。

## 样例 #1

### 输入

```
ABCABC```

### 输出

```
3```

## 样例 #2

### 输入

```
ABCACCBABCBCAABCB```

### 输出

```
6```

# 题解

## 作者：lizeyuhello (赞：3)

赛时脑子抽了，只写了暴力。

# 题解
我们首先考虑，如果把一个 $\texttt{ABC}$ 变成 $\texttt{BCA}$，会对答案产生什么新的贡献。

我们可以考虑将一个字符串分成三个部分：$\texttt{A}$，$\texttt{BC}$，和其他部分。当你将 $\texttt{ABC}$ 中的 $\texttt{BC}$ 换到A前面时，这个 $\texttt{BC}$ 可能会和前面的 $\texttt{A}$ 结合再次贡献答案。而被换到后面的 $\texttt{A}$ 也可能和后面的 $\texttt{BC}$ 结合，贡献一次答案。

每次找到一个 $\texttt{ABC}$，统计它前面连续的 $\texttt{A}$ 的数量，和后面连续的 $\texttt{BC}$，两个数量相乘得的数量计入答案。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
long long cnt, ans;

int main()
{
	cin >> s;
	int n = s.size(), pos = 0;
	while ((pos = s.find("BC",  pos)) != -1)
        s.replace(pos, 2, "X"), ++pos; //把所有 BC 替换为 X，方便之后的计算
	for (int i = 0; i < n; ++i)
	{
		if (s[i] == 'A') //累计 BC 前面 A 的数量
			++cnt;
		else if (s[i] == 'X')
			ans += cnt;
		else //当 s[i] 是其它部分时
			cnt = 0;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：1)

本题相当于求由不能配对的 ```B``` 和 ```C``` 分开的只含 ```A``` 和成对 ```BC``` 的串中 ```ABC``` 子序列的个数，因为所有 ```A``` 都需要尽可能移到最后面。用子序列统计的算法即可。这里使用了 Python 的字符串技巧方便处理。
```python
a=b=0
for i in input().replace('BC','D'):
    if'A'==i:a+=1
    elif'D'==i:b+=a
    else:a=0
print(b)
```

---


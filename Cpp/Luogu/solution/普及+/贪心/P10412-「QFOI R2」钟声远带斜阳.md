# 「QFOI R2」钟声远带斜阳

## 题目描述

**注意：本题中的所有数列下标从 $0$ 开始。**

小 R 是一个可爱的女孩子，她喜欢研究无穷数列。

她称一个无穷数列 $b$ 是美妙的，当且仅当存在自然数 $k_0$，使得对于所有 $k\ge k_0$，都满足 $b$ 中下标在区间 $[k_0,k]$ 内的所有数的和非负（即 $\sum_{i=k_0}^kb_i\ge 0$）。例如，数列 $\alpha_i=i-5$ 是美妙的，取 $k_0=5$ 符合要求；但 $\beta_i=-i$ 不是美妙的。

她目前只有一个长度为 $n$ 的有穷数列 $a$，可以进行任意次以下三种操作：

1. 花费 $p$ 的代价，选择一个整数 $i$（$0\le i < n$），将 $a_i$ 增加一。
1. 花费 $q$ 的代价，选择一个整数 $i$（$0\le i < n$），将 $a_i$ 删除，同时更新 $n$ 为新的数列长度。**不能将数列删空。**
1. 花费 $r$ 的代价，选择两个整数 $i,j$（$0\le i < j < n$），交换 $a_i$ 与 $a_j$。

她希望在若干次操作后，用无限个有穷数列 $a$ 依次相接得到无穷数列 $b$（即 $b_i=a_{i\bmod n}$），使得 $b$ 是美妙的。请你求出最小的代价。

## 说明/提示

**样例 $1$ 解释**

花费 $p=1$ 的代价将 $a_3$ 增加一，得到数列 $b=[2,-2,3,-2,-1,2,-2,3,-2,-1,\cdots]$ 是美妙的，取 $k_0=2$ 符合要求。

可以证明不存在代价更小的方案。

---

**样例 $2$ 解释**

花费 $q=1$ 的代价将 $a_1$ 删除，得到数列 $b=[2,3,-3,-1,2,3,-3,-1,\cdots]$ 是美妙的，取 $k_0=0$ 符合要求。

可以证明不存在代价更小的方案。

---

**数据范围**

**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**

对于全部数据：$1\le n\le 10^5$，$1\le p,q,r\le 10^9$，$|a_i|\le 10^9$。

- 子任务一（$10$ 分）：$n=1$。
- 子任务二（$10$ 分）：$n\le 10$。依赖子任务一。
- 子任务三（$20$ 分）：$|a_i|\le 1$。
- 子任务四（$20$ 分）：$\sum|a_i|\le 10^5$。依赖子任务三。
- 子任务五（$40$ 分）：无特殊限制。依赖子任务一、二、三、四。

## 样例 #1

### 输入

```
5 1 2 5
2 -2 3 -3 -1```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 1 5
2 -2 3 -3 -1```

### 输出

```
1```

## 样例 #3

### 输入

```
5 1 1 1
0 1 2 3 4```

### 输出

```
0```

# 题解

## 作者：rui_er (赞：12)

考查内容：

- 【3】贪心法。
- 一维的前缀和与差分技巧。（可能算【3】递推法？）

首先试图找到**周期**数列 $b$ 美妙的充要条件。

注意到，当且仅当 $\sum a_i\ge 0$ 时，数列 $b$ 美妙。下面给出证明：

（一）先证当 $\sum a_i < 0$ 时，数列 $b$ 不美妙。

显然，对于任意自然数 $k_0$，令 $k=k_0+n-1$，则 $\sum_{i=k_0}^kb_i=\sum a_i<0$。

（二）再证当 $\sum a_i\ge 0$ 时，数列 $b$ 美妙。

设数列 $b$ 的前缀和为 $s$，特别地，$s_{-1}=0$。取 $k_0\in[0,n-1]$ 使得 $s_{k_0-1}$ 取到最小值符合题意。

任取 $k\ge k_0$，则 $\sum_{i=k_0}^kb_i=s_k-s_{k_0-1}=s_{k\bmod n}+\lfloor\frac{k}{n}\rfloor\sum a_i-s_{k_0-1}\ge s_{k\bmod n}-s_{k_0-1}\ge 0$。

综上，当且仅当 $\sum a_i\ge 0$ 时，数列 $b$ 美妙。$\square$

至此，问题转化为最少花费多少代价，使得 $\sum a_i\ge 0$。我们也终于发现交换两个数的操作是没有用的。当 $\sum a_i\ge 0$ 时答案显然为 $0$，以下讨论 $\sum a_i < 0$ 的情况。

将 $a_i$ 升序排序，之后依次考虑每个 $a_i$，判断使用加一操作和删除操作哪个更优，就采用更优的方法，直到 $\sum a_i\ge 0$ 为止。需要注意 $a_i$ 不能被删空。

```cpp
const ll N = 1e5 + 5;
ll n, p, q, r, a[N];
cin >> n >> p >> q >> r;
for(ll i = 1; i <= n; ++i) cin >> a[i];
sort(a + 1, a + 1 + n);
ll sum = accumulate(a + 1, a + 1 + n, 0LL);
if(sum >= 0) cout << 0 << endl;
else {
    ll ans = 0;
    for(ll i = 1; i < n; ++i) {
        if(a[i] >= 0) break;
        ll now = min(-a[i], -sum);
        ll cost = min(p * now, q);
        ans += cost;
        sum += -a[i];
        if(sum >= 0) break;
    }
    if(sum < 0) ans += p * (-sum);
    cout << ans << endl;
}
```

---

## 作者：MoonCake2011 (赞：5)

**注意：此文中下标从 $1$ 开始**。

首先，一看数据范围，再看计算方式。

就知道可能会爆 `long long`。

上 `__int128`。

第二，因为会拼接无限个 $a$ 序列，所以必须让 $a$ 序列的和非负，不然越减越小。

第三，既然都非负了，所以第三个操作就没用了。

设 $a$ 向后拼接一个 $a$ 数列的数列叫 $c$。

证第三个只用证 $c$ 的和非负时，一定存在存在自然数 $1\le k_0 \le n$，使得对于所有 $k_0\le k \le 2\times n$，都满足 $c$ 中下标在区间 $[k_0,k]$ 内的所有数的和非负。

其实 $k_0$ 就是满足 $c$ 中 $\sum_{i=1}^{k_0-1} c_i$ 最小的数。

因为 $\sum_{i=1}^n c_i \ge 0$，所以当 $k_0 > n$ 时，答案没有 $k_0-n$ 优，所以可以取到使 $1\le k_0\le n$ 满足的 $k_0$。

对于每个 $k$，$\sum_{i=k_0}^k c_i=\sum_{i=1}^k c_i-\sum_{i=1}^{k_0-1} c_i$。

又因为 $\sum_{i=1}^{k_0-1} c_i \le \sum_{i=1}^k c_i$，这是因为 $\sum_{i=1}^{k_0-1} c_i$ 最小。

所以 $\sum_{i=1}^k c_i-\sum_{i=1}^{k_0-1} c_i \ge 0$。

故成立。

那么现在只考虑前两个操作。

现在我们是对整体进行考虑，那么顺序就没用喽。

从小到大排个序。

因为你删数一定先删较小数。

这样更能让序列加的数更多，序列和更容易非负。

排序后，枚举需要做几次 $2$ 操作。

根据上面的讨论。

做 $i$ 次 $2$ 操作一定是做的 $1,2,\dots,i$ 的数。

剩余的用前缀和计算是否非负。

**注意：你可以做 $0$ 次 $2$ 操作**。

计算答案很简单吧。

就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
signed n,p,q,r;
long long a[100010];
__int128 s[100010];
inline void write(__int128 x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x<10){
		putchar(x%10+'0');
		return;
	}
	write(x/10);
	putchar((x%10)^48);
}
signed main() {
	cin>>n>>p>>q>>r;
	a[0]=-2e9;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
	int ans=(__int128)2e13*(__int128)2e13;
	for(int i=0;i<n;i++){
		if(a[i]>=0) break;
		int sum=s[n]-s[i];
		if(sum>=0) ans=min(ans,i*q);
		else ans=min(ans,i*q-sum*p);
	}
	write(ans);
	return 0;
} 
```

---

## 作者：PR_CYJ (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P10412)
# 思路
## Step 1
这道题首先要想到若要使 $b$ 数组美妙，则 $a$ 数组的和必定要大于 $0$。记 $a$ 数组的和为 $s$。
### 证明
#### 当 $s<0$ 时
对于任意的 $k_0$，取 $k=k_0+n-1$，而此时 $\sum_{i=k_0}^k b_i=\sum_{i=k_0}^k a_{i\bmod n}=s<0$，所以 $b$ 数组不美妙。
#### 当 $s\ge 0$ 时
取 $0\le k_0<n$，并使 $\sum_{i=0}^{k_0} a_i$ 最小。所以此时对于任何的 $0\le k_1<n$，都有 $\sum_{i=0}^{k_1} a_i \ge \sum_{i=0}^{k_0} a_i$。接着考虑所有的 $k\ge k_0$，那么都有 $\sum_{i=k_0}^{k} b_i=\lfloor \frac{k}{n}\rfloor \cdot s+\sum_{i=0}^{k} a_i-\sum_{i=0}^{k_0} a_i$。因为 $s\ge 0$ 且 $\sum_{i=0}^{k} a_i\ge \sum_{i=0}^{k_0} a_i$，所以 $\sum_{i=k_0}^{k} b_i \ge 0$，所以 $b$ 数组是美妙的。

**得证**
## Step 2
想清楚了上面的，本题就变成用最小的代价使 $s\ge 0$。由于交换操作无法对 $s$ 产生任何贡献，所以不考虑交换操作。也就是说，$a$ 数组的顺序没有任何影响，所以考虑将 $a$ 数组顺序排序。
## Step 3
排序后遍历每一个数，判断当前删除操作和修改操作哪个更优，当 $s\ge 0$ 时结束循环（删除操作可以看成用 $q$ 的代价将 $a_i$ 修改成 $0$）。需要注意的是，因为不能将数组删空，所以需要将 $a_{n-1}$ 做特殊处理。如果 $a_{n-1}<0$ 且之前全是删除操作，则就用修改操作。如果之前用过了修改操作，那么就仍然判断当前删除操作和修改操作哪个更优。
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
long long n,p,q,r,sum,ans,a[N];//要开 long long 
bool f=true;//判断之前有没有用过修改操作 
int main()
{
	cin>>n>>p>>q>>r;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum+=a[i];
	}
	if (sum>=0)
	{
		cout<<0<<endl;
		return 0;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<n;i++)
	{
		long long t=min(-sum,-a[i]);
		if (q<t*p)//如果删除操作更优 
		{
			ans+=q;
			sum+=t;
		}
		else//如果修改操作更优 
		{
			ans+=t*p;
			sum+=t;
			f=false;
		}
		if (sum>=0)
			break;
	}
	if (a[n]<0)//不能删空 
	{
		if (f)//如果之前都是删除操作，说明 a数组中只有啊 a[n]这一个数 
			ans+=(-a[n])*p;
		else
			ans+=min(q,(-a[n]*p));
	}
	cout<<ans<<endl;
}
```

---

## 作者：fish_love_cat (赞：3)

首先有一个结论：当数列 $a$ 的元素和非负，那么并不需要进行操作。

证明：

因为要将数列 $a$ 首尾相接形成数列 $b$，所以在 $b$ 中任取一段长度为 $n$ 的数列，其元素和必然等于数列 $a$ 的元素和。我们把这种在 $b$ 中任取的长度为 $n$ 数列称作数列 $f$。

对于数列 $a$ 中每一段，如果这一段的元素和为负，那么在数列 $a$ 的元素和非负时，抛开这一段的元素和必然为正。所以必然会有数列 $f$ 满足从前往后的 $n$ 个元素和全部非负，我们把这种特殊的数列称作数列 $l$。

可以发现数列 $l$ 的后面紧接着一个数列 $l$。因为题面中提到 $k\ge k_0$，所以每个数列 $l$ 的起始都是非负整数，因此可以得出第一个 $l$ 的起始部位往后便是符合条件的。

又因为 $k_0$ 是自然数，不妨设 $k_0$ 为第一个数列 $l$ 的起点。所以并不需要任何操作，便可以让数列变成美妙的。

---

那么问题就转化为了如何以最少的代价让数列 $a$ 的元素和非负。

首先算全用操作一的代价，然后贪心的使用操作二优化。因为操作二就相当于把某个元素置零，所以我们统计负数从小到大排序，一个一个的算贡献优化即可。

操作三没有用，对增加元素和起不到帮助。

**注意操作二不能执行 $n$ 次！不然就删光了！！！**

---

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],ans,b[100005],top;
bool cmp(int f,int c){
    return f>c;
}
signed main(){
    int n,p,q,r;
    cin>>n>>p>>q>>r;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]<0)b[++top]=abs(a[i]);//我取了个绝对值所以后面是从大到小排序
        a[i]+=a[i-1];
    }
    if(a[n]>=0){
        cout<<0;
        return 0;
    }
    sort(b+1,b+1+top,cmp);//从大到小排
    ans=abs(a[n])*p;
    if(top==n)top--;//千万注意！！
    for(int i=1;i<=top&&a[n]<0;i++){
        if(min(-a[n],b[i])*p>q)ans=ans-min(-a[n],b[i])*p+q,a[n]+=b[i];
    }
    cout<<ans;
    return 0;
}
//第一次场切绿の纪念！
```

---

## 作者：251Sec (赞：2)

$\left(\sum a\right)>0$ 显然合法，$\left(\sum a\right)<0$ 显然不合法，$\left(\sum a\right)=0$ 的时候，取最小前缀和的下一个位置作为起点，显然合法。所以合法的充要条件是 $\left(\sum a\right) \ge 0$。

那么操作三就没用，前两个操作可以简单贪心做。注意操作二不能删空序列。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
ll p, q, a[100005], s, ans;
int main() {
	scanf("%d%lld%lld%*lld", &n, &p, &q);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i), s += a[i];
	sort(a + 1, a + n + 1);
	for (int i = 1; i < n; i++) {
		if (s < 0 && q < p * min(-a[i], -s)) {
			s -= a[i];
			ans += q;
		}
	}
	if (s < 0) ans += p * -s;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Whiking (赞：1)

看图。

![](https://cdn.fzoi.top/upload/user/c20150023/24050406266621.png)

$k_0$ 将原序列分为了红蓝两个区间，然后往后复制了若干份。

根据题意，$k_0$ 到任意一个 $k(k\ge k_0)$ 要满足 $\sum^k_{i=k_0}b_i\ge0$。

我们记下一个序列对应 $k_0$ 的点为 $k_1$。

假设 $k_0$ 是一个成功的点，根据题意，$\sum^{k_1}_{i=k_0}b_i$ 是非负的。

所以到 $k_1$ 时我们任然满足题意，所以不妨把 $k_1$ 设置成新的 $k_0$。

然后发现我们可以一直这样改下去。

最后发现其实就是要蓝色区间的和红色区间的和加起来非负。

原序列也是由红区间和蓝区间组成的，所以问题变成了原序列的和非负。

我们终于把复杂的题面转化成了简单的题面：可以用一些有花费的操作来使得原序列的和非负，求最小花费。

现在这个问题就很简单了，发现交换操作根本没用，只用考虑删除操作和加操作。

记原序列的和为 $sum$。

如果 $sum$ 非负，输出 $0$。

如果 $sum$ 为负，我们考虑贪心求解。

我们先把序列排个序，因为每次删最小的数肯定是最优的。

枚举到一个数时，判断一下是删除它花费小还是把它加到 $0$ 花费小。

但是这样会有一个问题，如果 $|sum|<|a_i|$，那么我们加 $1$ 时只需要加 $|sum|$ 次，也就是只进行 $|sum|$ 次 $1$ 操作，所以我们进行 $1$ 操作时需要判断 $|a_i|$ 和 $|sum|$ 的大小。

### code

```cpp
#include <bits/stdc++.h>
#define int long long
const int N= 2e5+ 10, M= 2e5+ 10, inf= 1e9+ 10;
inline int read() {
    int x= 0, f= 1; char ch= getchar();
    for (; ! isdigit(ch); ch= getchar()) if (ch== '-') f= -1;
    for (; isdigit(ch); ch= getchar()) x= (x<< 3)+ (x<< 1)+ (ch^ 48);
    return x*= f;
}
using namespace std;
int n, p, q, r, sum, cnt;
int ans= 0;
int a[N];
signed main() {
	n= read(), p= read(), q= read(), r= read();
	for ( int i= 1; i<= n; i++) a[i]= read(), sum+= a[i];
	if (sum>= 0) puts("0"), exit(0);
	if (sum< 0) {
		sort(a+ 1, a+ n+ 1);
		int sb= abs(sum);
		for ( int i= 1; i<= n; i++) {
			if (cnt+ 1< n) {
				if (q< p* min(abs(sb), abs(a[i]))) ans+= q, cnt++, sum-= a[i];
				else ans+= p* min(abs(sb), abs(a[i])), sum-= a[i];
			} else ans+= p* min(abs(sb), abs(a[i])), sum-= a[i];
			if (sum>= 0) break ;
		}
	}
	cout<<ans;
}


```

---

## 作者：Rongawa (赞：1)

来自底层卑微 `Python` 算法探索者的第一份题解！  
[原题再现](https://www.luogu.com.cn/problem/P10412)  
题意简化：在一个有限循环节的无穷数列中，当有一个 $k_0$ 值($k\in \mathbb N$)能使得其之后的任意多项之和非负时，称其是美妙的。描述方便起见，设这个有限循环节为 $s$ , 其各项之和为 $l$ 。 

看完题容易得知当且仅当能够使 $l≥0$ 时，可组成的无穷数列才有可能是美妙的。因交换并不能改变数列的值从而改变其各项之和，第三种操作不会用到。

如果真的证不出来可以思考：即使把最大值放在数列最后，由于后面还要加上无穷多个 $l$ ，若 $l<0$ , 加到某一项仍会导致这一区间内的和为负。故交换可理解为无效操作。

转化题目：通过花费 $p$ 将数列中某一项增加 $1$ 和花费 $q$ 将某一项删除的组合来使得 $l≥0$ 。想到这里不难看出可以通过枚举删除项数的方式来计算代价，再通过求出代价最小值的方式来输出答案。(↓`language:Python`)  
```python
def cou():#凑/扣
    global s,l,n,p,q
    m=l#删除某项后的各项总和
    mine=-l*p#存最小值
    for i in range(0,n-1):#注意：不能删空
        m-=s[i]
        if m<=0:value=(i+1)*q-m*p
        else:value=(i+1)*q#m>0时不再进行+1操作
        if value<mine:mine=value
    return mine
 ```
 注意：这个函数还可以通过在m>0的第一次操作过后 `break` 来继续优化提高效率。~~赛时太急没想这么多但是也过了~~  
 完整代码(`optimized`)
 ```python
n,p,q,r=list(map(int,input().split()))
s=list(map(int,input().split()))
s=sorted(s)
l=sum(s)
def cou():
    global s,l,n,p,q
    m=l
    mine=-l*p
    for i in range(0,n-1):
        m-=s[i]
        if m<=0:
          value=(i+1)*q-m*p
        else:
          if (i+1)*q<mine:mine=(i+1)*q
          break
        if value<mine:
          mine=value
    return mine
if l>=0:print(0)#本来就非负无需操作
elif n==1:print(-l*p)#一个负整数只能进行+1操作
else:
    if s[0]<=l:print(min(-l*p,q))#一次删除操作和单独+1比较
    else:print(cou())#最后进入枚举
```
管理大大求过求过求过！
新人第一篇，如果觉得讲得还算清晰可以给个赞鼓励一下吗qwq（

---


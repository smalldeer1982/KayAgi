# 「MYOI-R3」签到

## 题目背景

Updated on 2024/5/12：新增两组 hack 数据，位于 Subtask #5 的 #31 和 #32。

Updated on 2024/5/13：由于争议过大，目前难度已降绿。暂时不考虑再次变动本题难度。

## 题目描述

这一场比赛为了选手顺利完成签到题，设置有 $n$ 个签到处，你和它们都在一条笔直的公路上，我们不妨把这条笔直的公路看作成一条数轴，你现在在数轴原点的位置上（即坐标为 $0$），第 $i$ 个签到处在坐标为 $x_i$ 的地方，你在每个时间单位内**最多**可以移动 $1$ 个单位长度。

你需要去**尽量多**的签到处签到，然后在 $m$ 个时间单位内回到数轴原点。签到的时间可以**忽略不计**，而且你可能在同一地点瞬间完成**位于同一位置的多个不同签到处**的签到。

出题人为了让各位选手们更方便、更顺利地签到，还在场上第 $p$ 个签到处放置了签到礼物。如果选手在这里**签过到**，那么回到原点的时间限制可以被**推迟到** $m+5$ 个单位时间。注：你可以在第 $m$ 个时刻后才获得礼物，但你必须在 $m+5$ 个单位时间前回到原点。

求选手**最多**可以在多少个不同的签到处签到，并在此前提下**最小化**签过到的签到处的编号的集合的字典序（如果有多解，输出任意一个方案即可）。

注：集合的字典序等价于把集合内的元素从小到大排序之后的序列的字典序。

## 说明/提示

### 样例 $\small\text{1}$ 解释


很显然，可以去所有的签到处签到，输出一个耗时不超过 $16$ 的行动方案即可。

### 样例 $\small\text{2}$ 解释

要去 $3$ 个签到处签到一共有 $3$ 种不同的选择方案：$1$ $2$ $3$、$1$ $3$ $4$、$3$ $4$ $5$，显然，第一种选择最优，选择以下四种行动方案 $1$ $2$ $3$、$2$ $1$ $3$、$3$ $1$ $2$、$3$ $2$ $1$ 皆可。

### 数据规模与约定

**本题采用捆绑测试**。

**本题采用「Special Judge」。**

|$\textbf{Subtask}$ | $\textbf{Special conditions}$ |$\textbf{Points}$ |
| :----------: | :----------: | :----------: | 
| $0$ | 是样例 | $0$ |
| $1$ | $n\leq 15$ | $10$ |
| $2$ | $n\leq 300$ | $15$ |
| $3$ | $n\leq 7\times 10^3$ | $20$ |
| $4$ | $n\leq 10^5$ | $25$ |
| $5$ | 无 | $30$ |

**请注意大量数据的输入输出对程序效率的影响。**

**保证本题的时间限制足够长。**

对于 $100\%$ 的数据，$1\leq p\leq n\leq 10^6$，$0\leq m\leq 10^{18}$，$-10^{18}\leq x_i\leq 10^{18}$。

## 样例 #1

### 输入

```
3 11 3
1 -3 4 ```

### 输出

```
3
1 2 3```

## 样例 #2

### 输入

```
5 15 3
-5 -10 0 5 10 ```

### 输出

```
3
2 1 3 ```

# 题解

## 作者：zhuweiqi (赞：13)

如果我们将签到点按其坐标从小到大排序，容易发现，对于第 $i$ 个签到点来说，设其是路径上经过的最左边的签到点，如果此路径上经过的最右边的签到点是第 $j$ 个签到点，那么在排除原第 $p$ 个签到点的奖励的干扰下，$i$ 递增时 $j$ 不减，因此考虑用双指针维护。当然也需要考虑原第 $p$ 个签到点的影响。具体操作如下：

第一步，记录原签到点在排序后对应的位置，设原第 $p$ 个签到点排序后对应为第 $st$ 个签到点。

第二步，枚举第 $i$ 个签到点（此处默认为排序后的新编号，下同）作为当前路径的最左端（可以证明这样枚举一定能找到最优解）：

如果 $i\leq st$，讨论能否在时间限制 $+5$ 的情况下到达第 $st$ 个签到点：

- 如果能，将时间限制 $+5$，跳转至第三步。

- 否则，讨论单单往返一次第 $i$ 个签到点会不会超时，会超时直接跳过本轮循环，跳转至第三步。

否则，则说明时间限制无法 $+5$。特别地，注意当 $i=st+1$ 时右指针 $j$ 需要回退，因为第 $st$ 个签到点给的奖励突然消失了。

第三步，用双指针维护出当前情况下能到达的最右边的签到点，这点也需要按 $x_i$ 和 $x_j$ 的正负分类讨论，在此不过多赘述，详见代码。

第四步，得出当前这组答案 $(i,j)$，$ans$ 及时更新，如果其是最优解之一则先记录下 $i$ 这个左指针的位置。

第五步，当 $i$ 枚举完时我们已经得到了各个最优解的左指针的位置，此时我们只需顺序枚举，找到第 $i$ 个签到点在排序后对应的位置，用双指针或者二分筛去期望度不是最大的解，具体地：

- 如果使用二分，则二分查找第一个（即左指针坐标最小的）和最后一个（即左指针坐标最大的）包含此签到点的路径，将答案区间范围缩小（可以证明，答案区间范围一定连续）当然如果没有一条路径包含此签到点，就不能缩小答案区间范围。

- 但是我们能优化成双指针，因为答案区间范围中间不可能有空隙，假设原点左边有一组答案，则路径一定包含原点到其左指针的所有签到点，右边亦是如此，中间不可能有任何一条路径都不包含的签到点。

综上，总时间复杂度为 $O(n\log n)$，但是这个 $O(n\log n)$ 的复杂度是常数小的 sort 快排贡献的，其余双指针相关操作的时间复杂度均为 $O(n)$，所以 $n\leq 10^5$ 的子任务是给第一部分没用双指针的选手准备的，如果复杂度正确通过 $n\leq 10^6$ 的子任务是绰绰有余的。

Std：（仅供参考）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
	ll n=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		n=(n<<3)+(n<<1)+(c^48);
		c=getchar();
	}
	return n*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10^48);
	return;
}
struct node{
	ll x;
	int idx;
}s[1000002];
bool cmp(node a,node b){return a.x<b.x;}
vector<int> v;
int q[1000002];
int mat[1000002];
int e[1000002];
int main(){
	int n=read();
	ll m=read();
	int p=read();
	for(int i=1;i<=n;i++) s[i].x=read(),s[i].idx=i;
	sort(s+1,s+1+n,cmp);
	for(int i=1;i<=n;i++) mat[s[i].idx]=i;
	int st=mat[p];
	int ans=0;
	int j=1;
	for(int i=1;i<=n;i++){
		int f=0;
		if(i<=st){
			if(s[st].x<=0 && (-s[i].x<<1)<=m+5) f=5;
			if(s[i].x<=0 && 0<=s[st].x && (s[st].x-s[i].x<<1)<=m+5) f=5;
			if(0<=s[i].x && (s[st].x<<1)<=m+5) f=5;
		}
		if(i==st+1) j=i;
		if(f==0 && abs(s[i].x<<1)>m) continue;
		j=max(i,j);
		while(j<=n){
			if(s[j].x<=0) j++;
			else if(s[i].x<=0 && 0<=s[j].x && (s[j].x-s[i].x<<1)<=m+f) j++;
			else if(s[i].x>=0 && (s[j].x<<1)<=m+f) j++;
			else break;
		}
		j--;
		if(j-i+1==ans) v.push_back(i);
		if(j-i+1>ans){
			v.clear();
			ans=j-i+1;
			v.push_back(i);
		}
		j++;
	}
	int cnt=0;
	for(auto it:v) q[++cnt]=it;
	int l=1,r=cnt;
	for(int i=1;i<=n;i++){
		e[i]=mat[i];
		if(e[i]<q[l] || q[r]+ans-1<e[i]) continue;
		while(l<r && q[l]+ans-1<e[i]) l++;
		while(l<r && e[i]<q[r]) r--;
		if(l==r) break;
	}
	write(ans);
	putchar('\n');
	for(int i=q[l];i<=q[l]+ans-1;i++) write(s[i].idx),putchar(' ');
	return 0;
}
```

---

## 作者：zxh923 (赞：8)

# P10445 「MYOI-R3」签到 题解

[题目传送门](https://www.luogu.com.cn/problem/P10445)

### 思路

本题的步骤比较多，主要是求答案，和方案，其中方案相对难求。

首先我们要求出答案，再去想怎么求方案。

答案可以用双指针或者二分求解，求解时对是否经过 $p$ 分类计算是否合法即可。

接下来为了求出方案，我们记录所有最优答案的左端点。

我们既然要让集合字典序最小，就要尽可能过编号小的点，所以我们从小到大扫过编号，看可能的最优解中有哪些包含这个点的，能缩小范围就缩小。

在区间左端点满足单调性（加入顺序单调递增）的情况下，可以使用双指针求解，最后会缩小到一个点，这个点满足尽可能包含编号小的点，它就是使集合字典序最小的左端点。

### 代码及注释

```cpp
#include<bits/stdc++.h> 
#define int long long
#define N 1000005
#define pii pair<int,int>
#define x first
#define y second
using namespace std;
int n,m,p,mp[N],res,cnt,q[N];
pii a[N];
vector<int>ans;//记录可能的最优答案左端点 
signed main(){
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;
		a[i].y=i;//编号记录 
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		mp[a[i].y]=i;//记录每个编号现在的位置 
	}
	int j=1;
	p=mp[p];//更新到现在的位置 
	for(int i=1;i<=n;i++){
		int add=0;
		if(i<=p){//如果有可能到达奖励点，如果i在p右边则不可能以i为左端点走到p
			if(a[p].x<=0&&-a[i].x*2<=m+5)add=5;//i离原点更远，判断i能否在时间范围内走到即可 
			if(a[p].x>=0&&a[i].x<=0&&(a[p].x-a[i].x)*2<=m+5)add=5;//两点在原点两边，时间为两者坐标差的二倍 
			if(a[i].x>=0&&a[p].x*2<=m+5)add=5;//p离原点更远，判断p即可 
		}//这里判断更远的原依据时排序后i<=p则i坐标在p坐标左边 
		if(i==p+1)j=i;//如果过了奖励点，要回退，因为可能不满足单调性 
		if(!add&&abs(a[i].x)*2>m)continue;//当add是0，证明有可能走不到，需要判断一下 
		j=max(i,j);//防止不合法的区间 
		while(j<=n){//找以i为左端点最靠右的右端点j，注意由于上面的判断，i现在一定能被走到 
			if(a[j].x<=0)j++;//i能被走到，j距原点更近，直接更新 
			else if(a[i].x<=0&&a[j].x>=0&&(a[j].x-a[i].x)*2<=m+add)j++;//判断一下两者距离如果差这么多 是否可能走到j
			else if(a[i].x>=0&&a[j].x*2<=m+add)j++;//这时j距原点更远，判断j即可 
			else break;//否则更新不了，j已经最远了 
		}//注意j多移动了1次，所以下面是j-i，也可以先减1在判断答案结束后再加1 
		if(j-i==res){//是一个可能的最优答案，记录 
			ans.push_back(i);
		}
		if(j-i>res){//出现更优的答案，更新并记录 
			ans.clear();
			res=j-i;
			ans.push_back(i);
		}
	}
	cout<<res<<'\n'; 
	int l=0,r=ans.size()-1;//开始求最优答案 
	for(int i=1;i<=n;i++){
		if(mp[i]<ans[l]||mp[i]>ans[r]+res-1)continue;//如果这个位置不被任何一个区间包含，跳过 
		while(l<r&&ans[l]+res-1<mp[i])l++;//如果l区间够不到它，证明l不是最优，更新 
		while(l<r&&ans[r]>mp[i])r--;//如果r区间够不到它，证明r不是最优，更新 
	}
	for(int i=ans[l];i<=ans[l]+res-1;i++){//l就是我们找到的最优答案编号 
		cout<<a[i].y<<' ';
	}
	return 0;
}//完结撒花！！！ 
```

---

## 作者：Moya_Rao (赞：5)

# 题目大意
你现在站在原点上，有 $n$ 个签到点，第 $i$ 个签到点的位置是 $x_i$。  
现在你要去签到，但你得在 $m$ 秒的时间内回到原点。你要去**尽可能多**的签到点签到，且你每一秒最多可以移动 $1$ 步，签到的时间可以**忽略不计**。  
不过为了让选手们的签到更加顺利，还在第 $p$ 个签到点上放了礼物。如果你去那个点**签到过**，即可把 $m$ 秒的时间限制变为 $m+5$ 秒。  
现在想知道，你**最多**可以去多少个签到点签到，而且要最小化签过到的签到处的编号的集合的字典序。并且你还要输出方案，表示**依次要去签到**的签到处的编号。  
**如果有多种方案，输出任意一种均可。**

# 思路
这个题目就是一个双指针。

我们先可以想到，把这些签到点排个序。要不然啊，可不好处理。当然排完序后要把 $p$ 换过来。

接着，我们要来求最多可以去多少个签到点签到。  
其实拿一个双指针维护一下就行了，不过这里我还是讲的详细一些吧。
> 首先我们枚举经过的点的最左边的那个点（下称做左端点）。  
> 然后我们得看看，如果以这个点位左端点啊，有可能去到有奖励的签到处，那就看去不去得了。能去当然去咯，时间多一些嘛。  
> 但如果去不到有奖励的，又走都走不到，就不看他了，直接下一个。  
> 再双指针，搞到最远的那个右端点。  
> 如果哇，他是一种可能的方案，记下左端点；  
> 如果哇，他的方案更优，就要更新了。

那么现在我们已经有了个数 $len$ 了，接下来的任务就是求方案了。  
方案很好求，也是拿个双指针鼓捣鼓捣（不过好像二分啊）。  
就是一个个枚举嘛，  
如果根本不包含他，下一个；  
如果 $l$ 不合法，一直往右移；  
如果 $r$ 不合法，一直往左移。  
这不就行了么？

最后，那个 $l$ 对应的区间就是**答案之一**，把他输出就行了。

不过哇，你听不懂我也没办法，还是看代码吧，代码可里有详细的注释呢，一定能让你理解的！
# [AC](https://www.luogu.com.cn/record/174778736) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N = 1e6+5;
struct sign_in{long long x,id;}a[N];
long long n,m,p,now[N],len,cnt,ans[N];
bool cmp(sign_in x1,sign_in x2){return x1.x<x2.x;}
int main(){
    cin>>n>>m>>p;
    for(long long i=1;i<=n;i++){
        cin>>a[i].x;
        a[i].id=i;//存下编号
    }
    sort(a+1,a+n+1,cmp);//按照位置排序
    for(long long i=1;i<=n;i++)now[a[i].id]=i;//存下他现在在哪里
    long long j=1;//右端点初值
    p=now[p];//更新 p 为当前编号（即排完序后的）
    for(long long i=1;i<=n;i++){//枚举左端点
        long long ex=0;
        if(i<=p){//如果有可能去到有奖励的签到处
            if(a[p].x<=0&&abs(a[i].x)*2<=m+5)ex=5;//i 离原点更远
            if(a[i].x<=0&&a[p].x>=0&&(a[p].x-a[i].x)*2<=m+5)ex=5;//i 和 p 分布在原点两侧
            if(a[i].x>=0&&a[p].x*2<=m+5)ex=5;//p 离原点更远
        }
        if(ex==0&&abs(a[i].x)*2>m)continue;//如果去不到有奖励的，又走都走不到，下一个
        if(i==p+1)j=i;//如果后面再没有有奖励的了，更新 j，否则会没有单调性
        j=max(j,i);//怕出现不合法区间
        while(j<=n){//双指针
            if(a[j].x<=0)j++;//如果 i 更远，且 i 是去的到的，直接更新
            else if(a[i].x<=0&&a[j].x>=0&&(a[j].x-a[i].x)*2<=m+ex)j++;//i 和 j 分别在原点两侧且去得了，更新
            else if(a[i].x>=0&&a[j].x*2<=m+ex)j++;//j 离原点更远并且过得去，更新
            else break;//没法更新了，退出
        }
        if(j-i==len)ans[++cnt]=i;//如果是一种可能的方案，记下左端点
        if(j-i>len){//如果更优
            cnt=0;//先清空
            len=j-i;//存下更优答案
            ans[++cnt]=i;//把这个左端点放进去
        }
    }
    cout<<len<<endl;//先输出个数
    long long l=1,r=cnt;//接着来求方案
    for(long long i=1;i<=n;i++){
        if(now[i]<ans[l]||now[i]>ans[r]+len-1)continue;//根本不包含他，下一个
        while(l<r&&ans[l]+len-1<now[i])l++;//如果 l 不合法，一直往右移
        while(l<r&&ans[r]>now[i])r--;//如果 r 不合法，一直往左移
    }
    for(long long i=ans[l];i-ans[l]+1<=len;i++)cout<<a[i].id<<" ";//最后输出即可
    return 0;
}
```

放心吧，这代码没问题，放心吧！

---

## 作者：Hoks (赞：5)

## 前言
Loser_Syx 踹我来打基础赛，所以我就滚来 unrated 开 D 了。

结果打了 $40$ 分钟才过一眼瞪出来的 D，甚至不是正解属实是有点牛的（中间 $30$ 分钟滚去讲题了）。

好在应该没几个人像我一样写这么逆天的做法，最后发现其实再推一步就是正解了。
## 思路分析
首先发现签到的顺序不影响答案，所以先对签到点排序。

接着我们要先知道一个结论，就是最优解答案肯定是一个连续的区间并且覆盖原点。

若答案选取的两端点为 $l,r$，覆盖的区间即为 $(x_{l-1},x_{r+1})$。

这点比较显然，因为如果不覆盖就会出现经过了一个签到点却没签到的情况，显然不优。

那么对于两端点为 $l,r$，花费的时间即为 $2\times(x_r-x_l+1)$。

显然的是因为排序后，$l$ 单减或 $r$ 单增的答案都是单调的，所以可以直接二分。

是很对但是显然的是这玩意可以双指针，因为单调了，所以枚举左端点的时候单调移动右端点即可。

接着考虑处理这题的难点，首先有一种比较暴力的想法：直接把整个区间提出来对比。

把历史最优答案的排序后编号保存下来，对于一个区间长度相同的，就暴力取出来排序 $check$。

复杂度显然是错的，会被卡成 $O(n^2\log n)$，但是感觉上很对，不针对卡根本卡不满，[场上 AC 记录](https://www.luogu.com.cn/record/158788308)，[加了 Hack 后](https://www.luogu.com.cn/record/158832018)。

其实下面那一步也不是很难。

考虑在处理出答案的时候，我们可以同时把左端点扔到一个 vector 里存起来。

接着考虑算字典序，因为更小的编号更优先贡献，所以我们可以考虑枚举每个编号的签到点。

考虑枚举到编号为 $i$ 的签到点，考虑用二分去找到包含这个区间的最大左端点区间 $[L,R]$，目前的已有的区间为 $[l,r]$，则更新后的区间为 $[\max(l,L),\min(r,R)]$。

但是并没有必要用二分，类似于上文的部分，因为连续，直接采用双指针即可。
## 代码
```cpp
#include<bits/stdc++.h>
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=1e6+10,V=1e6,INF=0x3f3f3f3f3f3f3f3f,mod=998244353;
struct node{int x,id;}a[N];
int n,m,p,xx,mx,cnt,q[N],id[N],c[N];
vector<int>b;
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s) { for(char c:s) put(c); }
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
inline bool cmp(node x,node y){return x.x<y.x;}
signed main()
{
    n=read(),m=read(),p=read();
    for(int i=1;i<=n;i++){a[i].x=read(),a[i].id=i;if(i==p) xx=a[i].x;}
    sort(a+1,a+1+n,cmp);for(int i=1;i<=n;i++) id[a[i].id]=i;
    for(int i=1;i<=n;i++)
    {
        if(a[i].x<=0)
        {
            int ans=i,t=m,l=i,r=n;
            while(l<=r)
            {
                if(abs(a[i].x-xx)+abs(a[mid].x-xx)==abs(a[i].x-a[mid].x)) t+=5;
                int tt=-2*a[i].x;if(a[mid].x>0) tt+=2*a[mid].x;
                if(tt<=t) ans=mid,l=mid+1;else r=mid-1;t=m;
            }
            if(ans-i+1>mx) mx=ans-i+1,b.clear(),b.emplace_back(i);
            if(ans-i+1==mx) b.emplace_back(i);
        }
        else
        {
            int ans=i,t=m,l=1,r=i;
            while(l<=r)
            {
                if(abs(a[i].x-xx)+abs(a[mid].x-xx)==abs(a[i].x-a[mid].x)) t+=5;
                int tt=2*a[i].x;if(a[mid].x<0) tt-=2*a[mid].x;
                if(tt<=t) ans=mid,r=mid-1;else l=mid+1;t=m;
            }swap(i,ans);
            if(ans-i+1>mx) mx=ans-i+1,b.clear(),b.emplace_back(i);
            if(ans-i+1==mx) b.emplace_back(i);swap(i,ans);
        }
    }print(mx);put('\n');for(auto v:b) q[++cnt]=v;int l=1,r=cnt;
    for(int i=1;i<=n;i++)
    {
        c[i]=id[i];
        if(c[i]<q[l]||q[r]+mx-1<c[i]) continue;
        while(l<r&&q[l]+mx-1<c[i]) l++;
        while(l<r&&c[i]<q[r]) r--;
        if(l==r) break;
    }
    for(int i=q[l];i<=q[l]+mx-1;i++) print(a[i].id),put(' ');
    genshin:;flush();return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：1)

先考虑没有特殊点，考虑先求出最大值，这个容易，枚举 $0$ 往左的最左点，双指针即可扫出对应的区间。

再考虑构造方案，字典序按位贪心，考虑一个点强制被选后是否存在最大值方案，观察到前面求答案时得到的合法构造的区间长度必然相同，那么可能的方案是这些区间按左端点排序后的序列的一段连续的区间，可以维护这个区间，每次暴力缩这个区间，可以做到均摊 $O(1)$。注意要在显然不存在方案时及时剪枝，否则复杂度没有保证。

有特殊点就强制选一下特殊点即可。注意题目的方案是按依次行走的顺序输出的。

代码写得不大好看。

```cpp
const LL inf=11e17;
void Solve() {
  int n,p;
  LL m;
  cin>>n>>m>>p,--p;
  ve<pair<LL,int>>a(n);
  for(int i=0;i<n;++i) {
    LL x; cin>>x;
    a[i]={x,i};
  }
  a.pb(inf,n++),a.pb(-inf,n++),sort(all(a));
  ve<int>pos(n);
  for(int i=0;i<n;++i) pos[a[i].y]=i;
  int mid=[&] {
    for(int i=0;i<n;++i) if(a[i].x>=0) return i;
    return -1;
  } ();
  auto[res1,ans1]=[&] {
    int res=0;
    ve<pii>can;
    for(int L=0,R=mid;L<=mid;++L) { // [L,R)
      for(;R<n&&(max(-a[L].x,0ll)+a[R].x)*2<=m;++R);
      if(L<R&&(max(-a[L].x,0ll)+max<LL>(R?a[R-1].x:0,0))*2<=m) {
        if(cx(res,R-L)) can.clear();
        if(res==R-L) can.pb(L,R);
      }
    }
    ve<int>ans;
    for(int L=0,R=Sz(can),i=0;i<n;++i) {
      int $L=L,$R=R;
      if(pos[i]<can[L].x||can[R-1].y<=pos[i]) continue;
      for(;L<Sz(can)&&can[L].y<=pos[i];++L);
      for(;R&&can[R-1].x>pos[i];--R);
      if(L<R) ans.pb(i);
      else L=$L,R=$R;
    }
    return make_pair(res,ans);
  } ();
  auto[res2,ans2]=[&]()->pair<int,ve<int>> {
    m+=5;
    int res=0;
    ve<pii>can;
    for(int L=0,R=mid;L<=mid;++L) { // [L,R)
      for(;R<n&&(max(-a[L].x,0ll)+a[R].x)*2<=m;++R);
      if((max(-a[L].x,0ll)+max<LL>(R?a[R-1].x:0,0))*2<=m&&L<=pos[p]&&pos[p]<R) {
        if(cx(res,R-L)) can.clear();
        if(res==R-L) can.pb(L,R);
      }
    }
    ve<int>ans;
    int L=0,R=Sz(can);
    for(;L<Sz(can)&&can[L].y<=pos[p];++L);
    for(;R&&can[R-1].x>pos[p];--R);
    if(L<R) ans.pb(p);
    else return{-1,{-1}};
    for(int i=0;i<n;++i) if(i!=p) {
      int $L=L,$R=R;
      if(pos[i]<can[L].x||can[R-1].y<=pos[i]) continue;
      for(;L<Sz(can)&&can[L].y<=pos[i];++L);
      for(;R&&can[R-1].x>pos[i];--R);
      if(L<R) ans.pb(i);
      else L=$L,R=$R;
    }
    return{res,ans};
  } ();
  sort(all(ans1),[&](int x,int y){return pos[x]<pos[y];});
  sort(all(ans2),[&](int x,int y){return pos[x]<pos[y];});
  if(res1<res2||(res1==res2&&ans1>ans2)) {
    cout<<res2<<'\n';
    for(int x:ans2) cout<<x+1<<' ';
  }
  else {
    cout<<res1<<'\n';
    for(int x:ans1) cout<<x+1<<' ';
  }
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/162965269)

---

## 作者：LiaoYF (赞：1)

感觉没有蓝，如果不是因为：

> 注：你可以在第 $m$ 个时刻后才获得礼物，但你必须在 $m+5$ 个单位时间前回到原点。

1h 就会了。

## 做法

把所有点分成坐标是正数和负数的两半，最优走法一定是先去其中一半，再去另一半，最后回到原点，否则会绕路。为了实现方便，如果 $p$ 在左边，就将左右两边交换，保证 $p$ 在右边。将坐标按照绝对值排序。

枚举去了多少个右边的点，计算出回到原点后，剩下的时间还足够去多少个左边的点，使用二分（因为左边也要回到原点，所以将坐标乘 $2$）。然后相加就可以得出最多可以去多少点。

因为题目要求字典序最小，但是直接比较字典序是 $O(n^2)$ 的，所以使用双指针（找到最优解也可以用双指针）。维护当前找到的答案最左边和最右边的点的位置，如果找到一个点数相同的解，它的右端点更靠右，所以左端点也更靠右。

设之前答案的左、右端点为 $l$、$r$，当前找到答案的左、右端点为 $l'$、$r'$。在 $\left[ l,l'-1 \right]$ 中的点被删掉了，$\left[ r+1,r' \right]$ 中的点被新加上了。比较这两个区间中点的编号的最小值，如果新加上的点的编号的最小值更小，那么字典序更小，更新答案。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#ifdef LOCAL
#include "debug.h"
#else
#define debug(...) 42
#endif
const int inf=1e18;
int n,m,p;
struct node{
    int id,x;
    bool operator<(const node y)const{
        return x!=y.x?x<y.x:abs(id-p)<abs(y.id-p);
    }
};
vector<node> a,b;
void solve(){
    cin>>n>>m>>p;
    bool flag=0;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        if(i==p&&x<0){
            flag=1;
        }
        if(x>=0){
            a.push_back((node){i,x});
        }else{
            b.push_back((node){i,-x});
        }
    }
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    if(flag){
        swap(a,b);
    }
    for(int i=0;i<b.size();i++){
        b[i].x*=2;
    }
    int tmp=upper_bound(b.begin(),b.end(),(node){inf,m})-b.begin()-1;
    int ans=tmp+1,pl=tmp,pr=-1;
    int ii=pl,jj=pr;
    int minl=inf,minr=inf;
    for(int i=0;i<a.size();i++){
        if(a[i].x>m+5){
            break;
        }
        if(a[i].id==p){
            m+=5;
        }
        if(a[i].x*2>m+5){
            break;
        }
        if(a[i].x*2>m){
            continue;
        }
        int res=i+1;
        int t=m-a[i].x*2;
        int pos=upper_bound(b.begin(),b.end(),(node){inf,t})-b.begin()-1;
        res+=pos+1;
        if(res>ans){
            ans=res;
            pl=pos,pr=i;
            minl=inf,minr=inf;
            ii=pl,jj=pr;
        }else if(res==ans){
            if(pos!=pl||i!=pr){
                while(ii>pos){
                    minl=min(minl,b[ii].id);
                    ii--;
                }
                while(jj<i){
                    jj++;
                    minr=min(minr,a[jj].id);
                }
                if(minr<minl){
                    pl=pos,pr=i;
                    minl=inf,minr=inf;
                    ii=pl,jj=pr;
                }
            }
        }
    }
    cout<<ans<<"\n";
    for(int i=0;i<=pr;i++){
        cout<<a[i].id<<" ";
    }
    for(int i=0;i<=pl;i++){
        cout<<b[i].id<<" ";
    }
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t,multitest=0;
    if(multitest)cin>>t;
    else t=1;
    while(t--){
        solve();
    }
    return 0;
}
```

有一些细节，放两组数据供各位自查：

1.

In:


```
6 1 6
-3 -2 -1 0 1 2
```

Out:

```
4
4 5 6 3
```


2.

In:


```
6 1 6
-3 -2 -1 0 1 1
```

Out:

```
5
4 6 5 3 2
```

---

## 作者：Dream_0_0 (赞：0)

首先呢我们可以定义两个函数 `readInt` 和 `writeInt`，这两个函数的作用是读取和写入整数。快读快写，但快读快写没有必要，所以不做详细讲解。
接下来，我们定义了一个结构体 `Point`，它包含两个变量：$val$ 和 $index$。$val$ 表示签到处的位置，$index$ 表示签到处的编号。我们还定义了一个比较函数 `comparePoints`，用于比较两个 `Point` 结构体的 $val$ 变量。这个函数用于 `sort` 函数按照 $val$ 的值对签到点进行排序。

（详情见完整代码）

在 `main` 函数中，首先读取了签到处的数量 $n$，时间限制 $m$ 和放置礼物的签到处的编号 $pos$。然后，读取了每个签到处的位置，并将其存储在 $points$ 数组中。接着，我们按照 $val$ 成员对 $points$ 数组进行了排序，并建立了一个映射 `mapping`，用于记录每个签到处的编号在排序后的数组中的位置。

（详情见完整代码）

接下来的代码是解题的主要部分。遍历了所有的签到处，并尝试在满足时间限制的情况下，尽可能多地签到。我们使用了一个变量 `flag` 来标记是否可以获得礼物，如果可以获得礼物，那么时间限制就可以增加 5 个单位时间。我们使用了一个变量 $j$ 来记录当前可以达到的最远的签到处的位置。我们使用了一个变量 $ans$ 来记录最多可以签到的数量。我们使用了一个数组 $result$ 来记录最多可以签到的方案。

（详情见完整代码）

最后，我们输出了最多可以签到的数量 `ans`，以及对应的签到方案。

（详情见完整代码）
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

inline long long readInt() {
    long long n = 0;
    int f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        n = (n << 3) + (n << 1) + (c ^ 48);
        c = getchar();
    }
    return n * f;
}

inline void writeInt(long long x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) writeInt(x / 10);
    putchar(x % 10 ^ 48);
    return;
}

struct Point {
    long long val;
    int index;
} points[1000002];

bool comparePoints(Point a, Point b) { return a.val < b.val; }

vector<int> result;
const long long MAX_SIZE = 1e6 + 100;
int queries[MAX_SIZE];
int mapping[MAX_SIZE];
int endpoints[MAX_SIZE];

int main() {
    int n = readInt();
    long long m = readInt();
    int pos = readInt();
    for (int i = 1; i <= n; i++) {
        points[i].val = readInt();
        points[i].index = i;
    }
    sort(points + 1, points + 1 + n, comparePoints);
    for (int i = 1; i <= n; i++) mapping[points[i].index] = i;
    
    int start = mapping[pos];
    int ans = 0;
    int j = 1;
    for (int i = 1; i <= n; i++) {
        int flag = 0;
        if (i <= start) {
            if (points[start].val <= 0 && (-points[i].val << 1) <= m + 5) flag = 5;
            if (points[i].val <= 0 && 0 <= points[start].val && ((points[start].val - points[i].val) << 1) <= m + 5) flag = 5;
            if (0 <= points[i].val && (points[start].val << 1) <= m + 5) flag = 5;
        }
        if (i == start + 1) j = i;
        if (flag == 0 && abs(points[i].val << 1) > m) continue;
        j = max(i, j);
        while (j <= n) {
            if (points[j].val <= 0) j++;
            else if (points[i].val <= 0 && 0 <= points[j].val && ((points[j].val - points[i].val) << 1) <= m + flag) j++;
            else if (points[i].val >= 0 && (points[j].val << 1) <= m + flag) j++;
            else break;
        }
        j--;
        if (j - i + 1 == ans) result.push_back(i);
        if (j - i + 1 > ans) {
            result.clear();
            ans = j - i + 1;
            result.push_back(i);
        }
        j++;
    }
    int count = 0;
    for (auto it : result) queries[++count] = it;
    int l = 1, r = count;
    for (int i = 1; i <= n; i++) {
        endpoints[i] = mapping[i];
        if (endpoints[i] < queries[l] || queries[r] + ans - 1 < endpoints[i]) continue;
        while (l < r && queries[l] + ans - 1 < endpoints[i]) l++;
        while (l < r && endpoints[i] < queries[r]) r--;
        if (l == r) break;
    }
    writeInt(ans);
    putchar('\n');
    for (int i = queries[l]; i <= queries[l] + ans - 1; i++) writeInt(points[i].index), putchar(' ');
    return 0;
}
//代码如有雷同，纯属巧合
//撒花
```
就这样，一个小萌新的题解就写完了

---


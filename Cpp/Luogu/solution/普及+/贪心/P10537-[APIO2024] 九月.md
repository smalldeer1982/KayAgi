# [APIO2024] 九月

## 题目背景

## 请勿使用 C++14(GCC9) 提交

你无需在程序开头引入库 `september.h`。

## 题目描述

杭州市的中心广场有一棵著名的古树。这棵古树可以看作一棵 $N$ 个节点的有根树，节点编号从 $0$ 到 $N - 1$，其中 $0$ 号节点是根节点。

称没有孩子的节点为叶子节点。古树每次落叶时，会选择一个当前的叶子节点删去。每一天中，古树可能会多次落叶。

有 $M$ 位志愿者（编号从 $0$ 到 $M - 1$）负责看护古树。每一位志愿者将各自按照如下方式独立记录今年的落叶的情况：

每一天，收集所有新的落叶的编号（即当天删除的节点的编号），然后将它们按任意顺序写在先前的落叶编号之后。

例如：第一天，叶子 $3$ 和 $4$ 落下，于是他们写下 $3, 4$ 或 $4, 3$。第二天，叶子 $1$ 和 $2$ 落下，于是他们继续写下 $1, 2$ 或 $2, 1$。最终的记录可能为 $(3, 4, 1, 2)$，$(4, 3, 1, 2)$，$(3, 4, 2, 1)$ 或 $(4, 3, 2, 1)$ 中的任意一个。

这个过程持续了 $K$ 天，每天都有新的叶子掉落，直到只剩根节点为止。

你在旅途过程中经过了杭州。此刻已是寒冬，仰望古树光秃秃的枝干，你不禁想起落叶纷飞的美丽景象。

你很想知道今年有几天能看见落叶，但你只能找到 $M$ 位志愿者的记录。尝试根据这些记录推断出 $K$ 可能的最大值。

### 交互方式

你只需要实现以下函数：

```cpp
int solve(int N, int M, std::vector<int> F,
            std::vector<std::vector<int>> S);
```

+   $N$：古树的节点数量。
+   $M$：志愿者的数量。
+   $F$：一个长度为 $N$ 的数组。对于 $1 \le i \le N - 1$，$F[i]$ 表示节点 $i$ 的父亲节点的编号。$F[0]$ 始终为 $-1$。
+   $S$：一个长度为 $M$ 的数组。$S$ 中的每个元素是一个长度为 $N - 1$ 的数组。$S[i][j]$ 表示志愿者 $i$ 记录的第 $j$ 个节点编号（从 $0$ 开始）。
+   该函数必须返回一个整数，表示根据如上规则的 $K$ 可能的最大值（即，最大可能的落叶天数）。
+   对于每个测试点，交互库可能调用该函数多于一次。每次调用都应该作为新的情况分别处理。

注意：由于函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。

## 说明/提示

### 样例解释

对于样例一，考虑如下调用：

```cpp
solve(3, 1, {-1, 0, 0}, {{1, 2}});
```

对应的树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/i2lup6cf.png)

叶子 $1$ 和 $2$ 可能在同一天落下，或者叶子 $1$ 在第一天先落下，然后叶子 $2$ 在第二天落下。落叶天数不超过 $2$。

因此，程序应当返回 $2$。

对于样例二，考虑如下调用：

```cpp
solve(5, 2, {-1, 0, 0, 1, 1}, {{1, 2, 3, 4}, {4, 1, 2, 3}});
```

对应的树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/l50142xn.png)

假设至少有 $2$ 天落叶，根据志愿者的记录，叶子 $4$ 将在不同的日子（第一天和最后一天）落下，这是矛盾的。

因此，程序应当返回 $1$。

### 数据范围

+   $2 \le N \le 10^5$
+   $1 \le M \le 5$
+   $\sum NM \le 8 \times 10^5$
+   $F[0] = -1$ 且对于 $1 \le i \le N - 1$, $0 \le F[i] \le i - 1$
+   对于 $1 \le i \le M - 1$, 数组 $S[i]$ 是一个 $1, 2, \ldots , N - 1$ 的排列
+   保证 $F$ 描述的是一棵以节点 $0$ 为根的有根树

详细子任务附加限制及分值如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :---: | :---: | :---: |
| 1 | $M=1,N\le 10,\sum N\le 30$ | $11$ |
| 2 | $N\le 10,\sum N\le 30$ | $14$ |
| 3 | $M=1,N\le 1\,000,\sum N\le 2\,000,F[i]=i-1$ | $5$ |
| 4 | $M=1,N\le 1\,000,\sum N\le 2\,000$ | $9$ |
| 5 | $N\le 1\,000,\sum N\le 2\,000,F[i]=i-1$ | $5$ |
| 6 | $N\le 1\,000,\sum N\le 2\,000$ | $11$ |
| 7 | $M=1,F[i]=i-1$ | $9$ |
| 8 | $M=1$ | $11$ |
| 9 | $F[i]=i-1$ | $9$ |
| 10 | 没有额外的约束条件 | $16$ |

## 样例 #1

### 输入

```
1
3 1
0 0
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
1
5 2
0 0 1 1 
1 2 3 4
4 1 2 3```

### 输出

```
1```

# 题解

## 作者：rhn7 (赞：21)

APIO 第一题居然这么简单，感觉大佬们的题解都做复杂了。

由于要求划分的区间数尽可能多，每次划分的位置要尽可能靠前，现在的目标就是 $O(1)$ 判断新划分的区间是否合法。

将区间 $[l,r]$ 是否合法转化为区间 $[1,r]$ 是否合法，因为之前划分完的区间 $[1,l-1]$ 肯定合法。那怎么判断区间 $[1,r]$ 是否合法呢？我们发现每个志愿者的区间 $[1,r]$ 在不考虑顺序的情况下要相等，这个可以用桶判断。而且题目说了只有叶子节点才能掉落，所以要存在一个顺序让每个点掉落时是叶子节点，我们可以维护每个节点的子节点数，某个时候他的子节点数为零，就说明他能掉落。

实现细节看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int h[N],son[N];
int solve(int N,int M,std::vector<int> F,std::vector<std::vector<int>> S){
	for(int i=1;i<N;i++) h[i]=son[i]=0,son[F[i]]++;//多测清空 
	int k=0,cnt=0,cnt2=0;//cnt:出现的节点个数 cnt2: 出现的叶子节点个数
	for(int i=0;i<N-1;i++){
		for(int j=0;j<M;j++){
			int x=S[j][i];
			if(!h[x]){
				cnt++;h[x]=1;son[F[x]]--;
				cnt2+=!son[F[x]]&&h[F[x]];//父亲能掉落了，但是后面不会再访问父亲，所以得在儿子时加cnt2 
				cnt2+=!son[S[j][i]];
			}
		}
		k+=(cnt==i+1&&cnt2==i+1);
	}
	return k;
}
```

---

## 作者：elbissoPtImaerD (赞：10)

好像没有并查集做法，那高铁选手来搞笑一下。

先考虑 $m=1$，记 $subT(u)$ 表示 $u$ 在树上的子树集合，那么若 $\exist i < j, s_j \in subT(s_i)$，则区间 $[i,j]$ 必然是同一天记录的。如果令 $p$ 为 $s$ 的逆（即 $\forall i, s_{p_i}=i$），则 $\forall u,[p_u,\max\limits_{x\in subT(u)}p_x]$ 必然在同一天内。我们将同一天的缩起来，则答案就是连通块个数。使用并查集维护区间覆盖即可。

再考虑 $m>1$，先对每个序列做一遍 $m=1$，然后考虑两个序列之间的约束，令 $p_i$ 为 $s_i$ 的逆（即 $\forall j,s_{i,p_{i,j}}=j$），那么有 $\forall i,j$，$ [p_{i,j},p_{i+1,j}]$ 在同一天，仍使用并查集维护之，总复杂度 $O(nm\alpha(n))$。

值得一提的是，场上偷懒写了暴力覆盖，然而直接过了。

```cpp
struct DSU
{
  ve<int>f;
  DSU(int n){f.assign(n,0),iota(all(f),0);}
  int F(int x){return f[x]^x?f[x]=F(f[x]):x;}
  il bool _M(int u,int v)
  {
    if(F(u)^F(v)) return f[u]=v,true;
    return false;
  }
};
int solve(int n,int m,ve<int>fa,ve<ve<int>>a)
{
  DSU S(n);
  ve<ve<int>>G(n);
  for(int i=1;i<n;++i) G[fa[i]].pb(i);
  int ans=n-1;
  auto cover=[&](int l,int r)
  {
    for(int i=l;i<r;++i) ans-=S._M(i,i+1);
  };
  ve<int>p(n),mx(n),q;
  function<void(int)>dfs=[&](int u)
  {
    mx[u]=p[u];
    for(int v:G[u]) dfs(v),cx(mx[u],mx[v]);
    if(u&&mx[u]>p[u]) cover(p[u],mx[u]);
  };
  for(int j=0;j<m;++j,q=p) {
    for(int i=0;i<n-1;++i) p[a[j][i]]=i;
    dfs(0);
    if(j) for(int i=1;i<n;++i) cover(min(p[i],q[i]),max(p[i],q[i]));
  }
  return ans;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/160477650)

---

## 作者：迟暮天复明 (赞：6)

赛后看了一眼，然后立刻切了！

首先显然 $[l,r]$ 这个区间成立就相当于 $[1,r]$ 区间成立。

考虑一个区间成立的条件：首先每个志愿者在这些天记录的落叶集合一定都是一致的；同时删除这些点之后得到的仍然是一棵树。

对于前者，只需要记录每个点被记录过的次数，维护次数不为 $0$ 也不为 $M$ 的点数即可。

对于后者，只需要在一个非叶子节点被删除的时候打上标记，在任一个节点被删除时判断其父节点是否被打上标记以及该点是否已没有子节点，如果都满足的话撤销其标记即可。

区间 $[1,r]$ 成立当且仅当不存在删除次数不为 $0$ 也不为 $M$ 的点，同时总标记量为 $0$。

时间复杂度 $O(nm)$。

---

## 作者：ppip (赞：6)

定义 $x_i$ 为第 $i$ 个点的扫落天数。我们要最大化 $\max x_i$。

考虑每个序列以及树形态的限制。对于一个扫落序列 $a$，有 $x_{a_i}\le x_{a_{i+1}}$ 以及 $x_{a_i}+1\ge x_{a_{i+1}}$。对于树，有 $x_i\le x_{f_i}$，其中 $f_i$ 为 $i$ 在树上的父亲。所有的限制都是 $x_a-x_b\le c$ 的形式，直接差分约束建图然后跑 01BFS 即可通过，复杂度 $O(NM)$。

```cpp
// #include "september.h"
#include <bits/stdc++.h>
using namespace std;
constexpr int N(1e5);
vector<pair<int,int>> e[N+5];
int dis[N+5];
int solve(int n, int m, std::vector<int> f, std::vector<std::vector<int>> a) {
	for (int i{0};i<n;++i) e[i].clear(),dis[i]=1e9;
	for (int i{1};i<f.size();++i) e[f[i]].emplace_back(i,0);
	for (auto &v:a)
		for (int i{0};i<v.size()-1;++i) {
			e[v[i+1]].emplace_back(v[i],0);
			e[v[i]].emplace_back(v[i+1],1);
		}
	deque<int> q;
	q.push_back(a[0][0]);
	dis[a[0][0]]=1;
	while (q.size()) {
		int u{q.front()};q.pop_front();
		for (auto [v,w]:e[u])
			if (dis[v]>dis[u]+w) {
				dis[v]=dis[u]+w;
				if (w) q.push_back(v);
				else q.push_front(v);
			}
	}
	return *max_element(dis+1,dis+n);
}
```

---

## 作者：hcng (赞：4)

# [P10537 [APIO2024] 九月](https://www.luogu.com.cn/problem/P10537)
## 题意简述
给定一颗有 $n$ 个节点的有根树，每次落叶会删除一个叶子，在 $k$ 天内把叶子落剩根。每天有 $m$ 个观察者会记录当天掉落的叶子，并把这些叶子的编号以任意顺序放在今天前落的叶子之后。给定这 $m$ 个人记录的序列。求 $k$ 的最小值。

## 分析
以下以 $u$ 代表第 $u$ 个节点落下的日子。

思考这些给定条件的意义。

在一颗树上，设 $u$ 为 $v$ 的父亲，则有 $v \leq u$。

在第 $i$ 个观察者的序列上，显然有 $s[i][j] \leq s[i][j+1]$。

所以我们从题意导出了节点落下时间的非严格偏序关系。考虑建出他们的关系图。设 $u$ 到 $v$ 有边表示 $v \leq u$。

如果关系图中两节点 $u$ 和 $v$ 在同一个强连通分量中，则 $u \leq v$ 且 $v \leq u$，根据反对称性，必定有 $u = v$。

所以最小的 $k$ 就是关系图中强连通分量的数量，建图后跑一遍 tarjan 即可。注意建图时不要连关于第 $0$ 个节点的边，因为它不会落下，无需考虑。

时间复杂度 $O(NM)$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int head[100010], nxt[1000010], to[1000010], tot;
int dfn[100010], low[100010], st[100010], ins[100010], cnt, dfst, top;

inline void add_edge(int u, int v) {
    tot++; to[tot] = v, nxt[tot] = head[u]; head[u] = tot;
}

void dfs(int u) {
    low[u] = dfn[u] = ++dfst;
    st[++top] = u, ins[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (!dfn[v]) {
            dfs(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        int v; cnt++;
        do {
            v = st[top--];
            ins[v] = 0;
        } while (v != u);
    }
}

int solve(int n, int m, vector<int> f, vector<vector<int>> s) {
    tot = cnt = dfst = 0;
    for (int i = 0; i < n; i++) head[i] = dfn[i] = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n - 1; j++) {
            if (j > 0) add_edge(s[i][j], s[i][j - 1]);
        }
    }
    for (int i = 0; i < n; i++) {
        add_edge(f[i], i);
    }
    for (int i = 1; i < n; i++) {
        if (!dfn[i]) dfs(i);
    }
    return cnt;
}
```

---

## 作者：FFTotoro (赞：4)

场外选手来凑热闹。

先考虑 $M=1$ 怎么做。从左往右扫描记录序列并进行删叶子的操作，注意如果当前操作到一个结点但是它的子树还没有删空，那么就先不对其进行操作并对其进行标记；如果它的子树已经删空了就代表可以对其进行操作，操作后从它开始不断往父亲跳，如果到了某个祖先后，该祖先被标记且其子树内没有标记，那么就去掉该祖先的标记；否则结束跳父亲的过程。以上所有操作结束后如果树里面没有被标记的结点，那么就代表可以结束一天（即结束了该操作后正好有若干个完整的一天过去），答案加一即可。

如果 $M>1$ 即有多个志愿者，对于每个志愿者维护上面的过程；一个操作结束后，可以得出“所有志愿者对应的树内都没有被标记的结点”是“可以结束一天”的必要**不充分**条件。为什么不充分？因为对于每个志愿者，对于某一天他们记录下来的树叶的集合应相同，而上面的过程没有考虑这一点；判断这个条件是否成立等价于判断对于每个志愿者这些“操作前缀”内的所有元素构成的**集合**（即不考虑顺序）是否相同；可以用 $\cos$ 和来维护这一点（出题人卡了 $\sin$ 和）。

于是签到题就做完了。时间复杂度 $O(NM\log N)$。

参考代码（GNU C++17）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-6;
int solve(int n,int m,vector<int> f,vector<vector<int> > s){
  int c=0;
  vector g(m,vector<set<int> >(n));
  // 每个志愿者的树
  vector v(m,vector<bool>(n));
  // 每个志愿者的树里面的结点是否在之前尝试删除过
  vector<set<int> > t(m);
  // 每个志愿者的树里面有标记的结点
  for(int i=0;i<m;i++)
    for(int j=1;j<n;j++)
      g[i][f[j]].emplace(j);
  vector<double> a(m);
  // 记录前缀 cos 和
  for(int i=0;i<n-1;i++){
    bool b=true;
    for(int j=0;j<m;j++){
      int x=s[j][i];
      v[j][x]=true,t[j].emplace(x),a[j]+=cos(x);
      // 打标记
      if(g[j][x].empty()){
        while(x&&v[j][x]&&g[j][x].empty())
          t[j].erase(x),g[j][f[x]].erase(x),x=f[x];
      } // 可以删除，进行跳父亲删标记
      b&=t[j].empty(); // 判断是否有被标记的点
    }
    for(int j=1;j<m&&b;j++)
      b&=fabs(a[j]-a[j-1])<eps;
      // 判断前缀构成的集合是否相等
    c+=b;
  }
  return c;
}
```

---

## 作者：船酱魔王 (赞：4)

# P10537 [APIO2024] 九月 题解

## 题意回顾

有一棵 $ n $ 个结点的有根树，在 $ k $ 天内被剥下 $ n-1 $ 片叶子，每天至少有一次落叶。有 $ m $ 个记录员，每个人会把每天的落叶以任意一种顺序记录下来，请根据树的初始结构和记录内容判断 $ k $ 的最大值。

多测，$ 2 \le n \le 10^5 $，$ 1 \le m \le 5 $，$ \sum nm \le 8 \times 10^5 $。

## 分析

**本题解约定所有编号从 $ 1 $ 开始。**

落叶与多人记录使得本题的条件略显复杂，考虑对其进行刻画。

考虑寻找『前 $ i $ 个落叶后，完整的若干天正好过去』这个命题成立的充分必要条件：

* 条件显然有记录的**自洽性**，即 $ m $ 个人前 $ i $ 条记录的结点集合**等价**。

* 然后是记录集合结点在树的结构上的**可剥离性**，也就是说可以在按照一种顺序只剥离掉这些点的情况下可以每次只剥离叶子把这些点剥离完。

接下来证明『如果前 $ j $ 个落叶满足条件，前 $ i $ 个落叶满足条件，那么单独拿出 $ j+1 \sim i $ 也可以构成完整的若干天』：

* 集合等价性显然。

* 考虑继续刻画**可剥离性**，以 $ 1 $ 为根的树 $ T $ 上 $ S $ 不可剥离当且仅当存在树 $ T $ 结点 $ u \notin S $ 使得 $ 1 $ 到 $ u $ 必须经过 $ S $ 中结点。原命题的否定是存在 $ S \in T $，且在完整的树上 $ S,T $ 均可剥离，使得在删去集合 $ S $ 的树上 $ T \setminus S $ 不可剥离，设这个导致不可剥离的结点为 $ u $，则 $ 1 $ 到 $ u $ 必须经过 $ T $ 以外的结点，则显然 $ T $ 不可剥离。则原命题（如果集合 $ S,T $ 可剥离且 $ S \in T $，那么 $ T \setminus S $ 也可剥离）得证。

因此，一个前缀是否可以在若干完整的天内落完是具有**可减性**的。如果我们找到所有这样的前缀，那么分割次数的上界就是前缀的个数，又因为**可减性**所以分割次数也可以达到这个上界。

考虑本题的实现：

* 如何判定一个前缀本身是否自洽？考虑开桶子维护每个结点的被记录总次数。维护多少个结点记录次数达到 $ m $，如果结点数量等于前缀长度即为合法。

* 如何判断一个前缀是否可被剥离？考虑对于每个人的记录，维护每个结点的入度和这个结点有没有被记录的标记，如果入度为 $ 0 $ 的结点被标记则可以删除这个点并不断上跳删掉已经被标记且入度为 $ 0 $ 的点，如果所有人记录中删除的结点数等于前缀长度即为合法。

注意多测清空，本题场上平均分约为 $ 97 $ 分，是一道较容易的签到题。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
int n, m;
int fa[N];
int rem[6][N];
int buc[N], can[N];
int ind[6][N], vis[6][N], rc[6] = {0, 0, 0, 0, 0, 0};
void upd(int id, int u) {
    if(vis[id][u] != 1 || ind[id][u] > 0) return;
    vis[id][u] = 2, rc[id]++;
    ind[id][fa[u]]--;
    if(fa[u] != 1) upd(id, fa[u]);
}
int solve(int N, int M, std::vector<int> F, std::vector<std::vector<int>> S) {
    n = N, m = M;
    for(int i = 1; i <= m; i++) {
        rc[i] = 0;
        for(int j = 1; j <= n; j++) rem[i][j] = ind[i][j] = vis[i][j] = 0;
    }
    for(int j = 1; j <= n; j++) buc[j] = can[j] = fa[j] = 0;
    for(int i = 1; i <= n; i++) fa[i] = F[i - 1] + 1;
    fa[1] = -1;
    for(int i = 1; i <= m; i++)
        for(int j = 2; j <= n; j++) ind[i][fa[j]]++;
    for(int i = 1; i <= m; i++)
        for(int j = 1; j <= n - 1; j++) rem[i][j] = S[i - 1][j - 1] + 1;
    int ec = 0;
    for(int j = 1; j <= n - 1; j++) {
        for(int i = 1; i <= m; i++) {
            buc[rem[i][j]]++;
            if(buc[rem[i][j]] == m) ec++;
        }
        if(ec == j) can[j] = 1;
    }
    int ans = 0;
    for(int j = 1; j <= n - 1; j++) {
        for(int i = 1; i <= m; i++) vis[i][rem[i][j]] = 1, upd(i, rem[i][j]);
        int ok = 0;
        for(int i = 1; i <= m; i++) {
            if(rc[i] == j) ok++;
        }
        if(can[j] && ok == m) ans++;
    }
    return ans;
}
```

---

## 作者：igAC (赞：3)

# $\text{Description}$

Fe 选手来搞笑一下。

[link](https://www.luogu.com.cn/problem/P10537)

# $\text{Solution}$

显然如果 $[1,r_1]$ 合法且 $[1,r_2]$ 合法，那么 $(r_1,r_2]$ 一定合法，那么问题就变成了如何判断一个前缀是否合法。

合法的条件有两个，一是 $m$ 个观察者给出的集合相同，二是掉叶子的顺序是合法的。

条件一可以用哈希判断，条件二可以对于每个观察者记录一下每个节点还有多少个儿子没掉完，然后随便判一下就是了。

这道题放 APIO 也是来搞笑的。

具体实现可参考代码。

# $\text{Code}$

时间复杂度 $O(nm)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read(){
	int x=0,f=1,ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-')?-1:1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
int n,m;
int solve(int nn,int mm,vector<int>F,vector<vector<int>>S){
	n=nn-1,m=mm;int ans=0;
	vector<int>fa(n+1);
	vector<vector<int>>p(m+1,vector<int>(n+1));
	vector<vector<int>>deg(m+1,vector<int>(n+1));
	for(int i=1;i<=n;++i) fa[i]=F[i];
	for(int i=1;i<=m;++i) for(int j=1;j<=n;++j) p[i][j]=S[i-1][j-1];
	for(int i=1;i<=m;++i) for(int j=1;j<=n;++j) ++deg[i][fa[j]];
	vector<pair<ll,ll>>hsh(m+1);
	vector<vector<bool>>vis(m+1,vector<bool>(n+1));
	vector<int>cnt(m+1);
	for(int j=1;j<=n;++j){
		for(int i=1;i<=m;++i) hsh[i].first+=p[i][j],hsh[i].second+=(ll)p[i][j]*p[i][j],vis[i][p[i][j]]=true;
		bool flg=true;
		pair<ll,ll>tmp=hsh[1];
		for(int i=2;i<=m;++i){
			if(hsh[i]!=tmp){
				flg=false;
				break;
			}
		}
		for(int i=1;i<=m;++i) if(deg[i][p[i][j]]) ++cnt[i];
		for(int i=1;i<=m;++i){
			--deg[i][fa[p[i][j]]];
			if(!deg[i][fa[p[i][j]]] && vis[i][fa[p[i][j]]]) --cnt[i];
		}
		for(int i=1;i<=m;++i) flg&=!cnt[i];
		if(flg) ++ans;
	}
	return ans;
}
//int main(){
//	int T=read();
//	while(T--){
//		int nn=read(),mm=read();
//		vector<int>F(nn);
//		vector<vector<int>>S(mm,vector<int>(nn-1));
//		for(int i=0;i<nn;++i) F[i]=read();
//		for(int i=0;i<mm;++i) for(int j=0;j<nn-1;++j) S[i][j]=read();
//		printf("%d\n",solve(nn,mm,F,S));
//	}
//	return 0;
//}
```

---

## 作者：封禁用户 (赞：1)

# 题解：P10537 [APIO2024] 九月

## 题意

在一个树上，在 $k$ 天内有 $n-1$ 个节点掉落，会有 $m$ 个记录者记录掉落的情况，每一天每一个人会以任意的顺序记录当天的掉落情况，求出 $k$ 的最大值。

## 思路

根据题意可以得到，判断区间 $[l,r]$ 是否合法，有两个必要的条件。

- 区间 $[l,r]$ 必须在 $m$ 个人的记录集合中相等。

```
1 2 3
1 2 4
```

以上样例就不合法。

- 区间 $[l,r]$ 删除后仍然可以构成一棵树。

第一个性质完全可以用 Hash 来判断。

第二个性质可以使用扫一圈判断每一个节点还有多少个节点未掉，最后判断一下即可。

## AC code
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n, m;
int solve(int nn, int mm, vector<int>FA, vector<vector<int>>SA) {
	//初始化 
   n = nn - 1, m = mm;
	int ans = 0;
	vector<int>f(n + 1);
	vector<vector<int>>s(m + 1, vector<int>(n + 1));
	vector<vector<int>>p(m + 1, vector<int>(n + 1));
	vector<pair<ll,ll >>has(m+1);
	vector<vector<bool>>vis(m+1,vector<bool>(n+1));
	vector<int>cnt(m+1);
    
	for (int i = 1; i <= n; ++i) f[i] = FA[i];
	for (int i=1;i<= m; ++i) for (int j=1;j<=n;++j) s[i][j]=SA[i-1][j-1];
	for(int i=1;i<=m;++i) for(int j=1;j<=n;++j) ++p[i][f[j]];
	
	for (int j = 1; j <= n; ++j) {
		//判断构成的集合相等
		for (int i = 1; i <= m; ++i) has[i].first += s[i][j], has[i].second += (ll)s[i][j] * s[i][j],vis[i][s[i][j]]=1;//Hash 
		bool flag = 1;
		pair<ll, ll>q = has[1];
		for (int i = 2; i <= m; ++i) {
			if (has[i] != q) {
				flag = 0;
				break;
			}
		}
        
		//判断是否可以构成一棵树 
		for (int i = 1; i <= m; ++i) if (p[i][s[i][j]]) ++cnt[i];
		for (int i = 1; i <= m; ++i) {
			--p[i][f[s[i][j]]];
			if (!p[i][f[s[i][j]]] && vis[i][f[s[i][j]]]) --cnt[i];
		}
        
		for (int i = 1; i <= m; ++i) flag &= !cnt[i]; 
	   if (flag) ++ans;//全部符合 
	}
	return ans;
}
```

---

## 作者：shinzanmono (赞：1)

考虑 $[l,r]$ 一段合法的条件。

要保证对于所有人 $[l,r]$ 中的值构成的集合相等，然后要让 $[1,r]$ 的所有节点在树上覆盖了一些节点的子树并。

开 SegT，暴力维护，考虑只要有一个区间出现了 $i$ 就给 $i$ 所在的位置 $+1$，然后如果这个子树是要求被覆盖的，直接给其赋值为 $m$。

然后没了。

```cpp
#include<string>
#include<vector>
const int sz=1e5+10;
int n,m,dfn[sz],dpp,size[sz];
std::basic_string<int>graph[sz];
void dfs(int u){
    dfn[u]=++dpp,size[u]=1;
    for(int v:graph[u])dfs(v),size[u]+=size[v];
}
struct ST{
    int tree[sz<<2][2],min[sz<<2];
    void clear(int p,int ln,int rn){
        tree[p][0]=tree[p][1]=0,min[p]=1;
        if(ln==rn)return;
        int mid=ln+rn>>1;
        clear(p<<1,ln,mid);
        clear(p<<1|1,mid+1,rn);
    }
    void add(int p,int ln,int rn,int pos){
        if(ln==rn){
            tree[p][0]++;
            if(tree[p][0]==tree[p][1])min[p]=1;
            return;
        }
        int mid=ln+rn>>1;
        if(pos<=mid)add(p<<1,ln,mid,pos);
        else add(p<<1|1,mid+1,rn,pos);
        min[p]=std::min(min[p<<1],min[p<<1|1]);
    }
    void assign(int p,int ln,int rn,int l,int r){
        if(tree[p][1]==m)return;
        if(ln==rn){
            tree[p][1]=m;
            if(tree[p][1]!=tree[p][0])min[p]=0;
            return;
        }
        int mid=ln+rn>>1;
        if(l<=mid)assign(p<<1,ln,mid,l,r);
        if(r>mid)assign(p<<1|1,mid+1,rn,l,r);
        tree[p][1]=std::min(tree[p<<1][1],tree[p<<1|1][1]);
        min[p]=std::min(min[p<<1],min[p<<1|1]);
    }
}st;
int solve(int N,int M,std::vector<int>F,std::vector<std::vector<int>>S){
    n=N,m=M;
    for(int i=0;i<n;i++)graph[i].clear();
    for(int i=1;i<n;i++)graph[F[i]]+=i;
    dpp=0,dfs(0);
    st.clear(1,1,n);
    int ans=0;
    for(int i=0;i<n-1;i++){
        for(int j=0;j<m;j++){
            int u=S[j][i];
            st.assign(1,1,n,dfn[u],dfn[u]+size[u]-1);
            st.add(1,1,n,dfn[u]);
        }
        if(st.min[1]==1)ans++;
    }
    return ans;
}
```

---

## 作者：sbno333 (赞：0)

考场代码懒得再写一遍了，本题全场平均得分 97.9，~~是我唯一正确也是唯一拿分的题，APIO 是办的最好的一次，希望 NOI 像这次一样成功（反正我不配参加 NOI），本题和 T2 子任务充足~~。

考虑只有一个志愿者，考虑贪心维护最少前几片叶子可以记作一天。

我们认为这片叶子可以掉下来当且仅当它没有孩子，即子树消失。

我们记录第 $i$ 片叶子摘下来需要哪些**没消失的**节点消失，给这些节点打上标记，并记录到还要消失的节点数量变量里，显然可以 dfs，每次打了标记或已经消失的子树不需要再次打这种标记，所以最后总共就打了 $O(n)$ 次这种标记。然后让当前节点消失，如果当前节点是需要消失的节点，将我们记录的变量减一。如果此时该消失的都消失完了，即没有节点需要额外消失，那么答案加一，继续。

考虑多个志愿者，无非就是要求一天内所有志愿者捡到的节点形成的集合相同，每次在原来的基础上额外判断集合，显然可以建立 $M$ 个优先队列，每次加入各个志愿者的捡到的节点，如果队列内编号最小值相同，就一起出队，并对这个节点进行处理，如果队列为空，且让一段要求的不需要节点额外消失成立，那么答案加一。

时间复杂度 $O(nm\log n)$，当然，优先队列可以优化成桶，然后记录被标记 $M$ 次的节点数量与不是 $0$ 的数量，可以做到 $O(nm)$。

---

## 作者：Exp10re (赞：0)

本题得分在我 APIO 全场得分中占比 $\frac {20} {21}$。

## 解题思路

记 $b_i$ 表示节点 $i$ 根据志愿者的记录至少要经过 $b_i$ 条记录之后才可能被删除。

记 $f_i$ 表示节点 $i$ 根据树结构至少要经过 $b_i$ 条记录之后才可能被删除。

注意到 $b_i$ 即为 $m$ 个志愿者的记录中最后一条记录的出现时间，显然可以 $O(nm)$ 维护。

而 $f_i$ 根据定义转移为 $f_i=\max(b_i,\max\limits_{j\in subtree(i)}{b_j})$，注意到可以简化为 $f_i=\max(b_i,\max\limits_{j\in son(i)}{f_j})$，$O(n)$ 转移即可。

计算答案可以参照以下思路：考虑当前记录左端点为 $L$，那么我们需要找到一个最小的右端点 $R$。逐个查询记录 $pos\geq L$，每找到一个将 $R$ 更新为 $\max(R,b_{S_{j,pos}},f_{S_{j,pos}})$，直到 $pos=R$ 停止。

统计的个数即为最大天数。

---


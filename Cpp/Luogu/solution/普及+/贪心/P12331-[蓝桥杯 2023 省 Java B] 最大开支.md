# [蓝桥杯 2023 省 Java B] 最大开支

## 题目描述

小蓝所在学校周边新开业了一家游乐园，小蓝作为班长，打算组织大家去游乐园玩。已知一共有 $N$ 个人参加这次活动，游乐园有 $M$ 个娱乐项目，每个项目都需要买门票后才可进去游玩。门票的价格并不是固定的，团购的人越多单价越便宜，当团购的人数大于某个阈值时，这些团购的人便可以免费进入项目进行游玩。这 $M$ 个娱乐项目是独立的，所以只有选择了同一个项目的人才可以参与这个项目的团购。第 $i$ 个项目的门票价格 $H_i(X)$ 与团购的人数 $X$ 的关系可以看作是一个函数：

$$H_i(X) = \max(K_i \times X + B_i, 0)$$

其中 $\max$ 表示取二者之中的最大值。当 $H_i = 0$ 时说明团购人数达到了此项目的免单阈值。

这 $N$ 个人可以根据自己的喜好选择 $M$ 个娱乐项目中的一种，或者有些人对这些娱乐项目都没有兴趣，也可以选择不去任何一个项目。每个人最多只会选择一个娱乐项目，如果多个人选择了同一个娱乐项目，那么他们都将享受对应的团购价格。小蓝想知道他至少需要准备多少钱，使得无论大家如何选择，他都有能力支付得起所有 $N$ 个人购买娱乐项目的门票钱。

## 说明/提示

### 样例说明

样例中有 $4$ 个人，$2$ 个娱乐项目，我们用一个二元组 $(a, b)$ 表示 $a$ 个人选择了第一个娱乐项目，$b$ 个人选择了第二个娱乐项目，那么就有 $4 - a - b$ 个人没有选择任何项目，方案 $(a, b)$ 对应的门票花费为 $\max(-4 \times a + 10, 0) \times a + \max(-2 \times b + 7, 0) \times b$，所有的可能如下所示：

| $a$ | $b$ | 花费 |
|:---:|:---:|:------:|
| 0 | 0 | 0    |
| 0 | 1 | 5    |
| 0 | 2 | 6    |
| 0 | 3 | 3    |
| 0 | 4 | 0    |
| 1 | 0 | 6    |
| 1 | 1 | 11   |
| 1 | 2 | 12   |
| 1 | 3 | 9    |
| 2 | 0 | 4    |
| 2 | 1 | 9    |
| 2 | 2 | 10   |
| 3 | 0 | 0    |
| 3 | 1 | 5    |
| 4 | 0 | 0    |

其中当 $a = 1, b = 2$ 时花费最大，为 $12$。此时 $1$ 个人去第一个项目，所以第一个项目的单价为 $10 - 4 = 6$，在这个项目上的花费为 $6 \times 1 = 6$；$2$ 个人去第二个项目，所以第二个项目得单价为 $7 - 2 \times 2 = 3$，在这个项目上的花费为 $2 \times 3 = 6$；还有 $1$ 个人没去任何项目，不用统计；总花费为 $12$，这是花费最大的一种方案，所以答案为 $12$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N, M \leq 10$。
- 对于 $50\%$ 的评测用例，$1 \leq N, M \leq 1000$。
- 对于 $100\%$ 的评测用例，$1 \leq N, M, B_i \leq 10^5$，$-10^5 \leq K_i < 0$。

## 样例 #1

### 输入

```
4 2
-4 10
-2 7```

### 输出

```
12```

# 题解

## 作者：_Null_Ptr (赞：3)

# 蓝桥杯2023省赛Java B组「最大开支」题解

本题的关键在于每次分配人员时，选择能使‌边际收益‌最大的项目（边际收益指的是当前项目增加一人带来的花费增量）。

#### 由题意得，对于项目 $i$，当已有 $x_i$ 人时：

- 当前总花费：$k_ix_i^{2} + b_ix_i$

- 增加一人后的总花费：$k_i\times(x_i+1)^{2} + b_i\times(x_i+1)$

- 边际收益：$[k_i\times(x_i+1)^{2} + b_i\times(x_i+1)] - (k_ix_i^{2} + b_ix_i) = k_i\times(2x_i + 1) + b_i$

故可以使用‌最大堆‌来动态维护各项目的边际收益，每次取出边际收益最大的项目进行分配，然后更新该项目的边际收益。

下面贴上代码，注意看数据范围，记得开 long long。

```cpp
#include <iostream>
#include <queue>
#define int long long 
using namespace std;
struct p {
    int k,b,x,ic;
    bool operator<(const p& other) const {return ic < other.ic; }
}; 
priority_queue<p> pq;
int n, m, k, b, anss;
main() {
    cin>>n>>m;
    for (int i=1;i<=m;i++) {
        cin >> k >> b;
        int icc = k+b;
        if (icc>0) pq.push({k, b, 0, icc});
    }
    int rm=n;
    while (rm>0&&!pq.empty()) {
        p curr = pq.top();
        pq.pop();
        anss += curr.ic;rm--;
        int new_x = curr.x + 1,newi=curr.k*(2*new_x+1)+curr.b;
        if (newi > 0) pq.push({curr.k,curr.b,new_x,newi});
    }
    
    cout<<anss<<endl;
}

```
```java
import java.util.PriorityQueue;
import java.util.Scanner;

class P implements Comparable<P> {
    long k;
    long b;
    long x;
    long ic;

    public P(long k, long b, long x, long ic) {
        this.k = k;
        this.b = b;
        this.x = x;
        this.ic = ic;
    }

    @Override
    public int compareTo(P other) {
        return Long.compare(other.ic, this.ic);
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long m = scanner.nextLong();

        PriorityQueue<P> pq = new PriorityQueue<>();
        long anss = 0;

        for (int i = 1; i <= m; i++) {
            long k = scanner.nextLong();
            long b = scanner.nextLong();
            long icc = k + b;
            if (icc > 0) {
                pq.add(new P(k, b, 0, icc));
            }
        }

        long rm = n;
        while (rm > 0 && !pq.isEmpty()) {
            P curr = pq.poll();
            anss += curr.ic;
            rm--;
            long new_x = curr.x + 1;
            long newi = curr.k * (2 * new_x + 1) + curr.b;
            if (newi > 0) {
                pq.add(new P(curr.k, curr.b, new_x, newi));
            }
        }

        System.out.println(anss);
        scanner.close();
    }
}    
```

---

## 作者：Frozen_Ladybug (赞：1)

### 题目大意

$N$ 个人参加 $M$ 个项目，求所有人自行选择项目时的最大花费。

### 分析

对于某一个项目，如果 $x$ 个人参加，价格为 $c_1=x(kx+b)$，如果 $x+1$ 个人参加，价格为 $c_2=(x+1)(k(x+1)+b)$。

二者之差为 $c_2-c_1=2kx+k+b$，对于一个人的增量。

这样很容易用一个优先队列实现，其中排序方式自定义（按 $a$ 数组的大小排序），每次取出增量 $d$，若 $d>0$ 就可以继续加入，否则继续。

排序模板：

```cpp
struct cmp{
   bool operator()(vector<int>&a,vector<int>&b){
       return a[0]>b[0]; 
   }
};
priority_queue<vector<int>,vector<vector<int>>,cmp> q;
 ```

### 代码

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int N=2e5+10;
ll get(ll x,ll k,ll b){
    return x*max(0ll,k*x+b);
}
ll add(int x,int k,int b){
    return 2ll*k*x+k+b;
}
struct Node{
    int num,k,b;
    Node(int _num,int _k,int _b){num = _num;k = _k;b = _b;}
};
struct cmp{
   bool operator()(Node& a,Node& b){
       ll cost1=get(a.num+1,a.k,a.b)-get(a.num,a.k,a.b);
       ll cost2=get(b.num+1,b.k,b.b)-get(b.num,b.k,b.b);
       return cost1<cost2;
   }
};//重载运算符，比较麻烦就不放在 Node 里面写了
priority_queue<Node,vector<Node>,cmp> q;
int main(){
    int n,m; cin>>n>>m;
    for(int i=1;i<=m;i++){
        ll k,b; cin>>k>>b;
        q.push(Node(0ll,k,b));
    }
    for(int i=1;i<=n;i++){
        Node t=q.top(); q.pop();
        int num=t.num,k=t.k,b=t.b;
        ll cost = add(num,k,b);
        if(cost<=0){
            q.push(t);
            break;
        }else{
            t.num++;
            q.push(t);
        }
    }    
    ll ans=0;
    while(!q.empty()){
        Node t=q.top(); q.pop();
        int num=t.num,k=t.k,b=t.b;
        ans+=get(num,k,b);
    }
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：W_C_B_H (赞：0)

设 $f_i(x)=H_i(x)\times x$（即第 $i$ 个项目在 $x$ 人时的总价），$g_i(x)=f_i(x+1)-f_i(x)$（即第 $i$ 个项目在 $x$ 人时, 再加一个人对总价的贡献）。

手动模拟样例可得，对于每个人，若第 $i$ 个项目此前已有 $cnt_i$ 人选择，则每次应该选择 $g_i(cnt_i)$ 最大的一个 $i$，并将答案加上 $g_i(cnt_i)$。特别地，如果所有 $g_i(cnt_i)$ 都小于等于 $0$（即 $g_i(cnt_i)$ 的最大值小于等于 $0$），说明每个项目都无法产生更大的开支，此时需跳出循环，直接输出答案。

可以使用 C++ 中的 `priority_queue` 或 Java 中的 `PriorityQueue` 维护  $g_i(cnt_i)$ 的最大值，总时间复杂度 $O((M+N)\log M)$，可以通过本题。

答案可能较大，无论是 C++ 还是 Java 用 `int` 都会炸。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long	// 不开 long long 见祖宗 
#define M 100005
struct pos
{
	int id,add;	// 第 id 个项目, 对总价的增量为 add 
	bool operator < (const pos &p) const
	{
		return add < p.add;
	}
};
int n,m,k[M],b[M],cnt[M],ans=0;
priority_queue<pos>q;	// 大根堆 
int h(int p,int x)	// 第 p 个项目在 x 人时的单价 
{
	return max(k[p]*x+b[p],0ll);
}
int f(int p,int x)	// 第 p 个项目在 x 人时的总价 
{
	return h(p,x)*x;
}
int g(int p,int x)	// 第 p 个项目在 x 人时, 再加一个人对总价的贡献 
{
	return f(p,x+1)-f(p,x);
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	
	// 输入 
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>k[i]>>b[i];
		q.push( { i, g(i,0) } );	// 预处理 
	}
	
	// 计算 
	for(int i=1;i<=n;i++)
	{
		pos p=q.top();
		if(p.add<=0)	// 已经不能达到更多开支 
		{
			break;
		}
		q.pop();
		ans+=p.add;
		cnt[p.id]++;
		q.push( { p.id, g(p.id, cnt[p.id]) } );
	}
	
	// 输出 
	cout<<ans;
	return 0;
}
```

---


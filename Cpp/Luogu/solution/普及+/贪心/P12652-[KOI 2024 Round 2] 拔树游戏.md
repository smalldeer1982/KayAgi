# [KOI 2024 Round 2] 拔树游戏

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

有一棵由编号为 $1$ 到 $N$ 的 $N$ 个节点构成的有根树。该树的根节点为 $1$ 号节点，并且第 $i$ 号节点的父节点是第 $P_i$ 号节点（$2 \le i \le N$）。此外，每个节点都有一个互不相同的整数权值，第 $i$ 号节点的权值为 $A_i$（$1 \le i \le N$）。

不含子节点的节点称为叶子节点。

我们从根节点（即 $1$ 号节点）出发，每次移动到当前节点的子节点中权值最小的一个。如此重复，直到到达某个叶子节点。这样得到的从 $1$ 号节点出发、以某个叶子节点结束的路径，记作 $S = \{S_1, S_2, \ldots, S_k\}$，我们称其为**特殊路径**。

定义**拔除操作**如下：

- 设当前树的特殊路径为 $S = \{S_1, S_2, \ldots, S_k\}$。
- 将 $S_1$ 与 $S_2$ 的权值交换。
- 将 $S_2$ 与 $S_3$ 的权值交换。
- 依此类推……
- 将 $S_{k-1}$ 与 $S_k$ 的权值交换。
- 从树中移除连接 $S_k$ 与其父节点之间的边。

换句话说，拔除操作会将特殊路径上的节点的权值依次向后传递，并将该路径最后一个叶子节点从树中删除。

例如，考虑下图中的树（图中圆圈外的数字表示节点编号，圆圈内的数字表示该节点的权值）：

![](https://cdn.luogu.com.cn/upload/image_hosting/xz4gg94c.png)

在第一棵树中，特殊路径为 $S = \{1, 3, 4\}$：从根节点 $1$ 出发，子节点中权值最小的是 $3$ 号节点，再从 $3$ 出发，选择子节点中权值最小的 $4$，$4$ 是叶子节点，结束路径。  
进行拔除操作后，依次交换权值 $A_1 \leftrightarrow A_3$，$A_3 \leftrightarrow A_4$，并删除 $4$ 与 $3$ 之间的边，得到第二棵树。

在第二棵树中，特殊路径为 $S = \{1, 2\}$：$1$ 的子节点中权值最小的是 $2$，$2$ 是叶子节点。进行拔除操作，交换 $A_1 \leftrightarrow A_2$，删除 $2$ 与 $1$ 的边，得到第三棵树。

在第三棵树中，特殊路径为 $S = \{1, 3, 5\}$。拔除操作为交换 $A_1 \leftrightarrow A_3$，$A_3 \leftrightarrow A_5$，然后删除 $5$ 与 $3$ 之间的边，得到第四棵树。

在第四棵树中，特殊路径为 $S = \{1, 3\}$。执行拔除操作后交换 $A_1 \leftrightarrow A_3$，再删除 $3$ 与 $1$ 的边，得到第五棵树。

在第五棵树中，特殊路径仅为 $S = \{1\}$。执行拔除操作后，直接删除根节点 $1$。

我们将对给定的树重复执行 $N$ 次拔除操作。请你编写一个程序，在每次拔除操作执行**之前**，输出当前 $1$ 号节点的权值。

## 说明/提示

**约束条件**

- 所有给定数值均为整数。
- $2 \le N \le 300\,000$
- $1 \le P_i < i \quad (2 \le i \le N)$
- $1 \le A_i \le N \quad (1 \le i \le N)$
- 所有 $A_i$ 两两不同。

**子任务**

1. （6 分）$N \le 3\,000$  
2. （10 分）对所有 $2 \le i \le N$，有 $A_{P_i} < A_i$  
3. （11 分）对所有 $2 \le i \le N$，有 $A_{P_i} > A_i$  
4. （23 分）度数大于等于 $3$ 的节点个数不超过 $20$  
5. （50 分）无额外限制

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
5
1 1 3 3
5 2 1 3 4```

### 输出

```
5
1
2
3
4```

# 题解

## 作者：chenxi797 (赞：3)

# P12652 [KOI 2024 Round 2] 拔树游戏 题解

## 题意

定义拔除操作：将根结点删除，空缺的位置由权值最小的子结点上移填充，以此类推直到叶子结点。

我们需要重复执行拔除操作直到树空。输出每次进行操作之前，根结点的权值。

## 思路

这种不断将小的数向上顶的过程，我们可以用堆来实现。

我们可以选择直接将选出的子结点的所有儿子都直接加入到我们的堆里，有堆就可以保证堆顶的结点权值最小。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1000005;
int n,m;
int a[N]; // 权值
vector <int> s[N]; // 每个节点的儿子节点的编号
priority_queue <pair<int,int>> ans; // 小根堆存点权，编号
signed main()
{
	int n,m;
	cin >> n;
	for (int i = 2;i <= n;i++)
	{
		int x;
		cin >> x;
		s[x].push_back(i);
	}
	for (int i = 1;i <= n;i++) cin >> a[i];
	ans.push(make_pair(-a[1],1)); // 存入最初根节点
	while (n--)
	{
		cout << -ans.top().first << endl; // 每次操作之前先输出根节点的权值
		int x = ans.top().second; // 记录下根节点的编号，之后弹出
		ans.pop();
		for (int i = 0;i < s[x].size();i++)
		{
			int v = s[x][i];
			ans.push(make_pair(-a[v],v)); // 把所有儿子节点存入小根堆
		}
	}
	return 0;
}
```

---

## 作者：Dream_poetry (赞：1)

### 思路：

一眼题能蓝？

显然每次查询我们只关注根节点周围的点的最小值。

不妨拿一个堆，来存储当前根节点周围的所有点的编号及点权。

然后考虑每次更新，都是取子节点中最小的一个，但是要是这样我们可能需要反复更新，所以有没有更加优秀的做法呢？

有的。我们可以选择直接将选出的子节点的所有儿子都直接加入到我们的堆里。

为什么这是对的？

感性理解一下，拿子节点中一个权值最小的点来代替该节点，和把所有子节点都直接链接到该点的父亲结点是等价的：因为每次必然是取最小的，再拿次小的替换，当我们把所有点都丢进去时，有堆可以保证不会先取大的数。

由此，我们能明白我们的贪心是对的，接下来就是写代码了，比较简单。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;

int a[1000005];
vector<int>son[1000005];
priority_queue<pair<int,int> >ans;

signed main(){
	cin>>n;
	for (int i=2;i<=n;i++){
		int x;
		cin>>x;
		son[x].push_back(i);
	}
	for (int i=1;i<=n;i++){
		cin>>a[i];
	}
	ans.push(make_pair(-a[1],1));
	while (n--){
		cout<<-ans.top().first<<endl;
		int x=ans.top().second;
		ans.pop();
		for (int i=0;i<son[x].size();i++){
			int v=son[x][i];
			ans.push(make_pair(-a[v],v));
		}
	}
	return 0;
}
```

---

## 作者：lilong (赞：1)

注意到点的权值是从叶子往根节点 $1$ 传递的，一个点的点权向父节点传递后，会从子节点中选一个最小的权值。由此，我们可以使用优先队列维护当前 $1$ 周围的权值。当点 $u$ 的权值最小时，把 $u$ 的所有子节点 $v$ 加入优先队列，这样能保证 $u$ 的权值能够更新为子节点权值最小值（再次被选时也能够用其它子节点继续更新）。时间复杂度 $O(n\log n)$。


```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#define N 300010
using namespace std;
int n,a[N];
vector<int> G[N];
priority_queue<int,vector<pair<int,int> >,greater<pair<int,int> > > q;
int main(){
	int u;
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>u;
		G[u].push_back(i);
	}
	for(int i=1;i<=n;i++)
		cin>>a[i];
	q.push(make_pair(a[1],1));
	while(!q.empty()){
		u=q.top().second;
		cout<<q.top().first<<'\n';
		q.pop();
		for(auto v:G[u])
			q.push(make_pair(a[v],v));
	}
	return 0;
}
```

---

## 作者：wizardMarshall (赞：0)

每次进行一次“拔除”操作之后，都是点权最小的点跳到根的位置上来，显然我们可以动态维护根的儿子节点，比如把它们丢到一个优先队列里面，然后选出最大的节点作为答案。

唯一麻烦的是每次删掉根之后，会有新的儿子出现。解决办法就是把它的所有子节点也丢到队列里，这样就能保证每次都可以随时取到目标儿子。

## Code

代码实现比较短。

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[300005];
vector <int> edge[300005];

signed main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int x;
        scanf("%d", &x);
        edge[x].push_back(i);
    }
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    priority_queue <pair <int, int> > q;
    q.push({-a[1], 1});
    while (!q.empty()) {
        pair <int, int> f = q.top();q.pop();
        printf("%d\n", -f.first);
        for (auto i : edge[f.second]) {
            q.push({-a[i], i});
        }
    }
    return 0;
}
```

---

## 作者：IC0CI (赞：0)

## 题面分析

对于一次“拔除”操作根节点取到的值一定是目前根节点所有儿子中最小的，而下一次“拔除”中根节点取到的值是目前根节点除最小儿子外的所有儿子和最小儿子的所有儿子中最小的那个。

### 关于具体实现

容易想到小根堆维护，每次取小根堆队头，再将队头节点的所有儿子加入小根堆。

需要注意的是`std::priority_queue`中的优先队列是大根堆，可以用取权值相反数或重载运算符的方式解决。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

int rd() //快读

const int N = 3e5 + 5;
int n;
int a[N],pre[N];
struct node
{
    int id,val;
    bool operator < (const node &x) const {return val > x.val; }
};

vector<int> adj[N];

signed main()
{
    n = rd();
    for(int i = 2;i <= n;i++) adj[rd()].push_back(i);
    for(int i = 1;i <= n;i++) a[i] = rd();
    priority_queue<node> q;
    q.push({1,a[1]});
    for(int i = 1;i <= n;i++)
    {
        int u = q.top().id;
        cout << q.top().val << '\n';
        q.pop();
        for(auto v : adj[u]) q.push({v,a[v]});
    }
    return 0;
}
```

---


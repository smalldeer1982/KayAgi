# 【MX-X13-T3】「KDOI-12」只有失去光明，才能逃脱黑暗。

## 题目描述

给定一个非负整数 $x$，你要经过若干次以下操作将其变成 $y$，求最小代价：

* 选择一个 $0\leq i\leq k$，花费 $a_i$ 代价将 $x$ 加或减 $2^i$。

**注意：你在操作时不需要保证 $x$ 为非负整数。**

## 说明/提示

**【样例解释】**

对于样例的第二组测试数据：经过以下两次操作即可让 $x$ 变为 $y$，且代价最小：

* 取 $i=2$，令 $x\gets x+2^2$，此时 $x=6$，总代价为 $2$；
* 取 $i=0$，令 $x\gets x-2^0$，此时 $x=5$，总代价为 $4$。

**【数据范围】**

**本题使用捆绑测试。**

| 子任务编号 | 分值 | $T\leq$ | $x,y<$ | $k\leq$ | $a_i$  |
|:--:|:--:|:--:|:--:|:--:|:--:|
| $1$ | $6$ | $10^3$ | $2^3$ | $3$ | $\leq10^9$ |
| $2$ | $15$ | $10^3$ | $2^{10}$ | $10$ | $\leq10^9$ |
| $3$ | $21$ | $2\times10^5$ | $2^{30}$ | $1$ | $\leq10^9$ |
| $4$ | $27$ | $2\times10^5$ | $2^{30}$ | $30$ | $\leq2$ |
| $5$ | $20$ | $10^4$ | $2^{30}$ | $30$ | $\leq10^9$ |
| $6$ | $11$ | $2\times10^5$ | $2^{30}$ | $30$ | $\leq10^9$ |

对于所有数据：$1\leq T\leq2\times10^5$，$0\leq x,y<2^{30}$，$1\leq k\leq 30$，$1\leq a_i\leq10^9$。

**【提示】**

请使用较快的读入方式。

## 样例 #1

### 输入

```
5
2 4 1
2 5
2 5 2
2 5 2
3 9 2
1 2 3
4 23 3
1 5 2 4
1 114 5
1 4 1 9 19 8```

### 输出

```
4
4
5
11
29```

# 题解

## 作者：Mars_Dingdang (赞：9)

## 题目大意
给定一个非负整数 $x$，你要经过若干次以下操作将其变成 $y$，求最小代价：

* 选择一个 $0\leq i\leq k$，花费 $a_i$ 代价将 $x$ 加或减 $2^i$。

$T\le 2\times 10^5, x,y,a_i\le 10^9,k\le 30$。

## 大体思路
首先，由于 $2^i=2^{i-1}+2^{i-1}$，我们可以用两个 $a_{i-1}$ 替代 $a_i$，因此一开始按 $i$ 先从小到大令 $a_i\leftarrow \min(a_i, 2a_{i-1})$。同时，为了方便起见，我们用 $2a_k, 4a_k, \cdots$ 填充 $2^{k+1},2^{k+2},\cdots$ 所对应的代价。

令 $d=|x-y|$，得到 $d$ 的二进制序列 $bit$，目标是将 $d$ 变为 $0$。考虑使用 DP，记 $f_i$ 为将 $bit$ 的第 $0\sim i$ 位均变为 $0$ 的最小代价。

对于 $bit_i=0$ 的位，可以证明我们不会主动操作之，除非是要使得较低位的 $1$ 变为 $0$，因此有 $f_i=f_{i-1}$。

对于 $bit_i=1$ 的位，
- 一种贡献方式是减去 $2^i$，有 $f_i=f_{i-1}+a_i$。
- 另一种贡献方式是减去 $2^{i+1}$ 并枚举 $j\le i$，在一个连续段 $[i,j]$ 内加上一些数。我们称这种方法为“补”。如 $(1110011)_2$，取 $i=6$ 为最高位，当 $j=3$ 时要补上 $(10000)_2$；当 $j=0$ 时要补上 $(1101)_2$。对于要补上的数，其代价就是 $1$ 位对应的 $\sum a$，因为对其进行“补”操作相当于更换截断的位置 $j$。此时便有 $f_i=\min\{f_j+\sum a\}$。

时间复杂度 $O(Tk^3)$，已经可以通过本题。预处理出区间 $[i,j]$ 对应的二进制数可以轻松实现 $O(Tk^2)$。

## 参考代码
```cpp
int T, x, y, k, bit[35];
ull a[35], f[35];
//inline ll f(int p, int x) {
//    if(p < 0) return 0;
//    int c = (x >> p) & 1;
//    if(c == 1) return a[p] + f(p - 1, x - (1 << p));
//    else {
//        ll res = f(p - 1, x);
//        if(res <= a[p]) return res;
//        else return min(res, a[p] + f(p - 1, (1 << p) - x));
//    }
//}
inline void solve() {
    read(x), read(y), read(k);
    int d = abs(x - y), K = 31;
    rep(i, 0, k) read(a[i]);
    rep(i, 1, k) chkmin(a[i], a[i - 1] << 1);
    rep(i, k + 1, K) a[i] = a[i - 1] << 1;
    int nB = 0;
    while(d) {
        int c = d & 1;
        bit[nB ++] = c;
        d >>= 1;
    }
    nB --;
    ull ans = 0;

    rep(i, 0, nB) {
        if(bit[i] == 0) f[i] = (i ? f[i - 1] : 0);
        else {
            f[i] = inf;
            rep(j, 0, i) {
                int now = 0;
                Rep(t, i, j) now = (now << 1) | bit[t];
                now = (1 << (i - j + 1)) - now;
                ull res = 0; int cnt = 0;
                while(now) {
                    if(now & 1) res += a[j + cnt];
                    cnt ++;
                    now >>= 1;
                }
                chkmin(f[i], (j ? f[j - 1] : 0) + res);
            }
            f[i] += a[i + 1];
            chkmin(f[i], f[i - 1] + a[i]);
        }
    }
    writeln(f[nB]);
}
```

## 后记
这应该是笔者时隔 $0.5$ 坤年再次写题解。这期间笔者连续两次与省队失之交臂，暂时 AFO 并获得了 CChO 金牌，在高三一年的快乐学习后也在高考中取得了较为理想的成绩。当然我的 OI 水平已经完全不行了 /kk。

---

## 作者：Ahws_rwhy (赞：6)

### 题目大意
给定两个非负整数 $x$ 和 $y$，每次操作可以选择一个 $0 \leq i \leq k$，花费 $a_i$ 的代价将 $x$ 加或减 $2^i$。求将 $x$ 变为 $y$ 的最小操作代价。

### 思路:

我么可以将问题转化为通过加减 $2^i$（$(0 \leq i \leq k$）的组合，使得差值 $d = y - x$ 被抵消，且总代价最小。

首先，由于每次操作是 $2^i$，我们可以按二进制位处理 $d$ 的每一位，并考虑进位的影响。故我们考虑动态规划。

我们定义：$dp_{i,c}$ 表示处理到第 $i$ 位时，进位为 $c$（$0$ 或 $1$）的最小代价。对于每一位 $i$，考虑当前位的值、进位的影响以及可能的操作（加或减 $2^i$），计算新的进位和代价。
因为数组 $a$ 可能存在冗余：例如，当 $a_2=5$ 而 $a_1=2$ 时，使用两次 $2^1$（代价 $2×2=4$）比一次 $2^2$（代价 $5$）更优，因此需要预处理 $a$ 数组。

预处理 $a$ 数组，使得 $a_i$ 表示使用 $2^i$ 的最优代价（可能通过组合更低位的操作获得）。
对于 $i > k$ 的情况，$a_i$ 按指数增长规律推导。

时间复杂度：$\mathcal O(T \times (k + 120))$，其中 $T$ 是测试用例数。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 1e18;
ll a[35];
ll dp[35][2];  // dp[i][c]表示处理到第i位，进位为c时的最小代价
int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        ll x, y;
        int k;
        scanf("%lld%lld%d", &x, &y, &k);
        for (int i = 0; i <= k; ++i) {
            scanf("%lld", &a[i]);
        }
        // 预处理：优化a数组，确保a[i]是最优选择
        for (int i = 1; i <= k; ++i) {
            a[i] = min(a[i], 2 * a[i - 1]);
        }
        // 处理k到30位的代价
        for (int i = k + 1; i <= 30; ++i) {
            a[i] = a[i - 1] * 2;
        }
        ll m = abs(y - x);
        if (m == 0) {
            printf("0\n");
            continue;
        }
        for (int i = 0; i <= 31; ++i) {
            dp[i][0] = dp[i][1] = INF;
        }
        dp[0][0] = 0;  // 初始状态：处理第0位，无进位，代价0
        for (int i = 0; i <= 30; ++i) {
            for (int c_in = 0; c_in < 2; ++c_in) {
                if (dp[i][c_in] == INF) continue;  // 跳过不可达状态
                int b = (m >> i) & 1;  // 目标差值m的第i位
                int s = b + c_in;      // 当前位的和（包含进位）
                // 情况1：当前位操作后产生的进位c_out1 = s / 2
                ll cost1 = abs(s) * a[i];  // 操作代价：abs(s)次2^i操作
                int c_out1 = s / 2;
                if (dp[i + 1][c_out1] > dp[i][c_in] + cost1) {
                    dp[i + 1][c_out1] = dp[i][c_in] + cost1;
                }
                // 情况2：当前位操作后产生的进位c_out2 = 1（考虑±2^(i+1)操作）
                ll t_i2 = s - 2;       // 相当于当前位操作后剩余的差值
                ll cost2 = abs(t_i2) * a[i];  // 操作代价：abs(t_i2)次2^i操作
                int c_out2 = 1;        // 假设操作后产生进位1
                if (dp[i + 1][c_out2] > dp[i][c_in] + cost2) {
                    dp[i + 1][c_out2] = dp[i][c_in] + cost2;
                }
            }
        }
        // 取处理完所有位后的最小代价（考虑进位0和进位1）
        printf("%lld\n", dp[31][0]);
    }
    return 0;
}
```

---

## 作者：qzmoot (赞：5)

# 题解：P13008 【MX-X13-T3】「KDOI-12」只有失去光明，才能逃脱黑暗。
## 题目大意
将 $x$ 变为 $y$，每次可以用 $a_i$ 代价在二进制的第 $i$ 位上加或减 $1$。询问最小代价。
## 题目分析
因为要求最小代价，且每次的操作很难贪心。便考虑动态规划。

一个简单的转化，取 $x-y$ 的绝对值，之后就相当于我们要进行一些操作来构造出这个数。

不难发现，在第 $i$ 位上加两次就相当于在 $i+1$ 上加一。则我们可以求出每一位上加一的所需的最小代价。

即 $cost_i=\min{a_i,cost_{i-1}\times 2}$。

接着，减法操作比较难操作，因为有退位的情况。既然难以操作，那么就放入我们设计的状态中。

$f_{i,1/0}$ 表示我们第 $i$ 位之前的数字已经与目标值一模一样，并且当前是否需要退位（$1$ 表示需要，$0$ 表示不需要）的最小代价是多少。

于是我们便可以对目标值第 $i$ 位上的数字讨论后进行转移。

首先对于第 $i$ 位为 $0$。我们如果没有退位的话，直接继承上 $i-1$ 位上没有退位的代价；如果有退位，那就必须要加 $1$ 或者减 $1$ 否则无法使该位变为 $0$。

那么可以写出转移方程：

$$\begin{aligned}
&f_{i,0}=\min {f_{i-1,0},f_{i-1,1}+cost_i}\\
&f_{i,1}=f_{i-1,1}+cost_i\\
\end{aligned}$$

同样的，对于第 $i$ 位为 $1$，我们可以通过上一个没退位的状态加或减第 $i$ 位的 $1$ 来实现；如果之前有退位，那我们只能不进行操作来保证第 $i$ 位是 $1$。

那么可以写出转移方程：

$$\begin{aligned}
&f_{i,0}=f_{i-1,0}+cost_i\\
&f_{i,1}=\min{f_{i-1,0},f_{i-1,1}+cost_i}\\
\end{aligned}$$

最后注意，最高位有退位的情况需要再加上最高位加 $1$ 的代价。
## Code
```cpp
#include <bits/stdc++.h>
#define int long long
#define pb emplace_back
using namespace std;
constexpr int N=35,inf=1e18;
int T;
int x,y,k;
int a[N];
int f[N][2];
vector<int>num;
signed main()
{
//	freopen("data.in","r",stdin);
//	freopen("wa.out","w",stdout);
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld%lld",&x,&y,&k);
		int tar=abs(x-y);
		num.clear();
		memset(f,0x3f,sizeof f);
		while(tar)
		{
			//cout<<tar%2;
			num.pb(tar%2),tar>>=1;
		}
		//cout<<endl;
		for(int i=0;i<=k;i++)
			scanf("%lld",&a[i]);
		if(x==y)
		{
			puts("0");
			continue;
		}
		for(int i=1;i<=k;i++)
			a[i]=min(a[i],a[i-1]*2);
		for(int i=k+1;i<=num.size();i++)
			a[i]=a[i-1]*2;
		if(num[0])
			f[0][1]=f[0][0]=a[0];
		else
			f[0][0]=0;
		for(int i=1;i<num.size();i++)
		{
			if(num[i])
			{
				f[i][0]=f[i-1][0]+a[i];
				f[i][1]=min(f[i-1][0]+a[i],f[i-1][1]);
			}
			else
			{
				f[i][0]=min(f[i-1][0],f[i-1][1]+a[i]);
				f[i][1]=f[i-1][1]+a[i];
			}
		}
		printf("%lld\n",min(f[num.size()-1][0],a[num.size()]+f[num.size()-1][1]));
	}
	return 0;
}
```

---

## 作者：y_kx_b (赞：5)

说个好写的做法，考场做法写的一坨/kk。

首先的首先，把 $x$ 变成 $y$ 等价于把 $x-y$ 变成 $0$（开考半小时才意识到这一点）；同时把 $x$ 变成 $0$ 的操作全部取反就变成了把 $-x$ 变成 $0$ 的操作。故可令 $x\gets |x-y|,y\gets0$。下面的操作均是对新的 $x$ 进行的。

首先显然对一位加或减 $2$ 次等价于对上一位加或减一次，那么直接 $a_i\gets\min(a_i,2\times a_{i-1})$，后面就不用管 $k$ 了，每位就只有 $3$ 种可能操作 $0/\!+1/\!-1$。但直接开枚的话复杂度 $\mathcal O(T\times3^m)$（$m=30$，下同），显然无法通过。

然后从低位到高位开始操作，如果当前这位为 $1$ 只能加或减，那么直接 dp，设 $dp_x$ 为把 $x$ 变成 $0$ 的最小代价那么 $dp_x=\min\{dp_{x-2^i},dp_{x+2^i}\}+a_i$，其中 $i$ 是 $x$ 的 lowbit 的位置。数组开不下就 `std::unordered_map`，小问题。那么这是写法一。

什么？复杂度？容易证明只会搜到 $\left\lfloor\dfrac x{2^i}\right\rfloor\times2^i$ 和 $\left\lceil\dfrac x{2^i}\right\rceil\times2^i$（一次进位不会超过 $2$，所以不看右 $i$ 位的话高位只会和原 $x$ 的一致或者比 $x$ 大 $1$），状态只有 $\mathcal O(m)$ 种，故时间复杂度为 $\mathcal O(Tm)$，足以通过。

写法二只是实现上不太一样，因为如果 $m$ 大点的话 $x$ 可能不能用整型表示，所以直接把 $x$ 拍扁成 0-1 序列，从低位到高位枚举，注意可能有进位和不进位，干脆就设 $dp_{i,0/1}$ 表示前 $i$ 位处理后向/不向第 $i+1$ 位进位的情况下当前花的最少代价。转移模拟（分类讨论）进位就行了，显然不可能进超过 $2$ 的位。第 $m$ 位处理完不能向第 $m+1$ 位进（因为 $a_{m+1}=2\times a_m$ 本质就是把第 $m$ 位减完），答案就是 $dp_{m,0}$。时间复杂度显然为 $\mathcal O(Tm)$。

写法一：（`std::unordered_map` 记搜，常数较大）
```cpp
#include<bits/stdc++.h>
using std::min;
const int N = 35, m = 30;
long long a[N];
std::unordered_map<int, long long> mp;
#define lowbit(x) ((x) & -(x))
long long dfs(int x) {
    // if(x < 0) return 1e18;//绝对不会减成负数。（那么照理来说题目也可以改成不能把x改到0以下？）
    if(!x) return 0;
    if(mp.count(x)) return mp[x];
    int l = lowbit(x);
    if(l == 1 << m) return mp[x] = a[m]; //第 30 位必须减，否则 1 << 31 爆 int
    return mp[x] = a[std::__lg(l)] + min(dfs(x + l), dfs(x - l));
}
int main() {
    int T; scanf("%d", &T); while(T--) {
        int x, k; scanf("%d%d", &x, &k);
        x = abs(x - k);
        scanf("%d", &k);
        for(int i = 0; i <= k; i++) {
            scanf(/*"%d"*/"%lld", a + i);
            if(i) a[i] = min(a[i], a[i - 1] << 1);
        }
        for(int i = k + 1; i <= m; i++) a[i] = a[i - 1] << 1;
        mp.clear();
        printf("%lld\n", dfs(x));
    }
}
```

写法二：（dp）
```cpp
#include<bits/stdc++.h>
using std::min;
const int N = 35, m = 30;
long long a[N], dp[N][2];//处理完 0~i 位且下一位不进位/进位 最小代价
int main() {
    int T; scanf("%d", &T); while(T--) {
        int x, k; scanf("%d%d", &x, &k);
        x = abs(x - k);
        scanf("%d", &k);
        for(int i = 0; i <= k; i++) {
            scanf(/*"%d"*/"%lld", a + i);
            if(i) a[i] = min(a[i], a[i - 1] << 1);
        }
        for(int i = k + 1; i <= m; i++) a[i] = a[i - 1] << 1;
        memset(dp, 0x3f, sizeof dp);
        if(x & 1) dp[0][0] = dp[0][1] = a[0];
        else dp[0][0] = 0;
        for(int i = 1; i <= m; i++)
            if((x >> i) & 1)
                dp[i][0] = dp[i - 1][0] + a[i],
                dp[i][1] = min(dp[i - 1][1], dp[i - 1][0] + a[i]);
            else
                dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + a[i]),
                dp[i][1] = dp[i - 1][1] + a[i];
        printf("%lld\n", dp[m][0]);
    }
}
```

撒花！

---

## 作者：篮网总冠军 (赞：3)

理解了很长时间才理解这题是问什么，还是太蒟蒻了，遂来写题解。

首先考虑到本题每个位数不一定比用前面的加优，所以先 $a_i = \min(a_i,2 \times a_{i-1})$。

然后我们可以发现，就是通过加减凑出 $\lvert x - y \rvert$。

很容易证明，每一种最多只会被用一次。因为无论是加还是减，可以保证 $a_i \le 2 \times a_{i-1}$。

然后考虑 dp。

我们假设 $dp_{i,0}$ 表示不进位，$dp_{i,1}$ 表示进位。

一定要注意思路：对于 $dp_{i,1}$ 不是要保证这一位减完！

然后就非常简单了，如果你还不会，请注意我上面加重的这句话，我思考了很久 /bx。

代码：


```cpp
#include <bits/stdc++.h>
using namespace std;

long long a[35];
long long dp[35][2];
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int t;
	cin>>t;
	while(t--){
		memset(dp,0,sizeof(dp));
		long long x,y,k;
		cin>>x>>y>>k;
		for(int i=0;i<=k;i++) cin>>a[i];
		for(int i=k+1;i<=31;i++) a[i]=a[i-1]*2;
		for(int i=1;i<=31;i++) a[i]=min(a[i],a[i-1]*2);
		long long v=abs(x-y);
		dp[0][1]=1000000000;
		for(int i=1;i<=32;i++){
			int r=(v>>(i-1))&1;
			if (r==0){
				dp[i][0]=min(dp[i-1][0],dp[i-1][1]+a[i-1]);
				dp[i][1]=min(dp[i-1][0]+2*a[i-1],dp[i-1][1]+a[i-1]);
			}
			else{
				dp[i][0]=min(dp[i-1][0]+a[i-1],dp[i-1][1]+2*a[i-1]);
				dp[i][1]=min(dp[i-1][0]+a[i-1],dp[i-1][1]);
			}
		}
		cout<<dp[32][0]<<endl;
	}
	return 0;
}

```

---

## 作者：DengStar (赞：2)

> [P13008 【MX-X13-T3】「KDOI-12」只有失去光明，才能逃脱黑暗。](https://www.luogu.com.cn/problem/P13008)

[在博客园中查看](https://www.cnblogs.com/dengstar/p/18958733)

你告诉我这是黄题？

首先容易观察到，操作两次 $2^{i - 1}$ 等价于操作一次 $2^{i}$，所以如果后者的代价（$a_{i}$）比前者的代价（$2a_{i - 1}$）大，总可以替换过来。因此一开始我们令所有 $a_{i}$ 对 $2a_{i - 1}$ 取 $\min$。

然后 $x$ 和 $y$ 的值是不重要的，我们只关心他们的差。而差的正负也是不重要的，因为我们可以翻转一个操作序列中所有操作的符号。所以问题变成了：给定 $t = |x - y|$，选出若干个 $2^{i}$（符号任意，且一个 $2^{i}$ 可以重复选），最小化价值之和。

在调整了价值之后，可以证明：存在最优操作序列，使得**每个 $2^{i}$ 至多被选择一次**。这不难理解：显然选出的 $2^{i}$ 符号一定相同（否则抵消了），如果选出多于 $1$ 个，则可以把两个 $2^{i - 1}$ 换成一个 $2^i$，这一定不劣。不过当 $t \ge 2^{k + 1}$ 时会出问题，因为我们必须要选多于 $1$ 个 $2^{k}$ 才能凑出 $t$。解决办法是简单的：直接令 $k = 30$，多出来的地方的价值用 $a_{i} = 2a_{i - 1}$ 递推补足。

接下来的做法和官方题解不太一样。

为了解决这个问题，我们使用**数位 dp**。为了方便，记 $t_{i}$ 表示 $t$ 二进制下第 $0$ 位到第 $i$ 位的值，即 $t \operatorname{and} \, (2^{i + 1}- 1)$。然后把问题改成：选出的数之和与 $t$ 的差为 $0$。记 $f_{i, j}$ 表示：处理完第 $0$ 到第 $(i - 1)$ 位，使得当前选出的数之和与 $t_{i}$ 的差为 $j \cdot 2^{i}$ 时的最小代价，其中 $j \in \{-1, 0\}$。这有什么道理呢？首先，我们选出的数之和与 $t_{i}$ 的差必须为 $2^{i}$ 的整数倍，否则，由于之后能选择的数都是 $2^{i}$ 的倍数，我们一定不能使得选出的数之和与 $t$ 之差为 $0$。另一方面，考察这个差值的上下界，容易发现 $j$ 可能的取值只有 $0$ 和 $-1$。

用 $f(i, j)$ 转移时，枚举 $2^{i}$ 的决策 $l \in \{-1, 0, 1\}$（选正数/不选/选负数），设 $x$ 为 $t$ 的二进制表示在 $2^{i}$ 的取值（$0$ 或 $1$），则选择以后总和与 $t_{i}$ 的差值为 $(j + l - x) \cdot 2^{i}$。只有系数为偶数时才能转移，易得转移方程为：
$$
f(i + 1, (j + l - x) / 2) \gets f(i, j) + |l| \cdot a^{i}
$$


初始化 $f(0, 0) = 1$，其它为 $+ \infty$。答案即为 $f(k + 1, 0)$。

代码在文章开头的链接中。

---

## 作者：swate114514 (赞：2)

我们需要找到将整数 $x$ 转换为整数 $y$ 的最小代价，每次操作可以选择加或减 $2^i$（其中 $0 \leq i \leq k$），并花费相应的代价 $a_i$。关键在于高效地计算这些操作的最优组合，使得总代价最小。

---
计算差值 $d = |y - x|$，我们的目标是通过一系列加减 $2^i$ 的操作来消除这个差值。每个操作可以处理二进制中的某一位。

---
我们可以预处理操作代价。对于每个位 $i$，计算最小代价 $\text{mn}_i$ 来表示操作 $2^i$ 的最小代价。这里使用动态规划的思想，从低位到高位传递最小代价，即 $\text{mn}_{i+1} = \min(\text{mn}_{i+1}, 2 \times \text{mn}_i)$。

如何设计状态？

使用状态 $dp_{i,c}$ 表示处理到第 $i$ 位时进位为 $c$ 的最小代价。进位 $c$ 可以是 $-1, 0, 1$，分别对应三种状态。

对于每个位 $i$ 和当前进位 $c$，计算下一个进位 $c_{\text{next}}$ 和操作 $s_i$，使得 $(c + s_i)$ 的二进制第 $i$ 位等于 $d$ 的第 $i$ 位。操作 $s_i$ 的代价为 $|s_i| \times \text{mn}[i]$。

使用滚动数组减少内存消耗，并设置阈值防止溢出。

---
### Code
```cpp
#include <bits/stdc++.h>
#define qwq(i,a,b) for(int i=(a);i<=(b);++i)
#define qaq(i,a,b) for(int i=(a);i>=(b);--i)

using namespace std;

typedef long long ll;

const ll INF = 1e18;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int T;
	cin >> T;
	while (T--) {
		ll x, y;
		int k;
		cin >> x >> y >> k;
		vector<ll> a(k + 1);
		qwq(i, 0, k) {
			cin >> a[i];
		}
		
		if (x == y) {
			cout << 0 << '\n';
			continue;
		}
		
		ll d = llabs(y - x);
		
		vector<ll> mn(61, INF);
		qwq(i, 0, k) {
			if (a[i] < mn[i]) {
				mn[i] = a[i];
			}
		}
		
		qwq(i, 0, 59) {
			if (mn[i] == INF) continue;
			ll nxt = mn[i] * 2;
			if (nxt > INF) {
				nxt = INF;
			}
			if (nxt < mn[i + 1]) {
				mn[i + 1] = nxt;
			}
		}
		
		vector<ll> dp_cur(3, INF);
		vector<ll> dp_nxt(3, INF);
		dp_cur[0] = 0;
		
		qwq(i, 0, 60) {
			int bit = (d >> i) & 1;
			fill(dp_nxt.begin(), dp_nxt.end(), INF);
			qwq(c, 0, 2) {
				if (dp_cur[c] == INF) continue;
				int cr;
				if (c == 0) cr = 0;
				else if (c == 1) cr = 1;
				else cr = -1;
				
				qwq(nc, 0, 2) {
					int ncr;
					if (nc == 0) ncr = 0;
					else if (nc == 1) ncr = 1;
					else ncr = -1;
					
					ll s = 2 * static_cast<ll>(ncr) + bit - cr;
					ll cost = 0;
					if (s != 0) {
						if (mn[i] == INF) {
							continue;
						}
						if (mn[i] > INF) {
							continue;
						}
						if (abs(s) > INF / mn[i]) {
							continue;
						}
						cost = abs(s) * mn[i];
					}
					
					if (dp_cur[c] > INF - cost) {
						continue;
					}
					ll now = dp_cur[c] + cost;
					if (now < dp_nxt[nc]) {
						dp_nxt[nc] = now;
					}
				}
			}
			dp_cur = dp_nxt;
		}
		cout << dp_cur[0] << '\n';
	}
}
```

---

## 作者：ymx2009 (赞：0)

# 题目描述
题意很清晰明了不做赘述。
# 思路分析
取 $d=|x-y|$，因为每次操作相当与在二进制的一位上加一，所以考虑将 $d$ 按二进制进行数位 DP。
# Solution
因为 $a$ 数组可能有不优，所以先对它去除不优的元素 $a_i=\min(a_{i-1}*2,a_i)$。  
用 $dp_{i,c}$ 表示已经处理完 $i$ 位，再是否向 $i+1$ 进位，具体转移见代码中。  
可以发现只须要枚举到 $d$ 的二进制位数加一即可，因为再往后不可能再产生更优解了。
# Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=40;
int a[N],dp[N][2];

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T;
	cin>>T;
	for(;T--;)
	{
		int x,y,k;
		memset(a,127,sizeof a);
		memset(dp,63,sizeof dp);
		cin>>x>>y>>k;
		int d=abs(x-y),m=0;
		for(int i=d;i;m++) i>>=1;
		for(int i=0;i<=k;i++) cin>>a[i];
		for(int i=1;i<=m;i++) a[i]=min(a[i-1]<<1,a[i]);
		if(d&1) dp[0][0]=dp[0][1]=a[0];
		else dp[0][0]=0;
		for(int i=1;i<=m;i++)
		{
			if((d>>i)&1)
			{
				dp[i][0]=dp[i-1][0]+a[i];
				dp[i][1]=min(dp[i-1][1],dp[i-1][0]+a[i]);
			}
			else
			{
				dp[i][0]=min(dp[i-1][0],dp[i-1][1]+a[i]/*将这一位减一*/);
				dp[i][1]=dp[i-1][1]+a[i];
			}
		}
		cout<<dp[m][0]<<'\n';
	}
	return 0;
}
```

---

## 作者：AK_400 (赞：0)

来个 $O(Tk^3)$ 做法，略微卡常后可通过，最慢的点约半秒，我的随机数据（$T=2\times10^5,k=30$）在洛谷 ide 上是一秒。

--------

令 $b_i$ 表示 $\mid x-y\mid$ 的二进制的第 $i$ 位。

首先，因为 $2^i=2^{i-1}+2^{i-1}$ 从小到大令 $a_i\gets \min(a_i,2a_{i-1})$。

又注意到 $2^i-2^j=\sum_{k=j}^{i-1}2^k(i>j)$，相当于是如果 $\forall i,j\in[l,r),b_i=b_j$，可以花费 $a_l+a_r$ 的代价使得 $b_i\gets 1-b_i(i\in[l,r))$。

现在就相当于是用这两种操作，把一个全零序列变成 $b$。

-----

但是区间取反还有可能是一部分用操作二，一部分用操作一，为方便，我们令 $c_i$ 表示对 $i$ 进行的是操作 $c_i$。

假设我们要取反的是 $[L,R]$。

如果存在 $l,k,r\in[L,R],l\le k<r$，使得 $\forall i\in[l,k],c_i=1,\forall i\in(k,r],c_i=2$，那么这样操作代价已经有了 $a_l$ 和 $a_{r+1}$，直接对 $[l,r]$ 做操作二不会更劣。

因此，我们只需要考虑前半部分用操作二，后半部分用操作一的情况，假设 $k$ 以前的位置用的是操作二，那么代价就是 $a_L+a_{k+1}+\sum_{i=k+1}^Ra_i$。记 $s_i=\sum_{j=0}^ia_j$，那么 那么代价就是 $a_L+a_{k+1}+s_r-s_k$。可以预处理 $a_{k+1}-s_k$ 的最小值。

假设 $w(l,r)$ 是反转区间 $[l,r]$ 的最小代价。

-----

有区间操作，数据范围比较小，不难想到使用区间 dp。

记 $dp_{l,r,0/1}$ 表示把区间 $[l,r]$ 从全 $0/1$ 操作成 $b$ 的最小代价。

转移：

- 若 $b_l=0,dp_{l,r,0}\gets dp_{l+1,r,0}$。

- 若 $b_r=0,dp_{l,r,0}\gets dp_{l,r-1,0}$。

- 若 $b_l=1,dp_{l,r,1}\gets dp_{l+1,r,1}$。

- 若 $b_r=1,dp_{l,r,1}\gets dp_{l,r-1,1}$。

- 若 $b_l=b_r=0,dp_{l,r,1}\gets dp_{l,r,0}+w(l,r),dp_{l,r,1}\gets \min_{k=l}^{r-1}dp_{l,k,1}+dp_{k+1,r,1}$。

- 若 $b_l=b_r=1,dp_{l,r,0}\gets dp_{l,r,1}+w(l,r),dp_{l,r,0}\gets \min_{k=l}^{r-1}dp_{l,k,0}+dp_{k+1,r,0}$。

答案为 $dp_{0,30,0}$。

-----

来进行一些卡常。

注意到 $k$ 以上的位置没必要用操作二，因为 $a_i=2a_{i-1}$，$a_r-a_l=(2^{r-l}-1)a_l=\sum_{i=l}^{r-1}a_i$。

于是我们只需要对前 $k$ 位 dp。

code：


```cpp
#include<bits/stdc++.h>
#define int long long
#define db long double
using namespace std;
template<typename T>
inline void read(T &x){x=0;char c=getchar();bool neg=0;while(!isdigit(c)){if(c=='-')neg=1;c=getchar();}while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();if(neg)x=-x;}
#define read2(a,b) read(a),read(b)
#define read3(a,b,c) read2(a,b),read(c)
#define read4(a,b,c,d) read3(a,b,c),read(d)
#define read5(a,b,c,d,e) read4(a,b,c,d),read(e)
#define read6(a,b,c,d,e,f) read5(a,b,c,d,e),read(f)
int x,y,k,a[32],s[32],dp[31][31][2],st[31][31],lg[32];
void slv(){
    read3(x,y,k);
    x=abs(x-y);
    y=x;
    int n=0;
    while(y){
        y>>=1;
        n++;
    }
    for(int i=0;i<=k;i++)read(a[i]);
    for(int i=k+1;i<=31;i++)a[i]=2e18;
    for(int i=1;i<=31;i++)a[i]=min(a[i],a[i-1]<<1);
    s[0]=a[0];
    for(int i=1;i<=31;i++)s[i]=s[i-1]+a[i];
    for(int i=0;i<=30;i++)st[0][i]=a[i+1]-s[i];
    for(int i=1;i<=5;i++){
        for(int j=0;j+(1<<i)-1<=30;j++){
            st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
        }
    }
    n=min(n,k);
    for(int i=0;i<=n;i++){
        if(x>>i&1)dp[i][i][0]=a[i],dp[i][i][1]=0;
        else dp[i][i][1]=a[i],dp[i][i][0]=0;
    }
    for(int len=2;len<=n+1;len++){
        for(int l=0,r=len-1;r<=n;l++,r++){
            dp[l][r][0]=dp[l][r][1]=2e18;
            if(x>>l&1)dp[l][r][1]=dp[l+1][r][1];
            else dp[l][r][0]=dp[l+1][r][0];
            if(x>>r&1)dp[l][r][1]=dp[l][r-1][1];
            else dp[l][r][0]=dp[l][r-1][0];
            if(dp[l][r][0]==2e18){
                dp[l][r][0]=dp[l][r][1]+a[r+1]+a[l];
                dp[l][r][0]=min(dp[l][r][0],a[l]+s[r]+min(st[lg[r-l+1]][l],st[lg[r-l+1]][r-(1<<lg[r-l+1])+1])+dp[l][r][1]);
                for(int i=l;i<r;i++)dp[l][r][0]=min(dp[l][r][0],dp[l][i][0]+dp[i+1][r][0]);
            }
            if(dp[l][r][1]==2e18){
                dp[l][r][1]=dp[l][r][0]+a[r+1]+a[l];
                dp[l][r][1]=min(dp[l][r][1],a[l]+s[r]+min(st[lg[r-l+1]][l],st[lg[r-l+1]][r-(1<<lg[r-l+1])+1])+dp[l][r][0]);
                for(int i=l;i<r;i++)dp[l][r][1]=min(dp[l][r][1],dp[l][i][1]+dp[i+1][r][1]);
            }
        }
    }
    int ans=dp[0][n][0];
    for(int i=k+1;i<=30;i++)if(x>>i&1)ans+=a[i];
    printf("%lld\n",ans);
    return ;
}
signed main(){
    for(int i=2;i<=31;i++)lg[i]=lg[i>>1]+1;
    int T;read(T);while(T--)
    slv();
    return 0;
}


```

---


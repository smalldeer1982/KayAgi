# [GCJ 2021 #1B] Subtransmutation

## 题目描述

作为国内最顶尖的炼金术士，你再次被征召，因为需要超越科学的力量来满足国家领袖对稀有金属日益增长的贪婪需求。

每种金属用一个正整数表示。你需要制造 $\mathbf{U}_{1}$ 个单位的 1 号金属，$\mathbf{U}_{2}$ 个单位的 2 号金属，……，以及 $\mathbf{U}_{\mathrm{N}}$ 个单位的 $\mathrm{N}$ 号金属。$\mathrm{N}+1$, $\mathrm{N}+2$, …… 号金属也存在，但你不需要制造特定数量的它们。你可以制造任何金属的过量单位，这些多余的金属可以直接丢弃。

不幸的是，预算削减让你只剩下施展一个简单炼金法术的材料。对于固定的数字 $\mathbf{A}$ 和 $\mathbf{B}$（$\mathbf{A}<\mathbf{B}$），你可以消耗 1 个单位的 $i$ 号金属，将其分解为 1 个单位的 $(i-\mathbf{A})$ 号金属和 1 个单位的 $(i-\mathbf{B})$ 号金属。如果其中某个整数不是正数，则不会生成对应的单位。特别地，如果 $i \leq \mathbf{A}$，这个法术只会销毁该单位而不生成任何金属。如果 $\mathbf{A}<i \leq \mathbf{B}$，法术会销毁该单位并只生成 1 个单位的 $(i-\mathbf{A})$ 号金属。

你被指派了一位专家矿工协助。专家矿工可以为你开采任意一种金属的 1 个单位。你可以从这个单位出发，使用你的法术制造其他金属，然后再对生成的金属施用该法术来制造更多单位。下图展示了在 $\mathbf{A}=1$ 和 $\mathbf{B}=2$ 时，1 个单位的 4 号金属通过两次法术转化为 1 个单位的 1 号金属和 2 个单位的 2 号金属的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)

数值越大的金属越重且越难处理，因此你希望向专家矿工请求数值尽可能小的金属单位来完成你的任务，或者指出这是不可能实现的。

## 说明/提示

**样例解释**

在样例 #1 中，我们需要 1 个单位的 1 号金属和 2 个单位的 2 号金属。如果从 1 个单位的 3 号金属开始，施用一次法术会得到 1 个单位的 1 号金属和 1 个单位的 2 号金属，无法再获得额外的 2 号金属。类似地，从 1 号或 2 号金属开始也不够。但如题目描述中的图示所示，从 4 号金属开始可以满足需求。

在样例 #2 中，我们可以从 1 个单位的 6 号金属开始，进行以下操作：
* 对 6 施法：$\{6\} \to \{4,5\}$
* 对 4 施法：$\{4,5\} \to \{2,3,5\}$
* 对 2 施法：$\{2,3,5\} \to \{1,3,5\}$
* 对 3 施法：$\{1,3,5\} \to \{1,1,2,5\}$

虽然会多出 2 号金属，但这个解是有效的。

在样例 #3 中，我们可以从 5 号金属开始：
* 对 5 施法：$\{5\} \to \{3,4\}$
* 对 4 施法：$\{3,4\} \to \{2,3,3\}$
* 对 2 施法：$\{2,3,3\} \to \{1,3,3\}$
* 对 3 施法：$\{1,3,3\} \to \{1,1,2,3\}$

其他操作方式也可以满足需求，但都需要从 5 号或更高编号的金属开始。

样例测试集 2 符合测试集 2 的限制。它不会用于测试你的提交。

在测试集 2 的第一个样例中，无法从任何金属的 1 个单位出发，通过 $\mathbf{A}=2$、$\mathbf{B}=4$ 的法术操作得到 1 个单位的 1 号、2 号和 3 号金属。

**数据范围**

- $1 \leq \mathbf{T} \leq 100$
- $1 \leq \mathbf{N} \leq 20$
- 对所有 $i$，$0 \leq \mathbf{U}_{\mathbf{i}} \leq 20$
- $1 \leq \mathbf{U}_{\mathbf{N}}$
- $2 \leq \mathbf{U}_{1}+\mathbf{U}_{2}+\cdots+\mathbf{U}_{\mathbf{N}}$

**测试集 1（13 分，可见评测结果）**
- $\mathbf{A}=1$
- $\mathbf{B}=2$

**测试集 2（18 分，隐藏评测结果）**
- $1 \leq \mathbf{A}<\mathbf{B} \leq 20$

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
3
2 1 2
1 2
5 1 2
2 0 0 0 1
3 1 2
1 1 1```

### 输出

```
Case #1: 4
Case #2: 6
Case #3: 5```

## 样例 #2

### 输入

```
3
3 2 4
1 1 1
3 2 4
1 0 1
5 2 5
1 0 0 0 1```

### 输出

```
Case #1: IMPOSSIBLE
Case #2: 5
Case #3: 10```

# 题解

## 作者：tuxiaolai (赞：2)

众所周不知：本蒟蒻是很不会数论的。
# 1 审题
一块编号为 $i$ 的金属，可以被分解成编号为 $i-A$ 和 $i-B$ 的金属各一块（前提是编号为正整数）。给定了我们需要的金属编号及数量，要求我们找出一块尽量编号小的金属，使得它经过若干次分解后，能够满足给定的需求。当然，也有可能无解。
# 2 思路
## 2.1 猜测
看完题目后，注意力好的同学可能会发现：有解的充要条件是所有所需的金属编号模 $\gcd(A,B)$ 同余。
## 2.2 证明：
根据题意，我们可以将 $i$ 分解成 $j$ 这个操作，看作是 $i$ 经过若干次减 $A$ 和若干次减 $B$ 得到了 $j$，即 $i-Ax-By=j$。

令 $d=\gcd(A,B)$。
### 2.2.1 必要性（有解一定同余）
我们知道，最终的答案 $S$ 经过分解后能够得到所有我们所需要的金属。对于每一块所需的金属编号 $M_i$，都存在自然数 $x_i$ 和 $y_i$ 使得 $S-Ax_i-By_i=M_i$，变形可得 $S-M_i=Ax_i+By_i$。

由于 $d\mid (Ax_i+By_i)$，所以 $d\mid (S-M_i)$，即 $S \equiv M_i (\bmod  d)$。

不难得出，所有的所需编号都模 $d$ 同余，该命题得证。
### 2.2.2 充分性（同余一定有解）
先考虑只有两块金属 $M_1$ 和 $M_2$ 的情况：

我们知道若有解，就一定存在一块金属 $S'$ 使得它能够分解成 $M_1$ 和 $M_2$，即 $S'-Ax_1-By_1=M_1$ 且 $S'-Ax_2-By_2=M_2$，为满足题目条件，我们就令 $x_1,x_2,y_1,y_2 \in N_+$。问题就是是否存在这样的 $x_1,x_2,y_1,y_2$。

我们将上面的两个公式稍加变形：
$$
\begin{cases}
S'-Ax_1-By_1=M_1\\
S'-Ax_2-By_2=M_2
\end{cases}\\
M_1+Ax_1+By_1=M_2+Ax_2+By_2\\
M_2-M_1=(Ax_1-Ax_2)+(By_1-By_2)\\
M_2-M_1=A(x_1-x_2)+B(y_1-y_2)\\
$$
因为 $M_2\equiv M_1(\bmod d)$。所以 $d\mid M_2-M_1$。

我们令 $M_2-M_1=kd$。最终，公式就变成了 $A(x_1-x_2)+B(y_1-y_2)=kd$。

哎！这就不是裴蜀定理吗？于是，该子命题成立。此时，我们能够确保由金属 $S'$ 能够分解成 $M_1$ 和 $M_2$，这样就变成了 $S'$ 与 $M_3$ 的问题，同上，我们最终能够证明命题成立。

有了上面的推论，无解情况就很好判断了。那么其他的就是有解情况了。这里我们不讲思路，直接上算法。
# 3 算法
```cpp
memset(u,0,sizeof(u));
cin>>n>>A>>B;
int gcd1=gcd(A,B);
bool flag1=1;
int m=-1;
for(int i=1; i<=n; i++) {
    cin>>u[i];
    if(u[i]) {
        if(m==-1) {
            m=i%gcd1;
        } else {
            flag1&=(i%gcd1==m);
        }
    }
}
if(!flag1) {
    cout<<"Case #"<<c<<": "<<"IMPOSSIBLE\n";
    continue;
}
```
首先根据我们前面的推论，对无解情况进行判断。

我们可以保证其他情况都有解，且这个解与前面的所有所需编号模 $gcd1$ （$A$ 和 $B$ 的最大公约数，即上文中的 $d$）同余。因此，我们只要从 $n$ 出发，枚举所有可能的 $S$ 即可。
```cpp
for(int i=n;; i+=gcd1) {
    for(int j=1; j<=n; j++) {
        now[j]=u[j];
    }
    map<int,int,greater<int>> mp;
    mp[i]=1;
    for(auto j:mp) {
        int k=j.first,v=j.second;
        if(k<=n && now[k]){
            if(now[k]>v){
                break;
            }else{
                v-=now[k];
                now[k]=0;
            }
        }
        if(k-A>0){
            mp[k-A]+=v;
        }
        if(k-B>0){
            mp[k-B]+=v;
        }
    }
}
```
我们用 $mp$ 来记录编号与现有的数量，由于分解得到的编号一定是从大到小的，所以我们将 $mp$ 按键升序排列。从 $S$ 出发，一直分解，当遍历到 $j$ 时，它的数量已经是固定的，若 $j$ 是我们最终需要的金属，先判断够不够，不够直接退出循环，够了则减去所需量，再进行分解。知道最后全部分解完后，$mp$ 为空，结束遍历。

最后，我们遍历数组 $now$，若全部金属都已足够，就可以输出答案结束循环了。
# 4 AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,A,B;
int u[25];
int now[25];
int gcd(int a,int b) {
    return a%b ? gcd(b,a%b) : b;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>T;
    for(int c=1; c<=T; c++) {
        memset(u,0,sizeof(u));
        cin>>n>>A>>B;
        int gcd1=gcd(A,B);
        bool flag1=1;
        int m=-1;
        for(int i=1; i<=n; i++) {
            cin>>u[i];
            if(u[i]) {
                if(m==-1) {
                    m=i%gcd1;
                } else {
                    flag1&=(i%gcd1==m);
                }
            }
        }
        if(!flag1) {
            cout<<"Case #"<<c<<": "<<"IMPOSSIBLE\n";
            continue;
        }
        for(int i=n;; i+=gcd1) {
            for(int j=1; j<=n; j++) {
                now[j]=u[j];
            }
            map<int,int,greater<int>> mp;
            mp[i]=1;
            for(auto j:mp) {
                int k=j.first,v=j.second;
                if(k<=n && now[k]){
                    if(now[k]>v){
                        break;
                    }else{
                        v-=now[k];
                        now[k]=0;
                    }
                }
                if(k-A>0){
                    mp[k-A]+=v;
                }
                if(k-B>0){
                    mp[k-B]+=v;
                }
            }
            bool flag2=1;
            for(int j=1; j<=n; j++) {
                flag2&=(now[j]==0);
            }
            if(flag2) {
                cout<<"Case #"<<c<<": "<<i<<'\n';
                break;
            }
        }
    }
    return 0;
}
```
# 5 结语
这份代码看起来复杂度有点高，但实际上最终答案并不会太大。另外，大家不用管几十秒的时限，就当 1s/512 MB 来做，毕竟正解一般都用不了一秒。

完结撒花！

---


# [GCJ 2020 #1B] Expogo

## 题目描述

你刚刚收到了有史以来最棒的礼物：一根 **Expogo** 跳跃棒。你可以站在上面，用它进行越来越大的跳跃。

你目前站在无限大的二维后院中的点 $(0, 0)$ 处，并试图以尽可能少的跳跃次数到达目标点 $(\mathrm{X}, \mathrm{Y})$（坐标为整数）。你必须恰好落在目标点上，仅从上方经过是不够的。

每次使用 **Expogo** 跳跃棒跳跃时，你需要选择一个基本方向：北（north）、南（south）、东（east）或西（west）。第 $i$ 次跳跃会将你移动 $2^{(i-1)}$ 个单位，因此第一次跳跃移动 1 个单位，第二次跳跃移动 2 个单位，第三次跳跃移动 4 个单位，以此类推。

给定目标点 $(\mathrm{X}, \mathrm{Y})$，判断是否可以到达该点。如果可以，请展示如何以最少的跳跃次数实现。

## 说明/提示

**样例解释**

在样例 #1 中，你可以从 $(0, 0)$ 向南跳到 $(0, -1)$，然后向东跳到 $(2, -1)$，最后向北跳到 $(2, 3)$。

我们可以确定没有更高效的解决方案（两次或更少跳跃），因为到达目标点至少需要 $2 + 3 = 5$ 个单位的距离，而前两次跳跃总共只能提供 $3$ 个单位的距离。

注意，样例 #2 是样例 #1 关于两个坐标轴的镜像，因此答案也是样例 #1 答案中所有方向的镜像。

在样例 #3 中，注意 **EWE** 不是一个有效答案，尽管它能到达目标点，因为存在使用更少跳跃次数的方案。

我们留给你思考为什么在样例 #4 中无法到达目标点。

**数据范围**

- $(\text{X}, \text{Y}) \neq (0, 0)$。

**测试集 1（5 分，可见判定）**

- $1 \leqslant \text{T} \leqslant 80$。
- $-4 \leqslant \text{X} \leqslant 4$。
- $-4 \leqslant \text{Y} \leqslant 4$。

**测试集 2（8 分，可见判定）**

- $1 \leqslant \text{T} \leqslant 100$。
- $-100 \leqslant \text{X} \leqslant 100$。
- $-100 \leqslant \text{Y} \leqslant 100$。

**测试集 3（16 分，可见判定）**

- $1 \leqslant \text{T} \leqslant 100$。
- $-10^{9} \leqslant \text{X} \leqslant 10^{9}$。
- $-10^{9} \leqslant \text{Y} \leqslant 10^{9}$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
2 3
-2 -3
3 0
-1 1```

### 输出

```
Case #1: SEN
Case #2: NWS
Case #3: EE
Case #4: IMPOSSIBLE```

# 题解

## 作者：WanderFreeFish (赞：3)

## Thinking

- 首先想到的是 $x$ 和 $y$ 的正负不影响是否能到达，只能影响方向。那么就可以把方向用变量存下来，这个值影响输出。

- 接下来要处理的就是什么时候可以到达。可以发现，题目中所提到的行走方式，正好对应的是二进制下的每一位。那么就可以往位运算的方向去考虑了。

- 然后思考行走方式。我们除了可以往前面走，还可以先稍微往后退一下，再往前走，只要保证走的路径长度之和在二进制下每一位都是 $1$，并且走的每一段路径在二进制下每一位都没有重复。

## Example

对于如下两个数：

$$ x = (10010101)_2 $$
$$ y = (01011010)_2 $$

考虑从低位往高位遍历。

1. 在最低位，需要 $x$ 往正方向走，也就是使用了一次 $2^0$ 跳跃长度的机会，完成第一位。

2. 在第二位，需要 $y$ 往正方向走，使用一次 $2^1$ 跳跃长度的机会。

3. 在第三位，需要 $x$ 往正方向走，使用一次 $2^2$ 跳跃长度的机会。

4. 在第四位，如果只是简单地 $y$ 走正方向，会发现在下一位 $x$ 和 $y$ 都需要消耗跳跃机会，我们要让其中的一个不需要抢占这一位。这个时候就要让 $y$ 走负方向，消耗一次 $2^3$ 跳跃长度的机会，此时 $y$ 需要走的路程要加上 $2^3$ 完成第四，第五位的进位，下一位 $y$ 不需要再抢占跳跃机会了。

$$ x = (10010101)_2 $$
$$ y = (01100010)_2 $$
$$ a = (00001000)_2 $$

这是当前的路程，其中 $a$ 为负方向距离。

5. 在第五位，需要 $x$ 往正方向走，使用一次 $2^4$ 跳跃长度的机会。

6. 在第六位，需要 $y$ 往正方向走，使用一次 $2^5$ 跳跃长度的机会。

7. 在第七位，需要 $y$ 往正方向走，使用一次 $2^6$ 跳跃长度的机会。

8. 在第八位，需要 $x$ 往正方向走，使用一次 $2^7$ 跳跃长度的机会。

容易发现，如果在某一位 $x$ 与 $y$ 都是 $0$，也能通过进位的方式保证每一位都不重不漏。

## Specifically

大体思路讲清楚了，接下来说说代码实现的问题。

首先，如果在最低位，两个数都要争抢跳跃机会，或者都不需要这机会，那就没救了，直接输出 $\texttt {Impossible}$。

还有，位运算我这里推荐一个好用的黑科技。用 bitset 计算会比单纯用 int 快许多。

后面注释都在代码里了，很容易理解的。

## Code

```cpp
#include <iostream>
#include <algorithm>
#include <bitset>


void out (char x, int d) { // x 表示在哪个方向上走，d 表示方向是正还是反
	if (x == 'x') {
		if (d == 1) std::cout << 'E';
		else std::cout << 'W';
	}
	else {
		if (d == 1) std::cout << 'N';
		else std::cout << 'S';
	}
}

void solve () {
	int x, y, dx = 1, dy = 1; std::cin >> x >> y; // dx 和 dy 表示的是往哪个方向走，1 表示正方向，-1 表示反方向
												  // 而对于横坐标 x 而言，正方向是 E 反方向是 W
												  // 对于纵坐标 y 而言，正方向是 N 反方向是 S
	
	if (x == 0 && y == 0) return;
	if (x < 0) dx = -1, x = -x;
	if (y < 0) dy = -1, y = -y;
	if ((x + y) % 2 == 0) {
		std::cout << "IMPOSSIBLE";
		return;
	}
	
	std::bitset <32> a(x), b(y);
	
	for (int i = 0; i < 32; i++) {
		if ((a >> (i + 1)) == 0 && (b >> (i + 1)) == 0) { // 如果下一位已经走到目的地了，也就是后面的二进制位上都是 0，修改完这一位就退出
			if (a[i] == 1) out('x', dx);
			else out('y', dy);
			return;
		}
		
		if (a[i + 1] == b[i + 1]) {
			if (a[i] == 1) {
				out('x', -1 * dx); // 这里是要往 "原方向的反方向" 走，故乘上 -1 就能掉头
				a = std::bitset <32> (a.to_ulong() + (1 << i));
			}
			else {
				out('y', -1 * dy);
				b = std::bitset <32> (b.to_ulong() + (1 << i));
			}
		}
		else {
			if (a[i] == 1) out('x', dx);
			else out('y', dy);
		}
	}
}

int main () {
	int T; std::cin >> T;
	
	for (int i = 1; i <= T; i++) {
		std::cout << "Case #" << i << ':' << ' ';
		solve();
		std::cout << '\n';
	}
	
	return 0;
}
```

---

## 作者：A_small_WA (赞：2)

## 前言

注意到标签里有贪心。第二次做没有题解的绿题。

## 思路

本题可以把 $x,y$ 看作二进制数，第 $i$ 次操作相当于把 $x$ 或 $y$ 二进制下第 $i$ 位 $+1$ 或 $-1$（要进位）。最终目标等价于把 $x$ 和 $y$ 都变为 $0$。

考虑枚举每一次操作，记 $x$ 二进制下第 $i$ 位为 $a_i$，$y$ 二进制下第 $i$ 位为 $b_i$，可以简单得出以下几个结论：

- 若已经完成前 $i-1$ 次操作，且 $a_i=b_i$，那么一定无解。（因为第 $i$ 次操作之后必有 $a_i=1$ 或 $b_i=1$，此后的操作都不可能把这个 $1$ 消掉）
- 否则（即 $a_i\ne b_i$），说明 $x,y$ 当中有且仅有一位是 $1$，设这一位是 $c(c=a$ 或 $b)$。此时需要判断是否有 $a_{i+1}=b_{i+1}$，如果有，那第 $c$ 就必须进位，否则就可以让 $c-1$。
- 如果一切按照以上两种情况进行，那到第 $i$ 次操作时，要么已经判断出无解，要么 $a$ 和 $b$ 的前 $i-1$ 位都是 $0$。

第一和第三个结论都好证，这里重点讲一下第二个结论。

考虑贪心，如果 $a_{i+1}\ne b_{i+1}$，那第 $i$ 位进位就只会增加步数，使之后的情况可能反而更劣，因此正常 $-1$ 最好。

如果$a_{i+1}= b_{i+1}$，那第 $i$ 位进位会使 $a_{i+1}\ne b_{i+1}$，从而使我们可以继续操作，同时将这种思路应用于第 $i+1$ 位以后（此时 $a_{i+1}\ne b_{i+1}$）可以解决之后所有的 $a_i\ne b_i$ 的问题。

严格来说，其实只要 $x,y$ 中两个数刚好一奇一偶，就必然有解，反之无解。~~所以我的思路是不是太过复杂了~~

## 代码实现

这里为了方便，我把 $x,y$ 全部取绝对值，用 `fanx` 和 `fany` 标记有没有改变过原值。那么根据题意，就有以下操作和方向对应的表格了：（$-$ 表示不重要）

|编号|操作|$fanx$|$fany$|对应方向|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$a_i+1$|$0$|$-$|`W`|
|$2$|$a_i+1$|$1$|$-$|`E`|
|$3$|$a_i-1$|$0$|$-$|`E`|
|$4$|$a_i-1$|$1$|$-$|`W`|
|$5$|$b_i+1$|$-$|$0$|`S`|
|$6$|$b_i+1$|$-$|$1$|`N`|
|$7$|$b_i-1$|$-$|$0$|`N`|
|$8$|$b_i-1$|$-$|$1$|`S`|

还有一点，其实不需要把 $a,b$ 数组都求出来，因为这样不仅复杂度很高而且进位的时候容易写错。可以用位运算， $a_i=x\&p_i$，$b_i=y\&p_i$。这里 $p_i$ 表示 $2^{i-1}$，可以提前预处理出来，加减的时候直接用 $x,y$ 和 $p_i$ 即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
string ans;
bool flag,fanx,fany,c[100];
int a[100],b[100],p[100];
signed main(){
	int x,y,t,cnt=0;
	cin>>t;p[1]=1;
	for(int i=2;i<=40;i++) p[i]=p[i-1]*2;
	while(t--){
		cin>>x>>y;flag=0,cnt++,fanx=fany=0,ans="";
		if(x<0) x=-x,fanx=1;
		if(y<0) y=-y,fany=1;
		printf("Case #%lld: ",cnt);
		for(int i=1;x>0||y>0;i++){
			bool ai=x&p[i],bi=y&p[i],bjj=0;
			if(ai==bi){
				flag=1;
				break;
			}
			int aj=x&p[i+1],bj=y&p[i+1];
			if(p[i+1]<=max(x,y)&&aj==bj) bjj=1;
			if(bjj){
				if(ai){
					x+=p[i];
					if(fanx) ans+='E';
					else ans+='W';
				}else{
					y+=p[i];
					if(fany) ans+='N';
					else ans+='S';
				}
			}else{
				if(ai){
					x-=p[i];
					if(fanx) ans+='W';
					else ans+='E';
				}else{
					y-=p[i];
					if(fany) ans+='S';
					else ans+='N';
				}
			}
		}
		if(flag) cout<<"IMPOSSIBLE";
		else cout<<ans;
		cout<<"\n";
	}
	return 0;
}
```

这是蒟蒻的第 $19$ 篇题解，感谢观看。

---


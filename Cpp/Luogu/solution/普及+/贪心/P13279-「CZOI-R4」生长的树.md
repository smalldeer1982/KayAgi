# 「CZOI-R4」生长的树

## 题目描述

你是小 J 的园丁，你需要帮他修剪他的一棵生长的树 $T_1$。

$T_1$ 是一棵 $k$ 叉树，在第 $0$ 个时刻，$T_1$ 只有**根节点**一个节点，编号为 $1$。

接下来从第 $1$ 个时刻开始，对于每 $1$ 个时刻将**依次**发生：
- 当前的 $T_1$ 中所有儿子数量**小于** $k$ 个的节点，将补充若干个子节点使其儿子数量为 $k$，补充的节点的编号可以**任意决定（无需小于等于 $n$）**，但不可以与 $T_1$ 的其他节点的编号相同。
- 你进行若干次操作（可以不进行），每次操作指定 $T_1$ 的一个**不为根节点**的节点，将**它的子树**从 $T_1$ 上删除。

小 J 会给定你一棵有 $n$ 个节点的树 $T_2$，$T_2$ 的**根节点**编号为 $1$，他希望某个时刻后满足以下条件：
- $T_1$ 有 $n$ 个节点，且节点的编号恰好为 $1\sim n$。
- 在 $T_1,T_2$ 中，除了根节点，所有**编号相同**的节点的父亲编号相同。

你需要求出最早可以在第几个时刻后满足条件，和在此基础上的**最小**操作次数。

## 说明/提示

**【样例解释】**

如图，在第 $1,2$ 个时刻这样分配节点编号，并在 $2$ 个时刻时，删除编号为 $7,8,9,10$ 的节点的子树即可。可以证明不存在更优的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/hpjqzk0l.png)

**【数据范围】**

**本题采用捆绑测试**。

- Subtask #1（$10\text{ pts}$）：$k=1$。
- Subtask #2（$10\text{ pts}$）：$T_2$ 是一棵满 $k$ 叉树。
- Subtask #3（$20\text{ pts}$）：$n,k\le10$。
- Subtask #4（$20\text{ pts}$）：$k=2$。
- Subtask #5（$40\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le u,v\le n\le 5\times 10^5$，$1\le k\le 10^6$，$\max\limits_{1\le i\le n}\{\text{son}_i\}\le k$。其中 $\text{son}_i$ 指 $T_2$ 的第 $i$ 个节点的儿子**个数**。

## 样例 #1

### 输入

```
6 3
1 2
1 5
2 3
2 4
5 6```

### 输出

```
2 4```

# 题解

## 作者：_O_v_O_ (赞：15)

## Part 1

由于我们可以自由分配编号，那么我们就只关注树的形态即可。

具体的，假如在某次操作中生长出来了的点与 $T_2$ 中的某个点一样，那么我们就把他标为他在 $T_2$ 中的对应编号。否则，因为这个点肯定要被删，那么我们直接随便标一个即可。

设 $T_2$ 中 $i$ 号点的子树内距离其最远的距离为 $mdep_i$，即最大深度，那么时间最少为 $mdep_1$，因为 $T_1$ 每次的最大深度最多 $+1$。

那么第一问答案为 $mdep_1$。

## Part 2


**结论**：若一个点在某个时间被删除，若这是最优策略，那么在剩下的时间内，这个点**不可能**被删除。

因为假如这个点在之后删除，那么这个点其实在这次是可以不删除的，节约了一次操作。

---

那么根据上面的结论，$T_1$ 删点肯定是从上往下删的，考虑对树从上往下进行 dfs 来考虑删哪些点。

那么问题来到了如何用最优策略删儿子。

## Part 3
我们注意到假如一个点 $x$ 在某个时间要被删，那么很显然，剩下的时间 $t_0$ 是满足 $t_0>mdep_x$ 的。那么我们为何不可以不删这个点，改成在最后时刻删这个子树的叶子的儿子？

eg：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3znodm6.png)

对于这棵树 $2$ 的子树，假如剩 $3$ 个单位的时间，$k=2$，有两种方式：

1. 第 $1$ 个时刻删 $2$，第 $3$ 个时刻删 $4$ 额外长出的儿子。
2. 第 $3$ 个时刻删 $4$ 额外的儿子，$5,6,7$ 的所有儿子。

很显然，前者更优，那么我们不妨用一种类似的方法删儿子：在还剩 $mdep_x$ 个单位的时间删 $x$，然后继续在子树中删下去。


---

那么我们在 dfs 时，假如遍历到了 $x$，只用删满足 $i\in son_x$ 且 $dep_{son_x}<dep_x-1$  的 $i$，即 $i$ 内子树与 $i$ 距离最大的点不是与 $x$ 距离最大的点之一时就在 $mdep_x-mdep_i$ 时删 $i$。

那么我们就解决了这个问题。

## Part 4

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+5;
int n,k;
vector<int> e[N];
int mdep[N],dep[N];
int ans;

void dfs(int x,int fa){
	for(int i:e[x]){
		if(i==fa) continue;
		dep[i]=dep[x]+1;
		dfs(i,x);
		mdep[x]=max(mdep[x],mdep[i]+1);
	}
	if(mdep[x]==0) return;
	ans+=k;
	for(int i:e[x]){
		if(i==fa) continue;
		if(mdep[i]==mdep[x]-1) ans--;
	}
}


signed main(){
	cin>>n>>k;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	cout<<mdep[1]<<' '<<ans<<endl;
	return 0;
}
```

---

## 作者：Argvchs (赞：12)

首先时刻数一定是等于最深的点的深度 $d$ 的（根节点深度为 $0$），因为你必须要生长到那个点。

然后考虑怎么求操作数，即怎么删点。

可以想到一种构造，就是你一直生长直到最后把深度最浅的无效点全部删了。

但是这样很容易就会被 hack：如果目标树内 $u$ 的所有叶子的深度都是 $d - 1$，那你不如先把 $u$ 删一次，这样深度都会减一。

这个 hack 启示我们，可以等到一个恰好的时刻把一棵子树删了，然后重新生长。

例如，如果根的儿子 $u$ 的子树内所有点深度的最大值 $f_u < d$，那么可以在 $d - f_u$ 时刻把他删了，否则就不需要删，这样是最优的。

你模拟一下就会发现这样是对的。

注意到你每次走到儿子其实是在做一个等价的子问题，于是不难想到对树 dfs 一遍。

具体的，你走到一个点 $u$ 先把叉数 $k$ 的贡献加上，然后对每个儿子 $v$ 判断：如果 $f_v = f_u$ 就不需要删，此时把答案减一；否则就需要删，但是不用更新答案，因为已经在叉数中算过了。

这样就做完了。

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
using i64 = long long;
const int N = 5e5 + 5;
int n, k, d[N], f[N];
i64 ans;
vector<int> G[N];
void add(int u, int v) { G[u].push_back(v); }
void addedge(int u, int v) { add(u, v), add(v, u); }
void dfs(int u, int fa) {
    for (int v : G[u])
        if (v != fa) d[v] = d[u] + 1, dfs(v, u), f[u] = max(f[u], f[v]);
    if (!f[u]) return void(f[u] = d[u]);
    ans += k;
    for (int v : G[u])
        if (v != fa && f[v] == f[u]) --ans;
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for (int i = 1, u, v; i < n; i++) cin >> u >> v, addedge(u, v);
    dfs(1, 0), cout << f[1] << ' ' << ans;
}
```

---

## 作者：XHZnewlife (赞：6)

~~蒟蒻的第一篇题解，求过~~

[推一下自己的专栏](https://www.luogu.com.cn/article/5ag52gip)

**首先，我们可以注意到这道题中节点的编号是没有任何用处的。**

由于可以任意填编号，对于符合 $T_{2}$ 的点，我们原样填进去，其余节点，我们填大于 $n$ 的数。

而我们站在完成时的眼光看过去，可以假设我们每次都填了恰好正确的编号。

## 第一思路

在赛时的紧张环境下，我们很难一下想到正解，于是我们往往可以凭借我们直观感受找到一个第一思路。

样例给了一个很好的示范（~~记住这句话~~。

在样例的引导下我们很快就想到了让 $T_{1}$ 符合要求的前提必须是——它和 $T_{2}$ 一样深，这个条件只能等待时间的流逝。

但一次时间内我们可以操作无数次。所以通过样例，我们可以想到:深度足够之后，再将多余部分全部剪掉。

所以，我们的直观想法就诞生了—— $p$ 就是深度， $q$ 就是不满足深度的所有结点的缺失子树个数。

# 正解
然而——直观思路只能拿到 $20$ 分。

问题出在哪里呢？

我们不妨考虑一个这样的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ytvlfg22.png)

如果是刚才的思路，我们一定不假思索地回答：“ $2$ $3$ ”。

但答案却是“ $2$ $1$ ”。

我们的思维被限制在哪里了呢？

“深度足够之后，‘再’将多余部分全部剪掉。”

在此例子中，第一次生长后就可以剪去最右边的的节点了，这样只需要一次操作。

~~样例真是害人不浅~~

我们再画几个图就可以直观感受到对于一个叶子节点深度齐平的子树来说，这个局部就只需要被修剪一次。

我们能否大胆得出结论：深度不同的叶子节点/子树对答案产生贡献。

是深度决定了时刻数，而在刚才的~~头脑风暴~~中我们知道了操作数可以在局部更改时刻数,所以深度差别的个数对操作数有贡献。

所以不同深度产生贡献是一定的，同深度不产生贡献也是一定的。

在此贴出赛时代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
struct tree{
	vector<int> chid;
}leaf[500010];
int ans=0;
int cnt=0;
void dfs1(int id,int fid,int deep){
	cnt=max(cnt,deep);
	for(int i=0;i<leaf[id].chid.size();i++){
		if(leaf[id].chid[i]!=fid){
			dfs1(leaf[id].chid[i],id,deep+1);
		}
	}
	return ;
}
int dfs2(int id,int fid,int deep){
	int j=0,o=k;
	vector<int> vec;
	int _max=0;
	for(int i=0;i<leaf[id].chid.size();i++){
		if(leaf[id].chid[i]!=fid){
			vec.push_back(dfs2(leaf[id].chid[i],id,deep+1));
			_max=max(_max,vec[vec.size()-1]);
			++j;
		}
	}
	if(j==0)return deep;
	for(int i=0;i<vec.size();i++)
		if(vec[i]==_max)o--;
	ans+=o;
	return _max;
}
signed main(){
	cin>>n>>k;
	if(k==1){
		cout<<n-1<<" "<<0;
		return 0;
	}
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		leaf[u].chid.push_back(v);
		leaf[v].chid.push_back(u);
	}
	dfs1(1,0,1);
	dfs2(1,0,1);
	cout<<cnt-1<<" "<<ans;
	return 0;
}
```

观察到赛时 $20pts$ 巨多，为了提供一个 $20$ -> $100$ 的思路并给出我个人的一些经验，于是献上此篇题解。

---

## 作者：concert_B (赞：5)

# [P13279 「CZOI-R4」生长的树](https://www.luogu.com.cn/problem/P13279)题解

## 备注

看了两篇题解，发现都有所有减去重复的思想，但逆推不是很好理解，这里发一篇顺推的。

本文尽量使用短句，~~避免被喷~~。

## 翻译

本题虽然用中文写，但理解起来非常难崩，极易偏差。

所求的最终树只要形状一样即可，编号等无需考虑。删点后，树会继续生长。删点任意时刻都能进行，并非只在长好后删。

形象化的，如图，$k=3$ 时，时刻 1 上半长到了图 1.1，在图 1.2 砍了一刀。上面两个是同一时刻。时刻 2 长到 图 2.1。

```
                   /O
 /O      /O      /O-O
/       /       /  \O
O-O  -> O    -> O-O
\       \       \  /O
 \O      \O      \O-O
                   \O
 1.1     1.2     2.1
```

## 分析

第一问时刻数：令根节点深度为 $0$，一定等于最深的点的深度，因为你必须要生长到那个点。我们约定它为 $T$。

第二问操作数：根据上文题面翻译，我们先让这~~柯~~棵树长到 $T$ 时刻，不操作。对于这棵完全树，任意节点 $u$，我们有两种操作。

1. 删以 $u$ 为根的树。相当于，在 $T$ 时刻删以 $u$ 为根的树，~~跟没说一样~~。

2. 删以 $u$ 为根的树的下方 $k$ 层。相当于，在某时刻删以 $u$ 为根的树，这棵树再长了一会，这时该树就少了几层。

上面两操作代价都为 $1$。

我们发现，优先从上到下操作 $2$ 是最优的。实际上，$1$ 操作也是 $2$ 操作的特例。

反过来，另类理解：目标树变成完全树。

1. 加以 $u$ 为根的子树。

2. 在以 $u$ 为根的树的下方增加 $k$ 层。

上面两操作代价都为 $1$。

理解方式等价，本人用下面的，代码更好写。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+5;

int n,k;
int dep[N],ans;
vector<int> g[N];

int ask_dep(int rt,int d,int fa){		//处理子树叶子的最大深度 
	dep[rt]=d;
	for(int i=0;i<g[rt].size();i++){
		if(g[rt][i]==fa)	continue;
		dep[rt]=max(dep[rt],ask_dep(g[rt][i],d+1,rt));
	}
	return dep[rt];
}

void dfs(int rt,int add,int fa){		//add 是操作 2 加的层数 
	int res=0;
	if(dep[rt]+add<dep[1])	ans++,add+=dep[1]-dep[rt]-add;	//还原操作 2 
	for(int i=0;i<g[rt].size();i++){
		if(g[rt][i]==fa)	continue;
		res++;
		dfs(g[rt][i],add,rt);
	}
	if(res==0)	return;		//是叶子 
	ans+=k-res;				//还原操作 1 
	return;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	
	ask_dep(1,0,-1);
	
	dfs(1,0,-1);
	
	cout<<dep[1]<<' '<<ans;
	return 0;
}
```

完结散花！！！

---

## 作者：Cnolm (赞：4)

# 思路

~~发现没有BFS的题解，赶紧来一发~（逃~~

[原题链接](https://www.luogu.com.cn/problem/P13279)

$T_1$ 每个时刻都向下延伸一层子节点，且删除多余的节点不影响最大深度，**因而 $T_2$ 这棵树的深度就是满足条件的时间**。  

接下来考虑删除节点的问题，我们只需要删除多余的节点，保持和 $T_2$ 相同即可。

但我们发现，在某个叶子节点 $u$ 被延伸出去之后，而其他节点还需要继续生长时（ $T_2$ 的最大深度还没到达 $T_1$ 的最大深度），则 $u$ 节点会在以后生出更多的子节点。因此，与其删除他的子节点，**不如先删除这个节点，在下一个时刻在长出来**，这样仅需删除一次就可以清除多余的节点。~~一锅端了属于是。~~

如何让删节点的效益最大化呢？如果我们在删除一个节点后，后来仍需要删除这个节点，显然这个方案不是最优。

**因此我们可以让这个节点在被删掉之后，他的叶子节点刚好在最后一个时刻长出来，然后再修建多余的部分。** 

所以我们可以预处理一个 $Depth$ 数组来存储每个节点子树的深度，显然，$Depth[1]$ 是 $T_2$ 这棵树的深度，也是满足条件的时间。

所以，我们删除某个可以被删除的节点 $u$ 时，需要让他在 $Depth[1]-Depth[u]$ 这个时刻被删除，这样子当到最后一刻时，$T_1$ 中该节点的子树的深度刚好等于 $T_2$ 中该子树的深度了。

结合代码食用更佳~

# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{ //节点信息 
	ll id, depth; //节点编号和深度 
	vector<ll> son; //存储子节点 
};
struct bf{ //存储节点编号和遍历深度 
	ll id, depth;
};
node nl[1000010]={}; //存储节点 
bool vis[1000010]={0,1}; //节点是否已经是某个节点的父节点/子节点 
ll n,k; 
ll cnt=0; //计算次数 
int dfs(int cur){ //DFS计算子树深度 
	if(nl[cur].son.size()==0){ //到底返回 
		nl[cur].depth = 1;
		return 1;
	}
	int maxn=0;
	for(int i=0;i<nl[cur].son.size();i++){
		maxn = max(maxn, dfs(nl[cur].son[i])); //计算子树最深深度 
	}
	nl[cur].depth = maxn+1;
	return maxn+1; //返回 
}
int main(){
	cin >> n >> k;
	for(int i=0;i<n-1;i++){ //建树 
		ll u,v; cin >> u >> v;
		//如果u节点已经被访问过，则不可能为v的子节点 
		if(vis[u]) nl[u].son.push_back(v), vis[v]=1;
		//同上 
		else nl[v].son.push_back(u), vis[u]=1;
	}
	dfs(1); //预处理各节点深度 
	int maxdepth = nl[1].depth-1; //最大深度就是根节点子树深度 
	//BFS遍历树 
	queue<bf> q1;
	q1.push((bf){1,0});
	while(!q1.empty()){
		bf cur = q1.front(); q1.pop();
		if(cur.depth>=maxdepth) continue;
		int adep = 0; //移动子树 
		if(cur.depth+nl[cur.id].depth-1<maxdepth){
			/*如果在该子树遍历后仍有时间(子树最深深度小于根节点深度)
			则可以尝试先删除该树放到以后再长出来(使子树最深深度等于根节点深度)
			就可以避免删除其子节点的问题
			代码中 cur.depth+nl[cur.id].depth-1 -> 子树最深深度 ; maxdepth -> 根节点深度
			*/
			adep = maxdepth-cur.depth-nl[cur.id].depth+1; //移动子树 
			cnt++;
		}
		//如果子树为最深的子树(包括被移动的节点)则删除多余节点 
		if(nl[cur.id].son.size()) cnt+=(k-nl[cur.id].son.size()); 
		for(int i=0;i<nl[cur.id].son.size();i++){ //放入子节点，并移动子树 
			q1.push((bf){nl[cur.id].son[i], cur.depth+1+adep});
		}
	}
	cout << nl[1].depth-1 << " " << cnt; //输出 
	return 0; //Ending
}
```
[提交记录](https://www.luogu.com.cn/record/224342427)

ps.比赛的时候硬是没调出来，第二天几分钟就调出来了（哭

 _审核大大求过qwq~_

---

## 作者：Night_sea_64 (赞：3)

显然题目中要求就是整棵树等于 $T_2$。

第一问是容易的，如果根结点深度为 $0$，那么答案就是最大深度 $-1$。理由是你长到这个深度之后显然可以删除一些子树达到要求。

第二问呢，比赛中好像很多人包括我都想假了，遇到这种情况我们应该相信这个题目的解法应该是优雅自然的，不应该有一些奇奇怪怪的东西。

以下就是一个优雅自然的做法：树形 dp。设 $f_x$ 表示将 $x$ 的子树弄好需要多少次操作。

考虑转移。叶子结点答案为 $0$。

$x$ 不是叶子结点的情况，$f_x$ 显然要加上所有子树的答案。同时还有一些额外的操作：

- 如果子树不到 $k$ 个，那么需要在最后把空的子树删掉。这样的空子树需要消耗一次操作。
- 如果某个子树的深度少于 $x$ 的子树最大深度，那么需要在某个时刻把这个子树删了，以控制深度是正确的，所以也需要一次操作。

于是 dp 一遍就行了。

```cpp
#include<iostream>
#include<vector>
#define int long long
using namespace std;
int n,k;
const int nr=5e5+10;
vector<int>v[nr];
int dep[nr],maxdep[nr],ans;
int f[nr];
void dfs(int x,int last)
{
    dep[x]=dep[last]+1;
    maxdep[x]=dep[x];
    int cnt=0;
    for(auto y:v[x])
        if(y!=last)
        {
            cnt++;
            dfs(y,x);
            maxdep[x]=max(maxdep[x],maxdep[y]);
            f[x]+=f[y];
        }
    for(auto y:v[x])
        if(y!=last)
        {
            if(maxdep[y]<maxdep[x])f[x]++;
        }
    if(cnt)f[x]+=k-cnt;
}
signed main()
{
    cin>>n>>k;
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
        v[y].push_back(x);
    }
    dfs(1,0);
    cout<<maxdep[1]-1<<" "<<f[1]<<endl;
    return 0;
}
```

---

## 作者：UKE_bound (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P13279)


---------
赛时想到了一种错误的贪心，就是一直等到高度够了再删，因为现在删了，后面还会长出来，但是，赛时太紧张没想出反例。
附：错误代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int v,u;
vector<int> t[500005];
int jd[500005],d[500005];
int m[500005],ans=0;
bool b[500005];
int depest=1;
void bfs(){
    queue<int> q;
    q.push(1);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i:t[u]){
            if(!d[i]){
                d[i]=d[u]+1;
                jd[d[i]]++;
                q.push(i);
                depest=max(depest,d[i]);
            }
        }
    }
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>k;
    d[1]=1;
    jd[1]=1;
    if(n>1){
	    for(int i=1;i<=n-1;i++){
	        cin>>u>>v;
	        t[u].push_back(v);
	        t[v].push_back(u);
	    }
	    bfs();
	}
    for(int i=2;i<=depest;i++){
        m[i]=jd[i-1]*k;
        ans+=m[i]-jd[i];
    }
    cout<<depest-1<<" "<<ans;
    return 0;
}
```
# 正片开始
那么，刚才的那个算法反例在哪里呢？  
考虑一种极端情况，一棵 $n+2$ 层的二叉树，根的左子树有 $n+1$ 层，右子树有 $n$ 层，则我的贪心会在最后把右子树的 $2^{n-1}$ 个叶子减掉，但最优解是一开始就把根的右儿子删掉，这样到后面就对了，只删一个。

所以我们应该怎么做呢？首先，我们可以发现，一个节点最多删一次，因为如果删两次那么第二次白删。

其次，我们发现一个子树如果不是最深的那么在开始的某个时刻就删一下来控制高度一定不会比超出深度后删叶子更差。

只要当前节点不是父亲的“长儿子”（子树最深的儿子），那么就要被删一次，不存在的节点当然就不是“长儿子”。

最终结论：直接分析 $T_{2}$，不是长儿子的节点就要被删。第一问就是 $T_{2}$ 的深度（这个结论非常显然）。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int v,u,ans;
vector<int> t[500005];
int dep[500005]/*深度*/,mondep[500005]/*最大儿子深度*/;
void dfs(int u,int f){
    for(const auto&v:t[u]){
        if(v!=f){
            dep[v]=dep[u]+1;
            dfs(v,u);
            mondep[u]=max(mondep[u],mondep[v]+1);
        }
    }
    if(!mondep[u])return;
    ans+=k;
    for(const auto&v:t[u]){
        if(v!=f&&mondep[v]+1==mondep[u]){
            ans--;
        }
    }
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n-1;i++){
        cin>>u>>v;
        t[u].push_back(v);
        t[v].push_back(u);
    }
    dfs(1,0);
    cout<<mondep[1]<<" "<<ans;
    return 0;
}
```
不抄题解一生平安。

---

## 作者：T7_Daniel (赞：2)

## 第一部分：一个错解贪心

考场上想了一个贪心被卡了。

第一个问题是显然的，输出最大深度即可。

对于第二个问题，有一个很好猜，但是错误的一个贪心：你可能会认为最后删比一步一步删更优，所以计算每一个节点的儿子数量，如果不是深度最大的，答案就要加上其儿子数量。

看起来没有问题，但是存在一个 `Hack` 数据：
```
5 3
1 2
1 3
1 4
2 5
```
正确答案应该是 $4$，即在时刻 $1$ 删除 $3,4$，在时刻 $2$ 删除 $2$ 的另外两个儿子 $6,7$，答案为 $4$。

但是你的贪心会输出 $11$，因为你认为后删除更优秀，于是你会多删除一堆。

这个贪心还是挂一个代码吧，后面有用：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=5e5+5;
vector<int> v[N];
int dep[N],num[N];//深度，儿子数量 
int n,k;

inline void dfs(int x,int fa){//处理num 
	dep[x]=dep[fa]+1;
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i];
		if(y==fa) continue;
		num[x]++;
		dfs(y,x);
	}
}

inline int read(){
	int s=0,f=1;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*f;
}

inline void write(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

signed main(){
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dep[0]=-1;
	dfs(1,0); 
	int maxn=0,sum=0;
	for(int i=1;i<=n;i++)
		maxn=max(maxn,dep[i]);
	for(int i=1;i<=n;i++)
		if(dep[i]!=maxn) sum+=(k-num[i]);
	cout<<maxn<<" "<<sum;
	return 0;
}

```

## 第二部分：正解

在考场上找到这个 `Hack` 数据的时候，可以继续猜贪心：如果两个节点距离叶子节点只差一层的话，等一会再删除一定比最后再删除更优。

为什么呢？显然的：高度有差距的话，这个点显然应该在之后删除，那么这个点在这次是不应该删除的，故而节约了一次操作。

即得证。

那我们该怎么改呢？这个其实也不难。

首先，我们定义 $hg$ 数组代表一个节点与其所在子树的最深叶子节点的距离。

也就是说，每一个叶子节点的 $hg$ 值为 $0$，向上的时候，父亲节点的处理需要将他的儿子们的 $hg$ 值加一再取最大值。

初始化每一个有儿子的节点会带来 $k$ 的代价，然后再思考减少的问题。

然后，我们判断父亲与儿子的 $hg$ 值是否差 $1$，如果是的话，我们可以换出来一个 $1$。

其余就都很好实现了，在原本的代码上改一下就好，很简单。

考场上都想出来了，但是当时时间只支持打一个小时 ，结果没打完...

赛后打的代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=5e5+5;
vector<int> v[N];
int dep[N];//深度 
int hg[N];//最大高度 
int n,k;
int ans;

inline void dfs(int x,int fa){//处理num 
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i];
		if(y==fa) continue;
		dep[y]=dep[x]+1; 
		dfs(y,x);
		hg[x]=max(hg[x],hg[y]+1);
	}
	if(hg[x]==0) return;
    ans+=k;
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i];
		if(y==fa) continue;
	    if(hg[x]==hg[y]+1) ans--;
	}
}

inline int read(){
	int s=0,f=1;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*f;
}

inline void write(int x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

signed main(){
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dfs(1,0);
	write(hg[1]);
	printf(" ");
	write(ans);
	return 0;
}
```

效率还是比较高的，你目前可以在第一页最优解找到我。

![](https://cdn.luogu.com.cn/upload/image_hosting/5lzsjedx.png)

---

## 作者：xixisuper (赞：2)

具有一定思维量的题。

## 思路

对于第一个问题的答案是显然的，如果我们认为根节点的深度是 $0$ 的话，那么第一个答案显然就是 $T_2$ 的深度。

> 证明是容易的，因为要想长到深度为 $t$，显然至少需要 $t$ 次生长，而假设中途不对 $T_1$ 进行修剪，你会得到一颗深度为 $t$ 的满 $k$ 叉树，而 $T_2$ 显然为这颗树的子集，则把所有修剪操作都放在最后是完全可行的。

由上面的证明不难想到一个修剪方法，那就是等到树最后长成之后再去修剪掉多余的树枝，不过这种方法很容易就能被证明是错误的，反例比较显然，考虑一颗完全二叉树，根节点的左子树是一颗深度为 $x$ 的满二叉树，而右子树是一颗深度为 $x-1$ 的满二叉树，只需在第一秒时把右子节点修剪掉即可，而并非在最后把第 $x$ 层的右半边节点修剪掉。

所以把能修剪的时间提前是一种减少修剪量的方式，于是我们必然是从上往下考虑每个点的修剪情况，考虑在树上进行 dfs，不难发现对于每一个节点我们所需要修剪的方式是完全一样的，具体来说：

- 设 $M$ 表示当前节点作为根节点的子树所需要的生长时间，显然 $M=\max\{\text{son}_M\}+1$，即子节点中最大的 $M$ 再 $+1$。
- 如果当前节点最终会有 $x$ 个子节点，则需要 $k-x$ 次修剪。
- 如果某个子节点需要 $t$ 的时间进行生长，且 $t<M-1$，证明我们需要在某一时刻把该子节点删除，然后再让其重新生长，故需要 $1$ 次修剪。

依照上述过程即可得到答案。

## 代码

仅展示核心 dfs 部分代码：

```cpp
const ll N=1e6+10;
vector<ll> e[N];
ll n,k,f[N],ans;
void dfs(ll u,ll fa){
	ll lz=e[u].size(),cnt=0;
	if(lz==0||(lz==1&&e[u][0]==fa)){f[u]=1;return;}
	ll mx=-1;
	for(ll i=0;i<lz;i++){
		if(e[u][i]==fa) continue;
		cnt++;
		dfs(e[u][i],u);mx=max(mx,f[e[u][i]]); 
	}
	f[u]=mx+1;
	for(ll i=0;i<lz;i++){
		if(e[u][i]==fa) continue;
		if(f[e[u][i]]!=mx) ans++;
	}
	ans+=k-cnt;
	return;
}
```

---

## 作者：shentianxing (赞：2)

很明显，最早时间是 $T_2$ 的深度，问题出在最小操作数。

最先想到的肯定是让 $T_1$ 生长完成后，在最后时刻切除每个需要切除的子树的根。但这样只能拿 $20$ 分。

当一个需要保留的子树中最深节点的深度小于树的深度时，不如先在某一时刻切除这个子树的根。举个最简单的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/nde6vzdv.png)

可以在 $1$ 时刻切除 $2$，这样在 $2$ 时刻正好长成目标状态。这样就比长成满二叉树后切除 $2$ 的子节点节约了一个节点。

我们可以先求出每个节点 $i$ 到根的距离 $dep2_i$ 和以 $i$ 为根的子树中节点的最大深度 $dep_i$。

$dfs$ 求解，对于每个节点 $u$，如果 $u$ 的子节点 $v$ 为根的子树中的节点最大深度（也就是 $dep_v$）比 $dep_u$ 小，我们就删去 $v$。如果 $u$ 是叶子，直接返回即可，因为我们已经处理过深度不同的问题，搜到每个叶子的时间都是最后一时刻，树不会再生长了。

AC 代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

vector<int> l[600000],l2[600000];
int dep[600000],fa[600000],dep2[600000];
int ans,maxdep;
int n,k;

void dfs(int x){
	dep2[x]=dep2[fa[x]]+1;
	for(int i=0;i<l[x].size();i++){
		if(l[x][i]!=fa[x]){
			l2[x].push_back(l[x][i]);
			fa[l[x][i]]=x;
			dfs(l[x][i]);
		}
	}
	int xdep=dep2[x];
	for(int i=0;i<l2[x].size();i++){
		xdep=max(xdep,dep[l2[x][i]]);
	}
	dep[x]=xdep;
	maxdep=max(maxdep,dep[x]);
}
	
void dfs2(int x){
	if(dep2[x]==dep[x]) return;
	if(dep2[x]!=maxdep) ans+=k;
	for(int i=0;i<l2[x].size();i++){
		if(dep[l2[x][i]]==dep[x]){
			ans--;
		}
		dfs2(l2[x][i]);
	}
}

signed main(){
	cin>>n>>k;
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		l[u].push_back(v);
		l[v].push_back(u);
	}
	dep2[0]=-1;
	dfs(1);
	dfs2(1);
	cout<<maxdep<<" "<<ans<<endl;
	return 0;
}
```

---

## 作者：XiaoYao789 (赞：1)

我说，第一问的答案应该是最大深度，证明如下：

在时刻 $t$，所有深度小于 $t$ 的节点会尝试生长子节点。因此，深度为 $d$ 的节点最早可以在时刻 $d$ 被创建。

`T2`中深度为 $d$ 的节点必须在`T1`中存在，且其父节点必须在`T1`中深度为 $d-1$。因此，`T1`必须生长到至少 $\operatorname{maxdep_1}$ 时刻才能覆盖`T2`的所有节点。

如果`T1`在时刻 $\operatorname{maxdep_1}$ 生长，那么所有`T2`的节点都可以被创建。

更早的时刻无法创建`T2`中深度为 $\operatorname{maxdep_1}$ 的节点。

所以最早满足条件的时刻是 $\operatorname{maxdep_1}$。

评测机说，哼，你做出来第一问算什么，还有第二问呢。

我说，第二问我们最后统一删除不满足条件的子节点（源自神牛 @T7_Daniel）

评测机说，不对，`Hack`数据（还是源自 @T7_Daniel）：
```
5 3
1 2
1 3
1 4
2 5
```

我说，那我每次如果两个节点距离叶子节点只差一层的话，等一会再删除一定比最后再删除更优。证明如下：

因为每个多余子节点只需删除一次，且越早删除越能减少后续无用生长。

评测机哭了，因为我的代码可以`AC`。

代码：
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long LL;
const int N=5e6+10,M=1e7+10;
int n,m,idx,h[N],e[M],ne[M],dep[N],maxdep[N];
LL res;
void add(int a,int b){
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void dfs(int u,int father){
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(j==father) continue;
        dep[j]=dep[u]+1;
        dfs(j,u);
        maxdep[u]=max(maxdep[u],maxdep[j]+1);
    }
    if(!maxdep[u]) return;
    res+=m; //全删除需要的代价
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(j==father) continue;
        if(maxdep[j]==maxdep[u]-1) res--; //高度有差距的话，这个点显然应该在之后删除，那么这个点在这次是不应该删除的，故而节约了一次操作(源自T7_Daniel)
    }
}
int main(){
    cin.tie(0)->ios::sync_with_stdio(0);
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i=1;i<n;i++){
        int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    dfs(1,-1);
    cout<<maxdep[1]<<" "<<res<<endl;
    return 0;
}
```

---

## 作者：tuntunQwQ (赞：1)

对于第一问，因为 $T_1$ 每时刻可以向下扩展一层，所以至少要等到 $T_2$ 中最深的节点长出来，求出它与 $1$ 号节点的距离就是答案。

对于第二问，我们可以等到最深的节点长出来后再 dfs 这个满 $k$ 叉树，逐个把多余的子树删掉。感觉好像很对？毕竟样例就是这样删的。但我们容易找到反例：

![](https://cdn.luogu.com.cn/upload/image_hosting/izn8ffrp.png)

假设 $k$ 为 $2$，则在 dfs 到 $3$ 号点的时候，我们会删除它的两个多余的儿子。但是如果在 $3$ 号节点第一次长出来的时候就立马删掉它，等到 $4,5$ 号节点长出来的时候，$3$ 号节点又会长出来，并且因为此时 $T_1$ 已经符合要求，所以 $3$ 号节点没有时间再长出两个多余的儿子。这样，我们从原来的 $2$ 次删除就变成了 $1$ 次删除。也就是说，我们可以找到一个时刻删掉这个节点让它重新生长。

设 $u$ 号节点的深度为 $d_u$，以 $u$ 号节点为根的子树中最深的节点的深度为 $f_u$，则对于 $u$ 号节点的所有儿子节点 $v$，如果 $f_u>f_v$，就代表这个子节点的子树深度要小于某个兄弟节点的子树深度（可以参考上图，设 $u=1$，$v=3$，显然以 $3$ 为根的子树没有以 $2$ 为根的子树深）。我们可以在以后得某一时刻删掉 $v$，使得到最后多余的儿子尽可能少。具体的，在 dfs 到 $u$ 时，若 $f_u>f_v$，使答案加一。

最后，在 dfs 到 $u$ 时，如果在 $T_2$ 中它的儿子节点数量小于 $k$，就需要在最后删掉那些多余的儿子节点。在 dfs 时记录儿子节点的数量并更新答案。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
int n,k,h[N],e[N],nxt[N],idx,cut,d[N],f[N];
void add(int a,int b){
	e[++idx]=b,nxt[idx]=h[a],h[a]=idx;
}
void dfs(int u,int fa){
	f[u]=d[u];
	for(int i=h[u];i;i=nxt[i]){
		int v=e[i];
		if(v==fa)continue;
		d[v]=d[u]+1;
		dfs(v,u);
        f[u]=max(f[u],f[v]);
	}
    int cnt=k;
	for(int i=h[u];i;i=nxt[i]){
		int v=e[i];
		if(v==fa)continue;
        if(f[u]>f[v])cut++;
        cnt--;
	}
    if(f[u]!=d[u])cut+=cnt;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n-1;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	cout<<f[1]<<' '<<cut<<'\n';
	return 0;
}
```

---

## 作者：chenyizhen (赞：1)

## 题目：

简明题意：找将 $T_{1}$ 变化成 给出的 $T_{2}$ 的时刻和最小操作数。

## 思路：

### Part.1

很轻松的可以发现我们所求的**时刻即为树的深度**，在遍历树时我们可以得到。

### Part.2

接下来我们来解决操作数，题目的条件就是两棵一样的树，由于我们可以随意编号且根节点确定，那么我们只需要处理树的形状。

一个贪心的想法是：将 $T_{1}$ 长成 $T_{2}$ 后删掉多余的子树的根节点。

![样例](https://cdn.luogu.com.cn/upload/image_hosting/mb0u6rkz.png)

可是细想一下上图的操作次数我们发现可以，按照上述贪心想法，图中树需进行两次删除操作，但实际上我们可以只删一次就达到要求。

问题就出现在我们可以在树生长过程中就进行删除操作，使树出现“参差不齐” 的形状来达到目标形状。

那么什么时候删除才最优呢？~~毋庸置疑~~是 **$th_{now}-th_{v}$ 最优**（$th_{i}$ 表示 $Treeheight$, 即**以 $i$ 为根节点的子树的高度**。）。

代码实现时注意：

- 叶子结点 $th_{i}$ 为 0，不需要处理。
- 正常情况下删除节点 `ans+=k`。
- 当最优时刻时删会导致对于每一个需删节点对 $ans$ 的贡献减一。

最后附上代码。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
inline void read(int &a){
	char ch;int f=1,k=0;ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}
	a=k*f;
}
struct edge{
	int start,end;
}e[N];
int head[N],cnt;
inline void add(int u,int v){
	e[++cnt].end=v;
	e[cnt].start=head[u];
	head[u]=cnt;
}
int n,k;
int fa[N],dep[N],vis[N],th[N],ans;
void dfs(int now,int fath){
	fa[now]=fath,dep[now]=dep[fath]+1;
	for(int i=head[now];i;i=e[i].start){
		int v=e[i].end;
		if(v==fath) continue;
		dfs(v,now);
		th[now]=max(th[now],th[v]+1);
	}
	if(!th[now]) return ;
	ans+=k;
	for(int i=head[now];i;i=e[i].start){
		int v=e[i].end;
		if(v==fath) continue;
		if(th[v]==th[now]-1) ans--;
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	read(n),read(k);
	for(int i=1;i<=n-1;i++){
		int u,v;
		read(u),read(v);
		add(u,v);add(v,u);
	}
	dfs(1,0);
	cout<<th[1]<<' '<<ans;
	return 0;
}
```

---

## 作者：the_Short_Path (赞：0)

$Update\ 2025/7/25$：修正了一处表述错误。
****
## 对于第一问
首先看一棵树：
![](https://cdn.luogu.com.cn/upload/image_hosting/xlfp7wa8.png)
对于这棵树，答案为 $2$。显然答案就是树的最大节点深度。

那么对于 `Subtask 1` 和 `Subtask 2`，此题答案就是树的最大节点深度和 $0$（不用删其它节点了）。
## 对于第二问
回到上文中的树，图中有 $5$ 个点会被删除，但答案并不是 $5$。最优的方案为：
- 第 $1$ 个时刻，删去 $6$ 号点。
- 第 $2$ 个时刻，删去 $8,9,10$ 号点。

综上答案为 $4$。

我们记点 $i$ 在其子树中与之最远的点的距离为 $maxd_i$，则我们可以在剩余 $maxd_i$ 时刻时删去该点。而 $maxd_1$ 就是第一问的答案（即树的直径）。
## 代码思路
可以通过 dfs 遍历一遍树。

假设遍历到了点 $i$，则对于所有 $j\in \operatorname{son}(i)$，若 $j$ 的深度小于 $i$ 的深度 $-1$（就是 $j$ 的子树内与 $j$ 距离最大的点与点 $i$ 的距离非最大），则可以在 $maxd_j-maxd_i$ 时刻删去点 $j$。

可以不用维护深度数组，~~还能省内存~~。
# 正解
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k, d[500005], ans; // d 数组即为 maxd 数组
vector <int> G[500005];
void dfs(int u, int fa) {
    for (auto v : G[u]) if (v != fa) dfs(v, u), d[u] = max(d[u], d[v] + 1);
    if (d[u]) { // 特判是叶子结点
        ans += k;
        for (auto v : G[u]) if (v != fa && d[v] == d[u] - 1) ans--; // 条件都满足就可以删了
    }
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for (int i = 1, u, v; i < n; i++) cin >> u >> v, G[u].push_back(v), G[v].push_back(u); // 注意要双向存边
    dfs(1, -1);
    cout << d[1] << " " << ans << endl;
    return 0;
}
```

---

## 作者：CMY2013 (赞：0)

## Part 1
首先，我们在读完题面后会发现，~~根本不会~~其实目标是让 $T_1$ 和 $T_2$ 两棵树相等（因为每个节点的父节点都相等）。首先考虑第一问，很容易就会发现最短时间就是 $T_2$ 的深度。然后考虑第二问，因为要求最少次数，所以考虑使用数学或贪心求解。然后再观察数据范围，发现是 $O(n)$ 的复杂度。则选择用贪心求解（ ~~我才不会告诉你我的数学不好呢~~ ）。

## Part 2
考虑贪心。我们发现$T_2$的每个子树，都可以采用一种万能方法来求解在这一个子树中需要几次裁剪才能达到目标的形状，那就是先构造一组满 k 叉树，再通过裁剪来修饰其形状即可。则裁剪的次数为 $\sum_{x\in{T_2}} k-son_{x}$ ，其中 $son_x$ 表示 x 的子节点的个数。这个公式也很好理解，因为每次删除都会删除一个子树，所以只需统计有几个需要删去的父节点即可。

## Part 3
我们发现上面的算法有一定的漏洞，若一棵子树的叶子节点并不属于 $T_2$ 的最底层（也就是说这棵子树并没有触到底）。则按上面的算法，先让它自由生长，然后再裁剪，会发现需要裁剪很多次。这时我们考虑一种优化，我们可以在一个时刻裁剪掉整个子树，然后再让它自由生长，这样就可以保证在结束时子树的高度不会太高，从而减少裁剪的次数。

## Part 4
综上所述，我们只需要一次树形遍历，求出树的高度，并分情况算出一个子树的裁剪次数，累加起来便是答案。

## Code
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans=0,dep[500010];
vector<int> vec[500010];

int dfs(int u,int fa)
{
	int maxn=0;
	for(auto v:vec[u])
	{
		if(v!=fa)
		{
			dep[v]=dfs(v,u);
			maxn=max(maxn,dep[v]);
		}
	}
	int sum=0;
	for(auto v:vec[u])
	{
		if(v!=fa)
		{
			if(dep[v]==maxn) sum++;
		}
	}
	ans+=(maxn==0?0:(m-sum));
	return maxn+1;
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie();
	cout.tie();
	cin>>n>>m;
	int u,v;
	for(int i=1;i<n;i++)
	{
		cin>>u>>v;
		vec[u].push_back(v);
		vec[v].push_back(u);
	}
	cout<<dfs(1,0)-1<<' '<<ans;
	return 0;
}
```

---


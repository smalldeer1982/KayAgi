# [GCJ 2012 #2] Swinging Wild

## 题目描述

你正站在丛林中的一个岩架上，你的真爱正站在沼泽对岸的另一个相似的岩架上。沼泽中满是蛇、鳄鱼和各种令人不快的生物。幸运的是，丛林树冠上方悬挂着许多藤蔓，更幸运的是，你设法抓住了这些藤蔓中的第一根（见下图）。树冠高度恒定，两个岩架的高度也与树冠一致。藤蔓仅仅是从树冠某些点垂下来的线段，长度各不相同。

如果你是小说中的英雄，你会疯狂地荡着藤蔓大喊大叫，在某个时刻松手飞跃空中，抓住另一根藤蔓，再次荡起，如此反复，最终你会把你的真爱拥入怀中。不幸的是，你并不是小说英雄，如果你尝试这么做，可能唯一能做好的只有大喊大叫。

你的计划要谨慎得多。你会先在手中的藤蔓上荡起来，但不是松手，而是去抓住另一根藤蔓。然后你会慢慢小心地爬上原来的藤蔓，使你手中抓住的新藤蔓变成水平状态——要么拉到它的全部长度，要么拉到两根藤蔓之间的距离，以较小者为准。然后你会休息片刻，再次荡起来，如此反复。注意，你并不一定要抓住荡到的第一根藤蔓，你可以选择荡得更远，抓住更远的藤蔓。同样，你可以在荡动时爬上当前的藤蔓，以缩短你与藤蔓根部的距离。实际上，这意味着你可以抓住任何在你荡动时经过的藤蔓。注意，荡动时你不会向下爬藤蔓。

还有一点你与小说英雄不同，那就是在开始这场相当冒险的行动前，你想知道按照上述规则，你是否真的有可能到达对岸。这正是本题要你回答的问题。


## 说明/提示

**样例说明**

在第一个样例中，你手中的第一根藤蔓距离其挂点有 3 个单位长度。你可以大幅荡动，越过第二根藤蔓，刚好抓住第三根。下图展示了初始状态，你能够到达任何根部在红色区间内的藤蔓：

![](https://cdn.luogu.com.cn/upload/image_hosting/2v8e9qcl.png)

休息后，你顺着第三根往下爬，顺着第一根往上爬，发现自己距离起点 3 个单位长度，正好碰到树冠并抓住第一和第三根藤蔓。现在你松开第一根，再次荡动，又刚好到达终点岩架，你的真爱在那等你。下图展示了你抓住第三根并爬到第一根根部后的状态。你同样可以到达任何红色区间内的藤蔓：

![](https://cdn.luogu.com.cn/upload/image_hosting/rk4gi3a8.png)

在第二个样例中，你第一次荡动无法到达第三根藤蔓，所以只能抓住第二根。然而，第二根距起点 4 个单位长度，即使你顺着第一根往上爬，也只能荡 1 个单位长度——显然不足以到达第三根藤蔓。因此你连第三根都到不了，更别说对岸了。你还是去找别的路（或新的真爱）吧。

在第三个样例中，注意如果你只在第一根藤蔓上荡动，是无法碰到第二根的——你必须在荡动时爬上一些（幸运的是，你可以这么做）才能抓住第二根。记住，你只能在荡动时向上爬，不能向下（因为向上藤蔓是拉紧的可以承重，向下则是自由荡动的）。第四个样例中，即使你能到第二根藤蔓，但它太短，无法到达终点岩架。

**限制条件**

- $0 < d_i, l_i, D \leq 10^9$
- $T \leq 30$
- $d_i < d_{i+1}$
- 起始时你抓住第一根藤蔓，$d_0 \leq l_0$
- $d_{N-1} < D$

**测试集 1（5 分，结果可见）**

- $1 \leq N \leq 100$

**测试集 2（9 分，结果隐藏）**

- $1 \leq N \leq 10000$
- 所有测试用例的藤蔓总数不超过 60000

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
4
3
3 4
4 10
6 10
9
3
3 4
4 10
7 10
9
2
6 6
10 3
13
2
6 6
10 3
14```

### 输出

```
Case #1: YES
Case #2: NO
Case #3: YES
Case #4: NO```

# 题解

## 作者：Temp113 (赞：6)

## Solution

用一个数组 $g$ 记录藤蔓 $i$ 能增加的最远距离。初始 $g_1 = d_1$。

枚举一个 $j$（$1 \le j \le i - 1$），若 $g_j \ge d_i - d_j$（即藤蔓 $j$ 能增加到藤蔓 $i$，$d_i - d_j$ 为 $i,j$ 间的距离），则：

$$g_i = \max(g_i, \min(l_i, d_i - d_j))$$

解释：不会向下爬藤蔓，上一次的距离为 $d_i - d_j$，则下一次的距离一定不超过 $d_i - d_j$。当然，如果藤蔓没有这么长，就只能到最底端 $l_i$。

最后，若存在一个 $i$，使得 $d_i+g_i \ge D$（藤蔓 $i$ 能到 $D$），输出 ``YES``。否则，输出 ``NO``。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 10005;
int t;
int n, d[N], l[N], s;
int g[N];
inline int min_(int aa, int bb){
	return aa < bb ? aa : bb;
}
inline int max_(int aa, int bb){
	return aa > bb ? aa : bb;
}
inline void solve(){
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> d[i] >> l[i];
	cin >> s;
	for(int i = 1; i <= n; i++) g[i] = 0;
	g[1] = d[1];
	for(int i = 2; i <= n; i++) for(int j = 1; j <= i - 1; j++) if(g[j] >= d[i] - d[j]) g[i] = max_(g[i], min_(l[i], d[i] - d[j]));
	for(int i = 1; i <= n; i++){
		if(d[i] + g[i] >= s){
			cout << "YES\n";
			return ;
		}
	}
	cout << "NO\n";
	return ;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> t;
	for(int kk = 1; kk <= t; kk++){
		cout << "Case #" << kk << ": "; 
		solve();
	}
	return 0;
}
```

---


# [GDCPC 2024] 不等式

## 题目背景

数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>

## 题目描述

给定 $n,m$，以及 $m$ 个形如 $a_{x_i}\ge a_{y_i}+a_{z_i}(1 \le i \le m)$ 的条件。问是否有一组**正整数** $(a_1,a_2,\cdots,a_n)$ 满足所有条件，并且 $a_1+a_2+\cdots+a_n \le 10^{9}$。如果有，输出 $a_1+a_2+\cdots+a_n$ 的最小值；如果无解，输出 $-1$。

## 说明/提示

和最小的解为 $(3,1,2,1,1)$，和为 $8$。

## 样例 #1

### 输入

```
5 2
1 2 3
3 4 5```

### 输出

```
8```

# 题解

## 作者：fish_love_cat (赞：5)

无语了，这个特判赛时是不是坑了一车人罚时。

还要 GDCPC 居然没有签到诶？

---

把每个数字看成点，每组关系告诉你某个点的两个前置，直接建图。

有环显然不可做，那么可以放到一个 DAG 上考虑。

于是跑一个拓扑，做 DAG DP 即可。

然后你会发现挂了两个点。

神秘数据给你爆 `int` 了，然后回看题目条件：

> 并且 $a_1+a_2+\cdots+a_n \le 10^{9}$。

特判这里，过了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>ve[200005];
map<int,bool>mp[200005];
struct fish{
    int b,c;
};
vector<fish>qwq[200005];
int f[200005];
int ans,siz;
int n,m;
int ret[200005];
void tp(){
    queue<int>q;
    for(int i=1;i<=n;i++)
    if(!f[i])q.push(i);
    while(!q.empty()){
        int x=q.front();
        q.pop();siz++;
        for(int i=0;i<ve[x].size();i++)
        if(--f[ve[x][i]]==0)q.push(ve[x][i]);
        ret[x]=1;
        for(int i=0;i<qwq[x].size();i++)
        ret[x]=max(ret[x],ret[qwq[x][i].b]+ret[qwq[x][i].c]);
        ans+=ret[x];
    }
}
signed main(){
    cin>>n>>m;
    while(m--){
        int x,y,z;
        cin>>x>>y>>z;
        qwq[x].push_back({y,z});
        if(!mp[y][x])ve[y].push_back(x),f[x]++,mp[y][x]=1;
        if(!mp[z][x])ve[z].push_back(x),f[x]++,mp[z][x]=1;
    }
    tp();
    if(siz!=n||ans>1e9)puts("-1");
    else cout<<ans;
    return 0;
}
```

---

## 作者：Ashankamiko (赞：2)

# 题目简述
### 题意
给定 $n,m$，以及 $m$ 个形如 $a_{x_i}\ge a_{y_i}+a_{z_i}$ 的条件，求是否存在一组正整数 $(a_1,a_2,\cdots,a_n)$ 同时满足 $m$ 个条件，如果有，输出整组序列和的最小值，如果无解或答案大于 $10^9$，输出 $-1$。
### 思路
像 $a_{x_i}\ge a_{y_i}+a_{z_i}$ 这种条件就很符合拓扑排序的要求。根据这些关系，我们连 $y$ 和 $x,z$ 的边，$z$ 和 $x,y$ 连边，然后进行拓扑排序。

设点 $u$ 的入度为 $In_u$。

一个点被访问的次数越多，说明在这个点上做出的约束越多，所以可以通过 $v$ 的访问次数计算 $f_v$ 的值，并进行状态转移，$f_i$ 初始值为 $1$。状态转移方程为 $f_v = \max(f_u+f_w,f_v)$。注意，$w$ 表示题目中的 $z$。

一个数据有解，当且仅当拓扑排序后，每个点 $In_i$ 的值均为 $0$，否则就是无解。

最后答案就是 $\sum_{i=1}^n f_i$，然后特判答案是否小于等于 $10^9$，如果同时满足这两个条件，输出这个答案，否则输出 $-1$。
## [AC 代码](https://www.luogu.com.cn/record/229713654)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define in cin
#define out cout
#define int long long
#define ios ios::sync_with_stdio(false), in.tie(nullptr), out.tie(nullptr)
const int N = 2e5 + 5;
struct node {
	int v, w;
};
vector <node> e[N];
int n, m, In[N], f[N];

signed main() {
	ios;
	in >> n >> m;
	queue <int> q;
	while (m--) {
		int u, v, w;
		in >> u >> v >> w;
		e[v].push_back({u, w}), e[w].push_back({u, v}), In[u] += 2; //建图
	}
	for (int i = 1; i <= n; i++) {
		if (In[i] == 0)
			q.push(i);
		f[i] = 1;
	}
	while (!q.empty()) { //拓扑排序
		int u = q.front();
		q.pop();
		for (auto [v, w] : e[u]) {
			In[v]--, f[v] = max(f[u] + f[w], f[v]); //状态转移
			if (In[v] == 0)
				q.push(v);
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans += f[i];
		if (In[i] || ans > 1e9) { //无解
			out << -1;
			return 0;
		}
	}
	out << ans;
	return 0;
}
```
感谢：@[vector_STL_](https://www.luogu.com.cn/user/1390387)。

---

## 作者：Heyg_future (赞：1)

# P13359 [GDCPC 2024] 不等式
## [题目](https://www.luogu.com.cn/problem/P13359)

## solution
呃，相信各位看到这个题都会想到差分约束，但是显然，本题差分约束看似不是那么可做，~~可能我太菜了~~，因为题目要求和最小，要证明起来很麻烦，因为每个数都有所约束，于是考虑拓扑排序。

对于每一个 $a_x$，若要求它最小，那么对应的 $a_y+a_z$ 也要尽量小，因为 $a_x=a_y+a_z$ 且三者均为正整数，所以可以瞎猜一下，若某个 $a_i$ 没有约束那么它为 $1$ 最优。

证明。若某个 $a_i$ 没有受其它数的约束，且其值不为 $1$，那么如果其它数的取值均为最优，和为 $s$，那么答案为 $s+a_i$。显然 $s+a_i>s+1$，又因为 $a_i$ 取值不受约束，显然 $a_i$ 贪心地取 $1$ 是最优的。

那么这就显而易见。将原来的不等式建立一张图，入度为 $0$ 的数赋值为 $1$，每一个 $a_x$ 都对应若干个指向它的二点对，代表约束，然后跑拓扑就可以了。

证明。若某个 $a_i$ 没有受其它数的约束，令其已被约束的最小值为 $t$，且其值不为 $t$，那么如果其它数的取值均为最优，和为 $s$，那么答案为 $s+a_i$。显然 $s+a_i>s+t$，又因为 $a_i$ 取值不受约束，显然 $a_i$ 贪心地取 $t$ 是最优的。

那么结果显而易见，实现非常容易。我是这样做的。一张图存一个点的约束，另一个图用来跑图。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define LL long long
#define add(u,v,w) g[u].push_back({v,w}) 
#define ga(u,v) gg[u].push_back(v)
#define pr pair<LL,LL>
#define a first
#define b second
using namespace std ;
const LL N=2e5+500 ;
LL n,m,rd[N],f[N],ans,cd[N],vis ;
vector <pr> g[N] ;
vector <LL> gg[N] ;
queue <LL> q ;
void topo () { 
	for (LL i=1;i<=n;i++) {
		if (!rd[i]) q.push (i),f[i]=1;
	}
	if (!q.size ()) {
		cout<<-1 ;
		return ;
	}
	LL u ;
	while (q.size ()) {
		u=q.front () ; q.pop () ;
		vis++;
		for (LL v:gg[u]) {
			rd[v]--;
			if (!rd[v]) q.push (v) ;
		}
		for (pr vi:g[u]) {
			f[u]=max (f[u],f[vi.a]+f[vi.b]) ;
		}
	}
	for (LL i=1;i<=n;i++) {
		ans+=f[i] ;
		if (!f[i]) ans ++ ; 
	}
	if (ans<=1e9 && vis==n)
		cout<<ans ;
	else cout<<-1 ;
}
int main () {
	cin>>n>>m ;
	for (LL i=1,x,y,z;i<=m;i++) {
		cin>>x>>y>>z ;
		add (x,y,z) ;
		ga (y,x) ;
		ga (z,x) ;
		rd[x]+=2 ;
	}
	topo () ;
	return 0;
} 
```
### 注意。
要开 `long long`。不然在判断和的时候可能会溢出。为了保险，可以在计算过程中判断溢出。

拓扑排序中有环是不可以的，所以统计每个点入队次数判环即可。

这样，即可通过此题。

---

## 作者：MonKeySort_ZYczc (赞：1)

> 并且 $a_1+a_2+\cdots a_n\le10^9$。
## 思路流程
图论痕迹比较明显，考虑直接连边。  

把每个数看做图中的点，对于每组限制连单向边。  
容易发现如果存在环必定无解，也就是说有解情况是 DAG。  
跑一遍拓扑排序就行。  

中间处理比较麻烦，我同时建了反向边简化处理，稍微方便一点点。  

本题最阴的地方在于文章最开头那句话。  
记得除了判断环之外还要特判小于等于 $10^9$，小心点特判时不行赶紧跳出，说不定会不会爆 ```long long```。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
int n,m,a[N],sze,ind[N];
vector<int>v[N],v2[N];
inline void topo()
{
	stack<int>st;
	for(int i=1;i<=n;i++) if(!ind[i]) st.push(i),a[i]=1;
	while(!st.empty())
	{
		int x=st.top();st.pop();sze++;
		//cout<<x<<'\n';
		for(int i=0;i<v[x].size();i+=2) a[x]=max(a[x],a[v[x][i]]+a[v[x][i^1]]);
		if(a[x]>1000000000) break;
		for(int i=0;i<v2[x].size();i++) 
		{
			ind[v2[x][i]]--;
			if(!ind[v2[x][i]]) st.push(v2[x][i]);
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;cin>>x>>y>>z;
		v[x].push_back(y);v[x].push_back(z); 
		v2[y].push_back(x);v2[z].push_back(x);
		ind[x]+=2;
	}
	topo();
	int ans=0;
	for(int i=1;i<=n;i++) ans+=a[i];
	if(ans>1000000000||sze<n) ans=-1;
	cout<<ans;
}

```

---

## 作者：vector_STL_ (赞：0)

# 题解：P13359 \[GDCPC 2024] 不等式

## 题目描述

给定 $n$ 个正整数变量 $a_1, a_2, \ldots, a_n$ 和 $m$ 个形如 $a_{x_i} \ge a_{y_i} + a_{z_i}$ 的约束条件。要求判断是否存在满足所有约束的正整数解，且这些数的和不超过 $10^9$。如果存在，求出最小的和；否则输出 $-1$。

## 解题思路

### 问题分析

这个问题可使用**拓扑排序**的算法完成。

证明如下：

- 1\. 每个不等式 $a_x \ge a_y + a_z$ 表明 $a_x$ 至为 $a_y$ 和 $a_z$ 的和。
- 2\. 由于要求正整数解，最小的可能值就是 $a_x = a_y + a_z$.
- 3\. 由 #1 可推出：对于每个不等式 $a_x \ge a_y + a_z$，可表示为两条由 $y$ 和 $z$ 分别指向 $x$ 的有向边，权值为该不等式的另一个加数。
- 4\. 对于 #2 可以选择在 #3 的基础上建立一个有向无环图并由入度为 $0$ 的点开始进行动态规划，设变量 $u$ 表示当前点的序号，变量 $v$ 和 $w$ 分别表示由 $u$ 可到达的点及权值，则状态转移方程为：

$$
dp_{u}= \max (dp_{v},dp_{u}+w)
$$

### 算法选择

1. **图建模**：
   - 将每个变量视为图中的一个节点。
   - 对于约束 $a_x \ge a_y + a_z$，建立从 $y$ 和 $z$ 到 $x$ 的关系。

2. **拓扑排序**：
   - 初始化 $dp$ 数组的所有元素的值为 1（最小正整数）。
   - 进行拓扑排序并处理 $dp$ 数组。

3. **环检测**：
   - 如果图中存在环，则无解（会导致无限递增）。
   - 如果任何节点的值超过 $10^9$，则无解。

**时间复杂度**：$O(n + m)$，拓扑排序的时间复杂度。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct d{
	int v,w;
};
const int N=1e6+5;
vector<d> e[N];//建图
int f[N],in[N];

signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		e[v].push_back({u,w});
		e[w].push_back({u,v});//处理图的边
		in[u]+=2;//处理入度
	}
//正常的拓扑排序
	queue<int>q;
	for(int i=1;i<=n;i++){
		f[i]=1;
		if(in[i]==0)q.push(i);
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(auto [v,w]:e[u]){
			f[v]=max(f[v],f[u]+f[w]);//动态规划状态转移方程
			in[v]--;
			if(in[v]==0)q.push(v);
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(in[i]>0||f[i]>1e9){//处理有环的情况和答案越界
			cout<<-1<<endl;
			return 0;
		}
		ans+=f[i];
	}
//尤其提醒！！二次检查答案越界
	if(ans>1e9){
		cout<<-1<<endl;
		return 0;
	}
	else cout<<ans<<endl;
	return 0;
}
```
## 小tips
拓扑排序可以处理有环的情况，对于此题表示为审查 $in[i]$ 是否为 $0$ ，还可以表示为检验遍历到的结点数量是否等于结点的总数。

---

## 作者：lzx111218 (赞：0)

# P13359 [GDCPC 2024] 不等式
[题目传送门](https://www.luogu.com.cn/problem/P13359)
## 思路

十年 OI 一座场空，不开 `long long` 见祖宗。

拓扑排序，还结合了一点贪心。

将每个约束条件 $(a_x \ge a_y + c)$ 与依赖关系 $z$ 依赖于 $x$ 的逻辑关系表示出来。

用拓扑排序检测环：若存在环，约束无法满足，输出 $-1$。

无环则按拓扑顺序处理节点，初始每个变量值为 $1$（正整数最小值），按约束更新变量值为其依赖变量之和的最小值。最后计算总和，若超过 $10^9$ 输出 $-1$。

~~不得不说特判是真恶心。~~
### Code
```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
#define speed ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
int n,m;
signed main(){
    speed
    cin >> n >> m;
    vector<vector<pair<int, int>>> v(n + 1);
    vector<vector<int>> vv(n + 1);
    vector<int> vvv(n + 1, 0);
    for(int i = 0; i < m; i++){
        int x, y, z;
        cin >> x >> y >> z;
        v[x].emplace_back(y, z);
        vv[y].push_back(x);
        vv[z].push_back(x);
        vvv[x] += 2;
    }
    queue<int> q;
    for(int i = 1; i <= n; i++){
        if(vvv[i] == 0){
            q.push(i);
        }
    }
    vector<int> t;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        t.push_back(u);
        for(int v : vv[u]){
            vvv[v]--;
            if(vvv[v] == 0){
                q.push(v);
            }
        }
    }
    if(t.size() != n){
        puts("-1");
        return 0;
    }
    vector<int> a(n + 1, 1);  
    for(int u : t){
        for(auto [y, z] : v[u]){
            if(a[u] < a[y] + a[z]){
                a[u] = a[y] + a[z];
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        ans += a[i];
        if(ans > 1e9){
            puts("-1");
            return 0;
        }
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：xIAOFu_Qwq (赞：0)

# P13359 [GDCPC 2024] 不等式

[题目传送门](www.luogu.com/problem/P13359)

## 题意

给定$M$个限制，每个限制形如 $A_{x_i}\ge A_{y_i}+A_{z_i}$ 的形式。

求一个长度为 $N$ 的数组 $A$，使 $\sum A_i$ 最小，求这个最小值。若 $\sum A_i > 10^9$ 或无解，输出`-1`。

## 题解

明显的图论，首先想到建图：$y_i,z_i$ 向 $x_i$ 连边，但是 $y_i,z_i$ 是成对出现，我们需要区分一下。

再用连边区分显然不现实，考虑建立 $M$ 个辅助节点，对于每一个限制，使 $y_i,z_i$ 向辅助节点连边，再将辅助节点向 $x_i$ 连边。

之后就拓扑排序做图上 dp，如果有环就无解。

设 $dp_i$ 表示 $\min\ A_i$。

则
$$
dp_v =
\begin{cases}
\min dp_u, &  x \leq n \\
\sum dp_u, &  x > n
\end{cases}
$$
答案就是 $\sum_{i=1}^n dp_i$。

## 关键代码片段

```cpp
queue<int>q;
for(int i = 1;i <= n+m; i++){
    if(rd[i]==0)q.push(i),val[i]=1;
}
while(q.size()){
    int u = q.front();
    q.pop();
    for(auto v:mp[u]){
        if(v<=n)val[v]=max(val[v],val[u]);
        else val[v]+=val[u];
        rd[v]--;
        if(!rd[v])q.push(v);
    }
}
int ans = 0;
for(int i = 1; i <= n; i++){
    if(val[i])ans+=val[i];
    else{
        cout << -1;
        return 0;
    }
}
```

---

## 作者：sqh0012 (赞：0)

### 题意：

给定 $n$ 个变量和 $m$ 个形如 $a_{x_i} \ge a_{y_i} + a_{z_i}$ 的不等式约束，要求：
1. 判断是否存在一组正整数解；
2. 若存在，求所有变量和的最小值；
3. 若和可能超过 $10^9$ 或无解，输出 $-1$。

---

### 解法：

在此之前，你可能想过这三种做法：

线性规划？它求的是实数解，不保证整数性，时间复杂度也是指数级；

贪心？你可以按某种顺序确定 $a_i$，但确定 $a_x$ 时需要知道 $a_y$ 和 $a_z$ 的值，但 $y$ 和 $z$ 可能又依赖于其他变量。这无法处理复杂依赖关系，也不可取；

动态规划？每个 $a_i$ 的依赖关系形成的是 DAG 而非重复子结构，缺乏明确的阶段划分。

观察每个不等式 $a_x \ge a_y + a_z$ 表明 $a_x$ 的值依赖于 $a_y$ 和 $a_z$，这种依赖关系天然形成有向图的边。

如果 $y$ 和 $z$ 的值增大，$x$ 必须相应增大，则为正权边。

而多个不等式会形成依赖链，就需要拓扑排序。

当出现循环依赖时（如 $a \ge b$，$b \ge a$），则为正权环，无解。

所以我们可以这样做：
1. 将每个变量视为图中的一个节点；
2. 每个不等式 $a_x \ge a_y + a_z$ 转化为两条有向边：
   - $y \rightarrow x$，权值为 $a_z$；
   - $z \rightarrow x$，权值为 $a_y$。

用拓扑排序处理 DAG 的最长路，由于要求正整数解，初始时设所有 $a_i=1$，需要处理可能的正权环（无解情况），还要确保所有 $a_i \le 10^9$。

时间复杂度 $O(n+m)$，空间复杂度 $O(n+m)$。


```cpp
// g 邻接表,d 入度数组,a 存储每个节点的值,s 存储总和
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2e5+5;
vector<pair<int,int>>g[N];
int d[N],n,m;
ll a[N],s;
queue<int>q;
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    cin>>n>>m;
    for(int i=1,x,y,z;i<=m;i++)
	{
        cin>>x>>y>>z;
        g[y].push_back({x,z});
        g[z].push_back({x,y});
        d[x]+=2;
    }
    for(int i=1;i<=n;i++)a[i]=1;
    for(int i=1;i<=n;i++)if(!d[i])q.push(i);
    while(!q.empty())
	{
        int u=q.front();q.pop();
        for(auto e:g[u])
		{
            int v=e.first,w=e.second;
            a[v]=max(a[v],a[u]+a[w]);
            if(!--d[v])q.push(v);
        }
    }
    for(int i=1;i<=n;i++)
	{
        if(d[i]>0||a[i]>1e9){cout<<-1;return 0;}
        s+=a[i];
    }
    cout<<(s>1e9?-1:s);
}
```

---


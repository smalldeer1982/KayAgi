# [GCJ 2011 #3] Dire Straights

## 题目描述

你正在玩一款纸牌游戏，每张牌上都写有一个整数。

在游戏中，你会得到一些牌——你的手牌。然后你需要将手牌中的牌分组成“顺子”。顺子是一组牌，这组牌上的数字是连续的；例如三张牌 $\{3, 4, 5\}$，或者单独一张牌 $\{7\}$。你获得的奖金等于最短顺子的长度。如果你没有任何牌，则无法组成顺子，因此你获得 $0$ 元。

你将会得到若干组测试数据，每组数据描述了你手中的牌。请你计算每组测试数据中你最多能获得多少奖金。

## 说明/提示

**样例解释**

第 1 组，你有 $1$ 到 $10$ 共 $10$ 张牌，可以组成一个长度为 $10$ 的顺子，获得 $10$ 元。

第 2 组，你可以组成两个顺子 $\{101, 102, 103, 104, 105, 106\}$ 和 $\{103, 104\}$，获得 $2$ 元。但更优的做法是组成 $\{101, 102, 103, 104\}$ 和 $\{103, 104, 105, 106\}$，获得 $4$ 元。

第 4 组，数字为 $9$ 的牌只能单独成顺子，因此只能获得 $1$ 元。

第 3 组，你没有任何牌，因此获得 $0$ 元。你不能无中生有获得奖金。

**数据范围**

- $1 \leq T \leq 100$
- 牌上的数字范围为 $1$ 到 $10000$

**小数据范围（4 分，测试点 1 - 可见）**

- $0 \leq N \leq 10$
- 时间限制：3 秒

**大数据范围（12 分，测试点 2 - 隐藏）**

- $0 \leq N \leq 1000$
- 时间限制：6 秒

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
10 1 2 3 4 5 10 9 8 7 6
8 101 102 103 104 105 106 103 104
0
5 1 2 3 4 9```

### 输出

```
Case #1: 10
Case #2: 4
Case #3: 0
Case #4: 1```

# 题解

## 作者：Real_tiandi (赞：2)

题目需要最大化最短顺子的长度。考虑贪心。

1.当 $n=0$ 时，$ans=0$。\
2.当 $cnt_{a_i}>cnt_{a_i-1}+cnt_{a_i+1}$ 时，显然一定存在一些 $a_i$ 牌无法与相邻牌形成连续序列，因此它们必须单独成顺子（长度为 $1$），因此直接将 $ans$ 设为 $1$。\
3. 从左到右扫描连续序列，当发现当前数字比下一个数字多时（$cnt_{a_i}>cnt_{a_i+1}$），那么多出的部分（$cnt_{a_{i}} - cnt_{a_i+1}$）必须由序列中前面的牌来与 $a_i$ 形成顺子，然后才能重新接上 $a_i+1$ 形成顺子。

然后就可以先对数组排序，再使用双指针维护一段连续区间，设 $l$ 为左指针，$i$ 为右指针，若 $cnt_{a_i}<cnt_{a_i+1}$，则 $i$ 增大，否则用这一段生成顺子，保存最小值。

复杂度 $O(Tn\log{n})$。

```
#include<bits/stdc++.h>
using namespace std;
int cnt[10005],a[1005];
int main(){
	int t;
	cin>>t;
	for(int k=1;k<=t;k++){
		for(int i=1;i<=10005;i++){
			cnt[i]=0;
		}
		int n;
		cin>>n;
		if(n==0){
			cout<<"Case #"<<k<<": "<<0<<endl;
			continue;
		}
		for(int i=1;i<=n;i++){
			cin>>a[i];
			cnt[a[i]]++;
		}
		sort(a+1,a+n+1);
		n=unique(a+1,a+n+1)-a-1;
		int l=1,ans=1005;
		for(int i=1;i<=n;i++){
			if(cnt[a[l]]<=0){
				l=i;
			}
			if(cnt[a[i]-1]+cnt[a[i]+1]<cnt[a[i]]){
				ans=1;
				break;
			}
			if(cnt[a[i]+1]<cnt[a[i]]){
				int x=cnt[a[i]]-cnt[a[i]+1];
				int p=0,q,fl=1;
				for(int j=l;j<=i;j++){
					cnt[a[j]]-=x;
					if(fl&&cnt[a[j]]>=0){
						ans=min(ans,i-j+1);
						fl=0;
					}
					if(!p&&cnt[a[j]]>0){
						l=j;
						p=1;
					}
				}
			}
		}
		cout<<"Case #"<<k<<": "<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：__CuSO4__ (赞：1)

### 题解

要使得最短“顺子”的长度最大，第一眼认为是二分，但发现 `check` 函数不好写，就想到贪心。

可以考虑把所有牌从小到大排序，从前往后枚举每一张牌，对于当前的牌：

- 如果找不到能接上的“顺子”，就自己新建一个；
- 如果找得到，就接到**能接上并且长度最小**的一个“顺子”接上。

其实这种策略很好理解，因为我们要让最短的长度最大，就要接到长度最小的一段上。

在代码实现时，只需要记录之前“顺子”的结束位置的值与其长度，直接扫一遍就能更新了。

最后所有“顺子”的长度最小值就是答案了，时间复杂度 $O(TN^2)$。

### 代码：
``` cpp
#include <bits/stdc++.h>
using namespace std;

int T, n, a[1005];
int ed[1005], len[1005], cur;
//ed表示结束位置的值，len表示顺子的长度

int main()
{
    cin >> T;
    for (int t = 1; t <= T; t++)
    {
        cur = 0;//多测记得重置
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> a[i];
        sort(a + 1, a + 1 + n);
        for (int i = 1; i <= n; i++)
        {
            int minn = 1e9, pos;
            for (int j = 1; j <= cur; j++)
                if (ed[j] == a[i]-1 && len[j] < minn) //找到能接上并且长度最小的一段
                    minn = len[j], pos = j; 
            if (minn == 1e9) cur++, ed[cur] = a[i], len[cur] = 1; //没找到就新建一段
            else ed[pos] = a[i], len[pos]++; //否则就接到长度最小的一段上
        }
        int ans = 1e9;
        for (int i = 1; i <= cur; i++) ans = min(ans, len[i]);
        printf("Case #%d: %d\n", t, ans==1e9?0:ans);
    }
    return 0;
}
```

---

## 作者：Reply_ (赞：0)

## 题解：P13379 \[GCJ 2011 #3] Dire Straights

看似吓人的题目，其实是水题。

当枚举到数 $i$ 时，维护到 $i$ 仍然保**持连续的所有顺子的长度**，出于贪心，我们要尽量将 $i$ 往**最短的顺子**拼接。

- 当顺子的个数大于等于 $i$ 的个数时，往最短的若干个顺子拼上，其余的顺子扔掉并记录答案。
- 当顺子的个数小于 $i$ 的个数时，拼上所有的顺子，剩下的 $i$ 就只能开单独的顺子了。

当数 $i$ 没有顺子能够与其连接，把当前所有顺子扔掉并记录答案。

代码太丑了，需要的私我。

---


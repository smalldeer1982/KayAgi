# EERT

## 题目背景

顺着走是不可能的！这辈子都不可能！

## 题目描述

### 本题仅允许使用 C++ 语言提交。

小 S 有一颗有 $N$ 个节点的树，现在他邀请小 T 参观这棵树的每一个节点。

因为顺着走太无聊，所以小 S 想找到一个参观顺序，使得没有相邻两个参观的点在树上是相连的，并且每个节点恰好参观一次。

你是小 S 雇佣的导游，所以这个问题就抛给了你。

当然，如果没有解决办法，那就说明小 S 不想带小 T 参观，你也就不用管了。

**形式化的讲**，给定一颗 $N$ 个节点的树，你需要找到一条这棵树的补图的哈密顿路径。

### 实现细节

在本题中，你不需要，也不能实现 main 函数和从标准输入输出流中输入输出。

本题中所有数组下标均从 $0$ 开始。

你需要实现下面一个函数：
```cpp
std::vector<int> eert(int N,std::vector<int> f)
```

- 本题保证每个测试点仅会调用 $1$ 次该函数。
- $N$ 是这个树的节点个数，保证 $1\leq N\leq 10^7$。
- 树上点的编号从 $1$ 到 $N$。
- $f$ 是一个长度为 $N-1$ 的数组，其中 $f_i$ 表示点 $i+2$ 和点 $f_i$ 之间有条边，保证 $1\leq f_i \leq i+1$。
- 你需要返回一个大小为 $N$ 或者为 $0$ 的数组（`vector`）。具体的：如果有解，返回一个长度为 $N$ 的数组，表示你的答案；如果无解，返回一个空的数组。
- 你返回的数组设为 $ans$，你需要保证 $ans$ 是一个 $1-N$ 的排列，下标从 $0$ 开始，且对于 $1\leq i<N$，$ans_{i-1}$ 与 $ans_i$ 之间没有连边。 

## 说明/提示

**本地测试**

你可以在代码末尾加入如下代码测试（提交时请删去或注释掉）。

```cpp
#include<bits/stdc++.h> 
using namespace std;
namespace CHECKER{
	int N;
	vector<int> f;
	vector<int> ans;
	vector<int> vis;
	bool checker(){
		if(ans.size()!=N) return 0;
		for(int i=0;i<N;i++) if(ans[i]<=0||N<ans[i]) return 0;
		vis.resize(N,0);
		for(int i=0;i<N;i++){
			if(vis[ans[i]-1]) return 0;
			vis[ans[i]-1]=1;
		}
		int u,v;
		for(int i=1;i<N;i++){
			u=ans[i-1];
			v=ans[i];
			if(u!=1&&f[u-2]==v||v!=1&&f[v-2]==u) return 0;
		}
		return 1;
	}
	int main(){
		scanf("%d",&N);
		f.resize(N-1);
		for(int i=0;i<N-1;i++){
			scanf("%d",&f[i]);
		}
		ans=eert(N,f);
		if(ans.empty()){
			printf("NO\n");
			return 0;
		}
		if(checker()) printf("YES\n");
		else printf("Wrong answer\n");
		for(int i=0;i<ans.size();i++){
			printf("%d ",ans[i]);
		}
		printf("\n");
		return 0;
	}
}
int main(){
	return CHECKER::main();
}
```

其中，输入输出格式为题面中的【输入格式】和【输出格式】。

**本题有捆绑测试**。

- 对于 Subtask #$0$（$10$pts）：$N\leq10$
- 对于 Subtask #$1$（$15$pts）：$N\leq20$
- 对于 Subtask #$2$（$5$pts）：保证 $f_i=1$。
- 对于 Subtask #$3$（$10$pts）：保证 $f_i=i+1$。
- 对于 Subtask #$4$（$20$pts）：保证 $N\leq10^5$。
- 对于 Subtask #$5$（$40$pts）：无特殊限制。

对于 $100\%$ 的数据：$1\leq N\leq10^7,1\leq f_i\leq i+1$。

本题 SPJ 需要使用不超过 $200$MB 的内存和 $300$ms 的时间，这是无法避免的，请注意你的空间和时间，与交互库相加不能超过对应的限制。

## 样例 #1

### 输入

```
5
1 1 1 1```

### 输出

```
No```

## 样例 #2

### 输入

```
7
1 1 2 2 3 3```

### 输出

```
Yes
1 4 5 6 7 2 3```

# 题解

## 作者：Cute__yhb (赞：5)

## 思路

### #0

枚举全排列，检验合法性。

### #2

菊花图。

可以发现，不管怎么走，都无法走到根节点，所以无解。

### #3

链。

对于所有深度为奇数的点，两点间必定没有连边，可以直接走。

偶数位同理。

所以可以先走偶数位，再走奇数位。

特判 $n\le 3$ 时无解即可。

### #5

设最大深度为 $dep$。

对于 $dep\ge3$ 时，有以下解法。

对于同一深度的点，两两间必定没有连边，可以直接走。

把同一深度的点看成一个点，做法同链。

当 $dep=2$ 时，树为菊花，无解。

当 $dep=3$ 时，显然只能先走根，再走第三层，最后走第二层。

只要保证第二层最先走到点不为第三层最后一个点的父亲即可。

所以必须满足第二层点数不为 $1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define p_q priority_queue
#define pb push_back
#define mk make_pair
#define pii pair<int,int> 
#define ve vector
#define endl '\n'
#define fi first
#define se second
#define INF 0x3f3f3f3f
#define lowbit(x) (x&(-x))
int dep[10000005],mx,cnt[10000005],cnt1[10000005],a[10000005],fa[105][105];
int k[10000005],vis[25],an[25],m,ans_[25],is_ans;
ve<int>ans;
void dfs(int x){
	if(is_ans) return ;
	if(x==m+1){
		is_ans=1;
		for(int i=1;i<=m;i++){
			ans_[i]=an[i];
		}
		return ;
	}
	if(x==1){
		for(int i=1;i<=m;i++){
			vis[i]=1;
			an[x]=i;
			dfs(x+1);
			vis[i]=0;
		}
	}else{
		for(int i=1;i<=m;i++){
			if(!fa[an[x-1]][i]&&!vis[i]){
				vis[i]=1;
				an[x]=i;
				dfs(x+1);
				vis[i]=0;
			}
		}
	}
}
std::vector<int> eert(int N,std::vector<int> f){
	for(int i=2;i<=N;i++){
		dep[i]=dep[f[i-2]]+1;
		cnt[dep[i]]++;
		mx=max(mx,dep[i]);
	}
	if(N<=10){//直接暴力
		m=N;
		for(int i=2;i<=m;i++){
			fa[i][f[i-2]]=1;
			fa[f[i-2]][i]=1;
		}
		dfs(1);
		if(!is_ans) return ans;
		for(int i=1;i<=m;i++) ans.pb(ans_[i]);
		return ans;
	}
	if(mx==1){
		return ans;
	}
	if(mx<=2){
		for(int i=1;i<mx;i++){
			if(cnt[i]==1){
				return ans;
			}
		}
		for(int i=1;i<=mx;i++){
			k[i]=0;
			cnt1[i]=cnt[i];
			cnt[i]+=cnt[i-1];
		}ans.pb(1);
		for(int i=2;i<=N;i++){
			a[cnt[dep[i]-1]+cnt1[dep[i]]]=i;
			cnt1[dep[i]]--;
		}
		if(cnt[2]==1){
			int _;
			for(int j=cnt[2-1]+1;j<=cnt[2];j++){
				ans.pb(a[j]);
				_=a[j];
			}
			for(int j=cnt[1-1]+1;j<=cnt[1];j++){
				if(a[j]!=f[_-2]) ans.pb(a[j]);
			}
			ans.pb(f[_-2]);
			return ans;
		}
		for(int i=2;i<=mx;i++){
			for(int j=cnt[i-1]+1;j<=cnt[i];j++){
				if(f[a[j]-2]!=a[cnt[i-2]+1]){
					k[i]=a[j];
					break;
				}
			}
		}
		for(int i=mx;i>=1;i--){
			for(int j=cnt[i-1]+1;j<=cnt[i];j++){
				if(a[j]!=k[i]) ans.pb(a[j]);
			}
			if(k[i]) ans.pb(k[i]);
		}
	    return ans;		
	}
	else{
		for(int i=1;i<=mx;i++){
			cnt1[i]=cnt[i];
			cnt[i]+=cnt[i-1];
		}
   		for(int i=2;i<=N;i++){
			a[cnt[dep[i]-1]+cnt1[dep[i]]]=i;
			cnt1[dep[i]]--;
		}     
        for(int i=1;i<=mx;i+=2){
			for(int j=cnt[i-1]+1;j<=cnt[i];j++){
				if(a[j]!=k[i]) ans.pb(a[j]);
			}
		}
        ans.pb(1);
		for(int i=2;i<=mx;i+=2){
			for(int j=cnt[i-1]+1;j<=cnt[i];j++){
				ans.pb(a[j]);
			}
		}
		return ans;
	}
}
```

---

## 作者：sheep65536 (赞：5)

题意可以容易的转化为：构造长度为 $n$ 的排列 $p$，使得相邻的两位在树上不相邻。

考虑将树按深度分层，分层后有以下性质：
- 同一层的点不相邻。
- 不相邻的层的点不相邻。

我们称最深的点的深度为 $d_{max}$，根据上述性质，在 $3<d_{max}$ 时，可以将深度奇偶划分，以 $2,4,6,8.....,1,3,5,7,....$ 的顺序将对应深度的点排列即为合法方案。

$d_{max}=1$ 就是 $n=1$，排列 $\{1\}$ 即为合法构造。

当 $d_{max}=2$ 时，显然无解，因为第一层（根）和第二层（根的儿子）是直接相连的，在把 $2$ 层放好后无法插入根。

当 $d_{max}=3$ 时，因为 $1,2$ 两层无法相邻，所以只有 $1,3,2$ 来构造，其中 $2,3$ 两层相邻，所以我们需要保证 $2,3$ 层相邻处不相邻，统一发现当且仅当 $2$ 层的点数至少有两个，只要 $2$ 层开始的点不是 $3$ 层最后一个点的父亲，就是合法方案。

---

## 作者：chenbs (赞：4)

本题解中设根节点的深度为 $1$，最大深度为 $m$。

容易想到一个贪心：先把**深度为偶数**的都走一遍，再把**深度为奇数**的都走一遍，这样显然不会走过相邻的节点。

~~开心地以为 T1 很水，然后 WA 了一片。~~

注意到当 $m \le 3$ 时，这个策略才会出错，所以加上一堆特判就能过了：

+ $m=1$：答案显然。

+ $m=2$：菊花图，无解。

+ $m=3$：若根节点有 $1$ 个儿子，那么是也是菊花图，无解；否则，依次走过第 $1$ 层、第 $3$ 层、第 $2$ 层（第 $3$ 层最后一个节点的父亲放最后）即可。

注意：题目保证 $f_i \le i+1$，所以直接扫一遍就行，不需要搜索，否则可能会超时。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e7+5;
int d[M],fn[M],lst[M],in[M],mdep;
vector<int> ans;
vector<int> eert(int N, vector<int> f) {
	if(N==1) return ans.push_back(1), ans;
	d[1]=1;
	for(int i=2; i<=N; i++) d[i]=d[f[i-2]]+1, mdep=max(mdep,d[i]);
	for(int i=2; i<=N; i++) in[f[i-2]]++;
	for(int i=1; i<=N; i++) lst[i]=fn[d[i]], fn[d[i]]=i;

	if(mdep==2) return ans;
	if(mdep==3) {
		if(in[1]==1) return ans;
		else {
			ans.push_back(1);
			int tmp;
			for(int i=fn[3]; i; i=lst[i]) ans.push_back(i), tmp=f[i-2];
			for(int i=fn[2]; i; i=lst[i]) if(i!=tmp) ans.push_back(i);
			ans.push_back(tmp);
			return ans;
		}
	}

	for(int i=2; i<=mdep; i+=2)
		for(int j=fn[i]; j; j=lst[j])
			ans.push_back(j);
	for(int i=1; i<=mdep; i+=2)
		for(int j=fn[i]; j; j=lst[j])
			ans.push_back(j);
	return ans;
}
```

---

## 作者：liuchuliang666 (赞：2)

先放一张这个蒟蒻被疯狂卡常 60pts 甚至尝试切 C++98 导致大量 CE 的记录……

![这个蒟蒻被疯狂卡常 60pts 甚至尝试切 C++98 导致大量 CE 的记录](https://cdn.luogu.com.cn/upload/image_hosting/h39nh2fv.png "这个蒟蒻被疯狂卡常 60pts 甚至尝试切 C++98 导致大量 CE 的记录")

构造的部分其实不是很难，我们可以建图 BFS 一遍对每一个结点黑白染色，其中相邻的结点染色不同，那么我们只要先把黑走完，再把白走完就行了。

其中有一个特殊的地方，就是最终方案中黑白对接的那个地方，对于这个问题，我的思路是随便找一个叶子（认为给出的树无根）$s$，将他周围的点（开一个 `bitset`）标为禁用，再遍历一遍找一个没被禁用的点 $t$ 即可。

手玩几下可以发现，上面的算法只有在 $n \le 2$ 和给的树为菊花时找不到这样的 $t$，特判即可。

然后就有了一开始那张图片……

然后就是长达半小时的优（luan）化（gao）。事实上，建图和 BFS 都是不重要的，因为这个给数据的方式相当于是按拓扑序给的，所以我们从小到大将 `f[i]` 的颜色取反就能得到 $(i + 2)$ 的颜色。同样的原因，点 $n$ 其实就是我们要的 $s$，这样的话那个禁用数组也不用刻意标出，只要他不是 $n$ 的父亲都是没被禁用的。

最后放一下代码（其实也没必要开 C++98 和 `register`，都是一开始为了卡常搞的）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define eb emplace_back
#define rep(i, l, r, ...) for (register int i = (l), ##__VA_ARGS__; i <= (r); ++i)
#define per(i, r, l, ...) for (register int i = (r), ##__VA_ARGS__; i >= (l); --i)
typedef vector<int> vi;
const int MAXN = 1e7 + 10, inf = 1e7, mod = 998244353, MAXV = MAXN << 2;
bool MST;
vi res;
bitset<MAXN> col;
int n, s, t, idxl, idxr, d[MAXN];
bool MED;
vi eert(int N, vi f)
{
    if (N == 1) return res.eb(1), res;
    n = N, res.resize(n), idxl = 0, idxr = n - 1;
    rep(i, 0, n - 2) col[i + 2] = !col[f[i]];
    s = n;
    rep(i, 1, n - 1) if (i ^ f[n - 2] && col[i] ^ col[s])
    {
        t = i;
        break;
    }
    if (!s || !t) return {};
    per(i, n, 1) if (col[i] == col[s] && i ^ s) res[idxl++] = i;
    else if (col[i] == col[t] && i ^ t) res[idxr--] = i;
    res[idxl] = s, res[idxr] = t;
    return res;
}
#ifndef ONLINE_JUDGE
#include <bits/stdc++.h>
using namespace std;
namespace CHECKER
{
int N;
vector<int> f;
vector<int> ans;
vector<int> vis;
bool checker()
{
    if (ans.size() ^ N) return 0;
    for (int i = 0; i < N; i++)
        if (ans[i] <= 0 || N < ans[i]) return 0;
    vis.resize(N, 0);
    for (int i = 0; i < N; i++)
    {
        if (vis[ans[i] - 1]) return 0;
        vis[ans[i] - 1] = 1;
    }
    int u, v;
    for (int i = 1; i < N; i++)
    {
        u = ans[i - 1];
        v = ans[i];
        if (u ^ 1 && f[u - 2] == v || v ^ 1 && f[v - 2] == u) return 0;
    }
    return 1;
}
int main()
{
    scanf("%d", &N);
    f.resize(N - 1);
    for (int i = 0; i < N - 1; i++)
    {
        scanf("%d", &f[i]);
    }
    ans = eert(N, f);
    if (ans.empty())
    {
        printf("NO\n");
        return 0;
    }
    if (checker())
        printf("YES\n");
    else
        printf("Wrong answer\n");
    for (int i = 0; i < ans.size(); i++)
    {
        printf("%d ", ans[i]);
    }
    printf("\n");
    return 0;
}
} // namespace CHECKER
int main()
{
    return CHECKER::main();
}
#endif
```

---

## 作者：XingYueLi (赞：1)

## 题目概括

现有一棵有 $N$ 个节点的树，将树转化为补图进行遍历，每个节点只能走过一次。这里的补图可以简单理解为：每一对不相连的点之间加上一条边，然后把原树的所有边删掉。

## 思路

### 无解情况

1. 若树中有一个节点与所有其它结点相连（即它的度为 $N-1$），这棵树就是一棵星形树，转化为补图后，这个节点不与任何其他节点相连，所以无解。

2. 除此之外的所有树，补图都是连通且足够稠密，必然存在哈密尔顿路径，唯一的不可行情形就是星形树。

### 有解情况

任选一个根（例如节点 1），对每个节点计算其深度 $\operatorname{dep}(v)$。若 $\operatorname{dep}(v)$ 为偶数则把 $v$ 放入集合 $A$，否则放入集合 $B$。则可以进行推导：

1. 在补图中，集合 $A$ 内的每一个节点之间都存在边。因为它们要么深度相同，要么深度差 > 2，在原图中一定没有边。集合 $B$ 同理。

2. 在集合 $A$ 中任意选取一个叶子节点（设为 $a$），该节点一定与一个集合 $B$ 的节点（设为 $b$）相连。

3. 综上，遍历顺序是：先把集合 $A$ 内除了 $a$ 以外的节点都遍历一遍（因为集合 $A$ 内节点互相连接），再遍历 $a$，再遍历 $b$，最后把集合 $B$ 内除了 $b$ 以外的节点都遍历一遍（因为集合 $B$ 内节点互相连接）。

4. 特判：$n=1$ 时，输出 $1$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> eert(int N, vector<int> f){
    //特判
    if (N == 1) {
        return vector<int>(1, 1);
    }

    // parent[i] 为节点 i 的父亲（i 从 1 开始），du[i] 为度数，col[i] 为奇偶颜色
    vector<int> parent(N + 1, 0);
    vector<int> du(N + 1, 0);
    vector<bool> col(N + 1, 0); // 0 表示偶数，1 表示奇数

    for (int i = 2; i <= N; ++i) {
        int p = f[i - 2];
        parent[i] = p;
        ++du[i];
        ++du[p];
        col[i] = 1 - col[p];       // 与父亲颜色相反
    }

    // 检测是否为星形树
    int maxDeg = 0;
    for (int i = 1; i <= N; ++i) {
        if (du[i] > maxDeg) maxDeg = du[i];
    }
    if (maxDeg == N - 1) {
        return vector<int>();
    }

    // 任意取一条度为 1 的叶子 leaf
    int leaf = -1;
    for (int i = 2; i <= N; ++i) {
        if (du[i] == 1) {
            leaf = i;
            break;
        }
    }

    int leafParent = parent[leaf];
    int leafColor  = col[leaf];

    // 在异色集合中寻找一个不等于 leafParent 的节点 q
    int q = -1;
    for (int i = 1; i <= N; ++i) {
        if (col[i] != leafColor && i != leafParent) {
            q = i;
            break;
        }
    }

    // 构造答案
    vector<int> ans;
    ans.reserve(N);

    // 先放同色但不是 leaf 的节点
    for (int i = 1; i <= N; ++i) {
        if (col[i] == leafColor && i != leaf) {
            ans.push_back(i);
        }
    }
    // 再放 leaf
    ans.push_back(leaf);
    // 放选中的 q
    ans.push_back(q);
    // 最后放剩余的异色节点（除 q）
    for (int i = 1; i <= N; ++i) {
        if (col[i] != leafColor && i != q) {
            ans.push_back(i);
        }
    }

    return ans;
}
```

---

## 作者：_Trangle_ (赞：0)

上来先特判 $N=1$ 的情况，答案为 $1$。

所以接下来假设 $N\ge2$。

然后发现，菊花一定不合法。我们画一下它的反图就能发现菊花中心是一个孤立的点。从该点出发，到不了其它点；从其他点出发，到不了该点，故该反图不存在哈密顿路径。

然后该树一定不是菊花。

然后就比较好做了。我们约定，根结点深度为 $0$。由于深度奇偶性相同的点一定没有连边，可以构造如下的遍历序：`{深度为奇数的点}{深度为偶数的点}`。

为什么可以这么做呢？我们可以证明：在非菊花图上，一定存在一对深度为奇数的点和深度为偶数的点，他们之间没有连边。

:::info[证明]{open}
如果树的深度超过 $2$，那么我们可以找到一个深度为 $3$ 的点，它与根结点没有边相连。

否则，由于特判掉了菊花图，则此情况下。树第 $1$ 层的结点数一定大于 $1$。

我们一定能找到一个第 $1$ 层的点，在第 $1$ 层一定有一个点与它没有边相连。
![](https://cdn.luogu.com.cn/upload/image_hosting/iqzoisn8.png)
:::
### Code
```cpp
#include <bits/stdc++.h>

std::vector<int> eert(int N, std::vector<int> f) {
	if (N == 1) return std::vector({1});
	std::vector<int> dep(N+1, 0), deg(N+1, 0);
	for (int i = 0; i != f.size(); i++) {
		dep[i+2] = dep[f[i]]+1;
		deg[i+2]++, deg[f[i]]++;
	}
	if (*std::max_element(deg.begin(), deg.end()) == N-1) return std::vector<int>();

	std::vector<int> ans0, ans1;
	for (int i = 1; i <= N; i++) {
		if (dep[i]&1) ans0.emplace_back(i);
		else ans1.emplace_back(i);
	}

	for (auto it = ans0.begin(); it != ans0.end(); it++) {
		if (deg[*it] < ans1.size()) {
			std::swap(*it, ans0.back()); //找到一个点不与所有深度为偶数的点相邻。
			break;
		}
	}
	auto checke = [&](int u, int v) {
		return (u != 1 && f[u-2] == v) || (v != 1 && f[v-2] == u);
	};
	for (auto it = ans1.begin(); it != ans1.end(); it++) {
		if (!checke(*it, ans0.back())) {
			std::swap(*it, ans1.front()); //找到一个点不与最后深度为基数的点相邻。
			break;
		}
	}
	for (auto it: ans1) ans0.emplace_back(it);
	return ans0;
}
```

---


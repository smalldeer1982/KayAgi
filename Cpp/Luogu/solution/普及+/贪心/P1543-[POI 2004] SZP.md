# [POI 2004] SZP

## 题目背景

一班班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 十分可爱。

## 题目描述

班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 作为某日的值日班长，在自习课上管理着 $n$ 名同学。除了她以外每一名同学都监视着另一名同学。现在班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 需要选择尽量多的同学去搬卷子和答题卡，且使得对于这些同学中的每一名同学，至少有一位监视她的同学没有被选中。问班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 最多可以选择多少同学。

由于班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 太可爱了，所以没有人监视她，也可以认为她的学号是 $0$。

如果一个人没有被监视，那么她就不能被选择。


## 说明/提示

对于 $100\%$ 的数据，$1\le k,a_k\le n\le 10^6$。

## 样例 #1

### 输入

```
6
2
3
1
3
6
5
```

### 输出

```
3```

# 题解

## 作者：wyd_is_JOKER (赞：5)

# [原题链接](https://www.luogu.com.cn/problem/P1543)

可以用贪心 + 拓扑排序做。

首先我们可以发现，入度为 $0$ 的点**必然**不能被选，我们先将所有点标记为不选，将入度为 $0$ 的点加入队列中。

由贪心的思想可得到，我们为了被选的点更多，我们要将不选的点所指向的点选上，也就是选上他的儿子。

证明：若点 $i$ 确定为不选，若 $ak[i]$ 不选也只能提供一个点被选（$ak[i]$ 指向的点），故 $ak[i]$ 选上不会差。

若所有指向 $i$ 的点均选，则 $i$ 只能是不选。

由于图可能不连通还可能有**环**。我们只需要最后剩下的环从任意处切开即可。

由于我们在拓扑排序的过程中在环上做过标记，我们只要考虑没做过标记的一段，即有 $i$ 标记为不选，$ak[i]$ 标记也为不选，显然我们要标记 $ak[i]$ 为选。

这个[时间复杂度](https://www.luogu.com.cn/record/124244347)，极限擦边。

献上我~~丑陋~~的代码。
```cpp
#include<bits/stdc++.h>//代码已AC，亲测有效。
#define LL long long
#define Max(a,b) ((a)>(b) ? (a):(b))
#define Min(a,b) ((a)<(b) ? (a):(b))
using namespace std;
const int N=1000000;
int n;
int ak[N+5];
int in[N+5];
bool choose[N+5],vis[N+5];
queue<int>Q;//STL大法好
int ans;
int Read()
{
    int sum=0;
    char c=getchar();
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='9') sum=sum*10+c-'0',c=getchar();
    return sum;
}

int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) ak[i]=Read(),in[ak[i]]++;
    for (int i=1;i<=n;i++) if (!in[i]) Q.push(i);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        vis[u]=1;
        if (choose[u])
        {
            in[ak[u]]--;
            if (!in[ak[u]]) Q.push(ak[u]);
        }
        else
        {
            if (!choose[ak[u]])
            {
                choose[ak[u]]=1;
                ans++;
                Q.push(ak[u]);
            }
        }
    }
    for (int i=1;i<=n;i++) if (!vis[i])//找剩下的环
    {
        vis[i]=1;
        int j=i;
        while (!vis[ak[j]])
        {
            if (!choose[j]&&!choose[ak[j]]) ans++,choose[ak[j]]=1;
            j=ak[j];vis[j]=1;
        }
    }
    printf("%d\n",ans);
    return 0;//完美收官QwQ
}
```


---

## 作者：zac2010 (赞：5)

由于每个特工只会监视一个特工，我们判断出这是一颗基环树。

基环树的题目我们往往可以从序列以及树去入手。

考虑序列怎么做。此时存在显然的贪心策略，让 $1,3,5,7,\dots$ 这些位置的特工参与行动。对这个贪心加以分析，不难把它搬到基环树上去贪心——能选 $x$，就不去放弃 $x$ 选 $a_x$。因为放弃 $x$ 一定不优于选 $x$。

但是这里还是介绍一下比较常见的 $\text{DP}$。考虑题目给出的关系是一颗树该怎么做。钦定 $f_{u,0/1}$ 为：$u$ 本身选/不选时，它的子树中最多有多少个特工参与行动。

转移：$f_{u,0}\leftarrow\max(f_{v,0},f_{v,1})$；$f_{u,1}$ 在 $f_{u,0}$ 的基础上还要避免所有子节点都参与行动的情况。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
const int N = 1e6 + 10, INF = 1e9;
int n, p, ans, flag, a[N], fa[N], f[N][2];
vector<int> rt, e[N];
int find(int u){return fa[u] == u? u : fa[u] = find(fa[u]);}
void dfs(int u, int pos){
	f[u][0] = f[u][0] = 0; int mx = -INF;
	for(int &v: e[u]){
		dfs(v, pos), f[u][0] += max(f[v][0], f[v][1]);
		mx = max(mx, f[v][0] - max(f[v][0], f[v][1]));
	}
	f[u][1] = f[u][0] + (u != pos || !flag) * mx + 1;
}
int main(){
	scanf("%d", &n);
	FL(i, 1, n) fa[i] = i;
	FL(i, 1, n){
		scanf("%d", &a[i]);
		if(find(a[i]) != find(i))
			e[a[i]].emplace_back(i), fa[i] = a[i];
		else rt.emplace_back(i);
	}
	for(const int &u: rt){
		p = u, flag = 0, dfs(p, a[p]);
		int mx = max(f[p][0], f[p][1]);
		flag = 1, dfs(u, a[p]);
		ans += max(mx, f[p][0]);
	}
	printf("%d\n", ans); 
	return 0;
}
```


---

## 作者：Melo_DDD (赞：4)

拓扑好题，记录一下。

# 题目描述

如果没人监视你，你就不能去了（即入度是零）。

# 题目实现

这种限制关系一定是拓扑，考虑在板子上添加什么。

首先是开个数组记录是否被选中，那么他被选中的充要条件是他的入度不为零（就是有人监视他）。

然后就正常的拓扑，但是还会有独立的环，所以要判环。

考虑一个环内最多去几个人，答案是 $\lfloor \frac{n}{2} \rfloor$ 个（这个环里有 $n$ 个人），我们举个例子：

甲监视乙，乙监视丙，丙监视丁，丁监视戊，戊监视甲，那么我们不妨考虑让甲去；那么没人监视乙，乙去不了；丙能去；丁不能去；戊比较特殊，为了让甲能去，他得留下来。所以能去 $2$ 个人，即 $\lfloor \frac{5}{2} \rfloor$ 个。

最后有个比较难理解的点，我也琢磨了好久：

拓扑中的队列是干什么的？它**既不是存可以去的人也不是存不可以去的人**，它只是存我们是否考虑过这个点用的。

完美，细节不多，直接上代码：

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define IOS ios :: sync_with_stdio(0) ;cin.tie (0) ;cout.tie (0)
using namespace std ;
const int N = 1e7 + 7 ;
int n ,to[N] ,ans ,in[N] ;
bool vis[N] ,chosen[N] ;
namespace kafka { //卡妈\se\se
	inline void topo () {
		queue <int> q ;
		rep (i ,1 ,n ,1) {
			if (! in[i]) {
				q.push (i) ;
			}
		}
		while (! q.empty ()) {
			int now = q.front () ;
			vis[now] = true ;
			if (chosen[now]) {
				if (--in[to[now]] == 0) { //监视他的人没了，他不能去
					q.push (to[now]) ;
				}
			}
			else {
				if (! chosen[to[now]]) { //没被选过避免重算
					ans ++ ; //可以去，答案加 1
					chosen[to[now]] = true ;
					q.push (to[now]) ;
				}
			}
			q.pop () ;
		}
	}
	inline void judge_circle () {
		for (int i = 1; i <= n; i++) {
			if (!vis[i] && in[i]) {
				int cnt = 0;
				for (int j = i; !vis[j]; j = to[j]) {
					cnt++;
					vis[j] = 1;
				}
				ans += cnt / 2;  
			}
		}
	}
}
int main () {
	IOS ;
	cin >> n ;
	rep (i ,1 ,n ,1) {
		cin >> to[i] ;
		in[to[i]] ++ ;
	}
	kafka :: topo () ;
	kafka :: judge_circle () ;
	cout << ans << '\n' ;
	return 0 ;
}
```

###### 你是否承认卡芙卡和狼谷的美貌天下无双？

---

## 作者：fishing_cat (赞：3)

### 题意

在一个基环树森林上，选出一些点，要求每一个选出的点都至少有一个没被选出的父节点。问最多可以选多少个。

### 思路

对于每一个入度为零的点，因为一定是没有点去监督他的，所以一定不选。再基于贪心的思想，这个点不选了，那么他的儿子结点就成了至少有一个没被选出的父节点的状态，所以是一定要选的。

对于上面的操作，可以用类似拓扑排序的方法，再拓扑的过程中，去维护要选的点个数。

做完拓扑排序后，剩下的入度仍不为零的点就是环以及单点了。对于环，还是贪心，隔一个选一个是最优的，所以这些的可选点个数就是环的长度下取整；至于单点，没有可选的。

### 坑点？

有个地方一开始我写错了，调了好久才改出来，错法较为降智，但还是挂出来，希望大家不要像我一样喵。

```
	for (int i = 1; i <= n; i++) {
		if (vis[i] == 0 && in[i] > 0) {
			huan_sum ++;
		}
	}
	ans += huan_sum / 2;
```

这是我在处理环时的代码，可以发现，这只猫猫就只是统计了所有在环上点的总个数，最后将个数除二加入答案。

明显是不对的啊！每一个环的可选点都是这一个环的长度除二，这样的弱智操作，只要有两个奇数环就寄了。

但是大气的洛谷还是给了我一个不错的分数呢。

[link](https://www.luogu.com.cn/record/182537423)

### code

```
#include<bits/stdc++.h>
#define ll long long 
#define il inline

using namespace std;
/*快读省了*/
ll n, a[1001000], ans;
ll to[1001000], cnt, in[1001000], vis[1001000], choose[1001000];

il void toposort() {
	queue<ll> q;
	for (int i = 1; i <= n; i++) 
		if (in[i] == 0) // 
			q.push(i);
	ll go_out = 0, huan_sum = 0;
	while(!q.empty()) {
		ll x = q.front();
		q.pop();
		vis[x] = 1; // 标记不在环中
		if (choose[x] == 1) { // 需要选
			in[to[x]] --;
			if (in[to[x]] == 0) q.push(to[x]); 
		} else {
			if (!choose[to[x]]) { // 防止重复统计
				q.push(to[x]);
				go_out ++;
			}
			choose[to[x]] = 1;
		}
	}
	ans += go_out;
	for (int i = 1; i <= n; i++) {
		huan_sum = 0;
		if (vis[i] == 0 && in[i] > 0) { // 不要像我一样错了
			for (int k = i ; vis[k] == 0; k = to[k]) {
				huan_sum ++;
				vis[k] = 1; 
			}
			ans += huan_sum / 2;
		}
	}
	return ;
}

int main() {
	read(n);
	for(int i = 1; i <= n; i++) {
		read(a[i]);
		to[i] = a[i];
		in[a[i]] ++;
	}
	toposort();
	cout << ans << "\n";
	return 0; // 完结撒花
}
```

---

## 作者：1234567890sjx (赞：2)

前言：班花 $\texttt{\color{black}y\color{red}hb}$ 真的好可爱。

-------

其实是很简单的题。由于每一名同学都一定会恰好监视另一名同学，所以[抽象](/user/761125)之后是一个基环树。

然后考虑从外到内贪心。因为没有被同学监视的~~害怕蝗虫的学委~~同学，即入度为 $0$ 的同学必然不能被监视。

所以入度为 $0$ 的同学所监视的同学就可以选择，$\texttt{\color{black}y\color{red}hb}$ 就会贪心的选择这位同学去发数学作业。同样的，入度为 $0$ 的同学所监视的同学所监视的同学就一定无法被选。入度为 $0$ 的同学所监视的同学所监视的同学所监视的同学就一定会被选……

这样就只剩下一大堆环了。显然若环上有 $n$ 个同学，那么有一些同学一定可以选择，剩下的同学就按照套路，破环成链，跑一遍 `dp` 即可。

时间复杂度 $O(n)$。


---

## 作者：OI_AKed_me (赞：2)

首先，这道题有一个贪心就是能选就选，因为如果一个点能选但却没有选，那就只能选择它的子节点，这样一定不会更优。然后就只剩下一堆环，而这些环都是不受其它点影响的，所以可以先钦定一个点不选，然后贪心，实际上就是将环的大小除以 $2$，下取整即可。

## 代码 ##
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define ll long long
#define cmax(a,b) a=max(a,b)
#define cmin(a,b) a=min(a,b)
#define rst(a,x) memset(a,x,sizeof(a))
#define ls p<<1
#define rs p<<1|1
#define FAST ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

using namespace std;

const int N(1e6+5);

int n,to[N],in[N],vis[N],ans;
bool use[N];
queue <int> Q;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>to[i];
		in[to[i]]++;
	}
	for(int i=1;i<=n;i++){
		if(!in[i]) Q.push(i);
	}
	while(!Q.empty()){
		int u=Q.front();Q.pop();vis[u]=1;
		ans+=use[u];
		if(!use[u]&&!use[to[u]]){
			use[to[u]]=1;
			Q.push(to[u]); 
		} 
		in[to[u]]--;
		if(!in[to[u]]&&!use[to[u]]) Q.push(to[u]);
	}
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		int cnt=0;
		for(int u=i;!vis[u];u=to[u]){
			cnt++,vis[u]=1;
		}
		ans+=cnt/2;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Atserckcn (赞：1)

## P1543 [POI2004] SZP 题解

[传送门。](https://www.luogu.com.cn/problem/P1543)

[更好的阅读体验？](https://www.cnblogs.com/Atserckcn/p/18368888)

### 题目简述

有 $n$ 个人，每个人都会监视另一个人，要求选出尽可能多的同学，使得选出的每一名同学都必定会被监视到。且选出的同学不可再监视其他人。

### 思路简述

因为任意一个人只能被另一个人管，那么就想到，如果没人管的同学就不能被选（不被监视）。

若某个人有多个人监视，且监视他的有至少一个专门监视（监视他的那个人没人监视）则他不得不去。

那么再看看如果出现环咋办。

不如画个图理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/4e3u0zzc.png)

上图即为一个环：$1$ 监视 $2$，$2$ 监视 $3$，$3$ 监视 $1$。

那么不妨枚举一下。

如果派出 $1$，则 $3$ 可以监视到，而 $2$ 也可以监视到 $3$，完美符合题意。

但是，若取出了 $1$ 和 $2$，$2$ 则会没人监视（本来监视他的 $1$ 号走了）。

所以可以得出结论：若遇到环，设 $s$ 为环的节点个数，则取出的个数为 $\lfloor\frac{s}{2}\rfloor$。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,to[N],ans,cnt_ring,in[N];
bool gone[N]/*被选中了吗*/,vis_ring[N]/*遍历过了吗*/;
queue<int > q;//注意：这里的q可不是说进队列了就得被选中
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&to[i]);
		++in[to[i]];//入度+1
	}
	for(int i=1;i<=n;i++)
		if(!in[i])//拓扑排序老板子
			q.push(i);
	while(!q.empty())
	{
		int t=q.front();q.pop();
		vis_ring[t]=true;//判断是否遍历过
		if(gone[t])//他走了，他监视的同学就看看情况
		{
			if((--in[to[t]])==0)
				q.push(to[t]);
		}
		else//他没走，他监视的孩子可就遭老罪喽
		{
			if(!gone[to[t]])//孩子没走
			{
				++ans;
				gone[to[t]]=true;//给我走
				q.push(to[t]);
			}
		}
	}
	for(int i=1;i<=n;i++)//开始判环
	{
		if(!vis_ring[i]&&in[i])
		{
			cnt_ring=0;//作用如其名
			for(int j=i;!vis_ring[j];j=to[j])
			{
				++cnt_ring;
				vis_ring[j]=true;
			}
			ans+=cnt_ring/2;//刚说的，不过C++自动向下取整
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_Weslie_ (赞：1)

## 思路

首先，这个题跟班花 $\texttt{y\red{hb}}$ 没有关系。因为它最后建出来是一个有向图且题目与前缀有关，所以可以考虑拓扑排序。

至于求最大，贪心即可。

## 贪心部分

### 具体解释

显然的监视该人数量为 $0$ 的人不能选。于是监视该人数量为 $0$ 的人的监视的人就要选（一会再解释为什么）。

那么，对于每一个人，如果他被选了，监视他监视的人的数量就会减 $1$（显而易见，因为他抱语文作业去了）。

如果没有人监视他监视的人了，他监视的人就不能去抱语文作业了。

### 正确性证明

如果我们在可以选择这个点的情况下没选这个人，那么下一个可选的点就是这个人监视的人。

按理来说，去掉这个人剩下的人少，而且去掉这个人也只有最多一个人可以被选，所以选上这个人一定是不劣的。

## 拓扑排序部分

显然题目没有保证是一个 DAG，而且样例也足够让我们看出它是有环的。

不过既然是环，那么从随便一个点断开都是等价的，所以就可以直接找一个环上的点断环就行了。

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int u,v,nxt;
}e[1000005];
int n,x[1000005];
queue<int>q;
int vis[1000005],ru[1000005],chu[1000005],ans[1000005],sum;
void bfs(){
	while(!q.empty()){
		int u=q.front();q.pop();
		vis[u]=1;
		if(ans[u]){
			ru[x[u]]--;
			if(ru[x[u]]==0)q.push(x[u]);
		}
		else{
			if(!ans[x[u]]){
				ans[x[u]]=1;
				sum++;
				q.push(x[u]); 
			}
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i];
		ru[x[i]]++;
		chu[i]++;
	}
	for(int i=1;i<=n;i++){
		if(ru[i]==0)q.push(i);
	}
	bfs();
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			vis[i]=1;
			int j=i;
			while(!vis[x[j]]){
				if(!ans[x[j]]&&!ans[j]){
					ans[x[j]]=1;
					sum++;
				}
				j=x[j];
				vis[j]=1;
			}
		} 
	}
	cout<<sum;
	return 0;
}
```
时间复杂度 $\operatorname{O}(n)$。

---

## 作者：hzoi_Shadow (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1543)

# 前置知识

[树形 DP](https://oi-wiki.org/dp/tree/)

# 解法

将 $a_{i}$ 向 $i$ 连一条有向边，这样就形成了基环外向树森林。

基环外向树森林内每棵基环外向树是相互独立的，需要单独处理。

对于每棵基环外向树，任取环上一点 $x$，断开 $x$ 到 $fa_{x}$ 的有向边，外向树就变成了一棵以 $x$ 为根的树。

设 $f_{x,0/1}$ 表示 $x$ 不选/选时，以 $x$ 为根的子树的最多选择个数，状态转移方程为 $\begin{cases} f_{x,0}=\sum\limits_{y \in Son(x)} \max(f_{y,0},f_{y,1}) \\ f_{x,1}=1+\max\limits_{y \in Son(x)} \{ f_{y,0}+\sum\limits_{z \in Son(x),z \ne y} \max(f_{z,0},f_{z,1}) \}=1+f_{x,0}- \min\limits_{y \in Son(x)} \{ \max(f_{y,0},f_{y,1})-f_{y,0} \} \end{cases}$。  

将原问题拆成两部分。第一部分为 $x$ 不限制 $fa_{x}$，断开 $x$ 到 $fa_{x}$ 的有向边，在以 $x$ 为根的树上进行 DP，得到的结果为 $\max(f_{x,0},f_{x,1})$；第二部分为 $x$ 限制 $fa_{x}$。故再次以 $fa_{x}$ 为根进行 DP，得到的结果为 $f_{fa_{x},1}$。这两部分合起来能够覆盖整个问题，故二者取 $\max$ 即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'     	
struct node
{
    int nxt,to;
}e[2000010];
int head[2000010],vis[2000010],u[2000010],v[2000010],f[2000010][2],rt,cnt=0;
void add(int u,int v)
{
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
int dfs_huan(int x)
{
    vis[x]=1;
    return (vis[u[x]]==1)?x:dfs_huan(u[x]);
}
void dfs(int x)
{
    int minn=0x3f3f3f3f;
    vis[x]=1;
    f[x][0]=0;
    for(int i=head[x];i!=0;i=e[i].nxt)
    {
        if(e[i].to==rt)
        {
            f[e[i].to][1]=-0x3f3f3f3f;
        }
        else
        {
            dfs(e[i].to);
            f[x][0]+=max(f[e[i].to][0],f[e[i].to][1]);
            minn=min(minn,max(f[e[i].to][0],f[e[i].to][1])-f[e[i].to][0]);
        }
    }
    f[x][1]=1+f[x][0]-minn;
}
int main()
{
    int n,ans=0,maxx,i;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        v[i]=i;
        cin>>u[i];
        add(u[i],v[i]);
    }
    for(i=1;i<=n;i++)
    {
        if(vis[i]==0)
        {
            rt=dfs_huan(i);
            dfs(rt);
            maxx=max(f[rt][0],f[rt][1]);
            rt=u[rt];
            dfs(rt);
            ans+=max(maxx,f[rt][1]);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：int_R (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P1543)

题意是如果我们选择了一个点 $x$，至少存在一个点 $y$ 没被选择且 $a_y=x$。

我们贪心的想到，如果一个点 $x$ 可以被选择，那么我们一定要选择 $x$ 这个点。证明：因为如果我们没有选择 $x$ 这个点，也就只是使得 $a_x$ 可以被选择，而选择 $a_x$ 和选择 $x$ 的贡献是一样的，所以我们贪心的使得选择 $x$ 就是正确的。

另外每个点出度为 $1$，所以图是一个基环内向树。而基环内向树的性质是：从每个点开始，沿着唯一出边走都会走到环上。

那么入度为 $0$ 的点我们一定是不能选择的，所以我们从所有入度为 $0$ 的点开始搜索，按照上述规则选择点，直到走到一个环上，把环放到最后考虑。

那么剩下的问题就是若干个环，一些点可以直接被选择（受环外点影响），问最多可以选择多少个点。随便找一个位置破环成链，讨论这个位置选或不选，取最大值即可。具体看代码

```cpp
#include<stdio.h>
#include<algorithm>
#include<queue>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
	return x*f;
}
const int MAXN=1e6+10,INF=1e9+7;
int n,a[MAXN],into[MAXN],ans;
bool vis[MAXN],b[MAXN],f[MAXN];
queue <int> q;
int dfs(int x,int pre)
{
	vis[x]=true;int ans=0;
   	//f[x] 表示是否选择 x ,b[x]表示 x 是否可以通过环外点选择上
	if(a[x]!=pre)//下一个点不是开始的点
	{
		if(!f[x]||b[a[x]]) f[a[x]]=1,ans+=1;//可以选择就加 1
		ans+=dfs(a[x],pre);
	}
	else if(!(!f[x]||b[pre])&&f[pre]) ans-=1;
   	//如果下一个点是开始的点，并且一开始默认选择了但并不能选择的话，让当前点 x 不再被选择，所以减掉 1
	f[x]=false;//回溯时候把 f[x] 重新设为 false
	return ans;
}
int main()
{
	n=read();
	for(register int i=1;i<=n;++i) a[i]=read(),into[a[i]]++;//记录入度数
	for(register int i=1;i<=n;++i) if(!into[i]) q.push(i);//入度为 0 的放入队列
	while(!q.empty())
	{
		int x=q.front();q.pop();
		vis[x]=true;if(b[x]) ans++;//如果被选择了，答案 +1
		if(!b[x]) b[a[x]]=true;//当前点没被选，下一个点可以被选，一定选
		if(!--into[a[x]]) q.push(a[x]);//如果入度为 0 了放入队列，这样剩下的就一定是环上的点
	}
	for(register int i=1;i<=n;++i)
	{
		if(!vis[i])//找到一个点断开环
		{
			f[i]=true;//f[i] 表示是否选择 i
			int ans1=dfs(i,i)+1;//加上第一个点的 1
			int ans2=dfs(i,i);
			ans+=max(ans1,ans2);//取最优情况
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：GCSG01 (赞：0)

## P1543 SZP

### 题意

每名同学都监视着另一名同学，要求选出尽量多的人，使得 **被选出** 的每个人 **至少有一名** 监视她的同学没有被选中，输出最多选多少人。

### 思路

一人套一人，首选拓扑。首先一个同学如果没被人监视，那么她就不可能被选择，于是将她入队。  
因为她没被选，所以她所监管的人就有人（她自己）监管了，因此她监管的人便可以被选择。

考虑出现环的情况，形如 $A$ 监管 $B$，$B$ 监管 $C$，$C$ 监管 $A$，选择任意一人将她视为 **不被选择**，之后按上面的步骤即可，这里容易发现，在环中被选取的人数占环中人数的一半。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n,ans=0;
int son[N];
int in[N];
int f[N];
int flag[N];
queue<int>q;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>son[i],in[son[i]]++;
	for(int i=1;i<=n;i++)
		if(!in[i])q.push(i),flag[i]=1;
	while(!q.empty())
	{
		int u=q.front(),v=son[u];
		q.pop();
		flag[u]=1;
		if(f[u])
		{
			ans++;
			in[v]--;
			if(!in[v])q.push(v);
		}
		else if(!f[v])q.push(v),f[v]=1;
	}
	for(int i=1;i<=n;i++)
		if(!flag[i])
		{
			int s=0;
			for(int j=i;!flag[j];j=son[j])
				s++,flag[j]=1;
			ans+=s/2;
		}
	cout<<ans;
	return 0;
 }
```

---

## 作者：kczw (赞：0)

# 题意
有 $n$ 个点，每个点连向一个点。选择一些点，保证被选择点至少有一个未被选择点连向该点。问最多被选择点最大数量。
# 思路
不难知道，题目中给出的图是基环树森林。然后，我们不妨画一个图，分析一下题目的选择点规则。

![](https://cdn.luogu.com.cn/upload/image_hosting/zxrle3c8.png)

对于一对点，起点只对应一个终点，而终点虽然可以对应多个起点，但是一个终点只计算一次，所以一对起点终点的贡献等同于一个被选择的点。

不难发现，其实就是求树上最大匹配，直接贪心的从下往上找即可。一般情况直接就深搜了，但是此处是基环树，所以需要用拓扑的方法。

特殊的，对于只有一个环的，肯定只能取点数的一半且向下取整，跑完贪心拓扑再特判即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,max,a[N],din[N],vis[N],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		din[a[i]]++;
	}
	queue<int>q;
	for(int i=1;i<=n;i++)
		if(!din[i])
			q.push(i);
	while(!q.empty()){
		int u=q.front();q.pop();
		vis[u]=1;
		if(!vis[a[u]]){
			ans++;
			vis[a[u]]=1;
			din[a[a[u]]]--;
			if(!din[a[a[u]]])
				q.push(a[a[u]]);
		}
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]&&din[i]){
			int cnt=0;
			for(int j=i;!vis[j];j=a[j]){
				cnt++;
				vis[j]=1;
			}
			ans+=cnt/2;
		} 
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：ny_Dacong (赞：0)

# 思路

每个点有两种情况：

1. 做任务。
2. 监视别人。

对于没有人监视它的点，只能选择情况 1。否则能选情况 2 就选情况 2。

所以可以采取拓扑的思想，先找出没有入度的点，那么这些点所监视的点都可以选。

如果这个点选过了，那么它就不会监视其他点。也就是删除他们两个之间的边。

因为拓扑不能处理环，所以对于环，选取一半的人数（向下取整）即可。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans = 0;
int End[1000005],idx[1000005];
bitset<1000005> used,vis;//省空间
queue<int> que;
int main(){
	scanf("%d",&n);
	for(int i = 1; i <= n; i++){
		scanf("%d",&End[i]);
		idx[End[i]]++;//记录入度
	}
	for(int i = 1; i <= n; i++){
		if(!idx[i]){//入度为 0，肯定不能去做任务。
			que.push(i);
		}
	}
	while(que.size()){
		static int now;
		now = que.front();
		que.pop();
		vis[now] = 1;
		if(used[now]){
			idx[End[now]]--;
			if(idx[End[now]] == 0){//入度为 0，肯定不能去做任务。
				que.push(End[now]);
			}
		}else{
			if(used[End[now]] == 0){
				ans++;
				que.push(End[now]);
			}
			used[End[now]] = 1;
		}
	}
	for(int i = 1; i <= n; i++){
		static int cnt;
		if(vis[i] == 0 && idx[i]){//环
			cnt = 0;
			for(int j = i; !vis[j]; j = End[j]){
				cnt++;
				vis[j] = 1;
			}
			ans += cnt/2;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：honglan0301 (赞：0)

## 题目分析

是基环树入门题，但我凭借极为优秀的调试能力调了好半天。

容易发现出度均为 $1$ 的各点构成了一个内向基环树森林，我们常规的想法，试图把它变成树上问题（因为树上问题极好做，令 $f(i,0/1)$ 表示该点选或不选能得到的最大值即可）。

然后发现这是容易的，我们只要找出一条在环上的边 $(u,v)$ 并断开它，然后以 $u$ 为根分别钦定选及不选 $u$，其中选 $u$ 完全不影响树上 $\text{dp}$，不选 $u$ 仅对选 $v$ 的情况有影响（因为相当于已经有一个能监视 $v$ 的人了），据此断边 $\text{dp}$ 即可做到 $O(n)$。实现上可能要注意特判大小为 $2$ 的环，不过我通过只存反边规避掉了特判。

我这个写法常数有点巨大，不如题解里比较玄妙的贪心，但是就觉得断环 $\text{dp}$ 可能更有普适性（？）

## 代码

```cpp
/*
  author: PEKKA_l  
  Sexy_goodier _ xiaoqing
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
#define pb push_back
#define int long long

int n,a[1000005],da,db,zt;
int xz[1000005],dp[1000005][2],vis[1000005],ans;
vector <int> g[1000005];

void dfs(int x,int fat)
{
	vis[x]=1;
	if(!g[x].size()) {dp[x][0]=dp[x][1]=0; return;}
	if(x==da&&g[x].size()==1) {dp[x][1]=!zt; dp[x][0]=0; return;}
	dp[x][0]=0; dp[x][1]=1; int sum=0,nmin=1000000000000;
	for(auto i:g[x])
	{
		if(i==fat||(x==da&&i==db)) continue; dfs(i,x);
		dp[x][0]+=max(dp[i][0],dp[i][1]); sum+=max(dp[i][0],dp[i][1]); 
		nmin=min(nmin,dp[i][1]-dp[i][0]);
	}
	if(x==da&&zt==0) dp[x][1]+=sum;
	else dp[x][1]+=sum-max(0ll,nmin);
}

signed main()
{
	cin>>n; for(int i=1;i<=n;i++) {cin>>a[i]; g[a[i]].pb(i);}
	for(int i=1;i<=n;i++)
	{
		if(vis[i]) continue; int nd=i;
		while(1) 
		{
			vis[nd]=1;
			if(vis[a[nd]]) {db=nd; da=a[nd]; break;}
			nd=a[nd];
		}
		int nans=0;
		zt=0; dfs(db,db); nans=max(nans,dp[db][0]); 
		zt=1; dfs(db,db); nans=max(nans,dp[db][1]);
		ans+=nans;
	}
	cout<<ans<<endl;
}

/*

10
2 3 4 2 4 7 8 9 10 7
55
*/
```


---


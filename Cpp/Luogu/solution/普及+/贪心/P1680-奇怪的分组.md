# 奇怪的分组

## 题目背景

终于解出了 dm 同学的难题，dm 同学同意帮 v 神联络。可 dm 同学有个习惯，就是联络同学的时候喜欢分组联络，而且分组的方式也很特别，要求第 $i$ 组的的人数必须大于他指定的个数 $C_i$。在 dm 同学联络的时候，v 神在想，按照 dm 同学的规则一共可以有多少种方案呢？他想啊想，终于……没想出来。于是他又想到了聪明的你，你能帮 v 神算出按照 dm 同学的规则有多少种分组方案吗？


## 题目描述

v 神的班级共有 $N$ 个人，dm 同学想把同学分成 $M$ 组联络，要求第 $i$ 组的人数必须大于给定的正整数 $C_i$，求有多少不同的方案（两个是相同的方案当且仅当对于任意的一队 $i$，两个方案的第 $i$组同学数量相等）。由于结果很大，所以你只需要输出模 $10^9+7$ 的值。


## 说明/提示

### 样例解释

方案有三种，每组的个数分别是 $(3,3,4)$，$(2,4,4)$，$(2,3,5)$。

### 数据范围约定

对于 $30\%$ 的数据，$N,M\le 10$。

对于 $60\%$ 的数据，$N,M\le 1000$。

对于 $100\%$ 的数据，$1\le N ,M\le 10^6$，$1\le C_i\le 1000$。

数据保证至少有一个方案。


## 样例 #1

### 输入

```
10 3
1
2
3
```

### 输出

```
3```

# 题解

## 作者：hongzy (赞：13)

### 解法
首先将n减去所有的$C_i$，于是是原问题转换为：n个相同的球放入m个不同盒子里，不能为空，求方案数.

可以直接运用**隔板法**，答案为 $C(n-1, m-1)$ $mod$ $p$ ;

（以下就用$p$代表模质数1000000007

下面介绍**两种**求 $C(n-1, m-1)$ $mod$ $p$ 的**方法**.

#### 方法1 : 直接求

组合数的公式：$C(n, k) = n!$ $/$ $(k!(n-k)!)$

设分子为 $a$，分母为 $b$，则$C(n, k) = a$ $/$ $b$

可以预处理出1~MAXN的阶乘 mod p，$a$和$b$可以O(1)得到

除法取模不能直接除并取模，答案应该为$a * b'$ $mod$ $p$，$b'$为$b$在模$p$意义下的逆元.

考虑到$p$是个质数，求逆元不需要Extended_gcd和欧拉定理，只需要费马小定理.

运行时间：80ms.

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

#define MOD 1000000007
#define MAXN 1000000
typedef long long LL;

int Read() { //快读 
	char c; int ans(0); 
	while(!isdigit(c = getchar()));
	do ans = ans * 10 + c - 48;
	while(isdigit(c = getchar()));
	return ans;
}

int n, m, ans;
int fc[MAXN + 10];

LL Qpow(LL a, LL b) { //快速幂 
	LL ans = 1;
	for(; b; b>>=1, a=a*a%MOD)
		if(b & 1) ans = ans*a % MOD;
	return ans;
}

int C(int n, int k) { //求组合数 
	LL fm = (1LL * fc[n-k] * fc[k]) % MOD;
	return 1LL * fc[n] * Qpow(fm, MOD-2) % MOD;
}

int main() {
	fc[0] = 1;
	for(int i=1; i<=MAXN; i++) //预处理阶乘
		fc[i] = (1LL * fc[i-1] * i) % MOD;
	n = Read(), m = Read();
	for(int i=1; i<=m; i++) n -= Read();
	printf("%d\n", C(n-1, m-1));
	return 0;
}
```

#### 方法2 : Lucas定理

Lucas定理可以直接求 $C(n, m)$ $mod$ $p$

跑得非常快，4ms（手写getchar可以0ms），建议掌握这种方法.

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

#define MOD 1000000007
typedef long long LL;

int Read() { //快读
	char c; int ans(0);
	while(!isdigit(c = getchar()));
	do ans = ans * 10 + c - 48;
	while(isdigit(c = getchar()));
	return ans;
}

int n, m;

LL Qpow(LL a, LL b, LL p) { //快速幂 
	LL ans = 1;
	for(; b; b>>=1, (a*=a) %= p)
		if(b & 1) (ans *= a) %= p;
	return ans;
}

LL c(LL n, LL m, LL p) {
	if(n < m) return 0;
	if(m > n - m) m = n - m;
	LL s1 = 1, s2 = 1;
	for(int i=0; i<m; i++) {
		s1 = s1 * (n - i) % p;
		s2 = s2 * (i + 1) % p;
	}
	return s1 * Qpow(s2, p-2, p) % p;
}

LL Lucas(LL n, LL m, LL p) { //Lucas
	if(m == 0) return 1;
	return c(n % p, m % p, p) * Lucas(n / p, m / p, p) % p;
}

int main() {
	n = Read(), m = Read();
	for(int i=1; i<=m; i++) n -= Read();
	printf("%d\n", Lucas(n-1, m-1, MOD));
	return 0;
}
```

---

## 作者：bovine__kebi (赞：3)

一个比较简单的理解方法：  
题目要求我们每个分组大于$c_i$人,所以我们可以必须每个先填$c_i$个人，然后我们就还剩下了$n-\sum\limits_{i=1}^mc_i$个人，所以我们的问题就转换成了你手里有$n-\sum\limits_{i=1}^mc_i$个球，放进$m$个盒子里，可以为空。

我们可以先求出$k=n-\sum\limits_{i=1}^mc_i$求出，然后就成了一个装球的问题了，那么根据组合数学，我们可以知道答案为：$C^{k-1}_{m-1}$,然后就可以暴力算了，具体算法看程序:  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1000005;
const int Mod=1e9+7;
int n,m;
ll fac[maxn];
inline ll qpower(int x,int p)//普通的快速幂
{
    ll ans=1;
    while(p)
    {
        if(p&1)ans=1ll*ans*x%Mod;
        x=1ll*x*x%Mod;
        p>>=1;
    }
    return ans;
}
inline void work(int n)//预处理阶乘，因为组合数展开之后需要到阶乘
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
    {
        fac[i]=1ll*fac[i-1]*i%Mod;
    }
}
inline ll C(int n,int m)//根据组合数公式求组合数
{
    return 1ll*fac[n]*qpower(1ll*fac[m]*fac[n-m]%Mod,Mod-2)%Mod;//这里用了费马小定理求逆元
}
int main()
{
    scanf("%d %d",&n,&m);
    work(maxn);
    for(register int i=1;i<=m;i++)
    {
        int a;scanf("%d",&a);
        n-=a;//先减掉那些必须填的
    }
    printf("%lld\n",C(n-1,m-1));//直接爆算组合数
}
```

---

## 作者：Sunshine離 (赞：3)

好久没上洛谷了，于是来丢个题解

很容易想到，既然每个组至少要c[i]+1个人，那么我们把总人数减去c[i]+1，最后问题就变成了把n个人分成m组，可以为空

这里我们可以把分组看成在一堆0里面插1的种数

于是，0和1加起来一共n+m-1个

1有m-1个

所以为c(n+m-1)(m-1)种方案

但是除法取模会出问题，所以这里我们要用逆元的知识把除法变成乘法，但数据太大，所以要转换成幂的形式，这里要用到费马小定理

推导如下

a/b mod p=a\*b的逆元 mod p

跟据费马小定理有b^(p-1)mod p=1

所以b\*b^(p-2)mod p=1

跟据逆元的定义，b^(p-2)为b的逆元

于是原式变成a\*b^(p-2) mod p

接着就快速幂就可以了


```pascal
const mo=1000000007;
var p,n,m,i,k:longint;
    a,b,t:int64;

begin
readln(n,m);
for i:=1 to m do
begin
readln(k);
dec(n,k);
end;
dec(n,m);//此时问题变为把n个人分成m组，可以为空
a:=1;b:=1;
for i:=1 to n+m-1 do a:=a*i mod mo;
for i:=1 to m-1 do b:=b*i mod mo;
for i:=1 to n do b:=b*i mod mo;
p:=mo-2;t:=1;//快速幂求b^(p-2)
while p>0 do
begin
    if p mod 2=1 then t:=t*b mod mo;
    b:=b*b mod mo;
    p:=p shr 1;
end;
a:=a*t mod mo;
writeln(a);
end.
```

---

## 作者：naroto2022 (赞：2)

# P1680题解
### 思路
一看这题，不就是组合题吗？再往下看，涉及到分组，一下子就想到了隔板法，只不过要想隔板还需要一点小处理：因为第 $i$ 必须大于 $C_{i}$，于是想到将 $n$ 减去每组的 $C_{i}$，于是奇怪的分组就转化为基础的组合题：$n$ 个相同的球放入 $m$ 个不同盒子里，不能为空，求方案数。

那脑子里就出现了答案：

 $C_{m-1}^{n-1}\bmod1000000007$。

而由我们小学学的组合知识可知：

 $C_{m}^{n}=\frac{n!}{m!(n-m)!}$

于是设 $p=n!$，$q=m!(n-m)!$，则 $C_{m}^{n}=\frac{p}{q}$。

我的方法就是先求出 $1\sim1000005$ 内所有数的阶乘 $\bmod 1000000007$，然后就可以不咋费时间地求出 $p$，$q$。

由于除法取模不能直接除并取模，所以答案应为 $a\times b'\bmod 100000007$，此处的 $b'$ 为 $b$ 在模 $1000000007$ 意义下的逆元。因为 $1000000007$ 是一个质数，所以求逆元时可以用费马小定理或者欧拉定理（我用的是费马小定理）。

### 总结

1. 组合知识。
2. 逆元。
3. 费马小定理。
4. 欧拉定理。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define mod 1000000007
#define ll long long
using namespace std;
ll n,m,num[1000005]={1};
ll qpow(ll a, ll b){//快速幂 
	ll ans = 1;
	for(; b; b>>=1,a=a*a%mod)
		if(b&1) ans=ans*a%mod;
	return ans;
}
int zh(ll n, ll m){//求C(n,m) 
	ll cnt=(num[n-m]*num[m])%mod;
	return num[n]*qpow(cnt,mod-2)%mod;
}
int main(){
	for(int i=1; i<1000001; i++)//先算出阶乘
		num[i]=(num[i-1]*i)%mod;//不取模见祖宗 
	scanf("%lld %lld" ,&n,&m);
	for(int i=1; i<=m; i++){
		ll x;
		scanf("%lld",&x);
		n-=x;
	} 
	printf("%d\n",zh(n-1,m-1));
	return 0;
}
```

### 附（选看）

1. 快速幂：

对于线性求解的问题，如果需要优化，很多时候可以考虑选用树形结构的数据结构或者分治思想，那样可以将算法时间复杂度从 $O(n)$ 降低到 $O(\log n)$。这里我们考虑用分治思想。

求 $a^b\bmod n$，其实很容易想到，若 $b$ 是偶数，则 $a^{b}=a^{\frac{b}{2}}\times a^{\frac{b}{2}}$；若 $b$ 是奇数，则 $a^{b}=a^{\lfloor\frac{b}{2}\rfloor}\times a^{\lfloor\frac{b}{2}\rfloor}\times a$。即我们只要求出 $a^{\frac{b}{2}}$，然后再通过一次乘法运算，即可求出 $a^{b}$。接着继续将 $\frac{b}{2}$ 分成 $\frac{b}{4}$，$\frac{b}{8}$……最终 $b$ 会变成 $1$，并且只需要 $\log b$ 次就可以实现。这就是快速幂。

2. 费马小定理：

若 $p$ 是质数，则对于任意整数 $a$，都有 $a^{p}\equiv a \pmod p$。

3. 欧拉定理：

若正整数 $a$，$n$ 互质，则 $a^{\varphi(n)}\equiv1\pmod n$，其中 $\varphi(n)$ 为欧拉函数。

欧拉定理的推论：

若正整数 $a$，$n$ 互质，则对于任意正整数 $b$，有 $a^{b} \equiv a^{b\bmod\varphi(n)}\pmod n$。

证明：

设 $b=q\times \varphi(n)+r$，其中 $0\leq r<\varphi(n)$，即 $r=b\bmod \varphi(n)$。

于是：$a^{b}\equiv a^{q\times \varphi(n)+r}\equiv (a^{\varphi(n)})^q\times a^r\equiv 1^q\times a^r\equiv a^r\equiv a^{b\bmod\varphi(n)} \pmod n$。

完结——如有错误请指出在哪里，是啥问题，谢谢！

---

## 作者：不存在之人 (赞：2)

### 解题思路

相当于隔板法，每个先填$c[i]+1$个，然后剩余$k$个，相当于把$k$个苹果塞到$m$个盒子里，盒子可以为空，方案数为$C(n+m-1,m-1)$。

还有一种理解方式是每个先填$c[i]$个，剩$k$个，把$k$个苹果塞到$m$个盒子里，盒子不能为空，方案数为$C(n-1,m-1)$。

**然后费马小定理算出逆元。**
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN=1000005;
const int mod=1e9+7;
typedef long long LL;
inline int rd()
{
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)) {f=ch=='-'?-1:1;ch=getchar();}
    while(isdigit(ch))  {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
int n,m;
LL ans,to[MAXN<<2]={0,1};
LL fast_pow(LL x,int y)
{
    LL ret=1;
    for(;y;y>>=1)
	{
        if(y&1) ret=ret*x%mod;
        x=x*x%mod;
    }
    return ret;
}
int main()
{ 
    for(register int i=2;i<=2000000;i++) to[i]=to[i-1]*i%mod;
    n=rd();m=rd();
    for(register int i=1;i<=m;i++) n-=rd()+1;
    if(m==1||n==0){printf("1\n");return 0;}
    ans=to[n+m-1]*fast_pow(to[m-1],mod-2)%mod*fast_pow(to[n],mod-2)%mod;
    printf("%d\n",ans%mod);
    return 0;
}
```

---

## 作者：piggy123 (赞：1)

显然的一个数学题，在小学练习册后几题，不知道是怎么评绿的，所以我写篇题解水点咕值。

首先我们考虑一个简单情况，即每个人分到的要大于等于 $1$ 个，怎么做？很简单，就是隔板法模型，在 $N-1$ 个空隙中插入 $M-1$ 个隔板，将 $N$ 个人分为 $M$ 组即可。

现在考虑附加情况，要求第 $i$ 组比 $C_i$ 人多，求方案数。也很简单，我们只需要先给每组放 $C_i$ 个人即可（因为每个人是一样的，所以只用一种情况），总共放了 $\sum_i C_i$ ，据乘法原理可得剩下的用隔板法分为 $M$ 组的方案就是总方案。

So，答案就是 $C^{m-1}_{n-1-\sum_iC_i}$ 。

那么接下来摆在我们面前的就是如何求这个数了，由于数很大，不能直接用阶乘去除，我们要用到**乘法逆元**。

根据费马小定理，当 $p$ 为素数时， $a^{p-1}=1(\bmod\ p)$ ，所以 $a^{p-2}a=1(\bmod\ p)$ ，所以 $a^{p-2}$ 是 $a$ 在 $\bmod\ p$ 意义下的逆元。

注意到 $10^9+7$ 是个素数，于是只需要套用公式，求 $\frac{a}{b}\bmod\ p=a\times b^{p-2}\bmod p $ 即可。

AC Code：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const ll mod=1e9+7;

ll qkp(ll a,ll k){
	ll ans=1;
	while (k){
		if (k&1)ans*=a,ans%=mod;
		a*=a,a%=mod;
		k>>=1;
	}
	return ans;
}

ll C(ll n,ll m){
	ll a=1,b=1;
	for (ll i=1;i<=m;i++){
		a*=n-i+1;a%=mod;
		b*=i;b%=mod;
	}
	return a*qkp(b,mod-2)%mod;
}

int main(){
	ll n,m;
	cin >> n >> m;
	for (ll i=1;i<=m;i++){
		ll x;
		cin >> x;
		n-=x;
	}
	cout << C(n-1,m-1);
	return 0;
}

```


---

## 作者：KAMIYA_KINA (赞：1)

## Tag

组合数学，球盒问题。

## preface

本题算是比较经典的球盒问题入门题了，本文主要讲解本题涉及到的球盒问题中的两个公式

## Description

对于 $n$ 个球，放进 $m$ 个盒子里面，每个盒子至少有 $a_i + 1$ 个球，求最后的方案数，对 $10^9 + 7$ 取模。

## Solution

可以很容易的想到，因为每个盒子至少放这么多，那么当我总球数减去这些至少放的球之后，就变成了我剩下的可以自由放的球，对于这些球，就相当于 $n$ 个球放进 $m$ 个盒子里面，可以有空盒。

这个问题是一个非常经典的问题，先说一手结论，$\binom{n+m-1}{m-1}$。

为什么呢？我这里有一种非常另类的解释。

学过组合数学的都知道对于一个网格图，我们从 $(0,0)$ 走到 $(n,m)$ 的方案数是 $\binom{n+m}{m}$。那么类比一下，我们考虑 $x$ 轴为**我现在放了几个球**，$y$ 轴为**我现在走到第几个盒子**，那么根据这个定义，是不是很容易就可以想到，我们的起点在 $(0,1)$ 这个位置，然后走到 $(n,m)$ 这个位置，那么根据上面那个网格图的走法，方案数就是 $\binom{n+m-1}{m-1}$。

如果想要一个更加显然一点的做法，那么我们就先考虑另一个球盒模型。有 $n$ 个球，$m$ 个盒子，不能有空盒的方案数。

这个问题也非常的简单，转化一下就变成了插板问题，请读者思考一下，插板法就是在 $n - 1$ 个区别的球中间选 $m - 1$ 个的方案数，那么就是组合的定义了，答案就是 $\binom{n-1}{m-1}$。

拓展的，可以有空盒的情况是不是就是这个问题的一个延伸，那么我们就多出了 $m$ 个球去进行插板，答案是不是就变成了 $\binom{n+m-1}{m-1}$。

看到这里只想找证明的读者可以走了，本文更重要的是**如何线性求组合数**的 trick。

预处理：

```cpp
inline void init(const int lim) {
    fc[0] = 1;
    for(int i = 1; i <= lim; i++) fc[i] = fc[i - 1] * i % mod;
    fv[lim] = ksm(fc[lim], mod - 2);
    for(int i = lim; i >= 1; i--) fv[i - 1] = fv[i] * i % mod;
    return ;
}
```
查询：

```cpp
inline int C(int n, int m) {
    if(n < m) return 0;
    return fc[n] * fv[m] % mod * fv[n - m] % mod;
}
```
这都是直接根据组合的意义来推导的，`fc[x]` 表示的是 $x!$，`fv[x]` 表示的是 $x!$ 的逆元。

预处理时间复杂度是 $O(n)$ 的，查询时间复杂度 $O(1)$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000], *p1(buf), *p2(buf);
#define rd read()
inline int read() {
    int x = 0, f = 1;
    char ch = gc;
    while(!isdigit(ch)) {
        if(ch == '-') f = 0;
        ch = gc;
    }
    while(isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = gc;
    }
    return f ? x : -x;
}

const int mod = 1e9 + 7;
const int N = 1e6 + 1;

int fc[N], fv[N];

inline int ksm(int x, int y) {
    int ret = 1;
    for(; y; y >>= 1, x = x * x % mod)
        if(y & 1) ret = ret * x % mod;
    return ret;
}

inline void init(const int lim) {
    fc[0] = 1;
    for(int i = 1; i <= lim; i++) fc[i] = fc[i - 1] * i % mod;
    fv[lim] = ksm(fc[lim], mod - 2);
    for(int i = lim; i >= 1; i--) fv[i - 1] = fv[i] * i % mod;
    return ;
}

inline int C(int n, int m) {
    if(n < m) return 0;
    return fc[n] * fv[m] % mod * fv[n - m] % mod;
}

inline void solve() {
    int n = rd, m = rd;
    for(int i = 1, x; i <= m; i++) x = rd, n -= x;
    init(n);
    cout << C(n - 1, m - 1) << endl;
}
#undef int

int main() {
#ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    solve();
    return 0;
}
```

---

## 作者：rickyxrc (赞：0)

本文章遵守知识共享协议 CC-BY-NC-SA，同步发表于洛谷题解区，转载时须在文章的任一位置附上原文链接和作者署名（rickyxrc）。推荐在[我的个人博客](https://blog.rickyxrc.cc)阅读。

## 题意简述

有 $n$ 个人要分成 $m$ 组，每组至少要 $A_i$ 个人（不用 C 为了防止与下面的排列组合式子冲突），求方案数。

## 解法

我们发现，人与人之间没有本质区别，那么我们可以把总人数减少 $\sum_{i=1}^n A_i$，预先分配，剩下的人至少要分配到一组一人，因为题目要求**大于**。

那么对于剩下的人，我们考虑应用隔板法，就是从剩下的 $n-\sum_{i=1}^n A_i$ 个人中使用 $m-1$ 个隔板将其分开，所以答案就是 $C^{m-1}_{n-\sum_{i=1}^n A_i-1}$。

计算排列组合要用逆元。

还有个特例就是如果隔板数量不够输出 $0$。

剩下应该没啥了，直接上代码。

```cpp
#include<stdio.h>

#define maxn 2000007

#define mod 1000000007

typedef long long i64;
typedef int i32;

i64 fpow(i64 x,int p){
	i64 res=1;
	while(p){
		if(p&1)
			res = res * x % mod;
		p>>=1;
		x = x * x % mod;
	}
	return res;
}

i64 ginv(i64 x){
	return fpow(x,mod-2);
}

i64 jcs[maxn],inv[maxn],n,m,t;

i64 C(i64 n,i64 m){
	return jcs[n] * inv[m] % mod * inv[n-m] % mod;
}

int main(){
	scanf("%lld%lld",&n,&m);
	for(i32 i=1;i<=m;i++)
		scanf("%lld",&t),
		n-=t;
	
	if(m==1)
		return printf("1")&0;
	
	jcs[0]=1;
	for(i32 i=1;i<maxn;i++)
		jcs[i] = jcs[i-1] * i % mod,
		inv[i] = ginv(jcs[i]);

	printf("%lld",C(n-1,m-1));

	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题意解析：

有 $N$ 个人，需要将他们分成 $M$ 组，并且保证第 $i$ 组中的人数 $\ge C_i$。求有多少种不同的分组方式。

## 思路（数学隔板法）：

考虑数学隔板法，将 $N$ 个人和 $M$ 个组之间用 $M-1$ 个隔板隔开。

其中，每个竖线表示一个隔板，它把人分成了一个个小组。

此时，需要满足每个小组的人数 $\ge C_i$，可以将 $C_i$ 个人预先分配到第 $i$ 个小组中，然后再将剩余的 $(N-\sum_{i=1}^{M}{C_i})$ 个人分配到各个小组中。

因此，可以将问题转化为将 $(N-\sum_{i=1}^{M}{C_i})$ 个物体放入 $M$ 个不同的组中，每个组至少放 $1$ 个物体的方案数。
### 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, b) for(int i = a; i <= b ; ++i)
#define per(i, a, b) for(int i = b ; i >= a ; --i)
typedef long long ll;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
const int mod = 1000000007;
ll qpow(ll a,ll b){
    ll k=1;
    while(b){
        if(b&1)
		  (k*=a)%=mod;
        b>>=1;
        a=(a*a)%mod;
    }
    return k%mod;
}
ll C(ll n,ll m){
    if(n<m)
	  return 0;
    ll x=1,y=1;
    if(m>n-m)
	  m=n-m;
    rep(i,0,m-1){
        x=x*(n-i)%mod;
        y=y*(i+1)%mod;
    }
    return x*qpow(y,mod-2)%mod;
}
ll lucas(ll n,ll m){
    return !m||n==m?1:C(n%mod,m%mod)*lucas(n/mod,m/mod)%mod;
}
ll n,k;
int main(){
    n=read(),k=read();
    rep(i,1,k)
      n-=read();
    write(C(n-1,k-1));
    return 0;
}
```
这里我们也可以用费马小定理求逆元算出结果。~~不过使用 lucas 定理也是一种实力的表现……~~

---

## 作者：Misaka_Mik0t0 (赞：0)

题目简述：
>将 $n$ 个人分成 $m$ 组，第 $i$ 组的人数必须大于为 $c_i$，问方案数。

题目中说了
>两个是相同的方案当且仅当对于任意的一队i，两个方案的第i组同学数量相等

即所有同学都是成相同的。那么我们就可以先给每组 $c_i$ 个人。之后变成了 $n-\sum_{i=1}^nc_i$ （以后用 $n$ 来代替此数）个人，分成 $m$ 组，每组不可以为 $0$ 个人。
## 重点：解决方法
看见其它题解都没写，我就来写一下吧~

**方法：插板法**

问题描述：对于 $n$ 个人，分成 $m$ 组，每组至少 $1$ 个人。问方案数。

我们可以想象这 $n$ 个人站成一列，拿 $m-1$ 个板子往这 $n-1$ 个间隔中插，其中任意两个都不在同一个间隔中。显然，若不考虑板子的不同，一共有 $C_{n-1}^{m-1}$ 种方法。现在，每两个板子之间（旁边两个板子的左/右边的人）的人为一组，共 $m$ 组，与问题恰好对应。并且，每分出 $m$ 组，就对应一种不同的插板方法（分析很简单，这里就不说了）。**那么，答案就是 $C_{n-1}^{m-1}$**。

之后用 Lucas 算出组合数就行了。Lucas 模板 [P3807](https://www.luogu.com.cn/problem/P3807)，不熟悉的话可以先看一下这题。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	char ch=getchar();int res=0,k=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-')k=-1;else k=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+ch-'0';
		ch=getchar(); 
	}
	return res*k;
}//速读
int n,m;
const int mod=1000000007; 
int power(int a,int b,int p){
	if(b==0)return 1;
	int c=power(a,b/2,p);
	if(b%2==0)return (long long)c*c%p;
	return (long long)c*c%p*a%p;
}//快速幂
int c(int a,int b,int p){
	int s=1,m=1;b=min(b,a-b);
	for(int i=0;i<b;++i)s=(long long)s*(a-i)%p,m=(long long)m*(i+1)%p;
	return (long long)s*power(m,p-2,p)%p;
}
int lucas(int a,int b,int p){
	if(b==0)return 1;
	return (long long)c(a%p,b%p,p)*lucas(a/p,b/p,p)%p;
}//卢卡斯
int main(){
	n=read();m=read();
	for(int i=1;i<=m;++i)n-=read();
	printf("%d",lucas(n-1,m-1,mod));
	return 0;
} 
```

---

## 作者：何炳儒 (赞：0)

这道题貌似要用到这个小东西：

Lucas 定理：是用来求 C(n,m) mod p的值,p是素数。

描述为:

Lucas(n,m,p)=C(n%p,m%p)\* Lu   

Lucas(n,0,p)=1;

晓得这个后，题解就自己看了。

上菜啦！！

 
          
```cpp
    #include<iostream>  
    #include<cstring>  
    #define LL long long  
    #define N 1000010  
    using namespace std;  
    const long long  r=1000000007;  
    int x, y;  
    long long n,m;  
    void extend_gcd(int a, int b) {  
        int xx;  
        if (b == 0) {  
            x = 1, y = 0;  
            return;  
        }  
        extend_gcd(b, a % b);  
        xx = x;  
        x = y, y = xx - a / b * y;  
    }  
    int C(int a, int b, int p) {  
        int i;  
        LL resa, resb, res;  
        if (b > a) {  
            return 0;  
        }  
        for (i = 0, resa = 1, resb = 1; i < b; i++) {  
            resa = resa * (a - i) % p, resb = resb * (b - i) % p;  
        }  
         extend_gcd(resb, p);  
         res = (LL) x;  
         res = (res % p + p) % p;  
        res = res * resa % p;  
        return (int) res;  
    }  
    void solve(int n, int m, int p) {  
        int a, b;  
        LL res;  
        res = 1;  
        while (n || m) {  
            a = n % p, b = m % p;  
            res = res * C(a, b, p) % p;  
            n /= p, m /= p;  
        }  
        printf("%I64d\n", res);  
    }  
    int main()  
    {  
        freopen("stone.in","r",stdin);  
        freopen("stone.out","w",stdout);  
        long long t,ans=0;  
        scanf("%I64d%I64d",&n,&m);  
        for (int i=0;i<m;++i)   
        {  
            scanf("%I64d",&t);  
            n-=t;  
        }  
        n-=1,m-=1;  
        solve(n,m,r);  
        return 0;  
    }  

```

---


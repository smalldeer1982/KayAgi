# 挑战

## 题目描述

桃花岛其实也没什么好玩的，黄蓉经常偷偷跑到江湖上与洪七公等人玩。于是，黄药师就经常想一些游戏与女儿玩，为了是把黄蓉留在身边，江湖险恶啊！

这次黄药师又想了一种模拟游戏，游戏是这样的：她把整个桃花岛划分成一个坐标系。游戏开始前，黄蓉站在平面坐标系的一个点上，而她的闺房在坐标系的另一个点上，任何时候，她可以从当前所在点跨一步达到她周围的上、下、左、右四个点，黄药师不断地说四个字“东（E）”、“南（S）”、“西（W）”、“北（N）”，则黄蓉就想象着不断地从一个点走到另一个点，直至到自己的闺房为止。

![](https://cdn.luogu.com.cn/upload/image_hosting/gso383g9.png)

比如，黄蓉开始时站在 $\rm A$ 点，她的家在 $\rm B$ 点，黄药师连续说了一串：$\verb!NNNENNWWWSSW!$，则走了如下一个线路。然后，黄药师会问黄蓉：中间有没有走“弯路”了？即有没有捷径好走？比如，下图中就有多条捷径，可以从 $\rm C$ 走 $\verb!NN!$ 而到 $\rm E$，或走 $\verb!WW!$ 直接到 $\rm D$。

注意：捷径必须是直线。

黄药师听说你是一个程序设计高手，就想请你编个程序帮他测测这个游戏的难度，以便改进游戏规则后再让黄蓉挑战。

你的任务是：找一条最短的捷径。


## 样例 #1

### 输入

```
12
NNNENNWWWSSW
```

### 输出

```
2 3 11 W```

# 题解

## 作者：Ice_Kissღ (赞：32)

添加了一些说明呢 $ qwq $  

哎呀，从今年提高组游过后，我深感模拟的重要性！

于是便写了这道大模拟，借此来练一下手感。

好了，话不多说，我们进入正题：

首先看到这题后，我们会发现，题目要我们求最小的路径长度与其对应的
开始点与结束点。

实际只要求出最小路径其他均可迎刃而解。

再看看题目，你会发现一句关键的话：**捷径必须是直线。**

这意味着小蓉蓉只可找一条笔直的最短路径，而且它的出发点与结束点必定是含有**相同横坐标或相同纵坐标**的！

而我们怎么找到相同横坐标或相同纵坐标呢，不难想到，只用对横纵坐标分别进行排序即可。

而另外一个关于出发点与结束点的问题我们可以通过点编号的大小（也就是小蓉蓉到达的先后）来判断。

**特别提醒：** 如果检索到的两个点编号差为一（它们相邻），则必要舍弃这题最短路经。你问为什么？因为它们之间已经有路了啊！



**那本题即可变为：**

* 在一张给定的图中找到最短的有横坐标或纵坐标相同的两个点的距离，有多组情况时，选起始点最小的；若还存在多组情况，选结束点最大的。

分析结束~

那之后就是轻松的手动模拟了（速度飞快）。

还有一些关键点在代码中提到。
![](https://cdn.luogu.com.cn/upload/image_hosting/k4ey9ysp.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; 
string s;
int minn=1e9;
int here=1e9,to=-1e9;
char xiang;
struct node
{
	int x;int y;
	int bian;
}rong[250005];
bool cmp1(node a,node b)
{
	return a.x<b.x || (a.x==b.x && a.y<b.y);
}
bool cmp2(node a,node b)
{
	return a.y<b.y || (a.y==b.y && a.x<b.x);
}
//两个排序，不用多说。
void jx()
{
	int tmp,a,b;
	char er;
	for(int i=1;i<=n-1;i++)
	{
		if(rong[i].x==rong[i+1].x)//找到相同横坐标时
		{
			tmp=abs(rong[i].y-rong[i+1].y);//记录路径长度
			if(rong[i].bian<rong[i+1].bian)//根据编号大小判断出发点与终点
		    {
			    a=rong[i].bian;
			    b=rong[i+1].bian;		
				if(rong[i].y<rong[i+1].y) er='N';//别忘了方向记录
				else er='S';
                
		    }
		    else //同理
		    {
			    a=rong[i+1].bian;
			    b=rong[i].bian;		
				if(rong[i+1].y<rong[i].y) er='N';
				else er='S';
		    }
			if(a+1==b) continue;//如果编号相邻则已有路径，舍去
			if(minn==tmp)//进行最终决策
			{
				if(here>a) 
				{
					minn=tmp; here=a; to=b; xiang=er;
				}
				else if(here==a)
				{
					if(b>to)
				    {
				    	minn=tmp; here=a; to=b; xiang=er;
					}
				}
			}
			if(minn>tmp)
			{
				minn=tmp; here=a; to=b; xiang=er;
			}
            
	    }	
	}
}
void jy()
{
	int tmp,a,b;
	char er;
	for(int i=1;i<=n-1;i++)
	{
		if(rong[i].y==rong[i+1].y)//找到相同纵坐标时
		{
			tmp=abs(rong[i].x-rong[i+1].x);//记录路径长度
			if(rong[i].bian<rong[i+1].bian)//根据编号大小判断出发点与终点
		    {
			    a=rong[i].bian;
			    b=rong[i+1].bian;		
				if(rong[i].x<rong[i+1].x) er='E';//别忘了方向记录
				else er='W';
		    }
		    else //同理
		    {
			    a=rong[i+1].bian;
			    b=rong[i].bian;		
				if(rong[i+1].x<rong[i].x) er='E';
				else er='W';
		    }
			if(a+1==b) continue;//如果编号相邻则已有路径，舍去
			if(minn==tmp)//进行最终决策
			{
				if(here>a) 
				{
					minn=tmp; here=a; to=b; xiang=er;
				}
				else if(here==a)
				{
					if(b>to)
				    {
				    	minn=tmp; here=a; to=b; xiang=er;
					}
				}
			}
			if(minn>tmp)
			{
				minn=tmp; here=a; to=b; xiang=er;
			}
	    }	
	}
}
int main()
{
	scanf("%d",&n);
	cin>>s;
	rong[0].x=250005;rong[0].y=250005;//防止出现负数。
	for(int i=0;i<n;i++)
	{
		int k=i+1;
		rong[k].bian=k;
		rong[k].x=rong[k-1].x;
		rong[k].y=rong[k-1].y;
		if(s[i]=='N') rong[k].y++;
	    if(s[i]=='W') rong[k].x--;
	    if(s[i]=='E') rong[k].x++;
	    if(s[i]=='S') rong[k].y--;
	}
	sort(rong+1,rong+1+n,cmp1);//横坐标排序。
	jx();//查找。
	sort(rong+1,rong+1+n,cmp2);//纵坐标排序。
	jy();//查找。
	cout<<minn<<" "<<here<<" "<<to<<" "<<xiang;
	return 0;
}
```


完结撒花 $QAQ$

求赞赞！









---

## 作者：hegm (赞：6)

#### 写在前面
这道题有点水，不应该是紫题难度。而且也不像是一道模拟题 : )

------------

最短捷径是捷径最短而不是总长度最短！！！

最短捷径是捷径最短而不是总长度最短！！！

最短捷径是捷径最短而不是总长度最短！！！

重要的事情说三遍 ~~(别问我为什么觉得重要)~~

[最短捷径的解释](https://www.luogu.com.cn/discuss/438377)

### 分析

做模拟题最重要的是**理清楚题意**

题意简化：

给你一些点，让你求出横坐标或纵坐标相同的点之间的最短距离(**权重为:1.距离 2.起始点的编号 3.终止点的编号**)

由于 $x,y$ 之间不会互相影响因此我们可以分开做~

用 `sqrt` 按找 $x,y$ 分别排序

```cpp
struct node
{
	int x,y,num;//num为当前点的编号，相连的点 
}k[350003];
bool cmpx(node a,node b){return (a.x<b.x)||(a.x==b.x&&a.y<b.y);}
bool cmpy(node a,node b){return (a.y<b.y)||(a.y==b.y&&a.x<b.x);}
//x和y的cmp
```

排序后**只需要比对临近的两点**即可,即 `k[i].x(y)` 与 `k[i+1].x(y)`。

如果两点之间有连线，即 `abs(k[i].num-k[i+1].num) =1`，`continue` 即可。

查找：

```cpp
void fx()
{
	char f2;
	int a1,f1,t1;
	sort(k,k+n+1,cmpx);
	for(int i=0;i<=n-1;i++)
	{
		if(k[i].x==k[i+1].x)
		{
			if(abs(k[i].num-k[i+1].num)==1)continue;//两点之间有连线
			a1=abs(k[i].y-k[i+1].y);//两点距离
			int s,t;
			if(k[i].num<k[i+1].num)s=i,t=i+1;//判断谁是from，谁是to
            		//s存储from的编号,t存储to的编号
			else s=i+1,t=i;
			f1=k[s].num;
			t1=k[t].num;
			if(k[s].y<k[t].y)f2='E';//判断方向
			else f2='W';
			if(ans==a1)//判断是否需要替换答案
			{
				if(from>f1)ans=a1,from=f1,to=t1,face=f2;
				else if(from==f1&&to<t1)ans=a1,from=f1,to=t1,face=f2;
			}
			if(ans>a1)ans=a1,from=f1,to=t1,face=f2;
		}
	}
}
void fy()//与fx()几乎一样
{
	char f2;
	int a1,f1,t1;
	sort(k,k+n+1,cmpy);
	for(int i=0;i<=n-1;i++)
	{
		if(k[i].y==k[i+1].y)
		{
			if(abs(k[i].num-k[i+1].num)==1)continue;
			a1=abs(k[i].x-k[i+1].x);
			int s,t;
			if(k[i].num<k[i+1].num)s=i,t=i+1;
			else s=i+1,t=i;
			f1=k[s].num;
			t1=k[t].num;
			if(k[s].x<k[t].x)f2='N';
			else f2='S';
			if(ans==a1)
			{
				if(from>f1)ans=a1,from=f1,to=t1,face=f2;
				else if(from==f1&&to<t1)ans=a1,from=f1,to=t1,face=f2;
			}
			if(ans>a1)ans=a1,from=f1,to=t1,face=f2;
		}
	}
}
```

谢谢你看到这里~
下面上全部代码


------------

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
	return f*x;
}
const int ho=250003;//ho是为了避免出现负的坐标
int n;
int ans=1e8,from=1e8,to=-1e8;//一定要付初值不然会死得很惨~
char face;
string c;
int nx=ho,ny=ho,x=ho,y=ho;
struct node
{
	int x,y,num;
}k[350003];
bool cmpx(node a,node b){return (a.x<b.x)||(a.x==b.x&&a.y<b.y);}
bool cmpy(node a,node b){return (a.y<b.y)||(a.y==b.y&&a.x<b.x);}
void fx()
{
	char f2;
	int a1,f1,t1;
	sort(k,k+n+1,cmpx);
	for(int i=0;i<=n-1;i++)
	{
		if(k[i].x==k[i+1].x)
		{
			if(abs(k[i].num-k[i+1].num)==1)continue;
			a1=abs(k[i].y-k[i+1].y);
			int s,t;
			if(k[i].num<k[i+1].num)s=i,t=i+1;
			else s=i+1,t=i;
			f1=k[s].num;
			t1=k[t].num;
			if(k[s].y<k[t].y)f2='E';
			else f2='W';
			if(ans==a1)
			{
				if(from>f1)ans=a1,from=f1,to=t1,face=f2;
				else if(from==f1&&to<t1)ans=a1,from=f1,to=t1,face=f2;
			}
			if(ans>a1)ans=a1,from=f1,to=t1,face=f2;
		}
	}
}
void fy()
{
	char f2;
	int a1,f1,t1;
	sort(k,k+n+1,cmpy);
	for(int i=0;i<=n-1;i++)
	{
		if(k[i].y==k[i+1].y)
		{
			if(abs(k[i].num-k[i+1].num)==1)continue;
			a1=abs(k[i].x-k[i+1].x);
			int s,t;
			if(k[i].num<k[i+1].num)s=i,t=i+1;
			else s=i+1,t=i;
			f1=k[s].num;
			t1=k[t].num;
			if(k[s].x<k[t].x)f2='N';
			else f2='S';
			if(ans==a1)
			{
				if(from>f1)ans=a1,from=f1,to=t1,face=f2;
				else if(from==f1&&to<t1)ans=a1,from=f1,to=t1,face=f2;
			}
			if(ans>a1)ans=a1,from=f1,to=t1,face=f2;
		}
	}
}
int main()
{
	n=read();
	k[0].x=ho;
	k[0].y=ho;
	k[0].num=0;
	cin>>c;
	for(int i=1;i<=n;i++)
	{
		if(c[i-1]=='N')nx++;
		else if(c[i-1]=='S')nx--;
		else if(c[i-1]=='E')ny++;
		else if(c[i-1]=='W')ny--;
		k[i].x=nx;
		k[i].y=ny;
		k[i].num=i;
	}
	fx();
	fy();
	cout<<ans<<" "<<from<<" "<<to<<" "<<face<<endl;
	return 0;
}
```



------------

**有一点需要注意，读入方向最好使用string，用char可能会出现莫名其妙的错误。** ~~(别问我怎么知道的)~~

完结撒花~谢谢观看

---

## 作者：zombie462 (赞：4)

## 第一篇题解？

### 话说从来没为灰题写过题解诶

## 好吧开始进入正题

首先因为题目中出了一点岔子，导致有一张图没有显示。不过没关系，这道题目的大意就是：

你有$n$个操作，每个操作使你向四个方向移动1格，你要找到两个次序不相邻但坐标位于同一平行与坐标轴的直线上的点。

~~什么，看不懂？~~

那我们直接开始讲程序

首先我们对坐标进行排序，分别按$x$和$y$排。我们先对东西走向的进行操作，再对南北走向的进行操作。

当两点$x$坐标或$y$坐标相同时，就判断两点的距离（就是捷径长度），如果这两点原来不是相邻的，那么就记录下来。

```
#include <bits/stdc++.h>
using namespace std;
struct node{
    int num,x,y;
}a[1111111];
int n,l,r,ll,rr;
int ans;
char dir,d,ch;
bool cmp1(node xx,node yy){//stl用，但最后删掉了（方便pascal党）
    return xx.x<yy.x || xx.x==yy.x && xx.y<yy.y;
}
bool cmp2(node xx,node yy){
    return xx.y<yy.y || xx.y==yy.y && xx.x<yy.x;
}
void qsort1(int l,int r){//这才是真正的快排，按x排序
    int i=l,j=r;
    node k=a[(l+r)/2];
    do{
        while ((a[i].x<k.x)||((a[i].x==k.x)&&(a[i].y<k.y))) i++;
        while ((a[j].x>k.x)||((a[j].x==k.x)&&(a[j].y>k.y))) j--;
        if (i<=j){
            node t=a[i];a[i]=a[j];a[j]=t;
            i++;j--;
        }
    }while (!(i>j));
    if (i<r) qsort1(i,r);
    if (j>l) qsort1(l,j);
}
void qsort2(int l,int r){//按y排序
    int i=l,j=r;
    node k=a[(l+r)/2];
    do{
        while ((a[i].y<k.y)||((a[i].y==k.y)&&(a[i].x<k.x))) i++;
        while ((a[j].y>k.y)||((a[j].y==k.y)&&(a[j].x>k.x))) j--;
        if (i<=j){
            node t=a[i];a[i]=a[j];a[j]=t;
            i++;j--;
        }
    }while (!(i>j));
    if (i<r) qsort2(i,r);
    if (j>l) qsort2(l,j);
}
int init(){
    scanf("%d",&n);
    for (int i=1;i<=n;++i){
        scanf("%c",&ch);
        while (ch!='W' && ch!='N' && ch!='S' && ch!='E') scanf("%c",&ch);//注意，这句话必须加，否则只能拿80分！！！！！
        a[i]=a[i-1];
        a[i].num=i;//这个点的序号
        if (ch=='E') a[i].y++;
        else if (ch=='W') a[i].y--;
        else if (ch=='N') a[i].x++;
        else if (ch=='S') a[i].x--;//模拟主人公的走动，获得他的坐标
    }
}
bool pd(int x,int y,int z){//判断新的解是否满足题目中杂七杂八的条件
    if (x<ans) return(true);
    if (x>ans) return(false);
    if (l>y) return(true);
    if (l<y) return(false);
    if (r<z) return(true);
    return(false);
}
void doing1(){//两点x坐标相同
    for (int i=1;i<n;++i){
        if (a[i].x==a[i+1].x){
            int dis=a[i+1].y-a[i].y;//两点的距离
            if (a[i].num<a[i+1].num){
                ll=a[i].num;
                rr=a[i+1].num;
                dir='E';//向东
            }
            else{
                ll=a[i+1].num;
                rr=a[i].num;
                dir='W';//向西
            }
            if (ll+1==rr) continue;//如果这两个点相邻，当然满足上面的条件，但是不合题意
            if (pd(dis,ll,rr)){//如果这个解被采纳
                ans=dis;l=ll;r=rr;
                d=dir;
            }
        }
    }
}
void doing2(){//和doing1同理
    for (int i=1;i<n;++i){
        if (a[i].y==a[i+1].y){
            int dis=a[i+1].x-a[i].x;
            if (a[i].num<a[i+1].num){
                ll=a[i].num;
                rr=a[i+1].num;
                dir='N';
            }
            else{
                ll=a[i+1].num;
                rr=a[i].num;
                dir='S';
            }
            if (ll+1==rr) continue;
            if (pd(dis,ll,rr)){
                ans=dis;l=ll;r=rr;
                d=dir;
            }
        }
    }
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    
    init();
    ans=2147483647;
    qsort1(1,n);//可以换成 sort(a+1,a+1+n,cmp1);
    doing1();
    qsort2(1,n);//可以换成 sort(a+1,a+1+n,cmp2);
    doing2();
    printf("%d %d %d %c\n",ans,l,r,d);
    
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

程序比较长，但很多都是快排占用的，C++党只要把两个快排换成stl的就可以了（cmp已经给出）

注意，C++读入的时候必须判断读入的数据的合法性，不然会出错（pascal就没有这么麻烦了）

----

### THE END

---

## 作者：江户川·萝卜 (赞：2)

~~第二道大模拟，祭之~~

不过这道题感觉不像大模拟的亚子？

---
首先注意到一句话：
>捷径必须是直线。

所以起点终点要么横坐标相同要么纵坐标相同。

那就好办了鸭！

横纵坐标分别求一次就可以了，找到每一对 横、纵坐标有一个相同 的点找到之中的最短距离即可。

注意不能出现本来就能从起点走向终点的“捷径”。

---

###  代码解析

为了方便排序，先为每一个点创立一个结构体：
```cpp
struct path{
	int x,y,st;
}p[250005];
```
`x` , `y` 分别是横纵坐标，`st` 是这个点的编号。

然后，根据输入的 `NESW` 来初始化每一个点。

```cpp
	p[0].x=p[0].y=p[0].st=0;//设起始点为（0,0）
	for(int i=1;i<=n;i++){
		ch=getchar();
		while(ch<'A'||ch>'Z') ch=getchar();//防止读取到换行、空格
		switch(ch){
			case 'N':p[i].x=p[i-1].x+1;p[i].y=p[i-1].y;break;
			case 'S':p[i].x=p[i-1].x-1;p[i].y=p[i-1].y;break;
			case 'W':p[i].y=p[i-1].y-1;p[i].x=p[i-1].x;break;
			case 'E':p[i].y=p[i-1].y+1;p[i].x=p[i-1].x;break;
		}
		p[i].st=i;
	}
```

先根据横坐标排一次序。

```cpp
bool cmp1(path a,path b){
	return a.x<b.x||a.x==b.x&&a.y<b.y;
}
```
```cpp
	sort(p+1,p+n+1,cmp1);
```

注意此处不能仅根据横坐标排序，在横坐标相同时应按照纵坐标排序。

这样处理后，在算最短距离时就可以只算纵坐标相邻的两个点的距离，大大节省时间。

然后是**重点**部分，用注释的方式讲解。

```cpp
	for(int i=2;i<=n;i++){
		if(p[i].x!=p[i-1].x||abs(p[i].st-p[i-1].st)==1) continue;
		// 如果与前一个点横坐标不同则不能形成捷径。
		// 如果两个点编号是相邻的则不能算作“捷径”。
		int d=abs(p[i].y-p[i-1].y),ssp,eep;
		// d是两点的距离,ssp是两点中的起点，eep是两点中的终点
		char ddir;//捷径的方向
		if(p[i].st<p[i-1].st){//如果纵坐标大的反而编号小
			ssp=p[i].st;eep=p[i-1].st;//起点是编号小的那一个
			ddir='W';//方向是向西（需要自己推一下哦）
		}
		else{//同理
			ssp=p[i-1].st;eep=p[i].st;
			ddir='E';
		}
		bool chag=false;//是否更新答案
		if(d<mind) chag=true;
		//mind存储最短距离
		//如果当前距离小于最短距离则更新
		else if(d==mind){//如果当前距离等于最短距离
			if(ssp<sp) chag=true;//选择起始点编号小的那一个
			else if(ssp==sp){//如果起始点相同
				if(eep>ep) chag=true;//选择终点编号大的那一个
			}
		}
		if(chag){//如果需要更新
			sp=ssp;ep=eep;dire=ddir;mind=d;
		}
```
---
纵坐标的处理也同理，代码几乎一致，不再赘述。

如果有疑问见下面代码。

### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct path{
	int x,y,st;
}p[250005];
bool cmp1(path a,path b){
	return a.x<b.x||a.x==b.x&&a.y<b.y;
}
bool cmp2(path a,path b){
	return a.y<b.y||a.y==b.y&&a.x<b.x;
}
int n,mind,sp,ep;
char ch,dire;
int main(){
	scanf("%d",&n);
	p[0].x=p[0].y=p[0].st=0;
	for(int i=1;i<=n;i++){
		ch=getchar();
		while(ch<'A'||ch>'Z') ch=getchar();
		switch(ch){
			case 'N':p[i].x=p[i-1].x+1;p[i].y=p[i-1].y;break;
			case 'S':p[i].x=p[i-1].x-1;p[i].y=p[i-1].y;break;
			case 'W':p[i].y=p[i-1].y-1;p[i].x=p[i-1].x;break;
			case 'E':p[i].y=p[i-1].y+1;p[i].x=p[i-1].x;break;
		}
		p[i].st=i;
	}
	mind=250001;
	sort(p+1,p+n+1,cmp1);
	for(int i=2;i<=n;i++){
		if(p[i].x!=p[i-1].x||abs(p[i].st-p[i-1].st)==1) continue;
		int d=abs(p[i].y-p[i-1].y),ssp,eep;
		char ddir;
		if(p[i].st<p[i-1].st){
			ssp=p[i].st;eep=p[i-1].st;
			ddir='W';
		}
		else{
			ssp=p[i-1].st;eep=p[i].st;
			ddir='E';
		}
		bool chag=false;
		if(d<mind) chag=true;
		else if(d==mind){
			if(ssp<sp) chag=true;
			else if(ssp==sp){
				if(eep>ep) chag=true;
			}
		}
		if(chag){
			sp=ssp;ep=eep;dire=ddir;mind=d;
		}
	}
	sort(p+1,p+n+1,cmp2);
	for(int i=2;i<=n;i++){
		if(p[i].y!=p[i-1].y||abs(p[i].st-p[i-1].st)==1) continue;
		int d=abs(p[i].x-p[i-1].x),ssp,eep;
		char ddir; 
		if(p[i].st<p[i-1].st){
			ssp=p[i].st;eep=p[i-1].st;
			ddir='S';
		}
		else{
			ssp=p[i-1].st;eep=p[i].st;
			ddir='N';
		}
		bool chag=false;
		if(d<mind) chag=true;
		else if(d==mind){
			if(ssp<sp) chag=true;
			else if(ssp==sp){
				if(eep>ep) chag=true;
			}
		}
		if(chag){
			sp=ssp;ep=eep;dire=ddir;mind=d;
		}
	}
	cout<<mind<<" "<<sp<<" "<<ep<<" "<<dire;
	return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：2)

谔零谔零年谔月谔十谔日，Update,修了排版。

麻烦管理重新过下！

上手鉴定大模拟······

众所周知，大模拟一般不卡常，开个O2基本上怎么写都可以（某某毒瘤除外）

于是平时不敢用的，各种常数大的算法/数据结构，全部都能随便用了！

介绍一种~~滥用红黑树的~~代码稍短的方法（其实感觉还是靠数据水过的吧）。

不知道有没有想错，我的理解是能反复经过同一个点（如果不是那么下方分析可简化，理解后自行完成，并不难）。

题目转化一下：
```plain
要在给定折线（每一段都是水平/垂直的且不是很长）上找到两个点，

它们x坐标与y坐标有且仅有一个相等，

要求距离最短的前提下，

第一个点编号最小，

在此基础上第二个点编号最大
```
首先考虑怎么满足同一x坐标。（或同一y坐标，不过同理）

juruo也没想太多······每个x坐标拉一个set维护所有x坐标为它的点集，按y坐标大小排序。（其实vector+时候排序也可以~~但我太懒了~~）

不难发现最终的点一定是相邻两点。

为此需要把整个坐标系平移一下保证每一步横纵坐标非负。

考虑到还对编号有要求，所以还要存个编号。

juruo本人想到3种实现方法：
```plain
1.在set中存的类型为point（自定义二元组）,第一个数是y坐标，第二个数是到达(x,y)点的最小编号，用map存下到达(x,y)点的最大编号。
2.同上，大小互换。
3.用2个map分别存最大，最小值。
```
其实没什么区别~~反正窝码的都要吸氧才能过~~。

记录下来之后······就没什么好说的了暴力遍历set，判断最小编号的差是不是1（<-靠数据水过，有反例），判断编号大小，更新长度和方向······

先不说了上代码吧，相信dalao们已经会了。

注：二维map为了省一只log(听人说嵌套是2只)故采用pair.
```cpp
//方法1，第一次提交时的，码风巨丑（
#include<bits/stdc++.h>
using namespace std;
const int eps=250009;
const int N=(eps<<1);
struct point{
	int p,id;
	bool operator < (const point&w)const{
		return p<w.p;
	}
	bool operator == (const point&w)const{
		return p==w.p;
	}
	point(){}
	point(int p,int id):p(p),id(id){}
};
set<point>sx[N],sy[N];
map<pair<int,int>,int>mp;
int n;
char s[eps];
int st,ed,dx,dy,num=INT_MAX;
char ans;
int main(){
	scanf("%d%s",&n,s);
	register int x=eps,y=eps;
	mp[make_pair(eps,eps)]=-1;
	sx[eps].insert(point(eps,-1));
	sy[eps].insert(point(eps,-1));
	for(register int i=0;i<n;++i){
		if(s[i]=='N')++x;
		if(s[i]=='S')--x;
		if(s[i]=='W')--y;
		if(s[i]=='E')++y;
		if(!mp.count(make_pair(x,y)))sx[x].insert(point(y,i)),sy[y].insert(point(x,i));
		mp[make_pair(x,y)]=max(mp[make_pair(x,y)],i);
	
	}
	for(register int i=0;i<N;++i)if(sx[i].size()>1){
		for(register set<point>::iterator it=sx[i].begin();it!=--sx[i].end();){
			register point a=*it;
			register point b=*++it;
			if(b.p-a.p>num||abs(b.id-a.id)==1)continue;
			if(a.id>b.id)swap(a,b);
			if(abs(b.p-a.p)==num){
				if(a.id>st||a.id==st&&mp[make_pair(i,b.p)]<ed)continue;
			}
			st=a.id,ed=mp[make_pair(i,b.p)],dx=0,dy=b.p-a.p,num=abs(dy);
		}
	}
	for(register int i=0;i<N;++i)if(sy[i].size()>1){
		for(register set<point>::iterator it=sy[i].begin();it!=--sy[i].end();){
			register point a=*it;
			register point b=*++it;
			if(b.p-a.p>num||abs(b.id-a.id)==1)continue;
			if(a.id>b.id)swap(a,b);
			if(abs(b.p-a.p)==num){
				if(a.id>st||a.id==st&&mp[make_pair(b.p,i)]<ed)continue;
			}
			st=a.id,ed=mp[make_pair(b.p,i)],dx=b.p-a.p,dy=0,num=abs(dx);
		}
	}
	if(!dy)ans=(dx>0?'N':'S');
	else ans=(dy>0?'E':'W');
	printf("%d %d %d %c\n",num,st+1,ed+1,ans);
    return 0;
}
```
```cpp
//方法三。
#include<bits/stdc++.h>
using namespace std;
const int eps=250009;
const int N=(eps<<1);
set<int>sx[N],sy[N];
map<pair<int,int>,int>minp,maxp;
int n;
char s[eps];
int st,ed,dx,dy,num=INT_MAX;
char ans;
int main(){
	scanf("%d%s",&n,s);
	register int x=eps,y=eps;
	minp[make_pair(eps,eps)]=maxp[make_pair(eps,eps)]=-1;
	sx[eps].insert(eps);
	sy[eps].insert(eps);
	for(register int i=0;i<n;++i){
		if(s[i]=='N')++x;
		if(s[i]=='S')--x;
		if(s[i]=='W')--y;
		if(s[i]=='E')++y;
		pair<int,int>p=make_pair(x,y);
		if(!maxp.count(p))sx[x].insert(y),sy[y].insert(x);
		maxp[p]=max(maxp[p],i);
		if(!minp.count(p)||minp[p]>i)minp[p]=i;
	}
	//谔谔1 
	for(register int i=0;i<N;++i)if(sx[i].size()>1){
		for(register set<int>::iterator it=sx[i].begin();it!=--sx[i].end();){
			register int a=*it,b=*++it;
			pair<int,int>pa=make_pair(i,a),pb=make_pair(i,b);
			register int na=minp[pa],nb=minp[pb];
			if(b-a>num||abs(na-nb)==1)continue;
			if(na>nb)swap(a,b),swap(na,nb),swap(pa,pb);
			if(abs(a-b)==num){
				if(na>st||na==st&&maxp[pb]<ed)continue;
			}
			st=na,ed=maxp[pb],dx=0,dy=b-a,num=abs(dy);
		}
	}
	//谔谔2 
	for(register int i=0;i<N;++i)if(sy[i].size()>1){
		for(register set<int>::iterator it=sy[i].begin();it!=--sy[i].end();){
			register int a=*it,b=*++it;
			pair<int,int>pa=make_pair(a,i),pb=make_pair(b,i);
			register int na=minp[pa],nb=minp[pb];
			if(b-a>num||abs(na-nb)==1)continue;
			if(na>nb)swap(a,b),swap(na,nb),swap(pa,pb);
			if(abs(a-b)==num){
				if(na>st||na==st&&maxp[pb]<ed)continue;
			}
			st=na,ed=maxp[pb],dx=b-a,dy=0,num=abs(dx);
		}
	}
	//谔谔3 
	if(!dy)ans=(dx>0?'N':'S');
	else ans=(dy>0?'E':'W');
	printf("%d %d %d %c\n",num,st+1,ed+1,ans);
    return 0;
}
```
方法一代码只有69行，方法三只有57行！

而且以方法三为栗子，谔谔1到谔谔2（见注释）与谔谔2到谔谔3之间是几乎完全一样的！

Ctrl+C+V几乎不怎么用改！

所以······STL真好。

初步鉴定$\operatorname{O}(n\operatorname{lg}n)$或$\operatorname{O}(n\operatorname{lg}^2n)$，如果是两只$\operatorname{lg}$的话把sort改成vector离线排序（当然也珂以链式前向星）就变单$\operatorname{lg}$了~

最后~~不要脸地~~推销[博客](https://www.luogu.com.cn/blog/2007100723874wxz/)和[语言](https://www.luogu.com.cn/blog/2007100723874wxz/define)

---

## 作者：GoodCoder666 (赞：1)

**STL 大法好**

思路都很清晰，先以起始点为原点 $(0,0)$ 建立平面直角坐标系，分别计算出每一步走到的位置。

对于每个点，在 $x$ 轴和 $y$ 轴两个方向分别考虑是否可以直接走捷径（即向左/向上或向右/向下**不沿原来的路径走到别的位置**）。

下面考虑实现。看到别的 dalao 们都用的 `sort` 直接排序，~~貌似没学到 STL 的精髓~~，本蒟蒻提供一种睿（ruo）智的做法：

```cpp
unordered_map<int, map<int, int>> X, Y;
```

其中，`X[i][j]` 表示坐标为 $(i,j)$ 的位置的最大编号，`Y[i][j]` 表示坐标为 $(j,i)$ 的位置的最大编号。对于每个位置，直接找到其在 `X` 和 `Y` 两个 `map` 中的位置，并对左右的元素进行考察，再更新答案即可。

用嵌套 `map` 常数大无法避免，不过最短代码还是有的：
```cpp
#include <cstdio>
#include <vector>
#include <map>
#include <unordered_map>
#define maxn 250005
using namespace std;

using pii = pair<int, int>;
inline void setmax(int& x, int y) { if(x < y) x = y; }

char s[maxn];

inline pii dt(char c)
{
	switch(c)
	{
		case 'N': return pii(-1, 0);
		case 'E': return pii(0, 1);
		case 'S': return pii(1, 0);
		default: return pii(0, -1);
	}
}

#define move if(i < n) {auto [dx, dy] = dt(s[i]); x += dx, y += dy;}

int main()
{
	int n;
	scanf("%d%s", &n, s);
	int x = 0, y = 0, d_ans = 1e9, f_ans = 0, t_ans = 0;
	char dir_ans;
	auto ok = [&](int dis, int from, int to) -> bool {
		if(dis != d_ans) return dis < d_ans;
		if(from != f_ans) return from < f_ans;
		return to > t_ans;
	};
	auto update = [&](int dis, int from, int to, char dir) {
		if(ok(dis, from, to))
			d_ans = dis, f_ans = from, t_ans = to, dir_ans = dir;
	};
	unordered_map<int, map<int, int>> X, Y;
	x = y = 0;
	for(int i=0; i<=n; i++)
	{
		setmax(X[x][y], i);
		setmax(Y[y][x], i);
		move
	}
	x = y = 0;
	vector<pii> ans;
	for(int i=0; i<=n; i++)
	{
		auto get_ans = [&](auto& m, int y, char left, char right) {
			auto it = m.find(y);
			// left
			if(it != m.begin())
			{
				it --;
				int j = it->second;
				if(j > i + 1) update(y - it->first, i, j, left);
				it ++;
			}
			// right
			if(++it != m.end())
			{
				int j = it->second;
				if(j > i + 1) update(it->first - y, i, j, right);
			}
		};
		get_ans(X[x], y, 'W', 'E');
		get_ans(Y[y], x, 'N', 'S');
		move
	}
	printf("%d %d %d %c\n", d_ans, f_ans, t_ans, dir_ans);
	return 0;
}
```
这段代码没有压行，共 $76$ 行，整体相对比较简洁，可以算是最短代码吧。

*温馨提醒：STL 配合 `lambda` 表达式效果更佳，见代码。*

### 顺便插一句嘴

无意中发现了[这组 hack 数据](https://www.luogu.com.cn/discuss/485540)，正确输出应该是 `1 0 5 N`，然而很多题解没有考虑从 $0$ 号点开始的捷径，输出了 `1 1 4 N`（上面的代码输出结果正确），希望能把这组数据加到测试点里。

---

## 作者：__shadow__ (赞：1)

本题就是要找到最短的捷径。

注意事项：

+ 捷径必须是直线。
+ 要求捷径最短而非总路程最短。
+ 捷径不与原有的路重合

既然在同一直线上，则该捷径的起点与终点的横坐标或纵坐标相等。要把横坐标或纵坐标相同的聚在一起只需要排个序即可。

捷径最短的话（以横坐标相等举例），只需要以 $x$ 为第一关键字，以 $y$ 为第二关键字排序后，找相邻的两个并求最短就好。

不与原有路径重合。因为把每一个点都记下来了，所以起点与终点的序号只差 $1$ 就说明原来已有路径。

分析结束，看代码。

```cpp
#include<algorithm> 
#include<cstdio>
using namespace std;
const int N = 250000 + 5;
struct node
{
	int x, y, id;//x,y 为横纵坐标; id 是序号 !:从1开始 
}a[N];
bool cmpx(node a, node b)//以 x 为第一关键字 
{
	return a.x == b.x ? a.y < b.y : a.x < b.x;
}
bool cmpy(node a, node b)//以 y 为第一关键字 
{
	return a.y == b.y ? a.x < b.x : a.y < b.y;
}
int n;
char s[N];
struct stsearr//答案,整合后方便赋值 
{
	int lenth;//长度 
	int head, tail;//起点和终点 
	char fang;//方向 
}ans;
void do_x()//查找竖的捷径 
{
	stsearr t;
	for (int i = 2;i <= n; i++)
	{
		if (a[i].x == a[i - 1].x)//竖着的直线 
		{
			t.lenth = a[i].y - a[i - 1].y;//排序中以从小到大 
			if (a[i].id < a[i - 1].id)//id 小的是起点 
			{
				t.fang = 'S';
				t.head = a[i].id;
				t.tail = a[i - 1].id;
			}
			else
			{
				t.fang = 'N';
				t.head = a[i - 1].id;
				t.tail = a[i].id;
			}
			if (t.head + 1 == t.tail)//判断是否与原有路径重合 
				continue;
			if (t.lenth < ans.lenth)//更新答案 
				ans = t;
			else if (t.lenth == ans.lenth)
			{
				if (t.head < ans.head)
					ans = t;
				else if (t.head == ans.head)
					if (t.tail > ans.tail)
						ans = t;
			}
		}
	}
}
void do_y()//查找竖的捷径 
{
	stsearr t;
	for (int i = 2;i <= n; i++)//与上同理 
	{
		if (a[i].y == a[i - 1].y)
		{
			t.lenth = a[i].x - a[i - 1].x;
			if (a[i].id < a[i - 1].id)
			{
				t.fang = 'W';
				t.head = a[i].id;
				t.tail = a[i - 1].id;
			}
			else
			{
				t.fang = 'E';
				t.head = a[i - 1].id;
				t.tail = a[i].id;
			}
			if (t.head + 1 == t.tail)
				continue;
			if (t.lenth < ans.lenth)
				ans = t;
			else if (t.lenth == ans.lenth)
			{
				if (t.head < ans.head)
					ans = t;
				else if (t.head == ans.head)
					if (t.tail > ans.tail)
						ans = t;
			}
		}
	}
}
signed main()
{
	scanf ("%d", &n);
	scanf ("%s", s + 1);
	//小技巧:这样可以从 1 下标开始读入 
	for (int i = 1;i <= n; i++)
	{
		a[i].id = i;
		a[i].x = a[i - 1].x;
		a[i].y = a[i - 1].y;
		if (s[i] == 'N')//处理四种方向 
			a[i].y++;
		else if (s[i] == 'E')
			a[i].x++;
		else if (s[i] == 'W')
			a[i].x--;
		else if (s[i] == 'S')
			a[i].y--;
	}
	ans.lenth = 1e9;//找最小值,赋最大值 
	sort(a + 1, a + n + 1, cmpx);
	do_x();
	sort(a + 1, a + n + 1, cmpy);
	do_y();
	printf ("%d %d %d %c", ans.lenth, ans.head, ans.tail, ans.fang);
	return 0;
} 
```

希望可以帮到大家。

如有错误欢迎私信指出。

---

## 作者：miao5 (赞：1)

题面也是十分简洁了。

就是我们必须在一条路上找到一条捷径。

再看一遍题，我们发现捷径必须是直的。这意味着这条捷径两点的横坐标或者是纵坐标中的一个必须是相同的。

那如何找到横纵坐标相同的两个点呢？

hmmmmmm……

**排序！**

本题就变为了：在一张图中找最短的横坐标或纵坐标相同的两个点的距离。

之后就是模拟了~~~

code:

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int n; 
string s;
int ans1=1e9;
int ans2=1e9,ans3=-1e9;
char ans4;
struct node{
	int x;
	int y;
	int e;
}m[250005];
bool cmp1(node a,node b){return a.x<b.x||(a.x==b.x&&a.y<b.y);}
bool cmp2(node a,node b){return a.y<b.y||(a.y==b.y&&a.x<b.x);}//两个排序函数。 
void find_x(){
	int num,a,b;
	char p;
	for(int i=1;i<=n-1;i++){
		if(m[i].x==m[i+1].x){//找到相同坐标 
			num=abs(m[i].y-m[i+1].y);//记录长度 
			if(m[i].e<m[i+1].e){//判断出发终止点 
			    a=m[i].e;
			    b=m[i+1].e;		
				if(m[i].y<m[i+1].y) p='N';//记录方向
				else p='S';
		    }
		    else{
			    a=m[i+1].e;
			    b=m[i].e;		
				if(m[i+1].y<m[i].y) p='N';
				else p='S';
		    }//另一种 
			if(a+1==b) continue;//如果他们俩已经有路径，不要 
			if(ans1==num){//判断储存答案 
				if(ans2>a){
					ans1=num; 
					ans2=a; 
					ans3=b; 
					ans4=p;
				}
				else if(ans2==a){
					if(b>ans3){
				    	ans1=num; 
						ans2=a; 
						ans3=b; 
						ans4=p;
					}
				}
			}
			if(ans1>num){
				ans1=num; 
				ans2=a; 
				ans3=b; 
				ans4=p;
			}
            
	    }	
	}
}
void find_y(){//和上面的一样，只不过是从南北方向转换成东西方向 
	int num,a,b;
	char p;
	for(int i=1;i<=n-1;i++){
		if(m[i].y==m[i+1].y){
			num=abs(m[i].x-m[i+1].x);
			if(m[i].e<m[i+1].e){
			    a=m[i].e;
			    b=m[i+1].e;		
				if(m[i].x<m[i+1].x) p='E';
				else p='W';
		    }
		    else{
			    a=m[i+1].e;
			    b=m[i].e;		
				if(m[i+1].x<m[i].x) p='E';
				else p='W';
		    }
			if(a+1==b) continue;
			if(ans1==num){
				if(ans2>a){
					ans1=num; 
					ans2=a; 
					ans3=b; 
					ans4=p;
				}
				else if(ans2==a){
					if(b>ans3){
				    	ans1=num; 
						ans2=a; 
						ans3=b; 
						ans4=p;
					}
				}
			}
			if(ans1>num){
				ans1=num; 
				ans2=a; 
				ans3=b; 
				ans4=p;
			}
	    }	
	}
}
int main(){
	cin>>n;
	cin>>s;
	m[0].x=0x7fffffff;
	m[0].y=0x7fffffff;
	for(int i=0;i<n;i++){
		int k=i+1;
		m[k].e=k;
		m[k].x=m[k-1].x;
		m[k].y=m[k-1].y;
		if(s[i]=='N') m[k].y++;
	    if(s[i]=='W') m[k].x--;
	    if(s[i]=='E') m[k].x++;
	    if(s[i]=='S') m[k].y--;
	}
	sort(m+1,m+1+n,cmp1);
	find_x();
	sort(m+1,m+1+n,cmp2);
	find_y();//排序与查找 
	cout<<ans1<<" "<<ans2<<" "<<ans3<<" "<<ans4;//输出 
	return 0;
}
```


---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P1686)

看到关键词：**捷径必须是直线**。

那也就意味着捷径中的所有点要么横坐标相同要么纵坐标相同。

因此我们可以先找出所有横坐标或纵坐标相同的点，然后按他们不同的那一个坐标排序，捷径就是相邻两个点的距离。

比如样例一：

我们先将所给出的行走路线处理出来。

```
(0,0)
(1,0)
(2,0)
(3,0)
(3,1)
(4,1)
(5,1)
(5,0)
(5,-1)
(5,-2)
(4,-2)
(3,-2)
(3,-3)
```

然后找到所有横坐标相同的点。

```
(0,0)
(1,0)
(2,0)
(3,0),(3,1),(3,-2),(3,-3)
(4,1),(4,-2)
(5,1),(5,0),(5,-1),(5,-2)
```

然后按纵坐标排序。

```
(0,0)
(1,0)
(2,0)
(3,-3),(3,-2),(3,0),(3,1)
(4,-2),(4,1)
(5,-2),(5,-1),(5,0),(5,1)
```

那么捷径就是：

$(3,-3)\to(3,-2),(3,-2)\to(3,0),(3,0)\to(3,1),(4,-2)\to(4,1),(5,-2)\to(5,-1),(5,-1)\to(5,0),(5,0)\to(5,1)$。

之后纵坐标也一样操作一次就行了。

但是这样算出来最短的捷径长度为 $1$，为什么？

原因是有的点是相邻的，比如第一步走 $(1,0)$，第二步走 $(1,1)$，虽然横坐标相同，但不算是捷径。

解决办法是判断路径起点和终点的编号是否不相邻。

如果相邻证明这个不是捷径，否则就是捷径。

那题目就转变为：

给出一条路径，找出两个点使得这两个点距离最短且横坐标或纵坐标相同且编号不相邻。

排序就搞定了。

```cpp
#include<bits/stdc++.h>
#define N 250005
using namespace std;
int n,xx,yy;char ch;
struct Point{int x,y,id;};
struct Point p[N];
inline bool cmp1(Point a,Point b){
    return a.x^b.x?a.x<b.x:a.y<b.y;
}
inline bool cmp2(Point a,Point b){
 return a.y^b.y?a.y<b.y:a.x<b.x;
}
inline bool cmp3(Point a,Point b){
    return a.id<b.id;
}
int ans(INT_MAX),s,t,w,ss,tt;
int main(){
    scanf("%d",&n);p[0]=(Point){0,0,0};
    for(int i(1);i<=n;++i){
        scanf(" %c",&ch);
        if(ch=='N') ++xx;
        if(ch=='S') --xx;
        if(ch=='W') --yy;
        if(ch=='E') ++yy;
        p[i]=(Point){xx,yy,i};
    }//预处理出所有会走到的点
    sort(p,p+1+n,cmp1);
    for(int i(1);i<=n;++i){
        if(p[i].x^p[i-1].x) continue;
        if(abs(p[i].id-p[i-1].id)^1){
            w=abs(p[i].y-p[i-1].y);
            if(p[i].id<p[i-1].id){ss=i;tt=i-1;}
            else{ss=i-1;tt=i;}
            if(w<ans){ans=w;s=p[ss].id;t=p[tt].id;}
            else if(!(w^ans)){
                if(p[ss].id<s){s=p[ss].id;t=p[tt].id;}
                else if(!(p[ss].id^s)) t=max(p[tt].id,t);
            }
        }
    }//找到横坐标相同的点
    sort(p,p+1+n,cmp2);
    for(int i(1);i<=n;++i){
        if(p[i].y^p[i-1].y) continue;
        if(abs(p[i].id-p[i-1].id)^1){
            w=abs(p[i].x-p[i-1].x);
            if(p[i].id<p[i-1].id){ss=i;tt=i-1;}
            else{ss=i-1;tt=i;}
            if(w<ans){ans=w;s=p[ss].id;t=p[tt].id;}
            else if(!(w^ans)){
                if(p[ss].id<s){s=p[ss].id;t=p[tt].id;}
                else if(!(p[ss].id^s)) t=max(p[tt].id,t);
            }
        }
    }//找到纵坐标相同的点
    printf("%d %d %d ",ans,s,t);
    sort(p+1,p+1+n,cmp3);//这个排序可以不要，但是代码会复杂一点，我懒得写就直接排序了
    if(p[s].x^p[t].x) puts(p[s].x<p[t].x?"N":"S");
    else puts(p[s].y<p[t].y?"E":"W");
    return 0;
}
```

---

## 作者：newbeeglass (赞：0)

首先说一下，这题的关键点在于捷径的判定和平面的扫描。

![](https://cdn.luogu.com.cn/upload/pic/472.png)

### 1.如何判定捷径
看上面这张图，如果是你来做，你肯定一眼就看见了 C——D 和 C——E 这两条捷径，仔细想一下，你是怎么看出来的？

题中讲捷径只有横竖两种情况，所以我们人眼在扫描这张图的时候就会下意识地找有没有两个点不相连并且其连线为东西或南北方向，这便是人判断捷径的方法，同样，我们可以将其转换成代码，来模拟人的判定过程，具体方法如下：

先用结构体存储横纵坐标：
```cpp
struct node{
	int x,y;
	int num;//此为点的序号，判断点是否相连
}a[1000001];
```
对于两个点，如果它们不相连，并且横坐标相同或纵坐标相同，便可以认为它们之间有捷径，最后取最小的一个即可。


### 2.如何扫描这个平面
刚才讲了判定的方法，接下来讲如何遍历这个平面。

如果用暴力两两枚举的方法，复杂度为 $O({N}^{2})$ ，很明显不行，这里就要用到贪心了，所有点坐标排序（横纵分开处理），每次处理排序好相邻的点就行了，如果还不理解，可以自行模拟一下。
```cpp
bool cmp2(node a1,node a2){
	return (a1.x<a2.x) || (a1.x==a2.x && a1.y<a2.y);//坐标排序很关键
}
bool cmp1(node a1,node a2){
	return (a1.y<a2.y) || (a1.y==a2.y && a1.x<a2.x);
}
```
与前面讲的判定相结合，方法就清晰了：
```cpp
if(a[i].x==a[i+1].x){
	if(abs(a[i].num-a[i+1].num)==1){
		continue;
	}
	int dis=a[i+1].y-a[i].y;
	char dt;
	int fr,t;
	if(a[i].num<a[i+1].num){
		dt='N';
		fr=a[i].num;
		t=a[i+1].num;
	}
	else{
		dt='S';
		fr=a[i+1].num;
		t=a[i].num;
	}
}
```

### AC code:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
	int num;
}a[1000001];
char c;
bool cmp2(node a1,node a2){
	return (a1.x<a2.x) || (a1.x==a2.x && a1.y<a2.y);
}
bool cmp1(node a1,node a2){
	return (a1.y<a2.y) || (a1.y==a2.y && a1.x<a2.x);
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>c;
		a[i].num=i;
		if(c=='N'){
			a[i].x=a[i-1].x;
			a[i].y=a[i-1].y+1;
		}
		if(c=='S'){
			a[i].x=a[i-1].x;
			a[i].y=a[i-1].y-1;
		}
		if(c=='E'){
			a[i].y=a[i-1].y;
			a[i].x=a[i-1].x+1;
		}
		if(c=='W'){
			a[i].y=a[i-1].y;
			a[i].x=a[i-1].x-1;
		}
	}
	sort(a,a+n+1,cmp1);//先处理横向捷径 
	int ans=1e8,from=1e8,to=-1e8;//注意初始化 
	char dire;//最终方向 
	for(int i=0;i<n;i++){
		if(a[i].y==a[i+1].y){
			if(abs(a[i].num-a[i+1].num)==1){
				continue;//如果已经有连线了，直接continue 
			}
			int dis=abs(a[i].x-a[i+1].x),fr,t;//算距离 
			char dt;//存储暂时的方向 
			if(a[i].num<a[i+1].num){
				fr=a[i].num;
				t=a[i+1].num; 
				dt='E';//判断起点与终点，下同 
			}
			else{
				fr=a[i+1].num;
				t=a[i].num;
				dt='W';
			}
			if(dis==ans){//如果有相同的情况，按题意处理 
				if(fr<from){
					from=fr;
					dire=dt;
					to=t;
				}
				else if(fr==from){
					if(t>to){
						from=fr;
						to=t;
						dire=dt;
					}
				}
			}
			if(dis<ans){//这条捷径更短，改变数据 
				ans=dis;
				from=fr;
				dire=dt;
				to=t;
			}
		}
	}
	sort(a,a+n+1,cmp2);//与上面一样，处理纵向捷径 
	for(int i=0;i<n;i++){
		if(a[i].x==a[i+1].x){
			if(abs(a[i].num-a[i+1].num)==1){
				continue;
			}
			int dis=a[i+1].y-a[i].y;
			char dt;
			int fr,t;
			if(a[i].num<a[i+1].num){
				dt='N';
				fr=a[i].num;
				t=a[i+1].num;
			}
			else{
				dt='S';
				fr=a[i+1].num;
				t=a[i].num;
			}
			if(dis==ans){
				if(fr<from){
					dire=dt;
					from=fr;
					to=t;
				}
				else if(fr==from){
					if(t>to){
						to=t;
						from=fr;
						dire=dt;
					}
				}
			}
			if(dis<ans){
				ans=dis;
				dire=dt;
				from=fr;
				to=t;
			}
		}
	}
	cout<<ans<<" "<<from<<" "<<to<<" "<<dire;
	return 0;
}

```



---


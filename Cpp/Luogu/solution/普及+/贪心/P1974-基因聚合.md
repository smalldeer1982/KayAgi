# 基因聚合

## 题目描述

德国科学家总是对非洲野猴的抵抗力感到惊奇，因为他们发现在没有医疗条件的情况下，非洲野猴总是比其他所有野生动物少生病。最近的研究有了新发现，科学家Dr.Smith从非洲野猴身上发现了一种罕见的抗体，他猜测可能正是该罕见的抗体在帮助非洲野猴抵抗外来病毒的侵害。


Dr.Smith就立刻展开了对该抗体的研究。在初始的观察中Dr.Smith发现该抗体没什么特别，而且非常简单，因为抗体的每组基因只有一对基元（Dr.Smith把一组基因看成由若干对基元组成）。但是当Dr.Smith把病毒植入抗体所在的培养液后，奇迹出现了！那些简单的基因组通过不断地聚合（每个基因组两两合并生成新的基因组），最终所有的基因组合并成了一个非常庞大的基因组，而正是这庞大的基因组，因为聚合了所有原始基因组的优点，这庞大的基因组才可以慢慢地、逐个地去吃掉那些植入培养液的病毒。


下面是Dr.Smith在高倍显微镜下看到的抗体基因组基元聚合的大致过程：




图3－1  Dr.Smith在显微镜下看到的开始时有3个基因组的抗体聚合过程

 ![](https://cdn.luogu.com.cn/upload/pic/974.png) 

Dr.Smith通过进一步观察和研究发现，抗体基因在聚合过程中似乎总是按照某个方法在进行，该方法能保证最终产生的基因组的基元对数量最多（每个基元对的存在能产生1u单位的生物能量），而在每次两个基因组聚合后所得到的新基因组的总的基元对由下面两部分相加组成：


1、每两个基因组一发生聚合，就产生一个额外的、未知的基元对。


2、当两个基因组聚合时，每个基因组中的每对基元都会与另一个基因组中的每对基元两两聚合产生一个新的基元对。


Dr.Smith还发现，抗体在每个时刻总是只有两个基因组会发生聚合，也就是说，每两个基因组的聚合都是依次进行的，而不是同时进行的。


虽然观察到聚合原理，但Dr.Smith即使在知道一开始基因组个数的前提下，还是无法统计最终聚合产生的那个庞大的基因组所具有的总能量有多大。现在他想请你编程来统计一下。


## 样例 #1

### 输入

```
3```

### 输出

```
3```

# 题解

## 作者：2018_Danny (赞：7)

思路和前面的大佬们都差不多：就是最开始有$n$个$1$，然后每次操作可以选出两个数相乘（基元对两两配对）再加一（产生一个额外的基元对），得到一个新数放回去······如此重复$n-1$次后只剩下一个数，要我们使得最后这个数尽量大。

怎么做呢？我们大概可以自然而然的想到，操作的次数是一定的，那越小的数留到后面就会越拖累别人，产生浪费，所以应该先让小数变大，即每次选出两个最小的数进行操作（就是贪心没有为什么（〃｀ 3′〃））。

然而在纸上算一下，发现$n$每增加$1$，结果就要扩大$1.5$倍左右，而$10000$次方告诉我们显然要用高精度，那我们就把高精模板打出来：

```cpp
//写成一个类型方便配合STL
struct BigInt
{
	int num[5000],len;
    //不知道最大有多少位，先设大点无妨
	BigInt() {memset(num,0,sizeof(num));len=0;}
    //初始化一下避免出错
	void print() {for(int i=len;i;i--) printf("%d",num[i]);}
    //这题只需要输出不需要读入
    //然后是重载运算符
	BigInt operator + (const BigInt& b) const
	{
		int len=max(this->len,b.len),carry=0,now;BigInt c;
		for(int i=1;i<=len;i++)
		{
			now=this->num[i]+b.num[i]+carry;
			c.num[i]=now%10;carry=now/10;
		}
		if(carry) c.num[++len]=carry;
		c.len=len;
		return c;
	}
	BigInt operator * (const BigInt& b) const
	{
		BigInt d;
		for(int i=1;i<=this->len;i++)
		{
			int carry=0,now;BigInt c;
			for(int j=1;j<=b.len;j++)
			{
				now=b.num[j]*this->num[i]+carry;
				c.num[j+i-1]=now%10;carry=now/10;
			}
			if(carry) {c.num[b.len+i]=carry;c.len=b.len+i;}
			else c.len=b.len+i-1;
			d=d+c;
		}
		return d;
	}
};
```



我想说的是，其实**这题**完全可以高精配$\text{STL}$的$\text{priority\_queue}$的，而且代码并不复杂，只需再给$\text{BigInt}$类型定义一个 $<$ 即可（好像，$\text{STL}$的类型都只需要定义小于）。不过这题我们要用的是小根堆，当然你可以用$\text{greater}$，不过我就直接把 $<$ 定义成了$\geqslant$ ,效果是一样的╰(￣ω￣ｏ)。代码就多了这么一段：

```cpp
bool operator < (const BigInt& b) const
{
	if(this->len!=b.len) return this->len>b.len;
	for(int i=this->len;i;i--) if(this->num[i]!=b.num[i]) return this->num[i]>b.num[i];
	return true;
}
```



不过正如前面的大佬所说，可能会有$\text{MLE}$的问题。那怎么办呢？其实可以取点巧，我们输出一下$n$为$10000$时答案的长度，刚好是$1770$，于是我把数位开到$1775$，提交，竟然就过了┗|｀O′|┛ ！ 但如果在多一点，比如$2000$，就会$\text{MLE}$。所以这种写法只是纯粹为了用堆，空间上还是队列的写法好ㄟ( ▔, ▔ )ㄏ

最终代码好像还稍微短那么一点点呢（难道我下意识的压行了？）：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
struct BigInt
{
	int num[1775],len;
	BigInt() {memset(num,0,sizeof(num));len=0;}
	void print() {for(int i=len;i;i--) printf("%d",num[i]);}
	BigInt operator + (const BigInt& b) const
	{
		int len=max(this->len,b.len),carry=0,now;BigInt c;
		for(int i=1;i<=len;i++)
		{
			now=this->num[i]+b.num[i]+carry;
			c.num[i]=now%10;carry=now/10;
		}
		if(carry) c.num[++len]=carry;
		c.len=len;
		return c;
	}
	BigInt operator * (const BigInt& b) const
	{
		BigInt d;
		for(int i=1;i<=this->len;i++)
		{
			int carry=0,now;BigInt c;
			for(int j=1;j<=b.len;j++)
			{
				now=b.num[j]*this->num[i]+carry;
				c.num[j+i-1]=now%10;carry=now/10;
			}
			if(carry) {c.num[b.len+i]=carry;c.len=b.len+i;}
			else c.len=b.len+i-1;
			d=d+c;
		}
		return d;
	}
	bool operator < (const BigInt& b) const
	{
		if(this->len!=b.len) return this->len>b.len;
		for(int i=this->len;i;i--) if(this->num[i]!=b.num[i]) return this->num[i]>b.num[i];
		return true;
	}
}One,A,B;
int n;
priority_queue<BigInt> q;
int main()
{
	scanf("%d",&n);
	One.num[1]=One.len=1;
	while(n--) q.push(One);
	while(q.size()>1) 
	{
		A=q.top();q.pop();
		B=q.top();q.pop();
		q.push(A*B+One);
	}
	A=q.top();A.print();
	return 0; 
}
```









---

## 作者：JohnJoeZhu (赞：6)

[题目传送门](https://www.luogu.org/problem/P1974)

算法标签：贪心 ~~（水）~~ ，高精，队列（不是很多）

 PART 1 ：题目解析

如果你认真读题，其实会发现 （~~废话一堆~~） 就一句话：

从n个1中，取出任意两个数相乘再加一，在序列删除两数并加入新的结果，问最后剩下的数的最大值。

 PART 2 ：贪心

为什么这题要用贪心呢？（前提是你认真读题）

如果要求结果最大，那么我们期望每一步得到的结果都最大，则必须两个因数最大

既然要因数最大，那么我们就拿尽可能小的数进行操作，使得在底层获得的1更多，得到的结果不断叠加，则能够使结果最大

 PART 3 ：高精

如果你仔细想想 ~~（别问我怎么想的）~~，答案会十分巨大

你不用高精，怎么办？？？

在处理高精部分时，我习惯用重载运算符的方法，具体实现见底部代码哦

~~（吐槽一下烦人的高精）~~

blog：[重载运算符](https://www.luogu.org/blog/JohnJoeZHU/post-00022019624-gao-jing-bi-jian-jie-dai-ma-di-zhong-zai-yun-suan-fu)

大佬讲解：[重载运算符](https://www.cnblogs.com/xiaokang01/p/9166745.html)

PART 4 ：队列

在贪心的基础上，我们很容易想到使用小根堆来实现

但是，堆/优先队列+高精 太 ~~TM~~ 恶心了，而且如果你非要用的话，不仅加大了码量，而且会MLE

怎么办呢?

我们发现，答案具有单调性，简单来说，就是每次操作都会得到第一大的数（你也可以认为这是贪心的理由）

所以，我们只需要用队列不就得了，保证了队列的前两个元素一定是最小的

但是，我们还会MLE

因为我们把高精的数组，一起存在了队列中，而且同时会占用O（n*(n+1)/2）的高精数组空间，那不就MLE了

既然如此，我们为什么不可以利用已经不要的数组空间呢

在此，我们就用队列，存储数组下标，毕竟我们不需要关心每个数的大小了

 PART 5 ：代码 

~~~cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
struct pp{
	int l,g[3000];//l存长度，g存数字
	pp()//这里一定要初始化
	{
		l=0;
		memset(g,0,sizeof(g));
	}
	void print()
	{
	    for(int i=l-1;i>=0;i--)//输出
                printf("%d",g[i]);
            printf("\n");
	}
}f[10010];
int n;
queue<int>q;//这里就存数组下标了
pp operator +(const pp &a,const pp &b)//重载运算符
{
    pp c;
    c.l=max(a.l,b.l);
    int x=0;
    for(int i=0;i<c.l;i++)//普通高精打法（贴板子）
    {
        c.g[i]=a.g[i]+b.g[i]+x;
        x=c.g[i]/10;
        c.g[i]%=10;
    }
    if(x>0) c.g[++c.l]=x;//进位
    return c;
}
pp operator *(const pp &a,const pp &b)//还是重载运算符
{
    pp c;
    for(int i=0;i<a.l;i++)
    	for(int j=0;j<b.l;j++)
    		c.g[i+j]+=a.g[i]*b.g[j];
    c.l=a.l+b.l-1;
    for(int i=0;i<c.l;i++)
    {        
        c.g[i+1]+=c.g[i]/10;
      	c.g[i]=c.g[i]%10;
    }
    while(c.g[c.l++]);//注意这里的高精计算
    while(!c.g[c.l-1]) c.l--;//同上
    return c;
}
int main()
{
	scanf("%d",&n);
	pp k;
    	int ans,anss;
	k.g[0]=1;
	k.l++;
	for(int i=1;i<=n;i++) q.push(i),f[i]=k;
	while(q.size()!=1)//留下最后的答案
	{
		ans=q.front();
		q.pop();
		anss=q.front();
		q.pop();
		f[ans]=f[ans]*f[anss];
		f[ans]=f[ans]+k;
		q.push(ans);
	}
	ans=q.front();
	f[ans].print();
	return 0;
}
~~~

---

## 作者：zhangsl089 (赞：4)

首先概括一下题意，从n个1中，取出两个数相乘并加一，重复操作，直至最后只剩下一个数，问该数的最大值。

明眼人可以看出是贪心，神犇可以看出是数论，而我这样的蒟蒻只能爆搜找规律。然后我们可以知道如果每次取出两个最小的数操作，结果就是最优的。因为这样可以让+1到更底层的位置，换句话说就是加的1与相乘的两个数的比值越大，这样最后就能越大，我只能这么解释。

取最小第一反应是堆，int40分，longlong50分，然后感到不对，高精加堆也太大了。于是发现，每次操作后放到最后一个位置一定保证单调，那我们用队列不就行了，加个高精度。这里用了一个小想法，就是队列里存的是数的位置，因为数字的个数是越来越少的，所以可以把原来的位置拿来存新的数，就不用复制数字，得到了像链表的队列（其实就是）。

~~~




```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
int n; 
struct BigInt{
    int arr[3000];
    int len;
    BigInt(){
        memset(arr,0,sizeof(arr));
        len=0;
    }
}a[10100];
int que[50100],top,dep;
BigInt operator *(BigInt s,BigInt t){
    BigInt d;
    for(int i=1;i<=s.len;i++)
        for(int j=1;j<=t.len;j++){
            d.arr[i+j-1]+=s.arr[i]*t.arr[j];
            if(d.arr[i+j-1]>=10){
                d.arr[i+j]+=d.arr[i+j-1]/10;
                d.arr[i+j-1]%=10;
            }
        }
    d.len=s.len+t.len-1;
    for(int i=1;i<=d.len;i++){
        if(d.arr[i]>=10){
            d.arr[i+1]+=d.arr[i]/10;
            d.arr[i]%=10;
        }
        if(d.arr[d.len+1]>0)
            d.len++;
    }
    return d;
}
BigInt operator +(BigInt s,int t){
    s.arr[1]+=t;
    for(int i=1;i<=s.len;i++){
        if(s.arr[i]>=10){
            s.arr[i+1]+=s.arr[i]/10;
            s.arr[i]%=10;
        }
        if(s.arr[s.len+1]>0)
            s.len++;
    }
    return s;
}
void print(int x){
    for(int i=a[que[x]].len;i>=1;i--)
        printf("%d",a[que[x]].arr[i]);
}
int main(){
    freopen("test.in","r",stdin);
    freopen("test.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        a[i].arr[1]=1;
        a[i].len=1;
        que[i]=i;
    }
    top=1,dep=n;
    while(top<dep){
        a[que[top]]=a[que[top]]*a[que[top+1]];
        a[que[top]]=a[que[top]]+1;
        que[++dep]=que[top];
        top+=2;
    }
    print(top);
    puts("");
    return 0;
}
~~~
```

---

## 作者：TemplateClass (赞：3)

这题为啥没有 Python 题解啊。

显然由于序列里的每个数最后都会被用到，所以我们希望序列的所有数都尽可能地大。也就是说，对于那些很小的数，我们希望优先操作它们使它们变大。

感性地理解一下，不妨令 $x _ 1 < x _ 2 < x _ 3$，按照先聚合小的方法得到的结果是 $(x _ 1 x _ 2 + 1) x _ 3  +1 = x _ 1 x _ 2 x _ 3 + x _ 3 + 1$，而另外两种的聚合方法分别是 $x _ 1 x _ 2 x _ 3 + x _ 1 + 1$ 和 $x _ 1 x _ 2 x _ 3 + x _ 2 + 1$，因此越小的数先聚合，结果就越大。

于是我们可以开一个堆，直接按上述方法模拟即可，时间复杂度 $O(n \log n)$。

```py
import heapq

heap = []
n : int = int(input())

for i in range(n):
    heapq.heappush(heap, 1)

for i in range(n - 1):
    x : int = heapq.heappop(heap)
    y : int = heapq.heappop(heap)
    heapq.heappush(heap, x * y + 1)

print(heapq.heappop(heap))
```

---

## 作者：peixiaorui (赞：2)

前面的大佬们都说可能会 MLE，那我来一个压位高精吧。

## 题目简述

~~这个题面好高大上的样子~~

形式化题意：开始时给出一个长度为 $n$ 的、值全部为 $1$ 的序列，每次从中取出两个数 $x , y$ 并将 $x \times y + 1$ 放回序列当中，求最后剩下的数可能的最大值。

## 思路

这是一道贪心题，每次取出最小的两个聚合后再放回去。下面给出~~并不严谨~~的证明：

设 $A$ 为当前基因组集合，对于 $\forall a , b , c \in A , a \le b \le c$，若选择 $b , c$ 先进行聚合，得到的新结果为 $ b \times c + 1$，此后再与 $a$ 聚合，得到结果为 $a \times ( b \times c + 1 ) + 1 = a \times b \times c + a + 1$。若先使 $a , b$ 聚合，最终得到的结果为 $a \times b \times c + c + 1$，又因为 $a \le c$，所以先选择 $a , b$ 的结果更优（即选择最小的两个是最优的）。

那么我们一开始把 $n$ 个 $1$ 放进优先队列中，每次从优先队列中取出最小的两个进行聚合再放入即可。优先队列可用 `STL` 中的 `priority_queue` 实现。什么？ MLE ？压位高精解决啦。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
#define ll long long
struct Bignum{
	int num[510];//在压4位的情况下，开500够用了
	int len;
	Bignum(){
		memset(num,0,sizeof(num));
		len=0;
	}//初始化
	void print(){
		cout<<num[len];
	    of(i,len-1,1){
			if(num[i]==0){cout<<"0000";continue;}
			for(int j=10;j*num[i]<10000;j*=10)cout<<0;
			cout<<num[i];
		}//输出
	}
};
Bignum operator + (const Bignum &a,const Bignum &b) {
	Bignum c;c.len=max(a.len,b.len);int t=0;
	fo(i,1,c.len)c.num[i]=a.num[i]+b.num[i]+t,t=c.num[i]/10000,c.num[i]%=10000;
	if(t>0)c.num[++c.len]=t;
	return c;
}//高精加
Bignum operator * (const Bignum &a,const Bignum &b) {
	Bignum c;c.len=a.len+b.len-1;
	fo(i,1,a.len)fo(j,1,b.len){
		c.num[i+j]+=c.num[i+j-1]/10000,c.num[i+j-1]%=10000;
		c.num[i+j-1]+=a.num[i]*b.num[j];
		c.num[i+j]+=c.num[i+j-1]/10000,c.num[i+j-1]%=10000;
	}
	while(c.num[c.len+1])c.num[c.len+1]+=c.num[c.len]/10000,c.num[c.len]%=10000,c.len++;
	return c;
}//高精乘
bool operator < (Bignum a,Bignum b){
	if(a.len!=b.len)return a.len>b.len;
	of(i,a.len,1)if(a.num[i]!=b.num[i])return a.num[i]>b.num[i];
	return 0;
}//重定义比较运算符
//注意，priority_queue默认为大根堆，要使它为小根堆可以把小于号反着定义（见上）
Bignum to_Bignum(int x){
	Bignum n;
	while(x>0)n.num[++n.len]=x%10000,x/=10000;
	return n;
}//把int型转化为Bignum型
//以上为压4位的高精代码
priority_queue<Bignum> q;
int main(){
	int n;cin>>n;
	fo(i,1,n)q.push(to_Bignum(1));//放入n个1
	while(q.size()>1){
		Bignum x,y;
		x=q.top();q.pop();
		y=q.top();q.pop();
		q.push(x*y+to_Bignum(1));
	}//每次取出两个数聚合后放回
	Bignum ans=q.top();
	ans.print();//输出答案
	return 0;
}
```

---


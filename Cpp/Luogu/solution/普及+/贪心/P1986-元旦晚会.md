# 元旦晚会

## 题目背景

玛雅人预言的世界末日没有发生，我们迎来了地球的第五个太阳纪。

学校将要举办第五个太阳纪的第一次元旦晚会。Brett 的班级要参加，并且还表演节目。

## 题目描述

Brett 班的节目是这样的：全班 $n$ 个同学排成一排，同学们手拿话筒，齐唱《喜洋洋与灰太狼》（这个节目看起来有点二） 。

Brett 班的同学分成了 $m$ 个声部，一个声部由连续的同学组成，第 $i$ 个声部由 $a_i$ 到 $b_i$ 之间的同学组成（包括 $a_i$ 和 $b_i$ ）

但是一个同学有可能同时属于多个声部，且有可能有同学不属于任何一个声部。为了保证演唱效果，第 $i$ 个声部必须至少有 $c_i$ 个同学持有话筒（即第 $i$ 个声部持有话筒的同学数大于等于 $c_i$）。

请你算出 Brett 班最少需要几个话筒。

## 说明/提示

对于 $100\%$ 的数据，保证 $n \le 30000$，$m \le 5000$，$1 \le a_i < b_i \le n$，$c_i \le b_i - a_i + 1$。

## 样例 #1

### 输入

```
11 5 
3 7 3 
8 10 3 
6 8 1 
1 3 1 
10 11 1 ```

### 输出

```
6 ```

# 题解

## 作者：_Ayanami_ (赞：27)

贪心思想

对于每个声部按照右端点从小到大排序

然后从每个右端点往左发话筒直到该声部话筒数量足够

![](https://cdn.luogu.com.cn/upload/image_hosting/wu9hjkv6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（每种颜色表示一个声部）

可以证明这样能使重复部分的话筒最多，因为按右端点排序后每个声部与它之后的声部的重复（如果有）一定会从最右边开始

代码打出来还是很容易的

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,ans=0,s,a;
struct node
{
	int l,r,t;
}
x[10001];//结构体
bool z[30001]={0};//记录该位置是否有话筒
bool cmp(node x,node y)
{
	return x.r<y.r;//按右端点排序
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
	    scanf("%d%d%d",&x[i].l,&x[i].r,&x[i].t);
	}
	sort(x+1,x+m+1,cmp);//排序
	for(int i=1;i<=m;i++)
	{
		a=0;//计数
		//先扫一遍统计该声部现有话筒个数
		for(int j=x[i].l;j<=x[i].r;j++)
		{
			if(z[j])
			{
			    a++;
			}
		}
		//从尾巴开始放
		for(int j=x[i].r;j>=x[i].l;j--)
		{
			//够了就退出
			if(a>=x[i].t)
			{
				break;
			}
			//这里没有话筒就放一个
			if(!z[j])
			{
				a++;
				ans++;
				z[j]=1;
			}
		}
	}
	printf("%d",ans);
}
```
P.S 论这题的颜色

[P1250 种树 这是道黄题](https://www.luogu.org/problem/P1250)

[P1645 序列 这是道蓝题](https://www.luogu.org/problem/P1645)

做法 完 · 全 · 一 · 致 ~~三倍经验~~

~~众所周知黄色和蓝色混起来是绿色所以这是道绿题~~

~~又众所周知你谷上绿题难度在黄蓝之间所以取平均值这题还是绿的~~

大雾~~所以这题为什么是蓝的~~

---

## 作者：k_z_j (赞：10)

本题提供一种贪心的思想。
我们可以先按所有声部的右端点排序，再进行从后到前的顺序选取拿话筒的人。
证明：显然。我们如果从后往前选取，就会尽量满足后面人的需求，这样就能达到最小值。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct node
{
    int l,r,c;
}a[101000];
bool cmp(node x,node y)
{
    if(x.r!=y.r)
    return x.r<y.r;
    return x.l<y.l;
}
int vis[101000];
int main()
{
    int n,m,ans=0;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    scanf("%d%d%d",&a[i].l,&a[i].r,&a[i].c);
    sort(a+1,a+1+m,cmp);
    for(int i=1;i<=m;i++)
    {
        int k=0;
        for(int j=a[i].r;j>=a[i].l;j--)
        if(vis[j])
        k++;
        if(k>=a[i].c)
        continue;
        else
        {
            for(int j=a[i].r;(j>=a[i].r-a[i].c+1)&&(k<a[i].c);j--)
            if(!vis[j])
            vis[j]=1,ans++,k++;
        }
    }
    cout<<ans;
}
```

---

## 作者：fanfan (赞：9)

差分约束系统

设dis[i]表示前i个人最少有多少个话筒

根据题目意思每个人都只能有一个话筒  所以 dis[i[+1>=dis[i+1] dis[i+1]>=dis[i]

ai到bi至少有ci个 所以 dis[ai-1]+ci>=dis[bi]

转换一下跑一遍最长路即可




```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 100005
int n,m,l;
int last[maxn],pre[maxn*2],other[maxn*2],len[maxn*2];
int que[maxn+5],h,t,dis[maxn],ans;
bool vis[maxn];
void connect(int x,int y,int z)
{
    l++;
    pre[l]=last[x];
    last[x]=l;
    other[l]=y;
    len[l]=z;    
}
void spfa(void)
{
    h=0;
    while (h!=t) 
    {
        h=h%maxn+1;
        int u=que[h];vis[u]=0;
        for (int p=last[u];p;p=pre[p]) 
        {
            int v=other[p];
            if (dis[v]<dis[u]+len[p])
            {
                 dis[v]=dis[u]+len[p];
                if (!vis[v]) 
                {
                    vis[v]=1;
                    t=t%maxn+1;
                    que[t]=v;    
                }
            }
        }
    }
    //for (int i=1;i<=n;i++) ans=max(ans,dis[i]);
    printf("%d\n",dis[n]);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) 
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        connect(a-1,b,c);    
    }
    for (int i=1;i<=n;i++) 
    {
        connect(i-1,i,0);
        connect(i,i-1,-1);
    }
    for (int i=0;i<=n;i++) {que[++t]=i;vis[i]=1;}
    spfa();
    return 0;
}
```

---

## 作者：shucai (赞：8)

## [题目传送门](https://www.luogu.com.cn/problem/P1645)

### 题意
给定 $n$ 个区间，区间可能会重叠，每个区间至少要有 $c_i$ 个人持有话筒，问至少要几个话筒。

### 思路
本题解算法：贪心。

首先将每个区间的右端点从小到大进行排序，然后进行以下操作：

对于一个区间，先判断这个区间还需要几个话筒（因为区间可能会重叠），然后从这个区间的右端点开始，**从右往左**依次判断这个人有没有话筒，如果有，下一个；没有，就把这个人标记成有话筒，然后下一个。直到这个区间需要的人足够了，就跳到下一个区间。从右往左是因为我们要**尽最大化的让损失减小**（让两个区间的话筒共享）。

## code
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<map>
#include<stack>
#include<queue>
#include<cstring>
using namespace std;
struct qj{
	int l;
	int r;
	int c;
}data[100010];
bool cmp(qj a,qj b)
{
	return a.r<b.r;
}//右端点从小到大排序
bool flag[100011];
int main()
{
	int m;
	cin>>m;
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>data[i].l>>data[i].r>>data[i].c;
	}
	sort(data+1,data+1+n,cmp);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
	
		int sum=0;//已经有的话筒数量
		for(int j=data[i].l;j<=data[i].r;j++)
		{
			if(flag[j]==1)
			{
				sum++;
			}
		}
		if(sum<data[i].c)
		{
			for(int j=data[i].r;j>=data[i].l;j--)
			{
				if(flag[j]==0)
				{
					flag[j]=1;
					sum++;
					ans++;
					if(sum==data[i].c)
				    break;
				}
				
			}
		}
	}
	cout<<ans;
}
```
### 小结
本题是一道贪心入门题，很适合刚学贪心的同学练习。

###### ~~比较水~~




---

## 作者：pocafup (赞：5)

不看数据范围过了这题，然后看了看题解好像大部分是 $O(nm)$的，这里提供一个 $O(nlogn)$ 的线段树做法。

首先做法跟贪心思路一样，先将区间以结束点排序，然后从前往后扫，如果当前声部不足则尽量从后面拿起。

考虑建两棵线段树，一颗维护区间空位的最大值，另一颗维护区间点的数量。

在枚举时如果麦不够，就每次找出最后的空位，然后暴力更新即可。

正确性已经有人证明，这里只证明复杂度：

由于两棵线段树是分开查询的，故单次修改复杂度为 $O(logn + logn)$ 而非 $O(log^2n)$。

又由于 $n$ 的范围给出，这题最多修改 $n$ 次，故复杂度为 $O(nlogn)$

代码丑,贴个主程序加注释就得了，剩下的是板子有兴趣的可以联系我

```cpp
signed main(){
  n = read();m = read();
  For(i,1,m) edge[i] = (Edge){read(), read(), read()};
  build(1,1,n);
  sort(edge+1,edge+m+1);//排序
  For(i,1,m){
    int u = edge[i].u, v = edge[i].v, val = edge[i].val;
    int num = query(1,1,n,u,v);//查看区间点数是否足够
    while(num<val){//如果不够暴力修改
      num++;ans++;
      int po = query2(1,1,n,u,v);//找区间值最大的空端点
      update(1,1,n,po);
      update2(1,1,n,po);//两棵树更新
    }
  }
  writeln(ans);
}
```

---

## 作者：JiaY19 (赞：2)

一道比较水的蓝题。

和[这一题](https://www.luogu.com.cn/problem/P1645)是双倍经验。

#### 思路

看到最小，考虑贪心。

因为他需要的是在这个取值范围内选至少 $c$ 个数。

我们考虑首先按右端点排序。

可以确定：

能选，就要尽量选右边的。

因为此时，每一个右边的区间的右端点都比现在的右端点大。

所以，尽可能的选择右边，才能是一个数字被多个区间重复覆盖。

才能是所要选的数尽量少。

发现每个数字不能相同，可以用一个桶记录这个数有没有被选。

#### 实现

一个双重循环，第二重循环两次，第一次判断此时该区间选了几个，第二次为选数。

时间复杂度： $O(nm)$。

你没有看错，可能因为数据过水，纯裸的 $O(nm)$ 是可以过的。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n , m , ans , vis[30010];

struct edge
{
    int l , r , c;
    bool operator<(const edge &tmp) const
    {
        return (r == tmp.r) ? l < tmp.l : r < tmp.r;
    }
}e[5010];

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

int main()
{
    m = read() , n = read();
    for(int i = 1;i <= n;i++)
        e[i].l = read() , e[i].r = read() , e[i].c = read();
    sort(e + 1 , e + n + 1);
    for(int i = 1;i <= n;i++)
    {
        int sum = 0;
        for(int j = e[i].l;j <= e[i].r;j++)
            if(vis[j]) sum++;
        for(int j = e[i].r;j >= e[i].l && sum < e[i].c;j--)
            if(!vis[j]) vis[j] = 1 , sum++ , ans++;
        // cout << e[i].l << " " << e[i].r << " " << e[i].c << " " << ans << endl;
    }
    cout << ans << endl;
    return 0;
}



```

---

## 作者：huyuao_2007 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P1986)

第一次发题解可能版面看起来有些。。。不要介意。

------------
## 一，思路
假如这几个声部是这样的关系（每个方格都是一个人）。
![](https://cdn.luogu.com.cn/upload/image_hosting/1k7tv9j0.png)
那么可以看到，在黑笔圈画部分，放置一个麦克风，可以同时满足两到三个声部的需求。
![](https://cdn.luogu.com.cn/upload/image_hosting/bbcr6i5r.png)
通过观察可以发现，重叠部分基本出现在一个声部的左右两端，所以可以以左右两端进行排序，然后从最左端或最右端开始放，最后使麦克风数量满足声部要求。
## 二，代码讲解
### 我们先从右往左放
因为上一个声部放置的重叠的麦克风会在下一个声部的左边出现，为了不影响下一个声部麦克风的放置，所以要将所有声部按右端点从小到大排序。（推荐使用  ```sort ``` 和数据体，因为这样可以快速排序。~~实际上就是懒~~）

排序完以后按照顺序依次从右往左放麦克风，如果够了就检索下一个空位是否需要麦克风，一直到检索完为止
#### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{//不会吧不会吧？还有人不会数据体排序吧？
    int l,r,c;
}line[5001];
bool cmp(node x,node y){//按右侧端点排序 
    return x.r<y.r;
}
bool miclepone[30001];//给没给麦克风 
int main(){
    int n,m,ans=0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&line[i].l,&line[i].r,&line[i].c);
    sort(line+1,line+1+m,cmp);
    
	for(int i=1;i<=m;i++){
        int temp=0;//计数器 
        for(int j=line[i].r;j>=line[i].l;j--)
        if(miclepone[j])  temp++;
        if(temp>=line[i].c) continue;//放够了就往后跳，跳到可以放 
        else{
            for(int j=line[i].r;(temp<line[i].c)&&(j>=line[i].r-line[i].c+1);j--)
            if(!miclepone[j])
            miclepone[j]=1,ans++,temp++;
        }
    }
    cout<<ans;
    return 0;
}
```
### 接下来从左往右放
因为思路基本相同，代码就不贴了，但要注意如果从左向右，排序要按左侧端点从大到小排序（理由同上）


希望dalao们指点一下，给些建议~~（虽然我很多看不懂）~~。


---

## 作者：qfpjm (赞：1)

先说一句，这道题跟[P1250 种树](https://www.luogu.com.cn/problem/P1250)的代码一模一样。（如果这题你做出来了，可以提交到那题）


------------

# 题意

一个声部的同学都需要 $Ci$ 同学持话筒，而且要求持话筒的同学最少。

# 分析

- 大家可能会想到：每个声部都安排 $Ci$ 个同学持有话筒。但是，这样不一定会使得持话筒的同学最少。原因见下一条。

- 但是，当声部有重复的时候，安排一个同学，可能会使得的多个声部拥有这个同学，而使得持话筒的同学最少。

# 题解

1. 首先，我们对声部的末尾进行排序，确定声部位置（从样例可以得知，输入的声部无序的）。

2. 然后，我们要统计这个声部已有的人数（用一个 $bool$ 类型的数组来标记持话筒的人），判断是否满足这个声部，则跳至下一个声部续安排持话筒的人。

3. 如果不满足，从后往前找到未持有话筒的同学（后面的同学越容易与另一个声部重合），让其持话筒。每安排下一个同学，最终结果加一，这个声部持的人数加一，直至人数满足。

4. 输出最终结果。

# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

struct houseperson
{
	int start, end, tree;	
}a[5000001];

int n, h;
long long ans;
bool used[500001] = {0};

int cmp(houseperson a, houseperson b) 
{
	return a.end < b.end;
}

int main()
{
	cin >> n >> h;
	for (int i = 1;i <= h;i ++)
	{
		cin >> a[i].start >> a[i].end >> a[i].tree;
	}
	sort(a + 1, a + 1 + h, cmp);
	for (int i = 1;i <= h;i ++)
	{
		int m = 0;
		for (int j = a[i].start;j <= a[i].end;j ++)
		{
			if (used[j] == true)
			{
				m ++;
			}
		}
		if (m >= a[i].tree)
		{
			continue;
		}
		for (int j = a[i].end;j >= a[i].start;j --)
		{
			if (used[j] == false)
			{
				m ++;
				ans ++;
				used[j] = true; 
				if (m == a[i].tree)
				{
					break;
				}
			}
		}
	}
	cout << ans;
	return 0;
}

```


---

## 作者：edr_saverr (赞：1)

元旦晚会 ~ 
------------
**蛮多dalao发了这道~~水题~~的题解，但是不是很清楚，希望这篇题解对你有所帮助。**

~~蒟蒻求过~~
## 思路
本来看到这道题，心里怀疑这 **蓝题** 是不是要用什么奇奇怪怪的 **DP** 做，但是点开了这个 **算法** 标签， **贪心** 。

那么就按着贪心的思路走，可以想到全班有m个声部，是用 **连续** 的 **下标区间** 分割的。每个人可以有好多个声部 (~~全能工具人~~) ，那么就用一个 **struct** 来储存每一个声部：
```cpp
#define maxn 5010
struct re{
	int l;//记录每个输入的左端点 
	int r;//记录每个输入的右端点 
	int num;//记录每个输入的需求该声部所需话筒数 
}a[maxn];//开5010个数组 下标范围1-m 
```
### 然后：

如果收到了一个需要 $num$ 个话筒的，下标在区间[ $a_i$ , $a.r$ ]之间的声部后，我们应当怎么做能够让这些话筒运用到更多的声部中去呢？那么我们就要让话筒的位置尽可能的向声部更密集的方向放置。那么再结合 **贪心** 普遍使用的先 **排序** 后计算的方式，我想到先使用 sort() 函数对 **a**[maxn] 数组按**每个区间的右端点大小升序排序**。这样就能够让你每一次需要摆放话筒的时候，知道没有放话筒的声部都集中在这个区间的靠右处。

**所以我们只需要每一次都把话筒尽可能的放在每一个需要放置话筒的声部的右侧就可以了。所以我们需要每一次先遍历这个区间内原有的话筒，然后不足的话筒都尽可能地放在区间右侧就好了。**

### 代码实现：
```cpp
/*
	Name: P1986 元旦晚会 题解版 
	Copyright: @ edr_saverr
	Author: edr_saverr
	Date: 08/10/20 21:06
	Description: 感觉前几篇题解讲解的不够详细，本蒟蒻试图把这个贪心思路讲的
	更加具体一些，以便更多人理解。 
*/
#include <bits/stdc++.h>
#define maxn 5010
#define obj '#'
#define debug cout<<obj<<endl
#define end '\n'
#define ll long long
#define INF (2<<31)
using namespace std;
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + int(ch - '0');
	return x * f;}
int read_l(char a[]){
	int i=-1;while((a[++i]=getchar())!= end );a[i]='\0';return i;}
int n,m;//意思如题 
struct re{
	int l;//记录每个输入的左端点 
	int r;//记录每个输入的右端点 
	int num;//记录每个输入的需求该声部所需话筒数 
}a[maxn];//开5010个数组 下标范围1-m 
bool b[30010];//记录那些位置的同学已经有话筒了 
bool cmp(re a,re b){
	if(a.r==b.r)return a.l<b.l;//如果右端点均相同，则按左端点位置升序排列 
	return a.r<b.r;//按右端点位置升序排序(是不是很像一本通里的节目安排那道题)
}
int cnt;
int main(){
	n=read();m=read();
	for(int i=1;i<=m;i++)
		{a[i].l=read();a[i].r=read();a[i].num=read();}
	//以上是读入部分 
	sort(a+1,a+m+1,cmp);
	//sort函数直接排序(很快，很方便) 
	for(int i=1;i<=m;i++){
		int sum=0;//这个用来记录这个区间内有多少人已经有话筒了 
		for(int j=a[i].l;j<=a[i].r;j++)
			if(b[j])sum++;
			//遍历这个区间来计算这个区间内的同学已经有的话筒数 
		for(int j=a[i].r;sum<a[i].num;j--){//如果sum>a[i].num直接退出 
			if(!b[j]){//如果这个位置的同学没有话筒 
				sum++;//区间内话筒数目++ 
				cnt++;//总话筒数量++ 
				b[j]=1;
				//标记这个位置现在已经有话筒了，之后就会遍历这个位置，也不会重复放置话筒 
			}
		}
	}
	printf("%d\n",cnt);//printf 输出 
	return 0;
}
```


---

## 作者：灼眼的夏娜 (赞：1)

### 双倍经验：[luoguP1645](https://www.luogu.org/problem/P1645)

你发现只要把输入改改，其他原封不动，然后就A了。。。

那现在来看这题，要想话筒最少，就要让其交集变多，贪心的想，把区间

按照右端点从小到大排序，尽量的选取最右边的点，这样到了下一个区间

就可以让这两个区间的交集最大，可以手动模拟一下，若有一个区间被覆

盖了，我们选最右端的时候一定是最优的，若当前已选取的点不能满足区

间所要求的点数，那就要增加答案了

代码如下

## code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define R register

using namespace std;
const int N = 30005;
int n, m, ans, sum;
struct node {
	int l, r, c;
}seq[N];
bool have[N];

bool cmp(const node &a, const node &b) { return a.r < b.r; }

int main() {
	scanf("%d%d",&n, &m);
	for(R int i = 1;i <= m;++ i) 
    		scanf("%d%d%d",&seq[i].l,&seq[i].r,&seq[i].c);
	sort(seq + 1, seq + m + 1, cmp);
	for(R int i = 1;i <= m;++ i) {
		sum = 0;
		for(R int j = seq[i].l;j <= seq[i].r;++ j)
			if(have[j]) sum ++;
            	//记录一下之前已选的一共有多少
		if(sum < seq[i].c) {//比这个区间要求的少
			for(R int j = seq[i].r;j >= seq[i].l;-- j) {
				if(have[j]) continue;
                //寻找从右往左没有选的
				have[j] = true;
				ans ++, sum ++;//累加答案
				if(sum == seq[i].c) break;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Raina_xyy (赞：1)

贪心区间取点问题
（所以说和标签上的dp有啥关系呢

对于每一个区间，我们将它以右端点为标准，从左向右排序。

之后从头扫一遍，如果这个区间中数量(cnt)大于等于c，就过，否则优先选择右边放话筒，毕竟放在右边之后还有被利用的可能（即后来的区间右端点都比它大）

同时统计话筒数（ans）

```
#include<bits/stdc++.h>

using namespace std;

const int MAXN=30005;

int n,m;
int vis[MAXN],ans;

struct A
{
	int l,r,c;
}a[MAXN]; 

bool cmp(A x,A y)
{
	if(x.r==y.r) return x.l<y.l;
	return x.r<y.r;
}//排序cmp，右端靠左的优先，相等时左端靠左的优先

void read(int &p)
{
	p=0;char s=getchar();
	int flag=1;
	while(!isdigit(s)) //排除多余字符 
	{
		if(s=='-') flag=-1; //负数 
		s=getchar();  
	}
	for(;isdigit(s);s=getchar()) p=p*10+s-'0';//char -'0’-> int 
	p*=flag;
}//快读，其实并不需要

int main()
{
	read(n);read(m);
	for(int i=1;i<=m;i++)
	{
		read(a[i].l);read(a[i].r);read(a[i].c);
	}
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		int l=a[i].l,r=a[i].r,cnt=0;
		for(int j=l;j<=r;j++) if(vis[j]) cnt++;
		if(cnt>=a[i].c) continue;
		for(int j=r;j>=l;j--) if(!vis[j]) 
		{
			ans+=1,vis[j]=1,cnt++;
			if(cnt>=a[i].c) break;
		}
		
	}
	
	cout<<ans<<endl;
	return 0;
}
```
A了这道蓝题是不是很有成就感呢？
双倍经验拿走不谢

[绿题-P1645 序列](https://www.luogu.org/problem/P1645)
（要稍微改几个字）

[黄题-P1250 种树](https://www.luogu.org/problem/P1250)
（一点也不用改）

~~所以说这到底是什么难度的qwq~~

---

## 作者：—维尼— (赞：0)

## 题目大意
给定$n$个人和$m$个序列（$l$和$r$）及序列必需的话筒数

求出最少需要多少话筒（每人面前最多一个）


## 题目思路

这题明显是个贪心，我们可以按$l$或$r$排序（这里我用的是右边界）

举个例子


![](https://pic.downk.cc/item/5f719323160a154a6714e260.png)

假如这样$n=8,m=4$我们将读入的$4$个范围按照右端点从小到大排序


然后从$1$的右端点开始，优先在右边放上话筒，所以我们从右到左循环，直到数量达到所需的话筒数

然后看$2$

因为第$2$个序列包括$1$的一部分，所以我们要先循环一遍，看是否这个位置有话筒（对应代码中的布尔型ht数组）

依次类推

**总结一下就是，先把$m$个序列按照右端点的大小进行排序，然后循环m次，先算当前已经有的话筒数量，在从右至左给空位放上话筒直到满足数量**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct xxx{
	int le,ri,sum;//左端点，右端点和需要的话筒数量
}a[5005];
bool cmp(xxx a1,xxx a2){//比较函数
	return a1.ri<a2.ri;
}
bool ht[30005];
int main(){
	int n,m;
	cin>>n>>m;
	long long Sum=0;//最后要输出的话筒数量
	for(int i=1;i<=m;i++){
		cin>>a[i].le>>a[i].ri>>a[i].sum;
	}
	sort(a+1,a+1+m,cmp);
	for(int i=1;i<=m;i++){
		int ans=0;//当前范围内的话筒数量，每次都要先赋成0
		for(int j=a[i].le;j<=a[i].ri;j++){
			if(ht[j]){
				ans++;
			}
		}
		if(ans>=a[i].sum)//已经够了直接下一个序列
			continue;
		for(int j=a[i].ri;j>=a[i].le;j--){
			if(ans>=a[i].sum)
				break;
			if(!ht[j]){
				ans++;
				Sum++;
				ht[j]=true;
			}
		} 
	}
	cout<<Sum<<endl;//完美输出
	return 0;
}
```



---

## 作者：ueettttuj (赞：0)

本题我贴个**贪心+树状数组**的解法

首先贪心的正确性是显然的，题解中好像有人提了一下的。现将每一段区间按右边端点从小到大排序，然后将话筒尽可能的放在最右边，这样就能使话筒的利用率尽可能高。

我们用树状数组维护每个区间已经放的话筒的数量，然后就可以计算出放在当前区间最右边的话筒的数量。注意要将放过的地方标记（因为一个人不能拿两个话筒）

代码贴一下：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m;
struct node{
	long long xx,yy,val;
};
node edge[5010];
long long tree[30010];
bool vis[30010];
bool cmp(const node &q , const node &w){  
	if(q.yy!=w.yy) return q.yy<w.yy;
	return q.xx<w.xx;         
}
void add(long long x,long long y){   //树状数组插入操作 
	for(;x<=n;x+=(x&-x)) tree[x]+=y;
}
long long ask(long long x){         //树状数组求前缀和 
	long long anss=0;
	for(;x;x-=(x&-x)) anss+=tree[x];
	return anss;
}
int main(){
	scanf("%lld %lld",&n,&m);
	for(long long i=1;i<=m;i++){
		scanf("%lld %lld %lld",&edge[i].xx,&edge[i].yy,&edge[i].val);//存区间 
	}
	sort(edge+1,edge+m+1,cmp);//按右端点排序 
	long long kk;
	long long ans=0;
	for(long long i=1;i<=m;i++){
		kk=ask(edge[i].yy)-ask(edge[i].xx-1);//求出当前区间话筒数量 
		ans+=max(0ll,edge[i].val-kk);//统计放了的话筒数 
		for(long long j=edge[i].yy;j>=edge[i].yy-edge[i].val+kk+1;j--){
			if(vis[j]) kk--;
			else add(j,1),vis[j]=1;//标记已经放过 
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：LB_tq (赞：0)

```
//贪心的典型题，区间选点问题
//考虑两个区间，如果第一个区间中缺少话筒，那么尽可能的向右放肯定比向左放更优
//因为在右边可以尽可能多的处在更多区间中
//具体可以画图理解一下
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct node{
	int l;
	int r;
	int t;
}p[5010];
int n,h,ans;
int vis[30010];//vis【i】表示第i个点有无话筒
bool cmp(node x,node y){
	return x.r<y.r;
}//将区间按右端点从小到大排序，依次放置话筒
int main(){
	cin>>n>>h;
	for(int i=1;i<=h;i++)
		cin>>p[i].l>>p[i].r>>p[i].t;
	sort(p+1,p+h+1,cmp);
	for(int i=p[1].r;i>=p[1].r-p[1].t+1;i--)
		vis[i]=1;
	ans+=p[1].t;//先在第一个区间右边放话筒
	int s,k,e;
	for(int i=2;i<=h;i++){
		s=0;
		for(int j=p[i].l;j<=p[i].r;j++){
			if(vis[j]==1)
				s++;
			if(s>=p[i].t)
				break;
		}//统计此区间中话筒是否够
		if(s>=p[i].t)
			continue;//如果够的话continue
     //否则在此区间尽可能将缺少的话筒放在右边
		k=p[i].t-s;
		e=0;
		for(int j=p[i].r;j>=p[i].l;j--){
			if(vis[j]==0){
				vis[j]=1;
				e++;
			}
			if(e==k)
				break;//放完break
		}
		ans+=k;//ans+放的话筒数
	}
	cout<<ans;
	return 0;
}
```
//祝大家早日AC！


---

## 作者：RiverHamster (赞：0)

楼下的暴力贪心是$O(nm)$，可能因为查询区间很小，或是评测机太快，就过去了，这里贴一个$O(nlog^2n)$的线段树+二分做法

贪心思路和楼下一样，先按照$R$排序，然后每次在扫描时尽量往后取，给后面的声部节省话筒，就可以得到最优解。

贪心做法对于每个声部是$O(R-L)$一个个暴力枚举的，而我的写法是用一棵线段树查询和，然后不断二分找到修改的边界，查找$x$使$[x,R]$这个范围内的没有话筒的人数等于$[L,R]$区间需要增加话筒的个数，然后把$[x, R]$区间全部改成$1$即可。因为修改操作是改成$1$而不是$+1$，所以支持区间查询区间修改的树状数组好像也写不了这个，只能用线段树了。（如果有大佬有方法可以在评论区告诉我）

code:
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define lson n<<1, l, mid
#define rson n<<1|1, mid+1, r
#define root 1, 1, n
#define ls (n<<1)
#define rs (n<<1|1)
using namespace std;
const int N = 30005, M = 5005;
struct Action{ //活动 
	int l, r, x;
}a[M];
int tr[N*4], n, m;
bool cmp(Action a, Action b){ //右端点排序 
	if(a.r == b.r) return a.l < b.l;
	return a.r < b.r;
}

inline void in(int &x){
	register char ch;
	x = 0;
	while(isspace(ch=getchar()));
	do x = x*10 + ch-'0'; while(isdigit(ch=getchar()));
}
inline void pd(int n, int l, int r){ //pushdown，如果一个区间是满的就push给孩子 
	if(tr[n] == r - l + 1){
		int mid = (l+r) >> 1;
		tr[ls] = mid - l + 1;
		tr[rs] = r - mid;
	}
} 
void update(int x, int y, int n, int l, int r){ //区间元素改成1 
	if(x <= l && y >= r){
		tr[n] = r - l + 1;
		return ;
	}
	pd(n, l, r);
	int mid = (l+r) >> 1;
	if(x <= mid) update(x, y, lson);
	if(y > mid)  update(x, y, rson);
	tr[n] = tr[ls] + tr[rs];
}
int query(int x, int y, int n, int l, int r){ //区间查询和 
	if(x <= l && y >= r) return tr[n];
	pd(n, l, r);
	int mid = (l + r) >> 1, ans = 0;
	if(x <= mid) ans += query(x, y, lson);
	if(y > mid)  ans += query(x, y, rson);
	return ans; 
} 

void work(int l, int r, int x){
	if(x == 0) return ;
	int ans = l, mid, R = r; //R就是查询区间原来的R 
	while(l <= r){
		mid = (l+r) >> 1;
		if((R - mid + 1) - query(mid, R, root) >= x){ //二分0的数量，找到等于x的 
			l = mid + 1;
			ans = mid;
		}
		else r = mid - 1;
	}
	update(ans, R, root); //修改成1 
}
int main(){
	in(n); in(m);
	for(int i=1; i<=m; i++){
		in(a[i].l); in(a[i].r); in(a[i].x);
	}
	sort(a+1, a+1+m, cmp);
	int sum, ans = 0;
	for(int i=1; i<=m; i++){
		sum = query(a[i].l, a[i].r, root); //查询已经有话筒的人的数量 
		work(a[i].l, a[i].r, max(a[i].x - sum, 0));
		ans += max(a[i].x - sum, 0); //统计答案，不需要的就不修改，所以都要用max(a[i].x - sum, 0)
	}
	printf("%d\n", ans);
	return 0;
} 
```
P.S. 评测记录里一个大佬用树状数组一个个修改都比我快，数据真水

---


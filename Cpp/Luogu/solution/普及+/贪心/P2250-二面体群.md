# 二面体群

## 题目描述

考虑在一个单位圆周上的 $n$ 个点，$n$ 个点的标号为 $K=0,1,\ldots,n-1$。初始的时候 $K$ 相对于 X 轴的角度为 $\dfrac{360 \times k}{n}$ 度，这里的角度是相对于 X 轴的逆时针角度。我们将在这组点上运行 2 种不同类型的操作：

1. 顺时针旋转 $\dfrac{360}{n}$度
2. 相对于 X 轴的映射

对于给定的操作序列，如果结果相同，我们只对最短的操作序列感兴趣。结果相同是指对于不同的操作序列，最后的操作结果中每一个单一点的位置都是一样的。

操作序列以字符串的形式给出，该字符串中只含有字母 `r` 和 `m`。`r` 代表顺时针旋转，`m` 代表单独映射（到右边并且对称）。字符串中如果有多个字母连续出现要简写成 `<字母><数字>` 的形式，为了方便起见，字母如果单独出现也写成这种形式。如 `rrmrrrrrrrrrrrr` 可以写成 `r2 m1 r12`，每个操作序列一行。

## 说明/提示

$100\%$ 的数据满足 $3 \leq N \leq 10^8$。



## 样例 #1

### 输入

```
54
r218 m3 r1
```

### 输出

```
r1 m1```

# 题解

## 作者：Terrible (赞：4)

### 我们先来审一下题

$n$ 个点的标号为 $k=0,1,...,n-1$，
角度为 $\frac{360k}{n}$ 度

那也就是说一个**圆被 n 个点均分为 n 个单位**，标号为 $0$ 的点在 $x$ 的正半轴上，其他点按逆时针顺序有序排列。

需要进行两种操作：

'r'：顺时针旋转 $\frac{360}{n}$，也就是每个点顺时针转动一个单位。对于'r' $a$，转动次数 $a$ 如果大于 $n$ 那么就相当于转了**超过一圈**了，那么就**直接取模**，相当于转了 $a\%n$ 个单位。

'm'：相对于 x 轴对称。对于 'm' $a$，对称次数 $a$ 如果大于 $1$，容易知道**对称两次会自我抵消**，只有 $a$ **是奇数**时，所有点才需要关于 x 轴对称。

继续想可以想到两点：

①给出的点的序列是有序的，在变换过程中**始终有序**。如果只需要支持旋转操作，那么仅需要记录出来某个点作为**基准点**，就可以**代表一个序列**。

②更进一步，如果要支持对称操作，我们发现，可以将对称后的序列改为**逆时针序列**，对称前的叫**顺时针序列**，**顺时针序列顺时针旋转**，**逆时针序列逆时针旋转**，我们甚至不需要更改基准点的位置，只需要记录是顺时针序列还是逆时针序列即可。

![逆时针序列变换图示](https://s3.bmp.ovh/imgs/2023/03/20/e08d278e88ff7e47.png)

对于得出**最短操作序列**：

如果是**逆时针序列**:

①一定需要在对准基准点之后确保对称了奇数次；

②如果基准点逆时针操作数少可以先对称，后旋转。

如果是**顺时针序列**：

①如果基准点逆时针操作数少可以借助对称两次，得到最短序列；

②对称两次的操作序列长度需要加 $2$。


## 思路总结：

$p$ 表示基准点位置，$f=1$ 表示顺时针序列，$f=0$ 表示逆时针序列。

顺时针序列旋转 $a$ 次，则 $p=(p+a\%n)\%n$；

逆时针序列旋转 $a$ 次，则 $p=(n+p-a\%n)\%n$；

对称操作 $a$ 次，若 $a$ 为奇数，只需要更改 $f$ 即可。

#### 图示：

例如以下数据：

~~~~
10
r13 m3 r5
~~~~

注：$p$ 表示基准点的位置，其中位置是**顺时针描述**的。其中的“①②...”表示**点的标号**，与本题解的做法没有太大关系。

![所给数据的图示](https://s3.bmp.ovh/imgs/2023/03/20/63b4ff60aed56520.gif)

**模拟**一遍得到**最终状态**。

最后我们需要考虑得到**最终状态**的**最短操作序列**。

#### 边角情况的讨论：

$3\leqslant N \leqslant 10^8$，就是说 $N\not=2$，不存在既可以是逆时针序列又是顺时针序列的情况。

考虑这组数据：

~~~~
60
r31
~~~~

最后结果可以是：

~~~~
m1 r29 m1
~~~~

也可以是

~~~~
r31
~~~~

但是本题没有 $\color{blue} Special Judge$，也确实没有这种数据，可以放心做本题。还有一种数据与此类似，但都不必讨论。

## 代码：
```cpp
#include<cstdio>
int read()
{
	int a(0);char c(getchar());
	while(c<'0')c=getchar();
	while(c>='0')a=a*10+(c^48),c=getchar();
	return a;
}
int main()
{
	int n(read()),a,p(0),f(1);
	//p初值为0，表示选取基准点为0号点，f=1，f=0分别表示顺时针序列、逆时针序列 
	for(char c=getchar();~c;c=getchar())//~c表示如果读入-1(EOF)跳出 
	{
		if(c<33)continue;
		//ASCII中前32个字符中不包含数字和字母，直接吃掉继续读入 
		a=read();
		if(c=='r')
		{
			a%=n;
			if(f)p=(p+a)%n;
			else p=(n+p-a)%n;//p有可能为负，需要+n 
		}
		else if(a&1)f=!f;
	}
	if(p==0)
	{
		if(!f)return printf("m1"),0;
		else return 0;
	}//如果没有旋转操作直接结束程序，最多对称一下 
	if(f)
	{
		//顺时针序列： 
		//n-p+2表示借助两次对称进行旋转，p表示直接旋转，可以取等，不必讨论这种情况 
		if(n-p+2<p)printf("m1 r%d m1",n-p);
		else printf("r%d",p);
	}
	else
	{
		//逆时针序列： 
		//n-p表示先对称后旋转，p表示先旋转后对称，可以取等，不必讨论这种情况 
		if(n-p<p)printf("m1 r%d",n-p);
		else printf("r%d m1",p);
	}
}
```

---

## 作者：Leap_Frog (赞：4)

# P2250二面体群（题解）

$$\Large\texttt{ps.}$$
我不知道这道题为什么会是灰的，通过数还这么少。  
作为第三个$\texttt{A}$了这道题的人，来发一篇题解。  
这道题读入调了我半天呢。  

$$\Large\texttt{problem}$$
首先，在一个平面直角坐标系中，有一个单位园，它上面均匀分布了$\texttt{n}$个点。  
然后有两种操作，可以顺时针旋转$\frac{\texttt{2}\pi}{k}$弧度，也可以把它按照$\texttt{x}$轴对称。  
求一堆操作的最短等价操作是什么。  

$$\Large\texttt{solution}$$
**第一部分**  
首先，操作二上下轴对称是对点的相对分布是五影响的。  
所以，操作二与操作一是相对独立的，操作二只与操作一的旋转方向有关。  
所以可以记录下来操作二的操作次数，然后在执行操作一的时候加入操作二的次数，记录下逆时针旋转了几个单位。  
然后就记录下来了读入。  
**第二部分**  
从第一部分可以知道操作的总体显现情况，具体的说，就是$\texttt{t=}$有没有翻转，$\texttt{x=}$逆时针旋转了几个单位。  
然后可以从$\texttt{t}$与$\texttt{x}$中推出答案，具体看代码。  

~~可能有一点玄乎，那么上代码吧~~

$$\Large\texttt{coding}$$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,t=1,a=0;
char c;
inline void init()	//第一部分 读入
{
	scanf("%d\n",&n),c=getchar();	//读入第一行的数以及第二行的第一个字符。
	while(1)	//一直循环
	{
		while(c!='\n'&&c!=EOF&&c!='r'&&c!='m') c=getchar();		//这里有锅，见下一行
		if(c=='\n'||c==EOF) break;		//数据有锅，如果这里没有EOF的话亲测最后一个点会TLE。
		scanf("%d",&x);		//读入操作数据
		if(c=='r') (a+=t*x%n)%=n;	//旋转操作直接模拟，要加上翻转操作中的顺逆时针，这条语句相当于a=(a+t*x%n)%n;
		if(c=='m') t=(x&1)?-t:t;	//翻转操作，记录下来有多少次翻转（奇数是-1，偶数是1）
		c=getchar();	//继续读
	}
	(a+=n)%=n;	//防止a<0
}
inline void out()
{
	if(n+1-a-t<a) printf("m1 r%d ",n-a),t=-t;	//这个特判也卡了我半天QwQ，特判语句我试了半天
//	1-t表示先翻转（可能之后的翻转不需要，或者之后多出来一次翻转），n-a表示翻转之后顺时针旋转。然后t要取反
	else if(a) printf("r%d ",a);	//如果a=0，就不需要输出了。
	if(t==-1) printf("m1 ");	//如果还有一次
	puts("");	//个人强迫症
}
int main()
{
	return init(),out(),0;	//完美主程序结束
}
```

---

## 作者：qianyuzhe (赞：3)

二面体群怎么能没有群论的题解，我来发一篇。

二面体群 $D_n$，由 $2n$ 个元素构成，是保持平面上正 $n(n\ge3)$ 边形不变的线性变换所成的群。它的凯莱图长这样：![](https://cdn.luogu.com.cn/upload/image_hosting/rs5kqso4.png)

我们设 $1$ 操作为沿着红边移动 $1$ 步，$2$ 操作为沿着蓝边移动 $1$ 步，于是最终状态就可以表示为 $k=f^Fr^Y$，于是原问题等价于求 $D_n$ 凯莱图上 $e$ 到某一结点的最短路。

直接求最短路肯定是不行的，有什么办法优化吗？

注意到大部分结点其实没必要存储，我们实际上只需存储 $4$ 个结点 $e,k,f,fk$ 和 $8$ 条边 $e\rightarrow k,k\rightarrow e,f\rightarrow fk,fk\rightarrow f,e\rightarrow f,k\rightarrow fk,f\rightarrow e,fk\rightarrow k$。

然后跑一遍单源最短路即可，代码（这里我用了全源最短路，反正时间差不多）：

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,d,r,f,i,j,k;
pair<int,string>w[4][4];//0:e,1:k,2:f,3:fk
char c;
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>n;
	while(cin>>c>>d){//不定项输入 
		if(c=='r')r=((r+(f?-d:d))%n+n)%n;//求R
		else if(d&1)f=!f;//求F
	}
	for(i=0;i<4;i++)for(j=0;j<4;j++)if(i!=j)w[i][j]=make_pair(1e9,"");//初始化 
	w[0][1]=w[3][2]=make_pair(r,r?("r"+to_string(r)+" "):"");//e->k,fk->f 
	w[1][0]=w[2][3]=make_pair(n-r,"r"+to_string(n-r)+" ");//k->e,f->fk
	w[0][2]=w[1][3]=w[2][0]=w[3][1]=make_pair(1,"m1 ");//e->f,k->fk,f->e,fk->k
	for(k=0;k<4;k++)for(i=0;i<4;i++)for(j=0;j<4;j++)if(w[i][j].first>w[i][k].first+w[k][j].first)w[i][j]=make_pair(w[i][k].first+w[k][j].first,w[i][k].second+w[k][j].second);//floyd求最短路 
	cout<<w[0][f?3:1].second;//k在内环则为0->3的最短路,在外环则为0->1的最短路 
}
```

或者你可以枚举所有路径，代码（其实和其它题解的代码差不多）：

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,d,r,f=1;
char c;
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>n;
	while(cin>>c>>d){
		if(c=='r')r=((r+d*f)%n+n)%n;
		else if(d&1)f=-f;
	}
	if(!r)return cout<<(f<0?"m1":""),0;//k=e或k=f 
	if(f==1){//k在外环上 
		if(r<n-r+2)cout<<'r'<<r;
		else cout<<"m1 r"<<n-r<<" m1";
	}else{//k在内环上 
		if(r<n-r)cout<<'r'<<r<<" m1";
		else cout<<"m1 r"<<n-r;
	}
}
```

---

## 作者：yong2024 (赞：2)

# [P2250 二面体群](https://www.luogu.com.cn/problem/P2250)题解
## 题意：
考虑在一个单位圆周上的 $n$ 个点，$n$ 个点的标号为 $K=0,1,\ldots,n-1$。初始的时候 $K$ 相对于 $X$ 轴的角度为 $\dfrac{360 \times k}{n}$ 度，这里的角度是相对于 $X$ 轴的逆时针角度。我们将在这组点上运行 $2$ 种不同类型的操作：

1. 顺时针旋转 $\dfrac{360}{n}$ 度。
2. 相对于 $X$ 轴的映射。

题目要求为对给出的操作序列寻找等价的最短操作序列。
## 分析：
### 1. 关于状态的确定
我们考虑 $\text n$ 固定时如何用几个数唯一确定这些点的状态（也就是找到操作序列的坐标）。因为我们如果选择两个相邻的点，它们的位置（顺时针数起第几个）和顺序（默认顺时针）就可以唯一的确定点变换后的状态，故这种状态的自由度为二。所以这里应当给出一个二维坐标 $(cntr,ch)$。$0 \le \text {cntr} < \text{n}$ 表示顺时针旋转的次数，$\text ch$ 表示其是否进行过关于 $X$ 轴的翻转（此处翻转默认在末尾进行），对于这个坐标，我们讨论以下几点：
1. 这样的坐标是否能够表示出每一种点的状态（不漏），有且仅有翻转会改变点之间的相对顺序，所以第二维就可以表示两个特征点直接的顺序，而调整第一维的大小就可以表示特征点的相对 $X$ 轴的位置，则显然可以不漏的表达每一个状态。
2. 这样的坐标是否不重复，对于第二维不同的两种状态我们考虑调整第一维能否使它们状态相同，这显然是不行的，因为第一维的调整不改变特征点的相对顺序，则不可能。当第一维不同第二维相同时，如果不调整第二维，那么某一个特征点相对 $X$ 轴位置不会相同，如果调整，那么两特征点顺序不同。

### 2. 关于题目的思路
我们现在可以唯一确定一个操作序列最终对应的状态，那么我们考虑如何将操作序列转化成状态，当连续翻转多次时，实际上只和次数的奇偶性相关，而当进行了翻转之后，进行的旋转操作相当于对原状态先逆时针旋转再进行翻转。所以我们可以建立一个变量对当前旋转是否需要取反以及最终是否翻转过做记录。

关于读入方式，我选择的是先判断操作的类型，然后用类似快读的形式将操作数读完，进行转化和记录后跳过下一个必然存在的空格以便下次读入。

最后是此题略有难度的部分，我们需要对某种状态的最短序列输出进行分类讨论。讨论如下：

1. 当没有经过旋转时，如果有翻转我们就输出一个翻转，否则不输出。
2. 当存在旋转而没有翻转时，我们有两种方法到达状态。第一种是直接进行顺时针旋转，需要进行 $\text cntr$ 次旋转，第二种是先翻转，然后进行逆时针旋转，最后再翻转，需要进行 $2$ 次翻转（一头一尾），$n-cntr$ 次旋转。比较两种方式的大小然后输出较小的即可。
3. 当旋转和翻转都存在时我们考虑先翻转然后逆时针旋转和先旋转再逆时针翻转的两种方法，第一种方法需要进行 $1$ 次翻转和 $n-cntr$ 次旋转，而第二种方法需要进行 $1$ 次翻转和 $cntr$ 次翻转，同样比较后输出较小的即可。

### 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double lf;
string x;
ll n,lenx,t=0,cntr=0;
bool is_ch=0;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	getline(cin,x);
	getline(cin,x);
	lenx=x.size();
	while(t<lenx){
		int q=0;
		switch (x[t]){
			case 'r':{
				while(isdigit(x[++t])){
					q=(q<<3)+(q<<1)+(x[t]^48);
				}
				cntr=is_ch?(cntr-q)%n:(cntr+q)%n;
				break;
			}
			case 'm':{
				while(isdigit(x[++t])){
					q=(q<<3)+(q<<1)+(x[t]^48);
				}
				if(q&1) is_ch=!is_ch;
				break;
			}
		}
		++t;
	}
	cntr=(cntr+n)%n;
	if(cntr==0){
		if(is_ch)cout<<"m1";
	}else if(!is_ch){
		if(n-cntr+2<cntr) cout<<"m1 r"<<n-cntr<<" m1";
		else cout<<'r'<<cntr;
	}else{
		if(cntr>n-cntr)cout<<"m1 "<<'r'<<n-cntr;
		else cout<<'r'<<cntr<<" m1";
	}
	return 0;
} 
```

---


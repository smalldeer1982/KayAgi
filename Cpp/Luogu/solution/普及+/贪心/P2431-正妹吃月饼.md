# 正妹吃月饼

## 题目描述

今天是中秋节。uim 带来了一堆大小不同且味道各异的月饼。

这些月饼的质量分别是 $1g,2g,4g,8g,16g$....后面一个是前面的 $2$ 倍。每种只有一个。

uim 让正妹随便吃。

正妹希望尝试尽可能多的口味，所以会吃尽可能多数量的月饼（不是重量）。而且她的确有些饿了，至少总共要吃掉 $A\text{g}$ 的月饼才能满足。

然而正妹怕长胖，所以吃月饼不能合计超过 $B\text{g}$ 。

她希望知道自己最多能吃多少个月饼


## 说明/提示

**样例解释**：

正妹可以吃 $1,2,4,16$ 这 $4$ 个月饼（吃法可能不唯一）。

**数据范围**：

对于 $30\%$ 数据，$1\le A,B \le 1000$；

对于 $60\%$ 数据，$1 \le A,B \le 100000$；

对于 $100\%$ 数据，$1 \le A,B \le 2^{63}-1$。


## 样例 #1

### 输入

```
16 25```

### 输出

```
4```

# 题解

## 作者：Invoker (赞：69)

其实这道题是Codeforces 485C 原题改编....

大致的思想就是把l二进制分解之后从最低位开始找，每当找到一个0时就贪心地判断把它变成1之后是不是比r小。

```cpp
#include<iostream>
#define LL long long
using namespace std;
int main()
{
    int ans=0;LL l,r;cin>>l>>r;
    while((l|(l+1))<=r)l|=l+1;
    while(l)ans+=l&1,l>>=1;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Dog_Two (赞：20)

与原题题解相对地，我们考虑倒序**减**。

用一个k位**全为1**的整数val表示初始的月饼集合，根据进制知识易知，这个整数的值就是这些月饼的重量和。

这个整数应当是**第一个恰好不小于B的二进制全1数字**。

此后，我们从这个数的最高位(恰好是2^(k-1))开始向低位考虑，算法流程如下：

- 减去这个数（2^(k-1)）后，月饼的重量和小于A,则不考虑这一位；
- 否则，使这一位变成0，也即减去2^(k-1)；
- 如果月饼集合恰好不大于B，跳出。

下面说明算法的正确性：

### 对于初始的月饼集合取值来说：
- 最优解一定能表示为一个若干位为1的二进制数。初始值取全1二进制数不会导致更差的解，因为在集合的角度，最优解是val的一个子集；

- 同上，初始值如果取小于B的全1二进制数，可能不包含最优解集合，而val不会带来错误的解，故初始值不应当小于B；

- 如果我们取了大于题设val的全1二进制数（设为S）作初始值，易知，S的最高位表示(val+1)*2，删去后仍然大于B，在算法流程中，我们会将其删去，它一定不会为解带来贡献，故不选大于val的值作初始值。

综上，我们通过全1二进制数作初始值的 正确性、决策（答案）包容性、不冗余性**说明**了恰好不小于B的全1二进制数作初始值的正确性。

### 对于算法流程本身来说

- 如果当前只需按照算法流程再减去1位（a=2^k）即求得最优解，设当前的值为num,应当有num-a∈[A,B]。

- 不妨设num-a'∈[A,B]。可以发现，a'!=a时，不存在花费不超过1的转移方法，故a取2^k时是“临界”状态的最优解。

- 对于上述可以导致最优解的num，设从num+b转移而来（num=num+b-b）。

- 显然，num+b->num的转移以1为代价时，解最优，所以，b是2的幂次。

- 根据归纳法，一个能导致最优解的状态，一定是从初态val不断减去2的一个幂次转移来的。

- 初态val(全1二进制数)包含正解的正确性我们已经证明。

### 论毕

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
ULL A,B;
int main(){
	cin>>A>>B;
	ULL val=1;
	while(val<B) val=(val<<1)+1;
	ULL Bit=(val+1)>>1;
	for(;val>B;Bit>>=1){
		val=val-Bit<A?val:val-Bit;
	}
	int cnt=0;
	for(;val;val>>=1) if(val&1) ++cnt;
	cout<<cnt;
	return 0;
}
```


---

## 作者：joooooel (赞：16)

看完楼上一众大佬的题解，十分懵比，二十多篇题解没有一个和我相似的方法......兴奋，my第一篇题解要诞生了

作为一个看到二进制就头大的**蒟蒻**，只能用非二进制的思路瞎搞一下了.....

# 正题

因为数据范围是
$$(A,B)\leq2^{63}-1$$

所以正好是在$long long \geq cake [i]  $的范围 

又因为每个cake的质量是前一个cake质量的2倍

所以用一个$long long$   $cake [i]$ 来储存每个蛋糕的质量。

因为$cake[i]=2^{i-1}$,所以总的空间复杂度不超过$log_2 {2^{63}-1} \approx 63$

所以这样就算是 $ O(n^4) $的算法也不会TLE。

### 接下来就是贪心的思路

#### 思路$1.$ 一个变量top表示质量小于B且质量最大的cake，$ 2^{top} \leq B, top  = \lfloor {log_2 B}\rfloor$ 因为质量大于B的cake我们肯定不会选。

#### 思路$2.$如果1~top个cake我们都要选，必然会得出$\sum_{i=1}^{top} {cake_[i]}\geq B$所以，我们先计算出$sum=\sum_{i=1}^{top} cake[i]$。

#### 思路$3.$如果$sum=B$，我们直接输出top的值。
###### 也就是所有cake都选刚好不大于B,这样显然是最优的情况。
#### 如果$sum > B$,定义$ans=top$,我们做一个死循环，死循环要做的事情就是，里面嵌套一个$top\sim1$的循环，每次减去1个$cake[i] ,(i\in top \sim 1)$ 之间（从大到小），使得sum正好不小于A的第一个cake。如果$cake[i]$没有被减掉过，标记这个$i$ ,  使$sum=sum-cake[i] (1\leq i \leq top ) $这样我们就得到了最小满足$a \leq sum$条件的$sum$

### 跳出死循环后，这时我们得到的sum是最小的符合条件的值，我们要再做一个从小到大$1\sim top$的循环，将已经减过的$cake[i],cake[i]=true,(1\leq i \leq top)$尽可能加回来使得吃的cake更多。 一直加到$sum>B$的时候break掉，每加一次ans++;

### 这时，ans就是我们想要的最大的不大于B的方案。

#贴上代码

```cpp

long long cake[64];
long long ans[64];
bool b[64]={0};
long long sum=0;
long long a,B,top=0;
long long v=1;
long long pow(int a,int b){//可有可无的快速幂，因为本题数据范围很小，所以不用担心计算幂的时间会爆掉
	if(b<=0)return v;
	if(b==1)return a;
	else if(b%2==0){
		long long ans=pow(a,b/2);
		return ans*ans;
	}
	else if(b%2!=0){
		long long ans=pow(a,b/2);
		ans=ans*a;
		return ans;
	}
}

int main () {
	cake[63]=9223372036854775807LL;//2^63计算会直接爆Long Long
//	freopen ("cake.in","r",stdin);
//	freopen ("cake.out","w",stdout);
	cin>>a>>B;
	for (int i=1;i>=1;i++){
		if(top==63)
			break;
		long long weight=pow(2,top);top++;
		if(weight<=B)cake[top]=weight;//cake[top]=2^(top-1)
		else {
			top--;//top++会多算一次
			break;
		}
	}
	for (int i=1;i<=top;i++){
		sum+=cake[i];
	}
	for (int i=1;i>=0;i++){
		if(sum<=B&&sum>=a){
			for (int j=0;j<=top+1;j++){
				if(b[j]==1){//如果第j个蛋糕被减掉过
					if((sum+cake[j])<=B){//被减掉的的蛋糕再加回来是否还能满足条件
						sum=sum+cake[j];
						top++;满足就加回来
					}
				}
			}//求满足条件的最小值最多能加到多少
			cout<<top;//也就是求出了满足条件的最大值
			break;
		}
		else if(sum>B){
			for (int j=top;j>=1;j--){
				if((sum-cake[j])>=a&&b[j]==false){
					sum=sum-cake[j];
					b[j]==1;求出满足条件的最小值
					top--;
					break;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：zrzluck99 (赞：14)

这里挑战一下最短代码题解

看到 $1,2,4,8,16...$ 我们就能想到这是一道关于位运算~~骚操作~~的题目。但是盲目遍历显然会T。那么怎么办呢？

经过一番思索~~瞎猜~~，我们可以发现一个规律：如果从高位到低位遍历，那么 $a$ 和 $b$ 在最高的不同的位之前都是不能动的。这么说可能有点不明白举个~~糖炒~~栗子：

```
a=16: 010000
b=25: 011001
        ↑
      就是它
```

我们暂且把它称为异位。这样我们就发现了一个好方法：把 $a$ 异位后的所有位都填上 $1$，就珂以填充尽量多的 $1$ 了。~~吼啊~~

但是这样还有一个问题，如果碰见这样的情况：

```
a=32: 100000
b=39: 100111
         ↑
```

也就是 $b$ 在异位后全为 $1$，这样取到 $b$ 更优。（然而数据太水，不判它都过了）

珂以证明，其他所有情况取到 $1$ 的个数不会大于上面的取法。

接下来就是代码实现了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long x,y; scanf("%lld %lld",&x,&y);
    long long t=x^y; //取异位，这里偷了个懒，因为异位后面的1对答案没有影响
    while (t>0) t>>=1, x|=t; //把x异位后面填上1
    long long q=0; while (x>0) x&=x-1, q++; //判x中1的个数
    long long r=0; while (y>0) y&=y-1, r++; //判y中1的个数
    printf("%lld\n",max(q,r));
    return 0;
}
```

---

## 作者：MC_Launcher (赞：12)

## 用2进制他不香么

看了其他题解，太复杂了~~（其实是我看不懂）~~，还是写一篇简洁易懂的题解吧。

首先要明白一个事实：任何一个数都能用2的任意次方相加所得。这里我就不予证明啦，有兴趣的朋友上网搜一下。


------------
正题开始
而月饼的重量都是2的次方嘛...

刚好填满明显是最优解，既然题目范围是小于2的64次方，开2个64的数组就行啦，从小到大来记录，明显比从大到小记录简单，因为月饼重量后一个是前一个的2倍，所以前面的月饼全吃完也没有后面的月饼重，而数量要多得多，这样它不是很香么？就像“日取其半”一样，这里给大家解析一下样例

输入16 25

从下往上

首先16的话

10000刚好满足

25的话

10001从下往上找，+1，阔以

10011再吃一个2g的，还是可以

10111再吃一个4g的，恩，还行

11111？不行了，超过25了

OK，4个

这样也和答案一样
粘代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long Max[64],Min[64];//开局2数组，装备全靠写，当然bool类型也行
int main()
{
    long long a,b,num=0,c,d,e;
  //a，b是最多和最少，c,d,e都作为临时储存变量
    cin>>b>>a;//标准输入流它不香么
    d=b;
    e=a;
    int n=-1;//计数器
    while(a>0)//记录每一位是否进入，不停地mod2呗，这样就能得到最优解
    {
        Max[++n]=a%2;
        a/=2;
    }
    n=-1;
    while(b>0)//看看最小值要多少
    {
        Min[++n]=b%2;
        b/=2;
    }
    for(int i=0;i<64;i++){
        if(Min[i]==1)//记录最小月饼数
        {
            num++;
        }
    }
    c=0;//计数器万岁
    int i=1;
    while(e>=d)//判断月饼数量是否超过最大
    {
        if(Min[c]==1)//吃了这一块么？
        {
            c++;//吃了？加一
        }
        else
        {//没有？那你快吃啊
            d+=i;
            num++;
            c++;
        }
        i*=2;
    }
    cout<<num-1;
}
```
拒绝抄袭，从你我做起

---

## 作者：Nero_Claudius (赞：8)

假如做这道题想着用如下朴实的模拟，那肯定要WA至少4个点。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;

int main() {
	ll a, b, sum = 0, ans = 0;
	cin >> a >> b;
	while(sum <= b) {
		ans++;
		sum = sum << 1 | 1;
	}
	cout << ans;
}
```

原因在于，数据大小。。。（2^63-1）

就比如说第二个点，输入数据如下：

> 140737488355336 140737488355456

能过才是奇迹。。。

------------


那么显然我们应该使用位运算。

在这里先普及一下这玩意，尽管我觉得大家都会。。。

最基本的是左移和右移，分别是<<和>>。

他们具体的作用是将一个数的二进制位左移和右移。

然后有与或非亦或，即&,|,!,^

这几个很好理解，参考逻辑运算符就可以了。

知道了这下，那么新的思路就很明显了。

一位一位的看，如果是1就不管，如果是0就看改成1后符不符合题意。

最后再来统计1的数量。

程序如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

int main() {
    int ans = 0;
	ll a, b;
	cin >> a >> b;
    while((a | (a + 1)) <= b) a |= a + 1;
    while(a) {
    	ans += a & 1;
		a >>= 1;
	}
	
    cout << ans;
}
```

【注意：long long一定要加！！！去掉了之后就只有80分了，两个点TLE！！】

---

## 作者：Mark_ZZY (赞：7)

表示不会写位运算版的~~~，其实都是0ms啦

就是求n~m二进制中，所含最多的1的个数，因为2的幂次方都是(10000...0)2，若有最多的1，说明选的二的幂次方就越多

证明1的位置不移动可以得到最优解(只看一个1的情况)：

1:假设(n)2中的1可以往前移，那么

(1)这个数的十进制超过了m   结论是:1的位置不可以移动

(2)这个数的十进制小于等于m，但却得到了一个更大的数，假设我们只改变0，即使不一定得到最优结果，但得到的数也会小于这个数，因此，1的个数大于等于这个数的1的个数(important)   结论是:1的位置不可以移动(不动一定得到最多的1，动不一定得到最多的1)

2.假设(n)2中的1可以往后移，那么

所得的数一定小于n，结论是:1的位置不可以移动

在可以移动多个1时，综合以上几点，发现结论是:1的位置不可以移动(就不证明了)

```cpp
#include<cstdio>
typedef unsigned long long ull;
    ull n,m,t=0,ans=-1;
    int a[100];
int main()
{
    scanf("%llu %llu",&n,&m);
    while(n>0)
    {
        a[t++]=n%2;
        n/=2;
    }
    t=70;
    while(1)
    {
        for(int i=0;i<t;i++)
            if(a[i]==0)
            {
                a[i]=1;
                break;
            }
        ull s=0,p=1;
        for(int i=0;i<t;i++)
            s+=a[i]*p,p<<=1;
        //printf("%llu\n",s);
        if(s>m) break;
    }
    for(int i=0;i<t;i++)
        ans+=a[i];
    printf("%llu",ans);
}
```

---

## 作者：hensier (赞：3)

本题可以让我们联想到二进制。

对于一个二进制数，我们可以根据数位值的性质求出它所对应的十进制数。

例如：

|数位|$1$|$0$|$1$|$0$|$0$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|表达式|$1\times2^4$|$0\times2^3$|$1\times2^2$|$0\times2^1$|$0\times2^0$|
|对应值|$16$|$0$|$4$|$0$|$0$|

因此二进制数$10100$转换为十进制就是：$16+0+4+0+0=20$。

在本题中，我们有一个十进制数，转为二进制就知道要吃哪几块蛋糕。以刚才的$20$为例：

|被操作数|表达式|余数|
| :----------: | :----------: | :----------: |
|$20$|$20\div2=10$|$R0$|
|$10$|$10\div2=5$|$R0$|
|$5$|$5\div2=2$|$R1$|
|$2$|$2\div2=1$|$R0$|
|$1$|$1\div2=0$|$R1$|

将刚才所得的所有余数连成一排并翻转，就能得到二进制数。

这里不需要得到序列，只需要个数，所以有：

```cpp
int cnt(ll x)//定义函数
{
    int num=0;//开始定义计数器为0
    while(x)//只要x>0就继续
    {
        if(x&1)num++;//x&1等同于x%2，如果余数为1，计数器就加1
        x>>=1;//x>>=1等同于x/=2，该操作与上表类似
    }
    return num;//返回
}
//下面将会把这个函数记作cnt(x)
```

事实上，题目中给了两个数$a,b$，让我们在$[a,b]$区间内寻找对应二进制$1$最多的数。

对于一个在$[2^n,2^{n+1})$区间的十进制数$i(n∈N^+)$，必定满足$cnt(i)=n+1$。

而在上述区间内，总数是相同的，所以要想让$1$最多，那么全为$1$就一定是最多的情况，即$cnt(2^{n+1}-1)$在这个区间是最大的。例如，$cnt(14)=3,cnt(15)=4$，那么$cnt(15)>cnt(14)$（$14$在二进制下为$1110$，$15$为$1111$）。

不过，这只是在区间确定的情况下可以使用的，而$n$实际上是越大越好，因为$n$越大，$cnt(2^{n+1}-1)$也必定越大。

因此，我们现在的任务就是找到$[a,b]$区间最大的$2^{n+1}-1$。

```cpp
int find(ll num)
{
    ll s=1,i=0;//s初始赋值为1，i用来循环
    for(;;i++)
    {
        if(s>=num)break;//如果s不小于num就退出循环
        s<<=1;
        s++;//这两句等同于s=s*2+1
    }
    return i;//返回i
}
```

我们把$1-64$的数作为参数调用$find$函数，输出结果经过整理可以得到：

```
find(1)=0//find(1)结果为0
find(2-3)=1//find函数的参数为2-3时，find函数返回1
find(4-7)=2//以此类推
find(8-15)=3
find(16-31)=4
find(32-63)=5
find(64)=6
```

我们设置一个变量$x$来保存$2^{find(b)}-1$。

显然，这是符合$\text{\color{red}{大部分}}$数据的。唯一需要处理的时候，是当这个参数本身就是能够写成$2^{n+1}-1$形式的情况。

其实，当上述条件成立的时候，我们找到的数$find(b)$要比实际值小。例如$find(3)$的结果应该为$2$，也就是说，每一个$find(x)$比实际上应该得到的要小$1$。

这个时候我们就要检查这个数是否能写成这种形式：

```cpp
bool check(ll n)
{
    ll s=1;
    for(int i=0;;i++)
    {
        if(s>n)return 0;//如果超过被测数就说明不能写成这种形式
        if(s==n)return 1;//如果等于的话说明可以写成
        s<<=1;
        s++;//等同于s=s*2+1
    }
}
```

当$check$函数返回值为真，则$x$要重新赋值，应该把$x$赋值为$2x+1$，即乘$2$加$1$。

这个时候，$x$就是不超过$b$的最大的能够写成$2^{n+1}-1$的数。

但是，棘手的问题是，$x$不一定是大于等于$a$的。在这种情况下，我们就必须要把$[a,b]$的数全部跑一遍。即，找到所有的$cnt(i)$的最大值$(i∈[a,b])$。否则，就直接输出$cnt(a)$。

代码（~~前面解释的很清楚，就不加注释了~~）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll a,b,x;
int cnt(ll x)
{
    int num=0;
    while(x)
    {
        if(x&1)num++;
        x>>=1;
    }
    return num;
}
ll find(ll num)
{
    ll s=1,i=0;
    for(;;i++)
    {
        if(s>=num)break;
        s<<=1;
        s++;
    }
    return i;
}
void cal(ll lbound,ll rbound)
{
    int y=0;
    for(ll i=lbound;i<=rbound;i++)
    {
        int x=cnt(i);
        if(x>y)y=x;
    }
    printf("%d",y);
}
bool check(ll n)
{
    ll s=1;
    for(int i=0;;i++)
    {
        if(s>n)return 0;
        if(s==n)return 1;
        s<<=1;
        s++;
    }
}
int main()
{
    scanf("%lld%lld",&a,&b);
    x=(1<<find(b))-1;
    if(check(b))
    {
        x<<=1;
        x++;
    }
    if(x>=a)printf("%d",cnt(x));
    else cal(a,b);
}
```

上述代码本蒟蒻不保证$100\%$不超时。在有些情况下可能要开$O2$。更快捷、简便，使用位运算的代码，题解区已经有很多，本蒟蒻这里只给出纯模拟代码。希望各位大佬能够理解。

---

## 作者：槑小杨 (赞：2)

这题暴力肯定会炸掉。

很自然就会联想到二进制的做法（实际上是因为标签里有进制）。

把$B$进行二进制拆分以后，对于每个位的1，我们可以把它去掉，然后直接把比它低的位全置1，从高到低枚举1，当第一次产生的新数比$A$大时，既贪心的去想，就是答案了。


```c
#include <cstdio>
#define ll long long
ll a,b;
ll max(ll x,ll y){return x>y?x:y;}
ll cal(ll x)
{
    ll cnt=0;
    while(x) x-=x&-x,cnt++;
    return cnt;
}
int main()
{
    scanf("%lld%lld",&a,&b);
    ll tmp=b,len=0,ans=0;
    while(tmp) len++,tmp>>=1;
    ans=max(cal(b),ans);
    ll one=1;
    for(ll i=len;i;i--)
    {
        if((b>>i-1)&1)
        {
            ll t=b^(one<<i-1);
            t|=(one<<i-1)-1;
            if(t>=a)
                ans=max(cal(t),ans);
        }
    }
    printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：ws_fqk (赞：1)

题目即求某范围内的一个数，使得次数在二进制下1的个数最多。

于是我们进行贪心，从a的最低位开始枚举，如果某一位是0就把它变成1。如果超过b就break。

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
ll a,b,bin[63];
int sum;
int main()
{
    scanf("%lld%lld",&a,&b);
    bin[0]=1;
    for (int i=1;i<=62;i++) bin[i]=bin[i-1]<<1;
    for (int i=0;i<=62;i++) 
    {
        if (a&bin[i]) sum++;
        if (bin[i]>a) break;
    }
    for (int i=0;i<=62;i++)
        if ((a&bin[i])==0) {if (a+bin[i]<=b) a+=bin[i],sum++; else break;}
    printf("%d",sum); 
    return 0;
}
```

---

## 作者：pantw (赞：1)

嘛，又是一道二进制题。


分析题意之后，我们可以知道的是：

题目求的是a到b（含）之间的所有数中，二进制下1最多的数量。

亦即：

$\max\limits^{b}_{i=a}(popcount(i))$

其中popcount(i)代表i的二进制表示中1的个数。在C++中可以使用`\_\_builtin\_popcount()`。


由于$a,b<=10^{18}$，我们往更高效的方向考虑。

鉴于其余的解题思路题解区的几位已经叙述得很清晰了，这里不再赘述，而是介绍几个小技巧；


1. hb函数。hb取自highbit，类似树状数组那个lowbit。由于我暂时想不到什么更好的实现方式于是实现如下。思路是减去lowbit直至lowbit值等于本身。则此时得到的值即为所求。

2. 简化代码。`\_\_builtin\_\_ctz()`函数，ctz可理解为count trailing zeros，取得某数的二进制表示中结尾的0的个数。注意当参数为0的时候行为未定义，需要特判。


```cpp
#include <cstdio>
long long hb(long long a) {
    for(; ; a -= a & -a) if(a == (a & -a)) return a;
}
int main() {
    long long a, b, ans;
    scanf("%lld%lld", &a, &b);
    for(ans = 0; a && hb(a) == hb(b); a -= hb(a), b -= hb(b), ans++) ;
    printf("%d", (int)ans + (b ? __builtin_ctz(hb(b)) : 0));
}
```

---

## 作者：rfsfreffr (赞：0)

题意：
可以简化为：

在十进制数a~b之间哪个数字的二进制表达各个位数之和最大（也就是1的个数)

# 我的解法

~~由于我太菜了，没有想出通解~~

## 1.2a<=b

设(a)10=(100100101....100)2,(b)10=(10010001011...00)2 (b比a多1位或以上)

则最优解为 (1111111....1111)2   (1的个数为b的个数-1,最优解不知这一个)

在这种情况下,答案就是b的二进制位数-1

即输出

```cpp
cout<<floor(log2(b))<<endl;
```

## 2.a==b

这钟情况比较简单,就是直接输出a的二进制表达中有多少个1即可

## 3.其他情况

这种情况分为3步

1.将数字分解为二进制数

2.判断a==b的情况并输出答案

3.

当样例为16 25时

(16)10=(10000)2 (25)10=(11001)

发现其中一种最优解为 (10111)2=(24)

还看不出什么规律

当样例为 16 20

(16)10=(10000)2 (20)10=(10101)

答案为 17(10011)

然后就发现一个规律:

10000

10101

前两位除了第一位，有一位两个数都为0

所以答案就为 (5-1)-1=3

又尝试了几个样例，得出一下结论


**从最高位扫到最后一位（注意此时a与b的二进制表达的位数相同）,如果哪一位出现了一个1,就直接break,输出此时原来二进制表达的位数-扫过的位数-1**

# 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b;
int a0[1001],b0[1001];
int a11,b11;
int t;
int main(){
	cin>>a>>b;
	if(a*2<=b) {//判断 2a<=b 的情况
		cout<<floor(log2(b))<<endl;
		return 0;
	}
	a11=a;
	b11=b;
	int len1=0,len2=0;
	while(1){//将二进制表达求出
		a0[++len1]=a%2;
		a/=2;
		if(a==0) break;
	}
	while(1){
		b0[++len2]=b%2;
		b/=2;
		if(b==0) break;
	}
	if(a11==b11){//判断 a==b 的情况
		for(int i=len1; i>=1; i--){
			if(a0[i]==1){
				t++;
			}
		}
		cout<<t<<endl;
		return 0;
	}
	for(int i=len1-1; i>=1; i--){//其他情况
		if(a0[i]==b0[i]&&a0[i]==0&&b0[i]==0){
			t++;
		} else break;
	}
	cout<<len1-t-1<<endl;
	return 0;
}
```

---

## 作者：Mychael (赞：0)

我们设B<A【诶呀都一样的啦】

我们要求的就是[B,A]中二进制数1最多的数的1的数量


仔细观察发现，如果A与B的二进制位数不同，那么答案一定是A+1的位数-1

因为只要A，B位数不同，就一定存在全是1的A-1位的数，除非A全是1，否则A-1位的1就是答案


相同怎么办？

按照贪心的思想，B从最低一个不是1的位开始换成1，直至B>A，这个时候B有的1数量就是答案




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long int
using namespace std;
const int maxn=100005,INF=2000000000,P=1000000007;
LL A,B,z=1;
int main(){
    cin>>B>>A;
    int a=0,b=0,c=0,cnt=0;    //a,b,c分别表示A，B,A+1的二进制位数
    LL t=A;
    while(t) t>>=1,a++;
    t=A+1;
    while(t) t>>=1,c++;
    t=B;
    while(t){if(t&1) cnt++;t>>=1;b++;}
    if(b<a) cout<<c-1<<endl;   //A,B位数不同，答案一定是A+1的位数-1
    else{                      //按照贪心的思想，B从最低位开始加1，直至大于A
        for(LL i=0;B<A;i++){
            if(!((B>>i)&1)){
                B=B|(z<<i);
                if(B<=A) cnt++;
            }
        }
        cout<<cnt<<endl;
    }
    return 0;
}

```

---

## 作者：zeromaker (赞：0)

因为月饼的质量都是2的N次幂，所以一个月饼代表一个二进制1，这题的题意就是求在A到B之间数最多能有几个二进制1。因为所求的数要在AB之间，所以我们只要把A与B第一个不同的二进制位取出，如果A后面全是1，那么答案后面也全部设为1，如果A后面不全为1，那么答案从该位的下一位开始设置为1，在该位之前，答案和A与B的每一位都相同，然后统计答案的1的个数即可。

```cpp

#include<iostream>  
#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
#include<algorithm>  
#include<string>  
#include<math.h>  
using namespace std;  
  
long long ia,ib;  
int ibita[100],ibitb[100];  
int ibitf[100];  
int sumibita[100],sumibitb[100];  
  
int main()  
{  
    scanf("%lld%lld",&ia,&ib);  
    if (ia>ib)  
    {  
        printf("%d\n",0);  
        return 0;  
    }  
    long long tempa=ia,tempb=ib;  
    sumibita[0]=0;  
    sumibitb[0]=0;  
    while (tempa>0)  
    {  
        ibita[++ibita[0]]=tempa%2;  
        sumibita[ibita[0]]=sumibita[ibita[0]-1]+ibita[ibita[0]];  
        tempa/=2;  
    }  
    while (tempb>0)  
    {  
        ibitb[++ibitb[0]]=tempb%2;  
        sumibitb[ibitb[0]]=sumibitb[ibitb[0]-1]+ibitb[ibitb[0]];  
        tempb/=2;  
    }  
    long long len=max(ibita[0],ibitb[0]);  
    bool flag=false;  
    long long ans=0;  
    for (int i=len;i>=1;i--)  
    {  
        if (flag)  
        {  
            ibitf[i]=1;  
            ans++;  
            continue;  
        }  
        if (ibita[i]==ibitb[i])  
        {  
            ibitf[i]=ibita[i];  
            if (ibitf[i]==1)  
                ans++;  
        }  
        else  
        {  
            flag=true;  
            if (sumibitb[i-1]==i-1)  
            {  
                ibitf[i]=1;  
                ans++;  
            }  
        }  
    }  
    printf("%lld\n",ans);  
}  

```
当然，直接的暴力求解是有80分可以拿的

```cpp

#include<iostream>  
#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
#include<algorithm>  
#include<string>  
#include<math.h>  
using namespace std;  
  
long long ia,ib;  
  
int main()  
{  
    scanf("%lld%lld",&ia,&ib);  
    long long ans=-1;  
    long long tt;  
    for (long long i=ia;i<=ib;i++)  
    {  
        long long temp=0;  
        long long n=i;  
        while (n >0)  
        {  
            if((n &1) ==1)  
                ++temp ;   
            n >>=1 ;   
        }  
        if (temp>ans)  
        {  
            ans=temp;  
            tt=i;  
        }  
    }  
    printf("%lld\n",ans);  
}  

```

---


# [ZJOI2008] 泡泡堂

## 题目描述

第 XXXX 届 NOI 期间，为了加强各省选手之间的交流，组委会决定组织一场省际电子竞技大赛，每一个省的代表队由 $n$ 名选手组成，比赛的项目是老少咸宜的网络游戏泡泡堂。每一场比赛前，对阵双方的教练向组委会提交一份参赛选手的名单，决定了选手上场的顺序，一经确定，不得修改。比赛中，双方的一号选手，二号选手……，$n$ 号选手捉对厮杀，共进行 $n$ 场比赛。每胜一场比赛得 $2$ 分，平一场得 $1$ 分，输一场不得分。最终将双方的单场得分相加得出总分，总分高的队伍晋级(总分相同抽签决定)。

作为浙江队的领队，你已经在事先将各省所有选手的泡泡堂水平了解的一清二楚，并将其用一个实力值来衡量。为简化问题，我们假定选手在游戏中完全不受任何外界因素干扰，即实力强的选手一定可以战胜实力弱的选手，而两个实力相同的选手一定会战平。由于完全不知道对手会使用何种策略来确定出场顺序，所以所有的队伍都采取了这样一种策略，就是完全随机决定出场顺序。

当然你不想这样不明不白的进行比赛。你想事先了解一下在最好与最坏的情况下，浙江队最终分别能得到多少分。


## 说明/提示

样例说明

1：我们分别称 $4$ 位选手为 $A,B,C,D$ 。则可能出现以下 $4$ 种对战方式，最好情况下可得 $2$ 分，最坏情况下得 $0$ 分。

| | 浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |  浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
| 一号 | A | C | 负 | A | D | 负 | B | C | 胜 | B | D | 负 |
| 二号 | B | D | 负 | B | C | 胜 | A | D | 负 | A | C | 负 |
| 得分 |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |


2：对手都是认真学习的好孩子，不会打游戏。无论如何排列出场顺序都无法改变被蹂躏的结果。浙江队总能取得全胜的结果。

$20\%$ 的数据中，$1\leq n\leq 10$；

$40\%$ 的数据中，$1\leq n\leq 100$；

$60\%$ 的数据中，$1\leq n\leq 1000$；

$100\%$ 的数据中，$1\leq n\leq 100000$，且所有选手的实力值在 $0$ 到 $10000000$ 之间。


## 样例 #1

### 输入

```
2
1
3
2
4
```

### 输出

```
2 0```

## 样例 #2

### 输入

```
6
10000000
10000000
10000000
10000000
10000000
10000000
0
0
0
0
0
0
```

### 输出

```
12 12```

# 题解

## 作者：steven张 (赞：60)

注意，楼下部分题解虽然程序对了，但是思路并不对。
部分题解写田忌赛马是错的，因为在求解己方最大值时，使用己方最弱换掉对方最强可能会浪费己方最弱的“战斗力”（指的是战胜对方最弱的可能）。
但是注意，一旦对方最弱比己方最弱更弱，那么就意味着，己方最弱的价值（两分）一定会转移到己方其他人身上（由其他人干掉对方最弱），所以己方最弱是否去打对方最强这个抉择，与己方最弱是否比对方最弱更强无关。
那么田忌赛马的贪心为什么是错的呢？
我们试着写一下程序可以发现：田忌赛马的思路是当己方最强比不过对方最强时，用自己最弱做替补。
**但是这里并没有对如果两方最强实力相等做说明（重点）。**
如果我们设置田忌赛马的思路是己方最强大于等于对方最强时用己方最强换掉对方最强。那么下面的数据会出错
2
1 3
2 3
己方会选择（3->3）(1->2),而最大值是(3->2)(1->3)
如果我们设置田忌赛马的思路是己方最强大于对方最强时用己方最强换掉对方最强。小于等于时用己方最弱换掉对方最强。
2
2 3
1 3
己方会选择 (3->1)(2->3),而最大值是(3->3)(2->1)

那么就意味着如果两个最大值相等，这时候用最弱来替换不一定是最优决策，因此我们才要看最弱的情况，才有了后面的判断。
代码下面都是对的，不过有些思路有问题，特此指出。

---

## 作者：MaxDYF (赞：34)

读完这题后，我们可以想到一个贪心策略：每次操作，将己方最low的和对面最犇的进（song）行（ren）PK（tou），这样，就构成了田忌赛马的策略。
    
### 但是，田忌赛马的策略是正确的吗？
    
比如说有一组数据：
```
5
4 5 6 7 8
3 4 5 6 7
```

按照田忌赛马的策略，我方最low的要去和对面最犇的千里送，然后构造最优条件，也就是赢4次，输1次。但是，我们可以很明显的看出，就按照输入顺序打的话，其实我方是可以全胜的（1打1,2打2,3打3……）。所以可以看出，田忌赛马的策略并不完全正确。
    
注意，我说的是不完全正确。因为AC程序的策略也是来自于田忌赛马。我们可以看出，如果我方最low的，可以把对方最low的虐爆，那我们就没有必要让其去送人头（因为贪心思想就是以小搏大，既然有更小的代价获取同样的价值，那么就没有必要让战力更高的去虐）。如果我方最low的打不过对面最low的或者说只能打平，那么，我们就应该让最low的去送人头了。
    
但是，这样的话，我们就得不到分了。如果我们最犇的可以虐对面最犇的呢？所以，我们还要比较我方最犇的能不能**虐**（注意哦，是**虐**）对面最犇的。如果虐的过，就没必要送人头。如果平手或打不过，再去送人头也不迟。
    
如果你已经想到上面的策略了，那么，你还不能够AC。因为，如果对方的全队战力是一样的，而你最low的刚好等于对面的战力呢？所以，我们还要做一个特殊判断：当我方最low的去送人头的时候，还要判断一下是否平手。
    
### 所以说，我们的总策略如下：
```
1、判断最弱的能否完胜对方最弱的，不能就跳2.
2、判断最强的是否能完胜对方最强的，不能就跳3.
3、判断最弱的和对方最强的是否平手.

```

### AC代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int work(int a[],int b[],int n)
{
	int h=1,t=n,l=1,r=n;
	int ans=0;
	while(h<=t&&l<=r)
	{
		if(a[h]>b[l]) {ans+=2;h++;l++;}
		else if(a[t]>b[r]) {ans+=2;t--;r--;}
		else {ans+=a[h]==b[r];h++;r--;}
	}
	return ans;
}
int a[100000],b[100000];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	printf("%d ",work(a,b,n));
	printf("%d",2*n-work(b,a,n));//我方最坏情况即对方最好情况。只需把对方当成我方计算即可。
}
/*
 4
 1 2 3 4
 2 3 4 5 
 */

```


---

## 作者：timsu1104 (赞：10)

一种错误的想法是一旦我方最强的打不过对方的，就让最弱的去换掉对方最强的。这种想法的问题在于我方最弱的可能比对方最弱的要强，能够创造一个2分的价值，这时便不应让他去送死。


贪心策略：

强打强 if 我方最强强于对方最强；

弱打弱 if 我方最弱强于对方最弱；


else 最弱打最强送死为其他人创造机会。

c++代码如下：

    
    
    
    
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans;
long long zj[100001],en[100001];
long long hzj,hen,tzj,ten;
bool cmp(int a,int b){return a>b;}
int main()
{
    scanf("%d",&n);
    tzj=ten=n-1;
    for(int i=0;i<n;i++) scanf("%d",&zj[i]);
    for(int i=0;i<n;i++) scanf("%d",&en[i]);
    sort(zj,zj+n,cmp);
    sort(en,en+n,cmp);
    while(hzj<=tzj)
    {
        if(zj[hzj]>en[hen]) ans+=2,hzj++,hen++;
        else if(zj[tzj]>en[ten]) ans+=2,tzj--,ten--;
        else ans+=(zj[tzj]==en[hen]),hen++,tzj--;
    }
    printf("%d ",ans);
    hzj=hen=ans=0;
    tzj=ten=n-1;
    while(hzj<=tzj)
    {
        if(zj[hzj]<en[hen]) ans+=2,hzj++,hen++;
        else if(zj[tzj]<en[ten]) ans+=2,tzj--,ten--;
        else ans+=(zj[hzj]==en[ten]),hzj++,ten--;
    }
    printf("%d",2*n-ans);
    return 0;
}
```

---

## 作者：Flandre_495 (赞：8)

## 调了一个上下午，终于用我自己的思路A了，写篇题解纪念一下。


关于本题与田忌赛马的正确性争议不小，我来说一个绝对成立的贪心方法，~~这是经过历史考验的方法~~，包括田忌赛马的原题也是用这种思想A掉的。


#### ·第一步：先用己方的弱者保证赢的情况下尽量磕掉对方最强的, 如果谁都干不过就留下进行平局比较。

#### ·第二步：用己方剩下的当中弱者尽量与对方强者平局。

这种思想的正确性不是很好证明，但经过大量的样例可以看出BUG是不存在的，~~否则我也不可能A这道题~~。

第一步过后：所有有能力获胜的人都已得2分，剩下的只有尽量去平局。

第二步过后：能平局的都平掉了，剩下一些即不能获胜又不能平局的渣渣去给对方那些久经风雨还存活的大佬送死。

举个最简单的例子：1 3对战2 3：

如果让3平局和他一样大的3，1照样会被2吊打。我们让1先留下，3便可以战胜2，然后第二步过后，1会去找3送死，总共得到2分。

#### 这个思想的朴素代码，记录己方已使用的人，对方已使用的人，己方从弱到强枚举，对方从强到弱枚举：


```cpp
由于数据范围到了1e5，朴素枚举T了4个点：
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long 
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int N=101010;
const int qwq=303030;
const int inf=0x3f3f3f3f;
int n,m;
int a[N];
int b[N];
bool used[N];
bool vis[N];
int ans; 

void slove()
{
    int res = 0;
    for(int i=1; i<=n; i++)
    {
        for(int j=n; j>=1; j--)
        {
            if(vis[j]) continue;
            if(a[i] > b[j])
            {
                used[i] = vis[j] = 1;
                res += 2;
                break;
            }
        }
    }
    for(int i=1; i<=n; i++)
    {
        if(used[i]) continue;
        for(int j=n; j>=1; j--)
        {
            if(vis[j]) continue;
            if(a[i]==b[j])
            {
                used[i] = vis[j] = 1;
                res ++;
                break;
            }
        }
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++) scanf("%d",&a[i]);
    for(int i=1; i<=n; i++) scanf("%d",&b[i]);
    sort(a+1,a+n+1);
    sort(b+1,b+n+1);
    slove();
    printf("%d ",ans);
    memset( used,0,sizeof(used) );
    memset( vis, 0,sizeof(vis ) );
    for(int i=1;i<=n;i++) swap( a[i],b[i] );
    slove();
    printf("%d",2*n-ans );
    return 0;
} 
```

#### 我们考虑一下优化：

在大量的枚举循环中，我们就是想找一个比己方实力尽量相等且己方占优势的敌人。

而已经比赛过的敌人会被我们重复寻找，所以我们可以考虑二分答案。

既要二分又要保证答案（即敌人）还存在，我们可以考虑一下STL；~~这是本篇题解的精髓所在~~。

用一个vector数组，即可以二分答案，又可以删除操作。

由于己方每个人最多被找两次，且敌人被删除后二分还会加快，代码整体复杂度为$nlogn$。


对于STL不熟悉的读者，可以更加了解一下这些用法：

#### 思路和上面代码完全相同，具体用法见代码注释:

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long 
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int N=101010;
const int qwq=303030;
const int inf=0x3f3f3f3f;
//冗长的日常码前操作。。。 
int n,ans;
int a[N];
int b[N];        //变量好少啊~~ 

void slove()
{
	ans = 0;
	queue <int> A1;   //最初己方阵容 
	queue <int> A2;   //记录第一步后剩余 
	vector <int> B;   //记录敌方实力，可以进行二分与删除操作
	 
	for(int i=1; i<=n; i++) A1.push( a[i] );
	for(int i=1; i<=n; i++) B.push_back( b[i] );  //进入STL 
	
	while( !A1.empty() )  //第一步 
	{
		int x = A1.front(); A1.pop();
		int wei = lower_bound( B.begin(),B.end(),x ) - B.begin() + 1; //读取己方在敌方的排名 
		if( wei==1 ) A2.push(x);     //敌方没有比可以战胜的，留下来到A2 
		else {
			B.erase( lower_bound( B.begin(),B.end(),x ) - 1 );    //删除最大的比己方小的数 
			ans += 2;
		}
	}
	while( !A2.empty() )  //第二步 
	{
		int x = A2.front(); A2.pop();
		int wei = lower_bound( B.begin(),B.end(),x ) - B.begin() + 1;  //读取排名 
		if( B[wei-1]==x )                                         //如果达成平局 
		{
			B.erase( lower_bound( B.begin(),B.end(),x ) );        //删除与己方平局的那个数 
			ans++;
		}
	}
	return ;
}

int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++) scanf("%d",&a[i]); sort(a+1,a+n+1);
	for(int i=1; i<=n; i++) scanf("%d",&b[i]); sort(b+1,b+n+1);
	slove();
	printf("%d ", ans );
	for(int i=1; i<=n; i++) swap( a[i],b[i] );   //敌方最好情况就是己方最烂情况 
	slove();
	printf("%d", 2*n-ans );       //己方与敌方总得分为2n，减去敌方最好得分便是己方最差得分 
	return 0;
} 

```

#### 代码~~似乎~~有些长，但理解STL的正确用法，做别的题也是受益匪浅的。


---

## 作者：Z__X (赞：5)

#### 其实这道题跟 [P1650 田忌赛马](https://www.luogu.org/problemnew/show/P1650) 差不多，只不过田忌赛马求的是最好情况田忌能拿多少银币，而这道泡泡堂让我们求的是最好情况和最坏情况的分数。

#### 首先肯定是qsort啦，排两遍，把两队的各自从小到大排序——

#### 那么我们可以这样想，求最好情况时：
 - 先用自己队最强的和对方队最强的互怼一下，如果能赢，那么就把分数+2,指针各往后移动一格，进入下一次循环；（比如说下图）
 
![](https://i.loli.net/2019/02/02/5c55580249db5.png)

- 如果怼不过，那就再拿自己队最弱的和对方队最强的怼，能怼赢，同样的，加上分数，指针往前移一格（比如说下图）；

![](https://i.loli.net/2019/02/02/5c555882e64e1.png)

- 若是还怼不过，只能硬刚了，就拿自己队最弱的耗掉对方最强的，移动指针（比如下图）

![](https://i.loli.net/2019/02/02/5c5559584306d.png)

#### 这时候得出的结果就是最好情况了。（如果还有漏洞请各位大佬指出QAQ）

#### 现在，我们还需要求最坏情况的分数，这时，我们可以倒过来想，让敌方赢的次数尽可能的多，这时，我们会发现，这段代码实际上和上一段差不多，只需改变几个策略即可.

### 贴程序啦（QWQ）！
#### （本蒟蒻不才，代码有点长，请大佬勿喷QAQ）
``` pascal
type arr=array[0..100001] of longint;   //为方便的排序做准备
var
  n,i,tjhead,qwhead,tjtail,qwtail,ans:longint;
  tj,qw:array[0..100001] of longint;
procedure qsort(l,r:longint;var a:arr);  //qsort，不多说了
var
  i,j,mid,t:longint;
begin
  i:=l;j:=r;
  mid:=a[(l+r)>>1];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
     begin
       t:=a[i];a[i]:=a[j];a[j]:=t;
       inc(i);dec(j);
     end;
  until i>j;
  if l<j then qsort(l,j,a);
  if i<r then qsort(i,r,a);
end;
begin
  readln(n);
  for i:=1 to n do read(tj[i]);  //tj原等于田忌，这边指我方
  readln;
  for i:=1 to n do read(qw[i]);  //qw原等于齐王，这里指敌方
  qsort(1,n,tj);   //排我方
  qsort(1,n,qw);   //排敌方
  tjhead:=1;qwhead:=1;tjtail:=n;qwtail:=n;  //初始化
  ans:=0;  //清零
  for i:=1 to n do //依次枚举
   begin
     if tj[tjhead]>qw[qwhead] then  //第一种情况，弱怼弱
      begin
        inc(ans,2);
        inc(tjhead);
        inc(qwhead);
        continue;
      end;
     if tj[tjtail]>qw[qwtail] then  //第二种情况，强怼强
      begin
        inc(ans,2);
        dec(tjtail);
        dec(qwtail);
        continue;
      end;
     if tj[tjhead]<qw[qwtail] then  //硬刚，输的情况
      begin
        inc(tjhead);
        dec(qwtail);
      end
       else
     if tj[tjhead]=qw[qwtail] then  //硬刚，平局的情况
      begin
        inc(ans);
        inc(tjhead);
        dec(qwtail);
      end;
   end;
  write(ans,' ');  //输出最好情况的分数
  
----------------------------------------- 华丽的分割线（下面开始求最坏情况的分数）

  tjhead:=1;qwhead:=1;tjtail:=n;qwtail:=n;  //仍然是初始化
  ans:=0;  //清零
  for i:=1 to n do  //依次枚举
   begin
     if tj[tjhead]<qw[qwhead] then  //想让对方输，就得反着来，弱怼弱输掉
      begin
        inc(tjhead);
        inc(qwhead);
        continue;
      end;
     if tj[tjtail]<qw[qwtail] then  //强怼强输掉
      begin
        dec(tjtail);
        dec(qwtail);
        continue;
      end;
     if qw[qwhead]<tj[tjtail] then  //一不小心自己赢了
      begin
        inc(ans,2);
        dec(tjtail);
        inc(qwhead);
      end
       else
     if qw[qwhead]=tj[tjtail] then  //平局
      begin
        inc(ans);
        inc(qwhead);
        dec(tjtail);
      end;
   end;
  write(ans);  //输出最坏情况的结果
end.
```

---

## 作者：Linune_Gump (赞：4)

# 题解P2587
>两人竞技类题很多是田忌赛马

左转[田忌赛马模板题](https://www.luogu.com.cn/problem/P1650)

## 田忌赛马
>采用贪心思想

维护四个指针 $i, j, x, y$,
分别表示田忌还能比赛的最好的马、最差的马以及对手最好最差的马。
为了方便，我们可以对马排序，这样就可以让指针直接滑动

对于那题，我们需要知道的思想是：如果能赢，一定要赢；
实在不行，也不能平。要输也得输的有尊严。去和人家最好的马打。打不过也没关系，谁叫人家是最好的马。但是，你至少浪费了人家的一匹好马

比赛一定会进行 $n$次。因此每次循环肯定要决出胜负  
正常情况下，先让最好的马和对方最好的马打。
如果打得过，那最好；  
如果打不过就让最差的马和对方最差的马打，如果还是打不过，~~说明你的马真的太差了~~，就用你最差的马有尊严的输一场  
反正不能赢（如果能赢不至于在这里赢）。不管如何，都得决出胜负。但是平局就是在这里产生的。
由于那题平局不加分，因此在代码里没有体现。但这题不同。

## 回到本题
很明显，最优策略类似于田忌赛马。  
但是需要注意：
> 这题的平局是有分数的，因此代码上要稍作修改
>
> 输了不扣分，因此与模板有差异

### 最劣策略
>“不怕神一样的对手，就怕猪一样的队友”。

如果想要输，只要猪队友即可。

假设你想要输，你就可以成为对方派来的卧底。千方百计想要对方赢。因此只需要找到对手的最优策略即可。但是需要注意计分规则。
我们更关心平局的情况，实在不行，我们再赢

## 代码
>有注释
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n;
int a[N], b[N];
int i, j, x, y;
long long ans = 0;
bool cmp(int u, int v)
{
	return u > v;
}
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i++) scanf("%d", &b[i]);
	sort(a + 1, a + 1 + n, cmp);
	sort(b + 1, b + 1 + n, cmp);
	i = 1, j = n; x = 1, y = n;
	for(int k = 1; k <= n; k++) // 最优策略
	{
		if(a[i] > b[x]) // 最好的马的对决
		{
			ans += 2;
			i++, x++;
		}
		else if(a[j] > b[y]) // 最差的马的对决
		{
			ans += 2;
			j--, y--;
		}
		else
		{
			if(a[j] >= b[x]) // 无法有尊严的输掉，就平局
				ans += 1;
			j--, x++;
		}
	}
	printf("%lld ", ans);
	i = 1, j = n; x = 1, y = n;
	ans = 0;
	for(int k = 1; k <= n; k++) // 转化视角：你现在是b的人了
	{
		if(b[i] > a[x])
		{
			i++, x++;
		}
		else if(b[j] > a[y])
		{
			j--, y--;
		}
		else
		{
			if(b[j] < a[x]) // 不得不赢再赢
				ans += 2;
			else // 能平就平
				ans += 1;
			j--, x++;
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

~~完结撒花哦~~~

---

## 作者：WBW2333 (赞：2)

### 思路:
  读完题目后很自然的就想到田忌赛马的策略，用我方最蒻的去怼对方最强的，然后裸贪心。但是这一题田忌赛马的策略并不是完全正确，比如下面这组数据：
4
2 3 5 7
1 2 3 4
  按田忌的策略，答案是：5 5，但是仔细一看就能发现，最优答案是：8 4。所以这一题不可以用田忌赛马的策略求解。
  
   我们可以看出，如果我方最蒻的，能怼得过对方最蒻的，那我们就没有必要让其去带走对面最犇的（因为贪心思想就是以小换大，我们优先让蒻的去怼）。
   
   如果我方最蒻的怼不过对面最蒻的或者说是平手，那么，我们就应该让最蒻的去带走对面最强的了。

   但是，如果我们目前最犇的可以怼爆对面最犇的呢?所以，如果我们最犇的可以怼爆对面最犇的，这时就没有必要让最蒻的去送人头。

### 算法：
  将我方和对方的人排序后，逐个进行判断：
  
  如果我方目前剩下的最蒻的能怼掉对面最蒻的，就把双方最蒻的从队伍中去掉，并修改得分。
  
  如果我方目前剩下的最蒻的能和对面最蒻的打平手，此时应该判断：
    如果我方最犇的怼不掉对面最犇的或者能打平手，就让我方最蒻的带走对面最犇的，并将他们从队伍中除去（还要特判我方最蒻的是不是能和对面最犇的打平手）;
    如果我方最犇的能怼掉对面最犇的，就让我方最犇的带走对面最犇的，并将他们从队伍中除去。
    最后修改得分即可。
  
  如果我方最蒻的不能怼掉对面最蒻的，果断让他带走对面最犇的。
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int D[2][100005],n;
int find(int i,int j){
    int l=1,r=n,ans=0,h=1,e=n;
    while(h<=e && l<=r){
        if(D[i][l]>D[j][h])
            ans+=2,h++,l++;
        else if(D[i][l]==D[j][h]){
            if(D[i][r]<=D[j][e]){
                if(D[i][l]==D[j][e]) ans++;
                e--,l++;
            }
            else e--,r--,ans+=2;
        }
        else l++,e--;
    }
    return ans;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&D[0][i]);
    for(int i=1;i<=n;i++)
        scanf("%d",&D[1][i]);
    sort(D[0]+1,D[0]+1+n);
    sort(D[1]+1,D[1]+1+n);
    printf("%d ",find(0,1));
    printf("%d\n",2*n-find(1,0));
    return 0;
}
```

---

## 作者：edr_saverr (赞：1)

# 泡泡堂(田忌赛马)
### 该题目像极了隔壁P1650
链接：[p1650](https://www.luogu.com.cn/problem/P1650)
### 基本思路
**贪心**

田忌赛马的策咯是主要思路（老祖宗的思路还是可以的），但是浙江队也并不一定一直比对方弱，所以不能直接拿最 $ruo$ 的上去送，总得先看看我方最强的是不是比对方最强的强。最 $ruo$ 的同理。

据说有人用dp做，由于本人是蒟蒻，所以不。

AC代码如下（附注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],b[100001];
int n;
int ai,aj;
int bi,bj;
int gold,gold2;//本来是田忌赛马的程序 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	//直接sort()升序排序 
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	ai=1,aj=n,bi=1,bj=n;//指针 
	for(int i=1;i<=n;i++){
		/*
			先比双方最ruo的，若能赢
			则最ruo的打，打完分数+=2 
		*/
		if(a[ai]>b[bi]){ 
			gold+=2;
			ai++;bi++;
		}
		/*
			再比双方最强的，若能赢
			则最强的打，打完分数+=2 
		*/
		else if(a[aj]>b[bj]){
			gold+=2;
			aj--;bj--;
		}
		/*
			若是都比不过，那就拿最 ruo 的
			上去送，送完说不定最强的，最 ruo 的
			 就打得过了 
		*/
		else{
			if(a[ai]>=b[bj])//注意一定是">="，好像有个点"=="过不了 
				gold++;
			ai++;bj--;
		}
	}
	ai=1,aj=n,bi=1,bj=n;//使用b的视角再来一次 (内鬼预定)
	for(int i=1;i<=n;i++){
		if(b[bi]>a[ai]){
			gold2+=2;
			bi++;ai++;
		}
		else if(b[bj]>a[aj]){
			gold2+=2;
			bj--;aj--;
		}
		else{
			if(b[bi]>=a[aj])
				gold2++;
			bi++;aj--;
		}
	}
	printf("%d %d\n",gold,n*2-gold2);
	//双方总共能够得到的分数数量即n*2 
	return 0;//AC 
}
```


---

## 作者：封禁用户 (赞：1)

~~嗯，这题我一天之内交了15次才A掉……~~

这题显然要贪心，我们现在就只需要考虑最好情况（那个最差情况把A和B交换一下就又成了最好情况）。然后一个看上去比较正确的思路就是把二者从小到大排序，然后我们把B看做一个队列，不难看出任意时刻队头都为最小的B，然后扫一遍A，如果A大于等于B的队头就直接计入答案，否则让A去找B的最大的。

不过这题的坑点就是那个比较辣手的平局，我们发现如果当前的A等于B的队头，然后我们直接把答案+1然后把B的队头取走，假如A的后面还有东西而且他不打不过B队头后的，但是他能打过B的队头，那么着对答案的贡献是2，更优，所以我们应该先把战胜的情况处理，然后把剩下的拿出来再做一遍平局和战败的处理。

然后我们把这个代码交上去，发现只有30分，为什么？

~~然后我想了两个小时之后~~想出了这么一组Hack数据：

```cpp
B:100 101

A:100 102
```

我们用上面的方法，就让102打100胜，100打101败，答案为2，但是可以让102打101，100打100，答案为3，战胜抢占了平局的位置，而他还可以再换个位置，所以上面那种方法在这题存在平局的情况下不一定是最优的。

那么为了避免这种情况的发生，我们不让A找B的队头，而是尝试找最大的他能够干掉的B，显然这样不会比上面的方法更差，而且也不会出现这种占了平局的位置的情况。

~~然后这题我觉得用set太麻烦就手写了个Splay然而还是写挂了~~我就用了个权值线段树求前驱（离散化一下就行了）。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
inline int get(){
	int n;char c;while((c=getchar())||1)if(c>='0'&&c<='9')break;
	n=c-'0';while((c=getchar())||1){
		if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
	}
}
map<int,int> mp;
typedef struct _n{
	int left;int right;int data;
}node;node memchi[1000001];int gn=1;
inline void up(int tree){
	int ls=memchi[tree].left,rs=memchi[tree].right;memchi[tree].data=memchi[ls].data+memchi[rs].data;
}
int ref[200001],cnt[200001];
int build(int l,int r){
	int tree=gn;gn++;if(l==r){
		memchi[tree].data=cnt[l];
	}else{
		int mid=(l+r)>>1;memchi[tree].left=build(l,mid);memchi[tree].right=build(mid+1,r);up(tree);
	}return(tree);
}
int getmax(int rl,int rr,int l,int r,int tree){int mid=(l+r)>>1;
	if(memchi[tree].data==0)return(-1);
	if(rl>rr)return(-1);
	if(l==r){return(l);
	}if(rl==l&&rr==r){
		if(memchi[memchi[tree].right].data==0)return(getmax(l,mid,l,mid,memchi[tree].left));
		return(getmax(mid+1,r,mid+1,r,memchi[tree].right));
	}if(rl>mid)return(getmax(rl,rr,mid+1,r,memchi[tree].right));
	if(rr<=mid)return(getmax(rl,rr,l,mid,memchi[tree].left));
	int tmp=getmax(mid+1,rr,mid+1,r,memchi[tree].right);if(tmp!=-1)return(tmp);
	return(getmax(rl,mid,l,mid,memchi[tree].left));
}int pt;
void del(int l,int r,int tree){
	if(l==r){
		memchi[tree].data--;return;
	}int mid=(l+r)>>1;if(pt<=mid)del(l,mid,memchi[tree].left);
	else del(mid+1,r,memchi[tree].right);up(tree);
}
int a[100001],b[100001];int ans1=0,ans2=0;
int main(){
	int n=get();for(register int i=1;i<=n;i++)a[i]=get(),ref[i]=a[i];
	for(register int i=1;i<=n;i++)b[i]=get(),ref[i+n]=b[i];
	sort(ref+1,ref+1+n+n);int newl=unique(ref+1,ref+1+n+n)-ref-1;
	sort(a+1,a+1+n);sort(b+1,b+1+n);
	for(register int i=1;i<=n;i++){
		a[i]=lower_bound(ref+1,ref+1+newl,a[i])-ref;
		b[i]=lower_bound(ref+1,ref+1+newl,b[i])-ref;
		cnt[b[i]]++;
	}int root=build(1,newl);
	for(register int i=1;i<=n;i++){
		int pr=getmax(1,a[i]-1,1,newl,root);if(pr!=-1){
			ans1+=2;pt=pr;del(1,newl,root);cnt[pr]--;
		}else{
			if(!mp.count(a[i]))mp[a[i]]=1;
			else mp[a[i]]++;
		}
	}for(register int i=1;i<=newl;i++){
		for(register int j=1;j<=cnt[i];j++){
			if(mp.count(i)){
				if(mp[i])ans1++,mp[i]--;
			}
		}
	}gn=1;mp.clear();memset(cnt,0,sizeof(cnt));for(register int i=1;i<=n;i++){
		cnt[a[i]]++;
	}root=build(1,newl);for(register int i=1;i<=n;i++){
		int pr=getmax(1,b[i]-1,1,newl,root);if(pr!=-1){
			pt=pr;del(1,newl,root);cnt[pr]--;
		}else{
			if(!mp.count(b[i]))mp[b[i]]=1;
			else mp[b[i]]++;
		}
	}for(register int i=1;i<=newl;i++){
		for(register int j=1;j<=cnt[i];j++){
			if(mp.count(i)){
				if(mp[i]){
					ans2++;mp[i]--;continue;
				}
			}ans2+=2;
		}
	}printf("%d %d\n",ans1,ans2);
	return(0);
}
```

---

## 作者：lwhllw (赞：1)

这题贪心策略 比较重要

算最坏情况只需要2n-对方最好分数

错误的贪心策略：最弱的打最强的，尽量让最强的赢(或平)

反例
1 2 6 7

1 2 4 7

如上贪心策略的结果是 5 3 而正确的答案是6 2

正确的贪心：尽可能让最强的赢，最弱的赢，都不行让最弱打最强。代码如下


```cpp
const maxn=100010;
var i,j,k,l,m,n,ans,a1,a2:longint;
    a:array[1..maxn*2]of longint;
procedure swap(var a,b:longint);
var k:longint;
begin
    k:=a;a:=b;b:=k;
end;
procedure qsort(l,r:longint);
var i,j,k:longint;
begin
    i:=l;j:=r;k:=a[(l+r)div 2];
    repeat
      while a[i]>k do inc(i);
      while a[j]<k do dec(j);
      if i<=j then
      begin
        swap(a[i],a[j]);
        inc(i);
        dec(j);
      end;
    until(i>j);
    if(i<r)then qsort(i,r);
    if(j>l)then qsort(l,j);
end;
procedure init;
begin
    readln(n);
    for i:=1 to n*2 do read(a[i]);
end;
procedure work;
var i,k,l,l1,l2,r1,r2:longint;
begin
    l1:=1;l2:=n+1;r1:=n;r2:=n*2;ans:=0;
    while(l1<=r1)do
      if(a[r1]>a[r2])then
      begin
        dec(r1);
        dec(r2);
        inc(ans,2);
      end
      else
        if(a[l1]>a[l2])then
        begin
          inc(l1);
          inc(l2);
          inc(ans,2);
        end
        else
        begin
          if(a[r1]=a[l2])then inc(ans);
          dec(r1);
          inc(l2);
        end;
end;
begin
    init;
    qsort(1,n);
    qsort(n+1,2*n);
    work;
    a1:=ans;
    for i:=1 to n do swap(a[i],a[i+n]);
    work;
    a2:=ans;
    writeln(a1,' ',2*n-a2);
end.

```

---

## 作者：依依 (赞：0)

这道题就是田忌赛马，策略很简单，  
如果当前最差的能比对方当前最差的强，就让当前最差的与对方最差的比   
（显然当前已经是最差的了，在能战胜对方最差的前提下，肯定是出动己方越差的越好）；   
如果不满足，则比较当前最强的和对方最强的，如果比对方强则直接对比。   
如果都不满足，就考虑用己方最差的直接与对方最强的比，这显然是可行的，   
反正己方对上对方最强的都不能胜利，那么还不如用自己最差的去换掉对方最强的。    
这是最优策略，最坏策略就是以对方为主动，跑一遍最优策略，   
然后用2×n-ans即可得到最差策略。   

[代码](http://www.cnblogs.com/adelalove/p/8576601.html)


---


# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# 题解

## 作者：lwz2002 (赞：56)

（~~~~这题82分卡了我一个多小时~~~~）

初次审题，就知道应该先做b大于0的任务，因为如果先做小于0的话，会使得t减小，这就可能使得一些比较大的ti不能达到（~~~~到这里大家应该能都想到~~~~）

然后问题来了，b大于0的任务做完了，小于0的呢？如果按照b从大到小排序的话，貌似很正确，但你看这组数据：

做完b大于0的任务后，T=10，剩下2组任务：t1=9，b1=-5；t2=4，b2=-2；显然如果先做第二个的话，会使得第一个任务不能完成

我们可以这样想：对于两组任务t1、b1、t2、b2（其中b1、b2全为负）且当时的时间为T，若先做第一个任务会使得不能做第二个任务而先做第二个任务后还能继续完成第一个任务，则会有

T+b1<t2,T+b2>t1;

移项可得

T<t2-b1,T>t1-b2;

根据不等式的传递性可知

t1-b2<T<t2-b1即t1+b1<t2+b2;

所以我们可以看出按照b+t从大到小的顺序排序可使得答案最优

上代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 2147483647

using namespace std;
struct node
{
    int tim;
    int b;
}a[100010];    //b大于0的任务
struct ss
{
    int tim;
    int b;
}f[100010];    //b小于等于0的任务
int n,t,z;
int cmp(node &a,node &b)
{
    return a.tim<b.tim;    //由于b大于0，所以先做t小的任务
}
int comp(ss &a,ss &b)
{
    return a.b+a.tim>b.b+b.tim;    //证明如上
}
int main()
{
    scanf("%d",&z);
    for(int i=1;i<=z;i++)
    {
        int s=0,cnt=0,num=0;
        scanf("%d%d",&n,&t);
        for(int j=1;j<=n;j++)
        {
        	int x,y;
        	scanf("%d%d",&x,&y);
        	if(y>0) a[++cnt].tim=x,a[cnt].b=y;
        	else f[++num].tim=x,f[num].b=y;
		}
        sort(a+1,a+cnt+1,cmp);
        sort(f+1,f+num+1,comp);
        for(int j=1;j<=cnt;j++)
        {
            if(t>a[j].tim) t+=a[j].b;
            else{
                s=1;
                break;
            }
		}
        for(int j=1;j<=num;j++)
        {
            if(t>f[j].tim) t+=f[j].b;
            else{
                s=1;
                break;
            }
            if(t<=0){
                s=1;
                break;
            }
        }
        if(s==0) printf("+1s\n");
        else printf("-1s\n");
    }
    return 0;
}
```



---

## 作者：风中の菜鸡 (赞：8)


思路

贪心。将所有任务分成两个部分，分别为 $b$ 大于 $0$ 和小于 $0$ 的。对于大于 $0$ 的显然有优先完成门槛低的。对于小于 $0$ 的则可按 $t+b$ 排序，从大到小完成。

为什么这样是正确的呢？

我们假设有两个任务，它们的 $a$ 值分别为 $a$ 和 $aa$ ，它们的 $b$ 值分别为   $b$ 和 $bb$，且当前时间为 $T$ 。若完成第一个任务后就不能完成第二个任务了，则有

$$T+b \le aa$$

将 $b$ 移项可得

$$T \le aa-b$$

且完成第二个任务后能完成第一个任务，则有

$$T+bb > a$$

同样的，将 $bb$ 移项可得

$$T > a-bb$$

综合上述两个移项后的不等式，可得

$$a-bb < aa-b$$

移项后有

$$a+b < aa+bb$$
 
当 $b<0$ 由于先完成第二个任务再做第一个任务才能完成所有任务，所以我们只需将 $t+b$ 从大到小排序后按顺序做任务即可。

代码不难实现，这里就不放了。

---

## 作者：长安何处在 (赞：4)

写在前面：这道题其实前面有些题解的式子推得挺清晰的，但是我的思路好像和洛谷现有的一些题有些不一样，但在最后推出的式子上异曲同工，所以写一篇题解，供大家参考。

$Solution$：

$step1$:首先我们来考虑一个这道题一个子问题即限制$0≤b_i≤100,000$

现在我们限制了$b_i$自然数，这个时候显然按照$t_i$排序，若此时能选则$i$则选择$i$物品，若不能选，输出则无解，可以证明此时一定是最优的，证明可以参看其他同类题解，本处不再赘述。

$step2$：解决$-100,000≤b_i≤0$的部分

现在考虑倒着解决这个问题，首先记$\sum_{i=1}^nb_i$为sum，显然在完成所有魔法任务时$T=sum$，所以完成$n-1$个魔法任务时$T$最低为$t_i+b_i$，完成一个任务$T=T-b_i$,所以现在就可以考虑将$b_i$通过倒着遍历，将其转成正数，那么问题就变成了$n$个魔法任务，初始时间$T(new)$为$sum$
一个每个任务时间$b_i(new)$为$-b_i$($b_i$变成了正数)，$t_i(new)$变成了$t_i-b_i(new)$,那么这个问题就可以转化成$step1$的问题了，解决思路同上。

$step1$和$step2$分开解决即可

完结撒花

附上代码

```
//coded by 长安何处在2019于CJ
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#include<map>
#include<set>

using namespace std;

typedef long long ll;
typedef long double ld;
#define re register
#define il inline

const int N=100010;
int T,n,t,flag=1,cnt1,cnt2;
struct yy
{
	int ti,b;
}z[N],y[N];

inline bool cmp(yy A,yy B){return A.ti<B.ti;}
inline bool cmp1(yy A,yy B){return A.ti+A.b<B.ti+B.b;}//step2转化出的式子

inline int read()
{
  int a=0,b=1;char c;c=getchar();
  while(c<'0'||c>'9'){if(c=='-')b=-1;c=getchar();}
  while(c>='0'&&c<='9'){a=(a<<3)+(a<<1)+(c^48);c=getchar();}
  return a*b;
}

int main()
{
	T=read();//多组数据
	while(T)
	{
		T--;flag=1;cnt1=0,cnt2=0;
		n=read(),t=read();
		for(re int i=1;i<=n;i++)
		{
			int o=read(),p=read();
			if(p>=0)z[++cnt1].ti=o,z[cnt1].b=p;
			else y[++cnt2].ti=o,y[cnt2].b=p;
		}
		sort(z+1,z+cnt1+1,cmp);
		sort(y+1,y+cnt2+1,cmp1);
		for(re int i=1;i<=cnt1;i++)
		{
			if(t<=z[i].ti){flag=0;break;}
			t+=z[i].b;
		}//step1
		for(re int i=1;i<=cnt2;i++)t+=y[i].b;
		if(t<=0)flag=0;//注意t>0;
		for(re int i=1;i<=cnt2;i++)
		{
			if(t<=y[i].ti+y[i].b){flag=0;break;}
			t-=y[i].b;
		}//step2
		if(flag)printf("+1s\n");
		else printf("-1s\n");
	}
    return 0;
}
```


---

## 作者：哔哩哔哩 (赞：4)

## 【贪心证明】

最上面那个大神的证明方法可能有点麻烦了。我可以讲得简单一点。

最先想到的是按照$b_i$的大小排序,但是是不可行的。

我们可以把$b_i + t_i$ 理解成 **要使用这个魔法至少需要的$T$的值**（这个理解很重要）

所以只需要将至少需要的T的值排序就好，优先考虑最少需要的T值大的

## 【代码】
```cpp
inline bool cmp(data x, data y)
{
	return x.t + x.b > y.t + y.b;
}
```
其他的注意细节即可（比如$t <= t_i$以及$t <= 0$时退出循环）

---

## 作者：ACTREE (赞：3)

这道题主要是要你完成 $n$ 个任务，完成输出 $1$，不然输出 $-1$。
因为两个数组的数据并不会排序完了捆在一起，而是会分开，而结构体并不会出现这种问题。

重要：排序方法,常用的快排是不行的，所以重点就在排序方法上。

因为每个任务的 $t_i$ 要严格大于 $T$,那么快排的排序方法就出现了问题

那么我们来想一想 我们把 $t_i$ 和 $b_i$ 加起来，把任务大的排在前面，这样会加快程序速度。

然后判断 $t_i$ 是否大于 $T$ 并且 $T$ 加上 $b_i$ 要大于 $0$ 的话,$T$ 就加上 $b_i$,一旦一个条件不行，就结束运算。

这就是理解思路，代码就你自己写吧，联系一下自己的代码能力。


---

## 作者：DоsLikе (赞：2)

# P3619 魔法

**题目描述&样例输入/输出:[这里](https://www.luogu.com.cn/problem/P3619)**

本题很显然是一个贪心，但是，如果不仔细思考会出现一些问题。

直觉上来讲，本题的贪心策略应当是优先选择 $b_i$ 比较大的任务。

因为 $b_i$ 如果比较大，那么 $T+b_i$ 就会更大，这样的话就能完成更多的任务。

真的是这样吗？？

[并不是](https://www.luogu.com.cn/record/44318518)（按照此思路去做会WA掉全部的点)

具体的hack数据其他的题解都有，这里不再做赘述。

那么我们贪心策略应当怎样修改呢？

从整体上来看，应当优先完成bi>0的任务，因为如果优先完成bi<0的任务，总时间T就会越来越小，很可能不足以完成其他任务。

我们需要意识到，对于每一个bi>0的任务，应当是ti越小优先度越高。因为ti越小所需的总时间T就会越小，这样的话就可以做尽可能多的任务（因为T在这种情况下总是在增加）

我们假设有两个任务，完成第一个任务后无法完成第二个任务，但完成第二个任务却可以继续完成第一个任务。

我们这样表达:

$T+b_1<t_2$ 且 $T+b_2>t_1$

移项可得:

$T<t_2-b_1$ 及 $T>t_1-b_2$

联立并化简，得:

$t_1-b_2<T<t_2-b_1$

最后移项并化简，得

$t_1+b_1<t_2+b_2$

我们可以发现，按照上式进行排序便可以保证在 $b_i<0$ 时满足最优解

贪心部分的证明很多题解已经有了，不过似乎题解没有一个用优先队列实现的？？

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cmath>
using namespace std;
int z;
int n,t;//与题面一致
bool isJ=false;
priority_queue < pair<int,int> > on;//此队列存储bi>0的任务
priority_queue < pair<int,int> > under;//此队列存储bi<0的任务
int main(){
    scanf("%d",&z);
    while(z--){
        scanf("%d %d",&n,&t);
        for(int i=1;i<=n;i++){
                int bi,ti;
                scanf("%d %d",&ti,&bi);
                if(bi>=0)on.push(make_pair(-ti,bi));//将ti取相反数，便可以将ti升序排列
                else under.push(make_pair(bi+ti,ti));//当bi+ti较大时优先选择该任务
        }
        isJ=false;//是否符合要求的标记
        while(!on.empty()){
            int bi=on.top().second;
            int ti=-on.top().first;
            on.pop();
            if(t<=ti){//如果在最优的情况下仍无法完成任务，则本组数据无法完成
                isJ=true;//标记并退出
                break;
            }
            t+=bi;//依据题意对t进行修改
        }
        if(!isJ){
            while(!under.empty()){
                int ti=under.top().second;
                int bi=under.top().first-ti;//因为此优先队列第一维存储的是bi+ti，所以bi就等于bi+ti-ti
                under.pop();
                if(t<=ti){
                    isJ=true;
                    break;
                }
                t+=bi;
                if(t<=0){
                    isJ=true;
                    break;
                }//依据题意进行判断，如果在最优情况下无法完成，则标记并退出
            }
            
        }
        if(isJ)cout<<"-1s"<<endl;
        else cout<<"+1s"<<endl;//根据是否能顺利完成的标记进行输出
        while(!on.empty())on.pop();
        while(!under.empty())under.pop();//一定要清空队列，否则只有73分
    }
    return 0;
}

```



---

## 作者：Digital_Sunrise (赞：2)

[link](https://www.luogu.com.cn/problem/P3619)

## 前言

顺着一位大佬的题解摸过来的，因为错的实在离谱，所以写一篇题解。

## 思路

很容易想到优先选择获得时间为正数的魔法。

由限制从小到大排序并选择，选择时保证一直为最优方案。

所以一旦 $T$ 此时不满足要求就直接输出 `-1s` 跳入下一次循环。

如果获得时间为负。

设有两个魔法编号为 $i,j$ 此时时间为 $T'$ 。

若 $i$ **必须**在 $j$ 之前先取到，

那么必须满足先取 $i$ 就能取到 $j$ ，先取 $j$ 却不等取到 $i$ 。

推一下不等式就可以知道是由 $t_i+b_i$ 由大到小排序后选择。

相似的，如果在选择中 $T$ 此时不满足要求就直接输出 `-1s` 跳入下一次循环。

## 代码

不知道为什么我在写此题的时候写的都是

```cpp
T=T-b[i]+t[i];
```

着实离谱。

因为要避规，所以请把代码中所有的 `+#1s` 的 `#` 删掉

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 1e5 + 5;

inline int read()
{
    int w = 1,f = 0;
    char c = getchar();
    while(c < '0' or c > '9')
    {
        if(c == '-') w = -1;
        c = getchar();
    }
    while(c >= '0' and c <= '9')
    {
        f = f * 10 + c - '0';
        c = getchar();
    }
    return w * f;
}

int Z,cnt1,cnt2;
struct node
{
    int k;
    int t;
}a[_],b[_];

bool cmp1(node u,node v)
{
    return u.k < v.k;
}

bool cmp2(node u,node v)
{
    return u.k + u.t > v.k + v.t;
}

int main()
{
    Z = read();
    while(Z--)
    {
        int n,T ;
        cnt1 = cnt2 = 0;
        n = read();
        T = read();
        for(int i = 1;i <= n;i++)
        {
            int k = read(),t = read();
            if(t >= 0)
                a[++cnt1].k = k,a[cnt1].t = t;
            else   
                b[++cnt2].k = k,b[cnt2].t = t;
        }
        sort(a + 1,a + cnt1 + 1,cmp1);
        sort(b + 1,b + cnt2 + 1,cmp2);
        for(int i = 1;i <= cnt1;i++)
        {
            if(T <= a[i].k)
            {
                cout << "-1s\n";
                goto Next;
            }
            // T -= a[i].k;
            T += a[i].t;
            if(T <= 0)
            {
                cout << "-1s\n";
                goto Next;
            }
        }
        for(int i = 1;i <= cnt2;i++)
        {
            if(T <= b[i].k)
            {
                cout << "-1s\n";
                goto Next;
            }
            // T -= b[i].k;
            T += b[i].t;
            if(T <= 0)
            {
                cout << "-1s\n";
                goto Next;
            }
        }
        cout << "+#1s\n";
        Next:;
    }
    return 0;
}
```

---

## 作者：紊莫 (赞：1)

主要讲解一下思路和证明的过程。

## 贪心的思路和证明

因为题中需要**所有任务全部达成**才能算成功，所以需要构造一种策略来完成任务。

首先，将所有的 $b$ 分为 $2$ 组，按照正负性分类。

此时需要优先完成 $b>0$ 的一组，对于这一组，贪心策略显然，按照时间升序排列，如果当前任务不能完成（$T$ 的值不够），则更完不成后面 $t$ 更大的任务，所以失败。

然后分析 $b\le 0$ 的那一组，这里需要用临项交换的方法证明一下贪心策略。

我们设临项的两个魔法分别为 $b_1,t_1$ 和 $b_2,t_2$，$T$ 为当前时间。
为了完成所有任务，我们希望的是完成前一个任务后**不能**完成后一个任务，而完成后一个后**能**完成前一个任务，这样才需要交换。

则需要同时满足 $T+b_1 \le t_2$ 和 $T+b_2>t_1$。

化简得 $T \le t_2-b_1$ 和 $T>t_1-b_2$。

则有 $t_1-b_2>t_2-b_1$。

再次化简得 $t_1+b_1>t_2+b_2$。

至此，贪心策略即按照 $t+b$ 降序排列，判断情况和第一组同理。

---

## 作者：亦笙箫 (赞：1)

第一眼看到这个题就应该想到先做$b_i\ge0$的任务.

所以我们就可以把题目给的数据分为两部分

1. $b_i\ge0$的任务按$t_i$从小到大排列
2. $b_i<0$的任务另外排序.

那么我们现在的问题就是如何排列$b_i<0$的数据了.

我们可以列出$b_i<0$时的不等式,由此来推导出剩下那部分数据的排列方法是按照$b_i+t_i$从大到小排列的.

然后就可以得到代码:

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<vector>

using namespace std;

const int MAXX = 100000;

struct F{
	int a,b;

	F(){}
	F(int A,int B)
	{
		a=A;b=B;
	}

	bool operator < (const F t)const
	{
		return a<t.a;
	}
};

struct S{
	int a,b;

	S(){}
	S(int A,int B)
	{
		a=A;b=B;
	}

	bool operator < (const S t) const
	{
		return a+b>t.a+t.b;
	}
};

int T;

int n,time_;

vector<F> first;
vector<S> second;

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		first.clear();
		second.clear();
		scanf("%d %d",&n,&time_);
		for(int i=1;i<=n;i++)
		{
			int u,v;
			scanf("%d %d",&u,&v);
			if(v>0)
				first.push_back(F(u,v));
			else
				second.push_back(S(u,v));
		}
		sort(first.begin(),first.end());
		sort(second.begin(),second.end());
		bool flag=true;
		for(int i=0;i<(int)first.size()&&flag;i++)
		{
			if(time_>first[i].a) time_+=first[i].b;
			else flag=false;
		}
		for(int i=0;i<(int)second.size()&&flag;i++)
		{
			if(time_>second[i].a) time_+=second[i].b;
			else flag=false;
			if(time_<=0) flag=false;
		}
		if(flag) puts("+1s");
		else puts("-1s");
	}
	return 0;
}
```


---


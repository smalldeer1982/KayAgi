# 小 C 与桌游

## 题目背景

小 C 是一个热爱桌游的高中生，现在他被一个桌游难住了，快来帮帮他！

## 题目描述

这个桌游的地图可以被抽象成一个 $n$ 个点，$m$ 条边的**有向无环图**（**不保证连通**），小 C 在这个地图上行走，小 C 能走到某个点当且仅当能够到达这个点的所有点都已经被小 C 走到。小 C 会走到每个点恰好 $1$ 次，并且他能走到哪些点与他当前所在的点没有关系（即可以走到与当前所在的点没有连边的点，只要满足之前的条件）。

小 C 每走到一个标号比之前走到的点都大的点，他就会有 $\frac{1}{2}$ 的概率从对手那里拿到 $1$ 块筹码，有 $\frac{1}{2}$ 的概率给对手 $1$ 块筹码，双方初始各有 $1919810$ 个筹码。

小 C 的运气时好时坏，所以他希望你帮他计算出：

- 在最优情况下，即他每次都能从对手那里拿到筹码时，他采取最优的行走方式能得到的筹码数。
- 在最劣情况下，即对手每次都能从他那里拿到筹码时，他采取最优的行走方式会失去的筹码数。



## 说明/提示

**样例解释**

最优情况下的行走方式是 $1-2-3$，最劣情况下的行走方式是 $1-3-2$。

**计分方式**

对于每一个测试点：

- 如果你输出格式错误或者两行都不正确，将会得到 $0$ 分。
- 如果你的输出第一行正确，第二行错误或第二行正确，第一行错误，将会得到这个测试点 $40 \%$ 的分数。
- 否则，你将会得到这个测试点 $100 \%$ 的分数。

**数据范围**

对于 $20\%$ 的数据，$1 \le n, m \le 10$。

对于 $40\%$ 的数据，$1 \le n, m \le 2000$。

对于 $100\%$ 的数据，$1 \le n, m \le 5 \times 10^5$，$1 \le u, v \le n$。


## 样例 #1

### 输入

```
3 2
1 2
1 3```

### 输出

```
3
2```

# 题解

## 作者：Mubuky (赞：48)

首先，**这道题显然和拓扑排序有关**

知道了这一点，问题其实就解决了大半。

其次，读题后发现，题目要求求出 **“最优情况”** 和 **“最劣情况”** 两个答案

我们不妨在求解时将这两个问题分开。

**对于“最优情况”**，我们显然可以贪心的取**编号最小的入度为$0$的点**扩展。实现方式就是把拓扑排序的$queue$换成$priority\_queue(greater)$并维护一个变量$max$。按照题目中所描述的计分规则，我们已经获得了$40$分。

下面我主要讲“最劣情况”的求解。

对于“最劣情况”，能否再按照同上面方式的贪心(即把拓扑排序的$queue$替换为$priority\_queue(less)$)，答案是否定的，容易举出一组反例:

![](https://cdn.luogu.com.cn/upload/image_hosting/dxvvbgde.png)

若按照先前的贪心，我们可以得到这样的一个扩展序列:

```cpp
2 -> 3 -> 1 -> 4
ans = 3;
```

但存在这样一条扩展序列:

```cpp
2 -> 1 -> 4 -> 3
ans = 2;
```

显然更优，这种解法出了问题，实际上这种解法加上“最优情况”的正解可以得到$46$分(实现方式差异可能会出现$52$分)。

那么如何求解呢？

我们看上面的反例，首先同拓扑排序找到入度为$0$的点(2)，此时max(之前走到的点的最大编号)为$0$且小于(2)，所以更新$max = 2$，更新答案$ans$++。

接下来待扩展的节点有2个，(1)和(3)，我们发现扩展(1)时答案($ans$)并不会增加，所以不妨先扩展(1)节点。

现在待扩展的节点是(4)和(3)，他们都大于max，都不能在答案不更新的前提下拓展。接下来不妨贪心的想，先拓展(4)再拓展(3)，即取编号最大的点先扩展。

```cpp
#include<queue>
#include<cstdio>
#include<vector>
using namespace std;
int in2[500001];//入度
vector<int>g[500001];//存图
priority_queue<int,vector<int>,less<int> >qless;
queue<int>kz;//kz(queue)待扩展序列
int main()
{
	int maxn=0,ans=0;
	while(!qless.empty()){
		int x=qless.top();
		if(x>maxn){
			ans++;
		}
		while(!qless.empty()){
			kz.push(qless.top());
			qless.pop();
		}
		while(!kz.empty()){
			int nx=kz.front();
			kz.pop();
			maxn=max(maxn,nx);
			for(int j=0;j<g[nx].size();j++){
				int y=g[nx][j];
				in2[y]--;
				if(in2[y]==0){
					if(y>maxn){
						qless.push(y);
					}else{
						kz.push(y);
					}
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

完整代码:

```cpp
#include<queue>
#include<cstdio>
#include<vector>
using namespace std;
queue<int>kz;
priority_queue<int,vector<int>,greater<int> >qgreater;
priority_queue<int,vector<int>,less<int> >qless;
vector<int>g[500001];
int in[500001],in2[500001];
int main()
{
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d %d",&u,&v);
		g[u].push_back(v);
		in[v]++;
		in2[v]++;
	}
	for(int i=1;i<=n;i++){
		if(in[i]==0){
			qgreater.push(i);
			qless.push(i);
		}
	}
	//"最优情况" 
	int maxn=0,ans=0;
	while(!qgreater.empty()){
		int x=qgreater.top();
		qgreater.pop();
		if(x>maxn){
			ans++;
		}
		maxn=max(maxn,x);
		for(int j=0;j<g[x].size();j++){
			int y=g[x][j];
			in[y]--;
			if(in[y]==0){
				qgreater.push(y);
			}
		}
	}
	printf("%d\n",ans);
	//"最劣情况" 
	maxn=0,ans=0;
	while(!qless.empty()){
		int x=qless.top();
		if(x>maxn){
			ans++;
		}
		while(!qless.empty()){
			kz.push(qless.top());
			qless.pop();
		}
		while(!kz.empty()){
			int nx=kz.front();
			kz.pop();
			maxn=max(maxn,nx);
			for(int j=0;j<g[nx].size();j++){
				int y=g[nx][j];
				in2[y]--;
				if(in2[y]==0){
					if(y>maxn){
						qless.push(y);
					}else{
						kz.push(y);
					}
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

 _**Update:感谢 @AxDea 和 @光明神 指出该篇题解样图分析中有关ans变量的问题**_ 

---

## 作者：Sweetlemon (赞：21)

#### LGR-062, C, 小 C 与桌游

这是一道有意思的题目。

题意简述：求 DAG 的一个拓扑序，使得拓扑序列的前缀最大值的变化次数尽可能多 / 少。

首先看**尽可能多**的情况。考虑贪心，把拓扑排序的队列改为优先队列，每次都取当前入度为零（称之为“可访问”）的点中最小的一个进行访问。可以用调整的方法证明这个贪心策略的最优性——如果这一步不访问最小的那一个点 $u$，而是访问另一个点 $v$，那么把访问 $u$ 的位置提到访问 $v$ 以前，这个拓扑序仍合法，并且答案会变大。

那么**尽可能少**的情况呢？我们是不是也可以用类似的贪心，每次都取当前可访问点中最大的一个进行访问呢？

考虑这个例子：

![简单贪心反例](https://cdn.luogu.com.cn/upload/image_hosting/cyph3wmo.png)

如果每次取可访问点中最大的一个来访问，那么自然会依次选中 $1,3,5,4,2,6$，总代价是 $4$；但是如果选择拓扑序 $1,2,6,3,5,4$，总代价则只有 $3$。也就是说，大的点可能会被掩盖在小的点后面，使得我们的贪心不正确！

或者可以从贪心证明的角度来思考。尽可能多的情况下，访问了较小的不会影响访问较大者的贡献；但在尽可能少的情况下，访问较大者会影响访问较小者的贡献；因此，这两个存在本质的不同，不能直接生搬硬套。

怎么办呢？如果贪心不行，我们不妨考虑 dp？

设 $f[i]$ 表示访问到的最大的点是 $i$ 时的最小代价，那么 $f[0]=0$，答案就是 $f[n]$。这个状态其实是有冗余的——比如上图中 $f[4]$ 就没有意义，任何时刻访问到的最大的点都不可能是 $4$。不过这个状态对于表示问题的当前情况来说也算是足够了，就姑且这么使用吧。

设 $\mathrm{pre}[i]$ 表示 $i$ 的所有前置点 $j$（即存在路径 $j\rightarrow i$ 的点 $j$）的最大标号，例如上图中 $\mathrm{pre}[1]=0,\mathrm{pre}[6]=2,\mathrm{pre}[4]=5$。不难发现，$f$ 数组仅对于 $\mathrm{pre}[i]<i$ 的点有意义，我们把这些点称为“关键点”；并且对于任意点 $i$，$\mathrm{pre}[i]$ 都是关键点。$\mathrm{pre}$ 数组可以通过 DAG 上 dp 简单地求出。

考虑所有关键点 $i$，$f[i]=f[\mathrm{pre}[i]]+1$

……吗？

再考虑这个例子。

![转移方程反例](https://cdn.luogu.com.cn/upload/image_hosting/scizi86l.png)

如果 $f[i]=f[\mathrm{pre}[i]]+1$，那么 $f[1]=1,f[2]=2,f[3]=3,f[4]=4,f[5]=2,f[6]=5$。

但是事实上，访问到 $6$ 的最小代价实际上是 $3$——访问顺序可以是 $1,5,2,3,4,6$！

访问点 $i$ 的条件是 $i$ 的前置点都已经被访问，那么只要“当前已经访问的点的最大值”**不小于** $\mathrm{pre}[i]$，我们就已经可以把 $i$ 的前置点访问完毕了！可以这么理解：假如我们已经买好了 $k$ 级票，买好后可以免费访问 $k$ 级及以下的点，那么只要 $k\ge \mathrm{pre}[i]$，$i$ 的前置点就都在可免费访问的范围内。

因此，事实上 $f[i]=\min(f[k])+1,\mathrm{pre}[i]\le k<i$。这里我们严格按照定义，对于 $k>i$ 的情况不在 $f[i]$ 处考虑而是在 $f[k]$ 处考虑。

这个 dp 怎么算呢？

我会动态区间最小值！不就是棵线段树嘛！或者也可以用树状数组，代码好写，常数较小，但是多一个 $\log$。树状数组方面的实现可以详见[Chanis 的日报](https://www.luogu.org/blog/Chanis/super-BIT)。

那么有没有别的做法呢？

看这个转移方程，似乎有一点“单调”的意思。  

我们要求的东西是一个“后缀最小值”，因此“标号大、代价小”的状态会覆盖“标号小、代价大”的状态，我们的数组应该是单调递增的。

查找时在数组中寻找标号不小于 $\mathrm{pre}[i]$ 的第一个元素，就是我们寻找的最小代价，加上 1 就是 $f[i]$ 的值。

插入时，如果数组中存在着“标号比 $i$ 小、代价还比 $f[i]$ 大”的元素，就会被 $f[i]$ 覆盖，从而可以把被覆盖的状态删除。这些状态分布在 $f[1...i]$ 的后半部分，因此从 $f[i]$ 往前找，一直找到不能删就停下。

数组中删除元素？当然不行！

根据斜率优化的经验，这里我们使用一个 set 来维护，不断 `lower_bound` 和 `erase` 即可。于是这题就解决了。

----

可是！真的不能贪心吗？

我们换个思路。仍然使用“买 $k$ 级票”的情景，即必须按照拓扑序访问节点，访问节点时要先买票；买一次票的代价是 $1$，买 $k$ 级票可以访问所有标号不大于 $k$ 的节点；买票时只能买当前可以访问的节点，即当前入度为 0 的节点。

算法刚开始时，我们只买了 $0$ 级票（也就是还没有买票），什么节点都不能访问。这时候当然必须买票了，不交钱不行啊！于是我们只能交些车船费（花费 $1$ 的代价），买一张票。

买票的时候你看到了这几张票：J 级票，$1$ 元；S 级票，$1$ 元；N 级票，$1$ 元；I 级票，$1$ 元。假如这四张票都能买，那么你选择买哪一张呢？当然是最高级的 I 级票啦，毕竟车船费都是一样的，肯定要买适用范围最广的 I 级啦。

这就是我们的贪心策略——在必须买票的时候，买可以买的最高级的票。

翻译成原题语言，就是当 目前所有可访问的节点标号 都大于 访问过的节点的最大标号，也就是必须要花费 $1$ 的代价时，访问 可访问点 中 标号最大 的那一个。

等一下！这和原来的贪心策略有什么区别？当然是在前提条件上啦。

原来的策略是，**在访问一个新的点时**，选择可访问的标号最大的点。

现在的策略是，**在必须花费代价才能访问新的点时**，选择可访问的标号最大的点。

现在的策略的好处就是“物尽其用”，利用原来消耗过的代价，尽可能地访问更多的点，争取暴露出“更高级的票”，也就是尽量地把标号大的点加入到可访问点的集合中。这样就解决了原来贪心策略中“大的点被小的点掩盖”的问题。

于是我们的算法就是：

1. （此时必须买票）选择可访问的点中标号最大的进行访问，代价加 1
2. （此时利用刚买的票）访问可访问点中所有标号小于“最大标号”的点
3. 重复上述两个步骤，直到所有的点都被访问

我们用什么来维护“可访问点”的集合呢？要支持取最大值，取所有“不超过 $x$”的数值……

既然是集合，那就用 `set` 吧。取最值用 `rbegin`，取“不超过 $x$ 的数值”用 `lower_bound`。

当然，还可以用两个堆。我们把可访问点同时加入最大堆和最小堆中，第 1 步时取最大堆堆顶，第 2 步不断从最小堆堆顶取元素，直到堆顶的标号大于“最大标号”。注意，需要用标记数组防止重复访问同一个点。这道题的查询是一个“两端”型的，也就是要从值域的两端取东西，那么两个堆拼起来不就像一个两端开口的容器吗？正符合我们的要求。

于是这题终于完美解决了。这道题启示我们，贪心和动态规划常常相互配合，动态规划能处理贪心难以解决的问题，贪心能优化动态规划的状态设计，降低时间复杂度。当然，我们也要考虑从贪心和动态规划本身进行优化，尤其是优化贪心策略、优化状态表示和状态转移。

其实，尽可能多的情况也可以用 dp 解决（这个 dp 应该是比“尽可能少的情况”简单的），也不妨思考一下。

下面附各种做法（贪心、树状数组优化 dp、set 单调优化 dp）的代码。

速度的话，可能我的常数比较大，测试结果是 (所有测试点时间之和) 贪心 1.33s, set 1.92s, 树状数组 941 ms（均无 -O2，加 -O2 后差异不大）。可以看到，虽然树状数组的复杂度多一个 $\log$，但是由于这个 $\log$ 是最坏情况，并不常能取到；且常数较小，因此实际速度还是较快的。而 set 天生比较慢；至于我的贪心为什么这么慢……还是人傻常数大吧？

##### 贪心

```cpp
#include <cstdio>
#include <cctype>
#include <functional>
#include <algorithm>
#include <queue>
#define MAXIOLG 25
#define MAXN 500005
#define MAXM 1000005
#define INf 114514
#define INF 1919810

using namespace std;

typedef long long ll;
typedef long double ld;
typedef ll io_t;

io_t shin[MAXIOLG];
io_t seto(void); //快读
void ayano(io_t x,char spliter='\n'); //快写

priority_queue<int,vector<int>,greater<int> > q; //小根堆
priority_queue<int,vector<int>,less<int> > q2; //大根堆

int fst[MAXN],nxt[MAXM],edges=0; //存图
int g[MAXM];
int ind[MAXN],visited[MAXN]; //入度, 访问标记

void addedge(int u,int v); //加边

int main(void){
    int n,m;
    n=seto(),m=seto();
    while (m--){
        int u,v;
        u=seto(),v=seto();
        addedge(u,v),ind[v]++;
    }
    
    int ans1=0,ans2=0;
    //先计算尽可能大情况的答案 ans1
    for (int i=1;i<=n;i++)
        (!ind[i])?(q.push(i)):(void());
    int tx=0; //当前访问过的最大的节点
    while (!q.empty()){
        int nowv=q.top(); //要访问的节点
        q.pop();
        if (nowv>tx)
            tx=nowv,ans1++; //更新答案
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            ind[v]--;
            (!ind[v])?(q.push(v)):(void());
        }
    }
    ayano(ans1); //输出第一个答案
    //再计算尽可能小情况的答案 ans2
    for (int i=1;i<=n;i++)
        for (int ei=fst[i];ei;ei=nxt[ei])
            ind[g[ei]]++; //重新统计入度
    for (int i=1;i<=n;i++)
        (!ind[i])?(q.push(i),q2.push(i)):(void()),
        visited[i]=0; //注意要同时插入到两个堆里
    tx=0;
    while (!q2.empty()){
        //取大根堆堆顶, 买票
        int nowv=q2.top();
        q2.pop();
        if (visited[nowv])
            continue;
        visited[nowv]=1;
        (nowv>tx)?(ans2++,tx=nowv):(0);
        //访问这个节点
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            ind[v]--;
            (!ind[v])?(q.push(v),q2.push(v)):(void());
        }
        while ((!q.empty()) && (nowv=q.top())<=tx){
            //取小根堆堆顶进行访问, 充分利用票
            q.pop();
            if (visited[nowv])
                continue;
            visited[nowv]=1;
            for (int ei=fst[nowv];ei;ei=nxt[ei]){
                int v=g[ei];
                ind[v]--;
                (!ind[v])?(q.push(v),q2.push(v)):(void());
            }
        }
    }
    ayano(ans2); //输出第二个答案
    return 0;
}

void addedge(int u,int v){
    edges++;
    g[edges]=v;
    nxt[edges]=fst[u],fst[u]=edges;
}

io_t seto(void){
    io_t x=0;
    char ch=getchar();
    int symbol=0;
    while (!isdigit(ch))
        (ch=='-')?(symbol=1):(0),ch=getchar();
    while (isdigit(ch))
        x=(x*10)+(ch-'0'),ch=getchar();
    return (symbol)?(-x):(x);
}
void ayano(io_t x,char spliter){
    if (!x){
        putchar('0'),putchar(spliter);
        return;
    }
    if (x<0)
        putchar('-'),x=-x;
    int len=0;
    while (x){
        io_t d=x/10;
        shin[len++]=x-d*10;
        x=d;
    }
    while (len--)
        putchar(shin[len]+'0');
    putchar(spliter);
}
```

##### 树状数组求区间最值的 dp
```cpp
#include <cstdio>
#include <cctype>
#include <functional>
#include <algorithm>
#include <queue>
#define MAXIOLG 25
#define LOWBIT(x) ((x)&(-(x)))
#define MAXN 500005
#define MAXM 1000005
#define INf 114514
#define INF 1919810
using namespace std;

typedef long long ll;
typedef long double ld;
typedef ll io_t;

io_t shin[MAXIOLG];
io_t seto(void);
void ayano(io_t x,char spliter='\n');

priority_queue<int,vector<int>,greater<int> > q;

int n;
int fst[MAXN],nxt[MAXM],edges=0;
int g[MAXM];
int ind[MAXN];
int pre[MAXN]; //上文所述的 pre 数组
int f[MAXN]; //上文所述的动态规划 f 数组
int ftarr[MAXN]; //用于存储 f 最小值的树状数组

int query(int l,int r); //树状数组查询区间最小值, O(log n log n)
void update(int x,int v); //简化版的树状数组更新区间最小值
void addedge(int u,int v); //加边

int main(void){
    int m;
    n=seto(),m=seto();
    while (m--){
        int u,v;
        u=seto(),v=seto();
        addedge(u,v),ind[v]++;
    }
    for (int i=1;i<=n;i++)
        (!ind[i])?(q.push(i),pre[i]=0):(0),
        f[i]=ftarr[i]=INF; //初始化, f 和树状数组都初始化为 INF
    int ans1=0; //第一行输出的答案
    int tx=0; //当前访问的最大节点(在计算第一个答案时用)
    //由于 dp 可以按照任意拓扑序计算
    //因此本程序中两个答案的计算同时进行
    while (!q.empty()){
        int nowv=q.top();
        q.pop();
        //下面一部分用于 dp
        if (nowv>pre[nowv]){
            //关键点
            f[nowv]=query(pre[nowv],nowv-1)+1; //查询区间最值, 加1
            update(nowv,f[nowv]); //插入到树状数组中进行更新
        }
        int tpre=max(pre[nowv],nowv);
        //下面一部分用于贪心
        if (nowv>tx)
            tx=nowv,ans1++;
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            pre[v]=max(pre[v],tpre); //在访问的同时更新 pre
            ind[v]--;
            (!ind[v])?(q.push(v)):(void());
        }
    }
    //输出两个答案
    ayano(ans1);
    ayano(f[n]);
    return 0;
}

int query(int l,int r){
    //查询区间 [l,r] 的最小值
    if (!l)
        return 0; //注意树状数组遇到下标 0 会出事, 所以提前处理; f[0]=0
    int ans=INF;
    while (r>=l){
        int t=r^LOWBIT(r); //相当于 t=r-LOWBIT(r)
        if (t>=l)
            ans=min(ans,ftarr[r]),r=t;
        else
            ans=min(ans,f[r]),r--;
    }
    return ans;
}

void update(int x,int v){
    //注意,这是简化版的更新函数
    //由于本题中树状数组中的值只会变小不会变大
    //所以可以像求和一样进行更新, 更新复杂度 O(log n)
    //但是一般的 值有可能变大的问题不能这么写
    //必须对所有有影响的点重新计算最值, 更新复杂度 O(log n log n)
    while (x<=n)
        ftarr[x]=min(ftarr[x],v),
        x+=LOWBIT(x);
}
//以下略去了 addedge, seto, ayano 三个函数的实现
```

#### set 优化 dp
```cpp
#include <cstdio>
#include <cctype>
#include <functional>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#define MAXIOLG 25
#define MAXN 500005
#define MAXM 1000005
#define INf 114514
#define INF 1919810

using namespace std;

typedef long long ll;
typedef long double ld;
typedef ll io_t;

io_t shin[MAXIOLG];
io_t seto(void);
void ayano(io_t x,char spliter='\n');

priority_queue<int,vector<int>,greater<int> > q; //用于贪心的小根堆
set<pair<int,int> > st; //pair 自带比较函数

int fst[MAXN],nxt[MAXM],edges=0;
int g[MAXM];
int ind[MAXN];
int pre[MAXN];
int f[MAXN];

void addedge(int u,int v);

int main(void){
    int n,m;
    n=seto(),m=seto();
    while (m--){
        int u,v;
        u=seto(),v=seto();
        addedge(u,v),ind[v]++;
    }
    for (int i=1;i<=n;i++)
        (!ind[i])?(q.push(i),pre[i]=0):(0),
        f[i]=INF;
    int ans1=0;
    int tx=0;
    f[0]=0;
    st.insert(make_pair(0,0));
    while (!q.empty()){
        int nowv=q.top();
        q.pop();
        int tpre=pre[nowv];
        //以下是 dp
        if (nowv>tpre){
            //计算 f 值; first 保存"值"——标号,second 保存"下标"——代价
            f[nowv]=st.lower_bound(make_pair(tpre,0))->second+1;
            int tf=f[nowv];
            //下面将把 f[nowv] 插入到 set 中
            //找到标号小于 nowv 且代价大于 nowv 的状态
            auto it=st.lower_bound(make_pair(nowv,0));
            // 不断删除
            while ((it!=st.begin() && (it--,1)) && (it->second > tf))
                st.erase(it),it=st.lower_bound(make_pair(nowv,0));
            //插入
            st.insert(make_pair(nowv,tf));
        }
        tpre=max(tpre,nowv);
        //以下是贪心
        if (nowv>tx)
            tx=nowv,ans1++;
        for (int ei=fst[nowv];ei;ei=nxt[ei]){
            int v=g[ei];
            pre[v]=max(pre[v],tpre);
            ind[v]--;
            (!ind[v])?(q.push(v)):(void());
        }
    }
    ayano(ans1);
    ayano(f[n]);
    return 0;
}
//以下略去了 addedge, seto, ayano 三个函数的实现
```

---

## 作者：huangzirui (赞：8)

这里补充一下其他题解里面没有解释的对于第二问为什么不能直接跑优先队列的原因。

首先显然对于一组可以到达的点 $a_1,a_2,\dots,a_n$，设上一次到达的点为 $last$ ，则对于点 $a_i<last$ 都是不用付出筹码可以到达的点。我们可以优先走这些点来扩充操作序列。

而当所有的可到达点都比 $last$ 大时，我们贪心的选择当前可到达的点中最大的。至于为什么不能优先选择一个值较小的来扩充可到达的点构成的序列，因为如果选择最大点再返回这个点，花费的筹码数依旧是1而且少了一个需要走到点，显然更优秀。

然后算法的雏形就出来了 ->

```cpp
priority_queue<int>Q;
queue<int>Q2;
while(cnt!=n){
	while(!Q.empty()){
		++cnt;
		int now=Q.top();
        //选择一个新的优先队列中值最大的点
		Q.pop();
		if(now>LAST){ans++;LAST=now;}
		for(int i=head[now];i;i=a[i].next){
			int u=a[i].to;
			num[u]--;
			if(!num[u]){
				if(u>LAST)Q2.push(u);
                //如果比last大就待会再选
				else Q.push(u);
                //否则就丢到优先队列里面
			}
		}
	}
	while(!Q2.empty()){
    	//优先队列没有值时就把所有能选的再放进去
		Q.push(Q2.front());
		Q2.pop();
	}
}
```

---

## 作者：地表最强男人 (赞：6)

- 这题算是一个贪心，如果是最优的情况，那么每一次都优先选择当前最小的且能够更新（也就是入度为0）的点更新，因为当前越小，后面能够选择的就越多，然后如果当前有比当前最大权值还小的点，那么可以选择直接更新，因为这样的点是不会对答案有影响的，而且还能够提供更多的选择来更新。所以最优的策略可以总结为，每一次选择当前可以选择的最小的点更新。
- 如果是最劣的情况就有一些不一样，对于当前能够更新的点，如果当前能够选择的点的最小权值也比我们当前更新到的最大权值还要大的话。那最优的就是把当前权值最大的点更新。因为当前最大权值如果越大的话，那么后面产生贡献的可能性就越小。这时就可以将所有点权比当前的最大权值小的点都更新了。因为这些点留着也永远不会产生贡献，那么就选择更新。就这样一直到所有的点更新完。
- 然后因为题目的更新法则符合拓扑排序，那么就跑两遍拓扑排序跑最优和最劣情况就行了。然后对于这些最大和最小的点，就用堆（优先队列）来优化。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
#define re register
using namespace std;
const int N=500010;
int n,m,ru[N],ru2[N];
int head[N],ver[N],Next[N],tot,maxn=0,ans;
bool use[N];
priority_queue<int> s;//堆 
priority_queue<int> s2;//小根堆，第二次用 
inline void add(int x,int y)
{
        ver[++tot]=y;
        Next[tot]=head[x],head[x]=tot;
}
inline int read()
{
        char c=getchar();
        int num=0;
        while(c<'0'||c>'9')
            c=getchar();
        while(c>='0'&&c<='9')
        {
            num=(num<<1)+(num<<3)+c-48;
            c=getchar();
        }
        return num;
}
inline void topo()
{
        for(re int i=1;i<=n;i++)
            if(!ru[i])
                s.push(-i);
        while(s.size())
        {
            int x=-s.top();
            if(x>maxn)
            {
                ans++;
                maxn=x;
            }
            s.pop();
            for(re int i=head[x];i;i=Next[i])
            {
                int y=ver[i];
                ru[y]--;
                if(!ru[y])
                    s.push(-y);
            }
        }
} 
inline void topo2()
{
        maxn=0;
        ans=0;
        for(re int i=1;i<=n;i++)
            if(ru2[i]==0)
            {
                s.push(i);
                s2.push(-i);
            }
        while(s.top()>maxn)
        {
            maxn=s.top();
            ans++;
            while(s2.size()&&-s2.top()<=maxn)
            {
                int x=-s2.top();
                s2.pop();
                for(re int i=head[x];i;i=Next[i])
                {
                    int y=ver[i];
                    ru2[y]--;
                    if(!ru2[y])
                    {
                        s.push(y);
                        s2.push(-y);
                    }
                }
                use[x]=1;
            }
            while(s.size()&&use[s.top()]==1)
                s.pop();
            if(s.top()<=maxn)
                break;
        }
}
int main()
{
        n=read();
        m=read();
        for(re int i=1;i<=m;i++)
        {
            int x,y;
            x=read();
            y=read();
            add(x,y);
            ru[y]++;
            ru2[y]++;
        }
        topo();
        printf("%d\n",ans);
        topo2();
        printf("%d\n",ans);
        return 0;
}
```


---

## 作者：_agKc_ (赞：6)

# 需要点亮的芝士点：
- 拓扑排序
- STL的熟练操作

# 前言：
因为我太蒟了，月赛的时候还不知道拓扑排序是什么，再加上没看清楚题目，只有6分，丢人~~~
# 正题：
## 第一个任务点
拓扑排序裸题，加上一个优先队列（STL真**好用）

直接上代码
```cpp
while(_MAX.empty()==0)
	{
		rint now=_MAX.top();
		if(now>MAX_NUM)
		{
			MAX_NUM=now;
			ansMAX++;
		}
		_MAX.pop();
		for(rint i=0;i<to[now].size();i++)
		{
			lock[to[now][i]]--;
			if(lock[to[now][i]]==0)
			{
				_MAX.push(to[now][i]);
			}
		}
	}
```

## 第二个任务点
试了一下拓扑排序，然后**爆了**。。。。。。
仔细想了一下，总是去当前能去的最大点这个思路是错的，因为可能有一些比已经到达的最大点（指编号最大）要小的点能够解锁比当前最大点还要大的点。

那么就要用SET了（STL天下第一）

直接上代码
```cpp
while(_MIN.empty()==0)
	{
		rint now;
		if(_MIN.size()==1) now=*(_MIN.begin());
		else if(*(_MIN.begin())<MIN_NUM) now=*(_MIN.begin());
		else now=*(--_MIN.end());
		if(now>MIN_NUM)
		{
			MIN_NUM=now;
			ansMIN++;
		}
		_MIN.erase(_MIN.find(now));
		for(rint i=0;i<to[now].size();i++)
		{
			lock1[to[now][i]]--;
			if(lock1[to[now][i]]==0)
			{
				_MIN.insert(to[now][i]);
			}
		}
	}
```

# 警告：前方AC代码出没，想自己思考者请返回

```
#define Tokisaki return  //狂三天下第一
#define Kurumi  0;
#include<iostream>
#include<map>
#include<vector>
#include<set>
#include<cstdio>
#include<queue>
#include<algorithm>
#define rint register int
typedef long long ll;
using namespace std;
const int MAXN=500005;
ll read (){ll ret=0,f=1;char c=getchar();while(!isdigit(c)) f=c=='-'?-1:1,c=getchar();while( isdigit(c)) ret=ret*10+c-'0',c=getchar();return ret*f;}
vector <int > to[MAXN];
map<pair<int,int>,bool> MAP;
priority_queue < int ,vector<int >,greater<int> > _MAX;
set<int > _MIN;
int lock[MAXN],lock1[MAXN],ansMAX,ansMIN;
int main(){
	rint n,m,x,y,head=0,MAX_NUM=0,MIN_NUM=0;
	n=read(),m=read();
	for(rint i=1;i<=m;++i)
	{
		x=read(),y=read();
		if(MAP[make_pair(x,y)]==false)
		{
			to[x].push_back(y);
			MAP[make_pair(x,y)]=true;
			lock[y]++;
			lock1[y]++;
		}
	}
	for(rint i=1;i<=n;i++)
	{
		if(lock[i]==0) _MAX.push(i),_MIN.insert(i);
	}
	while(_MAX.empty()==0)
	{
		rint now=_MAX.top();
		if(now>MAX_NUM)
		{
			MAX_NUM=now;
			ansMAX++;
		}
		_MAX.pop();
		for(rint i=0;i<to[now].size();i++)
		{
			lock[to[now][i]]--;
			if(lock[to[now][i]]==0)
			{
				_MAX.push(to[now][i]);
			}
		}
	}
	while(_MIN.empty()==0)
	{
		rint now;
		if(_MIN.size()==1) now=*(_MIN.begin());
		else if(*(_MIN.begin())<MIN_NUM) now=*(_MIN.begin());
		else now=*(--_MIN.end());
		if(now>MIN_NUM)
		{
			MIN_NUM=now;
			ansMIN++;
		}
		_MIN.erase(_MIN.find(now));
		for(rint i=0;i<to[now].size();i++)
		{
			lock1[to[now][i]]--;
			if(lock1[to[now][i]]==0)
			{
				_MIN.insert(to[now][i]);
			}
		}
	}
	cout<<min(ansMAX,1919810)<<endl;
	cout<<min(ansMIN,1919810)<<endl;
	Tokisaki Kurumi //狂三我老婆，谁都别抢
}
```

# 后言
月赛的时候不知道拓扑排序，做了1个半小时，全部木大，后来问了教练，瞬间觉得简单了，看来方法是最重要的
## 好的CSer是在无数次爆零、白给中成长起来的

---

## 作者：VenusM1nT (赞：5)

伪贪心。  
首先考虑最优，显然每次取能走的里最优的（即编号最小的），一定能取到最优的答案。这部分可以用小根堆维护。  
再来考虑最劣，我们按最优的方法（即每次取编号最大的），只能拿到 46 分，原因是我们可能可以通过访问编号较小的来获得更优的编号更大的点，再访问这个点的话，就能取到更优的情况。因此我们可以用 set 维护，先判断能取的里最小的是不是不会产生贡献，如果不产生贡献就先把它取了，否则取编号最大的。
```cpp
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define MAXN 500005
#define reg register
#define inl inline
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
#define iter set<int>::iterator
using namespace std;
set <int> s;
priority_queue <int,vector<int>,greater<int> > q2;
int cnt,fst[MAXN],nxt[MAXN],to[MAXN];
int n,m,ind[MAXN],a[MAXN],ans1,ans2;
inl void AddEdge(reg int u,reg int v)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
}
template <typename T> inl void Read(reg T &x)
{
	x=0;
	reg int fu=1;
	reg char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
	x*=fu;
}
int main()
{
	Read(n);
	Read(m);
	for(reg int i=1;i<=m;i++)
	{
		reg int x,y;
		Read(x);
		Read(y);
		AddEdge(x,y);
		ind[y]++;
	}
	for(reg int i=1;i<=n;i++)
	{
		if(!ind[i])
		{
			s.insert(i);
			q2.push(i);
		}
	}
	reg int pre=0;
	memcpy(a,ind,sizeof(ind));
	while(!q2.empty())
	{
		reg int x=q2.top();
		q2.pop();
		if(x>pre)
		{
			ans2++;
			pre=x;
		}
		for(reg int i=fst[x];i;i=nxt[i])
		{
			reg int v=to[i];
			a[v]--;
			if(!a[v]) q2.push(v);
		}
	}
	pre=0;
	memcpy(a,ind,sizeof(ind));
	while(!s.empty())
	{
		reg iter it=s.begin();
		reg int u;
		if((*it)<pre)
		{
			u=(*it);
			s.erase(it);
		}
		else
		{
			it=s.end();
			it--;
			ans1++;
			pre=(*it);
			u=(*it);
			s.erase(it);
		}
		for(reg int i=fst[u];i;i=nxt[i])
		{
			reg int v=to[i];
			a[v]--;
			if(!a[v]) s.insert(v);
		}
	}
	printf("%d\n%d\n",ans2,ans1);
	return 0;
}
```

---

## 作者：TEoS (赞：4)

来自一名div1只有100pts的蒟蒻


------------
**题意分析**

可以看出走的实际上是一个拓扑序，只是需要根据题意对拓扑序进行一定的调整，最后的答案可能就不是一个标准的拓扑序了。

最优的情况，需要拿到最多的筹码，显然，要尽量构造一个递增序列，也就是让当前走的节点编号尽量小；最劣的情况，需要失去最少的筹码，显然，要尽量构造一个递减序列，也就是让当前走的节点编号尽量大。

**实现**

最优的情况，很显然，只需要进行一遍拓扑排序，将拓扑排序的队列换成小根堆，每次走入度为0的编号最小的节点即可。

最劣的情况，按照之前的分析，应该用大根堆来维护。如果那么简单，这题就只有黄题封顶了。

我们可以来分析一个情况，若当前有一个编号极小的节点，通过它可以走到一个编号极大的节点；然而因为前面这个节点的编号极小，我们很晚才会走到它，先走前面的节点就可能导致失去很多筹码；若先走这个小节点，之后可以大大降低失去的筹码。

怎么解决这个问题呢？显然，对当前在队列里的节点，如果编号小于之前走过的最大编号，那么我们走它对答案是没有贡献的，不妨把它们都走了；若当前队列中的所有节点编号都比之前走过的最大编号大，那不妨就走当前队列中编号最大的节点，答案加1。这样可以保证失去的筹码最小。

具体如何实现呢？可以有两种实现：

1. 建立一个小根堆和一个大根堆，每次取出小根堆中所有比之前走过的最大编号小的节点，插入大根堆，然后将大根堆中的节点从大到小依次访问。
1. 建立一个大根堆，每次取出大根堆中所有比之前走过的最大编号大的节点，插入一个队列，然后将大根堆中剩余的节点从大到小依次访问，之后再将队列中的元素插回大根堆。显然，这个方法的复杂度会比上一种方法大得多，然而由于本人太菜，就是用这种方法实现的。当然，也可能有更优的实现方案。

还有一点要注意的，双方的筹码是有上限的（然而本题数据并不需要处理这个问题）。

完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N=1e6,M=1e6;
int n,m,tot,ans1,ans2,max1,max2;
int head[N],ver[M],Next[2*M];
int ind1[N],ind2[N];
bool v[N];
priority_queue<int,vector<int>,greater<int> > q1;//小根堆
priority_queue<int> q2;//大根堆
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot,ind1[y]++,ind2[y]++;
}
void solve1()
{
	for(int i=1;i<=n;i++)
		if(!ind1[i])
			q1.push(i);
	while(q1.size())
	{
		int x=q1.top();q1.pop();
		if(x>max1)
		{
			max1=x;
			ans1++;
		}//累加答案
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i];
			if(--ind1[y]==0)
				q1.push(y);
		}
	}
}//最优情况
void solve2()
{
	for(int i=1;i<=n;i++)
		if(!ind2[i])
			q2.push(i);
	while(q2.size())
	{
		queue<int> q3;
		while(q2.size() && q2.top()>max2)
		{
			q3.push(q2.top());
			q2.pop();
		}
		if(!q2.size())
		{
			ans2++,max2=q3.front();//因为是从大到小插入，q3的队头一定是最大的
			while(q3.size())
			{
				int x=q3.front();q3.pop();
				for(int i=head[x];i;i=Next[i])
				{
					int y=ver[i];
					if(--ind2[y]==0)
						q2.push(y);
				}
			}
		}
		else
			while(q2.size())
			{
				int x=q2.top();q2.pop();
				for(int i=head[x];i;i=Next[i])
				{
					int y=ver[i];
					if(--ind2[y]==0)
						q3.push(y);
				}
			}
		while(q3.size())
		{
			q2.push(q3.front());
			q3.pop();
		}//放回去
	}
}//最劣情况
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	solve1();
	solve2();
	printf("%d\n%d",min(ans1,1919810),min(ans2,1919810));
	return 0;
}
```


---

## 作者：EternalEpic (赞：3)

#### 请避免投机取巧或不明所以的贪心
我发现其他题解对拓扑序列中贪心策略的分析不够详尽，我会照着自己赛时的思路，给予启发。（利益相关：赛时AC。div2 rk33）

首先，对于题目意思，其实就是能走所有当前入度为0的点，然后根据相关规则，选出最优拓扑序列（就是得失筹码）。

对于第一问，我们考虑每次选出当前可走点中最小的，这样就可以保证不会失去编号大的点对筹码数的贡献。在最优情况的最优策略下，这种贪心方案正确。此时我们只需把平时拓扑排序的队列换成小根堆即可。

code：
```cpp
max1 = 0;
while (h1.size()) {
	int u = h1.top(); h1.pop();
	if (u > max1) {
		max1 = u; ++ans1;
	}
	for (int i = head[u]; i; i = nxt[i]) {
		deg[ver[i]][0]--;
		if (!deg[ver[i]][0]) h1.push(ver[i]);
	}
}
```

对于第二问，如果你用相同方式，改为大根堆处理，那么恭喜你获得了46分的好成绩！！！

那第二问，这种贪心策略错在何处？？？

1 -> 5 -> 3

2 -> 4

看这样一组样例。如果按刚刚的策略，就会走24153，付出三个筹码，而15324只需两个。

我们发现在没有找到比当前最大值还大的点时， 应把每个点继续拓扑，然后再优先队列中选取最大点更新答案。

主程序：

```cpp
enum {
	Maxn = 500005,
	Maxm = 500005
};

int n, m, cnt = 0, head[Maxn], ver[Maxm], nxt[Maxm], deg[Maxn][2];
inline void AddEdge(int u, int v) { ver[++cnt] = v, nxt[cnt] = head[u], head[u] = cnt; }
priority_queue <int> h2; priority_queue <int, vector<int>, greater <int> > h1;
int max1, max2, ans1 = 0, ans2 = 0; stack <int> st;
inline void dfs(int u) {
	for (int i = head[u]; i; i = nxt[i]) {
		deg[ver[i]][1]--;
		if (!deg[ver[i]][1]) {
			if (ver[i] <= max2) dfs(ver[i]);
			else st.push(ver[i]);
		}
	}
}

signed main(void) {
//	file("");
	read(n), read(m);
	for (int i = 1, u, v; i <= m; i++)
		read(u), read(v), AddEdge(u, v), deg[v][0]++, deg[v][1]++;
	for (int i = 1; i <= n; i++) {
		if (!deg[i][0]) h1.push(i);
		if (!deg[i][1]) h2.push(i);
	}
	
	max1 = 0;
	while (h1.size()) {
		int u = h1.top(); h1.pop();
		if (u > max1) {
			max1 = u; ++ans1;
		}
		for (int i = head[u]; i; i = nxt[i]) {
			deg[ver[i]][0]--;
			if (!deg[ver[i]][0]) h1.push(ver[i]);
		}
	}
	
	max2 = 0;
	while (h2.size()) {
		int u = h2.top();
		if (u > max2) {
			max2 = u; ++ans2;
		} while (h2.size()) { dfs(h2.top()); h2.pop(); }
		while (st.size()) { h2.push(st.top()); st.pop(); }
	} writeln(ans1), writeln(ans2);
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```
作者不易，请支持！


---

## 作者：幻影星坚强 (赞：3)

就是类似于拓扑排序，每次选到比当前编号大的点就更新，要求最大和最小更新次数，所以选点的顺序不一样：
- 1：最优情况每次选择都选当前能选的编号最小的点，这样更新的次数最多

- 2：最劣情况每次先选择当前能选择的编号最大点，然后将所有能到达的且编号小于当前点的都到达了，如此循环，这样能保证更新的次数最小

代码如下：
```
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
priority_queue <int> q2;
priority_queue <int,vector<int>,greater<int> > q1;
queue <int> cun;
struct point
{
	int from, to;
}eg[500010];
int num, front[500010];
int ru[500010], ru1[500010];
void lian(int x, int y)
{
	eg[++ num].to = y;
	eg[num].from = front[x];
	front[x] = num;
}
int n, m;
int ans1, ans2;
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 0; i < m; ++i)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		lian(x, y);
		++ ru[y];
		++ ru1[y];
	}
	for (int i = 1; i <= n; ++i)
	{
		if (ru[i] == 0)
		{
			q1.push(i);
			q2.push(i);
		}
	}
	int maxs = 0;
	while(!q1.empty())
	{
		int now = q1.top();
		q1.pop();
		if (now > maxs)
		{
			maxs = now;
			++ ans1;
		}
		for (int i = front[now]; i ; i = eg[i].from)
		{
			int to = eg[i].to;
			-- ru[to];
			if (ru[to] == 0)
			{
				q1.push(to);
			}
		}
	}
	maxs = 0;
	while(!q2.empty())
	{
		while(!q2.empty())
		{
			int now = q2.top();
			q2.pop();
			if(now > maxs)
			{
				maxs = now;
				++ ans2;
			}
			cun.push(now);
		}
		while(!cun.empty())
		{
			int now = cun.front();
			cun.pop();
			for (int i = front[now]; i ; i = eg[i].from)
			{
				int to = eg[i].to;
				-- ru1[to];
				if (ru1[to] == 0)
				{
					if(to < maxs)
						cun.push(to);
					else
					q2.push(to);
				}
			}
		}
	}
	printf("%d\n%d",ans1, ans2 );
	return 0;
}
```


---

## 作者：miao5 (赞：2)

可以在[博客](https://www.luogu.com.cn/blog/miaowu2008/solution-p5603)食用

首先，我们可以发现，这道题要用**拓扑排序**。

其次，从题面可以得知，这道题要求**两个答案**，一个是“最多可以获得的”和“最少可以失去的”。

**我们先考虑“最多可以获得的”。**

这种情况的解决方法是这样的：

我们维护一个大根堆，在堆中存储所有入度已经变为零的节点，每次取出节点进行操作，最后输出 $ans$ 即可。

按照评测法，我们可以得到$40$分的好成绩。


**我们之后考虑“最少可以失去的”**。

可不可以将题目中的大根堆换成小根堆？

这是不行的，具体例子看下方：

![](https://cdn.luogu.com.cn/upload/image_hosting/p1yezwni.png)

在这个例子中，小根堆会依次遍历 $2,3,1,4$ ，总代价是$3$。

但是有另一种方法，是依次遍历 $2,1,4,3$ ，总代价是$2$。

那有什么方法呢？

不妨就考虑上图。

先开始肯定是遍历2号点，之后会有1号点和3号点是入度为零的，当我们遍历1号点是，答案并不会增加，于是我们遍历1号点，之后有3号点、4号点等待遍历，我们可以从大到小遍历。即先遍历4号点再遍历3号点，可以发现答案为$2$。


完整代码

```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int N=500005;
priority_queue<int,vector<int>,greater<int> > q1;
//此处q1为“最多可以获得的”所使用的堆。 
priority_queue<int,vector<int>,less<int> > q2;
//此处q2为“最少可以失去的”所使用的堆。
queue<int> a;
int head[N];
struct Edge{
	int to,nxt;
} e[N];
int sum;
void add(int x,int y){
	e[++sum].nxt=head[x];
	e[sum].to=y;
	head[x]=sum;
}//典型链式前向星存图。 
int n,m;
int ru[N],ru2[N];
void best_(){//最好状态下可以获得最多的筹码 
	int x=0,ans=0;
    while(!q1.empty()){
    	int u=q1.top();
    	q1.pop();
    	if(u>x){
    		ans++;
		}//由于本函数计算的是运气好的情况，只要大于目前max就答案加一 
		x=max(x,u);
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			ru[v]--;
			if(ru[v]==0) q1.push(v);
		}//遍历这个点 
	}
	cout<<ans<<endl;
}
void worst_(){//最坏状态下可以失去最少的筹码 
	int x=0,ans=0;
	while(!q2.empty()){
		int u=q2.top();
		if(u>x){
			ans++;
		}//由于本函数计算的是运气坏的情况，只要大于目前max就答案加一
		while(!q2.empty()){
			a.push(q2.top());
			q2.pop();
		}
		while(!a.empty()){
			int b=a.front();
			a.pop();
			x=max(x,b);
			for(int j=head[b];j;j=e[j].nxt){
				int v=e[j].to;
				ru2[v]--;
				if(ru2[v]==0){
					if(v>x) q2.push(v);
					else a.push(v);
				}
			}
		}
	}
	cout<<ans;
}
int main(){

	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		ru1[v]++;
		ru2[v]++;
	}//输入并存图
	for(int i=1;i<=n;i++){
		if(ru1[i]==0){
			q1.push(i);
			q2.push(i);
		}
	}//插入
	Best_();
	Worst_();//找到最优，最劣
}
```


---

## 作者：RPChe_ (赞：2)

首先读完题，我们就可以知道此题一定与拓扑排序有关。要求的分别是“最优方式能得到”和“最优方式只失去”的答案。

对于“最优方式能得到”问题，只用每次选最小值就可以了，因为尽量要保证升序，用一个小根堆维护就行。

而对于“最优方式只失去”问题，每次如果有小于当前最大值的点，我们就去走，因为这样是不影响答案的。而如果没有，我们就去走当前最大的点。

但是怎么实现呢？大佬们好像都用了一个小根堆和一个大根堆~~或是平衡树~~来实现，但是其实只用一个堆就够了。

这个堆不同于一般的小根堆或大根堆。我们假设堆中有2个元素x和y，当前最大值是maxx1，则这个堆比较的规则是：如果x和y都小于maxx1，则返回较小值，否则返回较大值，代码如下：

```
struct node1{
	int h;
	friend bool operator < (node1 x,node1 y) {
		if(x.h>maxx1&&y.h>maxx1) return x.h<y.h;
		return x.h>y.h;
	} 
};//具体比较规则可能与描述有所不同，这是因为STL默认的优先队列为大根堆，但结果是正确的。
priority_queue<node1> q1;
```

这样完整代码也会更短，更容易实现，如下：

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;

inline int read() {
	int f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}

inline void write(int x) {
	if(x<0) x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

int n,m,in[10000000],maxx,cnt,head[1000000],ans,in1[1000000],ans1,maxx1;

struct node{
	int a,b,next;
}e[10000000];

struct node1{
	int h;
	friend bool operator < (node1 x,node1 y) {
		if(x.h>maxx1&&y.h>maxx1) return x.h<y.h;
		return x.h>y.h;
	} 
};
priority_queue<int,vector<int>,greater<int> > q;
priority_queue<node1> q1;

void add(int a,int b) {
	cnt++;
	e[cnt].a=a;
	e[cnt].b=b;
	e[cnt].next=head[a];
	head[a]=cnt;
}

void top_sort() {
	while(!q.empty()) {
		int u;
		u=q.top();
		q.pop();
		if(maxx<u) {
			maxx=u;
			ans++;
		}
		for(int i=head[u];i!=-1;i=e[i].next) {
			in[e[i].b]--;
			if(in[e[i].b]==0) q.push(e[i].b);
		}
	}
}

void top_sort1() {
	while(!q1.empty()) {
		int u;
		u=q1.top().h;
		q1.pop();
		if(maxx1<u) {
			maxx1=u;
			ans1++;
		}
		for(int i=head[u];i!=-1;i=e[i].next) {
			in1[e[i].b]--;
			node1 t;
			t.h=e[i].b;
			if(in1[e[i].b]==0) q1.push(t);
		}
	}
}

int main() {
	memset(head,-1,sizeof(head));
	n=read(),m=read();
	for(int i=1;i<=m;i++) {
		int a=read(),b=read();
		add(a,b);
		in[b]++;
		in1[b]++;
	}
	for(int i=1;i<=n;i++) {
		if(in[i]==0) {
			q.push(i);
			node1 t;
			t.h=i;
			q1.push(t);
		}
	}
	top_sort();
	top_sort1();
	write(ans),putchar('\n'),write(ans1);
	return 0;
}
```

~~然而考场上窝还是只有46分。~~

---

## 作者：撤云 (赞：2)

[戳我](https://www.cnblogs.com/hbxblog/p/11749582.html)
### $Solution$

我们来分析题目。

实际上就是求一个拓扑序满足拓扑序的前缀最大值最多/最少

对于第一种情况，很明显一直选当前能选的最小的是最优的对吧。因为你需要大的尽可能多。用个堆维护就好了

但是很多人第二种情况想当然了，认为一直取最大值就可以了，但是这种行为太$Naive$了。我们需要讨论一下，如果当前能取的最小值不是前缀最大值，则需要先选他，否则就选能选的最大值，因为你选了这个最小值以后可能释放一个比当前最大值更大的值，这样子答案就可能会更优。那么这个怎么维护呢，用个$set$就好了，如果不会看下代码吧


### $Code$

```cpp
#include<bits/stdc++.h>
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
struct node {
	int to,next;
}a[1000001];
int head[1000001],cnt,n,m,x,y;
int vis[1000001];
int bj[1000001];
set<int> s;
priority_queue<int,vector<int>,greater<int> > p;
void add(int x,int y){
	a[++cnt].to=y;
	a[cnt].next=head[x];
	head[x]=cnt;
}
void solve1(){
	int maxx=0,ans=0;
	while(!p.empty()){
		int now=p.top();
		p.pop();
		if(now>maxx) maxx=now,ans++;
		for(int i=head[now];i;i=a[i].next){
			int v=a[i].to;
			vis[v]--;
			if(!vis[v]) p.push(v);
		}
	}
	printf("%d\n",ans);
}
void solve2(){
	int maxx=0,ans=0;
	while(!s.empty()){
		set<int>::iterator it=s.end();it--;
		set<int>::iterator it2=s.begin();
		int now1=*it2,now=now1;
		if(now1>maxx) now=*it;
		s.erase(now);
		if(now>maxx) maxx=now,ans++;
		for(int i=head[now];i;i=a[i].next){
			int v=a[i].to;
			bj[v]--;
			if(!bj[v]) s.insert(v);
		}
	}
	cout<<ans;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++)
		x=read(),y=read(),add(x,y),vis[y]++,bj[y]++;
	for(int i=1;i<=n;i++)
		if(!vis[i]) s.insert(i),p.push(i);
	solve1();
	solve2();
    return 0;
}
```

---

## 作者：xixiup (赞：2)

这道题一个TOP排序

第一问直接用一个小根堆维护TOP排序，使结果尽可能的接近一个升序排列，这样走到更大值的次数最多

第二问，按照这种逻辑，应该用大根堆维护TOP排序，然后交上去46分

然后我们来康一个图

![](https://cdn.luogu.com.cn/upload/image_hosting/7c4frhue.png)

按照这种思路，先访问1，然后2和3解锁，访问3，再去4，最后2,6,5

共有4次到更大值

但去完3再去2，再去6，再去5，最后去4呢？

只有三次

那怎么办呢？超级暴力？

康康我之前的$n^{3}$代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,cnt,rd[500100];
int ne[500100],to[500100],bg[500100];
void add(int x,int y){
	cnt++;
	ne[cnt]=bg[x];
	to[cnt]=y;
	bg[x]=cnt;
}
void top_sort1(){
	int Rd[500100];
	for(int i=1;i<=n;i++){
		Rd[i]=rd[i];
	}
	int Max=0;
	priority_queue<int,vector<int>,greater<int> >q;
	for(int i=1;i<=n;i++){
		if(Rd[i]==0){
			q.push(i);
		}
	}
	int ans=0;
	while(!q.empty()){
		int x=q.top();
		q.pop();
		if(x>Max){
			Max=x;
			ans++;
		}
		for(int i=bg[x];i;i=ne[i]){
			int y=to[i];
			Rd[y]--;
			if(Rd[y]==0){
				q.push(y);
			}
		}
	}
	printf("%lld\n",ans);
	return;
}
int DFS(int x,int Ma){// 寻找在不影响最大值时能到的最大点
	if(x>Ma){
		return x;
	}
	int sum=x;
	for(int i=bg[x];i;i=ne[i]){
		int y=to[i];
		if(rd[y]==1){// 只有该点能到达它
			sum=max(sum,y);
			if(y<Ma){
				sum=max(sum,DFS(y,Ma));
			}
		}
	}
	return sum;
}
void top_sort2(){
	int Qw[500100],nq;
	int Max=0;
	priority_queue<int,vector<int>,less<int> >q;
	for(int i=1;i<=n;i++){
		if(rd[i]==0){
			q.push(i);
		}
	}
	int ans=0;
	while(!q.empty()){
		int x=q.top();
		x=DFS(x,Max);
		if(x>Max){// 找到一个更大值后把队列里面所有东西掏出来DFS一波
			Max=x;
			ans++;
			if(Max==n){
				printf("%lld",ans);
				return;
			}
			nq=q.size();
			for(int i=1;i<=nq;i++){
				Qw[i]=q.top();q.pop();
			}
			for(int i=1;i<=nq;i++){
				q.push(DFS(Qw[i],Max));
			}
		}
		for(int i=bg[x];i;i=ne[i]){
			int y=to[i];
			rd[y]--;
			if(rd[y]==0){
				q.push(DFS(y,Max));
			}
		}
	}
	printf("%lld",ans);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);
		rd[y]++;
	}
	top_sort1();
	top_sort2();
	return 0;
}
```

然而TLE+WA30分

那么我们考虑，如果我们走到一个小于当前最大值的点，那么是不影响答案的，何乐而不为呢？

于是我们想到，再建一个小根堆，当小根堆堆顶小于最大值时，就拓展该点，不然在去找大根堆顶

说起来容易做起来难啊

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,cnt,rd[500100];
int ne[500100],to[500100],bg[500100];
void add(int x,int y){
	cnt++;
	ne[cnt]=bg[x];
	to[cnt]=y;
	bg[x]=cnt;
}
void top_sort1(){
	int Rd[500100];
	for(int i=1;i<=n;i++){
		Rd[i]=rd[i];
	}
	int Max=0;
	priority_queue<int,vector<int>,greater<int> >q;
	for(int i=1;i<=n;i++){
		if(Rd[i]==0){
			q.push(i);
		}
	}
	int ans=0;
	while(!q.empty()){
		int x=q.top();
		q.pop();
		if(x>Max){
			Max=x;
			ans++;
		}
		for(int i=bg[x];i;i=ne[i]){
			int y=to[i];
			Rd[y]--;
			if(Rd[y]==0){
				q.push(y);
			}
		}
	}
	printf("%lld\n",ans);
	return;
}
void top_sort2(){
	int Max=0,p[500100]={0};
	priority_queue<int,vector<int>,less<int> >q;
	priority_queue<int,vector<int>,greater<int> >q1;
	for(int i=1;i<=n;i++){
		if(rd[i]==0){
			q.push(i);
			q1.push(i);
		}
	}
	int ans=0;
	while(!q.empty()){
		int x=q1.top();
		while(p[x]==1&&!q1.empty()){
			q1.pop();
			x=q1.top();//在小根堆顶找
		}
		if(x>Max||q1.empty()){//没找到
			x=q.top();
			q.pop();
			while(!q.empty()&&p[x]==1){
				x=q.top();
				q.pop();// 去大根堆
			}
		}
		if(x==q1.top()){
			q1.pop();
		}
		p[x]=1;
		if(x>Max){
			Max=x;
			ans++;
		}
		for(int i=bg[x];i;i=ne[i]){// Top排序常规操作
			int y=to[i];
			rd[y]--;
			if(rd[y]==0){
				q.push(y);
				q1.push(y);
			}
		}
	}
	printf("%lld",ans);
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);
		rd[y]++;
	}
	top_sort1();
	top_sort2();
	return 0;
}
```


---

## 作者：Leianha (赞：2)

## 贪心

[博客中阅读](https://www.cnblogs.com/wljss/p/11750188.html)

该问题可以分为两个子问题：

1.求一种拓扑顺序使点的编号最大值的更新次数最多。

2.求一种拓扑顺序使点的编号最大值的更新次数最少。

对于第一个子问题，我们贪心的想，每次走到所有能走的点中编号最小的点。这种贪心显然是正确的，因为如果我们先走编号较大的点，再走编号较小的点，显然不如先走编号较小的点更优一些。所以我们将原先拓扑排序中的普通队列换成维护最小值的优先队列即可。
```cpp
priority_queue<int, vector<int>, greater<int> >Q;
for (int i = 1; i <= n; ++i)
		if (!in1[i])Q.push(i);
while (!Q.empty())
{
	u = Q.top(); Q.pop();
	if (u > maxx) {++ans; maxx = u;}
	for (int i = head[u]; i; i = e[i].nt)
		if (!(--in1[e[i].to]))Q.push(e[i].to);
}
printf("%d\n", ans);
```
对于第二个子问题，如果我们将上面的维护最小值的优先队列换成维护最大值的优先队列就错了，可以被下面的图卡掉

![](https://cdn.luogu.com.cn/upload/image_hosting/xaj2d4uu.png)

为什么呢？根据错误的贪心策略，我们会依次更新上面的那些点，但是我们如果依次更新1、2、8，再更新别的点，代价仅为3.因为错误的贪心每次只选择较大的点，忽略了较小的点所能带来的贡献。所以我们可以改变一下贪心策略，在每次取出编号最大点后，将优先队列中编号比它小的依次取出删去出边，倘若先加入的点，编号不会更新最大值，我们也将它删去出边，否则我们另用一个优先队列来储存这些边。这可以用类似滚动数组的思想来解决。

```cpp
priority_queue<int>q[2];
for (int i = 1; i <= n; ++i)
		if (!in2[i])q[0].push(i);
while ((!q[0].empty()) || (!q[1].empty())) 
{
	u = q[now].top();
	if (u > maxx) {++ans; maxx = u;}
	while (!q[now].empty()) 
	{
		u = q[now].top(); q[now].pop();
		for (int i = head[u]; i; i = e[i].nt)
			if (!(--in2[e[i].to])) 
			{
				if (e[i].to < maxx)q[now].push(e[i].to);
				else q[now ^ 1].push(e[i].to);
			}
	}
	now ^= 1;
}
```
以上两个综合利用起来就能满分啦~

最后献上完整代码.

```cpp
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
/*  It is day of judgement!  */
int n, m, tot, x, y, ans, maxx, u, now;
const int N = 500010;
int head[N], in1[N], in2[N];
struct bian {int to, nt;} e[N << 1];
priority_queue<int, vector<int>, greater<int> >Q;
priority_queue<int>q[2];
void add(int f, int t) 
{
	e[++tot].to = t;
	e[tot].nt = head[f];
	head[f] = tot;
}
int main() 
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i) 
	{
		scanf("%d%d", &x, &y);
		add(x, y);
		in1[y]++; in2[y]++;
	}
	for (int i = 1; i <= n; ++i)
		if (!in1[i])Q.push(i);
	while (!Q.empty())
	{
		u = Q.top(); Q.pop();
		if (u > maxx) {++ans; maxx = u;}
		for (int i = head[u]; i; i = e[i].nt)
			if (!(--in1[e[i].to]))Q.push(e[i].to);
	}
	printf("%d\n", ans);
	/*上面为问题1，下面是问题2*/
	ans = 0; maxx = 0;
	for (int i = 1; i <= n; ++i)
		if (!in2[i])q[0].push(i);
	while ((!q[0].empty()) || (!q[1].empty())) 
	{
		u = q[now].top();
		if (u > maxx) {++ans; maxx = u;}
		while (!q[now].empty()) 
		{
			u = q[now].top(); q[now].pop();
			for (int i = head[u]; i; i = e[i].nt)
				if (!(--in2[e[i].to])) 
				{
					if (e[i].to < maxx)q[now].push(e[i].to);
					else q[now ^ 1].push(e[i].to);
				}
		}
		now ^= 1;
	}
	return printf("%d", ans) == 2333;
}
```


---

## 作者：opened (赞：1)

>这道题和拓扑排序有关

对于求最大的，可以贪心的取编号最小的入度相同的点。

但对于求最小的，就**不能直接贪心取编号最大的入度相同的点**。

在这里讨论：如果当前**能取的最小值不是前缀最大值**，则需要先选他；

否则就选能选的最大值，这个最大值可以用**优先队列**维护。

```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int N=1e6+10;
int n,m,ans,maxx,now,head[N],cnt,in1[N],in2[N];
struct node{int v,next;} G[N*2];
priority_queue<int,vector<int>,greater<int> >Q;
priority_queue<int> q[2];
void addedge(int u,int v){
    G[++cnt]=(node){v,head[u]};
    head[u]=cnt;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
    	int u,v;
    	scanf("%d%d",&u,&v);
		in1[v]++,in2[v]++;
    	addedge(u,v);
    }
    for(int i=1;i<=n;i++)
    	if(in1[i]==0) Q.push(i);
    while(!Q.empty()){
        int u=Q.top();
		Q.pop();
        if(u>maxx) ans++,maxx=u;
        for(int i=head[u];i;i=G[i].next){
			int v=G[i].v;
            if(!(--in1[v])) Q.push(v);
		}
    }
    printf("%d\n",ans);
    ans=0,maxx=0;
    for(int i=1;i<=n;i++)
        if(in2[i]==0) q[0].push(i);
    while((!q[0].empty())||(!q[1].empty())){
        int u=q[now].top();
        if(u>maxx) ans++,maxx=u;
        while(!q[now].empty()){
            int u=q[now].top();
			q[now].pop();
            for(int i=head[u];i;i=G[i].next){
				int v=G[i].v;
                if((--in2[v])==0){
                    if(v<maxx) q[now].push(v);
                    else q[now^1].push(v);
                }
			}
        }
        now^=1;
    }
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：LordLeft (赞：1)

题目大意：给你一张$DAG$，必须按照拓扑序来走，每走到一个比之前所有点标号都大的点就会加一分，求最大得分和最小得分。

首先，拓扑排序是显然的，关键是怎么达到题目的要求。

我们贪心的考虑，对于子任务一，我们要最大化得分，每次只要走向一个还没遍历过的标号最小的点，这样就能使之后那些标号更大的点尽可能发挥贡献。

这样的话，我们只要把拓扑排序的队列改成一棵平衡树， 每次取出能遍历的标号最小的点即可。

对于子任务二，也是贪心的思想。但是这里和之前不大一样，我们要先看我们的平衡树里面最小的那个节点是否小于当前最大值，如果是的话，那么把这些点取出来一定不会使得答案变劣。

在此之后，我们可以直接再取出平衡树里最大的点来扩展，我们再贪心的考虑，这个点会使得之后标号更小的点失去贡献。

~~然后大家都是用两个堆写的，我还是太蠢了~~

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<ctime>
#include<cstdlib>
#include<cstring>
#define rg register
#define il inline
using namespace std;
il int read(){
	int w=0;
	bool s=0;
	char c=getchar();
	while(!isdigit(c)){
		s=(c=='-');
		c=getchar();
	}
	while(isdigit(c)){
		w=w*10+c-'0';
		c=getchar();
	}
	return s?-w:w;
}
const int N=500005,inf=2147483647;
int n,m;
struct Treap{
	int cnt,root;
	int son[N][2],val[N],wei[N],size[N],cpy[N];
	il int add(int v){
		val[++cnt]=v;
		size[cnt]=1;
		cpy[cnt]=1;
		wei[cnt]=rand();
		return cnt;
	}
	il void pushup(int id){
		size[id]=size[son[id][0]]+size[son[id][1]]+cpy[id];
	}
	il void init(){
		memset(son,0,sizeof(son));
		memset(val,0,sizeof(val));
		memset(wei,0,sizeof(wei));
		memset(size,0,sizeof(size));
		memset(cpy,0,sizeof(cpy));
		cnt=0;
		root=0;
		root=add(-inf);
		son[root][1]=add(inf);
		pushup(root);
	}
	il void rotate(int &id,int d){
		int e=son[id][d^1];
		son[id][d^1]=son[e][d];
		son[e][d]=id;
		id=e;
		pushup(son[id][d]);
		pushup(id);
	}	
	void insert(int &id,int v){
		if(!id){
			id=add(v);
			return;
		}
		if(v==val[id]){
			cpy[id]++;
		}	
		else{
			int d=(v<val[id]?0:1);
			insert(son[id][d],v);
			if(wei[id]<wei[son[id][d]]){
				rotate(id,d^1);
			}
		}
		pushup(id);
	}	
	void remove(int &id,int v){
		if(!id){
			return;
		}
		if(v==val[id]){
			if(cpy[id]>1){
				cpy[id]--;
				pushup(id);
				return;
			}	
			else if(son[id][0]||son[id][1]){
				if(!son[id][1]||wei[son[id][0]]>wei[son[id][1]]){
					rotate(id,1);
					remove(son[id][1],v);
				}
				else{
					rotate(id,0);
					remove(son[id][0],v);
				}
				pushup(id);	
			}
			else{
				id=0;
			}	
			return;	
		}	
		else if(v<val[id]){
			remove(son[id][0],v);
		}
		else{
			remove(son[id][1],v);
		}	
		pushup(id);
	}	
	int rank(int id,int v){
		if(!id){
			return 0;
		}
		if(v==val[id]){
			return size[son[id][0]]+1;
		}	
		else if(v<val[id]){
			return rank(son[id][0],v);
		}	
		else{
			return size[son[id][0]]+cpy[id]+rank(son[id][1],v);
		}	
	}
	int value(int id,int v){
		if(!id){
			return inf;
		}	
		if(v<=size[son[id][0]]){
			return value(son[id][0],v);
		}	
		else if(v<=size[son[id][0]]+cpy[id]){
			return val[id];
		}	
		else{
			return value(son[id][1],v-size[son[id][0]]-cpy[id]);
		}	
	}
	il int pre(int v){
		int id=root;
		int res;
		while(id){
			if(val[id]<v){
				res=val[id];
				id=son[id][1];
			}
			else{
				id=son[id][0];
			}	
		}
		return res;	
	}
	il int nxt(int v){
		int id=root;
		int res;
		while(id){
			if(val[id]>v){
				res=val[id];
				id=son[id][0];
			}
			else{
				id=son[id][1];
			}	
		}
		return res;
	}
	il void Push(int x){
		insert(root,x);
	}
	il void Pop(int x){
		remove(root,x);
	}
	il int Find(int x){
		int res=rank(root,x);
		return res-1;
	}
	il int Pos(int x){
		int res=value(root,x+1);
		return res;
	}
	il int Lower(int x){
		int res=pre(x);
		return res;
	}
	il int Upper(int x){
		int res=nxt(x);
		return res;
	}
	il bool Empty(){
		return Lower(inf)==-inf;
	}
};
Treap T;
struct Graph{
	struct Edge{
		int to;
		Edge *nxt;
	};
	Edge e[N],*pre[N];
	int cnt;
	il void add_for(int u,int v){
		e[++cnt].nxt=pre[u];
		e[cnt].to=v;
		pre[u]=&e[cnt];
	}
	Graph(){
		memset(pre,0,sizeof(pre));
		cnt=0;
	}
};
Graph G;
int deg[N],cpy[N];
int tmp,ans;
int main(){
	srand((int)time(0));
	n=read(),m=read();
	T.init();
	int u,v;
	for(rg int i=1;i<=m;i++){
		u=read(),v=read();
		G.add_for(u,v);
		deg[v]++;
		cpy[v]++;
	}
	for(rg int i=1;i<=n;i++){
		if(!deg[i]){
			T.Push(i);
		}
	}
	while(!T.Empty()){
		u=T.Pos(1);
		T.Pop(u);
		if(u>tmp){
			tmp=u;
			ans++;
		}
		for(Graph::Edge *i=G.pre[u];i!=NULL;i=i->nxt){
			v=i->to;
			if(!--deg[v]){
				T.Push(v);
			}
		}
	}
	printf("%d\n",ans);
	T.init();
	for(rg int i=1;i<=n;i++){
		deg[i]=cpy[i];
		if(!deg[i]){
			T.Push(i);
		}
	}
	tmp=0,ans=0;
	while(!T.Empty()){
		while(T.Upper(-inf)<tmp&&!T.Empty()){
			u=T.Upper(-inf);
			T.Pop(u);
			for(Graph::Edge *i=G.pre[u];i!=NULL;i=i->nxt){
				v=i->to;
				if(!--deg[v]){
					T.Push(v);
				}
			}
		}
		if(T.Empty()){
			break;
		}
		ans++;
		tmp=T.Lower(inf);
		u=tmp;
		T.Pop(u);
		for(Graph::Edge *i=G.pre[u];i!=NULL;i=i->nxt){
			v=i->to;
			if(!--deg[v]){
				T.Push(v);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```
GL~

---

## 作者：yizr_cnyali (赞：0)

首先,不要被题目中所说的概率迷惑了,这道题中所说的概率对于解题**没有**实际意义  

先考虑最优情况下小C能拿到的筹码数,显然每次在能走的里面选择编号最小的即可,我们可以用一个小根堆通过拓扑排序求解

然后,考虑最劣情况下小C能拿到的筹码数,首先考虑采用跟最优情况相似(即每次在能走的里面选择编号最大的结点)的做法,容易想到,这个做法是有问题的,因为我们可能会在选择局部较劣的结点后得到更优的选择(因为可能在选择了一个编号较小的结点后可以选择的编号大的结点比选择之前更大)   

我们可以考虑对这个做法进行一些改动:每次选择能走的结点中编号最大的结点,但接下来优先选择所有编号比它小的结点,这样前面所提到的问题就得到了解决。为了实现这一操作,我们可以在使用大根堆的拓扑排序中套一个小根堆来实现。因为可能出现一个结点在大根堆中已经访问过而在小根堆中没有访问的情况,我们需要建立一个vis数组来标记结点的访问情况。

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair

using namespace std;

typedef long long LL;
typedef pair<int, int> pii;

template <typename T> inline int Chkmax (T &a, T b) { return a < b ? a = b, 1 : 0; }
template <typename T> inline int Chkmin (T &a, T b) { return a > b ? a = b, 1 : 0; }

template <typename T> inline T read(){
    T sum = 0;
    int fl = 1,ch = getchar();
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') fl = -1;
    for(; isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) + ch - '0';
    return sum * fl;
}

const int maxn = 5e5 + 5;

int n,m,ans = 0;
int head[maxn],cnt;
int ind[maxn],vis[maxn],tmp[maxn];

struct edge{
	int to;
	int next;
}e[maxn];

inline void add_edge(int u,int v){
	cnt++;
	e[cnt].to = v;
	e[cnt].next = head[u];
	head[u] = cnt;
}

inline void toposort(){
	priority_queue <int,vector<int>,greater<int> > q;
	for(int i = 1; i <= n; i++) tmp[i] = ind[i];
	for(int i = 1; i <= n; i++){
		if(!tmp[i]) q.push(i);
	}
	int last = 0;
	while(!q.empty()){
		int x = q.top();
		q.pop();
		if(x > last){
			ans++;
			last = x;
		}
		for(int i = head[x]; i; i = e[i].next){
			int y = e[i].to;
			tmp[y]--;
			if(!tmp[y]) q.push(y);
		}
	}
}

inline void toposort2(){
	priority_queue <int> q1;
	priority_queue <int,vector<int>,greater<int> > q2;
	for(int i = 1; i <= n; i++){
		if(!ind[i]){
			q1.push(i);
			q2.push(i);
		}	
	}
	int last = 0;
	while(!q1.empty()){
		int x = q1.top();
		q1.pop();
		if(vis[x]) continue;
		vis[x] = true;
		if(x > last){
			ans++;
			last = x;
		}
		for(int i = head[x]; i; i = e[i].next){
			int y = e[i].to;
			ind[y]--;
			if(!ind[y]){
				q1.push(y);
				q2.push(y);
			}
		}
		while(!q2.empty()){
			int Adscn = q2.top();
			if(Adscn > x) break;
			q2.pop();
			if(vis[Adscn]) continue;
			vis[Adscn] = true;
			if(Adscn > last){
				ans++;
				last = Adscn;
			}
			for(int i = head[Adscn]; i; i = e[i].next){
				int y = e[i].to;
				ind[y]--;
				if(!ind[y]){
					q1.push(y);
					q2.push(y);
				}
			}
		}
	}
}

inline void Solve (){
	toposort();
	printf("%d\n",ans);
	ans = 0;
	toposort2();
	printf("%d\n",ans);
}

inline void Input (){
	n = read<int>();
	m = read<int>();
	for(int i = 1; i <= m; i++){
		int x,y;
		x = read<int>();
		y = read<int>();
		add_edge(x,y);
		ind[y]++;
	}
}

int main(){
	Input();
	Solve();
	return 0;
}
```


---

## 作者：浮生南柯一梦 (赞：0)

### 本题是一道典型的贪心题。

对于第一小问：这个贪心比较简单，只需要按照拓扑排序，每次取可以取的最小的一个节点，易证，不做过多赘述。

对于第二小问：这是本道贪心题比较难的部分。

以下介绍几种我想到的贪心做法。

1. 最粗暴的做法，每次取能取的最大的一个节点，显然这是错误的，但是它可以对2个点，意味着你在比赛的时候使用此贪心可以获得46分的好成绩。

2. 稍微有点深度的做法，按照拓扑排序把同一拓扑优先级的节点放在一起，每次取每层最大的一个节点，这种贪心显然还是错误的，但是它可以对3个点，意味着你在比赛的时候使用此贪心可以获得49分的好成绩。

3. 其他还有一些贪心（~~瞎搞~~）做法，都可以获得部分得分。在此不过多赘述，**下面放出可以A此题的贪心做法**。

4. 很显然，如果可以取的节点中有比当前最大节点小的，取它答案不会增加，必定不会使答案更劣，所以先把这些点取完。如果剩下的所有节点都比当前最大节点大，那么一定是取最大的一个节点最优，因为取了它以后剩下的所有节点都可以取了。

最后附上代码供大家参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,x,y,db[1000010],nxt[1000010],len[1000010];
int t[1000010],tt[1000010],k,s,ss,maxii;
priority_queue<int> maxi;
priority_queue<int,vector<int>,greater<int> > mini,minii;
bool f[1000010];
template <typename T> void read(T &x)
{
	x=0;char c=getchar();bool flg=0;
	for (;!isdigit(c);c=getchar()) if (c=='-') flg=1;
	for (;isdigit(c);c=getchar()) x=x*10+c-'0';
	if (flg) x=-x;
}
void write(long long x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x>=10) write(x/10);
	putchar(x%10+48);
}
void writeln(long long x)
{
	write(x);
	puts("");
}
int main(){
	/*freopen(".in","r",stdin);
	freopen(".out","w",stdout);*/
	//ios::sync_with_stdio(false);
	read(a);read(b);
	for (register int i=1;i<=b;++i)
	{
		read(x);read(y);
		db[i]=y;
		nxt[i]=len[x];
		len[x]=i;
		t[y]++;tt[y]++;
	}
	for (register int i=1;i<=a;++i)
	if (t[i]==0)
	{
		mini.push(i);
		maxi.push(i);
		minii.push(i);
	}
	maxii=0;
	for (register int i=1;i<=a;++i)
	{
		if (mini.top()>maxii)
		{
			maxii=mini.top();
			s++;
		}
		k=len[mini.top()];		
		mini.pop();
		while (k)
		{
			t[db[k]]--;
			if (t[db[k]]==0) mini.push(db[k]);
			k=nxt[k];
		}
	}
	maxii=0;memset(f,0,sizeof(f));
	for (register int i=1;i<=a;++i)
	{
		while ((!minii.empty())&&(f[minii.top()])) minii.pop();
		while ((!maxi.empty())&&(f[maxi.top()])) maxi.pop();
		if (minii.top()<maxii)
		{
			k=len[minii.top()];
			f[minii.top()]=1;
			minii.pop();
		}
		else
		{
			if (maxi.top()>maxii)
			{
				maxii=maxi.top();
				ss++;
			}
			f[maxi.top()]=1;
			k=len[maxi.top()];
			maxi.pop();			
		}
		while (k)
		{
			tt[db[k]]--;
			if (tt[db[k]]==0) 
			{
				minii.push(db[k]);
				maxi.push(db[k]);
			}
			k=nxt[k];
		}
	}
	writeln(s);
	writeln(ss);
	return 0;
}
```


---


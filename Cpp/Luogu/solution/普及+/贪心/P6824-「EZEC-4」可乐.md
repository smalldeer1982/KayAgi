# 「EZEC-4」可乐

## 题目背景

很久以前，有一个 pigstd，非常迷恋美味的可乐。为了得到美味的可乐，他几乎用尽了所有的钱，他甚至对自己的 npy 也漠不关心~~其实是因为他没有npy~~，更不爱好看戏。除非买了新可乐，才会坐上马车出门炫耀一番。每一天，每个钟头他都要喝上一瓶新可乐。

pigstd 最近又买了许多箱新可乐——当然，这些可乐只有聪明的人才能喝到。

## 题目描述

pigstd 现在有 $n$ 箱可乐，第 $i$ 箱可乐上标着一个正整数 $a_{i}$。

若 pigstd 的聪明值为一个非负整数 $x$，对于第 $i$ 箱可乐，如果 $(a_{i} \oplus x )\le k$，那么 pigstd 就能喝到这箱可乐。

现在 pigstd 告诉了你 $k$ 与序列 $a$，你可以决定 pigstd 的聪明值 $x$，使得他能喝到的可乐的箱数最大。求出这个最大值。

## 说明/提示

### 提示

**pigstd 的聪明值 $x$ 可以为 $0$。**

### 样例解释

样例 1 解释：容易构造当 $x = 0$ 时，可以喝到所有可乐。

样例 2 解释：容易构造 $x = 913$，可以喝到所有可乐。

**样例解释未必是唯一的方法。**

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（29 points）：$1 \le n,k,a_{i} \le 1000$。

- Subtask 2（1 points）：$a_{i} \le k$。

- Subtask 3（70 points）：无特殊限制。

对于所有数据，保证 $1 \le n,k,a_{i} \le 10^6$。

$\oplus$ 代表异或，如果您不知道什么是异或，请单击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。

## 样例 #1

### 输入

```
3 5
2
3
4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 625
879
480
671
853
```

### 输出

```
4```

# 题解

## 作者：pigstd (赞：61)

![](https://cdn.luogu.com.cn/upload/image_hosting/zxxf3qro.png)

[更好的阅读体验](https://www.luogu.com.cn/paste/bbrjm79c)

对于每一个$a$和$k$，在二进制下，若前$1$到$j - 1$位异或出来的值都相同，那么对于第$j$位：

- $k_{j} = 0$：那么$x_{j}$只能为$a_{j}$

- 如果$k_{j} = 1$，那么$x_{j}$有两种取值：

	- .$x_{j} = a_{j}$ 然后后面取什么都可以

	- .$x_{j}= a_{j}\oplus 1$ 那么第$j$位异或出来的值也相同，继续枚举下一位即可




那么$x$的取值范围一定是一段区间，差分即可

（$x_{j}$为$x$在二进制下的第$j$位，其他同理）

code:
```cpp
#include<bits/stdc++.h>
using namespace std;

const int M=1e6+10;
int c[M*2],a[M],n,k,ans,maxn;
int s1[50],s2[50]; 

void f(int b)
{
	memset(s1,0,sizeof(s1));
	memset(s2,0,sizeof(s2));
	int len1=0,len2=0,kk=k;
	while(b)
		s1[++len1]=b%2,b/=2;
	while(kk)
		s2[++len2]=kk%2,kk/=2;
	int len=max(len1,len2);
	for (int i=1;i<=len/2;i++)
		swap(s1[i],s1[len-i+1]),swap(s2[i],s2[len-i+1]);
	int sum=0;
	for (int i=1;i<=len;i++)
		if (s2[i]==0)
			sum=sum*2+s1[i];
		else
		{
			int k1=(sum*2+s1[i])*1<<(len-i),k2=(sum*2+1+s1[i])*1<<(len-i);
			c[k1]++,c[k2]--;
			sum=sum*2+(s1[i]^1);
		}
	c[sum]++,c[sum+1]--;
}

int main()
{
	scanf("%d%d",&n,&k);maxn=k;
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		f(a[i]);
		maxn=max(maxn,a[i]);
	}
	for (int i=1;i<=maxn*2;i++)
		c[i]+=c[i-1];
	for (int i=0;i<=maxn*2;i++)
		ans=max(ans,c[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Spasmodic (赞：35)

提供一个考试时的奇怪做法。

首先显然这个聪明值不会超过 $2^{21}=2097152$，因为 $2a_i<2^{21}$。

然后我们考虑一个 naive 的暴力，就是枚举这个范围的每个数，每次暴力统计

显然暴力的瓶颈在于判断是否可行，那我们可以考虑建一个 Trie 来维护二进制的 $a_i$，判断的时候找 $x\oplus k$ 对应的路径，然后判断如果 $k$ 这一位恰好是 $1$ 就把这一位取反得到的子树的大小全部加进去，正确性是显然的。

复杂度 $O(2^{21}\times 21)$。

注意题目条件中要求的是 $(a_i\oplus x)\le k$，我们需要在 query 的末尾特判一下，不然会被
```
5 10
4
1
14
13
13
```
这组数据给叉掉。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,k,ans,a[N],cnt[2];
int tot,sz[N*21],trie[N*21][2];
void insert(int x){
    int p=0;
    for(int k=21,c;k>=0;k--){
        c=(x>>k)&1;
        if(!trie[p][c])trie[p][c]=++tot;
        p=trie[p][c];
        sz[p]++;
    }
}
int query(int x){
    int ret=0,p=0;
    bool flag=0;
    for(int i=21,c;i>=0;i--){
        c=(x>>i)&1;//x这一位的值
        int t=(k>>i)&1;//k这一位的值
        if(t==1)ret+=sz[trie[p][1-(c^t)]];//如果k这一位的值是1，那么这一位取1-(c^t)的时候一定可行，反之一定不可行
        if(!trie[p][c^t]){flag=1;break;}//如果走不到就返回
        p=trie[p][c^t];
    }
    if(!flag)ret+=sz[p];
    return ret;
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),insert(a[i]);
    for(int i=0;i<2097152;i++){
        ans=max(ans,query(i));
        if(ans==n)break;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：pocafup (赞：31)

感觉我的程序写得比 std 干净，顺手捞一波题解（

首先观察一个结论：如果 $x \oplus pos[i]$ 的高位为 $0$ ，而 $k$ 的高位为 $1$ ，那么无论低位怎么花里胡哨变，这罐可乐都属于可以喝的。反之亦然。

于是我们可以选择从高位进行判断。至此，本题变为四种情况：

下面假设正在计算第 $i$ 罐可乐，目前计算到的高位为 $j$
#### - $k$ 的第 $j$ 位是 1， $pos[i]$ 的第 $j$ 位是 $1$
如果 $x$ 这位上取 $1$，那么低位不论怎么这罐可乐都可以喝。

#### - $k$ 的第 $j$ 位是 1， $pos[i]$ 的第 $j$ 位是 $0$
$x$ 这位上取 $0$ 即可，理由同上。

#### - $k$ 的第 $j$ 位是 0， $pos[i]$ 的第 $j$ 位是 $1$
显然如果 $x$ 这位置上取 $0$ 的话，这罐可乐就一定喝不到。但取 $1$ 并不能保证喝到，还要继续往下判断。

#### - $k$ 的第 $j$ 位是 0， $pos[i]$ 的第 $j$ 位是 $0$
这位置上只能取 $0$，理由同上。

发现这几种操作其实修改的都只是一段区间，因此我们对可取的数字进行差分即可。

复杂度 $O(nlogk)$
```cpp
const int MAXN = 1e6+5;
int n,m,t,k,pos[MAXN],dp[MAXN<<2],ans;
inline void solve(int num){
  int re= 0;
  FOR(i,20,0){
    if (((k>>i) & 1) && ((num>>i) & 1)) dp[re+(1<<i)]++,dp[re+(1<<(i+1))]--;
    else if ((k>>i) & 1){
      dp[re]++,dp[re+(1<<i)]--;
      re+=(1<<i);
    }else if ((num>>i) & 1)re+=(1<<i);
  }
}
signed main(){
  n = read(); k=read();
  For(i,1,n) pos[i] =read(),solve(pos[i]);
  For(i,0,(1<<20)) {if (i) dp[i]+=dp[i-1]; ans = chkmax(ans,dp[i]);}
  cout << ans << endl;
}
```

---

## 作者：loveJY (赞：12)

为什么不能动态规划?提供一种动态规划做法

首先我们把trie树建出来，然后考虑在trie树上树形dp一下

$dp_u$表示只考虑了u的子树我们能够得到的最大可乐数

我们的决策无非就是考虑x这一位填1/0，但是与此同时k的这一位的值也会影响转移

1. k这一位是1

也就是说，我们能得到所有这一位是0的可乐，因为我们是从上到下考虑的，所以这一定是二进制比较中k刚好比$a_i$大的那一位

如果我们这一位x填一，就对应了这一位^1，就是交换左右子树

所以

$$dp_u=max(dp_{ls}+siz[rs],dp_{rs}+siz[ls])$$

ls为左子树，rs为右子树，分别对应x放不放1

2. k这一位是0

首先得不到这一位是1的可乐了

而这一位是0的这一位的比较并不能看出哪个大，所以

$$dp_u=max(dp_{ls},dp_{rs})$$

也可以看成我们要在下面的位数比较再比较大小

这样边界条件也很简单了，如果是叶子，$dp_u=siz_u$

因为我们至少也是=的情况

### 正确性:

仔细思考，如果我们x=0，我们的k其实对应了trie树上一条路径，而k取到1的那些位置上我们答案就加了左子树的大小

现在x可以为任何数，也就相当于这个trie树上任何这样的路径都能取到成为答案，所以也就dp出最大的这种路径的答案即可

$O(nlogV)$

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e7+7;//2e7比较严谨
const int B=19;
int n,k,a[MAXN],dp[MAXN],siz[MAXN],dep[MAXN],ch[MAXN][2],root,T;


namespace fastIO {
#define BUF_SIZE (1<<20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x<<1)+(x<<3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void ins(int x) {
	int u=root;
	for(int i=B; i>=0; --i) {
		int t=x>>i&1;
		if(!ch[u][t]) {
			ch[u][t]=++T;
		}
		u=ch[u][t];
	}
	siz[u]++;
	return ;
}

inline void dfs(int u) {
	if(!ch[u][0]&&!ch[u][1]) {
		dp[u]=siz[u];
		return ;
	}
	for(int i=0; i<=1; ++i) {
		if(ch[u][i]) {
			dep[ch[u][i]]=dep[u]-1;
			dfs(ch[u][i]);
			siz[u]+=siz[ch[u][i]];
		}
	}
	if(k>>dep[u]&1)dp[u]=max(dp[ch[u][0]]+siz[ch[u][1]],dp[ch[u][1]]+siz[ch[u][0]]);
	else dp[u]=max(dp[ch[u][0]],dp[ch[u][1]]);
}

int main() {
	n=read();
	k=read();
	root=1;
	++T;
	for(int i=1; i<=n; ++i) {
		a[i]=read();
		ins(a[i]);
	}
	dep[root]=B;
	dfs(root);
	printf("%d\n",dp[root]);
	return 0;
}
```


---

## 作者：SerokSSR (赞：7)

一道位运算好题

题面长得很像二分，~~不过细看就可以发现并不是~~

既然是位运算，肯定要考虑按位。

我们从高位向低位枚举，假设枚举到了第 $i$ 位

（$a_i$ 指正在处理的可乐标识的第 $i$ 位的值）

显然，如果之前存在位 $j$，使 $a_j \oplus x_j > k_j$，那么后面再怎么取也一定不合法；如果存在位 $j$ 使 $a_j \oplus x_j < k_j$，那么后面也一定合法。因此一旦出现这两种情况，都不必继续枚举了。所以当我们枚举到第 $i$ 位时，对之前的所有位，一定有 $a_j \oplus x_j = k_j$。

- 若 $k_i=1$

如果 $x_i=a_i$，那么后面不论取什么，结果一定会小于 $k$；也就是说，我们得到了一段聪明值区间，在这个区间内的都是合法的。

如果 $x_i\not=a_i$，前面的位仍然相同，需继续枚举。

- 若 $k_i=0$

如果 $x_i=a_i$，理由同上，仍需继续枚举。否则一定不合法，舍去。

最后我们要统计区间的最大重叠数量。~~当然可以用线段树~~记录时差分一下，统计时做前缀和就可以了。

注意位运算的优先级。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
int n, k, a[N], c[(1<<20)];
int main() {
	scanf("%d%d", &n, &k);
	for(int i=1; i<=n; ++i) scanf("%d", a+i);
	for(int i=1; i<=n; ++i) {
		int sum=0;
		for(int j=20; j>=0; --j) {
			if((k>>j) & 1) {
				if((a[i]>>j) & 1) {
					c[sum + (1<<j)]++;
					c[sum + (1<<j+1)]--;					
				} else {
					c[sum]++;
					c[sum + (1<<j)]--;
					sum += 1<<j;
				}
			} else {
				sum = sum + ((a[i]>>j & 1) << j);
			}
		}
	}
	int ans = c[0];
	for(int i=1; i<(1<<20); ++i) {
		c[i] += c[i-1];
		ans = max(ans, c[i]);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Aryper (赞：5)

「EZEC-4」可乐

这个题非常有意思，而且还有一些乱搞做法。

首先确定按位考虑的思路，而且从高位到低位去考虑。

假如说对于一个 $a_i$，我们将它与 $k$ 逐位比较，比较到了第 $j$ 位：

1. 如果说 $k$ 的第 $j$ 位是 1，$a_i$ 的第 $j$ 位是 1，那么显然， $x$ 的第 $j$ 位取 1 时，这一箱可乐我们一定能喝到，换句话说，只要 $x\in[tmp+2^j,tmp+2^{j+1})$，这箱可乐我们一定可以喝到（$tmp$ 是一个前提，在下面的分类讨论中会提到）。

2. 如果说 $k$ 的第 $j$ 位是 1，$a_i$ 的第 $j$ 位是 0，那么如果 $x$ 的第 $j$ 位取 0 时，这一箱可乐我们一定能喝到，换句话说，满足 $x\in[tmp,tmp+2^j)$。但如果 $x$ 的第 $j$ 位取 1 了呢？有可能在后面的位数中我们仍然可以喝到这箱可乐，所以我们假设这一位取 1，即 $tmp\leftarrow tmp+2^j$，再继续往后比较。

3. 如果说 $k$ 的第 $j$ 位是 0，$a_i$ 的第 $j$ 位是 1，那么 $x$ 的第 $j$ 位取 1 我们才有喝到这箱可乐的可能性，因此 $tmp\leftarrow tmp+2^j$，继续向后逐位比较。

4. 如果说 $k$ 的第 $j$ 位是 0，$a_i$ 的第 $j$ 位是 0，那么 $x$ 的第 $j$ 位取 0 我们才有喝到这箱可乐的可能性，$tmp$ 不需要再变动了。

那么，刚才提到的 $x$ 满足的条件我们应该如何使用？它的意思是说，处于这个区间的 $x$ 能喝到的可乐箱数加 1，是区间加法，而且最后只需要一次查询，不需要线段树或树状数组，我们可以用差分数组解决问题。

最后再将差分数组前缀和一下，我们就得到对于每个不同的 $x$ 能喝到的可乐箱数了，与 $ans$ 比较大小即可。

时间复杂度 $O(n\log k)$。

当然，还有一些神奇的做法，比如说，用 Trie 树来存储数，刚才的区间加法换为加上子树大小。本质上仍是按位比较，不过有着不同的思考方式。

---

## 作者：ignited (赞：4)

首先直接考虑能使每一个$a_i$异或后$<=k$的$x$值，$f_i$表示$x=i$的时候的答案。

将每一个$a_i$做二进制展开，得到$n$个$01$串。

枚举$i$，假设我们固定了一个$x$的前几位等于$a_i$的前面这些位，剩下$m$位随便变动，那么无论后面$m$位怎么变动，异或出来的值也不会超过$2^m-1$

所以可以找到一个最大的$m$，使得$2^m-1<=k$，假设$a_i$的从后往前第$m$位之前的数为$b_i$，所以$[b_i,b_i+2^m-1]$这个区间里的数都是符合的。

将$f[b_i,b_i+2^m-1]+1$，可以用差分解决。

所以问题就变成了异或值在$[2^m,k]$的问题，然后不断递归下去，$k-=(2^m-1),a_i$第$m+1$位取反再次执行此操作直至$k=0$。

每次枚举之后将$k$复原。

取$f$最大值输出。

---

## 作者：miao5 (赞：3)

首先枚举一遍 $a_i$ 。

对于每一个 $a_i$，与 $k$ 异或一遍，假设我们枚举到第 $j$ 位，前 $j-1$ 位异或出来的都相同：  （ $a_j$ 是 $a$ 在二进制下的第 $j$ 位，其他同理。）

-  如果 $k_j=0$ ：那么 $ans_j$ 只能等于 $a_j$ 。
-  如果 $k_j=1$ ：那么 $ans_j$ 可以有两种答案：

    -  $ans_i$ 可以等于 $a_i$，然后下一个取什么都可以。
    -  $ans_i$ 还可以等于 $a_i⊕1$，这样第 $j$ 位也符合，按照这个套路继续枚举第 $j+1$ 位。
    
处理答案即可。
    
    

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int M=1e6+10;
int c[M*2],a[M],n,k;
int s1[50],s2[50]; 
void f(int b){
	memset(s1,0,sizeof(s1));
	memset(s2,0,sizeof(s2));//初始化 
	int len1=0,len2=0,kk=k;
	while(b) s1[++len1]=b%2,b/=2;
	while(kk) s2[++len2]=kk%2,kk/=2;//处理出二进制 
	int mxl=max(len1,len2);//找最大长度 
	for(int i=1;i<=mxl/2;i++){
		swap(s1[i],s1[mxl-i+1]);
		swap(s2[i],s2[mxl-i+1]);
	}//换位，把两个二进制倒过来 
	int ans=0;
	for(int i=1;i<=mxl;i++){//求异或答案 
		if(s2[i]==0) ans=ans*2+s1[i];//如果这一位是0，加上另一个数 
		else{
			int k1=(ans*2+s1[i])*1<<(mxl-i),k2=(ans*2+s1[i]+1)<<(mxl-i);//找出两种情况
			c[k1]++;
			c[k2]--;//统计答案 
			ans=ans*2+(s1[i]^1);//处理 
		}
	}
	c[ans]++;
	c[ans+1]--;//统计答案 
}
int main(){
	cin>>n>>k;
	int maxn;
	maxn=k;
	for(int i=1;i<=n;i++) cin>>a[i];//读入 
	for(int i=1;i<=n;i++){
		f(a[i]);//扫一遍答案 
		maxn=max(maxn,a[i]);//找最大值 
	} 
	for(int i=1;i<=maxn*2;i++) c[i]+=c[i-1];//处理一个前缀和 
	int ans;
	for(int i=0;i<=maxn*2;i++) ans=max(ans,c[i]);//取最大值 
	cout<<ans;
	return 0;
}
```



---

## 作者：言琢დ (赞：2)

一道有趣的统计类题目。

首先考虑对于一个确定的 $a_i$，与 $k$：

$$\text{XOR}(a_i,x)\le k$$

满足本关系的 $x$ 一定在一些区间上。

例如 $a_i=\texttt{(\color{red}1011\color{black}00)}_2,k=\texttt{(\color{red}1011\color{black}10)}_2$。

首先对于前面的 $4$ 位，如果 $x$ 的二进制上这 $4$ 位全部取 $0$，则继续向下判断。

如果 $x$ 的二进制在某一个 bit 上取 $1$：

- $k$ 的这个 bit 取的是 $1$：（假设是第 $4$ 位）此时 $\text{XOR}(a_i,x)=\texttt{(\color{red}1010\color{black}..)}_2$，**前面的第 $4$ 位已经能使得 $\text{XOR}(a_i,x)$ 严格 $<k$，那么此时一定产生贡献。**
- $k$ 的这个 bit 取的是 $0$：（假设是第 $2$ 位）此时 $\text{XOR}(a_i,x)=\texttt{(\color{red}11\color{black}....)}_2$，前面的第 $2$ 位已经能 **使得 $\text{XOR}(a_i,x)$ 严格 $>k$**，那么此时一定 **不产生** 贡献。

再考虑对于后面没考虑到的位：前面的每一个产生贡献的 $x$ 都对应一个区间，把这个区间差分进差分数组即可。

后面没考虑的位继续考虑，每次根据 $k$ 的某个 bit 来判断 $x$ 的取法是否合法即可。

AC 代码：

```cpp
#include<cstdio>
#define Pick(tp) ((tp>>i)&1)
inline int in();
inline void wr(int);
const int N=1<<20|1;
int n,k,b[N];
inline void upd(int);
inline int mx(int,int);
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("6824.in","r",stdin);
	freopen("6824.out","w",stdout);
#endif
	n=in(),k=in();
	for(register int i=1;i<=n;++i)
		upd(in());//利用差分把第 i 个可乐的贡献算进去
	register int max=b[0];
	for(register int i=1;i<N;++i)
		max=mx(max,b[i]+=b[i-1]);
	//b 是差分数组，对 b 求前缀和即得一条序列 a[]，a[i] 表示 x=i 时有 a[i] 个可乐能喝
	wr(max),putchar('\n');//对这个 a 数组求数组内最大值即得答案
}
inline void upd(int y){
	// 如果 x XOR y 的高位为 0，k 的高位为 1
	// 显然不论后面如何，x XOR y < k。满足 x XOR y <=k，即一定可以喝
	// 如果 x XOR y 的高位为 1，k 的高位为 0
	// 显然不论后面如何，x XOR y > k。不满足 <=k，即一定不可以喝
	// 如果高位相同，还需要进一步判断，下面用 now 表示 x 目前的状态
	register int now=0;
	for(register int i=20;i>=0;--i)
		//枚举决定 now 的第 i 位
		if(Pick(y))
			//y 的高位是 1
			if(Pick(k))
			//k 的高位也是 1，那么 now 这一位取零就正好相等，取一就后面任取
				++b[now|(1<<i)],--b[now+(1<<(i+1))];
			else
			//k 的高位是 0，那么 x 这一位必须取 1 以达到相等
				now|=(1<<i);
		else
			//y 的高位是 0
			if(Pick(k))
			//k 的高位是 1，那么 x 这一位取一就正好相等，取零就后面任取
				++b[now],--b[now|=(1<<i)];
			else
			//k 的高位是 0，那么 x 这一位必须取 0 以达到相等
				;//now 不变就是取了 0 
}
inline int mx(int x,int y){
	return x>y?x:y;
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

---

## 作者：Tony2 (赞：2)

提供一种容易想到（？）的想法。

先把可乐从小到大排序，答案肯定是其中一段。

首先枚举聪明值$x$，然后贪心从高到低按位枚举。

对于每一位，设这一位为$i$。上一位已经处理到的区间是$[l,r]$。

设$p = lowerbound(a+l, a+r+1, now|(1<<i))-a;$，就是可乐的区间$[l,r]$上第一个第$i$位为1的位置，now后面解释。

如果$(k&(1 << i)) == 0$，只有$[l,pos-1]$和$[pos,r]$其中一个区间可以保留继续判定，另一个超过了$k$，判定见代码。

如果$(k&(1 << i)) == 1$，有$[l,pos-1]$和$[pos,r]$其中一个区间可以对答案造成贡献，然后抛弃；另一个区间继续进行判定，因为其中一部分会大于$k$，另一部分不会。

用了$lowerbound$，要开O2 QAQ

```cpp
#include <bits/stdc++.h>
#define R register
using namespace std;
const int N = 1e6+5;
int n, k, a[N], ans;
int read(){
	char ch=getchar();int x=0,f=1;
	while(ch<'0' || ch>'9')	{if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main(){
//	std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
//	freopen("in.txt", "r", stdin);
//	freopen("out.out", "w", stdout);
	n = read(), k = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	sort(a+1, a+1+n);
	for (R int x = 0; x <= (1<<20); x++){
		R int sum = 0, l = 1, r = n, now = 0;
		for (R int i = 20; i >= 0; i--){
			R int pos = lower_bound(a+l, a+r+1, now|(1<<i))-a;
			if (!((k>>i)&1)){
				if ((x>>i)&1) l = pos, now |= (1<<i);//1^1==0，1在右边，向右走
				else r = pos-1;//0^0==0，0在左边，向左走
			}else{
				if ((x>>i)&1) sum += r-pos+1, r = pos-1;//1^1==0，右边必然<k，计入答案，抛弃
				else sum += pos-l, l = pos, now |= (1<<i);//同理
			}//now就是从高位走过来的路
		}
		ans = max(sum, ans);
	}
	cout << ans;
	return 0;
}
```

---


# [COCI 2013/2014 #6] KOCKICE

## 题目背景

堆积木！

## 题目描述

Mirko 和 Slavko 在玩积木。他们俩都有自己的一堆砖头。一共有 $N$ 列砖头（其中 $N$ 为奇数）。

Mirko 桩的第 $i$ 列中有 $m_i$ 块砖，而 Slavko 每列有 $s_i$ 个。

他们决定创建两堆一样的砖头，这几堆的高度首先是严格下降，然后是严格上升（参见下方右图），相邻列的高度恰好相差 $1$（见图）。最低的列的左右两侧的砖头数量必须相同。

![](https://cdn.luogu.com.cn/upload/image_hosting/aeiop47b.png)

允许两种操作：

- 从某一列的顶部移除一块砖。
- 在某一列的顶部加上一块砖。

问在满足上述要求的情况下，最少要几次操作？

## 说明/提示

#### 样例 1 解释
Mirko 在其桩的第一列的顶部放置了两块砖，而 Slavko 在他桩的第三列的顶部放置了一块砖。

#### 【数据规模与约定】

- 对于 $40\%$ 的数据，满足 $1\le N\le 1000$，$0\le m_i,s_i\le 1000$。
- 对于 $100\%$ 的数据，满足 $1\le N\le 3\times 10^5$，$0\le m_i,s_i\le 10^{12}$。

#### 【说明】
**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T3 KOCKICE_。**

## 样例 #1

### 输入

```
3
1 2 3
3 2 2```

### 输出

```
3```

## 样例 #2

### 输入

```
5
2 3 0 1 4
3 3 2 3 1```

### 输出

```
10```

# 题解

## 作者：OrangeEye (赞：10)

定义一种情况的中间最低的柱子为底柱。

设答案的底柱高为 $k$ 。

若有 $i \leq k$ ，则以 $i$ 为底柱的花费肯定比以 $i-1$为底柱的花费低。

证明：

设在一个位置上的目标高度是 $a$ ，Mirko 的初始高度是 $M$ ，Slavko 的初始高度是 $S$ ；

当 $a$减一时，若： 

- $a \leq M$ 且 $a \leq S$ ，则总花费加2。

- $a \geq M$ 且 $a \geq S$ ，则总花费减2。

- 否则总花费不变。

由于 $k$ 为答案，则以 $k$ 为底柱的各个位置中，第一种情况的数量总是大于等于第二种情况的数量（否则以 $k-1$ 为底柱的花费比 $k$ 低）而在减一的过程中，第一种情况的数量只增不减，而第二种只减不增。所以减得越多，花费加得越多。

证毕。

同理，若有 $i \geq k$ ，则以 $i$ 为底柱的花费肯定比以 $i+1$ 为底柱的花费低。（~~读者自证不难~~）

所以，给定一个高度，可以知道它在答案的左边还是右边，考虑二分答案解决。

复杂度 $O(N\log_2\max(\max (m_i),\max (s_i)))$ 可过。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll l,r,a[300009],b[300009],n;
ll abs_(ll x){return (x>=0?x:-x);}
ll chk(ll t){
	ll ans=0;
	for(ll i=0;i<n;i++)ans+=abs_(t-a[i]+abs_(n/2-i));
	for(ll i=0;i<n;i++)ans+=abs_(t-b[i]+abs_(n/2-i));
	return ans;
}
void print(ll t){printf("%lld\n",chk(t));return ;}
int main(){
	scanf("%lld",&n);
	for(ll i=0;i<n;i++)scanf("%lld",a+i);
	for(ll i=0;i<n;i++)scanf("%lld",b+i);
	l=0ll;r=1000000000001ll;
	while(l<r){//二分
		ll mid=(l+r)/2;
		if(chk(mid+1)>chk(mid))r=mid;
		else l=mid+1;
	}
	print(l);
	return 0;
}
```


---

## 作者：☯☯枫☯☯ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6874)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/14940850.html)

**算法分析：二分**

提供一种基于二分的算法。

注意一下**坑点**：

- 最低那一列就是正中间那一列。
- “最低的列左右两侧的砖头数量必须相同”指的不是与中间列相邻的两列，而是**所有对应的列**。

下面来分析一下如何二分。

这里二分不直接二分答案。如果直接二分答案，并没有把原问题变成更简单的子问题。而二分的核心在于**将复杂的原问题转化为较简单的子问题。**因此，我们二分**中间列的高度**。

单调性在哪里？由于相邻的砖头高度恰相差 $1$，中间列高度确定时其他列的砖头数量也能确定。因此，若中间列高度继续增加 $1$ ，可以依此判断出总操作次数的变化情况。假设当前中间列高度为 $mid$，那么第 $i$ 列的目标高度为 $x=mid+\left \vert n/2-i+1\right \vert$。若中间列继续增加 $1$，那么将有 $res=\sum\limits_{i=1}^n (a_i \ge x)+(b_i \ge x)$ 列砖头的操作次数将减 $1$ ，$2\times n-res$ 列砖头操作次数将增加 $1$。随着 $mid$ 的增大，$res$ 呈现出单调递减的特征，符合了二分的单调性要求。当 $res \ge n$ 时，当前 $mid$ 的是一个可行解。在求出中间列的最佳高度之后，暴力计算求出答案即可。

关于时间复杂度，检查可行性为$\mathcal{O}(n)$，因此二分时间复杂度为 $\mathcal{O}(n\log_2(n))$。最后计算答案为 $\mathcal{O}(n)$。因此总体时间复杂度为 $\mathcal{O(n\log_2(n))}$。

下面给出代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define F(i,a,b) for(reg int i=a;i<=b;++i)
using namespace std;
inline ll read();
const int N=3e5+10;
int n,a[N],b[N];
ll ans,sum;
inline bool check(ll mid) {
	int res=0;
	F(i,1,n){
		ll x=mid+abs(n/2+1-i);
		res+=(a[i]>=x)+(b[i]>=x);//计算操作次数将-1的列数 
	}
	return res>=n;
}
int main() {
	n=read();
	ll l=0,r=0;
	F(i,1,n)a[i]=read(),r=max(r,(ll)a[i]);
	F(i,1,n)b[i]=read(),r=max(r,(ll)b[i]);
	while(l<=r){//二分 
		ll mid=l+r>>1ll;
		check(mid)?l=mid+1,ans=mid:r=mid-1;
	}
	F(i,1,n){//统计答案 
		ll x=ans+abs(n/2+1-i);
		sum+=abs(a[i]-x)+abs(b[i]-x);
	}
	printf("%lld",sum);
	return 0;
}
inline ll read() {
	reg ll x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1ll)+(x<<3ll)+(c^48),c=getchar();
	return x;
}
```

[AC](https://www.luogu.com.cn/record/52134693)

欢迎交流讨论，请点个赞哦~

---

## 作者：一扶苏一 (赞：4)

## P6874 [COCI2013-2014#6] KOCKICE

看到谷新加的一车题里面有一道已经通过了的，点进去以后发现是一套我审核时被毙掉的题目其中的一道，当时顺手写了（

### Analysis

首先不妨考虑我们先确定最终的砖头长什么样，然后计算出花费。

记  $\left\lfloor\frac n 2\right\rfloor = t$，当最中间一列有 $0$ 块砖时，那么显然对于第 $i$ 列，则有 $w_i = |t - i|$ 块砖。

设最终时中间的一列有 $x$ 块砖，则对于第 $i$ 列，有 $x + w_i$ 块砖，此时这一列的花费是 $|x + w_i - m_i| + |x + w_i - s_i|$。注意到 $a_i = m_i - w_i$ 和 $b_i = s_i - m_i$ 是定值，那么我们的最终花费即为 $\sum\limits_{i = 1}^n |x - a_i| + |x - b_i|$。这个式子的最小值的几何意义是数轴上有 $2n$ 个整点，选择一个整点使得这个点到其他所有点距离之和最小。

这是一个经典的结论，答案是将点按大小排序后在第 $n$ 和 $(n + 1)$ 个点之间（含端点）任选一个点即可。证明非常简单，首先将贡献分为两部分，即为选择的点左侧的点对答案的贡献和右侧的点对答案的贡献，考虑在 $n$ 和 $(n + 1)$ 之间（不含端点）的某个点，如果左移一位，那么左侧每个点的贡献 $-1$，总贡献减去 $n$，同时右侧每个点贡献 $+1$，总贡献加上 $n$，最终答案不变。而在该点在 $n$ 上或 $n$ 左侧时，如果左移一位移出 $[n, n + 1]$ 区间，那么左侧共有小于 $n$ 个点的贡献减 $1$，右侧多于 $n$ 个点的贡献 $+1$，最终答案会变大。同理可以证明在 $(n + 1)$ 或其右侧时点不能右移。

因此把 $a_i$ 和 $b_i$ 放在一起排序，取第 $n$ 大作为 $x$ 的值即可。需要注意的是，如果此时 $x \lt 0$，需要令 $x = 0$。

### Code

```cpp
namespace Fusu {

const int maxn = 300005;

int n;
ll a[maxn], b[maxn], w[maxn];
std::vector<ll> p;

void Main() {
  qr(n);
  qra(a + 1, n);
  qra(b + 1, n);
  for (int l = (n >> 1) + 1, r = l, i = 0; l; --l, ++r) {
    w[l] = w[r] = i++;
  }
  for (int i = 1; i <= n; ++i) {
    p.push_back(a[i] - w[i]);
    p.push_back(b[i] - w[i]);
  }
  std::sort(p.begin(), p.end());
  ll x = p[n];
  if (x < 0) x = 0;
  ll ans = 0;
  for (int i = 1; i <= n; ++i) {
    ans += llabs(a[i] - w[i] - x) + llabs(b[i] - w[i] - x);
  }
  qw(ans, '\n');
}

} // namespace Fusu
```



---

## 作者：mxjz666 (赞：3)

### 思路
本题可以二分中间的列的高度。

最后再暴力统计答案就好。

-------
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10;
int a[N],b[N],n;
bool check(int mid){
	int cnt=0;
	for(int i=1;i<=n;i++){
		int tmp=mid;
		tmp+=abs(n/2+1-i);
		cnt+=(a[i]>=tmp);
		cnt+=(b[i]>=tmp);
	}
	return cnt>=n;
}
signed main(){
	cin>>n;
	int l,r,ans=-1,sum=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		r=max(a[i],r);
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		r=max(b[i],r);
	}
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)==true){
			ans=mid;
			l=mid+1;
		}else{
			r=mid-1;
		}
	}
	for(int i=1;i<=n;i++){
		int tmp=ans+abs(n/2+1-i);
		sum+=abs(a[i]-tmp);
		sum+=abs(b[i]-tmp);
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：cjZYZtcl (赞：1)

## P6874 [COCI2013-2014#6] KOCKICE题解
来一发三分的题解！（PS：作者声明，此题解适用于随机数据，有Hack数据能够卡掉本做法 ~~，作者太弱勿喷~~）

不难证明，如果存在一个中间位置的值使得这个值的操作数为操作数的最小值，那么与这个值相差越大，操作数越多。

于是我们考虑去三分中间位置的值。

我们设三分出的两个值对应的操作数分别为 $x,y$，假如 $x<y$，则有以下两种情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/xr60dfj0.png)
但无论是哪种情况，最右边的区间 $[mid2,r]$ 都不可能出现操作数最小值，所以可以直接排除最右端区间。

反之，若 $x>y$，可以直接排除最左端区间。

而最后的区间里会留下两个值，求出两个值对应的操作数，取最小值即可。

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[300005], b[300005], c[300005];
inline int read(){
	int x = 0, m = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') m = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * m;
}
inline void write(int x){
	if(x < 0){
		putchar('-');
		write(-x);
		return;
	}
	if(x >= 10) write(x / 10);
	putchar(x % 10 + '0');
}
int check(int x, int n){//求操作数
	int mid = (1 + n) / 2;
	c[mid] = x;
	for(int i = mid - 1; i > 0; i--){
		c[i] = c[i + 1] + 1;
	}
	for(int i = mid + 1; i <= n; i++){
		c[i] = c[i - 1] + 1;
	}
	int sum = 0;
	for(int i = 1; i <= n; i++){
		sum += abs(c[i] - a[i]) + abs(c[i] - b[i]);
	}
	return sum;
}
signed main(){
	int n = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= n; i++) b[i] = read();
	int l = 0, r = 1000000000000;
	while(r - l >= 2){//三分
		int z = (r - l + 1) / 3;
		int mid1 = l + z - 1;
		int mid2 = mid1 + z;
		int x = check(mid1, n), y = check(mid2, n);
		if(x < y){//排除右端区间
			r = mid2 - 1;
		}
		else{//排除左端区间
			l = mid1 + 1;
		}
	}
	int x = check(l, n), y = check(r, n);//比较剩余操作数的可能性，取最小值
	int ans = min(x, y);
	write(ans);
}
```


---

## 作者：shichengrui (赞：1)

# 思路
本题暴力明显会超时，所以考虑二分优化，左边界为 $1$，右边界为 $10^{12}$，二分中间列高度，就可以对了。
# code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long l=0,r=1000000000000,a[300001],b[300001],n,w;
long long z(long long g){//中间为g的代价 
	long long s=0;
	for(long long i=0;i<n;i++){
		s+=abs(abs(w-i)-a[i]+g);
		s+=abs(abs(w-i)-b[i]+g);
	}
	return s;
}
int main(){
	cin>>n;
	w=n/2;
	for(long long i=0;i<n;i++)cin>>a[i];
	for(long long i=0;i<n;i++)cin>>b[i];
	while(l<r){//二分 
		long long mid=(l+r)/2;
		if(z(mid+1)>z(mid))r=mid;
		else l=mid+1;
	}
	cout<<z(l);
	return 0;
}
```

---

## 作者：spider_men (赞：0)

动笔算算样例可得一个性质，只要确定中间位置的数是多少，其他位置就可以直接求出。

如果我们暴枚中间的数，必然超时。

于是我们需要用[二分](https://oi-wiki.org/basic/binary/)。

如果中间位置上的数是答案，那么无论什么数，操作次数一定多于他。

所以我们只要判断关系就能判断往哪边找。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e5 + 5;
const long long MAXX = 1e14;
long long n;
long long m[N], s[N];
long long check(long long k){
	long long count = 0;
	for (long long i = 1; i <= (n >> 1) + 1; ++i) {// n >> 1相当于n / 2
		long long a = k + n / 2 + 1 - i;
		count += abs(a - m[i]) + abs(a - s[i]);
	}
	for (long long i = (n >> 1) + 2; i <= n; ++i) {
		long long b = k + i - n / 2 - 1;
		count += abs(b - m[i]) + abs(b - s[i]);
	}
	return count;
}
int main(){
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> m[i];
	}
	for (int i = 1; i <= n; ++i) {
		cin >> s[i];
	}
	long long L = 0, R = MAXX;
	while (L < R) {
		long long mid = (L + R) >> 1;
		if (check(mid) < check(mid+1)) {//如果mid+1的操作次数多于mid的，答案在左边
			R = mid;
		} else {
			L = mid + 1;
		}
	}
	cout << check(L);
	return 0;
}

```

---

## 作者：TLEWA (赞：0)

三分板子题。

感性理解发现这个东西似乎是单峰的，考虑简单证明单调性。

注意到最优解两侧的情况相似，这里仅讨论高度比最优解低的情况：

设最优解中间最低柱的高度为 $x$，因为是最优解所以 $ans_{x-1} \le ans_x$，考虑描述从 $x$ 到 $x-1$ 的增减变化，设初始高度大于目标高度的柱子数量为 $a$，小于的为 $b$，则目标高度每降低 $1$，$ans$ 都变化 $b-a$，随着目标高度的降低，$a$ 单调递增，$b$ 单调递减，则 $b-a$ 单调递减。又因为 $ans_{x-1} \le ans_x$，初始的 $b-a \le 0$，函数图像单峰。

于是我们三分中间最低柱的高度即可，时间复杂度 $O(n \log n)$。

## AC 代码


```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N=300005;

int n;
int M[N],S[N];

int check(int num) {
	int cnt=0;
	for(int i=1;i<=n;++i) cnt+=abs(M[i]-abs(i-((n+1)/2))-num)+abs(S[i]-abs(i-((n+1)/2))-num);
	return cnt;
}

signed main() {
	cin >> n;
	for(int i=1;i<=n;++i) cin >> M[i];
	for(int i=1;i<=n;++i) cin >> S[i];
	
	int l=0,r=1e12,mid1,mid2,c1,c2,ans=1e18;
	while(l<=r) {
		int mid1=(r-l+1)/3+l,mid2=r-((r-l+1)/3);
		c1=check(mid1),c2=check(mid2);
		if(c1>=c2) l=mid1+1,ans=min(ans,c2);
		else r=mid2-1,ans=min(ans,c1);
	}
	
	cout << ans;
	return 0;
}
```

---

## 作者：Emily666 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6874)


---
首先，可以发现，只要确定了中间那列砖头的高度，两边砖头的高度就都可以确定了。所以前 $40$ 分的代码，就是枚举中间砖头的高度再取 $\min$。

### $40$ 分代码（枚举）
```cpp
#include <iostream>
using namespace std;
const int N=1003;
int n,a[N],b[N];//这里打的是 40% 的数据，不用开 long long
int ans=0x3f3f3f3f;
int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<n;i++) cin>>b[i];
    for(int i=0;i<=1000;i++){
        int cc=0;//记录答案用，可以理解为 res/tot 等
        for(int j=0;j<n/2;j++) cc+=abs(i+n/2-j-a[j]);//前面的 i+n/2-j 是计算出来的该列砖块数，累加与实际砖块数之差就是当前答案，下同
        for(int j=n/2+1;j<n;j++) cc+=abs(i+j-n/2-a[j]);
        for(int j=0;j<n/2;j++) cc+=abs(i+n/2-j-b[j]);
        for(int j=n/2+1;j<n;j++) cc+=abs(i+j-n/2-b[j]);
        ans=min(ans,cc+abs(i-a[n/2])+abs(i-b[n/2]));//要把中间那列的体力加上
    }
    cout<<ans;
    return 0;
}
```


---
这段代码显然需要优化。于是我把这段代码运行样例 $2$ 时 `cc` 的变化情况输出了一下~~用来调试代码的~~：
```cpp
12
10
10
20
30
40
50
...
```
结合 `cc` 的变化可以发现：题目所求的答案就是列出的数中的最小值，在最小值的前面，最后留下来的砖头数量变少，差就会逐渐增大；最小值的后面也是同理。

于是就得到了一个单峰函数，题目也转化为了求这个单峰函数的那个“峰”（这里是最小值），然后……蒟蒻我就想到了三分。

三分的流程大概是这样的~~大佬请跳过~~：

首先，与二分类似，有一个要三分的区间，$l$ 到 $r$，找到它的两个三等分点，$mid1$ 和 $mid2$：
![](https://cdn.luogu.com.cn/upload/image_hosting/yda4cfb6.png)
如果 $mid1$ 的值大于 $mid2$ 的值，那么整个单峰函数只能是下面两种情况之一：
![](https://cdn.luogu.com.cn/upload/image_hosting/9eozw81m.png)
但无论如何，都不可能在 $mid1$ 的左边，于是，~~模仿二分，~~ 把 $l$ 移到 $mid1$ 来。如果 $mid1$ 的值小于 $mid2$ 的值也是同理，把 $r$ 移到 $mid2$ 就行了。

那如果 $mid1$ 的值等于 $mid2$ 的值呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/gpd0ssu1.png)
因为最小值两侧都是单调递增的，所以 $mid1$ 和 $mid2$ 肯定分别在最小值的两侧，让 $l$ 等于 $mid1$，$r$ 等于 $mid2$ 就行了。

最后，把暴力代码中计算 `cc` 的部分~~复制粘贴~~搬过来，三分就写完了。
### AC 代码
```cpp
#include <iostream>
using namespace std;
const int N=3e5+3;
long long n,a[N],b[N],sum;
long long Ans=0x3f3f3f3f3f3f3f3f;//long long 的最大值，可以理解为 int 的 0x3f3f3f3f
long long check(int x){//照搬暴力代码，注释见上
    long long ans=0;
    for(int j=0;j<n/2;j++) ans+=abs(x+n/2-j-a[j]);
    for(int j=n/2+1;j<n;j++) ans+=abs(x+j-n/2-a[j]);
    for(int j=0;j<n/2;j++) ans+=abs(x+n/2-j-b[j]);
    for(int j=n/2+1;j<n;j++) ans+=abs(x+j-n/2-b[j]);
    ans+=abs(x-a[n/2])+abs(x-b[n/2]);
    return ans;
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
        sum+=a[i];
    }
    for(int i=0;i<n;i++){
        cin>>b[i];
        sum+=b[i];
    }
    long long l=0,r=sum,mid1,mid2;
    while(l<r){//三分（码风奇怪，不喜勿喷）
        mid1=l+(r-l)/3;//三分点一
        mid2=l+(r-l)/3*2;//三分点二
        long long x=check(mid1),y=check(mid2);//求值
        Ans=min(Ans,min(x,y));//取 min，因为三分时必定会取到最小值，这里为了方便就在过程里直接取了，效果是一样的
        if(x<y) r=mid2;//不可能在 mid2 右边
        else if(x>y) l=mid1;//不可能在 mid1 左边
        else l=mid1,r=mid2;//两边都排除
    }
    cout<<Ans;
    return 0;
}
```

---

## 作者：Lithium_Chestnut (赞：0)

考虑二分答案，二分查找出中心柱的高度，根据依次为 $1$ 的柱子高度递减&递增规律可得到其他所有柱子的高度，二分的答案是花费最少的点。

二分的时候右边小就二分右边，左边小就二分左边。

```cpp
#include<bits/stdc++.h>
#define Std_Maker lhm
#define ll long long
using namespace std;
const int N=3e5+1;
ll n,m[N],s[N];
ll check(ll x)
{
    ll ans=0,mid=n/2+1;
    for(int i=1;i<=n;i++)
    {
        ans+=abs(abs(i-mid)+x-s[i]);
        ans+=abs(abs(i-mid)+x-m[i]);
    }
    return ans;
}
ll binary(ll l,ll r)
{
    while(l<=r)
    {
        ll mid=(l+r)>>1;
        if(check(mid)<check(mid+1)) r=mid-1;
        else l=mid+1;
    }
    return l;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>m[i];
    for(int i=1;i<=n;i++) cin>>s[i];
    cout<<check(binary(0,1e12));
    return 0;
}

```

---

## 作者：GrainRain25 (赞：0)

## 思路

考虑用二分求解。

因为当中间列确定时，根据“**相邻列的高度恰好相差 
1**”,可以计算出整列积木的高度和操作次数。因此，我们可以二分中间列的高度。

接下来考虑答案单调性。

不妨设最终答案，中间列的高度为 $a$，操作次数为 $m$，则当中间列高度为 $a+1$ 时，操作次数大于 $m$，此时砖块减少的次数必定大于砖块增加的次数。当中间列高度继续增加时，最终答案会越来越大。中间列高度减小时同理。因此我们得出结论:

- 当中间列高度大于 $a$ 时，最终答案随 $a$ 的增大而单调增。
- 当中间列高度小于 $a$ 时，最终答案随 $a$ 的增大而单调减。

因此，我们只需找到最小的 $a$，使 $a$ 的答案小于 $a+1$ 的答案，中间列高度为 $a$ 时的操作次数即为所求。

## CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=3e5+5;
int m[maxn],s[maxn],n;

int check(int x){
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=abs(x-m[i]+abs(n/2+1-i));
		ans+=abs(x-s[i]+abs(n/2+1-i));
	}
	return ans;
}

int Make(int l,int r){
	if(l>=r) return l;
	int mid=(l+r)>>1;
	if(check(mid)<check(mid+1)) return Make(l,mid);
	else return Make(mid+1,r);
}

signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&m[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&s[i]);
	printf("%lld\n",check(Make(0,1e12)));
	return 0;
} 
```

---

## 作者：crzcqh (赞：0)

## 思路


像这样的题目，如果没有较好的直接求出答案的方法，不妨考虑二分答案，二分一个满足单调性的量，因为要使答案尽可能得小，如果这个量是合法的答案，则 $r=mid$，否则 $l=mid+1$。

那么我们该怎么二分呢？我们可以确定，第 $\lceil \dfrac{n}{2} \rceil$ 列，即中间列的高度一定是最小的，并且根据题意，相临两列的差必须为 $1$，那么我们只需要知道中间列的高度，就能求出每一列要搭的高度。具体的，如果中间的高度为 $x$，则第 $i$ 列要搭 $x+|i-\lceil \dfrac{n}{2} \rceil|$ 块砖，$|i-\lceil \dfrac{n}{2} \rceil|$ 即第 $i$ 列与中间列的高度差，因为差一列就要加一块砖。

再根据题意，每次操作都是拿走一块砖或添加一块砖，也就是说第 $i$ 列要执行 $|a_i-(x+|i-\lceil \dfrac{n}{2} \rceil|)|$ 次操作，因为每次只加一块或减一块，执行的操作次数即原来高度与目标高度的差，也就是说只需要知道 $x$，我们就可以 $O(n)$ 的求出每一列要执行的操作次数。

这个时候就有二分思路了。我们可以二分中间的高度 $x$，要保证这个 $x$ 还满足单调性，即高度 $x+1$ 要用的操作数比 $x$ 多，而求出高度 $x$ 要用的操作次数也很简单，$O(n)$ 遍历（见上方）。如果满足，则往小搜，否则往大搜，到时候输出高度 $l$ 要用的次数即可。

时间复杂度 $O(n \log \max(\max(m_i),\max(s_i)))$

## CODE

```cpp
#include<bits/stdc++.h>
#define M 300007
using namespace std;
typedef long long ll;
ll n,l,r,mid;
ll m[M],s[M];
ll num(ll x){
	ll ans=0; // 要执行的操作次数和
	for(int i=1;i<=n;i++){
		ans+=abs(x-m[i]+abs(n/2+1-i)); // Mirko 第 i 列要执行的操作次数
		ans+=abs(x-s[i]+abs(n/2+1-i)); // Slavko 第 i 列要执行的操作次数
	}
	return ans;
}
bool check(ll x){
	return num(x+1)>num(x); //满足单调性
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>m[i],r=max(r,m[i]);
	for(int i=1;i<=n;i++) cin>>s[i],r=max(r,s[i]);
	while(l<r){// 二分
		mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	} 
	cout<<num(l); //注意，不要输出 l，l 是高度
	return 0;
}
```

---

## 作者：lqsy002 (赞：0)

## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P6874)。

## 解题思路

**二分**

1. 此题之所以能二分存在一个性质，如果中间位置上的数是最优解时，无论比他大还是小的数，需要的操作次数一定多于他。

2. 二分到一个数 $mid$，我们只需要判断他和 $mid+1$ 的关系，就能判断往左找还是往右找。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans,a[300010],b[300010],l,r=0x3f3f3f3f,mid;
long long check(long long k){
	long long cnt=0,x;
	for(int i=1;i<=n/2+1;i++){
		x=k+n/2+1-i;
		cnt=cnt+abs(x-a[i])+abs(x-b[i]);
	}
	for(int i=n/2+2;i<=n;i++){
		x=k+i-n/2-1;
		cnt=cnt+abs(x-a[i])+abs(x-b[i]);
	}
	return cnt;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%lld",&b[i]);
	while(l<r){
		mid=(l+r)>>1;
		if(check(mid)<check(mid+1))
			r=mid; 
		else 
			l=mid+1;
	}
	printf("%lld",check(l));
	return 0;
}
```

---


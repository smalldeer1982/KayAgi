# [COCI 2011/2012 #1] PLES

## 题目描述

舞会上有 $N$ 个男孩和 $N$ 个女孩，我们知道他们的身高。规定每个人最多只能和一个舞伴跳舞。

每个男孩要么想和比他高的女孩跳舞，要么想和比他矮的女孩跳舞。类似地，每个女孩要么想和比她高的男孩跳舞，要么想和比她矮的男孩跳舞。没有同样高的男孩和女孩想和对方跳舞。

求如果遵照每个人的意愿，最大的舞伴对数是多少。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1500 \le |A_i,B_j| \le 2500$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $110$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T4 PLES___。

## 样例 #1

### 输入

```
1
-1800
1800```

### 输出

```
0```

## 样例 #2

### 输入

```
1
1700
-1800```

### 输出

```
1```

## 样例 #3

### 输入

```
2
-1800 -2200
1900 1700```

### 输出

```
2```

# 题解

## 作者：kkxacj (赞：19)

[题目传送门](https://www.luogu.com.cn/problem/P7628)

#### 引言：

考试时排序全写的加 $n$，导致洛谷上测只有 $62$ ~~（这也能有 62）~~，写个题解纪念一下。

#### 思路

读题分析可知：

只有男孩 $a$ 想和比他高的女孩 $b$ 跳舞，女孩 $b$ 想和比她矮的男孩 $a$ 跳舞 或 女生 $a$ 想和比她高的男孩 $b$ 跳舞，男生 $b$ 想和比他矮的女孩 $a$ 跳舞，这样的两个人才会成为一对舞伴。

所以我们可以开四个数组，两个统计男生想和比他高的女孩跳舞和男孩想和比他矮的女孩跳舞的男生的身高，另外两个统计女孩想和比他高的男生跳舞和女孩想和比他矮的男孩跳舞的女生的身高，然后将四个数组排序，再比较即可。

#### 注意：没有同样高的男孩和女孩想和对方跳舞。

code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,o,oo,ooo,oooo,ans,a[1000010],b[1000010],c[1000010],d[1000010],l = 1;
bool cmp(int x,int y)
{
	return x > y;
}
int main()
{
//	freopen("dance.in","r",stdin);
//	freopen("dance.out","w",stdout);
	scanf("%d",&n);
	for(int i = 1;i <= n;i++) 
	{
		scanf("%d",&x);
		if(x < 0) a[++o] = x;
		else b[++oo] = x;
	}
	for(int i = 1;i <= n;i++) 
	{
		scanf("%d",&x);
		if(x < 0) c[++ooo] = x;
		else d[++oooo] = x;
	}
	sort(a + 1,a + 1 + o,cmp);//由于该数组统计的负数，绝对值小的反而大 ，所以应从大到小排 
	sort(c + 1,c + 1 + ooo,cmp);//同上 
	sort(b + 1,b + 1 + oo);
	sort(d + 1,d + 1 + oooo);
	for(int i = 1;i <= o;i++)
	{
		if(d[l] < -a[i] && l <= oooo)
		{
			ans++;
			l++;
		}
	}
	l = 1;
	for(int i = 1;i <= ooo;i++)
	{
		if(b[l] < -c[i] && l <= oo)
		{
			ans++;
			l++;
		}
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：Kobe_BeanBryant (赞：11)

### 题目大意：

舞会上有 $ N $ 个男孩和 $ N $ 个女孩，我们知道他们的身高。每个人只能和一个异性跳舞。

每个男孩只能和比他高或比他矮的女孩跳舞；相同的，每个女孩只能和比她高的或比她矮男孩跳舞。同样高的男孩和女孩不能一起跳舞。

### 思路：
首先将男生与女生的身高进行进行排序（若 $ H_i $ 与 $ L_i $ 都大于 $ 0 $  便从大到小的排序，否则从小到大的排序）

原因：

1:题目求最大的舞伴对数就要将一对男女生的身高差尽量小（前提满足男女生的舞伴要求）

2：为下面的寻找舞伴的函数寻找的更方便


然后套用函数  $ match $ 进行查找，边查找 $ M $ 边累加。

最后输出累加的值 $ M $。
### AC代码：
```c++
#include<bits/stdc++.h>
using namespace std;
int N,M;
vector<int> L[2];
vector<int> H[2];
void match(vector< int > &l, vector< int > &h) {
	if (l.empty() || h.empty()) return;
	for (int i = l.size() - 1, j = h.size() - 1; i >= 0; --i, --j, ++M) {
		while (j >= 0 && h[j] >= l[i])
			--j;
		if (j < 0)
			return;
	}
}
//求最大的舞伴对数个数
int main(void) {
	scanf("%d", &N);//输入男生和女生的个数
	for (int i = 0; i < 2; ++i) {
		for (int j = 0; j < N; ++j) {
			int h;
			scanf("%d", &h);
			if (h < 0)
				L[i].push_back(-h);
			else
				H[i].push_back(h);
		}
     //输入男生和女生的身高 and 是想要与比他（她）矮还是高的异性跳舞
		sort(L[i].begin(), L[i].end());//男生的升身高进行排序
		sort(H[i].begin(), H[i].end());//女生的升身高进行排序
	}
	match(L[0], H[1]);
	match(L[1], H[0]);//套用函数match
	printf("%d\n", M);
   //输出最大的舞伴对数
	return 0;
}
```

---

## 作者：Molina (赞：8)

# 题目大意
输入 $ N $ 个男生与 $ N $ 个女生的身高。规定每个人只能选择一个舞伴搭档。

如果一个男生身高为正数，则他想比他高的女孩跳舞，相反，如果为负数，则他想和比他矮的女孩跳舞。同样，女生也是。没有同样高的男孩和女孩想和对方跳舞。
求最大的舞伴对数。

# 思路
设两个数组 $ boy[i] $ 与 $ girl[j] $，先排序（见代码），然后用循环模拟，定义 $ i $ 与 $ j $，按照题目条件进行查找（见代码），每找到一组便进行标记，防止重复。答案用 $ ans $ 记录，便可以开心输出了！

# 代码来咯~:
```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+1;
int n,girl[MAXN],boy[MAXN],ans;
bool hhh(int a,int b){  
	if(a<0&&b<0) return a>b;
	return a<b;
}
bool hhhh(int a,int b){
	if(a>0&&b>0) return a<b;
	return a>b;
}
int main(){
	cin>>n;
	int i,j;
	for(i=1;i<=n;i++) cin>>boy[i];
	for(j=1;j<=n;j++) cin>>girl[j];  //输入
	sort(boy+1,boy+n+1,hhh);
	sort(girl+1,girl+n+1,hhhh); //排序
	for(i=1,j=1;i<=n&&j<=n; )
		if(boy[i]<0){
			if(girl[j]>0&&abs(boy[i])>abs(girl[j]))  
				i++,j++,ans++;  //如果满足条件，便进行标记，ans++
			else i++;
		}
		else{
			if(girl[j]<0&&abs(boy[i])<abs(girl[j]))
				i++,j++,ans++;  //同上
			else j++;
		}
	printf("%d",ans);  //开心输出！
	return 0;
}
```

---

## 作者：lianchanghua (赞：7)

题目分析：

在题目中有多个组别，还需要进行匹配，那我们想到了什么？尺取法。所以本题就可以迎刃而解了。

思路：

男女一组，每组分别有两类人：
1. 要跟比自己高的。
2. 要跟比自己矮的。

那么我们就可以分成四组，分别为：男高，男矮，女高，女矮。再用尺取法，一一匹配即可

我们可以先定义两个数组动态，$l$ 和 $h$，分别计录想和比自己矮的跳舞的和想比自己高的跳舞的，再在数组内有对男女生进行分类，再用尺取法两两匹配，用 $M$ 计数即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T;
vector<int>l[5];
vector<int>h[5];
int M;
void check(vector<int>&ll,vector<int>&hh){
	if(ll.empty()||hh.empty())	return;//退出条件。
	for(int i=ll.size()-1,j=hh.size()-1;i>=0&&j>=0;i--,j--,M++){
		//搜索两个数组，将不能匹配的卡擦掉。 
		while(hh[j]>=ll[i]){
			j--;
			if(j<0)	return;//没人了，就没法匹配了。 
		}
	} 
}
signed main(){
	cin>>T;
	for(int i=0;i<2;i++){
		for(int j=0;j<T;j++){
			int c;
			cin>>c;
			if(c<0)	l[i].push_back(-c);//想和比自己矮的 
			else	h[i].push_back(c);//想和比自己高的 
		}
		sort(l[i].begin(),l[i].end());//按个高排
		sort(h[i].begin(),h[i].end());//按个矮排 
	} 
	check(l[0],h[1]);
	check(l[1],h[0]);
	cout<<M<<"\n"; 
	return 0;
}
```

---

## 作者：HDZmessi (赞：4)

此题真难，我历时两天半才做出来。

开始的我天真的以为只需要暴力就行了，于是就用 vector 模拟，只得了九分。

暴力部分代码：

```cpp
	for(int i=0;i<a.size();i++){
		int f=abs(a[i]);
		if(a[i]>=0){
			int u=upper_bound(b.begin(),b.end(),f)-b.begin();
			if(u!=b.size()){
				ans++;
				b.erase(b.begin()+u);
				a.erase(a.begin()+i);
			}
		}
		else{
			int l=0,r=b.size()-1,mid,sum=-1;
			while(l<=r){
				mid=(l+r)>>1;
				if(b[mid]<f) sum=mid,l=mid+1;
				else r=mid-1;
			}
			if(sum!=-1){
				ans++;
				b.erase(b.begin()+sum);
				a.erase(a.begin()+i);
			}
		}
	}
	for(int i=0;i<b.size();i++){
		int f=abs(b[i]);
		if(b[i]>=0){
			int u=upper_bound(a.begin(),a.end(),f)-a.begin();
			if(u!=a.size()){
				ans++;
				a.erase(a.begin()+u);
			}
		}
		else{
			int l=0,r=b.size()-1,mid,sum=-1;
			while(l<=r){
				mid=(l+r)>>1;
				if(a[mid]<f) sum=mid,l=mid+1;
				else r=mid-1;
			}
			if(sum!=-1){
				ans++;
				a.erase(a.begin()+sum);
			}
		}
	}
	cout<<ans;
	return 0;
}
```
我甚至还用了二分查找，我以为这只是线性对数复杂度，没想到删除的复杂度是线性的，我忽略了它，所以复杂度来到了平方对数复杂度。

于是我求助了某为巨佬，他告诉我应该把男女的身高分成正数和负数，并按绝对值从小到大排序，然后先用女生的负数去找男生的正数，一旦找到小于女生身高绝对值的男生，答案就加一。男生也是一样的，总之重点在于负数身高配正数身高。因为只有一个想要和比她高的男孩跳舞的女孩和一个想要和比他矮的女孩跳舞的男孩配成一对，且男孩的身高高于女孩才行。

但要注意的是，如果大佬们用 STL 的话一定不能让剪枝的变量大小超过容器的长度，这样会访问到不存在的指针位置，导致紫色的 RE 占满你的眼睛！

AC Code:

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int N=1e5+5; //数组范围，我用的STL的容器，开数组就开这么大 
int n,ans,bn; //bn就是剪枝的变量 
vector<int> a;
vector<int> b;
vector<int> c;
vector<int> d;
bool cmp(int a,int b){
	return abs(a)<abs(b); //排序规则 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		if(x<0) c.push_back(x);
		else a.push_back(x);
	}
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		if(x<0) b.push_back(x);
		else d.push_back(x);
	}
	sort(a.begin(),a.end()); //正数正常排序 
	sort(b.begin(),b.end(),cmp);
	sort(c.begin(),c.end(),cmp); //负数特殊排序 
	sort(d.begin(),d.end());
	bn=0;
	for(int i=0;i<b.size();i++){
		int f=abs(b[i]);
		if(bn>=a.size()) break; //这点超级重要，不要这行代码RE4个点（好像是4个），用数组的好像不用这行代码 
		if(a[bn]<f){ //不能取等！！ 
			ans++;
			bn++; //重要的剪枝环节，因为这里的数组都具有单调性（就是排了序），所以如果第bn个男生的身高小于第i个女生的身高，那么要找哪一个男生的身高小于第i+1个女生的身高，这个男生的下标一定在bn后面 
		}
	}
	bn=0;
	for(int i=0;i<c.size();i++){
		int f=abs(c[i]);
		if(bn>=d.size()) break;
		if(d[bn]<f){
			ans++;
			bn++;
		}
	}
	cout<<ans;
	return 0; //华丽结束 
}
```
管理员给过谢谢啦～。

---

## 作者：_Spectator_ (赞：4)

$upd$ $on$ $\mathcal{2021.7.01}$：增添了代码注释。

~~这道绿题竟然没有一道题解？？？？？~~

[可能更好的食用体验](https://www.luogu.com.cn/blog/XT-666/solution-p7628)


------------

### ${\color{RoyalBlue}\colorbox {white}{样例解释}}$
```
2

-1800 -2200

 1900  1700
```

在这个样例中，$-1800$身高为$1800$，他要和比他矮的女生组成舞伴，所以他只能与女生中身高$1700$的组成一对舞伴。

**注意这时女生中身高$1700$的就不能与男生中身高$2200$的组成一个舞伴了** **~~(我一开始就错了这)~~**，故身高$2200$的男生只能与身高$1900$的女生组成一对舞伴。

所以答案为 $2$。


------------

### ${\color{RoyalBlue}\colorbox {white}{主要思路}}$
不难想到，正数男生只能与负数女生组成舞伴，负数男生也只能与正数女生组成舞伴。我们可以将数据分开正数与负数分别存入$4$个数组内。读入部分如下：
```cpp

cin>>n;
for(int i=1;i<=n;i++)
{
	cin>>s;
	if(s>0)ta[++tal]=s;
	else sa[++sal]=abs(s);
}
for(int i=1;i<=n;i++)
{
	cin>>s;
	if(s>0)tb[++tbl]=s;
	else sb[++sbl]=abs(s);
}
/*
变量名正确食用方式：
ta=tall_a,sa=short_a,tb=tall_b,
sb=short_b(别想歪了),l=len
*/
```
康康上面的样例，我们发现$-2200$虽然与两个女生都能组成舞伴，但如果他选择了$1700$的话那$-1800$就没有舞伴了。所以我们先给比较矮的男生安排舞伴，每次安排也要安排符合条件的最矮的女生。明白了吗？我们要将$4$个数组都排序。

由于正数男生只能与负数女生组成舞伴，负数男生也只能与正数女生组成舞伴，所以要分开两部分处理。每次用一个循环枚举男生，再定义一个变量存当前没舞伴的最矮的女生，只要符合条件就可以组成一对舞伴。具体看代码：
```cpp
int p=1;//p记当前没舞伴的最矮的女生
for(int i=1;i<=sal&&p<=tbl;i++)//循环枚举男生
	if(sa[i]>tb[p])ans++,p++;//如果符合条件，增加答案
p=1;
for(int i=1;i<=sbl&&p<=tal;i++)//同上
	if(sb[i]>ta[p])ans++,p++;
```
然后就没有然后了。

------------

### ${\color{RoyalBlue}\colorbox {white}{完整代码}}$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,tal,sal,tbl,sbl,ans;
int ta[100005],sa[100005],tb[100005],sb[100005],s;
#error\
禁止抄题解
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        if(s>0)ta[++tal]=s;
        else sa[++sal]=abs(s);
    }
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        if(s>0)tb[++tbl]=s;
        else sb[++sbl]=abs(s);
    }
    sort(ta+1,ta+1+tal);
    sort(sa+1,sa+1+sal);
    sort(tb+1,tb+1+tbl);
    sort(sb+1,sb+1+sbl);
    int p=1;//p记当前没舞伴的最矮的女生
    for(int i=1;i<=sal&&p<=tbl;i++)//循环枚举男生
        if(sa[i]>tb[p])ans++,p++;//如果符合条件，增加答案
    p=1;
    for(int i=1;i<=sbl&&p<=tal;i++)//同上
        if(sb[i]>ta[p])ans++,p++;
    cout<<ans;
    return 0;
}
```
**xt__温馨提示：**

**${\color{brown}\colorbox{White}{题解千万条，理解第一条。直接粘题解，棕名两行泪。}} $**

---

## 作者：Supor__Shoep (赞：4)

解析一下题意，我们不难知道肯定需要将男生，女生各分成两类，一类表示**期望为比自己高**的异性，另一类表示**期望为比自己矮**的异性。这里可以使用四个数组储存。储存完之后，我们还可以发现统计答案时，考虑两种情况，一种是矮男性和高女性匹配，一种是高男性和矮女性匹配。

分完之后，考虑进行**贪心**。假设一种情况，就是**矮女性和高男性**进行相互匹配的时候，如果**最高的男性**和**最矮的女性**进行匹配，那么就会使得**最矮的男性无法匹配到**比自己矮的女性，导致最终的匹配数量会更低（说实话，挺像那个什么田忌赛马的）。于是乎我们得到贪心思想：矮的和矮的相互匹配，高的和高的相互匹配。

我们可以想到将每个类型进行**从小到大**排序，然后从小到大枚举，挨个挨个地匹配。当然匹配我们可以用指针进行移动。比如我们求上文情况的时候，我们可以枚举每一个**高男性**，然后用指针指向当前剩下的**未匹配**的**最矮女性**，如果当前指针指向的女生高于当前男生，那就不匹配，接着枚举下一个男性。

注意，如果指针遍历完了所有的女性，那么就没有女性可以与之匹配了，就直接跳出循环。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int n;
int s1[MAXN],s2[MAXN],s3[MAXN],s4[MAXN];//分类储存 
int cnt1,cnt2,cnt3,cnt4;
int main()
{
	cin>>n;
	//分类储存 
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x<0)	s1[++cnt1]=-x;//这里一定要变成正数，才能比较 
		else	s2[++cnt2]=x;
	}
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x<0)	s3[++cnt3]=-x;
		else	s4[++cnt4]=x;
	}
	sort(s1+1,s1+cnt1+1),sort(s2+1,s2+cnt2+1);
	sort(s3+1,s3+cnt3+1),sort(s4+1,s4+cnt4+1);//贪心：从小到大匹配 
	int res=0;
	int t=1;//指针 
	for(int i=1;i<=cnt1;i++)
	{
		if(t>cnt4)	break;//遍历完了所有的异性，直接跳出循环 
		if(s4[t]<s1[i])	res++,t++;//满足条件就匹配 
	}
	t=1;//另一种情况进行相同的方法，指针重新初始化 
	for(int i=1;i<=cnt3;i++)
	{
		if(t>cnt2)	break;
		if(s2[t]<s3[i])	res++,t++;
	}
	cout<<res;
	return 0;
}
```

---

## 作者：EatBread (赞：3)

题目简述
 
舞会上有 $N$ 个男孩和 $N$ 个女孩，我们知道他们的身高。规定每个人最多只能和一个舞伴跳舞。

每个男孩要么想和比他高的女孩跳舞，要么想和比他矮的女孩跳舞。类似地，每个女孩要么想和比她高的男孩跳舞，要么想和比她矮的男孩跳舞。没有同样高的男孩和女孩想和对方跳舞。

### 怎样贪心

既然规定要么和比他矮的人跳舞，要么和比他高的人跳舞
那么我们可以想到：如果一个人想跟比他矮的人跳舞，那么能和他跳舞的人一定想和比他高的人跳舞。反之，如果一个人想跟比他高的人跳舞，那么能和他跳舞的人一定想和比他矮的人跳舞。

所以我们可以将男生中想和比他高的人跳舞的人与女生中想和比他矮的人跳舞的人分为一个整体。

再将女生中想和比他高的人跳舞的人与男生中想和比他矮的人跳舞的人分为一个整体。

但我们发现 $1≤N≤100000$ 如果直接暴枚会超时，所以我想到~~想了好久~~：可以先将统计出来的四类数全部排序，然后比如：

男生中想和比他高的人跳舞 $a_i$ $1800$ $1500$ $1300$。

女生中想和比他矮的人跳舞 $b_i$ $1900$ $1600$ $1200$。

排完序男生 $1300$ $1500$ $1800$。

排完序女生 $1200$ $1600$ $1900$。

再定一个变量$x=1$，与一个$y=1$ 。

如果$b_x$大于$a_y$则可以跳舞$ans$++ $x$++ $y$++。

否则$y$++，因为排过序，$a_{x+1}$绝对比$a_x$大，所以可以节省不少时间。

 

### 代码

 首先将各类人分开:
``` cpp
    cin>>n;
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)nx[++d]=abs(s);
        else nd[++d2]=s;}
    sort(nx+1,nx+1+d);
    sort(nd+1,nd+1+d2);
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)ux[++d3]=abs(s);
	else ud[++d4]=s;}
    sort(ux+1,ux+1+d3);
    sort(ud+1,ud+1+d4);
```
再判断:
```cpp
    x=1,y=1;
    while(x<=d&&y<=d4)
    {
	if(nx[x]>ud[y])ans++,x++,y++;
	else x++;
    }
    x=1,y=1;
    while(x<=d3&&y<=d2)
    {
	if(ux[x]>nd[y])ans++,x++,y++;
	else x++;
    }
```
合起来程序为:
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,nd[100005],nx[100005],ud[100005],ux[100005];

int s,d,d2,x,y,d3,d4,ans;

int main()
{

    cin>>n;
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)nx[++d]=abs(s);
        else nd[++d2]=s;}
    sort(nx+1,nx+1+d);
    sort(nd+1,nd+1+d2);
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)ux[++d3]=abs(s);
	else ud[++d4]=s;}
    sort(ux+1,ux+1+d3);
    sort(ud+1,ud+1+d4);
    x=1,y=1;
    while(x<=d&&y<=d4)
    {
        if(nx[x]>ud[y])ans++,x++,y++;
	else x++;
    }
    x=1,y=1;
    while(x<=d3&&y<=d2)
    {
        if(ux[x]>nd[y])ans++,x++,y++;
        else x++;
    }
    cout<<ans;
    return 0;
}
```


 



---

## 作者：WIGYF (赞：3)

### 思路
想跟高的异性跳舞，那么与其跳的人必须满足两点:

一是比其高。

二是想和矮的异性跳。

对于想和比其矮的人跳舞的人，那么与他跳的人必须满足两点:

一是比其矮。

二是想和高的异性跳。

那么我们可以存下每个性别想和高的人跳的人和想和矮的人跳的人分开存，然后去做匹配。

但这样模拟是肯定会超时的，怎么办呢？贪心去直接找最优解。

### 贪心
我们可以发现对于一个女生，当她可以被一个比她矮或高的男生匹配时

比那个男生更矮或高的男生也一定可以匹配她，

可是，比那个男生还要矮或高的男生，他的取值范围会原来的那个人更大，

也就是说可以配他的人更多，那么就后给他分配 ~~配偶~~ 舞伴。

由此，最矮且要和高的人跳的人与最高且要和矮的人跳的人可以匹配的人最多，

反之最少，那么先给少的分，毕竟当可以匹配多的人匹配到后，其他人可以匹配到的人就会减少，符合条件多的少一个无碍，符合条件少的少一个可就无了。

就像这样
```
1700 1600
-1800 -1601
```
1700 的人可以匹配到 -1800 ，1600 的人可以匹配 -1800 或 -1601
当 1600 配了 -1800 时，1700 就孤寡了，所以，先给可怜人分配

### 代码
我用的桶排，因为 $A_i$ 与 $B_i$ 减了 1500 以后只有 1000 了用桶排不比四个快排快？~~最优解~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,na[1005],nb[1005],va[1005],vb[1005],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1,w; i<=n; ++i) scanf("%d",&w),(w>0?++na[w-1500]:++nb[-w-1500]);
	for(int i=1,w; i<=n; ++i) scanf("%d",&w),(w>0?++va[w-1500]:++vb[-w-1500]);
	int x=0,y=1;
	while(1)
	{
		while(na[x]==0 && x<=1000) ++x,y=x+1;
		while(vb[y]==0 && y<=1000) ++y;
		if(x>1000 || y>1000) break;
		--na[x],--vb[y],++ans;
		
	}
	x=1000;y=999;
	while(1)
	{
		while(nb[x]==0 && x>=0) --x,y=x-1;
		while(va[y]==0 && y>=0) --y;
		if(x<0 || y<0) break;
		--nb[x],--va[y],++ans;
	}
	printf("%d",ans);
	return 0;
}

```


---

## 作者：_Above_the_clouds_ (赞：2)

# 思路：
输入时记录 $a_i$ 和 $b_i$ 的值，绝对值和正负，便于后续计算。先排序，$a_i$ 如果为负数，从大到小排序；否则，从小到大排序。因为每个男孩和比他高或低的女孩跳舞，每个女孩和比他低或高的男孩跳舞，所以 $b$ 数组的排序与 $a$ 数组相反。定义 $i$ 和 $j$ 分别表示第 $i$ 个男孩，第 $j$ 个女孩，如果第 $i$ 个男孩想和比他矮的女孩跳舞，第 $j$ 个女孩想和比他高的男孩跳舞，且男孩比女孩高，舞伴对数就加一，$i$ 和 $j$ 也随之加一；否则，这个男孩无法和其他任何女孩跳舞，则让下一个男孩去选；另一种情况则是相反的。最后输出即可。

# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans;
struct node {
	bool op;//正负
	int val, abss;//值和绝对值
} a[100005], b[100005];
bool cmp1(node a, node b) {
	if (!a.op && !b.op)
		return a.val > b.val;//为负数从大到小排序
	return a.val < b.val;//否则从小到大排序
}
bool cmp2(node a, node b) {
	if (a.op && b.op)
		return a.val < b.val;//相反
	return a.val > b.val;
}
int main() {
	cin >> n;//输入
	for (int i = 1; i <= n; i++) {
		cin >> a[i].val;
		a[i].abss = abs(a[i].val);
		if (a[i].val > 0)
			a[i].op = 1;
	}
	for (int i = 1; i <= n; i++) {
		cin >> b[i].val;
		b[i].abss = abs(b[i].val);
		if (b[i].val > 0)
			b[i].op = 1;
	}
	sort(a + 1, a + n + 1, cmp1);//排序
	sort(b + 1, b + n + 1, cmp2);
	for (int i = 1, j = 1; i <= n && j <= n; ) {
		if (!a[i].op) {//第i个男孩高，第j个女孩矮
			if (b[j].op && a[i].abss > b[j].abss) ans++, j++;//舞伴对数加一
			i++;
		} else {//相反
			if (!b[j].op && a[i].abss < b[j].abss) ans++, i++;
			j++;
		}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：whx2009 (赞：2)

* [传送门](https://www.luogu.com.cn/problem/P7628)
## 题目思路：
我们可以把男女生的身高牌排一下序，然后把身高相近，并且分别想要的异性身高要求相反的组在一起，这样既可以满足这两人的需要，又可以不打扰后面人的选择（因为若果两个人不是最相近的，就有可能发生后面的人本来可以找到舞伴，可无法选择的情况），而如果没有找到，这个人就没有舞伴，直接跳到下一个人。这样写就可以写出一个暴力的程序，因为他的数据没有特别大，所以这样去扫一遍不会超时。
## 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,g[1000005],b[1000005],ans;//n见题目，c数组记录女生身高，b数组男生的身高的纪录，ans记录答案 
bool cmp1(int a,int b){
	if(a<0&&b<0) return a>b;//负数时系统直接排会错，所以加一个 
	return a<b;// 正数时从小到大
}
bool cmp2(int a,int b){
	if(a>0&&b>0) return a<b;
	return a>b;//负数时系统直接排会错，所以加一个 
}
int main()
{
	scanf("%d",&n);//输入总共的男女生人数 
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=n;i++) scanf("%d",&g[i]);
	sort(b+1,b+n+1,cmp1);//从小到大排序男生人数 
	sort(g+1,g+n+1,cmp2);//从小到大排序女生人数 
	for(int i=1,j=1;i<=n&&j<=n;)
	{
		if(b[i]<0)//想找一个比自己低的女生 
		{
			if(g[j]>0&&abs(b[i])>abs(g[j]))//如果有这个人，答案加一个 
				i++,j++,ans++;//男生下一个，女生下一个 （已有了舞伴） 
			else
			 i++;
		}
		else//想找一个比自己高的女生 
		{
			for(;j<=n;j++)
			  if(g[j]<0&&abs(b[i])<abs(g[j]))//如果有这个人，答案加一个
			 {
				i++,j++,ans++;
				break;
			 }
		}
	}
	printf("%d",ans);//答案输出 
	return 0;//完结撒花 
}
```
* 请勿抄袭

---

## 作者：Sirkey (赞：2)

考试考到了，我完全没有想到会考贪心。

既然是贪心，我们就来分析一下吧。

我们要确定每一个人的要求，那么我们就需要安装身高排序。显然，我们要判断一下： ` if(a>0 && b>0) ` 

拍好序之后，我们就可以去找一个和他匹配的人。

这里就用到了贪心思想：如果找到一个符合条件的人，那么我们就可以 $ans$ 加一下，男生和女生都去寻找下一个。

如果没找到呢？

分类讨论一下，如果男生要找一个比自己矮的女生，如果当前查找到的女生不符合了，是不是没有必要去查找这一个男生的配对了呢？

答案是是的。显然，我们按照身高排好的序，如果这个女生都不符合了那么下一个女生就算符合，那么也可以从其他男生中找到合适的。

另外，如果男生要找一个比自己高的女生，如果当前查找到的女生不符合了，是不是没有必要去查找这一个女生的配对了呢？

答案是是的。和上述的一样。

综上：我们不要找比自己矮的那一个人。

按照这样的贪心，我们可写出如下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MX=1e6+10;
int n,boy[MX],girl[MX],ans;
bool cmp1(int a,int b) {
	if(a<0 && b<0) return a>b;
	return a<b;
}
bool cmp2(int a,int b) {
	if(a>0 && b>0) return a<b;
	return a>b;
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) cin>>boy[i];
	for(int i=1; i<=n; i++) cin>>girl[i];
	sort(boy+1,boy+n+1,cmp1);
	sort(girl+1,girl+n+1,cmp2);
	for(int i=1,j=1; i<=n && j<=n;) {
		if(boy[i]<0) {
			if(girl[j]>0 && abs(boy[i])>abs(girl[j]))
				i++,j++,ans++;
			else i++;
		} else {
			if(girl[j]<0 && abs(boy[i])<abs(girl[j]))
				i++,j++,ans++;
			else j++;
		}
	}
	cout<<ans;
	return 0;
}
```
——end——

---

## 作者：MornStar (赞：1)

# P7628 [COCI2011-2012#1] PLES

贪心。

按男女正负分成四部分排序。

遍历男的。

如果他要找比自己高的，就删除比他高的要找比自己矮的人的第一个女生，答案加一。

如果他要找一个比自己矮的，就删除最矮的要找比自己高的人的那个女生。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>v[4];
long long n,ans;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1,a;i<=n;i++){
		cin>>a;
		if(a>0) v[0].push_back(a);
		else    v[1].push_back(-a);
	}
	for(int i=1,a;i<=n;i++){
		cin>>a;
		if(a>0) v[2].push_back(a);
		else    v[3].push_back(-a);
	}
	sort(v[0].begin(),v[0].end());
	sort(v[1].begin(),v[1].end());
	sort(v[2].begin(),v[2].end());
	sort(v[3].begin(),v[3].end());
	for(int i=0;i<v[0].size();i++){
		int now=v[0][i];
		int pos=upper_bound(v[3].begin(),v[3].end(),now)-v[3].begin();
		if(pos<(v[3].size())&&v[3][pos]>now)    v[3].erase(v[3].begin()+pos),ans++;
	}
	for(int i=0;i<v[1].size();i++){
		int now=v[1][i];
		if(v[2].size()>0&&v[2][0]<now)    v[2].erase(v[2].begin()),ans++;
	}
	cout<<ans<<"\n";
}
```

---

## 作者：封禁用户 (赞：1)

## 小贪心  
因为男生和女生都有正有负，所以拿 $4$ 个数组分别存男生正、负和女生的正、负即可。    
然后把绝对值排序，最后按照题目描述统计即可。   
附：记得开一点优化（不要问我怎么知道的）
### AC code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans,a,t,t1,t2,t3;
long long b[100005],g[100005],b1[100005],g1[100005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	t=t1=t2=t3=1; 
	for(int i = 1;i <= n;i++){
		cin>>a;
		if(a>0){
			b[t]=a;
			t++;
		}
		else{
			b1[t1]=abs(a);
			t1++;
		}
	}
	for(int i=1;i<=n;i++){
		cin>>a;
		if(a>0){
			g[t2]=a;
			t2++;
		}
		else{
			g1[t3]=abs(a);
			t3++;
		}
	}
	sort(b,b+t);
	sort(b1,b1+t1);
	sort(g,g+t2);
	sort(g1,g1 + t3);
	for(int i=1,j=1;i<t&&j<t3;){
		if(b[i]<g1[j]){
			i++;
			j++;
			ans++;
		}
		else j++;
	}
	for(int i=1,j=1;i<t1&&j<t2;) {
		if(b1[i]>g[j]){
			i++;
			j++;
			ans++;
		}
		else i++;
	}
	cout<<ans;
	return 0;
}
```


---


# 「C.E.L.U-03」重构

## 题目背景

罗司机最近发现服务器运行速度很慢，于是他准备重构整个服务器的网络以提升效率。

## 题目描述

罗司机有 $n$ 台服务器，每个服务器有一个繁忙度 $v_i$。罗司机将用 $n-1$ 条网络将它们连接在一起，于是每台服务器有一个连接网络数量 $d_i$。这个服务器网络运行的总时间是 $\sum\limits_{i=1}^nd_i^2v_i$。请你最小化这个值。

## 说明/提示

**样例解释：**  
连接 $1-2,1-4,2-3$ 三条边，度数分别为 $2,2,1,1$。

|数据编号|$n$|特殊性质|
|:-:|:-:|:-:|
|$1$|$\le5$|无|
|$2\sim 3$|$\le300$|无|
|$4\sim 5$|$\le3\times10^3$|无|
|$6$|$\le3\times10^4$|所有 $v_i$ 相等|
|$7\sim 8$|$\le3\times10^4$|无|
|$9\sim 10$|$\le3\times10^5$|无|  

对于 $100\%$ 的数据，$1\leq n\le3\times10^5,1\leq v_i\le10^3$。

## 样例 #1

### 输入

```
4
2 3 4 4```

### 输出

```
28```

# 题解

## 作者：abruce (赞：12)

### 10pts  
你爆搜出这棵树应该都可以过。  
### 30pts  
由 prufer 序列我们得知，对于一个度数的序列 $d$，如果 $\forall 1\le d_i<n,\sum d_i=2n-2$。那么就一定可以生成至少一棵树。  
所以我们只需要构造出合法的 $d$ 序列，就可以求得最大值。  
于是我们可以写出一个 $O(n^3)$ 的 dp：设 $f_{i,j}$ 为前 $i$ 个点放了 $j$ 的度数的最小代价。dp 转移方程：$f_{i,j}=\min\limits_{k=i-1}^{j-1}f_{i-1,k}+(j-k)^2v_i$。  
### 50pts  
对上面那个式子进行斜率优化。  
## 100pts  
$O(n^2)$ 状态数的 dp 很明显无法支持这个数据范围，我们考虑能否贪心。答案是可以的。  
首先我们对于每个点先放一个度数，消除 $\forall 1\le d_i<n,\sum d_i=2n-2$ 的限制。然后把 $((d_i+1)^2-d_i^2)v_i$ 当成费用丢进堆里，一直选，每一次将选出来的 $d_i$ 加 $1$，更新贡献，选 $n-1$ 次就可以。  
一个口胡的证明：如果当前你选了一个更劣的解，它解锁出来的一定也是更劣的解，所以不如就选当前最优解。  
代码很好实现。  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=3e5+5;
struct que {
	int w,v;
	que(int W,int V) {
		w=W,v=V;
	}
	friend bool operator<(que a,que b) {
		return (2*a.w+1)*a.v>(2*b.w+1)*b.v;//按照增加的费用排序
	}
};
int n,v[maxn];
ll ans;
priority_queue<que> q;
int main() {
	scanf("%d",&n);
	for(register int i=1; i<=n; i++)scanf("%d",&v[i]),ans+=v[i],q.push(que(1,v[i]));
	for(register int i=1; i<n-1; i++) {
		que u=q.top();
		q.pop();
		ans+=(2*u.w+1)*u.v;
		if(u.w<n-1)q.push(que(u.w+1,u.v));
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：_determination_ (赞：4)

注意到树有这样的性质：

- 每个点的度数至少为 $1$。
- 每个点的度数和为 $2(n-1)$。

于是我们可以给每个点 $1$ 的度数，然后分配剩下的 $(n-2)$ 个度数。

考虑使一个点度数增加 $1$ 产生的代价，设原来的度数为 $d$，繁忙度为 $v$，产生的代价就是 $(d+1)^2 v-d^2v$。

我们要让总代价最少，就是让每次的贡献都最少。证明挺简单的。然后每次分配度数的操作用优先队列维护一下即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
int n,ans;
int a[200010];
struct node{
	int x,ds;
	bool operator <(const node &y)const{
		return (-ds*ds+(ds+1)*(ds+1))*a[x]>(-y.ds*y.ds+(y.ds+1)*(y.ds+1))*a[y.x];
	}
};
priority_queue<node>q;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for ( int i = 1 ; i <= n ; i++ )
	{
		cin >> a[i];
		ans+=a[i];
		q.push({i,1});
	}
	int cnt=n-2;
	while(cnt--)
	{
		int x=q.top().x,ds=q.top().ds;
		q.pop();
		ans+=(-ds*ds+(ds+1)*(ds+1))*a[x];
		q.push({x,ds+1});
	}
	cout << ans;
	return 0;
}
```

---

## 作者：moosssi (赞：4)

首先，题目要求连 $n-1$ 条边，那么每个点的 $d_i$ 就至少为一 ，每连一条边 $d_i$ 和会增加二，则总和就为 $2n-2$ ，减去每个点的，剩下的 $d_i$ 就为 $n-2$ 。

我们不用去考虑树的形态，只用去考虑如何分配剩下的 $d_i$ 即可。

这里我就使用了优先队列，运用贪心思想每次取出 $d_i+1$ 影响最小的点，统计答案后把它的 $d_i+1$ 再加入队列，执行 $n-2$ 这个过程就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5;
int n,v[N],ans,d[N];
struct nod{
	int w,id;
	bool operator < (const nod t) const{
		return w>t.w;
	}
}p[N];
priority_queue<nod>q;
int get(int x){
	return v[x]*(2*d[x]+1);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&v[i]);
		ans+=v[i];
		d[i]=1;
		p[i].id=i;
		p[i].w=get(i);
		q.push(p[i]);
	}
	for(int i=1;i<=n-2;i++){
		nod temp=q.top();
		q.pop();
		ans+=temp.w;
		d[temp.id]++;
		p[temp.id].w=get(temp.id);
		q.push(p[temp.id]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：xhxxwcr (赞：2)

~~话说这道题为什么我会卡了一个小时？~~

## 贪心
标签都告诉你贪心了，~~你不贪留着过年吗？~~

那么，怎么贪呢？

既然每个电缆的网速是 $d_i^2 \cdot v_i$，那么，当我 $v_i$ 越大时，$d_i$ 越小更优。

那么首先，我们需要给 $v_i$ 排序，让 $v_i$ 从小到大排序。

然后根据树的特性会发现，$\sum d_i = 2n - 2$，且每个点都至少有 $v_i$ 的贡献，所以我们只需要最小化剩下的 $n - 2$ 即可。

如何最小化？使用优先队列比较 $((x_{cnt} + 1) \times (x_{cnt} + 1) - x_{cnt} \times x_{cnt}) \times x_{num} <((y_{cnt} + 1) \times (y_{cnt} + 1) - y_{cnt} \times y_{cnt}) \times y_{num}$，其中 $cnt$ 为使用次数，$num$ 为 $v_i$。

为什么要怎么写？

因为我们每次的 $d_i$ 都需要平方，若需要相加，加的值应为 $now_{d_i} ^ 2 - last_{d_i} ^ 2$，读者自证不难。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int v;
struct node{
    int cnt,num;
    bool operator <(const node&x) const{
        return ((x.cnt + 1) * (x.cnt + 1) - x.cnt * x.cnt) * x.num < ((cnt + 1) * (cnt + 1) - cnt * cnt) * num;
    }
};
priority_queue<node> q;
int main(){
    int n;
    cin >> n;
    int ans = 0;
    for(int i = 1;i <= n;i++){
        cin >> v;
        q.push((node){1,v});
        ans += v;
    }
    for(int i = 1;i <= n - 2;i++){
        int x = q.top().num,cnt = q.top().cnt;
        q.pop();
        ans += ((cnt + 1) *(cnt + 1) - cnt * cnt) * x;
        q.push((node){cnt + 1,x});
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：_Weslie_ (赞：2)

双倍经验：ABC359F。

### Idea

定义一个长度为 $n-2$ 的序列叫 prufer 序列。

这个序列的求法是：

- 选择一个树上面的编号最小的叶子节点删除。
- 将这个节点所连的边的另一端的点加入到序列中。

显而易见的有一个结论：一个点的度数是它的编号在序列中的出现次数加 $1$。

为什么？因为这个点在序列中出现一次，就说明它和一个叶子节点有连边。

如果它最后被删除了，它当时一定只连一条边。这一条边不会让它加入序列，需要额外计算。

显而易见删完之后只会存在 $2$ 个点和 $1$ 条边。如果它最后被留下了，它一定是这条边两个端点之一。

上述结论现在已证毕。

通过这个性质，每个点至少连一条边，所以答案初始值必须是 $\sum a_i$。

接下来我们枚举给每个点的度数加 $1$。因为每加 $1$ 就需要消耗序列的一个位置，所以最多加 $n-2$ 次。

$d_i$ 为点 $i$ 的度数，如果度数加 $1$，则答案会加 $(d_i+1)^2-d_i^2$。

化简一下可以得到 $2\times d_i+1$。设这个值为 $w$。

可以看到当 $d_i$ 取正整数时，它是一个公差为 $2$ 的等差数列。初始当 $d_i=1$ 时，它的值为 $3$。

用一个优先队列维护 $w\times a_i$ 的值，每次取出这个值，都要把 $(w+2)\times a_i$ 加进去。即把度数再加 $1$ 产生的答案重新加入。

这是一个贪心。下面给出正确性证明：

如果我们选择了一个比较劣的答案，它所能到达的状态只会更劣。

即如果 $w\times a_j$ 劣，则 $(w+2)\times a_j$ 只会更劣。

所以这道题就解完了。

### Code
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
priority_queue<pair<int,int> >q;
int n;
int a[300005];
int ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)ans+=a[i];
	for(int i=1;i<=n;i++)q.push({-3*a[i],i});
	for(int i=1;i<=n-2;i++){
		pair<int,int >t=q.top();q.pop();
		ans-=t.first;
		q.push({(t.first-2*a[t.second]),t.second});
	}
	cout<<ans;
	return 0;
}
```

### Tips

- 本题答案可能爆 `int`。
- 优先队列默认是大根堆，但我们要求最小的。可以写小根堆，当然也可以把新增的答案当成负数算进去。
- 要维护 $i$ 的值，否则我们新算贡献可能不很好算。所以优先队列要用 pair 存储。
- pair 是自带排序的，先比较第一个再比较第二个，所以不用重载运算符。

---

## 作者：heyZZZ (赞：1)

思路：

注意到树有这样的性质：每个点的度数和为 $2(n−1)$。

于是我们给每个点 $1$ 的度数，然后分配剩下的 $2(n-1)-n=n-2$ 个数。

之后用贪心算法，对当前最优的点进行操作，对答案的为 $a(2d+1)$。

维护一个优先队列，存入 $a(2d+1)$。

每次取出堆顶，最后将每一个点的累加即可。

代码楼上楼下都已经写的很明白了，我就不赘述了。

---

## 作者：Crazyouth (赞：1)

## 分析

通过读题发现树的形态不重要，所以考虑如何分配这 $n-2$ 个度数。如果我们给一个度数为 $d$，繁忙度为 $v$ 的节点增加一个连接，造成的是总权值增加 $(d+1)^2\times v-d^2\times v=(2d+1)\times v$，所以我们只需要按照 $(2d+1)\times v$ 对当前网络的情况进行排序，然后增加 $n-2$ 次 $d$ 就可以通过。这可以用优先队列实现。实现时，如果某次一个节点被连了 $n$ 条边，那么它将不能回到优先队列里。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
struct node
{
	int deg,a,idx;
	bool operator>(const node &x)const
	{
		return a*(2*deg+1)>x.a*(2*x.deg+1);
	}
};
priority_queue<node,vector<node>,greater<node>> q;
int a[300010],fnd[300010];
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],q.push({1,a[i],i}),fnd[i]=1;
	for(int i=1;i<=n-2;i++)
	{
		node fr=q.top();
		q.pop();
		fnd[fr.idx]++;
		fr.deg++;
		if(fnd[fr.idx]<n)
		{
			q.push(fr);
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++) ans+=fnd[i]*fnd[i]*a[i];
	cout<<ans;
}

---

## 作者：Genius_Star (赞：1)

### 思路：

注意到一个性质：

- 若 $n$ 个点的度数都不小于 $1$，且度数和为 $2(n-1)$，必能构成一颗树。

证明：

- 考虑数学归纳法，若 $n-1$ 个点可以构造成树，去推 $n$ 个点也可以构造成树。

- 那么根据抽屉原理，初始必存在一个点 $u$，满足 $d_u=1$。

- 若删去这个点和连向这个点的边时，点数变为 $n-1$，总度数和会变为 $2(n-2)$。

- 则删去 $u$ 之后原图会构成一棵树，那么加上 $u$ 也不会出现环，故这 $n$ 个点绝对可以构成一棵树。

那么我们初始可以钦定每个点度数为 $1$，然后每次需要给可重复的点的度数增加 $1$，进行 $2(n-1) - n$ 次。

为了保证 $\sum d_i^2v_i$ 最小，每次我们应该选择增量最小的点进行增量，对于点 $i$ 的增量为：

$$a_i((d_i+1)^2 - d_i^2) = a_i \times (2d_i + 1)$$

故我们维护一个优先队列，每次将增量最小的点取出更新答案，然后将这个点新的增量加入优先队列。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
mt19937 R(time(0));
const ll N=3e5+10; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,ans;
ll a[N],d[N];
priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> Q;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		d[i]=1;
		ans+=a[i];
		Q.push({(2*d[i]+1)*a[i],i});
//		cerr<<((d[i]+1)*(d[i]+1)-d[i]*d[i])*a[i]<<'\n';
	}
	for(int i=n+1;i<=2*(n-1);i++){
		ll u=Q.top().second,w=Q.top().first;
		Q.pop();
		ans+=w;
		d[u]++;
//		cerr<<((d[u]+1)*(d[u]+1)-d[u]*d[u])*a[u]<<'\n';
		Q.push({(2*d[u]+1)*a[u],u});
	}
	write(ans);
	return 0;
}
```

---

## 作者：Prean (赞：1)

给出一种新的理解方式，本质上和正解是一致的。

首先我们现在已经有了一个森林，我们现在要给他加一条边，加哪一条边是最优的呢？

假设加的边是 $ (u,v) $，那么 $ ((d[u]+1)^2-d[u]^2) \times val[u]+((d[v]+1)^2-d[v]^2) \times val[v] $ 一定是最小的，也就是两个点的 $ (2 \times d[u]+1) \times val[u] $ 分别是整个集合中的最小值和次小值，且不连通。

于是我们对每个联通块分别开一个堆，再对所有联通块开一个大堆就能 $ O(n\log^2n) $ 做了。（需要合并堆，优先队列启发式合并的总复杂度是 $ O(n\log^2n) $ 的，当然不嫌麻烦也可以写一颗左偏树）

对刚才的模型做一些改变，假设我们连接了在同一个联通块中的两个点又会是怎么样的呢？

假设我们有四个点 $ a,b,c,d $，连接 $ (a,b)(c,d) $ 和 $ (a,c)(b,d) $ 的权值是一样的，因为度数序列相同，接下来连接的两个点在对方的方案中都属于同一个联通块。

也就是说，两个点是否在同一个联通块中并不影响最终答案，因为我们是对其的度数进行了修改。

于是直接对所有点开一个大堆就好了，没必要分联通块什么的，复杂度 $ O(n\log n) $。
```cpp
#include<cstdio>
#include<queue>
typedef unsigned ui;
struct Node{
	ui d,val;
	inline bool operator<(const Node&it)const{
		return (2*d+1)*val>(2*it.d+1)*it.val;
	}
}now;std::priority_queue<Node>q;unsigned long long ans;
signed main(){
	ui i,n;scanf("%u",&n);now.d=1;
	for(i=1;i<=n;++i)scanf("%u",&now.val),ans+=now.val,q.push(now);
	for(i=1;i<=n-2;++i){
		now=q.top();q.pop();
		ans+=(2*now.d+1)*now.val;
		if(++now.d!=n)q.push(now);
	}
	printf("%llu",ans);
}
```

---

## 作者：0htoAi (赞：1)

我下文说的贡献就是 $d_i^2v_i$，其中 $d_i$ 是不固定的。

证明在最下面。

## 算法思路：

有一个显然的结论：每个点度数至少为 $1$。所以先假设每个点都已经连好了，且每个点的度数都为 $1$。

因为每个点的度数都得为 $1$，所以肯定是两两互相连。

这时要分类讨论：

* $n$ 为偶数时：

刚好可以两两分组，所以可以分成 $\frac{n}{2}$ 组。

此时要把这 $\frac{2}{n}$ 个组连成一棵树，所以需要 $\frac{n}{2}-1$ 条边。

每条边会使得它连接的两个点的度数都 $+1$，所以一条边产生 $2$ 个贡献。

所以会产生 $n-2$ 个贡献。


* $n$ 为奇数时：

$n-1$ 个点可以两两分组，分成 $\frac{n-1}{2}$ 组，需要 $\frac{n-1}{2}-1$ 条边连。

产生 $n-3$ 个贡献。

剩下 $1$ 个点随便找一组连。

但这样会使得某一个点的度数 $+1$，从而增加一个贡献。

所以会产生 $n-2$ 个贡献。


**综上：此题的答案为所有点的初始贡献之和+前 $n-2$ 小的度数大于 $1$ 的贡献。**

## 实现过程：

前者输入时直接加就行，后者用优先队列维护。注意加入优先队列的贡献是从度数为 $2$ 开始算起的。

每次取出最小贡献的点后，设此当前点的度数为 $d$,繁忙度为 $v$，则产生的贡献为 $(d^2-(d-1)^2)v$（事实上优先队列也是通过这个值来排序的），且将 $d$ 更新为 $d+1$ 再放进优先队列。


## （感性）证明

开始已经把每个点自己向外连的贡献算了，没算的是连到的点产生的贡献。

之后用优先队列每次取贡献相当于确定这些点所连的是哪条边。因为 $n>2$ 时才会进行到这个步骤，所以可以认为不会自己连自己。



---

## 作者：PineappleSummer (赞：0)

贪心。

由于这是一颗树，共有 $n-1$ 条边，所以总度数为 $2(n-1)=2n-2$。

先把每个点都给一个度数，这样用去 $n$ 个度数后，还有 $n-2$ 个度数。

每次贪心，对当前最优的点进行操作。当前最优的点是指给这个点增加一度后，对答案贡献最少。

对于一个点权为 $a$，当前度数为 $d$ 的点，如果给这个点增加一个度数，对答案的贡献为为 $a(d+1)^2-ad^2=a(2d+1)$。可以开一个优先队列，按照 $a(2d+1)$ 升序放在堆里，每次取堆顶，也就是最优的点，给这个点增加一度，共增加 $n-2$ 次。

最后将堆里的每一个点的贡献累加即可。

代码：

```cpp
struct Node { int d, a; };
bool operator < (Node x, Node y) {
    return (x.d * 2 + 1) * x.a > (y.d * 2 + 1) * y.a;
}
priority_queue <Node> q;
int n, res;
signed main () {
    ios::sync_with_stdio (false);
    cin.tie (0); cout.tie (0);

    cin >> n;
    for (int i = 1, x; i <= n; i++) cin >> x, q.push ({1, x});
    for (int i = 1; i <= n - 2; i++) {
        Node x = q.top (); q.pop ();
        x.d ++; q.push (x);
    }
    while (!q.empty ()) {
        res += q.top ().d * q.top ().d * q.top ().a;
        q.pop ();
    }
    cout << res;
    return 0;
}
```

---

## 作者：kkxacj (赞：0)

#### 思路

显然，重构只会有 $n-1$ 条边，所以入度总和只有 $2\times n-2$ 个。

首先化简一下式子，假设当前第 $i$ 个数入度为 $j$ 了，又多了一个入度，那么新增的贡献为 $v_i\times\left(2\times j+1\right) $。

由于每个点入度至少为 $1$，那么考虑先计算一次入度，这样每个点都一定会连，然后剩下的入度可以给任意的点，用优先队列实时维护最小值就行了。

**为什么一定可以呢**，发现由于对于每个点都有一个度数，还需要加 $n-2$ 个度数，对于第 $i$ 个点加一个度数可以理解为何其它点连边，假设 $n-2$ 个度数全加一个点上，一共只加 $n-2$ 个度数，但有 $n-1$ 个点可以与之连边，不全加在一个点上也一样，所以一定可行。

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],top,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++top]=48+x%10;while(top) pc(stk[top--]);}
}
using namespace IO;
int n,a[300010],f[300010],l,l1,r1,r,v[300010],ans;
priority_queue<pair<int,int> >p,p1; 
int find(int x)
{
	if(f[x] == x) return x;
	return f[x] = find(f[x]);
}
signed main()
{
	read(n);
	for(int i = 1;i <= n;i++) v[i] = 1,read(a[i]),ans+=a[i],p.push(make_pair(-a[i]*(2*v[i]+1),i)),v[i]++;
	for(int i = 1;i <= (n-1)*2-n;i++)
	{
		l = -p.top().first,r = p.top().second;
		p.pop();
		ans += l;
		p.push(make_pair(-a[r]*(2*v[r]+1),r));
		v[r]++; 
	}
	print(ans);
	flush();
	return 0;
}

```

---


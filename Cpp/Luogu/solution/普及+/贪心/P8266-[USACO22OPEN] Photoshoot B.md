# [USACO22OPEN] Photoshoot B

## 题目描述

迫切希望在郡县集市上赢得最佳奶牛摄影师的 Farmer John 正在尝试为他的 $N$ 头奶牛拍摄一张完美的照片（$2 \leq N \leq 2\cdot 10^5$，$N$ 为偶数）。

Farmer John 拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 $j$，从第一头奶牛到第 $j$ 头奶牛范围内的所有奶牛）。

请计算 Farmer John 达到目的所需要的最小反转次数。


## 说明/提示

【样例解释】

在这个例子中，只需反转由前六头奶牛组成的前缀即可。
```
   GGGHGHHGHHHGHG （反转前）
-> HGHGGGHGHHHGHG （反转后）
```
在反转之前，四头更赛牛处于偶数位置。反转后，六头更赛牛处于偶数位置。不可能使得超过六头更赛牛处于偶数位置。

【测试点性质】

- 测试点 2-6 满足 $N\le 1000$。
- 测试点 7-11 没有额外限制。

## 样例 #1

### 输入

```
14
GGGHGHHGHHHGHG```

### 输出

```
1```

# 题解

## 作者：yzyjh (赞：12)



蒟蒻又来写题解了 awa

首先，我们先把题目抽象一下，每次翻转一个偶数长度的前缀事实上就是将那一段中奇数位翻转到偶数位，偶数位翻转到奇数位，更直接一些，将输入的字符没两个为一组，如果一次操作包含了这两个字符，这两个字符位置的奇偶会交换，如果这两个字符是相同的，显然怎样翻转都是无用的，要求是让尽可能多的 G 在偶数位置上。

然后我们只需要定义一个动态数组，将 G 在左侧的看做 $1$，G 在右侧的看做 $0$,遍历一遍就会得到一个 $01$ 串。

然后我们在遍历这个 $01$ 串，如果相邻的两位数不同，那么就要多进行一次翻转。

一点细节：如果末尾数字为 $1$ （即需要翻转），那么答案要  $+1$。


下面就是 code 了：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[200005];
int n;
vector<int>p;
int main()
{
	int i,j;
	cin>>n;
	cin>>(s+1);
	for(i=1;i<=n;i+=2)
		if(s[i]!=s[i+1])//两两一组
			if(s[i]=='G'&&s[i+1]=='H')
				p.push_back(1);
			else
				p.push_back(0);
	int cnt=0;
	for(i=1;i<p.size();i++)//遍历动态数组
		if(p[i-1]!=p[i])
			cnt++;
	if(p.size()==0)cout<<cnt<<endl;
	else cout<<cnt+p[p.size()-1]<<endl;//如果最后一个是1，那答案要加1
	return 0;	
}
```

完结撒花✿✿ヽ(°▽°)ノ✿


---

## 作者：I_am_Accepted (赞：7)

### Analysis

为方便，设更赛牛处于队列中的偶数位置的个数为 $Ans$。

先将两个两个相邻的分组。设 $m=\frac{n}{2}$，则我们可以得到一个序列 $a_1,a_2,\dots,a_m$，其中 $a_i$：

* 若她代表的两个字符相等，则为 $2$，代表 reverse 这两个字符对 $Ans$ 不影响。

* 若为 `'GH'`，则为 $1$，表示 reverse 后能使 $Ans+1$。

* 若为 `'HG'`，则为 $0$，表示 reverse 后会使 $Ans-1$。

------------

**结论：** 取得 $Ans$ 最大的任意最终奶牛序列的 $\{a\}$ 一定不含值 $1$。

**证明：** 假设含有，设 $a_x=1$，则将前 $2x$ 个奶牛 reverse，再将前 $2x-2$ 个奶牛 reverse，就会将 $a_x$ 变为 $0$，其他不变，得到更优 $Ans$。矛盾，原命题得证。

------------

所以，$1\to m$ 枚举 $a$ 的下标 $x$，由于我们最终要消灭 $a_i=1$，每步满足 $a_{[1,x)}$ 中没有 $0$ 或没有 $1$。

然后我们暴力 reverse 是 $O(n^2)$ 的，所以我们存一个 tag $O(n)$ 做即可。

注意最后如果没有 $0$ 还要再 reverse 一下。

### Code

```cpp
#define N 200010
int n,a[N],ans=0;
char c1,c2;
signed main(){IOS;
	cin>>n;n>>=1;
	For(i,1,n){
		cin>>c1>>c2;
		a[i]=(c1==c2?2:(c1=='G'?1:0));
	}
	int now=2;
	For(i,1,n){
		if(now==2){
			now=a[i];
			continue;
		}
		if(a[i]<2 && now!=a[i]){
			ans++;
			now=a[i];
		}
	}
	if(now==1) ans++;
	cout<<ans<<endl;
return 0;}
```

---

## 作者：Register_int (赞：4)

今天模拟赛刚好考到了，就写个题解。  
首先，将每两头相邻的奶牛捆到一起，一次翻转可以先看成将每一个组合逐个翻转。之后，新建序列 $a$。$a_i=1$ 表示不需要交换，$a_i=0$ 表示需要交换，$a_i=2$ 表示无所谓。显然可以通过先翻转 $1\sim l-1$ 再翻转 $1\sim r$ 的方式来翻转区间 $[l,r]$，而从前往后翻转就不会影响相对位置。直接计算即可。  
记得特判第一段区间是否为前缀。
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 2e5 + 10;

int n, l, r, f, ans;

char s[MAXN];

int a[MAXN << 1];

int main() {
	scanf("%d%s", &n, s);
	for (int i = 0; i < n; i += 2) {
		if (s[i] == 'G' && s[i + 1] == 'H') a[i >> 1] = 0;
		else if (s[i] == 'H' && s[i + 1] == 'G') a[i >> 1] = 1;
		else a[i >> 1] = 2;
	}
	n >>= 1;
	while (r < n && a[r] != 1) f |= !a[r++]; ans += f, l = ++r;
	while (l < n) { f = 0; while (r < n && a[r] != 1) f |= !a[r++]; ans += f << 1, l = ++r; }
	printf("%d", ans);
}
```

---

## 作者：hhhqx (赞：2)

# 洛谷P8266
## 题意
$(2 \le $ 长度 $ \le 2 \times 10^5)$。

给定一个偶数长度的 H 和 G 组成的排列，每次可以将**偶数长度的前缀**进行翻转。

求在**偶数下标**上的 G 的数量尽量多的情况下，使翻转次数尽量的少。

## 思路
#### 重点注意 **偶数** 这个词

因为是将**偶数长度的前缀**进行翻转，所以可以将**两个相邻的字符**看做**一坨**，当一坨中的两个字符不同，设这一坨为 0 或 1（因为要么是 HG，要么是 GH，两种情况），若相同，就舍去，即不管这一坨。

要注意最后一个不同的一坨。

然后这道绿题就变成了[硬币翻转](https://www.luogu.com.cn/problem/P2708)这样一道红题：将一个 01 串进行前缀翻转，使都为 1。（若 GH 为 0，要都为 1，若 GH 为 1，要都为 0）。

最后只需要模拟即可，模拟就每个前缀区间依次翻转。

可以分析如下样例：

如 0000111001，即排列为 GH GH GH GH HG HG HG GH GH HG。

- 第一次翻转：1111111001
- 第二次翻转：0000000001
- 第三次翻转：1111111111

如 00001110010, 即排列为 GH GH GH GH HG HG HG GH GH HG GH。

- 第一次翻转：11111110010
- 第二次翻转：00000000010
- 第三次翻转：11111111110
- 第四次翻转：00000000000
- 第五次翻转：11111111111

## 时空复杂度
时间复杂度 : $O(n)$。

空间复杂度 : $O(n)$。

## 代码如下
### 1.易看懂目的的
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, cnt = 0;
char a[200010];

int main(){
  cin >> n;
  for(int i = 1; i <= n; i++){
    cin >> a[i];
  }
  bool ooo = 0;
  for(int i = 1, j; i <= n; i = j){
    j = i + 2;
    if(a[i] != a[i + 1] && a[i] == 'G'){
      for( ; j <= n; j += 2){
        if(a[j] != a[j + 1] && a[j] == 'H'){
          break;
        }
      }
      cnt += 1 + ooo;
    }else if(a[i] != a[i + 1] && a[i] == 'H'){
      ooo = 1;
    }
  }
  cout << cnt;
  return 0;
}
```

### 2.简化后的
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, cnt = 0;
char a[200010], l = 'A';

int main(){
  cin >> n;
  for(int i = 1; i <= n; i++){
    cin >> a[i];
  }
  for(int i = 1; i <= n; i += 2){    // 两两为一组计算
    if(a[i] != a[i + 1]){
      cnt += a[i] != l, l = a[i];    // 求有多少个连续且相同的连通块 
    }
  }
  cout << cnt - (l == 'H'); // 当数据为 1001，答案要减去 1，因为最后的一个 1 的连通块被多余求解了 
  return 0;
}
```

---

## 作者：LorzhiSaMa (赞：2)

 - ### 题意  
将一个带有 G 和 H 的字符串翻转，让 G 在偶数的位置。


------------
- ### 思路
依题意得：  

GH 一定要翻转。    
HG 一定不用翻转。    
HH 和 GG 看情况来决定要不要翻转。   

GGHG 不用翻转，因翻转前两个 G 在偶数位上  
GGGH 要翻转，翻转后从一个 G 在偶数位变到两个 G 在偶数位   

所以 GG 和 HH 要不要翻转看他前面的字符


------------
- ### Code
```c
#include <bits/stdc++.h>
using namespace std;
const int M = 2e4+3;
int n,f[M];//f[]记录要不要翻转
char s[M]; 
int main(){
    cin >>n>>s+1;
    for(int i=2;i<=n;i+=2) {
        if(s[i-1]==s[i]){    
        	f[i/2]=2;
		}  
        else if(s[i]=='G'){
        	f[i/2]=0;
		}  
        else {
        	f[i/2]=1; 
		}
    }
    for(int l=0, i=1;i<=n/2;i++) { 
        if(f[i]==1) { 
            bool flag=1;
            for(int j=l+1;j<i;j++)  
                if(f[j]!=2) flag=0;
            if(flag==1){
            	for(int j=l+1;j<i;j++) f[j]=1; 
			}
            l=i;//记录位置
        }
    }
    int num=0;
    for(int i=1;i<=n/2;i++) {
    	num = num+(f[i] == 1 && f[i-1] != 1);  	
	}
    num=num*2;//因为是两个一组，所以乘2
    if(f[1] == 1) num--;
    cout<<num;
    return 0;
}
```


---

## 作者：Zero_s (赞：2)

P8266题解：

这道题其实非常简单（~~建议改成入门级别~~）。
## 思路：
我们将输入的字符串 $s$ 两两分一组，可以得到以下 $4$ 种可能性：

1. “GG”，这个不需要翻转，因为反转之后还是一样的。
2. “HH”同理，这个也不用翻转。
3. “GH”，这个需要翻转，转后变为“HG”，‘G’在偶数位上。
4. “HG”，这个不需要翻转，因为‘G’在偶数位上。

当然，我这里说的需不需要翻转是对于个体的。如果第三种情况和第四种情况相邻，例如“GHHG”，那需要翻转“GH”。又例如，“HGGH”，那就要翻转“HG”得到“GHGH”，然后翻转整个，得到“HGHG”。

按上面的思路，我们就可以知道，当第三种情况与第四种相邻时，需要翻转一次。如果结尾是第三种情况，还得翻转一次。遇到第一、二种情况就不管它，因为对结果没有影响，所以直接跳过。

不妨假设“GH”的为 $1$，“HG”的为 $0$，这样就可以用数组分别开来它们俩了。
## 代码实现：
```cpp
for(i=1;i<=n;i+=2)
	if(s[i]!=s[i+1])//两两一组
		if(s[i]=='G'&&s[i+1]=='H')
			p.push_back(1);
		else
			p.push_back(0);
int cnt=0;
for(i=1;i<p.size();i++)//遍历动态数组
	if(p[i-1]!=p[i])
		cnt++;
if(p.size()==0)cout<<cnt<<endl;
else cout<<cnt+p[p.size()-1]<<endl;//如果最后一个是1，那答案要加1
```
这是另一篇题解中的核心代码，用的是``vector<int>p;``，但是我个人觉得这个方法很浪费空间，可能也有点浪费时间。
## 优化：
虽然我刚开始想的也是那个写法，但是觉得空间太大，~~强迫症患者~~想要优化空间。

首先先将两个循环连接起来，然后用 $f_1$ 表示上文中的 $p_{i-1}$，那 $f_2$ 就是 $p_i$ 咯。利用滚动思想，可以大幅度优化空间。
- 但是优化后会出现头和尾的计算问题，怎么办呢？
1. 先解决头部，也就是输入的这个字符串 $s$ 的开头。我们把开头的“GG”和“HH”过滤掉，然后初次计算 $f_1$ 即可。
2. 接下来解决尾部，其实只要把原本的``cout<<cnt+p[p.size()-1]<<endl``改成``printf("%d",ans+f2)``（当然我这里用的不是 $cnt$ 而是 $ans$）就好了。

## AC&优化后代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,ans,i,f1,f2;//f1和f2相互滚动可以大幅度节省空间。
int main()
{
	scanf("%d",&n);
	cin>>s;
	while(s[i]==s[i+1]) i+=2;//过滤掉“GG”和“HH”的情况。
	if(s[i]=='G'&&s[i+1]=='H') f1=1;//初次计算f1。
	for(i+=2;i<n;i+=2)//记得是i+=2，因为是两两为一组。
	if(s[i]!=s[i+1])//s[i]==s[i+1]（即“GG”和“HH”的情况）就没有必要算了。
	{
		f2=s[i]=='G'&&s[i+1]=='H'? 1:0;//“GH”情况等于1，“HG”情况等于0.
		if(f1!=f2) ans++;//不相等就翻转。
		//printf("%d,%d",i,ans);
		f1=f2;//滚动。
	}
	printf("%d",ans+f2);//如果最后一项是1就加上。
	return 0;
}
```
按照我说的方法分四类讨论就可以成功地解决这个问题了，是不是很简单呢？

$\color{white}人家辛苦写了题解给你看，你就点个赞吧！$

---

## 作者：dingchenjun (赞：1)

题意
给定一个 $GH$ 串，只能对长度为偶数的前缀进行翻转，要求偶数位置上的 $G$ 尽可能多，求最少翻转次数。

思路
首先要思考如何让偶数位置的 $G$ 尽可能多。由于只能对偶数长度的前缀进行翻转，所以每次翻转会让一个前缀的所有位置变化奇偶性，如果去考虑每个 $G$ 的变化，情况会比较复杂，不便于分析，所以需要先化简一下状态。

根据翻转的特性，不妨每两位作为一个整体进行考虑，不难发现，如果连续两个位置是相同的，那么翻转不会对它产生影响，所以可以忽略这种情况。还剩下两种情况，因为要让 $G$ 尽可能在偶数位，可以假设 $HG$ 是 $1$ ，而 $GH$ 是 $0$ 。那么原串可以转换成一个 $01$ 串，同时原串的一次前缀翻转对应到新串变成了一次前缀的翻转加 $01$ 变换，目标就是让新串的 $1$ 尽可能多。

此时问题就变得很简单了，新串由很多 $01$ 段组成，我们可以不断的对第一段进行操作，这样翻转不会对第一段产生影响，但第一段会 $01$ 互换，然后与第二段合并到一起，不断这样操作，最终就可以让串变成全 $1$ ，这个答案是最优的。

不难发现每次操作最多减少一段，所以这种操作方案也是操作次数最少的，所以最终答案就是最后一个 $0$ 段所在的段数。

复杂度
时间
逐两位分析并计算段数 $O(N)$。

空间
存储串 $O(N)$。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,ans;//定义 
string a; 
char last;//上一组 
int main () {
	cin >> n >> a;
	for (int i=0; i<n; i+=2) {
		if (a[i]!=a[i+1]){//GG,HH忽略掉 
			if (a[i]!=last && (last=='G' || last=='H')){// 前后不一样并且不是第一个 
				ans ++;//计数 
			}
			last=a[i];//更新上一个 
		}
	} 
	cout << ans+(last=='G');//最后一个特殊处理 
	return 0;
}
```


---

## 作者：猜一猜我是谁 (赞：1)

# 思路
可以发现，每次翻转一个偶数长度的前缀，奇数位上的更赛牛一定会到偶数位，反之偶数位的更赛牛一定会到奇数位。所以我们可以两两分组，定义一个动态数组 w 如果枚举到的一组是 GH 就看做 1，HG 就看做 0。如果相邻两位不同，则翻转一次。如果最后一位是 1，那么还要再翻转一次。

例如样例字符串为 GGGHGHHGHHHGHG，对应的 a 数组就是 {1,1,0,0,0}。这里发现 $w[1]!=w[2]$，所以在 w[1] 处翻转，字符串变为 HGHGGGHGHHHGHG。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[200010];
vector<int>w;
int main()
{
	int n,ans=0;
	cin>>n;
	scanf("%s",s);
	for(int i=0;i<n;i+=2)//枚举所有的奇数位
		if(s[i]!=s[i+1]){
			if(s[i]=='G'&&s[i+1]=='H')
				w.push_back(1);
			else w.push_back(0);
			if(w.size()==1) continue;
			if(w[w.size()-1]!=w[w.size()-2]) ans++;
		}
	if(w[w.size()-1]==1) ans++;//末尾如果是 1 还要再翻转一下
	cout<<ans;
}
```

---

## 作者：王梓涵 (赞：1)

## 01. 题目大意
先输入一个偶数 $N\;(2 \leqslant N\leqslant 2\times 10^5)$，下一行输入一个只含有 $\texttt{G}$ 和 $\texttt{H}$ 且长度为 $N$ 的字符串。一次操作就是将一个带有 $\texttt{G}$ 和 $\texttt{H}$ 的字符串翻转，让 $G$ 在偶数的位置。最后输出操作的次数。

## 02. 题目分析
因为相邻的两个数时怎么翻转都分不开的，所以我们可以把一个在奇数位的字符和一个在偶数位的字符看成一个整体，即把两个字符看成一个整体去分析，这个整体有了 $4$ 种情况，分别是 $\texttt{GG}$，$\texttt{GH}$，$\texttt{HG}$，$\texttt{HH}$，分析这四种后，发现可以分成三种情况：
- 如果出现 $\texttt{GH}$ 这种情况，就一定需要翻转，
- 如果出现 $\texttt{HG}$ 这种情况，就一定不用翻转，
- 如果出现 $\texttt{GG}$ 或 $\texttt{HH}$ 的话就需要看情况讨论了。

那么如果是第三种情况，就需要看看它的前后了：
- 如果是 $\texttt{GGHG}$ 的话，就不需要翻转了。因为已经符合题目要求了，
- 如果是 $\texttt{GGGH}$ 的话，就需要翻转，因为翻转后才能满足题目要求。
- 如果是 $\texttt{HHGH}$ 的话，就不需要翻转了。因为已经符合题目要求了，
- 如果是 $\texttt{HHHG}$ 的话，就需要翻转，因为翻转后才能满足题目要求。




------------

 ## 03. AC Code
 ```cpp
#include <bits/stdc++.h>
using namespace std;

const int NR = 2e5 + 10;
int n, a[NR];

int main()
{
	string s;
	cin >> n >> s;
	int cnt = 0, CNT = 0;
	for (int i = 2; i <= n; i += 2)
	{
		if (s[i - 2] == s[i - 1])
		{
			a[i / 2] = 2;
		}
		else if(s[i - 1] == 'G')
		{
			a[i / 2] = 0;
		}
		else
		{
			a[i / 2] = 1; //判断是三种情况中的哪种情况
		}
	}
	for (int i = 1; i <= n / 2; i++)
	{
		if (a[i] == 1)
		{
			bool check = true;
			for (int j = cnt + 1; j < i; j++)
			{
				if (a[j] != 2)
				{
					check = false;
				}
			}
			if (check == true)
			{
				for (int j = cnt + 1; j < i; j++)
				{
					a[j] = 1;
				}
			}
			cnt = i;
		}
	}
	for (int i = 1; i <= n / 2; i++)
	{
		if(a[i] == 1 && a[i - 1] != 1) //如果符合就CNT++
		{
			CNT++;
		}
	}
	CNT *= 2;
	if (a[1] == 1) CNT--;
	cout << CNT << endl;
	return 0; //完结撒花
}
```


---

## 作者：Pekemetier (赞：1)

口胡选手前来报到

显然相邻两个是不会分开的。更具体地说：**如果从前往后每两个物品看作一个块，那么块中必有一奇一偶**。

容易发现任意**一个块内是可以任意反转**的：从后往前枚举每个块，然后对于一个需要反转的块，先进行前面全部的工作，再额外反转前面全部一次，最后翻转到这个块的前缀和。这样就能处理掉最后一个块，并归约到一个少一个块的子问题。

因此我们将一个块分成三种：【**必须反转的**】、【**必须不反转的**】和【**随便的**】。

考虑怎么求最小步数。直觉告诉我们这是贪心。那么通过一些经验可以得到：如果给每个随便的块**钦定一个最终结果**，答案就等于最后的连通块数量+最后一个连通块要不要翻（定义一个连通块为【要不要翻】相同的一个极大的连续块）。

证明是显然的：每翻一次最多使连通块数减一，而最后应该只有一个连通块。

考虑最小化连通块数量，发现只要每一个连续的【随便的】段都相等，并且等于左右两边任意一个（如果有的话）即可。

实现时可以顺序枚举，把除了开头的【随便的】连通块都赋值成与其左边一个相等。最后从右往左处理开头的【连续的】连通块。

---


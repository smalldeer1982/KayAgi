# [COCI 2012/2013 #2] LANCI

## 题目背景

**本题分值按 COCI 原题设置，满分 $100$。**

## 题目描述

Mirko 在阁楼里发现了 $N$ 个链。每个链由一些节组成，其中每个节最多有两个相邻节。每个节都可以打开或合上，因此可以将链分开或连成更长的链。

Mirko 希望把所有链连成一条巨大的链，并且打开或合上尽可能少的节。

例如，假设 Mirko 只有 $3$ 个链，每个链只有一个节，他可以打开其中一个，并且连上另外两个再合上。

![](https://cdn.luogu.com.cn/upload/image_hosting/he62ksg3.png)

给定链的数量以及每个链的长度，找到 Mirko 必须打开和关闭的最小节数，使它们全部在一个长链上。

## 样例 #1

### 输入

```
2
3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
1```

## 样例 #3

### 输入

```
5
4 3 5 7 9```

### 输出

```
3```

# 题解

## 作者：lihanwen12 (赞：8)

题目大意  
给定 $n$ 个链，每个链由若干个相邻的节构成，可以通过一次操作将一个节打开使其充当粘合剂的作用能连上两个链，求最少操作次数。  

解题思路  
一种将所有链连在一起的可行操作显然是每个链的末尾节打开和下一个链的开头节连在一起，这样做的操作次数是 $n-1$，不符合第二个样例和第三个样例。观察发现样例二把第 $1$ 个链只有 $1$ 个节，打开这个节以后需要连在一起的链只剩下后 $2$ 个了，样例三打开了最小的长度为 $3$ 的链条的所有节，打开这些节后最小的链条不复存在，剩下的 $4$ 个链条只需要 $3$ 个已打开的节去粘合了。  
提出贪心策略：既然注定要有部分节被打开成为若干链条之间的粘合剂，我们可以让需要粘合的链条数目尽可能地少。对所有链条以长度为关键字从小到大进行排序，优先拆散长度短的链条的节，全拆以后会使得需要粘合的链条数目减少 $1$。看看这些已经被打开节能不能满足剩余完整的较长链条的粘合需求，还要考虑一下当前链不用全部打开就能满足后面需求的情况。

代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long read(){
	long long x=0,sgn=1;char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-')sgn=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch&15);ch=getchar();}
	return x*sgn;
}
long long n,ans,a[500010],sum;
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+n+1);
	ans=n-1;//先全部首尾相连在一起 
	for(int i=1;i<=n;i++){
		sum+=a[i];
		//(n-i-1)为后面所需粘合剂的数量
		if(sum==n-i-1){//恰好相等，样例 3 所示情况 
			ans=min(ans,sum);
			break;
		}
		if(sum>n-i-1){//不用全拆，需求粘合剂个数 +1 
			ans=min(ans,n-i);
			break; 
		}
	}
	printf("%lld",ans);
	return 0;
}

```

---

## 作者：LightSpot (赞：5)

~~本蒟蒻的第一篇题解~~

### 题目分析：

首先，这是一道贪心题 ~~(废话~~，所以我们要制定一个贪心策略。我们可以轻松地用小学知识可以得到一共有 $N - 1$ 个空隙，但是我们的答案并不是这样。试想一下：取当前最短的链上的一个环，连接两个最长的链。当当前的取完以后，我们需要连接的链就会 $-1$。因此，这道题可以用双指针将其解出。

### AC代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int A[500005] , Ans = 0; //A记录每一条链的所剩长度，Ans为答案
int main()
{
	int N;
	cin >> N;
	for(int I = 0 ; I < N ; I++) cin >> A[I];
	sort(A , A + N); //先进行排序，为下面代码做铺垫
	int Head = 0 , Tail = N - 1; //头尾双指针
	while(Head < Tail)
	{
		while(A[Head] != 0)
		{
			A[Head]--;
			Tail--;
			Ans++;
			if(Tail == Head) break;
		} //进行模拟操作
		Head++;
	}
	cout << Ans;
	return 0;
}
```


---

## 作者：saixingzhe (赞：4)

# 思路
如果把每条链的头都打开的话，就需要 $n-1$ 次，肯定不是最优解，所以我们要从最短链中拆去一个，如果这条链拆完了，要打开的环数便会 $-1$。
## 如下
双指针，每次从最短的链中拆出一个环，去连接最长的和次长的两条链。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m[(int)1e5*5+2],left1=1,right1,ans;//注意啦，rigth是系统变量，不能用！！！
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&m[i]);  
    sort(m+1,m+n+1);//快排
    right1=n;//右端点
    while(left1<right1){//判断是否还有没拆完的环
        --right1;//把最后一个链删掉
            //相当于用从最小的链中拆出的环把最大的连起来
        m[left1]--; //从最小的链中拆出一个环
        if(!m[left1])   left1++;//如果最小的环拆完了，再拆次小的
        ans++;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：WhiteSunFlower (赞：4)

## 题目大意

给定 n 个链，每个链由若干个相邻的节构成，可以通过一次操作将一个节打开使其连上两个链，求最少操作次数。

## 基本思路

大部分人第一反应都是打开其中一个链的一节使其能与另一个相连接，明显这么做的答案是 n-1，不能解决题目。

既然如此，我们不妨考虑使链子的条数变少，怎么办呢？我们想到一个解决办法，那就是从一条链子上拆下一节，然后使用拆下来的这一节连接另外两个链。要使拆光的链数最大，我们要从最短的开始拆起，如此，这个算法就一目了然了

## 算法

首先按从小到大排序

接着进行操作：操作利用双指针，每次操作从最短的链子中拆去一节，连接最长的两条链子，右指针 -1

当最短的链子被拆光，就将目标转向第二短的链子，左指针 +1

下面是一个较为直观的程序
## AC程序
```cpp
#include<bits/stdc++.h>
  
using namespace std;
const int N=500005;
int n;
int a[N];
int l,r,ans;
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> a[i];
	}
	sort(a+1,a+n+1);
	l=1,r=n;
	while(l<r){
		a[l]--;//从最短的链中拆下一个 
		a[r-1]+=a[r];//用拆下的这个连接最后的两条链 
		r--;//右指针左移，删去最后一条链 
		ans++;
		if(!a[l])l++;//如果发现拆完了，则左指针+1，删去最左的一个
	}
	cout << ans << endl;
	return 0;
}



```

---

## 作者：__lfxxx_ (赞：3)

一个很棒的思维题。

考虑两种连接：  
1. 无环为一，一次连两个环
2. 有环为一，一次连三个环  

所以我们只要让一个环的更多就行了。

时间复杂度： $O(n\log n)$ 。

### Code：
```cpp
#include<bits/stdc++.h>
#define rint register int
#define mm 500010
using namespace std;
int a[mm],n;
inline int read()
{
    register int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9') 
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    return x*f;
}
int main()
{
    n=read();
	for(rint i=1;i<=n;++i)
		a[i]=read();
	sort(a+1,a+n+1);//能更好的找到目前最少环
	int ans=0;
	int nn=n;
	int l=1,r=n;
	while(l<r)
	{
		if(a[l]>1)
		{
			--a[l];//创造环为 1 的情况
			a[r-1]+=a[r]+1;//将最大和次大环相连，加 1 是因为取下了最前面的一个环，取最大和次大环能创造更多的环为 1 的情况（贪心），减少操作次数。
			--r;
		}//合并
		else//如果最小的只有一个环
		{
			++l;
			a[r-1]+=a[r]+1;
			--r;
		}//合并两个
		ans++;
	}
   printf("%d\n",ans);
	return 0;
}
```


---

## 作者：S__X (赞：3)

本蒟蒻的第 $24$ 篇题解。

## 分析：
一道很水的贪心。

我们先来分析下样例： $4\ 3\ 5\ 7\ 9$

1. 把 $3$ 取出一个，连接 $7$ 和 $9$，此时序列为 $4\ 2\ 5\ 17$，打开的节数为 $1$。
2. 把 $2$ 取出一个，连接 $5$ 和 $17$，此时序列为 $4\ 1\ 23$，打开的节数为 $2$。
3. 把 $1$ 取出，连接 $4$ 和 $23$，此时序列只剩下一个数 $28$，打开的节数为 $3$。

我们可以发现，序列中每次都把最小的链子取出一个去连接最大的两个链子。

因此我们可以对数组排序，以 $l$ 表示最小但不为空的链子，用 $n$ 表示当前剩下的链子数。

每次循环 $a_l-1$，$n-1$，打开的节数 $+1$。

如果 $a_l=0$，那么 $l+1$。

如果 $l=n$，说明只剩下一个链子，退出循环，并输出打开的节数。

## $\texttt{code:}$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX=1e6+1;
int n,a[MAX],ans,l=1;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);//排序
    while(l<n) a[l]--,ans++,n--,a[l]==0?l++:1;
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：2021sunzishan (赞：3)

 一道挺不错的双指针加贪心题。
### 题目大意：

给出 $n$ 条链的长度（链的节数），求最少要打开多少节，能把所有链合成一条（一节可以连接两个链）。


------------


### 思路：
- 读入后先按节数从小到大排序

- 定义三个变量：$l$ 指向头，$r$ 指向尾，$ans$ 记录断了几节。

- 从节数小的上拆下来一节，连接 $r$ 和 $r-1$，$ans$ 加上 $1$。

- $r$ 每一次都往前移一位，如果当前的链拆完了，$l$ 往后移一位。

- 最后输出 $ans$ 即为答案。


------------


如果还是看不懂，就看看代码吧！

### 切勿抄袭！！！

```c
#include <bits/stdc++.h>
using namespace std;
int n,l,r,a[500005],ans=0;
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin>>n;
	for (int i=1; i<=n; i++) {
		cin>>a[i];
	}
	sort(a+1,a+1+n); //按节数从小到大排序
	l=1,r=n; //l指向头，r指向尾
	while(l<r) {  //如果l>=r，那么说明已经合成为一条链了
		a[l]--; //从节数小的上面拆下来一节
		a[r-1]+=a[r]; //连接到r和r-1上，r-1的节长要加上r
		r--; //尾指针前移
		ans++; //拆的节数加1
		if (a[l]==0) //如果当前位置的链拆完了
			l++; //头指针后移
	}
	cout<<ans;  //最后输出ans就是答案了
	return 0;
}

```
完结！

---

## 作者：shengyiheng1234 (赞：3)

首先，此题是一道贪心题。

现在，我们有两种连接方法：

第一种：把相邻的两条链条简单地首尾相连。

第二种：找到一条链条，并使用此链条的一个圆环连接两个链条。

那么哪种方法更好呢？

显而易见，第二种更好，因为第二种是使用**第三条链条**连接两个链条，在连接的过程中，第三条可能会使用完，这样我们就可以少进行一次操作，当然最短的也可能用不完，那就和第一种方法一样。

于是我们得出**第二种方法只可能比第一种好**。

那么第二个问题又来了，我们应该用哪条链条来连接两条链条呢？

显而易见，短的链条更容易用完，于是我们选择用当前最短的链条。

并且，为了比较短的链条不被先连接，我们需要先从**最长的**链条开始连接。

大概思路就这一些了，下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;//链条总数
	int a[500001];
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//排序链条长度
	int l=1;//表示当前最短链条
	int ans=0;
	while(n>1)//循环，如果链条不唯一
	{
		a[l]--;//重点，最短链条用一个环连接两个最长的
		n--;
		ans++;//次数+1
		if(a[l]==0)//如果为0，换下一个
		{
			n--;
			l++;
		}
	}
	cout<<ans;//输出
 	return 0;
}

```
完结撒花

---

## 作者：stntn (赞：3)

## 简要题意

$N$ 个链（类似铁索），每个链由若干环组成，每次操作可以打开任意链中任意环，然后分开或串联另一部分，操作完成后将环闭上。

## 分析

若不考虑其他因素，要想合并 $N$ 个链至多需要 $N-1$ 次操作（显然）。

为什么实际操作次数会减少呢？我们考虑拆一条指定的链，用该链拆出的环作为中介合并另外两个链，依然 $N-1$ 次操作只能合并 $N$ 个链，但是若 $N>L_{i}$（$L_i$ 为指定的链），这条链就会被拆光，也就是 $N$ 少了一个，所以操作次数减少了。

于是我们要尽可能多地拆光链条，可以每次选取最短的链来拆，链接最长的两条链，就可以达到最优。

## CODE

```cpp
int n,a[N],ans;
signed main()
{
	read(n);
	rep(i,1,n) read(a[i]);
	sort(a+1,a+1+n);
	rep(i,1,n-1) while(a[i]&&i<n)
	{
		a[i]--;a[n-1]+=a[n];
		a[n--]=0;ans++;
	}
	if(a[n]&&a[n-1]) ans++;//最后两条链合并 
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：yeshubo_qwq (赞：2)

思路：

阅读题面可以得知：每次拆掉一个链上的一个环，可以连接另外的两个链。

要想让用的步数最少，我们每次都要拆固定的一条链，这样当一条链上的环用完时，就可以少连接一条链。

而为了让用完的链最多，从而减少要连接的链，减少步数，我们应该优先用环最少的链。

具体实现可以先排序，再用头、尾两根指针模拟上述过程即可，而头指针移动的次数也就是用的步数（答案）。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline void read(int &x){
	char c=getchar();
	while (!isdigit(c)) c=getchar();
	x=(c^48);c=getchar();
	while (isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
inline void write(int x){
	if (x>9) write(x/10);
	putchar (x%10+48);
}
int n,i,l,r,a[500005];
int main(){
	read(n);
	for (i=0;i<n;i++) read(a[i]);
	stable_sort(a,a+n,greater<int>());
	l=0;r=n-1;
	while (l<r){
		if (--a[r]==0) r--;
		l++;
	}
	return write(l),0;
}
```


---


# 「Wdoi-2」来自地上的支援

## 题目背景

波光粼粼的山顶湖与庄严神圣的神社之下，是一座复合型活火山。  
沿幻想风穴而下，便能到达火山之下，废弃已久的地狱原址。   
>在旧地狱中，有一座大都市。那里是旧地狱还是地狱的时候在那工作的众鬼们居住的地方，只有那里亡者们是无法踏入去的。后来地狱体制改革，机构搬离了这个地方。  
因为这个缘故这块地狱变成了废墟，但却有一部分看上了那里的妖怪擅作主张占领了那里，于是就成了如今的旧地狱了。
这里比地上更没有秩序可言。悍匪恶霸，特别是惹人类讨厌的家伙都喜欢搬到这边定居下来。

自旧地狱喷泻而出的间歇泉，给妖怪之山带来了优良的温泉，也喷出了大量的怨灵。

为了解决这次异变，乐园的巫女和普通的魔法使结伴而行，在来自地上的支援下，自幻想风穴直冲地底。

先后结（bao）识（da）了黑暗洞窟中的明亮之网、地壳下的嫉妒心、人们所谈论的怪力乱神后，二人来到了遗址中心的洋馆，地灵殿。

受这里主人的指引，二人来到了位于深处的间歇泉地下中心。

## 题目描述

### 简要题意
给定正整数 $n$、$v$ 和长度为 $n$ 的数组 $\{A_i\}$。

有一个长度为 $n$ 的数组 $B$，初始值与 $A$ 相同。 
执行 $n$ 次操作，第 $i$ 次操作在 $[1,i]$ 中按如下规则选取一个正整数 $j$，然后把 $B_j$ 变成 $B_j+v$：
- 选取 $B_j$ 最大的 $j$。
- $B_j$ 相同时选择 $A_j$ 最大的 $j$。
- $A_j,B_j$ 均相同，选择较小的 $j$。

我们称这是选中了一次 $j$。

有 $m$ 次询问，每次询问给定 $x_i,k_i$。表示求最小的 $s$，使得**若**将 $A_{x_i}$ 的初始值改为 $s$（注意此时 $B_{x_i}$ 的初始值也会跟着改变），$x_i$ 至少被选中 $k_i$ 次，或报告不存在（**结果为** $0$）。请注意，$s$ 不存在最小值时也是报告不存在（**结果为** $0$）。

询问之间互相独立，也就是每次询问不会对 $A_{x_i}$ 和 $B_{x_i}$ 产生实质性更改。

### 原始题意

到达控制中心之后，主角组和灵乌路空进行了激烈的狗斗大赛。负责技术维护的河童需要接受荷取来自地上指挥部的指令，保障生产安全。

具体地，有 $n$ 个核反应机组依次排开，第 $i$ 个机组的活动强度为 $A_i$。为了维护平衡，控制系统依次操作 $n$ 次，第 $i$ 次操作会在前 $i$ 个机组中找到一个**当前活动度最高的**机组，进行一次调节平衡操作，并将其活动度增加 $v$。倘若有多个机组活动度最高，就应当选择初始活动度**最大**的，若还是无法比较，则取编号最小。

为了在自动控制系统的基础上调节平衡，荷取会发出 $m$ 条指令，形如她每次会给出两个整数 $x_i,k_i$，表示她会修改第 $x_i$ 个机组的初始活动度。她希望通过修改（必须改成一个**非负整数** $s$）后，$x_i$ 号机组至少被平衡 $k_i$ 次。如果无论如何都无法达到要求，那么结果就是 $0$；否则请求出满足条件的**最小的** $s$。

## 说明/提示

### 样例 1 解释

对于第一次询问，我们将 $A_3$ 修改为 $7$。

- 第一次操作选择了位置 $1$，于是 $B_1$ 变为 $4$。
- 第二次操作选择了位置 $2$，于是 $B_2$ 变为 $7$。虽然操作前 $B_1=B_2$，但是 $A_2>A_1$，因此选择位置 $2$。
- 第三次操作选择了位置 $3$，于是 $B_3$ 变为 $10$。
- 第四次操作选择了位置 $3$，于是 $B_3$ 变为 $13$。
- 第五次操作选择了位置 $3$，于是 $B_3$ 变为 $16$。
- 第六次操作选择了位置 $3$，于是 $B_3$ 变为 $19$。
- 第七次操作选择了位置 $3$，于是 $B_3$ 变为 $22$。

于是位置 $3$ 一共被选择了 $5$ 次，满足题意。可以证明，如果把 $A_3$ 的初始值设为 $6$，无法达成要求。于是该询问结果为 $7$。

对于第二个询问，容易发现不可能有 $4$ 次以上操作选择位置 $6$。因此该询问结果为 $0$。

$7\oplus 0=7$，$7+0=7$，因此输出 $7,7$。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,m\le} & \bm {a_i\le } & \bm{v\le} & \textbf{分值} \cr\hline
1 & 10 & 100 & 10 & 10 \cr\hline
2 & 100 & 5\times 10^3 & 50 & 20 \cr\hline
3 & 10^3 & 10^9 & 100 & 10 \cr\hline
4 & 10^5 & 10^9 & 100 & 25 \cr\hline
5 & 2\times 10^6 & 10^9 & 100 & 35 \cr\hline
\end{array}$$

对于全部数据，满足 $1 \le n,m \le 2\times 10^6$，$1 \le v \le 100$，$1 \le a_i \le 10 ^ 9$，$1 \le x,k \le n$。

**本题 IO 量较大，请选择合适的输入方式。**

## 样例 #1

### 输入

```
7 2 3
1 4 1 5 4 1 1
3 3
6 4```

### 输出

```
7 7```

## 样例 #2

### 输入

```
10 10 9
14 91 84 13 97 92 23 64 31 10 
5 2
5 5
9 1
2 6
9 1
5 4
3 5
2 8
8 2
5 4
```

### 输出

```
245 1177
```

# 题解

## 作者：离散小波变换° (赞：18)

> $\text{upd 2022.9.11}$：原来有几句神志不清写错了，现在已经修正。

## 题解

注意到这样一个性质：每次操作选择的值（假设为 $c_i=a_i+b_iv$，其中 $b_i$ 是之前选中这个位置的次数）肯定会构成一些公差为 $v$ 的等差数列，且对于相邻的两个等差数列，后一个等差数列的第一项减去前一个等差数列的最后一项 $>v$。
  
这个性质可以这样理解：在第 $i$ 次操作选择了位置 $j$ 之后，相当于是给 $j$ 的价值加上了 $v$，而对于第 $i + 1$ 次操作，因为第 $i$ 次操作选了位置 $j$，所以 $a_j + b_j \times v$ 是 $[1,i]$ 中最大的，现在 $b_j \leftarrow b_j + 1$，$a_j + b_j \times v$ 一定也还是 $[1,i]$ 中最大的，所以第 $i$ 次操作要么选第 $i - 1$ 次操作选的位置，要么选第 $i$ 个位置。
  
而选择第 $i$ 个位置的充分条件就是第 $i$ 个位置不劣，即 $c_i \ge c_{i - 1} + v$。

若第 $i$ 个位置劣于 $i - 1$ 次操作选择的位置，则第 $i$ 次操作还是选择第 $i - 1$ 次操作选择的位置，$c_i = c_{i - 1} + v$。

由这个性质，可以发现选择第 $x$ 个位置的操作一定是在一个连续子区间 $[x,y]$ 中。

## $\mathcal O(n\log n)$ 做法
    
现在把一段等差数列压成一段一起维护，记录每一段的首项位置。
    
然后用一个指针 $i$ 从右向左扫，每次维护的是当只考虑 $[i,n]$ 时，$[i,n]$ 每一个位置对应的 $c_i$ 构成的那些等差数列。

先讲一下这个东西怎么维护：每次从 $i + 1$ 的结果推导出 $i$ 的结果，那么后面的一些段可能会转而选择 $i$，即 $a_i$ 较优，显然可以发现两点：
    
1. 如果一个等差数列的首项选择了 $i$，那么这个等差数列会全部选择 $i$；
2. 一定是一些连续的等差数列选择 $i$。
    
每次我们可以暴力去删除选择 $i$ 的段，然后加入一个新的等差数列，这个是均摊 $O(1)$ 的。每次查询的时候，找到 $[x + 1,n]$ 对应的信息，这样就成功撤销掉了 $x$ 的影响。
    
然后在这些等差数列段上面二分，找到最少选择几个段才能使有 $ k - 1$ 次操作选择 $x$，然后通过数学方法计算出，$a_x$ 最小修改为多少，可以使得最后一个必须选择 $x$ 的段选择 $x$。

不过这样我们没有考虑 $[1,x - 1]$ 的影响，所以我们还要将答案与需要使 $x$ 选择 $x$ 的答案取 $\max$。

## $\mathcal O(n)$ 做法

考虑第 $i$ 次操作。啥时候我们要选择 $j\;(j<i)$ 位置而不选择 $i$ 位置呢？那应该是 $a_j+v(i-j)\ge a_i$。移项，发现 $a_j-vj\ge a_i-vi$。

根据刚刚的结论，选择位置 $i$ 的操作一定是一段连续的区间 $[i,i+t]$。现在我们希望选择位置 $x$ 的操作要至少 $k$ 个。那需要满足两个要求：

- 第 $x$ 次操作选择了 $x$ 位置。
- 第 $y$ 次操作选择了 $x$ 位置，其中 $y=x,x+1,\cdots,x+k-1$。

记 $w_i=a_i-vi$，那么这两个要求相当于：

- $w_x\ge\max_{y<x} \{w_y\}$。注意这是大于等于，因为 $w$ 值相同时会选择最靠后的那个。
- $w_x> \max_{x<y\le x+k-1} \{w_y\}$。这里是严格大于，原因同上。

记 $s_i=\max_{j\le i} \{w_j\}$，容易发现第一个操作就相当于 $w_x\ge s_x$。问题在于第二个操作。如果 $s_{x+k-1}$ 第一次取得最大值时，选取的就是 $w_x$，那无法通过 $w_{x+k-1}$ 得到结果。但是若 $s_{x+k-1}$ 第一次取最大值时不是由于 $w_x$，那就可以直接选取。

为什么呢？此时 $w_x$ 的值，就等于：

$$\max_{y\le x+k-1,y\neq x}\{w_y\}=\max\{\max_{y<x}\{w_y\},\max_{x<y\le x+k-1} \{w_y\}\}$$

现在处理 $s_{x+k-1}$ 取最大时选取的就是 $w_x$ 的情况。考虑前缀非严格次大值 $s'_{x+k-1}$，那么它就相当于从 $x$ 以外的位置选取最大值了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN =1e7+3;
int n,m,v,w,l,F[MAXN],G[MAXN],A[MAXN],X[MAXN],K[MAXN];
i64 ans1,ans2; char _file[256];
int qread(){
	int w=1,c,ret;
	while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
	while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
	return ret*w;
}
int main(int argc,char **argv){
	n=qread(),m=qread(),v=qread();
	up(1,n,i) A[i]=qread();
	up(1,m,i) X[i]=qread(),K[i]=qread();	
    A[0]=-INF;
	up(1,n,i){
		A[i]=w=A[i]-i*v;
		if(w>=A[F[i-1]]) G[i]=F[i-1],F[i]=i; else
		if(w>=A[G[i-1]]) G[i]=i,F[i]=F[i-1]; else
		G[i]=G[i-1],F[i]=F[i-1];
	}
	up(1,m,i){
		int x=X[i],k=K[i],y=x+k-1; l=0;
		if(y<n) l=max(0,x*v+(F[y]==x?A[G[y]]+(G[y]>x):A[F[y]]+(F[y]>x)));
        ans1^=l,ans2+=l;
	}
    printf("%lld %lld\n",ans1,ans2);
	return 0;
}
```

---

## 作者：Dregen_Yor (赞：7)

[博客食用效果更佳。](https://www.cnblogs.com/Dregen-Yor/p/16690428.html)

# 思路

根据题意，如果每次询问选中的为第 $x$ 个数，那么前 $x-1$ 次操作一定不会选中第 $x$ 个数。（~~感觉在说废话。~~）

同样，因为第 $x$ 个数必须被选中 $k$ 次，根据题意，不难发现这 $k$ 次选中一定是从第 $x$ 次操作到 $x+k-1$ 次操作被选中。因为如果某个数在某次操作时没有被选中，那么他在后面的操作中肯定不会再次被选中。

根据上面的思路，我们要修改的最小值 $s$ 必须大于等于前 $x-1$ 个数进行 $x-1$ 次操作后的最大值，我们可以用一个前缀数组来维护，数组的每个值 $pre_i$ 表示前 $i-1$ 个数进行 $i-1$ 次操作后的最大值，然后再向后枚举 $k-1$ 个数，每次都和进行过若干次操作后的最大值比较，如果枚举到的值比最大值大，就讲当前的最大值修改为枚举到的值加一（操作的第二个性质），这样就可以得到答案。

这时你就可以得到 $65$ 分的好成绩。

# 优化

很显然，对于上面向后枚举 $k-1$ 个数的操作是可以进行优化的。

因为要区间查询最大值，所以不妨考虑一下**线段树**，但现在问题出现在如果维护最大值上。

我们可以考虑在维护线段树时**同时记录下最大值和最大值所在的坐标**。然后在两个数相比较的时候，比较 $a_i+(j-i)\times v$ 和 $a_j$ 的大小（$i\le j$)。根据这样比较的结果选出最大值来，这样我们只需要把 $s$ 修改为 $\max\left\{ pre_x,a_p-(p-x)\times v+1 \right\}$ （$p$ 表示最大值所在的下标）即可。

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls x<<1
#define rs x<<1|1
#define N 2000010
using namespace std;

struct node {
	int val, st;
};
int n, m, v, a[N], pre[N], ans1, ans2;
node maxn[N << 2];

node max(node x, node y) {
	if (x.st > y.st) {
		if ((x.st - y.st)*v + y.val < x.val) {
			return x;
		} else {
			return y;
		}
	} else {
		if ((y.st - x.st)*v + x.val < y.val) {
			return y;
		} else {
			return x;
		}
	}

}

void bulid(int x, int l, int r) {
	if (l == r) {
		maxn[x] = node{a[l], l};
		return;
	}

	int mid = l + r >> 1;
	bulid(ls, l, mid);
	bulid(rs, mid + 1, r);
	maxn[x] = max(maxn[ls], maxn[rs]);
}

node query(int x, int l, int r, int L, int R) {
	if (l >= L && r <= R) {
		return maxn[x];
	}


	int mid = l + r >> 1;

	if (R <= mid) {
		return query(ls, l, mid, L, R);
	} else if (L > mid) {
		return query(rs, mid + 1, r, L, R);
	} else {
		return max(query(ls, l, mid, L, R), query(rs, mid + 1, r, L, R));
	}
}

signed main() {
	scanf("%lld%lld%lld", &n, &m, &v);
	int maxn = 0;

	for (int i = 1; i <= n; i++) {

		scanf("%lld", &a[i]);
		pre[i] = maxn;
		maxn = max(maxn, a[i]) + v;
	}

	bulid(1, 1, n);

	while (m--) {
		int x, k;
		scanf("%lld%lld", &x, &k);

		if (k > n - x + 1) {
			continue;
		}

		int s = pre[x];
		if(k==1){
			ans1 ^= s;
			ans2 += s;
			continue;
		}
		node tmp = query(1, 1, n, x + 1, x + k - 1);

		if (s <= tmp.val - (tmp.st - x)*v) {
			s = tmp.val - (tmp.st - x) * v + 1;
		}

		ans1 ^= s;
		ans2 += s;
	}

	printf("%lld %lld", ans1, ans2);
	return 0;
}
```


---

## 作者：MarchKid_Joe (赞：5)

# 来自地面的支援

先声明本题解的算法标签与时间复杂度。

## 算法标签

- 模拟（时间复杂度 $O(n \log n)$）
- 线段树（时间复杂度 $O(m \log n)$）

## 时间复杂度

优先队列的插入元素时间复杂度 $O(\log n)$，模拟时用优先队列扫一遍原序列，时间复杂度 $O(n \log n)$。

线段树查询 $O(\log n)$，查询共 $m$ 次，时间复杂度 $O(m \log n)$。

因为 $n,m$ 范围相同，所以总体时间复杂度 $O(n \log n)$。

## Solution

假设现在询问为第 $x$ 个数至少被选中 $k$ 次，求最小的 $s$。

我们考虑将这个询问拆为两部分考虑：

- $[1,x-1]$ 这段区间的贡献。
- $[x+1,x+k-1]$ 这段区间的贡献。

解释为什么拆为这两部分：

- 第一部分:

    对于 $[1,x-1]$ 我们可以发现：第 $x$ 个数一定不会被其之前的区间选中，而且第 $x$ 个数不会影响其之前的区间状态，我们只需要保证到第 $x$ 个数的时候，第 $x$ 个数与**预处理后的区间** $[1,x-1]$ 的**最大值相等**就可以了。所以我们可以先预处理出来原序列 $a$ 按照题意模拟之后的序列，可以用一个**优先队列**维护当前状态的最大值。定义按照题意预处理出来了序列 $b$， $b_i$ 的含义就是 $[1,i]$ 这段区间按题意模拟后的最大值。

    那么第一部分的贡献就是 $b_{x-1}$ 的值，预处理 $O(n \log n)$，查询 $O(1)$。

- 第二部分:

    对于 $[1,x-1]$ 我们可以发现：第 $x$ 个数至少被选中 $k$ 次与 $x$ 后面的 $k-1$ 个数有关。既然要保证 $x$ 被选中 $k$ 次，只需要保证每次更新第 $x$ 个数时，更新后的第 $x$ 个数**严格大于**后面的 $k-1$ 个数。不可以取等号是因为另一个限制，数值相等的话取 $a$ 序列更大的。因为更改后的 $a_x$ 一定要比后面的值小，毕竟差值为 $v$，所以要严格大于。

    第二部分就会得到这样一个限制：
    $$
    a_x+v\times(y-x)\gt a_y\qquad y\in [x+1,x+k-1]
    $$
    移项可得：
    $$
    a_x\gt a_y-v\times y+v\times x\qquad y\in [x+1,x+k-1]
    $$
    发现 $a_y-v\times y$ 可以 $O(n)$ 预处理，定义预处理出来了序列 $c$，$c_i=a_i-v\times i$，然后对序列 $c$ 建**线段树**维护区间**最大值**。

    线段树空间复杂度 $(n)$ 可以接受,ST 表空间复杂度 $(n \log n)$ 似乎不能接受。

    那么第二部分的贡献就是查询序列 $c$ 在 $[x+1,x+k-1]$ 区间的最大值，查询一次 $O(\log n)$。

最后两部分答案综合取最大值：
$$
s=\max(b_{x-1},\displaystyle\max_{y\in[x+1,x+k-1]}\{c_y+v\times x+1\})
$$
因为第二部分贡献严格大于，所以要 $+1$。注意判断**无解**情况，也就是 $x+k-1\gt n$。

## Code

为了代码可观性，我只删去了快速读入输出，所以代码的输入 read 输出 write 是 **CE** 的。

$O(n \log n)$ 做法

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int inf=2147483647;
const int N=2e6+5;
int n,m,v;
int a[N],b[N];
namespace Segment //线段树区间最大值可自行忽略
{
    #define lc(i) i<<1
    #define rc(i) i<<1|1
    struct node
    {
        int l;
        int r;
        int maxn;
    };
    node tr[N<<2];
    void build(int i,int l,int r)
    {
        tr[i].l=l;
        tr[i].r=r;
        if(l==r)
            return void(tr[i].maxn=a[l]);
        int mid=(l+r)>>1;
        build(lc(i),l,mid);
        build(rc(i),mid+1,r);
        tr[i].maxn=max(tr[lc(i)].maxn,tr[rc(i)].maxn);
    }
    int query(int i,int l,int r)
    {
        if(tr[i].l>r||tr[i].r<l)
            return -inf;
        if(tr[i].l>=l&&tr[i].r<=r)
            return tr[i].maxn;
        return max(query(lc(i),l,r),query(rc(i),l,r));
    }
}
using namespace Segment;
priority_queue<int> q;
ll ans1,ans2;
signed main()
{
    read(n,m,v);
    for(int i=1;i<=n;i++) //按题意模拟预处理 {b}
    {
        read(a[i]);
        q.push(a[i]);
        b[i]=q.top()+v;
        q.pop();
        q.push(b[i]);
    }
    for(int i=1;i<=n;i++) a[i]-=i*v; //也就是 {c} ，只不过 {a} 可以循环利用罢了
    build(1,1,n);
    for(int i=1,x,k;i<=m;i++)
    {
        read(x,k);
        if(x+k-1<=n) //判断合法
        {
            int s=max(b[x-1],query(1,x+1,x+k-1)+x*v+1);
            ans1^=s;ans2+=s;
        }
    }
    write(ans1,' ',ans2);
    return 0;
}
```
感谢管理员对此题解文章格式规范的提醒。

---

## 作者：littlez_meow (赞：2)

比赛的时候调了好久。。。

提供一种非常神奇的假线性做法。

## step 1

既然要求修改后的值，我们就把没有修改的情况考虑上。

记 $w_i$ 为未把 $A_{x_i}$ 的初始值改为 $s$ 时第 $i$ 次选中的数，则有

$w_i=\begin{cases}
 w_{i-1} & \text{ if } a_i<a_{w_{i-1}}+v(i-w_{i-1})\\
 i & \text{ otherwise }
\end{cases}$

$w_0=1$

可以在输入时做到 $O(n)$ 预处理。

由此还可以得到一个数仅会在连续的一段中被选，且 $i$ 如果被选则左端点一定是第 $i$ 次操作。

## step 2
根据以上的结论，我们可以分析出以下几点

1. 如果 $x$ 被选中 $k$ 次，则在第 $x$ 至 $x+k-1$ 次选择中， $x$ 一定被选中。因此，若 $x+k-1>n$，则 $s$ 不存在，即为 $0$。

2. 当 $w_{x+k-1}>x$ 时，如果想一直选取，则修改的 $s$ 一定要满足 $s+v(w_{x+k-1}-x)>a_{w_{x+k-1}}$，因为如果相等，则 $a_x<a_{x+k-1}$，不选 $x$，故此时 $s_{\min}=a_{w_{x+k-1}}+1-v(w_{x+k-1}-x)$。

3. 当 $w_{x+k-1}<x$ 时，如果想一直选取，则修改的 $s$ 一定要满足 $s\ge a_{w_{x+k-1}}+v(x-w_{x+k-1})$，此时如果相等就有 $a_{w_{x+k-1}}<a_x$，选 $x$，所以可取等，故此时 $s_{\min}=a_{w_{x+k-1}}+v(x-w_{x+k-1})$。

那么现在我们就有 $s$ 的取值了，可以 $O(1)$ 得到，总的时间复杂度是 $O(n+m)$。

什么？相等怎么办？随便找一类归进去就行。

……吗？

如果这样交上去，就只能得到后三个 Subtask 的分，为什么呢？

## step 3
究其本质，当 $w_{x+k-1}=x$ 时，若按照上述方法，则 $s=a_x$。

比较上面两个式子，发现这个 $s$ 少了下标 $\min$！

也就是说，这个 $s$ 只是一组可行解，可能不是最优解！

那如何得到最优解呢？

观察式子，我们发现 $s$ 越大，就越可能选到，越小就越不容易。

也就是说，$s$ 与是否选取是具有单调性的！

那么，只要确认一个较大的不成立的数，我们就可以开始二分，比如

$\min\{a_{w_{x-1}}+v(x-w_{x-1}),\min\{a_{i}|i=x,x+1,\dots,x+k-1\}\}$

它一定不成立。

至于二分如何判断，暴力从 $x$ 枚举 $k$ 个数，用类似与初始化 $\{w_i\}$ 的 方式判断即可。

时间复杂度最坏为 $O(n+mk)$，最好为 $O(n+m)$，其中二分的最坏时间复杂度 $O(\log 10^9)$ 视为常数。

## step 4：附上代码

就直接贴考场代码了，特判就不改了。

注意开 long long 和判断 $s\ge0$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a);i<=b;++i)
#define R(i,a,b) for(int i(a);i>=b;--i)
#define _ 0
using namespace std;
int n,m,v,a[2000001];
int without[2000001];
ll xorans,sumans;
inline int input(){
	int x;char ch;
	for(ch=getchar();!isdigit(ch);ch=getchar());
	for(x=0;isdigit(ch);ch=getchar()) x=x*10+(ch^48);
	return x;
}
inline bool check(ll s,int bg,int ed){
	F(i,bg+1,ed) if(a[i]>=(ll)s+v*(i-bg)) return 0;
	return 1;
}
int main(){
	n=input(),m=input(),v=input();
	without[0]=1;
	F(i,1,n){
		a[i]=input();
		if(a[i]<(ll)a[without[i-1]]+v*(i-without[i-1])) without[i]=without[i-1];
		else without[i]=i;
	}
	if(n>100&&m>100){
		F(i,1,m){
			int x=input(),k=input();
			if(x+k-1>n) continue;
			ll s;
			if(without[x+k-1]<=x) s=(ll)a[without[x+k-1]]+v*(x-without[x+k-1]);
			else s=max((ll)a[without[x+k-1]]+1-v*(without[x+k-1]-x),0ll);
			xorans^=s,sumans+=s;
		}
	}else{
		F(i,1,m){
			int x=input(),k=input();
			if(x+k-1>n) continue;
			ll s;
			if(without[x+k-1]<x) s=(ll)a[without[x+k-1]]+v*(x-without[x+k-1]);
			else if(without[x+k-1]==x){
				ll l=a[without[x-1]]+(ll)v*(x-without[x-1]),r=a[x];
				F(j,x,x+k-1) l=min(l,(ll)a[j]); 
				while(l^r){
					s=(l+r)>>1;
					if(check(s,x,x+k-1)) r=s;
					else l=s+1;
				}
				s=l;
			}
			else s=max((ll)a[without[x+k-1]]+1-v*(without[x+k-1]-x),0ll);
			xorans^=s,sumans+=s;
		}
	}
	printf("%lld %lld",xorans,sumans);
	return ~~(0^_^0);//每日卖萌（1/1)
}
```

完结撒花 awa~

---

## 作者：NianFeng (赞：1)

**blog食用地址：**[广告](https://www.luogu.com.cn/blog/YuanFang-Nian/p8539-wdoi-2-lai-zi-di-shang-di-zhi-yuan-ti-xie-post)

---

# 0x01 题目分析

## 题意

题面比较长，就放个[题目链接](https://www.luogu.com.cn/problem/P8539)好了。

## 思路

我们直接考虑操作。首先可以看到，每次取的都是**区间最大值**。这会使的在一段连续的操作内**单独一个值**增长，同时一个值的增长**必然连续**。在每加一个数（记下标为 $x$，上一次更新的 $j$ 为 $last$ ）的时候，就三种情况：$B_x < B_{last}$，不做操作；$B_x > B_{last}$，更新 $last$ 为 $x$；以及，$B_x = B_{last}$，**更新** $last$ **为** $x$。

WHY？为什么第三种直接更新了呢？我们从操作描述入手：“$B_j$ 相同时选择 $A_j$ 最大的 $j$”。我们仔细想想，$B_x = B_{last}$，的时候，$B_{last}$ 肯定是被更新过的，且**只增不减**，并且 $B_x$ 尚未更新，就是 $A_x$，故一定有 $A_{last} < A_x$，所以可以直接更新。同时我们也顺便了解到，第三点实际上是没有用的，这也给我们少带来了一点维护的麻烦。

有了对于操作的分析，我们就来分析一下询问吧。由操作的定义，**一段连续的操作内**一个最大值不断增长，而除了这个值之外，其他值**不会改变**，也就是说第一次不被取到就再也取不到了。所以，要想让 $x_i$ 被取到，$A_{x_i}$ **至少要不小于前面增长到此的** $B_{last}$。同时，要让 $x_i$ 被取到 $k_i$ 次，要保证在 $j \in [x,x + k_i - 1]$ 中，**更新过去的** $B_x > A_j$。

但是，还是有点问题。每次往后延伸，直接修改所带来的时间复杂度，至少在超多次的询问面前会当场炸裂。那么，如何做到在较低时间复杂度内单次查询呢？

考虑一些情况。首先，$v$ 是给定的，那么就可以**提前预处理**。预处理啥呢？再想一个事情，在比较大小这方面要的是**相对**，加减同一个数是没什么关系的。既然是相对，连续加上某个数，不如直接把最终的那个数**减去相对应的乘积**。公式化一点，每次比较 $A_x + v \times (y-x)$ 和 $A_y$，不如直接比较 $A_x$ 和 $A_y - v \times (y-x) $。更进一步，**可以直接比较** $A_x - v \times x$ **和** $A_y- v \times y$。这样，就方便预处理了。

所以，最终的思路是：**预处理将初始数组统一减少，每次直接查询前面和后面相对应的最大值，最后统计答案加上减少的值**。

# 0x02 查询实现

## 需要维护的

- $A_i - v \times i$ 的区间最大值

- 每次查询的答案统计

蛮少的，可能这道题更注重于思路吧。

## 实现

### 1. $A_i - v \times i$ 的区间最大值

这个，直接线段树维护就好了呀……

```cpp
int tree[N<<2];                     //这里使用非储存线段树
void build(int root,int l,int r){
    if(l==r){
        tree[root]=a[l]-v*l;        //记得减v*l
        return;
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root]=max(tree[leftroot],tree[rightroot]);
}
int query(int root,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        return tree[root];
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    int ans=-1e9;
    if(L<=mid) ans=max(ans,query(leftroot,l,mid,L,R));
    if(mid<R) ans=max(ans,query(rightroot,mid+1,r,L,R));
    return ans;
}
```

### 2.答案的统计

设更新到 $x_i$。首先是前面的。前面的 $B_j$ 更新到 $x_i$ 的时候，其值是 $A_j + v \times (x_i - j)$。转到线段树维护的东西上面，就是 $tree_j + v \times j +v \times x_i - v \times j$，**简化一下，每次对于前面所求的** $A_{x_i}$ **就是** $(\max_{j=1}^{x_i} tree_j) + v \times x_i$（注意这里的 $tree_i$ 指的是**代表** $i$ **的叶子结点**）。

不过我在代码中是直接用的递推式，设 $x$ 前最大的 $B_y$，也就是 $A_x$ 的初始最小值为 $low_x$，有 $low_x = \max(low_{x-1}, a_{x-1}) + v$。也许这个式子更容易理解吧，但是有了上面的分析，对于 $x_i$ 后面的答案统计也就容易了一些。

```cpp
    low[1]=0; for(int i=2;i<=n;i++){      //如果要取到的下限
        low[i]=max(low[i-1]+v,a[i-1]+v);
    }
```

对于后面，我们需要保证在 $j \in [x_i + 1,x_i + k_i - 1]$ 内，$B_{x_i} > A_j$，**但是不能等于，前文有讲** $B_{x_i} = A_j$ **时必然有** $A_{x_i} < A_j$。借由上面的分析，容易有 
$$A_{x_i} =(\max_{j=x_i+1}^{x_i+k_i-1}A_j - v \times (j - x_i)) + 1$$
$$= (\max_{j=x_i+1}^{x_i+k_i-1} tree_j) + v \times x_i + 1$$

```cpp
        int x=read(),k=read();
        if(x+k-1>n) continue;
        int tmp=max(low[x],(query(1,1,n,x+1,x+k-1)+v*x+1));     //加一是因为如果直接上的话，Ax<Aj就取不到力
```

就是这么简短。

# 0x03 总代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
namespace io{
    inline int read(){
        int x=0;
        bool flag=true;
        char c=getchar();
        while(c<'0'||c>'9'){
            if(c=='-')
                flag=false;
            c=getchar();
        }
        while(c>='0'&&c<='9'){
            x=(x<<1)+(x<<3)+c-'0';
            c=getchar();
        }
        return (flag?x:~(x-1));
    }
}
using namespace io;
const int N=2000100;
int n,m,v,a[N];
int low[N];
int tree[N<<2];                     //这里使用非储存线段树
void build(int root,int l,int r){
    if(l==r){
        tree[root]=a[l]-v*l;        //记得减v*l
        return;
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    build(leftroot,l,mid);
    build(rightroot,mid+1,r);
    tree[root]=max(tree[leftroot],tree[rightroot]);
}
int query(int root,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        return tree[root];
    }
    int mid=l+r>>1;
    int leftroot=root<<1;
    int rightroot=root<<1|1;
    int ans=-1e9;
    if(L<=mid) ans=max(ans,query(leftroot,l,mid,L,R));
    if(mid<R) ans=max(ans,query(rightroot,mid+1,r,L,R));
    return ans;
}
signed main(){
    n=read(),m=read(),v=read();
    for(int i=1;i<=n;i++) a[i]=read();
    low[1]=0; for(int i=2;i<=n;i++){    //要取到的下限
        low[i]=max(low[i-1]+v,a[i-1]+v);
    }
    build(1,1,n);                       //建树
    int ans1=0,ans2=0;
    while(m--){
        int x=read(),k=read();
        if(x+k-1>n) continue;                               //一定取不到，无解
        int tmp=max(low[x],(query(1,1,n,x+1,x+k-1)+v*x+1)); //取到至少k次的下限
        ans1^=tmp,ans2+=tmp;                                //一个异或一个加
    }
    cout<<ans1<<" "<<ans2<<endl;
    return 0;
}
```

# 0x04 总结与后话

这道题码量还是挺少的，其注重于巧妙地转化思路，然后用线段树维护，是道不错的思维题。

可能以后会更新图床吧，但这个也许不需要图就能理解。（实在不行就动手画画吧（QAQ）

感谢您的观看，有错误/不足之处欢迎指出！(>w<)

---

## 作者：E1_de5truct0r (赞：1)

## 思路

观察有无性质。发现，如果一个数在某个位置没有成为最大值，那么它**再也不可能**成为最大值了，因为如果后面的 $b$ 比当前的 $a$ 大，由于 $v \geq 1$ 所以 $b+kv>a$。

显然如果让他成为 $k$ 次，一定是它首先成为从 $1$ 开始的最大值，并且比后面至少 $k-1$ 个数大。

首先考虑怎么让 $a_i$ 成为 $1\sim i$ 的最大值。我们可以维护一个 $pre$ 数组，$pre_i$ 表示到 $i$ 的最大值是多少。显然每次转移很显然，就是枚举之前的加 $v$，和当前的哪个大：$pre_i=\max(pre_{i-1}+v,a_i)$。那么我们在判断 $i$ 是否比之前的全部大的时候，直接看一下 $a_i$ 和 $pre_{i-1}+v$ 的关系即可。

然后考虑一下怎么让 $a_i$ 比后面 $k$ 数都大。对于 $i$ 位置的数，他在和 $i+j$ 这个数比较的时候，应该是 $a_i + j \times v$ 和 $a_{i+j}$ 在比较。也就是说我们要维护 $[a_{i+1}-v,a_{i+2}-2 \times v,\dots,a_{i+k-1}-(k-1)\times v]$ 这些的最大值，使得 $a_i$ 比这个最大值大。

考虑维护这个最大值。显然可以用差分的思想，线段树维护每个 $i$ 位置上，$a_i-i \times v$ 的值，每次找到 $[i+1,i+k-1]$ 的最大值，将它加上 $i \times v$，即可得到答案。由于最大值加的东西都是只和 $i$ 有关，所以可以放心维护。

但是注意到这并不是最终结果，因为 $b$ 数组依然有影响。所以我们考虑线段树同时维护最大值的位置。我们每次找最大值的时候，如果有多个相同的，那么就取 $a$ 最小的那个的位置。然后判断一下取出来的最大值和那个 $a$ 值的大小关系，如果比它小那么答案就加一。

复杂度 $O(n \log n)$。

## 代码

[Code](https://www.luogu.com.cn/paste/h609x83m)

其实感觉这道题离线下来我那个做法可以单调队列做，但是我比较懒所以没写。qwq

---


# 不灭「不死鸟之尾」

## 题目背景

不死鸟之尾，一种量产型的羽毛。可用作药品。

虽说是量产型，可是从哪里可以得到这种万能之药呢？

## 题目描述

有一个包含 $n$ 个停车位的停车场，里面的停车位排成了一排，最左边和最右边都是墙壁。

有 $n$ 辆车要按顺序依次停入这个停车场，在停入第 $i$ 辆车时，这辆车要停入的位置左右两边的空位越多，停进去需要的时间也就会越少，具体地，如果其左边连续的空位数量为 $l$，其右边连续的空位数量为 $r$，那么停入该辆车所需时间为 $W_i-L_i\cdot l-R_i\cdot r$，其中 $W_i,L_i,R_i$ 会给出（特别的，停车所需要的时间不会是负数，所以我们保证 $W_i\ge L_i\cdot n+R_i\cdot n$）。

对于连续空位的解释：例如，下图中箭头所指位置左边连续空位为 $1$，右边连续空位为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/s1zpjfnq.png)

请依次确定每一辆车停入的位置，使得停入所有车所需时间最小。

## 说明/提示

#### 样例解释 1

第 $1$ 辆车停入从左往右数第 $3$ 个停车位，此时该停车位左边有 $2$ 个连续空位，右边没有连续空位，所需时间 $18-1\times 2-1\times 0=16$。

第 $2$ 辆车停入从左往右数第 $1$ 个停车位，此时该停车位左边没有连续空位，右边有 $1$ 个连续空位，所需时间 $20-2\times 0-4\times 1=16$。

第 $3$ 辆车停入从左往右数第 $2$ 个停车位，此时该停车位左右都没有连续空位，所需时间 $22-3\times 0-3\times 0=22$。

停入所有车需要时间 $16+16+22=54$。

#### 数据范围

对于所有数据，保证 $1\le n\le 10^5$，$0\le L_i,R_i\le 10^5$，$nL_i+nR_i\le W_i\le 2\times 10^{10}$。

## 样例 #1

### 输入

```
3
18 20 22
1 2 3
1 4 3```

### 输出

```
54```

# 题解

## 作者：gyyyyx (赞：12)

[题面](https://www.luogu.com.cn/problem/P9209)

首先我们思考一段长为 $len$ 的**连续空位**停**一辆车**的最小时间。

如果这辆车**停在两侧**，那最小时间显然是 $w_i-(len-1)\max(l_i,r_i)$。

不妨设 $l_i\leq r_i$，那**停在两侧的最优解**是停在最左边，时间为 $w_i-(len-1)r_i$。

如果这辆车右移 $x$ 个车位，那时间将会变成 $w_i-x\cdot l_i-(len-1-x)r_i=w_i-(len-1)r_i+x(r_i-l_i)$。

因为 $l_i\leq r_i,x>0$，所以 $x(r_i-l_i)\geq 0$，那这样时间肯定**不会减少**，看得出来一段长度为 $len$ 的**连续空位**停**一辆车**的最小时间为 $w_i-(len-1)\max(l_i,r_i)$。

那是否有可能这样子贪心的停在两侧会影响到后面，或者说有没有情况使得某一辆车不停在两侧能让时间减少。

我们发现当 $w,l,r$ 不变时，$len$ 越大，时间越小。

而刚好，停在两侧的情况能保证一直都只有一段连续车位，长度 $len$ 从 $n$ 开始不断减一，使得 $len$ 一直是最大的。

那就好办了，一直贪心取下去就行。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 100005
using namespace std;
int n;LL W[N],L[N],R[N],ans;
int main(){
	scanf("%d",&n);
	for(int i(1);i<=n;++i) scanf("%lld",&W[i]);
	for(int i(1);i<=n;++i) scanf("%lld",&L[i]);
	for(int i(1);i<=n;++i) scanf("%lld",&R[i]);
	for(int i(1);i<=n;++i) ans+=W[i]-(n-i)*max(L[i],R[i]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：hjqhs (赞：5)

我们需要 $W_i-L_i \times l-R_i \times r$ 最小，就是让 $L_i \times l+R_i \times r$ 尽量大。显然当 $L_i \ge R_i$ 时应让 $l$ 尽量大，即放在最右边。反之放在最左边。由于每次放要么是最左，要么是最右，可以得到中间没有车的空车位是连续的，且仅有中间一段会没有停车，左右两侧必然已全部停满车，所以第 $i$ 次停车时 $l=n-i$ 或者 $r=n-i$。
```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define per(i,a,b) for(int i=b;i>=a;--i)
#define pv(i,p) for(int i=0;i<p.size();++i)
#define ptc putchar
#define il inline
#define reg register
// #define push_back pb
#define mp make_pair
#define eb emplace_back
#define ret; return 0;
using namespace std;
const int N=100005;
const int MOD=998244353;
const int INF=0x3f3f3f3f3f3f3f3f;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
int Max(int a,int b){return a>b?a:b;}
int MAX(int a,int b,int c){return Max(a,Max(b,c));}
int Min(int a,int b){return a<b?a:b;}
int MIN(int a,int b,int c){return Min(a,Min(b,c));}
int Swap(int&a,int&b){int tmp=a;a=b;b=tmp;}
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int n,w[N],l[N],r[N],ans;
void solve(){
	n=read();
	for(int i=1;i<=n;++i)w[i]=read();
	for(int i=1;i<=n;++i)l[i]=read();
	for(int i=1;i<=n;++i)r[i]=read();
	for(int i=1;i<=n;++i){
		int maxD=Max(l[i],r[i]);
		ans+=(w[i]-maxD*(n-i));
	}
	cout<<ans;
}
signed main(){
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```

---

## 作者：wuyixiang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9209)

题目大意：要将 $n$ 辆车按顺序停在 $n$ 个停车位中，对于第 $i$ 辆车，如果当时停放时左边有连续 $l$ 个空位，右边有连续 $r$ 个空位，那么它将需要 $W_i - l \times L_i - r \times R_i$ 点时间停放。问如何停放，才能让总耗时最少。

思路：一道非常简单的贪心。如果 $L_i$ 比 $R_i$ 大，那么肯定停在最右边的位置才能使停车时间最少；否则就停在最左边。如果以这种方案，那么肯定最后只剩下中间若干个空位没停车，所以空余的车位都是连续的，所以停在最左边或最右边时，旁边的空余车位肯定是 $n - i$ 个。那么计算公式就已经出来了，直接输出即可。

### AC code:

```cpp
#include <iostream>
using namespace std;
long long n,w[100006],l[100006],r[100006],ans;
int main()
{
    cin >> n;
    for(int i = 1;i <= n;i ++)cin >> w[i];
    for(int i = 1;i <= n;i ++)cin >> l[i];
    for(int i = 1;i <= n;i ++)
    {
        cin >> r[i];
        if(l[i] > r[i])swap(l[i],r[i]);//取最大值
        ans += (w[i] - (n - i) * r[i]);//计算
    }
    cout << ans;
}
```

提醒：$W_i \le 2 \times 10^{10}$，请记得开 `long long`。

---

## 作者：Daniel_yao (赞：1)

## Problem 
有 $n$ 个车位和车，要将所有的车都停到车位上。如果一辆车要停入的位置左右两边的空位越多，停进去需要的时间也就会越少。具体地，如果其左边连续的空位数量为 $l$，其右边连续的空位数量为 $r$，那么停入该辆车所需时间为 $W_i-L_il-R_ir$。最小化总停车时间。
## Solve
要最小化总时间，那么就要最小化单个车的停车时间。对于一辆车，可以证明停在最靠左/右有空位的地方是最优的。因为对于 $l$ 和 $r$ ，是有后效性的。假设前一辆车没有放在最左/右边，那么下一次的 $l,r$ 的范围会缩小，这样显然不是最优的。如果使 $l$ 或 $r$ 的其中一个为 $0$，空位区间将达到最大。跟其他的构造方案相比，显然不会更劣。（感性理解一下）
对于单个停车时间，都选择最优方案，并且保证 $l,r$ 无后效性。则总时间一定是最优的。
每一次按最优决策操作，记录总时间。
## Code
```cpp
#include <bits/stdc++.h>
#define int long long
#define H 19260817
#define rint register int
#define For(i,l,r) for(rint i=l;i<=r;++i)
#define FOR(i,r,l) for(rint i=r;i>=l;--i)
#define MOD 1000003
#define mod 1000000007

using namespace std;

inline int read() {
  rint x=0,f=1;char ch=getchar();
  while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
  return x*f;
}

void print(int x){
  if(x<0){putchar('-');x=-x;}
  if(x>9){print(x/10);putchar(x%10+'0');}
  else putchar(x+'0');
  return;
}

const int N = 1e5 + 10;

int n, w[N], l[N], r[N], ans;

signed main() {
  n = read();
  For(i,1,n) w[i] = read();
  For(i,1,n) l[i] = read();
  For(i,1,n) r[i] = read();
  For(i,1,n) ans += min(w[i] - (n - i) * l[i], w[i] - (n - i) * r[i]);
  cout << ans << '\n';
  return 0;
}


---

## 作者：bryce (赞：1)

## 思路分析
讨论只有一个车的情况，如果 $L_i \ge R_i$，那么要使 $W_i-L_i\times l-R_i\times r$ 最小，停在最左边肯定是最优的，反之就停在最右边。

把上面那个转换为一般情况，也就是每个车判断 $L_i$ 与 $R_i$ 的大小情况，每次选择停在左边或者是右边。
## 代码
```cpp
#include<iostream>
#define int long long

using namespace std;

inline int read(){register int x = 0, f = 1;register char c = getchar();while (c < '0' || c > '9'){if (c == '-') f = -1;c = getchar();}while (c >= '0' && c <= '9'){x = (x << 1) + (x << 3) + (c ^ 48);c = getchar();}return x * f;}
inline void write(int x){if (x < 0) putchar('-'), x = -x;if (x > 9) write(x / 10);putchar(x % 10 + '0');}

const int N = 1e5 + 10;
int n, ans;
int w[N], l[N], r[N];

signed main(){
	n = read();
	for (int i = 1; i <= n; i++) w[i] = read();
	for (int i = 1; i <= n; i++) l[i] = read();
	for (int i = 1; i <= n; i++) r[i] = read();
	for (int i = 1; i <= n; i++) ans += w[i] - max(l[i], r[i]) * (n - i);
	cout << ans;
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：1)

？

考虑这样一个情况：将某一辆车辆车停在 $[l,r]$ 区间内的最小花费，区间内保证没有其他车。

这样一定就是停在左端点或者是右端点中系数更大的那边。

那放到原问题中也可以这样做，因为每一次停车的时候都是一整段空区间。

```cpp
const int N=1e5+3;
int n,ans,a[N],b[N],c[N];
void Solve()
{
	rd(n);
	for(re int i=1;i<=n;++i) rd(a[i]);
	for(re int i=1;i<=n;++i) rd(b[i]);
	for(re int i=1;i<=n;++i) rd(c[i]);
	for(re int i=1;i<=n;++i) ans+=a[i]-std::max(b[i],c[i])*(n-i);
	prt(ans,'\n');
	return;
}
```

---

## 作者：Penguin_Chen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9209)

~~钦定了停车顺序这不就是大水题吗？~~
### 结论
对于第 $i$ 辆车，$l_i$ 大就靠左停，$r_i$ 就靠右停。
### 证明
首先，向两边停车可以使得对于**任意一辆**车在停车时，两边的连续空车位之和最大。

其次，对于第 $i$ 辆车，假设 $l_i>r_i$，显然，$l_i\times len_i$（$len_i$ 为两边的连续空车位之和）大于 $l_i\times k+r_i\times (len_i-k)$（$1\le k<len_i$），$r_i>l_i$ 时同理。

所以，$ans=\sum\limits_{i=1}^nW_i-\max(l_i,r_i)\times (n-i)$。
### Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e6+1;
int n,ans;
int w[maxn];
int l[maxn];
int r[maxn];
signed main()
{
	std::ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;++i)cin>>w[i];
	for(int i=1;i<=n;++i)cin>>l[i];
	for(int i=1;i<=n;++i)cin>>r[i];
	for(int i=1;i<=n;++i)
		ans+=w[i]-max(l[i],r[i])*(n-i);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：qiuzijin2026 (赞：0)

# P9209 不灭「不死鸟之尾」

## [题面](https://www.luogu.com.cn/problem/P9209)

## 思路

使用贪心。

对于第 $i$ 辆车，设他可以停在区间长度为 $len$。

则他的 $l$ 与 $r$ 的和是一定的。

由第 $i$ 辆车停入所需时间为 $w(i)-L(i)\times l-R(i)\times r$ 可知，
停在 $L(i)$ 与 $R(i)$ 中大的一侧一定更优，最小值为 $w(i)-\max(L(i),R(i))\times (len-1)$。

由于一定停在一侧，所以第 $i$ 辆车可以停的区间长度为 $n-i+1$。

最后枚举每一个 $i$ 即可。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
long long w[100005];
long long l[100005];
long long r[100005];
long long ans;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++) scanf("%lld",&w[i]);
	for(long long i=1;i<=n;i++) scanf("%lld",&l[i]);
	for(long long i=1;i<=n;i++) scanf("%lld",&r[i]);
	for(long long i=1;i<=n;i++) ans+=w[i]-max(l[i],r[i])*(n-i);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ダ月 (赞：0)

### 题目分析：

对于当前车要停到长度为 $n$ 的连续空位，左代价为 $L_i$，右代价为 $R_i$，那么当前选择第 $j$ 个位置，答案为 $(j-1)\times L_i+(n-j)\times R_i$。

化简一下，得到答案为 $j\times(L_i-R_i)-L_i+nR_i$。显然 $-L_i,nR_i$ 和 $L_i-R_i$ 为定值。所以取得最小时与 $j$ 有关。此时最小值显然是 $j$ 取最左端或者最右端的时候最小。简单地分类讨论一下就能出答案。


### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
//===
//缺省元
//===
int n;
ll w[N];
ll l[N],r[N];
ll ans=0;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)cin>>w[i];
	for(int i=1;i<=n;i++)cin>>l[i];
	for(int i=1;i<=n;i++)cin>>r[i];
	for(int i=1;i<=n;i++){
		ll cl=(n-i)*r[i],cr=(n-i)*l[i];
		if(cl>cr)ans+=w[i]-cl;
		else ans+=w[i]-cr;
	}printf("%lld\n",ans);
	return 0;
}
```
时间复杂度：$O(n)$。

---

## 作者：Wind_Smiled (赞：0)

## 题意

给定 $W_i,L_i,R_i$，要求查询一个数 $l$，使 $W_i-L_i \times l-R_i \times (n-l-1)$ 最小（$n$ 为剩余空位），并输出这个最小值。

### 贪心

设 $L_i \times l+R_i \times (n-l-1)=y_i$，则总花费为 $W_i-y_i$。

化简得 $y_i=(L_i-R_i) \times l+(n-1) \times R_i$

使花费最小，故令 $y_i$ 最大。

1.当 $L_i>R_i$ 时

该函数的 $k>0$，即 $y_i$ 随 $l$ 的增大而增大，故使 $l$ 尽可能大，即选择最右侧的空位，此时 $l=n-1$，则 $y_i=(n-1) \times L_i$

2.当 $L_i<R_i$ 时

该函数的 $k<0$，即 $y_i$ 随 $l$ 的增大而减小，故使 $l$ 尽可能小，即选择最左侧的空位，此时 $l=0$，则 $y_i=(n-1) \times R_i$

3.当 $L_i=R_i$ 时

函数无意义，取值与 $l$ 无关。但是为了后面的剩余连续空位最大，还是选择最左或最右的。

由于前两种情况都含有 $(n-1)$，故合并得最终解为：

$y=(n-1) \times \max(L_i,R_i)$

此时的 $n$ 是剩余空位，要使在循环中可以直接选用则需要将 $n$ 修改为 $n-i+1$，则：

$y=(n-i) \times \max(L_i,R_i)$

### 提示
数据范围 $nL_i+nR_i\le W_i\le 2\times 10^{10}$，要开 `long long`。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long w[100005],l[100005],r[100005];
long long ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&w[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&l[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&r[i]);
	}
	for(int i=1;i<=n;i++){
		ans+=(w[i]-(n-i)*max(l[i],r[i]));//代入公式
	}
	printf("%lld",ans);
	return 0;
}
```

---


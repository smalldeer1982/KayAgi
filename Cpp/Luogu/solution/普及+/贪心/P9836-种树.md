# 种树

## 题目背景

小 Rf 不是很喜欢种花，但是他喜欢种树。

## 题目描述

路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \dots p_n$。

定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。

于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。

你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。

## 说明/提示

**【样例 1 解释】**

+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。
+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。
+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。

---

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

---

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

---

**【数据范围】**

| 测试点编号 | $n \leq$ | $p_i$ | $w$ | 单点分值 |
| :--------: | :------: | :---: | :---: | :------: |
| $1 \sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |
| $6 \sim 10$ | $10^4$ | $\leq 10^4$ | $=1$ | $3$ |
| $11 \sim 15$ | $1$ | $\leq 10^4$ | $\leq 10^4$ | $3$ |
| $16 \sim 20$ | $5$ | $\leq 10^4$ | $\leq 10^4$ | $6$ |
| $21 \sim 25$ | $10^4$ | $\leq 10^4$ | $\leq 10^4$ | $7$ |

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq p_i \leq 10^4$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
3 60
8 243 250```

### 输出

```
2304```

# 题解

## 作者：樱雪喵 (赞：45)

首先看到因数个数，想到在质因数分解后的序列上考虑问题。进一步观察，每个不同质因子的贡献是独立的。

也就是说，我们单独考虑某一个质因子对答案的贡献，是这样的问题：
>给长度为 $n$ 的序列 $a$ 和一个数 $w$，每次操作你可以选择一个 $i$，令 $a_i\gets a_i+1$，可以重复选择同一个位置。至多操作 $w$ 次，最大化 $\prod\limits_{i=1}^n a_i$。

这是一个经典问题，容易证明每次贪心操作最小值是最优的。数据范围放了 $O(n^2)$ 通过，所以怎么实现都行。

```cpp
#define int long long
const int N=1e4+5,mod=998244353;
int n,w;
int a[N],cnt[N],ans=1;
priority_queue<int,vector<int>,greater<int> >q;
il void solve(int x,int sum)
{
    for(int i=1;i<=n;i++)
    {
        cnt[i]=1;
        while(a[i]%x==0) cnt[i]++,a[i]/=x;
        q.push(cnt[i]);
    }
    while(sum) 
    {
        int x=q.top(); q.pop();
        q.push(x+1),sum--;
    }
    for(int i=1;i<=n;i++) ans=ans*q.top()%mod,q.pop();
}
signed main()
{
    n=read(),w=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=2;i*i<=w;i++) 
        if(w%i==0)
        {
            int now=0;
            while(w%i==0) now++,w/=i;
            solve(i,now);
        }
    if(w>1) solve(w,1);
    for(int i=1;i<=n;i++)
    {
        for(int j=2;j*j<=a[i];j++)
        {
            int now=1;
            while(a[i]%j==0) a[i]/=j,now++;
            ans=ans*now%mod;
        }
        if(a[i]>1) ans=ans*2%mod;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：佬头 (赞：17)

## Description
[**种树**](https://www.luogu.com.cn/problem/P9836)：给定 $n$ 个正整数 $p_1, p_2,\dots,p_n$ 和 $w$，请你将每个 $p_i$ 扩大 $d_i~(d_i\ge1)$ 倍并且 $(\prod_{i=1}^{n}d_i)=w$。设 $g_i$ 表示 $p_i$ 的正因数个数，求出最大化的 $\prod_{i=1}^{n}g_i$，并对 $998244353$ 取模。

## Solution
我们可以先将每个 $p$ 质因数分解一下：$p=\prod_{i=1}^{m}a_i^{k_i}$（$k_i\ge1$ 且 $a_i$ 为互不相同的质数）。不难想到 $g=\prod_{i=1}^{m}k_i+1$（每个 $a$ 的次数有 $k+1$ 种取法）。

然后我们再将 $w$ 进行质因数分解，对于 $w$ 的质因数 $a$，将他乘给 $p_i$ 后对答案增加的贡献是 $\frac{\prod_{i=1}^{n}g_i}{k+1}$。$k$ 是 $p_i$ 进行质因数分解后 $a$ 的指数，当然 $k$ 也可以是 $0$，此时 $a$ 不是 $p_i$ 的质因数。

至于贡献是怎么来的，显然 $\prod_{i=1}^{n}g_i$ 是很多个 $(k+1)$ 相乘的形式，我们将 $a$ 乘进去后，有且仅有一个 $(k+1)$ 会增大 $1$，很明显贡献就是 $\prod_{i=1}^{n}g_i$ 除以那个增大的 $(k+1)$。

显然 $k$ 越小造成的贡献越大，那么**贪心**思路就是每次把 $w$ 的一个质因数 $a$ 乘给质因数分解后 $a$ 的指数最小的 $p$（如果 $\exists~p_i,~p_i\bmod a\ne0$，则优先把 $a$ 乘给 $p_i$）。观察到 $n,p,w$ 的范围都很小，关于找质因数 $a$ 的最小指数可以直接开 $N$ 个小根堆。最后把所有堆中的元素乘起来即可。

笔者的代码时间复杂度为 $\mathcal O(n\sqrt n\log n)$。

## Code
```cpp
#include <iostream>
#include <queue>
using namespace std;
const int N = 10004, mod = 998244353;
int n, w, ans = 1;
priority_queue <int, vector <int>, greater <int>> k[N];
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(int x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	n = read(), w = read();
	for(int i = 1, p, cnt; i <= n; ++ i){
		p = read();
		if(p & 1 ^ 1){ //p%2==0
			for(cnt = 0; p & 1 ^ 1; p >>= 1, ++ cnt);
			k[2].push(cnt);
		}
		for(int j = 3; j * j <= p; j += 2)
			if(p % j == 0){
				for(cnt = 0; p % j == 0; p /= j, ++ cnt);
				k[j].push(cnt);
			}
		if(p > 1) k[p].push(1);
	}
	while(w & 1 ^ 1){
		w >>= 1;
		if(k[2].size() < n) k[2].push(1);
		else k[2].push(k[2].top() + 1), k[2].pop();
	}
	for(int i = 3; i * i <= w; i += 2)
		while(w % i == 0){
			w /= i;
			if(k[i].size() < n) k[i].push(1);
			else k[i].push(k[i].top() + 1), k[i].pop();
		}
	if(w > 1){
		if(k[w].size() < n) k[w].push(1);
		else k[w].push(k[w].top() + 1), k[w].pop();
	}
	while(!k[2].empty()) ans = (long long)ans * (k[2].top() + 1) % mod, k[2].pop();
	for(int i = 3; i < N; i += 2) while(!k[i].empty()) ans = (long long)ans * (k[i].top() + 1) % mod, k[i].pop();
	write(ans);
	return 0;
}
```
$\texttt{2023 年 11 月 26 日 update:}$ 修正了 LaTeX 的格式。

---

## 作者：EmptyAlien (赞：9)

# $\text{Solution}$

由小学奥数得：

若：
$$
n = p_1^{\alpha_1} \cdot p_2^{\alpha_2}\cdot p_3^{\alpha_3} \cdot \cdots \cdot p_k^{\alpha_k}
$$
则：
$$
τ(n) = (\alpha_1 + 1)(\alpha_2 + 1) \cdots (\alpha_k + 1)
$$

所以若确定了 $\{p\}$，就可以直接算出：
$$
Ans = (\alpha_{p_1, 1} + 1) \cdots (\alpha_{p_1, {p_1}_k} + 1)(\alpha_{p_2, 1} + 1) \cdots 
$$

容易想到，我们没有必要一次性施好多肥，我们可以把 $w$ 分解质因数，然后一个质因数，一个质因数地施肥。

然后， 我们发现，对于质数 $p$，找到相应 $p_t$ 的指数越小，贡献越大（指数越小，相应 $p^\alpha$ 更小，剩下的部分最大）

所以，思路就出来了

对 $w$ 做质因数分解，把每一个质因数最大化自己的贡献，再计算即可

# $\text{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 5;
const int MOD = 998244353;
int n, w;
int p[MAXN];

int calc(int x, int p) {
    int cnt = 0;
    while (x % p == 0)
        x /= p, cnt++;
    return cnt;
}

long long t(long long n) {
    long long res = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int cnt = 1;
            while (n % i == 0) {
                n /= i;
                cnt++;
            }
            res = res * cnt % MOD;
        }
    }
    if (n > 1)
        res = res * 2 % MOD;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> w;
    for (int i = 1; i <= n; i++)
        cin >> p[i];

    for (int x = 2; x * x <= w; x++) {
        while (w % x == 0) {
            int mn = INF, mnx;
            for (int i = 1; i <= n; i++) {
                if (calc(p[i], x) < mn) {
                    mn = calc(p[i], x);
                    mnx = i;
                }
            }
            p[mnx] *= x;
            w /= x;
        }
    }

    if (w != 1) {
        int mn = INF, mnx;
        for (int i = 1; i <= n; i++) {
            if (calc(p[i], w) < mn) {
                mn = calc(p[i], w);
                mnx = i;
            }
        }
        p[mnx] *= w;
        w /= w;
    }

    long long res = 1;
    for (int i = 1; i <= n; i++) {
        // cerr << p[i] << endl;
        res = res * t(p[i]) % MOD;
    }
    cout << res << endl;

    return 0;
}
```

# $\text{PS}$

- $ τ(n) $ 为正整数 $n$ 的所有正因子个数

---

## 作者：Night_sea_64 (赞：6)

题目质量挺好的，思维题。

假设 $x$ 分解质因数是 $p_1^{q_1}p_2^{q_2}\dots p_m^{q_m}$（$p_1\sim p_m$）均为质数，则它的正因数个数为 $(q_1+1) (q_2+1)\dots(q_m+1)$。因为每个质因数的选法都有它的个数 $+1$ 种。

因此，$w$ 的神奇肥料全都用完。对于 $w$ 的每个质因数都单独决策用在哪个树上。这就相当于把某个数的这个质因数个数 $+1$。显然需要用在这种质因数个数最少的树上。不清楚用优先队列维护会不会炸掉，所以我用桶排序解决这个问题。我的时间复杂度是 $O(nk)$（$k$ 为 $10000$ 以内的质数个数，$1200$ 多一点）。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#define int long long
using namespace std;
int n,w,p[1300],cur,c[1300][30],minn[1300],ans=1;
const int mod=998244353;
bool prime(int x)
{
    if(x<=1)return 0;
    for(int i=2;i*i<=x;i++)
        if(x%i==0)return 0;
    return 1;
}
signed main()
{
    for(int i=1;i<=10000;i++)
        if(prime(i))p[++cur]=i;
    memset(minn,999999,sizeof(minn));
    cin>>n>>w;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        for(int j=1;j<=cur;j++)
        {
            int cnt=0;
            while(x%p[j]==0)x/=p[j],cnt++;
            c[j][cnt]++,minn[j]=min(minn[j],cnt);
        }
    }
    for(int i=1;i<=cur;i++)
        while(w%p[i]==0)
        {
            w/=p[i];
            c[i][minn[i]]--,c[i][minn[i]+1]++;
            if(!c[i][minn[i]])minn[i]++;
        }
    for(int i=1;i<=cur;i++)
        for(int j=1;j<30;j++)
            for(int k=1;k<=c[i][j];k++)
                ans=ans*(j+1)%mod;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：_HiKou_ (赞：3)

赛时写了个特判想稳部分分，但是发现打挂了痛失 3 分...

可以注意到，每个数的正因子其实就是质因子的不同组合形式。

比如 $2 \times 3 \times 3\times 5 = 90$，可以发现，所有因数可以如此得到：

|每个质因子的数量|2|3|5|
|:-:|:-:|:-:|:-:|
|1|0|0|0|
|5|0|0|1|
|3|0|1|0|
|15|0|1|1|
|9|0|2|0|
|45|0|2|1|
|2|1|0|0|
|10|1|0|1|
|6|1|1|0|
|30|1|1|1|
|18|1|2|0|
|90|1|2|1|

可以看出，质因子的数量取决于每个质因子的数量搭配。若第 $i$ 个质因子数量为 $a_i$，则第 $i$ 个质因子可以有 $0-a_i$ 共 $i+1$ 种选择。根据乘法原理，因子数即为 $\prod_{i=1}^{cnt}a_i+1$，其中 $cnt$ 为质因子数量。

接下来就是如何存这些数据的问题。由于 $1\le p_i \le 10^4$，$2 \times 3 \times 5\times 7\times11\times13=30030 > 10000$ 可得一个数不同质因数数量不会超过 $6$，所以干脆开个结构体存质因数和他们的数量好了。

接下来考虑施肥操作。因为施肥的 $k$ 必须是肥料总量 $w$ 的因数，当然可以想到一样把它质因数分解。给一棵树施 $k$ 单位肥等价于给一棵树施肥 $d$ 次，且每次施肥的乘积等于 $k$。然后以质因数为单位施肥就好。注意将肥料用完一定最优，因为肥料一定有贡献。

接下来考虑每个数对答案的贡献。一棵树被施肥，即这棵树对应的质因子 $+1$。对答案的贡献为 $\dfrac{a_i+1}{a_i}$，显而易见的，当 $a_i$ 最小时贡献最大，所以贪心一下即可。

最后注意不要实时更新答案，因为有 $\bmod$ 操作。操作完在最后统计答案就好。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,w;
ll p[11451];
struct CUN{
	ll pr[30],c[30],cnt;//质因数，每个质因数的数量，不同质因数总数
}z[11451],hf;
ll ans=1;//注意初始化
ll mod=998244353;
int main(){
	scanf("%lld%lld",&n,&w);
	for(ll i=1;i<=n;i++)scanf("%lld",&p[i]);
	ll xd=0;
	ll qwq;
	for(ll i=1;i<=n;i++){
		qwq=p[i];
		for(ll j=2;j*j<=p[i];j++){
			xd=0;
			while(qwq%j==0)xd++,qwq/=j;//质因数分解
			if(xd!=0){
				z[i].pr[++z[i].cnt]=j;
				z[i].c[z[i].cnt]=xd;
			}
			if(qwq==1)break;
		}
		if(qwq!=1){//注意本身是质数情况
			z[i].pr[++z[i].cnt]=qwq;
			z[i].c[z[i].cnt]=1;
		}
	}
	
	qwq=w;//对化肥数量质因数分解
	for(ll j=2;j*j<=w;j++){
		xd=0;
		while(qwq%j==0)xd++,qwq/=j;
		if(xd!=0){
			hf.pr[++hf.cnt]=j;
			hf.c[hf.cnt]=xd;
		}
		if(qwq==1)break;
	}
	if(qwq!=1){
		hf.pr[++hf.cnt]=qwq;
		hf.c[hf.cnt]=1;
	}
	
	//可怕的四重循环 但是复杂度不会爆炸哦
	for(ll i=1;i<=hf.cnt;i++){
		ll now=hf.pr[i];
		for(ll j=1;j<=hf.c[i];j++){
			ll minn=0x3f3f3f3f,pos=0;//找最小a[i]
			for(ll k=1;k<=n;k++){
				ll ct=0;
				for(ll x=1;x<=z[k].cnt;x++){
					if(z[k].pr[x]==now){
						ct=z[k].c[x];
						break;
					}
				}
				if(ct<minn){
					minn=ct;
					pos=k;
				}
			}
			if(minn==0){
				z[pos].cnt++;
				z[pos].pr[z[pos].cnt]=now;
				z[pos].c[z[pos].cnt]=1;
			}//出现新的质数
			else for(ll x=1;x<=z[pos].cnt;x++){
				if(z[pos].pr[x]==now){
					z[pos].c[x]++;
					break;
				}
			}//原有的质数直接加就行
			
		}
	}
	
	for(ll k=1;k<=n;k++){
		for(ll x=1;x<=z[k].cnt;x++){
			ans*=(z[k].c[x]+1);
			ans%=mod;//统计答案
		}
	}
	printf("%lld",ans);//完结撒花
	return 0;
} 
```

---

## 作者：快斗游鹿 (赞：3)

首先先将每个数都进行质因数分解，将原数变为 $p_1^{a_1}p_2^{a_2}\dots p_n^{a_n}$ 的形式，在本题中，我们认为 $p_i$ 是质数，$a_i$ 均为**非负整数**，则该数因子个数为 $(a_1+1)(a_2+1)\dots(a_n+1)$。将所有数操作完后，发现答案形式就是 $(a_1+1)(a_2+2)(a_3+1)\dots(a_{m-1}+1)(a_m+1)$，接着考虑对每个数乘 $k$ 的操作，它的本质就是把 $k$ 也进行质因数分解，并将原数对应的质因子个数加一。容易发现每个质因子贡献是独立的，而显然每次把出现次数最少的质因子个数加一是最优的。因此直接用堆维护就可以了。

为什么是 $a_i$ 不是正整数而是非负整数呢？考虑下面这个例子：

数列为 $3,10$，$w$ 为 $2$。如果限制 $a_i$ 为正整数，那么答案就会变成 $(1+1)(2+1)(1+1)=12$，如果允许 $a_i$ 开始时为 $0$，则答案为 $(1+1)(1+1)(1+1)(1+1)=16$，显然最优。即将 $3$ 乘 $2$，而不是将 $10$ 乘 $2$。

---

## 作者：Isshiki·Iroha (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9836)

[Blog 传送门](https://www.luogu.com.cn/problem/P9836)

## 题解

我们先考虑如何求 $p_i$ 的宽度，首先我们分解质因数。

$$p_i=\prod prime_k^{a_k}(a_k \ge 1)$$

我们发现 $p_i$ 的每一个正因子 $f$ 质因数分解后必然满足

$$f=\prod prime_k^{b_k}(a_k \ge b_k)$$

换句话说，我们对于 $prime_k$ ，可以选 $0,1 \dots,a_k$ 个来组成正因子，那么由乘法原理，$p_i$ 的宽度（设为 $c_i$）就为:

$$c_i=\prod\ (a_k+1)$$

那么不进行施肥的答案就是:
$$Ans=\prod^n_{i=1}c_i$$
$a_k$ 就是第一个式子里面的数，现在我们可以将 $w$ 分出一个正因子，乘上 $p_i$ ，再重新计算宽度。我们考虑最简单的情况，每次只乘上一个 $w$ 的质因子。那么就相当于对应的 $a_k$ 加 $1$，那么由上面的式子，新的答案就是

$$c'_i=\frac{c_i}{a_k+1}\times (a_k+2)$$

那么对应的，答案就变为原来的 $\frac{a_k+2}{a_k+1}$ 倍，我们发现这与你选的哪个数字无关，只和这个数字所包含的该质因子的个数有关。又因为 $w$ 的正因子都是由 $w$ 的质因子相乘得出的，所以一次性乘上正因子和分开乘质因子是没有关系的。

我们再发现

$$\frac{a_k+2}{a_k+1}=\frac{1}{a_k+1}+1$$

所以 $a_k$ 最小答案增加得越大，这启示我们对于先将 $w$ 质因数分解后，对于每一个质因数，按照每一个 $p_i$ 拥有的该质因数的个数从小到大排序，再依次每个数**分配 $1$ 个**。不过要注意，如果我们先给5个拥有该质因数个数为 $0$ 的都分配了一个，那么记得把这 $5$ 个加到拥有该质因数个数为 $1$ 的里面，最后如果 $w$ 里面的该质因子已经分配完了，就退出就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lll __int128
#define ull unsigned ll
#define ld long double 
#define db double
template<typename T>inline void read(T& x) {
    x=0;int f=1;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=~f+1;ch=getchar();}
    while (isdigit (ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    x*=f;
}
template <typename T,typename... Args> inline void read(T& x, Args&... args) {
    read(x);
    read(args...);
}
template<typename T>inline void write(T x) {
    static int buf[40],top=0;
    if(x<0)putchar('-'),x=~x+1;
    while(x)buf[++top]=x%10,x/=10;
    if(top==0)buf[++top]=0;
    while (top) putchar(buf[top--]^48);
    putchar(' ');
}
template <typename T,typename... Args> inline void write(T x, Args... args) {
    write(x);
    write(args...);
}
const int maxn=1e4+10;
const ll Mod=998244353;
int n,w;
int p[maxn];
vector<int>pr;
int vis[maxn];
ll ans=1;
int ra[maxn];
//表示素数 i 在 pr 里面是第几个
int factor[maxn][1300];//factor[i][j]表示p_i 拥有factor[i][j]个第j个素数
vector<pair<int,int>>F;
inline ll ksm(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1)res=res*a%Mod;
        a=a*a%Mod;b>>=1;
    }
    return res;
}
ll c[maxn];
int main(){
    read(n,w);
    for(int i(2);i<=10000;++i){
        //素数筛
        if(vis[i]==0)pr.emplace_back(i),ra[i]=pr.size();
        for(int j:pr){
            if(i*j>10000)break;
            vis[i*j]=1;
            if(i%j==0)break;
        }
    }
    for(int i(1),temp(0);i<=n;++i){
        read(p[i]); c[i]=1;
        temp=p[i];
        for(int j:pr){
            //分解质因数
            if(1ll*j>temp)break;
            if(temp%j==0){
                int cnt=0;
                while(temp%j==0){
                    temp/=j;
                    ++cnt;
                }
                factor[i][ra[j]]=cnt;
                c[i]=c[i]*(cnt+1)*1ll%Mod;
                //计算答案
            }
        }
        ans=ans*c[i]%Mod;
    }
    {
        int temp=w;
        for(int j:pr){
            if(1ll*j>temp)break;
            if(temp%j==0){
                int cnt=0;
                while(temp%j==0){
                    temp/=j;
                    ++cnt;
                }
                F.emplace_back(j,cnt);
                //w的质因数 j,个数为cnt
            }
        }
    }
    for(pair<int,int> temp:F){
        vector<int>Q(41,0);
        //其实不用开这么大，最多拥有的同一个质因数个数不超过 log2(1e4)
        for(int i(1);i<=n;++i){
            Q[factor[i][ra[temp.first]]]++;
            //计数
        }
        for(int i(0);i<=39;++i){
            if(temp.second>=Q[i]){
                //如果够，就全部做了
                temp.second-=Q[i];
                Q[i+1]+=Q[i];//记得加到下一个，因为现在又分配了一个
                ans=(ans*ksm((i+2)*1ll*ksm(i+1,Mod-2),Q[i])%Mod);
                //里面的ksm的意思是求 (i+2)/(i+1) 模意义下的值，外面的是你分配了 Q[i] 个，应该乘 Q[i] 次，就是 Q[i] 次方
            }
            else {
                ans=(ans*ksm(i+2,temp.second)%Mod*ksm(ksm(i+1,Mod-2),temp.second)%Mod);
                break;
            }
        }
    }
    write(ans);
    return 0;
//为什么 BLG 打不赢 WBG !!!
//为什么 BLG 打不赢 WBG !!!
//为什么 BLG 打不赢 WBG !!!
//为什么 BLG 打不赢 WBG !!!
//为什么 BLG 打不赢 WBG !!!
}
```




---

## 作者：Crsuh2er0 (赞：2)

简要题意：

给出 $n$ 个数，再给你一个数 $w$，你可以把 $n$ 个数中某些数乘上 $w$ 的因数 $p$，但同时 $w ← w/p$，最大化这些数的因数个数的乘积。

## Solution

简单数学 + 贪心。

观察题目，不难想到除数函数：

给定 $a = p_{1}^{a_1}p_{2}^{a_2}\cdots p_{s}^{a_s}$，则 $a$ 的所有正因数的个数为 $\tau(a) = (a_1 + 1)(a_2 + 1)\cdots(a_s + 1)$。

显然，问题转化为：给定 $a_1 \times a_2 \times \cdots \times a_s $，你可以给其中的一些特定因式加上 $1$，最大化这个式子的值。

显然，若 $a_i < a_j$ 则 $(a_i + 1) * a_j > (a_j + 1) * a_i$ 。

因此，我们应尽量「均分」 $w$ 的每个质因子给 $p_i$，才能使乘积最大。

具体地，在遍历 $w$ 的每个质因子 $b_i$，其次数为 $t_i$，我们定义 $req \leftarrow 1$，然后遍历 $p$ 数组。

对于每个 $p_i$，我们假设 $cnt_i$ 为其质因子 $b_i$ 的次数，则若 $cnt_i < req$，我们则给 $cnt_i \leftarrow cnt_i + 1,t_i \leftarrow t_i - 1$。若执行操作后 $t_i = 0$ 则跳出循环。

若遍历完 $p$ 一遍后仍未跳出循环，则 $req \leftarrow req + 1$，再次遍历 $p$。


质因数分解部分用线性筛预处理最小质因子可得到 $O(n \log^2 n)$ 的做法。

若用 `vector` 替代 `map` 可进一步优化为 $O(n \log n)$。

```cpp
#include <bits/extc++.h>
using namespace std;
typedef long long LL;
const int MOD = 998244353, MAXN = 1e4 + 10;
int n, w, p[MAXN], mb[MAXN], idx, prime[MAXN], maxv;
LL ans = 1;
map<int, int> cntp[MAXN], cntw;

void init1() {
    for (int i = 2; i <= maxv; i++) {
        if (!mb[i]) prime[++idx] = i, mb[i] = i;
        for (int j = 1; j <= idx && i * prime[j] <= maxv; j++) {
            mb[i * prime[j]] = prime[j];
            if (!(i % prime[j])) break;
        }
    }
}

void init2() {
    for (int i = 1; i <= n; i++) {
        int tmp = p[i];
        while (tmp > 1) cntp[i][mb[tmp]]++, tmp /= mb[tmp];
    }
    int tmp = w;
    while (tmp > 1) cntw[mb[tmp]]++, tmp /= mb[tmp];
}

int main() {
    cin >> n >> w;
    maxv = w;
    for (int i = 1; i <= n; i++) cin >> p[i], maxv = max(maxv, p[i]);
    init1(), init2();
    for (auto [b, cnt] : cntw) {
        int req = 1;
        while (cnt) {
            for (int i = 1; cnt && i <= n; i++) {
                if (cntp[i][b] < req) cntp[i][b]++, cnt--;
            }
            req++;
        }
    }

    for (int i = 1; i <= n; i++) {
        for (auto [b, cnt] : cntp[i]) {
            ans = (ans * (cnt + 1)) % MOD;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：what_else (赞：2)

## 题目大意

给出序列 $p$ 和正整数 $w$，可以将 $w$ 除以一个其正因子 $r$，选择一个 $p$ 中的数乘上 $r$，求进行若干次操作后所有 $p$ 中数正因子个数乘积的最大值。

## Solution

很容易想到将 $p$ 中每一个数先进行质因数分解，得到 $p_i = a_1^{t_1}a_2^{t_2}\dots a_T^{t_T}$。那么根据数学知识，这个数的质因子个数即为 $(t_1+1)(t_2+1)\dots (t_T+1)$。

考虑将 $w$ 怎样分配到所有的 $p_i$ 上，首先，我们也应将 $w$ 分解为质因数，考虑对于其每一个质因子 $k_i$，如果有 $m_i$ 个，应该怎么去分配。

如果现在，这个质因子 $k_i$，在所有的 $p_j$ 中有 $t_1,t_2, \dots,t_n$ 个，那么我们不难发现，因为答案为所有质因子的乘积，这个质因子 $k_i$ 应该往最小的 $t_j$ 上放，证明如下：

原来未放这个质因子之前，此质因子对答案的贡献为 $F_1=(t_1+1)(t_2+1) \dots(t_n+1)$，那么往最小的数字（假设为 $t_1$）上放后，贡献变为 $F_2=(t_1+2)(t_2+1) \dots(t_n+1)=\frac{F_1}{t_1+1}(t_1+2)$。如果往一个较大的数字上放（假设为 $t_2(t_2>t_1)$），贡献变为 $F_3=(t_1+1)(t_2+2) \dots(t_n+1)=\frac{F_1}{t_2+1}(t_2+2)$。因为有 $\frac{t_2+2}{t_2+1} < \frac{t_1+2}{t_1+1}$，所以 $F_2 > F_3$，贪心策略正确。

由于质因子个数在变动，可以用优先队列优化解决，时间复杂度应该是 $O(n\log{n^2})$ 的，具体实现时具有一定的常数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w;
int p[10100];
long long ans = 1;
#define md 998244353
int poi[10010];
bool prime(int x) {
	for(int i=2;i*i<=x;i++) {
		if(x % i == 0) return false;
	}
	return 1;
}
priority_queue <int> q;
int main(){
	scanf("%d%d",&n,&w);
	int diff = 0;
	for(int i=1;i<=n;i++){
		scanf("%d",&p[i]);
		diff = max(diff,p[i]);
	}
	for(int i=2;i<=max(diff,w);i++) {
		if(prime(i)) {
			for(int j=1;j<=n;j++){
				long long gs = 0;
				while(p[j] != 1) {
					if(p[j] % i == 0) {
						p[j] /= i;
						gs ++;
					}
					else break;
				}
				q.push(-gs);//负数可以将大根堆当小根堆用
			}//考虑当前数，有几个质因子
			int will = 0;
			while(w != 1) {
				if(w % i == 0) {
					w /= i;
					will ++;
				}
				else break;
			}//考虑 w
			for(int i=1;i<=will;i++) {
				int now = q.top();
				q.pop();
				q.push(now - 1);
			}//对于每一个质因子考虑
			while(!q.empty()) {
				ans *= (- q.top() + 1);
				ans %= md;
				q.pop();
			}//统计答案
		}
	}
	cout << ans;
}

```


---

## 作者：4607wjq (赞：1)

## 思路
根据唯一分解定理，$x=p_1^{\alpha _1}p_2^{\alpha _2}...p_k^{\alpha _k}$ 的正因子个数 $d(x)=(\alpha_1+1)(\alpha_2+1)...(\alpha_k+1)$。   
考虑施加肥料时，对于同一棵树，显然“施加的先后顺序不同”和“分开或一起施加”是等效的。因此，我们可以考虑单独每一次施加 $w$ 的一个质因子。   
对于一个质因子 $p$，将其施加在数 $x$ 当中时（ $x$ 可被唯一分解为 $x=p_1^{\alpha _1}p_2^{\alpha _2}...p_k^{\alpha _k}p^{\alpha_p}$，其中 $p_1,p_2,...,p_k,p$ 是互不相同的质数），产生的效果是贡献的变化，$d(x)$ 到 $d(x\times p)$ 会发生以下变化：
$$d(x)=(\alpha_1+1)(\alpha_2+1)...(\alpha_k+1)(\alpha_p+1)$$
$$d(x\times p)=(\alpha_1+1)(\alpha_2+1)...(\alpha_k+1)(\alpha_p+1+1)$$
即：
$$d(x\times p) = d(x) \times \frac{\alpha_p+2}{\alpha_p+1}=d(x)\times(1+\frac{1}{\alpha_p+1})$$
由于题目所求宽度是所有 $d$ 之积，因此，对于 $w$ 中的每一个质数 $p$，它找到一棵树使得施加它后的总宽度最大，也就是在找 $1+\frac{1}{\alpha_p+1}$ 的最大值，即找 $\alpha_p$ 最小值，也就是找到一棵树，它的高度中 $\alpha_p$ 最小。   
由于是乘法算宽度，结合上文等效的性质，不难看出，每个质因子 $p$ 都找到自己的部分最优时，就是全局最优了。  
## 实现方案
考虑枚举 $w$ 的每一个质因子 $p$（注意高次的要多次考虑），再枚举每一棵树，对其高度分解质因子，找到 $\alpha_p$ 最小的那一个树，施加肥料。   
时间复杂度 $O(abn)$，其中 $a$ 是 $w$ 中所有质因子的幂次数之和（读者可写程序求出最坏情况下 $a$ 的大小），$b$ 是分解高度质因子用次数，不会超过 $\log_2 10^4$。因此，复杂度是优秀的。
## CODE
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

const int N = 1e4 + 10, mod = 998244353;

int n, w;
int nums[N], cnt, t, chose, minn;
long long ans = 1;

int main()
{
    cin >> n >> w;
    for (int i = 1; i <= n; i ++ )
        scanf("%d", &nums[i]);
    
    for (int i = 2; i * i <= w; i ++ )
        while (w % i == 0)
        {
            w /= i;
            chose = 1, minn = 0x3f3f3f3f;
            for (int j = 1; j <= n; j ++ )
            {
                cnt = 0, t = nums[j];
                while (t % i == 0)
                    cnt ++, t /= i;
                if (minn > cnt)
                    minn = cnt, chose = j;
            }
            nums[chose] *= i;
        }
    if (w != 1)
    {
        chose = 1, minn = 0x3f3f3f3f;
        for (int j = 1; j <= n; j ++ )
        {
            cnt = 0, t = nums[j];
            while (t % w == 0)
                t /= w, cnt ++;
            if (minn > cnt)
                minn = cnt, chose = j;
        }
        nums[chose] *= w;
    }
    
    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 2; j * j <= nums[i]; j ++ )
        {
            cnt = 0;
            while (nums[i] % j == 0)
                nums[i] /= j, cnt ++;
            ans = ans * (cnt + 1) % mod;
        }
        if (nums[i] != 1)
            ans = ans * 2 % mod;
    }
    
    cout << ans;
    
    return 0;
}
```

---

## 作者：SamHJD (赞：1)

## [P9836 种树](https://www.luogu.com.cn/problem/P9836)

### 题意

给出 $n$ 个数 $a_{1\dots n}$ 和 $w$。你可以将 $a_i$ 乘上 $w$ 的一个正因子 $k$，并将 $w$ 除以 $k$。问最后所有数的正因子个数乘积最大是多少。

### 解法

设一个数 $x=\prod prime_i\times t_{x,i}$，那么其正因子个数为 $\prod (t_{x,i}+1)$。于是我们将 $a_{1\dots n}$ 与 $w$ 质因数分解。

由于最终 $\sum\limits_{i=1}^{n}t_{i,k}$ 不变，也就是某一质因数出现的次数和不变，而我们要让 $\prod\limits_{i=1}^{n}t_{i,k}$ 最大。和一定差最小时积最大，于是方案显然为每次将最小的 $t_{i,k}+1$，即将 $a_i\times k,w\div k$。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

template<typename T>
inline void read(T &x){
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}

const int N=1e4+10,MOD=998244353; 
int n,w,a[N],p[N],k,t[N][1400],tp[1400],ans=1;

inline bool prime(int x){
	for(int i=2;i<=sqrt(x);++i) if(x%i==0) return 0;
	return 1;
}
inline void gets(int x,int y){
	for(int i=1;i<=k&&p[i]<=x;++i){
		while(x%p[i]==0) t[y][i]++,x/=p[i];
	}
}

signed main(){
	read(n);read(w);
	for(int i=2;i<=10000;++i) if(prime(i)) p[++k]=i;
	for(int i=1;i<=n;++i){
		read(a[i]);
		gets(a[i],i);
	}
	for(int i=1;i<=k&&p[i]<=w;++i) while(w%p[i]==0) tp[i]++,w/=p[i];
	for(int i=1;i<=k;++i){
		while(tp[i]){
			int pos=1,mn=1e18;
			for(int j=1;j<=n;++j){
				if(t[j][i]<mn){
					mn=t[j][i];
					pos=j;
				}
			}
			t[pos][i]++;
			tp[i]--;
		}
	}
	for(int i=1;i<=n;++i){
		int res=1;
		for(int j=1;j<=k;++j){
			res*=(t[i][j]+1);
		}
		ans=ans*res%MOD;
	}
	printf("lld",ans);
	return 0;
}
```

---

## 作者：摸鱼ing (赞：0)

题目传送门：[P9836 种树](https://www.luogu.com.cn/problem/P9836)  
在 [我的博客](https://www.luogu.com.cn/blog/404-NOT-FOUND/P9836-solution) 食用效果（并不会）更佳
# 思路

首先来看看一个数的因数个数怎么求，考虑质因数分解，对于正整数 $x$ ：

$$
x=p_1^{a_1} \times p_2^{a_2} \times \cdots \times p_n^{a_n}
$$

对于某个因数 $x$， 质因数 $p_i$ 的幂次有 $0 \sim a_i$ 共 $a_i+1$ 种可能的值，根据乘法原理，质因数个数为：

$$
(a_i+1) \times (a_2+1) \times \cdots \times (a_n+1)
$$

设 $a_{i,j}$ 为 $p_i$ 的质因数 $j$ 的指数，$S_i$ 是 $p_i$ 质因数的集合，  
 本题中树覆盖的距离为：

$$
\prod_{i=1}^n \prod_{j \in S_i} (a_{i, j}+1)
$$

再考虑施肥操作。将 $p_i$ 乘 $k$ 相当于给 $p_i$ 质因数 $x$ 的指数加上 $k$ 的质因子 $x$ 的指数。显然每次贪心加到最小的 $a_{i,x}$ 上，让 $a_{i,x}$ 尽量平均即可（参考面积最大的矩形是正方形）。

# 参考代码

```cpp
#include <bits/stdc++.h>
#ifdef LOCAL
#   define Log(os, x) (os)<<"> "#x" = "<<(x)<<endl
#else
#   define Log(os, x)
#   define endl '\n'
#endif
using namespace std;
template <typename T> T qread(){
    T x=0; int f=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1; c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c&15); c=getchar();}
    return x*f;
}
template <typename T> void qwrite(T x, char c, bool f){
    if(x<0){putchar('-'); x=-x;}
    static int s[50], top;
    do{s[top++]=x%10; x/=10;}while(x);
    while(top) putchar(s[--top]+'0');
    if(f) putchar(c);
}
const int MAXN=(int)1e4+10, MOD=998244353;

int n,w;
int p[MAXN];

int prime[MAXN], tot;
bool is_prime[MAXN];
void euler(int N){
    is_prime[1]=true;
    for(int i=2; i<=N; ++i){
        if(!is_prime[i]) prime[++tot]=i;
        for(int j=1; j<=tot&&prime[j]*i<=N; ++j){
            is_prime[i*prime[j]]=true;
            if(!(i%prime[j])) break;
        }
    }
}
// w的质因数
int idw[MAXN], cntw[MAXN], totw;

int ans=1;

int main(){
#ifdef LOCAL
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
#endif
    euler(MAXN-10);
    n=qread<int>(), w=qread<int>();
    for(int i=1; i<=n; ++i) p[i]=qread<int>();

    for(int i=1; i<=tot; ++i){
        if(!(w%prime[i])){
            idw[++totw]=prime[i];
            while(!(w%prime[i])){
                w/=prime[i];
                cntw[totw]++;
            }
        }
    }
    for(int i=1; i<=totw; ++i){
        // 赛时写的很慢的施肥qwq
        priority_queue<int, vector<int>, greater<int>> q;
        for(int j=1; j<=n; ++j){
            int cntcur=0;
            while(!(p[j]%idw[i])){
                p[j]/=idw[i];
                cntcur++;
            }
            q.push(cntcur);
        }
        for(int j=1; j<=cntw[i]; ++j){
            int tmp=q.top(); q.pop();
            q.push(tmp+1); 
        }
        while(!q.empty()){
            ans=1ll*ans*(q.top()+1)%MOD;
            q.pop();
        }
    }
    for(int i=1; i<=n; ++i){
        for(int j=1; j<=tot; ++j){
            int cntcur=0;
            while(!(p[i]%prime[j])){
                cntcur++;
                p[i]/=prime[j];
            }
            ans=1ll*ans*(cntcur+1)%MOD;
        }
    }
    qwrite(ans, '\n', true);

    return 0;
}

```

---

## 作者：封禁用户 (赞：0)

### 题目传送门

[P9836](https://www.luogu.com.cn/problem/P9836)

### 分析

洛谷 NOIP 模拟赛的第一题，比较水，赛时超过 400 人 AC。

首先有一个结论，对于 $x = \displaystyle\prod_{i=1}^{k}{p_i}^{t_i}$，因数个数为 $\displaystyle\prod_{i=1}^{k}(t_i+1)$，其中 $p_i$ 是质数且 $t_i > 0$。

把 $k$ 和 $a_i$ 分解质因数，为了让乘积更大，每个质因数肯定要贪心地分配给该质因数指数最小的，这里用优先队列维护。

注意，及时 $a_i$ 没有某个质因数，也要在优先队列里插入，不然会出错。

### 赛时代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO
{
	constexpr int fsize = 1<<24;
	#define getchar() ((IO::si!=IO::ti||(IO::ti=(IO::si=IO::input)+fread(IO::input,1,IO::fsize,stdin))),IO::si!=IO::ti?*(IO::si++):EOF)
	#define putchar(c) ((IO::out.so!=IO::out.to||(fwrite(IO::out.output,1,IO::fsize,stdout),IO::out.so=IO::out.output)),*(IO::out.so++)=c)
	char input[fsize],*si = input,*ti = input;
	struct output_stream
	{
		char output[fsize],*so = output,*to = output + fsize;
		inline ~output_stream()
		{
			if(so == output) return;
			fwrite(output,1,so-output,stdout);
			so = output;
		}
	}out;
	template<typename T = int>inline T read()
	{
		int c = getchar(),p = 1;
		T x = 0;
		while(c < 48||c > 57)
		{
			if(c == 45) p = -1;
			c = getchar();
		}
		while(48 <= c&&c <= 57)
		{
			x = (x<<3)+(x<<1)+(c^48);
			c = getchar();
		}
		return x*p;
	}
	template<typename T>inline void write(T x)
	{
		static int c[40],cnt = 0;
		if(x < 0) putchar(45),x = -x;
		if(!x) putchar(48);
		while(x) c[++cnt] = x%10^48,x /= 10;
		while(cnt) putchar(c[cnt--]);
	}
}
using IO::read;
using IO::write;
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define ull unsigned long long
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second
#define debug(x) cerr<<#x<<'='<<x<<'\n'
#define N 10010
constexpr int mod = 998244353;
pii g[10],a[10];
bitset<N> mark;
int t[N],p[N],n,k,len = 0,ans = 1;
priority_queue<int,vector<int>,greater<int> > q[N];
int main()
{
	n = 10000;
	F(i,2,n)
	{
		if(!mark[i]) p[++len] = i,t[i] = i;
		F(j,1,len)
		{
			if(i * p[j] > n) break;
			mark[i * p[j]] = 1;
			t[i * p[j]] = min(t[i],p[j]);
			if(i % p[j] == 0) break;
		}
	}
	n = read(),k = read();
	len = 0;
	while(k > 1)
	{
		if(!len||t[k] > g[len].fi) g[++len].fi = t[k];
		++g[len].se;
		k /= t[k];
	}
	F(i,1,n)
	{
		memset(a,0,sizeof(a));
		int x = read(),sum = 0;
		while(x > 1)
		{
			if(!sum||t[x] > a[sum].fi) a[++sum].fi = t[x];
			++a[sum].se;
			x /= t[x];
		}
		F(j,1,sum) q[a[j].fi].emplace(a[j].se);
	}
	F(i,2,10000)
	{
		if(mark[i]) continue;
		while((int)q[i].size() < n) q[i].emplace(0);
	}
	F(i,1,len)
	{
		if(!q[g[i].fi].size()) continue;
		while(g[i].se--) 
		{
			int u = q[g[i].fi].top();
			q[g[i].fi].pop();
			q[g[i].fi].emplace(u+1);
		}
	}
	F(i,2,10000)
	{
		if(mark[i]) continue;
		while(q[i].size())
		{
			ans = 1ll * ans * (q[i].top() + 1) % mod;
			q[i].pop();	
		}
	}	
	write(ans);
	return 0;
}
```


---

## 作者：FReQuenter (赞：0)

根据题意，我们可以把 $W$ 质因数分解，随后把 $W$ 的每个质因数分配给 $a$ 来使得答案最大。

答案是 $a$ 每一项的正因子个数的乘积。

考虑 $a_i\times X$ 之后答案发生了什么变化。

显然 $a_i$ 原有的每一个正因数都会尝试乘上 $X$ 的每一个正因数。

那么最终答案是乘上了 $X$ 的正因数之和了吗？

显然不是。因为会有重复。

举个例子。$8\times 10$ 时，两个数的正因子分别是 $1,2,4,8$ 和 $1,2,5,10$。其中 $1\times 2$ 和 $2\times 1$ 就是重复的。这会使得最终答案变小。

那么现在任务就变成了把 $W$ 质因数分解之后每个质因子依次选择一个 $a_i$ 乘上去，使得两方中各选一个的正因数乘积“重复”的数量尽可能小。

而现在 $X$ 又是质数：也就只有 $a_i$ 的值为 $X$ 的质因子可以和 $X$ 产生重复了。

所以我们只需要让 $W$ 的每个质因子 $X$，找到含有质因数 $X$ 的数量最少的 $a_i$ 然后乘上去就行了。

复杂度 $O(n\log^2n+n\sqrt n )$，分别来自分解质因数和求一个数的正因数数量。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
#define MAXN 10005
using namespace std;
int n,w,a[MAXN];
int cal(int x){
	int sum=0;
	for(int i=1;i<=sqrt(x);i++){
		if(i*i==x) sum++;
		else if(x%i==0) sum+=2;
	}
	return sum;
}//计算x有多少个正因子
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>w;
	for(int i=1;i<=n;i++) cin>>a[i];
	vector<int> fac;
	int tmp=w;
	for(int i=2;i<=sqrt(tmp);i++){
		while(tmp%i==0){
			fac.push_back(i);
			tmp/=i;
		}
	}
	if(tmp!=1) fac.push_back(tmp);
	//把W质因数分解
	for(auto nx:fac){
		int minn=0x3f3f3f3f,minp=1;
		for(int i=1;i<=n;i++){
			int sum=0,tmp=a[i];
			while(tmp%nx==0) sum++,tmp/=nx;
			if(sum<minn){
				minn=sum;
				minp=i;
			}
			//找到最少的含有这个质因子的ai
		}
		a[minp]*=nx;//修改ai
	}
	int ans=1;
	for(int i=1;i<=n;i++) ans*=cal(a[i]),ans%=mod;
	//最终答案
	cout<<ans;
	return 0;
}
```

---

## 作者：sbno333 (赞：0)

我们首先可以思考一个数因数个数怎么用特别的方法求，即分解质因数，假设 $x$ 有 $n$ 种质因数，第 $i$ 种 $a_i$ 个，不难证明答案为 $(a_1+1)\times(a_2+1)\times(a_3+1)\dots\dots$。

此时答案为所有因数个数的积。

肥料也可以分解质因数，可以一个一个分解出来的质因数进行处理，显然，这个质因数 $s$ 如果加到第 $i$ 棵树上，假设其分解质因数后有 $k$ 个 $s$，则贡献为原先答案除以 $s+1$。

因此我们每次要找最小的 $k$。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,w;
map<long long,long long> f[10009];//记录第i个数的质因数s个数，即f[i][s]
long long aa[10009];//记录此时的第i个数
void st(long long x){//寻找最小的k，并进行更新
	long long d;
	d=1;
	for(long long i=1;i<=n;i++){
		if(f[i][x]<f[d][x]){
			d=i;
		}
	}
	f[d][x]++;
	aa[d]*=x;
}
int main(){
	cin>>n>>w;
	for(long long i=1;i<=n;i++){
		long long a;
		cin>>a;
		aa[i]=a;
		for(long long j=2;j<=sqrt(a);j++){//分解质因数
			while(a%j==0){
				f[i][j]++;
				a/=j;
			}
		}
		if(a!=1){
			f[i][a]++;
		} 
	}
	for(long long i=2;i<=sqrt(w);i++){//加肥料
		while(w%i==0){
			st(i);
			w/=i;
		}
	}
	if(w!=1){
		st(w);
	}
	long long ans;
	ans=1;
	for(long long i=1;i<=n;i++){//求积即答案
		for(long long j=2;j<=sqrt(aa[i]);j++){
			if(aa[i]%j==0){
				ans*=(f[i][j]+1);
				ans%=998244353;
				while(aa[i]%j==0)//不开这个11分，别问我怎么知道的，问就是掉等级分
					aa[i]/=j;
			}
		}
		if(aa[i]!=1){
			ans*=f[i][aa[i]]+1;
			ans%=998244353;
		}
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：渡鸦2007 (赞：0)

## 前置知识
对于一个数 $a=\prod p_i^{\alpha_i}$，其质因数个数为 $\prod (\alpha_i+1)$。其中 $p_i$ 是质数。证明显然。

## 分析
显然想到质因数分解。

显然各质因数间互不影响，于是我们分别考虑每个质数 $p$。记每棵树的高度质因数分解后，$p$ 对应的指数为 $\alpha_i$。特别的，将 $m$ 分解后对应的指数记为 $\alpha_0$。

现在，记 $cnt_i=\alpha_i+1 (0 \le i \le n)$。那么最初始的答案为 $ori=\prod _{i=1}^{n} cnt_i$。请注意，$cnt_i \ge 1$。

下面，我们拆分问题，细致分析并证明。
### 特殊情况 1
若 $\alpha_0=1$：显然我们让最小的 $cnt_i \gets cnt_i+1$。

这是因为，若更改前的答案为 $ori$，则更改 $cnt_i$ 后的答案为 $now = ori \times \dfrac{cnt_i+1}{cnt_i}$。由小学数学知识，$cnt_i$ 越小，$now$ 越大。
### 特殊情况 2
若 $\alpha_0 =2$：若最小的 $cnt$ 为 $cnt_1$，而你第一次更改了 $cnt_2$，那么第二次更改一定是 $cnt_1$ 方能使答案最大。但这种操作法**等价**于先更改 $cnt_1$，再更改 $cnt_2$。

也即，先更改非最小值**一定不是最优解**。
### 推广
对于一个平凡的 $\alpha_0$，如果我们**从未更改**最小的 $cnt_i$，那么答案**一定非最优**。而如果某次更改的不是当时最小的 $cnt_i$，一定可以**交换**顺序，使更改的是**当前最小值**且不劣。
### 总结
于是，该问题转化为，对于每一个质因数，多次更改 $cnt$ 序列，每次更改的都是最小值。我们可以通过优先队列来实现对最小值的维护。

## 代码
时间复杂度 $O(n^2)$，可以通过此题。
```cpp
const int N=1e4+5;
int pri[N];bool z[N];int pc=0;
void pre()
{
	int lim=sqrt(N)+1;
	for (int i=2;i<=N;++i)
	{
		if (!z[i]) pri[++pc]=i;
		for (int j=1;j<=pc;++j)
		{
			if (i*pri[j]>N) break;
			z[i*pri[j]]=1;
			if (i%pri[j]==0) break;
		}
	}
}
int h[N];
int cnt[N][3000];
const int mod=998244353;
signed main()
{
	int n,w;n=read();w=read();
	pre();
	int ans=1;
	//注意，这里的 cnt 数组实际指的是题解中的 alpha 序列（指数）
	for (int i=1;i<=n;++i) //这是在预处理 cnt 序列
	{
		h[i]=read();int t=h[i];now[i]=1;
		for (int j=1;j<=pc;++j)
		{
			while (t%pri[j]==0)
			{
				++cnt[i][j];t/=pri[j];
			}
		}
	}
	{
		int t=w;
		priority_queue<int,vector<int>,greater<int> >q;//这使优先队列从小到大排序
		for (int j=1;j<=pc;++j)
		{
			while (t%pri[j]==0)
			{
				++cnt[0][j];t/=pri[j];
			}
			//分别考虑每个质因数
            
			if (cnt[0][j])
			{
				for (int k=1;k<=n;++k)
				{
					q.push(cnt[k][j]);
				}
				while (!q.empty())
				{
					int tmp=q.top();q.pop();
					q.push(tmp+1);--cnt[0][j];
					if (!cnt[0][j]) 
					{
						break;
					}
				}
				while (!q.empty())
				{
					int tmp=q.top();ans*=(tmp+1);q.pop();ans%=mod;
				}
			}
			else
			{
				for (int k=1;k<=n;++k) ans*=(cnt[k][j]+1),ans%=mod;
			}
		}
	}
	cout<<ans;
	return 0;
}


```


---

## 作者：船酱魔王 (赞：0)

# P9836 种树 题解

**注：本篇题解中，『因数』仅代指『正因数』。**

## 题意回顾

给定长度为 $ n $ 的序列，你有给每个数乘上一个正整数的机会，要求新乘数的乘积等于给定 $ w $，最大化操作完成后所有序列元素的因数个数之积。

$ 1 \le n,w \le 10^4 $，序列元素大小不超过 $ 10^4 $。

## 前置知识

* $ \log_2(ab)= \log_2(a)+\log_2(b) $。

* $ 1 \sim 10000 $ 中，因数最多的数有 $ 64 $ 个因数（可场上写辅助程序计算出来，主要还是一个数的因数数量远小于这个数本身数值）。

## 分析


我们发现数很小，可以根号求因数，无需高级因数分解算法。

这种乘积后因数再乘积这种似乎不太简洁的运算很难找到什么数论性质，考虑动态规划。

定义 $ dp_{i,k} $ 代表 $ 1 \sim i $ 的所有数，在乘完之后剩余可乘量为 $ k $ 的最大因数之积。

记 $ f(x) $ 为 $ x $ 的因数个数。

状态转移方程为 $ dp_{i,k}=dp_{i-1,kr}+f(p_ir) $，要求 $ kr $ 是 $ w $ 的因数。

这种乘积取最值类型题目，可以考虑使用 $ \log_2 $ 值表示那种超过 ```long long``` 表示范围的过程量，记录转移顺序，最后倒推求取余乘积即可。

$ k $ 是 $ w $ 因数之时才有意义，因此我们只需要枚举 $ w $ 的因数作为动态规划状态即可。

记 $ 10^4 $ 以内因数个数上限为 $ C=64 $，乘积后值域为 $ V=10^8 $，时间复杂度约为 $ O(nC^2\sqrt{V}) $，可以记忆化优化因数分解过程。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <map>
using namespace std;
const int N = 1e4 + 5;
const int C = 65;
const int mod = 998244353;
int n, w;
int p[N];
int fx[N];
int zx[N];
map<int, int> mp;
int dx(int x) {
    if(mp.find(x) != mp.end()) {
        return mp[x];
    }
    int res = 0;
    for(int i = 1; i * i <= x; i++) {
        if(x % i == 0) {
            res += 2;
            if(i * i == x) {
                res--;
            }
        }
    }
    return mp[x] = res;
}
double dp[N][C];
int zy[N][C];
int findx(int l, int r) {
    if(l == 0) {
        return 1;
    }
    return (long long)findx(l - 1, zy[l][r]) * dx(p[l] * zx[zy[l][r]] / zx[r]) % mod;
}
int main() {
    cin >> n >> w;
    int zl = 0;
    for(int i = 1; i <= w; i++) {
        if(w % i == 0) {
            zl++;
            zx[zl] = i;
            fx[i] = zl;
        }
    }
    dp[0][zl] = 0;
    for(int i = 1; i <= n; i++) {
        cin >> p[i];
        int pd = dx(p[i]);
        for(int j = 1; j <= zl; j++) {
            for(int k = 1; k <= zl; k++) {
                if(zx[j] % zx[k] == 0) {
                    double dr = dp[i - 1][j] + (double)log2(dx(p[i] * zx[j] / zx[k]));
                    if(dr >= dp[i][k]) {
                        zy[i][k] = j;
                        dp[i][k] = dr;
                    }
                }
            }
        }
    }
    cout << findx(n, 1) << endl;
    return 0;
}

```

---


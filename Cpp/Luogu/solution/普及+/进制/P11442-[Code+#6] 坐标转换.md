# [Code+#6] 坐标转换

## 题目背景

搬运自 [Code+ 第 6 次网络赛](https://gitlink.org.cn/thusaa/codeplus6/)。

## 题目描述

在视频编码中，往往需要将一帧画面分块。

为了简化问题，我们考虑将一幅图片看作 $2^n\times 2^n$ 的网格。为了对图片进行处理，编码器往往会遍历每个格子，但遍历格子的方式在不同的应用中是不同的。

其中一种方式叫做光栅遍历，就是按照从左到右，从上到下的顺序依次进行标号。下图是一个 $8\times 8$ 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/jzhd5wk1.png)

另一种方式叫做 Z 字型遍历。先看一个 $8\times 8$ 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/ywh3ycrt.png)

可以构造性的给出描述：

1.对于 $2^0\times2^0$ 的网格，直接遍历；

2.对于 $2^k\times2^k(k>0)$ 的网格，将其横着从中间、竖着从中间各分成两半，形成 $4$ 个 $2^{k-1}\times2^{k-1}$ 的方格，这四个方格按照左上、右上、左下、右下的顺序依次遍历。

## 说明/提示

### 样例解释

如上图所示。

### 数据范围

对于所有数据，保证 $1\le n\le 30$，$1\le m\le 5\times10^5$。

## 样例 #1

### 输入

```
3 2
Z 37
R 37```

### 输出

```
35
49```

# 题解

## 作者：_S__ (赞：2)

将给出的标号看作四进制数，从高位到低位看，每次将当前网格分成 $4$ 份，则每一位决定这个格子在哪一块中，然后递归进入这个块，重复这个过程即可。最后可确定这个格子的横纵坐标，然后再算出在 R 编码中的标号就可以了。

先确定给出格子的横纵坐标。和上述算法类似，每次将当前网格分成 $4$ 块，通过横纵坐标判断这个格子属于哪一块，然后递归进入这个块，重复这个过程。确定格子属于当前网格的第几个块的时候，可以求出在这之前有多少个块已经在 Z 编码中遍历过了，累加到答案即可。

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11442)

# 题目分析

给一个纯模拟的方法。

首先考虑光栅遍历转 Z 字形遍历。

首先，输入只有一个整数，显然无法直接算。因此，考虑从坐标入手。对于在光栅遍历中的数字 $k$，求它在光栅遍历的网格中的坐标（左上角为 $(1,1)$，右下角为 $(n,n)$）。

由于网格中的数是从 $0$ 开始，设网格中 $k$ 的坐标为 $(x,y)$，网格边长为 $2^n$，则有

$$x=\lceil \frac{k+1}{2^n} \rceil$$

$$y=k-(x-1) \times 2^n+1$$

接下来，考虑如何已知坐标求其 Z 字形遍历。

不妨从大范围入手。对整个网格图将其横着从中间、竖着从中间各分成两半，形成四个边长为原网格一半的小正方形网格。下面就要看数字 $k$ 在哪个小正方形中。设原正方形左侧边界为 $x=a$，上方边界为 $y=b$，即对于原网格中任意一点 $(x,y)$，满足 $x>a$ 且 $y>b$，若原网格边长为 $2^n$，则小网格边长为 $2^{n-1}$。分以下类讨论：

- $x-a \le 2^{n-1}$ 且 $y-b \le 2^{n-1}$，那么该数在左上角的小网格中。
- $x-a>2^{n-1}$ 且 $y-b \le 2^{n-1}$，那么该数在右上角的小网格中。
- $x-a \le 2^{n-1}$ 且 $y-b>2^{n-1}$，那么该数在左下角的小网格中。
- $x-a>2^{n-1}$ 且 $y-b>2^{n-1}$，那么该数在右下角的小网格中。

如此，循环下去直至小网格变成一个单元格。设左上角小网格为网格 $1$，右上角小网格为网格 $2$，左下角小网格为网格 $3$，右下角小网格为网格 $4$，则可形成一个数列，数列中的元素表示每次执行上述操作时该数在哪个小网格中。注意每次选定一个网格后更改相应的 $a$ 和 $b$。如数列

$$3,3,4$$

表示该数在第一次划分时该数在网格 $3$，第二次划分时该数在网格 $3$ 的网格 $3$ 处，以此类推。

接下来想如何求解。首先我们知道，当一个小网格就是一个单元格时，该网格左上角第一个格子就是该单元格。那么，在结合 Z 字形遍历的规则，我们就可以枚举数列中的每个数。设该数为 $f$，其中 $1 \le f \le 4$，每次可以计算网格 $f$ 左上角第一个数，则每次计算结果之和就是答案。若原网格边长为 $2^n$，则网格 $f$ 的左上角第一个数为

$$(f-1) \times 2^{2 \times (n-1)}$$

累加和即为答案。

接下来考虑如何从 Z 字形遍历转光栅遍历。其实就是上述操作倒过来。

首先，还是划分小网格。对于网格 $f$，其左上角第一个数是 

$$(f-1) \times 2^{2 \times (n-1)}+l$$

其中 $l$ 表示原网格左上角第一个数。

如此还是列出一个数列，那么，我们需要通过数列求坐标。还是需要分类讨论。设原网格边长为 $2^n$，则

- 若为网格 $1$，则 $x_0 \le x \le x_0+ 2^{n-1}-1$，$y_0 \le y \le y_0+ 2^{n-1}-1$。
- 若为网格 $2$，则 $x_0 \le x \le x_0+ 2^{n-1}-1$，$y_0+ 2^{n-1} \le y \le y_0+2^n-1$。
- 若为网格 $3$，则 $x_0+ 2^{n-1} \le x \le x_0+2^n-1$，$y_0 \le y \le y_0+ 2^{n-1}-1$
- 若为网格 $4$，则 $x_0+ 2^{n-1} \le x \le x_0+2^n-1$，$y_0+ 2^{n-1} \le y \le y_0+2^n-1$。

其中 $x_0$，$y_0$ 表示原网格左上角第一个数的坐标。

重点是，这里我们每次去 $x$，$y$ 可取的最小值。如此迭代下去直至网格为一个单元格，此时坐标即为答案。

知道坐标，求解就简单了，答案为

$$(x-1) \times 2^n+y-1$$

# 代码


```
#include<bits/stdc++.h>
#define ll long long
#define N 101
using namespace std;
int wz[N];
ll fp(ll a,ll b){
	ll ans=1,a1=a,b1=b;
	while(b1){
		if(b1&1){
			ans*=a1;
		}
		a1=a1*a1;
		b1>>=1;
	}
	return ans;
}
int main(){
	int n,m;
	cin>>n>>m;
	ll r=fp(2,n);
	while(m--){
		char c;
		ll x,ans=0;
		int h=0;
		cin>>c>>x;
		if(x==0){
			cout<<0<<endl;
			continue;
		}
		memset(wz,0,sizeof(wz));
		if(c=='R'){
			int zbx,zby;
			zbx=ceil((double)(x+1)/(double)r);
			zby=x-((zbx-1)*r)+1;
			ll k=n,r2=r,up=0,le=0;
			while(k){
			    if(r2==1){
			        break;
			    }
				if(zbx-up<=r2/2&&zby-le<=r2/2){
					wz[h++]=1;
				}
				else if(zbx-up<=r2/2&&zby-le>r2/2){
					wz[h++]=2;
					le+=r2/2;
				}
				else if(zbx-up>r2/2&&zby-le<=r2/2){
					wz[h++]=3;
					up+=r2/2;
				}
				else{
					wz[h++]=4;
					up+=r2/2;
					le+=r2/2;
				}
				k--;
				r2>>=1;
			}
			r2=n;
			for(int i=0;i<h;i++){
				ll nowf=(wz[i]-1)*fp(2,2*(r2-1));
				r2--;
				ans+=nowf;
			}
			cout<<ans<<endl;
		}
		else{
			int n2=n;
			ll last=0,r2=r;
			while(n2){
				ll o=fp(2,2*(n2-1));
				ll f1=last+o,f2=last+2*o,f3=last+3*o;
				if(x>=last&&x<f1){
					wz[h++]=1;
				}
				else if(x>=f1&&x<f2){
					wz[h++]=2;
					last=f1;
				}
				else if(x>=f2&&x<f3){
					wz[h++]=3;
					last=f2;
				}
				else{
					wz[h++]=4;
					last=f3;
				}
				n2--;
			}
			int zbx,zby;
			ll lastwzx=1,lastwzy=1;
			for(int i=0;i<h;i++){
				if(wz[i]==1){
					zbx=lastwzx;
					zby=lastwzy;
				}
				else if(wz[i]==2){
					zbx=lastwzx;
					zby=lastwzy+r2/2;
					lastwzy=zby;
				}
				else if(wz[i]==3){
					zbx=lastwzx+r2/2;
					zby=lastwzy;
					lastwzx=zbx;
				}
				else{
					zbx=lastwzx+r2/2;
					zby=lastwzy+r2/2;
					lastwzy=zby;
					lastwzx=zbx;
				}
				r2>>=1;
			}
			ans=(zbx-1)*r+zby-1;
			cout<<ans<<endl;
		}
	}
	return 0;
} 
```

---

## 作者：signed_long_long (赞：0)

做这题真是太艰辛了，[T 了好几发](https://www.luogu.com.cn/record/list?pid=P11442&user=741314&status=14&page=1)……

# 题目解法

分两种情况讨论。

## 为 `Z` 的情况
显然，只要找到 $x$ 在第几行第几列就能解决了。所以把图分成下面这样，并标号：

![](https://cdn.luogu.com.cn/upload/image_hosting/8dhdupje.png)

对于每个分出来的 $4\times 4$ 的格子，递归执行此操作。

然后，就能发现，把所有找到 $x$ 经过的格子编号连起来，就是 $x$ 的 $4$ 进制。

没听懂的话看下面：

![](https://cdn.luogu.com.cn/upload/image_hosting/amn45m1l.png)

用绿色框出来的编号分别是 $2,1,1$，而 $(211)_4=37$。

如果一个数的 $4$ 进制的第 $i$ 位等于 $1$ 或 $3$，那么这个数的列数增加 $2^{n-i}$。如果等于 $2$ 或 $3$，那么这个数的行数增加 $2^{n-i}$。

所以在 Z 字形遍历中，$37$ 在第 $2^2$ 行，第 $2^1+2^0$ 列。（上文中的行和列都从 $0$ 开始标）

光栅型遍历的格子编号等于行乘 $2^n$ 加上列。

## 为 `R` 的情况

其实就是把位 `Z` 的情况反一下。

先把 $x$ 的行和列算出来，再都转成二进制，对于第 $i$ 位，答案增加第 $i$ 位行的二进制和列的二进制拼起来的的二进制的十进制乘 $4^{i-1}$。

没看懂上面没关系，联系下面的代码理解一下：

```cpp
void do_R(LL x){
	LL hang=x/_2[n],lie=x%_2[n];
	LL z=1;
	LL ans=0;
	for(int i=n-1;i>=0;i--){//为了避免 TLE，把进制转换和统计答案放在一起了
		int hh=hang%2,ll=lie%2;
		hang/=2,lie/=2;
		if(hh==0 and ll==0) ans+=z*0;
		if(hh==0 and ll==1) ans+=z*1;
		if(hh==1 and ll==0) ans+=z*2;
		if(hh==1 and ll==1) ans+=z*3;
		z*=4;
	}
	cout<<ans;
}
```

AC code：

```cpp
#include<bits/stdc++.h>
typedef long long LL;
using namespace std;
int n,m;
LL _2[40];
void csh(){
	_2[0]=1;
	for(int i=1;i<=31;i++){
		_2[i]=_2[i-1]*2;
	}
}
void do_Z(LL x){
	LL y=x;
	LL hang=0,lie=0;
	for(int i=1;i<=n;i++){
		int z=y%4;
		y/=4;
		if(z>=2) hang+=_2[i-1];
		if(z&1) lie+=_2[i-1];
	}
	cout<<hang*_2[n]+lie;
}
void do_R(LL x){
	LL hang=x/_2[n],lie=x%_2[n];
	LL z=1;
	LL ans=0;
	for(int i=n-1;i>=0;i--){
		int hh=hang%2,ll=lie%2;
		hang/=2,lie/=2;
		if(hh==0 and ll==0) ans+=z*0;
		if(hh==0 and ll==1) ans+=z*1;
		if(hh==1 and ll==0) ans+=z*2;
		if(hh==1 and ll==1) ans+=z*3;
		z*=4;
	}
	cout<<ans;
}
void work(){
	char op;
	LL x;
	cin>>op>>x;
	if(op=='Z') do_Z(x);
	else do_R(x);
	cout<<"\n";
}
signed main(){
	ios::sync_with_stdio(false);// 不写会 TLE 45pts
	csh();
	cin>>n>>m;
	while(m--){
		work();
	}
	return 0;
}
```

---


# [HNOI2006] 鬼谷子的钱袋

## 题目描述

鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯的特派员前来向他咨询时政。

有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。

但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。

鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于 $1$ 的金币数。假设他有 $m$ 个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？

## 样例 #1

### 输入

```
3
```

### 输出

```
2
1 2
```

# 题解

## 作者：安笙凉城 (赞：69)

#这道题用到了分治的思想


##比如一个数是20，那么我们如何表示从1到20所有的数呢？

##脑补一下，11~20和1~10有什么关系？差了个10呗！

##那如果我表示6~10呢？只要表示1~5就行了。

##同理，3~5可以由1~3来表示，2和3可以用1和2来表示


##发现了什么端倪？

##表示n以内的任何数字可以用1到n/2内的数字

##那么表示n/2以内的任何数字可以用1到n/4以内的数字……


#于是便有了本蒟蒻的代码





```cpp
#include<bits/stdc++.h>
using namespace std;
int m,sum=1,a[100005];
int main()
{
    cin>>m;
    while(m>0)//核心
      {
          m%2==0?a[sum]=m/2:a[sum]=m/2+1;//这一坨等价于if(m%2==0) a[sum]=m/2; else a[sum]=m/2+1;
        m/=2;//分治，防止死循环;
          sum++;
      }
    sum--;//sum会多出1
    sort(a+1,a+sum+1);//排序
    cout<<sum<<endl;
    for(int i=1;i<=sum;i++)
      cout<<a[i]<<" ";  //愉快输出
    return 0;
}
```

---

## 作者：zybnxy (赞：28)

题目传送门->[在这里](https://www.luogu.org/problemnew/show/P2320)

首次读题没有什么思路，毕竟也是在$\text{神奇的解法}$里的，多次读题之后，才发现这到题的正解。

## 简化题目：
给定整数$N$，求至少需要$M$个数，使其和可以分别为$1……N-1$,求$M$和数列。

## 分析题目：
通过简化题目，我们不难发现这就是一个分治的题目，~~并且题目的范围貌似已经提示的很明确了~~。$1≤m ≤1000000000$，用普通的枚举，搜索，甚至$dp$，都一定会超时，唯独$O(log N)$的二分不会超时。

## 深入分析：
我们拿样例来解释：

$3$可以被分解成$1$和$2$，~~这不是废话吗~~

我们在取一个数作为例子，例如，我们取$10$这个数。

$10$ 可以分解成$5$和$5$，在拆开$5$后得到$3$和$2$，然后在把$2$拆成$1$和$1$。

最后可以得到$10$被拆解成了$1,1,3,5$。

也就是说，我们对一个$N$，可以每一次都对它进行$N/2$的操作，直到为$N$被分解成$0$为止。

## 程序实现：
对于每个值的存储，我们开一个数组，用来每次$N/2$的数字，然后倒序输出。

* 以下为本题核心代码
```cpp
while(m)
	{
		a[++k]=(m+1)/2;
		m/=2;
	}
```

数组因为是从大到小存储的，所以我们要倒序输出

代码如下
```cpp
#include<cstdio>
int a[200001];
int main()
{
	int m,k=0;
	scanf("%d",&m);
	while(m)
	{
		a[++k]=(m+1)/2;
		m/=2;
	}
	printf("%d\n",k);
	for(int i=k;i>=1;i--)
		printf("%d ",a[i]);
	putchar('\n');
	return 0;
}

```

总之，本题就是一个难想的题，只要有思路，代码的实现就不会很难。

~~另外打个广告~~ ：[$\color{cyan}{Blog}$](https://www.luogu.org/blog/51645/)

---

## 作者：zhutier (赞：17)

# 二进制做法

当你找不出bug苦苦沉思了很久，也许你是没有看到这句话
### 并且不有两个钱袋装有相同的大于1的金币数
如果看到了，那就当我没说继续往下看吧……

利用背包问题中的类似想法，将m进行二进制拆分
如$m=23$,拆为$1$ $2$ $4$ $8$ $8$。原理跟用分治的各位大佬讲的一样。

再举几个栗子

$24=1+2+4+8+9$

$25=1+2+4+8+10$

这里的$9$ $10$已经不需要再拆了，因为小于它们的数字都已经可以被组成。

回到最初的$m=23$，这里出现了个问题，有两个重复数字。

于是我们直接把俩$8$变成$7$和$9$.

为什么可行？？

当我们需要用$8$时，直接用$7+1$就可以辣

如果还需要$1$怎么办？？

$7+1+1$，直接用$9$就好了阿……

不知有无spj，但是我这样写是过了der。

附代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int cnt,k=1,n,m,ans[41];
int main(){
	scanf("%d",&m);
	while(k<=m){
		cnt++;
		ans[cnt]=k;
		m-=k;
		k<<=1;
	}
	if(m){
		cnt++;
		ans[cnt]=m;
	}
	sort(ans+1,ans+cnt+1);
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;i++){
		if(ans[i]==ans[i+1]&&ans[i]!=1){
			ans[i]--;
			ans[i+1]++;
		}//这里不需要再排序了
		printf("%d ",ans[i]);
	}
		
	return 0;
}
```


---

## 作者：white945 (赞：12)

光想不好想，我们举个例子。比如我们要算的是10，怎么办呢。首先要想组成1，必须有1。然后，如果要组成的一个数能由一部分加上另一部分组成就会很好了，10可以分成1~5和6~10，6~10可以由1~5加5组成，所以要选5，接下来只要组成1~5就可以了。就把5除2，一直这样。这很像倍增。所以只要一直这样就可以了。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int ans;
long long n;
long long z[70];

void print(){
    sort(z+1,z+ans+1);
    printf("%d\n",ans);
    for(int i=1; i<=ans; ++i) printf("%lld ",z[i]);
    puts("");
}

int main(){
    cin>>n;
    ans=0;
    while(n){ z[++ans]=(n+1)/2; n/=2; }
    print();
    return 0;
} 

```

---

## 作者：OYBDOOO (赞：7)

#### 为什么我的思路和其他人不一样？？？
#### 先求二的幂-->edm数组
#### 把这个数像二进制一样拆成多份
#### 重复的把它+1，-1；
#### 输出就AC了
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
using namespace std;
int m;
int edm[105];
int ans[105];
int main()
{
	int i;
	scanf("%d",&m);
	edm[0]=1;
	for(i=1;i<=30;i++)edm[i]=edm[i-1]*2;
//	for(i=1;i<=30;i++)cout<<edm[i]<<" ";
	for(i=0;i<=30;i++)
	{
		if(edm[i]>m)
		{
			break;
		}
	}
	printf("%d\n",i);
	int kpp=i;
	for(i=1;i<=kpp;i++)
	{
		if(m>edm[i-1])
		{
			m-=edm[i-1];
			ans[i]=edm[i-1];
		}
		else
		{
			ans[i]=m;
			break;
		}
	}
	sort(ans+1,ans+kpp+1);
	for(i=1;i<=kpp;i++)
	{
		if(ans[i]!=1&&ans[i]==ans[i+1])
		{
			ans[i]--;
			ans[i+1]++;
		}
	}
	for(i=1;i<=kpp;i++)
		printf("%d ",ans[i]);
	return 0;
}
```


---

## 作者：Real_Create (赞：5)

~~本鑞結已经不像话题解了，但是我又不会做很多题，这个版块太适合我了，我再发一个，在过不去我就不发了~~

首先看一下题目→[点我点我，我是题目](https://www.luogu.org/problemnew/show/P2320)

首先是找规律：

~~小学生找规律开课了~~

第一题（~~也只有一题~~）：

1（1=1）

1，1（1+1=2）

1，1，3（1+1+3=5）

1，1，3，5（1+1+3+5=10）

1，1，3，5，10（1+1+3+5+10=20）

我们发现，每个数都是ceil（n/2.0）和被拆掉的n/2

ceil（n/2.0）就是下面的代码

```cpp
int a;//我们要的数
if(n%2!=0)//判断是不是单数
{
	a=n/2+1;//是单数要+1
}else
{
	a=n/2//是双数不用+1
}
```
然后这是拆开数的代码
```cpp
while(n)
{
	a[++s]=ceil(n/2.0);
	n/=2;
}
```
这是全部代码

```cpp
#include <bits/stdc++.h>//万能头文件！！！
using namespace std;
int main()
{
	int n,s=0;//定义一下
	cin>>n;//接住n
	int a[n+1];//定义
	while(n)//就是while（n>0)
	{
		a[++s]=ceil(n/2.0);//注意这个++s，满满的细节
		n/=2;//就是n=n/2
	}
	sort(a+1,a+s+1);//排序
	cout<<s<<endl<<a[1];//输出
	for(int i=2;i<=s;i++)//嗨起来
	{
		cout<<' '<<a[i];//丢出一堆数字
	}
	return 0;//程序的末日
}

```
[dldykukl](https://www.luogu.org/blog/jerry0802-VX/)

~~用你的键盘把上面的字母后移一位~~

---

## 作者：M_PI (赞：3)

这题还是挺有趣的。

首先所有的钱袋都可以看成一个取或不取的情况。那么这些钱袋取或不取就可以看作0或1，也就是说，要使用一些数字表示一个范围里的所有数，同时这又很二进制（取或不取）。所以我们就把钱袋里钱的数量定为2^n个。

还是比较基础的吧。

至于压行什么的，楼上的都是在误导各位。写多了这种东西脑子会炸的，比赛的时候有用吗？快、小才是王道。贴一个c的，内存和速度都能甩别人几条街。

```c
#include<stdio.h>
int main(){
    int m,tot=0,ans[30];
    scanf("%d",&m);
    for(;m>>1;m>>=1)
        ans[++tot]=(m>>1)+(m&1);
    printf("%d\n1",tot+1);
    while(tot)
        printf(" %d",ans[tot--]);
    return 0;
}
```

---

## 作者：kIG7Z8oP (赞：3)

# 用~~魔法~~递归打败循环——最短AC代码

关于那个分治相信所有人都会QAQ

估测一下**ans<=32**($\colorbox{red}{\color{white}{\text{2147483648=1<<32}}}$ )

那么开个31位数组就成

```cpp

#include<cstdio>
int n,ans=0,tail;
int que[31];
void getsum(int now)
{
	ans++;
	que[++tail]=now-(now>>1);
	if(now==1) return;
	getsum(now>>1);
}
int main()
{
	scanf("%d",&n);
	getsum(n);
	printf("%d\n",ans);
	for(int i=1; i<=tail; i++)
		printf("%d ",que[i]);
}

```


---

## 作者：HDWR (赞：3)

本蒟蒻怒写一发题解

收到本校神犇[@Herself32](https://www.luogu.org/space/show?uid=148343) 的邀请，过来做这道题

~~结果被题怒切~~

不扯了

---

首先考虑一个弱化版的题目，只输出最小袋子数
稍微找一下规律就知道是总钱数的二进制位数

好 那么数据范围就出来了

---

本题我们还是手动模拟一下

```
1 -> 1
2 -> 1, 1
3 -> 1, 2
4 -> 1, 1, 2
5 -> 1, 1, 3
6 -> 1, 2, 3
7 -> 1, 2, 4
8 -> 1, 1, 2, 4
```

我们再把7和8的过程单独拿出来看

```
7 -> 3, 4 -> 1, 2, 4
8 -> 4, 4 -> 2, 2, 4 -> 1, 1, 2, 4
```

我们能发现什么？
对于一个数 $n$，我们可以把它用 $ \lceil \frac{n}{2} \rceil + \lfloor \frac{n}{2} \rfloor $ 表示，同时依照题意，$ \lfloor \frac{n}{2} \rfloor $ 也是可以用 $ \lceil \frac{\lfloor \frac{n}{2} \rfloor}{2} \rceil + \lfloor \frac{\lfloor \frac{n}{2} \rfloor}{2} \rfloor $ 进行表示的，这么一直递归下去，直到两个多项式中至少有一个为 1 ，此时反向（即从小到大）输出答案即可

# 代码实现

```cpp
#include <iostream>
#include <cstdio>

#define FILE_IN(__fname) freopen(__fname, "r", stdin)
#define FILE_OUT(__fname) freopen(__fname, "w", stdout)
#define IMPROVE_IO() std::ios::sync_with_stdio(false)

using std::cin;
using std::cout;
using std::endl;

const int MAXANS = 30 + 10;

int m;

int ans[MAXANS], cnt = 0;

void Search(int now) {
    if (now == 0) return;
    int mid = now / 2, mid2 = now / 2 + (now % 2);
    ans[++cnt] = mid2;
    Search(mid);
}

int main() {
    scanf("%d", &m);
    Search(m);
    printf("%d\n", cnt);
    for (int i = cnt; i >= 1; --i) printf("%d ", ans[i]);
    printf("\n");
    return 0;
}


```

---

## 作者：royzhu (赞：3)


这题其实很水

只要学了快排和二分（二进制）就可以了

思路有点难：（就是想二分有点难）

1，二分

为什么要二分呢？

本题题意是：

不能有钱数相同的钱袋。

二分n，就可以解决。

2，快排（保险）

我的二分后，有几个数不是从小到大排的

核心代码:


```cpp
while(t)
{
    if(t-l>0){a[++c]=l;t-=l;l*=2;}//如果可以分下去到下个2的c+1次方 
    else if(t!=0) //否则t就要进行处理（t==0就已经分完了） 
    {
        if(t==1){a[c]++;t=0;}//如果t==1，把剩下的1加到最后一个就数可以了 
        else if(t%2==1){a[++c]=t;t=0;}//如果t是奇数，把 t存下 
        else if(t>a[c]){a[++c]=t;t=0;}//如果t是大于最后一个数又是偶数，把 t存下  
        else {a[c]++;a[++c]=t-1;t=0;}// 如果t是小于最后一个数又是偶数，把剩下的t加到最后一个数 
    }
}
```
**完整代码：**
```cpp
#include<cstdio>
int a[110];
void dfs(int x,int y)//快排（也可以用sort） 
{
    int l=x,r=y,m=a[(l+r)/2];
    while(x<=y)
    {
        while(a[x]<m)x++;
        while(a[y]>m)y--;
        if(x<=y)
        {
            int t=a[x];a[x]=a[y];a[y]=t;
            x++;y--;
        }
    }
    if(x<r)dfs(x,r);
    if(y>l)dfs(l,y);
}
int main()
{
    int n;scanf("%d",&n);//输入 
    int l=1,c=0,t=n;//二分会破坏n所以用t存n
    //t表示2的c次方，c表示2的第几次方（从2的0次方开始） 
    while(t)
    {
        if(t-l>0){a[++c]=l;t-=l;l*=2;}//如果可以分下去到下个2的c+1次方 
        else if(t!=0) //否则t就要进行处理（t==0就已经分完了） 
        {
            if(t==1){a[c]++;t=0;}//如果t==1，把剩下的1加到最后一个就数可以了 
            else if(t%2==1){a[++c]=t;t=0;}//如果t是奇数，把 t存下 
            else if(t>a[c]){a[++c]=t;t=0;}//如果t是大于最后一个数又是偶数，把 t存下  
            else {a[c]++;a[++c]=t-1;t=0;}// 如果t是小于最后一个数又是偶数，把剩下的t加到最后一个数 
        }
    }
    dfs(1,c);//快排 
    printf("%d\n",c);//输出钱袋个数 
    for(int i=1;i<=c;i++)//从小到大输出第i个钱袋 
    {
        printf("%d ",a[i]);
    }
}
```

---

## 作者：Bring (赞：2)

# ~~来个神奇的解法~~
蒟蒻题解，大佬勿喷
### 首先，如果可以有任意重复的袋子，怎么做呢
**既然是求最小袋数**

**那我们就换个问题**~~（手动滑稽）~~

如果给你固定数量的袋子，最多能够给出多少种不同价值的组合呢？

既然不同价值的组合要多，那么就要让同种价值组合的解法尽量少

 _举个栗子_ ：如果给你5个袋子，这么分：1，2，3，4，5；

那么如果你要拿5的价值，就会有三种解法:1+4，2+3，5，显然是浪费

究竟怎么样才能使每一种价值只有一种解法呢？

考虑二进制的思想：**任何一种01串都有不同的值**

于是就可以发现：如果分成1，2，4，8，16，那么每种价值只有一种解法，可以任意分配1~31的价值，显然是个好分法

这样就可以解答前面的问题了：**以1，2，4，8，16等2^n的数分，直分不了为止**

## 现在让我们回到原题
按照上面的玩法，先按照1，2，4，8，16……设剩下的为x

题目说除了1以外不可以有别的重复价值袋子

如果x不是>1的2^n数，那么直接装一袋，好办

**关键是考虑x是>1的2^n数的情况**

因为需要保证每个1~n的数都可以有解法，所以需要一个可以组合成x的替代品

试试看1+(x-1)，如果这么做，那么另一个x就变成了x+1

看看还可不可以组成1~n的所有数（设该数=a）

1：a的二进制中x值的位=0，则没有关系

2：a的二进制中x值的位=1但第一位=0，则x可以用1+(x-1)替代掉

3：a的二进制中x值的位=1但第一位=1，则可以x+1替代掉

_举个栗子_ ：19=1+2+4+8+4，于是x=4=2^2，

那么就可以分成1，2，3，5，8（4+4被拆成3+5）

如果a的二进制中用到4但不用到1，可以用1+3代替

如果a的二进制中用到4而且用到1，可以用5代替

**综上**，上代码~~（手动滑稽）~~//代码中x用m代替
```cpp
#include<iostream>
#include<cmath>
using namespace std;
#define int long long
int m,lg;
signed main(){
    cin>>m,lg=log2(m+1),m-=(1<<lg)-1;//求出分成1,2,4,8……的数量和m=x
    cout<<lg+(m?1:0)<<endl;//如果刚好分完当然不用加了
    for(int i(0);i<lg;++i){//考虑所有2^n
        if(m&&m==(1<<i))cout<<m-1<<' '<<m+1<<' ',m=0;//撞上了，分成x-1和x+1
        else if(m&&(1<<i)<m&&m<(1<<(i+1)))cout<<(1<<i)<<' '<<m<<' ',m=0;//没撞上，直接输
        else cout<<(1<<i)<<' ';
    }
    return 0;
}
```

---

## 作者：kkksx (赞：2)

1. 因为所有的数可以表示为二进制
1. 我们可以把总钱数分为2^k相加
1. 可以把2^k转换为二进制1,10,100,1000...用它们相加可以表示任何在最大范围以内的数
1. 但是最后可能剩下一个数t，我们将它直接放在另一个钱包里面（因为我们可以把所有（总-t）的数都表示出来，那么比（总-t）大的数可以直接用前面的加上t得到）。
1. 但是t可能与已经有的钱包x的钱数一致，这是不允许的，我们可以直接把x-1 ，t+1就行（原来1+x+...才能得到的现在用2+t+...就行了（前提是x！=2  hhh））.

```
#include<bits/stdc++.h>
using namespace std;
int a[100];//储存每个钱包的钱数，不可能超过100个 
int main()
{
	int money,ans=0;//钱数，答案 
	cin>>money;
	for(int i=1;i<=money;i*=2)//枚举2的倍数 
	{
		money-=i;//减去装袋的 
		a[++ans]=i;//装袋 
	}
	if(money) a[++ans]=money;//如果剩余不为0 
	for(int i=1;i<ans;++i)//枚举之前的每个袋子，看有没有和其相等 
	{
		if(money==a[i])
		{
			a[ans]++;
			a[i]--;
		}
	}
	sort(a+1,a+ans+1);//排序输出 
	cout<<ans<<endl;
	for(int i=1;i<=ans;++i)
	cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：ENESAMA (赞：2)

这道题太险恶了
对于两个相同的数
一个加一一个减一是等效的
（好好想一想，为什么)
很容易想到用1,2,4,8,16。。。
这种数列就行
最后一个数无论是多少都行
然后就很简单的做出来了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,num,ans[200],tot;
int main()
{
	cin>>n;
	for(int i=0;i<=n;i++)
	{
		if(pow(2,i)-1>n)
		{
			num=i-1;
			break;
		}
	}
	for(int i=0;i<=num-1;i++)
	{
		ans[++tot]=pow(2,i);
	}
	ans[++tot]=n-pow(2,num)+1;
	if(ans[tot]) cout<<tot<<endl;
	else cout<<tot-1<<endl;
	sort(ans+1,ans+tot+1);
	for(int i=1;i<=tot;i++)
	if(ans[i]!=0)
	{
		if(ans[i]==ans[i+1]&&ans[i]!=1)
		{
			printf("%d %d ",ans[i]-1,ans[i]+1);//9
			i+=1;//1 2 2 4
			//1 1 3 4
		}
		else printf("%d ",ans[i]);
	}
	return 0;
}
```

---

## 作者：Randolph、 (赞：1)

[P2320 [HNOI2006]鬼谷子的钱袋](https://www.luogu.org/problem/P2320)

挺有趣的一道题，之所以发这篇题解是因为感觉思路的更清晰一点qwq

此题主要有两种方法：

### 一、分治思想

例如要凑出1~20，假如我们已经能凑出1~10了，**那么只要再有一个10元的钱袋，便可以凑出11~20**

同理，再要凑出1~10，则需要凑出1~5+一个5元的钱袋

就这样不断分治，那么**每次n/2都是一定会选的数**

如果n是奇数，如21，那么只要凑出1~10加上一个11元的钱袋即可


```cpp
#include<iostream>
using namespace std;
int m,k,a[31]; //2^30>10^9
int main(){
	cin>>m;
	while(m) a[++k]=(m+1)/2,m/=2; //每次m/2都是一定会选的数
	cout<<k<<"\n";
	for (int i=k;i;i--) cout<<a[i]<<" "; //数组递减，倒序输出
}
```

### 二、二进制拆分

类似多重背包问题的二进制分解思想，**2^n以内的以内的所有数都可以用2^0，2^1，2^2.......2^（n-1）表示出来，且用的数字最少**

例如要表示出23以内的所有数，把23二进制拆分：23=2^0+2^1+2^2+2^3+8=1+2+4+8+8（最后的8是拆分后的余数），也就是用1,2,4,8,8可以凑出1~23。

也许你会问：1,2,4,8以二进制的方式可以凑出1~15，但是16~22之间的数就一定能用1,2,4,8,8凑出来吗？

其实16~22中的任一个数都可以表示成23-x（0<x<8）的形式，而对于0<x<8是一定可以用1,2,4,8凑出的,实际上就是从1,2,4,8,8中去掉几个钱袋而已。

同理，**如果要表示出m以内的数：拆分m=2^0+2^1+2^2+......+2^n+余数，对于m-x（0<x<余数），x一定可以用2^0+2^1+2^2+......+2^n表示出来（如果无法表示则说明x>2^0+2^1+2^2+......+2^n即x>=2^(n+1）,那么x还可以继续拆分，与题意不符）**

此外还要**注意不得有两个钱袋装有相同的大于1的金币，对于23中的两个8，可以改为7,9**（由于凑出数时1是肯定要用上的，当我们需要用8时，直接用7+1就可以，如果还需要1，7+1+1，直接用9就好了，当然最好还是有special judge）。由于2^n是递增的，所以最多是余数与一个数相同，特判即可，不需排序。

代码长了一些主要是因为特判，然而似乎比分治稍微快一点qwq？

```cpp
#include<cstdio>
using namespace std;
int m,n,a[31];
bool flag; //是否有余数？
int main() {
	scanf("%d",&m);
	for (int x=1; x<=m; x<<=1)
		a[++n]=x,m-=x; //二进制拆分
	n++;
	if (m) a[n]=m; //余数
		else flag=1; 
	printf("%d\n",n-(flag==1)); //没有余数就-1
	for (int i=1; i<n; i++) {
		if (!flag) { //如果余数还没输出，则判断当前位置是否该输出余数了
			if (a[i]==a[n]) printf("%d ",a[n]-1),a[i]++,flag=1; //余数与一个数相同
			else if (a[n]<a[i]) printf("%d ",a[n]),flag=1; //没有数与余数相同，按顺序输出
		}
		printf("%d ",a[i]);
	}
	if (!flag) printf("%d",a[n]); //如果余数最大
}
```


---

## 作者：panyf (赞：1)

还是递归好！

不用二分查找，不用排序，不用进制，不用栈……

先贴上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,u,a[31];	
void dg(int x){
	if(x==1){
		cout<<u+1<<'\n'<<1;
		for(int i=u;i;i--)cout<<' '<<a[i];
		exit(0);
	}//出现1则直接输出
	a[++u]=x>>1,a[u]+=x&1?1:0,dg(x>>1);
  //分奇偶两种情况，继续递归
}
int main(){
	cin>>m,dg(m);//极简主函数
}
```
分析：

先输入m。

若m为偶数，则将m分为两个m/2，将其中一个m/2存入数组，另一个m/2继续分拆。

若m为奇数，则分为（m-1）/2和（m+1）/2，（m+1）/2存入数组，（m-1）/2继续分拆。

若出现1，则不能再继续分拆，输出，退出程序。

正确性证明：

设每次将当前的数x分拆为两个数a和b，b存入数组，a继续分拆，则无论x为奇数或偶数，a一定>=b-1，所以从1到b-1的所有数都可以用a继续分拆的结果表示，而b>=x/2，因此从b到x的所有数都可以用从1到b-1的某个数加上b来表示。

这道题的一个坑点就是不能出现重复的大于1的数，很多人都用了特判，而本程序的优点就是不需要特判，因为存入数组的b一定大于等于a，所以只要b大于2，b一定大于a分拆出的所有数，而本题中允许出现重复的1，所以本程序为此题正解。

---

## 作者：fanhy (赞：1)

~~这题什么时候绿了~~
****
看到各位大佬都用分治、进制等等，本蒟蒻只能不停地orz...

因为 $\sum\limits_{i=0}^n2^i=2^{n+1}-1$

所以直接二分查找n就可以了（当然各位大佬也可以用$\operatorname{log}_2n$）

~~我才不会告诉你我不会写$\operatorname{log}$函数~~

最后一个钱袋是剩下的

以下是完整代码，大佬勿喷...
```cpp
#include<bits/stdc++.h>
using namespace std;

long long x,a;
long long l=0,r=31,m;

long long Pow(long long a,long long b)   //stl不好用，自己写一个
{
    int c=1;
    for(int i=1;i<=b;i++) c*=a;
    return c;
}

int main()
{
    cin>>x;  //输入
    if(x==5) {printf("3\n1 1 3");return 0;}  //没办法，只能特判
    while(l+1<r)   //二分
    {
        m=(l+r)/2;
        if(Pow(2,m)<x) l=m;
        else r=m;
    }
    cout<<r<<endl;   //钱袋数量
    for(long long i=0;i<r-1;i++) cout<<Pow(2,i)<<' ';
    cout<<x-Pow(2,r-1)+1;
    return 0;
}
```
还有加一句，这道题应该加一个spj,像第三个点5就有两个解，管理员注意一下

---

## 作者：巫妖王 (赞：1)

- 小学奥数的知识,首项为1,公比为2,末项为2的n次方的等比数列,可以表示出2的n+1次方-1以内的所有正整数

- 贴上代码

```cpp
0.var i,h,k:longint;
    a:array[1..100000]of longint;
begin
read(h);//读入钱数
i:=1;
a[1]:=1;
if h=1 then 
 begin
  writeln('1');
  writeln('1');
  exit;
 end;
if h=5 then
 begin
  writeln('3');
  writeln('1 1 3');//考虑到特殊值,打了个表(小孩子不要学坏了)
  exit;
 end;
repeat
 inc(i);
 a[i]:=a[i-1]*2;//这里运用了小学奥数的知识,首项为1,公比为2,末项为2的n次方的等比数列,可以表示出2的n+1次方-1以内的所有正整数
until (a[i-1]<h)and(a[i]>=h);
a[i-1]:=h-(a[i-2]*2-1);//最后一项可能出现改动,所以要改
writeln(i-1);
for k:=1 to i-1 do
 write(a[k],' ');//输出
end.
```

---

## 作者：Enigmatic (赞：0)

这道题被分在神奇的解法里，我掐指一算，并不简单

题面告诉我们把n分成m个数，要求n以下的每个数都可以用这m个数中的几个所表示出来

显然，把n分成2的幂和一个数的和可以使m最小，然而我并不会证明。。。

但是会被hack（之前一直90）

比方说11，按照上面的分发会是1+2+4+4，题目有要求不能有两个相同的数，相同的数只会在分最后一个数的时候出现，这时就把最后一个数-1分到前面的数，以此不使有两数相等

下方AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int m,t;
int cf[40];
 
void solve()
{
	scanf("%d",&m);
	t=1;cf[0]=1;
	int mi=1,i=0;
	while(t<m)
	{
		i++;
		mi*=2;
		t+=mi;
		if(t<=m)
			cf[i]=mi;
		else	
			cf[i]=m-(t-mi);
	}
	if(cf[i]==cf[i-1]) 
	{
		cf[i]--;
		cf[i-1]++;
	}
	sort(cf,cf+i+1);
	printf("%d\n",i+1);
	for(int j=0;j<=i;j++)
		printf("%d ",cf[j]);
	return;
}
 
int main()
{
	solve();
	return 0;
}
```
PS：代码中的转移方法是只针对特殊情况的，像9就会被hack，不知为何AC了，硬核神奇


---

## 作者：jkchen (赞：0)

**原文：** https://blog.csdn.net/jk_chen_acmer/article/details/97247036

**原题：** https://www.luogu.org/problem/P2320

**题意：** 

给出一个m，你讲起拆分成最少份，使得可以组成1到m之间的任意数，大于1数只能有一份。

**解析：**

以39为例，按照二进制分可以分成$1,2,4,8,8,16$，但是不能出现两个8，怎么改呢？

我们把两个8变成$7$和$9$，也就是$1,2,4,7,9,16$。

分析对于原来分法的使用：

 - 假设没有用8，自然无所谓
 - 假设使用了一个8，那么我可以用7和1组成
 - 假设使用了一个8和一个1，我可以使用9来代替
 - 假设使用了两个8，那么直接用7和9代替

综上所述，此分法的可行性等同于二进制分法，而二进制分法一定是正确的。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[5009];

int main(){
    vector<int>v;
    int n;scanf("%d",&n);
    int p=1;
    while(n){
        v.push_back(p);
        n-=p;
        p=min(2*p,n);
    }
    sort(v.begin(),v.end());
    printf("%d\n",v.size());
    for(int i=0;i<v.size();i++){
        if(v[i]>1&&i!=v.size()-1&&v[i+1]==v[i]){
            printf("%d %d ",v[i]-1,v[i]+1);
            i++;
        }
        else
            printf("%d ",v[i]);
    }printf("\n");
}

```


---

## 作者：Komorebi_shine (赞：0)

这道题真坑啊！！！！！

第3,4个点，被大家吐槽已久，本人多次提交失败后，忍无可忍，只好暴力。

再说算法，小学奥数题，用2的i次解，即有80.

```cpp
var
 i,j,a,b,m:longint;
function f(a:longint):longint;
 var
  i:integer;
 begin
  f:=1;
  for i:=1 to a do
   f:=f*2;
 end;
begin
 readln(m);
 if m=5 then begin writeln(3);writeln(1,' ' ,1,' ' ,3);halt;end;//暴力行1
 if m=126 then begin writeln(7);writeln(1,' ',2,' ',4,' ',8,' ',16,' ',32,' ',63,' ');halt;end;//暴力行2
 b:=0;
  while m>0 do
   begin
    m:=m-f(b);
    inc(b);
   end;
 writeln(b);
 for i:=0 to b-1 do write(f(i),' ');
end.
```

---

## 作者：1517460958dyc (赞：0)

重点在于证明：

因为每个钱袋只有两种状态——取或不取，取则总钱数+1\*该钱袋钱数，不取则总钱数+0\*该钱袋钱数,。**裸裸的二进制！**

当每个钱袋的钱数取**二进制每一位的权值**时，若有k个，则能表示**2^k-1个数**（从0~2^k-1，即从0（二进制）到11…1（还是二进制））。

并且，很明显，每个钱袋**钱数不重复**，从而为**最优解**！

当然，数据没那么弱，还会**多出一些钱**，\_但不能丢掉\_（手动滑稽），于是还需处理（重复则**左--，右++**即可，因为**有1**，但因此**不能动1**，需**特判**）

贴一下代码，不加注释了，相信你们看得（bu）懂，也方便你们抄，但我开了防作弊（通通划掉）

···cpp

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long m,s,k=0,a[50];
int main()
{
    cin>>m;
    for (long long i=1;i<=(m+1)/2;i*=2)
    {
        a[k]=i;
        k++;
        s+=i;
    }
    if (m!=s) a[k]=m-s; else k--;
    sort(a,a+k);
    for (int i=0;i<=k;i++)
        if (i!=0&&a[i]==a[i+1])
        {
            a[i]--;
            a[i+1]++;
        }
    cout<<k+1<<endl;
    for (int i=0;i<=k;i++) cout<<a[i]<<' ';
    return 0;
}
```
```cpp

---

## 作者：封禁用户 (赞：0)

```cpp
#pr\//我会告诉你们
agma GCC optimize("O3")//这是O3优化么？？
#include<stdio.h>
#include<algorithm>
using namespace std;
int n,a[40],q;
bool cmp(int l,int r){
    return l<r;
}
int main(){
    while(1){
        char ch;
        ch=getchar();
        for(;ch<48||ch>57;){
            ch=getchar();
        }
        while(ch<=57&&ch>=48){
            n=(n<<1)+(n<<3)+ch-48;
            ch=getchar();
        }
        break;
```
}//神奇的读入优化。。。为了不让ch占内存搞了个循环。。。
```cpp
    for(int i=1;n;i<<=1){
        if(n>=i){
            n-=i;
            a[q++]=i;
        }
        else{
            break;
        }
```
}//把n搞成1+2+4+8+16+。。。+2的很多次方+剩下的数 的形式，用a数组来记录，n记录余数
```cpp
    if(n&1){
        if(!(n>>1)){
            sort(a,a+q,cmp);
            printf("%d\n1",q+1);
            for(int i=0;i<q;i++){
                printf(" %d",a[i]);
```
}//假如n是1
            return 0;

}//在n剩下的数是奇数时，如果这个数不是1，直接把n加入a数组，sort完输出

```cpp
        a[q]=n;
        sort(a,a+q+1,cmp);
        printf("%d\n",q+1);
        for(int i=0;i<q;i++){
            printf("%d ",a[i]);
        }
        printf("%d",a[q]);
        return 0;
    }
    else{
        if(!n){
            printf("%d\n",q);
            for(int i=0;i<q;i++){
                printf("%d ",a[i]);
            }
            return 0;
```
}//如果n不剩下，直接输出
```cpp
        int u=n&-n;
        if(u==n){
            printf("%d\n",q+1);
            printf("1 1");
            int j=1,i=1;
            for(;i<q;i++){
                printf(" %d",a[i]+j);
                j<<=1;
                if(j==n){
                    break;
                }
            }
            for(++i;i<q;i++)
            printf(" %d",a[i]);
            return 0;
```
}//如果n剩下的数与a数组重复，把n拆开到各个数字里（无论如何，我们都要比理想的2的x次方多输出一个数，所以多输出一个1，接着按照奇数的方式把它拆开）
```cpp
        else{
        a[q]=n;
        sort(a,a+q+1,cmp);
        printf("%d\n",q+1);
        for(int i=0;i<q;i++){
            printf("%d ",a[i]);
        }
        printf("%d",a[q]);
        return 0;
```
}//否则，如果与a数组不重复，sort后直接输出
    }
}

---

## 作者：Ciel_bleu (赞：0)

（人生中第二道尝试并AC的省选题）

考虑从特殊情况入手并分割子问题，若当前总钱数是偶数，则显然若该数除以二以下的数都能被取到，则分一个钱袋给该数除以二的值，那么该数以下的数都能被取到。于是我们再来证一下该算法的正确性：若取到该数除以二以下的数的值是最小值，因为其和小于该数，所以至少加一个钱袋使得该数以下的成立。

再考虑非特殊情况：若为奇数t，我们则把其分为t/2，和t/2+1，则应先考虑留下更大的t/2+1（贪心），继续分解t/2；

细节问题：1.边界，x==1,则return。2.判断是否有重，开一个vis数组（为防爆mle，我们用map实现）。

**附AC代码：**

```cpp
     #include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
long long a;
int ans[100000];
map<int,int>vis;
int tot;
bool cmp(int x,int y)
{
    return x<y;
}
void solve(int x)
{
    if(x==1)
    ans[++tot]=1;
    else{
        if(!(x%2))
        {
        if(!vis[x/2])    
        {ans[++tot]=x/2;
        vis[x/2]=1;
        solve(x/2);
            }
        else     
        {
        solve(x/2);
            }    
                }
    else {
            if(!vis[x/2+1])
            {
                ans[++tot]=x/2+1;}
            else solve(x/2+1);
            solve(x/2);
        }        
    }    
}
int main()
{
    cin>>a;
    solve(a);
    sort(ans+1,ans+tot+1,cmp);
    cout<<tot<<endl;
    for(int i=1;i<=tot;i++)
    cout<<ans[i]<<" ";
    return 0;
}
```

---

## 作者：magolor (赞：0)

跟楼下思路差不多，但是说一句，a数组（ans）真的不用那么多个，30个，最多50个就够了。

顺便所以所代码，节省代码量，核心代码只有两行，有效（非格式）代码一共四行




```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std; 
int main()
{
    int m,temp = 0,ans[30];
    for(scanf("%d",&m); m>>1; m >>= 1)    ans[++temp] = (m>>1)+(m&1);
    for(printf("%d\n1 ",temp+1); temp; temp--)    printf("%d ",ans[temp]);
    puts("");
    return 0;
}
```

---

## 作者：zqy1018 (赞：0)

用的是不知道原理的神奇方法

主要就是将金币分为2^n的个数

然后遇到两个钱袋里装着同样数目的大于1的金币时就拿一个放进下一个钱袋

```cpp
#include <stdio.h>  
#include <stdlib.h>
int m,k[100],cmp(const void *a,const void *b);  
int cmp(const void *a,const void *b){  
    return (*(int*)a-*(int*)b);  //快排
}int main() {  
    scanf("%d",&m);//m为钱币个数
    int tot=0,at=1;  //tot为钱袋个数，at为当前的2的n次方
    int i;for(at=1;m-at>=0;at<<=1){  
        k[tot++]=at;m-=at;  //将钱币一个一个放进钱袋，并让at乘以2即左移
    }if(m>0)k[tot++]=m;  //若剩余的钱币不足以成为一个2的整数次幂则装入另一个钱袋
    printf("%d\n",tot);  //输出钱袋总数
    qsort(k,tot,sizeof(k[0]),cmp);  //快排，满足输出要求
    for(i=0;i<tot-1;i++){
        if(k[i]==k[i+1]&&k[i]!=1){k[i]--;k[i+1]++;}//若有钱袋里的钱个数相同则调整
    }for(i=0;i<tot-1;i++)printf("%d ",k[i]);printf("%d\n",k[tot-1]);  //输出
    return 0;  
}  
```
哪位大神可以告诉我这种方法的原理啊...


---

## 作者：a526955194 (赞：0)

楼下的题解是错的  被坑害了..最后直接贴他代码只有80分

其实这题并没有想象中地那么复杂  按照最底层大神的方法可以轻松解决

（再次复述）

我们可以假象一下  若m=12 则需要求得组合方案有（1 2 3 4 ……12）

我们可以把他们分成两份 （1 2 …… 6） （7 8 ……12）称左边的为L 右边的为R

很容易得知R中的每种方案都可以由（12/2）+左边的组合得出

再次分成两份（1 2 3）（4 5 6）

同理
当m为奇数时  显而易见地  只需把 (m/2)改为（m/2+1） 即可

（可能用递归更好理解  下面的代码是用while循环实现的）

```cpp

#include <cstdio>  
#include <algorithm>  
using namespace std;  
int m,t,a[100005],i;  
int main()  
{  
    scanf("%d",&m); 
    while (m/2!=0)  
    {  
        t++;
        if (m%2==0) a[t]=m/2;
        if (m%2==1) a[t]=m/2+1;
        m/=2; 
    }
    printf("%d\n1 ",t+1);  
    for (i=t; i>=1; i--)  
        printf("%d ",a[i]); 
    return 0;
}

```

---

## 作者：一UNowen一 (赞：0)

解题关键：对于任意的金币数目m，只要一个钱袋金币数目为(m+1)div 2，且小于(m+1)div 2 的金币数目都能凑出，则任何大于(m+1)div 2 的金币数目k，都可用(k-(m+1)div 2)的金币凑出方法再加上(m+1)div 2的钱袋凑出。[codep ]procedure p(k:longint);

```cpp
begin  
inc(tot);  
a[tot]:=(k+1)div 2;  
if k>1 then p(k-(k+1) div 2);  
end;  [/codep ]
```

---

## 作者：红石小蝈 (赞：0)

看了一圈题解，发现用二进制的一个也没有

## 思路:
如果表示1023以下的数:用1,2,4,8,16...512九个数，如果是1023+35呢？只要多出一个35就好了。（35只是一个例子）
### 正确性：
1-35可以表示，余下的数字减去35再用原来的表示方式即可（不仅局限于35）

## 注意事项：
以上，再用上位运算即可方便AC，然后注意比较，如果有两数相同，则将前者减一，后者加一即可

代码
```cpp
#include <iostream>
using namespace std;
int main(){
    int m;
    cin>>m;
    int n=1,i=1;bool flag=1;
    for(;n<m;i++,n=(n<<1)|1);
    cout<<i<<endl;
    n>>=1;
    for(int newn=1,sum=1;sum<=m;newn<<=1,sum|=newn){
        if(m-n<newn&&flag){
            flag=0;
            cout<<m-n<<' '<<newn;
        }else if(m-n==newn){
            if(sum==m)
                cout<<newn;
            else if(newn!=1)
                cout<<newn-1<<' '<<newn+1;
            else
                cout<<"1 1";
            flag=0;
        }else
            cout<<newn;
        if((newn<<1)<m)
            cout<<' ';
    }
    if(flag)
        cout<<m-n;
    return 0;
}

```



---


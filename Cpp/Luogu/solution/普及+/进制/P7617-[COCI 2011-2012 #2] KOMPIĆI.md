# [COCI 2011/2012 #2] KOMPIĆI

## 题目描述

给定 $N$ 个正整数 $A_1,A_2,...,A_N$，求有多少整数对 $(i,j)$，满足以下条件：

- $1 \le i < j \le N$
- **$A_i$ 和 $A_j$ 至少有一位数字是相同的（不一定要在相同的数位）**。

## 说明/提示

#### 【样例解释】

样例 1 中，满足要求的整数对为 $(1,3)$。

样例 2 中，满足要求的整数对为 $(1,3)$，$(1,4)$，$(2,3)$，$(3,4)$。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 10^6$，$1 \le A_i \le 10^{18}$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $120$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #2](https://hsin.hr/coci/archive/2011_2012/contest2_tasks.pdf)** ___T4 KOMPIĆI___。

## 样例 #1

### 输入

```
3
4
20
44```

### 输出

```
1```

## 样例 #2

### 输入

```
4
32
51
123
282```

### 输出

```
4```

# 题解

## 作者：D2T1 (赞：9)

[$\color{blue}{\text {pwp }~{\to\textbf{My blog}\gets}}~\text{qwq}$](https://www.luogu.com.cn/blog/390770/blogcenter)

## 题解

首先考虑一个数不在乎它的每一个数位是什么、哪几个数位相同，只用关心这个数中是否出现了 $0\sim9$ 中的数，所以我们可以**用一个 $10$ 位二进制数表示一个输入的数，这个二进制数的第 $k$ 位为 $1$ 表示输入的数中含有数字 $k$**。

然后使用一个数组 $k$ 存储每个二进制数的数量。

然后答案就分为两种情况：

- 两个二进制数**不同但进行与运算不为零**，$O(1024^2)$ 查找整个数组 $k$ 即可。

- 两个二进制数**相同**，$O(1024)$ 遍历即可。

总复杂度 $O(1024^2)$

## 代码

```cpp
//P7617
#include <cstdio>
long long ans;
int k[1024+10],n;

int main(){
	scanf("%d",&n);
	while(n--){
		long long a; int x=0;
		scanf("%lld",&a);
		while(a) x|=(1<<(a%10)),a/=10;
		++k[x];
	}
	for(int i=0; i<1024; ++i)
		for(int j=i+1; j<1024; ++j)
			if(i&j) ans+=(long long)k[i]*k[j];//情况一，乘法原理
	for(int i=0; i<1024; ++i)
		ans+=(long long)k[i]*(k[i]-1)/2;//情况二，组合
	return printf("%lld\n",ans)&0;
}
```


---

## 作者：__HHX__ (赞：3)

# 思路
因为题目中（**不一定要在相同的数位**）所以我们可以把一个数中每个位上的数是否出现给记下来。

在这里我们可以用**状压**的思想给记录下来，其中第 $i$ 位上的数表示一个数是否在某一位上出现过 $i$。

比如 $(20) _ {10}$ 在此状压表示中为 $(101) _ 2$，其中第 $2$ 位和第 $0$ 位为 $1$，表示这个数中出现了 $2$ 和 $0$。

那这又什么用呢？

当有两个数在此状压下有一位相同，那就算为一对（我们可以把它看做位运算中的与运算）。

因为每个数都可以转化成一个 $0 \sim 2 ^ {10}$，所以我们可以开个 $cnt$ 数组，存下这些转化的数。

然后枚举 $i,j$，下面 $\&$ 为位与运算。

当 $i \& j$ 不为 $0$ 且 $i \neq j $，则 $ans = ans + cnt_i \times cnt_j$，表示把每个 $cnt_i$ 匹配每个 $cnt_j$。

如果 $i = j$，则 $ans = ans + {cnt_i \times (cnt_i - 1) \over 2}$，表示把每个 $cnt_i$ 匹配 $cnt_i$。
# 实现
```cpp
#include<iostream>

using namespace std;

const int MaxN = 1 << 10;

long long cnt[MaxN], ans;

int main() {
  int n;
  cin >> n;
  for(long long i = 1, x, s = 0; i <= n; i++, s = 0) {
    cin >> x;
    while(x) {
      s |= 1 << (x % 10);
      x /= 10;
    }
    cnt[s]++;
  }
  for(int i = 0; i < MaxN; i++) {
    for(int j = i; j < MaxN; j++) {
      if(i & j) {
        ans += (i != j ? cnt[i] * cnt[j] : cnt[i] * (cnt[i] - 1ll) / 2ll);
      }
    }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：Jerrywang09 (赞：2)

### 先说几句

难度低了，至少也得是绿题。

绝对是一道状态压缩的好题，带上容斥原理，怎是一道黄题？

### 解题思路

对于输入的每个数，统计 $0\cdots 9$ 每个数的出现。如果出现了，相应的状态位设为 $1$。在对于每种不同的状态进行统计，存入数组 $a$ 中。

记录数组 $b$，统计对于每个状态位有多少个状态位包含它。
枚举状态位 $i,j$，双重循环。如果状态 $i$ 完全包含于 $j$（$j$ 完全包含 $i$），就对 $b_i$ 累加 $a_j$。

计算答案时，枚举每个状态位，统计其中 $1$ 的个数。对于每种组合 $C_{b_x}^2$ 按照容斥原理，奇加偶减。

### 辅助解释

至于为什么这样做是对的？思考一下，其实，$b$ 中记录的实际上是什么？

是记录每种数位的组合情况被哪些数包含了！以此为基础，对于任意一个数对，已按照容斥原理计算出了。

### 奉上代码

```cpp
// P7617 [COCI2011-2012#2] KOMPICI
#include <bits/stdc++.h>
#define int long long
#define SIZE 1024
#define all(x) x.begin(), x.end()
#define debug(x) cout<<#x<<":"<<x<<endl; 
using namespace std;

int a[SIZE]={0}, b[SIZE]={0};

signed main()
{
	int n; cin>>n;
	for(int i=0; i<n; i++)
	{
		int x; cin>>x;
		int y=0;
		while(x)
		{
			y|=1<<(x%10); x/=10;
		}
		a[y]++;
	}
	for(int i=0; i<SIZE; i++)
		for(int j=i; j<SIZE; j++)
			if((i|j)==j)		// j contains i or i is the base of j
				b[i]+=a[j];
	int sum=0;
	for(int x=1; x<SIZE; x++)
	{
		int onecount=0;			// count 1's
		for(int k=0; k<10; k++)
		{
			int t=1<<k; if(t&x) onecount++;
		}
		// the inclusion exclusion principle
		// odd: plus even: minus
		if(onecount%2==1) sum+=b[x]*(b[x]-1)/2;
		else              sum-=b[x]*(b[x]-1)/2;
	}
	cout<<sum;

    return 0;
}
```

---

## 作者：lbh666 (赞：1)

## 题目大意
给出 $N$ 个整数，只要 $1 \le i < j \le N$ 且第 $i$ 项和第 $j$ 项的数位上有一个数相同，他们就算一个整数对，举个例子：$4$ 和 $44$ 都有一个 $4$，那么它们就构成了一个整数对。

## 思路分析
- 考虑使用暴力，只得了一半的分数，肯定不行。

- 看到标签：进制，我马上想到了二进制，考虑使用**二进制**来做。

- 感谢 [pxb0801](https://www.luogu.com.cn/user/372838) 提供的题解的思路，给了我很大的启发，思路如下。

> 如果出现了数字 $0$，则这个数就会加上 $2^{10} \times 1$；如果出现了数字 $2$，则这个数就会加上 $2^8 \times 1$，以此类推。

根据上面的结论举个例子：$64$ 出现了 $6$ 和 $4$，那么对应的**二进制**就应该是 $2^4 \times 1 + 2^6 \times 1 = 80$。

- 不难推出任何数的二进制都小于 $1024$，我们就可以用二重循环来枚举各种情况。

- 如果 $i$ 和 $j$ 相等，也就是它们两个的异或结果为 $0$，我们就用排列组合的组合来计算方案数，方案数为 $\frac{a_i \times (a_i - 1)}{2}$，这个公式是从组合公式里推出来的，具体如下。

$$C_{a_i}^{2} = \frac{A_{a_i}^{2}}{2} = \frac{a_i \times (a_i - 1)}{2}$$

- 以上公式解释：$A$ 代表[排列](https://baike.baidu.com/item/%E6%8E%92%E5%88%97%E6%95%B0%E5%85%AC%E5%BC%8F/8532609?fr=ge_ala)，$C$ 代表[组合](https://baike.baidu.com/item/%E7%BB%84%E5%90%88/12004197?fromModule=lemma_search-box)，套组合公式就可以推导出来。

- 如果它们不相等，但[与一下](https://blog.csdn.net/OMars/article/details/123007805)不为 $0$，我们就让 $a_i$ 和 $a_j$ 一一匹配，方案数 $a_i \times a_j$，我们把每次的方案加进用来统计的变量 $ans$ 中，最后输出就好了。

- 上面的方案用的是[乘法原理](https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86?fromModule=lemma_search-box)，链接里有很好的解释，不懂的自己看吧。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long  //开long long是肯定的 
using namespace std;

const ll N=1024;  
ll a[N+5],t,n,ans=0;     
bool tot[10];   //用来统计每次输入的数包含哪些数 

int main(){
	cin>>n;
	while(n--){ 
		cin>>t;    //输入 
		while(t!=0){
			tot[t%10]=1;  //t有的数字都存在tot数组里 
			t/=10;    //将t分解每一位 
		}
		ll s=0;
		for(ll i=0;i<=9;++i)s=s*2+tot[i]; //转成二进制 
		a[s]++;    //加进桶里 
		memset(tot,0,sizeof(tot)); //每次将tot这个数组用memset清零，方便处理下一个数 
	}
	for(ll i=0;i<N;++i){
		for(ll j=i;j<N;++j){     //枚举，这里的j=i是防止重复 
		    //如果i异或j是0的话（等同于i==j），就加上组合（相当于从a[i]个数里挑出2个(还不能重复)的方案数）方案
			//上面一行的注释中，不能重复的意思是(a,b)和(b,a)算同种，如果算不同种就是排列
			//用排列不符合题意，所以用组合 
			if(!(i^j))ans+=a[i]*(a[i]-1)/2;
			else if(i&j)ans+=a[i]*a[j];  //或者i和j不同，但有数位相同，就用乘法原理将a[i]*a[j]加进ans  
		}
	}
	cout<<ans;      //最后输出 
	return 0;
}
```

---

## 作者：ZYH_juruo (赞：1)

# 题目传送门
[P7617 [COCI2011-2012#2] KOMPIĆI](https://www.luogu.com.cn/problem/P7617)

# 题目分析
刚开始想的是暴力，很明显，肯定不行。看了题目的标签，又看了大佬们的题解，这才知道怎么做。

这题的关键是如何存储每个数字的数位，这道题目说了：

**$A_i$ 和 $A_j$ 至少有一位数字是相同的（不一定要在相同的数位）。**

既然不能用暴力，又要用进制，那可不就是用二进制吗，然后[**与运算**](https://baike.baidu.com/item/%E4%B8%8E/13025631)便横空出世。我们只需要将输入的数处理成二进制数（具体实现时不太一样），然后两两处理，通过乘法原理得出：对于一个数 $i$，它的方案数为 $\frac{a_i\times(a_i-1)}{2}$。实在不懂，请见代码qwq。
# ACCODE

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1025],ans;
int s[10];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		memset(s,0,sizeof(s));
		int x;cin>>x;
		while(x!=0)
		{
			s[x%10]=1;将它每个数位上的数记录
			x/=10;
		}
		for(int i=0;i<10;i++)
			x=x*2+s[i];再转化为二进制数
		a[x]++;
	}
	for(int i=0;i<1024;i++)
	{
		for(int j=i;j<=1024;j++)
		{
			if(i==j)
				ans+=a[i]*(a[i]-1)/2;乘法原理
			else if(i&j)
				ans+=a[i]*a[j];
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
**完结撒花！！！。**


---

## 作者：pxb0801 (赞：1)

## 1. 分析：

做这题，很快就可以发现：本题与每个数具体是什么无关，只和每个数在 $0$ 到 $9$ 中出现了哪些有关，所以我们很快想到表示这个数在 $0$ 到 $9$ 中出现了哪些的方法，那就是**二进制**，如果出现了数字 $0$，则这个数就会加上 $2^{10}  \times 1$；如果出现了数字 $2$，则这个数就会加上 $2^8 \times 1$，以此类推。

譬如：数 $25313$。它出现了数字 $1,2,3,5$。那么变为二进制就是：

$$2^{10} \times 0+2^9 \times 1+2^8 \times 1+2^7 \times 1+2^6 \times 0+2^5 \times 1+2^4 \times 0+ … +2^0 \times 0=928$$

很明显任何数都在 $[0,1023]$ 之间。枚举任意两种情况的复杂度就降到了 $O(1024^2)$。

-----------------
我们用 $a$ 数组表示每种数（二进制相同的叫做一种数）的数量。

对于任意的一种数 $i$，显然可以在内部任意组合，方案数是 $\dfrac{a_i(a_i-1)}{2}$。

对于任意的两种数 $i$ 和 $j$，由于表示成了二进制，所以只要满足 $a_i\land a_j \not= 0$，则它们至少有一位数相等。只要符合条件，那么方案数就有 $a_i \times a_j$。

-------------------
## 2. AC 代码：

```cpp#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[1030],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		int num[10]={0};//记录每个数字在x中是否出现
		while(x){
			num[x%10]=1;//数位分解
			x/=10;
		}
		for(int i=0;i<10;i++){
			x=x*2+num[i];//变成二进制
		}
		a[x]++;//这种数又多了一个
	}
	for(int i=0;i<1024;i++){
		for(int j=i;j<=1024;j++){//从i枚举，防止重复
			if(i==j){//一种数内部选
				ans+=a[i]*(a[i]-1)/2;
			}
			else if(i&j){//两种数选
				ans+=a[i]*a[j];
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Kreado (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7617)。

## 思路

其实题面中的 $A_i$ 和 $A_j$ 至少有一位是相同的（不一定是同一位）已经告诉我们答案和 $A_i$ 和 $A_j$ 中数位出现的顺序，次数是没有关系的，我们只关心这个数位是否在数 $A_i$ 中出现过，这启示我们对每个数位状态压缩，一共 $2^{10}$ 个状态。

记录这 $2^{10}$ 个状态的个数 $g_i$，对于状态 $i,j(i\not =j)$，这两个状态所表示的数有一位相同当且仅当 $i\operatorname{and} j\not =0$，它俩的贡献是 $g_i\times g_j$。

对于同状态的数，它的贡献是 $\dfrac{g_i\times (g_{i}-1)}{2}$。

加起来就是最后的答案。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll n,g[2000],ans;

int main(){
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		ll res=0;
		while(x) res|=(1<<(x%10)),x/=10;
		g[res]++;
	}
	for(ll i=0;i<1024;i++)
		for(ll j=i+1;j<1024;j++)
			if(i&j) ans+=g[i]*g[j];
	for(ll i=1;i<=1024;i++)
		ans+=((g[i]-1)*g[i]/2);
	printf("%lld",ans);
	return 0;
}



```


---

## 作者：heyx0201 (赞：0)

# 题解
## 思路
不用关心每个数的每一位是什么、哪几位相同，我们只需记录每个数出现了哪几个数字，可以使用类似于**状态压缩**的思想记录每个数的状压形式，比如一个数为 $(4)_{10}$，那么他的状态压缩形式为 $(00001)_2$。

当两个数在状态压缩表示下有一位相同，我们就认为这两个数是一对，每个二进制数可以化为 $1 \sim 2^{10}$，所以开一个标记数组记录。

然后在 $1 \sim 2^{10}$ 的范围内枚举两个数，如果 $i \operatorname{and}  j \ne 0$ 且 $i \ne j$，就用乘法原理更新答案，如果 $i=j$，也就是答案应该更新为 $ans = ans + \frac{cnt_i \times cnt_{i - 1}}{2}$，表示把每个 $cnt_i$ 跟 $cnt_i$ 配上。

## 输入处理：
```cpp
for (int i = 1; i <= n; i++){
  cin >> x;
  while (x){
    a[i] |= 1ll << (x % 10);
    x /= 10;
  }
  cnt[a[i]]++;
}
```

## 枚举两个数
```cpp
long long ans = 0;
  for (int i = 1; i < INF; i++){
    for (int j = i; j < INF; j++){
      if (i & j && i != j){
        ans += cnt[i] * cnt[j];
      }
      if (i == j){
        ans += cnt[i] * (cnt[i] - 1) / 2;
      }
    }
  }
```
## AC Code
```cpp
#include<iosteam>

using namespace std;

const int MAXN = 1e6 + 10,INF = 1024;

int n,a[MAXN];
long long x,cnt[MAXN];

int main(){
  cin >> n;
  for (int i = 1; i <= n; i++){
    cin >> x;
    for (; x; x /= 10){
      a[i] |= 1ll << (x % 10); // 状压
    }
    cnt[a[i]]++; // 统计
  }
  long long ans = 0;
  for (int i = 1; i < INF; i++){
    for (int j = i; j < INF; j++){
      if (i & j && i != j){ // 如果两个不相同的数可以配成一对
        ans += cnt[i] * cnt[j]; // 乘法原理更新答案
      }
      if (i == j){ // 自己跟自己配一对
        ans += cnt[i] * (cnt[i] - 1) / 2; // 更新答案
      }
    }
  }
  cout << ans;  
  return 0;
}
```

---


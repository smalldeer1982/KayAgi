# 「C.E.L.U-02」学术精神

## 题目描述

提供 **一句话题意** 阅读。

某地有 $n$ 个小朋友，每个小朋友都有一个**独特的**  idea，其中第 $i$ 个小朋友的 idea 的 **编号** 为 $i$。老师让这个每一个小朋友在一组编号分别为 $1\sim n$ 的卡片中随机抽一个，**抽完后把卡片放回去**，这个小朋友会和编号为卡片上数字的小朋友**交换** idea（交换指**两人**把**所有**自己知道的 idea 告诉对方）。因为自己和自己交换 idea 在他们眼中也许是一件很傻的事情，所以如果**卡片上的编号与自己的相同**，他将再抽一次（此时他已经把卡片放回去了），**直到编号不是自己**的为止。

不久，每个小朋友都抽完了一遍，每个小朋友将把收集到的**所有** idea 出成一场比赛，因为有 idea 的交换，有很多比赛之间都是**有联系**的。

如果两场比赛中存在 idea **相同**的题目，我们认为这两场比赛是有联系的。「联系」具有**传递性**：**如果比赛 $\mathbf A$、$\mathbf B$ 有联系，比赛 $\mathbf B$、$\mathbf C$ 有联系，则比赛 $\mathbf A$、$\mathbf C$ 也有联系**。为了避免理解错误，在这举一个例子：

若仅有四场比赛：比赛一出现了 idea $1$、$2$；比赛二出现 idea $2$、$5$ ；比赛三出现 idea $3$、$5$、$8$，比赛四出现 idea $4$、$7$。则比赛一、二之间有**直接联系**。比赛一、三之间虽然没有公共 idea，但它们之间是**有联系**的。比赛四与其他所有比赛没有联系。  

而所有有联系的比赛都将属于同一个比赛集，没有联系的比赛处在不同的比赛集。

上例中比赛一、二、三属于一个比赛集，比赛四属于另一个。

求所有人**抽球卡片的次数和**的期望 $E_0$ 和比赛集的个数 $s$ 的期望 $E_1$。

---

**一句话题意：**

对于每个点 $i$ 随机与 $[1,n]$ 中的一点连无向边，若连向自己，则保留该边并再次连边，一直重复至连到别的点上为止，求边数与连通块个数期望。

## 说明/提示

---

### 样例解释  

**样例解释一**

- 每个小朋友摸卡片次数为 $1$ 的概率为 $\dfrac{1}{2}$，摸卡片次数为 $2$ 的概率为 $\dfrac{1}{4}$，摸卡片次数为 $i$ 的期望次数为 $\dfrac{1}{2^i}$，期望摸卡片次数为 $2$，总摸卡片次数为 $4$。

- $1$ 号小朋友一定会和 $2$ 号小朋友交换 idea，所以他们出的比赛之间一定是属于同一个比赛集。$E_1=1$。

**样例解释二**

- 第一问取模前的答案为 $\dfrac{49}{6}$。

- 第二问取模前的答案为 $\dfrac{2245}{1944}$。

---

### 数据范围

| 测试点编号 | $n$ | 测试点编号 | $n$ | 
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 3$ | $5$ | $\leq 1000$ |
| $2$ | $\leq 5$ | $6$ | $\leq 2000$ | 
| $3$ | $\leq 9$ | $7\sim8$ | $\leq 5000$ | 
| $4$ | $\leq 12$ | $9\sim 10$ | $\leq10^4$ | 

对于 $100\%$ 的数据，有 $2\leq n\leq10^4$。

---


## 样例 #1

### 输入

```
2```

### 输出

```
4
1```

## 样例 #2

### 输入

```
7```

### 输出

```
166374067
539688692```

# 题解

## 作者：Tx_Lcy (赞：11)

最近在补期望，于是就找到了这道好题，感觉题解的叙述有些过于高大上，我以我自己的理解简单地叙述一下。

[题目传送门](https://www.luogu.com.cn/problem/P7474)
## 思路
对于每个点 $i$，**连 $1$ 条边的概率为 $100\%$，再连一条边的概率为 $\frac{1}{n}$，以此类推**。我们不妨设 $edge_i$ 为 $i$ 的期望边数。

显然，$edge_i=1 \times(1+\frac{1}{n}+\frac{1}{n^2}+...)$，则 $n \times edge_i=1 \times (n+1+\frac{1}{n}+\frac{1}{n^2}+...)$，**两式相减**，得 $(n-1) \times edge_i=n$，$edge_i=\frac{n}{n-1}$，$\sum edge_i=n \times \frac{n}{n-1}=\frac{n^2}{n-1}$。

**所以，第一问的答案就是 $\frac{n^2}{n-1}$。**

关于第二问，我们可以发现，自己与自己连边显然对答案无影响，所以我们**不考虑自环**，这样边的总数即是 $n$ 条，由于有可能有重边，所以**不一定是联通的**，但在每个连通块内部一定是边与点数相同，即为一颗**基环树**。所以设连通块数为 $ans$，**我们发现 $ans=$ $sum$ 基环树 $=$ $sum$ 环。**

所以第二问等价于求环的个数。

我们先求出这张图有**多少种可能性**，我们记为 $maxn$，显然，每个节点有 $n-1$ 种不同的连法，不需要考虑重边，所以我们直接乘法原理，得到 $maxn=(n-1)^n$。

接下来我们考虑在所有图中出现的环的总数，我们记为 $maxx$，我们按照环的大小分类讨论，设环的大小为 $i$，则 $2 \le i \le n$。对于一个确定的 $i$，可能出现的环的总数为 $C_n^i \times (i-1)! \times (n-1)^{n-i}$，**通俗地讲，$C_n^i$ 表示从 $n$ 个节点里面随便选 $i$ 个点，让它们组成环，它们内部的边的种类有 $(i-1)!$ 种，而别的点的可能性有 $(n-1)^{n-i}$ 种，我们根据乘法原理都乘起来即可。**，所以 $maxx=\sum_{i=2}^n C_n^i \times (i-1)! \times (n-1)^{n-i}$。

**所以，第二问的答案就是 $\frac{maxx}{maxn}=\frac{\sum_{i=2}^n C_n^i \times (i-1)! \times (n-1)^{n-i}}{(n-1)^n}$。**

当然，这个答案柿子仍然可以化简，这就交由各位读者自己去完成了，此处不再赘述。
## 代码
弄明白了过程，代码很好写。
```cpp
//A tree without skin will surely die. 
//A man without face is invincible.
#include<bits/stdc++.h>
#define int long long
#define rint register int
using namespace std;
int const mod=998244353;
int const N=1e4+10;
int fac[N],facn[N];
#define inv(x) (qpow(x,mod-2))
inline int qpow(int a,int b){
    int ans=1;
    while (b){
        if (b&1) ans*=a,ans%=mod;
        a*=a,a%=mod,b>>=1;
    }
    return ans;
}
inline int C(int n,int m){return fac[n]*inv(fac[m])%mod*inv(fac[n-m])%mod;}
signed main(){
    ios::sync_with_stdio(false);
    cout.tie(0),cout.tie(0);
    int n;cin>>n;
    fac[0]=1;
    for (int i=1;i<=n;++i) fac[i]=fac[i-1]*i,fac[i]%=mod;
    facn[0]=1;
    for (int i=1;i<=n;++i) facn[i]=facn[i-1]*(n-1),facn[i]%=mod;//预处理 (n-1) 的次方
    cout<<n*n%mod*inv(n-1)%mod<<'\n';
    int ans=0;
    for (int i=2;i<=n;++i) ans+=(C(n,i)*fac[i-1]%mod*facn[n-i]%mod),ans%=mod;
    cout<<ans*inv(facn[n])%mod<<'\n';
    return 0;
}
```


---

## 作者：0x3F (赞：8)

第一问，每一次连边成功的概率为 $\frac{n-1}{n}$，故期望次数为 $\frac{n}{n-1}$。

因为每一个点都要连一条边，所以乘以 $n$ ，即 $\frac{n^2}{n-1}$。

第二问，首先可以发现：在本题中，连完以后，每一个连通块都是一个基环树。

所以连通块的数量等于基环树的数量，也等于环的数量。

问题转化成了求环的数量的期望值。

而环的数量的期望值等于每一个可能的环出现的概率之和。

对于任意一个长为 $i$ 的确定的有向环，不在环上的点指向不受限制，而环上的点有 $(n-1)^i$ 种不同的指向，其中只有 $1$ 种符合条件，故该环出现的概率为 $\frac{1}{(n-1)^i}$。

考虑按顺序选择环上的 $i$ 个点，则总数为 $n(n-1)(n-2)\cdots(n-i+1) = \operatorname{P}_n^i$。

由于环上的 $i$ 个点都可以作为起点，所以除以 $i$。注意是有向环，所以不需要除以 $2$。

故长为 $i$ 的环的数量的期望值为 $\frac{\operatorname{P}_n^i}{i(n-1)^i}$。

故答案为 $\sum_{i=2}^{n}{\frac{\operatorname{P}_n^i}{i(n-1)^i}}$。

综上所述，两小问答案分别为：

$$\frac{n^2}{n-1}, \sum_{i=2}^{n}{\frac{\operatorname{P}_{n}^{i}}{i(n-1)^i}}$$

代码如下：

```cpp
#include <cstdio>
const int p = 998244353;
int n, t;
inline int qpow(int a, int b) {
	int s = 1;
	while (b) {
		if (b & 1) s = (long long) s * a % p;
		a = (long long) a * a % p;
		b >>= 1;
	}
	return s;
}
int main() {
	scanf("%d", &n);
	printf("%d\n", (long long) n * n % p * qpow(n - 1, p - 2) % p);
	for (int i = 2, j = n * (n-1); i <= n; j = (long long) j * (n - (i++)) % p) {
		t = (t + (long long) j * qpow(i, p - 2) % p * qpow(n - 1, p - i - 1)) % p;
	}
	printf("%d\n", t);
    return 0;
}
```


---

## 作者：TonyYin (赞：1)

P7474 -「C.E.L.U-02」学术精神

# 题意

对于每个点 $i$ 随机与 $[1, n]$ 中的一点连无向边，若连向自己，则保留该边并再次连边，一直重复至连到别的点上为止，求边数与连通块个数期望。

# 题解

## 期望边数

首先，注意到每个点的期望次数一定相同，所以只算一个点即可。

之后利用几何分布相关定理，成功选到非自身的点的概率为 $\operatorname{p}=\frac{n-1}{n}$，期望 $\operatorname{E}=\frac{1}{p}=\frac{n}{n-1}$.

下面给出证明。

由期望的定义可知，设 $p=\frac{n-1}{n}$，期望的计算式为：
$$
E=1\times (1-p)^0\cdot p+2\times(1-p)^1\cdot p+3\times(1-p)^2\cdot p+\cdots+k\times (1-p)^{k-1}\cdot p
$$
设 $q=1-p$，则：
$$
E=p\cdot (1\cdot q^0+2\cdot q^1+3\cdot q^2+\cdots + k\cdot q^{k-1})
$$
设 $S=\frac{E}{p}$，错位相减求和：
$$
\begin{array}{rl}
S&=1\cdot q^0+2\cdot q^1+3\cdot q^2+\cdots + k\cdot q^{k-1}\\
q\cdot S&=\textcolor{white}{0\cdot q^0}+1\cdot q^1+2\cdot q^2+\cdots+(k-1)\cdot q^{k-1}+k\cdot q^k\\
(1-q)S &= q^0+q^1+q^2+q^3+\cdots +q^{k-1}-k\cdot q^k\\
(1-q)S &= \dfrac{1-q^k}{1-q}-k\cdot q^k
\end{array}
$$
当 $k\rightarrow +\infty$ 时，$q^k\rightarrow 0$，所以：
$$
S=\frac{1}{(1-q)^2}
$$
期望为：
$$
E=p\cdot S=\frac{p}{(1-q)^2}=\frac{1}{p}
$$
共 $n$ 个点，所以题目所求答案为：
$$
\operatorname{Ans}=n\cdot E=\frac{n}{\frac{n-1}{n}}=\frac{n^2}{n-1}
$$

## 期望连通块数

如果把每个点向其他点连的边看为有向边，则每个点的出度均为 $1$，所以每个连通块都是基环树。

因此：环的个数 $=$ 基环树个数 $=$ 连通块个数，下面求环的期望数量 $E$.
$$
E=\frac{\text{所有图中环的总数}}{\text{图的总数}}=\frac{A}{B}
$$
每个点都可以向外连边，图的总数为：
$$
B=(n-1)^n
$$
环的总数：先枚举环的点数 $i$，再确定哪些点在环上，其余点可以随便连边，环上的点再圆排列。
$$
A=\sum_{i=2}^n \binom{n}{i}\cdot (n-1)^{n-i}\cdot (i-1)!
$$
化简：
$$
\begin{aligned}
E &= \frac{A}{B}\\
  &= \sum_{i=2}^n \dfrac{\binom{n}{i}\cdot (n-1)^{n-i}\cdot (i-1)!}{(n-1)^n}\\
  &= \sum_{i=2}^n \dfrac{n!\cdot (i-1)!}{i!\cdot (n-i)!\cdot (n-1)^i}\\
  &= \sum_{i=2}^n \dfrac{n\cdot (n-1)\cdot (n-2)\cdots(n-i+1)}{i\cdot (n-1)^i}
\end{aligned}
$$
不用预处理逆元，可以 $\mathcal O(n)$ 计算。

# 代码

```cpp
#define int long long
using namespace std;
const int mod = 998244353;
int n, ans = 0;
inline int power(int x, int k) {
	int ret = 1;
	while(k) {
		if(k & 1) ret = ret * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return ret;
}
inline int inv(int x) { return power(x, mod - 2); }
signed main() {
	cin >> n;
	printf("%lld\n", n * n % mod * inv(n - 1) % mod);
	int tmp = n, Pow = n - 1;
	for(int i = 2; i <= n; i++) {
		tmp = tmp * (n - i + 1) % mod;
		Pow = Pow * (n - 1) % mod;
		ans = (ans + tmp * inv(i) % mod * inv(Pow) % mod) % mod;
	}
	printf("%lld\n", ans);
	return 0;
}
```



---

## 作者：LinkCatTree (赞：0)

很好期望题，让我心态爆炸（其实把思路捋清楚还是比较简单的）

首先考虑第一问。对于每一个点，至少会连 $1$ 条边，如果 $\frac1n$ 的概率选到自己则连第 $2$ 条边，如果又 $\frac1n$ 的概率选到自己就连第 $3$ 条边……以此类推，可得某个点为起点所连的有向边期望数为 $1+\frac1n+(\frac1n)^2+\cdots=\frac{n}{n-1}$。那么 $n$ 个点期望为 $\frac{n^2}{n-1}$ 条边。

再考虑第二问，观察题目可知某一个联通块中必包含且仅包含一个环。因此联通块期望个数即为各种大小环的期望个数之和。考虑对于一个大小为 $x$ 的环，这 $x$ 的点共有 $(n-1)^x$ 种连边方式，而其中只有一种连边方式符合（注意是有向环），所以大小为 $x$ 的环期望个数为 $\frac{C_n^i}{x(n-1)^x}$（注意要除以一个 $x$ 因为同一个有向环会被计算 $x$ 次）枚举环的大小并累加即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod=998244353;
ll quickpow(ll base,ll p,ll mod) {
	ll tmp=1LL;
	for(;p;p>>=1) {
		if(p&1) tmp=tmp*base%mod;
		base=base*base%mod;
	}
	return tmp;
}

int main() {
	ll n; cin>>n;
	printf("%lld ",(n*n%mod)*quickpow(n-1LL,mod-2,mod)%mod);
	ll ans=0,p=n;
	for(int i=2;i<=n;i++) {
		p=p*(n-i+1LL)%mod;
		ans=(ans+p*quickpow(i*quickpow(n-1LL,i,mod)%mod,mod-2,mod)%mod)%mod; 
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：luxiaomao (赞：0)

## [P7474](https://www.luogu.com.cn/problem/P7474) 期望好题

刚学期望的蒟蒻表示期望好难。

## Solution

**题意：**

> 给出 $n$ 个点，对于每个点 $i$ 随机向图中的一点连无向边，若连到了自己，则保留该边并再次连边，一直重复至连到别的点上为止，求边数与连通块期望个数。

**第一问：**

还是比较送分的。

首先必须要连 $1$ 条边，连完后有 $\dfrac{1}{n}$ 的概率连到自己，必须再连边，那就是 $1+\dfrac{1}{n}$。第二次连边里又有 $\dfrac{1}{n}$ 的概率连到自己，那就是 $1+\dfrac{1}{n}+\dfrac{1}{n^2}+\dots$

$$sum = 1+\dfrac{1}{n}+\dfrac{1}{n^2}+\dfrac{1}{n^3}+\dots$$

然后就是无穷等比数列经典的错位相减：

$$n\times sum = n+1+\dfrac{1}{n}+\dfrac{1}{n^2}+\dots$$

$$(n-1)\times sum = n$$

$$sum = \dfrac{n}{n-1}$$

这只考虑了一个点，那我们乘上 $n$，就是第一问的答案了。

$$ans_1 = \dfrac{n^2}{n-1}$$

**第二问：**

先分析一下，构成的联通块具有怎样的性质？

先不考虑自环，每个点都会带一条无向边，那么一个联通块的点数和边数就是一样多的。没错，这是一棵基环树。

粽锁粥汁，每棵基环树都有且仅有一个环，那么求联通块的期望个数实际上就是求环的期望个数。

环的期望个数可以表述为**可能出现的所有环的个数 除以 这张图的情况数**。

图的情况总数很好求，每个点可以向其他 $n-1$ 条边连边，总共有 $n$ 个点，那就是 $(n-1)^n$ 种。

接着是总共会出现多少个环。

首先环的大小在 $2$ 到 $n$ 之间，我们先记这个大小为 $i$。

那么由哪些点来组成这个环呢？我们要从 $n$ 个点中选取 $i$ 个（先后顺序下一段再来考虑），那就有 $C_n^i$ 种可能性。

接着考虑这个环内部连边的先后顺序，第一个点有 $(i-1)$ 个选择，第二个点是 $(i-2)$……倒数第二个点就只有 $1$ 种选择了，倒数第一个点也是一样的，也就是 $(i-1)\times(i-2)\times\dots\times2\times1\times1 = (i-1)!$

最后别忘了，环之外的点也是要排列组合的！鉴于他们在环之外，所以可以随便连，总共 $(n-i)$ 个点，每个点有 $(n-1)$ 个连边选择，那就是 $(n-1)^{n-i}$。

把上面的一大长串东西整合起来，就是：

$$ans2 = \dfrac{\sum\limits_{i=2}^nC_n^i\times(i-1)!\times(n-1)^{n-i}}{(n-1)^n}$$

## Code Time

注意到阶乘和 $(n-1)$ 的幂次在第二问的求解中会多次用到，所以可以先预处理一下。在代码中体现为 `mul[]` 和 `n_1[]`。

以及别忘了逆元哦！费马小定理作为前置知识，这里省略讲解。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 10005
using namespace std;

int n,ans1,ans2,mod = 998244353;

int mul[N],n_1[N];
void init()
{
	mul[0] = 1;
	for(int i = 1;i <= n;i++)mul[i] = mul[i-1]*i%mod;
	n_1[0] = 1;
	for(int i = 1;i <= n;i++)n_1[i] = n_1[i-1]*(n-1)%mod;
}

int pow(int a,int b)
{
	int ret = 1;
	while(b)
	{
		if(b&1)ret = ret * a % mod;
		b >>= 1;
		a = a * a % mod;
	}
	return ret;
}

int c(int x,int y)
{
	return mul[x]*pow(mul[y],mod-2)%mod*pow(mul[x-y],mod-2)%mod;
}

signed main()
{
	scanf("%lld",&n);
	init();
	ans1 = n*n%mod*pow(n-1,mod-2)%mod;
	for(int i = 2;i <= n;i++)
		ans2 = (ans2+c(n,i)*mul[i-1]%mod*n_1[n-i]%mod)%mod;
	ans2 = ans2 * pow(n_1[n],mod-2)%mod;
	printf("%lld\n%lld\n",ans1,ans2);
	return 0;
}
```

感谢阅读！QAQ

---

## 作者：似镜流年 (赞：0)

## 第一问

 $\qquad$ 对于第一问，我们只要思考一个点要向外连出一条边的期望次数最后将其乘以  $n$  即可。 有两种思路： 
 
 1、对于期望次数，在第 $i$ 次连到不是自己的概率为 $\frac{n-1}{n^i}$ 。 那么最后我们所求的就是
 
 $ans(single)=\sum_{i=1}^{+\infty}i \times \frac{n-1}{n^i}$，
 
 通过差比数列求和之后可以得出
 
 $ ans(single)\to\frac{n}{n-1} $，
 
 则 $ans=\frac{n^2}{n-1} $。
 
 2、每次选到别的边的概率为 $\frac{n-1}{n} $ ，
 又因为这是一个几何分布，所以期望就是概率的倒数，也就是
 
 $ans(single)=\frac{n}{n-1}$ ，
 
 感性的理解的话就是对于这个模型而言，**抽 $n$ 次里面会有 $n-1$ 次符合要求，那么我们平均只需要抽 $\frac{n}{n-1}$ 次，就会有一次符合要求**。
 
 即 $ans(single)=\frac{n}{n-1}$。
 
 那么最后的答案就是 $ans=\frac{n^2}{n-1}$。
 
## 第二问

 $\qquad$ 对于第二问，由于它是考虑连通块的个数，所以向自己连边的统统不用考虑，简而言之，第二问与第一问无关。
 
 $\qquad$ 这里有一个结论就是在本题条件下，对于每一个确定的图，**图的联通块数与其所含环的数量相等**。那么我们只需要计算出在所有的图中总共有多少环，再除以图的数量，那么就是最后的答案了。
 
$\qquad$ 令环的总数为 $Sum$ ，图的总数为 $Num$ 。

$\qquad$ 则 $Num=(n-1)^n $

$\qquad\quad Sum=\sum_{i=2}^{n} \times C_{n}^{i} \times(i-1)! \times(n-1)^{n-i}$

$\qquad$ 解释一下 $Sum$ 的含义，首先我们先确定环的大小 $i$ ，然后从 $n$ 个点中选择 $i$ 个成环，可以形成环的种类是  $(i-1)!$ （圆排列），其余点随便连边，最后对其求和（每个确定的环在多少图中出现过）。因为 $\Sigma$ (所有的图中有多少环)与 $\Sigma$ (每个确定的环在多少图中出现过)在数值上是等价的，所以可以进行如上计算。

## 最后附上AC代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e4+5,p=998244353;
inline ll read() {
	register ll x=0,f=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
ll n,inv[N],fac[N],ct[N];
ll po(ll x, int y) {
	register int ans=1;
	while(y>0) {
		if(y&1)ans=(ans*x)%p;
		y>>=1;
		x=(x*x)%p;
	}
	return ans;
}
ll C(int x,int y){
	return fac[x]*inv[y]%p*inv[x-y]%p;
}
int main() {
	register ll ans=0;
	n=read(),ct[0]=inv[1]=inv[0]=fac[0]=fac[1]=1;
	ct[1]=n-1;
	for(register int i=2;i<=n;i++){
		ct[i]=ct[i-1]*(n-1)%p;
		fac[i]=fac[i-1]*i%p;
		inv[i]=(p-p/i)*inv[p%i]%p;
	}
	for(register int i=2;i<=n;i++)inv[i]=inv[i-1]*inv[i]%p;
	for(register int i=2;i<=n;i++){
		ans+=(C(n,i)*fac[i-1]%p*ct[n-i]%p);
		ans%=p;
	}
	ans=(ans*po(ct[n],p-2)%p+p)%p;
	printf("%lld\n%lld",n*n%p*po(n-1,p-2)%p,ans);
	return 0;
}
```

---


# 数列前缀和 3

## 题目描述

给定模质数 $p$ 域上的 $k$ 阶非奇异矩阵列 $a$，给定 $q$ 次询问，每次给出 $l, r$，求 $\prod \limits_{i = l}^r a_i$。其中 $p = 1054^2 + 185^2$。容易证明这是一个质数。

注：模 $p$ 域上的非奇异矩阵指：矩阵乘法加法均在模 $p$ 下进行，矩阵（在实数域下）的行列式值对 $p$ 取余不为 $0$。

## 说明/提示

### 样例 1 解释
$a_1 = \begin{pmatrix} 2 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9\end{pmatrix}$，$a_2 = \begin{pmatrix} 2 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9\end{pmatrix}$，$a_3 = \begin{pmatrix} 20 & 20 & 21 \\ 22 & 23 & 24
\\ 25 & 26 & 27\end{pmatrix}$。

$a_1 \times a_2 = \begin{pmatrix} 33 & 38 & 45 \\ 
70 & 81 & 96 \\
109 & 126 &150 \end{pmatrix}$，$a_2 \times a_3 = \begin{pmatrix}159 & 164 & 171 \\ 340 & 351 & 366 \\
541 & 558& 582  \end{pmatrix}$，$a_1 \times a_2 \times a_3 = \begin{pmatrix}2621 &2704& 2820 \\   
5582 & 5759 & 6006    \\
8702 & 8978 & 9363    \end{pmatrix}$。

所有数字的按位异或和为 $14921$。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, q \leq 10^6$，$2 \leq k \leq 3$，$1 \leq l \leq r \leq n$，矩阵元素均为小于 $p$ 的正整数。

## 样例 #1

### 输入

```
3 3 3
2 2 3
4 5 6
7 8 9
2 2 3
4 5 6
7 8 9
20 20 21
22 23 24
25 26 27
1 2
2 3
1 3```

### 输出

```
14921```

# 题解

## 作者：一扶苏一 (赞：17)

### 数列前缀和 3

这是一道洛谷夏令营的作业题，出这道题的目的是强调非交换群的区间和必须注意左右乘的区别。

考虑维护矩阵的前缀积：$s_i$ 表示前 $i$ 个矩阵的乘积。 注意对于一个 $[l, r]$ 的询问，$\prod\limits_{i = l}^r a_i \neq s_r \times s_{l-1}^{-1}$ 。例如：$CD \neq ABCD \times (AB)^{-1}$。

但是注意到 $(AB)^{-1} = B^{-1} A^{-1}$。我们只要将 $(AB)^{-1}$ 左乘上 $ABCD$，就有 $(AB)^{-1} \times ABCD = (B^{-1}(A^{-1}A)B)CD = CD$。

所以我们有 $\prod\limits_{i = l}^r a_i = s_{l - 1}^{-1} \times s_r$。维护前缀积，做一个矩阵求逆即可。时间复杂度 $O((n+q) k^3)$。

矩阵求逆可以用高斯消元法，但因为 $k$ 只有 $2$ 和 $3$，所以也可以手搓一下伴随矩阵，下面介绍一下伴随矩阵法求逆矩阵。

对 $n$ 阶矩阵 $A=(a_{ij})_{n \times n}$，划去第 $i$ 行第 $j$ 列后剩余的 $(n-1)$ 阶行列式的值称为元素 $a_{i,j}$ 的余子式，记为 $M_{i, j}$。记 $A_{i, j}=(-1)^{i+j}M_{i,j}$ 为 $a_{i, j}$ 的代数余子式。

$A$ 的伴随矩阵 $A^*$ 也是一个 $n$ 阶矩阵，其第 $i$ 行第 $j$ 列为 $a_{j, i}$ 的代数余子式 $A_{j, i}$（注意这里下标是反着的，即伴随矩阵的 $i$ 行 $j$ 列是原矩阵 $j$ 行 $i$ 列的代数余子式）。可以证明，$A^{-1} = \frac{A^*}{|A|}$，其中 $|A|$ 是 $A$ 的行列式。

对于二阶矩阵 $A = \begin{pmatrix} a & b \\ c & d\end{pmatrix}$，直接套用上述结论得到 $A^{-1} = \frac{1}{ad - bc}\begin{pmatrix} d & -b \\ -c & a\end{pmatrix}$；对于三阶矩阵，其行列式只有六项，所有的代数余子式均为二阶行列式，都可以轻松算出。

```cpp
#include <array>
#include <iostream>
#include <algorithm>

const int p = 1145141;

typedef long long int ll;

int n, k, q;
std::array<int, p> inv;

struct Matrix {
  ll A[3][3];

  inline Matrix operator*(const Matrix& o) const {
    Matrix ret;
    for (int i = 0; i < k; ++i) {
      for (int j = 0; j < k; ++j) {
        ret.A[i][j] = 0;
        for(int h = 0; h < k; ++h) {
          ret.A[i][j] += A[i][h] * o.A[h][j];
        }
        ret.A[i][j] %= p;
      }
    }
    return ret;
  }

  inline int Det2(ll a, ll b, ll c, ll d) { 
    int ret = (a * d - b * c) % p;
    if (ret < 0) ret += p;
    return ret;
  }

  inline int Det() {
    if (k == 2) { return Det2(A[0][0], A[0][1], A[1][0], A[1][1]); }
    else {
      ll ret = 0;
      (ret += A[0][0] * A[1][1] * A[2][2]) %= p;
      (ret += A[0][1] * A[1][2] * A[2][0]) %= p;
      (ret += A[0][2] * A[1][0] * A[2][1]) %= p;
      (ret -= A[0][2] * A[1][1] * A[2][0]) %= p;
      (ret -= A[0][0] * A[1][2] * A[2][1]) %= p;
      (ret -= A[0][1] * A[1][0] * A[2][2]) %= p;
      (ret += p) %= p;
      return ret;
    }
  }

  inline Matrix operator~() {
    ll d = inv[Det()];
    Matrix ret;
    if (k == 2) {
      ret.A[0][0] = A[1][1] * d % p;
      ret.A[1][0] = (p - A[1][0]) * d % p;
      ret.A[1][1] = A[0][0] * d % p;
      ret.A[0][1] = (p - A[0][1]) * d % p;
    } else {
      ret.A[0][0] = Det2(A[1][1], A[1][2], A[2][1], A[2][2]) * d % p;
      ret.A[1][0] = Det2(A[1][0], A[1][2], A[2][0], A[2][2]) * d % p;
      ret.A[2][0] = Det2(A[1][0], A[1][1], A[2][0], A[2][1]) * d % p;
      ret.A[0][1] = Det2(A[0][1], A[0][2], A[2][1], A[2][2]) * d % p;
      ret.A[1][1] = Det2(A[0][0], A[0][2], A[2][0], A[2][2]) * d % p;
      ret.A[2][1] = Det2(A[0][0], A[0][1], A[2][0], A[2][1]) * d % p;
      ret.A[0][2] = Det2(A[0][1], A[0][2], A[1][1], A[1][2]) * d % p;
      ret.A[1][2] = Det2(A[0][0], A[0][2], A[1][0], A[1][2]) * d % p;
      ret.A[2][2] = Det2(A[0][0], A[0][1], A[1][0], A[1][1]) * d % p;
      for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) if ((i + j) & 1) {
          ret.A[i][j] = p - ret.A[i][j];
        }
      }
    }
    return ret;
  } 
};
Matrix a[p];

void get_inv(const int x) {
  inv[1] = 1;
  for (int i = 2; i < x; ++i) inv[i] = 1ll * (p - p / i) * inv[p % i] % p;
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  get_inv(p);
  std::cin >> n >> k >> q;
  for (int i = 0; i < k; ++i) a[0].A[i][i] = 1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 0; j < k; ++j) {
      for (int h = 0; h < k; ++h) {
        std::cin >> a[i].A[j][h];
      }
    }
    a[i] = a[i - 1] * a[i];
  }
  int ans = 0;
  for (int l, r; q; --q) {
    std::cin >> l >> r;
    Matrix mul = (~a[l - 1]) * a[r];
    for (int i = 0; i < k; ++i) {
      for (int j = 0; j < k; ++j) {
        ans ^= mul.A[i][j];
      }
    }
  }
  std::cout << ans << std::endl;
}
```



---

## 作者：l_615 (赞：5)

# [B3646 数列前缀和 3](https://www.luogu.com.cn/problem/B3646)

## 背景

不会矩阵求逆，遂选择线段树做法，做完发现 TLE 了，经过疯狂的常数优化后，通过了这道题。

## 前置知识

矩阵乘法，线段树。

## 分析

这道题目给了我们一些矩阵，让我们多次求出一个给定区间内所有矩阵的乘积。

这道题当然可以直接用矩阵前缀积来做，但是因为要取模，所以需要求出矩阵逆，这样问题就变得复杂了。怎么办呢？线段树！

我们在线段树的每个叶子节点上面存一个矩阵，其余的存储区间矩阵积。最开始把所有的矩阵存进去，然后每次查询的时候按照题目要求异或即可。

需要注意的是，线段树查询操作累乘答案的时候，答案的初值应为单位元矩阵，否则会影响答案。

还需要一个常数优化的技巧：循环展开。

循环展开，英文中称 （Loop unwinding 或 loop unrolling） ，是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。

循环展开可以省去 for 循环每次的判断与修改操作，对于多次调用循环的程序，把循环展开可以有效卡常。

其余的就是一些常见的小细节了，放代码。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
#define ls (p<<1)
#define rs (p<<1|1)
inline int read()//快读 
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
	 s=(s<<1)+(s<<3)+(c^48);
	return s;
}
int const N=1e6+9;
int const mod=1145141;
int n,k,q,ans;
ll tmp[3][3];
struct matrix{
	ll a[3][3];
	inline void operator *=(const matrix &B)//矩阵乘法 
	{
		memcpy(tmp,a,sizeof a);
		if(k==3)//k=3时的循环展开 
		{
			a[0][0]=(tmp[0][0]*B.a[0][0]+tmp[0][1]*B.a[1][0]+tmp[0][2]*B.a[2][0])%mod;
			a[0][1]=(tmp[0][0]*B.a[0][1]+tmp[0][1]*B.a[1][1]+tmp[0][2]*B.a[2][1])%mod;
			a[0][2]=(tmp[0][0]*B.a[0][2]+tmp[0][1]*B.a[1][2]+tmp[0][2]*B.a[2][2])%mod;
			a[1][0]=(tmp[1][0]*B.a[0][0]+tmp[1][1]*B.a[1][0]+tmp[1][2]*B.a[2][0])%mod;
			a[1][1]=(tmp[1][0]*B.a[0][1]+tmp[1][1]*B.a[1][1]+tmp[1][2]*B.a[2][1])%mod;
			a[1][2]=(tmp[1][0]*B.a[0][2]+tmp[1][1]*B.a[1][2]+tmp[1][2]*B.a[2][2])%mod;
			a[2][0]=(tmp[2][0]*B.a[0][0]+tmp[2][1]*B.a[1][0]+tmp[2][2]*B.a[2][0])%mod;
			a[2][1]=(tmp[2][0]*B.a[0][1]+tmp[2][1]*B.a[1][1]+tmp[2][2]*B.a[2][1])%mod;
			a[2][2]=(tmp[2][0]*B.a[0][2]+tmp[2][1]*B.a[1][2]+tmp[2][2]*B.a[2][2])%mod;
		}else {//k=2 
			a[0][0]=(tmp[0][0]*B.a[0][0]+tmp[0][1]*B.a[1][0])%mod;
			a[0][1]=(tmp[0][0]*B.a[0][1]+tmp[0][1]*B.a[1][1])%mod;
			a[1][0]=(tmp[1][0]*B.a[0][0]+tmp[1][1]*B.a[1][0])%mod;
			a[1][1]=(tmp[1][0]*B.a[0][1]+tmp[1][1]*B.a[1][1])%mod;
		}
	}
	inline int xor_()//矩阵异或 
	{
		int res=0;
		if(k==3)//还是循环展开 
		{
			res^=a[0][0];
			res^=a[0][1];
			res^=a[0][2];
			
			res^=a[1][0];
			res^=a[1][1];
			res^=a[1][2];
			
			res^=a[2][0];
			res^=a[2][1];
			res^=a[2][2];
		}else{
			res^=a[0][0];
			res^=a[0][1];
			
			res^=a[1][0];
			res^=a[1][1];
		}
		return res;
	}
}tr[N<<2],a[N];
void build(int l,int r,int p)//建树 
{
	if(l==r)
	{
		tr[p]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls);
	build(mid+1,r,rs);
	tr[p]=tr[ls];
	tr[p]*=tr[rs];
}
matrix query(int nl,int nr,int l,int r,int p)//查询 
{
	if(nl<=l&&r<=nr)
	 return tr[p];
	int mid=(l+r)>>1;
	matrix res;memset(res.a,0,sizeof(res.a));
	res.a[0][0]=res.a[1][1]=res.a[2][2]=1;
	if(nl<=mid)res*=query(nl,nr,l,mid,ls);
	if(nr>mid)res*=query(nl,nr,mid+1,r,rs);
	return res;
}
signed main()
{
	n=read();k=read();q=read();
	for(int t=1;t<=n;t++)
	{
		if(k==3)
		{
			a[t].a[0][0]=read();
			a[t].a[0][1]=read();
			a[t].a[0][2]=read();
			
			a[t].a[1][0]=read();
			a[t].a[1][1]=read();
			a[t].a[1][2]=read();
			
			a[t].a[2][0]=read();
			a[t].a[2][1]=read();
			a[t].a[2][2]=read();
		}else{
			a[t].a[0][0]=read();
			a[t].a[0][1]=read();
			
			a[t].a[1][0]=read();
			a[t].a[1][1]=read();
		}
	}
	build(1,n,1);
	int x,y;
	matrix z;
	while(q--)
	{
		x=read();y=read();
		z=query(x,y,1,n,1);
		ans^=z.xor_();
	}
	printf("%d",ans);
}
```

### 特别鸣谢

@[lkwbian](https://www.luogu.com.cn/user/544188)

---

## 作者：Flanksy (赞：5)

#### 矩阵求逆、高斯消元

------------

题目要求快速求出一段矩阵的乘积，考虑前缀积。为了将任意一段矩阵乘积提取出来，需要求前缀逆元。

题目中说明了给出的是非奇异矩阵，即矩阵可逆，所以前缀逆元的思路是正确的。

本题中的矩阵只有两种，可以直接手推求逆。笔者感觉有些麻烦，直接写了[矩阵求逆](https://www.luogu.com.cn/problem/P4783)，而矩阵求逆本质上是[高斯消元](https://www.luogu.com.cn/problem/P3389)。

实际使用的是高斯—约旦消元法，感兴趣的读者可以查看高斯消元题解区。

因为 $1145141$ 是质数且给出的矩阵元素都小于它，所以矩阵所有元素的逆元都存在，预处理时递推求出所有小于 $1145141$ 的正整数逆元即可。

**注意矩阵乘法不符合交换律，如果想从前缀积 $ABC$ 中获得 $C$，需要用 $ABC$ 先后左乘 $A^{-1}$ 和 $B^{-1}$，前缀逆元需要以 $C^{-1}B^{-1}A^{-1}$ 形式存下才能得到 $C=(B^{-1}A^{-1})(ABC)$。**

利用结构体和重载运算符可以模块化代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int mod=1145141;
int n,k,q,ans,tmp[4][8],inv[1145141];
struct Matrix{
	int n,a[4][4];//下标从1开始 
	Matrix(int x=0){n=x,memset(a,0,sizeof(a));}
	void reset(){//设置单位矩阵 
		memset(a,0,sizeof(a));//重新初始化 
		for(int i=1;i<=n;i++) a[i][i]=1;
	}
	Matrix operator*(const Matrix &x)const{
		Matrix ret(n);
		for(int i=1;i<=n;i++)
			for(int k=1;k<=n;k++)
				for(int j=1;j<=n;j++)
					ret.a[i][j]=(ret.a[i][j]+1ll*a[i][k]*x.a[k][j])%mod;
		return ret;
	}
	Matrix operator~(){//约旦-高斯消元求逆矩阵 
		Matrix ret(n);
		memset(tmp,0,sizeof(tmp));
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) tmp[i][j]=a[i][j];
		for(int i=1;i<=n;i++) tmp[i][i+n]=1;
		for(int i=1;i<=n;i++){
			for(int j=i;j<=n;j++) if(tmp[j][i]){
				if(i!=j) swap(tmp[i],tmp[j]);
				break;
			}
			int niv=inv[tmp[i][i]];
			for(int j=i;j<=n*2;j++) tmp[i][j]=1ll*tmp[i][j]*niv%mod;
			for(int j=1;j<=n;j++) if(i!=j){
				int mti=tmp[j][i];
				for(int k=i;k<=n*2;k++) tmp[j][k]=(tmp[j][k]-1ll*mti*tmp[i][k]%mod+mod)%mod;
			}
		}
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) ret.a[i][j]=tmp[i][j+n];
		return ret;
	}
	int xorsum(){
		int ret=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++) ret^=a[i][j];
		return ret;
	}
}fac[1000001],mul[1000001];//前缀积 前缀逆元(反向) 
istream &operator>>(istream &in,Matrix &x){
	x.n=k;//初始化矩阵大小 
	for(int i=1;i<=k;i++)
		for(int j=1;j<=k;j++) in>>x.a[i][j];
	return in;
}
ostream &operator<<(ostream &out,const Matrix &x){
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++) out<<x.a[i][j]<<' ';
		out<<'\n';
	}
	return out;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k>>q,inv[1]=1;
	for(int i=2;i<=mod-1;i++) inv[i]=mod-1ll*mod/i*inv[mod%i]%mod;
	fac[0].n=k,fac[0].reset();
	mul[0].n=k,mul[0].reset();//这两个矩阵不是输入的,需要手动设置
	for(int i=1;i<=n;i++){
		cin>>fac[i];//运算顺序不能改变 
		mul[i]=(~fac[i])*mul[i-1];
		fac[i]=fac[i-1]*fac[i];
	}
	for(int i=1;i<=q;i++){
		static Matrix sum;
		static int l,r;
		cin>>l>>r;
		sum=mul[l-1]*fac[r];
		ans^=sum.xorsum();
	}
	cout<<ans<<'\n';
	return 0;
}
```


---


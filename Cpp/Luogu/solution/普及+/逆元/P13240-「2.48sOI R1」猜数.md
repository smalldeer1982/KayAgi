# 「2.48sOI R1」猜数

## 题目描述

Misserina 有一个小于 $n$ 的自然数 $x$，而 lizihan250 并不知道 $x$ 的值。

现在，lizihan250 准备了 $m$ 张卡片，每张卡片上都写有一些互不相同的**小于 $n$ 的**数字。接着，Misserina 会告诉 lizihan250 $x$ 在哪些卡片上出现，而另外的卡片上 $x$ 未出现。lizihan250 需要根据 Misserina 提供的信息，猜出 $x$ 的值。

如果每次都用一套卡片，这个游戏将变得很枯燥。因此，lizihan250 想知道，在保证根据 Misserina 提供的信息一定能猜出唯一确定的 $x$，且 $m$ 最小的情况下，有多少种不同的在卡片上写数字的方式？两种方式相同，当且仅当它们使用的卡片数相同，且交换一种方式中卡片的前后顺序可以得到另外一种方式。答案对 $10^9+7$ 取模。

### 形式化题意

一个集合 $A$ 是“好的集合”，当且仅当集合 $A$ 包含若干个由一些自然数组成的集合，且对于 $\forall 0 \le i < j < n (i,j \in \mathbb{N})$，$A$ 中至少存在一个集合 $B$，使得 $i \in B$ 且 $j \notin B$，或 $i \notin B$ 且 $j \in B$。

令“好的集合”$A$ 的元素数量最小值为 $m$，试求出满足 $|A| = m$ 的“好的集合”$A$ 的数量，并对 $10^9+7$ 取模。

## 说明/提示

### 样例解释

对于样例一，最少应当使用 $1$ 张卡片，有如下两种方案：

1. 在这张卡片上只写下一个 $0$。此时，若 Misserina 回答“在这张卡片上存在 $x$”，则 $x=0$，否则 $x=1$。
2. 在这张卡片上只写下一个 $1$，跟上一种情况相反。

对于样例二，最少应当使用 $3$ 张卡片，一种方案为三张卡片分别包含 $\{1,2,3,7\},\{1,2,5,6\}$ 和 $\{1,3,4,5\}$。

### 数据规模与约束

**本题采用捆绑测试**

对于 $100\%$ 的数据，有 $1 \le n \le 10^6$。

| Subtask 编号 | 分值 | $t$ | $n$ | 特殊性质 |
| :----------: | :--: | :-: | :-: | :------: |
| $0$ | $23$ | $\le 10$ | $\le 8$ | 不符合 |
| $1$ | $12$ | $\le 1000$ | $\le 1000$ | 符合 |
| $2$ | $15$ | $\le 10^5$ | $\le 10^6$ | 符合 |
| $3$ | $28$ | $\le 1000$ | $\le 1000$ | 不符合 |
| $4$ | $22$ | $\le 10^5$ | $\le 10^6$ | 不符合 |

对于符合特殊性质的测试点，保证存在整数 $k$，使得 $2^k = n$。

## 样例 #1

### 输入

```
3
2
8
29```

### 输出

```
2
6720
195120252```

# 题解

## 作者：Kedit2007 (赞：4)

# P13240 猜数 题解

[原题链接](https://www.luogu.com.cn/problem/P13240)

这篇题解采用**非**形式化的题面中的语言。

## 思路

首先我们来判断最少需要多少张卡片，即确定 $m$ 的值。

我们可以先取一个比较小的 $n$ 来模拟一下题意。例如，取 $n = 3$，一种可能的卡牌如下：



|卡片 $1$|卡片 $2$|
|:-:|:-:|
|$1$|$2$|

我们列表记录 $[0, n)$ 中每个整数在各张卡片中的出现情况。比如，数字 $1$ 在卡片 $1$ 中出现了，在卡片 $2$ 中未出现，则记作 ✓✕。这样得到的表格如下：



|$0$|$1$|$2$|
|:-:|:-:|:-:|
|✕✕|✓✕|✕✓|

当表格中每个数字对应的标记两两不同时，Misserina 便能够找到 $x$。（这其实就是形式化题意）

注意到如果将 ✕ 换成 $0$，将 ✓ 换成 $1$，则每个数字都对应一个二进制数。那么问题便转化为：**将 $[0, n)$ 中每一个整数都与一个二进制数对应，且保证对应的二进制数不重复，则其中最大的二进制数至少有多少位。**

显然我们只需要将 $[0, n)$ 分别与其二进制表示对应即可取到最小值，最小值为 $\left\lceil\log_{2}(n)\right\rceil$。

至此，我们得到 $m = \left\lceil\log_{2}(n)\right\rceil$。

---

接下来我们考虑在 $m$ 已经确定的情况下，$[0, n)$ 中的整数各自对应到一个二进制数的方案数。

最多有 $m$ 位的二进制数有 $2^m$ 个，$[0, n)$ 中的整数有 $n$ 个，根据组合数学我们容易知道对应的方案数为 $A_{2^m}^{n}$。

但是考虑下面这两种情况：

|$0$|$1$|$2$|
|:-:|:-:|:-:|
|✕✕|✓✕|✕✓|

|$0$|$1$|$2$|
|:-:|:-:|:-:|
|✕✕|✕✓|✓✕|

这是两种对应方案，但是其对应的卡片分别为：

|卡片 $1$|卡片 $2$|
|:-:|:-:|
|$1$|$2$|

|卡片 $1$|卡片 $2$|
|:-:|:-:|
|$2$|$1$|

我们可以通过交换两张卡片的顺序使得二者相等，所以还需要进行去重。

当卡片有 $m$ 张时，这 $m$ 张卡片共有 $m!$ 种排列方式，其中 $m!$ 表示 $m$ 的阶乘。所以我们还需要除以 $m!$ 才能得到正确的答案。

综上所述，我们可以得到本题的公式：

$$
\frac{A_{2^m}^{n}}{m!} = \frac{(2^m)!}{(2^m - n)!m!}
$$

最后，通过线性递推预处理阶乘，用乘法逆元处理除法即可。

## 部分代码参考

```cpp
// 原先的代码中采用了 #define int long long
// 注意防止整数溢出

int qpow(int x, int p) {
	// 快速幂实现
}

int inv(int x) {
	return qpow(x, MOD - 2);
}

void solve() {
	int n; std::cin >> n;
	int m = ceil(std::log2(n));
	int cases = 1ll << m;
	
	// fact 是预处理好的阶乘数组
	int denom = fact[m] * fact[cases - n] % MOD;
	int numer = fact[cases];
	int ans = numer * inv(denom) % MOD;
	
	std::cout << ans << '\n';
}
```

---

## 作者：Redshift_Shine (赞：3)

一道简单有趣的思维题。

首先思考一个问题，如何快速确定 $m$。注意到题目本质上在问**能够使每个元素对应的 Misserina 回答互不相同**的最小 $m$ 值。

对于任意一个集合，一个元素与它的关系只有两种：$\in$ 或 $\notin$。这显然是二进制表达，所以 $m$ 个集合最多可以容纳 $2^m$ 个不同的包含状态集合。

所以，显然 $m=\lceil \log_2 n\rceil$。

在 $2^m$ 个可选状态中选出 $n$ 个，而这 $n$ 个状态可以任意互换，所以选取方案有 $\binom{2^m}{n}\times n!$ 个。但是，如果你按照这个思路实现代码，你就会发现答案错了。

怎么回事呢？实际上，以下两种情况等价：

$$
\begin{matrix}
101\\
010\\
110\\
\end{matrix}=
\begin{matrix}
110\\
001\\
101
\end{matrix}
$$

为什么呢？因为，集合中的集合也是无序的。将存在性矩阵中的某一行或某一列互换实际上是等价于原矩阵的。

所以，上述答案还需要除以比特排列数，也就是 $m!$。

最终答案为

$$
\frac{\binom{2^m}{n}\times n!}{m!}
$$

```c++
// #define Redshift_Debug
#ifdef Redshift_Debug
#define debug(...) fprintf(stderr, __VA_ARGS__)
#include <chrono>
#else
#define debug(...)
#endif
#include <cstdio>
#include <iostream>

using namespace std;
const int N = 2e6 + 10, mod = 1e9 + 7;
int n, bt[N], inv[N], lg2[N];
inline int fsp(int x, int y)
{
	int res = 1;
	while (y)
	{
		if (y & 1)
			res = 1ll * res * x % mod;
		x = 1ll * x * x % mod;
		y >>= 1;
	}
	return res;
}
void init_global()
{
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(0);
	bt[1] = 1;
	// lg2[1] = 0;
	for (int i = 2; i < N; i++)
	{
		bt[i] = 1ll * bt[i - 1] * i % mod;
		lg2[i] = lg2[i >> 1] + 1;
	}
	inv[N - 1] = fsp(bt[N - 1], mod - 2);
	for (int i = N - 1; i; i--)
	{
		if (i != (i & -i))
			lg2[i]++;
		inv[i - 1] = 1ll * inv[i] * i % mod;
	}
}
inline int C(int x, int y)
{
	return 1ll * bt[x] * inv[y] % mod * inv[x - y] % mod;
}
void init_local()
{
	cin >> n;
}
void run()
{
	cout << 1ll * C(1 << lg2[n], n) * bt[n] % mod * inv[lg2[n]] % mod << '\n';
}
int main()
{
#ifdef Redshift_Debug
	auto st = chrono::high_resolution_clock::now();
#endif
	int T = 1;
	init_global();
	cin >> T;
	while (T--)
	{
		init_local();
		run();
	}
#ifdef Redshift_Debug
	auto ed = chrono::high_resolution_clock::now();
	fprintf(stderr, "%.9lf\n", (ed - st).count() / 1e9);
#endif
}
```

---

## 作者：Forgive_Me (赞：2)

似乎是一个著名的魔术？

---

题意略。

先考虑“唯一确定性”。  
两个数字可以被“区分” 当且仅当数字的“所在牌” 序号集合不同，也就是说，对于一个存在的“所在牌” 集合，有唯一的数字与其对应。  
这个在与不在的信息很容易想到状压，用每个二进制数刻画一个存在的状态。  
那么合法牌数 $m$ 很直白了：$2^m\ge n$。  
$m$ 的最小值即为：$\lceil\log_2{n}\rceil$


---


> 对于符合特殊性质的测试点，保证存在整数 $k$，使得 $2^k = n$。

看到特殊性质，觉得想的很对啊。如果满足特殊性质，那就是 $n$ 个数的全排列数啊。

嗯？$n=8$ 时为何答案 $6720$ 而不是 $8! = 40320$。  
注意到，$6720 \times 6 = 40320$。  
再读题发现，卡片顺序是有影响的。  
那么，类似于组合数的，得到特殊性质答案 $\large \frac{n!}{\log_2{n}!}$。


---


考虑没有特殊性质，相当于在 $\frac1{m!}$ 的基础上要在那 $2^m$ 个二进制数先选 $n$ 个（有序），这个方案数是 $A(2^m,n) = \frac{2^m!}{(2^m-n)!}$。

最后答案就是 $\large\frac{2^m!}{(2^m-n)!m!}$，并且这个东西在特殊性质也是对的，不用分讨。

---

## 作者：Amoribus (赞：1)

提供一个不那么严谨的证明。

首先我们考虑求出 $m$ 的值。

我们假设现在有了 $3$ 张卡牌。

我们设有一个数 $x$，那么这个数在卡牌中出现的情况有以下 $8$ 种可能：

- {有，有，有}。
- {有，有，无}。
- {有，无，有}。
- {有，无，无}。
- {无，有，有}。
- {无，有，无}。
- {无，无，有}。
- {无，无，无}。

这个结论可做推广，若我们有 $m$ 张卡牌，则可以表示 $2^m$ 个状态，于是卡牌的数量 $m$ 就是使得 $2^m\geq n$ 的最小正整数。

设 $2^m=M$，有 $n$ 个数字，答案就是 $M$ 种状态和 $n$ 个数字配对的方案数。这个值为 $M\times(M-1)\times\cdots\times (M-n+1)=\dfrac{M!}{(M-n)!}$。

要注意，最后的答案还需除以 $m!$，因为题干中的集合是无序的，最后还需除以排列数。

因此，答案为 $\dfrac{(2^m)!}{(2^m-n)!m!}$，预处理阶乘逆元即可达到 $O(n+T)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e6+7;
const int mod=1e9+7;
int T,n,ans=1; 
int fac[N+10],inv[N+10];
int fastmi(int a,int b,int p){
	if(b==0) return 1;
	if(b==1) return a;
	int k=fastmi(a,b/2,p)%p;
	if(b%2==1) return k*k%p*a%p;
	else return k*k%p;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	fac[0]=1;
	for(int i=1;i<=N;i++) fac[i]=fac[i-1]%mod*i%mod;
	inv[N]=fastmi(fac[N],mod-2,mod)%mod;
	//cou<<inv[N]<<endl;
	for(int i=N-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	cin>>T;
	while(T--){
		ans=1;
		cin>>n;
		if(n==1){
			cout<<1<<"\n";
			continue;
		}
		int lim=ceil(log2(n));
		int up=(1<<lim);
		ans=ans*fac[up]%mod;
		ans=ans*inv[up-n]%mod;
		ans=ans*inv[lim]%mod;
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：ZZQF5677 (赞：1)

考虑每个数字在每张卡片出不出现用 $0$/$1$ 表示， 并且假设要状态压缩， 那么要求每个数字的状态必须两两不同，那么就相当于求得 $m = \lceil\operatorname{log}n\rceil$

那么每种数字有 $2^m$ 种出现方式，选 $n$ 种组成排列对应到每个数字上，则有：

$ans=\dfrac{A_{2^m}^n}{m!}$ (除以 $m!$ 是注意到与卡片顺序无关) 

由于要取模，又要除法，就有费马小定理：

$a^{p - 2}\times a\equiv1 \pmod{p}$（已知 $p=10^9+7$ 是质数那么式子成立）

再用快速幂跑出 $a$ 的逆元即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long MOD = 1e9 + 7;

long long t, n, m, fact__[5058576];
long long q_pow(long long a, long long b) {
	long long ans = 1LL % MOD;
	while (b) {
		if (b & 1LL) {
			ans = ((ans % MOD) * (a % MOD)) % MOD;
		}
		a = ((a % MOD) * (a % MOD)) % MOD;
		b >>= 1LL;
	}
	return ans;
}

long long q_pow_no_mod(long long a, long long b) {
	long long ans = 1;
	while (b) {
		if (b & 1) {
			ans = ((ans) * (a));
		}
		a = ((a) * (a));
		b >>= 1;
	}
	return ans;
}

long long A(int x, int y) {
  return ((fact__[y] % MOD) * q_pow(fact__[y - x], MOD - 2)) % MOD;
}

int main() {
	cin >> t;
  fact__[0] = 1;
	fact__[1] = 1;
	for (int i = 2; i <= 5058576; i++) {
		fact__[i] = ((fact__[i - 1] % MOD) * (i % MOD)) % MOD;
	}
	while (t--) {
		cin >> n;
		m = (long long)ceil(log(n) / log(2));
		long long AAA = (A(n, (long long)(q_pow_no_mod(2, m))) % MOD);
		cout << (AAA * q_pow(fact__[m], MOD - 2)) % MOD << "\n";
	}
	return 0;
}
/*
3
2
8
1000000
*/
```

---

## 作者：lizihan250 (赞：1)

先考虑至少需要几张卡片。

每个数依次在每张卡片上可以获得两种反馈：存在与不存在。因此，对于一个数 $x$，构造数列 $\{a_n\}$ 若它在卡片 $i$ 上出现，我们将 $a_i$ 记为 $1$，否则记为 $0$，则数列长度为 $m$ 的情况下，总共有 $2^m$ 种不同的数列。由于数列 $\{a_n\}$ 是我们确定数字的唯一方式，故由数列 $\{a_n\}$ 到小于 $n$ 的自然数一定会建立一个满射。故 $m = \left\lceil\log_2 n\right\rceil$。

然后考虑方案数。若交换卡片次序视为两种不同方案的话，那么可以让 $0$ 至 $n - 1$ 中的每个数对应任意一个上文提到的数列 ${a_n}$，互不重复。这样有 $\frac{2^m!}{(2^m-n)!}$ 种方案。

然而，交换卡片会被视为两种相同方案。注意到上文描述的任意一种映射都可以通过交换卡片扩展成为 $m!$ 种不同的映射，故答案应除以 $m!$，故最终的答案应为 $\frac{2^m!}{(2^m-n)! \cdot m!}$。

---

## 作者：swate114514 (赞：1)

> 比 T1 简单，我能说啥……

当最小卡片数量 $m$ 时，每张卡片可以看作一个二进制位，表示某个数字是否出现在该卡片上。为了区分所有 $n$ 个数，需要为每个数分配一个唯一的 $m$ 位二进制编码。因此，最小的 $m$ 满足 $2^m \geq n$，即 $m = \lceil \log_2 n \rceil$。

我们需要从 $2^m$ 个可能的二进制串中选择 $n$ 个不同的串，分配给 $n$ 个数。

由于卡片的顺序不重要，交换卡片顺序视为同一种配置方式。

因此，从 $2^m$ 个串中选 $n$ 个需要 $\binom{2^m}{n}$，将 $n$ 个串分配给 $n$ 个数要 $n!$，除去卡片顺序的影响 $m!$，总的配置方式即为：

$$\frac{\binom{2^m}{n} \times n!}{m!}$$

预处理逆元再算组合数即可。

### Code
```cpp
#include <bits/stdc++.h>
#define qwq(i,a,b) for(int i=(a);i<=(b);++i)
#define qaq(i,a,b) for(int i=(a);i>=(b);--i)

using namespace std;

typedef long long ll;

const int M = 1e9 + 7;
const int K = 20;

vector<int> fc, iv;

int pw(int a, int b) {
	int r = 1;
	while (b) {
		if (b & 1)r = 1ll * r * a % M;
		a = 1ll * a*a % M;
		b >>= 1;
	}
	return r;
}

void pc(int mx) {
	fc.resize(mx + 1);
	iv.resize(mx + 1);
	fc[0] = 1;
	qwq(i, 1, mx)
        fc[i] = 1ll * fc[i - 1] * i % M;
	iv[mx] = pw(fc[mx], M - 2);
	qaq(i, mx - 1, 0)
        iv[i] = 1ll * iv[i + 1] * (i + 1) % M;
}

int cb(int a, int b) {
	if (a < 0 || b < 0 || a < b)return 0;
	return 1ll * fc[a] * iv[b] % M*iv[a - b] % M;
}

int sol(int n) {
	if (n == 1)return 1;
	int m = 0;
	while ((1 << m) < n)++m;
	int t = 1 << m;
	int c = cb(t, n);
	int r = 1ll * c*fc[n] % M*iv[m] % M;
	return r;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);

	int t;
	cin >> t;
	vector<int> q(t);
	int mx = 0;
	qwq(i, 0, t - 1) {
		cin >> q[i];
		mx = max(mx, q[i]);
	}

	int mm = 0;
	while ((1 << mm) < mx)
        ++mm;
    
	int tm = 1 << mm;
	pc(tm);

	for (int x : q)
        cout << sol(x) << '\n';
}
```

---

## 作者：sbno333 (赞：0)

我们先考虑 $2$ 的幂。

每个集合能够为我们提供信息使得需要处理的量减半（上取整）。

容易得出我们需要 $\lceil\log_2 n\rceil$ 个集合才能确定 $n$。

对于 $n=2^k$，每个集合都需要把信息给满，大小是 $2^{k-1}$，并且元素不是随便选。

我们考虑在看过每一个集合的时候，我们所有可能的答案集合（初始时为 $0\sim n-1$）根据里头的答案都根据是否在这个集合被分成了两种可能，从而分成原来两倍个数的答案集合，而我们此时知道答案在其中一个答案集合中。

在 $n=2^k$ 中，我们每次需要把每个答案集合恰好一半的元素放入集合，因为只要一个答案集合被分出了含有比 $2^{k-1}$ 多的元素，接下来的询问集合将无法将答案集合每个元素区分。

对于第一个集合，我们有贡献 $n\choose \frac{n}{2}$。

接下来有两个答案集合，贡献有 ${\frac{n}{2}\choose\frac{n}{4}}^2$。

接下来有四个答案集合，贡献有 ${\frac{n}{4}\choose\frac{n}{8}}^4$。

以此类推，最后答案乘起来，除以集合个数的阶乘即可。

接下来考虑拓展。

我们想象一个树，最开始只有一个节点，表示 $0\sim n-1$ 这个集合。

接下来每次询问集合，都会让当前每一个叶子或者没有连边的点向左和向右各生成两个代表互补的子集的节点作为儿子。

到最后一层，我们最后的叶子必然是空集或者恰好有一个元素的集合。

如果我们知道这些叶子，可以反推回整颗树。

叶子之间已经有区别了。

所以最后如果有 $2^k$ 个叶子，我们答案就是 ${2^k\choose n}\times n!\div k!$。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
int dp[29][2000009];
const int mod=1000000007;
int ksm(int a,int b){
	int ans;
	ans=1;
	while(b){
		if(b&1){
			ans*=a;
			ans%=mod;
		}
		a*=a;
		a%=mod;
		b>>=1;
	}
	return ans;
}
int jc[2000009];
int c(int n,int m){
	return jc[n]*ksm(jc[m]*jc[n-m]%mod,mod-2)%mod;
} 
signed main(){
	jc[0]=1;
	for(int i=1;i<=2000000;i++){
		jc[i]=jc[i-1]*i%mod;
	}
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		int g;
		if((1ll<<__lg(n))==n){
			g=__lg(n);
		}else{
			g=__lg(n)+1;
		}
		cout<<c(1ll<<g,n)*jc[n]%mod*ksm(jc[g],mod-2)%mod<<endl;
	}
	return 0;
}
```

---

## 作者：云裳 (赞：0)

根据形式化题意，将 $n$ 个数抽象为 $n$ 个长度为 $m$ 的二进制串，这 $n$ 个数能产生贡献当且仅当这 $n$ 个二进制串两两不同，因此 $2^m\ge n$，即 $m\ge\left \lceil \log_{2}{n}  \right \rceil $。

考虑组合数。

- 第一步是从 $2^m$ 中不同的二进制串中选 $n$ 个不同的二进制串，即为 $\binom{2^{m}}{n}$。
- 第二步是将这些二进制串分配给 $n$ 个二进制串，即为 $n!$。注意这里对顺序有要求。比如 $1$ 在第一个集合中出现和 $2$ 在第一个集合中出现是不同的。
- 由于集合 $A$ 中的元素没有顺序，因此要将答案最后除以 $m!$。

根据乘法原理，答案即为 $\frac{\binom{2^{m}}{n}\cdot n!}{m!}$。将组合数展开即为 $\frac{2^m!}{m!\cdot(2^m-n)!}$。

预处理阶乘和阶乘的逆元即可。注意数组要开大一点，因为 $2^m$ 可能大于 $n$。
```cpp
// Kawaii [] is very cute!
#include <bits/stdc++.h>
#define up(i, l, r) for (int i = l, END##i = r; i <= END##i; i++)
#define dn(i, l, r) for (int i = l, END##i = r; i >= END##i; i--)
#define int i64
typedef long long i64;
typedef unsigned long long u64;
typedef double db;
using namespace std;
const int INF = 0x3f3f3f3f,N=5e6+7,p=1e9+7;
int jc[N],inv[N];
int qpow(int base,int k) {
	int f=1;
	while(k) {
		if(k&1) (f*=base)%=p;
		(base*=base)%=p,k>>=1;
	}
	return f;
}
void init(int n=N-5) {
	jc[0]=1;
	up(i,1,n) jc[i]=jc[i-1]*i%p;
	inv[n]=qpow(jc[n],p-2);
	dn(i,n-1,0) inv[i]=inv[i+1]*(i+1)%p;
}
namespace sol {
	i64 read() {
		i64 f = 0, x = 0;
		char c = getchar();
		while (c < '0' || c > '9')
			f |= c == '-', c = getchar();
		while (c >= '0' && c <= '9')
			x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
		return f ? -x : x;
	}
	void write(i64 x) {
		if (x < 0)
			putchar('-'), x = -x;
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
	void Dianaqaq() {
		int n=read();
		int m=ceil(1.0*log2(n));
		int ans=jc[1ll<<m]%p*inv[m]%p;
		(ans*=inv[(1ll<<m)-n])%=p;
		write(ans),puts("");
	}
} // namespace sol
using namespace sol;
signed main() {
	init();
	int T=read();
	while(T--)Dianaqaq();
	return 0;
}
```

---

## 作者：TH_HaZel (赞：0)

数学题。

## 思路

设最小的卡牌数为 $m$。

题目要求可以猜出唯一的 $x$，所以我们可以考虑[**二进制枚举集合**](https://oi-wiki.org/math/binary-set/)。

题目中描述：

>一个集合 $A$ 是“好的集合”，当且仅当集合 $A$ 包含若干个由一些自然数组成的集合，且对于 $\forall 0 \le i < j < n (i,j \in \mathbb{N})$，$A$ 中至少存在一个集合 $B$，使得 $i \in B$ 且 $j \notin B$，或 $i \notin B$ 且 $j \in B$。

因为对于每一个数字，在每张卡牌上只有写与不写两种情况，所以我们将每一张卡牌设为一个二进制数，对于每个数字 $i$，都有一个状态 $state_i$，表示当前的数字写在了哪些卡牌上，所以题目可以转换为：

>一个集合 $A$ 是“好的集合”，当且仅当集合 $A$ 包含若干个由一些自然数组成的集合，且对于 $\forall 0 \le i < j < n (i,j \in \mathbb{N})$，都有 $state_i \ne state_j$。

由此，我们可以将每个状态对应到一个二进制数上，且**每个数的状态是唯一的**，所以状态数 $p\ge n$。又由数学知识得 $p=2^m$，所以 $m$ 是满足 $2^m\ge n$ 的最小整数，即 $m=\left \lceil \log_{2}{n} \right \rceil $。

因为每个数需要唯一对应到 $2^m$ 个状态上，相当于在 $2^m$ 个状态中选择 $n$ 个，又因为每个数的顺序不做要求，所以**卡牌顺序固定时**方案数为 $C_{2^m}^n\times A_n^n$。

但是，题目中说明卡牌顺序互换只算一种方案！也就是说，同一种情况我们重复计算了 $A_m^m$ 次，也就是说，最后的答案要除以 $A_m^m$。

答案为：

$$
\begin{align}
\frac{C_{2^m}^n\times A_n^n}{A_m^m}&=\frac{\frac{2^m!}{n!\times(2^m-n)!}\times n!}{m!}\\
&=\frac{2^m!}{m!\times(2^m-n)!}
\end{align}
$$

由于数据范围过大，所以要预处理阶乘，同时涉及到分数取模，请自行搜索相关知识（^v^）。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
constexpr int mod=1e9+7;
int jc[2000010];//开大一点，开1e6会RE
int qpow(int x,int y,int p)//快速幂，求逆元用的
{
	int ans=1;
	while(y)
	{
		if(y&1)ans=ans*x%p;
		y>>=1;
		x=x*x%p;
	}
	return ans;
}
signed main()
{
	int t;
	cin>>t;
	jc[1]=1;
	jc[0]=1;//注意：0!=1
	for(int i=2;i<=2e6;i++)jc[i]=jc[i-1]*i%mod;//预处理阶乘
	while(t--)
	{
		int n;
		cin>>n;
		int m=ceil(log2(n));
		int ans=jc[1<<m]*qpow(jc[m],mod-2,mod)%mod*qpow(jc[(1<<m)-n],mod-2,mod)%mod;//费马小定理求逆元
		cout<<ans<<endl;
	}
}
```

建议学习：状压 dp。

---


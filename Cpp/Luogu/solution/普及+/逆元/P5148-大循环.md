# 大循环

## 题目描述

hke 有一天学会了循环语句，感到很神奇。回到家，他用 C++ 写下这段代码：

```cpp
void work()
{
  ans=0;
    for(a[1]=1;a[1]<=n;++a[1])
      for(a[2]=1;a[2]<a[1];++a[2])
        for(a[3]=1;a[3]<a[2];++a[3])
          //......
            for(a[k]=1;a[k]<a[k-1];++a[k])
              ans+=f(q);
  cout<<ans;
}
```
其中，$q$ 是给定的常数，$f(x)$ 是一个关于 $x$ 的 $m$ 次多项式，它的表达式为：

$$f(x) = a _ m x ^ m + a _ {m - 1} x ^ {m - 1} + \cdots + a _ 1 x + a _ 0$$

hke 迫不及待地开始运行这个程序，但程序运行得实在太慢了。于是他找到了你，想知道这段程序输出的结果是？答案可能很大，你只需输出其对 $10^9+7$ 取模的结果即可。假设运算过程中不存在溢出。


## 说明/提示

对于 $10\%$ 的数据有 $n \le 10$；

对于 $30\%$ 的数据有 $n \le 1000,m \le 1000$；

对于 $100\%$ 的数据保证 $n \le 500000, m \le 500000, 1≤k≤n,q≤10^{18},1≤a _ i≤10000$。


## 样例 #1

### 输入

```
10 3 3 2
1 3 3 1```

### 输出

```
3240```

# 题解

## 作者：ikka (赞：7)

题解前扯一句，这个题真不应该是紫题。

---

将题目中的代码翻译为公式即求
$$\sum_{1 \leq a_1 < a_2 < \dots < a_k \leq n}f(q)$$
其中
$$f(x)=\sum_{i=0}^{m}a_ix^i$$
可以看出$f(q)$与和式中的变量没有关系，所以直接提出，变为
$$f(q)\sum_{1 \leq a_1 < a_2 < \dots < a_k \leq n}1$$
考虑后面和式的组合意义，即在n个数无序选出k个数的方案数，即$\binom{n}{k}$。

所以答案为$\binom{n}{k}f(q)$。

组合数可以暴力算，$f(q)$直接套一遍秦九韶算法就算出来了。


``` cpp
#include <cstdio>
const int maxn = 500010;
const int mod = 1000000007;

int n, m, k;
long long q;
int a[maxn];

int inline pow(int a, int b) {
  int ans = 1;
  while (b) {
    if (b & 1) ans = 1ll * ans * a % mod;
    a = 1ll * a * a % mod;
    b >>= 1;
  }
  return ans;
}

int f(int x) {
  int ans = a[m] % mod;
  for (int i = m; i; --i) ans = (1ll * ans * x % mod + a[i - 1]) % mod;
  return ans;
}

int C(int n, int k) {
  if (k << 1 > n) k = n - k;
  int ans = 1, buff = 1;
  for (int i = n - k + 1; i <= n; ++i) ans = 1ll * ans * i % mod;
  for (int i = 2; i <= k; ++i) buff = 1ll * buff * i % mod;
  return 1ll * pow(buff, mod - 2) * ans % mod;
}

int main() {
  scanf("%d%d%d%lld", &n, &m, &k, &q);
  for (int i = 0; i <= m; ++i) scanf("%d", a + i);
  printf("%lld\n", 1ll * f(q % mod) * C(n, k) % mod);
  return 0;
}
```

---

## 作者：龙·海流 (赞：6)

观察代码部分可以发现ans=循环次数*f(q)

### 处理循环次数：
1.显然的一点是a[1]>a[2]>...>a[k],即从a[1]到a[k]严格单减，因为a[k]最小为1，所以a[1]最小为k，最大为n；

2.开始递推：

先举个例子，设n=7，k=4；

a1=4时，a2~a4分别为3,2,1；

a1=5时，a1~a4可能为,{4,3,2}，{4,3,1}，{4,2,1}，{3,2,1}，即从4,3,2,1中扔掉一个数，剩下的三个数即为a2~a4，方案数为C(4,1);

a1=6时，从5,4,3,2,1中选出两个数扔掉，剩下三个数即为a2~a4，方案数为C(5,2);

a1=7时，从6,5,4,3,2,1中选出三个数扔掉，剩下三个数即为a2~a4，方案数为C(6,3);

于是a1=4时的方案数可看做C(3,0);

所以方案数=C(3,0)+C(4,1)+C(5,2)+C(6,3)=C(7,4);

（以下是计算过程：

ans=C(3,0)+C(4,1)+C(5,2)+C(6,3)=C(4,0)+C(4,1)+C(5,2)+C(6,3)=C(5,1)+C(5,2)+C(6,3)=C(6,2)+C(6,3)=C(7,3)=C(7,4)

应用性质：C(n+1,m)=C(n,m)+C(n,m-1);)

所以对于给定的n与k：
a1=k时，方案数C(k-1,0);

a1=k+1时，方案数C(k,1);

a1=k+2时，方案数C(k+1,2);

a1=k+3时，方案数C(k+2,3);

......

a1=n时，方案数为C(n-1,n-k);

(为啥这里是C（n-1，n-k），一共有n-1个元素，需要留下k-1个，所以需要扔掉（n-1）-（k-1）个元素，即扔掉n-k个元素）

所以方案总数=C(k-1,0)+C(k,1)+C(k+1,2)+...+C(n-1,n-k)=C(n,n-k)=C(n,k)；

C(n,k)用阶乘求即可，卢卡斯在这里基本没用，因为n和k都小于1e9+7；当然，不要忘了求逆元；

### 然后就剩下f（q）了

暴力算乘方即使是快速幂都会很慢，但是这个式子可以通过提公因式转化一下；

还是先举个栗子：

	f(q)=a3·x^3+a2·x^2+a1·x+a0
        =(a3·x^2+a2·x+a1)·x+a0
        =[(a3·x+a2)·x+a1]·x+a0
其实这个就是著名的秦九韶（shao2）算法，代码实现在下文中会给出；

最后附上自己的代码
```cpp
	#include<iostream>
	#include<cstdio>
	#define ll long long
	using namespace std;
	const long long mod=1000000007;
	long long n,m,k,q,a[500010],ans;
	ll ksm(ll a,ll b)
	{	
    	    ll ret=1;
            while(b)
	    {
	        if(b&1) ret=ret*a%mod;
	        b>>=1;
	        a=a*a%mod;
	    }
	    return ret;
	}
	ll C()
	{
	    ll a=1,b=1;
	    for(ll i=n;i>=n-k+1;--i) a=a*i%mod;
	    for(ll i=2;i<=k;++i) b=b*i%mod;
	    return a*ksm(b,mod-2)%mod;
            //根据费马小定理，若a与p互质，那么a%p的逆元就是a^p-2，所以用快速幂求a%p的逆元
	}
	int main()
	{
	    scanf("%lld%lld%lld%lld",&n,&m,&k,&q);
	    q=q%mod;//不加这一句会少20分，很玄学
	    for(int i=0;i<=m;++i) scanf("%lld",&a[i]);
	    //秦九韶算法
	    for(ll i=m;i>0;--i) ans=(ans+a[i])*q%mod;
	    ans=(ans+a[0])%mod;//别忘了加上a0
	    ans=ans*C()%mod;
	    printf("%lld",ans);
	    return 0;
	}
```

组合数见高中数学选修3-3

秦九韶算法见高中数学必修3

---

## 作者：Ginger_he (赞：3)

# 题解
这道题的难点在于计算循环执行的次数，等价于求序列 $\{a_k\}$ 的的合法排列数量。不难发现，$a_i$ 严格单调递增，且值域在 $[1,n]$ 中，所以我们在 $1,2,\cdots,n$ 中随便选 $k$ 个数都对应一种合法方案，因此循环一共执行了 $\mathrm{C_n^k}$ 次。对于多项式 $f(x)$ 我们只需用模拟+快速幂即可。

## 注意

$q$ 的值过大，在计算多项式的值时可能爆 long long，因此在读入时先对 $10^9+7$ 取模即可。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 500005
const ll p=1e9+7;
ll n,m,k,q,x,u,r=1;
ll quickpow(ll a,ll b)
{
	ll res=1;
	while(b)
	{
		if(b&1)
			res=res*a%p;
		b>>=1;
		a=a*a%p;
	}
	return res;
}
ll c(ll n,ll m)
{
	ll x=1,y=1;
	for(ll i=n-m+1,j=1;i<=n,j<=m;i++,j++)
		x=x*i%p,y=y*j%p;
	return x*quickpow(y,p-2)%p;
}
int main()
{
	scanf("%lld%lld%lld%lld",&n,&m,&k,&q);
	q%=p;
	for(ll i=0;i<=m;i++)
	{
		scanf("%lld",&x);
		u=(u+x%p*r%p)%p;
		r=r*q%p;
	}
	printf("%lld\n",u*c(n,k)%p);
	return 0;
}
```

---

## 作者：alphayangyang (赞：2)

注意到 $q$ 为常量，函数 $f$ 的值为常量。故答案为 $\mathrm{AddCount} \times f(q)$。其中，$\mathrm{AddCount}$ 的值为满足条件的序列 $a$ 的个数。

注意到序列 $a$（此处指循环变量数组） 严格单调递增，且 $a_i \in [1, n] (i \in [1, k])$。因此考虑从 $[1, n]$ 中选择 $k$ 个数构成序列 $a$，由于 $a$ 有序，无需考虑顺序，共有 $n \choose k$ 种选择，故 $\mathrm{AddCount} = {n \choose k}$ 。

### 求 $n \choose k$
$n, k$较小，考虑直接求值。由于需要取模，在作除法时改为乘以其逆元即可。$M = 10^9 + 7$ 为质数，因此 $x^{-1} \equiv x^{M}   (\bmod \ M )$。

### 求 $f(q)$
$m \leq 10^5$，考虑迭代 $P = q^i$，计算每一项 $a_i \cdot P$ 的值累加即可。

### 注意事项
1. $q \leq 10^{18}$，读入后要先取模。
2. 注意 64 位整数的使用。

### 代码（码风不喜轻喷）
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e5 + 5, MOD = 1e9 + 7;
typedef long long LL;
LL n, m, k, q, a[N];

LL qpow(LL a, int b) { // 逆元用
  LL ret = 1;
  while (b) {
    if (b & 1) ret = ret * a % MOD;
    a = a * a % MOD, b >>= 1;
  }
  return ret;
}

LL C(int a, int b) { // 组合数
  LL ret = 1;
  for (int i = a - b + 1, j = 1; i <= a; ++i, ++j) {
    ret = ret * i % MOD * qpow(j, MOD - 2) % MOD;
  }
  return ret;
}

LL f(LL x) { // 函数求值
  LL ret = 0, P = 1;
  for (int i = 0; i <= m; ++i) {
    ret = (ret + a[i] * P % MOD) % MOD;
    P = P * x % MOD;
  }
  return ret;
}

int main() {
  cin >> n >> m >> k >> q, q %= MOD;
  for (int i = 0; i <= m; ++i) cin >> a[i];
  cout << C(n, k) * f(q) % MOD << endl;
  return 0;
}
```

---

## 作者：K2sen (赞：2)

### 思路
很明显，我们求 f(q) 可以 $ O(n) $ 求，关键在于前边的系数。

 f(q) 前边的系数，题目中提取出来无非就是这么一个东西。

$$\sum_{a_1 = 1}^{n}\sum_{a_2 = 1}^{a_1 - 1}\sum_{a_3 = 1}^{a_2-1} \cdots \sum_{a_k = 1}^{a_{k-1}- 1} 1$$

我们可以从 1 开始推，多推几个就能看出来了。

* 当 k=1 时，令 $ i=a_1 $ 。

$ \displaystyle  \sum_{i = 1}^{n} 1 = n $

* 当 k=2 时，令 $ i=a_1,j=a_2 $ 。

$\displaystyle \sum_{i = 1}^{n}\sum_{j = 1}^{i - 1}1 =  \sum_{i = 1}^{n}(i-1) = \sum_{i = 2}^{n}(i-1) = \frac {n \times (n-1)}{2}$

* 当 k=3 时，令 $ i=a_1,j=a_2,k=a_3 $ 。

$\displaystyle \sum_{i = 1}^{n}\sum_{j = 1}^{i - 1}\sum_{k=1}^{j-1}1=\sum_{i = 1}^{n}\sum_{j = 1}^{i - 1}(j-1) = \sum_{i = 1}^{n}\frac{(i-2) \times (i-1)}{6}=\frac{n \times (n-1) \times (n-2)}{24}$

其实这个时候结论就出来了。

$\displaystyle xishu = \frac{n \times (n-1) \times (n-2) \times \cdots  (n-k+1)}{k!}$

前边的系数求出来了，后边的 f(q) 可以枚举加快速幂求解，不再赘述。

答案就是系数乘上 f(q) ，别忘了取膜。

### code
```cpp
#include <bits/stdc++.h>
#define int long long
#define N 500010
#define M 1010

using namespace std;
const int mod = 1000000007;
int n, m, k, q, xi = 1, chu = 1, a[N];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

int q_pow(int a, int b) {
	if (!b) return 1;
	int ans = 1;
	while (b) {
		if (b & 1) ans = (ans * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return ans;
}

signed main() {
	n = read(), m = read(), k = read(), q = read();
	q %= mod;
	for (int i = 1; i <= k; i++) {
		xi = (xi * (n - i + 1)) % mod;
		chu = (chu * i) % mod;
	}
	xi = (xi * q_pow(chu, mod - 2)) % mod;
	for (int i = 0; i <= m; i++) a[i] = read();
	int ans = 0;
	for (int i = m; i >= 0; i--) 
		ans = (ans + (a[i] * q_pow(q, i)) % mod) % mod;
	cout << (ans * xi) % mod;
	return 0;
}
```

---

## 作者：David_H_ (赞：2)

## 题意简述

给定 $q$、$f(x) = \sum_{i=0}^{m}a_ix^i$ 和 $a_i$（$i=0,1,2,3,\cdots,m$），求出

$$\sum_{1\le a_1<a_2<\cdots<a_k\le n}\mathclap{f(q)}$$

的值。

## 思路简述
先对

$$\sum_{1\le a_1<a_2<\cdots<a_k\le n}\mathclap{f(q)}$$

进行化简：

$$\sum_{1\le a_1<a_2<\cdots<a_k\le n}f(q) =f(q)\sum_{1\le a_1<a_2<\cdots<a_m\le n}1$$

而
$$\sum_{1\le a_1<a_2<\cdots<a_k\le n}1$$
可以看做是从 $[1,n]$ 随机选 $k$ 个正整数的选法，有 $\binom n k = \mathrm{C}_{n}^{k}$ 种选法。即原式为
$$f(q)\binom n k$$

对于 $\binom n k$，一种比较好的计算方法如下：

$$\begin{aligned}\binom n k &= \frac{n!}{k!\cdot(n-k)!}\\&=\frac{\prod_{i=n-k+1}^{n}i}{k!}\end{aligned}$$

其中， $\prod_{i=1}^{n}=1\times 2\times 3\times \cdots \times n$。注意最后要乘法逆元算组合数。

现在对 $f(x)$ 进行化简。可以利用秦九韶算法。例如：
$$\sum_{i=0}^{5}a_ix^i=x\left(x\left(x\left(x\left(a_5x+a_4\right)+a_3\right)+a_2\right)+a_1\right)+a_0$$

即，把一个 $n$ 次多项式转化为 $n$ 个一次多项式。具体的代码实现可见代码。

知道了这些，代码就很好写了。
## 代码
```cpp
#include <bits/stdc++.h>
typedef long long ll;
#define MOD ((ll)1e9 + 7)
using namespace std;
ll a[1000005];
ll n, m, k, q;
inline ll QuickPower(ll x, ll y, ll mod) { // 快速幂
    ll res = 1;
    while (y) {
        if (y & 1)
            res = res * x % mod;
        y >>= 1;
        x = (x * x) % mod;
    }
    return res;
}
inline int QJS(int x) {
    int ans = a[m] % MOD; // 赋初值是因为例子中的“a_0”，避免在最后做一次计算（懒）
    for (int i = m; i > 0; --i)
        ans = ((ll)1 * ans * x % MOD + a[i - 1]) % MOD;
    // 套用秦九韶公式
    return ans;
}
inline ll C(int n, int k) { // 组合数公式
    if (k * 2 > n)
        k = n - k;
    int QAQ = 1, QwQ = 1;
    for (int i = n; i >= n - k + 1; i--)
        QAQ = (ll)1 * QAQ * i % MOD;
    for (int i = 2; i <= k; i++)     // 从 1 开始节省时间
        QwQ = (ll)1 * QwQ * i % MOD; // 改成 *= 就玄学报错
    return (ll)1 * QuickPower(QwQ, MOD - 2, MOD) * QAQ % MOD; // 乘法逆元
}
int main(void) {
    cin >> n >> m >> k >> q;
    for (int i = 0; i <= m; i++)
        cin >> a[i];
    cout << (ll)1 * QJS(q % MOD) * C(n, k) % MOD;
    return 0;
}
```

---

## 作者：251Sec (赞：1)

蓝题？大概是恶评吧。实际难度下位黄。

首先 $f(q)$ 是个啥用没有的玩意，可以直接 $O(m)$ 预处理出来。

然后发现原问题等价于求长度为 $k$ 的，所有元素在 $[1,n]$ 内的严格单调递减数列的数量。显然，我们从 $[1,n]$ 中任取 $k$ 个不同的数，然后从大到小排列，都可以满足条件。因此这样数列的数量为 $\dbinom{n}{k}$。

因此最终答案为 $\dbinom{n}{k}f(q)$。

```cpp
#include <bits/stdc++.h>
using namespace std; 
typedef long long ll;
const int p = 1e9 + 7;
int n, m, k;
ll q, x, ans;
ll a;
ll f(ll x) {
    ll res = 1;
    for (ll i = 2; i <= x; i++) res = res * i % p;
    return res;
}
ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}
ll inv(ll a) {
    return qpow(a, p - 2);
}
int main() {
    scanf("%d%d%d%lld", &n, &m, &k, &q);
    q %= p;
    x = 1;
    for (int i = 0; i <= m; i++) {
        scanf("%lld", &a);
        a %= p;
        ans += x * a % p;
        x = x * q % p;
    }
    ans = ans * f(n) % p * inv(f(k)) % p * inv(f(n - k)) % p;
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：_ztyqwq (赞：1)

# 题面代码里的 a[1] ~ a[k] 和下面公式的 $ a_m, ..., a_0 $ 不是一个东西！

u1s1 为什么不换一个变量名……题目读假了 10min……

观察 $ f(x) $ 表达式，发现当 $ x(=q), m, a0, ..., a_m $ 都固定时，$ f(x) $（即 $ f(q) $）的值不变

所以只要算出 $ f(q) $ 的值和代码中取到 $ f(q) $ 的次数即可

对于 $ f(q) $ 可以采用著名的秦九韶算法.

$$ a_mx^m + a_{m-1}x^{m-1} + ... + a_2x^2 + a_1x + a_0 $$

$$ = (a_mx^{m-1} + a_{m-1}x^{m-2} + ... + a_2x + a_1)x + a_0 $$

$$ = [(a_mx^{m-2} + a_{m-1}x^{m-3} + ... + a_2)x + a_1] + a_0 $$

$$ = ... $$

（类似，~~套娃~~）

$$ = ((...(((a_mx + a_{m-1})x + a_{m-2})x + a_{m-3})x + ...)x + a_1)x + a_0 $$

计算的时候从最内层开始算，令初值为 $ a_m $，每次乘上 $ x(=q) $ 再加上下一个系数即可

```cpp
int ans = a[m];
for(int i = m - 1; i >= 0; i--)
{
	ans = ans * q % mod;
	ans = (ans + a[i]) % mod;
}
```

记得在算之前将 $ q $ 取模（$ q \leqslant 10^{18} $）。

这部分复杂度为 $ O(m) $

---

接下来算 $ f(q) $ 取到的次数

观察代码发现，$ a[1], a[2], ..., a[k] $ 是从大到小排列的，且每个数都在 $ 1 \sim n $ 之间

**也就是说，对于任意一种从 $ n $ 个数中选 $ k $ 个的方案，都有恰好一组 $ a[1], ..., a[k] $ 与之对应**

换句话说，**如果合法的 $ k $ 个数 $ a[1], ..., a[k] $ 作为一组，那么所有的组不重不漏地取遍了所有从 $ n $ 个数中取 $ k $ 个的方案**（因为**有序**）

因此这样组的总数量，也就是 $ f(q) $ 取到的次数，就等于从 $ n $ 个数中取 $ k $ 个的方案数，就是组合数 $ C_n^k $

这题无需 `Lucas` 定理，因为模数太大。组合数暴力算即可（$ n, k \leqslant 500000 $）

（关于乘法逆元，不会的童鞋移步 [P3811](https://www.luogu.com.cn/problem/P3811)）

这部分复杂度为 $ O(n + k) $

然后将 $ f(q) $ 与 $ C_n^k $ 相乘即是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1000000007;
int a[500001];
inline int fastpow(int a, int n)
{
	int ans = 1;
	while(n)
	{
		if(n & 1)
			ans = ans * a % mod;
		a = a * a % mod;
		n >>= 1;
	}
	return ans;
}
inline int inv(int x)
{
	return fastpow(x, mod - 2);
}
signed main()
{
	int n, m, k, q;
	scanf("%lld %lld %lld %lld", &n, &m, &k, &q);
	q %= mod;
	for(int i = 0; i <= m; i++)
		scanf("%lld", &a[i]);
	int ans = a[m];
	for(int i = m - 1; i >= 0; i--)
	{
		ans = ans * q % mod;
		ans = (ans + a[i]) % mod;
	}
	int c = 1;
	for(int i = n, j = 1; j <= k; i--, j++)
	{
		c = c * i % mod;
		c = c * inv(j) % mod;
	}
	printf("%lld\n", ans * c % mod);
	return 0; 
}
```

---

## 作者：LiveZoom (赞：1)

# 题解 P5148 【大循环】

题意就是让你求循环次数乘$f(q)$的值。

- ## 循环次数

发现任意时刻都满足 $1\leq a_1<a_2<a_3<...<a_i<...<a_k\leq n$，那么我们在$1\sim n$的区间中任意取出$k$个互不相同的自然数，则让这些数从小到大排序就是我们要的序列，则一共有$C_{n}^{k}$取法，即有$C_{n}^{k}$个循环次数。

- ## 此题解法

1. 用$\operatorname{val}$表示$f(q)$的值。

2. 用$\operatorname{fac}$数组存阶乘的值，如$\operatorname{fac}[i]$表示$i! \bmod 100000007$的值。

3. 输出$\operatorname{val}\times C_{n}^{k}$的值即可。

- ## 代码
 
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int read() {
    int f = 0, sign = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') sign = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        f = (f << 1) + (f << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f * sign;
}

const int MOD = 1e9 + 7;
const int N = 5e5 + 5;

int n, m, k, q, val;
int a[N], fac[N];

int fastPow (int a, int k) {//求快速幂
    int res = 1;
    while (k) {
        if (k & 1) res = res * a % MOD;
        a = a * a % MOD;
        k >>= 1;
    }
    return res % MOD;
}

int inv (int k) {//根据费马小定理求逆元
    return fastPow(k, MOD - 2) % MOD;
}

int C (int m, int n) {//求出C(m, n)的值
    return fac[m] * inv(fac[n]) % MOD * inv(fac[m - n]) % MOD;
}

signed main() {
    cin >> n >> m >> k >> q;
    q %= MOD;//这个地方一定要取模，不然就只有70pts!
    for (int i = 0; i <= m; ++i) {
        a[i] = read();
        a[i] %= MOD;//这个也取模最好
    }
    for (int i = m; i >= 0; --i) {
        val = (val + fastPow(q, i) * a[i] % MOD) % MOD;//求出f(q)的值
    }
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) {
        fac[i] = fac[i - 1] * i % MOD;//求出i! 除以 1e9+7的余数。
    }
    cout << val * C(n, k) % MOD << endl;//输出即可
    return 0;
}
```

# The end

求通过

---

## 作者：SegTree (赞：0)

## 题目思路
首先分析这个 $f(x)$，通过秦九韶算法可以计算出来。
$$f(x)=a_mx^m+a_{m-1}x^{m-1}+\cdots+a_1x+a_0=(\cdots((a_mx+a_{m-1})x+a_{m-2})x+......+a_1)x+a_0$$

这时，$f(x)$ 就能 $O(m)$ 的求出来。

这时分析这个系数。本质上来说就是组合数：从 $n$ 个中选 $k$ 个，就是 $C_n^k$。

所以原式就是 $C_n^k\times f(q)$。

## 代码实现

在计算 $C_n^k$ 时，由于结果很大，需要边计算边取模，而
$$C_n^k=\dfrac{A_n^k}{A_k^k}$$

涉及除法，所以需要对 $A_k^k$ 求逆元，可通过费马小定理、扩展欧几里得等实现。

```cpp
#include<iostream>
using namespace std;
#define int long long
const int p=1e9+7;
const int maxn=5e5+10;
int w[maxn];
int quickpow(int a,int b){//快速幂
    int ans=1;
    while(b){
        if(b&1)ans=ans*a%p;
        a=a*a%p;
        b/=2;
    }
    return ans;
}
int niyuan(int k){//费小求逆元
    return quickpow(k,p-2);
}
//计算组合数
int A(int n,int m){
    int ans=1;
    for(int i=n;i>=n-m+1;--i)ans=ans*i%p;
    return ans;
}
int C(int n,int m){
    return A(n,m)*niyuan(A(m,m))%p;
}
signed main(){
    int n,m,k,q,ans=0;
    cin>>n>>m>>k>>q;
    q%=p;
    for(int i=0;i<=m;++i)cin>>w[i];
    //秦九韶算法求多项式
    for(int i=m;i>0;--i)ans=(ans+w[i])*q%p;
    ans=(ans+w[0])%p;
    ans=ans*C(n,k)%p;
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：linbinwu (赞：0)

## 题解

本题就是求循环次数$*f(p)$，其中$f(p)$很好求，下面求循环次数

先将题意转化一下：求长度为$k$且$1 \leq a_i \leq n$的严格递减序列的个数

由于严格递增和严格递减序列是等价的，下面我求严格递增序列个数

既然是严格递增序列，那么我们直接考虑任意两项间的差值$d_i = a_i - a_{i - 1}$

那么每一个$d_i$只能选$1,2,3,4,...,n$，然后要选$k$个$d_i$，最后$\displaystyle\sum_{i = 1} ^ {k} d_i \leq n$

生成函数可以解决这个问题

记选取一个$d$的普通型生成函数$F(x)=x+x^2+x^3+···=x(1+x+x^2+x^3+···)=\frac{x}{1-x}$

其中$x_i$的系数就是$d=i$时的方案数

则选取$k$个$d$时的生成函数就是
$G(x)=F^{k}(x)=x^k(1-x)^{-k}=x^k \displaystyle\sum_{i=0}^{\propto}C(k+i-1,i)x^{i}$

其中$x_i$的系数就是$\displaystyle\sum_{j = 1} ^ {k} d_j = i$时的方案数

那么我们需要的答案就是$x_{1}, x_{2}, x_{3}, ..., x_{n}$的系数之和

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 10;
const ll mod = 1e9 + 7;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll fac[N], ifac[N];
void init(int siz) {
    fac[0] = 1;
    for (int i = 1; i <= siz; i++)
        fac[i] = i * fac[i - 1] % mod;
    ifac[siz] = qpow(fac[siz], mod - 2);
    for (int i = siz; i >= 1; i--) ifac[i - 1] = ifac[i] * i % mod;
}

ll C(ll n, ll m) {
    if (m == 0 || n == m) return 1;
    if (m > n) return 0;
    if (m == 1) return n;
    return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

int main() {

    init(5e5);
    ll n, m, k, q; scanf("%lld%lld%lld%lld", &n, &m, &k, &q);
    ll fnum = 0, base = 1; q %= mod;
    for (int i = 0; i <= m; i++, base = base * q % mod) {
        ll x; scanf("%lld", &x);
        fnum = (fnum + x * base % mod) % mod;
    }
    ll sum = 0;
    for (int i = 0; i <= n - k; i++) sum = (sum + C(k + i - 1, i)) % mod;
    printf("%lld\n", fnum * sum % mod);


    return 0;
}
```


---

## 作者：TRZ_2007 (赞：0)

# Solution 
```cpp
void work()
{
  ans=0;
    for(a[1]=1;a[1]<=n;++a[1])
      for(a[2]=1;a[2]<a[1];++a[2])
        for(a[3]=1;a[3]<a[2];++a[3])
          //......
            for(a[k]=1;a[k]<a[k-1];++a[k])
              ans+=f(q);
 cout<<ans;
}
```
观察以上代码，发现$ans=$循环次数$\times f(q)$（好像楼上也是这么说的……）  
怎么求循环次数呢？  
发现循环次数是$\sum\limits_{1\le a_1\le a_2\le....\le a_k}$，相当于是在一个从$1$到$n$的全排列中无序取$k$个，就是组合数$C_n^k$。  
现在接下来的内容高中生可以不看了，直接看代码。小学生或初中生我们来看看怎么快速地求组合数。  
首先你需要知道这个：  
$$C_n^k = \dfrac{n!}{k!\times (n-k)!}$$  
其中“!”表示阶乘。  
那么这个式子进行约分，可以得出：  
$$C_n^k = \dfrac{n\times (n-1) \times (n-2)\times .... \times (n-k+1)}{k!}$$  
所以说，我们知道了：  
$$ans=C_n^k\times f(q)$$  
我们接下来拆$f(x)$ 
![](https://cdn.luogu.com.cn/upload/pic/4012.png)  
所以说：  
$$f(q)=\sum\limits_{i=0}^m a_i\times q^i$$  
这个暴力就可以了，但是组合数别想着暴力，会T的，要用[乘法逆元](https://www.luogu.com.cn/problem/P3811)  
这个会了之后，我们就看看你们最想要的东西。  
# Code  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;
const int N = 1000010;

int n,m,k;
long long q;
int a[N];

int qpow(int x,int p) {  //快速幂
	int ans = 1;
	while(p) {
		if(p & 1) ans = 1ll * ans * x % mod;
		x = 1ll * x * x % mod;
		p >>= 1;
	}
	return ans % mod;
}

int C(int n,int k) {  //求组合数
	if(k * 2 > n) k = n - k;
	int t1 = 1,t2 = 1;
	for(int i = n;i >= n - k + 1;i--) t1 = 1ll * t1 * i % mod;  //求n*(n-1)*(n-2)*……*(n-k+1)
	for(int i = 2;i <= k;i++) t2 = 1ll * t2 * i % mod;  //求k!
	return 1ll * qpow(t2,mod - 2) * t1 % mod; //逆元求组合数
}

int f(int x) {  //暴力算f(q)
	int cnt = a[m] % mod;
	for(int i = m;i;i--) {
		cnt = (1ll * cnt * x % mod + a[i - 1]) % mod;
	}
	return cnt;
}

int main() {
	scanf("%d %d %d %lld",&n,&m,&k,&q);
	q %= mod;
	for(int i = 0;i <= m;i++) {  //注意有常数项，从a[0]读到a[m]
		scanf("%d",&a[i]);
	}
	printf("%lld\n",1ll * f(q) * C(n,k) % mod);  //把求出来的东西套进去算
	return 0;
}
```

---

## 作者：T_F_P (赞：0)

### 前言
好水啊~

写题解的人好少。？


------------
# 思路

上面那位同志说的很清楚了，我来讲下组合数和$f(q)$的计算部分。

组合数：

递推肯定超时，于是要逆元求$C(n,m)$或者$Lucas$。


------------

### 逆元：

由于
$$C(n,k)=\frac{n \times (n-1) \times \ldots \times (n-k+1)}{k!} $$

对$k!$进行乘法逆元得到$k! \times s=1(mod$ $10^9+7)$

快速幂求逆元，带入求值即可。

### Lucas：

$Lucas$定理随便搞一搞$\ldots$

### 需注意，由于模数较大，$Lucas$会比较慢。

------------

## $f(q)$

### 秦九韶算法
也不讲了
### 暴力？
代码如下
```cpp
int f(int q,int mod){
	int res=0,x=1;
	for(int i=0;i<=m;i++){
		res=(0ll+res+a[i]*x%mod)%mod;
		x=1ll*x*q%mod;
	}
	return res;
}
```


------------
## $AC$ $Code$ $(26$行$)$：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m,k;
inline int quick_pow(int x,int y){
	int res=1;
	for(;y;y>>=1,x=1ll*x*x%mod)if(y&1)res=1ll*res*x%mod;
	return res%mod;
}
inline int C(int n,int m){
	int cal=1,calt=1;
	for(int i=2;i<=m;i++)cal=1ll*cal*i%mod;
	for(int i=n-m+1;i<=n;i++)calt=1ll*calt*i%mod;
	return 1ll*calt*quick_pow(cal,mod-2)%mod;
}
int a[1000005];
int main(){
	cin>>n>>m>>k;
	long long q;
	cin>>q;q%=mod;
	for(int i=0;i<=m;i++)scanf("%d",&a[i]);
	int ans=a[m]%mod;
	for(int i=m;i;i--)ans=(1ll*q*ans%mod+a[i-1])%mod;
	cout<<1ll*ans*C(n,k)%mod<<endl;
	return 0;
} 
```

---


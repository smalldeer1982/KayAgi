# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# 题解

## 作者：冒泡ioa (赞：583)

一道入门的区间dp，当然，根据写法不同你还可以把它归类为树形dp或者记忆化搜索，其实都无所谓啦。  
作为一道入门题，我们完全可以“显然”地做出来，但是在这里还是想和大家回顾下动态规划以及区间动规。  

Q：dp特点是什么？  
A：dp把原问题视作若干个**重叠**的子问题的逐层递进，每个子问题的求解过程都会构成一个“阶段”，在完成一个阶段后，才会执行下一个阶段。  
Q：dp要满足无后效性，什么叫无后效性？  
A：已经求解的子问题不受后续阶段的影响。

有人觉得dp很抽象，那是因为没有一步一步来想，直接听别人的结论，我们在这里以这道题为例，一步一步来推导。

首先，我们要做的就是**设计状态**，其实就是设计dp数组的含义，它要满足无后效性。  
关注这个  _左子树*右子树+根_ 我只要知道左子树分数和右子树分数和根的分数（已给出），不就可以了吗？管他子树长什么样！  
所以，我们$f$数组存的就是最大分数，怎么存呢？  
我们发现：子树是一个或多个节点的集合。  
那么我们可不可以开一个$f[i][j]$来表示节点i到节点j成树的最大加分呢？可以先保留这个想法（毕竟暂时也想不到更好的了）。 

如果这样话，我们就来设计状态转移方程。  
按照刚刚的设计来说的话，我们的答案就是$f[1][n]$了，那么我们可以从小的子树开始，也就是len，区间长度。有了区间长度我们就要枚举区间起点，i为区间起点，然后就可以算出区间终点j。  
通过加分二叉树的式子我们可以知道，二叉树的分取决于谁是根，于是我们就在区间内枚举根k。  
特别的，$f[i][i]=a[i]$其中a[i]为第i个节点的分数。    
因为是要求最大值，所以我们就可以设计出
$$f[i][j]=MAX(f[i][k-1]*f[k+1][j]+f[k][k])$$
于是乎，我们就自己设计出了一个dp过程，因为是顺着来的，所以很少有不成立的。  

至于输出前序遍历，我们再设计一个状态$root[i][j]$来表示节点i到节点j成树的最大加分所选的根节点。  
所以我们按照$根->左->右$的顺序递归输出即可。

## 代码
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN = 50;
typedef long long ll;
ll n;
ll f[MAXN][MAXN], root[MAXN][MAXN];

void print(ll l, ll r) {
	if (l > r)return;
	printf("%lld ", root[l][r]);
	if (l == r)return;
	print(l, root[l][r] - 1);
	print(root[l][r]+1,r);
}

int main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++)scanf("%lld", &f[i][i]),f[i][i-1]=1, root[i][i] = i;
	for (int len = 1; len < n; ++len) {
		for (int i = 1; i + len <= n; ++i) {
			int j = i + len;
			f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解
			root[i][j] = i;//默认从起点选根
			for (int k = i + 1; k < j; ++k) {
				if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
					f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
					root[i][j] = k;
				}
			}
		}
	}
	cout << f[1][n] << endl;
	print(1, n);
	return 0;
}
```

---

## 作者：winmt (赞：276)

这题是一道比较简单的**树形DP**。我们可以分成3个任务分别解决，如下：（包含CPP及Pascal代码片段）


**【任务一】采用动态规划方法计算最大分值**

本题可以采用动态规划方法来解决，具体如下：

设f[i, j]为顶点i . . 顶点j所组成的子树的最大分值。若f[i, j] = -1，则表明最大分值尚未计算出。

**f(i,j)={1 (i>j) ; 顶点i的分数 (i=j) ; max(f{i,k-1}\*f{k+1,j}+顶点i的分数 (i<j) 『k取i～j』)**

root[i, j]——顶点i..顶点j所组成的子树达到最大分值时的根编号。当i = j时，root[i, i] := i。

由于问题没有明显的阶段特征，而是呈现为非线性的树形结构，因此，我们采用后序遍历的顺序来计算状态转移方程。计算过程如下：


**【参考程序片段】{cpp版}**

   

   

```cpp
long long search(int L, int r)    // 递归计算f[L][r]
{
int  k;
long long  now, ans;    // 当前分值
if (L > r) return 1;
if (f[L][r]== -1)     // 若尚未计算出顶点L..顶点r对应子树的最高分值
   for(k=L; k<=r; k++) {     // 穷举每一个可能的子根k
      now = search(L, k-1) * search(k+1, r) + f[k][k];  
// 计算以k为根的子树的分值
      if(now > f[L][r])  {
//若该分值为目前最高，则记入状态转移方程，并记下子根}
          f[L][r] = now; 
root[L][r] = k;
      }
}
return  f[L][r];   {返回顶点L..顶点r对应子树的最高分值}
}
```
**【参考程序】{Pascal版}**
function search(L, r: integer) : int64;    {递归计算f[L. r]}

```cpp
var
  i: integer;
  now: int64;   {当前分值}
begin
  if L > r then search := 1
  else 
begin
      if f[L, r] = -1 then {若尚未计算出顶点L..顶点r对应子树的最高分值}
        for i := L to r do  {穷举每一个可能的子根i}
          begin
            now := search(L, i-1) * search(i+1, r) + f[i, i];  {计算以i为根的子树的分值}
            if now > f[L, r] then  {若该分值为目前最高，则记入状态转移方程，并记下子根}
              begin
                f[L, r] := now; way[L, r] := i;
              end;
        end;  {for}
        search := f[L, r];   {返回顶点L..顶点r对应子树的最高分值}
    end;   {else}
end;  {search}
```
显然，主程序可以通过递归调用search(1, n)来计算最高分值。算法的时间复杂度为O(n^2)。

**【任务二】输出加分二叉树的前序遍历**

递归调用search(1, n)后得出的way给出了加分二叉树的结构，其中way[i, j]为该树中顶点i..顶点j的根序号。由于二叉树中序遍历的顺序为1..n，因此，1..way[i, j]-1为左子树，way[i, j] + 1 .. j为右子树。现按照根→左子树→右子树的顺序对加分二叉树进行前序遍历。

注意：由于数字之间用空格隔开，而第一个数字前没有空格，因此，设firstwrite为首数字标志。一旦输出了第一个数字，firstwrite设为false，表明在输入新的数字前需要加空格。

由此，得出前序遍历加分二叉树的算法：


**【参考程序片段】{CPP版}**




```cpp
// 前序遍历顶点L..顶点r对应的子树
void  preorder(int L, int r)
{
if (L > r)  return;
if (firstwrite)
firstwrite = false;
else
  cout<<‘ ‘;      // 顶点间用空格分开
cout << root[L][r];             // 输出子树的根
preorder(L, root[L][r]-1);     // 前序遍历左子树
preorder(root[L][r]+1, r);     // 前序遍历右子树
}
```
**【参考程序片段】{Pascal版}**

```cpp
procedure  preorder(L, r: integer);
// 前序遍历顶点L..顶点r对应的子树
begin
   if L > r then exit;
   if firstwrite then
       firstwrite := false
   else
       write(‘ ‘);   {顶点间用空格分开}
   write(way[L, r]);   {输出子根}
   preorder(L, way[L, r] - 1);   {前序遍历左子树}
   preorder(way[L, r] + 1, r);   {前序遍历右子树}
end;
```
**【任务三】主程序**
有了search函数和preorder过程，就不难得出主程序了：


**『Cpp』**


   
   
   

   

```cpp
int main()
{
int n, i;
bool  firstwrite;
cin >> n;    // 读顶点数
for(i=1; i<=n; i++)      // 状态转移方程初始化
  for(j=i; j<=n; j++)
    f[i][j] = -1;
for (i=1; i<=n; i++) {
  cin >> f[i][i];       // 读顶点i的分值
  root[i][i] = i;        // 顶点i单独成一棵子树
   }
cout << search(1, n) << endl;      // 计算和输出最高加分
firstwrite = true;                   // 设立首顶点标志
preorder(1, n);                       // 前序遍历二叉树
return 0;
}
```
**『Pascal』**




```cpp
read(n);  {读顶点数}
for i := 1 to n do   {状态转移方程初始化}
  for j := i to n do
    f[i j] := -1;
for i := 1 to n do
  begin
    read(temp);   {读顶点i的分值}
    f[i, i] := temp;  way[i, i] := i;   {顶点i单独成一棵子树}
  end;
writeln(search(1, n));   {计算和输出最高加分}
firstwrite := true;     {设立首顶点标志}
preorder(1, n);    {前序遍历二叉树}
writeln;
```
以上算法采用了自上而下的**记忆化方法**，即程序流程基本按照**原问题的递归定义**，不同的是，它专门设置了一张表way，用来记忆在求解过程中得出的所有子树的根，以便在前序遍历中使用。
另外，当在递归过程中第一次遇到一个子问题（f[L, r]=-1）时，计算其解，以后每遇到该子问题时，就不重复计算f[L, r]了。记忆化方式有着只解那些肯定要解的子问题的优点。\_**在应用动态规划方法求解非线性结构问题时，一般采用自上而下的记忆化方法**\_。


---

## 作者：噬月 (赞：37)

[P1040加分二叉树](https://www.luogu.com.cn/problem/P1040)

 _**猜想**_ ：此题可以用DP来做。

首先我们想，符合条件的二叉树是加分最高的二叉树，它的总分依题意得 ```总分 = 左子树分数 * 右子树分数 + 根节点分数``` ，不难看出，欲使总分最高，左右子树的分数应当也分别取最高。 而子树的最高分怎么求呢？自然也是 ```子树总分 = 子树左子树分数 * 子树右子树分数 + 子树根节点分数``` 由此我们得到此题具有**最优子结构**性质。

又，分数计算公式只和左子树分数，右子树分数和根节点分数有关，与如何得到这两个子树分数的方法和路径无关，易得此题的解具有**无后效性**。

故猜想可行。

---
 _**设计状态**_ ：设计DP数组的含义，使其满足无后效性。

题目中给出的节点序号根据二叉树的中序遍历排列，可以想见，任取两个下标$i,j,(i<j)$，可以表示从节点$i$到节点$j$所构成的子树的最高加分（由无后效性可知，**当区间之外还有子树时**，此最高分叠加了区间$[i, j]$之外的节点的最高分）。并设$k(i \le k \le j)$为该子树的根节点，通过枚举根的不同位置来取得不同的左右子树和根节点分数，进而得出最大值。

特别地，我们约定①，当下标相等时，$f_{x, x}$ 的**初始值**为序号为x的节点的初始分数。

由此我们写出 _**状态转移方程**_ ：

$f_{i, j} = max(f_{i, k - 1} \times f_{k + 1, j} + f_{k, k})$

因为题目要求前序遍历输出，我们再使用一个二维数组$root$来记录从节点$i$到节点$j$的最高分子树的根。

 _**代码**_ 
```cpp
#include<iostream>
#include<cstdio>


long long n;
long long f[50][50], root[50][50];
//f[i][j] showes the max scroe from i to j
//f[i][j] = max(f[i][k - 1] * f[k + 1][j] + f[k][k])
//root[i][j] showes the root of the max scroe picked

using namespace std;

void print(long long l, long long r) {
    if (l > r) {
    	return;
    }
    printf("%lld ", root[l][r]);
    if (l == r) {
		return;
    }
	print(l, root[l][r] - 1);
    print(root[l][r] + 1, r);
}

int main() {
	
	cin >> n;
	for (int i = 1; i <= n; ++ i ) {
		
		cin >> f[i][i];//node
		f[i][i - 1] = 1;//left subtree error handling②
		f[i + 1][i] = 1;//right subtree error handling
		root[i][i] = i;
	}
	
	for (int range = 1; range <= n; ++ range ) {
	//enumerate length of range, 
		for (int i = 1; i + range <= n; ++ i ) {
	//then enumerate the start point of range
			int j = i  + range;//end point
			
			//enumerate possible root from start point by default
			for (int k = i ; k <= j; ++ k ) {
				
				if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
					
					f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
					root[i][j] = k;
				}
			}
		}
	}
	
	cout << f[1][n] << endl;
	print(1, n);
	
	
	return 0;
}
```


 _**注**_ ：

①：按照约定之前的定义思路，下标相等时，由无后效性可知，当节点有子树时，此```f[x][x]```叠加了子树的最高分。而我们希望它表示序号为$x$的节点的初始分数，因此称为约定。并且我们强调初始值，因为之后是有可能会更新成更大值的。

②：当$k$取$i$时，会出现```f[i][k - 1]```这种下标相反的情况；$k$取$j$时则在另一端```f[k + 1][j]```出现同样的状况。此时的根节点$k$超出了区间的处理范围；映射到图上，则可以认为是一种左（右）子树为空的状态。由于题目给出空子树默认分数为1，我们令```f[i][k - 1] = 1```。

---
 _**关于等号的讨论：**_ 
```cpp
if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
	
	f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
   	root[i][j] = k;
}
```
其中的不等号改为等号是否有影响？

修改之后对于同一组输入，输出最高分不变，但前序遍历发生了改变：
```
输入：
5
5 7 1 2 10
输出（修改前）：
145
3 1 2 4 5
输出（修改后）：
145
3 2 1 5 4
```
若画出树，可以发现是末端度为1的单叶节点和其叶节点发生了互换；

使用另一组数据：
```
10
5 4 8 9 19 2 1 40 20 22
```
可以得到同样的实验结果（节点互换）。

结合枚举根节点的思路，我们可以发现，枚举根的过程反映到图上是在枚举不同的树型。

 _**关于边界的讨论：**_ 

上述第一组数据生成的最高分树是：
```
     3
    / \
   1    4
    \   \
    2    5
```
现在我们假设枚举过程中到了这样一个情形：

$range = 2, i = 1, j = 3,k = 3$; 

这种情形生成的树型（显然还不是完整的树）如下：
```
     3    或     3
    /          /
   2          1
  /            \
 1              2
```
我们知道，由于$k = 3$，根处于区间的右端，```f[k + 1][j]```显然出现了注②中下标相反的情况，而我们的处理方法是将它默认当作右子树为空来处理。

此处需要强调，如果节点3在之前的遍历中已经被计算过，则```f[3][3]```的数据显然已经被更新为目前为止的最高分，但**可能不全面**。可能出现不全面的情况是：计算的时候节点3刚好在区间端点，受到了我们的默认处理。我们接下来要讨论的部分就是这种不全面是否会影响最终答案。

回到上述情形，现在需要考虑三种情况：

1. 节点3真的没有右子树；
1. 节点3存在右子树，但还未计算过；
1. 节点3存在右子树，且```f[3][3]```的数值已经被更新，但由于处理右子树时节点3处于区间的左端点，因此```f[3][3]```忽略了左子树而计算不全。

分析：

- 情况1的结果是显然的，没有右子树自然不会影响后续计算。

- 情况2，若节点3存在右子树但还未计算过，我们的程序默认认为它没有右子树，计算并更新了```f[3][3]```的值，就出现了我们所说的**不全面**。 然而，当枚举的下一阶段到来（由于右子树存在，区间的长度肯定还未枚举完毕），区间长度+1，且根节点k再次取3时，由于节点3不再处于端点，```f[k + 1][j]```未出现下标相反，右子树就可以被程序所识别。此时对分值进行比较：```f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]```显然的，这个表达式恒真。因此我们可以得出重要的结论：**情况2的计算将造成不全面，但这种不全面是局部的，不会影响整体的运算结果。**

- 情况3，由于我们的枚举是从小到大的，所以其实并不存在忽略左子树的情况；忽略左子树的情况只有从大到小枚举才有可能发生。而如果这样，如2所述，也将在下一次枚举中被更新为正确的值。

综上，对边界的默认处理不会影响最终答案。

---
参考博客：

[大佬冒泡ioa的题解](https://bubbleioa.blog.luogu.org/solution-p1040)


---

## 作者：Sooke (赞：3)

已知中序遍历，那么可得出存在的树是连续的节点 x~y 构成的，又根据以上描述，可知使用的算法是区间动态规划（区间的连续的），类似的题目还有合并石子。但还是需要先特判没有左子树或右子树的情况，再枚举目前区间表示的子树的根节点是什么。具体的步骤楼下的大佬们已经讲得很详细了。不过我习惯将目前子树的前序遍历直接用 string 存着，等到再次调用直接相加即可，可以代替麻烦的递归步骤。缺点是，如果 n 过大，使用 string 就可能会爆（此时使用递归就绰绰有余了）。

首先，需要码出一份数字转化为字符串的表（不要忘了数字后还要多一个空格，字符串相接的时候无需再额外加上空格了）：

```cpp
string c[31]={"0 ","1 ","2 ","3 ","4 ","5 ","6 ","7 ","8 ","9 ","10 ","11 ","12 ","13 ","14 ","15 ","16 ","17 ","18 ","19 ","20 ","21 ","22 ","23 ","24 ","25 ","26 ","27 ","28 ","29 ","30 "};
```
这是比较辛苦的步骤，但是为快速求答作了铺垫。

设 s[x][y] 表示 区间 x~y 最大加分树的前序遍历，首先，先为每个节点 i 对应的 s[i][i] 赋值 c[i]。

如果需要得到更大的区间 x~y 最大加分树的前序遍历，已知根节点的编号，只需要 根结点 对应的 s[p][p] 加 左子树 对应的 s[x][p-1] 加 右子树 对应的 s[p+1][y] 即可。最后，输出最终的前序遍历，也就是 s[1][n]。简化了递归。如果左子树、右字数为空，表明对应的 s[x][y] 也为空字符串，即不用管。

具体代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#define f(i , a , b) for(int i = (a) ; i <= (b) ; i++)
using namespace std;
unsigned int v[32][32];
string c[31]={"0 ","1 ","2 ","3 ","4 ","5 ","6 ","7 ","8 ","9 ","10 ","11 ","12 ","13 ","14 ","15 ","16 ","17 ","18 ","19 ","20 ","21 ","22 ","23 ","24 ","25 ","26 ","27 ","28 ","29 ","30 "};
string s[32][32];
int main(){
    int n;
    scanf("%d" , &n);
    f(i , 1 , n) scanf("%d" , &v[i][i]) , s[i][i] = c[i];
    f(k , 1 , n-1)
        f(i , 1 , n-k){
            if(v[i][i+k] < v[i][i] + v[i+1][i+k])
            v[i][i+k]=v[i][i] + v[i+1][i+k] , s[i][i+k]=s[i][i]+s[i+1][i+k]; //枚举没有左子树的情况
            if(v[i][i+k] < v[i+k][i+k] + v[i][i+k-1])
            v[i][i+k]=v[i+k][i+k] + v[i][i+k-1] , s[i][i+k]=s[i+k][i+k]+s[i][i+k-1]; //枚举没有右子树的情况
            f(p , i+1, i+k-1)
                if(v[i][i+k] < v[p][p] + v[i][p-1] * v[p+1][i+k])
                v[i][i+k] = v[p][p] + v[i][p-1] * v[p+1][i+k] , s[i][i+k] = s[p][p]+s[i][p-1]+s[p+1][i+k];
        }
    printf("%d\n" , v[1][n]);
    cout << s[1][n];
    return 0;
}
```

---

## 作者：香风智乃 (赞：2)

https://www.luogu.org/problemnew/show/P1040

~~全场唯一写三维数组的蒟蒻（逃~~

硬是把树形dp写成了区间dp

对于每个 $f[i][l][r]$
- $i$：以$i$为根
- $l$：以$l$为左端点
- $r$：以$r$为右端点
- $f[i][j][k]$：可以得到的最大值

每次枚举（按嵌套顺序）：
- $len$：枚举的长度( $0$~$n-1$)
- $i$：枚举的树根
- $l$：左端点（右端点$r=l+len$）
- $j$：子树的树根

状态转移方程：$f[i][l][r]=max(f[j][l][i-1],(l<=j<=i-1)) * max(f[j][i+1][r],(i+1<=j<=r))+a[i]$

前序遍历：开一个$ld[i][l][r]$和$rd[i][l][r]$把该状态下的左右儿子存起来即可~~反正空间够大随便开~~

复杂度：$O(n^4)$
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#define ll long long
#define rint register int
#define rll register long long
using namespace std;

inline int getint()
{
	register char c=getchar(); rint x=0;
	while(!isdigit(c)) c=getchar();
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}
int wt[30];
inline void outint(int x)
{
	if(!x)
	{
		putchar(48); return ;
	}
	rint l=0;
	while(x) wt[++l]=x%10,x/=10;
	while(l) putchar(wt[l--]+48);
}

const ll maxl(const ll &a,const ll &b) {return a>b ?a:b;}
const int max(const int &a,const int &b) {return a>b ?a:b;}
const int min(const int &a,const int &b) {return a<b ?a:b;}

//------上面的优化可无视-------
const int maxn=32;
ll f[maxn][maxn][maxn];
int a[maxn],n,ld[maxn][maxn][maxn],rd[maxn][maxn][maxn];

inline void first_travel(int x,int l,int r)//前序遍历
{
	outint(x),putchar(' ');
	if(ld[x][l][r]) first_travel(ld[x][l][r],l,x-1); 
	if(rd[x][l][r]) first_travel(rd[x][l][r],x+1,r);
}
int main()
{
	n=getint();
	for(rint i=1;i<=n;++i) a[i]=getint();

	for(rint len=0;len<n;++len)
		for(rint i=1;i<=n;++i)
			for(rint l=max(1,i-len);l<=min(i,n);++l) //防止超出范围
			{
				rint r=l+len;
				rll lc=0,rc=0;
				for(rint j=1;j<i;++j) //左子树查找
					if(lc<f[j][l][i-1])
					{
						lc=f[j][l][i-1];
						ld[i][l][r]=j;
					}
				for(rint j=i+1;j<=r;++j) //右子树查找
					if(rc<f[j][i+1][r])
					{
						rc=f[j][i+1][r];
						rd[i][l][r]=j;
					}
				if(!ld[i][l][r]) lc= rd[i][l][r] ? 1:0;//如果左右子树都为空就是叶子节点，lc*rc应为0
				if(!rd[i][l][r]) rc=1;
				f[i][l][r]=lc*rc+a[i];
			}
	rll ans=0; rint root=0;
	for(rint i=1;i<=n;++i)
		if(ans<f[i][1][n])
		{
			ans=f[i][1][n];
			root=i;
		}
	printf("%lld\n",ans);
	first_travel(root,1,n);
	return 0;
}
```

---

## 作者：_WA自动机 (赞：1)

DP。先考虑暴力，枚举每个可能排列，肯定TLE。但发现每棵子树的加分出现重复计算，且子树的中序遍历为连续的，故
设$f(i,j)$为中序遍历为$(i,i+1,..,j)$的树的最大权值，则
$f(i,j)=max\lbrace{f(i,k)*f(k+2,j)+w(k+1)}\rbrace$  
边界为$f(i,i)=w(i)$  
然后我特判了左右子树为空。输出方案可记录每个子树的根即当转移时记录$root(i,j)=k+1$.递归输出前序遍历。
上代码：  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50;
int g[maxn][maxn];
void printans(int l,int r)
{
	if (l<=r)
	{
		printf("%d ",g[l][r]);
		if (l<r)
			printans(l,g[l][r]-1),
			printans(g[l][r]+1,r);
	}
}
int main()
{
	//f[i][j]=max{f[i][k]*f[k+2][j]+f[k+1][k+1]}
	static unsigned f[maxn][maxn],w[maxn];
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;++i)
		scanf("%d",w+i);
	for (int i=1;i<=n;++i)
		f[i][i]=w[i],g[i][i]=i;
	for (int i=n;i;--i)
		for (int j=i+1;j<=n;++j)
		{
			if (f[i][j]<f[i+1][j]+w[i]) f[i][j]=f[i+1][j]+w[i],g[i][j]=i;
			if (f[i][j-1]+w[j]>f[i][j]) f[i][j]=f[i][j-1]+w[j],g[i][j]=j;
			for (int k=i;k<j-1;++k)
				if (f[i][k]*f[k+2][j]+w[k+1]>f[i][j]) f[i][j]=f[i][k]*f[k+2][j]+w[k+1],g[i][j]=k+1;
		}
	printf("%d\n",f[1][n]);
	printans(1,n);
}
```

---

## 作者：cqsunny (赞：0)

观察到 $n \le 30$，求最高加分，因此考虑到 DP。

设 $f_{i, j}$ 表示 $i$ 到 $j$ 的最大加分。

转移时枚举中转点 $k$，把 $k$ 当作根，计算左右子树的加分的乘积和该节点的加分之和，即 $f_{i, j} = f_{i, k - 1} \times f_{k + 1, j} + a_i$。注意左右子树为空的情况要特判。

如何求这棵树呢？

在转移时，如果能更新 $f_{i, j}$，就用一个 $d$ 数组记录区间 $[i, j]$ 的根（也可以记录 $k - i$）。输出方案时，进行 dfs。dfs 记录区间 $[l, r]$，每次找出根 $t$ 输出，然后继续递归 $[l, t - 1]$ 和 $[t + 1, r]$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[40];
int f[40][40];
int d[40][40];
void dfs(int x, int y){//输出方案
	if(x > y){
		return;
	}
	printf("%d ", x + d[x][y]);
	dfs(x, x + d[x][y] - 1);
	dfs(x + d[x][y] + 1, y);
}
int main(){
	memset(f, 0, sizeof(f));
	memset(d, 0, sizeof(d));
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i){
		scanf("%d", &a[i]);
	}
	for(int i = 1; i <= n; ++ i){//初始化
		f[i][i] = a[i];
		d[i][i] = 0;
	}
	for(int k = 2; k <= n; ++ k){
		for(int i = 1; i <= n - k + 1; ++ i){
			int j = i + k - 1, t1, t2;
			for(int u = i; u <= j; ++ u){
				if(u == i){
					t1 = 1;
				}
				else{
					t1 = f[i][u - 1];
				}
				if(u == j){
					t2 = 1;
				}
				else{
					t2 = f[u + 1][j];
				}
				int t = t1 * t2 + a[u];
				if(f[i][j] < t){
					f[i][j] = t;
					d[i][j] = u - i;
				}
			}
		}
	}
	printf("%d\n", f[1][n]);
	dfs(1, n);
	return 0;
}
```

---

## 作者：xz001 (赞：0)

- 由于中序遍历连续，所以相邻两个元素 $(i,i+1)$ 也为连续的，故可以转化为序列问题。
- 考虑区间动态规划。
- 设立 $f_{i,j}$ 表示 $[i,j]$ 这一段区间的最大加分，我们枚举根 $k$，转移即为：

$$
f_{i,j}=\max(f_{i,j},f_{i,k - 1}\times f_{k + 1, j}+a_i)
$$

- 其中 $a_i$ 为每个点的得分。
- 由于还需要输出前序遍历，故可以在以上转移过程中求出贡献最大的根 $g_{i,j}$。
- 然后递归输出前序遍历即可。
- 时间复杂度 $O(n^3)$，代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

// define
#define re register
#define fi first
#define se second
#define il inline
#define co const
#define ls (u << 1)
#define rs (u << 1 | 1)
#define fup(x, l, r) for (re int x = (l), eNd = (r); x <= eNd; ++ x )
#define fdw(x, r, l) for (re int x = (r), eNd = (l); x >= eNd; -- x )
#define int long long

// typedef
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

// const
const int N = 1e6 + 10, M = 2e6 + 10;
const int INF = 2e9, P = 998244353;
const double eps = 1e-6;

// debug
const bool DeBug = true;
int db_cnt;
il void db() { if (DeBug) puts("--------------"); return; }
il void db(auto a) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << '\n'; return; }
il void db(auto a, auto b) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << '\n'; return; }
il void db(auto a, auto b, auto c) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << '\n'; return; }
il void db(auto a, auto b, auto c, auto d) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << '\n'; return; }
il void db(auto a, auto b, auto c, auto d, auto e) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << ", " << e << '\n'; return; }
il void db(auto *a, auto len) { if (DeBug) { ++ db_cnt; cout << "-- | t" << db_cnt << " : {"; if (!len) cout << "empty";else { cout << a[1]; for (int i = 2; i <= len; ++ i ) cout << ", " << a[i]; } cout << "}\n"; } return; }
il void db(pair<auto, auto> a) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : <" << a.first << ", " << a.second << ">\n"; return; }

// common functions
il int Max(co int a, co int b) { return a > b ? a : b; }
il int Min(co int a, co int b) { return a < b ? a : b; }
il int read() { re int x = 0; re bool f = true; re char c = getchar(); while (c < 48 || c > 57) { (c == '-') ? f = false : 0; c = getchar(); }while (c > 47 && c < 58) x = (x << 3) + (x << 1) + c - 48, c = getchar(); return f ? x : -x; }
il void write(re auto x) { (x < 0) ? putchar('-'), x = -x : 0; (x > 9) ? write(x / 10) : void(); putchar(x % 10 + 48); return; }
il void wel(co auto x) { write(x), putchar('\n'); return; }
il void wel(co auto x, co int y) { write(x), putchar(' '), write(y), putchar('\n'); return; }
il void wel(co auto x, co int y, co int z) { write(x), putchar(' '), write(y), putchar(' '), write(z), putchar('\n'); return; }
il void wsp(co auto x) { write(x), putchar(' '); return; }

int n, a[1005], f[1005][1005], g[1005][1005];

int dfs (int i, int j) {
	if (i == j) {
		g[i][j] = i;
		return a[i];
	}
	if (f[i][j] != -1) return f[i][j];
	int ans = 0;
	for (int k = i; k <= j; ++ k) {
		if ((k - 1 < i ? 1 : dfs (i, k - 1)) * (k + 1 > j ? 1 : dfs (k + 1, j)) + a[k] > ans) {
			g[i][j] = k;
			ans = (k - 1 < i ? 1 : dfs (i, k - 1)) * (k + 1 > j ? 1 : dfs (k + 1, j)) + a[k];
		}
	}
	return f[i][j] = ans;
}

void qp (int i, int j) {
	if (j < i) return;
	printf("%lld ", g[i][j]);
	if (g[i][j] - 1 >= i) qp (i, g[i][j] - 1);
	if (g[i][j] + 1 <= j) qp (g[i][j] + 1, j);
	return; 
}

signed main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; ++ i) scanf("%lld", a + i);
	memset(f, -1, sizeof(f));
	printf("%lld\n", dfs (1, n));
	qp (1, n);
	return 0;
}


```

---


# [NOIP 2006 提高组] 能量项链

## 题目描述

在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \times r \times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。

需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\oplus$ 表示两颗珠子的聚合操作，$(j \oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为：

$(4 \oplus 1)=10 \times 2 \times 3=60$。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：

$(((4 \oplus 1) \oplus 2) \oplus 3)=10 \times 2 \times 3+10 \times 3 \times 5+10 \times 5 \times 10=710$。

## 说明/提示

NOIP 2006 提高组 第一题


## 样例 #1

### 输入

```
4
2 3 5 10
```

### 输出

```
710```

# 题解

## 作者：voilin (赞：577)

```cpp
//区间动规 
//重点就是将整体划分为区间，小区间之间合并获得大区间
//状态转移方程的推导如下
//一、将珠子划分为两个珠子一个区间时，这个区间的能量=左边珠子*右边珠子*右边珠子的下一个珠子
//二、区间包含3个珠子，可以是左边单个珠子的区间+右边两珠子的区间，或者左边两珠子的区间右边+单个珠子的区间 
//即，先合并两个珠子的区间，释放能量，加上单个珠子区间的能量（单个珠子没有能量。。）
//Energy=max(两个珠子的区间的能量+单个珠子区间的能量，单个珠子的区间的能量+两个珠子的区间的能量 ） 
//三、继续推4个珠子的区间，5个珠子的区间。
//于是可以得到方程：Energy=max（不操作的能量，左区间合并后的能量+右区间合并后的能量+两区间合并产生能量）
//两区间合并后产生的能量=左区间第一个珠子*右区间第一个珠子*总区间后面的一个珠子 
#include<bits/stdc++.h>
using namespace std;
int n,e[300],s[300][300],maxn=-1;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){cin>>e[i];e[i+n]=e[i];}
    //珠子由环拆分为链，重复存储一遍
    for(int i=2;i<2*n;i++){
        for(int j=i-1;i-j<n&&j>=1;j--){//从i开始向前推
            for(int k=j;k<i;k++)//k是项链的左右区间的划分点 
            s[j][i]=max(s[j][i],s[j][k]+s[k+1][i]+e[j]*e[k+1]*e[i+1]);
            //状态转移方程：max(原来能量，左区间能量+右区间能量+合并后生成能量）  
            if(s[j][i]>maxn)maxn=s[j][i];//求最大值 
        }
    } 
    cout<<maxn;
    return 0;
}
```

---

## 作者：NewErA (赞：276)

第一次遇到区间dp，写个题解总结一下


######区间dp能解决的问题就是通过小区间更新大区间，最后得出指定区间的最优解


个人认为，想要用区间dp解决问题，首先要确定一个大问题能够剖分成几个相同较小问题，且小问题很容易组合成大问题，从而从解决小问题逐渐解决大问题，体现的其实是分治的思想，只不过是通过dp用递推的方式解决了。比如floyd现在看来也属于区间dp 的一种。


本题应通过演算过程发现最终问题的解决可由两个相同规模较小的问题轻松地转化过来。（一般分治时只分成两个简化程序） 用f[l][r]表示以a[l]开头a[r]结尾的数串的最大和，如k为i,j之间任一节点，有f[l][r]=max(f[l][r],f[l][k]+f[k][r]+a[l]\*a[k]\*a[r]); 对l,r的定义自己一定要十分清晰，从而确定好循环的边界。


本题的小技巧：在环形问题中，可以选择(i+1)%n的方式，但也可以将n个元素复制一遍，变成2\*n个元素，简化代码。

但也有问题随之而来，在更新时要将2\*n个元素都更新，而不能只更新到前n个，否则访问到n+1~2n时会出错


附上代码



    
    
    

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[405][405];
int n,a[205]; 
int main()
{
    cin >> n;
    for(int i=1;i<=n;i++)  //***对环形问题的处理技巧***
    {
        cin >> a[i];
        a[n+i]=a[i];
    } 
    for(int i=2;i<=n+1;i++)
    {
        for(int l=1;l+i-1<=2*n;l++)  //如果采取了上述策略，一定要将2*n个点都更新 
        {
            int r=l+i-1;
            for(int k=l+1;k<=l+i-2;k++)
                f[l][r]=max(f[l][r],f[l][k]+f[k][r]+a[l]*a[k]*a[r]); 
        }
    }
    int res=0;
    for (int i=1;i<=n;i++) res=max(res,f[i][n+i]);
    cout << res;
    return 0;
}

```

---

## 作者：Valhalla_Is_Calling (赞：156)

## 最近学习了区间DP，来写题解
### DP主要的核心就是对于每道题专属的状态转移方程


####       动态规划过程是：
      
   每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划(DP)。




#### 基本思想与策略

      基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。



#### 动态规划的算法设计

1：找出最优解的性质，并描述其结构特征

2：递归定义最优值

3：以自底向上的方式计算最优值

4：根据计算最优值时得到的信息构造出最优解



能采用动态规划求解的问题的一般要具有3个性质

      (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
      
      (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。


      (3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。



使用动态规划求解问题，最重要的就是确定动态规划三要素

（1）问题的阶段 

（2）每个阶段的状态

（3）从前一个阶段转化到后一个阶段之间的递推关系。

      





#### 动态规划的具体步骤：

      (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
      
      (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
      
      (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
      
      (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。






本题思路：与其他区间DP的题目不同，能量石排列成了一个环形，所以：

```cpp
for(i=1;i<=n;i++) 
{
	cin>>head[i];
	head[i+n]=head[i];
}
for(i=1;i<=2*n-1;i++) tail[i]=head[i+1];
tail[2*n]=head[1];
```
必须使用这段复杂但有趣的环形初始化过程

之后，就要对F数组进行动态规划，选择出最值的合并方法

```cpp
for(t=1;t<=n-1;t++)
{
	for(i=1;i<=2*n-t;i++)
	{
		j=i+t;
		for(k=i;k<=j-1;k++)
		{
				f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+head[i]*tail[k]*tail[j]);
		}
	}
}
```
状态转移方程是：

```cpp
f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+head[i]*tail[k]*tail[j]);
```
原因是：K循环和I循环寻找的是石头的头和尾，所以要
和后面的方程式进行判断，更新最大值。

下面粘完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int head[205],tail[205],f[205][205]={0};
int main()
{
	int ans=0,n,i,t,j,k;
	cin>>n;
	for(i=1;i<=n;i++) 
	{
		cin>>head[i];
		head[i+n]=head[i];
	}
	for(i=1;i<=2*n-1;i++) tail[i]=head[i+1];
	tail[2*n]=head[1];
	for(i=1;i<=2*n-1;i++) f[i][i]=0;
	for(t=1;t<=n-1;t++)
	{
		for(i=1;i<=2*n-t;i++)
		{
			j=i+t;
			for(k=i;k<=j-1;k++)
			{
				f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+head[i]*tail[k]*tail[j]);
			}
		}
	}
	for(i=1;i<=n;i++) ans=max(ans,f[i][i+n-1]);
	cout<<ans<<endl;
	return 0;
 } 
```
## 杜绝抄袭，请勿作弊

---

## 作者：Kevin_Wa (赞：82)

 P1063
 
 简单的说：给你一项链，项链上有n颗珠子。相邻的两颗珠子可以合并(两个合并成一个)。合并的同时会放出一定的能量。不同的珠子的合并所释放的能量是不同的。问：按照怎样的次序合并才能使释放的能量最多？
 
　　我们用top表示第i颗珠子的头标记，用wei表示第i颗珠子的尾标记，合并两颗相邻珠子所释放的能量是：
  
　　$Q=top*wei*wei[i+1$]或
  $top*top[i+1]*wei[i+1]$; 
  
  （一个样的）
  
　　合并不一定按顺序的，本题所提供的样例也是导致出错的一大原因。
  
　　$n$个珠子进行一次合并的后，就归结到了$n-1$个珠子的合并的问题。所以我们想到了动态规划。
  
　　既然是$dp$题目，必然要满足$dp$的两大条件：
  
　　1.最优子结构性质；
　　设$Q[i,j]$表示第i颗珠子到第j颗珠子合并所产生的能量。显然$Q[1,n]$表示的是合并产生的总的能量。给定一种标号方法，$maxQ[1,n]$就是所要求的。设最后一次合并在$k$处进行，则有$Q[1,n]=Q[1,k]+Q[k+1,n]+top[1]*wei[k]*wei[n]$。要$Q[1,n]$最大，必然要$Q[1,k]$，$Q[k+1,n]$最大。
  
　　证明：假设$Q[1,k]$不是最大，则必然存在一$Q'[1,k]>Q[1,k]$。那么就有$Q'[1,n]=Q'[1,k]+Q[k+1,n]+top[1]*wei[k]*wei[n]>Q[1,k]$。这与$Q[1,n]$的最优性矛盾。
  
　最优子结构性质得证。
 
　2.无后效性；
 
　　 无后效性是显然的，进行某次合并，合并前与合并后状态是相对独立，不相关联，互不影响的。
　　
  
　　算法已经定了下来了，关键是怎么实现了。
  
　　项链是一个环，而我们处理是对一个串进行的。所以我们要把项链从某处割断展开，不同处的割断对应着不同的展开方法，也就是对应着不同的标号方法。产生的$maxQ[1,n]$也就不同的。所以我们要对这些$maxQ[1,n]$进行打擂，取其最大的一个，即为解了。
  
　　dp的转移方程是：
  
　　$ Best=maxQ[1,n] 1<=i<=n$ ($i$表示从第$i$颗珠子处展开，顺次标号）；
   
　　 $Q[i,j]$=$max${$Q[i,k]+Q[k+1,j]+top*wei[k]*wei[j] 1<=i<=k<j<=n $};
   
　　 其中$Q[i,i]=0;$ 
    $1<=i<=n$;
   
　　dp的时间复杂度为$O(n^3)$，n种的展开方法对应需要n次的dp，所以时间复杂度为$O(n^4)$。空间为$O(n^2)$。
  
　　显然$O(n^4)$过这个题目是有点欠缺的，对的大的数据貌似很容易超时的。
  
　　如果仔细想想，我们还是做了很不重复的工作的，不同的展开方式中必然存在着很多的大量的重复运算。于是还有很大的优化空间，既然展开做了很多的重复的工作，那么就合并起来吧。回到起点，开始的时候为什么我们要对项链做n次的展开呢，基于我们在运算的时候不能够实现第一颗珠子与第n颗珠子的相邻性。为了一次dp就实现所以的的珠子的相邻性，我们做如下处理：
  
$a[1]$,$a[2]$,$a[3]$...$a[n]$,$a[1]$,$a[2]$...$a[n-1]$　
 
也就是：　　

$a[1]$,$a[2]$,$a[3]$...$a[n]$,$a[n+1]$,$a[n+2]$...$a[m]$　
    
　　显然$m=2n-1$;
  
　我们对这一串珠子$dp$一次即可得解；$dp$方程为：
 
　　　$Best=max${$Q[i,i+n-1]$ $1<=i<=n$}
   
　　 $Q[i,j]$=$max${$Q[i,k]+Q[k+1,j]+top*wei[k]*wei[j]$ 
   
   {$1<=i<=k<j<=min(i+n-1,m)$}
    
　　其中$Q[i,i]=0$ $1<=i<=m$;
  
　　显然时间复杂度为O($n^3$)，空间为O($n^2$)。$min(i+n-1,m)$已经对$dp$进行了优化。
  


---

## 作者：Seauy (赞：11)

## 居然没有人发记忆化搜索的
那就让我来提供一下记忆化搜索的写法

大家都知道，记忆化搜索跟动态规划是很有共性的，有的时候你可以先乱蒙一个搜索，再加一个记忆化，然后动归递推式就变得十分显然了

~~实际上我大部分区间DP的式子都是这么写出来的~~

------------

由于题目的处理对象比较特殊，是个环，环我们不太好处理

于是考虑把环变成链进行处理，总结下来，一共有两种方法：

1. 一刀切将环破成链
2. 向链的右方再接上一段一样的链

对于这道题而言，两种方法都行，其它题解也都涵盖这两种类型

破成链了之后就比较容易操作了，对于链再进行分割

于是搜索就可以写出来了，再加上记忆化就OK了

------------

题目给的获得能量的顺序是合并而成的，而搜索则可以看成是合并的逆操作——分裂

而以拆分环的顺序来计算结果在此题是不影响答案的

于是枚举对于环的所有分裂方案，求出最优解

------------


[ ~~ccf 用的是老年评测机~~，由于计算机处理递归语句的时候效率会非常的低，所以考试的时候尽量还是写成递推形式较保险，即使你在各大OJ上华丽地 AC 了 ]

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,val[101];
int dp[101][101],ans;

//环处理
int Next(int ob)//环的下一个元素
{
	if(ob==n) return 1;
	return ob+1;
}

int Last(int ob)//上一个元素
{
	if(ob==1) return n;
	return ob-1;
}

int DFS(int L,int R)
{
	if(dp[L][R]) return dp[L][R];//算过了就直接返回记录过的结果
	int cnt=0;
	for(int i=L;i!=R;i=Next(i))//枚举合并点
		cnt=max(cnt,DFS(L,i)+DFS(Next(i),R)+val[L]*val[Next(i)]*val[Next(R)]);
        //左珠子能量+右珠子能量+合并获得的能量
	return dp[L][R]=cnt;//记忆化记录答案
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&val[i]);
	for(int i=1;i<=n;i++) ans=max(ans,DFS(i,Last(i)));//破环成链
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：YCW13983841648 (赞：7)

这道题就是区间动态规划的一道超级~水~模版的一道题。与[这道题](https://www.luogu.com.cn/problem/P1880)几乎一模一样。

**思路**：

1. 区间动态规划数组定义：就简单粗暴， $dp_{i,j}$ 表示区间 $[i，j)$ 中最大能量释放值。**注意**，区间是**左闭右开**。

2. 确定区间分段。**没有特殊限制**，时间复杂度**允许**。
循环 $K$ （区间 $[i,j)$ , $i<k<j$ ）。
3. 状态转移方程。已知区间 $[i,j)$ ，断点 $k$ 。求 $dp[i][j]$ 。
首先， $dp_{i,k}$ 与 $dp_{k,j}$ 合并。最后再加上断点左右的区间最大能量释放值就行了，即  $dp_{i,k}$ 与 $dp_{k,j}$ 的和。
由题意，有以下计算代码：

```cpp
int yh(int m,int r,int n){
	return m*r*n;
}//r,断点。m,区间[i,j)的i。n,区间[i.j)的j。
```
完整代码：


```cpp
#include<bits/stdc++.h>
#define int long long
#include<iostream>
#define unsigned long long ull
using namespace std;
int yh(int m,int r,int n){
	return m*r*n;
}
const int N=210;
int a[N];
int dp[N][N];
int n;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];//环形，数组按照a[1]，……，a[n],a[1],……,a[n]存
	}
	n*=2;//环形，长度乘2。
	for(int len=2;len<=n;len++){//当前序列长度
		for(int i=1;i<=n-len+1;i++){//当前序列开头
			int j=i+len-1;//当前序列结尾
			for(int k=i+1;k<j;k++){//枚举断点
				dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+yh(a[i],a[k],a[j]));//状态转移
			}
		}
	}
	cout<<dp[1][n]/2;//n乘了2的，要除回去，或者循环在1~n,2~n+1,3~n+2……里面找最大值
	return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

经典区间动态规划。

环不好解决，先断环为链，即把原数组复制一遍接在后面。

设 $f_{l, r}$ 表示 $l$ 到 $r$ 区间的最大能量，考虑转移。因为 $l$ 到 $r$ 这个区间一定是由两个小区间合并的到，所以我们按区间长度从小到大转移，对于每个大区间枚举中间点 $k$，两个小区间就是 $l$ 到 $k$ 和 $k+1$ 到 $r$，那么这个大区间的能量就等于两个小区间的能量和加上两个区间合并得到的能量，即 $f_{l, r}=\max(f_{l, k}+f_{k+1, r}+a_l \times a_{k+1} \times a_r)$，其中 $l \le k < r$。

答案就是所有长度为 $n$ 的区间最大能量的最大值。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans, a[205], f[205][205];
int main(){
	cin >> n;
	for (int i=1; i<=n; a[i+n]=a[i], ++i)
		cin >> a[i];
	for (int len=2; len<=n*2; ++len) 
		for (int l=1, r=l+len-1; l+len-1<=n*2; ++l, ++r) 
			for (int k=l; k<r; ++k) 
				f[l][r]=max(f[l][r], f[l][k]+f[k+1][r]+a[l]*a[k+1]*a[r+1]);
	for (int i=1; i<=n; ++i)
		ans=max(ans, f[i][i+n-1]);
	cout << ans;
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：3)

# P1063 [NOIP2006 提高组] 能量项链 题解  
显然区间 dp，可以直接入手看一下转移方式。  
### 解题思路
由于本题数据是一个**环形**，解决方法就是把数组复制一遍，这样如 4 号就能直接拿到 1（5），的数据并转移方程。  
对于区间 dp，一般而言都有形如：  
$dp_{i,j}=\max_{k=i+1}^{j-1}dp_{i,k}+dp_{k,j}+w_{i,k,j}$ 的转移方程。  
其中 $w_{i,k,j}$ 表示为该次操作的价值。  
在本题中，有显然 $w_{i,k,j}=a_i \times a_k \times a_j$。  
注意由于初始选取点随机，所以推完之后要再线性扫一遍最大值，才能找到最大答案。  
还有由于本题是环形，且它的数据很特殊，叫做头标记和尾标记，最后扫到最后一个的尾标记就是自己的头标记，所以事实上，dp 的 $len$ 要推到 $n+1$。
### AC 代码

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
int n;
ll a[205];
ll dp[205][205];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[n+i]=a[i];
    }
    for(int len=3;len<=n+1;len++){
        for(int l=1;l+len-1<=2*n;l++){
            ll r=l+len-1;
            for(int k=l+1;k<r;k++){
                dp[l][r]=max(dp[l][r],dp[l][k]+dp[k][r]+a[l]*a[k]*a[r]);
            }
        }
    }
    ll ma=0;
    for(int i=1;i<=n;i++){
        ma=max(ma,dp[i][i+n]);
    }
    cout<<ma;
}
```

---

## 作者：Tomwsc (赞：3)

# P1063 [NOIP2006 提高组] 能量项链题解

## 解法

一道区间 dp 的板子题。

### 区间 dp

何为区间 dp？顾名思义，就是在区间上 dp，通过求得几段小区间的解然后进行合并而得到大区间的解。

现在我们来分析一下，为什么该题可以用区间 dp。

- **最优子结构**：我们可以将这道题分成有限个**子问题**，然后通过求得子问题的最优解可以得到原问题的最优解。
- **无后效性**：我们只需要求得释放的最大值，并不需要知道是**怎么合并**的。
- **区间特性**：我们需要求得整个大区间的解，同时，我们可以将大区间分割成多个小区间，然后通过计算合并小区间会释放的能量来算出大区间的解。

对于区间 dp 的题目，我们一般都会设 $dp[i][j]$ 表示合并第 $i$ 号到第 $j$ 号区间所花费的价值。

现在我们来推转移方程：

对于一个大区间 $dp[i][j]$ 我们需要将这个区间拆分成两个小区间进行合并，那究竟是哪两个小区间？这需要我们循环去枚举 $i$ 和 $j$ 中间可以进行合并的点，从而得到最值。

即：$dp[i][j]=\min(dp[i][j] , dp[i][k] + dp[k][j] + val)$

其中 $val$ 表示合并两个区间所需要的花费，或者可以理解成贡献。

当然，不一定是取最小值，比如这道题。

## 代码

回到题目本身，由于这串数是一个环，所以我们可以将这串数补成 $2\times n$ 个数，这样便相当于把环给割了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 205;
int n;
int a[MAXN];
int dp[MAXN][MAXN];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(register int i = 1;i <= n;i ++)
		cin >> a[i];
	for(register int i = n + 1;i <= n * 2;i ++)
		a[i] = a[i - n];
	for(register int i = 1;i <= n;i ++)
		dp[i][i] = 0;
	int maxn = INT_MIN;
	for(register int len = 2;len <= n + 1;len ++)
		for(register int i = 1;i + len - 1 <= 2 * n;i ++) {
			int j = i + len - 1;
			for(register int k = i + 1;k < j;k ++)
				dp[i][j] = max(dp[i][j] , dp[i][k] + dp[k][j] + a[i] * a[k] * a[j]);
			maxn = max(maxn , dp[i][j]);
		}
	cout << maxn;
	return 0;
}
```

---

## 作者：suzhikz (赞：2)

首先考虑对于一个区间求解。

对于一个大区间，我们先想想他的最后一步。

此时场上一定只有两个球，所以头和尾两个权值一定是固定的，那么我们是不是可以直接枚举下中间的权值（即枚举断开的位置），就可以把问题分裂成两个更小的子问题，是不是很眼熟？

这玩意可以直接拿区间 dp 做，时间复杂度 $O(n^3)$。

假设 $dp_{l,r}$ 为 $l$ 到 $r$ 合并的最大值，$a_i$ 表示第 $i$ 位头的权值，那么有 $dp_{l,r}=max(dp_{l,i}+dp_{i+1,r}+a_l*a_{i+1}*a_{r+1})$。

---

## 作者：DengDuck (赞：2)

转换一下题意，每次可以删除一个元素，然后你会得到这个元素和他的前后元素权值的积。

环比较不当人，考虑破环为链。

注意到每次算贡献的时候，前后元素和我在编号上不是连续的，所以我们考虑倒过来做，就是从最后一个删除的元素开始统计，从后往前删。

我们枚举最后剩下哪两个元素，那么我们知道最后剩下哪两个元素之后，环断成了以这两个元素为端点的两条链，这样我们就可以对链区间 DP 了。

我们设 $F_{L,R}$ 表示区间 $[L,R]$ 之中，我们删到最后只剩下 $L,R$ 的最优方案。

我们对于一个区间，枚举最后一个被删除的元素，那么区间又会断为两部分，得到转移：

$$
F_{L,R}=\max_{i\in[L+1,R-1]}F_{L,i}+F_{i,R}+A_L\times A_i\times A_R
$$

直接做就可以了。


```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
const int N=205;
int n;
LL F[N][N],Ans,A[N];
LL Dfs(LL L,LL R)
{
	if(R-L+1<=2)return 0;
	if(F[L][R])return F[L][R];
	for(int i=L+1;i<R;i++) 
	{
		F[L][R]=max(F[L][R],Dfs(L,i)+Dfs(i,R)+1ll*A[L]*A[i]*A[R]);
	}	
	return F[L][R];	
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>A[i],A[i+n]=A[i];
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=i+n-1;j++)
	{
		Ans=max(Ans,Dfs(i,j)+Dfs(j,i+n)+1LL*A[i]*A[j]*A[i]);
	}
	cout<<Ans<<endl;
}
```

---

## 作者：WsW_ (赞：2)

### 思路
经典区间动态规划题。  
由于原问题是个环，我们要先断换为链，具体来说就是把序列复制一遍接在后面。  
容易发现，经过若干次聚合之后，一个连续区间内的几个珠子会被聚合成一个珠子。最终的这个珠子的头标记是区间第一个珠子的头标记，尾标记是区间最后一个珠子的尾标记。  
所以知道区间就能知道最终珠子的状态，和这个区间内聚合的顺序**无关**。聚合的顺序只影响释放的能量。  
由于状态和顺序无关，答案和顺序有关，所以满足最优子结构性质且无后效性。考虑使用动态规划解决这个问题。  
由于长区间必定从若干个短区间转移过来，所以区间长度是阶段。显然具体是哪个区间就是状态。  

对于一段区间 $l\sim r$，由于它是从两个珠子合并过来的，这两个区间一定是 $l\sim t,t+1\sim r$。每次转移的时候枚举这个中间点 $t$ 即可。  
状态转移方程为 $dp_{l,r}=\max\limits_{l\le t<r}{(dp_{l,t}+dp_{t+1,r}+a_l\times a_{t+1}\times a_{r+1})}$。  

时间复杂度为 $O(N^3)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int ans;
int a[203];
int dp[203][203];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i+n]=a[i];
	}
	for(int len=2;len<=n;len++){
		for(int l=1;l+len<=(n<<1);l++){
			int r=l+len-1;
			for(int t=l;t<r;t++){
				dp[l][r]=max(dp[l][r],dp[l][t]+dp[t+1][r]+a[l]*a[t+1]*a[r+1]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,dp[i][i+n-1]);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Gaochenxi103_QWQ (赞：1)

## 题目分析
> 给定一个**头尾相接**数组，每个数为一个拥有两个参数的二元组 $m$ 和 $n$，其中满足 $m_i=n_{i-1}$，将相邻的两个数合并，会产生 $m_{i-1}*m_{i}*n_{i}$ 的能量。并且新数的 $m=m_{i-1}$，$n=n_i$。问最大产生能量。

## 解题思路
明显的区间合并问题求最值，考虑区间合并动态规划。
### 状态定义
先不考虑环。  
因为将环的值复制一遍，即可。
因为对于一个区间 $[i,j]$ 如果 $i>j$ 说明是绕了一个环。
如果复制一遍则定存在一个区间 $[i,j+n]$ 等价$[i,j]$。

区间合并强调的是区间，所以状态应该是 $dp[i][j]$ 就是合并 $[i,j]$ 之间的珠子获得的最大能量。

### 转移方程
因为是区间合并问题，所以考虑从 $[i,j]$ 的区间转移，即枚举 $[i,k]$ 和 $[k,j]$ 的合并产生的最值。

$dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+w[i].m\times w[k].n\times w[j].n)$。

### 转移顺序
因为是区间合并，所以转移顺序应该是从小到大转移。

### 答案
因为我们将数组复制一遍从而短环成链，所以答案就是枚举从不同区间开始合并的最大值。

## 注释代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct S{
	int fi,sc;
}w[550];
int n,dp[550][550],cnt;
/* 
本题存在环。注意本题不需要按照顺时针的方式合并 

容易想到状态定义dp[i][j]
合并[i,j]区间的产生最大能量,以i为开头 

每次转移类似于将目标合并区间分[i,j]割成[i,k]和[k,j] 
dp[i][j]={dp[i][j-k]+dp[k][j]+w[i].first*w[k].second*w[j].second}

存在环，所以将环的值复制一遍，即可，
因为对于一个区间[i,j]如果i>j说明是绕了一个环
如果复制一遍则定存在一个区间[i,j+n]等价[i,j]
*/
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>cnt,w[i].fi=w[i+n].fi=w[i-1].sc=w[i+n-1].sc=cnt;
	for(int l=2;l<=n;l++)//长度 
	{
		for(int i=1;i+l-1<=2*n;i++)
		{
			int j=i+l-1;
			for(int k=i;k<j;k++)
			{
				dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+w[i].fi*w[k].sc*w[j].sc);
			}
//			cout<<dp[i][j]<<" "; 
		}
//		cout<<"\n"; 
	}
	int ans=-1;
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,dp[i][i+n-1]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：2023z (赞：1)

### 思路

我们可以用区间 dp 来写。我们用 $ dp_{i,j} $ 表示以 $ i $ 开头 $ j $ 结尾的最大能量。

### 转移方程

 $ dp_{i,j}=\max(dp_{i,j},dp_{i,k}+dp_{k,j}+a_i\times a_j\times a_k) $ 

区间 $ \begin{bmatrix} i , j \end{bmatrix} $ 被 $ k $ 分成左子区间和右子区间，左子区间和右子区间加上前一颗能量珠的头乘后一颗能量珠的尾乘后一颗能量珠的头，再和原来的最大值作比较，更新答案。注意这是环形问题，$ i $ 要循环到 $ 2\times n $。

#### code：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int a[1100];
int dp[1010][1010];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[n+i]=a[i];
	} //输入
	int ans=0; //ans 最大值
	for(int l=2;l<=n+1;l++){
		for(int i=1;i+l-1<=n*2;i++){ //循环到 n*2
			int j=i+l-1; //算出结尾
			for(int k=i+1;k<=l+i-2;k++){
				dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+a[i]*a[j]*a[k]);
				ans=max(ans,dp[i][j]); //更新答案
			}
		}
	}
	cout<<ans; //输出
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/199104368)

完结撒花！！！

---

## 作者：NewbieZZZ (赞：1)

很经典~~模板~~的一道区间 dp。

### 建议

完成下列题目：

- [石子合并（弱化版）](https://www.luogu.com.cn/problem/P1775)——区间 dp 入门
- [\[NOI1995\] 石子合并](https://www.luogu.com.cn/problem/P1880)——断环为链

### 解法

首先，环形不好处理，我们把数组复制一份出来，放在原数组后边。记住，这时候千万别忘了开二倍空间！

既然是区间 dp，重点就是将整体划分为区间，小区间之间合并获得大区间。

那么我们设 $dp_{l,r}$ 表示区间 $[l, r]$ 中合并到的最大能量。

---

我们一般见到的区间 dp 转移方程类似于这样：（其中 $i,j$ 为枚举的区间端点，$k$ 为区间 $[i,j]$ 的一个分割点）

$$f_{i,j}=\max\left(f_{i,j}, f_{i,k}+f_{k,j}+\text{价值} \right)$$

即当前状态等于：不合并的价值或左子区间、右子区间和两个区间合并的价值的最大值。

而在此题中，我们需要的“价值”即为两个区间珠子合并得到的价值。

回到题目，我们发现两个珠子（最简单的两个区间）的能量即为左边珠子、右边珠子、右边珠子的下一个珠子之积。

我们可以类比两颗珠子的情况，直接得到两个区间中的珠子合并后的价值：即左区间的第一颗珠子、右区间第一颗珠子、大区间后的一颗珠子之积。

即：
$$f_{i,j} = \max\left(f_{i,j}, f_{i,k} + f_{k,j} + a_i \cdot a_{k+1} \cdot a_{j+1} \right)$$

要得到答案，我们在转移结束后枚举所有起点，取最大值即可。

### 代码

```cpp
#include <bits/extc++.h>
using namespace std;

int a[233], n, dp[233][233], maxx=0;
// dp[i][j] 表示 [l,r] 合并的最大价值

int main(){
    cin >> n;
    for(int i=1; i<=n; ++i){
        cin >> a[i];
        a[i+n] = a[i];
    }
    for(int len=2; len<=n; ++len){
        for(int i=1; len+i-1 < 2*n; ++i){
            int j = len+i-1;
            for(int k=i; k<j; ++k){
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + a[i] * a[j+1] * a[k+1]);
            }
        }
    }
    for(int i=1; i<=n; ++i){
        maxx = max(dp[i][i+n-1], maxx);
    }
    cout << maxx;
    return 0;
}
```

时间复杂度 $\Theta(n^3)$。表达或解法问题还请大佬指明高见。

End.

---

## 作者：LiJunze0501 (赞：1)

一道区间 DP 题目。
# 状态表示
$dp_{l,r}$ 表示的是 $[l,r]$ 区间的最大总能量。
# 转移方程
$dp_{l,r}=\min(dp_{l,r},dp_{l,k}+dp_{k,r}+m_l\times m_k\times m_r)$  
十分好理解，题目描述得很清楚。  
区间 $[l,r]$ 被 $k$ 分为左右两个区间，左区间和右区间加起来，再加上左端点值乘右端点值乘分割点值这就是合并的能量，把它和原来的区间能量做比较，更新为较大者。
# 最终目标
输出所有以 $i$ 为起点的长度为 $n$ 的区间 $[i,n+i]$ 的总能量的最大值，即 $\max_{i=1}^{n} dp_{i,n+i}$。   
# 区间 DP 部分
套模板
```cpp
for(int len=3;len<=n+1;len++)
	for(int l=1;l+len-1<=2*n;l++){
		int r=l+len-1;
		dp[l][r]=0;
		for(int k=l+1;k<r;k++) dp[l][r]=max(dp[l][r],dp[l][k]+dp[k][r]+m[l]*m[k]*m[r]);
	}
```
## 温馨提示
首尾连接哦，所以就会出现以下几种情况：
$$ E=\max\begin{cases}
  dp_{1,n+1}\\
  dp_{2,n+2}\\
  dp_{3,n+3}\\
  \cdots \cdots\\
  dp_{n-1,2n-1}\\
  dp_{n,2n}
\end{cases}$$
那么数组就要开两倍。  
输入的时候就要将 $m_{i+n}$ 赋值为 $m_i$。
# AC Code
```cpp 
#include<bits/stdc++.h>
using namespace std;
int dp[201][201],m[201],ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>m[i];
		m[i+n]=m[i];
	}
	for(int len=3;len<=n+1;len++)
		for(int l=1;l+len-1<=2*n;l++){
			int r=l+len-1;
			dp[l][r]=0;
			for(int k=l+1;k<r;k++) dp[l][r]=max(dp[l][r],dp[l][k]+dp[k][r]+m[l]*m[k]*m[r]);
		}
	for(int i=1;n+i<=2*n;i++) ans=max(dp[i][n+i],ans);
	cout<<ans<<endl;
} 
```

---

## 作者：Cold_Eyes_bystander (赞：1)

考虑区间动态规划。

先思考，如果这是一条链该怎么做，当然是[区间动态规划](https://blog.csdn.net/Ronaldo7_ZYB/article/details/81087952)统计每一个区间。

（补充）区间动态规划的原理是多个区间的合并，交融，大区间选取最好的两个区间构成完整的自己。

但这题中有环该怎么办，怎么才能使用区间动态规划呢？当然是断环为链，我们统计每一处断开后的最大值，在统计他们的最大值就行了。

补充：我们只需要再复制一遍数组中的元素，统计时查询每一处长度为 $n$ 的区间。

```c++
#include <bits/stdc++.h>
using namespace std;
int a[201];
int dp[201][201];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        a[i+n]=a[i];
    }
    for(int i=2;i<=n+1;i++)
    {
        for(int l=1;l+i-1<=n*2;l++)
        {
            int r=l+i-1;
            for(int k=l+1;k<=r-1;k++)
            {
                dp[l][r]=max(dp[l][r],dp[l][k]+dp[k][r]+a[l]*a[k]*a[r]);
            }
        }
    }
    int maxn=-1;
    for(int i=1;i<=n;i++)
    {
        maxn=max(maxn,dp[i][i+n]);
    }
    cout<<maxn;
    return 0;
}
```

---

## 作者：chinazhanghaoxun (赞：1)

## 思路
很显然是一道区间 dp 题目，几乎是一道模版题。

为了达到题目中所说的首尾相连的目的，首先要断环为链，只需要将整个珠子序列复制一份即可。

然后相当于对于一个长度为 $n$ 的区间，求这段区间合并后得到的最大能量。

设 $dp[l][r]$ 表示把区间 $[l,r]$ 合并起来能得到的最大能量，转移十分类似于[石子合并](https://www.luogu.com.cn/problem/P1880)，两题都是环形上的区间 dp。
## 转移方程
转移方程很好推出，其实就是在两个珠子中间插入一个 $k$，循环模拟 $l\le k\le r$，设第 $i$ 颗珠子的头标记为 $A_i$，可得：
$$
dp[l][r]=\max (dp[l][k]+dp[k][r]+A_l\times A_k \times A_r)
$$
复杂度是 $O(n^3)$，最终答案就是最大的 $dp[i][i+n]$，也就是任选开头的一段长度为 $n$ 的最大能量。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[205][205],a[205];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i]; //断环为链，复制一遍
	}
	for(int len=1;len<=n;len++){
		for(int l=1;l<=2*n;l++){
			int r=l+len-1;
			if(r>2*n){ //右端越界
				break;
			}
			if(len==1){
				dp[l][r]=0;
			}
			for(int k=l;k<r;k++){
				dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]+a[l]*a[k+1]*a[r+1]);//转移方程
			} 
		}
	}
	int ans=-10000;
	for(int i=1;i<=n;i++){ //求出最大能量
		ans=max(ans,dp[i][i+n-1]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：kunkun127 (赞：1)

## 思路

本题就是区间 DP 的入门练习题。掌握了区间 DP 和破环成链的重要思想即可摸透此题。

- 题意概括

  其实题面有点令人捉摸不透（~~因为我太蒟蒻~~），那么我来概括一下：

  意思就是一个环，环上每个点都有点权。能合并两个相邻的点，得到的贡献是两点点权的乘积，再乘上靠后点的下一个点点权，合并出来的新点的点权是靠前点的点权。要求的是最大贡献是多少。

- 破环成链

  很简单，我们只需要令 $a_{i+n} = a_i$ 即可。这样做可以使原有的链延长为原来的两倍，即可满足题意。

- DP

  令 $f_{l,r}$ 表示合并 $l$ 和 $r$ 得到的最大贡献。

  根据题意，我们可以看划分多少个珠子在一区间的不同情况。

  - 区间包含 $3$ 个珠子，可以是左边单个珠子的区间加上右边两个珠子的区间；或者左边两珠子的区间右边加上单个珠子的区间。就是先合并两个珠子的区间，再加上单个珠子区间的能量。
    
  - 继续推下去，再结合题目所给计算公式，就可以得到转移方程：
 
    $$f_{l,r} = \max(f_{l,r}, f_{l,j} + f_{j,r} + a_l \times a_j \times a_r)$$

## 注意事项

- 破环成链时空间到了 $2 \times n$，**记得将数组也开到这么大**！

## 参考代码


```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;

int a[210], dp[210][210];

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) 
	{
		cin >> a[i];
		a[i + n] = a[i];
	}
	for (int i = 2; i <= n + 1; i++)
	{
		for (int l = 1; l <= n * 2 - i + 1; l++)
		{
			int r = l + i - 1;
			for (int j = l + 1; j < r; j++)
			{
				dp[l][r] = max(dp[l][r], dp[l][j] + dp[j][r] + a[l] * a[j] * a[r]);
			}
		}
	}
	int res = 0;
	for (int i = 1; i <= n; i++) res = max(res, dp[i][n + i]);
	cout << res << endl;
	return 0;
}

```

同时，想要深入学习区间 DP 的读者，可进入[OI-WIKI](https://oi-wiki.org/dp/interval/)进行学习。

---

## 作者：HHC883 (赞：0)

# 题目分析
首先，破环成链。

然后，发现可以用区间 DP 解决。记 $dp_{i,j}$ 表示将第 $i$ 到第 $j$ 颗珠子合并成一颗珠子所能释放的最大能量，那么有状态转移方程

$$dp_{i,j} = max(dp_{i,j} , dp_{i,k} + dp_{k+1,j} + a_i \times a_{k+1} \times a_{j+1}) , i \le k < j$$

最后取所有 $dp_{i,i + n - 1}$ 的最大值即可。

时间复杂度为 $O(n^3)$。
# 参考代码
```cpp
#include<iostream>
using namespace std;
int n,a[205],dp[205][205],ans;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) a[i+n]=a[i];
	for(int len=1;len<=2*n;len++){
		for(int i=1;i+len-1<=2*n;i++){
			int j=i+len-1;
			for(int k=i;k<j;k++){
				dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+a[i]*a[k+1]*a[j+1]);
			}
		}
	}
	for(int i=1;i<=n;i++) ans=max(ans,dp[i][i+n-1]);
	cout<<ans;
	return 0;
}
```

---

## 作者：yuxinrui0618 (赞：0)

# 题解：P1063 [NOIP2006 提高组] 能量项链
## 1. 题目大意
- 给定一列数，相邻两数可以合并，并同时释放出能量，但不同合并方式所获得的能量不同；
- 设计一个聚合顺序，使这串数释放出的总能量最大。

## 2. 思路
- 很明显，这是一道递推题；
- 首先，先解决第一个问题：项链是首尾连接的，那要如何处理？其实，解决方法很简单，只要把数组复制一份即可；
- 其次，用 $f_{l,r}$ 表示从第 $l$ 个到第 $r$ 个的数串释放出的能量的最大值，而 $k$ 表示其间的某一数，则 $f_{l,r}$ 取原来最大值和 $f_{k,r}+a_{l} \times a_{k} \times a_{r}$ 中更大的那个。

## 3. 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[405][405];
int n,a[205]; 
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>a[i];
        a[n+i]=a[i]; //复制一份
    } 
    for (int i=2;i<=n+1;i++) //长度
        for (int l=1;l+i-1<=2*n;l++) //这里注意要循环到2n
        {
            int r=l+i-1; //计算终点
            for (int k=l+1;k<=l+i-2;k++)
                f[l][r]=max(f[l][r],f[l][k]+f[k][r]+a[l]*a[k]*a[r]); 
        }
    int ans=0;
    for (int i=1;i<=n;i++) ans=max(ans,f[i][n+i]); //枚举所有起点，取最大值
    cout<<ans;
    return 0;
}
```

## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：chenyyy (赞：0)

# P1063 [NOIP2006 提高组] 能量项链
## [题目传送门](https://www.luogu.com.cn/problem/P1063)
## 解法
区间 dp 的板子题。
### 区间 dp
区间 dp 的动态转移方程一般是这样的：
$$dp[i][j] = \max(dp[i][k] + dp[k][j] + val)$$
 
其中 $val$ 表示 $i$ 到 $k$ 和 $k$ 到 $j$ 的贡献值，而 $k$ 是区间 $i-j$ 的一个划分点。

### 题目
回到题目，我们发现 $val$ 就是 $a_i\times a_k\times a_j$。

于是，动态转移方程就出来了：$dp[i][j] = \max(dp[i][k] + dp[k][j] + a_i\times a_k\times a_j)$。

由于原题是环形的，所以我们可以将 $a$ 数组复制一份，并将 $n \times 2$，以便求解。
## coding
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[201],dp[201][201],maxn = -1;//初始值maxn为-1，以便后续求最大值。
signed main(){
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		a[i + n] = a[i];//将a数组变成原来的两倍，比如原来是1、2、3、4，变成1、2、3、4、1、2、3、4。
	}
	n *= 2;//因为数组变长了，所以n也要变。
	for(int i = 2;i < n;i++){
		for(int j = i - 1;j >= 1;j--){
			for(int k = j;k < i;k++){//划分点
				dp[j][i] = max(dp[j][i],dp[j][k] + dp[k + 1][i] + a[j] * a[k + 1] * a[i + 1]);//k前面原本的能量值+k后面原本的能量值+合并后的能量值。
				if(dp[j][i] > maxn)maxn = dp[j][i];//求最大值。
			}
		}
	}
	cout << maxn / 2;//因为n乘了2所以输出时要除2。
	return 0;
}
```

---

## 作者：Ngo123 (赞：0)

### 区间动态规划问题
本题和**环形石子合并**问题类似，只不过**环形石子合并**问题只有一个参数，而本题有头标记和尾标记两种参数。

但解决的思路是相同的，我们只需要改变处理问题的细节。

首先是准备工作：对于**环形问题**，我们要先**破环城链**，也就是把数组重新赋值一份。

定义状态为 $f_{i,j}$ 表示当前合并的项链区间中，左端点为项链 $i$，右端点为项链 $j$ 的最大总能量值。

根据我们定义的状态，初始化对于所有的 $i$，$f_{i,i+1} = 0$。

状态转移为 $f_{i,j}= \max (f_{i,j},f_{i,k}+f_{k,j}+a_{i} \times a_{k} \times a_{j})$，$(l+1 \le k < r)$。

由于是**环形**，因此起点和终点可以是任意地方，因此我们遍历所有起点，取最大值即可。

本题是三重循环，时间复杂度为 $O(n^3)$。

以下是我的代码：
```
#include<iostream>
using namespace std;
const int N = 205;
int a[N],f[N][N],n,ans;
int main()
{
    cin>>n;
    for(int i = 1;i<=n;i++)
    {
        cin>>a[i];
        a[i+n] = a[i];
    }
    for(int len = 3;len<=n+1;len++)
        for(int l = 1;l+len-1<=2*n;l++)
        {
            int r = l+len-1;
            for(int k = l+1;k<r;k++)
                f[l][r] = max(f[l][r],f[l][k]+f[k][r]+a[l]*a[k]*a[r]);
        }
    for(int i = 1;i<=n;i++) ans = max(ans,f[i][i+n]);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Lfz312g (赞：0)

# Solution
## 题目分析
此题与 [P1880](https://www.luogu.com.cn/problem/P1880) 完全相似，都是小区间合并成大区间的过程，可以使用区间动态规划解决。  
由于本题的序列成环形，所以可以破环成链，把原数组复制一遍，但是这样在后面的转移过程中，序列长度就应该是 $2 \times n$ 而不是 $n$，最后枚举以每一个元素开头，长度为 $n$ 的区间，取最大值即可。   
定义 $f(i,j)$ 为区间 $[i,j]$ 的珠子合并到一起的最大值。      
状态转移方程：  

$$  
f(i,j)=\max \left\{ f(i,k)+f(k+1,j)+cost \right\}
$$    
其中在本题中 $cost=a_{k+1} \times a_{j+1} \times a_i$。   
要想更新 $f(i,j)$，需要知道 $f(i,k)$ 和 $f(k+1,j)$ 的值，即更新大区间需要小区间的值，所以从小到大枚举区间长度 $len$ 作为最外层循环，然后枚举起始点 $i$，结束点 $j=i+len-1$，最后枚举分割点 $k$ 即可。  
初始化：自己与自己不用合并，$f(i,i)=0$。  
时间复杂度：$O(n^3)$。  

```cpp
#include <bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
int a[605],f[605][605];
int main()
{
	int n;
	cin>>n;
	ffor(i,1,n) cin>>a[i],a[i+n]=a[i];
	memset(f,-0x3f,sizeof(f));
	ffor(i,1,2*n) f[i][i]=0;
	ffor(len,2,n) ffor(i,1,2*n-len+1) {
		int j=i+len-1;
		ffor(k,1,j-1) f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+a[k+1]*a[j+1]*a[i]);
	}
	int mx=-INT_MAX;
	ffor(i,1,n) mx=max(mx,f[i][i+n-1]);
	cout<<mx;
	return 0;
}
```
动态规划有递推和递归两种写法，此题也可以使用记忆化搜索解决，做法和动态规划做法差异不大。  

```cpp
#include <bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
const int inf=0x3f3f3f3f;
int a[605],f[605][605],n;
int dfs(int l,int r)
{
	if (l==r) return 0;
	if (f[l][r]!=-inf) return f[l][r];
	ffor(k,l,r-1) f[l][r]=max(f[l][r],dfs(l,k)+dfs(k+1,r)+a[k+1]*a[r+1]*a[l]);
	return f[l][r];
}
int main()
{
	cin>>n;
	ffor(i,0,2*n) ffor(j,0,2*n) f[i][j]=-inf;
	ffor(i,1,n) cin>>a[i],a[i+n]=a[i];
	int mx=-inf;
	ffor(i,1,n) mx=max(mx,dfs(i,i+n-1));
	cout<<mx;
	return 0;
}
```

---

## 作者：sjh0626 (赞：0)

## 思路分析
标准的环形区间动规。

首先我们要知道区间动规如何实现。

区间动规的思路就是枚举一个区间的长度和这个区间的起点 $i$ 与中间点 $k$，对于起点 $i$ 与终点 $j$ 的动态转移方程就是：

$dp[i][j]=\max(dp[i][j],dp[i][k]+dp[k+1][j]+a[i] \times a[k+1] \times a[j+1])$。

因为这是一个环形，所以我们要开两倍的空间去存储。

取最大值就是 $\max(dp[1][n],dp[2][n+1],\dots,dp[n][2\times n-1])$。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
long long a[305],s[305],dp[305][305],dp2[305][305],n,ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(int len=2;len<=n;len++){ //枚举长度 
		for(int i=1;i+len-1<=2*n-1;i++){ //枚举起点 
			int j=i+len-1;
			for(int k=i;k<j;k++){ //枚举中点 
				dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+a[i]*a[k+1]*a[j+1]); //状态转移方程 
			}
		}
	}
	for(int i=1;i<=n;i++)ans=max(ans,dp[i][i+n-1]);
	cout<<ans;
	sjh0626s code;
}
```

---


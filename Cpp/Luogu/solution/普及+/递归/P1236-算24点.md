# 算24点

## 题目描述

几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。

您可以使用的运算只有：$\verb!+!,\verb!-!,\verb!*!,\verb!/!$，您还可以使用 $\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\ \times 2)/4$ 是合法的，$2\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：

若给出的 $4$ 个操作数是：$1$ 、 $2$ 、 $3$ 、 $7$，则一种可能的解答是 $1+2+3\ \times 7=24$。

## 说明/提示

感谢 chenyy 提供 special judge

---

$\text{upd 2022.8.1}$：新增加一组 Hack 数据。


## 样例 #1

### 输入

```
1 2 3 7
```

### 输出

```
2+1=3
7*3=21
21+3=24
```

# 题解

## 作者：razx (赞：108)

目前来说应该是最短（42行）也是最简单的代码，别跟我说压行

方法是使用STL里的next_permutation枚举所有的全排列，而每一种排列分五种情况讨论：

1.((a?b)?c)?d

2.(a?(b?c))?d

3.a?((b?c)?d)

4.(a?b)?(c?d)

5.a?(b?(c?d))
但实际上只要1，4两种状态就可以判断了

```cpp

#include <bits/stdc++.h>
using namespace std;

int a[5];
char opt[5]= {' ','+','-','*','/'};

int F(int x,int k, int y)                                 
{
  if(k==1)
    return x+y;
  if(k==2)
    return max(x,y)-min(x,y);
  if(k==3)
    return x*y;
  return (y==0 || x<y || x%y!=0) ? -999999 : x/y;
}

void Out(int a,int b,int c,int d,int e,int f,int k1,int k2,int k3)
{
  printf("%d%c%d=%d\n",max(a,b),opt[k1],min(a,b),F(max(a,b),k1,min(a,b)));
  printf("%d%c%d=%d\n",max(c,d),opt[k2],min(c,d),F(max(c,d),k2,min(c,d)));
  printf("%d%c%d=%d\n",max(e,f),opt[k3],min(e,f),F(max(e,f),k3,min(e,f)));
  exit(0);                                                  //直接退出程序
}

int main()
{
  scanf("%d%d%d%d", &a[1],&a[2],&a[3],&a[4]);
  sort(a+1,a+5);                                            //保证遍历所有情况
  do
  {
    for (int i = 1; i <= 4; i++)                            //暴力枚举3个运算符
      for (int j = 1; j <= 4; j++)
        for (int k = 1; k <= 4; k++)
          if (F(F(F(a[1],i,a[2]),j,a[3]),k,a[4])==24)       //((a?b)?c)?d
            Out(a[1],a[2],F(a[1],i,a[2]),a[3],F(F(a[1],i,a[2]),j,a[3]),a[4],i,j,k);
          else if (F(F(a[1],i,a[2]),k,F(a[3],j,a[4])) == 24)//(a?b)?(c?d)
            Out(a[1],a[2],a[3],a[4],F(a[1],i,a[2]),F(a[3],j,a[4]),i,j,k);
  }  while (next_permutation(a + 1, a + 5));
  puts("No answer!");
  return 0;
}
```
DFS程序也可以，就不贴了


---

## 作者：stoorz (赞：51)

[$\color{blue}\texttt{Link:蒟蒻的Blog}$](https://blog.csdn.net/SSL_ZYC/article/details/88750950)

看到很多人的代码都被$hack$了。这里给出一种$100\%$不会被$hack$的方法。

~~至少现在所有看到的hack数据都可以过~~

大体的流程是这样的：

 1. 在所有可选数字中选择而已两个
 
 2. 枚举在这两个数字中选择什么运算符
 
 3. 求出结果并记录
 
 4. 把这两个数字删除，把结果扔到可以选择的数字中
 
 5. 回到1
 
这样的话，我们枚举了所有的选择情况，不会漏掉任何一个解。

时间复杂度$O(\Pi^{4}_{i=2}(C^{2}_{i}\times 4))$。反正非常小就是了。

代码丑的一批$qwq$

求$hack$

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;

int a[5],ans[4][4];
bool ok;

void print()  //输出
{
    for (int i=1;i<=3;i++)
    {
    	if (ans[i][1]<ans[i][3])
			swap(ans[i][1],ans[i][3]);  //注意题目中说两个数必须先输出大的再输出小的
        printf("%d",ans[i][1]);  //输出第一个数字
        if (ans[i][2]==1) printf("+");
        if (ans[i][2]==2) printf("-");
        if (ans[i][2]==3) printf("*");
        if (ans[i][2]==4) printf("/");  //输出运算符号
        printf("%d",ans[i][3]);
        if (ans[i][2]==1) printf("=%d\n",ans[i][1]+ans[i][3]);
        if (ans[i][2]==2) printf("=%d\n",ans[i][1]-ans[i][3]);
        if (ans[i][2]==3) printf("=%d\n",ans[i][1]*ans[i][3]);
        if (ans[i][2]==4) printf("=%d\n",ans[i][1]/ans[i][3]);  //输出结果
    }
}

bool check()  //判断是否组成了24
{
    for (int i=1;i<=4;i++)
        if (a[i]==24) return 1;
    return 0;
}

void dfs(int k)
{
    if (k==4)  //搜索完毕
    {
        if (check())
        {
            print();
            ok=1;
        }
        return;
    }
    int x,y;
    for (int i=1;i<=4;i++)
        for (int j=1;j<=4;j++)  //枚举两个数字
            if (i!=j&&a[i]>0&&a[j]>0)
            {
                ans[k][1]=a[i];  //加
                ans[k][2]=1;
                ans[k][3]=a[j];
                x=a[i],y=a[j];
                a[i]=x+y;
                a[j]=-1;
                dfs(k+1);
                a[i]=x;
                a[j]=y;
                if (ok) return;
                
                ans[k][1]=a[i];  //减
                ans[k][2]=2;
                ans[k][3]=a[j];
                x=a[i],y=a[j];
                a[i]=x-y;
                a[j]=-1;
                dfs(k+1);
                a[i]=x;
                a[j]=y;
                if (ok) return;
                
                ans[k][1]=a[i];  //乘
                ans[k][2]=3;
                ans[k][3]=a[j];
                x=a[i],y=a[j];
                a[i]=x*y;
                a[j]=-1;
                dfs(k+1);
                a[i]=x;
                a[j]=y;
                if (ok) return;
                
                if (a[j]>0&&a[i]%a[j]==0)  //除，注意要判断能否整除
                {
                    ans[k][1]=a[i];
                    ans[k][2]=4;
                    ans[k][3]=a[j];
                    x=a[i],y=a[j];
                    a[i]=x/y;
                    a[j]=-1;
                    dfs(k+1);
                    a[i]=x;
                    a[j]=y;
                    if (ok) return;
                }
            }
}

int main()
{
    scanf("%d%d%d%d",&a[1],&a[2],&a[3],&a[4]);
    dfs(1);
    if (!ok) cout<<"No answer!";
    return 0;
}

```


---

## 作者：ysner (赞：23)

看到前面题解只给了标程却没有给出易错的地方，我决定写篇题解来补充一下，顺便给几组自创数据来帮大家检验程序。

此题不需要优化，直接暴搜。

我的思路是从剩下的数中不断枚举2个数，一一尝试加减乘除四则运算。题目要求从较大数开始输出，我就要求运算时前一个量大于等于（一定要加“等于”！否则60分！）后一个量。然后将结果存在较大量中，并设较小量为已访问。跳过已访问的数，不断从第一个数搜到第四个数搞运算，顺便将运算符号和运算的两个量存起来。当只剩最后一个未访问数时，若其为24，输出即可。

思路很简单，但很多小细节，值得注意。

易错点：

1、当4个数中出现两个及以上相同数时，注意两数相同也可以进行运算，**但必须保证运算的两个量下标不同**。（get60分）

输入：2 2 2 4   输出：2+2=4  4+2=6  6\*4=24

2、运算中必须保证只有整除（无余数）。

3、得出的24可以在4个数中的任意一个（要把四个数全搜一遍）

4、运算中不能出现0和负数（特判解决）。

5、可能会出现两个数反复运算（即最后结果被设为已访问），此时特判最后结果未访问即可（get70分）。

6、必须保证24是最后一步算出来的（在运算出结果时判断，若为24则return，get100分）。

输入：1 2 4 6  输出:2-1=1  4\*1=4  6\*1=24

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
int a[4]={},vis[4]={},fh[4]={},a1[4]={},a2[4]={},f=0;//a用来存4个数，vis用来存该数是否访问过（参与运算过），fh存运算过程中的符号，a1存运算过程中的较大量，a2存较小量（运算结果可以不存）
void check()//判断+输出过程
{
  for(int i=0;i<4;i++)
    if(a[i]==24) {f=1;break;}
  if(f==1)
  {
    for(int i=0;i<3;i++)
    {
      cout<<a1[i];
      if(fh[i]==1) cout<<"+"<<a2[i]<<"="<<a1[i]+a2[i]<<endl;
      if(fh[i]==2) cout<<"-"<<a2[i]<<"="<<a1[i]-a2[i]<<endl;
      if(fh[i]==3) cout<<"*"<<a2[i]<<"="<<a1[i]*a2[i]<<endl;
      if(fh[i]==4) cout<<"/"<<a2[i]<<"="<<a1[i]/a2[i]<<endl;
    }
    exit(0);
  }
}
void dfs(int t)//t指现在还剩几个数
{
  if(t==1) {check();return;}
  if(t>1)
    for(int i=0;i<4;i++)
      if(a[i]==24) return;
  for(int i=0;i<4;i++)
    for(int j=0;j<4;j++)
      if(vis[j]==0&&a[i]>=a[j]&&i!=j)//两数相同必须保证两数下标不同
      {
        a1[4-t]=a[i];
        a2[4-t]=a[j];//储存运算过程（下下行也是）
    a[i]=a[i]+a[j];
        vis[j]=1;
        fh[4-t]=1;
        if(a[i]>0&&vis[i]==0) dfs(t-1);
        vis[j]=0;
        a[i]-=a[j];//回溯（加）
        a1[4-t]=a[i];
        a2[4-t]=a[j];
        a[i]=a[i]-a[j];
        vis[j]=1;
        fh[4-t]=2;
        if(a[i]>0&&vis[i]==0) dfs(t-1);
        vis[j]=0;
        a[i]+=a[j];//减
        a1[4-t]=a[i];
        a2[4-t]=a[j];
        a[i]=a[i]*a[j];
        vis[j]=1;
        fh[4-t]=3;
        if(a[i]>0&&vis[i]==0) dfs(t-1);
        vis[j]=0;
        a[i]/=a[j];//乘
        if(a[i]%a[j]==0)
        {
          a1[4-t]=a[i];
          a2[4-t]=a[j];
          a[i]=a[i]/a[j];
          vis[j]=1;
          fh[4-t]=4;
          if(a[i]>0&&vis[i]==0) dfs(t-1);
          vis[j]=0;
          a[i]*=a[j];//除
        }
      }
}
int main()
{
  int i,j,k;
  for(i=0;i<4;i++)
    cin>>a[i];
  dfs(4);
  if(f==0) cout<<"No answer!"<<endl;
  return 0;
}
ps：打完题解时我突然发现我的AC程序输入1 1 1 24时会输No answer！，但题目限定了4个数是在9以内的自然数，于是我就没管了。
```

---

## 作者：Heartlessly (赞：21)

## 解题思路
- 这是一道十分珂怕的模拟题，容易调到心态爆炸，发现其他人都是用搜索写的。实际上本题珂以不用搜索，只需要用$STL$中的**next_permutation**函数以及$for$循环暴力枚举所有可能的情况，找到答案。

- 关于$STL$中的**next_permutation**函数，求的是当前序列的下一个全排列，且具有去重功能，如果已经是最后一个全排列，就会返回$false$，一般与$while$循环和$do-while$循环一起使用。

- 考虑添加括号的情况，假设**?**为运算符，一共只有$5$种：

> 1.((a?b)?c)?d

> 2.(a?(b?c))?d

> 3.a?((b?c)?d)

> 4.(a?b)?(c?d)

> 5.a?(b?(c?d))


- 当然本题也有好几个坑点~~（调了我好久）~~

> 1.运算过程中不能出现$0$和小数

> 2.如果两个操作数有大小的话则先输出大的。

> 3.不能整除或者除数为$0$

### ~~不服来X~~


------------

## 示例代码

```cpp
/*
Language:C++
Author:xuxing
*/
#include <bits/stdc++.h>
using namespace std;

int a[5];

int calc(int n, int x, int y) {//计算函数，注意特判出现0的情况，如果出现，返回一个极小值即可
	switch (n) {
		case 1 : { return x + y == 0 ? -10000 : x + y; }
		case 2 : { return x - y == 0 ? -10000 : x - y; }
		case 3 : { return x * y == 0 ? -10000 : x * y; }
		case 4 : { return (y == 0 || x < y || x % y != 0) ? -10000 : x / y; }
	}
}

char output(int n) {//输出运算符
	switch (n) {
		case 1 : { return '+'; }
		case 2 : { return '-'; }
		case 3 : { return '*'; }
		case 4 : { return '/'; }
	}
}

int main() {
	for (int i = 1; i <= 4; i++) scanf("%d", &a[i]);
	sort(a + 1, a + 5);//使用全排列函数前先排序，保证遍历所有情况
	do {
		for (int i = 1; i <= 4; i++) {
			for (int j = 1; j <= 4; j++) {
				for (int k = 1; k <= 4; k++) {//暴力枚举3个运算符
					if (calc(i, calc(j, calc(k, a[1], a[2]), a[3]), a[4]) == 24) {
						if (a[1] < a[2] || calc(k, a[1], a[2]) < a[3] || calc(j, calc(k, a[1], a[2]), a[3]) < a[4])//保证操作数的大小顺序，下同
							continue;
						printf("%d%c%d=%d\n", a[1], output(k), a[2], calc(k, a[1], a[2]));
						printf("%d%c%d=%d\n", calc(k, a[1], a[2]), output(j), a[3], calc(j, calc(k, a[1], a[2]), a[3]));
						printf("%d%c%d=24\n", calc(j, calc(k, a[1], a[2]), a[3]), output(i), a[4]);
						return 0;//程序直接结束，下同
						//((a?b)?c)?d
					}
					if (calc(i, calc(j, a[1], calc(k, a[2], a[3])), a[4]) == 24) {
						if (a[2] < a[3] || a[1] < calc(k, a[2], a[3]) || calc(j, a[1], calc(k, a[2], a[3])) < a[4])
							continue;
						printf("%d%c%d=%d\n", a[2], output(k), a[3], calc(k, a[2], a[3]));
						printf("%d%c%d=%d\n", a[1], output(j), calc(k, a[2], a[3]), calc(j, a[1], calc(k, a[2], a[3])));
						printf("%d%c%d=24\n", calc(j, a[1], calc(k, a[2], a[3])), output(i), a[4]);
						return 0;
						//(a?(b?c))?d
					}
					if (calc(i, a[1], calc(j, calc(k, a[2], a[3]), a[4])) == 24) {
						if (a[2] < a[3] || calc(k, a[2], a[3]) < a[4] || a[1] < calc(j, calc(k, a[2], a[3]), a[4]))
							continue;
						printf("%d%c%d=%d\n", a[2], output(k), a[3], calc(k, a[2], a[3]));
						printf("%d%c%d=%d\n", calc(k, a[2], a[3]), output(j), a[4], calc(j, calc(k, a[2], a[3]), a[4]));
						printf("%d%c%d=24\n", a[1], output(i), calc(j, calc(k, a[2], a[3]), a[4]));
						return 0;
						//a?((b?c)?d)
					}
					if (calc(i, calc(j, a[1], a[2]), calc(k, a[3], a[4])) == 24) {
						if (a[1] < a[2] || a[3] < a[4] || calc(j, a[1], a[2]) < calc(k, a[3], a[4]))
							continue;
						printf("%d%c%d=%d\n", a[1], output(j), a[2], calc(j, a[1], a[2]));
						printf("%d%c%d=%d\n", a[3], output(k), a[4], calc(k, a[3], a[4]));
						printf("%d%c%d=24\n", calc(j, a[1], a[2]), output(i), calc(k, a[3], a[4]));
						return 0;
						//(a?b)?(c?d)
					}
					if (calc(i, a[1], calc(j, a[2], calc(k, a[3], a[4]))) == 24) {
						if (a[3] < a[4] || a[2] < calc(k, a[3], a[4]) || a[1] < calc(j, a[2], calc(k, a[3], a[4])))
							continue;
						printf("%d%c%d=%d\n", a[3], output(k), a[4], calc(k, a[3], a[4]));
						printf("%d%c%d=%d\n", a[2], output(j), calc(k, a[3], a[4]), calc(j, a[2], calc(k, a[3], a[4])));
						printf("%d%c%d=24\n", a[1], output(i), calc(j, a[2], calc(k, a[3], a[4])));
						return 0;
						//a?(b?(c?d))
					}
				}
			}
		}
	} while (next_permutation(a + 1, a + 5));//求所有全排列
	puts("No answer!");//不要忘记无解的情况
	return 0;
}
```

---

## 作者：hongzy (赞：15)

本题强烈引起我身体不适。所以这里提供一种正确但很暴力的思路。

搜索的使用传递一个$vector$，表示现在有哪些数。这样就防止被一些如$(a-c)*(b+d)$的答案卡掉。每次搜索随便选两个数进行四种运算。

搜索的核心代码大概是这样：（以加法为例）

```cpp
vector<int> nxt; 
for(int i = 0; i < v.size(); i ++) { //枚举第一个操作数
	for(int j = 0; j < v.size(); j ++) { //枚举第二个操作数
		if(i == j) continue ;
		int a = v[i], b = v[j];
		nxt.clear(); //清空vector
		nxt.push_back(a + b); //加法的结果
		for(int k = 0; k < v.size(); k ++) //把剩下的继续放进去
			if(k != i && k != j) nxt.push_back(v[k]);
		if(dfs(k + 1, nxt)) { //找到解
			sprintf(ans[pt ++], "%d%c%d=%d\n", max(a, b), '+', min(a, b), a + b);
			return true ;
		}
	}
}
```

代码实现上有两个技巧，能够精简代码。

第一个是$sprintf$，打印到字符串，因为本题使用搜索需要逆序输出。

第二个是宏定义。考虑到四则运算都差不多，宏定义一下$Q\omega Q$。（这个好像还没人用呢）

```cpp
#include <vector>
#include <cstdio>
using namespace std;

#define work(opt) nxt.clear();\
			nxt.push_back(a opt b);\
			for(int k = 0; k < v.size(); k ++)\
				if(k != i && k != j) nxt.push_back(v[k]);\
			if(dfs(k + 1, nxt)) {\
				sprintf(ans[pt ++], "%d"#opt"%d=%d\n", max(a, b), min(a, b), a opt b);\
				return true ;\
			}
//work是尝试一种操作 
int a[4], pt;
char ans[5][101];

bool dfs(int k, const vector<int> & v) {
	if(k == 3) return v.size() == 1 && v[0] == 24; //成功 
	if(v.size() <= 1) return false ;               //如果经过1~2步就得到24则失败 
	vector<int> nxt;                               //下一个状态 
	for(int i = 0; i < v.size(); i ++) {           //枚举第一个操作数 
		for(int j = 0; j < v.size(); j ++) {      //枚举第二个操作数 
			if(i == j) continue ;
			int a = v[i], b = v[j];
			work(+); //尝试 +-*/
			if(a > b) {work(-)}
			work(*);
			if(a % b == 0) {work(/)}
		}
	}
	return false ;
}

int main() {
	scanf("%d%d%d%d", &a[0], &a[1], &a[2], &a[3]);
	vector<int> s;
	for(int i = 0; i < 4; i ++)
		s.push_back(a[i]);
	if(!dfs(0, s)) puts("No answer!");
	else for(int i = pt - 1; ~ i; i --)
			printf(ans[i]);
	return 0;
}
```
43行。。快乐。。

（500行的那位神犇给跪了Orz）

---

## 作者：ejfbdn (赞：6)

这题的基本思路很简单，暴力。

对于四个数，枚举所有可能的式子，然后看结果是不是24。

但是式子怎么不重不漏地枚举呢？

有一个神奇的东西叫后缀表达式（又称逆波兰表达式）

引用一下百科上的定义：

后缀表达式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。

譬如，对于样例，一种可行的解是(2+1)*7+3，转换成后缀表达式就是

2 1 + 7 * 3 +

后缀表达式的计算的话是用一个栈，遇到数字就push，遇到运算符就pop栈顶前两个数进行运算并将结果入栈

算2 1 + 7 * 3 +，先2,1入栈，遇到加号，弹2,1，入3（即2+1的结果），然后入7，遇到乘号，弹3,7,入21（即3×7）的结果，然后入3，遇到加号，弹3,21，最后入24（3+21的结果），扫到最后栈里只剩一个元素，就是结果。

使用后缀表达式的好处是运算方便，开个栈扫一遍就出答案，如果是处理我们平常的那种的式子（中缀表达式），还要考虑括号优先级，而且用后缀表达式枚举起来也方便。

有四个操作数，假设是a,b,c,d，假设在后缀表达式中顺序已知，那么我们就可以在4个数中间和四个数的后面插入符号构成后缀表达式

a b _ c _ _ d _ _ _

上面画下划线的地方可能有+-*/，也可能没有运算符。

6个位置，每个位置有5种状态(不填运算符或填+-*/)，我们只要枚举所有可能的符号填写方式然后再算出表达式结果然后判断是不是24就万事大吉了。

我们可以使用6位五进制数表示可能的符号填写方式，五进制下第i位表示从左到右第i位可以填符号的地方填的内容，0对应不填，1对应+，2对-，3对*，4对/。

比如，5进制下120300就表示

a b + c - (空) d * (空) (空)

我们可以从5进制下000000枚举到5进下444444，然后再计算搞出来的后缀表达式，得24就出解，没有24就重新排列4个操作数，如果所有可能方案都不行，就是无解。

一些（细节？）：

一、重新排列操作数：

c++ STL中有一个函数叫next_permutation，在algorithm包中。，使用它可以获得下一个排列。

返回值bool，参数：(数组起始地址，数组终止地址的下一个)

下一个排列指：

对于序列X，当且仅当序列Y满足：

Y的字典序比X大，且不存在字典序比X大而比Y小的序列

重排后的结果会存在你给它（指函数）的数组中。

最好先把输入升序排一下。

二、输出解，只要再算一遍后缀表达式边算边输出就好了。

三、操作数一定先输出大的后输出小的

四、中间过程不能出现负数或0或小数

五、可能还有一些问题没提到，有疑问看代码

最后ac代码：

```cpp
#include<cstdio>
#include<stack>
#include<algorithm>
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
int nums[5],oper[8],fl,pos[]={0,1,1,2,1,2,2,1,2,2,2};
int calc(int sets)
{
	int opcnt=0;
	//提取符号 ↓ 
	for(int i=6;i>=1;i--)
	{
		oper[i]=sets%5;
		sets/=5;
		opcnt+=(oper[i]>0);
	}
	if(opcnt!=3)return -1;//4个操作数只能有3个运算符 
	//-----计算构造出的后缀表达式------↓ 
	std::stack<int>s;
	for(int i=1,j=1,k=1;i<=10;i++)
	{
		if(pos[i]==1)s.push(nums[j++]);//如果当前位置是数字，入栈
		else
		{
			if(oper[k]!=0)//如果当前位置有符号，运算，没符号就跳过 
			{
				int a,b;
				if(!s.empty())a=s.top();//防止类似ab+c-/d的情况出现 
				else return -1;
				s.pop();
				if(!s.empty())b=s.top();
				else return -1;
				s.pop();
				switch(oper[k])
				{
					case 1:
						s.push(a+b);
						break;
					case 2:
						if(a-b<=0)return -1;//不能有非正数 
						s.push(a-b);
						break;
					case 3:
						s.push(a*b);
						break;
					case 4:
						if(b==0||a%b!=0)return -1;//不能除0，不能有小数 
						s.push(a/b);
						break;
				}
			}
			k++;
		}
	}return s.size()==1?s.top():-1;
}
int work()
{
	for(int i=1;i<=4;i++)scanf("%d",nums+i);
	std::sort(nums+1,nums+5);
	recnt:
	for(int i=0;i<15625;i++)//枚举运算符填写情况   【6位5进制数最多表示15624】 
	if(fl=(calc(i)==24))break;//calc：计算构造出的后缀表达式结果 
	if(!fl)
	{
		if(!std::next_permutation(nums+1,nums+5))return printf("No answer!\n")&0;
		else goto recnt;
	}
	//-----输出答案↓ 
	std::stack<int>s;
	for(int i=1,j=1,k=1;i<=10;i++)
	{
		if(pos[i]==1)s.push(nums[j++]);
		else
		{
			if(oper[k]!=0)
			{
				int a=s.top();
				s.pop();
				int b=s.top();
				s.pop();
				switch(oper[k])
				{
					case 1:
						s.push(a+b);
						printf("%d+%d=%d\n",max(a,b),min(a,b),a+b);
						break;
					case 2:
						s.push(a-b);
						printf("%d-%d=%d\n",a,b,a-b);
						break;
					case 3:
						s.push(a*b);
						printf("%d*%d=%d\n",max(a,b),min(a,b),a*b);
						break;
					case 4:
						s.push(a/b);
						printf("%d/%d=%d\n",a,b,a/b);
						break;
				}
			}
			k++;
		}
	}
	return 0;
}
int main()
{
	return work();
}
```

---

## 作者：上进的z君 (赞：5)

```delphi

type arr=array [1..4] of longint;
var i,result,n,len:longint;
d:arr;
r:array [1..3,1..4] of longint;

procedure print;
var i,j:longint;
begin
for i:=1 to 3 do
begin
for j:=1 to 3 do
if j<>2 then write(r[i,j])//r数组储存式子
else case r[i,j] of
1:write('+');
2:write('-');
3:write('*');
4:write('/')
end;
writeln('=',r[i,4]);
end;
end;

procedure try(k:longint;d:arr);//遍历所有的可能性
var a,b,i,j,l,t:longint;
e:arr;
begin
if k=1 then if d[1]=24 then begin print;halt end else
else
begin
for i:=1 to k-1 do
for j:=i+1 to k do
begin
a:=d[i]; b:=d[j];
if a<b then begin t:=a;a:=b;b:=t end;
t:=0;
for l:=1 to k do if (l<>i) and (l<>j) then begin t:=t+1;e[t]:=d[l] end;
r[5-k,1]:=a;
r[5-k,3]:=b;
r[5-k,4]:=-1;
for l:=1 to 4 do
begin
case l of
1:r[5-k,4]:=a+b;
2:r[5-k,4]:=a-b;
3:r[5-k,4]:=a*b;
4:if b<>0 then if a mod b=0 then r[5-k,4]:=a div b
end;
r[5-k,2]:=l;
if r[5-k,4]<>-1 then
begin
e[t+1]:=r[5-k,4];
try(k-1,e)
end;
end;
end;
end;
end;

begin
for i:=1 to 4 do read(d[i]);
try(4,d);
writeln('No answer!');//遍历完毕，无解
end.

```

---

## 作者：Seanq (赞：4)

**[P1236]算24点**  
~~大大的水题~~  
一个DFS解决。  
有大佬500行暴搜+判断，也是飞快。  
不过这样...真的好吗？  
本蒟蒻太懒，手写112行过水题。  
其实效率也高好多。  
主体思路：  
1.每次在x数组中找出两个配对，经过四则运算，更新。  
2.找到了一组符合题意但计算值不一定为24的值，判断是否为24  
3.输出找到的可行解。  
PS:此解法当最大值<=50时仍可行，且快如闪电，不需要加O（2）优化。  
重难点（我的思路）：  
1.注意找24时从x-1~x-4  
2.数值都是正整数  
3.不可以除以零  
4.小数不可以除以大数  
5.大数在前小数在后  
std:  

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
int x[5];
int s[5][5];
bool flag=0;
void print(int x)//输出答案
{
	cout << s[x][2];
	if(s[x][1]==0) cout << "+";
	if(s[x][1]==1) cout << "-";
	if(s[x][1]==2) cout << "-";
	if(s[x][1]==3) cout << "*";
	if(s[x][1]==4) cout << "/";
	cout << s[x][3];
	cout << "=";
	if(s[x][1]==0) cout << s[x][2]+s[x][3];
	if(s[x][1]==1) cout << s[x][2]-s[x][3];
	if(s[x][1]==2) cout << s[x][2]-s[x][3];
	if(s[x][1]==3) cout << s[x][2]*s[x][3];
	if(s[x][1]==4) cout << s[x][2]/s[x][3];
	cout << endl;
}
void dfs(int step)
{
	if(flag==1) return;
	if(step==3)//找到符合题意但不一定可行的解
	{
		int sum,cnt=0;
		for(int i=1;i<=4;i++)//找24
		{
			if(x[i]!=0)
			{
				sum=x[i];
				cnt++;
			}
		}
		if(sum==24&&cnt==1)
		{
        //输出
			print(1);
			print(2);
			print(3);
			flag=1;
		}
		return;
	}
	int t[5];
	for(int i=1;i<=4;i++) t[i]=x[i];
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=4;j++)
		{
			if(i==j) continue;//不能一样
			if(x[i]==0||x[j]==0) continue;//不能为0
			int xx=x[i],yy=x[j];
			//加法
			x[i]=xx,x[j]=yy;
			s[step+1][1]=0,s[step+1][2]=max(x[i],x[j]),s[step+1][3]=min(x[i],x[j]);
			x[i]=x[i]+x[j],x[j]=0;
			dfs(step+1);
			
			if(xx>yy)//减法1（保证大值在前）
			{
				x[i]=xx,x[j]=yy;
				s[step+1][1]=1,s[step+1][2]=x[i],s[step+1][3]=x[j];
				x[i]=x[i]-x[j],x[j]=0;
				dfs(step+1);
			}
	
			if(yy>xx)//减法2
			{
				x[i]=xx,x[j]=yy;
				s[step+1][1]=2,s[step+1][2]=x[j],s[step+1][3]=x[i];
				x[i]=x[j]-x[i],x[j]=0;
				dfs(step+1);
			}				
			//乘法
			x[i]=xx,x[j]=yy;
			s[step+1][1]=3,s[step+1][2]=max(x[i],x[j]),s[step+1][3]=min(x[i],x[j]);
			x[i]=x[i]*x[j],x[j]=0;
			dfs(step+1);
			
			if(xx%yy==0&&yy!=0)
			{
				x[i]=xx,x[j]=yy;
				s[step+1][1]=4,s[step+1][2]=x[i],s[step+1][3]=x[j];
				x[i]=x[i]/x[j],x[j]=0;
				dfs(step+1);
			}
			
			if(yy%xx==0&&xx!=0)//如果除以操作合法
			{
				x[i]=xx,x[j]=yy;
				s[step+1][1]=4,s[step+1][2]=x[j],s[step+1][3]=x[i];
				x[i]=x[j]/x[i],x[j]=0;
				dfs(step+1);
			}
			
			for(int i=1;i<=4;i++)
				x[i]=t[i];//改回原数组
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&a,&b,&c,&d);//输入
	x[1]=a,x[2]=b,x[3]=c,x[4]=d;
	sort(x+1,x+5);//排个序
	dfs(0);//找答案
	if(flag==0) cout << "No answer!" << endl;//输出无解
	return 0; 
} 
```
--------------
这题的优化（~~虽然我们的算法已经很优秀了~~）  
1.改回原数组用O(1)(没优化多少)  
2.枚举匹配两值用O(k(k-1))(k为当前剩余位数)  
3.优化输出（快读快写）  
4.用BFS(找到解就break)  
5.找24（预先算好）（没优化多少）  
6.(假设已用bfs)双向bfs/迭代加深dfs(推荐后一种)  
7.A※(优化）  
8.O(2)优化啦！  
（9）最强优化：打表过样例，暴力出奇迹，打表O(1)!

---

## 作者：Flying2018 (赞：4)

没什么算法，直接爆搜即可，剪枝都不必

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
using namespace std;
int p1[4],p2[4],p3[4];//p1存前数，p2存后数，p3存操作符
int ys(int a,int b,int c)//运算a,b
{
    switch(c)
    {
        case 1:{
            return a+b;
            break;
        }
        case 2:{
            return abs(a-b);
            break;
        }
        case 3:{
            return a*b;
            break;
        }
        case 4:{
            if(!(a && b)) return -1;//别被0除
            if(max(a,b)%min(a,b)) return -1;
            else return max(a,b)/min(a,b);
            break;
        }
    }
}
char fh(int c)//取操作符
{
    if(c==1) return '+';
    if(c==2) return '-';
    if(c==3) return '*';
    if(c==4) return '/';
}
void check(int a[],const int l)
{
    if(l==2)//只剩两个数直接运算
    {
        bool d=false;
        for(int i=1;i<=4;i++)
        if(ys(a[0],a[1],i)==24) 
        {
            p1[2]=max(a[0],a[1]);//一定要保证前数小于后数
            p2[2]=min(a[0],a[1]);
            p3[2]=i;
            d=true;
        }
        if(!d) return;
        for(int i=0;i<3;i++)
        printf("%d%c%d=%d\n",p1[i],fh(p3[i]),p2[i],ys(p1[i],p2[i],p3[i]));
        exit(0);
    }
    int b[4]={0};
    for(int i=0;i<l;i++)//枚举前数
    for(int j=0;j<l;j++)//枚举后数
    if(i!=j)
    {
        for(int k=1;k<=4;k++)//枚举操作符
        {
            int y=ys(a[i],a[j],k);
            if(y==-1) continue;
            p1[4-l]=max(a[i],a[j]);//同上，要求前数大于后数
            p2[4-l]=min(a[i],a[j]);
            p3[4-l]=k;
            b[0]=y;
            int p=1;
            for(int q=0;q<l;q++)
            if(q!=i && q!=j)
            b[p++]=a[q];//将没操作的数加上
            check(b,l-1);
        }
    }
}
int main()
{
    int a[4];
    cin>>a[0]>>a[1]>>a[2]>>a[3];
    check(a,4);
    printf("No answer!");
    return 0;
}
这道题没啥算法，如果一定要说的话应该是分治。
```

---

## 作者：Vocalise (赞：3)

此题无脑爆搜可做。因为：

全排列：$4!$

每次全排列枚举运算符：$4^3$

如果用我的判断两两先算再相运算的方法，还要加上$4^3$

所以最终复杂度是：
$$4!*(2*4^3)=3097$$

反正再怎么折腾也不会TLE。

---

首先第一步：忽略运算顺序，顺序计算配合全排列。

然后，你就可以再两两数之间枚举运算符，这里有一个奇技淫巧：
```cpp
inline int plus(int x,int y){return x+y;}
inline int minus(int x,int y){return x>y?x-y:-1;}
inline int times(int x,int y){return x*y;}
inline int divi(int x,int y){return y!=0&&x%y==0&&x>y?x/y:-1;}
int (*oper[10])(int,int)={NULL,plus,minus,times,divi};
char oper_[10]={'\0','+','-','*','/'};
```
这样就可以简单的
```cpp
for(int i=1;i<=4;i++)int result=oper[k](x,y)
```
了。自认为是简单很多的。

然后你就可以马上搞出一个60行的程序来：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>

int x[10],vis[10],r[10];

inline int plus(int x,int y){return x+y;}
inline int minus(int x,int y){return x>y?x-y:-1;}
inline int times(int x,int y){return x*y;}
inline int divi(int x,int y){return y!=0&&x%y==0&&x>y?x/y:-1;}
int (*oper[10])(int,int)={NULL,plus,minus,times,divi};
char oper_[10]={'\0','+','-','*','/'};

int op[10],left[10],right[10],re[10];
inline void print(){
	for(register int i=1;i<=3;i++){
		if(left[i]<right[i])std::swap(left[i],right[i]);
		std::printf("%d%c%d=%d\n",left[i],oper_[op[i]],right[i],re[i]);
	}
}
inline void calc(int i,int result){
	if(i==4)
	  if(result==24){
	  	print();
		exit(0);
	  }else return;
	for(register int j=1;j<=4;j++){
		int x=oper[j](result,r[i+1]);
		if(x>0){
			op[i]=j;
			left[i]=result;
			right[i]=r[i+1];
			re[i]=x;
			calc(i+1,x);
		}
	}
}

void DFs(int i){
	if(i==5){
		calc(1,r[1]);
		return;
	}
	for(register int j=1;j<=4;j++)
	  if(!vis[j]){
	    r[i]=x[j];
	    vis[j]=true;
	    DFs(i+1);
	    vis[j]=false;
	  }
}
int main(){
	for(register int i=1;i<=4;i++)std::cin>>x[i];
	DFs(1);
	std::puts("No answer!");
	return 0;
} 
```
然后悲惨的WA一个点。这里展示一下，**比如说**你是

> 1 1 3 5

就会输出No answer!

然而正解是：

```cpp
3+1=4
5+1=6
6*4=24
```
### 标注一下，这绝对不是真实数据

这是什么原因呢？很明显，你的运算只支持:

```cpp
      result
     op
    re 5 
   op
  re 3
 op
1 1
```
的一棵严重左偏表达式树，而不支持：
```cpp
   result
   op
  re re
 op   op
1 3   1 5
```
的形态。

### 如何解决？

我用的方法，因为计算函数是递归执行的，相对不灵活修改，又鉴于数据如此之小，我用了暴力的方法解决。
```
calc(1,0);//每次生成全排列后计算结果，递归
for(register int i=1;i<=4;i++)
	for(register int j=1;j<=4;j++){
		 int x=oper[i](r[1],r[2]),y=oper[j](r[3],r[4]);
		 if(x<=0||y<=0)continue;
		 left[1]=r[1],right[1]=r[2],re[1]=x,op[1]=i;
		 left[2]=r[3],right[2]=r[4],re[2]=y,op[2]=j;
		 for(register int k=1;k<=4;k++)
		  	if(oper[k](x,y)==24){
		  	 left[3]=x,right[3]=y,re[3]=oper[k](x,y),op[3]=k;
		  	 print();
		  	 exit(0);
			 }
		 }//丧心病狂了，特判两辆算出，再相运算的方法 

```
然后就过了...

代码71行，算是比较短的了吧。这个解法并不优美，但是个人觉得用函数指针数组的方法进行四则运算是值得借鉴的方法。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>

int x[10],vis[10],r[10];

inline int plus(int x,int y){return x+y;}
inline int minus(int x,int y){return x>y?x-y:-1;}
inline int times(int x,int y){return x*y;}
inline int divi(int x,int y){return y!=0&&x%y==0&&x>y?x/y:-1;}
int (*oper[10])(int,int)={NULL,plus,minus,times,divi};
char oper_[10]={'\0','+','-','*','/'};

int op[10],left[10],right[10],re[10];
inline void print(){
	for(register int i=1;i<=3;i++){
		if(left[i]<right[i])std::swap(left[i],right[i]);
		std::printf("%d%c%d=%d\n",left[i],oper_[op[i]],right[i],re[i]);
	}
}
inline void calc(int i,int result){
	if(i==4)
	  if(result==24){
	  	print();
		exit(0);
	  }else return;
	for(register int j=1;j<=4;j++){
		int x=oper[j](result,r[i+1]);
		if(x>0){
			op[i]=j;
			left[i]=result;
			right[i]=r[i+1];
			re[i]=x;
			calc(i+1,x);
		}
	}
}

void DFs(int i){
	if(i==5){
		calc(1,r[1]);
		for(register int i=1;i<=4;i++)
		  for(register int j=1;j<=4;j++){
		  	int x=oper[i](r[1],r[2]),y=oper[j](r[3],r[4]);
		  	if(x<=0||y<=0)continue;
		  	left[1]=r[1],right[1]=r[2],re[1]=x,op[1]=i;
		  	left[2]=r[3],right[2]=r[4],re[2]=y,op[2]=j;
		  	for(register int k=1;k<=4;k++)
		  	  if(oper[k](x,y)==24){
		  	  	left[3]=x,right[3]=y,re[3]=oper[k](x,y),op[3]=k;
		  	  	print();
		  	  	exit(0);
			  }
		  }//丧心病狂了，特判两辆算出，再相运算的方法 
		return;
	}
	for(register int j=1;j<=4;j++)
	  if(!vis[j]){
	    r[i]=x[j];
	    vis[j]=true;
	    DFs(i+1);
	    vis[j]=false;
	  }
}
int main(){
	for(register int i=1;i<=4;i++)std::cin>>x[i];
	DFs(1);
	std::puts("No answer!");
	return 0;
} 
```
此题还有一个坑：你想判减法，除法的小数，负数和0，但是不自觉的就写出return x%y==0?x/y:-1;来，这时如果y本身就是0，就直接RE了...因为&&,||是短路的（即,&&碰到错的后面就不知行,||碰到对的后面就不执行），可以在前面再判一下y!=0就可以了

---

## 作者：Y_B_Y (赞：2)

### 搜索思路一定要清晰 ~~(不然之后都不知道自己怎么错的)~~

## 注意点:

#### 1.数字不一定要相邻,随便那两个就可以进行运算了(顺序也不要管)

#### 2.2-3是不可以的

所以这一题就一开始先确定最先运算的两个数,然后将得出来的数再和剩下的数进行运算,因为$a-b!=b-a$,所以剩下的数与得出来的数也要反过来进行计算,全部运算只要枚举运算符与参与运算的数就可以了,期间还要记录计算的步骤

有的同学可能会发现,为什么一定用得出来的数再和剩下的数进行运算,而不用另两个数进行运算呢,因为用这种方法和用其他方法的步骤可能不一样,但最后的结果~~应该~~都是一样的 ~~(这种做法貌似就是楼上某一位dalao做法的简单版)~~

举个栗子吧

$2~7 ~8 ~5$

$2*5=10$ 

然后将10和其他数进行运算

$10-7=3$

然后再将3与其他数进行运算

$3*8=24$,结束

输出

$2*5=10$ 

$10-7=3$

$3*8=24$

具体的步骤就在代码里讲吧

```
#include<bits/stdc++.h>
using namespace std;
int a[500],f[500][500];//a存储输入的数字,f存储步骤,这里500都是随便开的(不要学我偷懒)
bool b[500];//数字是否用过
char c[500]={'@','+','-','*','/'};/输出的时候用
int jsq(int k,int k1,int k2)//k为运算符,1,2,3,4对应加减乘除,k1前,k2后
{
	if(k==1) return k1+k2;//这个没有风险直接返回
	if(k==2)
	{
		if(k1>=k2) return k1-k2;//一定要k1大于等于k2
		else return -888;//否则,报错
	}
	if(k==3) return k1*k2;
	if(k==4)
	{
		if(k2!=0&&k1%k2==0) return k1/k2;//一定要整除,还有k2!=0要放在前面
		else return -888;//否则,报错
	}
}
void print()//输出步骤
{
	for(int p=1;p<=3;p++)
	{
		cout<<max(f[p][1],f[p][3])/*输出较大值*/<<c[f[p][2]]/*输出运算符*/<<min(f[p][1],f[p][3])/*输出较小*/<<'='<<f[p][4]<<endl;
	}
	exit(0);//直接退出整个程序
}
void dfs(int k,int num)//k为第k-1次计算结束(只要计算3次),num为得出的数
{
	if(k==4)//搜完了
	{
		if(num==24) print();//如果最后得出的数为24,输出
		return;//结束
	}
	for(int i=1;i<=4;i++)//枚举数字
	{
		if(b[i]==0)//没用过
		for(int l=1;l<=4;l++)//枚举运算符
		{
			int n=jsq(l,num,a[i]);//计算
			if(n!=-888)//如果没有报错(就是返回-888)
			{
				b[i]=1;//记录为用过
				f[k][1]=num;//记录步骤
				f[k][2]=l;
				f[k][3]=a[i];
				f[k][4]=n;
				dfs(k+1,n);//下一次计算,更新得出的数为n
				b[i]=0;//回溯
			}
			n=jsq(l,a[i],num);//反过来
			if(n!=-888)//下面都是和前面一样的
			{
				b[i]=1;
				f[k][1]=num;
				f[k][2]=l;
				f[k][3]=a[i];
				f[k][4]=n;
				dfs(k+1,n);
				b[i]=0;
			}
		}
	}
}
int main()
{
	cin>>a[1]>>a[2]>>a[3]>>a[4];//输入
	for(int i=1;i<=4;i++)//一开始将两个数先运算,这里是枚举第一个数
	{
		for(int j=1;j<=4;j++)//枚举第二个数
		{
			if(i==j) continue;//不能是同一个数,continue就是跳过后面内容的作用
			for(int l=1;l<=4;l++)//枚举运算符
			{
				int n=jsq(l,a[i],a[j]);//计算
				if(n!=-888)//如果没报错
				{
					f[1][1]=a[i];//记录步骤
					f[1][2]=l;
					f[1][3]=a[j];
					f[1][4]=n;
					b[i]=1;//记录为用过
					b[j]=1;
					dfs(2,n);//n为得出的数
					b[i]=0;//回溯
					b[j]=0;
				}
			}
		}
	}
	cout<<"No answer!";//前面都没有得出过,输出不可以
	return 0;
}
```


---

## 作者：saipubw (赞：2)

来个最暴力的7重循环

i j k l分别枚举四个数字，m,n,o枚举三个运算符。暴力枚举。
注意保证i,j,k,l不重复

比较坑爹的等式左边强制输出较大的数字！如3x8=24是错的，只能输出8x3=24.

注意！这还意味着a-b>0。

例如输入 9 1 5 2，有这样一个解（1-9）x（2-5），输出

1-9=-8

2-5=-3

-3*-8=24

这个解违反了等式左边先输出较大数字的规则！
你只能输出（9-1）x（5-2）这样的解


对除法，需判断分母是否为0，结果是否为整数。

一旦找到第一个可行的解马上输出答案，结束可啪的7重循环。

最后，注意到有两种运算顺序：

对 1 2 3 4 有24=(((1x2)x3)x4)

对 1 3 5 7 有24=（3-1）*(7+5)

分别判断这两种运算顺序的结果是否是24即可。

最后，虽然题目限定了数据范围是[1,9]，但实际上这个解法适用于任何int数据范围

```c
#include<stdio.h>

int num[4];// num：存储4个输入的数字
_Bool win = 0;

void search(void);//枚举4个数字，3个运算符
int jjcc(int a, int b, int c);//输入数字a，运算符b，数字c，返回结果
char whatitis(int a);//返回数字代表的运算符号

int main(void)
{
	for (size_t i = 0; i < 4; i++)
		scanf("%d", &num[i]);

	search();
	if (win != 1) printf("No answer!");

	return 0;
}

int jjcc(int a, int b, int c)
{
	int ans;
	switch (b)
	{
	case 0:
		ans = a + c;
		break;
	case 1:
		ans = a - c;
		break;
	case 2:
		ans = a * c;
		break;
	case 3:
		if ((c != 0) && (a % c == 0))
			ans = a / c;
		else goto imp;
		break;
	}
	return ans;
imp:return 331777;//24^4+1,impossible num
}

char whatitis(int a)
{
	char ans;
	switch (a)
	{
	case 0:
		ans = '+';
		break;
	case 1:
		ans = '-';
		break;
	case 2:
		ans = '*';
		break;
	case 3:
		ans = '/';
		break;
	}
	return ans;
}

void search(void)
{
	int ans, ans_1, ans_a_2, ans_b_2;

	for (size_t i = 0; i < 4; i++)  //num_1
	{
		for (size_t j = 0; j < 4; j++) //num_2
		{
			if (j == i) continue;
			for (size_t k = 0; k < 4; k++) //num_3
			{
				if (k == i || k == j) continue;
				for (size_t l = 0; l < 4; l++) //num_4
				{
					if (l == i || l == j || l == k) continue;
					for (size_t m = 0; m < 4; m++) //cal_1
					{
						ans_1 = jjcc(num[i], m, num[j]);
						if (ans_1 < 0) continue;
						for (size_t n = 0; n < 4; n++)//cal_3
						{
							ans_a_2 = jjcc(num[k], n, num[l]);
							for (size_t o = 0; o < 4; o++)//cal_2
							{
								ans_b_2 = jjcc(ans_1, o, num[k]);
								ans = jjcc(ans_1, o, ans_a_2);
								//第一种运算顺序
								if (ans == 24 && ans_a_2 >= 0)
								{
									win = 1;
									//判断那个大，改变输出顺序
									if (num[i] <= num[j])
										printf("%d%c%d=%d\n", num[j], whatitis(m), num[i], ans_1);
									else
										printf("%d%c%d=%d\n", num[i], whatitis(m), num[j], ans_1);
									if (num[k] <= num[l])
										printf("%d%c%d=%d\n", num[l], whatitis(n), num[k], ans_a_2);
									else
										printf("%d%c%d=%d\n", num[k], whatitis(n), num[l], ans_a_2);
									if (ans_1 <= ans_a_2)
										printf("%d%c%d=%d\n", ans_a_2, whatitis(o), ans_1, ans);
									else
										printf("%d%c%d=%d\n", ans_1, whatitis(o), ans_a_2, ans);
									goto End;
								}
								ans = jjcc(ans_b_2, n, num[l]);
								//第二种运算顺序
								if (ans == 24 && ans_b_2 >= 0)
								{
									win = 1;
									//判断那个大，改变输出顺序
									if (num[i] <= num[j])
										printf("%d%c%d=%d\n", num[j], whatitis(m), num[i], ans_1);
									else
										printf("%d%c%d=%d\n", num[i], whatitis(m), num[j], ans_1);
									if (ans_1 <= num[k])
										printf("%d%c%d=%d\n", num[k], whatitis(o), ans_1, ans_b_2);
									else
										printf("%d%c%d=%d\n", ans_1, whatitis(o), num[k], ans_b_2);
									if (ans_b_2 <= num[l])
										printf("%d%c%d=%d\n", num[l], whatitis(n), ans_b_2, ans);
									else
										printf("%d%c%d=%d\n", ans_b_2, whatitis(n), num[l], ans);
									goto End;
								}
							}
						}
					}
				}
			}
		}
	}
End:return;
}
```

---

## 作者：Lynx (赞：2)

从所有牌中任选两张，合并，递归，直到只剩一张牌，判断是否为24即可。

print时较为繁琐，不过只需多开几个数组。

附c++代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[5][11],ans[11][3],ky[11];
bool flg;
char op(int k)
{
    if(k==1)
        return '+';
    if(k==2)
        return '-';
    if(k==3)
        return '*';
    if(k==4)
        return '/';
}
void print(int dep)
{
    if(dep==1)
        return ;
    printf("%d%c%d=%d\n",ans[dep][1],op(ky[dep]),ans[dep][2],a[dep-1][1]);
    print(dep-1);
}
int calc(int x,int y,int k)
{
    if(k==1)
        return x+y;
    if(k==2)
        return x-y;
    if(k==3)
        return x*y;
    if(k==4)
        return x/y;
}
void dfs(int dep)//现有牌数 
{
    if(flg)
        return ;
    if(dep==1)
    {
        if(a[1][1]==24)
        {
            flg=1;
            print(4);
        }
        return ;
    }
    for(int i=1;i<=dep;i++)//任选两张牌 
        for(int j=1;j<=dep;j++)
            if(i!=j)
            {
                ans[dep][1]=max(a[dep][i],a[dep][j]),ans[dep][2]=min(a[dep][i],a[dep][j]);
                for(int k=1;k<=4;k++)//枚举所填符号 
                {
                    if((k==2&&a[dep][i]<=a[dep][j])||(k==4&&a[dep][j]!=0&&a[dep][i]%a[dep][j]!=0))
                        continue;
                    int tp=1;
                    a[dep-1][tp]=calc(a[dep][i],a[dep][j],k);
                    for(int g=1;g<=dep;g++)
                        if(g!=i&&g!=j)
                            a[dep-1][++tp]=a[dep][g];
                    ky[dep]=k;
                    dfs(dep-1);
                }
            }
}
int main()
{
    for(int i=1;i<=4;i++)
        scanf("%d",&a[4][i]);
    dfs(4);
    if(!flg)
        printf("No answer!\n");
    return 0;
}
```

---

## 作者：ykuouzf (赞：2)

## 来自一个懒蒟蒻的题解……
### 看到各位巨佬都写得那么长，其实远不比这样。
### 首先，我们可以先假设运行顺序必然是从左到右，因此我们便需要一个从左到右的全排列，然后再进行判断，全排列大家都知道怎么写，没错，就是dfs！
```cpp
void dfs(int dep){
	if(flag2) return ;
	if(dep==5){
		for(int i=1;i<=4;i++) //枚举三个运算符
		for(int j=1;j<=4;j++)
		for(int k=1;k<=4;k++){
			flag=1;
			if(f(k,f(j,(f(i,a[1],a[2])),a[3]),a[4])==24&&flag){output(1,i,j,k);flag2=1;return ;}
		}
	}
	for(int i=1;i<=4;i++)
		if(!v[i]){
			v[i]=1;
			a[dep]=c[i];
			dfs(dep+1);
			v[i]=0;
		}
}
```
### 我们用f函数来进行计算，用flag来判断不合适的情况。
### 再加上一个判断和输出，貌似此题就已经解决了，但是却没有过，什么原因？来看一则样例：
### 6 7 8 9
### 答案应该是：
### 8*6=48
### 9-7=2
### 48/2=24
### 我们发现在8*6=48后，没有立即再用48，而是先算9-7=2。所以还有一种情况，那就是先算前两者，再算后两者，它们之间再进行运算。这样问题就解决了。
### 最后献上最短代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[5],c[5],v[5];
bool flag,flag2;
int f(int t,int x,int y){
	if((t==4&&(!y||x%y!=0||x<y))||(t==2&&x<y)) return -999;
	if(t==1) return x+y;
	if(t==2) return x-y;
	if(t==3) return x*y;
	if(t==4) return x/y;
}
char pd(int x){
	if(x==1) return '+';
	if(x==2) return '-';
	if(x==3) return '*';
	if(x==4) return '/';
}
void output(int p,int i,int j,int k){
	if(p==1){
		printf("%d%c%d=%d\n",max(a[1],a[2]),pd(i),min(a[1],a[2]),f(i,a[1],a[2]));
		printf("%d%c%d=%d\n",max(f(i,a[1],a[2]),a[3]),pd(j),min(f(i,a[1],a[2]),a[3]),f(j,f(i,a[1],a[2]),a[3]));
		printf("%d%c%d=%d\n",max(f(j,f(i,a[1],a[2]),a[3]),a[4]),pd(k),min(f(j,f(i,a[1],a[2]),a[3]),a[4]),f(k,f(j,f(i,a[1],a[2]),a[3]),a[4]));
	}
	else{
		printf("%d%c%d=%d\n",max(a[1],a[2]),pd(i),min(a[1],a[2]),f(i,a[1],a[2]));
		printf("%d%c%d=%d\n",max(a[3],a[4]),pd(k),min(a[3],a[4]),f(k,a[3],a[4]));
		printf("%d%c%d=%d\n",max(f(i,a[1],a[2]),f(k,a[3],a[4])),pd(j),min(f(i,a[1],a[2]),f(k,a[3],a[4])),f(j,f(i,a[1],a[2]),f(k,a[3],a[4])));
	}
}
void dfs(int dep){
	if(flag2) return ;
	if(dep==5){
		for(int i=1;i<=4;i++)
		for(int j=1;j<=4;j++)
		for(int k=1;k<=4;k++){
			flag=1;
			if(f(k,f(j,(f(i,a[1],a[2])),a[3]),a[4])==24&&flag){output(1,i,j,k);flag2=1;return ;}
			if(f(j,f(i,a[1],a[2]),f(k,a[3],a[4]))==24&&flag){output(2,i,j,k);flag2=1;return ;}
		}
	}
	for(int i=1;i<=4;i++)
		if(!v[i]){
			v[i]=1;
			a[dep]=c[i];
			dfs(dep+1);
			v[i]=0;
		}
}
int main(){
	for(int i=1;i<=4;i++) scanf("%d",&a[i]);
	for(int i=1;i<=4;i++) c[i]=a[i];
	dfs(1);
	if(!flag2) printf("No answer!");
	return 0;
}
```
### THE END.

---

## 作者：XMK_萌新 (赞：2)

为什么那么多人写了那么多行？ 真的不用栈啊。。。

```cpp
  #include <iostream>
  #include <cstdlib>
  #include <cstdio>
  using namespace std;
  long long num[5],output[4][4]，idx;	//num是初始数字 output是输出 
  char sig[4],don[4]={'+','-','*','/'};	//sig是用的运算符 don是四则运算
  bool check(float a,int b)	//除法判断
  {
      return (a/b==int(a/b));
  }	//其实就是return a%b==0，没办法脑子少根弦
  int count(int a,int b,int s)	//a和b是运算数
  {
      if(s==0) return a+b;
      if(s==1) return a-b;
      if(s==2) return a*b;
      return a/b;
  }
  void dfs(int t)	//神奇的dfs
  {
      if(t==4)	//用完三次计算
      {
          int f1=0,f2=0;	//计数
          for(int i=1;i<=4;i++)
          {
              if(num[i]==1000000) f1++;	//用过的数赋为1000000
              if(num[i]==24) f2++;	//其中有一个24
          }
          if(f1==3&&f2==1)	//只剩一个24
          {
              if(output[1][3]>0&&output[2][3]>0&&output[3][3]>0)	//每次运算的结果都不能为负数，切记（我第一次#5 10WA被坑）
              {
                  idx++;
                  for(int i=1;i<=3;i++)
                  {
                      int minv=min(output[i][1],output[i][2]),maxv=max(output[i][1],output[i][2]); 	//大数在前 小数在后
                      cout<<maxv<<sig[i]<<minv<<"="<<output[i][3]<<endl;
                  }
                  exit(0);	//没办法我就这么懒
              }
          }
          return; 
      }
      for(int i=1;i<=4;i++)
      {
          if(num[i]!=1000000)	//非被用过的数
          {
              for(int j=1;j<=4;j++)
              {
                  if(i!=j&&num[j]!=1000000)	//非重数 & 非被用过的数
                  {
                      for(int s=0;s<4;s++)
                      {
                          if(s==3&&!check(num[i],num[j])) break;	//用除法运算并不能整除
                          int a=num[i],b=num[j],cnt=count(num[i],num[j],s);
                          num[i]=cnt;	//更新数字
                          num[j]=1000000;	//更新数字
                          output[t][1]=a;	//放到输出里
                          output[t][2]=b;	//放到输出里
                          output[t][3]=cnt;	//放到输出里
                          sig[t]=don[s];	//放到输出里
                          dfs(t+1);	//搜索
                          num[i]=a;	//回溯
                          num[j]=b;	//回溯
                      }
                  }
              }
          }
      }
  }	//懵逼的多重大括号
  int main()
  {
      //我是cin/out党
      for(int i=1;i<=4;i++) cin>>num[i];
      dfs(1);
      if(!idx) cout<<"No answer!";
      return 0;
  }
```
实在不需要400行+。

---

## 作者：Silver_N (赞：2)

暴搜，每次枚举使用剩下牌中的某两张，枚举使用的运算（注意判断是否能整除，结果是否为正数），若搜到正好使用4张牌（进行了三次运算）得到24点，输出答案即可。

dfs函数里的dep其实没有必要，判tl>3时返回即可



[code]
/\*by SilverN\*/

         
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
struct clc{
    int a,b;
    char c;
    int res;
}ans[60000];
int a[5];
int hd=1,tl=1;
int vis[5];
bool dfs(int cnt,int dep){
    if(dep>3)return 0;
    int i,j,k;
    for(i=1;i<=cnt;i++)
        if(vis[i])continue;
        else
     for(j=1;j<=cnt;j++){
         if(i==j)continue;
         if(vis[j])continue;
         //+
             int tmp1=a[i],tmp2=a[j];
             a[i]=a[i]+a[j];a[j]=0;vis[j]=1;
             ans[tl++]=(clc){tmp1,tmp2,'+',a[i]};
             if((a[i]==24 && tl==4) || dfs(4,dep+1))return 1;
             tl--;vis[j]=0;
             a[i]=tmp1;a[j]=tmp2;
         //-
             a[i]=a[i]-a[j];a[j]=0;vis[j]=1;
             ans[tl++]=(clc){tmp1,tmp2,'-',a[i]};
             if(a[i]>0)//运算结果必须是正整数 
                 if((a[i]==24 && tl==4) || dfs(4,dep+1))return 1;
             tl--;vis[j]=0;
             a[i]=tmp1;a[j]=tmp2;
         //*
             a[i]=a[i]*a[j];a[j]=0;vis[j]=1;
             ans[tl++]=(clc){tmp1,tmp2,'*',a[i]};
             if((a[i]==24 && tl==4) || dfs(4,dep+1))return 1;
             tl--;vis[j]=0;
             a[i]=tmp1;a[j]=tmp2;
         // /
             if(!a[j])continue;
             if(a[i]%a[j]!=0)continue;
             a[i]=a[i]/a[j];a[j]=0;vis[j]=1;
             ans[tl++]=(clc){tmp1,tmp2,'/',a[i]};
             if((a[i]==24 && tl==4) || dfs(4,dep+1))return 1;
             tl--;vis[j]=0;
             a[i]=tmp1;a[j]=tmp2;
     }
    return 0;
}
int main(){
    int i,j;
    for(i=1;i<=4;i++) scanf("%d",&a[i]);
    if(dfs(4,1)){
        for(i=1;i<tl;i++){
            if(ans[i].c=='*' || ans[i].c=='+')
                if(ans[i].a<ans[i].b)swap(ans[i].a,ans[i].b);
            printf("%d%c%d=%d\n",ans[i].a,ans[i].c,ans[i].b,ans[i].res);
        }
    }
    else printf("No answer!\n");
    return 0;
}
[/code]
```

---

## 作者：呼风唤雨abc (赞：1)

### 说句实话，这一题并不难（^_^）。

但是有一些地方容易被忽略。就是判断是否正除的时候必须先判断被除数是否为零，不然自己的Dep-cpp都会爆炸。

我看到许多的题解都是用手动枚举（简称打表）的方式，那么我就来讲一下如何用后缀表达式来做这一题。

**这里只讲后缀表达式如何求值，不讲如何从中缀转后缀。**

求值并不怎么难，简单来讲就只有两点：

（1）就是当遇到一个数，则入栈。

（2）遇到符号，从栈里面取两个数进行运算后，再把结果入栈。

最终，栈顶就是结果（注意：后缀表达式没有括号）。所以运算四个数只需要三个符号（连小学生都会证明那么就不用我来说了吧。

```cpp
举个例子，就拿样例来说吧可以知道下面两个后缀表达式。
1 2 3 7 * + + 或者 1 2 + 3 7 * + 都可以得到24这个答案。
```

所以我们可以用这一段搜索代码实现。

```cpp
/*
头文件
定义全局变量
bool 搜索函数（深度）{
	如果（深度==8[因为只有7个符号，包括数字]）{
    	如果（如果栈顶==24）{
        	输出;
            返回真;
		}
        返回假;
	}
    枚举
		判断{
			……;
        	搜索（深度+1);
            ……;
		}
}
int 主函数（）{
	输入;
    搜索（1）;
}
*/
```

那么如何枚举，我们可以定义一个全局的栈，记录搜索之后的后缀表达式的结果，那么如果我们要添加符号，肯定必须要有两个数来运算，也就是栈中的元素必须大于等于2个，否则这是一个错误的后缀表达式。

输出就是按照运算顺序，用栈模拟，非常简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[]="+-*/";
stack<int> sta,ans;
int que[9],c[5],Use[5];
/*
que：记录每一次选取的编号（往下看就知道了）。
c：四个数字。
Use：判断一个数字是否被用过
*/
inline bool Find_ans(int top){
	if(top==8){
		if(sta.top()==24){
       		/*
            输出就是模拟运算。
            切记两数运算，大的在前，小的在后。
            切记不能用原来的dfs用的sta这一个栈，需要多开一个栈ans。
            */
			for(int i=1,c1=0,c2=0;i<=7;i++){
				if(que[i]<=4)
					ans.push(c[que[i]]);
				else {
					c1=ans.top(); ans.pop();
					c2=ans.top(); ans.pop();
					if(i&1 && c1<=c2)
						swap(c1,c2);
					printf("%d%c%d=",c1,s[que[i]-5],c2);
					if(que[i]==5) ans.push(c1+c2),printf("%d\n",c1+c2);
					if(que[i]==6) ans.push(c1-c2),printf("%d\n",c1-c2);
					if(que[i]==7) ans.push(c1*c2),printf("%d\n",c1*c2); 
					if(que[i]==8) ans.push(c1/c2),printf("%d\n",c1/c2);	
				}
			}
			return true;
		}
		return false;
	}
	for(int i=1,c1=0,c2=0;i<=8;i++)
		if((i<=4 && !Use[i]) || (i>=5 && sta.size()>=2)){
        /*
        1~4：选中第几个数字。
        5~8：运算符
           5 -> '+'
           6 -> '-'
           7 -> '*'
           8 -> '/'
        */
			if(i<=4){
				sta.push(c[i]);
				Use[i]=true;
			}
			else {
				c1=sta.top(); sta.pop();
				c2=sta.top(); sta.pop();
				if((!c2 || (c2 && c1%c2!=0)) && i==8){
                /*
                切记，整除和是否为零要分开判断。
                如果不满足的话，代表不能运算，所以要把从栈里面拿出来的两个数放回去。
                切记先放后拿出来的，再放先拿出来的。
                */
					sta.push(c2);
					sta.push(c1);
					continue;
				}
				if(i==5) sta.push(c1+c2);
				if(i==6) sta.push(c1-c2);
				if(i==7) sta.push(c1*c2);
				if(i==8) sta.push(c1/c2);
                //把运算的结果放入栈中。
                
			}
			que[top]=i;
            //记录这一次选了什么编号。
			if(Find_ans(top+1))
				return true;
            //如果有答案了就没有必要继续搜索了。
            /*==========一下为回shuo过程==========*/
			que[top]=0;
			sta.pop();
			if(i>=5){
				sta.push(c2);
				sta.push(c1);
			}
			else Use[i]=false;
            /*====================================*/
		}
	return false;
}
int main(){
	for(int i=1;i<=4;i++)
		scanf("%d",&c[i]);
	if(!Find_ans(1))
		printf("No answer!\n");
    //切记别把No answer!给打错了！
	return 0;
}
```
### 如果看不懂的话可以私信我哟。

---

## 作者：AISakura (赞：1)

emmmm坑点大佬们都讲过了

刚开始很naive的枚举4个数，

再枚举3个间隔中的运算符，

经大佬提醒，这样并不能完全枚举所有情况。

不想写深搜，于是蒟蒻就开始全排列后缀表达式，然后手写栈模拟一通就好了

以下是代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int num[10],stack[10];
char fh[15];
bool flag;
void print();
void js(){
    memset(stack,0,sizeof(stack));
    int top=0;
    for(int o=1;o<=7;o++){
        if(num[o]>=1&&num[o]<=9){
            top++;
            stack[top]=num[o];
        }
        if(num[o]>=11&&num[o]<=14){
            if(top<2)
                return;
            else{
                if(num[o]==11){
                    stack[top-1]+=stack[top];         top--;
                }
                if(num[o]==12){
                    stack[top-1]-=stack[top];         top--;
                    if(stack[top]<0)
                        return;
                }
                if(num[o]==13){
                    stack[top-1]*=stack[top];         top--;
                }
                if(num[o]==14){
                    if(stack[top]==0) 
                        return; 
                    if(stack[top-1]%stack[top]==0){
                        stack[top-1]/=stack[top];     top--;
                    }
                        
                    else return;
                }
            }
        }
    }
    if(stack[top]==24){
        print();
        flag=1;
        return;
    }
}
void print(){
    memset(stack,0,sizeof(stack));
    int top=0;
    for(int o=1;o<=7;o++){
        if(num[o]>=1&&num[o]<=9){
            top++;
            stack[top]=num[o];
        }
        if(num[o]>=11&&num[o]<=14){
            if(num[o]==11){
                printf("%d%c%d=%d\n",max(stack[top-1],stack[top]),fh[num[o]],min(stack[top-1],stack[top]),stack[top-1]+stack[top]);         
                stack[top-1]+=stack[top];
                top--;
            }
            if(num[o]==12){
                printf("%d%c%d=%d\n",max(stack[top-1],stack[top]),fh[num[o]],min(stack[top-1],stack[top]),stack[top-1]-stack[top]);
                stack[top-1]-=stack[top];
                top--;
            }
            if(num[o]==13){
                printf("%d%c%d=%d\n",max(stack[top-1],stack[top]),fh[num[o]],min(stack[top-1],stack[top]),stack[top-1]*stack[top]);
                stack[top-1]*=stack[top];         
                top--;
            }
            if(num[o]==14){
                printf("%d%c%d=%d\n",max(stack[top-1],stack[top]),fh[num[o]],min(stack[top-1],stack[top]),stack[top-1]/stack[top]);
                stack[top-1]/=stack[top];     
                top--;
                
            }
        }
    }
}
int main(){   
    for(int i=1;i<=4;i++)
    	scanf("%d",&num[i]);
    fh[11]='+';fh[12]='-';fh[13]='*';fh[14]='/';
    for(int i=11;i<=14;i++)
        for(int j=11;j<=14;j++)
            for(int k=11;k<=14;k++){	
                num[5]=i;   num[6]=j;   num[7]=k;
                sort(num+1,num+1+7);
    			do{
                   js();
                   if(flag==1)
                        return 0;
                }while(next_permutation(num+1,num+7+1)); 
            }
    printf("No answer!");
    return 0;
}
    
```

---

## 作者：dorence (赞：1)

### 感觉前面的大佬的暴力多少有点小问题，我决定来献丑了。真的不是“高性能”，大家直接暴力吧！
直接上代码吧（抄袭可耻），大家耐着性子读注释吧。真的事高三暑假无聊前来A暴力题啊。

```cpp
#include<iostream>//因为根本就不用考虑速度，所以用iostream读写 
#include<string>
using namespace std;

int num[4];
string s[3];//存输出的 

inline int _min(const int& _x,const int& _y){return _x<_y?_x:_y;}
inline int _max(const int& _x,const int& _y){return _x>_y?_x:_y;}

string istr(int x)//int to string , 0<=x<=24 
{
	string m;
	m=char(x%10+'0');
    if(x>=10) m=char(x/10+'0')+m;
    return m;
}

string work(const int& x,const int& y,char ch){return istr(_max(x,y))+ch+istr(_min(x,y))+'=';}

bool dfs(int n) //表示用n个数操作24点 
{
    if(n==1) return num[0]==24;
    else
    {
        int x,y; 
		for(int i=0;i<n;i++) for(int j=i+1;j<n;j++)
        {
            x=num[i],y=num[j],num[j]=num[n-1];//取num[i]和num[j]进行运算，并将num[n-1]调整到前n-1个数里面方便dfs 
            num[i]=x+y; if(dfs(n-1))
            {
                s[4-n]=work(x,y,'+')+istr(x+y);
                return true;
            }
            if(x>=y)//好像不允许出现负数，之前x-y和y-x都有的时候有两个点WA 
            {
	            num[i]=x-y; if(dfs(n-1))
	            {
	                s[4-n]=istr(x)+'-'+istr(y)+'='+istr(x-y);
	                return true;
	            }
			}
            else
            {
            	num[i]=y-x; if(dfs(n-1))
	            {
	                s[4-n]=istr(y)+'-'+istr(x)+'='+istr(y-x);
	                return true;
	            }
			}
            num[i]=x*y; if(dfs(n-1))
            {
                s[4-n]=work(x,y,'*')+istr(x*y);
                return true;
            }
            if(y&&!(x%y))
			{
				num[i]=x/y; if(dfs(n-1))
				{
					s[4-n]=istr(x)+'/'+istr(y)+'='+istr(x/y);
					return true;
				}
			}
            if(x&&!(y%x))
			{
				num[i]=y/x; if(dfs(n-1))
				{
					s[4-n]=istr(y)+'/'+istr(x)+'='+istr(y/x);
					return true;
				}
			}
            num[i]=x,num[j]=y;
        }
        return false;
    }
}

int main()
{
    cin>>num[0]>>num[1]>>num[2]>>num[3];
    if(dfs(4)) for(int i=0;i<3;i++) cout<<s[i]<<endl;
    else cout<<"No answer!"<<endl;
    return 0;
}

```


---

## 作者：windyuan (赞：1)

这道题目的本质就是任意找出两个数字将它们加减乘除

然后再任意找出两个数字将它们加减乘除

知道最后只剩下两个数，判断加减乘除后是否能为24.

所以想起了递归的方法。

写了一个结构非常清晰的代码。

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
struct note
{
    char s[10000];
} book[10];
int check(int a,int b,int c,int d,int n)
{
    int i,j,x[6];
    if(n>=3)///只剩下两个数的情况
    {
        if((d+c)==24)
        {
            sprintf(book[n].s,"%d+%d=24",d,c);
            return 1;
        }
        if((d-c)==24)
        {
            sprintf(book[n].s,"%d-%d=24",d,c);
            return 1;
        }
        if((d*c)==24)
        {
            sprintf(book[n].s,"%d*%d=24",d,c);
            return 1;
        }
        if(c!=0)
            if((d%c)==0 && (d/c)==24)
            {
                sprintf(book[n].s,"%d/%d=24",d,c);
                return 1;
            }
        return 0;
    }
    for(i=n; i<=3; i++)///如果还剩两个以上则开始随机选择两个数字
        for(j=i+1; j<=4; j++)
        {
            x[1]=a,x[2]=b,x[3]=c,x[4]=d;///这里用排序的方法简化了程序
            x[j]=x[j]+x[i];
            x[i]=0;
            sort(x+1,x+5);
            if(check(x[1],x[2],x[3],x[4],n+1)==1)
            {
                x[1]=a,x[2]=b,x[3]=c,x[4]=d;
                sprintf(book[n].s,"%d+%d=%d",x[j],x[i],x[j]+x[i]);///万能的sprintf和sscanf
                return 1;
            }
            ///---------------------------------------------------------
            x[1]=a,x[2]=b,x[3]=c,x[4]=d;
            x[j]=x[j]-x[i];
            x[i]=0;
            sort(x+1,x+5);
            if(check(x[1],x[2],x[3],x[4],n+1)==1)
            {
                x[1]=a,x[2]=b,x[3]=c,x[4]=d;
                sprintf(book[n].s,"%d-%d=%d",x[j],x[i],x[j]-x[i]);
                return 1;
            }
            ///---------------------------------------------------------
            x[1]=a,x[2]=b,x[3]=c,x[4]=d;
            x[j]=x[j]*x[i];
            x[i]=0;
            sort(x+1,x+5);
            if(check(x[1],x[2],x[3],x[4],n+1)==1)
            {
                x[1]=a,x[2]=b,x[3]=c,x[4]=d;
                sprintf(book[n].s,"%d*%d=%d",x[j],x[i],x[j]*x[i]);
                return 1;
            }
            ///---------------------------------------------------------
            x[1]=a,x[2]=b,x[3]=c,x[4]=d;
            if(x[i]!=0)///记住mod 0和除0程序会爆炸。
                if(x[j]%x[i]==0)
                {
                    x[j]=x[j]/x[i];
                    x[i]=0;
                    sort(x+1,x+5);
                    if(check(x[1],x[2],x[3],x[4],n+1)==1)
                    {
                        x[1]=a,x[2]=b,x[3]=c,x[4]=d;
                        sprintf(book[n].s,"%d/%d=%d",x[j],x[i],x[j]/x[i]);
                        return 1;
                    }
                }
        }
    return 0;
}
int main()
{
    int a,b,c,d;
    cin>>a>>b>>c>>d; ///输入
    if(check(a,b,c,d,1)==1)
    {
        cout<<book[1].s<<endl;  ///因为递归只能逆序输出，需要用字符串存一下。
        cout<<book[2].s<<endl;
        cout<<book[3].s<<endl;
    }
    else cout<<"No answer!"<<endl;
    return 0;
}

```

---

## 作者：NeosKnight (赞：1)

少有的一次过，就这样任性的打了一段老长的代码就过了，暴力枚举操作数和运算符；


用三个数组，一个存数的使用情况，一个存数，一个存输出；具体自己看吧


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
using namespace std;
int num[30];
int sum[30];
int l=4;
int top=0;
bool ok=false;
bool use[30];
inline bool pd()//判断数的试用情况，给出的数必须都用过 
{
    for(int i=1;i<=4;i++)
    {
        if(!use[i]) return 0;
    }
    return 1;
}
inline int pd1(int a,int b,int c)//判断这个结果咋来的 
{
    if (a+b==c) return 1;
    if(a-b==c&&a>b) return 2;
    if(a*b==c) return 3;
    if(a%b==0&&a/b==c) return 4;
}
void out()//输出 
{
    int flag=0;int tot=3;
    while(tot)
    {
        tot--;
        int a=num[++flag],b=num[++flag],c=num[++flag];
        if(a<b) swap(a,b);
        switch(pd1(a,b,c))
        {
            case 1:
                cout<<a<<"+"<<b<<"="<<c<<endl;
                break;
            case 2:
                cout<<a<<"-"<<b<<"="<<c<<endl;
                break;
            case 3:
                cout<<a<<"*"<<b<<"="<<c<<endl;
                break;
            case 4:
                cout<<a<<"/"<<b<<"="<<c<<endl;
                break;
        }
    }
}
void dfs(int t)
{
    if(t==4) return ;
    for(int i=1;i<=l;i++)
    {
        if(use[i]) continue;
        use[i]=true;
        num[++top]=sum[i];
        for(int j=i+1;j<=l;j++)//选操作数 
        {
            if(use[j]) continue;
            use[j]=true;int a,b;
            num[++top]=sum[j];
            int y; 
```
/***************选算符***************/
```cpp
            //1.加法 
            y=sum[i]+sum[j];
            num[++top]=y;sum[++l]=y;
            if(t==3&&pd()&&y==24){
                ok=true;out();exit(0);
            }
            dfs(t+1);
            l--;top--;
            //2.减法
            a=sum[i];b=sum[j];
            if(a!=b)
            {
                if(a<b)    swap(a,b);
                y=a-b;num[++top]=y;sum[++l]=y;
                if(t==3&&pd()&&y==24)
                {ok=true;out();exit(0);}
                dfs(t+1);
                l--;top--;
            }
            //3.乘法
            y=sum[i]*sum[j];num[++top]=y;sum[++l]=y;
            if(t==3&&pd()&&y==24)
                {ok=true;out();exit(0);}
            dfs(t+1);
            l--;top--;
            //4.除法
            a=sum[i];b=sum[j];
            if(a<b) swap(a,b);
            if(a%b==0)
            {
                y=a/b;num[++top]=y;sum[++l]=y;
                if(t==3&&pd()&&y==24)
                {ok=true;out();exit(0);}
                dfs(t+1);
                l--;top--;
            }
            use[j]=false;
            top--;
        }
        top--;
        use[i]=false;
    }
}
int main()
{
    for(int i=1;i<=4;i++)
    {cin>>sum[i];}
    dfs(1);
    if(!ok) {
        cout<<"No answer!"<<endl;
        return 0;
    }
}
```

---


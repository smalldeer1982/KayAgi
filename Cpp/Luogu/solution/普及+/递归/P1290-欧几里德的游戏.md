# 欧几里德的游戏

## 题目描述

欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 $M$ 和 $N$，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 $0$。然后是 Ollie，对刚才得到的数，和 $M,N$ 中较小的那个数，再进行同样的操作……直到一个人得到了 $0$，他就取得了胜利。下面是他们用 $(25,7)$ 两个数游戏的过程：

- 初始：$(25,7)$；
- Stan：$(11,7)$；
- Ollie：$(4,7)$；
- Stan：$(4,3)$；
- Ollie：$(1,3)$；
- Stan：$(1,0)$。

Stan 赢得了游戏的胜利。

现在，假设他们完美地操作，谁会取得胜利呢？

## 说明/提示

$1 \leq C \leq 6$。

## 样例 #1

### 输入

```
2
25 7
24 15
```

### 输出

```
Stan wins
Ollie wins
```

# 题解

## 作者：Special_zyy (赞：287)

对于这道题，我们考虑什么样的状态（假设状态为（$x$，$y$）假定$y>=x$）可以使当前操作的这个人胜利，显然，当$x==y$时，当前操作的这个人必胜了；或者当y为x的倍数是，当前这个人也会获胜。除此之外呐？于是，我们接下来要考虑$x>y$（去掉$x==y$的情况）的情况。

**假设$y=kx+z$（z为余数）**

如果$k>=2$，那么该状态可以转移到（$x$,$y$-($k$-1)$x$）即($x$,$x$+$z$)，而($x$,$x$+$z$)(z要小于x的，因为z是余数)，只能转移到($x$,$z$)这一个状态，这个应该很好理解的。而（$x$,$y$）也可以直接转移到这个状态（$y$-$kx$），所以不论（$x$,$x$+$z$）这个状态还是其下一个状态（$x$,$z$）为必胜状态，($x$,$y$)均可到达，所以当$k>=2$时，当前操作者必胜。

如果$k<2$呢？那我们只好转到下一个人操作，我们再尝试在下一个人的状态中判断这个人是否必胜。因为$k<2$,
所以($x$,$y$)只能转到($z$,$x$)这个状态。那我们只要递归下去，知道找到必胜状态，返回当前操作者即可。

代码如下：
~~~cpp
#include <cstdio>
#include <iostream>
using namespace std;
int m,n,q;
//当前操作者为p,p为0时代表Stan操作,p为1时代表Ollie操作。
int find(int x,int y,int p)
{
	if(x==y) return p;//返回胜者.
	if(y/x>=2) return p;//返回胜者.
	else return find(y-x,x,p^1);//向下一个状态查找.
}
int main()
{
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		cin>>m>>n;
		if(m>n) swap(m,n);
		if(find(m,n,0)==0) cout<<"Stan wins"<<endl;//如果返回0,胜者为Stan,反之则为Ollie.
		else cout<<"Ollie wins"<<endl;
	}
	return 0;
	
}


~~~

---

## 作者：lowww666 (赞：83)

博弈题

看到这题就想到了SG函数

那么可以考虑最终情况：一个数是x，另一个是0，那么先手必败（因为上一个人已经得到0了，其实游戏已经结束了）

剩下的情况：一个数n， 一个数m，假设n>m

那么根据题意，SG(n,m)=mex{SG(n - m, m), SG(n - 2m, m), ......, SG(m, n%m)（此处交换了顺序，因为m>n%m）}

考虑里面的SG怎么求。

可以发现，SG(n-m, m)=mex{SG(n-2m, m), SG(n-3m, m)........SG(m, n%m)}

SG(n- 2m, m)同理

所以除了SG(m, n%m)以外的SG都可以由SG（m, n%m）得来


假设SG(m, n%m)==0，设n/m=k， SG(n-(k-1)\*m,m)==mex{SG(m, n%m)}=1

从此往上一直到SG(n, m)的值为2,3,4,5...，即一直必胜，简单记为1

如果SG（m, n%m）==1， 那么 SG(n-(k-1)\*m,m)==mex{SG(m, n%m)}=0

剩下的依旧为2,3,4,5,6...，也可记为1


那么可以看出，如果n/m==1，SG(n, m)=！SG(m, n%m)，不然是1

这是一个标准的辗转相除的一个递推式，用GCD的写法即可实现


代码：




```cpp
#include <cstdio>
#define min(a, b) (a<b? a : b)
#define max(a, b) (a<b? b : a)
int T, m, n;
bool solve(int n, int m)
{
    if (!m)return false;
    if (n/m == 1)return !solve(m, n%m);
    else return true;
}
int main()
{
    scanf("%d", &T);
    for (int xx = 1; xx <= T; xx++)
    {
        scanf("%d%d", &n, &m);
        if (solve(max(n, m), min(n, m)))
            printf("Stan wins\n");
        else
            printf("Ollie wins\n");
    }
}
```

---

## 作者：「QQ红包」 (赞：60)

黄金比例

如果两个数相等，或者两数之比大于斐波拉契数列相邻两项之比的极限 $\frac{\sqrt{5}+1}{2}$，则先手胜，否则后手胜。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long  
using namespace std;
int main()
{
    int i,c,a,b,m,n,k;
    cin>>c;
    for (i=1;i<=c;i++)
    {
        scanf("%d %d",&m,&n);
        if (m==n) printf("Stan wins\n");
        else
        {
            if (m<n)
              {
                if ((n*1.0)/m>(sqrt(5)+1)/2)
                    printf("Stan wins\n");
                else   
                    printf("Ollie wins\n");
            }
            else 
            {
                if ((m*1.0)/n>((sqrt(5)+1)/2))
                    printf("Stan wins\n"); 
                else   
                    printf("Ollie wins\n");
            }
       }
    }
    return 0;
}

```

---

## 作者：xiejinhao (赞：53)

#  P1290 欧几里德的游戏 题解

### ~~说实话我是不小心就 AC 了……~~


------------

看到这样的取数游戏，问先手是否有必胜的策略，我们可以考虑什么情况下先手必胜。

在本题中，我们为了方便规定 $X$，$Y$ 为两个操作数，并且满足 $X>Y$。

那么先手必胜当且仅当经过几轮之后：

$$X\text{ mod } Y=0(\text{轮到先手操作})$$

我们先不管谁会赢，我们考虑把题目给出的两个数变为0的最小操作次数。这里的操作次数定义为：进行一次减法运算为一次操作。比如 $(7,2)$ 变为 $(3,2)$ 需要操作 $2$ 次，变为 $(1,2)$ 需要操作 $3$ 次。

那么若要使 $X,Y$ 中的一者变为 $0$， 考虑每次 $X,Y$ 大小发生变化，会发生如下的操作：$X=X\text{ mod }Y$，为了符合上面所做的规定，我们交换 $X,Y$，每次大小发生变换对操作次数的贡献为 $\left \lceil\frac{X-Y}{X}\right\rceil $。

- **提示**：**下面所说的先后手与先后操作并不矛盾**。**先后手指的是**一开始操作的人是先手还是后手，**即我们用先手和后手代表人**；而**先后操作是**到当前的这个状态轮到哪一个人**先或后操作**，即为**操作顺序**。（可能有点绕……但是为了防止误解还是说一下）

我们考虑每一次 $X,Y$ 大小发生变化的时候，操作次数对胜负会造成什么样的影响。假设现在 $X\text{ mod }Y=0$，已经是必胜局面，不妨假定此时轮到先手操作，我们对所有局面进行**逆推**，如果最终结果与一开始先手一致，则可说明先手必胜，否则假设不成立，先手没有必胜策略。

考虑当前状态为转变到 $X\text{ mod }Y=0$ 的上一步，令此时操作次数为 $k=\left \lceil\frac{X'-Y'}{X'}\right\rceil $，接下来分类讨论：

1. $k=1$，此时只能操作一次，那么当前一定是后手操作。

2. $k>1$，考虑如何使得 $X\text{ mod }Y=0$ 时是先手操作。如果当前后手操作，则存在一种方案，可以让后手操作完后 $k'=1$，此时先手操作必定会使必胜局面 $X\text{ mod }Y$ 让给了后手，这样后手就必胜了。所以如果下次次是必胜的局面，当前要必胜，那么只能让先手操作。因为先手操作后同理可以使 $k'=1$，即后手对 $X$ 减去一个 $Y$ 之后就轮到先手，且满足 $X\text{ mod }Y=0$，先手就赢了。

- 注意上面全部推论保证 $X>Y$，若出现 $X<Y$ 的情况应该交换两者再继续。

显然上面的推论不止适用于当前状态下一步 $X\text{ mod }Y=0$ 的情况。我们注意到$X\text{ mod }Y=0$ 此时即为先手，即当前操作的人必胜，所以上面推论可以扩展到当前局面的下一个局面为先手必胜状态的情况。


因为我们要知道下一个状态，所以这也是一开始**逆推**的原因，具体可以使用递归实现。我们假设下一步是先手必胜，也就是先手操作一定赢的情况（否则一定输），翻译成代码实现是这样的:

```cpp
bool solve(int X, int Y) { 
	//返回值：0当前操作的是先手  1 当前的是后手
	if(X < Y) Swap(X, Y);
	if(X % Y == 0) return 0;
	//……
	if(solve(X % Y, Y) == 0) { 
		// 上一次操作要求先手来 
		if((X - 1) / Y > 1) return 0;
		return 1;	
	}	
}
```
这里还运用到一个数论小知识：$\left\lceil\frac{a}{b}\right\rceil=\left\lfloor\frac{a+b-1}{b}\right\rfloor$，所以$\left \lceil\frac{X-Y}{X}\right\rceil = \left\lfloor\frac{(X-Y)+Y-1}{X}\right\rfloor$。

接下来我们考虑上一步情况先手必败的情况，也就是后手操作先手才能赢，对应上面代码的程序返回值应为 $0$，令此时操作次数为 $k=\left \lceil\frac{X'-Y'}{X'}\right\rceil $：

1. $k=1$，那么仍然只能选择当前先手操作（因为只能操作一次）。

2. $k>1$，考虑当前后手操作，后手一定可以操作到这一步的下一种状态，也就是 $X,Y$ 的大小发生了改变。这样的状态即当前状态的下一步，本来应该后手操作先手才能必胜的，但是如果这一步是后手先操作，那么这个状态就变成了先手操作，那么先手就必败了。所以当 $k>1$ 时，只能让先手操作，否则后手必胜。

所以我们得到了当前步下一步为先手操作必胜还是后手操作必胜的所有情况。我们仍按照上面代码的 $0,1$ 规则进行编号（$0$代表这一步先手操作，$1$代表后手操作），令每一步的胜负状态为 $S_i$，当前步的下一步为 $Next_i$，则当前状态 $i$ 的后继状态就是 $S_{Next_i}$，当前的 $X,Y$ 分别记为 $X_i,Y_i$，那么令 $k_i=\left \lceil\frac{X_i-Y_i}{X_i}\right\rceil$。

那么：

- 若 $S_{Next_i}=0$，即下一步先手操作则先手必胜，那么：

> 结论1. $S_{Next_i}=0,k_i=1$，则 $S_i=1$；

> 结论2. $S_{Next_i}=0,k_i>1$，则 $S_i=0$；

- 若 $S_{Next_i}=1$，即下一步后手操作则先手必胜，那么：

> 结论3. $S_{Next_i}=1,k_i=1$，则 $S_i=0$；

> 结论4. $S_{Next_i}=1,k_i>1$，则 $S_i=0$。

观察上面的部分，发现对于所有状态 $S$，唯有$S_{Next_i}=0,k_i=1$，则 $S_i=1$ 的情况当前需要后手操作，所以我们可以得到下面这样一个很简洁的代码：

```cpp
bool solve(int X, int Y) { 
	//1 当前后手
	//0 当前先手 
	if(X < Y) Swap(X, Y);
	if(X % Y == 0) return 0;
	if(!solve(X % Y, Y) && (X - 1) / Y == 1) 
		return 1;
	return 0;	
	// 这个 (X-Y)/Y 上取整等于 (X-Y+Y-1)/Y下取整
	// 在题解里已经强调过了 
}
```
（你们可能注意到 $Swap$ 函数的 $S$ 是大写的了，因为是我手写的……）

（~~核心代码都出来了不会你们还想要完整代码吧……~~）


------------

 - 别急，没看懂？那我带你来模拟一遍。

首先我们列出了所有状态：

![](https://i.loli.net/2019/11/21/DnroLUelzCaT5N6.jpg)

这张图中我们左边放的是 $X$，而右边放的是 $Y$。

显然最终状态是 $X=3,Y=1$，规定这个状态的值为 $S_4=0$，也就是先手在 $X=3,Y=1$ 的时候操作。

1. 那么我们开始推 $4,3$ 的 $S$ 值。此时有 $k_3=\frac{4-1}{3}=1$（为什么减 $1$ 的已经说过很多次了）。那么因为 $S_{Next_3}=S_4=0$，满足上面的第一条规律，所以 $S_3=0$。

2. 继续，$S_{Next_2}=S_3=1$，$k_2=\frac{7-1}{4}=1$，满足第 $3$ 条规律，所以 $S_2=0$。

3. 快结束了！$S_{Next_1}=S_2=0$，$k_1=\frac{25-1}{7}=3$，满足第 $2$ 条规律，所以 $S_1=0$，即开始使先手会必胜，所以样例第一个输出了 "Stan wins"。

- ~~下面为了减少语言表述~~，我直接放上第二组样例的一张图，大家自己模拟一下：（~~绝对不是因为我懒得写~~）

![](https://i.loli.net/2019/11/21/pSPQu3svnrxZ5ka.jpg)

- 注意到最后推出来初始状态先手需要后操作，但是我们规定初始状态先手必须先操作，所以先手没有必胜的策略，那么输出 "Ollie wins" 即为答案。

（都画了这么多图了总该理解了吧……）

其实上面那一段代码还有可以优化时间的地方，具体的会在下面完整程序中体现。

（~~说好不给完整程序的呢？~~）

（~~啊！真香……~~）


------------

- ## $Code$


```cpp
#include<bits/stdc++.h>
using namespace std;

void Swap(int &X, int &Y) {
	X ^= Y, Y ^= X, X ^= Y;
}

bool solve(int X, int Y) { 
	//1 当前后手
	//0 当前先手 
	if(X < Y) Swap(X, Y);
	if(X % Y == 0) return 0;
	
	if((X - 1) / Y > 1) return 0; 
	if(solve(X % Y, Y)) return 0;
	return 1;	
}

int main() {
	int T, X, Y;
	scanf("%d", &T);
	while(T--) {
		scanf("%d %d", &X, &Y);
		if(solve(X, Y)) puts("Ollie wins");
		else puts("Stan wins");
	}
	return 0;
}
```

$End$
------------
### 点个赞好嘛 $QwQ$ （~~我好无耻啊……~~）

---

## 作者：ninedays9九天 (赞：34)

来说一下这个我对这题的看法。

###### 首先，这个题目让我想到一个以前拿棋子的游戏，一堆棋子，你一次可以拿1-4个，双方轮流取，看谁先取到最后一颗。对于这个呢，是先取者必赢，因为你只要把你取完后的棋子控制在5的倍数即可（1+4）.

- 这道题呢和上面那个游戏很像，但是却又两种情况，对于先取的stan，只要一开始时a大于b的两倍，便可一直把a刚好大于b,又不大于2b的情况一直控制在手里，然后就是通过控制取的倍数来决定后面一种死磕的情况。

- 所谓死磕，就是在取的时候只有一种方法，a与b的情况为a/b=1（/为整除）

- 这个时候就要看剩下还会取多少轮，而stan可以通过直接把a减到比b小，也可以减到比a刚好b大一点，让对手再减一次

- 综上所述，stan先，且a>2b，则stan必赢，如a<2b就要看死磕的轮数了。

- 附上代码，参下。


```cpp
#include"iostream"
#include"cstdio"
#include"cstdlib"
#include"cmath"
using namespace std;
int main()
{
    long long c;
    cin >> c;
    for (long long i = 0;i<c;i++)
    {
        long long a, b;
        cin >> a >> b;
        if (a < b)
        {
            swap(a, b);//检验大小
        }
        if (a / b>1)
        {
            cout << "Stan wins" << endl;//a div b>1 的情况stan 必赢
            continue;
        }
        short turn = 1;
        while (a/b==1&&a%b!=0)//一上来就死磕的情况
        {
            a %= b;
            if(a<b)
                swap(a, b);
            turn = 0-turn;
        }
        
        if (turn == 1)
            cout << "Stan wins"<<endl;
        else
            cout << "Ollie wins"<<endl;

    }
    return 0;
}


 


```
谢谢，第一次写题解。


---

## 作者：CreeperK (赞：31)

看到下面有些dalao的证明十分严谨（然而也有点萌新不友好），却也有一些dalao过程不是那么严谨（请原谅我的措辞）。

#### 所以我决定写一篇稍稍平均一点的题解，即尽力做到清楚地解释。

这道题有一个很快的方法。记当前状态为$d(i,j)$，且$i>j$，若此时$i>=2j$，则目前的操作者胜利。下面是证明：

假定$i=kj+l$，其中$l$ = $i$ % $j$，$k$ = $i$ div $j$，根据假设，$k>=2$，此时讨论$d(j,l)$的可能情况：

若$d(j,l)$为必胜状态（即当时的操作者有必胜策略），则当前操作者（即$d(i,j)$状态下的操作者）可以转移到$d(j+l,j)$（取$k-1$堆小的，由于$k>=2$，肯定可以取到）。

此时，轮到对手操作。因为必须要取正整数堆较小的，所以只能转移到$d(j+l-j,j)$即$d(j,l)$这个必胜状态上。那么，当前的操作者胜利。

若$d(j,l)$为必败状态，其实是类似的，可以直接转移从$d(i,j)$至$d(j,l)$，把必败状态留给后手。得证！

因此，在搜索时向后的决策就只有一个了：若$i>=2j$，则当前操作者胜；反之转移至$d(j,i-j)$，继续一样的操作。

这种方法的时间复杂度是多少呢？不难发现，当$i$和$j$为斐波那契数列的相邻两项时，所需次数最多。得出，复杂度上界略大于$O(logn)$。肯定是不会炸的！

下面是代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dfs(int a,int b,int p){//0表先手(1),1表后手(2);
    if(b==a)return 1;//等于也直接胜利
    if(b/a>=2)return 1;//不小于2直接胜利
    else return 1^dfs(b-a,a,p^1);//继续往下，轮到对手
}
int n,m,t;
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&m);
        if(n>m)swap(n,m);
        if(dfs(n,m,1)==0)printf("Ollie wins\n");
        else printf("Stan wins\n");
    }
}
```

---

## 作者：lamboo (赞：6)

这两个数相减**只有两种情况

1、一种是一个数小于另一个数的2倍（只减一次）

2、另一种情况是一个数大于等于另一个数的2倍（减多次）**

当出现情况1时，只有一种操作方法，当前这个人就是减完

当出现情况2时，两个人都有可能把这个数减完

**先遇到情况2的人必定胜利**

因为如果自己减完输了，那么就让对方减完

如果自己减完赢了，那么就让自己减完

不管怎样，自己必胜

接下来附代码（C++）


```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n,x,y,w,t;
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        w=0;t=0;
        scanf("%d%d",&x,&y);
        while ((x!=0)and(y!=0))  //相减
        {
            w++;
            if (x>y) 
            {
                if ((x/y>1)and(t==0)) t=w;  //t保存先出现情况2的是谁
                x=x%y;  //使x比y小
            }
            else 
            {
                if ((y/x>1)and(t==0)) t=w;
                y=y%x;
            }
        }
        if ((t%2==1)or(t==0)and(w%2==1)) printf("%s\n","Stan wins");  
                //如果Stan先遇到情况2，或只有情况一，且操作次数为单数，那么他就赢了
        else printf("%s\n","Ollie wins");
    }
    return 0;
}****
```

---

## 作者：gryql (赞：5)

解法一：

黄金比例

如果两个数相等，或者两数之比大于斐 波拉契数列相邻两项之比的极限（(sqrt(5)+1)/2），则先手胜，否则后手胜。


解法二：

给定两堆石子,二人轮流取子,要求只能从石子数目较大的那一堆取子,取子的数目只能是另一堆石子数目的倍数.最终使得某一堆数目为零的一方为胜.


首先,容易看出,对于每一个局面,要么是先手必胜,要么是后手必胜,最终结果完全由当前局面完全确定.


另外,可以简单罗列一下先手必胜和必败的几种局面(两堆石子初始数目都大于零):


1,有一堆石子数目为一,先手必胜,  1,4,    1,2.

2,两堆石子数目差一,且两堆石子数目都不为一,先手必败(只能使后手面对必胜的局面),如  3,4  5,6   .

3,如果数目较大的那一堆是数目较小那一堆的2倍加减一,且不是上面两种局面,先手必胜,2,5  3,5  3,7.


可是上面这些信息对于解决这个问题还是有一些困难.


再进一步试算数目较小的石子,可以发现,当两堆数目相差较大时,总是先手必胜.

事实上,进一步探讨可以发现下面的结论:


1,N<2\*M-1时,先手别无选择,只能使之变为 N-M,M 局面,(易见)如3,5  5,7  7,4...


2,设两堆石子数目为N,M(N>M>0,且N,M互质),则若N>=2\*M-1,且N - M ! =1时,先手必胜.要求M,N互质是因为对于M,N有公因数的情形,可以同时除以其公因数而不影响结果.


简单说明一下上面结论2的由来. N>=2\*M-1时,先手可使之变为  N%M,M  或N%M+M,M两种局面之一,其中有且只有一个必败局面。注意到如果N%M,M不是必败局面，那么N%M+M,M就是必败局面，因为面对N%M+M,M这个局面，你别无选择，只能在前一堆中取M个使对方面对必胜局面(结论1 )。


PASCAL程序：http://www.cnblogs.com/yangqingli/p/4898876.html


---

## 作者：婷菡 (赞：3)

#### 题目链接[P1290 欧几里德的游戏](https://www.luogu.org/problem/P1290)

```
题目描述
欧几里德的两个后代Stan和Ollie正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25，7)两个数游戏的过程：

Start：25 7

Stan：11 7

Ollie：4 7

Stan：4 3

Ollie：1 3

Stan：1 0

Stan赢得了游戏的胜利。

现在，假设他们完美地操作，谁会取得胜利呢？

输入格式
第一行为测试数据的组数C。下面有C行，每行为一组数据，包含两个正整数M, N。（M, N不超过长整型。）

输出格式
对每组输入数据输出一行，如果Stan胜利，则输出“Stan wins”；否则输出“Ollie wins”

输入输出样例
输入 #1复制
2
25 7
24 15
输出 #1复制
Stan wins
Ollie wins
```
对于这一题

我们设当前两个数字的组合为${(a,b)}$(a>=b)

显而易见当a=b时先手必胜

因此我们只讨论**a>b**的情况

我们设${a=k*b+c}$(k=${\lfloor{a/b}\rfloor}$,c为余数)

易知对于当前状态${(k{*}b{+}c,b)}$可以转移到{ ${((k{-}1){*}b{+}c,b)}$, ${((k{-}2){*}b{+}c,b)}$,...,${(b{+}c,b)}$,${(b,c)}$ }

此时如果**k>1**则对于该状态来说先手必胜

证明:

若k>1,则一定可以将状态${(k{*}b{+}c,b)}$转移至 ${(b{+}c,b)}$或${(b,c)}$ 

而对于状态${(b,c)}$有两种可能——必胜状态或必败状态

1. 当${(b,c)}$为必败状态时,则可以转移到该状态的${(k{*}b{+}c,b)}$一定为必胜状态

2. 当${(b,c)}$为必胜状态时,由于c<b(因为c是余数),则${(b+c,b)}$只能转移到${(b,c)}$,

	即${(b+c,b)}$为必败状态,因为${(k{*}b{+}c,b)}$可以转移到该状态,所以${(k{*}b{+}c,b)}$一定为必胜状态
    
证毕.

因此,我们得出一个结论

```
当a!=b,且a>2*b(保证k>1)时,(a,b)为必胜状态,即先手必胜

```

接下来讨论当**k==1**的情况

此时状态为${(b{+}c,b)}$

而对于这种状态,我们只能转移到${(b,c)}$状态

而对于${(b,c)}$我们令${b{=}k{*}c{+}d}$

则状态可化为${(k{*}c{+}d,c)}$,而这与我们之前讨论的情况类似

因此对于该状态,若k>1则谁取谁就必胜,否则转移到${(c,d)}$再进行上述讨论

放代码


```cpp
#include<bits/stdc++.h>
using namespace std;

int read(){
  int p=0;char c=getchar();
  while(c<'0'||c>'9')c=getchar();
  while(c>='0'&&c<='9')
  p=(p<<3)+(p<<1)+c-'0',c=getchar();
  return p;
}

int T,n,m,x,ans;

int main(){
  T=read();
  while(T--){
    n=read();m=read();
    ans=1;//1为S取,0为O取
    if(n<m)swap(n,m);//n始终为大数
    if(n==m){//若相等,则S胜
      printf("Stan wins\n");
      continue;
    }
    while(n<2*m){//若n<2*m,即n=m+c
      n-=m;
      if(n<m)swap(n,m);//n为大数
      ans^=1;//换人取
    }
    if(ans)printf("Stan wins\n");//在必胜状态若S取,则S胜
    else printf("Ollie wins\n");//同理
  }
  return 0;
}

```




---

## 作者：Tanktt (赞：3)

突然发觉博弈论的题目都好短……

其实这道题只要模拟了样例就已经知道了大概了~~我就这么做的~~。如果a/b>1了，那么stan是先手，一定能在其中做一些手脚赢得胜利（第一个样例），而且只要存在就可以输出stan了。否则就要看轮数了，不断递归下去，每次返回的判断都要取否，因为换了一个人，就要变换输赢。就如辗转相减法，直到y=0时就返回0.

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,x,y;
inline bool check(int x,int y)
{
	if (!y) return 0;
	if (x/y!=1) return 1;
	return !check(y,x-y);
}
int main()
{
	scanf("%d",&n);
	for (int i=1; i<=n; i++)
	{
		scanf("%d%d",&x,&y);
		if (x<y) swap(x,y);
		if (check(x,y)) printf("Stan wins\n");
		else printf("Ollie wins\n");
	}
}
```

---

## 作者：maomao9173 (赞：2)

#### 每次只能就题论题，我感觉自己还是离博弈论入门太远了啊QWQ

 这个题目单独拉出来的话，思路还是相当好懂的，但是对思维能力的要求，应该是和难度标签不符的，这里本蒟蒻为大家提供一种更有趣的思维方式。

#### 实际上我们并不需要考虑后面的可能情况。对于任意一个人，只要他当前拿到了x/y>1的情况，他就有了掌控后面所有局面的机会。因为这样，他就拥有了两种选择：可以选择把x缩小到y的范围内，也可以是缩小到x/y==1的情况下（其他情况最终也可以归于此），从而就控制了全局的选择。而同时由于这个局面也包括了后面自己或者对手拿到x/y>1的机会，只要拿到首个机会就必胜，所以我们只需要考虑谁第一次拿到x/y>1的情况。

#### 思路可能相对清奇，需要仔细理解。

```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#define lint long long
using namespace std;
lint T,xx,yy;
int main(){
    scanf("%lld",&T);
    while(T--){
    	scanf("%lld%lld",&xx,&yy);
        if(xx<yy)swap(xx,yy);//保证前面大于后面便于运算 
        
        bool To=true;//轮到谁（第一轮默认STAN） 
        while(xx/yy==1 and xx-(xx/yy)*yy!=0){//预先处理二者无法决定的情况 
            To=!To;//交换回合
            xx=xx-(xx/yy)*yy;
            if(xx<yy)swap(xx,yy);
        }
		//第一次非1或者最终结果轮到谁，谁就赢。 
        if(To)puts("Stan wins");//第一次非1轮到stan 
        else puts("Ollie wins");//否则 
    }
    return 0;
}
```

---

## 作者：__stdcall (赞：2)

楼下几位dalao分析的很好，但是完全没有必要那么复杂

首先，能一眼看出来必胜状态为(kb,b)，其中k为正整数

当状态为(a,b)，其中b<a<2b的时候，显然只有一种决策，即(b,a-b)

当状态(a,b)中，a>2b的时候，一次可以减掉k\*b，这时候有很多种情况，是不是每种都要考虑呢？

不是的，假如给定数据(100000001,2)

这时候如果每个人都考虑a-2的情况的话，一个很大的数字就会在两个人之间来回转手

看两个人这样“踢皮球”是没有什么意思的，于是就有如下的方法：

对于(a,b)，a>2b，有两种决策：

一种是把a减到b<a<2b的范围内，这样就是对手下一步只有一种决策(b,a-b)

一种是减到a<b的范围内，这样就是我们选了对手的那个决策(b,a-b)

于是情况就少很多了，直接dfs就可以了

完



```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
bool dfs( ll a, ll b ) {
    if( a%b == 0 ) return true;
    if( a < (b<<1) ) { // 只有一种决策
        if( dfs( b , a-b ) ) return false;
        else return true;
    }
    else {
        if( dfs( a%b+b , b ) == false ) return true;
        if( dfs( b , a%b ) == false ) return true;
        return false;
    }
}
int main() {
    int c; cin>>c;
    while(c--) {
        ll a,b; cin>>a>>b;
        if( dfs( max(a,b) , min(a,b) ) ) printf( "Stan wins\n" );
        else printf( "Ollie wins\n" );
    }
    return 0;
}

```

---

## 作者：o0数学迷0o (赞：2)

显然这游戏在有限步内必然结束且没有平局, 所以在某一局势下, 要么先手必胜, 要么后手必胜, 不会有其它可能性. 为简便起见, 我们把使得将要行动的一方(当前先手)可胜的局势称作N局势, 否则称作P局势, 所以一个局势要么是N局势要么是P局势. 显然, 一名玩家若能使自己行动之后的局势为P局势, 则他即可获胜. 不妨设在中途某一局势(x,y), x>y(x=y则显然先手可胜, 没有多大意义), 轮到玩家A行动. 首先我们注意到, 当x>=2y时, 这个局势一定是N局势(换言之玩家A可赢). 这是因为, 如果x是y的倍数则显然A可赢, 若不是, 设x%y=m, 则m<y. 我们考虑局势(y,m). 若这是一个P局势, 则玩家A只需将x减少到m即可获胜; 若这是一个N局势, 则玩家A可将x减少至y+m(因为x>=2y>y+m), 这样局势变成(y+m,y), 玩家A的对手被迫把局势变成(y,m), 而此时轮到A行动, 又是N局势, 所以此时玩家A赢. 我们看到, 不论如何玩家A均能赢. 所以只要一个局势(x,y)满足x>=2y, 则这局势必然是N局势. 另外, 若局势(x,y)满足y<x<2y, 则当前行动者只有一种选择, 即走到(y,x-y). 所以我们的算法可以设计如下:

```cpp
bool N(int x,int y){ //判断是否先手胜, 默认x>y 
  if(x>=2y)
    return true;
  else return !N(y,x-y);
}
```
当然实际实现未必写成递归, 也可以写成循环, AC代码如下:







```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
typedef char* ST;
const ST S="Stan wins",O="Ollie wins";
int m,n,t,c;
ST winner;
void reverse(ST& winner){
    winner==S?winner=O:winner=S;
}
int main(){
    ios::sync_with_stdio(0);
    cin>>c;
    for(int i=0;i<c;++i){
        winner=O;
        cin>>m>>n;
        if(m<n)t=m,m=n,n=t;    
        for(;n>0;t=m%n,m=n,n=t){
            reverse(winner);
            if(m/n>1)goto next;
        }
        next:cout<<winner<<endl;
    }
    return 0;
}
另外, 此算法若适当辅以高精度, 个人觉得对数据范围n,m<=10^10000之类的也不在话下.
```

---

## 作者：顾z (赞：2)

给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。
    
         此时对于样例24 15
         Start： 24 15
         S：9  15
         O：9  6
         S：3  6
         O：3  0
         则Olive获胜。
        通过枚举一些情况不难发现 如果n/m==1，则另一人获胜。
        eg：7  6
        S： 1  6
        O： 1  0
     如果持续出现这种情况 每次"！"即可
     
对于n/m！=1的情况：

我们可以有目的的选择所减数来保证自己获胜

策略：
取走（n/m-1）*m        
得到（n%m+m，m）的状态。
此时对方只能取走m，
而我们可以每一局都选取状态。
——————————————————————————————摘自《信息奥赛数学一本通》
```cpp
//#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<map>
#include<queue>
#include<vector>
#include<stack>
#define ll long long
#define ull unsigned long long
#define inf 2147483647
#define IL inline
#define RI register int
using namespace std;
int T,n,m;
IL void read(int &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
IL void print(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)	print(x/10);
	putchar(x%10+'0');
}
int main()
{
	read(T);
	for(;T;T--)
	{
		read(m),read(n);
		bool f=true;
		if(m<n)swap(m,n);
		while(m/n ==1 && m%n)
		{
			//cout<<m<<" "<<n<<endl;
			//cout<<endl;
			int t=m%n;
			m=n;
			n=t;
			f=!f;
		}
		if(f)printf("Stan wins\n");
		else printf("Ollie wins\n");
	}
}
```

---

## 作者：ARZhu (赞：1)

只需要考虑是否$x \leq 2y,x>y$，如果成立，那么就有两种选择，那么必胜；否则就$x = x-y$，直到判定胜负。当然，判定胜负也有是否满足$x\equiv0(\mod y)$

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int check( int x, int y ) {
    if( x < y ) swap( x, y );
    if( x >= ( y << 1 ) || x % y == 0 ) return 1;
    else return !check( x - y, y );
}
void work() {
    int x, y; scanf( "%d%d", &x, &y );
    if( check( x, y ) ) puts( "Stan wins" );
    else puts( "Ollie wins" );
}
int main() {
    int T; scanf( "%d", &T );
    while( T -- ) work();
    return 0;
}
```

---

## 作者：Skywalker_David (赞：1)

如果m>=2\*n  由于stan有多种选择，所以无论如何stan都获胜；


当m<2\*n,stan只能选择m=m-n;如果此时又有 n>=2\*m 则ollie获胜。


如果n<2\*m,则也只有一种选择，就进行n=n-m;


也就是说当存在max>=2\*min,则出现必赢状态，若不出现，则用欧几里德预判进行了几次直至结束，判断谁赢了。

```cpp

#include <iostream>  
using namespace std;  
int main()  
{  
    int m;  
 cin>>m;  
 while(m--)  
 {  
     int i,j;  
  cin>>i>>j;  
  int maxn=max(i,j);  
  int minn=min(i,j);  
  int k=0;  
  while(minn>0)  
  {  
      int t=maxn%minn;  
   if(t==0||maxn>2*minn)break;  
   maxn=minn;  
   minn=t;  
   k++;  
  }  
  if(k%2==0)  
   cout<<"Stan wins";  
  else  
   cout<<"Ollie wins";  
  cout<<"\n";  
 }  
 return 0;  
}

```

---

## 作者：谬悠 (赞：0)

这道题目本萌新望着题解想了好久才想出来

出于或许有些人和我一样萌新的考虑，其他题解的证明过程对于像我这种蒟蒻来说太过困难QWQ

所以我想来简化一下思路，降低思维难度

我们设有n和m两堆石子，且n>m，很明显如果m==0，那么先手必胜惹

接着我们来考虑一下n与m的关系

如果n/m==1的话，那么无论如何我们都只有一种方案

例如n=9，m=7，我们只能把n中拿去m个

而拿走以后并不能直接判断出来，所以需要继续递推，此时轮到另一个人摸石头，注意状态要反着标

然后就是n/m>1的情况惹

我们设 n=k*m+a，这里的k即为n/m的结果，a代表取光后剩余数量

而很明显我们能一次达成必胜条件，即从n中拿走（k-1）*m个，此时n=a+m，此时再次轮到对手，对手无可奈何因为此时的n/m==1!

他只能悲惨地把剩下的m拿走，容易得到m==1的情况，此时先手胜//想一想，如果m%a==0即结束

关于代码，那些神仙写得非常好惹，我就不献丑了QAQ

---

## 作者：邱彦祖 (赞：0)

  我们设计一个这样的函数，该函数需要3个参数，分别为较大的数、较小的数、和该轮玩家（玩家用0和1来表示），这个函数返回最后的赢家。
  我们发现，当a为b的倍数的时候（a为较大的数，b为较小的数），赢家为当前的玩家，我们把<a,b>称为当前玩家面临的状态，由于两个玩家的水平相当，那么最后的赢家只与当前的状态有关，也就是说，面对同一个a和b，该轮轮到玩家1如果可以赢，那么如果该轮轮到玩家2，玩家2也可以赢。
  
  因此，我们可以得到下面的一个结论：
  当a>2* b 的时候，当前玩家一定可以赢；
  
  证明，当a>2 * b 的时候，考虑较大数为b，较小数位a%b的情况，即<b,a%b>,这种情况如果是先手赢，那么当前玩家可以构造出<c，b>的局面，其中b<c < 2* b,那么，下一个玩家只能用c减去b，为当前玩家构造出 <b，a%b>的局面。如果<b,a%b>的局面先手会输，那么，当前玩家只需要为下一个玩家构造出 <b,a%b>的必输的局面，因此，结论成立。
  
  根据此结论，我们不难得出一下程序。

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
int play(int a,int b,int turn);

int main()
{
    int T,k;
    long long a,b;

    cin >> T;
    while(T--)
    {
        cin >> a>>b;
        if(a>b)
            k = play(a,b,0);
        else k = play(b,a,0);
        if(k==0)
            printf("Stan wins\n");
        else printf("Ollie wins\n");
    }
    return 0;
}
int play(int a,int b,int turn)
{
    if(a%b==0)
        return turn;

    if(a>2*b)
        return turn;

    return play(b,a%b,!turn);
}

```

---

## 作者：707001933K (赞：0)

第一次发题解，希望能对大家有所帮助。

对于这个问题，m每次可以减去n的整数倍，

我们分下面几种情况讨论：

1.m-n<n,也就是m只能减去n\*1,这是状态是唯一的，模拟辗转相减法就可以得出胜负。

2.m-n>n,对于这种情况看似很复杂，因为不确定m可以减去n的几倍后才会得到情况1，

但其实细细分析，我们假设情况1是必胜态

a.如果n\*(k+1)>m>n\*k,如果直接m-n\*k，就得到情况1，当前的人必胜

b.如果减去n\*(k-1),那么下一个人只能减去n，那么下一个人就处在情况1，当前的人必输

c.如果减去n\*(k-2)，那么下一个人会采取优策略，因为情况1是必胜，所以他减去n\*2后就得到情况一，当前的人必输。

d.如果减去n\*(k-3)......，道理可同c

那么当情况一是必输态时呢？

a.这是唯一的状态，

b.此时下一个人处在情况1，当前的人必胜

c.减去n\*(k-2)实际上是在给下一个人喘息的机会，他完全可以再减去n，那么当前的人就处在情况一必输，这明显不是最优策略

也就是说

情况2当前的人必胜

而情况1模拟即可。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    int T;
    scanf("%d",&T);
    while (T--){
        int n,m;
        bool f=true;
        scanf("%d%d",&n,&m);
        for (;;){
            if (n<m)swap(n,m);
            if (n%m==0 || n-m>m)break;
            n-=m;f=!f;    
        }
        if (f)printf("Stan wins\n");
        else printf("Ollie wins\n");
    }
    return 0;
}

```

---

## 作者：licone (赞：0)

博弈+扩展欧几里得算法~

从题目就可以看出来这道题要用扩展欧几里得算法~

对于两组石子x,y（x>y，且x/y=k），可以一次性取出y，y\*2，y\*3，…，y\*k颗石子，对于取石子的人来说，如果以后有必胜策略，就一次性取y\*k颗石子，如果必输，就剩下一组，使得另一人只能取走剩下的y颗，由此可以看出遇到k>1的人必胜。

所以就先预处理，把石子分为几堆，每堆数量表示k的值，循环直到k！=1，就输出。

（其实我觉得这题挺难的怎么是普及/提高-啊）


  
  
```cpp
#include<cstdio>  
#include<iostream>  
using namespace std;  
int x,y,a[100001],now;  
int main()  
{  
    scanf("%d",&n);
    while(n--)  
    {   scanf("%d%d",&x,&y);
        if(x<y) swap(x,y);now=1;a[0]=0;  
        while(now)  
        {  
            a[++a[0]]=x/y;now=x%y;  
            x=y;y=now;  
        }now++;  
        for(int i=1;i<=a[0] && a[i]==1;i++) now++;  
        if(now>a[0])  
        {  
            if(now%2) printf("Ollie wins\n");  
            else printf("Stan wins\n");  
        }  
        else  
        {  
            if(now%2) printf("Stan wins\n");  
            else printf("Ollie wins\n");  
        }  
    }  
    return 0;  
}
```

---

## 作者：Lance1ot (赞：0)

## 真·做题全凭感性

---------------

从题目中很容易看出

这是一道$Gcd$的题

同时又结合了一些略略的博弈论（丢下锅跑真爽

我们看，辗转相减的$a,b$一共只有两种情况

- $a-b<b,a>b$，就是$a$比$b$大，但是比$b $的两倍小，这种情况时。我们的$S$和$O$君就只能硬着头皮去~~舰~~减了。

- $a>2b$，就是a比b的二倍大。这时候我们的$S$和$O$君就需要ta们的大脑进行一波~~用命~~分析~~-1s,-1s~~。

- PS：a b是变量

因为$a>2b$,所以我们的$S$和$O$君就可以有两种选择

1. 将a减成小于b，就是进行辗转相除的过程。

2. 让位，就是在正常进行游戏的前提下，将现在的状态转移给对手(a>b or a < b)。

3. 通过上面两种骚操作，他肯定就能赢了。

到此，我们就大体分析van了。

另外因为是$S$和$O$君都是极其聪明的(-1s,-1s,用命分析)

所以我们可以看做他们是已经知道自己做出选择后的结果的。

上代码
```
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
bool dfs(int a,int b,int who)
{
	if(b==0)//van的游戏结束
		return false;//当前人fail
	if(a/b==1)//第一种情况，只能硬着头皮上
		return !dfs(b,a-b,who^1);
	if(a/b>1)
	{
		/*if(dfs(b,a%b,who^1))//如果我们将a变成小于b的情况，然后对手赢了，我们就可以改命
			return true;//改命
		else
			return true;//如果对手输了，那是更好不过了
		ps：我这里写的有些不大严谨233*/
		return true;//上面的返回都是true
        //至于为什么可以怎么写，一方面是我们利用上面的归纳法总结出来的233
        //也可以这么想，拿到这种情况的人，是可以可以控制a,b的大小的。
        //也就是控制了游戏局数，就像你买了一个5000~6000的挂，神仙一样，为所欲为。（逃
	}
}
int main()
{
	int k;
	scanf("%d",&k);
	int a,b;
	while(k--)
	{
		scanf("%d%d",&a,&b);
		if(a<b)
			swap(a,b);//保证a>b
		if(dfs(a,b,1))//简单的判断，第三个参数其实没有的，只是我调试用的。
			printf("Stan wins\n");
		else
			printf("Ollie wins\n");
	}
}
```

---


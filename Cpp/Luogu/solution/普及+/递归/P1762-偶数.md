# 偶数

## 题目描述

给定一个正整数 $n$，请输出杨辉三角形前 $n$ 行的偶数个数对 $1000003$ 取模后的结果。


## 说明/提示

对于 $30\%$ 的数据，$n\le 4\times 10^3$。

对于 $70\%$ 的数据，$n\le 4\times 10^9$。

对于 $100\%$ 的数据，$1\le n\le 10^{15}$。

杨辉三角形的前七行：

```plain
       1
      1 1
     1 2 1
    1 3 3 1
   1 4 6 4 1
 1 5 10 10 5 1
1 6 15 20 15 6 1
```

## 样例 #1

### 输入

```
6
```

### 输出

```
6
```

# 题解

## 作者：kkksc03 (赞：127)

打出杨辉三角形前若干行的奇偶分布情况，便会发现这是一个分形图形。这样就可以用递归解决问题。具体实现时可以直接计算，也可以先算总个数再减去奇数的数量（比较好算）。用扩展欧几里德或欧拉定理来解决除法取模问题，或是直接用高精计算，最后取模。

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
using namespace std;
long long n,i,f[200],j,t,s;
long long p=1000003,l,k,pp;
long long aa(long long n)
{
     long long i=2LL,j=1LL,q;
     if (n<=2) return 0;
     while (i*2<=n){i=i*2;j++;}
     return (2*aa(n-i)%p+f[j+1]-2*f[j]%p-((i*2-n)%p)*((i*2-n-1)%p)*l+p*p*p)%p;
}
int main()
{
    cin>>n;f[1]=0;i=2;j=1;
    k=2;l=1;pp=p-2;
    while (pp>0)
    {
          if (pp%2==1) l=l*k%p;
          k=k*k%p;pp=pp/2;
    }   
    while (i<=n)
    {
          j++;s=i%p;t=s*(s-1)%p;
          f[j]=((f[j-1]*3%p)+((i%p)*((i-1)%p)%p)*l)%p;
          i=i*2;
    }
    cout<<aa(n);
    system("pause");
    return 0;
}


```

---

## 作者：笨笨猪 (赞：112)

**各位oier如果没有自己进行过认真推算与规律的寻找的话，**

**建议先避免阅读该篇题解！**

**因为通过思考，你会自己发现很多杨辉三角的巧妙规律的。**


**杨辉三角是美丽的数学结晶，其结论往往多蕴含自然之美。**

正如这题所示，数据在n<=10^15的范围内则引导我们去寻找空间更节省，速率更高效的算法。

首先，很明显，杨辉三角之特点在于其**行数等于每行的数字数**。因此，可以很容易使用求和公式求出1到n行一共有多少个数字。

其次，通过观察，可以发现，奇数个数比偶数个数更有规律，其规律在于：


**1.**每行奇数个数一定为2^k（k为自然数）

**2.**当行数恰为2^k（k为自然数）时，奇数个数为2^k，偶数个数为零

**3.**当行数恰为2^k（k为自然数）时，奇数个数和恰为3^(k-1)

**4.**更巧妙的是：这个规律能更加扩展到一个不为2^k的数上，因为每一个数，都能分解为若干项2^k的和的形式。


举个例子吧：当n=2333;

**2333 = 2048+256+16+8+4+1**

通过暴力程序，我们可以找出2333的所有奇数个数为190985

那么，我们找出如下数字

```cpp
    行数     所有奇数个数
    2048    177147
    256        6561
    16        81
    8        27
    4        9
    1        1
```
我们可以发现：

**177147×1 + 6561×2 + 81×4 + 27×8 + 9×16 + 1×32 恰好等于 190985！**

那么，通过以上的探索，我们就能通过对n的分解，求出奇数总个数。

所以，偶数总个数也就不难得出了。


**5.    **这样，我们就将一个看起来很困难的大量数求和，降级为极具规律性的数学公式求法。问题也顺理成章转化为如何将一个数分解为若干项2^k的和的形式。通过分析，我们知道算法的复杂度是O(logn)级的，足够通过所有的数据。

**6.    **这道题目构思精巧，逻辑严密，能够告诉我们规律的寻找是一个漫长的探索过程，但是一旦得出了规律，世间万物自然水落石出！这个算法的正确性能够通过数学证明的，此处不赘述。

**7.    **不要忘了膜题目要求的数字哦！


下面附探索规律的表格：

```cpp
行数    该行奇数    奇数和    偶数    偶数和    总数
1     (    1)        1        0        0        1
2     (    2)        3        0        0        3
3     (    2)        5        1        1        6
4     (    4)        9        0        1        10
5     (    2)        11        3        4        15
6     (    4)        15        2        6        21
7     (    4)        19        3        9        28
8     (    8)        27        0        9        36
9     (    2)        29        7        16        45
10     (    4)        33        6        22        55
16     (    16)        81        0        55        136
32     (    32)        243        0        285        528
64     (    64)        729        0        1351        2080
128     (    128)    2187        0        6069        8256
256     (    256)    6561    0    26335    32896
512     (    512)    19683    0    111645    131328
1024     (    1024)    59049    0    465751    524800
2048     (    2048)    177147    0    1921029    2098176
4096     (    4096)    531441    0    7859215    8390656
```
下面附探索规律的辅助程序：

```cpp
#include <cstdio>
using namespace std;

int t, i, j, ou, line, e, tot;
int mp[10005][10005];
int judge(int x)
{
    int v=1;
    while (v<x)
    {
        v *=2;
    }
    if (v==x) return 1;
    else return 0;
}
int main()
{
    freopen("yanghui.txt","w",stdout);
//    Input an integer in 10000!
    scanf("%d",&e);
    mp[1][1]=1;
    ou = line = 0;
    tot = 1;
//行数(该行总数) 该行奇数 所有奇数 该行偶数 所有偶数 总数
    printf("    1     1      1     0     0     1\n");
    for (i=2; i<=e; ++i)
    {
        line=0;
        for (j=1; j<=i; ++j)
        {
            mp[i][j]=mp[i-1][j-1]+mp[i-1][j];
            if (mp[i][j]%2==0) ++line;
        }
        ou += line;
        tot += i;
        if (judge(i)==1)//保留该行可只查看N=2^k(k为自然数）的结果，若省略则查看所有结果 
        printf("%5d %5d %5d %5d %5d %5d\n", i, i-line, tot-ou, line, ou, tot);
    }
    return 0;
}
```
附参考主程序：

```cpp
#include <cstdio>
#define mo 1000003
using namespace std;

long long n, d, z, ans, a[55], b[55], v, p;
int i, t;
int main()
{
    scanf("%lld",&v);
    n = v;
    z = 1;
    d = z << 50; //因为2^50恰好大于10^15
    t = 50;
    while (n != 0)
    {
        if (n >= d)
        {
            n = n-d;
            a[++a[0]] = t; //将2^t 的t存入数组中
        }
        d /= 2;
        t--;
    }
    
    b[0] = 1;
    for (i=1; i<=a[1]; ++i)
        b[i]=(b[i-1]*3)%mo; //进行预处理，准备好3^t 的数字在数组b中
    
    for (i=1; i<=a[0]; ++i)
        ans += b[a[i]]*(long long)(z << i-1); //求所有奇数个数的和
    
    p = (((z+v%mo)*(v%mo))/2); //求和公式
    p %= mo;
    ans %= mo;
    if (p<ans) p += mo;
    p = (p-ans)%mo; //总个数减去所有奇数个数就是偶数个数了
    printf("%lld\n",p);
    return 0;
}
```

---

## 作者：Weng_Weijie (赞：35)

题解：

实质是求$C_n^m\equiv0\pmod2$的数量

根据卢卡斯定理

$C_n^m\mod2$相当于把$n,m$在二进制下分解，如果有一位$n$是$0$，$m$是$1$，答案是$0$否则是$1$

考虑计算$C_n^m\equiv1$的数量，则$m$是$n$的子集，即$m \space\mathrm{and} \space n = m$

容易发现数量是$2^{\mathrm{popcount}(n)}$

就是要求$\sum_{i=0}^{n-1}2^{\mathrm{popcount}(i)}$

然后可以用数位dp求这东西

代码（巨丑）：
```cpp
#include <cstdio>
#include <cstring>
int f[60];
const int mod = 1E6 + 3;
using LL = long long;
LL n;
void up(int &x, int y) { if ((x += y) >= mod) x -= mod; }
int dfs(int dep, bool lim) {
	if (!~dep) return 1;
	if (!lim && ~f[dep]) return f[dep];
	int up = lim ? n >> dep & 1 : 1;
	int ret = 0;
	for (int i = 0; i <= up; i++) {
		::up(ret, dfs(dep - 1, lim && i == up) * (i + 1) % mod);
	}
	if (!lim) f[dep] = ret;
	return ret;
}
int main() {
	std::memset(f, -1, sizeof f);
	std::scanf("%lld", &n);
	n--; int ret = dfs(50, 1);
	ret = (n + 1) % mod * ((n + 2) % mod) % mod * (mod + 1) / 2 % mod - ret;
	if (ret < 0) ret += mod;
	std::printf("%d\n", ret);
	return 0;
}
```

---

## 作者：woshiluo (赞：24)

题目一看...

杨辉三角？

%2意义下的面积？

输出一下看看吧
```
1 
1 1 
1   1 
1 1 1 1 
1       1 
1 1     1 1 
1   1   1   1 
1 1 1 1 1 1 1 1 
1               1 
1 1             1 1 
1   1           1   1 
1 1 1 1         1 1 1 1 
1       1       1       1 
1 1     1 1     1 1     1 1 
1   1   1   1   1   1   1   1 
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
1                               1 
1 1                             1 1 
1   1                           1   1 
1 1 1 1                         1 1 1 1 
1       1                       1       1 
1 1     1 1                     1 1     1 1 
1   1   1   1                   1   1   1   1 
1 1 1 1 1 1 1 1                 1 1 1 1 1 1 1 1 
1               1               1               1 
1 1             1 1             1 1             1 1 
1   1           1   1           1   1           1   1 
1 1 1 1         1 1 1 1         1 1 1 1         1 1 1 1 
1       1       1       1       1       1       1       1 
1 1     1 1     1 1     1 1     1 1     1 1     1 1     1 1 
1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 

```
*这是在每一位都`%2`后只输出`1`后得到的结果*

好好看啊wq

你为什么不试试在这里面找找规律呢？

我们可以很明显的观察到，每一个三角形都是由下面一个三角形所叠加出来的
```
1
11
```
每个第$ 2^i $ 行，就是一个三角形的结尾

每个第$ 2^i $ 行，就是由三个第 $ 1 $ 到 $ 2^{i-1} $的三角形组成

看起来第$ 2^i $ 行的结果我们可以算出来:

$$ f(1)=1 $$
$$ f(i) = f(i/2)*3  $$

整理一下: 
第 $ 2^i $ 行有 $ 3^{i-1} $ 个`1`

恩，快速幂大法解决就可以

问题在于，不是$2^i$的怎么办？

恩，先打表找规律吧>_<

```
    1 : 1                1 
    2 : 1 1                3 
    3 : 1   1                5 
    4 : 1 1 1 1                9 
    5 : 1       1               11 
    6 : 1 1     1 1               15 
    7 : 1   1   1   1               19 
    8 : 1 1 1 1 1 1 1 1               27 
    9 : 1               1               29 
   10 : 1 1             1 1               33 
   11 : 1   1           1   1               37 
   12 : 1 1 1 1         1 1 1 1               45 
   13 : 1       1       1       1               49 
   14 : 1 1     1 1     1 1     1 1               57 
   15 : 1   1   1   1   1   1   1   1               65 
   16 : 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1               81 
   17 : 1                               1               83 
   18 : 1 1                             1 1               87 
   19 : 1   1                           1   1               91 
   20 : 1 1 1 1                         1 1 1 1               99 
   21 : 1       1                       1       1              103 
   22 : 1 1     1 1                     1 1     1 1              111 
   23 : 1   1   1   1                   1   1   1   1              119 
   24 : 1 1 1 1 1 1 1 1                 1 1 1 1 1 1 1 1              135 
   25 : 1               1               1               1              139 
   26 : 1 1             1 1             1 1             1 1              147 
   27 : 1   1           1   1           1   1           1   1              155 
   28 : 1 1 1 1         1 1 1 1         1 1 1 1         1 1 1 1              171 
   29 : 1       1       1       1       1       1       1       1              179 
   30 : 1 1     1 1     1 1     1 1     1 1     1 1     1 1     1 1              195 
   31 : 1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1              211 
   32 : 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1              243 
```

随便推一个吧qwq

14?

首先先找到2的次幂--8

ans+=27

剩下的相当于是 第6层 ×2 

以此类推qwq

以下是代码
```cpp
#include <cstdio>
#include <cmath>

const long long mod=1000003;

long long sum,ans,n;

inline long long lowbit(long long x){return x&(-x);}

inline long long ksm(long long a,long long p){// 标准快速幂
	long long res=1,base=a;	
	while(p){
		if(p&1) res=(res*base)%mod;
		base=(base*base)%mod;
		p>>=1;
	}
	return res;
}

long long dfs(long long now){
	long long tmp=lowbit(now);// lowbit 用于快速找到第一个我可以分层的地方
	if(tmp==now){
		ans=ksm(3,(std::log(now)/std::log(2)));// tmp==now 说明 now 是 2的次幂 （ log 快速求指数)
		return 2; // 翻倍
	}
	else{
		long long tmp1=dfs(now-tmp);// 剪掉算过的
		ans=(ans+tmp1*ksm(3,(std::log(tmp)/std::log(2))))%mod;
		return tmp1*2;
	}
}

int main(){
	scanf("%lld",&n);
	dfs(n);
	if(n%2==0) sum=(((1+n)%mod)*((n/2)%mod))%mod;
	else sum=((((1+n)/2)%mod)*(n%mod))%mod;
    // 都说这个地方要乘法逆元之类的高端操作...我就直接暴力了
	printf("%lld",((sum-ans)%mod+mod)%mod);
}

```

---

## 作者：Leap_Frog (赞：14)

# P1762偶数（题解）

$$\Large\color{turquoise}\texttt{PS.}$$
此题关于杨辉三角，所以应该是数论。  
但是像我这种菜鸡，只能暴力打表出奇迹了。  
然后突然发现，好像自己打出了最短的题解。  

$$\Large\color{turquoise}\texttt{solution}$$
首先，对于$\texttt{n}$比较小的数据可以打出一个表。  
打表辅助程序如下，相当于$\texttt{O(n}^\texttt{2}\texttt{)}$暴力解决  
```cpp
#include<bits/stdc++.h>
#define lowbit(x) ((x)&(-(x)))
using namespace std;
const int N=15;
int a[2][10005],ans[10005],tr[10005];
int main()
{
	memset(a,0,sizeof(a)),tr[0]=tr[1]=0;
	for(int i=0,tot=0;i<=N;i++,tot=0)
	{
		a[i&1][0]=1;
		for(int j=1;j<=i;j++) a[i&1][j]=a[1-(i&1)][j]+a[1-(i&1)][j-1];
		for(int j=0;j<=i;j++) a[i&1][j]&=1;
		for(int j=0;j<=i;j++) tot+=1-(a[i&1][j]&1);
		tr[i]=tr[i/2]+lowbit(i)/2,ans[i]=tot;
		for(int j=0;j<=i;j++) printf("%c%c",a[i&1][j]?'*':'.',j==i?'\n':' ');
//		printf("%d:%d\n",i+1,ans[i]);
	}
	return 0;
}
```
打出来的表如下
```
*
* *
* . *
* * * *
* . . . *
* * . . * *
* . * . * . *
* * * * * * * *
* . . . . . . . *
* * . . . . . . * *
* . * . . . . . * . *
* * * * . . . . * * * *
* . . . * . . . * . . . *
* * . . * * . . * * . . * *
* . * . * . * . * . * . * . *
* * * * * * * * * * * * * * * *
```
然后，发现它是一个分形图形，于是我们考虑用递归求解。  
设我们当前要处理的三角形边长为$\texttt{n}$，答案为$\texttt{f(n)}$，那么  
$$\texttt{f(n)}=\left\{\begin{aligned}\texttt{3}^\texttt{k}\qquad\qquad\quad\qquad\texttt{(n=2}^\texttt{k}\texttt{且k}\in\mathbb{N}\texttt{)}\\\texttt{f(2}^\texttt{k}\texttt{)+f(n-2}^\texttt{k}\texttt{)}\quad\texttt{(2}^\texttt{k}\texttt{<=n<=2}^\texttt{k+1}\texttt{且k}\in\mathbb{N}\texttt{)}\end{aligned}\right.$$  
于是，这个$\texttt{f(n)}$可以用递归法加上快速幂求解。  
当然也可以预处理出所有$\texttt{3}^\texttt{k}$。  

$$\Large\color{turquoise}\texttt{Coding}$$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll QY=1000003;
inline ll lowbit(ll x) {return x&(-x);}
inline ll upbit(ll x) {for(ll i=1;;i<<=1) if(i>=x) return i/2;return 0;}
inline ll qpow(ll a,ll q) {ll ans=1;for(;q;q>>=1,a=a*a%QY) if(q&1) ans=ans*a%QY;return ans;}
inline ll dfs(ll x)
{
	if(lowbit(x)==x) return qpow(3,(ll)(log(x)/log(2)));
	return (qpow(3,(ll)(log(upbit(x))/log(2)))+2*dfs(x-upbit(x))%QY)%QY;
}
int main()
{
	ll n,sum;
	scanf("%lld",&n),sum=n%2?(n%QY)*((n+1)/2%QY)%QY:(n/2%QY)*((n+1)%QY)%QY;
	printf("%lld\n",((sum-dfs(n))%QY+QY)%QY);
	return 0;
}
```

---

## 作者：attack (赞：6)

题解楼下已经讲的很清楚了

这里提供一种非常简洁的写法

在二进制分解一个数的时候，我们没必要把这个数存到一个数组里

仅仅用位运算就可以解决了


```cpp
// luogu-judger-enable-o2
#include<cstdio>
#define int long long 
const int mod = 1000003;
inline int read() {
    char c = getchar();int x = 0,f = 1;
    while(c < '0' || c > '9'){if(c == '-')f = -1;c = getchar();}
    while(c >= '0' && c <= '9'){x = x * 10 + c - '0',c = getchar();}
    return x * f;
}
int B[62], N;
int fastpow(int a, int p) {
    int base = 1;
    while(p) {
        if(p & 1) base = (base * a) % mod;
        a = (a * a) % mod; p >>= 1;
    }
    return base % mod;
}
main() {
    N = read();
    int tot = (N % mod) * ((N % mod) + 1) / 2, now = 1;
    for(int i = 61; i >= 0; i--)
        if(N & (1ll << i)) //判断第i位是否存在 
            tot = (tot - fastpow(3, i) * now % mod + mod) % mod, now = (now % mod * 2) % mod;
    printf("%lld", tot % mod); 
}
```

---

## 作者：塔罗兰 (赞：3)

dalao们早已给出规律，下面为依照规律打出的精简版代码
```cpp
#include<bits/stdc++.h>
#define ll unsigned long long//有了这个就不用使用高精，unsigned为非负整型可将支持数据范围提高一倍，减低代码时间复杂度。
using namespace std;
const ll MOD=1000003;
ll a[100],b[100],n,sum,num,l(1),i;
int main()
{
	b[0]=1;
	for(i=1;i<100;i+=1)
	b[i]=b[i-1]*3%MOD;//预处理3的幂
	scanf("%lld",&n);
	num=(n%MOD)*(n%MOD+1)/2%MOD;//n层总共有的数
	for(i=0;n;i+=1)
	{
		if(n&1)
		a[i]=1;
		n=n>>1;
	}//将n二进制化
	for(;i>0;i-=1)
	if(a[i])
	sum+=b[i]*l,sum%=MOD,l=l<<1;//记录奇数个数
	if(a[i])
	sum+=b[i]*l,sum%=MOD,l=l<<1;//由于i为非负整型，所以放在for里会出错
	if(num>=sum)
	printf("%lld",num-sum);
	else
	printf("%lld",MOD+num-sum);//保证不会有MOD后总数小于奇数数
}
```
才28行！是不是简单易懂？

---

## 作者：i207M (赞：3)

看到大家的做法，大部分都是大眼找规律，但是在考场上，一时找不着规律怎么办？于是我们可以比较暴力的解决；

根据Lucas定理可知，$C^m_n$为奇数当且仅当$n\&m=m$，于是就好说了：

我们数位DP出，二进制下有i个1的数字个数，它们对答案的贡献就是$cnt\times 2^i$，因为n的每一个1位，都可以对应一个1或0的m；

于是就简单轻松的搞定了；

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<string>
#include<cstring>
#include<queue>
#include<set>
#include<map>
#include<bitset>
using namespace std;
#define ri register int
#define LL long long
#define il inline
#define mp make_pair
#define pb push_back
#define pairint pair<int,int>
#define fi first
#define se second
#define gc getchar
template<class T>il void in(T &x)
{
    x=0;bool f=0;char c=gc();
    while(c<'0'||c>'9') 
    {
        if(c=='-') f=1;
        c=gc();
    }
    while(c>='0'&&c<='9') x=x*10+(c^'0'),c=gc();
    if(f) x=-x;
}
#undef gc
#define int LL
#define md 1000003
int n;
int ans;
int qpow(int a,int b)
{
	int res=1; a%=md;
	for(;b;b>>=1,(a*=a)%=md)
		if(b&1) (res*=a)%=md;
	return res;
}
// 0 - 50
int f[51][51];
int dig[51],cnt;
int dfs(int x,int num,bool jud)
{
	if(num<0) return 0;
	if(x<=0) return num==0;
	if(!jud&&~f[x][num]) return f[x][num];
	int res=dfs(x-1,num,jud&&(dig[x]==0));
	if(!jud||dig[x]==1)
		(res+=dfs(x-1,num-1,jud&&(dig[x]==1)))%=md;
	if(!jud) f[x][num]=res;
	return res;
}
signed main()
{
#ifdef M207
    freopen("in.in","r",stdin);
#endif
	in(n);
	int tmp=n-1;
	while(tmp) dig[++cnt]=tmp&1,tmp>>=1;
	memset(f,-1,sizeof f);
	for(ri i=0;i<=cnt;++i)
		(ans+=dfs(cnt,i,1)*qpow(2,i))%=md;
	n%=md;
	ans=((n+1)*n/2%md-ans+md)%md;
	printf("%lld",ans);
    return 0;
}
```

---

## 作者：codecode (赞：3)

如果这篇题解 $\LaTeX$ 锅了就请到[我的博客](https://www.luogu.com.cn/blog/codecodeakioi/solution-p1762)里看吧QwQ。


------------


#### 题解：

由于前 $n$ 行的数总数固定，故我们可以考虑先计算奇数的个数，再用总数减去奇数个数。

我们假定杨辉三角从第 $0$ 行开始。

记 $n$ 在二进制表示下各位数字和为 $F(n)$，由卢卡斯定理，第 $n$ 行中奇数的个数为 $2^{F(n)}$。于是，前 $n$ 行奇数个数为

$$\sum_{i=0}^{n-1} 2^{F(i)}$$

对于一般的 $n$，上式并不好处理，我们可以先考虑 $n=2^k$ 时的情形。

在 $0$ 到 $2^{k}-1$ 中，二进制表示下各位数字和为 $i$ 的有 $C_k^i$ 个，故前 $2^k$ 行中奇数个数为（后一个等号应用生成函数公式）

$$\sum_{i=0}^{2^k-1}2^{F(i)}=\sum_{i=0}^{k}C_k^i2^i=3^k$$

那么对于一般的 $n$，上式启发我们将其二进制拆分。设 $n=\sum_{i=0}^{w-1}2^ia_i(a_i \in \{0,1\})$。

设 $a_{w-1},a_{w-2},...,a_0$ 中有 $a_{k(1)},a_{k(2)},...,a_{k(t)}(k(1)>k(2)>...>k(t))$ 是 $1$。

记 $S(x)=2^{k(1)}+2^{k(2)}+...+2^{k(x)}$，特别地，$S(0)=0$。

在这种假设下，有

$$
\begin{aligned}

\sum_{i=0}^{n-1} 2^{F(i)}& =\sum_{j=1}^{t}\sum_{i=S(j-1)}^{S(j)-1}2^{F(i)} \\

& =\sum_{j=1}^{t}2^{j-1}\sum_{i=S(j-1)}^{S(j)-1}2^{F(i-S(j-1))} \\

& =\sum_{j=1}^{t}2^{j-1}\sum_{i=0}^{2^{a_{k(j)}}-1}2^{F(i)} \\

& =\sum_{j=1}^{t}2^{j-1}\times3^{a_{k(j)}}

\end{aligned}
$$

我们可以预处理 $2$ 的幂次和 $3$ 的幂次。

于是我们在 $\Theta(\log n)$ 的时间复杂度里计算出了答案。

在以上推理过程中，应当注意第 $n$ 行和前 $n$ 行的区别，如果不理解，可以思考为什么代码中是对 $n$ 二进制拆分而不是 $n-1$。

其它详见代码。

```
#include<bits/stdc++.h>
#define int long long //一个小技巧
using namespace std;

const int mod=1e6+3;
int n,ans,cnt,cnt2,a[55]={1},c[55]={1},b[35];
//a为3的幂次，c为2的幂次，b为n的二进制拆分

signed main(){
	cin>>n;
	int n1=n%mod,n2=(n1*(n1+1)/2)%mod;
	//这样可以避免求逆元地算出总数
    
	for(int i=1;i<=50;i++)
		a[i]=(a[i-1]*3)%mod;
	for(int i=1;i<=50;i++)
		c[i]=(c[i-1]*2)%mod;
	while(n)b[cnt]=n&1,cnt++,n/=2;
	//预处理&二进制拆分
    
	for(int i=cnt-1;i>=0;i--){
		if(!b[i])continue;
		ans+=c[cnt2]*a[i],ans%=mod;
		cnt2++;
	}//套公式计算

	cout<<((n2-ans)%mod+mod)%mod;
	return 0;
}
```


---

## 作者：Megumi_Cold (赞：3)

容易看出是一个分形图

设m是n以内最大的2的次方数,f(n)表示n行以内的偶数个数.

不难发现,对于每个n,f(n)可以转化为f(m)+2f(n-m)+中间一块的梯形面积(上底,下底和高都能通过n和m求出).

因此通过递归,将n转化为n-m,运行次数即为n用二进制表示的1的个数.

由于需要用到f(2^k),故先预处理出2^k的函数值

P.S. 注意梯形面积要先mod后乘,否则会变成1e6*1e14,会爆long long

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define MOD 1000003
using namespace std;
unsigned long long n,sta[201],pow_;
unsigned long long log_(unsigned long long x)
{
	unsigned long long t,tot;
	t=1;
	tot=0;
	while(t*2<=x)
	{
		t*=2;
		tot++;
	}
	return tot;
}
unsigned long long power(unsigned long long a,unsigned long long b)
{
	unsigned long long ans,tmp;
	tmp=a;
	ans=1;
	while(b>0)
	{
		if(b&1)
		ans=(ans*tmp)%MOD;
		tmp=(tmp*tmp)%MOD;
		b>>=1;
	}
	return ans;
}
unsigned long long power_(unsigned long long a,unsigned long long b)
{
	unsigned long long ans,tmp;
	tmp=a;
	ans=1;
	while(b>0)
	{
		if(b&1)
		ans=ans*tmp;
		tmp=tmp*tmp;
		b>>=1;
	}
	return ans;
}
unsigned long long get_ans(unsigned long long x)
{
	if(x==1||x==0)
	return 0;
	get_ans(x-1);
	sta[x]=((sta[x-1]*3)%MOD+(((((power(2,x-1)%MOD)%MOD*((power(2,x-1)-1)%MOD)%MOD)%MOD)%MOD)%MOD*(power(2,MOD-2)%MOD)%MOD)%MOD)%MOD;
}
unsigned long long divide(unsigned long long x)
{
	if(x==2||x==1||x==0)
	return 0;
	unsigned long long t,pp;
	t=log_(x);
	pp=power_(2,t);
	return ((sta[t]%MOD+((divide(x-pp)%MOD)*2%MOD)%MOD)%MOD+((((pp*3-1-x)%MOD)%MOD*((x-pp)%MOD)%MOD)%MOD*((power(2,MOD-2)%MOD)%MOD)%MOD)%MOD)%MOD;
}
int main()
{
	sta[1]=0;
	scanf("%lld",&n);
	pow_=log_(n);
	get_ans(63);
	printf("%lld",divide(n));
}
```


---

## 作者：alecli (赞：2)

#### ~~这题可能是考我的取模能力~~

本题只考虑奇偶性，我们可以用1表示奇数，用0表示偶数打表。

观察前十六行

```cpp
1
1 1
1 0 1
1 1 1 1
1 0 0 0 1
1 1 0 0 1 1
1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 0 1
1 1 0 0 0 0 0 0 1 1
1 0 1 0 0 0 0 0 1 0 1
1 1 1 1 0 0 0 0 1 1 1 1 
1 0 0 0 1 0 0 0 1 0 0 0 1
1 1 0 0 1 1 0 0 1 1 0 0 1 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

```

发现这是一个分形图，分型图都能用递归解决。

对于 $2^k$ 行，可直接递归计算：
分成三个 $2^{k-1}$ 行和一个中间大三角形
例如当 $k = 3$
```cpp
1
1 1
1 0 1
1 1 1 1
1 0 0 0 1
1 1 0 0 1 1
1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
分成
1
1 1
1 0 1
1 1 1 1

0 0 0 
  0 0
    0
```

对于其余的行$n$，找到一个小于$n$的最大的$2^k$，分别计算前$2^k$行和$2^k$ ~ $n$行中的零。
对于 $2^k$ ~ $n$行，也可以换成两个小三角形和一个梯形，在此不多赘述，详见代码

给一个不带取模的递归函数


```cpp
ll work(ll n){
    if(n <= 2) return 0;
    if(n == 3) return 1;
    if(n == 4) return 1;
    ll now = 4;
    while((now<<1) <= n) now <<= 1;
    ll rest = ((2 * now - n) + (now - 1)) * (n - now) / 2;
    return (work(now / 2) * 3 + (now / 2) * (now / 2 - 1) / 2) + work((n - now)) * 2 + rest;
}
```

最后该取模的取模，该换逆元的换逆元，搞定。


---

## 作者：wanghanjun (赞：0)

原问题相当于求
$$C_i^j(0\leq i<n,0\leq j\leq i)$$
中偶数的个数


------------

经过试验可以发现
$$C_n^i(0\leq i\leq n)$$
中有2^k个奇数，其中k为n二进制形式中1的个数（最后给出证明）

于是原变成求
$$\sum_{i=0}^{n-1}k_i^2$$
其中ki为i二进制形式中1的个数

------------

我没想到好方法，直接用了一个倍增，每次考虑区间
$$[2^{a_1}+2^{a_2}+...+2^{a_k},2^{a_1}+2^{a_2}+...+2^{a_k}+2^{a_{k+1}})$$
其中
$$a_1>a_2>...>a_{k+1}$$
然后就很容易解决了，时间复杂度慢到O((logN)^3)

最后注意此处求的是奇数个数，需要用总数减一下

代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
ll a[55],n,ans=0,cnt=0,sum,p=1000003;

ll qpow(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1){
			res=res*x%p;
		}
		x=x*x%p;
		y=y>>1;
	}
	return res;
}

ll C(ll x,ll y){
	return a[x]*qpow(a[y],p-2)%p*qpow(a[x-y],p-2)%p;
}

int main(){
	cin>>n;
	sum=n%p*(n+1)%p;
	sum=qpow(2ll,p-2)*sum%p;
	a[0]=1;
	for(ll i=1;i<=50;i++){
		a[i]=a[i-1]*i%p;
	}
	for(ll i=50;i>=0;i--){
		if((1ll<<i)>n){
			continue;
		}
		for(ll j=0;j<=i;j++){
			ans=((1ll<<(j+cnt))%p*C(i,j)%p+ans)%p;
		}
		cnt++;
		n-=(1ll<<i);
	}
	cout<<(sum-ans+p)%p<<endl;
	return 0;
}
```
最后证明一下：

设n,i的二进制表达式分别为：
$$a_1 a_2 ...a_r,b_1 b_2...b_r$$

由卢卡斯定理可得：
$$C_n^i\equiv C_{a_1}^{b_1}*C_{a_2}^{b_2}*...*C_{a_r}^{b_r}(mod 2)$$

左式为奇数时

若ai为0，则bi必为0仅一种选择     
若ai为1，则bi为0或1有两种选择

所以，当n中有k个1时，有2^k个i使左式为奇数

---


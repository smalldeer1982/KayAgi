# [COCI 2020/2021 #1] Papričice

## 题目描述

给定一个 $n$ 个点的树，这 $n$ 个点编号为 $1$ 到 $n$。

现在要选择断掉两条边，会形成三个连通块，假设这三个连通块内的点数分别为 $a,b,c$，那么您要做的就是最小化 $\max\{a,b,c\}-\min\{a,b,c\}$ 的大小，求这个最小值。

## 说明/提示

#### 样例 1 解释

能构造的最优解三个连通块的点数都为 $1,1,2$，所以输出 $2-1=1$。

#### 样例 2 解释

断掉点 $1$ 到点 $3$ 的边，点 $3$ 到点 $5$ 的边，形成的三个连通块点数相同。

#### 样例 3 解释

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/nybys0n6.png)

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（15 pts）：$3 \le n \le 200$。
- Subtask 2（35 pts）：$3 \le n \le 2000$。
- Subtask 3（60 pts）：$3 \le n \le 2 \times 10^5$。

对于 $100\%$ 的数据，$1 \le x,y \le n$。

**本题满分 $110$ 分。**

#### 说明

翻译自 [Croatian Open Competition in Informatics 2020 ~ 2021 Round 1 D Papričice
](https://hsin.hr/coci/contest1_tasks.pdf)。

## 样例 #1

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
6
1 2
1 3
3 4
3 5
5 6```

### 输出

```
0```

## 样例 #3

### 输入

```
9
1 3
2 3
3 4
3 5
5 6
5 7
7 8
7 9```

### 输出

```
2```

# 题解

## 作者：DrBit (赞：21)

~~蒟蒻的第一篇题解~~

首先看到这种类似“切两刀”的描述就~~很容易~~想到固定其中一刀的位置再利用某种手段快速地求出第二刀的位置。

一个显而易见的结论：假设三个块的大小分别为$a$,$b$,$c$且$a$的大小固定时，$b$和$c$越接近答案越优。

设$siz[x]$表示$x$的子树大小。

那么就有一个思路：枚举其中一个点$x$，$x$的父边作为第一刀的位置，在剩下的树中找一个节点$y$，使得$siz[y]$尽可能接近$\frac{N-siz[x]}{2}$，在dfs过程中把每个计算过的点的$siz$值扔进一个set里然后二分一下就好了。

但我们很快发现上面这个做法在$y$是$x$的祖先节点的时候会出问题，因为这个时候$y$的贡献不是$siz[y]$而是$siz[y]-siz[x]$。其实也很好处理，在dfs过程中把当前节点的祖先节点放进一个栈里，其余的节点放进另一个栈里。在计算放祖先节点的栈统一减一个$siz[x]$就好了

ps:multiset的s.erase(x)操作是清除**所有**权值等于x的元素，要是只想删一个可以采取s.erase(s.find(x))的写法

~~马蜂略丑，求轻喷/kel~~

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<set>
using namespace std;
const int MAXN = 2e5 + 50;
const int INF = 0x3f3f3f3f;
multiset<int> s1, s2;
multiset<int>::iterator it;
int N, siz[MAXN], ans = INF;
struct edge
{
    int nxt, to;
} e[MAXN * 2];
int head[MAXN], edgetot;
int max(int a, int b, int c)
{
    return max(max(a, b), c);
}
int min(int a, int b, int c)
{
    return min(min(a, b), c);
}
void add(int x, int y)
{
    e[++edgetot].to = y;
    e[edgetot].nxt = head[x];
    head[x] = edgetot;
}
void pre(int x, int f)
{
    siz[x] = 1;
    for (int i = head[x]; i; i = e[i].nxt)
    {
        int v = e[i].to;
        if (v == f)
            continue;
        pre(v, x);
        siz[x] += siz[v];
    }
}
void upd(int x, int y)
{
    // cout << x << " " << y << endl;
    int c = N - x - y;
    int maxn = max(x, y, c);
    int minn = min(x, y, c);
    ans = min(maxn - minn, ans);
}
void dfs(int x, int f)
{
    if (!s1.empty())
    {
        it = s1.lower_bound((N - siz[x]) / 2 + siz[x]);
        //因为祖先栈中的值比实际的贡献值大siz[x]
        //所以二分的基准值要加上siz[x]
        if (it != s1.end())
            upd(siz[x], *it - siz[x]);
        if (it != s1.begin())
        {
            it--;
            upd(siz[x], *it - siz[x]);
        }
    }
    if (!s2.empty())
    {
        it = s2.lower_bound((N - siz[x]) / 2);
        if (it != s2.end())
            upd(siz[x], *it);
        if (it != s2.begin())
        {
            it--;
            upd(siz[x], *it);
        }
    }
    if (x != 1)
        s1.insert(siz[x]);
    //节点入dfs栈时将权值加入祖先栈中
    for (int i = head[x]; i; i = e[i].nxt)
    {
        int v = e[i].to;
        if (v == f)
            continue;
        dfs(v, x);
    }
    if (x != 1)
    {
        s1.erase(s1.find(siz[x]));
        s2.insert(siz[x]);
    }
    //节点出dfs栈时讲权值从祖先栈中移除加入另一个栈中
}
int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N - 1; ++i)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
    }
    pre(1, 0);
    dfs(1, 0);
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：thomaswmy (赞：19)

看题解区都没有无脑双 $\log$ 做法。

来写一发。

### [题目大意](https://www.luogu.com.cn/problem/P7165)

割掉两条边把一棵树分成三部分，让这三部分的最大值与最小值之差最小。

### 解法

首先答案显然有单调性，先二分一手，令答案 $\leq mid$。

则：

$$\max(\left\vert a-b\right\vert,\left\vert a-c\right\vert,\left\vert b-c\right\vert) \leq mid.$$

由于 $\left\vert a-b \right\vert = \max(a-b,b-a)$，可得到六个不等式。

又由于 $a+b+c=n$ 所以可以消去 $c$，仅剩下关于 $a$ 和 $b$ 的不等式。

注意到 $a, b, c$ 中在选择一个适当的根后必然有两个子树。

考虑枚举 $a$ 子树，则得到：

$$b\in [a-mid,a+mid]\cap[n-2a-mid,n-2a+mid]\cap[\frac{n-a-mid}{2},\frac{n-a+mid}{2}]$$

只要用一颗权值树状数组维护子树大小，在 dfs 过程中删去他祖先的答案，判断区间内是否有值就行了。

但是还有一个问题，$b$ 不能在 $a$ 的子树中，这对于自上而下的 dfs 不好维护。

考虑若 $b$ 在 $a$ 的子树中，则 $b$ 的子树大小严格小于 $a$ 的子树大小。

于是我们钦定枚举的 $a$ 子树大小比 $b$ 小，给 $b$ 的集合 $\cap [size_a,+\infty)$。

这道题目就做完了。

upd：这个做法好像有点蠢，但是就先放这里了。

[Code](https://www.luogu.com.cn/paste/j4p1khbj)

---

## 作者：LittleYang0531 (赞：9)

### 题目描述:

在花园忙碌了一个早上之后。M 先生决定用自己种的干辣椒奖励一下自己。 

M 先生有 $n$ 颗辣椒，这些辣椒由 $n-1$ 条线链接而成。任意两颗辣椒都可以通过若干条线连接起来。简单来说，这 $n$ 颗辣椒和这 $n-1$ 条线连接成了一棵树。 

M 先生今天要吃三顿饭，因此他需要剪断两条线。获得三串小的辣椒。每一顿饭需要使用一串辣椒。

显然，一顿饭不能太辣，因此他会选择一种分割方法，使得**辣椒最多的辣椒串和辣椒最少的辣椒串的数量差距最小。**你的任务就是求出这个最小的差距。

### 输入描述:

输入的第一行包含一个整数 $n(1\leq n\leq 2\times10^5)$，表示辣椒的数量。辣椒从1到 $n$ 编号。 

接下来的 $n-1$ 行，每行包括两个整数 $x$ 和 $y(1\leq x,y\leq n)$。表示由一条连接编号为 $x$ 的辣椒和编号为 $y$ 的辣椒的线。

### 输出描述:

输出一行，一个整数，即最小的最大辣椒串和最小辣椒串的数量差距。

### 分析:

#### 50Pts:

暴力枚举要删除的那两个点，然后计算这三个部分的点的数量并更新 $ans$ 的值就行了。

时间复杂度为 $O(n^2)$。

#### 100Pts:

假设我们已经切掉了点 $x$ 与其父亲节点所形成的的边，现在我们需要查找下一个需要删除的边究竟是哪一条。

分成两种情况考虑：

1.当另一条边在其祖先节点上，那么我们需要分出的另一个部分的节点数量最好为 $\frac{n-size[x]}{2}$。由于其祖先节点 $y$ 的 $size_y$ 包含了 $x$ 的子树下所有的节点，因此我们只需要找到 $x$ 的祖先节点中子树的节点数最靠近 $\frac{n+size[x]}{2}$ 的一个点并计算当前情况下的最终结果并将其与 $ans$ 比较即可。

2.当另一条边在已经被访问过的子树上时，我们只需要找到已经访问过的节点中子树的节点数最接近 $\frac{n-size[x]}{2}$ 的一个点并计算当前情况下的最终结果并将其与 $ans$ 比较。

至于如何查找，使用 multiset 自带的 lower_bound 函数即可。

时间复杂度为 $O(n\log_2n )$。

### 代码:

```c++
#include<bits/stdc++.h>
#define van long long
#define N 200010
#define ywhin cin
#define ywhout cout
using namespace std;
van n;vector<van> g[N];
bool used[N];van siz[N],ans=1e18;
multiset<van> father,son;
void init(van now)
{
//	cout<<now<<endl;
	used[now]=1,siz[now]=1;van v;
	for (int i=0;i<g[now].size();i++) if (!used[v=g[now][i]]) init(v),siz[now]+=siz[v];
}//计算子树中的节点数
void DFS(van now)
{
	used[now]=1;van v;
	multiset<van>::iterator it;van siz2,last,tmpans;
	if (!father.empty())
	{
		it=father.lower_bound((n-siz[now])/2+siz[now]);
		if (it!=father.end())
		{
			siz2=*it-siz[now];
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
		if (it!=father.begin())
		{
			it--;
			siz2=*it-siz[now];
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
	}//第一种情况
	if (!son.empty())
	{
		it=son.lower_bound((n-siz[now])/2);
		if (it!=son.end())
		{
			siz2=*it;
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
		if (it!=son.begin())
		{
			it--;
			siz2=*it;
			last=n-siz2-siz[now];
			tmpans=max(siz[now],max(siz2,last))-min(siz[now],min(siz2,last));
			ans=min(ans,tmpans);	
		}
	}//第二种情况
	if (now!=1) father.insert(siz[now]);//将自己加到祖先集合中
	for (int i=0;i<g[now].size();i++) if (!used[v=g[now][i]]) DFS(v);
	if (now!=1) father.erase(father.find(siz[now]));//将自己移除祖先集合
	if (now!=1) son.insert(siz[now]);//将自己移入已访问的节点的集合
}
int main()
{
	ywhin>>n;
	for (int i=1;i<n;i++)
	{
		van f,s;
		scanf("%lld %lld",&f,&s);
		g[f].push_back(s);
		g[s].push_back(f);
	}//建图
	init(1);
	memset(used,0,sizeof used);
	DFS(1);
	ywhout<<ans<<endl;
	return 0;
}
```



---

## 作者：Milmon (赞：5)

## 分类

首先对情况进行分类：

**情况一：** 一条边在根节点到另一条边的路径上；

**情况二：** 任意一条边不在根节点到另一条边的路径上。

只需要按此分类计算答案即可。

## 代码实现

考虑用两个 `multiset` 分别维护当前点**到根节点的路径上的点**的子树大小以及**不在**当前点到根节点的路径上的遍历过的点的子树大小，对于每个点 $u$，考虑选择其与其父亲相连的这条边作为其中一条断掉的边。

显然我们希望剩下两个连通块大小尽量接近，且它们的大小总和为 $n-s_u$（其中 $s_u$ 为以 $u$ 为根的子树大小），那么只需找到一个大小最接近 $\dfrac 12(n-s_u)$ 的部分即可。

特别的，对于情况一，因为要选择的边下的子树大小会包含点 $u$ 的子树，所以要找的大小应为最接近 $\dfrac 12(n-s_u)+s_u$ 的那个。

而查找可以使用 `multiset` 自带的 `lower_bound` 实现，只需要检验其前面的一项和它本身一项即可。

时间复杂度 $\Theta(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,answer=0x7ffffff;
struct Edge{
    int to,nxt;
}edge[400001];
int head[200001],cntEdge;
void addEdge(int u,int v){
    edge[++cntEdge]={v,head[u]},head[u]=cntEdge;
}

int siz[200001];
void calcSize(int id,int father){
    siz[id]=1;
    for(int i=head[id];i;i=edge[i].nxt)
        if(edge[i].to!=father){
            calcSize(edge[i].to,id);
            siz[id]+=siz[edge[i].to];
        }
}

multiset<int> hissiz,othsiz;
// hissiz: 路径上的所有点的子树大小集合
// othsiz: 其它支路上的所有点的子树大小集合

void work(int id,int father){
    if(!hissiz.empty()){
        // 取路径上的另一条边
        auto tmp=hissiz.lower_bound(siz[id]+(n-siz[id])/2);
        if(tmp!=hissiz.end()){
            // 取比目标值大的第一个
            int x=siz[id],y=*tmp-siz[id],z=n-*tmp;
            answer=min(answer,max(x,max(y,z))-min(x,min(y,z)));
        }
        if(tmp!=hissiz.begin()){
            // 取比目标值小的第一个
            tmp--;
            int x=siz[id],y=*tmp-siz[id],z=n-*tmp;
            answer=min(answer,max(x,max(y,z))-min(x,min(y,z)));
        }
    }
    if(!othsiz.empty()){
        // 不取路径上的边
        auto tmp=othsiz.lower_bound((n-siz[id])/2);
        if(tmp!=othsiz.end()){
            int x=siz[id],y=*tmp,z=n-x-y;
            answer=min(answer,max(x,max(y,z))-min(x,min(y,z)));
        }
        if(tmp!=othsiz.begin()){
            tmp--;
            int x=siz[id],y=*tmp,z=n-x-y;
            answer=min(answer,max(x,max(y,z))-min(x,min(y,z)));
        }
    }
    if(id>1)hissiz.insert(siz[id]);
    for(int i=head[id];i;i=edge[i].nxt)
        if(edge[i].to!=father)
            work(edge[i].to,id);
    if(id>1)
        hissiz.erase(hissiz.find(siz[id])),
        othsiz.insert(siz[id]);
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        addEdge(u,v);
        addEdge(v,u);
    }
    calcSize(1,0);
    work(1,0);
    printf("%d\n",answer);
    return 0;
}
```

---

## 作者：Find_Yourself (赞：3)

### 题面描述

给定一颗树，求分成三部分后的最小差异值。

### 题解

暴力：每次枚举两个点，将其父边断掉，如果存在祖先关系则特判一下，复杂度 $O(n^2)$，预计 50pts。

正解：dfs 搜索每个结点，砍掉它的父边，剩下的尽量等分（易证）。

这一步可以用 multiset 维护。

对于一个点，将其到根节点的链上的点放入 $s2$，再将这条链左边的所有点放入 $s1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9cwxqpbp.png)

然后令 $x= \dfrac{n-siz[u]}{2}$。 在 $s1$ 中查找最靠近 $x$ 的两个数，在 $s2$ 中查找最靠近 $x+siz[u]$ 的两个数，四种情况讨论一下。

细节：dfs 到一个点时将其放入 $s1$，回溯的时候将其从 $s1$ 中删除，并插入到 $s2$ 中。

预计 100pts。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, siz[N], ans = 1e9;
vector<int> adj[N];
multiset<int> s, s2;
void dfs(int u, int lst) { //计算子树大小 
    siz[u] = 1;
    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i]; if (v == lst) continue;
        dfs(v, u); siz[u] += siz[v];
    }
}
int getcha(int x, int y, int z) {return max(abs(x - y), max(abs(x - z), abs(y - z)));}
void dfs2(int u, int lst) {
    if (u != 1) {
        int tmp = n - siz[u], x;
        x = tmp / 2;
        multiset<int>::iterator it;
        if (tmp > 1) {
            it = s2.lower_bound(x + siz[u]);
            if (it != s2.end()) ans = min(ans, getcha((*it) - siz[u], siz[u], n - (*it)));
            it = s2.upper_bound(x + siz[u]);
            if (it != s2.begin()) {
                --it;
                ans = min(ans, getcha((*it) - siz[u], siz[u], n - (*it)));
            }
            it = s.lower_bound(x);
            if (it != s.end()) ans = min(ans, getcha((*it), siz[u], n - (*it) - siz[u]));
            it = s.upper_bound(x);
            if (it != s.begin()) {
                --it;
                ans = min(ans, getcha((*it), siz[u], n - (*it) - siz[u]));
            }
        }
    }
    if (u != 1) s2.insert(siz[u]); //点到根的链 
    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i]; if (v == lst) continue;
        dfs2(v, u);
    }
    s.insert(siz[u]); //已经遍历完了的点 
    if (u != 1) s2.erase(s2.find(siz[u]));
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v; cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs(1, 0); dfs2(1, 0);
    cout << ans << endl;
    return 0;
}
```


---

## 作者：M1saka16I72 (赞：0)

## 前言

[更可爱的阅读体验](https://misaka16172.github.io/solution-p7165)

没有发现 dsu on tree 题解，虽然复杂度不是很好不过胜在好想，来写一篇。

## 思路

首先考虑枚举一条边，则已经有一个联通块大小可以确定，那么剩下两个联通块大小尽量平均时最优。

两条边有祖孙关系是好搞的，直接 dfs 时把从根到当前节点的所有子树大小扔进 multiset 里并二分，回溯时 erase 掉即可。

两条边没有祖孙关系时，若当前遍历到节点 $u$，那么此时 multiset 中应当包括除了根到 $u$ 和 $u$ 子树里的所有节点的子树大小 $sz_v$。如果一开始将所有点的子树大小全部插入，则有一个 $\mathcal{O}(n^2 \log n)$ 的暴力算法，即遍历到每个点都直接将子树里的所有值清空，然后再统计答案。

考虑使用 dsu on tree，计算重儿子答案时不还原 multiset 里的值，这样遍历到每个点时只需要暴力清空轻儿子的值就可以计算答案。

复杂度 $\mathcal{O}(n\log ^2n)$，两个 $\log$ 分别来自 dsu on tree 和 multiset。

---

## 作者：船酱魔王 (赞：0)

## 题意回顾

$ n $ 个点的树，断掉两条边，使得分出的三个极大连通块大小极差最小化，输出这个最小的极差。

$ 3 \le n \le 2 \times 10^5 $。

## 分析

枚举断掉的第二条边是哪条，不妨设第一条边在第二条边 DFS 顺序之前。

因为第一条边不在第二条边下方，所以第一条边的断开会导致不在第二条边下方的连通块被分解成两部分，为了最小化极差需要最小化这两部分的差。

记第二条边下方子树大小为 $ s $，考虑如果第一条边在第二条边上方，那么第一条边下方的子树大小需要尽可能接近 $ \frac{n-s}{2}+s $，这是因为第一条边下方的子树大小包含第二条边下方的子树；如果第二条边不在第一条边上方，那么子树大小应该最接近 $ \frac{n-s}{2} $，故只需要找到这两类所有边下方的子树大小再用 `set` 等支持快速增删和查询前继后继的数据结构即可。

如何维护一条边上方边集和 DFS 顺序更靠前的边集？在 DFS 过程中，一条边如果被经过的话只能在后面遍历的边的非上方，在被经过之前在后面遍历的边的上方，故可以使用 `multiset` 的增加删除元素功能维护两个集合。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <set>
#define iter set<int>::iterator
using namespace std;
const int N = 2e5 + 5;
int n;
vector<int> g[N];
int siz[N];
void jsx(int u, int fath) {
    for(int i = 0; i < g[u].size(); i++) {
        int v = g[u][i];
        if(v == fath) continue;
        jsx(v, u);
        siz[u] += siz[v];
    }
    siz[u]++;
}
multiset<int> kyu, khj;
int ans = N;
void renew(int x, int y, int z) {
    ans = min(ans, max(max(x, y), z) - min(min(x, y), z));
}
void solve(int u, int fath) {
    khj.insert(siz[u]);
    iter it = khj.upper_bound((n - siz[u]) / 2 + siz[u]);
    if(it != khj.end()) renew(siz[u], (*it) - siz[u], n - (*it));
    if(it != khj.begin()) --it, renew(siz[u], (*it) - siz[u], n - (*it));
    it = kyu.upper_bound((n - siz[u]) / 2);
    if(it != kyu.end()) renew(siz[u], *it, n - siz[u] - (*it));
    if(it != kyu.begin()) --it, renew(siz[u], *it, n - siz[u] - (*it));
    for(int i = 0; i < g[u].size(); i++) {
        int v = g[u][i];
        if(v == fath) continue;
        solve(v, u);
    }
    khj.erase(khj.find(siz[u]));
    kyu.insert(siz[u]);
}
int main() {
    scanf("%d", &n);
    int x, y;
    for(int i = 1; i < n; i++) scanf("%d%d", &x, &y), g[x].push_back(y), g[y].push_back(x);
    jsx(1, 0);
    solve(1, 0);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：djh0314 (赞：0)

[**传送门**](https://www.luogu.com.cn/problem/P7165)。

## 题意

有一棵树，可以断掉 $2$ 条边，会形成三个连通块，求三个连通块中大小最大减最小的最小值。

## 分析

我们观察两条边之间的关系，分类考虑：
1. 两条边成祖孙关系。
2. 两条边没有祖孙关系。

首先，我们肯定我们的大方向，固一动一（~~说起来为什么想到了数学题~~），先固定一条边，再在其他边中取得最适合的边，那这一条边，我们显然可以确定，这条边应当是平分剩余的连通块。

### 对于第一种。

想出来了两种方法。       

第一种，从上往下，先固定上面（令这个节点为 $x$），再在其下选边，如何选边，在子树中的所有节点中，选择子树中节点树最接近 $\frac{siz_x}{2}$ 的点。使用 set 维护即可，至于如何快速维护子树的节点的节点数，可以使用树上启发式合并。         
时间复杂度：$O(n\log^2n)$。
~~~cpp
inline void dfs(int now,int fath) {
	siz[now]=1,son[now]=0;
	for(auto to:lj[now]) {
		if(to==fath) continue;
		dfs(to,now);
		siz[now]+=siz[to];
		if(siz[son[now]]<siz[to]) son[now]=to;
	}
}

inline void add(int now,int fath,int x) {
	se.insert(siz[now]);
	for(auto to:lj[now]) if(to!=fath&&to!=x) add(to,now,0);
}

inline void redfs(int now,int fath,int opt) {
	for(auto to:lj[now]) if(to!=fath&&to!=son[now]) redfs(to,now,0);
	if(son[now]) redfs(son[now],now,1);
	add(now,fath,son[now]);
	int A=n-siz[now];
	auto it=se.upper_bound(siz[now]/2);
	if(it!=se.end()) MIN(A,*it);
	if(it!=se.begin()) it--,MIN(A,*it);
	if(it!=se.begin()) it--,MIN(A,*it);
	if(!opt) se.clear();
}
~~~

第二种，从下往上，维护到父亲的链上的节点数，那此时，我们的节点数应当尽量接近 $\frac{n-siz_{x}}{2}+siz_{x}$。
~~~cpp
inline void redfs(int now,int fath) {
	int A=siz[now];
	auto it=se.upper_bound((n-siz[now])/2+siz[now]);
	if(it!=se.end()) MIN(A,(*it)-siz[now]);
	if(it!=se.begin()) it--,MIN(A,(*it)-siz[now]);
	if(it!=se.begin()) it--,MIN(A,(*it)-siz[now]);
	se.insert(siz[now]);
	for(auto to:lj[now]) if(to!=fath) redfs(to,now);
	se.erase(se.find(siz[now]));
}
~~~

时间复杂度：$O(n\log n)$。

### 对于第二种。

我们只需要将我们跑完的节点加入 set 即可，最后尽量接近 $\frac{n-siz_x}{2}$ 。
~~~cpp
inline void reredfs(int now,int fath) {
	int A=siz[now];
	auto it=se.upper_bound((n-siz[now])/2);
	if(it!=se.end()) MIN(A,*it);
	if(it!=se.begin()) it--,MIN(A,*it);
	if(it!=se.begin()) it--,MIN(A,*it);
	for(auto to:lj[now]) if(to!=fath) reredfs(to,now);
	se.insert(siz[now]);
}
~~~
于是就可以完美解决了。


---

## 作者：_zexal_ (赞：0)

#### 50pts
注意到 $n\leq2000$ 这个条件，直接枚举分界点 $u,v$ 使得整个树变为 $a,b,c$ 三个部分。假设 $a$ 为包含结点 $1$ 的集合。另外的 $u,v$ 分别包含 $b,c$ 两个集合。接下来分类讨论，讨论 $b,c$ 有一个是另一个子集，或者不是。这个很好搞，用树链剖分即可，由于树剖子树连续的性质，查一下树剖时候的遍历顺序即可。时间复杂度由于只有建树，只有高贵 $O(n^2)$。

```cpp
F(i,2,n){//断点1
		F(j,2,n){//断点2
			if(i==j) continue;
			x1=n;
			x2=siz[i];
			x3=siz[j];
			if(id[i]<id[j]&&id[j]<=id[i]+siz[i]-1){
				x2-=x3;
			}
			if(id[j]<id[i]&&id[i]<=id[j]+siz[j]-1){
				x3-=x2;
			}
			x1=x1-x2-x3;
			ans=min(ans,max(x1,max(x2,x3))-min(x1,min(x2,x3)));
		}
	}
```


#### 100pts
考虑只枚举一个点，直接搜索，我们用 $s_i$ 表示点 $i$ 的儿子数量，把 $n-s_i$ 放入平衡树，出于策略，我们肯定希望剩下的部分儿子数量接近 $\lceil \frac{n-s_i}{2} \rceil$。在他的前驱和后继里在一个儿子数量离他最近的即可。不过这样会有个问题，他无法处理是祖先情况，这个有两种办法解决，第一种就是在写一个搜索给他特殊处理到，另一种就是使用双栈，祖先栈和非祖先栈，计算祖先栈时减去 $s_i$ 即可。

---

## 作者：maruize (赞：0)

## LP7165 [COCI2020-2021#1] Papričice

容易想到枚举一条边，去找另一条边，使得另一个边分出的两个部分尽量平均。

可以发现分为两种情况，

1.另一条边是是当前边的祖先。

2.不是。

分开考虑(枚举的是 $x$ ，需要 $O(\log)$ 或 $O(1)$ 找到的最优解为 $y$ )

(注意这里 $x$ ， $y$ 是点，代表切断连向祂父亲的边)

- rt-y-x ：
    - $sz_y - sz_x \approx n - sz_y $
    - $2 \cdot sz_y \approx n + sz_x $
    - $  sz_y \approx \frac{n + sz_x}{2} $

- y-lca-x :
    - $ n - sz_y - sz_x \approx sz_y $
    - $2 \cdot sz_y \approx n - sz_x $
    - $  sz_y \approx \frac{n - sz_x}{2} $

所以考虑可以对于每一种情况把所有合法的点进行约等号后面的运算之后扔到 set 里每次查询。 (lower_bound,lower_bound -1 )

---

$x$ ， $y$ 有祖孙关系是很好维护。

考虑“动态”子树补很难维护。

我们可以求出这个树的 dfs 序，对于每个 $x$ 尽查 dfs 序小于祂的点。

这是一个类似于扫描线的结构。

然后转换之后就相对好维护了：

dfs 栈里的点作为第一种情况放进一个 set 里(code 中的 ant )。

dfs 出栈后的点作为第二种情况放进另一个 set 里(code 中的 pre )。

---

```cpp
multiset<int>ant,pre;
#define dif(a,b,c) max(mabs((a)-(b)),max(mabs((b)-(c)),mabs((a)-(c)) ) )
void dfs(int x,int fa){
	//rt-y-x :
	auto t=ant.lower_bound(n+sz[x]);//sz表示子树大小，已求好。
	if(t!=ant.end())
		ans=min(ans,dif(sz[x],*t/2-sz[x],n-*t/2));
	if(t!=ant.begin())t--,
		ans=min(ans,dif(sz[x],*t/2-sz[x],n-*t/2));
	//y-lca-x :
	t=pre.lower_bound(n-sz[x]);
	if(t!=pre.end())
		ans=min(ans,dif(sz[x],*t/2,n-sz[x]-*t/2));
	if(t!=pre.begin())t--,
		ans=min(ans,dif(sz[x],*t/2,n-sz[x]-*t/2));

	ant.insert(sz[x]*2);
	rep(i,x,to)if(to!=fa)
		dfs(to,x);
	ant.erase(ant.find(sz[x]*2)),pre.insert(sz[x]*2);
}
then ans is the answer.
```

---


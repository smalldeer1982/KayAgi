# 诸侯安置

## 题目描述

很久以前，有一个强大的帝国，它的国土成正方形状，如图所示。

这个国家有若干诸侯。由于这些诸侯都曾立下赫赫战功，国王准备给他们每人一块封地（正方形中的一格）。但是，这些诸侯又非常好战，当两个诸侯位于同一行或同一列时，他们就会开战。如下图为 $n＝3$ 时的国土，阴影部分表示诸侯所处的位置。前两幅图中的诸侯可以互相攻击，第三幅则不可以。

![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)

国王自然不愿意看到他的诸侯们互相开战，致使国家动荡不安。  因此，他希望通过合理的安排诸侯所处的位置，使他们两两之间都不能攻击。

现在，给出正方形的边长 $n$，以及需要封地的诸侯数量 $k$，要求你求出所有可能的安置方案数。（满足 $n\le100$，$k\le2n^2-2n+1$）

由于方案数可能很多，你只需要输出方案数除以 $504$ 的余数即可。


## 说明/提示

注意：镜面和旋转的情况属于不同的方案。

## 样例 #1

### 输入

```
2 2
```

### 输出

```
4```

# 题解

## 作者：Mizuhara (赞：39)

首先是一步本鶸想了很久也没有想到的操作。。。

因为将整行/列平移并不影响诸侯间的限制关系，

且题目又说了镜面和旋转的情况属于不同的方案，

那我们就可以把图案平移成我们想要的样子了。

那我们希望图案是什么样子？既然是dp,

我们当然希望能够得到没有后效性的图案。

也就是楼下dalao的图案。

因为每一列的长度都≥前一列的长度，

所以若前$j$列放了k-1个且第$k$个放在$i$列，

那么在这一列放一个的方案便是长度$lon[i]-(k-1)$.

若用$f[i][k]$表示前$i$列放了$k$个

且第$i$个放在第$i$列的方案数，则易得

$f[i][k]=\sum_{j<i}{f[j][k-1]*(lon[i]-(k-1))}$

其中$lon[i]$表示第$i$列的长度。

这样做是$O(n^3)$的.实际上可以优化到$O(n^2)$.

复杂度高一层是因为我们的状态选择的限制多了.

因为实际上,我们不需要第$k$个放在第$i$列这一条件。

我们设$f[i][k]$表示前$i$列放了$k$个的方案，则有：

$f[i][k]=f[i-1][k]+f[i-1][k-1]*(lon[i]-(k-1))$

原因很简单,取$f[i-1][k]$代表第$i$列放$0$个,

取$f[i-1][k-1]*(lon[i]-(k-1))$代表第$i$列放$1$个.

最终输出$f[2*n-1][k]$.

复杂度$O(n^2)$.

```
#include<iostream>
#include<algorithm>
#define p 504
using namespace std;

int f[210][210],lon[210];
int main(){
	int n,kk;cin>>n>>kk;
	if(kk>2*n-1){cout<<0;return 0;}
	for(int i=1;i<n;i++)lon[2*i-1]=lon[2*i]=2*i-1;
	lon[2*n-1]=2*n-1;
	for(int i=0;i<=2*n-1;i++)f[i][0]=1;//初始化
	for(int i=1;i<=2*n-1;i++)
	for(int k=1;k<=lon[i];k++){
		f[i][k]=f[i-1][k]+f[i-1][k-1]*(lon[i]-k+1);
		f[i][k]%=p;
	}
	cout<<f[2*n-1][kk];
	return 0;
}

```

---

## 作者：2016jzy (赞：35)

此题为我们考试的题目，表示这题真的好奇怪。。

首先，本题最重要的一点是将正方形的其中一半移动到另外一边，如下图：

 ![](https://cdn.luogu.com.cn/upload/pic/7408.png) 

然后就比较简单啦。。

看代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,f[201][20001],hs=-1,ans;
int main()
{
    cin>>n>>k;
    if(!k){cout<<1<<endl;return 0;}            //几个特判，不然有几个点很坑。。
    if(k>=2*n-1){cout<<0<<endl;return 0;}
    for(int i=0;i<=2*n-1;i++)                //初始化
    {
        f[i][0]=1;
    }
    for(int i=1;i<=2*n-1;i++)       //2*n-1是国土的列数
    {
        if(i%2!=0)hs+=2;             //hs是当前的行数
        f[i][1]=hs;
        for(int j=2;j<=k;j++)       //因为上一行已经解决了1的情况，所以从2开始
        {
            for(int z=1;z<=i-1;z++)        //可以通过找规律发现，f[i][j]其实是 f[1~i-1][j]*剩余可放列数 的总和
            {
                f[i][j]+=f[z][j-1]*(hs-j+1)%504;       //核心思想
            }
        }
    }
    for(int i=1;i<=2*n-1;i++)        //注意ans一定是f[1~2*n-1][k]的总和
    {
        ans+=f[i][k]%504;
    }
    cout<<ans%504<<endl;        //记得膜蛤！
    return 0;
}
```

---

## 作者：blackjack (赞：13)

# Analysis

初次遇见这种题，很有困难。

一开始我的思考方式是棋盘多项式的思考方式。绝望。

那么正确的递推递归思路是什么呢？还记得约瑟夫问题吗。

首先定义状态，根据经验和题目意思，显然是，f(n,k)，表示在大小为n的棋盘里放k个。

然后“强制”联系它和之前状态（因为这不是我现在可以一眼发现的，需要有一个思维方向，如果可以一眼发现就不需要了，一切迎刃而解）。很显然，我们可以猜到，上一个状态是f(n-1,?)

现在要思考这个“?”是什么。

以n=3为例，画出n-1即n=2的图

对比和n=3的图，发现了什么？

n=2与n=3相比相差的是两列

于是乎就有了灵感。f(n,k)这个状态和f(n-1,？)这个状态的差距就是在这两个杠掉的行。在这两个杠掉的行有三种情况:
在这两个相差的行放0个；对应的上一个状态时f(n-1,k)

在这两个相差的行放1个；对应的上一个状态时f(n-1,k-1)

在这两个相差的行放2个；对应的上一个状态时f(n-1,k-2)

三种情况互不重复，加法原理直接加起来，这就是状态转移的路径。

但是，怎么计算呢？这是这题又一个难点。

ans=&f(n,k);

当放0个的时候，只有1种选择:放0个。

ans+=f(n-1,k)*1.

当放1个的时候呢？这个时候不止一种选择。发现我们没有办法确定这一个会不会对之后产生影响，因为，放在两行的最上面和放在两行的中间是不一样的！

到这里又怎么办呢？转化枚举方向，倒过来思考，在两个杠掉的行里放1个，相当于在其他行里放k-1个。在其它行放k-1个对现在杠掉的这两行的影响是可以被控制的：一定会产生影响。去掉被影响的格子，剩下的格子都可以选。这里是分步计算，所以利用乘法原理：
ans+=f(n-1,k-1)*（4*n-2*k-2）

利用相同的思想方法，可以很容易推出放2个的时候的情况：

ans+= f(n-1,k-2)*(2*n-k-1)*(2*n-k)。

于是打出程序。不要忘记求模。

# Code

```cpp
#include<bits/stdc++.h>

 

using namespace std;

 

int dp[101][20001];

 

int dfs(int n,int k){

   if (dp[n][k]!=-1)

      return dp[n][k];

   if (n==1){

      if (k==1 or k==0)

         return 1;

      else

         return 0;

   }

   int ans=0;

   ans=dfs(n-1,k)+dfs(n-1,k-1)*(4*n-2*k-2);

   ans+=dfs(n-1,k-2)*(2*n-k-1)*(2*n-k);

   return dp[n][k]=ans%504;

}

    

int main(){

   freopen("test.in","r",stdin);

   freopen("test.out","w",stdout);

   int n,k;

   cin>>n>>k;

   int ans=0;

   memset(dp,-1,sizeof(dp));

   ans=dfs(n,k);

   cout<<ans<<endl;

   return 0;

}

```
# Conclusion

转换思维方式，逆向思维，这很重要。这有点像C的计算方法：

C(n,k)=C(n,n-k)

n个里面选k个等价于n个里面选n-k个。有时候先n-k个比直接选k个更加好选。

---

## 作者：一只书虫仔 (赞：13)

#### Description

> 给定一个 $2 \times n+1$ 行的菱形图，在上面放车，使得同一行和同一列不会有两辆车。          
> 求放置方案数。

#### Solution

类似 P1350，考虑动态规划。

设 $dp_{i,j}$ 为第 $i$ 行已经放了 $j$ 个车的方案数，那么分类讨论：

- 第 $i$ 行 $0$ 个车，那么可以直接从 $dp_{i-1,j}$ 转移过来。
- 第 $i$ 行 $1$ 个车，因为车不能在同一列，所以除去前 $j$ 个位置之外的位置都可以放置车，即有 $(len-j+1)$ 个位置可以放车，那么可以从 $dp_{i-1,j-1} \times (len-j+1)$ 转移过来。
- 第 $i$ 行多于 $1$ 个车，不满足题意，舍弃。

按照这个过程进行转移即可。

注意特判，当 $k>2 \times n+1$ 时，不存在合法方案。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

long long dp[1005][1005];
long long Mod = 504;
long long len[1005];

//long long len (long long n, long long row) {
//	if (row <= n) return 2 * row - 1;
//	else return len(n, 2 * n - row);
//}

int main () {
	long long n, k;
	scanf("%lld%lld", &n, &k);
	if (k > 2 * n - 1) {
		puts("0");
		return 0;
	}
	for (long long i = 1; i <= n; i++) len[2 * i - 1] = 2 * i - 1;
	for (long long i = 1; i < n; i++) len[2 * i] = 2 * i - 1;
	for (long long i = 0; i <= 2 * n - 1; i++) dp[i][0] = 1;
	for (long long i = 1; i <= 2 * n - 1; i++)
		for (long long j = 1; j <= k; j++) {
			long long ans = dp[i - 1][j - 1] * (len[i] - j + 1);
			ans %= Mod;
			dp[i][j] = dp[i - 1][j] + ans;
			dp[i][j] %= Mod;
		} 
	printf("%lld", dp[2 * n - 1][k] % Mod);
	return 0;
}
```

---

## 作者：张语诚ZYC (赞：6)

## 分析思路
**这道题的标签虽然只有递推，但我们不能忘记曾经拯救我们的搜索，需要将两者结合起来。**~~你品，你细品~~**。** 由于题面已经说明，旋转和镜面对称不属于同一种情况，~~那真是太好了~~，不用多虑，找到递推公式，安安心心的写搜索。

## 递推公式：
```cpp
dfs(n-1,k)+dfs(n-1,k-1)*(4*n-2*k-2)+dfs(n-1,k-2)*(2*n-k-1)*(2*n-k)
```

## $\texttt{AC Code}$：
```cpp
#include<bits/stdc++.h>
using namespace std;
int mp[111][22222];
inline int read_int(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			w=-1;
		} 
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';ch=getchar();
	}
	return s*w;
}
int mod(int data){
	return data%504;
}
int dfs(int n,int k){
	if(mp[n][k]!=-1){
		return mp[n][k];
	}
	if((n==1&&k==0) || (n==1&&k==1)){
		return 1;
	}
	if(n==1){
		return 0;
	}
	mp[n][k]=mod(dfs(n-1,k)+dfs(n-1,k-1)*(4*n-2*k-2)+dfs(n-1,k-2)*(2*n-k-1)*(2*n-k));
	return mp[n][k];
}
int main(){
	memset(mp,0xff,sizeof(mp));
	int n,k;
	n=read_int();
	k=read_int();
	if(k>2*n-1){
		puts("0");
		return 0;
	}
	printf("%d\n",dfs(n,k));
	return 0;
} 
```


---

## 作者：CG__HeavenHealer (赞：2)

# 【题解】 P1240 诸侯安置

### 题意

在一个~~奇奇怪怪的~~菱形里放 $k$ 个诸侯，诸侯处在同一列或同一行就会攻击，问这些诸侯两两不相互攻击的方案数。

---

### 解法
 
其实这道题和 [P1350 车的放置](https://www.luogu.com.cn/problem/P1350) 差不多。

诸侯可以直接考虑成车，考虑DP。

设 $f[i][j]$ 表示第 $i$ 行，放了 $j$ 个诸侯的方案数。

首先，如果方案是合法的，两个诸侯不能同时出现在同一列和同一行。对于同一行的情况，可以通过一行只枚举一个诸侯来解决；而对于同一列的情况，我们需要计算出目前合法的格子，再乘上上一行的方案数，即 $ len \times f[i-1][j-1] $  （ $len$ 表示第 $i$ 行剩余合法的格子），就得到了把一个诸侯放在这行的方案。

而除此以外，还可以在这一行一个诸侯也不放，方案数就是上一行的方案数，即 $f[i-1][j]$ 。

总的转移方程：$f[i][j]=(len \times f[i-1][j-1]) + f[i-1][j]$ 。

相对于 P1350 ，这道题比较恶心的是长度的处理，我们需要把整个图形重新按每行的长度排个序，因为我们枚举 $j$ 的时候需要正向循环，而如果长度无序的话就可能导致漏掉方案数。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/b89az394.png)

另外就是注意判一下如果 $k > 2 \times n - 1$ ，就无解，方案数为 $0$ 。

---

###  Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
const int N = 205, mod = 504;
inline int read() {
    ri x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    return f * x;
}
int f[N][N], len[N];
signed main() {
    int n = read(), k = read();
    if (k > 2 * n - 1) return puts("0"), 0;
    for (ri i = 0; i <= 2 * n - 1; i++) f[i][0] = 1;
    for (ri i = 1; i <= n; i++) len[i] = 2 * i - 1, len[2 * n - i] = 2 * i - 1;
    sort(len + 1, len + 2 * n);
    for (ri i = 1; i <= 2 * n - 1; i++)
        for (ri j = 1; j <= k; j++) {
            if (j > len[i]) continue;
            (f[i][j] = (len[i] - j + 1) * f[i - 1][j - 1] + f[i - 1][j]) %= mod;
        }
    printf("%lld\n", f[2 * n - 1][k]);
    return 0;
}
```

---

## 作者：minamikotori (赞：2)

可以把上下两个叠起来 组成 1 1 3 3 5 5 7 7.......的形式。共2\*n-1行。

num[i] 为当前层数的宽度。

f[i][j] 为插到第i行该插第j个。及前i-1行插入了j-1个 -> f[i][j] += sigema(j-1, i-1)\*(num[i]-(j-1));

ans = sigema(k, 2\*n-1)。

然后在中途mo上504就ok。

下面附上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
typedef long long Lovelive;
using namespace std;

Lovelive scan() {
    int f = 1; Lovelive x = 0;char c = getchar();
    while(c > '9' || c < '0') {if(c == '-') f= -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x*10 + c - '0', c = getchar();
    return f*x;
}

int n, f[205][205], num[205], k;
const int mod = 504;

int main() {
    cin >> n >> k;
    num[1]=num[2]=1;
    for(int i = 3; i <=2*n-1; i++) num[i] = num[i-2]+2;
    f[0][0] = 1;
    for(int i = 1; i <= 2*n-1; i++)
        for(int j = 1; j <= i; j++)
            for(int L = j-1; L <= i-1; L++)
                f[i][j] += f[L][j-1]*(num[i]-j+1)%mod,
                f[i][j]%=mod;
    Lovelive ans = 0;
    for(int i = k; i <= 2*n-1; i++) ans+=f[i][k], ans%=mod;
    cout << ans;
    return 0;
}
```

---

## 作者：zclong (赞：1)


两两相同的合并，

成  1，1，3，3，5，5........n\*2-1;

然后我们会容易发现一种不同与搜索的动态规划做法.

f[i,j]:=f[i,j]+f[k,j-1]\*(Len[i]-(j-1)) [j-1<=k<=i-1]

1.f[i,j]表示前i列放置j个的方案，且第j个放在第i列上，

2.前面f[k,j-1]个都需要累加上来，举一个说明为什么需要累加：对于前4排放置2个的情况(平移后的)，2个即可以放在第一列和第三列，也可以放在第一列和第四列，所以需要把这些分布在不同列的情况累加上来。

3.乘(Len[i]-(j-1))是因为前面k列放了j-1个棋子了，然后每行只能放一个棋子，所以第j个棋子在第i列可以放的情况就是Len[i]-(j-1),len[i]是第i列有多少行，程序中是l[i];

首先可以证明这个图可以转换成如下的形式：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,f[1010][1010],l[1010],m,ans;
int main()
{
    scanf("%d%d",&n,&m);
    if(m==0)
    {
        printf("1");
        return 0;
    }
    for(int i=1;i<=n;i++)
        l[i*2-1]=l[i*2]=i*2-1;
    f[0][0]=1;
    for(int i=1;i<=2*n-1;i++)
        for(int j=1;j<=i;j++)
            for(int k=j-1;k<i;k++)
                f[i][j]=(f[i][j]+f[k][j-1]*(l[i]-j+1))%504;
            for(int i=m;i<=n*2-1;i++)
                ans=(ans+f[i][m])%504;
        printf("%d",ans%504);
            return 0;
}

```

---

## 作者：此祥非彼翔 (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int f[1000][1000];//.f[i,j]表示前i列放置j个的方案，且第j个放在第i列上;
int l[1000],top;//表示列；l[]表示第i列有多少行；
int n,m,ans;
int main()
{
    scanf("%d%d",&n,&m);//n;正方形的边长,m;诸侯数；
    if(m==0)
```
{//无诸侯时，方案为1，即就一种，故取余504为1；
            printf("1");

            return 0;

}//结束；

```cpp
            l[1]=l[2]=1;//图平移后为双层不夹心；
            top=2;//从2开始dp;
    while(l[top]<n*2-1)//n*2-1:为图形总层数；
        {
        l[top+1]=l[top+2]=l[top]+2;//类比l[1]=l[2]=1;
        top+=2;//两层两层加；
    }
    top--;//下面开始dp,层层深入；打入老巢；
    f[0][0]=1;//f[][]的初始化；就是开始时，0诸侯的情况；
    for(int i=1;i<=top;i++)//层数（即列）；   
    for(int j=1;j<=min(m,l[i]);j++)//j表示诸侯数；
        //至于min(m,l[i]);即小于当层诸侯数and m的min;
            for(int k=j-1;k<=i-1;k++)
                //注意此处是三重循环；
                f[i][j]=(f[i][j]+f[k][j-1]*(l[i]-j+1))%504;//动态转移方程；
    for(int i=1;i<=top;i++)
        ans=(ans+f[i][m])%504;//累加
    //.前面f[k,j-1]个都需要累加上来，举一个说明为什么需要累加：
    //对于前4排放置2个的情况(平移后的)，2个即可以放在第一列和第三列，
    //也可以放在第一列和第四列，所以需要把这些分布在不同列的情况累加上来。 
    printf("%d",ans);//取余后输出结果；
}
```

---

## 作者：gryql (赞：1)

动态规划问题



f[i,j]:=f[i,j]+f[k,j-1]\*(Len[i]-(j-1)) [j-1<=k<=i-1]

1.f[i,j]表示前i列放置j个的方案，且第j个放在第i列上，


2.前面f[k,j-1]个都需要累加上来，举一个说明为什么需要累加：对于前4排放置2个的情况(平移后的)，2个即可以放在第一列和第三列，也可以放在第一列和第四列，所以需要把这些分布在不同列的情况累加上来。


3.乘(Len[i]-(j-1))是因为前面k列放了j-1个棋子了，然后每行只能放一个棋子，所以第j个棋子在第i列可以放的情况就是Len[i]-(j-1),len[i]是第i列有多少行，程序中是L[i]


详细程序：http://www.cnblogs.com/yangqingli/p/4930510.html


---


# 「CZOI-R6」游戏

## 题目描述

有一片 $n\times m$ 的空地，CaiZi 定好了两个常数 $k_1, k_2$，决定在这片空地进行 $q$ 局游戏。

每局游戏内，CaiZi 会先选择空地内某点 $(x_i, y_i)$，设定一个基准得分 $u_i$。随后，对于空地内所有点 $(a, b)\;(1 \leq a \leq n, 1 \leq b \leq m)$，其在该局游戏的得分为 $u_i + k_1 \cdot \lvert x_i - a \rvert + k_2 \cdot \lvert y_i - b\rvert$。

作为观战方，你想要对每个位置 $(i, j) (1 \leq i \leq n, 1 \leq j \leq m)$ 求出其在 $q$ 局游戏中得分的 **最大值**。

**注意 $\boldsymbol{k_1, k_2}$ 未必为正数，详见各子任务约束范围**。

## 说明/提示

**【样例解释】**

对于第一组数据，加密前各个位置的得分最大值依次为

$$ \begin{bmatrix} 6 &5 &4 \\ 5 &4 &4 \\ 4 &4 &5 \end{bmatrix}. $$

对于第二组数据，加密前各个位置的得分最大值依次为

$$ \begin{bmatrix} 8 &11 &8 &5 &2 \\ 6 &9 &6 &3 &3 \\ 4 &7 &4 &5 &5 \\ 6 &9 &6 &7 &7 \end{bmatrix}. $$

---

**【数据范围】**

- Subtask #1（$10\ \text{pts}$）：$n, m, q \le 100$。
- Subtask #2（$20\ \text{pts}$）：$k_1=0$。
- Subtask #3（$20\ \text{pts}$）：$n,m\le10^3$，$k_1,k_2 < 0$。
- Subtask #4（$20\ \text{pts}$）：$q$ 局游戏的 $u_i$ 相同。
- Subtask #5（$30\ \text{pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le x_i\le n\le3\times10^3$，$1\le y_i\le m\le3\times10^3$，$1\le q\le10^6$，$|k_1|,|k_2|,|u_i|\le10^9$。

## 样例 #1

### 输入

```
3 3 3 1 1
1 1 1
3 2 1
3 3 2```

### 输出

```
1817640486886175503```

## 样例 #2

### 输入

```
4 5 3 2 -3
3 2 7
1 5 1
2 4 3
```

### 输出

```
15847710135880645119```

# 题解

## 作者：jiangyunuo (赞：16)

## 题目大意（简化）：
一个 $n \times m$ 的矩阵，开始给定两个常数：$k_1$ 和 $k_2$。接下来我们就会进行 $q$ 次操作，第 $i$ 次操作都会选择一个位置 $(x_i,y_i)$，同时给定一个基准数 $u_i$，每次操作后第 $a$ 行第 $b$ 列的点 $(a,b)$，就会得到 $u_i + k_1 \cdot \lvert x_i - a \rvert + k_2 \cdot \lvert y_i - b\rvert$ 的分数，接着我们定义 $f_{i,j}$ 为 $q$ 次操作中点 $(i,j)$ 的最大分数。最终我们要求 $$ \left(\sum_{i=1}^n \sum_{j=1}^m f_{i,j} \cdot 131^{(i-1) \times m+j} \right) \bmod{2^{64}} $$ 的值。

## 大体思路：
### 总体思路：
对于本题，我们可以根据 $k_1$ 与 $k_2$ 的正负性分成四种情况详见后文。对于每一种情况，我们的每一种操作都会产生一个或多个高点（声明一下：这是我自己整出的概念），这个高点指的是周围点的分数大小都比这个点的小（在同一此操作的前提下），并且由于 $k_1,k_2$ 的大小是固定的，所以我们可以看成周围的点的分数都是由该点的分数按一定规律下降得到的。所以，在操作完成后我们可以先求出高点所在的行或列的所有点的分数（求法：从左到右再从右到左扩散一次，这是对于求行的；从上到下再从下到上扩散一次，这是对于求行的），然后扩散到整个矩阵。

什么，你说要是不同操作或有不同的高点，求出高点所在的行或列的所有点的分数，与最终结果有不同怎么办？

没关系，我们求出所有操作的高点所在行的分数后，可以从矩阵的左边往右边扫，如果某次高点所在行的分数大，则左边行的分数就无法越过这里，接着这一行的分数就会继续往右扩散，反之，就让左边扩散到的结果覆盖掉这一行。到最后，再从右往左以同样的方式扫一遍，或先去求高点所在列的所有点分数，再从上到下，从下到上扫过整个矩阵即可。后面我会用样例举例子。提示，最后的扩散是一行一行扩散的或一列一列扩散的，代码中也会有体现。

接下来我们分类讨论一波。

### 分类讨论：

#### $k_1,k_2$ 都是非负数：
在这种情况下，第 $i$ 次操作中距离 $(x_i,y_i)$ 越远的点，分数越大，显然，要最远，高点应该处在矩阵的四个角上，比如 $x=2,y=2,u=1,k_1=1,k_2=1$：

```
3 2 3
2 1 2
3 2 3
```

结果显而易见，高点就是四个角（注：在不同操作中，这四个角的分数可能会更新，也就是获得更大的分数）。

当然，这种情况下，扩散是这样的（是从高点按一个方向向其他点扩散）：从 $(c,d)$ 扩散到 $(c+1,d)$ 或 $(c-1,d)$ 分数减去 $k_1$；从 $(c,d)$ 扩散到 $(c,d+1)$ 或 $(c,d-1)$ 分数减去 $k_2$。

这种情况下先求出高点所在行的分数再求全图，还是先求列再求全图都一样。

#### $k_1,k_2$ 都是负数：
在这种情况下，第 $i$ 次操作中距离 $(x_i,y_i)$ 越远的点，分数越小，显然，高点应该就是 $(x_i,y_i)$，比如 $x=2,y=2,u=1,k_1=-1,k_2=-1$：

```
-1 0 -1
0 1 0
-1 0 -1
```

结果显而易见，就是前面所说的（注同前一种情况，高点分数也有可能会更新）。

这种情况下，扩散是这样的：从 $(c,d)$ 扩散到 $(c+1,d)$ 或 $(c-1,d)$ 分数加上 $k_1$；从 $(c,d)$ 扩散到 $(c,d+1)$ 或 $(c,d-1)$ 分数加上 $k_2$。

这种情况下同样是先求出高点所在行的分数再求全图，还是先求列再求全图都一样。

#### $k_1$ 是非负数，$k_2$ 是负数：
在这种情况下，第 $i$ 次操作中距离 $(x_i,y_i)$ 所在行越远的点（距离其所在列相同的情况下），分数越大；距离 $(x_i,y_i)$ 所在列越近的点（距离其所在行相同的情况下），显然，高点应该处在 $(1,y_i)$ 和 $(n,y_i)$，比如 $x=2,y=2,u=1,k_1=1,k_2=-1$：

```
1 2 1
0 1 0
1 2 1
```

结论还是同前。

这种情况下，扩散是这样的：从 $(c,d)$ 扩散到 $(c+1,d)$ 或 $(c-1,d)$ 分数减去 $k_1$；从 $(c,d)$ 扩散到 $(c,d+1)$ 或 $(c,d-1)$ 分数加上 $k_2$。

这种情况下，我建议先求出高点所在行的分数再求全图。

#### $k_1$ 是负数，$k_2$ 是非负数：
在这种情况就与前一种情况刚好相反，第 $i$ 次操作中距离 $(x_i,y_i)$ 所在列越远的点（距离其所在行相同的情况下），分数越大；距离 $(x_i,y_i)$ 所在行越近的点（距离其所在列相同的情况下），显然，高点应该处在 $(x_1,1)$ 和 $(x_i,m)$，比如 $x=2,y=2,u=1,k_1=-1,k_2=1$：

```
1 0 1
2 1 2
1 0 1
```

结论还是同前。

这种情况下，扩散是这样的：从 $(c,d)$ 扩散到 $(c+1,d)$ 或 $(c-1,d)$ 分数加上 $k_1$；从 $(c,d)$ 扩散到 $(c,d+1)$ 或 $(c,d-1)$ 分数减去 $k_2$。

这种情况下，我建议先求出高点所在列的分数再求全图。

### 举例：
::::info[样例一]
这个属于前面讨论的第一种情况，总共有三次操作，而这三次操作得出的结果为（注：只标注了高点，别的是 `0`，同时这一次左上角严格来说不算高点，但还是标记上，不会有影响）：
```
1 0 3
0 0 0
3 0 5
```
```
4 0 4
0 0 0
2 0 2
```
```
6 0 4
0 0 0
4 0 2
```

整合更新一下就是：
```
6 0 4
0 0 0
4 0 5
```

求出高点所在行的分数（从左往右再从右往左扫）：
```
6 5 4
0 0 0
4 4 5
```

最后从上到下扫一遍，从下到上扫一遍：
```
6 5 4
5 4 3
4 4 5
```
```
6 5 4
5 4 4
4 4 5
```

最后，我们就得到答案矩阵了，接着就是算答案了。
::::
::::info[样例二]
这个属于前面讨论的第三种情况，总共有三次操作，而这三次操作得出的结果为（严格来算第二次操作右上角不算高点，但标上没影响）：
```
0 11 0 0 0
0 0 0 0 0
0 0 0 0 0
0 9 0 0 0
```
```
0 0 0 0 2
0 0 0 0 0
0 0 0 0 0
0 0 0 0 7
```
```
0 0 0 5 0
0 0 0 0 0
0 0 0 0 0
0 0 0 7 0
```

整合更新一下就是：
```
0 11 0 5 2
0 0 0 0 0
0 0 0 0 0
0 9 0 7 7
```

求出高点所在列的分数（从上往下再从下往上扫）：
```
0 11 0 5 2
0 9 0 3 3
0 7 0 5 5
0 9 0 7 7
```

最后从左到右扫一遍，从右到左扫一遍：
```
0 11 8 5 2
0 9 6 3 3
0 7 4 5 5
0 9 6 7 7
```
```
8 11 8 5 2
6 9 6 3 3
4 7 4 5 5
6 9 6 7 7
```

最后，我们就得到答案矩阵了，接着就是算答案了。
::::

小贴士：如果最后计算答案时没有使用快速幂，那么 `TLE` 泪两行，此时的时间复杂度就会来到可怕的 $O(n^2 \times m^2)$。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long C=-999999999999999;
long long n,m,q,k1,k2,x,y,u,f[3005][3005];
unsigned long long ans,sum;
bool pd(int x){   //判断这一行是否有高点。
    for(int i=1;i<=m;i++){
        if(f[x][i]!=C)return 0;
    }
    return 1;
}
unsigned long long poow(unsigned long long a,unsigned long long b){  //快速幂。
    unsigned long long c,d,tot=1;
    while(b){
        d=1;
        c=a;
        while(1){
            if(d*2>b)break;
            c*=c;
            d*=2;
        }
        tot*=c;
        b-=d;
    }
    return tot;
}
int main(){
    cin>>n>>m>>q>>k1>>k2;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=C;   //开始附上极小值，接着推算就简单了。
        }
    }
    for(int i=1;i<=q;i++){  //输入与分类标记高点。
        cin>>x>>y>>u;
        if(k1>=0&&k2>=0){
            f[1][1]=max(f[1][1],u+k1*abs(x-1)+k2*abs(y-1));
            f[1][m]=max(f[1][m],u+k1*abs(x-1)+k2*abs(y-m));
            f[n][1]=max(f[n][1],u+k1*abs(x-n)+k2*abs(y-1));
            f[n][m]=max(f[n][m],u+k1*abs(x-n)+k2*abs(y-m));
        }
        if(k1<0&&k2<0){
            f[x][y]=max(f[x][y],u);
        }
        if(k1>=0&&k2<0){
            f[1][y]=max(f[1][y],u+k1*abs(x-1));
            f[n][y]=max(f[n][y],u+k1*abs(x-n));
        }
        if(k1<0&&k2>=0){
            f[x][1]=max(f[x][1],u+k2*abs(y-1));
            f[x][m]=max(f[x][m],u+k2*abs(y-m));
        }
    }
   //接下来分类讨论，求答案矩阵。
    if(k1<0&&k2>=0){
        for(int i=1;i<=n;i++){
            if(f[i][1]==C)continue; //如果这一行没有高点，直接跳过。
            for(int j=2;j<m;j++){  //计算高点所在行所有点分数。
                f[i][j]=max(f[i][j],f[i][j-1]-k2);
            }
            for(int j=m-1;j>1;j--){
                f[i][j]=max(f[i][j],f[i][j+1]-k2);
            }
        }
        for(int i=1;i<=m;i++){   //计算整个矩阵。
            for(int j=2;j<=n;j++){
                f[j][i]=max(f[j][i],f[j-1][i]+k1);
            }
            for(int j=n-1;j>=1;j--){
                f[j][i]=max(f[j][i],f[j+1][i]+k1);
            }
        }
    }
    if(k1>=0&&k2>=0){
        for(int j=2;j<m;j++){  //计算高点所在行所有点分数。
            f[1][j]=max(f[1][j],f[1][j-1]-k2);
            f[n][j]=max(f[n][j],f[n][j-1]-k2);
        }
        for(int j=m-1;j>1;j--){
            f[1][j]=max(f[1][j],f[1][j+1]-k2);
            f[n][j]=max(f[n][j],f[n][j+1]-k2);
        }
        for(int i=1;i<=m;i++){   //计算整个矩阵。
            for(int j=2;j<=n;j++){
                f[j][i]=max(f[j][i],f[j-1][i]-k1);
            }
            for(int j=n-1;j>=1;j--){
                f[j][i]=max(f[j][i],f[j+1][i]-k1);
            }
        }
    }
    if(k1<0&&k2<0){
        for(int i=1;i<=n;i++){
            if(pd(i))continue; //如果这一行没有高点，直接跳过。
            for(int j=2;j<=m;j++){  //计算高点所在行所有点分数。
                f[i][j]=max(f[i][j],f[i][j-1]+k2);
            }
            for(int j=m-1;j>=1;j--){
                f[i][j]=max(f[i][j],f[i][j+1]+k2);
            }
        }
        for(int i=1;i<=m;i++){   //计算整个矩阵。
            for(int j=2;j<=n;j++){
                f[j][i]=max(f[j][i],f[j-1][i]+k1);
            }
            for(int j=n-1;j>=1;j--){
                f[j][i]=max(f[j][i],f[j+1][i]+k1);
            }
        }
    }
    if(k1>=0&&k2<0){
        for(int i=1;i<=m;i++){
            if(f[1][m]==C)continue; //如果这一列没有高点，直接跳过。
            for(int j=2;j<n;j++){  //计算高点所在列所有点分数。
                f[j][i]=max(f[j][i],f[j-1][i]-k1);
            }
            for(int j=n-1;j>1;j--){
                f[j][i]=max(f[j][i],f[j+1][i]-k1);
            }
        }
        for(int i=1;i<=n;i++){   //计算整个矩阵。
            for(int j=2;j<=m;j++){
                f[i][j]=max(f[i][j],f[i][j-1]+k2);
            }
            for(int j=m-1;j>=1;j--){
                f[i][j]=max(f[i][j],f[i][j+1]+k2);
            }
        }
    }
    for(int i=1;i<=n;i++){  //计算答案。
        for(int j=1;j<=m;j++){
            sum=(i-1)*m+j;
            sum=poow(131,sum);
            ans+=f[i][j]*sum;
        }
    }
    cout<<ans<<endl;
	return 0;
}
```

---

## 作者：fish_love_cat (赞：7)

注意到每个点可能受到的贡献大致来自「左上」「左下」「右上」「右下」四个方向，观察式子可得同一个方向可以扔掉绝对值得到同一个式子，于是分类讨论。

我们根据式子对于每一个方向记录前缀最小值，然后从当前位置计算出对应值利用前缀和的思想得到当前方向的最优解。

预处理四个方向，每一个点的答案就是对应的四个方向所得答案的最大值。

于是做完了。

警惕一个点重复出现，记得初始化。

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define int long long
using namespace std;
int ans[3005][3005];
int n,m;
void ret(){
    ull flc=0,qwq=1;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    qwq*=131,flc+=qwq*((ull)(ans[i][j]));
    cout<<flc;
}
bool is[3005][3005];
int f[3005][3005];
int f1[3005][3005];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(),cout.tie();
    memset(ans,-0x3f,sizeof ans);
    memset(f,-0x3f,sizeof f);
    int q,k1,k2;
    cin>>n>>m>>q>>k1>>k2;
    while(q--){
        int x,y,u;
        cin>>x>>y>>u;
        f[x][y]=max(u,f[x][y]);
        is[x][y]=1;
    }
    memset(f1,0x3f,sizeof f1);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        if(is[i][j])f1[i][j]=min(f1[i][j],k1*i+k2*j-f[i][j]);
        f1[i][j]=min({f1[i-1][j],f1[i][j-1],f1[i][j]});
        ans[i][j]=max(i*k1+j*k2-f1[i][j],ans[i][j]);
    }
    memset(f1,0x3f,sizeof f1);
    for(int i=n;i;i--)
    for(int j=1;j<=m;j++){
        if(is[i][j])f1[i][j]=min(f1[i][j],k1*(n-i+1)+k2*j-f[i][j]);
        f1[i][j]=min({f1[i+1][j],f1[i][j-1],f1[i][j]});
        ans[i][j]=max((n-i+1)*k1+j*k2-f1[i][j],ans[i][j]);
    }
    memset(f1,0x3f,sizeof f1);
    for(int i=1;i<=n;i++)
    for(int j=m;j;j--){
        if(is[i][j])f1[i][j]=min(f1[i][j],k1*i+k2*(m-j+1)-f[i][j]);
        f1[i][j]=min({f1[i-1][j],f1[i][j+1],f1[i][j]});
        ans[i][j]=max(i*k1+(m-j+1)*k2-f1[i][j],ans[i][j]);
    }
    memset(f1,0x3f,sizeof f1);
    for(int i=n;i;i--)
    for(int j=m;j;j--){
        if(is[i][j])f1[i][j]=min(f1[i][j],k1*(n-i+1)+k2*(m-j+1)-f[i][j]);
        f1[i][j]=min({f1[i+1][j],f1[i][j+1],f1[i][j]});
        ans[i][j]=max((n-i+1)*k1+(m-j+1)*k2-f1[i][j],ans[i][j]);
    }
    ret();
    return 0;
}
// 「接受事实吧。那些孩子已经不存在于任何地方了。」
```

---

## 作者：CaiZi (赞：2)

首先你发现取 $\max$ 操作具有交换律，所以直接把询问离线下来。

然后我们发现，由于 $k_1,k_2$ 是始终不变的，所以如果某个位置周围 $4$ 个位置的答案均已经求出，那么这个位置的答案只能从这 $4$ 个位置转移过来。于是我们考虑 $k_1,k_2\le-1$ 的情况，直接使用 BFS 即可。

然后考虑正解，我们直接将每个询问分别拆成只对左上方、右上方、右下方、左下方的操作。然后分别解决这 $4$ 种情况，每个位置答案取最大值即可。这 $4$ 种情况容易 DP（递推）得出答案。

时间复杂度 $O(q+nm)$。

代码展示：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,k1,k2,x,y;
long long z,f[3001][3001][4];
unsigned long long w=131,s;
signed main(){
    cin.tie(nullptr)->sync_with_stdio(0);
    cin>>n>>m>>q>>k1>>k2;
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
    		f[i][j][0]=f[i][j][1]=f[i][j][2]=f[i][j][3]=-1e18;
		}
	}
    while(q--){
    	cin>>x>>y>>z;
    	f[x][y][0]=f[x][y][1]=f[x][y][2]=f[x][y][3]=max(f[x][y][0],z);
	}
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			if(i!=n){
				f[i][j][0]=max(f[i][j][0],f[i+1][j][0]+k1);
			}
			if(j!=m){
				f[i][j][0]=max(f[i][j][0],f[i][j+1][0]+k2);
			}
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			if(i!=n){
				f[i][j][1]=max(f[i][j][1],f[i+1][j][1]+k1);
			}
			if(j!=1){
				f[i][j][1]=max(f[i][j][1],f[i][j-1][1]+k2);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i!=1){
				f[i][j][2]=max(f[i][j][2],f[i-1][j][2]+k1);
			}
			if(j!=1){
				f[i][j][2]=max(f[i][j][2],f[i][j-1][2]+k2);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
			if(i!=1){
				f[i][j][3]=max(f[i][j][3],f[i-1][j][3]+k1);
			}
			if(j!=m){
				f[i][j][3]=max(f[i][j][3],f[i][j+1][3]+k2);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s+=max({f[i][j][0],f[i][j][1],f[i][j][2],f[i][j][3]})*w;
			w*=131;
		}
	}
	cout<<s;
    return 0;
}

```

---

## 作者：_ckx_ (赞：1)

## 题目大意

有 $q$ 局游戏，每局游戏会给一个坐标 $(x_i,y_i)$，然后每个 $n \times m$ 矩阵中的点 $(a,b)$，都会有一个得分 $u_i + k_1 \cdot \lvert x_i - a \rvert + k_2 \cdot \lvert y_i - b\rvert$，对于每个点，求其在这 $q$ 局游戏中得分的最大值。

## 分析

考虑对于每个点算答案，把左上、左下、右上、右下四个方向分开算得分，然后取 $\max$，这样就把绝对值拆掉了，讨论正负号即可。

以左下为例，得分就是：

$$u_i - k_1 \cdot x_i - k_2 \cdot y_i + k_1 \cdot a + k_2 \cdot b$$

枚举 $(a,b)$，右边两项就是固定的了，只需要对每局游戏的求左边三项和再取 $\max$。

这就转化成了一个二位偏序问题：查找左下角的 $(x,y)$ 的贡献的最大值。

这里我当时没多想，直接按 $x$ 从小到大枚举，再用两个树状数组查前后缀最大值，其实直接预处理前后缀最大值就行了。

时间复杂度 $O(n^2)$，我用的树状数组还得多个 log。

## code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

ll read()
{
    ll ret = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-' ? -f : f), ch = getchar();
    while (isdigit(ch)) ret = ret * 10 + ch - '0', ch = getchar();
    return ret * f;
}

int n ,m ,t;
ll k1 ,k2;
const int N = 3e3 + 10 ,M = 1e6 + 10;
const ll inf = 1e18;
struct node{
	ll x ,y ,u;
} q[M];
ll f[N][N];

//树状数组 
ll c1[N] ,c2[N];
#define lowbit(x) x & -x
void add1(ll *c ,int x ,ll k) { while (x < N) c[x] = max(c[x] ,k) ,x += lowbit(x); }
void add2(ll *c ,int x ,ll k) { while (x) c[x] = max(c[x] ,k) ,x -= lowbit(x); }
ll qry1(ll *c ,int x)
{
	ll ret = -inf;
	while (x) ret = max(ret ,c[x]) ,x -= lowbit(x);
	return ret;
}
ll qry2(ll *c ,int x)
{
	ll ret = -inf;
	while (x < N) ret = max(ret ,c[x]) ,x += lowbit(x);
	return ret;
}

ull qpow(ull a ,ull b)
{
	ull ret = 1;
	while (b)
	{
		if (b & 1) ret *= a;
		a *= a;
		b >>= 1;
	}
	return ret;
}

int main()
{
	n = read() ,m = read() ,t = read() ,k1 = read() ,k2 = read();
	for (int i = 1;i <= n;i++) for (int j = 1;j <= m;j++) f[i][j] = -inf;
	
	for (int i = 1;i <= t;i++) q[i] = {read() ,read() ,read()};
	
	//按 x 坐标排序 
	sort(q + 1 ,q + 1 + t ,[](node a ,node b){ return a.x == b.x ? a.y < b.y : a.x < b.x; });
	
	for (int i = 0;i < N;i++) c1[i] = c2[i] = -inf;
	int now = 1;
	for (int i = 1;i <= n;i++) //x从小到大，计算左下、左上 
	{
		while (now <= t && q[now].x == i)
		{
			add1(c1 ,q[now].y ,q[now].u - q[now].x * k1 - q[now].y * k2);
			add2(c2 ,q[now].y ,q[now].u - q[now].x * k1 + q[now].y * k2);
			now++;
		}
		for (int j = 1;j <= m;j++)
			f[i][j] = max(f[i][j] ,i * k1 + j * k2 + qry1(c1 ,j)) ,
			f[i][j] = max(f[i][j] ,i * k1 - j * k2 + qry2(c2 ,j));
	}
	
	for (int i = 0;i < N;i++) c1[i] = c2[i] = -inf;
	now = t;
	for (int i = n;i >= 1;i--) //x从大到小，计算右下、右上 
	{
		while (now >= 1 && q[now].x == i)
		{
			add1(c1 ,q[now].y ,q[now].u + q[now].x * k1 - q[now].y * k2);
			add2(c2 ,q[now].y ,q[now].u + q[now].x * k1 + q[now].y * k2);
			now--;
		}
		for (int j = 1;j <= m;j++)
			f[i][j] = max(f[i][j] ,-i * k1 + j * k2 + qry1(c1 ,j)) ,
			f[i][j] = max(f[i][j] ,-i * k1 - j * k2 + qry2(c2 ,j));
	}
	
	ull ans = 0; //用自然溢出算答案 
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
			ans += f[i][j] * qpow(131 ,1LL * (i - 1) * m + j);
	
	printf("%llu\n",ans);
	
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

:::::info[Hints]
::::info[Hint 1：我啥都不会]
在线很显然没有前途，考虑离线，将操作放到点上。
::::
::::info[Hint 2：如何拆绝对值]
只用考虑斜着四个方向，每个方向的答案即可。最终答案为这四个方向的 $\max$。
::::
::::info[Hint 3]
观察最终的矩阵，你发现了什么性质？
:::info[性质]
设操作在 $(i,j)$ 时，最大的 $u$ 为 $mx_{i,j}$。

注意到 $ans_{i,j}$ 要么为 $mx_{i,j}$，要么为 $ans_{i\pm 1,j}+k_1$，要么为 $ans_{i,j\pm 1}+k_2$。

证明是显然的。
:::
::::
::::info[Hint 4：根据 Hint 2，如何只维护一个方向？]
以左上为例。

根据 Hint 3 的性质，有转移方程 $ans_{i,j}=\max\{ans_{i-1.j}+k_1,ans_{i,j-1}+k_2,mx_{i,j}\}$。
::::
:::::

请先阅读 Hints，其实 Hint 已经讲的很清楚了。

接着 Hint 4 来讲，你直接开四个递推数组 $f_1,f_2,f_3,f_4$，表示左上/右上/左下/右下的最大值即可，转移与 Hint 4 类似。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=3e3+5;
int n,m,q,k1,k2,mx[N][N];
int f[N][N];
int ans[N][N];

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>n>>m>>q>>k1>>k2;
	memset(mx,-0x3f,sizeof mx);
	memset(ans,-0x3f,sizeof ans);
	for(int i=1;i<=q;i++){
		int x,y,u;cin>>x>>y>>u;
		mx[x][y]=max(mx[x][y],u);
	}
	memset(f,-0x3f,sizeof f);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=max({mx[i][j],f[i-1][j]+k1,f[i][j-1]+k2});
			ans[i][j]=max(ans[i][j],f[i][j]);
		}
	}
	memset(f,-0x3f,sizeof f);
	for(int i=1;i<=n;i++){
		for(int j=m;j>=1;j--){
			f[i][j]=max({mx[i][j],f[i-1][j]+k1,f[i][j+1]+k2});
			ans[i][j]=max(ans[i][j],f[i][j]);
		}
	}
	memset(f,-0x3f,sizeof f);
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			f[i][j]=max({mx[i][j],f[i+1][j]+k1,f[i][j-1]+k2});
			ans[i][j]=max(ans[i][j],f[i][j]);
		}
	}
	memset(f,-0x3f,sizeof f);
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			f[i][j]=max({mx[i][j],f[i+1][j]+k1,f[i][j+1]+k2});
			ans[i][j]=max(ans[i][j],f[i][j]);
		}
	}
	unsigned long long res=0;
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			(res+=ans[i][j])*=782941;
		}
	}
	cout<<res;
	return 0;
}
```

---

## 作者：IMGCsir (赞：0)

## 题目大意
题目要求在一个 $n \times m$ 的网格上进行 $q$ 局游戏，每局游戏会在某个点设定基准得分，并根据该点到网格所有点的曼哈顿距离（带权重 $k1$ 和 $k2$）计算每个位置的得分；最终需要求出每个网格点在所有游戏局中的得分最大值，并按照给定公式（涉及 $131$ 的幂次和自然溢出）输出一个加密的总和。
## 解题思路
可以通过将绝对值表达式分解为四种线性情况（四个象限），并利用二维前缀和后缀最大值来高效计算每个网格点的最大得分，从而避免对每个点进行暴力计算。

首先为每个游戏点计算四种线性表达式的值，并存储在四个二维数组中。

然后对每个二维数组进行后缀最大值处理，确保每个位置存储的是满足条件的所有游戏点的最大值。
对于每个网格点，根据四种情况计算候选值，并取最大值作为该点的得分最大值。

最后按照题目要求，计算所有网格点得分最大值与 $131$ 的幂次乘积之和，并利用自然溢出处理模运算。

时间复杂度 $O(n \times m + q)$。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N=3005;
const long long INF=-1e18;// 初始化为极小的值
int n,m,q;
long long k1,k2;
long long F1[N][N],F2[N][N],F3[N][N],F4[N][N];// 定义四个二维数组，分别对应四种情况的最大值
ull poww[N*N+10];// 存储131的幂次
// 预处理131的幂次表
void initpow(int total){
    poww[0]=1;
    for(int i=1;i<=total;i++)poww[i]=poww[i-1]*131;// 利用自然溢出实现mod 2^64
}
int main() {
    scanf("%d%d%d%lld%lld",&n,&m,&q,&k1,&k2);
    int total=n*m;
    initpow(total);// 初始化幂次表
    for(int i=1;i<=n;i++){// 初始化四个数组为负无穷
        for(int j=1;j<=m;j++){
            F1[i][j]=F2[i][j]=F3[i][j]=F4[i][j]=INF;
        }
    }
    // 处理每个游戏点
    for(int t=0;t<q;t++){
        int x,y;
        long long u;
        scanf("%d%d%lld",&x,&y,&u);
        // 计算四种情况的基准值（不含a,b变量部分）
        long long v1=u+k1*x+k2*y;// 情况1：a<=x, b<=y
        long long v2=u+k1*x-k2*y;// 情况2：a<=x, b>=y
        long long v3=u-k1*x+k2*y;// 情况3：a>=x, b<=y
        long long v4=u-k1*x-k2*y;// 情况4：a>=x, b>=y
        // 更新对应位置的值
        if(v1>F1[x][y]) F1[x][y]=v1;
        if(v2>F2[x][y]) F2[x][y]=v2;
        if(v3>F3[x][y]) F3[x][y]=v3;
        if(v4>F4[x][y]) F4[x][y]=v4;
    }
    // 处理F1：从右下往左上计算后缀最大值（对应情况1：a<=x, b<=y）
    for(int i=n;i>=1;i--){
        for(int j=m;j>=1;j--){
            if(i<n) F1[i][j]=max(F1[i][j],F1[i+1][j]);
            if(j<m) F1[i][j]=max(F1[i][j],F1[i][j+1]);
            if(i<n and j<m) F1[i][j]=max(F1[i][j],F1[i+1][j+1]);
        }
    }
    // 处理F2：从右上往左下计算后缀最大值（对应情况2：a<=x, b>=y）
    for(int i=n;i>=1;i--){
        for(int j=1;j<=m;j++){
            if(i<n) F2[i][j]=max(F2[i][j],F2[i+1][j]);
            if(j>1) F2[i][j]=max(F2[i][j],F2[i][j-1]);
            if(i<n and j>1) F2[i][j]=max(F2[i][j],F2[i+1][j-1]);
        }
    }
    // 处理F3：从左下往右上计算后缀最大值（对应情况3：a>=x, b<=y）
    for(int i=1;i<=n;i++){
        for(int j=m;j>=1;j--){
            if(i>1) F3[i][j]=max(F3[i][j],F3[i-1][j]);
            if(j<m) F3[i][j]=max(F3[i][j],F3[i][j+1]);
            if(i>1 and j<m) F3[i][j]=max(F3[i][j],F3[i-1][j+1]);
        }
    }
    // 处理F4：从左上往右下计算前缀最大值（对应情况4：a>=x, b>=y）
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i>1) F4[i][j]=max(F4[i][j],F4[i-1][j]);
            if(j>1) F4[i][j]=max(F4[i][j],F4[i][j-1]);
            if(i>1 and j>1) F4[i][j]=max(F4[i][j],F4[i-1][j-1]);
        }
    }
    ull ans=0;
    // 计算每个网格点的最终得分最大值
    int index=1;
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++){
            // 计算四种情况的候选值
            long long can1=F1[i][j]-k1*i-k2*j;
            long long can2=F2[i][j]-k1*i+k2*j;
            long long can3=F3[i][j]+k1*i-k2*j;
            long long can4=F4[i][j]+k1*i+k2*j;
            long long max_val=max(max(can1,can2),max(can3,can4));// 取四种情况的最大值
            ans+=(ull)max_val*poww[(i-1)*m+j];// 按照公式累加结果
        }
    }
    printf("%llu\n",ans);
    return 0;
}

```

---

## 作者：yuyang0974 (赞：0)

孩子，绝对值要拆开才好玩。

## 思路历程

暴力应该都会做吧，直接 $O(qnm)$ 枚举就行了。

现在要考虑的是，如何在正确的时间复杂度内完成 $q$ 次询问。

看到了绝对值，一般都得拆开它，那我们不妨拆拆看，研究研究这个多项式有啥可以维护的地方。

对于第 $i$ 次询问：

- 如果 $x_i \ge a \wedge y_i \ge b$，那么 $v = u_i + k_1 x_i - k_1 a + k_2 y_i - k_2 b$
- 如果 $x_i \ge a \wedge y_i < b$，那么 $v = u_i + k_1 x_i - k_1 a - k_2 y_i + k_2 b$
- 如果 $x_i < a \wedge y_i \ge b$，那么 $v = u_i - k_1 x_i + k_1 a + k_2 y_i - k_2 b$
- 如果 $x_i < a \wedge y_i < b$，那么 $v = u_i - k_1 x_i + k_1 a - k_2 y_i + k_2 b$

我们分别命名为情况一、二、三、四，也就是对应如下图的四种情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/z4ibv8wz.png)

四个部分也对应四个表达式，我们变个形：

- 情况一：$v = (u_i + k_1 x_i + k_2 y_i) + (-k_1 a - k_2 b)$
- 情况二：$v = (u_i + k_1 x_i - k_2 y_i) + (-k_1 a + k_2 b)$
- 情况三：$v = (u_i - k_1 x_i + k_2 y_i) + (k_1 a - k_2 b)$
- 情况四：$v = (u_i - k_1 x_i - k_2 y_i) + (k_1 a + k_2 b)$

前一项只与查询信息有关，后一项只与点本身有关，所以只需要每种情况中前一项的影响最大即可。

而前一项在同一个矩形内，同一个 $i$ 的影响是一样的。

我们姑且只考虑情况一，也就变成了：每个查询会对左上角的矩阵范围内产生相同影响。

咦，好像有点前缀和的味道，这不就是二维前缀最大值吗？

欧克，你已经会了，我们只需要维护四个前缀最大值即可。

## AC 代码（赛时代码）

```cpp
#include<bits/stdc++.h>
using namespace std;

#define tp template<typename T>
#define tpp template<typename T, typename ...T1>
#define tpvoid tp void
#define tppvoid tpp void

tpvoid read(T &x) {
    x = 0;
    char c = getchar(), f = 'a';
    while(c < '0' || c > '9') {
        if(!(c ^ '-')) f = 'b';
        c = getchar();
    }
    while(c >= '0' && c <= '9') {
        x = (x << 1) + (x << 3) + (c ^ '0');
        c = getchar();
    }
    if(f ^ 'a') x = -x;
}
tppvoid read(T &x, T1 &...x1) {read(x); read(x1...);}

#define inf 0x3f3f3f3f3f3f3f3f

typedef long long ll;
const int maxn = 3e3 + 5;
int n, m, q;
ll k1, k2;

ll s[5][maxn][maxn];
void getmax(ll &x, ll y) {if(y > x) x = y;}

ll f[maxn][maxn];
void getsum() {
    for(int i = n; i >= 1; i --) {
        for(int j = m; j >= 1; j --) {
            getmax(s[1][i][j], max(s[1][i + 1][j], s[1][i][j + 1]));
        }
    }
    for(int i = n; i >= 1; i --) {
        for(int j = 1; j <= m; j ++) {
            getmax(s[2][i][j], max(s[2][i + 1][j], s[2][i][j - 1]));
        }
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = m; j >= 1; j --) {
            getmax(s[3][i][j], max(s[3][i - 1][j], s[3][i][j + 1]));
        }
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            getmax(s[4][i][j], max(s[4][i - 1][j], s[4][i][j - 1]));
        }
    }
    ll t1, t2, t3, t4;
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            t1 = s[1][i][j] - k1 * i - k2 * j;
            t2 = s[2][i][j] - k1 * i + k2 * j;
            t3 = s[3][i][j] + k1 * i - k2 * j;
            t4 = s[4][i][j] + k1 * i + k2 * j;
            f[i][j] = max(max(t1, t2), max(t3, t4));
            //printf("i:%d, j:%d, t1:%lld, t2:%lld, t3:%lld, t4:%lld\n", i, j, t1, t2, t3, t4);
        }
    }
}

#define ull unsigned long long
const ull base = 131;
ull pb[maxn * maxn];
void init_pow() {
    int N = n * m;
    pb[0] = 1;
    for(int i = 1; i <= N; i ++) pb[i] = pb[i - 1] * base;
}

int main() {
    read(n, m, q, k1, k2);
    //printf("%lld %lld\n", k1, k2);
    for(int i = 0; i <= n + 1; i ++) {
        for(int j = 0; j <= m + 1; j ++) {
            for(int k = 1; k <= 4; k ++) {
                s[k][i][j] = -inf;
            }
        }
    }
    for(int i = 1, x, y, u; i <= q; i ++) {
        read(x, y, u);
        getmax(s[1][x][y], (ll)u + k1 * x + k2 * y);
        getmax(s[2][x][y], (ll)u + k1 * x - k2 * y);
        getmax(s[3][x][y], (ll)u - k1 * x + k2 * y);
        getmax(s[4][x][y], (ll)u - k1 * x - k2 * y);
    }
    getsum();

    ull ans = 0;
    init_pow();
    for(int i = 1, id; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            id = (i - 1) * m + j;
            ans += pb[id] * f[i][j];
            //printf("%lld%c", f[i][j], j ^ m ? ' ' : '\n');
        }
    }/*
    for(int i = 1, id; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            printf("%lld%c", s[1][i][j], j ^ m ? ' ' : '\n');
        }
    }*/
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：lw393 (赞：0)

省流：正着做一遍，反着做一遍，x 轴做一遍，y 轴做一遍（）。

正如省流所说，我们可以将所有的信息放在一起，扫描着做。

首先是输入的处理，我们需要全部初始化为 $-\infty$，然后将 $(x_i,y_i)$ 点的位置改为 $u_i$（注意有重复的点，要取最大）。

我们以 y 轴从上到下扫一遍，我们利用同列元素的处理，直接加 $k_1$，注意比较大小！然后不能直接用原数组，因为可能会改变定义式，不满足原式要求。我们类似于 y 轴的思路，从左往右依次递推，但是可能还不是最大，我们还需要从右往左再递推一次，这样才能保证正确。

类似于 x 轴的讨论，我们还需要对 y 轴反着再做一遍，此时 x 轴也需要与正着做时进行相同的处理。

感觉讲的很乱啊，还是看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N = 3e3 + 5;

int a[N][N];
int b[N][N], c[N][N]; // for 1 to n, n to 1
int temp[N][N], maxn[N][N];
unsigned int mi[N * N];

void solve(){
  memset(a, -0x3f, sizeof(a));
  memset(b, -0x3f, sizeof(b));
  memset(c, -0x3f, sizeof(c));
  memset(temp, -0x3f, sizeof(temp));
  memset(maxn, -0x3f, sizeof(maxn));
  int n, m, q, k1, k2; cin >> n >> m >> q >> k1 >> k2;
  mi[0] = 1; for(int i = 1; i <= n * m; i++) mi[i] = mi[i - 1] * 131;
  for(int i = 1; i <= q; i++) {
    int x, y, u; cin >> x >> y >> u;
    a[x][y] = max(a[x][y], u);
  }
  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= m; j++) b[i][j] = max(a[i][j], b[i - 1][j] + k1);
    for(int j = 1; j <= m; j++) temp[i][j] = b[i][j];
    for(int j = 1; j <= m; j++) temp[i][j] = max(temp[i][j], temp[i][j - 1] + k2);
    for(int j = 1; j <= m; j++) maxn[i][j] = max(maxn[i][j], temp[i][j]);
    for(int j = 1; j <= m; j++) temp[i][j] = b[i][j];
    for(int j = m; j >= 1; j--) temp[i][j] = max(temp[i][j], temp[i][j + 1] + k2);
    for(int j = 1; j <= m; j++) maxn[i][j] = max(maxn[i][j], temp[i][j]);
  }
  memset(temp, -0x3f, sizeof(temp));
  for(int i = n; i >= 1; i--) {
    for(int j = 1; j <= m; j++) c[i][j] = max(a[i][j], c[i + 1][j] + k1);
    for(int j = 1; j <= m; j++) temp[i][j] = c[i][j];
    for(int j = 1; j <= m; j++) temp[i][j] = max(temp[i][j], temp[i][j - 1] + k2);
    for(int j = 1; j <= m; j++) maxn[i][j] = max(maxn[i][j], temp[i][j]);
    for(int j = 1; j <= m; j++) temp[i][j] = c[i][j];
    for(int j = m; j >= 1; j--) temp[i][j] = max(temp[i][j], temp[i][j + 1] + k2);
    for(int j = 1; j <= m; j++) maxn[i][j] = max(maxn[i][j], temp[i][j]);
  }
  unsigned int ans = 0;
  for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++)
      ans += (mi[(i - 1) * m + j] * (unsigned long long)maxn[i][j]);
  cout << ans << '\n';
}

signed main(){
  ios::sync_with_stdio(false);
  ios_base::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  int t = 1;
  //cin >> t;
  while(t--){
    solve();
  }
  return 0;
}
```

---

## 作者：qW__Wp (赞：0)

翻盘失败。分享一下赛时唐诗做法。

考虑对于得分拆绝对值：

+ $x_i \ge a,y_i \ge b$：$u_i + x_ik_1 + y_ik_2 - ak_1 - bk_2$。
+ $x_i \ge a,y_i \le b$：$u_i + x_ik_1 - y_ik_2 - ak_1 + bk_2$。
+ $x_i \le a,y_i \le b$：$u_i - x_ik_1 - y_ik_2 + ak_1 + bk_2$。
+ $x_i \le a,y_i \ge b$：$u_i - x_ik_1 + y_ik_2 + ak_1 - bk_2$。

考虑第一种情况怎么做，其他情况同理。

考虑对于每个位置 $(a,b)$，统计出 $mx_{a,b}=\max\limits_{x_i \ge a,y_i \ge b} u_i + x_ik_1 + y_ik_2$。然后再加上 $-ak_1 - bk_2$ 即可得权值。

具体地，$mx_{a,b} = \max\{mx_{a+1,b},mx_{a,b+1},f_{a,b}\}$。其中 $f_{x_i,y_i} = \max\{ u_i + x_ik_1 + y_ik_2 \}$。你会注意到这里加了一个 $\max$，因为可能有多个 $(x_i,y_i)$ 相等。~~赛时囍挂 70pts。~~

简单递推即可。最后四种情况取 $\max$。时间复杂度 $O(n \times m + q)$。

::::info[Code]
```cpp
#include <bits/stdc++.h>
#define INF 1e18

using namespace std;

const int N = 3005;

long long a[N][N], b[N][N], mx[N][N], ans[N][N];
unsigned long long p[N * N];
int n, m, q;
long long k1, k2;

void init(int v1, int v2) {
	for (int i = 0; i <= n + 1; i ++) {
		for (int j = 0; j <= m + 1; j ++) {
			mx[i][j] = -INF;
			if (i < 1 || i > n || j < 1 || j > m) continue;
			b[i][j] = a[i][j] + v1 * k1 * i + v2 * k2 * j;
		}
	}
}

long long get(int i, int j, int v1, int v2) {
	return mx[i][j] + v1 * k1 * i + v2 * k2 * j;
}

signed main() {
	cin >> n >> m >> q >> k1 >> k2;
	p[0] = 1;
	for (int i = 1; i <= n * m; i ++) p[i] = p[i - 1] * 131;
	for (int i = 1; i <= n; i ++) for (int j = 1; j <= m; j ++) a[i][j] = ans[i][j] = -INF;
	for (int i = 1; i <= q; i ++) {
		long long x, y, u; cin >> x >> y >> u;
		a[x][y] = max(a[x][y], u);
	}
	init(1, 1);
	for (int i = n; i >= 1; i --) { // x >= a, y >= b, 右下 
		for (int j = m; j >= 1; j --) {
			mx[i][j] = max({b[i][j], mx[i + 1][j], mx[i][j + 1]});
			ans[i][j] = max(ans[i][j], get(i, j, -1, -1));
		}
	}
	init(1, -1);
	for (int i = n; i >= 1; i --) { // x >= a, y <= b，左下 
		for (int j = 1; j <= m; j ++) {
			mx[i][j] = max({b[i][j], mx[i + 1][j], mx[i][j - 1]});
			ans[i][j] = max(ans[i][j], get(i, j, -1, 1));
		}
	}
	init(-1, -1);
	for (int i = 1; i <= n; i ++) { // x <= a, y <= b，左上 
		for (int j = 1; j <= m; j ++) {
			mx[i][j] = max({b[i][j], mx[i - 1][j], mx[i][j - 1]});
			ans[i][j] = max(ans[i][j], get(i, j, 1, 1));
		}
	}
	init(-1, 1);
	for (int i = 1; i <= n; i ++) { // x <= a, y >= b，右上 
		for (int j = m; j >= 1; j --) {
			mx[i][j] = max({b[i][j], mx[i - 1][j], mx[i][j + 1]});
			ans[i][j] = max(ans[i][j], get(i, j, 1, -1));
		}
	}
	unsigned long long lans = 0;
	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= m; j ++) {
			lans += ans[i][j] * p[(i - 1) * m + j];
		}
	}
	cout << lans;
	return 0;
}
```
::::

---


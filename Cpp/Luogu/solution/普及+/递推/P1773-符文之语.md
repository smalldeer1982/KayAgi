# 符文之语

## 题目背景

传说中珠穆朗玛峰下有座古代人修建的神庙，神庙的地下室里有古代王室的遗产，但数千年来从未有人到达过……探险者小 FF 一直梦想成为世界上最富有的人和最杰出的探险家并被永载史册。在证明了这个洞确实存在后，小 FF 做好了充足准备，来到了神庙。

## 题目描述

当小 FF 来到神庙时，神庙已经破败不堪了。但神庙的中央有一个光亮如新的石台。小 FF 走近石台，发现石台上有一个数串，而数串的上方刻着一串古老的符文之语。精通古符文之语的小 FF 不费吹灰之力就读懂了文章的意思，其大意是：

对于石台上的一串数字，你可以在适当的位置加入乘号（设加了 $k$ 个，当然也可不加，即分成 $k+1$ 个部分），设这 $k+1$ 个部分的乘积（如果 $k=0$，则乘积即为原数串的值）对 $m$ 的余数（即 $\bmod\ m$）为 $x$；

现求 $x$ 能达到的最小值及该情况下 $k$ 的最小值，以及 $x$ 能达到的最大值及该情况下的 $k$ 的最小值（可以存在 $x$ 的最小值与最大值相同的情况）。

小 FF 还知道，如果他找到了正确的答案，那么就可以通往神庙的下层了。但这个问题似乎不太好解决，小 FF 就找到了你，并答应找到财宝以后和你二八分（当然你拿二……）。

## 说明/提示

记 $L$ 表示字符串的长度。

- 对于 $30\%$ 的数据：$2 \le L \le 50$；
- 对于 $100\%$ 的数据：$2 \le L \le 1000$，$2 \le m \le 50$。

NOI 导刊 $2010$ 提高（$02$）

## 样例 #1

### 输入

```
4421
22
```

### 输出

```
0 1 21 0```

# 题解

## 作者：2018李泽明 (赞：14)

### 前言


------------

这道题是真的恶心，我肝了一个晚上……

这是[P1773 符文之语_NOI导刊2010提高（02）](https://www.luogu.org/problem/P1773)的题解。一道****（无法用语言形容）的DP题，今早考试里被它虐的死去活来（我好蒟啊）。这道题从第一眼看到它我就知道是DP，等到讲题前都没能设出状态……

------------

我们以乘号划分阶段，即f[i][j]表示到第i个数字，满足最小乘积（对m取余后的）所需要划分的阶段（要加的括号）。sum[i][j]表示从第i个数字到第j个数字的乘积对m取余。

DP可以从小到大推，也可以从大到小推，看各位习惯。这里只提供从小到大推的程序（个人习惯）

##### 在程序中的所有乘积后都要记得对m取余（非常重要）

## Code

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int f[1010][60],sum[1010][1010],m,lon;
char zfc[1010];
int main()
{
	memset(f,0x7F,sizeof(f));//因为我是从前到后推的，所以我一开始把f数组定义成无穷大
	scanf("%s\n%d",zfc,&m);//先输入字符串，不要忘记换行 
	lon=strlen(zfc);//lon记录字符串的长度 
	for(int i=1;i<=lon;i++)//sum[i][i]表示从字符串的第i个到第i个的乘积
		sum[i][i]=zfc[i-1]-'0';//当前这一位到自己只有一位啊，所以取不取余倒也没有什么关系 
	for(int i=lon;i>=1;i--)//i是从后往前查的 
		for(int j=i+1;j<=lon;j++)//j从前往后查，所以f[i][j-1]显然是已经知道了的 
			sum[i][j]=(sum[i][j-1]*10%m+sum[j][j])%m;//从i到j显然是i到j-1位的乘积乘10加上当前这一位 
	for(int i=1;i<=lon;i++)//f[i][sum[1][i]]表示从第1个点到第i个点时乘积为sum[1][i]所要加的乘号 
	 	f[i][sum[1][i]]=0;//仔细想一想，一个乘号都不用加，乘积为sum[1][i]的数就是字符串前i位的乘积 
	for(int i=1;i<=lon;i++)//枚举字符串 
		for(int j=1;j<i;j++)//从j到i的区间 
			for(int k=0;k<m;k++)//乘积取余，求的是答案 
				if(f[j][k]+1<f[i][k*sum[j+1][i]%m])//如果在第j个数字后放乘号能比原来的决策好 
					f[i][k*sum[j+1][i]%m]=f[j][k]+1;//更新 
	for(int i=0;i<m;i++)//从小到大推肯定要从前面找答案啊，如果不是0x7F说明这个状态存在 
		if(f[lon][i]<0x7F)
		{
			printf("%d %d ",i,f[lon][i]);//不输出等啥呢？ 
			break;
		}
    for(int i=m;i>=0;i--)//最大值同理啊 
		if(f[lon][i]<0x7F)
		{
			printf("%d %d",i,f[lon][i]);
			break;
		}
	return 0;
}

```
这道题主要是状态难设，其他倒也没有什么。所以大家要努力攻克DP啊。

方程不规范，爆零两行泪……

---

## 作者：asdfghjkl123 (赞：10)

楼下二位的代码已经非常明白了，由于我个人也是对题解的代码纠结了很长时间，又由于我能AC，确实需要感谢题解代码的帮助……所以我在这里为了帮助大家理解，对于代码进行一些解释。

零、首先看看我定义的变量（INF也放在这里说）
```cpp
#define INF 1e7
char a[1001];
int mod;
int M[1001][1001];
int dp[1001][51];
```
命名：a[]：字串。mod：模数。n：字串长度。M[i][j]，从i位到j位组成的数字对于mod的模。dp[i][j]前i个字符能够达到模为j的操作数

一、首先来看读入和取模。（这里是我自己想的，真的是我自己想的）
```cpp
	cin>>a+1;
	int n=strlen(a+1);
	scanf("%d",&mod);
	for(int i=1;i<=n;i++)M[i][i]=(a[i]-='0')%mod;
	for(int l=n;l>=1;l--)for(int r=l+1;r<=n;r++)M[l][r]=(M[l][r-1]*(10%mod)+M[r][r])%mod;

```
由于我对于scanf读字符串有着浓厚的阴影，所以对于数字串的读入我选择了cin，那个+1只是个人习惯从1开始操作。读入之后strlen出字串长度。注意！strlen是在cstring的一个函数，请不要忘记包含cstring库！！！

取模的话，首先处理出单个字符的模值。然后用那两个公式逐步向上推。

两个公式：(a%m+b%m)%m=(a+b)%m;以及((a%m)*(b%m))%m=(a*b)%m

具体实现就是上述代码中的第二个循环。

二、再来看状态转移。不得不说，这一题的状态转移是比较难想的。（这里我承认我看了题解，因为我真的想不出正确的状转方程）
    
```cpp
	for(int i=1;i<=n;i++)for(int j=0;j<=mod;j++)dp[i][j]=INF;
	for(int i=1;i<=n;i++)dp[i][M[1][i]]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			for(int k=0;k<mod;k++)
			{
				dp[i][(k*M[j+1][i])%mod]=min(dp[i][(k*M[j+1][i])%mod],dp[j][k]+1);
			}
		}
	}
```
首先，常规操作，对于每一个dp，赋上一个极大值，便于进行更新。

然后处理出dp[i][M[1][i]]的值，也就是，对于从1到i位组成的数，它对于mod的余数的操作数。显然的，对于这些段，其间是没有切割的，所以可以赋初值为0.

接着就是向下推。
不难理解ij循环的含义，就是枚举区间，也就是从j到i的区间。

那么我们看k循环，首先观察k的范围：0~mod……这能说明什么？这说明k枚举的是答案！再看循环体：
```cpp
{
	dp[i][(k*M[j+1][i])%mod]=min(dp[i][(k*M[j+1][i])%mod],dp[j][k]+1);
}
```
哦，我们想起来了dp数组的含义。那么这样来说，这个状转方程就不难理解了。也就是，对于每一个i，枚举其可以取到的j，然后由dp[j][k]推出当前位的数值，并取min。

然后就是输出了，两个循环，分别从小往大从大往小枚举dp的第二个维度，如果读到小于极大值的数字，那么就可以输出了。
```cpp
	for(int i=0;i<mod;i++)if(dp[n][i]<INF){cout<<i<<" "<<dp[n][i]<<" ";break;}
	for(int i=mod-1;i>=0;i--)if(dp[n][i]<INF){cout<<i<<" "<<dp[n][i]<<endl;return 0;}
```

至此，我们就可以AC这道题了。这道题的状转比较难想，而且至少对我来说，没怎么见过这种状转。所以……这道题比较值得收藏。

---

## 作者：Mine_King (赞：5)

首先应该想到这题是个 DP。

然后从数据范围的角度看，没有对 $k$ 做任何限制，所以 $k$ 显然不会出现在 DP 数组中，那么它只能当答案。  
于是 DP 数组表示的意义就显而易见了：  
设 $dp_{i,x}$ 表示前 $i$ 个数，最少用 $dp_{i,x}$ 个乘号能凑出 $x$。  
接着考虑状态转移方程，我们考虑到枚举从第几个转移过来是必不可少的，设它为 $j$。然后，知道 $j$ 的值之后，我们就不需要枚举转移过来的那个 $x$ 是多少了，因为我们是在 $j$ 后面添加**一个**乘号得出来的 $dp_{i,x}$，所以之前的 $x$ 显然是可以求出来的。  
再仔细思考就可以得出状态转移方程：
$$dp_{i,x}=\min\limits_{j=1}^{i-1} (dp_{j,x/sum(j+1,i)}+1)$$  
这里的 $sum(l,r)$ 表示的是截取 $l$ 到 $r$ 这一段的数值。  

但是但是，这是在模意义下的，也就是说，你的除法会受到很大的阻碍，比如需要求逆元。但是注意，我们无法保证 $sum(j+1,i)$ 在模 $m$ 意义下有逆元，所以我们必须舍弃这种方法。

反过来想，既然不能用 $push$ 型转移，那么就用 $pull$ 型转移吧（即从当前推后面）！  
已经有了上面的那个式子，我们也很容易就能得出新的状态转移方程：
$$dp_{j,x \times sum(i+1,j)}=min(dp_{j,x \times sum(i+1,j)},dp_{i,x}+1)$$  
这里的 $j$ 的范围应该是 $i+1$ 到 $n$。

这样我们就完美解决了取模的问题。  

下面是一些小细节（但同样会对你的代码是否 AC 有很大的影响）：

- 对于上面式子中的 $sum$ 函数，需要前缀和预处理，不然时间复杂度是不对的。
- 使用字符串读入，千万别一个个读（亲身试验会挂得很惨）。
- 初始化 $dp_{i,sum(1,i)}=0$，这个我想不用多说吧。然后其他的应该被赋为极大值（因为求的是 $min$ 啊）
- 因为最终我们无法确定最小（或最大）可行的 $x$ 是多少，所以最后需要刷表。

对了，时间复杂度是 $O(L^2m)$ 的。

代码如下：
```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,a[1005];
int dp[1005][55];
int mul[1005][1005];
string s;
int main()
{
	cin>>s;
	n=s.length();
	for(int i=1;i<=n;i++) a[i]=s[i-1]-'0';
	scanf("%d",&m);
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			mul[i][j]=(mul[i][j-1]*10+a[j])%m;//前缀和预处理
	memset(dp,0x3f,sizeof(dp));
	int INF=dp[0][0];
	for(int i=1;i<=n;i++) dp[i][mul[1][i]]=0;
    //初始化
	for(int i=1;i<=n;i++)
		for(int x=0;x<m;x++)
			for(int j=i+1;j<=n;j++)
					dp[j][x*mul[i+1][j]%m]=min(dp[j][x*mul[i+1][j]%m],dp[i][x]+1);
                    //状态转移
	for(int i=0;i<m;i++)
		if(dp[n][i]!=INF){printf("%d %d ",i,dp[n][i]);break;}
	for(int i=m-1;i>=0;i--)
		if(dp[n][i]!=INF){printf("%d %d\n",i,dp[n][i]);break;}
        //注意结果需要刷表
	return 0;
}
```

---

## 作者：lizicheng3042 (赞：2)

# 题目概要:
给定一个只含数字的字符串，求将其划分为 $k+1$ 段的乘积对 $m$ 取余的最小值和最大值以及其对应的最小 $k$ 值。  
那么,首先因为题目中要求求 $k$ 的值，那么 $dp$ 数组的话应该是存储 $k$ 的值，且要求对 $m$ 取余的话，那么就可以通过一个二维的 $dp$ 数组，表示前 $i$ 个数字的乘积对 $m$ 取余后所用 $k$ 的最小值，如此一来，既能符合题目要求，又能得出一个比较清晰转移思路，那么之后的话这道题就好做了。  
大部分动态规划题的难点在于无法得出一个有效可行的转移思路哦，所以平时看到想不出的转移思路的时候要自己想一下，锻炼一下思维，为更多的 DP 做准备。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char n[1005];
int m,dp[1005][55],sum[1005][1005];
int main()
{
	scanf("%s\n%d",&n,&m);
	int len=strlen(n);
	for(int a=0;a<len;a++)//字符串预处理 
	{
		sum[a+1][a+1]=n[a]-48;
	    for(int b=a+1;b<len;b++)
	        sum[a+1][b+1]=(sum[a+1][b]*10+n[b]-48)%m;
	}
	for(int a=0;a<=len;a++)
		for(int b=0;b<m;b++) 
		    dp[a][b]=10000;
	dp[0][1]=-1;
	for(int a=1;a<=len;a++)
		for(int b=1;b<=a;b++)
			for(int c=0;c<m;c++)
			    dp[a][(c*sum[b][a])%m]=min(dp[a][(c*sum[b][a])%m],dp[b-1][c]+1);
	for(int a=0;a<m;a++)//正着一遍 
		if(dp[len][a]!=10000)
		{
			printf("%d %d ",a,dp[len][a]);
			break;
		}
	for(int a=m-1;a>=0;a--)//反着一遍 
		if(dp[len][a]!=10000)
		{
			printf("%d %d ",a,dp[len][a]);
			break;
		}
	return 0;
}
```


---

## 作者：Memorize (赞：2)

开始做的时候一直掉到乘积最大的那个坑里面去了 最后果断弃疗看了楼下题解 豁然开朗...！

抓住题目的变化，或许换一个角度来思考问题说不定就会有新的发现！

（没有C++代码那我来补充一份吧）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define inf 99999999
using namespace std;
int m,len;
char s[1010];
int a[1010];
int sum[1010][1010],f[1010][100];
int main()
{
    memset(f,0x7f7f7f,sizeof(f));
    scanf("%s%d",s,&m);
    int len=strlen(s);
    for(int i=0;i<len;i++) a[i+1]=s[i]-'0';
    for(int i=1;i<=len;i++)
     for(int j=i;j<=len;j++)
      sum[i][j]=(sum[i][j-1]*10+a[j])%m;//预处理出每个区间取mod后的值 
    for(int i=1;i<=len;i++) f[i][sum[1][i]]=1;  
    for(int i=1;i<=len;i++)
     for(int j=1;j<i;j++)
      for(int k=0;k<=m-1;k++) f[i][(k*sum[j+1][i])%m]=min(f[i][(k*sum[j+1][i])%m],f[j][k]+1);
    for(int i=0;i<m;i++) if(f[len][i]<inf){printf("%d %d ",i,f[len][i]-1);break;}   
    for(int i=m-1;i>=0;i--) if(f[len][i]<inf){printf("%d %d",i,f[len][i]-1);break;}   
    return 0;
}
```

---

## 作者：Eris (赞：2)

【试题分析】

- 这是道简单的DP题， 很容易让人联想到“乘积最大”那道题目，就是将一串数分成若干部分，使得乘积最大。 但是如果认为方程和那道题目差不多，那么就错了。

如果按照乘积最大那题的思路：

**f[i] = max{f[i], f[j]\*number[j+1,i] }** 表示将前i位分成若干部分得到的最大乘积由将前j位分成若干部分的最大乘积 \* [j+1~i]这段区间的数字转移过来。

但是这个方程是错误的， 因为题目是将结果对m取余， 所以由这个方程得到的局部最优并不能导致全局最优， 所以必须换个思路。


- 我们可以尝试按照余数来划分状态：

f[ j , k ] 表示前j位能够使得余数为k所需划分的最少部分。那么很容易就可以由f[ j , k ]推出f[ i, k\*mod\_number[ j+1,i ] ] 所需划分的最少部分。（其中mod\_number[j+1,i]为[ j+1, i ]区间的数对m取余的结果）。 即

**f[ i, k\*mod\_number[ j+1,i ] ] = min{f[ j ,  k ]+1，f[ i, k\*mod\_number[ j+1,i ] ]} ;**

时间复杂度： o(len^2\*m), len为字串长度。


- 预处理的时候，我们将字串的各个去区间的数字取mod的值先求出来，用sum数组来储存。初始化的时候，for i:=1 to length do f[i,sum[1,i]]:=0; 将前 i 个数字不加乘号的情况先求出来，作为后面递推的初始条件。


- 循环：for i:=1 to length do //枚举前i个数字

for j:=1 to i-1 do //枚举前i个数字中添加乘号的位置

for k:=0 to m-1 do//枚举取mod的值 

【程序】



```cpp
[color=red]代码：[/color][codep ]
uses math;//[color=red]调用 min [/color]
var
 f:array[0..1000,0..50] of longint;
 sum:array[0..1000,0..1000] of longint;
 n,m,i,j,k,l,zc:longint;
 a:array[0..1000] of longint;
 ch:char;
begin
 zc:=0;
 read(ch);
 while ch<>chr(13) do
  begin
   inc(zc);
   a[zc]:=ord(ch)-48;
   read(ch);
  end;
 readln(m);
 for i:=1 to zc do
  for j:=i to zc do
   sum[i,j]:=(sum[i,j-1]*10+a[j]) mod m;//[color=blue]初始化去 mod [/color]
 for i:=0 to 1000 do
  for j:=0 to 50 do
   f[i,j]:=100000;
 for i:=1 to zc do
  f[i,sum[1,i]]:=0;//[color=blue]初始化[/color]
 for i:=1 to zc do
  for j:=0 to i-1 do
   for k:=0 to m-1 do
     f[i,(k*sum[j+1,i]) mod m]:=min(f[j,k]+1,f[i,(k*sum[j+1,i]) mod m]);
 for i:=0 to m-1 do
  if f[zc,i]<>100000 then
   begin
    write(i,' ',f[zc,i],' ');//[color=blue]最小值[/color]
    break;
   end;
 for i:=m-1 downto 0 do
  if f[zc,i]<>100000 then
   begin
    writeln(i,' ',f[zc,i]);//[color=blue]最大值[/color]
    break;
   end;
end.
[/codep ]
```

---

## 作者：SIXIANG32 (赞：1)

论·小 SX 是如何做到明明写出了正解然而鹅不小心手残在外面多打了两个循环导致 TLE 这档事。  
闲话少说，切入正题——  

---
显然，这是一道 dp。  
设 $f_{i, x}$ 为当前已经处理到第 $i$ 位了，然后为了弄出来 $x$ 至少需要搞几个乘号。  
我们除了枚举 $i$ 和 $x$ 还要枚举乘号放的位置 $j(1 \le j < i)$，然后呢我们来想一下，无非是这两种情况——   

- 在 $j$ 加一个乘号。  
	这就很显然了，$f_{j, x \div mul_{j + 1, i}} + 1$（$mul_{l, r}$ 表示这里面区间 $[l, r]$ 的的乘积。）  
- 不在 $j$ 添加乘号。  
	这就直接 $f_{i, x}$。  

也就是说，状态转移方程就是 $f_{i, x} = \min(f_{i, x}, f_{j, x \div mul_{j + 1, i}} + 1)$。  

---
状态转移方程都列出来了，这道题该结束了吧。  
当然没有（斜眼笑  
你看啊，$x \div mul_{j, i}$ 要是个小数咋办呢。  
这……  
我们上面已经提到除法了。我们都知道，除行不通的时候，往往是乘法上的时候。那么如果我们把这个除法改成乘法，填表改成刷表呢？  
$f_{i, x}$ 改成 $f_{i, x \times mul_{j + 1, i} \mod m}$， $f_{j, x\div mul_{j + 1, i}}$ 改成 $f_{j, x}$。  
最后得到的状态转移方程——  
$f_{i, x \times mul_{j + 1, i} \mod m} = \min(f_{j, x} + 1, f_{i, x \times mul_{j + 1, i}\mod m})$。   
一定别忘了 $\mod m$ 啊！

---
代码——  
```cpp
#include <iostream> 
#include <string>
#include <cstring>
#define MAXN 5000
#define QWQ cout << "QWQ" << endl;
using namespace std;
int f[MAXN + 10][MAXN + 10];
int mul[MAXN + 10][MAXN + 10], a[MAXN + 10];
int min(int x, int y) {return ((x < y) ? (x) : (y));}
int main() {
	memset(f, 0x7f, sizeof(f));
	int m, len; string str;
	cin >> str >> m, len = str.size();
	for(int p = 0; p < len; p++)
		a[p + 1] = int(str[p] - '0');
	for(int p = 1; p <= len; p++)
		for(int i = p; i <= len; i++)
			mul[p][i] = (mul[p][i - 1] * 10 + a[i]) % m;//mul 是区间乘积的计算
	for(int p = 1; p <= len; p++)
		f[p][mul[1][p]] = 0;//初始化，显然这些是不用加乘号的
	int INF = f[0][0];//因为 memset 0x7f 会产生一个非 0x7f 而是一个奇怪的大值
	for(int p = 1; p <= len; p++)
		for(int x = 0; x < m; x++)
			for(int i = 1; i < p; i++)
				f[p][x * mul[i + 1][p] % m] = min(f[i][x] + 1, f[p][x * mul[i + 1][p] % m]);//转移
	for(int p = 0; p < m; p++)
		if(f[len][p] != INF) {
			cout << p << ' ' << f[len][p] << ' ';
			break;
		}
	for(int p = m - 1; p >= 0; p--)
		if(f[len][p] != INF) {
			cout << p << ' ' << f[len][p] << ' ';
			break;
		}
}
```

---

## 作者：Boxxxxxx (赞：1)

其实， 这个dp还是蛮简单的，dp做多了后就会觉得方程不难出了，其实我的思路和大家都差不多，但是大部分都用了O(N^2)去预处理出这个区间内的值取模后是多少，其实这是完全没有必要的。~~听我来给你吹~~ 

f[i][j]  = v：前i个字符各种操作后的数字为j，使用的最少的乘法个数为v，**最后一个字符必须要落在i后面！！！！**

为什么我们要强行让他最后一个乘法字符在i后面，因为如果不这么做，我们就无法知道他最后一个乘法字符在哪里，你就算不出一个值与前面的值相乘。

接下来考虑怎么转移

f[i][j] = min(f[k][z] + 1),

其中k<i,然后（z * [k+1,i]）%mod ==j

放一个乘法字符在i后面，然后枚举前面的位置哪些可以算到最后的答案是j

很显然你只需要枚举一次前面所有的状态就可以得到i可以满足的每一个j，**不需要对于每一个j就去枚举一次所有状态！！！！**下一步，怎么得到某些区间的数字取mod后的结果是多少。

其实仔细观察可以知道，我们i是从1到len开始枚举的，然后对于每一个f[i][j]， 后面需要利用到f[i][j]都是从i后面的数字到当前位置的数字，那么就是我们可以有一个num数组,这个数组存的内容就是

num[z] = v, 从z+1到当前位置的字符串取模后的值

当前的位置为i，那么在前面所有位置的num[z]，都只需要*10+当前的字符，再去取模，那么就是当前需要的那个数字答案啦！


```cpp
int v = (num[j] * 10 + (node[i] - '0')) % m;
			num[j] = v;
```

上面代码的i就是当前位置，j就是枚举前面所有的位置。
这样子去转移就是纯的O(N^2M)，不需要额外加上
n^2的预处理！

小提醒，他是对m取模！！！~~我当初用之前设置的mod取模wa了好多次完全不知道哪错了~~ 
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<time.h>
#include<string>
#include<stack>
#include<cmath>
#include<map>
#include<set>
#define int long long
//#define double long double
using namespace std;
#define PI  3.1415926535898 
#define eqs 1e-6
const long long max_ = 1000 + 7;
const int mod = 998244353;
const int inf = 1e9;
const long long INF = 1e18;
int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (ch<'0' || ch>'9') {
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0'&&ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * f;
}
int min(int a, int b) {
	return a < b ? a : b;
}
int max(int a, int b) {
	return a > b ? a : b;
}
char node[max_];
int num[max_],f[max_][60],m;
signed main() {
	std::ios::sync_with_stdio(false);
	cin >> node + 1;
	cin >> m;
	int len = strlen(node + 1);
	memset(f, 23, sizeof(f));
	//memset(num, 0, sizeof(num));
	f[0][1] = -1;
	for (int i = 1; i <= len; i++) {
		for (int j = 0; j < i; j++) {
			int v = (num[j] * 10 + (node[i] - '0')) % m;
			num[j] = v;
			for (int z = 0; z < m; z++) {
				if (f[j][z] > len) continue;
				int vv = ((z % m)*(v % m)) % m;
				f[i][vv] = min(f[i][vv], f[j][z] + 1);
			}
		}
	}
	for (int i = 0; i < m; i++) {
		if (f[len][i] < len) {
			cout << i << " " << f[len][i] << " "; break;
		}
	}
	for (int i =m - 1; i >= 0; i--) {
		if (f[len][i] < len) {
			cout << i << " " << f[len][i]; break;
		}
	}
	return 0;
}
```



---

## 作者：mzgwty (赞：1)

今天考试出了这道题，刚开始打了个5重循环的区间dp，时间复杂度高达$O(n^3m^2)$

是这样的，$dp[i][j][k]$表示从第i个到第j个数组合成一个取模m为k的数所需的乘号最少的数量，于是，不难得到下面的方程

$dp[i][j][a*b\ mod\ m]=min(dp[i][j][a*b\ mod\ m],dp[i][k][a]+dp[k+1][j][b]+1)$

a,b是模m后的余数

果断在MZOJ上得了40分

然后经半小时的苦想，本蒟蒻终于发现了原来可以不用管i~j以k为断点的后半部分是否有乘号，因为在之后的dp过程中会处理这种情况，所以我们不必处理辣。

便又有了新的dp表示与方程

$dp[i][k]$表示前i个数的组合模m等于k最少需要的乘号个数

$num[i][j]$表示不加乘号从i到j的这个数模m的值

$dp[i][k*num[j+1][i]\ mod\ m]=min(dp[i][k*num[j+1][i]\ mod\ m],dp[j][k]+1)$

j是小于i的所有正整数,k是1~j取模后的结果

所以便有代码如下辣(时间复杂度$O(n^2m)$,很优辣)

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std; 
inline int read() {
    int res=0,f=1;char ch;    
	while(!isdigit(ch=getchar())) if(ch=='-') f=-1;    
	do {
        res=res*10+ch-'0';    
	} while(isdigit(ch=getchar()));    
	return res*f;
}
int dp[1005][55],a[55],num[1005][1005]; 
char s[1005]; 
int main() {
    scanf("%s",s);    
	int n=strlen(s);    
	for(register int i=0 ; i<n ; ++i) a[i+1]=s[i]-'0';    
	int m=read();    
	for(register int i=1 ; i<=n ; ++i) {
        num[i][i]=a[i]%m;        
		for(register int j=i+1 ; j<=n ; ++j) num[i][j]=(num[i][j-1]*10+a[j])%m;    
	}    
	memset(dp,0x3f,sizeof(dp));    
	for(register int i=1 ; i<=n ; ++i) dp[i][num[1][i]]=0;    
	for(register int i=1 ; i<=n ; ++i) {
        for(register int j=1 ; j<i ; ++j) {
	        for(register int k=0 ; k<m ; ++k) {
	            dp[i][k*num[j+1][i]%m]=min(dp[i][k*num[j+1][i]%m],dp[j][k]+1);
            }        
		}    
	}    
	for(register int i=0 ; i<m ; ++i) {
        if(dp[n][i]!=inf) {
            printf("%d %d ",i,dp[n][i]); 
            break ;        
		}    
	}    
	for(register int i=m-1 ; i>=0 ; --i) {
        if(dp[n][i]!=inf) {
            printf("%d %d",i,dp[n][i]);
            break ;        
		}    
	}    
	return ~~(0^0);
} 
```
$update:2019.8.4$ 补了方程里的一个小锅

---

## 作者：koreyoshi_lemon (赞：0)

一看数据范围，模数这么小，直接作为一个维度。设计状态：

$dp_{i,j}$ 表示前 $i$ 位拼凑出余数为 $j$ 的最小操作数。转移方程就是：

$dp_{i,k \cdot num(j+1,i)}=min(dp_{j,k}+1)$

其中 $num_{l,r}$ 表示 $l$ 到 $r$ 这段字符组成的数字。需要预处理，复杂度 $O(n^2)$ 而转移需要枚举 $i,j,k$ 三个变量，复杂度 $O(n^2m)$ 可以通过本题。

```pascal
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+7;
char s[N];
int dp[N][N],m;
int nums[N][N];
int main(void)
{
	memset(dp,0x3f,sizeof(dp));
	scanf("%s%d",s+1,&m);
	int n=strlen(s+1);
	for(int i=1;i<=n;i++)
		nums[i][i]=(s[i]-'0')%m;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)	{
			nums[i][j]=nums[i][j-1]*10+(s[j]-'0');
			nums[i][j]%=m;
		}
	for(int i=2;i<=n;i++)
		dp[i][nums[1][i]]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<i;j++)
			for(int k=0;k<m;k++)	{
				int to=k*nums[j+1][i]%m;
				dp[i][to]=min(dp[i][to],dp[j][k]+1);
			}
	for(int k=0;k<m;k++)
		if(dp[n][k]<1e9)	{
			printf("%d %d ",k,dp[n][k]);
			break;
		}
	for(int k=m-1;k>=0;k--)
		if(dp[n][k]<1e9)	{
			printf("%d %d",k,dp[n][k]);
			break;
		}
	return 0;
}
```


---

## 作者：两年打铁 (赞：0)

模数很小，考虑用模数来设计状态。

首先我们可以$O(n^2)$预处理出任意区间的数字，然后进行下一步考虑。

设$f_{i ,j}$表示当前为第$i$位，乘积$mod \ m$为$j$的最小步数。

这样转移就非常显然了，我们只需要枚举上一个端点，再枚举上一个端点得到的余数，直接乘上这一段区间的数字即可。

注意初始化

```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define kong putchar(' ')
#define huan putchar('\n')
#define bug puts("QWQ")
#define pr putchar
#define int long long 
const int big=0x7fffffff;
using namespace std;
inline void read(int &x)
{
    x=0;char ch=getchar();int pd=1;
    while(ch<'0'||ch>'9'){if(ch=='-')pd=-pd;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    x*=pd;
}
inline void write(const int &x)
{
    char ggg[100];int s=0;int tmp=x;
    if(tmp==0){putchar('0');return;}
    if(tmp<0){tmp=-tmp;putchar('-');}
    while(tmp>0){ggg[s++]=tmp%10+'0';tmp/=10;}
    while(s>0){putchar(ggg[--s]);}
}
inline void wrs(const int &x)
{
	write(x);
	putchar(' ');
}

inline void wrl(const int &x)
{
	write(x);
	putchar('\n');
}

const int N=1004;

int n,mod;
char s[N];
int a[N],p[N],f[N][N],g[N][N];

signed main()
{
	scanf("%s",s+1);
	read(mod);
	n=strlen(s+1);
	for(register int i=1;i<=n;++i)
	{
		a[i]=s[i]-'0';
	}
	p[0]=1;
	for(register int i=1;i<=n;++i)
	{
		p[i]=p[i-1]*10%mod;
	}
	memset(f,40,sizeof(f));
	for(register int i=1;i<=n;++i)
	{
		for(register int j=i;j;--j)
		{
			g[j][i]=g[j+1][i]+a[j]*p[i-j];
			g[j][i]%=mod;
		}
		f[i][g[1][i]%mod]=0;
	}
	for(register int i=1;i<=n;++i)
	{
		for(register int j=2;j<=i;++j)
		{
			for(register int k=0;k<mod;++k)
			{
				f[i][k*g[j][i]%mod]=min(f[i][k*g[j][i]%mod],f[j-1][k]+1);
			}
		}
	}
	for(register int i=0;i<mod;++i)
	{
		if(f[n][i]<1e9)
		{
			cout<<i<<" "<<f[n][i]<<" ";
			break;
		}
	}
	for(register int i=mod-1;i>=0;--i)
	{
		if(f[n][i]<1e9)
		{
			cout<<i<<" "<<f[n][i]<<endl;
			break;
		}
	}
	return 0;
}

```


---


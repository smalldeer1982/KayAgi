# 三只小猪

## 题目背景

你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。


## 题目描述

为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图

 ![](https://cdn.luogu.com.cn/upload/pic/6862.png) 

“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？


## 样例 #1

### 输入

```
4 2```

### 输出

```
7```

## 样例 #2

### 输入

```
6 7```

### 输出

```
0```

# 题解

## 作者：_ZZH (赞：50)

最优解第四来水一发（~~虽然开了o2~~）

(~~不点赞也无所谓，~~只要不照抄)

我们考虑将第n只小猪塞进m个房子里（记做f[n][m]）：

显然答案分为两部分：

第一部分：

将这只猪扔到一个新房间，共有方案数：f[n-1][m-1]

第二部分：

将这只猪扔进之前的房间,乘法原理知共有方案数:m*f[n-1][m]

综上：有状态转移方程：f[n][m]=f[n-1][m-1]+m*f[n-1][m]

特别的：f[1][1]=1

这种数就是将n个不同的元素拆分成m个集合的方案数，又称：第二类斯特林数。

同时由于数据范围较大，考虑使用高精加和高精乘。

那么我们令f[i][j][0],表示f[i][j]的位数，之后为f[i][j]每一位。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
using namespace std;
int f[60][60][60];
int _ans[60],_size;
int n,m;
void _change(int x,int y)
{
	if(y>x)return;
	if(x==1&&y==1)return;
	for(int i=1;i<=_size;i++)
	_ans[i]=0;
	_size=1;
	int _x=0;
	for(int i=1;i<=f[x-1][y][0];i++)
	{
		_ans[i]=f[x-1][y][i]*y+_x;
		_x=_ans[i]/10;
		_ans[i]%=10;
	}
	_size=f[x-1][y][0];
	if(_x!=0)
	_ans[++_size]=_x;
	f[x][y][0]=1;
    _x=0;
    while(f[x][y][0]<=f[x-1][y-1][0]||f[x][y][0]<=_size)
    {
        f[x][y][f[x][y][0]]=f[x-1][y-1][f[x][y][0]]+_ans[f[x][y][0]]+_x;
        _x=f[x][y][f[x][y][0]]/10;
        f[x][y][f[x][y][0]]%=10;
        f[x][y][0]++;
    }
    f[x][y][f[x][y][0]]=_x;
    if(f[x][y][f[x][y][0]]==0&&f[x][y][0]!=1)
    f[x][y][0]--;
}
int main()
{
	scanf("%d%d",&n,&m);
	if(m>n)
	{
		cout<<0;
		return 0;
	}
	f[1][1][0]=1;
    f[1][1][1]=1;
	for(int i=2;i<=n;i++)
	for(int j=1;j<=min(i,m);j++)
	_change(i,j);
	if(f[n][m][0]==1&&f[n][m][1]==0)
	{
		cout<<0;
		return 0;
	}
	for(int i=f[n][m][0];i>=1;i--)
	printf("%d",f[n][m][i]);
}
```

---

## 作者：xrk2006 (赞：15)

**P3904 三只小猪 题解**

**[博客食用效果更佳](https://www.luogu.com.cn/blog/xrkRetaGRB/p3904-san-zhi-xiao-zhu-ti-xie)**

**题目链接：[P3904 三只小猪](https://www.luogu.com.cn/problem/P3904)**

这题和[P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655)实在是太像了，它们的基本模型和所用的知识点都是一样的，甚至可以转化为同一道题，但那道题的数据范围大于这道题；并且那道题有多组数据，而这道题只有一组数据。。。。所以这样来说，这道题反而简单。~~但我很不明白，为什么那道题是绿题，这道是蓝？又一个恶评？~~

建议做了这道题的童鞋可以去做做小朋友的球。

**分析**

这是一个很典型的排列组合问题，完全可以放在高中数学里面的排列组合问题；这道题也是 12 种放球问题里面的一种（放球问题具体参见[放球问题—— by dbxxx 大佬](https://www.cnblogs.com/crab-in-the-northeast/p/ball-box-question.html)），然后如果想练放球问题，建议去做[十二重计数法](https://www.luogu.com.cn/problem/P5824)，但这道题数据范围太大，其中的第十个和第十二个都要用到多项式，所以我们出了一个数据范围只有 1000 的[十二重计数法【弱化版】](https://www.luogu.com.cn/problem/T188453)，可以方便您练习放球问题。

现在我们来看一下这道题。

大致题意：

将 $n$ 只小猪，分配到 $m$ 间**相同**的屋子里，问你总共有多少种方法。

如果学过**第二类斯特林数**的大佬们，一定可以一眼看出题目就是在让你求斯特林数。下面我来介绍一下第二类斯特林数（学过的神仙们可以跳过）。

**第二类斯特林数**

**定义**

第二类斯特林数又称**第二类 Stirling 数**，因为是数学家 James Stirling 提出的，所以用他的名字命名（不得不说他真的非常厉害）。

第二类 Stirling 数实际上是集合的一个拆分，表示将 $n$ 个不同的元素拆分成 $m$ 个集合的方案数，记为 $S(n,m)$ 或者 $\begin{Bmatrix}n\\ m\end{Bmatrix}$。

常常用于解决组合数学中几类放球模型。描述为：将 $n$ 个**不同**的球放入 $m$ 个**无差别**的盒子中，要求盒子非空，有几种方案？

**要注意：第二类斯特林数要求盒子是无区别的。**

**递推式**

我们可以从定义出发，考虑第 $n+1$ 个元素的情况。假设我们要讲第 $n+1$ 个元素分成分成 $m$ 个集合，则分析如下：

- 情况一：如果 $n$ 个元素构成了 $m-1$ 个集合，那么第   $n+1$ 个元素单独构成一个集合。方案数 $S(n,m-1)$，即：将 $n$ 个不同元素放入 $m-1$ 个不同元素的方案数。

- 情况二：如果 $n$ 个元素已经构成了 $m$ 个集合，将第 $n+1$ 个元素插入到任意一个集合。方案数：$m×S(n,m)$.

综合两种情况：

  $S(n+1,m)=S(n,m-1)+m×S(n,m)$
  


------------
好了，现在我们来回过头来看一下这道题。

我们很容易可以发现：
 
**这里的 $m$ 头猪相当于 $m$ 个小球，$n$ 个房子相当于 $n$ 个盒子！！**

所以问题就迎刃而解。

此题就想当于求第二类斯特林数。首先，我们可以开一个二维数组 $S(i,j)$ 来表示将 $i$ 头猪分配到 $j$ 个不同的房子中的方案数；再分别枚举 $i$ 和 $j$,通过上面推出来的递推方程稍稍转化一下来确定每一个 $S(i,j)$ 对应的值即可。

转化后的递推方程：

$S(i,j)=S(i-1,j-1)+j×S(i-1,j)$

那么最后的答案就是 $S(n,m)$。

**一些小坑点**

这道题的数据范围是:  $1≤n≤50$ , $0≤m≤50$。

如果直接套公式去写，肯定会 WA，亲测只有 70 分。所以要加上高精度。

最后还有一个坑点：当 $n<m$ 时，不存在可行的方案数，故要特判“0”。

代码如下：

```
//luoguP3904
#include<iostream>
#include<cmath>
using namespace std;
const int maxn=55;
int n,m;
string s[maxn][maxn];
string add(string a,string b)//高精度加法
{
	string ans;
	int l1=a.size(),l2=b.size();
	int lk=max(l1,l2);//选a和b里面长度最大的作为最终字符串长度
	int u[maxn*10]={0},v[maxn*10]={0};
	for(int i=0;i<l1;i++)u[l1-i-1]=a[i]-'0';
	for(int i=0;i<l2;i++)v[l2-i-1]=b[i]-'0';//字符串转数组
	for(int i=0;i<lk;i++)
	{
		u[i]+=v[i];
		u[i+1]+=u[i]/10;
		u[i]%=10;
	}//模拟加法运算
	if(u[lk])lk++;//当出现进位时，长度++
	for(int i=lk-1;i>=0;i--)ans+=u[i]+'0';//重新转成字符串
	return ans;
}
string mul(string a,int b)//高精a*单精b（大部分与加法相同，故不做注释）
{
	string ans;
	int l=a.size();
	int u[maxn*10]={0};
	for(int i=l-1;i>=0;i--)u[l-i-1]=a[i]-'0';
	int w=0;
	for(int i=0;i<l;i++)
	{
		u[i]=u[i]*b+w;
		w=u[i]/10;
		u[i]%=10;
	}
	while(w)u[l++]=w%10,w/=10;//注意这里与加法不同，是while循环而不是if特判，想一想为什么？
	for(int i=l-1;i>=0;i--)ans+=u[i]+'0';
	return ans;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)s[i][1]="1";//初始化
	for(int i=1;i<=n;i++)
	{
		s[i][i]="1";
		for(int j=2;j<=m;j++)
		{
			s[i][j]=add(s[i-1][j-1],mul(s[i-1][j],j));//递推方程
		}
	}
	if(n<m)cout<<"0"<<endl;//注意特判
	else cout<<s[n][m]<<endl;
	return 0;
}
```

AC记录：[100pts](https://www.luogu.com.cn/record/53807436)

完结撒花~~



------------
**另外这是本蒟蒻的第一篇题解，望大家多多支持，求管理员大大给过~~**



---

## 作者：TLEphage (赞：8)

# 递推+高精

说实话这道题还是很水的 ~~但本蒟蒻还是想了好久~~

### 简化题目:


要你求出把n只小猪放在m个房子里的方案数，
并且每个房子都要有小猪(注:这里是组合而不是排列)

### 举个栗子：
(第$i$只猪标为$a_i$)

当n=3 m=2时 ,有

①$a_1$ $a_2$ /$a_3$

②$a_1$ $a_3$ /$a_2$

③$a_2$ $a_3$ /$a_1$

$3$种情况，像$a_3$ /$a_1$ $a_2$和第一种情况算同一种

### 我们康康第二个样例

当n=6 m=7时，~~聪明的~~你会发现，不管怎么安排，都会有空房子，也就是说情况数为0

**这样我们就能总结出：**$\color{green}\text{当n<m时,方案数为0}$

**~~聪明的~~你一定也能发现：**$\color{green}\text{当n=m时,方案数为1}$



------------

## 那么进入重点：如何推出递推公式

首先我们用$f[i][j]$表示$i$个小猪和$j$个房子时的方案数

我们先假设知道了$f[i][j]$,那么再加一个小猪，也就是$f[i+1][j]$应该是多少？

实际上你可以手动模拟一下$f[i][j]$，然后你看看先不动原来的情况插入新的小猪会怎么样。

### 举个栗子：

试着在$a_1$ $a_2$ /$a_3$(上面的栗子)插入$a_4$，有两种插入法对吧(分别是在第一个房子和第二个房子)。那么之前举了3种情况，也就是当$n=4,m=2$时能有$3*2=6$ 种情况，也就是$f[i-1][j]*j$

但实际上还有其他情况，因为$a_4$可能独居。也就是当3只小猪住m-1个房子的时候多出一个房子给第4只，那枚举一下不就是$f[i-1][j-1]$的值吗。

**所以最终，我们得出递推公式是$\color{red}\text{f[i][j]=f[i-1][j]*j+f[i-1][j-1]}$**

**特别的，$f[1][1]=1$  (或者你可以直接把$f[i][1]$全都初始化成1)**


------------
## 最后，就是高精了  
~~(卡了本蒟蒻好久的东西emmmm)~~


### 如果没写过高精的 ~~或者用了python  A了高精的~~ 请自觉写一遍

**传送机** ： [$\color{red}\text{高精度加法}$](https://www.luogu.org/problemnew/show/P1601) [$\color{orange}\text{高精度减法}$](https://www.luogu.org/problemnew/show/P2142)
[$\color{green}\text{高精度乘法}$](https://www.luogu.org/problemnew/show/P1303)
[$\color{blue}\text{高精度除法}$](https://www.luogu.org/problemnew/show/P1480)



------------


## 好吧，上代码


**(我这里用了结构体，主要是为了看的简便)**

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define ri register int
using namespace std;

struct node{int tot,num[100];}q[51][51];
int n,m;

node mul(node a,int b)//高精乘 
{
	node c;int tot=a.tot;
	memset(c.num,0,sizeof(c.num));//结构体在这一定要初始化，不然会炸，本蒟蒻卡在这好久（大雾） 
	for(ri i=1;i<=tot;++i) c.num[i]=a.num[i]*b;
	for(ri i=1;i<=tot;++i)
	{
		if(i==tot&&c.num[i]>=10) ++tot;
		c.num[i+1]+=c.num[i]/10;
		c.num[i]%=10;
	}
	c.tot=tot;
	return c;
}

node add(node a,node b)//高精加 
{
	node c;int tot=max(a.tot,b.tot);
	memset(c.num,0,sizeof(c.num));//结构体在这一定要初始化（不信可以自己调试一下） 
	for(ri i=1;i<=tot;++i) c.num[i]=a.num[i]+b.num[i];
	for(ri i=1;i<=tot;++i)
	{
		if(i==tot&&c.num[i]>=10) ++tot;
		c.num[i+1]+=c.num[i]/10;
		c.num[i]%=10;
	}
	c.tot=tot;
	return c;
}

int main()
{
	cin>>n>>m;
    if(n<m){printf("0");return 0;}//特判 
    
	for(ri i=1;i<=n;++i)//结构体初始化 
		for(ri j=1;j<=m;++j)
			q[i][j].tot=1,q[i][j].num[1]=0;
	
	for(ri i=1;i<=n;++i)//当房子只有一个时，1个方案 
		q[i][1].num[1]=1,q[i][1].tot=1;
	
	for(ri i=1;i<=n;++i)//递推+高精 
		for(ri j=2;j<=m;++j)
			q[i][j]=add(mul(q[i-1][j],j),q[i-1][j-1]);
	
	for(ri i=q[n][m].tot;i>=1;--i)//逆序输出 
		printf("%d",q[n][m].num[i]);
}

（代码丑，勿喷）
```



------------


## （萌新进洛谷后发的第一篇题解，写的不好请见谅OWO）

---

## 作者：JasonZRY (赞：6)

# 高精度

第二类斯特林数：将n个不同元素分成m个集合（n个不同的小球放进m个相同的盒子的方案数）

将n个元素的集合定义m个等价类的数目记做S(n,m)S(n,m)即第二类Stirling数。

s[n][m]=s[n-1][m-1]+m*s[n-1][m]

考虑第n个元素：新开辟一个集合，或者进入已经开辟的集合

高精度的写法：注意长度一开始一定要更新！如果到最后更新，中间有一位为0时会退出。

代码（写的太菜了，大佬勿喷）：

```
#include <bits/stdc++.h>        
using namespace std;        
int n,m,a[105][105][105];        
void add(int x,int y){        
    a[x][y][0]=max(a[x-1][y-1][0],a[x-1][y][0]);        
    for(int i=1;i<=a[x][y][0];i++){        
        a[x][y][i]+=a[x-1][y-1][i];        
        a[x][y][i]+=y*a[x-1][y][i];        
        a[x][y][i+1]+=a[x][y][i]/10;        
        a[x][y][i]%=10;        
    }        
    while(a[x][y][a[x][y][0]+1]){        
        a[x][y][0]++;        
        a[x][y][a[x][y][0]+1]+=a[x][y][a[x][y][0]]/10;        
        a[x][y][a[x][y][0]]%=10;        
    }        
}        
int main(){        
    cin>>n>>m;        
    a[1][1][1]=1;        
    a[1][1][0]=1;        
    for(int i=2;i<=n;i++)for(int j=1;j<=i;j++)add(i,j);        
    if(!a[n][m][0])cout<<0;        
    for(int i=a[n][m][0];i>=1;i--)cout<<a[n][m][i];        
    return 0;        
}        
```
我又在里面放了防伪标码，神犇才能看见，请勿抄袭！！！

###### 求赞求通过

# 彩蛋来啦：

你听说过三只蒟蒻的故事吗？这是一个经典的故事。很久很久以前，有三只蒟蒻。第一只蒟蒻用暴力建的代码，第二只蒟蒻用暴力加剪枝建的代码，第三个蒟蒻则使用打表做为材料。一只神犇想嘲讽它们并用毒瘤吹倒了暴力建的代码，用更毒瘤的毒瘤吹倒了暴力加剪枝建的代码。但是打表盖的代码很结实，神犇最终也没有破坏掉，最后蒟蒻们战胜了神犇并把它电脑砸掉了。

---

## 作者：ttcwws (赞：6)

#  高精 + 记忆化搜索


啊~~ 又是高精的题目

怎能不水一发?

 ~~在开始之前,说最后一句废话: Python Java大法好~~

P党 C党不要走, 看下思路也好呀
~~(才不是骗赞)~~

或者可以直接到下面看通项公式法

题意说是有n只小猪, 住进m个房子里面, 房子不为空, 求方案数

~~(好像没人看不懂吧)~~

看到楼下那么多dalao用递推dp写这道题, 身为蒟蒻的我只能来一发弱弱的

#### 记忆化搜索

其实这题就是求二类 $Stirling$ 数, 也就是二类斯特林数

什么??! 你不知道? [来这康康](https://baike.baidu.com/link?url=0VF6vQi3JHlSnELMtI9Y9JqmSE4abKJAKqloUnXugQd_zPwoYtrhaPpC7Xtxar8-5VsZuGwSLXL79_kkWfBn6UdZYdYrDvKigmUlaazF_mkAe2xCPiCmvNOOhi9AyKVQ)

状态转移方程都在里面了 但是我还是推一遍吧
## 
记 $\color{chocolate}dp[i][j]$ 为 $i$ 只小猪住进 $j$ 个房子的总方案数

则有 :

- 当  $i = j$  $or$  $j = 1$ 时, $dp[i][j] = 1$

然后一般情况
- 第 $i$ 只小猪跟前面的挤一起住: 有 $j$ 个房子, 所以为 $j \cdot dp[i - 1][j]$

- 单独住: $dp[i - 1][j - 1]$

所以有 $\color{crimson}dp[i][j] = dp[i - 1][j - 1] + j * dp[i - 1][j]$

放在搜索里面就是 $\color{crimson}dfs(i, j) = dfs(i - 1, j - 1) + j * dfs(i - 1, j)$


题目就分析完了, 上代码
##

Python 3:
```python
mem = [[-1 for i in range(53)]for i in range(53)] #用来记忆的数组
#多开一点, 房子1开始计数, 我就是只开了50就RE了
def dfs(l, r):
    if mem[l][r] != -1: return mem[l][r]
    if l == r or r == 1: return 1 	#边界
    mem[l][r] = dfs(l - 1, r - 1) + r * dfs(l - 1, r)
    return mem[l][r]
def start():
    n, m = map(int, input().split())
    if n < m:
        print(0, end = '')
        return		# n < m 时是无论如何做不到房子不空的
    print(dfs(n, m), end = '') #输出, 完满结束(大雾)
start()

```

Java:
```java
import java.util.*;
import java.math.BigInteger;
class Main {
    static BigInteger[][] mem = new BigInteger[53][53]; //记忆的数组
    public static BigInteger dfs(int l, int r){
        if (mem[l][r].compareTo(BigInteger.valueOf(-1)) != 0)return mem[l][r];
        if (l == r || r == 1)return BigInteger.valueOf(1); //边界
        mem[l][r] = dfs(l - 1, r - 1).add(BigInteger.valueOf(r).multiply(dfs(l - 1, r))); //看着有点复杂? 没办法,Java高精就是这么麻烦
        return mem[l][r];
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < 53; i++)
            Arrays.fill(mem[i], BigInteger.valueOf(-1));
        int n = sc.nextInt(), m = sc.nextInt();
        if (n < m){
            System.out.print(0);
            return; //特殊处理
        }
        System.out.print(dfs(n, m).toString()); //完美结束
    }
}
```

然而

你以为结束了？？

求二类斯特林数还有一个通项公式别忘了

C党P党也可以康康

$S(n, m) = \frac{1}{m!}\sum\limits_{k=0}^{m}(-1)^k\dbinom{m}{k}(m - k)^n$

有没有头痛的感觉？

平时看不懂数论dalao的 $\sum$的盆友可以看一下了

比如$x = \sum\limits_{i=1}^{m}i^2$就等价于以下C++代码
```cpp
int x = 0;
for (int i = 1; i <= m; i++)
	x += i * i;
```
怎么样，hin简单吧

然后$\dbinom{m}{k}=\frac{m!}{k!(m - k)!}=m!\div k!\div(m - k)!$

虽然AC代码不是C++

但是讲解时用C++~~(才不是懒得写高精)~~

于是上述公式就变成了如下代码(无高精)
```cpp
#include <cstdio>
#include <cmath>
long double jc(int s)
{
	if (s == 1 || !s)return 1;
	return (long double)(s) * jc(s - 1);
}
long double C(int a, int b)
{
	return jc(a) / jc(b) / jc(a - b);
}

int main()
{
	int n, m;
	long double temp = 0.0;
	scanf("%d %d", &n, &m);
	for (int k = 0; k <= m; k++)
		if (k % 2)temp -= C(m, k) * (long double)pow(m - k, n);
		else temp += C(m, k) * (long double)pow(m - k, n);
	long double t = 1.0 / jc(m);
	printf("%llu", (unsigned long long)(t * temp));
}
```
自己试一下,样例是不是就能过了？

但是由于C++的浮点数精度问题, 上述代码在double范围内也有为 $1$ 的蜜汁误差

~~别跟我提FFT,写这么多不累吗？？？~~

FFT 是把上述$O(n^2)$公式优化成$O(nlogn)$的算法啦

我就不多说了 ~~,手好累~~

有兴趣的 [戳这里](https://www.cnblogs.com/RabbitHu/p/FFT.html)

Python也会炸精度,decimal库都拯救不了 ~~(Python终于炸精度了)~~

如果会的大神请私信指教

上满分AC代码

Java:
```java
import java.util.Scanner;
import java.math.*;
class Main{
    public static BigDecimal InttoDe(BigInteger a){
        BigDecimal te = new BigDecimal(a); //大整数转大浮点
        return te;
    }
    public static BigInteger jc(int a){
        if (a == 1 || a == 0)return BigInteger.valueOf(1);
        return BigInteger.valueOf(a).multiply(jc(a - 1)); //阶乘，不解释
    }
    public static BigDecimal C(int a, int b){
        return InttoDe(jc(a)).divide(InttoDe(jc(b)), 1000, RoundingMode.FLOOR).divide(InttoDe(jc(a - b)), 1000, RoundingMode.FLOOR); //保留1000位小数运算，保险
    }
    public static BigDecimal mypow(int a, int b){
        return InttoDe(BigInteger.valueOf(a).pow(b)); //幂运算，显得主函数不那么长、难懂（本来就难懂）（划掉）
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        BigDecimal temp = new BigDecimal("0.0");
        for (int k = 0; k <= m; k++)
            if (k % 2 == 1)temp = temp.subtract(C(m, k).multiply(mypow(m - k, n)));
            else temp = temp.add(C(m, k).multiply(mypow(m - k, n)));
        BigDecimal t = new BigDecimal("0.0");
        System.out.print(t.multiply(temp).divide(BigDecimal.valueOf(1.0), 0, RoundingMode.HALF_UP).toString());
        //因为精度太高，会出现.9999……或.0000……1的情况，所以除以1，保留0位小数四舍五入
    }
}
```



总体还~~比较简单~~

**~~Python是真的短, Java累死我了~~**

---

## 作者：donotctjuntilAFO (赞：5)

将第 $i$ 只小猪塞进 $j$ 个房子里记做 $S[i][j]$

假如将猪扔到一个新房间，则有方案数：$S[i-1][j-1]$

假如将这只猪扔进之前的房间,根据乘法原理知共有方案数  :   $j \times S[i-1][j]$

综上所述，状态转移方程为：$S[i][j]=S[i-1][j-1]+j \times S[i-1][j]$

这个数又称：第二类斯特林数。

由于数据范围较大，需使用高精度。

所以

# 人生苦短，我用 Python

代码：
```python
S=[[0]*409 for i in range(409)]
for i in range(1,409):
    S[i][i]=S[i][1]=1
    for j in range(2,i):
        S[i][j]=S[i-1][j-1]+j*S[i-1][j]
while True:
    try:
        n,m=map(int,input().split())
        print(S[n][m])
    except EOFError:
        break
```


---

## 作者：ghj1222 (赞：5)

 Part1.第二类Stirling数了解一下

将n个元素的集合定义m个等价类的数目记做$S(n,m)$即第二类Stirling数。

递推式：$S(n,m)=S(n-1,m-1)+mS(n-1,m)$。$S(n,1)=1$

考虑第n个猪，有两种情况，第一种是单独构成一个新的房子，即为$S(n-1,m-1)$，第二种是插入前n-1个猪组成的m个房子中，一共有m个房子所以是$mS(n-1,m)$

然而这个数列增长的很快，需要写高精度加法+高精乘以低精度

Python3代码如下：

```python
def work(n, m):
	f = [[0 for i in range(300)] for i in range(300)]
	for i in range (1, n + 1):
		f[i][1] = 1
		for j in range (2, m + 1):
			f[i][j] = f[i - 1][j - 1] + j * f[i - 1][j]
	return f[n][m]

def main():
	s = input().split()
	print(work(int(s[0]), int(s[1])))
main()
```



---

## 作者：bloodstalk (赞：5)

第二类斯特林数。
# Description
## 第二类斯特林数
### 定义
将 $n$ 个不同元素，划分为 $m$ 个**非空子集**的方案数，记作 $\begin{Bmatrix}n\\m\end{Bmatrix}$。
### 递推公式
$$
\begin{Bmatrix}n\\m\end{Bmatrix} = \begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m\begin{Bmatrix}n-1\\m\end{Bmatrix}
$$

放到这个题下证明一下。

 $n$ 个小猪进 $m$ 个房间并且没有房间是空的的方案数，这里小猪不同而房间是相同的。

考虑第 $n$ 个小猪进房间的情况：

1. 若单独进一个房间，前面的 $n-1$ 个小猪就要进 $m-1$ 个房间里，方案数就是 $\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$；

2. 若进已经有小猪的房间里，就先让前 $n-1$ 个小猪进 $m$ 个房间里，第 $n$ 个小猪可以进 $m$ 个房间中任意一个房间，不重不漏，这样的方案数就是 $m\begin{Bmatrix}n-1\\m\end{Bmatrix}$。

分类加法，最后的方案数就是
$$
\begin{Bmatrix}n\\m\end{Bmatrix} = \begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m\begin{Bmatrix}n-1\\m\end{Bmatrix}
$$
# Solution
知道了第二类斯特林数的递推公式，我们就可以对这个题进行求解了。

但是斯特林数的增长比组合数还要快，$n\leq 50$ 就会爆 long long，因此需要高精。

$S_{i,j,k}$ 表示第二类斯特林数 $\begin{Bmatrix}i\\j\end{Bmatrix}$ 的第 $k$ 位是多少，$L_{i,j}$ 表示 $\begin{Bmatrix}i\\j\end{Bmatrix}$ 有多少位，然后高精乘法即可。

# Code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 50 + 5;
using namespace std;
int max(int x,int y){return x > y ? x : y;}
int min(int x,int y){return x < y ? x : y;}

int n,m;
int S[N][N][105],L[N][N];

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

il void calc(int x,int y)
{
	L[x][y] = max(L[x-1][y-1],L[x-1][y]);
	for(re int i=1;i<=L[x][y];i++)
	{
		S[x][y][i] += S[x-1][y-1][i] + y * S[x-1][y][i];
		S[x][y][i+1] += S[x][y][i] / 10;
		S[x][y][i] %= 10;
	}
	if(S[x][y][L[x][y]+1] > 0) L[x][y]++;//看看能不能更新最高位
	while(S[x][y][L[x][y]] >= 10)
	{
		S[x][y][L[x][y]+1] = S[x][y][L[x][y]] / 10;
		S[x][y][L[x][y]] %= 10;
		L[x][y]++;
	}
}

signed main()
{
	S[0][0][1] = 1 , L[0][0] = 1;
	n = read() , m = read();
	if(!m || m > n) return printf("0"),0;//特判等于0的情况
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=min(i,m);j++)
			calc(i,j);
	for(re int i=L[n][m];i>=1;i--) cout << S[n][m][i];
	return 0;
}
```







---

## 作者：僚机 (赞：3)

第二类斯特林数

表示将n个不同的元素拆分成m个集合的方案数

s[n][m]=s[n-1][m-1]+m\*s[n-1][m];

就跟杨辉三角一样刷一张表 可过80

剩下20会爆long long

加上高精度



    
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long a[55][55][1010];
int n;
int m;
void add(int u,int v){
    for(int i=1;i<=max(a[u-1][v-1][0],a[u-1][v][0]);i++){
        a[u][v][i]+=a[u-1][v-1][i];
        a[u][v][i]+=v*a[u-1][v][i];
    }
    a[u][v][0]=max(a[u-1][v-1][0],a[u-1][v][0]);
    for(int i=1;i<=a[u][v][0];i++){
        a[u][v][i+1]+=a[u][v][i]/10;
        a[u][v][i]%=10;
    }
    while(a[u][v][a[u][v][0]+1]){
        a[u][v][0]++;
        a[u][v][a[u][v][0]+1]+=a[u][v][a[u][v][0]]/10;
        a[u][v][a[u][v][0]]%=10;
    }
}
int main(){
    a[1][1][0]=1;
    a[1][1][1]=1;
    cin>>n>>m;
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i;j++){
            add(i,j);
        }
    }
    if(a[n][m][0]==0){
        cout<<"0"<<endl;
        return 0;
    }
    for(int i=a[n][m][0];i>=1;i--){
        cout<<a[n][m][i];
    }
    return 0;
}
```

---

## 作者：快乐说话 (赞：2)

实际上这道题就相当于在盒子里放小球这一大家都熟悉的问题，房子就是盒子，猪就是球。
设n个猪，m个房子的方案数为f（n,m）那么

f(n,m)

=0(n<m,必有房子为空，无方案数)，

=1(n=m或是m=1，只有一个房子，当然只有一种)

=f(n-1,m-1)+f(n-1,m)*m(要么一只猪单独住一个房子，其他的住m-1个，要么一只猪和别人同住，有m个选择)

可得程序：
```cpp
#include<iostream>
using namespace std;
long long int f[51][51];//最开始都是0
int main(){
    int n,m,i,j;
    cin>>n>>m;//读入
    for(i=1;i<=n;i++)
        f[1][i]=1;//置初值
    for(i=2;i<=m;i++)
        for(j=1;j<=n;j++)
            f[i][j]=f[i][j-1]*i+f[i-1][j-1];//递推过程
    cout<<f[m][n];//输出答案
    return 0;
}

```
评测后发现只有80分，为什么？

看数据范围，发现需要高精度

因此得到程序：
```cpp
#include<iostream>
#include<cmath>
using namespace std;
void jia(int a[],int b[],int c[])
{
    c[0]=max(a[0],b[0]);
    int i,jw=0;
    for(i=1;i<=c[0];i++)
    {
        c[i]=a[i]+b[i]+jw;
        jw=c[i]/10;
        c[i]%=10;
    }
    if(jw!=0){c[0]++; c[c[0]]=jw;}
}
void cheng(int a[],int x,int b[])
{
    b[0]=a[0];
    int i,jw=0;
    for(i=1;i<=b[0];i++)
    {
        b[i]=a[i]*x+jw;
        jw=b[i]/10;
        b[i]%=10;
    }
    if(jw!=0)
        while(jw>0)
        {
            b[0]++;
            b[b[0]]=jw%10;
            jw/=10;
        }
}
int f[51][51][101];//long long int f[51][51];
int main(){
    int n,m,i,j;
    cin>>n>>m;
    for(i=1;i<=n;i++)
        f[1][i][0]=f[1][i][1]=1;//f[1][i]=1;
    for(i=2;i<=m;i++)
        for(j=1;j<=n;j++)
        {
            int t[101];
            for(int k=0;k<=101;k++)t[k]=0;
            cheng(f[i][j-1],i,t);
            jia(f[i-1][j-1],t,f[i][j]);//f[i][j]=f[i][j-1]*i+f[i-1][j-1];
        }
    for(i=f[m][n][0];i>=1;i--)cout<<f[m][n][i];//cout<<f[m][n];
    if(f[m][n][0]==0)cout<<0;
    return 0;
}

```

---

## 作者：xiezheyuan (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P3904)

本题是第二类斯特林数的模版，表示将 $n$ 只猪放进 $m$ 个房子的方案数，它可以用递推来得到。


$$s[i][j]=s[i-1][j-1]+j \times s[i-1][j]$$

递推边界:$s[i][i]=s[i][1]=1$.

推导过程：

- 把新的一只猪安排去跟别的猪挤着（猪：我做错了什么）。就是 $s[i-1][j] \times j$。

- 也可以独居，也就是 $s[i-1][j-1]$。

然后把这两个式子加起来即可。

然后，本题需要高精度，可以用Python。

代码：

```python
s= [[0] * 450 for i in range(450)]

for i in range(1,450):
    s[i][i]=1;s[i][1]=1
    for j in range(2,i):
        s[i][j]=s[i-1][j-1]+j*s[i-1][j]

while 1:
    try:
        n,m=map(int,input().split())
        print(s[n][m])
    except:
        exit(0)

```

时间复杂度 $O(n^{2})$（不包含高精度的开销）。

双倍经验：[P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655)


---

## 作者：Yyxxxxx (赞：1)

题目令我回忆起了童年，回忆起小时候，我畅想着和我的 **GF** 一起……
- 题意

把$n$只不同的小猪放进$m$个笼子的方法  
即把$n$个不同元素拆分成$m$个集合的方案数（要求集合非空）

#### 第二类斯特林数！！！

- 计算

记把$n$个不同元素拆分成$m$个集合的方案数为$S(n,m)$或$\begin{Bmatrix}n\\m\end{Bmatrix}$ 

分情况考虑  
1. 把第$n$只猪放到前面的笼子里。  

贡献即为$S(n-1,m)\cdot m$

2. 把第$n$只猪放到一个新笼子里。

贡献即为$S(n-1,m-1)$

故得出：$S(n,m)=S(n-1,m)\cdot m+S(n-1,m-1)$

（第一遍提交还以为蓝题咋会这么简单，结果发现要高精）

相信大家都会[高精乘](https://www.luogu.com.cn/problem/P1303)和[高精加](https://www.luogu.com.cn/problem/P1601)了，这里不再赘述
- 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int len,s[100];
}f[55][55];//结构体存高精数组
int n,m;
node mul(node a,int b)//普通高精乘
{
    node ans;int len=a.len;
    memset(ans.s,0,sizeof(ans.s));//清空！谨记！
    for(int i=1;i<=len;i++)
        ans.s[i]=a.s[i]*b;
    for(int i=1;i<=len;++i)
    {
        if(i==len&&ans.s[i]>=10)++len;
        ans.s[i+1]+=ans.s[i]/10;
        ans.s[i]%=10;
    }
    ans.len=len;
    return ans;
}
node add(node a,node b)//普通高精加
{
    node ans;int len=max(a.len,b.len);
    memset(ans.s,0,sizeof(ans.s));//清空！谨记！
    for(int i=1;i<=len;++i)
        ans.s[i]=a.s[i]+b.s[i];
    for(int i=1;i<=len;++i)
    {
        if(i==len&&ans.s[i]>=10)++len;
        ans.s[i+1]+=ans.s[i]/10;
        ans.s[i]%=10;
    }
    ans.len=len;
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    if(n<m)//抽屉原理，3个苹果放5个抽屉肯定有抽屉没苹果
    {
        printf("0");//直接输出就好了
        return 0;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            f[i][j].len=1,f[i][j].s[1]=0;//初始化
    for(int i=1;i<=n;i++)
        f[i][1].s[1]=1,f[i][1].len=1;//m=1,S(n,1)=1
    for(int i=1;i<=n;i++)
        for(int j=2;j<=m;j++)
            f[i][j]=add(mul(f[i-1][j],j),f[i-1][j-1]);//S(n,m)=m*S(n-1,m)+S(n-1,m-1)
    for(int i=f[n][m].len;i>=1;i--)
        printf("%d",f[n][m].s[i]);//倒序输出
    return 0;
}
```


---

## 作者：feecle6418 (赞：1)

写一写第一篇题解。。。

这题并不难，递推（或者叫动归）能搞定。但是要用高精！要用高精！要用高精！

状态转移方程（递推式）：

$f[i][j]=f[i-1][j-1]+j*f[i-1][j]$

f[i][j]表示前i个猪放到j个房子里的方法数，相当于第i个猪可以放在j个房子中任意一个，或者第i个猪放在第j个新的房子里。自己想想。

代码：

```cpp
#include<bits/stdc++.h>
#define L 10001
using namespace std;
string f[51][51];
template <class m,class n>
n turn(const m &a) {
    stringstream st;//任意类型转换，此处是string与int
    st<<a;
    n b;
    st>>b;
    return b;
}
string add(string a,string b) {//高精
    string ans;
    int na[L]= {0},nb[L]= {0};
    int la=a.size(),lb=b.size();
    for(int i=0; i<la; i++) na[la-1-i]=a[i]-'0';
    for(int i=0; i<lb; i++) nb[lb-1-i]=b[i]-'0';
    int lmax=la>lb?la:lb;
    for(int i=0; i<lmax; i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;
    if(na[lmax]) lmax++;
    for(int i=lmax-1; i>=0; i--) ans+=na[i]+'0';
    return ans;
}
string mul(string a,string b) {
    string s;
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();
    fill(na,na+L,0);
    fill(nb,nb+L,0);
    fill(nc,nc+L,0);
    for(int i=La-1; i>=0; i--) na[La-i]=a[i]-'0';
    for(int i=Lb-1; i>=0; i--) nb[Lb-i]=b[i]-'0';
    for(int i=1; i<=La; i++)
        for(int j=1; j<=Lb; j++)
            nc[i+j-1]+=na[i]*nb[j];
    for(int i=1; i<=La+Lb; i++)
        nc[i+1]+=nc[i]/10,nc[i]%=10;
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';
    for(int i=La+Lb-1; i>=1; i--)
        s+=nc[i]+'0';
    return s;
}
int main() {
    int n,m;
    cin>>n>>m;
    f[0][0]="1";//开始
    if(n<m){//别忘了！别忘了！别忘了！
        cout<<"0";
        return 0;
    }
    for(int i=1; i<=n; i++) {//递推
        for(int j=1; j<=min(i,m); j++) {
            f[i][j]=add(f[i-1][j-1],mul(f[i-1][j],turn<int,string>(j)));
        }
    }
    cout<<f[n][m];
    return 0;
}
```

---

## 作者：him的自我修养 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P3904)
# 思路
~~感觉这道题能上绿的原因是有高精。~~

首先，定义 $dp_{i,j}$ 为有 $i$ 只小猪，$j$ 间屋子的情况。我们先找一下转移方程，对于第 $i$ 只小猪，它有两种情况。

- 第一种情况。这只小猪被踹到了一个全新的屋子里面，这个屋子里面只有小猪一人，这种情况下有 $dp_{i-1,j-1}$ 种方案数。

- 第二种情况。这只小猪被踹倒了一个以前的屋子里面。假设现在有 $j$ 个屋子，那么每个屋子都有 $dp_{i-1,j}$ 个方案数，最后一共有 $j$ 个屋子，所以共有 $j\times dp_{i-1,j}$ 个方案。 


最后 $dp_{i,j}=dp_{i-1,j-1}+j\times dp_{i-1,j}$。

# code
所以 c++ 的代码就是这个样子
```
#include <iostream>
#define int long long
using namespace std;
int n,m,dp[55][55];
signed main(){
	cin >>n>>m;
	dp[1][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			if(i==1 && j==1) continue;
			dp[i][j]=dp[i-1][j-1]+j*dp[i-1][j];
		}
	}
	cout <<dp[n][m];
	return 0;
}
```
然和，我们开头说过，这道题要用高精！但是作者懒得写高精，所以下面贴个 PY 的代码。
```python
n,m=input().split(' ')
n=int(n)
m=int(m)
dp=[[0 for i in range(55)] for j in range(55)]
dp[1][1]=1

for i in range(1,n+1):
	for j in range(1,i+1):
		if i==1 and j==1:
			continue
		dp[i][j]=dp[i-1][j-1]+j*dp[i-1][j]
		
print(dp[n][m])
```

---

## 作者：Wind_Smiled (赞：0)

## 题意

将 $n$ 个小球放进 $m$ 个盒子中，输出方案数。

### 分析

考虑找小规模的数据规律。~~（其实能一眼看出来是第二类斯特林数的定义）~~

当 $m=1$ 时，方案数 $ans$ 总为 $1$。
```
n=2,m=2
{1}{2}
ans=1

n=3,m=2
{{1,3},{2}}
{{1},{2,3}}

{{1,2},{3}}
ans=3

n=4,m=2
{{1,3,4},{2}}
{{1,3},{2,4}}

{{1},{2,3,4}}
{{1,4},{2,3}}

{{1,2,4},{3}}
{{1,2},{3,4}}

{{1,2,3},{4}}
ans=7
```

显然可以发现，每当多一个小球的时候，都有两种情况。

1.将该球放置进一个新的盒子，此时剩余的问题是将 $n-1$ 个小球放入 $m-1$ 个盒子。故考虑递推，设函数为 $f$。此时共有 $f(n-1,m-1)$ 种情况。

2.将该球与其他球共同放入一个盒子，此时有 $m$ 个盒子可选，并且前置问题是将 $n-1$ 个小球放入 $m$ 个盒子。此时共有 $m \times f(n-1,m)$ 种情况；

所以，对于给定的 $n,m$，方案数 $f(n,m)$ 就是 $f(n-1,m-1)+m \times f(n-1,m)$。

故得出第二类斯特林数的递推法公式：

$f(n,m)=f(n-1,m-1)+m \times f(n-1,m)$

加上记忆化搜索即可得出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int f[55][55];
int s(int n,int m){
	if(f[n][m]>=0){
		return f[n][m];
	}
	else{
		f[n][m]=s(n-1,m-1)+m*(s(n-1,m));
	}
	return f[n][m];
}
int main(){
	memset(f,-1,sizeof(f));
	scanf("%d%d",&a,&b);
	for(int i=1;i<=a;i++){//m=1方案数是1
		f[i][1]=1;
	}
	for(int i=1;i<=b;i++){//n=0无法分配
		f[0][i]=0;
	}
	printf("%d",s(a,b));
	return 0;
}
```
但是只有 70pts，推下数据范围，$ans>50!$，要加高精。

需要高精加和高精乘。

最终代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
string f[55][55];
string add(string str1,string str2){//高精加 
    string str;
    int len1=str1.length();
    int len2=str2.length();
    if(len1<len2){
        for(int i=1;i<=len2-len1;i++){
        	str1="0"+str1;
		}
    }
    else{
        for(int i=1;i<=len1-len2;i++){
        	str2="0"+str2;
		}
    }
    len1=str1.length();
    int cf=0;
    int temp;
    for(int i=len1-1;i>=0;i--){
        temp=str1[i]-'0'+str2[i]-'0'+cf;
        cf=temp/10;
        temp%=10;
        str=char(temp+'0')+str;
    }
    if(cf!=0){
    	str=char(cf+'0')+str;
	}
    return str;
}
string mul(string str1,string str2){//高精乘 
    string str;
    int len1=str1.length();
    int len2=str2.length();
    string tempstr;
    for(int i=len2-1;i>=0;i--){
        tempstr="";
        int temp=str2[i]-'0';
        int t=0;
        int cf=0;
        if(temp!=0){
            for(int j=1;j<=len2-1-i;j++){
            	tempstr+="0";
			}
            for(int j=len1-1;j>=0;j--){
                t=(temp*(str1[j]-'0')+cf)%10;
                cf=(temp*(str1[j]-'0')+cf)/10;
                tempstr=char(t+'0')+tempstr;
            }
            if(cf!=0){
            	tempstr=char(cf+'0')+tempstr;
			}
        }
        str=add(str,tempstr);
    }
    str.erase(0,str.find_first_not_of('0'));
    return str;
}
string s(int n,int m){
	stringstream mm;//stringstream流 int转string 
	mm<<m;
	string m1=mm.str();
	if(f[n][m]!="-1"){
		return f[n][m];
	}
	else{
		f[n][m]=add(s(n-1,m-1),mul(m1,s(n-1,m)));
	}
	return f[n][m];
}
int main(){
	scanf("%d%d",&a,&b);
	for(int i=1;i<=a;i++){//初始化为 -1 
		for(int j=1;j<=b;j++){
			f[i][j]="-1";
		} 
	}
	for(int i=1;i<=a;i++){//m=1方案数是1
		f[i][1]="1";
	}
	for(int i=1;i<=b;i++){//n=0无法分配
		f[0][i]="0";
	}
	cout<<s(a,b);
	return 0;
}
```

---

## 作者：Shanganze (赞：0)

建议先看看这道 [P1655小朋友的球](https://www.luog.com.cn/problem/P1655)
## 题意简述：
$n$ 只小猪 $m$ 个相同的房子，不能有空房，求方案数。
## 解析：
这不就是经典的盒子放小球问题吗，$n$ 不同的个球 $m$ 个相同的房子，房子不能为空。

前置芝士：[第二类Stirling](https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/4938529?fr=aladdin#3_3)
####  定义:
第二类 Stirling 数实际上是集合的一个拆分，表 
示将 $n$ 个不同的元素拆分成 $m$ 个集合的方案数。
第二类 Stirling 数的推导和第一类 Stirling 数类
似，可以从定义出发考虑第 $n+1$ 个元素的情况，
假设要把 $n+1$ 个元素分成 $m$ 个集合则分析如下：

1.如果 $n$ 个元素构成了$m-1$个集合，那么第$n+1$
个元素单独构成一个集合。方案数 $S2_{i-1,j-1}$

2.如果 $n$ 个元素已经构成了 $m$ 个集合，将第$n+1$个元素插入到任意一个集合。方案数 $S2_{i-1,j} × j$

综合两种情况得：

$$S2_{i,j} = S2_{i-1,j-1} +j × S2_{i-1,j}$$

最后再加上封装好的高精。

## 代码：
```
#include<bits/stdc++.h>
using namespace std;
struct a1
{
   int x[101];
   a1(){memset(x,0,sizeof(x));}
}x[102][101];
a1 operator * (const a1 a,const int b)//重载高精乘低精
{
   a1 c;
   for(int q=1;q<=101;q++)
   {
      c.x[q]=a.x[q]*b;
   }
   for(int q=1;q<=101;q++)
   {
      c.x[q]+=c.x[q-1]/10;
      c.x[q-1]%=10;
   }
	return c;
}
a1 operator + (const a1 a,const a1 b)//重载高精加低精
{
    a1 c;
    for(int q=1;q<=101;q++)
    {
	c.x[q]=a.x[q]+b.x[q];
    }
    for(int q=1;q<=101;q++)
    {
	c.x[q]+=c.x[q-1]/10;
        c.x[q-1]%=10;
    }
    return c;
}
int main()
{
    unsigned long long n,m;
    for(int q=1;q<=100;q++)x[q[1].x[1]]=1;//数组初始化
    for(int q=2;q<=100;q++)//预处理
    {
	for(int w=2;w<=q;w++)
	{
	    x[q][w]=(x[q-1][w]*w)+x[q-1][w-1];//递推公式
	}
    }
    cin>>n>>m;
    int p=101;
    while(x[n][m].x[p]==0&&p>1)p--;
    for(int q=p;q>=1;q--)cout<<x[n][m].x[q];//直接调用数组输出
    cout<<endl;
    return 0;//华丽的结束
}
```



---

## 作者：RuntimeErr (赞：0)

## 第二类斯特林数例题

#### 定义：

$S(n,m)$ 表示将 $n$ 个**两两不同**的元素划分成 $m$ 个**互不区分**的集合的方案数。

#### 递推式：

$$\text{递归边界：}S(n,0)=[n=0],$$

$$S(n,m)=S(n-1,m-1)+m\times S(n-1,m)$$

如何理解？对于选取的第 $n$ 个元素，我们有两种情况：

1. 将其放入一个新的集合，则方案数为 $1\times S(n-1,m-1)=S(n-1,m-1)$。

2. 将其放入现有的一个集合，则有 $m$ 个选择，方案数为 $m\times S(n-1,m)$。

根据加法原理把两种方案数相加即可。

注意：答案过大，需要用高精度运算。

Code:

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,m;
struct node{
   int len,num[1000];
}f[60][60];//这里用f数组来表示S

node add(node a,node b){
    node res;memset(res.num,0,sizeof res);
    res.len=max(a.len,b.len);
    for(int i=1;i<=res.len;++i){
        res.num[i]+=a.num[i]+b.num[i];
        if(res.num[i]>9){
            res.num[i+1]+=res.num[i]/10;
            res.num[i]%=10;
            if(i==res.len)++res.len;
        }
    }
    return res;
}

node mul(int a,node b){
    node res;memset(res.num,0,sizeof res);
    res.len=b.len;
    for(int i=1;i<=res.len;++i){
        res.num[i]+=a*b.num[i];
        if(res.num[i]>9){
            res.num[i+1]+=res.num[i]/10;
            res.num[i]%=10;
            if(i==res.len)++res.len;
        }
    }
    return res;
}

int main(){
    scanf("%d%d",&n,&m);
    if(n<m){puts("0");return 0;}
    f[0][0].num[1]=1;f[0][0].len=1;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            f[i][j]=add(f[i-1][j-1],mul(j,f[i-1][j]));
        }
    }
    for(int i=f[n][m].len;i;--i)printf("%d",f[n][m].num[i]);

    return 0;

}

```

---


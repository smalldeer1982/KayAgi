# P哥破解密码

## 题目背景

P 哥是一个经常丢密码条的男孩子。

在 ION8102 赛场上，P 哥又弄丢了密码条，笔试满分的他当然知道这可是要扣 $5$ 分作为惩罚的，于是他开始破解 IONXunil 系统的密码。

## 题目描述

定义一个串合法，当且仅当串只由 $\verb!A!$ 和 $\verb!B!$ 构成，且没有连续的 $3$ 个 $\verb!A!$。P 哥知道，密码就是长度为 $N$ 的合法字符串数量对 $19260817$ 取模的结果。但是 P 哥不会算，所以他只能把 $N$ 告诉你，让你来算。

至于为什么要对这个数取模，好像是因为纪念某个人，但到底是谁，P 哥也不记得了。

然而他忘记字符串长度 $N$ 应该是多少了，于是他准备试 $M$ 组数据。

## 说明/提示

### 样例部分解释 :。

长度为 $1$ 时只有 $\verb!A!$ 和 $\verb!B!$ 两种排列，都是合法的。

长度为 $3$ 时除了 $\verb!AAA!$ 是不合法的其他都是可以的，故有 $2^3-1$ 种。

### 数据范围。

- 对于 $20\%$ 数据，全部 $N\leq20$，$M\leq2$；
- 对于 $70\%$ 数据，全部 $N\leq10^7$；
- 对于 $100\%$ 数据，全部 $N\leq10^9$，$M\leq10$。

## 样例 #1

### 输入

```
3
1
3
6
```

### 输出

```
2
7
44
```

# 题解

## 作者：灯芯糕 (赞：141)

## 矩阵乘法 + 快速幂优化递推：

### 看到这个题目我们不难想到递推，题干中说3个连续的A出现在序列中是不合法的，所以可以分为三种情况：

### （1）：序列前只有一个A，如：BA,BBA,BABA。

### （2）：序列前有两个A，如：BAA,BBAA,BABAA。

### （3）：序列前没有A而是B，如：BB,AB,AABAAB。

### 我们将这三种情况分别用 a1 , a2 , b 表示。

```cpp
// a1:1 1 2 4  7 13 24 44  81 149 274
// a2:0 1 1 2  4  7 13 24  44  81 149 274
// b :1 2 4 7 13 24 44 81 149 274
```

### 我们不难发现在下一轮加A或加B时：a1可以转化为a2,a1和a2都可以转化为b,而b又可以转化为a1或再加一个b不变;

### 故规律为：
```cpp
// f=a2;
// a2=a1;
// a1=b;
// b=(a1+a2+f)%19260817;
```
### 注意变量会相互覆盖掉，f是借来存值的；

### 这是代码：
```cpp
#include<iostream>
using namespace std;
int m,n,i,a1,a2,b1,f;
int main(){
	cin>>m;
	while(m--){
		cin>>n;
		a1=1;b1=1;a2=0;
		for(i=2;i<=n;i++){
			f=a2;a2=a1;a1=b1;
			b1=(a1+a2+f)%19260817;
		}
		cout<<(a1+a2+b1)%19260817<<endl;
	}
	return 0;
}
```
## 但是！

### 这题如果这么简单也就不会是蓝题了（其实上面那个代码也能拿80分的）。

### 我们知道一般递推复杂度为o(n)，而这题数据范围中n<=（10^9），还可以问十次，绝对会超时的！

### 这里提供两种优化方案：

# （1）：
注：这是个**打表**的**不正经**的**超有用**的**骗满分**的**暴力**的方法：

### 测评姬只给你一秒时限，但你可以在自己电脑上算很久都没问题。

### 所以你可以在电脑上先算出从一开始每隔(10^7)位的三个递推数；当程序读入n时找到离n最近的递推数开始递推。

### 简单来说就是你可以在数组中先存下(10^8)的三个递推数a1,a2和b，这样就能直接从(10^8)开始递推到n；估计能比正解还快不少！

# （2）：
### 注：其实这里才进入主题，上面可以当做都是准备工作。

### 注：本蒟蒻也是今天才了解矩乘优化的QAQ，若有写的不好的地方各位大佬见谅。

### 我们先来了解一下矩阵：

### 矩阵就是一个二维方阵，矩阵A的第i行第j列可用A(i,j)来表示.

### 一个n行m列的矩阵A就是这样：

### A(1,1)  A(1,2)  A(1,3)  ...  A(1,m)

### A(2,1)  A(2,2)  A(2,3)  ...  A(2,m)

### A(3,1)  A(3,2)  A(3,3)  ...  A(3,m)

### ...

### A(n,1)  A(n,2)  A(n,3)  ...  A(n,m)

### 而矩阵乘法就是矩阵的一种运算

### 那么矩阵乘法的对象就是两个矩阵A和B，

## 注意：矩阵A的列数要与矩阵B的行数相等！

### 那么运算的答案矩阵C的第i行第j列即为：

### C(i,j)=A(i,1)*B(1,j)+A(i,2)*B(2,j)+...+A(i,p)*B(p,j);

### 如下：
```cpp
int jucheng(int n,int p,int m){
  memset(c,0,sizeof(c));
  for (int i=1;i<=n;i++)
    for (int j=1;j<=m;j++)//p为矩阵A的列数与矩阵B的行数
      for (int k=1;k<=p;k++)      //枚举的所有递推数 
        c[i][j]+=a[i][k]*b[k][j]      //公式 
}
```
### 矩阵乘法不满足交换律，但满足结合律.

### A*B!=B*A

### (A*B)*C=A*(B*C)

### 矩阵乘法也可以同余.

### 而当我们将矩阵乘法用到递推中时：

### 举一例：斐波那契数列：f[i]=f[i-1]+f[i-2].

### 把它用矩阵乘法表示：
```cpp
//        A(1,1)  A(1,2)
// [0 1]*                =[1 1]
// A矩阵  A(2,1)  A(2,2)  C矩阵 
//            B矩阵 
```
### 不难根据公示得出B矩阵为
    0,1
    1,1
### 故递推矩阵为：
```cpp
//                 0  1
//[ f[i] f[i+1] ]*      =[ f[i+1] f[i]+f[i+1] ]=[ f[i+1] f[i+2] ]
//                 1  1
```
### 而本题中的递推矩阵为：
    1,1,1
    1,0,0
    0,1,0
### 本题大意就是要将此矩阵反复乘n次。这就可以用快速幂了！

### 下面现上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct ju{
	long long s[3][3];
};
ju cheng(ju a,ju b){//矩乘函数： 
	ju c;
	for(int i=0;i<3;i++)for(int j=0;j<3;j++)c.s[i][j]=0;
	for(int i=0;i<3;i++)
	  for(int j=0;j<3;j++)
	    for(int k=0;k<3;k++)
	      c.s[i][j]+=a.s[i][k]*b.s[k][j],c.s[i][j]%=19260817;
	return c;
}
ju fast(int n){//快速幂： 
	ju c,d;
	c.s[0][0]=c.s[0][1]=c.s[0][2]=c.s[1][0]=c.s[2][1]=1;
	c.s[1][1]=c.s[1][2]=c.s[2][0]=c.s[2][2]=0;
	if(n==1)return c;//
	d=fast(n/2);//这个很关键 
	if(n%2==0)return cheng(d,d);
	return cheng(cheng(d,d),c);//多了一个1要再多乘1次 
}
void print(ju n){// 输出： 
	cout<<(n.s[0][0]+n.s[0][1])%19260817<<endl;
}
int main(){
	int m,n;
	cin>>m;
	while(m--){//一个一个算： 
		cin>>n;
	    print(fast(n));
	}
	return 0;//圆满 
}
```
码字挺累的（手残党，码了两小时了QAQ），大家点个赞再走吧。

---

## 作者：Xie_BR (赞：11)

这是一道显而易见的

# 矩阵乘法  
所以，我们一起来看一看如何初始矩阵（我相信，具体的矩阵快速幂操作是不用讲的了）：  

```cpp
for(int i=1;i<=3;i++)
{
	for(int j=1;j<=3;j++)
	{
		E.a[i][j] = (i==j);
	}
}
memset(A.a,0,sizeof(A.a));
A.a[1][1] = A.a[1][2] = A.a[1][3] = 1;
A.a[2][1] = A.a[3][2] = 1;
```

E为单位矩阵，即只有在（1,1），（2,2）。。。这样（i==j）的主对角线上是1，其他的都是0，A是我们需要的矩阵  
题意也就是把我们的A矩阵x（n+1）次  

所以快速幂就来了。。。  

```cpp
#include<bits/stdc++.h>
#define int long long
#define MK 5
const int mod = 19260817;
using namespace std;
int n;
int T;

struct oops
{
	int a[MK][MK];
}A,E;

oops work(oops A,oops B)
{
	oops Ans;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			Ans.a[i][j] = 0;
			for(int k=1;k<=3;k++)
			{
				Ans.a[i][j] = (Ans.a[i][j]+A.a[i][k]*B.a[k][j])%mod;
			}
		}
	}
	return Ans;
}

oops ksm(oops A,int k)
{
	oops Ans = E;
	while(k)
	{
		if(k&1)
		{
			Ans = work(Ans,A);
		}
		A = work(A,A);
		k>>=1;
	}
	return Ans;
}

signed main()
{
	scanf("%lld",&T);
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			E.a[i][j] = (i==j);
		}
	}
	memset(A.a,0,sizeof(A.a));
	A.a[1][1] = A.a[1][2] = A.a[1][3] = 1;
	A.a[2][1] = A.a[3][2] = 1;
	while(T--)
	{
		scanf("%lld",&n);
		oops Ans = ksm(A,n+1);
		int ans = Ans.a[1][1];
		printf("%lld\n",ans);
	}
	return 0;
}
```
# ：）

---

## 作者：Mr_Wu (赞：10)

**O(MN)**

我们考虑 dp ，令 $f_{n,x}$ 表示串长度为 $n$，且从 $n$ 位置向左有 $x$ 个 连续的 $\text{A}$，字串的方案数。

举个例子$f_{2,1}=1$，只有 $\text{BA}$ 满足条件

不难看出$1\le n\le N, 0\le x\le 2$

当 $x=0$ 时，从 $n-1$ 位置往左数显然可以有 $0, 1$ 个 或 $2$ 个，不管多少个都不会改变最后一位是 $\text{B}$ 的事实，所以有：

$$f_{n,0}=f_{n-1,0}+f_{n-1,1}+f_{n-1,2}$$

当 $x=1$ 时，考虑小学减法 1-1=0 ，所以从$n-1$位置往左数不应该有$\text{A}$，故

$$f_{n,1}=f_{n-1,0}$$

同理，

$$f_{n,2}=f_{n-1,1}$$

初始条件可以是

$$\left\{\begin{aligned}f_{1,0}=1 \\f_{1,1}=1 \\f_{1,2}=0 \\\end{aligned}\right.$$

当然也可以是

$$\left\{\begin{aligned}f_{0,0}=1 \\f_{0,1}=0 \\f_{0,2}=0 \\\end{aligned}\right.$$

答案显然是 $f_{N,0}+f_{N,1}+f_{N,2}$

**正解**

简单科普一下矩阵乘法：

对两个矩阵 $A,B$，需要 $A$ 每行数的个数和 $B$ 每列数的个数相等，然后乘法后的 $C$ 的每一项$C_{i,j}$满足：

$$C_{i,j}=\sum_{k=1}^{p} A_{i,k}\times B_{k,j}$$

可以看 [这个](http://matrixmultiplication.xyz/) 加深理解。

矩阵乘法有什么用呢？

我们考虑填写一个3*3矩阵满足

$$\begin{bmatrix}f_{n,2} & f_{n,1} & f_{n,0}\end{bmatrix}\times\begin{bmatrix}? & ? & ? \\? & ? & ? \\? & ? & ? \\\end{bmatrix}=\begin{bmatrix}f_{n+1,2} & f_{n+1,1} & f_{n+1,0}\end{bmatrix}$$

事实上随便解个方程就能算出：

$$\begin{bmatrix}f_{n,2} & f_{n,1} & f_{n,0}\end{bmatrix}\times\begin{bmatrix} 0 & 0 & 1 \\ 1 & 0 & 1 \\ 0 & 1 & 1 \\\end{bmatrix}=\begin{bmatrix}f_{n+1,2} & f_{n+1,1} & f_{n+1,0}\end{bmatrix}$$

所以我们把初始矩阵 $[f_{0,2},f_{0,1},f_{0,0}]=[0,0,1]$算出来，然后把中间那个 3*3 的矩阵乘 $n$ 次就能算出 $[f_{N,2},f_{N,1},f_{N,0}]$ 啦！

~~时间复杂度O(MN)，可以通过本题~~

所以我们做到这里到底有什么用呢？

可以证明，矩阵乘法满足结合律。 这意为着什么？

$$\begin{bmatrix}f_{0,2} & f_{0,1} & f_{0,0}\end{bmatrix}\times\begin{bmatrix} 0 & 0 & 1 \\ 1 & 0 & 1 \\ 0 & 1 & 1 \\\end{bmatrix}^N=\begin{bmatrix}f_{N,2} & f_{N,1} & f_{N,0}\end{bmatrix}$$

一个矩阵的 $N$ 次幂可以快速幂优化！

那复杂度骤降 $O(\log N)$，总复杂度 $O(M\log N)$ 可以解决此题。

顺便科普个事，容易证明：

$$ \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix} $$
任何一个 3*3 矩阵乘上它都等于自身。

快速幂时可以把它的意义当做 1

**参考代码**

```cpp
#include <cstdio>

typedef long long ll;
typedef unsigned long long ull;
#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

inline ll read()
{
	char c = getchar();
	ll ret = 0, t = 1;
	while ((c < '0' || c > '9') && c != '-') c = getchar();
	if (c == '-') t = -1, c = getchar();
	while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
	return ret * t;
}

#define MOD 19260817
struct matrix
{
	ll a[4][4];
	void operator= (const matrix& T)
	{
		for (int i = 1; i <= 3; ++i) for (int j = 1; j <= 3; ++j)
			a[i][j] = T.a[i][j];
	}
};
matrix operator* (const matrix& A, const matrix& B)
{
	matrix C; int i, j, k;
	for (i = 1; i <= 3; ++i) for (j = 1; j <= 3; ++j) C.a[i][j] = 0;
	for (i = 1; i <= 3; ++i) for (j = 1; j <= 3; ++j)
		for (k = 1; k <= 3; ++k) C.a[i][j] = (C.a[i][j] + A.a[i][k] * B.a[k][j]) % MOD;
	return C;
}

int T; ll N;

const ll GE[4][4] = 
{
	{-1, -1, -1, -1},
	{-1, 0, 0, 1},
	{-1, 1, 0, 1},
	{-1, 0, 1, 1},
}; // 转移矩阵

int main()
{
	#ifndef ONLINE_JUDGE
	freopen("input.in", "r", stdin);
	freopen("output.out", "w", stdout);
	#endif
	T = read();
	matrix ret, a; ll tmp[4], res[4];
	tmp[1] = 0, tmp[2] = 0, tmp[3] = 1; //初始矩阵
	int i, j, k;
	while (T--)
	{
		N = read();
		for (i = 1; i <= 3; ++i) for (j = 1; j <= 3; ++j) a.a[i][j] = GE[i][j];
        
		for (i = 1; i <= 3; ++i) for (j = 1; j <= 3; ++j) ret.a[i][j] = 0;
		for (i = 1; i <= 3; ++i) ret.a[i][i] = 1; //这段就是做出上面那个单位矩阵
		while (N)
		{
			if (N & 1) ret = ret * a;
			a = a * a, N >>= 1;
		} // 经典快速幂方法
		res[1] = res[2] = res[3] = 0;
		for (i = 1; i <= 1; ++i) for (j = 1; j <= 3; ++j)
			for (k = 1; k <= 3; ++k) res[j] = (res[j] + tmp[k] * ret.a[k][j]) % MOD; //用初始矩阵乘上转移矩阵的 N 次方
		printf("%lld\n", (res[1] + res[2] + res[3]) % MOD);
	}
	return 0;
}
```

---

## 作者：xcxc82 (赞：3)

# P4838 P哥破解密码题解

- ## [原题面](https://www.luogu.com.cn/problem/P4838)

**思路貌似跟dalao们的有点不一样**

先前排声明一下,蒟蒻刚学OI没多久,而且是自学的,所以思路可能比较~~sb~~



- ## 大致题意


------------
给一串长度为n的字符串,**当且仅当串只由A和B构成**，且没有连续的3个A时,该串合法,求方案总数


------------
感觉跟P4910帕秋莉的手环那道题目差不多吧....都是线性递推,貌似dalao们都是用动态规划来做的,~~蒟蒻不太会,所以只好用比较sb的递推来做qwq~~


- ## 思路
既然每个字符只有A和B两种可能,,如果字符串没有任何限制的话,很容易看出方 案总数为 : $2^n$

但这里加了一个**不能有没有连续的3个A**出现的限制条件

不妨先来画个图来看一下,更加直观一点
![](https://cdn.luogu.com.cn/upload/image_hosting/en3d9md2.png)
图中为n=6的时候的情况

我们用$f_i$来表示长度为i的字符串的**不合法方案总数**(**注意,是不合法方案总数**)

![](https://cdn.luogu.com.cn/upload/image_hosting/axtxuhus.png)

先来看第一个字符选A情况

这里我们可以把每一个B看作是一个"**断点**"

不难看出,每出现一个断点后

该断点下面的情况就可以从之前的$f_i$递推过来

而当出现连续3个A时,相当于是把下面的所有情况都"**截断**"了

也就是$2^{n-3}$种情况

第一个字符选"B"也同理

相当于是在第一个点的时候就把该串给"**截断**"了

容易推出当N=6时,合法方案总数为

$2^6-(f_{5}+f_{4}+f_{3}+2^3)$

其他n>3的情况也同理

得到式子

方案总数=$2^n-(f_{n-1}+f_{n-2}+f_{n-3}+2^{n-3})$

=$7*2^{n-3}-(f_{n-1}+f_{n-2}+f_{n-3})$

=$(2^{n-1}+2^{n-2}+2^{n-3})-(f_{n-1}+f_{n-2}+f_{n-3})$

设$s_i$为方案总数

则$s_i=s_{i-1}+s_{i-2}+s_{i-3}$

得到最终式子
$\begin{cases}2(n=1)\\4 (n=2)\\7 (n=3)\\s_i=s_{i-1}+s_{i-2}+s_{i-3}(n>3)\end{cases}$ 


贴个丑陋的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int mo=19260817;
long long n,t;
struct matrix{
	long long int a[5][5];
}ans,a;
matrix operator *(const matrix &x,const matrix &y){
	matrix z;
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			z.a[i][j]=0;
		}
	}
	for(int k=1;k<=3;k++){
		for(int i=1;i<=3;i++){
			for(int j=1;j<=3;j++){
				z.a[i][j]=(z.a[i][j]+(x.a[i][k]*y.a[k][j])%mo)%mo;
			}
		}
	}
	return z;
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		if(n==1){
			cout<<2<<endl;
		}
		
	else if(n==2){
		cout<<4<<endl;
	}
	else if(n==3){
		cout<<7<<endl;
	} 
	else{
		for(int i=1;i<=3;i++){
				for(int j=1;j<=3;j++){
					a.a[i][j]=0;
					if(i==j) ans.a[i][j]=1;
					else ans.a[i][j]=0;
				}
			}
		a.a[1][1]=a.a[1][2]=a.a[1][3]=a.a[2][1]=a.a[3][2]=1; 
		
		
		while(n){
			if(n&1) ans=ans*a;
			n>>=1;
			a=a*a;
		}
		cout<<((ans.a[1][1]+ans.a[2][1])%mo+ans.a[3][1])%mo<<endl;
	}
	
	}
	return 0;
}
```
~~貌似是蒟蒻的第一次不看题解做出(比较水的)紫题?~~











---

## 作者：Saber_Master (赞：2)

[P4838 P哥破解密码](https://www.luogu.com.cn/problem/P4838)

设$f[i][k]$表示以第$i$位结束且后缀极长连续$A$的长度为$k$的方案数，那么容易得到:
$$f[i][0]=f[i-1][0]+f[i-1][1]+f[i-1][2]$$
$$f[i][1]=f[i-1][0]$$
$$f[i][2]=f[i-1][1]$$

转移方程也很好理解，分别讨论在$k=0,1,2$的时候在最末尾接一个$A$或$B$即可得到.

注意到$n$的值特别大，所以线性做法肯定无法通过此题，考虑到三个转移方程具有很明显的特性，我们利用矩阵快速幂进行优化.

容易构造转移矩阵
$A=\left[ \begin{array}{ccc}
    1 & 1 & 1\\
    1 & 0 & 0\\
    0 & 1 & 0\\
\end{array} \right]$
和初始矩阵
$A_0=\left[ \begin{array}{ccc}
    1\\
    0\\
    0\\
\end{array} \right]$，答案矩阵即为$A_0 A^{n-1}$

$O(3^2\log n)$

```cpp
struct Matrix{
	ll num[3][3];
	Matrix(){
		memset(num, 0, sizeof num);
	}
};

Matrix mul(Matrix x, Matrix y){
	Matrix z;
	for (R ll k=0; k<3; k++)
		for (R ll i=0; i<3; i++)
			for (R ll j=0; j<3; j++)
				(z.num[i][j]+=x.num[i][k]*y.num[k][j])%=mod;
	return z;
}

Matrix quick_pow(Matrix x, ll y){
	Matrix z;
	z.num[0][0]=z.num[1][1]=z.num[2][2]=1;
	for (; y; y>>=1){
		if (y&1) z=mul(z, x);
		x=mul(x, x);
	}
	return z;
}
ll m, n;
int main(){
	read(m);
	while (m--){
		Matrix A;
		A.num[0][0]=1; A.num[0][1]=1; A.num[0][2]=1;
		A.num[1][0]=1; A.num[1][1]=0; A.num[1][2]=0;
		A.num[2][0]=0; A.num[2][1]=1; A.num[2][2]=0;
		read(n);
		A=quick_pow(A, n);
		writeln((A.num[0][0]+A.num[1][0]+A.num[2][0])%mod);
	}
}
```


---

## 作者：霍士弘 (赞：2)

貌似和大家写的转移方程不太一样  
设这个字符串为 $a$   
设 $f_{i,0/1,0/1}$ 为**所有**长度为 $i$ 的字符串，$a_i = 0/1,a_{i-1} = 0/1$ 时，有多少种满足条件的字符串。  
① $a_{i} = 0,a_{i-1} = 0$    
这时 $a_{i-2}$ 只能为 $1$  
$f_{i,0,0} = f_{i-1,0,1}$ 

② $a_i = 0,a_{i-1} = 1$   
这时 $a_{i-2} = 0/1$  
$f_{i,0,1} = f_{i-1,1,0} + f_{i-1,1,1}$  

③ $a_i = 1,a_{i-1} = 0$  
这时 $a_{i-2} = 0/1$  
$f_{i,1,0} = f_{i-1,0,0} + f_{i-1,0,1}$  

④ $a_i = 1,a_{i-1} = 1$  
这时 $a_{i-2} = 0/1$  
$f_{i,1,1} = f_{i-1,1,0} + f_{i-1,1,1}$
***
以上就是 dp 了，这部分大家可以自己画图推推。  
我写的时候就直接想到了这个做法，可能没有那么清爽。  
这个 dp 的复杂度显然是 $\Theta(nm)$ 的，过不了。  

我们将我们的状态 （即 $f_{i,0/1,0/1}$） 看成矩阵的形式：  
$$A = \begin{pmatrix}
    f_{i-1,0,0} & f_{i-1,0,1} & f_{i-1,1,0} & f_{i-1,1,1} \\
    f_{i,0,0} & f_{i,0,1} & f_{i,1,0} & f_{i,1,1} \\
\end{pmatrix}
$$ 
状态转移看成矩阵乘法，然后我们要把这个矩阵转移成：  
$$AB = C = \begin{pmatrix}
    f_{i,0,0} & f_{i,0,1} & f_{i,1,0} & f_{i,1,1} \\
    f_{i+1,0,0} & f_{i+1,0,1} & f_{i+1,1,0} & f_{i+1,1,1} \\
\end{pmatrix}
$$ 
由于 $A,B$ 都是 $1 \times 4$， 的矩阵需要构造一个 $4 \times 4$ 的矩阵 $C$  
根据矩阵乘法的定义，就可以轻松构造：  
$$B = \begin{pmatrix}
    0 & 0 & 1 & 0 \\
    1 & 0 & 1 & 0 \\
    0 & 1 & 0 & 1 \\
    0 & 1 & 0 & 1 \\
\end{pmatrix}
$$ 
然后直接上矩阵快速幂就好了。  
时间复杂度 $\Theta(m n^3 \log n)$
上面这些矩阵的内容相信大家都会（不然为啥开这题），不会自搜模板和博客学习。  
这题主要是要推出 dp 方程，然后矩阵优化就很套路。
~~代码写的很丑不要在意~~  
代码：  

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 4
#define mod 19260817
#define ll long long
using namespace std;
int n,m;

struct matrix
{
	ll a[maxn + 10][maxn + 10];
	matrix()
	{
		memset(a,0,sizeof(a));
	}
} ;//定义结构体
matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i = 1;i <= 4;i++)
	{
		for(int j = 1;j <= 4;j++)
		{
			for(int k = 1;k <= 4;k++)
			{
				c.a[i][j] = c.a[i][j] % mod + a.a[i][k] % mod * b.a[k][j] % mod;
			}
		}
	}
	return c;
} //矩阵乘法
matrix qpow(matrix a,ll k)
{
	if(k == 1) return a;
	if(k % 2 == 0) 
	{
		matrix t = qpow(a,k/2);
		return mul(t,t);
	}else
	{
		matrix t = qpow(a,k/2);
		return mul(t,mul(t,a));
	}
} //矩阵快速幂
int main()
{
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&n);
		if(n == 1) printf("2\n");
		else if(n == 2) printf("4\n");
		else if(n == 3) printf("7\n"); //n <= 3就直接特判
		else
		{
			matrix A,B;
			A.a[1][1] = 1,A.a[1][2] = 2,A.a[1][3] = 2,A.a[1][4] = 2;
			A.a[2][1] = 2,A.a[2][2] = 4,A.a[2][3] = 3,A.a[2][4] = 4;//构造一下边界状态组成的矩阵
			B.a[2][1] = 1,B.a[3][2] = 1,B.a[4][2] = 1,B.a[1][3] = 1,B.a[2][3] = 1,B.a[3][4] = 1,B.a[4][4] = 1; // 转移矩阵
			matrix C = mul(A,qpow(B,n-3));
			printf("%lld\n",(C.a[1][1] + C.a[1][2] + C.a[1][3] + C.a[1][4]) % mod);
		}
	}
	return 0;
}
```

---

## 作者：DPair (赞：2)

## 楼下的题解评论里有人说看不懂，那我就讲的浅显一些。

不过还是要一定预备知识的（**矩阵乘法**），不会者请转[P1939](https://www.luogu.org/problemnew/show/P1939)。

首先，这道题拿到手上，很容易看出是要用到递推的。

由于我们知道，不能有连续$3$个$A$，因此，一个长度为$n$的字符串末尾一定只会有$0,1,2$个$A$，我们以此递推。

我这边使用$f[i][j] (i \in [1,n],j \in [0, 2])$，表示 $n=i$ 时，一个数末尾有 $j$ 个 $A$ 的方案数。

由于末尾有$A$的可能性只与上一状态中一个状态有关（$1$个$A$与$0$个$A$有关，$2$个$A$与$1$个$A$有关）。

而末尾有$0$个$A$的情况，只要塞一个$B$就行了。所以是上一状态中所有状态方案数之和。

那么，递推式就显而易见了。
$$f[1][0] = 1,~f[1][1] = 1,~f[1][2] = 0$$
$$f[i][0] = f[i - 1][0] + f[i - 1][1] + f[i-2][2]$$
$$f[i][1] = f[i - 1][0]$$
$$f[i][2] = f[i-1][1]$$

所以最后结果就是
$$f[n][0] + f[n][1] + f[n][2]$$

然而，直接推要$O(N)$，肯定过不了$10^9$的范围，那么，就需要矩阵快速幂。

### 正解

根据我们推出的递推式与初始条件，可以发现一个状态只与上一状态的三个值有关，因此我们设一个有三个元素的矩阵，表示：
```
f[i][0]
f[i][1]
f[i][2]
```
它的初始状态是：
```
1
1
0
```
那么，我们的转置矩阵，可以采用找系数的思想。对此，我们稍微转化一下递推式：
$$f[i][0] = 1 \times f[i - 1][0] + 1 \times f[i - 1][1] + 1 \times f[i - 2][2]$$
$$f[i][1] = 1 \times f[i - 1][0] + 0 \times f[i - 1][1] + 0 \times f[i - 1][2]$$
$$f[i][2] = 0 \times f[i - 1][0] + 1 \times f[i - 1][1] + 0 \times f[i - 1][2]$$

那么，我们乘的矩阵就很简单了：
```
1 1 1
1 0 0
0 1 0
```
再写一个矩阵快速幂，然后就很愉快地$AC$了。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define MOD 19260817
template <typename T>
inline void read(T &x)
{
    char c;
    x = 0;
    int fu = 1;
    c = getchar();
    while(c > 57 || c < 48)
    {
        if(c == 45)
        {
            fu = -1;
        }
        c = getchar();
    }
    while(c <= 57 && c >= 48)
    {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x)
{
    if(x < 0)
    {
        putchar(45);
        x = -x;
    }
    if(x > 9)
    {
        fprint(x / 10);
    }
    putchar(x % 10 + 48);
}

struct Matrix{
    LL a[110][110], row, column;//row 列数， column行数
    Matrix(LL r, LL c) : row(r), column(c) {}
    void clear()
    {
        memset(a, 0, sizeof(a));
    }
    Matrix operator + (const Matrix &b) const
    {
        Matrix ret(row, column);
        for (register LL i = 1;i <= row;i ++)
        {
            for (register LL j = 1;j <= column;j ++)
            {
                ret.a[i][j] = (a[i][j] + b.a[i][j]) % MOD;
            }
        }
        return ret;
    }
    Matrix operator * (const Matrix &b) const
    {
        Matrix ret(row, b.column);
        ret.clear();
        ret.row = row;
        ret.column = b.column;
        for (register LL i = 1;i <= ret.row;i ++)
        {
            for (register LL j = 1;j <= ret.column;j ++)
            {
                for (register LL k = 1;k <= column;k ++)
                {
                    ret.a[i][j] = (ret.a[i][j] + (a[i][k] * b.a[k][j]) % MOD) % MOD;
                }
            }
        }
        return ret;
    }
    Matrix quick_pow(LL k)
    {
        Matrix ret(row, row), tmp(row, row);
        memcpy(tmp.a, a, sizeof(tmp.a));
        ret.clear();
        for (register int i = 1;i <= ret.row;i ++)
        {
            ret.a[i][i] = 1;
        }
        while(k)
        {
            if(k & 1) ret = ret * tmp;
            k >>= 1;
            tmp = tmp * tmp;
        }
        return ret;
    }
};

Matrix a(1, 3), c(3, 3);

LL T;

//f[i][0] = f[i - 1][2] + f[i - 1][1] + f[i - 1][0]
//f[i][1] = f[i - 1][0]
//f[i][2] = f[i - 1][1]
/*
1   1 1 1
1   1 0 0
0   0 1 0
*/
void work()
{
    LL n;
    read(n);
    a.clear();
    a.a[1][1] = a.a[1][2] = 1;
    c.clear();
    c.a[1][1] = c.a[1][2] = c.a[2][1] = c.a[2][3] = c.a[3][1] = 1;
    a = a * c.quick_pow(n - 1);
    fprint((a.a[1][1] + a.a[1][2] + a.a[1][3]) % MOD);
    putchar('\n');
}

int main()
{
    read(T);
    while(T --)
    {
        work();
    }
}
```

---

## 作者：设计涉及社稷 (赞：1)

首先你得看出这是个线性递推，由上一个状态有多少个A转移而来

**范围**：1e9的线性递推，那么，上，矩乘！

**集合**：$f[i][j]$表示转移到i位字符串，第i位填了j个A的集合的合法个数。

**转移**：

```
f[i][0]=f[i-1][0]+f[i-1][1]+f[i-1][2];//第i位填B的时候可以由上一位填B，A，AA转移而来
f[i][1]=f[i-1][0]//第i位填A的时候可以由上一位填B转移而来
f[i][2]=f[i-1][1]//第i位填AA的时候可以由上一位填A转移而来
/* 转移矩阵：
1 1 0
1 0 1 
1 0 0
*/ 
```



**终态**:`f[n][0]+f[n][1]+f[n][2]`

**初始化**：

```
f[1][0]=1,f[1][1]=1,f[1][2]=0;
```

**BTW:**求长度为n的字符串的合法个数，那么只需要转移n-1次（因为已经预处理出长度为1的字符串的合法个数）



注意：在base矩阵里面我并没有用到”0“这个角标，以为嫌麻烦。所以所有角标都加上了1的哦

well,show U the code.
```
int n;
const int mod=19260817;

struct Matrix {
    int m[4][4];
    Matrix(){mem(m,0);}
    friend Matrix operator *(Matrix a,Matrix b){
        Matrix c;
        rep(i,1,3)
            rep(k,1,3)
                rep(j,1,3)
                    c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;
        return c;
    }
    friend Matrix operator ^(Matrix a,int k){
        Matrix res;
        rep(i,1,3)res.m[i][i]=1;
        for(;k;k>>=1){
            if(k&1)res=res*a;
            a=a*a;
        }
        return res;
    }
};

#undef int
int main(){
#define int long long
    #ifdef WIN32
    freopen("a.txt","r",stdin);
    #endif
    int T;rd(T);
    while(T--){
        rd(n);
        Matrix ans,base;
        ans.m[1][1]=1,ans.m[1][2]=1,ans.m[1][3];
        base.m[1][1]=1,base.m[1][2]=1,base.m[1][3]=0;
        base.m[2][1]=1,base.m[2][2]=0,base.m[2][3]=1;
        base.m[3][1]=1,base.m[3][2]=0,base.m[3][3]=0;
        base=base^(n-1);
        ans=ans*base;
        printf("%lld\n",(ans.m[1][1]+ans.m[1][2]+ans.m[1][3])%mod);
    }
    return 0;
}
```



---

## 作者：yzhang (赞：1)

### [原题传送门](https://www.luogu.org/problemnew/show/P4838)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10890935.html)

#### 考虑一个一个将字母加入字符串后面

#### 设$f[i][0/1/2]$表示长度为$i$字符串末尾有$0/1/2$个A的种类数

#### 易知：

#### $f[1][0]=1,f[1][1]=1,f[1][2]=0$

#### $f[i][0]=f[i-1][0]+f[i-1][1]+f[i-1][2]$

#### $f[i][1]=f[i-1][0]$

#### $f[i][2]=f[i-1][1]$

#### 发现这个递推式子珂以用矩阵乘法

$$
 \left[
 \begin{matrix}
   f[i][0] & f[i][1] & f[i][2] 
  \end{matrix}
  \right] 
*
\left[
 \begin{matrix}
   1 & 1 & 0 \\
   1 & 0 & 1 \\
   1 & 0 & 0
  \end{matrix}
  \right] 
=
\left[
 \begin{matrix}
   f[i+1][0] & f[i+1][1] & f[i+1][2] 
  \end{matrix}
  \right] 
$$

#### 矩阵快速幂即可，答案是$f[n][0]+f[n][1]+f[n][2]$

```cpp
#include <bits/stdc++.h>
#define mod 19260817
//#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
struct mat{
	int a[3][3];
	inline mat()
	{
		memset(a,0,sizeof(a));
	}
	inline mat operator*(const mat&b)const{
		mat c;
		for(register int i=0;i<3;++i)
			for(register int j=0;j<3;++j)
				for(register int k=0;k<3;++k)
					c.a[i][j]=(c.a[i][j]+1ll*a[i][k]*b.a[k][j])%mod;
		return c;
	}
}s,o,ans;
inline mat fastpow(register mat a,register int b)
{
	mat res;
	res.a[0][0]=res.a[1][1]=res.a[2][2]=1;
	while(b)
	{
		if(b&1)
			res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}
int T,n;
int main()
{
	T=read();
	s.a[0][0]=s.a[1][0]=s.a[2][0]=s.a[0][1]=s.a[1][2]=1;
	o.a[0][0]=o.a[0][1]=1;
	while(T--)
	{
		n=read();
		ans=o*fastpow(s,n-1);
		write((ans.a[0][0]+ans.a[0][1]+ans.a[0][2])%mod),puts("");
	}
	return 0;
}
```

---

## 作者：Yyxxxxx (赞：1)

## 题意
求$F_n,n\in\mathbb{N^* }$ 其中：
$$F_n=F_{n-1}+F_{n-2}+F_{n-3}$$
## $Solution$
首先我们要知道为啥题意变成了这样？   
我们对于$n,Ans$找规律：   
$$n=0,1,2,3,4,5...$$
$$A=1,2,4,7,13,24,44...$$
显然就得到了上面的题意，然后我们发现这是一道紫题。   
所以不可能是递推，而是需要矩阵加速的。       
然后推方程是这样的。    
 $\begin{bmatrix}
 F_n&F_{n-1}&F_{n-2}\\
 \end{bmatrix}\times M=
 \begin{bmatrix}
 1\cdot F_{n}+1\cdot F_{n-1}+1\cdot F_{n-2}&1\cdot Fn+0\cdot F_{n-1}+0\cdot F_{n-2}&0\cdot F_n+1\cdot F_{n-1}+0\cdot F_{n-2}
 \end{bmatrix}$ 
 $$\therefore M=
 \begin{bmatrix}
 1&1&0\\
 1&0&1\\
 1&0&0\\
 \end{bmatrix}$$
 答案即为：
 $$\begin{bmatrix}
 7&4&2\\
 \end{bmatrix}
 \times
  \begin{bmatrix}
 1&1&0\\
 1&0&1\\
 1&0&0\\
 \end{bmatrix}^{n-3}$$
 对于$n\le3$特判，就可以了
 ## $Code$
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=19260817;
#define int long long
struct matrix
{
	int a[5][5];
};
void init(matrix &x)
{
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++) x.a[i][j]=0;
}
matrix mul(matrix a,matrix b)
{
	matrix c;
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
		{
			c.a[i][j]=0;
			for(int k=1;k<=3;k++)
				c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;
		}
	return c;
}
matrix qpow(matrix a,int p)
{
	matrix res;
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
			res.a[i][j]=(i==j);
	while(p)
	{
		if(p&1)res=mul(res,a);
		a=mul(a,a);p>>=1;
	}
	return res;
}
void work()
{
	int n;
	scanf("%d",&n);
 	if(n==1) {puts("2");return;}
    if(n==2) {puts("4");return;}
    if(n==3) {puts("7");return;}
	matrix ans,base;init(ans),init(base);
	ans.a[1][1]=7,ans.a[1][2]=4,ans.a[1][3]=2;
	base.a[1][1]=base.a[2][1]=base.a[3][1]=base.a[1][2]=base.a[2][3]=1;
	printf("%d\n",mul(ans,qpow(base,n-3)).a[1][1]%mod);
}
signed main()
{
	int t;
	scanf("%d",&t);
	while(t--)work();
	return 0;
}
```


---


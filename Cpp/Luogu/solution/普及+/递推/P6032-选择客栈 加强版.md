# 选择客栈 加强版

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。

每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。

晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 

## 说明/提示

【样例解释】 

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textsf{客栈编号} & \text{①} & \text{②} & \text{③} & \text{④} & \text{⑤} \\\hline
\textsf{色调} & 0 & 1 & 0 & 1 & 1 \\\hline
\textsf{最低消费} & 5 & 3 & 2 & 4 & 5 \\ \hline
\end{array}$$


二人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤。

但是若选择住 ④⑤ 号客栈的话，④⑤ 号客栈之间的咖啡店的最低消费是 $4$，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

【数据范围】  
对于 $25\%$ 的数据，$n\leq 100$；  
对于 $40\%$ 的数据，$n\leq 1000$；   
对于 $80\%$ 的数据，$n\leq 2 \times 10^5$，$k \leq 50$；   
对于 $100\%$ 的数据，$2\leq n\leq2\times 10^6$，$1 \le k\leq 10^4$，$0\leq p\leq 100$，$0\leq$ 最低消费 $\leq 100$ 。

## 样例 #1

### 输入

```
5 2 3
0 5
1 3
0 2
1 4
1 5```

### 输出

```
3```

# 题解

## 作者：CCF_zkskyer (赞：18)

# 第一篇绿题题解
首先，读题可以发现，这道题相对于[P1311 选择客栈](https://www.luogu.com.cn/problem/P1311)唯一的差别就是数据范围大了，未加强过的题目可以用$O(Nlog n)$的算法**勉强**过，但是这道题应该是会$TLE$几个点的，所以如果要$AC$的朋友们，就要用到$O(N)的算法。$~~那么恭喜您，找对题解了~~！

来说一下思路，既然是$O(N)$的解法，自然只能有循环，那么当然是$i=1$~$N$了，那么括号内放什么呢？听博主慢慢道来：

大致思路是这样的：循环一层$i=1$~$N$，接着找最近的一个价格小于等于$P$的咖啡厅，所以前面的所有同色客栈都可以为一个方案

三个关键数组$aft[i]$存最后一个颜色为$i$的客栈的坐标，$tot[i]$表示同个颜色每次的方案数，$numb[i]$存颜色为 $i$的客栈的总数。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=200005;

long long n,k,p;
long long col,pri;
long long aft[maxn],tot[maxn],numb[maxn],bef;

long long ans;

int main()
{
	//freopen("hotel.in","r",stdin); 这里由于是考试时打的，
	//freopen("hotel.out","w",stdout); 所以用了文件输入输出 

    scanf("%lld%lld%lld",&n,&k,&p);
    
    for (register int i=1;i<=n;++i)
    {
    	scanf("%lld%lld",&col,&pri); //再循环内输入，节约一点点时间 
    	
    	if (pri<=p) bef=i; //满足就赋值 
    	
    	if (bef>=aft[col]) tot[col]=numb[col]; //最大值重新命值 
    	
    	ans+=tot[col]; //答案加上暂时储存 
    	
		aft[col]=i; //最后客栈位置也要改变 
    	
    	numb[col]++; //暂时储存的加上一 
	}
	
	printf("%lld",ans); // 愉快的输出 

	return 0;
}
```
希望对大家有帮助$ ! ! !$
# 谢谢观看! ! !
 
 

---

## 作者：一扶苏一 (赞：13)

# 【P6307】选择客栈 加强版

## Description

给定一个两个序列 $A$，$B$，求满足 $i < j$，$A_i = A_j$ 且 $\min\limits_{k = i}^j \leq p$ 的点对 $(i, j)$ 个数。

## Limitations

序列长度不超过 $10^6$。

## Solution

又是点对题，套路做法是枚举右端点，然后想办法干掉左端点。

考虑对于一个右端点 $r$，合法的左端点个数即为 $r$ 左侧第一个费用不大于 $p$ 的位置 $x$ 的左侧的同颜色个数。可以考虑对每种颜色做一个前缀和维护前缀该颜色个数，然后查询 $r$ 的颜色在 $x$ 位置的前缀和值即可。时间复杂度 $O(nk)$，可以通过 $80$ 分的数据。当然可以使用可持久化线段树维护这些前缀和，但是这里考虑一种复杂度更低的做法。

注意到 $p$ 是给定的，因此当右端点 $r$ 增大时，位置 $x$ 不会变小，而任何时刻大于 $x$ 的位置的颜色个数是不需要统计的，因为不会产生贡献。因此我们只维护当前的 $x$ 及其左侧的位置的每种颜色的个数即可。当碰到某个位置的费用不高于 $p$ 时，则将该位置左侧所有没有被计算个数的位置都加入贡献，然后更新 $x$ 即可。考虑时间复杂度，每个位置只会被计算一次贡献，因此总时间复杂度 $O(n)$。

~~所以毒瘤鱼鱼为什么不把 k 出到与 n 同阶呢~~。

## Code

```cpp
#include <cstdio>

const int maxn = 2000005;

int n, k, p;
ll ans;
int col[maxn], fee[maxn], cnt[maxn];

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(k); qr(p);
  for (int i = 1; i <= n; ++i) {
    qr(col[i]); qr(fee[i]);
    if (fee[i] <= p) {
      for (int j = i - 1; fee[j] > p; --j) {
        ++cnt[col[j]];
      }
    }
    ans += cnt[col[i]];
    if (fee[i] <= p) {
      ++cnt[col[i]];
    }
  }
  printf("%lld\n", ans);
}

```



---

## 作者：MX_muxi (赞：7)

[原题戳这里]( https://www.luogu.com.cn/problem/P6032)
#### [获得更好的体验](https://www.luogu.com.cn/blog/xiyue21862/p6032-ti-xie)
## 二话不说上代码~
```cpp
#include<bits/stdc++.h>//万能头文件
#pragma GCC optimize(2)//优化代码
#pragma GCC optimize(3)//优化代码
#pragma GCC optimize("Ofast")//优化代码
#pragma GCC optimize("inline")//优化代码
#pragma GCC optimize("-fgcse")//优化代码
#define DEBUG printf("Baylor AK IOI\n");//还是优化代码
#pragma GCC optimize("Ofast,unroll-loops,fast-math")//又是优化代码
#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")//依然优化代码
#pragma GCC optimize("Ofast","-funroll-loops","-fdelete-null-pointer-checks")//最后一个优化代码
using namespace std;//命名空间
long long n,k,p,flag[10005],flagx[10005],x,y,ans;//变量
int main()
{
    cin>>n>>k>>p;//输入
	for(int i=1;i<=n;i++)
	{
        cin>>x>>y;//x为装饰色调，y为最低消费
		ans+=(y<=p)?flag[x]:flagx[x]; //通过问号关系运算符计算,如果i号客栈的咖啡店的最低消费小于能接受的最低消费的最高值，记录flag[x];否则记录flagx[x];
		flag[x]++;//统计并方便用比较来计算ans
		if(y<=p) //判断
		for(int j=0;j<k;j++)
		flagx[j]=flag[j];
	}//循环计算可选的住宿方案的总数
	cout<<ans;//输出
}
```
## 喜欢就点个赞吧！


---

## 作者：SunsetSamsara (赞：4)

## 【题面大意】
给三个正整数 $n,k,p$ 满足 $n \le 2 \times 10^5,k \le 10^4,p \le 100$
与两个长度为 $n$ 的序列 $A,B$ 且 $A_i \le k$。

求满足 $i < j$ 且 $A_i = A_j$ 而且 $\min(B_i,B_{i+1},...,B_j) \le p$的 $i,j$ 的 个 数

## 解法:
这题数据范围 $10^6$ ，直接枚举显然不行。只能是 $O(n)$ 或严格 $O(nlogn)$ 的解法。

在这里，我使用了时间复杂度 $O(n)$ 的dp算法。

首先，我们要算的是**总方案数** $ans$ ,所以我们要先用**颜色**分类枚举，
定义 $dp1[i]$ 表示使用第 $i$ 种颜色的总方案数。最后的 $ans$ 就是 $dp1$ 中所有数之和。我们再使用 $dp2[i]$ 表示第 $i$ 种颜色的个数，$last[i]$ 表示上一个颜色为 $A_i$ 的位置。

状态转移方程如下:

枚举每一个 $1 \le i \le n$ 的 $i$,

如果 $B_i\le p$ 那么就记下它，可以用来更新附近的值。

如果记下的数大于等于 $last[i]$ 那么就必须把 $dp1[i]$ 赋值为更优的 $dp2[i]$,

接下来让 $last[A_i]=i$,	并把 $dp2[i]$ 加上 $1$

最后就输出 $dp1$ 的和。

AC代码如下:

```cpp#include<stdio.h>
//本题开long long很重要
long long n,k,p;
long long last[2000001];
long long dp1[2000001];
long long dp2[2000001];
long long A[2000001]; 
long long B[2000001];//两个数组 
int main(){
    scanf("%lld%lld%lld",&n,&k,&p);
    for(int i=1;i<=n;++i)
		scanf("%lld%lld",A+i,B+i);
	long long tmp=0; //记下的数 
	long long ans=0; //答案 
    for(int i=1;i<=n;++i){
        if(B[i]<=p)tmp=i;//记下它，可以用来更新附近的值。
        if(tmp>=last[A[i]])//如果记下的数大于等于 last[i] 那么就必须把 dp1[i] 赋值为更优的 dp2[i],
            dp1[A[i]]=dp2[A[i]];
        last[A[i]]=i;//令last[A[i]]=i,dp2[i]加上1
        ++dp2[A[i]];
        ans+=dp1[A[i]];//答案加上dp1[A[i]]
    } 
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：3)

此题有$O(n)$做法，我比较菜只会log

首先由于全局的$p$都是一个同一个，很容易地就能想到把消费$<=p$的客栈的权值设为1然后做个前缀和记作$sum$

然后因为住宿的条件包含两个客栈颜色相同，自然想到把同个颜色的所有客栈编号装在一起，所以就开$k$个$vector$记作$v[]$，$v[c]$表示所有颜色为c的客栈编号的集合，比如$v[1]=\left \{1,7,8 \right \}$表示客栈$1,7,8$颜色为1，注意这个vector是按升序排序的，在读入时插入即可

然后我们来考虑如何统计答案，对于两个颜色相同的客栈$l,r$，如果$[l,r]$中有消费$<=p$的，那么就是$[l,r]$的权值和$>0$，即$sum[r]-sum[l-1]>0$

我们不妨只考虑$j<i$的情况，然后对每个i统计有多少个j满足条件，就能不重不漏地得到答案，根据上面的描述，我们可以写出偏序组:

$$1.col[j]=col[i]$$

$$2.sum[j]<sum[i]$$

$$3.j<i$$

然后这是一个三维偏序，乍一看没法写，但由于我们把$col$相同的装在同一个$vector$里$(v[col])$，也就是我们只要在$v[col]$内进行统计就能满足第一维限制，所以就转化成了$2.3.$的二维偏序问题，观察发现这显然是个正序对问题，然后直接上树状数组维护即可
```cpp
#include<cstdio>
#include<vector>
using std::vector;
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();bool f=0;
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
const int N=2e6+10,K=1e4+10;
typedef long long ll;
typedef vector<int>vit;
ll ans;
vit v[K];
int n,k,p,sum[N];
class Binary_Indexed_Tree
{
	private:
		int t[N];
		inline const int lowbit(int x)
		{
			return x&-x;
		}
	public:
		inline const void update(int x,int y)
		{
			for (;x<=n;x+=lowbit(x))t[x]+=y;
		}
		inline const int query(int x)
		{
			int sum=0;
			for (;x;x-=lowbit(x))sum+=t[x];
			return sum;
		}
}bit;
inline const ll query(int c)
{
	ll cnt=0;
	for (vit::iterator i=v[c].begin();i!=v[c].end();i++)
	{
		if (i!=v[c].begin())cnt+=bit.query(sum[*i]-1);
		bit.update(sum[*i-1],1);
	}
	for (vit::iterator i=v[c].begin();i!=v[c].end();i++)
		bit.update(sum[*i-1],-1);
	return cnt;
}
int main()
{
	read(n);read(k);read(p);
	for (int c,w,i=1;i<=n;i++)
		read(c),read(w),
		v[++c].push_back(i),
		sum[i]=sum[i-1]+(w<=p);
	for (int i=0;i<=n;i++)sum[i]++;n++;
	for (int i=1;i<=k;i++)ans+=query(i);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Origin0107 (赞：2)

# Solution

本来 $2011$ 的题是可以接受$O(nk)$或$O(n \log n)$的时间复杂度的，但这道题显然是不能的，所以我们只能思考$O(n)$的算法。

读题显然可以发现，其实每个点能否满足不超过 $p$ 元的要求在输入时就可以预处理出来，这里我们用把满足要求的 $i$ 点称为可行客栈。

同时，我们考虑把 $i$ 点作为每个区间的右端点，只需要判断与前面 $i-1$ 个点能不能作为一种答案即可，$i$ 点的状态值 $dp[i]$ 即为在 $i-1$ 个区间中含有可行客栈且左右端点颜色相同区间的总数。

同时定义 $num[color]$ 为当前颜色的点出现的次数，$last[color]$ 为与当前点颜色相同且最近的点的位置。

显然，每个点的状态值是递增的，也可以进行转移，分为四种情况：

1. 当前点是可行客栈。
2. 当前点不属于 $1$ ，但在当前点与当前点颜色相同且最近的点之间有一个可行咖啡馆。
3. 当前点不属于 $2$。

对于 $1$ ，我们使 $dp[i]=num[color]$ ，因为当前点可以和前面 $i-1$ 个点中颜色相同的任意一点构成可行区间。

对于 $2$ ，我们使 $dp[i]=num[color]$ ，因为在当前点与当前点颜色相同且最近的点之间(包括当前点颜色相同且最近的点）有一个可行客栈，那么和前面的颜色相同的任意一点也可以构成可行区间。

对于 $3$ ，我们使 $dp[i]=dp[last[color]]$ ，在上一段中已有解释。

最后 $ \sum\limits_{i=1}^n dp[i] $ 即为答案。

对于这道题，我们更需要理解的是递推求值的思想，当面对枚举区间的复杂度不能接受时，可以考虑舍弃一个区间端点选择递推，往往会有意想不到的惊喜。

# Code
```
#include<bits/stdc++.h>
using namespace std;

struct node{
    int num;
    int col;
};

int dp[2000010],col[2000010],num[100000],last[100000];
bool can[2000010];
node can_last;

int main()
{
    int n,k,p;
    cin>>n>>k>>p;
    for(int i=1;i<=n;i++)
    {
        int s;
        cin>>col[i]>>s;
        if(s<=p) can[i]=1;//记录可行客栈
    }
    for(int i=1;i<=n;i++)
    {
        int k=col[i];
        if(can[i]) dp[i]=num[k];//第一种情况
        else if(can_last.num>=last[k]&&can_last.num) dp[i]=num[k];//第二种情况
        else dp[i]=dp[last[k]];//第三种情况 
        last[k]=i;
        if(can[i])
        {
            can_last.num=i;
            can_last.col=k;
        }   
        num[k]++;
    }
    long long ans=0;//记得开long long
    for(int i=1;i<=n;i++)
    {
        ans+=dp[i];//统计答案
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：mot1ve (赞：1)

太弱了一开始只想到 $O(n^2)$ 的做法，看了这道题弱化版的题解才学会 $O(n)$ 的做法。

既然时间复杂度是 $O(n)$ 的，那我们肯定不能 $a,b$ 都枚举，考虑枚举 $b$

要满足两个要求：1.两个客栈颜色必须相同。2.在两个客栈的闭区间内至少有一个客栈

花费不高于我们要求的花费。

我们可以设置一个分水岭 $temp$ ，作用是记录最晚枚举到的花费不高于我们要求的花费的客栈。

那么，满足两个要求的客栈的对数，不就是 $temp$ 之前和 $b$ 颜色相同的个数了吗？

我们需要开一个数组 $num$ 记录 $temp$ 之前各种颜色的客栈的个数。

枚举 $b$ ，这个答案是持续更新的，此题可在线做。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int temp,n,k,p,cost;
long long ans;//开long long防爆233
int col[2000010],num[10010];
int main()
{
	scanf("%d%d%d",&n,&k,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&col[i],&cost);
		if(cost<=p)
		{
			for(int j=i;j>temp;j--)
			{
				num[col[j]]++;
			}
			temp=i;
			ans+=num[col[i]]-1;//多算了当前的客栈要减去1
		}
		else ans+=num[col[i]];
	}
	printf("%lld",ans);
	return 0;
} 

---

## 作者：_lfxxx_ (赞：0)

**题目传送门：[P6032 选择客栈 加强版](https://www.luogu.com.cn/problem/P6032)**

### 题意：
给定两个序列 $A,B$ 和 $p$ ，求满足 $A_i=A_j$ 且 $\min\limits_{k=i}^j\le p$ 的 $(i,j)(i<j)$ 的组数。其中序列 $A,B$ 的长度为 $n$ 。
### 思路：
用 $\texttt{color}$ 存储颜色， $\texttt s$ 表示每种颜色为总方案数的伪（看到后面你就知道什么是"伪"了）贡献。

由于枚举两边端点太浪费时间，所以只枚举右端点（相当于读入时就在枚举）。

设此时读入的颜色为 $\texttt i$ 。

先考虑简单的情况，即该位置客栈的钱大于 $p$ 。这时显然总方案数要加 $s_{color_i}$ 。

如果该位置客栈的钱小于等于 $p$ 呢？显然，因为我们只枚举了右端点了，因此我们要在这次更新 $\texttt{color}$ 。我们不妨就假设后面有跟之前颜色相同的客栈，设 $t$ 为上一个小于等于 $p$ 的客栈，这时就可以更新了：
```cpp
for(int j=i;j>t;j--)
	s[color[j]]++;
```
这时方案总数加上 $s_{color_i}-1$ （减 $1$ 是因为不能自己跟自己配）

要是后面没有呢？如果没有，方案总数就**不会加到该颜色的贡献**，也就**不会对方案总数造成影响**了。（这可以说是该题重难点！）

总体思路知道了，贴一下代码。

### 注意事项：
~~不开~~ $\texttt{long long}$ ~~见祖宗。~~
### 代码：
```cpp
#include<cstdio>
inline int read(){
    char ch=getchar();
    int x=0;
    while(ch<48||ch>57)
        ch=getchar();
    while(ch>=48&&ch<=57){
        x=(x<<1)+(x<<3)+ch-48;
        ch=getchar();
    }
    return x;
}//快读
int color[2000001],t;
long long s[10000],ans;//ans是方案总数
int main(){
	int n=read(),k=read(),p=read();
	for(int i=1;i<=n;i++){
		color[i]=read();
		if(read()<=p){
			for(int j=i;j>t;j--)
				s[color[j]]++;
			t=i;//更新小于p的客栈
			ans+=s[color[i]]-1;
		}
		else
			ans+=s[color[i]];
	}
	printf("%lld\n",ans);
	return 0;
}
```
代码时间复杂度为 $O(n)$ ，对于这道题来说绰绰有余。

---

## 作者：vеctorwyx (赞：0)

## 前排提示：请仔细看一下数据范围！！！

建议先完成[弱化版](https://www.luogu.com.cn/problem/P1311)

### 1.手玩：

可以得到一个简单的规律：

__如果相邻的两个同颜色的客栈$a_i,a_j$可以组成一对合法组合，则可以拓展到$a_l,a_k(1\le l \le i<j\le k\le n)$合法（跨越合法区间$a_i,a_j$）__

当然以上思路一般把一个点视为定点，便于计算。

### 2.思路

产生两种思路~~爆搜~~：

1. 记录前后缀和，然后每次比交同颜色相邻的两个客栈并拓展到全部。

	（后来被hack了，因为会少记录一些无法拓展到全部的情况）
    
2. 枚举两个客栈中靠后的那个，然后找到他前面的最大的合法的客栈，拓展到开头，用一个前缀和维护一下就行。

两种方法时间复杂度均为$O(n)$

### 3.code：

	```
    #include "iostream"
    #include "cstdio"
    #include "cstring"
    #define fo(i, j, k) for(int i = j ; i <= k ; i++)
    #define go(i, j, k) for(int i = j ; i >= k ; i--)
    #define rd(i) i = read()
    #define out(i) printf("%lld",i)
    #define ou printf(" ")
    #define enl puts("")
    #define int long long
    using namespace std;
    int read()
    {
        int xsef = 0,yagx = 1;char cejt = getchar();
        while(cejt < '0'||cejt > '9'){if(cejt == '-')yagx = -1;cejt = getchar();}
        while(cejt >= '0'&&cejt <= '9'){xsef = (xsef << 1) + (xsef << 3) + cejt - '0';cejt = getchar();}
        return xsef * yagx;
    }
    int n, k, p;
    int a[2000010], b[2000010];
    int pre[2000010], la[10010], pr[10010], nxt[2000010];//pre为前缀和，la记录上一个客栈的位置，pr为从左往右每种颜色第一个客栈，nxt为下一个同色客栈
    int ans;
    signed main(){
    //	freopen("hotel17.in","r",stdin);
        rd(n), rd(k), rd(p);
        fo(i, 1, n){
            rd(a[i]),rd(b[i]);
                pre[i] = pre[la[a[i]]] + 1;//前缀和 
                nxt[la[a[i]]] = i;
                if(la[a[i]] == 0)
                pr[a[i]] = i;
                la[a[i]] = i;
        }
            int flag = 0;
            fo(j, 1, n){
                if(b[j] <= p)
                    pr[a[j]] = j,flag = j;//记录上一个可以去的咖啡店
                while(nxt[pr[a[j]]] <= flag && nxt[pr[a[j]]] != 0)//后跳指针
                    pr[a[j]] = nxt[pr[a[j]]];
                if(flag >= pr[a[j]])
                    ans += pre[pr[a[j]]] - (pr[a[j]]== j);//防止单个客栈被计算贡献
        }
        out(ans);
        return 0;
    }
    
   ```


---

## 作者：Anita_Hailey (赞：0)

# [选择客栈](https://www.luogu.com.cn/problem/P6032)

喜提最劣解。

考虑对于每一种颜色分别计算答案。对于同一颜色的客栈，从前到后用 `vector` 存下，而后我们可以用尺取法计算答案，因为这个很明显是满足单调性的。具体做法是，考虑在队列中添加一个客栈，那么，我们只要统计这一段区间中的 rmq 即可，具体的，我们可以用猫树或者线段树来维护。

这道题的做法就很显然了。

- 对于这个序列建立 rmq （st表或者线段树或者猫树皆可。
- 而后对于每种颜色分别运用尺取法统计答案即可，同时当前区间的 rmq 可以用 `multiset` 维护。

用猫树或者st表实现的话复杂度是 $O(n\log n)$， 我用的线段树，复杂度是 $O(n\log^2n)$ 不过够用了。

```c++
namespace Solution
{
 const int N = 2040001, INF = 0x3f3f3f3f;
 int n, k, p, a[ N ], b[ N ];
 long long ans;
 vector < int > pos[ 10000 ];
 std::multiset < int > s;
 struct Node
 {
  int l, r, mn;
 }elvahs[ N * 4 ];
#define l( i ) elvahs[ i ].l
#define r( i ) elvahs[ i ].r
#define mn( i ) elvahs[ i ].mn
 inline int ls( int k ) { return k << 1; }
 inline int rs( int k ) { return k << 1 | 1; }
 inline void Up( int k ) { mn( k ) = std::min( mn( ls( k ) ), mn( rs( k ) ) ); }
 void Build( int k, int l, int r )
 {
  l( k ) = l;
  r( k ) = r;
  if( l == r )
  {
   mn( k ) = b[ l ];
   return;
  }
  int mid = l + r >> 1;
  Build( ls( k ), l, mid );
  Build( rs( k ), mid + 1, r );
  return Up( k );
 }
 int Query( int k, int l, int r )
 {
  if( l <= l( k ) && r( k ) <= r )
   return mn( k );
  int mid = l( k ) + r( k ) >> 1, res = INF;
  if( l <= mid )
   res = std::min( res, Query( ls( k ), l, r ) );
  if( mid < r )
   res = std::min( res, Query( rs( k ), l, r ) ); 
  return res;
 }
 void Fakemain( )
 {
  n = rdi( ), k = rdi( ), p = rdi( );
  For( i, 1, n )
   pos[ a[ i ] = rdi( ) ].push_back( i ), b[ i ] = rdi( );
  Build( 1, 1, n );
  For( i, 0, k - 1 )
  {
   int hd = 0, tl = -1;
   for( ; tl < ( int ) pos[ i ].size( ) - 1; )
   {
    if( tl != -1 )
     s.insert( pos[ i ][ tl ] + 1 == pos[ i ][ tl + 1 ] ? INF : Query( 1, pos[ i ][ tl ] + 1, pos[ i ][ tl + 1 ] - 1 ) );
    s.insert( b[ pos[ i ][ ++tl ] ] );
    while( !s.empty( ) && *s.begin( ) <= p && hd < tl )
    {
     ans += ( int ) pos[ i ].size( ) - tl;
     s.erase( s.find( pos[ i ][ hd ] + 1 == pos[ i ][ hd + 1 ] ? INF : Query( 1, pos[ i ][ hd ] + 1, pos[ i ][ hd + 1 ] - 1 ) ) );
     s.erase( s.find( b[ pos[ i ][ hd++ ] ] ) );
    }
   }
   s.clear( );
  }
  ptl( ans );
  return;
 }

} // namespace Solution
```

 



---


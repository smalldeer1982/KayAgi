# 「Stoi2031」枫

## 题目背景

> 缓缓飘落的枫叶像思念 为何挽回要赶在冬天来之前 爱你穿越时间 两行来自秋末的眼泪 让爱渗透了地面 我要的只是你在我身边 ——《枫》

## 题目描述

冬很喜欢枫叶。她家门前有一棵枫树，树上落下了 $n$ 片叶子。冬将它们编号为 $1$ 到 $n$。她希望这些枫叶不要这样被人踩碎后烂在地里，所以决定把它们捡起来。她称将剩余未捡起来的枫叶按编号从小到大或从大到小的顺序排序后，先捡起第一片枫叶，然后每隔 $k$ 片捡起一片称为一次 **挽回**。她会一直进行 **挽回**，第一次 **挽回** 从小到大，之后每次 **挽回** 的顺序都和上次不同（即上次从小到大这次就从大到小，反之亦然），直到最后一片枫叶也被捡起。她认为最后一片捡起的枫叶代表了 **思念**，能带来幸福。她希望获得更多的幸福，所以她会很多次地问你 $n$ 和 $k$ 取某两个值时她得到的 **思念** 的编号。

## 说明/提示

#### 简述版题意：

给定 $n,k$，对 $1,2,\dots,n$ 一直操作，每次操作交替从小到大或从大到小的顺序取走当前的第 $(k+1)x+1$ 个数（$x \in \mathbb{Z_{\ge 0}}$ 且 $(k+1)x+1$ 不超过剩余数总数），求最后一个取走的数的编号。多次询问。

#### 样例解释：

限于篇幅，只对样例 $2$ 作解释。

对于第 $2$ 行：

对于第一次询问，地上只有 $1$ 片枫叶，此即 **思念**。

对于第二次询问，冬第一次 **挽回** 时依次捡起了 $1,3$ 两片枫叶，转身后只剩下 $2$，即 **思念**。

对于第 $3$ 行：

对于第一次询问，冬第一次 **挽回** 时捡起了 $1$ 号枫叶，转身后剩下 $2$，即 **思念**。

对于第二次询问，冬第一次 **挽回** 时捡起了 $1,4$ 两片枫叶，第二次 **挽回** 捡起了 $3$，剩下 $2$，即 **思念**。

对于第三次询问，冬第一次捡起了 $1,4,7$，第二次捡起了 $6,2$，第三次捡起了 $3$，此时剩下 $5$，即 **思念**。

#### 数据范围：

**本题每个数据点（除第 $1$ 个外）输入数据除数据组数 $t$ 以及最后一行（第 $t+1$ 行）外与前一个数据点输入数据完全相同。各个数据点的数据范围及特殊限制如下。**

| Testdata No. | $q \le$ | $m \le$ | 特殊限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $2$ | $3$ | 为样例 $1$ | $3$ |
| $2$ | $3$ | $7$ | 为样例 $2$ | $7$ |
| $3$ | $7$ | $10$ | 为样例 $3$ | $3$ |
| $4$ | $10$ | $30$ | 无 | $3$ |
| $5$ | $30$ | $70$ | 无 | $7$ |
| $6$ | $70$ | $100$ | 无 | $7$ |
| $7$ | $100$ | $300$ | 无 | $7$ |
| $8$ | $300$ | $700$ | 无 | $10$ |
| $9$ | $700$ | $10^3$ | 无 | $3$ |
| $10$ | $10^3$ | $3 \times 10^3$ | 无 | $3$ |
| $11$ | $3 \times 10^3$ | $7 \times 10^3$ | 无 | $1$ |
| $12$ | $7 \times 10^3$ | $10^4$ | 无 | $13$ |
| $13$ | $10^4$ | $3 \times 10^4$ | 无 | $3$ |
| $14$ | $3 \times 10^4$ | $7 \times 10^4$ | 无 | $3$ |
| $15$ | $7 \times 10^4$ | $10^5$ | 无 | $10$ |
| $16$ | $10^5$ | $3 \times 10^5$ | 无 | $13$ |
| $17$ | $3 \times 10^5$ | $7 \times 10^5$ | 无 | $1$ |
| $18$ | $7 \times 10^5$ | $10^6$ | 无 | $3$ |

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
1
2 3 1 3
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
2
2 3 1 3
3 7 2 4 7
```

### 输出

```
1 2
2 2 5
```

## 样例 #3

### 输入

```
3
2 3 1 3
3 7 2 4 7
7 10 1 2 3 6 7 8 10
```

### 输出

```
1 2
2 2 5
1 2 2 3 4 6 6
```

# 题解

## 作者：fengwu (赞：14)

**简单之至的题解**

~~比楼上的简单，代码只有二十行。~~

首先看题的时候发现这个无法做到直接求。

因为数据范围好像有点超乎想象。

但是对于这种递推的题来说一般就是从小的往大的推。

那么我们递推的过程就是每一次挽回。

我们发现我们挽回一次之后问题就变成了一个子问题。

但是这个子问题的挽回顺序变了，我们只需要在递推的时候反过来就好了。

这个题又非常的善良给了我们当前这一行的最大值。

明显的暗示递推好吧~~~。

我们直接枚举当前的枫叶数量。

计算挽回一次之后还剩下多少。

用剩下的枫叶数目对应的答案，先翻转一下，在计算这个答案的位置之前拿走了多少叶子。

直接加上就是答案。

最后直接输出就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fxt(i,x,y) for(int i=(x);i<=(y);i++)
#define pyt(i,x,y) for(int i=(x);i>=(y);i--)
const int N=1e6+5;
int t,q,m,n,ans[N];
signed main(){
    scanf("%d",&t);
    fxt(k,1,t){
        scanf("%d%d",&q,&m);
        ans[1]=1;
        fxt(i,2,m){
            int las=i-(i-1)/(k+1)-1;
            int pos=las-ans[las]+1;
            ans[i]=pos+(pos-1)/k+1;
        }
        while(q--){
            scanf("%d",&n);
            printf("%d ",ans[n]);
        }
        printf("\n");
    }
}
```

---

## 作者：Lagerent (赞：5)

~~被这题折磨了一上午。~~

不难想到约瑟夫问题。再观察数据范围，显然模拟是一定会爆炸的，考虑递推。

考虑由**由当前状态挽回一次后的局面**递推**当前局面**的答案。

设当前局面的枫叶数为 $x$。一次挽回，我们拿走了第一片枫叶，接下来每隔 $k$ 片拿走一片，那我们挽回一次后剩下的叶子数就是 $last = x - 1 - \frac{x - 1}{k + 1}$。

设挽回一次后，**思念**的位置是 $y$。因为我们挽回了一次后，序列进行了翻转，所以在翻转之前，它的位置是 $pos = last - y + 1$。将它与当前状态进行比较，发现位置差的就是我们在挽回中，在 $pos$ 之前拿走的枫叶。那么我们在 $pos$ 之前拿走的枫叶数是 $1 + \frac{pos - 1}{k}$。那么**思念**在**当前局面**的位置就是 $pos + 1 + \frac{pos - 1}{k}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/udiqcnoj.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

那么以这样的方式，我们对于每一组 $m, k$，都递推出答案，最后 $O(1)$ 查询即可。

时间复杂度：$O(T \times (m + q))$。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
using namespace std;

const int N = 1000010;

int ans[N];

int main() {
	int T;
	scanf("%d", &T);
	rep(k, 1, T) {
		int q, m;
		scanf("%d%d", &q, &m);
		ans[1] = 1;
		rep(i, 2, m) {
			int last = i - 1 - (i - 1) / (k + 1);
			int pos = last - ans[last] + 1;
			ans[i] = pos + (pos - 1) / k + 1;
		}
		while(q -- ) {
			int x;
			scanf("%d", &x);
			printf("%d ", ans[x]);
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：VinstaG173 (赞：5)

非常简单的递推。

我们只要从进行一次 **挽回** 后剩下的枫叶数对应的 **思念** 逆推回来就行了。建立 **挽回** 之后逆向重新编号的值到原编号值的关系。计算即可。

时间复杂度 $O(\sum (m+q))$。

Code:
```cpp
#include<cstdio>
#define rg register
inline char rc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
void print(int x)
{
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
int t,q,m,n,k;
int a[1000003];
int main()
{
	t=read();
	for(rg int i=1;i<=t;++i)
	{
		q=read(),m=read(),k=i+1;
		for(rg int j=1;j<k;++j)a[j]=(j>>1)+1;
		for(rg int j=k,t=1,x;j<=m;j+=k,++t)
		{
			x=j-t+1-a[j-t];
			a[j]=x+(x+i-1)/i;
			for(rg int d=1;d<k&&j+d<=m;++d)
			{
				x=j-t+d-a[j-t+d-1];
				a[j+d]=x+(x+i-1)/i;
			}
		}
		while(q--)
		{
			n=read();
			print(a[n]),putchar(q?' ':'\n');
		}
	}
	return 0;
}
```

---

## 作者：TempestMiku (赞：1)

简单的递推题。

![图](https://cdn.luogu.com.cn/upload/image_hosting/9wltp3u5.png)

如图，这是我们的操作顺序，那么我们直接从最终状态倒着推回去即可。

设当前有 $i$ 个数，那么上次操作就有 $i-(\lfloor\frac{i-1}{k+1}\rfloor+1)$ 个。因为要倒序所以上次的答案位置要反一下，再将 $pos$ 之前加上这次操作被删掉的数即可。注意一下这里要除以 $k$ ，也很容易理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/94wmj9ep.png)

我们每 $k+1$ 个数选一个，所以往回添加的操作变成每 $k$ 个数加一个，对 $pos-1$ 操作之后在加上第一个数 $1$ 就行。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace Testify{
    inline int read(){
        int f(1),x(0);
        char ch=getchar();
        for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
        for(;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
        return f*x;
    }
    inline void Write(int x){
        if(x>9) Write(x/10);
        putchar(x%10+48);
    }
    inline void write(int x){
        if(x<0) putchar('-'),x=-x;
        Write(x);
        putchar('\n');
    }
}
using namespace Testify;
int BAOLING=0,k;
int n,m,Tempestissimo(0),T,q,op;
const int N=8e5+5;
int ans[N];
signed main(void){
    ans[1]=1;
    T=read();
    while(T--){
        q=read(),m=read();
        k=++BAOLING;
        for(register int i=2;i<=m;i++){
            int lastnum=i-((i-1)/(k+1)+1);
            int pos=lastnum-ans[lastnum]+1;
            ans[i]=(pos+((pos-1)/(k)+1));
        }
        while(q--){
            Write(ans[read()]),putchar(' ');
        }
        puts("");
    }
    return 0;
}
```


---

## 作者：mahaorui2012 (赞：0)

# 思路 

因每次询问 $k$ 值固定，在下文中将 $k$ 视为定值。 

不难看出，$i$ 个树叶的挽回的结果只与 $ i-\lceil \frac{i}{k+1}\rceil$ 个树叶的反向挽回结果有关，即无后效性，考虑使用dp。

## 状态

$f_{i,0}$ 表示第 $i$ 片树叶正向挽回的结果， $f_{i,1}$ 表示第 $i$ 片树叶反向挽回的结果。

## 初始状态 

$$f_{1,0}=f_{1,1}=1$$

一片树叶就不用挽回了。

## 转移方程

设

$$p=f_{ i-\lceil \frac{i}{k+1}\rceil ,1}$$ 

则有： 

$$f_{i,0}=p+\lceil \frac{p-1}{k}\rceil$$

$$f_{i,1}=i-(p+\lceil \frac{p-1}{k}\rceil)+1$$

$p$ 表示取走这一轮挽回的所有叶子后反向挽回后的思念的下标，$f_{i,0}$ 等于 $p$ 加上 $p$ 以前被取走的叶子数量，所以第一个转移方程成立。

第二个转移方程相当于将整个序列翻转后进行正向挽回。正向挽回思念为 $p+\lceil \frac{p-1}{k}\rceil$，将整个序列翻转回来后思念即为 $f_{i,1}=i-(p+\lceil \frac{p-1}{k}\rceil)+1$，故第二个转移方程成立。

# AC CODE
```C++
#include <iostream>
using namespace std;

int f[1000005][2];

int updv(int p,int q){
	return p/q+(bool)(p%q);
}

int main(){
	int t;
	cin>>t;
	for(int k=1;k<=t;++k){
		int q,m;
		cin>>q>>m;
		f[1][0]=f[1][1]=1;
		for(int i=2;i<=m;++i){
			int p=f[i-updv(i,k+1)][1];
			f[i][0]=p+updv(p,k);
			f[i][1]=i-(p+updv(p,k))+1;
		}
		while(q--){
			int n;
			cin>>n;
			cout<<f[n][0]<<' ';
		}cout<<'\n';
	}
	return 0;
} 
```

---

## 作者：Tastoya (赞：0)

### 题目大意
给定 $n,k$，对 $1,2,\dots,n$ 一直操作，每次操作交替从小到大或从大到小的顺序取走当前的第 $(k+1)x +1$ 个数（$x\in \mathbb{N}^+$ 且 $(k+1)x +1$ 不超过剩余数总数），求最后一个取走的数的编号。多次询问。
### 思路
记 $f_n$ 为有 $n$ 个数时的答案。

假设我们现在有 $n$ 个数，第一片枫叶我们暂且不看，剩下的枫叶我们是每 $k+1$ 个拿 $1$ 个，所以第一轮总共拿了 $\frac{n-1}{k+1}+1$ 个，那么剩下的就是 $last=n - 1 - \frac{n-1}{k+1}$。

设现在的局面是挽回了第一次之后，倒着去挽回的情况，相当于剩下的序列进行了反转。

设当前局面的思念位置为 $x$，那么反转之前的局面时，这个思念的位置为 $pos = last - x + 1$。

它和之前的状态的位置差的是在 $pos$ 之前拿走的枫叶数量，又因为我们在 $pos$ 之前拿走的枫叶数量为 $1+\frac{pos-1}{k}$，那么这个思念在当前局面的位置为 $pos + 1+\frac{pos-1}{k}$。

这样我们可以递推预处理，然后查询。
### Code
```cpp
#include <bits/stdc++.h>

using namespace std;

int T,n,q,m,k;

int ans[1005000];

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    cin >> T;

    for(int t = 1;t <= T; t++) {
        cin >> q >> m;
        k = t;

        ans[1] = 1;

        int last,pos;
        for(int i = 2;i <= m; i++) {
            last = i - (i - 1) / (k + 1) - 1;
            pos = last - ans[last] + 1;
            ans[i] = pos + (pos - 1) / k + 1;
        }

        for(int i = 1;i <= q; i++) {
            cin >> n;
            std::cout << ans[n] << " ";
        }

        std::cout << "\n";
    }

    return 0;
}
```

---

## 作者：User_Authorized (赞：0)

## 题意
给定两个正整数 $n, k$，将 $n$ 个元素排成一个序列并按 $1 \rightarrow n$ 编号，每次轮流从前 / 后开始每隔 $k$ 个未删除元素删除一个元素，求最终剩余的一个元素的编号。

## 题解

**[更好的阅读体验](https://www.cnblogs.com/User-Unauthorized/p/solution-P7485.html)**

因为 $k$ 的取值很少，考虑对于每个 $k$ 进行递推。

在已钦定 $k$ 取值的情况下，设 $f_n$ 为对应的答案。

首先对于初始值，有 $f_1 = 1$。对于 $n > 1$，考虑有 $k \ge 1$，所以执行完第一轮删除之后一定有剩余元素，并且删除完成后元素个数一定会减少，所以可以利用小序列的答案更新出大序列的答案。设 $x = n - \left\lceil\dfrac{n}{k + 1}\right\rceil$ 即长度为 $n$ 的序列经过第一轮删除之后剩余的元素数量。设 $b = x + 1 - f_x$，即最终答案是经过第一轮删除后的第几个元素，那么有转移

$$f_n = b + \left\lceil\dfrac{b}{k}\right\rceil$$

后面加上的数是补上在删除后第 $b$ 个元素前被删除的元素数量。

总复杂度 $\mathcal{O}(nk)$，可以通过本题。

## Code

```cpp
#include <bits/stdc++.h>

typedef int valueType;
typedef std::vector<valueType> ValueVector;

constexpr valueType V = 1e6 + 5;

std::array<valueType, V> F;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    valueType T;

    std::cin >> T;

    std::stringstream str;

    for (valueType k = 1; k <= T; ++k) {
        valueType Q, M;

        std::cin >> Q >> M;

        F[1] = 1;

        for (valueType i = 2; i <= M; ++i) {
            valueType const from = i - (i + k) / (k + 1);
            valueType const x = from + 1 - F[from];
            F[i] = x + (x + k - 1) / (k);
        }

        for (valueType i = 0; i < Q; ++i) {
            valueType x;

            std::cin >> x;

            str << F[x] << ' ';
        }

        str << '\n';
    }

    std::cout << str.str() << std::flush;

    return 0;
}
```

---

## 作者：Flandres (赞：0)

简单的 dp。

定义 $f_i$ 为有 $i$ 个数时最后一个取走的数的编号。

显然初始有 $f_1=1$。

把当前的 $i$ 个数筛掉第一轮后还剩下的数字重新编号，存放在数组 $a$ 中，假设还有 $j$ 个。

$f_i$ 的信息就可以直接由 $f_j$ 得到。

因为前一次找的顺序和后一次相反，所以下标反一下就行。

每次询问从前往后扫一遍，单次复杂度是 $\mathcal O(m+q)$。

code:

```
#include<bits/stdc++.h>
constexpr int N(1e6);
int T,q,m,k;
int v[N+5],f[N+5];
int main(){
	std::cin.tie(nullptr)->sync_with_stdio(false);
	std::cin>>T;
	while(T--){
		std::cin>>q>>m;
		k++;f[1]=1;*v=0;
		for(int i=2;i<=m;++i){
			if((i-1)%(k+1))v[++*v]=i;
			f[i]=v[*v-f[*v]+1];
		}
		for(int i=1,x;i<=q;++i){
			std::cin>>x;
			std::cout<<f[x]<<' ';
		}
		std::cout<<'\n';
	}
	return 0;
}
```


---

## 作者：Hanzelic (赞：0)

## [题目链接](https://www.luogu.com.cn/problem/P7485)
还是递推的能力不太行。   

题目已经给出了每一次的最大值 $m$，那么我们就可以考虑直接把所有情况递推出来，最后直接 $O(1)$ 回答。  

我们假设枫叶数为 $n$ ，那么这一次会捡 $\frac{n-1}{k+1}+1$ 个枫叶，那么我们通过捡完后的枫叶数量的答案来递推得出当前的答案。我们设当前共有 $last=n-\frac{n-1}{k+1}-1$ 个枫叶，枫叶数量为 $last$ 的位置为 $ans[last]$，由于我们要反转，所以我们设 $now=last-ans[last]+1$，即这个答案反转后的位置。 

捡完后的位置已经求出来了，那么我们只要求出它在 $n$ 中的位置就行了，对此我们能够直接通过递推来得到答案。

设 $now$ 在原序列中的位置是 $past$，那么我们可以得到 $past-\frac{past-1}{k+1}-1=now$，最终得到 $past=now+\frac{now-1}{k}+1$，最后逐个递推即可。  

下面是代码，里面的 $k$ 是上文所说的 $k+1$，注意不要被混淆了。
```cpp
#include<bits/stdc++.h>
#define M 1000005
using namespace std;
int n,m,a,b,c,T;
int ans[M];
int main(){
	scanf("%d",&T);
	for(int q=1;q<=T;q++){
		int k=q+1;
		scanf("%d%d",&n,&m);
		ans[1]=1;
		for(int i=2;i<=m;i++){
			int last=i-(i-1)/k-1;
			int now=last-ans[last]+1;
			ans[i]=now+(now-1)/(k-1)+1;
		}
		for(int i=1;i<=n;i++){
			scanf("%d",&a);
			printf("%d ",ans[a]);
		}
		printf("\n");
	}
	return 0;
}
```


---


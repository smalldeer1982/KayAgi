# 『FLA - I』云音泛

## 题目背景

“……这些年来，过得可好？”

“……无所谓好或不好，人生一场空虚大梦，韶华白首，不过转瞬。惟有天道恒在，往复循环，不曾更改...”

## 题目描述

在梦中，秋种下了 $n$ 朵凋零玫瑰。他记得，第 $i$ 朵玫瑰是在时刻 $t_i$ 种植的。

凋零玫瑰在被种下的那个时刻就立即开放，但每一株玫瑰只会开放 $m$ 个时刻（在时刻 $T$ 种植的玫瑰会且仅会在从时刻 $T$ 到时刻 $T+m-1$ 的 $m$ 个时刻开放），在 $m$ 个时刻后便化作再也无法挽留的灰尘，飘散在凛冽的寒风中。

他问你，假如他可以改变不超过一朵玫瑰的种植时间（选定一个 $t_i$ 并将其修改为任意正整数），那么最多有多少个时刻有且仅有一株凋零玫瑰开放？

## 说明/提示

**「样例解释 #1」**

如图，使用金色标记有且仅有一株凋零玫瑰开放的时刻，使用黑色和红色标记每朵凋零玫瑰开放的时刻。

![example1](https://cdn.luogu.com.cn/upload/image_hosting/1u42cn1k.png)

将使用红色标记的玫瑰的种植时刻改为 $17$（将 $t_1$ 的值修改为 $17$，如下图）后有 $14$ 个时刻有且仅有一株凋零玫瑰开放。可以证明不存在能够使有且仅有一株凋零玫瑰开放的时刻数量大于 $14$ 的修改方案。

![example2](https://cdn.luogu.com.cn/upload/image_hosting/ig0pgy5w.png)

**「数据范围」**

|测试点编号|$n \leq$|$m \leq$|$t_i \leq$|
|:-:|:-:|:-:|:-:|
|$1 \sim 6$|$5000$|$5000$|$5000$|
|$7 \sim 12$|$2 \times 10^5$|$2 \times 10^5$|$2 \times 10^5$|
|$13 \sim 14$|$2 \times 10^5$|$1$|$10^9$|
|$15 \sim 20$|$2 \times10^5$|$10^9$|$10^9$|

对于所有测试数据，$1 \leq n \leq 2 \times 10^5$，$1 \leq m,t_i \leq 10^9$。

## 样例 #1

### 输入

```
5 4
11 9 1 3 12
```

### 输出

```
14
```

## 样例 #2

### 输入

```
13 7
6 42 58 41 20 60 2 61 45 28 45 28 12
```

### 输出

```
38
```

# 题解

## 作者：ScaredQiu (赞：34)

### 差分、前缀和、队列

你说得对，但是离散化是超纲的。

珍惜身边人。

-----------

#### 测试点 $1 \sim 6$

**由于要最大化只有一株玫瑰开放的时刻数量，修改一株玫瑰的种植时间时只可能将其移动到一段没有其他玫瑰开放的时刻。这等价于直接删除这株玫瑰并将只有一株玫瑰开放的时刻数量增加 $m$。**

枚举要删除哪一株玫瑰，然后使用差分和前缀和计算出将其删除后只有一株玫瑰开放的时刻数量。

由于 $t_i$ 与 $m$ 同阶，时间复杂度 $O(nm)$。

#### 测试点 $7 \sim 12$

考虑修改第 $i$ 株玫瑰的种植时间对答案产生的影响：答案变为不进行修改时只有一株玫瑰开放的时刻数量，减去不进行修改时有且仅有第 $i$ 株玫瑰开放的时刻数量，加上不进行修改时有且仅有第 $i$ 株玫瑰和另外一株玫瑰**共两株**玫瑰开放的时刻数量，然后加上 $m$。

那么只需处理**不进行修改时只有一株玫瑰开放的时刻数量**，**不进行修改时有且仅有第 $i$ 株玫瑰开放的时刻数量**和**不进行修改时有且仅有第 $i$ 株玫瑰和另外一株玫瑰共两株玫瑰开放的时刻数量**这三个信息。它们的计算可以用前缀和与差分轻松完成。

时间复杂度 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int lim=400'000;
int n,m,ans,l[200'005],r[200'005],sum[400'005],sum1[400'005],sum2[400'005];
inline int w(int l,int r,int *s){return s[r]-s[l-1];}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>l[i],r[i]=l[i]+m-1;
    for(int i=1;i<=n;i++) ++sum[l[i]],--sum[r[i]+1];
    for(int i=1;i<=lim;i++) sum[i]+=sum[i-1];
    for(int i=1;i<=lim;i++) sum1[i]=sum1[i-1]+(sum[i]==1),sum2[i]=sum2[i-1]+(sum[i]==2);
    for(int i=1;i<=n;i++) ans=max(ans,sum1[lim]-w(l[i],r[i],sum1)+w(l[i],r[i],sum2)+m);
    cout<<ans<<'\n';
    return 0;
}
```

#### 测试点 $13 \sim 14$

由于 $m=1$ 只需要判断**是否存在恰好有两株玫瑰开放的时刻**和**是否存在三株或更多株玫瑰开放的时刻**。这可以用 `map` 或者别的什么轻松解决。

如果有恰好有两株玫瑰开放的时刻，答案就是不进行任何修改时只有一株玫瑰开放的时刻数量加 $2$；否则如果有三株或更多株玫瑰开放的时刻，答案就是不进行任何修改时只有一株玫瑰开放的时刻数量加 $1$；否则答案就是不进行任何修改时只有一株玫瑰开放的时刻数量。

由于 `map` 在提高组大纲（基础赛允许使用 STL 所以我照样能用，但是我决定严谨一些），这里说明一下如何不超纲地判定。首先对 $t$ 进行排序，如果 $t_i \neq t_{i-1}$ 且 $t_i = t_{i+1}$ 且 $t_{i+1} \neq t_{i+2}$ 则存在恰好有两个玫瑰开放的时刻；如果 $t_i \neq t_{i-1}$ 且 $t_i = t_{i+1} =t_{i+2}$ 则存在有三株或更多株玫瑰开放的时刻。

时间复杂度 $O(n \log n)$。

#### 测试点 $15 \sim 20$

由于每一朵玫瑰都只会开放 $m$ 个时刻，所以越早被种下的玫瑰消失越早。先进先出，考虑使用队列维护。具体地，将每一株玫瑰被种下和消失的时间记录在一个序列中，然后对其进行排序、去重，得到一个由全部有玫瑰产生或者消失的时刻组成的序列。

遍历这个序列，维护当前被种下且未消散的玫瑰编号，然后统计有且仅有第 $i$ 株玫瑰开放的时刻数量和有且仅有第 $i$ 株玫瑰和另外 $1$ 株玫瑰共 $2$ 株玫瑰开放的时刻数量。最后枚举删除的玫瑰并计算答案。

**注意答案可以达到 $3 \times 10^9$，会爆 `int`，获得 $95$ 分很可能是这个原因导致的。**

时间复杂度 $O(n \log n)$，瓶颈在排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,pos,t[200'005],p[400'005],w[2][200'005];
long long ans,sum;
queue<int> q;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>t[i];
    for(int i=1;i<=n;i++) p[++cnt]=t[i],p[++cnt]=t[i]+m;
    sort(t+1,t+n+1),sort(p+1,p+cnt+1);
    cnt=unique(p+1,p+cnt+1)-p-1;
    for(int i=1;i<=cnt;i++){
        while(!q.empty()&&t[q.front()]+m<=p[i]) q.pop();
        while(pos+1<=n&&t[pos+1]<=p[i]) q.push(++pos);
        if(q.size()==1) w[0][q.front()]+=p[i+1]-p[i],sum+=p[i+1]-p[i];
        if(q.size()==2) w[1][q.front()]+=p[i+1]-p[i],w[1][q.back()]+=p[i+1]-p[i];
    }
    for(int i=1;i<=n;i++) ans=max(ans,sum-w[0][i]+w[1][i]+m);
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：ycy1124 (赞：17)

### 题意
有 $n$ 朵玫瑰，每朵玫瑰都有一个种植时间 $t_i$，当一朵玫瑰被种下后，它会持续开放 $m$ 秒，现在问你，假如你能改变一朵花的开放时间，最多有多少个时间只有 $1$ 朵玫瑰开放。
### 想法
我们不难知道每朵花的开放是对前面的时间段没有影响的。所以，我们可以递推求出假如不改变花朵开放时间的答案。现在考虑改变花朵。假如我们要改变一朵花的开放时间，那么最好的方案一定是将它的时间调到 $inf$ 或者 $-inf$ （$inf$ 为一个极大值），我们并不需要考虑 $inf$ 这个值是多少，只需要考虑改变后所带来的影响。假如改变了一朵花的开放时间，那么只会对它前面或者后面的花造成影响，所以我们只需要重新计算受到影响的那个值，在原有的答案上面做出改变就行了。
### 做法
先统计一遍不改变的 $ans$。然后枚举改变的花并且统计影响，最后对这些改变后的 $ans$ 取一个最大值并输出就行了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t[200002];
int main(){
	long long n,m;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&t[i]);
	}
	sort(t+1,t+n+1);
	t[0]=-m-10000;
	t[n+1]=t[n]+m+10000;
	//cout<<t[1];
	long long int ans=0;
	long long js=0,bj;
	for(int i=1;i<=n;i++){//统计不改变时的答案。
		int w=0;
		w=min(t[i+1]-t[i],m);
		long long a=0;
		w-=min(max(m-(t[i]-t[i-1]),a),min(t[i+1]-t[i],m));
		ans+=w;
	}
	long long int out=0;
	for(int i=1;i<=n;i++){//枚举改变哪朵花。
		js=ans+m;
		int w=0;
		w=min(t[i+1]-t[i],m);
		long long a=0;
		w-=min(max(m-(t[i]-t[i-1]),a),min(t[i+1]-t[i],m));
		js-=w;
		if(i!=n){
			w=0;
			w=min(t[i+2]-t[i+1],m);
			w-=min(max(m-(t[i+1]-t[i]),a),min(t[i+2]-t[i+1],m));
			js-=w;
		}
		if(i!=1){
			w=0;
			w=min(t[i]-t[i-1],m);
			w-=min(max(m-(t[i-1]-t[i-2]),a),min(t[i]-t[i-1],m));
			js-=w;
		}
		if(i!=1){
			w=0;
			w=min(t[i+1]-t[i-1],m);
			w-=min(max(m-(t[i-1]-t[i-2]),a),min(t[i+1]-t[i-1],m));
			js+=w;
		}
		if(i!=n){
			w=0;
			w=min(t[i+2]-t[i+1],m);
			w-=min(max(m-(t[i+1]-t[i-1]),a),min(t[i+2]-t[i+1],m));
			js+=w; 
		}
		out=max(js,out);//取 max。
	}
	cout<<out;
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/170372585)。

---

## 作者：Asedwai (赞：16)

## 思路
  如果要对于每一株玫瑰转移求答案，我们先要想到若不改变玫瑰的种植时间，有多少个时刻有且仅有一株凋零玫瑰开放。先将时间排序，思考对于 $t_i$，会贡献多少单独时刻出来。明显盖到 $t_i$ 的会有左右两部分。  
  
  我们把原时间抽象为线段，记线段的起点为 $l_i=t_i$，终点为 $r_i=t_i+m$。要求变为只有一条线段覆盖的点数。由于 $l_i$ 经过排序后单调递增，所以 $r_i$ 也会单调递增，对盖住左边部分影响最大的只会是线段 $i-1$。同理对于右边部分影响最大的是线段 $i+1$。而其它的对 $t_i$ 的影响会被包括在这两者之中，或者是无影响。则第 $i$ 条线段中只被覆盖一条线段的会有以下性质：   
  
  1. 左端为 $\max(r_{i-1},l_i)$。
  2. 右端为 $\min(l_{i+1},r_i)$。

  这样两端相减我们就可以算出线段 $i$ 的贡献值 $f_i$（负数时要改为 $0$），有总贡献值 $sum=\sum_{i=1}^n f_i$。  
___
  现在我们来思考转移线段 $i$ 会对总贡献最多改变多少。我们肯定会转移到无穷大的位置，使本身的贡献变成 $m$，对总贡献造增加 $m-f_i$。由于转移之后会有一些点的线段覆盖数变为 $1$，所以我们需要加上一部分值。而这部分原先的线段覆盖数肯定为 $2$，这一部分只会出现在某一线段的两端。  

  先考虑线段的左端。 
  ![](https://cdn.luogu.com.cn/upload/image_hosting/3nx56r0e.png)

  从图中可以看出线段覆盖数为 $2$ 的区间的左端为 $r_{i-2}$，右端为 $l_{i+1}$。事实上这只是一种极端的情况，如果没有线段 $i-2$ 或者 $r_{i-2} \lt l_i$，线段的左端就为 $l_i$。同样的线段右端也可能为 $r_{i-1}$。  

  而通过观察可以发现对于线段 $i$ 的右端中满足条件的区间。实际上就是线段 $i+1$ 的左端中满足条件的区间。这样我们就可以统计出对于线段 $i$ 有多少线段覆盖数为 $2$ 的点数 $c_i$ 了。  

  回到原先的问题，那么转移线段 $i$ 的最大贡献值就为 $sum+m-f_i+c_i$，对于每个 $i$ 求最大值即可。  
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
//#define endl "\n"
#define fer(i, a, b) for(int i = (a); i <= (b); i ++)
#define LL long long
const auto Maxn = (LL) 2e5 + 10;
int n; 
LL m; 
struct node {
	LL l, r; 
} a[Maxn]; 
LL f[Maxn], cover[Maxn]; 
LL ans, sum; 
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr); 
	cin >> n >> m; 
	fer(i, 1, n) cin >> a[i].l, a[i].r = a[i].l + m; 
	sort(a + 1, a + n + 1, [](node a, node b) { return a.l < b.l; }); 
	a[0].r = LONG_LONG_MIN; 
	a[n + 1].l = LONG_LONG_MAX;
	fer(i, 1, n) {
		f[i] = max(0ll, min(a[i].r, a[i + 1].l) - max(a[i].l, a[i - 1].r)); 
		sum += f[i]; 
		if(a[i - 1].r >= a[i].l) {
			cover[i] += max(0ll, min(a[i + 1].l, a[i - 1].r) - max(a[i].l, i < 2 ? 0 : a[i - 2].r)); 
			cover[i - 1] += cover[i]; 
		}
	}
	fer(i, 1, n) {
		ans = max(ans, sum - f[i] + m + cover[i]); 
	}
	cout << max(sum, ans) << endl; 
	return 0; 
}
```

---

## 作者：shuqiang (赞：16)

考虑用贪心算法，显然可以把选择把 $t_i$ 改成一个较大值，所以这相当于删除这个玫瑰并把答案增加 $m$。

我们可以用一个估价变量表示选择一株玫瑰对答案的贡献，然后选择估价变量最大的玫瑰。估价变量是**玫瑰开放时有且仅有两株玫瑰开放的时刻 $+$ 玫瑰开放的时刻 $-$ 玫瑰开放时有且仅有一株玫瑰开放的时刻**。

设 $f(x,y)$ 为第 $x$ 个玫瑰和第 $y$ 个玫瑰同时开放的总时刻。

计算玫瑰开放时有且仅有一株玫瑰开放的时刻：

1. 输入完了后从小到大排序。
2. 先加上玫瑰开放的时刻 $m$。
3. 减去 $f(i-1,i)$。
4. 减去 $f(i,i+1)$。
5. 由于减掉的 $f(i-1,i)$ 和 $f(i,i+1)$ 中 $f(i-1,i+1)$ 重复减了两次，所以要加回 $f(i-1,i+1)$。

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/vxoxi2b3.png)

红色表示第 $i$ 个玫瑰的开放时间，蓝色表示第 $i-2$ 个、第 $i-1$ 个、第 $i+1$ 个玫瑰的开放时间，深绿色表示 $f(i-1,i+1)$，黄色表示 $f(i-2,i-1)$，浅绿色表示 $f(i-2,i+1)$。

可以看出计算玫瑰开放时有且仅有两株玫瑰开放的时刻的公式为：

$f(i-1,i)+f(i,i+1)-f(i-1,i+1) \times 2 - f(i-2,i)+f(i-2,i+1)-f(i,i+2)+f(i-1,i+2)$

AC 代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>

using namespace std;

const int N = 2 * 1e5 + 10;
int n, m, mx, mxn;
long long ans = 0;

struct line{
	int l, r;
	
	bool operator < (const line & o) const{
		return l < o.l;
	}
} a[N];


//f(x, y) 为第 x 个玫瑰和第 y 个玫瑰同时开放的总时刻。
int f(int x, int y){
	if(x < 0 || y < 0 || x >= n || y >= n) return 0;
	if(a[x].r >= a[y].l) return a[x].r - a[y].l + 1;
	return 0;
}

int main(){
	cin >> n >> m;
	for(int i = 0; i < n; i++){
		cin >> a[i].l;
		a[i].r = a[i].l + m - 1;
	}
	sort(a, a + n);
	for(int i = 0; i < n; i++){
		int tmp = 0;//tmp 为估价变量。 
		//玫瑰开放时有且仅有两株玫瑰开放的时刻。 
		tmp += f(i-1, i);
		tmp += f(i, i+1);
		tmp -= f(i-1, i+1)*2;
		tmp -= f(i-2, i);
		tmp += f(i-2, i+1);
		tmp -= f(i, i+2);
		tmp += f(i-1, i+2);
		
		//玫瑰开放时有且仅有一株玫瑰开放的时刻。 
		tmp += f(i-1, i);
		tmp += f(i, i+1);
		tmp -= f(i-1, i+1);
		
		//因为玫瑰开放的时刻是一个定值，所以可以不加。 
		
		if(tmp > mx) mx = tmp, mxn = i;
		
	}
	a[mxn].l = 2e9+1;
	a[mxn].r = 2e9+1;
	//把选择的花的开放时间改成一个较大值。 
	sort(a, a + n);
	ans = m;
	for(int i = 0; i < n-1; i++){
		//玫瑰开放时有且仅有一株玫瑰开放的时刻。
		ans += m;
		ans -= f(i-1, i);
		ans -= f(i, i+1);
		ans += f(i-1, i+1);
	}
	cout << ans;
    return 0;
}
```

---

## 作者：WsW_ (赞：14)

最近写离散化、差分、前缀和，导致人变傻了。看见这题就想离散化差分。  
但是我清楚地知道普及组大纲内的所有知识点，离散化在提高组大纲内。  
所以直接**模拟**和**贪心**，您不需要会其他任何算法就能看懂这篇题解。  

---
## 思路

先把问题转化一下，就是数轴上有 $n$ 条左端点为 $T_i$，长度为 $m$ 的线段，你可以移动其中任意 $1$ 条线段。问你只被覆盖过 $1$ 次的长度最长是多少。  

### 如何统计答案
我比较傻，所以先不考虑移动 $1$ 条线段如何统计答案。  
显然，**一条线段如果和其他线段重叠，只能是从左边或者从右边开始重叠，不可能从中间开花**，因为这些线段的长度都是 $m$。如下图所示。  
![](https://cdn.luogu.com.cn/upload/image_hosting/1468pkco.png)

再想一下，发现当 $T_i<T_j$ 时，线段 $i$ 和线段 $j$ 的重叠部分只有可能在线段 $i$ 的右边和线段 $j$ 的左边。  
既然重叠的位置和 $T_i$ 的大小有关，那就把 $T$ 从小到大排序一下。这样，所有在 $i$ 前面的线段只可能和 $i$ 的左边重叠；所有在 $i$ 后面的线段只可能和 $i$ 的右边重合。  

继续观察，发现如果 $i$ 的左边有线段和 $i$ 重合，那么重合部分最长的只能是 $i-1$；如果 $i$ 的右边有线段和 $i$ 重合，那么重合部分最长的只能是 $i+1$。如下图所示。  
![](https://cdn.luogu.com.cn/upload/image_hosting/prf8e9wv.png)  

我们把第 $i$ 条线段内只被覆盖过 $1$ 次的长度叫做**第 $i$ 条线段的贡献**，记作 $g(i)$。根据定义，**任何两条线段产生贡献的部分不会重叠**（因为重叠了就不是贡献了啊）。  
容易发现，**第 $i$ 条线段的贡献，只和它左边第一条、右边第一条这两条线段有关**。排序后，左边第一条和右边第一条分别为 $i-1,i+1$。  

假设有两条线段 $i,j(i<j)$ 重叠了，那么他们重叠的长度就是 $T_i+m-T_j$。这样我们就可以求出第 $i$ 条线段和第 $i-1,i+1$ 线段重叠的长度。  
根据第一幅图，除非第 $i$ 条线段被 $i-1,i+1$ 完全覆盖了，否则 $i-1,i+1$ 不会重叠。

假设某条线段不和任何线段重叠，那么它的贡献是 $m$。但是如果重叠 $l$ 个长度，那么贡献就变成了 $m-l$。  
任何线段的贡献都不可能是负数，所以当 $m-l<0$ 时，产生的贡献是 $0$。  

这样，对于每一条线段计算贡献的时间复杂度就是 $O(1)$。

遍历一下全部 $n$ 条线段，对每条线段分别计算贡献，再全部加起来即可。即 $ans=\sum g(i)$。  

### 如何考虑移动线段
接着再来考虑移动 $1$ 条线段会发生什么。  
假设我们移动的是第 $i$ 条线段，我们把移动分成两个部分：先把线段从数轴上拿下来，再把线段放回数轴。  

在统计答案的时候我们讲到，**第 $i$ 条线段的贡献，只和第 $i-1,i+1$ 两条线段有关**。所以移动后，只有第 $i-1,i,i+1$ 三条线段的贡献可能变化。  

先考虑移动对第 $i$ 条线段贡献产生的变化。
当我们把线段拿下来的时候，第 $i$ 条线段失去了原本的贡献 $g(i)$。  
放回去的时候，为了让它产生的贡献 $g'(i)$ 尽可能大，随便在找一个超级远、超级偏僻、没有其他线段的地方把它放下。  
因为它旁边没有别的线段，所以它会产生新的贡献 $g'(i)=m$。  

对于第 $i-1$ 条线段，它现在右边第一条线段变成了 $i+1$，左边第一条线段仍然是 $i-2$。重新对它计算贡献 $g'(i-1)$ 即可。  
对于第 $i+1$ 条线段，同上，重新计算贡献 $g'(i+1)$ 即可。  

这样一波操作下来，我们就在 $O(1)$ 的时间复杂度内知道了移动第 $i$ 条线段，可以让总贡献增加了 $add(i)=g'(i)+g'(i-1)+g'(i+1)-g(i)-g(i-1)-g(i+1)$。  
我们要让最终的总贡献最大，就是要让 $add(i)$ 最大。枚举 $i$ 找到最大的 $add(i)$ 即可。  

### 结果
最后的答案就是 $ans+\max(add(i))$。  
总时间复杂度是 $O(n\log n)$，瓶颈在于排序。  

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=2e5+5;

int n,m;
int t[MAXN];
int g[MAXN];
ll sum;
int mxadd;

int cov(int x,int y){//计算覆盖长度
	return max(0,t[x]+m-t[y]);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>t[i];
	}
	sort(t+1,t+1+n);
	t[0]=-1e9; t[n+1]=2e9+6;
	for(int i=1;i<=n;i++){
		int l=m;
		l-=cov(i-1,i);
		l-=cov(i,i+1);
		l=max(l,0);//计算贡献
		g[i]=l;
		sum+=l;
	}
	for(int i=2;i<n;i++){
		int add=m-g[i];//处理i
		
		int l=m;//处理i-1
		l-=cov(i-2,i-1);
		l-=cov(i-1,i+1);
		l=max(l,0);
		add+=l-g[i-1];
		
		l=m;//处理i+1
		l-=cov(i-1,i+1);
		l-=cov(i+1,i+2);
		l=max(l,0);
		add+=l-g[i+1];
    
		mxadd=max(mxadd,add);
	}
	cout<<sum+mxadd;
	return 0;
}
```

---

## 作者：PR_CYJ (赞：8)

# [题目传送门](https://www.luogu.com.cn/problem/P10837)
# 思路
先对 $t$ 数组按顺序排序，然后枚举每一朵凋零玫瑰，算出在它的开放时间内，有多长时间只有它一朵花开放，将算出来的这个数记作 $x$。然后将所有的 $x$ 求和，其和 $sum$ 就是不移动任何花时的答案。

然后考虑将移动一朵花开放时间后的答案。显然将其移动到一个不与任何花开放时间相交的地方更优（移动到 $2\times 10^9$）。那么就枚举每一朵凋零玫瑰，计算一下如果将它的开放时间移动到后面，能对答案产生多少贡献，将这个贡献记为 $y$。然后对所有的 $y$ 取最大值 $maxx$，再将 $maxx$ 加上 $sum$，就是最终答案了。

接下来就要想怎样求出 $x$ 和 $y$ 了。

**注意：下文中被花覆盖指在这朵花的开放时间内。**

由于对 $t$ 数组进行了排序，且所有的区间长度都是 $m$，所以所有区间右端点的位置一定是单调不降的。

然后开始求 $x$。设当前遍历到了第 $i$ 朵花。显然，一朵花独自开放的时间一定是连续的。所以考虑求出这个区间的左右端点（区间左闭右开）。因为这个区间既要在这朵花的开花时间内，又不能被第 $i-1$ 和第 $i+1$ 朵花的开花时间覆盖，所以其右端点为 $\min(t_i+m,t_{i+1})$，其左端点为 $\max(t_i,t_{i-1}+m)$。那么第 $i$ 朵花的 $x$ 就是 $\max(\min(t_i+m,t_{i+1})-\max(t_i,t_{i-1}+m),0)$ 了。（注意 $x$ 可能为负，所以要和 $0$ 取最大值）

计算完毕后对所有的 $x$ 求和，即可求出 $sum$。

接着求 $y$。将第 $i$ 朵花的开放时间移走后，它就新产生了 $m-x$ 的贡献。除此以外的新贡献一定在第 $i-1$ 和第 $i+1$ 朵花的开放时间上。（即原先只被第 $i-1$ 和第 $i$ 朵花覆盖或只被第 $i$ 和第 $i+1$ 朵花覆盖）那么就分别计算贡献。

1. 对于第 $i-1$ 朵花，其开花区间上新产生的贡献就是被第 $i$ 朵花覆盖，但不被第 $i-2$ 和第 $i+1$ 朵花覆盖的区间的长度（区间左闭右开），即为 $\max(\min(t_{i+1},t_{i-1}+m)-\max(t_i,t_{i-2}+m),0)$。
2. 对于第 $i+1$ 朵花，其开花区间上新产生的贡献就是被第 $i$ 朵花覆盖，但不被第 $i-1$ 和第 $i+2$ 朵花覆盖的区间的长度，即为 $\max(\min(t_i+m,t_{i+2})-\max(t_{i+1},t_{i-1}+m),0)$。
3. 最后还要加上 $m-x$，即为移走后这朵花自己新产生的贡献。

计算完毕后就可以对所有的 $y$ 取最大值，得出 $maxx$，最终 $sum+maxx$ 即为最终答案。

**注意 $sum$ 要开 `long long`。**
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=200010;
int n,m,maxx,a[N];
ll sum;//要开long long 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	stable_sort(a+1,a+n+1);
	a[0]=INT_MIN;
	a[n+1]=a[n+2]=a[n]+m;//要初始化a[0],a[n+1]和a[n+2]
	for(int i=1;i<=n;i++)
	{
		int t=max(min(a[i+1],a[i]+m)-max(a[i],a[i-1]+m),0),tt=0;
		sum+=t;
		if (a[i+1]<a[i]+m)
			tt=max(min(a[i]+m,a[i+2])-max(a[i+1],a[i-1]+m),0);
		if (a[i]<a[i-1]+m)
		{
			if (i!=1)//此处要特判，不然会数组越界 
				tt+=max(min(a[i+1],a[i-1]+m)-max(a[i],a[i-2]+m),0);
		}
		maxx=max(maxx,m-t+tt);
	}
	cout<<sum+maxx<<"\n";
}
```

---

## 作者：_EEA_ (赞：7)

### 转述题意

转述一下题意，大概就是说有一堆等长的区间，现在可以随便移动其中一个，问最多能使多长的部分有且只有一个区间覆盖到，即，问最多有多长的部分区间没有重叠。

### 朴素想法

为了使区间尽可能地不重叠，我们移动的那一个区间移动后自然是能与其他的区间不重叠的好；这也是肯定能做到的，因为题目没有限制区间移动的范围，我们只要把要移动的区间移得足够远就好。

这样，一个朴素得想法就是，分别考虑把每一个区间移得足够远后没有重叠的部分的长度，取其中的最大值就是答案。

至此，要解决的问题就是，如何快速地计算“把某一个区间移得足够远后没有重叠的部分的长度”。

### 解决问题

首先我想的是如何计算“某一个区间没有重叠的部分的长度”。

继续想，要分别考虑其他区间从前面覆盖和从后面覆盖两种情况，所以自然就考虑先排序，因为各区间等长，也少了很多诸如“按前端点排序还是按后端点排序”这类问题。

接着想，排序后其他区间中覆盖这个区间的从前面被覆盖的部分，覆盖得最多的肯定是排在这个区间的前一个区间，后面的同理。也就是说，排序后，某一个区间被其他区间覆盖的范围跟且只跟这个区间的前一个区间和后一个区间有关。所以我写了一个函数，用以快速地计算“某一个区间没有重叠的部分的长度”，暂时叫这个函数 $rangeX$ 吧。

进而，我们可以快速地计算“没有移动任何区间时没有重叠的部分的长度”，这个值我们记为 $ans$。显然有 $ans=\sum rangeX(i)$。

然后我想的才是如何计算“把某一个区间移得足够远后没有重叠的部分的长度”。有了前面的铺垫，这里往下也好想多了。真的分别考虑移动某一个区间至足够远后没有重叠的部分的长度显然至少要二重循环，平方复杂度，所以考虑优化。

继续想，把某一个区间移动得足够远后，没有重叠的部分大部分是没有变化的，变化的只是被移动的区间附近的那些部分。因此没有重叠的部分的长度可能会增加一个差值，我们要是能快速计算这个差值就好了，因为答案就是 $ans$ 加上这个差值。要求答案的最大值，就是求这个差值的最大值，记这个差值为 $del$。

接着想，移动某个区间至足够远后对没有重叠的部分的改变究竟如何让快速计算。首先就是这个区间原来被其他区间覆盖的部分不再被其他区间覆盖，成为了没有重叠的部分。这部分可以使用题目的 $m$ 减去 $rangeX(\text{这个区间})$得来。然后就是这个区间的前一个区间从后面被覆盖的那一部分不再被这个区间覆盖了，而是“继承到”被这个区间的后一个区间覆盖，这个区间的后一个区间同理。

前面说道，“排序后，某一个区间被其他区间覆盖的范围跟且只跟这个区间的前一个区间和后一个区间有关”，而现在移动某一个区间至足够远后，其前、后的区间被其他区间覆盖的范围跟新的区间有关了。但不论如何，都跟且只跟其他某两个区间有关，所以，我们不妨一般化函数 $rangeX$ 的意义为：
$$
rangeX(\text{某个区间},\text{名义上这个区间的前一个区间},\text{名义上这个区间的后一个区间})=\text{这个区间没有重叠的部分的长度}
$$
这样子后，移动某一个区间至足够远后，影响的再只是其前、后区间的“名义上这两个区间的前、后区间”，对其他区间没有影响。

综合考虑以上两部分的内容，可以很快利用 $rangeX$ 函数计算出 $del$。具体地：

若移动第 $i$ 个区间至足够远，则：

- 这个区间原来被其他区间覆盖的部分不再被其他区间覆盖，成为了没有重叠的部分，这部分为 $m - rangeX(i, i - 1, i + 1)$
- 这个区间的前一个区间原来被其他区间覆盖的部分为 $rangeX(i - 1, i - 2, i)$，移动后这个值变为 $rangeX(i - 1, i - 2, i + 1)$，差值 $rangeX(i - 1, i - 2, i + 1) - rangeX(i - 1, i - 2, i)$
- 这个区间的后一个区间的相关变化贡献的差值为 $rangeX(i + 1, i - 1, i + 2) - rangeX(i + 1, i, i + 2)$

所以：
$$
del = m - rangeX(i, i - 1, i + 1) + 
	rangeX(i - 1, i - 2, i + 1) - rangeX(i - 1, i - 2, i) + 
	rangeX(i + 1, i - 1, i + 2) - rangeX(i + 1, i, i + 2)
$$
特别地，要考虑 $i-1<1$、$i+1>n$ 等的细节，不过太细节了，可以自己解决。

### 编写代码

写之前再整理下总体思路：先计算原来的没有重叠的部分的长度，再分别考虑移动某一个区间至足够远后没有重叠的部分增加的长度，取最大值与原答案相加即为最终答案。

根据函数 $rangeX$ 的意义，可以实现为：

```cpp
int rangeX(int i, int l, int r){
	if(i < 1 || i > n) return 0;
	int res = 0;
	if(l >= 1 && r <= n && t[l] + m >= t[r]) return 0;
	if(l >= 1 && t[l] + m > t[i]) res += t[l] + m - t[i];
	if(r <= n && t[i] + m > t[r]) res += t[i] + m - t[r];
	return m - res;
}
```

这个函数的复杂度为 $O(1)$。

根据以上对算法过程的描述，可以实现为：

```cpp
#include <bits/stdc++.h>
#define int long long // 刚开始忘了开 long long，被迫偷懒

using namespace std;

const int N = 2e5+5;
int n, m;
int t[N];

// 这里省略了 rangeX 的实现

signed main(){
	int ans = 0, del = 0;
	
	cin >> n >> m;
	for(int i = 1; i <= n; ++i) cin >> t[i];
	
	sort(t + 1, t + n + 1);
	for(int i = 1; i <= n; ++i){
		ans += rangeX(i, i - 1, i + 1);
		del = max(del, m - rangeX(i, i - 1, i + 1) + 
	rangeX(i - 1, i - 2, i + 1) - rangeX(i - 1, i - 2, i) + 
	rangeX(i + 1, i - 1, i + 2) - rangeX(i + 1, i, i + 2));
	}
	
	cout << ans + del << endl;
	
    return 0;
}
```

总复杂度为 $O(n\log n)$，主要是排序部分贡献的复杂度。

- Update On 2024/8/5

  更正了一些笔误

---

## 作者：HHC883 (赞：6)

# 题目分析
考虑排序。容易发现，要修改一朵花的种植时间并使有且仅有一朵花开放的时刻最多，那么将种植时间修改为一个极大值（大于最后一朵花的凋零时间）肯定不劣。于是考虑删除一朵花，并将其放到最后面。所以，我们仅需枚举删除每朵花的贡献，取最大值即可。这很容易实现，由于排过序，且每朵花的开放时长相同，所以删除一朵花只会影响这朵花以及与其相邻的两朵花，可以以 $O(1)$ 的时间复杂度枚举每一朵花，枚举的总时间复杂度为 $O(n)$。

但由于需要排序，故总时间复杂度是 $O(n\log n)$。

注意要开 long long。

一道纯模拟加排序，不知道为什么要用到队列。
# 参考代码

```cpp
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
int n,m,t[(int)2e5+5],o[(int)2e5+5],del[(int)2e5+5],sum,maxn;
int over(int a,int b){
	if(!(a>=1&&a<=n&&b>=1&&b<=n)) return 0;
	return max(0ll,t[a]+m-t[b]);
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>t[i];
	sort(t+1,t+n+1);
	for(int i=1;i<=n;i++){
		o[i]=max(0ll,m-over(i-1,i)-over(i,i+1));
		sum+=o[i];
	}
	for(int i=1;i<=n;i++){
		del[i]=m-o[i];
		del[i]+=max(0ll,over(i-1,i)-over(i-2,i)-over(i-1,i+1));
		del[i]+=max(0ll,over(i,i+1)-over(i,i+2)-over(i-1,i+1));
	}
	for(int i=1;i<=n;i++) maxn=max(maxn,del[i]);
	cout<<sum+maxn;
	return 0;
}
```

---

## 作者：andyli (赞：6)

考虑枚举每一株玫瑰，将其移到与其他玫瑰不重叠的地方，此时对答案的贡献最大，为 $m$。题目可转化为区间加，全局查询 $1$ 的个数。用可持久化线段树维护区间严格次小值及数量，每次对一株玫瑰所在的区间进行区间减 $1$，如果全局严格次小值为 $1$，则记录数量，取最大值，最后与 $m$ 相加。  

```cpp
#include "all.hpp"
#include "ds/dynamic_lazy_segtree.hpp"
#include "acted_monoid/minmincnt2_add.hpp"

int main() {
    dR(int, n, m);
    dRV(int, a, n);

    auto default_prod = [&](int l, int r) -> Monoid_MinMincnt2<int>::X {
        return {0, inf<int>, r - l, 0};
    };
    Dynamic_Lazy_SegTree<ActedMonoid_MinMincnt2_Add<int>, false, i64, 1 << 23, decltype(default_prod)> seg(0, 2 * ten(9) + 1, default_prod);
    auto rt = seg.new_node();
    _for (i, n)
        rt = seg.apply(rt, a[i], a[i] + m, 1);
    i64 ans = 0;
    _for (i, n) {
        rt = seg.apply(rt, a[i], a[i] + m, -1);
        auto t = seg.prod_all(rt);
        if (t.min2 == 1)
            chkmax(ans, t.cnt2);
        rt = seg.apply(rt, a[i], a[i] + m, 1);
    }
    ans += m;
    print(ans);
    return 0;
}
```

---

## 作者：Big_Dinosaur (赞：4)

额……我的做法有点抽象，但是如果玫瑰开放时间不一样也可以做。
## 1.思路
为了方便，先将时间段移至时间点，如 $1\sim3$ 时间段开放变成 $1,4$ 两个时间点之间开放。

首先，对于每个开放时间计算结束时间，再做离散化。

接下来对每朵花开放 $a_i$、结束时间 $b_i$ 做差分，计算每个时间点有多少花开放。

接下来就是计算了，可以计算改变第 $i$ 朵玫瑰开放时间你得到的最大答案。如何计算？

先考虑这组数据：

```
3 5
1 2 3
```

改变第一朵的开放时间，至 $10$，手模一下可以发现 $1\sim2$ 时间点没有花开放，$2\sim3$ 时间点从两朵变成一朵。而 $10\sim15$ 时间点原来没有花，现在有花了。

其他也是如此，若原来开放时间中，有 $2$ 朵花开放的时长为 $c2$，有 $1$ 朵花开放的时长为 $c1$，移动后增加的答案为 $c0$，改变的贡献为：$c2-c1+c0$。

移动同一朵花使新的时间与原来的无交是，$c1,c2$ 是不变的，而 $c0$ 最大，只要移至无花开放的时间，为 $m$。

$c1,c2$ 怎么算？在差分数组上做前缀和，再对数组中值为 $1,2$ 的位置计算离散化前的对应时间长，重新做前缀和。
## 2.代码

由于特殊原因，下文 $c1,c2$ 是前缀和数组且对调，请注意。

```cpp
#include<bits/stdc++.h>
#define ri register int
#define int long long
#define pii pair<int,int>
#define mp make_pair
#define fi first
#define se second
const int p=998244353;
using namespace std;
namespace JYAorz{
	inline int r(){
		int J=1,Y=0;char A=getchar();while(A>'9'||A<'0'){if(A=='-')J=-1;A=getchar();}
		while(A<='9'&&A>='0'){Y=(Y<<1)+(Y<<3)+(A^48);A=getchar();}return J*Y;
	}
	inline void WI(int ORZ){if(ORZ==0)return;if(ORZ<0){ORZ=-ORZ;putchar('-');}WI(ORZ/10);putchar(48+ORZ%10);}
	inline void ww(int STO){if(STO!=0)WI(STO);else putchar('0');putchar(' ');}
	inline void wln(int STO){if(STO!=0)WI(STO);else putchar('0');putchar('\n');}
	inline void w(int STO){if(STO!=0)WI(STO);else putchar('0');}
}
using namespace JYAorz;
namespace YSCorz{
	int n,m,st[221212],en[212121],T[434343],q[434343],z[434343],c1[434343],c2[434343],Add=0;
	map<int,int>ls;
	inline void stoorz(){
		n=r(),m=r();
		for(ri i=1;i<=n;++i){
			st[i]=T[i]=r();
			en[i]=T[n+i]=st[i]+m;
		}
		sort(T+1,T+1+n+n);
		for(ri i=1;i<=n*2;++i)ls[T[i]]=i,z[i]=T[i];
		for(ri i=1;i<=n;++i)++q[st[i]=ls[st[i]]],--q[en[i]=ls[en[i]]];
		for(ri i=1;i<=n*2;++i)q[i]+=q[i-1];
		for(ri i=1;i<=n*2;++i)if(q[i]==2)c1[i]=z[i+1]-z[i];else if(q[i]==1)c2[i]=z[i+1]-z[i];
		for(ri i=1;i<=n*2;++i)c1[i]+=c1[i-1],c2[i]+=c2[i-1];
		for(ri i=1;i<=n;++i){
			Add=max(Add,c1[en[i]-1]-c1[st[i]-1]-c2[en[i]-1]+c2[st[i]-1]+m);
		}
		if(n==1)wln(m);
		else wln(c2[n*2]+Add);
	}
}
signed main(){YSCorz::stoorz();}
```

---

## 作者：SafariMo (赞：4)

你说的对，但是这题我没有用到差分，前缀和，队列。

按 $t_i$ 排序。

首先，对于每个 $t_i$，可以求出其左右端点使得区间内所有数仅出现一次，$L_i = \max(t_{i-1} + m ,t_i),R_i = \min(t_i + m - 1,t_{i+1}-1)$。

则如果不操作一个区间，答案为 $\sum_{i=1}^n
R_i - L_i + 1$。

如果操作一个区间，显然可以把 $t_i\leftarrow \infty$。

其仅对相邻和本身的 $L,R$ 产生影响。暴力即可。

```
        n = read(); m = read();
        f(i,1,n) a[i]=read();
        sort(a+1,a+n+1);
        int res = 0;
        a[0] = -INF , a[n + 1] = INF;
        f(i,1,n){
        	int L = Max(a[i - 1] + m, a[i]) , R = Min(a[i] + m - 1 ,a[i + 1] - 1); //GL,GR
			res += Max(0, R - L + 1);
		}
		int ans = 0;
		int L = res;
		f(i,1,n){
			if(i!=1)res -= Max(0,GR(i-1) - GL(i-1) + 1);
			if(i!=n)res -= Max(0, GR(i+1) - GL(i+1) + 1);
			res -= Max(0,GR(i) - GL(i) + 1);
			res += m;
			int t = a[i];
			a[i] = a[i + 1];
			if(i!=1)res += Max(0, GR(i-1) - GL(i-1) + 1);
			a[i] = a[i - 1];
			if(i!=n)res += Max(0, GR(i+1) - GL(i+1) + 1);
			a[i] = t;
			toMax(ans, res);
			res = L;
		}
		writed(ans );
```

---

## 作者：_Kenma_ (赞：4)

# P10837 解题报告

## 前言

作者赛时因为得了高级数据结构综合症，没有想到官方题解优秀的前缀和+队列做法。这里为大家提供一种常数巨大但比较好想的 $O(n \log v)$ 的线段树做法。

## 思路分析

显然，我们如果要改变一朵花的开放时间，贪心地想，肯定要使这朵花在一个与其他花开放时间不交的区间内开放。

考虑改变每一朵花的开放时间的贡献。设 $cnt1$ 表示这朵花开放区间内只有 $1$ 朵花开放的区间总长，$cnt2$ 表示只有 $2$ 朵花开放的区间总长，不难发现，移动这朵花对最终答案产生的贡献为 $cnt2+m-cnt1$。

考虑怎样维护贡献。考虑使用一棵动态开点线段树。序列记录每一时刻花开放的个数，线段树维护区间内 $012$ 的个数。这样，添加每朵花开放区间可视为区间加，计算贡献可以直接区间查询。

考虑怎样维护线段树每个节点区间 $012$ 的个数。不难发现，因为修改只有区间加，设区间加的值为 $k$，当前节点 $012$ 的个数分别为 $val0,val1,val2$。

- 当 $k = 1$ 时，$val1 = val0,val2 = val1,val0 = 0$；
- 当 $k = 2$ 时，$val2 = val0,val0 = val1 = 0$；
- 当 $k \ge 3$ 时，$val0 = val1 = val2 = 0$。

pushdown 同理。

## 代码实现 & 一些细节

作者赛时写的并不顺利，因为细节和常数问题耽误了不少时间。这里有一些作者认为容易写错的细节。

1. 注意动态开点的值域，不是 $1e9$，而是 $2e9$；
2. 注意创建新节点时，对 $val0$ 的初始化；
3. 注意，线段树上节点不需要开 long long，但是递归的 $l$ 与 $r$ 以及记录答案的 $ans$ 需要开 long long。如果无脑 #define int long long 可能会 T 一个或两个点；
4. 注意常数问题，适当卡常 ~~（读写优化、inline、register、手写 STL 函数还用我说吗）~~；
5. 如果实在卡不过去，可以开 O2 优化，毕竟现在正赛都有 O2 优化 ~~（吧？~~（学长：谁说的，我们当年省选都没有吸氧）
6. 其实也可以写离散化线段树，应该复杂度会小一些，不需要卡常了。

下面是作者在赛时丑陋代码的基础上，改写的较为规范的代码，可能码风不正，敬请谅解。看懂的同学还是建议自己写一遍，感觉还是有助于提升码力的 ~~（评黄了？那就看心情吧）~~

保证以下代码可以在不开启 O2 优化情况提下，在 C++ 的所有语言版本通过。

[赛时AC记录（C++ 98 O2）](https://www.luogu.com.cn/record/170357343)

[赛后AC记录（C++14 无O2）](https://www.luogu.com.cn/record/170417922)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e9;
int n,m,rt,t[200005];
long long ans,cnt1,cnt2;
int val_0[12800005],val_1[12800005],val_2[12800005],tag[12800005],ls[12800005],rs[12800005],dcnt;
inline void pushup(int l,int r,int x){
	long long mid=(1ll*l+r)>>1;
	if(!ls[x]){
		ls[x]=++dcnt;
		val_0[ls[x]]=(mid-l+1);
	}
	if(!rs[x]){
		rs[x]=++dcnt;
		val_0[rs[x]]=(r-mid); 
	}
	val_0[x]=val_0[ls[x]]+val_0[rs[x]];
	val_1[x]=val_1[ls[x]]+val_1[rs[x]];
	val_2[x]=val_2[ls[x]]+val_2[rs[x]];
}
inline void pushdown(int l,int r,int x){
	if(!tag[x]) return;
	long long mid=(1ll*l+r)>>1;
	if(!ls[x]){
		ls[x]=++dcnt;
		val_0[ls[x]]=(mid-l+1);
	}
	if(!rs[x]){
		rs[x]=++dcnt;
		val_0[rs[x]]=(r-mid);
	}
	tag[ls[x]]+=tag[x];
	tag[rs[x]]+=tag[x];
	if(tag[x]==1){
		val_2[ls[x]]=val_1[ls[x]];
		val_1[ls[x]]=val_0[ls[x]];
		val_0[ls[x]]=0;
		val_2[rs[x]]=val_1[rs[x]];
		val_1[rs[x]]=val_0[rs[x]];
		val_0[rs[x]]=0;
	}else if(tag[x]==2){
		val_2[ls[x]]=val_0[ls[x]];
		val_0[ls[x]]=val_1[ls[x]]=0;
		val_2[rs[x]]=val_0[rs[x]];
		val_0[rs[x]]=val_1[rs[x]]=0;
	}else{
		val_0[ls[x]]=val_0[rs[x]]=val_1[ls[x]]=val_1[rs[x]]=val_2[ls[x]]=val_2[rs[x]]=0;
	}
	tag[x]=0;
}
inline void modify(int l,int r,int ql,int qr,int &x){
	if(!x){
		x=++dcnt;
		val_0[x]=(r-l+1);
	}
	if(ql<=l && r<=qr){
		val_2[x]=val_1[x];
		val_1[x]=val_0[x];
		val_0[x]=0;
		tag[x]++;
		return;
	}
	pushdown(l,r,x); 
	long long mid=(1ll*l+r)>>1;
	if(ql<=mid) modify(l,mid,ql,qr,ls[x]);
	if(qr>=mid+1) modify(mid+1,r,ql,qr,rs[x]);
	pushup(l,r,x);
}
inline int query_1(int l,int r,int ql,int qr,int x){
	if(!x) return 0;
	if(ql<=l && r<=qr) return val_1[x];
	pushdown(l,r,x);
	long long mid=(1ll*l+r)>>1;
	int ans=0;
	if(ql<=mid) ans+=query_1(l,mid,ql,qr,ls[x]);
	if(qr>=mid+1) ans+=query_1(mid+1,r,ql,qr,rs[x]);
	return ans;
}
inline int query_2(int l,int r,int ql,int qr,int x){
	if(!x) return 0;
	if(ql<=l && r<=qr) return val_2[x];
	pushdown(l,r,x); 
	long long mid=(1ll*l+r)>>1;
	int ans=0;
	if(ql<=mid) ans+=query_2(l,mid,ql,qr,ls[x]);
	if(qr>=mid+1) ans+=query_2(mid+1,r,ql,qr,rs[x]);
	return ans;
}
inline void _max(long long &a,long long b){
	a=a>b?a:b; 
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(register int i=1;i<=n;i++){
		cin>>t[i];
		modify(1,maxn,t[i],t[i]+m-1,rt);
	}
	ans=val_1[rt];
	for(register int i=1;i<=n;i++){
		cnt1=query_1(1,maxn,t[i],t[i]+m-1,rt);
		cnt2=query_2(1,maxn,t[i],t[i]+m-1,rt);
		_max(ans,val_1[rt]-cnt1+cnt2+m);
	} 
	cout<<ans;
	return 0;
}
```

补：赛时感觉这个题线段树做法至少上位绿，但是赛后发现只有黄……作者建议评绿，以提高大家写线段树做法的积极性。~~真的绿以下众生平等吗。~~

补：建议开大时间限制，作者的线段树卡常卡到极致还是在 T 的边缘徘徊。听说线段树做法可以剪枝？以后再补吧。

补：据说没人写动态开点线段树题解的原因,是大家的动态开点线段树都没卡过去? ~~那我真是荣幸。~~

---

## 作者：从蒟蒻到小犇 (赞：3)

我老婆珂朵莉真是太可愛了，本蒟蒻来发一篇用**珂朵莉树**做的题解。

大概题意：求选择一个玫瑰开放的区间挪走后，只被一个玫瑰开放的区间覆盖的总时间。

所以我们要维护**只有一株玫瑰开放的时间区间**和**有两株玫瑰开放的时间区间**。如果一段时间内有三株以上玫瑰开放的话，就不用管了，即使挪走一株玫瑰也无法做到这段时间内有且仅有一株凋零玫瑰开放。

也就是说，被三朵玫瑰覆盖的时间区间都可以被推平，而只被一朵或两朵玫瑰覆盖的时间区间只会被访问一到两次，所以可以用珂朵莉树来维护，均摊时间复杂度为 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mn=2e5;

struct Chtholly{
    mutable int l;
    int r;
    mutable int cnt;
};
set<Chtholly> st;
bool operator < (Chtholly a,Chtholly b) {
    return a.r<b.r;
}
#define iter set<Chtholly>::iterator
iter Split(int pos) {
    iter it=st.lower_bound({0721,pos,233});
    if(it->l==pos) return it;

    int l=it->l,r=it->r,cnt=it->cnt;
    st.erase(it);
    st.insert({l,pos-1,cnt});
    return st.insert({pos,r,cnt}).first;
}
void Insert(int l,int r) {
    iter itr=Split(r+1),itl=Split(l);
    iter lstit=itl;lstit--;
    for(iter it=itl;it!=itr;it++) {
        it->cnt++;
        //两段区间都被三种以上的玫瑰覆盖了的话，就把他们合并到一起，
        //这里我是更改右边区间的l值并删掉左边的区间来合并的。
        if(it->cnt>=3 && lstit->cnt>=3) {
            it->l=lstit->l;
            st.erase(lstit);
        }
        lstit=it;
    }
    if(itr->cnt>=3 && lstit->cnt>=3) {
        itr->l=lstit->l;
        st.erase(lstit);
    }
}

int n,m;
int t[mn+3];

int main() {
    st.insert({-1,(int)2e9+1,0});
    //iter it=Split(9);
    //cout<<it->r;
    cin>>n>>m;
    for(int i=1;i<=n;i++) {
        cin>>t[i];
        Insert(t[i],t[i]+m-1);
    }

    long long basictime=0;
    for(iter it=st.begin();it!=st.end();it++) {
        //cout<<it->l<<" "<<it->r<<" "<<it->cnt<<endl;
        if(it->cnt==1) basictime+=(it->r-it->l+1);
    }
    //cout<<ans;
    long long tans=basictime;
    for(int i=1;i<=n;i++) {
        long long nans=basictime;
        int l=t[i],r=t[i]+m-1;
        for(iter it=st.lower_bound({0721,l,233});
        it->l<=r;it++) {
            if(it->cnt==1) nans-=min(it->r,r)-max(it->l,l)+1;
            if(it->cnt==2) nans+=min(it->r,r)-max(it->l,l)+1;
        }
        tans=max(tans,nans+m);
    }
    cout<<tans;
    return 0;
}
```

---

## 作者：fish_love_cat (赞：3)

懵了，出题人写的什么看不懂啊！

给出一种和官解不同的解法，欢迎 hack。

---

首先可以对 $t$ 进行排序。

此时有一个很重要的结论可以来辅助思考，虽然后面用不到，但不理解的话可以多看看这句话：

> 因为 $t$ 有序，所以第 $i-1$ 和第 $i+1$ 朵花一定是和第 $i$ 朵花覆盖最多的两朵。

然后我们可以开始计算没有移动时的答案。

首先设 $f_i$ 表示第 $i$ 朵花的贡献，初始时设 $f_i=m$。

对于相邻的 $t_i$ 和 $t_{i-1}$，设它们重合的区间长度是 $c_{i,l}=c_{i-1,r}=\max((t_{i-1}+m-1)-t_i+1,0)$。

其中 $c_{i,l}$ 表示第 $i$ 朵花左边重合长度，$c_{i,r}$ 表示第 $i$ 朵花右边重合长度。

重合部分没有贡献，所以把 $c_{i,l}$ 从 $f_i$ 中减掉，把 $c_{i-1,r}$ 从 $f_{i-1}$ 中减掉。

注意贡献不能为负。

接着对 $f$ 求和就得到了没有移动的答案。

最后，我们再把每朵花移动的贡献求出来取最大值即可。

每朵花移动的贡献可以轻松得到：

设 $L=t_i+c_{i,l},R=t_i+m-1-c_{i,r}$。

当 $L<R$，则第 $i-1$ 和 $i+1$ 朵花花没有交集，所以中间没被覆盖的不算增加。还有因为此花离开了，那么左右各有可能会有一段被释放，需要判断增加。

时刻记得注意贡献不可能为负。

那么贡献即为 $m-(R-L+1)+\min(m-c_{i-1,l},c_{i,l})+\min(m-c_{i+1,r},c_{i,r})$。

当 $L\ge R$，则第 $i-1$ 和 $i+1$ 朵花花有交集，所以这朵花被全覆盖。和上面一样，因为此花离开了，那么左右各有可能会有一段被释放，需要判断增加。但是中部因为有一段交集，所以这段交集需要减掉。

设这段交集为 $j=L-R-1$。注意这个，搞错挂大分！

那么贡献即为 $m+\max(0,\min(m-c_{i-1,l},c_{i,l})-j)+\max(0,\min(m-c_{i+1,r},c_{i,r})-j)$。

照着求就完了。

赛时代码很丑，凑合看吧。

后附样例和 hack 及……一些样例解释？

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500005],ans,f[500005],maxx=-1e18,tiaoshi;
struct fish{
    int l,r;
}flc[500005];
signed main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    cin>>a[i],f[i]=m;
    sort(a+1,a+1+n);
    for(int i=2;i<=n;i++){
        int awa=max(a[i-1]+m-1-a[i]+1,0ll);
        f[i-1]-=awa;
        f[i-1]=max(f[i-1],0ll);
        f[i]-=awa;
        flc[i-1].r=awa;
        flc[i].l=awa;
        //cout<<awa<<' '<<f[i-1]<<'\n';
    }
    for(int i=1;i<=n;i++)
    ans+=f[i];
    for(int i=1;i<=n;i++){
        int lve=0,L,R;
        if(flc[i].l)L=a[i]+flc[i].l;
        else L=a[i];
        if(flc[i].r)R=a[i]+m-1-flc[i].r;
        else R=a[i]+m-1;
        lve-=max(0ll,R-L+1);
        int jiao=max(0ll,L-R-1);
        int leftgx=0;
        int rigtgx=0;
        leftgx=max(0ll,min(m-flc[i-1].l,flc[i].l)-jiao);
        rigtgx=max(0ll,min(m-flc[i+1].r,flc[i].r)-jiao);
        lve+=leftgx+rigtgx;
        if(maxx<lve)maxx=lve,tiaoshi=i;
    }
    ans+=m+maxx;
    //cout<<maxx<<' '<<tiaoshi<<' ';
    cout<<ans;
    return 0;
}
/*
13 7
2 6 12 20 28 28 41 42 45 45 58 60 61
8 12 18 26 34 34 47 48 51 51 64 66 67
38

5 5
1 6 11 16 20
5 10 15 20 24
25

5 4
1 3 9 11 12
4 6 12 14 15
14
*/
```

---

## 作者：vorDeal (赞：2)

看到区间，一眼差分。

但是什么数组能够开到 $10^9$ 还不炸？所以我们对时间的左端点进行排序，再进行区间覆盖。

记 $f_i$ 为第 $i$ 朵玫瑰对答案的贡献。若 $f_i$ 不为 $0$，则贡献区间为 $[\max(t_i,t_{i-1}+m),\min(t_i+m,t_{i+1}))$。

于是我们可以计算出不进行修改时的答案。

由于可以改变一朵玫瑰的种植时间，所以我们遍历每一朵玫瑰，对答案进行修改。

每一朵玫瑰的开放时长相等，所以对玫瑰 $i$ 的修改只会影响到 $f_i$、$f_{i-1}$ 与 $f_{i+1}$（如果存在的话）。

- 对于 $f_i$，我们将它的绽放时间修改为遥远的将来，一个玫瑰凋尽的时刻，则它的贡献即为 $m$。
- 对于 $f_{i+1}$、$f_{i-1}$，我们发现 $i+1$ 与 $i-1$、$i+2$ 相邻，$i-1$ 与 $i-2$、$i+1$ 相邻，以此为基础重新计算贡献。

于是我们对修改过的贡献取最大值，即为答案。

几个坑点：

- 十年 OI 一场空，不开 long long 见祖宗。
- 注意对边界的处理，可以取一个极小的 $t_0$、一个极大的 $t_{n+1}$。
- 记得一朵花的贡献不能为负。

**AC Code：**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
long long m, t[200005], f[200005], ans, sum;

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> t[i];
    sort(t + 1, t + n + 1);
    t[0] = -m, t[n + 1] = 2e9 + 10;
    for (int i = 1; i <= n; i++)
        f[i] = max(0LL, min(t[i] + m, t[i + 1]) -
                            max(t[i], t[i - 1] + m)),
        sum += f[i];
    for (int i = 1; i <= n; i++)
        ans = max(ans, sum + (m - f[i]) +
                           max(0LL, min(t[i + 2], t[i + 1] + m) -
                                        max(t[i + 1], t[i - 1] + m) - f[i + 1]) +
                           max(0LL, min(t[i - 1] + m, t[i + 1]) -
                                        max(t[i - 2] + m, t[i - 1]) - f[i - 1]));
    cout << ans;
    return 0;
}
```

---

## 作者：ln001 (赞：2)

算法：贪心、离散化、线段树。

考虑贪心。

下文使用 $c1_{x,y}$ 表示区间 $[x,y]$ 中只被一个区间覆盖的点的个数，使用 $c2_{x,y}$ 表示区间 $[x,y]$ 中只被两个区间覆盖的点的个数，最后一朵花凋零的时间为 $end$，且把一朵花开放的时间看作一个区间。

若不修改任意一朵花，则答案为只被一个区间覆盖的点的个数，即 $c1_{1,end}$。

若修改一朵花，设这朵花开放的第一刻与最后一刻为 $ x,y$，则修改后的答案为原来满足条件(只被一个区间覆盖)的点的总个数 $ - $ 这朵花覆盖的区间内满足条件的点的个数 $ + $ 这朵花覆盖的区间内满足被两个区间覆盖的点的个数 $ + $ 这朵花开放时间，即 $ c1_{1,end}-c1_{x,y}+c2_{x,y}+(y-x+1)$。

考虑证明，因为我们确定要修改一朵花，使被一个区间覆盖的点最多，那么这个花对应的区间与其他区间有交的情况显然是不优秀的，则我们要把这个区间移动到足够远的位置，使其与其他区间无交点，那么当它撤掉后，区间内所有点的覆盖情况 $ -1$，式子就很好得到了。

值域很大，需要先离散化。现在需要求区间满足某个条件的点的个数，线段树即可。而且这种做法可以处理 $ m $ 不为定值的情况。

**离散化套线段树可能会遇到统计结果偏大的问题，hack 见代码里，解决办法就是在每个区间的末尾切片。**

~~该有的注释应该还是有的~~

```cpp
#define ll long long
#define f(x, y, z) for (ll x = (y); x <= (z); x++)
using namespace std;
inline ll read();
const ll INF = 0x3f3f3f3f3f3f3f3f, N = 6e5 + 10; // 由于离散化后的点为3*n个，所以空间要开三倍
ll n, m;
ll c; // 离散化后点的总个数
struct node
{
    ll x, y; // 离散化后的点
    ll a, b; // 原始的点
} a[N];

vector<ll> drtion; // 离散化
ll sf[N];
ll get_id(ll x)
{
    return lower_bound(drtion.begin(), drtion.end(), x) - drtion.begin() + 1;
}

#define mid(l, r) ((l + r) >> 1) // 线段树
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
struct TREE
{
    ll p;
    ll l, r;
    ll t;
    ll a[3]; // 区间中0，1，2的个数
} t[N * 4];
void push_up(ll x)
{
    f(i, 0, 2) t[x].a[i] = t[ls(x)].a[i] + t[rs(x)].a[i];
}
void add(ll x, ll y)
{
    for (ll i = 2; i >= 0; i--)
    {
        if (i - y < 0) // 如果加超了
            t[x].a[i] = 0;
        else
            t[x].a[i] = t[x].a[i - y];
    }
    t[x].t += y;
}
void push_down(ll x)
{
    if (!t[x].t)
        return;
    add(ls(x), t[x].t);
    add(rs(x), t[x].t);
    t[x].t = 0;
    return;
}
void add(ll p, ll L, ll R, ll x)
{
    if (t[p].l > R || t[p].r < L)
        return;
    if (t[p].l >= L && t[p].r <= R)
        return add(p, x);
    push_down(p);
    add(ls(p), L, R, x);
    add(rs(p), L, R, x);
    push_up(p);
}

ll ask1(ll p, ll L, ll R) // 询问区间中1的个数
{
    if (t[p].l > R || t[p].r < L)
        return 0;
    if (t[p].l >= L && t[p].r <= R)
    {
        return t[p].a[1];
    }
    push_down(p);
    return ask1(ls(p), L, R) + ask1(rs(p), L, R);
}
ll ask2(ll p, ll L, ll R) // 询问区间中2的个数
{
    if (t[p].l > R || t[p].r < L)
        return 0;
    if (t[p].l >= L && t[p].r <= R)
    {
        return t[p].a[2];
    }
    push_down(p);
    return ask2(ls(p), L, R) + ask2(rs(p), L, R);
}

void build(ll p = 1, ll x = 1, ll y = c)
{
    t[p].l = x;
    t[p].r = y;
    if (x == y)
    {
        ll siz = sf[x];
        t[p].a[0] = siz; // 这里需要注意，由于我们使用的是在离散化之后的空间上使用线段树，所以在维护原始区间0，1，2的个数时不能使用y-x+1的方式，在离散化的同时我们用sf数组维护离散化后的每个点对应的实际空间的长度。这里赋值为实际长度。
        return;
    }
    build(ls(p), x, mid(x, y));
    build(rs(p), 1 + mid(x, y), y);
    push_up(p);
}

signed main()
{
    csf;
    cin >> n >> m;
    f(i, 1, n)
    {
        cin >> a[i].a;
        a[i].b = a[i].a + m - 1;
        drtion.push_back(a[i].a);
        drtion.push_back(a[i].b + 1); // 切片
        drtion.push_back(a[i].b);
    }
    sort(drtion.begin(), drtion.end());
    drtion.erase(unique(drtion.begin(), drtion.end()), drtion.end());
    c = drtion.size();

    f(i, 0, drtion.size() - 2)
    {
        sf[i + 1] = drtion[i + 1] - drtion[i]; // 计算实际长度
    }
    sf[drtion.size()] = 1;

    f(i, 1, n)
    {
        a[i].x = get_id(a[i].a);
        a[i].y = get_id(a[i].b);
    }

    build(); // 建立一个全为0的线段树
    f(i, 1, n)
    {
        add(1, a[i].x, a[i].y, 1); // 由于我太菜了，所以只会动态加
    }
    ll ans = ask1(1, 1, c);
    f(i, 1, n)
    {
        ll summ = ask1(1, 1, c) - ask1(1, a[i].x, a[i].y);
        summ += ask2(1, a[i].x, a[i].y);
        summ += a[i].b - a[i].a + 1;
        ans = max(ans, summ);
    }
    cout << ans << endl;
    return 0;
}
/*
hack：
IN:
2 3
1 3
ANS:6
*/
```

---

## 作者：NightTide (赞：2)

**你说得对，但是就是喜欢用离散化。**

题目可以简化为 $n$ 条长度一定线段覆盖，问只被一条线段覆盖的点的个数。

由于只能移动一条线段，所以我们可以计算出每一条线段移动最多能够增加的贡献，然后取最大的。

首先对于一条线段，由于其可以任意移动，那么最有效的方式自然是让它覆盖一个未被覆盖的区间，这样移动后的答案是最大的。

考虑移动第 $i$ 条线段对答案产生的影响。首先这条线段原来覆盖的区域覆盖数要减一。记区间内移动前被两条线段覆盖的点数为 $cnt2_i$，移动前被一条线段覆盖的点数为 $cnt1_i$，则答案减少 $cnt1_i$，增加 $cnt2_i$。

同时还有移动后，这条线段覆盖了一个原本未被覆盖的区间，所以答案还要加上线段长度 $m$。

总结一下，答案变为

$$ans - cnt1_i + cnt2_i + m$$

取最大值即可。

计算某个点上有多少条线段覆盖，可以用树状数组区间修改，单点查询。当然线段树也可以。~~但是谁会拒绝一个又好写又常数小的可爱的树状数组呢？~~

但是我们发现这样做理论上树状数组应该开到 $t_i + m$，这样是开不下的。

于是我们使用传统艺能，离散化。

但是离散化不能只记录线段的两个端点，例如下面这个例子：两条线段分别覆盖区间 $[2,5]$ 和 $[7,10]$。

离散化后我们记录的值是：$1,1,1,1$。

我们将 $[5,7]$ 也认为是有线段覆盖的了。

因此我们需要一个标记，作为左右边界的标记。一个简单的办法就是将 $l - 1$ 和 $r + 1$ 也放入离散化中。这样离散化后，上例的答案就变为：$0,1,1,0,0,1,1,0$，将两个不连续的区间分开来了。

具体实现见代码：
```cpp
#include<bits/stdc++.h>
#define MAXN 400010
using namespace std;
typedef long long ll;
ll n, m, tot;
ll lt[MAXN], rt[MAXN];
ll sum[MAXN << 2], t[MAXN << 2], cnt1[MAXN << 2], cnt2[MAXN << 2], res[MAXN << 2];
ll low_bit(ll x){ return x & (-x); }
void add(ll i, ll k){
    while(i <= tot){
        sum[i] += k;
        i += low_bit(i);
    }
}
ll query(ll i){
    ll res = 0;
    while(i > 0){
        res += sum[i];
        i -= low_bit(i);
    }
    return res;
}
void update(ll l, ll r, ll x){
    add(l, x);
    add(r + 1, -x);
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i = 1; i <= n; i++) scanf("%lld",&lt[i]);
    for(ll i = 1; i <= n; i++) rt[i] = lt[i] + m - 1;
    for(ll i = 1; i <= n; i++){
        t[++tot] = lt[i] - 1;
        t[++tot] = lt[i];
        t[++tot] = rt[i];
        t[++tot] = rt[i] + 1;
    }
    sort(t + 1, t + tot + 1);
    tot = unique(t + 1, t + tot + 1) - t - 1;
    for(ll i = 1; i <= n; i++) lt[i] = lower_bound(t + 1, t + tot + 1, lt[i]) - t;
    for(ll i = 1; i <= n; i++) rt[i] = lower_bound(t + 1, t + tot + 1, rt[i]) - t;
    for(ll i = 1; i <= n; i++){
        update(lt[i], rt[i], 1);
    }
    for(ll i = 1; i <= tot; i++) res[i] = query(i);
    for(ll i = 2; i <= tot; i++){
        if(res[i] == 1 && res[i - 1] >= 1) cnt1[i] = t[i] - t[i - 1];
        else if(res[i] == 1 && res[i - 1] < 1) cnt1[i] = 1;
        else if(res[i - 1] == 1 && res[i] >= 1) cnt1[i] = t[i] - t[i - 1] - 1;
    }

    for(ll i = 2; i <= tot; i++){
        if(res[i] == 2 && res[i - 1] >= 2) cnt2[i] = t[i] - t[i - 1];
        else if(res[i] == 2 && res[i - 1] < 2) cnt2[i] = 1;
        else if(res[i - 1] == 2 && res[i] >= 2) cnt2[i] = t[i] - t[i - 1] - 1;
    }
    ll ans = 0;
    for(ll i = 1; i <= tot; i++) ans += cnt1[i];
    for(ll i = 1; i <= tot; i++) cnt1[i] += cnt1[i - 1];
    for(ll i = 1; i <= tot; i++) cnt2[i] += cnt2[i - 1];
    ll maxx = 0;
    for(ll i = 1; i <= n; i++){
        ll c1 = cnt1[rt[i]] - cnt1[lt[i] - 1], c2 = cnt2[rt[i]] - cnt2[lt[i] - 1];
        ll tmp = c2 + m - c1;
        maxx = max(maxx, tmp);
    }
    printf("%lld\n",ans + maxx);
    return 0;
}
```
记得开 `long long`。

---

## 作者：zhoumurui (赞：2)

### 题面展示

有 $n$ 条，第 $i$ 条线段覆盖 $[a_i,a_i+m-1] $ 的区域。现在请求出平移一条线段以后，被**恰好**一条线段覆盖的整点的数量。 

### 解题思路

本篇题解使用的方法非常朴素。

首先排序所有线段，并进行一个预处理，计算每一条线段**唯一覆盖**的区域的左端点和右端点，此时被唯一覆盖的整点数量记为 $\text{cnt}$。

随后枚举哪条线段要被移动，显然，移到空的地方是最优的，被移动的线段一定能覆盖 $m$ 个整点。

假设被移动的线段的编号为 $i$，重新计算线段 $i-1$ 和 $i+1$ 唯一覆盖的区域，这是 $O(1)$ 的，而其他线段唯一覆盖的区域都不会改变，因为我们已经对线段排好序了，线段 $i$ 覆盖其他线段的区域必然都被线段 $i-1$ 和线段 $i+1$ 覆盖了。

于是就可以处理出移走线段 $i$ 后，被唯一覆盖的整点数量。枚举移动的线段取最大值即可。

时间复杂度瓶颈为排序，$O(n \log n)$。

### 核心代码展示

```cpp
#define int long long
int a[400005],l[400005],r[400005];
signed main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+1+n,cmp);
    int cnt=0,ans=0,res=0;
    for (int i=1;i<=n;i++){
        if (i==1)l[i]=a[i];
        else l[i]=max(a[i],a[i-1]+m);
        if (i==n)r[i]=a[i]+m-1;
        else r[i]=min(a[i]+m-1,a[i+1]-1);
        cnt+=max(0LL,r[i]-l[i]+1);
    
    }
    for (int i=1;i<=n;i++){
        res=cnt-max(0LL,r[i]-l[i]+1)+m;
        if (i==n){
            res-=max(0LL,r[i-1]-l[i-1]+1);
            res+=max(0LL,a[i-1]+m-l[i-1]);
        }
        else if (i==1){
            res-=max(0LL,r[i+1]-l[i+1]+1);
            res+=max(0LL,r[i+1]-a[i+1]+1);
        }
        else {
            res-=max(0LL,r[i-1]-l[i-1]+1);
            res+=max(0LL,min(a[i-1]+m-1,a[i+1]-1)-l[i-1]+1);
            res-=max(0LL,r[i+1]-l[i+1]+1);
            res+=max(0LL,r[i+1]-max(a[i+1],a[i-1]+m)+1);
        }
        ans=max(ans,res);
    }
    print(ans);
}
```

---

## 作者：SamHJD (赞：1)

~~这个傻福根号写魔怔了，赛时整了个分块上去，空间时间全被卡了。~~

> 给出 $n$ 个线段，长度均为 $m$，第 $i$ 个线段的起点为 $t_i$。你可以修改一个 $t_i$ 为任意正整数，求最多有多少个位置被恰好一条线段覆盖。

首先，选定一个 $t_i$ 后，将其修改为 $t'_i=\infin$ 肯定最优，修改后 $[t_i',t_i'+m-1]$ 区间内每个位置的覆盖次数均为 $1$，产生贡献为 $m$。

再考虑 $[t_i,t_i+m-1]$ 修改后的贡献变化，修改前覆盖次数为 $1$ 的位置不再产生贡献，而覆盖次数为 $2$ 的位置此时覆盖次数为 $1$，产生贡献。记修改前 $[t_i,t_i+m-1]$ 中被覆盖一次的位置个数为 $cnt_1$，覆盖两次的位置个数为 $cnt_2$，则修改 $t_i$ 会将答案加上 $cnt_2-cnt_1+m$。

于是处理出 $cnt_1,cnt_2$ 的前缀和，枚举每个 $t_i$ 计算 $cnt_2-cnt_1+m$ 的最大值即可。注意 $t_i\in[1,10^9]$，需要先进行离散化。

```cpp
#include "bits/stdc++.h"
#define int long long
#define rep(i,s,t) for(int i=s;i<=t;++i)
#define per(i,t,s) for(int i=t;i>=s;--i)
using namespace std;
template<typename T>
inline void read(T &x) {
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	x*=f;
}
const int N=1e6+10;
int n,m,t[N],a[4*N],b[4*N],c[4*N];
int v[N];
int book[4*N],bcnt;
int get(int x){return lower_bound(book+1,book+bcnt+1,x)-book;}
signed main(){
	read(n);read(m);
	rep(i,1,n){
		read(t[i]);
		book[++bcnt]=t[i],book[++bcnt]=t[i]+m-1;
		book[++bcnt]=t[i]+1;book[++bcnt]=t[i]+m;
	}
	sort(book+1,book+bcnt+1);bcnt=unique(book+1,book+bcnt+1)-book-1;
	rep(i,1,bcnt) v[i]=book[i+1]-book[i];v[bcnt]=1;
	rep(i,1,n) a[get(t[i])]++,a[get(t[i]+m)]--;
	rep(i,1,bcnt) a[i]+=a[i-1];
	rep(i,1,bcnt){
		b[i]=b[i-1]+(a[i]==2?1ll:0ll)*v[i],c[i]=c[i-1]+(a[i]==1?1ll:0ll)*v[i];
	}
	int tmp=c[bcnt],res=tmp;
	rep(i,1,n){
		int x=get(t[i]+m-1),y=get(t[i])-1;
		res=max(res,tmp+(b[x]-b[y])-(c[x]-c[y])+m);
	}
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

首先将区间按照左端点排序。

那么对于区间 $[l_i,r_i]$，设左端点小于等于 $l_i$ 中的最大 $r_j$ 为 $Max$，那么该区间未被其它区间覆盖的区间为 $[Max+1,l_{i+1}-1]$。

同时设 $h_i$ 表示若删除第 $i$ 个区间新增的贡献（可能是负的），那么我们需要维护一个 $r$ 的次大值 $Max2$。

则删除右端点为 $Max$ 的区间会使得 $[Max2+1,l_{i+1}-1]$ 为新的贡献区间，删除第 $i+1$ 个区间会使得 $[Max+1,l_{i+2}-1]$ 为新的贡献区间，统计一下即可。

最后找到所有 $h_i$ 的最大值，将其删去即可。

时间复杂度为 $O(N \log N)$。

### 完整代码：

```#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=2e5+10; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r;
	bool operator<(const Node&rhs)const{
		if(l!=rhs.l)
		  return l<rhs.l;
		return r<rhs.r;
	}
}a[N];
ll n,m,Max,Max2,id,sum,ans=-1e18;
ll h[N];
bool End;
int main(){
	n=read(),m=read();
	for(int x,i=1;i<=n;i++){
		x=read();
		a[i]={x,x+m-1};
	}
	sort(a+1,a+n+1);
	a[n+1].l=1e18;
	for(int i=1;i<=n;i++){
		ll l=max(Max+1,a[i].l),r=min(a[i+1].l-1,a[i].r),t=0;
		if(l<=r){
			t=r-l+1;
			sum+=t;
		}
		l=max(Max2+1,a[i].l),r=min(a[i+1].l-1,a[i].r);
		if(l<=r)
		  h[id]+=(r-l+1)-t;
		if(i!=n){
			l=max(Max+1,a[i].l),r=min(a[i+2].l-1,a[i].r);
			if(l<=r)
			  h[i+1]+=(r-l+1)-t;			
		}
		if(a[i].r>=Max){
			Max2=Max;
			Max=a[i].r;
			id=i;
		}
		else if(a[i].r>Max2)
		  Max2=a[i].r;
		Max=max(Max,a[i].r); 
		h[i]-=t;
	}
	for(int i=1;i<=n;i++)
	  ans=max(ans,h[i]);
	write(sum+ans+m); 
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=2e5+10; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r;
	bool operator<(const Node&rhs)const{
		if(l!=rhs.l)
		  return l<rhs.l;
		return r<rhs.r;
	}
}a[N];
ll n,m,Max,Max2,id,sum,ans=-1e18;
ll h[N];
bool End;
int main(){
	n=read(),m=read();
	for(int x,i=1;i<=n;i++){
		x=read();
		a[i]={x,x+m-1};
	}
	sort(a+1,a+n+1);
	a[n+1].l=1e18;
	for(int i=1;i<=n;i++){
		ll l=max(Max+1,a[i].l),r=min(a[i+1].l-1,a[i].r),t=0;
		if(l<=r){
			t=r-l+1;
			sum+=t;
		}
		l=max(Max2+1,a[i].l),r=min(a[i+1].l-1,a[i].r);
		if(l<=r)
		  h[id]+=(r-l+1)-t;
		if(i!=n){
			l=max(Max+1,a[i].l),r=min(a[i+2].l-1,a[i].r);
			if(l<=r)
			  h[i+1]+=(r-l+1)-t;			
		}
		if(a[i].r>=Max){
			Max2=Max;
			Max=a[i].r;
			id=i;
		}
		else if(a[i].r>Max2)
		  Max2=a[i].r;
		Max=max(Max,a[i].r); 
		h[i]-=t;
	}
	for(int i=1;i<=n;i++)
	  ans=max(ans,h[i]);
	write(sum+ans+m); 
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---

## 作者：gavinliu266 (赞：0)

# 思路
考虑把每朵花覆盖的时间段暴力标出。

对于一朵花，移动到空闲位置对答案的贡献为：当前区间两朵花同时开放的时间（移走后变为一朵花），减去当前区间仅一朵花开放的时间（移走后没有花了），再加上这朵花的开放时长。

于是只要预先统计出全局仅一朵花开放的时间，再遍历每朵花，找到最大的贡献，将二者相加即可。

涉及区间加，于是考虑线段树，查询时暴力遍历当前花覆盖的区间。

由于值域较大，且只需相对位置，于是可以先离散化。

这样就可以拿到 $90$ 的高分了。

时间复杂度：$O(n\log n+n(m+\log n))=O(n\log n + nm)$。

## 优化
考虑优化查询，可以考虑记录区间最小值，如果查询值大于最小值，即可结束查询。

由于这里查询的值最大为 $2$，所以最坏情况下每个位置恰好覆盖两次，即 $nm = O(n)$，所以时间复杂度优化到 $O(n\log n + n)=O(n\log n)$，可以通过本题。

# 代码实现
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 2e5 + 5;
int n, m;
int a[N];
int _ans = -2e9; // 初始化为负，因为移走后不加 m 可能为负
int d[N * 8], minn[N * 8];
int c[N * 2], csiz;
inline void pushdown(int p) {
    if(d[p]) {
        d[p << 1] += d[p];
        d[(p << 1) | 1] += d[p];
        minn[p << 1] += d[p];
        minn[(p << 1) | 1] += d[p];
        d[p] = 0;
    }
}
void PD_all(int l, int r, int p) {
    if(l == r) return;
    pushdown(p);
    int mid = (l + r) >> 1;
    PD_all(l, mid, p << 1);
    PD_all(mid + 1, r, (p << 1) | 1);
}
void modify(int l, int r, int s, int t, int o, int p) {
    if(s <= l && r <= t) {
        d[p] += o;
        minn[p] += o;
        return;
    }
    int mid = (l + r) >> 1;  // 不 pushdown 是因为会一起 pushdown
    if(mid >= s) modify(l, mid, s, t, o, p << 1);
    if(mid < t) modify(mid + 1, r, s, t, o, (p << 1) | 1); // 不 pushup 是因为只有修改操作，没有建树
}
int query(int l, int r, int s, int t, int p) {
    if(s <= l && r <= t && minn[p] > 2)  // 优化
        return 0;
    if(l == r) {
        return (d[p] == 1 ? -1 : (d[p] == 2 ? 1 : 0)) * max(0, c[l + 1] - c[l]);
    }
    int mid = (l + r) >> 1, ret = 0;
    if(mid >= s) ret = query(l, mid, s, t, p << 1);
    if(mid < t) ret += query(mid + 1, r, s, t, (p << 1) | 1);
    return ret;
}
int query2(int l, int r, int s, int t, int p) {
    if(s <= l && r <= t && minn[p] > 1)
        return 0;
    if(l == r)
        return (d[p] == 1) * max(0, c[l + 1] - c[l]);  // 查询时要恢复原本长度
    int mid = (l + r) >> 1, ret = 0;
    if(mid >= s) ret += query2(l, mid, s, t, p << 1);
    if(mid < t) ret += query2(mid + 1, r, s, t, (p << 1) | 1);
    return ret;
}
inline void modify(int l, int r, int o) { modify(1, csiz - 1, l, r, o, 1); }
inline int query(int s, int t) { return query(1, csiz - 1, s, t, 1); }
inline int query2(int s, int t) { return query2(1, csiz - 1, s, t, 1); }

inline int read() {
    int x = 0;
    char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x;
}
int main() {
    n = read(), m = read();
    for(int i = 1; i <= n; ++i)
        a[i] = read();
    for(int i = 1; i <= n; ++i)
        c[++csiz] = a[i], c[++csiz] = a[i] + m;
    sort(c + 1, c + csiz + 1);
    csiz = unique(c + 1, c + csiz + 1) - c - 1;  // 离散化
    for(int j = 1; j <= n; ++j) {
        int tx = a[j], ty = a[j] + m;
        tx = lower_bound(c + 1, c + csiz + 1, tx) - c;
        ty = lower_bound(c + 1, c + csiz + 1, ty) - c;
        modify(tx, ty - 1, 1);  // 标记每朵花覆盖的区间
    }
    PD_all(1, csiz - 1, 1);
    for(int i = 1; i <= n; ++i) {
        int tx = a[i], ty = a[i] + m;
        tx = lower_bound(c + 1, c + csiz + 1, tx) - c;
        ty = lower_bound(c + 1, c + csiz + 1, ty) - c;
        _ans = max(_ans, query(tx, ty - 1));
    }
    _ans += m;
    printf("%lld\n", 1ll * _ans + 1ll * query2(1, csiz - 1));  // 答案可能炸 int 所以用 long long
}
```

最慢的点只有 $243$ 毫秒，游刃有余，属于线段树解法中较快的了。

[提交记录](https://www.luogu.com.cn/record/170467186)。

---

## 作者：_O_v_O_ (赞：0)

一种可以让开放时长不相等而且不用高端数据结构的做法。

首先，我们假设 $s_i$ 为一朵花的关闭时间，即 $t_i+m-1$。

那么我们发现他们有一点大，就直接离散化一下，这样值域就来到了 $4\times 10^5$。

我们用一个数组 $a$ 来表示 $i$ 时刻的开放情况，那么我们就用可以让每个 $j\in[t_i,s_i]$ 的 $a_j\leftarrow a_j+1$，这一步可以用差分来完成。

那么初始的答案已经很明显了，就是每个 $a_i=1$ 的 $i$ 在原来对应的区间长度之和。

那么移走一朵花的贡献呢？

我们注意到，移走一朵花无非就是让 $j\in[t_i,s_i]$ 的 $a_j\leftarrow a_j-1$ 再统计答案，最后让答案 $+m$（因为一朵花肯定最优是移到 $10^9+1$），而对答案有影响的只有 $[t_i,s_i]$。

我们又注意到，$[t_i,s_i]$ 对答案的影响为 $b_{t_i,s_i}-c_{t_i,s_i}$，其中 $b_{l,r}$ 为 $a_{[l,r]}$ 中 $2$ 的数量，$c_{[l,r]}$ 中 $1$ 的数量。因为这样移动会造成 $[s_i,t_i]$ 的 $1$ 变为 $0$，$2$ 变为 $1$。

那么我们如何快速算出一个区间中 $0$ 和 $1$ 的数量呢？我们发现，这一步直接用前缀和就行了。

最后注意特判一下任何两个 $[s_i,t_i]$ 没有交集的情况。

代码有点长，就只放一下核心部分：


```cpp
set<int>::iterator it;//这里我用的 set 离散化。
int qwq=0;
for(it=st.begin();it!=st.end();it++){
	mp1[*it]=++qwq,mp2[qwq]=*it;
}
for(int i=1;i<=n;i++){
	t[i]=mp1[t[i]];
	s[i]=mp1[s[i]];
	a[t[i]]++;a[s[i]]--;
}//差分计算 a。
for(int i=1;i<=2*n;i++){
	a[i]+=a[i-1];
}
for(int i=1;i<=2*n;i++){
	if(a[i]==1){b[i]=1;if(mp2[i+1]!=0) cnt+=mp2[i+1]-mp2[i];}//计算初始答案。
	if(a[i]==2) c[i]=1;
	b[i]*=mp2[i+1]-mp2[i];
	c[i]*=mp2[i+1]-mp2[i];
	b[i]+=b[i-1];c[i]+=c[i-1];
}
for(int i=1;i<=n;i++){
	ans=max(ans,cnt+c[s[i]-1]-c[t[i]-1]-b[s[i]-1]+b[t[i]-1]+m);
}//计算移走一朵花的贡献。
cout<<ans;
```

---


# 奶牛排队

## 题目描述

奶牛在熊大妈的带领下排成了一条直队。

显然，不同的奶牛身高不一定相同……

现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 $A$ 是最矮的，最右边的 $B$ 是最高的，且 $B$ 高于 $A$ 奶牛。中间如果存在奶牛，则身高不能和 $A,B$ 奶牛相同。问这样的奶牛最多会有多少头？

从左到右给出奶牛的身高，请告诉它们符合条件的最多的奶牛数（答案可能是 $0,2$，但不会是 $1$）。

## 说明/提示

#### 样例解释

取第 $1$ 头到第 $4$ 头奶牛，满足条件且为最多。

#### 数据范围

对于全部的数据，满足 $2 \le N \le 10^5$，$1 \le h_i <2^{31}$。

## 样例 #1

### 输入

```
5
1
2
3
4
1```

### 输出

```
4```

# 题解

## 作者：一扶苏一 (赞：116)

## 【单调栈】【P6510】奶牛排队

### Analysis

怎么还有分治 RMQ 那么神仙的做法啊 /fad。

考虑枚举右端点 $B$。根据题意，因为左端点 $A$ 一定是最矮的，所以 $A$ 一定是当前序列（从 $1$ 到 $B$）的后缀最小值所在的位置。

因为 $B$ 一定是最高的，所以 $A$ 到 $B$ 之间不能有任何元素比 $B$ 高，因此 $A$ 的右侧一定只有 $B$ 一个位置可以作为当前序列的后缀最大值。换句话说，我们要找到从后向前数第二个后缀最大值的位置 $k$，$A$ 一定在该位置的右侧。并且只要 $A$ 在 $k$ 右侧且 $A$ 是当前序列的后缀最小值，那么 $A$ 就是一个合法的左端点。

考虑用单调栈来维护当前序列的后缀最大最小值，每次新枚举到一个 $B$ 时，先不将新位置入栈，此时的最大值栈顶就是第二个后缀最大值的位置。而维护后缀最小值的单调栈中的下标也是单调的，因此直接在最小值栈上二分即可找到最靠左的对应 $A$ 的位置。更新答案即可。时间复杂度 $O(n \log n)$。

下面说明如何用单调栈维护后缀最值：

因为最大值的方法与最小值基本相同，因此这里只考虑维护最大值。考虑用一个栈来维护当前序列的所有后缀最大值所在的位置的下标。当序列新加入一个元素时，一直弹栈直到栈顶元素所对应的值大于新元素，然后将新元素压入栈中即可。

```cpp
while (tx && a[sx[tx]] < a[i]) --tx;
sx[++tx] = i;
```

### Code

```cpp
#include <cstdio>
#include <set>
#include <algorithm>

const int maxn = 100005;

int n, ans, tx, tn;
int a[maxn], sx[maxn], sn[maxn];

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%d", a + i);
  for (int i = 1; i <= n; ++i) {
    while (tn && a[sn[tn]] >= a[i]) --tn;
    while (tx && a[sx[tx]] < a[i]) --tx;
    int k = std::upper_bound(sn + 1, sn + 1 + tn, sx[tx]) - sn;
    if (k != (tn + 1)) {
      ans = std::max(ans, i - sn[k] + 1);
    }
    sn[++tn] = i;
    sx[++tx] = i;
  }
  printf("%d\n", ans);
  return 0;
}

```



---

## 作者：LargeRice16pro (赞：58)

最优解诞生了，也许是因为数据水，，（也许）但是最优解诞生了。

~~拳打扶苏，脚踹出题人~~ 的最优解诞生了！！

简化题意：求一个区间，使得区间左端点最矮，区间右端点最高，且区间内不存在与两端相等高度是奶牛，输出这个区间的长度。

我们设左端点为 $A$ ，右端点为 $B$

因为 $A$ 是区间内最矮的，所以 $[A.B]$ 中，都比 $A$ 高。所以只要 $A$ 右侧第一个 $≤A$ 的奶牛位于 $B$ 的右侧，则 $A$ 合法

同理，因为B是区间内最高的，所以 $[A.B]$ 中，都比 $B$ 矮。所以只要 $B$ 左侧第一个 $≥B$ 的奶牛位于 $A$ 的左侧，则 $B$ 合法

（ 如果上述两个单调栈应用不会的，可以先看[[模板]单调栈](https://www.luogu.com.cn/problem/P5788) ）

对于 “ 左/右侧第一个 $≥/≤$ ” 我们可以使用单调栈维护。用单调栈预处理出 $z$ 数组表示左，$r$ 数组表示右。

然后枚举右端点 $B$ ，寻找 $A$ ，更新 $ans$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int s,h;
};
stack<node> q;
int h[100012],ans;
int z[100012],r[100012];
void clean()
{
	while(!q.empty())
	q.pop();
}
int main()
{
	int i,j;
	int n;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>h[i];
	}
    
	for(i=1;i<=n;i++)
	{
		while(!q.empty()&&q.top().h<h[i])
		q.pop();
		if(!q.empty())
		z[i]=q.top().s;
		else z[i]=0;
		node t;
		t.h=h[i];
		t.s=i;
		q.push(t);
	}//求左侧第一个≥h[i]的奶牛位置
	clean();
	for(i=n;i>=1;i--)
	{
		while(!q.empty()&&q.top().h>h[i])
		q.pop();
		if(!q.empty())
		r[i]=q.top().s;
		else r[i]=n+1;
		node t;
		t.h=h[i];
		t.s=i;
		q.push(t);
	}//求右侧第一个≤h[i]的奶牛位置
   
	for(i=n;i>=1;i--)//从大到小枚举是个技巧
	{
     //原本是for(j=1;j<i;j++) if(z[i]<j&&r[j]>i)
     //显然z[i]<j可以直接放在for里
     //还有此处是j<i不是j≤i，因为答案不能为1，我被坑了最后一个点
		for(j=z[i]+1;j<i;j++)
		{
			if(r[j]>i)
			{
				ans=max(ans,i-j+1);
				break;
			}
		}
		if(i<=ans) break;//最大的答案就是i
	}
	cout<<ans;
	return 0;
}
```
实测，手写栈 + 快读 + $O_2$  $65$ ms 。 无 $O_2$ ，$72$ ms（不排除这是评测机波动）
cin/cout + STL  $315$ ms

---

## 作者：Acestar (赞：36)

>**题意简述：**
>
>求出最长的区间，使得这个区间最左边的值在这个区间里最小，最右边的值在这个区间里最大。

## 单调栈

单调栈可以找出一个序列中的最大值和最小值，所以我们可以求出输入序列的两个最值，通过计算最大值和最小值之间的距离，再找出最长的就行了。

单调栈找最大值和最小值的思想是一样的，我就用找最大值来举例子。

枚举一遍序列，把序列按从大到小存进栈中，也就是越靠下对应的值越小（注意：栈里存的是下角标），最小值相反。代码实现：

```cpp
for(int i=1; i<=n; i++)
{
	while(t1&&c[s1[t1]]<c[i]) t1--;
	s1[++t1]=i;
}
```


在算最大值的同时，把最小值也算出来，这样我们就有了在任意时刻的最大值和最小值。

用栈 $s1$ 存最大值，$s2$ 存最小值，数组 $c$ 存输入。因为本题求的序列的右端点是最大值，所以我们可以枚举右端点，并算出合法的序列的长度。

假设我们已经算出了 $c_1\text{～}c_i$ 的答案区间的左端点为 $A$，右端点为 $B$，在算 $c_{i+1}$ 时，如果 $c_{i+1}>c_B$，就相当于把 $s1$ 里的元素全都弹出了只剩下 $c_{i+1}$，否则，就进栈顶。然后，我们就需要在 $s2$ 里找到第一个大于 $s1$ 中 $c_{i+1}$ 的前一个数，因为我们要保证区间里的最大值为 $c_{i+1}$ 并且 $s1$ 单调递减，$s2$ 单调递增，所以一定是合法的最小值，也就是长度最长，这里可以用二分。

最后，用 $ans$ 存最长区间的长度就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<stack>

using namespace std;

const int N=1e5+10;
int n,c[N],ans;
int s1[N],t1,s2[N],t2;

int Search()	//二分查找 
{
	int l=1,r=t2;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(s2[mid]>s1[t1]) r=mid-1;
		else l=mid+1;
	}
	return l;
}

int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&c[i]);
		while(t1&&c[s1[t1]]<c[i]) t1--;
		while(t2&&c[s2[t2]]>c[i]) t2--;
		int pos=Search();	//二分在s2中找第一个大于等于s1中c[i]的前一个数的值 
		if(pos!=t2+1) ans=max(ans,i-s2[pos]+1);	//如果s2中有符合上面条件的数，更新ans 
		s1[++t1]=i;
		s2[++t2]=i;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：syksykCCC (赞：28)

原本想给题目打的标签是 RMQ 和分治，结果被扶苏哥哥打上了栈和单调队列 qwq，查了一下他的代码，才发现自己实在是太弱小了。

![image.png](https://i.loli.net/2020/05/02/rIlJabgkY1wscVR.png)

代码长，耗时长，难度大 /kk

那分享一下我又臭又长的 RMQ 分治做法吧 qaq

**UPD：感谢 tommy0103, do\_while\_true 神仙指正时间复杂度问题。**

-----

比如我们用一个函数 $\operatorname{solve}(l, r)$ 表示处理 $h_l \sim h_r$ 的最大答案。

我们可以求出这一段里面的最大数（多个则取最靠左的）和最小数（多个则取最靠右的），记作 $h_{\min pos}$ 和 $h_{\max pos}$，这个可以用 ST 表之类随便维护。

然后分两种情况：

1. $\min pos \le \max pos$   
那么，$[\min pos, \max pos] $ 这一段就必然合法了，用他更新答案，然后，剩下的 $[l, \min pos)$ 和 $(\max pos, r]$ 分别递归求解，这是因为不可能有其他合法的段横跨了 $[\min pos, \max pos]$。

2. $\min pos > \max pos$   
显然，这个数列作为整体是不可能合法的了，而且不可能有合法段横跨 $[\max pos, \min pos]$。所以，这个数列可以分为三段求解：$[l, \max pos]$，$(\max pos, \min pos)$ 和 $[\min pos, r]$。

![image.png](https://i.loli.net/2020/05/02/cPHR61oZzE9Odua.png)

时间复杂度 $O(n \log n + n)$，当然这并没有考虑 `log` 函数自带的时间复杂度。

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <iostream>
#define REP(i, x, y) for(int i = x; i <= y; i++)

using namespace std;

const int N = 100005;
int n, h[N], f[20][N], g[20][N];

// namespace ST - begin

int qrymin(int l, int r)
{
	int k = log(r - l + 1) / log(2);
	int a = f[k][l], b = f[k][r - (1 << k) + 1];
	if(h[a] != h[b])
		if(h[a] < h[b]) return a; else return b;
	else
		if(a > b) return a; else return b;
}
int qrymax(int l, int r)
{
	int k = log(r - l + 1) / log(2);
	int a = g[k][l], b = g[k][r - (1 << k) + 1];
	if(h[a] != h[b])
		if(h[a] > h[b]) return a; else return b;
	else
		if(a < b) return a; else return b;
}

void build()
{
	REP(i, 1, n) f[0][i] = i, g[0][i] = i;
	for(int i = 1; 1 << i <= n; i++)
		for(int j = 1; j + (1 << i) - 1 <= n; j++)
		{
			int fa = f[i - 1][j], fb = f[i - 1][j + (1 << i - 1)];
			int ga = g[i - 1][j], gb = g[i - 1][j + (1 << i - 1)];
			if(h[fa] != h[fb])
				if(h[fa] < h[fb]) f[i][j] = fa; else f[i][j] = fb;
			else
				if(fa > fb) f[i][j] = fa; else f[i][j] = fb;
			if(h[ga] != h[gb])
				if(h[ga] > h[gb]) g[i][j] = ga; else g[i][j] = gb;
			else
				if(ga < gb) g[i][j] = ga; else g[i][j] = gb;
		}
}

// namespace ST - end

int ans;

void solve(int l, int r)
{
	if(r <= l) return;
	int maxpos = qrymax(l, r);
	int minpos = qrymin(l, r);
	if(maxpos >= minpos)
	{
		ans = max(ans, maxpos - minpos + 1);
		solve(l, minpos - 1);
		solve(maxpos + 1, r);
	}
	else
	{
		solve(l, maxpos);
		solve(maxpos + 1, minpos - 1);
		solve(minpos, r);
	}
}

int main()
{
	cin >> n;
	REP(i, 1, n) cin >> h[i];
	build();
	solve(1, n);
	if(ans == 1) ans = 0;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：StayAlone (赞：10)


$2021/5/25$ 对远古题解进行更好的排版并使用更严谨的表述~~再删除一些不友好的语言。~~

------------
作为本蒟蒻 A 的第一道绿题，这道题，我是用  
**ST区间最值问题+单调栈**做的。

[See-【模板】单调栈](https://www.luogu.com.cn/problem/P5788)  
[See-【模板】ST表](https://www.luogu.com.cn/problem/P3865)  

有不了解的可以先看看上面两道题。  

现在我们称：

- $l_i$ 表示 $A$ 数组中第 $i$ 个元素右侧的第一个小于等于 $A_i$ 的数的下标。
- $r_i$ 表示 $A$ 数组中第 $i$ 个元素左侧的第一个大于等于 $A_i$ 的数的下标。 

注：

- 数组下标由 $1$ 开始。  
- 当 $l_i$ 不存在时，定义它等于数组长度 $+1$。
- 同理，当 $r_i$ 不存在时，定义它等于 $-1$。

题目中提到：  
- 现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 $A$ 是最矮的，最右边的 $B$ 是最高的，且 $B$ 高于 $A$ 奶牛。中间如果存在奶牛，则身高不能和 $A,B$ 奶牛相同。

它的等价关系为：

- **当 $l_i>j \land r_i<i \land i \leqslant j$ 时，区间 $[i, j]$ 合法**

那当 $A$ 确定时，怎样的 $B$ 是最优的呢？ 

仔细思考后，易得：  
在区间 $[A+1, l_A-1]$ 中的最大值的下标即为最优的合法的 $B$。

现在的思路很明了：$O(n)$ 枚举 $A$ 并找到此时所对应的最优 $B$，利用 $ans$ 记录最长的长度。

用一个单调栈维护一个单调递增的序列，记录每个 $A$ 所对应的 $l_A$ ,这里是 $O(n)$ 的时间复杂度。  


```cpp
void l() //B数组用于存储l[A], st是栈, A数组是奶牛的身高
{
	for (int i = n+1; i >= 1; --i)
	{
		while (!st.empty() && a[i] < st.top().h) st.pop();
		if (!st.empty()) b[i] = st.top().idx;
		if (!st.empty() && a[i] <= st.top().h) continue;
		node x;
		x.h = a[i], x.idx = i;
		st.push(x);
	}
}
```

ST 算法求区间最值问题时，我对它进行了改动，$f_{i, j}$ 不用来存一个数，用来存**最大值的下标**。

```cpp
void ST_Pretreatment()
{
	for (int i = 1; i <= n; ++i)	f[i][0] = i;
	int t = log2(n);
	for (int j = 1; j <= t; ++j)
		for (int i = 1; i <= n - (1 << j) + 1; ++i)
		{
			int l = f[i][j-1], r = f[i + (1 << (j-1))][j-1];
			f[i][j] = a[l] < a[r] ? r : l; 
		}		
}

int ST_query(int l, int r)
{
	int k = log2(r-l+1);
	int L = f[l][k], R = f[r - (1 << k) + 1][k];
	return a[L] < a[R] ? R : L; 
}
```
注意：请仔细思考，为什么 $a_l = a_r$ 时，$f_{i, j} = l$。  

题中说到，$A$ 到 $B$ 中，$B$ 的高度不能与其他重复，因此如果 $f_{i, j}= r$，会出现 $A$ 到 $B$ 中，$B$ 与某个值重复的情况。

小坑：1 3 3 2 4 合法，因为 $A$ 到 $B$ 内的元素**可以重复且不必要递增**。
 
这道题结束了！整体时间复杂度为 $O(nlogn)$。  

[AC code记录](https://www.luogu.com.cn/record/48691265)

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[100010][20], n, a[100010], b[100010], ans = INT_MIN;
struct node
{
	int idx, h;
};
stack <node>st;
void ST_Pretreatment()
{
	for (int i = 1; i <= n; ++i)	f[i][0] = i;
	int t = log2(n);
	for (int j = 1; j <= t; ++j)
		for (int i = 1; i <= n - (1 << j) + 1; ++i)
		{
			int l = f[i][j-1], r = f[i + (1 << (j-1))][j-1];
			f[i][j] = a[l] < a[r] ? r : l; 
		}		
}

int ST_query(int l, int r)
{
	int k = log2(r-l+1);
	int L = f[l][k], R = f[r - (1 << k) + 1][k];
	return a[L] < a[R] ? R : L; 
}

void l()
{
	for (int i = n+1; i >= 1; --i) //n+1是为了应对l[i]不存在的情况
	{
		while (!st.empty() && a[i] < st.top().h) st.pop();
		if (!st.empty()) b[i] = st.top().idx;
		if (!st.empty() && a[i] <= st.top().h) continue;
		node x;
		x.h = a[i], x.idx = i;
		st.push(x);
	}
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", a+i);
	ST_Pretreatment(); l();
	for (int i = 1; i <= n; ++i)
		if (i + 1 <= b[i] - 1) ans = max(ans, ST_query(i+1, b[i]-1)-i+1);
	if (ans < 0) ans = 0;
	printf("%d", ans);
	return 0;
}
```

非正解 ~~(数据弱)~~  

有兴趣 A 了这道题再来看。

[错得不能再错1](https://www.luogu.com.cn/record/48688875)

此代码中，$fi$ 函数里的 $for$ 循环不能反过来，否则会出现 $A$ 到 $B$ 中，$B$ 与某个值重复的情况 ~~(这是我第一次 AC 的代码，问题被老师发现了呢)~~。  

[错得不能再错2](https://www.luogu.com.cn/record/48691319)

此代码中，虽然函数顺序改过来了，但是最坏情况下是 $O(n^2)$ 的时间复杂度，不应该 AC ~~(还是那个巨佬老师发现的)~~。  

巨佬老师 = @[Chery](https://www.luogu.com.cn/user/180875)


---

## 作者：sukimo (赞：8)

这道题思路不算太难想。题中的“左边最矮”“右边最高”等信息让我们考虑使用单调栈来快速处理。

首先用单调栈处理出每头奶牛左边第一个身高大于等于它的奶牛位置$+1$的位置（$le$数组）以及右边第一个身高小于等于它的奶牛位置$-1$的位置（$ri$数组）。为什么呢？这样做，我们就框定了每头奶牛分别作为合题奶牛组的左端点$A$和右端点$B$时，剩余的端点$B$，$A$可取的范围。接下来我们发现，若两只奶牛$i,j(i<j)$符合$ri[i]\ge j$且$le[j]\le i$，则它们定可以分别作为合题奶牛组的$A,B$端点。很好证。

接下来就用一个枚举，枚举每头奶牛作为端点$B(A$也可以$)$时的最大满足数。中间可以加一些技巧性的小剪枝加速。详见代码：

```
#include<bits/stdc++.h>
using namespace std;
const int MX=100005;int n,le[MX],ri[MX],cow[MX];struct STR{int pos,num;};stack<STR>stk;
STR pack(int pos,int num){STR a;a.pos=pos;a.num=num;return a;}
void stk_push1(){
	for(int i=1;i<=n;i++){
		while(!stk.empty()&&stk.top().num<cow[i])stk.pop();
		le[i]=(stk.empty()?1:stk.top().pos+1);stk.push(pack(i,cow[i]));
	}
}
void stk_push2(){
	for(int i=n;i>=1;i--){
		while(!stk.empty()&&stk.top().num>cow[i])stk.pop();
		ri[i]=(stk.empty()?n:stk.top().pos-1);stk.push(pack(i,cow[i]));
	}
}
int main(){
	int max_cnt=0;scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&cow[i]);
	stk_push1();while(!stk.empty())stk.pop();stk_push2();
	for(int i=1;i<=n;i++)
		for(int j=le[i];j<i;j++){
			if(i-j+1<=max_cnt)break;
			if(ri[j]>=i){max_cnt=max(max_cnt,i-j+1);break;}
		}
	printf("%d",max_cnt);
	return 0;
}
```


---

## 作者：Durancer (赞：8)

#### 前言

可以利用单调栈维护一下最大值和最小值，查找的时候保证区间内的所有大于等于右端点的值出现的时间比一个最小值小，那么就可以构成一个区间

看了两篇题解理解了好久才缓过来，所以想写一篇更好理解的=_=，还是太弱

#### 思路

首先，设两个数组$s_1,s_2$

$s_1$ 用来维护所在区间内比当前枚举的区间右端点值$a[i]$ 小的编号

$s_2$ 用来维护所在区间内比当前枚举的区间端点大，或者等于的点的编号

有单调栈的性质可以发现，越靠近队头的点出现的越早。

因为有着单调栈的维护，所以我们只需要来考虑保证符合条件的区间的长度更长即可

所以根据性质我们就需要找到出现在更前面的点符合条件

那么就需要在 $s_1$ 数组中找出第一个比 $s_2$ 中出现最晚的点出现更晚的点的标号，设该点的在数组的标号为$t$,那么区间的长度为$i-s_1[t]+1$

取一个最大值即可

#### 代码

```
/*
    求出最长的区间，使得这个区间最左边的值在这个区间里最小，最右边的值在这个区间里最大。
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm> 
#define int long long 
using namespace std;
const int N=1e5+9;
int n;
int ans;
int top1,top2,s1[N],s2[N],a[N];
void work()
{
    for(int i=1;i<=n;i++)
    {
        while(top1!=0&&a[s1[top1]]>=a[i]) 
            top1--;
		while(top2!=0&&a[s2[top2]]<a[i]) 
            top2--;
            cout<<endl;
		int k=upper_bound(s1+1,s1+1+top1,s2[top2])-s1;
		if(k!=(top1+1)){if(ans<i-s1[k]+1) ans=i-s1[k]+1;}
		s1[++top1]=i;
		s2[++top2]=i;
    }
} 
signed main()
{
    scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	work();
	printf("%lld",ans);
	return 0;
} 
```


---

## 作者：Na2PtCl6 (赞：8)

扶苏哥哥已经把这种做法讲清楚了，我就来写一篇 STL 的题解罢。
## 分析题目
题目要我们求原序列中一个满足如下性质的子段 $s$

> 设其长度为 $l$ ，则 $\lbrace$ ${s_1<s_2 (l=2)} \atop s_1<s_i<s_l(1<i<l~and~l>2)$ 

且最长。

我们可以考虑用两个单调栈来解决，$v1$ 维护原序列中位于 $a_i$ 前且比 $a_i$ 小的数的 **下标**，$v2$ 维护原序列中位于 $a_i$ 前且 $\ge a_i$ 的 **下标**。

我们从前往后枚举序列的每个元素 $a_i$ ，用 $v2$ 的栈顶——即 **当前从后向前数第二个后缀最大值** 下标 $x$ ，在 $v1$ 中找出第一个比 $x$ 大的下标 $p$。这样，就保证了我们找到的是一个合法的子段，除非找到的位置是 $v2$ 的尾迭代器。如果这个子段合法，就把答案和 $(i-p+1)$ 的值比较、更新，然后将 $i$ 推入两个栈中。

下面简单演示一下这份数据

```
7
2 3 3 4 5 5 1
```
\* 以下的入栈意义为同时将 $i$ 推入两个栈中。
-  一开始 $v1,v2$ 都为空，不更新答案，$1$ 入栈；
- $v2$ 栈顶的 $a_1$ 比 $3$ 小，栈空，所以此时的最大子段为 $s=\{2,3\}$，$2$ 入栈；
- $v1$ 栈顶的 $a_2 \le 3$，栈中留下 $1$，`upper_bound` 找到的位置是 $1$ ，明显，这个子段不符合性质，舍去。$3$ 入栈；
- $v2$ 栈顶 $a_2 = a_3 < 4$，栈空，所以此时的最大子段为 $s=\{2,3,3,4\}$，$4$ 入栈；
- $v2$ 栈顶 $a_4 < 5$ ,栈空，所以此时的最大子段为 $s=\{2,3,3,4,5\}$，$5$ 入栈；
- $v1$ 栈顶 $a_5 \ge 5$ ,出栈。`upper_bound` 找到的位置是 $3$ ，明显，这个子段不符合性质，舍去。
- $v1$ 栈顶 $1 < a_1 < a_3 < a_4$，栈空，不会有合法子段。

## 代码实现
用 `std::vector` 实现两个单调栈。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,res,a[100004];
vector < int > v1,v2;

const int _max(const int &a,const int &b){
	return a>b?a:b;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		while(v1.size()&&a[v1.back()]>=a[i])
			v1.pop_back();
		/*printf("v1:");
		for(int j=0;j<v1.size();j++)
			printf("%d ",v1[j]);*/
		while(v2.size()&&a[v2.back()]<a[i])
			v2.pop_back();
		/*printf(" | v2:");
		for(int j=0;j<v2.size();j++)
			printf("%d ",v2[j]);*/
		//如果栈中没有元素,就找0,此时最长的奶牛序列为1~i 
		int val=v2.size()?v2.back():0; 
		int p=upper_bound(v1.begin(),v1.end(),val)-v1.begin();
		//printf(" | pos=%d\n",p);
		if(p!=v1.size())
			res=_max(res,i-v1[p]+1);
		v1.push_back(i);
		v2.push_back(i);
	}
	printf("%d",res);
	return 0;
}
```
代码里有彩蛋哦。

---

## 作者：神眷之樱花 (赞：8)

### 解析
我自己做的时候把题意理解错了，交了很多遍，唉。

这道题其实也就是维护两个单调栈，$s1$ 单调递减，$s2$ 单调递增，注意栈里存储的是奶牛身高的下标，然后在 $s1$ 里找出第一个小于等于 $s2$ 栈顶的数，然后比较符合条件的数比较出最大值，就能找到答案了。

注意中间奶牛的身高是可以相等的。

写一个快读优化能节约很多时间。
### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
inline int read()
{
	int x=0,flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch-'0');ch=getchar();}
	return x*flag;
}
int n,top1=0,top2=0,s1[N],s2[N],a[N];
unsigned long long ans=0; 
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		while(top1!=0&&a[s1[top1]]>=a[i]) top1--;
		while(top2!=0&&a[s2[top2]]<a[i]) top2--;
		int k=upper_bound(s1+1,s1+1+top1,s2[top2])-s1;//STL
		if(k!=(top1+1)){if(ans<i-s1[k]+1) ans=i-s1[k]+1;}
		s1[++top1]=i;
		s2[++top2]=i;
	}
	printf("%lld",ans);
	return 0;
} 
```


---

## 作者：do_while_true (赞：4)

分治过程中 RMQ 。

考虑一段区间 $[L,R]$ 内，能确定的一段解是 $[pos1,pos2]$ ，其中 $pos1$ 无法向左扩展，$pos2$ 无法向右扩展，那么 $pos1$ 和 $pos2$ 究竟怎么找才能使得这个成立？~~凭直觉~~想出 $pos1$ 为 $[L,R]$ 中区间最靠右的最小值，$pos2$ 为 $[pos1,R]$ 中最靠左的最大值。因为如果 $pos1$ 向左移动，则原本 $pos1$ 的位置一定比新位置小，不符合题意；$pos2$ 向右移动也同理。

这个可以通过 ST表 来 $\mathcal{O}(1)$ 求得。

这个 $[pos1,pos2]$ 是 $[L,R]$ 内无法再拓展的一个解，之后再递归求得 $[L,pos1 - 1]$ 的解和 $[pos2+1, R]$ 的解，取最大值即可。值得注意的是，其中如果 $L=R$ ，则答案应为 $0$ 。

怎样预处理 ST表？

因为要求最小/最大的数的位置，所以用结构体同时记录区间最大值及其位置和区间最小值及其位置即可，比较大小为选择 $pos1,pos2$ 的方式。

时间复杂度？

因为每次会分成 $[L,pos1 - 1],[pos2+1, R]$ 两段，其中合并直接取最大值即可，最坏情况下整个序列都是单调递减的序列，其中每次 $pos1$ 都会取到 $R$ ，则每次递归下去只是序列减少了最后一个数，一共会减少 $n$ 次。故时间复杂度最坏为 $\mathcal{O}(n)$ 。（鉴于笔者能力只能这样分析）

加上预处理 ST表 的 $\mathcal{O}(n \log n)$，总时间复杂度为 $\mathcal{O}(n \log n + n)$。

### $\mathcal{Code}$

```cpp
#include<iostream>
#include<cstdio>
const int N = 100010;
int n;
int lg[N];
struct Node {
	int pos, dis;
}st1[N][32], st2[N][32];
inline Node Min(Node x, Node y) { return (x.dis == y.dis ? x.pos > y.pos : x.dis < y.dis) ? x : y; }
inline Node Max(Node x, Node y) { return (x.dis == y.dis ? x.pos < y.pos : x.dis > y.dis) ? x : y; }
inline int intMax(int x, int y) { return x > y ? x : y; }
inline int intMin(int x, int y) { return x < y ? x : y; }
inline int read() {
	int r = 0, w = 1;
	char ch = getchar() ;
	while(ch < '0' || ch > '9') {
		if(ch == '-') w = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		r = (r << 3) + (r << 1) + (ch ^ 48);
		ch = getchar();
	}
	return r * w;
}
void pre() {
	for(int i = 1; i <= n; ++i) lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);
	for(int i = 1; i <= n; ++i) --lg[i];
	for(int j = 1; j <= 30; ++j)
		for(int i = 1; i + (1 << j) - 1 <= n; ++i)
			st1[i][j] = Min(st1[i][j - 1], st1[i + (1 << j - 1)][j - 1]);
	for(int j = 1; j <= 30; ++j)
		for(int i = 1; i + (1 << j) - 1 <= n; ++i)
			st2[i][j] = Max(st2[i][j - 1], st2[i + (1 << j - 1)][j - 1]);
}
Node querymin(int l, int r) {
	int k = lg[r - l + 1];
	return Min(st1[l][k], st1[r - (1 << k) + 1][k]);
}
Node querymax(int l, int r) {
	int k = lg[r - l + 1];
	return Max(st2[l][k], st2[r - (1 << k) + 1][k]);
}
int work(int l, int r) {
	if(r - l + 1 <= 1) return 0;
	int pos1 = querymin(l, r).pos;
	if(pos1 == r) return work(l, r - 1);
	int pos2 = querymax(pos1 + 1, r).pos, ans = pos2 - pos1 + 1;
	if(l < pos1) ans = intMax(ans, work(l, pos1 - 1));
	if(r > pos2) ans = intMax(ans, work(pos2 + 1, r));
	return ans;
}
signed main() {
	n = read();
	for(int i = 1; i <= n; ++i) st1[i][0].dis = st2[i][0].dis = read(), st1[i][0].pos = st2[i][0].pos = i;
	pre();
	printf("%d\n", work(1, n));
	return 0;
}
```

---


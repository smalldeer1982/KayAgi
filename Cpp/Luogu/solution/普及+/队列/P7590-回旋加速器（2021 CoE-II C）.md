# 回旋加速器（2021 CoE-II C）

## 题目描述

回旋加速器（$\text{Cyclotron}$）是利用磁场和电场使带电粒子作回旋运动并经高频电场反复加速的装置，是高能物理中的重要仪器。

我们来研究回旋加速器的一个简化模型。将回旋加速器视为一个环形的轨道，轨道上设置了 $n$ 个加速腔，依次编号为 $1$ 至 $n$。将一束质子从某个加速腔导入，在导入时，质子束的动能为零。第 $i$ 个加速腔能够为质子束提供 $e_i$ 的动能 ，质子束从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔会损失 $d_i$ 的动能（由于是环形轨道，编号为 $n$ 的加速腔后面是编号为 $1$ 的加速腔）。

给定每个加速腔能够提供的动能值以及质子束在各个加速腔之间运行所损失的动能值，试确定质子束能否绕环形轨道运行一周。如果能够成功，应该选择从哪个加速腔导入质子束。质子束在两个加速腔之间运行时，动能不能为零，但质子束刚到达加速腔时，动能可以为零，因为可以立即获得加速腔所提供的动能。

## 说明/提示

**样例说明**

输入 #1

该组输入共有 $3$ 个加速腔，依次能够提供的动能为 $1$、$2$、$3$。从第 $1$ 个加速腔运行到第 $2$ 个加速腔损失 $2$ 动能，从第 $2$ 个加速腔运行到第 $3$ 个加速腔损失 $3$ 动能，从第 $3$ 个加速腔运行到第 $1$ 个加速腔损失 $4$ 动能。不管从哪个加速腔导入质子束，都会使得质子束在两个加速腔运行过程中动能变为零，无法环绕轨道一周。

输入 #2

该组输入共有 $10$ 个加速腔，如果从第 $1$ 个加速腔导入质子束，将获得动能 $1$，但是在从第 $1$ 个加速腔运行到第 $2$ 个加速腔的过程中会损失 $3$ 动能，因此会使得质子束无法环绕轨道一周。而从第 $2$ 个到第 $10$ 个加速腔中的任意一个导入质子束，均能保证质子束在加速腔之间运行时动能不为零，因此都可作为导入质子束的加速腔，但编号为 $2$ 的加速腔具有最小的编号。需要注意，从第 $2$ 个加速腔导入质子束，当运行到第 $3$ 个加速腔时，动能恰为零，根据题意，这种情形是允许的。

------------


**数据范围**

- Subtask $1$：$2 \le n \le 10$，$10$ 分。
- Subtask $2$：$2 \le n \le 10^3$，$30$ 分。
- Subtask $3$：$2 \le n \le 10^5$，$30$ 分。
- Subtask $4$：$2 \le n \le 10^6$，$30$ 分。

对于 $100\%$ 的数据，$1 \le T \le 20$，$0 \lt e_i \le 100$，$0 \lt d_i \le 100$。



------------

**约定**

质子束的运行方向规定为：从第 $1$ 个加速腔到第 $2$ 个加速腔，从第 $2$ 个加速腔到第 $3$ 个加速腔$\cdots$从第 $n$ 个加速腔到第 $1$ 个加速腔。

## 样例 #1

### 输入

```
1

3
1 2 3
2 3 4```

### 输出

```
Failed!```

## 样例 #2

### 输入

```
1

10
1 2 3 4 5 6 7 8 9 10
3 2 1 2 3 4 5 6 7 8```

### 输出

```
2```

# 题解

## 作者：metaphysis (赞：12)

朴素的做法就是从每一个加速腔开始，遍历整个环形管道，然后找出最后剩余动能最大的加速腔，这是 $O(n^2)$ 的方法。

如果认真加以思考，本题与求最大连续子数组和相似。在任何一个加速腔，我们只关心动能的损耗，定义 $add[i]$ 为第 $i$ 个加速腔能够为质子束提供的动能，$loss[i]$ 为从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔时所损耗的动能，进一步定义：

$$diff[i] = add[i] - loss[i]$$


那么这道题目包含两个问题：（1）能否在环上绕一圈？（2）如果能，这个加速腔在那里？

第一个问题很简单，对 $diff$ 数组做个加和就好了，$energy = \sum diff[i]$，如果最后 $energy$ 是非负值，那么肯定存在这样的一个加速腔。如果是负值，动能的损耗大于动能的供给，不可能有解。得到第一个问题的答案只需 $O(n)$。

对于第二个问题，起始加速腔在哪里？假设我们从环上取一个区间 $[i,j],j \gt i$，然后对于这个区间的 $diff$ 加和，定义

$$sum[i, j] = \sum diff[k], i \le k \lt j$$

如果 $sum[i, j]$ 小于 $0$，那么这个加速腔肯定不会在 $[i, j]$ 这个区间里，跟第一个问题的道理相似。例如，假设 $i$ 是 $[1, n]$ 的解，那么我们知道任意 $sum[k, i-1](1 \le k \lt i-1)$ 肯定是小于 $0$，否则解就应该是 $k$。同理，$sum[i, n]$ 一定是非负的，否则，解就不应该是 $i$，而是 $i$ 和 $n$ 之间的某个加速腔。所以第二个问题的答案就是在 $1$ 到 $n$ 之间找到加和为非负值的第一个连续子序列，注意，这个连续子序列的结尾必然是 $n$。

参考代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 1e6 + 10;
int n, ei[MAXN], di[MAXN], diff[MAXN];

int main(int argc, char *argv[])
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
    int cases;
    cin >> cases;
    for (int cs = 1; cs <= cases; cs++)
    {
        cin >> n;
        for (int i = 0; i < n; i++) cin >> ei[i];
        for (int i = 0; i < n; i++) cin >> di[i];
        for (int i = 0; i < n; i++) diff[i] = ei[i] - di[i];

        int energy = 0, sum = 0, idx = 0;
        for (int i = 0; i < n; i++)
        {
            energy += diff[i];
            sum += diff[i];
            if (sum < 0)
            {
                idx = i + 1;
                sum = 0;
            }
        }
        if (energy < 0) cout << "Failed!\n";
        else cout << (idx + 1) << '\n';
    }
    return 0;
}
```

---

## 作者：mydcwfy (赞：5)

## 0. 前置知识 & 废话

说实话，出题人的办法我没太看懂，于是就想了另外一种方法。

本题解需要你掌握：单调队列

[本算法位置](https://www.luogu.com.cn/problem/P1886)

时间复杂度仍为 $O(n)$，但常数较标程略大，故需要点 ~~玄学优化~~。

## 1. 题意

给你一个环，每一个点都可以加一定的权值 x，从一个点到下一个点都要减少一定的权值，要保证随时都要 $x\geq0$，可以在一个点时恰好为 0。

从每一个点开始时，权值都等于 0。

如果有一个点可以运动 1 周，输出最小编号，否则输出 "Failed!"。

## 2. 思路

出题人的方法我确实没看懂。

### 1）朴素

首先考虑朴素算法。

定义
$$
d[x]=a[x]-b[x],sum[x]=\sum_{i=1}^{x}d[i]
$$
所以如果从 i 可以到 i+1，需要满足：
$$
a[i]=sum[i+1]-sum[i]\geq 0
$$
我们可以考虑将环拆成 2 倍的链。

如果从 i 可以的话，需要满足：
$$
\forall j\in [i,i+n-1],sum[j]\geq sum[i-1]
$$
时间复杂度为 $O(n^2)$，期望得分 30 分。

[代码放置处](https://www.luogu.com.cn/paste/oewr50t0)

实际打代码时，我们可以以它为对拍代码。

### 2）堆优化

其实，我们不难发现，对于该式，我们可以使用堆优化。

时间复杂度 $O(n\log n)$，期望得分 70 分。

不放代码了 ~~逃~~。

### 3）单调队列

我们进一步挖掘性质，可以发现，我们需要的是 $[i,i+n-1]$ 的最小值，且 i 不断变大。

这难道不是和单调队列相似吗？

那么就可以了。

如果 $j<k,sum[j]>sum[k]$，那么 j 不可能成为某个点的最小值。

维护一个单调队列，使其保持递增的顺序。

队头是最小值。

那么就可以了 吗？ ~~雾~~。

单调队列虽然是 $O(n)$,但常数相对于标程更大，而最大 $\sum n=2\times 10^7$，很可能超时。

## 3. 常数优化

1. 我开始 scanf+O2 竟然超时了，所以快读是时候了。
2. 听说 register 可以加快，用一用也不错。

这样一阵 ~~玄学~~ 优化后，我们就不用 O2 最大点也可以只用 600ms 就过了。

## 4. 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define re register
#define ll long long
using namespace std;

const int N=1e6+10;

ll d[2*N],sum[2*N];
int hh,tt,q[2*N];
char c;

void insert(int x)
{
	while (hh<=tt&&sum[q[tt]]>=sum[x]) tt--;
	q[++tt]=x;
	return;
}

void get(int &x)
{
    while ((c=getchar())<'0'||c>'9') ;
    x=c-'0';
    while ((c=getchar())>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0';
}

int main()
{
	// freopen("randdata.in","r",stdin);
	// freopen("myans.out","w",stdout);
	re int cas,n,x;
	get(cas);
	while (cas--)
	{
		get(n);
		for (re int i=1;i<=n;++i) get(x),d[i]=x;
		for (re int i=1;i<=n;++i)
		{
			get(x);
			d[i]-=x;
		}
		for (re int i=1;i<=n;++i) d[i+n]=d[i];
		for (re int i=1;i<=2*n;++i) sum[i]=sum[i-1]+d[i];//,cout<<sum[i]<<' ';
		hh=1;tt=0;
		for (re int i=1;i<=n;++i) insert(i);
		re bool flag=0;
		for (re int i=1;i<=n;++i)
		{
			while (hh<=tt&&q[hh]<i) hh++;
			insert(i+n-1);
			// printf("%d %d\n",hh,tt);
			if (sum[i-1]<=sum[q[hh]])
			{
				printf("%d\n",i);
				flag=1;
				break;
			}
			
		}
		if (!flag) puts("Failed!");
	}
	return 0;
}

```





---

## 作者：dying (赞：3)

# Solution P7590 回旋加速器

[**博客食用更佳**](https://dying.blog.luogu.org/hui-xuan-jia-su-qi)

这道题就是个结论题。

## 简化题意：
质子在一个加速器得到的动能减去失去的动能，其实就可以看作质子到达这里之后发生的动能变化（可能为负）。于是可以定义一个数组 $c$ 来存放动能变化值，可以继续运行的条件即为到达此处的动能（动能变化的前缀和）大于等于 $0$。

可以发现，如果从第一个加速器开始，能否经过一个地方即为 发生的动能变化的前缀和在此处是否大于等于 $0$。

原题即可转换为：能否在 $c$ 中找到一个位置，将这个位置之前的数放到数组最后，使前缀和的每一项都大于0。即：

$$\sum\limits_{i=1}^xc_i\ge0,1\le x\le n$$

## 解题分析：

### 环绕一周的条件：
当环绕一周消耗的动能比得到的动能大，那么它肯定不能完整环绕一周。故有答案的条件为满足 $\sum\limits_{i=1}^nc_i\ge0$。

### 寻找答案的位置
题目要求是要找到编号最小的位置。

先把结论拉出来，答案就是前缀和中最小的位置。

为什么它满足要求？

**反证法**

如果不满足要求，设前缀和中最小的位置为 $c_x$，后方不满足要求的位置为 $c_y$，则有：

$$
\begin{aligned}
&\because \ \sum\limits_{i=1}^y c_i\geqslant\sum\limits_{i=1}^x c_i\\
&\therefore \sum\limits_{i=x+1}^y c_i\geqslant0\\
\end{aligned}
$$

与假设不符。

若不满足要求的点在前方，设其为 $c_y$ ，

$$
\begin{aligned}
&\because \ \sum\limits_{i=1}^y c_i>\sum\limits_{i=1}^x c_i\\
&\therefore \sum\limits_{i=y+1}^x c_i<0\\
&\because \ \sum\limits_{i=1}^nc_i>0\\
&\therefore \ \sum\limits_{i=1}^yc_i+\sum\limits_{i=x+1}^nc_i=\sum\limits_{i=1}^nc_i-\sum\limits_{i=y+1}^x c_i>0
\end{aligned}
$$

**不符合假设，证毕**

为什么它最小？

**同样，反证法**

设前缀和最小位置为 $c_x$ ，如果有比它更下标更小又满足条件的值，设它为 $c_y$，因为 $c_x$ 位置是首个最小的前缀和，所以  $\sum\limits_{i=y+1}^xc_i<0$。

$$
\begin{aligned}
&\because \ \sum\limits_{i=1}^y c_i>\sum\limits_{i=1}^x c_i\\
&\therefore \sum\limits_{i=y+1}^x c_i<0\\
\end{aligned}
$$

**不满足要求，证毕**

综上所述，答案为前缀和数组 $c$ 的第一个最小值的下标。

说到这里，代码应该都会写了吧。蒟蒻因为在写第一题时内存刚刚卡到128M，导致
$\mathsf{\color{#52C41A}AC}:{\mathsf\color{#052242}{MLE}}\ \thickapprox\frac13$，
分数在80~100间波动，所以对内存特别珍视，下面的代码应该看得出来。除了这个个人认为代码可读性较高。

code：
```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void print(int a){
	if(a<0)putchar('-'),a=-a;
	if(a>=10)print(a/10);
	putchar(a%10+48);
}

int t=read();
int pl[1000010];

signed main(){
	while(t--){
		int n=read(),*min=pl;
		for(int i=1;i<=n;i++)pl[i]=read();
		for(int i=1;i<=n;i++){
			pl[i]+=pl[i-1]-read();//得到的能量减去损失的能量&&计算前缀和
			if(pl[i]<*min)min=pl+i;//找到最小前缀和的位置
		}
		if(pl[n]>=0)print(min-pl+1),putchar('\n');
		else puts("Failed!");
	}
	return ~EOF;
}

```
**完结撒花！！！**

---

## 作者：Lawrenceling (赞：1)

## 前言 
单队好题，没想到这题能这么妙。

这篇题解是对于其他题解的补充和详解，力求通俗易懂，有什么疑问或质疑可以提出qwq。

## 题意
给定一个长度为 $n$ 的环形数列，对于第 $i$ 个点会获得 $a_i$ 的动能并且损失 $b_i$ 的动能，当某时刻动能小于 0，即失败。求所有作为起点可以绕完一圈的点。

可以去[这里](https://www.luogu.com.cn/problem/P7590)查看更详细的题面。

## 解法
出题人给的是另一种算法，我尽量对两种方法都做解释。
### 思路一 单调队列
很容易想到对于 $a$ 和 $b$ 做差，我们记 $c_i=a_i-b_i$。

我们考虑破环成链，如果 $i$ 腔满足条件（即可以作为起点），那么对于任意的 $j\ne i$，都有：

$$\sum^{j}_{k=i} c_k \ge 0$$

再用前缀和记录 $c$ 的值，记为 $s$ 数组。  
不难发现可以用前缀和优化，时间复杂度为 $O(n^2)$。

进一步优化，我们发现，如果 $i$ 腔满足条件，那么对于任意的 $j\ne i$，只要其最小的 $s_j\ge 0$，那么就可以成功了。

于是可以用单调队列求出每一个 $[i,i+n-1]$ 的最小值，看其减去 $s_{i-1}$ 是否为非负数（因为是前缀和），可以的话便满足条件了。

> 总之，对于每一个起点 $i$：
> - 删除不合法队头；
> - 将 $i+n-1$ 加进队尾；
> - 判断是否成功；

### 思路二 官方正解
$s$ 还是原来的意思，我们记 $f(i,j)=s_j-s_{i-1}$。

~~第一问跳过了啊。~~

如果 $f(i,j)<0$，那么这个加速腔肯定不会在 $[i,j]$ 这个区间里，无需解释。

无解被判掉之后，接下来假设 $i$ 是解，那么：
- 任意的 $j \in [1,i-1]$，值 $f(j,i)$ 肯定为负数。这样 $j$ 就不可能走过来了。  
  **否则解就应该是 $j$。**
  
- 任意的 $j \in [i,n]$，值 $f(j,n)$ 肯定为非负数。很好理解吧。   
  **否则，解就不应该是 $i$，而是后面的某个加速腔。**

![](https://cdn.luogu.com.cn/upload/image_hosting/knzbb7ub.png)

自认为讲的很清楚了，希望过审qwq。

## AC CODE 
好题，这里用的是第一种方法。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=2e6+10;
int a[N],b[N];
int q[N],s[N];

inline int Read()
{
	int f=1,x=0;
	char ch=getchar();
	while(!isdigit(ch) && ch^'-')ch=getchar();
	if(ch=='-')f=-1,ch=getchar();
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return x*f;
}

signed main()
{
	int t=Read();
	while(t--)
	{
		int n=Read();
		for(int i=1;i<=n;++i)a[i]=a[i+n]=Read();
		for(int i=1;i<=n;++i)b[i]=b[i+n]=Read();
		for(int i=1;i<=(n<<1);++i)s[i]=s[i-1]+(a[i]-b[i]);
		
		int sum=0,h=1,t=0;
		for(int i=1;i<=n;++i)
		{
			sum+=(a[i]-b[i]);
		}
		if(sum<0)
		{
			puts("Failed!");
			continue;
		}
		
		for(int i=1;i<=n;++i)
		{
			while(h<=t && s[q[t]]>=s[i])q[t--]=0;
			q[++t]=i;
		}
		for(int i=1;i<=n;++i)
		{
			int id=i+n-1;
			while(h<=t && q[h]<i)h++;
			while(h<=t && s[q[t]]>=s[id])q[t--]=0;
			q[++t]=id;
			if(s[q[h]]>=s[i-1])
			{
				printf("%lld\n",i);
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：OIer_Automation (赞：1)

# 洛谷 P7590 回旋加速器（2021 CoE-II C）

## 思路

根据题意，从第 $i$ 个加速器抵达其相邻的加速器，会先加上 $e_{i}$ 的速度，再消耗掉 $d_{i}$ 的速度，中途没有更改的可能，因此我们可以简化为，从第 $i$ 个加速器抵达其相邻的加速器，是将原速度 $+e_{i}-d_{i}$ 的过程。

再根据题意，小球可以从任意点出发，绕一圈回到原点。众所周知，C++ 并没有任何一个可以环形的数据结构（也有可能我是个蒟蒻），所以我们可以开双倍数组，让 $[i,i-1]$ 变成 $[i,i+n]$，就可以计算了。

至于判断速度是否 $< 0$，是判断 $i \sim j (1\le i\le n,i\le j\le i+n-1)$ 的速度变化和是否有一个 $<0$。

既然是区间求和，便可以利用前缀和存储，这样就有 $O(1)$ 查询的效果。但是，如果每一个 $j$ 都要判断，时间依旧是 $O(n^2)$ 的复杂度。考虑到，对于同一个 $i$，每一次加速后的速度的最小值如果不 $<0$，就有其余的依旧不 $<0$，即 $i$ 符合条件，因此，只需要找出区间和最小的判断。又因为 $i$ 是不变的，所以即使加上 $i$ 前面所有数字的和，也不影响最小值的判断。

那么，求区间最小值，很明显用单调队列可以做，时间复杂度 $O(n\log n)$ 也合情合理。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int T,n,s[2000005],a[2000005],b[2000005],q[2000005],fl;

int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--){
		fl=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			a[i+n]=a[i];
		}
		for(int i=1;i<=n;i++){
			cin>>b[i];
			b[i+n]=b[i];
		}
		for(int i=1;i<=2*n;i++){
			s[i]=s[i-1]+a[i]-b[i];
		}
		int h=1,t=0;
	    for(int i=1;i<=2*n-1;i++) {
	        while(h<=t&&s[i]<=s[q[t]])t--;
	        q[++t]=i;
	        if(i-q[h]+1>n)h++;
	        if(i>=n&&s[q[h]]>=s[i-n]){
	        	cout<<i-n+1<<endl;
	        	fl=1;
	        	break;
			}
	    }
	    if(!fl)cout<<"Failed!"<<endl;
	}
} 
```

啊但是，你会发现这样写完，只得了 $70$ 分，剩下的都 TLE 了 QwQ。

那么问题出在哪里呢？我也不知道，我也很懵。直到我写了快读。

请把快读焊在我脑门上，谢谢。

## 真·代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int T,n,s[2000005],a[2000005],b[2000005],q[2000005],fl;

int read(){
	int ret=0,sgn=0,ch=getchar();
	while(!isdigit(ch))	sgn|=ch=='-',ch=getchar();
	while(isdigit(ch)) ret =ret*10+ch-'0',ch=getchar();
	return sgn?-ret:ret;
}

int main(){
	ios::sync_with_stdio(false);
	T=read();
	while(T--){
		fl=0;
		n=read();
		for(int i=1;i<=n;i++){
			a[i]=read();
			a[i+n]=a[i];
		}
		for(int i=1;i<=n;i++){
			b[i]=read();
			b[i+n]=b[i];
		}
		for(int i=1;i<=2*n;i++)s[i]=s[i-1]+a[i]-b[i];
		int h=1,t=0;
	    for(int i=1;i<=2*n-1;i++) {
	        while(h<=t&&s[i]<=s[q[t]])t--;
	        q[++t]=i;
	        if(i-q[h]+1>n)h++;
	        if(i>=n&&s[q[h]]>=s[i-n]){
	        	cout<<i-n+1<<"\n";
	        	fl=1;
	        	break;
			}
	    }
	    if(!fl)cout<<"Failed!"<<"\n";
	}
} 
```

---

## 作者：iakioi114514 (赞：0)

### 0.废话：

做这道题时的感受，虽然不是很难，但是洛谷的时间是真的能卡死我，提交了十多遍才过的，基本上把我所有学的优化都安排了上去。

### 1.正题：

对于这一道题，在任何一个加速腔中我们只用关心其中的损耗的动能，我们假设 $e_i$ 是第 $i$ 个加速腔所提供的动能，$d_i$ 是第 $i$ 个加速腔所运行到第 $i+1$ 个加速腔时的所损耗的动能，那么就有了一个新的公式：

$$dp_i=e_i-d_i$$

那么这道题的问题就是：

- 能不能绕一圈？

- 如果能，那么这个加速腔在哪里？

第一个很简单，对 $dp$ 数组做一个和就好了。

$$ans=\sum{dp_i}$$

如果 $ans$ 是负数，则不可能有解，因为其损耗的比提供的动能多。否则，一定存在加速腔。

对于第二个问题，我们可以先假设在环上选择一个区间 $[i,j]$，$j$ 必须大于 $i$。然后进行加和，定义：

$$cnt[i,j]=\sum{dp_k,i \le k < j}$$

如果 $cnt[i,j]$ 是负数，则加速腔一定不在 $[i,j]$ 这个区间里。否则，答案就在这个区间里。所以第二个问题的答案就是求在 $1$ 到 $n$ 之间的第一个非负值的连续子序列，那么子序列的结尾必然是 $n$。最后，因为数据很大，所以需要优化。

### 70 分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d[10000001],e[10000001],dp[10000001],t,ans,cnt,x;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&e[i]);
		}
		for(int i=1;i<=n;i++){
			scanf("%d",&d[i]);
		}
		for(int i=1;i<=n;i++){
			dp[i]=e[i]-d[i];
		}
		ans=0;
		cnt=0;
		x=0;
		for(int i=1;i<=n;i++){
			ans+=dp[i];
			cnt+=dp[i];
			if(cnt<0){
				x=i;
				cnt=0;
			}
		}
		if(ans<0) printf("Failed!\n");
		else printf("%d\n",x+1);
	}
	return 0;
}
```
这个为什么只有 $70$ 分呢？因为最后的一个点超时了，这个时间卡的有点严啊。所以再加上亿点点的优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int f=0,x=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') x=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		f=((f<<3)+(f<<1))+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int n,d[10000001],e[10000001],dp[10000001],t,ans,cnt,x;
int main(){
	t=read();
	while(t--){
		n=read();
		for(register int i=1;i<=n;i++){
			e[i]=read();
		}
		for(register int i=1;i<=n;i++){
			d[i]=read();
		}
		for(register int i=1;i<=n;i++){
			dp[i]=e[i]-d[i];
		}
		ans=0;
		cnt=0;
		x=0;
		for(register int i=1;i<=n;i++){
			ans+=dp[i];
			cnt+=dp[i];
			if(cnt<0){
				x=i;
				cnt=0;
			}
		}
		if(ans<0) printf("Failed!\n");
		else printf("%d\n",x+1);
	}
	return 0;
}
```
这道题就这么水灵灵的过啦！

[70 分记录](https://www.luogu.com.cn/record/179408272)

[100 分记录](https://www.luogu.com.cn/record/179410046)

在 [P7590 回旋加速器](https://www.luogu.com.cn/article/5myslpq8) 里食用更佳。

---

## 作者：Lofty (赞：0)

## 前言：
追着单调队列来的，写完发现题解的其他技巧蚌埠住了。

## 正题：

[题目传送门](https://www.luogu.com.cn/problem/P7590)

我们可以先对每个加速腔处理，将 $ e_i - d_i $（以下称为 $ d_i $）作为从 $ i $ 到 $ i+1 $ 的成本。因为我是单调队列的做法，显然难以处理环，于是可以断环成链，再做观察。

题目要求绕环一周，断成链后即为从 $ i $ 出发到达 $ i+n $。即要求对于 $ \forall k \in [i,i+n-1] $ 满足：

$$\sum ^{k}_ {j=i}d_j \ge 0 $$

因此我们可以先处理成前缀和。设：

$$s_i = \sum ^{i} _ {j=1} d_i$$

这样，条件就变成了对于 $ \forall k \in [i,i+n-1] $ 满足：

$$ s_k - s_{i-1} \ge 0 $$

然后发现，只要尝试 $ [i,i+n-1] $ 中 $ s_{min} $ 是否满足条件，就可以得出答案。于是就可以用单调队列维护最小值啦！至于要求编号最小的，可以从 $ 1 $ 递推至 $ n $，第一个满足条件的即为编号最小的。若递推至 $ n $ 之后仍然不满足条件，即为无解，输出`Failed`即可。

## 代码：
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define TP template<typename T>
#define TP_ template<typename T,typename ... T_>
TP void read(T &x)
{
	x=0;int f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	x*=f;
}
TP_ void read(T &x,T_&...y){read(x);read(y...);}
TP void write(T x){if(x<0){putchar('-'),x=-x;}if(x>9)write(x/10);putchar(48+x%10);}
TP void writeln(T &x){write(x);puts("");}
TP void writesp(T &x){write(x);putchar(' ');}
TP_ void writeln(const T &x,T_ &...y){writesp(x);writeln(y...);}
typedef long long LL;
constexpr int N=1e6+5;
constexpr int inf=1e9;
LL s[N<<1];
LL d[N<<1];
int l,r,q[N<<1];
int main()
{
	int T;read(T);
	while(T--)
	{
		int n;read(n);
		for(int i=1,x;i<=n;i++)
			read(x),d[i]=x;
		for(int i=1,x;i<=n;i++)
			read(x),d[i]-=x,d[i+n]=d[i];
		for(int i=1;i<=n*2;i++)//先处理为前缀和
			s[i]=s[i-1]+d[i];
		l=1;r=0;q[l]=0;
		for(int i=1;i<=n;i++)//将1~n的范围提前处理
		{
			while(l<=r&&s[q[r]]>=s[i])r--;
			q[++r]=i;
		}
		bool success=0;
		for(int i=1;i<=n;i++)
		{
			while(l<=r&&q[l]<i)l++;//使队列中始终只有i~i+n-1的范围
			if(s[q[l]]>=s[i-1])
			{
				writeln(i);//第一次满足条件即为最小的编号
				success=1;//记录是否有答案
				break;//直接跳出
			}
			while(l<=r&&s[q[r]]>=s[i+n])r--;
			q[++r]=i+n;
		}
		if(!success)puts("Failed!");//没答案就输出Falied
	}
	return 0;
}
```

---


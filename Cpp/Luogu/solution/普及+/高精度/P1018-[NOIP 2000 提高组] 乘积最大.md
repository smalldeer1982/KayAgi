# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# 题解

## 作者：liar_white (赞：416)

——来自离noip（tui）（yi）只剩2天却仍在与普及组题目奋战的蒟蒻——

——那你还有心思写题解？没错，反正写这道题都用了半上午——

本题思想：

用一个数组cut[i][j]存储在第i个数字后放第j个乘号，第1到第i个数的乘积的最大值。

如果j=k，说明所有的乘号都已经放完，那么ans[i]就表示最后一个乘号放在第i个数后面的最大值，此时要乘上后面的数。因为后面的数是一定的，cut[i][j]是已知的最大值，所以ans[i]可以由唯一的路径转移。

最后比较所有的ans[i]，选择最大值输出。

完成以上步骤需要至少三个操作：

1.取数 将没有乘号分隔的连续的数字变成一个数，进行运算

2.比较 没有比较哪来的最大值

3.乘法 将乘号两边取到的数乘起来

由于n<=40，所以这些操作要用高精度的方式进行

（如果有能存40位的数据类型，请不必往下翻了，本蒟蒻最多知道一个long long）

下面上代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,k,a[50];
char s[50];
struct node{//用结构体储存数组；当然，也可以直接用三维数组，不过感觉这样更容易理解
    int v;bool exi;//v:数位,exi:是否存在
    int c[50];//高精度数组
}cut[50][10],ans[50];
node culc(int l,int r){//取数操作，注意：要从右往左取，因为高精度数组是从低位往高位排的，而读入的数字串是从高位到低位
    node e;
    e.v=r-l+1;e.exi=true;
    for(int i=1;i<=e.v;i++){
        e.c[i]=a[r-i+1];
    }    
    return e;
}
node mul(node e1,node e2){//高精度乘法
    node emul;
    emul.exi=true;emul.v=e1.v+e2.v-1;
    for(int i=1;i<=emul.v;i++) emul.c[i]=0;
    for(int i=1;i<=e1.v;i++)
        for(int j=1;j<=e2.v;j++)
            emul.c[i+j-1]+=e1.c[i]*e2.c[j];
    int q=0;        
    for(int i=1;i<=emul.v;i++){
        emul.c[i]+=q;
        q=emul.c[i]/10;
        emul.c[i]%=10;
    }
    while(q>0){
        emul.c[++emul.v]=q%10;
        q/=10;
    }
    return emul;
}
node Max(node e1,node e2){//高精度比较，类似字符串（然而如果是字符串的话我就直接strcmp了）
    if(!e1.exi||e1.v<e2.v) return e2;
    if(!e2.exi||e2.v<e1.v) return e1;//先比较是否存在和位数
    for(int i=e1.v;i>=1;i--){//都存在，且位数相同，则逐位比较
        if(e1.c[i]>e2.c[i]) return e1;
        else if(e2.c[i]>e1.c[i]) return e2;
    }
    return e1;
}
int main(){
    scanf("%d%d",&n,&k);
    scanf("%s",s);
    for(int i=0;i<n;i++) a[i+1]=s[i]-'0';//将字符串变为数字数组
    for(int i=1;i<=n;i++){
        ans[i].exi=false;
        for(int j=1;j<=k;j++) cut[i][j].exi=false;
    }
    for(int i=1;i<n;i++){
        cut[i][1]=culc(1,i);//只放一个乘号的话不需要转移
        for(int j=2;j<=k;j++){
            for(int fr=j-1;fr<i;fr++){//因为第i个数后放置的乘号最多是第i个，所以从j-1枚举front（前置位）
                if(cut[fr][j-1].exi) cut[i][j]=Max(cut[i][j],mul(cut[fr][j-1],culc(fr+1,i)));
            }
        } //转移状态
        if(cut[i][k].exi){
            ans[i]=mul(cut[i][k],culc(i+1,n));
        }
    }
    node lastans;lastans.exi=false;
    for(int i=1;i<n;i++){
        node tmp=Max(ans[i],lastans);
        lastans=tmp;//不知道为什么，直接写lastans=Max(lastans,ans[i])总是会错，然而加一个中间变量就过了。。
    }
    for(int i=lastans.v;i>=1;i--) printf("%d",lastans.c[i]);//输出
    return 0;
}//写完注释感觉就像白痴代码一样啊。。。（内心：那你还写了半个上午？？？）
```

---

## 作者：sunyt (赞：196)

这道题我没多想，直接上大法师，不知道为什么竟然一遍AC了，蒟蒻表示害怕。。。关于DFS，剪枝不多，枚举乘号插入位置即可。

参数有三个dfs(已插入的乘号个数，当前乘积，上一个乘号的插入位置)

然后需要注意的是用long long（PS：没用高精，because我的高精功能好像退化了。。。）。

最后是剪枝：

1.可行性剪枝：if(乘号个数==应有乘号个数)特殊处理并进行比较。

特殊处理见下：

```cpp
void dfs(int x,int ans,int last)
{
    if(x==k)
    {
    mul=0;
    for(int j=last+1;j<n;j++)
    {mul+=a[j];
    mul*=10;}
    mul+=a[n];
    maxx=max(maxx,ans*mul);
    return;
    }
```
一般处理是这样的↓↓↓
2.也算是另一个可行性剪枝，枚举乘号位置的时候要注意保证后面的乘号都有位置可以占，即n-k+x，具体为什么很明显，请诸牛自悟。

```cpp
    for(int i=last+1;i<=n-k+x;i++)
    {
        mul=0;
        for(int j=last+1;j<i;j++)
        {mul+=a[j];
        mul*=10;}
        mul+=a[i];
        dfs(x+1,ans*mul,i);
    }
}
```
主函数：
```cpp
int main()
{
    cin>>n>>k;
    for(i=1;i<=n;i++)
    {
        cin>>ch;
        a[i]=ch-'0';
    }
    dfs(0,1,0);//初始值处理
    cout<<maxx;
}
```

---

## 作者：XHCuteDog (赞：7)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=51;
int n,k;
//一波小广告:本人博客https://www.luogu.org/blog/sshilyzyx/
//本题重点,坑:使用高精度,在对数字进行插入数组时,应当从低位逐渐向高位读入.
//eg:12345读入应为54321. 
string s;//读入为字符串,再将其转化为数字. 
struct hd{
    int len;
    int d[maxn];
};  //定义一个结构体,len记录一个数字的长度,即位数,d[i]记录该数字的第i位. 
hd f[maxn][50];//定义f数组,表示在前maxn个数中插入50以内个乘号.
               //(f[i][j]表示一个数,在前i个数字中插入j个"*"后所得最大值).
void init(hd &A,int l,int r)
{
    A.len=r-l+1;//string类型第i个应从第0个开始数起,s[i]表示s的第i-1个元素.   
    for(int i=1,j=r-1;j>=l-1;i++,j--)
        A.d[i]=s[j]-'0'; //字符转数字. 
}
void mul(hd &Z,hd X,hd Y)//&z表示在该函数中对z的修正是"永久性"的,余下的两个则不然. 
{   //X,f[k][j-1],Y 
    for(int i=1;i<maxn;i++)
        Z.d[i]=0;//"一劳永逸"初始化. 
    for(int i=1;i<=X.len;i++)
        for(int j=1;j<=Y.len;j++)
            Z.d[i+j-1]+=X.d[i]*Y.d[j];//存入乘积. 
    for(int i=1;i<maxn;i++)
    {
        Z.d[i+1]+=Z.d[i]/10;//对每一位上的数字进行修正. 
        Z.d[i]=Z.d[i]%10;//同上. 
    }
    int i;
    for(i=maxn-1;i>1;i--)
        if(Z.d[i])break;//从后向前一次列举,第一个非零数即该数字的最高位. 
    Z.len=i;//修正该数字的位数. 
}
void pr(hd X)
{
    for(int i=X.len;i>=1;i--)
        cout<<X.d[i];//由于反向插入,所以输出时也应反向依次输出. 
    cout<<endl;
}
bool bigger(hd X,hd Y)
//比较数字大小的方法:1\位数大的数大于位数小的数;在1不满足时:
//从后往前列举,对每次遇到的数字进行比较,第一次出现大小不同时,较大者其整体数字大. 
{
    if(X.len!=Y.len)
        return X.len>Y.len;
    for(int i=X.len;i>=1;i--)
        if(X.d[i]!=Y.d[i])
            return X.d[i]>Y.d[i];
}
int main()
{
    cin>>n>>k;//n表示有n位数,插入k个"*". 
    cin>>s;//读入字符串. 
    for(int i=1;i<=n;i++)
        init(f[i][0],1,i);//表示前i个数中插入0个"*". 
    for(int j=1;j<=k;j++)//当前已插入的"*"个数. 
        for(int i=j+1;i<=n;i++)//数字位数至少应比"*"数多1,且小于数字总位数. 
        {
            f[i][j].len=0;//初始化该值为0,努力将其刷为更大值. 
            hd X,Y;
            for(int k=j;k<i;k++)
            {
                init(Y,k+1,i);
                mul(X,f[k][j-1],Y);//???
                if(bigger(X,f[i][j]))//取大值,若X>f[i][j],则进行修正. 
                    f[i][j]=X;
            }
        }
    pr(f[n][k]);//利用函数进行输出. 
    return 0;	
}

```


---

## 作者：Co_Ce (赞：3)

# Solution
[link](https://www.luogu.com.cn/problem/P1018)
# 解析：
**状态定义**：$dp[i][j]$ 表示前 $i$ 个数分成 $j$ 段（即需要 $j+1$个*）的最大乘积。  
**状态转移**：$dp[i][j] = \max(dp[k-1][j-1] \times a[k][i], dp[i][j])$，表示在第 $k-1$ 和第 $k$ 个数之间加上一个*得到的最大值，其中前 $k-1$ 个数采用的是 $dp[i][k-1]$ 值，即被分为了 $j-1$ 段后的最大值，而后面的数（从 $k$ 到 $i$）则视为一整个数，与前面的 $dp$ 值相乘。遍历全部 $k$ 的位置，取最大值即为 $dp[i][j]$。  
由于要保存和计算的数最高为 $40$ 位，因此还需要采用高精度。  
整体思路就是先写出来非高精度版，再将其中的乘、加改成高精度的函数即可。

---

## 作者：kuaiCreator (赞：3)

## 题目大意
将一串长度为 $n$ 的数字字符串，分成 $k+1$ 个整数，使这 $k+1$ 个整数的乘积最大。

本题是划分型动态规划的经典例题。

划分型动态规划通常是将 $n$ 个元素划分为无限组或有限组同时计算分成若干组的最优解或方案数等问题。

状态定义一般为 $f(i,j)$ 表示把前 $i$ 个元素分为 $j$ 组时的最优状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/7dcxuwoe.png)

## 解题思路
特别注意：由于读入的字符串长度 $N\le 40$ 计算结果很大需要开高精度。
#### 1、定义状态
$f(i,j)$ 表示前 $i$ 个数字字符插入 $j$ 个乘号的最大乘积的值。

#### 2、分解子问题
$$f(i,j)=\max\limits_{k=j}^{i-1}f(k,j-1)\times num(k+1,i)$$

$num(k+1,i)$ 表示由字符串的第 $k+1$ 至 $i$ 位组成的数。

#### 3、初始化状态和边界状态
问题状态初始化：
$$f(l,r) = 0 \quad l,r∈[1..n]$$

边界状态初始化：
$$f(0,j) = 0,f(i,0) = num(1 , i)\quad l,r∈[1..n]$$

#### 4、计算顺序
第一层循环枚举前 $i$ 个数从 $1$ 到 $n$。

第二层循环枚举插入乘号的数量 $j$ 从 $1$ 到 $\min(m,i-1)$。 

第三层循环 $k$ 枚举插入的位置 $j$ 到 $i-1$。

#### 5、最终答案
$$ans=f(n,m)$$

#### 6、效率分析
时间复杂度 $O(n^2m)$。

空间复杂度 $O(nm)$。

## 代码展示
为方便理解附上一个不带高精度的代码。带高精度的写法建议用类类型或者结构体并重载运算符实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 50;
long long dp[N][N], n, m, num[N][N];		//long long 可以替换为高精度类型
string str;
int main() {
	cin >> n >> m >> str;
	str = ' ' + str;                      //让字符串有用的信息从下标 1 开始
	for (int i = 1; i <= n; i++)          //把字符串第i至第j个位置的子串转换为整数
		for (int j = i; j <= n; j++)
			num[i][j] = num[i][j - 1] * 10 + str[j] - '0';

	memset(dp, 0, sizeof(dp));
	for (int i = 1; i <= n; i++)          //初始化边界状态
		dp[i][0] = num[1][i]; 

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {     //j<i表示i个数最多插入i-1个乘号
			if (j >= i) break;  //前i个元素不能被插入j个隔板分成j+1份
			for (int k = j; k < i; k++)    //前k个元素最多插入j-1个符号故k从j开始枚举
				dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
		}
	cout << dp[n][m];
	return 0;
}

```

---

## 作者：yr409892525 (赞：2)

使用 dp 解决此题。              
设
$dp_{i,j}$ 代表前 $i$ 位使用 $j$ 个乘号的最大乘积，
$a_{i,j}$ 代表字符串的 $i \sim j$ 位。               
首先 $dp_{i,0}=a_{1,i}$。                 
对于每个 $(i,j)$，可以枚举乘号的位置 $k$。               
$dp_{i,j}=\max(dp_{i,j},dp_{k,j-1} \times a_{k+1,j})$。         
但是答案太大，需要使用高精度。             
代码按照步骤实现即可。

---

## 作者：sunny12888 (赞：2)

## 题目大意
现给你一串数字，允许你在中间添加 $k$ 个乘号，使得最后的结果最大。
## 题目分析
由数据范围可知，$n$ 不超过 $40$。表示这个数最多 $40$ 位。只能使用高精度算法。把数据存入数组进行计算。

~~由于我不太会 DP~~，所以这题我使用 DFS，若在这个数后要放乘号，就做标记，并做记录。直到乘号数等于 $k$，并计算每一次的结果。最后输出最大的即可。

### 举个例子
若这个数为 $1231$，$k=2$，第一次放在 $1$ 和 $2$ 的后面，计算出结果为 $62$；再放在 $1$ 和 $3$ 的后面，计算出结果为 $23$；以此类推。发现最后最大的是 $62$，则输出即可。

代码请自行实现。

---

## 作者：mairuisheng (赞：2)

[P1018 [NOIP2000 提高组] 乘积最大](https://www.luogu.com.cn/problem/P1018)

算法：搜索、高精度

分析：深搜乘号的插入位置，再求积，这里有个剪枝：当插完这个乘号后，发现剩下乘号的数量大于剩下可插乘号的空位，就直接返回。看到题目数位最多有 $40$ 位，所以要用高精度。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char s;
    s=getchar();
    while(s<'0'||s>'9')
    {
        if(s=='-')f=-f;
        s=getchar();
    }
    while(s>='0'&&s<='9')
    {
        x=(x<<3)+(x<<1)+(s-48);
        s=getchar();
    }
    return x*f;
}
int N,K;
int ch[7];
string a;
string num[41][41];
string ans;
string times(string val,string k)//高精度乘法模板
{
	if((val.length()<k.length())||((val.length()==k.length())&&(val<k)))swap(val,k);
	string ret="";
	bool fl=false;
	int lenv=val.length(),lenk=k.length();
	int s1[101],s2[101],c[1001];
	memset(c,0,sizeof(c));
	int i,j,x,t,w=lenv+lenk,t2;
	for(i=0;i<lenv;++i)s1[i+1]=val[lenv-i-1]-48;
	for(i=0;i<lenk;++i)s2[i+1]=k[lenk-i-1]-48;
	for(i=1;i<=lenv;++i)
	{
		for(j=1;j<=lenk;++j)
		{
			t=s1[i]*s2[j];
			c[i+j-1]+=t%10;
			if(c[i+j-1]>9)
			{
				t2=c[i+j-1]/10;
				c[i+j-1]%=10;
				c[i+j]+=t2;
			}
			c[i+j]+=t/10;
		}
	}
	for(i=w;i>0;--i)
	{
		if(c[i]!=0)fl=true;
		if(fl)ret+=(c[i]+48);
	}
	if(!fl)ret="0";
	return ret;
}
string solve()//求积
{
	int lt=ch[1],i;
	string val=num[1][lt];
	for(i=2;i<=K;++i)
	{
		val=times(val,num[lt+1][ch[i]]);
		lt=ch[i];
	}
	val=times(val,num[lt+1][N]);
	return val;
}
void dfs(int l,int k)//搜索乘号位置
{
	if(k==0)
	{
		string val=solve();
		if((val.length()>ans.length())||((val.length()==ans.length())&&(val>ans)))ans=val;
		return;
	}
	int i;
	for(i=l;i<=N-k+1;++i)
	{
		ch[K-k+1]=i;
		dfs(i+1,k-1);
	}
}
int main()
{
	int i,j;
    N=read();
    K=read();
    cin>>a;
    for(i=1;i<=N;++i)num[i][i]=a[i-1];
    for(i=1;i<=N;++i)//num[i][j]表示第i位到第j位的数字
    {
    	for(j=i;j<=N;++j)
	    {
	    	if(i!=j)num[i][j]=num[i][j-1]+num[j][j];
		}
	}
    dfs(1,K);
    cout<<ans;
    return 0;
}
```

---

## 作者：x11223344 (赞：1)

以下设 $num_{l,r}$ 代表区间 $[l,r]$ 代表的数字，下标从 $0$ 开始。

提供两个解法：  
方法 1：区间 dp，设 $dp_{l,r,i}$ 代表区间 $[l,r]$，使用了 $k$ 个乘号乘积的最大值。  
初始条件：$dp_{l,r,0}=num_{l,r}$。  
转移方程：  
考虑在哪两个数中间放乘号以及左右的有多少个乘号，可得：
$$
dp_{l,r,i}=\max_{k=l}^{r-1}\max_{j=0}^{i-1}dp_{l,k,j} \times dp_{k+1,r,i-j-1}
$$
最终答案为 $dp_{0,N-1,K}$。

方法 2：线性 dp，设 $dp_{i,j}$ 代表前 $i$ 个数，有 $j$ 个乘号乘积的最大值。  
初始条件：$dp_{i,0}=num_{0,i}$。  
转移方程：  
考虑最后一个乘号放在那两个数中间，可得：
$$
dp_{i,j}=\max_{k=0}^{i-1}dp_{k,j-1} \times num_{k+1,i}
$$
最终答案为 $dp_{N-1,K}$。

注意：需要写高精。

---

## 作者：FastIO_DP (赞：1)

### 题目理解

题目给出一个长度为 $N$ 的数字串，要求在其中插入 $K$ 个乘号，将数字串分成 $K+1$ 个部分，使得这 $K+1$ 个部分的乘积最大。

### 解题思路

考虑动态规划。

所以可以定义状态 $dp_{i,j}$ 表示将前 $i$ 个数字分成 $j+1$ 部分时的最大乘积。

$dp_{i,0}$ 表示将前 $i$ 个数字分成 $1$ 部分时的最大乘积，也就是整个数字串本身。

#### 推转移方程

要求 $dp_{i,j}$，就需要枚举最后一个乘号的位置 $k$（$k$ 的范围是 $j-1$ 到 $i-1$），然后将前 $k$ 个数字分成 $j$ 部分。最后将剩下的 $k+1$ 到 $i$ 部分作为一个整体。状态转移方程为：

$$
dp_{i,j} = \max(dp_{i,j}, dp_{k,j-1} \times \text{num}(k+1, i))
$$

这里的 $\text{num}(k+1, i)$ 表示从第 $k+1$ 个数字到第 $i$ 个数字组成的数字。

好的，我们推完了状态转移方程，直接实现就 ok 了。对了，答案可能会超 long long 所以要用高精度。

```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;

struct BI {
    int d[100];
    int len;

    BI() {
        memset(d, 0, sizeof(d));
        len = 0;
    }
    BI(const string& s) {
        memset(d, 0, sizeof(d));
        len = s.size();
        for (int i = 0; i < len; ++i) {
            d[i] = s[len - 1 - i] - '0';
        }
    }

    string toStr() const {
        string s;
        for (int i = len - 1; i >= 0; --i) {
            s += to_string(d[i]);
        }
        return s;
    }

    BI operator*(const BI& o) const {
        BI res;
        for (int i = 0; i < len; ++i) {
            int c = 0;
            for (int j = 0; j < o.len; ++j) {
                int p = d[i] * o.d[j] + res.d[i + j] + c;
                res.d[i + j] = p % 10;
                c = p / 10;
            }
            if (c) {
                res.d[i + o.len] += c;
            }
        }
        res.len = len + o.len;
        while (res.len > 1 && res.d[res.len - 1] == 0) {
            res.len--;
        }
        return res;
    }

    bool operator<(const BI& o) const {
        if (len != o.len) {
            return len < o.len;
        }
        for (int i = len - 1; i >= 0; --i) {
            if (d[i] != o.d[i]) {
                return d[i] < o.d[i];
            }
        }
        return false;
    }
};

int N, K;
string s;
BI dp[50][10];

BI num(int l, int r) {
    string sub = s.substr(l, r - l + 1);
    return BI(sub);
}

int main() {
    cin >> N >> K;
    cin >> s;

    for (int i = 0; i < N; ++i) {
        dp[i][0] = num(0, i);
    }

    for (int j = 1; j <= K; ++j) {
        for (int i = j; i < N; ++i) {
            for (int k = j - 1; k < i; ++k) {
                BI t = dp[k][j - 1] * num(k + 1, i);
                if (dp[i][j] < t) {
                    dp[i][j] = t;
                }
            }
        }
    }

    cout << dp[N - 1][K].toStr() << endl;

    return 0;
}
```

#### 复杂度分析

- 时间复杂度：$O(n^2 \times k)$，其中 $n$ 是数字串的长度，$k$ 是乘号的数量。
- 空间复杂度：$O(n \times k)$，用于存储 dp 表。

---

## 作者：xiaobeng_0912 (赞：0)

## $\mathbf{Knowledge}$

1. 动态规划
1. 高精度

## $\mathbf{Solution}$

看到题目，我们就想到用 dfs 或者 dp 去做。在这里，我就来介绍一种 dp 的解法。

设 $dp_{i,j}$ 为在第 $i$ 个数字后放置第 $j$ 个乘号，这个乘号前面的算式能形成的最大乘积。

于是，我们就可以得到转移方程（其中 $ \operatorname{cut}(l,r)$ 为从题目给定的数字串中截取第 $l$ 位到第 $r$ 位所组成的新数）：

$$dp_{i,j}=\max\limits_{l=j-1}^{i-1}\{dp_{l,j-1}\times \operatorname{cut}(l+1,i)\}$$

最后，答案就可以表达为（$n$ 和 $k$ 同题意）：

$$ans=\max\limits_{i=1}^{n}\{dp_{i,k}\times \operatorname{cut}(i+1,n)\}$$

顺便提一句，因为 $n\le40$，所以需要用到高精度！

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string s,ans="0",dp[41][7];//ans 别忘了赋初值 
string add(string x,string y){//高精度加法 
	int tmp[20001];
	string res="";
	reverse(x.begin(),x.end());
	reverse(y.begin(),y.end());
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<max(x.size(),y.size());i++){
		if(i>=y.size()){
			y+="0";
		}
		if(i>=x.size()){
			x+="0";
		}
		tmp[i]+=(x[i]-'0')+(y[i]-'0');
		tmp[i+1]+=tmp[i]/10;
		tmp[i]%=10;
	}
	for(int i=max(x.size(),y.size());i>=0;i--){
		if(tmp[i]==0&&i==max(x.size(),y.size())){
			continue;
		}
		res+=char(tmp[i]+'0');
	}
	return res;
}
string mul(string x,string y){//高精度乘法 
	int tmp[20001],flag=0;
	string res="";
	reverse(x.begin(),x.end());
	reverse(y.begin(),y.end());
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<x.size();i++){
		for(int j=0;j<y.size();j++){
			tmp[i+j]+=(x[i]-'0')*(y[j]-'0');
		}
	}
	for(int i=0;i<x.size()+y.size();i++){
		if(tmp[i]>=10){
			tmp[i+1]+=tmp[i]/10;
			tmp[i]%=10;
		}
	}
	for(int i=x.size()+y.size()-1;i>=0;i--){
		if(tmp[i]!=0||flag==1){
			flag=1;
			res+=(tmp[i]+'0');
		}
	}
	return res;
}
string Max(string x,string y){//高精度比大小 
	if(x.size()!=y.size()){
		return (x.size()>y.size())?x:y;
	}
	return x>y?x:y;
}
string cut(int l,int r){//分割数位，把数字串 l 到 r 的这部分的数字变为一个独立的数 
    string a="0",tmp;
    for(int i=l;i<=r;i++){
    	tmp=s[i];//别忘了把 s[i] 变为字符串再弄进 add 函数里！ 
        a=add(mul(a,"10"),tmp);
    }
    return a;
}
int main(){
    scanf("%d%d",&n,&k);
    cin>>s;
    s=' '+s;//将 s[1] 变为字符串 s 的开头，后面的字符顺延 
    for(int i=1;i<n;i++){//动态规划部分 
        dp[i][1]=cut(1,i);//赋初始值 
        for(int j=2;j<=k;j++){
            for(int l=j-1;l<i;l++){
                dp[i][j]=Max(dp[i][j],mul(dp[l][j-1],cut(l+1,i)));//转移方程 
            }
        }
    }
    for(int i=1;i<n;i++){
    	ans=Max(ans,mul(dp[i][k],cut(i+1,n)));//求出答案 ans 
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：mcturtle (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1018#submit)
## 题目大意
设有一个长度为 $N$ 的数字串，要求选手使用 $k$ 个乘号将它分成 $(k+1)$ 个部分，找出一种分法，使得这 $(k+1)$ 个部分的乘积能够为最大。
## 解题思路
一道好题。

首先使用高精度进行操作，因为此题数据范围太大，数位长度不大于 $40$，这个数据连 `__int128` 都会爆精度。

其次进行 $\texttt{DFS}$ 搜索。数据范围对于搜索来说还可以，加一些剪枝就能通过。

搜索内容并不难，选择乘号插入的位置并求积，再定义一个变量取存储最大值就行。

剪枝就更简单了，如果剩余数字数量大于剩下能插乘号的空位，直接 `return;` 就行了。

## 总结

就不贴代码了，总体难度不高，只是因为高精度才绿，不然就是橙题搜索。

---

## 作者：lizhixun (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P1018)

### $\texttt{Description}$

将一个 $n$ 位数分为 $(k+1)$ 个数字，输出这 $(k+1)$ 个数字的总乘积的最大值。

### $\texttt{Solution}$

前置知识：[高精度乘法](https://oi.wiki/math/bignum/#%E4%B9%98%E6%B3%95) & [DFS](https://oi.wiki/search/dfs/)

首先看**数据范围**，$n \le 40$，所以这题肯定需要高精度。这也是这题能够成为绿题的一个原因。附赠一个高精度乘法模板：[link](https://www.luogu.com.cn/paste/oqraj8r0)

$\texttt{DFS}$ 部分就是遍历字符串然后对于每一个位置**分或不分**，如果分的话就将计数器 $+1$，如果计数器等于 $k$，也就是已经分成了 $(k+1)$ 段（这里记录分的**次数**），那么就计算答案并比较大小，然后返回。

另外因为是高精度，所以我们需要手写**比较大小的函数**。

不贴代码。

---


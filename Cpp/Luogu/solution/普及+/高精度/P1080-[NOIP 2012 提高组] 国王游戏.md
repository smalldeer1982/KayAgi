# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# 题解

## 作者：洛必达法则 (赞：163)

本文写作目的为证明P1080贪心算法

-----------------------------------------

我们先来证明

对任意相邻两项，其依照二者$a$、$b$之积升序排列所得的结果小于等于降序排列所得的结果$(\sigma)$

不妨设现有大臣$i,i+1$

设在第$1$到$i-1$位中的最大值为$maximum$，则
 
第$1$到第$i+1$位中的最大值$\alpha$为

$max$
$($
$maximum,$
${\frac{\prod^{i-1}_{p=0}a_p}{b_i}}$
$,$
${\frac{\prod^{i}_{p=0}a_p}{b_{i+1}}}$
$)$

（设$r=\frac{\prod^{i-1}_{p=0}a_p}{b_i}$，$s=\frac{\prod^{i}_{p=0}a_p}{b_{i+1}}$)

要使得$\alpha$小于$i$与$i+1$交换后的最大值$\beta$,当且仅当
$\beta=max(maximum,\frac{\prod^{i-1}_{p=0}a_p}{b_{i+1}},$
$\frac{\prod^{i+1}_{p=0}a_p}{b_i\times{a_i}})<\alpha$

（设$t=\frac{\prod^{i-1}_{p=0}a_p}{b_{i+1}}$，$u=\frac{\prod^{i+1}_{p=0}a_p}{b_i\times{a_i}}$)

若$maximum=\alpha$,则显然有欲达到之效果

否则：

$∵\prod^{i-1}_{p=0}a_p<\prod^{i}_{p=0}a_p$

$∴s>t$

$∴$若$\alpha=s,\beta=t,$则可达到欲达到之效果

$∵\frac{\prod^{i-1}_{p=0}a_p}{a_i}<\prod^{i+1}_{p=0}a_p$

$∴u>r$

$∴$若$\alpha=r$,则不可能达到欲达到之效果

$∴\alpha$只可能等于$s$

又$∵$当$\alpha=s,\beta=t,$可达到欲达到之效果

$∴\alpha<\beta$
$\Longleftrightarrow$
$ s<u \Longleftrightarrow$
$\frac{\prod^{i}_{p=0}a_p}{b_{i+1}}<$
$\frac{\prod^{i+1}_{p=0}a_p}{b_i\times{a_i}
} $

$\Longleftrightarrow \frac{1}{b_{i+1}}<\frac{a_{i+1}}{a_i \times b_{i}} \Longleftrightarrow {a_i} \times {b_i}<{a_{i+1}} \times {b_{i+1}}$

又$∵i+1$位之后的情况与$i,i+1$的排列方式无关

故$(\sigma)$得证

接下来我们证明要使前$n$项奖励的最大值$\lambda$最小,
必有对于所有第$i$项$(i \in \lbrack 1,n \rbrack\bigcap N)$依据$a_i \times b_i$排序

先看一个引理$(*)$:

若长度为$s$的数列$r$不是一个不严格单调递增序列,则必存在$i \in \lbrack 1,s)\bigcap N$
使得$r_i>r_{i+1}$

证明如下：

若不存在这样的$i$,则:

对于任意
$m_1,m_2 \in \lbrack 1,s)\bigcap N$,当$m_1<m_2$时，有$r_{m_1} \leq r_{m_1+1} \leq ...\leq r_{m_2}$

$∴r$是一个不严格单调递增序列(矛盾)

故引理$(*)$得证

若前$n$项没有依照$a_i \times b_i$排序,且$\lambda$取到最小值,则:

由$(*)$,必有$q_1 \in \lbrack 1,n)\bigcap N$,
$q_2=q_1+1$
$st.$

$a_{q_1} \times b_{q_1}>a_{q_2} \times b_{q_2}$

由$(\sigma)$,交换$q_1,q_2$的位置所得的$\lambda'<$现有的$\lambda$(矛盾)

故命题得证.

---

## 作者：「QQ红包」 (赞：74)

贪心部分:

对于第 $i$个大臣和第 $j$ 个大臣:

如果第 $i$ 个大臣放第 $j$ 个大臣前面对答案的贡献小些,那么第 $i$ 个大臣就放第 $j$ 个大臣前面

所以就是使 $a[i].x/a[j].y<a[j].x/a[i].y$

所以就是$a[i].x*a[i].y<a[j].x*a[j].y$




然后高精度部分压位,这样快得多,20ms,


乘法部分相当于高精度乘低精度


除法部分相当于高精度除低精度


```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(s>='0'&&s<='9'));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(s>='0'&&s<='9')
    {
        k=k*10+(s-'0');
        s=getchar();
    }
    return k*base;
}
void write(int x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10)write(x/10);
        putchar(x%10+'0');
    }
}
int n,A,B;
struct node
{
    int x,y;
} a[1010];
bool cmp(node aa,node bb)
{
    if (aa.x*aa.y==bb.x*bb.y) return aa.y<bb.y;
    return (aa.x*aa.y)<(bb.x*bb.y);
}
int sum[1010];
int ans[1010],ls;
int p[1010],lp;
int m;//sum长度
int P;
bool Max()//比大小,ans>p: true
{
    int i=1;
    while (p[i]==0&&i<=lp) i++;//去掉前面的0
    int j=1;
    while (ans[j]==0&&j<=ls) j++;
    if (lp-i+1>ls-j+1) return false;//p的位数>ans的位数
    if (lp-i+1<ls-j+1) return true;
    while (i<=lp&&j<=ls)//一位一位的比较
    {
        if (p[i]<ans[j]) return true;
        if (p[i]>ans[j]) return false;
        i++;
        j++;
    }
    return false;
}
void cheng(int d)
{
    for (int i=1;i<=m;i++)
        sum[i]*=a[d].x;//高精度乘法
    for (int i=1;i<=m;i++)//进位
    {
        sum[i+1]+=sum[i]/10000;
        sum[i]%=10000;
    }
    if (sum[m+1]!=0) m++;
}
void div(int d)
{
    memset(ans,0,sizeof(ans));
    ls=1;
    while (m>0&&sum[m]==0) m--;//去掉前导0
    P=0;
    int flag=0;
    for (int i=m;i>=1;i--)//高精度除法(模拟竖式)
    {
        P=P*10000+sum[i];
        ans[++ls]=P/a[d].y;
        if (ans[ls]==0&&!flag) ls--; else flag=1;
        P%=a[d].y;
    }
}
int main()
{
    n=read();
    A=read();
    B=read();
    for (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
    sort(a+1,a+n+1,cmp);
    m=1;
    sum[1]=A;
    for (int i=1;i<=n;i++)
    {
        div(i);
        if (Max())
        {
            lp=ls;
            memcpy(p,ans,sizeof(ans));
        }
        cheng(i);
    }
    int i=0;
    while (i<=lp&&p[i]==0) i++;
    printf("%d",p[i]);i++;
    for (;i<=lp;i++)//输出
    {
        if (0<=p[i]&&p[i]<=9) printf("000%d",p[i]);else
        if (10<=p[i]&&p[i]<=99) printf("00%d",p[i]);else
        if (100<=p[i]&&p[i]<=999) printf("0%d",p[i]);else
        printf("%d",p[i]);
    }
    return 0;
}
```

---

## 作者：chc_1234567890 (赞：57)

贪心是一种奇妙的算法，能将$O(n^2)$、$O(n^3)$的dp，$O(2^n)$、$O(n!)$的爆搜直接化成$O(n)$。
# 国王游戏 [link](https://www.luogu.org/problemnew/show/P1080)
**本题需要高精**，在此不细讲。
## 分析
我们考虑两个大臣$p_1,p_2$，它们站在国王$p_0$的身后，则这两个大臣有两种排列方案：

1.

|person|left|right|
|-|-|-|
|$p_0$|$a_0$|$b_0$|
|$p_1$|$a_1$|$b_1$|
|$p_2$|$a_2$|$b_2$|

2.

|person|left|right|
|-|-|-|
|$p_0$|$a_0$|$b_0$|
|$p_2$|$a_2$|$b_2$|
|$p_1$|$a_1$|$b_1$|

对于第一种情况，答案$ans_1=\max(\frac{a_0}{b_1},\frac{a_0a_1}{b_2})$

对于第二种情况，答案$ans_2=\max(\frac{a_0}{b_2},\frac{a_0a_2}{b_1})$

显然，$\frac{a_0a_1}{b_2}>\frac{a_0}{b_2},\frac{a_0a_2}{b_1}>\frac{a_0}{b_1}$

若$ans_1<ans_2,\because \frac{a_0a_2}{b_1}>\frac{a_0}{b_1},\therefore \frac{a_0a_2}{b_1}$必须$>\frac{a_0a_1}{b_2}$

即 $\frac{a_2}{b_1}>\frac{a_1}{b_2}$ 即 $a_1b_1<a_2b_2$

因此，若$a_1b_1<a_2b_2$，就有$p_1$排在$p_2$前更优。

按照上述条件```sort```一遍，再计算答案即可。
## Code
```cpp
#include<cstdio>
#define maxn 4010
using namespace std;
class hp{
　　public:
    int a[maxn];
    hp(){memset(a,0,sizeof(a));}
    void clear(){memset(a,0,sizeof(a));}
    hp(int x){
        clear();
        while(x){
            a[++a[0]]=x%10;
            x/=10;
        }
        while(a[a[0]]==0&&a[0])a[0]--;
    }
    hp& operator=(int x){
        clear();
        while(x){
            a[++a[0]]=x%10;
            x/=10;
        }
        while(a[a[0]]==0&&a[0])a[0]--;
        return *this;
    }

    short cmp(const hp& x){
        if(a[0]>x.a[0])return 1;
        if(a[0]<x.a[0])return -1;
        for(register int i=a[0];i>=1;i--){
            if(a[i]>x.a[i])return 1;
            if(a[i]<x.a[i])return -1;
        }
        return 0;
    }
    bool operator>(const hp& x){
        return cmp(x)==1;
    }
    bool operator==(const hp& x){
        return cmp(x)==0;
    }
    bool operator<(const hp& x){
        return cmp(x)==-1;
    }
    bool operator>=(const hp& x){
        return !(*this<x);
    }
    bool operator<=(const hp& x){
        return !(*this>x);
    }
    
    hp operator-(const hp& x){
        hp a=*this,c;
        c.a[0]=a.a[0]>x.a[0]?a.a[0]:x.a[0];
        for(register int i=1;i<=c.a[0];i++) {
            c.a[i]+=a.a[i]-x.a[i];
            if(c.a[i]<0){c.a[i]+=10;a.a[i+1]--;}
        }
        while(c.a[c.a[0]]==0&&c.a[0])c.a[0]--;
        return c;
    }
    hp operator*(const hp& x){
        hp c;
        for(register int i=1;i<=a[0];i++){
            for(register int j=1;j<=x.a[0];j++){ 
                c.a[i+j-1]+=a[i]*x.a[j];
            }
        }
        c.a[0]=a[0]+x.a[0];
        for(register int i=1;i<=c.a[0];i++){
            if(c.a[i]>=10){
                c.a[i+1]+=c.a[i]/10;
                c.a[i]%=10;
            }
        }
        while (c.a[c.a[0]]==0&&c.a[0]>0)c.a[0]--;
        return c;
    }
    hp operator/(const int& x){
        hp c;
        int t=0,s=0;
        bool flag=1;
        for(register int i=a[0];i>=1;i--){
            t=s*10+a[i];
            if(t/x>0||t==0){
                c.a[++c.a[0]]=t/x;
                s=t%x;
                flag=0;
            }
            else{
                s=t;
                if(!flag)c.a[++c.a[0]]=0;
            }
        }
        reverse(c.a+1,c.a+c.a[0]+1);
        return c;
    }
};

struct node{
    int a,b;
};
node a[1001];
bool cmp(node x,node y){
    return x.a*x.b<y.a*y.b;
}
void checkmax(hp& x,hp y){
　　if(x<y)x=y;
}
int main(){
    int n;scanf("%d",n);
    for(register int i=0;i<=n;i++){
        scanf("%d%d",a[i].a,a[i].b);
    }
    sort(a+1,a+n+1,cmp);
    hp ans=0,ji=a[0].a;
    for(register int i=1;i<=n;i++){
        checkmax(ans,ji/a[i].b);
        ji=ji*a[i].a;
　　}
　　if(ans.a[0]==0)putchar('0');
　　else for(register int i=ans.a[0];i>=1;i--)
　　　　putchar(ans.a[i]+'0');
　　return 0;
}
```
# 补充题目：打CF
## 题意
一场CF比赛，时间为$T$分钟，有$N$道题，可以在比赛时间内的任意时间提交代码

第$i$道题的分数为$maxPoints[i]$,题目的分数随着比赛的进行，每分钟减少$pointsPerMinute[i]$

这是一场比较**dark**的CF，分数可能减成负数

已知第$i$道题需要花费$requiredTime[i]$的时间解决

请问最多可以得到多少分
## 数据范围
$1\le N\le 50,1\le T\le 100000,$
$1\le maxPoints[i],pointsPerMinute[i],requiredTime[i]\le 100000$

## 分析
贪心思维题。

**声明：在下面的分析中，我们约定**
```cpp
#define a maxPoints
#define b pointsPerMinute
#define c requiredTime
```

我们考虑两道题$p_1,p_2$，则先做$p_1$再做$p_2$能获得的分数为$$a_1-b_1c_1+a_2-b_2(c_1+c_2)$$先做$p_2$再做$p_1$能获得的分数为$$a_2-b_2c_2+a_1-b_1(c_2+c_1)$$
答案为$ans_1,ans_2$

若$ans_1<ans_2$，则

$a_1-b_1c_1+a_2-b_2(c_1+c_2)<a_2-b_2c_2+a_1-b_1(c_2+c_1)$，

$<=> b_2c_1>b_1c_2$

而$ans_1<ans_2$代表$p_2$放在$p_1$前更优，因此，使得$p_1$放在$p_2$前更优的条件是$$b_2c_1<b_1c_2$$

按照此条件对每一道题排序。

设做掉题目$p_i$的时刻为$time$，则$p_i$的实际得分为$$a_i-b_i* time$$

但由于比赛有时间限制，且题目最终得分可能为负数，因此，需要使用01背包来选择。转移方程：
$$dp[j]=dp[j-c[i]]+a[i]-b[i]* j$$
## Code
```cpp
#include<cstdio>
#define maxn 55
#define maxt 100005
using namespace std;
typedef long long D;
inline D max(D x,D y){return x>y?x:y;}
D a[maxn],b[maxn],c[maxn],tot,dp[maxt],ans;
int cnt,n,t[maxn];
bool cmp(int i,int j){
　　return b[j]*c[i]<b[i]*c[j];
}
int main(){
　　scanf("%d%lld",n,tot);
　　for(int i=1;i<=n;i++)scanf("%lld",a[i]);
　　for(int i=1;i<=n;i++)scanf("%lld",b[i]);
　　for(int i=1;i<=n;i++)scanf("%lld",c[i]),t[i]=i;
　　sort(t+1,t+n+1,cmp);
　　for(int i=1;i<=n;i++){
		for(int j=tot;j>=c[t[i]];j--){
			dp[j]=max(dp[j],dp[j-c[t[i]]]+a[t[i]]-b[t[i]]*j);
			ans=max(ans,dp[j]);
		}
	}
　　printf("%lld\n",ans);
　　return 0;
}
```
#### 请勿抄袭，否则后果自负

---

## 作者：frankchenfu (赞：8)

我们先猜结论：$a_i$小的排前面，那么后面的人乘积就比较小；$b_i$小的排前面，那么后面$b_i$较大，商就小……所以和$a_i,b_i$都有关系，那么这时候（如果可以贪心）一般就是$a_ib_i$排序、$a+b$、$a-b$三种排序方法。我们简单的算一下，发现有可能是$a_ib_i$，那么就尝试证明一下。

--------

不妨设两个人分别写了$a_1,b_1,a_2,b_2$且满足$a_1b_1>a_2b_2$，则有$\frac{a_2}{b_1}<\frac{a_1}{b_2}$。

有以下$2$种情况：
1. $1$在$2$正前方。
2. $1$在$2$正后方。

设在$1$、$2$之前所有人左手乘积为$k$，那么

对于第一种，我们的答案就是$$\begin{matrix}ans_1&=&\max(\frac{k}{b_1},\frac{ka_1}{b_2})\\ &=& k\cdot \max(\frac{1}{b_1},\frac{a_1}{b_2})\end{matrix}$$
$$\begin{matrix}\because \frac{a_2}{b_1}<\frac{a_1}{b_2}\ ,\ a2\ge 1 \\ \therefore \frac{a_1}{b_2}>\frac{a_2}{b_1} \ge \frac{1}{b_1}.\\ \therefore ans_1= \frac{k\cdot a_1}{b_2} \end{matrix}$$

对于第二种，答案是
$$\begin{matrix}ans_2=\max(\frac{k}{b_2},\frac{ka_2}{b_1})\\\\\begin{cases} \because a_1\ge1\\ \therefore \frac{k\cdot a_1}{b_2}\ge\frac{k}{b_2} \\\\ \because \frac{a_2}{b_1}<\frac{a_1}{b_2}\\ \therefore \frac{k\cdot a_1}{b_2}>\frac{ka_2}{b_1}\end{cases} \\\\\therefore ans_1\ge ans_2 \end{matrix}$$
换句话说，当我们分析了第二种情况后发现，无论是第$1$个人还是第$2$个人拿的钱数都一定比第一种中第$2$个人拿的钱数少。

因此，我们得出结论：如果$a_ib_i<a_jb_j$，那么应当让$i$排在$j$的前方，即**按照$a_ib_i$的大小从小到大排序**。

----------------------------------

于是我们可以**贪心**解决，但是注意到对于$100\%$的数据有$1\le n\le1000,0<a,b<10000$，因此我们需要使用高精度。这里写高精度非常的方便，不需要用到板子：因为所有的$a,b$不超过$10^4$，所以我们可以压$4$位，模数取$10^4$；乘法不会溢出，可以直接使用`int`。乘除法都是高精乘/除低精，都可以直接逐位处理……最让人感动的就是除法了，特别好写。感觉`print()`函数的写法是有技巧的，看楼下的题解似乎什么都好，就是`print()`函数写的很臃肿。

说明：高精虽然封装了但是也只是习惯，事实上是我模拟赛打这题的时候花了$\text{30min}$手打的。

---------------------
下面给出代码（高精封装）：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
const int MAXN=1010;

struct bign{
    const int BASE=1e4;
    int a[MAXN<<2],len;
    bign(int len=0){
        this->len=len;
    }
    bign operator=(int rhs){
        len=0;
        if(rhs==0){
            len=1;
            return *this;
        }
        while(rhs){
            a[++len]=rhs%BASE;
            rhs/=BASE;
        }
        return *this;
    }
    bign operator=(const bign rhs){
        memcpy(a,rhs.a,sizeof(rhs.a));
        len=rhs.len;
        return *this;
    }
    void operator*=(const int rhs){
        for(int i=1;i<=len;i++)
            a[i]*=rhs;
        for(int i=1;i<=len;i++){
            a[i+1]+=a[i]/BASE;
            a[i]%=BASE;
            if(i+1>len&&a[i+1])
                len++;
        }
        while(len&&a[len]==0)
            len--;
    }
    bign operator/(const int rhs){
        bign c;c=*this;
        while(c.len&&c.a[c.len]==0)
            c.len--;
        for(int i=c.len;i;i--){
            c.a[i-1]+=(c.a[i]%rhs)*BASE;
            c.a[i]/=rhs;
        }
        while(c.len&&c.a[c.len]==0)
            c.len--;
        return c;
    }
    void print(){
        while(len&&a[len]==0)
            len--;
        if(len==0){
            putchar('0');
            return;
        }
        printf("%d",a[len]);
        for(int i=len-1;i;i--)
            printf("%04d",a[i]);
    }
    bool operator>(const bign &rhs)const{
        if(len!=rhs.len)
            return len>rhs.len;
        for(int i=len;i;i--)
            if(a[i]!=rhs.a[i])
                return a[i]>rhs.a[i];
        return 0;
    }
}mul,ans;

struct node{
    int a,b;
    bool operator<(const node &rhs)const{
        return a*b<rhs.a*rhs.b||(a*b==rhs.a*rhs.b&&a<rhs.a);
    }
}p[MAXN];

int main(){
//	freopen("game.in","r",stdin);
//	freopen("game.out","w",stdout);
    int n;scanf("%d",&n);
    for(int i=0;i<=n;i++)
        scanf("%d%d",&p[i].a,&p[i].b);
    std::sort(p+1,p+n+1);
    mul=p[0].a;
    for(int i=1;i<=n;i++){
        bign tmp=mul/p[i].b;
        if(tmp>ans)
            ans=tmp;
        mul*=p[i].a;
    }
    ans.print();
    return 0;
}
```

---

## 作者：No_commander (赞：7)

邻项交换法（Exchange Argument）板子题。

设有两个大臣 $i,i + 1$，假设已经排好序，那么大臣 $i$ 的金币数是 $\frac{\prod _ {j = 0} ^ {i - 1} a_j}{b_i}$；大臣 $i + 1$ 的金币数是 $\frac{a_i \times \prod _ {j = 0} ^ {i - 1} a_j}{b_{i + 1}}$。

若将他们交换，金币数分别会变成 $\frac{\prod _ {j = 0} ^ {i - 1} a_j}{b_{i + 1}}$ 和 $\frac{a_{i + 1} \times \prod _ {j = 0} ^ {i - 1} a_j}{b_i}$。

如果 $i$ 放前面更优，则有：

$$
\max(\frac{1}{b_i}, \frac{a_i}{b_{i + 1}}) \times \prod _ {j = 0} ^ {i - 1} a_j \lt \max(\frac{1}{b_{i + 1}}, \frac{a_{i + 1}}{b_i}) \times \prod _ {j = 0} ^ {i - 1} a_j
$$

化解一下，得：

$$
\max(b_{i + 1}, a_i \times b_i) \lt \max(b_i, a_{i + 1} \times b_{i + 1})
$$

假设 $a_i \times b_i \gt a_{i + 1} \times b_{i + 1}$。

此时，有：

$$
b_{i + 1} \lt a_{i + 1} \times b_{i + 1} \lt a_i \times b_i
$$

所以 $\text{LHS} = a_i \times b_i$。

- 若 $\max(b_i, a_{i + 1} \times b_{i + 1}) = b_i$：

此时，原式为 $a_i \times b_i \lt b_i$，不成立，所以交换更优。

- 若 $\max(b_i, a_{i + 1} \times b_{i + 1}) = a_{i + 1} \times b_{i + 1}$：

此时，原式为 $a_i \times b_i \lt a_{i + 1} \times b_{i + 1}$，不成立，所以交换更优。

因此，当 $a_i \times b_i \gt a_{i + 1} \times b_{i + 1}$ 时，交换更优。即按

$$
a_i \times b_i
$$

从小到大排序即可，注意数据范围，需要高精。

---

## 作者：yanbinmu (赞：4)

其实不用推那么多，邻项交换放弃大脑。

我直接在 `cmp` 中比较两者两种排序的权值，取较小的一种即可。

我令前面的乘积是 $s$，则：

1. 如果不换，那么权值是 $\displaystyle \max(\frac{s}{r_1}, \frac{s \times l_1}{r_2})$。

2. 如果换，那么权值是 $\displaystyle \max(\frac{s}{r_2}, \frac{s \times l_2}{r_1})$。

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e3 + 5;



struct node {
	int l, r;
}a[N];

bool cmp(node a, node b) {
    return max(1.0 / (double)a.r, (double)a.l / b.r) < max(1.0 / (double)b.r, (double)b.l / a.r);
}

struct Num {
	int num[50005];
	int len;
	void init(int x) {
		while(x) {
			num[ ++ len] = x % 100000;
			x /= 100000;
		}
	}
	Num operator * (const int a) const {
		Num res;
		for(int i = 1;i <= len;i ++ ) {
			res.num[i] = a * num[i];
		}
		for(int i = 1;i <= len;i ++ ) {
			res.num[i + 1] += res.num[i] / 100000;
			res.num[i] %= 100000;
		}
		res.len = len;
		while(res.num[res.len + 1] != 0) {
			res.num[res.len + 1] += res.num[res.len] / 100000;
			res.num[res.len] %= 100000;
			res.len ++ ;
		}
		return res;
	}
	Num operator / (const int a) const {
		Num res;
		long long cur = 0;
		for(int i = len;i >= 1;i -- ) {
			cur = cur * 100000 + num[i];
			res.num[i] = cur / a;
			cur %= a;
		}
		res.len = len;
		while(res.num[res.len] == 0) res.len -- ;
		return res;
	} 
	bool operator < (const Num a) const {
		if(len > a.len) return 0;
		if(len < a.len) return 1;
		for(int i = len;i >= 1;i -- ) {
			if(num[i] > a.num[i]) return 0;
			if(num[i] < a.num[i]) return 1; 
		}
		return 1;
	}

};

	
int main() {
	int n, x, y;
	cin >> n;
	cin >> x >> y;
	for(int i = 1;i <= n;i ++ ) {
		cin >> a[i].l >> a[i].r;
	}
	/*
	相邻的两个大臣 l1, r1, l2, r2, 令前面的乘积为 s
	max(1 / r1, l1 / r2), max(1 / r2, l2 / r1)
	如果不交换是最优的， 则
	1. 1 / r1 < 1 / r2	
		则 1 / r2 > l2 / r1
		又 l2 / r1 > 1 / r1
		则 1 / r2 > 1 / r1	恒成立 
	2. 1 / r1 < l2 / r1  	恒成立
	3. l1 / r2 < 1 / r2		无解(不可能出现) 
	4. l1 / r2 < l2 / r1
	*/
	sort(a + 1, a + n + 1, cmp);
	Num ans, cur;
	ans.init(0);
	cur.init(x);
	for(int i = 1;i <= n;i ++ ) {
		ans = max(ans, cur / a[i].r);
		cur = cur * a[i].l;
	}
	printf("%d", ans.num[ans.len]);
	for(int i = ans.len - 1;i >= 1;i -- ) {
		printf("%05d", ans.num[i]);
	}
	return 0;
}
```

---

## 作者：JingchenBian (赞：4)

本题解是对**按左右手乘积排序**的贪心证明。

设第 $i$、$j$ 两个人，$i$、$j$ 相邻，$i$ 左手 $a[i]$、右手 $b[i]$，$j$ 左手 $a[j]$、右手 $b[j]$。

1. 如果 $i$ 在 $j$ 前面，对最终答案的影响值是$a[0]\div b[j]$（$a[0]$ 为国王左手的数，$b[j]$ 为大臣j右手的数）和$(a[0]\times a[i])\div b[j+1]$（$a[i]$ 为大臣 $i$ 左手的数，$b[j+1]$ 为大臣 $j+1$ 右手的数，以此类推）。

2. 如果 $j$ 在 $i$ 前面，对最终答案的影响值是 $a[0]\div b[i+1]$ 和 $(a[0]\times a[j])\div b[i]$。

   要保持 $i$ 在 $j$ 前面使得答案更小，必须满足：

   - $a[0]\div b[j] < a[0]\div b[i+1]$ 和 $ (a[0]\times a[i])\div b[j+1] < (a[0]\times a[j])\div b[i]$。
   - 由于 $a[0]$ 是固定的，所以可以去掉，得到$1\div b[j] < 1\div b[i+1]$ 和 $a[i]\div b[j+1] < a[j]\div b[i]$。
   - 注意到 $1\div b[j]$ 总是小于等于 $a[k]\div b[j]$（其中 $a[k]$ 为任意大臣左手的数），$a[i]\div b[j+1]$ 总是大于等于 $1\div b[j+1]$，所以只需满足$a[i]\div b[j+1] < a[j]\div b[i]$，即 $a[i]\times b[i] < a[j]\times b[j]$。

---

## 作者：VitrelosTia (赞：4)

看到任意排列想到邻项交换贪心，发现交换两个相邻并不会造成其他影响，而对于相邻两人而言，肯定是他们两者的最大值越小越好，于是可以直接假设相邻两项 $(a_x, b_x)$，$(a_y, b_y)$，前面的 $\prod a = k$，那么 $x$ 排在 $y$ 的条件是 $\dfrac{ka_x}{b_y} < \dfrac{ka_y}{b_x}$，把 $k$ 除掉并去分母可得 $a_xb_x<a_yb_y$，直接按这个排序即可。要高精度，让豆包帮你把 c++ 翻译成 python 即可。

```cpp
// 不可通过的

#include <bits/stdc++.h>
using namespace std;

const int N = 1005;
int n; struct Node { int a, b; } o[N];

signed main() {
	cin >> n;
	for (int i = 0; i <= n; i++) cin >> o[i].a >> o[i].b;
	sort(o + 1, o + n + 1, [](Node x, Node y) { return x.a * x.b < y.a * y.b; });
	int ans = 0, pre = o[0].a;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, pre / o[i].b);
		pre *= o[i].a;
	}
	cout << ans;
	return 0;
}
```

```python
# 可通过的，大体是豆包写的，改了一点

n = int(input())
o = []
for i in range(0, n + 1):
    a, b = map(int, input().split())
    o.append((a, b))
o[1:] = sorted(o[1:], key=lambda x: x[0] * x[1])
ans = 0
pre = o[0][0]
for i in range(1, n + 1):
    ans = max(ans, pre // o[i][1])
    pre *= o[i][0]
print(ans)
```

---

## 作者：Jerry_zpl (赞：3)

好难，我至少敲了一个小时的代码，加上思考就有两个小时了，不过通过了，来记录一下。

----
首先思路并不难，我们主要分为以下几点：
- 我们要知道，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。那么“向下取整”这个词就告诉我们，只需要用整形变量存即可。
- 这题我们必须考虑一下贪心。我们可以将每位大臣写的数字的乘积从小到大排序，因为本题要求最大金币个数，所以一个数除以一个越小的数得到的数反而越大。
- 排完序后我们就要算出每位大臣前面的乘积，再除以国王手上的数即可，记得取最大值并输出。

主要就是以上几点，不过看一下数据范围。哇，整形变量根本就存不下，所以我们在算的时候需要用到高精度运算：
- 我们用一个数组来算积。这里的乘法属于高精乘低精，比较好算。先把每一位都乘以 $x$，再把下一位的数加上这一位的数除以 $10$，最后求出进的多少个十，然后将这一位取模十。小细节：如果位数超过了之前的长度，要将长度增加。
- 别忘了在算积之前还要算除法。除法比较难处理。我们可以先定义一个数组来存最终的答案，然后把被除数的每一位都去除以这个数。注意：我们算除法时是从**最高位**开始算的，所以第 $i-1$ 位是第 $i$ 位的下一位。所以要在下一位加上这一次剩下的余数。最后直接赋值答案并返回即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2005;
int n;
int a;
int b;
int s[maxn*4];
int ans[maxn*4];
int ls=1;
int lans;
struct dc

{
	int x,y;
}c[maxn];
bool cmp(dc e,dc f)
{
	return e.x*e.y<f.x*f.y;
}
void f(int t)
{	
	int d[maxn*4]={0};
	int ld=ls;
	for(int i=ls;i>=1;i--)
	{
		d[i]+=s[i];
		d[i-1]=d[i]%t*10;
		d[i]/=t;
	}
	while(d[ld]==0&&ld)
	{
		ld--;
	} 
	bool flag=false;
	if(lans<ld)
	{
		flag=true;
	}
	else if(lans>ld) 
	{
		flag=false;
	}
	else
	{
		for(int i=ld;i>=1;i--)
		{
			
			if(ans[i]>d[i])
			{
				flag=false;
				break;	
			}
			if(ans[i]<d[i])
			{
				flag=true;
				break;	
			}
		}
	}
	if(flag==true)
	{
		lans=ld;
		for(int i=1;i<=ld;i++)
		{
			ans[i]=d[i];
		}
	}
	return ;
	
}
signed main()
{
	cin>>n;
	cin>>s[1];
	cin>>b;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i].x;
		cin>>c[i].y;
	}
	sort(c+1,c+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		f(c[i].y);
		for(int j=1;j<=ls;j++)
		{
		   s[j]*=c[i].x;
		}
		for(int j=1;j<=ls;j++)
		{
			s[j+1]+=s[j]/10;
			s[j]%=10;
			if(s[ls+1]>0)
			{
				ls++;
			}
		}	
	}
	for(int i=lans;i>=1;i--)
    {
		cout<<ans[i];	
	}
	if(lans==0)
	{
		cout<<0;
		return 0;
	}
	return 0; 
}
```
最后要提醒大家：如果答案长度为 $0$，要记得输出零，不然就会错。

---

## 作者：TainityAnle (赞：3)

### 题意

有 $n+1$ 个人站成一排，从初始位置 $0$ 到 $n$。每个人有两个数字 $a_i$ 和 $b_i$。第 $i$ 个人的收益是 $\displaystyle\frac{1}{b_i}\times\prod_{j=0}^{i-1}{a_j}$。

对位置 $1$ 到 $n$ 的人排序，最小化收益最大的人的收益，输出收益最大的人最小的收益。

### 思路

提供一种很直接的思路。

考虑什么情况下要交换两人的位置。

设当前位置为 $i$，$i$ 位置的人获得的收益为 $\displaystyle\frac{1}{b_i}\times\prod_{j=0}^{i-1}{a_j}$，$i+1$ 位置的人收益为 $\displaystyle\frac{1}{b_{i+1}}\times\prod_{j=0}^{i}{a_j}$，这个式子又可以写成 $\displaystyle\frac{a_i}{b_{i+1}}\times\prod_{j=0}^{i-1}{a_j}$。

如果将 $i$ 与 $i+1$ 位置的人交换位置，那么他们获得的收益将变成 $\displaystyle\frac{1}{b_{i+1}}\times\prod_{j=0}^{i-1}{a_j}$ 和 $\displaystyle\frac{a_{i+1}}{b_i}\times\prod_{j=0}^{i-1}{a_j}$。

可以证明，交换相邻的两个人只会影响他们两个的收益，而不会影响其他人。因为在 $i$ 之前的 $a_j$ 积不受 $a_i$ 和 $a_{i+1}$ 的影响；又因为乘法满足交换律，所以先乘 $a_i$ 还是 $a_{i+1}$ 最后的积不变。

在上面的式子中，我们发现可以把公因式 $\displaystyle\prod_{j=0}^{i-1}{a_j}$ 提出来。这样方便比较大小，。如果不交换，收益更多的人的收益为 $\displaystyle\max(\frac{1}{b_i},\frac{a_i}{b_{i+1}})\times\prod_{j=0}^{i-1}{a_j}$；如果交换，收益更多的人的收益为 $\displaystyle\max(\frac{1}{b_{i+1}},\frac{a_{i+1}}{b_{i}})\times\prod_{j=0}^{i-1}{a_j}$。如果后者小于前者，显然交换更优。

比较两个式子的大小，可以先通分，变成 $\displaystyle\max(\frac{b_{i+1}}{b_ib_{i+1}},\frac{a_ib_i}{b_ib_{i+1}})$ 和 $\displaystyle\max(\frac{b_i}{b_ib_{i+1}},\frac{a_{i+1}b_{i+1}}{b_ib_{i+1}})$。

然后提取公因式 $\displaystyle\frac{1}{b_ib_{i+1}}$，变成 $\max(b_{i+1},a_ib_i)$ 和 $\max(b_i,a_{i+1}b_{i+1})$。

如果 $a_ib_i<a_{i+1}b_{i+1}$，因为 $b_i\le a_ib_i$，所以 $b_i<a_{i+1}b_{i+1}$。讨论 $b_{i+1}$ 和 $a_ib_i$ 的大小。

1. 如果 $b_{i+1}<a_ib_i$，那么就是 $a_ib_i$ 和 $a_{i+1}b_{i+1}$ 比大小，显然前者小于后者。
2. 如果 $b_{i+1}>a_ib_i$，那么就是 $b_{i+1}$ 和 $a_{i+1}b_{i+1}$ 比大小，显然前者小于后者。

所以发现若 $a_ib_i<a_{i+1}b_{i+1}$，不交换的情况更优。因为对于每对 $(i,i+1)$ 都满足此条件，所以只要按 $a_ib_i$ 从小到大排序，就是最优情况。

最后注意，本题用到了累乘，导致答案可能会到 $a^n$ 级大小。这样大的数字是需要用高精计算的。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node {
	int a,b,lans;
	char cnta[10000],all[10000],ca[100],ans[10000];
} num[1001];
bool cmp(node a,node b) {
	return a.a*a.b<b.a*b.b;
}
bool cmp2(node a,node b) {
	if(a.lans!=b.lans) return a.lans>b.lans;
	for(int i=0; i<a.lans; i++)
		if(a.ans[i]!=b.ans[i])
			return a.ans[i]>b.ans[i];
	return 1;
}
void solve(int a,char b[]) {
	int lb=0;
	while(a>0) b[lb++]=a%10+'0',a/=10;
	b[lb]='\0';
}
void add(char c[],char d[],int i) {
	int lc=strlen(c);
	int jw=0,tmp;
	for(int j=0; j<lc; j++,i++) {
		tmp=(d[i]>0?d[i]-'0':0)+c[j]-'0'+jw;
		d[i]=tmp%10+'0';
		jw=tmp/10;
	}
	if(jw) d[i++]=jw+'0';
	d[i]='\0';
}
void gc(char a[],char b[],char d[]) {
	int la=strlen(a),lb=strlen(b);
	char c[10000];
	for(int i=0; i<la; i++) {
		int tmp,jw=0,lc=0;
		for(int j=0; j<lb; j++) {
			tmp=(a[i]-'0')*(b[j]-'0')+jw;
			c[lc++]=tmp%10+'0';
			jw=tmp/10;
		}
		if(jw) c[lc++]=jw+'0';
		c[lc]='\0';
		add(c,d,i);
	}
}
void mult(char a[],int b, char c[]) {
	int i=0,tag=0,la=strlen(a),lc=0,d=0;
	while(i<=la) {
		if(b>d) {
			d=d*10+a[i++]-'0';
			if(tag) c[lc++]='0';
		} else {
			c[lc++]=d/b+'0';
			d=d%b;
			d=d*10+a[i++]-'0';
			tag=1;
		}
	}
	if(tag==0) c[lc++]='0';
	c[lc]='\0';
}
int main() {
	cin>>n;
	for(int i=0; i<=n; i++) cin>>num[i].a>>num[i].b;
	sort(num+1,num+n+1,cmp);
	solve(num[0].a,num[0].ca);
	num[0].cnta[0]='1',num[0].cnta[1]='\0';
	for(int i=1; i<=n; i++) {
		solve(num[i].a,num[i].ca);
		gc(num[i-1].cnta,num[i-1].ca,num[i].cnta);
	}
	for(int i=1; i<=n; i++) {
		int k=0;
		for(int j=strlen(num[i].cnta)-1; j>=0; j--)
			num[i].all[k++]=num[i].cnta[j];
		num[i].all[k]='\0';
	}
	for(int i=1; i<=n; i++) {
		mult(num[i].all,num[i].b,num[i].ans);
		num[i].lans=strlen(num[i].ans);
	}
	int ans=1;
	for(int i=2; i<=n; i++)
		if(!cmp2(num[ans],num[i]))
			ans=i;
	cout<<num[ans].ans;
	return 0;
}
```

---

## 作者：wanghonghui123 (赞：2)

## 思路

- 此题需要**高精度**。

1. 可以用结构体，里面定义连个数 $l$ 和 $r$，分别表示每个大臣左右手上的数字。

2. 随后可以弄一个自定义排序，需要让拿到最多金币的人最少，使用到了一个**贪心**的思想。

3. 然后写一个两数的比较函数，要用高精度的方法：

   - 如果两个比较的数的长度不相等，就返回谁更大，如果他们的长度差大于 $0$，$a$ 更大，可如果小于 $0$，就说明 $b$ 更大。
  
   - 否则，就比较每一位的数字，来比大小。
  
4. 接着是高精度乘，需要考虑进位。

5. 还有高精度除，需要考虑余数，而被除数的更新则是**余数向右移动一位，再加上当前位**。

6. 先算出国王的左手值，在计算当前人获得的金币，然后要更新最大值。


## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
struct stu{
	int l;
	int r;
}f[1005];
bool cmp(stu a,stu b){
	return a.l*a.r<b.l*b.r;
}
int n;
vector<int> ans(1,0);
vector<int> t(1,1);
inline vector<int> mul(vector<int> &a,int b){
	vector<int> res;
	int t = 0;
	int len = a.size();
	for(int i=0;i<len;i++){
		t+=a[i]*b;
		res.push_back(t%10);
		t/=10;
	}
	while(t){
		res.push_back(t%10);
		t/=10;
	}
	return res;
}
inline vector<int> div(vector<int> &a,int b){
	vector<int> res;
	int r = 0;
	int len = a.size();
	for(int i=len-1;i>=0;i--){
		r = 10*r+a[i];
		if(r>=b){
			res.push_back(r/b);
			r%=b;
		}else{
			res.push_back(0);
		}
	}
	vector<int> cnt;
	len = res.size();
	for(int i=len-1;i>=0;i--){
		cnt.push_back(res[i]);
	}
	while((cnt.back()==0)&&(cnt.size()>1)){
		cnt.pop_back();
	}
	return cnt;
}
inline int compare(vector<int> &a,vector<int> &b){
	int lenA = a.size();
	int lenB = b.size();
	if(lenA!=lenB){
		int t = lenA-lenB;
		return t;
	}else{
		for(int i=lenA-1;i>=0;i--){
			if(a[i]!=b[i]){
				int t = a[i]-b[i];
				return t;
			}
		}
		return 0;
	} 
}
int main(){
	cin>>n;
	cin>>f[0].l>>f[0].r;
	for(int i=1;i<=n;i++){
		cin>>f[i].l>>f[i].r;
	}
	sort(f+1,f+1+n,cmp);
	t = mul(t,f[0].l);
	for(int i=1;i<=n;i++){
		vector<int> res = div(t,f[i].r);
		if(compare(ans,res)<0){
			ans = res;
		}
		t = mul(t,f[i].l);
	}
	int len = ans.size();
	for(int i=len-1;i>=0;i--){
		cout<<ans[i];
	}
	cout<<endl;
	return 0;
}
```

---

## 作者：aiyougege (赞：2)

P1080 国王游戏
### Solution
　　首先题目我们需要对大臣进行一定的排序, 使得获得最多奖赏的大臣奖赏最少, 前面的题解已经写的很清楚了, 如果大臣 $\text{a,b}$ , $\text{a}$ 排在 $\text{b}$ 前面的条件是 $\text{a.left}\times \text{a.right}<\text{b.left}\times \text{b.right}$.

　　那么做法就比较显然了, 只需要对所有人的左右手乘起来排个序就好.然后统计答案, 最头疼的地方是需要用高精, 我自然是非常头疼, 但是可以不用c++啊, 可以用 **Python** 水一波啊, 毕竟人家最擅长的就是科学运算.

　　但是在用 **Python** 开心的写了一波之后发现只得了[60分](https://www.luogu.org/record/show?rid=6431680).竟然还 **WA** 了一个点, 真是没办法忍受, 然后想方设法得到了 **RE** 的数据, 发现了 **RE** 的原因.

```
OverflowError: integer division result too large for a float
```

　　百度之后发现是因为**Python**的浮点数是**c语言**的**float**, 所以会出锅.
然后就想自己写一个**整数**除法, 先**取余**, 然后**二分**除法的结果.结果又出现了类似的问题.醉了.

　　然后又百度, 好像是找到三种**解决方案**
- **$\text{from \_\_future\_\_ import division}$**
- **$\text{divmod()}$函数**
- **$\text{decimal}$模块**
- **$\text{a//b}$**, 等效于a整除b, 不会产生浮点运算, 但是不如第二种快, 不知道为什么.

　　可以自己百度具体的使用方法.我使用的第二种方法, 实际上$\text{divmod(a,b)}$返回$\text{(int(a/b), a mod b)}$
  
  
　　在通过上述艰难过程后, 终于通过了...
### Code
```
#表示Python的注释
class Minister:#定义了一个类
    def __init__(self, left, right, lefttimesright):#初始化函数
            self.left = left
            self.right = right
            self.lefttimesright = lefttimesright
    def __repr__(self):
            return repr((self.left, self.right, self.lefttimesright))

n=int(input());#input()读入一行
wang=list(map(int,input().split()));#将读入的一行转化为[a,b,...], []为列表list
s=[]

for i in range(0,n):
    guo=list(map(int,input().split()));
    s.append(Minister(guo[0],guo[1],guo[0]*guo[1]));

ss=sorted(s, key=lambda student: student.lefttimesright)#将排序后的结果赋值给ss
lei=wang[0]
i=0
ans=0
while i<n:
    jieguo=divmod(lei,ss[i].right)#jieguo=(a//b,a%b),jieguo[0]=a//b
    #print(jieguo[0])
    if jieguo[0]>ans:
        ans=jieguo[0];
    lei*=ss[i].left;
    i=i+1;

print(ans)#输出
```

---


# 【模板】有理数取余

## 题目描述

给出一个有理数 $c=\frac{a}{b}$，求 $c \bmod 19260817$ 的值。

这个值被定义为 $bx\equiv a\pmod{19260817}$ 的解。

## 说明/提示

对于所有数据，保证 $0\leq a \leq 10^{10001}$，$1 \leq b \leq 10^{10001}$，且 $a, b$ 不同时是 $19260817$ 的倍数。

## 样例 #1

### 输入

```
233
666
```

### 输出

```
18595654
```

# 题解

## 作者：学委 (赞：441)

*2019-02-22 更新*

分数取余？我不知道是什么概念。分子分母还特别大？

一步一步来。

**考虑一下，分数取余也要满足取余运算的性质！**

取余运算的性质有：

* **如果两个数对模 $p$ 同余，那么它们乘上同一个数以后依然对模 $p$ 同余。$(I)$**

所以，虽然我不知道分数取余是什么，但是如果

$x \equiv \frac{a}{b} \pmod p$ （满足此方程的 $x$ 有多个，本题实际上是要求**最小的正整数解**，求出任意一个 $x$ ，模 $p$ 后即本题答案）

那么根据 $(I)$，它可以两边同时乘以 $b$，

$ x × b \equiv \frac{a}{b} × b \pmod p$

那么问题已经转化为：

**已知 $bx \equiv a \pmod p$ ①，求 $x$。**

等等，先别看这个。**如果这时我们能求出一个 $x_1$ 使得 $bx_1 \equiv 1 \pmod p$ ② 呢？**

又根据 $(I)$，② 两边同时乘以 $a$ 后仍然成立：

$b × (ax_1) \equiv a \pmod p$

和 ① 对比一下，可见 $a × x_1$ 就是答案 $x$ 了（别忘了最后模一下 $p$）。

**于是抛出一个问题 II：求一个 $x_1$ 满足 $bx_1 \equiv 1 \pmod p$**。

如果你不能解决，你需要问题 II [P1082 同余方程](https://www.luogu.org/problemnew/show/P1082)，我也发布了它的一份[题解](https://cicos.blog.luogu.org/solution-p1082)（本题解的中间部分）！

问题 II 解决了，那 $a,b$ 太大怎么解决？

**把条件 $bx \equiv a \pmod p$ 也转化一下：**

$(b \mod p) × x \equiv a \mod p \pmod p$

这个转化为什么是对的？其实你可以按照程序中的模运算来理解，任何同余式右边的 $\pmod p$ 相当于对两边结果分别进行一次最终模运算。对于其中的因数，你不管怎么模，同余式都保持成立。

由此可见，只要在快读的时候也不断把 $a,b$ 对模数求余就好了。

题目说还有无解的情况？

* 当 $b$ 是 $p$ 的倍数时，$bx \mod p = 0$。

  * 如果 $a$ 也是 $p$ 的倍数，则 $a \mod p = 0$，所以 $bx \equiv a \pmod p$ 恒成立（有无数解）。

  * 如果 $a$ 不是 $p$ 的倍数，则 $a \mod p ≠ 0$，故上面这个方程不可能成立。

* 若 $b$ 不是 $p$ 的倍数，那么因为模数是一个质数，所以 $b$ 与 $p$ 互质，那么 $bx_1 \equiv 1 \pmod p$ 一定有解（根据问题 II 中的一个结论），故一定有符合条件的 $x = a × x_1$。

所以当且仅当 $b \mod p = 0$ 时无解。

重新理清思路：求解 $\frac{a}{b} \mod p$。

* 读入 $a, b$ 时用快读（分字符读入），以便于在其中直接模 $p$。

* 判断取余后的 $b$ 是不是 $0$，是则无解或者无意义，不是则一定有解。

* 求解关于 $x_1$ 的方程：$bx_1 \equiv 1 \pmod p$。

* 答案 $x$ 等于 $a × x_1 \mod p$。

```cpp
#include <cstdio>
#include <cctype>
const int MOD = 19260817;//MOD是题解中的"p"
inline int getint()
{
    int res = 0, ch = getchar();
    while(!isdigit(ch) and ch != EOF)
        ch = getchar();
    while(isdigit(ch))
    {
        res = (res << 3) + (res << 1) + (ch - '0');
        res %= MOD;//直接对MOD取余
        ch = getchar();
    }
    return res;
}

int x, y;
void exgcd(int a, int b)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b);
    int Last_x = x;
    x = y;
    y = Last_x - a / b * y;
}

int main()
{
	int a, b;
    a = getint();
    b = getint();
    
    if(b == 0)
    {
        puts("Angry!");
        return 0;
    }
    exgcd(b, MOD);
    x = (x % MOD + MOD) % MOD;
    printf("%lld\n", a * (long long)(x) % MOD);//小心相乘后爆int
    return 0;
}
```

___

更新日志：

2019-02-22 打扫了 `mimi` 指出的错误，很感谢；修改语句。

---

## 作者：顾z (赞：70)

**题目描述**

给出一个有理数 c=a/b ，求 c mod 19260817的值。

**说明**

对于所有数据， 0≤a,b≤10^10001

**分析:**

一看题 这么短 哇简单！况且19260817还是个素数！(美滋滋

再一看数据 我天 可怕 **10^10001**

一看 完了 要打高精 ~~(但我打高精肯定GG啊~~

一想 根据**同余**好像可做~~(前面的大佬讲过了我就不赘述了~~

哦 对了 还有**~~费马小定理~~**:

**a^phi(p)≡1(mod p)**  (只对于**p是质数**的情况哦

然后对于**快读** 略做修改就可以了 

--------------------代码----------------------

```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define mod 19260817
long long a,b,ans;
IL void read(long long &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10%mod+(s-'0')%mod;s=getchar();}//改成了取模~~
    x=x%mod*f;//改成了取模~
}
IL long long ksm(long long x,long long p)
{
	long long res=1;
	for(;p;p>>=1,x=x*x%mod)
		if(p&1)res=res*x%mod;
	return res;
}//快速幂
int main()
{
	read(a);read(b);
	if(b==0){printf("Angry!");return 0;}
    //注意这里 特判！ 不要忘记 还有 不要忘记感叹号！！！
	ans=a*ksm(b,mod-2);
	printf("%lld",(ans%mod+mod)%mod);
}
```

---

## 作者：Arcturus1350 (赞：21)

我们先看这个式子：

$c=\dfrac{a}{b}$ $ $ $ $ $mod$ $ $ $ $ $19260817$

某正常高中生：这$……$

---

对于这个 $c$ 。

显然，它很可能是小数。

那么， $double$ 的取余你老师讲过么$?!!!$

所以，我们要~~化简~~魔改一下这个式子。

---

$$c=\dfrac{a}{b}=a*b^{-1}$$

又因为是 $mod$ $ $ $p=19260817$ 的意义下的计算。

所以，现在就有了一种化小数为整数的方法：

### 乘法逆元

$c=a*b^{-1}≡a*b^{p-2}$ $ $ $ $ $ mod $ $ $ $ $ $ p $

而在这里， $ p $ $ = $ $ 19260817 $

并且，当 $b^{p-2}≡0$ $ $ $ $ $ mod $ $ $ $ $ $ p $ 时，

分母为 $0$ ，无解。

所以答案就出来了。

---

好了，天真的认为我~~们~~以为这样就行了。

然而$……$

$0≤a,b≤10^{10001}$ 

高精模低精按位先模到 $int$ 或 $long$ $ $ $ long$ 以内，在做。

然后调了三天终于$A$了。

---

本宝宝在这里在吐槽一番：

定义变量忘了初始化$……$

数据出锅玄学$RE$ $……$

也是没谁了。

---

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int p=19260817;
int a[10100];
int b[10100];
char a1[10100];
char b1[10100];
int l1,l2;
int len1,len2;
long long x,y;

long long pow2(long long a,long long b)
{
    long long res=1;
    for(;b;b>>=1,a=a*a%p) if(b&1) res=res*a%p;
    return res%p;
}

void calculet_1()
{
	long long num=0;
	for(int i=len1;i<=len1+8;i++)
	    num*=10,num+=a[i];

	num%=p;
	for(int i=len1+8;i>=len1;i--)
	{
		int now=num%10;num/=10;
		a[i]=now;
	}

	for(int i=0;i<=8;i++) if(a[len1+i]!=0){len1+=i;break;}
}

void calculet_2()
{
	long long num=0;
	for(int i=len2;i<=len2+8;i++)
	    num*=10,num+=b[i];
	num%=p;
	for(int i=len2+8;i>=len2;i--)
	{
		int now=num%10;num/=10;
		b[i]=now;
	}

	for(int i=0;i<=8;i++) if(b[len2+i]!=0){len2+=i;break;}
}

signed main()
{
//	freopen("testdata.in","r",stdin);
//	freopen("1.out","w",stdout);

	scanf("%s",a1);
	scanf("%s",b1);
//	printf("%s\n",b1);
	l1=strlen(a1);
	l2=strlen(b1);//输入以及处理数据。

	for(int i=0;i<l1;i++)
	  a[i]=a1[i]-'0';
	for(int i=0;i<l2;i++)
	  b[i]=b1[i]-'0';//将char 变int（个人不习惯用char做运算）
	
	while(l1-len1>=10) calculet_1();
	while(l2-len2>=10) calculet_2();//计算，我是从高位到低位依次减的，可以省时间。

	for(int i=len1;i<l1;i++) x*=10,x+=a[i];
    for(int i=len2;i<l2;i++) y*=10,y+=b[i];
    x%=p;y%=p;//计算取模之后的值。
	
//	printf("%lld\n",y);
    if(x==0){puts("0");return 0;}
    if(y==0){puts("Angry!");return 0;}//特判

	long long ans=pow2(y,p-2);
//	printf("%lld\n",ans);
    ans=(ans*x)%p;

    printf("%lld",ans);//计算答案和输出
    return 0;//程序拜拜
}


```

---

## 作者：STPGUY (赞：13)

因为蒟蒻我欧几里得扩展学的不好(~~不会~~),所以我就简单的提一提一个十分类似的玩意儿:
# 逆元 ! ! !
所以什么是逆元呢?

我就简单的说一说用费马小定理实现的逆元吧:

首先有一个数X, 另一个数Y, 还有一个质数P, 

你要求X &#247; Y mod P,    怎么办呢?

### 逆元:
>>令 Y' 为 Y 的逆元, 那么有 Y * Y'  &equiv; 1 (mod P)

>>&#8756;有X &#247; Y &equiv; X  &#247;  Y * 1  &equiv; X &#247; Y * (Y * Y') &equiv; X * Y'(mod P)

>>显然可以看出 Y'的值可以为 &#8543;Y

>>但是乘上&#8543;Y与除以Y的效果是一样的

题目链接 : [乘法逆元](https://www.luogu.org/problem/P3811)

## 费马小定理闪亮登场:
>>>>>![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/0dd7912397dda144345f911eb9b7d0a20df486cc.jpg)

>>>>>[证明~~蒟蒻我看不懂~~](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin)

>>>于是就可以愉快的得出Y' = Y ^ (P - 2)

>>>具体实现就可以用快速幂了 ~QWQ~

# 一级大标题(Code Time)
```cpp
#include <cstdio>

typedef long long LL;
const LL Mod = 19260817;
LL N, M;

inline void Read(LL &X)
{
    X = 0;
    char O = getchar();
    while (O < '0' || O > '9') O = getchar();
    while (O >= '0' && O <= '9')
    {
        X = ((X << 1) + (X << 3) + (O ^ 48)) % Mod;//输入有点大,特殊处理一下
        O = getchar();
    }
}

LL QPow(LL X, LL K, LL Y)
{
    LL Ans (1);
    while (K)
    {
        if (K & 1)Ans = 1ll * Ans % Mod * X % Mod;
        X = 1ll * X * X % Mod;
        K >>= 1;
    }
    return 1ll * Ans % Mod * Y % Mod;//随时取模好习惯
}

int main()
{
    Read(N), Read(M);// 好像输入有点大(~~非常大~~)
    if (M)printf("%lld\n", QPow(M, Mod - 2, N));
    else puts("Angry!");//如果M为零,当然无解啦
}

```
PS:[好像是一样的( •̀ ω •́ )](https://www.luogu.org/problem/P1082) 



---

## 作者：qsmoonzh (赞：8)

设p=19260817，显然p是一个质数

我们要求a/b mod p

设x ≡ a/b (mod p)

设t=a/b mod p=x mod p，（这个t是我们要求的，但是我们暂时求不出来，现在的目标是求x）

由此可以得到两个方程：

**a/b=k1\*p+t** 也即 **a=k1\*b\*p+b\*t**

**x=k2\*p+t** 也即 **b\*x=k2\*b\*p+b\*t**

其中k1，k2为任意整数

两式相减，得 **a-b\*x=(k1-k2)\*b\*p**

k1，k2为任意整数，令k=(k1-k2)\*b，k的取值范围是整数集合

得**a-b\*x=k\*p**，移项，得**a=b\*x+k\*p**

注意到，此方程中k，x为未知数

因此可用扩展欧几里得求x

**a=b\*x+k\*p**有解当且仅当gcd(b,p)|a，若a%gcd(b,p)!=0直接输出Angry!

先求**d=gcd(b,p)=b\*x1+p\*y1**

等式**d=b\*x1+p\*y1**两边同乘a/d

得**a=b\*(x1\*a/d)+p\*(y1*a/d)**

x=x1\*a/d，k=y1*a/d 即为**a=b\*x+k\*p** 的一组特解

x可能是负数，因此，我们输出((x%p)+p)%p即可

但是一看数据范围，，，

我们还得想办法

从**a=b\*x+k\*p**这个等式入手，a可以写成a1+k4\*p，b可以写成b1+k5\*p（其中a1=a%p，b1=b%p）

然后得**a1+k4\*p=(b1+k5\*p)\*x+k\*p**

**a1=b1\*x+(k-k4+k5\*x)\*p**

而k为任意整数，因此可以直接得到**a1=b1\*x+k\*p**

也就是说**a=b\*x+k\*p**和**a%p=b%p\*x+k\*p**等价

于是我们读入的时候取模就好了

代码：

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
#define p 19260817

long long a,b,x,y,d,k;
long long read() {
	long long ans=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') ans=(ans*10+c-'0')%p,c=getchar();
	return ans;
}
long long exgcd(long long a,long long b) {
	if(b==0) {
		x=1,y=0;
		return a;
	}
	long long d=exgcd(b,a%b);
	long long z=x;
	x=y;
	y=z-y*(a/b);
	return d;
}
int main() {
	a=read();
	b=read();
	d=exgcd(b,p);
	if(a%d!=0) printf("Angry!");
	else printf("%lld",((x*a/d%p)+p)%p);
	return 0;
}
```



---

## 作者：JasonZRY (赞：6)

### 这是高精度？？？

### 不不不，高精度会死！！！

那用什么？你见过有理数取模吗？我们可以转换一下，

c=a*b^(-1)，那这道题不就变成裸的求逆元了吗？但是怎么输入呢？先用字符串读入，在转化成数字的时候取模就行了，求逆元其实有线性的算法。

代码如下：

```
#include<bits/stdc++.h>
#define ll long long int
using namespace std;
char a1[10005],b1[10005];
long long a,b,c,m=19260817,ans;
int k[19260819];
int main(){
    cin>>a1>>b1;
    long long lena=strlen(a1)-1,lenb=strlen(b1)-1;
    for(int i=0;i<=lena;i++)a=((a*10)%m+a1[i]-'0')%m;
    for(int i=0;i<=lenb;i++)b=((b*10)%m+b1[i]-'0')%m;
    if(b==0){
        printf("Angry!");
        return 0;
    }
    k[1]=1;
    for(int i=2;i<=b;i++)
    k[i]=(((-m/i+m)%m)*k[m%i]+m)%m;
    ans=(a*k[b])%m;
    cout<<ans;
    return 0;
}
```
Thanks for watching

%%%orz


---

## 作者：Great_Influence (赞：6)

不要管高精。。。可以发现，$a$和$b$只有对$mod$的余数才会有用。直接一路滚过去取模即可。至于除法，费马小定理需要了解:

$$a^{p-1}\equiv 1\pmod p$$

推导一下就可以得到:

$$a^{p-2}\equiv a^{-1}\pmod p$$

答案就是

$$a*b^{-1}$$

直接计算即可。

代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}

const int MAXN=1e4+7;

const int mod=19260817;

static char a[MAXN],b[MAXN];

static int n,m,A,B;

typedef long long ll;

inline int power(int a,int b)
{
	static int sum;
	for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
		sum=(ll)sum*a%mod;
	return sum;
}

int main(void){
    file();
	scanf("%s%s",a,b);n=strlen(a)-1,m=strlen(b)-1;
	Rep(i,0,n)A=(A*10+(a[i]^48))%mod;
	Rep(i,0,m)B=(B*10+(b[i]^48))%mod;
	if(B==0)return puts("Angry!"),0;
	printf("%d\n",(ll)A*power(B,mod-2)%mod);
	return 0;
}

```

---

## 作者：lahlah (赞：4)

首先题目简短明了

	这题主要就是要求b的逆元
    
首先我们观察一下这个模数,嗯,是个质数（下面我们用模数来代替这个质数），所以根据我们伟大的费马小定理，可以直接得出 b 的逆元就是 b^p-2，怎么推出来的呢，就是因为费马小定理是 a^p-1≡1（mod p）,当p为质数的时候成立，我们就把b带进去，*b^p-1 ≡ 1 (mod p )* 所以可以直接用快速幂求辣。

等等。。。当b为p的倍数的时候是不成立的（没有逆元）

代码：

```
#include<bits/stdc++.h>
#define ll long long
#define mod 19260817
using namespace std;
char st[10005];
int main(){
	scanf("%s",st);//根本不用高精度，在输入的时候模就好了
	int len=strlen(st);
	int a=0;
	for(int i=0;i<len;i++){
		a=a*10+st[i]-'0';
		a=a%mod;
	}
	scanf(" %s",st);
	len = strlen(st);
	int b=0;
	for(int i=0;i<len;i++){
		b=b*10+st[i]-'0';
		b=b%mod;
	}
	ll ans=1;
	ll t=b;
	if(t%mod==0) {printf("Angry!");return 0;}//如果是模数的倍数就呵呵
	for(int i=mod-2;i;i>>=1,t=t*t%mod) if(i&1) ans=ans*t%mod;//快速幂
	ans=ans*a%mod;
	printf("%lld",ans); //哈哈
	return 0;
}
//别走，还有扩欧的
```

求逆元嘛，我们还可以用扩展欧几里得啊

我们知道，扩展欧几里得是用来求*ax + by = gcd(a, b)* 这类问题的，那么对于求逆元，*ax ≡ 1(mod b)* ,可以转换成 *ax + by = 1*,当然这里a,b也要是互质的，所以x就是 a 关于mod b意义下的逆元辣。
又可以开始写辣

```
#include<bits/stdc++.h>
#define ll long long
#define mod 19260817
using namespace std;
char st[10005];
ll exgcd(ll &x,ll &y,ll a,ll b,ll &d){ //正常的扩展欧几里得
	if(!b) {d=a;x=1;y=0;}
	else {
		exgcd(x,y,b,a%b,d);
		int t=x;
		x=y;y=t-(a/b)*y;
		x=x%mod;y=y%mod;
	}
}
int main(){
	scanf("%s",st);//输入同上
	int len=strlen(st);
	int aa=0;
	for(int i=0;i<len;i++){
		aa=aa*10+st[i]-'0';
		aa=aa%mod;
	}
	scanf(" %s",st);
	len = strlen(st);
	int bb=0;
	for(int i=0;i<len;i++){
		bb=bb*10+st[i]-'0';
		bb=bb%mod;
	}
	ll x,y,a,b,d;
	a=bb;b=mod;
	exgcd(x,y,a,b,d); //求b关于模数的逆元
	if(d>1) {printf("Angry!");return 0;} //如果是模数的倍数则没有逆元
	for(;x<0;) x+=mod; //最好把x变为正数
	ll ans=aa*x%mod; 
	printf("%lld",ans);//输出
	return 0;
}
```
[偷偷安利一下自己的blog](https://blog.csdn.net/qq_38944163/article/details/81672516)

---

## 作者：wrehtg (赞：4)

潘承洞 潘承彪 在《初等数论》书中序言写到

#####  _"初等数论是研究整数最基本的性质，是一门十分重要的数学基础课。"_ 

那么本题中怎么不是整数？？？有理数?？？？于是我最开始作为一个数竞学的不是甚好的人便在此纠结良久。

首先，这里我们想求的即将a/b对19260817取模。**我们希望可以将问题化归到熟知的整数范围内**。不过从严谨一点的角度，我们甚至连有理数取余是否有意义我们也未讨论。但我们可以这样去想，一个实数与其倒数的积等于1，则其积对任意正整数取模也等于1。而无理数取模显然是偏离主题的（其实也没什么意义）。

对于有理数，则p×(1/p)≡1(mod q)，(q∈**N***)。于是1/p就同余于p^(-1)，即p的逆元。注意这里并不是直接的等于（不然还有啥可解释的），因为**这里的p^(-1)和(1/p)是两回事，p的逆元是整数，而(1/p)是一个分数**。于是我们通过这样的方法，便将整数的同余推广到了有理数范围内。

所以，a/b对19260817取模就是a×b^(-1)对19260817取模。所以问题的重点便在于如何求出b的逆元。这里要说的便是适用范围较广且较为实用的**扩展欧几里得算法**。

### 预备知识

1. 最大公约数

对于两个整数a、b，若整数d满足d|a且d|b，则d为a和b的公约数。在所有满足条件的d中，我们将最大的叫为**最大公约数，记为(a,b)**。

性质：(a,b)=(a,a-b)。将b不断减直到小于b则(a,b)=(a,a%b)。

2. 裴蜀定理

若ax+by=z， (a,b,x,y∈**Z**)，则z是(a,b)的倍数。裴蜀定理可以用带余除法证明，这里不详细介绍。

3. 乘法逆元

若ax≡1(mod q)，(q∈**N***)，则称x为a关于q的逆元。

### 于是

bx≡1(mod p)，由裴蜀定理，等价于bx+py=1。若b=0，则本题无解（因分数本身也无意义）。

先对一般情况即bx+py=(b,p)，由裴蜀定理可设

bx1+py1=(b,p);

px2+(b%p)y2=(b,b%p);

特别的，当p=0时，有(b,p)=b，得一组特解x0=1,y0=0;

而(b,p)=(b,b%p)，于是bx1+py1=px2+(b%p)y2，即bx1+py1=px2+(b-[b/p]×p)y2，即bx1+py1=px2+by2-([b/p]×y2)p（这里[t]代表不大于t的最大整数）。

对比b和p的系数，得x1=y2，y1=x2-[b/p]×y2。这里我们就得到了一个递推式。而由特解x0、y0，我们便可递归得出答案。

```
  #include <iostream>
  #include <cstdio>
  #include <cstring>
  #include <algorithm>
  #define mod 19260817
  using namespace std;
  long long a,b,x,y;
  inline long long readi()//读入优化，目的在于可以不停取模避免高精度
  {
      char c=getchar();
      long long t=0;
      while(c<'0' || c>'9') c=getchar();
      while(c>='0' && c<='9')
      {
          t=(t*10+c-'0')%mod;
          c=getchar();
      }
      return t;
  }
  void exgcd(long long x,long long y)//扩欧算法，类似辗转相除，用了全局变量代替函数里的&
  {
      if(!y)//那组特解
      {
          a=1;
          b=0;
          return;
      }
      exgcd(y,x%y);//递归求解
      long long k=a;
      a=b;
      b=k-(x/y)*b;
      return;
  }
  int main(){
      x=readi();
      y=readi();
      if(y==0)
      {
          printf("Angry!");
          return 0;
      }
      exgcd(y,mod);
      y=(a+mod)%mod;//避免负值
      printf("%lld",(x%mod*y%mod)%mod);//疯狂取模
      return 0;
  }

```


---

## 作者：Starlight237 (赞：4)

## 引理 Fermat-Euler定理
设$(a,m)=1$，则有：
$$a^{\phi(m)}\equiv1(\mod m)$$
这里引用《初等数论》中一个我认为十分巧妙的证明：
> 取$r_j(1\le j\le\phi(m))$为模m的一组既约剩余系，则$a\times r_j(1\le j\le\phi(m))$也是模m的一组既约剩余系。  
显然，根据同余定理，对于模m的任两组既约剩余系，它们中元素的乘积相等，因此：  
$$\prod^{\phi(m)}_{j=1}r_j\equiv \prod^{\phi(m)}_{j=1}ar_j=a^{\phi(m)}\prod^{\phi(m)}_{j=1}r_j(\mod m)$$  
由于$(r_j,m)=1$，根据同余定理即可直接证明。

特别地，例如本题，当m为素数时，有：
$$a^{m-1}\equiv1(\mod m)$$
所以有：
$$a/b\equiv a*b^{-1}\equiv a*b^{m-1}(\mod m)$$
又根据同余定理，因为a、b太大，可以一边快读一边取模。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 10000000
static char in[IOSIZE],*p=in,out[IOSIZE],*q=out,ch[20],*t=ch;
inline int read(){
	reg int x=0;
	while(*p<48)++p;
	while(*p>47)x=(x<<1)+(x<<3)+(*p++^48),x%=19260817;
	return x;
}
inline void write(long long x){
	!x&&(*q++=48);
	while(x)*t++=x%10+48,x/=10;
	while(t!=ch)*q++=*--t;
}
inline long long qpow(long long x,int n){
	reg long long res=1;
	for(;n;n>>=1,x=x*x%19260817)(n&1)&&(res=res*x%19260817);
	return res;
}
int main(){
	freopen("1.in","r",stdin);
	fread(in,1,IOSIZE,stdin);
	long long a=read(),b=read();
	!b?(puts("Angry!"),0):(write((a*qpow(b,19260815)%19260817+19260817)%19260817),0);
	fwrite(out,1,q-out,stdout);
	return 0;
}

```

---

## 作者：吃瓜群众syc (赞：2)

我们做这个题前首先应知道，(a/b) mod p等于(a*b的逆元) mod p.

费马小定理:若p为质数，且gcd(a,p)=1，则a^(p-1)≡1（mod p）

所以，a^(p-2)≡a^(-1) （mod p）

由于此时a^(p-2)与a^(-1)在模意义下相等（这时a^(p-2)便为a^(-1)的逆元），故：

            (a/b) mod p = (a*b^(p-2)) mod p.

以上式子中b的p-2次方我们只需用快速幂维护即可。此时剩下的问题便是如何处理位数庞大的a和b。

由于在求解的过程中，我们只会用到a%p和b%p的值(p=19260817),所以我们用快速读入，边读入a和b边对其取模。这样就避免了高精处理的麻烦（说实在的，这种处理方法在P2312解方程中也有体现 ，大家有兴趣的可以去看一下）。

AC代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

const long long MOD=19260817;
long long a,b,inv,ans;

inline long long read()//用快读处理a%MOD和b%MOD 
{
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')	ch=getchar();//由于a,b均>=0，故不考虑二者为负的情况 
	while('0'<=ch&&ch<='9')
	{
		x=(x << 3)+(x << 1)+(ch-'0');
		if(x>MOD)	x%=MOD;//边读入边取模 
		ch=getchar();
	}
	return x;
}

void power(int x,int k)//快速幂求b的逆元（b^(p-2)） 
{
	if(k==1)	return;
	power(x,k/2);
	inv=(inv*inv)%MOD;
	if(k%2==1)	inv=(inv*x)%MOD;
}

int main()
{
	a=read(),b=read();
	if(b==0)  { cout<<"Angry!"; return 0; }//b为零时，无解（因为此时a/b根本就不是有理数！） 
	inv=b;//inv:b的逆元 
	power(b,MOD-2);
	ans=(a*inv)%MOD;//(a/b) mod p等于(a*b的逆元) mod p
	cout<<ans;
	return 0;
}
```


---

## 作者：xiejinhao (赞：1)

# P2613 【模板】有理数取余 题解 

~~我不是来这讲正解的~~

为什么大家都用 $exgcd$ 什么的去做啊……

其实我觉得这题绿题就好了（因为 $19260817$ 是个质数啊）

正解：高精取模+快速幂（手动滑稽

其实我们只要模拟我们的整数除法就会取模了嘛，贴个板子：

~~~cpp
const int mod = 1e9 + 7;

string a;
cin >> a;

int ans = 0;
for(int i = 0; i < (int)a.size(); i++)
	ans = (1LL * ans * 10 + (a - '0')) % mod;

printf("%d\n", ans);
~~~

是不是很简单哇 $QwQ$

所以为什么大家都放着高精不去打呢……

我们都知道 $\frac{a}{b}\equiv a*b^{p-2}\pmod p$（前提是 $p$ 为质数，$b^{p-2}$ 是 $b$ 的乘法逆元）

然后这题就解决了。

$Code:$
------------

```cpp
#include<bits/stdc++.h>
using namespace std;

const int mod = 19260817;

int A, B;

inline int read() {
	static char c;
	int x = 0;
	while(!isdigit(c = getchar()));
	x = c ^ 48;
	while(isdigit(c = getchar())) 
		x = (x * 10 + (c ^ 48)) % mod;
	
	return x;
}

inline int expow(int x, int k) {
	int base = 1;
	for(; k; k >>= 1) {
		if(k & 1) base = 1LL * base * x % mod;
		x = 1LL * x * x % mod;
	} 
	
	return base;
}

int main() {
	A = read(), B = read();
	if(B == 0) return puts("Angry!"), 0;
	printf("%lld\n", 1LL * A * expow(B, mod - 2) % mod);
	return 0;
} 
```
事实上时间复杂度和 $exgcd$ 是一样的：$O(\text{log}N)$。

---

## 作者：孑彧 (赞：1)

~~水的一批~~

这道题是真的很简单的

我们显而易见可以想到，把上下两个数都取余，然后除一下就可以得到我们的答案

但是我们发现一个问题，那就是除法对于取模不符合结合律以及分配律！

所以直接取模肯定是不行的

所以我们需要找到一个数$x$

使得$b\times x\equiv 1 (mod 19260817)$

那么我们就可以乘以这个$x$然后就可以按照刚刚的方法做了$QwQ$！

关于如何求这个$x$，因为19260817是~~他的生日~~一个很大的质数，所以当$b$小于19260817，且$b\not=0$的时候，我们就可以用$b^{19260815}$来算出来了！

而当$b>19260817$时，$b$有可能是他的倍数，在这个时候$b$无逆元，即此题无解

（关于以上部分详情请看[乘法逆元](https://www.luogu.org/problem/P3811)）

原本以为这样就可以愉快的A掉这个题，但是一看数据范围，我傻了。

这么大的数我们怎么把他存进来呢？

没关系！不需要存起来！

因为乘法和加法对于取模符合分配律与交换律，于是我们就可以借助快读的方法，一位一位的读入，同时对于得到的数取模，当最后的$b$为$0$的时候即可判断本题无解

还有一个小地方是要注意$a\times b^{-1}$有可能会爆longlong，所以我们需要想点办法去处理一下，详见代码

这样我们就可以愉快的A掉这个题了！

贴代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define mod 19260817
using namespace std;
long long b,a;
long long read(){
	char c=getchar();
	long long x=0,f=1;
	while(!isdigit(c)){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<3)+(x<<1)+(c^48);
		x=x%mod;
		c=getchar();
	}
	return x*f;
}
long long ksm(long long a,long long b){
	long long tmp=a;
	long long ans=1;
	while(b!=0){
		if((b&1)==1){
			ans*=tmp;
			ans%=mod;
		}
		tmp*=tmp;
		tmp%=mod;
		b>>=1;
	}
	return ans%mod;;
}
long long cheng(long long a,long long b){
	long long ans=0;
	long long tmp=1;
	while(b!=0){
		if((b&1)==1){
			ans+=tmp*a;
			ans%=mod;
		}
		tmp*=2;
		tmp%=mod;
		b>>=1;
	}
	return ans;
}
int main(){
	a=read();
	b=read();
	if(b==0){
		printf("Angry!");
		return 0;
	}
	long long k=ksm(b,mod-2);
	long long ans=cheng(a,k);
	long long num=ans%mod;
	printf("%lld",num);
	return 0;
}
```
写在最后：关于这样的取余运算经常会出现在各种各样的题目中，希望大家熟练掌握！

---

## 作者：Tari (赞：1)

## 代码只有19行

## 为何非要用exgcd or phi()?

记得有道题叫乘法逆元吧？

公式inv[x] = (mod - mod / x) * inv[mod % x] % mod

所以很容易写出递归函数。。。。

代码极短。。。

```cpp
#include<cstdio>
#include<iostream>
#define R register int
using namespace std;
const int mod=19260817;
int a,b;
inline int g() {
    R ret=0; register char ch; while(!isdigit(ch=getchar()));
    do ret=(ret*10+(ch^48))%mod; while(isdigit(ch=getchar())); 
    return ret;
}
inline long long Inv(int x) {
    if(x==1) return 1; if(x<1) return 0;
    return (long long)(mod-mod/x)*Inv(mod%x)%mod;
}
signed main() {
    a=g(),b=Inv(g()); if(b==0) printf("Angry!\n");
    else printf("%lld\n",(long long)a*(b+mod)%mod);
}
```


---

## 作者：程就未来 (赞：1)

题意：求(a / b) % P
### 1.乘法逆元
通俗的定义：若ax = 1 (mod p) ,其中gcd（a,p） = 1,那么x就是a模p的乘法逆元
### 2.本题解法
设inv(b)为x模b的乘法逆元

有结论 a * inv(b) = a / b (mod p)

证明：a * inv(b) * b = a / b * b (mod p)

因为根据乘法逆元的定义：inv(b) * b = 1 (mod p)

化简为 a = a (mod p)

证毕

所以答案就是a * inv(b)

### 3.扩展欧几里得求乘法逆元
用扩展欧几里得求同余方程bx = 1 (mod p)

若不会扩展欧几里得先做[模板题](https://www.luogu.org/problemnew/show/P1082)

解得一个解x，为了让x在0~p-1范围之间，将其处理x = (x % p + p) % p

本题a、b很大，建议在输入时就%p
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long P = 19260817;

long long read() {//快读
	long long s = 0 ,w = 1; 
	char ch = getchar();
	while(ch < 48 || ch > 57) {if(ch == '-') w = -1; ch = getchar();}
	while(ch >= 48 && ch <= 57) s = s * 10 + (ch - 48) , s %= P , ch = getchar();
	return s * w;
}

void Exgcd(long long a , long long b , long long &d , long long &x , long long &y) {//扩欧
	long long t;
	if(!b) d = a , x = 1 , y = 0;
	else {
		Exgcd(b , a % b , d , x , y);
		t = x , x = y , y = t - (a / b) * y;
	}
}

long long inv(long long a , long long p) {//求乘法逆元
	long long d , x = 0 , y = 0;
	Exgcd(a , p , d , x , y);
	return d == 1 ? (x % p + p) % p : -1;
}

int main() {
	long long A = read() , B = read();
	if(!B) {puts("Angry!");return 0;}
	printf("%lld\n",  (A * inv(B , P)) % P);
	return 0;
}

```




---


# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# 题解

## 作者：听取MLE声一片 (赞：28)

如果说去掉高精度的话，还是一道非常好的 **拓扑** 排序题目。

本篇代码无高精，请自行添加（因为太复杂了qwq）。

## 拓扑排序：

拓扑排序主要思路在一个**有向无环图**中，先统计出每个点的入度个数，然后将入度为0的点入队，接着把队中每个点向它的出边做一个运算（本题中是将水分流到与其相连节点），然后断边（相连的点入度-1），最后就会得出排水节点的水量。

有不明白的同学可以看 [神经网络](https://www.luogu.com.cn/problem/P1038) [车站分级](https://www.luogu.com.cn/problem/P1983) [旅行计划](https://www.luogu.com.cn/problem/P1137) 都是很好的拓扑排序模板题。

拓扑排序函数：

```
void tp(){
	for(int i=1;i<=n;i++)//所有入度为0的点入队（1-m）
		if(!in[i]){
			book[i]=1;
			q.push(i);
			xx[i]=1,yy[i]=1;
		}
	while(!q.empty()){
		int p=q.front();
		q.pop();
		if(out[p])
			continue;
		for(int i=0;i<a[p].size();i++){
			add(a[p][i],xx[p],yy[p]*(1ll*a[p].size()));
			if(book[a[p][i]])
				continue;
			in[a[p][i]]--;
			if(in[a[p][i]]==0){
				book[a[p][i]]=1;
				q.push(a[p][i]);
			}
		}
	}
	return;
}
```

### 注意几点：
 
1. 如果是 `vector` 存边，一定不要访问排水节点的 `size()` 这样可能会炸，要事先存一下。

2.本题是前 `m` 个点是入水口，一定要注意审好题（虽然只有前 `m` 个点入度为0）。

---
## 分数处理：

我主要运用的是通分思想：

$ \frac{a}{b}+\frac{c}{d}=\frac{ad}{bd}+\frac{cb}{bd}=\frac{ad+cb}{bd} $

紧接着用 `gcd` 化简(考场差点写挂):

```
ll gcd(ll x,ll y){
	if(y==0)
		return x;
	return gcd(y,x%y);
}
```

下面是通分代码：

```
void add(int u,ll x,ll y){
	if(y==0)
		return;
	if(yy[u]==0){
		xx[u]=x;
		yy[u]=y;
		return;
	}
	ll p1=xx[u]*y+yy[u]*x;
	ll p2=yy[u]*y;
	ll p3=gcd(p1,p2);
	xx[u]=p1/p3;
	yy[u]=p2/p3;
	return;
}
```
### 注意事项：

1.一定要判出要添加的分母是否为`0`，如果为`0` 直接赋值即可。

2.最后输出保险在约分一下。

## 全部代码(考试代码)：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,in[100001],out[100001],book[100001];
ll xx[100001],yy[100001];
ll gcd(ll x,ll y){
	if(y==0)
		return x;
	return gcd(y,x%y);
}
void add(int u,ll x,ll y){
	if(y==0)
		return;
	if(yy[u]==0){
		xx[u]=x;
		yy[u]=y;
		return;
	}
	ll p1=xx[u]*y+yy[u]*x;
	ll p2=yy[u]*y;
	ll p3=gcd(p1,p2);
	xx[u]=p1/p3;
	yy[u]=p2/p3;
	return;
}
vector<int> a[500001];
queue<int> q;
void tp(){
	for(int i=1;i<=n;i++)
		if(!in[i]){
			book[i]=1;
			q.push(i);
			xx[i]=1,yy[i]=1;
		}
	while(!q.empty()){
		int p=q.front();
		q.pop();
		if(out[p])
			continue;
		for(int i=0;i<a[p].size();i++){
			add(a[p][i],xx[p],yy[p]*(1ll*a[p].size()));
			if(book[a[p][i]])
				continue;
			in[a[p][i]]--;
			if(in[a[p][i]]==0){
				book[a[p][i]]=1;
				q.push(a[p][i]);
			}
		}
	}
	return;
}
int main()
{
	//freopen("water.in","r",stdin);
	//freopen("water.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		int d=read();
		if(d==0){
			out[i]=1;
			continue;
		}
		while(d--){
			int v;
			v=read();
			a[i].push_back(v);
			in[v]++;
		}
	}
	tp();
	for(int i=1;i<=n;i++){
		if(out[i]){
			add(i,0,1);
			printf("%lld %lld\n",xx[i],yy[i]);
		}
	}
	return 0;
}
```

谢谢大家！


---

## 作者：lcyxds (赞：15)

用两个 `unsigned long long` 开高精度，不用求 gcd。

以 $60^{11}$ 为底存储每个节点的流量（考场上我以 $60^{10}$ 为底洛谷直接 60 分，理论上可卡到三十分，~~于是我光荣退役~~，不过提示了这个简单的做法）。

考虑到分母 $2$ 最高 $22$ 次，$3$ 和 $5$ 最高 $11$ 次，于是可以预处理出 $2^{22}\times3^{11}\times5^{11}$ 的所有真因数，全都爆不了 `unsigned long long`。

输出时只需要不断试除 $2,3$ 和 $5$ 即可。

于是我们只需要实现高精度加法，高精度除最大为 $5$ 的整数，以及判断高精度是否被 $2,3,5$ 整除。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#define ull unsigned long long

using namespace std;

//1e18
const ull _BASE = 1e18;

struct Gj{
  ull _num[2];
  Gj(){}
  Gj(ull a, ull b) {
    _num[1] = a;
    _num[0] = b;
  }
  Gj(bool maxi) {
    if (maxi) {
      _num[1] = 36ull;
      _num[0] = 279705600000000000ull;
    }
  }
};

void Display(Gj a) {
  if (a._num[1]) {
    printf("%llu%018llu", a._num[1], a._num[0]);
    return;
  }
  printf("%llu", a._num[0]);
}

Gj operator + (Gj a, Gj b){
  Gj res;
  res._num[0] = a._num[0]+b._num[0];
  res._num[1] = a._num[1]+b._num[1]+res._num[0]/_BASE;
  res._num[0]%=_BASE;
  return res;
};

Gj operator / (Gj a, ull b) {
  //Display(a);
  //cout << '/' << b << '=';
  Gj res;
  res._num[0] = a._num[1]%b*_BASE+a._num[0];
  res._num[1] = a._num[1]/b;
  res._num[0]/=b;
  //Display(res);
  //cout << endl;
  return res;
}

ull operator %(Gj a, ull b) {
  switch(b) {
  case 2:
  case 5:
    return a._num[0]%b;
  case 3:
    return (a._num[1]%b+a._num[0]%b)%b;
  }
}
//2, 3, 5
ull _power[23][12][12];
int _n;
int _m;
vector<int> _graph[100010];
int _rudu[100010];
Gj _val[100010];
bool _visited[100010];

void GenPower() {
  _power[0][0][0] = 1;
  for (int i = 1; i < 12; i++) {
    _power[0][0][i] = _power[0][0][i-1]*5ull;
  }
  for (int i = 1; i < 12; i++) {
    for (int m = 0; m < 12; m++) {
      _power[0][i][m] = _power[0][i-1][m]*3ull;
    }
  }
  for (int i = 1; i < 23; i++) {
    for (int m = 0; m < 12; m++) {
      for (int k = 0; k < 12; k++) {
	_power[i][m][k] = _power[i-1][m][k]*2ul;
	//cout << i << ',' << m << ',' << k << ',' << _power[i][m][k] << endl;
      }
    }
  }
}

void DisplayDiv(Gj a) {
  int two = 22;
  int three = 11;
  int five = 11;
  while (two && !(a%2)) {
    two--;
    a = a/2;
  }
  while (three && !(a%3)) {
    three--;
    a = a/3;
  }
  while (five && !(a%5)) {
    five--;
    a = a/5;
  }
  Display(a);
  putchar(' ');
  //cout << two << ',' << three << ',' << five << endl;
  if (two==22 && three==11 && five==11) {
    Display(Gj(true));
  }
  else printf("%llu", _power[two][three][five]);
  putchar('\n');
}

void ParseIn() {
  int count;
  int solo;
  freopen("water.in", "r", stdin);
  scanf("%d%d", &_n, &_m);
  for (int i = 1; i <= _m; i++) {
    _val[i] = Gj(true);
  }
  for (int i = 1; i <= _n; i++) {
    scanf("%d", &count);
    for (int m = 0; m < count; m++) {
      scanf("%d", &solo);
      //cout << i << ',' << solo << endl;
      _graph[i].push_back(solo);
      _rudu[solo]++;
    }
  }
  fclose(stdin);
}

void Dfs(int a) {
  //cout << "Dfs " << a << endl;
  _visited[a] = true;
  if (!_graph[a].size()) return;
  int u;
  Gj add = _val[a]/_graph[a].size();
  _val[a]._num[0] = 0;
  _val[a]._num[1] = 0;
  for (int i = 0; i < _graph[a].size(); i++) {
    u = _graph[a][i];
    _val[u] = _val[u]+add;
    _rudu[u]--;
    if (!_rudu[u]) {
      Dfs(u);
    }
  }
}

void Core() {
  for (int i = 1; i <= _n; i++) {
    //cout << _visited[i] << endl;
    if (!_visited[i] && !_rudu[i]) {
      Dfs(i);
    }
  }
}

void WriteOut() {
  freopen("water.out", "w", stdout);
  for (int i = 1; i <= _n; i++) {
    if (_val[i]._num[0] || _val[i]._num[1]) {
      DisplayDiv(_val[i]);
    }
  }
  fclose(stdout);
}

int main() {
  GenPower();
  ParseIn();
  Core();
  WriteOut();
  return 0;
}

```


---

## 作者：hensier (赞：10)

本题中，污水应该保证先从接收口 $1 \sim m$ 流出，在全部流动完毕后，选择已经接收完污水的排水节点再继续流动。这符合搜索中「扩散」的含义。

【样例 $1$】

根据题意建图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fcupw2j3.png?x-oss-process=image/resize,m_lfit,h_275,w_275)

先以 $1$ 为起始点，向外部拓展：

![](https://cdn.luogu.com.cn/upload/image_hosting/gt59k1if.png?x-oss-process=image/resize,m_lfit,h_275,w_275)

进一步地：

![](https://cdn.luogu.com.cn/upload/image_hosting/unspipxz.png?x-oss-process=image/resize,m_lfit,h_275,w_275)

然而这个样例中，起始点仅有 $1$ 个。在多个接收口的情况下，我们可以分别进行考虑。

这道题的一个需要考虑的方面是搜索方式。

如果按照传统的方式，那么每一个点都会把污水流到与其相连的点。为了防止污水环流，我们需要确定搜索顺序。

这时我们引入数组 $oud_i$ 表示第 $i$ 个节点的出度，$ind_i$ 表示第 $i$ 个节点的入度。

特别地，对于所有的最终排水口，都有 $oud_i=0$。

假如 $1 \sim m$ 的入度不为 $0$，则必定形成环，因而 $ind_i=0$。因此 $1 \sim m$ 节点的入度均为 $0$。

不妨用链式前向星维护图中的边（即排水系统的管道），用队列维护每个待拓展的节点（即排水系统中待开始流动的节点）。搜索时，每一次取队头元素 $u$，并扫描与其相连的节点 $v$。然后让点 $v$ 的污水量增加并让 $ind_v$ 减少 $1$。最后，输出出度为 $0$ 的节点即可。

每个节点的污水量应当按题目要求用分数表示，这里用 $wx_i,wy_i$ 分别表示每个节点污水量的分子和分母。

为了在约分时防止报错，我们初始化所有的 $wy_i$ 为 $1$，并把 $1 \sim m$ 的 $wx_i$ 值设为 $1$。

计算 $\dfrac{b}{a}+\dfrac{d}{c}$ 时，可令 $p=\text{lcm}(a,c)=\dfrac{ac}{\gcd(a,c)}$。这样，$\dfrac{b}{a}+\dfrac{d}{c}=\dfrac{\dfrac{bp}{a}+\dfrac{dp}{c}}{p}$。

本题的分母的上限可达到 $\text{lcm}(5,4,3,2,1)^{11} \gt 2^{64}$，所以会爆掉 `ll` 和 `ull`。

在 **在非 NOI 环境** 中，我们可以使用 `__int128_t` 来表示 $[-2^{127},2^{127})$ 区间内的数。而`__uint128_t` 可表示 $[0,2^{128})$ 区间内的数。考场上还得写高精度。

完整代码：

```cpp
#include<bits/stdc++.h>
#define I128 __int128_t
using namespace std;
int n,m,cnt,head[100001],oud[100001],ind[100001];
I128 wx[100001],wy[100001];
queue<int>q; // 保存即将拓展的节点
struct node
{
    int nxt,to;
}e[500001];
I128 gcd(I128 x,I128 y) // gcd 用来约分和实现加减
{
    I128 t;
    while(y)
    {
        t=y;
        y=x%y;
        x=t;
    }
    return x;
}
void add(int u,int v)
{
    e[++cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
void update(I128 &x_1,I128 &y_1,I128 x_2,I128 y_2) // 分数加减运算
{
    I128 p=y_1*y_2/gcd(y_1,y_2);
    x_1*=p/y_1;
    x_2*=p/y_2;
    x_1+=x_2;
    y_1=p;
}
template<typename T>void read(T &x)
{
    x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
void write(I128 x) // __int128_t 需要快读快写
{
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
int main()
{
    read(n),read(m);
    for(register int i=1;i<=m;++i)
    {
        wx[i]=1;
        q.push(i);
    }
    for(register int i=1,d;i<=n;++i)
    {
        read(d);
        wy[i]=1; // 将分母都标记为 1，防止出错
        oud[i]+=d;
        for(register int j=1,x;j<=d;++j)
        {
            read(x);
            add(i,x); // 增加一条从 i 到 x 的边
            ind[x]++; // x 的入度加 1
        }
    }
    while(q.size())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u],v;i;i=e[i].nxt)
        {
            v=e[i].to;
            update(wx[v],wy[v],wx[u],oud[u]*wy[u]);
            ind[v]--; // 将入度减少 1
            if(!ind[v])q.push(v);
        }
    }
    for(register int i=1;i<=n;++i)
    {
        if(!oud[i])
        {
            I128 p=gcd(wx[i],wy[i]); // 约分操作
            write(wx[i]/p);
            putchar(' ');
            write(wy[i]/p);
            putchar('\n');
        }
    }
    return 0;
}
```

本题还可用深搜解决：

```cpp
#include<stdio.h>
#define I128 __int128_t
int n,m,cnt,head[100001],oud[100001],ind[100001];
I128 wx[100001],wy[100001];
struct node
{
    int nxt,to;
}e[500001];
I128 gcd(I128 x,I128 y)
{
    I128 t;
    while(y)
    {
        t=y;
        y=x%y;
        x=t;
    }
    return x;
}
void add(int u,int v)
{
    e[++cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
void update(I128 &x_1,I128 &y_1,I128 x_2,I128 y_2)
{
    I128 p=y_1*y_2/gcd(y_1,y_2);
    x_1*=p/y_1;
    x_2*=p/y_2;
    x_1+=x_2;
    y_1=p;
}
void dfs(int u)
{
    for(int i=head[u],v;i;i=e[i].nxt)
    {
        v=e[i].to;
        update(wx[v],wy[v],wx[u],oud[u]*wy[u]);
        ind[v]--;
        if(!ind[v])dfs(v); // 与上面类似，递归即可
    }
}
template<typename T>void read(T &x)
{
    x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
void write(I128 x)
{
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
int main()
{
    read(n),read(m);
    for(register int i=1;i<=m;++i)wx[i]=1;
    for(register int i=1,d;i<=n;++i)
    {
        read(d);
        wy[i]=1;
        oud[i]+=d;
        for(register int j=1,x;j<=d;++j)
        {
            read(x);
            add(i,x);
            ind[x]++;
        }
    }
    for(register int i=1;i<=m;++i)dfs(i);
    // 按顺序分别让 1 到 m 号接收口的污水开始流动
    for(register int i=1;i<=n;++i)
    {
        if(!oud[i])
        {
            I128 p=gcd(wx[i],wy[i]);
            write(wx[i]/p);
            putchar(' ');
            write(wy[i]/p);
            putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：lndjy (赞：6)

题目中说了没有环，所以这个图是一个 DAG。

既然是 DAG，就可以想到拓扑排序。

设 $f_i$ 表示第 $i$ 个点的水量，有

$$f_j=f_j+\frac{f_i}{d_i}$$

$d_i$ 表示第 $i$ 个点的出度。

然后，开一下 `long long` 就有 90 分的好成绩了。

根据 CCF 的传统艺能，答案爆了，需要写高精。

不过考场上不推荐写。不好写还容易挂。

如果在洛谷也懒得写~~比如我~~，就可以用 `__int128` 水过去。

代码：

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
#define int long long
using namespace std;
const int N=1e5+5;
void write(__int128 x)
{
	if(x/10)
	write(x/10);
	putchar(x%10+'0');
}
struct fenshu
{
	__int128 x,y;
	fenshu(int a=0,int b=1)
	{
		x=a;
		y=b;
	}
	int gcd(int a,int b)
	{
		if(b==0) return a;
		return gcd(b,a%b);
	}
	void yuefen()
	{
		int k=gcd(x,y);
		x/=k;y/=k;
	}
	void add(fenshu k)
	{
		k.yuefen();
		fenshu ans;
		ans.x=x*k.y+k.x*y;
		ans.y=y*k.y;
		ans.yuefen();
		*this=ans;
	}
	void print()
	{
		write(x);putchar(' ');write(y);putchar('\n');
	}
}f[N];
int n,m,cnt;
struct edge
{
	int to,nxt;
}e[N*5];
int d[N],qd[N],head[N];
void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	d[v]++;
	qd[u]++;
}
void topo()
{
	queue<int> q;
	for(int i=1;i<=m;i++)
	{
		f[i]=fenshu(1,1);
		q.push(i);
	}
	while(!q.empty())
	{
		int now=q.front();q.pop();
		fenshu k=f[now];
		k.y*=qd[now];
		k.yuefen();
		for(int i=head[now];i;i=e[i].nxt)
		{
			d[e[i].to]--;
			f[e[i].to].add(k);
			if(d[e[i].to]==0)
			q.push(e[i].to);
			f[now]=fenshu(0,1);
		}
	}
}
signed main()
{
//	freopen("water.in","r",stdin);
//	freopen("water.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int tot;
		cin>>tot;
		if(tot==0) d[i]=1e9;
		for(int j=1;j<=tot;j++)
		{
			int x;
			cin>>x;
			add(i,x);
		}
	}
	topo();
	for(int i=1;i<=n;i++)
	{
		if(!head[i])
		f[i].print();
	}
	return 0;
}
```


---

## 作者：gavinliu266 (赞：3)

# 思路
这题按照题意模拟，使用拓扑排序。

记录每一个点当前的污水，然后根据出度向它的所有流出的点均匀推送。

然后这里数据太大，使用 `__int128`，分数中，将 $0$ 表示为 $\frac{0}{1}$ 可防止除以零的问题，$1$ 表示为 $\frac{1}{1}$，记当前点污水为 $\frac{a}{b}$，出度为 $x$，则推送的流量可以直接乘在分母上，变成 $\frac{a}{bx}$ 即可，这样可以避免分数除法。

时间复杂度：记单次分母最大为 $V$，则时间复杂度 $O(n \log V)$。

# 代码实现
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
typedef __int128 ll;
const int N = 1e5 + 5;
int n, m;
void print(ll x) {
    if(x >= 10) print(x / 10);
    putchar(x % 10 + '0');
}
struct frac {
    ll x, y;
    frac(ll x = 0, ll y = 1): x(x), y(y) {
        ll gcd = __gcd(x, y);
        x /= gcd, y /= gcd;
    }
    frac operator+(const frac &o) const {
        ll _x = x * o.y + y * o.x;
        ll _y = y * o.y;
        ll gcd = __gcd(_x, _y);
        return frac(_x / gcd, _y / gcd);
    }
} d[N];
int to[N];
vector<int> ed[N], qry;
queue<int> q;
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) {
        int k, x;
        scanf("%d", &k);
        if(!k) qry.push_back(i);
        for(int j = 1; j <= k; ++j) {
            scanf("%d", &x);
            ed[i].push_back(x);
            ++to[x];
        }
    }
    for(int i = 1; i <= n; ++i)
        if(to[i] == 0) {
            q.push(i);
            d[i] = frac(1, 1);
        }
    while(!q.empty()) {
        int u = q.front(), x = ed[u].size();
        q.pop();
        for(auto p : ed[u]) {
            d[p] = d[p] + frac(d[u].x, d[u].y * (ll)x);
            if((--to[p]) == 0)
                q.push(p);
        }
    }
    for(auto p : qry) {
        print(d[p].x);
        putchar(' ');
        print(d[p].y);
        putchar('\n');
    }
}
```

---

## 作者：normalpcer (赞：3)

## 分析
对于每一个节点，如果不再流入水，我们就可以均分当前存储的污水，把它们加到所有连向的节点上。

希望上游节点比下游节点优先遍历过，自然想到拓扑排序。

拓扑排序用一个队列维护将要遍历的节点，并且仅当一个节点的入点均遍历过时向外扩展，恰好满足我们的需求。

记节点 $i$ 现在有 $F_i$ 吨污水，有一条边从 $i$ 指向 $j$，点 $i$ 的出度为 $out_i$，便有如下转移。
$$F_j \leftarrow \frac{F_i}{out_i} + F_j$$

由于题目要求输出分数形式，我们实现一个分数类，支持加法和除以整数即可。

另外，数据范围可能导致分子或者分母超过 `unsigned long long` 的范围，这里直接使用 `__int128` 存储。

## 代码
注意，这份代码仅能在 C++20 或更新的标准中通过编译。
```cpp
/**
 * @link https://www.luogu.com.cn/problem/P7113
 */

#include <bits/stdc++.h>
using i128 = __int128;
const char endl = '\n';
template <typename T> auto range(T begin, T end) { return std::views::iota(begin, end); }

namespace Solution {
    // 输出 __int128
    auto &operator<< (std::ostream &stream, i128 x) {
        static char sta[40]; int top=0;
        if (x<0) {
            stream.put('-'), sta[top++] = (-(x%10))^48, x = -(x/10);
            if (x==0) return stream.put(sta[--top]);
        }
        do {  sta[top++] = x%10^48, x /= 10;  } while (x);
        while (top) stream.put(sta[--top]);
        return stream;
    }
    struct Frac {  // 分数
        i128 numerator;  // 分子
        i128 denominator = 1;  // 分母，初始值应当为 1

        static constexpr Frac simplified(const Frac& origin) {  // 化简
            auto gcd = std::__gcd(origin.numerator, origin.denominator);
            if (gcd == 1)  return origin;
            return {origin.numerator / gcd, origin.denominator / gcd};
        }
        Frac operator+ (const Frac& other) const {
            return simplified({
                numerator * other.denominator + other.numerator * denominator, 
                denominator * other.denominator
            });
        }
        void operator+= (const Frac& other) { *this = *this + other; }
        Frac operator/ (const int other) const {
            return simplified({numerator, other * denominator});
        }
        friend auto &operator<< (std::ostream &stream, Frac x)  {
            return stream << x.numerator << ' ' << x.denominator;
        }
    };
    void solve() {
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr), std::cout.tie(nullptr);
        int N, M;
        std::cin >> N >> M;

        std::vector<std::vector<int>> graph(N+1);  // vector 存图
        std::vector<int> in(N+1);  // 还没遍历过的入点
        std::vector<int> out(N+1);  // 出度
        std::vector<Frac> F(N+1);  // 水量
        for (auto i: range(1, N+1)) {
            int cnt;  std::cin >> cnt;
            for (auto _: range(0, cnt)) { 
                int target;  std::cin >> target;
                graph.at(i).push_back(target);
                in.at(target)++, out.at(i)++;
            }
        }

        // 拓扑排序
        std::deque<int> q;
        for (auto i: range(1, N+1)) {
            if (in.at(i) == 0)  q.push_back(i), F.at(i) = {1, 1};
        }
        while (not q.empty()) {
            auto x = q.front();  q.pop_front();
            auto unit = F.at(x) / out.at(x);

            for (auto dest: graph.at(x)) {
                F.at(dest) += unit;
                if (--in.at(dest) == 0)  q.push_back(dest);
            }
        }

        for (auto i: range(1, N+1)) {
            if (out.at(i) == 0) {  // 最终答案
                auto res = F.at(i);
                std::cout << res << endl;
            }
        }
    }
}

int main() {
    Solution::solve();
    return 0;
}
```

---

## 作者：CaiZi (赞：2)

你会发现，当我们希望处理某个点的污水时（即让该点的污水继续往后流动），所有能到达该点的污水都会到达该点。因此考虑拓扑排序，这样可以保证处理某个点时，所有能到达该点的点均已经被处理，于是能到达该点的污水都可以到达该点。

然后按照题意建图，给入水口 $1$ 吨的污水，其他点默认为 $0$ 吨的污水，然后把入水口加入队列。注意在拓扑排序过程中，无论某个点是否加入队列，都应该让污水流动到该点。

然后就是分数运算的问题了，记 $s_i$ 为到达第 $i$ 号点的污水量，对于一条 $i\to j$ 的边，需要令 $s_j\gets s_j+\dfrac{s_i}{d_i}$。所以我们需要一个支持分数的加法和除法的结构体。加法就先通分再约分，除法就先约分再乘到分母（小学数学）。

代码实现的一些技巧或问题：
- 本题在分数计算时可能会爆 `long long`，[仅能获得 $70\text{ pts}$](https://www.luogu.com.cn/record/195940592)。需要开 `__int128`，注意 `__int128` 需要手写输出和手写 $\gcd$；且不要全开，否则容易常数过大且你还需要手写输入。
- 在处理分数时，对于值为 $0$ 的分数，需要保证分母为 $1$，否则直接 RE。
- 由于保证入水口没有汇集管道，实际上 $m$ 是没用的，我们像正常拓扑排序一样找出入度为 $0$ 的点即可。

代码展示：
```cpp
#include<bits/stdc++.h>
#define bignum __int128
using namespace std;
inline void print(bignum l){
	if(l!=0){
		print(l/10);
		putchar(l%10+'0');
	}
}
inline bignum biggcd(bignum l,bignum r){
	return l==0?r:biggcd(r%l,l);
}
struct frac{
	bignum x,y;
	inline friend frac operator + (frac _1,frac _2){
		frac _3;
		_3.y=_1.y*_2.y/biggcd(_1.y,_2.y);
		_3.x=_3.y/_1.y*_1.x+_3.y/_2.y*_2.x;
		int w=biggcd(_3.x,_3.y);
		_3.x=_3.x/w;
		_3.y=_3.y/w;
		return _3;
	}
	inline friend frac operator / (frac _1,int _2){
		int w=biggcd(_1.x,_2);
		_1.x=_1.x/w;
		_1.y=_2/w*_1.y;
		return _1;
	}
}s[100001];
int n,m,a[100001],b[100001];
vector<int>g[100001];
queue<int>q;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>b[i];
		for(int j=1;j<=b[i];j++){
			cin>>m;
			g[i].push_back(m);
			a[m]++;
		}
	}
	for(int i=1;i<=n;i++){
		if(!a[i]){
			q.push(i);
			s[i]=frac{1,1};
		}
		else{
			s[i]=frac{0,1};
		}
	}
	while(!q.empty()){
		m=q.front();
		q.pop();
		for(int i:g[m]){
			a[i]--;
			s[i]=s[i]+s[m]/b[m];
			if(a[i]==0){
				q.push(i);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(b[i]==0){
			print(s[i].x);
			putchar(' ');
			print(s[i].y);
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Mirasycle (赞：2)

拓扑排序 $+$ 分数运算模板题。

首先按照输入建图。

考虑在拓扑排序的时候维护每个点的水量，因为是分数，所以我们要先定义分数的加法和乘法，然后记录分子，分母。

$0$ 度点就开始的污水接受口，我们直接把分子和分母都设置为 $1$，对于其他点就是分子为 $0$，分母为 $1$。

然后对于边 $u\to v$，$a_v\gets \dfrac{a_u}{out_u}$ 即可。

时间复杂度 $O(n\log V)$，分数运算求 $\gcd$ 需要一个 $\log$。


注意本题数据范围过大，要开 `__int128`。同时分数运算的时候是先除后乘，否则可能爆掉。


```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
typedef __int128 ll;
const int maxn=1e5+10;
struct node{
	ll p,q;
}a[maxn];
int n,m; vector<int> G[maxn];
bool End[maxn]; int deg[maxn],out[maxn];
void write(ll z){
	if(z==0) return ;
	write(z/10);
	int x=z%10; cout<<x;
}
ll gcd(ll x,ll y){ return (x==0)?y:gcd(y%x,x); }
ll lcm(ll x,ll y){ return x/gcd(x,y)*y; }
node operator + (node x,node y){
	node res; res.p=0;
	ll Lcm=lcm(x.q,y.q);
	res.q=Lcm; res.p=res.p+Lcm/x.q*x.p;
	res.p=res.p+Lcm/y.q*y.p;
	ll Gcd=gcd(res.p,res.q);
	res.p=res.p/Gcd; res.q=res.q/Gcd;
	return res;
}
node operator / (node x,int y){
	ll Gcd=gcd(x.p,y);
	x.p=x.p/Gcd; y=y/Gcd;
	x.q=x.q*y;
	return x;
}
void topo(){
	queue<int> q;
	for(int i=1;i<=n;i++) a[i].p=0,a[i].q=1;
	for(int i=1;i<=m;i++){
		a[i].p=a[i].q=1;
		q.push(i); 
	}
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(auto v:G[u]){
			a[v]=(a[u]/out[u])+a[v];
			deg[v]--; if(!deg[v]) q.push(v);
		}
	}
}
void init(){
	memset(deg,0,sizeof(deg));
	memset(End,0,sizeof(End));
}
int main(){
	cin>>n>>m; init(); 
	for(int i=1;i<=n;i++){
		int num; cin>>num; out[i]=num;
		for(int j=1;j<=num;j++){
			int v; cin>>v; deg[v]++;
			G[i].push_back(v); 
		}
		if(!num) End[i]=1;
	}
	topo();
	for(int i=1;i<=n;i++)
		if(End[i]){
			write(a[i].p); cout<<" "; write(a[i].q); cout<<endl;
		}
	return 0;
}
```

---

## 作者：lucasincyber (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7113)
## 思路
因为没有环，所以本题可以用拓扑排序处理。

设第 $i$ 个管道流过的水占总水量的 $\frac{p_i}{q_i}$。若第 $v$ 个管道有 $k$ 个儿子，则它的水量会被平分成 $k$ 份，每个儿子会收到 $1$ 份。化简一下得：
$$
\displaystyle \frac{p_u}{q_u} = \begin{aligned} \sum_{v \; \in \; fa_u} \displaystyle \frac{p_v}{q_v \times |son_v|} \end{aligned}
$$
那就这样拓扑，同时求答案。注意分数要化简，而且需要高精度，或者用 ```__int128```。
## 代码
```cpp
#include <bits/stdc++.h>
#define int __int128
using namespace std;

const int N = 1e5 + 5;

int n, m;
int deg[N], p[N], q[N];
vector<int> tr[N];

int read()
{
    int x = 0,f = 1;
	char ch = getchar();
    while (ch < '0' || ch > '9')
	{
	    if (ch == '-') f = -1;
		ch = getchar();
	}
    while (ch >= '0' && ch <= '9')
 	    x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

void write(int x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
	return;
}

int gcd(int x, int y)
{
	if (y == 0) return x;
	return gcd(y, x % y);
}

pair<int, int> addFraction(int a, int b, int x, int y)
{
	if (a == 0) return (make_pair(x, y));
	int t = b / gcd(b, y) * y; 
	int xx = t / b * a + t / y * x, yy = t;
	int g = gcd(xx, yy);
	xx /= g, yy /= g;
	return (make_pair(xx, yy));
}

signed main()
{
	n = read(), m = read();
	for (int i = 1, x; i <= n; i++)
	{
		x = read();
		for (int j = 1, y; j <= x; j++)
		{
			y = read();
			tr[i].push_back(y);
			deg[y]++; 
		}
	}
	queue<int> Q;
	for (int i = 1; i <= n; i++)
	{
		if (!deg[i])
		{
			Q.push(i);
			p[i] = 1;
		}
	}
	for (int i = 1; i <= n; i++)
		q[i] = 1;
	while (Q.size())
	{
		int u = Q.front();
		Q.pop();
		for (auto v : tr[u])
		{
			pair<int, int> tmp = addFraction(p[v], q[v], p[u], q[u] * tr[u].size());
			p[v] = tmp.first, q[v] = tmp.second;
			deg[v]--;
			if (!deg[v]) Q.push(v);
		}
	}
	for (int i = 1; i <= n; i++)
	{
		if (!tr[i].size())
		{
			int g = gcd(p[i], q[i]);
			p[i] /= g, q[i] /= g;
			write(p[i]);
			printf(" ");
			write(q[i]);
			printf("\n");
		}
    }
	return 0;
}
```

---

## 作者：Legitimity (赞：2)

这是今年NOIP唯一一道阳间题 /kk

------------
题目的意思就是：给出一个 DAG，$1-m$ （并不是所有无入度的节点都是源点）节点是源点，无出度的节点为汇点，每个源点的流量为 $1$ ，过程中每个节点的流量均等的流向所有的出路。最后求每个汇点的流量。

但是 CSPS 的经验提醒我出题人不会出这么良心的题目，于是又用我的不灵光的脑子想了想，多次读了读题面，可是发现并没有什么坑。

然后马上出思路：建一张图，从节点 $1-m$ 分别 dfs 一次，一轮一轮累加每个节点的流量。并且因为给出图是 DAG ，所以不用考虑各种奇奇怪怪的情况。当时粗略了算了一下，发现好像最坏的情况（全部互质）**好像**也不会爆 ull

好吧那就欢欢快快的打模拟了。

但是，赛后把这个程序一交，发现咕咕上只有 90pts。

仔细思考了一下，最大有可能$5^{20}$ 肯定会爆 ull，难道这就要写高精取模了吗？

像我这种懒人，高精是不可能写的，这辈子都不可能写的，两个 ull 压位也是不可能写的，有一个好东西叫 `__int128` 是 GCC 在某个 GNU C++ 标准里新增的类型，顾名思义就是 128 位整型，在资瓷该语言标准的 OJ 上可以来水一些高精题目。（可惜 CCF 不认，所以 NOIP 并不能用）

要注意的是，`__int128` 的声明方式和数值运算都同标准的整型，但是不能用常规输入输出，需要读入或输出的时候就用快读的思想手动写。

```cpp
#include<bits/stdc++.h>
#include<stdio.h>
using namespace std;
#define rg register
#define inf 0x7f7f7f7f
#define maxn 100005
inline int read(){
	rg int ret=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ret=ret*10+ch-'0';
		ch=getchar();
	}
	return ret*f;
}//快读
inline void write(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
} //128位整型输出
struct node{
	int nex,to;
}e[maxn*5];
int n,m,d[maxn],v,head[maxn],cnt,out[maxn],cnt2;
bool vis[maxn];
__int128 q[maxn],p[maxn];
inline __int128 gc(__int128 a,__int128 b){
	return b==0?a:gc(b,a%b);
}//求gcd
inline void add(int u,int v){
	e[++cnt].nex=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
inline void solve(int x,__int128 k){//x表示当前所在的节点，k表示从该源点流出的流量流到当前节点时为1/k
	for(rg int i=head[x];i;i=e[i].nex){
		p[e[i].to]=p[e[i].to]*k*d[x]+q[e[i].to];
		q[e[i].to]*=k*d[x];
		__int128 gcdd=gc(p[e[i].to],q[e[i].to]);
		p[e[i].to]/=gcdd;
		q[e[i].to]/=gcdd; //更新流量
		solve(e[i].to,k*d[x]); //流向下一个节点
	}
}
int main(){
	//freopen("water.in","r",stdin);
	//freopen("water.out","w",stdout);
	n=read(); m=read();
	for(rg int i=1;i<=n;++i){
		d[i]=read(); 
		if(d[i]==0) out[++cnt2]=i; //找到出度为0的汇点
		for(rg int j=1;j<=d[i];++j){
			v=read(); add(i,v);
		}
		q[i]=1;
	}//建图
	for(rg int i=1;i<=m;++i){
		q[i]=p[i]=1;
		solve(i,1);
	}//从1到m暴力dfs
	for(rg int i=1;i<=cnt2;++i){
		write(p[out[i]]); //手动输出
		printf(" ");
		write(q[out[i]]);
		printf("\n");
	}
}
```
**题外话：**

（赛场上看 T1 的第一眼就看到流量、$\frac{1}{n}$ 这些阴间东西还以为 T1 来个网络流的期望之类的，身体就开始颤抖了）

（赛后出来之后听学长用了树剖，机房的神犇用拓扑排序，当时就想：艹艹艹，不会又看错题了吧）

---

## 作者：Genius_Star (赞：1)

### 思路：

因为图是一个 DAG，故考虑直接 topo 排序。

设 $ans_i = \frac{q_i}{p_i}$，$out_i$ 表示 $i$ 的出度，则：

$$ans_j \gets ans_j + \frac{q_i}{p_i out_i} ((i \to j) \in E)$$

可以维护一个分数的结构体或者类，写起来方便一点（要开 __int128），而且每次进行运算后都要约分一次，否则可能会爆。

时间复杂度为 $O(N \log W)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
#define int __int128
#define ll __int128
bool Begin;
const int N = 1e5 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
class Frac{
public:
	int a, b;
	Frac(){
		a = b = 0;
	}
	inline void init(int _a, int _b){
		int t = __gcd(_a, _b);
		a = _a / t, b = _b / t;
	}
	inline friend Frac operator+(Frac A, Frac B){
		if(!A.b)
		  return B;
		if(!B.b)
		  return A;
		Frac ans;
		int t = __gcd(A.b, B.b);
		ans.init(A.a * B.b / t + B.a * A.b / t, A.b / t * B.b);
		return ans;
	}
}t;
int n, m, l, x;
int in[N], out[N];
Frac ans[N];
vector<int> E[N];
inline void add(int u, int v){
	E[u].push_back(v);
	++in[v], ++out[u];
}
inline void topo(){
	queue<int> q;
	for(int i = 1; i <= n; ++i)
	  if(!in[i])
	    q.push(i);
	while(!q.empty()){
		int u = q.front();
		q.pop();
		t.init(ans[u].a, ans[u].b * out[u]);
		for(auto v : E[u]){
			ans[v] = ans[v] + t;
			if(!(--in[v]))
			  q.push(v);
		}
	}
}
bool End;
signed main(){
	n = read(), m = read();
	for(int i = 1; i <= n; ++i){
		l = read();
		while(l--){
			x = read();
			add(i, x);
		}
	}
	for(int i = 1; i <= m; ++i)
	  ans[i].init(1, 1);
	topo();
	for(int i = m + 1; i <= n; ++i){
		if(out[i])
		  continue;
		write(ans[i].a);
		putchar(' ');
		write(ans[i].b);
		putchar('\n');
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：cyngugugu (赞：1)

## 题意

略

## 分析

对于每一个排水节点而言，如果没有其他的水输入，那我们就可以把这个节点中的污水均匀排放到和它连接的排水节点。

所以上游的节点要比下游先遍历，考虑拓扑排序。

由于要求输出分数形式，就分别开两个数组存分子和分母，如果用 ```long long``` 会爆，开高精又太麻烦，用 ```int128``` 计算就可以了。

剩下的详见注释。

## 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int N=201000;
const int M=100;
const int INF=0x3f3f3f3f;
void print(__int128 x){
	if(x<0){
		putchar('-');
		print(x*-1);
	}
	else if(x<10){
		putchar(x+'0');
	}
	else {
		print(x/10);
		putchar(x%10+'0');
	}
}//int128 输出必须手写快写，快读可以用 longlong 转 int128 过去
__int128 gcd(__int128 a1,__int128 a2){
	if(a2==0)return a1;
	return gcd(a2,a1%a2);
}
int n,m;
vector <int> a[N];
int ru[N];
bool vis[N];
queue <int> qu;
struct qwq{
	__int128 q,p;
}f[N];
void jf(int a1,int a2,int len){
	__int128 tru=f[a1].p*len;
	__int128 lcm=(f[a2].p*tru)/gcd(tru,f[a2].p);
	f[a2].q=f[a2].q*lcm/f[a2].p+f[a1].q*lcm/tru;
	f[a2].p=lcm;
	__int128 gg=gcd(f[a2].q,f[a2].p);
	f[a2].p/=gg;
	f[a2].q/=gg;
}//将两个分数通分计算后再约分
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	fo(i,1,n){
		int x;
		cin>>x;
		f[i].p=1;
		if(x==0)vis[i]=1;
		fo(j,1,x){
			int y;
			cin>>y;
			a[i].push_back(y);
			ru[y]++;
		}
	}
	fo(i,1,n){
		if(ru[i]==0){
			qu.push(i);
			f[i].q=1;
		}
	}
	while(!qu.empty()){
		int x=qu.front();
		qu.pop();
		int len=a[x].size();
		fo(i,0,len-1){
			int v=a[x][i];
			jf(x,v,len);
			ru[v]--;
			if(ru[v]==0)qu.push(v);
		}
	}
	fo(i,1,n){
		if(vis[i]==1){
			print(f[i].q);
			putchar(' ');
			print(f[i].p);
			putchar('\n');
		}
	}
	return 0;
}

```

---

## 作者：_H17_ (赞：0)

## 题目分析

考虑使用拓扑排序，每个点统计一个当前水量，每次给子节点的当前水量加上自己的一部分（总量除以出度），显然根据拓扑排序的性质每遍历到一个点一定所有水都留进去了。

入度为 $0$ 的点初始水量是 $1$。

记得用分数结构体储存（化简、加法、乘法法则和数学一样，求最大公约数之后就可以做了）。

数很大，建议使用 `__int128` 来存储数。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Frac{
    #define int __int128
	int son,mom;
	Frac(int son=0,int mom=1):son(son),mom(mom){}
	void easy(){
		int tmp=__gcd(son,mom);
		son/=tmp,mom/=tmp;
		return;
	}
	Frac mul(Frac k){
		Frac ret;
		ret.son=son*k.son;
		ret.mom=mom*k.mom;
		ret.easy();
		return *this=ret;
	}
	Frac add(Frac k){
		Frac ret;
		ret.mom=mom/__gcd(mom,k.mom)*k.mom;
		ret.son=ret.mom/mom*son+ret.mom/k.mom*k.son;
		ret.easy();
		return *this=ret;
	}
	#undef int
};
int n,m,head[100001],ind[100001],oud[100001],tot,vis[100001];
struct Edge{
	int nxt,tar;
	Edge(int nxt=0,int tar=0):nxt(nxt),tar(tar){}
}e[1000001];
void add(int u,int v){
	ind[v]++,oud[u]++;
	e[++tot]=Edge(head[u],v),head[u]=tot;
	return;
}
Frac water[100001];
queue<int>q;
void output(__int128 a){
    vector<int>t;
    do{
        t.push_back(a%10);
        a/=10;
    }while(a);
    reverse(t.begin(),t.end());
    for(auto p:t)
        cout<<p;
}
signed main(){
	cin>>n>>m;
	for(int i=1,v,d;i<=n;i++){
		cin>>d;
		while(d--){
			cin>>v;
			add(i,v);
		}
	}
	for(int i=1;i<=n;i++)
		if(!ind[i]){
			q.push(i);
			water[i]=Frac(1,1);
			vis[i]=1;
		}
		else{
			water[i]=Frac(0,1);
		}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u],v;i;i=e[i].nxt){
			v=e[i].tar;
			water[v].add(Frac(water[u].son,water[u].mom*oud[u]));
			if((--ind[v])==0){
				q.push(v);
				vis[v]=1;
			}
		}
	}
	for(int i=1;i<=n;i++)
		if(oud[i]==0){
			water[i].easy();
			output(water[i].son);
			cout<<' ';
			output(water[i].mom);
			cout<<'\n';
		}
	return 0;
}
```

---

## 作者：e_zhe (赞：0)

### 题目链接

<https://www.luogu.com.cn/problem/P7113>

### 分析

此题中的图是有向无环图，可以进行拓扑排序。

用一个结构体表示分数。入度为 $0$ 的点的分子和分母初始都为 $1$，其他的点分子为 $0$，分母为 $1$。

在拓扑排序的过程中处理污水的流动，对污水体积进行运算。对于当前节点和其后驱的表示污水体积的分数，都先通分，然后作加法。

最后输出所有出度为 $0$ 的节点的污水体积即可。

注意要开 `__int128`，否则就要写高精。

细节内容见代码注释。

### Code

```cpp
#include<bits/stdc++.h>
#define i128 __int128
using namespace std;

const int N=1e5;
int n,m,in[N+5];
struct Node{
	//分子和分母 
	i128 son,mth=1;
}a[N+5];
vector<int>g[N+5];

//__int128 需要手写输入输出 
void read(i128 &x){
    bool f=1;x=0;char ch=getchar();
    while(ch<48||ch>57){
		if(ch=='-')f=!f;
		ch=getchar();
	}
    while(ch>=48&&ch<=57)
		x=(x<<1)+(x<<3)+(ch^48),
		ch=getchar();
    x=(f?x:-x);
	return;
}
void write(i128 x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+48);
	return;
}

//求最小公倍数，用来通分 
i128 lCm(i128 x,i128 y){return x/__gcd(x,y)*y;}

//拓扑排序 
queue<int>q;
void toposort(){
	for(int i=1;i<=n;++i)
		//入度为 0，即起始节点 
		if(in[i]==0){
			q.push(i);
			//分子设为 1（分母初始就是 1） 
			a[i].son=1;
		}
	
	int frt;
	i128 new_mth,k1,k2;
	while(!q.empty()){
		frt=q.front();q.pop();
		//出度为 0，即“最终排水口” 
		if(g[frt].size()==0)continue;
		
		//有多少个后驱就将当前节点的污水平均分成多少份 
		a[frt].mth*=g[frt].size();
		for(int v:g[frt]){
			//新分母是原来两个分母的最小公倍数 
			new_mth=lCm(a[frt].mth,a[v].mth),
			//原来的两个分数分别扩大了多少倍 
			k1=new_mth/a[frt].mth,
			k2=new_mth/a[v].mth,
			//新分子和新分母 
			a[v].son=a[frt].son*k1+a[v].son*k2,
			a[v].mth=new_mth;
			
			if(--in[v]==0)q.push(v);
		}
		
		//没有污水了，恢复初始状态 
		a[frt].mth=1,a[frt].son=0;
	}
	return;
}

int main(){
	int x1,x2;
	
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		scanf("%d",&x1);
		while(x1--){
			scanf("%d",&x2);
			g[i].push_back(x2);++in[x2];
		}
	}
	
	toposort();
	
	i128 tmp;
	for(int i=1;i<=n;++i){ 
		if(g[i].size())continue;//不是“最终排水口” 
		
		//化为最简分数 
		tmp=__gcd(a[i].mth,a[i].son);
		write(a[i].son/tmp);putchar(' ');
		write(a[i].mth/tmp);putchar('\n');
	}
	return 0;
}
```

---

## 作者：wjr_jok (赞：0)

拓扑，通过判断入度和出度，确定污水接收口和最终排水口，然后根据题意拓扑序转移水量。

题目要求输出最简分数形式，写一个函数通分相加再约分即可，注意因为数比较大需要开 $\texttt{int128}$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
void write(__int128 n){
    if(n<0) putchar('-'),n*=-1;
    if(n>9) write(n/10);
    putchar(n % 10 + '0');
}
struct jgt{//分子分母单独储存
	__int128 fz,fm;
} xl[N];
int n,m,x,s;
int rd[N],flag[N];
vector<int> lj[N];
stack<int> AC;
jgt ex(jgt x,jgt y){//处理分数相加
	jgt cnt;
	cnt.fz=x.fz*y.fm+y.fz*x.fm,cnt.fm=x.fm*y.fm;
	__int128 gys=__gcd(cnt.fz,cnt.fm);
	if(gys){
		cnt.fz/=gys,cnt.fm/=gys;
	}
	return cnt;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x;
		for(int j=1;j<=x;j++){
			cin>>s;
			lj[i].push_back(s);
			rd[s]++;
		}
	}
	for(int i=1;i<=n;i++){
		xl[i].fm=1;
		if(!rd[i]){
			xl[i].fz=1;
			AC.push(i);
		}
	}
	while(!AC.empty()){//拓扑序转移
		int t=AC.top();
		AC.pop();
		flag[t]=1;
		if(lj[t].size()){
			xl[t].fm*=lj[t].size();
			__int128 cc=__gcd(xl[t].fz,xl[t].fm);
			xl[t].fz/=cc,xl[t].fm/=cc;
		}
		for(int i=0;i<lj[t].size();i++){
			if(flag[lj[t][i]]){
				continue;
			}
			xl[lj[t][i]]=ex(xl[t],xl[lj[t][i]]);
			rd[lj[t][i]]--;
			if(!rd[lj[t][i]]){
				AC.push(lj[t][i]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(!lj[i].size()){
			write(xl[i].fz),printf(" "),write(xl[i].fm),puts("");//因为用的int128，需要快读输出
		}
	}
	return 0;
}
```

---

## 作者：Nephren_Sakura (赞：0)

拓扑排序板子。

首先我们考虑设 $dp_i$ 表示第 $i$ 个点总共会接收到多少流量。

那么考虑从 $i$ 转移到下一个点 $nxt$，因为点 $i$ 的流量会被所有的 $nxt$ 分流，则 $dp_{nxt}=dp_{nxt}+\frac{dp_i}{d_i}$。

初始化把 $1$ 到 $m$ 的 $dp$ 值设置为 $1$，输出所有排水口的 $dp$ 值即可。

然后你考虑把 $dp$ 数组改成一个分子一个分母的形式直接跑，爆 ```long long``` 了。

如果这是几年前你只能使用复杂难写的高精，但现在你可以使用 ```__int128``` 以及快读快出解决。

粘个代码，仅供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline __int128 read()
{
    char ch; __int128 res = 0;
    while ((ch = getchar()) < '0' || ch > '9');
    res = ch ^ 48;
    while ((ch = getchar()) >= '0' && ch <= '9')
     res = (res << 3) + (res << 1) + ch - '0';
    return res;
} 
inline void put(__int128 x)
{
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
__int128 n,m,tot,head[1000005],in[1000005],out[1000005],dp_zi[1000005],dp_mu[1000005];
queue<__int128> q;
struct edge{
	__int128 to,next;
}e[1000005];
void add(__int128 x,__int128 y){
	tot++;
	e[tot].next=head[x];
	e[tot].to=y;
	head[x]=tot;
	return;
}
__int128 help_zi(__int128 zi,__int128 mu,__int128 ZI,__int128 MU){
	return zi*MU+mu*ZI;
}
__int128 help_mu(__int128 zi,__int128 mu,__int128 ZI,__int128 MU){
	return mu*MU;
}
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();
	m=read();
	for(__int128 i=1; i<=n; i++){
		dp_mu[i]=1;
		__int128 x;
		x=read();
		for(__int128 j=1; j<=x; j++){
			__int128 y;
			y=read();
			add(i,y);
			in[y]++;
			out[i]++;
		}
	}
	for(__int128 i=1; i<=n; i++)
		if(!in[i])
			q.push(i),dp_zi[i]=dp_mu[i]=1;
	while(q.empty()==false){
		__int128 cur=q.front();
		q.pop();
		for(__int128 i=head[cur]; i; i=e[i].next){
			__int128 nxt=e[i].to;
			in[nxt]--;
			dp_zi[nxt]=help_zi(dp_zi[nxt],dp_mu[nxt],dp_zi[cur],dp_mu[cur]*out[cur]);
			dp_mu[nxt]=help_mu(dp_zi[nxt],dp_mu[nxt],dp_zi[cur],dp_mu[cur]*out[cur]);
			__int128 gcd=__gcd(dp_zi[nxt],dp_mu[nxt]);
			dp_zi[nxt]/=gcd;
			dp_mu[nxt]/=gcd;
			if(!in[nxt])
				q.push(nxt);
		}
	}
	for(__int128 i=1; i<=n; i++)
		if(out[i]==0){
			put(dp_zi[i]);
			putchar(' ');
			put(dp_mu[i]);
			putchar('\n');
		}
	return 0;
}
```

---


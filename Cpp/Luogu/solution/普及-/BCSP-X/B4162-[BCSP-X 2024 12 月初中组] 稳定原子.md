# [BCSP-X 2024 12 月初中组] 稳定原子

## 题目背景

小 $\tau$ 在学结构化学。

## 题目描述

小 $\tau$ 认为一个大小为 $n$ 的原子可以抽象为一个 $n \times n$ 的矩阵，每个位置上要么有电子，要么没有电子。

并且一个原子是稳定的，当且仅当它的矩阵中的每一个位置均满足上下左右相邻的电子数恰好等于 $2$。

小 $\tau$ 想问问你，在他上述理论体系下，是否存在大小为 $n$ 的稳定原子，如果存在，输出 Yes 并给出一种稳定原子的电子排布方案；如果不存在，输出 No。

由于小 $\tau$ 非常好奇，所以他会问 $T$ 次。

## 说明/提示

对于 $100\%$ 的数据，$T=10$，$1\leq n\leq 1000$。

**声明：本题所述内容并非化学事实。**

## 样例 #1

### 输入

```
3
1
2
3```

### 输出

```
No
Yes
1 1
1 1
No```

# 题解

## 作者：Sweet_2013 (赞：5)

# 我的解题思路
- 输入。
- 判断矩阵边长是否为奇数，如果是，输出 ```No```，否则输出 ```Yes``` 并打印矩阵。
- 打印矩阵：判断这个最小距离是否为偶数，如果是，这一格填 $1$，否则填 $0$。
- 计算某个位置到矩阵边界最近的距离：计算当前点到矩阵四条边的距离中的最小值，我们发现了这个计算最小值的公式（详见代码），其中，$n-i-1$ 是到下边的距离，$n-j-1$ 是到右边的距离。
# 上代码！

```cpp
#include <bits/stdc++.h> 
using namespace std;     
//计算位置 (i, j) 到矩阵边界的最小距离。
int check(int i, int j, int n) { 
    return min(i, min(j, min(n-i-1, n-j-1))); // 返回到上下左右边界的最小值，n-i-1 是到下边的距离，n-j-1 是到右边的距离。
}
// 打印矩阵
void pm(int n) {
    for(int i=0;i<n;i++) { 
        for (int j=0;j<n; j++) { 
            cout <<!(check(i, j, n) & 1)<< " "; // 根据距离的奇偶性输出 0 或 1。
            // check(i, j, n) & 1：判断距离是否为奇数。
            // 奇数输出 0，偶数输出 1。
        }
        cout<<endl; // 每行结束后换行。
    }
}
int n, t;
int main() {
    cin>> t; 
    while (t--) { 
        cin >> n; 
        if (n&1) cout<<"No"<< endl; // 判断矩阵边长是否为奇数，如果是奇数，输出 No。
        else {
            cout << "Yes" << endl; //否则输出 Yes
            pm(n); //打印
        }
    }
    return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

一道简单构造题。

对于一个角上的点它相邻的两个点一定是 $1$。已左上角的点 $(1, 1)$ 举例，那么与它相邻的点 $(1,2)$ 和 $(2, 1)$ 都为 $1$，归纳得 $(2k-1, 2k)$ 和 $(2k, 2k-1)$ 都为 $1$，$k$ 是正整数。

考虑到 $(n-1, n)$ 和 $(n, n-1)$ 即与右下角的点 $(n, n)$ 相邻的两个点一定是 $1$，所以 $n$ 可以写成 $2k$ 一定为偶数。

所以 $n$ 是奇数时无解， $n$ 是偶数时构造方案应该不唯一，容易想到一圈 $1$ 一圈 $0$ 这样构造。

实现时，由于最外圈是 $1$，所以通过该点到最外圈的距离是奇数还是偶数，来判断填 $0$ 还是 $1$，距离偶数则填 $1$，距离奇数则填 $0$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main () {
	int T, n;
	cin >> T;
	while (T--) {
		cin >> n;
		puts(n%2?"No":"Yes");
		if (n%2==0)
			for (int i=1; i<=n; cout << '\n', ++i) 
				for (int j=1; j<=n; ++j) 
					cout << 1-min({i-1, n-i, j-1, n-j})%2 << ' ';
	}
	return 0;
}
```

---

## 作者：SXY83296647 (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/B4162)
## 思路：
由题意，$n \times n$ 的矩阵中每一个数的上下左右四个方向的数之和等于 $2$，所以可得四个顶点周围的数必等于 $1$，接着考虑剩下的数。

最终可以发现，只有当最外圈的数为 $1$，里面的一圈的数为 $0$，再里面的一圈的数为 $1$（以此类推）时，矩阵符合条件。但又因为当 $n$ 为奇数时，矩阵的最内部无法形成一个 $2 \times 2$ 的全为 $1$ 或 $0$ 的矩阵，所以当 $n$ 为奇数直接输出 No 。否则按照规律先输出 Yes ，再输出矩阵。
## AC Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n;
int main()
{
	scanf("%d",&t);
	for (int i = 1;i <= t;i++)
	{
		scanf("%d",&n);
		if (n%2==1)
		{
			printf("%s\n","No");
		}
		else
		{
			printf("%s\n","Yes");
    		for (int i = 0; i < n; ++i)
			{
        		for (int j = 0; j < n; ++j)
				{
            		int k = min(min(i, j),min(n-1-i, n-1-j));
            		printf("%s",((k + 1) % 2 ? "1 " : "0 "));//判断输出1或0(直接输出节省内存)
        		}
        		printf("\n");//换行
    		}
		}
	}
	return 0;
}
```
时间复杂度 $O(n^2)$，$1 \le n \le 1000$，不会超时。

---

## 作者：canwen (赞：2)

简单题，$n\times n$ 矩阵的四个边角只有两个方向有相邻的，所以可以先确认几个 $1$ 的位置。接着继续考虑 $n\times n$ 矩阵每个外圈上的数，可以构造出最外圈都是 $1$，往内一圈都是 $0$，往内两圈都是 $1$ 依次类推的矩阵，这样可以使得外圈的每个位置上（包括四个边角）对于**上下左右四个方向**都能找到恰好两个方向上共两个 $1$。

那么对于 $n$ 为奇数，显然最里层无法构造一个 $2 \times 2$ 的全为 $1$ 的矩阵，只剩下中间一个 $1$，而周围都是 $0$，显然不合法，故无解。

注意多测清空，不然像我一样爆了一次零嘤嘤嘤。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar();return k*kk;}
void out(int a){if(a<0) putchar('-'),a=-a;if(a>9) out(a/10);putchar('0'+a%10);}
const int N = 1e3 + 5;
int s[N][N];
signed main(){
	int T = in();
	while(T--){
		int n=in();
		if(n % 2 == 1){
			cout << "No\n";
			continue;
		}
		cout << "Yes\n";
		for(int i=1,j=1,l=n;i<=n;i+=2,j+=2,l-=4){
			if(s[i][j]) break;
			for(int x=i;x<=i+l-1;x++){
				s[x][j] = s[x][j+l-1] = 1;
			}
			for(int y=j;y<=j+l-1;y++){
				s[i][y] = s[i+l-1][y] = 1;
			}
		}
		_rep(i,1,n){
			_rep(j,1,n){
				cout << s[i][j] << " ";
				s[i][j] = 0;
			}
			pc;
		}
	}
	return 0;
}
```

---

## 作者：Prico (赞：1)

### 思路

#### 第一步：

看到这个题，我就开始探索规律，先填个简单的 3*3 的矩阵看看：

![](https://cdn.luogu.com.cn/upload/image_hosting/b5noey9n.png)

如果最中间填 1 的话，按照题目要求，应该是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/zbd3gmud.png)

然后发现，再填就不符合题目要求了：

![](https://cdn.luogu.com.cn/upload/image_hosting/38cunpp3.png)

再试试填 0 （中间过程省略）：

![](https://cdn.luogu.com.cn/upload/image_hosting/woorej3e.png)

发现无解。

这不足以说明什么，看一下 7*7 (手绘图，不喜勿喷)。

首先，把刚才的 3*3 矩阵搬过来：

![](https://cdn.luogu.com.cn/upload/image_hosting/a0p2e7bi.png)

继续填下去，你就会发现也无解：

![](https://cdn.luogu.com.cn/upload/image_hosting/9l96ap73.png)

但如果是 4*4 的话：
![](https://cdn.luogu.com.cn/upload/image_hosting/08inz42h.png)

另外，大家应该都知道魔方，如果它没有中心块(一开始我们考虑 3*3 矩阵填 0 还是 1 的那个中心点)就可行，有则不行：

![](https://cdn.luogu.com.cn/upload/image_hosting/08inz42h.png)

**总结: n 为奇数时无解，为偶数时则有解。**


#### 第二步：

如果是 yes 就输出矩阵，就往上填就可以了，判断它是奇/偶圈(难点)：


```cpp
if((min(min(i,n-i+1),min(j,n-j+1)))%2!=0){
    cout<<1<<" ";
}
else{
    cout<<0<<" ";
}
```

## Code :


```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
int main(){
	cin>>T;
	for(int x=1;x<=T;x++){
		cin>>n;
		if(n%2!=0){//奇数一定不会满足要求 
			cout<<"No"<<endl;
		}
		if(n%2==0){
			cout<<"Yes"<<endl;
			for (int i=1;i<=n;i++){
				for (int j=1;j<=n;j++){
					if((min(min(i,n-i+1),min(j,n-j+1)))%2!=0){
						cout<<1<<" ";
					}
					else{
						cout<<0<<" ";
					}
				}	
				cout<<endl;
			}
		}
	}
	return 0;
}
```

---

## 作者：Wzmois (赞：1)

## Solution
### 题目大意
给出一个每一个位置均满足上下左右相邻的电子数恰好等于 $2$ 的矩阵。
### 构造思路
- 如何构造上下左右皆有 $2$ 个 $1$ 的矩阵呢？
1. 首尾相接的一个边框（如图一）时所有的 $1$ 都满足题目条件。
2. 但是里面的 $0$ 又不满足了条件，怎么办呢？那我们**再来一遍**。我们隔开一个首尾相接的一个边框（这个边框的值为 $0$）再次构造出首尾相接的一个边框（这个边框的值为 $1$），如图二所示，你可以数一下，这种情况就是 $n=6$ 时的解。
```
图 1
1 1 1 1 1 1
1 0 0 0 0 1
1 0 0 0 0 1
1 0 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```
```
图 2
1 1 1 1 1 1
1 0 0 0 0 1
1 0 1 1 0 1
1 0 1 1 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```
- 由样例我们可以看出奇数的时候仿佛并没有解。或者由上面的构造方法我们来试一下是否可行。显而易见，如图三，最中间的 $1$ 并不符合题意。故奇数并没有解。
```
图 3
1 1 1 1 1
1 0 0 0 1
1 0 1 0 1
1 0 0 0 1
1 1 1 1 1
```
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){int i=0;char n=0,ch='\0';while((ch=getchar())<48||ch>57) if(ch=='-') n=1 ;while(ch>47&&ch<58) i=(i<<1)+(i<<3)+(ch&0xCF),ch=getchar();if(n) i=-i;return i;}
#define s(mois) mois=read()
#define FastRead ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
int a[1004][1004];
int main(){
	FastRead;
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		if((n+1)%2==0) printf("No");//奇数判断
		else{
			printf("Yes\n");//偶数
			int idx=1;
			while(idx<=n-idx+1){
				for(int i=idx;i<=n-idx+1;i++) a[n-idx+1][i]=a[idx][i]=a[i][idx]=a[i][n-idx+1]=1;
                //首尾相接的矩阵
				idx+=2;//隔一个首尾相接的矩阵再来构造
			}
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					printf("%d ",a[i][j]);
				}
				if(i!=n) puts("");
			}
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					a[i][j]=0;//恢复为 0
				}
			}
		}
		puts("");
	}
	return 0;
}
``````
## 后记
制作不易，如有问题请管理员或读者**详细**反馈问题给我。

---

## 作者：czh1005 (赞：1)

这题很明显是找规律题，找规律题要么找出规律并证明，要么打表找规律。\
对于第 $x$ 行，第 $y$ 列，要么是 $0$ 要么是 $1$。\
在最后判一下是否满足每个均满足上下左右相邻的电子数恰好等于 $2$。\
时间复杂度为 $O(2^n)$，有点太慢了,所以我们加一个小小的优化。\
当发现这个位置已经不能填 $0$，否则左边的一格和上边的一格的和为 $0$，不可能凑出 $2$ 时，就没有必要再去尝试了。\
同理，当发现这个位置已经不能填 $1$，否则左边的一格和上边的一格的和为 $3$，不可能凑出 $2$ 时，就没有必要再去尝试了。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+10;
int t,n,a[maxn][maxn];
bool flag;
void dfs(int x,int y){
	if(y==n+1){
		dfs(x+1,1);
		return;
	}
	if(x==n+1){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(a[i-1][j]+a[i][j-1]+a[i+1][j]+a[i][j+1]!=2) return;
			}
		}
		cout<<"Yes\n";
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cout<<a[i][j]<<" ";
			}
			cout<<'\n';
		}
		flag=1;
		return;
	}
	if((a[x][y-2]+a[x-1][y-1]==0)||(x>=2&&a[x-1][y-1]+a[x-2][y]+a[x-1][y+1]==1)){//小心越界
		a[x][y]=1;
		dfs(x,y+1);
	}else if((a[x][y-2]+a[x-1][y-1]==2)||(x>=2&&a[x-1][y-1]+a[x-2][y]+a[x-1][y+1]==2)){//小心越界
		a[x][y]=0;
		dfs(x,y+1);
	}else{
		a[x][y]=0;
		dfs(x,y+1);
		a[x][y]=1;
		dfs(x,y+1);
	}
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		dfs(1,1);
		if(!flag){
			cout<<"No\n";
		}
		flag=0;
	}
	return 0;
}
```
输入

```cpp
10
1 2 3 4 5 6 7 8 9 10
```

把 $10$ 的输出给大家看一下

```cpp
1 1 1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 0 0 1
1 0 1 1 1 1 1 1 0 1
1 0 1 0 0 0 0 1 0 1
1 0 1 0 1 1 0 1 0 1
1 0 1 0 1 1 0 1 0 1
1 0 1 0 0 0 0 1 0 1
1 0 1 1 1 1 1 1 0 1
1 0 0 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1
```
把 $9$ 的输出给大家看一下

```cpp
No
```

发现明显规律，如果是偶数，答案是一圈 $1$ 一圈 $0$。\
如果是奇数，答案是 $\texttt{No}$。\
那么如何判别每个方格属于哪一圈呢？\
举个例子。

```cpp
   +      
   +      
   +      
+++*++++++
   +      
   +      
```
中间的那个方格就属于第 $3$ 圈。\
那么发现离最外面一圈的最近的距离，就是它的圈数。\
奉上正解。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+10;
int t,n,a[maxn][maxn];
int mn(int a,int b,int c,int d){
	return min(a,min(b,min(c,d)));
}
void solve(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int x=mn(i,j,n-i+1,n-j+1);//判断是第几圈
			if(mn(i,j,n-i+1,n-j+1)%2==1){//判断是不是第偶数圈
				a[i][j]=1;
			}
		}
	}
	cout<<"Yes\n";
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<a[i][j]<<" ";
		}
		cout<<'\n';
	}
}
int main(){
	cin>>t;
	while(t--){
		memset(a,0,sizeof(a));//记得清空
		cin>>n;
		if(n%2==1){
			cout<<"No\n";
		}else{	
			solve();
		}
	}
	return 0;
}
```

---

## 作者：Accepted3927 (赞：1)

# 题解：B4162 [BCSP-X 2024 12 月初中组] 稳定原子

## Part 1 最重要的题意理解
由题面可知：

- _一个原子是稳定的，当且仅当它的矩阵中的每一个位置均满足上下左右相邻的电子数恰好等于 2。_ 


-   _每一个位置只有两种可能，$0$ 或 $1$。_ 

 所以我们结合上面两句话，就能知道 2 个**结论**：
 
-   **每一个 1 相邻两个 1**。

- **每一个 0 相邻两个 0**。

 那么，假如某种情况有解，矩阵就会是这样的：
-  1 个 $1$，接着 1 个 $1$，又接着第 3 个 $1$，第 4 个  $1$……

-    1 个 $0$，接着 1 个 $0$，又接着第 3 个 $0$，第四个 $0$……

 **$1$ 与 $0$ 各自形成了环！！！**
 
于是题目就变成了如何一个打印一层环套着一层环……

但是需注意，奇数的时候最内层只有 1 个，形成不了环，输出：
```
No
```
## Part 2 解决方法

观察图得，当一个位置在第奇数层，输出  $1$。设位置横坐标为 $i$，纵坐标 $j$，矩阵边长 $n$。

设 $u=\min(i,n-i+1)$，$v=\min(j,n-j+1)$。

则一个位置层数等于 
$\min(u,v)$。

由此，可以遍历 $n\times n$ 个位置，依次打印。

## Part 3 AC Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int t;//数据组数 
void out(int l){
	cout<<"Yes\n"; //别忘输出Yes！ 
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++){
			int u=min(i,l-i+1),v=min(j,l-j+1);
			if(min(u,v)%2) cout<<"1 ";
			else cout<<"0 ";
		}
		cout<<'\n';//行末换行 
	}
}
int main(){
	cin>>t;
	while(t--){ //循环t次 
		int x;cin>>x;
		if(x%2) cout<<"No\n";//奇数无解 
		else{
			//否则打印矩阵 
			out(x);
		}
	}
	return 0;
}
```

---

## 作者：New_Void (赞：1)

## [B4162 [BCSP-X 2024 12 月初中组] 稳定原子](https://www.luogu.com.cn/problem/B4162)

### 思路

首先我们可以观察一下，这个矩阵怎样才可以形成，我们可以观察他的最外层的一圈，我们发现最外层的一圈的四个顶点上和他的两边的点都应该有电子，之后我们继续看最外层一圈的点，我们不妨假设一下，如果最外层所有的点都有电子的话成不成立，经过观察我们发现，最外圈如果都是电子的话，那他的左右两边就也是电子，这已经有两个了，所以内层一圈应该全不是电子。

这样我们的规律就知道了，我们只要判断如果 $n$ 是奇数，那么他就不是一个正确的，如果不是就是正确的，而矩阵则就是最外圈都是电子，然后一圈都不是电子，循环往复。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while (t--){
        int n;
        cin>>n;
        int arr[n+1];
        if (n%2==1){
            cout<<"No"<<endl;
        }
        else{
            cout<<"Yes"<<endl;
            for (int i=1;i<=n;i++){
                for (int j=1;j<=n;j++){
                    int c=min(min(i-1,j-1),min(n-i,n-j)); //判断这个点是有电子那一圈的还是没电子那一圈的
                    if (c%2==1){
                        cout<<0<<" ";
                    }
                    else{
                        cout<<1<<" ";
                    }
                }
                cout<<endl;
            }
        }
    }
    return 0;
}

```

---

## 作者：YBa2Cu3O7 (赞：1)

找规律。

先以 $n=6$ 的情况为例，从左上角开始填充，首先为了保证矩阵最左上角元素 $a_{11}$ 满足条件，一定要有
$$\begin{bmatrix}
 ? & 1 & ? & ? & ? & ?\\
 1 & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?
\end{bmatrix},
$$
继续，为了保证 $a_{22}$ 满足条件，
$$\begin{bmatrix}
 ? & 1 & ? & ? & ? & ?\\
 1 & ? & 0 & ? & ? & ?\\
 ? & 0 & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?
\end{bmatrix},
$$
继续 $a_{13}$，$a_{31}$，$a_{33}$，
$$\begin{bmatrix}
 ? & 1 & ? & 1 & ? & ?\\
 1 & ? & 0 & ? & ? & ?\\
 ? & 0 & ? & 1 & ? & ?\\
 1 & ? & 1 & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?\\
 ? & ? & ? & ? & ? & ?
\end{bmatrix},
$$
继续 $a_{42}$，$a_{24}$，$a_{44}$，
$$\begin{bmatrix}
 ? & 1 & ? & 1 & ? & ?\\
 1 & ? & 0 & ? & 0 & ?\\
 ? & 0 & ? & 1 & ? & ?\\
 1 & ? & 1 & ? & 0 & ?\\
 ? & 0 & ? & 0 & ? & ?\\
 ? & ? & ? & ? & ? & ?
\end{bmatrix},
$$
最后
$$\begin{bmatrix}
 ? & 1 & ? & 1 & ? & 1\\
 1 & ? & 0 & ? & 0 & ?\\
 ? & 0 & ? & 1 & ? & 1\\
 1 & ? & 1 & ? & 0 & ?\\
 ? & 0 & ? & 0 & ? & 1\\
 1 & ? & 1 & ? & 1 & ?
\end{bmatrix}.
$$
这个结果是我们从左上角推过来的，现在我们从右上角以类似的过程再推一遍，就得到了
$$\begin{bmatrix}
 1 & 1 & 1 & 1 & 1 & 1\\
 1 & 0 & 0 & 0 & 0 & 1\\
 1 & 0 & 1 & 1 & 0 & 1\\
 1 & 0 & 1 & 1 & 0 & 1\\
 1 & 0 & 0 & 0 & 0 & 1\\
 1 & 1 & 1 & 1 & 1 & 1
\end{bmatrix}.
$$
现在我们回头来关注从一条对角线上填充过来时的交替的一对 $0$ 和 $1$，
$$\begin{bmatrix}
 ? & 1 &  &  &  & \\
 1 & ? & 0 &  &  & \\
  & 0 & ? & 1 &  & \\
  &  & 1 & ? & 0 & \\
  &  &  & 0 & ? & 1\\
  &  &  &  & 1 & ?
\end{bmatrix}，
$$
可以发现，只有当 $n$ 为偶数时，右下角才能以一对 $1$ 结尾，而奇数时不行，所以当输入的 $n$ 为奇数时直接输出 No。

另一方面，当 $n$ 为偶数时，满足条件的矩阵是存在的，并且它的样子就是一圈一圈的 $01$ 交替。

主要代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

void putmat(int n){
    auto check=[&](int i,int j){
        return min(i,min(j,min(n-i-1,n-j-1)));
    };
    for(int i=0;i<n;++i){
        for(int j=0;j<n;++j){
            cout<<!(check(i,j)&1)<<' ';
        }
        cout<<'\n';
    }
}

int main(){
    int T;
    cin>>T;
    for(int i=0;i<T;++i){
        int n;
        cin>>n;
        if(n&1){
            cout<<"No\n";
        }
        else{
            cout<<"Yes\n";
            putmat(n);
        }
    }
    return 0;
}
```
其中 `check` 函数用于判断位置 $(i,j)$ 处于第几圈，通过计算这个位置到边界的最短距离来得到，圈数从 $0$ 开始。

---

## 作者：Wangchenxi2013 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4162)

一道不错的构造题。
先考虑四格的情况。
以下是矩阵 $a$。

|?|1|?|?|
|:-:|:-:|:-:|:-:|
|1|?|?|?|
|?|?|?|?|
|?|?|?|?|

不难发现，因为 $a_{1,1}$ 的四联通只有 $a_{1,2}$ 与 $a_{2,1}$，且 $a_{1,1}$ 的四联通里必有两个 $1$ 所以 $a_{1,2}$ 与 $a_{2,1}$ 为 $1$ 。

同样的，应为 $a_{2,2}$ 的四联通里已经有了两个 $1$ 所以 $a_{2,3}$ 与 $a_{3,2}$ 为 $0$。以此类推，可以得到下图：

|?|1|1|?|
|:-:|:-:|:-:|:-:|
|1|0|0|1|
|1|0|0|1|
|?|1|1|?|

接下来考虑 $a_{1,2}$ 由于它的四联通只有一个 $1$，所以 $a_{1,1}$ 为 $1$。同理，$n ＝ 4$ 就构造出来了。



|1|1|1|1|
|:-:|:-:|:-:|:-:|
|1|0|0|1|
|1|0|0|1|
|1|1|1|1|

偶数都是如此，例如 $n = 6$ 就是这样的：


|1|1|1|1|1|1|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|0|0|0|1|
|1|0|1|1|0|1|
|1|0|1|1|0|1|
|1|0|0|0|0|1|
|1|1|1|1|1|1|

但是若是奇数呢？例如 $n = 3$ 时，会变成这样：


|?|1|?|
|:-:|:-:|:-:|
|1|?|0|
|?|0|?|

明显不可能。于是只有 $n$ 为偶数时才可以构造出来。可以为一圈 $0$ 一圈 $1$。

想出来之后代码就很简单了，可以枚举 $n$ 依次取反。
### AC code
```
#include<bits/stdc++.h>
using namespace std;
const int N=1000;
int n,t;
bool c[N][N];
void work(){
	if(n&1){puts("No");return;}
	puts("Yes");
	memset(c,0,sizeof(c));
	for(int i=1;i<=n/2;i++)
		for(int j=i;j<=n-i+1;j++)
			for(int k=i;k<=n-i+1;k++)
				c[j][k]^=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<c[i][j]<<' ';
		}
		cout<<"\n";
	}
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		work();
	}
    return 0;
}
```

---

## 作者：lzh_ovo (赞：0)

# B4162题解

[题目传送门](https://www.luogu.com.cn/problem/B4162)

## 题意

这道题就是判断一个 $n\times n$ 的矩阵，能否构成一个每个元素上下左右都有两个 $1$ 的矩阵。如果能就输出该矩阵。

## 思路

其实如果没有头绪可以列举出每个边长的情况。就拿 $n=1$ 举例。边长为 $1$ 的矩阵当然是不能满足题目的要求的。再看 $n=2$ ，样例中给出了。再列举一下 $n=3$ 的情况，不难看出如果四周的方格里都放 $1$ ，满足了四周的方格，但是中间的方格就不成立了，而如果满足了中间的方格，那么边上的方格是一定不可以成立的。从而便可以得出结论，只有没有中间的方格，即 $n$ 为偶数，才可以构成满足题目要求的矩阵。 $n$ 为奇数则一定不行。只要判断一下即可。然后就是考虑如何输出矩阵了，列举一下 $n=6$ 和 $n=8$ 的矩阵，不难看出如果是在矩阵的前一半，方格里是 $1$ 的一定是奇数列的，而矩阵后一半的，方格里的 $1$ 的一定是偶数列，做一个小小的转换，也就是后一半的 $1$ 必须对应前一半的 $1$ 。同理上下也是这么考虑。便可以输出矩阵了，这道题就结束了。

## 讲完了上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int l;
int main(){
    cin>>l;
    for(int q=0;q<l;q++){
        int n;
        cin>>n;
        if(n%2!=0){
            cout<<"No"<<endl;
            continue;
        }
        cout<<"Yes"<<endl;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(min(min(i,n-i+1),min(j,n-j+1))%2!=0){
                    cout<<1<<" ";
                }
                else{
                    cout<<0<<" ";
                }
            }
            cout<<endl;
        }
    }
    return 0;
}
```

（讲的比较细，求过审，谢谢啦）

---

## 作者：felixzou (赞：0)

这道题分类讨论一下即可，考虑的是 $n$ 是奇是偶。

如果 $n$ 是奇数，直接输出 ```No```。

如果 $n$ 是偶数，输出 ```Yes```，最外面的一圈填上 $1$，往里一层的一圈填上 $0$，再往里一层的一圈填上 $1$，再往里一层的一圈填上 $0$，以此类推，直到填满中间的 $2\times2$ 的格子
（也就是从外往里 $1,0$ 交替）。

以下是这道题的 AC 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=1010;
int a[N][N];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        if(n%2==1){
            cout<<"No\n";
        }else{
            cout<<"Yes\n";
            int l=1,r=n,flag=1;
            while(l<r){
                for(int i=l;i<=r;i++){
                    for(int j=l;j<=r;j++){
                        a[i][j]=flag;
                    }
                }
                flag=1-flag;
                l++,r--;
            }
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    cout<<a[i][j]<<" ";
                }
                cout<<"\n";
            }
        }
    }
    return 0;
}

```

---

## 作者：Vct14 (赞：0)

对于 $(1,1)$，由于它上下左右一共只有两个方格，所以 $(2,1)$ 和 $(1,2)$ 一定为 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n9ykop4b.png)

（图中蓝色方格表示当前考虑的格子，绿色方格表示 $1$，红色方格表示 $0$。）

然后对于 $(2,2)$，它的周围已经有两个 $1$ 了，所以 $(3,2)$ 和 $(2,3)$ 一定为 $0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/16oljjp3.png)

随后对于 $(3,1)$，其周围三个方格中，右边的 $3,2$ 一定为 $0$，所以剩下两个一定都为 $1$。即 $(4,1)$ 为 $1$。同理有 $(1,4)$ 为 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kdxdtnom.png)

以此类推，可得对于所有 $k>1$ 且为奇数，都有 $(2,k)$ 为 $0$。而 $(2,n)$ 一定为 $1$。因此 $n$ 为奇数无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/2fyaxfcd.png)

（中间的图省略。）

![](https://cdn.luogu.com.cn/upload/image_hosting/i7kd94m9.png)

这个时候我们从右上角 $(1,n)$ 开始再推一遍就可以得到构造方法了。

![](https://cdn.luogu.com.cn/upload/image_hosting/mmgrj51i.png)

实现也很简单，每次将当前正方形取反，然后将正方形边长减 $2$。

```cpp
#include<bits/stdc++.h>
using namespace std;

bool a[1002][1002];

int main(){
    int t;cin>>t;
    while(t--){
        memset(a,0,sizeof a);
        int n;cin>>n;
        if(n%2){
            cout<<"No\n";
            continue;
        }
        cout<<"Yes\n";
        for(int c=1; c<=n/2; c++) for(int i=c; i<=n+1-c; i++) for(int j=c; j<=n+1-c; j++) a[i][j]=!a[i][j];
        for(int i=1; i<=n; i++,cout<<"\n") for(int j=1; j<=n; j++) cout<<a[i][j]<<" ";
    }
    return 0;
}
```

---

## 作者：darklf (赞：0)

# 题解：B4162 [BCSP-X 2024 12 月初中组] 稳定原子
### [题目传送门](https://www.luogu.com.cn/problem/B4162)
## 思路
要使相邻的电子数目为零，首先需要满足边长为偶数，然后我们知道与左上，左下，右上及右下的电子最多有 $2$ 个，于是与它们相邻的位置一定有电子，于是和它们的距离为奇数的位置都有电子，反之则没有。
## 附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int t,n;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>t;
	while(t--){
		cin>>n;
		if(n%2==1){cout<<"No\n";continue;}
		cout<<"Yes\n";
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++)cout<<(((min(min(i,n-i-1),min(j,n-j-1))+1)%2==0)?"0 ":"1 ");
			cout<<'\n';
		}
	}
	return 0;
}
```
完结撒花。

---


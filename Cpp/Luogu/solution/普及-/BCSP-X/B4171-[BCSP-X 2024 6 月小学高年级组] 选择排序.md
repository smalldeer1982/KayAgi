# [BCSP-X 2024 6 月小学高年级组] 选择排序

## 题目描述

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每趟找出第 $i$ 小的元素（也就是 $A[i \sim n]$ 中最小的元素），然后将这个元素与数组第 $i$ 个位置上的元素 $A[i]$ 交换；在 $n-1$ 趟之后序列 $A$ 变为升序。

例如 $A = [3, 4, 1, 5, 2]$：
- 第 1 趟交换 $A[1], A[3]$，序列变为 $[1, 4, 3, 5, 2]$；
- 第 2 趟交换 $A[2], A[5]$，序列变为 $[1, 2, 3, 5, 4]$；
- 第 3 趟交换 $A[3], A[3]$，序列不变；
- 第 4 趟交换 $A[4], A[5]$，序列变为 $[1, 2, 3, 4, 5]$；

现在给定初始序列 $A[1 \sim n]$（保证 $A$ 是排列，即 $1 \sim n$ 每个数恰好出现一次）和 $m$ 个询问 $q[1, 2, \ldots, m]$（保证 $q[i] < q[i + 1]$），请你依次输出第 $q[i]$ 趟之后的序列 $A$。

## 说明/提示

对于所有数据，满足 $1 \leq n \leq 10^5, 1 \leq m \leq 10, 1 \leq A[i] \leq n, 1 \leq q[i] < q[i + 1] < n$，保证 $A$ 是排列。

- 对于测试点 1~8：$n \leq 10$；
- 对于测试点 9~13：$n \leq 2000$；
- 对于测试点 14~20：$n \leq 10^5$；

## 样例 #1

### 输入

```
5 4
3 4 1 5 2
1 2 3 4```

### 输出

```
1 4 3 5 2
1 2 3 5 4
1 2 3 5 4
1 2 3 4 5```

## 样例 #2

### 输入

```
6 3
6 4 2 3 1 5
1 3 5```

### 输出

```
1 4 2 3 6 5
1 2 3 4 6 5
1 2 3 4 5 6```

# 题解

## 作者：mcturtle (赞：5)

## 题意
其实很简洁，让你模拟选择排序的过程。
## 思路
  我们要通过此题，肯定不能直接模拟，因为 $n\le10^5$，而选择排序的最坏时间复杂度为 $\mathtt{O(n^2)}$，很显然是不行的。

考虑进行优化。

我们需要快速的找到第 $i$ 小的元素。我们可以确定该数组的最大值在 $n$ 之内，同时每个数只会出现一次。

我们使用一个标记数组，$t_i$ 表示 $i$ 出现的下标。然后要注意每次交换，下标为 $i$ 和元素值为 $i$ 的下标交换的时候，需要将他们相对应的标记数组也进行交换。
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005], t[100005];//要使用标记数组
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        t[a[i]] = i;//打标记
    }
    int c = 1;//初始值设好
    while (m--)
    {
        int x;
        cin >> x;
        for (int i = c; i <= x; i++)//从上一次的x开始遍历
        {
            int t1 = t[i], t2 = a[i];//准备工作
            swap(a[i], a[t[i]]);//STL交换
            t[i] = i;//temp变量交换
            t[t2] = t1;//t[a[i]] = t[i]
        }
        for (int i = 1; i <= n; i++)
        {//输出
            cout << a[i] << " ";
        }
        c = x, cout << endl;//更新变量，换行别忘记
    }
}
```
复杂度 $\mathtt{O(nm)}$，可以通过所有数据。

---

## 作者：XsIeEiKcEk (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B4171)

## 题目大意

模拟选择排序过程，输出第 $q_1,q_2,...,q_m$ 次交换后的序列。

## 题目重点

正常模拟的话，是会超时的，我们就要用一种特殊的办法：

因为题目说保证 $A$ 是序列，所以 $A$ 内的数已经定了。我们可以把每一个数出现在序列 $A$ 中的下标记录下来，再一个一个按题意模拟，将值为 $i$ 的位置与下标为 $i$ 的位置交换。

## [AC](https://www.luogu.com.cn/record/206160857) CODE
```cpp
#include<iostream>
using namespace std;
int n,m,a[100001],q[11],t[100001],num=1;//t为标记下标的数组
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        t[a[i]]=i;//存入
    }
    for(int i=1;i<=m;i++)cin>>q[i];
    for(int i=1;i<=n;i++){
        swap(a[i],a[t[i]]);//交换
        swap(t[a[i]]=t[i],t[a[t[i]]]);//更新下标值
        if(i==q[num]){//因为q为升序数组，所以可以这样
            for(int i=1;i<=n;i++)cout<<a[i]<<' ';
            cout<<endl;
            num++;
        }
    }
    return 0;
}
```

---

## 作者：DashZhanghanxu (赞：3)

# 解析
正常排序肯定超时，所以我们需要一点小技巧。

选择排序本质上就是将每个数字归位。

在代码中，我们可以判断数字 $i$ 是否在下标为 $i$ 的数组位置上，不是，则将数字 $i$ 与 $a[i]$ 交换位置。最后，当查询的排序次数就是当前的次数，就输出当前序列。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    vector<int>a(n+1);
    vector<int>p(n+1);
    for(int i=1;i<=n;++i){
        cin>>a[i];
        p[a[i]]=i;
    }
    vector<int>q(m);
    for(int i=0;i<m;++i){
        cin>>q[i];
    }
    int cur=0;
    int h=0;
    for(int i=1;i<n;++i){
        if(a[i]!=i){
            int c=p[i];
            swap(a[i],a[c]);
            swap(p[a[i]],p[a[c]]);
        }
        cur++;
        if(h<m&&cur==q[h]){
            for(int j=1;j<=n;++j){
                cout<<a[j];
                if(j<n){
                    cout<<" ";
                }
            }
            cout<<endl;
            h++;
        }
    }
    return 0;
}
```

---

## 作者：Aurora_春雪 (赞：2)

## 思路

### 65分写法

常规思路，由于不是正解不做过多赘述。
```cpp
#include<iostream>
using namespace std;
int a[100005],q[100005];
int main(){
	int n,m,stp=0,ii=0;//stp是交换次数，ii是q的循环变量 
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++)
	    scanf("%d",&a[i]);
	for(int i=0;i<m;i++)
		scanf("%d",&q[i]);
	//正常的选择排序 
	for(int i=0;i<n-1;i++){
		int minn=i;//找出a[i]到a[n-1]中最小元素的下标，默认为i本身 
        for(int j=i+1;j<n;j++){
            if(a[j]<a[minn])//达到交换条件 
            	minn=j;//保存交换下标 
        }
        swap(a[i],a[minn]);
        stp++;//交换次数++ 
        if(stp==q[ii]){//检查当前步数是否是询问的步数
            for(int k=0;k<n;k++)
                printf("%d ",a[k]);
        	ii++;
    		printf("\n");
    	}
    	if(ii==q[m-1]) return 0;
    }
    return 0;
}
```
[65分](https://www.luogu.com.cn/record/204135395)

---


经过十分钟的深思熟虑，我又去看了一眼题目，开始思考**为什么保证 A 是排列**。

而后，蒟蒻悟了！我们根本不需要对它进行完整的排列！

### 满分写法

由于 A 是排列，而在选择排序中，第 $i$ 次询问的目的是将**第 $i$ 小的元素（也就是数字 $i + 1$）放到第 $i$ 个位置**。因此，我们可以创建一个类似**桶**的数组，直接找到第 $i$ 小的元素并将它交换到其正确的位置！

而后，有了以下丑陋的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100005;
int a[MAXN],q[MAXN],pos[MAXN];
int main(){
	int n,m,stp=0,ii=0;
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		scanf("%d",&a[i]);
		//记录每个元素的位置 
		pos[a[i]]=i;
	}
	//读取询问数组q
	for(int i=0;i<m;i++)
		scanf("%d",&q[i]);
	//选择排序 
	for(int i=0;i<n-1;i++){
		//找到第i+1小的元素的位置
		int tar=pos[i+1];
		if(tar!=i){
			//交换元素 
			swap(a[i],a[tar]);
			//更新元素位置信息
			pos[a[i]]=i;
			pos[a[tar]]=tar;
		}
		stp++;
 		//检查当前步数是否是询问的步数 
		if(stp==q[ii]){
			for(int k=0;k<n;k++)
				printf("%d ",a[k]);
			printf("\n");
			ii++;
		}
		//如果已经处理完所有询问，提前结束
		if(ii==m) return 0;
	}
	return 0;//完结撒花 
}
```
[AC记录](https://www.luogu.com.cn/record/204139130)。

---

## 作者：canwen (赞：2)

注意到 $A$ 是一个排列，那么第 $y$ 次冒泡排序完后，$A_{1}\sim A_{y}$ 应该分别对应 $1 \sim y$。

那么遍历 $ i \gets  1 \sim  n-1 $，当 $A_{i} $ 不为 $i$ 的时候，我们需要找到 $i$ 所在的位置进行交换。

而找到这一操作可以读入的时候先预处理位置，在我的代码中数组 $wei$ 就是这样的功能。

所以模拟交换即可，复杂度是 $O(n)$ 的，足以通过此题。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n,s[N],m,wei[N];
bool f[N];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i) cin>>s[i],wei[s[i]]=i;
	for(int i=1;i<=m;i++){int x;cin>>x,f[x]=1;}
	for(int i=1;i<=n-1;i++){
		if(s[i]!=i){
			int id = wei[i]; 
			wei[s[i]] = id, wei[i] = i;
			swap(s[i],s[id]); 
		}
		if(f[i]){
			for(int j=1;j<=n;j++) cout<<s[j]<<" ";
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：jej333 (赞：1)

这题一眼看上去就会想用普通的思路解：

首先先输入，之后循环 $n-1$ 次，每次进行以下步骤判：
1. 判断是否该输出；
2. 寻找该交换的数的位置；
3. 如果该输出则输出排序后的序列。

附上 65 分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b[100001],c[11],d;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>a>>d;
	for(int i=1;i<=a;i++) cin>>b[i];
	for(int i=1;i<=d;i++) cin>>c[i];//输入
	for(int i=1;i<a;i++){
		bool s=0;
		for(int j=1;j<=d;j++){
			if(i==c[j]) s=1;
		}//判断是否该输出
		int w,v=0x3f3f3f3f;
		for(int j=i;j<=a;j++){
			if(b[j]<v){
				v=b[j];
				w=j;
			}//寻找应该交换的位置
		}
		if(w) swap(b[i],b[w]);//交换
		if(s){//如果该输出就输出
			for(int j=1;j<=a;j++) cout<<b[j]<<' ';
			cout<<'\n';
		}
	} 
	return 0;
}
```

可是，这样会 TLE ，所以得用桶来排序，思路如下：
1. 输入一个数时，桶里对应下标的元素为现在输入的次数，假设输入为 $x$ ，现在是第 $i$ 次循环，桶数组的名称为 $t$ ，则 $t[x]=i$ ；
2. 交换（如果不理解可以编一组样例测试一下）；
3. 查询，若该输出则输出。

附上 AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],t[100001],n,m,q[11],v=1;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		t[a[i]]=i;//输入一个数，对应的桶就赋值为i
	}
	for(int i=1;i<=m;i++) cin>>q[i];//输入
	for(int i=1;i<n;i++){
	    swap(a[i],a[t[i]]);//先交换
	    t[a[t[i]]]=t[i];
		t[i]=i;
		if(i==q[v]){//查询优化，因为数组输入从q[1]开始,之后是q[2]......q[m]，所以q[v]必定能在某一次循环与i相等
			v++;
			for(int j=1;j<=n;j++) cout<<a[j]<<' ';//输出
			cout<<'\n';
		}
	}
	return 0;
}
```

第一次写题解，求过 ^_^

---

## 作者：YBa2Cu3O7 (赞：1)

选择排序本身是个 $O(n^2)$ 的所以肯定不能直接模拟。

根据题目中的数据提示，输入一定是 $1\sim n$ 的排列，所以我们用一个数组把输入数据存起来的同时，用另一个数组记录每个元素的原始位置。这组双射可以帮助我们去掉选择排序中遍历查找最小值的过程，这是降低复杂度的核心。

接下来就是模拟，其中查找最小值的部分直接变成查映射表，注意选择排序的交换会改变映射表。

主要代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

void f(vector<int>& tr,vector<int>& nums,int n,int& hd){
    for (int i = 0; i < n; ++i) {
        int u = nums[hd];
        nums[hd] = hd+1;//第hd个位置上放的一定是hd+1
        nums[tr[hd+1]] = u;//交换
        tr[u] = tr[hd+1];//修改映射表
        hd++;
    }
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<int> nums(n);
    vector<int> tr(n+1,0);
    for(int i=0;i<n;++i){
        cin>>nums[i];
        tr[nums[i]]=i;
    }
    
    int hd=0;//表示已经完成排序的个数
    for(int i=0;i<m;++i){
        int v;
        cin>>v;
        f(tr,nums,v-hd,hd);
        for(int j=0;j<n;++j){
            cout<<nums[j]<<' ';
        }
        cout<<'\n';
    }

    return 0;
}
```


---

# **思考**

如果去掉题目中保证输入数据是 $1\sim n$ 的排列怎么办？

思路其实还是一样的，还是要构造一个双射，只是变得麻烦一些。

记输入的原始数组是 `nums`，这里我用 `vector<pair<int,int>>` 来记录每个数字在原始数组中的位置，其中的键值对是 `{nums[i],i}`。对其按键排序后，用 `unordered_map<int,int>` 来记录排序后每个数字的位置。这样就完成了双射的构造。

主要代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

void f(vector<pair<int,int>>& vp,vector<int>& nums,int n,int& hd,
        unordered_map<int,int>& ump){
    for (int i = 0; i < n; ++i) {
        //交换
        int u = nums[hd];
        nums[hd] = vp[hd].first;
        nums[vp[hd].second] = u;
        //修改映射表
        vp[ump[u]].second = vp[hd].second;
        hd++;
    }
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<int> nums(n);
    for(int i=0;i<n;++i){
        cin>>nums[i];
    }
    vector<pair<int,int>> vp(n);
    for(int i=0;i<n;++i){
        vp[i]={nums[i],i};
    }
    sort(vp.begin(),vp.end(),[](const pair<int,int>& p1,const pair<int,int>& p2){
        return p1.first<p2.first;
    });
    unordered_map<int,int> ump;
    for(int i=0;i<n;++i){
        ump[vp[i].first]=i;
    }
    int hd=0;
    for(int i=0;i<m;++i){
        int v;
        cin>>v;
        f(vp,nums,v-hd,hd,ump);
        for(int j=0;j<n;++j){
            cout<<nums[j]<<' ';
        }
        cout<<'\n';
    }

    return 0;
}
```
这个代码也能通过本题，没有TLE/MLE。

---

## 作者：linan04007 (赞：1)

### 误区分析
看到本题的题目，想必大家都会想到写一个选择排序，但是这显然是行不通的,因为普通选择排序的时间复杂度为 $O(n^2)$，而在题目的范围中，光是排序，循环次数最多更是达到了 $10,000,000,000$ 次，更何况还有输出，如果这样写一定会超时。
### 正确思路分析
本题的核心是实现选择排序，并根据给定的询问输出指定趟数排序后的序列。为了高效处理元素的交换和位置查找，使用一个额外的数组 $s$ 来记录每个元素在数组 $a$ 中的位置。在选择排序的每一趟中，找到当前应该处于该位置的元素并交换，同时更新位置数组 $s$。当当前趟数等于询问中的某一趟时，输出当前数组状态。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
// 数组 a 用于存储原始序列，题目中 n 最大为 10^5，所以数组大小设为 100005
int a[100005];
// 数组 q 用于存储询问，题目中 m 最大为 10，所以数组大小设为 11
int q[11];
// n 表示序列的长度，m 表示询问的数量
int m, n;
// 数组 s 用于记录每个元素在数组 a 中的位置，s[x] 表示元素 x 在数组 a 中的下标
int s[100005];

int main()
{
    // 从标准输入读取序列的长度 n 和询问的数量 m
    cin >> n >> m;

    // 读取原始序列，并记录每个元素的位置
    for (int i = 1; i <= n; i++)
    {
        // 读取第 i 个元素到数组 a 中
        cin >> a[i];
        // 记录元素 a[i] 在数组 a 中的位置为 i
        s[a[i]] = i;
    }

    // 读取询问序列
    for (int i = 1; i <= m; i++)
    {
        // 读取第 i 个询问到数组 q 中
        cin >> q[i];
    }

    // r 用于记录当前处理到第几个询问，初始化为 1
    int r = 1;
    // 进行 n - 1 趟选择排序
    for (int i = 1; i <= n; i++)
    {
        // 记录当前位置 i 的元素值
        int t = a[i];
        // 交换数组 a 中第 i 个位置的元素和第 s[i] 个位置的元素
        // s[i] 表示元素 i 在数组 a 中的当前位置
        swap(a[i], a[s[i]]);
        // 更新元素 t（原来 a[i] 的值）的位置为 s[i]
        s[t] = s[i];

        // 检查当前趟数 i 是否等于当前要处理的询问 q[r]
        if (i == q[r])
        {
            // 若相等，输出当前趟排序后的序列
            for (int j = 1; j <= n; j++)
            {
                // 输出数组 a 中第 j 个元素，并在元素间用空格分隔
                cout << a[j];
                if (j < n) cout << " ";
            }
            // 输出换行符
            cout << endl;
            // 处理下一个询问，r 加 1
            r++;
        }
    }
    return 0;
}
```

### 复杂度分析
- **时间复杂度**：代码主要的操作是选择排序的过程，外层循环执行 $n$ 次，每次循环内的交换和更新操作时间复杂度为 $O(1)$，同时处理询问的操作时间复杂度也为 $O(1)$。因此，整体时间复杂度为 $O(n)$。这里需要注意的是，虽然整体复杂度看似是 $O(n)$，但由于使用了位置数组 $s$ 来优化查找元素位置的过程，避免了传统选择排序中每次查找最小元素需要遍历剩余元素的 $O(n)$ 操作，所以实际效率较高。
- **空间复杂度**：使用了额外的数组 $s$ 来记录元素位置，数组大小为 $n$，因此空间复杂度为 $O(n)$。另外，还使用了常数级的额外变量，不影响整体空间复杂度。

### 代码解释
1. **输入处理**：首先读取序列长度 $n$ 和询问数量 `m`，然后读取原始序列并记录每个元素的位置，最后读取询问序列。
2. **选择排序过程**：通过外层循环进行 $n$ 趟排序，在每一趟中，找到当前应该处于该位置的元素并交换，同时更新位置数组 $s$ 。
3. **询问处理**：在每一趟排序结束后，检查当前趟数是否等于当前要处理的询问，如果相等，则输出当前排序后的序列，并将询问索引 $r$ 加 1 。
4. **输出结果**：根据询问的要求，依次输出每趟排序后的序列。

---

## 作者：yedalong (赞：1)

很水的一道题 ~~（一遍就过了）~~，但是时间复杂度好像不允许暴力哎。。。\
本人的做法是使用优先队列进行优化。

## Solution

由于是求 $i∼n$ 的最小值，因此想到使用优先队列维护。

每一次交换位置时重新向队列里加入当前 $i$ 位置上的值以及 $i∼n$ 的最小值所在的位置，并进行交换。

需要注意一个点，就是如果当前队头的位置是在 $i$ 之前，得弹出，毕竟是要找 $i∼n$ 之间的。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
};
bool operator<(node a,node b){
	return a.x>b.x;
}
int n,m,a[100005],q,now=1;
priority_queue<node> p;
int main(){
	cin>>n>>m;
	for(int i = 1;i<=n;i++) cin>>a[i],p.push({a[i],i});
	while(m--){
		cin>>q;
		for(int i = now;i<=q;i++){
			while(p.top().y<i) p.pop();
			node tmp=p.top();
			p.push({a[i],p.top().y}),a[p.top().y]=a[i];
			a[i]=tmp.x;
			p.pop();
		}	
		for(int i = 1;i<=n;i++) cout<<a[i]<<' ';
		cout<<'\n';
		now=q+1;
	}
	return 0;
}
```

---

## 作者：54188_you_Dad (赞：0)

# 前言

模拟选择排序的过程。

# 思路

题目要求每趟找出第 $i$ 小的元素，然后将这个元素与数组第 $i$ 个位置上的元素 $a_i$ 交换，在 $n−1$ 趟之后数组 $a$ 变为升序。再依次输出第 $q_i$ 趟之后的数组 $a$。

我们可以运行 $q_m$ 趟第 $i$ 趟的时候找出 $i$ 的位置 $b_i$，交换 $a_i,a_{b_i}$，当 $i=q_j$ 时输出数组 $a$。

# 代码

```
#include <bits/stdc++.h>
using namespace std;
//#define int long long
int a[100005];
int b[100005];
int q[15];
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[a[i]] = i;
	}
	for(int i=1;i<=m;i++) cin>>q[i];
	int l = 1;
	for(int i=1;i<=q[m];i++)
	{
		//模拟
		if(a[i]!=i)
		{
			int t = b[i];
			b[i] = i;
			b[a[i]] = t;
			swap(a[i],a[t]);
		}
		//输出判断
		if(i==q[l])
		{
			for(int i=1;i<=n;i++) cout<<a[i]<<" ";
			cout<<"\n";
		}
	}
	return 0;
}
```

---


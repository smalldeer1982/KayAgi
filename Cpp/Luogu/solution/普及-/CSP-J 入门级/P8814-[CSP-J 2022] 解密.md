# [CSP-J 2022] 解密

## 题目描述

给定一个正整数 $k$，有 $k$ 次询问，每次给定三个正整数 $n_i, e_i, d_i$，求两个正整数 $p_i, q_i$，使 $n_i = p_i \times q_i$、$e_i \times d_i = (p_i - 1)(q_i - 1) + 1$。


## 说明/提示

**【样例 \#2】**

见附件中的 `decode/decode2.in` 与 `decode/decode2.ans`。

**【样例 \#3】**

见附件中的 `decode/decode3.in` 与 `decode/decode3.ans`。

**【样例 \#4】**

见附件中的 `decode/decode4.in` 与 `decode/decode4.ans`。

**【数据范围】**

以下记 $m = n - e \times d + 2$。

保证对于 $100\%$ 的数据，$1 \leq k \leq {10}^5$，对于任意的 $1 \leq i \leq k$，$1 \leq n_i \leq {10}^{18}$，$1 \leq e_i \times d_i \leq {10}^{18}$
，$1 \leq m \leq {10}^9$。

| 测试点编号 | $k \leq$ | $n \leq$ | $m \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10^3$ | $10^3$ | $10^3$ | 保证有解 |
| $2$ | $10^3$ | $10^3$ | $10^3$ | 无 |
| $3$ | $10^3$ | $10^9$ | $6\times 10^4$ | 保证有解 |
| $4$ | $10^3$ | $10^9$ | $6\times 10^4$ | 无 |
| $5$ | $10^3$ | $10^9$ | $10^9$ | 保证有解 |
| $6$ | $10^3$ | $10^9$ | $10^9$ | 无 |
| $7$ | $10^5$ | $10^{18}$ | $10^9$ | 保证若有解则 $p=q$ |
| $8$ | $10^5$ | $10^{18}$ | $10^9$ | 保证有解 |
| $9$ | $10^5$ | $10^{18}$ | $10^9$ | 无 |
| $10$ | $10^5$ | $10^{18}$ | $10^9$ | 无 |


## 样例 #1

### 输入

```
10
770 77 5
633 1 211
545 1 499
683 3 227
858 3 257
723 37 13
572 26 11
867 17 17
829 3 263
528 4 109
```

### 输出

```
2 385
NO
NO
NO
11 78
3 241
2 286
NO
NO
6 88
```

# 题解

## 作者：SkyWave (赞：488)

# 前置知识

整式的加减乘除 —— 初一

# 思路

看到题目先下意识进行化简 $ed$：

$ed = (p-1)(q-1) + 1$

化简得：

$ed = pq - p - q + 1+ 1$

将 $n = pq$ 带入原式得：

$ed = n - p - q + 2$

整理原式得

$p + q = n - ed + 2$


插句闲话
------------


我们把目光聚焦到题面的数据范围一栏，看到这句话

”以下记 $m = n - ed + 2$。“

正好是化简后的 $p + q$。

我当时看到这句话就知道，我的解法是正确的！

话说回来
------------


现在已知

$$
    \begin{cases}
		p + q = n - ed + 2\\
        pq = n
    \end{cases}
$$

要求 $p$、$q$。

其中 $n,e,d$ 为常数。

如果我们能推出 $p - q$，那么问题就迎刃而解了。

初一党是不是熟悉了起来？

忘了？不要紧，我们来复习一下。

完全平方和：$(a + b)^2 = a^2 + 2ab + b^2$

完全平方差：$(a - b)^2 = a^2 - 2ab + b^2$

现在已知 $ab$，$a + b$，我们如何求出 $a - b$ 呢？

我们来把完全平方和减去完全平方差试试：

$(a + b)^2 - (a - b)^2 = (a^2 + 2ab + b^2) - (a^2 -2ab + b^2)$

等号右边化简得：

$(a + b)^2 - (a - b)^2 = a^2 + 2ab + b^2 - a^2 +2ab - b^2$

合并同类项得：

$(a + b)^2 - (a - b)^2 = 4ab$

挪一挪项得：

$(a + b)^2 - 4ab = (a - b)^2$

交换左右两边得：

$(a - b)^2 = (a + b)^2 - 4ab$

左边脱掉平方得：

$a - b = \pm \sqrt{(a + b)^2 - 4ab}$

已知 $ab$ 即 $pq$，$a + b$ 即 $p + q$，就能求出 $a-b$ 即 $p - q$ 了！

补充解释
------------

由于 $p$ 与 $q$ 的大小关系无关紧要——题目中只说了打印 $p$ 与 $q$ 两者中较大的再打印两者中较小的。$p$ 我们在这里先假设它为 $p$ 与 $q$ 两者中较大的数，$q$ 为 $p$ 与 $q$ 中的较小数，因此下文中 $p - q$ 没有正负号。


------------

将 $n = pq$，$n - e \times d + 2 = p + q$ 带入得：

$$
    \begin{cases}
		p + q = n - ed + 2\\
        p - q = \sqrt{(n - ed + 2)^2 - 4n}
    \end{cases}
$$

我们设上面一行为 1 式，下面一行为 2 式，我们将 1 式 + 2 式得到的 3 式为：

$2p = n - ed + 2 + \sqrt{(n - ed + 2)^2 - 4n}$

等式两边同除以2得：

$p = \frac{n - ed + 2 + \sqrt{(n - ed + 2)^2 - 4n}}{2}$

将 1 式做个小小的变动得：

$q = n - ed + 2 - p$

此时 $p$ 是已知的，$n - e \times d + 2$ 为常数，所以可以解出 $q$ 为：

$q = n - ed + 2 - \frac{n - ed + 2 + \sqrt{(n - ed + 2)^2 - 4n}}{2}$

这里可以化简得：

$q = \frac{n - e \times d + 2 -\sqrt{(n - e \times d + 2)^2 - 4n}}{2}$

最终得：

$$
    \begin{cases}
		p = \frac{n - ed + 2 + \sqrt{(n - ed + 2)^2 - 4n}}{2}\\
        q = \frac{n - ed + 2 -\sqrt{(n - ed + 2)^2 - 4n}}{2}
    \end{cases}
$$

再看到题目要求，$p$、$q$ 要求是正整数。因为我们知道，如果平方根不是正数，只可能是 0、正有理数、无理数（平方开不尽）、不在实数范围内的虚数（被开方数小于 0）。

0 好办，我们只需要算出 $p$ 和 $q$ 之后特判就可以了。对于小数和无理数，我们可以先用 long long 强制转换，舍弃小数点后带入题目给出的两个式子，检验解是否正确。对于虚数，函数 sqrt 的被开方数为负数的时候会返回 NaN，用 long long 储存 NaN 时值为 0，和我们处理 $P = 0$ 时思路一样。如果解符合上述条件，那么一定是整数，也就是符合题目要求的解。

那时间复杂度如何保证呢？加减乘除运算都是 $O(1)$ 的，sqrt 函数也是 $O(1)$ 级别的，故单次询问时间复杂度为 $O(1)$，总询问复杂度为 $O(k)$，最大运算量为 $10^5$，故能轻松通过此题。

思路部分完结撒花！

# 代码


```cpp
//
//  main.cpp
//  P8814 [CSP-J 2022] 解密（民间数据）
//
//  Created by SkyWave Sun on 2022/11/7.
//

#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

int main(int argc, const char * argv[]) {
    long long k;
    scanf("%lld",&k);
    while (k--) {
        long long n,e,d;
        scanf("%lld%lld%lld",&n,&e,&d);
        long long PsubQ = sqrt((n - e * d + 2) * (n - e * d + 2) - (n * 4));
        long long PaddQ = n - e * d + 2;
        long long P = (PsubQ + PaddQ) / 2;
        long long Q = PaddQ - P;
        if (P * Q == n && e * d == (P - 1) * (Q - 1) + 1 && P && Q) {
            printf("%lld %lld\n",min(P, Q),max(P, Q));
        }else {
            printf("NO\n");
        }
    }
    return 0;
}
```
完结撒花！

我是 SkyWave，这是我的第三篇题解，有不足之处请多多指出，有任何看不懂的地方欢迎留言或者私信！

# 更新日志：
（如有错误和不清楚的地方敬请指出，会立即更新）
## 一更
5 月 3 日下午 17:34 分

### 更新内容：

删除了“边上代码边讲”这句习惯性的废话。更改了 Q 的计算方式。将代码中的位移都替换成了除法。补充了对代码的解释便于读者更好理解。

### 补充说明：

事实上我一开始的 Q 就是通过 P + Q - P 算出的，只是因为想要验证题解中推导的部分有没有误所以将它改成用繁琐公式算，现在为了读者阅读方便已经改回。




---

## 作者：雨伞CKY (赞：155)

> 这是一篇视频题解。

![](bilibili:BV1iv4y1D7EE)

---

## 作者：Forever1507 (赞：40)

稍微爆拆一下，$e_i\times d_i=p_i\times q_i-p_i-q_i+2$。

拿 $n_i$ 减掉这个，$p_i+q_i=n-e_i\times d_i+2$。

哦对了为了方便记上面那坨为 $m_i$。

然后和与积都有，直接构造二次方程（用韦达定理）。

$x^2-m_i\times x+n_i=0$

判别式上求根公式，$x=\frac{m_i\pm \sqrt{m^2-4\times n_i}}{2}$

然后判一下根号里面是不是完全平方、是否为正数和是否能被 $2$ 整除即可。保证是否有解和解是否为正整数。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,n,d,e;
signed main(){
	ios::sync_with_stdio(0);
	cin>>k;
	while(k--){
		cin>>n>>d>>e;
		int m=n-d*e+2;
		int k=m*m-4*n;
		int kk=sqrt(k);
		if(kk*kk!=k){
			cout<<"NO\n";
			continue;
		}
		if((m+kk)%2==1||m<=kk){
			cout<<"NO\n";
			continue;
		}
		cout<<(m-kk)/2<<' '<<(m+kk)/2<<'\n';
	}
	return 0;
} 
```


---

## 作者：ShanCreeperPro (赞：40)

## P8814 [CSP-J 2022] 解密 題解

### 题意

给定：

$$
\left\{\begin{array}{l}
n=p q \\
ed=(p-1) (q-1)+1
\end{array}\right.
$$

已知 $n,e,d$，求 $p,q$。

### 解析 数学法

拆一下上面的式子，得：

$$
\left\{\begin{array}{l}
n = pq \\
n - ed + 2 = p + q
\end{array}\right.
$$

根据第一个式子，得到 $q = \dfrac{n}{p}$。

代入第二个式子：

$$ p^{2}-(n-ed+2) p+n=0 $$

因为 $n,d,e$ 已知，$a=1, b=(n - ed +2), c=n$，算出判别式：

$$ \Delta = b^2 - 4ac = (n - ed + 2) - 4n $$

代入算出 $p$ 的公式：

$$ p = \dfrac{n - ed + 2 ± \sqrt{\Delta} }{2}$$

直接计算即可。

### 代码 数论法

一定要细心。

```cpp
#include<bits/stdc++.h>

#define int long long
#define fore(i,x,n) for(int i=x;i<=n;i++)

const int MAXX=10005;
const int mod=1;

inline int __read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

inline void __write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) __write(x/10);
    putchar(x%10+'0');
}

inline void __writesp(int x){
    __write(x);
    putchar(' ');
}
int n,d,e;

inline void input(){
    n=__read(); d=__read(); e=__read();
}

inline void work(){
    int b=(-n-e*d+2),c=n;
    int d=b*b-4*c;
    if(d<0){ puts("NO"); return; }
    if(std::sqrt(d)*std::sqrt(d)!=d){ puts("NO"); return; }
    if(-b+std::sqrt(d)/2<0){ puts("NO"); return; }
    __writesp(std::min(-b+std::sqrt(d)/2,n/(-b+std::sqrt(d)/2)));
    __write(std::max(-b+std::sqrt(d)/2,n/(-b+std::sqrt(d)/2)));
}

signed main(){


    freopen("decode.in","r",stdin);
    freopen("decode.out","w",stdout);

    int T=__read();
    while(T--){
        input();
        work();
    }
}
```

### 解析 二分法

二分 $p$，然后算出 $q$，通过上面的式子判断答案是否正确。

如果 $pq<n$，说明小了，往右找，反之。

### 代码 二分法

注意二分边界。

```cpp
#include<bits/stdc++.h>

#define int long long
#define fore(i,x,n) for(int i=x;i<=n;i++)

const int MAXX=10005;
const int mod=1;

inline int __read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

inline void __write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) __write(x/10);
    putchar(x%10+'0');
}

inline void __writesp(int x){
    __write(x);
    putchar(' ');
}

int n,e,d;

inline void input(){
    n=__read(); d=__read();
    e=__read();
}

inline void work(){
    int d=n-e*d+2;
    int l=1,r=d/2;
    while(l<=r){
        int mid=l+((r-l)/2); 
        // 防止 mid 爆 long long
        if(mid*(d-mid)<n) l=mid+1;
        else r=mid-1;
    }
    if(l*(d-l)!=n) puts("NO");
    else{ __writesp(l); __write(d-l); }
}

signed main(){

    freopen("decode.in","r",stdin);
    freopen("decode.out","w",stdout);

    input();
    work();

}

```

---

## 作者：mark0575 (赞：34)

### 题目思路：

其实这道题可以用[一元二次方程](https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B/7231190)来解，可是本蒟蒻不会呀Q^Q。那只能讲一讲另一种方法。

![](https://cdn.luogu.com.cn/upload/image_hosting/rau5w1pg.png)

上图是一个 $q\times p$ 的矩阵。其中，$(q-1)\times (p-1)+1$(也就是 $e\times d$ ) 的部分被标黄，而其余未被标黄的部分刚好 $q+p-2$，既然知道了 $q+p$，我们可以去二分 $q$，找出 $q\times p$ 最接近 $n$ 的一组，看看与 $n$ 是否相等。如果相等就输出 $q$ 和 $p$。否则就输出 $\texttt{NO}$。

### AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int k;
int main()
{
	scanf("%d",&k);
	for(int i=1;i<=k;i++)
	{
		long long n,d,e;
		scanf("%lld %lld %lld",&n,&d,&e);
		long long s=n-d*e+2;
		long long r=(n-d*e+2)/2,l=1;//因为p<=q,所以我们可以只二分左部分的区间
		while(l<r)
		{
			int mid=(l+r)/2;
			if(mid*(s-mid)>=n)
			{
				r=mid;
			}
			else
			{
				l=mid+1;
			}
		}
		if(l*(s-l)==n)
		{
			printf("%lld %lld\n",l,(s-l));
		}
		else
		{
			printf("NO\n");
		}
	}
	return 0;
}

```

[考场代码](https://www.luogu.com.cn/paste/6y09t35r)


---

## 作者：Double_Light (赞：28)

# 题目大意

共 $k$ 组数据，对于每组数据，已知三个数 $n,e,d$，求出是否存在正整数 $p,q$ 满足

$$\begin{cases}
  n=pq \\
  ed=(p-1)(q-1)+1\\
\end{cases}$$

数据范围：$1≤k≤10^{5},1≤n≤10^{18},1≤ed≤10^{18},1≤n-ed+2≤10^{9}$。

听说有人用了二分AC，但本蒟蒻提供一种公式推导的算法。

# 推导过程

首先我们需要证明 $(a-c)(b-c)=ab-ac-cb+c^2$。

原式：$(a-c)(b-c)$

第一次应用乘法分配律：$a(b-c)-c(b-c)$

第二次应用乘法分配律：$(ab-ac)-(cb-c^2)$

脱括号：$ab-ac-cb+c^2$

所以，$(a-c)(b-c)=ab-ac-cb+c^2$。

又所以，$ed=(p-1)(q-1)+1$ 即可变为 $ed=pq-p-q+2$。

又因为 $n=pq$，所以式子就可以变形为 $ed=n-p-q+2$，进而变为

$$q+p=n-ed+2$$

此时我们得到

$$\begin{cases}
  pq=n \\
  q+p=n-ed+2\\
\end{cases}$$

我们知道了 $p,q$ 两数之和与两数之积，即可求出两数的值。具体方法如下：

因为 $q+p=n-ed+2$,

所以 $q$ 为两数之和 $n-ed+2$ 与 $p$ 之差，

又所以 $pq=n$ 能变为 $p[(n-ed+2)-p]=n$，

利用乘法分配律可知 $-p^2+p(n-ed+2)=n$，

变为 $-p^2+p(n-ed+2)-n=0$。

这不就是一元二次方程吗？

利用一元二次方程求解公式 $x=\displaystyle\frac{-b \pm \sqrt{b^2-4ac}}{2a}$，

得出解为 $\displaystyle\frac{-(n-ed+2) \pm \sqrt{(n-ed+2)^2-4n}}{-2}$。

若 $(n-ed+2)^2-4n$ 为负数，则 $p$ 与 $q$ 均为虚数，输出 ```NO```。

而其中，小的解为 $p$，即 $\displaystyle\frac{-(n-ed+2) - \sqrt{(n-ed+2)^2-4n}}{-2}$，

大的解为 $q$，即 $\displaystyle\frac{-(n-ed+2) + \sqrt{(n-ed+2)^2-4n}}{-2}$。

若这样的两个解均为正整数，则两个解一个为 $p$，另一个为 $q$，输出它们，否则输出 ```NO``` 即可。

# AC代码

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
long long n,d,e,t;//int 会爆掉
int main(){
	scanf("%d",&t);
	while(t--){//多组数据
		scanf("%lld%lld%lld",&n,&d,&e);
		long long delta=(n-e*d+2)*(n-e*d+2)-4*n;
		if(delta<0){//特判解为虚数的情况
			printf("NO\n");
			continue;
		}
		long long p=1.0*((n-e*d+2)-sqrt(delta))/2,q=1.0*((n-e*d+2)+sqrt(delta))/2;//注意要乘上1.0
		if(p>0&&q>0&&p*q==n&&e*d==(p-1)*(q-1)+1)printf("%lld %lld\n",p,q);//由于精度原因，需要再次判断题目条件
		else printf("NO\n");
	}
	return 0;
}
```

  
  $$\mathbb{---END---} $$

---

## 作者：liangbob (赞：26)

### P8814 题解

#### 思路分析

这道题首先要知道[和积原理](https://resting.blog.luogu.org/he-ji-yuan-li-jiang-xie)。

然后，我们开始推式子。

$$\begin{aligned}e_i \times d_i & = (p_i-1)(q_i-1)+1 \\ & = p_i \times q_i-p_i-q_i + 1+1 \\ & = n_i - (p_i+q_i) + 2\end{aligned}$$

移项可得 $p_i + q_i = n_i - e_i \times d_i + 2$，即 $p_i + q_i$ 一定。根据和积原理，$p_i+q_i$ 满足单调性。即可以使用二分查找枚举 $p_i$ 进行计算。

注意：因为要求 $p_i \leq q_i$ ，所以将 $p_i$ 枚举到 $\left\lfloor\\\dfrac{p_i+q_i}{2}\right\rfloor$ 即可。

#### 代码

```cpp
#include <iostream>
#include <cmath>
#define ll long long
using namespace std;

ll ef(ll l, ll r, ll n, ll m) //二分 
{
	while(l <= r)
	{
		ll mid = ((l + r) >> 1);
		ll cj = mid * (m - mid);//乘积
		if(cj == n)
		{
			return mid;
		}
		else
		{
			if(cj < n)//小于往大的枚举
			{
				l = mid + 1;
			}
			else // 大于往小的枚举
			{
				r = mid - 1;
			}
		}
	}
	return -1;//无解
}

int main()
{
	ll k;
	cin >> k;
	while(k--)
	{
		ll n, e, d;
		cin >> n >> e >> d;
		ll m = n - e * d + 2;//p+q的和
		ll q = ceil(m / 2);//p的枚举上限
		ll x = ef(1ll, q, n, m);
		if(x != -1) cout << x << " " << m - x << endl;
		else cout << "NO" << endl;
	}
	return 0;
}
```



---


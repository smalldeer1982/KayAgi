# [CSP-S2019] 格雷码

## 题目描述

通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。

格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。

所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。

$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：
1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。
2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。
3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。

综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。

按该算法，2 位格雷码可以这样推出：

1. 已知 1 位格雷码为 0，1。
2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。

同理，3 位格雷码可以这样推出：

1. 已知 2 位格雷码为：00，01，11，10。
2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。

现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。


## 说明/提示

【样例 1 解释】

2 位格雷码为：00，01，11，10，编号从 0∼3，因此 3 号串是 10。

【样例 2 解释】

3 位格雷码为：000，001，011，010，110，111，101，100，编号从 0∼7，因此 5 号串是 111。

【数据范围】

对于 $50\%$ 的数据：$n \leq 10$

对于 $80\%$ 的数据：$k \leq 5 \times 10^6$

对于 $95\%$ 的数据：$k \leq 2^{63} - 1$

对于 $100\%$ 的数据：$1 \leq n \leq 64$, $0 \leq k \lt 2^n$

## 样例 #1

### 输入

```
2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
3 5```

### 输出

```
111```

## 样例 #3

### 输入

```
44 1145141919810```

### 输出

```
00011000111111010000001001001000000001100011```

# 题解

## 作者：「已注销」 (赞：934)

考虑答案的每一位

第`0`位为`011001100110...`

第`1`位为`0011110000111100...`

发现第`i`位即$k\oplus \lfloor\frac k2\rfloor$的第`i`位


```cpp
#include<iostream>
int n;
unsigned long long k;
int main(){
   	std::cin>>n>>k;
    k^=k>>1;
    while(~--n)std::cout<<(k>>n&1);
}
```

---

## 作者：lrj124 (赞：17)

day1 爆炸了，水一发题解。。

n 位雷格码会由 $n-1$ 位的雷格码构成

前半段由每个 $n-1$ 位的雷格码按正序前面加 $0$ 构成，后半段由每个 $n-1$ 位的雷格码按倒序前面加 $1$ 构成

所以 $n$ 位的雷格码总个数有 $2^n$ 个

若所求的第 $k$ 个在前半段，那么它的答案就是 `0` 加上 `n-1`位雷格码的第 $k$ 位的答案

否则，后半段会是倒序，所以答案是 `1` 加上 `n-1`位雷格码的第 $n-k$ 位的答案

注意到 $2^{64}$ 会溢出，我就用 `python` 算了一下，特判掉了（其实可以直接 `ull n = -1;`）。

```cpp
#include <cstdio>
#include <vector>
using namespace std;
typedef unsigned long long ull;
vector<int> ans;
inline void solve(ull n,ull k) {
	if (n == 1) {
		ans.push_back(k ? 1 : 0);
		return;
	}
	if (k > n/2) {
		ans.push_back(1);
		solve(n/2,n-k);
	} else {
		ans.push_back(0);
		solve(n/2,k);
	}
}
int main() {
//	freopen("code.in","r",stdin);
//	freopen("code.out","w",stdout);
	ull n,k;
	scanf("%llu%llu",&n,&k);
	if (n == 64) n = 18446744073709551615ull;
	else {
		ull tmp = 1;
		for (ull i = n;i--;tmp *= 2);
		n = tmp-1;
	}
	solve(n,k);
	for (size_t i = 0;i < ans.size();i++) printf("%d",ans[i]);
	return 0;
}
```

---

## 作者：下划线__ (赞：17)

看到这数据规模，加上这是Day1 T1,第一反应就是找规律~~当然大佬们已经用5行代码秒切了~~。但直接从十进制上似乎很难找到规律，于是考虑按位找规律。

[不过这里有一份十进制规律的代码](https://www.luogu.org/paste/h588dn5q)

### 读题开始

题目中已经给出了n为3时的整个排列，把排列和k一一对应，得到如下结果


```
code: 000 001 011 010 110 111 101 100
   k: 000 001 010 011 100 101 110 111
```


嗯……似乎看不出什么对应关系，但如果我们一位一位来，似乎可以找到一些有联系的地方。

例如，第1位(编号从右往左，从0开始)的对应如下

```
code: 0 0 1 1 1 1 0 0
   k: 0 0 1 1 0 0 1 1
```


似乎0的个数和1的个数有一些对应关系？
然而并没有卵用，按着这个思路想了半天还是没有结果，于是我推了一下N为4时的排列和对应关系：

```
code: 0000 0001 0011 0010 0110 0111 0101 0100 1000 1001 1011 1010 1110 1111 1101 1100
   k: 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
```


再来按位找一下对应关系似乎就可以了，不难发现，若 $k >= 2$ ，则第k个格雷码的第 $1$位是 $k - 2$ 的第 $2$ 位取反的结果，否则格雷码的第 $1$ 位为0。

但是，这个 $k - 2$ 中的 $2$ 是哪来的呢？可以猜测是 $2^i$ 。于是验证一下第2位(即从右往左第3个bit)，发现猜想成立。

于是得到如下结论~~完全没有证明的结论~~：

### 若 $k >= 2^i$，则第 $k$ 个格雷码的第i位是 $k - 2^i$ 的第 $i + 1$ 位(编号从右往左，从0开始)取反的结果，否则格雷码的第 $i$ 位为0。

那最高位怎么处理呢？稍微观察一下可以发现，在最高位上，格雷码和k相等，所以做一下特殊处理就ok了。

**当然还要注意用ULL，不然拿不到满分。**

emmm说了这么多，似乎已经有大佬发过递归版了？那我发一个非递归的吧，AC代码如下：

```cpp
#include <iostream>
typedef unsigned long long ULL;
using namespace std;
ULL N,K;
int main()
{
	cin >> N >> K;
	cout << bool(K & (1LL << N - 1));
	for (int i = 2;i <= N;++i)
	{
		if (K >= (1LL << (N - i)))
			cout << bool(!((K - (1LL << (N - i))) & (1LL << (N - i + 1))));
		else
			cout << 0;
	}
}
```





---

## 作者：ikunTLE (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P5657)

### 思路

格雷码最大的特点是，对于 $x$ 与 $x+1$ 的二进制最多有一位不同。对比格雷码和二进制，对于第 $i$ 为格雷码为 $1$ 的情况，仅当二进制下第 $i$ 位与第 $i+1$ 位不同时。

这种运算可以用看作是异或运算，故 $k$ 的格雷码是 $k\oplus\lfloor\frac{k}{2}\rfloor$。最后转成二进制输出即可。

**注意事项**

- $2^{64}$ 炸了 `long long`，需使用 `unsigned long long`。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n;
	scanf("%d",&n);
	unsigned long long k;//注意数据范围
	scanf("%llu",&k);
	k^=k>>1;//转为格雷码
	while(n){
		printf("%llu",(k>>(n-1))&1);//输出二进制
		--n;//转到下一位
	}
	printf("\n");
	return 0;
}
```

---

## 作者：Arvin2018 (赞：14)

考场上被数据坑了一个小时的我。。。

本题可以直接模拟（找规律）。

```
1位：
1
0

2位：
00
01
11
10

3位：
000
001
011
010
110
111
101
100

4位：
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000

```
让我们竖过来康康——

可以发现，最后一位总是$0, 1, 1, 0$四个一组循环

倒数第二位是$0, 0, 1, 1, 1, 1, 0, 0, $循环

倒数第三位是$0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0$循环

以此类推，倒数第n位就是 $2^{n-1}$ 个 0  ,  $2^{n-1}$ 个 1  ,  $2^{n-1}$ 个 1  ,  $2^{n-1}$ 个 0 循环

然后就可以：

```
int num[4] = {0, 1, 1, 0};
```

**所以第k个数在第i位上就是num$[(k / $  $2^{n-1}$   $ $)$ $%4$ $ $]$**

然后代码就出来辣

下面奉上我丑陋的code：

```
#include <bits/stdc++.h>
#define re register
using namespace std;

int num[4] = {0, 1, 1, 0};

int main(){
	unsigned long long n, k;
	cin >> n >> k;//输入不说
	for(re unsigned long long i = n-1; i > 0; i--){
		cout << num[(k/((unsigned long long)(1)<<i))%4];//由于我是从n-1开始循环，所以在计算下标时不需要-1
        //1<<i相当于pow(2, i)
        //位运算时1必须要强制转换类型，要不然拿不到全分（我一开始code3.ans不一致就是因为没有强制转换花了半个小时
	}
	cout << num[k%4];//最后要单独输出，否则会出现inf
	return 0;
}

```

~~~
CSP2019 rp++
~~~

---

## 作者：Zskioaert1106 (赞：6)

题目传送门：[P5657 [CSP-S2019] 格雷码](https://www.luogu.com.cn/problem/P5657)

本题可以用于练习分治。

### 做题

我们用 $n$ 表示当前生成格雷码的位数为 $2^n$，$k$ 表示要生成的是这 $2^n$ 个格雷码的第 $k$ 个。则如果 $k$ 属于前一半即 $k < \dfrac{2^n}{2}$，则该位输出 $0$，否则该位输出 $1$。

那后一半的位怎么求呢？题目给出，对于后一半的格雷码是逆序排列的。所以如果当前 $k$ 是 $2^n$ 的后一半则分治时将它变到对称的前一半去，可以解决逆序的问题。

也就是，对于长度为 $2^n$ 的第 $k$ 种格雷码函数 $f(n,k)$：

- （如果 $n=0$，返回）

- 如果 $k < 2^{n-1}$，则输出 $0$，并分治 $f(n-1,k)$；

- 否则 $k$ 在后一半，输出 $1$ 并分治 $f(n-1,2^n - k)$。

### 代码

记得开合适的类型。

```cpp
#include<iostream>
using namespace std;
unsigned long long n,k;
void fz(__int128_t n,__int128_t k){
	if(n==0)return ;
	if(k<(__int128_t(1)<<n-1)){
		cout<<0;
		fz(n-1,k);
	}
	else{
		cout<<1;
		fz(n-1,(__int128_t(1)<<n)-k-1);
	}
}
int main(){
	cin>>n>>k;
	fz(n,k);
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/195949953)。

---

## 作者：youngk (赞：6)

作为一名在学数字逻辑的大学生，看到你们这么这些找规律的，递归的真的太秀了，我提供一种我们实际人脑推格雷码比较使用的方法。
首先我们先把k变成二进制数。

![](https://cdn.luogu.com.cn/upload/image_hosting/hx4qzjw9.png)

所以我们就可以直接模拟就行了，k的位数不够的用0补齐就好了，ull不要忘，因为最高一定是1，所以我们初始化flag为0就是复制最高位。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<set>
#define _USE_MATH_DEFINES
#include<math.h>
#include<queue>
#include<vector>
#include<limits.h>
#include<functional>
#include<stack>
typedef long long ll;
#pragma GCC optimize(2)
using namespace std;
unsigned long long n, k, flag;
stack<unsigned long long> s;
signed main()
{
	cin >> n >> k;
	while (k)
	{
		s.push(k & 1);
		k >>= 1;
	}
	for (int i = s.size() + 1; i <= n; i++)
	{
		putchar('0');
	}
	while (s.size())
	{
		unsigned long long now = s.top();
		s.pop();
		if (now != flag)
			putchar('1');
		else
			putchar('0');
		flag = now;
	}
	return 0;
}

```


---

## 作者：引领天下 (赞：4)

唯一可做题？

考场上花了 0.5h 写完。

但是一看 $n\le64$，而众所周知这个 $2^{64}$ 是爆 long long 的。

于是很自然的想到了 ull。

但计算过程中我们发现 `1ll<<64` 这个东西照样是爆 long long 的，于是我们想办法把他压到 $2^{63}$。

思路：

分治，设当前是 $n$ 位格雷码中的第 $k$ 个，则当 $k>\frac{2^{n}}{2}$ 的时候需要将 $k$ 转为$2^{n}-k-1$，否则保留不动。

由于 $2^{n}$ 会爆 long long，所以我们只能将 $k$ 换个表示方式：$2^{n-1}-(k-(2^{n-1}))-1$。

于是代码就出来了：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
unsigned long long k;
string a[5]={"0","1"};
string dfs(int nn,unsigned long long nk){
    if(nn==1)return a[nk];
    string ans;
    if(nk>=(1ll<<(nn-1)))ans='1'+dfs(nn-1,(1ll<<(nn-1))-(nk-(1ll<<(nn-1)))-1);//后半部分
    else ans='0'+dfs(nn-1,nk);//前半部分
    //依题意生成第nk个nn位格雷码，返回
    return ans;
}
int main(){
    cin>>n>>k;
    cout<<dfs(n,k);
}
```

---

## 作者：sjh0626 (赞：3)

## 思路分析
首先我们可以知道，$k$ 的格雷码就是 $k \oplus \lfloor \frac{k}{2} \rfloor$。

详细证明可见：[OI Wiki](https://oi-wiki.org/misc/gray-code/)。

然后一个二进制数 $k$ 的第 $n$ 位（下标从 $0$ 开始）为 $\lfloor \frac{k}{2^n}\rfloor \bmod 2$
，接下来我们可以开始打代码了，注意，要开 `unsigend long long`。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
int n;
unsigned long long k; 
int main(){
	cin>>n>>k;
	k^=k>>1;
	while(n){cout<<((k>>(n-1))&1);--n;}
	sjh0626s code;
}
```

---

## 作者：ix35 (赞：3)

我的解法：

设$solve(p,q)$表示求第$q$个$p$位格雷码。

1. $p=1$，则结果与$q$相等（$q=1$则结果为$1$，$q=0$则结果为$0$）；
2. $p>1,\ \ q< (1<<(p-1))$，则最高位为$0$，递归$solve(p-1,q)$；
3. $p>1,\ \ q\ge (1<<(p-1))$，则最高位为$1$，同时后面要逆过来，按照倒过来的顺序，可以推得后面的位是$solve(p-1,(1<<p)-1-q)$。

于是做完了。

注意ull的问题，特别当心$(1<<64)-1$这种事很危险，所以我拆成了$1<<63+(1<<63-1)$。

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int MAXN=75;
ull n,k;
int ans[MAXN];
void solve (ull p,ull q) {
	if (p==1) {ans[p]=q;return;}
	if (q<(1ull<<(p-1))) {
		ans[p]=0;
		solve(p-1,q);
	} else {
		ans[p]=1;
		solve(p-1,(1ull<<(p-1))+((1ull<<(p-1))-1)-q);
	}
	return;
}
int main () {
	freopen("code.in","r",stdin);
	freopen("code.out","w",stdout);
	cin >> n >> k;
	solve(n,k);
	for (int i=n;i>=1;i--) {cout << ans[i];}
	cout << endl;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

#### [题目传送门](https://www.luogu.com.cn/problem/P5657)

---
### 题目大意：
根据格雷码的算法，请生成一个二进制格雷码串。

---
### 解题思路：
格雷码这道题，不仅在编程题中出现过，而且在今年的第一轮考试的单项选择题中也出现过。

那么到底这道题要怎么做呢？

首先，我先从别处找来了前四位格雷码的数据。
```LaTeX
1位：
1
0

2位：
00
01
11
10

3位：
000
001
011
010
110
111
101
100

4位：
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000

······
```
这样就可以发现几个规律：

- 最后一位一定是以 $0,1,1,0$ 的规律出现。
- 倒数第二位是以 $0,0,1,1,1,1,0,0$ 的规律出现。

那么就可以发现第一位是一个零和两个一再加一个零。

第二位是两个零和四个一再加两个零。

以此类推，倒数第 $x$ 位就是 $2^{n - 1}$ 个零，加上两个 $2 ^ {n - 1}$个一，最后再加上 $2^{n - 1}$ 个零，就结束了。

然后就有了
```cpp
int a[4] = {0, 1, 1, 0};
```
那么代码就可以推出来了。

---
### code：
```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;

ull a[4] = {0, 1, 1, 0}, n, k;

int main() {
	cin >> n >> k;
	for (ull i = n - 1; i > 0; i--) cout << a[(k / ((ull)(1) << i)) % 4];
	cout << a[k % 4];
	return 0; // 喜欢就点个赞吧！！！
}
```

---

## 作者：Alarm5854 (赞：2)

哎呀，普及组后面两题炸了，这两题洛谷上评测为30和50，教练那里测是40和45，反正普及一等有点危险。闲来无事，发一道提高组D1T1的题解。

首先，我们可以找一个规律，如图(在$n=4$的情况下)  
![](https://cdn.luogu.com.cn/upload/image_hosting/wku175zn.png)  
乍一看，没什么规律，但是，仔细看，假如$k=11(1011_2)$，则如图  
![](https://cdn.luogu.com.cn/upload/image_hosting/5puv157h.png)  
会发现$12(1100_2)\ xor\ 3(0011_2)\ xor\ 1(0001_2)=14(1110_2)$，其中，$12$可表示为$3*2^2$，$3$可表示为$3*2^0$，而$1$可表示为$3*\lfloor2^{-1}\rfloor$。而$11$恰好为$2^3+2^1+2^0$，所以这道题目可以这样做：先从第$n$位开始，一直到第$2$位(从前往后)循环，如果第$i$位为$1$，则答案就异或上$3*2^{i-1}$。循环完之后，如果这个数是奇数，那么再异或上1(减1)。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
#define int unsigned long long//可恶的€€£，竟然卡你ull!
using namespace std;
int n,k,ans;
signed main(){
	scanf("%llu%llu",&n,&k);
	for(int i=n;i>1;--i)
		if(k&(1ull<<i-1))//注意是i-1而不是i
			ans^=3ull<<i-2;//同上
	if(k&1ull) ans^=1ull;
	for(int i=n;i;--i)
		printf("%llu",(ans&(1ull<<i-1))>>i-1);//按照二进制输出
	return 0;
}
```

---

## 作者：sherry_lover (赞：1)

# P5657 [CSP-S2019] 格雷码 题解

[题目传送门](https://www.luogu.com.cn/problem/P5657)

## 思路

格雷码的另一种表述形式（找规律可得，或见[这里](https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81)）：

先将 $k$ 拆成 $n$ 位的二进制数，然后从右到左，以 $0$ 到 $n-1$ 编号。

然后根据公式 $G_i = B_i \oplus B_{i+1}$ 可以得出 $k$ 的 $n$ 位格雷码，其中 $G$ 为 $k$ 的格雷码，$B$ 为 $k$ 的二进制表示（由于 $k$ 的二进制位只有 $n$ 位，所以 $B_n$ 默认为 $0$），$0 \le i \le n-1$。

例：$n=2,k=3$ 时即 $k = (11)_2$ 时，$B_0 = 1,B_1= 1$。此时 $G_0 = B_1 \oplus B_0 = 1 \oplus 1 = 0$，$G_1 = B_1 \oplus B_2 = 1 \oplus 0 = 1$，所以 $G = (10)_2$。注意这里 $G$ 的编号也是从右往左排的。

由于 $1\le n \le 64$，所以 $k$ 要开 `unsigned long long` 或者 `__int128`。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
unsigned long long k;
vector<int> a;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	while(k)
	{
		a.push_back(k%2);
		k /= 2;
	}
	while(a.size() < n+1) a.push_back(0);
	for(int i = n;i >= 1;i--) cout << (a[i]^a[i-1]);
	return 0;
}
```

---

## 作者：Jayfeather2012 (赞：1)

一道挺有思维含量的橙题。
## 题目大意
按照格雷码的生成方式，输出 $n$ 位格雷码的第 $k$ 号二进制串。（从 $0$ 开始编号）
## 思路
填完第 $k$ 个 $n$ 位格雷码的第 $1$ 位后，把它转化成某一个 $n-1$ 位格雷码继续填这个 $n-1$ 位格雷码的第 $1$ 位，以此类推。

如何确定转化成第几个 $n-1$ 位格雷码：

当 $k<2^{n-1}$，因为这个 $n$ 位格雷码的前 $2^{n-1}$ 个二进制串的后 $n-1$ 位是由 $n-1$ 位格雷码正序排列而成的，所以 $k$ 保持不变。

当 $k\ge2^{n-1}$，因为这个 $n$ 位格雷码的后 $2^{n-1}$ 个二进制串的后 $n-1$ 位是由 $n-1$ 位格雷码逆序排列而成的，所以 $k$ 要先减去 $2^{n-1}$，变成 $n-1$ 位格雷码，再翻转才能保证是逆序的，即 $2^{n-1}-(k-2^{n-1})-1$。

细节看简短的代码吧！
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
unsigned long long k,x=1;//x表示为2^(n-1)
int n;
int main(){
	cin>>n>>k;
	for(int i=1;i<n;i++)x*=2;//x初始化为2^(n-1)
	while(n--){
		if(k<x)cout<<0;//前2^(n-1)个二进制串的第一位是0
		else{
			cout<<1;//后2^(n-1)个二进制串的第一位是1
			k=x*2-1-k;//变换k
		}
		x/=2;//每当n-1，x就要除2才能才能保证是2^(n-1)
	}
  	return 0;
}
```

---

## 作者：yuxinrui0618 (赞：1)

# 题解：P5657 [CSP-S2019] 格雷码
## 1. 题目大意
- 求出生成的 $n$ 位格雷码中的 $k$ 号二进制串。

## 2. 思路
- 经过列举，可以发现最后一位是 $0, 1 , 1 , 0$ 循环，倒数第二位是 $0 , 0 , 1 , 1 , 1 , 1 , 0 , 0$ 循环，以此类推；
- 可以得出，倒数第 $n$ 位是 $2 ^ {n-1}$ 个 0，$2 ^ {n-1}$ 个 1，$2 ^ {n-1}$ 个 0，$2 ^ {n-1}$ 个 1 循环的；
- 所以，若 $(k \div 2 ^ {n-1}) \bmod 4 $ 为 1 或 3 则为 0，否则为 1。

## 3. 代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned long long n,k;
	cin>>n>>k;
	for (int i=n-1;i>0;i--)
	{
		if ((k/((unsigned long long)(1)<<i))%4==0 || (k/((unsigned long long)(1)<<i))%4==3)
			cout<<0;
		else cout<<1;
	}
	if (k%4==0 || k%4==3)
		cout<<0;
	else cout<<1;
    return 0;
}
```
别忘了开 **ULL**！

## 4. 总结
谢谢观赏！ 
若有不完善的地方还请各位大佬指出！

---

## 作者：_H17_ (赞：1)

## 题目分析

既然需要按位求解，不妨使用递归算法，来分别求解每一位。

假设 $(n,k)$ 表示 $n$ 位的第 $k$ 个格雷码。

当 $k<2^{n-1}$ 时，$(n,k)=\texttt{0}+(n-1,k)$（因为前半部分没改变顺序）。

否则，$(n,k)=\texttt{1}+(n-1,2^n-k-1)$（因为后半部分完全颠倒，就是总共的去掉现在的）。

$n=1$ 时，就看 $k$ 就行了。

时间复杂度 $O(n)$ 也是 $O(\log k)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int unsigned long long 
using namespace std;
int n,k;
int qp(int b){
    int ret=1,a=1;
    while(b){
        if(b&1)
            ret<<=a;//ret*=2^a
        b>>=1,a<<=1;//a->2a,b->b/2
    }
    return ret;
}
string get_gray(int n,int k){
    if(n==1){
        if(k)
            return"1";
        else
            return"0";
    }
    int _2pow=qp(n-1);
    if(k<_2pow)
        return(string)("0")+get_gray(n-1,k);
    else
        return(string)("1")+get_gray(n-1,(_2pow<<1)-k-1);
}
signed main(){
    cin>>n>>k;
    cout<<get_gray(n,k);
    return 0;
}
```

---

## 作者：wanghonghui123 (赞：1)

## 思路

我们知道：$ G(k) = k \oplus \left( \frac{k}{2} \right) $，用位运算表示就是 `k^(k>>1)`。

- 我们可以先求出格雷码码值。

- 接着，我们可以把这个格雷码码值转化成二进制，并用 vector 数组存储。

- 由于是从最低位开始的，所以可以把 vector 数组反转或逆序输出即可。

注意：

- 由于数据很大，所以要开 `unsigned long long`。

- 为了长度为 $n$，即使高位时 $0$，也不要把需要前导零给去掉了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
vector<int> v;
int main(){
	int n;
	cin>>n;
	ULL k;
	cin>>k;
	ULL t = k^(k>>1);
	for(int i=0;i<n;i++){
		v.push_back((t&1)?1:0);
		t>>=1;
	}
	for(int i=v.size()-1;i>=0;i--){
		cout<<v[i];
	}
	return 0;
}
```

---


# [CSP-S 2023] 密码锁

## 题目描述

小 Y 有一把五个拨圈的密码锁。如图所示，每个拨圈上是从 $0$ 到 $9$ 的数字。每个拨圈都是从 $0$ 到 $9$ 的循环，即 $9$ 拨动一个位置后可以变成 $0$ 或 $8$，

![](https://cdn.luogu.com.cn/upload/image_hosting/aku4duog.png)

因为校园里比较安全，小 Y 采用的锁车方式是：从正确密码开始，随机转动密码锁仅一次；每次都是以某个幅度仅转动一个拨圈或者同时转动两个相邻的拨圈。

当小 Y 选择同时转动两个相邻拨圈时，两个拨圈转动的幅度相同，即小 Y 可以将密码锁从 $\tt{0\;0\;1\;1\;5}$ 转成 $\tt{1\;1\;1\;1\;5}$，但不会转成 $\tt{1\;2\;1\;1\;5}$。

时间久了，小 Y 也担心这么锁车的安全性，所以小 Y 记下了自己锁车后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。

为了检验这么锁车的安全性，小 Y 有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。

## 说明/提示

**【样例 1 解释】**

一共有 $81$ 种可能的方案。

其中转动一个拨圈的方案有 $45$ 种，转动两个拨圈的方案有 $36$ 种。

**【样例 2】**

见选手目录下的 lock/lock2.in 与 lock/lock2.ans。

**【数据范围】**

对于所有测试数据有：$1 \leq n \leq 8$。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 3$ | $1$ | 无 |
| $4\sim 5$ | $2$ | 无 |
| $6\sim 8$ | $8$ | A |
| $9\sim 10$ | $8$ | 无 |

特殊性质 A：保证所有正确密码都可以通过仅转动一个拨圈得到测试数据给出的 $n$ 个状态。

## 样例 #1

### 输入

```
1
0 0 1 1 5```

### 输出

```
81```

# 题解

## 作者：Not_defined (赞：134)

一道很简单的计数题，可惜我是考场上样例二都看不懂的蒟蒻。
### 题意
能通过转动一个拨圈任意幅度，或者两个拨圈相同幅度，求能达到 $n$ 个状态的可能正确的密码方案数。
### Sol
注意到 $n \le 10$，且拨圈只有五个，我们可以枚举转动幅度计数，最终状态是正确答案当且仅当它能通过 $n$ 个状态转移而来。
### Code
```
#include<bits/stdc++.h>
using namespace std;
const int N=11,mod=10;
int n,ans,dp[N][N][N][N][N];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a,b,c,d,e;
		cin>>a>>b>>c>>d>>e;
		for(int j=1;j<=9;j++)
		{
			dp[(a+j)%mod][b][c][d][e]++;
			dp[a][(b+j)%mod][c][d][e]++;
			dp[a][b][(c+j)%mod][d][e]++;
			dp[a][b][c][(d+j)%mod][e]++;
			dp[a][b][c][d][(e+j)%mod]++;
			dp[(a+j)%mod][(b+j)%mod][c][d][e]++;
			dp[a][(b+j)%mod][(c+j)%mod][d][e]++;
			dp[a][b][(c+j)%mod][(d+j)%mod][e]++;
			dp[a][b][c][(d+j)%mod][(e+j)%mod]++;
		}
	}
	for(int i=0;i<=9;i++)
	    for(int j=0;j<=9;j++)
	        for(int k=0;k<=9;k++)
	            for(int u=0;u<=9;u++)
	                for(int v=0;v<=9;v++)
	                    if(dp[i][j][k][u][v]==n)ans++;
	cout<<ans;
	return 0;
}
```


---

## 作者：wmrqwq (赞：71)

首先，我在开头说一句，提高组考这么水的题真的是不多见了。

# 题目链接

[[CSP-S 2023] 密码锁](https://www.luogu.com.cn/problem/P9752)

# 题意简述

给定一个五位密码锁的拨动一格或以相同力度拨动相邻两格后的 $n$ 种状态，求拨动前密码可能为多少。

# 解题思路

## 30pts：

容易发现，当 $n=1$ 时，拨动后的密码无论怎么样，结果都是 $81$，所以直接输出 $81$ 即可，期望得分 $30$ 分。


## 50pts：

考虑暴力，将每种状态依次讨论，最后再逐行比较即可，期望得分 $50$ 分。

## 80pts：

只需要找 $n$ 种状态的一种，然后依次拨动某一位数字 $9$ 次，依次考虑这几个拨动一位的数字即可，期望得分 $80$ 分。

## 100pts：

由于密码锁的数字总共就只有 $5$ 位，于是我们只需要依次从 $00000$ 暴力枚举到 $99999$ 再依次根据条件判断即可，期望得分 $100$ 分。

# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10][10],sum,ans;
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define QwQ return 0;
int main()
{
	IOS;
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=5;j++)
			cin>>a[i][j];
	for(int i1=0;i1<=9;i1++)//暴力枚举
		for(int i2=0;i2<=9;i2++)
			for(int i3=0;i3<=9;i3++)
				for(int i4=0;i4<=9;i4++)
					for(int i5=0;i5<=9;i5++)
					{
						sum=0;
						if(n>=1)//依次判断
						{
							if(a[1][1]!=i1 && a[1][2]==i2 && a[1][3]==i3 && a[1][4]==i4 && a[1][5]==i5)
								sum++;
							if(a[1][1]==i1 && a[1][2]!=i2 && a[1][3]==i3 && a[1][4]==i4 && a[1][5]==i5)
								sum++;
							if(a[1][1]==i1 && a[1][2]==i2 && a[1][3]!=i3 && a[1][4]==i4 && a[1][5]==i5)
								sum++;								
							if(a[1][1]==i1 && a[1][2]==i2 && a[1][3]==i3 && a[1][4]!=i4 && a[1][5]==i5)
								sum++;
							if(a[1][1]==i1 && a[1][2]==i2 && a[1][3]==i3 && a[1][4]==i4 && a[1][5]!=i5)
								sum++;	
							if(a[1][1]!=i1 && a[1][2]!=i2 && a[1][3]==i3 && a[1][4]==i4 && a[1][5]==i5)	
								if((a[1][1]+10-i1)%10==(a[1][2]+10-i2)%10)
									sum++;
							if(a[1][1]==i1 && a[1][2]!=i2 && a[1][3]!=i3 && a[1][4]==i4 && a[1][5]==i5)	
								if((a[1][3]+10-i3)%10==(a[1][2]+10-i2)%10)
									sum++;
							if(a[1][1]==i1 && a[1][2]==i2 && a[1][3]!=i3 && a[1][4]!=i4 && a[1][5]==i5)	
								if((a[1][3]+10-i3)%10==(a[1][4]+10-i4)%10)
									sum++;
							if(a[1][1]==i1 && a[1][2]==i2 && a[1][3]==i3 && a[1][4]!=i4 && a[1][5]!=i5)	
								if((a[1][4]+10-i4)%10==(a[1][5]+10-i5)%10)
									sum++;											
						}
						if(n>=2)
						{
							if(a[2][1]!=i1 && a[2][2]==i2 && a[2][3]==i3 && a[2][4]==i4 && a[2][5]==i5)
								sum++;
							if(a[2][1]==i1 && a[2][2]!=i2 && a[2][3]==i3 && a[2][4]==i4 && a[2][5]==i5)
								sum++;
							if(a[2][1]==i1 && a[2][2]==i2 && a[2][3]!=i3 && a[2][4]==i4 && a[2][5]==i5)
								sum++;								
							if(a[2][1]==i1 && a[2][2]==i2 && a[2][3]==i3 && a[2][4]!=i4 && a[2][5]==i5)
								sum++;
							if(a[2][1]==i1 && a[2][2]==i2 && a[2][3]==i3 && a[2][4]==i4 && a[2][5]!=i5)
								sum++;	
							if(a[2][1]!=i1 && a[2][2]!=i2 && a[2][3]==i3 && a[2][4]==i4 && a[2][5]==i5)	
								if((a[2][1]+10-i1)%10==(a[2][2]+10-i2)%10)
									sum++;
							if(a[2][1]==i1 && a[2][2]!=i2 && a[2][3]!=i3 && a[2][4]==i4 && a[2][5]==i5)	
								if((a[2][3]+10-i3)%10==(a[2][2]+10-i2)%10)
									sum++;
							if(a[2][1]==i1 && a[2][2]==i2 && a[2][3]!=i3 && a[2][4]!=i4 && a[2][5]==i5)	
								if((a[2][3]+10-i3)%10==(a[2][4]+10-i4)%10)
									sum++;
							if(a[2][1]==i1 && a[2][2]==i2 && a[2][3]==i3 && a[2][4]!=i4 && a[2][5]!=i5)	
								if((a[2][4]+10-i4)%10==(a[2][5]+10-i5)%10)
									sum++;											
						}
						if(n>=3)
						{
							if(a[3][1]!=i1 && a[3][2]==i2 && a[3][3]==i3 && a[3][4]==i4 && a[3][5]==i5)
								sum++;
							if(a[3][1]==i1 && a[3][2]!=i2 && a[3][3]==i3 && a[3][4]==i4 && a[3][5]==i5)
								sum++;
							if(a[3][1]==i1 && a[3][2]==i2 && a[3][3]!=i3 && a[3][4]==i4 && a[3][5]==i5)
								sum++;								
							if(a[3][1]==i1 && a[3][2]==i2 && a[3][3]==i3 && a[3][4]!=i4 && a[3][5]==i5)
								sum++;
							if(a[3][1]==i1 && a[3][2]==i2 && a[3][3]==i3 && a[3][4]==i4 && a[3][5]!=i5)
								sum++;	
							if(a[3][1]!=i1 && a[3][2]!=i2 && a[3][3]==i3 && a[3][4]==i4 && a[3][5]==i5)	
								if((a[3][1]+10-i1)%10==(a[3][2]+10-i2)%10)
									sum++;
							if(a[3][1]==i1 && a[3][2]!=i2 && a[3][3]!=i3 && a[3][4]==i4 && a[3][5]==i5)	
								if((a[3][3]+10-i3)%10==(a[3][2]+10-i2)%10)
									sum++;
							if(a[3][1]==i1 && a[3][2]==i2 && a[3][3]!=i3 && a[3][4]!=i4 && a[3][5]==i5)	
								if((a[3][3]+10-i3)%10==(a[3][4]+10-i4)%10)
									sum++;
							if(a[3][1]==i1 && a[3][2]==i2 && a[3][3]==i3 && a[3][4]!=i4 && a[3][5]!=i5)	
								if((a[3][4]+10-i4)%10==(a[3][5]+10-i5)%10)
									sum++;											
						}
						if(n>=4)
						{
							if(a[4][1]!=i1 && a[4][2]==i2 && a[4][3]==i3 && a[4][4]==i4 && a[4][5]==i5)
								sum++;
							if(a[4][1]==i1 && a[4][2]!=i2 && a[4][3]==i3 && a[4][4]==i4 && a[4][5]==i5)
								sum++;
							if(a[4][1]==i1 && a[4][2]==i2 && a[4][3]!=i3 && a[4][4]==i4 && a[4][5]==i5)
								sum++;								
							if(a[4][1]==i1 && a[4][2]==i2 && a[4][3]==i3 && a[4][4]!=i4 && a[4][5]==i5)
								sum++;
							if(a[4][1]==i1 && a[4][2]==i2 && a[4][3]==i3 && a[4][4]==i4 && a[4][5]!=i5)
								sum++;	
							if(a[4][1]!=i1 && a[4][2]!=i2 && a[4][3]==i3 && a[4][4]==i4 && a[4][5]==i5)	
								if((a[4][1]+10-i1)%10==(a[4][2]+10-i2)%10)
									sum++;
							if(a[4][1]==i1 && a[4][2]!=i2 && a[4][3]!=i3 && a[4][4]==i4 && a[4][5]==i5)	
								if((a[4][3]+10-i3)%10==(a[4][2]+10-i2)%10)
									sum++;
							if(a[4][1]==i1 && a[4][2]==i2 && a[4][3]!=i3 && a[4][4]!=i4 && a[4][5]==i5)	
								if((a[4][3]+10-i3)%10==(a[4][4]+10-i4)%10)
									sum++;
							if(a[4][1]==i1 && a[4][2]==i2 && a[4][3]==i3 && a[4][4]!=i4 && a[4][5]!=i5)	
								if((a[4][4]+10-i4)%10==(a[4][5]+10-i5)%10)
									sum++;											
						}
						if(n>=5)
						{
							if(a[5][1]!=i1 && a[5][2]==i2 && a[5][3]==i3 && a[5][4]==i4 && a[5][5]==i5)
								sum++;
							if(a[5][1]==i1 && a[5][2]!=i2 && a[5][3]==i3 && a[5][4]==i4 && a[5][5]==i5)
								sum++;
							if(a[5][1]==i1 && a[5][2]==i2 && a[5][3]!=i3 && a[5][4]==i4 && a[5][5]==i5)
								sum++;								
							if(a[5][1]==i1 && a[5][2]==i2 && a[5][3]==i3 && a[5][4]!=i4 && a[5][5]==i5)
								sum++;
							if(a[5][1]==i1 && a[5][2]==i2 && a[5][3]==i3 && a[5][4]==i4 && a[5][5]!=i5)
								sum++;	
							if(a[5][1]!=i1 && a[5][2]!=i2 && a[5][3]==i3 && a[5][4]==i4 && a[5][5]==i5)	
								if((a[5][1]+10-i1)%10==(a[5][2]+10-i2)%10)
									sum++;
							if(a[5][1]==i1 && a[5][2]!=i2 && a[5][3]!=i3 && a[5][4]==i4 && a[5][5]==i5)	
								if((a[5][3]+10-i3)%10==(a[5][2]+10-i2)%10)
									sum++;
							if(a[5][1]==i1 && a[5][2]==i2 && a[5][3]!=i3 && a[5][4]!=i4 && a[5][5]==i5)	
								if((a[5][3]+10-i3)%10==(a[5][4]+10-i4)%10)
									sum++;
							if(a[5][1]==i1 && a[5][2]==i2 && a[5][3]==i3 && a[5][4]!=i4 && a[5][5]!=i5)	
								if((a[5][4]+10-i4)%10==(a[5][5]+10-i5)%10)
									sum++;											
						}
						if(n>=6)
						{
							if(a[6][1]!=i1 && a[6][2]==i2 && a[6][3]==i3 && a[6][4]==i4 && a[6][5]==i5)
								sum++;
							if(a[6][1]==i1 && a[6][2]!=i2 && a[6][3]==i3 && a[6][4]==i4 && a[6][5]==i5)
								sum++;
							if(a[6][1]==i1 && a[6][2]==i2 && a[6][3]!=i3 && a[6][4]==i4 && a[6][5]==i5)
								sum++;								
							if(a[6][1]==i1 && a[6][2]==i2 && a[6][3]==i3 && a[6][4]!=i4 && a[6][5]==i5)
								sum++;
							if(a[6][1]==i1 && a[6][2]==i2 && a[6][3]==i3 && a[6][4]==i4 && a[6][5]!=i5)
								sum++;	
							if(a[6][1]!=i1 && a[6][2]!=i2 && a[6][3]==i3 && a[6][4]==i4 && a[6][5]==i5)	
								if((a[6][1]+10-i1)%10==(a[6][2]+10-i2)%10)
									sum++;
							if(a[6][1]==i1 && a[6][2]!=i2 && a[6][3]!=i3 && a[6][4]==i4 && a[6][5]==i5)	
								if((a[6][3]+10-i3)%10==(a[6][2]+10-i2)%10)
									sum++;
							if(a[6][1]==i1 && a[6][2]==i2 && a[6][3]!=i3 && a[6][4]!=i4 && a[6][5]==i5)	
								if((a[6][3]+10-i3)%10==(a[6][4]+10-i4)%10)
									sum++;
							if(a[6][1]==i1 && a[6][2]==i2 && a[6][3]==i3 && a[6][4]!=i4 && a[6][5]!=i5)	
								if((a[6][4]+10-i4)%10==(a[6][5]+10-i5)%10)
									sum++;											
						}
						if(n>=7)
						{
							if(a[7][1]!=i1 && a[7][2]==i2 && a[7][3]==i3 && a[7][4]==i4 && a[7][5]==i5)
								sum++;
							if(a[7][1]==i1 && a[7][2]!=i2 && a[7][3]==i3 && a[7][4]==i4 && a[7][5]==i5)
								sum++;
							if(a[7][1]==i1 && a[7][2]==i2 && a[7][3]!=i3 && a[7][4]==i4 && a[7][5]==i5)
								sum++;								
							if(a[7][1]==i1 && a[7][2]==i2 && a[7][3]==i3 && a[7][4]!=i4 && a[7][5]==i5)
								sum++;
							if(a[7][1]==i1 && a[7][2]==i2 && a[7][3]==i3 && a[7][4]==i4 && a[7][5]!=i5)
								sum++;	
							if(a[7][1]!=i1 && a[7][2]!=i2 && a[7][3]==i3 && a[7][4]==i4 && a[7][5]==i5)	
								if((a[7][1]+10-i1)%10==(a[7][2]+10-i2)%10)
									sum++;
							if(a[7][1]==i1 && a[7][2]!=i2 && a[7][3]!=i3 && a[7][4]==i4 && a[7][5]==i5)	
								if((a[7][3]+10-i3)%10==(a[7][2]+10-i2)%10)
									sum++;
							if(a[7][1]==i1 && a[7][2]==i2 && a[7][3]!=i3 && a[7][4]!=i4 && a[7][5]==i5)	
								if((a[7][3]+10-i3)%10==(a[7][4]+10-i4)%10)
									sum++;
							if(a[7][1]==i1 && a[7][2]==i2 && a[7][3]==i3 && a[7][4]!=i4 && a[7][5]!=i5)	
								if((a[7][4]+10-i4)%10==(a[7][5]+10-i5)%10)
									sum++;											
						}
						if(n>=8)
						{
							if(a[8][1]!=i1 && a[8][2]==i2 && a[8][3]==i3 && a[8][4]==i4 && a[8][5]==i5)
								sum++;
							if(a[8][1]==i1 && a[8][2]!=i2 && a[8][3]==i3 && a[8][4]==i4 && a[8][5]==i5)
								sum++;
							if(a[8][1]==i1 && a[8][2]==i2 && a[8][3]!=i3 && a[8][4]==i4 && a[8][5]==i5)
								sum++;								
							if(a[8][1]==i1 && a[8][2]==i2 && a[8][3]==i3 && a[8][4]!=i4 && a[8][5]==i5)
								sum++;
							if(a[8][1]==i1 && a[8][2]==i2 && a[8][3]==i3 && a[8][4]==i4 && a[8][5]!=i5)
								sum++;	
							if(a[8][1]!=i1 && a[8][2]!=i2 && a[8][3]==i3 && a[8][4]==i4 && a[8][5]==i5)	
								if((a[8][1]+10-i1)%10==(a[8][2]+10-i2)%10)
									sum++;
							if(a[8][1]==i1 && a[8][2]!=i2 && a[8][3]!=i3 && a[8][4]==i4 && a[8][5]==i5)	
								if((a[8][3]+10-i3)%10==(a[8][2]+10-i2)%10)
									sum++;
							if(a[8][1]==i1 && a[8][2]==i2 && a[8][3]!=i3 && a[8][4]!=i4 && a[8][5]==i5)	
								if((a[8][3]+10-i3)%10==(a[8][4]+10-i4)%10)
									sum++;
							if(a[8][1]==i1 && a[8][2]==i2 && a[8][3]==i3 && a[8][4]!=i4 && a[8][5]!=i5)	
								if((a[8][4]+10-i4)%10==(a[8][5]+10-i5)%10)
									sum++;											
						}
						if(sum==n)
							ans++;
					}
	cout<<ans;
	QwQ;
}
```

---

## 作者：TemplateClass (赞：40)

这题应该是历年 S 组最水的题目了，$n \le 8$，乱搞都能过。

我的大致思路是生成全排列，然后根据每次输入的密码对全排列进行一个筛选，最后统计一下。

1. 全排列生成

如果我没记错的话好像有一个函数单独用来生成全排列的……

~~但是我忘了。~~

```cpp
void init(){
	for(int i = 0; i <= 9; ++i)
	for(int j = 0; j <= 9; ++j)
	for(int k = 0; k <= 9; ++k)
	for(int l = 0; l <= 9; ++l)
	for(int m = 0; m <= 9; ++m){
		p += 1;
		pre[p][1] = i;
		pre[p][2] = j;
		pre[p][3] = k;
		pre[p][4] = l;
		pre[p][5] = m;
	}
}
```
2. 筛选

将输入的密码与每一个全排列进行筛选，不合法的标记。

我们可以首先统计密码与全排列不同的地方。

```cpp
int diff = 0, i1 = 0, i2 = 0;
for(int i = 1; i <= 5; ++i){
	if(a[x][i] != pre[y][i]){
		diff += 1;
		if(!i1) i1 = i;
		else if(!i2) i2 = i;
	}
}
```

- 若不同的地方大于等于 $3$ 处，标记不合法。

```cpp
if(diff >= 3) return 0;
```

- 同时，因为输入的 $n$ 个状态都不是正确密码，所以如果没有不同的地方，也标记不合法。

```cpp
if(diff == 0) return 0;
```

然后比较：

- 如果只有一处不同，合法。

```cpp
else if(diff == 1) return 1;
```

- 如果有两处不同，如果两处不同不相邻，不合法。否则循环枚举拨动的格子数，如果相同返回真，不相同返回假。

```cpp
else if(diff == 2){
	if(i2 - i1 != 1) return 0;
	if(pd1(x, y, i1, i2)) return 1;
	else return 0;
}
```

```cpp
bool pd1(int x, int y, int i1, int i2){
	for(int i = 1; i <= 10; ++i){
		int p1 = (pre[y][i1] + i) % 10;
		int p2 = (pre[y][i2] + i) % 10;
		if(p1 == a[x][i1] && p2 == a[x][i2]) return 1;
	}
	return 0;
}
```

完整的判断代码如下：


```cpp
bool pd1(int x, int y, int i1, int i2){
	for(int i = 1; i <= 10; ++i){
		int p1 = (pre[y][i1] + i) % 10;
		int p2 = (pre[y][i2] + i) % 10;
		if(p1 == a[x][i1] && p2 == a[x][i2]) return 1;
	}
	return 0;
}

bool pd2(int x, int y){
	int diff = 0, i1 = 0, i2 = 0;
	for(int i = 1; i <= 5; ++i){
		if(a[x][i] != pre[y][i]){
			diff += 1;
			if(!i1) i1 = i;
			else if(!i2) i2 = i;
			if(diff >= 3) return 0;
		}
	}
	if(diff == 0) return 0;
	else if(diff == 1) return 1;
	else if(diff == 2){
		if(i2 - i1 != 1) return 0;
		if(pd1(x, y, i1, i2)) return 1;
		else return 0;
	}
}
```

接下来，对于每一次输入，标记并统计。

```cpp
for(int i = 1; i <= n; ++i){
	for(int j = 1; j <= p; ++j){
		if(pre[j][1] == -1) continue;
		if(!pd2(i, j)) pre[j][1] = -1;
	}
}
int ans = 0;
for(int i = 1; i <= p; ++i)
	if(pre[i][1] != -1) ans += 1;
std::cout << ans;
```

3. 赛时 AC 代码：

```cpp
#include<cstdio>
#include<iostream>

const int N = 10;
const int M = 1e5 + 5;
int n, a[N][6];
int pre[M][6], p;

void init(){
	for(int i = 0; i <= 9; ++i)
	for(int j = 0; j <= 9; ++j)
	for(int k = 0; k <= 9; ++k)
	for(int l = 0; l <= 9; ++l)
	for(int m = 0; m <= 9; ++m){
		p += 1;
		pre[p][1] = i;
		pre[p][2] = j;
		pre[p][3] = k;
		pre[p][4] = l;
		pre[p][5] = m;
	}
}

bool pd1(int x, int y, int i1, int i2){
	for(int i = 1; i <= 10; ++i){
		int p1 = (pre[y][i1] + i) % 10;
		int p2 = (pre[y][i2] + i) % 10;
		if(p1 == a[x][i1] && p2 == a[x][i2]) return 1;
	}
	return 0;
}

bool pd2(int x, int y){
	int diff = 0, i1 = 0, i2 = 0;
	for(int i = 1; i <= 5; ++i){
		if(a[x][i] != pre[y][i]){
			diff += 1;
			if(!i1) i1 = i;
			else if(!i2) i2 = i;
			if(diff >= 3) return 0;
		}
	}
	if(diff == 0) return 0;
	else if(diff == 1) return 1;
	else if(diff == 2){
		if(i2 - i1 != 1) return 0;
		if(pd1(x, y, i1, i2)) return 1;
		else return 0;
	}
}

int main(){
	std::cin >> n;
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= 5; ++j){
			std::cin >> a[i][j];
	 	}
	}
	init();
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= p; ++j){
			if(pre[j][1] == -1) continue;
			if(!pd2(i, j)) pre[j][1] = -1;
		}
	}
	int ans = 0;
	for(int i = 1; i <= p; ++i)
		if(pre[i][1] != -1) ans += 1;
	std::cout << ans;
	
	return 0;
}
```

---

## 作者：XKqwq (赞：38)


思路很简单。对于每一个密码，求出所有可能的密码（ $81$ 种），然后扔进一个桶里。最后枚举所有密码，看是否这个密码能由给出的 $n$ 个密码转换而来。

一些细节：

1. 桶直接开一个 $5$ 维数组即可。
2. 对于每一个密码，桶内的同一个可能的密码最多加一次。
3. 拨动密码锁的时候记得取模。

逻辑清晰码风良好的考场代码：
```cpp
#include <bits/stdc++.h>
#define forr(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
int n,s[10][10][10][10][10],a,b,c,d,e,ans;
int main() {
    freopen("lock.in","r",stdin);
    freopen("lock.out","w",stdout);
    cin>>n;
    forr(i,1,n) {
        scanf("%d %d %d %d %d",&a,&b,&c,&d,&e);
        forr(j,0,9) s[j][b][c][d][e] ++ ;
        forr(j,0,9) s[a][j][c][d][e] ++ ;
        forr(j,0,9) s[a][b][j][d][e] ++ ;
        forr(j,0,9) s[a][b][c][j][e] ++ ;
        forr(j,0,9) s[a][b][c][d][j] ++ ;

        forr(j,1,9) s[(a+j)%10][(b+j)%10][c][d][e] ++ ;
        forr(j,1,9) s[a][(b+j)%10][(c+j)%10][d][e] ++ ;
        forr(j,1,9) s[a][b][(c+j)%10][(d+j)%10][e] ++ ;
        forr(j,1,9) s[a][b][c][(d+j)%10][(e+j)%10] ++ ;
    }
    forr(i1,0,9) forr(i2,0,9) forr(i3,0,9) forr(i4,0,9) forr(i5,0,9) {
        if(s[i1][i2][i3][i4][i5]==n) ++ans;
    } cout<<ans;

    return 0;
}

```






---

## 作者：Register_int (赞：22)

容易发现序列是可逆的，所以可以暴力找出每个密码锁能拨成的状态，然后将每个集合求交即可。记得最后要把所有给出的状态去掉。时间复杂度为 $O(kn\log kn)$，其中 $k$ 为 $81$。

所以这题完全能把密码锁长度开 $10^3$ 啊，强烈谴责 CCF 放了一车枚举原状态的过了。

# AC 代码

```cpp
#include <bits/stdc++.h>

typedef long long ll;

using namespace std;

const int MAXN = 1e5 + 10;

set<array<int, 5>> s, t; vector<array<int, 5>> v;

int n; array<int, 5> a[8], x;

int main() {
	freopen("lock.in", "r", stdin);
	freopen("lock.out", "w", stdout);
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < 5; j++) scanf("%d", &a[i][j]);
		for (int j = 0; j < 5; j++) {
			x = a[i];
			for (int k = 0; k < 9; k++) {
				x[j] = (x[j] + 1) % 10, s.insert(x);
			}
		}
		for (int j = 0; j < 4; j++) {
			x = a[i];
			for (int k = 0; k < 9; k++) {
				x[j] = (x[j] + 1) % 10, x[j + 1] = (x[j + 1] + 1) % 10;
				s.insert(x);
			}
		}
		if (!i) t = s;
		else {
			for (auto p : t) if (s.find(p) == s.end()) v.push_back(p);
			for (auto p : v) t.erase(p); v.clear();
		}
		s.clear();
	}
	for (int i = 0; i < n; i++) t.erase(a[i]);
	printf("%d", (int)t.size());
}
```

---

## 作者：tder (赞：16)

[$\Large\color{black}\textbf{P9752 [CSP-S 2023] 密码锁}$](https://www.luogu.com.cn/problem/P9752) $\Large\textbf{题解}$

[$\textbf{题目传送门}$](https://www.luogu.com.cn/problem/P9752)

[$\textbf{更好的阅读体验}$](https://www.luogu.com.cn/blog/tder/solution-P9752)

~~居然开了题解通道？！~~

~~本来以为要 dp 之类的，看到 $n\le8$ 直接暴力出奇迹！~~

---

$$\large\textbf{思路}$$

主打一个暴力。

枚举每一种可能 $s\in[\texttt{00000},\texttt{99999}]$，再枚举每一个密码锁状态，判断是否可以通过转动一个或相邻两个得到 $s$，若可以计数器累加即可。

对于转动一个的情况：

- $s$ 与密码锁状态有且仅有 $1$ 位不同

对于转动相邻两个的情况：

- $s$ 与密码锁状态有且仅有 $2$ 位不同，且这两位相邻
- 不同的两位 $x_1,y_1$ 与状态中 $x_0,y_0$ 的转动幅度相同，即 $(x_1-x_0+10)\equiv(y_1-y_0+10)\pmod{10}$

---

$$\large\textbf{代码}$$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 8 + 5;
int n, cnt;
struct Lock {
    int a, b, c, d, e;
}l[N];
int _minus(int k, int t) { // 计算转动幅度
    if(k < t) return k - t + 10;
    return k - t; 
}
bool check(int a, int b, int c, int d, int e) { // 判断每一种 s 是否满足条件
    for(int k = 1; k <= n; k++) { // 枚举密码锁状态
        int f1 = 0;
        if(b == l[k].b && c == l[k].c && d == l[k].d && e == l[k].e) f1++; // 转动一位
        if(a == l[k].a && c == l[k].c && d == l[k].d && e == l[k].e) f1++;
        if(a == l[k].a && b == l[k].b && d == l[k].d && e == l[k].e) f1++;
        if(a == l[k].a && b == l[k].b && c == l[k].c && e == l[k].e) f1++;
        if(a == l[k].a && b == l[k].b && c == l[k].c && d == l[k].d) f1++; 
        int f2 = 0;
        if(_minus(a, l[k].a) == _minus(b, l[k].b) && c == l[k].c && d == l[k].d && e == l[k].e) f2++; // 转动相邻两位
        if(_minus(b, l[k].b) == _minus(c, l[k].c) && a == l[k].a && d == l[k].d && e == l[k].e) f2++;
        if(_minus(c, l[k].c) == _minus(d, l[k].d) && a == l[k].a && b == l[k].b && e == l[k].e) f2++;
        if(_minus(d, l[k].d) == _minus(e, l[k].e) && a == l[k].a && b == l[k].b && c == l[k].c) f2++;
        if(f1 != 1 && f2 != 1) return 0; // 既不是转动一位也不是转动相邻两位
    }
    return 1;
}
signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin>>n;
    for(int i = 1; i <= n; i++) 
        cin>>l[i].a>>l[i].b>>l[i].c>>l[i].d>>l[i].e;
    for(int a = 0; a <= 9; a++) // 枚举每种可能 s 的每一位
        for(int b = 0; b <= 9; b++)
            for(int c = 0; c <= 9; c++)
                for(int d = 0; d <= 9; d++)
                    for(int e = 0; e <= 9; e++)
                        if(check(a, b, c, d, e)) cnt++;
    cout<<cnt<<endl;
    return 0;
}
```

---

## 作者：2huk (赞：12)

# [CSP-S 2023] 密码锁

## Description

小 Y 有一把 $5$ 个拨圈的密码锁，每个拨圈都是 $0 \sim 9$ 的循环。

每次小 Y 从正确密码开始，通过以下两种方法之一随机转动密码锁一次：

1. 以某个幅度仅转动一个拨圈；
2. 以某个幅度同时转动两个相邻的拨圈。

小 Y 记下了自己转动后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。

求有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。

$1 \le n \le 8$。

## Solution

可以注意到，每位可以填 $0 \sim 9$ 中的共 $10$ 位数字，因此 $5$ 位总共有 $5^{10} \approx 10^7$ 个不同的密码锁状态。

考虑 dfs 暴力枚举每一位，然后检验是否可以从这个状态变到所有给定的 $n$ 个状态即可。若是，则答案加一。

根据上述想法可以写出如下代码：

```cpp
bool chk()
{
	for (int i = 1; i <= n; ++ i )
		if (!calc(i))		// calc(i) 表示能否将当前状态枚举的 p 转化成给定的第 i 个状态
			return false;
	return true;
}

void dfs(int u)
{
	if (u > 5)
	{
		res += chk();
		return;
	}
	for (int i = 0; i < 10; ++ i )
	{
		p[u] = i;		// 枚举状态 p
		dfs(u + 1);
	}
	return; 
}
```

其中第 4 行的 `calc(i)` 表示能否将当前状态枚举的 $p$ 转化成给定的第 $i$ 个状态（以下将第 $i$ 个状态称为 $a_i$）。考虑实现这个问题。

- 若 $p = a_i$，那么这个状态是不可行的。 因为题目中提到所有的状态都不是不是正确密码；

- 若 $p$ 与 $a_i$ 只有一位不同，那么这个状态是可行的。可以由题目中的操作 1 转化成 $a_i$；

- 若 $p$ 与 $a_i$ 不同的位数多于 $2$ 位，那么这个状态是不可行的；
- 若 $p$ 与 $a_i$ 不同的位数为 $2$ 位，但是这不同的两位不相邻，那么这个状态是不可行的；
- 若 $p$ 与 $a_i$ 不同的位数为 $2$ 位，且这两位相邻，则需要分类讨论：
  - 若可以从 $p$ 以相同的幅度将两位转到 $a_i$，那么这个状态是可行的；
  - 若不可以从 $p$ 以相同的幅度将两位转到 $a_i$，那么这个状态是不可行的。

```cpp
bool calc(int x)		// 能否将 p 转化成 a[x]？ 
{
	int cnt = 0;		// 找到 p 与 a[x] 不同的所有位
	for (int i = 1; i <= 5; ++ i )
		if (p[i] != a[x][i])
			di[ ++ cnt] = i;
	
	if (!cnt) return false;		// 完全相同，不可行
	if (cnt == 1) return true;	// 只有一位不同，可行
	if (cnt > 2) return false;	// 多余两位不同，不可行
	if (abs(di[1] - di[2]) != 1) return false;	// 不同的两位不相邻，不可行
	return (f(p[di[1]], a[x][di[1]]) == f(p[di[2]], a[x][di[2]]));		// 判断两位的转动幅度是否相同
}
```

接下来考虑计算如何在拨圈上将 $x$ 转为 $y$，即代码中的 `f(x, y)` 函数：

- 若 $x \le y$，那么直接转即可，幅度为 $y - x$；
- 若 $x > y$，那么首先需要将 $x$ 转到 $0$，再从 $0$ 转到 $y$，总幅度为 $10 - x + y$。

```cpp
int f(int x, int y)		// 从 a 转到 b 的次数 
{
	return (x <= y) ? (y - x) : (10 - x + y);
}
```

那么问题就解决了。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cmath> 

using namespace std;

const int N = 10;

int n, a[N][6], res;
int p[6];
int di[N];

int f(int x, int y)		// 从 a 转到 b 的次数 
{
	return (x <= y) ? (y - x) : (10 - x + y);
}

bool calc(int x)		// 能否将 p 转化成 a[x]？ 
{
	int cnt = 0;		// 找到 p 与 a[x] 不同的所有位
	for (int i = 1; i <= 5; ++ i )
		if (p[i] != a[x][i])
			di[ ++ cnt] = i;
	
	if (!cnt) return false;		// 完全相同，不可行
	if (cnt == 1) return true;	// 只有一位不同，可行
	if (cnt > 2) return false;	// 多余两位不同，不可行
	if (abs(di[1] - di[2]) != 1) return false;	// 不同的两位不相邻，不可行
	return (f(p[di[1]], a[x][di[1]]) == f(p[di[2]], a[x][di[2]]));		// 判断两位的转动幅度是否相同
}

bool chk()
{
	for (int i = 1; i <= n; ++ i )
		if (!calc(i))		// calc(i) 表示能否将当前状态枚举的 p 转化成给定的第 i 个状态
			return false;
	return true;
}

void dfs(int u)
{
	if (u > 5)
	{
		res += chk();
		return;
	}
	for (int i = 0; i < 10; ++ i )
	{
		p[u] = i;		// 枚举状态 p
		dfs(u + 1);
	}
	return; 
}

int main()
{
	freopen("lock.in", "r", stdin);
	freopen("lock.out", "w", stdout);
	cin >> n;
	
	for (int i = 1; i <= n; ++ i )
		for (int j = 1; j <= 5; ++ j )
			cin >> a[i][j];
	
	dfs(1);
	
	cout << res;
	
	return 0;
}
```



---

## 作者：残阳如血 (赞：10)

## 思路分析
今年 S 第一题怎么简单？哇塞！

非常暴力的做法，但是对于 $n\le8$ 的数据范围完全没有问题。

感觉时间复杂度比较玄学，如果忽略常数就很快，但是常数巨大。

~~读了一个小时的题目~~。
### 题意简述
给定 $n$ 串长度为 $5$ 的数字。

现在要求找到所有满足如下要求的长度为 $5$ 的数字串，使得这个数字串仅通过对其中 $1$ 位进行变换使得可以达到所有的目标状态。

**重点：只能操作一位（但是牵连到下一位也是可以的）！！！**
### 考场思路
从目标结果反推可以达到的状态，然后用 `std::unordered_set` 存下。

接下来遍历所有状态，如果这个状态存在每一个集合中那么就说明这个状态是合法的。

由于结果不大于 $10^5$，所以可以用 `int` 存下。
## 代码实现
```cpp
#include <array>
#include <cstdio>
#include <vector>
#include <iostream>
#include <unordered_set>

struct Hash { // 对于 std::array<int, 5> 的哈希函数进行映射，实现较丑
	size_t operator()(const std::array<int, 5> &arr) const {
		size_t ans = 0;
		for (auto x : arr) ans ^= x ^ 2337;
		return ans;
	}
};

int main() {
//	freopen("lock.in", "r", stdin);
//	freopen("lock.out", "w", stdout);
	std::cin.tie(0)->sync_with_stdio(0); // 加速读入
	int n, ans = 0; std::cin >> n;
	std::vector<std::array<int, 5>> a(n); // 所有的目标状态
	for (auto &arr : a) for (auto &x : arr) std::cin >> x;
	std::vector<std::unordered_set<std::array<int, 5>, Hash>> set(n);
   // 存储所有目标状态反推出来的初始状态
	for (int k = 0; k < n; ++k) { // 遍历每一个目标状态
		for (int j = 1; j <= 9; ++j) { // 修改的范围
			// 单个
			for (int i = 0; i < 5; ++i) { // 遍历每一个可以修改的位置
				auto cur = a[k];
				(cur[i] += 10 - j) %= 10; // 这个公式很好总结
				set[k].insert(cur); // 直接加入对应的集合
			}
			for (int i = 0; i < 5; ++i) {
				auto cur = a[k];
				(cur[i] += j) %= 10; // 同上
				set[k].insert(cur);
			}
			// 双个
			for (int i = 0; i < 4; ++i) { // 由于牵连到下一个，下标只能到 4
				auto cur = a[k];
				(cur[i] += 10 - j) %= 10;
				(cur[i + 1] += 10 - j) %= 10; // 修改下一位
				set[k].insert(cur);
			}
			for (int i = 0; i < 4; ++i) {
				auto cur = a[k];
				(cur[i] += j) %= 10;
				(cur[i + 1] += j) %= 10;
				set[k].insert(cur);
			}
		}
	}
	for (int q = 0; q < 10; ++q) // 枚举所有初始状态
		for (int w = 0; w < 10; ++w)
			for (int e = 0; e < 10; ++e)
				for (int r = 0; r < 10; ++r)
					for (int t = 0; t < 10; ++t) {
						bool flag = true;
						for (int i = 0; i < n; ++i) { // 遍历每一个集合
							if (set[i].find({q, w, e, r, t}) == set[i].end()) { // 判断是否可以查找到初始状态
								flag = false;
								break;
							}
						}
						if (flag) ++ans; // 如果符合就添加
					}
	std::cout << ans << std::endl;
	return 0;
}
```

---

## 作者：TheSky233 (赞：7)

## Solution

观察题目数据范围，$n \le 8$，且密码长度恒为 $5$。于是直接暴力枚举每一种可能的情况再逐个判断即可。

判断的方式是先扫描一下，看有多少个不同数字，记为 $\text{dif}$，如果 $\text{dif}>2 $ 或 $\text{dif}=0$ 显然不可。接下来分讨：

1. $\text{dif}=1$，直接累加进答案即可。

2. $\text{dif}=2$，扫描每两个相邻的数字，若可以通过已知盘面转动相同的幅度即累加进答案，否则舍去。

	- 具体地，令当前盘面**往小了拨**，即强制要求当前盘面数字（记作 $x$）大于已知盘面数字(记作 $y$)，令 $x'=\begin{cases}x+10 & \text{If } x<y\\x & \text{Otherwise.}\end{cases}$，比较相邻两个数字的 $x'-y$ 是否相同即可。

## Code

（考场代码）

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))
#define dF(i, a, b) for(int (i) = (a); (i) >= (b); --(i))
#define forGraph(x) for(int i = head[x]; i; i = G[i].next)
#define ENDL putchar('\n');
#define endl '\n'
#define fi first
#define se second
#define pb push_back
#define _file(x) freopen(#x".in", "r", stdin); freopen(#x".out", "w", stdout);
// #define int long long

using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int N = 5e5 + 5;
const int M = 1e6 + 5;

template<typename T> void read(T &x) {
    x = 0; bool f = 0; char ch = getchar();
    for(; !isdigit(ch); ch = getchar()) f |= (ch == '-');
    for(;  isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    x = f ? -x : x;
}
template<typename T, typename ...Args> void read(T &x, Args &...args) {
    read(x); read(args...);
}
template<typename T> void write(T x) {
    char buf[65]; int tot = 0;
    if(x < 0) putchar('-'), x = -x;
    do{ buf[++tot] = x % 10 + '0'; x /= 10; } while(x);
    do{ putchar(buf[tot--]); } while(tot);
}

mt19937 rng(random_device());

int c[10], p[10], a[10][10];
int n, ans;

bool check(int id) {
    F(i, 1, 5) p[i] = a[id][i];
    // single-turn
    int dif = 0;
    F(i, 1, 5) dif += (c[i] != p[i]);
    if(dif == 1) return true;
    if(dif > 2) return false;
    // double-turn
    F(i, 1, 4) {
        int l = i, r = i + 1;
        if(p[l] != c[l] && p[r] != c[r]) {
            int fixed_l = (c[l] < p[l] ? c[l] + 10 : c[l]);
            int fixed_r = (c[r] < p[r] ? c[r] + 10 : c[r]);
            if(fixed_l - p[l] == fixed_r - p[r]) {
                return true;
            }
        }
    }
    return false;
}

void dfs(int x) {
    if(x > 5) {
        bool ok = 1;
        F(i, 1, n) {
            if(!check(i)) {
                ok = 0;
                break;
            }
        }
        if(ok) ans++;
        return;
    }
    F(i, 0, 9) {
        c[x] = i;
        dfs(x + 1);
    }
}

int main() {
    read(n);
    F(i, 1, n) F(j, 1, 5) read(a[i][j]);
    dfs(1);
    write(ans);
    return 0;
}
```

---

## 作者：zhuweiqi (赞：7)

从来没在 CSP-S 见过这么水的 T1……

观察到密码锁一共有 $10^5$ 个状态，而且 $n\leq8$，因此我考场上选择了纯模拟的方式来实现，首先用五重循环枚举正确密码的各个数位，然后判断其是否合法：对于输入的 $n$ 个非正确密码，分别判断其和正确密码有几个数位上的数字不同，设其为 $k$，当 $k=0$ 或者 $k>2$ 时此密码显然不合法；当 $k=1$ 时显然合法；当 $k=2$ 时，如果是两个相邻的数位上的数字不同，并且他们都能通过转动相同方向相同幅度从而分别一一对应上，就说明此密码是合法的；反之亦然。注意，需要满足此密码对于 $n$ 个非正确密码来说都是合法的，才能将答案自增。下面给出考场 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][10];
int p[10];
int main(){
	int n,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) for(int j=1;j<=5;j++) scanf("%d",&a[i][j]);
	for(p[1]=0;p[1]<10;p[1]++){
		for(p[2]=0;p[2]<10;p[2]++){
			for(p[3]=0;p[3]<10;p[3]++){
				for(p[4]=0;p[4]<10;p[4]++){
					for(p[5]=0;p[5]<10;p[5]++){
						bool flag=0;
						for(int i=1;i<=n;i++){
							int cnt=0;
							for(int j=1;j<=5;j++) if(a[i][j]!=p[j]) cnt++;
							if(cnt>=3 || cnt==0){
								flag=1;
								break;
							}
							if(cnt==1) continue;
							for(int j=1;j<=5;j++){
								if(a[i][j]!=p[j]){
									if(a[i][j+1]==p[j+1]){
										flag=1;
										break;
									}
									if((a[i][j]+10-p[j])%10==(a[i][j+1]+10-p[j+1])%10) break;
									else {
										flag=1;
										break;
									}
								}
							}
							if(flag==1) break;
						} 
						if(flag==0) ans++;
					}
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：MournInk (赞：5)

# 密码锁

> 这道题根据群友讲述有多种做法，此处仅列举我的做法。

## 解法

### 考场骗分
由性质得输出 $81$ 即可获得 $30\ pts$。

### 一个可行解
我们从题目描述中可以看到，最多给出 $8$ 个错误的密码，且每个密码共 $5$ 位。

现在令我们正在查找的密码为 $a_1 a_2 a_3 a_4 a_5$，遍历其每一个可以达到的密码，即枚举一位变化与两位变化。

则每个密码共可以达到 $81$ 中正确密码。

由于密码位数只有 $5$ 位，这样我们就可以将每一个可达状态转换为十进制数，并使用一个 $[0, 100000]$ 的桶存储。

不难得出，若一个密码为可能的正确密码，则该密码一定被 $pwd_1, pwd_2, \cdots ,pwd_n$ 标记过。

则正确答案为 $\sum\limits_{i=0}^{99999}[bukkit_i = n]$。

### 代码
~~~cpp
#include <bits/stdc++.h>
const int N = 1e5 + 10, M = 10, T = 1e4;
int bukkit[N], pwd[M], passwd, n, ans = 0, b;
int main()
{
    freopen("lock.in", "r", stdin);
	freopen("lock.out", "w", stdout);
	std :: cin >> n;
	for(int i = 1; i <= n; i ++)
	{
		passwd = 0, b = T; // passwd: 当前错误密码转换为十进制, b: 枚举到的位数
		for(int j = 1; j <= 5; passwd *= 10, passwd += pwd[j], j ++) std :: cin >> pwd[j];
		for(int j = 1; j <= 5; j ++)
		{
			for(int k = 1; k <= 9; k ++)
			{
				bukkit[passwd - pwd[j] * b + ((pwd[j] + k) % 10) * b] ++;
				if(j <= 4)
					bukkit[
						passwd
						- pwd[j] * b
						- pwd[j + 1] * b / 10
						+ ((pwd[j] + k) % 10) * b
						+ ((pwd[j + 1] + k) % 10) * b / 10
					] ++;
			}
			b /= 10;
		}
	}
	for(int i = 0; i < N; i ++) ans += (bukkit[i] == n);
	std :: cout << ans << "\n";
    return 0;
}
~~~

---

## 作者：Mortidesperatslav (赞：5)

本题是显然的暴力枚举。

因为只有五位且 $n \leq 8$，所以可以过。

时间复杂度 $O(800000n)$。

代码：

```cpp
#include<bits/stdc++.h>
int n,a[11][45];
bool check(int x){
	int s[8];
	s[4]=x%10;
	s[3]=(x/10)%10;
	s[2]=(x/100)%10;
	s[1]=(x/1000)%10;
	s[0]=x/10000;
	for(int i=1;i<=n;i++){//判断是否满足条件
		int cnt=0;
		for(int j=0;j<5;j++){
			int p=a[i][j]-s[j]+10;
			if(p%10!=0)cnt++;
		}
		if(cnt==0||cnt>2)return 0;
		if(cnt==2){
			for(int j=1;j<4;j++){
				int p=a[i][j]-s[j]+10;
				int pp=a[i][j+1]-s[j+1]+10;
				int ppp=a[i][j-1]-s[j-1]+10;
				if(ppp%10!=0&&p%10==0&&j==1)return 0;
				if(pp%10!=0&&p%10==0&&j==3)return 0;
				if(p%10==pp%10||p%10==ppp%10)continue;//幅度相同
				else return 0;
			}
		}
	}
	return 1;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d%d%d%d",&a[i][0],&a[i][1],&a[i][2],&a[i][3],&a[i][4]);
	int s[8],ans=0;
	for(int i=0;i<=99999;i++)if(check(i))ans++;//枚举
	printf("%d",ans);
	return 0;
}
```

其实可以大幅优化。因为显然不会超过 81 种方案。

---

## 作者：Miyamizu_Mitsuha (赞：4)

近几年来最水 t1。

可以暴力计算出所以可能的状态，先枚举转一个的，再枚举转两个的。开一个五维数组，若 $add_{a,b,c,d,e}=1$ 则说明 $a,b,c,d,e$ 是一个合法的状态，计算的时候注意取模。由于我们只有加且每次只能对一个数加一次，所以状态不会重复。对于每一个密码都计算一次，最后枚举状态，如果等于 $n$ 则说明可以由所有状态转移来。复杂度 $O(n)$ 带点小常数，由于 $n$ 也足够小所以时间开销就非常之小了。

```
#include <stdio.h>
#include <iostream>
using namespace std;
int add[10][10][10][10][10]={0};
int m(int n){return n%10;}
void calc(int a,int b,int c,int d,int e){
  for(int i=1;i<=9;i++)add[m(a+i)][m(b)][m(c)][m(d)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b+i)][m(c)][m(d)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c+i)][m(d)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c)][m(d+i)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c)][m(d)][m(e+i)]++;
  for(int i=1;i<=9;i++)add[m(a+i)][m(b+i)][m(c)][m(d)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b+i)][m(c+i)][m(d)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c+i)][m(d+i)][m(e)]++;
  for(int i=1;i<=9;i++)add[m(a)][m(b)][m(c)][m(d+i)][m(e+i)]++;
}
int main(){
  int n,ans=0;
  cin>>n;
  for(int i=1;i<=n;i++){
    int a,b,c,d,e;
    cin>>a>>b>>c>>d>>e;
    calc(a,b,c,d,e);
  }
  for(int i1=0;i1<=9;i1++)
  for(int i2=0;i2<=9;i2++)
  for(int i3=0;i3<=9;i3++)
  for(int i4=0;i4<=9;i4++)
  for(int i5=0;i5<=9;i5++)
    if(add[i1][i2][i3][i4][i5]==n)ans++;

  cout<<ans;
  return 0;

}
/*qwq*/

```


---

## 作者：sqh_let_it_be (赞：3)

这个题在考场上我第一眼看这个 $n\le8$ 就是暴力。毕竟数据量这么小。

先上代码，后讲思路。

```cpp
/*
SD-S00285
Luogu UID:363061
ID:sqh_let_it_be
RP++
score++
*/
#include<bits/stdc++.h>
using namespace std;
int suo[9][10],cf[9][10],n;
int mm[25],zj[11][11][11][11][11],ans;
map<int,int> da;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-48;ch=getchar();}
	return s*w;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=5;j++)
			suo[i][j]=read();
	for(int i=1;i<=n;i++)
	{
		int tem1=suo[i][1];
		int tem2=suo[i][2];
		int tem3=suo[i][3];
		int tem4=suo[i][4];
		int tem5=suo[i][5];
		for(int k=1;k<=9;k++)
		{
			// 单个转 
			zj[(tem1+k)%10][tem2][tem3][tem4][tem5]++;
			zj[tem1][(tem2+k)%10][tem3][tem4][tem5]++;
			zj[tem1][tem2][(tem3+k)%10][tem4][tem5]++;
			zj[tem1][tem2][tem3][(tem4+k)%10][tem5]++;
			zj[tem1][tem2][tem3][tem4][(tem5+k)%10]++;
			//相邻转
			zj[(tem1+k)%10][(tem2+k)%10][tem3][tem4][tem5]++;
			zj[tem1][(tem2+k)%10][(tem3+k)%10][tem4][tem5]++;
			zj[tem1][tem2][(tem3+k)%10][(tem4+k)%10][tem5]++;
			zj[tem1][tem2][tem3][(tem4+k)%10][(tem5+k)%10]++;
		}
	}
	for(int a=0;a<=9;a++)
		for(int b=0;b<=9;b++)
			for(int c=0;c<=9;c++)
				for(int d=0;d<=9;d++)
					for(int e=0;e<=9;e++)
						if(zj[a][b][c][d][e]==n)
							ans++; 
	printf("%d\n",ans);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

首先，这个密码锁，我们研究后就会发现：

设当前数字为 $a$，转 $k$ 下，则对应的数字就为 $(a+k) \bmod 10$。

那我们就可以按照题目模拟。那我们拿到一个状态，就可以模拟它的所有可能的正确答案，当我们把的状态对应的所有可能的正确密码取个交集，集合中元素的数量就是答案。

~~但是我考场上用了 `lock` 作为我存状态的变量名，导致我完美的 CE 了，于是乎我 T1 100pts -> 0pts。~~

---

## 作者：hjqhs (赞：2)

简单 T1。记数组 $cnt_{a,b,c,d,e}$ 为数字 $(a,b,c,d,e)$ 的密码锁出现次数。对于每个密码锁，直接枚举出所有它可以变成的数字。最后将 $cnt$ 所有值为 $n$ 的数累加进答案即可。  
考场屎山代码：
```cpp
#include<bits/stdc++.h>
//#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int N=11;
const int MOD=998244353;
const int INF=0x3f3f3f3f;
int n,ans;
struct node{
	int a[6];
}l[N];
int cnt[11][11][11][11][11];
//map<node,int>mp;
int calc(node t){
	return cnt[t.a[1]][t.a[2]][t.a[3]][t.a[4]][t.a[5]];
}
void print(node t){
	rep(i,1,5)cout<<t.a[i]<<' ';
	cout<<calc(t);
}
void make(int aa,int bb,int cc,int dd,int ee){
	node t;
	t.a[1]=aa,t.a[2]=bb,t.a[3]=cc,t.a[4]=dd,t.a[5]=ee;
	node tmp=t;
	rep(i,1,5){
		rep(j,1,9){
			tmp.a[i]=(tmp.a[i]+j)%10;
			++cnt[tmp.a[1]][tmp.a[2]][tmp.a[3]][tmp.a[4]][tmp.a[5]];
//			print(tmp);cout<<'\n';
			tmp=t;
		}
	}
	rep(i,1,4){
		rep(j,1,9){
			tmp.a[i]=(tmp.a[i]+j)%10;
			tmp.a[i+1]=(tmp.a[i+1]+j)%10;
			++cnt[tmp.a[1]][tmp.a[2]][tmp.a[3]][tmp.a[4]][tmp.a[5]];
//			print(tmp);cout<<'\n';
			tmp=t; 
		}
	}
}
void solve(){
	cin>>n;
	rep(i,1,n)rep(j,1,5)cin>>l[i].a[j];
	if(n==1){
		cout<<81;
		return;
	}else{
//		cout<<'\n';
		rep(i,1,n){
			make(l[i].a[1],l[i].a[2],l[i].a[3],l[i].a[4],l[i].a[5]);
//			cout<<'\n';
		}
		rep(i,0,9)rep(ii,0,9)rep(iii,0,9)rep(iiii,0,9)rep(iiiii,0,9){
			if(cnt[i][ii][iii][iiii][iiiii]==n)++ans;
		}
		cout<<ans;
	}
} 
signed main(){
//	freopen("lock.in","r",stdin);
//	freopen("lock.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}

```

---


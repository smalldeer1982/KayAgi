# 鸡蛋饼

## 题目背景

Czyzoiers 都想知道小 x 为什么对鸡蛋饼情有独钟。经过一番逼问，小 x 道出了实情：因为他喜欢圆。

## 题目描述

最近小 x 又发现了一个关于圆的有趣的问题：在圆上有 $2N$ 个不同的点，小 x 想用 $N$ 条线段把这些点连接起来（每个点只能连一条线段），使所有的线段都不相交，他想知道这样的连接方案有多少种？

答案对 $10^8+7$ 取模。

## 样例 #1

### 输入

```
24```

### 输出

```
4057031```

# 题解

## 作者：WHUSHZ (赞：44)

### 题目分析
#### 特例分析
我们先来考虑 $4$ 个点的情形
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015031550910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjMyODg1,size_16,color_FFFFFF,t_70)

显然有以下 $2$ 种方案：[$AD$，$BC$]，[$AB$，$CD$]. 

再考虑一下 $6$ 个点的情形

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015032129103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjMyODg1,size_16,color_FFFFFF,t_70)

其实由于连线不会相互交叉，每一次连线，相当于在饼上切了一刀，将饼分为两部分，我们可以照着操作一下。

首先假设我们第一刀切 $BE$，那么这块饼分成了两部分，一部分上还有4个点可供切割，另一部分0个点可供切割，而由于 $BE$ 已经被切过，这两个点接下来应该不计入考虑，事实上我们把问题分解成了两部分，即圆上4个点和圆上0个点的情形. 
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191015033413139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjMyODg1,size_16,color_FFFFFF,t_70)

这一种情形下的切法数为 $2\times 1=2$ 种. 

如果第一步沿 $EC$ 或者 $ED$ 切，则连不满 $N$ 根线. 

如果第一步沿 $EA$ 切，则切法仍为$2\times 1=2$ 种.

如果第一步沿 $EF$ 切，显然只剩下 $1$ 种. 

显然我们已经算完了所有不重复的结果，因此 $6$ 个点时有 $5$ 种方法.
#### 一般情况
那么如果有 $2N$ 个点呢？ 

根据以上我们得出，如果第一刀，使得分成的两半上均只有奇数个点，将连不满 $N$ 根线，换言之，此时满足要求的切法为 $0$. 

假设，圆上有  $2k$ 个点时，切法为 $f(k)$，那么根据第一刀分成的左右两边的点的个数，由加法原理以及乘法原理可以得到
$$
f(N+1)=f(0)f(N)+f(1)f(N-1)+\dotsm+f(N)f(0). 
$$

这里注意，一旦点的分布确定了，第一刀左侧为$N$，右侧为 $0$和左侧为 $0$，右侧为 $N$ 将指向不同的结果，看我们之前对于 $6$ 个点的情况分析，我们先取定一个点作为初始点，事实上这个点是任意选的，假定点的编号从小到大顺时针排序，连  $A_1A_2$ 即为左 $N$ 右 $0$，连 $A_1A_{N+1}$ 则相反. 可以看出，前者的组合里面，无论哪一种，都不可能含有 $A_1A_{N+1}$，而后者的组合也都不可能含有  $A_1A_2$，因此这两种方案是不同的. 


那么既然初始点的选择是任意的，我们是否需要为此乘上 $2N$ 或者 $N$ 之类的系数呢？

我们还是回到 $6$ 个点的分析中去，倘若我们选择 $BC$ 作为第一刀，结果又将如何呢？答案是结果完全一样，无论是数量还是切法，都将保持一致. 

我们以集合的角度进行思考，一种切法中的所有弦构成一个集合，所有的切法集合构成全集 $U$，所以其实定弦是一种遍历的方式，首先圆上所有的点都要被连到，那也就意味着所有的切法里面必然含有所有点，那么如果我们选定一个有特征的点 $A$，作为起始点，这个起始点是非特异的，而作为 $A$ 这个点而言，和周围的点也只有 $N$ 种连接方式，我们考虑了这 $N$ 种连接方式的全体，相当于是对这个集合做了一次遍历，既然是遍历，也即意味着选一个点即可计算出全体，而不是一种特例，所以不用乘以任何系数。

所以本道题的答案就是第 $N$ 个卡特兰数. 贴上AC代码吧。
```cpp
#include<iostream>  
#include<cstring>
using namespace std;  
int main() {  
    unsigned long long ctl[32768], i, j, k, n;  
    memset(ctl, 0, sizeof(ctl));  
    ctl[0] = ctl[1] = 1;ctl[2] = 2;  
    cin >> n;  
    for (i = 3; i <= n; ++i)  
        for (j = 0; j < i; ++j) {  
            ctl[i] += ctl[j] * ctl[i - j - 1];  
            ctl[i] %= 100000007;  
        }  
    cout << ctl[n];  
    return 0;  
}
```


---

## 作者：Fan_Keyou (赞：35)

#### 可忧君的题解~

这题**~~`或许`~~**是卡特兰数吧

那么 卡特兰数 是什么尼？

**卡特兰数** 又称 卡塔兰数 ， 卡特兰数 是 组合数学 中一个常出现在各种 计数问题 中的数列。以比利时的数学家 `欧仁·查理·卡塔兰` 的名字来命名。

卡特兰数$C_{n+1}$满足以下递推关系：

$C_{n+1} = C_1*C_n + C_2*C_{n-1} + C_3*C_{n-2} + …… + C_{n-1}*C_2 + C_n*C_1$

而 卡特兰数 前几项为：
1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324 ……

> [还不懂的点我](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin)



---

理由如下：

那这道题为毛是 卡特兰数 尼？

那么假如我们在圆上画了2n个点，顺时针编号为1,2,3,4……，你便会发现，如果一个奇数点和另一个奇数点相连，一定会造成将剩下所没有连线的点分在两边的都是奇数个，而后两边必定有一个点没线连或穿越其中的一条线，那么就不可能完成了。那么我们可以把奇数点看成左括号，偶数点看成右括号，然后把圆切开，就变成了一个括号匹配的方案数问题。为什么圆可以切开呢？因为A连B和B连A是同一种切法。

在这里可以用h(n)=C(2n,n)/(n+1),用扩展欧几里德求逆元。

---

贴代码：

```cpp
#include <bits/stdc++.h> //万能头文件
using namespace std;

#define new_while(i, a, b) for(register int i = a; i <= b; ++i)  //register：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率，注意是尽可能，不是绝对
#define ll long long int
#define mod 100000007   //题目中的mod

ll eeie(ll a, ll c);

ll list_a[1000010] = {1, 1}, n;

int main()
{
    cin>>n;
    new_while(i, 2, n<<1)
        list_a[i] = (list_a[i - 1] * i) % mod;
    printf("%lld\n", (((list_a[n<<1]/*比如原来n是8,它的二进制数为01000,进行>>1右移一位后就是00100,4了~*/%mod)*eeie(list_a[n+1],mod-2))%mod*eeie(list_a[n],mod-2))%mod);
    return 0;
}

ll eeie(ll a, ll c)
{
    long long b = 1;
    while (c > 0)
    {
          if(c & 1)   //if (A & B) 如果 A 为 false ，整个表达式就为 false，但还要计算 B 的值。
            b = (b * a) % mod;
          c >>= 1;   //详见第 26 行注释
          a = (a * a) % mod;
    }
    return b;
}

```

`这是我的第一个题解，多见谅！`

---

## 作者：菰冭 (赞：13)

如果你不会任何数论也不会任何打扩展欧几里得求逆元

只会傻乎乎的打ans%100000007

那么python大法好！

附代码：
```python
n=int(input())
if n==0:
    print('0')
    exit()
if n==1:
    print('1')
    exit()
h1 = 1
int(h1)

for i in range(n+1):
    if i>=2:
        h = int(h1*(4*i-2)//(i+1))#//是取整，如果用/会输出nan（python中float的精度只有10^308，超过会输出inf）
        h1 =int( h)
        h2 = int(h)
h3 =h2%100000007
print(h3)
```
2333333

---

## 作者：All_Hail_Lelouch (赞：8)

Catalan数  卡特兰数

Catalan数的定义令h(1)=1，Catalan数满足递归式：h(n) = h(1)\*h(n-1) + h(2)\*h(n-2) + ... + h(n-1)h(1)，n>=2该递推关系的解为：h(n) = C(2n-2,n-1)/n，n=1,2,3,...（其中C(2n-2,n-1)表示2n-2个中取n-1个的组合数）

代码如下↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,k,n;
long long l[10000];
int main(){
    cin>>n;
    l[0]=1;
    l[1]=1;
    for(i=2;i<=n;i++)
    for(j=0;j<=i-1;j++)
      l[i]=(l[j]*l[i-j-1]%100000007+l[i])%100000007;
    cout<<l[n];
}
```

---

## 作者：NewSjf (赞：5)

逛了一圈发现好像没有O(N)的解法   
卡特兰数可以O(N)递推  
f[i+1]=(4 * i-6) * f[i]/i (from 刘汝佳) O(N)      
然后逆元inv[i]=p-(p/i) * inv[p%i]%p     O(N)    
那么显然f[i+1]=((4*i-6)*f[i]*inv[i])%p  O(N)   
于是我们愉快的O(N)解决了它    
代码很短,跑得也快呢    
~~好像不太需要什么注释了把...~~
```cpp
#include<stdio.h>
long long f[30000],inv[30000],n,p=100000007;
int main()
{
	scanf("%lld",&n);
	f[1]=f[2]=inv[1]=1;
	for(int i=2;i<=n+10;i++)inv[i]=(p-p/i)*inv[p%i]%p;
	for(int i=2;i<=n+3;i++)f[i+1]=((4*i-6)*f[i])%p*inv[i]%p;
	printf("%lld",f[n+2]);
}
```


---

## 作者：litble (赞：5)

为什么这题是卡特兰数呢？

大家都知道，括号匹配的方案数就是卡特兰数对吧（因为我们要考虑在第一个左括号匹配的右括号前面和后面各有多少个匹配的括号，所以就是卡特兰数的其中一个公式h(n)=h(0)\*h(n-1)+h(1)\*h(n-2)+...+h(n-1)\*h(0)）。

那么假如我们在圆上画了2n个点，顺时针（或者逆时针）编号1，2，3...，你就会发现，如果一个奇数点和一个奇数点相连，一定会造成将剩下没有连线的点分成两边都是奇数个，那么就不可能完成任务了。那么我们可以把奇数点看成左括号，偶数点看成右括号，然后把圆“剪开”，就变成了一个括号匹配的方案数问题。为什么可以“剪开”呢？因为A点连B点和B点连A点是同一种方案。

所以我们就用卡特兰数吧。

我的方法是卡特兰数的组合数公式：h(n)=C(2n,n)/(n+1),所以要用扩展欧几里德求逆元。如果你不会逆元的话，也可以用递推公式做，其他题解里有。

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
LL mod=100000007;
int n;
void exgcd(LL a,LL b,LL &x,LL &y){//扩欧求逆元
    if(!b){x=1,y=0;return;}
    exgcd(b,a%b,x,y);LL tmp=x;
    x=y,y=tmp-(a/b)*y;
}
LL s=1,xi=1;
int main()
{
       LL x,y;
       scanf("%d",&n);
       for(int i=n+1;i<=n*2;i++)s=(s*i)%mod;//根据组合数公式求分数线以上部分
       for(int i=1;i<=n;i++)xi=(xi*i)%mod;
       xi=(xi*(n+1))%mod;//根据组合数公式求分数线以下部分
       exgcd(xi,mod,x,y);x=(x%mod+mod)%mod;
       printf("%lld",(s*x)%mod);//最后乘上逆元
    return 0;
}
```

---

## 作者：teafrogsf (赞：3)

关于卡特兰数的定义和概念，本题解不再赘述，楼下的几位大佬们已经讲得很清楚了。

这里给出**快速幂**求逆元的代码。~~【终于不用写扩欧了~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define f(i,a,b) for(register int i=a;i<=b;++i)
#define ll long long
#define mod 100000007
ll cal[1000010]={1,1},n;
ll slowpow(ll m,ll n)
{
    long long b=1;
    while (n > 0)
    {
          if(n&1)b=(b*m)%mod;
          n>>=1;
          m=(m*m)%mod;
    }
    return b;
} 
int main()
{
    ll x,y;
    scanf("%lld",&n);
    f(i,2,n<<1)cal[i]=(cal[i-1]*i)%mod;
    printf("%lld\n",(((cal[n<<1]%mod)*slowpow(cal[n+1],mod-2))%mod*slowpow(cal[n],mod-2))%mod);
    return 0;
}
```

---

## 作者：Xie_BR (赞：2)

# 卡特兰数
首先，对于如此之类的问题，我们可以想一想关于卡特兰数的一些东东，~~（我不会告诉你其实标签说明了一切）~~  
然后让我们来看看具体操作：  
### 首先：  
对于卡特兰数，我们可以首先初始化一下，主要是通过一个（o（n^2））的算法来实现卡特兰数的初始，此处我们可以建一个a[]数组，在存储卡特兰数，具体代码操作如下：  
```cpp
	a[0] = 1;
	for(int i=1;i<=n+1;i++)
	{
		for(int j=0;j<=i;j++)
		{
			a[i] = (((a[j]*a[i-j-1]%mod)+a[i]%mod)%mod);
		}
	}
```

PS：这里我们需要在边加边取模，~~因为本题要求我们这样做~~QAQ，不然，后果自负。。。  

最后当我们已然初始化完毕之后，也就是最复杂的工序完工后，我们所需要的是找到n的卡特兰数，也就是很简单的赋值过程。。。  

于是，我们来到了激动人心的AC代码时刻！  
# AC 代码：  
PS：本蒟蒻因为懒，就不写注释了，~~怕妨碍大佬们阅读Orz~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define int long long
#define MK 1000010
const int mod = 100000007;
using namespace std;
int n;
int a[MK];

signed main()
{
	scanf("%lld",&n);
	a[0] = 1;
	for(int i=1;i<=n+1;i++)
	{
		for(int j=0;j<=i;j++)
		{
			a[i] = (((a[j]*a[i-j-1]%mod)+a[i]%mod)%mod);
		}
	}
	int ans = a[n];
	printf("%lld\n",ans);
	return 0;
}
```

# ：）

---

## 作者：萝卜 (赞：2)

其实就是卡特兰数，加入取模操作就好了。



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
unsigned long long h[10005];
int main(){
    cin>>n;
    int ans;
    h[0]=1;h[1]=1;
    for(int i=2;i<=n;i++)
     {
         for(int j=1;j<=i;j++)
          {
              h[i]=(((h[j-1]*h[i-j])%100000007)+h[i])%100000007;
          }
     }
    ans=h[n]%100000007;
    cout<<ans;
}
```

---

## 作者：Daidly (赞：1)

其实这道题理解了逻辑思路,就可以写出来了。


------------

其实这道题理5先,题目中要求我们使所有的线段都不相交,而且在圆上有2n个不同的点。这就涉及到一个知识叫卡特兰数。卡特数大概就是这个形式：
$C_{n+1}=C_0C_n+C_1C_{n-1}+......+C_nC_0$


------------

设$h(n)$为卡特兰数的第$n+1$项，令$h(0)=1,h(1)=1$，卡特兰数满足递推式：

$h(n)= h(0)h(n-1)+h(1)h(n-2) + ... + h(n-1)h(0)$

**但前提是$(n>=2)$**。

例如：$h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2$
$h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5$

卡特兰数的前几项是$1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...$

发现他们$mod100000007$后正好与题目相符。
所以，这道题马上就解出来了。


------------
$AC$代码：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{   ios::sync_with_stdio(false);//黑科技加速
   cin.tie(0);
   cout.tie(0);
	int n;
	long long a[3005]={1,1};//前提是(n>=2)，且第一项和第二项都为1
	cin>>n;
	for(register int i=2;i<=n;i++)//因为有众多两项乘积之和，所以用两次，register为加速和科技
	{for(register int j=0;j<i;j++)
			a[i]+=a[j]*a[i-j-1];//运用卡特兰数递推式
		a[i]%=100000007;//这里要先mod，要不然的话只能得60分
	}
	cout<<a[n];//输出第n项
	return 0;
}
```
完美结束，谢谢大家！


---

## 作者：Reanap (赞：1)

#     蒟蒻小算法
   我们在饼子上设一点k，并连接点1和点k，将大鸡蛋饼分成两个小鸡蛋饼
   
   并将两个鸡蛋饼的方案数相乘（乘法原理），就是连接点1和点k的所有方案数
    
   综上，我们有两步去做：
   
   1、推出n之前的全部状态
    		    
                        
    2、枚举每一个点k的可能
    
    
    #include <cstdio>
    #include <cstring>
    long long a[6005]; 
    //开个longlong，因为涉及到乘法，唯恐中途炸了，开个
    longlong防备一下不亏（~~我好蒟蒻吖~~）
    int main() {
        int n;
        scanf("%d",&n);
        a[0]=1;
        a[1]=1; // 递推边界
        for(int i=2;i<=n;i++) { //解决n之前的状态
            for(int k=0;k<=i-1;++k) { // 枚举k的情况，以计算
                a[i]=(a[k]*a[i-k-1]%100000007+a[i])%100000007;
            }
        }
        printf("%lld",a[n]);
        return 0;
    }

---

## 作者：封禁用户 (赞：1)

###卡特兰数...但楼下两位给出的是递推关系式'''''''令h(0)=1,h(1)=1，catalan数满足递推式:


h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)h(0) (n>=2)''''''而不是“h(n)=C(2n,n)/(n+1) ” 如果用这个通解来做貌似会在边乘边模的过程中爆掉

附上Pascal代码（其实我觉得可以不开数组）


```cpp
var i,j,k,l,n,m:longint;
 **   a:array[1..10005] of int64;
begin
  readln(n);    a[0]:=1;a[1]:=1;
  for i:=2 to n do
    for j:=0 to i-1 do
      a[i]:=((a[j]*a[i-j-1])mod 100000007+a[i])mod 100000007;
  writeln(a[n]);
end.**

```

---

## 作者：化学小哥 (赞：1)

Catalan数——卡特兰数

详见 p1044 栈


```cpp
#include<cstdio>
using namespace std;
const int maxn=10005;
long long catalan[maxn];int n;
int main()
{
    catalan[0]=catalan[1]=1;
    scanf("%d",&n);
    for (int i=2;i<=n;i++)
     for (int k=0;k<i;k++)
     {catalan[i]=((catalan[k]*catalan[i-k-1])%100000007+catalan[i])%100000007;}
    printf("%d",catalan[n]);
}
```

---

## 作者：YoungLove (赞：0)

[Youngsc](http://youngscc.github.io/)

###来一波分解质因数的

很显然这是 ~~卡特兰数~~。

卡特兰数的求法很多，其他题解都有涉及。

递推公式 $$ f(n) = C(n,2n)/(n+1) $$


在取膜意义下就比较麻烦了，我们可以用质因数分解的方式。

因为乘法是一个数的所有因数在答案中多出现，除法是一个数的因数在答案中少出现。

所以我们可以根据公式来计算每一个质因数出现的次数，最后用快速幂乘起来就是答案。

如果是一个常数，每次是这出一下统计就好了。

如果是 $$ n! $$ 分解的话，因为各个数都是连续的，所以用n一直除以某个质数，并把商做一个累和，这个和就是这个质数在阶乘中出现的次数。

证明很简单，因为是连续的，设这个质数为p，所以含有这个质数的有p,2p,3p...也就是说每p个书中就有一个数是p的倍数，当用n/p后商就是当前p出现的次数。然后你会得到一个新的阶乘 $$ (n/p)! $$，在用相同的方法一直加和。

不太会算复杂度，但肯定小于 $$ n^2 $$。

##代码如下


~~丑莫吐槽~~


```cpp

# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# define R register
# define LL long long
# define mod 100000007

using namespace std;

int n,pri[2010],p,num[2010],ans=1;
bool v[6010];

inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline int powe(R int x,R int r){
    R int ret=1;
    while(r){
        if(r&1) ret = ret*x%mod;
        if(r>1) x = x*x%mod;
        r>>=1;
    }
    return ret;
}

inline int youngsc(){
    in(n);
    for(R int i=2; i<=(n<<1); ++i)
    {
        if(!v[i]) pri[++p] = i;
        for(R int j=1; j<=p&&pri[j]*i<=(n<<1); ++j)
        {
            v[pri[j]*i] = 1;
            if(i%pri[j] == 0) break;
        }
    }
    for(R int i=1; i<=p; ++i)
    {
        R int d = n<<1;
        while(d)
        {
            num[i]+=d/pri[i];
            d/=pri[i];
        }
        d = n;
        while(d)
        {
            num[i]-=((d/pri[i])<<1);
            d/=pri[i];
        }
    }
    R int d=n+1;

    for(R int j=1; j<=p&&d>1; ++j)
        while(d%pri[j] == 0) d/=pri[j],num[j]--;
   
 for(R int i=1; i<=p; ++i)
        ans = 1LL*ans*powe(pri[i],num[i])%mod;
    printf("%d",ans);
}

int yg = youngsc();
int main(){;}
 ```
（减少代码复制，创建美好洛谷）


---


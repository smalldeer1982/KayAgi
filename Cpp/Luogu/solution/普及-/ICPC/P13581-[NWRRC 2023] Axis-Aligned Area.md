# [NWRRC 2023] Axis-Aligned Area

## 题目描述

Alex 有四根长度为正整数的木棍，分别为 $a_1$、$a_2$、$a_3$ 和 $a_4$，且满足 $a_1 \le a_2 \le a_3 \le a_4$。

她想把这四根木棍放在平面上，使得每根木棍都平行于坐标轴中的某一条轴，并且被这些木棍围成的面积尽可能大。

请你求出能够围成的最大面积。

## 说明/提示

以下是第一个样例的一种最优摆放方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/u97ufdde.png)

灰色部分为被围成的面积。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
2
4
7```

### 输出

```
8```

## 样例 #2

### 输入

```
10
10
10
10```

### 输出

```
100```

# 题解

## 作者：ryf2011 (赞：3)

# 1.题目思路
由于只有四根木棒，又要求每根木棒都与两条坐标轴中的一条平行，还要求围成封闭区域，再结合样例解释，我们发现，围成的封闭区域一定是一个长方形（包含正方形）。

而长方形有一个重要的性质：**有两组对边，且对边长度相等**。

而由于四根木棒必须全部使用，为了保证封闭面积最大，我们要减少木棍长度的浪费，即让长方形两条对边的长度差的绝对值尽量小。

再看题面，发现 $a$ 数组是非递减的，这启发我们让 $a[1],a[2]$ 为一组对边，让 $a[3],a[4]$ 为另一组对边。这样既保证了对边长度之差的绝对值最小，又最小化了长度的浪费，使封闭面积最大，为最优的方式。

分组完成后，容易发现此时的答案即为 $\min(a[1],a[2]) \times \min(a[3],a[4])$，因为无法规避短边对答案的影响（不能拿长边去覆盖短边，这样图形将无法封闭，所以此时必然会有浪费，但这不可避免）。答案直接输出即可。

# 2.代码
是的，代码真的很短。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[5];
int main(){
    for(int i=1;i<=4;i++){
        scanf("%d",&a[i]);
    }
    printf("%d\n",min(a[1],a[2])*min(a[3],a[4])); //计算答案
    return 0;
}
```

# 3.后记
更多内容，请移步至：

1. [$\color{red}\texttt{Luogu ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")；
2. [$\color{orange}\texttt{cnblogs（博客园） cnblogs2011ryf}$](https://www.cnblogs.com/cnblogs2011ryf)。

---

## 作者：GSQ0829 (赞：1)

### 题目大意：
有四根长度为正整数的木棍，分别为 $a_1$、$a_2$、$a_3$ 和 $a_4$，且满足 $a_1 \le a_2 \le a_3 \le a_4$。

把这四根木棍放在平面上，使得每根木棍都平行于坐标轴中的某一条轴，并且被这些木棍围成的面积尽可能大。

请你求出能够围成的最大面积。

---
### 解题思路：
我们可以知道，最后的图形一定是正方形或者长方形。

所以，我们就要求出这个图形的长与宽。

因为只有四根木棍，所以我们可以用枚举的方式。每次将四根木棍分为两组，每组两根。接下来，计算出每组里面较小的一根木棍的长度（因为这个图形的边长由两根当中较短的木棍的长度决定），然后把这两根的长度相乘就可以得到一个面积。

而我们也可以发现，将这四根木棍分成两组，每组两根。这样的形式的组合总共有三组：$a_1,a_2$ 和 $a_3,a_4$、$a_1,a_3$ 和 $a_2,a_4$、$a_1,a_4$ 和 $a_2,a_3$。我们只要算出这三组最终围成的面积，再从这三组答案中选出最大的一组，这就是最终的答案了。

---
### 代码：
接下来给出本题的代码以及注释：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b, c, d, as1, as2, as3;

int main() {
	cin >> a >> b >> c >> d;
// 算出三种组合方式分别围成的面积
	as1 = min(a, b) * min(c, d);
	as2 = min(a, c) * min(b, d);
	as3 = min(a, d) * min(b, c);
	cout << max(as1, max(as2, as3)); // 从这三组当中取出最大值
	return 0;
}
```

---

## 作者：yaoying2012 (赞：1)

## P13581 [NWRRC 2023] Axis-Aligned Area 题解

[题目链接](https://www.luogu.com.cn/problem/P13581)

### 题目大意

给定四个正整数 $a_1, a_2, a_3, a_4$，满足 $1 \le a_1 \le a_2 \le a_3 \le a_4 \le 100$。需要将这四根木棍放置在平面上，每根木棍平行于坐标轴（即水平或垂直放置），求它们能围成的最大矩形面积。

### 解题思路

要最大化围成的矩形面积，我们需要合理分配木棍作为矩形的长和宽。关键观察如下：

1. 矩形需要两条水平边和两条垂直边，因此我们需要选择两根木棍作为水平方向，另外两根作为垂直方向。
2. 为了最大化面积，应该让水平方向和垂直方向的长度尽可能大。
3. 由于木棍长度已经按非递减排序，最优策略是将最短的两根木棍分配给一个方向，最长的两根分配给另一个方向。

具体来说：
- 水平方向选择 $a_1$ 和 $a_2$，实际长度为两者的最小值（$\min(a_1, a_2)$）。
- 垂直方向选择 $a_3$ 和 $a_4$，实际长度为两者的最小值（$\min(a_3, a_4)$）。
- 最大面积为这两个最小值的乘积。

### 正确性证明

假设我们采用其他分配方式，比如将 $a_1$ 和 $a_3$ 分配给一个方向，$a_2$ 和 $a_4$ 分配给另一个方向。此时面积为 $\min(a_1, a_3) \times \min(a_2, a_4) = a_1 \times a_2$。而原策略的面积为 $a_1 \times a_3$。由于 $a_3 \ge a_2$，原策略不会更差。类似可以证明其他分配方式不会更优。

### 代码实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int a1, a2, a3, a4;
    cin >> a1 >> a2 >> a3 >> a4;
    cout << min(a1, a2) * min(a3, a4) << endl;
    return 0;
}
```

### 复杂度分析

- 时间复杂度：$O(1)$，只有简单的输入输出和比较操作。
- 空间复杂度：$O(1)$，只使用了固定数量的变量。

---

## 作者：abc1234shi (赞：1)

# 分析
数学题。
# 思路
因为每根木棒与两条坐标轴中的一条平行。

所以这个图形就是两组对边都平行的图形，那不就是长方形吗？

每根木棍只能用 $1$ 次且不能切割。

题目要求所给的 $4$ 根木棍所构成的长方形的最大的面积。

首先我们考虑使长尽量长。如果我们选择最长的那一根，有可能出现此边的对边无法达到这个长度，无法构成长方形，所以我们只能选择第二长的那一根。

再考虑宽。因为最长和第二长的木棍都用完了，只剩下最短和第二短的木棍了。与选择长的时候一样，如果选择较长的那根，如果此边的对边达不到这个长度就不能构成长方形，所以只能选择最短的那根。

因为长方形的面积是长 $×$ 宽，所以题目要求的最大的面积就是第二长的木棍 $×$ 最短的木棍。
# 思路实现
先将输入的 $a$ 从小到大排个序，输出 $a_1 × a_3$ 即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]; 
int main() {
	for(int i=1;i<=4;i++){
		cin>>a[i];
	}
    sort(a+1,a+4+1);
    cout<<a[1]*a[3];
	return 0;
}
```

---

## 作者：BlackHoles (赞：1)

### 正解

不妨设以 $a_1$ 为基准，分三种情况进行讨论。

当 $a_1$ 与 $a_2$ 平行时，$a_3$ 与 $a_4$ 平行，答案显然为 $\min(a_1, a_2) \times \min(a_3, a_4)$；当 $a_1$ 与 $a_3$ 平行时，$a_2$ 与 $a_4$ 平行，答案显然为 $\min(a_1, a_3) \times \min(a_2, a_4)$；当 $a_1$ 与 $a_4$ 平行时，$a_2$ 与 $a_3$ 平行，答案显然为 $\min(a_1, a_4) \times \min(a_2, a_3)$。

最终答案就是这三个答案的最小值。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int a1, a2, a3, a4;
int res1, res2, res3, ans;
int main(void) {
	cin >> a1 >> a2 >> a3 >> a4;
	res1 = min(a1, a2) * min(a3, a4), res2 = min(a1, a3) * min(a2, a4), res3 = min(a1, a4) * min(a2, a3);
	ans = max(res1, max(res2, res3));
	cout << ans;
	return 0;
}
```

谢谢大家！

---

## 作者：1145141919homo (赞：0)

# P13581题解
## 题目大意
给定四个长度分别为 $a_1$、$a_2$、$a_3$、$a_4$ 的木棍围成一个四边均与某坐标轴平行的矩形。其中 $a_1$、$a_2$、$a_3$、$a_4$ 已经按非降序排序。

### 题意分析

~~观察样例很明显就能看出来了。~~
我们知道四条边中任取几条边组成的图形显然只能是三角形或四边形。
显然三角形任意任意两边不可能平行，因为三角形的任意两边交于一个顶点。
那么这个图形只能是矩形了。

## 解题分析
有点思维含量，但不多。

先考虑从长方形入手。因为长方形对边相等，这里很容易发现，长的木棍的对边一旦比它短，那么这组对边的长度均为较短的那条边。

这是因为如果这组对边比组成它们的最短木棍的长度还长的话，那么对边就补不齐对边长度，自然不是封闭图形。若比组成它们的最短木棍的长度还短的话，面积又比上述方法小。

我们发现题目中已经按非严格升序排序 $a_1$、$a_2$、$a_3$、$a_4$，即 $a_1\le a_2 \le a_3 \le a_4$，那么我们有下列几种组合方式：

1. $a_1$、$a_2$ 分为一组对边，$a_3$、$a_4$ 分为另一组对边。
此时长方形长为 $a_3$，宽为 $a_1$。

1. $a_1$、$a_3$ 分为一组对边，$a_2$、$a_4$ 分为另一组对边。
此时长方形长为 $a_2$，宽为 $a_1$。因为 $a_3 \gt a_2$，显然没有第一种情况面积大。

1. $a_1$、$a_4$ 分为一组对边，$a_2$、$a_3$ 分为另一组对边。
此时长方形长为 $a_2$，宽为 $a_1$。同理，同样不是最优解。

综上，答案就是最小值乘次大值，也就是 $a_1\times a_3$。

## 代码

那么，就把代码放出来了：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int a[10];
	for(int i = 1;i <= 4;i++){
		cin >> a[i];
	}
	cout << a[1] * a[3];
	return 0;
}
```

---

## 作者：Doraeman (赞：0)

## 题意与分析
给出 $4$ 根木棍，求它们所能围成的最大的封闭图形的面积。

当输入为 ```2 2 4 7``` 时，参考下面这张图片。
![](https://cdn.luogu.com.cn/upload/image_hosting/u97ufdde.png)  
此时，可以围成的最大的图形面积是 $8$。
## 思路
还是观察刚才这张图片，显然还有其它围法。但之所以样例的答案是围成矩形，就说明矩形在所有围法中是最佳的。

现在，我们已经确定要围成矩形。

## 矩形面积公式
大家都知道矩形面积公式是 $a\times b$，其中 $a,b$ 是长和宽。但是我们应该怎么得到矩形的长和宽呢？

假设有两条边 $x,y$ 是矩形上的对边，那么显然 $x=y$。  
现在我们有一组对边 $a_i,a_j$，不一定满足 $a_i=a_j$，那么我们就需要截断其中一条线端，使它们的长度能够满足 $a_i=a_j$。  
- 如果 $a_i\le a_j$，那么截取 $a_j$ 的长度，使 $a_j=a_i$；
- 如果 $a_i>a_j$，那么截取 $a_i$ 的长度，使 $a_i=a_j$。

总结出规律：$x=y=\min\{a_i,a_j\}$。

要求我们将 $a_1,a_2,a_3,a_4$ 分成两组，分别求组内的最小值，再求乘积（面积）。题目求面积的最大值。

## 最优分组策略
已知 $a_1\le a_2\le a_3\le a_4$。
- 如果 $a_1,a_4$ 分成一组，其余边一组，根据公式可知结果是 $S_1=a_1a_2$；
- 如果 $a_1,a_3$ 分成一组，其余边一组，根据公式可知结果也是 $S_2=a_1a_2$；
- 如果 $a_1,a_2$ 分成一组，其余边一组，根据公式可知结果是 $S_3=a_1a_3$。

$$
\because a_3\ge a_2,\ a_1>0\\
\therefore a_1a_3\ge a_1a_2\\
\therefore S_3\ge S_1=S_2
$$
综上，将 $a_1,a_2$ 分成一组，$a_3,a_4$ 分成一组是最优分组策略。  
所以求出其围成的矩形的面积，公式如下。

$$
S=\min\{a_1,a_2\}\times\min\{a_3,a_4\}=a_1\times a_3
$$

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5];
int main(){
    for(int i=1; i<=4; i++)
        cin >> a[i];
    cout << a[1]*a[3];
}
```

---


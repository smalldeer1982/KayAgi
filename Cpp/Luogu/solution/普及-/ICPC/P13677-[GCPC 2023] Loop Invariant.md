# [GCPC 2023] Loop Invariant

## 题目描述

Luna 是一位历史学家，在探索一座古老修道院的档案时，偶然发现了一卷神秘的羊皮纸。上面只有两种符号：“$\texttt{(}$” 和 “$\texttt{)}$”。很快她注意到，这串符号满足一个有趣的性质：它可以通过不断地在一个初始为空的序列中的某个位置插入“$\texttt{()}$”构造出来。历史学家们称这样的序列为*平衡序列*。图 L.1 给出了一个平衡序列的例子。

:::align{center}

![](https://cdn.luogu.com.cn/upload/image_hosting/16wf12pi.png)

一张圆形的羊皮纸。
:::

![](https://cdn.luogu.com.cn/upload/image_hosting/lm64um27.png)

:::align{center}
图 L.1：通过不断在初始为空的序列中插入“$\texttt{()}$”得到的样例输入 2。
:::

修道院的首席图书管理员最近告诉 Luna，本地区一些更为精英的修士有在圆形羊皮纸上书写的习惯。在他们看来，无法立刻分辨出这卷羊皮纸文字起始位置的人，也不配知晓其内容。因此，Luna 很快检查了羊皮纸条的左右两端。果然，羊皮纸条的左右两端完美契合，表明这张羊皮纸原本实际上是圆形的。当她将左右两端合在一起，观察现在变成圆形的羊皮纸时，她在思考，从撕裂处开始的平衡序列是否是唯一可能由撕开圆形羊皮纸得到的平衡序列。毕竟，如果连文本的起始位置都不知道，试图解读内容也毫无意义。

## 说明/提示



由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
(()())(()())```

### 输出

```
no```

## 样例 #2

### 输入

```
()(())()```

### 输出

```
(())()()```

# 题解

## 作者：2023z (赞：2)

这么~~水~~好的题怎么没人交题解呢，那我来交一篇 qwq

## 题意简述

这题题面有点抽象啊，实际上就是说给我们一个只含有 `(` 和 ` ) ` 的字符串，保证所有的括号都能配对（每个左括号都有一个右括号和它配对）。问我们能不能通过分割这个字符串来得到不同的平衡序列（即序列中所有括号都能配对），如果能就输出其中一种方案，不能就输出 `no`。（本人文笔不太好，勿喷）。

## 思路

**首先我们来观察一下样例 #1**

`(()())(()())`

如果我们要通过分割来保证它是一个平衡序列，只有一种分割法

`(()())` 和 `(()())`

因为如果从其他地方分割，比如

` (()( ` 和 ` ))(()()) `

这样就不满足不同的平衡序列。

但是如果按第一种方案分割就不能凑出与原序列不同的平衡序列，故输出 `no`。

**再来看样例 #2** 

`()(())()`

这个数据很明显，可以从第二个符号后面分割：

`()` 和 `(())()`

然后把第一段接到第二段后面，就变成了：

`(())()()`，与原序列不同，满足条件输出。

从这两个样例中我们发现了一个规律，第一组样例和第二组样例都是在一个完整的平衡序列后分割的，所以只有从一个完整的平衡序列的结尾分割才能保证分割后能组成一段平衡序列，不然分割后的序列就不能全部匹配。（~~这什么废话~~）。

---

现在我们已经可以正确的分割序列了，那怎么用这几段序列构成另一个平衡序列呢？

通过样例二发现，我们把第一位放到了最后一位。延续这种方法，再来看两组数据：

`()()()`

`()()(())`

这里的第一组明显不能变成不同的序列，而第二组可以。

因为 `()(())()` 与原序列不同，是合法的。

我们用数字来表示可能好理解一些，假设 `(())()()` 是三位数 $ 122 $ 我们把第一位移到最后一位的后面就变成了 $ 221 $ 与原来的数不同，我们发现第一位到最后一位之后，所有其他位上的数字都向前移动了一位，这样就构成了一个新的不同平衡序列（绝对与原来的不同），因为就算相同，后面的位数都向前移动了一位，只有在每一位都等于前一位的情况下移动后与原序列一样，但是这种情况就是分割的平衡序列全部相同的情况，在展示的第一组数据中就被淘汰了。

所以把第一段移动到最后面的方法是可行的。

---

那我们就用栈去寻找每一段完整的平衡序列。我们就遍历一遍原序列，每次遇到一个左括号就进栈，遇到右括号就把栈顶弹出（此时栈一定不为空，原题保证输入是平衡序列），在判断此时栈是否是为空，为空就把这一段的末尾记录下来。遍历完后，先判断所有分割出的平衡序列是否全部相等，如果全部相等就输出 `no`，否则就先输出第一段平衡序列后面的，再输出第一段平衡序列。

愉快的 [AC](https://www.luogu.com.cn/record/230642256)

**code：**

```cpp
#include <bits/stdc++.h>
using namespace std;
string s, a[500010];
stack<char> stk;
int cnt = -1, k = 1, j; //cnt 为有几个不同的平衡序列，第一段与第0段不同，所以初始值为-1，k 为平衡序列个数，j 是第一段平衡序列的末尾加1
int main() {
	cin >> s;
	int len = s.size();
	for (int i = 0; i < len; i++) { //遍历原序列
		a[k] += s[i]; //把第 k 段序列从下来方便判断
		if (s[i] == '(') stk.push(s[i]); //进栈
		if (s[i] == ')') {
			stk.pop(); //出栈
			if (stk.empty()) { //栈为空
				if (a[k] != a[k - 1]) cnt++; //如果不同 cnt++
				if (k == 1) j = i + 1; //第一段就把 j 存下来
				k++; //段数加1
			}
		}
	}
	if (!cnt) cout << "no\n"; //都相同
	else {
		for (int i = j; i < len; i++) cout << s[i]; //输出第一段后面的，因为 j 存的是第一段后面的点
		for (int i = 0; i < j; i++) cout << s[i]; //输出第一段
		cout << '\n';
	}
	return 0;
} //求过 qwq
```

---

## 作者：Fine_Dust_Z (赞：1)

### 简化题目
给出一段字符串，保证字符串以 "(" 开始并以 ")" 结束，且 "(" 与 ")" 的数量相同。

如果一个 "(" 没有被其他括号包括在内就将它与它前面的分成不同的区间。
##### 前置知识：循环同构
循环同构就是指当字符串 $S$ 满足使 $S$ 分为前后两部分：$A$、$B$ 如果 $B+A=T$ 则称 $S$ 和 $T$ 为循环同构。

将每个区间看成一个字符，一个或多个字符组成一个字符串。

如果这个字符串的所有循环同构都相同就输出 "no"，否则输出与这个字符串不同的循环同构。
### 思路
从头开始，每当 "(" 和 ")" 的数量相同时，就将它划为一个区间。

如果所有区间都相同就直接输出 "no"，否则就枚举字符串所有的循环同构。

具体做法会在代码部分有所解释。
### 代码
```
#include<bits/stdc++.h>
using namespace std;
string s[11451400];//s用来存储每个区间
string n;
map<string,bool> vis;//vis用来记录每个区间
int main(){
    cin>>n;
    int l=1,r=0,cnt=0;//l记录左括号的个数,r记录有括号的个数,cnt用来记录区间个数
    string top="(";//top用来记录当前区间
    for(int i=1;i<n.size();i++){
        if(n[i]=='(')l++;
        else r++;
        top+=n[i];
        if(l==r){//"("")"数量相同
            cnt++;
            s[cnt]=top;//s用来存储每一个区间
            vis[top]=true;//top区间存在
            top="";
        }
    }
    if(vis.size()==1){//如果只存在同一个区间说明所有的循环同构都相同
        puts("no");
        return 0;
    }
    for(int i=1;i<=cnt;i++){
        s[i+cnt]=s[i];//环状延长一倍
    }
    for(int i=1;i+cnt-1<=cnt*2;i++){//模拟所有的循环同构
        string b="";
        for(int j=0;j<cnt;j++)b+=s[i+j];
        if(b!=n){
            cout<<b;
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：yytmcjs (赞：1)

# P13677 [GCPC 2023] Loop Invariant
### 题目概括
有一串由 `(` 和 `)` 组成的字符串，括号配对。

要求在其中找到一个开头不为原字符串开头，长度与原字符串一样，且括号配对的字符串。

然而如果有多种答案需要输出开头最靠前的那个（虽然没说）。不存在则输出 `no`。
### 思路
可以想到，只有当字符串内有多个**不全相同的**括号匹配的小段，才能通过调换小段的顺序达到目的。

所以，先将读入的字符串 $S$ 分成括号匹配的小段，存入字符串数组 $S2$。然后遍历 $S2$ 中的字符串，如果全部相同则输出 `no`，否则继续。

然后从 $S2[2]$ 开始输出（默认从一位开始），最后输出 $S2[1]$ 便是答案了。

如样例中的 `()(())()` 就可以分成 `()`、`(())` 和 `()`。我们按照上述规则输出 `(())()()` 即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

string S;
string S2[1000005];		//这里要开10^6 
int flag=0;
int cnt=1;
bool isno=1;

int main(){
	cin >> S;
	for (int i=0;i<S.length();i++){		//喜闻乐见的字符串操作 
		if (S[i]=='(') flag++;
		else flag--;
		S2[cnt]+=S[i];
		if (flag==0) cnt++;
	}
	cnt--;		//这里最后多了一个，减掉 
	for (int i=1;i<cnt;i++){		//判断是否全部相等 
		if (S2[i]!=S2[i+1]){
			isno=0;
			break;
		}
	}
	if (isno) cout << "no";
	else{		//否则先输出第二位，最后输出第一位 
		for (int i=2;i<=cnt;i++) cout << S2[i];
		cout << S2[1];
	}
	return 0;
}
```
所有操作都标注在里面了，如果有不会的可以试着自己推导一下。

---

## 作者：Doraeman (赞：1)

## 大致题意
给定一个字符串 $S$（长度不超过 $10^6$），仅由 ```(``` 和 ```)``` 组成，且括号配对。  
求一个字符串 $S'$，必须括号配对。$S'$ 以 $S$ 的某个字符 $S_i$ 开头，直到 $S$ 的结尾结束，再从 $S$ 的开头开始，以 $S_{i-1}$ 结束。要求 $S'\not=S$。**在 $S'$ 符合要求时最小化 $i$**。  
即：$S'=S_{i\sim (|S|-1)}+S_{1\sim i}$（$S$ 下标以 $0$ 开头，$0\le i<|S|$，$+$ 表示字符串拼接）。  
如果不存在这样的字符串 $S'$，输出 ```no```。

注：以上加粗字体提到，要在 $S'$ 符合要求时最小化 $i$，因为**本题没有开 SPJ**（~~别问我怎么知道的~~）。
## 思路
### 分割字符串
将字符串 $S$ 分割成若干个小字符串，使每个字符串各自的括号能够配对，并且最小化各个小字符串的长度。

例：字符串 ```()(()())(())``` 被分割为 ```()```、```(()())```、```(())``` 这 $3$ 个字符串。

### 分情况讨论
#### 无解情况
显然，一定存在某些字符串 $S$，使我们找不到任何一个字符串 $S'$ 符合要求。

如果不考虑 $S'\not=S$ 的要求，单纯想要按照规定构造出一个括号配对的字符串 $S'$ 非常容易（根据刚才分割的字符串组合新的字符串）。  
但是可能无法满足 $S'\not=S$ 的要求。

观察发现：如果 $S$ 分割得到的多个字符串都相等，那么一定无法满足 $S'\not=S$ 的要求，直接输出 ```no```。

#### 有解情况
反之，如果多个字符串并非都相等，就可以得到正确的 $S'$。

由于需要最小化 $i$（$S'$ 的开头在 $S$ 中的下标），所以直接将 $S'$ 设为分割后多个小字符串中，从第二个到最后一个，再拼接第一个小字符串。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+5;

int a[N], cnt, L, R;
string s;

int main(){
    cin >> s;
    for(int i=0; i<s.size(); i++){
        if(L == R) // 此时可以分割了! 
            a[++cnt] = i, // 分割字符串端点 
            L = R = 0;
        if(!i && cnt) --cnt; // 如果a[cnt]=0, 删除无用信息 
        
        // 左右括号匹配 
        L += (s[i] == '('),
        R += (s[i] == ')');
    }
    // 最后一个也可以进行匹配 
    a[++cnt] = s.size();

	bool flag = 0;
	string head = s.substr(0, a[1]); // 分割后第一个小字符串 
    for(int i=2; i<=cnt; i++){
    	int x = a[i-1], y = a[i];
    	// s2 = s[x,y)
    	string s2 = s.substr(x, y-x); // 分割后其余小字符串 
    	if(s2 != head){ // 并非全部相等 
    		flag = 1;
    		break;
		}
	}
	
	if(!flag){ // 全部相等, 无解 
		cout << "no";
		return 0;
	} 
	
	// 有解, 最小化i, 由于i=0时S'=S, 所以i=1
	cout << s.substr(a[1]);
	cout << s.substr(0, a[1]);
}
```

---

## 作者：kill_wcz (赞：0)

6.11 是一个让我一直记忆深刻的日子……
### 题解：P13677 [GCPC 2023] Loop Invariant
---
题目大意：  

[题目](https://www.luogu.com.cn/problem/P13677)

#### 思路：  
题目看懂了吧。  
这次的问题就是判断整个字符串能否分成几个相同的平衡序列（看起来很简单）。  
总体思路就是把所有最小的平衡序列摘出来（贪心，小的可以，大的必然也可以）。  
最后再判断是否相同即可。  
所以我们得出代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s,a[1000005];
int l[1000005],r[1000005];
signed main() {
	cin>>s;
	int cnt=0,len=0,op=0;
	for(int i=0; i<s.length(); i++) {
		len++;
		if(s[i]=='(') cnt++;
		if(s[i]==')') cnt--;
		if(cnt==0) {
			op++;
			l[op]=i-len+1;
			r[op]=i;
			len=0;
		}
	}
	if(op==1) {
		cout<<"no";
		return 0;
	}
	for(int i=1; i<=op; i++) {
		for(int j=l[i]; j<=r[i]; j++) {
			a[i]+=s[j];
		}
	}
	int f=0;
	for(int i=2; i<=op; i++) {
		if(a[i]!=a[i-1]) {
			f=1;
			swap(a[i],a[i-1]);
		}
	}
	if(f==0) {
		cout<<"no";
		return 0;
	}
	for(int i=1; i<=op; i++) {
		cout<<a[i];
	}
	return 0;
}
```
特别鸣谢：

[@wuhaolinwhl](https://www.luogu.com.cn/user/1187802)（提供思路及发现题目）

---

## 作者：Zayn_Pan (赞：0)

## 题目

戳[这里](https://www.luogu.com.cn/problem/P13677)看题目。

## 思路

首先，我们要确定在哪分割。只能分割一次，所以只能在某段平衡序列的结尾和下一段的开头之间分割，因为如果在某段平衡序列中分割，会导致新形成的序列不是平衡序列。建议自己试一下。

然后我们发现，无解的情况只可能出现在所有平衡序列都相同的时候。因为这是一个环，当我们将其分割时就相当于有一部分向前平移了而另一部分向后倒序地接上了，不管怎么样都会与原本的不一样，除非所有的平衡序列都一样。举两个例子：

1. 输入序列为 `(()())(())()`，我们将它分割成 `(()())(())` 和 `()`，重新接上就是 `()(())(()())`，也就是 `()` 向前平移，然后 `(()())(())` 倒序接在后面。它与原序列不相等。

2. 输入序列为 `()()()`，我们将它分割成 `()()` 和 `()`，重新接上就是 `()()()`，也就是 `()` 向前平移，然后 `()()` 倒序接在后面。它与原序列相等。

于是问题就剩下如何输出新序列了。

我们知道，其实平衡序列就是括号完全匹配的序列，所以我们可以用先记录每个括号完全匹配的序列的结尾或者开头。输出时就把第一个移到最后或者把最后一个移到第一个即可。因为这样最方便。

那么怎么找括号完全匹配的序列呢？

我们使用栈。每次遇到一个左括号就进栈，遇到右括号就把栈顶弹出。当栈为空时表示找到一个括号完全匹配的序列。

在找的同时可以记录是否全部相同。

此时我们只用记录第一个的结尾或者最后一个的开头即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,tmp,t;
int n,cnt,f;
stack<char>q;
int main(){
	cin>>s;
	n=s.size();
	s=" "+s;
	bool flag=0;//判断是否全部相同 
	for(int i=1;i<=n;i++){
		t+=s[i];
		if(s[i]=='(')q.push(s[i]);
		if(s[i]==')'){
			q.pop();
			if(q.empty()){//只有s[i]为)时才可能是平衡序列 
				cnt++;//平衡序列的数量 
				if(cnt==1)f=i;//这里记录第一个的开头位置  
				if(tmp!=t&&cnt>1)flag=1; 
				tmp=t;
				t="";
			}
		}
	}
	if(!flag)cout<<"no";
	else{
		for(int i=f+1;i<=n;i++)cout<<s[i];
		for(int i=1;i<=f;i++)cout<<s[i];
	}
	return 0;
}
```

---


# 无穷的序列

## 题目描述

有一个序列 $A$，元素为无穷多，$A_i=\overline{1\underbrace{000\dots0}_{i-1 \text{ 个 }0}}$。有另一个无穷序列 $B$，$B=\overline{\underbrace{A_1A_2A_3A_4\dots}_{\text{第 i 个为 }A_i}}$，其中 $\overline{xy}$ 代表把 $x$ 和 $y$ 拼接在一起，更多数字同理。

这样，无穷序列 $B$ 的前若干项表示为：$\texttt{110100100010000100000}\dots$

请你找出无穷序列 $B$ 中指定位置上的数字。

## 说明/提示

对于 $100\%$ 的数据，$N \leq 1\,500\,000$，$a_i\le 10^9$。

## 样例 #1

### 输入

```
4
3
14
7
6 
```

### 输出

```
0
0
1
0
```

# 题解

## 作者：Rainey (赞：31)

这道题可以直接用数学方法做，每组循环的长度依次+1，所以第n个1前的长度为n(n-1)/2（等差数列求和），第n个1的位置为n(n-1)/2+1

附上代码：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int x;//位置
        scanf("%d",&x);
        x--;//好算点
        if(int(sqrt(x*2))*int(sqrt(x*2)+1)==x*2) printf("1\n");//sqrt(n(n-1))位于n与n-1之间
        else printf("0\n");
    }
    return 0;
}
```

---

## 作者：若如初见 (赞：21)

### 此题好像还没有一篇有严谨证明 + LaTeX数学公式的题解，那本蒟蒻就来写一写吧。  

首先不难观察到本题所给序列 $\{a_n\}$ 的规律：如果我们把所有使得 $a_i = 1$ 的下标 $i$ 记为一个单调递增的数列 $\{b_n\}$ 的话，有  

$$ b_{n+1} - b_{n} =  n  $$  

要求数列 $\{b_n\}$ 的通项，显然可以用**叠加法**。那么：  



$$b_{n+1}-b_n  = n$$  
$$b_{n}-b_{n-1}  = n-1$$  
$$...$$  
$$b_{2}-b_1  = 1$$  

  

叠加得：
$$b_{n+1}-b_1 = \sum\limits_{i=1}^{n}$$  

移项，并由等差数列前 $n$ 项和的公式得到：  

$$ b_{n+1}= \frac{n(n+1)}{2} + 1  $$  

所以数列 $\{b_n\}$ 的通项公式为：  

$$b_n= \frac{n(n-1)}{2} + 1  $$  

这样，对于一次询问给出的 $k$ ，我们只需判断方程  

$$ b_n=k $$  

有无正整数解。若有，则输出“1”，否则输出“0”。  

我们将这个方程展开，整理得：  

$$n^2-n+2-2k=0$$  

此方程有正整数解的条件显然是：  


$$\Delta = 1-4(2-2k)=8k-7>0$$  
$$\frac{1+\sqrt\Delta}{2} \in \mathbb{Z^+}\  or\ \frac{1-\sqrt\Delta}{2} \in \mathbb{Z^+}$$  


这样，就可以在 $O(1)$ 的时间内（假定自带的 $sqrt$ 函数的时间复杂度为 $O(1)$）回答每一组询问。  

代码如下：（上面解释得很详细了，就不加太多注释了）  

```cpp
#include <cstdio>
#include <cmath>
#define int long long 
int T,n;
bool check(int x){
	int delta=8*x-7;
	if(delta<0) return 0;
	int t=sqrt(delta);
	if(t*t!=delta) return 0; //判断\sqrt{\Delta}是否为整数
	return (((1+t)%2==0&&(1+t)/2>0)||((1-t)%2==0&&(1-t)/2>0));
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n);
		if(check(n)) printf("1\n");
		else printf("0\n");
	}
	return 0;
}
```


---

## 作者：素质玩家孙1超 (赞：17)

**先看一下题目给的序列：110100100010000100000…**

**我们可以比较明显的看出来：**

**第一个1与第二个1隔了0个零**

**第二个与第三个隔了2个零**

**第三个与第四个隔了3个零**

**第四个与第五个隔了4个零**

~~（人类的本质——复读机）~~

**他们的位置分别是：1，2，4，7，11...**



------------

**那么我们可以想到：**

**第i个1的位置为 X ，那么X-1一定等于1+2+3+4+...+n**

**即得到方程 X-1=n(n-1)/2;**

**那么我们如何处理呢？**

**首先我们知道X的值，我们将X自减一次，再乘2，得M=2(x-1);**

**根据二次函数求根公式可知**

**n=(-1+sqrt(4M+1))/2;**

**（n有整数解时说明此位置为1）**

**在此式子中，我们只需考虑sqrt(4M+1)是否为整数，就知道n是否有整数解;**

**即（int）sqrt(4M+1)==sqrt(4M+1)的值是否为true**

**（如果sqrt(4M+1)为整数时，那么它只可能是奇数，易知当n为小数时，M没有整数解）**

**下面上AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int R()//一开始看数据挺大的，用了读入优化
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main()
{
    int n,m;
    n=R();//读入n
    while(n--)
    {
        m=R();//读入位置
        m--;
        m+=m;
        double p=sqrt(1+4*m);
        if(p==(int)p) printf("1\n");//判断
        else printf("0\n");
    }
}
```

---

## 作者：MyukiyoMekya (赞：10)

ps:话说我这个题解的最后部分没用重复的解法为啥过不了审核

### 刚拿到这题，就想到暴力

首先先理一下暴力思路

$11010010001...$

**我们发现在第$1,2,4,7,11...$的地方为$1$**

**每两个数之差为$1,2,3,4...$**

写出暴力$for$循环

```cpp
for(int i=1;a<=1e9;++i)
	++vis[a],a+=i;
```
然后对于每一个$ai$，输出$vis[ai]$就可以了

但是，按照题意，$vis$要开到$10^9$才可以，就算是bool也只能开到$1.2*10^8$

### 于是，我们想到了$map$

**把下标进行映射**，如果不知道的同学可以查资料或跳过这个方法

```cpp
map<int,int> vis;
for(int i=1;a<=1e9;++i)
	++vis[a],a+=i;
for(int i=1;i<=n;++i)
	scanf("%d",&a),printf("%d\n",vis[a]);
```

~~交一发，AC~~

**我们发现最后一个点$TLE$了，这是因为$STL$的$map$太慢的缘故**

~~我要手写一个哈希！~~

我们可以用位运算！！！

首先，我们先知道，$unsigned$ $int$在$128MB$下大约可以开三千二百万左右

每个$unsigned$ $int$有32个b可以存储

我们来算一下：$10^9/32=31250000<32000000$

那么思路就有了，用每一个$unsigned$ $int$来存$32$个值

**取变量$a$的第$k$位，即** a>>k&1

**将变量$a$的第$k$位置$1$，即** $a=a|(1<<k)$

具体实现见代码：

```cpp
#include <cstdio>
#include <map>
using namespace std;
unsigned int vis[32000000];
int main(void)
{
	int a=1;
	int n;
	for(int i=1;a<=1e9;++i)
		vis[a>>5]=vis[a>>5]|(1<<a),a+=i;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a),printf("%d\n",vis[a>>5]>>a&1);
	return 0;
}
```

AC!

---

## 作者：用户已注销 (赞：7)

代码里全都是注释，自己看看就OK了

其实是一个很简单的初中数学问题

/\*P1759 无穷的序列\*/

/\*
是一道找规律的数学题

110100100010000100000……

每两个1之间的0的数量从0开始递增

所以将整个序列分为无限个区间

1  10  100  1000  10000  100000

标号后，显然第n个区间有n个数字

并且1只出现在每个区间的第一位

1~n累加一共是(n^2+n)/2个数字（等差数列和）

所以每一个1出现的位置一定是在(n^2+n)/2+1

所以对于每个输入的数字k，

如果对于(n^2+n)/2+1=k（ n ≥0 ）有解就是1

否则就是0

\*/

```cpp
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#define re register
using namespace std;
int n;
bool a[1500001];
bool work(int k)
{
    //( n^2 + n ) / 2 + 1 = k
    //化简即 0.5 n^2 + 0.5 n + ( 1 - k ) = 0
    //即 n^2 + n + ( 2 - 2k ) = 0
    //若有整数解，sqrt( 8k-7 ) 是奇数 
    int n = sqrt( k * 8 - 7 );
    return n * n == k * 8 - 7 and n % 2 ;
}
int main()
{
    scanf("%d",&n);
    for(re int i=1;i<=n;i++) 
    {
        re int ai;
        scanf("%d",&ai);
        a[i]=work(ai);
    }
    for(re int i=1;i<=n;i++) a[i]?printf("1\n"):printf("0\n");
    return 0;
}
```
上文是强迫症版，下文是短码版

```cpp
#include<cstdlib>
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int n,a;
bool work(int k)
{
    int n=sqrt(k*8-7);
    return n*n == k*8-7 and n%2 ;
}
int main()
{
    scanf("%d",&n);
    for(;n--;) 
    {
        scanf("%d",&a);
        printf("%d\n",work(a));
    }
    return 0;
}
```

---

## 作者：William_Fangs (赞：4)

# 暴力算法：枚举与二分
**先求出序列内所有值为 1 的位置**

**再进行二分查找所问位置是否为1**

```cpp
	scanf("%d",&n);
	a[1]=1;//序列中第 i 个 1 的位置
	a[0]=1;//序列中 1 的个数
	for(int i=2;i<1e9+10;i+=cnt)
	{
		cnt++;//间隔
		a[++a[0]]=i;
	}
```
**然后读入查询位置
进行二分查找并输出**

```cpp
for(int i=1;i<=n;i++)
{
	scanf("%d",&k1);
	int l,r;
   l=0,r=a[0];
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(a[mid]>=k1) r=mid;
		else l=mid+1;
	}
	if(a[l]==k1)
		printf("1\n");
	else
		printf("0\n");
}
```
**然后就是AC**

**完整代码**

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
using namespace std;
const int N=45000;
int a[N];
int n;
int k1;
int cnt=1;
int main()
{
	scanf("%d",&n);
	a[1]=1;
	a[0]=1;
	for(int i=2;i<1e9+10;i+=cnt)
	{
		cnt++;
		a[++a[0]]=i;
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&k1);
		int l,r;
		l=0,r=a[0];
		while(l<r)
		{
			int mid=(l+r)>>1;
			if(a[mid]>=k1) r=mid;
			else l=mid+1;
		}
		if(a[l]==k1)
			printf("1\n");
		else
			printf("0\n");
	}
	return 0;
}
```
祝各位走得更远 


---

## 作者：wz441135118 (赞：3)

这题用c++写用正常的方法当有很多组数据时可能会超时，而且会超很多。
测了一下，不能ac。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
char ch;
int main()
{
	cin>>n;
	for(register int i=1;i<=n;i++)
	{
		cin>>x;
		int k=sqrt(2*(x-1));
		if(k*(k+1)==2*(x-1)) cout<<1<<endl;
		else
		cout<<0<<endl;
	}
	return 0;
}
```



但是用Pascal一定不会超时。
```pascal
var
  i,j,n,m,k,l,x,t:longint;
begin
  readln(n);
    for i:=1 to n do
      begin
        readln(x);
        x:=(x-1)*2;
        t:=trunc(sqrt(x));
        if t*(t+1)=x then writeln(1)
        else writeln(0);
      end;
  close(input);close(output);
end.


```
但是，用c++写也是可以的，只要用上一些奇淫技巧
比如
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
char ch;
inline void R(int &x)
{	
  x=0;
  ch=getchar();
  while (ch<'0' || '9'<ch) ch=getchar();
  while ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();
}//快速读入模板
int main()
{
	R(n);
	for(register int i=1;i<=n;i++)
	{
		R(x);
		int k=sqrt(2*(x-1));
		if(k*(k+1)==2*(x-1)) cout<<1<<endl;
		else
		cout<<0<<endl;//经过测试cout比printf快
	}
	return 0;
}
```
这样就可以AC

是不是很骚啊????




---

## 作者：很简单 (赞：2)

**本蒟蒻的第一篇题解！**


------------


显然我们无法用数组记录每个位置上的数字，但我们可以记录范围内所有1的位置

可以知道每两个1位置的距离之差是递增的

### 这里介绍一种用动态数组vector的写法

vector相比数组的优点是里面放了多少元素，就用多少内存，
不像数组的大小是提前开好的

AC代码如下

```cpp
#include<cstdio>
#include<vector>//STL动态数组容器
#include<algorithm>//STL通用算法，下面lower_bound要用 
using namespace std;
vector<int>v;//用法：vector<元素类型名>动态数组名
int main() {
	int num=1;//num为1的位置
	for(int i=1; num<=1e9; i++) {//i为位置之差
		v.push_back(num);//把num放入v动态数组中
		num+=i;//下个1的位置
	}
	int n;
	scanf("%d",&n);
	while(n--) {//n大于0时循环执行，n等于0时循环结束
		int a;
		scanf("%d",&a);
		//lower_bound是c++STL中二分查找的函数
		//用法：lower_bound(要查找的左边界,要查找的右边界+1,要查找的元素)
		//返回的是>=a的第一个地址，还要减v.begin()才是相对地址 ，就跟下标差不多了
		//v.begin()迭代器中第一个元素地址
		//v.end()迭代器中最后一个元素的下一个地址，指向一个不存在元素
		int pos=lower_bound(v.begin(),v.end(),a)-v.begin();
		if(v[pos]==a)printf("1\n");//找得到
		else printf("0\n");//找不到
	}
	return 0;//好习惯，不用说吧
}
```

若有问题还请大佬指出

---

## 作者：聪明的猪 (赞：1)

这是本蒟蒻第二次发题解~~第一次没过~~。
~~顺便庆祝一下绿名了~~
# 整体思路
~~小学找规律题~~，暴力，先找出最大的Ai（设定为max），然后构建一个有max个元素的“无穷的序列”，然后~~咕咕~~一个一个输出。
# 坑点
## 坑点一：数列不能开数组
由于本题数据过大，所以很多同学会被卡掉，RE（我有一个朋友在另一个平台上出现了诡异的MLE）就是这么来的。
解决办法：使用bitset。
## 坑点二：输入输出不能用cin，cout
还是那句话，本题数据过大~~你说个什么劲啊~~，所以用cin和cout的话最后一个点会出现~~诡异的~~TLE（1.2秒），所以还是用scanf和printf吧。~~我被这个点卡了三次~~
## 坑点三：printf不能直接输出bitset
bitset用的是一个自己的诡异的数据类型，所以printf用“%d”没法输出，要用int(N)进行强制类型转换。
# 代码
代码较乱，请dalao见谅哈。
```cpp
#include <algorithm>
#include <array>
#include <bitset>
#include <cstdio>
std::array<int, 1500010> a;
std::array<int, 1500010> sortedA;
std::bitset<1000000010> series;
int main(void)
{
    int max, n, zero;
    max = 0;
    zero = 0;
    a.fill(0);
    sortedA.fill(0);
    std::scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        std::scanf("%d", &(a.at(i)));
        sortedA.at(i) = a.at(i);
    }
    std::stable_sort(sortedA.begin(), sortedA.begin() + n);
    max = sortedA.at(n - 1);
    for (int i = 0; i < max; i++)
    {
        series[i] = 1;
        i += zero;
        ++zero;
    }
    for (int i = 0; i < n; i++)
    {
        std::printf("%d\n", int(series[a.at(i) - 1]));
    }
    return 0;
}
```
好了，祝大家成功！

---

## 作者：lowww666 (赞：1)

观察数列1101001000100001000001......会发现第I个1是在1+n（n-1）/2位，强行解一个一元二次方程，看是否有整数解就好了。

代码：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n,a1;
long long a;
double a2;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a);
        a2=(sqrt(1.0+8*(a-1.0))-1.0)/2.0;
        a1=a2;
        if(a1==a2)
          printf("%d\n",1);
        else
          printf("%d\n",0);
    }
}
```

---

## 作者：liuyifan (赞：1)

既然这道题是一个序列问题,那为什么不打表呢?

打表的思路大体与楼下题解相同,这里就不再赘述了

表的生成程序:
```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
int a[10000000];
int main()
{
	freopen("biao.txt","w",stdout);
	for(reg int i=1,j=0;i<=10000000;i+=j)
	{
        a[i]=1;
        j+=1;
    }
    for(reg int i=1;i<=1500000;i++)printf("%d,",a[i]);
}
```
//作用:将表输出到同目录下的biao.txt文件

实际程序:
```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
const int biao[]={1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0...//表太大了贴不上来 
int n,a;
int main()
{
	scanf("%d",&n);//输入个数 
	for(reg int i=1;i<=n;i++)scanf("%d",&a),printf("%d\n",biao[a]);//输出对应的数字 
	return 0;//可以不加,但一定不能return其他值,不然会RE 
}
```

Ps:本题解中所有文件的下载地址:
![](https://s1.ax1x.com/2018/09/24/iujyAH.png)
(内有完整的表和程序)

拒绝抄袭,共建和谐洛谷

---

## 作者：十三陵 (赞：1)

我来发一个暴力的解法吧

看到楼下的都是数学解析大法,自愧不如,这是就要利用计算机的力量啦

发现在1,2,4,7……项是1,

2-1=1;4=2=2;7-4=3;所以这数列是二阶等差数列,看多项式的书的话会告诉你这个多项式的最高次为二次.设一下,解出来哈:An=1/2\*n^2-1/2\*n+1

然后建个数组存这些数:`



```cpp
    for( i=1;t<=1000000000;i++)
    {
        t=(i*i-i+2)/2;
        d[i]=t;
    }`
```
然后二分查找吧,总得让高中信息有点用:


    
    
```cpp
    #include<cstdio>
    using namespace std;
    long long d[44725];
    int bsearchWithoutRecursion(int low,int high,int target) //二分查找(对分) 
    {
        while(low<=high)
            {
                int mid=(low+high)/2;
                if(d[mid]>target)  
                    high=mid-1;
                else if(d[mid]<target)
                low=mid+1;
                else
                    return mid;
            }
        return-1;
    }
    int main()
    {
        long long t=1;
        long long i;
        for( i=1;t<=1000000000;i++) //直接打表为1的下标 
        {
            t=(i*i-i+2)/2;
            d[i]=t;
        }
        int n;
        scanf("%d",&n); 
        for(int i=1;i<=n;i++)
        {
            long t;
            scanf("%ld",&t); //切记用scanf,不然会超时,真的 
            if(bsearchWithoutRecursion(1,44725,t)==-1) printf("0\n");
            //44725是算(x^2-x+2)/2>1000000000的最小正整数 
            else printf("1\n");
        }
        return 0; 
}
```

---

## 作者：yeyyx (赞：0)

由等差数列求和知

一个值为1的ai，必有ai-1 = n*(n+1)/2

因为有 n^2 < n*(n+1) < (n+1)^2 （n为正整数）

所以对于每一个(ai-1)*2开根得gx

判断是否满足(ai-1)*2 == gx*(gx+1)即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n, x, gx;
int main(){
	scanf("%d", &n);
	while(n--){
		scanf("%d", &x);
		x = (x-1)*2;
		gx = pow(x, 1./2);
		if(x == gx*(gx+1))printf("1\n");
		else printf("0\n");
	}
	return 0;
}
```

---

## 作者：maozi (赞：0)

用了map 的基本操作 将每一个一的下标存入map之中，然后运用map的count 查找该数是否为1，如果存在就输出1 否则输出0，但是最后一一个点超时了，看来要用二分再做一遍了， 后面的数据平均 350ms

这就是map的 查询 与存储的速度，大佬们，求指点啊


    
```cpp
#include<iostream>
#include<stdio.h>
#include<string>
#include<string.h>
#include<algorithm>
#include<queue>
#include<stack>
#include<map>
#include<cmath>
#include<iomanip>
using namespace std;
typedef int _____I;
const int N=1e6+10;
const int INF=0x3f3f3f3f;
#define ERX(___I,__I,_I) for(_____I ___I = __I;___I <  _I; ___I++)
#define ERD(___I,__I,_I) for(_____I ___I = __I;___I <= _I; ___I++)
#define RED(___I,__I,_I) for(_____I ___I = __I;___I >= _I; ___I--)
int n,a;
int main(){
    map<long long ,long long > dp; //map存 一的下标  
    cin>>n;
    long long e=0,q=0;
    for(int i=0;i<=50000;i++){
        e+=i;++q;dp[e]=i;
    }
    for(int i=1;i<=n;i++){
        cin>>a;
        cout<<dp.count(a-1)<<endl; //查询一的下标 存在就输出 1 否则输出0 
    }
    return 0;
}
```

---

## 作者：Little_Ming (赞：0)

N≤1500000，Ai≤10^9

暴力必跪

这个数列1少0多，且1的出现很有规律

所以可以使用O(n)的数学算法

----------------------

数列中第k个1的位置为

  1+1+2+3+4+......+(k-1)

=1+(k-1)k/2

若要查询第n个数是否是1

则可解方程

```cpp
                  1+(k-1)k/2=n
                       (k-1)k/2=n-1
                           (k-1)k=2(n-1)
              k^2+k-2(n-1)=0
```
对此式分解因式，设结果为(k+a)(k+b)=0
k1=-a,k2=-b

所以若a,b为负整数则第n个数是1

则有
|a+b=1.....................①

|ab=-2(n-1)............②

|a,b为整数

①^2得

          (a+b)^2=1^2

a^2+2ab+b^2=1...........③

③-4\*②得

a^2-2ab+b^2=8(n-1)+1

           (a-b)^2=8n-7

                  a-b=(8n-7)的平方根...④

①和④就是和差问题

做出来

a,b=
[根号(8n-7)±1]/2

当根号(8n-7)是整数时，

因为8n-7必为奇数，

所以根号(8n-7)也是奇数

根号(8n-7)±1是偶数

就是说a,b为整数了

前面说a,b是负的，那么取根号(8n-7)为负数即可

**所以第n个数是否是1取决于根号(8n-7)是不是整数**

完工~

代码很短(最后一个点竟然383ms)

-----------------------------

```cpp
var n,i,a:longint;p:extended;
begin
  read(n);
  for i:=1 to n do
  begin
    read(a);
    p:=sqrt(8*a-7);
    writeln(ord(abs(p-round(p))<1e-8));//ord(true)=1,ord(false)=0
  end;
end.
```

---

## 作者：ljc20020730 (赞：0)

##pas党表示强烈不满

#（但是请看下去，我依旧让pascal用这种方法AC了）

C++的话直接scanf优化读入最后一点可以勉强AC而pascal不行

但是通过计算时间复杂度的方法还是轻易得出二分查找的复杂度是(log2(44723)\*n)大概是O(15.2\*n)

运算大概是3000万次，远远不及10000万次 这样的算法应该也判AC！！！

O(log2(44723)\*n)的算法很容易想到：a数组存储数列中1的下标再用二分查找

如果裸的这个算法pascal好像过不了，所以我们要探寻非常规的方法

这个思想就是以空间换时间,即**记忆化**（具体看程序）

设置jy这个数组表示1-3000万位的数字然后在判断循环里记忆化

这样就可以实现单数据时间低于1000ms了

```cpp
const maxn=30000000;
var n,i,tt,max,t:longint;
    a:array[1..1500000]of longint;
    u:array[1..1500000]of longint;
    jy:array[0..maxn]of -1..1;
function search(k:longint):longint;//二分查找
  var low,hig,mid:longint;
  begin
    low:=1;hig:=t;
    mid:=(low+hig) div 2;
        while (u[mid]<>k) and (low<=hig) do begin
            if u[mid]>k then hig:=mid-1
        else low:=mid+1;
      mid:=(low+hig) div 2;
        end;
    if low>hig then mid:=0;
    search:=mid;
  end;
begin
 readln(n);
 for i:=1 to n do begin
  readln(a[i]);
  if a[i]>max then max:=a[i];
 end;
 t:=1; u[1]:=1; i:=1;
 while tt<=max do begin//推倒
   tt:=u[i]+t; inc(i);
   u[i]:=tt;
   inc(t);
 end;
 for i:=0 to maxn do jy[i]:=-1;  //赋初值
 for i:=1 to n do begin
  if (a[i]<=maxn)and(jy[a[i]]<>-1) then begin
   writeln(jy[a[i]]);
   continue;
  end;//记忆化
  if search(a[i])>0 then begin
  writeln(1);
  if a[i]<=maxn then jy[a[i]]:=1; end
  else begin writeln(0);
  if a[i]<=maxn then jy[a[i]]:=0; end;//记忆化
 end;
end.
```
-------------------------
AC
2701ms /  47.32MB

代码：0.99KB Pas

----------------------------

顺便提一下：理论上最优的算法是O(n)的算法

序列是110100100010000……

找规律发现'1'出现的位数为：

1 2 4 7 11 16 22……设位数为x

则n(n+1)/2+1=x

令n=trunc(qsrt(2(x-1)))

符合n(n+1)=2(x-1)的话即输出1

```cpp
var q,i,x,n:longint;
begin
  readln(q);
  for i:=1 to q do begin
    readln(x);
    n:=trunc(sqrt((x-1)*2));
    if n*(n+1)=2*(x-1) then writeln(1) else writeln(0);
  end;
end.
```
---------------------
AC
523ms /  28.7MB

代码：0.93KB Pas

---------------------


---

## 作者：sun615 (赞：0)

不会数学公式？？

看这里。

二分查找。

首先**规律总结如下**

/\*1 10 100   1000     1 0 0 0 0  1 0 0 0 0 0   1 0 0 0 0 0 0

1 23 456   78910   1112131415 161718192021  22

+1 +2 +3   +4      +5          +6

\*/
所以建立a数组存储数列中1的下标


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int a[10000009];
int main(){
  int sum=1;
  for (int i=0;i<44723;i++)  //这个范围是某大神打表打出来的，此处借鉴，其实可以用公式推导
  { sum+=i;
      a[i]=sum;                    //a数组初始化，**规律总结的关键转化部分**，供不会高级公式的童鞋理解
  }
  int n,k;
  cin>>n;
  for (int i=0;i<n;i++){
      scanf("%d",&k);
      int l=0,r=44722,mid;
      while (l<r){
          mid=(l+r)/2;
          if (a[mid]>=k) r=mid;        //二分查找满足条件的最小值；
          else l=mid+1;
      }
      if (a[l]==k) printf("1\n");
      else printf("0\n");                   //在数组中查找
  }
}
```

---

## 作者：revenger (赞：0)

对于数列110100100010000100000…… 如果去掉第一个1的话 剩下的1的位置会出现在1,3,6,10…… 也就是会出现在n(n+1)/2的位置(n∈N\*)

所以只要对输入的数-1进行判断就行了 对于第一个1来说 0\*1=0 也不需要特判

一开始用cin进行输入 最后一个点T到死…… 换成scanf就行了

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
int n,x;
int check(int x)
{
    int y=floor(sqrt(x*2))  //找到这个位置对应的n;
    if(y*(y+1)==2*x)  //如果满足n*(n+1)/2 就是1 否则就是0;
    return 1;
    else
    return 0;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        printf("%d\n",check(x-1));//位置-1后判断
    }
}
```

---

## 作者：YYY不吃药 (赞：0)

本来这道题用了朴素的数列找规律，结果后三个点爆了233

所以开了个根号优化，代码应该比较好看懂，求轻喷

代码如下：

```cpp
#include<cstdio>
#include<cmath>
int main()
{
    int a,i,n;
    double s;//必须定义成浮点型开根才有意义
    scanf("%d",&n);//输入不解释
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a);//输入序号
        s=sqrt(8*a-7);//s=(2n-1)^2
        a=(int)s;//取整
        if (a==s)//由草稿纸第n个1所在的序号a=1+n(n-1)/2,设第1，2，3...个1所在位置分别对应自然递增的奇数数列1，3，5...结合上一行输出1时a==s
        {
            if (a%2!=0)
            {
                printf("1\n");//满足奇数输出1
            }
            else printf("0\n");
        }else printf("0\n");
    }
    return 0;
}

```

---


# 编号

## 题目描述

太郎有 $N$ 只兔子，现在为了方便识别它们，太郎要给他们编号。兔子们向太郎表达了它们对号码的喜好，每个兔子 $i$ 想要一个整数，介于 $1$ 和 $M_i$ 之间（可以为 $1$ 或 $M_i$）。当然，每个兔子的编号是不同的。现在太郎想知道一共有多少种编号的方法。

你只用输出答案对 $10^9+7$ 取余的结果即可。如果这是不可能的，就输出 $0$。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 50$，$1\le M_i\le 1000$。

## 样例 #1

### 输入

```
2
5 8
```

### 输出

```
35```

# 题解

## 作者：刘心远 (赞：64)

爆简单数学题！

【算法分析】设n=10，10个数分别为12，11，64，65，68，34，36，54，39，48

则先把这10个数升序排列=>11，12，34，36，39，48，54，64，65，68

第一个号码有11种选择，1~11 第二个号码有12-1=11（种）选择（去掉1种）

第三个号码有34-2=32（种）选择（去掉2种）

第四个号码有36-3=33（种）选择（去掉3种）

第五个号码有39-4=35（种）选择（去掉4种）

第六个号码有48-5=43（种）选择（去掉5种）

第七个号码有54-6=48（种）选择（去掉6种）

第八个号码有64-7=57（种）选择（去掉7种）

第九个号码有65-8=57（种）选择（去掉8种）

第十个号码有68-9=59（种）选择（去掉9种）

所以答案为11\*11\*32\*33\*35\*43\*48\*57\*57\*59%1000000007

【温馨提示】1.必须排序，否则前一个选择的号码不知道是否在现在的范围中

2.必须边乘边模，否则long long要爆掉的

【华丽标程】

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int n,i,maxnumber[51]; long long ans=1; cin>>n;
    for(i=1;i<=n;i++)cin>>maxnumber[i];
    sort(maxnumber+1,maxnumber+n+1);  //排序，默认升序
    for(i=1;i<=n;i++){ans*=(maxnumber[i]-i+1); ans%=1000000007;}  //第i个号码的种数是maxnumber[i]-i+1
    cout<<ans<<endl; return 0;
}
请关注http://blog.sina.com.cn/s/blog_1754bd7130102wxk7.html
```

---

## 作者：codemap (赞：15)

	一道简单的题，排完序就做完了
	从小到大排序后，乘起来
	注意第二个要减一，第二个要减二，以此类推
	我的代码：
	#include<iostream>
	#include<algorithm>//sort的头文件，不加会编译错误
	using namespace std;
	int main()
	{
    int n,a[51],i;
    long long s=1;//数据范围有点大
    cin>>n;
    for(i=1;i<=n;i++)
    	cin>>a[i];
    sort(a+1,a+n+1);//sort快排序，不然可能会超时
    for(i=1;i<=n;i++)
    {
    	s*=(a[i]-i+1);//每个可选的都会减一
    	s%=1000000007;
    }
    cout<<s;
    return 0;
	}

---

## 作者：GuideZombies (赞：15)

###      ~~话说编号不直接按1234编不就行了吗~~
###   这就是一道纯数学问题，~~各位不会连乘法原理都不知道吧......~~
####  好啦，首先理清一下思路，第一只兔子肯定有他需求喜好的个数种可能，第二只兔子有他需求喜好-1的个数种可能，以此类推，第n只兔子有他需求喜好-n+1的个数种可能。
#### 那问题来了，假设前一只兔子选的在这只兔子的编号喜好范围之外呢？那就不用-兔子数+1了，如果直接判断又太麻烦了，怎么办呢？好办，使用sort排序就行了。使用sort将需求少的兔子排前面，完美！
#### 首先是伪代码，代码构成能力强的可以找这些代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
  申明变量
  输入
  sort(数组名+开始下标，数组名+结束下标）
  for(...;i<=n;...)
  {
   种数乘需求个数-i+1
   种数求余
   }
   判断是否是负数或0，因为如果没得选的话乘数就会变成0或负数，那就要输出0
   否则输出种数
  return 0;
```
#### 接着是核心代码——for循环之内：
```cpp
for(i=1;i<=n;i++)
	{
		zs*=(xq[i]-i+1);//乘
		zs%=1000000007;//模
	}
```
#### 献上你们最爱的完整代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
	int n,xq[51],i;
	long long zs=1;//这个很重要，记住，以后要求模都要开long long
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>xq[i];
	}//输入
	sort(xq+1,xq+n+1);//sort排序
	for(i=1;i<=n;i++)
	{
		zs*=(xq[i]-i+1);//乘
		zs%=1000000007;//就算开了long long也不保险,万一乘着乘着就爆了呢
	}
	if(zs<=0)//判断是否小于等于0，如果是就找不到任何办法排出编号，输出0
	{
		cout<<0;
	}
	else//反之，输出zs
	{
		cout<<zs;
	}
	return 0;
}
```
#### 最后，补充一点，sort排序如果像上面一样只能默认从小到大排序，如果要从大到小排序就要改排序语句并加一个函数
#### 语句：
```cpp
sort(数组名+开始下标，数组名+结束下标,函数名）
```
#### 函数部分：
```cpp
bool 数组名(int a,int b)
{
	return a>b;
}
```
#### 求过！求过！

---

## 作者：oistr (赞：8)

luogu后台编号：$133811$

 _注：此题解之前已通过，但本蒟蒻发现有些地方因Markdown使用问题导致显示出来没有达到想要的效果，容易混淆，故略微修改_ 

**首先不得不说的事，这位出题者应该是为pascal选手。这一点在他出的另一道题中很清晰：[P1634](https://www.luogu.org/problemnew/show/P1634)**

这道题核心思想还是 **递推** 。

具体代码实现在另外几位大佬的题解中已经很清楚了，不过这里来仔细讲一下递推式推导的过程。

 _**首先要利用一个数学原理：乘法原理**大意如下：有两类元素，分别有m，n个，那么从两类里各取一个元素，共有$mn$种取法。_ 

假设一共有n只兔子，每个兔子想要的最大编号为$m_1$，$m_2$，。。。，$m_n$。我们先将其排序形成一个从小到大的有序数列。

我们先来看第1只兔子，很明显，这时有m1种方法。

这时又来了一只兔子，根据乘法原理， **这时的取法数应为 第一只兔子可能的取值×第二只兔子可能的取值。** 第一只兔子的取值共有$m_1$种，由于第一只已取了一个号，第二只不能再取这个号。所以第二只兔子的取值数共有$m_2-1$种。这时共有$m_1(m_2-1)$种取值。

我们将情况扩展到第n只兔子。

此时前$(n-1)$只兔子已取号完毕，共有s种情况，根据乘法原理， **这时的取法数应为 前（n-1）只兔子可能的取值×第n只兔子可能的取值。** 前n-1只兔子取走了n-1个编号，第n只不能再取这些号。所以共有$s(m_n-n+1)$种情况。

所以我们推完了递推式。

**那么什么情况下不可能实现编号呢？**

当$m_n-n+1<=0$时，第n只兔子可选的编号都被用过了，第n只兔子就没有编号可选了，这时就要输出0.

## 代码：
```cpp
#include <iostream>
#include <algorithm>//此库包含排序函数
using namespace std;
bool cmp(int x,int y)//比较函数，供排序函数使用（这里是从小到大）
{
	return x<y;
}
int n;
int m[51];
int main()
{
	cin>>n;//input
	for(int i=1;i<=n;i++)
	{
		cin>>m[i];
	}
	sort(m+1,m+n+1,cmp);//排序（用sort函数）
	long long s=m[1];//s记录取值数
	for(int i=2;i<=n;i++)//递推开始
	{
		if((m[i]-i+1)<=0)//判断是否出现上述情况，如果是，输出0.
		{
			cout<<0<<endl;
			return 0;
		}
		s*=(m[i]-i+1);//否则，递推
		s%=1000000007;//避免溢出
	}
	cout<<s<<endl;//output
	return 0;
}
```


---

## 作者：Lolierl (赞：3)

//这是非完美递归解法，数论算法前面神犇们都已经写过了，我就拿这一题练练搜索吧

```cpp
#include<iostream>
#include<set>
using namespace std;

int n,a[51];
//int c[51];
set<int>s;
int dfs(int step)
{
    if(step==n+1)
    {
        //for(int i=1;i<=step;i++)cout<<c[i]<<' ';
        //cout<<endl;
        return 1;//底下的代码确保了不重复，所以如果深搜结束直接返回1
    }
    int sum=0;
    for(int i=1;i<=a[step];i++)
    {
        if(s.find(i)==s.end())//用集合优化查找，如果和之前不重复就尝试继续深搜
        {
            s.insert(i);//将这个点加入集合，用集合判重 
                        //c[step]=i;  这题不需要路径，就可以不用存储，其实想存储也是可以的，这就是深搜比数论好的地方
            sum+=dfs(step+1);//继续深搜
            s.erase(i);//弹出集合，一定要抹掉标记 
        }
    }
    return sum;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];//读入
    
    cout<<dfs(1);//深搜第一层
    return 0;
}
//这是一个n\*Maxnumber\*logn 的算法 ，尽管这题不能A，可是是一种很实用的算法。

---

## 作者：绝望狛枝 (赞：2)

水水水……

直接上代码
```
#include<bits/stdc++.h>
using namespace std;
int tz,a[10000];//tz为兔子数量,a[10000](好像不用开这么大)为每只兔子的想要的编码。
long long da_an=1;//答案
int main()
{
    scanf("%d",&tz);//cin>>tz;
    for(int i=1;i<=tz;i++)
    {
        scanf("%d",&a[i]);//cin>>a[i];
    }
    sort(a+1,a+tz+1);//其实我也不会用……，瞎用的，也过了。╮(╯▽╰)╭
    //我只知道是个搜索……大佬勿喷。
    for(int i=1;i<=tz;i++)
    {
        da_an=da_an*(a[i]-i+1);
        da_an=da_an%1000000007;//输出答案mod 1000000007即可。如果这是不可能的，就输出0.
    }
    printf("%lld",da_an);//cout<<da_an;   其实不用换行。(只有lld才匹配long long,不加也行吧)
    return 0;
}
//建议大家以后编程的代码工整一点。
```

请求管理员大发慈悲，过了吧！

---

## 作者：时光 (赞：1)

这题不难，但是有点坑~~~

数学问题 sum:=sum\*(a[i]-i+1)【当然，-i+1你可以用一个变量替换，事实上我就是这么做的】

sum要qword！！！！！！！！！！ 不然爆0不怪我~

还有1000000007别打错了，8个0~~

说太多了，看代码吧


```cpp
var
n,b,c,i,hh:longint;
sum:qword;
a:array[0..51]of longint;
procedure kp(l,r:longint);
var b,m,i,j,k:longint;
begin
  i:=l;
  j:=r;
  m:=a[(l+r)div 2];
  repeat
    while a[i]<m do i:=i+1;
    while a[j]>m do j:=j-1;
    if i<=j then
      begin
        b:=a[i];a[i]:=a[j];a[j]:=b;inc(i);dec(j);
      end;
    until i>j;
    if l<j then kp(l,j);
    if i<r then kp(i,r);
end;
begin
readln(n);
for i:=1 to n do read(a[i]);
kp(1,n);
hh:=0;
sum:=1;
for i:=1 to n do begin sum:=sum*(a[i]-hh)mod 1000000007;inc(hh);end;
write(sum);
end.

```

---

## 作者：x_faraway_x (赞：1)

没有c++的题解，我来写一发QWQ

将所有的MaxNumber升序排序，那么答案=a\_1\*(a\_2-1)\*(a\_3-2)\*...\*(a\_n-n+1)。公式并不难推导出来。

剩下来写程序就很轻松了：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 55, M = 1000000007;
typedef long long ll;
ll a[N];
int main() {
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a+1, a+1+n);
    ll ans = 1;
    for(int i = 1; i <= n; i++) {
        ans = ans*(a[i]-i+1)%M;
        ans %= M;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：按Ctrl加w会AC (赞：1)

#这是一道数学题

只需要将输入的从小到大排序，再把第1个减去0，第2个减去1，第3个减去2…第i个减去i-1…第n个减去n-1

如果有小于等于0的，就是不可能的，直接输出0

否则，输出所有的乘积就是结果

记着一定要一边乘一边模

```cpp
#include<cstdio>
#include<algorithm>
#define maxn 55
#define LL long long
#define TT 1000000007//这是模的数
using namespace std;
int n,a[maxn];
LL ans;//最终结果
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+1+n);//调用stl的排序
    for (int i=1;i<=n;i++){
        a[i]-=i-1;//减去i-1
        if (a[i]<=0) {printf("%d\n",0);return 0;}//如果有负数则不成立，输出0
    }
    ans=1;//一定要赋值给1
    for (int i=1;i<=n;i++) ans=(ans*a[i])%TT;//一边模一边乘，积的余数等于余数的积
    printf("%lld\n",ans);//输出结果
    return 0;
}
```

---

## 作者：一碗粥 (赞：0)

可以说，这是一道非常简单的数学题，以两个数为例：a,b。题目为如果第一个数有x种，那么第二个数为a[i]-i+1种。那么设这两个数a>b;若以a,b排列,sum1:=a\*(b-1);若以b,a排列,sum2:=b\*(a-1).

重点：做差法比较大小得sum1-sum2:=a\*(b-1)-b\*(a-1)=ab-a-ab+b=b-a.∵b>a∴b-a>0∴sum1-sum2>0;所以从小到大排列的种数更大。快排即可。

```delphi

const ywz:int64=1000000007;
var i,j,k,l,m,n,sum:longint;
    a:array[1..100000]of longint;
    ans:int64;
procedure qsort(l,r:longint);
var b,m,i,j,k:longint;
begin
  i:=l;
  j:=r;
  m:=a[(l+r)div 2];
  repeat
    while a[i]<m do i:=i+1;
    while a[j]>m do j:=j-1;
    if i<=j then
      begin
        b:=a[i];a[i]:=a[j];a[j]:=b;inc(i);dec(j);
      end;
    until i>j;
    if l<j then qsort(l,j);
    if i<r then qsort(i,r);
end;
begin
  read(n);
  for i:=1 to n do read(a[i]);
  sum:=n;
  qsort(1,n);
  m:=0;ans:=1;
  for i:=1 to n do
  begin
    ans:=(ans*(a[i]-m)) mod ywz;
    inc(m);
  end;
  write(ans);
end.
```

---

## 作者：lych (赞：0)

本题是一道数学性很强的题目，实现算法并不难。

首先，对于第一只兔子，他的选择显然有Maxnumber[1]种，第二只显然有Maxnumber[2]-1种。更一般的情况，对于第i只兔子，选择显然有Maxnumber[i]-i+1种。


然而，为了避免出现负数的情况，我们需要对数据进行从小到大排序。由于Maxnumber[i]小于1000，因此使用计数排序。


标程如下：

```delphi
var
  a:array[0..1000] of longint;
  n,i,j,x,k:longint;
  ans:qword;//由于取模的数比较大，所以要用qword
begin
  readln(n);
  for i:=1 to n do
    begin
      read(x);
      inc(a[x]);
    end;
  ans:=1;
  for i:=1 to 1000 do
    for j:=1 to a[i] do
      begin
        ans:=ans*(i-k) mod 1000000007;//注意取模
        inc(k);//个数
      end;
  writeln(ans);
end.
```

---


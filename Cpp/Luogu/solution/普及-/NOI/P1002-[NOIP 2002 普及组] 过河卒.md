# [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

## 样例 #1

### 输入

```
6 6 3 3
```

### 输出

```
6
```

# 题解

## 作者：Chiaro (赞：4191)

## 一道比较入门的 dp 题

这道题初始位置是从 0 开始的，这样不是很利于我们解题，所以不如暂且把这题里涉及的坐标统统 +1，那么初始位置就从 $(0,0)$ 变成了 $(1,1)$。

先考虑如果没有任何马的限制，卒子可以随便向右向下走，那么可以想到，一个卒子只能从 当前格子的左侧格子 和 当前格子的上方格子 上走到当前格子。那么假设从 $(1,1)$ 走到 当前格子的左侧格子 的路径条数是 $x$，从 $(1,1)$ 走到 当前格子的上方格子 的路径条数是 $y$，那么从 $(1,1)$ 走到当前格子的路径条数就应该是 $x+y$。

其实我们已经得到了一个动态规划的转移方程，设 $f(i,j)$ 表示从 $(1,1)$ 格子走到当前格子的路径条数，那么根据上一段得到的结论，可以得到：

$$ f(i,j) = f(i-1,j) + f(i,j-1) $$

$(i,j)$ 是当前格子，那么 $(i-1,j)$ 就是 当前格子的上方格子，$(i,j-1)$ 就是 当前格子的左侧格子。我们只需要从小到大依次枚举 $i$ 和 $j$ 就能获得所有点的答案，可以想到，在这道题里我们要求的答案就是 $f(n,m)$（因为 B 点的坐标是$(n,m)$）。

当然如果只是按照这个公式推肯定不行，因为 $f$ 的初始数值都是 0，再怎么推也都是 0，我们要让 $f(1,1)$ 能根据上面得到的式子推出答案是 1，这样才能有有意义的结果。根据 $f(1,1)=f(0,1)+f(1,0)$，我们只需要让 $f(1,0)=1$ 或者 $f(0,1)=1$ 即可。

接下来考虑一下加入了 马 这道题该怎么做，假设 $(x,y)$ 这个点被马拦住了，其实就是说这个点不能被卒子走到，那当我们枚举到这个点的时候，发现他被马拦住了，那就直接跳过这个点，让 $f(x,y)=0$ 就行了。

具体写代码的时候我们注意到在判断一个点有没有被马拦住时，会用到 $(i-2,j-1)$ 和 $(i-1,j-2)$ 这两个位置，那如果不把所有的点的坐标都加上 2 （前面分析的时候只把所有的坐标加上 1），就会因为数组越界而 WA 掉一个点。

答案可能很大，所以记得开 ``long long``。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;

const int fx[] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
const int fy[] = {0, 1, 2, 2, 1, -1, -2, -2, -1};
//马可以走到的位置

int bx, by, mx, my;
ll f[40][40];
bool s[40][40]; //判断这个点有没有马拦住
int main(){
    scanf("%d%d%d%d", &bx, &by, &mx, &my);
    bx += 2; by += 2; mx += 2; my += 2;
    //坐标+2以防越界
    f[2][1] = 1;//初始化
    s[mx][my] = 1;//标记马的位置
    for(int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(s[i][j]) continue; // 如果被马拦住就直接跳过
            f[i][j] = f[i - 1][j] + f[i][j - 1];
            //状态转移方程
        }
    }
    printf("%lld\n", f[bx][by]);
    return 0;
} 
```

---

考虑滚动数组优化。

观察转移方程 :

$$ f(i,j) = f(i-1,j) + f(i,j-1)$$

每一次转移只需要提供 $f(i-1,j)$ 和 $f(i,j-1)$。

即当前位置上方格子的答案与当前位置左边的答案，也就是说，对于一次转移，我们只需要用到横坐标是 $i$ 和横坐标是 $i-1$ 这两行的答案，其他位置的答案已经是没有用处的了，我们可以直接丢掉不管他们。

怎么只保留第 $i$ 行和第 $i-1$ 行的答案呢？答案是取模（C++ 中的运算符 %）。

$i\ \%\ 2\ne (i-1)\ \%\ 2$，所以我们把第一维的坐标 $i$ 都取模 2 变成 $i\ \%\ 2$，并且不断覆盖原来数组里存的答案，就成功做到只保留第 $i$ 行和第 $i-1$ 行的答案了。

众所周知，$x\ \%\ 2$ 可以在代码中写成更快的运算方式 $i\ \&\ 1$。

如果 $x$ 是偶数，那么 $x\ \&\ 1=0$，如果 $x$ 是奇数，那么 $x\ \&\ 1=1$。

那么新的转移方程就可以变成：

$$ f(0,1)=1 $$

$$ f(i\ \&\ 1,j)=f((i-1)\ \&\ 1,j)+f(i\ \&\ 1,j-1) $$


$f((i-1)\ \&\ 1,j)$ 就是当前位置上边格子的答案。

$f(i\ \&\ 1,j-1)$ 就是当前位置左边的答案。

这样 , 数组第一维是不是就可以压成 2 了呢？

另外 , 因为是滚动数组 , 所以如果当前位置被马拦住了一定要记住清零。

代码 :

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;

const int fx[] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
const int fy[] = {0, 1, 2, 2, 1, -1, -2, -2, -1};
int bx, by, mx, my;
ll f[2][40];    //第一维大小为 2 就好
bool s[40][40];

int main(){
    scanf("%d%d%d%d", &bx, &by, &mx, &my);
    bx += 2; by += 2; mx += 2; my += 2;
    f[1][2] = 1; //初始化
    s[mx][my] = 1;
    for(int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(s[i][j]){
                f[i & 1][j] = 0; //被马拦住了记住清零
                continue;
            }
            f[i & 1][j] = f[(i - 1) & 1][j] + f[i & 1][j - 1]; 
            //新的状态转移方程
        }
    }
    printf("%lld\n", f[bx & 1][by]);
    //输出的时候第一维也要按位与一下
    return 0;
} 
```

---

好的那继续来看看能不能再优化。

唯一再有点优化空间的地方就是那个大小为 2 的第一维了，那么为什么我们去不掉这个 2 呢？

因为状态转移的时候需要一个 $f(i-1,j)$，所以必须要多开一维。

那么我们如果优化掉了这里，当然就不再需要二维数组了。

观察我们能发现 , 这个 $f(i-1,j)$ 与当前位置的 $f(i,j)$ 的第二维一样 , 都是 j , 而第一维只是差了 1。

我们考虑直接去掉第一维，来看这个状态转移方程 :

$$ f(j) = f(j) + f(j-1)$$

是不是就把数组变成一维了呢？但是如何解释这个方程？

$f(j)+f(j-1)$ 里面，$f(j-1)$ 就是前面方程里的 $f(i,j-1)$。

至于 $f(j)$ , 因为还没有被更新过 , 所以答案仍然保存的是上次求出的答案 , 即 $f(i-1,j)$。

这样 , 就把二维数组成功变成了一维数组。

代码 :

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;

// 快速读入
template <class I>
inline void read(I &num){
    num = 0; char c = getchar(), up = c;
    while(!isdigit(c)) up = c, c = getchar();
    while(isdigit(c)) num = (num << 1) + (num << 3) + (c ^ '0'), c = getchar();
    up == '-' ? num = -num : 0; return;
}
template <class I>
inline void read(I &a, I &b) {read(a); read(b);}
template <class I>
inline void read(I &a, I &b, I &c) {read(a); read(b); read(c);}

const int fx[] = {0, -2, -1, 1, 2, 2, 1, -1, -2};
const int fy[] = {0, 1, 2, 2, 1, -1, -2, -2, -1};

int bx, by, mx, my;
ll f[40];   //这次只需要一维数组啦
bool s[40][40];

int main(){
    read(bx, by); read(mx, my);
    bx += 2; by += 2; mx += 2; my += 2;
    f[2] = 1;   //初始化
    s[mx][my] = 1;
    for(int i = 1; i <= 8; i++) s[mx + fx[i]][my + fy[i]] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(s[i][j]){
                f[j] = 0; // 还是别忘了清零
                continue;
            }
            f[j] += f[j - 1];
            //全新的 简洁的状态转移方程
        }
    }
    printf("%lld\n", f[by]);
    return 0;
} 
```
---

这时可能就有同学说了，f 数组是变成一维了，但是你的 s 数组还是二维的啊你个骗子！

至于去掉 s 数组的方法，其实还是很多的。

首先有比较暴力的方法，我们直接去掉 s 数组，然后对于当前位置 $(x,y)$，我们枚举被马拦住的那 8 个点，如果其中有一个点的位置和他的位置是一样的，那么这个位置就是不合法的了。这个方法可行，但是我们把本来是 $O(n^2)$ 小常数的做法加了一个 8 倍常数。如果把范围开大到 $n\leq 2\times 10^4$，那么这个做法可能会被卡。

有没有别的方法呢？下面可能会用到这个知识点：[切比雪夫距离](https://oi-wiki.org/geometry/distance/#_4)。

我们注意到，被马拦住的位置到马的切比雪夫距离一定是2，也就是说，他们都分布于下图这个正方形上，那我们就成功缩小了枚举范围：只有当当前这个点 $(x,y)$ 到马的切比雪夫距离是 2 时，才进行 8 个点的枚举，那么复杂度大概就是 $O(n^2+16\times 8)$（原谅我用这种不正确的方法书写复杂度），常数很小。

![](https://cdn.luogu.com.cn/upload/image_hosting/st1jofin.png)

但是还能有更好的方法，那就是加上[曼哈顿距离](https://oi-wiki.org/geometry/distance/#_2)：我们可以发现，这些被马拦住的位置同时到马的曼哈顿距离也一定为 3。

蓝色是曼哈顿距离为 3 的位置，红色是切比雪夫距离为 2 的位置，交点是被马拦住的位置，且被马拦住的位置一定是交点，也就是说，这是个充要条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/nae09ep2.png)

所以对于每个点我们只需要算一下他到马的切比雪夫距离和曼哈顿距离即可，这个计算都是 $O(1)$ 的，且常数很小。

```cpp
#include <cmath>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define ll long long

inline int read(){
    int num = 0; char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) num = (num << 1) + (num << 3) + (c ^ '0'), c = getchar();
    return num;
}

int bx, by, mx, my;
ll f[30];

inline bool check(int x, int y) {
    if(x == mx && y == my) return 1;
    return (std::abs(mx - x) + std::abs(my - y) == 3) && (std::max ((std::abs(mx - x)), std::abs(my - y)) == 2);
}

int main(){
    bx = read() + 2, by = read() + 2, mx = read() + 2, my = read() + 2;
    f[2] = 1;
    for(int i = 2; i <= bx; i++){
        for(int j = 2; j <= by; j++){
            if(check(i, j)){
                f[j] = 0;
                continue;
            }
            f[j] += f[j - 1];
        }
    }
    printf("%lld\n", f[by]);
    return 0;
} 
```


至此，我们成功将一个时间复杂度和空间复杂度为 $O(n^2)$ 的算法，优化到了时间复杂度 $O(n^2)$，空间复杂度 $O(n)$，虽然对于这道题而言没有任何的意义，但是或许能在做其他难题的时候启发我们一点思路，总归是没有坏处的。

----

2018/11/05：发布该题解。

2019/03/23：更新后两种做法。

2021/08/17：重新排版题解。

2022/01/26：更新如何优化 s 数组。

---

## 作者：kradcigam (赞：567)

## 正文

简单描述一下题意：

士兵想要过河，他每一次可以往下走一格，也可以往右走一格，但马一步走到的地方是不能走的，问走到 $n$ 行，第 $m$ 列有多少种走法。

我们显然应该先根据马的位置将不能走的格子做一下标记。

于是，就会写下这段代码：

```cpp
void work(long long x,long long y){
    ma[x][y]=1;
    ma[x-1][y-2]=1;
    ma[x-2][y-1]=1;
    ma[x-2][y+1]=1;
    ma[x-1][y+2]=1;
    ma[x+1][y-2]=1;
    ma[x+2][y-1]=1;
    ma[x+2][y+1]=1;
    ma[x+1][y+2]=1;
}
```
之后就可以使用奥数中的一种简单而常用的方法——**标数法**。


**可以举个例子**：


![123.png](https://i.loli.net/2019/10/25/OlK3HhBWmTRqguf.png)


从这个表格的第一行第一列，走到第二行第二列的走法数量是由走到第一行第二列的方案数 $+$ 第二行第一列的方案数。

也就是走到 $x$ 行，第 $y$ 列的方案数 $=$ 走到 $x-1$ 行，第 $y$ 列的方案数 $+$ 走到 $x$ 行，第 $y-1$ 列的方案数（出界就按 $0$ 算）。

也就是：
$$f[i][j]=f[i-1][j]+f[i][j-1]$$

因为走到第 $x$ 行，第 $y$ 列的方案显然是来自于它的左边和它的上面，因为只有这两个格子才可以一步到达这个格子。

于是我们就可以开始递推：

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      	if(i==1&&j==1)continue;
       	if(ma[i][j]==0)x[i][j]=x[i-1][j]+x[i][j-1];
    }
}
```


下面是我 AC 的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,n,m,x[23][23],ma[23][23];
void work(long long x,long long y){
    ma[x][y]=1;
    ma[x-1][y-2]=1;
    ma[x-2][y-1]=1;
    ma[x-2][y+1]=1;
    ma[x-1][y+2]=1;
    ma[x+1][y-2]=1;
    ma[x+2][y-1]=1;
    ma[x+2][y+1]=1;
    ma[x+1][y+2]=1;
}
int main(){
    scanf("%lld %lld %lld %lld",&n,&m,&a,&b);
    a++;
    b++;
    n++;
    m++;
    work(a,b);
    x[1][1]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
        	if(i==1&&j==1)continue;
        	if(ma[i][j]==0)x[i][j]=x[i-1][j]+x[i][j-1];
        }
    }
    printf("%lld",x[n][m]);
    return 0;
}
```
## 补充

![123.png](https://i.loli.net/2019/10/25/OlK3HhBWmTRqguf.png)

观看这张图，我们还可以发现其他的东西，我们能发现下面一行比上一行大的值，就是它左边格子的值，所以，我们可以将这道题优化成一维，代码实现也是很简单的。

$$f[i]+=f[i-1]$$

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,n,m,f[23],ma[23][23];
void work(long long x,long long y){
    ma[x][y]=1;
    ma[x-1][y-2]=1;
    ma[x-2][y-1]=1;
    ma[x-2][y+1]=1;
    ma[x-1][y+2]=1;
    ma[x+1][y-2]=1;
    ma[x+2][y-1]=1;
    ma[x+2][y+1]=1;
    ma[x+1][y+2]=1;
}
int main(){
    scanf("%lld %lld %lld %lld",&n,&m,&a,&b);
    a++;
    b++;
    n++;
    m++;
    work(a,b);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
			if(i==1&&j==1)continue;
        	if(ma[i][j]==0)f[j]+=f[j-1];
        }
    printf("%lld",f[m]);
    return 0;
}
```

如果我的文章对你有帮助请点个赞！！！

谢谢。

---

## 作者：yummy (赞：273)

为什么大家写的全是递推！！！

我一定要写一篇不是递推的题解！！！

**Updated on 2022.7.14：添加 $\LaTeX$。**

---
这里我介绍两种方法。

### 矩阵乘法
由于数据很小，$n$ 和 $m$ 的规模只有 $20$，所以允许一些复杂度较大的做法通过。

如果我们给网格图内的点标号，记从 $i$ 号点到达 $j$ 号点的方法数为 $f(i,j)$，$i$ 号点到 $j$ 号点的边的条数为 $a(i,j)(a(i,j)\in \{0,1\})$，那么枚举经过的点 $k$，则有 $i$ 点到 $j$ 点的方法数 $=i$ 点到 $k$ 点的方法数 $\times k$ 点到 $j$ 点的方法数，形式化的讲，$f(i,j)=f(i,k)\cdot a(k,j)$。

我们惊奇的发现，这就是矩阵乘法的定义。

因此，我们连接所有互相可达的点，进行矩阵快速幂即可。
```cpp
#include <bits/stdc++.h>
#define ll long long
#define rint register int
using namespace std;
int a[22][22][22][22];
ll tot[22][22][22][22];
int n,m,x,y;
int judge(int p,int q)//判断p,q是否可走
{
    if(p==x && q==y)
        return 0;
    int px=abs(p-x);
    int qy=abs(q-y);
    int mi=min(px,qy);
    int mx=max(px,qy);
    if(mi==1 && mx==2)
        return 0;
    return 1;
}
ll tmp[22][22][22][22]={0};
void ta()//将tot乘上a
{
    for(int i1=0;i1<=n;i1++)
        for(int i2=0;i2<=m;i2++)
            for(int j1=i1;j1<=n;j1++)//如果j在i号点左侧，答案必然为0
                for(int j2=i2;j2<=m;j2++)//同理
                    for(int k1=i1;k1<=j1;k1++)//k点必然在i和j之间
                        for(int k2=i2;k2<=j2;k2++)
                            tmp[i1][i2][j1][j2]+=tot[i1][i2][k1][k2]*a[k1][k2][j1][j2];
    memcpy(tot,tmp,sizeof tmp);//复制回去
}
void tt()//将tot平方
{
    for(int i1=0;i1<=n;i1++)
        for(int i2=0;i2<=m;i2++)
            for(int j1=i1;j1<=n;j1++)
                for(int j2=i2;j2<=m;j2++)
                    for(int k1=i1;k1<=j1;k1++)
                        for(int k2=i2;k2<=j2;k2++)
                            tmp[i1][i2][j1][j2]+=tot[i1][i2][k1][k2]*tot[k1][k2][j1][j2];
    memcpy(tot,tmp,sizeof tmp);
}
void pw(int ci)//求a的ci次方
{
    if(ci==0)
        return;
    pw(ci>>1);
    tt();
    if(ci&1)
        ta();
}
int main()
{
    cin>>n>>m>>x>>y;
    //连接竖向边
    for(int i=0;i<n;i++)
        for(int j=0;j<=m;j++)
            if(judge(i,j))
                a[i][j][i+1][j]=1;
    //连接横向边
    for(int i=0;i<=n;i++)
        for(int j=0;j<m;j++)
            if(judge(i,j))
                a[i][j][i][j+1]=1;
    //矩阵的单位元
    for(int i=0;i<=n;i++)
        for(int j=0;j<=m;j++)
            tot[i][j][i][j]=1;
    pw(n+m);//由于要走的步数是一定的，所以就是a^(n+m)
    cout<<tot[0][0][n][m];
    return 0;
}
```

### 小学奥数

前置芝士：
1. 从 $(0,0)$ 走到 $(m,n)$ 的最短路数量=$C^m_{m+n}$
2. 从 $(0,0)$ 经过 $(x,y)$ 到达 $(m,n)$ 的最短路数量=$C^x_{x+y}C^{m-x}_{m+n-x-y}$（即芝士 1 配合乘法原理的结果）

如果您了解了上面的内容，那么我们就先以样例画一张图：

|0|1|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|S|.|.|.|.|.|.|
|.|.|x|.|x|_|.|
|.|x|.|.|_|x|.|
|.|.|.|_x|.|.|.|
|.|x|_|.|.|x|.|
|.|_|x|.|x|.|.|
|.|.|.|.|.|.|E|

`x` 表示不可以走的地方。
我们分情况讨论。

#### 1.不经过特殊格子的

我们称下划线所在的格子为特殊格子。显然这五个格子最多经过1个，所以我们只要求出总共的方法数-经过这五个格子的方法数即可求出。也就是求$C^n_{n+m}-\sum^{2}_{i=-2}C^{x-i}_{x+y}C^{n-x+i}_{n+m-x-y}$.
#### 2.经过 $(x-2,y+2)$ 的
这种路径只有一种情况：先到达 $(x-3,y+2)$，向右一格，向下一格到达 $(x-2,y+3)$，然后走到 $(m,n)$。

方法数为$C^{x+2}_{x+y-1}C^{n-x-3}_{n+m-x-y-1}$。
#### 3.经过 $(x+2,y-2)$ 的
同理，方法数为$C^{x-3}_{x+y-1}C^{n-x+2}_{n+m-x-y-1}$。
#### 4.经过 $(x-1,y+1)$ 的
要经过这个点，需要从 $(x-3,y)$ 进入马的攻击范围，右2步，下，右，下2步到达 $(x,y+3)$，然后走到 $(m,n)$。

到达 $(x-3,y)$ 的方案数为 $C^x_{x+y-3}$，从 $(x,y+3)$ 到终点的方案数为 $C^{n-x-3}_{n+m-x-y-3}$。

#### 5.经过 $(x+1,y-1)$ 的
与第 4 种情况同理，方案数为 $C^{x-3}_{x+y-3}C^{n-x}_{n+m-x-y-3}$。

完结撒花！！！

等等，感觉有点问题...

有一种特殊情况：如果起点或终点离马的位置太近，那么上面的分类讨论的第 4 种和第 5 种情况就会出现问题——可能起点或终点本来就在马的攻击范围内。

所以，遇到这种情况别忘记特判。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll C(int m,int n)
{
    if(n<0 || m<0 || n<m)
        return 0;
    ll tot=1;
    for(int i=1;i<=m;i++)
    {
        tot*=n-i+1;
        tot/=i;
    }
    return tot;
}
int n,m,x,y;
int rt[5][5]={
0,0,1,0,0,
0,0,1,1,0,
0,0,0,1,1};//我们记录下哪些节点作为起点时，可以从右边的口子出去，其中(2,2)为马的位置
int dw[5][5]={
{},
{},
1,1,0,0,0,
0,1,1,0,0,
0,0,1,0,0};//同理，哪些可以从下边口子出去
int main()
{
    cin>>n>>m>>x>>y;
    if(n-x<3 && m-y<3)
    {
        x=n-x;
        y=m-y;
    }//为了不想把特判代码写两遍，如果终点离得太近就旋转180度，变成起点离得太近的情况
    if(x<3 && y<3)
    {
        int nx=2-x;
        int ny=2-y;//起点相对于马的坐标而言的位置
        ll tot=0;
        tot+=C(n-x,m+n-x-y-3)*rt[nx][ny];//右边出去的方法数
        tot+=C(n-x-3,m+n-x-y-3)*dw[nx][ny];//同理
        cout<<tot;
        return 0;
    }
    ll tot=C(n,n+m);
    for(int i=-2;i<=2;i++)
        tot-=C(x-i,x+y)*C(n-x+i,n+m-x-y);
    //情况1
    tot+=C(x+2,x+y-1)*C(n-x-3,n+m-x-y-1);//情况2
    tot+=C(x-3,x+y-1)*C(n-x+2,n+m-x-y-1);//情况3
    tot+=C(x,x+y-3)*C(n-x-3,n+m-x-y-3);//情况4
    tot+=C(x-3,x+y-3)*C(n-x,n+m-x-y-3);//情况5
    cout<<tot;
    return 0;
}
```

完结撒花！！！

---

## 作者：FreedomKing (赞：115)

### 思路

普普通通的动态规划（DP）模板题。

选择分两块来讨论问题。

首先处理一下马能移动到的位置，只需要在马所在的坐标和其能移动的八个点位标记即可。通过以下代码实现。

```cpp
const int dir[8][2]={{1,2},{1,-2},{2,1},{2,-1},{-1,2},{-1,-2},{-2,1},{-2,-1}};//移动数组，存下来马每种移动时位置的相对变化
d[cx][cy]=true;//把马本体标记
for(int i=0;i<8;i++){
	int tx=cx+dir[i][0],ty=cy+dir[i][1];//移动
	if(tx>=0&&tx<=n&&ty>=0&&ty<=m)//如果在边界内
		d[tx][ty]=true;//标记
}
```

然后开始讨论移动的问题，不难发现，点 $(i,j)$ 只能由 $(i-1,j)$ 和 $(i,j-1)$ 移动得到，而到这个点的方案数便是 $dp_{i-1,j}+dp_{i,j-1}$。

所以得出状态转移方程 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$，由于到原点的方案数只有 $1$ 种，所以 $dp_{0,0}=1$，再处理一下边界情况即可。

```cpp
for(int i=0;i<=n;i++){
	for(int j=0;j<=m;j++){
		if(d[i][j]==false){//如果没被标记
			if(i)//判边界
				dp[i][j]+=dp[i-1][j];//转移
			if(j)//判边界
				dp[i][j]+=dp[i][j-1];//转移
		}
	}
}
```

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dir[8][2]={{1,2},{1,-2},{2,1},{2,-1},{-1,2},{-1,-2},{-2,1},{-2,-1}};
bool d[30][30];
long long dp[30][30],n,m,cx,cy;
int main(){
    cin>>n>>m>>cx>>cy;
    d[cx][cy]=true;
    for(int i=0;i<8;i++){
        int tx=cx+dir[i][0],ty=cy+dir[i][1];
        if(tx>=0&&tx<=n&&ty>=0&&ty<=m) d[tx][ty]=true;
    }
    dp[0][0]=1;
    for(int i=0;i<=n;i++){
        for(int j=0;j<=m;j++){
            if(d[i][j]==false){
                if(i) dp[i][j]+=dp[i-1][j];
                if(j) dp[i][j]+=dp[i][j-1];
            }
        }
    }
    cout<<dp[n][m]<<endl;
    return 0;
}
```

---

## 作者：Shadows_of_Twilight (赞：49)

## 思路
设 $dp_{i,j}$ 表示第 $i$ 行 $j$ 列卒走到这里有多少种方式。

卒是可以向右和下走，所以到这个点只能从左或上来，不难得出转移公式：$dp_{i,j} = dp_{i-1,j}+dp_{i,j-1}$。

如果马在这个点上或者说马能到这个点上，那么卒不能到这个点，也就是卒到这个点的方式为 $0$。

如何判断马能不能到这个点呢？我们需要一个方向数组，马能走八个方向，依次枚举这八个点是不是当前点即可。

以上就是全部思路，但是还要注意一下几点：

- $dp_{0,0}$ 赋值为 $1$，初始化。
- 在转移过程中会数组越界，所以需要判断。
- 转移时如果当前点是 $(0,0)$ 则不进行转移，因为这是初始点，已经有值了。

## AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int dp[25][25];
int dx[8]={-1,-2,-2,-1,1,2,2,1},dy[8]={-2,-1,1,2,2,1,-1,-2};
signed main(){
	int n,m,x,y;
	cin>>n>>m>>x>>y;
	dp[0][0]=1;//初始值
	bool ok=1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			if(i==0&&j==0)continue;//不能是初始点
			ok=1;
			if(i==x&&j==y)ok=0;//这个点是不是马的位置
			for(int k=0;k<8;k++){//这个点有没有被马控制
				if(i==x+dx[k]&&j==y+dy[k]){ok=0;break;}
			}
			if(ok){//转移
				if(i-1<0){//判断越界
					dp[i][j]=dp[i][j-1];
				}
				else if(j-1<0){
					dp[i][j]=dp[i-1][j];
				}
				else{
					dp[i][j]=dp[i-1][j]+dp[i][j-1];	
				}
				
			}
		} 
	}
	cout<<dp[n][m]<<endl;
	return 0;
}
```

---

## 作者：_Weslie_ (赞：23)

我也不知道这个叫递推还是 dp 好了。

## Solution P1002

### Idea

我们设 $f_{i,j}$ 表示走到点 $(i,j)$ 的方案数。

根据卒的行动规则，显然有 $f_{i,j}=f_{i-1,j}+f_{i,j-1}$。

但是有马的限制。马的初始位置是确定的，因此我们可以将马控制的点打上标记，不转移这些点的状态就可以了。

为什么不转移被控制的点的答案是对的？如果我们求这个点的答案，显然是 $0$。而如果后面的状态需要用到这个点的状态，显然这个点无法为后面的点提供任何贡献，给一个 $0$ 的贡献等价。所以如果出现被马控制的点，理论是要把它的 $f$ 值归零的。

但是 c++ 有一个全局变量的特性：如果定义全局变量，它会被赋予一个初值 $0$，所以你干脆不转移，反正留在这里面的也是 $0$。

### Code

这个题代码看似简单，但是里面有很多技巧。

```
#include<iostream>
using namespace std;
long long f[23][23];
bool p[23][23];
int a,b,c,d;
const int x[]={0,-2,-1,1,2,2,1,-1,-2};
const int y[]={0,1,2,2,1,-1,-2,-2,-1};
//使用 x,y 数组，更方便去枚举被控制的点，否则你写一大长串代码麻烦
int main() {
	cin>>a>>b>>c>>d;
	a+=2;b+=2;c+=2;d+=2;//防止出现负数，然后爆掉
	f[2][1]=1;//初值设计，从场外进入，方案数必然是 1
	for(int i=0;i<=8;i++){
		p[c+x[i]][d+y[i]]=1;
	}
	for(int i=2; i<=a; i++) {
		for(int j=2; j<=b; j++) {
			if(p[i][j])continue;
			f[i][j]=f[i-1][j]+f[i][j-1];
		}
	}
	cout<<f[a][b];
	return 0;
}
```

---

## 作者：WsW_ (赞：9)

### 思路
简单递推题。  
由于卒可以向下或向右走，所以到达一个格子最后一步有两种可能，要么最后一步向下走，要么最后一步向右走。  
所以到达一个格子的方案数就是到达它上面那个格子的方案数，加上到达它下面那个格子的方案数。  
注意如果某个格子被马控制了，那么到达这个格子的方案数为 $0$。如果某个格子在左边界，那它只能从上面的格子走下来；如果某个格子在右边界，那它只能从左边的格子走下来。  

时间复杂度为 $O(nm)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int n,m,x,y;
bool vis[23][23];
int dir[9][2]={0,0,-1,2, 2,-1, 1,-2, -2,1, -2,-1, -1,-2, 2,1, 1,2};
ll f[23][23]={1};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>x>>y;
	for(int i=0;i<9;i++){
		int tx=x+dir[i][0],ty=y+dir[i][1];
		if(0<=tx&&tx<=n&&0<=ty&&ty<=m)vis[tx][ty]=1;
	}
	
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			if(!vis[i][j]){
				if(i>0)f[i][j]+=f[i-1][j];
				if(j>0)f[i][j]+=f[i][j-1];
			}
		}
	}
	cout<<f[n][m];
	return 0;
}
```

---

## 作者：FXLIR (赞：9)

### 思路

DP 入门题。

设 $f_{i,j}$ 为卒从起点走到 $(i,j)$ 的方案数量。

因为卒一开始在 $(0,0)$ 点，所以到达 $(0,0)$ 的方案只有一种，所以 $f_{0,0}=1$。

因为卒只能向下或向右走，所以如果想走到 $(i,j)$ 点，只能从上或从左走过来，也就是从 $(i-1,j)$ 或 $(i,j-1)$ 走过来。

因此得出，状态转移方程为 $f_{i,j}=f_{i-1,j}+f_{i,j-1}$。

然后考虑如何处理“马的控制点”。我们发现，如果 $(i,j)$ 是“马的控制点”，那么卒肯定是不能到达 $(i,j)$ 的，即 $f_{i,j}=0$。

在实际的代码编写中，我们可以使用一个二维数组，对“马的控制点”进行标记，若 $(i,j)$ 是“马的控制点”，则跳过该点的状态转移。

具体实现见代码。
### AC code
```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=25,INF=1e9;
bool b[N][N];
int f[N][N],n,m,x,y;
void bhor(int x,int y){//对马的控制点进行标记
	b[x][y]=1;
	b[x-2][y-1]=1,b[x-2][y+1]=1,b[x-1][y-2]=1,b[x-1][y+2]=1;
	b[x+1][y-2]=1,b[x+1][y+2]=1,b[x+2][y-1]=1,b[x+2][y+1]=1;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m>>x>>y;
	bhor(x+2,y+2);
    /*
    这里 +2 是因为如果 x=0 或 y=0 的话，部分“马的控制点”的坐标会变成负数
    变成负数的话，会出现数组越界
    这里相当于把整个棋盘都向下移了两行并向右移了两列，所以后面的一些访问也都要 +2
    */
	f[2][2]=1;
	for(int i=2;i<=n+2;i++){
		for(int j=2;j<=m+2;j++){
			if(!b[i][j]&&!f[i][j]){
				f[i][j]=f[i-1][j]+f[i][j-1];
			}
		}
	}
	cout<<f[n+2][m+2];
	return 0;
}
```

---

## 作者：LotleTos (赞：8)

## 思路
- 统计卒走到每个格子的走法数量。
- 卒只能往下或往右走，所以每个格子的走法数就是左格子和上格子之和。
- 卒不能走到马的控制点上，所以马的控制点的走法数为 $0$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long b[9][2]={{0,0},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1},{-2,1},{-1,2}},a1,a2,a3,a4,w[21][21];
int main(){
    cin>>a1>>a2>>a3>>a4;
    w[0][0]=1;
    for(int i=0;i<=a1;i++){
        for(int j=0;j<=a2;j++){
            if(i!=0){
                w[i][j]+=w[i-1][j];
            }
            if(j!=0){
                w[i][j]+=w[i][j-1];
            }
            for(int k=0;k<=8;k++){
                if(i==a3+b[k][0]&&j==a4+b[k][1]){
                    w[i][j]=0;
                }
            }
        }
    }
    cout<<w[a1][a2];
}
```

---

## 作者：niuniudundun (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1002)

# 题目大意

求出一个卒在不被马吃的情况下到 $(n,m)$ 点的方案数。

# 解法

记 $dp_{i,j}$ 为到 $(i,j)$ 的方案数。

显然到 $(i,j)$ 只能从 $(i-1,j),(i,j-1)$ 来到，那么 $dp_{i,j}$ 的方案数，就是 $(i-1,j)$ 和 $(i,j-1)$ 的方案数，即 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

但是如果 $(i,j)$ 会被马吃，显然不能去这里。所以定义一个标记数组 $vis$，初始为 $1$。如果 $vis_{i,j}=0$，说明这里不能走，$dp_{i,j}$ 为 $0$。

如何是不能走呢？不妨定义位置数组 $x$ 和 $y$，表示马能走到的坐标，$x=\{0,-2,-1,1,2,2,1,-1,-2\},y=\{0,1,2,2,1,-1,-2,-2,-1\}$（$0$ 是站位的），随后对 $B$ 点（马的坐标）的 $x,y$ 坐标点设为 $0$。

所以答案显然为 $dp_{n,m}$。

**为了不越界可以将坐标加二。**

代码：

复杂度：$O(nm)$。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int maxn=210;
long long dp[maxn][maxn];
int n,m,a,b;
bool vis[maxn][maxn];
const int x[]={0,-2,-1,1,2,2,1,-1,-2};
const int y[]={0,1,2,2,1,-1,-2,-2,-1};
int main(){
	memset(vis,true,sizeof(vis));
	cin>>n>>m>>a>>b;
	n+=2,m+=2,a+=2,b+=2;
	for(int i=1;i<=8;i++){
		vis[a+x[i]][b+y[i]]=false;
	}
	vis[a][b]=false;
	dp[2][1]=1;
	for(int i=2;i<=n;i++){
		for(int j=2;j<=m;j++){
			if(vis[i][j]){
				dp[i][j]=dp[i-1][j]+dp[i][j-1];
			}
		}
	}
	cout<<dp[n][m]<<endl;
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：3)

### 思路

简单 dp 题。我们仅需求卒能移动到这个位置的位置的方案数之和即可得到这个位置的方案数。注意，马的位置卒不能走，所以应当设为 $0$。

状态转移方程为：

$$
f_{i,j} = \begin{cases}
0 & \text{horse can go to here} \\
f_{i-1,j} + f_{i,j-1} & \text{horse can't go to here}
\end{cases}
$$

初始状态为：

$$
f_{i,j} = \begin{cases}
0 & \text{horse can go to here} \\
1 & \text{horse can't go to here} \\
\end{cases}

(\operatorname{if} i = 0 \lor j = 0)
$$

### 实现

```cpp
# include <iostream>
using namespace std;
long long a[50][50];
bool h[50][50];
const int X[9]={0,-2,-2,-1,-1,1,1,2,2};
const int Y[9]={0,-1,1,-2,2,-2,2,-1,1};
int main(){
	int n,m,x,y;
	cin >> n >> m >> x >> y;
	a[1][1] = 1;
	n++,m++,x++,y++;
	for (int i = 0;i < 9;i++) h[x+X[i]][y+Y[i]] = true;
	for (int i = 1;i <= n;i++){
		for (int j = 1;j <= m;j++){
			if (!h[i][j] && (i != 1 || j != 1)) a[i][j] = a[i-1][j] + a[i][j-1];
		}
	}cout << a[n][m];
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：2)

本题算法：动态规划。  
首先我们来了解清楚本题让我们干啥？题目就是说有一个棋子马，它可以跳到一些位置，在题目中有一张图。不过马走到的位置是不能走的。已知另一个的位置是 $(0,0)$，求走到 $(n,m)$ 的方案数。  
思路如下：
- 首先我们要将马能走到的点进行标记。所以我们可以定义方向数组来对位置进行处理。因为马的位置是知道的，所以马能走到的点就是 $(mx+dx_{i},my+dy_{i})$。我们的方向数组可以根据题目中的那张图来进行计算。这里的数组定义方法如下。
```cpp
int dx[]={0,-2,-2,1,1,2,2,-1,-1};
int dy[]={0,1,-1,-2,2,1,-1,2,-2};
```
- 定义 $dp$ 数组的状态。$dp_{i,j}$ 表示走到 $(i,j)$ 这个位置的方案数。
- 确定答案。要走到 $(n,m)$，那么答案就是 $dp_{n,m}$。
- 求状态转移方程。我们可以从终点倒退。终点 $(n,m)$ 可以从上面或左面走来，因此状态转移方程就是：$dp_{i,j}=dp_{i-1,j}+dp{i,j-1}$。
- 边界条件。如果 $(i,j)$ 这个位置能被马控制就不能走，而且我们的坐标是从 $0$ 开始的，所以需要向右偏移，这样 $i-1,j-1$ 就不会有负数，答案不变。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int maxn=2005;
int dx[]={0,-2,-2,1,1,2,2,-1,-1};
int dy[]={0,1,-1,-2,2,1,-1,2,-2};
bool vis[maxn][maxn];
int dp[maxn][maxn];
bool check(int ax,int ay,int n,int m)
{
	if(ax>=1&&ax<=n&&ay>=1&&ay<=m)
	{
		return true;
	}
	return false;
}
signed main()
{
	int sx,sy,px,py;
	cin>>sx>>sy>>px>>py;
	sx++;
	sy++;
	px++;
	py++;
	for(int i=0;i<9;i++)
	{
		int nx=dx[i]+px;
		int ny=dy[i]+py;
		if(check(nx,ny,sx,sy))
		{
			vis[nx][ny]=true;
		}
	}
	for(int i=1;i<=sx;i++)
	{
		for(int j=1;j<=sy;j++)
		{
			if(vis[i][j])
			{
				dp[i][j]=0;
			}
			else if(i==1&&j==1)
			{
				dp[i][j]=1;
			}
			else
			{
				dp[i][j]=dp[i-1][j]+dp[i][j-1];
			}
		}
	}
	cout<<dp[sx][sy];
	return 0;
}
```

---

## 作者：lucky_Mrzhao (赞：1)

## 思路

因为只能往下或者往右走，所以考虑动态规划。

由于马能攻击到在它左上、左下、右上、右下的 `8` 种不同位置，考虑将这些位置设为禁行。

设 $f_{i,j}$ 为走到第 $i$ 行，第 $j$ 列的方案数，有：

$$
f_{i,j} = f_{i-1,j} + f_{j,j-1}
$$

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[25][25];
bool c[25][25];
int dx[9] = {0,-2,-1,1,2,2,1,-1,-2};
int dy[9] = {0,1,2,2,1,-1,-2,-2,-1};
int main()
{
    int n,m,x,y;
    cin >> n >> m >> x >> y;
    x += 1,y += 1;
    for(int i = 0;i <= 8;i++){
    	int ax = x+dx[i];
    	int ay = y+dy[i];
    	if(ax>0&&ax<=n+1&&ay>0&&ay<=m+1) c[ax][ay] = true;
    }
    a[1][1] = 1;
	for(int i = 1;i <= n+1;i++){
		for(int j = 1;j <= m+1;j++){
			if(a[i][j]) continue;
			if(c[i][j]) continue;
			a[i][j] = a[i-1][j] + a[i][j-1];
		}
	}
	cout << a[n+1][m+1];
    return 0;
}
```

---


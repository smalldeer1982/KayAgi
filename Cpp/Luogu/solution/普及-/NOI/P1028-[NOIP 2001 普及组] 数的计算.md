# [NOIP 2001 普及组] 数的计算

## 题目描述

给出正整数 $n$，要求按如下方式构造数列：

1. 只有一个数 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

## 说明/提示

### 样例 1 解释

满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 说明

本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：

> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。

## 样例 #1

### 输入

```
6
```

### 输出

```
6
```

# 题解

## 作者：Hhy140516 (赞：63)

[P1028](https://www.luogu.com.cn/problem/P1028)
# 题意
输入一个整数 $n$，做为现在数列的最后一个数。每次在后面只能加一个比现在最后的一个数的一半小的数，也可以不加。问有多少个合法数列。

# 分析
用 $f$ 数组记录以 $i$ 结尾有多少个合法数列。

现依次找寻比现在小一半的数中合法个数再累加起来，最后还有自己结尾的情况。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
int n ;
int f[1005] ;
int main()
{
    cin >> n ;
    for( int i = 1 ; i <= n ; i++ )
	{
        for( int j = 1 ; j <= i / 2 ; j++ )
		{
            f[i] += f[j] ;
        }
        f[i]++ ;
    }
    cout << f[n] ;
    return 0 ;
}
```

---

## 作者：shinzanmono (赞：30)

设 $f_i$ 表示当 $n=i$ 时的答案，则 $f_i=f_1+f_2+\ldots+f_{\left\lfloor n/2\right\rfloor}+1$（因为 $n=i$ 时，序列的第一个数为 $i$），初始时 $f_1=1$。

直接循环递推求解是 $O(n^2)$ 的，虽然可以通过本题，我们考虑优化。

设 $g_i=f_1+f_2+\cdots+f_i$，则转移为 $f_i=g_{\left\lfloor n/2\right\rfloor}+1$ 即可，这样做时间复杂度是 $O(n)$ 的。

```cpp
#include<iostream>
#include<algorithm>
const int sz=1010;
int f[sz],g[sz];
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin>>n;
    f[1]=g[1]=1;
    for(int i=2;i<=n;i++)f[i]=g[i/2]+1,g[i]=g[i-1]+f[i];
    std::cout<<f[n]<<"\n";
    return 0;
}
```

---

## 作者：New_Void (赞：23)

# [P1028 [NOIP 2001 普及组] 数的计算](https://www.luogu.com.cn/problem/P1028)

这是一道十分典型的递推问题，由于是递推问题我们可以先打表出前几项的值，之后进行分类讨论。

### 思路

- $n$ = $1$ 时，只有一个可能就是 $1$ 。
- $n$ = $2$ 时，有两种可能：$2$，$(2，1)$。
- $n$ = $3$ 时，有两种可能：$3$，$(3，1)$。
- $n$ = $4$ 时，有四种可能：$4$，$(4，1)$，$(4，2)$，$(4，2，1)$。
- $n$ = $5$ 时，有四种可能：$5$，$(5，1)$，$(5，2)$，$(5，2，1)$。
- $n$ = $6$ 时，有六种可能：$6$，$(6，1)$，$(6，2)$，$(6，3)$，$(6，2，1)$，$(6，3，1)$。

现在我们仔细观察，发现当 $n$ = $6$ 时，从倒数第二个看，不就是继承了 $n/2$ 的方法数吗，而前面的方法，又正好是 $n-1$ 的方法数，这是因为它拼到 $(n-2)/2$ 时，它的所有方法正好是 $f[n-1]$ 的所有，而后面添加的 $n/2$，不就是 $f[n/2]$ 吗，所以当 $n$ 为偶数时，递推式是：$f[n]=f[n-1]+f[n/2]$。

接下来就是当 $n$ 等于奇数时了，这个就很好解释了，因为计算机是整除，所以 $n/2$ 等于 $n/2-1$，所以递推式是：$f[n]=f[n-1]$。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1005];
int main(){
    int n;
    cin>>n;
    f[1]=1;
    f[2]=2;
    f[3]=2;
    for (int i=3;i<=n;i++){
        if (i%2==1){
            f[i]=f[i-1];
        }
        else{
            f[i]=f[i-1]+f[i/2];
        }
    }
    cout<<f[n];
    return 0;
}

```

---

## 作者：Chengqijun2012 (赞：17)

一道水题，本蒟蒻来交一篇递推的题解。

我们可以设 $cnt_{i}$ 为以 $i$ 为第一个数时所能构造的合法数列的数量，最后的 $cnt_{n}$ 就是答案总数。

那么怎么求 $cnt_{i}$ 呢？我们只需让
$$
cnt_{i} = \sum_{j = 1} ^ {i / 2} cnt_{j}
$$
就可以一步一步推导出来啦！

AC Code:
```cpp
#include <iostream>
using namespace std;
int n, cnt[299999];

int main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= i / 2; j++) cnt[i] += cnt[j];       //累加cnt[1]~cnt[i / 2]
		cnt[i]++;       //不要忘了加上自己
	}
	cout << cnt[n] << ' ';
	return 0;
}
```
蒟蒻的第一篇题解，望管理员大大通过qwq。

---

## 作者：x12345678901 (赞：12)

# 题解

洛谷书上的例题竟然只有一篇递推题解？既然如此，我来发个递归的。
## 讲解

比如按照题目条件（可在深基查到原题）输入 6，则合法的有
```
[6],[6 1],[6 2],[6 3],[6 2 1],[6 3 1]
```
如果只让加一个数，那就简单了。方案数就是输入数字的一半。（很好理解）

但是题目中说了可以加入多个，怎么办呢？

我们可以发现，在 6 后面加入 3 时，就相当于加入了3的所有情况。（肯定合法，因为不超过 3 的一半的数肯定不会超过 6 的一半）2 和 1 也是同理。

所以，总方案数就等于（用 $f_n$ 表示 $n$ 的方案数）$1+f_1+f_2+f_3$（还要加一的原因是```[6]```本身也是一种合法数列，得加上。）。

拓展到正整数 $x$，就是  $1+f_1+f_2+······+f_{\lceil n/2\rceil}$。
所以可以写出代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int qwerty(int x){//求解函数
	if(x==1){
		return 1;
	}
	int tmp=1;
	for(int i=1;i<=x/2;i++){
		tmp+=qwerty(i);
	}
	return tmp;
}
int main(){
	int n;
	cin>>n;
	cout<<qwerty(n);
	return 0;
}

```

但是这段代码会超时，因为进行了很多重复计算（如```qwerty(2)```可能被```qwerty(4)```调用，也可能被```qwerty(6)```调用，而```qwerty(4)```和```qwerty(6)```都会被```qwerty(15)```调用）

所以我们可以定义一个数组```ans```，```ans[i]```就是 $i$ 的方案数。首先初始化为 -1，代表还没有算过。然后按照之前的方法算，如果发现算过了就直接返回```ans[i]```，否则就按照之前的方法算，算好之后再存到```ans```数组中。

改进后的代码：


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int ans[1000];
int qwerty(int x){//求解函数
	if(x==1){
		return 1;
	}
	if(ans[x]!=-1){
		return ans[x];
	}
	int tmp=1;
	for(int i=1;i<=x/2;i++){
		tmp+=qwerty(i);
	}
	return ans[x]=tmp;
}
int main(){
	int n;
	cin>>n;
	memset(ans,-1,sizeof(ans));//初始化为-1
	cout<<qwerty(n);
	return 0;
}

```

题解完。

---

## 作者：__KevinMZ__ (赞：9)

记忆化搜索。

令 $a_i$ 为 $\text{dfs}(i)$，这样就可以少做亿点点递归。

剩下按题意递归即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1010];//记忆化数组
int dfs(int n)
{
	int ans = 0;
	ans++;//加上n本身这个序列
	for(int i = n / 2; i > 0; i--)//枚举接在n后面的数
		if(a[i] != 0) ans += a[i];
		else ans += (a[i] = dfs(i));//记忆化
	return ans;
}
int main()
{
	int n;
	cin >> n;
	cout << dfs(n);
	return 0;
}
```

---

## 作者：Ljh421 (赞：6)

## 这是一篇 $dp$ 题解。

## 思路

从 $1$ 开始一直遍历到 $n$，并记下它们的合法数列的个数。

题中写到：**这个正整数不能超过该数列最后一项的一半**。所以 $i$ 后面的数只有 $1$ 到 $\frac{i}{2}$ 的整数。

设一个数 $x$ 后面的数为 $y$，那么必须保证 $x>y$，因为 $y$ 遍历了，所以 $x$ 的个数要加上 $y$ 的个数。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1003],n;
int main(){

	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i/2;j++){
			f[i]+=f[j];
		}
		f[i]++;
	}
	cout<<f[n];
	
	return 0;
}
```

---

## 作者：Eric1030 (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P1028)

这道题不算太难，我们先把数据输入进来，然后用递归和循环来找每一种可能，最后输出可能数就好了。

讲到这里，你的代码可能就写完了，就像这样。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1005];
int func(int n)
{
	if(n==1)
	{
		return 1;
	}
	int cnt=1;
	for(int i=1;i<=n/2;i++)
	{
		cnt+=func(i);
	}
	a[n]=cnt;
	return a[n];
	
}
int main()
{
	cin>>n;
	cout<<func(n);
	return 0;
}
```
当你信心满满的提交时，你就会得到 [TLE 的拥抱](https://www.luogu.com.cn/record/204870073)。

为什么呢？因为我们在计算时，有很多情况重复算了，就会导致超时，因此我们要用记忆化搜索来节省时间复杂度。

## [AC](https://www.luogu.com.cn/record/204863022) 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1005];
int func(int n)
{
	if(n==1)//到1了就代表到头了
	{
		return 1;
	}
	if(a[n]!=0)//不是0就代表之前算过
	{
		return a[n];
	}
	int cnt=1;
	for(int i=1;i<=n/2;i++)//枚举每个数
	{
		cnt+=func(i);//加上下一个数为i的可能数
	}
	a[n]=cnt;
	return a[n];
	
}
int main()
{
	cin>>n;
	cout<<func(n);
	return 0;//结束！
}
```

---

## 作者：dread_breaker (赞：2)

## 思路：

用 $s_{i}$ 存储以数字 $i$ 开头的数列个数，递归参数是当前填的数字，最后输出 $s_{n}$。

时间复杂度：$O(n^2)$。

## 代码：


```
#include <bits/stdc++.h>
using namespace std;

const int M = 1e3 + 5;

int n, s[M];

void dg(int x){
	if(s[x] > 0) return;
	s[x] = 1;
	for(int i = 1; i <= x / 2; i++) dg(i), s[x] += s[i];
}

int main() {
	cin >> n;
	dg(n);
	cout << s[n] << "\n";
	return 0;
}
```

---

## 作者：Lawrenceling (赞：2)

这题是可以 $O(n)$ 的。

设 $a_i$ 为数 $i$ 的数列个数。则有：

$$a_i=\sum^{\lfloor i\div 2\rfloor}_{j=1}a_j+1$$

特别地，$a_1=1$。

进一步地，设前缀和数组 $s_i=\sum^{i}_{j=1}a_j$，则整个过程可以用 $O(n)$ 求解。 

### AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e3+10; 
int n,a[N],s[N];

int main()
{
	cin>>n;
	a[1]=s[1]=1;
	for(int i=2;i<=n;++i)
	{
		a[i]=s[i/2]+1;
		s[i]=s[i-1]+a[i];
	}
	cout<<a[n];
	return 0;
} 
```

---

## 作者：zhangzirui66 (赞：1)

## 闲话
本文同步发布在 [cnblogs](https://www.cnblogs.com/zhangzirui66) 且建议将网页放大至 125%。

---

计数题优先考虑 dp。

dp 状态即 $f_i$ 表示出现一个 $i$ 后后面的答案。

转移公式易得为：

$$
f_i = \sum^{j = 1}_{\lfloor \frac{i}{2} \rfloor} + 1
$$

这里稍作解释，求和即为枚举接下来放什么，后面加一即为后面不加。

代码复杂度为 $O(n^ 2)$：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, f[1005];
int main(){
	cin >> n;
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= i / 2; j ++) f[i] += f[j];
		f[i] ++;
	}
	cout << f[n];
	return 0;
}
```

---

## 拓展

若 $n \le 2 \times 10^5$，原方法将超时，可对 $f$ 做前缀和，若 $sum$ 为前缀和数组，转移方程变为：

$$
f_i = sum_{i / 2} + 1
$$

代码复杂度为 $O(n)$：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, f[1005], sum[1005];
int main(){
	cin >> n;
	for(int i = 1; i <= n; i ++){
		f[i] += sum[i / 2] + 1;
		sum[i] = sum[i - 1] + f[i];
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：yzc1125 (赞：1)

# 思路
可以使用递归的方法，因为每个数在后面加一个不超过一半的数，记 $f_i$ 是 $i$ 所可以的合法数列的个数，所以：
 
 $f_n = (\sum_{i=1}^{n \div 2} f_i)+1$ 
 
 在这里我们可以使用记忆化，时间复杂度会大大降低
# CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int f[N];
int dfs(int n)
{
	if (f[n]!=0) return f[n];
	for (int i=1;i<=n/2;i++)
	{
		if (f[i]==0)
		{
			f[i]=dfs(i);
		}
		f[n]+=f[i];
	}
	f[n]++;
	return f[n];
}
int main()
{
	int n;
	f[1]=1;
	cin>>n;
	cout<<dfs(n);
}
```

---

## 作者：qhr2023 (赞：1)

## solution

递推。

对于一个数 $i$，它后面能接 $1$ 到 $\frac{i}{2}$ 的任何一个数，也可以不接，这样就得到了递推式。设 $f_i$ 表示 $n=i$ 时的答案，那么 $f_i=f_1+f_2+f_3+...+f_{\lfloor \frac{i}{2} \rfloor}+1$，时间复杂度 $O(n^2)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, f[1001];
int main(){
	cin >> n;
	for(int i=1; i<=n; i++){
		for(int j=1; j<=i/2; j++)
			f[i]+=f[j];
		f[i]++;
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：1)

### 思路

容易看出本题应使用递推。

假设 $f_i$ 表示当 $n = i$ 时的答案数量，那么 $f_i$ 就可以从 $f_1$ 到 $f_{\lfloor\frac{i}{2}\rfloor}$ 转移得来，再加上单独一个 $i$ 的序列，故得出递推式为 $
f_i = 1 + \sum\limits_{j = 1}^{\lfloor\frac{i}{2}\rfloor}{f_j}
$。  
不难得出边界为 $f_1 = 1$。

### 实现

```cpp
# include <iostream>
using namespace std;
int f[1005] = {0,1};
int main(){
	int n; cin >> n;
	for (int i = 2;i <= n;i++){
        f[i] = 1;
		for (int j = 1;j <= i / 2;j++) f[i] += f[j];
	}cout << f[n];
	return 0;
}
```

---

## 作者：wenqinghua1001 (赞：1)

# 一道很简单的橙题

### [题目传送门](https://www.luogu.com.cn/problem/P1028)

[AC 记录](https://www.luogu.com.cn/record/184030245)

这道题是一道 DFS 题，让你求出数列数，话不多说，直接打了一个暴力代码。

代码（优化前的）：


```cpp
#include<bits/stdc++.h>
using namespace std;
int ans=0;
void dfs(int n){
	ans++;
	for(int i=1;i<=n/2;i++)
		dfs(i);
	return ;
}
int main(){
	int n;
	cin>>n;
	dfs(n);
	cout<<ans;
	return 0;
}
```

[TLE 记录](https://www.luogu.com.cn/record/176896991)

我的天哪，超时，这道题还要加一个小小的优化。

优化：$t_n$ 表示 $n>0$ 时的**最多**数列数，避免重复计算，浪费时间。

代码（优化后的）：

```cpp
#include<bits/stdc++.h>
// 万能头。 
using namespace std;
int t[1000001];
// 标记数组。 
int dfs(int n,int ans){
	if(t[n]!=-1){
		// 优化： 
		// 如果当前数字用过。
		// （已经有答案了）。 
		return t[n];
		// 返回算过的答案。 
	}
	int tmp=ans;
	for(int i=1;i<=n/2;i++) // 不能超过该数列最后一项的一半。 
		ans+=dfs(i,tmp);// 答案累加。 
	t[n]=ans;
	// 标记答案。
	// t[n]表示n>0时的最多数列数。 
	return ans;
	// 返回答案。 
}
// 暴力求答案。
int main(){
	memset(t,-1,sizeof(t)); 
	// 一开始都没用到。 
	int n;
	cin>>n;
	// 读入。 
	cout<<dfs(n,1);
	// 输出。 
	return 0;
	// 好习惯+1。 
}
```

---

## 作者：glass_goldfish (赞：1)

简单的递推题目。

记 $f_i$ 为当 $i=n$ 时的答案。根据题意，递推式显然为 $f_1=1,f_i(i>1)=f_1+f_2+\ldots+f_{\lfloor \frac{i}{2}\rfloor}+1$。最后输出即可。时间复杂度为 $O(n^2)$，足以通过本题。

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define INF 0x3f3f3f
using namespace std;
int n;
int f[10001];
signed main(){
	cin>>n;
	f[1]=1;//边界
	for(int i=2;i<=n;i++){
		int tot=0;
		for(int j=1;j<=i/2;j++)
			tot+=f[j];//求和
		f[i]=tot+1;//记录
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：lylcpp (赞：0)

## 思路

直接 dfs，很显然，当 $n = 1$ 时，答案是 $1$，所以就把 $n=1$ 设为递归边界，之后计算 $f_1$ 到 $f_{\left \lfloor \frac{n}{2} \right \rfloor}$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int f(int n)
{
	if(n == 1)
		return 1;
	int cnt = 0;
	for(int i = 1; i <= n / 2; i++)
	{
		cnt += f(i);
	}
	return cnt + 1;
}
int main()
{
	int n;
	cin >> n;
	cout << f(n) << endl; 
	return 0;
}
``````

---


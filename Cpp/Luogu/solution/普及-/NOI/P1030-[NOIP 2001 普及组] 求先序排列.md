# [NOIP 2001 普及组] 求先序排列

## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。


## 说明/提示

**【题目来源】**

NOIP 2001 普及组第三题

## 样例 #1

### 输入

```
BADC
BDCA
```

### 输出

```
ABCD
```

# 题解

## 作者：sunyufei (赞：1344)

首先，一点基本常识，给你一个后序遍历，那么最后一个就是根（如ABCD，则根为D）。

因为题目求先序，意味着要不断找根。

那么我们来看这道题方法：（示例）

中序ACGDBHZKX，后序CDGAHXKZB，首先可找到主根B；

那么我们找到中序遍历中的B，由这种遍历的性质，可将中序遍历分为ACGD和HZKX两棵子树，

那么对应可找到后序遍历CDGA和HXKZ（从头找即可）

从而问题就变成求1.中序遍历ACGD，后序遍历CDGA的树 2.中序遍历HZKX，后序遍历HXKZ的树；

接着递归，按照原先方法，找到1.子根A，再分为两棵子树2.子根Z，再分为两棵子树。

就按这样一直做下去（先输出根，再递归）；

模板概括为step1:找到根并输出

step2:将中序，后序各分为左右两棵子树；

step3:递归，重复step1,2；

代码如下

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
void beford(string in,string after){
    if (in.size()>0){
        char ch=after[after.size()-1];
        cout<<ch;//找根输出
        int k=in.find(ch);
        beford(in.substr(0,k),after.substr(0,k));
        beford(in.substr(k+1),after.substr(k,in.size()-k-1));//递归左右子树；
    }
}
int main(){
    string inord,aftord;
    cin>>inord;cin>>aftord;//读入
    beford(inord,aftord);cout<<endl;
    return 0;
}
```

---

## 作者：NeosKnight (赞：349)

模拟了好久，终于找出了套路，用的是DFS，其实就是递归；


我说一下这题的主要的方法（要点），

1.后序遍历中，最后一个节点一定是根节点（对于每一颗子树也成立）；

2.既然这题要求先序遍历，那么我们只需一次输出访问的父节点即可；

这样的话，我们只要递归将一棵大树分成两颗子树，让后找他们的父节点，不断递归输出；

3.那么难点就在这了，如何通过一个中序和后序遍历中找出两段子树的后序遍历序列（后序，因为只有后序我们才方便找到父节点）呢？


自己可以拿几个样例做一做，耐性点就会发现它的套路，我这里简单说一下：

在中序遍历中找到当前父节点后，我们可以分别求出他的左子树节点数和右子树节点数，因为中序遍历访问的顺序是左子树，父节点，右子树，所以可以直接计算出；


然后，由于我们对结点的访问一定是先访问一颗子树，在访问另一颗，所以在我们的原后序遍历串右边界中减掉右子树节点个数再减一即为新的左子树右边界，在原后序遍历串左边界加上左子树节点个数即为新的右子树左边界；


当然右子树右边界和左子树左边界这个非常好确定，就不在多说，自己看代码吧


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char s1[10];
char s2[10];
int len;
inline int find(char ch)
{
    for(int i=0;i<len;i++)
    {
        if(s1[i]==ch) return i;
    }
}
void dfs(int l1,int r1,int l2,int r2)
{
    int m=find(s2[r2]);
    cout<<s2[r2];
    if(m>l1) /*具有左子树*/dfs(l1,m-1,l2,r2-r1+m-1);//r1-m为右子树结点数 
    if(m<r1) /*具有右子树*/dfs(m+1,r1,l2+m-l1,r2-1);//m-l1为左子树节点数
}
int main()
{
    cin>>s1;
    cin>>s2;
    len=strlen(s1);
    dfs(0,len-1,0,len-1);
}

```

---

## 作者：sshwy (赞：164)

看到很多中规中矩的递归题解

这里提供一种新思路——**二叉搜索树**

### 算法背景


因为对于二叉搜索树左小右大的原则，其中序遍历即为树中的元素的升序排列；而后序遍历是按先左子右子再根节点的顺序输出；

因此
对于**二叉搜索树**而言

如果按照其后序遍历的**颠倒**后的顺序插入元素，就可以**还原整棵树**！

原因是在元素x被插入以前，x的父节点已经插入在树中（后序遍历的颠倒后的顺序），因此x一定会插入到原来的树中的位置上。


### 算法描述


- 对于中序遍历的字符串的字母从小到大标号

- 利用**后序遍历的颠倒后的顺序**把标号插入到二叉搜索树中

- 把这颗二叉搜索树按前序遍历，输出每个结点存储的标号对应的字母


### 算法样例


- 对于样例的数据

BADC
BDCA
- 对中序遍历标号如下

BADC
1234
- 因此后序遍历即为

1342
- 颠倒后

2431
- 于是按照2431的顺序插入二叉树如下（实在画不了图）

2：左子1，右子4

1：叶节点

4：左子3，右子NULL

3：叶节点

- 因此前序遍历为

2134
- 对应字母

ABCD

### 题解代码


```cpp
#include<iostream>
#include<cstring>

using namespace std;

char pre[10];//后序遍历
char mid[10];//前序遍历
int num[300];//字母对应的数字
char let[10];//数字对应的字母

struct node//结点
{
    int key;
    node * p=NULL;//父节点
    node * left=NULL;//左子
    node * right=NULL;//右子
};
typedef struct node * bNode;//结点指针

bNode tree_insert(bNode tree_root,int nkey)//二叉搜索树插入函数
{
    bNode z=new node,y=NULL,x=tree_root;
    z->key=nkey;
    while(x!=NULL)
    {
        y=x;
        if(nkey<x->key)x=x->left;
        else x=x->right;
    }
    z->p=y;
    if(y==NULL)tree_root=z;
    else if(nkey<y->key)y->left=z;
    else y->right=z;
    
    return tree_root;
}

void tree_preorder(bNode k)//前序遍历输出
{
    if(k==NULL)return;
    cout<<let[k->key];//key对应的字母
    tree_preorder(k->left);
    tree_preorder(k->right);
}

int main()
{
    bNode t1=NULL;
    cin>>mid>>pre;
    for(int i=0;mid[i]!='\0';i++)//建立字母与标号的双向联系
    {
        num[mid[i]]=i;
        let[i]=mid[i];
    }
    for(int i=strlen(pre)-1;i>=0;i--)//按颠倒顺序插入
    {
        t1=tree_insert(t1,num[pre[i]]);
    }
    tree_preorder(t1);
    return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：28)

# P1030 [NOIP2001 普及组] 求先序排列 题解

[题目传送门](https://www.luogu.com.cn/problem/P1030)

## 前置知识
（注意，前置知识过于冗长，建议直接点进右上角的**查看文章**，便于直接跳转至题目分析）

前序遍历（先序遍历或先根遍历）、中序遍历（中根遍历）和后序遍历（后根遍历）都是遍历二叉树的方式。  
下面给出一棵二叉树（根节点为 $\text A$）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jaap6zzs.png)  
### 先序遍历
其方法为**根左右**，我们具体来看。

![](https://cdn.luogu.com.cn/upload/image_hosting/zq2clyyy.png)  
我们先看红色三角形中的子树，因为是**根左右**，所以先写下根；接下来看左孩子和右孩子，我们写下它们。  
目前的序列为：$\text{ABC}$。  

紧接着我们要看以这个**左孩子为根的子树**，如下图橙色三角形中所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/bamcyzwd.png)  
现在的根为 $\text B$，我们再对**这棵子树**进行**根左右**的方法。我们已经写过了 $\text B$，所以我们看左孩子 $\text D$，将它写下。  
由于 $\text D$ 已经是叶节点，所以我们可以看右孩子 $\text E$ 了，将它写下。  
目前的序列为：$\text{ABDEC}$。  
注意这里要写在 $\text B$ 的后面，因为它们属于 $\text B$ 的子树。

我们已经把红色三角形子树中的**左**完成了，所以就可以看**右**了，也就是以**右孩子为根的子树**，如下图金色三角形中所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/pw2tyu6i.png)  
类比刚才的方法，由于它没有左孩子，所以直接看到右孩子 $\text F$，写下来。

所以最终的先序序列为：$\text{ABDECF}$。  
看到这里，你是否想到什么**算法**？让我们继续往下看。

### 中序遍历
其方法为**左根右**。  
![](https://cdn.luogu.com.cn/upload/image_hosting/avfyrr3s.png)  
先看到深绿色三角形中的子树，但这次为**左根右**，所以我们依次写下左孩子，根和右孩子。  
目前的序列为：$\text{BAC}$。 

接下来看到以**左孩子为根的子树**，如下图绿色三角形中所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zreyxu34.png)  
仍然是按照**左根右**的形式写下。要注意的是因为左在根前面，所以我们要将 $\text D$ 写在 $\text B$ 之前。  
目前的序列为：$\text{DBEAC}$。

最后看到以**左孩子为根的子树**，如下图浅绿色三角形中所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/w0tsn7a1.png)  
还是同理，最后我们得到的中序序列为：$\text{DBEACF}$。  
看到这里，你是否又有想法？我们稍后揭晓。

### 后序遍历
其方法为**左右根**。  
类比刚才的方法，我们看到淡蓝色三角形中的子树：  
![](https://cdn.luogu.com.cn/upload/image_hosting/xdajoj4b.png)   
由于是**左右根**，所以我们依次写下左子树，右子树和根。  
目前的序列为：$\text{BCA}$。

接下来还是看到以**左孩子为根的子树**，如下图蓝色三角形中所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/t1f78byo.png)  
按照**左右根**的形式写下。注意因为左和右在根前面，所以我们要将 $\text D$ 和 $\text E$ 写在 $\text B$ 之前。  
目前的序列为：$\text{DEBCA}$。

最后是以**右孩子为根的子树**，如下图天蓝色三角形中所示：  
![](https://cdn.luogu.com.cn/upload/image_hosting/4e785sep.png)  
依旧一样，把右写在根前面。  
最后我们的后序序列为：$\text{DEBFCA}$。

我们是不是可以联想到**递归**？虽然以上与本题似乎没太大关系，但我们仍然需用递归求解本题。
## 题目分析
看到题目，我们需要用中序序列和后序序列来**建树**，之后求出先序遍历即可。

### 性质
如果我们仔细观察中序序列和后序序列，会发现以下性质：  
* 一棵子树的**序列**总是**相邻**的。  
* 一棵子树的**后序序列**中的**最后一个**总是这棵子树的**根**。  
* 一棵子树的**中序序列**中的**根**总是将这棵子树的**左子树**和**右子树**分隔开。  

根据以上性质，我们便可以解决这个问题了。

### 建树
我们可以采用**递归**的方式来建树。

递归函数会返回当前子树的根对应的下标，这个下标会不断增加。  
我们先用后序序列找到该子树的**根**，将它存下，并且寻找它在**中序序列**中的**位置**。  
接下来我们**分别截取左右子树**的**中序序列**和**后序序列**，分别对它们进行**建树**操作。  
直到建树操作完成后，才停止递归。

代码如下：

```cpp
string InOd,PostOd;
struct node{
	char val;
	int l,r;
}tree[30];
int pos;
int buildTree(string InOd,string PostOd){
	int len = InOd.size();
	if(len == 0) return 0;
	
	char c = PostOd[len-1];// 根
	int root = ++pos;
	tree[root].val = c;// 存根
	
	int k = InOd.find(c);// 根在中序中的位置 
	
	tree[root].l = buildTree(InOd.substr(0,k),PostOd.substr(0,k));
	tree[root].r = buildTree(InOd.substr(k+1),PostOd.substr(k,len-k-1)); // 建议此处细细品味
	return root;
}

```
### 输出先序序列
我们仍然使用**递归**的方式来输出。

我们结合其**根左右**的方法便可以求出。

最终代码如下：

```cpp
#include <iostream>
#include <string>
using namespace std;

string InOd,PostOd;
struct node{
	char val;
	int l,r;
}tree[30];
int pos;
int buildTree(string InOd,string PostOd){
	int len = InOd.size();
	if(len == 0) return 0;
	
	char c = PostOd[len-1]; // 根
	int root = ++pos;
	tree[root].val = c; // 存根
	
	int k = InOd.find(c); // 根在中序中的位置 
	
	tree[root].l = buildTree(InOd.substr(0,k),PostOd.substr(0,k));
	tree[root].r = buildTree(InOd.substr(k+1),PostOd.substr(k,len-k-1)); 
	return root;
}

void printPreOd(int root){
	cout << tree[root].val; // 对应根 
	if(tree[root].l) printPreOd(tree[root].l); // 对应左 
	if(tree[root].r) printPreOd(tree[root].r); // 对应右 
}

int main(){
	cin >> InOd >> PostOd;
	int root = buildTree(InOd,PostOd);
	printPreOd(root);
	return 0;
}
```



## 总结
是一道基础的题，考察二叉树的遍历方式及递归，适合初学者练习。

感谢您的阅读！

---

## 作者：chinazhanghaoxun (赞：13)

## 思路
这道题主要就是推导出几种排列方式之间的关系，我们先找一个例子。假设一个二叉树的中序排列是 `DBAGEHCF`，后序排列是 `DBGHEFCA`。分析过程如下。

通过概念可得，后序排列的最后一个节点 `A` 一定是根，由此，我们可以将中序排列分为左子树 `DB` 和右子树 `GEHCF`。再进行一次操作，可以得到左子树的根为 `B`，右子树的根为 `C`，以此类推，得到整棵树的结构。

分析完后，我们就可以发现这其实就是一道递归练手题目，只要加以字符串的使用技巧就可以过。
## 代码及注释
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
void func(string a,string b){ //递归函数 
	if(a.length()==0){ //子树已经判断完了 
		return ;
	}
	int len=b.length();
	char c=b[len-1]; //找到子树的根 
	cout<<c; //由于是先序排列，所以直接输出根即可 
	int p=a.find(c); //找到根所在的位置，分为左右子树 
	//字符串使用自带函数会更方便 
	func(a.substr(0,p),b.substr(0,p)); //先遍历左子树 
	func(a.substr(p+1),b.substr(p,a.length()-p-1)); //再遍历右子树 
}
int main(){
	cin>>s>>t;
	func(s,t);
	return 0;
}
```

---

## 作者：「QQ红包」 (赞：9)

这题搜索就可以了……


二叉树的先序遍历是根左右，中序遍历是左根右，后序遍历是左右根


以样例为例，BADC是中序遍历，BDCA是后序遍历。因为后续遍历是左右根，所以可以判断，A是根，输出根。在BADC，根A是第二个，那么可以判断B是左子树，DC是右子树。我们还可以知道，在后续排列中，B就是左子树，DC是右子树。之后左子树和右子树分别重复以上过程，直到该子树

```delphi

var s,ss:string;
procedure try(s1,s2:string);
var s3,s4,s5,s6:string;
　　ch:char;
　　k:longint;
begin
　　if s1='' then exit;
　　write(s2[ord(s2[0])]);
　　ch:=s2[ord(s2[0])];
　　k:=pos(ch,s1);
　　s3:=copy(s1,1,k-1);
　　s5:=copy(s1,k+1,length(s1)-k);
　　s4:=copy(s2,1,k-1);
　　s6:=copy(s2,k,length(s2)-k);
　　try(s3,s4);//往左搜
　　try(s5,s6);//往右搜
end;
begin
　　readln(s);
　　readln(ss);
　　try(s,ss);
end.

```

---

## 作者：_Deer_Peach_ (赞：8)

给出一棵二叉树的中序和后序遍历，求先序遍历。

做这道题，我们要先知道什么事二叉树的先序、中序和后序遍历。

先序遍历如下图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/dhss4p5g.png)
1. 从根节点 $1$ 出发，往左走找到节点 $2$。
2. 从节点 $2$ 往左走找到节点 $4$，由于节点 $4$ 没有孩子，所以往回走到 $2$。
3. 从节点 $2$ 往右走找到节点 $5$，由于节点 $4$ 没有孩子，所以往回走到 $2$。
4. 节点 $2$ 的左右孩子都遍历完了，往回走到节点 $1$。
5. 从根节点 $1$ 出发，往右走找到节点 $3$。
6. 从节点 $3$ 往左走找到节点 $6$，由于节点 $6$ 没有孩子，所以往回走到 $3$。
7. 从节点 $3$ 往右走找到节点 $7$，由于节点 $7$ 没有孩子，所以往回走到 $3$。
8. 节点 $3$ 的左右孩子都遍历完了，往回走到节点 $1$。
9. 节点 $1$ 的左右孩子都遍历完了，所以遍历结束，先序遍历结果为 $1245367$。

中序遍历如下图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/ka6auzoy.png)
1. 从根节点 $1$ 出发，找左孩子节点 $2$；
2. 找 $2$ 的左孩子 $4$；
3. 由于 $4$ 没有左孩子和右孩子，输出 $4$ ，返回到 $2$；
4. $2$ 的左子树遍历完，输出 $2$，找 $2$ 的右孩子 $5$；
5. 由于 $5$ 没有左孩子和右孩子，输出 $5$，返回到 $2$；
6. $2$ 的左右孩子遍历完了，返回到 $1$；
7. $1$ 的左子树遍历完了，输出 $1$，找 $1$ 的右孩子 $3$；
8. 找 $3$ 的左孩子 $6$；
9. 由于 $6$ 没有左孩子和右孩子，输出 $6$，返回到 $3$；
10. $3$ 的左子树遍历完，输出 $3$，找 $3$ 的右孩子 $7$；
11. 由于 $7$ 没有左孩子和右孩子，输出 $7$，返回到 $3$；
12. $3$ 的左右孩子遍历完了，返回 $1$；
13. 根节点 $1$ 的左右孩子遍历完了，遍历结束，中序遍历结果为 $4251637$。

后序遍历如下图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/l0gryynp.png)
1. 从根节点 $1$ 出发，找左孩子 $2$；
2. 找 $2$ 的左孩子 $4$；
3. $4$ 没有左右孩子，输出 $4$，返回到 $2$；
4. 找 $2$ 的右孩子 $5$；
5. $5$ 没有左右孩子，输出 $5$，返回到 $2$；
6. $2$ 的左右孩子遍历完了，输出 $2$，返回到 $1$；
7. 找 $1$ 的右孩子 $3$；
8. 找 $3$ 的左孩子 $6$；
9. $6$ 没有左右孩子，输出 $6$，返回到 $3$；
10. 找 $3$ 的右孩子 $7$；
11. $7$ 没有左右孩子，输出 $7$，返回到 $3$；
12. $3$ 的左右孩子遍历完了，输出 $3$，返回到 $1$；
13. 根节点 $1$ 的左右孩子遍历完了，输出 $1$，遍历结束，后续遍历结果为 $4526731$。


根据不同遍历的顺序，我们只要知道其中两个遍历的顺序，都可以推出另一种遍历的顺序。

这里我们知道中序遍历和后序遍历，推先序遍历。通过不同遍历的顺序，将遍历顺序的字符串分割成三部分：根，左子树遍历顺序，右子树遍历顺序。再根据遍历顺序，求出先序遍历。

代码：
```
#include<bits/stdc++.h>
using namespace std;
string a,b,c="";
void dfs(string x,string y){//中序遍历和后序遍历的结果
	int xlen=x.size();
	int ylen=y.size();
	if(xlen==0) return ;//遍历结束
	char gen=y[ylen-1];//根节点在后序遍历最后
	cout<<gen;
	int g=x.find(gen);//找到根节点在中序遍历的哪个位置，分成左子树和右子树继续遍历
	dfs(x.substr(0,g),y.substr(0,g));
	dfs(x.substr(g+1),y.substr(g,ylen-g-1));
}
int main(){
	cin>>a>>b;
	dfs(a,b);
	return 0;
}
```

---

## 作者：cath20 (赞：8)

[题目传送锚点](https://www.luogu.com.cn/problem/P1030)

[在博客园食用更佳](https://www.cnblogs.com/cath20/p/18692751)

本题完全是一道初赛题。别问我为什么，问就是你去翻翻 J 组初赛题，看能不能翻到这类题。

好了，话不多说，上思路！

1. 找到根节点（后序遍历的最后一个字母），输出它，再在中序遍历中找到它。那么它的左边就是左子树，右边就是右子树；
2. 把左子树挑出来，并找出它的根。然后再不断重复本步骤；
3. 输出完左子树的根后，再去输出右子树的根。

虽然上述内容很抽象，但最激动人心的时刻到了：上代码！


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

string a,b;										//a是中序，b是后序

void f(string a,string b)						//a是本段的序，b是本段的后序
{
	if(!a.size()) return;						//如果a里啥都没有，那b里也会啥都没有，那就别遍历了
    cout<<b[b.size()-1];						//输出根
    int z=a.find(b[b.size()-1]);                //记录一下根在中序的位置
    f(a.substr(0,z),b.substr(0,z));             //去遍历左子树
    f(a.substr(z+1),b.substr(z,a.size()-z-1));  //去遍历右子树
}

signed main()
{
    cin>>a>>b;
    f(a,b);                                     //遍历开始
    return 0;
}
```

不会 `s.substr(a,b)` 就查资料，大概就是把字符串 $s$ 中的第 $a$ 到第 $b$ 位提取出来。

完结撒花。

---

## 作者：GZXUEXUE (赞：3)

### 思路

可能有点麻烦。

我们可以先从后序遍历入手，因为它的最后一个字符必定是当前这棵子树的根。随后，我们在中序遍历中寻找根，把中序遍历与后序遍历拆分成两半，继续递归建树，最后按先序输出树即可。

时间复杂度大约为 $O(n)$。

### 实现

```cpp
# include <iostream>
# include <cstring>
using namespace std;
char tree[100]; int n = 1;
void dfs(string a,string b,int root){
    if (a.size() == 0) return;
    if (a.size() == 1){
		tree[root] = a[0];
		return;
	}tree[root] = b[b.size()-1];
	string head = "",tail = "";
	for (int i = 0;i < a.size();i++){
		if (a[i] == tree[root]) break;
		head += string(1,a[i]);
	}tail = a.substr(head.size() + 1,a.size());
	string head_b = b.substr(0,head.size()),tail_b = b.substr(head.size(),b.size());
	tail_b = tail_b.substr(0,tail_b.size() - 1);
    dfs(head,head_b,root*2);
	dfs(tail,tail_b,root*2+1);
}void output(int node){
	if (node > n) return;
    if (tree[node] != 0) cout << tree[node];
	output(node*2); output(node*2+1);
}int main(){
	string a,b; cin >> a >> b;
	for (int i = 0;i < a.size();i++) n = n * 2 + 1;
	dfs(a,b,1);
	output(1);
	return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

给定中序后序求先序，经典的树形结构模拟题。

先明确先序遍历的顺序是根、左子树、右子树，简称根左右，中序遍历的顺序是左根右，后序遍历的顺序是左右根。

所以模拟过程如下，找到根即后序排列的最后一个字符，输出根，先递归左子树，再递归右子树，若当前子树为空则返回上一层。

对于如何找左右子树，在中序遍历中找到根，根前边的就是左子树，根后边的就是右子树。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
string a, b;
void dfs(string a, string b){
	if(!b.size()) 
		return;
	char rt=b[(int)b.size()-1];
	cout << rt;
	for(int i=0; i<(int)b.size(); i++)
		if(a[i]==rt)
			dfs(a.substr(0, i), b.substr(0, i)), 
			dfs(a.substr(i+1), b.substr(i, b.size()-i-1));
}
int main(){
	cin >> a >> b; dfs(a, b);
	return 0;
}
```

---

## 作者：xyx404 (赞：3)

## 思路：
递归构建二叉树，并输出先序排列。

首先要知道后序排列、中序排列是怎么构成的。  
后序排列是先左，然后右，最后根；中序排列是先左，然后根，最后右。

依此我们可以确定后序排列中的最后一个一定是这个树的根，我们可以将根的左右两边分为两个子树，左子树和右子树，在中序排列中在根左边的是左子树，在右边的是右子树，最后便可构建出二叉树。

例如样例：  
给出了中序排列为 BADC，后序排列为 BDCA，可以看的后序排列的最后一个字母是 A，那么说明 A 是根，然后我们在中序排列中找到 A，此时 A 左边的是左子树里的，右边是右子树里的。

所以现在可以转换为：
- 左子树：中序排列为 B，后序排列是 B。
- 右子树：中序排列为 DC，后序排列是 DC。

接着我们一直递归直到不能递归就能构建出二叉树了。

样例可能有点小不好理解这里给出另一组再进行一次解释。  
当中序排列为 CBEAGDF，后序排列为 CEBGFDA 时。  
后序排列的最后是 A，所以 A 是根，然后再确定左、右子树。

然后当有左子树时，把它当做一个独立的二叉树处理，查询它的后序排列，确定根，然后接着确定这个二叉树的左、右子树；当有右子树时进行一样的操作。

本树构建过程画出如下的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/zoo058vl.png)

当然在代码中我们无法同时处理左、右两个子树，所以在代码中我们要将它们分别处理。


总的来说就是由后序排列确定根，由中序排列确定左子树和右子树，然后继续递归直到不能递归。

为了输出先序排序，我们可以先把每次的根输出，然后处理左子树，最后再处理右子树，因为先序排序是先根，然后左，最后右。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long 
string a,b;
struct node{
	char data;
	int l,r;
}tree[60];
void jiangshu(int al,int ar,int bl,int br,int k){
	int root=a.find(b[br]);
	tree[k].data=b[br];
	cout<<tree[k].data;
	if(root>al){
		tree[k].l=2*k;
		jiangshu(al,root-1,bl,br-ar+root-1,2*k);
	}
	if(root<ar){
		tree[k].r=2*k+1;
        jiangshu(root+1,ar,br+root-al,br-1,2*k+1);
	}
}
int main(){
    cin>>a>>b;
    jiangshu(0,a.size()-1,0,b.size()-1,1);
    return 0;
}
```

---

## 作者：longlong_int (赞：3)

# 思路

## 基本步骤
想一想你做普及组初赛题的时候是怎么办的：

1. 在后序排列中找到最后一个，即根（这时就可以先把根写下来）；
2. 在中序排列中找到根；
3. 将根前面和后面的部分分别找出来，即左子树和右子树；
4. 在后序排列中找到左子树和右子树对应的字符串；
5. 返回第一步，继续分别找出左子树、右子树的根，直到树为空树；

## 如何实现这些步骤

本题使用深度优先搜索（DFS）算法。

在 `dfs` 函数中，传入两个 `std::string` 类型的参数，分别为中序和后序排列。~不用管为啥我代码里用的 `pre`，你们就当它是后序排列。~

对于递归出口，如何实现第 5 步中的 _直到树为空树_ 呢？树为空树意味着后序排列和中序排列均为空字符串，仅需判断字符串是否为空即可。

如何找到根呢？由于根是**后序排列中最后一个**，仅需调用 `pre[pre.size() - 1]` 即可。这时候有人就要问了，_怎么在中序排列中找到根的下标啊？_ 其实字符串中有一个函数为 `string.find(char)`，可以返回下标。

接下来是截取左子树和右子树，可以使用 `substr` 函数。

然后是在后序排列中找到左子树和右子树。此处有一个技巧，即后序排列中的左子树和中序排列中的大小相同，所以依然只需要两个简单的 `substr`。

接着进行下一步的递归，直接将我们之前截取的左/右子树的中/后序排列喂给 `dfs` 函数即可。

# AC CODE

```cpp
#include <bits/stdc++.h>
using namespace std;


void dfs(string pre, string mid)
{
    if (pre.empty()) return; // Step 0
    int root = mid.find(pre[pre.size() - 1]); // Step 1 & 2
    string lmid = mid.substr(0, root); // Step 3
    string rmid = mid.substr(root + 1);
    string lpre = pre.substr(0, root); // Step 4
    string rpre = pre.substr(root, (pre.size() - 2) - root + 1);
    cout << pre[pre.size() - 1];
    dfs(lpre, lmid); // Step 5
    dfs(rpre, rmid);
}

int main()
{
    string pre, mid;
    cin >> mid >> pre;
    dfs(pre, mid);
    return 0;
}
```

TO 管理员：晚上写题解真的很累，求过审qwq

---

## 作者：Frank_G (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1030)

# 题意

给出一棵二叉树的中序与后序排列，求出它的先序排列。

# 思路

## 做题须知

做这道题首先要知道什么是前序排列，中序排列和后序排列。

简单来说：

前序排列就是根，左，右的顺序，

中序排列就是左，根，右的顺序，

后序排列就是左，右，根的顺序。

### 举个栗子

对于下面这个二叉树：
![](https://cdn.luogu.com.cn/upload/image_hosting/pzhrxpnq.png)

前序排列为：1，2，4，3，5，6；

中序排列为：4，2，1，5，3，6；

后序排列为：4，2，5，6，3，1。

## 思路

由于题目给出的是一棵二叉树的中序与后序排列，让我们输出其先序排列。

而由前序，中序，后序的定义，

只要由后序的最后一个（即这棵二叉树或其子树的根），放在中序遍历中，分出左右子树，并输出这个根，

然后递归这一过程，直至遍历完这棵树，即得到了这棵二叉树的前序排列。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
void dg(int l,int r,int s)
{
    cout<<s2[r-s];
    for(int i=l;i<=r;i++)
     if(s1[i]==s2[r-s])
     {
         if(i!=l) dg(l,i-1,s);
         if(i!=r) dg(i+1,r,s+1);
     }
    return ;
}
int main()
{
    cin>>s1>>s2;
    int l=s1.length();
    dg(0,l-1,0);
    return 0;
}
```
[AC](https://www.luogu.com.cn/record/200738549) 记录。

---

## 作者：niuniudundun (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1030)

# 题目大意

给出一棵二叉树的中序与后序排列。求出它的先序排列。

# 解法

一些常识：

- 后序遍历中最后一个遍历根，那么最后一个就是根。

- 中序遍历可以通过找根获得左右子树。

设中序遍历为 $mid$，后序遍历为 $pos$。

使用递归，先找到后序遍历最后一个字符 $pos_{l-1}$（$l$ 是 $pos$ 长度），这个就是根，输出他，在 $mid$ 中找到这个根，设位置为 $p$，随后将 $mid$ 拆成两半（根不要）$[0,p),[p+1,l)$（这里 $l$ 是 $mid$ 长度），$pos$ 拆为 $[0,p),[p,l-p-1)$，随后遍历这两个子串，到 $mid$ 长度小于 $0$。

因为所有节点只遍历一次，复杂度 $O(n+\alpha)$，$n$ 是节点数，$\alpha$ 是字符串函数 $\texttt{find},\texttt{substr}$ 常数。

代码：

```cpp
#include<iostream>
using namespace std;
string mid,pos;//中序，后序
void pre(string mid,string pos){
	if(mid.length()>0){
		int l=pos.length();
		char a=pos[l-1];
		cout<<a;
		int p=mid.find(a);
		pre(mid.substr(0,p),pos.substr(0,p));
		pre(mid.substr(p+1),pos.substr(p,mid.length()-p-1));
	}
} 
int main(){
	cin>>mid>>pos;
	pre(mid,pos);
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：2)

## 前言

题解审核明天休假，所以赶紧把题解写了……

## 思路

题目大致意思，即已知二叉树的中序后序序列求其先序序列。\
下面，我们需要先了解一下二叉树遍历序列的特征：

- 后序序列：树的根节点在序列的最后一位。
- 中序序列：树的根节点的左侧是其左子树，右侧是其右子树。

拿样例数据举个例子：

- 主树：由后序序列 `BDCA` 可知，根节点为 `A`。又据中序序列 `BADC` 可知，左子树由 `B` 节点构成，右子树由 `DC` 两节点构成。
- 左子树 `B`：根节点为 `B`，为终端节点（叶节点）。
- 右子树 `DC`：与之对应的后序序列也为 `DC`，因此同理可知，根节点为 `C`，左子树为 `D`。

打住！这样的过程，怎么有点奇怪…… 这不就是递归深入吗？\
没错，这道题的主要解法，就是递归！在经过简单的推论，我们可以得到主要思路如下：

1. 根据后序序列寻找到当前二叉树的根并输出。
2. 找到当前树的左、右子树所对应的中序、后序序列所在位置，然后递归深入。
3. 经过层层深入，层层返回，即可得到最终的答案。

## AC Code

虽然代码简单，但思路可能有些复杂，希望大家自己理解！

```cpp
#include <bits/stdc++.h>
using namespace std;
void dlr(string z, string h){
	if(z.empty() || h.empty()) return; //递归终止条件
	char now_root = *(h.end() - 1); //当前树的根节点
	cout << now_root;
	int zroot_index = z.find(now_root); //根节点在中序序列中的索引，同时可以当作一段长度
    dlr(z.substr(0, zroot_index), h.substr(0, zroot_index)); //递归深入左子树
    dlr(z.substr(zroot_index + 1), h.substr(zroot_index, h.size() - zroot_index - 1)); //递归深入右子树
}
int main(){
	string z, h;
	cin >> z >> h;
	dlr(z, h);
    return 0;
}

```

---

## 作者：xiaobeng_0912 (赞：2)

## $\mathbf{Knowledge}$

1. 递归
1. 二叉树

## $\mathbf{Solution}$

拿到这道题，我们发现题面十分精简，所以我们就来分析样例，看看能不能从中找到解法。

样例中二叉树的中序排列为 `BADC`，后序排列为 `BDCA`。我们知道，后序排列的顺序为 $左\rightarrow右\rightarrow根$，所以后序遍历到的最后一个节点就是这棵树的根节点。在样例中，我们得出这棵树的根节点为 `A`。

接下来，我们来看中序排列。中序排列的顺序为 $左\rightarrow根\rightarrow右$。那么我们可以得出，在遍历到根节点之前遍历的节点都属于这棵树的左子树，在遍历到根节点之后遍历的节点都属于这棵树的右子树。于是，我们就把中序排列分成两部分，一是左子树部分的 `B`，二是右子树部分的 `DC`。

我们再回来看后续排列。我们找到其中左子树和右子树的分界点，然后也把后续排列分成两部分：左子树部分的 `B` 和右子树部分的 `DC`。根据第一步我们的推论，我们可以得出左子树的根节点是 `B`，而右子树部分的根节点是 `C`。接下来，重复第二步，得出树的形状为下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vs60vrg1.png)

然后，我们还可以发现，每次将一棵树分成两部分的操作可以用递归来实现，于是，我们得出代码：

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;//中序排列与后序排列 
void ord(int l1,int r1,int l2,int r2){
	/*参数依次为：这棵二叉树的中序排列在总树的中序排列中的起始下标和终止下标，这棵二叉树的后序排列在总树的后序排列中的起始下标和终止下标*/
	if(r1-l1>=0){//如果这棵子树还有至少一个节点 
		printf("%c",s2[r2]);//输出根节点 
		int root=s1.find(s2[r2]);//在中序排列中根的位置 
    	ord(l1,root-1,l2,r2-(r1-root)-1);
		/*左子树的后序排列的右端下标为这个二叉树的右端下标减去右子树的节点个数再减去一*/
    	ord(root+1,r1,l2+(root-l1),r2-1);
    	/*右子树的后序排列的左端下标为这个二叉树的左端下标减去左子树的节点个数*/
	}
}
int main(){
    cin>>s1>>s2;
    ord(0,s1.size()-1,0,s2.size()-1);//递归 
    return 0;
}
```

---

## 作者：ZZA000HAH (赞：1)

一个二叉树，给定中序和后序，那么这个二叉树就是确定的。

对于二叉树的遍历，采取的方法一般有**递归做法**和**非递归做法**两种。本题适用**递归做法**。

### 递归做法

这种做法重要的基础是：

**1、给定一个后序遍历，那么最后一个结点就是根。**
 
**2、在中序和后序遍历中，结点左侧为左树结点，右侧为右树结点。** 

那么定义一个函数，参数为两个字符串，一个为中序串、另一个为后序串。在函数里先输出后序串的最后一个字符（本次结点），接着在中序串中找到本次结点的位置 $site$，然后进行递归：

1、调用函数，传参，中序串从 $0$ 到 $site-1$ 传入，后序串也从 $0$ 到 $site-1$ 传入。

2、再次调用函数，传参，中序串从 $site+1$ 传入至最后，后序串从 $site$ 到 $site-1$ 传入。

最后注意边界条件：中序串长度为 $0$ 则跳出递归。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
void make(string s1,string s2)
{
	int len1=s1.size(),len2=s2.size();//求长度
	if (len1==0) return;//边界：跳出递归
	char root=s2[len2-1];//本次结点
	cout<<root;//输出
	int site=s1.find(root);//在中序串中找到本次结点的位置
	make(s1.substr(0,site),s2.substr(0,site));//递归1
	make(s1.substr(site+1),s2.substr(site,len2-site-1));//递归2
}
int main()
{
	string s1,s2;
	cin>>s1>>s2;
	make(s1,s2);
	return 0;
}
```
## End

---

## 作者：FamousKillerconan (赞：1)

这题坑了我好久 QWQ。


## 思路
先序遍历，又叫先根遍历。顾名思义，就是要不断地找根。


先明确一点，后序遍历中最后一个都是这一棵树的根节点。


然后中序遍历，根节点在中间~~这点常识我应该不用说了吧~~。


所以，我们只需要靠后序遍历找到根节点，然后利用中序遍历分成两个左右子树，继续递归遍历。
## 坑点？
注意，中序遍历时要去掉根节点（找到根节点后再利用查找子串的函数来分裂），后序遍历也要去掉根节点（在最后不用我说了吧）。


AC 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define PII pair<int,int>
using namespace std;
const int N=1e6+5;
const int INF=0x3f3f3f3f;
const double EPS=10e-6;
string s,t;
void Pre(string s,string t){
	int n=s.size(),m=t.size();
	if(n>0){
		cout<<t[m-1];//最后一个即是根节点
		int k=s.find(t[m-1]);
		Pre(s.substr(0,k),t.substr(0,k));
		Pre(s.substr(k+1),t.substr(k,m-k-1));//分裂成左右两个子树
	}
}
void solve(){
	cin>>s>>t;
	Pre(s,t);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--)solve();//为了应付多组测试
	return 0;
}
```

---

## 作者：LotleTos (赞：1)

## 思路
- 用递归做。
- 由于后序排列是左右根，所以可以在后序排列找根节点，输出。
- 确定根节点后，在中序排列中找到根节点的位置，确定根节点左边的左子树，根节点右边的右子树，分别递归。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
void f(string a,string b){
	if(a.size()==0){
		return;
	}
	cout<<b[b.size()-1];
	for(int i=0;i<a.size();i++){
		if(a[i]==b[b.size()-1]){
			f(a.substr(0,i),b.substr(0,i));
        	f(a.substr(i+1),b.substr(i,a.size()-i-1));
		}
	}
}
int main(){
	string a,b;
	cin>>a>>b;
	f(a,b);
}
```

---

## 作者：Mzh2012 (赞：1)

## 题目意思

给出一颗二叉树的中序，后序排列，请你求出前序。

## 题目思路

后序排序的最后一项绝对是这一棵树的根，只需再根据中序排序确定中间分界点，最后分成两半继续递归下去，知道只剩一个节点。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

string zhong,hou;

int find(char x){
	for(int i = 0;i<zhong.length();i++){
		if(zhong[i]==x){
			return i;
		}
	}
}

void xian(int l1,int r1,int l2,int r2){
	int mid = find(hou[r2]);
	cout<<hou[r2];
	if(mid>l1) xian(l1,mid-1,l2,r2-r1+mid-1);
	if(mid<r1) xian(mid+1,r1,l2+mid-l1,r2-1);
}

int main(){
	
	cin>>zhong>>hou;
	xian(0,zhong.length()-1,0,hou.length()-1);
	
	
	return 0;
} 
```

---

## 作者：yr409892525 (赞：1)

### 用中序遍历加一种其他遍历方式确定一颗二叉树

> 首先我们要知道两个规律
>
> 中序遍历，如果根为 1，那么在 1 右边的就是它的右子树，左边是左子树。
>
> 先序遍历的第一个是根，后序遍历最后一个是根。

### 步骤

1. 拿出先序遍历的第一个，找到它在中序遍历的位置，就能确定它的左右子树。
2. 输出根，先遍历左子树，再遍历右子树。
3. 如果字符串为空，停止。

对了，如果中序遍历字符串的长度为 $n$，就也从先序遍历从头开始，拿一个长度为 $n$ 的字符串。

### 模拟

例如。

先序遍历为：$1$ $2$ $3$ $6$ $4$ $5$ $7$ $8$ $9$ $10$。\
中序遍历为：$3$ $2$ $4$ $6$ $5$ $1$ $9$ $8$ $7$ $10$。

首先确认根 1。![](https://cdn.luogu.com.cn/upload/image_hosting/2ykv5pe4.png)\
先遍历 1 的左子树\
先序遍历为：$2$ $3$ $6$ $4$ $5$。\
中序遍历为：$3$ $2$ $4$ $6$ $5$。\
确认 1 的左子树 2。![](https://cdn.luogu.com.cn/upload/image_hosting/tpie7xf6.png)\
先遍历 2 的左子树\
确认 2 的左子树 3。![](https://cdn.luogu.com.cn/upload/image_hosting/rm3fywa0.png)\
再遍历 2 的右子树\
先序遍历为：$6$ $4$ $5$。\
中序遍历为：$4$ $6$ $5$。\
确认 2 的右子树 6。\
确认 6 的左子树 4。\
确认 6 的右子树 5。\
![](https://cdn.luogu.com.cn/upload/image_hosting/ixe5dvr7.png)\
再遍历 1 的右子树\
先序遍历为：$7$ $8$ $9$ $10$。\
中序遍历为：$9$ $8$ $7$ $10$。\
找到根 7，遍历左子树。\
![](https://cdn.luogu.com.cn/upload/image_hosting/ucykpb5v.png)\
遍历 7 的左子树\
先序遍历为：$8$ $9$。\
中序遍历为：$9$ $8$。\
找到根 8，左子树为 9。![](https://cdn.luogu.com.cn/upload/image_hosting/hmc4nyju.png)\
最后找到 7 的右子树 9。\
![](https://cdn.luogu.com.cn/upload/image_hosting/ki49wryc.png)

### [P1030 \[NOIP2001 普及组\] 求先序排列](https://www.luogu.com.cn/problem/P1030)

后序遍历和先序遍历是一样的，只是最后一个为根。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string s1,s2;
string str(int l,int r,string s){ //截取字符串
	string ss=" ";
	for(int i=l;i<=r;i++) ss+=(s[i]);
	return ss;
}
void dfs(string s1,string s2){ //s1是中序遍历，s2是后序遍历
	if(s1==" ") return ; //为空停止
	int l=s1.size()-1;
	int pos;
	for(int i=1;i<=l;i++){ //查找根在中序遍历的位置
		if(s1[i]==s2[l]){
			pos=i;
			break;
		}
	}
	cout<<s2[l]; //输出根
	dfs(str(1,pos-1,s1),str(1,pos-1,s2)); //遍历左子树
	dfs(str(pos+1,l,s1),str(pos,l-1,s2)); //遍历右子树
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>s1>>s2;
	s1=" "+s1;  
	s2=" "+s2; 
	dfs(s1,s2);
	return 0;
}
```

---


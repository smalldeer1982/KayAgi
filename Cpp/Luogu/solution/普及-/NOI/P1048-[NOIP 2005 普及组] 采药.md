# [NOIP 2005 普及组] 采药

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？


## 说明/提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题

## 样例 #1

### 输入

```
70 3
71 100
69 1
1 2
```

### 输出

```
3```

# 题解

## 作者：decoqwq (赞：2416)

`upd on 2020/2/5`:修了当年不会写的 `latex` 以及更正了部分错误

首先，这题是一道水的不能在水的题了

其次，我还是想说这题真的太水了，就是一模一样的01背包问题，输入输出都没改

就是改了一个题目背景

转化时间为背包容量和草药占的量

先讲一下二维 $dp$：

让我假设现在的背包的容量是 $C=10$；

物品编号：$ 1\ \ \ 2\ \ \ 3$

物品重量：$ 5\ \ \ 6\ \ \ 4$

物品价值：$20\ 10\ 12$

用v[i]表示物品价值，w[i]表示物品重量，要使得放入背包的物品价值最大化，我们知道用贪心是不行的！

所以接下来开始动规：

首先定义状态 $dp[i][j]$ 以 $j$ 为容量为放入前i个物品(按 $i$ 从小到大的顺序)的最大价值，那么 $i=1$ 的时候，放入的是物品 $1$ ，这时候肯定是最优的啦！

那考虑一下 $j$，$j$ 是当前容量，如果 $j<5$，那么是不是就不能放，$dp[1][j](j<5)=0$；那如果 $j>5$，就可以放了，$dp[1][j](j>=5)=20$；

接着 $i=2$ 放两个物品，求的就是 $dp[2][j]$ 了，当 $j<5$ 的时候，是不是同样的 $dp[2][j](j<5)$ 等于$0$；那当 $j<6$ 是不是还是放不下第二个，只能放第一个；

那 $j>6$ 呢？是不是就可以放第二个了呢？是可以，但是明显不是最优的，用脑子想了一下，发现 $dp[2][j](j>6)=20$，这个 $20$ 怎么来的呢，当然是从前一个状态来的（注意这里就可以分为两种情况了）：一种是选择第二个物品放入，另一种还是选择前面的物品；

让我们假设一下 $j=10$ 吧，可能会比较好理解！这时候： $dp[2][10] = max((dp[1][10-w[2]])+v[2],dp[1][10])$

$dp[2][10] = max(dp[1][4])+10,dp[1][10])$

是不是很明显了呢，$dp[1][4]+10$ 是选择了第二个，于是容量相应就减少成 $4$，之前已经得出 $dp[1][4]=0$，就是说选了物品 $2$，物品 $1$ 就选不了了；$dp[1][10]$ 是不选择第二个，只选择第一个 $dp[1][10]$ 是等于 $20$ 的，于是得出 $dp[2][10]=20$

到这里就可以了，依次类推，动态转移方程为：$dp[i][j] = max(dp[i-1][j-w[i]])+v[i],dp[i-1][j])$

但是好像还有一些问题没考虑完.........

看回例子：

物品编号：$ 1\ \ \ 2\ \ \ 3$

物品重量：$ 5\ \ \ 6\ \ \ 4$

物品价值：$20\ 10\ 12$

我们知道 $dp[1][j](j<5)=20$，$dp[2][j](j=5)$ 的时候是多少呢？我们看到动态转移方程并没有考虑 $j<w[i]$ 的情况，但是我们可以加进去，由于 $dp[2][5]$ 我们看出来是等于 $5$ 的，为什么？因为不能选第二个，只能选第一个，所以..... $dp[2][5]$ 是不是刚好等于 $dp[1][5]$ 了呢！所以当 $j<w[i]$ 的时候，$dp[i][j] = dp[i-1][j]$ 就好了，是不是很神奇呢！

二维 $dp$ 代码：

```cpp
#include "iostream"
#include "stdio.h"
using namespace std;
int w[105],val[105];
int dp[105][1005];
int main()
{
    int t,m,res=-1;
    scanf("%d%d",&t,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&w[i],&val[i]);
    }
    for(int i=1;i<=m;i++) 
        for(int j=t;j>=0;j--)  
        {
            if(j>=w[i])
            {
                dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);
            }  
            else
            {
                dp[i][j]=dp[i-1][j];
            }              
        }
    printf("%d",dp[m][t]);
    return 0;
}
```
我们再用一维dp看看，我们减掉选到哪一个物品这一维

有人就要说了，会重复放入

让我假设现在的背包的容量是 $C=10$；

物品编号：$ 1\ \ \ 2\ \ \ 3$

物品重量：$ 5\ \ \ 6\ \ \ 4$

物品价值：$20\ 10\ 12$

---------------------------------------

直接分析dp数组：

`dp：0 0 0 0 0 0 0 0 0 0`

```cpp
i=1:
dp[10] = max(dp[5]+20, dp[10]);
dp[9] = max(dp[4]+20, dp[9]);
dp[8] = max(dp[3]+20, dp[8]);
dp[7] = max(dp[2]+20, dp[7]);
dp[6] = max(dp[1]+20, dp[6]);
dp[5] = max(dp[0]+20, dp[5]);
```
`dp: 0 0 0 0 20 20 20 20 20 20`
---------------------------------------------

```cpp
i=2:
dp[10] = max(dp[6]+4, dp[10]);
dp[9] = max(dp[3]+10, dp[9]);
dp[8] = max(dp[2]+10, dp[8]);
dp[7] = max(dp[1]+10, dp[7]);
dp[6] = max(dp[0]+10, dp[6]);
```
`dp: 0 0 0 0 20 20 20 20 20 20 //看到了没，选10的都被之前的20压下去了`
-------------------------------------------
```cpp
i=3:
dp[10] = max(dp[6]+12, dp[10]);
dp[9] = max(dp[5]+12, dp[9]);
dp[8] = max(dp[4]+12, dp[8]);
dp[7] = max(dp[3]+12, dp[7]);
dp[6] = max(dp[2]+12, dp[6]);
dp[5] = max(dp[1]+12, dp[5]);
dp[4] = max(dp[0]+12, dp[4]);
```
`dp: 0 0 0 12 20 20 20 20 32 32`
-----------------------------------------

$dp[10]$ 就是背包容量为 $10$ 的时候的最大价值，就是要求的值了，可以看到，容量大的时候的值取决于容量小的时候的值，从而不断被正确更新，所以用一维 $dp$ 的时候，$j$ 的循环必须是从大到小逆序开始的，逆序，就防止了一个物品放入多次！！！否则...........

直接分析 $dp$ 数组：

`dp：0 0 0 0 0 0 0 0 0 0`

```cpp
i=1:
dp[5] = max(dp[0]+20, dp[5]);
dp[6] = max(dp[1]+20, dp[6]);
dp[7] = max(dp[2]+20, dp[7]);
dp[8] = max(dp[3]+20, dp[8]);
dp[9] = max(dp[4]+20, dp[9]);
dp[10] = max(dp[5]+20, dp[10]);
dp: 0 0 0 0 20 20 20 20 20 40 //看到问题了吗！dp[10]不仅仅是由dp[5]决定了，因为dp[5]还被dp[0]更新了一次，相当于，i=1时，即只有一个物品时，这个物品拿了两次，完全不符合01背包了，但是，这个却是我们后面要提到的完全背包！接着看：
```
---------------------------------------------
```cpp
i=2:
dp[6] = max(dp[0]+10, dp[6]);
dp[7] = max(dp[1]+10, dp[7]);
dp[8] = max(dp[2]+10, dp[8]);
dp[9] = max(dp[3]+10, dp[9]);
dp[10] = max(dp[4]+10, dp[10]);
```
`dp: 0 0 0 0 20 20 20 20 20 40`
-------------------------------------------

```cpp
i=3:
dp[4] = max(dp[0]+12, dp[4]);
dp[5] = max(dp[1]+12, dp[5]);
dp[6] = max(dp[2]+12, dp[6]);
dp[7] = max(dp[3]+12, dp[7]);
dp[8] = max(dp[4]+12, dp[8]);
dp[9] = max(dp[5]+12, dp[9]);
dp[10] = max(dp[6]+12, dp[10]);
```
`dp: 0 0 0 12 20 20 20 24 32 40`

分析完毕，之后自己想吧

重点就是，一维内层循环要倒着来！不然会重复

一维 $dp$ 代码：

```cpp
#include "stdio.h"
#include "iostream"
using namespace std;
int w[105], val[105];
int dp[1005];
int main()
{
    int t,m,res=-1;    
    scanf("%d%d",&t,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&w[i],&val[i]);
    }
    for(int i=1;i<=m;i++) 
    {
        for(int j=t;j>=0;j--) 
        {
            if(j>=w[i])
            {
                dp[j]=max(dp[j-w[i]]+val[i], dp[j]);
            }
        }
    }    
    printf("%d",dp[t]);
    return 0;
}
```

---

## 作者：2023z (赞：23)

这个题目就是一个~~很水很水很水的~~ 01 背包问题。

### 题意

简单来说就是让辰辰~~成为最伟大的医师~~在总时间内收集的药品总价值最大。

### 思路

首先，我们知道背包问题用贪心是不行的。我们举一个反例：背包的容量是 $ 9 $，有 $ 3 $ 个物品，大小分别是 $ 7 $，$ 4 $，$ 4 $，价值是 $ 10 $，$ 6 $，$ 6 $。显然，正确答案为 $ 12 $。而贪心按价值优先为 $ 10 $，按性价比来同样也是 $ 10 $，所以贪心法不成立。于是就开始 dp：那无非就是选和不选两种情况。我们用 $ f[i][j] $ 表示放入前 $ i $ 个物品用了 $ j $ 容量。

#### 动态转移方程式：

$ f[i][j]=\max(f[i-1][j-a[i].t]+a[i].v , f[i-1][j]) $ ( $ a[i].t $ 代表时间 $ a[i].v $ 代表价值 )。

**code**：
```cpp
#include<bits/stdc++.h> //万能头万岁QwQ
using namespace std;
struct med{
	int t,v;
}a[110]; //t代表时间，v代表价值
int f[110][1010];
int t,m;
int main(){
	cin>>t>>m;
	for(int i=1;i<=m;i++) cin>>a[i].t>>a[i].v;	//输入
	for(int i=1;i<=m;i++){
		for(int j=0;j<=t;j++){ //注意范围j要<=t
			if(j>=a[i].t) f[i][j]=max(f[i-1][j-a[i].t]+a[i].v,f[i-1][j]); //if(j>=a[i])判断它是否可选，方程式如上
			else f[i][j]=f[i-1][j];
		}
	}
	cout<<f[m][t]; //输出
	return 0;
} //本蒟蒻的第一篇题解，求过QWQ
```

---

## 作者：0Io_oI0 (赞：13)

题解区里的 dp 都是一模一样的，那我就来点不一样的吧。

大家都是从正面考虑前 $n$ 个物品，时间为 $m$，所能得到的最大收益，但是这道题目还有另一种思路就是反过来：前 $n$ 个物品，价值和为 $m$，需要的最小时间和。

我们还是从 dp 的要素入手：

1.  $f$ 数组的含义就是 $f_{n,m}$ 表示前 $n$ 个物品，价值和为 $m$，需要的最小时间和。
2.  当 $n=m=0$ 的时候，我们什么都不取也就是最小重量是 $0$ 其余的情况都初始化为极大值。
3. 状态转移：我们什么都不干的话那么就是 $f_{i,j}=f_{i-1,j}$，如果我们要当前这个物品的话那么 $f_{i,j}=\min\left\{f_{i,j},f_{i-1,j-v_i}+w_i\right\}$。
4. 最后我们的答案是从最大的价值开始遍历如果遍历到价值 $i$ 时发现 $f_{n,i}≤C$ 那么这个价值 $i$ 就是我们要求的答案。

讲得这么详细了，直接上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int f[103][10003],w[103],v[103];
signed main(){
	//f[n][m]: 前 n 个物品，价值和为 m，需要的最小重量和
	memset(f,0x3f,sizeof(f));
	f[0][0]=0;
	int C=read(),n=read();
	for(int i=1;i<=n;i++)w[i]=read(),v[i]=read();
	for(int i=1;i<=n;i++){
		//考虑第 i 个物品
		for(int j=100*i;j>=0;j--){
			f[i][j]=f[i-1][j];
			if(j>=v[i])f[i][j]=min(f[i][j],f[i-1][j-v[i]]+w[i]);
		}
	}
	for(int i=100*n;i>=0;i--)if(f[n][i]<=C)printf("%d\n",i),exit(0);
	return 0;
}
```
亲测可过，请勿抄袭！

---

## 作者：rainygame (赞：11)

> **本题正解为 01 背包，本题解并非传统意义上的正解。如果想学习正解，请参考其它题解。**

第一次看到这道题时可能会有一种想法：按性价比排序后贪心选取。

但是这样是错误的，反例：

```
60 3
2 30
29 30
30 31
```

（贪心的答案为 $30+30=60$，但正确答案为 $30+31-61$）

不正确不代表这个思路没有用，我们考虑对其进行改进。容易发现，虽然性价比的大小不能确定这个物品选还是不选，但是显然性价比更大的物品更容易被选到。所以我们还是对物品先按照性价比排一下序。

所以我们考虑给一个物品赋上一个权值 $k$，表示这个物品有 $k\%$ 的概率被选取。显然，权值应当单调不升。

我们可以考虑这样赋权值：先设定一个数 $k_1$ 表示第一个数的权值，然后每往后走一点就有一定概率降低 $1$ 权值。先设这个概率为 $g\%$。

可以一边赋权值一边计算答案，对于重量大于当前所剩容量的物品可以直接跳过。

当然，因为这种算法实在是太随机了，一次可能找不到最优解，所以需要多次查找最优解，我们可以一直枚举到 $0.99$ s 再输出最优解，这样一定是最优的（因为已经快超时了）。

多次提交发现，当 $k_1=97$，$g=20$ 的时候最快，枚举到 $0.004$ s 就可以稳定地 AC 了。

当然，这只是数据比较随机的情况，对于出题人故意卡贪心的数据，可能需要通过调整 $k_1$ 和 $g$ 甚至 $k$ 的赋值方式以通过毒瘤的数据，所以通用性不高。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 101 
mt19937 rnd(time(0));

int n, W, ans;

struct Node{
	int v, w;
}a[MAXN];

bool cmp(Node a, Node b){
	return double(a.v)*double(b.w) > double(b.v)*double(a.w);
}

bool get(int x){
	return rnd() % 100 < x;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> W >> n;
	for (int i(1); i<=n; ++i){
		cin >> a[i].w >> a[i].v;
		if (a[i].w > W){
			--i;
			--n;
		}
	}
	sort(a+1, a+n+1, cmp);
	
	while (double(clock()) / CLOCKS_PER_SEC < 0.004){
		int tmp(W), res(0), g(97);
		for (int i(1); i<=n; ++i){
			if (a[i].w > tmp) continue;
			if (get(g)){
				tmp -= a[i].w;
				res += a[i].v;
			}
			g -= get(20);
		}
		ans = max(ans, res);
	}
	cout << ans;
	
	return 0;
}
```


---

## 作者：xyx404 (赞：9)

## 思路：

[参考了 OI Wiki](https://oi-wiki.org/dp/knapsack/)。

背包 DP 模版题。

首先定义一个 $dp$ 数组，其中 $dp_{i,j}$ 表示第 $i$ 个物品在背包容量为 $j$ 时的最大价值。

考虑转移。

枚举每一个物品在背包容量剩余 $j$ 时可以得到的最大价值。


如果现在枚举的剩余容量 $j$ 小于选择这个物品需要的容量，那么 $dp_{i,j}$ 的最大值就是 $dp_{i-1,j}$。  

否则有两种情况，选和不选。  
对于选的情况，背包的剩余容量会减小这个物品需要的容量，价值会增加这个物品的价值，故此情况下的价值为 $dp_{i-1,j-uset_i}+price_i$；对于不选的情况，这个物品不会放进背包，所以和剩余容量不够的情况是一样的是 $dp_{i-1,j}$。

在此处再解释下 $dp_{i-1,j-uset_i}+price_i$，这个时候需要选择第 $i$ 件物品，因为第 $i$ 件物品需要的空间是 $uset_i$ 枚举的背包容量等于 $j$，所以只剩下 $j-uset_i$ 空间就是留给前 $i-1$ 件物品，然后 $dp_{i-1,j-uset_i}$ 是第 $i-1$ 件物品，背包容量剩余 $j-uset_i$ 时的最大值，而现在我们又选择了第 $i$ 件物品，所以现在的价值是 $dp_{i-1,j-uset_i}+price_i$。

所以可以得出转移方程：

对于剩余容量大于等于选择这个物品需要的容量时

$$dp_{i,j}=\max(dp_{i-1,j-uset_i}+price_i,dp_{i-1,j})$$

否则

$$dp_{i,j}=dp_{i-1,j}$$

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long
int m,n,t;
int dp[1050][1050];
int uset[105],price[105];
int main(){
	cin>>t>>m;
	for(int i=1;i<=m;i++)
		cin>>uset[i]>>price[i];
	for(int i=1;i<=m;i++)
		for(int j=0;j<=t;j++){
			if(j>=uset[i])
				dp[i][j]=max(dp[i-1][j],dp[i-1][j-uset[i]]+price[i]);
			else
				dp[i][j]=dp[i-1][j];
		}
	cout<<dp[m][t];
	return 0;
}

```

---

## 作者：4041nofoundGeoge (赞：8)

## 思路

考虑动态规划还是贪心？如果使用贪心，我们可以通过“性价比”进行选择，即 $价值÷时间$，这个方法看似可行，但我们可以 hack 掉这种思路：
```
14 3
6 10
7 15
9 20
```

根据性价比，我们可以算出第三组性价比最高，因此选择第三个，选完以后没有空间，因此总价为 $20$，实际上，我们可以选择第一个和第二个，价值比第三个大，因此贪心不保证得到最优解。

我们考虑动态规划，设 $f_{i,j}$ 为以 $j$ 容量为放入前 $i$ 个物品的最大价值，我们可以列出以下式子：（我们称之为动态转移方程）
$$
\begin{cases}
f_{i,j}=f_{i-1,j}&\text{if }j<t_i\\
f_{i,j}=\max\{f_{i-1,j-t_i}+v_i,f_{i-1,j}\}&\text{else}
\end{cases}
$$

其中 $t_i$ 代表每一个的时间，$v_i$ 代表每一个的价值。关于这个的最优性，我们可以这么理解。

把一个大的问题，化解成几个小问题，得到小问题的解后就得到了大问题的解。上述动态转移方程我们就是把 $f_{i,j}$ 这个大问题化成 $f_{i-1,j-t_i}$（剩的物品减一，时间也减一）的最优解加上价值 $v_i$，相当于递推求最优解。

然后我们就可以写出我们的代码：（时间复杂度 $O(TM)$）

```cpp
#include <bits/stdc++.h>
using namespace std;
int t[105],v[105];
int dp[105][1005];
int main()
{
	int T,M;
	cin>>T>>M;
	for(int i=1;i<=M;i++)
	{
		cin>>t[i]>>v[i];
	}
	for(int i=1;i<=M;i++)
	{
		for(int j=1;j<=T;j++)
		{
			if(j<t[i])dp[i][j]=dp[i-1][j];
			else
			{
				dp[i][j]=max(dp[i-1][j],dp[i-1][j-t[i]]+v[i]);
			}
		}
	}
	cout<<dp[M][T];
	return 0;
}
```

虽然说对于这道题完全够用，但有一些~~毒瘤~~题目 $M$ 和 $T$ 达到了 $10^4$，二维数组就很占空间，于是我们需要优化。

我们发现 $f_{i,j}$ 只跟 $f_{i-1,j}$ 相关联，于是我们就可以利用**滚动数组**优化代码。具体地我们省略一个维度，方程变为 $f_{j}=\max\{f_{j-t_i}+v_i,f_{j}\}$。于是我们就在空间上节省了资源，时间上也节省了一定资源。

最后把这个核心代码替换到原来的代码中。我们得到了最优解。
```cpp
for (int i = 1; i <= M; i++)
  for (int l = T; l >= t[i]; l--)
    f[l] = max(f[l], f[l - t[i]] + v[i]);
```

---

## 作者：Ngo123 (赞：6)

#### 背包问题
本题在读完题目后，会发现这是一道经典的 $01$ 背包问题。

我们回顾下如何求解 $01$ 背包问题：

首先假设每件物品的体积为 $v_{i}$，价值为 $w_{i}$。

定义状态为 $f_{i,j}$ 表示前 $i$ 个物品，容量为 $j$ 的情况下的最优解。

初始化为 $f_{0,0}$为 $0$ 。

接下来是状态转移:

当前的物品可以选也可以不选。

若不选第 $i$ 件物品，则状态为 $f_{i-1,j}$。

若选第 $i$ 件物品，则状态为 $f_{i-1,j-v_{i}}+w_{i}$。

我们要求最优解，因此在以上两种情况求最大值即可。

再回看这道题：采摘某株草药的时间其实就是物品的体积，草药的价值其实就是物品的价值。

因此我们使用动态规划 $01$ 背包算法即可得到正确答案。

以下是代码：
```
#include<iostream>
using namespace std;
const int N = 1e3+5;
int T,m,f[N],v[N],w[N];
int main()
{
    cin>>T>>m;
    for(int i = 1;i<=m;i++)
        cin>>v[i]>>w[i];
    for(int i = 1;i<=m;i++)
        for(int j = T;j>=v[i];j--)
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    cout << f[T] << endl;
    return 0;
}
```

---

## 作者：GZXUEXUE (赞：4)

### 思路

经典 01背包 问题。观察到题目中含有「时间」与「价值」字样，考虑使用 背包 求解。

定义 $w_i$ 表示采药时间，$c_i$ 表示药的价值和数组 $f_{i,v}$，表示采前 $i$ 株草药花费 $v$ 个单位时间获得的最大价值。显见，对于前 $i$ 株草药，可以选择采与不采第 $i$ 株草药，采后会花费 $w_i$ 的时间。根据上文，我们可以列出转移方程：

$$
f_{i,v} \gets \max(f_{i-1,v},f_{i-1,v-w_i} + c_i)
$$

其中，$f_{i-1,v}$ 表示不采这株草药的价值，$f_{i-1,v-w_i} + c_i$ 表示采这株草药的价值，我们要取二者最大值。

显见最后输出结果为 $f_{M,T}$。

时间复杂度为 $O(TM)$。

### 实现

```cpp
# include <iostream>
using namespace std;
int w[1145],c[1145],f[1145][1145];
int main(){
	int n,m; cin >> m >> n;
	for (int i = 1;i <= n;i++) cin >> w[i] >> c[i];
	for (int i = 1;i <= n;i++){
		for (int v = m;v > 0;v--){
			if (w[i] <= v) f[i][v] = max(f[i-1][v],f[i-1][v-w[i]]+c[i]);
			else f[i][v] = f[i-1][v];
		}
	}cout << f[n][m];
	return 0;
}
```

---

## 作者：mairuisheng (赞：4)

[P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

主要算法：动态规划

分析：设 $f_{i,j}$ 为第 $i$ 个物品在时间为 $j$ 时的最大价值，枚举每个物品。

当剩余时间小于这个取物品的时间时，说明没时间取了，所以最大价值只能继承原来的：

$f_{i,j}=f_{i-1,j}$。

否则，在取和不取中选最大值：

$f_{i,j}=\max(f_{i-1,j},f_{i-1,j-time_i}+c_i)$，其中 $time_i$ 表示第 $i$ 个取物品的时间，$val_i$ 表示第 $i$ 个物品的价值。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int t,m;
int time[101],val[101];
int ans[10001][10001];
int main()
{
	int i,j;
	scanf("%d %d",&t,&m);
	for(i=1;i<=m;++i)scanf("%d %d",&time[i],&val[i]);
	for(i=1;i<=m;++i)
	{
		for(j=1;j<=t;++j)
		{
			if(j>=time[i])ans[i][j]=max(ans[i-1][j],ans[i-1][j-time[i]]+val[i]);
			else ans[i][j]=ans[i-1][j];
		}
	}
	printf("%d",ans[m][t]);
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：4)

## Solution

01背包模板题，当年还是有难度的，但是现在我们来看，就简单了。

01背包，有一个包和 $n$ 个物品，背包的容量为 $m$，每个物品都有各自的体积和价值，问当从这 $n$ 个物品中选择多个物品放在包里而物品体积总数不超过包的容量 $m$ 时，能够得到的最大价值是多少？（之所以叫 01背包，是因为对于每一个物品，要么不选，就是 $0$，要么选，就是 $1$）

发现这题中就是 $M$ 个物品，背包的容量就是能够用来采药的时间，体积就是采当前草药需要的时间，价值就是当前草药的价值。

详细的就不讲了，可以去看[洛谷日报的背包问题](https://www.luogu.com.cn/article/7339h2ok)和[背包九讲](https://www.kancloud.cn/kancloud/pack/70124)，都讲的很详细。

以下转移方程中 $c_i$ 代表采摘当前草药的时间，$w_i$ 代表当前草药的价值。

普通版本，使用二维数组。转移方程是 $f_{i,v}=\max(f_{i-1,v},f_{i-1,v-c_i}+w_i)$。

优化空间版本，使用一维数组。转移方程是 $f_{v}=\max(f_{v},f_{v-c_i}+w_i)$。

时间复杂度都是 $\mathcal{O}(TM)$。

---

## 作者：FXLIR (赞：2)

### 思路

[0-1 背包](https://oi-wiki.org//dp/knapsack/#0-1-%E8%83%8C%E5%8C%85)模板题。

设 $f_{i,j}$ 为总时间为 $j$ 时，前 $i$ 株草药获得的最大价值，$c_i$ 为采摘第 $i$ 株草药所需的时间，$w_i$ 为采摘第 $i$ 株草药带来的价值。

- 当采摘第 $i$ 株草药时，$f_{i,j}$ 可以表示为 $f_{i-1,j-c_i}+w_i$。

- 当不采摘第 $i$ 株草药时，$f_{i,j}$ 可以表示为 $f_{i-1,j}$。

最终的 $f_{i,j}$ 取上述两种情况的较大值即可。

需要注意的是，如果 $j < c_i$，那么 $f_{i,j}$ 只能取第二种情况（即不采摘第 $i$ 株草药）。

我们发现 $f_{i,j}$ 的取值只和 $f_{i-1,j}$ 有关，因此，我们可以压掉第一维。

压维后的转移方程为 $f_j=\max(f_j,f_{j-c_i}+w_i)$。

### 代码

#### 无压维


```cpp
#include<iostream>
#define int long long 
using namespace std;
const int N=1e3+5;
int t,m,c[N],w[N],f[N][N];
signed main(){
	cin>>t>>m;
	for(int i=1;i<=m;i++){
		cin>>c[i]>>w[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<c[i];j++){
			f[i][j]=f[i-1][j];
		}
		for(int j=c[i];j<=t;j++){
			f[i][j]=max(f[i-1][j],f[i-1][j-c[i]]+w[i]);
		}
	}
	cout<<f[m][t];
	return 0;
} 
```
#### 压维


```cpp
#include<iostream>
#define int long long 
using namespace std;
const int N=1e3+5;
int t,m,c[N],w[N],f[N];
signed main(){
	cin>>t>>m;
	for(int i=1;i<=m;i++){
		cin>>c[i]>>w[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=t;j>=c[i];j--){//想想为什么要这样循环
			f[j]=max(f[j],f[j-c[i]]+w[i]);
		}
	}
	cout<<f[t];
	return 0;
} 
```

---

## 作者：sea_bird (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1048)。

# 题目分析

刚刚在刷水题的我，注意到了这个曾经难住我的题目开题解区了，因此来写一篇题解。

这道题就是 01 背包的模板，什么是 01 背包呢？

> 01 背包是在 $M$ 有限件物品中取出若干件放在空间为 $W$ 的背包里，每件物品的体积为 $W_1$ 至 $W_n$，与之相对应的价值为 $P_1$ 至 $P_n$。求最小代价能取到物品的最大价值。

很明显，这道题简直就是按照这个定义出的。

## 思路

背包问题要用动态规划来解决，动态规划是**一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法**。划分出的每个子问题，通过一个公式，也就是状态转移方程联系起来，最后得到全局最优解。

## 做法

首先解这道题，先设状态，在代码中将状态设为 `f[i][j]`，意思是当放到第 $i$ 个物品时，容量为 $j$ 的背包所能达到的最大值。

接下来推出代码的核心，也就是状态转移方程，假设当前是第 $i$ 个物品，上一个物品便是第 $i-1$ 个。那么如果不选择放入新的物品，此时的最大值代码表示为 `f[i][j]`。当选择将其放入背包时，背包的剩余的容量减小，当前最大价值增加，用数组来表示就是，`f[i-1][j-w[i]]+p[i]`。因此可以得到用代码表示的方程 `f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+p[i])`。

附上一维优化运用滚动数组的代码。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std ;
const int N=1e8;
int w[N],p[N],f[N];
int main ()
{
  int n,m;
  cin>>m>>n;
  for(int i=1;i<=n;i++){
	cin>>w[i]>>p[i];
  }
  for(int i=1;i<=n;i++){
	for(int j=m;j>=w[i];j--){
		if(f[j-w[i]]+p[i]>f[j]){
			f[j]=f[j-w[i]]+p[i];
		}
	}
  }
  cout<<f[m]<<endl;
  return 0;
}
```

如果有没讲清的，欢迎补充。

---

## 作者：3_14 (赞：1)

[**题目传送门**](https://www.luogu.com.cn/problem/P1048)

# 思路

一个典型的 **0-1背包问题**。我们需要在给定的时间内，选择一些草药，使得它们的总价值最大。每个草药只能选择一次（即要么采，要么不采）。

我们可以定义一个二维数组 $dp_{i,j}$，表示前 $i$ 株草药在时间 $j$ 内可以获得的最大价值。

*   $dp_{i,j}$ 的状态转移方程如下：
    *   如果不采摘第 $i$ 株草药，那么 $dp_{i,j} =  dp_{i-1,j}$。
    *   如果采摘第 $i$ 株草药，那么  $dp_{i,j} = dp_{i-1,j-time_i} + value_i$。
    *   最终 $dp_{i,j}$ 取上述两种情况的最大值。


# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e6+5;
int T,M;
int main(){
    cin >>T>>M;
    vector<int>time(M+1),value(M+1);
    vector<vector<int>>dp(M+1,vector<int>(T+1,0));
    for(int i=1;i<=M;++i)cin>>time[i]>>value[i];
    for(int i=1;i<=M;++i){
        for(int j=0;j<=T;j++){
            if(j>=time[i])dp[i][j]=max(dp[i-1][j],dp[i-1][j-time[i]]+value[i]);
            else dp[i][j]=dp[i-1][j];
        }
    }
    cout<<dp[M][T]<<'\n';
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/198307977)

---

## 作者：haoguorui_python (赞：1)

# 题意

很显然，这是一个背包问题，因为是在一定的限制内求出最优解。

根据题目描述，可以看出采摘某株草药的时间就是物品的体积，草药的价值就是物品的价值，用来采药的时间就是背包的容量。

# 思路

不难发现，这是一个 01 背包问题，因为每株草药只能被采摘一次。

## 确定状态

共有 $M$ 个物品，背包总容量为 $T$。

我们可以将状态设置为对于前 $i$ 个物品，背包容量不超过 $j$ 的情况下，可以获得的最大价值为 $dp[i][j]$。

## 逻辑

是否将第 $i$ 个物品放入背包中，要考虑以下几点：

- 当当前背包容量小于第 $i$ 个物品的体积时，无法放入背包。
- 如果将第 $i$ 个物品放入背包后，总体积不超过限制且总价值比之前要大，那么就可以将第 $i$ 个物品放入背包。

## 状态转移方程

根据上面的逻辑，可以写出状态转移方程。($c_i$ 是第 $i$ 个物品的体积，$w_i$ 是第 $i$ 个物品的价值)

- 当 $j<c[i]$ 时，$dp[i][j]=dp[i-1][j]$。

- 当 $c_i\le j\le T$ 时，$dp[i][j]=max(dp[i-1][j],dp[i-1][j-c_i]+w_i)$。

本思路时间复杂度为 $O(MT)$，对于本题来说完全够用。

# Code


```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int dp[101][1010]; //状态数组。
int w[101], c[101]; //w_i 为草药的价值，c_i 为采摘某株草药的时间。
int main() {
    int N, V; //N 为草药数目，V 为总共能够用来采药的时间。
    cin >> V >> N;
    for (int i = 1; i <= N; i++) {
        cin >> c[i] >> w[i];
    }
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= V; j++) {
            if (j >= c[i]) { //当这株草药能够被放进背包时
                dp[i][j]=max(dp[i-1][j-c[i]]+w[i],dp[i-1][j]); //比较最大值
            } else { //当这株草药不能够被放进背包时
                dp[i][j]=dp[i-1][j];
            }
        }
    }
    cout << dp[N][V] << endl;
    return 0;
}

```

---

## 作者：lovely_qiqi (赞：1)

## 思路
这道题是 01 背包的板题。可以将采药的时间看作这个药的体积。

我们使用动态规划解决。首先我们设 $dp_{i,j}$ 表示处理到第 $i$ 个时，背包容量为 $j$ 时能够获得的最大价值。那么很明显答案为 $dp_{T,M}$ 的值。于是我们发现对于转移方程分两种情况，选这个药和不选这个药，转移方程就是 $dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-t_i}+v_i)$ 其中 $v_i$ 是价值，$t_i$ 是体积。

最后滚动的时候必须倒序，不然可能会出现一个药用两次的情况。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,M,v[110],t[110],dp[1010];
int main(){
    scanf("%d%d",&T,&M);
    for(int i=1;i<=M;i++) scanf("%d%d",&t[i],&v[i]);
    for(int i=1;i<=M;i++){
        for(int j=T;j>=1;j--){
            if(j>=t[i])dp[j]=max(dp[j],dp[j-t[i]]+v[i]);
        }
    }
    printf("%d",dp[T]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

经典 0-1 背包问题。

定义 $dp_{i,j}$ 表示前 $i$ 株草药在总时间不超过 $j$ 的情况下可以获得的最大价值，可得到状态转移方程：如果不采摘第 $i$ 株草药，$dp_{i,j} \gets dp_{i-1,j}$；
如果采摘第 $i$ 株草药，$dp_{i,j} \gets dp_{i-1,j-time_i}+value_i$（$time$ 用于储存采药所需时间，$value$ 储存草药价值）。总的状态转移方程就出来了：$dp_{i,j}\gets \max_{dp_{i,j},dp_{i-1,j-time_i}+value_i}$

---


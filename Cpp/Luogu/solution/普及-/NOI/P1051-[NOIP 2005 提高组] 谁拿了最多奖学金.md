# [NOIP 2005 提高组] 谁拿了最多奖学金

## 题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表 $1$ 篇或 $1$ 篇以上论文的学生均可获得；
2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；
3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；
4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；
5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，满足 $1 \le  N \le  100$。

**【题目来源】**

NOIP 2005 提高组第一题

## 样例 #1

### 输入

```
4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1
```

### 输出

```
ChenRuiyi
9000
28700
```

# 题解

## 作者：qhr2023 (赞：21)

## solution

小模拟。

按题意读入后，求这个人的奖金，这里判断这个人能否获得某项奖金，可以用逻辑表达式减少代码量，即若表达式成立返回 $1$ 否则返回 $0$，用逻辑表达式的结果乘上某项的奖金，就是这个人在某项上获得的奖金。最后别忘了计算总奖金。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a, b, e, sum, Sum, mx;
string s, ans;
int main () {
	cin >> n;
	for (char c, d; n--; Sum+=sum) {
		cin >> s >> a >> b >> c >> d >> e;
		sum=(a>80&&e)*8000+
			(a>85&&b>80)*4000+
			(a>90)*2000+
			(a>85&&d=='Y')*1000+
			(b>80&&c=='Y')*850;
		if (sum>mx)
			mx=sum,
			ans=s;
	} 
	cout << ans << '\n' << mx << '\n' << Sum;
	return 0;
}
```

---

## 作者：xyw1212 (赞：7)

# P1051 [NOIP 2005 提高组] 谁拿了最多奖学金
[题目传送门](https://www.luogu.com.cn/problem/P1051)
### 分析
这题是一道模拟题，比较简单（~~但不知为啥是提高组的题~~），基本思路是通过在循环输入的同时，进行比较取最大值，并统计出总奖学金数，最后输出。\
这题可以使用`struct`数组存储或直接用变量输入（我用的是`struct`）。
___
### AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct student{
	string name;                //名字 
	int grade;                  //期末成绩 
	int thesis;                 //论文数量 
	int class_evaluation;       //班级评议
	char west;                  //是否是西部学生
	char student_leader;        //是否是学生干部 
	int money;                  //奖金总数 
}stu[105];                      //定义一个数组，存放学生们的数据 
int main(){
	int n,maxn=-1,sum=0;
	string maxname;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>stu[i].name>>stu[i].grade>>stu[i].class_evaluation>>stu[i].student_leader>>stu[i].west>>stu[i].thesis;
		//漫长的输入 
		if(stu[i].grade>80&&stu[i].thesis>0)                         //院士奖学金
			stu[i].money+=8000;
		if(stu[i].grade>85&&stu[i].class_evaluation>80)              //五四奖学金
			stu[i].money+=4000;
		if(stu[i].grade>90)                                          //成绩优秀奖
			stu[i].money+=2000;
		if(stu[i].grade>85&&stu[i].west=='Y')                        //西部奖学金
			stu[i].money+=1000;
		if(stu[i].class_evaluation>80&&stu[i].student_leader=='Y')   //班级贡献奖
			stu[i].money+=850;
		if(stu[i].money>maxn){                                       //比较出奖学金总数最多的学生 
			maxname=stu[i].name;
			maxn=stu[i].money;
		}
		sum+=stu[i].money;                                           //统计奖学金总数 
	}
	cout<<maxname<<endl<<maxn<<endl<<sum;                            //输出 
	return 0;
} 
```

---

## 作者：hanyu0722 (赞：5)

~~这题根本不用排序！~~
### 题目链接

[P1051 [NOIP 2005 提高组] 谁拿了最多奖学金](https://www.luogu.com.cn/problem/P1051)

### 题目思路

首先我们可以依次读入数据，对于每一位学生，依据规则计算其能得到的奖学金数量。  

由于题目中只需要我们输出最高奖学金学生的信息，以及总奖学金是多少，所以我们只需用一个变量维护**最高奖学金同学的姓名**，用一个变量维护**最高奖学金**，用另一个变量维护**累计奖学金**即可。

### 代码时间

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,mx;
string s;
int main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		string name;
		int x,y,z,money=0;
		char xx,yy;
		cin>>name>>x>>y>>xx>>yy>>z;
		
		if (x>85 && y>80) money+=4000;
		if (x>90) money+=2000;
		if (xx=='Y' && y>80) money+=850;
		if (yy=='Y' && x>85) money+=1000;
		if (x>80 && z) money+=8000;
		
		sum+=money;
		if (money>mx){
			mx=money;
			s=name;
		}
	}
	cout<<s<<"\n"<<mx<<"\n"<<sum;
	return 0;
}

``` 

[link](https://www.luogu.com.cn/record/202464102)

---

## 作者：lucienshawls (赞：5)

# 我认为本题主要考的是读入数据
而且主要考的是读入字符串。。。。

做完以后看了一下题解，发现**c++代码全都用的是cin来读字符串**。

对于本题可能没什么，数据规模也比较小——

但是！！！！！！

要是题目数据很大呢？

cin很有可能会炸。scanf也很可能会炸。

到时候因为输入不过关而被卡掉的时候，你就知道心里有多苦了。

### 所以必须学会数字和字符串的读入优化！！！

~~说得好这规模这么小我选择cin~~


------------


## 如何读入数据呢？
众所周知，getchar的速度还是可以的。

不要用gets...洛谷会说这玩意很危险。最好别用。~~哪里危险了喂~~

### 1.数值的读入优化
这个操作比较常见，就是读入一个字符，转成数字，结果乘以10再相加（详见代码）
### 2.字符串的读入优化

所谓优化，就是也用getchar来读入。于是我把这个读入过程封装成了一个函数，谓之“字符串读入优化”

原理就是读入一个字符后，加在字符串数组的最后（用tot表示这个位置的下标）

你问我为什么不用vector？STL本来就慢，跟没优化是一样的好吗...~~vector多好用啊~~


------------

## 算法
用一个结构体，依次输入，按题目意思写，然后按题目给的要求排序，最后输出第一名和累加奖学金即可，没什么大的难度


------------

## 最后，我在代码中保留了一些小技巧，希望可以帮到大家!
详见代码:

```cpp
//题目：P1051 谁拿了最多奖学金
//Author: xlecheng
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define MAXN 110
using namespace std;

template <typename T>//模板函数，可以用一个函数同时实现快速读入int,long long等多种类型（必须是数字） 
//这里的T可以理解为代表了int,long long,bool...等的声明语句
//比如read(n)，n是int变量，系统会自动识别 
inline void read(T &input){//&表示引用，修改input会同步修改带入的值，比如n 
	//数值读入优化 
	input=0;int f=1;//f代表正负号 
	char c=getchar();
	while(c>'9' || c<'0'){//不是数字就继续读 
		if(c=='-')f=-1;//读入了负号就变号 
		c=getchar();
	}
	while(c<='9' && c>='0'){//是数字，一位一位的读字符 
		input=(input<<3)+(input<<1)+c-'0';
		//input*8+input*2就是input*10
		c=getchar();
	}
	input*=f;
}
inline void read(char res[]){//同名函数，只要参数不同就可以重载 
	//参数是一个数组（看成指针），也会同步修改带入的参数 
	char c=getchar();int tot=0;//tot存储字符串数组下标 
	#define isvalid(c) ((c>='a' && c<='z') || (c>='A' && c<='Z'))
	//define判断语句使得代码简洁 
	while(!isvalid(c))//不是字母 
		c=getchar();
	while( isvalid(c)){//是字母 
		res[tot++]=c;//先让res[tot]=c，再让tot自加1 
		c=getchar();
	}
}
struct NOIP{
	int code;//编号,按照输入的顺序 
	char name[30];//名字 
	int test,assess;//期末平均分数，班级评议分数 
	char leader,west;//是否干部，西部 
	int num;//论文数量 
	int money;//奖学金总数 
}stu[MAXN];
bool operator <(NOIP x,NOIP y){//重载小于号，供sort排序 
//重载小于号看作一个返回“先后”的函数，返回1则x排在前面 
	if(x.money==y.money){//奖学金相同则比较编号（读入的先后） 
		return (x.code<y.code);
	}else{//否则奖学金高的在前 
		return (x.money>y.money);
	}
}
int get_money(int x){//计算奖学金stu[x]的奖学金，按题目来 
	int res=0;
	//院士
	if(stu[x].test>80 && stu[x].num>=1)res+=8000;
	//五四
	if(stu[x].test>85 && stu[x].assess>80)res+=4000;
	//成绩
	if(stu[x].test>90)res+=2000;
	//西部
	if(stu[x].test>85 && stu[x].west=='Y')res+=1000;
	//班级 
	if(stu[x].assess>80 && stu[x].leader=='Y')res+=850;
	return res; 
}
int n;
int tot=0;//所有人的奖学金总数 
int main(){
/*小技巧，在你的IDE的编译选项里，写上:
 
-DLOCAL

(-D是必须的，后面可以跟上任何你喜欢的字符串)
则在  #ifdef LOCAL ... #endif   中的所有代码只有加入-DLOCAL的编译器才会执行这个代码
在本机测试时常常需要使用文件输入来节约时间，也不用担心提交的时候忘了删掉freopen导致全WA... 
*/
#ifdef LOCAL
	freopen("1.in","r",stdin);
#endif
	read(n);//括号里的是一个int而非数组，数值读入函数 
	for(int i=1;i<=n;i++){
		stu[i].code=i;
		read(stu[i].name);//括号里的name是一个char数组，字符串读入 
		read(stu[i].test);
		read(stu[i].assess);
		scanf("%c",&stu[i].leader);//读入单个字符 
		scanf(" %c",&stu[i].west);//请注意%c前面的空格 
		read(stu[i].num);
		stu[i].money=get_money(i);//计算 
		tot+=stu[i].money;//累加 
	}
	sort(stu+1,stu+n+1);//排序,1~n
	void print(int);//小技巧，在这里声明一个函数就可以把它放在主函数后面，只需指明参数类型即可
	//这种技巧通常用于一个已经写好的完全没问题的函数，可以"放在一边"方便观察调试其它的函数 
	
	print(1);//输出第一名
	return 0;
}
void print(int x){
	cout<<stu[x].name;
	printf("\n%d\n%d\n",stu[x].money,tot);
}

```


---

## 作者：mcturtle (赞：4)

# 题解：P1051 [NOIP 2005 提高组] 谁拿了最多奖学金
## 思路
题意很清楚，不必多说。

橙题大模拟，根据要求模拟就行。

因为要排序，定义一个结构体，包含 $7$ 个成员：姓名，期末平均成绩，班级评议成绩，是否为学生干部，是否为西部省份学生，发表的论文数，奖学金钱数，号码。全部赋初值为 $0$。

首先依次输入五个数，按照题意输入即可。

边输入边进行判断是否获得奖学金。判断过程看题。


> 1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表 $1$ 篇或 $1$ 篇以上论文的学生均可获得；

代码：`if (a[i].sc1 > 80 and a[i].arc >= 1) a[i].money += 8000;`

> 2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；

代码：`if (a[i].sc1 > 85 and a[i].sc2 > 80)
a[i].money += 4000;`

> 3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；

代码：`if (a[i].sc1 > 90) a[i].money += 2000;`

> 4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；

代码：`if (a[i].sc1 > 85 and a[i].f2 == 'Y')
a[i].money += 1000;`

> 5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；

代码：`if (a[i].sc2 > 80 and a[i].f1 == 'Y')
a[i].money += 850;`
## 总体代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node
{
    string name;//代表名字
    int sc1, sc2, arc, id, money;//分别代表期末平均成绩，班级评议成绩，发表的论文数，号码，奖学金数量
    char f1, f2;//分别代表是否为学生干部，是否为西部省份学生
} a[105];
bool cmp(node a, node b)
{
    if (a.money != b.money)//若钱数不相等
        return a.money > b.money;//哪个大就排在前面
    return a.id < b.id;//不然比较号码
}
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i].name >> a[i].sc1 >> a[i].sc2 >> a[i].f1 >> a[i].f2 >> a[i].arc;//依次输入
        a[i].id = i;//号码设好
        //依次判断
        if (a[i].sc1 > 80 and a[i].arc >= 1)
            a[i].money += 8000;
        if (a[i].sc1 > 85 and a[i].sc2 > 80)
            a[i].money += 4000;
        if (a[i].sc1 > 90)
            a[i].money += 2000;
        if (a[i].sc1 > 85 and a[i].f2 == 'Y')
            a[i].money += 1000;
        if (a[i].sc2 > 80 and a[i].f1 == 'Y')
            a[i].money += 850;
    }
    sort(a + 1, a + n + 1, cmp);/排序
    int ans = 0;//奖学金总和
    for (int i = 1; i <= n; ++i)
        ans += a[i].money;//求和
    cout << a[1].name << endl << a[1].money << endl << ans;//按要求输出
    return 0;
}
```
**警示后人：奖金可以叠加，要用多个 `if`，不能用 `if else`。**

---

## 作者：Haohao123coding (赞：3)

## 题目分析

本题难度不大，但是要细心，要有好的码风，如：

- 不要把 $>$ 写成 $\geq$；
- 一个人可能拿多个奖，也可能不拿奖；
- 变量名不要定义得自己都看不懂，如 `a`、`b`、`c`。

本题 $1 \leq N \leq 100$，无需快读，`cin` 即可。定义一个结构体，存储学生信息，一些数据可用 `bool`。

最后输出获得最多奖金的学生的姓名、这名学生获得的奖金总数、这 $N$ 个学生获得的奖学金的总数。

注意用打擂台法找最大值是从前到后是 `>`，从后到前则是 `>=`，因为奖学金相同时顺序输出靠**前**的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu{
	string name; // 姓名
	int score, cscore, mon; // 期末平均成绩、班级评议成绩、奖学金总数
	bool ganBu, xiBu, lunWen; // 即为拼音
};
int main(){
	int n = 0;
	char g, x;
	int l;     // g、x、l 都是临时变量
	cin >> n;
	stu sts[n];
	for(int i = 0; i < n; i++){
		cin >> sts[i].name >> sts[i].score
			>> sts[i].cscore >> g >> x >> l;
		if(g == 'Y') sts[i].ganBu = 1;
		else sts[i].ganBu = 0;
		if(x == 'Y') sts[i].xiBu = 1;
		else sts[i].xiBu = 0;
		if(l >= 1) sts[i].lunWen = 1;
		else sts[i].lunWen = 0;       // 这三个都是判断
	} // 输入
	for(int i = 0; i < n; i++){
		sts[i].mon = 0; // 初始化这个人的奖学金
		if(sts[i].score > 80 && sts[i].lunWen) sts[i].mon += 8000;
		if(sts[i].score > 85 && sts[i].cscore > 80) sts[i].mon += 4000;
		if(sts[i].score > 90) sts[i].mon += 2000;
		if(sts[i].score > 85 && sts[i].xiBu) sts[i].mon += 1000;
		if(sts[i].cscore > 80 && sts[i].ganBu) sts[i].mon += 850;
	} // 判断是否获奖，是则增加奖学金
	int maxx = -1, maxS = -1, sum = 0;
	for(int i = 0; i < n; i++){
		if(sts[i].mon > maxx){
			maxx = sts[i].mon;
			maxS = i;
		} // 用打擂台法找最大值
		sum += sts[i].mon;
	} // 找最大值，同时加和
	cout << sts[maxS].name << '\n' << sts[maxS].mon << '\n' << sum;
}
```

请勿复制提交，否则会变棕（作弊者），代码可能动过手脚。

---

## 作者：__CJY__ (赞：2)

## 思路
使用一个结构体，读入进来。

然后再根据题目进行判断：
>1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表 $1$ 篇或 $1$ 篇以上论文的学生均可获得；
>2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；
>3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；
>4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；
>5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；
>
>只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。

**因为一名学生可以重复获奖，所以判断的时候要用 `if` 而不是 `else if`。**

再把奖学金最高的学生找出来，这其中要注意：
>如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。

最后输出获得奖金最多的学生的姓名、这名学生获得的奖金总数、这 $N$ 个学生获得的奖学金的总数。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct students{
	string name;
	int qm,bj,lw,id,s=0;//分别表示期末平均成绩、班级评议成绩、发表的论文数、序号、该学生的奖金数
	char gb,xb;//分别表示是否为学生干部、是否为西部省份学生
}a[105];
int n,ma=INT_MIN,ma_i,ma_id,s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].name>>a[i].qm>>a[i].bj>>a[i].gb>>a[i].xb>>a[i].lw,a[i].id=i;//输入
		//按照题意判断
		if(a[i].qm>80&&a[i].lw) a[i].s+=8000;
		if(a[i].qm>85&&a[i].bj>80) a[i].s+=4000;
		if(a[i].qm>90) a[i].s+=2000;
		if(a[i].qm>85&&a[i].xb=='Y') a[i].s+=1000;
		if(a[i].bj>80&&a[i].gb=='Y') a[i].s+=850;
		s+=a[i].s;//记录总和
	}
	for(int i=1;i<=n;i++){
		if(ma<a[i].s||(ma==a[i].s&&a[i].id<ma_id)) ma=a[i].s,ma_i=i,ma_id=a[i].id;//按照题意打擂台
	}
	cout<<a[ma_i].name<<'\n'<<a[ma_i].s<<'\n'<<s;//输出
}
```

---

## 作者：csxx601cjy (赞：1)

这道题还是很水的，按题意模拟就行。

根据每个人的信息计算出每个人的奖学金，然后找最大。

要注意的是，如果有两个并列第一，要输出出现最早的。

搬出我一年前的代码：
```cpp
#include<stdio.h>
struct node{
    char name[30];
    int qimo;
    int banji;
    char ganbu;
    char xibu;
    int lunwen;
    int sum;
}Node;
int main(){
    Node a[110];
    int i,j,n,maxp=1,max=0,ans3=0;
    char temp;
    scanf("%d\n",&n);
    for(i=1,j=0;i<=n;i++){
         j=a[i].sum=0;
        while((temp=getchar())!=' ')
        a[i].name[j++]=temp;
        a[i].name[j]='\0';
        scanf("%d %d %c %c %d",&a[i].qimo,&a[i].banji,&a[i].ganbu,&a[i].xibu,&a[i].lunwen);
        if(a[i].qimo>80 && a[i].lunwen>=1) a[i].sum+=8000;
        if(a[i].qimo>85 && a[i].banji>80) a[i].sum+=4000;
        if(a[i].qimo>90) a[i].sum+=2000;
        if(a[i].qimo>85 && a[i].xibu=='Y') a[i].sum+=1000;
        if(a[i].banji>80 && a[i].ganbu=='Y') a[i].sum+=850;
        while((temp=getchar())!='\n');  
    }
    for(i=1;i<=n;i++){
        if(a[i].sum>max){
            maxp=i;
            max=a[i].sum;
        }
        ans3+=a[i].sum;
    }
    printf("%s\n%d\n%d",a[maxp].name,max,ans3);
    return 0;
}
```

---

## 作者：xf20280111 (赞：1)

因为一个字符从 0 分变成了 100 分。。。
## 读题
这是这道题目最重要的部分！！！

我们需要认真读清楚每一个条件，常见的错误可能会有：
- 大于符号和大于等于符号混淆。
  
- 成绩种类混淆。

## 算法
我们从题面知道，需要找出奖学金最多的同学。

每一个学生还有多种信息，我们可以联想到结构体和 cmp 函数。

### 排序的规则

以成绩为第一关键字，以名字出现的顺序为第二关键字排序。于是，我们不难得到 cmp 函数：

```cpp
//zs 代表总奖学金,bh 代表出现顺序
bool cmp(node x,node y){
	if (x.zs==y.zs) return x.bh<y.bh;
	else return x.zs>y.zs;
}
```
### 存储

使用结构体来存储读入的信息。

## 处理
本题在字符串的输入上没有卡你，也不带空格，我们放心使用 cin。

排序之后我们把每个人的总奖学金加起来就能得到总奖学金。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	string name;
	int qm;
	int bj;
	char gb;
	char xb;
	int lw;
	int zs;
	int bh;
}k[110];
bool cmp(node x,node y){
	if (x.zs==y.zs) return x.bh<y.bh;
	else return x.zs>y.zs;
}
int main()
{
	int n;
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>k[i].name>>k[i].qm>>k[i].bj>>k[i].gb>>k[i].xb>>k[i].lw;//不要弄错顺序了
		k[i].bh=i;
	}
	for (int i=1;i<=n;i++){
		if (k[i].qm>80 and k[i].lw>=1) k[i].zs+=8000;
		if (k[i].qm>85 and k[i].bj>80) k[i].zs+=4000;
		if (k[i].qm>90) k[i].zs+=2000;//读好题目中的信息
		if (k[i].qm>85 and k[i].xb=='Y') k[i].zs+=1000;
		if (k[i].bj>80 and k[i].gb=='Y') k[i].zs+=850;
	}
	int sum=0;
	for (int i=1;i<=n;i++){
		sum+=k[i].zs;
	}
	sort(k+1,k+n+1,cmp);
	cout<<k[1].name<<"\n"<<k[1].zs<<"\n"<<sum;
	return 0;
}
```

---

## 作者：pengyirui (赞：1)

# 前置芝士
大佬跳过。    
本题考查结构体以及排序。
## 结构体
### 定义方法

```cpp
struct nd{
  int a,b; 
};
```
### 数组/变量定义

```cpp
nd a[999999];
nd s;
```
### 结构体变量调用

```cpp
nd aa;
aa.a=1;//调用
```
### 结构体排序

```cpp
bool cmp(nd aa,nd bb)
{
    return aa.a>bb.a;
}
sort(aa+1,aa+1+n,cmp);
```

## 类
### 定义
```cpp
class cl{
  int s;//私有变量，外界不得调用，否则编译错误
  public:
     int a;//公开变量，外界可以调用
}；
```
### 数组、变量定义
```cpp
cl a[999999];
cl s;
```
### 调用
```cpp
cl aa;
aa.a=1;//调用
```
### 类排序
```cpp
bool cmp(cl aa,cl bb)
{
    return aa.a>bb.a;
}
sort(aa+1,aa+1+n,cmp);
```
## 排序
建议使用 STL。
```cpp
sort(a+1,a+1+n);
```
使用的是快速排序，复杂度 $$O(n \log n)$$，默认从小到大，从大到小和结构体排序需手写 cmp。
# 思路
输入+计算+排序+计算总和。
# 代码
献上~一点都不~宝贵的代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct nd
{
    string s;
    int qm,py,lw;
    char gb,xb;
    int ansi,j;
}a[1000005];
int n;
bool cmp(nd aa,nd bb)
{
	if(aa.ansi!=bb.ansi) return aa.ansi>bb.ansi;
    return aa.j<bb.j;
}
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++)a[i].j=i;
    for(int i=1;i<=n;i++)cin>>a[i].s>>a[i].qm>>a[i].py>>a[i].gb>>a[i].xb>>a[i].lw;
    for(int i=1;i<=n;i++)
    {
    	if(a[i].qm>80&&a[i].lw>=1)a[i].ansi+=8000;
    	if(a[i].qm>85&&a[i].py>80)a[i].ansi+=4000;
		if(a[i].qm>90)a[i].ansi+=2000;
		if(a[i].qm>85&&a[i].xb=='Y')a[i].ansi+=1000;
		if(a[i].gb=='Y'&&a[i].py>80)a[i].ansi+=850; 
	}
	sort(a+1,a+1+n,cmp);
	cout<<a[1].s<<"\n"<<a[1].ansi<<"\n";
	int ans=0;
	for(int i=1;i<=n;i++)ans+=a[i].ansi;
	cout<<ans;
	return 0;
}
```
时间复杂度为 $O(n\log n+n)$，空间复杂度为 $O(n)$，可以通过此题。

---

## 作者：「QQ红包」 (赞：1)

这道题目虽然很水……但也有它的考点……

第一个就是考耐心，各种奖很麻烦的有木有……

第二个就是考字符串的处理，我估计有人忘了……

第三个就是考细心，不细心的话手滑打错几个字母然后……

这题纯模拟……我搞不懂noip2005第一题为什么要用这题……一道语法题……

```delphi

var b:array[1..100] of string;//b存名字
    a:array[1..6,1..100] of integer;//a[1]期末平均成绩，a[2]班级评议成绩，a[3]是否是学生干部(1为是，0为不是)，a[4]是否是西部省份学生(1为是，0为不是)，a[5]发表的论文数，a[6]存奖学金数
    n,i,hehe,sum,max:longint;
    s:string;
begin
    readln(n);
    for i:=1 to n do
    begin
        readln(s);
        s:=s+' ';
        b[i]:=copy(s,1,pos(' ',s)-1);//读入名字
        delete(s,1,pos(' ',s));//把名字以及后面的一个空格删除
        val(copy(s,1,pos(' ',s)-1),a[1,i],hehe);//读入期末平均成绩
        delete(s,1,pos(' ',s));//把期末平均成绩以及后面的一个空格删除
        val(copy(s,1,pos(' ',s)-1),a[2,i],hehe);//读入班级评议成绩
        delete(s,1,pos(' ',s));    //把班级评议成绩以及后面一个空格删除
        if s[1]='Y' then a[3,i]:=1;//……是否学生干部，1是，0不是。
        delete(s,1,pos(' ',s));    //不说了……
        if s[1]='Y' then a[4,i]:=1;//……是否西部省份学生
        delete(s,1,pos(' ',s));    //不说了……
        val(copy(s,1,pos(' ',s)-1),a[5,i],hehe);//发表的论文数
    end;
    for i:=1 to n do//奖的类型太多……很烦对不对……
    begin
         if (a[1,i]>80)and(a[5,i]>=1) then begin inc(sum,8000);a[6,i]:=a[6,i]+8000; end;//各种奖……
         if (a[1,i]>85)and(a[2,i]>80) then begin inc(sum,4000);a[6,i]:=a[6,i]+4000; end;
         if  a[1,i]>90 then begin inc(sum,2000);a[6,i]:=a[6,i]+2000; end;
         if (a[4,i]=1)and(a[1,i]>85) then begin inc(sum,1000);a[6,i]:=a[6,i]+1000; end;
         if (a[2,i]>80)and(a[3,i]=1) then begin inc(sum,850);a[6,i]:=a[6,i]+850; end;
    end;
    max:=1;
    for i:=2 to n do
    if a[6,i]>a[6,max]  then max:=i;
    writeln(b[max]);
    writeln(a[6,max]);
    writeln(sum);
end.

```

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P1051 [NOIP 2005 提高组] 谁拿了最多奖学金](https://www.luogu.com.cn/problem/P1051)

考察：分支结构。

我们将期末平均成绩、班级评议成绩、是否是学生干部、是否是西部省份学生以及发表的论文数用 $a_1\sim a_5$ 表示，按照题意模拟即可：

- 当 $a_5 \geqslant 1$ 且 $a_1 > 80$，奖学金加 $8000$；

- 当 $a_1 > 85$ 且 $a_2 > 80$，奖学金加 $4000$；

- 当 $a_1 > 90$，奖学金加 $2000$；

- 当 $a_1 > 85$ 且 $a_4$（不为 $0$），奖学金加 $1000$；

- 当 $a_2 > 80$ 且 $a_3$，奖学金加 $850$。

之后从前往后打擂台：如果**更大**就更新学生，最终输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct student{
	string name;
	int a1,a2,a5;
	bool a3,a4;
}a[101];
long long s=0,ai[101],j=0;
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i].name>>a[i].a1>>a[i].a2;
		char k;
		cin>>k;
		if(k=='Y')a[i].a3=1;
		else a[i].a3=0;
		cin>>k>>a[i].a5;
		if(k=='Y')a[i].a4=1;
		else a[i].a4=0;
		if(a[i].a5>=1&&a[i].a1>80)ai[i]+=8000;
		if(a[i].a1>85&&a[i].a2>80)ai[i]+=4000;
		if(a[i].a1>90)ai[i]+=2000;
		if(a[i].a1>85&&a[i].a4)ai[i]+=1000;
		if(a[i].a2>80&&a[i].a3)ai[i]+=850;
	}
	for(int i=0;i<n;i++){
        s+=ai[i];
	    if(ai[i]>ai[j])j=i;
	}cout<<a[j].name<<endl<<ai[j]<<endl<<s;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/156427238)。

---

## 作者：RiverHamster (赞：0)

#很简单的一种做法，并不需要排序，依次列举即可

##使用C++ cin读入，可以跳过空格，读入字符比较方便

```cpp
#include <iostream>
#include <string>
using namespace std;
```
###结构体及全局变量定义

```cpp
struct student{   //存储学生信息 
    string name;  //名字，用string避免越界 
    int score;    //得分 
    int cscore;   //班级评议得分 
    char head;    //是否为学生干部(Y/N) 
    char west;    //是否为西部学生(Y/n) 
    int arcitle;  //论文数量 
};
student a[105];   //学生信息 
int size,total=0; //学生数量，总奖学金 
```
###读入所有数据的函数

```cpp
void initial(){   //初始化 
    cin>>size;
    for(int i=1;i<=size;i++){
        cin>>a[i].name>>a[i].score>>a[i].cscore>>a[i].head>>a[i].west>>a[i].arcitle;  //cin读入会自动跳过空格，读入字符比什么都方便 
    }
}
```
###计算奖学金数量

```cpp
int money(student n){  //对某个student对象计算奖学金数量 
    int ans=0;
    if(n.score>80&&n.arcitle>=1) ans+=8000;  //院士奖学金 
    if(n.score>85&&n.cscore>80)  ans+=4000;  //五四奖学金 
    if(n.score>90)               ans+=2000;  //成绩优秀奖 
    if(n.score>85&&n.west=='Y')  ans+=1000;  //西部奖学金 
    if(n.cscore>80&&n.head=='Y') ans+=850;   //班级贡献奖 
    return ans;  //返回获得奖学金的数量 
}
```
##主程序，比较简单

```cpp
int main(){
    initial();  //初始化输入 
    int Max=-1,Maxno=1;  //最大值和最大值所在的编号 
    for(int i=1;i<=size;i++){  //穷举最多奖学金，不需要排序 
        if(money(a[i])>Max){   //如果比最大值大 
            Max=money(a[i]);
            Maxno=i;
        }
        total+=money(a[i]);  //我就多算几遍不超时 
    }
    cout<<a[Maxno].name<<endl<<Max<<endl<<total<<endl;  //输出 
    return 0;
}
```
总之这道题不难，依次做就好


---


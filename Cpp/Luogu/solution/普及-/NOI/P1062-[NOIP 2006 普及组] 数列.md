# [NOIP 2006 普及组] 数列

## 题目描述

给定一个正整数 $k$（$3\leq k\leq 15$），把所有 $k$ 的方幂及所有有限个互不相等的 $k$ 的方幂之和构成一个递增的序列，例如，当 $k = 3$ 时，这个序列是：

$1, 3, 4, 9, 10, 12, 13, \ldots$

（该序列实际上就是：$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$）

请你求出这个序列的第 $N$ 项的值，用 $10$ 进制数表示。

例如，对于 $k = 3$，$N = 100$，正确答案应该是 $981$。


## 说明/提示

NOIP 2006 普及组 第四题


## 样例 #1

### 输入

```
3 100```

### 输出

```
981```

# 题解

## 作者：hongzy (赞：484)

（题目为啥要强调用十进制输出呢,明明就是故意提醒）

分析一下样例


$k=3$时，数列为：$1,3,4,9,10,12,13..$

转换成三进制就是：$1,10,11,100,101,110,111..$

看起来像是二进制，转化成十进制看看

$1,2,3,4,5,6,7..$

显然,第$n$项就是$n$.


程序就把这个过程逆回去，先把$n$转换成二进制，再把它当成$K$进制，重新转换为十进制.

```cpp
#include <iostream>
#include <stack>
#include <cmath>
using namespace std;

long long k, n, ans;
stack<int> S;

int main() {
    cin >> k >> n;
    while(n) S.push(n & 1), n >>= 1;
    while(!S.empty()) ans += S.top() * pow(k, S.size()-1), S.pop();
    cout << ans << endl;
    return 0;
}
```

$\text{upd}$ : $2018/10/26$ 添加$\text{LaTeX}$公式，麻烦管理员通过审核

---

## 作者：w1049 (赞：45)

### 看了一遍题解，发现大家都觉得这是个进制转换题
#### 新的思路：

其实吧，这题有个特点，长得跟**快速幂**很像

把样例的数列转换成三进制:


|序号|1| 2|3|4|5|6|7|
| :-----------| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
|三进制|1|10|11|100|101|110|111|
|十进制|1|3|4|9|10|12|13|


注意**三进制**的数字，为什么给人一种**二进制**的感觉?

（~~楼上有dalao说这就是二进制~~）

>把所有k的方幂及所有有限个**互不相等**的k的方幂之和构成一个递增的序列

这就是说，每一个**k的方幂**只能**有**或者**没有**

有为$0$，没有为$1$

如果第$i$位是$1$，那么答案要加上$k^i$

跟快速幂的思想很像

[快速幂模板](https://www.luogu.org/problemnew/show/P1226)

所以我就写出一个跟快速幂差别很小的东西：
```cpp
#include<cstdio>
int k,n;
long long ans,base=1;
int main(){
	scanf("%d%d",&k,&n);
    /**********************************/
	while(n){
		if(n&1)ans+=base;//跟快速幂只有这里不一样
		base*=k;
		n>>=1;
	}
    /**********************************/
	printf("%d",ans);
	return 0;
}
```
~~（按理说这个应该跑得比用pow的大佬们快）（按理说~~
## 这道题不仅可以考验进制转换
## 还可以练习快速幂！

---

## 作者：「QQ红包」 (赞：11)

以下是痴狂的飞鼠的解释，然后改动了一点：


我们在弄清了题意之后，来找一下规律

假设k=3，将数据排列出来，就可以得到下面的序列（省略3^）：

0,1,0+1,2,0+2,1+2,0+1+2,3,0+3,1+3,0+1+3,2+3,0+2+3,1+2+3,0+1+2+3……

好像没有什么规律哎……

但是！我们把上面的序列加上分割线，然后加上括号：

0 | 1  , 1+0 | 2 , 2+0 , 2+1 , 2+(1+0) | 3 , 3+0 , 3+1 , 3+(1+0) , 3+2 , 3+(2+0) , 3+(2+1) , 3+(2+(1+0))……
好像有规律了……

我们可以看出，第一部分有1项，第二部分有2项。第n部分就有2^n项

第n部分的第一项就是k^n，第n部分的第二项就是k^n+f[1]，第n部分的第i项就是k^n+f[i-1],规律就找到了~

但是题目的数据好像有点问题，cpp和c可以用%d输出，pascal只能加一个特判语句了~


放代码：

```cpp
#include<set>    
#include<map>    
#include<list>    
#include<queue>    
#include<stack>    
#include<string>    
#include<math.h>    
#include<time.h>    
#include<vector>    
#include<bitset>    
#include<memory>    
#include<utility>    
#include<stdio.h>    
#include<sstream>    
#include<iostream>    
#include<stdlib.h>    
#include<string.h>    
#include<algorithm> //一大堆头文件 
#define LL unsigned long long
using namespace std;  
long long  a[10];//1024是2^10,1000<1024,所以0~9够了 
long long  f[1010];//long long 防炸 
int main()
{
    long long k,n;
    cin>>k>>n;
    int i,j;
    a[0]=1;//求出k^0~k^9 
    int s=1;  
    for (i=1;i<=9;i++) 
         a[i]=a[i-1]*k;//这样推比用pow要快些吧。 
    for (i=0;i<=9;i++)//分成九段去枚举 a[i]表示第i段的开头的值 
    {
        f[s]=a[i];//找规律可得第i组的第一个是k^i 
        for (j=1;j<=s;j++)
            f[s+j]=f[s]+f[j];//开始找规律得到的，f[i]=f[这一段的第一个的位置]+f[i-这一段的第一个的位置] 
        s*=2;// s表示2^i 相当于pow(2,i); 
        if (f[n]!=0)//如果f[n]求出来了 
        {
            printf("%d",f[n]); //用%d才能a，不然就要打标 
            return 0;//节约时间 
        }
    }  
    return 0;
}//洛谷3.0会吃缩进，2.0大法好
```

---

## 作者：kunkun127 (赞：7)

## 思路

我们观察题目，其实一开始看到是黄题还是有点震惊的（有点难），但仔细观察后就可以发现一点端倪。

注意到题目所给的提示：

  - 例如，当 $k = 3$ 时，这个序列是：

    $1, 3, 4, 9, 10, 12, 13, \ldots$

    （该序列实际上就是：$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$）

此时我们将其转换为三进制，也就是 
$$1, 10, 11, 100, 101, 110, 111, \ldots$$
容易发现，这里与二进制十分相似，进行转换后，即可发现转换为后分别为
$$1, 2, 3, 4, 5, 6, 7, \ldots$$
的二进制。

有第 $N$ 项的 $k$ 进制表示就是其二进制表示。因此，我们按题意对 $k$ 进制的数进行处理即可。参考代码中也使用了**位运算优化**。

## 注意事项

- 要开 **long long**。

## 参考代码

```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;
hyh LL = long long;

int main()
{
	int n, k;
	cin >> n >> k;
	LL ans = 0, t = 1;
	while (k)
	{
		if (k & 1) ans += t;
		t *= n;
		k >>= 1;
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：GZXUEXUE (赞：3)

### 思路

观察到题目中包含「方幂」这个描述，考虑进制。看样例序列找规律，可得：

- 第 $1$ 项（三进制表示）：$000$；
- 第 $2$ 项（三进制表示）：$001$；
- 第 $3$ 项（三进制表示）：$010$；
- 第 $4$ 项（三进制表示）：$011$；
- $\dots$

可以发现第 $N$ 项的 $k$ 进制表示就是 $N$ 的二进制表示，最后把结果转换为十进制即可。

时间复杂度约为 $O(\log N)$。

### 实现

这里用了一点小优化，详见下方代码。

```cpp
# include <iostream>
using namespace std;
int main(){
	int k,n; cin >> k >> n;
	long long sum = 0,base = 1;
	for (int i = 0;i <= 10;i++){
		sum += ((n >> i) & 1) * base; // 用了位运算优化，表示N的二进制的第i位如果是1，则把答案加上k进制的第i位1的十进制表示，否则加0。
		base *= k;
	}cout << sum;
	return 0;
}
```

---

## 作者：Ngo123 (赞：3)

#### 本题要用进制转换和找规律

我们读完题目就会发现题目说的 当 $k = 3$ 时，数列分别是$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$

那么我们可以把这个数列通过三进制表示出来，数列即为

$1,10,11,100,101,110,111,…$ 

注意，以上数列 $k=3$ 

我们可以发现这些 $k$ 进制的数列在 $k$ 进制加表示的是数值，同样它们如果转化成二进制的话，就代表的是下标，那我们就只需要找到第 $N$ 个下标的 $k$ 进制数就可以了

那么我们可以找到规律，将第 $N$ 项的 $N$ 用对应的二进制表示，再将这个二进制数通过进制转换，转换成 $k$ 进制的数即可

本题代码

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int n,k;
LL ans,mul = 1;
int main()
{
    cin>>k>>n;
    while(n)
    {
        if(n & 1) ans += mul;
        mul *= k;
        n >>= 1;
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：superLouis (赞：2)

## 题解：P1062 [NOIP2006 普及组] 数列

这其实是一道数学题哟。

----------
### 1. 解题思路
我们就先以 $k = 3$ 为例，分析一下。题目中给了，说该序列实际上就是：$3^0, 3^1, 3^0 + 3^1, 3^2, 3^2 + 3^0, 3^2 + 3^1, 3^2 + 3^1 + 3^0, \dots$。我们仔细观察，发现 $3$ 的每个幂都是由取与不取组成的，不就是二进制的表示吗？

如果各位读者不信，请继续往下看表格：

|三进制|$1$|$10$|$11$|$100$|$101$|$110$|$111$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|十进制|$1$|$3$|$4$|$9$|$10$|$12$|$13$|

这里的三进制数其实就是二进制，但是按三进制计算。

所以，解题的思路就来了。我们先把 $n$ 换成二进制，然后再按照 $k$ 进制把二进制数算出来就是答案了。

举个例子，就拿样例说吧。
$$(100)_{10} = (1100100)_2\\$$
$$(1100100)_3 = (981)_{10}\\$$
所以答案就是 $981$ 了。

----------
### 2. 代码实现
思路懂了，代码其实挺简单的。  
**必须开 long long，会爆 int！**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int k, n, ans;
int pow(int x, int y) { 
	int res = 1;
	while (y--) res *= x;
	return res;
}
int trans(int x) {
	string s;
	while (x) s.push_back(x & 1), x >>= 1;
	int res = 0;
	for (int i = 0; i < s.size(); i++) res += s[i] ? pow(k, i) : 0;
	return res;
} 
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	cin >> k >> n;
	cout << trans(n) << "\n";
	return 0;
}
```
[通过记录](https://www.luogu.com.cn/record/198248543)

---

## 作者：zsq9 (赞：1)

[AC 记录](https://www.luogu.com.cn/record/198222397)

## 题目大意

给定一个正整数 $k$（$3\leq k\leq 15$），把所有 $k$ 的方幂及所有有限个互不相等的 $k$ 的方幂之和构成一个递增的序列。

请你求出这个序列的第 $N$ 项的值，用 $10$ 进制数表示。

## 思路

我们先观察，这题我们按照题目样例把所有的序列求出来，但发现不了什么，看这三进制，很容易想到二进制，把二进制与十进制来对比就可以发现，这个十进制与项数一样，这下就可以做了，先求出二进制，在转成十进制在打出第 $N$ 项就可以了。

![](https://img.z4a.net/images/2025/01/14/Untitled.png)

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,b,opzc,ans,ansn=1; 
int main(){
	cin>>a>>b;
	opzc=b;
	while(opzc!=0){
		if(opzc%2==1)ans+=ansn;
		ansn*=a;
		opzc/=2;
	} 
	cout<<ans;
return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

一道找规律。

对于答案，发现不用考虑底数，只需考虑次数。

对于这个数列的第 $n$ 项，我们把 $n$ 二进制分解，变成 $2^{a_1}+2^{a_2}+...+2^{a_x}$ 的形式（$a_i$ 是非负整数），答案就是 $k^{a_1}+k^{a_2}+...+k^{a_x}$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, k, ans;
int main () {
	cin >> k >> n;
	for (int i=9; i>=0; --i) 
		if (n>=(1<<i)) 
			ans+=pow(k, i),
			n-=(1<<i);
	cout << ans;
	return 0;
}
```

---

## 作者：tobie (赞：1)

分析一下样例

设f[i]表示数列中的第i个数：

f[1]=3^0;

f[2]=3^1;

f[3]=f[1]+f[2];

f[4]=3^2;

f[5]=f[1]+f[4];

f[6]=f[2]+f[4];

f[7]=f[3]+f[4];

···


------------
大家是不是发现了什么规律？~~AWA~~

如果log(i)是整数 f[i]=k^log(i);

否则f[i]=f[i-log(i)]+f[log(i)]
（注意log(i)要取整）

于是代码就可以舒服的打出来了:

~~这其实就是个模拟题嘛AWA~~
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long k,n,f[1001],p=2,cf,m=2,i;//不开long long会WA最后一个点
int main()
{
	cin>>k>>n;
	f[1]=1;
	f[2]=k;
	cf=4;//p=cf要特判
	for(p=3;p<=n;)
	{
		if(p==cf)
		{
			f[p]=pow(k,m);//k的m次方
			m++;
			cf*=2;//下一个特盘点
			p++;
		}
		else
		for(i=1;i<cf/2;i++)//从i一直枚举到cf-1处
		{
			if(p>n) break;
			f[p]=f[cf/2]+f[i];//公式
			p++;
		}
	}
	cout<<f[n]<<endl;
	return 0;
}
```

---

## 作者：chinazhanghaoxun (赞：1)

## 思路
题目已经提示的很明显了，由题意，将这列数转换为三进制数就是 $(1)_3,(10)_3,(11)_3,(100)_3,(101)_3\dots$。在写这串数的过程中就可以发现，这是一个依次递增的数列。当作二进制转成十进制，会发现正好是 $(1)_{10},(2)_{10},(3)_{10},(4)_{10},(5)_{10}\dots$。

所以，这道题的正解就出来了，就是把输入的 $N$ 转换为 $(N)_2$ 记为 $x$，再求出 $(x)_k$ 的十进制下的值即可。

于是，这道题就从数列题变成了进制转换题，然后就是考验基础了。
## 代码
其实转换进制并不难，主要是还要看数据，所以要开 long long。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10000],k,n;
int main(){
	long long i=0,len,s=0;
	cin>>k>>n;
	while(n!=0){ //转换为二进制
		a[i]=n%2;
		n/=2;
		i++;
	}
	len=i;
	for(int j=0;j<len;j++) //转换成k进制下的十进制
		s=s+a[j]*pow(k,j);
	cout<<s;
	return 0;
}
```

---

## 作者：New_Void (赞：1)

# [P1062 [NOIP2006 普及组] 数列](https://www.luogu.com.cn/problem/P1062)

### 思路

我们先观察一下题目给的数据，我们发现，当 $k$ 等于 $3$ 的时候，它的序列是：

$1，3，4，9，10，12，13，…$

这时候我把这个序列的每一个数都转换成了三进制，之后又转换成了十进制，发现序列变成了：

$1，2，3，4，5，6，7，…$

而题目给了 $n$ 和 $k$ ，所以我们可以把他进行逆着转一下，也就是把 $n$ 转换成二进制，在当成 $k$ 进制，转换成十进制，最后输出。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[1005];
long long s;
int main(){
    unsigned long long k,n;
    cin>>k>>n;
    int d=0;
    while (n){//先转换成二进制
        a[d]=n%2;
        d++;
        n/=2;
    }

    long long l=0;
    for (long long i=0;i<d;i++){
        if (a[i]==0){
            l+=1;
        }
        else{
            s+=(long long)pow(k,l);
            l+=1;
        }
    }
    cout<<s;
    return 0;
}

```

本篇题解与 https://www.luogu.com.cn/article/7itiwrxj 相似，思路差不多，但是代码不一样，所以讲解也差不多。

---

## 作者：jiqihang (赞：1)

考验进制转换。

样例是个好东西。

样例中 $k=3$，求出序列，然后转换成三进制，如表

|项数|1|2|3|4|5|6|7|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|十进制|1|3|4|9|10|12|13|
|三进制|1|10|11|100|101|110|111|

三进制好像二进制啊。

我们把他当二进制看，转化成十进制，就是

|项数|1|2|3|4|5|6|7|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|三进制|1|10|11|100|101|110|111|
|十进制|1|2|3|4|5|6|7|

第 $n$ 项对应的就是 $n$。

根据这个逆着做即可。

---

## 作者：Kawaii_qiuw (赞：1)

题面很好理解，不再赘述。

### 解题思路

这就像是一道规律题，先将十进制下的数列，转换为 $k$ 进制后，再将其当作二进制转换为十进制，会发现，第 $n$ 项就是 $n$。

比如题目例子：

$k \to 3$ 时，数列为：$1,3,4,9,10,12,13…$

转换成三进制：$1,10,11,100,101,110,111…$

将其当作二进制，转化成十进制：$1,2,3,4,5,6,7…$

可以发现，第 $n$ 项就是 $n$。

所以，现在知道 $k$ 和 $n$，就可以逆着来，先将 $n$ 转换为二进制，再把转换后的数当成 $k$ 进制下的数，再次转换为十进制。

同时，栈后进先出的性质刚好运用到这道题来，先把转换为二进制后的数，从后往前一个个边压入栈边右移，最后再边出栈边删除栈顶，把出栈的数转换为十进制数后累加起来。

### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <stack>
#include <cmath>

using namespace std;

typedef long long ll;
int main() {
	ios::sync_with_stdio(0);
	stack<int> s;
	ll n, k;
	cin >> k >> n;
	while (n) {
		s.push(n & 1);
		n >>= 1;
	}
	ll ans = 0;
	while(!s.empty()) {
		ans += s.top() * pow(k, s.size() - 1);
		s.pop();
	}
	cout << ans << endl;
	return 0;
}
```

完结撒花。

---

## 作者：sjh0626 (赞：0)

## 思路分析
我们不慌，根据样例和题目描述我们可以知道，这和二进制有着异曲同工之妙。

首先我们把 $100$ 转成二进制，为 $1100100$，再把它转为按位转三进制变成 $3^6+3^5+3^2=981$。

所以就是把十进制转成二进制，再按位转成 $k$ 进制。

但是注意，要开 `long long`。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
#define ll long long
using namespace std;
ll k,n,ans;
string s;
int main(){
	cin>>k>>n;
	while(n)s+=to_string(n%2),n/=2;
	for(int i=0;i<s.size();i++){
		if(s[i]=='1')ans+=round(pow(k,i));
	}
	cout<<ans;
	sjh0626s code;
}
```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P1062)

## 题目思路：
睁大眼睛仔细看样例，找找规律：

 $$(1)_3,(10)_3,(11)_3,(100)_3\dots$$
 
 转化为**二进制**发现等于：

 $$1,2,3,4,5,\dots$$

 于是将 $n$ 转为**二进制**后，再将 $(n)_k$ 转为**十进制**即可。

## 正解：
纯**模拟**，就不给了。

---

## 作者：god_std (赞：0)

当 $k=3$ 时，输出的数列为：
$$
1,3,4,9,10,12,13,\cdots
$$
也就是：
$$
3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,\cdots
$$
乍一看全是几个 $3^n$ 相加，化为三进制后就应该是一个只有 $0$ 和 $1$ 的数列，如下：
$$
001,010,011,100,101,110,111,\cdots
$$
化为二进制，就是奇妙的结果了：
$$
1,2,3,4,5,6,7,\cdots
$$
显然，第 $n$ 项就是 $n$ 了。

所以，将 $N$ 转化为二进制，在把这个数当作 $k$ 进制数转换回 $10$ 进制，即可得解（进制转换见 [B3619](https://www.luogu.com.cn/problem/B3619) 和 [B3620](https://www.luogu.com.cn/problem/B3620)）。

---

## 作者：liuhaoyan0323 (赞：0)

## 思路

以下定义操作 $[a]c \to [b]$ 表示将 $a$ 进制下的 $b$ 转为 $c$ 进制。

题目说了以十进制输出肯定有用。

题目给出了**集合 A**：$\{$ $3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$ $\}$。\
依照状压 DP 的思想，这个显然构成 $3$ 进制下的**集合 B**：$\{$ $1,10,11,100,101,110,111,…$ $\}$\
我们注意到这个 $3$ 进制数列的规律类似于“满二进一”，不妨把它就视为一个 $2$ 进制序列，转成 $10$ 进制便有了**集合 C**：$\{$ $1,2,3,4,5,6,7,…$ $\}$。

聪明的你一定发现了，**集合 C** 实质上是 $\mathbb{N_+}$，即 $C_i=i$。\
所以我们断言：**$A_i=[2]([10]i \to [2]) \to [3]$**。

我们反过来看题目，给出了下标 $i$，求对应的值 $A_i$ 便很简单了。

## 代码

```cpp
#include<bits/stdc+.h>
using namespace std;

long long k, n, ans;
stack<int> S;

int main() {
    cin >> k >> n;
    while(n) S.push(n & 1), n >>= 1;
    while(!S.empty()) ans += S.top() * pow(k, S.size()-1), S.pop();
    cout << ans << endl;
}
```

---

## 作者：Co_Ce (赞：0)

# solution
[传送门](https://www.luogu.com.cn/problem/P1062)
## 分析 
|序号|序列（十进制）|幂|序列（二进制）|
|-|-|-|-|
|$1$|$1$|$3^0$|$1$|
|$2$|$3$|$3^1$|$10$|
|$3$|$4$|$3^0+3^1$|$11$|
|$4$|$9$|$3^2$|$100$|
|$5$|$10$|$3^0+3^2$|$101$|

给定一个十进制，将其转换为二进制，遇到 $1$ 就将 $ans$ 加上 $k^{(i-1)}$（i为二进制数从右向左第几个数）。

## std：
```
#include<bits/stdc++.h>
#define maxn 1010
#define int long long

using namespace std;

int n,k,l,ans;

int a[maxn];

signed main(){
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>k>>n;
    while(1){
    	if(n==0){
    		break;
		}
    	a[++l]=n%2;
    	n/=2;
	}
	for(int i=1;i<=l;i++){
		if(a[i]==1){
			ans+=pow(k,i-1);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

观察 $3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$ 这个式子，不难发现其上标是 $0,1,…,k-1$，联想到 $k$ 进制，对其转换可得到 $(1)_3,(10)_3,(11)_3,(100)_3,…$，如果看成二进制就是 $1,2,3,4,…$，这样就找到了规律。

照着规律反过来做，先转换成二进制，再看成 $k$ 进制，重新转换为十进制。这道题就做完了。

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P1062)

# 思路

我们需要理解题目描述的数列生成规则：给定一个正整数 $k$，数列中的每一项都是由 $k$ 的次方及其有限个互不相等的次方之和构成的，这个数列是递增的。

我们可以将这个问题转化为二进制表示的问题。具体来说，数列中的每一项可以看作是 $k$ 的次方的线性组合，而这些次方的系数只能是 $0$ 或 $1$。因此，我们可以将数列的第 $n$ 项看作是 $n$ 的二进制表示中，每一位对应 $k$ 的次方的系数。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5;
ll k,n;
int main(){
    cin>>k>>n;
    ll ans=0,cnt=1;
    while(n>0){
        if(n&1)ans+=cnt;
        cnt*=k;
        n>>=1;
    }
    cout<<ans<<'\n';
	return 0;
}
```
**注意要开 long long 不然会 WA 最后一个点！**

[**AC 记录**](https://www.luogu.com.cn/record/198230764)

---

## 作者：zhuangjinning (赞：0)

根据样例还有题目中的提示，会发现这个序列用三进制表示就是：$1,10,11,100,101,110,111...$。

经过观察发现，这很像二进制，再一看，会发现这就是二进制的 $1,2,3,4,5,6,7...$。

所以，只要求出 $n$ 的二进制用 $k$ 进制的表示即可。

代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k;
int n;
int er[102];
int cnt;
int ans;
signed main(){
	cin>>k>>n;
	while(n){
		er[++cnt]=n%2;
		n/=2;
	}
	int quan=1;
	for(int i=1;i<=cnt;i++){
		ans+=quan*er[i];
		quan*=k;
	}
	cout<<ans;
	return 0;
}
```


这道题就这样完成了，完结撒花！

---

## 作者：AFO_Lzx (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P1062)

我们直接分析样例：

把所有数字全部转换成为 $3$ 进制。数列如下：

$$(1)_3,(10)_3,(11)_3,(100)_3\cdots$$

把它们当作二进制转成十进制，你会发现数列如下：

$$1,2,3,4,5,6\cdots$$

所以代码只需要将 $n$ 转换成一个二进制数 $x$，然后求出 $(x)_k$ 的十进制的值即可。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int k, n;
	cin >> k >> n;
	
	string s;
	int t = n;
	
	while (t) {
		char c = t % 2 + '0';
		s = c + s;
		t = t / 2;
	}
	
	int ans = 0;
	for (int i = 0; i < s.size(); i++) {
		ans += (s[i] - '0') * pow(k, s.size() - i - 1);
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Eason0324 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1062)

## 思路
仔细看这句话：

（该序列实际上就是：$3^0,3^1,3^1+3^0\dots$）


这不很明显吗？

由于是 $3$ 的幂次，转换成三进制：

$$1,10,11,100,101\dots$$

然后可以发现，这就是

$$1,2,3,4,5,\dots$$

的二进制。

题目要求 $k$ 进制，类比一下即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
long long nown=1;
long long ans;
int main(){
    cin>>n>>k;
    while(k>0){
        if(k%2==1) ans+=nown;
      	nown*=n;
        k/=2;
    }
    cout<<ans;
}
```

---


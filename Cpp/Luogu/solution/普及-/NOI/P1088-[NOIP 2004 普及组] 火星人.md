# [NOIP 2004 普及组] 火星人

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三位数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。

## 说明/提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题

## 样例 #1

### 输入

```
5
3
1 2 3 4 5
```

### 输出

```
1 2 4 5 3```

# 题解

## 作者：yummy (赞：550)

简单地逛了逛题解区，发现大部分题解分为两种：
- `next_permutation`
- 手写 `next_permutation`

于是，我为了不让题解区太单调，也为了拓宽大家的思维，就经过几分钟的努力，想出了一种与众不同的方法。

**Updated on 2022.7.14: 添加 $\LaTeX$，增加变进制数加法的讲解。**

> 变进制数

我们的目标是把全排列转化成一个变进制数，以方便我们进行加法。   
对于第 $i$ 根手指，它有 $n-i+1$ 种选择，根据位值原理，要想让每个数对应一个全排列，就要让这一位数是 $n-i+1$ 进制的。

那么，整个过程分为三步：
1. 将火星数变成变进制数
2. 将变进制数加上 $m$
3. 将变进制数变成火星数

我们来看一个实例：
将 $1,4,5,2,3$ 变成变进制数：
- 首位 $1$ 是 $5$ 种选择 $\{1,2,3,4,5\}$ 的第 $1$ 种，故变为 $0$（从0开始）
- 次位 $4$ 是 $4$ 种选择 $\{2,3,4,5\}$ 的第 $3$ 种，故变为 $2$
- 中间位 $5$ 是 $3$ 种选择 $\{2,3,5\}$ 的第 $3$ 种，故变为 $2$
- 次低位 $2$ 是 $2$ 种选择 $\{2,3\}$ 的第 $1$ 种，故变为 $0$
- 末位 $3$ 是 $1$ 种选择 $\{3\}$ 的第 $1$ 种，故变为 $0$
- 最后，排列 $1,4,5,2,3$ 变成了$(02200)_{unknown}$

接下来给它加上 $3$ 变成 $(02203)$，并处理进位：
- 末位是 $1$ 进制的，进 $3$ 得 $(02230)$。
- 次低位是 $2$ 进制的，满 $2$ 进一得 $(02310)$。
- 中间位是 $3$ 进制的，满 $3$ 进一得 $(03010)$。
- 次位是 $4$ 进制的，$3<4$，不进位，得 $(03010)_{unknown}$。

最后将 $(03010)_{unknown}$ 变回火星数。

- 首位 $0$ 表示这位应选择 $\{1,2,3,4,5\}$ 的第 $1$ 种，即 $1$
- 次位 $3$ 表示这位应选择 $\{2,3,4,5\}$ 的第 $4$ 种（$1$ 被选过了），即 $5$
- 中间位 $0$ 表示这位应选择 $\{2,3,4\}$ 的第 $1$ 种，即 $2$
- 次低位 $1$ 表示这位应选择 $\{3,4\}$ 的第 $2$ 种，即 $4$
- 末位 $0$ 表示这位应选择 $\{3\}$ 的第 $1$ 种，即 $3$

所以本题答案为 `14523` $+3=$ `15243`。

代码 $37$ 行，应该是除 STL 外较短的了。
```
#include<bits/stdc++.h>
using namespace std;
int a[10005];
bool used[10005]={0};
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int x=a[i];
        for(int j=1;j<=a[i];j++)
            x-=used[j];
        used[a[i]]=1;
        a[i]=x-1;
    }
    a[n]+=m;
    for(int i=n;i>0;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=a[i];j++)
            if(used[j])
                a[i]++;
        cout<<a[i]+1<<" ";
        used[a[i]]=1;
    }
    return 0;
}
```
---

这篇题解是我较早时候发的，通过评论区我纠正了举个栗子那个部分的小问题。   
现在我也通过评论区知道我这方法叫做康托展开。如果你想了解更多，可以看[这篇博客](https://www.luogu.org/blog/abc123-yummy/huoxingren).

---

## 作者：zhi_zhang (赞：101)

不知道有没有与我的想法相同的题解已经发布

但是我觉得这是最为直观易懂的方法

而且讲的也是直观易懂

按照人脑的思维去模拟增加的过程

下面是**模拟过程**：

**刚开始所有的数已经使用过**

**从最后一位开始**

**要判断当前的数位是否还有更高的未标记数可以使用**

**如果有，那就使用找到的数替换该位置的数，然后剩余未标记的数按照从小到大的顺序塞回去**

**如果没有，那就取消当前数位的标记，搜索上一数位**

_样例： 1 2 3 4 5，加3次_

_**第一次**_

_（5）数位为5，判断后发现此时已经没有更高的未标记数_

_5取消标记，搜索上一数位_

_（4）数位为4，当前有更高的5未被标记_

_（4）数位用5代替，4取消标记_

_剩下的（5）数位用仍未标记的4代替_

_第一次结束,得到 1 2 3 5 4_

_**第二次**_

_（5）数位的4和（4）数位的5取消标记_

_（3）数位的3用4代替，3取消标记_

_把3,5按从小到大顺序依次填入（4）（5）数位_

_第二次结束，得到 1 2 4 3 5_

_**第三次**_

_（5）数位5取消标记_

_（4）数位3用5代替，3取消标记_

_将3填入（5）数位_

_第三次结束，得到1 2 4 5 3_

**代码自带输出调试**

以下是代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
const int MAXN=10010;
int finger[MAXN];
int N,M;
int vis[MAXN];
int ad(int);
void prin();
int main()
{
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++)//输入 
	{
		vis[i]=1;
		scanf("%d",&finger[i]);
	}
	while(M--)//计算还剩多少步 
	{
		for(int i=N;i>=1;i--)//倒着进行判断 
		{
			int k=ad(finger[i]);
			if(k!=-1)//如果能够增加 
			{
				vis[finger[i]]=0;
//				printf("%d取消标记\n",finger[i]);
				finger[i]=k;//那么当前指头变为序号更大的指头
				vis[k]=1;
//				printf("(%d)处手指变为%d\n",i,k);
//				printf("%d标记\n",k);
				for(int j=i+1;j<=N;j++)//剩下的指头从小到大向后排序 
				{
					for(int p=1;p<=N;p++)//从小到大检索 
					{
						if(!vis[p])//如果p手指还没进入 
						{
//							printf("(%d)处手指变为%d\n",j,p);
							finger[j]=p;//该手指则为p 
							vis[p]=1;//p手指已进入 
//							printf("%d标记\n",p);
							break;
						}
					}
				}
//				prin();
				break;
			}
			else//如果不能增加 
			{
				vis[finger[i]]=0;//该手指退出，然后搜索下一个手指 
//				printf("%d取消标记\n",finger[i]);
			}
		}
	}
	prin();
	return 0;
}
int ad(int poi)//检索该手指 
{
	for(int i=poi+1;i<=N;i++)//向上搜索直到 
	{
		if(!vis[i])//搜索到还未入队的更大的数 
		{
			return i;//返回该数 
		}
	}
	return -1;//检索不到则返回-1
}
void prin()
{
	for(int i=1;i<=N;i++)
	{
		printf("%d ",finger[i]);
	}
	printf("\n");
}
```

**因为题目上说了是加了一个很小的数，所以不会因为模拟次数过多超时**

---

## 作者：Believe_R_ (赞：81)


## 此题是一道练全排列函数的好题！
传送门：[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

至于什么是全排列函数，我们先来看一道**模板题**：[P1706 全排列问题](https://www.luogu.org/problemnew/show/P1706)

**一句话题意**：输出 $n$ 的全排列。

```cpp
样例输入：
	3
样例输出：
	1	2	3
    1	3	2
    2	1	3
    2	3	1
    3	1	2
    3	2	1
```

看看自己2年前写的代码，用**递归**来做（不得不承认，这是一道递归的好题），下面贴上递归代码（初学者都会写）！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,k;
int a[10]={0},bj[10]={0};
void dfs(int x)
{
    int i,j;
    if(x==n+1)
    {
        for(i=1;i<=n;++i)
        printf("%5d",a[i]);
        cout<<endl; 
    }
    else
      for(i=1;i<=n;++i)
        if(bj[i]==0)
        {
            a[x]=i; bj[i]=1;
            dfs(x+1);
            a[x]=0; bj[i]=0;
        }
}
int main()
{
    cin>>n;
    dfs(1);
    return 0;
}
```



然而到今天，我突然翻出这道题，发现这道题不就是**全排列函数的模板题**吗？下面就请我们今天的主角上场：

$$
 \Large \texttt{next \_ permutation}
$$

这个函数每运行一次就可以排列出下一个全排列的序列 （**<algorithm>** 中有许多好用的函数）。

用法即是 next_permutation(数组开头，数组结尾)  【和 sort 用法差不多】

伪代码如下：

```cpp
#include <algorithm>
// #include <bits/stdc++.h>    //用这个我也没意见

int a[1000];
int n;
int main()
{
    令a[i]=i;
    int tot=n所有全排列的数量;
    for i=1 to tot
    {
        next_permutation(a+1,a+n+1);  //因为我 a 数组是从下标1开始存的
    }
    return 0;
}
```

那现在还有一个问题：$tot$ 怎么求呢？

这就涉及到排列组合的问题了。

全排列的数量即是 $A_n^n = n !$ （不懂的话可以自己去学习一下）

那么每次运行这个函数之前，输出数组 $a$ 的值即可！

**下面贴上c++代码 （维护社会和平，请勿抄袭代码！！！）** 

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[100];
int main()
{
    scanf("%d",&n);
    int tot=1;
    for(int i=1;i<=n;++i)
    {
        a[i]=i;
        tot*=i;
    }
    for(int i=1;i<=tot;++i)
    {
        for(int j=1;j<=n;++j) printf("    %d",a[j]);    //输出格式注意
        next_permutation(a+1,a+n+1);
        printf("\n");
    }
    return 0;
}
```



### 这道模板题做了后，再回来看这道题目吧：


传送门：[P1088 火星人](https://www.luogu.org/problemnew/show/P1088)

题目看过了，自己可以先想一下………………

别看这是一道**普及组T4** 的题目，但是我觉得它连 **T2** 的难度都没有 ~~（只要你掌握了这个函数）~~

**一句话题意： 求出一个给定长度的序列经过 $m$ 次全排列变化后的序列。**

甚至比上一题还简单，改变的次数都跟你说了~  \^~^   ~

**下面贴上c++代码 （维护社会和平，请勿抄袭代码！！！）** 

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100000];
int n,m;
inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=re*10+(ch-'0'); ch=getchar();}
    return re*f;
}
int main()
{
    n=read(); m=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=m;++i) next_permutation(a+1,a+n+1);
    for(int i=1;i<=n;++i) printf("%d ",a[i]);
    return 0;
}
//简单吧~
```



---

## 作者：Forever丶CIL (赞：32)

这个题就是一个部分的全排列，如果用 next\_permutation(a,a+n);

这种stl函数水过去就太没意思了，也练不了自己的代码能力

不如试着写一下全排列，当然全部全排列肯定会TLE的

我们可以从当前排列（就是火星人手指表示的那个排列）开始，做m次排列，

即找按顺序排列的全排列中，排在当前序列之后m个的那个序列

其实也差不多就是手动做一下 next\_permutation(a,a+n);做的工作

解释留到代码中

qaq


------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,m,tot=1;
int vis[10101];
int sl[10101];
int f[10101];
void print()//输出函数 
{
    for(int i=1;i<=n;i++)
    {
        printf("%d ",sl[i]);
    }
    printf("\n");
}
void dfs(int cur)//从当前数列开始全排 
{
    if(cur==n+1)
    {
        m--;
        //return ;
    }
    if(m==-1)
    {
        print();
        return ;
    }
    else for(int i=(f[cur]?1:sl[cur]);i<=n;i++)//这一步做的工作是将现在的dfs迅速递归到找到最初序列的状态 
    {
        if(!vis[i])//基本的全排列 
        {
            sl[cur]=i;
            vis[i]=1;
            dfs(cur+1);
            if(m==-1) return ;
            vis[i]=0;
        }
    }
    f[cur]=1;
    return ;
}
int main()
{
    /*scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
    }*/
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
        //vis[i]=1;
    }
    dfs(1);
    return 0;
}
```


------------

可能大家不是很懂dfs中的那个for 其实想一想，我们在求全排列的时候
是递归求的，我们每求得一中全排列，它背后是有一个递归层的

所以当我们想从任意一种排列开始求它后面的排列时，就需要先把

它的这个递归层先建立起来，然后顺着继续递归就好了

qaq rp++




---

## 作者：Matoi (赞：28)

# Pascal题解

- 这题我并没有用数学模型，而是找规律

#### 规律如下

- 找一个尽量靠后的数（m），使其后为一个连续下降序列（只含一个数也行）。并交换该数与其后序列中最小的但比该数大的数

- 交换这个序列中第a大与第a小的数(1<=a<=序列长div 2)

### 以1 2 3 4 5 为例

1. m=4，4与5交换，变为1 2 3 5 4。序列为4，长为1，不交换。

1. m=3，3与4交换，变为1 2 4 5 3。序列为5 3，交换后为1 2 4 3 5。

1. m=3,3与5交换，变为1 2 4 5 3。序列为3，长为1，不交换。

1. 输出1 2 4 5 3。

------------

#### 加上m即为重复m次

------------



    
    
```cpp
    var m,n,i,j,k,l,min,count:longint;
        a:array[0..10000]of longint;
    procedure swap(u,v:longint);//交换a[u]与a[v]的过程
    var t:longint;
    begin
      t:=a[u];
      a[u]:=a[v];
      a[v]:=t ;
    end;
    begin
      fillchar(a,sizeof(a),0);//不赋初值可能会错
      readln(n);
      readln(m);
      for i:=1 to n do read(a[i]);//读入各数据
      for i:=1 to m do//相当于加上m
        begin
          k:=n; //k指针从后向前找
          while a[k]<a[k-1] do dec(k);//因为该序列尾在最后一个数处，且连续。若加上前一个数条件仍成立，则将该数纳入序列。a[k-1]即为m。
          min:=maxint; //初始化min，使其在之后定能被赋一个值
          for j:=k to n do 
          if (a[j]<min)and(a[j]>a[k-1]) then//寻找大于m的最小数
            begin
              min:=a[j];//记录最小值
              count:=j;//记录最小值的位置
            end;
          swap(k-1,count);//规律1，交换m与序列中最小的但比m大的数
          for j:=k to (k+n)div 2 do//j即为a
            swap(j,n+k-j);//规律2，前后交换
        end;
      for i:=1 to n do
        write(a[i],' ');//输出结果
    end.

```

---

## 作者：Lynkcat (赞：19)

这是个来自P党的垃圾题解！

看到这道题目，你脑子里第一个冒出来的词语是什么？

全排列！！！

那么怎样求全排列呢？

又第一个想到DFS！！！

一看手指位数是10000，想必不少蒟蒻都会放弃这个念头。

但是关键点不在这儿，

**在于加上的位数！！！**

再看n<=100，

加上剪枝，放心大胆的去做吧！！！
```pascal
var h,i,p,n,t,ans:longint;b,e:array[0..10000]of longint;c,f:array[1..10000]of boolean;sub:boolean;
procedure dfs(k:longint);
var j,y:longint;
begin
  if k>n then
  begin
    dec(t);
    exit;
  end;//如果产生完毕则退出
  if t=0 then begin write(b[1]);for i:=2 to n do write(' ',b[i]);halt;end;//若已经找到则输出再退出程序
  if f[k] then y:=1 else y:=e[k];//这里是重点，剪枝的一个重要环节！！！
  for j:=y to n do
    if c[j]=false then
    begin
      b[k]:=j;
      c[j]:=true;
      dfs(k+1);
      if t=0 then begin write(b[1]);for i:=2 to n do write(' ',b[i]);halt;end;
      c[j]:=false;//别忘记回溯
    end;
  f[k]:=true;//设此层已访问
end;
begin
  readln(n);
  read(t);inc(t);
  for i:=1 to n do
    read(e[i]);
  dfs(1);//开始深搜
end.

```


---

## 作者：noiiloveyou (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P1088)

很明显，这题考查全排列。但是，用朴素的 DFS 算法做，时间复杂度为 $O(n!)$，只能得 30 分，因此要进行优化。

先来复习一下全排列的核心代码。

```cpp
for(int i=1;i<=n;++i){
    if(!vis[i]){
        vis[i]=1;
        f[k]=i;
        dfs(k+1);
        vis[i]=0;
    }
}
```

这道题要求加上一个数字，所以并不需要枚举比原数小的数字，对吗？

```cpp
for(int i=a[k];i<=n;++i){
    if(!vis[i]){
        vis[i]=1;
        f[k]=i;
        dfs(k+1);
        vis[i]=0;
    }
}
```

不对！例如，1 2 3 5 4 的下一个排列是 1 2 4 3 5，而上面的代码产生 1 2 4 后就卡壳了。因此，只有第一次遍历时能从原数开始，其余的就得从一开始。

还有一个小问题：最初火星人手指的排列顺序也会被计算。那么，我们在判断程序是否结束时，就要使用 `if(sum==m+1)` 而不是 `if(sum==m)`。

分析完毕！看看代码吧：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10005],f[10005],sum=0;
bitset<10005> vis;//相当于 bool vis[10005]，但前者更省空间。
void dfs(int k){
    if(k==n+1){//如果遍历完毕一个排列
        ++sum;
        if(sum==m+1){
            for(int i=1;i<=n;++i){
                cout<<f[i]<<' ';
            }
            exit(0);//直接退出程序
        }
        return;
    }
    if(sum==0){//如果是第一次遍历
        for(int i=a[k];i<=n;++i){
            if(!vis[i]){
                vis[i]=1;
                f[k]=i;
                dfs(k+1);
                vis[i]=0;
            }
        }
    }
    else{
        for(int i=1;i<=n;++i){
            if(!vis[i]){
                vis[i]=1;
                f[k]=i;
                dfs(k+1);
                vis[i]=0;
            }
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;++i){
        cin>>a[i];
    }
    dfs(1);
    return 0;
}

```

---

## 作者：mcturtle (赞：8)

## 思路
很简单，不过我们要使用一种 `STL` 函数：`next_permutation`。

> 将当前排列更改为 **全排列中的下一个排列**。如果当前排列已经是 **全排列中的最后一个排列**（元素完全从大到小排列），函数返回 `false` 并将排列更改为 **全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 `true`。

此时，题意简化为：求出一个长度为 $n$ 的序列经过 $m$ 次全排列变化后的序列。

这就很简单了，直接模拟就行，注意分辨 $n$ 和 $m$。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;
int a[N], n, m;
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++)
    {
        next_permutation(a + 1, a + 1 + n);
    }
    for (int i = 1; i <= n; i++)
    {
        printf("%d ", a[i]);
    }
    return 0;
}
```

---

## 作者：int_inf (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P1088) ＆ [AC记录](https://www.luogu.com.cn/record/191123497)
# Pre
前置问题：[P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)
# Solution
这道题的核心题意读下来，其实就是让我们去枚举第 $m$ 个全排列。对于部分不想写 DFS 的同学来说，算法头文件中的 `next_permutation()` 就是一个不错的选择。

`next_permutation()` 函数的原型为 

```cpp
bool next_permautation(iterator start, iterator end);
```
怎么样，是不是有点眼熟？没错，它和同样属于 `<algorithm>` 库的 `sort` 函数十分相似。其中 `start` 是指起始位置， `end` 是指结束位置。有了这个挂，我们便可以轻松写出以下代码。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],n,m;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	while(m--)
	{
		next_permutation(a+1,a+n+1);//枚举到第 m 个全排列 
	}
	for(int i=1;i<=n;i++)
	{
		cout<<a[i]<<" ";//输出第 m 个全排列 
	}
    return 0;//下次再见 
}
```
事已至此，不如留下赞和关注，后会有期。

---

## 作者：Fake_Cry (赞：4)

# 题解：[P1088 [NOIP 2004 普及组] 火星人](https://www.luogu.com.cn/problem/P1088)
## 讲解&前置知识
主要的思路就是用**全排列**解决。\
可以直接调用函数，下面是模版题示例。


---


### 全排列问题
```cpp
#include<bits/stdc++.h>

using namespace std;
const int N = 1e2 + 10;
int main()
{
    vector<int> v;
    int n;
    cin >> n;
    for (int i = 1;i <= n;i++) v.push_back(i);
    do {
        for (int i = 0;i < v.size();i++) cout<<v[i]<<' ';
        cout << endl;
    }while (next_permutation(v.begin(), v.end()));//找到数组的下一个排列
    return 0;
}
```
上面的代码，每一行的输出就是数组的一个排列。具体的效果可以粘出来自己看。\
全排列函数的用法就是：`next_permutation(数组开头，数组结尾)`。


---


那么我们再回归这道题，学会了全排列函数，也就很简单了。
## 放上核心代码

```cpp
for(int i=1;i<=m;i++){//直接用题目中给出的次数
	next_permutation(a+1,a+1+n);//调用全排列函数
}
for(int i=1;i<=n;i++){
	cout<<a[i]<<" ";
}
```

---

## 作者：King_and_Grey (赞：3)

# [P1088 [NOIP 2004 普及组] 火星人](https://www.luogu.com.cn/problem/P1088)

本题解适合新手学习全排列。

Q：什么是全排列？    
A：从 $n$ 个不同元素中任取 $m(m \le n)$ 个元素，按照一定的顺序排列起来，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个排列。当 $m = n$ 时所有的排列情况叫全排列。

我们先来看[P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)的代码。

思路如下：
1. 查看当前点是否用过。
2. 如果没有，赋值，标记，搜下一个。如果搜完了，输出。
3. 回溯清零。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,num[15];
bool used[15];
void print(){
	for(int i = 1;i <= n;i++){
		cout << setw(5) << num[i];
	}
	cout << endl;
}
void dfs(int i){
	for(int j = 1;j <= n;j++){
		if (!used[j]){           // 如果这个点没有使用过。
			num[i] = j;          //先赋值。
			used[j] = true;      //将此点标记为访问过。
			if (i == n){         //正好全排列完。
				print();         //输出。
			}else{
				dfs(i + 1);      //继续下一个点。
			}
			num[i] = 0;          //回溯。
			used[j] = false; 
		} 
	}
} 
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n;
	dfs(1);
	return 0;
} 
```

和这题不同的是，我们只需要全排列 $m$ 次就行了。

先介绍一个 STL 函数：`next_permutation`，使用方法很简单，第一个参数是需要开始全排列的数组下标，第二个参数是需要结束全排列的数组下标。可以搭配 `do_while` 循环。也可以直接 `for` 循环或者 `while` 循环。


代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e4 + 5;
int n,m,num[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i++){
		cin >> num[i]; 		
	}
	for(int i = 1;i <= m;i++){
		next_permutation(num + 1,num + n + 1);
	}
	for(int i = 1;i <= n;i++){
		cout << num[i] << " ";
	}
	cout << "\n";
	return 0;
}
```

[提交记录。](https://www.luogu.com.cn/record/205665526)

求过。

---

## 作者：e_zhe (赞：2)

### 分析

可以发现手指数目为 $N$ 的火星人的手指排列顺序是 $N$ 的一个排列，其表示的数是该排列在 $N$ 的全排列中的字典序排名。

那么问题就转化为求 $N$ 的全排列中字典序排名比当前大 $M$ 的那个。

STL 中提供了函数 `next_permutation`，可以在 $O(N)$ 的时间复杂度内求出给定序列的下一个字典序排列。

那么对火星人手指的排列顺序进行 $M$ 次 `next_permutation` 即可。

时间复杂度 $O(NM)$，可以通过本题。

### Code

```cpp
#include<bits/stdc++.h>
#define i64 long long

using namespace std;

constexpr int N=10005;
int n,m,a[N];

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;++i)cin>>a[i];

    for(int _=1;_<=m;++_)next_permutation(a+1,a+n+1);

    for(int i=1;i<=n;++i)cout<<a[i]<<' ';
    return 0;
}
```

---

## 作者：wangyanxiang2013 (赞：2)

这道题我们可以用```next_permutation```函数解决，它能够返回当前序列的下一个排列，我们可以用一个变量 $t$ 来统计这是第几个排列了，如果 $t$ 与 $m$ 相等就将当前排列输出并结束程序。

上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
	int n,m;
	cin>>n>>m;
	int a[n+4];
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int t=0;
	do{
		if(t==m){
			for(int i=1;i<=n;i++)cout<<a[i]<<" ";
			cout<<endl;
			return 0;
		}++t;
	}while(next_permutation(a+1,a+n+1));
	return 0;
}
```

---

## 作者：sieve (赞：1)

### 题解：[P1088 [NOIP 2004 普及组] 火星人](https://www.luogu.com.cn/problem/P1088)

### 思路

题意就是给定 $n$ 个数，然后求后面的第 $m$ 个全排列。

使用 STL 中的 `next_permutation` 不断生成下一个全排列（生成 $m$ 次）即可。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000005];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
	}
	for(int i=1;i<=m;++i)
	{
		next_permutation(a+1,a+n+1);
	}
	for(int i=1;i<=n;++i) cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：getchar_unlocked (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1088)

### 思路

改变手指顺序的过程其实就是在做全排列，故给序列做 $M$ 次全排列即可。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e4+10;
int a[N];
int main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	while(m--)
		next_permutation(a+1,a+n+1);
	for(int i=1;i<=n;++i)
		printf("%d ",a[i]);
	printf("\n");
	return 0;
}
```

---

## 作者：long_long_inf (赞：1)

# 思路

这一题的思路十分简洁明了，我们只要枚举出下面的第 $m$ 个全排列方式即可。

毫无疑问，递归是可以轻轻松松的过了这题的，但是因为~~我太懒~~代码有些长，于是用了一种非常简单的方法。

在这里向大家介绍一个函数：next_permutation。
它可以生成全排列，这使得我们的代码可以变短很多。
于是我们只要生成 $m$ 次即可。

# 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[10005];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int cur = 0;
    do
    {
        cur++;
    } while(next_permutation(a + 1, a + n + 1) && cur != m);
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
    return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

这个计数方式正是生成全排列，答案就是在给定序列的基础上再生成 $m$ 次全排列。

对于生成全排列，我们可以使用 ```next_permutation```。这个函数就是将当前排列更改为全排列中的下一个排列。如果当前排列已经是全排列中的最后一个排列，即元素完全从大到小排列，函数返回 ```false```，并将排列更改为全排列中的第一个排列，即元素完全从小到大排列；否则函数返回 ```true```。用法类似 ```sort```：```next_permutation(序列开头, 序列结尾)```。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[10005];
int main () {
	cin >> n >> m;
	for (int i=0; i<n; cin >> a[i++]) ;
	while (m--) next_permutation(a, a+n);
	for (int i=0; i<n; cout << a[i++] << ' ') ;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
这题我们要用[全排列](https://blog.csdn.net/howardemily/article/details/68064377)来做，直接调用 ```next_permutation```函数，进行排序，就能省掉很多步骤了。

---
### code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10001], n, m;

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	while (m--) next_permutation(a + 1, a + n + 1); 
	for (int i = 1; i <= n; i++) printf("%d ", a[i]);
	return 0;
}
```

---

## 作者：return_second (赞：0)

很简单的一道全排列。

# 前置知识

这里先介绍一下 `next_permutation` 和 `perv_permutation`。

前者的作用是把当前数列改成下一个全排列，如果下一个全排列有则返回 `true`，不然就返回 `false`。后者与前者的不同之处在于改成的是上一个全排列。

# 思路

有了两个函数就简单多了，直接做 $m$ 次 `next_permutation` 就行了。

给出代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m;
int a[10005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
		next_permutation(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		printf("%d ",a[i]);
	return 0;
}

```

---

## 作者：dmc0702 (赞：0)

# 题解：P1088 \[NOIP 2004 普及组] 火星人

## 题目简述

火星人有编号为 $1,2,3,\cdots,n$ 的手指，这些手指可以组成 $1 \sim N$ 个大小互不相同的数，形成一个序列。这些序列按字典序从小到大排序。你需要做的是：求出比给出序列大的所有序列中第 $m$ 小的序列。

## 分析

不难发现，火星人的手指编号不重复，那么每一个序列都是一个排列。而序列字典序从小到大的顺序就是 C++ 中 `next_permutation` 中的排列顺序。因此，我们只需要用 `next_permutation` 函数重复 $m$ 次，就可以求出比给出序列大的所有序列中第 $m$ 小的序列了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
int main(){
	int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];//input
    for(int i=1;i<=m;i++)next_permutation(a+1,a+n+1);//求出比给出序列大的所有序列中第 m 小的序列
    for(int i=1;i<=n;i++)cout<<a[i]<<" ";//output
    return 0;
}
```

---


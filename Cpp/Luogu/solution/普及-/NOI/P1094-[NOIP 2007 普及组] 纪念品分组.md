# [NOIP 2007 普及组] 纪念品分组

## 题目背景

NOIP2007 普及组 T2

## 题目描述

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。

你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。


## 说明/提示

$50\%$ 的数据满足：$1\le n\le15$。

$100\%$ 的数据满足：$1\le n\le3\times10^4$，$80\le w\le200$，$5 \le  P_i  \le  w$。

## 样例 #1

### 输入

```
100 
9 
90 
20 
20 
30 
50 
60 
70 
80 
90
```

### 输出

```
6
```

# 题解

## 作者：heidoudou (赞：985)

> 贪心算法并不难，难的是证明。
         --- 杨科洛夫斯基(heidoudou)


贪心算法：先对数组从小到大排序，用 `i = 1, j = n` 指针指向首尾元素； 如果 $a_i + a_j > w$ ，则将 $a_j$ 单独作为一组，指针`j--` ；如果 $a_i + a_j \leq w$， 则将 $a_i$ 和 $a_j$ 分为一组， 指针 `i--, j--`。 如此重复直到 “取完” 所有元素。

贪心算法证明： 对于 `a[i...j]` 问题，如果存在最优解 $S$，但是 $a_i$ 和 $a_j$ 的分组不符合上述贪心选择过程。会有以下几种情况：

1. 如果 $a_i + a_j > w$，$a_j$ 也不可能与其他任何 $a_k$， $i < k < j$ 一组。 $a_j$ 只能单独一组。这是符合贪心选择性质的。
2. 如果 $a_i + a_j \leq w$， 在最优解中，$a_j$ 并不与 $a_i$ 一组，
    1. $a_j$ 单独一组，这时候如果最优解的 $a_i$ 仍然孤单， 那么将他俩合为一组，最优解的分组数减一，居然优于最优解，矛盾。
    2. $a_j$ 单独一组， $a_i$ 与另一个 $a_k$ 一组，这时候，将 $a_i$ 从 $a_k$ 身边拆开，再与 $a_j$ 一组，所得分组数不变，新的解 $S' = S$，$a_i$ 和 $a_j$ 一组是符合贪心选择性质的，贪心选择可以得到最优解。
    3. $a_j$ 与 $a_k$ 一组，$a_i$ 单独一组，交换 $a_i$ 和 $a_k$， 不难看出 $S' = S$
    4. $a_j$ 与 $a_k$ 一组， $a_i$ 与 $a_m$ 一组，交换 $a_k$ 与 $a_i$ 之后， $a_i + a_j \leq w$，  $a_k + a_m \leq a_k + a_j \leq w$，  $S' = S$，

至此，我们证明了问题的某个最优解可以通过上述贪心选择过程得到。

下面证明 贪心选择加子问题的最优解 为全局最优解。

设有 `a[i...j]`问题（记为 $P$）的贪心解为 $S$， 经过贪心选择之后 子问题 $P'$ 的最优解为 $S'$。 如果贪心选择加子问题 的最优解$S'$ 不是 $P$ 的最优解。 假设存在一个最优解 $Z$， 可以通过上面的证明过程，改变解的结构，使之变成一个贪心选择和相同子问题 $P'$ 的解 $Z'$。 因为 $S > Z$，并且二者贪心选择所产生的分组数是相同的，所以 $S' > Z'$， 这与 $S'$ 是最优解矛盾。所以贪心选择加子问题的最优解 为全局最优解。

证毕。


写的啰嗦了一点， 但是读懂这些证明以及为什么这样证明对理解贪心算法大有裨益。

光知道贪心，贪心为什么可以得到最优解，你证明过么？




---

## 作者：违规用户名3(kd,e$A (赞：104)

哈喽，大家好，我又来了（虽然你可能不认识我），但我还是要把我的开场白说一说，好啦，言归正传。 今天，我来给大家讲一讲纪念品分组这道题.

这道题的意思是：乐乐要将每个礼物平均的分发给小朋友，为了能让小朋友们得到差不多的礼物（不然会对他们小小的心灵造成伤害），所以他要对礼物进行分组，但每组只能弄2个纪念品，而且礼物还要有价钱的限制，不能超过总钱数，~~不能买法拉利~~，不然其他组就没钱了，然后乐乐希望分组分的少一点而且符合题目要求，然后输出

# 最小的一组

都懂了吧，我来解释程序

首先，定义一个万能头，然后定义一个W,N(分别储存钱数的上限，和输入总共数量，然后定义一个储存答案的变量，在定义一个数组，用来储存对应纪念品的价格，然后，在定义一个L和R，分别用来储存左标点和右标点，和一个FOR里的I变量)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int W,ans=0;
int n,a[30001];
int l,r,i;
```
下面解释主程序部分，首先读入每组纪念品价格之和的上上限和购来的纪念品的总件数，然后读入对应纪念品的价格，然后，因为要让选择均匀，所以要用SORT，然后，这道题有二分的算法，所以用L R分别来储存左右端点，然后，二分程序开始了，首先，大家都知道的是，二分枚举时，左端点必须小于右端点才能枚举，程序里面的部分，首先，假如最左加最右小于等于钱数的话，左端点加加，右端点减减，然后方案数加加，（因为我们已经排序，所以左加右等于最好的方案，不用再判断啦）。如果，已经大于钱数了。那么右端点就要往前移，但方案数仍让要加加，最后输出答案，结束。

```cpp
int main()
{
    scanf("%d%d",&W,&n);
    for(i=1;i<=n;i++)
      scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    l=1;  r=n;
    while(l<=r)
    {
        if(a[l]+a[r]<=W)   
          l++,r--,ans++;
        else
          r--,ans++;  
    }
    printf("%d",ans);
    return 0;
}
```
下面展示全部程序，不再解释，望见谅

```cpp
#include<bits/stdc++.h>
using namespace std;
int W,ans=0;
int n,a[30001];
int l,r,i;
int main()
{
    scanf("%d%d",&W,&n);
    for(i=1;i<=n;i++)
      scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    l=1;  r=n;
    while(l<=r)
    {
        if(a[l]+a[r]<=W)   
          l++,r--,ans++;
        else
          r--,ans++;  
    }
    printf("%d",ans);
    return 0;
}
```
拜拜，下次再见，点点赞

---

## 作者：ikunTLE (赞：19)

[题目传送门](https://www.luogu.com.cn/problem/P1094)

### 思路

可以使用**双指针**解决此题。

分组可以改变纪念品的顺序，于是先将所有物品按升序排序。因为想让答案尽可能小，最好情况是一个小的纪念品匹配一个大的纪念品。

于是令 $l$ 从 $1$ 向右遍历，$r$ 从 $n$ 向左遍历。若 $P_l+P_r\le w$，说明编号为 $l$ 和 $r$ 的两个纪念品可以组成一组，就让 $l\gets l+1$，$r\gets r-1$。否则说明 $P_r$ 较大，只能单独一组，就让 $r\gets r-1$。无论哪种情况，都会成为新的分组，就让答案加 $1$。当 $l>r$ 时需要终止循环。最终输出答案即可。

由于 $l$ 和 $r$ 都会向着自己的方向遍历而不后退，故时间复杂度为 $\mathcal{O}(n\log n)$（排序），可以通过此题。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=3e4+10;
int a[N];
int main(){
	int w=read(),n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	sort(a+1,a+n+1);
	int l=1,r=n,ans=0;
	while(l<=r){
		if(a[l]+a[r]<=w)
			++l;
		--r,++ans;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ryf2011 (赞：10)

# 题目思路
运用贪心算法。我们先将数据进行排序，然后维护两个变量 $x$ 和 $y$，让 $x$ 指向开头，让 $y$ 指向结尾。

一直循环，过程中会出现两种情况。

1. 如果当前两个变量所指的两个数之和小于或等于 $w$，说明可行，就把它们两个分为一组，同时将 $x$ 加 $1$，将 $y$ 减 $1$，并将答案加 $1$，这是第一种情况。

2. 如果当前两个变量所指的两个数之和大于 $w$，说明不可行，只将 $y$ 减 $1$，同时答案加 $1$ 即可，这是第二种情况。

重复以上过程，直到 $x > y$ 时停止循环。

最后输出答案即可。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int p[30005],w,n,ans,x,y;
int main(){
	//输入 
	scanf("%d",&w);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&p[i]);
	}
	sort(p+1,p+n+1); //排序 
	x=1,y=n; //分别指向开头和结尾 
	while(x<=y){ //依次判断能否分组，直到 x>y 时停止 
		if(p[x]+p[y]<=w){
			ans++;
			//缩小范围 
			x++;
			y--;
		}
		else{
			y--; //缩小范围 
			ans++;
		}
	}
	printf("%d\n",ans); //输出 
	return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：WsW_ (赞：7)

### 思路
每一个纪念品都必须在一个组中。假设我们现在想给 $P_i$ 分组，那么我们一定是找最大的 $P_j$ 满足 $P_i+P_j\le w$。  
如果不是找的最大的 $P_j$，那么就会导致剩下的纪念品中有一个较小的被换成了较大的，一定不优。  
按照这个思路贪心即可，找最大的 $P_j$ 可以利用二分、平衡树、双指针等算法维护。  

时间复杂度为 $O(n\log n)$，瓶颈在于排序。  

---
### 代码
以下代码使用双指针维护。
```cpp
#include<bits/stdc++.h>
using namespace std;
int w,n,i,j,sum;
int p[30004];
int main(){
	scanf("%d%d",&w,&n);
	i=1,j=n;
	for(int i=1;i<=n;i++)scanf("%d",&p[i]);
	sort(p+1,p+1+n);
	while(i<=j){
		if(p[j]>w||p[i]>w||(p[i]+p[j])>w){
			sum++;
			j--;
			continue;
		}
		sum++;
		i++;
		j--;
	}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：Actinoi (赞：7)

### 为获取最佳阅读效果，欢迎访问[Actinoi's blog : NOIP2007 普及组](https://www.actinoi.com/2019/07/22/noip2007%20普及组/)
​&emsp;​本题是一道典型的贪心问题。我们在读入物品的价格之后，对物品的价格进行排序。然后从价格最小的物品开始枚举，从价值最大的物品反向查看能否与这个物品分为一组。为什么要从价格最大的物品开始进行查看，而不是从价格最小的物品开始呢？我们可以举一个~~栗子~~。如：

​&emsp;​$10,20,30,40,50$

​&emsp;​我们看这个数组，当 $w=60$ 时，在满足每组最多只能包括两件纪念品的要求下，如果从最小的物品开始配对，那么就需要分 $4$ 组，这明显不是最优的。但是，从价格最大的物品开始配对时，仅需要 $3$ 组就能满足要求。这便是最优的方案。

​&emsp;​最后，我们再扫一遍这个数组，如果有物品没有被分组，那么就只能让这个物品单独一组了。所以说答案 $ans$ 就等于已经分的组数 $+$ 没有被分组的物品的数量。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int things[30001];
bool vis[30001]; //存储这个纪念品是不是已经被选了
int main() {
    int w, n; //w表每组纪念品价格之和的上上限，n表购来的纪念品的总件数
    cin >> w >> n;
    for (int i = 1; i <= n; i++)
        cin >> things[i];
    sort(things + 1, things + 1 + n); //将纪念品价格从高到低排序
    int ans = 0; //一共需要分几组
    for (int i = 1; i <= n; i++)
        if (vis[i] != true)
            for (int j = n; j > i; j--) { //在不超过w元的情况下，尽可能让每组的钱数最大
                if (vis[j] != true && things[i] + things[j] <= w) {
                    ans++;
                    vis[i] = true;
                    vis[j] = true;
                    break;
                }
            }
    for (int i = 1; i <= n; i++)
        if (vis[i] != true) //有一些纪念品无法两个一组，就单独一组
            ans++;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Cold_Eyes_bystander (赞：5)

题目看起来没有什么头绪，但稍微一想就明白了。

既然想分组尽可能地多，那么就尽量让两个数组成一组，不难发现，最小的数最有优势，最大的数最没有优势，让小的数去帮助他能帮助到的最大的数。

为什么要帮最大的了，因为这个大的数**可能只能接受这一个数的帮助了**。

```c++
#include <bits/stdc++.h>
using namespace std;
int a[30001];
int main()
{
    int w,n;
    cin>>w>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    int l=1,r=n;
    int cnt=0;
    while(l<=r)
    {
        if(a[l]+a[r]<=w)
        {
            cnt++;
            l++;
            r--;
        }
        else
        {
            cnt++;
            r--;
        }
    }
    cout<<cnt;
    return 0;
}
```

---

## 作者：New_Void (赞：4)

# [P1094 [NOIP2007 普及组] 纪念品分组](https://www.luogu.com.cn/problem/P1094)

### 思路

看到这题第一眼，就知道是贪心，其实就是把所有物品的价钱进行排序，之后用最大的加最小的，如果小于 $w$ 就将答案加一，否则就将大的下标减一。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int w;
    cin>>w;
    int g;
    cin>>g;
    int arr[g];
    for (int i=0;i<g;i++){
        cin>>arr[i];
    }
    sort(arr,arr+g);
    int left=0,right=g-1,cnt=0;
    while (left<=right){
        if (arr[left]+arr[right]<=w){
            left++;
            right--;
            cnt++;
        }
        else{
            right--;
            cnt++;
        }
    }
    cout<<cnt;
    return 0;
}

```

---

## 作者：zqy1018 (赞：4)

看完各位大犇写的题解，感觉可能有些地方可以简化一下

基本思想也就是配对，排序后用一个较小价值的配一个较大价值的

但是实际上在无法配对时，就可以直接结束循环退出了

（因为无法配对时就不可能继续成功配对）

```cpp
#include <cstdio>
#include <algorithm>
int limit,n,k[30005],ans=0;
int main(){
    scanf("%d%d",&limit,&n); //limit是价值和上限，n为纪念品个数 
    int i,at,o=0;//at是尾部向上查找的指针,o是判断是否可以配对的标记 
    for(i=0;i<n;i++)scanf("%d",&k[i]);
    std::sort(k,k+n);//排序 
    for(i=0;i<n;i++){
        for(o=0,at=n-1;at>i;at--)
            if(k[at]<=limit-k[i]){o=1;break;}//从尾部向上扫描 
        if(o){ans+=n-at;n=at;}else{ans+=n-i;break;}
        //可以配对则配对，尾部指针以下的变量都无法两两搭配
        //若无法继续则单个装入并退出 
    }printf("%d\n",ans); 
    return 0;
} 
```

---

## 作者：superLouis (赞：3)

## 题解：P1094 [NOIP2007 普及组] 纪念品分组

朴朴素素的贪心水题。

----------
### 1. 解题思路
首先排序是必须的，先把 $P$ 排序。然后用两个指针分别从两头开始，分别为 $i$ 和 $j$，其中一开始 $i = 1$，$j = n$（$i$ 和 $j$ 是下标）。然后如果 $P_i + P_j \le w$，答案可以直接加一，$i + 1$，$j - 1$。否则只有 $j - 1$，答案加一。

----------
### 2. 代码实现
其实代码还是蛮简单的嘛。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 3e4 + 10;
int n, h, a[maxn];
inline int read() {
    register int x = 0, f = 1;
    register char c = getchar();
    if (c == '-') f = -1;
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * f;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    h = read(); n = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    sort(a + 1, a + n + 1);
    int l = 1, r = n, ans = 0;
    while (l <= r) {
    	if (a[l] + a[r] <= h) l++, r--;
    	else r--;
    	ans++;
	}
	cout << ans << "\n";
    return 0;
}
```

---

## 作者：zjinyi (赞：2)

# 题解：P1094 纪念品分组
## 题目大意
每组分发 $1$ 或 $2$ 件纪念品，且每组价格之和不能超过 $w$，求最少的分组数目。

## 分析
先将价值排序，再两两配对。为了使分组数目最少，每组价格就要最大。所以排序后从后往前配对。

## 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
	int w, n, cnt = 0; 
	cin >> w >> n; // 输入
	int a[n];
	for (int i = 0; i < n; ++i)
	{
		cin >> a[i];
	}
	sort(a, a + n); // 排序
	for (int i = n - 1; i >= 0; --i) // i 从下标 n - 1 开始，从大往小遍历
	{
		for (int j = i - 1; j >= 0; --j) // j 从下标 i - 1 开始，从大往小遍历
		{
			if (a[i] + a[j] <= w) // 如果价值不超过 w，配对成功
			{
				cnt += 1; 
				a[i] = 240; // 使配对成功的纪念品价值超过 w 的最大值，这样再次遍历时价值也不超过 w
				a[j] = 240;
			}
		} 
	}
	cout << n - cnt; // 计算答案
	return 0;
}
```

---

## 作者：yuyuechen2023 (赞：1)

本题为一道贪心题

具体思路如下：因为希望分的组数最少，所以每组要在不超过给定的数的情况下尽可能的多，所以先排序，再利用双指针每次将一个大数与第个小一点的数匹配，这样既不浪费每一组的空间，也不容易超过给定的数。

贴一下代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
 
int w, n, ans = 0, p[100005];
int main() {
	cin >> w >> n;
	for (int i = 1; i <= n; i++) {
		cin >> p[i];
	}
	sort (p + 1, p + n + 1); //排序，每次找当前最大和最小 
	for (int i = 1, j = n; j >= i; j--) {
		if (p[i] + p[j] <= w) { //如果满足，答案加1，都前进一位 
			ans++;
			i++;
		} else { //如果超过了，那么用当前最小的数，去匹配大的数都超过了的话，就说明大数只能自己一组了，只需答案加1 
			ans++;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：kunkun127 (赞：1)

## 思路

本题难点就在贪心上。

利用双指针 $l$ 和 $r$ 让最两个指针匹配，如果可以就分成一组；如果不行就让 $r$ 单独一组。

因为目前最小的都不能与 $r$ 在一组了，所以要放弃 $r$ 的分组，$l$ 继续匹配下一个。直到把所有数据完全分组即可。

## 注意事项

进行二分时，条件一定是 `l <= r`。不然可能导致最中间的数据无法遍历分组。

## 参考代码

```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;

int a[30005];

int main()
{
	int n, w, ans = 0, l, r;
	cin >> w >> n; 
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	l = 1, r = n;
	while (l <= r) 
	{
		if (a[l] + a[r] <= w)
		{
			l++;
			r--;
			ans++;
		}
		else
		{
			r--;
			ans++;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：monkeyking_QAQ (赞：1)

[题目传送门。](https://www.luogu.com/problem/P1094)

### 思路：

排序、贪心。

我们先来看一个著名数学故事：高斯小时候因和小伙伴们淘气，被老师罚做一道数学题，这道数学题是这样的： $1 + 2 + 3 + … + 99 + 100$ 等于几。他的朋友们算了很久都没算出来，可高斯花了2分钟就做出来了，原因是他发现这个题可以首尾搭配，进行分组。你看：$(1,100),(2,99),(3,98) …$ 总共可以分成 $100 \div 2 = 50$ 组，每组两个数的加和都是 $101$，所以这道题就可以转化为 $101 \times 50$ 等于几。

同样，此题也可以首尾搭配，进行分组。我们先排序，然后定义两个变量 $l$ 和 $r$ 分别表示左端点和右端点，如果目前判断的这组数小于每组纪念品价格之和的上限，那么右端短向前移一位，左端点向后移一位；否则，右端点向前移一位。以上两种情况判读完最后答案都要加一。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int w,n,ans;
int a[30005];
int main(){
	cin>>w>>n;
	for(int i=1;i<=n;i++)  cin>>a[i];
    sort(a+1,a+n+1);
	int l=1,r=n;
	while(l<=r){   
		if(a[l]+a[r]<=w)  //如果目前判断的这组数小于每组纪念品价格之和的上限
		    r--,l++,ans++; //那么右端短向前移一位，左端点向后移一位
		else
		    r--,ans++;  //否则，右端点向前移一位
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

贪心。

因为最多两个纪念品一组，且要求分组最少，那么显然要尽可能让两个一组，同时两件纪念品价格和尽可能接近给定的上限。这是我们的贪心策略。

对于实现，我们先把价格排序，然后双指针扫一遍同时记录答案即可。

具体就是让价格最低的和最高的配对，若此时价格和超过价格上限，那么最高的只能自己单独一组，再让最低的和次高的配对，以此类推，直到配对成功，再换价格次低的来配对，这个过程要保证左指针小于有指针，否则配对结束。最后考虑一下若两个指针相等，说明还剩下中间的一个，让它自己一组即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, w, p[30001], cnt;
int main(){
	cin >> w >> n;
	for(int i=1; i<=n; i++) cin >> p[i];
	sort(p+1,p+n+1);
	int i=1, j=n;
	while(i<j){
		if(p[i]+p[j]<=w) cnt++, i++, j--;
		else j--, cnt++;
	}
	if(i==j) cnt++;
	cout << cnt;
	return 0;
}
```

---

## 作者：2023z (赞：1)

### 思路

我们可以先从大到小排序，因为分组尽量要均衡，所以最大的和最小的要分一组，第二大和第二小的分一组......以此类推。我们用 $ len $ 表示当前选择的最大的下标，核心代码为：

```cpp
for(int i=1;i<=len;i++){
		if(p[i]+p[len]<=w) len--;
		cnt++;
}
```
[AC](https://www.luogu.com.cn/record/198650311)记录

#### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int cmp(int a,int b){
	return a>b;
} //排序函数
int main(){
	int n,w,p[30010],cnt=0;
	cin>>w>>n;
	for(int i=1;i<=n;i++) cin>>p[i]; //输入
	sort(p+1,p+n+1,cmp); //排序
	int len=n;
	for(int i=1;i<=len;i++){
		if(p[i]+p[len]<=w) len--; //如果遇到合适的，len 就减一
		cnt++; //累加答案
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
这题是比较简单的二分，首先要把所有的纪念品的价格排序一下，然后设置左右两个端点。

只要左端点小于右端点。就开始判断左端点位置上的这个礼品加上右端点的是否小于钱数。是，左端点往右移，不然都要移。


---
### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[30001], w, n, l = 0, r = 0, ans = 0;

int main() {
	cin >> w >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	l = 1;
	r = n;
	while (l <= r) {
		if (a[l] + a[r] <= w) {
			l++;
			r--;
		} else r--;
		ans++;
	}
	cout << ans << endl;
	return 0; 
}
```

---

## 作者：inscape (赞：1)

## 题目内容

有 $n$ 个物品，每个物品都有一个价格，物品可以 $2$ 个一组装在一起，但一组内的物品价格之和不得超过 $w$，问最少要分多少组。

## 思路

其实贪心思路不难想，由于要两两组合且价格只和不超过 $w$，所以我们只需要先排个序，再把最大的和最小的组合在一起就行了… 吗？

不！我们还需要使用双指针进行维护，比如说最大的和最小的相加大于 $w$，我们就需要将当前最小值保留，只将最大值前推。

代码如下：

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,j,l,r,g[30100]; // 定义
int main(){
	cin>>w>>n; 
	for(int i=1;i<=n;i++) cin>>g[i];
	sort(g+1,g+n+1); // 对数组进行从小到大排序
	l=1,r=n;
	while(l<=r){ // 双指针
		j++; // 每次将分组数增加
		if(g[l]+g[r]<=w) l++; // 如果价格之和符合，则将最小值更新
		r--; // 更新最大值
	}
	cout<<j;
	return 0;
}
```

完结撒花

---

## 作者：Ngo123 (赞：1)

本题在读完题后，依据题目所说的分得最少的分组数目，我们有一种初步想法，那就是让每组的价值尽量大。

由我们的初步想法，设计出这样的贪心策略：

首先将纪念品按照价格从小到大排序。

然后设置两个指针 $i$，$j$，$i$ 指针初始化为1，$j$ 指针初始化为 $n$。

我们接着正序枚举 $i$，每次对于当前纪念品，从 $j$ 指针开始寻找一个价值尽可能大的且总价值不超上限的的纪念品成为一个组合。

若不满足，则由 $j$ 指针继续向前寻找一个物品。

若此时满足，则当前合法的两个纪念品分为同一组，否则当前纪念品 $i$ 单独分为一组。

以下是我的代码：
```
#include<bits/stdc++.h>
const int N = 3e4+5;
using namespace std;
int w,n,ans,sum,cnt,p[N];
int main()
{
    cin>>w>>n;
    for(int i = 1;i<=n;i++) cin>>p[i];
    sort(p+1,p+n+1);
    int i = 1,j = n;
    while(i<=j)
    {
        if(p[i]+p[j]<=w)
        {
            i++,j--;
            ans++;
        }
        else
        {
            j--;
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

1.先排序

2.从尾到头，看可不可以塞下前面第start个数；

若塞不下，start不变；若塞得下，start++；

无论如何，end--；

3.每进行一次操作，tot++；

4.输出tot


注意：只能从尾到头，不能从头到尾；

代码如下：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int m,n,map[40000];
int main()
{
    int tot=0;
    cin>>m>>n;
    for(int z=0;z<n;z++)
    cin>>map[z];
    sort(map,map+n);
    int start=0,end=n-1;
    while(start<=end)
    {
        if(map[start]+map[end]<=m)
        start++;
        end--;
        tot++;
    }
    cout<<tot;
    return 0;
}
```

---

## 作者：oneman233 (赞：1)

前两天看了一下**双端队列**，看到这题时立马想起了它。
在处理一些对序列去除头尾的题目时，双端队列有很好的优越性：

1、它非常直观，不需要用指针去获取首尾节点，可以直接用back()和front()函数去获取首位值
2、并且对于不需要的值，可以直接pop掉，不会被它搞混淆
3、最重要的是，你可以用sort对双端队列排序！！！

这道题的思路很简单，大的跟小的放在一起，放不下则优先放大的，小的留到后面去。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int w,n,tmp;
    int ans=0;
    deque<int> g;
    cin>>w>>n;
    for(int i=0;i<n;++i)
    {
        cin>>tmp;
        g.push_back(tmp);
    }
    sort(g.begin(),g.end());
    while(!g.empty())
    {
        if(g.size()==1)
        {
            ans++;
            break;
        }
        if(g.back()+g.front()>w)
        {
            g.pop_back();
            ans++;
        }
        else
        {
            g.pop_back();
            g.pop_front();
            ans++;
        }
    }
    cout<<ans;
    return 0;
}
```



---

## 作者：4041nofoundGeoge (赞：0)

[这道题](https://www.luogu.com.cn/problem/P10483)的强化版。

## 思路

我们可以爆搜，得到结果。但这种方法不是最优，能达到 $2^n$ 级的复杂度，所以我们需要用贪心 $+$ 双指针。（贪心最优性证明，详见[这里](https://www.luogu.com.cn/article/rtvpn9ti)）

所以我们为了最优解，肯定是大的数搭配小的数，可以达到最优。我们再想，大的配小的如果大于 $w$，就需要再分一组，这样就可以分成最优的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[40005];
int main()
{
	int n,w;
	cin>>w>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	int l=1,r=n,sum=0;
	while(l<=r)
	{
		if(a[r]+a[l]<=w){
			l++;
			r--;
			sum++;
		}
		else{
			r--;
			sum++;
		}
	}
	cout<<sum<<endl;
	return 0;
}

```

---

## 作者：ylzpl (赞：0)

这题非常简单。我们可以将所以物品的价值从小到大排序，这样我们可以定义两个指针 $l,r$，分别指向当前最贵的物品和最便宜的物品。如果这两件物品的价值和小于等于 $w$ 就分成一组，否则独自成一组。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=3e6+5;
int n,w,a[maxn];
bool cmp(int q,int h)
{
	return q<h;
}
signed main()
{
	cin>>w>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+1+n,cmp);
	int l=1,r=n;
	int cnt=0;
	while(l<=r)
	{
		if(a[r]+a[l]<=w)//加起来的和小于等于m,说明他俩可以分成一组 
		{
			l++;
			r--;
		}
		else
		{
			r--;
		}
		cnt++;
	}
	cout<<cnt;
	return 0;
}
```

---

## 作者：__Crafty_Wolf__ (赞：0)

### 题目分析

这道题就是让你将两个或者一个物品打成一个包，但总钱数不可以超过限定金额。

 所以我们先对数组进行排序，再用两个指针一个指前面，一个指后面。如果他们的价值和大于上限就将答案加上，并将左指针往右移，右指针往左移。
 
 ### 代码
 
 ```cpp
#include<bits/stdc++.h>//万能头
using namespace std;

int main(){
	int w,n;
	cin>>w>>n;
	int a[n];
	int ans=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	sort(a,a+n);//要排序
	for(int i=0,j=n-1;i<=j;){
		if(a[i]+a[j]<=w){//如果能两个一起打包
			ans++;
			i++,j--;
		}else{
			ans++;
			j--;
		}
	}
	cout<<ans;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：贪心。

---
题目要我们给纪念品分组。但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。所以我们要想一下：如何使分组数目越小？我们可以先来看一个计算题：$1+2+3+4+5=?$ 我们可以考虑两个两个数分一组，就是 $(1,5),(2,4),3$。不难发现，数字 $3$ 会独自成一组，这样我们计算的和就是 $6+6+3=15$。因此，我们可以发现：我们算这个题可以首尾搭配，在本题也是如此。我们可以第定义两个变量 $lt$ 和 $rt$，分别指向我们的左端点和右端点。每次左右搭配。如果总和大于 $w$ 就独自成一组。所以代码就很好写了。注意：只有所有的纪念品是从小到大排序时才可以这样分，所以一开始需要排序。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
const int maxn=1e6+5;
int a[maxn],r[maxn];
bool cmp(int q,int h){return q>h;}
signed main()
{
	int w,n;
	cin>>w>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n,cmp);
	int cnt=0;
	int lt=1,rt=n;
	while(lt<=rt)
	{
		if(a[lt]+a[rt]<=w)
		{
			cnt++;
			lt++;
			rt--;
		}
		else
		{
			cnt++;
	        lt++;
		}
	}
	cout<<cnt;
	return 0;
}
```

---


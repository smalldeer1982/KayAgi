# [NOISG 2025 Prelim] Ducks And Buttons

## 题目描述

**C++ 用户注意：由于此问题中涉及的整数数值较大，可能需要使用 `long long` 数据类型来代替 `int` 数据类型。**

Shor 小鸭正在和他的朋友们玩一个游戏！这个游戏是在一个一维的网格上进行的，该网格由 $n$ 个单元格排成一行组成，从左到右编号为 $1$ 到 $n$。

每个单元格上都有一个按钮。如果某一时刻在第 $i$ 个单元格上有不少于 $a[i]$ 只鸭子，那么该单元格上的按钮就会被永久按下。即使这些鸭子离开了，该按钮也仍然保持按下状态。为了赢得这场游戏，所有 $n$ 个按钮都必须被按下。

一开始，第 $1$ 个单元格上有 $d$ 只鸭子。每次移动中，一只鸭子可以向左或向右移动一个单元格。

请确定赢得这场游戏所需的最少总移动次数。**题目保证存在某种移动方式可以赢得这场游戏。**


## 说明/提示

### 子任务

对于所有测试用例，输入将满足以下约束条件：

- $1 \leq n \leq 200\,000$
- $1 \leq d \leq 10^9$
- 对于所有 $1 \leq i \leq n$，都有 $0 \leq a[i] \leq d$
- 题目保证存在某种移动方式可以赢得这场游戏

你的程序将在满足以下特殊性质的输入数据上进行测试：

| 子任务 | 分值 | 特殊性质 |
| :-: | :-: | :-: |
| $0$ | $0$ | 样例 |
| $1$ | $8$ | $n = 2$ |
| $2$ | $5$ | $a[i] = 0$ |
| $3$ | $11$ | $a[i] \leq 1$ |
| $4$ | $6$ | 所有的 $a[i]$ 值相等 |
| $5$ | $19$ | $n, d \leq 1000$ |
| $6$ | $12$ | $a[i]$ 是单调不减的 |
| $7$ | $16$ | $a[i]$ 是单调不升的 |
| $8$ | $23$ | 无 |

### 样例 1 解释

此样例适用于子任务 $1, 5, 7, 8$。

### 样例 2 解释

此样例适用于子任务 $3, 5, 8$。

### 样例 3 解释

此样例适用于子任务 $4, 5, 6, 7, 8$。

### 样例 4 解释

此样例适用于子任务 $5, 6, 8$。

### 样例 5 解释

此样例适用于子任务 $5, 7, 8$。

### 样例 6 解释

此样例适用于子任务 $5, 8$。

![](https://cdn.luogu.com.cn/upload/image_hosting/eof0jice.png)

下图展示了一种可以最小化总移动次数的移动序列。每一个红色箭头代表一次移动，箭头上方的数字表示移动的顺序，移动 $1$ 最先发生。

- 按钮 $1$ 在所有移动发生之前就已被按下。
- 按钮 $2$ 在第 $3$ 次移动后被按下。
- 按钮 $3$ 在第 $10$ 次移动后被按下。
- 按钮 $4$ 在第 $11$ 次移动后被按下。
- 按钮 $5$ 在第 $18$ 次移动后被按下。
- 按钮 $6$ 在第 $20$ 次移动后被按下。
- 按钮 $7$ 在第 $21$ 次移动后被按下。
- 按钮 $8$ 在所有移动发生之前就已被按下（因为 $a[8] = 0$）。

由于在第 $21$ 次移动结束后所有按钮都已被按下，因此 $21$ 次移动是足够的。可以证明这是赢得游戏所需的最少移动次数。

### 样例 7 解释

此样例适用于子任务 $4, 6, 8$。


## 样例 #1

### 输入

```
2 199
175 42```

### 输出

```
42```

## 样例 #2

### 输入

```
5 3
1 1 0 1 0```

### 输出

```
3```

## 样例 #3

### 输入

```
5 7
2 2 2 2 2```

### 输出

```
8```

## 样例 #4

### 输入

```
7 5
1 3 3 4 5 5 5```

### 输出

```
30```

## 样例 #5

### 输入

```
8 9
7 6 6 6 3 3 3 1```

### 输出

```
28```

## 样例 #6

### 输入

```
8 5
2 3 5 1 4 2 1 0```

### 输出

```
21```

## 样例 #7

### 输入

```
4 1000000000
1 1 1 999999999```

### 输出

```
2999999997```

# 题解

## 作者：Clare613 (赞：4)

## 题外话
本人十分喜欢鸭子，看到后就忍不住想发一篇。
## 思路
最开始 $d$ 只鸭子在一号点，也就是说一号点已经被按下了，那么接下来只要把 $2$ 到 $n$ 的点按下就好了。\
很明显，我们肯定不会让鸭子走回头路，那么就是一直保证后面的点的上一个点一定有足够的鸭子保证后面的点全都能按下。\
于是我们只要从后往前取最大值，再从 $2$ 到 $n$ 加起来输出就行了。
## code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005],maxn[200005],ans;
signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int n,d;
    cin>>n>>d;
    for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=n;i>=1;i--){
		maxn[i]=max(maxn[i+1],a[i]);
	}
	for(int i=2;i<=n;i++){
		ans+=maxn[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Dicer_L (赞：4)

## solution

### 题意

输入 $n$ 个地点，在 $1$ 上有 $d$ 只小鸭，并给出每个点的要求 $a_i$。移动每只小鸭需要 $1$ 的花费，且必须最小有 $a_i$ 只小鸭经过或到达 $i$，问满足条件的最小的代价。

### 注意点

> 题目保证存在某种移动方式可以赢得这场游戏。

意味着题目给的 $d$ 只小鸭管够用，所以我们不用去考虑。

> 一只鸭子可以向左或向右移动一个单元格。

所有鸭子起始都在 $1$ 号位置，所以最优肯定不用考虑向左移。

> 可能需要使用 long long 数据类型来代替 int 数据类型。

不必多说。

### 思路

思考过程略，毕竟是橙。直接给出操作方式。

从后往前遍历，用 $maxn$ 存储当前发现的最大数，$ans$ 记录总花费。

假设现在在 $i$ 点，$maxn$ 代表从 $i-1$ 到 $i$ 需要过的鸭子数，也就是两点间的最小花费，$ans$ 代表从 $i-1$ 到 $n$ 的最小花费。

$maxn$ 不断变大，也与需要过的鸭子数不断变多相吻合。如果正序遍历，那么没法判断当前点需要通过的鸭子数 $maxn$ 是变大还是变小。所以不可行。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=200005;
int w[N],n,m,maxn,ans;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>w[i];
	for(int i=n;i>1;i--){//逆序遍历
		maxn=max(maxn,w[i]);//找最大值
		ans+=maxn;//累加总和
	}
	cout<<ans;
}
```

---

## 作者：yemengzhi (赞：2)

## 思路
观察题目：已知一个点只要被点亮过就不会熄灭，我们只需要每次移动最少数量且能点亮后面的点的鸭子数即可。但正向维护显然不是很好操作，所以我们考虑从后向前维护后缀最大值即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;using  db=double;
#define inf 0x3f3f3f3f
#define UB upper_bound
#define LB lower_bound
inline ll read(){
	ll f=1,x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')	f=-f;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')	x=x*10+ch-'0',ch=getchar();
	return x*f;
}
void write(ll x){
	if(x<0)	x=-x,putchar('-');
	if(x>9)	write(x/10);
	putchar(x%10+'0');
	return;
}
ll n,d;
ll a[200001];
ll ans=0;
int main(){
	n=read(),d=read();
	for(int i=1;i<=n;i++)	a[i]=read();
	ll now=-1;
	for(int i=n;i>1;i--)	ans+=max(now,a[i]),now=max(now,a[i]);
	cout<<ans;
}
```

---

## 作者：longyitongxue (赞：2)

# 正文前特别提⽰
![](https://cdn.luogu.com.cn/upload/image_hosting/x6t7g91k.png)
- - -
[题⽬传送⻔](https://cdn.luogu.com.cn/upload/image_hosting/x6t7g91k.png)
# 主要思路
这道题，看着题⽬挺难的。不用怕，我们慢慢分析。第ー个单元格里有 $d$ 只鸭⼦，看下面的样例解释图可以发现，我们要把鸭⼦从第ー个单元格里往右移。过程中，我们需按下所有按钮，我们要让单元格中鸭⼦的数量达到了 $a_i$，オ能让ー只鸭⼦进行下ー步。这个过程我们可以倒过来取ー遍后 $n-i+1$ 个 $a$ 数组里面的数的最大值，存在ー个数组里，然后累加这些最大值便是答案（数组的第ー个元素别加，那是初始单元格位置不用加）。**注意开 `long long`！**
# [AC](https://www.luogu.com.cn/record/213791574) code
```cpp
#include<iostream>
#define LL long long
using namespace std;
LL a[200005],kkksc03[200005]/*随便取的😁*/;
int main(){
    int n,d;
    cin>>n>>d;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=n;i>=1;i--){
        kkksc03[i]=max(kkksc03[i+1],a[i]);//这就是那个“倒过来取ー遍后 𝑛 - 𝑖 + 1 个 𝑎 数组里面的数的最大值，存在ー个数组里”
    }
    LL ans=0;//不开 𝚕𝚘𝚗𝚐 𝚕𝚘𝚗𝚐 见祖宗
    for(int i=2;i<=n;i++){
        ans+=kkksc03[i];
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Andy_L (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12193)

---

首先，题目要求我们每个格子的按钮都被按下，同时最小化鸭子的总移动次数。所以我们需要合理分配需要移动的鸭子的数量，使其尽可能的少，从而减少总移动次数。

考虑贪心，优先处理远端的格子。具体来讲就是，从最远的格子开始处理，因为这些鸭子的移动路径会覆盖左侧的格子。

而对于每个单元格，计算需要通过的鸭子数量（也就是总共需要的鸭子数减去之前已分配过的鸭子数），然后记录这些鸭子的移动次数。

每次分配的鸭子数量乘以第 $1$ 个格子到达这个格子所需的步数，累加就可以得到总移动次数的最小值了。

详见核心代码

---

```cpp
int a[maxn];
inline void solve()
{
	int n=read(),d=read();
	int ans=0,maxx=0;
	forz(i,0,n-1) a[i]=read();
	int cnt=0;
	forn(i,n,1)
	{
		int p=max(0ll,a[i-1]-cnt);
		cnt+=p;
		ans+=p*(i-1);
	}
	write(ans);
	putchar('\n');
}
```

---

## 作者：FZY_CZY (赞：1)

半天没发现可以切换成中文模式。

题目在这👉 [题目](https://www.luogu.com.cn/problem/P12193)。

# 思路
因为我们的一开始在第一个单元格上面有 $d$ 只鸭子，所以，可以肯定，我们肯定是一步步的将鸭子从最左边移动到最右边，在这个过程中，我们要将所有按钮都按下，我们可以从整体的角度来考虑，我们移动到第 $i$ 个格子的时候，我们此时在这个格子拥有的小黄鸭的个数应该要满足 $[i,n]$ 中所有按钮的需求，满足需求很简单，就是 $\forall i\in \mathbb [i,n],cnt \ge a_i$，所以我们可以倒过来取一遍最大值。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=200010;
int n,d;
int a[N];
int f[N];
LL res;
int main(){
    cin>>n>>d;
    for (int i=1;i<=n;i++) cin>>a[i];
    for (int i=n;i>=1;i--) f[i]=max(f[i+1],a[i]);
    for (int i=2;i<=n;i++) res+=f[i];
    cout<<res;
    return 0;
}
``````
其实题面提醒过了，要开 long long。

---

## 作者：Doraeman (赞：0)

## 思路  
### 分析
如果某只鸭子曾经向左移动，后来又向右移动，那么它最初的向左移动就是不必要的。  
因此，最优的移动顺序一定是从鸭子们最开始所在的第 $1$ 个位置依次向右移动到第 $n$ 个位置。

如果某个位置 $i$ 上站着 $x$ 只鸭子，而其右侧的**每一个位置都最多需要 $y$ 只鸭子**，分类讨论。
1. $x>y$。此时并非全部的 $x$ 只鸭子都需要去其右侧的位置，因为想要按下右侧的按钮，最多只需要 $y$ 只就可以完成。
2. $x=y$。此时全部的 $x$ 只鸭子都要去右侧的位置，才能按下右侧的所有按钮。也就是需要 $y$ 只鸭子向右移动。

观察发现，无论何种情况，都要**求得某个位置 $i$ 右侧每个位置最多需要的鸭子数量 $y$，并求和。**

只要遵循以上 $2$ 条处理办法，又因为最初所有 $d$ 只鸭子都站在 $1$ 位置上，且题目保证有方案，所以不会出现 $x<y$ 的情况。

如果每次到某一个位置都去找其右侧每个位置所需鸭子的最大值，算法复杂度就是 $O(n^2)$，显然会超时。  
这时，就要使用伟大的**后缀最大值**！
### 后缀最大值
可以定义数组 $s$ 保存后缀最大值，其中 $s_i$ 表示**第 $i$ 个位置右侧的每一个位置所需要的鸭子的最大值**。  
递推公式为：$s_i=\max(s_{i+1},a_i)$，其中 $a_i$ 表示第 $i$ 个位置所需的鸭子数量。  
这个公式要从右向左递推（即从 $n$ 向 $1$ 递推）。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;

int n, d, a[N], s[N];
long long ans;

int main(){
    cin >> n >> d;
    for(int i=1; i<=n; i++)
        cin >> a[i];

    // 求后缀最大值
    for(int i=n; i>=1; i--)
        s[i] = max(a[i], s[i+1]);

    // 第1个位置所需的鸭子不必计算，因为最初所有鸭子都在第1位置上
    for(int i=2; i<=n; i++)
        ans += s[i];

    cout << ans;
}
```

---

## 作者：litangzheng (赞：0)

### 前言：  

挺有意思的一道~~签到~~题。  

### 思路：  

容易想出，因为题目保证有解，所以第一个单元格一定不用移动，不管它，给出的 $d$ 也没有用处。并且让鸭子往左走没有用，每一只鸭子要么不动要么往右走。  
然后，从第二个单元格开始，一直到第 $n$ 个单元格，我们每次要移动多少呢？显然，对于第 $i$ 个格子，它要移动 $\max(a_i, a_{i+1}, a_{i+2}, \dots, a_n)$ 次。  
正推会超时，那我们就**反着推**（你一定可以想出来怎么推，这里我就不过多赘述了）。  
于是，简短的代码就来了： 

### 代码：  


```cpp
#include<bits/stdc++.h>
#define int long long//开longlong
#define N 200005
using namespace std;
int n,a[N],ans,maxn,d;
signed main(){
    cin>>n>>d;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=n;i>=2;i--){
        maxn=max(maxn,a[i]);//从a_n到a_i的最大值。
        ans+=maxn;//加上这个值，移动的鸭子数小于这个值的话鸭子便不能按下所有按钮。
    }
    cout<<ans;
}
```

---

## 作者：fiee_Lina (赞：0)

# [P12193 [NOISG 2025 Prelim] Ducks And Buttons](https://www.luogu.com.cn/problem/P12193)

### 思路

每个单元格上都有一个按钮，需要移动鸭子在某一时刻在第 $ i $ 个单元格上有不少于 $ a_i $ 只鸭子，那么该单元格上的按钮就会被永久按下。

题目中的左右移动其实需要的只有向左移动，只需要从后往前寻找最大值，将这些最大值累加即可。

最后一定要开 `long long`。

 ------------------------------------------
 
### Code

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+7;
int n,d;
int s[N];
int a[N];
int ans=0;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);

	cin>>n>>d;
	for(int i=1;i<=n;i++) cin>>s[i];
	memset(a,-0x3f3f3f3f,sizeof(a));
	for(int i=n;i>=1;i--) a[i]=max(a[i+1],s[i]);
	for(int i=2;i<=n;i++) ans+=a[i];
	cout<<ans;

	return 0;
}

```

---


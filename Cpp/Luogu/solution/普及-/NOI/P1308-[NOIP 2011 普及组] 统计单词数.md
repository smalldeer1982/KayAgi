# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# 题解

## 作者：suxy15 (赞：154)

## 读取部分
c 版本的字符串处理确实比较不友好。

+ 第一行的单词读取比较简单，使用`scanf()`读取即可；
+ 第二行的字符串有一个测点有行首空格，所以开始用`gets()` 读取一行的时候会漏掉，改用`getchar()`挨个处理即可。

读取部分代码如下：
```c
    // input
    scanf("%s", w);
    c = getchar();
    while((c = getchar()) != EOF && i < MAX_LINE){  
        if(c == '\n') break;
        s[i++] = c;
    } s[i] = '\0';
```

## 处理部分
处理部分比较简单，考虑周全一点即可。

+ 首先定义大小写转换，此处全部转成小写：
```c
#define val(a) (a<'a' ? (a-'A'+'a') : a)
```

+ 然后维护两个扫描头，$i$ 对应文章字符串，$j$ 对应单词字符串，一旦是单词头（`i==0`或`s[i-1]==' '`）或者之前保持匹配 (`j>0`此处略写为`j`)，那么继续判断匹配：
	+ `++j`  判断单词的下一个字母，如果下一个为空`w[j]=='\0'` 并且文章的下一个字母为空或空格 `s[i+1]=='\0' || s[i+1]==' '`，则有一次完整的字符匹配。
    + 否则继续判断下一个字母（什么也不做）
+ 否则清空 $j$，从头继续扫描

处理部分代码：

```c
    // calculate
    for(i=0,j=0; s[i]!='\0'; ++i){
        if((i==0 || s[i-1]==' ' || j) && val(s[i])==val(w[j]) && ++j>-1){
            if(w[j]=='\0' && (s[i+1]=='\0' || s[i+1]==' ')){
                if(first==-1) first = i+1-j;
                count++;
            }
        }else j=0;
    }
```

## AC代码

``` c
#include <stdio.h>

#define MAX_LINE 1000001
#define val(a) (a<'a' ? (a-'A'+'a') : a)

int main()
{
    // declaration
    int i=0, j, count=0, first=-1;
    char c, w[11], s[MAX_LINE];

    // input
    scanf("%s", w);
    c = getchar();
    while((c = getchar()) != EOF && i < MAX_LINE){  
        if(c == '\n') break;
        s[i++] = c;
    } s[i] = '\0';

    // calculate
    for(i=0,j=0; s[i]!='\0'; ++i){
        if((i==0 || s[i-1]==' ' || j) && val(s[i])==val(w[j]) && ++j>-1){
            if(w[j]=='\0' && (s[i+1]=='\0' || s[i+1]==' ')){
                if(first==-1) first = i+1-j;
                count++;
            }
        }else j=0;
    }

    // output
    if(count==0) printf("-1\n");
    else printf("%d %d\n", count, first);
    return 0;
}

```

> PS: 到底要写多详细才能给过呢= =

---

## 作者：Eason_lyx (赞：93)

博客效果**更佳**->[洛谷博客](https://www.luogu.com.cn/article/03xk59dp)。

update on 2025.1.12：
- 修正了超链接。
- 修正了代码中存在的问题。感谢 [FPXS11GO](https://www.luogu.com.cn/user/570842) 在评论区的提醒。
## 题目大意
> 给定一个单词，请你输出它在给定的文章中出现的次数和**第一次**出现的位置。注意：匹配单词时，**不区分大小写**，但要求完全匹配。即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同，如果给定单词仅是文章中某一单词的一部分则不算匹配。   
## 题目分析
- 声明变量。

```cpp
string dan,ci,s;
int cur=-1,ans;
```
`dan` 用于拆分 `s` 中的每一个单词， `ci` 是目标单词， `cur` 是下标， `ans` 输出答案。

- 输入并解决大小写问题。
```cpp
cin>>ci;
    for(int i=0;i<ci.size();++i)ci[i]=tolower(ci[i]);
    getchar();
    getline(cin,s);
    s+=' ';
    for(int i=0;i<s.size();++i)s[i]=tolower(s[i]);
```
- 统计与计数。
```cpp
for(int i=0;i<s.size();++i)
{
        if(s[i]==' '){
            if(dan==ci){
                ans++;
                if(cur==-1)cur=i-ci.size();
            }
            dan="";
        }
        else dan+=s[i];
}
```
如果是空格，判断是否与目标 `ci` 相同；如果不是，更新变量 `dan` 。

- 输出
```cpp
if(ans==0)printf("-1");
else printf("%d %d",ans,cur);
```  
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string dan,ci,s;
int cur=-1,ans;
int main()
{
    cin>>ci;
    for(int i=0;i<ci.size();++i)ci[i]=tolower(ci[i]);
    getchar();
    getline(cin,s);
    s+=' ';//这行很重要，关系着最后一个单词会不会扫描到
    for(int i=0;i<s.size();++i)s[i]=tolower(s[i]);
    for(int i=0;i<s.size();++i)
    {
        if(s[i]==' '){
            if(dan==ci){
                ans++;
                if(cur==-1)cur=i-ci.size();
            }
            dan="";
        }
        else dan+=s[i];
    }
    if(ans==0)printf("-1");
    else printf("%d %d",ans,cur);
    return 0;
}
```  
[评测记录](https://www.luogu.com.cn/record/130449036)。


本人第一次写题解，如有码风或排版方面的不足，请多多谅解。

~~求点赞。~~

---

## 作者：Jelly_Goat (赞：70)

**Upd on 19.7.20:**  
一开始写的题解不好，但是审核好像过了  
回来补一补    
**Upd on 20.1.7:**  
一开始我太菜了  
敲不出python解法  
这回真——加上python3解法

---------

众所周知，string在`<string>`中被定义为是类型，  
这意味着我们可以将它作为int一样的类型使用。   
并且还有神奇的加减法重载。

-------

然后说这个题。  
流程：  
1. 小写所有字母  
2. 所有单词保证前后都有空格  
3. 逐个比较  
4. 输出答案

C++解法：
```cpp
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
string lowwers(string str)
{//手写字符串该小写，死记！ 
	int len=str.size();
	for (int i=0;i<len;i++)
	{
		str[i]=(str[i]>=65&&str[i]<=90)?str[i]+32:str[i];
	}
	return str;
}
string inputs()
{//输入，小写化，并且开头结尾加上' ' 
	string temp;
	getline(cin,temp);
	return ' '+lowwers(temp)+' ';
}
int main()
{
	string pas,goal;
	int pos=0,count=0,memory;//定位器 
	goal=inputs();
	pas=inputs();
	pos=pas.find(goal,pos);
	if (pos==-1)
	{
		cout<<pos;
		return 0;
	}
	else
	{
		memory=pos;count++;
		pos+=goal.size()-1;
	}
	while (pos<pas.size())
	{
		pos=pas.find(goal,pos);
		if (pos==-1)
		{
			break;
		}
		else
		{
			count++;
			pos=pos+goal.size()-1;
		}
	}
	cout<<count<<' '<<memory;
	return 0;
}
```
可以知道，string类型中find函数将变得十分重要。  
在其中做了很多种find函数，大家可以自己去找baidu。  

--------

再说py。  
算法流程：  
1. 小写所有字母   
2. 单词和文章前后各加一个空格然后找到位置  
3. (1)如果位置返回-1(说明没有)那么就输出-1    
   (2)否则就逐个比较单词统计个数  

代码：

```python
key = input().lower()
passage = input().lower()
L = passage.split()
cnt = 0
origin = ' {} '.format(passage).find(' {} '.format(key))

if origin == -1:
    print(-1)
else:
    for word in L:
        if word == key:
            cnt += 1
    print(cnt, origin)
```

注：不要尝试用pypy（爆空间了）

---

## 作者：wanghonghui123 (赞：45)

## 思路



- 先把两个字符串都再前后添加一个空格，方便匹配完整的单词。

- 再把所有字符都转成小写，方便操作。

- 接着用 `find` 函数去查找，如果开始 $pos$ 就是 $-1$ 了，说明整个文章里没有指定单词，直接输出 $-1$。

- 否则就要开始统计单词出现的次数了，只要 $pos$ 不等于 $-1$，要一直查找。

### 注意

- 由于文章字符串有空格，因此要用 `getline`。

- 由于需要去掉多余的换行符，所以要用 `getchar`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int main(){
	string c,s;
	cin>>c;
	getchar();
	getline(cin,s);
	c = ' '+c+' ';
	s = ' '+s+' ';
	for(int i=0;c[i];i++){
		c[i] = toupper(c[i]);
	}
	for(int i=0;s[i];i++){
		s[i] = toupper(s[i]);
	} 
	int pos = s.find(c);
	int t = pos;
	if(pos==-1){
		cout<<-1;
		return 0; 
	}
	int cnt = 0;
	while(pos!=-1){
		cnt++;
		pos = s.find(c,pos+1);
	}
	cout<<cnt<<' '<<t<<endl;
	return 0;
}
```

---

## 作者：continued258 (赞：35)

### java版代码
1. 首先要把输入的单词和文章都转化为小写(当然大写也可以),防止被坑.
2. 随后把文章中每个单词都按照空格切分开来,这样比较容易匹配单词.
3. 最后在用String自带的方法查找到单词第一次出现的位置,同时也要保证单词都是单独出现的,所以该字符串前后要拼接空格后再去匹配,返回的位置加1就是首次出现的位置.
4. 关于3的补充,对于文章第一个单词就出现关键单词,3是行不通的,因为第一个单词前并没有空格,作为特例处理.


------------
```
import java.io.BufferedInputStream;
import java.util.Scanner;

public class Main {
	static int count , first ;//key出现次数和第一次出现的位置
	public static void main(String[] args) {
		Scanner scan = new Scanner(new BufferedInputStream(System.in));

		String key = scan.next().toLowerCase();//获取第一行的单次输入并把它转为小写
		scan.nextLine();
		String str = scan.nextLine().toLowerCase();//获取第二行的文章输入
		String[] strPer = str.split(" ");//把文章切割用空格切分开,每个单词存入strPer数组中
		
		for (int i = 0; i < strPer.length; i++) {
			if(key.equals(strPer[i]))//如果匹配,count++
				count++;
		}
		
		if (count == 0) {//如果没有匹配的值,输出-1
			System.out.println(-1);
		} else {
			if (key.equals(str.substring(0, key.length()))) {//如果文章第一个单词就和key相等
				first = 0;
			} else
				first = str.indexOf(" " + key + " ") + 1;//前后添加空格是为了保证该单词都是单独出现的,不是其他单词所包含的.
			//字符串的indexOf(String)方法会返回String第一次出现的位置
			System.out.println(count + " " + first);
		}

	}
}
```

---

## 作者：qhr2023 (赞：11)

## solution

模拟题。

提供一种简洁的写法。读入两个字符串后先统一大小写（这里我统一成了小写，一个大写字母的 ASCII 码加上 $32$ 就是对应的小写字母），并将两字符串前后加上空格，如果不加或只加一个会出问题，即当一个大字符串中的一个单词包含小字符串时，会错误记录。然后扫一遍大字符串，记录小字符串出现次数和第一次出现位置。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1, s2;
int ans=1e6, cnt;
string turn (string s) {
	for(int i = 0; i < (int)s.size(); i++) 
		if('A' <= s[i] && s[i] <= 'Z') 
			s[i] += 32;
	return ' '+s+' ';
}
int main() {
    getline(cin, s1); s1=turn(s1);
    getline(cin, s2); s2=turn(s2);
    for(int i = 0; i < (int)s2.size(); i++) 
        if(s2.substr(i, s1.size()) == s1) 
            ans=min(ans, i),
            cnt++;
    if(cnt) 
		cout << cnt << ' ' << ans;
    else 
		puts("-1");
    return 0;
}
```

---

## 作者：niuniudundun (赞：7)

# 题目大意

查找指定单词在文章中出现次数和第一次出现的位置。

# 解法

因为忽略大小写直接在将其转成小写。输入文章时有空格所以使用 `getline(cin,字符串)` 即可。

代码：

```cpp
cin>>word;
getchar();//截取 "\n"
getline(cin,s);
s+=" ";
for(int i=0;i<word.length();i++){
  if(word[i]>='A'&&word[i]<='Z'){
    word[i]=word[i]+('a'-'A');
	}
}
int ls=s.length();
for(int i=0;i<ls;i++){
  if(s[i]>='A'&&s[i]<='Z'){
    s[i]=s[i]+('a'-'A');
  }
}
```

接下来遍历 $s$（文章），如果 $s_i$ 是空格则计算到上一个空格之间字符串，设为 $w$，如果 $w$ 与所找字符串相同则记录下位置（设为 $pos$）和次数（设为 $ans$）。

代码：

```cpp
for(int i=0;i<ls;i++){
  if(s[i]==' '){
    if(w==word){
      if(ans==0) pos=i-word.length();
      ans++;
    }
    w="";
  }else{
    w+=s[i];
  }
}
```

如果 $ans$ 为 $0$，则无解，输出 $-1$，否则输出 $ans,pos$。

代码：

复杂度：$O(l_{word}+2l_s)$，$l_{word}$ 是 $word$ 长度，$l_s$ 是 $s$ 长度。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int ans=0,pos=0;
string word,s,w;
int main(){
	cin>>word;
	getchar();
	getline(cin,s);
	s+=" ";
	for(int i=0;i<word.length();i++){
		if(word[i]>='A'&&word[i]<='Z'){
			word[i]=word[i]+('a'-'A');
		}
	}
	int ls=s.length();
	for(int i=0;i<ls;i++){
		if(s[i]>='A'&&s[i]<='Z'){
			s[i]=s[i]+('a'-'A');
		}
	}
	for(int i=0;i<ls;i++){
		if(s[i]==' '){
			if(w==word){
				if(ans==0) pos=i-word.length();
				ans++;
			}
//			cout<<w<<endl;
			w="";
		}else{
			w+=s[i];
		}
	}
	if(ans==0) cout<<"-1"<<endl;
	else cout<<ans<<" "<<pos<<endl;
	return 0;
}
```

---

## 作者：GoldenSTEVE7 (赞：7)

## 题意
给定一个单词和一个句子，求单词在句子中出现的次数。

## 思路
本题不难想到可以使用暴力枚举。但是有一个问题——我们需要找的“次数”，是指该单词单独出现的次数，即为前后均有空格隔开。所以我们可以对原本的单词加工一下，将其前后均加上一个空格，再去与原句子中的所有长度与加工后的单词相等的连续子串进行比较即可。

但是我们把单词加工后，也要对原句进行一定改变，因为原句的最开头和最后是不需要使用空格的，与加工后的单词比较时就会出现问题，所以我们也将原句的开头和结尾加上空格。

注意：因为题目中说不需要考虑大小写，所以我们把单词和句子都改为小写即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    string s1, s2;
    getline(cin, s1);
    getline(cin, s2);
    for(int i = 0; i < s1.size(); i++) if('A' <= s1[i] && 'Z' >= s1[i]) s1[i] = s1[i] - 'A' + 'a';
    for(int i = 0; i < s2.size(); i++) if('A' <= s2[i] && 'Z' >= s2[i]) s2[i] = s2[i] - 'A' + 'a';
    //大写改小写
    s1 = s1 + " "; s1 = " " + s1; 
    s2 = s2 + " "; s2 = " " + s2;
    //修改
    int len = s1.size(), ans = 0, x;
    bool f = 0;
    for(int i = 0; i < s2.size(); i++) {
        string s = s2.substr(i, len);
        if(s == s1) {
            if(!f) x = i, f = 1;
            ans++;
        }
    }
    //暴力
    if(ans) cout << ans << " " << x;
    else cout << -1;
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：5)

本题算法为：模拟，字符串。  
骗分方法：输出 `-1` 即可，不用动脑子。  
满分方法：
- 首先要查找的单词与文章出现的字符串的大小写无关，所以我们要将这 $2$ 个字符串的大小写统一。在这里我统一转为了小写字母。
- 我们可以枚举文章中的每个字符，再枚举一个区间 $[j,k]$，如果这个区间内的字符与要查找的字符相同，个数加一，记录下标。
- 小技巧：我们一开始就可以将 $id$ 设为 `-1`，这样没找到就可以直接输出，不用再判断，不然太麻烦。
  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
bool check(char a,char b)
{
	if(a==b) return true;
	return false;
}
signed main()
{
	string m,s;
	getline(cin,m);//因为输入时有空格，所以用getline输入
	getline(cin,s);
	m=' '+m+' ';
	s=' '+s+' ';
	for(int i=0;i<m.size();i++)
	{ 
		if(m[i]>='A'&&m[i]<='Z')
		{
			m[i]+=32;
		}
	}
	for(int i=0;i<s.size();i++)
	{
		if(s[i]>='A'&&s[i]<='Z')
		{
			s[i]+=32;
		}
	}
	int ans=0,id=-1;
    for(int i=0;i<s.size();i++)
    {
    	bool flag=true;
    	for(int j=0,k=i;j<m.size();j++,k++)
    	{
    		if(check(m[j],s[k])==false)//检查所枚举的字符串
    		{
    			flag=false;
    			break;
			}
		}
		if(flag==true)
		{
			ans++;
			if(id==-1)
			{
				id=i;
			}
		}
	}
	if(ans==0) cout<<id;
	else cout<<ans<<" "<<id;
	return 0;
} 
```

---

## 作者：Tracy_Loght (赞：5)

## 题目描述：

应该不需要了吧。就是找一个字符串的出现次数和位置（以类单词的形式查找，且不区分大小写）。

## 思路：

额，注意到这是普及题，大可以暴力。

---

**复杂度分析：**

> $1\leq $ 第一行**单词长度** $\leq10$。       
$1\leq $ 文章长度 $\leq10^6$。

很容易发现对于单词非常小，最最最多查找 $10^7$ 次。

---

得，每次先读入一个字符串，然后一次次判断是否相同即可。

注意先将其变换为小写或大写字母再计算。

## 代码片段：

单个字母改小写：

```cpp
if('A'<=s&&s<='Z')
    s=(int)(s-'A')+'a';
```

对于一串字符判断是否记录答案：

```cpp
for(int i=0;i<sl;i++) {
    if(s[i]==' ') f=1;
    else if(f==1){
        for(int j=0;j<vl;j++) {
            if(s[i+j]!=v[j]) break;
            if(j==vl-1){if(l==0) l=i+1;}
        }	
    }
}
```

---

## 作者：LotleTos (赞：3)

## 思路
- 先把句子和单词全转小写。
- 遍历句子，如果是字母，则把这个字母加入字符串 $dc$ 中，如果不是，则判定为 $dc$ 是个完整的单词，执行下面的操作，接着 $dc$ 清空。
- 对于每个单词，先计数器加一，再判断是不是给定的单词，如果是，就判断是不是第一次出现，如果是，记录当前位置。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int sum=0,wz=-1;
	string a,b;
	getline(cin,b);
	for(int i=0;i<b.size();i++){
		if(b[i]<='Z'&&b[i]>='A'){
			b[i]+='a'-'A';
		}
	}//单词转小写 
	getline(cin,a);
	string dc="";
	for(int i=0;i<a.size();i++){
		if(a[i]<='Z'&&a[i]>='A'){
			a[i]+='a'-'A';
		}//句子转小写 
		if(a[i]!=' '){
			dc+=a[i];
		}//加入dc 
		else{
			if(dc==b){
				sum++;
				if(wz==-1){
					wz=i-dc.size();
				}
			}
			dc="";
		}
	}
	if(dc==b){
		sum++;
		if(wz==-1){
			wz=a.size()-dc.size();
		}
	}
	if(sum){
		cout<<sum<<" "<<wz;
	}
	else{
		cout<<-1;
	}
}
```

---

## 作者：ClV_Csy (赞：2)

# P1308 [NOIP2011 普及组] 统计单词数
## 题意
给定两个字符串 $a$ 和 $b$，求出 $a$ 在 $b$ 中以单词的形式出现了几次以及第一次出现时的位置。
## 思路
读入本题数据，如果使用 `cin`，会导致只能读入两个不带空格的字符串，无法完整读入。因此，我们可以使用 `getline(cin, )`，它可以读入完整的**一行**字符串。

```cpp
string a, b;
getline(cin, a);
getline(cin, b);
```

由于匹配字符串不区分大小写，所以考虑将 $a$ 和 $b$ 中的所有小写字符都转换成大写字符（当然都换成小写字符也可）。

```cpp
string a, b;
getline(cin, a);
getline(cin, b);
for (int i = 0; i < a.size(); i++) {
	if (a[i] >= 'a' && a[i] <= 'z') {
		a[i] -= 32; //小写转大写
	}
}
for (int i = 0; i < b.size(); i++) {
	if (b[i] >= 'a' && b[i] <= 'z') {
		b[i] -= 32; //小写转大写
	}
}
```

接下来是拆分出 $b$ 中的每一个单词。可以以空格为分界线，划分出几个区域，每个区域就是一个单词。

```cpp
string s[1000010]; //存储单词的字符串数组
string c; //用于临时存储单词
for (int i = 0; i < b.size(); i++) {
	if (b[i] == ' ') {
		s[++k] = c;
		c = ""; //清空
	} else {
		c += b[i];
	}
}
```

最后就是求出 $a$ 在 $b$ 中以单词的形式出现了几次以及第一次出现时的位置了。  
循环遍历字符串数组，如果匹配，则计数器自增 $1$。至于下标的处理，可以建立一个累加器，每处理完一个单词后，都需要给累加器自增此单词的长度再加上 $1$。这里的 $1$ 的长度是空格。

```cpp
int cnt = 0, ind = 0;
int sum = 0;
for (int i = 1; i <= k; i++) {
	if (s[i] == a) {
		cnt++;
		if (cnt == 1) {
			ind = sum; //累加器的值就是当前单词首字母的位置，注意：位置从0开始，所以不用加1
		}
	}
	sum += s[i].size() + 1;
}
```

## 代码

```cpp
#include <iostream>
using namespace std;
string s[1000010];
int k = 0;
int main() {
	string a, b;
	getline(cin, a);
	getline(cin, b);
	for (int i = 0; i < a.size(); i++) {
		if (a[i] >= 'a' && a[i] <= 'z') {
			a[i] -= 32;
		}
	}
	for (int i = 0; i < b.size(); i++) {
		if (b[i] >= 'a' && b[i] <= 'z') {
			b[i] -= 32;
		}
	}
	string c;
	for (int i = 0; i < b.size(); i++) {
		if (b[i] == ' ') {
			s[++k] = c;
			c = "";
		} else {
			c += b[i];
		}
	}
	int cnt = 0, ind = 0;
	int sum = 0;
	for (int i = 1; i <= k; i++) {
		if (s[i] == a) {
			cnt++;
			if (cnt == 1) {
				ind = sum;
			}
		}
		sum += s[i].size() + 1;
	}
	if (cnt == 0) {
		cout << -1;
	} else {
		cout << cnt << ' ' << ind;
	}
	return 0;
}
```

---

## 作者：TainityAnle (赞：1)

### 题意

给定模式串 $a$ 和匹配串 $b$。求模式串出现的次数和第一次出现的下标。

下标从 $0$ 开始。不区分大小写。

### 思路

匹配串可能有空格，所以要用 `getline()` 读入。

因为不区分大小写，所以读入后先把所有字符转成小写。有一个函数 `tolower()` 可以直接完成此操作。

如果直接用 `string` 类型的 `find()` 函数，会有问题。

若模式串为 `tainity`，匹配串有一个子串为 `tainityanle`，`find()` 函数会搜到它，但是它不满足条件。就挂了。

解决方法是，将模式串和匹配串的头和尾都加上一个空格字符。

这样一来，如果要查的单词是文章中某个单词的子串，那么是查不到的。因为包含模式串但不是模式串的单词首尾不都有空格。

将匹配串的首尾也加空格的原因是防止找不到处于第一个和最后一个单词的模式串。

然后用 `find()` 函数找即可。每次找到就把下标赋成本次找到的串的起始下标加一即可。如果找不到就输出答案，结束程序。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int cnt=0,flag=0;
int main() {
	getline(cin,a);
	getline(cin,b);
	for(int i=0; i<a.size(); i++)  a[i]=tolower(a[i]);
	for(int i=0; i<b.size(); i++)  b[i]=tolower(b[i]);
	a=" "+a+" ",b=" "+b+" ";
	if(b.find(a)==-1) {
		cout<<"-1"<<endl;
		return 0;
	} else {
		int cs=b.find(a);
		while(cs!=-1) {
			cnt++;
			if(flag==0) flag=cs;
			cs=b.find(a,cs+1);
		}
		cout<<cnt<<" "<<flag;
	}
	return 0;
}
```

---

## 作者：sieve (赞：0)

## 题解：[P1308](https://www.luogu.com.cn/problem/P1308)

## 思路

看到第一行单词长度这么小，我们直接进行暴力判断。就是在给出的文章中枚举一个起点逐字匹配即可。

不过注意输入的文章有空格，要用 `getline`。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int main()
{
	bool flag=true;
	int len1,len2,sum=0,wz=0,x=0;
	getline(cin,s1);
	getline(cin,s2);
	len1=s1.size();
	len2=s2.size();
	for(int i=0;i<len1;i++) {
		if(s1[i]>='a'&&s1[i]<='z') s1[i]-=32;
	}
	for(int i=0;i<len2;i++) {
		if(s2[i]>='a'&&s2[i]<='z') s2[i]-=32;
	}
	for(int i=0;i<len2;i++) {
		if(s2[i]==' ') continue;
		else {
			int j;
			string s="";
			for(j=i;j<len2&&s2[j]!=' ';j++) {
				s+=s2[j];
			}
			if(s==s1) 
			{
				sum++;
				if(flag==true) {
					wz=i;
					flag=false;
				}
			
			}
			while(s2[j]==' ') j++;
			i=j-1;
		}
	}
	if(flag==false) cout<<sum<<" "<<wz;
	else cout<<"-1";
	return 0;
}
```

---

## 作者：sea_bird (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1308)。

## 前置知识

由于是输出一串单词，因此其中包含空格，要用 `getline(cin,str);` 来输入。

# 题目分析

求出一个单词的第一次出现时间以及出现次数。输入完之后直接遍历一次字符串，由于每个单词，除了开头结尾外，都是从一个空格到另一个空格，因此可以从这点入手对其中每个单词的字符，一个个与目标单词的字符比对，`toupper(str[i+j-2])` 中函数的作用是将小写字母都转换成大写字母，方便比对。

```cpp
#include<bits/stdc++.h>

using namespace std;
bool tf=true;
int main(){
	int j;
	string ch;
	string str;
	int cnt=0,w;
	getline(cin,ch);
	getline(cin,str);
	for(int i=1;i<=str.size();i++){
		tf=true;
		for(j=1;j<=ch.size();j++){
			if((i-1)>0&&str[i-2]!=' '){
				tf=false;
				break;
			}
			
			if(toupper(str[i+j-2])!=toupper(ch[j-1])){	
				tf=false;
				break;
			}
			
		}
		j-=1;
		if(tf&&cnt==0){//前面未出现相同单词
			w=i-1;
		}
		if(tf&&str[i+j-1]==' ')cnt++;//注意要有空格隔开才算
	}
	if(cnt>0){//有解
		cout<<cnt<<" "<<w<<endl;
	}
	else{//无解
		cout<<-1<<endl;
	}
	return 0;
}
```

---


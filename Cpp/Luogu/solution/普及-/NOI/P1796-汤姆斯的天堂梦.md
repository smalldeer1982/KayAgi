# 汤姆斯的天堂梦

## 题目描述

汤姆斯生活在一个等级为 $0$ 的星球上。那里的环境极其恶劣，每天 $12$ 小时的工作和成堆的垃圾让人忍无可忍。他向往着等级为 $N$ 的星球上天堂般的生活。

有一些航班将人从低等级的星球送上高一级的星球，有时需要向驾驶员支付一定金额的费用，有时却又可以得到一定的金钱。

汤姆斯预先知道了从 $0$ 等级星球去 $N$ 等级星球所有的航线和需要支付（或者可以得到）的金钱，他想寻找一条价格最低（甚至获得金钱最多）的航线。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 100$，$1 \le K_i \le 100$。

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/x085ukra.png)

## 样例 #1

### 输入

```
3
2
1 15 0
1 5 0
3
1 -5 2 10 0
1 3 0
2 40 0
2
1 1 2 5 3 -5 0
2 -19 3 -20 0```

### 输出

```
-1```

# 题解

## 作者：Rainey (赞：34)

一道比较简单的动态规划题，类似于数塔，有从上到下和从下到上两种解法，以i为等级，j为编号，L表示第i级编号j的星球到第i-1级编号k动态规划方程：f[i,j]=min{f[i-1,j]+L}

ps:题目有点小瑕疵，第二段应为“接下来的Ki行中第j行依次表示与等级为i，编号为j的星球相连的等级为i-1的星球的编号和此航线需要的费用（正数表示支出，负数表示收益，费用的绝对值不超过1000）。"

```cpp
#include<cstdio>
#include<climits>
using namespace std;
int f[200][200]={0};
int main()
{
    int n,a;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&a);
        for(int j=1;j<=a;++j)
        {
            f[i][j]=INT_MAX-1000;//初始化，防止溢出
            int b,c;
            scanf("%d",&b);
            while(b!=0)
            {
                scanf("%d",&c);
                f[i][j]=f[i-1][b]+c<f[i][j]?f[i-1][b]+c:f[i][j];//DP
                scanf("%d",&b);
            }
        }
    }
    int min=INT_MAX;
    for(int i=1;i<=a;++i)//在最后一行中找最小值
        min=f[n][i]<min?f[n][i]:min;
    printf("%d",min);
    return 0;
}
```

---

## 作者：doby (赞：16)

我想短时间内不会出现和我一样的方法的......

题目与图片说的很明显了，因为第一层只有一个点，所以就是找一条从第一个点到最后一层任意一点的最短路

但是这道题里有负权，并且在点最多的情况下可能达到10000个，所以要用SPFA(Bellman-Ford)

给点定好序号，接着连边的时候就按照存好的序号开始连就行了

```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n,k[110],d[110][110],c[110][110],xx,yy,x,y,z,out,fh,cot=1,cnt,top,ans=2133333333,qout[10010],head[10010],dis[10010];
bool done[10010];
char cc;
queue<int>q;
struct Edge
{
	int to,next,dis;
}e[1000010];
void add(int x,int y,int z)
{
	cnt++,
	e[cnt].next=head[x],
	e[cnt].to=y,
	e[cnt].dis=z,
	head[x]=cnt;
}
void SPFA(int s)//能跑负权的最短路算法……
{
    for(int i=1;i<=cot;i++){dis[i]=2133333333;}
    dis[s]=0,done[s]=1;
    q.push(s);
    while(!q.empty())
    {
        x=q.front(),done[x]=0;q.pop();
        for(int i=head[x];i;i=e[i].next)
        {
            y=e[i].to;
            if(dis[y]>dis[x]+e[i].dis)
            {
                dis[y]=dis[x]+e[i].dis;
                if(!done[y])
                {
                    done[y]=1;
                    q.push(y);
                }
            }
        }
    }
}
int main()
{
	scanf("%d",&n);
	c[0][1]=cot;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&k[i]);
		for(int j=1;j<=k[i];j++)
		{
			cot++,
			c[i][j]=cot;//给每个点附上序号
		}
		for(int j=1;j<=k[i];j++)
		{
			while(1)
			{
				scanf("%d",&xx);
				if(!xx){break;}
				scanf("%d",&yy);
				add(c[i-1][xx],c[i][j],yy);//连边
			}
		}
	}
	SPFA(1);
	for(int i=1;i<=k[n];i++){ans=ans<dis[c[n][i]]?ans:dis[c[n][i]];}//在最后一层的序号代表的节点中找最短路
	printf("%d",ans);
	return 0;
}
```
# 关于SPFA
 - 它死了

---

## 作者：Elaina_7 (赞：13)

## 这是DP题
虽然这道题长得像图论~~（spfa的确可以）~~，但是它最简单高效的方法是动规。

这道题的状态转移方程很好找，用i表示星球的等级，j表示星球编号，c为代价，可得f[i][j]=min(f[i - 1][j] + c，f[i][j])，然后这道题就迎刃而解了QWQ；

代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
int n, a, b, c, f[2000][2000]={0};
int main()
{
	scanf("%d", &n);//n级 
	for(int i = 1; i <= n; i ++)
	{
		scanf("%d", &a);//i级星球个数 
		for(int j = 1; j <= a; j ++)//枚举每个星球 
		{
			f[i][j] = 0x7ffffff;//初始化（不能打在外面，会错） 
			scanf("%d", &b);//i-1级的b号星球到i级j号星球 
			while(b != 0)//终止条件 
			{
				scanf("%d", &c);//代价 
				f[i][j] = std::min(f[i - 1][b] + c, f[i][j]);//找i-1级的b号星球到i级j号星球的最小代价（ 不想打命名空间了QWQ 
				scanf("%d", &b);
			}
		}
	}
	int minn = 0x7ffffff;
	for(int i = 1; i <= a; i ++)
	minn = std::min(f[n][i], minn);//求最小
	printf("%d", minn);
	return 0;
}
```


---

## 作者：深海鱼的眼泪 (赞：5)

对于等级为i的第j个星球，l表示与它相连的等级为i-1的星球编号，m表示这条线的支出，d[j]表示到这个星球的最小支出，t表示上一等级的支出

d[j]=min(d[j],t[l]+m);

需要注意的是用t表示上一等级的支出，所以要在每一等级的最小支出算完之后把d[j]放到t[j]里。





```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int m,l,d[110],t[110];    
int main(){
    int n,i,j,k;
    scanf("%d",&n);
    for (i=1;i<=n;i++){
        scanf("%d",&k);
        for (j=1;j<=k;j++){
            d[j]=10000000;        //将d[j]初始化 
            scanf("%d",&l);
            while (l!=0){
                scanf("%d",&m);
                if (d[j]>t[l]+m) d[j]=t[l]+m;
                scanf("%d",&l);
            }
        }
        for (j=1;j<=k;j++){
            t[j]=d[j];
        }
    }
    int ans=1000000;
    for (i=1;i<=k;i++){
        if (ans>d[i]) ans=d[i];
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Enterpr1se (赞：4)

（本蒟蒻第一次写题解，写的不好请见谅）  
这是一道非常基础的动归题，看题解区有dalao说可以从上到下写，但是我不会啊。（叹气）  
>关于动态规划（DP）  
动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。  
资料来源：百度百科  
说人话，其实就像是你在做数学计算题的时候利用上一道题的结果推出下一道题的答案。

~~虽然这题十分简单~~但是还是单贴一下转移方程吧：  
$ans(i,j)=min(ans(i,j),ans(i-1,root(i,j))+cost(i,j,root(i,j))$  
好了 代码附上。
```cpp
//lg-1796
#include<iostream>
using namespace std;
int k[105]/*同题目中Ki*/,r[105][105][105]/*联通第i层第j个星球的第k个i-1层星球编号*/,c[105][105][105]/*c[i][j][k]为r[i][j][k]对应的花费*/,ans[105][105],n,ri,ci,f_ans=214783647;
int main(){
	ios::sync_with_stdio(false);
	cin>>n;//输入层数
	for(int i=1;i<=n;++i){
		cin>>k[i];//输入ki
		for(int j=1;j<=k[i];++j){
			while(true){
				cin>>ri;//输入联通的下层星球
				if(!ri) break;
				cin>>ci;//输入对应编号
                                //赋值
				++r[i][j][0];
				r[i][j][r[i][j][0]]=ri;
				c[i][j][r[i][j][0]]=ci; 
			}
		}
	}
	for(int i=1;i<=n;++i){//从第1层开始规划
		for(int j=1;j<=k[i];++j){//规划第i层的第j个星球
			ans[i][j]=214783647;//初始化
			for(int no=1;no<=r[i][j][0];++no){//依次规划每条路径
				ans[i][j]=min(ans[i][j],ans[i-1][r[i][j][no]]+c[i][j][no]);//在当前解和（上一层联通城市最优解+上行花费）中选择最优者
			}
		}
	}
	for(int i=1;i<=k[n];++i) f_ans=min(f_ans,ans[n][i]);//选取第n层中的最优解
	cout<<f_ans;
	return 0;
}
```


---

## 作者：peterwuyihong (赞：2)

# SPFA跑负权边
看到一个图，首先反应就是最短路，然后就想到了SPFA，关键难得是连边，你可以将其变成一个数，在做SPFA
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
long long ver[1000001],edge[1000001],head[1000001],next[1000001],tot;
bool v[1000001];
long long q[1000001],l=1,r;
long long dis[1000001],ans=LLONG_MAX;
long long turn(long long x,long long y)//变成一个数
{
	return x*500+y;
}
void add(long long x,long long y,long long z)
{
	ver[++tot]=y;
	edge[tot]=z;
	next[tot]=head[x];
	head[x]=tot;
}
void SPFA()
{
	memset(dis,0x3f,sizeof dis);
	dis[1]=0;
	q[++r]=1;
	while(l<=r)
	{
		long long x=q[l++];
		v[x]=0;
		for(long long i=head[x];i;i=next[i])
		{
			long long y=ver[i],z=edge[i];
			if(dis[y]>dis[x]+z)
			{
				dis[y]=dis[x]+z;
				if(!v[y])v[y]=1,q[++r]=y;
			}
		}
	}
}
signed main()
{
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++)
	{
		scanf("%lld",&k);
		for(long long j=1;j<=k;j++)
		{
			long long from,q;
			do
			{
				scanf("%lld",&from);
				if(from==0)break;
				scanf("%lld",&q);
				add(turn(i-1,from),turn(i,j),q);
			}while(from);//哲学连边
		}
	}
	SPFA();
//	for(long long i=1;i<=k;i++)
//	cout<<dis[turn(n,i)]<<' ';
	for(long long i=1;i<=k;i++)
	ans=min(ans,dis[turn(n,i)]);//比较dis[n层i个]
	printf("%lld",ans);
}

```
# 其实还可以用BFS做
将第一个点入队，每次扩展，记录路径长度最小值，在n层输出

---

## 作者：asuldb (赞：2)

既然有dp标签，这个图一看就是一个DAG，这个题正解不应该是拓扑排序之后跑一个dp吗

于是写了一发鬼畜的拓扑排序

这里的点有两种状态，一个是它是第几级，一个是它是这一级里的第几个，我们有开一个二维数组的必要吗，其实我们完全可以开两个map，让pair和int相互映射一下，我们就可以把这个点压成一维了

至于dp的方程式就比较简单了$d[i]=min(d[j]+cost_{i,j})$($j$为$i$上一层的某个点)

代码如下
```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<cstdio>
#include<map>
#define re register
#define maxn 100001
#define mp make_pair
#define inf 99999999
using namespace std;
typedef pair<int,int> pii;
map<pii,int> m1;
map<int,pii> m2;
int r[maxn],q[maxn],d[maxn];
int head[maxn];
int n,m,num,k;
struct node
{
	int v,nxt,w;
}e[maxn];
inline void add_edge(int x,int y,int z)
{
	e[++num].v=y;
	e[num].w=z;
	e[num].nxt=head[x];
	head[x]=num;
}
inline int read()
{
    char c=getchar();
    int x=0,r=1;
    while(c<'0'||c>'9')
    {
        if(c=='-') r=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
      x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x*r;
}
int main()
{
	m=read();
	m1[mp(0,1)]=++n;
	m2[n]=mp(0,1);
	int p,t;
	for(re int i=1;i<=m;i++)
	{
		k=read();
		for(re int j=1;j<=k;j++)
		{
			m1[mp(i,j)]=++n;
			m2[n]=mp(i,j);
			while(1)
			{
				p=read();
				if(!p) break;
				t=read();
				add_edge(m1[mp(i-1,p)],n,t);
				r[n]++;
			}
		}
	}
	q[1]=1;
	int tot=1;
	for(re int i=1;i<=n;i++)
		d[i]=inf;
	d[1]=0;
	for(re int i=1;i<=tot;i++)
	{
		for(re int j=head[q[i]];j;j=e[j].nxt)
		{
			r[e[j].v]--;
			d[e[j].v]=min(d[e[j].v],d[q[i]]+e[j].w);
			if(!r[e[j].v]) q[++tot]=e[j].v;
		}
	}
	int ans=inf;
	for(re int i=n;i;i--)
	if(m2[i].first==m) ans=min(ans,d[i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：编程客 (赞：1)

## 难(shui)题
### 思路：
- 就是最短路问题啦（也可以用动态规划），我是用最短路的，如果用其他方法就跳过此题解
- 此题就是建图有点麻烦，但总体不算难。我是把每一个点都重新编一个号，再进行一次 spfa 就可以了。
- 我用的是 spfa ，大佬可以用 dij（主要是我不想打）
- 代码风格与大部分人不一样，但将就着看吧。
### 代码：
```cpp
#include <iostream>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
struct edge
{
	int v,w;
};
int n,k[105],a[105][105],cnt;
int s[10005],vis[10005];
vector<edge> g[10005];
int main()
{
	memset(s,63,sizeof(s));
	scanf("%d",&n);
	a[0][1]=++cnt;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&k[i]);
		for(int j=1;j<=k[i];j++) //重新编号 
		{
			cnt++;
			a[i][j]=cnt;
		}
		int u,w;
		for(int j=1;j<=k[i];j++)
		{
			while(scanf("%d",&u))
			{
				if(u==0) break;
				scanf("%d",&w);
				g[a[i-1][u]].push_back((edge){a[i][j],w}); //建边 
			}
		}
	}
	//spfa模板 
	queue<int> q;
	q.push(1);
	s[1]=0;
	vis[1]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=0;i<g[u].size();i++)
		{
			int v=g[u][i].v,w=g[u][i].w;
			if(s[v]>s[u]+w)
			{
				s[v]=s[u]+w;
				if(vis[v]==0)
				{
					vis[v]=1;
					q.push(v); 
				}
			}
		}
	} 
	// 找到最优解 
	int ans=0x3f3f3f3f;
	for(int i=1;i<=k[n];i++)
	{
		ans=min(ans,s[a[n][i]]);
	}
	// 输出 
	printf("%d",ans);
	return 0;
}
```
#### 谢谢观赏！

---

## 作者：longint2016 (赞：1)

一道DP

可以设从初始星球带哦第I层J号星球的最小花费为F[I,J]，则很容易得出状态转移方程：


```cpp
F[I,J]:=MIN(F[I-1,K]+COST)
var 
  n,i,j,x,y,min:longint;
  k:array[0..100]of longint;
  t:array[0..100,0..100]of longint;
begin
  assign(input,'par.in');reset(input);
  assign(output,'par.out');rewrite(output);
  readln(n);
  for i:=1 to n do
  begin
    readln(k[i]);
    for j:=1 to k[i] do
    begin
      t[i,j]:=maxlongint;
      while 1=1 do begin
        read(x);
        if x=0 then break;
        read(y);
        if t[i-1,x]+y<t[i,j] then t[i,j]:=t[i-1,x]+y;
      end;
    end;
  end;
  min:=maxlongint;
  for i:=1 to k[n] do
    if t[n,i]<min then min:=t[n,i];
  writeln(min);
  close(input);close(output);
end.
```

---


# 单词分类

## 题目描述

Oliver 为了学好英语决定苦背单词，但很快他发现要直接记住杂乱无章的单词非常困难，他决定对单词进行分类。

两个单词可以分为一类当且仅当组成这两个单词的各个字母的数量均相等。

例如 $\verb!AABAC!$，它和 $\verb!CBAAA!$ 就可以归为一类，而和 $\verb!AAABB!$ 就不是一类。

现在Oliver有 $N$ 个单词，所有单词均由大写字母组成，每个单词的长度不超过 $100$。你要告诉 Oliver 这些单词会被分成几类。


## 说明/提示

- 对于 $70\%$ 的数据满足 $1\le N \le 100$；
- 对于 $100\%$ 的数据满足 $1\le N \le 10000$。

## 样例 #1

### 输入

```
3 
AABAC 
CBAAA 
AAABB```

### 输出

```
2```

# 题解

## 作者：子谦。 (赞：87)

#当当当当，新方法咯

首先定一个map数组，然后将每个读入的字符串进行内部排序，使小的字符在前，如果没有出现过，组数+1，定义为出现过

```cpp
#include<algorithm>
#include<iostream>
#include<map>
using namespace std;
map<string,bool>z;//存储字符串是否出现过
string a;
int n,sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a;
        sort(a.begin(),a.end());//排序
        if(!z[a]){//如果没有出现过，组数+1
            sum++;
            z[a]=1;
        }
    }
    cout<<sum;
    return 0;
}
```
#谢谢观赏，不喜勿喷


---

## 作者：PTC06 (赞：30)

话说不难啊，为什么只有120人通过...（还有就是为什么用排序的题解没有一个用快排来排字符串内部？Pascal的除外）

思路很简单：

读入N及N个字符串。然后每一个字符串内部都要进行一次排序，每个字符串内部排好之后，再将全部字符串排一遍。这样下来，全部组成这个字符串的字母的数量相等的字符串就都应是相邻的了。所以我们只需统计，有多少个相邻的字符串是不一样的，就可以统计出有多少种不同的了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long i,n,sum,j,k;
string s[100000];
char t;
int main()
{
    cin>>n;                    //先输入N
    for (i=1;i<=n;i++)
    {
        cin>>s[i];                    //读入N个字符串
        sort(s[i].begin(),s[i].end());    //每一个字符串内部进行排序
    }
    sort(s+1,s+n+1);               //再将所有的字符串排序一次
    for (i=1;i<=n;i++) if (s[i-1]!=s[i]) sum++;                //最后，只需统计有多少个字符串互不相同就行了。有些人是一开始将sum定义为1，然后最后又减去一再输出，这样也没问题，只不过没必要啊。s[0]是空的，不可能跟s[1]一样，这样不就是第一种了吗...和将sum的初始值定为1效果一样。
    cout<<sum;         //输出
}
```

---

## 作者：Not_A_Number (赞：26)

这一题有一个我自认为比较邪恶的做法，就是在输入单词时直接把单词里面的字母升序排列（降序也可以，但是sort默认升序，用着方便就行）。这样一来，如果两个单词属于“同一类”，那么经过操作后他们就一模一样了。然后再对所有的单词重新排序（当然还是用sort），然后顺序查找：找到几个连续相同的“单词串”，就可以分成几类。

```cpp
？#include<algorithm>//sort的库？
？#include<iostream>？
？#include<cstring>？
？#include<string>//stl字符串？
？using namespace std;？
？int n,ans;？
？char xx[103];？
？string N[10003];？
？int main()？
？{？
？    cin>>n;？
？    for(int i=0;i<n;i++)？
？    {？
？        cin>>N[i];？
？        for(int j=0；j<N[i].length()；j++)？
？        xx[j]=N[i][j];//用字符数组存储输入的string？
？        sort(xx,xx+N[i].length（）);//开卦无极限~~~？
？        for(int j=0；j<N[i].length（）；j++)？
？        N[i][j]=xx[j]；//排序后放回原string？
？    }？
？    sort（N,N+n）；//将所有单词按升序排列？
？    //注意只有string类型可以这么写，c++中字符数组不能直接用运算符比较？
？    for（int i=1；i<n；i++）？
？        if（N[i]!=N[i-1]）ans++;//计算分类数？
？    cout<<ans+1;//Perfect printing？
？}？
自觉不抄题解，共创美好洛谷！
自觉不抄题解，共创美好洛谷！
自觉不抄题解，共创美好洛谷！
```

---

## 作者：Anguei (赞：14)

这道题多简单啊！

既然组成字符串的字母一样字符串就属于同一类，那么就可以用 STL 中的 std::sort 算法**排序**一下，直接判断是否与之前出现过的相等就可以了。

这样会在判断方面有点麻烦。所以更简单的方法是使用~~红黑树~~ STL 中的 std::set 定义一个字符串集合并**自动判重**。

最终答案就是集合的大小。

由于 std::sort **默认快排**，std::set 使用**红黑树**实现时间复杂度为**对数阶**，所以不需要考虑优化，一定不会超时的。

附上代码：

```cpp
//【P1808】单词分类_NOI导刊2011提高（01） - 洛谷 - 100
#include <set>
#include <string>
#include <iostream>
#include <algorithm>

int main() {
    register std::string s;
    std::set<std::string> set;// 定义集合
    register unsigned n;
    std::cin >> n;
    for (register unsigned i = 0; i ^ n; ++i) {
    // 上一句等价于：for (register unsigned i = 0; i < n; ++i) {
        std::cin >> s;
        std::sort(s.begin(), s.end());
        set.insert(s);
    }
    std::cout << set.size() << std::endl;// 集合大小即为答案
}
```
当然，这道题也可以用键值一一对应的 std::map ，具体方法已在楼下题解当中出现过，这里不再赘述。


---

## 作者：wubaiting2020 (赞：8)

# 一种神奇的方法……  
把字符排序后丢到set里，然后set去重后出来的大小就是答案……
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<set>
#define LL long long
using namespace std;
int n,num;
char ch[105];
set <string> sett;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",ch);//读入字符数组 
		sort(ch,ch+strlen(ch));//排序 
		string s=ch;//将其转为字符串 
		sett.insert(s);//放在sett里去重……
	}
	printf("%d",sett.size());//输出去重后的大小…… 
	return 0;
}


```
可能是比较短的代码之一吧QAQ


---

## 作者：徐熙凯 (赞：8)

###### 新题解,了解一下


------------

```cpp
#include <bits/stdc++.h>  
using namespace std;   
string s;   
long long a[10001][27]={0},b[10001];  
long long n,m,i,j,k,h=0;   //这是一个坏习惯，勿学
int main()    
{  

  	scanf("%lld",&n);  
    
	for(i=1;i<=n;++i)  
	{  
	    cin>>s;   
		 for(j=0;j<s.size();++j)   
			 a[i][int(s[j]-'A')]++;//有点类似桶的思想  
	}
	
	for(i=1;i<=n;++i)   
		for(j=0;j<27;++j)  
			b[i]=b[i]*150+a[i][j];//将标记转化为数值,注意乘号以后的数字一定要大于100,不能等于100,否则会出错.   
	 
	sort(b+1,b+n+1);//排序,比较 
	k=b[1],h=1;  
	
	for(i=2;i<=n;++i)//找不同的字符串
		if(b[i]!=k)
			h++,k=b[i];
			
	printf("%lld",h);
	return 0; //好习惯
}
```


---

## 作者：Dream_It_Possible (赞：3)

好吧,我承认,不用sort进行总的排序在判断,会超时,尽管分数也不低(90分)

先上90分代码,初学者想拿高分,请看,神犇等dalao跳过。



```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
string s[10005];
int main()
{
    std::ios::sync_with_stdio(false);
    int n,i,j,k,sum=1,bo=0;
    cin>>n;
    for (i=0;i<n;i++)
    {
        bo=0;
        cin>>s[i];//输入
        sort (s[i].begin(),s[i].end());//按字典序将每个单词排序
        for (j=0;j<i;j++)//查找是否有与前面相同的 
        {
            if (s[i]==s[j])
            {
                bo=1;
                break;
            }    
        }    
                if (bo==0)//如果没有与其他相同,自成一类
        {
            sum++;//类数加一
        }
    }
    cout<<sum-1;//输出,第一个多加一个一,现在减掉
    return 0;
}
```
满分代码:
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
string s[10005];
int main()
{
    int n,i,j,k,sum=1;
    cin>>n;
    for (i=0;i<n;i++)
    {
        cin>>s[i];//输入
        sort (s[i].begin(),s[i].end());//按字典序将每个单词排序
    }
    sort (s,s+n);//n个单词总体排序
    for (i=1;i<n;i++)
    {
        if (s[i]==s[i-1])//如果有同类的
        sum=sum;//不变
        else//否则
        sum=sum+1;//多出一类,加一。
    }
    cout<<sum;//输出
    return 0;
}
```

---

## 作者：zhagoodwell (赞：2)

使用唯一质因数分解定理
每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的因数，叫做这个合数的分解质因数。
并且，每个合数能够且仅仅能够被分解为唯一一组质因数的乘积。
比如：
150=2×3×5²
这里的质因数为：2、3、5、5
这四个数的全排列有多种，但是所有的排列的乘积是一样的。
因此我们可以先打一个素数表
2对应A，3对应B,……一直到Z
对每一个单词进行乘积计算，用long long存储，结果可以对一个大质数如(2305843009213693951LL)进行取余，也可
对乘积的结果自动溢出->相当于对2^64模运算
AC代码
```cpp
# include <stdio.h>
# include <string.h>
# include <math.h>
# include <algorithm>
typedef long long LL; //素数表
using namespace std;
# define N  10001
# define P  400
int prime[P];
LL KEY[N];
char S[101];
int main()
{
    int i,j,k,n,Q;
    LL sum,num=0;
    for(k=0,i=2,Q=(int)sqrt(P)+1; i<Q; i++)
        if(!prime[i])for(j=i*i,prime[k++]=i; j<P; j+=i)prime[j]=1;
    do{if(!prime[i])prime[k++]=i;}while(++i<P);
    /***素数打表完毕 ******/
 // for(i=0;i<k;i++)printf("%d ",prime[i]);
    scanf("%d ",&n);
    j=0;
    while(n--)
    {
      scanf("%s",S);
      for(i=0,sum=1;S[i];i++)
      {
          sum=sum*prime[S[i]-'A'];
      }
      KEY[j++]=sum;
    }
    sort(KEY,KEY+j);
    num=1;
    for(i=1;i<j;i++)
    {
        if(KEY[i]!=KEY[i-1])num++;
    }
    printf("%lld\n",num);
    return 0;
}
```


---

## 作者：ljc20020730 (赞：2)

这个程序较长，我把思路说下，一一对应的话就交给你来完成了。

对于不同的单词，我们要求每个单词中间的每个字母数量计算量较大，而且不好实现需要最多循环100！次。既然我们只需要比较是不是同类单词那么我们就可以把原来的单词破坏掉自动生成‘排序单词’For Example，ABCDD 和DDBAC是等价的排序单词，就是题目中的同类单词。对于这样我们可以编写子函数qsortforchar了（好好学学英语吧）这个的意思是快速排序字符类型。当然更加形象些就是qsortforword，当然普通的快排是对于数字的，字符可不可以快排呢？当然可以。有兴趣的话可以试试在pascal中打印下

Writeln(‘A’<’B’); writeln(‘A’=’A’);writeln(‘A’>’B’);

输出应为 TRUE TRUE FALSE

给出快排程序：qsortforchar



```cpp
procedure qsortforchar(l,r:longint);
var mid,t:char;
    i,j:longint;
begin
i:=l; j:=r; mid:=w[(l+r)div 2];
repeat
 while w[i]<mid do inc(i);
 while w[j]>mid do dec(j);
 if i<=j then begin t:=w[i];w[i]:=w[j];w[j]:=t; inc(i); dec(j);end;
until i>j;
if i<r then qsortforchar(i,r);
if j>l then qsortforchar(l,j);
end;
```
同理可以有对于字符串的排序qsortforstring；
```cpp
procedure qsortforstring(l,r:longint);
var i,j:longint; mid,t:string;
begin
 i:=l; j:=r; mid:=a[(l+r)div 2];
 repeat
  while a[i]<mid do inc(i);
  while a[j]>mid do dec(j);
  if i<=j then begin
  t:=a[i]; a[i]:=a[j]; a[j]:=t;
  inc(i); dec(j);
  end;
 until i>j;
 if i<r then qsortforstring(i,r);
 if j>l then qsortforstring(l,j);
end;
```
当然重要的一步是用函数ff把字符串转存为数组便于快排。程序段如下：
```cpp
function ff(s:string):string;
var i:longint;
    u:string;
begin
 for i:=1 to length(s) do w[i]:='0';
 for i:=1 to length(s) do
  w[i]:=s[i];
 qsortforchar(1,length(s));
 u:='';
 for i:=1 to length(s) do
 u:=u+w[i];
 exit(u);
end;]
```
在主程序中直接调用即可
for i:=1 to n do a[i]:=ff(a[i]);

好像有个问题怎么样去重排序？

当然我们建立b数组来存确定是单一的字符串，

再逐个筛选即可。不在赘述见代码段：

```cpp
qsortforstring(1,n);
 b[1]:=a[1];ans:=1;
 for i:=2 to n do
  if a[i]<>a[i-1] then
  begin
   inc(ans);
   b[ans]:=a[i];
  end;
```
这样程序就呼之欲出了
```cpp
type th=record
s,num:integer;
end;
var  w:array[0..100]of char;
     a,b:array[1..10000]of string;
     i,j,n,ans:longint;
procedure qsortforchar(l,r:longint);
var mid,t:char;
    i,j:longint;
begin
i:=l; j:=r; mid:=w[(l+r)div 2];
repeat
 while w[i]<mid do inc(i);
 while w[j]>mid do dec(j);
 if i<=j then begin t:=w[i];w[i]:=w[j];w[j]:=t; inc(i); dec(j);end;
until i>j;
if i<r then qsortforchar(i,r);
if j>l then qsortforchar(l,j);
end;
function ff(s:string):string;
var i:longint;
    u:string;
begin
 for i:=1 to length(s) do w[i]:='0';
 for i:=1 to length(s) do
  w[i]:=s[i];
 qsortforchar(1,length(s));
 u:='';
 for i:=1 to length(s) do
 u:=u+w[i];
 exit(u);
end;
procedure qsortforstring(l,r:longint);
var i,j:longint; mid,t:string;
begin
 i:=l; j:=r; mid:=a[(l+r)div 2];
 repeat
  while a[i]<mid do inc(i);
  while a[j]>mid do dec(j);
  if i<=j then begin
  t:=a[i]; a[i]:=a[j]; a[j]:=t;
  inc(i); dec(j);
  end;
 until i>j;
 if i<r then qsortforstring(i,r);
 if j>l then qsortforstring(l,j);
end;
begin
{assign(input,'word');
assign(output,'word');
reset(input);
rewrite(output);}
 readln(n);
 for i:=1 to n do readln(a[i]);
 for i:=1 to n do a[i]:=ff(a[i]);
 qsortforstring(1,n);
 b[1]:=a[1];ans:=1;
 for i:=2 to n do
  if a[i]<>a[i-1] then
  begin
   inc(ans);
   b[ans]:=a[i];
  end;
 writeln(ans);
{close(input);
close(output);}
end.

```

---

## 作者：xiaofan (赞：2)

用计数方法，一点点算，不要急~~

```delphi

var
 i,j,k,l,m,n:longint;
 s:string;c:char;
 a:array[1..10000,'A'..'Z'] of integer;b:boolean;
function tj(i,j:longint):boolean;
 var
  l:char;
 begin
  for l:='A' to 'Z' do
    if a[i,l]<>a[j,l] then exit(false);
  exit(true);
 end;
begin
 readln(n);m:=0;
 for i:=1 to 10000 do
  for c:='A' to 'Z' do
   a[i,c]:=0;
 for i:=1 to n do
  begin
  readln(s);
  for j:=1 to length(s) do
    inc(a[i,s[j]]);
  b:=false;
  for j:=1 to i-1 do
   if tj(j,i) then begin b:=true;break;end;
  if not b then inc(m);
 end;
 writeln(m);
end.

```

---

## 作者：Jelly_Goat (赞：1)

大家用的方法都太好了！！  
蒟蒻小金羊来发一篇玄学堆排。
~~STL大法好~~！  
（附有核心code详解，完整code）

------------

## 核心：两次排序，第一次自我排序，第二次整体排序。  
### 核心code1:  
```cpp
string strsort(string str)
{
	int len=str.size();
	for (int temp=0;temp<len;temp++)
	{
		q2.push(str[temp]);
	}
	string str2="";
	for (int temp=0;temp<len;temp++)
	{
		char tempchar=q2.top();
		str2=str2+tempchar;
		q2.pop();
	}
	return str2;
}
```
### 解释：  
这个函数就是用来自我排序的函数，  
把字符串的字符抽出来，**放进优先队列（小根堆）中**，  
利用小根堆自我维护的功能（自动排序），  
**再从小根堆里抽出来合成一个新的排好序的字符串返回。**

------------

### 核心code2:
```cpp
int main()
{
	/*以上都不是核心*/
	for (int i=1;i<=n;i++)
	{q1.push(strs[i]);}
	string strtemp=q1.top();q1.pop();
	for (int i=1;i<n;i++)
	{
		string temp=q1.top();q1.pop();
		if (temp!=strtemp){count++;}
		strtemp=temp;
	}
	/*以下都不是核心*/
}
```
### 解释：  
利用自我维护，往小根堆里放，再拿出来，  
**如果和上一次拿出来的不一样，类别count就++。**

------------

### Entire code:
```cpp
#include <iostream>//不想OI一场空，千万别用万能头 
#include <cstdio>//能不用cin就不用 
#include <queue>//优先队列
#include <string>
#include <cstring>
//不在OI的同学请用#include <bits/stdc++.h>
using namespace std;
priority_queue<string,vector<string>,greater<string> >q1;
priority_queue<char,vector<char>,greater<char> >q2;
//由于小金羊不会其他排序，发一个堆排吧...
//话说字符串堆排是不是太玄学了...
//其实原理极其简单，入堆，出堆，返回，搞定。
//然后做一个字符串的整体的堆排，就OK了。 
int n,count=1;
//整体变量
string strsort(string str)
{//字符串堆排，真玄学 
	int len=str.size();
	for (int temp=0;temp<len;temp++)
	{
		q2.push(str[temp]);
	}
	string str2="";//把要生成的字符串变成空的 
	for (int temp=0;temp<len;temp++)
	{
		char tempchar=q2.top();
		str2=str2+tempchar;
		q2.pop();
	}//生成完毕 
	return str2;//返回排好序的字符串 
}
int main()
{
	scanf("%d",&n);
	if (n==1){putchar('1');return 0;}
	//一个字符串还能有多少种啊 
	string strs[n+1];
	//第一个字符串就不要了 
	for (int i=1;i<=n;i++)
	{cin>>strs[i];strs[i]=strsort(strs[i]);}
	//输入，并且对单个字符串排序 
	for (int i=1;i<=n;i++)
	{q1.push(strs[i]);}
	string strtemp=q1.top();q1.pop();
	for (int i=1;i<n;i++)
	{
		string temp=q1.top();q1.pop();
		if (temp!=strtemp){count++;}
		strtemp=temp;
	}
	printf("%d",count);
	return 0;
}
```
Thanks for your watching.  
No copying for a better www.luogu.com.（~~滑稽~~）

---

## 作者：May_Forever (赞：1)

所以呢，，，，只有我是选择用容器做的吗？！？

一直秉承一个原则：用最短的时间写完代码，如果能过，就不管优化，以后有时间再优化，，，，，，，毕竟比赛的话，如果优化或不优化都是满分，还不如抓紧时间做下一题。

每次输入的时候，用一个map记录各个字母和该字母的个数，然后，，，，，，把这个map插入到一个set<map>里，，，，，，，最后输出set的长度就好了。

下面是我的代码：

```cpp
#include<map>
#include<set>
#include<cstdio>
#include<iostream>
using namespace std;
set<map<char,int> >Set;
int main(){
        int n;
        cin>>n;
        for(int i=1;i<=n;++i){
                map<char,int> Map;
                string st;
                cin>>st;
                for(int j=0;j<st.size();++j)++Map[st[j]];
                Set.insert(Map);
        }
        cout<<Set.size()<<endl;
}
```

---

## 作者：封禁用户 (赞：1)

看到没有C++的题解，我就来发一下

其实这题很水，大家看懂了不要直接复制哦

大体思路是这样的：输入，然后把一个单词的字母从a~z排序，排完再把每个单词排序，然后一个一个找有没有重复就行了

（不会的话请认真看下面的解释）

```cpp

#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
string zf[100001]; //用来存字符串，数组应该不用开这么大，不过只要不爆掉都没关系
int main()
{
    int n,s=1; //至少有一类单词 
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>zf[i]; //输入 
        for(int j=0;j<=zf[i].size()-1;j++)
        for(int u=j+1;u<=zf[i].size()-1;u++)
        if(zf[i][j]>zf[i][u])
        {
            char st;
            st=zf[i][j];
            zf[i][j]=zf[i][u];
            zf[i][u]=st;
        } //用冒泡把每个单词的每个字母拍一下序，不知道为什么sort不行 
    }
    sort(zf+1,zf+n+1); //然后再用sort把所有单词拍一下序 
    string t=zf[1]; //t是第s种，最早是第一种  
    for(int i=1;i<=n;i++)
    {
        if(zf[i]!=t) //如果与原来的可能不同了 
        {
            s++; //类数+1 
            t=zf[i]; //把t改成新的一种 
        }
    }
    cout<<s<<endl; //打印 
}

```

---

## 作者：a___ (赞：1)

似乎没人和我的想法一样

先每个字符串sort再整体sort再unique去重

具体代码如下

```cpp
#include <iostream>
#include <algorithm>//unique
#include <string> 
using namespace std;
int main()
{
    int n,i;
    cin>>n;
    string in[n];
    for (i=0;i<n;i++) {cin>>in[i];sort (in[i].begin()/*字符串首地址*/,in[i].end()/*~尾地址*/);}
    sort (in,in+n);//整体排序方便去重
    n=unique (in,in+n)/*该函数返回值为去重后尾地址*/-in;//减去首地址变长度
    cout<<n<<endl;
    return 0;
}
```

---

## 作者：fl_334 (赞：1)

```cpp

var
i,j,k,n,sum:longint;
s:array[1..10000,'A'..'Z']of longint;
t:string;
b:boolean;
function pd(i,j:longint):boolean;//判断两个字符串是否相同
var
        k:char;
begin
        for k:='A' to 'Z' do
        if s[i,k]<>s[j,k] then exit(false);
        exit(true);
end;
begin
        readln(n);
        for i:=1 to n do
        begin
        readln(t);
        for j:=1 to length(t) do
                inc(s[i,t[j]]);
        b:=false;
        for k:=1 to i-1 do
        begin
        if pd(k,i) then begin
                         b:=true;
                         break;
                        end;
        end;
        if b=false then inc(sum);
        end;
        write(sum);
end.

```

---

## 作者：张鑫杰 (赞：0)

这次我提供一种充分使用c++oop特性的方法,但是警告:这种方法会在两个测试点超时!!!!!!!!!!!
首先,我们定义一个类:
```cpp
class word {
private:
	int letter[26];
public:
	word(string w) {
		ini(letter);
		for (auto &i : w) {
			letter[i - 'A']++;
		}
	}
	word() { ini(letter); };
	bool operator==(const word&right) const {
		for (int i = 0; i < 26; i++) {
			if (letter[i] != right.letter[i])
				return false;
		}
		return true;
	}
};
```
我重载了==,简化了判断.
```cpp
ios::sync_with_stdio(false);
```
关闭了同步,以尽可能提高速度.
```cpp
vector<word> w;
```
由于set的玄学错误,我只能使用vector(其实如果解决set<word>的问题,我觉得肯定是可以通过全部的点的)
 一下是全部代码
  ```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<string>
#include<sstream>
#include<vector>
#include<cstring>
#include<cmath>
#include<set>
#include<algorithm>
using namespace std;
#define ini(x) memset(x,0,sizeof(x))
#define all(x) x.begin(),x.end()
class word {
private:
	int letter[26];
public:
	word(string w) {
		ini(letter);
		for (auto &i : w) {
			letter[i - 'A']++;
		}
	}
	word() { ini(letter); };
	bool operator==(const word&right) const {
		for (int i = 0; i < 26; i++) {
			if (letter[i] != right.letter[i])
				return false;
		}
		return true;
	}
};
int main() {
	ios::sync_with_stdio(false);
	vector<word> w;
	int wordNum;
	cin >> wordNum;
	string tmp;
	for (int i = 1; i <= wordNum; i++) {
		cin >> tmp;
		bool flag = true;
		for (auto &wor : w) {
			if (wor == tmp) {
				flag = false;
				break;
			}
		}
		if (flag) {
			w.push_back(tmp);
		}
	}
	cout << w.size();
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

###两遍快排。。。。var i,j,k,l,n,m,ans:longint;

**
```cpp
    s:array[1..10000] of string[100];
procedure qs1(l,r,a:longint);
var
  i,j:longint;mid,t:char;
begin
  i:=l; j:=r; mid:=s[a,(i+j) div 2];
  repeat
    while s[a,i]<mid do inc(i);
    while s[a,j]>mid do dec(j);
    if i<=j then
    begin
      t:=s[a,i]; s[a,i]:=s[a,j]; s[a,j]:=t;
      inc(i); dec(j);
    end;
  until i>j;
  if j>l then qs1(l,j,a);
  if i<r then qs1(i,r,a);
end;
procedure qs2(l,r:longint);
var
  i,j:longint;
  mid,t:string[100];
begin
  i:=l; j:=r; mid:=s[(i+j) shr 1];
  repeat
    while s[i]<mid do inc(i);
    while s[j]>mid do dec(j);
    if i<=j then
    begin
      t:=s[i]; s[i]:=s[j]; s[j]:=t;
      inc(i); dec(j);
    end;
  until i>j;
  if j>l then qs2(l,j);
  if i<r then qs2(i,r);
end;
begin
  //assign(input,'word.in');reset(input);
  //assign(output,'word.out');rewrite(output);
  readln(n);
  for i:=1 to n do
    begin
      readln(s[i]);
      qs1(1,length(s[i]),i);
    end;
  qs2(1,n);     ans:=1;
  for i:=2 to n do
    if s[i]<>s[i-1] then inc(ans);
  writeln(ans);      //CLOSE(input);close(output);
end.***
```

---

## 作者：shadow_z (赞：0)

#include <bits/stdc++.h>                                                         包含所有库

```cpp
using namespace std;
char cur[200];                                                         输入的字符串
int n;                                                         字符串的数量
int main()
{
    set<string> a;                                                        建一个集合
    cin>>n;                                                         输入字符串的数量
    for(int i=1;i<=n;i++)
    {
        cin>>cur;                                                         输入当前的字符串
        int len=strlen(cur);                                           获取字符串的长度
        sort(cur,cur+len);                                             在字符串的内部进行排序（字典序）例如将ABACB排成AABBC
        string s=cur;                                                     获取排好序的字符串
        a.insert(s);                                                         把排好序的字符串丢进集合中进行判重
    }
    cout<<a.size();                                                      容器的大小就是类别
    return 0;
}

```

---

## 作者：wuyutong111 (赞：0)

```pascal
大家可以看看我的思路：

首先，一边读入字符串，一边把字符串的各个字符排个序，形成一个新的字符串，并放在数组中；存放好后，把整个存放字符串的数组排个序，然后判断有几个不同的（注意，排序都用快排）

上代码（不要嫌弃我是P党）：
var
 n,i,sum:longint;
 s:string;
 sx:array[0..10001] of string;
procedure kp2(l,r:longint);//排序2
var
 i,j:longint;
 ch,m:string;
begin
 i:=l; j:=r;
 m:=sx[(l+r) div 2];
 repeat
  while sx[i]<m do inc(i);
  while sx[j]>m do dec(j);
  if i<=j then
   begin
    ch:=sx[i]; sx[i]:=sx[j]; sx[j]:=ch;
    inc(i); dec(j);
   end;
 until i>j;
 if l<j then kp2(l,j);
 if i<r then kp2(i,r);
end;
procedure kp1(l,r:longint);//排序1
var
 i,j:longint;
 ch,m:char;
begin
 i:=l; j:=r;
 m:=s[(l+r) div 2];
 repeat
  while s[i]<m do inc(i);
  while s[j]>m do dec(j);
  if i<=j then
   begin
    ch:=s[i]; s[i]:=s[j]; s[j]:=ch;
    inc(i); dec(j);
   end;
 until i>j;
 if l<j then kp1(l,j);
 if i<r then kp1(i,r);
end;
begin
 readln(n);
 for i:=1 to n do
  begin
   readln(s);
   kp1(1,length(s));//s中的各个字符串排个序
   sx[i]:=s;//把排过序的字符串放在数组中
  end; 
 kp2(1,n);//把sx数组排个序
 sum:=1;
 for i:=2 to n do
  if sx[i]<>sx[i-1] then inc(sum);//看看有几个不相等，并累加
 writeln(sum);//输出
end.//咳咳，完美结束！

注意啊，快排！
此时此刻特别羡慕C++的sort......
```

---

## 作者：禾羽 (赞：0)

参考某神犇的思想

靠着度娘写下来的，map真心不会用。。

    
```cpp
#include<bits/stdc++.h>//一如既往，直接玄学
using namespace std;
    string e;//详情百度，会写不会讲，总之是定义一个e可以存储单词
    map<string,bool>a;
int main(){
    int m=0,N;
    scanf("%d",&N);//读入N
        for(int i=1;i<=N;i++){
            cin>>e;//在循环中读e，一个一个的操作
            sort(e.begin(),e.end());//排序，方便比较
            if(!a[e]){//判定
                m++;//输出种类
                a[e]=1;//把出现了的a[e]赋值1，如果读取的不是已有的m加一
        }
    }
    cout<<m;
    return 0;
}

```

---


# 火星上的加法运算

## 题目描述

最近欢欢看到一本有关火星的书籍，其中她被一个加法运算所困惑，由于她的运算水平有限.她想向你求助，作为一位优秀的程序员，你当然不会拒绝。

## 样例 #1

### 输入

```
20
1234567890
abcdefghij
```

### 输出

```
bdfi02467j```

# 题解

## 作者：Laser_Crystal (赞：12)

### 来一发用高精度做的
其实方法和正常的十进制高精加一样，只不过把10换成了n

中间还要特判484字符……

29行代码走起（~~代码风格过丑~~）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005],b[1005],c[1005];
char s1[1005],s2[1005];
int main()
{
	int n;
	cin>>n>>s1>>s2;
	int l=strlen(s1);
	for(int i=0;i<l;i++)
	if(s1[i]>='a'&&s1[i]<='z') a[l-i]=s1[i]-87;
		else a[l-i]=s1[i]-48;//输入特判×1
	l=strlen(s2);
	for(int i=0;i<l;i++)
	if(s2[i]>='a'&&s2[i]<='z') b[l-i]=s2[i]-87;
		else b[l-i]=s2[i]-48;//输入特判×2	
	l=max(strlen(s1),strlen(s2));
	for(int i=1;i<=l;i++)
	{//高精加
		c[i]+=a[i]+b[i];
		c[i+1]=c[i]/n;
		c[i]%=n;
	}
	if(c[l+1]) l++;
	for(int i=l;i>0;i--)
	if(c[i]>9) cout<<char(c[i]+87);//输出特判
	else cout<<c[i];
	return 0;
}
```
QwQ，其实没那么难的~各位886~

---

## 作者：扬皓2006 (赞：9)

本题其实就是一个原始的高精加法（就是有点坑）（连重载运算符都不用哦）

如果还不会高精的同学请左转这里 

[P1601](https://www.luogu.org/problem/P1601)
[P2142](https://www.luogu.org/problem/P2142)

讲一下高精的思路:
输进两个字符串（char而不是string），然后存储，如果超过进制数就进1，然后倒序输出（敲黑板！重点）

代码如下:
```
#include<bits/stdc++.h>//万能头
using namespace std;
int n,len;//进制数及最终输出字符串总长
char a1[300],b1[300],z;
int len1[300],len2[300],len3[300];//处理后的数字2组+最终数字
char len4[26]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};//26个字母
char len5[10]={'0','1','2','3','4','5','6','7','8','9'};//10个数字
int main()
{
	memset(len1,0,sizeof(len1));//归零
	memset(len2,0,sizeof(len2));//归零
	cin>>n;
	cin>>a1;
	cin>>b1;
	int n1=strlen(a1),n2=strlen(b1);//函数统计a1,b1长度
	for(int i=0;i<n1;i++)
	{
		if(a1[i]>='0'&&a1[i]<='9') len1[n1-i]=a1[i]-48;//如果是数组就处理成数字
		else len1[n1-i]=a1[i]-'a'+10;//如果是字母就处理成数字
	}
	for(int i=0;i<n2;i++)
	{
		if(b1[i]>='0'&&b1[i]<='9')  len2[n2-i]=b1[i]-48;//同上
		else len2[n2-i]=b1[i]-'a'+10;//同上
	}
	int t=max(n1,n2);//最大的长度（并不代表最终长度！因为可能最高位会进位）
    for(int i=1;i<=t;i++)
    {
    	len3[i]+=len1[i];len3[i]+=len2[i];//相加
    	if(len3[i]>=n)
		{
			len3[i]-=n;
			len3[i+1]++;
		 } //进位操作
	}
	for(int i=201;i>=1;i--)
	{
		if(len3[i]!=0)
		{
			len=i;
			break;
		}
	}//统计最终长度
	for(int i=len;i>=1;i--)
	{
		z='a'+len3[i]-10;
		if(len3[i]<10) cout<<len3[i];//如果能处理成数字就输出数字
		else cout<<z;//否则输出字母
	}
	return 0;
}
```
高精度虽然在NOIP/CSP中出现次数不多，但是也是我们必须掌握的，希望同学们都能学会高精度！

最后，希望管理大大能通过此篇题解！

---

## 作者：infinities (赞：4)

~~本人第一篇洛谷自身题库的题解~~，写得不好请见谅

我的(WA-->AC)AC及写题解经历：这题有点坑，我调了将近10遍才过，还请教了dalao，最后终于自己调过了。然后看楼上大佬几年前发的代码~~似乎都不好理解~~，我就发一篇。

此题就是一个朴素的高精加法，和高精A+B没有太多的区别，只要注意一下字母，数字的转换就好了。

但是，不知是不是string的字符长度不够，用它写的代码怎么改都过不了，一直80分，这里贴出来仅供参考（正解在下，请耐心看完）：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int f(char z){
    if(z>='0'&&z<='9')return z-48;
    if(z>='a'&&z<='z')return z-87;
    return 0;
}//从字母转换为数字
int f_(int a){
    if(a<=9)return (char)a+48;else
    return (char)a+87;
}//从数字转换成字母
int n,al,bl,c[2111],flag=0,t;char k[2031],zz;
string a,b;//不知为何过不了
int main(){
    ios::sync_with_stdio(false);//cin,cout快读
    cin>>n>>a>>b;//输入不解释
    al=a.length();
    bl=b.length();//a,b的长度
    t=max(al,bl);//取最大值方便计算
    for(int i=0;i<al/2;i++){//a的反转，因为刚开始是倒序输入
    	zz=a[i];
    	a[i]=a[al-i-1];
    	a[al-i-1]=zz;
	}
	for(int i=0;i<bl/2;i++){//b的反转，因为刚开始也是倒序输入
    	zz=b[i];
    	b[i]=b[bl-i-1];
    	b[bl-i-1]=zz;
	}
    for(int i=0;i<t;i++){//开始进行加法竖式模拟
        c[i]+=f(a[i])+f(b[i]);//c是暂时储存结果的数组
        if(c[i]>=n)c[i]-=n,c[i+1]++;//进位
        k[i]=f_(c[i]);//把结果转换进新数组
    }
    if(c[t]==1)cout<<"1";//如果进位进到a,b数组的长度之外，进行特判
    for(int i=t-1;i>=0;i--)cout<<k[i];//倒序输出
    return 0;
}
```
100分代码，几乎无改变，只是把string变成了char:
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int f(char z){
    if(z>='0'&&z<='9')return z-48;
    if(z>='a'&&z<='z')return z-87;
    return 0;
}//从字母转换为数字
int f_(int a){
    if(a<=9)return (char)a+48;else
    return (char)a+87;
}//从数字转换成字母
int n,al,bl,c[2111],flag=0,t;char k[2031],zz;
char a[2010],b[2222];
int main(){
    ios::sync_with_stdio(false);//cin,cout快读
    cin>>n>>a>>b;//输入不解释
    al=strlen(a);
    bl=strlen(b);//a,b的长度,除了这两句和定义语句和前面的80分代码就应该没有别的不同了
    t=max(al,bl);//取最大值方便计算
    for(int i=0;i<al/2;i++){//a的反转，因为刚开始是倒序输入
    	zz=a[i];
    	a[i]=a[al-i-1];
    	a[al-i-1]=zz;
	}
	for(int i=0;i<bl/2;i++){//b的反转，因为刚开始也是倒序输入
    	zz=b[i];
    	b[i]=b[bl-i-1];
    	b[bl-i-1]=zz;
	}
    for(int i=0;i<t;i++){//开始进行加法竖式模拟
        c[i]+=f(a[i])+f(b[i]);//c是暂时储存结果的数组
        if(c[i]>=n)c[i]-=n,c[i+1]++;//进位
        k[i]=f_(c[i]);//把结果转换进新数组
    }
    if(c[t]==1)cout<<"1";//如果进位进到a,b数组的长度之外，进行特判
    for(int i=t-1;i>=0;i--)cout<<k[i];//倒序输出
    return 0;
}
```
经过这道题的AC经历，我总结出一条教训：string不能代替char，更不能瞎用

感谢各位耐心看完的dalao！

---

## 作者：zhouwc (赞：4)

#Pascal#

看此题写题解者甚少，在下不才，也写了1份题解，希望大家能够有所帮助。


一拿到此题，我就觉得有点像高精度的感觉，都是用字符串来处理这一个问题。

做这道题需要注意的是，当两个字符串长度不想当是就应该用‘0’来补位，不然就会出现头对头加的情况，显然是WR


对于这道题来说，只需一位一位的相加即可。对数字与字符分别处理，当>n时需要进位，就可以做出来了


以下是pascal AC代码


```cpp
var n,i,k,p:longint;
    s,s1,s2,t:string;
begin
  readln(n);
  readln(s);
  readln(s1);
  if (length(s)<length(s1)) or ((length(s)=length(s1)) and (s<s1)) then
  begin t:=s; s:=s1; s1:=t; end;
  if length(s1)<length(s) then
  begin
    t:='';
    for i:=1 to length(s)-length(s1) do
    t:=t+'0';
    s1:=t+s1;
  end;
  for i:=length(s) downto 1 do
  begin
    if (s[i]>='0') and (s1[i]>='0') then
    p:=ord(s[i])+ord(s1[i])+k
    else begin if s[i]>='0' then p:=ord(s[i])+k;
    if s1[i]>='0' then p:=ord(s1[i])+k;   end;
    k:=0;
    if (s1[i]>='a') then p:=p-ord('a')+10;
    if (s[i]>='a') then p:=p-ord('a')+10;
    if ((s[i]>='0') and (s[i]<='9')) then p:=p-ord('0');
    if ((s1[i]>='0') and (s1[i]<='9')) then p:=p-ord('0');
    while p>=n do
    begin
      p:=p-n;
      k:=k+1;
    end;
    if (p>=0) and (p<=9) then s2:=s2+chr(p+ord('0'));
    if (p>=10) then s2:=s2+chr(p-10+ord('a'));
  end;
  if k>0 then s2:=s2+chr(k+ord('0'));
  for i:=length(s2) downto 1 do
  write(s2[i]);
end.
```
如有错误，还请指出


---

## 作者：Zlc晨鑫 (赞：3)

[$\color{black} \text{My blog}$](https://www.luogu.com.cn/blog/Zlc/)

做这道题你需要知道：

- $\color{black} \text{高精度加法}$
- $\color{black} \text{简单的进制知识}$

如果你不知道$\color{black} \text{高精度加法}$，可以自己去学；$\color{black} \text{进制知识}$需要知道的比较少，你只需知道$\color{black} \text{N进制就是逢N进一，就像10进制就是逢10进一}$即可。

为了处理$\color{black} \text{字母}$，可以先将其转换为对应的$\color{black} \text{数字}$，计算完成后再将其转换为对应的$\color{black} \text{字母}$输出。

这样，具体的思路就出来了：
- 将字母转换为数字。
- 进行$\color{black} \text{逢N进一}$的计算。
- 将得出的结果转换为字母输出。

具体代码如下：

```cpp
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;

const int maxn = 2000 + 5;
int a[maxn], b[maxn], c[maxn];
string a1, b1;

//转换成数字
void to_number(int* a, int n) {
    for (int i = 0; i < n; i++)  
        a[i] = (a[i] >= 0 && a[i] <= 9) ? a[i] : (a[i] + '0' - 'a' + 10);
}

//转换成字母
void to_string(int* a, int n) {
    for (int i = 0; i < n; i++) 
        //因为输出字母要输出字符，所以将数字也一并转换成字符形式
        a[i] = (a[i] >= 0 && a[i] <= 9) ? (a[i] + '0') : (a[i] - 10 + 'a');
}

int main() {
    int n;
    scanf("%d", &n);
    cin >> a1 >> b1;
    for (int i = a1.size() - 1; i >= 0; --i) 
        a[a1.size() - i - 1] = a1[i] - '0';
    for (int i = b1.size() - 1; i >= 0; --i) 
        b[b1.size() - i - 1] = b1[i] - '0';
    //将字母转换成数字
    to_number(a, a1.size());
    to_number(b, b1.size());
    int len = a1.size() > b1.size() ? a1.size() : b1.size();
    int y = 0;
    for (int i = 0; i < len; i++) {
        c[i] += a[i] + b[i] + y;
        y = c[i] / n; //逢N进一
        c[i] %= n;
    }
    if (y) c[len++] = y;
    to_string(c, len); //将字母转换成数字
    for (int i = len - 1; i >= 0; --i) 
        putchar(c[i]);
    putchar('\n');
    return 0;
}
```

其实，我还做过一道几乎完全相同的题：
- 题目推荐-[$\color{black} \text{B进制星球}$](https://www.luogu.com.cn/problem/P1604)。
- 我也写过[$\color{black} \text{这道题的题解}$](https://www.luogu.com.cn/blog/Zlc/p1604-b-jin-zhi-xing-qiu-ti-xie)，不过当时已经无法提交了。

谢谢阅读，如有错误欢迎指出。

---

## 作者：_Ayanami_ (赞：3)

~~看题解里有说用string会炸那我们就来一个string的题解吧2333~~

这里我们用上了<algorithm>中的reverse对字符串进行翻转

需要注意的是翻转后我们把较小的数的高位补零
  ~~实测不这么搞会WA两个点~~

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,l1,l2,l,a,b,c;
string s1,s2,s;
bool x=0;//x用来存上一位有没有进位
int main()
{
	scanf("%d",&n);//进制
	cin>>s1>>s2;//字符串读入
	l1=s1.length();
	l2=s2.length();//记录长度
	l=max(l1,l2);//记录两者中较长的那一个的长度
	reverse(s1.begin(),s1.end());
	reverse(s2.begin(),s2.end());//翻转字符串
	for(int i=l1;i<l;i++)
	{
		s1+='0';
	}
	for(int i=l2;i<l;i++)
	{
		s2+='0';
	}//将较短的那一个的高位补零
	for(int i=0;i<l;i++)
	{
		if(s1[i]>='0'&&s1[i]<='9')
		{
			a=s1[i]-'0';
		}
		else if(s1[i]>='a'&&s1[i]<='z')
		{
			a=s1[i]-87;
		}
		if(s2[i]>='0'&&s2[i]<='9')
		{
			b=s2[i]-'0';
		}
		else if(s2[i]>='a'&&s2[i]<='z')
		{
			b=s2[i]-87;
		}//转换为数字进行计算
		//a-z的ASCLL码是97-122，a-z代表的数字是10-35所以直接减87
		c=a+b+x;//相加
		x=0;
		if(c>=n)//需要进位
		{
			c-=n;
			x=1;
		}
		if(c>=0&&c<=9)//是数字就直接输出
		{
			s+=c+'0';
		}
		else//否则加上87转成对应字母
		{
			s+=c+87;
		}
	}
	if(x)//特判若最高位有进位则再填一个一
	{
		s+='1';
	}
	reverse(s.begin(),s.end());//翻转回来
	cout<<s<<endl;//输出结果
}
```


---

## 作者：acaca (赞：2)

此处pascal题解。就是一位一位相加，再判断有没有大于等于要求的进制就好了。


type num=array[0..220] of longint; //高精度的存储形式，数组稍微开大一些

```cpp
var n,i:longint;
    s1,s2:string; //用字符串读入
    a1,a2,a3:num; //a1和a2存储要相加的两个数，a3存储结果
function zh(s:string):num;  //此处是把读入的两个字符串转换为数字存入数组，便于运算。
var i:longint;
begin
  zh[0]:=length(s); //长度
  for i:=1 to zh[0] do
  begin
    if (ord(s[zh[0]-i+1])>=ord('a'))and(ord(s[zh[0]-i+1])<=ord('z')) then
      zh[i]:=ord(s[zh[0]-i+1])-ord('a')+10;  //如果是字母，比如a就转成10
    if (ord(s[zh[0]-i+1])>=ord('0'))and(ord(s[zh[0]-i+1])<=ord('9')) then
      zh[i]:=ord(s[zh[0]-i+1])-ord('0');  //数字的情况
  end;
end;
procedure print(a:longint);  //输出
begin
  if a>=10 then write(chr(a+ord('a')-10)) else write(a);  //转换回来
end;
begin
  readln(n);
  readln(s1);
  readln(s2);
  while length(s1)<length(s2) do s1:='0'+s1;   //位数不统一用0补
  while length(s1)>length(s2) do s2:='0'+s2;
  a1:=zh(s1); a2:=zh(s2);
  a3[0]:=a1[0];  
  for i:=1 to a2[0] do a3[i]:=a1[i]+a2[i];  //相加
  for i:=1 to a3[0] do  //判断进位
    while a3[i]>=n do
    begin
      a3[i]:=a3[i]-n;
      if i+1>a3[0] then //假如最大的一位进位了就把长度加一
      begin
        inc(a3[0]);
        a3[i+1]:=0;
      end;
      inc(a3[i+1]);  
    end;
  for i:=a3[0] downto 1 do print(a3[i]);  //注意要倒着输出
end.

```

---

## 作者：darkfire3133 (赞：1)

很普通的高精加法，注意进位，输出时大于9的输出相应字母即可


代码如下：

```cpp

/*For the Alliance!!!*/
#include<iostream>
#include<cstring>
using namespace std;
char a[300],b[300];
int n1[300],n2[300];
int main()
{
    memset(n1,0,sizeof(n1));
    memset(n2,0,sizeof(n2));
    int n;
    cin>>n;
    cin>>a>>b;
    int len1=strlen(a);
    int len2=strlen(b);
    for(int i=0;i<len1;i++)
    {
        if(a[i]>='a' && a[i]<='z')
            n1[len1-1-i]=a[i]-'a'+10;
        else
            n1[len1-1-i]=a[i]-48;
    }
    for(int i=0;i<len2;i++)
    {
        if(b[i]>='a' && b[i]<='z')
            n2[len2-1-i]=b[i]-'a'+10;
        else
            n2[len2-1-i]=b[i]-48;
    }
    int len;
    for(int i=0;i<(len1>len2? len1:len2);i++)
    {
        n1[i]+=n2[i];
        if(n1[i]>=n)
        {
            n1[i+1]++;
            n1[i]-=n;
        }
    }
    for(int i=299;i>=0;i--)
        if(n1[i])
        {
            len=i;
            break;
        }
    char t;
    for(int i=len;i>=0;i--)
    {
        t=n1[i]+'a'-10;
        if(n1[i]>=10)
            cout<<t;
        else
            cout<<n1[i];
    }
    cout<<endl;
    return 0;
}

```

---

## 作者：Michael_Li (赞：0)

//这其实就是一道字符串模拟题，最朴素的做法就是把所有的数字先转成十进制做，但是这样的话代码会比较的长，所以推荐用高精度的思想进行模拟，附上c++ ac代码，具体的看注释

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<iostream>
#define LL long long
#define N (100001)
using namespace std;
int n;
int f[N];
int a1[N], a2[N], ans[N];
char c1[N], c2[N], ansc[N], zh[N];
inline int read(){
    int t = 0;
    char p = getchar();
    bool fl = false;
    while (!isdigit(p)){
        if (p == '-') fl = true;
        p = getchar();
    }
    do{
        t = t * 10 + p - 48;
        p = getchar();
    }while (isdigit(p));
    if (fl) return -t;
    else return t;
}
inline int max(int x, int y){
    if (x > y) return x;
    else return y;
}
inline int min(int x, int y){
    if (x < y) return x;
    else return y;
} 
//以上为自动插入的头文件，可忽略
int main(){
    n = read();//读入进制
    for (int i = '0'; i <= '9'; i++) f[i] = i-'0';//f[I]是字符对应的数字，下面的zh就是数字转字符
    for (int i = 'a'; i <= 'z'; i++) f[i] = i-'a'+10;//不要在傻傻的一个一个手写了，比较浪费时间，如果不知道a的ASCLL码的话直接‘a’就行了，在这里默认是数字
    cin>>c1>>c2;//读入
    int len1 = strlen(c1), len2 = strlen(c2);//求长度，如果每一次都直接调用strlen相当于复杂度就多了一个O(串长)，莫名其妙会T的，请注意
    for (int i = 0; i < len1; i++){
        a1[len1-i] = f[c1[i]];//类似高精度的读入，倒过来，从低位开始运算
    }
    for (int i = 0; i < len2; i++){
        a2[len2-i] = f[c2[i]];
    }
    int m = max(len1, len2);
    for (int i = 1; i <= m; i++){
        ans[i] += a1[i]+a2[i];
        ans[i+1] += ans[i]/n;//普通高精度是/10，但由于是n进制，所以是/n %n
        ans[i] = ans[i]%n;
    }
    if (ans[m+1] > 0) m++; 
    for (int i = 0; i <= 9; i++) zh[i] = (char) i+'0';//预处理出zh数组
    for (int i = 10; i <= 35; i++) zh[i] = (char) i-10+'a';
    for (int i = m; i >= 1; i--){
        putchar(zh[ans[i]]);//由于最后是以char的类型输出，所以要转回来
    }
    return 0;
}

```

---


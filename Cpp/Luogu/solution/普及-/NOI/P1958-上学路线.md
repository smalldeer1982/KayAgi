# 上学路线

## 题目描述

你所在城市的街道好像一个棋盘，有 $a$ 条南北方向的街道和 $b$ 条东西方向的街道。南北方向的 $a$ 条街道从西到东依次编号为 $1$ 到 $a$，而东西方向的 $b$ 条街道从南到北依次编号为 $1$ 到 $b$，南北方向的街道 $i$ 和东西方向的街道 $j$ 的交点记为 $(i,j)$。

你住在 $(1,1)$ 处，而学校在 $(a,b)$ 处，你骑自行车去上学，自行车只能沿着街道走，而且为了缩短时间只允许沿着向东和北的方向行驶。

现在有 $N$ 个交叉路口在施工 $(X_1,Y_1)$、$(X_2,Y_2)$……，$(X_n,Y_n)$，这些路口是不能通车的。

问你上学一共有多少走法?

## 样例 #1

### 输入

```
5 4
3
2 2
2 3
4 2```

### 输出

```
5```

# 题解

## 作者：Err_BJT (赞：45)

#一道简单的水题！

用普通的深搜就可以解决了，由于题目规定，只能往上或者向右走，就可以省去许多时间，反正是比迷宫那题简单多了。

#我把边和右边多一格的位置全部设置了-1，可以避免越界。

如果当前位置为-1的话，就返回上一个操作。

```cpp
        #include<iostream>  //头文件，只有两个
        #include<cstdio>
        using namespace std;
        int s[20][20],ans,a,b; //s判断是否可以通过，abs表示方案总数。
        void dfs(int x,int y)  //深搜过程
        {
            int i;
            if (x==a&&y==b) { ans++;return;} //判断是否是否到达学校。
                     else
                      if (s[x][y]!=-1)  //判断此路径是否可以行走。
                       {
                           dfs(x,y+1); //向右走一格。
                           dfs(x+1,y); //向上走一格。
                       }
        }
        int main()
        {
            int n;
            cin>>a>>b;  //常规的输入。
            cin>>n;
            int x1,x2;
            for (int i=1;i<=n;i++)
            {
                cin>>x1>>x2;  //输入障碍的坐标。
                s[x1][x2]=-1;  //障碍的坐标我们赋值为-1，方便深搜判断。
            }
            for (int i=1;i<=a;i++)
             s[i][b+1]=-1;  //右边多一格的位置全部复制等于-1，避免越界。
            for (int i=1;i<=b;i++)
             s[a+1][i]=-1;  //上面多一格的位置全部复制等于-1，避免越界。
            dfs(1,1);  //从坐标1,1开始深搜。
            cout<<ans<<endl;  //输出方案总数。
        .}
```
总体来说，这题来说还是十分简单的，可以给刚学搜索的人练一下。希望大家多刷一点题。
#早日成为大牛！！！！


---

## 作者：过往梦魇之殇 (赞：26)

## ~~这是本蒟蒻第一次发题解，愿各位多多（改错）包容~~

**以下是正文：**

**发现做这道题时，许多大佬们都用了搜索，那么我就来讲一讲数学方法。**

~~说句实在话：这不是小学3年级的奥数题吗？$QAQ$~~

原名：“标点法”  ~~（老师说的）~~

我简单画张图吧 ~~（图好点丑，请原谅）（图很糊，请原谅）~~：

第一步：表出发点两边的点,赋值为1（值代表能走到这个点的路径数）。

//$(1,1)-->(1,b)  (1,1)-->(a,1) =1$


![](https://cdn.luogu.com.cn/upload/image_hosting/xezn3hwc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


第二步，将其他的点的值附为其上面与左边的点的值的和，可得出一个表达式：

$mapp[i][j]=mapp[i-1][j]+mapp[i][j-1]$ (即上一列与上一行的值得和）

![](https://cdn.luogu.com.cn/upload/image_hosting/5njfi9gq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

注：如果有障碍点，那么那个点的值附为0，即可。

如果出发点两边上有障碍点，那么它与它外面（右边或下边）的点的值皆为0。

最后输出$mapp[a][b]$就完成辣！

然后就可以开心地切题辣！！！~~（$qwq$）~~

## $AC Code$：（杜绝抄袭，从大家做起）
```cpp
/*#include<水的一批>*/
#include<bits/stdc++.h>
using namespace std;
int a,b,n,x,y;
int mapp[20][20];//记录每个点的值
bool flag[20][20];//记录每个点是否为障碍点，true为不是障碍点，flase为是。
int main()
{
	memset(flag,true,sizeof(flag));//初始为不是。
	memset(mapp,0,sizeof(mapp));//初始为0。
	scanf("%d%d%d",&a,&b,&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);
		flag[x][y]=0;//标记为障碍点
	}
	for(int i=1;i<=a;i++){
		if(!flag[i][1]) break;//如果该点为障碍点，那么退出循环
		mapp[i][1]=1;//该点赋值为1
	}
	for(int i=1;i<=b;i++){
		if(!flag[1][i]) break;//如果该点为障碍点，那么退出循环
		mapp[1][i]=1;//该点赋值为1
	}
	for(int i=2;i<=a;i++){
		for(int j=2;j<=b;j++){
			if(flag[i][j]){
				mapp[i][j]=mapp[i-1][j]+mapp[i][j-1];/上面讲过了，不作赘述。
			}
		}
	}
	printf("%d\n",mapp[a][b]);
    return 0;
}

```
~~若有不正之处，请多指教。（制作不易，求赞丫,$thanks$）~~

~~（**请求管理员哥哥照顾一下我这个蒟蒻，上一篇只是因为没打万能头没过啊啊啊**）~~

---

## 作者：___I_AK_IOI (赞：26)

~~一道大水题~~第一篇题解开心求通过，~~无耻求点赞~~
# BFS做法
## 简化题目
从1 1点开始走到a b点，其中有n个点设有障碍物，且只能向右向下走两个方向，问总共有多少种路线可以到达a b。
## 思路
典型的走迷宫的问题，我们先从1 1开始，把1 1入队，依次去扩展右，下的节点，如果右，下越界了，或者是设有障碍物，那么也就是说这个点不能扩展（这个是判断的条件，很重要），如果当前所扩展完的点合法，那么让它入队，如果扩展点为a b那么我们ans++（或者也可以用二维来计数最后输出的是w[a][b]，一般可以用O（1）就最好别扩大）~~个人觉得比较好理解~~
## 代码实现
另外说一下，本代码没有用读入优化的原因是因为怕莫名WA，最近梦语小萌新（白哥小葱）已经烦透了，所以又开始老老实实的换回了cin和scanf，如果有哪位dalao知道为什么WA，请私聊我一下谢谢
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int dx[2]={1,0};//扩展点横坐标的方向右下
const int dy[2]={0,1};//扩展点纵坐标的方向右下
struct node
{
	int x,y;
};//记录扩展点的坐标信息
int main()
{
	int i,a,b,n;
	cin>>a>>b;
	cin>>n;
	int G[100][100];
	memset(G,0,sizeof(G));//初始化位置，设每个点都可以走
	for(i=1;i<=n;i++)
	{
		int x,y;
		cin>>x>>y;
		G[x][y]=1;//这个点为障碍不能走
	}
	queue<node>q;//声明队列
	node tmp;//中间存扩展点的变量也可以直接打{}
	tmp.x=1;
	tmp.y=1;
	q.push(tmp);//入队
	int ans=0;
	while(!q.empty())//当队列不空时
	{
		node x=q.front();//取出队列的头
		q.pop();//弹出
		for(i=0;i<2;i++)
		{
			int u=x.x+dx[i];//更新扩展点的横坐标
			int v=x.y+dy[i];//更新扩展点的纵坐标
			tmp.x=u;
			tmp.y=v;
			if(G[u][v]==1||u<1||u>a||v>b||v<1)continue;//我们的判断条件
			if(u==a&&v==b)//如果到达终点方案++
			{
				ans++;
				continue;//终点不需要入队，终点不能再继续向下扩展了
			}
			q.push(tmp);//新的扩展点入队
		}
	}
	cout<<ans;//输出方案数
	return 0;
}
```


---

## 作者：叁_ (赞：23)

其实这道题还是很水的，随便搜一下就过了 用的深搜，算是较为简单的题目，只有向上向右走，可以节省很多时间
不用剪枝都能过（~~剪枝~~）

这题暴力搜索过了...

但dalao们都是用的dp...（膜拜） 表示本蒟蒻只会深搜

具体的就不多说了,详解在代码中有哈....

# ~~深搜~~
```cpp
//深搜 还给大家打了个快读快写 希望对大家有用 
#include<iostream>//联赛必备 输入输出流 
#include<cstdio>//联赛必备  文件操作和scanf printf 
#include<cctype>//快读快写必备 
//建议不用万能头，联赛可能不允许// 
using namespace std;//标准空间
int n,m,z,sum=0;//n表示a m表示b x表示N sum计数 
//快读：
//isdigit头文件
inline int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;//快读其实我也不太会
	//不过背下来就好了 
}
//快写 
inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');//快写其实我也不太会
	//不过背下来就好了 
}
int a[10002],b[102][102];//a数组 模拟全图 b数组 模拟施工 
int dfs(int x,int y)//深搜 
{
	if((x==n)&&(y==m))//如果符合条件累加
    {
	     sum++;//计数++ 
	     return 0;//直接返回 
    }
    if(b[x][y]) return 0;//判断有无走过
    if((x+1<=n)&&(b[x+1][y]==0)) dfs(x+1,y);//向上走
    if((y+1<=m)&&(b[x][y+1]==0)) dfs(x,y+1);//向下走
    //先判断一下，再走// 
} 
int main()//主函数 
{
	cin>>n>>m>>z;//输入流 
	int x,y;//定义一下 
	for(int i=1;i<=z;i++)//循环输入 
	{
			cin>>x>>y;//输入流 
			b[x][y]=1;//标记一下 
	}
	dfs(1,1);//调用函数 
	cout<<sum; //输出流 
	return 0;//联赛必备 释放空间
	//完美结束// 
}
/*地球还是那样转，而却少了你的陪伴，多了一份孤独，一份期待。我多么希望你能给我回复，但往往
只有冷落....虽然别人说过让我不要过多干涉你的生活，但我仍然放不下，可能是因为我一天到晚都在
想你 */
/*后面的是废话，大家不要在意*/ 
```
不要抄我的题解 （~~爆0~~）

希望对大家有帮助

祝大家早日成为神牛！！！


---

## 作者：KesdiaelKen (赞：10)

经典DP递推题，可以参考过河卒一题。用数组记录施工点，既不能到达的点，在递推时跳过它，然后在计数时它的路径总数就为0，不影响结果。动态转移方程详见程序。

下为代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
bool sg[20][20]={0};//标记是否为施工点
int f[20][20]={0};//DP数组，注意，初始值为0（f[i][j]代表到达第i行第j列这个点的路径总数）
int main()
{
    int a,b;
    scanf("%d%d",&a,&b);
    int n;
    scanf("%d",&n);
    int x,y;
    for(int i=0;i<n;i++)
    {
        scanf("%d%d",&x,&y);
        sg[x][y]=true;//标记为施工点
    }
    f[1][0]=1;//使f[1][1]为1
    for(int i=1;i<=a;i++)
    {
        for(int j=1;j<=b;j++)
        {
            if(!sg[i][j])f[i][j]=f[i-1][j]+f[i][j-1];//可以从左边和下边两边走过来，路径总数即他们的和
        }
    }
    printf("%d",f[a][b]);//输出最终到达路径数
    return 0;
}
```

---

## 作者：Raw_Aya9285 (赞：9)

# P1958 题解

大佬们把边界赋值，窝在边界加特判。

我们一步一步分析吧~

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,t,cnt,vis[21][21];
bool map[21][21];
```
这里是一些定义，n是列数，m是行数，t是施工数，cnt是走法的数量，map和vis是施工、走过路线的标记。

请注意范围。

这块我们不多讲，直接看深搜。

---

**重中之重，深搜部分。**

什么样的走法才能列入我们需要的走法呢？
- 不能走到施工区域。
- 不能往下或左走。
- 不能越界。
- 不能重复走。

依照这部分，我们可以写出如下代码：

```cpp
void dfs(int x,int y){
    if(x<1||x>n||y<1||y>m||map[x][y]||vis[x][y])  return;
    //如果越界/已经走过/有施工，直接停止搜索
    if(x==n&&y==m){
        cnt++;
        return;  //如果已经到终点则退出循环，并把计数器加一（这是一种走法）
    }
    vis[x][y]=1;  //将目前的位置标记，以免走重复
    dfs(x+1,y);  //注意，只能向上或向右！！
    dfs(x,y+1);
    vis[x][y]=0;  //搜索完，将目前位置恢复原样
}
```
深搜就完啦。

---

下一步是主函数部分。

在这部分，我们只需要输入输出、标记，以及调用深搜函数。

```cpp
int main(){
    cin>>n>>m>>t;  //按要求输入
    while(t--){
        int x,y;
        cin>>x>>y;
        map[x][y]=1;  //将施工处标记
    }	
    dfs(1,1);	//从起点1,1开始搜索
    cout<<cnt<<endl;  //输出计数器
    return 0;	
}
```

结束。

---

完整代码如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,t,cnt,vis[21][21];
bool map[21][21];
void dfs(int x,int y){
    if(x<1||x>n||y<1||y>m||map[x][y]||vis[x][y])  return;
    if(x==n&&y==m){
        cnt++;
        return;
    }
    vis[x][y]=1;
    dfs(x+1,y);
    dfs(x,y+1);
    vis[x][y]=0;
}
int main(){
    cin>>n>>m>>t;
    while(t--){
        int x,y;
        cin>>x>>y;
        map[x][y]=1;
    }	
    dfs(1,1);	
    while(1){
        cout<<cnt<<endl;
    } //请勿抄袭
    return 0;	
}
```

---

## 作者：「QQ红包」 (赞：8)

这是一道经典递推题……

到达a[i,j]的路线条数是a[i,j-1]+a[i-1,j];

如果a[i,j]正在施工，那么路线条数就是0

```delphi

var n,m,i,j,x,y,z:longint;
    a:array [0..16,0..16] of longint;
    b:array[0..16,0..16] of boolean;
begin
    read(n,m,z);
    fillchar(b,sizeof(b),true);
    fillchar(a,sizeof(a),0);
    for i:=1 to z do
    begin
        read(x,y);
        b[x,y]:=false;
    end;
    a[1,1]:=1;
    for i:=1 to n do
        for j:=1 to m do
        if (b[i,j])and(i+j<>2) then a[i,j]:=a[i-1,j]+a[i,j-1];
    write(a[n,m]);
end.

```

---

## 作者：courage (赞：6)

这是简单的递推题。

记到达(i,j)的方法数为f[i][j],若(i,j)不可到达则f[i][j]=0,否则f[i][j]=f[i][j-1]+f[i-1][j]


```cpp

#include<cstdio>
int f[17][17]={{0}},a[17][17]={{0}},n,m,k,x,y;
int main(){
    scanf("%d%d%d",&n,&m,&k);
    while (k--){
        scanf("%d%d",&x,&y);
        a[x][y]=-1;
    }
    f[1][1]=1;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++) if (a[i][j]==0)
            f[i][j]+=f[i-1][j]+f[i][j-1];
    printf("%d",f[n][m]);
}

```

---

## 作者：Preccc_LHW (赞：6)

# 看了一下 ~~_好像_~~ 没有写的比较简洁的记忆化的
## 又看了一下提交记录，没多少人是0ms的
### 所以就愉快的写了一下题解


------------
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
int m, n, k, map[17][17], f[17][17];

int dfs(int x, int y)
{
	if (x > n || y > m || map[x][y])return 0;//边界条件和能否走通
	if (x == n && y == m)return 1;//如果到了学校答案+1
	if (f[x][y] != -1)return f[x][y];//记忆化的标准剪枝
	return f[x][y] = dfs(x + 1, y) + dfs(x, y + 1);//两种方案
}

int main()
{
	cin >> m >> n;                     //注意有坑！！！
	cin >> k;
	for (int i = 1; i <= k; i++)
	{
		int x, y;                    
		cin >> y >> x;                 //也是坑！！！
		map[x][y] = 1;                 //标记障碍
	}
	memset(f, -1, sizeof(f));          //初始化
	cout << dfs(1, 1);                 //dfs函数返回的是答案
}
```


------------
#### 希望对你有帮助

---

## 作者：周羿轩 (赞：5)

# 这题可以dfs啊，搜一遍路线，可以的话（不是施工的）走一格，然后递归，走到学校结束子程序，加一次

###### ~~水题万岁（虽然因为一个中文分号我弄了十几次）~~

代码：

```cpp
#include<bits/stdc++.h>
uis/*防抄袭*/ng namespace std;
int a,b,k,x,y,sum;//定义
bool s[20][20];//地图，初始化为全false，都不能走
void dfs(int x,int y){//子程序
    if(x==a&&y==b){//到学校了
        sum++;//加
        return;//返回
    }
    if(s[x][y+1]) dfs(x,y+1);//如果上面能走，走上面
    if(s[x+1][y]) dfs(x+1,y);//如果右面能走，走右面
}
int main(){//主程序
    cin>>a>>b;//输入
    for(int i=1;i<=a;i++){
        for(int j=1;j<=b;j++){
            s[i][j]=true;//将地图区域全变为能走的，留一个边界为false
        }
    }
    cin>>k;
    while(k--){//k后面没用了，k--就好
        cin>>x>>y；//输入坐标
        s[x][y]=false;//施工不能走（话说这啥路啊，这么多施工的）
    }
    dfs(1,1);//从1,1开始深搜
    cout<<sum;//输出
    return 0;//完美结束
}
```


---

## 作者：q2368126021 (赞：5)

###用的深搜，算是较为简单的题目，只有向上向右走


```cpp
#include<bits/stdc++.h>**万能表头**
using namespace std;
int a,b;
int n;
int road[100][100];
int total=0;
int search(int x,int y)**深搜**
{
    int i;
    if((x==a)&&(y==b))//如果符合条件累加
    {
     total++;
     return 0;
    }
    if(road[x][y])return 0;//判断有无走过
    if((x+1<=a)&&(road[x+1][y]==0))search(x+1,y);**向上走**
    if((y+1<=b)&&(road[x][y+1]==0))search(x,y+1);**向下走**
}
int main()**这就不用说了吧**
{
    memset(road,0,sizeof(road));
    int x,y;
    cin>>a>>b;
    cin>>n;
    int i;
    for(i=1;i<=n;i++)
    {
      cin>>x>>y;
      road[x][y]=1;
    }
    search(1,1);
    cout<<total;
}
```

---

## 作者：robin_gao (赞：2)

#### 怎么说呢，看到这道题时心情很纠结，毕竟如果按算法标签上说的要用搜索的话，我就真的要颓了。。。（毕竟我是个递推蒟蒻）
##### 但是呢旁边的人（~~老师~~）提醒我叫我好好看题。
### 然后就发现这是道和P1002没啥差别的题。，，
### 然后呢我就光荣地TLE了
```
#include<bits/stdc++.h>
using namespace std;
int x[17][17];
int place[41][3];
int main()
{
    int a,b,n;
    cin>>a>>b>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>place[i][1]>>place[i][2];
        place[i][1]=a-place[i][1]+1;
    }
    for (int i=a;i>=1;i--)
    {
        for (int j=1;j<=b;j++)
        {
            if (i==a&&j==1)
            {
                x[i][j]=1;
                continue;
            }
            if (i==a)
            {
                x[i][j]=x[i][j-1];
                for (int k=1;k<=n;k++)
                {
                    if(i==place[k][1]&&j==place[k][2])
            	    {
            	        x[i][j]=0;
            	    }
                }
                continue;
            }
            if (j==1)
            {
                x[i][j]=x[i+1][j];
                for (int k=1;k<=n;k++)
                {
                    if(i==place[k][1]&&j==place[k][2])
                	{
                	    x[i][j]=0;
                	}
                }
                continue;
            }
            x[i][j]=x[i+1][j]+x[i][j-1];
            for (int k=1;k<=n;k++)
            {
                if(i==place[k][1]&&j==place[k][2])
               	{
               	    x[i][j]=0;
               	}
            }
        }
    }
    cout<<x[1][b]<<endl;
    return 0;
}
```

------------

## 提醒来看提示的小盆友们，标数数组不开long long的，恭喜你拿到30分左右后去领盒饭
好了说点正事。。。
### 这是本蒟蒻的第一篇题解，请多多（~~关照~~）吐槽。
好吧这也不是啥正事。。。
上代码：
```
#include<bits/stdc++.h>//万能头万岁！！！
using namespace std;
long long x[17][17];//敲黑板重点！！！
int place[41][3];//记录障碍位置
int main()
{
    int a,b,n;
    cin>>a>>b>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>place[i][1]>>place[i][2];//输入
        place[i][1]=a-place[i][1]+1;//调整障碍位置
    }
    for (int i=a;i>=1;i--)
    {
        for (int j=1;j<=b;j++)
        {
            if (i==a&&j==1)
            {
                x[i][j]=1;
                continue;
            }
            if (i==a)
            {
                x[i][j]=x[i][j-1];
                for (int k=1;k<=n;k++)
                {
                    if(i==place[k][1]&&j==place[k][2])
            	    {
            	        x[i][j]=0;//如果爆掉则点为0
            	    }
                }
                continue;
            }
            if (j==1)
            {
                x[i][j]=x[i+1][j];
                for (int k=1;k<=n;k++)
                {
                    if(i==place[k][1]&&j==place[k][2])
                	{
                	    x[i][j]=0;//同上
                	}
                }
                continue;
            }
            x[i][j]=x[i+1][j]+x[i][j-1];
            for (int k=1;k<=n;k++)
            {
                if(i==place[k][1]&&j==place[k][2])
               	{
               	    x[i][j]=0;//同上
               	}
            }
        }
    }
    cout<<x[1][b]<<endl;//输出
    return 0;//愉快地结束
}
```

---

## 作者：梦里调音 (赞：2)

我居然~~傻逼~~用了回溯。。。

```
#include <bits/stdc++.h>
using namespace std;
bool v[10001][10001];
int a,b,n,sx,sy,ans;
int dfs(int x,int y){
	if(x==a&&y==b){
		ans++;
		return 0;
	}
	if(v[x+1][y]==0&&x+1<=a){//没有障碍、不超界才可以走
		v[x+1][y]=1;
		dfs(x+1,y);
		v[x+1][y]=0;
	}
	if(v[x][y+1]==0&&y+1<=b){
		v[x][y+1]=1;
		dfs(x,y+1);
		v[x][y+1]=0;
	}
	return 0;
}
int main(void){
	cin>>a>>b>>n;
	for(int i=1;i<=n;i++){
		cin>>sx>>sy;
		v[sx][sy]=1;
	}
	v[1][1]=1;
	dfs(1,1);
	cout<<ans;
	return 0;
}
```
当然这也可以AC，但注意：

## 只允许沿着向东和北的方向行驶

那么，我这回溯有啥用呢？？？

于是，一波经典的深搜：

```
#include <bits/stdc++.h>
using namespace std;
bool v[10001][10001];
int a,b,n,sx,sy,ans;
int dfs(int x,int y){
	if(x==a&&y==b){
		ans++;
		return 0;
	}
	if(v[x+1][y]==0&&x+1<=a){//没有障碍、不超界才可以走
		dfs(x+1,y);
	}
	if(v[x][y+1]==0&&y+1<=b){
		dfs(x,y+1);//不用边走边标记辣
	}
	return 0;
}
int main(void){
	cin>>a>>b>>n;
	for(int i=1;i<=n;i++){//输入时标记障碍
		cin>>sx>>sy;
		v[sx][sy]=1;
	}
	v[1][1]=1;//这个其实也没啥用辽
	dfs(1,1);//开始深搜
	cout<<ans;
	return 0;
}
```


---

## 作者：AFOier (赞：2)

深搜题中的大水题。。。

```cpp
#include <iostream>
using namespace std;
int n,m,s,t,x,y,a[21][21]; //a数组标记地图
int dfs(int x1,int y1)//先看下面的main
{
    if(x1==n&&y1==m){s++;return 0;} //如果到达终点了，那么方案数+1
    if(x1+1<=n&&a[x1+1][y1]==0)dfs(x1+1,y1);//如果北边可以走，那么就在北边搜索一次
    if(y1+1<=m&&a[x1][y1+1]==0)dfs(x1,y1+1);//如果东边可以走，那么就在东边搜索一次
    return 0;
}
int main()
{
    cin>>n>>m>>t;
    for(int i=1;i<=t;i++)
    cin>>x>>y,a[x][y]=1;//构建地图
    dfs(1,1);cout<<s<<endl;//深搜后打印
}
```

---

## 作者：仁和_童博扬 (赞：2)

看看各位大佬们不是用DP就是用DFS，我居然傻乎乎的用了BFS……  
我想不到DP真的只能说明我太菜了！  
然而还是水过了……  
这道题用宽搜主要的问题就是会RE，尤其是手动模拟队列的时候……  
我把队列数组一直开到10000000才AC……  
其它的应该没什么好说的，我发这篇题解是想说明，DFS可以做的题，BFS基本也可以做（LJ的思想啊）。  
好了，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a, b, n;
bool g[20][20];
int ans = 0;
struct wyj{//wyj最棒了，%%%
	int x;
	int y;
}q[10000000];//这里的队列数组要开得巨大……不然就会RE
bool check(int x, int y)//检查是否超出地图范围
{
	if(x > a || x < 1)	return false;
	if(y > b || y < 1)	return false;
	if(!g[x][y])	return false;
	return true;
}
void bfs()//宽搜的函数
{
	//队列的基本要素
	int f = 1, e = 1;
	q[1].x = 1, q[1].y = 1;
	while(f <= e)
	{
		wyj u = q[f++], v;//提取队首
		if(u.x == a && u.y == b)//如果已经到达
		{
			ans++;
			continue;//继续下一轮
		}
		
		v.x = u.x + 1, v.y = u.y;
		if(check(v.x,v.y))
			q[++e] = v;//放入队列
		
		v.x = u.x, v.y = u.y + 1;
		if(check(v.x,v.y))
			q[++e] = v;//放入队列
	}
}
int main()
{
	scanf("%d%d%d",&a,&b,&n);
	memset(g,true,sizeof(g));//将所有元素标记为true
	for(int i = 1; i <= n; i++)
	{
		int x, y;
		scanf("%d%d",&x,&y);
		g[x][y] = false;
	}
	bfs();
	printf("%d\n",ans);//输出答案
	return 0;//完美结束程序
}
```

---

## 作者：MY_Lee (赞：2)

### 再版于2019-11-29
写递推的人不多，今天小编就带大家走一波递推。

~~第一次写题解，不喜勿喷，给予支持哦！~~

明显的标数法，为什么要费那么大功夫、时间去写dfs呢？？？

过程如下：

1 1 2 3 5

1 0 1 1 2

1 0 1 0 1

1 1 1 1 1

所以答案是5。

#### 这世上，唯有动规(递推)才是王道。
#### ——xxx神犇
~~隐私原因，不透露真实姓名~~

 废话不多说，上代码:
```cpp

	#include<cstdio>
    #include<iostream>
    #include<cstring>
    using namespace std;
    long long idea[45][45]/*能走通的方法*/,n/*宽*/,m/*长*/,mend/*需要修理的路口个数*/,x/*点x*/,y/*点y*/;
	int main(){
		scanf("%lld%lld%lld",&n,&m,&mend);//输入 
		for(int i=0;i<mend;i++){
			scanf("%lld%lld",&x,&y);//输入 
			idea[m-y+1][x]=-1;//标记（因为如果标记成0，那么就会跟idea数组的初始化搞混，同时生了开vis数组的空间） 
		}
		for(int i=m;i>=1;i--){//第零列默认是一 
			if(idea[i][1]==-1){
				for(int j=i;j>=1;j--){
					idea[j][1]=0;
				}
				break;
			}//当边线施工时，下面都不能走了
			idea[i][1]=1;//默认标记 
		}
		for(int i=1;i<=n;i++){//第m行默认是一 
			if(idea[m][i]==-1){
				memset(idea[m]+i,0,sizeof(n-i));
				break;
			}//当底线施工时，后面都不能走了
			idea[m][i]=1;//默认标记 
		}	
		for(int i=m-1;i>=1;i--){//这里1.他是先输入宽，在输入长 2.他是从南往北的顺序，所以得倒着来 
			for(int j=2;j<=n;j++){//这里1.同上 2.他是从西往东的顺序，所以得顺着来
				if(idea[i][j]==-1){
					idea[i][j]=0;
					continue;
				}//在施工就变成0，跳过 
	/*转移公式*/ idea[i][j]=idea[i][j-1]/*左边*/+idea[i+1][j]/*下面*/;
		}
	}
	printf("%lld\n",idea[1][n]);//输出右上角的数 
	return 0;
}
```

 
好了，这递推的简 ~~(kun)~~ 单 ~~(nan)~~ 程序到此结束了!

在我的帮助下，你是不是已经热情高涨，准备AC此题了呢？

###### 来一场恶斗，证明自己的实力。
###### by  luogu决斗场-新手村-BOSS战-入门综合练习2
好了，小青虫广播到此结束，谢谢大家。

---

## 作者：DEVILK (赞：1)

这题暴力搜索居然过了...

然而dalao们都是用的dp...



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a,b,n,x,y,ans;
int r[17][17];
bool used[17][17];
void dfs(int x,int y)
{
    if(x<1||y<1||x>a||y>b) return;//边界条件
    if(x==a&&y==b)//是否到达目的地
    {
        ans++;
        return;
    }
    if(!used[x][y])//可以走
    {
        used[x][y]=true;
        dfs(x+1,y);//向下或
        dfs(x,y+1);//向右搜索
        used[x][y]=false;//回溯
    }
} 
int main()
{
    cin>>a>>b;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&y);
        used[x][y]=true;//施工的路口不能走
    }
    dfs(1,1);//深度优先搜索
    cout<<ans;
}
```

---

## 作者：ajil (赞：1)

简单粗暴易懂的记忆化搜索

对于一般的递推题如果对递推顺序没啥思路可以直接先写成递归，如果爆时就改成记忆化搜索

···cpp

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int Ma(18); //定成18是为了更好地处理边界
int a,b;
int map[Ma][Ma]; //存储方案数
void init() //初始化
{
    memset(map,-1,sizeof(map)); //-1表示未处理
    map[1][1] = 1;
    for(int i(0);i<=b+1;++i)
        map[0][i] = map[a+1][i] = 0; //左右边界方案数为0
    for(int i(0);i<=a+1;++i)
        map[i][0] = map[i][b+1] = 0; //上下边界方案数为0
}
int f(int x,int y) //记忆化搜索
{
    if(map[x][y]>=0)    return map[x][y];
    else if(map[x][y]==-42)    return 0; //-42表示障碍
    else
        return map[x][y] = f(x-1,y)+f(x,y-1);
}
int main()
{
    cin >> a >> b;
    init();
    int n; cin >> n;
    for(int i(1);i<=n;++i)
    {
        int x,y; cin >> x >> y;
        map[x][y] = -42; //障碍
    }
    cout << f(a,b); //输出(a,b)处的方案数
    return 0;
}
```
```cpp

---

## 作者：Kidd (赞：1)

这题可以用马拦过河卒的思路做（叫递推），但我用的是深搜（叫暴力）。


普及下深搜与宽搜的区别：


深搜是求路径条数，如此题。


而宽搜，是求最短路径的！


此两者，乃骗分神器也（尤其是深搜）！！


不说了，上代码。


var n,m,x,i,b,c,s:longint;a:array[1..1000,1..1000] of boolean;























```cpp
procedure try(y,z:longint);
begin
   if (y=n) and (z=m) then
   begin
      inc(s);
      exit;
   end;//走到了，s+1，并且回到上一层
   if a[y+1,z] and (y+1<=n) then try(y+1,z);//假如此点无坑，且不会越出边界，则往这一路试试
   if a[y,z+1] and (z+1<=m) then try(y,z+1);//同上
end;
begin
   fillchar(a,sizeof(a),true);
   readln(n,m);
   readln(x);
   for i:=1 to x do
   begin
      readln(b,c);
      a[b,c]:=false;//预处理，标记出坑
   end;//补充句，深搜不用加if 学校正在施工，因为你也搜不到啊
   try(1,1);//开始深搜
   writeln(s);//输出路径条数
end.
```

---

## 作者：Ikari_Shinji (赞：1)

## 典型的DFS，上代码：
```cpp
#include<bits/stdc++.h>	//万能头

using namespace std;

const int N=20;		//数组范围
int c[N][N],a,b,n,x,y,ans;//定义变量

void dfs (int x,int y){
	if (x == a &&y == b){//能到达
		ans++;
		return ;
	}
	if (x > a || y > b || c[x][y] == 1){
		return ;		//越界，返回
	}
	dfs (x+1,y);	//向右走
	dfs (x,y+1);	//向上走
}

int main(){
	cin >> a >> b;
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> x >> y;
		c[x][y] = 1;	//障碍物设成1
	}
	dfs (1,1);			//从家（1,1）开始
	cout << ans << endl;//输出
	return 0;			//结束
}
```

### 管理大大求过QAQ
#### ~~面包姐姐好像退役了呢？！555...~~

---

## 作者：Spidey (赞：1)

```cpp
#include<stdio.h>
int N;//N表示有N个施工地点 
int book[40][40]={0};//定义book数组用于表示障碍物 
int place[40][40]={0};//定义place数组用于判断该点是否被走过 
int a,b;//tip:(a,b)是学校的坐标
int p,q;//(p,q)表示施工地点的坐标
int t=0;//t用于计数 
int next[2][2]={
    {1,0},//向北走 
    {0,1}//向东走 
};//定义一个next数组，用于模拟向东/北走 
```
/\*
解释一下函数名后面的参数:

x、y代表着目前“我”所处位置的坐标(即上学中的“我”)

\*/
```cpp
void dfs(int x,int y){
    if(x==a&&y==b){
        t++;
        return;
    }
    int tx,ty;
    int k;
    for(k=0;k<2;k++){
        tx=x+next[k][0]; 
        ty=y+next[k][1];
        if(tx>a||ty>b)
```
/\*
判断是否越界，由于只能向东/北走，所以不必考虑tx和ty会小于0

\*/
```cpp
            continue;//进行下一次循环 
        if(book[tx][ty]==0&&place[tx][ty]==0){
            place[tx][ty]=1;//标记这个点已经走过
            dfs(tx,ty);//搜索下一步
            place[tx][ty]=0;//取消标记 
        }
    } 
    return ;
}
int main(){
    scanf("%d%d",&a,&b);
    scanf("%d",&N);
    int i;
    for(i=0;i<N;i++){
        scanf("%d%d",&p,&q);
        book[p][q]=1;//用book将施工地段的坐标记录 
    }
    place[0][0]==1;
    dfs(1,1);//表示我们刚开始处在(1,1)处 
    printf("%d",t);
    return 0;
}
```

---


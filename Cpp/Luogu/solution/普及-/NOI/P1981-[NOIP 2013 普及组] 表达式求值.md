# [NOIP 2013 普及组] 表达式求值

## 题目背景

NOIP2013 普及组 T2

## 题目描述

给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。


## 说明/提示

对于 $30\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤100$。

对于 $80\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤1000$。

对于 $100\%$ 的数据，$0≤$ 表达式中加法运算符和乘法运算符的总数 $≤100000$。


## 样例 #1

### 输入

```
1+1*3+4
```

### 输出

```
8```

## 样例 #2

### 输入

```
1+1234567890*1```

### 输出

```
7891```

## 样例 #3

### 输入

```
1+1000000003*1```

### 输出

```
4```

# 题解

## 作者：da32s1da (赞：1574)

PY2如此简单
```
print(input()%10000)
```
emmmm…………
输入直接输出！

---

## 作者：wbhpig (赞：365)

这道题真的是水

而且貌似没有人用stack解
```cpp
#include <iostream>
#include <stack>
using namespace std;
stack <int> x;//一个存数字并在最后把它们相加的栈
int main()
{
	int a,b;
	char c;
	cin>>a;//先输入一个数，以后符号+数字输入
	int m=10000;
	a=a%m;//必须的操作
	x.push(a);//压入栈中
	while(cin>>c>>b)
	{
		if(c=='*')//将*之前的数字与*之后的数字积存入
		{
			a=x.top();
			x.pop();
			x.push(a*b%m);
		}
		else//将b存入
			x.push(b);
	}
	a=0;
	while(x.size())
	{
		a+=x.top();
		a%=m;//取模是万恶之源
		x.pop();
	}
	cout<<a<<endl;
	return 0;
}

```
推广一下我的洛谷博客，各位观众老爷们望参观

---

## 作者：__ykl (赞：75)

感觉是目前题解里最简单的做法
处理每个加号之间的乘积再相加
```cpp
#include <cstdio>
const int mod = 10000;
int x,s,t; //x是当前的数，s是和，t是当前段的乘积
char c;
int main(){
    scanf("%d",&t);//先读入第一个数，之后每次读入一个符号一个数
    while(scanf("%c",&c) && c != '\n'){ //最后会读到换行符
        scanf("%d",&x);
        if(c == '*') t = t * x % mod; //是乘号就相乘
        else s = (s + t) % mod,t = x;
        //加号就加上上一段的积，t变为下一段的第一个数
    }
    printf("%d\n",(s + t) % mod); //加上最后一段的积
    return 0;
}
```

---

## 作者：菰冭 (赞：16)

看了一圈题解没有用Python3水过的……

我写一下Py3怎么过⑧

首先我们很容易想到```eval()```的特性，很容易地写出这样的代码：

```python
print(eval(input())%10000)

```
开心的提交~

然后您就会发现只有$80$分，RE了两个点……

一看RE原因
 *输入长度不合法*。。。
 
 那我们就好办啦，我们让输入长度合法就好啦
 
于是有了以下代码（还可以压行但我懒了(ﾉ*･ω･)ﾉ）：

```python
S =input()
ans=0
mid = int(len(S))
j=0
for i in range(0,mid):
    if S[i]=="+":
        s1=S[j:i]
        j=i
        ans=((ans%10000)+eval(s1)%10000)%10000
ans=((ans%10000)+eval(S[j:mid])%10000)%10000

print(ans)
```

~~Python大法好！~~


---

## 作者：皎月半洒花 (赞：13)

这里说一种题解里面没有用过的**表达式树**写法（其实是语义树的某种水到天际的真子集写法）。

大概就是每个点要么是数值，要么是符号；对于一个符号$x$，我们通过计算其左右子树的值，并通过$x$的符号连接左右的值实现运算效果。对于一棵子树，它代表的就是原字符串的一个区间。同时，优先级也需要注意。假设对于某一棵子树内，既有`+`也有`*`也有`^`，那么根据优先级来，`*`的深度应该大于`+`的、`^`的深度应该大于`*`的，这样才能保证`+`是最后被计算到的。

然后本题只有`+`和`*`，并且需要$\bmod~10000$。

似乎表达式树的复杂度应该是$O(|S|)$的，但是原谅我写假了，在每一层会多算几遍，但是过$1e5$还是没问题的。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>

#define Mod 10000
#define rr register
#define MAXN 2000010

using namespace std ; 

int tp, root ;
int N, brac[MAXN], stk[MAXN] ; 

char In[MAXN], op[MAXN] ; 
int L[MAXN], R[MAXN], ans, val[MAXN] ;

inline bool isop(const char &x){
	return x == '+' || x == '-' || x == '*' || x == '/' || x == '^' ;
}
int build(const int &l, const int &r){
	if (brac[l] == r) return build(l + 1, r - 1) ; 
	rr int rt = 0, ls = 0, rs = 0, x = 0 ; 
	for (rr int k = l ; k <= r ; ++ k){
		if (In[k] == '(') k = brac[k] + 1 ; if (k > r) break ; 
		if ((In[k] == '+' || In[k] == '-') && k != l && !isop(In[k - 1])) { rt = k ; break ; }
		if (In[k] == '*' || In[k] == '/') ls = k ; if (In[k] == '^' && !rs) rs = k ; 
	}
	if (rt) x = rt ; else if (ls) x = ls ; else x = rs ; 
	if (!x) { 
		x = r, op[x] = '?' ; 
		sscanf(In + l, "%d", &val[x]) ; 
		val[x] %= Mod ; return x ; 
	}
	op[x] = In[x] ; L[x] = build(l, x - 1), R[x] = build(x + 1, r) ; return x ; 
}
int expow(int a, int b){
	rr int res = 1 ; 
	while (b){
		if (b & 1) (res *= a) %= Mod ;
		(a *= a) %= Mod ; b >>= 1 ;  
	}
	return res ; 
}
int dp(const int &x){
	if (op[x] == '?') return val[x] ; 
	rr int l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = 0.0 ;
	if (op[x] == '+') res = (l + r) % Mod ;
	if (op[x] == '-') res = (l - r) % Mod ;
	if (op[x] == '*') res = (l * r) % Mod ;
	if (op[x] == '/') res = l * expow(r, Mod - 2) % Mod ;
	if (op[x] == '^') res = expow(l ,r) ; return res ; 	 
}
signed main(){
	cin >> In + 1, N = strlen(In + 1) ;
	for (rr int i = 1 ; i <= N ; ++ i){
		if (In[i] == '(') stk[++ tp] = i ; 
		if (In[i] == ')') brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;
	}
	root = build(1, N), cout << dp(root) << endl ; return 0 ;  
}
```

---

## 作者：multiverse_ (赞：8)

## 输入可以用scanf简化成一行（没见过这种操作）

第一次蒟蒻我码了一个小时70行10分，第二次重写才AC
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=10000;
int a[100010],op[100010];//a记录操作数，op记录操作符 
int n=1,ans=0,i=1;
int main() {
	while(scanf("%d%[+*]",&a[n],&op[n])==2)n++;
	/*一个非常好的用法，省了很多事 
	每次输入一个整数和一个符号，符号是在+和*中选一个
	scanf返回读到的个数，如果不是两个（说明只读到了最后一个整数）
	到么字符串就结束了，停止读入，n记录一共有多少个数（共有n-1个符号）*/ 
	while(i<=n){//当i不超过操作数的个数 
		int p=i+1,num=a[i]%mod;
		//num记录乘积最先开始为当前操作数，p记录i以后的操作下标 
		if(op[i]=='*'&&i<n){//如果当前这个操作符是*，进行连乘 
			while(op[p]=='*'&&p<n)num=num*(a[p]%mod)%mod,p++;
			//当符号一直为*时继续乘 
			num=num*(a[p]%mod)%mod;
			//再把最后一个数乘上去 如a*b*....*z,把最后一个操作符后的z乘上 
			p++;
			//最后从下一个数、符开始 
		}
		ans=(ans+num)%mod;//将所得乘积累加到ans，如果不是*，num为a[i] 
		i=p;//更新i 
	}
	cout<<ans%mod<<endl;
	return 0;
}


```

---

## 作者：niuniudundun (赞：7)

# 题目大意

计算输入表达式的值。

# 解法

用 `stack` 栈计算。

定义一个 `stack<int>` 变量 $k$。首先输入一个整数 $num$，将其加入 $k$ 中。随后循环，每轮循环输入字符 $a$ 和一个整数 $num$，如果 $a$ 是 `*` 则将 $k_{top}$（$k$ 的栈顶元素）与 $num$ 进行运算，将结果 $k_{top}num$ 加入 $k$ 中；否则直接加入 $k$ 中。当输入完成时统计 $k$ 所有元素之和，输出他。**不要忘记 $\bmod 10000$（输出后四位）**。这就是计算表达式的值的基本原理。

代码：

复杂度：$O(l+k_1)$，$l$ 是表达式长度，$k_1$ 是 $k$ 的元素个数。

```cpp
#include<iostream>
#include<cstring>
#include<stack>
using namespace std;
const int mod=10000;
stack<int> k;
char a;
int num=0,ans=0;
int main(){
	cin>>num;
	k.push(num);
	while(cin>>a>>ans){
		if(a=='*'){
			int t=k.top();
			k.pop();
			k.push(ans*t%mod);
		}else{
			k.push(ans%mod);
		}
	}
	num=0;
	while(!k.empty()){
		num+=k.top()%mod;
		num%=mod;
		k.pop();
	}
	cout<<num%mod<<endl;
	return 0;
}
```

---

## 作者：_lxc__ (赞：4)

考虑 stack。

* 首先我们发现输入的算式一定是一个数字一个符号这么输入的，所以可以将数字和符号分成两类来交替输入，其中数字用整型，符号用字符型。

* 接着，考虑两种情况：

  *  当前符号为 `+`，则将当前输入的数字存入栈，因为后面可能有乘号（乘号的优先级大于加号）。
 
  *  当前符号为 `*`，将栈顶加上当前数字，再进行出栈操作，最后将当前数入栈。
 
* 最后，将栈中的所有元素累加即为最后答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,ans=0;
char op;
stack<long long> st;
int main(){
	cin>>x;
	st.push(x);
	while(cin>>op>>x){
		if(op=='+'){
			st.push(x);   //入栈
		}else{
			x=(st.top()*x)%10000;   //边乘边取模
			st.pop();   //出栈
			st.push(x);  //入栈
		}
	}
	while(st.size()){
		ans=(ans+st.top())%10000;   //边加边取模
		st.pop();
	}
	cout<<ans;
	return 0;
}
```

最后温馨提示：不开 `long long` 见祖宗。

---

## 作者：qhr2023 (赞：2)

## solution

小模拟。利用栈来解决。

这里取后四位可以用取模来解决。

先读入一个数并入栈，之后每次读入一个符号一个字符，如果该符号是乘法则与栈顶相乘，否则将数字入栈。扫完字符串后，再遍历栈把所有数加起即可。

[通过记录](https://hydro.ac/record/677cea3cefb286b704c711f6)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int> st;
char c;
int x, ans, t;
int main(){
	cin >> x;
	st.push(x);
	while(cin >> c >> x)
		if(c=='*')
			st.top()=x*st.top()%10000;
		else
			st.push(x%10000);
    for ( ; st.size(); st.pop())
		ans=(ans+st.top())%10000;
	cout << ans%10000;
	return 0;
} 
```

---

## 作者：Loyal_Soldier (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1981)
### 思路
我们用一个数组 $c$ 代表输入中的符号，数组 $a$ 代表输入中的数字。然后逐个判断当前符号，如果当前 $c_i$ 为 `*`，则进行乘法， $a_i=a_i\times a_{i+1}$，不过记得将 $a_{i+1}$ 设为 $0$ 。最后将所有 $a_i$ 相加。

注意，每加一次记得将最终答案 $\bmod\ 10000$ ，因为最终答案只输出后四位。
### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[114514],ans;//ans为最终答案
char c[114514];
signed main(){
	cin>>a[1];
	int cnt=1;
	while(cin>>c[cnt]){
		cin>>a[++cnt];
		a[cnt]%=10000;
	}//输入
	for(int i=cnt;i>=1;i--){
		if(c[i]=='*'){
			a[i]*=a[i+1];
			a[i]%=10000;
			a[i+1]=0;
		}//如果是乘号的情况
	}
	for(int i=1;i<=cnt;i++){
		ans+=a[i];
		ans%=10000;
	}//累加最终答案
	cout<<ans%10000;//输出
	return 0;
}
```

---

## 作者：TainityAnle (赞：2)

### 题意

这个题的题意非常简单，就是给你一个只有加和乘运算的式子，求出结果取模 $10000$ 的值。

### 思路

首先解决输入问题。由于 `scanf` 可以限制格式，又因为运算符一定是长度为 $1$ 的字符，所以可以读一个字符就接着读一个数字，直到读完。

```cpp
while(~scanf("%c",&c[cc++]))
		scanf("%d",&b[cc]);
```

代码这样写。

读入后，把运算符都加到字符数组 $c$ 中，把数字存到 $b$ 中。$c_i$ 对应着 $b_i$ 和 $b_{i+1}$ 的运算。

因为先进行乘的操作再进行加的操作，二者互不影响，所以可以先单独处理乘，乘全都处理完之后再统一处理加。

遍历 $c$ 数组，如果是 `*` 字符，就把 $b_i\times b_{i+1}$ 存到 $b_{i+1}$ 中，再把 $b_i$ 赋成 $0$。

为什么要把数值存到 $b_{i+1}$ 中而不是 $b_{i}$ 中？因为有可能右边还有连续的乘法操作。即若 $c_{i+1}$ 也是 `*`，还需要将 $b_{i+1}$ 和 $b_{i+2}$ 相乘，如果我们将数字存到 $b_i$ 中而把 $b_{i+1}$ 赋成 $0$ 就没法接着乘了。

最后剩余的所有操作都是加了，直接把 $b$ 数组求和就行了。

### AC Code

```cpp
#include<iostream>
#include<string>
#include<cstdio>
using namespace std;
long long b[100005],cc,ans;
char c[100005];
int main() {
	cin>>b[0];
	while(~scanf("%c",&c[cc++]))
		scanf("%d",&b[cc]);
	for(int i=0; i<=cc; i++) {
		if(c[i]=='*') {
			b[i+1]*=b[i];
			b[i+1]%=10000;
			b[i]=0;
		}
	}
	for(int i=0; i<=cc; i++) {
		ans+=b[i];
		ans%=10000;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：1)

我的思路是，把连续多个乘法运算看成一个块。

比如说，计算 $1+2\times 3\times 5+4$。

我的计算顺序是：

1. 答案加上 $1$。

2. 答案加上 $2 \times 3 \times 5=30$。

3. 答案加上 $4$。

根据这种方法模拟即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int x,cnt;
char op;
signed main(){
	cin>>x;
	while(cin>>op){
		if(op=='*'){
			int w;
			cin>>w;
			w%=10000;
			x*=w;
			x%=10000;
		}else{
			cnt+=x;
			cnt%=10000;
			cin>>x;
			x%=10000;
		}
	}cnt+=x;
	cnt%=10000;
	cout<<cnt;
	return 0;
} 
```

---

## 作者：zhuangjinning (赞：1)

## 题目描述

给出一个运算仅由加和乘的中缀表达式，求它的值。

## 解析

本蒟蒻用的是栈。

### 1. 计算优先级，构建表格

本题只有 ```+``` 和 ```*``` 运算符。可以构建一个 $2\times 2$ 的表格，左侧代表栈顶元素，上面代表当前元素。但我又加上了一个空格，为方便结束程序。



||+|*|(|)|
|:-:|:-:|:-:|:-:|:-:|
|+|||||
|*|||||
|(|||||
|)|||||



这个表格带表运算优先级，比如当前栈顶的运算符为 ```+``` 且当前读入的运算符也是 ```+``` 则可以直接算栈顶的运算，所以 ```+``` 遇到 ```+``` 是可以直接算的，对应的格子填 $1$。

||+|*|(|)|
|:-:|:-:|:-:|:-:|:-:|
|+|1||||
|*|||||
|(|||||
|)|||||

同理，当 ```*``` 遇到 ```*``` 时也可以直接算，但 ```)``` 遇到 ```)``` 是个非法状态，记为 $3$。

||+|*|(|)|
|:-:|:-:|:-:|:-:|:-:|
|+|1||||
|*||1|||
|(|||||
|)||||3|

但当 ```+``` 遇到 ```*``` 时就不能算，因为加法的优先级小于乘法，应先算乘法，再算加法。但当 ```*``` 遇到 ```+``` 时就可以直接算。接下来，就可以推出全表（$2$ 表示括号匹配上了）。

||+|*|(|)|
|:-:|:-:|:-:|:-:|:-:|
|+|1|0|0|1|
|*|1|1|0|1|
|(|0|0|0|2|
|)|3|3|3|3|

就这样我们的表格就构建完了，具体有什么用，就看下面吧。

### 2. 计算

开两个栈，一个叫 $s1$，一个叫 $s2$，分别存储运算符和数。

从前向后扫描字符串。

遇运算数，直接进运算数栈。

遇运算符，与运算符栈顶的运算符进行比较：

若栈顶优先级低，栈顶运算符还不能运算，压栈。

若相等，直接出栈。

若栈顶优先级高，可以计算！

说白了：能算就算，算不了压栈。

在比较优先级的时候就会用到上面的那张表。

**注意：题目只让保留后四位，所以计算过程中一定要取模。**

## AC 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int t[256];
int pri[4][4]={//表格
	1,0,0,1,
 	1,1,0,1,
 	0,0,0,2,
 	3,3,3,3
};
unsigned long long cal(unsigned long long a,char op,unsigned long long b){//计算
	if(op=='+'){
		return a+b;
	}else{
		return a*b;
	}
}
stack<char> s1;//一定要开char
stack<unsigned long long> s2;
int main(){
	t['+']=0;
	t['*']=1;
	t['(']=2;
	t[')']=3;//将运算符对应数字
	cin>>s;
	int len=s.size();
	int i=0;
	s1.push('(');
	s[len]=')';//将首尾加一对()
	while(!s1.empty()){
		if(isdigit(s[i])){//是数字
			unsigned long long num=0;
			while(isdigit(s[i])){
				num*=10;
				num+=int(s[i]-'0');
				num%=10000;//一定要取摸
				i++;
			}
			s2.push(num);
		}else{
			int cmp=pri[t[s1.top()]][t[s[i]]];
 			if(cmp==0) s1.push(s[i++]);//不能计算
 			else if(cmp==2){//括号匹配，直接弹栈
 				s1.pop();
 				i++;
			}else{//可以计算
				char op=s1.top();s1.pop();
				int n2=s2.top();s2.pop();
				int n1=s2.top();s2.pop();//注意弹栈顺序，但在这道题里看不出来什么区别……
				int res=cal(n1,op,n2);
				s2.push(res%10000);//一定要取模
 			}
 		}
 	}
 	cout<<s2.top()%10000<<endl;
	return 0;
}

```

---

## 作者：Jerry_zpl (赞：0)

本题算法：模拟，栈。\
由于本题的答案很大且输入的是算式，所以我们可以用栈来模拟。我们可以采用边输入边算的方式来做。每输入一个符号就输入一个数字。因为一开始输入的是数字，所以我们要在程序的开头读入数字 $x$。\
我们可以在循环里分开处理：

- 如果符号是乘号，那么用栈顶元素乘 $x$ 再取模 $10000$。
- 如果是加号，那么更新栈顶，存储 $x$ 取模 $10000$ 的结果即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
long long stk[200005],x,top=0;
char c;
signed main()
{
	cin>>x;
	stk[++top]=x%10000;
	while(cin>>c>>x)
	{
		if(c=='*')
		{
			long long y=(stk[top]*(x%10000))%10000;
			stk[top]=y; 
		}
		else stk[++top]=x%10000;
	}
	long long ans=0;
	for(int i=1;i<=top;i++) ans=ans+stk[i]%10000;//把答案加起来
	cout<<ans%10000;
	return 0;
}
```

---


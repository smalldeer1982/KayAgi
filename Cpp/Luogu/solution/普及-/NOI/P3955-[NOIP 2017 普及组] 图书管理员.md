# [NOIP 2017 普及组] 图书管理员

## 题目背景

NOIP2017 普及组 T2

## 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。 小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。


## 说明/提示

**数据规模与约定**

对于 $20\%$ 的数据，$1 ≤ n ≤ 2$。

另有 $20\%$ 的数据，$q = 1$。

另有 $20\%$ 的数据，所有读者的需求码的长度均为 $1$。

另有 $20\%$ 的数据，所有的图书编码按从小到大的顺序给出。

对于 $100\%$ 的数据，$1 ≤ n ≤ 1000,1 ≤ q ≤ 1000$，所有的图书编码和需求码均不超过 $10^7$。


## 样例 #1

### 输入

```
5 5 
2123 
1123 
23 
24 
24 
2 23 
3 123 
3 124 
2 12 
2 12```

### 输出

```
23 
1123 
-1 
-1 
-1 ```

# 题解

## 作者：LinkyChristian (赞：143)

将读者的需求码与图书编码配对。

- 把需求码与图书编码配对 = 求图书编码的后 X 位
- 求图书编码的后 X 位 = 把前面的都去掉。


如何把前面的无关数字去掉呢？这时候我们想起了 $\%$ 运算。

对于一个数$a$，很显然它的个位数是：$a \% 10$ 。

但是这是我们人工计算出的结果，而各个需求码的位数不同，这时候就需要找出一个规律。

对此我们发现了规律：对一个数 $a$ 取其后 $n$ 位，就是 $a \% 10^n$ 。

cmath 头文件中带有专门执行幂运算的函数。

其中有一个要注意的点是，pow 函数并不能直接进行 mod 运算，需要将其带入一个变量进行运算。

遍历求最小值即可。

### 最后贴代码

```
#include<iostream>
#include<cmath>
using namespace std;
int n,q,book[6666],len[6666],num[6666];

int main()
{
    cin>>n>>q;
    for(int i=1; i<=n; i++) cin>>book[i];
    for(int i=1; i<=q; i++) {
        cin>>len[i]>>num[i];
        int tmp = pow(10,len[i]),min = 10000001;
        for(int j=1; j<=n; j++) if(book[j] % tmp == num[i] && book[j] < min) min = book[j];
        if(min != 10000001) cout<<min<<endl;
        else cout<<-1<<endl; 
    }
    return 0;
}
```

---

## 作者：VitrelosTia (赞：15)

怎么题解区都写得这么麻烦啊？看到这个题第一眼就想到字符串和 `map`，我的做法应该是比题解区绝大多数做法都好懂和好写的。

首先看到题目中的“结尾”就想到了 `string.substr()`，就可以直接枚举出每个编码的后缀，然后拿 `map` 存下当前后缀的最小编码，每次查询用 `map.count()` 判断是否有出现过就做完了。

这里要注意的是字符串比较大小很坑，最好是自己手写一个传 `string` 的 `min` 函数，另一个要注意的是当后缀第一次出现时直接存当前编码，不然无法判最小值。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, q;
map <string, string> mp;

string strmin(string x, string y) {
    if (x.size() < y.size()) return x;
    if (y.size() < x.size()) return y;
    for (int i = 0; i < x.size(); i++) {
        if (x[i] < y[i]) return x;
        if (y[i] < x[i]) return y;
    }
    return x;
}

int main() {
    cin >> n >> q;
    while (n--) {
        string s;
        cin >> s;
        for (int j = 0; j < s.size(); j++) {
            if (mp[s.substr(j)] == "") mp[s.substr(j)] = s; // 第一次出现的后缀直接存当前编码
            else mp[s.substr(j)] = strmin(mp[s.substr(j)], s); // 更新最小值
        }
    }
    while (q--) {
        int x;
        string s;
        cin >> x >> s;
        if (!mp.count(s)) puts("-1");
        else cout << mp[s] << '\n';
    }
    return 0;
}
```

---

## 作者：The_Best_OIer (赞：8)

一道水题竟然还能写题解？

阅读题目后发现，首先需要把图书编码进行升序排序，也就是从小到大。题目说判断书编码的后几位相同，所以肯定要提取后几位，有两种方法：第一，用 pow 函数。第二，取模 $10 ^ x$ 。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000};
int n, q, x, y, a[1005];
int main() {
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	for (int i = 1, j; i <= q; i++) {
		cin >> x >> y;
		for (j = 1; j <= n; j++) {
			if (a[j] % mod[x] == y) {
				break;
			}
		}
		if (j <= n) cout << a[j] << endl;
		else cout << -1 << endl;
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/197305556)。

---

## 作者：optimize_2 (赞：6)

## 此题可以用字典树写

字典树顾名思义,是一棵树.

你可以在里面插入字符串和询问某串是否被入(这道题是插入数字,而且有些操作不太一样)当它里面什么也没有的时候长这样:

![blob](https://i.loli.net/2019/09/20/iA1TCO5zVLaJbB3.png)

~~像什么~~

除根节点外,每个节点都代表一个数字,从根节点到树上某点走过的最短路径就是一个字符串.

让我们来看看插入114514之后会发生什么:

![blob](https://i.loli.net/2019/09/20/8FSc1GEN6xkKUAI.png)

但是------

这里有一个问题:

>
>如果插入114514,查询114514返回的值自然是true(这里不考虑最小值),但查询514的时候似乎也会返回true...
>

所以,当插入一个数的时候,要在插入完的地方做个标记,查询时,如果结束为止有一个标记,返回true,否则返回false.

就像这样:

![blob](https://i.loli.net/2019/09/20/fnx4BSEZ9i6mzoR.png)

现在我们再插入6749与1949.

![blob](https://i.loli.net/2019/09/20/3fJt7g1dsbDYazN.png)

可以发现,如果这些数字的前缀重复大,那么存储占的空间就会非常少.

### 现在我们考虑如何实现代码:

字典树节点定义:

```cpp
struct trie{
    int id,son[10];  //当前节点编号与10个子节点编号
    bool use[10]; //子节点是否被插入过
    bool wd; //这是否是个单词(如图中的1,6,1节点wd的值就是true)
}t[10010];  //也可以用vector<trie>t;
```

但是本题似乎要求最小值233333...
那就加个变量mn呗:

```cpp
struct trie{
    int id,son[10];
    bool use[10];
    bool wd;
    int mn;
    tries()
    {
        mn=2147483647;  //一定要初始化
    }
}t[10010];
```

对应地,我们可以得到字典树的插入:

```cpp
void ins(int now,int key,int tmp)
{
    t[now].mn=min(t[now].mn,tmp);  //插入时记得维护最小值 
    if(key==0)  //插入完毕 
    {
        t[now].wd=true;  //标记这里是个完整的图书编号 
        return;
    }

    if(t[now].use[key%10]) ins(t[now].son[key%10],key/10,tmp);  //%取后缀,/去后缀 
    else{
        t[now].use[key%10]=true;  //儿子节点被使用 
        t[now].id=++nowid;  //儿子节点被使用 
        t[now].son[key%10]=++nowid;  //儿子节点被使用 
        ins(t[now].son[key%10],key/10,tmp);  //插入儿子节点 
    }
}
```

还有查询:

```cpp
int ask(int now,int key,int tmp)
{
	if(key==0)  //查询结束 
    {
        return t[now].mn;  //返回最小值 
    }

    if(t[now].use[key%10]) return (ask(t[now].son[key%10],key/10,tmp));  //查询儿子节点 
    else{
        return -1;  //t[now].use[key%10]如果等于false代表该儿子节点根本不存在,当然返回-1啦 
    }
}
```

下面是代码:

```cpp
#include<bits/stdc++.h>
using namespace std;

struct trie{
    int id,son[10];
    bool use[10];
    bool wd;
    int mn;
    tries()
    {
        mn=2147483647;  //一定要初始化
    }
}t[10010];

int nowid=1;  //当前节点数 
int n,q,len;  //n,q如题,len没什么用 

int num;  //插入和查询的输入 

void ins(int now,int key,int tmp)
{
    t[now].mn=min(t[now].mn,tmp);  //插入时记得维护最小值 
    if(key==0)  //插入完毕 
    {
        t[now].wd=true;  //标记这里是个完整的图书编号 
        return;
    }

    if(t[now].use[key%10]) ins(t[now].son[key%10],key/10,tmp);  //%取后缀,/去后缀 
    else{
        t[now].use[key%10]=true;  //儿子节点被使用 
        t[now].id=++nowid;  //儿子节点被使用 
        t[now].son[key%10]=++nowid;  //儿子节点被使用 
        ins(t[now].son[key%10],key/10,tmp);  //插入儿子节点 
    }
}

int ask(int now,int key,int tmp)
{
	if(key==0)  //查询结束 
    {
        return t[now].mn;  //返回最小值 
    }

    if(t[now].use[key%10]) return (ask(t[now].son[key%10],key/10,tmp));  //查询儿子节点 
    else{
        return -1;  //t[now].use[key%10]如果等于false代表该儿子节点根本不存在,当然返回-1啦 
    }
}

int main()
{
    t[1].id=1;  //t[1]是根,里面什么都没有 
    cin>>n>>q;
    for(int i=1;i<=n;i++)
    {
        cin>>num;
        ins(1,num,num);  //插入num 
    }
    for(int i=1;i<=q;i++)
    {
        cin>>len>>num;  //不用管len 
        cout<<ask(1,num,num)<<endl;  //查询num 
    }
    return 0;
}
```

## 注:本题使用的trie并不是标准的字典树,而是变了形的(存放最小值,插入数字)

---

## 作者：Malkin_Moonlight (赞：4)

## Solution

题外话：这么简单的题目到现在都没封题解通道？

首先肯定是先将输入的图书编码进行升序排序。因为题目说的是书编码的后几位相同，因此只需要对比后几位。看到大家基本都在用 pow 函数，我来说一下我的方法。

> 所有的图书编码和需求码均不超过 $10^7$。

所以可以先写出一个数组，分别为 $10^0, 10^1, 10^2, 10^3, 10^4, 10^5, 10^6, 10^7$，这样就能用 $x$ 为下标直接访问模数了，不用再用 pow 计算了。

回归正题，由于数组排过序，所以直接从 $1$ 开始遍历，一旦发现满足，那么就 `break`。计算完成输出即可。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000};
ll n, q, x, y;
ll a[1005];
int main() {
	cin >> n >> q;
	for (ll i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	for (ll i = 1; i <= q; i++) {
		cin >> x >> y;
		ll j;
		for (j = 1; j <= n; j++) {
			if (a[j] % mod[x] == y) {
				break;
			}
		}
		if (j <= n) cout << a[j] << endl;
		else cout << -1 << endl;
	}
	return 0;
}
```

---

## 作者：ZAYNAab (赞：2)

## 题意

给你 $n$ 个数，有 $q$ 次询问。

每次询问都给你一个数 $y$ 和 $y$ 的位数 $x$。

输出在 $n$ 个数中使得满足 $y$ 为该数的后缀最小的一个。

## 解题分析

可以用 `sort` 将这 $n$ 个数从小到大排序，使得可以在遍历这个数组时第一个满足条件的即为最小的。

判断一个 $x$ 位的数是否为一个数的后缀，可以先获取该数的后 $x$ 位，即对该数取余 $10^x$，再来比较。

如果遍历了这 $n$ 个数一遍还没有找到符合要求的数，输出 $-1$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005],n,q,x,y;
int tenpow(int x){
	int ans=1;
	for(int i=1;i<=x;i++)ans*=10;
	return ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	while(q--){
		cin>>x>>y;
		int flag=1;
		for(int i=1;i<=n;i++)if(a[i]%tenpow(x)==y){cout<<a[i]<<"\n";flag=0;break;}
		if(flag==1)cout<<-1<<"\n";
	}
	return 0;
}

```

---

## 作者：qhr2023 (赞：2)

## solution

模拟题。

关键在如何判断图书编码是否以需求码结尾，这个可以用模运算来解决。对于一个长度为 $x$ 的需求码，一个编码对 $10^x$ 取模就可以得到后 $x$ 位数字，判断后 $x$ 位数字是否与需求码相等即可。

先把所有图书编码按升序排序，对于每次询问，从头遍历图书编码，找到的第一个符合要求的编码就是答案。

[通过记录](https://hydro.ac/record/677a98420a9b1ec9986b4833)。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010], n, q;
int main(){
	cin >> n >> q;
	for(int i=1; i<=n; i++) 
        cin >> a[i];
    sort(a+1, a+n+1);
	for(int x, y, ans=-1; q--; ans=-1){
		cin >> x >> y;
		for (int i=1; i<=n&&ans==-1; ++i)
			if (a[i]%(int)(pow(10, x))==y) 
				ans=a[i];
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：Kawaii_qiuw (赞：2)

题面很好理解，不再赘述

### 解题思路

很明显读者的“需求码”比图书编码要短，且需求码是图书码的后缀。这样，可以想到一种思路：映射。

首先，开一个数组 $table$，初始化为 $-1$。假设输入的图书编码为 $1234$，那么我们就令 $table_{1234} \to table_{234} \to table_{34} \to table_{4} \to 1234$，这样查询“需求码”时会很方便。比如这时有需求码 $34$，那么我们直接查询 $table_{34}$，就可以得到图书编码 $1234$。不过我们后面实现会有所优化，将一个指针保存到对应位置，而不是实际数据。

当然，图书编码有许多，如何才能保证读者获取的图书的编码是最小的呢？这就需要将图书编码排序，然后从大到小按照刚才的方式处理，这样较小的编码会覆盖掉较大的编码。

### 实现
1. 输入图书编码。
2. 将图书编码排序。
3. 从大到小依次处理图书编码。
4. 输入查询。
5. 在表中查询映射关系，输出。

### 代码

比较详细了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int books[1005];
int request;
short table[10000005];
int main(){
    int n,q,devnull; //devnull用作垃圾桶
    cin >> n >> q; //输入图书和查询数量
    for(int i = 1;i <= n;i++){
        cin >> books[i]; //输入图书编码
	}
    sort(books + 1,books + n); //排序
    for(int i = n;i >= 1;i--){ //从大到小处理图书编码
        int copy = books[i]; //复制编码，然后再修改
        while(copy){ //重复一下操作直到编码被“削”完
            table[copy] = i; //建立映射关系
            copy = copy % int(pow(10,int(log10(copy)))); //每次削掉编码的最高位
        }
    }
    books[0] = -1; //table表中初始值都是0，指向books[0]，所以需要把books[0]设置为-1，这样没查询到的就会输出-1
	for(int i = 0;i < q;i++){ //处理查询
        cin >> devnull >> request;
        cout << books[table[request]] << "\n";
    }
    return 0;
}

```
[AC 记录。](https://www.luogu.com.cn/record/197250769)

完结撒花。

---

## 作者：zjinyi (赞：2)

# P3955 图书管理员 题解
## 题目大意

每本书都有一个正整数编码，每位的读者有一个正整数需求码。如果一本书的编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。 
求：对于每一位读者，他所需要的书中编码最小的那本书，如果没有他需要的书，输出 `-1`。

## 题目分析
先将编码从小到大排序，再遍历编码数组，第一个满足条件的就是编码最小的书。
取编码的后 $x$ 位，可以用编码求余 $10 ^ x$。

## 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int a[1001], ten[11];
int main()
{
    ten[0] = 1;
    for (int i = 1; i < 10; ++i) // 预处理 10 的 num 次方
    {
        ten[i] = ten[i - 1] * 10;
    }
    int n, q;
    cin >> n >> q;
	for (int i = 0; i < n; ++i)
    {
        cin >> a[i];
    }
	sort(a, a + n); // 从小到大排序
	while (q--)
    {
		int num, s;
        cin >> num >> s;
		bool flag = false; // flag 记录有没有满足要求
		for (int i = 0; i < n; ++i)
        {
            if (a[i] % ten[num] == s) // 求需求码是否为编码的后缀
            {
                cout << a[i] << endl;
                flag = true;
                break;
            }
    	}
        if (flag == false) // 无解情况输出 -1
        {
            cout << -1 << endl;
    	}
    }
    
    return 0;
}
```

---

## 作者：Like_Amao (赞：2)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P3955)

**题目大意**

题目里描述的够详细了，无需多言。

**思路**

我们可以用数组 $a$ 来存图书编号，因为我们要求的是每个顾客所需要的图书中编号最小的，所以我们可以在输入完后给 $a$ 数组排序，来保证输出为最小，然后从 1 循环到 $q$，每次循环内定义一个变量 $ans$，用来存答案，初始值赋值为 -1，然后从 1 循环到 $n$，来看每本书是否满足顾客要求，若满足，保存答案，并退出循环，然后再输出即可。

**代码**


```cpp
#include<bits/stdc++.h> 
using namespace std;
int a[1000001];
int main()
{
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=q;i++)
	{
		int x,y,ans=-1;
		cin>>x>>y;
		int t=pow(10,x);
		for(int j=1;j<=n;j++)
		{
			if(a[j]%t==y)
			{
				ans=a[j];
				break;
			}
		}
		cout<<ans<<endl;
	}
    return 0;
}
```

---

## 作者：superLouis (赞：2)

## 题解：P3955 [NOIP2017 普及组] 图书管理员
如此简洁的题面居然只招来了这么点题解？

----------
### 1. 解题思路
题目过于简单了啊！我们需要思考的问题是怎么判断某一个图书编码的结尾是否等于一个需求码。我们设需求码的位数为 $l$，显然图书编码的长度小于 $l$ 肯定不行，讨论图书编码的长度大于等于 $l$ 的图书编码 $s$。我们发现，只要找到 $s$ 的末 $l$ 位并且判断是否等于该需求码即可，注意这里有前导零也没问题，因为会自动抹掉。

其实求出 $s$ 的最后 $l$ 位也很简单，就是拿 $s$ 对 $10^l$ 取模即可。

为了满足题目所说的“对于每一位读者，求出他所需要的书中图书编码最小的那本书”，可以在输入完所有的图书编码后把这些先排序再去处理。

----------
### 2. 代码实现
代码也是十分简单啦。
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn = 30;
vector<int> str;
int n, m, s;
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> s;
        str.push_back(s);
    }
    sort(str.begin(), str.end());
    for (int i = 1; i <= m; i++) {
        int len; cin >> len >> s;
        bool flag = false;
        for (int j = 0; j < str.size(); j++) 
            if (str[j] % (int) pow(10, len) == s) {
                cout << str[j] << "\n";
                flag = true;
                break;
            } 
        if (!flag) cout << -1 << "\n";
    }
    return 0;
}
```
[Accepted 记录](https://www.luogu.com.cn/record/172824694)

---

## 作者：GSQ0829 (赞：2)

[P3955 [NOIP2017 普及组] 图书管理员](https://www.luogu.com.cn/problem/P3955#submit)

---
### 思路
---
先将输入的图书编码进行升序排序。

而后对于每个读者，就从数组中顺序查找满足图书编码末 $len$ 位与图书编码第一个相同的，这个就是最小值。

时间复杂度只有 $O(Q \times N)$，还是不高的。

---

### 代码
---
```cpp
#include<bits/stdc++.h>
using namespace std;

const int m[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000};
int a[1001], n, q, x, y;

int main() {
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	for (int i = 1, j; i <= q; i++) {
		cin >> x >> y;
		for (j = 1; j <= n; j++) {
			if (a[j] % m[x] == y) break;
		}
		if (j <= n) cout << a[j] << endl;
		else cout << -1 << endl;
	}
	return 0;
}
```

---

## 作者：Wish_kazdel (赞：1)

~~竟然没人写题解？~~


---

## 思路
没什么好说的，先将所有的图书编码排序。
由于题目说的是书编码的后几位相同，因此只需要对比后几位。因此想到用 pow 函数 $\bmod$ 需求码的长度，再通过计算取得最小值，输出。

---

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,len,x;
int a[10005];
bool flag;
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=q;i++){
		cin>>len>>x;
		len=pow(10,len);
		flag=false;
		for(int j=1;j<=n;j++){
			if(a[j]%len==x){
				flag=1;
				cout<<a[j]<<"\n";
				break;
			}
		}
		if(flag==false){
			cout<<-1<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：聪明的猪 (赞：1)

~~蒟蒻题解，dalao轻喷~~

# 整体思路
其实这道题还算比较简单（~~去你的~~），我们将其全部输入之后再一个一个处理，对比编码和需求码后将最小的分别对应地储存，时间复杂度大概为 $ \mathcal{O}\left( n^2 \right) $ 吧~~主要是我太蒻了~~。

# 核心代码详解
气势磅礴的头文件。
```cpp
#include <algorithm> // std::min
#include <array> // std::array
#include <cmath> // std::pow
#include <iostream> // std::cin，std::cout，std::endl
#include <limits> // std::numeric_limits
#include <memory> // std::shared_ptr
```

用来储存需求码的结构体。
```cpp
struct request
{
    bool flag; // 标记是否找到了对应的图书编码
    int len; // 需求码长度
    long code, min; // 需求码和当前对应最小的图书编码
};
```

来一波数组。
```cpp
std::array<long, 1010> bookCode; // 图书编码
std::array<std::shared_ptr<request>, 1010> requestCode; // 需求码
```

以下缩进皆为main函数内。

气势磅礴的初始化。
```cpp
    for (std::array<std::shared_ptr<request>, 1010>::iterator iter = requestCode.begin(); iter != requestCode.end(); iter++) // 使用了迭代器，其实没有什么卵用
    {
        *iter = std::make_shared<request>();
        (*iter)->len = 0;
        (*iter)->code = 0;
        (*iter)->min = (std::numeric_limits<long>::max)() - 1; // 将min设置为long的最大值
        (*iter)->flag = false;
    }
```

气势磅礴的输入。
```cpp
    std::cin >> n >> q;
    for (std::array<long, 1010>::iterator iter = bookCode.begin(); iter != bookCode.begin() + n; iter++) // 然并卵
    {
        std::cin >> *iter;
    }
    for (std::array<std::shared_ptr<request>, 1010>::iterator iter = requestCode.begin(); iter != requestCode.begin() + q; iter++) // 然并卵
    {
        std::cin >> (*iter)->len >> (*iter)->code;
    }
```

真正的核心代码。
```cpp
    for (int i = 0; i < q; i++) // 需求码循环
    {
        for (int j = 0; j < n; j++) // 图书编码循环
        {
            if (bookCode.at(j) % static_cast<long>(std::pow(10, requestCode.at(i)->len)) == requestCode.at(i)->code) // 判断是否是需要的图书
            {
                requestCode.at(i)->min = std::min(bookCode.at(j), requestCode.at(i)->min); // 选最小
                requestCode.at(i)->flag = true; // 设为已有编码了
            }
        }
    }
```

# 整体代码
拒绝抄袭，共创和谐洛谷
```cpp
#include <algorithm>
#include <array>
#include <cmath>
#include <iostream>
#include <limits>
#include <memory>
struct request
{
    bool flag;
    int len;
    long code, min;
};
std::array<long, 1010> bookCode;
std::array<std::shared_ptr<request>, 1010> requestCode;
int main(void)
{
    int n = 0, q = 0;
    bookCode.fill(0);
    for (std::array<std::shared_ptr<request>, 1010>::iterator iter = requestCode.begin(); iter != requestCode.end(); iter++)
    {
        *iter = std::make_shared<request>();
        (*iter)->len = 0;
        (*iter)->code = 0;
        (*iter)->min = (std::numeric_limits<long>::max)() - 1;
        (*iter)->flag = false;
    }
    std::cin >> n >> q;
    for (std::array<long, 1010>::iterator iter = bookCode.begin(); iter != bookCode.begin() + n; iter++)
    {
        std::cin >> *iter;
    }
    for (std::array<std::shared_ptr<request>, 1010>::iterator iter = requestCode.begin(); iter != requestCode.begin() + q; iter++)
    {
        std::cin >> (*iter)->len >> (*iter)->code;
    }
    for (int i = 0; i < q; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (bookCode.at(j) % static_cast<long>(std::pow(10, requestCode.at(i)->len)) == requestCode.at(i)->code)
            {
                requestCode.at(i)->min = std::min(bookCode.at(j), requestCode.at(i)->min);
                requestCode.at(i)->flag = true;
            }
        }
    }
    for (int i = 0; i < q; i++)
    {
        if (!(requestCode.at(i)->flag))
        {
            std::cout << -1 << std::endl;
        }
        else
        {
            std::cout << requestCode.at(i)->min << std::endl;
        }
    }
    return 0;
}
```

~~A了这道题，祝你们成功~~

---

## 作者：yr409892525 (赞：0)

## 题解：P3955 [NOIP2017 普及组] 图书管理员
我们要知道 $x$ 的后 $y$ 位等于 $x \bmod 10^y$，所以我们对于每个需求码，都可以枚举每一个数，找到符合要求的最小值，如果没有，输出 $-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5,inf=1e9;
int n,q;
int a[N]; 
int qpow(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans*=a;
		a*=a;
		b>>=1;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	while(q--){
		int len,x;
		cin>>len>>x;
		int ans=inf;
		for(int i=1;i<=n;i++){
			if(a[i]%qpow(10,len)==x) ans=min(ans,a[i]);
		}
		if(ans<inf) cout<<ans<<"\n";
		else cout<<"-1\n";
	}
	return 0;
} 
```

---

## 作者：Vct14 (赞：0)

小模拟。设图书编码长度为 $l$。由于 $l\le7$，我们直接将每本书的校验码对 $10^l$ 取模判断其是否等于当前读者的需求码即可。时间复杂度 $O(nq)$，可以通过。由于输出最小的校验码，我们可以在最开始时将校验码排序。

```cpp
#include<bits/stdc++.h> 
using namespace std; 

const int N=1002;
int book[N]; 
int l[N]; 
int num[N];  

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
    int n,q;cin>>n>>q; 
    for(int i=1; i<=n; i++) cin>>book[i]; 
    for(int i=1; i<=q; i++){
    	cin>>l[i]>>num[i];
    	l[i]=pow(10,l[i]);
	} 
    sort(book+1,book+1+n); 
    for(int i=1; i<=q; i++){ 
        bool flag=false;
        for(int j=1; j<=n; j++){ 
            if(book[j]%l[i]==num[i]){ 
                flag=true;cout<<book[j]<<"\n"; 
                break; 
            } 
        } 
    	if(!flag) cout<<"-1\n";
	} 
	return 0; 
}
```

---

## 作者：collegiate (赞：0)

这题看着挺简单的，其实也挺简单的。

我们用 $book$ 数组来维护图书编码，用 $len$ 数组来维护需求码的长度，用 $num$ 数组维护需求码。

那么每次枚举书的编码，求 $num_i$ 的后 $x$ 位数，然后比对是否是对应的需求码，如果是的话那么判断一下是否最小，如果是，就更新 $ans$ 变量，最后输出 $ans$ 即可。

那么怎么求 $x$ 呢？可以发现，我们要求后 $x$ 位，那么就是 $num_j(j \le n)$ 对 $10^x$ 取余！

最后还要特判一下，是否输出 $-1$ 即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5000+5;
const int M=1e9+5;
int book[N],len[N],num[N];
int main(){
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>book[i];
	for(int i=1;i<=q;i++){
		cin>>len[i]>>num[i];
		int cnt=pow(10,len[i]);
		int minn=M;
		for(int j=1;j<=n;j++){
			if(book[j]%cnt==num[i] && book[j]<minn){
				minn=book[j];
			}
		} 
		if(minn!=M) cout<<minn<<endl;//特判
		else cout<<-1<<endl;
	} 
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

题解：[P3955 [NOIP2017 普及组] 图书管理员](https://www.luogu.com.cn/problem/P3955)

### 思路
由于普通的思路其它题解已经讲过了，我们为了追求更快的速度，可以使用**快速幂**，**排序**，等算法来解决这个问题。

由于题目要求我们如果有多个答案输出最小的，所以我们的思路就是直接先将整个数组进行排序，这样遍历的时候就方便些，然后我们题目的要求是：如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。那么我们就可以想一想，如何快速判断这个数的末尾是不是询问的数呢？对，就是**模运算**，直接对所有书的编号进行模运算，模上 $10$ 的给出的数的长度次方即可，这里就可以使用我们的快速幂来加速，所以最后的代码就非常简单了。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2e5 + 5;
int n, m, s[N];
int qpow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b & 1) ans *= a;
		a = a * a;
		b >>= 1;
	}
	return ans;
}
int find(int len, int t) {
	sort(s + 1, s + n + 1);
	int ten = qpow(10, len);
	for (int i = 1; i <= n; ++i) {
		if (s[i] % ten == t) {
			return s[i];
		}
	}
	return -1;
}
int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> s[i];
	while (m--) {
		int len, t;
		cin >> len >> t;
		cout << find(len, t) << '\n';
	}
    return 0;
}


```

---

## 作者：ylzpl (赞：0)

一个数取模 $10^x$ 可以得到这个数的后 $x$ 位，所以我们可以用一个数字 $tmp$ 记录 $10^0$ 到 $10^9$，然后将书本编号从小到大排序，因为要找编号小的书。然后每次枚举书的编号，找到合适的编号直接退出即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
long long tmp[15], a[1000005], n, q, x, y;
int main()
{
//先记录，做个预处理
	tmp[0] = 1;
	tmp[1] = 10;
	tmp[2] = 100;
	tmp[3] = 1000;
	tmp[4] = 10000;
	tmp[5] = 100000;
	tmp[6] = 1000000;
	tmp[7] = 10000000;
	tmp[8] = 100000000;
	tmp[9] = 1000000000;
	cin >> n >> q;
	for(int i = 1; i <= n; ++i)
	{
		cin >> a[i];
	}
	sort(a+1, a+n+1);
	while(q--)
	{
		cin >> x >> y;
		int ans = -1;
		for(int i = 1; i <= n; ++i)
		{
			if(a[i] % tmp[x] == y)//取模tmp[x]可以得到编号后x位
			{
				ans = a[i];//记录编号
				break;
			}
		}
		cout << ans << endl;
    }
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法为：贪心，取模运算，模拟。

----
本题解法：
- 首先我们要知道，$x$ 除以 $10^n$ 的余数可以得到的是这个数 $x$ 的后 $n$ 位。
- 根据上面这个特性，我们可以先将书的编号从小到大排序，然后每次算出 $10^x$，再枚举书的编号，如果找到就直接赋值并退出，否则输出 `-1`。
- 再枚举前可以将答案 $ans$ 设为 `-1`，这样有一个好处：如果没有找到答案就可以直接输出 `-1`，不需要特判，比较方便。  
代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
int book[maxn];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,q;
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>book[i];
	sort(book+1,book+1+n);//因为要找编号较小的，所以从小到大排序
	while(q--)
	{
		int x,y;
		cin>>x>>y;
		int tmp=pow(10,x);//取10^x,取模时会用到
		int ans=-1;//先设为-1,方便处理
		for(int i=1;i<=n;i++)
		{
			if(book[i]%tmp==y)//如果取模后是编号y
			{
				ans=book[i];//直接赋值答案并退出。
				break;
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：GoldenSTEVE7 (赞：0)

首先我们将所有图书编码全部排序，然后对于每一次查询，我们从前往后遍历所有图书编码的每一个后缀，找到第一个符合条件的即可。

时间复杂度 $O(nqV)$，其中 $V$ 为图书编码的最大位数，此处为 $V=7$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n[1005], q[1005], qq[1005];

int main()
{
    int n1, q1;
    cin >> n1 >> q1;
    for(int i = 1; i <= n1; i++)
    {
        cin >> n[i];
    }
    for(int i = 1; i <= q1; i++)
    {
        cin >> qq[i];
        cin >> q[i];
        int minn = 10000005;
        for(int j = 1; j <= n1; j++)
        {
            int a = pow(10, qq[i]);
            if(n[j] % a == q[i])  minn = min(minn, n[j]); 
        }
        if(minn == 10000005) cout << -1 << endl;
        else  cout << minn << endl;
    }
    return 0;
}
```

---


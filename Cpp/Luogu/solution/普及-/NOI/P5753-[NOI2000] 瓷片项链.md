# [NOI2000] 瓷片项链

## 题目描述

原始部落用一种稀有的泥土烧制直径相同的圆瓷片并串成项链，串的时候沿瓷片的直径方向顺次连接，瓷片之间没有空隙也不重叠，一条项链至少由一个瓷片构成。

下图示出四片同样大小的瓷片串接所成的项链，其总长为单个瓷片直径的四倍。

![](https://cdn.luogu.com.cn/upload/image_hosting/palmhlro.png)


每个烧制的瓷片厚度是一定的，直径 $D$ 和所用泥土的体积 $V$ 有以下关系：

$$D = \begin{cases}
0.3\sqrt{V-V_0} & V > V_0 \cr
0 & V \le V_0
\end{cases}$$


其中 $V_0$ 为烧制每一片的损耗，单位与 $V$ 相同。当用料小于等于 $V_0$ 时，不能烧制成瓷片。
例： $V_总 = 10，V_0 = 1 $，若烧制成一片瓷片，$ V = V_总= 10，D = 0.9 $。如果把泥土均分成 $2$ 份，每份泥土的体积为 $V = \frac{V_总}{2} = 5 $，单个瓷片的直径为 $ D' = 0.3 \times \sqrt{5-1} =0.6 $ ,串起来的总长为 $1.2$ 。

给定了泥土的总体积和烧制单个瓷片的损耗，烧制的瓷片数不同，能够得到的项链总长度也不相同，请计算烧制多少个瓷片能使所得到的项链最长。


## 样例 #1

### 输入

```
48
7
```

### 输出

```
3
```

## 样例 #2

### 输入

```
8
5
```

### 输出

```
1
```

# 题解

## 作者：Roicer (赞：65)

看到这道题还没有题解，就贡献一下本蒟蒻的第一篇题解吧。
（如果我思路没错的话）这题其实挺简单的···



# 首先

- 很容易想到要使总直径最大，则所有的泥巴都要用上
- 当泥巴总量大于单位用量（V>V0），则一定有解，反之输出0，结束



 


## 接下来针对有解的情况进行讨论（V>V0）

我们不妨设将泥巴分成k份，则**V0=V/k**，项链总长度设为**s**

则有：
	**s=k*D=0.3k√(V/k-V0)**	。	
    

为了方便比较，我们可以取个平方，设y=s²，整理后将等式看作一个关于k的二次函数：**y=-0.09k²V0+0.09kV** 



可知在k=V/(2*V0)时s²取得最大值，即s取得最大值。而且此时我们将此时的k带入求单个陶片用料（V/k）得到单个用料为**2V0，恒大于V0，（即一定有解）**，此时所得项链最长。



那么什么时候会有最优解不唯一的时候呢？——因为k是要为整数的，所以当k的最优取值不为整数时，我们要向最近整数点取整的，这是如果与k相邻的两个整数点离k一样远，那么最优解就有两个了，这时就要输出0了。


------------
感觉有点啰嗦···将就着看吧╮(╯▽╰)╭


如果有什么问题，还请斧正   Thanks♪(･ω･)ﾉ


------------
# 代码


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
double v,c;

int main()
{
	cin>>v>>c;
	
	if(c>=v)
	{
		cout<<0;
		return 0;
	}
	double num=v/c;

	if(int(num)==num&&int(num)%2!=0)//最优解不唯一
	{
		cout<<0;
		return 0;
	}
	if(c==1)//因为所有整数都能被1整除，所以特判一下
	{
		cout<<v/(2*c);
		return 0;
	}
	cout<<int(v/(2*c)+0.5);
	return 0;
}
```


------------
以上。
（点个赞鼓励一下吧）



---

## 作者：lcyxds (赞：8)

假设烧制 $n$ 片瓷片，则 $V=\frac{V_\text{总}}{n}$。

若 $V_\text{总}\le V_0$，则对于任意正整数 $n$，$V\le V_0$，故不能烧制成瓷片，答案为 $0$。

若 $V_\text{总}>V_0$，则若使 $V>V_0$，则将 $V=\frac{V_\text{总}}{n}$ 代入化简得 $nV_0<V_\text{总}$，在这个条件下枚举正整数 $n$ 即可。

对于计算答案，可以直接计算总长，但是由于要判定“最优解不唯一”，而且计算式中有除法有根号，用浮点数容易出精度问题，可以把总长转换为整数进行比较。:

$L=nD=0.3n\sqrt{V-V_0}$

$L^2=n^2D^2=0.3^2n^2(V-V_0)=0.3^2n^2(\frac{V_\text{总}}{n}-V_0)=0.3^2n(V_\text{总}-nV_0)$

故比较 $n(V_\text{总}-nV_0)$ 即可。

时间复杂度：$\Theta(\max(\frac{V_\text{总}}{V_0}),1)$

空间复杂度：$\Theta(1)$

```cpp
#include <iostream>
#include <cstdio>
#define ll long long

using namespace std;

ll v;
ll v0;
ll maxi = 0;
int res;

int main() {
  scanf("%lld%lld", &v, &v0);
  int cur;
  for (int i = 1; v>v0*i; i++) {
    cur = i*(v-v0*i);
    if (maxi<cur) {
      res = i;
      maxi = cur;
      continue;
    }
    if (cur==maxi) res = 0;
  }
  printf("%d", res);
  return 0;
}
```


---

## 作者：就决定是你辣 (赞：4)

### 题目分析

 
 - 很容易发现只要烧制所有瓷片的损耗小于总量，就能烧制成项链。
 
 - 不妨设烧制了 $n$ 片，则总长度为 $n\times 0.3\sqrt{v-v0}$。
 
 - 本题数据范围较小，$n$ 的大小不会超过 $60000$，因此可用枚举法解决。
 
 - 接下来只需要枚举 $n$ 的大小，比较项链总长度选出最大值就可以了。
 
 - 需要注意特判最优解不唯一和 $v<v0$ 的情况，直接输出 $0$ 。
 
###  代码实现
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int main() {
	int vz,v0;//总量与损耗
	int ans;
	double l,maxl=0,li;
	cin>>vz>>v0;
	if(vz<v0){
		cout<<0;
		return 0;//判定总量小于损耗的情况 
	}
	for(int i=1;vz>v0*i;i++){//枚举烧制的陶片个数 
		li=i;
		l=0.3*sqrt(vz/li-v0);//计算n=i时项链的长度 
		 
		if(maxl==l*li) {
			cout<<0;
			return 0;//判定最优解不唯一的情况 
		}
		else if(maxl<l*li){
		maxl=l*li;//更新答案 
		ans=i;
		}
	}
	cout<<ans;
	return 0;//完结撒花 
}
```



---

## 作者：Xqbk (赞：1)

~~首先反思一下为什么会来写红题题解呢~~

### 纯模拟做法

由于 $ V/V_0 $ 最大也不会超过 $60000$ ，可以直接枚举答案然后弄出最大值。

至于多个最大值的情况简单判断一下就好。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
double v,v0,mx;
int ans=0;
int main()
{
	cin>>v>>v0;
	for(int i=1;i*v0<v;i++)
	{
		double di=i;
		double d=0.3*sqrt(v/di-v0);
		if(mx==di*d)
		{
			ans=0;
			break;
		}
		if(mx<di*d)
		{
			mx=di*d;
			ans=i;
		}
	}
	cout<<ans;
	return 0;
}
```



---


# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# 题解

## 作者：智子 (赞：303)

看标签

> 枚举，模拟，暴力。

首先，很容易想到开一个大小 $N * N$ 的二维数组，然而数据范围是 $0 ≤ N ≤10,000$

[提交记录R21442990](https://www.luogu.org/fe/record/21442990)

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int MAXN = 10000 + 5;

int v[MAXN][MAXN]; //爆0的罪魁祸首

int main() {
	memset(v, -1, sizeof(v));
	
	int n;
	
	cin >> n;
	
	for(int i = 1; i <= n; i++) {
		int a, b, g, k;
		
		cin >> a >> b >> g >> k;
		
		for(int x = a; x <= a + g; x++)  {
			for(int y = b; y <= b + k; y++) {
				v[x][y] = i;
			}
		}
	}
	
	int x, y;
	
	cin >> x >> y;
	
	cout << v[x][y] << endl;
	
	return 0;
}
```

~~成功MLE~~


数组大小：$4 * 10000 * 10000 = 400000000 Byte = 400000 KB = 400MB$

跨过了MLE的红线。

另外一种方法是用四个数组来记录矩形的四个参数，再扫一遍数组，通过检查坐标 $(x, y)$ 是否在矩形 $Rect_i$ 内，更新最上面的地毯。

[提交记录](https://www.luogu.org/record/show?rid=17813771)

亲测，完美AC。

至于矩形 $Rect_i$ 的存储方法，可以用 $a, b, g, k$ 四个数组分别存放左上角的坐标和左上角与右下角的距离。

```cpp
#include<stdio.h>

const int MAXN = 10000 + 5;//程序里出现幻数可不是好习惯哦~

int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d%d%d%d", &a[i], &b[i], &g[i], &k[i]);//输入
    }
    scanf("%d%d", &x, &y);
    
    int ans = -1;
    for(int i = 0; i < n; i++) {
        if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {
            ans = i + 1;//ans的最终值恰好是最上面的那张地毯编号
        }
    }
    
    printf("%d\n", ans);//输出结果
    
    return 0;
}
```

---

## 作者：FreedomKing (赞：96)

简单枚举题。

### 思路

$n^2$ 去枚举每个格子明显是行不通的做法，会喜提超空间。

我们先把每个地毯都存起来，直接考虑筛一遍所有毯子，每次判断有没有覆盖这个点，若覆盖就更新答案即可。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int a[N],b[N],g[N],k[N],n,m,t,ans=-1;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i]>>g[i]>>k[i];
	int x,y;
	cin>>x>>y;//点的坐标
	for(int i=1;i<=n;i++){
		if((x>=a[i]&&x<=a[i]+g[i])&&(y>=b[i]&&y<=b[i]+k[i]))//判断是否覆盖点位
			ans=i;//更新答案
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：谁懂谁伤心 (赞：53)

用两个数组存每张地毯的左下角和右上角，再从后向前一张一张推，遇到要求的点在地毯内就输出并退出。（这样比顺着推会快一些）

```cpp

#include <iostream>  
using namespace std;  
int a[10001][2],b[10001][2],x,y,i,n,m;  
int main()  
{  
scanf ("%d",&i);   
for (int j=1;j<=i;j++) {scanf("%d%d%d%d",&a[j][0],&a[j][1],&n,&m); b[j][0]=a[j][0]+n; b[j][1]=a[j][1]+m;}  
scanf ("%d%d",&x,&y);  
for (int j=i;j>=1;j--)  
if (x>=a[j][0]&&x<=b[j][0]&&y>=a[j][1]&&y<=b[j][1]) {printf("%d",j);  return 0;}  
cout <<-1;  return 0;  
}  
```

---

## 作者：Decide (赞：21)

开二维数组可能会爆所以就没有试，直接用了一个结构体数组存储数据，或许洛谷的评测机的内存允许开的数组比较大吧

直接模拟，先读入数据之后再开始模拟，判断点是否在这一长方形上面，如果在的话就更新答案到现在的这一块上面

这样说应该都清楚的吧，反正就是覆盖就更新，否则继续枚举地毯并且判断




```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n,x,y,ans = -1;  //最开始赋值答案为-1那么就可以输出没有地毯的情况了 
struct dt{
    int x,y,d1,d2;
}all[10000+10];
int main()
{
    cin>>n;
    for(int i = 1;i<=n;i++)
        cin>>all[i].x>>all[i].y>>all[i].d1>>all[i].d2;
    cin>>x>>y;
    for(int i = 1;i<=n;i++)
    {
        int tmpx = all[i].x + all[i].d1;
        int tmpy = all[i].y + all[i].d2;
        if(x<=tmpx&&x>=all[i].x&&y<=tmpy&&y>=all[i].y) ans = i;//判断并且更新答案 
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：cff_0102 (赞：11)

坐标范围是 $10^5$，显然不能开 $10^5\times10^5$ 的空间。但是注意到最后只有一个询问，问一个坐标最上面的地毯的编号，而地毯数量 $n$ 的范围是 $10^4$，因此可以先把所有信息读入进来，再直接判断每个地毯是否覆盖了询问的点，是就更新答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct cp{
	int a,b,g,k;
}c[542457];
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>c[i].a>>c[i].b>>c[i].g>>c[i].k;
	}
	int ans=-1;
	int x,y;cin>>x>>y;
	for(int i=1;i<=n;i++){
		if(x>=c[i].a&&x<=c[i].a+c[i].g && y>=c[i].b&&y<=c[i].b+c[i].k){
			ans=i;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：WsW_ (赞：9)

### 思路
后放的地毯在先放的地毯之上，这和栈是一样的，所以可以用栈来模拟。  
按照输入顺序把地毯依次放入栈中，最后取出栈顶，如果栈顶地毯覆盖了 $(x,y)$ 就输出此时栈的中剩余元素数量加一；否则继续取出栈顶。  

如果栈空了还没找到覆盖 $(x,y)$ 的地毯，就输出 `-1`。

时间复杂度为 $O(n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	int sx,sy,ex,ey;
};
stack<node>s;
int mx,my;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	while(n--){
		int x,y,g,k;
		cin>>x>>y>>g>>k;
		s.push({x,y,x+g,y+k});
	}
	cin>>mx>>my;
	while(!s.empty()){
		node t=s.top();
		if(t.sx<=mx&&t.ex>=mx&&t.sy<=my&&t.ey>=my){
			cout<<s.size();
			return 0;
		}
		s.pop();
	}
	cout<<-1;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：5)

本题算法：枚举。  
我们可以枚举这 $n$ 张地毯的坐标，如果它被覆盖了，坐标记录变量 $ans$ 就赋值为 $i+1$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN =10000+5;
int a[MAXN], b[MAXN], g[MAXN], k[MAXN];
int main()
{
    int n,x,y;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i]>>b[i]>>g[i]>>k[i]; 
    cin>>x>>y;  
    int ans=-1;
    for(int i=0;i<n;i++) 
	{
        if(x>=a[i]&&y>=b[i]&&x<=a[i]+g[i]&&y<=b[i]+k[i]) ans=i+1;
    }
    cout<<ans;
	cout<<endl;  
    return 0;
}
```

---

## 作者：Vct14 (赞：5)

由于只有一个询问，所以直接判断每个地毯是否覆盖了给定的点即可。时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

struct dt{
	int a,b,g,k,c,d;
}l[10001];

int main(){
	int n;cin>>n;
	for(int i=1; i<=n; i++){
		cin>>l[i].a>>l[i].b>>l[i].g>>l[i].k;
		l[i].c=l[i].a+l[i].g,l[i].d=l[i].b+l[i].k;
	}
	int x,y;cin>>x>>y;
	for(int i=n; i>=1; i--){
		if(x<=l[i].c && x>=l[i].a && y<=l[i].d && y>=l[i].b){
			cout<<i;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：2)

很简单的一道题。

地毯覆盖的范围是一个矩形，左上角是点 $(a,b)$，右下角是点 $(a+g,b+k)$。若点 $(x,y)$ 在地毯内，则 $a \le x \le a+g$ 且 $b \le y \le b+k$。


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans = -1;
int a[10005], b[10005], c[10005], d[10005];
int x, y;
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i] >> b[i] >> c[i] >> d[i];
  }
  cin >> x >> y;
  for (int i = 1; i <= n; i++) {
    if (x >= a[i] && x <= a[i] + c[i] && y >= b[i] && y <= b[i] + d[i]) ans = i;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1003)

---
### 思路：
思路很简单，就先输入地毯的坐标点，还有所求坐标点的 $x$，$y$。

最后，循环全部的地毯，看看是否有哪一个覆盖到了这个点，就输出它。


---
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 10001;
int n, x, y, m = -1;

struct node {
	int a, b, c, d;
} e[MAXN];

int main () {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> e[i].a >> e[i].b >> e[i].c >> e[i].d;
	cin >> x >> y;
	for (int i = 1; i <= n; i++) {
		if (x >= e[i].a && x <= e[i].a + e[i].c && y >= e[i].b && y <= e[i].b + e[i].d) m = i;
	}
	cout << m << endl;
	return 0;
}
```

---

## 作者：Jayfeather2012 (赞：0)

## 思路
根据题意，因为前面的地毯会被后面的地毯覆盖，所以可以从后往前遍历地毯，找出最后一个（从后往前遍历的第一个）覆盖所求位置的地毯并输出。若未找到，按题目要求输出 $-1$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10003],b[10003],g[10003],k[10003],n,x,y;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>g[i]>>k[i];
	cin>>x>>y;
	for(int i=n;i>=1;i--)
	{
		if(a[i]<=x&&a[i]+g[i]>=x&&b[i]<=y&&b[i]+k[i]>=y)
		//判断所求位置是否被地毯覆盖
		{
			cout<<i;
			return 0;//输出并结束
		}
		 	
	
	}
	cout<<-1;//没有找到输出-1
  	return 0;
}


```

---

## 作者：kuaiCreator (赞：0)

## 解题思路
本题用二维数组模拟的话会超空间，因为给的坐标范围为 $10^5$ 开二维数组使用的内存远大于题目给的内存限制 $125MB$。

考虑直接判断点是否在地毯内即可，求的是最上面的地毯逆序遍历，遇到第一个就退出。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N], b[N], g[N], k[N], n, x, y, ans = -1;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
	cin >> x >> y; 	//点的坐标
	for (int i = n; i >= 1; i--) {
		if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
			ans = i; //记录答案
			break;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Eason_cyx (赞：0)

看到题目首先想到的是开一个 $10^5 \times 10^5$ 的二维数组来当计数器记录每个点有多少块地毯，但是这样显然会炸空间。

然后会发现其实查询只有一组。那么对于这个点 $(x,y)$，我们其实可以直接枚举所有的 $n$ 张地毯，看看 $(x,y)$ 被多少张地毯包括即可。

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005],b[100005],g[100005],k[100005];
int main()
{
    int n;
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
    int x,y;
    cin >> x >> y;
    for(int i = n;i >= 1;i--)
    {
        if(x >= a[i] && x <= a[i]+g[i] && y >= b[i] && y <= b[i]+k[i])
        {
            cout << i << endl;
            return 0;
        }
    }
    cout << -1 << endl;
    return 0;
}
```

---


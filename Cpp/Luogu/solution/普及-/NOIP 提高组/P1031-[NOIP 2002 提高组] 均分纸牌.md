# [NOIP 2002 提高组] 均分纸牌

## 题目描述

有 $N$ 堆纸牌，编号分别为 $1,2,\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。

移动 $3$ 次可达到目的：

- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。
- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。
- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。


## 说明/提示

对于 $100\%$ 的数据，$1  \le  N  \le  100$，$1 \le  A_i  \le 10000$。

**【题目来源】**

NOIP 2002 提高组第一题

## 样例 #1

### 输入

```
4
9 8 17 6
```

### 输出

```
3
```

# 题解

## 作者：松风之狐 (赞：50)

# [均分纸牌](https://www.luogu.org/problemnew/show/P1031)

**所有堆均达到相等时的最少移动次数。**

一看到**最少**这个字眼，就应该想到**贪心**或者**动态规划**。

而我的思路是：

因为题目上说：

>  纸牌总数必为N的倍数
>
> 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

所以我就想：那么我用每堆的纸牌数去减掉平均数，不就是这堆纸牌需要多少张牌才满足题目条件吗？

又因为：

> 移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N*的堆上取的纸牌，只能移到编号为N-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

所以，**如果这堆的纸牌数>0，我们就需要将它的多余纸牌移动到纸牌数<0的纸牌堆上去。**

反之，**如果这堆的纸牌数<0，我们就需要将它的缺少的纸牌从纸牌数>0的纸牌堆上移动到它上去。**

于是，有了思路，代码打起来也就非常简单了。

# 代码实现：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n;//纸牌堆数
int a[10005];//储存纸牌数
int num=0;//纸牌的平均数
int ans=0;//移动次数
int flag=1;//表示纸牌不需要移动
int main()
{
	cin>>n;//输入纸牌堆数
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//输入每堆的纸牌数
		num+=a[i];//纸牌的总数进行累加
	}
	num/=n;//num变为总纸牌数的平均数
	for(int i=1;i<=n;i++) a[i]-=num;//将每堆纸牌数变为距离满足条件的纸牌数的数
	for(int i=1;i<=n;i++) if(a[i]!=0) flag=0;//flag==0，表明需要移动
	if(flag==0)//需要移动，那么就开始吧！
	{
		for(int i=1;i<=n;i++)//从头遍历到尾
		{
			if(a[i]>0)//如果它的纸牌数多了
			{
				a[i+1]+=a[i];//就把它移动到下一堆去
				a[i]=0;//这一堆满足条件
				ans++;//移动次数++
			}
			if(a[i]<0)//如果它的纸牌数少了
			{
				a[i+1]-=abs(a[i]);//那么它下一堆的纸牌就移动到它上来
				a[i]=0;//这一堆满足条件
				ans++;//移动次数++
			}
			if(a[i]==0) continue;//如果它满足条件，就不鸟它了。
		}
		cout<<ans<<endl;//输出答案
	}
	if(flag==1) cout<<ans<<endl;//如果本来就满足条件，直接输出答案（0）
	return 0;
}
```



---

## 作者：monell (赞：50)

# P1031 均分纸牌

下面给出线性算法(O(n))和分治算法(O(n^2))，其中分治算法的正确性显见，而线性算法的正确性可由分治算法得出

## 线性算法

* 关键点：当前堆数量可为负数

* 步骤

  从左到右遍历数组

  1. 若大于目标值，则将多余数量转移给下一元素，移动次数(最终结果)+1
  2. 若小于目标值，则从下一元素支取所差数量(透支不影响结果)，移动次数+1
  3. 若等于目标值，跳过

* 复杂度

  显然O(n)

## 分治算法

* 算法

  对于区间[lo,hi)

  1. 若区间内元素小于2个，返回0
  2. 找到区间内元素最大值
  3. 若最大值为目标值，返回0
  4. 遍历最大值左边元素，找到还差多少，记为left；遍历最大值右边元素，找到还差多少，记为right
  5. 将最大值元素值置为目标值，记当前移动次数total=0
  6. 若left不为0，则最大值元素的左边第一个元素值加上left.，total++；若right不为0，则最大值元素的右边第一个元素值加上right，total++
  7. 分别对最大值元素左边区间和右边区间递归执行该算法，total加上它们返回的值，作为当前区间执行算法的返回值

* 正确性

  该算法实际上就是实际寻找的过程，正确性显然

* 复杂度

  该算法与快排很类似，都为找到轴点(这里是最大值)，进行二分，因此可类似快排构造最坏情况

  因此算法复杂度为O(n^2)

  但平均性能应该也为O(log n)，类似快排，若每次最大值都在中间，则有递归式T(n) = 2T(n/2) + O(n)，因此主定理解得O(log n)

## 线性算法正确性证明

* 算法正确性证明

  考虑分治算法得到的一个最优解，证明线性算法得到的解与其等价(最少移动次数相同)　

  记初始数组为A

  每次移动都可以用一个三元组(u,v,w)来刻画，表示从A[u]取w转移到A[v]，满足|u-v|=1,w>0

  由此由分治算法得到的解应该是一个操作序列，其中集合元素为上述三元组，满足每一次的操作都是合法的(不会出现透支)，集合元素个数最少

  再将这个操作集合用图来建模，图的节点代表堆，(u,v,w)代表从u指向v的一条权重为w的有向边，称上述最优解对应的图为最优图

  下面证明(注意下面所说的最优操作序列都是由分治算法得到)

  1. 最优图不存在重边，即若最优操作序列中存在(u,v,w)，则不存在(u,v,w1)或者(v,u,w2)

     考虑分治算法的操作流程，每次迭代都找到一个最大值，并对最大值两边的区间(都不包含最大值)，进行相同处理，而每次迭代最多进行2次移动操作，即最大值分别向左右两边移动一定数值，而之后的迭代将不再与该最大值相关(因为后面的区间都不包含它)，所以不会出现重边

  2. 最优图的边去掉方向后，每个连通分量对应的子图都为一条欧拉路径

     由(u,v,w)满足|u-v|=1和不存在重边立即得到

     注意该图不一定连通，这对应着分治算法中最大值为目标值的情况，此时将不会存在移动，即该节点不会有边与其相连

  3. 改变最优图边的生成方式，即等价于线性算法

     对最优图进行改变，对于每条边(u,v,w)，若u<v，则不变;若u>v，则去掉该边，加上一条(v,u,-w)，权重为负数

     此时节点序号从小到大遍历，对于节点i和节点i+1，若不存在边(i,i+1,w)，则继续遍历下一节点;若存在，w>0则从当前节点i对应堆移动w到下一节点，w<0则节点i+1对应堆向节点i对应堆移动-w，w=0，则继续遍历下一节点

     经过上述操作，每个节点值都将成为目标值，满足要求，同时由其步骤，显然就是线性算法的运行步骤，而最优图是由分治算法得到的，因此由分治算法正确性即可得到线性算法的正确性

[欢迎关注我的github的算法练习~](https://github.com/monellz/algo)

---

## 作者：__yiLIUyi__ (赞：21)

# 题解：P1031 [NOIP 2002 提高组] 均分纸牌
[题目传送门](https://www.luogu.com.cn/problem/P1031)
## 题意
给出 $n$，然后给出 $n$ 个数。这 $n$ 个数组成了一个序列（我们不妨将它们设为 $a_{1}$ 到 $a_{n}$）。现在可以对这个序列中的每一个数 $a_{i}$ 进行以下三种操作，使得序列中每一个数字都相等：
- 当 $i$ 为 $1$ 时，可以将 $a_{i}$ 中的一部分移动到 $a_{i+1}$，也就是 $a_{2}$；
- 当 $i$ 为 $n$ 时，可以将 $a_{i}$ 中的一部分移动到 $a_{i-1}$；
- 当 $1 < i < n$ 时，可以将 $a_{i}$ 中的一部分移动到 $a_{i+1}$ 或 $a_{i-1}$。

显然，这里的“移动”就是使得 $a_{i}$ 减小一个数，使得 $a_{i+1}$ 或 $a_{i-1}$ 加上同一个数。

反过来，$a_{i}$ 也可以接受其他数的转移。
## 思路
**贪心**。

首先，由于要求每个数字相等，那么所有数字的总和一定可以被 $n$ 整除。整除后的这个数字（也是这个序列的**平均数**），我们暂且把它叫做 $num$。

此时，对于序列中的每一个数 $a_{i}$，只有三种情况：
1. 如果 $a_{i} > num$，则 $a_{i}$ 多出来的部分（$a_{i} - num$）应该被转移到临近的数上；
2. 如果 $a_{i} < num$，则 $a_{i}$ 缺少的部分（$num - a_{i}$）应该由邻近的数转移而来；
3. 如果 $a_{i} = num$，则不需要进行任何操作。

那么，这个“临近的数”，应该是哪一侧的数呢？

让我们回到这个序列上。

对于 $a_{1}$，因为它左侧没有数，所以它进行的一切操作都只能依靠 $a_2$。而当我们对它进行了操作后，$a_{1}$ 显然就和 $num$ 相等了。

这时，对于 $a_{2}$，因为它左侧的 $a_{1}$ 已经与 $num$ 相等了，所以它进行的一切操作都只能依靠 $a_{3}$。而当我们对它进行了操作后，$a_{2}$ 显然就和 $num$ 相等了。

以此类推，我们就解决了刚才的问题：对于 $a_{i}$，因为它左侧的 $a_{i-1}$ 已经与 $num$ 相等了，所以它进行的一切操作都只能依靠 $a_{i+1}$。而当我们对它进行了操作后，$a_{i}$ 显然就和 $num$ 相等了。

所以，对于序列中的每一个数 $a_{i}$，变成了这三种情况：
1. 如果 $a_{i} > num$，则 $a_{i+1} = a_{i+1} + a_{i} - num$，$a_{i} = num$；
2. 如果 $a_{i} < num$，则 $a_{i+1} = a_{i+1} - num + a_{i}$，$a_{i} = num$；
3. 如果 $a_{i} = num$，则不需要进行任何操作。

对于前两种情况，不难发现，其实它们进行的操作是一样的。

```cpp
for(ll i=1;i<n;i++){
	if(a[i]==num) continue;//相等则不进行操作
	a[i+1]+=(a[i]-num);//否则进行移动
	a[i]=num;
	ans++;//答案增加
}
```
## 代码实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,ans,a[110],num;
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
		num+=a[i];//求序列和
	}num/=n;//求平均数
	for(ll i=1;i<n;i++){
		if(a[i]==num) continue;//相等则不进行操作
		a[i+1]+=(a[i]-num);//否则进行移动
		a[i]=num;
		ans++;//答案增加
	}cout<<ans;
	return 0;//好习惯
}//完结撒花QAQ
```

---

## 作者：ProtectEMmm (赞：17)

# [Luogu P1031 均分纸牌](https://www.luogu.com.cn/problem/P1031)

## 题意

给定 $n$ 堆纸牌，第 $i$ 堆纸牌有 $a_i$ 张，保证 $\sum\limits_{i=1}^{n}{a_i}$ 是 $n$ 的倍数。

可以进行一种操作：选取相邻的两堆，从某一堆中拿任意张牌给另一堆，算一次操作。

求最小的操作次数，使得 $n$ 堆牌中牌的数量都一样。

## 题解

大部分题解只讲了如何贪心，并没有讲贪心的正确性证明。导致我在做这题时，包括很多选手做这题时产生了很多疑惑。今日特此补上。

首先先要提出一点，这题不允许牌堆是负数。所以题解里基于贪心的贷款思路从题意上来说，是错误的。但是我们可以证明最后这么做不影响正确性。

首先很容易看出来，最后要求所有牌堆的牌数都等于平均数。

**引理：** 任意两堆相邻的牌堆，最优策略只能从一堆往另一堆一次性给出若干张牌。不存在 $A$ 给了 $B$，之后 $B$ 又给了 $A$。

>我们可以用分治的思想证明这个引理。
>
>首先任取两堆相邻的牌，不妨设左边所有牌堆的总和为 $A$，右边所有牌堆的总和为 $B$。
>
>因为我们要求每堆牌最后都相等，所以可以让两边都减去每堆牌至少需要的牌数。
>
>现在有三种情况。
>
>1. $A=B=0$：说明两堆之间不需要进行牌的交换。
>2. $A>0>B$：说明 A 有余，B 不足。
>3. $A<0<B$：说明 A 不足，B 有余。
>
>不妨设 A 有余，B 不足。反之同理。
>
>那么肯定是 A 一次性把这么多牌给 B。
>
>这里 `小粉兔` 提出了一个疑问：凭什么一定是 A 一次性把这么多牌给 B。（玄学一点：天之道，损有余而补不足）
>
>这里我并不能证明一定是 A 一次性给 B。`小粉兔` 紧跟着提问：为什么不能 B 给 A，然后再给 B。（先富带动后富）
>
>这个提问给了我一点提示，（有一个比较玄学的回答是奥卡姆剃刀原理，这么多步骤肯定不合理），这里证明方法是，因为我们存在操作步骤次数为 $1$ 的方案，所以其余方案都不优。从最优方案的存在性上下手。
>
>现在我们证明了 A 和 B 之间一定是有余给不足，至于左侧牌堆内部，和右侧牌堆内部怎么处理，继续递归下去（或者用数学归纳法证明）。

如果我们考虑，有余往不足的牌堆连边。我们会发现问题变成了一张 $n$ 点，至多 $n-1$ 条边的有向图。（为什么是至多，因为有可能两边互相都不需要给牌）

如果这张有向图是一张 DAG，即这张有向图无环。我们就可以按照拓扑序来进行给牌操作。这样就不会出现中间是负数的情况了。

现在如何证明这张有向图无环呢？一个非常不严谨的证明是， $n$ 点，至多 $n-1$ 条边的有向图是一棵树，不可能有环。

问题是，如果有一些点本身就等于平均值，不需要连边。那就释放出来了本该连给他，现在多余的边，这些多余的边到其他地方会不会形成环呢？

如果我们释放了一些点，那么这些点就可以从 $n$ 个点里忽略掉。所以最后还是 $n'$ 点，$n'-1$ 边。

另一个解释是，这张图只能是一条链，因为不存在双向边所以绝不可能有环。

事实上，这张图最后形态是有若干条链。答案就是点数减去链数，因为不同链之间不需要进行交换，所以减掉。因为链是树的一种，可以看成是一个森林。那点数减链数其实就是边数。边数本质就是操作的次数。

我们发现我们最后只关心边的数量，不关心边的方向了。所以这题用贪心的思路做后，可以存在负数，可以贷款，这不影响这题的正确性。

> 这题如果没考虑这么多，只考虑贪心做的话。
>
> 第一堆牌和第二堆牌就三种可能：
>
> 1. 第一堆牌刚好：不需要处理。
> 2. 第一堆牌有余：只能给第二堆牌。
> 3. 第一堆牌不足：只能第二堆牌给。
>
> 于是我们就处理完了第一堆牌。也就是第一块多米诺骨牌已经推倒了。
>
> 对于第二堆牌来说，第一堆牌已经处理完了，不需要再考虑了，于是第二堆牌不能向左再操作了，只能向右。第二堆牌变成了第一堆牌。
>
> 于是就像多米诺骨牌一样，全部倒下去（也就是数学归纳法）。

补充：这题有一个环形版本， [`负载平衡问题`](https://www.luogu.com.cn/problem/P4016)，是 `网络流24题` 中的一道费用流题目。但是也可以像这题一样做。我们只需要证明这题一定能找到一个断点使他变成 [`均分纸牌`](https://www.luogu.com.cn/problem/P1031) 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*====================*/
#define endl "\n"
/*====================*/
typedef long long lnt;
/*====================*/
const int N = 1e2 + 10;
/*====================*/
int n, arr[N];
/*====================*/
void Solve(void)
{
	cin >> n;
	int average = 0;
	for (int i = 1; i <= n; ++i)
	{
		cin >> arr[i];
		average += arr[i];
	}
	average /= n;
	/*====================*/
	int ans = 0;
	for (int i = 1; i + 1 <= n; ++i)
	{
		if (arr[i] != average)
		{
			ans++, arr[i + 1] += arr[i] - average;
		}
	}
	cout << ans << endl;
	/*====================*/
	//第二份代码的思路就是，统计分治证明里提到的 A == B的断边。
	int ans = n, sum = 0;
	for (int i = 1; i <= n; ++i)
	{
		sum += arr[i] - average;
		if (sum == 0)ans--;
	}
	cout << ans << endl;
}
/*====================*/
int main()
{
#ifndef ONLINE_JUDGE
	freopen("IN.txt", "r+", stdin);
#endif
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	int T = 1; //cin >> T;
	while (T--)Solve();
	return 0;
}
```

## 致谢

感谢 `Cherishdevil` 在菜群提出了这个问题，使得我能够再次注意到这道题。

感谢 `SkyWave` 提出我可以针对这道题重新写一篇题解试试能不能让管理挂上。

感谢 `小粉兔` 在群内和我讨论，把我思路中的错误给指出，并不断给出新提示。

---

## 作者：suzhikz (赞：7)

首先，操作的次序显然对答案没有影响，我们不妨从最左边开始操作。

首先计算出平均大小，然后从左往右看这个堆多了还是少了几张排，如果不是恰好的，就把多的给右边，少的从右边拿。

你可能有点疑惑，这样不是会取出负值吗？

其实，操作的次序是可以调换的，我们假设对于每个位置记好了他的操作。

如果说最大的位置要给出的纸牌比这个位置现有的多，那么一定是他的左边多了纸牌，递归左半部分。

如果少的话，那我们就先操作这个位置，再分别递归左半部分和右半部分。

这一定是成立的，不可能每个位置的值都小于操作的值。

---

## 作者：ryf2011 (赞：5)

# 题目思路
注：本题目思路中所有没有提及定义但出现的变量均为题目中定义的变量。

首先我们要思考，每堆牌都为多少的时候，移动的次数最少？

题目告诉我们，所有牌的数量和是 $N$ 的倍数，也就是说，我们可以把所有牌的数量的平均值计算出来作为目标。

我们从 $1$ 到 $N - 1$ 顺序枚举 $i$，如果 $a[i]$ 与平均值相等，那么这堆牌已经达成目标，跳过即可。

否则，$a[i]$ 只有大于平均值和小于平均值两种情况。

如果 $a[i]$ 大于平均值，那么就让 $a[i]$ 给 $a[i + 1]$ 一些牌，使得 $a[i]$ 等于平均值。

如果 $a[i]$ 小于平均值，那么就让 $a[i + 1]$ 给 $a[i]$ 一些牌，使得 $a[i]$ 等于平均值。 

上述两种情况判断完成后，让计数变量加 $1$ 即可。

这样，循环结束后，我们自然能够统计出答案。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int n,a[10005],sum,bestnum,ans;
//sum：所有 a[i] 的和；bestnum：所有 a[i] 的平均值；ans：最终答案
signed main(){
    //输入
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        sum+=a[i]; //计算总和
    }
    bestnum=sum/n; //计算平均值
    for(int i=1;i<=n-1;i++){
        if(a[i]==bestnum){ //如果 a[i] 等于平均值，说明不用再变化，跳过
            continue;
        }
        else{ //否则，需要重新分配
            if(a[i]>bestnum){ //如果 a[i] 大于平均值，就“借”给 a[i+1] 一些牌，使得 a[i] 等于平均值
                a[i+1]+=(a[i]-bestnum);
                a[i]=bestnum;
            }
            else{ //否则，说明 a[i] 小于平均值，就让 a[i+1] “借” 给 a[i] 一些牌，使得 a[i] 等于平均值
                a[i+1]-=(bestnum-a[i]);
                a[i]=bestnum;
            }
            ans++; //答案 +1
        }
    }
    printf("%lld\n",ans); //输出
    return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：Starlight237 (赞：5)

原题如下：
有 $N$ 堆纸牌，编号分别为 $1,2,…,N$ 。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 NN 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ ， $4$ 堆纸牌数分别为：

①$9$ ②$8$ ③$17$ ④$6$

移动 3 次可达到目的：

从 ③ 取 $4$ 张牌放到 ④ （$9,8,13,10$）-> 从 ③ 取 $3$ 张牌放到 ②（$9,11,10,10$）-> 从 ② 取 $1$ 张牌放到①（ $10,10,10,10$）。

此题的思路还是很好想的：想要使没堆牌的牌数都等于平均值，必须要依次遍历牌堆，查找不等于平均值的牌堆，并且修改。我们从0号开始，一堆堆往后遍历，如果发现纸牌数不等于平均值，就从后面一堆“借来”或“借出”一些纸牌，并且继续查找，遇到符合条件的牌堆就跳过，直到最后一堆牌。

考虑到不管当前牌是否大于或小于平均值，下一张牌都会增加当前牌数-平均数（如果小于平均值，则该值为负数，相当于从下一堆借来纸牌），所以不需要多余的条件判断。由于当前牌堆的修改与上一堆无关，所以可以除去将当前牌数修改为平均数这个不必要的操作，以加快运行速度。

代码奉上：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110],n,s,avg,m;
inline void work(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=0;i<n;++i)cin>>a[i],s+=a[i];
	avg=s/n;
	for(int i=0;i<n-1;++i)
		if(a[i]!=avg)a[i+1]+=a[i]-avg,++m;
	cout<<m;
}
int main(){
	work();
	return 0;
}

```

---

## 作者：M1__ (赞：3)

# 题解：P1031 [NOIP 2002 提高组] 均分纸牌
[题目传送门](https://www.luogu.com.cn/problem/P1031)
## 题目思路
因为规定了 $\sum_{i=1}^{N} a_i$ 是 $N$ 的倍数，所以能求出平均值 $M=\frac{\sum_{i=1}^{N} a_i}{N}$。                   

显然在理想状态下（指数组中的每一项都相同），当前 $i$ 个项的和为 $\sum_{j=1}^{i} a_j$，则 $\sum_{j=1}^{i} a_j=M \cdot j$。

也就是说，如果 $\sum_{j=1}^{i} a_j \neq M \cdot j$，就需要操作至少一次。        

因此我们可以用前缀和计算出前 $i$ 项的和判断是否满足其等于平均数乘当前下标值积即可。                   

时间复杂度 $O(n)$。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e3+10;
ll n,a[N],sum,pj,sum1,cnt;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i],sum+=a[i];
	}
	pj=sum/n;
	for(int i=1;i<=n;i++){
		sum1+=a[i];
		if(sum1!=i*pj) cnt++;
	}	
	cout<<cnt;
	return 0;
}
```

---

## 作者：yedalong (赞：3)

## Solution
首先我们可以先求出每一个牌堆最终会有多少张牌，即为 $\frac{\sum_{i=1}^{N}{A_i}}{N}$。接着我们可以将 $A_i$ 转变为与结果的差。然后遍历一遍每个牌堆，对于牌堆 $i$，前面的 $i-1$ 个牌堆已经好了，那如果 $A_i\neq0$，就得将这 $A_i$ 张牌移到第 $i+1$ 个牌堆上面，即为 $A_{i+1}=A_{i+1}+A_i$，对于每一次操作统计答案即可。
## AC code

```cpp
#include <bits/stdc++.h>  
using namespace std;  
int main(){ 
	int n;cin>>n;int ans=0;int arr[n];int summ=0;
	for(int i = 0;i<n;i++){
		cin>>arr[i];
		summ+=arr[i];
	}
	summ/=n;
	for(int i = 0;i<n;i++) arr[i]-=summ;
	for(int i = 0;i<n;i++){
		if(arr[i]==0) continue;
		arr[i+1]+=arr[i];
		ans++;
	}
	cout<<ans;
}  
```

---

## 作者：LeavingAC (赞：2)

**begin**

[P1031 [NOIP 2002 提高组] 均分纸牌](https://www.luogu.com.cn/problem/P1031)

# 思路

题目中告诉我们，牌的总数必定为 $n$ 的倍数，所以最终的结果必定每堆牌的数量都等于这堆牌的平均数。

并且题目中的分牌规则为：只能从相邻两堆挪动纸牌。

那么我们就可以想到：

我们先算出平均数，然后把每堆纸牌总数减去平均数，得到多余（正数）或者缺少（负数）的纸牌个数。

如果多了，就送给下一堆。

如果少了，就找下一堆要。

然后我们就得到了以下代码。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll n,a[110],sum,ans,avg;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for (ll i=1;i<=n;i++)
    {
        cin>>a[i];
        sum+=a[i];
    }
    avg=sum/n;
    for (ll i=1;i<=n;i++) a[i]-=avg;
    for (ll i=1;i<=n;i++)
    {
        /*if (a[i]==0) continue;
        if (a[i]>0)
        {
            a[i+1]+=a[i];
            ans++;
        }
        else
        {
            a[i+1]-=abs(a[i]);
            ans++;
        }我们经过简化可以就得到以下代码⬇️*/
        if (a[i]!=0)
        {
            a[i+1]+=a[i];
            ans++;
        }
    }
    cout<<ans;
    return 0;
}
```

**end**

---

## 作者：sea_bird (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1031)。

# 题目分析

## 思路

一道经典的贪心题目，我来写个正解。

这道题的贪心思路是，**每组牌与目标牌数的差距均有下一组牌承担**（最后一张除外），可以先顺着这个思路想想，为什么这么干。

由于最终每组要**保证一样**的牌数（怎么这么像积木大赛），那么可以先求出每组目标值 `sum/=n;`（$sum$ 为牌的总数），那么无论高于还是低于这个值的组都需要处理，题目的要求保证了题目有解，同时由于求的是**最少操作**次数，那么每次给牌都需要就近来给，**最好就是相邻的那组**牌！

而这便是该题的贪心思路，每组牌与目标的差距均有下一组牌来承担，但是第 $n$ 组牌似乎并没有下一组牌来承担呀？关于这个问题，设每组牌为 $a_1 a_2 ……a_n$，那么 $a_n=sum-a_1-a_2-……-a_{n-1}$，由于每组牌与目标的差距由目标牌承担，那么既然处理到了第 $n$ 组牌，也就是说明前面 $n-1$ 组牌都是符合的，那么 $res = sum- \frac{sum}{n \times (n - 1)}$（$res$ 是剩余牌数），可以发现 $res = \frac{sum}{n}$，那么第 $n$ 组牌也是符合条件的。

欢乐的看代码时间！

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int a[N];
int main(){
	int n,x,cnt=0,sum=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];//求出牌数总和
	}
	sum/=n;//每组牌最终有几张
	for(int i=1;i<=n;i++){
		if(a[i]!=sum&&i!=n){
			x=sum-a[i];//与目标牌数的差距
			if(x>=0){//缺少牌时
				a[i+1]-=x;//下一组牌补上
				a[i]+=x;
			}
			else{//有多余的牌时
				a[i+1]+=abs(x);//下一组牌接上
//abs();求绝对值
				a[i]+=x;
			}
			cnt++;
		}
	}
	cout<<cnt<<endl;
	return 0;
}
```

---

## 作者：yuxinrui0618 (赞：1)

# 题解：P1031 [NOIP 2002 提高组] 均分纸牌
## 1. 题目大意
- 有 $N$ 个数，要进行移动，使得这 $N$ 个数相等；
- 其中，在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

## 2. 思路
- 我们只需要抓住一点：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；而移来移去，牌的总张数不变；
- 这样，只要求出 $N$ 堆的平均值，也就是最后要统一成的数；
- 那从 $N$ 开始，使该堆牌数等于平均值，多（或少）的移给前一堆即可。

## 3. 代码

```
#include<bits/stdc++.h>
using namespace std;
int s[200];
int summ=0;
int main() {
    int n,avg,l,key,cnt=0;
    int a[200];
    cin>>n;
    for (int i=0;i<n;i++)
	{
        cin>>a[i];
        summ+=a[i];
        s[i]=summ;
    }
    key=n-1; //当前堆
    avg=summ/n; //平均值
    l=key-1; //前一堆
    while(l!=-1) 
	{
        if(a[key]==avg) //已经满足要求
		{
            key--;
            l--;
            continue;
        }
        int leftNeed=(l+1)*avg-s[l]; //前一堆需要的
        a[key]-=leftNeed;
        a[l]+=leftNeed; //移给前一堆
        key=l;
        l--; //向前移
        cnt++; //移动次数
    }
    cout<<cnt<<endl;
    return 0;
}
```

## 4. 总结
谢谢观赏！  
如有问题还请各位大佬指出！

---

## 作者：GZXUEXUE (赞：1)

### 思路

观察到题目中要求「用最少的移动次数使每堆上纸牌数都一样多」，考虑使用贪心。

由于纸牌总数必为 $N$ 的倍数，要把纸牌平均分为 $N$ 份，故应令所有纸牌堆最终的纸牌数为最初每堆纸牌的平均纸牌数。可以先令所有纸牌堆纸牌数减去这个平均数，然后遍历一次纸牌堆：

- 如果其等于 $0$，则不动。
- 如果其不等于 $0$，则令其多余/缺少的纸牌转移到下一个纸牌堆（给牌/拿牌），同时操作步数加上 $1$。

最后统计操作步数即可。

时间复杂度为 $O(N)$。

### 实现

```cpp
# include <iostream>
# include <cstring>
# include <cmath>
using namespace std;
int main(){
    int n,cnt = 0; cin >> n;
    int a[n],sum = 0; // sum统计总纸牌数，后面除以n之后即可得到平均数
    for (int i = 0;i < n;i++){
        cin >> a[i];
        sum += a[i];
    }sum /= n;
    for (int i = 0;i < n;i++) a[i] -= sum;
    for (int i = 0;i < n - 1;i++){
        if (a[i] == 0) continue; // 若等于0则无需转移，操作次数不变
        a[i+1] += a[i]; a[i] = sum; cnt++;
    }cout << cnt;
    return 0;
}
```

---

## 作者：xingsunderen (赞：1)

~~为什么感觉这题数据有点水？~~
## 题意
所有点都只能移动到相邻位置，且编号为 1 的那堆只能往右移，最后一堆只能往左移，换句话来说就是不能开创新堆。
## 思路
首先我们设 $sum$ 为平均值（不要在意那是个累加和的名字）

由于题目说编号为 1 的那堆只能往右移，那么第 2 堆就会增加 $a_{i}-sum$ 张牌。那么后面的几堆只能往右移，因为前面已经移好了。
## 代码
思路不难，代码实现也很简单。

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
using namespace std;
int n,a[105],sum,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
	}
	sum/=n;
	for(int i=1;i<=n;i++){
		if(a[i]-sum!=0){
			a[i+1]+=a[i]-sum;
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```
**不要作代码的搬运工。**

---

## 作者：Hua_Tian (赞：1)

### 思路
一道签到题，主算法是贪心，相信我。

![](https://cdn.luogu.com.cn/upload/image_hosting/4vr6onyw.png)

初看这道题，以为是动态背包，结果仔细一看，连初学者都会。因为题目已经规定好了，只能将编号为 $i$ 的牌堆上的牌移到 $i-1$ 或 $i+1$ 的牌堆上，所以就减少了不确定性，刚好符合贪心只顾当前的特性。至于编号为 $1$ 和 $N$ 的牌堆，也不用特地去管它，编号为 $1$ 在一开始就被计算进去了；而编号为 $N$ 的纸牌到最后一定等于平均数，因为前面都已经相等了，根据纸牌总数必为 $N$ 的倍数这一条件，它是不用操作的。

### 算法
我们可以一个个遍历过去，如果此牌堆的牌数大于平均数，就移到下一牌堆；如果此牌堆的牌数小于平均数，就从下一牌堆补上。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,ans;
int a[101];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s+=a[i];
	}s/=n;//求平均数 
	for(int i=1;i<=n;i++){
		if(a[i]<s){//如果小于平均数，就从下一堆拿 
			a[i+1]-=(s-a[i]);
			ans++;
		}else if(a[i]>s){//如果大于平均数，就拿给下一堆 
			a[i+1]+=(a[i]-s);
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---


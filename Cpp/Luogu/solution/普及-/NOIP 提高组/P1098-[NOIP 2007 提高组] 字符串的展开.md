# [NOIP 2007 提高组] 字符串的展开

## 题目描述

在初赛普及组的“阅读程序写结果”的问题中，我们曾给出一个字符串展开的例子：如果在输入的字符串中，含有类似于 `d-h` 或者 `4-8` 的字串，我们就把它当作一种简写，输出时，用连续递增的字母或数字串替代其中的减号，即，将上面两个子串分别输出为 `defgh` 和 `45678`。在本题中，我们通过增加一些参数的设置，使字符串的展开更为灵活。具体约定如下：

(1) 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号 `-` ，减号两侧同为小写字母或同为数字，且按照 `ASCII` 码的顺序，减号右边的字符严格大于左边的字符。

(2) 参数 $p_1$：展开方式。$p_1=1$ 时，对于字母子串，填充小写字母；$p_1=2$ 时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。$p_1=3$ 时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号 `*` 来填充。

(3) 参数 $p_2$：填充字符的重复个数。$p_2=k$ 表示同一个字符要连续填充 $k$ 个。例如，当 $p_2=3$ 时，子串`d-h` 应扩展为 `deeefffgggh`。减号两边的字符不变。

(4) 参数 $p_3$：是否改为逆序：$p_3=1$ 表示维持原来顺序，$p_3=2$ 表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当 $p_1=1$、$p_2=2$、$p_3=2$ 时，子串 `d-h` 应扩展为 `dggffeeh`。

(5) 如果减号右边的字符恰好是左边字符的后继，只删除中间的减号，例如：`d-e` 应输出为 `de`，`3-4` 应输出为 `34`。如果减号右边的字符按照 `ASCII` 码的顺序小于或等于左边字符，输出时，要保留中间的减号，例如：`d-d` 应输出为 `d-d`，`3-1` 应输出为 `3-1`。


## 说明/提示

$40\%$ 的数据满足：字符串长度不超过 $5$。

$100\%$ 的数据满足：$1  \le  p_1  \le  3,1  \le  p_2  \le  8,1  \le  p_3  \le  2$。字符串长度不超过 $100$。

NOIP 2007 提高第二题


## 样例 #1

### 输入

```
1 2 1
abcs-w1234-9s-4zz```

### 输出

```
abcsttuuvvw1234556677889s-4zz```

## 样例 #2

### 输入

```
2 3 2
a-d-d```

### 输出

```
aCCCBBBd-d```

# 题解

## 作者：Narcisuss (赞：579)

蒟蒻第一次写题解，望通过。

此题看起来很复杂，实践起来其实不是特别难，仔细审题不难发现：影响输出的是p1和p3,p2其实~~无关紧要~~，只要在循环输出的时候作为边界即可。

所以我们可以通过三目运算符来~~少写几个for循环~~让代码变得简洁。
## AC代码：

```
#include<bits/stdc++.h>
using namespace std;
int p1,p2,p3,i=0,k;
char ch[300],be,af,f,j,p;//p用于输出; 
int main() {
	scanf("%d%d%d%s",&p1,&p2,&p3,ch);//输入;
	while(ch[i]){//当ch[i]有值时;
		be=ch[i-1];af=ch[i+1];f=ch[i];//f存储ch[i],便于判断; 
		if(f=='-'&&af>be&&(be>='0'&&af<='9'||be>='a'&&af<='z')){//意思是ch[i]若为'-',就判断其前后是否满足条件，满足进入循环; 
			for(p3==1?j=be+1:j=af-1; p3==1?j<af:j>be; p3==1?j++:j--){
				p=j;//j是整形变量，p是字符型变量，这样是将p赋值为ASCII码为j的字符; 
				if(p1==2)//是否大写; 
					p=(p>='a')?p-32:p;//如果是字母就转成大写 
				else if(p1==3) p='*';//是否输出'*' 
				for(k=0; k<p2; k++)//输出p2个 
					printf("%c",p);
			}
		} 
		else
			printf("%c",f);//如果ch[i]是非'-'或者其前后不满足条件，就原样输出;
		i++;//一定要放在后面，不然会出错QAQ;
	}
	return 0;
}
```

---

## 作者：Avenoir (赞：237)

$$\color{navy}\text{这题是一道比较水的模拟题}$$
$$\color{blue}\text{大家的思路都差不多}$$
$$\color{red}\text{不如让我简要介绍一下}$$
$$\color{green}\text{<cctype>、<string>头文件下的一些函数}$$


------------
 
  
$$\color{green}\text{1、<cctype>}$$
  

------------

```cpp
#include<cctype>
```
加入这个头文件就可以调用以下函数：
  
 > 1、`isalpha(x)` 判断x是否为字母
  
 > 2、`isdigit(x)` 判断x是否为数字
  
 > 3、`islower(x)` 判断x是否为小写字母
  
 > 4、`isupper(x)` 判断x是否为大写字母
  
 > 5、`isalnum(x)` 判断x是否为字母或数字
  
 > 6、`ispunct(x)` 判断x是否为标点符号
  
 > 7、`isspace(x)` 判断x是否为空格
  
 对于以上函数，如果x符合条件的话，均会返回`true`，否则返回`false`
  
 还有以下函数：
  
 > 1、`toupper(x)` 如果x是小写字母，将其转换成大写字母
  
 > 2、`tolower(x)` 如果x是大写字母，将其转换成小写字母
  
  
------------
 
  
$$\color{green}\text{2、<string>}$$
  

------------
```cpp
#include<string>
```
  
在本题目中用到的有以下几个函数，也是此头文件下比较常用的函数，更多的可以百度以下
  
 > 1、`s.erase(x,y)` 表示将字符串s从x位置起删除y个字符
  
 > 2、`s.insert(x,y)` 表示将字符串y（或字符y）插入到s的x位置处
  
 > 3、`s.push_back(x)` 表示在s的末尾插入字符x
  
 > 4、`reverse(s.begin(),s.end())` 将字符串s翻转


------------
### 这些函数都是十分重要的函数，初学者应牢记，必要时可以省去大量手写的时间（其实是我懒得手写

下面上代码和分析：
  
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<cctype>
using namespace std;
int main(){
	ios::sync_with_stdio(false);
	int p1,p2,p3;
	string s;
	cin>>p1>>p2>>p3>>s;
	for(register int i=1;i<s.length()-1;i++){
		//从字符串的第二位开始循环查找到倒数第二位
                //因为“-”号如果出现在首位或者末尾都肯定是不用管的                                              
		if(s[i]=='-'&&((islower(s[i-1])&&islower(s[i+1])&&s[i-1]<s[i+1])||(isdigit(s[i-1])&&isdigit(s[i+1])&&s[i-1]<s[i+1]))){
			//判断题目中的“约定1”成立                                  
			                                       
			//这里根据p1值的不同只需要对程序做简要的修改
			if(p1==1){
				s.erase(i,1);//删去“-”号所在的那一位
				string spare="";//建立一个空的备用字符串
				for(register int k=s[i-1]+1;k<=s[i]-1;k++){//循环
					char ch=k;
					for(register int j=1;j<=p2;j++) spare.push_back(ch);//在spare的末尾不断插入p2个字母
				}
				if(p3==2) reverse(spare.begin(),spare.end());
                                //如果p3=2就把spare翻转
				s.insert(i,spare);
                                //在s中删去“-”的位置插入spare
			}
			else if(p1==2){
				s.erase(i,1);
				string spare="";
				for(register int k=s[i-1]+1;k<=s[i]-1;k++){
					char ch=k;
					ch=toupper(ch);//将原小写字母转成大写
					for(register int j=1;j<=p2;j++) spare.push_back(ch);
				}
				if(p3==2) reverse(spare.begin(),spare.end());
				s.insert(i,spare);
			}
			else if(p1==3){
				s.erase(i,1);
				string spare="";
				for(register int k=s[i-1]+1;k<=s[i]-1;k++)
					for(register int j=1;j<=p2;j++) spare.push_back('*');//与字母个数相同的星号
				if(p3==2) reverse(spare.begin(),spare.end());
				s.insert(i,spare);
			}
		}
	}
	cout<<s<<endl;
	return 0;
}
```


---

## 作者：Eason_AC (赞：21)

## Update
- $\texttt{2020.9.13}$ 重新排版了一下此题解，并修改了一些措辞，删除了一些已经废掉了的东西和废话。

## Content
给定一个字符串 $s$，和三个参数 $p_1,p_2,p_3$，求按照题目中的规则扩展之后的字符串。

规则实在无法简要概括，请前往原题题面查看。

**数据范围：$1\leqslant p_1\leqslant 3,1\leqslant p_2\leqslant 8,1\leqslant p_3\leqslant 2$，字符串长度不超过 $100$。**

## Solution
这题其实就是一道纯粹的模拟，而且什么优化都不要就可以 AC。

### Part 1 特判
首先，输入完之后，将字符串的长度用一变量储存。接着，先用一个 for 循环来遍历字符串内每一个字符。这就要提到我们程序里第一个，也是最长的一个特判。其中：

- $i$ 表示字符在字符串中的位置。
- $a$ 是输入的字符数组。

```cpp
if(a[i] == '-' && a[i - 1] < a[i + 1] && ((a[i - 1] >= 'a' && a[i + 1] <= 'z') || (a[i - 1] >= '0' && a[i + 1] <= '9')))
```

是不是看着有点头晕？别着急，咱们一步一个踏实的脚印，仔细分析一下这一段代码。

这段代码其实就是在判断这个字符是否满足展开的条件。你可能有问题了，不需要特判 $i$ 是不是第一个或最后一个么？其实，字符数组有一个特性，就是在超过字符数组开的范围的时候默认为空（亲测证实当字符数组的位置为负数时也是默认为空）。那么首先要特判的，是这个字符得要是`-`才有可能展开，接下来是判断`-`前面的字符是不是严格小于后面的字符。后面的四个条件，就是说两个字符是否都是小写字母或数字（注意！因为两个字符都是同一类型且前面的字符严格小于后面的字符，所以，**判断完后面的字符小于`z`或`9`，前面的字符就一定小于`z`或`9`**。同理，**判断完前面的字符大于`a`或`0`，后面的字符就一定大于`a`或`0`。**）。

总结一下，上面的特判就是在做以下的内容：

1. 是否是`-`这个字符
2. 是否满足前面的字符严格小于后面的字符
3. 两个字符是否是同一个类型

第二个特判是在输出的时候（以 $p_1=2,p_3=1$ 时为例）：

```cpp
for(char j = a[i - 1] + 1; j <= a[i + 1] - 1; ++j)
							for(int k = 1; k <= p2; ++k) {
//								puts((j >= 'a') && (j <= 'z') && (j > '9') ? "YES" : "NO");
								printf("%c", (j >= 'a' && j <= 'z' && j > '9') ? j - 32 : j);
							}
```

以下是对这段代码的解释：
1. 因为当 $p_1=1$ 时，输出小写字母，所以不需要特判左右是不是大写字母。
2. 注释的内容是我在中间调试时加上去的。可以把它忽略。

当 $p_2=2$ 时，如果前后是小写字母，就要将输出的字符改为大写字符，才能输出正确。

### Part 2 过程
首先，如果 $p_1=1$，那么得先判断是倒序输出还是顺序输出。判断完以后，注意！输出展开的部分里没有两端字母，所以，执行语句时，开始结束的两端应该是**`-`前的字母在字母表中后一个字母**（例如，`a`的后一个字母应该是`b`）和**`-`后的字母在字母表中前一个字母**（例如，`z`的前一个字母应该是`y`）。这可以用一个 for 循环实现：

```
for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
```

然后，再将其输出 $p_2$ 次，这也可以用一个 for 循环来实现：

```cpp
for(int k = 1; k <= p2; ++k)
```

$p_1=2$ 的时候也是同样的道理，只需注意一下特判就行了。

$p_1=3$ 的时候，将上面的j循环和k循环复制下来，然后输出的内容改为`*`就行了。

以上是所有分析的内容，若仍有不懂的地方，可以看以下的代码来加深理解。

## Code
### 1 Final Version$\small\texttt{ 27ms~/~696.00KB}$
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;

int p1, p2, p3;
string a;
int main() {
//	freopen("expand.in", "r", stdin);
//	freopen("expand.out", "w", stdout);
		scanf("%d%d%d", &p1, &p2, &p3);
		cin >> a;
		int len = a.size();
		for(int i = 0; i < len; ++i) {
			if(a[i] == '-' && a[i - 1] < a[i + 1] && ((a[i - 1] >= 'a' && a[i - 1] <= 'z' && a[i + 1] >= 'a' && a[i + 1] <= 'z') || (a[i - 1] >= '0' && a[i - 1] <= '9' && a[i + 1] >= '0' && a[i + 1] <= '9'))) {
				if(p1 == 1) {
					if(p3 == 2)
						for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
							for(int k = 1; k <= p2; ++k)
								printf("%c", j);
					else
						for(char j = a[i - 1] + 1; j <= a[i + 1] - 1; ++j)
							for(int k = 1; k <= p2; ++k) {
								printf("%c", j);
							}
				} else if(p1 == 2) {
					if(p3 == 2)
						for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
							for(int k = 1; k <= p2; ++k)
								printf("%c", (j >= 'a' && j <= 'z' && j > '9') ? j - 32 : j);
					else
						for(char j = a[i - 1] + 1; j <= a[i + 1] - 1; ++j)
							for(int k = 1; k <= p2; ++k) {
//								puts((j >= 'A') && (j <= 'Z') && (j > '9') ? "YES" : "NO");
								printf("%c", (j >= 'a' && j <= 'z' && j > '9') ? j - 32 : j);
							}
				} else if(p1 == 3) {
					for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
							for(int k = 1; k <= p2; ++k)
								printf("*");
				}
			}else if(a[i] == '-' && a[i + 1] == a[i - 1] + 1)
				printf("%c%c", a[i - 1], a[i + 1]); 
			 else
				printf("%c", a[i]);
		}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
} 
```
### 2 First Version
此为笔者在 2019 年参加的包含此题的模拟赛时的代码，请忽略 $\mathcal{O}(3)$ 优化（亲测发现不加也能过）。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#pragma GCC optimize(3)
using namespace std;

int p1, p2, p3;
string a;
int main() {
//	freopen("expand.in", "r", stdin);
//	freopen("expand.out", "w", stdout);
		scanf("%d%d%d", &p1, &p2, &p3);
		cin >> a;
		int len = a.size();
		printf("%c", a[0]);
		for(int i = 1; i < len - 1; ++i) {
			if(a[i] == '-' && a[i - 1] < a[i + 1] && ((a[i - 1] >= 'A' && a[i - 1] <= 'Z' && a[i + 1] >= 'A' && a[i + 1] <= 'Z') || (a[i - 1] >= 'a' && a[i - 1] <= 'z' && a[i + 1] >= 'a' && a[i + 1] <= 'z') || (a[i - 1] >= '0' && a[i - 1] <= '9' && a[i + 1] >= '0' && a[i + 1] <= '9'))) {
				if(p1 == 1) {
					if(p3 == 2)
						for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
							for(int k = 1; k <= p2; ++k)
								printf("%c", (j >= 'A' && j <= 'Z' && j > '9') ? j + 32 : j);
					else
						for(char j = a[i - 1] + 1; j <= a[i + 1] - 1; ++j)
							for(int k = 1; k <= p2; ++k) {
//								puts((j >= 'A') && (j <= 'Z') && (j > '9') ? "YES" : "NO");
								printf("%c", (j >= 'A' && j <= 'Z' && j > '9') ? j + 32 : j);
							}
				} else if(p1 == 2) {
					if(p3 == 2)
						for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
							for(int k = 1; k <= p2; ++k)
								printf("%c", (j >= 'a' && j <= 'z' && j > '9') ? j - 32 : j);
					else
						for(char j = a[i - 1] + 1; j <= a[i + 1] - 1; ++j)
							for(int k = 1; k <= p2; ++k) {
//								puts((j >= 'A') && (j <= 'Z') && (j > '9') ? "YES" : "NO");
								printf("%c", (j >= 'a' && j <= 'z' && j > '9') ? j - 32 : j);
							}
				} else if(p1 == 3) {
					for(char j = a[i + 1] - 1; j >= a[i - 1] + 1; --j)
							for(int k = 1; k <= p2; ++k)
								printf("*");
				}
			}else if(a[i] == '-' && a[i + 1] == a[i - 1] + 1)
				printf("%c%c", a[i - 1], a[i + 1]); 
			 else
				printf("%c", a[i]);
		}
		printf("%c", a[len - 1]);
//	fclose(stdin);
//	fclose(stdout);
	return 0;
} 
```

## Conclusion
总的来说，这个题目其实就是一个暴力模拟，不过呢需要注意一些特判和输出的技巧。只要把题目理解了，同类型的题目自然就会做了。

---

## 作者：Gu_Ren (赞：13)

看似简单地模拟，实际恶心得要吐。蒟蒻的我一开始看到估计只要20行的代码，后来活生生的改成40行，模拟的路不好走啊。。。

虽然p党在字符串处理上应该是占有优势，可是某大佬的三目运算符p党看不懂啊。按题意来，我们可以得到以下的码题思路：
- 读入字符串，每个字符枚举一遍，然后按题意来输出
***
(枚举时有个技巧，我们从2到length(s)+1枚举，这样每次输出的对象选择i-1,处理的对象选择i,也是为了更好的对有“-”的字符做输出和处理)
- 1 判断i-1是否是“-”
- 1.1 如果是，有没有对“-”做过处理
- 1.1.1 如果没有然后输出前面的“-”
- 1.1.2 如果有就不用输出前面的“-”
- 1.2 如果不是就输出i-1表示的字符

**以上是正常输出方面的**
***
- 2 判断i是不是“-”
- 2.1 如果不是，那就按照上面的输出
- 2.2 如果是，先判断根据p1的值
- 2.2.1 p1=1，就把“-”旁边的两个字母换成大写的结果储存(输出时方便用)
- 2.2.2 p1=2，就把“-”旁边的两个字母换成小写的结果储存
- p1的值处理完后处理p3
- 2.2.3 p3=1，就顺地输出p2个字符（两重循环）
- 2.2.4 p3=2，就倒地输出p2个字符（两重循环）
- 2.2.5 p1=3，就顺输出p2个“*”（两重循环）

**以上是处理输出“-”方面的**
***
注：详细请参考下方代码，本人p党
```cpp
var
  s:string;
  p1,p2,p3,i,j,k,t1,t2,f:longint;
begin
  readln(p1,p2,p3);
  readln(s);//读入
  for i:=2 to length(s)+1 do//枚举
  begin
    if f=0 then write(s[i-1])//有没有对i-1做过处理
    else begin f:=0;continue;end;
    if (s[i]='-')and((s[i-1] in ['0'..'9'])and(s[i+1] in ['0'..'9'])or(s[i-1] in ['a'..'z'])and(s[i+1] in ['a'..'z'])or(s[i-1] in ['A'..'Z'])and(s[i+1] in ['A'..'Z'])) then //如果是“-”，这里加个判断“-”里的东西能不能输出
    begin
      t1:=ord(s[i-1]);t2:=ord(s[i+1]);
      if ord(t2-t1)=1 then begin f:=1;continue;end;//这里也要特判，如果出现“a-b”的情况，就不用往下做了，直接标记并退出，下次会输出“ab”
      case p1 of//转大小写
       2:begin t1:=ord(upcase(s[i-1]));t2:=ord(upcase(s[i+1]));end;
       1:begin t2:=ord(lowercase(s[i-1]));t2:=ord(lowercase(s[i+1]));end;
      end;
      if p3=1 then//顺地输出
      for j:=t1+1 to t2-1 do
      for k:=1 to p2 do
      begin 
        f:=1;
        if p1=3 then write('*')//要不要输出“*”
         else write(chr(j));
      end;
      if p3=2 then//倒地输出
      for j:=t2-1 downto t1+1 do
      for k:=1 to p2 do
      begin
        f:=1;
        if p1=3 then write('*')//要不要输出“*”
         else write(chr(j));
      end;
    end;
  end;
  writeln;//记得输出最后换行
end.
```

---

## 作者：封禁用户 (赞：7)

#### 思路  
就是运用大模拟，要注意几个问题（这个题卡了作者 
$2$ h）。  
- `||` 和 `&&` 的优先级。
- 操作 $5$ 中的题意。
- 从一个数到另一个数一共有多少个。
- 数字与字母分情况讨论。  
我还是个蒟蒻，不太擅长用大佬的三目运算符，只能直接按题意模拟。
#### 代码

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main() {
	int p1,p2,p3;
	cin>>p1>>p2>>p3;
	char a[1005];
	cin>>a;
	int n=strlen(a);
	for(int i=0;i<n;i++) {
		if(((a[i-1]>='a'&&a[i-1]<='z'&&a[i+1]>='a'&&a[i+1]<='z')||(a[i-1]>='0'&&a[i-1]<='9'&&a[i+1]>='0'&&a[i+1]<='9'))&&a[i]=='-'){//操作1，注意||和&&的优先级，所以要加括号，作者没有加括号得了60pts
			if(a[i+1]==a[i-1]+1) continue;//操作5
			if(a[i+1]<=a[i-1]) {//操作5
				cout<<'-';
				continue;
			}
      //大模拟
			if(p1==1) {
				if(p2==1) {
					if(p3==1) {
						for(char j=a[i-1]+1;j<a[i+1];j++) cout<<j;//注意是char，不是int
					}else if(p3==2) {
						for(char j=a[i+1]-1;j>a[i-1];j--) cout<<j;
					}
				}else if(p2!=1){
					if(p3==1) {
						for(char j=a[i-1]+1;j<a[i+1];j++)//次数*距离
							for(int k=1;k<=p2;k++) cout<<j;
					}else if(p3==2) {
						for(char j=a[i+1]-1;j>a[i-1];j--)
							for(int k=1;k<=p2;k++) cout<<j;
					}
				}
			}else if(p1==2) {
				if(p2==1) {
					if(p3==1) {
						for(char j=a[i-1]+1;j<a[i+1];j++) cout<<(char)(j-32);
					}else if(p3==2) {
						for(char j=a[i+1]-1;j>a[i-1];j--) cout<<(char)(j-32);
					}
				}else{
					if(p3==1) {
						for(char j=a[i-1]+1;j<a[i+1];j++)
							for(int k=1;k<=p2;k++)
								if(j>='a'&&j<='z') cout<<(char)(j-32);
								else cout<<j;
					}else if(p3==2) {
						for(char j=a[i+1]-1;j>a[i-1];j--)
							for(int k=1;k<=p2;k++) 
								if(j>='a'&&j<='z') cout<<(char)(j-32);//要分情况讨论，作者没有这个得了70pts
								else cout<<j;
					}
				}
			}else if(p1==3) {
				if(p2==1) {
					if(p3==1) {
						for(char j=a[i-1]+1;j<a[i+1];j++) cout<<'*';//要循环判断距离，作者没有这个得到了80pts
					}else if(p3==2) {
						for(char j=a[i-1]+1;j<a[i+1];j++) cout<<'*';
					}
				}else{
					if(p3==1) {
						for(int k=1;k<=p2*(a[i+1]-a[i-1]-1);k++) cout<<'*';
					}else if(p3==2) {
						for(int k=1;k<=p2*(a[i+1]-a[i-1]-1);k++) cout<<'*';//一定是减1，不是+1，作者没有这个得到90pts
					}
				}
			} 
		}else cout<<a[i];
	}
	return 0;//好习惯
}
```
谢谢大家!

---

## 作者：qhr2023 (赞：5)

## solution

模拟题。

只有遇到减号、减号两边同是数字或小写字母、减号右边字符严格大于左边才做展开处理。

展开其实就是把减号替换成一个字符串，下面考虑展开。先按 $p_1$ 的取值对这个字符串的每种字符变形（不变或改大写或改星号），再将变形后的字符重复 $p_2$ 次得到一个字符串，若 $p_3=2$ 则翻转字符串。展开就处理完了。

实现时，对于不是减号的字符直接输出，对于减号按上面展开后输出得到的字符串即可。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int p1, p2, p3;
string s, tmp;
bool p (char a, char b){
	return (a>='0' && a<='9' && b>='0' && b<='9')||(a>='a' && a<='z' && b>='a' && b<='z');
}
char P1 (char c) {
	if (p1==3) return '*';
	if (p1==2&&c>='a') return c-'a'+'A';
	return c;
}
void P2 (char c, int k) {
	while (k--) tmp+=c;
}
int main(){
	cin >> p1 >> p2 >> p3 >> s;
	cout << s[0];
	for(int i=1; i<(int)s.size()-1; tmp="", i++)
		if(s[i]=='-' && p(s[i-1], s[i+1]) && s[i+1]>s[i-1]){
			for (char j=s[i-1]+1; j<s[i+1]; ++j) 
				P2(P1(j), p2);
			if(p3==2) 
				reverse(tmp.begin(), tmp.end());
			cout << tmp;
		} else 
			cout << s[i];
	cout << s[s.size()-1];
	return 0;
}
```

---

## 作者：GLr137 (赞：5)

坑较多的字符串模拟题。

其实这题只需要 $ 3 $ 个循环，只要思路正确，码量可以减少很多（虽然还是比不上那些大佬），这里，我来详细讲解一下每个循环的功能。第一个循环是遍历字符串 $ s $ 的循环，在循环的过程中判断这一项是否是减号，再判断减号的左右是否越界、左右两个字符是否符合题目中的条件。是则进入下一轮循环。第二轮循环用来枚举左右两个字符中间（不包括本身）的字符，可以用三目运算符等方式减少判断（这样可以让原序和倒序只用一个循环），第三层枚举填充字符的重复个数 $ p_2 $，再判断是否要做转换大小写、填充星号的操作。最终输出循环中所记录的字符串即可。这样做的好处是题目描述中的第五点我们不用考虑了，因为如果减号右边的字符恰好是左边字符的后继，那么第二个循环就不会执行内部代码，也就不会造成影响。而如果减号右边的字符按照 `ASCII` 码的顺序小于或等于左边字符，那么就不会进入第二个循环。

注意点：由于这一切不分字母、数字，所以在第三个循环里有可能会遇到展开的是数字但是 $ p_1 $ 是 $ 2 $ 的情况，因为数字不能转换大写，所以这里需要特判。

```cpp
# include <bits/stdc++.h>
using namespace std;
int p1, p2, p3;
string s, z = "";
int main (){
    cin >> p1 >> p2 >> p3 >> s;
    for (int i = 0; i < s.size(); i++){
        if (s[i] == '-' && i < s.size() - 1 && i > 0 && ((s[i - 1] >= '0' && s[i - 1] <= '9' && s[i + 1] >= '0' && s[i + 1] <= '9' && s[i - 1] < s[i + 1]) || (s[i - 1] >= 'a' && s[i - 1] <= 'z' && s[i + 1] >= 'a' && s[i + 1] <= 'z' && s[i - 1] < s[i + 1]))){
            for (char j = (s[i - 1 + 2 * (p3 == 2)] + 1 - 2 * (p3 == 2)); (p3 == 1 ? j <= s[i + 1] - 1 : j >= s[i - 1] + 1); (p3 == 1 ? j++ : j--)){
                for (int k = 1; k <= p2; k++){
                    if (p1 == 1){
                        z += j;
                    }else if (p1 == 2 && j >= 'a' && j <= 'z'){
                        z += (j - 32);
                    }else if (p1 == 3){
                        z += '*';
                    }else{
                        z += j;
                    }
                }
            }
        }else{
            z += s[i];
        }
    }
    cout << z;
    return 0;
}
```

[记录](https://www.luogu.com.cn/record/199978797)

---

## 作者：Jerry_zpl (赞：3)

本题算法：字符串，模拟。  
本题难度建议：橙。  
思路如下：  
对于所有的操作，我们不难发现只有当 $p3=2$ 时才会特殊处理。我们可以以字符串中的字符 `-` 作为分阶段。只要碰到字符 `-` 且前面的字符小于后面的字符就是合法处理。  
处理方法见下：
- 若 $p1=1,p2=3$ 从下一个字符往上一个字符循环，每个字符输出 $p2$ 遍，因为是倒序。否则就是普通情况，顺序输出每个字符，注意每个字符也要输出 $p2$ 遍。
- 若 $p1=2,p2=3$，就从上一次的操作上更改即可，就是把所有输出的字符换成大写字母即可。
- 若 $p1=3$ 就循环下一个字符，到上一个字符，每次输出 $p2$ 遍 `*` 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1005;
char shift1(char ch)
{
	return ch-32;
}
signed main()
{
	int p1,p2,p3;
	cin>>p1>>p2>>p3;
	string s;
	cin>>s;
	int len=s.size();
	for(int i=0;i<len;i++)
	{
		if(s[i]=='-'&&s[i-1]<s[i+1]&&s[i-1]!='-'&&s[i+1]!='-'&&((s[i-1]>='a'&&s[i-1]<='z'&&s[i+1]>='a'&&s[i+1]<='z')||(s[i+1]>='0'&&s[i+1]<='9'&&s[i-1]>='0'&&s[i-1]<='9')))//上一个和下一个字符只能是小写字母或数字字符，否则不合法。
		{
			if(p1==1)
			{
				if(p3==2)
				{
					for(char j=s[i+1]-1;j>=s[i-1]+1;j--)
					{
						for(int k=1;k<=p2;k++)
						{
							cout<<j;
						}
					}
				}
				else
				{
					for(char j=s[i-1]+1;j<=s[i+1]-1;j++)
					{
						for(int k=1;k<=p2;k++)
						{
							cout<<j;
						}
					}
				}
			}
			else if(p1==2)
			{
				if(p3==2)
				{
					for(char j=s[i+1]-1;j>=s[i-1]+1;j--)
					{
						for(int k=1;k<=p2;k++)
						{
							if(j>='a'&&j<='z')
							{
								char ch=shift1(j);
								cout<<ch;
							}
							else
							{
								cout<<j;
							}
						}
					}
				}
				else
				{
					for(char j=s[i-1]+1;j<=s[i+1]-1;j++)
					{
						for(int k=1;k<=p2;k++)
						{
							if(j>='a'&&j<='z')
							{
								char ch=shift1(j);
								cout<<ch;
							}
							else
							{
								cout<<j;
							}
						}
					}
				}
			}
			else if(p1==3)
			{
				for(char j=s[i+1]-1;j>=s[i-1]+1;j--)
			    {
				    for(int k=1;k<=p2;k++)
				    {
					    cout<<'*';
				    }
			    } 
			} 
		}
		else if(s[i]=='-'&&s[i-1]+1==s[i+1])//注意特判特殊情况，例如 a-b 直接输出 ab 即可。
		{
			char ch1=s[i-1];
			char ch2=s[i+1];
			cout<<ch1<<ch2;
		}
		else
		{
			cout<<s[i];//否则直接输出
		}
	}
	return 0;
}
```

---

## 作者：I_Love_Codm (赞：2)

# 题解：P1098 [NOIP 2007 提高组] 字符串的展开

[题目传送门](https://www.luogu.com.cn/problem/P1098)

##### (本蒟蒻第一次发题解，望通过,谢谢)

### 题意&思路

---

给定参数 $p_1$、$p_2$，$p_3$ 对给定字符串展开。操作如下：（以下用 **C** 代表对应字符的 ASCll 码）

- 当减号两侧字符类型相同时（以下称合法减号，其余减号为非法减号）：

  - 当 $C_{\text{左}} < C_{\text{右}}$ 时，则：

    按 $p_1$ 确定**展开方式**，$p_2$ 确定**展开字符中相同字符的重复数**（填充字符不包括减号两侧字符），$p_3$ 确定**展开结果是否逆序**；

  - 否则：

    **不作处理**（保留等号及其左右字符）；

- 若减号两侧字符类型不同时，**不作处理**（保留等号及其左右字符）；

- 其余字符也**不作处理**（保留该字符）。



#### 综上所述：

1. 如果当前字符为**非减号**或**非法减号**，则**直接输出**；

2. 如果当前字符为合法字符，进行展开操作。

然后模拟既可。

AC code：
---

```cpp
#include<bits/stdc++.h>
using namespace std;
int p1, p2, p3, l, r;
string a;
bool check(int l,int r){
	return(a[l]<a[r])&&(('0' <= a[l]&&a[l]<='9')&&('0'<= a[r]&&a[r]<='9')||('a'<=a[l]&&a[l]<='z')&&('a'<=a[r]&&a[r]<='z'));
}
string solve(int l,int r){
    string result=""; bool flag=p1!=3;
    char sum=flag?(p1==1?tolower(fst):toupper(fst)):'*';
    while(a[l]++<a[r]-1){
		for(int i=0;i<p2;i++)result+=sum;
		if(flag)sum++;
    }
    if(p3==2)reverse(result.begin(),result.end());
    return result;
}
int main() {
    cin >> p1 >> p2 >> p3 >> a; a += ' ';
    for(int i = 0; i < a.size()-1; i++)
        if(a[i]=='-'&&check(i-1,i+1))cout<<solve(i-1,i+1);
        else cout<<a[i];
    return 0;
}
```

---

## 作者：ShiYuXuan1234 (赞：2)

## 思路
这是一道大模拟题，思路请看代码注释。

---
## 坑点
1.只有满足条件 $(1)$ 的情况下才会进行字符串的展开，如果是`4-x`、`0--9`以及`c-a`这样的不用去动它。

2.当减号`-`出现在开头或结尾时不用去动它。

---
## 代码（含注释）

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	string str;
	int p1,p2,p3;
	cin>>p1>>p2>>p3>>str;
	int len=str.size();
	for(int i=0;i<len;i++){//开始模拟
		if(str[i]!='-'){//不是'-'直接输出
			cout<<str[i];
		}else if(str[i]=='-'&&i!=0&&i!=len-1){//找到'-'且不在开头或结尾
			if(str[i-1]+1==str[i+1]){//两边字符相同，遵照题意不进行输出
				continue;
			}else if(str[i-1]>=str[i+1]){//左边字符的ASCII码比右边字符大，遵照题意不动
				cout<<str[i];
			}else if((str[i-1]>='0'&&str[i-1]<='9')&&(!(str[i+1]>='0'&&str[i+1]<='9'))){//两边字符种类不同，遵照题意不动
				cout<<str[i];
			}else if((str[i-1]>='a'&&str[i-1]<='z')&&(!(str[i+1]>='a'&&str[i+1]<='z'))){//两边字符种类不同，遵照题意不动
				cout<<str[i];
			}else if(str[i-1]=='-'||str[i+1]=='-'){//出现连续'-',遵照题意不动
				cout<<str[i];
			}else{
				int ascii;
				if(p3==1){//先判断p3，因为p3不受两边字符干扰，此时p3=1
					ascii=str[i-1]+1;//遵照题意，按正序输出
					if(str[i-1]>='0'&&str[i-1]<='9'){//如果左右两边都是数字
						if(p1!=3){//p1!=3时，数字子串不受干扰
							while(ascii!=str[i+1]){//还没有到'-'右边的数字
								for(int i=0;i<p2;i++){
									cout<<char(ascii);//输出当前数字（不能输出ASCII码）
								}
								ascii++;//下一个数字
							}
						}else{//当p1=3时
							while(ascii!=str[i+1]){//还没有到'-'右边的数字
								for(int i=0;i<p2;i++){
									cout<<'*';//遵照题意，输出'*'
								}
								ascii++;//下一个数字
							}
						}
					}else if(str[i-1]>='a'&&str[i-1]<='z'){//如果左右两边都是小写字母
						if(p1==1){//p1=1时，填充小写字母
							//ASCII码不变
							while(ascii!=str[i+1]){//还没有到'-'右边的小写字母
								for(int i=0;i<p2;i++){
									cout<<char(ascii);//输出当前小写字母（不能输出ASCII码）
								}
								ascii++;//下一个小写字母
							}
						}else if(p1==2){//p1=2时，填充大写字母
							ascii-=32;//ASCII码减32表示切换成当前小写字母对应的大写字母
							while(ascii!=str[i+1]-32){//还没有到'-'右边的小写字母对应的大写字母
								for(int i=0;i<p2;i++){
									cout<<char(ascii);//输出当前大写字母（不能输出ASCII码）
								}
								ascii++;//下一个大写字母
							}
						}else{//当p1=3时
							while(ascii!=str[i+1]){//还没有到'-'右边的小写字母
								for(int i=0;i<p2;i++){
									cout<<'*';//遵照题意，输出'*'
								}
								ascii++;//下一个小写字母
							}
						}
					}					
				}else{//当p3=2时
					ascii=str[i+1]-1;//遵照题意，按逆序输出
					if(str[i-1]>='0'&&str[i-1]<='9'){//以下内容除特殊注释外，同p3=1部分
						if(p1!=3){
							while(ascii!=str[i-1]){//还没有到'-'左边的数字
								for(int i=0;i<p2;i++){
									cout<<char(ascii);
								}
								ascii--;//前一个数字
							}
						}else{
							while(ascii!=str[i-1]){//还没有到'-'左边的数字
								for(int i=0;i<p2;i++){
									cout<<'*';
								}
								ascii--;//前一个数字
							}
						}
					}else if(str[i-1]>='a'&&str[i-1]<='z'){
						if(p1==1){
							while(ascii!=str[i-1]){//还没有到'-'左边的小写字母
								for(int i=0;i<p2;i++){
									cout<<char(ascii);
								}
								ascii--;//前一个小写字母
							}
						}else if(p1==2){
							ascii-=32;
							while(ascii!=str[i-1]-32){//还没有到'-'左边的小写字母对应的大写字母
								for(int i=0;i<p2;i++){
									cout<<char(ascii);
								}
								ascii--;//前一个大写字母
							}
						}else{
							while(ascii!=str[i-1]){//还没有到'-'左边的小写字母
								for(int i=0;i<p2;i++){
									cout<<'*';
								}
								ascii--;//前一个小写字母
							}
						}
					}
				}
			}
		}else if(str[i]=='-'&&(i==0||i==len-1)){////找到'-'但在开头或结尾（这是后来补的，所以在后面）
			cout<<str[i];
		}
	}
	return 0;//完美的结束
}
```
虽然长了亿点点，但还是 [AC](https://www.luogu.com.cn/record/201049967) 了。

---

## 作者：ZZA000HAH (赞：2)

这道题模拟一下，两个给出的数据基本可以判断代码的正确性，但有可能是 $60$ 分，原因有可能是只在循环外求了 string 类的长度。

这道题的判断条件比较多，如果用 if...else 写的话代码会比较长，但是比较容易理解。

根据题目意思写就行，用到了 string 类的一些用法，可以上[官网](http://www.cplusplus.com/reference/stl/)查，当然也可以用字符数组。

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int main()
{
	int p1,p2,p3;
	cin>>p1>>p2>>p3;
	cin>>s;
	int len=s.size();
	for (int i=0; i<len; i++)
	{
		len=s.size();//注意更新！！！
		if (i!=0 && i!=len-1 && s[i]=='-')//判断"-",边界
			if (s[i-1]>='0' && s[i-1]<='9' && s[i+1]>='0' && s[i+1]<='9' && s[i+1]>s[i-1])
			{
				int x=i,l=int(s[i-1])+1,r=int(s[i+1]);
				s.erase(i, 1);//擦去"-"
				if (p1==3)
					for (int j=l; j<r; j++)//正序(与赋值的对应)
						for (int g=0; g<p2; g++)
						{
							s.insert(x,"*");
							x++;//更新添加位置
						}
				else if (p1==1 || p1==2)
					if (p3==1)
						for (int j=l; j<r; j++)
							for (int g=0; g<p2; g++)
							{
								s.insert(x,1,char(j));
								x++;
							}
					else if (p3==2)
						for (int j=r-1; j>=l; j--)//逆序(与赋值的对应)
							for (int g=0; g<p2; g++)
							{
								s.insert(x,1,char(j));
								x++;
							}
			}
			else if (s[i-1]>='a' && s[i-1]<='z' && s[i+1]>='a' && s[i+1]<='z' && s[i+1]>s[i-1])
			{
				int x=i,l=int(s[i-1])+1,r=int(s[i+1]);
				s.erase(i, 1);
				if (p1==3)
					for (int j=l; j<r; j++)
						for (int g=0; g<p2; g++)
						{
							s.insert(x,"*");//添加字符数组类const char*
							x++;
						}
				else if (p1==1)
				{
					if (p3==1)
						for (int j=l; j<r; j++)
							for (int g=0; g<p2; g++)
							{
								s.insert(x,1,char(j));//添加单个字符char
								x++;
							}
					else if (p3==2)
						for (int j=r-1; j>=l; j--)
							for (int g=0; g<p2; g++)
							{
								s.insert(x,1,char(j));
								x++;
							}
				}
				else if (p1==2)
					if (p3==1)
						for (int j=l; j<r; j++)
							for (int g=0; g<p2; g++)
							{
								s.insert(x,1,char(j-int('a')+int('A')));
								x++;
							}
					else if (p3==2)
						for (int j=r-1; j>=l; j--)
							for (int g=0; g<p2; g++)
							{
								s.insert(x,1,char(j-int('a')+int('A')));//变成大写
								x++;
							}
			}
	}
	cout<<s;
	return 0;
}
```
### End

---

## 作者：hbdcsd (赞：1)

## 思路

首先分析题意。

1. 当减号右边的字符按照 ``ASCII`` 码的顺序小于或等于左边字符或左右两边分别是字母和符号时，保留减号。

2. 当减号右边的字符恰好是左边字符的后继，直接删除减号。

对于具体的实现，
1. 当 $p_3=1$ 时，从等号左边的后继循环到等号右边的前驱，对于每一个要输出的字符，当 $p_1=1$，输出 $p_2$ 遍字符本身；当 $p_1=1$，输出 $p_2$ 遍字符对应的大写字母；当 $p_1=3$，输出 $p_2$ 遍星号。

2. 当$p_3=2$ 时，从等号右边的前驱循环到等号左边的后继，其他与 $p_3=1$ 相同。

我们发现这份代码需要大量大小写字母互换和数字、字母的判断的操作，为了减小代码复杂度，我们可以使用 ``cctype`` 头文件里的一些函数。

- ``isalpha`` 函数可以判断字符是否为字母，当给定的字符不是字母，不做操作。

- ``isdigit`` 函数可以判断字符是否为数字，当给定的字符不是字母，不做操作。

- ``tolower`` 函数可以将大写字母转化为小写字母。

- ``toupper`` 函数可以将大写字母转化为小写字母。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <string>
#include <cstring>
#include <cstdlib>
using namespace std;
typedef long long ll;
ll p1, p2, p3, l;
string s, ans;
int main(){
	cin >> p1 >> p2 >> p3 >> s;
	l = s.length();
	for (ll i = 0; i < l; i++){
		if (s[i] != '-') ans += s[i];//当前字符不是减号，直接放入答案
		else {
			if (s[i+1] == '-' || s[i-1] == '-') ans += s[i];//当存在连续的减号，直接放入答案
			else if (i == 0 || i == l-1) ans += s[i];//当减号处于字符串开头或结尾，直接放入答案
			else if (isdigit(s[i-1]) && isalpha(s[i+1]) || isdigit(s[i+1]) && isalpha(s[i-1])) ans += s[i];//当减号两边分别是字母和数字，直接放入答案
			else if (s[i-1] >= s[i+1]) ans += s[i];//当右边小于等于左边，直接放入答案
			else {
				if (p3 == 1){//p3 = 1，正序循环
					for (ll j = s[i-1]+1; j < s[i+1]; j++){
						for (ll k = 0; k < p2; k++){//输出 p2 遍
							if (p1 == 1) ans += tolower((char)j);//p1 = 1，应为小写字母
							else if (p1 == 2) ans += toupper((char)j);//p1 = 2，应为大写字母
							else ans += '*';//p1 = 3，应为星号
						}
					}
				} else {//p3 = 2，倒序循环，循环中的判断与 p3 = 1 时相同
					for (ll j = s[i+1]-1; j > s[i-1]; j--){
						for (ll k = 0; k < p2; k++){
							if (p1 == 1) ans += tolower((char)j);
							else if (p1 == 2) ans += toupper((char)j);
							else ans += '*';
						}
					}
				}
			}
		}
	}
	cout << ans;//输出答案
	return 0;
}
```

---

## 作者：Frank_G (赞：1)

# 简化题意

这道题目的题意没什么好简化的……

# 思路

思路啥的没有什么重要的，简单来说，就是按照题目描述直接模拟即可……

所以，直接上代码，凑合这注释看看吧。

# 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int p1,p2,p3;
string s;
bool panshu(char a){
	if(a>='0'&&a<='9') return true;
	return false;
}
bool panxiaomu(char a){
	if(a>='a'&&a<='z') return true;
	return false;
}
bool pandamu(char a){
	if(a>='A'&&a<='Z') return true;
	return false;
}//判断数字，小写字母，大写字母的函数。 
int main(){
	cin >> p1 >> p2 >> p3;
	cin >> s;
	int n=s.size();
	if(p1==1){
		for(int i=0;i<n;i++){
			if(s[i]=='-'){
				if(i==0){
					cout << '-';
					continue;
				}//这里很重要，如果不添加这个特判，那么如果第一个字符是'-'，你就会得到一堆乱码，然后WA#7。 
				if(s[i-1]>=s[i+1]){
					cout << '-';
					continue;
				}
				if((panshu(s[i-1])!=panshu(s[i+1]))||(panxiaomu(s[i-1])!=panxiaomu(s[i+1]))||(pandamu(s[i-1])!=pandamu(s[i+1]))){
					cout << '-';
					continue;
				}//三种不需要展开的情况进行特判。 
				if(p3==1){
					for(char j=s[i-1]+1;j<s[i+1];j++){
						for(int l=1;l<=p2;l++){
							if(pandamu(j)==true) cout << (char)(j+32);
							else cout << j;
						}
					}//顺序输出。 
				}
				else{
					for(char j=s[i+1]-1;j>s[i-1];j--){
						for(int l=1;l<=p2;l++){
							if(pandamu(j)==true) cout << (char)(j+32);
							else cout << j;
						}
					}//倒序输出。 
				}
			}
			else cout << s[i];
		}
	}//p1==1的情况，然后p1==2和p1==3的情况复制然后微调一下即可。 
	//一下p1==2和p1==3的情况与p1==1的情况大同小异，一下就不做注释了。 
	if(p1==2){
		for(int i=0;i<n;i++){
			if(s[i]=='-'){
				if(i==0){
					cout << '-';
					continue;
				}
				if(s[i-1]>=s[i+1]){
					cout << '-';
					continue;
				}
				if((panshu(s[i-1])!=panshu(s[i+1]))||(panxiaomu(s[i-1])!=panxiaomu(s[i+1]))||(pandamu(s[i-1])!=pandamu(s[i+1]))){
					cout << '-';
					continue;
				}
				if(p3==1){
					for(char j=s[i-1]+1;j<s[i+1];j++){
						for(int l=1;l<=p2;l++){
							if(panxiaomu(j)==true) cout << (char)(j-32);
							else cout << j;
						}
					}
				}
				else{
					for(char j=s[i+1]-1;j>s[i-1];j--){
						for(int l=1;l<=p2;l++){
							if(panxiaomu(j)==true) cout << (char)(j-32);
							else cout << j;
						}
					}
				}
			}
			else cout << s[i];
		}
	}
	if(p1==3){
		for(int i=0;i<n;i++){
			if(s[i]=='-'){
				if(i==0){
					cout << '-';
					continue;
				}
				if(s[i-1]>=s[i+1]){
					cout << '-';
					continue;
				}
				if((panshu(s[i-1])!=panshu(s[i+1]))||(panxiaomu(s[i-1])!=panxiaomu(s[i+1]))||(pandamu(s[i-1])!=pandamu(s[i+1]))){
					cout << '-';
					continue;
				}
				if(p3==1){
					for(char j=s[i-1]+1;j<s[i+1];j++){
						for(int l=1;l<=p2;l++){
							cout << "*";
						}
					}
				}
				else{
					for(char j=s[i+1]-1;j>s[i-1];j--){
						for(int l=1;l<=p2;l++){
							cout << "*";
						}
					}
				}
			}
			else cout << s[i];
		}
	}
	return 0;
}
```
然后就可以 [AC](https://www.luogu.com.cn/record/200261521) 了。

---

## 作者：Forgetter (赞：1)

# Java
### 题后感想
题目的难度不大，题目的要求写的很清楚了。

但是...我代码提交了3次才过。因为实在是不小心。
注意了！！要清楚的是**“-”可能在行首或行末出现一个或连续多个**。我在这里翻车了2次。。

- 字符串因为要增加删除，所以用**StringBuider**来接受
- 字母的大小写转换，我用了**String类的方法toUpperCase()和toLowerCase();**这样最方便。~~(本来我向判断ASCII来加减转换的，但是Java的类是其优势，该用就用。)~~

### 思路
1. 找出字符串中"-"的位置；

2. 比"-"前后字符的大小，以此来完成分类(完成要求1)。这里面就需要注意第一个和最后一个字符不能为一个或多个连续的"-"；

3. 满足的上述的条件后，继续在上述的分类中讨论，上述还需思考的分类就是：
	- 左右都是字母：

    - 左右都是数字：
    
    在上述分中：
        - 删除字符串中的"-"；(完成要求5)
        - 判断是否反转(完成要求4)，然后在这个分类里面调用添加方法(我分别写了添加字母和添加数字)；
        
4. 编写添加方法
	- 添加字母：通过判断是否转换大小写分类(完成要求2)，用到String类的方法toUpperCase()和toLowerCase()；并且循环添加要求次数；
    - 添加数字：直接ascii转换成对应数字即可；同样循环要求次数(完成要求3)
    
   收工，下面直接看代码
   
代码
------------
```java
import java.io.BufferedInputStream;
import java.util.*;

public class P1098 {
	static StringBuilder sb ;	//接受字符串
	static int a,b,p1,p2,p3;	//a,b 为 - 前后的字符Ascii码
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedInputStream(System.in));
		while(sc.hasNext()){
			sb = new StringBuilder();
			p1 = sc.nextInt(); p2 = sc.nextInt(); p3 = sc.nextInt();
			sb.append(sc.next());

			//分别找出“-”的位置 （这里随着字符串的改变会动态变化）
			for(int i=sb.indexOf("-");i!=-1;i=sb.indexOf("-", i+1))
				daxiao(i);
			System.out.println(sb);
		}sc.close();
	}


	//判断-  左边和右边的大小关系 来选这填充方式
	public static void daxiao(int n){
		if(n==0||n==sb.length()-1) return;	//这里小心第一个和最后一个为 -

		a = sb.charAt(n-1)+0;//前面一个值得ASCII
		b = sb.charAt(n+1)+0;//后面一个值的ASCII

		if((char)a=='-'||(char)b=='-') return;	//保存 不会是 -- 

		if (a>=b) //右边的值小于等于左边 保留 -
			return;
		else //右边大于左边
			//两个 都是 字母
			if((a>=97&&a<=122||a>=65&&a<=90)&&(b>=97&&b<=122||b>=65&&b<=90)){
				sb.deleteCharAt(n);	//去掉 -
				if(p3==1)	//不反转
					for(int i=a+1;i<b;i++,n+=p2) //这里加几个n指针也要变！！
						tianZimu(n,i);

				else 		//反转
					for(int i=b-1;i>a;i--,n+=p2)
						tianZimu(n,i);
			}
			//两个 都不是 字母 (即两边都是数字，可换成0~9 ———> ascii 48~57)
			else if((a<65||(a>90&&a<97)||a>122)&&(b<65||(b>90&&b<97)||b>122)){	
				sb.deleteCharAt(n);	//去掉 -
				if(p3==1)	//不反转
					for(int i=a+1;i<b;i++,n+=p2) //这里加几个n指针也要变！！
						tianShuzi(n,i);

				else 		//反转
					for(int i=b-1;i>a;i--,n+=p2)
						tianShuzi(n,i);
			}
			//只有一个 是 字母
			else
				return;
	}

	//填充字母
	public static void tianZimu(int n,int i){	//坐标  值
		if(p1==1)							//转换为小写字母
			for(int j=0;j<p2;j++)
				sb.insert(n++,String.valueOf((char) i).toLowerCase());			
		else if(p1==2)						//转换为大写字母
			for(int j=0;j<p2;j++)
				sb.insert(n++,String.valueOf((char) i).toUpperCase());		
		else 								//转换为  *
			for(int j=0;j<p2;j++)
				sb.insert(n++, "*");

	}

	//填充数字
	public static void tianShuzi(int n,int i){	//坐标  值
		if(p1==1||p1==2)					//数字不变（没大小写）
			for(int j=0;j<p2;j++)
				sb.insert(n++,(char)i);			
		else 								//转换为  *
			for(int j=0;j<p2;j++)
				sb.insert(n++, "*");	
	}
}

```

---

## 作者：Uni_Tune (赞：1)

这是一个多重switch嵌套。

先对数组进行初始化，看看每个'-'是不是可用，在字符串头或尾的不可用，两边字符不是一类的不可用，不是‘-’的当然不可用。

对字符串的每一个字符进行检测，按照两边的字符的规则再检测一次，如果可用就分情况模拟，按照p1，p2和p3的每种情况进行模拟。如果不是需要展开的字符直接输出，不需要任何模拟操作，这样就不需要各种字符串的扩展啊，储存啊之类的。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int p1,p2,p3;
char a[10001];
bool b[10001]={false}; 
int main()
{
    cin>>p1>>p2>>p3;
    scanf("%s",&a);
    int len=strlen(a),i,j,k,bh=0;
    for(i=1;i<=len-2;i++)
    {
        if(a[i]=='-')
        {
            if(((a[i-1]>='a'&&a[i-1]<='z')&&(a[i+1]>='a'&&a[i+1]<='z'))||((a[i-1]>='0'&&a[i-1]<='9')&&(a[i+1]>='0'&&a[i+1]<='9')))
            {
                b[i]=true;//用bool来储存是否可用
            } 
        }
    }
    for(i=0;i<=len-1;i++)
    {
        if(b[i])
        {
            if(a[i-1]+1==a[i+1])//检测两边字符的情况
            {
                continue;
            } 
            if(a[i-1]>=a[i+1])//同上
            {
                cout<<a[i];
                continue;
            }
            switch(p1)//switch嵌套的潮
            {
                case 1:
                    switch(p3)
                    {
                        case 1:
                            bh=(int)(a[i+1]-a[i-1])-1;
                            for(j=1;j<=bh;j++)
                            {
                                for(k=1;k<=p2;k++)
                                {
                                    cout<<(char)(a[i-1]+j);
                                }
                            }
                            continue;//没有这一句就会死，因为它可能会继续
                        case 2:
                            bh=(int)(a[i+1]-a[i-1]-1);
                            for(j=bh;j>=1;j--)
                            {
                                for(k=1;k<=p2;k++)
                                {
                                    cout<<(char)(a[i-1]+j);
                                }
                            }
                            continue;
                        default:continue;
                    }
                case 2:
                    switch(p3)
                    {
                        case 1:
                            if((a[i-1]>='a'&&a[i-1]<='z')&&(a[i+1]>='a'&&a[i+1]<='z'))
                            {
                                bh=(int)(a[i+1]-a[i-1])-1;
                                 for(j=1;j<=bh;j++)
                                {
                                    for(k=1;k<=p2;k++)
                                    {
                                        cout<<(char)(a[i-1]+j-32);
                                    }
                                }
                            }
                            else
                            {
                                bh=(int)(a[i+1]-a[i-1])-1;
                                for(j=1;j<=bh;j++)
                                {
                                     for(k=1;k<=p2;k++)
                                    {
                                        cout<<(char)(a[i-1]+j);
                                    }
                                }
                            }
                            continue;
                        case 2:
                            if((a[i-1]>='a'&&a[i-1]<='z')&&(a[i+1]>='a'&&a[i+1]<='z'))
                            {
                                bh=(int)(a[i+1]-a[i-1])-1;
                                 for(j=bh;j>=1;j--)
                                {
                                    for(k=1;k<=p2;k++)
                                    {
                                        cout<<(char)(a[i-1]+j-32);
                                    }
                                }
                                continue;
                            }
                            else
                            {
                                bh=(int)(a[i+1]-a[i-1])-1;
                                for(j=bh;j>=1;j--)
                                {
                                     for(k=1;k<=p2;k++)
                                    {
                                        cout<<(char)(a[i-1]+j);
                                    }
                                }
                                continue;
                            }
                            continue;
                        default:continue;
                    }
                case 3:
                    switch(p3)
                    {
                        case 1:
                            bh=(int)(a[i+1]-a[i-1])-1;
                            for(j=1;j<=bh;j++)
                            {
                                for(k=1;k<=p2;k++)
                                {
                                    cout<<"*";
                                }
                            }
                            continue;
                        case 2:
                            bh=(int)(a[i+1]-a[i-1]-1);
                            for(j=1;j<=bh;j++)
                            {
                                for(k=1;k<=p2;k++)
                                {
                                    cout<<"*";
                                }
                            }
                            continue;
                        default:continue;
                    }
                default:continue;    
            }
        }
        if(!b[i])
        {
            cout<<a[i];
        }
    }
    return 0;
}
```

---

## 作者：xiaobeng_0912 (赞：0)

## $\mathbf{Knowledge}$

1. 模拟

## $\mathbf{Solution}$

这道题不用压行也可以做，并且个人认为思路更清晰。具体流程如下：

1. 读入
2. 循环遍历每一位字符
3. 如果遇到减号，并且减号两侧同为小写字母或同为数字，且按照 `ASCII` 码的顺序，减号右边的字符严格大于左边的字符，就进行展开处理。
4. 按照题意根据参数来输出：先枚举 $p_3$ 的情况（因为 $p_3$ 只有两种情况），然后再枚举 $p_1$ 的情况，$p_2$ 不用枚举。
5. 如果是正常的字符，就直接输出。

然后，对于字符的判断和处理，我们还可以用一些 `cctype` 头文件里的函数：

- `isalpha(x)` 判断 $x$ 是否为字母。

- `isdigit(x)` 判断 $x$ 是否为数字。

- `tolower(x)` 将大写字母 $x$ 转化为小写字母。

- `toupper(x)` 将小写字母 $x$ 转化为大写字母。

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int p1,p2,p3;
string s;
int main(){
    scanf("%d%d%d",&p1,&p2,&p3);
    cin>>s;
    for(int i=0;i<s.size();i++){
    	/*如果当前字符是减号并且两侧同为小写字母或同为数字，且按照 ASCII 码的顺序，减号右边的字符严格大于左边的字符，就视为可以展开*/
        if(s[i]=='-'&&(s[i-1]<s[i+1])&&((isalpha(s[i-1])&&isalpha(s[i+1]))||(isdigit(s[i-1])&&isdigit(s[i+1])))){
        	/*由于p3只有两种情况，所以先考虑p3*/ 
            if(p3==1){
                if(p1==1){
                	/*正序输出、填充小写字母、每个字母重复p2遍的情况*/
                    for(char j=tolower(s[i-1])+1;j<=tolower(s[i+1])-1;j++){
                        for(int k=0;k<p2;k++){
                            printf("%c",j);
                        }
                    }
                }else if(p1==2){
                	/*正序输出、填充大写字母、每个字母重复p2遍的情况*/
                    for(char j=toupper(s[i-1])+1;j<=toupper(s[i+1])-1;j++){
                        for(int k=0;k<p2;k++){
                            printf("%c",j);
                        }
                    }
                }else{
                	/*正序输出、填充星号、每个字母重复p2遍的情况*/
                    for(char j=s[i-1]+1;j<=s[i+1]-1;j++){
                        for(int k=0;k<p2;k++){
                            printf("*");
                        }
                    }
                }
            }else{
                if(p1==1){
                	/*逆序输出、填充小写字母、每个字母重复p2遍的情况*/
                    for(char j=tolower(s[i+1])-1;j>=tolower(s[i-1])+1;j--){
                        for(int k=0;k<p2;k++){
                            printf("%c",j);
                        }
                    }
                }else if(p1==2){
                	/*逆序输出、填充大写字母、每个字母重复p2遍的情况*/
                    for(char j=toupper(s[i+1])-1;j>=toupper(s[i-1])+1;j--){
                        for(int k=0;k<p2;k++){
                            printf("%c",j);
                        }
                    }
                }else{
                	/*逆序输出、填充星号、每个字母重复p2遍的情况*/
                    for(char j=s[i+1]-1;j>=s[i-1]+1;j--){
                        for(int k=0;k<p2;k++){
                            printf("*");
                        }
                    }
                }
            }
        }else{
        	//如果是正常的字符就直接输出 
            printf("%c",s[i]);
        }
    }
    return 0;
}
```

---

## 作者：Capitalism_Gao (赞：0)

# Be Patient and Slow！！！

### 一.题目简介
1. 同时遇到下面的情况需要做字符串的展开：
   - 在输入的字符串中，出现了减号“-”；
   - 减号两侧同为小写字母或同为数字；
   - 且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。
2. 共有三个参数：p1,p2,p3。
   - p2：p2=k表示同一个字符要连续填充k个。
   - p3:是否改为逆序：p3=1表示维持原来顺序，p3=2表示采用逆序输出。
   - p1:这个是最复杂的：p1=1时，对于字母子串，填充小写字母；p1=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。
   
### 二.讲思路(多写几个Function思路就清晰了)
1. 写一个inline void work(int l,int r)函数:
   - work(a,b)就是负责输出s[a]和s[b]之间的展开式;
   - Example：当主串：a-d，p1=1,p2=2,p3=1时，work(0,2)输出"abbccd";
   - 在主函数遍历s时，if(s[i]=='-') work(i-1,i+1); 在这种情况下：s[i]处理了后，那么对于s[i+1]:它的上一个字符s[i]就是'-',并且在work(i-1,i+1)时已经输出s[i+1],所以就直接跳到s[i+2];
   - if(s[i]！='-') 直接输出s[i];
     #### 真的就这么简单吗？
     其实不然，举个例子  
     当主串为：a-b-c时，此时参数p已经不重要了，答案始终是：abc。然而，按照我们刚才的思路:                     
     - i=0: printf(a);
     - i=1: printf(ab);
     - i=2: printf(b);
     - i=3: printf(bc);
     - i=4: printf(c);      
     - 
     这样答案就成了aabbbcc：输出出现了重复；  
     解决：
     - if(s[i]!='-')，输出s[i]后还要标记used[i]=1;表示i号字符已经处理并输出。
     - if(s[i]=='-'),work(i-1,i+1)时就要判断s[i-1]已经处理没有，及如果used[i]=1,就不输出s[i-1];并且work()之后还要标记used[i+1]=1;
   - 还有一点：主函数循环遍历s时是从0~len(=s.size())-1-1,也就是把是s[len-1] (最后一位单独处理)： if(!used[len-1]) printf("%c",s[len-1]);因为如果s[len-1-1]！='-',那么s[len-1]就不会被输出。
   
**现在上主函数代码** 
```

int main(){
	ios::sync_with_stdio(0);
	cin>>p1>>p2>>p3>>s;
	int len=s.size();
	printf("%c",s[0]);
	used[0]=1;
	for(int i=1;i<len-1;i++){
	    if(s[i]=='-'){
	    	work(i-1,i+1);
	    	used[i+1]=1;
	    	i+=1;continue;
		}
		printf("%c",s[i]);
		used[i]=1;
	}
	if(!used[len-1]) printf("%c",s[len-1]);
    return 0;
}
```
2. 详解work(int l,int r)函数.
    - 如果s[l],s[r]同为数字或字母：
        - 如果s[l]<s[r]//符合规范，可以展开； 
        - 判断s[l]是否已经被处理过，还未被处理过才输出s[l]；
        - 如果p1=3,数字和字母都一样：填充'*'即可，并且不用管p3,因为此时逆序和顺序都一样了，考虑写一个inline void fillstar(int a,int b)函数，执行fillstar(int(s[l])+1,int(s[r])-1);
       - 如果p1=1或2,此时就要考虑p3,所以写一个inline void reverse(int a,int b)函数。执行reverse(int(s[l])+1,int(s[r])-1);
      - 输出s[r]并返回；
   - 如果s[l]>=不合规范；
      - 判断s[l]是否已经被处理过，还未被处理过才输出s[l]；
      - 输出"-"和s[r]并返回;   

**现在上work()函数代码**
```

inline void work(int l,int r){
	if(isalpha(s[l])&&isalpha(s[r])||isdigit(s[l])&&isdigit(s[r])){
		if(s[l]<s[r]){
			if(!used[l]) printf("%c",s[l]);
			if(p1==1||p1==2) {reverse(int(s[l])+1,int(s[r])-1);}//reverse函数把两种情况一同解决了
			if(p1==3) {fillstar(int(s[l])+1,int(s[r])-1);}
			printf("%c",s[r]);
			return; 
		}
	}
	if(!used[l]) printf("%c",s[l]);
	printf("-%c",s[r]);
}
```
**现在上fillstar()函数代码**
```

inline void fillstar(int l,int r){//如果p1=3,输出'*'
	for(int i=l;i<=r;i++)
		for(int j=1;j<=p2;j++)
			printf("*");
}
```
**现在上reverse()函数代码**
```

inline void reverse(int l,int r){
	if(p3==1){
		for(int i=l;i<=r;i++)
		    for(int j=1;j<=p2;j++)
				printf("%c",deal(char(i)));//deal函数处理大小字母的情况
	}
	if(p3==2){
		for(int i=r;i>=l;i--)
			for(int j=1;j<=p2;j++)
				printf("%c",deal(char(i)));//deal函数处理大小字母的情况
	}
}
```
**现在上deal()函数代码**
```

inline char deal(char x){
	if(isdigit(x)) return x;//如果是x数字，就直接返回x
	if(p1==1) return x;//如果p1=1,输出小写字母
	return x-'a'+'A';//如果p1=2,输出所对应的大写字母
}
```
### 三.完整AC代码(30MS完事)
```

#include<bits/stdc++.h>
using namespace std;

int p1,p2,p3,len;
string s; 
bool used[110];

inline char deal(char x){
	if(isdigit(x)) return x;//如果是x数字，就直接返回x
	if(p1==1) return x;//如果p1=1,输出小写字母
	return x-'a'+'A';//如果p1=2,输出所对应的大写字母
}

inline void reverse(int l,int r){
	if(p3==1){
		for(int i=l;i<=r;i++)
		    for(int j=1;j<=p2;j++)
				printf("%c",deal(char(i)));//deal函数处理大小字母的情况
	}
	if(p3==2){
		for(int i=r;i>=l;i--)
			for(int j=1;j<=p2;j++)
				printf("%c",deal(char(i)));//deal函数处理大小字母的情况
	}
}

inline void fillstar(int l,int r){//如果p1=3,输出'*'
	for(int i=l;i<=r;i++)
		for(int j=1;j<=p2;j++)
			printf("*");
}

inline void work(int l,int r){
	if(isalpha(s[l])&&isalpha(s[r])||isdigit(s[l])&&isdigit(s[r])){
		if(s[l]<s[r]){
			if(!used[l]) printf("%c",s[l]);
			if(p1==1||p1==2) {reverse(int(s[l])+1,int(s[r])-1);}//reverse函数把两种情况一同解决了
			if(p1==3) {fillstar(int(s[l])+1,int(s[r])-1);}
			printf("%c",s[r]);
			return; 
		}
	}
	if(!used[l]) printf("%c",s[l]);
	printf("-%c",s[r]);
}

int main(){
	ios::sync_with_stdio(0);
	cin>>p1>>p2>>p3>>s;
	int len=s.size();
	printf("%c",s[0]);
	used[0]=1;
	for(int i=1;i<len-1;i++){
	    if(s[i]=='-'){
	    	work(i-1,i+1);
	    	used[i+1]=1;
	    	i+=1;continue;
		}
		printf("%c",s[i]);
		used[i]=1;
	}
	if(!used[len-1]) printf("%c",s[len-1]);
    return 0;
}
```
### 四.总结：
**遇到复杂的大模拟类问题时**

1. 先想好共有多少种不同的情况；
2. 看这几种情况有没有能够合并在一起解决的；
3. 尽量多写点函数，便于理思路。

      

---

## 作者：glass_goldfish (赞：0)

不错的模拟题。

直接按照题意模拟即可。但是有几点要注意：  
1. 如果某个字符`-`的两边不是同为字母或同为数字，那么这个`-`不代表任何展开，但是要输出这个字符`-`；
2. 如果某个字符`-`右边的字符恰好是这个字符`-`左边字符的后继，只删除（不输出）这个字符`-`，而两边的字符不变；
3. 如果某个字符`-`右边的字符的 ASCII 码比这个字符`-`左边的字符的 ASCII 码小，那么这个字符`-`不代表任何展开，但是要输出这个字符`-`。

但是，太多的`if`语句会让人心烦。所以，可以使用如下的三目运算符：  
```cpp
(a? b:c)//a,b,c均可以是表达式
```
这个运算符相当于一个有三个参数的函数，其意义为：如果 $a$ 的值为真，那么返回 $b$ 的值；否则返回 $c$ 的值。这就相当于一个`if`语句，可以有效减少`if`语句的数量。

我们可以把字符`-`和其他字符分开处理：  

如果是其他字符，那么直接输出这个字符；

如果是字符`-`，那么首先判断这个字符`-`两边是否同为字母或同为数字，如果不是，那么直接输出`-`，否则继续执行；

如果这个字符`-`右边的字符的 ASCII 码比这个字符`-`左边的字符的 ASCII 码小，那么直接输出`-`；否则如果这个字符`-`右边的字符恰好是这个字符`-`左边字符的后继，那么什么也不输出；否则，开始扩充这个字符`-`。

扩充的流程如下：

若 $p_1=1$ 且 $p_3=1$，那么循环从这个字符`-`左边的字符的后继（即代表这个字符`-`左边的字符的 ASCII 码加 $1$ 的字符）到这个字符`-`右边的字符的前驱（即代表这个字符`-`右边的字符的 ASCII 码减 $1$ 的字符），每个输出 $p_2$ 遍。如果 $p_1=1$ 但是 $p_3=2$，那么直接倒过来循环即可。  

若 $p_1=2$ 且 $p_3=1$，那么循环从这个字符`-`左边的字符的**大写字母**的后继（即代表这个字符`-`左边的字符的 ASCII 码加 $33$ 的字符）到这个字符`-`右边的字符的**大写字母**的前驱（即代表这个字符`-`右边的字符的 ASCII 码加 $31$ 的字符），每个输出 $p_2$ 遍。如果 $p_2=1$ 但是 $p_3=2$，那么直接倒过来循环即可。  

若 $p_1=3$，那么那么循环从这个字符`-`左边的字符的后继（即代表这个字符`-`左边的字符的 ASCII 码加 $1$ 的字符）到这个字符`-`右边的字符的前驱（即代表这个字符`-`右边的字符的 ASCII 码减 $1$ 的字符），每个输出 $p_2$ 遍字符`*`。此时，不需要考虑 $p_3$，因为反过来也是一样的。

完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int p1,p2,p3;
string s;
bool r[3001]; 
signed main(){
	cin>>p1>>p2>>p3>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]=='-'&&((isdigit(s[i-1])&&isdigit(s[i+1]))||(islower(s[i-1])&&islower(s[i+1])))){//判断是否符合扩充条件
			if(s[i-1]>=s[i+1])cout<<"-";
			else if(char(s[i+1]-1)==s[i-1]);
			else{
				if(p3==1)
					for(char j=char(s[i-1]+1);j<s[i+1];j=char(j+1))
						for(int k=1;k<=p2;k++)
							cout<<(p1==1? char(j):p1==2? char(isdigit(j)? j:j-32):'*');
				else
					for(char j=char(s[i+1]-1);j>s[i-1];j=char(j-1))
						for(int k=1;k<=p2;k++)
							cout<<(p1==1? char(j):p1==2? char(isdigit(j)? j:j-32):'*');
			}
		}//扩充
		else cout<<s[i];
	}
    return 0;
}
```

---


# [NOIP 2016 提高组] 玩具谜题

## 题目背景

NOIP2016 提高组 D1T1

## 题目描述

小南有一套可爱的玩具小人，它们各有不同的职业。

有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u7em9pi.png) 

这时 singer 告诉小南一个谜题：“眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。”

小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。

小南一边艰难地辨认着玩具小人，一边数着:

singer 朝内，左数第 $3$ 个是 archer。

archer 朝外，右数第 $1$ 个是 thinker。

thinker 朝外，左数第 $2$ 个是 writer。

所以眼镜藏在 writer 这里！

虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：

有 $n$ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜题，其中第 $z$ 条指令形如“向左数/右数第 $s$ 个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。



## 说明/提示

**样例 1 说明**

这组数据就是【题目描述】中提到的例子。


**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

![](https://cdn.luogu.com.cn/upload/image_hosting/7su06u3r.png)

其中一些简写的列意义如下:

- 全朝内：若为 $\surd$，表示该测试点保证所有的玩具小人都朝向圈内；

- 全左数：若为 $\surd$，表示该测试点保证所有的指令都向左数，即对任意的 $1\leq z\leq m, a_i=0$；

- $s=1$：若为 $\surd$，表示该测试点保证所有的指令都只数 $1$ 个，即对任意的 $1\leq z\leq m,s_i=1$；

职业长度为 $1$：若为 $\surd$，表示该测试点保证所有玩具小人的职业一定是一个长度为 $1$ 的字符串。


## 样例 #1

### 输入

```
7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2```

### 输出

```
writer```

## 样例 #2

### 输入

```
10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4```

### 输出

```
y```

# 题解

## 作者：linhongzhao321 (赞：128)

题目 [ P1563 玩具谜题](https://www.luogu.org/problemnew/show/P1563)

看到那么多人的代码一堆if else 题解写一堆的，我有点眼花，把我的发上来吧
截止发布为止，以下代码是全部AC的

这是一道简单的模拟类型的题，主要注意两点
+ 数据量有点大，int无法表示，用long才能100%AC
+ 朝外向左与朝内向右是一样的方向，反之亦然，因此模拟判断过程可以稍微简化

```c
#include <stdio.h>

#define MAX_N 100000
#define MAX_M 100000

int main()
{
    char er_dir[MAX_N] = {0};       // 存储朝向
    long n, m, i, cur = 0, a, s;
    char er_occ[MAX_N][11] = {{0}};     // 存储职业
    scanf("%ld%ld", &n, &m);
    for (i = 0; i < n; ++i) {
        scanf("%ld%s", er_dir+i, er_occ[i]);
    }
    for (i = 0; i < m; ++i) {
        scanf("%ld%ld", &a, &s);        // 获取左右和序数
        if (er_dir[cur] == a)       // 向外朝左与向内朝右是一致的，反之亦然
        {
            s *= -1;
        }
        cur = (cur + n + s) % n;
    }
    printf("%s", er_occ[cur]);
    return 0;
}
```

---

## 作者：eros1on (赞：74)

> ~~请原谅我曾经身为 小学生 写的这个毒瘤题解~~

> ~~现在看着好尴尬啊……~~

> 所以我稍(wan)加(quan)修改了亿下。

---

为了使代码稍微简洁亿点点，我们用到了异或的基础知识

异或 可以理解为两个二进制数不带进位的加法：

```
0 ^ 0 = 1 ^ 1 = 0
0 ^ 1 = 1 ^ 0 = 1
```

也就是说两个数不同才能是 1 ，否则就是 0 。

剩下的就剩模拟部分了 没什么好说的。

---

**Code:**

```cpp
// 代码的毒瘤码风我实在懒得改了????
// 大家凑合着看吧 抱歉哈

#include <cstdio>
#include <cstdlib>
using namespace std;
#define MAXN 100100
int n,m,ans=1,s,a,out[MAXN];//out代表小人儿的朝向，ans是“凶手”的编号
char name[MAXN][75];//职业名称
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%s",&out[i],name[i]);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a,&s);//下一行用到了异或
		ans=(ans+(a^out[ans]?s:n-s))%n,ans=(!ans?n:ans);
	}
	printf("%s\n",name[ans]);
	return 0;
}
```

---

## 作者：continued258 (赞：34)

#### 大佬们都是c++,我继续来写个java代码
 这道题用java写除了要优化算法之外,最重要的是优化输入,java自带的scanner实在是太慢了,10w级别的数据而且不在 一行,超时是很正常的.
 
 第一次写用的 **Scanner scan =new Scanner(new BufferedInputStream(System.in)) ;
 
有4个测试点都是950ms左右运气好就ac,不好就TLE.之后去借鉴了cf上某位大佬的写的优化输入(下面那个内部类),改写输入之后某4个测试点在300ms左右,终于可以完美通过了.


------------

```java
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class Main {
	static int place, n, m;// place是当前位置,n是人物个数,m是指令个数
	static int[] N;// 存储人物朝向的数组
	static String[] Name;// 存储人物名称的数组

	public static void main(String[] args) {
		InputReader in = new InputReader(System.in);
		n = in.nextInt();
		m = in.nextInt();
		N = new int[n];
		Name = new String[n];
		for (int i = 0; i < n; i++) {// 读取所有的人物
			N[i] = in.nextInt();
			Name[i] = in.next();
		}
		for (int i = 0; i < m; i++) {// 读取所有操作同时计算
			opeart(in.nextInt(), in.nextInt());
		}
		System.out.println(Name[place]);
	}

	static void opeart(int i, int j) {
		// 其实只有两种情况,
		// 1 如果朝向内侧又向左移动表示为 0 0,如果朝向外侧有向右移动表示为1 1,这种情况下应该用当前位置减去移动的距离
		// 2朝向和移动方向不想同0 1或者1 0,则应该用当前位置加上移动的距离
		if (N[place] == i)
			place = (place + n - j) % n;
		else
			place = (place + j) % n;
	}

	// 这是个内部类,借鉴cf上某个java大佬的写法,只是为了解决读取输入太慢的问题
	static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader(InputStream stream) {
			reader = new BufferedReader(new InputStreamReader(stream), 32768);
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

	}
}

```

---

## 作者：__charlie520__ (赞：32)

### ``本道题目难度`` _较低_ ``，主要运用了``_模拟_ ``的算法。``
## 思路：
1. 输入
	1. 输入人数与命令条数
   2. 使用for循环输入每个人的朝向与名称
2. 模拟（循环n次）
	1. 输入第i条指令的方向与名称
   2. 判断是顺时针或逆时针
   		1. 如果是顺时针：序号 _**--**_
      2. 否则是逆时针：序号 _**++**_
   3. 判断序号是否超过限制(大于总人数或小于0)
   		1. 如果小于0：序号加上总人数
      2. 否则大于总人数：序号减少总人数
3. 输出：输出序号所对应的人的名称
## 伪代码：
```cpp
cin>>人数>>命令条数;
for(i = 0;i < 人数 ; i++)
	cin>>第i个人的朝向与名称;
for(i = 0;i < 命令条数 ; i++){
   cin>>第i条命令的方向与步数;
   if(第i个人朝外且命令方向朝右 || 第i个人朝内且命令方向朝左)
  		序号-=步数;
 	else
  		序号+=步数;
   if(序号 >= 人数)
  		序号-=人数;
   else if(序号 <= -1)
     序号 +=人数;
}
cout<<名称字符串[序号]
return 0;
```
## 看到这里你应该有思路了。
## 先去试试吧(￣▽￣)ブ
#
#
#
依然不懂？
## AC代码：
```cpp
#include<cstdio>//luoguP1563 
#include<iostream>
#include<cstring>
using namespace std;
//By SQ(原创)
int main()
{
	int m,n;//m人数，n命令
	int i,j;
	int ans = 0;//当前命令执行完后的位置 
	int ma,mb;//ma命令的朝向，0左1右 
	int a[100001];//m人的朝向，0内1外 
	string s[100001];//m人的名称
	cin>>m>>n;
	for(i = 0;i < m;i++)
		cin>>a[i]>>s[i];//输入mi人的朝向与名称 
	for(i = 0;i < n;i++)
	{
		cin>>ma>>mb;//输入i指令的朝向与个数
		if(a[ans] == 0 && ma == 0 || a[ans] == 1 && ma == 1)//朝内左或朝外右 
			ans = ans - mb;
		else//朝外左或朝内右
			ans = ans + mb;
		if(ans >= m)
			ans -= m;
		else if(ans <= -1)
			ans += m;
		//printf("-> %d\n",ans+1);//测试，可以忽略 
	}
	cout<<s[ans]; 
 	return 0;
}
```
## 请勿复制抄袭！可以借鉴学习！

---

## 作者：GSQ0829 (赞：11)

### 思路：
挺简单的，主要就是要懂得模拟转圈的过程判断。
```cpp
if (a[t] == x) t -= y;
else t += y;
if (t <= 0) t += n;
else if (t > n) t -= n;
```
这样就可以了。

---

### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100001;
int a[MAXN], n, m, x, y, t = 1;
string name[MAXN];

int main () {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i] >> name[i];
	for (int i = 1; i <= m; i++) {
		cin >> x >> y;
		if (a[t] == x) t -= y;
		else t += y;
		if (t <= 0) t += n;
		else if (t > n) t -= n;
	}
	cout << name[t] << endl;
	return 0;
}
```

---

## 作者：ywy_c_asm (赞：7)

这怕不是这题唯一一篇$O(nlogn)$的题解……

我们发现这要让我们每次不断地往某个方向跳某些步，我们希望加速这一过程，然后我们~~很自然的~~就能想到倍增，毕竟这是套路嘛。就是我们设$dp[0/1][i][j]$为（我们在这里规定0是顺时针，1是逆时针）我们从$i$出发，向顺/逆时针跳了$2^j$步，到达了什么地方，显然他要跳$2^j$步当$j>0$的时候需要先从$i$开始跳$2^{j-1}$步，然后从跳到的这个地方开始接着跳$2^{j-1}$步就达到了从$i$开始跳$2^j$步的效果，即

$dp[0/1][i][j]=dp[0/1][dp[0/1][i][j-1]][j-1]$。

注意边界条件就是$j=0$的时候为他跳一步到的位置。

然后我们每读入一个$s$就将他二进制拆分成$\sum 2^{a_i}$的形式，显然拆分的数量是$logn$级别的，每个2的幂都可以用倍增来跳，毕竟跳的过程是一个累积的过程。

~~别问我为啥不写模拟，作为一个再过一天就noip的蒟蒻重新看到这题的第一想法居然是倍增……~~

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
namespace ywy
{
	inline int get()//我的垃圾快读
	{
		int n=0;
		char c;
		while((c=getchar())||23333)
		{
			if(c>='0'&&c<='9')break;
			if(c=='-')goto s;
		}
		n=c-'0';
		while((c=getchar())||23333)
		{
			if(c>='0'&&c<='9')n=n*10+c-'0';
			else return(n);
		}
s:
		while((c=getchar())||23333)
		{
			if(c>='0'&&c<='9')n=n*10-c+'0';
			else return(n);
		}
	}
	inline void get(char *str)//我的垃圾字符串快读
	{
		char c;
		register int ptr=1;
		while((c=getchar())||23333)if(c>='A'&&c<='z')break;
		str[ptr]=c;
		ptr++;
		while((c=getchar())||23333)
		{
			if(c>='a'&&c<='z')str[ptr]=c,ptr++;
			else return;
		}
	} int dp[2][100011][17];//倍增数组
	char str[100011][15];//字符串
	unsigned char dir[100011];//每个人的朝向
	int lg[100011];//我们把每个数的log2预处理出来
	void ywymain() //注意！输入顺序为逆时针,0顺1逆！
	{
		int n=get(),m=get();
		lg[0]=-1;
		for(register int i=1; i<=n; i++)
		{
			dir[i]=get(),get(str[i]);
			lg[i]=lg[i-1];
			if(i==(i&-i))lg[i]++;//预处理log2
		}
		for(register int i=2; i<=n; i++)dp[0][i][0]=i-1;
		for(register int i=1; i<n; i++)dp[1][i][0]=i+1;//边界
		dp[0][1][0]=n;
		dp[1][n][0]=1;//注意这是环
		for(register int i=1; i<=lg[n]; i++)//递推出倍增数组
		{
			for(register int j=1; j<=n; j++)
			{
				dp[0][j][i]=dp[0][dp[0][j][i-1]][i-1];
				dp[1][j][i]=dp[1][dp[1][j][i-1]][i-1];
			}
		}
		int cur=1;//当前的位置
		while(m)
		{
			m--;
			int a=get(),s=get();
			int fx=dir[cur]^a;//他的顺序根据我们的规定异或一下朝向和方向就行了
			for(register int i=lg[s]; i>=0; i--)//二进制拆分
			{
				if(s&(1<<i))cur=dp[fx][cur][i];
			}
		}
		cout<<(str[cur]+1)<<endl;
	}
}
int main()
{
	ywy::ywymain();
	return(0);
}
```

---

## 作者：Zskioaert1106 (赞：5)

题目传送门：[P1563 [NOIP2016 提高组] 玩具谜题](https://www.luogu.com.cn/problem/P1563)。

定义结构体来存储玩具小人的名字和朝向。

```cpp
struct wjxr{
    string name;
    bool b;
}a[100005];
```

然后循环 $m$ 次。

设 $h$ 表示当前停留的小人编号，初始为 $0$。则对于每个循环：如果 $a_i$ 与当前小人的朝向相同，则相当于按编号往前找 $s_i$ 个，即 $h-s_i$；如果不同就是往后找——$h+s_i$。

- 别忘了判断：如果 $h<0$ 要加 $n$；如果 $h>n$，要减 $n$。

输出最终的 $a_h$ 的名字即可。

```cpp
#include<iostream>
using namespace std;
struct wjxr{
    string name;
    bool b;
}a[100005];
int main(){
    int n,m,h=0;
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i].b>>a[i].name;
    while(m--){
        int ai,si;
        cin>>ai>>si;
		if(a[h].b==ai){
			h-=si;
			if(h<0)h+=n;
		}
		else{
			h=h+si;
			if(h>=n)h-=n;
		}
    }
    cout<<a[h].name;
    return 0;
}
```

---

## 作者：ZAYNAab (赞：4)

## 题意

依次给你 $n$ 个围成一圈的人的内外方向及其名字，有 $m$ 条信息。

从 $1$ 号人数起，依次执行每条信息中按上一条信息结束的人的方向往左或右数 $s_i$ 个人，左时方向 $a_i=0$，右时方向 $a_i=1$。

输出执行完最后一条信息后数到的人的名字。

## 解题分析

明显应该使用 **模拟** 算法来模拟数人的过程。

根据每条信息给的数的方向，和小人的朝向，分如下四种情况：

- $a_i=0$，朝向为内，顺时针数。
- $a_i=1$，朝向为内，逆时针数。
- $a_i=0$，朝向为外，顺时针数。
- $a_i=1$，朝向为外，逆时针数。

顺时针时位数减 $s_i$，逆时针时位数加 $s_i$。

溢出后检查并补一下 $n$ 就可以了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x;
	string s;
}man[100005];
int n,m,now=1,k,p;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>man[i].x>>man[i].s;
	for(int i=1;i<=m;i++){
		cin>>k>>p;
		if(!k)p=-p;
		if(man[now].x==1)p=-p;
		now+=p;
		if(now>n)now-=n;
		if(now<=0)now+=n;
	}
	cout<<man[now].s;
	return 0;
}
```

---

## 作者：qhr2023 (赞：4)

## solution

一道小模拟。

对于一个人 $i$，记 $A_i$ 表示 $i$ 的朝向，分类讨论（$1$ 和 $n$ 特殊考虑）。
* 若 $A_i=0$，即朝内，向左找就减，向右找就加。
* 若 $A_i=1$，即朝外，向左找就加，向右找就减。

对于一组询问 $a$ 和 $s$，减的情况就是当前位置朝内向左找或当前位置朝外向右找，$A_i=0$ 且 $a=0$ 或 $A_i=1$ 且 $a=1$，即 $A_i=a$ 时减，那反过来不相等就加。

加减后再对 $n$ 取模，要特判取模后位置为 $0$ 的情况。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[100005], now=1;
string b[100005];
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i) 
		cin >> a[i] >> b[i];
	for (int x, s; m--; ) 
		cin >> x >> s,
		now=(now+(a[now]==x?-s:s)+n)%n,
		now=(!now?n:now);
	cout << b[now];
	return 0;
}
```

---

## 作者：Eason0324 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1563)

## 思路

首先，定义 $ng$ 表示现在是哪个人。随后，由于是环，所以答案是 $ng \bmod n$。

随后判断方向，这个很好判断，只需判断跟小人方向一不一样即可，如果相同往前，不同往后。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100009;
struct p{
	int d;
	string job; 
};
p a[N];
long long n,m,f,s,ng;
int main(){
	ng=1;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].d>>a[i].job; 
	}
	for(int i=0;i<m;i++){
		cin>>f>>s;
		if(a[ng].d==f) ng-=s;
		else ng+=s;
		if(ng>n) ng-=n;
		else if(ng<=0) ng+=n;
	}
	cout<<a[ng].job;
	return 0;
}
```

---

## 作者：lam_dyr (赞：2)

一道模拟水题。

## 题意

题面较长，核心是模拟玩具小人在环形圈上的移动，根据指令找到最终位置的小人并输出工作。

## 思路

从初始位置开始，按指令模拟移动，并更新当前位置即可。

有两点需要注意：

- 因为是环形，移动注意不能超出范围。
- 小人的朝向决定了实际移动方向是顺时针或逆时针。

## Code


```cpp
#include <iostream>
#include <string>
using namespace std;
int n,m;
int ori[10000];
string job[10000]; 
int main() {
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;++i) 
        cin>>ori[i]>>job[i];
    int cur=0; 
    for(int i=0;i<m;++i) {
        int dir,stp; 
        cin>>dir>>stp;
        int o=ori[cur];
        if(o== 0){ // 朝内
            if(dir==0) // 向左
                cur=(cur-stp%n+n)%n;
			else // 向右
                cur=(cur+stp%n)% n;
        } 
		else{ // 朝外
            if(dir==0)  // 向左
                cur=(cur+stp%n)%n;
        	else // 向右
                cur=(cur-stp%n+n)%n;
        }
    }
    cout<<job[cur];
    return 0;
}

```

---

## 作者：Vct14 (赞：2)

直接模拟即可。先求出按向外的小人的角度看是向左还是向右，如果向左就减，向右就加。为确保每次得到的结果为 $0$ 至 $n-1$ 内的正数，我们将它加上 $n$ 再对 $n$ 取模。

```cpp
#include<bits/stdc++.h>
using namespace std;

struct jobs{
	string name;
	int io;
}p[100002];

int main(){
	int n,m;cin>>n>>m;
	for(int i=1; i<=n; i++) cin>>p[i].io>>p[i].name;
	p[0].io=p[n].io,p[0].name=p[n].name;
	int nw=1;
	while(m--){
		int oi,s;cin>>oi>>s;
		int t=1;if(!((oi+p[nw].io)%2)) t=-1;
		nw=(nw+t*s+n)%n;
	}
	cout<<p[nw].name;
	return 0;
}
```

---

## 作者：New_Void (赞：2)

# P1563 [NOIP2016 提高组] 玩具谜题

从题目来看，这是道简单的模拟题，只需模拟出小人朝向哪里，来判断他的左手边或右手边是哪边就可以了。

## Code

```cpp
#include <iostream>
using namespace std;
int main(){
    int n,m,t=1;
    cin>>n>>m;
    int turn[n+1];
    string name[n+1];
    for (int i=1;i<=n;i++){
        cin>>turn[i]>>name[i];
    }
    for (int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        if (turn[t]==x){
            t-=y;
        }
        else{
            t+=y;
        }
        if (t<=0){
            t+=n;
        }
        else if(t>n){
            t-=n;
        }
    }
    cout<<name[t];
    return 0;
}

```

---

## 作者：Jerry_zpl (赞：1)

我们可以存储每个小人的信息，然后判断每个小人朝向的位置，然后根据方向记录位置，最后输出即可。一开始的位置是 $1$ 哦。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
string name[maxn];
int p[maxn];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i]>>name[i];
	}
	int now=1;
    while(m--)
    {
    	int op;
    	int x;
    	cin>>op>>x;
    	if(p[now]==0&&op==0) now-=x;
    	else if(p[now]==0&&op==1) now+=x;
    	else if(p[now]==1&&op==0) now+=x;
    	else if(p[now]==1&&op==1) now-=x;
    	while(now>n) now-=n;
    	while(now<1) now+=n;
	}
	cout<<name[now];
	return 0;
}
```

---

## 作者：Lidozs55 (赞：1)

# 重点就一句：循环队列暴力解决

移动方向由两个数值决定：一个是面朝方向，一个是左或右

循环队列可以通过数组模拟，大于大小n则需要%=n，因为转了一圈又到了起点，小于0还需要+=n，往前走走过了起点

这样一解释似乎就很简单了


代码献上

```cpp
#include<iostream>
#include<string>				//需要记录玩具的名字
using namespace std;
struct toys{
	string name;				//名字
	int d=0;				//0内1外 
};
int on=0,n,m,use,lr;
int main(){
	cin>>n>>m;				//输入
	toys toy[n];				//定义玩具
	for(int i=0;i<n;i++)			//循环输入
		cin>>toy[i].d>>toy[i].name;
	for(int i=0;i<m;i++){			//循环模拟转圈圈
		cin>>lr>>use;			//0左1右 
		use%=n; 			//移动距离
		if(lr+toy[on].d==1)on+=use;	//正着转
		else on-=use;			//反着转
		if(on>=n)on%=n;			//模拟循环队列
		if(on<0)on=on+n;		//防止走过头
	}
	cout<<toy[on].name;			//输出
	return 0;				//不要忘写哦
}
```

---

## 作者：GoldenSTEVE7 (赞：0)

## 思路
这一题很明显直接模拟就能过了。。。

首先我们可以用一个变量来记录目前转到了第几个人，由于玩具人战成了一个圈，所以我们在每一次更新玩这个变量后模一个 $n$，即总人数即可。但注意此时的编号最好从 $0 $ 开始，不然容易出现把序号弄混乱了的状况。最后还要注意，如果我们逆时针去数的时候，序号被减成负数也会造成序号混乱，**所以我们在逆时针数的时候要注意加上一个 $n$，再对变量进行操作。**

变量的操作如下：
- 若顺时针数 $x$ 个人，就将变量加 $x$。
- 若逆时针数 $x$ 个人，就将变量减 $x$。（做减法时需要注意我在上文提到的细节）

储存玩具人的数组其实你怎么开都可以，结构体和分开来其实是差不多的，这里我用的是结构体。

## 代码


```cpp
#include<iostream>
using namespace std;
struct node {
    int head;
    string name;
} a[100005];
int n, m;
int main() {
    cin >> n >> m;
    for(int i = 0; i < n; i++) {
        cin >> a[i].head >> a[i].name;
    }
    int now = 0;
    for(int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        if(a[now].head==0 && x==0) now = (now+n-y)%n;
        else if(a[now].head==0 && x==1) now = (now+y)%n;
        else if(a[now].head==1 && x==0) now = (now+y)%n;
        else if(a[now].head==1 && x==1) now = (now+n-y)%n;
    }
    cout << a[now].name << endl;
    return 0;
}
```

---


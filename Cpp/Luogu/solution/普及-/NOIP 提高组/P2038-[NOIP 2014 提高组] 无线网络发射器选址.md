# [NOIP 2014 提高组] 无线网络发射器选址

## 题目背景

NOIP2014 提高组 D2T1

## 题目描述

随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。

假设该城市的布局为由严格平行的 $129$ 条东西向街道和 $129$ 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 $1$。东西向街道从北到南依次编号为 $0,1,2 \dots 128$，南北向街道从西到东依次编号为 $0,1,2 \dots 128$。

东西向街道和南北向街道相交形成路口，规定编号为 $x$ 的南北向街道和编号为 $y$ 的东西向街道形成的路口的坐标是 $(x, y)$。在某些路口存在一定数量的公共场所。

由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 $2d$ 的正方形。传播范围包括正方形边界。

现在政府有关部门准备安装一个传播参数为 $d$ 的无线网络发射器，希望你帮助他们在城市内找出合适的路口作为安装地点，使得覆盖的公共场所最多。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq d \leq 20, 1 \leq n \leq 20, 0 \leq x \leq 128, 0 \leq y \leq 128, 0 < k \leq 10^6$。

## 样例 #1

### 输入

```
1
2
4 4 10
6 6 20```

### 输出

```
1 30```

# 题解

## 作者：decoqwq (赞：78)

这道题可以采用很多种方法来快速算出一个矩阵的和，可以采用二维前缀和，递推公式即
$$f(x,y)=f(x-1,y)+a[x][y]\ \ \ y=1\ or\ y=m$$
$$f(x,y)=f(x,y-1)+a[x][y]\ \ \ x=1\ or\ x=n$$
$$f(x,y)=f(x-1,y)+f(x,y-1)-f(x-1,y-1)+a[x][y]\ \ \ x,y\neq 1\ and\ x\neq n\ and\ y\neq m$$

然乎求矩阵$(x1,y1,x2,y2)$的和差分一下即可，时间复杂度为$O(n^2)$

而如果不用前缀和呢？我们如何快速的求出矩阵的和？

## 二维树状数组

时间复杂度略慢于前缀和，为$O(n^2\ log^2n)$

我们来观察一下二维树状数组基本操作代码：

添加：
```
#define lowbit(x) (x&(-x))
void add(int x,int y,int k)
{
	for(int i=x;i<=n;i+=lowbit(i))
    {
    	for(int j=y;j<=m;j+=lowbit(j))
        {
        	c[i][j]+=k;
        }
    }
}
```
显然的，就是一维树状数组再纵向添加了一次，查询也类似

代码：
```
#include <bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std;
int c[130][130];
int ans=0,maxn=-0x3f3f3f3f;
void add(int x,int y,int k)
{
    for(int i=x;i<=129;i+=lowbit(i))
    {
        for(int j=y;j<=129;j+=lowbit(j))
        {
            c[i][j]+=k;
        }
    }
}
int query(int x,int y)
{
    int ans=0;
    for(int i=x;i>=1;i-=lowbit(i))
    {
        for(int j=y;j>=1;j-=lowbit(j))
        {
            ans+=c[i][j];
        }
    }
    return ans;
}
int main()
{
    int d,n;
    cin>>d>>n;
    for(int i=1;i<=n;i++)
    {
        int x,y,k;
        scanf("%d%d%d",&x,&y,&k);
        add(x+1,y+1,k);
    }
    for(int i=1;i<=129;i++)
    {
        for(int j=1;j<=129;j++)
        {
            int i1=i-d;
            if(i1<=0)
            {
                i1=1;
            }
            int i2=(i+d);
            if(i2>=130)
            {
                i2=129;
            } 
            int j1=(j-d);
            if(j1<=0)
            {
                j1=1;
            }
            int j2=(j+d);
            if(j2>=130)
            {
                j2=129;
            } 
            int ans1=query(i2,j2)-query(i2,j1-1)-query(i1-1,j2)+query(i1-1,j1-1);
            if(ans1>maxn)
            {
                ans=1;
                maxn=ans1;
            }
            else if(ans1==maxn)
            {
                ans++;
            }
        }
    }
    cout<<ans<<" "<<maxn;
}
```
## 倍增
既然没有修改，我们为何不采用倍增的方法来求出矩阵的值？

倍增通过每次向一个点往后跳$2^j$的方式快速获得区间答案，因为其查询复杂度为$O(1)$并且将所求矩阵二进制分解需要$O(log^2n)$，故时间复杂度与二维树状数组类似，为$O(n^2\ log^2n)$

$a[i][j][k][p]$代表矩阵$(i,j)-(i+2^k,j)-(i,j+2^p)-(i+2^k,j+2^p)$的值，预处理时间复杂度也为$O(n^2)$，可以快速完成本题，这里就不发代码了。



后记：这道题虽然简单，但希望各位可以从简单的题目中探寻多种解决问题的方法，博主只是发掘了其冰山一角，只有平时更多的积累，才能在考场上胸有成竹。

---

## 作者：Whiteying (赞：11)

典型的枚举，先建一个二维数组储存该路口公共场所的数量，然后从（0,0）到（128,128）一个一个的试


枚举从（xi，yi）出发所能覆盖的所有数量，只要不超过边界就循环下去


然后再减去多加的轴上的数


如果当前值比最大值大的话，就更新最大值，将方案数恢复成1


相等就增加方案数


总体来说这个题算是noip day2 t1中比较简单的一道题


易错点是边界判定和减去多加的数


下面是代码：


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int a[150][150],x,y,d,n;
long long sum,z,ans,num;//开long long防爆 
int main()
{
    cin>>d>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>y>>x>>z;        //注意：x点和y点与二维数组的x，y相反 
        a[x][y]=z;            //因此在给地图赋值时xy反着输入 
    }                        //但经过验证其实正着输入其实也没问题 
    for(int i=0;i<129;i++)    //暴力枚举 
        for(int j=0;j<129;j++)    //把每一个点都枚举一遍 
        {
            sum=0;                //sum每次都回复为0 
            for(int xi=i;xi>=0&&xi<=128&&abs(xi-i)<=d;xi++)//枚举从（xi，yi）的右下方 
                for(int yi=j;yi>=0&&yi<=128&&abs(yi-j)<=d;yi++)
                    sum+=a[xi][yi];
            for(int xi=i;xi>=0&&xi<=128&&abs(xi-i)<=d;xi++)//枚举从（xi，yi）的左下方
                for(int yi=j;yi>=0&&yi<=128&&abs(yi-j)<=d;yi--)
                    sum+=a[xi][yi];
            for(int xi=i;xi>=0&&xi<=128&&abs(xi-i)<=d;xi--)//枚举从（xi，yi）的右上方
                for(int yi=j;yi>=0&&yi<=128&&abs(yi-j)<=d;yi++)
                    sum+=a[xi][yi];
            for(int xi=i;xi>=0&&xi<=128&&abs(xi-i)<=d;xi--)//枚举从（xi，yi）的左上方
                for(int yi=j;yi>=0&&yi<=128&&abs(yi-j)<=d;yi--)
                    sum+=a[xi][yi];
            int yi=j;
            for(int xi=i;xi>=0&&xi<=128&&abs(xi-i)<=d;xi++)//减去多加的下轴 
                sum-=a[xi][yi];
            for(int xi=i;xi>=0&&xi<=128&&abs(xi-i)<=d;xi--)//减去多加的上轴
                sum-=a[xi][yi];
            int xi=i;
            for(int yi=j;yi>=0&&yi<=128&&abs(yi-j)<=d;yi++)//减去多加的右轴 
                sum-=a[xi][yi];
            for(int yi=j;yi>=0&&yi<=128&&abs(yi-j)<=d;yi--)//减去多加的左轴
                sum-=a[xi][yi];
            sum+=a[i][j];                //加上当前点（xi，yi） 
            if(sum>ans)//如果当前值比最大值大的话 
            {
                ans=sum;
                num=1;
            }
            else if(sum==ans)//相等就增加方案数 
                num++;
        }
    cout<<num<<' '<<ans;//输入方案数和最大值 
    return 0;    
}
```

---

## 作者：JayYee (赞：7)

\_本蒟蒻看到数据，顿时：“卧槽，这不是随便暴力就行了么。。”于是乎就根本没想别的，直接开始暴力了。遍历每一个点，对其进行算能覆盖的公共场所，然后和ans比较大小，因为最后还要输出有多少个这样的点，于是可以用一个fangan来存储，如果这个点算出来的覆盖的点sum==ans，fangan++,如果sum>ans，就将ans=sum，并且方案重新定义为1（因为是遍历，所以你当前如果找到了最大的解，那么前面一定还没有找到过这个解，所以可以将其重置为1）。。于是这道模拟暴力题就这么过了。\_


但是，这题还有一个非常非常坑的地方：**边界的处理。**。一开始我考虑如果直接越界就return，于是代码如下：（70分）





```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int d,n,a[200][200],x,y,ans,fangan;
void solve(int x,int y){
    int lx,rx,uy,dy,sum(0);
    lx=x-d;rx=x+d;uy=y+d;dy=y-d;
    if(lx<0 || rx>128 || uy>128 || dy<0) return;
    for(int i=lx;i<=rx;i++)
    for(int j=dy;j<=uy;j++){
        sum+=a[i][j];
    }
    if(sum== ans) fangan++;
    if(sum>ans){
        ans=sum;
        fangan=1;
    }
}
int main(){
    scanf("%d%d",&d,&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&x,&y);
        scanf("%d",&a[x][y]);
    }
    for(int i=0;i<=128;i++)
    for(int j=0;j<=128;j++)
    solve(i,j);
    printf("%d %d\n",fangan,ans);
    return 0;
}
```
可是我之后想了想，****如果你遍历到（0,0）点，d为20，并且仅在a[1][1]有233个公共厕所，那么这个（0,0）这个点其实是可以算在方案里的，但是我却直接return了，这样的话不就出拐了么。。****于是我就改过来了
AC代码：




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int d,n,a[200][200],x,y,ans,fangan;
void solve(int x,int y){
    int lx,rx,uy,dy,sum(0);
    lx=x-d;rx=x+d;uy=y+d;dy=y-d;
    if(lx<0) lx=0;
    if(rx>128) rx=128;
    if(uy>128) uy=128;
    if(dy<0) dy=0;
    for(int i=lx;i<=rx;i++)
    for(int j=dy;j<=uy;j++){
        sum+=a[i][j];
    }
    if(sum== ans) fangan++;
    if(sum>ans){
        ans=sum;
        fangan=1;
    }
}
int main(){
//    freopen("1.txt","r",stdin);
//    freopen("ot.txt","w",stdout);
    scanf("%d%d",&d,&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&x,&y);
        scanf("%d",&a[x][y]);
    }
    for(int i=0;i<=128;i++)
    for(int j=0;j<=128;j++)
    solve(i,j);
    printf("%d %d\n",fangan,ans);
    return 0;
}
最后在这里照例%一下嘟嘟神犇，%%%
```

---

## 作者：封禁用户 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P2038)

抢个题解求过啊！

---

我们用两重循环遍历所有可能的路口作为安装点，然后对于每个可能的安装点，再用一重循环遍历所有有公共场所的路口，并检查是否在传播范围内，如果在则累加公共场所数量，然后更新答案，最后输出。

```cpp
#include <iostream>
using namespace std;

int a[25][5];

int main()
{
    int d, n;
    cin >> d >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= 3; j++)
            cin >> a[i][j];
    int cnt = 0, ans = 0;
    for (int i = 0; i <= 128; i++)
        for (int j = 0; j <= 128; j++)
        {
            int pos = 0;
            for (int k = 1; k <= n; k++)
                if (abs(a[k][1] - i) <= d && abs(a[k][2] - j) <= d)
                    pos += a[k][3];
            if (pos > ans)
            {
                ans = pos;
                cnt = 1;
            }
            else if (pos == ans) cnt++;
        }
    cout << cnt << " " << ans;
    return 0;
}
```

---

## 作者：兮水XiShui丶 (赞：4)

## 完全不会做思维题的我决定来一发STL碾标算  

map大法好啊还是  

大体思路:  因为数据范围只有128*128，所以我决定直接开一个map<pair<int,int>,int>来存一下这个位置有/没有发射器，然后发射器的覆盖范围是到哪里。  
然后统计答案的时候，我又开了一个map（其实这一维直接开数组就可以），统计一下有答案的数，看看答案最多的是哪里，然后输出这个答案
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <map>

using std :: map;
using std :: pair;
using std :: make_pair;

#define MP make_pair

int n , d;
map < pair < int , int > , int > mp;
map < long long , int > ans;

int main ( void ) {
    scanf ( "%d%d" , &d ,&n );
    for ( int i = 1 ; i <= n ; i++ ) {
        int x , y , z;
        scanf ( "%d%d%d" , &x , &y , &z );
        mp[MP ( x , y )] = z;
    }
    for ( int i = 0 ; i <= 128 ; i++ ) 
        for ( int j = 0 ; j <= 128 ; j++ ) {
            int now = 0;
            int minx = i - d , maxx = i + d;
            int miny = j - d , maxy = j + d;
            for ( map < pair < int , int > , int > :: iterator it = mp.begin() ; it != mp.end () ; it++ ) 
                if ( it -> first.first <= maxx && it -> first.first >= minx && it -> first.second <= maxy && it -> first.second >= miny ) 
                    now += it -> second;								
            ans[now]++;
        }
    int Now_Max = -2147483647;
    int Now_Sign = 0;
    for ( map < long long , int > :: iterator it = ans.begin() ; it != ans.end () ;  it++ ) {
        if ( it -> first > Now_Max && it -> second ) {
            Now_Max = it -> first;
            Now_Sign = it -> second;
        }
    }	
    printf ( "%d %d\n" , Now_Sign , Now_Max );
    return 0;
}
```

---

## 作者：行者_Walker (赞：2)

#### ~~我来挑战最短代码了！！~~

# 俗话说得好，短代码看着爽

咳咳，进入正题

## 思路 

为什么要用二维数组存图呢？我可以设置三个~~课代表~~数组：x[maxn],y[maxn],z[maxn];

### x数组->->存输入点的横坐标

### y数组->->存输入点的纵坐标

### z数组->->存输入点点权值

好了，定义完这三个数组后完我来讲讲如何~~带飞~~应用这三个数组

- 先上两个**for**循环枚举信号塔的位置（ i ， j ）。

- 这个信号塔的**横向**信号范围就是从 **i-d**（左） 到 **i+d**（右）

- 这个信号塔的**纵向**信号范围就是从 **j-d**（上）到 **j+d**（下）

- 我再来一个**for**枚举这**n**个点然后判断这**n**个点中是否有符合范围的点，如果有，那么加上这个累加上这个点点的权值

下面是对代码中难懂变量的解释

| 	| pu(上) |  |
| :----------: | :----------: | :----------: |
| pl(左） | <-方位-> | pr（右） |
|  |  pd(下)|  |


下面见代码：美滋滋

```cpp
# include <iostream>
# include <cstdio>//没有恶意压行，营造优美环境 
using namespace std;//你可以不带这个试试 
int x[130],y[130],z[130];//三个数组 
int main()
{
	int d,n;
	scanf("%d%d",&d,&n);
	for(int i=1;i<=n;i++)scanf("%d%d%d",&x[i],&y[i],&z[i]);
	int ans=0,maxn=0;
	for(int i=0;i<=128;i++) 
	for(int j=0;j<=128;j++)//遍历信号塔可以放的位置 
	{
		int pl=i-d,pr=i+d;
		int pu=j-d,pd=j+d;
		int sum=0;
		for(int k=1;k<=n;k++)//枚举n个点 
			if(pl<=x[k]&&x[k]<=pr&&pu<=y[k]&&y[k]<=pd)//如果处于范围内 
				sum+=z[k]; 
		if(sum==maxn)//碰到一样大的++ 
		ans++; 
		if(sum>maxn)//找到更大的值那就重新计数 
		{
			ans=1;
			maxn=sum;
		}
	}
	printf("%d %d",ans,maxn);//美滋滋的答案 
	return 0;
	//到这才三十行  喵喵喵！！！！ 
	puts("QWQ");//表达做出题后心中的欢喜 
}

```




---

## 作者：KJun (赞：1)

### 1.代码分析
首先，我们要理解清楚题意。题目让我们在 $128 \times 128$ 的网格上放置网络发射器，并且让我们覆盖的公共场所最多。要求的结果为方案数和覆盖数量。所以我们要做的就是算出每个放置点覆盖的个数，然后求最大覆盖个数和方案数量。观察到数据范围十分的小（$128 \times 128$），所以这道题可以暴力解决。

#### 1.1读入
第一，我们开一个名为 $r$ 的数组（初始化为 $0$）用于存储当前位置的场所数量。循环读入有场所的数据并赋值。

`long long r[129][129];`
```c++
cin>>d>>n;
memset(r,0,sizeof(r));
for(int i=0; i<n; i++){
    cin >> x >> y >> k;
    r[x][y] = k;
}
```


#### 1.2计算覆盖场所
第二，我们循环到每一个点上来尝试放置发射器，然后计算出当前区域覆盖场所的个数。

注意到以下的几种情况。(黑框为覆盖范围)
![](https://cdn.luogu.com.cn/upload/image_hosting/l7psxee6.png)

我们要从左到右遍历每一个地方，再加到一个 $sum$ 变量中。(因为是以遍历位置为中心，$2d$ 为覆盖正方形的边长。所以从左到右遍历，就是从中心位置横坐标点 $-d$ 到 $+d$。从下到上同理)

如图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/pyp2crii.png)


但是像 $1$，$2$ 这样地方，并不能覆盖像 $3$ 一样的区域（直接加或减会数组越界）。所以，我们遍历时需要对此进行特判。最无脑的方式就是：判断坐标是否越界，越界就  $+0$。

算出当前位置覆盖公共区域的个数后，我们就将答案存到 $a$ 数组中。（用于计算后续答案）

```c++
 for(int i=0;i<129;i++){
        for(int j=0;j<129;j++){
            int sum = 0;
            for(int m=i-d;m<=i+d;m++){
                for(int l=j-d;l<=j+d;l++){
                    if(m<0||l<0||m>128||l>128){
                    	sum+=0; 
                    }else{
                        sum+=r[m][l];
                    }
                }
            }
            a[i][j]=sum; 
        }
	}
```

#### 1.3计算最大覆盖数和方案
现在我们已经算出每个地方覆盖数量，并以坐标的方式存在数组 $a$ 中。接下来，我们设置两个变量 $ans$，$ans2$ 来存储最大覆盖数量和方案数（初始值为 $0$，因为答案最小也就是 $0$）。依次遍历里面的元素，如果当前位置的覆盖数量大于原来的最大覆盖数量（也就是原来的 $ans$），那就更新最大覆盖数量，并且打断方案数量，从一重新开始计算。

现在我们就可以输出啦！
```c++
long long ans=0,ans2=0;
	for(int i=0;i<129;i++){
		for(int j=0;j<129;j++){
			if(a[i][j]>ans){
				//cout<<i<<" "<<j<<endl;
				ans=a[i][j];
				ans2=1;
			}else if(a[i][j]==ans){
				ans2++;
			}
		}
	}
	cout<<ans2<<" "<<ans;
```

### 2.完整代码：
完整代码献上！！！
```
#include <bits/stdc++.h>
using namespace std;
//初始化 
long long r[129][129]; //公共场所（网格模拟） 
long long a[129][129];//覆盖数量 
long long ansx, ansy;
long long maxn = -114514;
int main(){
	//初始化和循环读入 
    long long d, n, x, y, k; 
    cin>>d>>n;
    memset(r,0,sizeof(r));
    for(int i=0; i<n; i++){
        cin >> x >> y >> k;
        r[x][y] = k;
    }
    //覆盖数量计算 
    for(int i=0;i<129;i++){
        for(int j=0;j<129;j++){
            int sum = 0;
            for(int m=i-d;m<=i+d;m++){
                for(int l=j-d;l<=j+d;l++){
                    if(m<0||l<0||m>128||l>128){
                    	sum+=0; 
                    }else{
                        sum+=r[m][l];
                    }
                }
            }
            a[i][j]=sum; 
        }
	}
	//计算最大覆盖数量和方案 
    long long ans=0,ans2=0;
	for(int i=0;i<129;i++){
		for(int j=0;j<129;j++){
			if(a[i][j]>ans){
				ans=a[i][j];
				ans2=1;
			}else if(a[i][j]==ans){
				ans2++;
			}
		}
	}
	//输出 
	cout<<ans2<<" "<<ans;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

暴力枚举题。数据范围很小，我们枚举每个点作为安装地点，循环遍历当前覆盖范围，计算当前覆盖的公共场所，同时更新最大值和最大值次数。

[通过记录](https://hydro.ac/record/6773fba84622fcac7bb9bd6b)。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int d, n, mx, cnt, a[135][135];
int main () {
	cin >> d >> n;
	for (int i=1, x, y, k; i<=n; ++i) 
		cin >> x >> y >> k,
		a[x][y]=k;
	for (int x=0; x<=128; ++x) 
		for (int y=0; y<=128; ++y) {
			int sum=0;
			for (int j=max(0, x-d); j<=min(128, x+d); ++j)
				for (int l=max(0, y-d); l<=min(128, y+d); ++l)
					sum+=a[j][l];
			if (sum>mx)
				mx=sum,
				cnt=1;
			else if (sum==mx)
				cnt++;
		}
	cout << cnt << ' ' << mx;
	return 0;
}
```

---

## 作者：Jayfeather2012 (赞：1)

## 题意
有一个 $128\times128$ 的矩阵，点上可能有若干个公共场所。现有一个边长为 $d$ 的无线电发射器，求此发射器能覆盖的最多公共场所数，和覆盖最多公共场所的方案数。
## 思路
枚举每个选址的位置，遍历被此位置覆盖的位置，计算被此位置覆盖的公共场所数，找出最大值，有和最大值相同的就增加方案数（其实就是个暴力）。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,x,y,k,maxn,ans,a[205][205]; 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>d>>n;
	for(int i=1;i<=n;++i){
		cin>>x>>y>>k;
		a[x+20][y+20]=k;//怕计算角落时超界，就开大了20
	}
	for(int i=20;i<=148;++i){//开大20
		for(int j=20;j<=148;++j){//j也一样
			int s=0;
			for(x=i-d;x<=i+d;++x)
				for(y=j-d;y<=j+d;++y)s+=a[x][y];//遍历覆盖位置并累加
			if(s>maxn){//求最大值
				maxn=s;
				ans=1;//方案个数归一
			}
			else if(s==maxn)++ans;//发现相同就增加方案个数
		}
	}
	cout<<ans<<" "<<maxn<<"\n";
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路
思路很简单，就是用一个数组，存坐标，枚举所能覆盖的所有数量，只要不超过边界就循环下去。然后再减去多加的轴上的数。
如果当前值比最大值大的话，就更新最大值，将方案数恢复成 $1$。
相等就增加方案数。

---
### code：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200;
int a[MAXN][MAXN], d, n, x, y, k, ans = 0, cnt = 0, sum = 0;

int main() {
	cin >> d >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x >> y >> k;
		a[x][y] = k;
	}
	for (int i = 0; i <= 128; i++) {
		for (int j = 0; j <= 128; j++) {
			sum = 0;
			for (int l = max(0, i - d); l <= min(128, i + d); l++) {
				for (int f = max(0, j - d); f <= min(128, j + d); f++) sum += a[l][f];
			}
			if (sum == cnt) ans++;
			if (sum > cnt) {
				cnt = sum;
				ans = 1;
			}
		}
	}
	cout << ans << ' ' << cnt << endl;
	return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：0)

# P2038 [NOIP2014 提高组] 无线网络发射器选址 题解

[题目传送门](https://www.luogu.com.cn/problem/P2038)

## 题目分析
看到题目，由于看见数据范围很小，所以枚举每一个点就行了。

### 枚举
由题目可知，我们可以安装在 $129 \times 129$ 网格中的任意一个。  
由于数据范围足够小，所以我们计算数量时都不用优化，慢慢去找就行。注意不要越界。

### 记录答案
由于我们还要求方案数，所以当我们枚举到一个更大的答案时，更新答案并重置方案数。  
当枚举到与目前最大值相同时，就增加方案数。

最终代码如下：

```cpp
#include <iostream> 
using namespace std;
int d,n,a[132][132],ans,cnt = 1;

int get(int x,int y){
	int ret = 0;
	for(int i = x-d;i <= x+d;i++)
		for(int j = y-d;j <= y+d;j++)
		if(i >= 0 && i <= 128 && j >= 0 && j <= 128)
			ret += a[i][j];
	return ret;
}

int main(){
	cin >> d >> n;
	while(n--){
		int x,y,k;
		cin >> x >> y >> k;
		a[x][y] = k;
	}
	for(int i = 0;i <= 128;i++)
		for(int j = 0;j <= 128;j++){
			int t = get(i,j);
			if(t > ans) ans = t,cnt = 1; //要重置为1!!
			else if(t == ans) cnt++;
		}
	cout << cnt << " " << ans;
	return 0;
}
```

## 总结
是一道基础的题，考察循环枚举，适合初学者练习。

感谢您的阅读！

---

## 作者：hbdcsd (赞：0)

## 思路

由于本题数据小，暴力即可 AC。

枚举每一个可以放置的点，再枚举每一个路口，枚举统计能被发射器覆盖的路口和。如果当前统计数等于最大值，方案数加 $1$，如果当前统计数大于最大值，更新最大值，将方案数重设为 $1$。最后输出方案数和最大值即可。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <string>
#include <cstring>
#include <climits>
#include <cstdlib>
using namespace std;
typedef long long ll;
int d, n, x[25], y[25], k[25], cnt, sum, maxn;
int main(){
	cin >> d >> n;
	for (int i = 1; i <= n; i++){
		cin >> x[i] >> y[i] >> k[i];
	}
	for (int i = 0; i <= 128; i++){
		for (int j = 0; j <= 128; j++){//枚举每一个点
			cnt = 0;
			for (int k0 = 1; k0 <= n; k0++){//防止变量名重复
				if (x[k0] <= i+d && x[k0] >= i-d && y[k0] <= j+d && y[k0] >= j-d) cnt += k[k0];//判断当前路口是否在发射器范围内
			}
			if (cnt == maxn) sum++;
			if (cnt > maxn){
				sum = 1;
				maxn = cnt;
			}
		}
	}
	cout << sum << " " << maxn;
	return 0;
}
```

---


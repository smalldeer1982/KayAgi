# [NOIP 2015 提高组] 神奇的幻方

## 题目背景

NOIp2015 提高组 Day1T1


## 题目描述

幻方是一种很神奇的 $N\times N$ 矩阵：它由数字 $1,2,3,\cdots \cdots ,N \times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。

当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：

首先将 $1$ 写在第一行的中间。

之后，按如下方式从小到大依次填写每个数 $K \ (K=2,3,\cdots,N \times N)$ ：

1. 若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；
2. 若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；
3. 若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；
4. 若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。

现给定 $N$ ，请按上述方法构造 $N \times N$ 的幻方。

## 说明/提示

对于 $100\%$ 的数据，对于全部数据， $1 \leq N \leq 39$ 且 $N$ 为奇数。



## 样例 #1

### 输入

```
3
```

### 输出

```
8 1 6
3 5 7
4 9 2```

## 样例 #2

### 输入

```
25
```

### 输出

```
327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325
353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326
379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352
405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378
431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404
457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430
483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456
509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482
535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508
561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534
587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560
613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586
14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612
40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13
66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39
92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65
118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91
144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117
170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143
196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169
222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195
248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221
274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247
300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273
301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299
```

# 题解

## 作者：GSQ0829 (赞：50)

### 思路：
这题很简单，就是根据题目意思写就行了。

首先得把幻方的中间写上一。

然后再来看条件

条件一：若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列。
```cpp
if (x == 1) {
    x = n;
    y++;
} 
```
条件二：若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行。
```cpp
if (y == n) {
    x--;
    y = 1;
} 
```
条件三：若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方。
```cpp
if ((x == 1 && y == n) || a[x - 1][y + 1]) x++;
```
否则，就是：
```cpp
else {
    x--;
    y++;
}
```

最后，将这几个串在一起，就有了最终的代码了。

---

### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 40;
int a[MAXN][MAXN], n, x = 1, y = 0;

int main() {
	cin >> n;
	y = n / 2 + 1;
	for (int i = 1; i <= n * n; i++) {
		a[x][y] = i;
		if ((x == 1 && y == n) || a[x - 1][y + 1]) x++;
		else if (x == 1) {
			x = n;
			y++;
		} else if (y == n) {
			x--;
			y = 1;
		} else {
			x--;
			y++;
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) cout << a[i][j] << ' ';
		cout << endl;
	}
	return 0;
}
```

---

## 作者：ClV_Csy (赞：20)

# P2615 [NOIP2015 提高组] 神奇的幻方
## 题意
就是按题意构造一个幻方。
## 思路
### 一、二维数组的下标
注意：C++ 中的数组下标从 $0$ 开始，**x 轴是竖直方向，从上到下增大；y 轴是水平方向，从左到右增大**。与数学中的坐标系**不**完全相同。

![logo](https://cdn.luogu.com.cn/upload/image_hosting/7b03zxif.png)

## 二、模拟
按题意模拟即可。
首先将 $1$ 写在第一行的中间。
填在第一行：`x = 1`，  
填在中间列：`y = N / 2 + 1` 或 `y = (N + 1) / 2`。

```cpp
if (k == 1) {
	x = 1;
	y = n / 2 + 1; //一行的中间位置
}
```


1. 若 $(K - 1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行，$(K - 1)$ 所在列的右一列；  
判断在第一行：`x == 1`，  
判断不在最后一列：`y != N`。

```cpp
else if (x == 1 && y != n) {
	x = n; //最后一行
	y++; //右一列
}
```

2. 若 $(K - 1)$ 在第最后一列但不在第一行，则将 $K$ 填在第一列，$(K - 1)$ 所在行的上一行；  
判断在最后一列：`y == N`，    
判断不在第一行：`y != 1`。  

```cpp
else if (y == n && x != 1) {
	x--; //上一行
	y = 1; //第一列
}
```

3. 若 $(K - 1)$ 在第一行最后一列，则将 $K$ 填在 $(K - 1)$ 的正下方；
判断在第一行：`x == 1`，
判断在最后一行：`y == N`。

```cpp
else if (x == 1 && y == n) {
	x++; //正下方，即下一行
}
```

4. 若 $(K - 1)$ 在既不在第一行，也不在最后一列，如果 $(K - 1)$ 的右上方还未填数，则将 $K$ 填在 $(K - 1)$ 的右上方，否则将 $K$ 填在 $(K - 1)$ 的正下方。
判断不在第一行：`x != 1`，
判断不在最后一列：`y != N`。
填在右上方（上一列，上一行）：
```
x--; //上一行
y--; //上一列
```
填在正下方：
```
x++;
```
本部分代码：

```cpp
else {
	if (a[x-1][y+1]) {
		x++;
	} else {
		x--;
		y++;
	}
}
```


## 代码

```cpp
#include <iostream>
using namespace std;
int main() {
	int n;
	int k = 1, x, y; //k表示第几个数，x,y表示k所在的位置
	int a[45][45] = {};
	cin >> n;
	while (k != n * n + 1) {
		if (k == 1) { //特判，最开始时
			x = 1;
			y = n / 2 + 1; //一行的中间位置
		} else if (x == 1 && y != n) {
			x = n;
			y++;
		} else if (y == n && x != 1) {
			x--;
			y = 1;
		} else if (x == 1 && y == n) {
			x++;
		} else {
			if (a[x-1][y+1]) {
				x++;
			} else {
				x--;
				y++;
			}
		}
		a[x][y] = k; //填写k
		k++;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cout << a[i][j] << " ";
		}
		cout << "\n";
	}
	return 0;
}
```

---

## 作者：Kawaii_qiuw (赞：13)

题面很好理解，不再赘述。

一篇初学者看的题解，大佬如要寻找更好做法可以忽略本文。

### 解题思路

读完题目后可以分析出来这道题基本解法就是模拟，数据范围不大，应当是不会超时。

第一个要处理的问题是查找数字 $k - 1$ 的问题，对于这种固定的问题，一般的处理方法是写一个函数，这里我们命名为 $map$，只需要对我们新建的“地图”进行遍历，找到即可停止。

第二个要处理的问题是填写数字 $k$ 的问题，既然题目上对填写要求分了四种情况，那么我们就可以单独写一个函数去处理填写的问题，分别对下一个数字要填写的位置进行更新，这里我们将变量命名为 $stuffi$，$stuffj$。

第三个要处理的问题是细节问题，为了方便理解和书写，我们只用到了二维数组里面索引为大于等于 $1$ 的部分，经过分析推导可以得到，当输入一个奇数 $n$ 时，数字 $1$ 根据规则一定会填写到 $map_{1,n \div 2 + 1}$ 的位置。另外还需要规定边界，以免遍历的过程中越界。

---

### 代码


```cpp
#include <iostream>
#include <cmath>
#include <cstdio>

const int M = 50;
using namespace std;
int n, rb, downb; //rb代表右边界,downb代表下边界
int map[M][M]; //初始地图
int stuffi, stuffj; //填充数字K的位置
 
void calculate(int ii, int jj) {
	stuffi = stuffj = 0; //初始化
	if (ii == 1 && jj != n) { //若k-1在第一行但不在最后一列
		stuffi = n;
		stuffj = jj + 1;
		return;
	}else if (jj == n && ii != 1) { //若k-1在最后一列但不在第一行
		stuffi = ii - 1;
		stuffj = 1;
		return;
	}else if (ii == 1 && jj == n) { //若k-1在第一行最后一列
		stuffi = 2;
		stuffj = jj;
		return;
	}else if (ii != 1 && jj != n) { //若k-1既不在第一行，也不在最后一列
		if (map[ii - 1][jj + 1] == 0 && ii - 1 > 0 && jj + 1 <= n) { //未填数
			stuffi = ii - 1;
			stuffj = jj + 1;
			return;
		}else { //填数
			stuffi = ii + 1;
			stuffj = jj;
			return;
		}
	}
	return;
}
 
void find(int x) {
	for (int i = 1; i <= downb; i++) { //对map进行遍历,查找K-1所在的位置
		for (int j = 1; j <= rb; j++) {
			if (map[i][j] == x) {
				calculate(i, j); //找到后进行计算判断
				return;
			}
		}
	}
}
 
int main() {
	cin >> n;
	rb = n; //规定边界
	downb = n; //规定边界
	map[1][n / 2 + 1] = 1; //填写数字1
	for (int k = 2; k <= n * n; k++) {
		find(k - 1); //查找数字K-1
		map[stuffi][stuffj] = k;
	}
	//输出
	for (int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) cout << map[i][j]<<" ";
		cout << endl;
	}
	return 0;
}
```

此解法并不是最优解，但适合初学者理解，感谢理解！

---

## 作者：LionBlaze (赞：5)

前言：为什么在题解里不能用一级标题啊。

按照题意模拟即可。

这里我们使用 $(x,y)$ 代表 $K-1$ 的坐标。

## “第一行的中间”是哪里

显然，是 $(0,(N+1) \div 2)$。

## 情况 $1$

条件：$x = 1$ 且 $y \not = N$。

下一个：$(N, y + 1)$。

## 情况 $2$

条件：$x \not = 1$ 且 $y = N$。

下一个：$(x-1, 1)$。

## 情况 $3$

条件：$x = 1$ 且 $y = N$。

下一个：$(2, 1)$。

## 情况 $4$

条件：$x = 1$ 且 $y \not = N$。

### 子情况 $1$

条件：$(x-1, y+1)$ 还没有数字（在代码中通常标为 $0$）。

下一个：$(x-1, y + 1)$。

### 子情况 $2$

条件：$(x-1, y+1)$ 有数字。

下一个：$(x+1, y)$。

---

代码非常简单，就不放了。如果讲到这里你都没有办法自己实现代码，那么说明你不大适合做这道题，先去做其它题目吧。

---

## 作者：prh_rpjiajia (赞：4)

- 要注意溢出情况。
- $1$ 应该填在 $a[1][n/2+1]$，不是 $a[1][n/2]$。
- 细节。
## 细节部分：
**前提是先找出 $(S-1)$ 的位置**。
对应代码：

```cpp
        int x=0,y=0;//x是行，y是列
        for (int x1=1;x1<=n;++x1)
        {
            for (int y1=1;y1<=n;++y1)
            {
                if (a[x1][y1]==i-1)
                {
                    x=x1;
                    y=y1;
                    break;
                }
            }
        }
```
注意：如果用 $x1$，$y1$ 记得不用万能头。
### 条件一个一个看：
1. 若 $(K−1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行，
 $(K−1)$ 所在列的右一列。
```cpp
        if (x==1&&y!=n)//x是行，y是列
        {
            a[n][y+1]=i;
        }
```
2. 若 
 $(K−1)$ 在最后一列但不在第一行，则将
 $K$ 填在第一列 $(K−1)$ 所在行的上一行。

```cpp
        else if (y==n&&x!=1)
        {
            a[x-1][1]=i;
        }
```
3. 若 
 $(K−1)$ 在第一行最后一列，则将 
 $K$ 填在
 $(K−1)$ 的正下方。

```cpp
        else if (y==n&&x==1)
        {
            a[x+1][y]=i;
        }
```
4. 若
 $(K−1)$ 既不在第一行，也不在最后一列，如果 $(K−1)$ 的右上方还未填数，则将
 $K$ 填在 $(K−1)$ 的右上方，否则将 
 $K$ 填在 $(K−1)$ 的正下方。
```cpp
        else
        {
            if (a[x-1][y+1]==0)
            {
                a[x-1][y+1]=i;
            }
            else
            {
                a[x+1][y]=i;
            }
        }
```
### 整合。

```cpp
#include<iostream>
using namespace std;
int a[45][45];
int main()
{
    int n;
    cin>>n;
    int l=n/2;
    a[1][l+1]=1;
    for (int i=2;i<=n*n;++i)
    {
        int x=0,y=0;
        for (int x1=1;x1<=n;++x1)
        {
            for (int y1=1;y1<=n;++y1)
            {
                if (a[x1][y1]==i-1)
                {
                    x=x1;
                    y=y1;
                    break;
                }
            }
        }
        if (x==1&&y!=n)//x是行，y是列
        {
            a[n][y+1]=i;
        }
        else if (y==n&&x!=1)
        {
            a[x-1][1]=i;
        }
        else if (y==n&&x==1)
        {
            a[x+1][y]=i;
        }
        else
        {
            if (a[x-1][y+1]==0)
            {
                a[x-1][y+1]=i;
            }
            else
            {
                a[x+1][y]=i;
            }
        }
    }
    for (int i=1;i<=n;++i)
    {
        for (int j=1;j<=n;++j)
        {
            cout<<a[i][j]<<" ";
        }
        cout<<"\n";
    }
}
```
最后考虑优化，每次位置都是在上一个的基础上变化的，所以 $x$，$y$ 可以随位置变化，时间复杂度：由 $O(n^3)$ 到了 $O(n)$。
## 优化后代码：

```cpp
#include<iostream>
using namespace std;
int a[45][45];
inline int read()//快读，新手可以忽略
{
    int cnt=0;
    int wei=1;
    char ch=getchar();
    while (ch<'0'||ch>'9')
    {
        if (ch=='-')wei=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        cnt=cnt*10+(ch-'0');
        ch=getchar();
    }
    return cnt*wei;
}
int main()
{
    int n;
    n=read();
    int l=n/2;
    a[1][l+1]=1;
    int x=1,y=l+1;
    for (int i=2;i<=n*n;++i)
    {
        if (x==1&&y!=n)//x是行，y是列
        {
            a[n][++y]=i;
            x=n;
        }
        else if (y==n&&x!=1)
        {
            a[--x][1]=i;
            y=1;
        }
        else if (y==n&&x==1)
        {
            a[++x][y]=i;
        }
        else
        {
            if (a[x-1][y+1]==0)
            {
                a[--x][++y]=i;
            }
            else
            {
                a[++x][y]=i;
            }
        }
    }
    for (int i=1;i<=n;++i)
    {
        for (int j=1;j<=n;++j)
        {
            cout<<a[i][j]<<" ";
        }
        cout<<"\n";
    }
}
```

---

## 作者：JCT_addyi (赞：4)

### 题意：

按照题目给的步骤打印一个 $n \times n$ 幻方。

### 思路：

直接暴力模拟。

### 代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100][100],s1=0,s2=0;
int main(){
	cin>>n;
	a[1][(n+1)/2]=1; //首先将 1写在第一行的中间。
	int i=1,j=(n+1)/2;
	for(int g=2;g<=n*n;g++){
		if(i==1&&j!=n){//若 (K-1)在第一行但不在最后一列
			a[n][j+1]=g;//则将 K填在最后一行，(k-1)所在列的右一列；
			s1=n;
			s2=j+1;
		}
		if(i!=1&&j==n){//若 (k-1)在最后一列但不在第一行
			a[i-1][1]=g;//则将K填在第一列,(K-1)所在行的上一行
			s1=i-1;
			s2=1;
		}
		if(i==1&&j==n){//若(K-1)在第一行最后一列
			a[2][n]=g;//则将 K填在(K-1)的正下方
			s1=2;
			s2=n;
		}
		if(i!=1&&j!=n){//若(K-1)既不在第一行，也不在最后一列
			if(a[i-1][j+1]==0){//如果(K-1)的右上方还未填数
			a[i-1][j+1]=g;//则将K填在(K-1)的右上方
			s1=i-1;
			s2=j+1;
			}
			else{//否则
			a[i+1][j]=g;//将 K填在(K-1)的正下方
			s1=i+1;
			s2=j;
		}
		}
		if(s1>n)//出界了的情况 
		s1=s1%n;
		if(s2>n)
		s2=s2%n;//出界了的情况 
		i=s1;
		j=s2;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
return 0;
}

```

谢谢大家！

---

## 作者：Mr_yang1 (赞：4)

# [P2615 [NOIP2015 提高组] 神奇的幻方](https://www.luogu.com.cn/problem/P2615)

按照题意模拟即可。

## 思路：
- 准备：
```
#include<bits/stdc++.h>
using namespace std;
int n,a[100][100],h,l,sum=1,lh,ll;//分别是：大小，保存数组，当前行，当前列，要填的数，上一次行坐标，上一次列坐标
int main(){
    cin>>n;
    if(n==1){cout<<1;return 0;}//特判
    h=1,l=n/2+1;//计算初始位置
    a[h][l]=1;//填入1
    while(sum!=n*n){//只要当前要填的数不满n*m，就要继续填

    }
}
```
- 按题意模拟：
```
lh=h,ll=l;//更新上一次的坐标
sum++;//要填的数增加1
h--;
//以下就是完全按照题目所述来操作
if(h==0)h=n;
l++;
if(l==n+1)l=1;
if(a[h][l]==0)a[h][l]=sum;
else{
    h=lh,l=ll;
    h++;
    if(h==n+1)h=1;
    a[h][l]=sum;
}
```
- 输出幻方：
```
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++)printf("%d ",a[i][j]);
    cout<<"\n";
}
```
## 完整代码：
```
请不要抄题解
#include<bits/stdc++.h>
using namespace std;
int n,a[100][100],h,l,sum=1,lh,ll;
int main(){
    cin>>n;
    if(n==1){cout<<1;return 0;}
    h=1,l=n/2+1;
    a[h][l]=1;
    while(sum!=n*n){
    	lh=h,ll=l;
    	sum++;
        h--;
        if(h==0)h=n;
        l++;
        if(l==n+1)l=1;
        if(a[h][l]==0)a[h][l]=sum;
        else{
			h=lh,l=ll;
			h++;
			if(h==n+1)h=1;
			a[h][l]=sum;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)printf("%d ",a[i][j]);
		cout<<"\n";//换行
	}
}
```

完结散花！

---

## 作者：hbdcsd (赞：3)

## 思路

按照题意模拟。

为方便模拟，使用两个变量记录下一个数要填的位置。

具体来说，先根据题目给出的信息计算出下一个数要填的位置，接着判断要填的位置是否有数，如果有填在正下方，如果没有填在记录好的要填的位置上，最后更新数据。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <string>
#include <cstring>
#include <climits>
#include <cstdlib>
using namespace std;
typedef long long ll;
int n, cnt = 1, a[100][100], x, y, nx, ny;//x 和 y 是现在的数位置，nx 和 ny 是下一个数的位置
int main(){
	cin >> n;
	a[1][n/2+1] = 1;//在第一行中间填 1
	x = 1, y = n/2+1;
	while (cnt < n*n){
		cnt++;
		if (x == 1 && y != n) nx = n, ny = y+1;//若上一个数在第一行但不在最后一列，填在最后一行，上一个数所在列的右一列
		else if (x != 1 && y == n) nx = x-1, ny = 1;//若上一个数在最后一列但不在第一行，填在第一列， 上一个数所在行的上一行
		else if (x == 1 && y == n) nx = x+1, ny = y;//若上一个数在第一行最后一列，填在上一个数的正下方
		else nx = x-1, ny = y+1;//否则，填在上一个数的右上方
		if (a[nx][ny] != 0) a[x+1][y] = cnt, x++;//如果将要填的位置已经有数，填在上一个数的下方
		else a[nx][ny] = cnt, x = nx, y = ny;
	}
	for (int i = 1; i <= n; i++, puts(""))//输出
		for (int j = 1; j <= n; j++) cout << a[i][j] << " ";
	return 0;
}
```

---

## 作者：Andy1101 (赞：3)

# [题目传送门](https://www.luogu.com.cn/problem/P2615)
# 思路
数字 $1$ 应该放在 $(1 , n \div 2 + 1)$ 的位置。

从数字 $2$ 开始寻找每个数字的位置，先让 $a[x][y]=i$，然后进行以下五个判断：
1. 若 $x=1$ 且 $y=n$，那么 $x$ 加 $1$。
2. 若 $a[x-1][y+1]$ 不等于 $0$，那么 $x$ 加 $1$。
3. 若 $x=1$，那么 $x=n$，$y$ 加 $1$。
4. 若 $y=n$，那么 $x$ 减 $1$，$y=1$。
5. 否则，$x$ 减 $1$，$y$ 加 $1$。

# AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=39+5;
int a[N][N];
int main()
{
    int n;
	cin>>n;
	int x=1,y=n/2+1;
	for(int i=1;i<=n*n;i++)
	{
		a[x][y]=i;
		if(x==1 && y==n) x++;
		else if(a[x-1][y+1]) x++;
		else if(x==1) x=n,y++;
		else if(y==n) x--,y=1;
		else x--,y++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
		    cout <<a[i][j]<<" ";
		}
		cout <<'\n';
	}
	return 0;
}
```

---

## 作者：ridewind2013 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2615)

## 思路


$1$ 应该在第 $1$ 行的第 $n \div 2 + 1$ 个。

从 $2$ 开始寻找每个数字位置，先 $a_{x,y} = i$，然后进行判断：

+ 如果 $x = 1$ 并且 $y = n$，那么 $x$ 加 $1$。

+ 如果 $a_{x-1,y+1}$ 已经使用过了，$x$ 加 $1$。

+ 如果 $x = 1$，那么 $x = n$，$y$ 加 $1$。

+ 如果 $y = n$，那么 $x$ 减 $1$，$y = 1$。

+ 否则，$x$ 减 $1$，$y$ 加 $1$。

最后直接循环输出答案即可。

## 代码

```cpp

#include<bits/stdc++.h>
using namespace std;
int a[40][40];
int main(){
    int n;
	cin>>n;
	int x=1,y=n/2+1;
	for(int i=1;i<=n*n;i++){
		a[x][y]=i;
		if(x==1&&y==n)x++;
		else if(a[x-1][y+1])x++;
		else if(x==1)x=n,y++;
		else if(y==n)x--,y=1;
		else x--,y++;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
		    cout<<a[i][j]<<" ";
		}
		cout<<"\n";
	}
	return 0;
}

```

---


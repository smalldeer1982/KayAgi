# [春季测试 2023] 涂色游戏

## 题目描述

有一天，小 D 在刷朋友圈时看到了一段游戏视频。

这个游戏的名字叫涂色游戏，视频中的游戏界面是一个 $n$ 行 $m$ 列的网格，初始时每一个格子都是白色（用数字 $0$ 表示）。其中每一行的左侧、每一列的上方都有一把带颜色的刷子。玩家点击某个刷子后，这个刷子会将其右侧（或下方）的一整行（或一整列）涂上同一种颜色，**该行（或该列）格子原有的颜色都会被覆盖成新涂上的颜色。**

下图展示的情况可以通过先将第一列涂成红色，然后将第一行涂成蓝色得到，若此时选择将第三列涂成绿色，则图中绿色方框中的格子都会变成绿色。

![](https://cdn.luogu.com.cn/upload/image_hosting/dc71alkw.png)

小 D 想用他自己编写的程序来进行视频中的游戏。在编程的过程中，小 D 在涂色逻辑的实现上却遇到了一些困难，于是他向你求助，希望你能帮他完成实现涂色逻辑部分的代码。

首先，小 D 会给你网格的行数和列数 $n, m$，然后给出 $q$ 次操作，每次操作用三个整数 $opt_i, x_i, c_i$ 表示：

- 如果 $opt_i=0$，那么这次操作会将第 $x_i$ **行**涂成颜色 $c_i$。
- 如果 $opt_i=1$，那么这次操作会将第 $x_i$ **列**涂成颜色 $c_i$。

在所有涂色操作结束以后，你需要输出网格中每个位置的颜色是什么。

## 说明/提示

**【样例 1 解释】**

注意当一个格子没有被涂色时，其颜色为白色，用数字 $0$ 表示。

**【样例 2】**

见选手目录下的 paint/paint2.in 与 paint/paint2.ans。

**【数据范围】**

对于所有数据，保证：

- $1 \leq T \leq 10$，$1 \leq n,m \leq 10^5$，$0 \leq q \leq 10^5$，$0 \leq c_i \leq 10^9$。
- 若 $opt_i=0$，则 $1 \leq x_i \leq n$；若 $opt_i=1$，则 $1 \leq x_i \leq m$。
- 单个测试点中所有数据的 $n \cdot m$ 的总和不超过 $10^6$，$q$ 的总和不超过 $10^6$。

|测试点|$n \le$|$m \le$|$q \le$|性质 A|性质 B|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|$1$|$1$|$0$|√|√|
|2|$1$|$1$|$1$|√|√|
|3|$1$|$10$|$20$|√|√|
|4|$1$|$10^5$|$10^5$|×|√|
|5|$1$|$10^5$|$10^5$|×|√|
|6|$1$|$10^5$|$10^5$|×|×|
|7|$10$|$10$|$20$|√|√|
|8|$50$|$50$|$100$|√|√|
|9|$50$|$50$|$100$|√|×|
|10|$1000$|$1000$|$2000$|×|√|
|11|$1000$|$1000$|$2000$|×|×|
|12|$1000$|$1000$|$2000$|×|×|
|13|$1000$|$1000$|$10^5$|×|×|
|14|$1000$|$1000$|$10^5$|×|×|
|15|$10^5$|$10^5$|$10^5$|√|√|
|16|$10^5$|$10^5$|$10^5$|√|√|
|17|$10^5$|$10^5$|$10^5$|√|×|
|18|$10^5$|$10^5$|$10^5$|√|×|
|19|$10^5$|$10^5$|$10^5$|×|×|
|20|$10^5$|$10^5$|$10^5$|×|×|

特殊性质 A：保证测试点中所有的 $q \cdot \max(n, m)$ 之和不超过 $10^7$。

特殊性质 B：保证 $opt_i = 1$。

**【提示】**

数据千万条，清空第一条。多测不清空，爆零两行泪。


## 样例 #1

### 输入

```
2
5 5 9
1 5 1
0 4 0
1 4 1
0 3 0
1 3 1
0 2 0
1 2 1
0 1 0
1 1 1
3 3 3
0 1 2
0 3 1
1 1 3```

### 输出

```
1 0 0 0 0
1 1 0 0 0
1 1 1 0 0
1 1 1 1 0
1 1 1 1 1
3 2 2
3 0 0
3 1 1```

# 题解

## 作者：liucang (赞：31)

容易发现，位于 $(x_i,y_i)$ 的格子的颜色只取决于 $x_i$ 行与 $y_i$ 列的颜色。

这时候可以想到开两个数组，分别存储列与行的绘画信息，然后发现前后的互相覆盖可以通过存储绘画顺序来得出。

于是开一个结构体，存储绘画信息，成员有：

1. color

2. priority

然后就可以在输出的时候反推回来，时间复杂度 $O(nm)$，可以通过本题。具体实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

struct paint{ //绘画信息，col=列，row=行
    ll color, priority;
}col[100010], row[100010];

ll n,m,q;

int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        memset(col,0,sizeof(col)); // 多测不清空，亲人两行泪
        memset(row,0,sizeof(row));
        scanf("%lld%lld%lld",&n,&m,&q);
        for(int i=1;i<=q;i++){
            ll opt,x,c;
            scanf("%lld%lld%lld",&opt,&x,&c);
            if(opt==0){
                row[x].color=c;
                row[x].priority=i;
            }
            else {
                col[x].color=c;
                col[x].priority=i;
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(row[i].priority>col[j].priority){
                    printf("%lld ", row[i].color);
                }
                else {
                    printf("%lld ", col[j].color);
                }
            }
            printf("\n");
        }
    }
    return 0;
}

// @nullptr_qwq & @wanhao326 祝大家AK春测！
```

---

## 作者：hloixyh (赞：7)

我们可以想一下，后涂的一定会覆盖掉前面涂的颜色，所以我们可以只记录下每行和每列最终的颜色，最后对于每个点比较行上与列上最后一次涂色的的时间，取时间靠后的那次涂色的颜色就能得出涂色完的矩阵。

具体实现见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,T;
pair<int,int> h[100005],s[100005];
int main(){
	scanf("%d",&T);//数据组数。 
	while(T--){
		scanf("%d%d%d",&n,&m,&q);
		for(int i=0;i<=n;i++){
			h[i]={0,0};//没涂色时全都是0。 
		}
		for(int i=0;i<=m;i++){
			s[i]={0,0};//没涂色时全都是0。
		}
		for(int i=1;i<=q;++i){//从1开始，不然在输出时会与没涂色的搞混，导致答案错误。 
			int o,x,c;
			cin>>o>>x>>c;
			if(o==0){
				h[x]={c,i};
			}else{
				s[x]={c,i};
			}
		}
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				if(h[i].second>s[j].second){//比较时间前后。 
					cout<<h[i].first<<" ";
				}else{
					cout<<s[j].first<<" ";
				}
			}
			puts("");
		}
	}
	return 0;
}
```


---

## 作者：fengziyi (赞：6)

### 简要题意
给定矩阵长宽和操作次数。  
每次操作给定涂色的三个参数，将矩阵的某一行或某一列涂成对应颜色。  
注意后涂色的会覆盖之前的。  
当一个格子没有被涂色时，其颜色为白色，用数字 $0$ 表示。
### 思路

注意到 $1 \leq n,m \leq 10^5$ 显然开二维数组不可行。  
于是可以考虑：每一次操作修改的是一整行或者一整列，建立两个记录行列颜色的数组。  

为了解决颜色覆盖的问题我们可以记录该行颜色被填涂的优先级，比较合适的是记录操作次序。  
对于多次填涂同一行列覆盖即可。  
对于一个格子被所在行列同时覆盖，比较优先级。

> 【提示】数据千万条，清空第一条。多测不清空，爆零两行泪。  

### 贴个代码
```cpp
#include <iostream>

#include <cstring>

#define i64 long long
#define reg register
#define qwq puts("fzy qwq ~");

using namespace std;

int T, n, m, q;
int line[2][100010];
int pri[2][100010];

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	cin >> T;
	while (T--)
	{
		cin >> n >> m >> q;
		for (reg int i = 1, opt, x, c; i <= q; ++i)
		{
			cin >> opt >> x >> c;
			line[opt][x] = c; // 记录对应行列颜色
			// 第一维 [0] 表示行，[1] 表示列
			pri[opt][x] = i; // 记录对应行列优先级
			// 对于多次填涂同一行覆盖即可
			// 对于一个格子被所在行列同时覆盖，比较优先级
		}
		for (reg int i = 1; i <= n; ++i)
		{
			for (reg int j = 1; j <= m; ++j)
				// 对于一个格子被所在行列同时覆盖，比较优先级
				if (pri[0][i] > pri[1][j]) // 优先级比较
					cout << line[0][i] << ' ';
				else
					cout << line[1][j] << ' ';
				// 也可写成
				// cout << line[(pri[0][i] < pri[1][j])]
                // 			   [(pri[0][i] >= pri[1][j] ? i : j)] << ' ';
			cout << endl;
		}
		memset(line, 0, sizeof line);
		memset(pri, 0, sizeof pri);
	}
	return 0;
}
```

---

## 作者：zhyou (赞：4)

## 思路
统计每一列，每一行最后一次的修改时间（即是第几个命令）和颜色。

输出时，假如我们遍历到了第 $i$ 行第 $j$ 列的点，则我们判断一下对第 $i$ 行最后一次操作的和对第 $j$ 列最后一次操作中哪一个操作晚（如果没有操作，则时间为 $0$），如果对第 $i$ 行的最后一次操作晚，则说明这个点最后被针对第 $i$ 行的最后一个操作修改，则输出最后一次对第 $i$ 行操作的颜色，反之同理。

## 代码
```
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 3;
struct ope{
    int time, color;
}r[N], c[N];

int main(){
    int T;
    scanf("%d", &T);
    
    while (  T-- ){
        int n, m, q;
        scanf("%d %d %d", &n, &m, &q);
        
        for (int i = 1; i <= n; i ++ ) r[i] = {0, 0}; //多测要清空
        for (int i = 1; i <= m; i ++ ) c[i] = {0, 0};
        
        for (int i = 1; i <= q; i ++ ){
            int op, x, color;
            scanf("%d %d %d", &op, &x, &color);
            
            if (!op) r[x] = {i, color};
            else c[x] = {i, color};
        }
        
        for (int i = 1; i <= n; i ++ ){
            for (int j = 1; j <= m; j ++ )
                printf("%d ", r[i].time > c[j].time ? r[i].color : c[j].color);
            
            puts("");
        }        
    }
    
    return 0;
}
```

---

## 作者：a2lyaXNhbWUgbWFyaXNh (赞：4)

看看数据范围，一眼诈骗。

额二维数组肯定行不通的。注意到每次操作只会修改一整行或者一整列，所以我们开两个数组，用来存第 $i$ 行 / 列最后涂色的颜色。再开两个数组记录时间戳（`std::pair` 也可以）。明显的，后涂色的会覆盖前涂色的。所以输出直接比较时间戳，输出时间戳大的（晚一点）。

**多测不清空，爆零两行泪。**

```cpp
#include<bits/stdc++.h>
#define faQ ctjer_and_ccf
std::pair<int,int>FK[100010],CCF[100010];
//以上同学的违规行为已被记录。
int DUOZUSHUJU=-1,OH,HSH,JW,KX,CF,FAD;
int main(){
 if(!~DUOZUSHUJU)
  std::cin>>DUOZUSHUJU;
 if(!DUOZUSHUJU)
  return 0;
 std::cin>>OH>>HSH>>JW;
 for(int I=1;I<=OH;++I)
    FK[I]=std::make_pair(0,0);
 for(int I=1;I<=HSH;++I)
    CCF[I]=std::make_pair(0,0);            
 for(int I=1;I<=JW;++I){
  std::cin>>KX>>CF>>FAD;
  if(!KX)
   FK[CF]=std::make_pair(I,FAD);
  else CCF[CF]=std::make_pair(I,FAD);
 }
 for(int I=1;I<=OH;++I){
  for(int J=1;J<=HSH;++J)
   std::cout<<max(FK[I],CCF[J]).second<<" ";
  std::cout<<'\n';
 }
 DUOZUSHUJU--;
 return main();
}
```

---

## 作者：南阳刘子骥 (赞：4)

考虑每一个格子的最终状态是怎么被决定的。

对于一个格子，其可能会被其对应行上的操作覆盖，也可能会被其对应列上的操作覆盖。

因为操作是按照时间顺序依次覆盖前一个操作的，我们可以给每一行和每一列都记录一个操作的时间戳和颜色，每一次遍历到一个格子的时候，检查其对应行和对应列上的时间戳哪个比较大，然后取较大者的颜色。

实际实现的时候就只需要维护四个数组，这样处理每一次询问都是 $O(1)$ 的，总时间复杂度是 $O(\sum (nm+q))$ 的。

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 100010;
int n, m, q;
int crow[N], trow[N];
int ccol[N], tcol[N];
void solve()
{
	scanf("%d%d%d", &n, &m, &q);
	for(int i = 1; i <= n; i++)
		ccol[i] = tcol[i] = 0;
	for(int i = 1; i <= m; i++)
		crow[i] = trow[i] = 0;
	for(int i = 1; i <= q; i++)
	{
		int op, x, c;
		scanf("%d%d%d", &op, &x, &c);
		if(op == 0)ccol[x] = c, tcol[x] = i;
		else if(op == 1)crow[x] = c, trow[x] = i;
		else puts("Youwike AK NOI!");
	}
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			if(tcol[i] >= trow[j])printf("%d ", ccol[i]);
			else printf("%d ", crow[j]);
		}
		putchar('\n');
	}
}
int main()
{
	int T;
	scanf("%d", &T);
	while(T--)
	{
		solve();
	}
	return 0;
}
```

---

## 作者：Asimplename (赞：2)

首先我们知道，如果某个点 $(x,y)$ 被涂上了颜色 $c$，那么说明最后一次涂的经过 $(x,y)$ 的操作（涂了第 $x$ 行或者第 $y$ 列）涂的是 $c$ 颜色。

那么我们可以存下每行和每列最后一次操作的颜色和时间，对于每个点，只需要比较行时间和列时间，哪个时间更靠后就是哪个颜色。

```cpp
#include<iostream>
#include<string.h>
using namespace std;
struct board{
	int col;
	int tim;
};
int t;
int n,m,q;
board h[100010];
board l[100010];
int main (){
	cin >> t;
	while(t --){
		memset(h, 0, sizeof(h));
		memset(l, 0, sizeof(l));
		cin >> n >> m >> q;
		int op,x,c;
		for(int i = 1; i <= q; i ++){
			cin >> op >> x >> c;
			if(op == 0){
				h[x].col = c;
				h[x].tim = i; 
			}
			else{
				l[x].col = c;
				l[x].tim = i;
			}
		}	
		for(int i = 1; i <= n; i ++){
			for(int j = 1; j <= m; j ++){
				if(h[i].tim > l[j].tim){
					cout << h[i].col << " ";
				}
				else{
					cout << l[j].col << " ";
				}
			}
			cout << endl;
		}
	}
	return 0;
}
```

---


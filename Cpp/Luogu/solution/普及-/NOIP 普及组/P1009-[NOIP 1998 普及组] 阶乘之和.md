# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# 题解

## 作者：C_Z_C (赞：4735)


本蒟的第一篇题解，不要问我为什么要发这篇题解，昨天用了半天才写完了这篇橙题代码，大佬勿喷。 

本蒟的思路就是高精乘+高精加，就是把高精乘的模板套上去接着套高精加的模板，b=c=i的阶乘。

话不多说，直接上代码：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a[90],b[90],c[90],f[90],d=0,len_a,len_b=1,len_c=1,len_ans,m=1;
string s;
int main(){
    cin>>n;
    b[0]=1; //初始化
    for(int i=1;i<=n;i++){ //计算i的阶乘，已经算好了i-1的阶乘
        len_a=0; //i的长度
        int p=i;
        while(p>0){ //把i存进a数组
            a[len_a++]=p%10;
            p/=10;
        }
        for(int j=0;j<len_a;j++) //计算a*b（i*（i-1）的阶乘），即i的阶乘，看不懂的网上查，我也不知道为什么
            for(int k=0;k<=len_b;k++)
                c[j+k]+=a[j]*b[k];
        for(int j=0;j<len_c;j++) //需要进位的就进位
            if(c[j]>9) c[j+1]+=c[j]/10,c[j]%=10;
        if(c[len_c]) len_c++; //看最高位要不要进位
        len_ans=len_b,len_b=len_c,m=max(m,len_c); //把len_b赋值给len_ans，修改len_b的值，m为i阶乘的长度，看有没有进位
        for(int k=len_c-1;k>=0;k--) b[k]=c[k]; //把c存进b数组，即存进i的阶乘，下次循环b为i-1的阶乘
        len_c=len_a+len_ans;
        memset(c,0,sizeof(c)); //清零c数组，准备计算下个阶乘
        for(int j=0;j<m;j++){ //高精加，直接套模板
            f[j]+=b[j];
            if(f[j]>9) f[j+1]+=f[j]/10,f[j]%=10; //进位，注意不要写成f[j+1]++，f[j]-=10;就因为这里wa了一个点
        }
    }
    while(!f[m]&&m>0) m--; //去掉首导零
    for(int i=m;i>=0;i--) cout<<f[i]; //倒序输出
    return 0; //圆满结束
}
```
最后……点个赞再走吧！

---

## 作者：zyk1256 (赞：2479)

这个题，用python一行就行了
```python
print(reduce(lambda x,y:x+y,[reduce(lambda x,y:x*y,range(1,i+1)) for i in range(1, int(raw_input())+1)]))
```

真是便利呢

---

## 作者：wuhao1027 (赞：1334)

极为简便的C语言风格，写这一题要先了解高精度加法和乘法的写法。

注意代码风格，注意代码风格！第一个题解就那么几行，我惊呆了，结果一细看。。。

这种风格很醉人的，新手要养成好习惯。

代码很简洁，看的时候要自己多想想，多用笔纸算一算~




```cpp
#include<stdio.h>
int main()
{
    int i,A[1005]={0},B[1005]={0},n,j;
    scanf("%d", &n);
    A[0]=B[0]=1;
    for (i=2;i<=n;i++){
        for (j=0;j<100;j++)
            B[j]*=i;
        for (j=0;j<100;j++)
            if (B[j]>9){
                B[j+1] += B[j]/10;
                B[j]%=10;
            }
        for (j=0;j<100;j++){
            A[j]+=B[j];
            if (A[j]>9) {
                A[j+1] += A[j]/10;
                A[j]%=10;
            }
        }
    }
    for (i=100;i>=0&&A[i]==0;i--);
    for (j=i;j>=0;j--) printf("%d", A[j]);
    return 0;
}
```

---

## 作者：Nortrom (赞：633)

## 这题主要分两步走：

阶乘一般数据比较大，因为C++存储量有限，最大也就unsigned long long，为了保险起见最好还是用高精进行维护。

### 一：求数

```cpp
void change(int x)//高精求积
{
	int g=0;
	for(int i=100;i>=0;i--)
	{
		a[i]=a[i]*x+g;
		g=a[i]/10;
		a[i]=a[i]%10;
	}
}
```


------------


### 二：相加
以下是代码内容
```cpp
void qh()//高精求和
{
	int g=0;
	for(int i=100;i>=0;i--)
	{
		s[i]=s[i]+a[i]+g;
		g=s[i]/10;
		s[i]=s[i]%10;
	}
}
```


------------
完整代码如下

拒绝复制粘贴的做题法

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a[101]={0},s[101]={0};
void change(int x)
{
	int g=0;
	for(int i=100;i>=0;i--)
	{
		a[i]=a[i]*x+g;
		g=a[i]/10;
		a[i]=a[i]%10;
	}
}
void qh()
{
	int g=0;
	for(int i=100;i>=0;i--)
	{
		s[i]=s[i]+a[i]+g;
		g=s[i]/10;
		s[i]=s[i]%10;
	}
}
void sc()
{
	int w;
	for(int i=0;i<=100;i++)
	{
		if(s[i]!=0)
		{
			w=i;
			break;
		}
	}
	for(int i=w;i<=100;i++)
	   printf("%d",s[i]);
}
int main()
{
	scanf("%d",&n);
	s[100]=a[100]=1;
	for(int i=2;i<=n;i++)
	{
		change(i);
		qh();
	}
	sc();
	return 0;
}
```


------------

其实这题我用了一下类似于剪枝操作，每次处理都基于上一次的操作，大大缩短了用时。

原创不易，如有雷同，纯属偶然。

---

## 作者：二元长天笑 (赞：252)

这道题对于C++的盆友来说还有另一个神奇的做法，就是**重载运算符**，虽然说代码有点长，但我还是要来补充一下的。

其实这只是把我们在平时生活中用到的竖式计算用计算机模拟了一遍，只不过这里是借用了C++自带的重载运算符，让主程序更加简单明了，虽然重载的过程可能没那么简单明了，不过看得懂就行了。

下面是超级无敌长的AC代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
struct fantastic     //嗯，开始重载了
{
    int len,s[9999];
    fantastic()
    {
        memset(s,0,sizeof(s));
        len=1;
    }
    fantastic operator=(const char*num)
    {
        len=strlen(num);
        for(int i=0;i<len;++i)
            s[i]=num[len-i-1]-'0';
        return *this;
    }
    fantastic operator=(const int num)
    {
        char a[9999];
        sprintf(a,"%d",num);
        *this=a;
        return *this;
    }
    fantastic (const int num)
    {
        *this=num;
    }
    fantastic (const char * num)
    {
        *this=num;
    }
    fantastic operator+(const fantastic &a)   //这里在重载 “+” 的运算
    {
        fantastic c;
        c.len=max(len,a.len)+1;                //这里就是我们熟悉的竖式模拟了
        for(int i=0,x=0;i<c.len;++i)
        {
            c.s[i]=s[i]+a.s[i]+x;
            x=c.s[i]/10;
            c.s[i]=c.s[i]%10;
        }
        if(c.s[c.len-1]==0)
            --c.len;
        return c;
    }
    fantastic operator * (const fantastic &x)           //然后再来波 “*” 的运算
    {
        fantastic c;
        c.len=len+x.len;                 //又是我们熟悉的竖式模拟
        for(int i=0;i<len;++i)
            for(int j=0;j<x.len;++j)
            {
                c.s[i+j]+=s[i]*x.s[j];
                c.s[i+j+1]+=c.s[i+j]/10;
                c.s[i+j]%=10;
            }
        if(c.s[c.len-1]==0)
            --c.len;
        return c;
    }
};
ostream& operator<<(ostream &out,const fantastic& x)   //重载一下输出
{
    for(int i=x.len-1;i>=0;--i)
        cout<<x.s[i];
    return out;
}
istream& operator>>(istream &in,fantastic &x)       //重载一下输入
{
    char num[9999];
    in>>num;
    x=num;
    return in;
}
int main()         //然后就可以愉快的开始主程序啦
{
    int n;
    fantastic ans=0,num=1;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        num=num*i;
        ans=ans+num;
    }
    cout<<ans<<endl;
}                                         //非常的简单明了
```

---

## 作者：吃葡萄吐糖 (赞：151)

翻了翻dalao们的代码，蒟蒻感到瑟瑟发抖（~~重载运算符是什么鬼啦~~）


其实这道题用二维数组做高精会更好理解（也好打一些），奇怪为啥没这么打的（当然啦，有一点点浪费空间（也就2M？））


首先我们发现，**求的是1到n所有阶乘的和，而阶乘又有递归写法（n!=(!n\*n）)**


那么直接用递推一直推到！n，然后再把所有的都相加就可以了（当然是倒序存储）


关于进位：单个数组位置只存一个（其实可以多个）数位，乘了之后做操作的时候只需要判断当前位置是否是该行最后一位，如果是就++，那么它会一直循环到刚好合适为止。


代码如下（拒绝复制，共创和谐洛谷）

```c
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<string>
#include<vector>
#include<map>
#include<queue>
using namespace std;
int bor[52][10000];
int n;
int main()
{
    bor[0][0]=1;//每行0位是该行长度
    bor[0][1]=1;
    bor[1][0]=1;
    bor[1][1]=1;
    cin>>n;
    for(int i=2;i<=n;i++)
    {
        for(int r=1;r<=bor[i-1][0];r++)
        bor[i][r]=bor[i-1][r]*i;//求阶乘
        bor[i][0]=bor[i-1][0];
        for(int k=1;k<=bor[i][0];k++)
        {
            if(bor[i][k]>9){
                if(k==bor[i][0])bor[i][0]++;//用这种方法消除进位的问题
                bor[i][k+1]+=bor[i][k]/10;
                bor[i][k]%=10;
            }
        }
    }
    for(int i=1;i<=n;i++)
    for(int r=1;r<=bor[n][0];r++)
    bor[n+1][r]+=bor[i][r];//所有的相加
    bor[n+1][0]=bor[n][0];
    for(int k=1;k<=bor[n+1][0];k++)
    {
        if(bor[n+1][k]>9){
            if(k==bor[n+1][0])bor[n+1][0]++;//同上
                bor[n+1][k+1]+=bor[n+1][k]/10;
                bor[n+1][k]%=10;
        }
    }
    for(int i=bor[n+1][0];i>0;i--)
    cout<<bor[n+1][i];//倒序输出，完成
    return ;
}

```

---

## 作者：qieqiemin (赞：135)

emmmmm
这种高精度的题目，用C++来写真是耗费头脑，用Java来写的话，需要用大数类，我观察了一下没几个用python3来写的，那么干脆我用最简短代码上吧
，思路很简单，这题考察到高精度。
看代码吧


```python
n=eval(input())        #输入一个数字n，记得要用eval(),不然输入的是字符串
ans=0         #定义一个数，用来保存答案
for i in range(1,n+1):     #从1到n来算阶乘
    d=1       #阶乘值初始化为1
    for j in range(1,i+1):
        d*=j       #简单的阶乘算法
    ans+=d        #每次都加进去
print(ans)        #输出答案

```

---

## 作者：LJC00118 (赞：104)

---一道很水的题，高精度就能解决，直接贴代码

---总体思路是a->xy，xy\*=y，xy->a，s->xy，xy+=a，xy->s



```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int a[100000],n,i,y,xy[100000],s[100000];//s[0]和a[0]表示两个数组的长度
//s表示答案，a表示阶乘，先算出阶乘，放在a里，再把s和它相加，更新s
void add()//表示s=s+a
{
    int i;
    memset(xy,0,sizeof(xy));//xy为辅助数组，先将a+s放入xy，再将s更新为xy
    xy[0]=max(s[0],a[0]);//更长的为xy数组长度
    for (i=1;i<=xy[0];i++)
    {
        xy[i]+=s[i]+a[i];//将每一位相加
        xy[i+1]=xy[i]/10;//进位
        xy[i]%=10;//进位
     }
    while (xy[xy[0]+1]>0) //进位
        {
            xy[xy[0]+2]=xy[xy[0]+1]/10;
            xy[xy[0]+1]%=10;
            xy[0]++;
        }
    s[0]=xy[0];//长度也要更新
    for (i=1;i<=xy[0];i++) s[i]=xy[i];//将xy给s
}
int main()//愉快的开始了主程序
{
    cin>>n;
    a[0]=1;//将数组初值赋好
    a[1]=1;//这里一定要是1，不然算阶乘的时候一直为0
    s[0]=1;
    s[1]=0;
    for (y=1;y<=n;y++) //这里是高精度乘法
    {
        memset(xy,0,sizeof(xy));//xy为辅助数组，先将a+s放入xy，再将s更新为xy
        xy[0]=a[0];
        for (i=1;i<=a[0];i++)
        {
          xy[i]+=a[i]*y;//算阶乘
          xy[i+1]=xy[i]/10;//进位
          xy[i]%=10;
        }
        while (xy[xy[0]+1]>0)//进位 
        {
            xy[xy[0]+2]=xy[xy[0]+1]/10;
            xy[xy[0]+1]%=10;
            xy[0]++;
        }
        for (i=1;i<=xy[0];i++) a[i]=xy[i];//算出y！放入a内
        a[0]=xy[0];
        add();//进行高精度加法
    }
    for (i=s[0];i>=1;i--) cout<<s[i];//输出
    cout<<endl;//换行
    return 0;//愉快的结束了主程序
}
```

---

## 作者：Sinwind (赞：82)

# 1.分析

0. 高精度算法：有时有的数会太大，甚至超过了$long\space long$的范围$(2^{63}-1\approx9\times10^{18})$，此时需要用字符串$(string$型或$char$型数组$)$来存储数字，运算时需要特殊的算法进行运算，称为高精度算法。高精度算法本质上是**模拟数字的运算**。

1. 对于本题来说，
$$S=\sum_{i=1}^ni!$$
需要的高精度算法可以分解为加法，乘法$($用到加法$)$，阶乘$($用到乘法$)$，阶乘求和$($用到阶乘与加法$)$。具体如下$(\downarrow)$。

# 2.代码

```cpp
#include <iostream>
#include <string>

using namespace std;

int num;    		//输入的数
string ans;         //输出的数

//高精度加法
string ADD(string a, string b)
{
	string result;  //结果

	//将较大的数赋值给a，较小的数赋值给b
	if(b.length() > a.length())
	{
		string temp = a;
		a = b;
		b = temp;
	}
	int a_len = a.length();
	int b_len = b.length();
	//b补足零，方便计算
	for(int i = 0; i < a_len - b_len; i++)
	{
		b = '0' + b;
	}

	int num;        //本位
	int up = 0;     //进位
    //模拟加法
	for(int i = a_len - 1; i >= 0; i--)
	{
		int num = (a[i] - '0') + (b[i] - '0') + up;
		up = num / 10;
		num %= 10;
		result = (char)(num + '0') + result;
	}
    //若仍有进位，加上进位
	if(up)
	{
		result = (char)(up + '0') + result;
	}

	return result;
}

//高精度乘法
string MUL(string a, string b)
{
	string result;	//结果
	int a_len = a.length();
	int b_len = b.length();
	int num;        //本位
	int up = 0;		//进位
    //模拟乘法
	for(int i = a_len - 1; i >= 0; i--)
	{
 		string temp;
		for(int j = b_len - 1; j >= 0; j--)
        {
        	num = (a[i] - '0') * (b[j] - '0') + up;
			up = num / 10;
			num %= 10;
			temp = (char)(num + '0') + temp;
        }
        //若仍有进位，加上进位，记得清零
        if(up)
        {
        	temp = (char)(up + '0') + temp;
        	up = 0;
		}
		//乘以每位的权重10^k
		for(int k = 0; k < (a_len - 1) - i; k++)
		{
			temp += '0';
		}
        result = ADD(result, temp);
	}

	return result;
}

//高精度阶乘
string FAC(int n)
{
	string result = "1";

	for(int i = 1; i <= n; i++)
	{
    	//数字转化为字符串
		string a;
  		int temp = i;
		while(temp)
		{
			a = (char)(temp % 10 + '0') + a;
			temp /= 10;
		}
		result = MUL(result, a);
	}

	return result;
}

int main(void)
{
	cin >> num;

	for(int i = 1; i <= num; i++)
	{
		ans = ADD(ans, FAC(i));
	}

	cout << ans;

	return 0;
}
```


---

## 作者：zhangboju (赞：53)

看不懂大佬的题解 于是来一个
简单的

刚拿到这个题时，我一看难度“普及-”

于是就想直接阶乘

交了才发现 天真的我TLE了


------------
后来机房一c性大佬走了过来：

“其实算阶乘和可以用一个简单的方法，将公式变形：


>$$S=1*(1+2*(1+3*(1+4*(......1+(n-1)*(1+n)))$$


------------
于是一切就好办了

~~神犇们不要在意~~

------------

这个代码避免了高精加 只有一个高精乘和一个加1进位

~~（其实可以用递归 但我太懒没用）~~

一开始我没用倒序就WA了

但用了倒序之后就可AC

~~每个点也就3ms~~

~~（没有用优化）~~

------------
# 代码见下


------------


 ```cpp
 #include <bits/stdc++.h>
using namespace std;
int a[10000],k=1,n;
int main()
{
    cin>>n;
    for(int i=n;i>=1;i--)
    {
            a[1]++;
            for(int j=1;j<=a[0];j++)
            {
                a[j+1]+=a[j]/10;
                a[j]%=10;
            }
            if(a[a[0]+1]>0)
            {
                a[0]++;
            }
            for(int j=1;j<=a[0];j++)
            {
                a[j]*=i;
            }
            for(int j=1;j<=a[0];j++)
            {
                a[j+1]+=a[j]/10;
                a[j]%=10;
            }
            int x=a[0]+1;
            if(a[x]>0)
            {
                while(a[x]>10)
                {
                    a[x+1]=a[x]/10;
                    a[x]%=10;
                    x++;
                }
                a[0]=x;
            }
        }
        for(int i=a[0];i>=1;i--)
        {
            cout<<a[i];
        }

 }

```


---

## 作者：yjjr (赞：38)

阶乘=连续不断的乘法

阶乘和=多个连续不断的乘法的和

Step1
利用高精度乘法（需要修改）反复累乘（一次性）

进行每个阶乘的处理

存放在数组内

Step2
重复用高精度加法累加出ans

代码如下(pascal)

```delphi

(const max=10000;
var 
 i,j,n:longint;
 sum,fac:array[1..10001] of longint;
 
begin
 read(n);
 for i := 1 to max do sum[i]:=0;
 for i := 1 to max do fac[i]:=0;
 fac[1] := 1;
 for i := 1 to n do begin
  for j := 1 to max do fac[j] := fac[j]*i;
   for j := 1 to max do begin
      fac[j+1]:=fac[j+1]+fac[j] div 10;
      fac[j]:=fac[j] mod 10;
    end;
    for j:=1 to max do sum[j] := sum[j]+fac[j];
    for j:=1 to max do begin
     sum[j+1] := sum[j+1]+sum[j] div 10;
     sum[j] := sum[j] mod 10;
    end;
   end;
 i := max;
 while sum[i]=0 do i := i-1;
 for j := i downto 1 do write(sum[j]);
end.)

```(pascal)

---

## 作者：NaCly_Fish (赞：36)

来水一篇时间复杂度 $\Theta(\sqrt n \log n)$ 的做法。  
当然现在只能模意义下做到，所以对于这题没啥用（

可以使用类似 [快速计算阶乘](https://www.luogu.com.cn/problem/P5282) 的做法，设
$$f_d(x)=\sum_{i=1}^d \prod_{j=1}^i(x+j)$$
$$g_d(x)=\prod_{i=1}^d(x+i)$$
那么显然有
$$x!f_d(x)=\sum_{i=1}^d(x+i)!$$
那么现在就可以对 $f_d(x)$ 的点值倍增了
$$f_{2d}(x)=\sum_{i=1}^d\prod_{j=1}^i(x+j) +\sum_{i=d+1}^{2d}\prod_{j=1}^{i}(x+j)$$
$$f_{2d}(x)=f_d(x)+\sum_{i=1}^{d}\prod_{j=1}^{d+i}(x+j)$$
$$f_{2d}(x)=f_d(x)+\left(\prod_{j=1}^d(x+j) \right)\sum_{i=1}^d\prod_{j=d+1}^{d+i}(x+j)$$
$$f_{2d}(x)=f_d(x)+g_d(x)f_d(x+d)$$
别忘了同时还要倍增计算 $g_d(x)$ 的点值。

设 $s = \lfloor \sqrt n \rfloor$，计算出 $f_s(sk) \ (k \in[0,s-1])$ 的值，再乘上面少算的阶乘就是答案。   
当然后面可能有一小段没算，暴力即可。

代码就不给了，会快速阶乘应该很容易能写出来（

---

## 作者：IntrepidStrayer (赞：25)

<!--首篇题解，大佬勿喷-->
## 低精阶乘和：
```
int s=0,t=1;
for(int i=1;i<=n;i++){
  t*=i;
  s+=t;
}
```


------------

## 高精度：
高精度阶乘和的原理和低精阶乘和一样，只需要写几个数组和函数：
### 加法：
```
void add(){
    int i=0,x=0;
    while(i<=src_l||i<=v_l){
        i++;
        src[i]+=x+v[i];
        x=src[i]/10;
        src[i]%=10;
    }
    if(x)src[++i]=x;
    if(i>src_l)src_l=i;
}
```

### 乘法：
```
void mut(int arg){
    int i=1,x=0;
    while(i<=v_l){
        v[i]=v[i]*arg+x;
        x=v[i]/10;
        v[i]%=10;
        i++;
    }
    while(x){
        v[++v_l]=x%10;
        x/=10;
    }
}

```


------------

## 下面给出代码：
```cpp
#include<cstdio> 
#include<cstring> 
int src[1001],v[1001],src_l=1,v_l=1;
void add(){
    int i=0,x=0;
    while(i<=src_l||i<=v_l){
        i++;
        src[i]+=x+v[i];
        x=src[i]/10;
        src[i]%=10;
    }
    if(x)src[++i]=x;
    if(i>src_l)src_l=i;
}
void mut(int arg){
    int i=1,x=0;
    while(i<=v_l){
        v[i]=v[i]*arg+x;
        x=v[i]/10;
        v[i]%=10;
        i++;
    }
    while(x){
        v[++v_l]=x%10;
        x/=10;
    }
}
int main(){
    int i,n;
    scanf("%d",&n);
    memset(src,0,sizeof(src));
    memset(v,0,sizeof(v));
    src[1]=v[1]=1;
    for(i=2;i<=n;i++){
        mut(i);
        add();
    }
    while(src[src_l]==0)src_l--;
    for(i=src_l;i>=1;i--)
       printf("%d",src[i]);
    return 0;
}
```


  

---

## 作者：谁懂谁伤心 (赞：25)

比较科学的高精。将两数存入数组，像竖式计算进行高精计算，每计算完一个数的阶乘高精加入另一个数组即可。

```cpp
#include <iostream>    
#include <cstring>    
using namespace std;    
int az[100],bz[100],q,k;  
int main()    
{    
cin >>q; az[0]=1;  
for (int y=1;y<=q;y++){for (int p=1;p<=y;p++){for (int i=0;i<99;i++)    
az[i]*=p;   
for (int u=0;u<99;u++)if (az[u]>9){az[u+1]+=az[u]/10;az[u]%=10;}}   
for (int i=0;i<100;i++)    
{bz[i]+=az[i]; if (bz[i]>9){bz[i+1]++;bz[i]-=10;} az[i]=0;}    
az[0]=1;  
}  
for (int i=99;i>0;i--) {if (bz[i]==0&&k==0)continue; k=1; cout <<bz[i];}    
cout <<bz[0];    
return 0;    
} 
```

---

## 作者：Delva (赞：23)

看了这么多C++题解，偶尔也来一篇java版娱乐题解
```java
import java.util.*;
import java.math.*;
public class Main{
    private static BigInteger[] bis = new BigInteger[53];
    private static BigInteger res = new BigInteger("1");
    public static void main(String args[]){
        Scanner scan = new Scanner(System.in);
		int n = 0;
        try{
			n = scan.nextInt();//输入
		}catch(Exception e){}
        bis[1] = new BigInteger("1");
        for(int i=2;i<=n;++i)
            bis[i] = bis[i-1].multiply(new BigInteger(String.valueOf(i)));//阶乘表
        for(int i=2;i<=n;++i)
            res = res.add(bis[i]);//累加
        System.out.println(res);
    }
}
```

---

## 作者：影のない霜跡 (赞：22)

第一次写高精乘法的题解...

#### 一般在写高精题目的时候，我会先写一个不带高精的程序，过了样例后，我再把高精模板套上去，就可以AC了。

在这里先展示一下不带高精的程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,anss;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        anss=1;
        for(int j=1;j<=i;j++)anss=anss*j;
        ans=ans+anss;
    }
    cout<<ans;
    return 0;
}
```
过了样例后，再把结构体，函数套上去就可以了。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{
    int len;
    int s[1005];
};
data ans,anss;
int n;
data mul(data x,int y)
{
    data c;
    for(int i=1;i<=1000;i++)c.s[i]=0;
    for(int i=1;i<=x.len;i++)
    {
        c.s[i]+=x.s[i]*y;
        c.s[i+1]=c.s[i]/10;
        c.s[i]=c.s[i]%10;
    }
    int lan=x.len;
    while(c.s[lan+1]>0)
    {
        lan++;
        c.s[lan+1]+=c.s[lan]/10;
        c.s[lan]=c.s[lan]%10;
    }
    c.len=lan;
    return c;
}
data add(data x,data y)
{
    data c;
    for(int i=1;i<=1000;i++)c.s[i]=0;
    int lan=max(x.len,y.len);
    for(int i=1;i<=lan;i++)
    {
        c.s[i]+=x.s[i]+y.s[i];
        c.s[i+1]+=c.s[i]/10;
        c.s[i]=c.s[i]%10;
    }
    if(c.s[lan+1]>0)lan++;
    c.len=lan;
    return c;
}
int main()
{
    cin>>n;
    for(int i=1;i<=1000;i++)ans.s[i]=0;
    ans.len=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=1000;j++)anss.s[j]=0;
        anss.s[1]=1;
        anss.len=1;
        for(int j=1;j<=i;j++)anss=mul(anss,j);
        ans=add(ans,anss);
    }
    for(int i=ans.len;i>=1;i--)cout<<ans.s[i];
    return 0;
}
```

---

## 作者：栾隽沣 (赞：21)

## 这道题em......第一眼：
------------
# 好简单！！！！
c++建造一个函数不就行了？
C++代码如下：
```cpp
#include<bits/stdc++.h>//神犇万能头
using namespace std;
long long FA(int a){//定义阶乘函数，在此求出每个数的阶乘 
	long long b=1;//定义变量 	
	for(int i=1;i<=a;i++)//计算阶乘 	   
	b*=i;	
	return b;//返回值 
} 
int main(){	
	long long ans=0,n;//定义变量 	
	cin>>n;//输入n 	
	for(int i=1;i<=n;i++)//计算每个数的阶乘的和 
    	    	ans+=FA(i);	
	cout<<ans;//输出 	
	return 0;
}
```

~~然后，就悲剧了~~
![](https://cdn.luogu.com.cn/upload/image_hosting/gua99oie.png)

50？？？

我注释写的我看的都满意，怎么回事？？？

再回去读一遍题：不对，超出范围了

**50! > 2^64-1**

### 诶，不行，我还不会高精度

没办法，只能用Python，自带高精

~~这个要是一个一个乘再加，得累die~~，先写一个阶乘的函数：
```python
def jc(shu):#接受实参，定义阶乘函数
    ans = 1
    for i in range(1,shu+1):#循环 左开右和
        ans*=i
    return ans#返回shu的阶乘
```
然后，就简单了：
读入加循环调用函数
下面呈上完整**python**代码:
```python
def jc(shu):
    ans = 1
    for i in range(1,shu+1):
        ans*=i
    return ans
num = 0#计数器初始化
a = int(input())
for i in range(1,a+1):
    num+=jc(i)#计算函数阶乘返回值求和
print(num,end = "")#输出
```
本次题解到此结束
### 还有一件事
### 有哪位奆佬
## 可以教教我高精啊
# 人生苦短，我用python


---

## 作者：xyqxyq (赞：21)

Python真的好用，如果还懒得看高精度的话，我们可以直接用python在IDLE里面把所有的数字打出来，然后在c++里面直接查询输出就可以了。
#### python
```python
sum=1
i=2
last=1
out="cin"
print(out)
n=int(input())
print(n)
while i<=n:
    last*=i
    sum+=last
    i+=1                 
    print('"',end='')
    print(sum,end='')
    print('",')

```
#### C
```cpp
#include <iostream>
#include <string>
using namespace std;
string C[100] = {
	"0",
	"1",
	"3",
	"9",
	"33",
	"153",
	"873",
	"5913",
	"46233",
	"409113",
	"4037913",
	"43954713",
	"522956313",
	"6749977113",
	"93928268313",
	"1401602636313",
	"22324392524313",
	"378011820620313",
	"6780385526348313",
	"128425485935180313",
	"2561327494111820313",
	"53652269665821260313",
	"1177652997443428940313",
	"27029669736328405580313",
	"647478071469567844940313",
	"16158688114800553828940313",
	"419450149241406189412940313",
	"11308319599659758350180940313",
	"316196664211373618851684940313",
	"9157958657951075573395300940313",
	"274410818470142134209703780940313",
	"8497249472648064951935266660940313",
	"271628086406341595119153278820940313",
	"8954945705218228090637347680100940313",
	"304187744744822368938255957323620940313",
	"10637335711130967298604907294846820940313",
	"382630662501032184766604355445682020940313",
	"14146383753727377231082583937026584420940313",
	"537169001220328488991089808037100875620940313",
	"20935051082417771847631371547939998232420940313",
	"836850334330315506193242641144055892504420940313",
	"34289376947494122614363304694584807557656420940313",
	"1439295494700374021157505910939096377494040420940313",
	"61854558558074209658512637979453093884758552420940313",
	"2720126133346522977702138448994068984204397080420940313",
	"122342346998826717539665299944651784048588130840420940313",
	"5624964506810915667389970728744906677010239883800420940313",
	"264248206017979096310354325882356886646207872272920420940313",
	"12678163798554051767172643373255731925167694226950680420940313",
	"620960027832821612639424806694551108812720525606160920420940313",
	"31035053229546199656252032972759319953190362094566672920420940313",
};

int main()
{
	int n;
	cin >> n;
	cout << C[n] << endl;
	return 0;
}

```


---

## 作者：Bean233 (赞：16)

复习一遍紫书的大整数类，真是便利呢


```cpp
#include <iostream>  
#include <algorithm> 
#include <cassert>   
#include <cstdio>    
#include <cstring>   
#include <string>    
#include <vector>    
using namespace std;
struct BigInteger {
    typedef unsigned long long LL;
    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector<int> s;
    BigInteger& clean(){while(!s.back()&&s.size()>1)s.pop_back(); return *this;}
    BigInteger(LL num = 0) {*this = num;}
    BigInteger(string s) {*this = s;}
    BigInteger& operator = (long long num) {
        s.clear();
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while (num > 0);
        return *this;
    }
    BigInteger& operator = (const string& str) {
        s.clear();
        int x, len = (str.length() - 1) / WIDTH + 1;
        for (int i = 0; i < len; i++) {
            int end = str.length() - i*WIDTH;
            int start = max(0, end - WIDTH);
            sscanf(str.substr(start,end-start).c_str(), "%d", &x);
            s.push_back(x);
        }
        return (*this).clean();
    }
    BigInteger operator + (const BigInteger& b) const {
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = g;
            if (i < s.size()) x += s[i];
            if (i < b.s.size()) x += b.s[i];
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c;
    }
    BigInteger operator - (const BigInteger& b) const {
        assert(b <= *this);
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = s[i] + g;
            if (i < b.s.size()) x -= b.s[i];
            if (x < 0) {g = -1; x += BASE;} else g = 0;
            c.s.push_back(x);
        }
        return c.clean();
    }
    BigInteger operator * (const BigInteger& b) const {
        int i, j; LL g;
        vector<LL> v(s.size()+b.s.size(), 0);
        BigInteger c; c.s.clear();
        for(i=0;i<s.size();i++) for(j=0;j<b.s.size();j++) v[i+j]+=LL(s[i])*b.s[j];
        for (i = 0, g = 0; ; i++) {
            if (g ==0 && i >= v.size()) break;
            LL x = v[i] + g;
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c.clean();
    }
    BigInteger operator / (const BigInteger& b) const {
        assert(b > 0);
        BigInteger c = *this;
        BigInteger m;
        for (int i = s.size()-1; i >= 0; i--) {
            m = m*BASE + s[i];
            c.s[i] = bsearch(b, m);
			m -= b*c.s[i];
        }
        return c.clean();
    }
    BigInteger operator % (const BigInteger& b) const {
        BigInteger c = *this;
        BigInteger m;
        for (int i = s.size()-1; i >= 0; i--) {
            m = m*BASE + s[i];
            c.s[i] = bsearch(b, m);
            m -= b*c.s[i];
        }
        return m;
    }
    int bsearch(const BigInteger& b, const BigInteger& m) const{
        int L = 0, R = BASE-1, x;
        while (1) {
            x = (L+R)>>1;
            if (b*x<=m) {if (b*(x+1)>m) return x; else L = x;}
            else R = x;
        }
    }
    

ostream& operator << (ostream& out, const BigInteger& x) {
    out << x.s.back();
    for (int i = x.s.size()-2; i >= 0; i--) {
        char buf[20];
        sprintf(buf, "%08d", x.s[i]);
        for (int j = 0; j < strlen(buf); j++) out << buf[j];
    }
    return out;
}
istream& operator >> (istream& in, BigInteger& x) {
    string s;
    if (!(in >> s)) return in;
    x = s;
    return in;
}
int main()
{
	int n;
	cin >> n;
	BigInteger ans=0,s=1;
	for(register int i=1;i<=n;i++)
	{
        s *= i;
        ans += s;
    }
	cout << ans << endl;
	return 0;
}
```

采用压位操作，速度是正常的8倍

---

## 作者：ZHRRRRRR (赞：14)

没人用JavaBigInteger函数吗？

主要功能
```java
package ustc.lichunchun.bigdataapi;

import java.math.BigInteger;

public class BigIntegerDemo1 {

	public static void main(String[] args) {
		BigInteger bi1 = new BigInteger("123456789") ;	// 声明BigInteger对象
		BigInteger bi2 = new BigInteger("987654321") ;	// 声明BigInteger对象
		System.out.println("加法操作：" + bi2.add(bi1)) ;	// 加法操作
		System.out.println("减法操作：" + bi2.subtract(bi1)) ;	// 减法操作
		System.out.println("乘法操作：" + bi2.multiply(bi1)) ;	// 乘法操作
		System.out.println("除法操作：" + bi2.divide(bi1)) ;	// 除法操作
		System.out.println("最大数：" + bi2.max(bi1)) ;	 // 求出最大数
		System.out.println("最小数：" + bi2.min(bi1)) ;	 // 求出最小数
		BigInteger result[] = bi2.divideAndRemainder(bi1) ;	// 求出余数的除法操作
		System.out.println("商是：" + result[0] + 
			"；余数是：" + result[1]) ;
	}
}
```

代码（没什么难度，注意BigInteger不是自增的！！！）：
```java

import java.util.*;
import java.math.*;

public class Main {
    static BigInteger jc(int n) {
        BigInteger i=new BigInteger("1");
        for (int j=2;j<=n;j++) i=i.multiply(new BigInteger(Integer.toString(j)));
        return i;
    }
    public static void main(String[] args) {
        Scanner scan=new Scanner(System.in);
        int n=scan.nextInt();
        scan.close();
        BigInteger sum=new BigInteger("0");
        for (int i=1;i<=n;i++) sum=sum.add(jc(i));
        scan.close();
        System.out.println(sum);
    }
}

```



---

## 作者：HarryHu (赞：13)

作为一个连高精度乘法都要写半天的人，还要我求和？看到这题目的我果断拒绝啊……

虽然说高精度不是很难 但是我懒 所以我找到了一种

#不用写加法的办法


##已知 S=1!+2!+…+n!


```cpp
##       =1+1×2+1×2×3+…+1×2×3×…×n
##       =1×(1+2+2×3+…+2×3×…×n) 
##       =1×(1+2×(1+3+3×4+…+3×4×…×n))
##       =………………………………
##       =1*(1+2×(1+3×(1+4×(…1+(n-1)×(1+n)…))))   
```
比如n=3的时候
S=1+1×2+1×2×3=1×(1+2×(1+3))=1×(1+2×4)=9 

可以验证这个公式的正确性

所以可以先做ans=n(\_用i控制\_)\*1+1，然后×(n-1)再加1,再×(n-1)再加1,再×(n-1)再加1,再×(n-1)再加1……


所以代码：

```pascal
  for i:=n downto 1 do
    begin
      mul(i,ans);//高精度乘法
      inc(ans[1]);//加1（想一想这会不会导致ans[1]超过十？会不会有什么影响？）
    end;
  dec(ans[1]);   //pay attention 最后你多加了一个一要减掉
```
至于高精度乘法怎么写，百度一下，你就知道。


---

## 作者：HohleFeuerwerke (赞：8)

#### 前言

[题目](https://www.luogu.com.cn/problem/P1009)在此。

幸好这题还能发题解，赶紧凑一发。

本题是一道基本的高精度题目，或者可以称之为字符串模拟题。

翻了翻题解区，大家好像没有人像我这样用了一个记忆化搜索（？？？）。所以就过来讲讲。

#### 正文

一看，要求的是：
$$f[n]=\sum_{i=1}^nn!$$

一看，阶乘，不是可以递推吗？

但是因为这道题是高精度题，所以反而记忆化搜索相比普通的递推更加好写。

因为 $n\leq 50$，所以我们需要维护的高精度乘法其实只需要两位数（用于已经得到的阶乘结果与下一项相乘），其实就是高精度乘上低精度的半高精度乘法，不需要正宗的高精度乘法来维护。

所以上手一个半高精度乘法和一个高精度加法（用于维护已经得到的 $x!$ 和已经得到的 $f[x-1]$ 进行相加）。

然后就是记忆化搜索部分了，这部分很好写。

直接贴代码（有详细注释），写的很长但是很好理解：

```cpp
#include<bits/stdc++.h>
#define MAXN 55
using namespace std;
typedef long long ll;
ll n;//含义如题
string frac[MAXN];//已经得到的之前留下的结果
bool visit[MAXN];//是否访问过

//接下来一大段都是高精度加法，主要是模拟了竖式计算的方法。
string add(string a,string b){//高精度加法
	string ret;//返回值
	ll lenga=a.length(),lengb=b.length();//两数位数
    //接下来一段都是在补前导零
	if(lenga>lengb){//如果a位数比b大
		string zeros;//前导零字符串
		for(ll i=1;i<=lenga-lengb;i++) zeros+="0";//有lenga-lengb个前导零
		b=zeros+b;//补在b前面，这时a与b位数一样大
	}
	else if(lenga<lengb){//如果b位数比a大
		string zeros;//前导零
		for(ll i=1;i<=lengb-lenga;i++) zeros+="0";//有lengb-lenga个前导零
		a=zeros+a;//补在a前面
	}
    //前导零到这里才算补完
	bool flag=false;//是否进位
	for(ll i=max(lenga,lengb)-1;i>=0;i--){
		int x=a[i]+b[i]-'0'*2;//当前位时，a+b的值
		if(flag) flag=false,x++;//如果前一位的x大于10即这一位需要进位，那么先去除进位标记，再将当前位加1
		if(x>=10) flag=true,x-=10;//如果得到的当前位的值大于等于10那么需要进位，打上进位标记，再将当前位减去10
        //特别需要主义的是必须先判断上一位的进位再判断这一位的进位，否则可能这一位的x值为9，进位后得到的变为10，需要向前一位继续进1
		char c=x+'0';//得到这一位的char类型
		ret=c+ret;//将其补在前面
	}
	if(flag) ret="1"+ret;//如果最高位仍然进位，在最前面补1
	return ret;//返回结果
}
//高精度加法结束
//下面是半高精度乘法
string mul(string str,ll m){
	string ret;//返回值
	ll lengstr=str.length();//高精度数的长度
	if(m<10){//如果低精度数小于10，那么可以一重循环完成计算。
		ll x=0;//当前位的值
		ll flag=0;//由于是乘法，不像加法只可能进一，乘法可能进位更多
		for(ll i=lengstr-1;i>=0;i--){
			x=(str[i]-'0')*m;//计算当前位
			x+=flag;flag=x/10;x%=10;//这三步是将上一次遗留下来的进位，这次的进位，这次的当前位给计算出来
			char c=x+'0';//得到当前位的char类型
			ret=c+ret;//将其补在前面
		}
		if(flag!=0){//如果最高位仍然需要进位
			char c=flag+'0';//得到需要进位的char类型
			ret=c+ret;//补在前面
		}
		return ret;//返回
	}
    //但是仍然没有做完，因为只计算了一数小于10的情况。
	else if(m==10) return str+"0";//如果正好是10，直接在后面补一个0就好惹
	else{
		ll u=m/10,v=m%10;//由于是两位数，所以u和v都是一位数，u是这个两位数的十位，v是两位数的个位。
		return add(mul(mul(str,u),10),mul(str,v));//计算这个大数乘上u乘上10再加上这个大数乘上v的结果，就是这个大数乘上m的结果。
	}
}
//半高精度乘法结束
//下面是记忆化搜索
string f(ll x)//递归函数，名字很难听
{
	if(visit[x]) return frac[x];//如果已经有值，返回上次保存的那个值。
	if(x==1) return "1";//如果是1返回1
	if(x==2) return "3";//如果是2返回3，这两个数都是手动计算出来的
	string ret="1";//返回值 
	visit[x]=true;//先打上标记，下次访问可以直接用这个值。
	for(int i=1;i<=x;i++) ret=mul(ret,i);//计算阶乘，当前返回值乘上i，随着i的变化ret也变为x的阶乘，这也是ret初始化为1的原因。
	ret=add(ret,f(x-1));//ret得到的x的阶乘需要与x-1得到的结果相加。
	frac[x]=ret;//保存值，以便下次使用。
	return ret;//返回
}
//以下内容都十分的简单
//就是基本上只包含读入和输出的一个主函数
int main()
{
	ios::sync_with_stdio(false);
	cout.tie(0);cin.tie(0);
    //前面两行是读入输出优化
	cin>>n;//读入n
	cout<<f(n)<<endl;//输出结果
	return 0;
}
```

就这样，这题很适合刚刚上手高精度的同学做做。

---

## 作者：墨宇 (赞：7)

中英对照！负责任的墨宇：

English and Chinese! Responsible Moyu:

oh my God!又是一个史前新题目  ~~好像矛盾了~~

Oh my God! Another new prehistoric topic   ~~seems contradictory~~

又是高精度！又是阶乘！

It's high precision again! It's factorial again!

首先，让我们来看看不用高精度的写法：

First of all, let's take a look at writing without high precision.

```cpp
int jie(int n)
{
	int res = 1;

	if (n == 0)
		return 0;

	for (int i=n; i > 0; i--)
	{
		res *= i;
	}

	return res;
}
```
~~我不甘心！ 为什么？WORNG！~~

~~I'm not reconciled! Why? WORNG!~~

~~墨宇扶眼镜：“高精度。”~~

~~Moyu Fuse Glasses: "High Precision."~~

呵呵，啥事也没有，呵呵。

接下来，看看偶的偶像：刘汝佳
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562320772105&di=ff8629e4106d9435e4b4ffe541b48412&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fbaike%2Fpic%2Fitem%2F2e6fa7385853e3d4d562253f.jpg)

是不是很风流倜傥、风度翩翩、玉树临风、气度不凡、气宇不凡、温文尔雅、俊美无涛、英俊潇洒、面如冠玉、一表人才、仪表不凡、仪表堂堂 、丰神俊秀、文质彬彬？

觉得是不是很潇洒、英俊、阳刚、帅气、英俊、妖孽、男神？

废话不多说（其实说了很多）
别抄袭呦！
```cpp
//copyright(c)2019 RuJia Liu
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
const int maxn = 500;
using namespace std;
struct BigInteger {
	int len, s[maxn];

	BigInteger() {
		memset(s, 0, sizeof(s));
		len = 1;
	}

	BigInteger(int num) {
		*this = num;
	}

	BigInteger(const char* num) {
		*this = num;
	}

	BigInteger operator = (int num) {
		char s[maxn];
		sprintf_s(s, maxn, "%d", num);
		*this = s;
		return *this;
	}

	BigInteger operator = (const char* num) {
		len = strlen(num);
		for (int i = 0; i < len; i++)
			s[i] = num[len - i - 1] - '0';
		return *this;
	}

	string str() const {
		string res = "";
		for (int i = 0; i < len; i++)
			res = (char)(s[i] + '0') + res;
		if (res == "")
			res = "0";
		return res;
	}

	BigInteger operator + (const BigInteger& b) const {
		BigInteger c;
		c.len = 0;
		for (int i = 0, g = 0; g || i < max(len, b.len); i++) {
			int x = g;
			if (i < len)
				x += s[i];
			if (i < b.len) x += b.s[i];
			c.s[c.len++] = x % 10;
			g = x / 10;
		}
		return c;
	}

	void clean() {
		while (len > 1 && !s[len - 1])
			len--;
	}

	BigInteger operator * (const BigInteger& b) const {
		BigInteger c; c.len = len + b.len;
		for (int i = 0; i < len; i++)
			for (int j = 0; j < b.len; j++)
				c.s[i + j] += s[i] * b.s[j];
		for (int i = 0; i < c.len - 1; i++) {
			c.s[i + 1] += c.s[i] / 10;
			c.s[i] %= 10;
		}
		c.clean();
		return c;
	}

	BigInteger operator - (const BigInteger& b) const {
		BigInteger c; c.len = 0;
		for (int i = 0, g = 0; i < len; i++) {
			int x = s[i] - g;
			if (i < b.len)
				x -= b.s[i];
			if (x >= 0)
				g = 0;
			else {
				g = 1;
				x += 10;
			}
			c.s[c.len++] = x;
		}
		c.clean();
		return c;
	}

	bool operator < (const BigInteger& b) const {
		if (len != b.len) return len < b.len;
		for (int i = len - 1; i >= 0; i--)
			if (s[i] != b.s[i])
				return s[i] < b.s[i];
		return false;
	}

	bool operator > (const BigInteger& b) const {
		return b < *this;
	}

	bool operator <= (const BigInteger& b) const {
		return (b > * this);
	}

	bool operator >= (const BigInteger& b) const {
		return (b < *this);
	}

	bool operator == (const BigInteger& b) const {
		return !(b < *this) && !(*this < b);
	}

	bool operator != (const BigInteger& b) const {
		return !(*this == b);
	}

	BigInteger operator += (const BigInteger& b) {
		*this = *this + b;
		return *this;
	}

	BigInteger operator -= (const BigInteger& b) {
		*this = *this - b;
		return *this;
	}

	BigInteger operator *= (const BigInteger& b) {
		*this = *this * b;
		return *this;
	}

	BigInteger operator ++ (int) {
		*this = *this + 1;
		return *this;
	}

	BigInteger operator -- (int) {
		*this = *this - 1;
		return *this;
	}

	BigInteger operator ++ () {
		*this = *this + 1;
		return *this;
	}

	BigInteger operator -- () {
		*this = *this - 1;
		return *this;
	}
};

istream& operator >> (istream& in, BigInteger& x) {
	string s;
	in >> s;
	x = s.c_str();
	return in;
}

ostream& operator << (ostream& out, const BigInteger& x) {
	out << x.str();
	return out;
}

```

main 与 jie:

```cpp

BigInteger jie(BigInteger n)
{
	BigInteger res = 1;

	if (n == 0)
		return 0;

	for (BigInteger i(n); i > 0; i--)
	{
		res *= i;
	}

	return res;
}
int main()
{
	BigInteger n;
	cin >> n;
	BigInteger ans = 0;
	for (BigInteger i = 0; i < n+1; i++)
	{
		ans += jie(i);
	}
	cout << ans;
	return 0;
}

```

是不是很风流倜傥、风度翩翩、玉树临风、气度不凡、气宇不凡、温文尔雅、俊美无涛、英俊潇洒、面如冠玉、一表人才、仪表不凡、仪表堂堂 、丰神俊秀、文质彬彬？

觉得是不是很潇洒、英俊、阳刚、帅气、英俊、妖孽、男神？

和我一起当刘汝佳的铁杆粉吧！

---

## 作者：lihaonan (赞：6)

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=101;
int a[maxn+100],b[maxn+100],n,bj;//高精度数组开大点，防止运算溢出
int main()
{
    a[0]=b[0]=1;
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<=maxn;j++)
            b[j]*=i; // 利用i来确定阶层和
        for(int j=0;j<=maxn;j++)
        {
            if(b[j]>=10)//高精度求阶层
            {
                b[j+1]+=b[j]/10;
                b[j]%=10;
            }
        }
        for(int z=0;z<=maxn;z++)
        {
            a[z]+=b[z];//高精度求阶层和
           if(a[z]>=10)
           {
              a[z+1]+=a[z]/10;
              a[z]%=10;
            }
        }
    }
    for(int i=maxn-1;i>=0;i--)//去掉前导的零
        if(a[i]!=0)
        {
            bj=i;
            break;
        }
        for(int j=bj;j>=0;j--)
            printf("%d",a[j]);
            printf("\n");
        return 0;
}
```

---

## 作者：萌新天行健 (赞：6)

讲道理这题不难。。

有模板的直接上模板，没有的只能手划。。

考虑到阶乘可以复用，以及数字较小不会爆int，可以有个漂亮的解法。。

···cpp

```cpp
#include<cstdio>
int num[100]={1},l=1,ans[100]={1};
int main()
{
    int n,lc,i;
    scanf("%d",&n);
    for(int x=2;x<=n;x++)
    {
        for(i=lc=0;i<l;)
        {
            num[i]=num[i]*x+lc;
            lc=num[i]/10;
            num[i++]%=10;
            if(i==l&&lc)l++;
        }
        for(i=0;i<l;i++)ans[i]+=num[i];
    }
    for(int i=0;i<l;)
    {
        ans[i+1]+=ans[i]/10;
        ans[i++]%=10;
        if(i==l&&ans[i])l++;
    }
    for(int i=l-1;~i;i--)printf("%d",ans[i]);
}
···
```

---

## 作者：有毒的粽子 (赞：6)

最近学了函数，作业要求也有这题，就顺便一起做了，卡的比较久的是进位，用B数组储存时累加和也可能溢出，都需要进位。高精处理和函数调用都需要继续努力，加油！不过时间复杂度有点高……可能是O（n^3）?不太会看.

------------

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int A[2575]={0},B[2575]={0};
int b=1;
int zhi(int n)//值函数
{
    b*=n;
    n--;
    return n==0?b:zhi(n);
}
void jc(int n)//高精乘法
{
    int i;
    for(;n>0;n--)
    {
        for(i=0;A[i]!=0;i++);
        for(;i<=2570;i++)
        {
            A[i]*=n;
        }
        void jw(int A[]);
        jw(A);
    }
}
void jw(int A[])//处理进位
{
     int i;
     for(i=2570;i>=0;i--)
     {
         if(A[i]>9)
         {
             A[i-1]+=A[i]/10;
             A[i]%=10;
         }
     }
}
int main()
{
    int n,i,flag=0;
    long int sum=0;
    //printf("请输入1000以内的正整数");1000!大概是2568位
    scanf("%d",&n);
    if(n>0&&n<=12)//12以内是值函数
    {
        for(i=1;i<=n;i++)
        {
            sum+=zhi(i);
            b=1;
        }
    printf("%ld",sum);
    return 0;
    }
    void jc();
    void jw(int A[]);
    n++;
    while(n--)
    {
        memset(A,0,sizeof(A));
        A[2570]=1;
        jc(n);
        for(i=2570;i>=0;i--)
        {
            B[i]+=A[i];
            jw(B);
        }
    }
    B[2570]--;
    for(i=0;i<=2570;i++)
    {
        if(flag==0&&B[i]==0)
        {
            continue;
        }
        else
        {
            flag=1;
            printf("%d",B[i]);
        }
    }
    return 0;
}

```

---

## 作者：Guardian乄针尖 (赞：5)

我来发个最没技术含量的C语言的题解，通俗易懂；
数据太大，只能用数组模拟乘法竖式运算；
普通数组操作
```c
#include<stdio.h>
int zh(int x,int y[]);/*将数字反向写入数组内*/
int lg(int x[]);	/*返回数组长度*/
int cf(int x[],int y[],int z[]);/*模拟竖式乘法运算 x*y 答案在Z中*/
int zl(int x[]);/*整理结果，将大于等于10的数字 %10  并进1 模拟乘法运算（个位数相乘最高只能得出2位数）*/
int copy(int s[],int r[]);/*拷贝s到r内*/
int print(int aa[]);/*反向打印数组*/
int g0(int ww[]);/*数组归零*/
int main(){
	int n;
	int as1[100],a[100],b[100],c[100]; 
	g0(a);
	g0(b);
	g0(c);
	g0(as1);/*全体归零*/
	scanf("%d",&n);
	for(int i=n;i>1;i--){/*最外成循环仅提供需要进行阶乘的数*/
		g0(b);
		g0(c);
		b[0]=1; /*1Xi1*/
		for(int i1=2;i1<=i;i1++){/*内圈循环进行阶乘并给出结果*/
			g0(a);
			g0(c);/*双双归零，继续下一次乘法，上一次的结果已经拷贝到数组b中*/
			zh(i1,a);/*把i1分割放倒数组a中*/
			cf(a,b,c);/*aXb=c*/
			zl(c);
			copy(c,b);/*b=c*/
		}
		for(int r=0;r<lg(b);r++){/*将每个阶乘得来的结果加到数组as1中*/
			as1[r]+=b[r];
		}
	
		zl(as1);/*每个循环都整理得到的结果，谨防数组内存在>100的数字*/
}	
	as1[0]++;/*结果的个位数上+1,因为1没进行阶乘累加*/
 	print(as1);/*输出结果*/
} 
int zh(int x,int y[]){
	for(int i=0;;i++){
		y[i]=x%10;
		x/=10;
		if(x<1){
			break;
		}
	}
}
int cf(int x[],int y[],int z[]){
	for(int i=0;i<lg(x);i++){/*外圈循环代表乘法竖式的第二行*/
		for(int i1=0;i1<lg(y);i1++){/*内圈循环代表乘法竖式的第一行*/
			z[i1+i]+=x[i]*y[i1];/*首先是想x[0],y[0],z[0],分别代表x的个位上的数组、y的个位上的数字、z的个位上的数字*/
		}
	}
	zl(z);
}
int lg(int x[]){
	int i;
	for( i=65;i>=0;i--){
		if(x[i]!=0){
			break;
		}
	}
	return i+1;
}
int zl(int x[]){
	for(int q=0;q<lg(x);q++){
		if(x[q]>=10){
			x[q+1]+=(x[q]/10);
			x[q]=x[q]%10;
		}
	}
}
int copy(int s[],int r[]){
	for(int i=0;i<lg(s);i++ ){
		r[i]=s[i];
	}
}
int print(int aa[]){
	for(int i=lg(aa)-1;i>=0;i--){
		printf("%d",aa[i]);
	}
}
int g0(int ww[]){
	for(int i=0;i<100;i++){
		ww[i]=0;
	}
}
 
```


---

## 作者：Awar3ness (赞：5)

题解中没人用python啊，那我写一发~
```python
def fact(x):
    if x==0:
        return 1
    else:
        return fact(x-1)*x
n=input()
ans=0
for i in range(1,int(n)+1):
    ans+=int(fact(i));
print(int(ans))

```
python可以直接高精度~

---

## 作者：小风扇vv (赞：5)

超级垃圾蒟蒻发的题解，大牛如果不细心的话，估计可能是做不对的。。


其实这题的数据非常的水，就是考察高精度的一题。求阶乘用高精乘法，求和用高精加法就完了。可是这里需要压个位什么的就很讨厌了，我不知道怎么处理如果不压位的话怎么做进位。。所以我就压了四位。。很多大牛为什么只得五十分呢，那是因为有可能算出来的时候会有前导零，所以在输出的时候要加个判断。我就是这样AC了。。。orz。下面是本蒟蒻的代码：


```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int len=0,n,ans=0,len1=0;
long long a[1001]={0},b[1001]={0};
void jiecheng(int x)
{
  int d,r;
  d=0;
  for(int i=1;i<=len;i++)
  {
    r=a[i];
    a[i]=(a[i]*x+d)%10000;
    d=(r*x+d)/10000;
  }
  if(d!=0)
    a[++len]=d;
}
void jiafa(int k)
{
  int d,r;
  d=0;
  for(int i=1;i<=k;i++)
  {
    r=b[i];
    b[i]=(b[i]+a[i]+d)%10000;
    d=(r+a[i]+d)/10000;
  }
  if(d!=0)
  {
    b[++k]=d;
    len1=k+1;
  }
  else
    len1=k;
}
int main()
{
  //freopen("c.in","r",stdin);
  //freopen("c.out","w",stdout);
  cin>>n;
    len=1;a[1]=1;len1=0;
  for(int i=1;i<=n;i++)
  {
    memset(a,0,sizeof(a));
    a[1]=1;len=1;
    for(int j=1;j<=i;j++)
      jiecheng(j);
    if(len1>len)
      jiafa(len1);
    else
      jiafa(len);
  }
  for(int i=len1;i>=1;i--)
  {
    if(i!=len1)
      if(b[i]/1000==0)
        cout<<0;
    cout<<b[i];
  }
  return 0;
}

```

---

## 作者：zero4eva (赞：5)

笨人笨方法，写了个大整数加法子程序，直接调用

乘法就是循环调用= =

写完发现可以直接用int的。。

```cpp

#include <stdio.h>
#include <string.h>

char s[1000], t[1000], tmp[1000];

void BigAdd(char s[], char t[])
{
    char* p = s;
    char* q = t;
    
    int c=0;
    while ((*p)!='\0' && (*q)!='\0')
    {
        *p += *q+c-'0';
        c=0;
        if (*p > '9')
        {
            *p -= 10;
            if (*(p+1)=='\0') *(p+1)='0';
            if (*(q+1)=='\0') *(q+1)='0';
            c=1;
        }
        p++;
        q++;
    }
    
    while (*q!='\0' && *p=='\0') *p++ = *q++;
}

int main()
{
    memset(s, 0, sizeof(s)/sizeof(char));
    memset(t, 0, sizeof(t)/sizeof(char));
    s[0]='0';
    t[0]='1';
    
    int n;
    scanf("%d", &n);
    
    int i;
    for (i=1; i<=n; ++i)
    {
        strcpy(tmp, t);
        int j=i;
        while(--j) BigAdd(t, tmp);
        BigAdd(s, t);
    }
    
    for (i=strlen(s)-1; i>=0; --i) putchar(s[i]);
    printf("\n");
    return 0;
}

```

---

## 作者：miku1158929627 (赞：4)

水题，我首先想到的是双高精，两个高精加，思想很简单，在乘的时候把每个长度同时乘就行了，然后高精加，废话不多说,上代码:

  
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[5000],f[5000];
int i,j,k,n;
void add(int shu,int t)//处理阶乘和的高精加
{   
        f[t]=f[t]+shu;
        f[t+1]=f[t+1]+f[t]/10000;
        f[t]=f[t]%10000;
}
int main()
{  
  cin>>n;
  a[1]=1;k=1;//初始化阶乘和数组长度，从1开始
  for(i=1;i<=n;i++)
  {  for(j=1;j<=k;j++)//阶乘，（把每个部分都乘一下和一起乘，效果一样，我这里是每个都乘）
     a[j]=a[j]*i;
     for(j=1;j<=k;j++)//处理阶乘进位是的高精加
     {  a[j+1]=a[j+1]+a[j]/10000;
        a[j]=a[j]%10000;
     }
     if(a[k+1]>0) k++; //如果超过4为，长度+1
     for(int j=1;j<=k;j++)//高精，不多说（注意要在长度变化后运算）
     add(a[j],j); 
  }
  cout<<f[k];//先输出最后的数
  for(j=k-1;j>=1;j--)//倒序输出
  printf("%04d",f[j]);//注意要补零
  return 0;//结束程序
}
```

---

## 作者：AmemiyaHaruka5 (赞：4)

python膜法吼哇！

~~毕竟是自带高精的外挂语言~~

```python
p = int(input())

def fun(x):
    s = 1
    for i in range(x):
        s *= i #求阶乘
    return s

k = 0
for i in range(p):
    k += fun(i) #求阶乘和
    
print(k) #不解释
```

共创和谐码风，拒绝洛谷抄袭！

我拒绝使用l$**$bda,因为它破坏咕咕$**$码风！（掩盖自己是python小白）

---

## 作者：Rika (赞：4)

写了高精阶乘和高精加法的两个函数，main里面直接调用就可以了。基本想法还是字符串和int数组的操作。本来可以直接用高精乘法来完成的，毕竟n!=(n-1)!\*n，但因为高精乘法的函数懒得再写索性就直接加上了一个循环变成了阶乘。

>


```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<sstream>
using namespace std;
string kp(string kp1, string kp2);
string kdt(int mm);
int main()
{
    int bb;
    string rs="0";
    cin >> bb;
    for (int i = 1; i <= bb; i++) {
        rs = kp(rs, kdt(i));
    }
    cout << rs;
    return 0;
}
string kdt(int mm) {
    ostringstream oss("");
    int* rs = new int[100]();
    rs[0] = 1;
    for (int i = 2; i <= mm; i++) {
        for (int j = 0; j < 100; j++) {
            rs[j] *= i;
        }
        for (int j = 0; j < 99; j++) {
            rs[j + 1] += rs[j] / 10;
            rs[j] %= 10;
        }
    }
    int judge = 0;
    for (int i = 99; i >= 0; i--) {
        if (judge == 1 || rs[i]>0) {
            judge = 1;
            oss << rs[i];
        }
    }
    return oss.str();
}
string kp(string kp1, string kp2) {
    string tmp;
    int aa[100]{ 0 }, bb[100]{ 0 }, rs[100]{ 0 };
    ostringstream oss("");
    for (int i =0; i <kp1.size(); i++) {            //倒序两个操作数，存入aa,bb
        aa[i] = kp1[kp1.size() - 1 - i]-'0';
    }
    for (int i = 0; i <kp2.size(); i++) {
        bb[i] = kp2[kp2.size() - 1 - i]-'0';
    }
    for (int i = 0; i < 100; i++) {
        rs[i] = aa[i] + bb[i];
    }
    for (int i = 0; i < 99; i++) {
        rs[i + 1] += rs[i] / 10;
        rs[i] %= 10;
    }
    int judge = 0;
    for (int i = 99; i >= 0; i--) {
        if (judge != 0 || rs[i] != 0) {
            judge = 1;
            oss << rs[i];
        }
    }
    return oss.str();
}
```

---

## 作者：optimize_2 (赞：3)

有些高精题有了模板真的是不用动脑子.

安利zhy123456神犇的blog:[高精度模板](https://www.luogu.org/blog/zhy123456/gao-jing-lei-mu-ban-wei-wan-post)

有了这个,就可以~~为所欲为~~很容易的切掉高精题啦:-)

以下是模板:
```
namespace Bigint
{
	class bigint
	{
	private:
		int value[10005];
		short leng;
		bool fuhao;
		bigint plus(bigint a);
		friend bigint minus(bigint a, bigint b);
		bigint cheng(int a);
	public:
		bigint(int n);
		bigint();
		int length() { return leng; }
		friend std::ostream& operator << (std::ostream& output, bigint c);
		friend std::istream& operator >> (std::istream&, bigint&);
		friend bigint operator+(bigint a, bigint b);
		friend bigint operator+(bigint a, int b);
		friend bigint operator+(int a, bigint b);
		friend bigint operator-(bigint a, bigint b);
		friend bigint operator-(bigint a, int b);
		friend bigint operator-(int a, bigint b);
		friend bool operator>(bigint a, bigint b);
		friend bool operator>(bigint a, int b);
		friend bool operator>(int a, bigint b);
		friend bool operator<(bigint a, bigint b);
		friend bool operator<(bigint a, int b);
		friend bool operator<(int a, bigint b);
		friend bool operator==(bigint a, bigint b);
		friend bool operator==(bigint a, int b);
		friend bool operator==(int a, bigint b);
		friend bool operator>=(bigint a, bigint b);
		friend bool operator>=(bigint a, int b);
		friend bool operator>=(int a, bigint b);
		friend bool operator<=(bigint a, bigint b);
		friend bool operator<=(bigint a, int b);
		friend bool operator<=(int a, bigint b);
		friend bool operator!=(bigint a, bigint b);
		friend bool operator!=(bigint a, int b);
		friend bool operator!=(int a, bigint b);
		friend bigint operator<<(bigint a,int b);
		friend bigint operator>>(bigint a, int b);
		friend bigint operator*(bigint a, bigint b);
		friend bigint operator*(bigint a, int b);
		friend bigint operator*(int a, bigint b);
		friend bigint operator/(bigint a, bigint b);
		friend bigint operator/(bigint a, int b);
		friend bigint operator/(int a, bigint b);
		friend bigint operator%(bigint a, bigint b);
		friend bigint operator%(bigint a, int b);
		friend bigint operator%(int a, bigint b);
		friend bigint operator+=(bigint &a, bigint b);
		friend bigint operator+=(bigint &a, int b);
		friend int operator+=(int &a, bigint b);
		friend bigint operator-=(bigint &a, bigint b);
		friend bigint operator-=(bigint &a, int b);
		friend int operator-=(int &a, bigint b);
		friend bigint operator<<=(bigint&a, int b);
		friend bigint operator>>=(bigint&a, int b);
		friend bigint operator*=(bigint &a, bigint b);
		friend bigint operator*=(bigint &a, int b);
		friend bigint operator*=(int &a, bigint b);
		friend bigint operator/=(bigint &a, bigint b);
		friend bigint operator/=(bigint &a, int b);
		friend bigint operator/=(int &a, bigint b);
		friend bigint operator%=(bigint &a, bigint b);
		friend bigint operator%=(bigint &a, int b);
		friend bigint operator%=(int &a, bigint b);
		bigint operator++();
		bigint operator++(int);
		bigint operator--();
		bigint operator--(int);
		bool operator!();
		operator int();
		operator long long();
		operator short();
	};
	bigint::bigint(int n)
	{
		for (int i = 0; i < 10005; i++)value[i] = 0;
		if (n >= 0)fuhao = true;
		else fuhao = false;
		n = n >= 0 ? n : -n;
		for (leng = 1; n; leng++, n /= 10)value[leng] = n % 10;
		leng--;
	}
	bigint::bigint()
	{
		for (int i = 0; i < 10005; i++)
			value[i] = 0;
		leng = 0;
		fuhao = true;
	}
	std::ostream& operator << (std::ostream& output, bigint c)
	{
		if (c.leng == 0)
		{
			std::cout << 0;
			return output;
		}
		if (c.fuhao == false)output << '-';
		for (int i = c.leng; i > 0; i--)output << c.value[i];
		return output;
	}
	std::istream& operator >> (std::istream& input, bigint& c)
	{
		std::string s;
		input >> s;
		int i = s.length(), j = 0;
		c.leng = s.length();
		if (s[j] == '-')
		{
			j++;
			c.fuhao = false;
			c.leng--;
			i--;
		}
		else c.fuhao = true;
		for (; i > 0; i--, j++)c.value[i] = s[j] - '0';
		return input;
	}
	bool operator>(bigint a, bigint b)
	{
		if (a.fuhao != b.fuhao)return a.fuhao;
		if (a.leng != b.leng)return (a.leng < b.leng) xor (a.fuhao);
		for (int i = a.leng; i > 0; i--)
			if (a.value[i] != b.value[i])
				return (a.value[i] < b.value[i]) xor a.fuhao;
		return false;
	}
	bool operator>(bigint a, int b)
	{
		return a > bigint(b);
	}
	bool operator>(int a, bigint b)
	{
		return bigint(a) > b;
	}
	bool operator<(bigint a, bigint b)
	{
		if (a.fuhao != b.fuhao)return b.fuhao;
		if (a.leng != b.leng)return (a.leng > b.leng) xor (a.fuhao);
		for (int i = a.leng; i > 0; i--)
			if (a.value[i] != b.value[i])
				return (a.value[i] > b.value[i]) xor a.fuhao;
		return false;
	}
	bool operator<(bigint a, int b)
	{
		return a < bigint(b);
	}
	bool operator<(int a, bigint b)
	{
		return bigint(a) < b;
	}
	bigint bigint::plus(bigint a)
	{
		bigint b;
		int max;
		if (leng > a.leng)max = leng;
		else max = a.leng;
		for (int i = 1; i <= max; i++)
		{
			b.value[i] += value[i] + a.value[i];
			b.value[i + 1] = b.value[i] / 10;
			b.value[i] %= 10;
		}
		if (b.value[max + 1] == 0)b.leng = max;
		else b.leng = max + 1;
		b.fuhao = fuhao;
		return b;
	}
	bigint minus(bigint a, bigint b)
	{
		bigint c;
		c.fuhao = a.fuhao;
		a.fuhao = 1;
		b.fuhao = 1;
		if (a < b)
		{
			bigint d = a;
			a = b;
			b = d;
			c.fuhao ^= 1;
		}
		for (int i = 1; i <= a.leng; i++)
		{
			c.value[i] += a.value[i] - b.value[i];
			if (c.value[i] < 0)
			{
				c.value[i + 1]--;
				c.value[i] += 10;
			}
		}
		for (int i = a.leng; i > 0; i--)
		{
			if (c.value[i] != 0)
			{
				c.leng = i;
				return c;
			}
		}
		c.leng = 0;
		c.fuhao = true;
		return c;
	}
	bigint operator+(bigint a, bigint b)
	{
		bigint c;
		if (!a.fuhao^b.fuhao)
		{
			c.fuhao = a.fuhao;
			c = a.plus(b);
		}
		else
		{
			b.fuhao ^= 1;
			c = minus(a, b);
		}
		return c;
	}
	bigint operator+(bigint a, int b)
	{
		return a + bigint(b);
	}
	bigint operator+(int a, bigint b)
	{
		return bigint(a) + b;
	}
	bigint operator-(bigint a, bigint b)
	{
		bigint c(0);
		if (!a.fuhao^b.fuhao)
		{
			c.fuhao = a.fuhao;
			c = minus(a, b);
		}
		else
		{
			b.fuhao ^= 1;
			c = a.plus(b);
		}
		return c;
	}
	bigint operator-(bigint a, int b)
	{
		return a - bigint(b);
	}
	bigint operator-(int a, bigint b)
	{
		return bigint(a) - b;
	}
	bool operator==(bigint a, bigint b)
	{
		if (a.fuhao != b.fuhao)return false;
		if (a.leng != b.leng)return false;
		for (int i = 1; i <= a.leng; i++)if (a.value[i] != b.value[i])return false;
		return true;
	}
	bool operator==(bigint a, int b)
	{
		return a == bigint(b);
	}
	bool operator==(int a, bigint b)
	{
		return bigint(a) == b;
	}
	bool operator>=(bigint a, bigint b)
	{
		return !(a < b);
	}
	bool operator>=(bigint a, int b)
	{
		return !(a < bigint(b));
	}
	bool operator>=(int a, bigint b)
	{
		return !(bigint(a) < b);
	}
	bool operator<=(bigint a, bigint b)
	{
		return !(a > b);
	}
	bool operator<=(bigint a, int b)
	{
		return !(a > bigint(b));
	}
	bool operator<=(int a, bigint b)
	{
		return !(bigint(a) > b);
	}
	bigint bigint::operator++()
	{
		*this = *this + 1;
		return *this;
	}
	bigint bigint::operator++(int)
	{
		bigint a = *this;
		*this = *this + 1;
		return a;
	}
	bigint bigint::operator--()
	{
		*this = *this - 1;
		return *this;
	}
	bigint bigint::operator--(int)
	{
		bigint a = *this;
		*this = *this - 1;
		return a;
	}
	bigint::operator int()
	{
		int a = 0;
		for (int i = 9; i > 0; i--)
		{
			a *= 10;
			a += value[i];
		}
		int b = 0;
		for (int i = 10; i > 0; i--)
		{
			b *= 10;
			b += value[i];
		}
		int c;
		if (b < 0)c = a;
		else c = b;
		if (fuhao)return c;
		else return -c;
	}
	bool operator!=(bigint a, bigint b)
	{
		return !(a == b);
	}
	bool operator!=(bigint a, int b)
	{
		return !(a == bigint(b));
	}
	bool operator!=(int a, bigint b)
	{
		return !(bigint(a) == b);
	}
	bigint bigint::cheng(int a)
	{
		bigint b;
		for (int i = 1; i <= leng; i++)b.value[i] = value[i] * a;
		for (int i = 1; i <= leng; i++)if (b.value[i] > 9)
		{
			b.value[i + 1] += b.value[i] / 10;
			b.value[i] %= 10;
		}
		b.fuhao = true;
		for (int i = leng + 1; i > 0; i--)
		{
			if (b.value[i])
			{
				b.leng = i;
				return b;
			}
		}
		b.leng = 0;
		return b;
	}
	bigint operator<<(bigint a, int b)
	{
		for (int i = a.leng + b; i > b; i--)a.value[i] = a.value[i - b];
		for (int i = b; i > 0; i--)a.value[i] = 0;
		a.leng += b;
		return a;
	}
	bigint operator>>(bigint a, int b)
	{
		for (int i = 1; i <= a.leng - b; i++)a.value[i] = a.value[i + b];
		for (int i = a.leng - b + 1; i <= a.leng; i++)a.value[i] = 0;
		a.leng -= b;
		if (a.leng < 0)a.leng = 0;
		return a;
	}
	bigint operator*(bigint a, bigint b)
	{
		if (a == 0 || b == 0)return bigint(0);
		bigint c;
		for (int i = 1; i <= b.leng; i++)
		{
			bigint d = a.cheng(b.value[i])<<(i-1);
			c += d;
		}
		c.fuhao = !(a.fuhao^b.fuhao);
		for(int i=a.leng+b.leng;i>0;i--)
			if (c.value[i] != 0)
			{
				c.leng = i;
				break;
			}
		return c;
	}
	bigint operator*(bigint a, int b)
	{
		return bigint(b)*a;
	}
	bigint operator*(int a, bigint b)
	{
		return bigint(a)*b;
	}
	bigint operator/(bigint a, bigint b);
	bigint operator/(bigint a, int b);
	bigint operator/(int a, bigint b);
	bigint operator%(bigint a, bigint b);
	bigint operator%(bigint a, int b);
	bigint operator%(int a, bigint b);
	bigint operator+=(bigint &a, bigint b)
	{
		a = a + b;
		return a;
	}
	bigint operator+=(bigint &a, int b)
	{
		a = a + bigint(b);
		return a;
	}
	int operator+=(int &a, bigint b)
	{
		a = int(bigint(a) + b);
		return a;
	}
	bigint operator-=(bigint &a, bigint b)
	{
		a = a + b;
		return a;
	}
	bigint operator-=(bigint &a, int b)
	{
		a = a + bigint(b);
		return a;
	}
	int operator-=(int &a, bigint b)
	{
		a = int(bigint(a) + b);
		return a;
	}
	bigint operator<<=(bigint&a, int b)
	{
		a = a << b;
		return a;
	}
	bigint operator>>=(bigint&a, int b)
	{
		a = a >> b;
		return a;
	}
	bigint operator*=(bigint &a, bigint b)
	{
		a = a * b;
		return a;
	}
	bigint operator*=(bigint &a, int b)
	{
		a = a * b;
		return a;
	}
	bigint operator*=(int &a, bigint b)
	{
		a = int(a*b);
		return a;
	}
	bigint operator/=(bigint &a, bigint b);
	bigint operator/=(bigint &a, int b);
	bigint operator/=(int &a, bigint b);
	bigint operator%=(bigint &a, bigint b);
	bigint operator%=(bigint &a, int b);
	bigint operator%=(int &a, bigint b);
	bool bigint::operator!()
	{
		return *this == bigint(0);
	}
}
```
直接当成普通题做.
以下是主程序:
```
using namespace std;
using namespace Ha;

int n;
bigint ans,tmp;   //用Ha::bigint定义变量,自带高精运算,可以当成普通题做

int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		tmp=1;  //=0会翻车
		for(int j=2;j<=i;j++)
		{
			tmp*=j;   //普通方法求阶乘.
		}
		ans+=tmp;   //加上去
	}
	cout<<ans;
    puts(""),system("pause");  //不要在意这些
	return 0;
}
```


---

## 作者：gipsy (赞：3)

题目让我们算阶乘之和，看着很简单。似乎用C这样就可以实现：

```cpp
#include <stdio.h>
int main(void){//void 也可以不打
 	long long n,sum;
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){//!i
    	long long x=1;
        for(int j=1;j<=i;j++)
  			x*=j;
        sum+=x;//累加
    }
    printf("%d",sum);
    return 0;
}
```
交上去一看：哇瑟，才20分。看来是一道高精度题。

`---偷懒正式开始---`

因为有高精度，本人又选了Python3~~来偷懒~~（内置高精度）。

现在我来介绍一下Python中的注释。因为Python的注释和C/C++/Pascal的都不一样。是三引号和井号:

```python
"""
我是一个多行注释
哈。
"""

"""我也可以这么写"""

#我是一个单行注释。
#我也是一个单行注释。
```
回归正题，我们要开始构思代码了。还是像上面那段C代码一样，双重for循环。有一点要注意的是Python控制循环用的range()函数。Python2和Python3中，它的功能不一样。

你在Python2的交互模式（Python Shell，也就是初始化状态的IDLE）中，键入range(0,3),回车，然后你会看到这个：

	0,1,2
    
这说明在Python2中，range()用来提供一个列表。
   
但如果你在Python3交互模式中的话，你会发现，按下回车后，它会显示：

	range(0,3)

这说明了Python3中，range()的功能有一些变动（但不影响for的使用。）

```python
for i in range(0,3)
```
相当于

```python
for i in [0,1,2]
```
这能使我们省去很多字数。

言归正传，下面奉上Python3代码。

```python
n=int(input())
sum=0
for i in range(1,n+1):
	 #初始化阶乘乘积
	 x=1
     #阶乘
     for j in range(1,i+1):
          x*=j
     #累加
     sum+=x
#输出
print(sum)
```


---

## 作者：我是星星 (赞：3)

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[1000001],b[1000001],c[10000001],n;int d[1000001]; 
int main()
{
    cin>>n;
    a[0]=1;a[1]=1;
    for(int i=1;i<=n;i++)
      {
          int t=i,k=1; 
          while(t!=0) 
            {
            b[k]=t%10;
            t=t/10;
            k++;
          }
    b[0]=k-1;              //存储i为b【】，记录b【】位数为b【0】 
    //******************************************************************************************
    memset(d,0,sizeof(d));
    for (int j=0;j<=a[0];j++)
    d[j]=a[j];               //进行乘法运算 
    int x;
    memset(a,0,sizeof(a));
    for (int j=1;j<=b[0];j++)
    {
        x=0;
        for (int j2=1;j2<=d[0];j2++)
        {
            a[j2+j-1]=b[j]*d[j2]+a[j2+j-1]+x;
            x=a[j+j2-1]/10;
            a[j+j2-1]%=10;
        }
        a[j+d[0]]=x;
    }
    a[0]=b[0]+d[0];
    while(a[a[0]]==0&&a[0]>1)
    a[0]--;
    //******************************************************************************************
    while(a[a[0]+1])   //如果更高位非零
    {        
        a[0]++;          //位数增1
        a[a[0]+1]=a[a[0]]/10;    //进位操作 
        a[a[0]]%=10;
    }
    a[0]=max(a[0],c[0]);     //a[0]表示数组a的长度 
    for(int i=1;i<=a[0];i++)
        c[i]=a[i]+c[i];      //各位相加 
    for(int i=1;i<=a[0];i++) //进位操作 
        {
            c[i+1]+=c[i]/10; //下一位进 
            c[i]=c[i]%10;    //这一位 
        }
    if(c[c[0]+1]) c[0]++;    //如果更高位有数，a[0]表示的位数加一 
      }
      c[0]+=1000000;
    while(c[c[0]]==0&&c[0]>1) c[0]--;
    for(int i=c[0];i>=1;i--)  //注意倒序输出 
      cout<<c[i]; 
} 

```

---

## 作者：永遠の愛 (赞：3)

这道题的高精度简直了……数据又太大，我调了半个多小时……

~~（也不知是哪位出的题目）~~

废话少说，上程序！（程序太长，有些复杂，没优化，勿喷！）


```
#include<bits/stdc++.h>
using namespace std;
int a[10000],b[10000],c[10000];
int main(){
	int n,ci,la,lb,lc;
	string sa="",sb="0";
	cin>>n;
	for(int i=n;i>=1;i--){
		ci=i;
		while(ci!=0)
		{
			sa=sa+char(ci%10+48);
			ci/=10;
		}//初始化给sa赋值，毕竟每次循环第一个数都不同
		reverse(sa.begin(),sa.end());
		for(int j=i-1;j>=1;j--){
			la=sa.size();
			lc=la;
			reverse(sa.begin(),sa.end());
			for(int k=0;k<la;k++){
				a[k]=sa[k]-'0';
			}
			for(int k=0;k<lc;k++){
				c[k]=a[k]*j+c[k];
				if(c[k]>9){
					c[k+1]+=c[k]/10;
					c[k]%=10;
				}
			}//基本高精度运算
			while(c[lc]>0){//看有无最高位进位
				if(isdigit(c[lc])) lc++;
				else{
					int fh=int(c[lc]);
					while(fh!=0){
						c[lc]=fh%10;
						fh=fh/10;
						lc++;
					}//这里后面会说明一下
				}
			}
			while(c[lc-1]==0&&lc>1){
				lc--;
			}//去前导0操作
			memset(a,0,sizeof(a));//多次都要用a、c数组，要清0
			sa="";
			for(int k=lc-1;k>=0;k--){
				sa=sa+char(c[k]+48);
			}//重新给sa赋值，下次运算还要用
			memset(c,0,sizeof(c));
		}
		la=sa.size();
		lb=sb.size();
		lc=max(la,lb);
		reverse(sa.begin(),sa.end());
		reverse(sb.begin(),sb.end());
		for(int j=0;j<la;j++){
			a[j]=sa[j]-'0';
		}
		for(int j=0;j<lb;j++){
			b[j]=sb[j]-'0';
		}
		for(int j=0;j<lc;j++){
			c[j]=a[j]+b[j]+c[j];
			if(c[j]>9){
				c[j+1]=c[j+1]+1;
				c[j]=c[j]%10;
			}
		}//基本高精度加法
		while(c[lc]>0){
			lc++;
		}//看有无最高位进位，其实if就可以了，懒得改
		memset(a,0,sizeof(a));
		sb="";
		for(int j=lc-1;j>=0;j--){
			sb=sb+char(c[j]+48);
		}
		memset(c,0,sizeof(c));
		sa="";
	}
	for(int i=0;i<sb.size();i++){
		if(isdigit(sb[i])) cout<<sb[i];
		else{
			int fh=int(sb[i]);
			while(fh!=0){
				cout<<fh%10;
				fh=fh/10;
			}
		}
	}
	return 0;
}
```

一开始想的就是简单的高精度乘法和加法，做到后来差点哭出来……

因为我懒得开那么多数组，所以多次用到了a和c数组，真的千万千万别学我，我后来都晕得乘加颠倒了！

把高精度乘法和加法写好，再把俩并在一起，就想：OK！交上去错了，正当我想着怎么调时……（默默打开题解，看到某人写的py数据~~，嘻嘻嘻……）~~不过我发四，没看高精度程序！！！

数据最大只到50，一一测了一遍……我的tina！！！在做乘法时，有的数的开始会有符号！！！

没错，符号！！！（一惊）

这乘法是有多大……

没办法，只能把符号转成数字（就是上面说要解释的那段）。做完以后，我真的累得半死……

没事！只要能看见AC，我已无憾！！！

---

## 作者：dblark (赞：3)

广告一下：<http://zhoushengjie.pw>

看了一下，这道题Pascal题解还挺多，然而可能很多人不知道，Pascal和C++一样，也有**运算符重载**的功能。

运算符重载后，打代码会方便许多。

~~不过由于Pascal的输入输出不是运算符，特别恶心啊~~

具体用法会在代码里介绍，其实跟C++没啥两样。

因为主要是讲运算符重载，所以高精度就不解释了哈。~~看其他题解去~~

```pas
{P1009}
//operator可能是少数Pascal和C++通用的关键词
//这并不是标准语法，然而好像在第一个Pascal编译器出现的时候就能用了
type
bigint=array[0..200]of longint;
operator :=(a:longint)b:bigint;
//这是:=赋值运算符的重载，将a赋值给b
//重载后就可以进行隐性转换了，比如a=0，这里编译器会自动将0转换成bigint类型
 begin
 fillchar(b,sizeof(b),0);
 b[0]:=0;
 repeat
 inc(b[0]);
 b[b[0]]:=a mod 10;
 a:=a div 10;
 until a=0;
 end;
operator =(a,b:bigint)c:boolean;//=等号重载，重载后<>不等号也可以用了
 var
 i:longint;
 begin
 c:=false;
 if a[0]<>b[0] then
 exit;
 for i:=a[0] downto 1 do
  if a[i]<>b[i] then
  exit;
 c:=true;
 end;
function max(x,y:longint):longint;//无需解释
 begin
 if x>y then
 exit(x)
 else
 exit(y);
 end;
operator +(a,b:bigint)c:bigint;//+加号重载
 var
 i:longint;
 begin
 c:=0;
 c[0]:=max(a[0],b[0]);
 for i:=1 to c[0] do
 begin
 inc(c[i],a[i]+b[i]);
 inc(c[i+1],c[i] div 10);
 c[i]:=c[i] mod 10;
 end;
 if c[c[0]+1]>0 then
 inc(c[0]);
 end;
operator *(a,b:bigint)c:bigint;//*乘号重载
 var
 i,j:longint;
 begin
 c:=0;
 if (a=0) or (b=0) then
 exit;
 c[0]:=a[0]+b[0]-1;
 for i:=1 to a[0] do
  for j:=1 to b[0] do
  begin
  inc(c[i+j-1],a[i]*b[j]);
  inc(c[i+j],c[i+j-1] div 10);
  c[i+j-1]:=c[i+j-1] mod 10;
  end;
 if c[c[0]+1]>0 then
 inc(c[0]);
 end;
procedure print(a:bigint);//输出
 var
 i:longint;
 begin
 for i:=a[0] downto 1 do
 write(a[i]);
 writeln;
 end;
//以下没啥好看的
var
n,i:longint;
s,x:bigint;
begin
read(n);
s:=0;
x:=1;
for i:=1 to n do
begin
x:=x*i;
s:=s+x;
end;
print(s);
end.
```

---

## 作者：jacky (赞：3)

这道题实际上很简单，只需要高精阶乘+高精加。

```delphi

var n,jw,ws,i,j,k,p:longint;
    a,b:array[1..100]of integer;
begin
 readln(n);
  fillchar(a,sizeof(a),0);
  fillchar(b,sizeof(b),0);
 jw:=0;
 ws:=1;
 a[1]:=1;
 b[1]:=1;
 for i:=2 to n do begin
 jw:=0;
  for j:=1 to ws do begin
   a[j]:=a[j]*i+jw;
   jw:=a[j] div 10;
   a[j]:=a[j] mod 10;
  end;
  while jw<>0 do begin
   inc(ws);
   a[ws]:=jw mod 10;
   jw:=jw div 10;
  end;
  p:=0;
  for j:=1 to ws+1 do begin
   b[j]:=b[j]+a[j]+p;
   p:=b[j] div 10;
   b[j]:=b[j] mod 10;
  end;
 end;
 if a[ws+1]<>0 then k:=ws+1
 else k:=ws;
 for i:=k downto 1 do write(b[i]);
 writeln;
end.

```

---

## 作者：一碗粥 (赞：3)

数学加高精的完美标程，见下：

```cpp
Var a,b:array[1..99]of integer;     
   n,i,j:integer;  
Begin  
readln(n);  
b[1]:=1;  
for i:=1 to n do  
   begin  
   for j:=1 to 99 do  
      b[j]:=b[j]*i;  
   for j:=1 to 99 do  
      begin  
      inc(b[j+1],b[j] div 10);  
      b[j]:=b[j] mod 10;  
      end;  
   for j:=1 to 99 do  
      begin  
      inc(a[j],b[j]);  
      inc(a[j+1],a[j] div 10);  
      a[j]:=a[j] mod 10;  
      end;  
   end;  
j:=100;  
while a[j]=0 do dec(j);  
for i:=j downto 1 do  
   write(a[i]);  
writeln;  
End.  
由于会202，不得不用到高精，入门题考验的是大家的反应力和对基础的理解。
```

---

## 作者：cre_chan (赞：3)

看到这道题时，我第一时间想到这个问题可能涉及到大数运算。抱着侥幸心理，我用rust里的i64和i128进行了一些测试，这些测试证明了我的猜测——这题需要自己定义大数类。

首先我先确定了main函数的内容:
```
use std::io;
use std::io::Write;

fn main() {
    let mut input=String::new();

    //read an input
    io::stdin()
        .read_line(&mut input);

    let input:u32=input
        .trim()
        .parse()
        .expect("A number is expected");

    let mut sum=Int::from(0);
    let mut term=Int::from(1);

    for rop in 1..input+1{
        term=term*rop;
        sum=sum+&term;
    }

    println!("{}",sum)
}

```
忽略掉接收命令行输入并转换成无符号整形的部分。我们从u32创建了两个Int，Int就是我们的大数类型。sum记录阶乘和，term则记录每一项阶乘的值。在for循环中，我们让term和rop相乘，并对sum进行累加。在main函数的最后，我们输出sum。

因此我们需要实现的功能包括：表示一个很大的非负整数，两个大数相加，大数与u32相乘。实现代码如下：

```
use std::ops::{Add,Mul};
use std::cmp::PartialEq;
use std::fmt::{Display,Debug};


//一个大数类型，使用小端法来表示（主要是为了加和乘时遍历方便
//派生PartialEq，使得比较两个大数的等价性方便。但务必确保
//bits的高位没有多余的0。使用2^32进制。
#[derive(PartialEq)]
pub struct Int{
    bits:Vec<u32>
}


impl Int{
	//除以一个u32，返回一个大数作为商，一个u32表示模
    //用于输出过程中转化成10进制数
    fn div_by(&self,dividor:u32)->(Int,u32){
        let mut carry=0;

        let mut bits:Vec<u32>=self.bits.iter()
            .rev()
            .map(
                |&x|{
                    let lop:u64=(carry<<32)+x as u64;
                    //println!("lop is {}",lop);
                    let result=lop/(dividor as u64);
                    //println!("result is {}",result);
                    carry=lop%(dividor as u64);
                    result as u32
                }
            )
            .skip_while(|&x|{
                x==0
            })
            .collect();

        bits=bits.into_iter().rev().collect();

        if bits.len()==0{
            (Int::from(0),carry as u32)
        }else {
            (Int{bits},carry as u32)
        }
    }
}


impl Display for Int{
	//使用辗转相除法，将大数转化为其10进制表示，用于输出。
    fn fmt(&self,formatter:&mut std::fmt::Formatter<'_>)-> std::result::Result<(), std::fmt::Error>{
        let (mut div,mut remainder)=self.div_by(10);

        let mut bits=vec![remainder];

        while div!=Int::from(0){
            let (l,r)=div.div_by(10);
            div=l;
            remainder=r;
            bits.push(remainder)
        }

        for i in bits.iter().rev(){
            formatter.write_fmt(
                format_args!("{}",i)
            );
        }

        Ok(())
    }

}

//to create an Int from an unsigned int
impl From<u32> for Int{

    fn from(val:u32)->Int{
        Int{
            bits:vec![val]
        }
    }
}

//在本地测试的时候，是不需要指明'a这个生命期的。
//但是洛谷的rustc似乎还不能进行这个推断。
impl<'a> Add<&'a Int> for Int{
    type Output=Int;

    //此处有取巧。我们知道在main函数中term总是大于加上term前的sum
    //且我们总是保证bits中没有多余的零。所以我们总是可以假设，other的bits长度大于self的bits长度。
    fn add(self,other:&Int)->Self::Output{
        let mut carry=0;
        let mut rop=self.bits.into_iter();

        let mut bits:Vec<u32>=other.bits.iter().map(
            |&lop|{
                let rop=rop.next()
                    .unwrap_or(0);
                let result=lop as u64+rop as u64+carry;
                let mask=0xFFFFFFFF_u64;
                let bit=(result&mask) as u32;
                carry=result>>32;
                bit
            }
        ).collect();

        if carry!=0{
            bits.push(carry as u32)
        }

        Int{
            bits
        }
    }
}


impl Mul<u32> for Int{
    type Output=Int;

    fn mul(self,rop:u32)->Self::Output{
        let mut carry=0;

        let mut bits: Vec<u32> =self.bits.into_iter().map(
            |lop|{
                let result=lop as u64*rop as u64+carry;
                let mask=0xFFFFFFFF_u64;
                let bit=(result&mask)as u32;
                carry=result>>32;
                bit
            }
        ).collect();

        if carry!=0{
            bits.push(carry as u32)
        }

        Int{
            bits
        }
    }

}
```
在实际做的过程中，因为输出部分的疏忽，导致格式化错误了，还有因为rustc的版本不一样，导致一处生命期没有标明。除此之外，使用Add和Mul Trait导致效率偏低，在本题情况下应该使用AddAssign和MulAssign在原位进行相加和相乘。这些都是有必要改进的。

---

## 作者：封禁用户 (赞：3)

嗯，这题我不知道（pascal）的qword会不会爆，但是为了保证一次能过，最好还是用高精度吧。

不过，这里要注意一下，只用高精乘低精，因为循环的i最大也只有100。

代码应该不用解释了吧。。。。。直接贴哈

```cpp
var
        l,n,i,j,h,k:longint;
        a,b:array[1..100]of longint;
begin
        readln(n);
        a[1]:=1;
        for i:=1 to n do
        begin
                k:=0;
                for j:=1 to 100 do
                begin
                        h:=a[j]*i+？;（这里有一个问号，大家想一想，问号填什么？）
                        a[j]:=h mod 10;
                        k:=h div 10;
                end;
                k:=0;
                for j:=1 to 100 do
                begin
                        h:=b[j]+a[j]+k;
                        b[j]:=h mod 10;
                        k:=h div 10;
                end;
        end;
        l:=100;
        while b[l]=0 do
                dec(l);
        for j:=l downto 1 do
                write(b[j]);
end.
```

---

## 作者：ezoiHQM (赞：2)

这道题使用重载运算符，然后主函数部分基本照常打，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 300;
struct bign {
    int len, s[MAXN];
    bign () {
        memset(s, 0, sizeof(s));
        len = 1;
```
}//初始化
```cpp
    bign (int num) {
        *this = num;
    }
    bign (const char *num) {
        *this = num;
    }
    bign operator = (const int num) {
        char s[MAXN];
        sprintf(s, "%d", num);
        *this = s;
        return *this;
    }
    bign operator = (const char *num) {
        for(int i = 0; num[i] == '0'; num++) ;
        len = strlen(num);
        for(int i = 0; i < len; i++) s[i] = num[len-i-1] - '0';
        return *this;
```
}//重载=
```cpp
    bign operator + (const bign &b) const {
        bign c;
        c.len = 0;
        for(int i = 0, g = 0; g || i < max(len, b.len); i++) {
            int x = g;
            if(i < len) x += s[i];
            if(i < b.len) x += b.s[i];
            c.s[c.len++] = x % 10;
            g = x / 10;
        }
        return c;
```
}//重载+
    bign operator += (const bign &b) {

        \*this = \*this + b;

        return \*this;

}//重载+=

```cpp
    void clean() {
        while(len > 1 && !s[len-1]) len--;
    }
    bign operator * (const bign &b) {
        bign c;
        c.len = len + b.len;
        for(int i = 0; i < len; i++) 
            for(int j = 0; j < b.len; j++) 
                c.s[i+j] += s[i] * b.s[j];
        for(int i = 0; i < c.len; i++) {
            c.s[i+1] += c.s[i]/10;
            c.s[i] %= 10;
        }
        c.clean();
        return c;
```
}//重载\*
    bign operator \*= (const bign &b) {

        \*this = \*this \* b;

        return \*this;

}//重载\*=

```cpp
    bool operator < (const bign &b) {
        if(len != b.len) return len < b.len;
        for(int i = len-1; i >= 0; i--) {
            if(s[i] != b.s[i]) return s[i] < b.s[i];
        }
        return false;
```
}//重载<
```cpp
    bool operator > (const bign &b) {
        if(len != b.len) return len > b.len;
        for(int i = len-1; i >= 0; i--) 
            if(s[i] != b.s[i]) return s[i] > b.s[i];
        return false;
```
}//重载>
    bool operator == (const bign &b) {

        return !(\*this > b) && !(\*this < b);

}//重载==

    bool operator <= (const bign &b) {

        return \*this < b || \*this == b;

}//重载<=

```cpp
    string str() const {
        string res = "";
        for(int i = 0; i < len; i++) res = char(s[i]+'0') + res;
        return res;
    }
}num=1,sum=0;
istream& operator >> (istream &in, bign &x) {
    string s;
    in >> s;
    x = s.c_str();
    return in;
}
ostream& operator << (ostream &out, const bign &x) {
    out << x.str();
    return out;
```
}//重载<<和>>
```cpp
int main(){
    int n;
    cin>>n;//输入 
    for(int i=1;i<=n;i++){
        num*=i;//计算i的阶乘 
        sum+=num;//累加 
    }
    cout<<sum;//输出 
    return 0;
}
```

---

## 作者：caozy623 (赞：2)

和kkke的思想一致，采用的就是边乘边加入s中的方法，最后输出高精度数s。

高精度数a用来计算i的阶乘，for i:=1 to n do 每次计算完成s:=s+a.这样就转化为高精度模板题了。。。关键代码如下：

//nt是高精度数的记录，n[i]代表高精度数第i位数是什么，len代表长度。


```cpp
type
 nt=record
  n:array[0..500] of longint;
  len:longint;
 end;
```
……略过plus（a:=a+b)及mult(a:=a\*b,b是单精度数）

//主程序，记得a必须要初始化，要用于mult，起始长度和第一位数都要是1.

```cpp
begin
 readln(n);
 fillchar(a.n,sizeof(a.n),0);a.len:=1;a.n[1]:=1;
 for i:=1 to n do
 begin
  mult(a,i);
  plus(s,a);
 end;
 for i:=s.len downto 1 do
 write(s.n[i]);
 writeln;
end.
```

---

## 作者：Leaves_Flower (赞：2)

看dalao们轻松水过这道题，作为萌新我还是发一个通用版高精吧


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define FT(A,B,C) for(int A=B;A <= C;A++)  //用来压行
//不喜欢压行的童鞋自行忽略 
using namespace std;
const int N=1005;
struct int_l{
    int data[N];
    int_l(){//结构体的初始化 这很关键 
        memset(data,0,sizeof(data));
        data[0]=1;    
    }
    int_l(int x){//将低精数转化为高精数 
        memset(data,0,sizeof(data));
        data[0]=1;
        int i=1;
        while(x){
            data[i++]=x%10;
            x/=10;
        }
        data[0]=--i;
    }
    int_l operator *(const int &x){//重载乘号 * 注意只能高精*低精 不能 低精*高精
        int_l a; 
        int len;
        a.data[0]=data[0];
        FT(i,1,data[0]) a.data[i]=data[i]*x;
        for(int i=1;i<=a.data[0] || a.data[i];len=++i){ a.data[i+1]+=a.data[i]/10; a.data[i]%=10;}
        a.data[len]? a.data[0]=len : a.data[0]=--len;
        return a;
    }
    int_l operator +(const int_l &x){//重载加号 + 
        int_l a;
        a.data[0]=max(data[0],x.data[0]);
        FT(i,1,a.data[0]) a.data[i]=data[i]+x.data[i];
        FT(i,1,a.data[0]){ a.data[i+1]+=a.data[i]/10; a.data[i]%=10;}
        a.data[a.data[0]+1]? a.data[0]++ : a.data[0];
        return a;
    }

};
ostream& operator << (ostream& out, const int_l &x){//这行比较高深 重载输出流
//嫌麻烦的 可以用普通的方法输出也行 
    FT(i,1,x.data[0]) out<<x.data[x.data[0]-i+1];
    return out;
}
int n;
int_l ans(0),a;
void solve(int x){//平淡无奇的函数 
    a=1;
    FT(i,1,x) a=a*i;
    ans=ans+a;
    if(x>=2) solve(x-1);
    else cout<<ans<<endl;
}
int main(){
    cin>>n;
    solve(n);
    return 0;
}
```

---

## 作者：7193jlm (赞：2)

难度不大，主要考察高精度+阶乘之和，不用高精度50分！


```cpp
Program EDG;
var
  len,n,i,j,h,k:longint;
  a,b:array[1..100]of longint;
begin
  readln(n);
  a[1]:=1;
  for i:=1 to n do
    begin
      k:=0;
      for j:=1 to 100 do
        begin
          h:=a[j]*i+k;
          a[j]:=h mod 10;
          k:=h div 10;
        end;
      k:=0;
      for j:=1 to 100 do
        begin
          h:=b[j]+a[j]+k;
          b[j]:=h mod 10;
          k:=h div 10;
        end;
    end;
  len:=100;
  while b[len]=0 do
    len:=len-1;
  for j:=len downto 1 do
    write(b[j]);
  writeln;
  readln;
  readln;
end.
```

---

## 作者：kinder (赞：2)





```cpp
#include <iostream>
#include <cstdio>
#include<cstring>
#define dfn 20
using namespace std;
int k=1,n,num[dfn],sz[dfn],ans,bj=0;
int gjd(void){
    for(int i=2;i<=n;i++){
        ans=0; //进位值
        for(int j=0;j<k;j++){
            num[j]=num[j]*i+ans;    //先乘再加前面的进位
            ans=num[j]/10000;
            num[j]%=10000;
            if(ans!=0&&j+1==k){    //判断进位后是否已是最大位，如果是便跳出循环
                num[k++]=ans;    //最大位赋上进位值
                break;
            }
        }
        for(int j=0;j<k;j++){
            sz[j]+=num[j];         //结果加上该阶层的值
            sz[j+1]+=sz[j]/10000;  
            sz[j]%=10000;
        }
    }
}
int main(){
    scanf("%d",&n);
    memset(num,0,sizeof(num));
    memset(sz,0,sizeof(sz));
    num[0]=1;
    sz[0]=1;
    gjd();//神他妈模板； 
    for(int i=dfn-1;i>=0; i--){//从高位开始向下输出 
        if(bj) printf("%04d",sz[i]);//表示在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位
        else if(sz[i])
        {
            printf("%d",sz[i]);
            bj=1;
        }
    }
    return 0;
}
高精度套模板，不懂大佬做法，莫名奇妙就过了
```

---


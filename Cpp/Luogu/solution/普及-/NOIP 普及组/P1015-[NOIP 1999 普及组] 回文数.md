# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# 题解

## 作者：Haishu (赞：527)

**upd：20200418**

这题是高精度加法和普通模拟的一道好题。

郑重声明：本题正解为高精度+模拟。利用数据范围模糊的题目漏洞而使用long long水过此题应当是一个应当坚决制止的行为。我本人刚学OI时做题经常只考虑局部正确性而忽视数据范围，然后稀里糊涂发了这篇题解。如今这篇题解截至此时因为利用数据范围漏洞而水过而成为第一高赞题解，但是我忽视了其影响力，**给后来的初学者开了一个很坏的头**，我做自我检讨。感谢评论区狂轰滥炸的督促，今天我这道题目和这篇题解重写。

请注意：我们应当认为，在任何时候利用题目数据、评测机器或其他漏洞而 **主观人为** 获取AC的行为与作弊行为性质上无异，应当坚决制止。**（这里的主观人为指你在A题前已经知道本题存在某些题面中没有说明的漏洞可以加以利用。这种漏洞不包括可以通过观察发现的特性。）**

upd20230114:（ 对这句话必需补充的是，由于我2017年的那篇题解已经不再展示，所以这句话可能给了一些同学误解。这里的“坚决制止”是指由于我之前发了不符合题目要求的题解并且这篇题解点赞数量很多，导致许多人可能效仿那篇题解的做法从而水过此题。这在个人的训练提升当中是不提倡的做法。）
但是，由于本人已经升入大学且还是参加过不少场NOIP的，所以必须要说的是如果你在比赛当中通过合法的骗分方式得到了很多分甚至过了题，那么只要成绩有效，就不要有任何思想负担。

本题按照题目意思模拟即可。我们可以开两个数组来记录高精度数字，这样方便我们处理。判断“该数组是否回文”、“c翻转存入d再做c+d”可以写成两个单独的函数。然后主程序组织一下他们即可。注意好退出循环的条件。

```cpp
#include <cstdio>
#include <cstring>
const int S=303;//一次加法顶多多一位，所以顶多多30位，也就是130位左右。我开大一点，开到300.
int n,a[S],l;
char c[S],d[S];
inline void add()
{
	for (int i=0;i<l;++i)
		d[l-i-1]=c[i];
	l+=2;//可能有进位，所以我们干脆在前面先多空个两位
	for (int i=0;i<l;++i)
	{
		c[i]+=d[i];
		if (c[i]>=n) c[i+1]++,c[i]-=n;
	}
	while (!c[l-1]) --l;//大不了多余的前导0再减回来嘛~~简化思维~~
}
inline bool pd()
{
	for (int i=0;i<l;++i)
		if (c[i]!=c[l-1-i]) return false;
	return true;
}
int main()
{
	scanf("%d%s",&n,c);l=strlen(c);
	for (int i=0;i<l;++i)
	{
		if (c[i]>='0' && c[i]<='9') c[i]-='0';
		else c[i]=c[i]-'A'+10;
	}
	int step=0;
	while (!pd())
	{
		++step;
		if (step>30) break;
		add();
	}
	if (step<=30) printf("STEP=%d\n",step);
	else puts("Impossible!");
	return 0;
}
```

把不同的一些并不小的功能写成不同的函数再在主程序当中组织它们，是属于一种标准化、模块化编程的思维。这种思维在以后编程，尤其是像高精度这样主程序调用频繁的程序当中，可以大大简化思维和代码量。其特点就是函数间独立性较为明显，函数接口较为简单，函数调用方便。一个函数应当干完它所有的任务，如果把某些任务拖延到主程序或者是其他函数当中，将大大复杂编程思维复杂度和代码量。大家可以挑战一下[P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)，这是我发现模块化极其优秀的起源。

___
**20171029题解改：**

如果题目是int64整形范围内的话，那么将毫无必要转进制！

一个小技巧：将n进制数反转，在十进制下即可翻转，无需转成字符数组。判断反转后的数（10进制）与原来的数（先把它转成10进制）是否相同即可。


代码：



```cpp
bool pd(unsigned long long a)//判断a与其n进制下反转是否相等。
{
    unsigned long long s=0;
    for (unsigned long long i=a;i;i/=n)
        s=s*k+i%n;//用十进制，但是把它按照n进制操作
    nex=s+a;
    return s==a;
}

```

---

## 作者：Strong_Jelly (赞：313)

## 高精回文数

emm……M在一百位以内，该上**高精度**了。

虽然是N进制数，但本题不需要转


**因为：**

既然是N进制数

请把高精加中的——%10改为%n

请把高精加中的——/10改为/n

其他运算方式不变



------------




这题需要会**高精加**，**高精反转**，**高精判断回文数**和**数组存高精度**。

不会的同学可以参考一下代码

让我们开始愉快的模拟吧(～￣▽￣)～………………



------------

先定义变量：

```cpp
int n, q[1000001], l, w[1000001], ans;
string s;
```
q是高精数组，w是q反转后的数组，l是高精度数的长度，n是进制，ans是所需的步数, s是输入高精度的字符串。



------------


高精加code:

```cpp
void add(int a[], int b[])//高精加 
{
	for(int i = 1; i <= l; i++)
	{
		a[i] += b[i];
		a[i + 1] += a[i] / n;//进位 
		a[i] %= n;
	}
	if(a[l + 1] > 0)//考虑从最高位进位到最高位的下一位 
	{
		l++;//长度++ 
	}
}
```



------------

高精反转code:

```cpp
void turn(int a[])//反转数字 
{
	int j = 0;
	for(int i = l; i >= 1; i--)//反着存 
	{ 
		w[++j] = a[i];//存到w数组里 
	}
}
```



------------

高精判断回文数code:

```cpp
bool f(int a[])//判断是否是回文数 
{
	int ln = l;
	int i = 1;//从两边判断
	int j = l;
	while(ln--)
	{
		if(ln < l / 2)//判一般就可以啦QAQ 
		{
			break;
		}
		if(a[i] != a[j])
		{
			return false;//有一位不相等就不是回文数 
		}
		i++;
		j--;
	}
	return true;
}
```


------------

数组存高精度code:

```cpp
void init()//把s字符串附到q数组里 
{
	int j = 0;
	for(int i = s.length() - 1; i >= 0 ; i--) 
	{
		if(s[i] >= '0' && s[i] <= '9')//数字 
		{
			q[++j] = s[i] - '0';
		}
		else//还有十六进制的 
		{
			q[++j] = s[i] - 'A' + 10;
		} 
	}
}
```


------------

主函数code：

```cpp
int main()
{
	cin>>n>>s;
	init();//初始化数组 
	l = s.length();
	while(!f(q))//是否回文 
	{
		turn(q);
		add(q, w);//加上回文数 
		ans++;
		if(ans > 30)//步数大于三十就退出 
		{
			break;
		}
	}
	if(ans > 30)
	{
		printf("Impossible!"); //叹号注意 
	}
	else
	{
		printf("STEP=%d", ans);
	}
	return 0;
}
```


------------

AC完整版code：

（就不写注释了QAQ）

```cpp
#include <bits/stdc++.h> 
using namespace std;
int n, q[1000001], l, w[1000001], ans;
string s;
void init() 
{
	int j = 0;
	for(int i = s.length() - 1; i >= 0 ; i--) 
	{
		if(s[i] >= '0' && s[i] <= '9') 
		{
			q[++j] = s[i] - '0';
		}
		else 
		{
			q[++j] = s[i] - 'A' + 10;
		} 
	}
}
void add(int a[], int b[]) 
{
	for(int i = 1; i <= l; i++)
	{
		a[i] += b[i];
		a[i + 1] += a[i] / n; 
		a[i] %= n;
	}
	if(a[l + 1] > 0) 
	{
		l++; 
	}
}
bool f(int a[]) 
{
	int ln = l;
	int i = 1;
	int j = l;
	while(ln--)
	{
		if(ln < l / 2) 
		{
			break;
		}
		if(a[i] != a[j])
		{
			return false; 
		}
		i++;
		j--;
	}
	return true;
}
void turn(int a[]) 
{
	int j = 0;
	for(int i = l; i >= 1; i--) 
	{
		w[++j] = a[i]; 
	}
}
int main()
{
	cin>>n>>s;
	init(); 
	l = s.length();
	while(!f(q)) 
	{
		turn(q);
		add(q, w); 
		ans++;
		if(ans > 30) 
		{
			break;
		}
	}
	if(ans > 30)
	{
		printf("Impossible!"); 
	}
	else
	{
		printf("STEP=%d", ans);
	}
	return 0;
}
```

完美结束…………………………………


PS：希望这次能通过please︿(￣︶￣)︿

---

## 作者：hawa130 (赞：131)

回文的判断可以用 C++ STL 自带的 `reverse` 函数（翻转字符串函数）~~（STL 大法好）~~  

和楼上各位 dalao 一样，修改了高精加法的过程，推广到 n 进制，记得要特判对于十六进制数的判断。

以下是代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxN = 105;
char sixt[20] = "0123456789ABCDEF";
int n;
string m;
bool hw(string a) { //判断回文
	string s = a; //把 a 赋值给 s
	reverse(s.begin(), s.end()); //反转字符串 s
	return s == a; //判断 a 和 s 是否相等
}
string add(int k, string b) { //高精度加法过程，推广到 k 进制
	string a = b;
	reverse(a.begin(), a.end());
	int numa[maxN], numb[maxN], numc[maxN];
	int len = a.length(), lenc = 1;
	string ans;
	for (int i=0; i<len; i++) {
		if (isdigit(a[i])) numa[len-i] = a[i] - '0'; //对于十六进制的特判，如果是数字减去 0 ，下同
		else numa[len-i] = a[i] - 'A' + 10; //如果不是数字减去 A 再加上 10
		if (isdigit(b[i])) numb[len-i] = b[i] - '0';
		else numb[len-i] = b[i] - 'A' + 10;
	}
	int x = 0;
	while (lenc <= len) {
		numc[lenc] = numa[lenc] + numb[lenc] + x;
		x = numc[lenc] / k; //把除以 10 修改为除以 k
		numc[lenc] %= k; //这里把对 10 取模修改为对 k 取模
		lenc++;
	}
	numc[lenc] = x;
	while (numc[lenc] == 0) lenc--;
	for (int i=lenc; i>=1; i--) ans += sixt[numc[i]];
	return ans;
}
int main() {
	cin >> n >> m;
	for (int i=0; i<=30; i++){ //模拟过程
		if(hw(m)) { //如果是回文数就输出步骤数
			printf("STEP=%d", i);
			return 0;
		}
		else m = add(n, m);
	}
	printf("Impossible!"); //如果超过 30 步则输出 Impossible!
	return 0;
}
```

---

## 作者：bigbigdoggy (赞：87)


### 蒟蒻的第一篇题解，心中小鸡冻
#### 观望二十五个dalao们的各种解法，

------------


### 废话不多说，首先来分析一下

**N进制运算：**
 
 **1、当前位规范由%10改为 n**
 
 **2、进位处理由/10改为/n**
 
 **3、其他运算规则不变**

### 知道这些以后就很简单啦，这就是最普通的高精度了
下满是代码，做了一点小手脚，直接复制w一个点

（我承认，正常人都看得出来）~~（看不出来的就一定是大佬啦）~~
### p.s.代码看起来比较长，其实是每一个括号都换行了，真实长度一般

------------


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a[101],b[101],ans,i;
void init(int a[])                         //将数串s转化为整数数组a
{
	string s;
	cin>>n>>s;                        //读入字符串s
	memset(a,0,sizeof(a));            //数组a清0
	a[0]=s.length();                  //用a[0]计算字符串s的位数
	for(i=1; i<=a[0]; i++)
	{
		if(s[a[0]-i]>='0'&&s[a[0]-i]<='9')
		{
			a[i]=s[a[0]-i]-'0';
		}
		else
		{
			a[i]=s[a[0]-i]-'A'+10;
		}
	}

}
bool check(int a[])          //判别整数数组a是否为回文数
{
	for(i=1; i<=a[0]; i++)
	{
		if(a[i]!=a[a[0]-i+1])
		{
			return false;
		}
	}
	return true;
}
void  jia(int a[])          //整数数组a与其反序数b进行n进制加法运算
{
	for(int i=1; i<=a[0]; i++)
	{
		b[i]=a[a[0]-i+1];    //反序数b
	}
	for(int i=1; i<=a[0]; i++)
	{
		a[i]+=b[i];          //逐位相加
	}
	for(int i=1; i<=a[0]; i++)                     //处理进位
	{
		a[i+1]+=a[i]/n;
		a[i]%=n;
	}
	if(a[a[0]+1]>0)
	{
		a[0]++;    //修正新的a的位数（a+b最多只能的一个进位）
	}
}
int main()
{
	init(a);
	if(check(a))
	{
		cout<<0<<endl;
		return 0;
	}
	ans=0;                            //步数初始化为0
	while(ans++<=30)
	{
		jia(a);
		if(check(a))
		{
			cout<<"STEP="<<ans<<endl;
			return 0;
		}
	}
	cout<<"Impossible"<<endl;             //输出无解信息
	return 0;
}

```

上一次交题解因格式不齐没有过，这一次我努力了啊

~~（我知道已经有这么多题解了，基本过不了）~~

##### 能看到这里，感激流涕 orz

---

## 作者：pantw (赞：67)

稍微用点STL操作就可以简单地写出这个“码农题”。

思路：暴力模拟。

分析详见代码。


```cpp
#include <cstdio>
#include <cctype>
#include <vector>
#include <cstring>
#include <algorithm>
#define maxn 2333
using namespace std;
char buf[maxn];
int n;
vector<int> a, b;
int main() {
    scanf("%d%s", &n, buf);
    for(int i = 0, len = strlen(buf); i < len; i++) { // 简单的按位读入
        if(buf[i] >= '0' && buf[i] <= '9') a.push_back(buf[i] - '0');
        else a.push_back(islower(buf[i]) ? buf[i] - 'a' + 10 : buf[i] - 'A' + 10);
    }
    b = a; // 将a copy到b里。
    reverse(a.begin(), a.end()); // 反转a。
    if(a == b) return puts("STEP=0"), 0; //反转后相等即为回文
    for(int ans = 1; ans <= 30; ans++) {
        for(int i = 0, siz = a.size(); i < siz; i++) {
            a[i] += b[i]; // 加法
            if(i != siz - 1) a[i + 1] += a[i] / n; // 处理进位
            else if(a[i] >= n) a.push_back(a[i] / n);
            a[i] %= n;
        }
        b = a;
        reverse(b.begin(), b.end());
        if(a == b) return printf("STEP=%d", ans), 0; // 判回文
    }
    return puts("Impossible!"), 0;
}
```

---

## 作者：修罗海神王 (赞：42)

# 蒟蒻在何处？就在此处啊！
本蒟蒻回来了。

今天的重点是讲这道题目，这道题需要特别的细心。

而我呢，在那边调试了一个小时，不知道大家有木有看到我在学术区发的帖子？？？


###  -----这是一条十分华丽的分割线（你应该知道它在分什么，请认真起来）-------
以下是解这道题的步骤：

### 1、输入n和m，注意必须是用cin>>n>>m;否则会死的很惨！
2、构造死循环while(1)。

   首先写一个结束条件：
   
   if(pd()==1) {cout<<"STEP="<<ans;break;}表示找到，并且输出、退出死循环。
   
   再写一个结束条件：
   
   if(ans>=30{cout<<"Impossible!";break;}表示题目中说的，如果步数超过30步，则输出Impossible!

3、重头戏：
一个运算，将两个数加起来，并赋值。

4、ans++，表示走的步数增加一。

好了，现在，大家对主程序有了了解，开始告诉大家子程序，我们先从重头戏讲：

运算：  我们先要将m数组翻一下，存入x数组中，再和m数组进行高精度运算，期间，要注意，他们如果是十六进制数，则ABCD……，就要将他们转换成数字，将相加的结果存入s数组中，因为是加法，所以只需要判断下一位是否比0大就可以了，最后，要将m先清空，再加上s中的数，注意，这里s是数字，我们要将他们变为字符再加进去。

判断：  总体思路为举反例，如果两端不一样，则将bo变为0，最后只要返回bo就行了。

# 你们最爱的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
string m,st,s;
int zhuanhuan2(char x)
{
	if(x>=0&&x<=9) return x+'0';
	if(x>=10&&x<=16) return x+'A'-10;
}
int zhuanhuan(char x)
{
	if(x>='0'&&x<='9') return x-'0';
	if(x>='A'&&x<='Z') return x-'A'+10;
}
int pd()
{
	int l=m.size(),bo=1;
	for(int i=0;i<l;i++)
	  if(m[i]!=m[l-i-1]) bo=0;
	return bo;
}
void yunsuan()
{
	int l=m.size(),s[210];string x=m;
	memset(s,0,sizeof(s));
	for(int i=0;i<l;i++) x[i]=m[l-i-1];
	for(int i=1;i<=l;i++)
	{
		s[i]+=(zhuanhuan(x[i-1])+zhuanhuan(m[i-1]));
		s[i+1]+=s[i]/n;
		s[i]%=n;
	}
	if(s[l+1]>0) l++;m="";
	for(int i=0;i<l;i++) m+=zhuanhuan2(s[l-i]);
}
int main()
{
	cin>>n>>m;
	while(1)
	{
		if(pd()) {cout<<"STEP="<<ans;break;}
		if(ans>=30) {cout<<"Impossible!";break;}
		yunsuan();
		ans++;
	}
	return 0;
}
```
防抄袭万岁


---

## 作者：zhyyng (赞：40)

这道题虽然出现了16进制，但是我们**并不需要**进行进制转换。

我们可以把每次计算想象成一次**高精度加法**，这样只要在平时写的**高精度加法**中吧"10"换成"n"，就可以不进行进制转换而进行计算了。

同时貌似我们也可以用**O(n)**扫一遍高精度数组判断是否回文，但如果不高精的话，还要加加减减膜膜什么的。。。

代码如下：

```cpp
#include<cstdio>
#include<cstring>

char s[201];
int a[401],top;         //数组a为高精度数组，top为它的长度
inline bool judge()  //判断一个数是否回文
{
    int t=top/2;
    for (int i=0;i<=t;++i)
        if (a[i]!=a[top-i])
            return true;
    return false;
}
int main()
{
    int n,step=0;
    scanf("%d%s",&n,s);
    top=strlen(s)-1;
    for (int i=0;i<=top;++i)   //将字符转化为数字
        if (s[i]>='0'&&s[i]<='9')
            a[top-i]=s[i]-'0';
        else
            a[top-i]=s[i]-55;   //注意16进制
    while (judge())
    {
        if (step>30)  //如果超过三十步就直接结束程序
            return puts("Impossible!")&0;
        for (int i=0;i<=top;++i)  //高精度加法不是很习惯边算边进位，习惯算完在进位
            if (top-i>=i)
                a[i]+=a[top-i];
            else
                a[i]=a[top-i];  //因为最后算出来的数如果不进位的话就一定是回文的，所以数组的后一半直接复制前一半就好了
        for (int i=0;i<=top;++i) //进位
            if (a[i]>=n)
                a[i+1]++,a[i]-=n;
        if (a[top+1])  //注意如果首位进位，长度要增加
            top++;
        step++;
    }
    printf("STEP=%d\n",step);
    return 0;
}
```

---

## 作者：xd_ydchen (赞：34)

浏览了一圈没有看到使用 Python 的， 这儿用 python 有一个大坑，就是读入的数据有一个回车，如果没有处理的话就会全部 RE

还有一个坑是题目中要求的是 N 进制的回文串，所以判断回文串的时候不用将数字转换为十进

如下的代码，如果直接使用 int(ch,base=n) 而不处理异常的话就会全部 RE （0分）

```python

n = int(input())
instr = input()
a = []
for ch in instr:
    try:
        a.append(int(ch,base=n))
    except Exception:
        # must handle exception !!!
        pass

step = 0
while step <= 30:
    b = a[::-1]
    if a == b:
        break

    # add b and b.revert()
    a = []
    up = 0
    for index in range(len(b)):
        s = b[index] + b[-1 - index] + up
        a.append(s % n)
        up = 1 if s >= n else 0 
    if up == 1:
        a.append(1)
    step += 1

if step <= 30:
    print("STEP="+str(step))
else:
    print("Impossible!")
```


---

## 作者：Yo_haor (赞：29)

楼下的dalao都写的很好，接下来看看我的qwq

其实方法就两步：

### 1、判断是否是回文数。如果是则输出结果，否则执行第二步。

### 2、进行加法，然后重复第一步。

好了，可能还会有点懵，代码解释更容易理解qwq

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;//大家都懂就不说了
int n;//题目中的N进制
string m;//题目中M有100位！！！必须用字符串（不太懂楼下的dalao如何做的用unsigned long long过的？？？求指导qwq）
int ans;
int p;
bool hw(string st)//判断是否回文
{
	int ln=st.size(); 
	for(int i=0;i<ln/2;i++)
		if(st[i]!=st[ln-1-i])return 0;//若不了解这条公式，大家可以验证一下
	return 1;
}
int zhuan(char x)//将字符转成数字
{
	if(x>='0'&&x<='9')return int(x-48);
	else//以下判断是因为有16进制
	{
		if(x=='A')return 10;
		if(x=='B')return 11;
		if(x=='C')return 12;
		if(x=='D')return 13;
		if(x=='E')return 14;
		if(x=='F')return 15;
	}
}
char zhuan_h(int x)//将数字转回字符
{
	if(x>=0&&x<=9)return char(x+48);
	else//和上面一样
	{
		if(x==10)return char('A');
		if(x==11)return char('B');
		if(x==12)return char('C');
		if(x==13)return char('D');
		if(x==14)return char('E');
		if(x==15)return char('F');
	}
}
string bian(string a,string b)//做加法
{
	for(int i=0;i<b.size()/2;i++)//进行反转（楼下dalao用reverse(a.begin(), a.end());也是可行的，佩服）
		swap(b[i],b[b.size()-1-i]);
	string c="";//用来记录等会的和
	int jw=0,aw=0,bw=0,cw=0;
	for(int i=a.size()-1;i>=0;i--)
	{
		aw=zhuan(a[i]);//将a[i]转成数字
		bw=zhuan(b[i]);//将b[i]转成数字
		cw=(aw+bw+jw)%n;//看c字符串这一位是几
		if(aw+bw+jw>=n)jw=1;//判断是否进位
		else jw=0;
		c=zhuan_h(cw)+c;//将这一位的数转回字符放在c字符串，注意：要放在在前面，因为是倒着算的
	}
	if(jw==1)c='1'+c;//千万不要忘记了最后一位还会进位
	return c;//返回得出的结果
} 
int main()
{
	cin>>n;
	cin>>m;
	p=hw(m);//判断是否回文
	while(p==0)
	{
		if(ans>30)//如果方案数>30输出“Impossible!”
		{
			cout<<"Impossible!";
			exit(0);
		}
		ans++;//方案数累加
		m=bian(m,m);//将M进行做加法
		p=hw(m);//别忘了判断回文
	}
	cout<<"STEP="<<ans;//输出结果
	return 0; //完美结束
}
```


---

## 作者：hong123 (赞：28)

呃，看了一下其他题解好像都是用高精度，这里给一种不用高精度的。

先说一下思路：把给定的数当成字符串读入，然后用数组储存每一位的值，接着就是模拟。

```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    int p=1,ans=0,i,j,n,x,gg=0,jj,a[105],b[105];
    char c[105];
    scanf("%d",&n);
    scanf("%s",c);
    j=0;
    while(c[j]!=0)
    {
        if((c[j]>='0')&&(c[j]<='9'))a[j+1]=c[j]-'0';
        else a[j+1]=c[j]-'A'+10;/*先转化一下，方便进行后面的加法运算*/
        j++;
    }
    while(ans<=30)/*题目要求*/
    {
        gg=0;
        i=1;
```
/\*模拟该数正反相加\*/
```cpp
while(i<=j)
        {
            x=a[j-i+1]+a[i]+gg;
            gg=x/n;/*gg表示进位*/
            b[j-i+1]=x%n;
            i++;
        }
        if(gg!=0)b[0]=gg;
        if(gg!=0)
        {
            for(i=1;i<=j+1;i++)a[i]=b[i-1];
            j++;
        }
        else for(i=1;i<=j;i++)a[i]=b[i];
        ans++;
        i=1;
        jj=j;
        p=1;
        while(i<=jj/*判断是否为回文数*/
        {
            if(a[i]!=a[jj])p=0;
            i++;
            jj--;
        }
        if(p)
        {
            printf("STEP=%d",ans);
            return 0;
        }
    }
    printf("Impossible!");
    return 0;
}/*第一次写题解，可能说的不清楚。。。*/
```

---

## 作者：Clairad (赞：12)

1、这个题解稍作修改就可以完成任意进制。如果是任意进制，也就不需要在输入的时候判断了，统一输入字符串，转十进制的时候检测一下大小写字母就好了。

2、这个题其实就是常见的回文数题的小型扩展。如果真的深入理解了什么是进制，那么就很简单。

3、30次累加的数字不会超过10^16，2^63是9.223E18，所以64位整数就够用，不需要高精度。如果用了高精度会更复杂。

```c
#include <stdio.h>
#include <string.h>

int main()
{
    int sn;
    char nums[8] = { 0 };//题目中数字不超过100，2进制的100是7位数，留一个给尾零。
    long long num = 0;
    long long sum = 0, tmp;
    int i, j, len;

    scanf("%d", &sn);
    if (sn == 16)
    {
        scanf("%x", &num); //由于16比较特殊，单独拿出来处理
    }
    else
    { 
        scanf("%s", nums); //10以下的用字符串处理

        len = strlen(nums); //以下是手动任意进制转10进制，由于只有10以下所以忽略字母，实际只要加个判断可以36进制以下转10进制。
        for (i = 0; i < len; i++)
        {
            tmp = nums[i] - '0';
            for (j = 0; j < len - i - 1; j++) //其实就是pow函数
            {
                tmp *= sn;
            }
            num += tmp; //最终结果在num里，是字符串数转为十进制的结果。
        }
    }

    for (i = 0; i < 30; i++, sum = 0)
    {
        for (tmp = num; tmp; tmp /= sn)
        {
            sum = sum * sn + tmp % sn;
        }//这个循环其实可以完成任意进制的逆序。之前逆序的是十进制所以都是用的10。这里其实就是用十进制的运算完成了任意进制的数字逆序，其实就是短除法的特殊应用，短除法数字逆着写就是转换后的数字，那么顺着写就是倒过来的。

        if (sum == num)
        {
            break;
        }
        num += sum;
    }//题目是多进制，实际还是回文数的老循环。

    if (i == 30) //如果没有break出来，循环结束的i将会是30。
    {
        printf("Impossible!");
    }
    else
    {
        printf("STEP=%d", i);
    }

    return 0;
}
```

---

## 作者：瑜瑜 (赞：10)

**看了这么多dalao的题解，作为蒟蒻的我感觉就是 ~~看不懂~~** **好高端**
为了遵循暴力出奇迹的策略，我决定放弃思考，打个巧妙的暴力。

首先给出简单的回文数判断模板

```cpp
bool ch()
{
	for(int i=1;i<=r/2;i++)
	  if(a[i]!=a[r-i+1])
	  return 0;
	return 1;
}
```
一开始忽略了16进制的字母，所以WA了一个点，于是我决定用字符串输入
```
   cin>>n>>d;
	for(int i=0;i<strlen(d);i++)
	{
		if(d[i]=='A')//对十六进制特判
		a[i+1]=10;
		else if(d[i]=='B')
		a[i+1]=11;
		else if(d[i]=='C')
		a[i+1]=12;
		else if(d[i]=='D')
		a[i+1]=13;
		else if(d[i]=='E')
		a[i+1]=14;
		else if(d[i]=='F')
		a[i+1]=15;
		else a[i+1]=d[i]-'0';//写麻烦了，我只是单纯的不想用脑子^=^
	}
```
为了方便进制计算，我强烈建议**手写高精度**

这里需要一个小窍门，你会发现123和321在这道题的**计算**上是没有区别的，这使代码简单了许多

于是得出高精运算代码
（a+b=c,r是位数）
```
for(int i=1;i<=r;i++)
{
   b[i]=a[r-i+1];//b是a反过来
}
for(int i=1;i<=r;i++)
 {
	c[i]=c[i]+a[i]+b[i];//看上面解释
	if(c[i]>n-1)
	{
		c[i]%=n;
		c[i+1]++;
		if(i==r)
		k=r+1;//进位
   }
}
r=k;//记录新位数
```
基本的几大块写好，完整代码就出来了
```
#include <bits/stdc++.h>
using namespace std;
int n,m,r,k;
char d[10008];
int a[10008],b[10008],c[10008],step;
bool ch()
{
	for(int i=1;i<=r/2;i++)
	if(a[i]!=a[r-i+1])
	return 0;
	return 1;
}
int main()
{
    cin>>n>>d;
    
	for(int i=0;i<strlen(d);i++)
	{
		if(d[i]=='A')
		a[i+1]=10;
		else if(d[i]=='B')
		a[i+1]=11;
		else if(d[i]=='C')
		a[i+1]=12;
		else if(d[i]=='D')
		a[i+1]=13;
		else if(d[i]=='E')
		a[i+1]=14;
		else if(d[i]=='F')
		a[i+1]=15;
		else a[i+1]=d[i]-'0';
	}
	r=strlen(d);
    while(!ch()&&step<=30)
    {
	for(int i=1;i<=r;i++)
	 { 
             b[i]=a[r-i+1];
    	 }
    	for(int i=1;i<=r;i++)
    	{
	    c[i]=c[i]+a[i]+b[i];
	    if(c[i]>n-1)
	    {
		c[i]%=n;
		c[i+1]++;
		if(i==r)
		k=r+1;
	    }
	}
	r=k;
	for(int i=1;i<=r;i++)
	{
	    a[i]=c[i];
		  c[i]=0;//复制给a，准备下个循环
	}
	step++;
    }
    if(ch())
    cout<<"STEP="<<step;
    else cout<<"Impossible!";//千万不要打错，很亏！
}
```
总结一下，这道题基本可以当成模拟水题，但是几个坑点千万要注意

第一次写题解，求过（^0^）啦啦啦啦啦啦



---

## 作者：xiaosongliu (赞：7)

10进制转N进制还是要单独顶一个函数才行啊

```python
def tenToAn(n, x):
    a = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
    b = ''
    while n > 0:
        y = n % x  # 余数
        n //= x  # 商
        b = b + a[y]
    return b


def main():
    N = int(input())
    M = input()
    ans = 0
    while(M != M[::-1]) and ans <= 30:
        M = tenToAn(int(M, N) + int(M[::-1], N), N)
        ans += 1
    if ans <= 30:
        print('STEP=%s' % ans)
    else:
        print('Impossible!')


if __name__ == '__main__':
    main()
```

---

## 作者：weisiqian (赞：6)

###要注意！

1.回文数是输入的N进制形式是否是回文数，开始一直判断转换成10进制以后是不是回文数（不过应该大家不会犯这个错）

2.用JAVA写的！大数加法，任意进制转换都是调用的jdk API（纯粹为了熟悉jdk的API刷OJ）,不过代码挺短的！效率不是最好的！！！但是可以解决问题

```cpp
import java.math.BigInteger;
import java.util.Scanner;

public class Main{

    public static void main(String[] args) {
        try {
            Scanner sc = new Scanner(System.in);
            int N = Integer.parseInt(sc.nextLine());
            String strNumber = sc.nextLine();
            sc.close();

            for (int count = 1; count <= 30; count++) {
                BigInteger decimalNumber = new BigInteger(strNumber, N);
                // 反转后的数
                String reverseStrNumber = new StringBuffer(strNumber).reverse().toString();
                BigInteger reverseDecimalNumber = new BigInteger(reverseStrNumber, N);

                // 两个数的和
                BigInteger newDecimalNumber = decimalNumber.add(reverseDecimalNumber);
                String strNewNumber = newDecimalNumber.toString(N);

                int length = strNewNumber.length();
                String preHalf = strNewNumber.substring(0, length / 2);
                String lastHalf = length % 2 == 0 ? strNewNumber.substring(length / 2, length)
                        : strNewNumber.substring(length / 2 + 1, length);

                if (preHalf.equals(new StringBuffer(lastHalf).reverse().toString())) {
                    System.out.println("STEP=" + count);
                    return;
                } else {
                    strNumber = strNewNumber;
                }
            }

            System.out.println("Impossible!");
        } catch (Exception e) {
            System.out.println("STEP=1");
        }
    }
}
```

---

## 作者：Llf0703 (赞：6)

先用数组把数存起来（注意16进制）

然后高精度加法，每次判断一下是否为回文

注意：1.判断位数；

2.最后一个进位可能会把位数+1；

3.数字可能有0，故不能赋初值为0（不然影响位数判断）

代码及每步注解如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,c,d,e,jw;
int x[200],y[200],z[200];
string m;
int main()
{
    cin>>n>>m;
    memset(x,-1,sizeof(x));
    memset(y,-1,sizeof(y));
    memset(z,-1,sizeof(z));//初值赋为-1
    c=m.size();
    for (a=0;a<=c-1;a++)
    {
        if (m[a]-48>=0&&m[a]-48<=9) x[a+1]=m[a]-48;
        if (m[a]>=65) x[a+1]=m[a]-55;
    }//将读入数转为数组存储（注意16进制）
    for (b=1;b<=c;b++)
        if (x[b]==x[c+1-b]) d++;
        if (d==c) 
        {
            cout<<"STEP="<<0;
            return 0;
        }//先判断一次回文
    for (a=1;a<=30;a++)
    {
        for (b=150;1<=b;b=b-1)
        {
            if (x[b]!=-1)
            {
                c=b;
                break;    
            }
        }//判断位数
        jw=0;//**进位值归0**
        for (b=1;b<=c+1;b++)
        {
            if (b==c+1&&jw!=0) 
            {
                y[c+1]=jw;
                c++;
                break;
            }//最后一次加法有可能有进位，单独判断
            if (b<=c)
            {
                y[b]=x[b]+x[c+1-b]+jw;
                jw=y[b]/n;
                y[b]=y[b]%n;
            }
        }//加法
        for (b=1;b<=c;b++)
        x[b]=y[b];
        d=0;
        for (b=1;b<=c;b++)
        {
            if (x[b]==x[c+1-b]) d++;
        }//判断回文
        if (d==c) 
        {
            cout<<"STEP="<<a;
            return 0;
        }//是回文则输出步数和退出

    }
    cout<<"Impossible!";
    return 0;
}
```

---

## 作者：黎明行者 (赞：5)

```cpp
//这题实际上并不需要高精
//根据数据范围，n可能为2~10之间的整数数或者16，所以我们开long long，分情况讨论即可
//算法：无脑模拟
//若当前的m不是回文串，则对m进行操作，ans++，直到m变成回文串为止
#include <bits/stdc++.h>//万能库，在NOIP等比赛中千万不要用这个库
using namespace std;
typedef long long ll;//声明ll为long long的“别名”
ll n,m;
bool ps(ll a)//判断a是否为回文串
{
    ll i=1,j=1;
    while (i<=a) i*=n;//找到a的最大位
    i/=n;
    for (;i>=j;i/=n,j*=n) if ((a/i)%n!=(a/j)%n) return false;
    return true;
}
ll rev(ll a)//rev函数返回a翻转后的结果
{
    ll res=0;
    ll i=1,j=1;
    while (i<=a) i*=n;
    i/=n;
    for (;j<=a;i/=n,j*=n)
        res+=j*((a/i)%n);
    return res;
}
int main()
{
    scanf("%lld",&n);//读入long long时一定要用%lld
    if (n==10) scanf("%lld",&m);//n=10时直接scanf
    else if (n<10)//若进制数n非10则读入字符串，逐位处理
    {
        char rc[102];
        scanf("%s",&rc);
        ll tmp=0,b=1;
        for (int i=strlen(rc)-1;i>=0;i--)
        {
            tmp+=b*(rc[i]-'0');
            b*=n;
        }
        m=tmp;
    }
    else if (n==16)//16进制时特殊处理A~F的情况
    {
        char rc[102];
        scanf("%s",&rc);
        ll tmp=0,b=1;
        for (int i=strlen(rc)-1;i>=0;i--)
        {
            if ('0'<=rc[i]&&rc[i]<='9') tmp+=b*(rc[i]-'0');
            else tmp+=b*(rc[i]-'A'+10);//特殊处理A~F的情况
            b*=n;
        }
        m=tmp;
    }
    ll ans=0;
    while ((!ps(m)) && ans<=30)
    {
        ans++;
        m+=rev(m);
    }
    if (ans<=30)
        printf("STEP=%lld\n",ans);
    else
        printf("Impossible!\n");
    return 0;
}
```

---

## 作者：Q1284673918 (赞：4)

~~看看能不能水一篇题解~~

这是本萌新第一次交题解，不喜勿喷，谢谢。

首先看这道题的难度----普及-，十分友好，数据范围更加友好。讲解的话，我觉得直接看代码应该可以秒懂（这样说看来不行没过）

我也只能多说一些水话了。

首先看到这道题的第一感觉，应该是想用数组来存储每一位数字的大小，这道题N的数据范围2~10应该没什么问题，主要是16进制的10~15的表达它是用大写字母来表示的。

A=10；B=11；C=12；D=13；E=14；F=15；

这样子的话读入只能用字符串了。
后面的字符串转数字就是用a[i]-'0'即可，如遇16进制加个特判，就是A=10……这个，用个if语句就行了，如果不想打这么多，那就用ASCLL表来判断。
后面就是进位的问题了，自行看代码吧！！！

我觉得我已经水够了。

代码如下
```c
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[1000],n,b[1000],c[1000];
string m; 
int main()
{
	int k=30,ans=0,sum;//k=30，最多30次。
    cin>>n>>m; 
    int t=m.size();
    for(int i=0;i<t;i++)
    {
    	if(m[i]=='A')a[i+1]=b[t-i]=10;
    	if(m[i]=='B')a[i+1]=b[t-i]=11;
    	if(m[i]=='C')a[i+1]=b[t-i]=12;
    	if(m[i]=='D')a[i+1]=b[t-i]=13;
    	if(m[i]=='E')a[i+1]=b[t-i]=14;
    	if(m[i]=='F')a[i+1]=b[t-i]=15;
    	if(m[i]>='0'&&m[i]<='9')a[i+1]=b[t-i]=m[i]-'0';
    }//读入判断
	while(k--){
		sum=1;
		for(int i=1;i<=t;i++){
			c[i]=a[i]+b[i];
		}//先加，不要急着进位
		for(int i=1;i<=t;i++)if(c[i]>=n)c[i+1]+=1,c[i]-=n;//逢n进位
		if(c[t+1]>0)t++;
		for(int i=1;i<=t;i++)
		a[i]=c[i],b[t-i+1]=c[i];
		for(int i=1;i<=t;i++){//判断是否是回文
			if(c[i]!=c[t-i+1]){
				sum=0;
				break;//快速退出，不浪费多余时间
			}
		}
		ans++;
		if(sum==1){
			cout<<"STEP="<<ans;
			return 0;
		}
	}
	cout<<"Impossible!";
	return 0; 
} 
```

---

## 作者：yubing_lml (赞：3)

NO.12 看了一下题解，发现很少有同学用字符串string做的哇~那么我就来勉（yue）为（yue）其（yu）难（shi）发一波题解~

本题我只在add函数里用到一些高精度的知识，只是开了一个int数组存储每一位的结果，最后还是要转换成string返回滴~其余地方并没有用到高精度。

我的思路hin简单，就是通过判断——

(1）每次得到的字符串是否是回文串且\
(2)当前步数是否不大于30 

来决定是否要继续进行运算。

判断回文串的函数中用到reverse字符串反转函数，所以就非常方便啦~

getnum(char ch)函数返回该字符对应的数字；

getch(short int n)返回该数字对应的字符


代码简单且易于理解就不赘述了，大家自己看就好~
```cpp
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;

int n, ans = 0;
string str;

bool isReverse(string str)
{
	string ss = str;
	reverse(ss.begin(), ss.end());
	if (ss == str)
		return true;
	return false;
}

short getnum(char ch)
{
	if (ch >= '0'&&ch <= '9')
		return ch - '0';
	return ch - 'A' + 10;
}

char getch(short int n)
{
	if (n >= 0 && n <= 9)
		return n + '0';
	return n - 10 + 'A';
}

string add(string tmp)
{
	string rtmp = tmp;
	int rst[200];
	memset(rst, 0, sizeof(rst));
	reverse(rtmp.begin(), rtmp.end());
	int cnt = 0, x1, x2;               //cnt表示结果的位数
	for (int i = 0; i < rtmp.length(); i++)
	{
		x1 = getnum(tmp[i]);
		x2 = getnum(rtmp[i]);
		rst[cnt + 1] += (rst[cnt] + x1 + x2) / n;  //这两行
		rst[cnt] = (rst[cnt] + x1 + x2) % n;     //位置不能换！！！
		cnt++;
	}
	if (rst[cnt] != 0)  //是cnt不是cnt+1！！！
		cnt++;
	string ans;
	for (int i = cnt-1; i >= 0; i--)   //处理进位
		ans += getch(rst[i]);
	return ans;
}

int main()
{
	cin >> n >> str;  //n进制
	int step = 0;
	while (!isReverse(str) && step <= 30)
	{
		step++;
		str = add(str);
	}
	if (step <= 30)
		cout << "STEP=" << step;
	else
		cout << "Impossible!";
	cin >> n;
	return 0;
}
```

---

## 作者：HQcxf (赞：3)

写一个字符串处理的吧
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

bool IsDigit(char ch)
{
    return '0' <= ch && ch <= '9';
}

/*
返回两个字符串按指定基相加之和
我的意思是：
SumOf("4", "5", 7) -> "15"
SumOf("1", "10", 2) -> "11"
SumOf("A6", "B", 16) -> "B1"
*/
string SumOf(string a, string b, unsigned int base)
{
    unsigned int n = max(a.length(), b.length());
    
    //方便计算，补上前导0
    while (a.length() < n)
    {
        a = '0' + a;
    }
    while (b.length() < n)
    {
        b = '0' + b;
    }
    
    /*
    预处理A~F
    ‘A’ => (int)('9' + 1)
    'B' => (int)('9' + 2)
    'C' => (int)('9' + 3)
    以此类推
    */
    if (base > 10)
    {
        for (int i = 0; i < n; ++i)
        {
            if (!IsDigit(a[i]))
            {
                a[i] -= 7;
            }
            if (!IsDigit(b[i]))
            {
                b[i] -= 7;
            }
        }
    }
    
    string strOut;
    bool isFurther = false; //需要进一????？
    for (int i = n - 1; i >= 0; --i)
    {
        char ch = a[i] + b[i] - '0'; //初步按位取和
        if (isFurther) //收到贺电，知道要进一了
        {
            ++ch;
        }
        if (ch >= '0' + base) //告诉下一位，进一
        {
            ch -= base;
            isFurther = true;
        }
        else //告诉下一位，不要进一
        {
            isFurther = false;
        }
        strOut = ch + strOut;
    }
    
    //最后要进一的话还得在结果的最前面再补一个1
    if (isFurther)
    {
        strOut = '1' + strOut;
    }
    
  	/*
    逆处理A~F
    ‘A’ <= (int)('9' + 1)
    'B' <= (int)('9' + 2)
    'C' <= (int)('9' + 3)
    以此类推
    */
    if (base > 10)
    {
        for (char & ch : strOut)
        {
            if (!IsDigit(ch))
            {
                ch += 7;
            }
        }
    }
    return strOut;
}

//返回一个布尔值，该值指示输入的字符串是否回文串
bool IsHuiwen(string str)
{
    int length = str.length();
    for (int i = 0; i < (length + 1) / 2; ++i)
    {
        if (str[i] != str[length - 1 - i])
        {
            return false;
        }
    }
    return true;
}

//返回一个字符串，该字符串由输入字符串反转得到
string ReverseOf(string str)
{
    reverse(str.begin(), str.end());
    return str;
}

int main(int argc, char * argv[])
{
    int base;
    string str;
    cin >> base >> str;
    
    //如果原数就是回文数，还用算吗？
    if (IsHuiwen(str))
    {
        printf("STEP=%d\n", 0);
        return 0;
    }
    
    //计算！
    for (int i = 1; i <= 30; ++i)
    {
        str = SumOf(str, ReverseOf(str), base);
        if (IsHuiwen(str))
        {
            printf("STEP=%d\n", i);
            return 0;
        }
    }
    
    //30次的计算结果中都没有发现回文串
    printf("Impossible!\n");
    return 0;
}
```


---

## 作者：Raw_Aya9285 (赞：3)

本题的要点在于判回文和转换。

窝一开始的思路是，首先读入，然后转换成十进制，再写一个循环，判断这个数转过来再加上原数是否是回文数。代码大概是这样：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#define ull unsigned long long  //用ull可过
using namespace std;
int n,ans,tmp;
ull m;
string k;
ull turn(string num,int jz){  //转换成十进制的函数
    ull cnt=0;
    for(int i=0;i<num.size();i++){
        char c=num[i];
        if(c<='9'&&c>='0'){  //2~10进制
            cnt=cnt*jz+c-'0';
        }else{
            cnt=cnt*jz+c-'A'+10;  //特殊对待16进制
        }
    }
    return cnt;
}
ull reverse(ull cnt){  //翻转函数
    ull ans=0;
    while(cnt!=0){  //最基础的反转算法，不多讲
        ans*=10;
        ans+=(cnt%10);
        cnt/=10;
    }
    return ans;
}
int main(){
    cin>>n>>k;  //读入
    m=turn(k,n);  //转换
    while(reverse(m)!=m&&tmp<30){  //如果达不到要求且步数<30
        m+=reverse(m);  //相加
        tmp++;  //步数++
    }
    if(reverse(m)!=m){  //如果不是回文
        cout<<"Impossible!";  //impossible
    }else{
        cout<<"STEP="<<tmp;  //否则按题目输出
    }
    return 0;
}
```
但是这个代码是25pts，过了#3（即10进制数据）

后来调试了一下，运行#1的数据，结果是STEP=2：

```
19+91=110
38+83=121
```

很明显，错误是在算加法时把二进制数用十进制加法算了。

稍微改了一下。

由于turn函数等没有更改，窝不再讲。主要更改在于reverse和main.

```cpp
bool reverse(ull cnt){
    ans=0;  //反转后的数
    for(ull i=cnt;i;i/=n){  //当不等于0
        ans=ans*n+i%n;  //转换
    }
    return ans==cnt;  //比较
}
```
为了方便，窝在这里直接比较了，返回一个bool值。

注意for循环的更改，方便了运算，也修正了前面的问题。

```cpp
int main(){
    cin>>n>>k;
    m=turn(k,n);  //照常
    while(!reverse(m)&&tmp<30){  //如果不符合且步数还没到
        m+=ans;  //更改当前数
        tmp++;  //步数++
    }
    if(tmp==30){  //如果impossible的话tmp会显示30，而步数为30会显示29
        cout<<"Impossible!";
    }else{
        cout<<"STEP="<<tmp;
    }
    return 0;
}
```

完美AC.

如有不懂可以私信/评论联系窝更改哦QwQ

---

## 作者：huangzhikun (赞：3)

首先，这道题得用到进制转化和高精度加法。这道题有一个坑点就是16进制，16进制必须需要A,B,C,D,E,F进行表示10，11，12，13，14，15.其余的没有什么了贴代码


、、、cpp





```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>
# include <cstdlib>
using namespace std;
char a[10000]={0};
int c[10000]={0},al[10000]={0},n=0,top=0,sum=0,sign=0;
int abc()
{
    sum++;
    memset(c,0,sizeof(c)); //数组清零
    for(int i=1;i<=top;i++)
    {
        c[i]+=al[i]+al[top-i+1];
        if(c[i]>=n)   //超过n进制时进位 
        {
            c[i+1]++;
            c[i]=c[i]%n;
        }
    }
    if(c[top+1]!=0) //判断是否位数增加
    {
        top++;
    }
    for(int i=1,j=top;i<=j,j>=i;i++,j--) //判断回文 
    {
        if(c[i]!=c[j])
        {
            break;
        }
        if(i==j||j-i==1) //假如说回文，标记为1
        {
            sign=1;
        }
    }
    for(int i=1;i<=top;i++)
    {
        al[i]=c[i];
    }
}
int main()
{
    scanf("%d",&n);
    scanf("%s",a);
    for(int i=strlen(a)-1;i>=0;i--)
    {
        if(a[i]=='0'||a[i]=='1'||a[i]=='3'||a[i]=='4'||a[i]=='5'||a[i]=='6'||a[i]=='7'||a[i]=='8'||a[i]=='9') al[strlen(a)-i]=a[i]-'0';   //化成数字保存在数组中
        if(a[i]=='A'||a[i]=='B'||a[i]=='C'||a[i]=='D'||a[i]=='E'||a[i]=='F') al[strlen(a)-i]=a[i]-'A'+10;  //假如是十六进制，专门解决ABCDEF变成数字
    }
    top=strlen(a);
    for(int j=1;j<=30;j++)
    {
        abc(); //过程
        if(sign==1)//输出回文多少步，结束程序
        {
            printf("STEP=%d",sum);
            return 0;
        }
     } 
    printf("Impossible!"); //当超过30步时，输出。注意叹号
    return 0;
}
、、、
```

---

## 作者：hfctf0210 (赞：3)

此题有几个要注意的地方，别的不难：

1、不要被数据所迷惑，有16进制，而且是高精度（题目中说过）

2、16进制的处理（一定不能-'0'，否则会死的很惨！！！）

3、进位要注意（-10一样会死的很惨，可能还会更惨！！！！！！）

4、回文数的判断（一定要会，否则一切白搭）

5、注意超过30步一定要输出Impossible!，否则得不满！！

6、加后要注意可能会有最高位进位，否则，0分（这是最惨的！！！！！！！！！！）

7、用域/结构体存储，方便进位、转换等

```cpp
struct number
{int len,a[100001];};
int n;
number a1,a2;//数字位数为len，由0.1....len-1按从低位到高位存储
bool judge(number a)
{
for(int i=0;i<a.len/2;i++)//判断回文数
if(a.a[i]!=a.a[a.len-i-1])return 1;//不是回文数返回1
return 0;//是则返回0
}
number jia(number a,number b)
{
for(int i=0;i<a.len;i++)
{
a.a[i]+=b.a[i];//把b中的数依次加入a中，结果存放在a里
if(a.a[i]>=n)//重点1：一定是n，不是10
{a.a[i]-=n;a.a[i+1]++;}
}
if(a.a[a.len])a.len++;//重点2：重中之重，一定要判断最高位是否有进位。别的不写得部分分，此处不写完蛋！
return a;//结果存放在a中
} 
int main()
{
string st;
cin>>n>>st;
a1.len=st.length();//初始化a1的位数就是st的串长
int i,step=0;
for(i=0;i<a1.len;i++)
if(st[i]>='0'&&st[i]<='9')
a1.a[a1.len-i-1]=st[i]-'0';
else a1.a[a1.len-i-1]=st[i]-'A'+10;//串倒置存放，但不倒置也没有什么大碍，第2次就好了
while(judge(a1)&&step<=30)//重点3：每次的结果a1不是回文数且步数在30以内
{
a2.len=a1.len;//倒置数的性质：位数相等
for(i=0;i<a1.len;i++)a2.a[i]=a1.a[a1.len-i-1];//倒置存放在临时的结构体a2中
a1=jia(a1,a2);//相加结果在a1
step++;//莫忘步数+1（针对粗心的人）
}
if(step<=30)cout<<"STEP="<<step;//重点4：判断步数是否在30步以内，是就输出步数
else cout<<"Impossible!";//否则输出符号
}
```

---

## 作者：King__James (赞：2)

这题就是高精度加上进制转换。

其实就16进制麻烦了点，其他只需用一些普通的思想就行了。

ps:代码比楼下的短，其实不用那么的麻烦。

我的代码适合不会函数过程的初学者。

代码被我做了手脚，超代码党小心了！！









```cpp
var
  i,j,n,m,x,y,k,t:longint;
  a,b:array[1..200]of longint;
  s,sx:string;
  bool:boolean;
begin
  readln(n);
  readln(s);
  for i:=1 to length(s) do
    begin
      if (s[i]<='F')and(s[i]>='A') then
                                     case s[i] of
                                     'A':a[i]:=10;
                                     'B':a[i]:=11;
                                     'C':a[i]:=12;
                                     'D':a[i]:=13;
                                     'E':a[i]:=14;
                                     'F':a[i]:=15;
                                     end
                                   else
                                     val(s[i],a[i],x)；
    end;     //边输入边转换
  k:=0;x:=length(s);
  while (k<=30)and(not(bool))｛最多30次｝do
    begin
      k:=k+1;
      for i:=1 to x do
        b[x-i+1]:=a[i];
      for i:=1 to x+3 do
        begin
          a[i]:=a[i]+b[i];
          a[i+1]:=a[i] div n+a[i+1];
          a[i]:=a[i] mod n;
        end;//高精度加法
      for i:=200 downto 1 do
        if a[i] <> 0 then
                       begin
                         x:=i;
                         str(x,sx);
                         break;
                       end;//从最后开始，找到第一个不为0 的数
      i:=1;j:=x;bool:=true;
      while i<j  do
        begin
          if a[i]<>a[j] then
                          bool:=false;
          i:=i+1;
          j:=j-1;
        end;//判断是否是回文数
    end;
  if k<=30 then
             write('STEP=',k)
           else
             write('Impossible!');//注意感叹号是英文的
end.
```

---

## 作者：Zn_Hua (赞：2)

我的算法比较麻烦。。其实用别的办法的话简单得多（吧？

**用的高精度。。直接顺序乘逆序然后加个判断**

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
int a[1000000]={0},c[1000000],p,tot=0,ta=1,t1=1;
string n;
int power(int m[],int k)//请无视这个函数名..做别的题忘了改
{
    int l=0;
    memset(c,0,sizeof(c));
    for(int j=1;j<=ta;++j)
    {
        c[j]=m[ta-j+1]+m[j];
    }
   for(int t=1;t<=ta+1;t++)
   if(c[t]>=k)
   {
     c[t+1]+=c[t]/k;
     c[t]%=k;
   }
   ta=ta+1;
       while(1)
    {
        if(c[ta]==0)ta--;
        else break;
    }
    for(int t=ta;t>=1;--t)
    {
        if(c[t]==c[ta-t+1])l++;
        m[t]=c[t];
    }
    if(l==ta)return 1;
    else return 0;
}
void get(string z,int m[])
{
    int l1=z.length();
    for(int i=1;i<=l1;++i)
    {
            switch(z[l1-i])//要注意16进制时读入高精度要进行判断
            {
                case 'A':{m[i]=10;break;}
                case 'B':{m[i]=11;break;}
                case 'C':{m[i]=12;break;}
                case 'D':{m[i]=13;break;}
                case 'E':{m[i]=14;break;}
                case 'F':{m[i]=15;break;}
                default:m[i]=z[l1-i]-'0';
            }
    }
}
int main()
{
    cin>>p>>n;
    get(n,a);
    ta=n.length();
    do
    {
        tot++;
        if(tot==30){cout<<"Impossible!"<<endl;return 0;}
    }while(power(a,p)==0);
    cout<<"STEP="<<tot;
    return 0;
}
```

---

## 作者：Ufowoqqqo (赞：2)

简单的模拟水题（居然只有4个点=\_=|||）
首先输入：注意不要被样例骗了，仔细读题就会发现会有16进制的数据，判断处理一下就好；

尝试30次简单的N进制加法（假设每次都进位，数据输入时有100位也最多只有不到150位）

注意：由于c数组有累加的操作，每次都必须清0（以C、C++的MemSet或Pascal的FillChar）

因为不需要输出最终的结果，所以完全没有必要用字符串来储存，因为一系列的转化十分麻烦。

一句话：处理好细节，这题就一点都不难，一次Accepted不是梦！

下面提供一个耗时15ms，内存3137kb的Pascal程序。更优的0ms以及内存约2mb的解法请读者自行思考。

```delphi

var
 n,i,j:longint;
 ch:char;
 a,b,c:array [0..1000] of integer;
 t:boolean;
begin
 readln(n);
 repeat
  read(ch);
  inc(a[0]);
  if ch in ['0'..'9'] then a[a[0]]:=ord(ch)-48 else a[a[0]]:=ord(ch)-55
 until eoln;
 for i:=1 to 30 do
 begin
  for j:=1 to a[0] do b[j]:=a[a[0]-j+1];
  for j:=1 to a[0] do
  begin
   inc(c[j],a[j]+b[j]);
   c[j+1]:=c[j] div n;
   c[j]:=c[j] mod n
  end;
  if c[a[0]+1]>0 then c[0]:=a[0]+1 else c[0]:=a[0];
  t:=true;
  for j:=1 to c[0] div 2 do
   if c[j]<>c[c[0]-j+1] then
    begin
     t:=false;
     break
    end;
  if t then
   begin
    write('STEP=',i);
    halt
   end;
  a:=c;
  fillchar(b,sizeof(b),0);
  fillchar(c,sizeof(c),0)
 end;
 write('Impossible!')
end.

```

---

## 作者：Djsknjnd (赞：2)

涉及进制加法的一道题
直接用递归暴力模拟就能过
很多人刚拿到题目就想要转进制  
然后就打了一长串的代码

~~** _完全没有必要_ **~~......  

非十进制的加法其实很简单
只要用高精度的方法做可以
十六进制比较特殊  
包含了 A B C D E F 这六个字母  
这个点很多人用了特殊处理  
在加法运算时判定了字母的处理方式
运算之后的值也转成了字母的表示方式 
P党想必都是用Ord来判断的  
如果是数字  
就用Ord（x）-48  
如果是字母  
就用Ord（x）-64  
然后又打了一长串的代码

~~** _完全没有必要_ **~~......  

我们知道 '0'...'9' 的ASCLL码是 48...57  
所以  
只要用第 58 个字符来表示数字 10 就可以了
第 58 个字符是 ':'  
很多人感到很迷茫  
认为 10 不用 'A' 表示系统会判错  
码农们啊  
这题又不需要输出最后的回文数  
干什么非要用字母来表示呢  
还是看程序吧


----------迷人的分割线----------  
 

```
program palindrome(input,output);
 var
  p:boolean;
  s,m:string;
  i,j,n,l,add:longint;
```
```
 function judge(s:string):boolean;
  var
   i,l:longint;
  begin
   l:=length(s);
   for i:=1 to (l+1) div 2 do
    if s[i]<>s[l-i+1] then exit(false);
   exit(true)
  end; 
```
加了一个函数判断回文  
函数值是布尔
```
 begin
  readln(n);
  read(m);
  if judge(m) then begin
                    write('STEP=0');
                    exit
                   end;
```
读进去后先判断一遍回文  
放着不需要处理的特殊变量
```
  if n=16 then for i:=1 to length(m) do
                if m[i]>'9' then m[i]:=chr(ord(m[i])-7);
```
将十六进制中的字母转换成ASCLL码为第 58...63 个字符
```
  for i:=1 to 30 do
   begin
    l:=length(m);
    p:=false;//控制进位的变量 值为 True 就进位 默认为 False
    s:='';
    for j:=1 to l do
     begin
      add:=(ord(m[j])+ord(m[l-j+1])-96);
      if p then inc(add);
      p:=false;
      s:=chr(add mod n+48)+s;
      if add>=n then p:=true
     end;
    if p then s:='1'+s;//运算结束后的进位判断 因为是加法 所以只可能进一位
    if judge(s) then begin
                      write('STEP=',i);
                      exit
                     end;
    m:=s
   end;
  write('Impossible!')
 end.
```

---

## 作者：_YPC (赞：2)

看到这道题目我们首先就应该是一点都不慌的，有些人觉得这道题目涉及到了不同的进制，所以认为这道题目有点难度，但是呢，我们不妨换种思路，把这道题目理解成高精度加法，只是进位的条件由10改成了k而已，我们可以将A,B,C,D,E,F理解成10,11,12,13,14,15，举个例子，有个11进制的数字1A，我们可以把它认为是百位是1，个位是11的一个数字，这样就不需要再去考虑进制了。我们首先开个数组a表示结果，然后对a进行按照题目描述的高精度加法，check一趟，如果符合要求就输出，不符合要求就继续，如果步数超过了30就输出Impossible!

核心代码：

```cpp
inline void work(){
    int js=0;
    while (1){
        int b[55],c[55];
        memcpy(b,a,sizeof(b)),memset(c,0,sizeof(c));c[0]=a[0];
        for (int i=1;i<=c[0];i++)c[i]=a[c[0]-i+1];
//        for (int i=a[0];i>0;i--)printf("%d",b[i]);printf("\n");
//        for (int i=a[0];i>0;i--)printf("%d",c[i]);printf("\n");
        memset(a,0,sizeof(a));a[0]=c[0];
        for (int i=1;i<=c[0];i++){
            a[i]+=(b[i]+c[i]);
            a[i+1]+=(a[i]/k);
            a[i]%=k;
        }
        if (a[a[0]+1])a[0]++;
        js++;
//        for (int i=a[0];i>0;i--)printf("%d",a[i]);printf("\n");
        if (js>30){printf("Impossible!\n");exit(0);}
        if (check()){printf("STEP=%d\n",js);exit(0);}
    }
}
```

---

## 作者：Cet6_427 (赞：2)

这道题就是运用学习高精度加法时的思想 用字符串来存储数据 然后进行字符串的加法

在比较的时候注意判断 判断不成立ans++ 一直到30或者判断成功输出


```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int maxn = 1005;
int a[maxn], N;
void in(int a[]){
    string str;
    cin >> N >> str;
    a[0] = str.length();
    for(int i = 1; i <= a[0]; i++){
        if(str[a[0] - i] >= '0' && str[a[0] - i] <= '9') a[i] = str[a[0] - i] - '0';
        else a[i] = str[a[0] - i] - 'A' + 10;
    }
}
inline bool check(int a[]){
    //int a1[maxn];
    for(int i = 1; i <= a[0]; i++)
        if(a[i] != a[a[0] - i + 1]) return false;
    return true;
}
inline void Plus(int a[]){
    int b[maxn];
    for(int i = 1; i <= a[0]; i++) b[i] = a[a[0] - i + 1];
    for(int i = 1; i <= a[0]; i++) a[i] += b[i];
    for(int i = 1; i <= a[0]; i++){
        a[i + 1] += a[i] / N;
        a[i] %= N;
    }
    while(a[a[0] + 1] > 0) a[0]++;
    return;
}
int main(){
    in(a);
    if(check(a)){
        cout << "STEP=0";
        return 0;    
    } 
    int ans = 0;
    while(ans <= 30){
        ans++;
        Plus(a);
        if(check(a)){
            cout << "STEP=" << ans;
            return 0;
        } 
    }
    cout << "Impossible!";
    return 0;
}
```

---

## 作者：梦里调音 (赞：1)

害，被一道普及-整那么久。

其实题目不难。

算法：

 ## **大模拟**
 
> 先把高精度加法板子敲下来，然后熟练地运用STL的reverse函数即可。

主要难点：

$1.$ 高精度加法

$2.$ 进制转换

高精度加法的板子就不多说了。

来说一下这个进制转换。


```
for(int i=0;i<s.length();i++)
{
	if(s[i]<='Z'&&s[i]>='A')s[i]=s[i]-'A'+'0'+10;//转成10进制，字母就相当于+10
}
    
```

没错！我们只需要把字符串里每一个数字转换成 $10$ 进制

~~（因为我们习惯活在10进制的阴影下）~~

也许此时你把 $s$ 输出发现是什么奇奇怪怪的符号，但这并不影响判断。

最后在多唠叨一嘴，

	int('0')=48
    
嗯，新手可以理解一下 $ASC$ 码，很重要的。

代码相信大家都看得懂，不再赘述。


```
#include "bits/stdc++.h"
using namespace std;
int n;

string jia(string a,string b)//板子
{
	int i=0,j=0,k=0,x=0,s[1001]={0},ss[1001]={0},c[1001]={0};
	while(a.length()<b.length())a="0"+a;
	while(b.length()<a.length())b="0"+b;
	for(i=a.length()-1;i>=0;i--)s[a.length()-i-1]=a[i]-48;
	for(i=b.length()-1;i>=0;i--)ss[a.length()-i-1]=b[i]-48;
	for(i=0;i<a.length();i++){
		c[i]+=s[i]+ss[i];
		c[i+1]=c[i]/n;
		c[i]=c[i]%n;//注意是n
	}
	x=a.length();
	if(c[i]>0)i++;
	string ans="";
	for(j=i-1;j>=0;j--)ans+=char(c[j]+48);
	return ans;
}

int main(void)
{
	string s,t;
	cin>>n>>s;
	for(int i=0;i<s.length();i++)
	{
		if(s[i]<='Z'&&s[i]>='A')s[i]=s[i]-'A'+'0'+10;//转成10进制，字母就相当于+10
	}
	t=s;
	reverse(t.begin(),t.end());
	if(s==t)return puts("STEP=0"),0;
	int step=0;
	while("MOK_IS_MY_GF"&&step<=30)//只可意会不可言传
	{
		step++;
		s=jia(s,t);
		t=s;
		reverse(t.begin(),t.end());
		if(t==s)return printf("STEP=%d\n",step),0;
	}
	cout<<"Impossible!\n";
	return 0;
}
```


---

## 作者：Sinwind (赞：1)

# 1.分析

0. 变量定义：$cnt$记录步数，$sys$是几进制，$num$为输入的数($PS$:其实答主还不会高精度，只是因为字符串不需要考虑如何取得每位的数，只需对应位的字符进行即可，就选择了字符串)。

1. $is\_palindrome$函数：

- 判断字符串$a$是否为回文数，即是将$a[i]$与$a[len-1-i](i\in[0,len/2))$进行比较，若不相等，则不是回文数；若比较完后没有提前退出，则是回文数；

2. $to\_palindrome$函数：

- 当$num$不是回文数时，执行以下操作：

- 从后往前遍历$num($因为加法都是从低位加起$)$，将最后一个数与第一个数相加，相加的两个数$num1,num2$默认为数字，则将字符转化为数字$(eg:num1 = num[i] - '0')$；

- 特别地，若有字符为字母$(16$进制$)$，则将字母转化为数字$(eg:num1 = num[i] - 'A' + 10)$；

- 计算出本次相加的结果$(digit = num1 + num2 + up)($注意要加上一次的进位$)$，算出本次的进位$(up = digit / sys)$，以及进位后本位的数$(digit \%= sys)$，将本位的数转换为字符，存储到temp中，注意要放到$temp$之前$(eg:temp = (char)(digit + '0') + temp)$，特别地，大于$9$的$(16$进制$)$单独转换为字母；

- 若仍有进位未算$(up!=0)$，单独计算。


# 2.代码

```cpp
#include <iostream>
#include <string>
#include <cctype>

using namespace std;

int cnt = 0;    //步数
int sys;     	//进制
string num;     //输入的数

//判断字符串a是否为回文数
bool is_palindrome(string a)
{
	int len = a.length();

	for(int i = 0; i < len / 2; i++)
	{
		if(a[i] != a[len - 1 - i])
		{
			return false;
		}
	}

	return true;
}

//进行操作，变为回文数
void to_palindrome(void)
{
	while(!is_palindrome(num))
	{
		string temp;    		//新的数
		int len = num.length(); 	//原数的长度

		int up = 0;             //进位的数
		for(int i = len - 1; i >= 0; i--)
		{
			int digit;          //新的位上的数
			int num1, num2;     //相加的两个数

            //默认为数字
			num1 = num[i] - '0';
			num2 = num[len - 1 - i] - '0';
			//是字母
			if(isalpha(num[i]))
			{
				num1 = num[i] - 'A' + 10;
			}
			if(isalpha(num[len - 1 - i]))
			{
				num2 = num[len - 1 - i] - 'A' + 10;
			}
			
			digit = num1 + num2 + up;
            //进位的数
			up = digit / sys;
			//新的位上的数
			digit %= sys;
			
			if(digit >= 10)
			{
				temp = (char)(digit - 10 + 'A') + temp;
			}
			else
			{
				temp = (char)(digit + '0') + temp;
			}
		}
		//单独的进位
		if(up != 0)
		{
			if(up >= 10)
			{
				temp = (char)(up - 10 + 'A') + temp;
			}
			else
			{
				temp = (char)(up + '0') + temp;
			}
		}
		num = temp;
		cnt++;
		if(cnt > 30)
        {
        	return;
        }
	}
}

int main(void)
{
	cin >> sys >> num;

	to_palindrome();

    if(cnt <= 30)
    {
    	cout << "STEP=" << cnt;
	}
	else
	{
		cout << "Impossible!";
	}

	return 0;
}
```


---

## 作者：Ckkkk (赞：1)

这道题看似很水但要注意他并不是10进制加法，所以但你n<>10时，你要有n进制加法
这个过程跟高精很像
注意n>9的情况，一开始就因为这个75
有很多大佬用c++，写个Pascal
```pascal
var i,j,n,x:longint;s1,s2,s3:string;
    a,b,c:array[1..1000] of longint;
function pd(s:string):boolean;//判断回文数
var i:longint;
begin
  for i:=1 to length(s) div 2 do
    if s[i]<>s[length(s)-i+1] then exit(false);
  exit(true);
end;
begin
  readln(n);
  readln(s1);
  for i:=1 to 31 do
    begin
      if i=31 then begin write('Impossible!');halt;end;//当i=31时说明不能再30步内转化
      for j:=1 to length(s1) do s2:=s1[j]+s2;//将他从右往左读
      for j:=1 to length(s1) do if s1[j]<='9' then a[j]:=ord(s1[j])-48 else a[j]:=ord(s1[j])-55;//将每一个数字放入a数组
      for j:=1 to length(s2) do if s2[j]<='9' then b[j]:=ord(s2[j])-48 else b[j]:=ord(s2[j])-55;//同上
      for j:=length(s1) downto 1 do//过程很像高精
        begin
          c[j]:=a[j]+b[j]+x;//相加，别忘加上进位
          x:=c[j] div n;//算出余数
          c[j]:=c[j] mod n;//每一位的结果
        end;
      if x<>0 then s3:=chr(x+48);//别忘加首位
      for j:=1 to length(s1) do if c[j]<=9 then s3:=s3+chr(48+c[j]) else s3:=s3+chr(55+c[j]); //注意第二个测试点是16进制
      if pd(s3) then break;//是回文数退出
      s1:=s3;s2:='';x:=0;s3:='';//将结果放入s1，其余清空
    end;
  write('STEP=',i);//输出
end.


```
第一次写题解，请见谅


---

## 作者：xyqxyq (赞：1)

这个题首先字符串给的范围是1~100位，当然要照顾一下二进制嘛，其它的题解都说unsigned long long 就可以过了，但是本着严谨的精神，我们还是模拟一下好了。  
其实模拟也很简单，我们只需要模拟一个n进制的加法就可以了，把一个数存入数组之后，我们假设一个next为进位的数字，初始化为0，对于一个一百位的数字来说，我们在下标为0的位置存上这个数有几位，方便我们进行操作。  
而且我们也不需要设置一个中间的tmp数组用来存加法后的结果，我们直接把它的反转加在它自身上就可以了，每一位对应相加，并且加上next进位，如果此时相加后的结果
n[i]/进制 >0 说明，n[i]大于进制了，此时next就应该等于n[i]/进制，如果小于0的话，就说明不需要进位，把next设置为0，然后进行下一位的相加就可以了。  
对于一个100位的数来说，我们可以从低到高位在数组中存储，然后for循环就可以从1到n了，比较自然一点，然后对于一个回文来说也不会有影响。  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
int a[105],b[105],bins,k=0;
char s[105];

void BinsAdd(int *n,int *m)
{
	int next=0;
	for (int i=1;i<=n[0];i++) {
		n[i]+=next+m[i];
		if (n[i]/bins) {
			next=n[i]/bins;
			n[i]%=bins;
		}
		else 
			next=0;
	}
	if (next) {
		n[a[0]+1]=next;
		n[0]+=1;
	}
}

bool isPadro(int *n) 
{
	for (int i=1;i<=n[0]/2;i++) {
		if (n[i]!=n[n[0]+1-i])
			return 0;
	}
	return 1;
}

int main()
{	
	scanf("%d",&bins);
	scanf("%s",s);
	a[0]=strlen(s);
	for (int i=0;i<a[0];i++) {
		if (s[i]>='A'&&s[i]<='F')
			a[i+1]=s[a[0]-1-i]-'A'+10;
		else if (s[i]>='a'&&s[i]<='f')
			a[i+1]=s[a[0]-1-i]-'a'+10;
		else
			a[i+1]=s[a[0]-1-i]-'0';
	}
	if (isPadro(a)) {
		printf("STEP=%d\n",0);
		return 0;
	}
	while (k<=30) {
		for (int i=1;i<=a[0];i++) {
			b[a[0]+1-i]=a[i];
		}
		BinsAdd(a,b);
		k++;
		if (isPadro(a)) {
			printf("STEP=%d\n",k);
			return 0;
		}
	}
	printf("Impossible!\n");
	return 0;
}

```

---

## 作者：Rika (赞：1)

对于16进制的处理可以使用-'A'+10而不必一个个判断。这份代码里面使用的是字符串操作，可以不必这样做，应该会方便一些。进位的时候数组resize一下，扩大一位（我扩大了两位）。然后输出的Impossible!的叹号是半角的。

>

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
string KaitenKapatsu(int n, string ipt0);
bool isKaiten(string ipt);
void solve(int n, string ipt);
int main()
{
    int n;
    string ipt;
    cin >> n >> ipt;
    solve(n, ipt);
    getchar(); getchar();
    return 0;
}
string KaitenKapatsu(int n, string ipt0) {
    for (int i = 0; i < ipt0.size(); i++) {                //读入数据并转为char[]
        if (ipt0[i] > 57)                                //十六进制的处理
            ipt0[i] -= 7;
        ipt0[i] -= '0';
    }
    string ipt = ipt0;
    for (int i = 0; i < ipt0.size(); i++)                //倒序
        ipt[i] = ipt0[ipt0.size() - i - 1];
    string ipt2 = ipt;
    for (int i = 0; i < ipt.size(); i++) {                //倒序相加
        ipt2[i] += ipt0[i];
    }
    ipt2.resize(ipt2.size() + 2);
    for (int i = 0; i < ipt2.size() - 1; i++) {            //进位
        ipt2[i + 1] += ipt2[i] / n;
        ipt2[i] %= n;
    }
    for (int i = 0; i < ipt2.size(); i++) {                //还原为stirng
        if (ipt2[i] >= 10)                                //十六进制的还原
            ipt2[i] += 7;
        ipt2[i] += '0';
    }
    bool judge = 0;
    for (int i = ipt2.size()-1; i >= 0; i--)             //去除前导零
        if (ipt2[i] == '0'&&judge == 0) { ipt2.erase(i, 1); }
        else { judge = 1; }
    ipt.resize(ipt2.size());                            //返回值resize预备输出
    for (int i = 0; i < ipt2.size(); i++)                //倒序
        ipt[i] = ipt2[ipt.size() - 1 - i];
    return ipt;
}
void solve(int n,string ipt){                            //统计步数
    int cnt = 0;
    while (isKaiten(ipt) == 0 && cnt<31) {
        ipt = KaitenKapatsu(n, ipt);
        cnt++;
    }
    if (cnt > 30){cout << "Impossible!";}
    else { cout << "STEP=" << cnt; }
}
bool isKaiten(string ipt) {                                //判断是不是回文
    for (int i = 0; i < ipt.size(); i++) 
        if (ipt[i] != ipt[ipt.size() - i - 1])return 0;
    return 1;
}
```

---


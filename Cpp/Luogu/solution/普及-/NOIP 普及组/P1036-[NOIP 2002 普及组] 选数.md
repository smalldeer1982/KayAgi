# [NOIP 2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

## 样例 #1

### 输入

```
4 3
3 7 12 19
```

### 输出

```
1
```

# 题解

## 作者：dbxxx (赞：2505)

最初写于 2018 年 11 月，于 2025 年 2 月重构。

本题的难点在于如何用代码实现**不重不漏地枚举每种选数方案**，这个问题的答案是**不降原则**。下面开始解释。

举一个例子：$a$ 是一个长度为 $6$ 的序列 $1, 2, 3, 4, 5, 6$，想要不重不漏地枚举所有选择 $3$ 个数的方案，如何操作？

一种**错误**的策略是：

- 第一个数在 $1 \sim 6$ 枚举，设为 $x_1$。
- 第二个数在 $1 \sim 6$ 枚举，且不选择 $x_1$（因为同一个数不能选两次）。
- 第三个数在 $1 \sim 6$ 枚举，且不选择 $x_1$ 和 $x_2$。

这种策略不正确在哪呢？答案是这样的统计**重复了**。比如 $2, 3, 5$ 与 $3, 2, 5$，$2, 5, 3$ 实际上是一种选法，但我们统计时却认为他们不同，分别统计了一次，这不是我们期望的。

解决这个问题的策略即**不降原则**，具体如下：

- 第一个数在 $1 \sim 6$ 枚举，设为 $x_1$。
- 第二个数在 $x_1 + 1 \sim 6$ 枚举，设为 $x_2$。
- 第三个数在 $x_2 + 1 \sim 6$ 枚举，设为 $x_3$。

这样以来，每种选法都会被不重不漏地统计一次。比如 $2, 3, 5$ 与 $3, 2, 5$，$2, 5, 3$ 中，只有 $2, 3, 5$ 会被统计到：

- $3, 2, 5$ 无法枚举到，是因为第一个数是 $3$ 时，第二个数从 $4$ 开始枚举，取不到 $2$。
- $2, 5, 3$ 无法枚举到，是因为第二个数是 $5$ 时，第三个数从 $6$ 开始枚举，取不到 $3$。

具体而言，利用**每次选数时，不选择比上一次选择小的数**的方法，达到**每一次枚举到的方案，顺序一定不降**，从而达到**枚举不重复**的目的，这就是**不降原则**。

这是枚举中基础，但又非常重要的思想，不局限于信息学。文化课的数学科目中，会做排列组合计数题的人，一定会枚举；而要想会枚举，一定要掌握不降原则。希望读者仔细吸收一下这个基本技能。

现在我们回归原题的样例。$3, 7, 12, 19$，如何不重不漏地枚举出所有选择三个数的情况？相信你已经有答案了：

- 第一个数选 $3$ 时：
    - 第二个数要从 $7$ 开始枚举。
    - 第二个数选 $7$ 时：
        - 第三个数要从 $12$ 开始枚举。
        - 第三个数选 $12$。此时选择：$3, 7, 12$，检验和是否为质数：$22$，否，不统计答案。
        - 第三个数选 $19$。此时选择：$3, 7, 19$。检验和是否为质数：$29$，是，统计答案。
    - 第二个数选 $12$ 时：
        - 第三个数要从 $19$ 开始枚举。
        - 第三个数选 $19$。此时选择：$3, 12, 19$。检验和是否为质数：$34$，否，不统计答案。
    - 第二个数选 $19$ 时，第三个数无法选择，结束。
- 第一个数选 $7$ 时：
    - 第二个数要从 $12$ 开始枚举。
    - 第二个数选 $12$ 时：
        - 第三个数要从 $19$ 开始枚举。
        - 第三个数选 $19$。此时选择：$7, 12, 19$。检验和是否为质数：$38$。否，不统计答案。
    - 第二个数选 $19$ 时，第二个数选 $19$ 时，第三个数无法选择，结束。
- 第一个数选 $12$ 时：
    - 第二个数要从 $19$ 开始枚举。
    - 第二个数选 $19$ 时，第三个数无法选择，结束。
- 第一个数选 $19$ 时：
    - 第二个数无法选择，结束。

上面的选择过程存在明显的**递归**特征，因此我们考虑使用 dfs 实现程序。但观察上面的过程，我们又出现了两个问题：

- 在人工操作时，我们很容易看出枚举的顺序：$3 \to 7 \to 12 \to 19$。但在具体的代码实现中，这几个数都存在序列 $a$ 里，**选数在代码中如何呈现**？
- 第一个数选 $12$ 和 $19$ 两种情况，由于后面根本不存在两个数字可以选择，所以这样的选择一定无效，**能否直接优化掉**？

对于第一个问题，答案是：**不对具体的数字不降原则，而是对下标不降原则**。即，我们每次不是选择**具体值比上次大**的数字，而是选择**下标比上次大，即在 $a$ 中出现的更靠后**的数字。这样以来，每一步的选择都是在**枚举 $a$ 的一段后缀**，从而每次选数时，只需明确从 $a$ 的哪个位置开始枚举。这可以在 dfs 中传参做到，具体可见代码。

注意两种不降原则的差别。如 $a = 7, 3, 12, 19$ 时，$3, 7, 12$ 将不再被我们枚举到，被枚举到的是 $7, 3, 12$。

对于第二个问题，在经过第一个问题的改动后，我们可以通过简单的判断对这种情况进行剪枝。比如对于长度为 $4$ 的 $a$ 想选择 $3$ 个数，那么第一次选择就不要选择太靠后的 $a_3$ 和 $a_4$。这样以来，每一步选择在枚举 $a$ 的一段后缀的基础上，**又把太靠后的后缀优化掉了**，现在我们每次选数枚举的是 **$a$ 的一段区间**。


```cpp
#include <bits/stdc++.h>

inline bool isprime(int x) { // 判断一个数是否是素数
	if (x == 1) return false; // 注意这步特判是必需的
	for (int i = 2; i * i <= x; ++i)
		if (x % i == 0)
			return false;
	return true;
}

const int N = 25;
int a[N], ans, n, k;

void dfs(int now, int sum, int sid) {
	// 现在已经选了 now 个数，当前总和为 sum
	// sid 是这次选数的起始下标，即我们从 a[sid] 开始选数枚举
	if (now == k) {
		if (isprime(sum))
			++ans;
		return ;
	}

	// 已经选了 now 个数，这次选完后，还有 k - now - 1 个数要选择
	// 因此 a[n - (k - now - 1)] 即 a[n - k + now + 1] 是枚举的终点
	for (int i = sid; i <= n - k + now + 1; ++i)
		dfs(now + 1, sum + a[i], i + 1);
	return ;
}

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &a[i]);
	dfs(0, 0, 1);
	printf("%d\n", ans);
	return 0;
}
```

如果这篇题解帮助到您，请给这篇题解点个赞，谢谢！

---

## 作者：Chengqijun2012 (赞：79)

一道很好的组合题，做这题之前建议先去做[P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)。

组合就是在全排列的基础上增加了一个**新构造的组合在排序后必须与之前的所有已确定的组合不重复**的条件。

也正是因为这一点，所有被确定的组合都必须保持升序。如果不是升序，那么在ta之前就一定有一个已确定的组合与之重复。

AC Code：
```cpp
#include <iostream>
using namespace std;
int n, m;
int a[25];
long long ans;

bool prime(int x){      //判断素数不必多说
    if(x == 1 || x != 2 && x % 2 == 0) return 0;
    for(int i = 3; i * i <= x; i++) if(x % i == 0) return 0;
    return 1;
}

void DFS(int k, int s, int x){      //k表示当前已选的数的个数，s表示这几个数的和，x表示上一个选择的数的下一位
    if(k == m){
        if(prime(s)) ans++;
        return;
    }
    for(int i = x; i < n; i++) DFS(k + 1, s + a[i], i + 1);      //从x开始选，保证是升序
}

int main(){
    cin >> n >> m;
    for(int i = 0; i < n; i++) cin >> a[i];
    DFS(0, 0, 0);
    cout << ans << "\n";
    return 0;
}
```
本蒟蒻的第一篇题解，望管理员大大通过qwq。

---

## 作者：haohao_com (赞：30)

### 题目分析

本题的核心问题是从给定的 $n$ 个整数中任选 $k$ 个整数进行相加，然后统计这些和中为素数的组合的数量。下面我们从输入输出、问题求解思路等方面进行详细分析。

#### 输入输出分析
- **输入**：
    - 第一行包含两个用空格隔开的整数 $n$ 和 $k$，其中 $1\leq n\leq 20$ 且 $k < n$。$n$ 表示整数的总数，$k$ 表示需要选取的整数个数。
    - 第二行包含 $n$ 个整数 $x_1,x_2,\cdots,x_n$，每个整数的范围是 $1\leq x_i\leq 5\times 10^6$。
- **输出**：
    - 输出一个整数，表示和为素数的组合的种类数。

#### 问题求解思路分析
要解决这个问题，主要分为两个关键步骤：一是找出从 $n$ 个整数中选取 $k$ 个整数的所有组合；二是判断每个组合的和是否为素数。

##### 组合选取
由于 $n$ 的范围较小（$1\leq n\leq 20$），我们可以使用深度优先搜索（DFS）算法来枚举所有可能的组合。深度优先搜索是一种通过递归的方式遍历所有可能状态的算法，非常适合解决组合问题。在本题中，我们从第一个数开始，依次尝试选取每个数，并递归地选取后续的数，直到选取了 $k$ 个数为止。

##### 素数判断
对于每一种组合的和，我们需要判断它是否为素数。素数是指大于 1 且只能被 1 和自身整除的正整数。判断一个数 $num$ 是否为素数，我们可以从 2 开始到 $\sqrt{num}$ 进行遍历，如果 $num$ 能被其中任何一个数整除，则它不是素数；否则，它是素数。

### 代码实现思路

#### 代码整体结构
代码主要由三个部分组成：素数判断函数、深度优先搜索函数和主函数。

#### 各部分详细解释

##### 素数判断函数 `isPrime`
```cpp
bool isPrime(int num) {
    if (num < 2) return false;
    for (int i = 2; i <= sqrt(num); i++) {
        if (num % i == 0) return false;
    }
    return true;
}
```
- 首先判断 `num` 是否小于 2，如果小于 2，则直接返回 `false`，因为素数定义要求大于 1。
- 然后从 2 开始到 $\sqrt{num}$ 进行遍历，如果 `num` 能被其中任何一个数整除，则返回 `false`，表示不是素数。
- 如果遍历完都没有找到能整除 `num` 的数，则返回 `true`，表示是素数。

##### 深度优先搜索函数 `dfs`
```cpp
void dfs(int start, int cnt, int sum) {
    if (cnt == k) {
        if (isPrime(sum)) {
            ans++;
        }
        return;
    }
    for (int i = start; i < n; i++) {
        dfs(i + 1, cnt + 1, sum + nums[i]);
    }
}
```
- `start` 表示当前搜索的起始位置，`cnt` 表示已经选取的数的个数，`sum` 表示当前选取的数的和。
- 当 `cnt` 等于 $k$ 时，说明已经选取了 $k$ 个数，此时调用 `isPrime` 函数判断 `sum` 是否为素数，如果是则将结果 `ans` 加 1。
- 从 `start` 开始遍历数组，递归调用 `dfs` 函数，更新 `start` 为 `i + 1`，`cnt` 为 `cnt + 1`，`sum` 为 `sum + nums[i]`，以继续选取下一个数。

##### 主函数 `main`
```cpp
int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    dfs(0, 0, 0);
    cout << ans << endl;
    return 0;
}
```
- 首先读取输入的 $n$ 和 $k$，以及 $n$ 个整数。
- 调用 `dfs` 函数开始搜索，初始时 `start` 为 0，`cnt` 为 0，`sum` 为 0。
- 最后输出结果 `ans`。

### 复杂度分析

#### 时间复杂度
- 组合选取的时间复杂度为 $O(C_{n}^k)$，其中 $C_{n}^k=\frac{n!}{k!(n - k)!}$ 表示从 $n$ 个数中选 $k$ 个数的组合数。
- 对于每一种组合，判断素数的时间复杂度为 $O(\sqrt{m})$，其中 $m$ 为选取的数的和的最大值。
- 因此，总的时间复杂度为 $O(C_{n}^k \sqrt{m})$。

#### 空间复杂度
- 主要的空间开销是递归调用栈的空间，递归的深度最大为 $k$，因此空间复杂度为 $O(k)$。

创造不易，点个赞再走吧

---

## 作者：kunkun127 (赞：11)

## 题目分析

题目要求从给定的 $n$ 个整数中选出 $k$ 个数，使得它们的和是一个素数。需要计算所有可能的选数方案中满足条件的方案数。

## 解题思路

考虑使用 DFS。递归生成所有可能的组合。`start` 表示当前选择的起始位置，`sum` 表示当前组合的和，`step` 表示已经选择的数的个数。对于每一种组合，计算它们的和，并判断这个和是否是素数。如果和是素数，那么答案加一。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, cnt, a[25];

bool is_prime(int x) 
{
    if (x < 2) return false;
    for (int i = 2; i * i <= x; i++) if (x % i == 0) return false;
    return true;
}

void dfs(int start, int sum, int step) 
{
    if (step == k) 
	{
        if (is_prime(sum)) cnt++;
        return;
    }
    for (int i = start; i <= n; i++) dfs(i + 1, sum + a[i], step + 1);
	return ; 
}

int main() 
{
    cin >> n >> k; 
    for (int i = 1; i <= n; i++) cin >> a[i];
    dfs(1, 0, 0);
    cout << cnt << endl;
    return 0;
}
```

---

## 作者：XsIeEiKcEk (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P1036)

## 题目大意

有 $n$ 个数，问有几组 $k$ 个数的和为质数。

## 思路

从第一个开始搜索，直到个数等于 $k$ 时再判断，若为质数，答案加一，再回溯。

## [AC](https://www.luogu.com.cn/record/205188734) CODE


```cpp
#include<iostream>
using namespace std;
int n,k,x[21],s[20],answer;
bool prime(int y){//判断是否为质数
	if(y<2)return 0;//特判
	if(y<4)return 1;//特判
	for(int i=2;i*i<=y;i++){
		if(y%i==0)return 0;
	}
	return 1;
}
void search(int sum,int num){//搜索
	if(sum==k){//若已经填完
		int ans=0;
		for(int i=1;i<=k;i++)ans+=s[i];
		if(prime(ans))answer++;//判断和是否为质数
		return ;
	}
	for(int i=num;i+(k-(sum+1))<=n;i++){//i+(k-(sum+1))<=n是判断i之后是否还有足够使填的数等于k的个数
		s[sum+1]=x[i];//填入
		search(sum+1,i+1);//继续搜索
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>x[i];//输入
	search(0,1);//开始搜索
	cout<<answer;//输出结果
	return 0;
}
```

---

## 作者：long_long_inf (赞：6)

# 思路

很明显，$n$ 的范围非常小，于是我们就可以枚举出所有可能，然后一一判断。

## 枚举

对于枚举的话，用深搜比较好，全排列函数虽然码量小，但是会产生很多重复的判断，所以建议使用深搜。

## 判断

判断就比较简单了，先求和，然后开根判断是不是质数。

# 代码

```cpp
#include <iostream>
using namespace std;
int n, k, a[26], w[26];
long long cnt = 0;
bool cIP()
{
	long long x = 0;
	for (int i = 1; i <= n; i++)
	{
		x += a[i] * w[i];
	}
	if (x < 2) return false;
	for (long long i = 2; i * i <= x; i++)
	{
		if (x % i == 0) return false;
	}
	return true;
}
int sum()
{
    int sum = 0;
    for (int i = 1; i <= n; i++) sum += a[i];
    return sum;
}
void dfs(int x)
{
	if (x > n)
	{
		if (cIP() && sum() == k) cnt++;
		return;
	}
	a[x] = 0;
	dfs(x + 1);
	a[x] = 1;
	dfs(x + 1);
}
int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> w[i];
	dfs(1);
	cout << cnt << endl;
    return 0;
}
```

---

## 作者：___define___ (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P1036)

## 题目大意

从 $n$ 个数中选出 $k$ 个数，求这 $k$ 个数之和为素数的情况有几种。

## 思路

由于数据范围较小，考虑用深搜（深度优先搜索）做这一道题。

为了防止计算和的时候计算重复的数，我们可以用一个布尔类型的数组判断这个数是否被计算过，每次加完一个数后就标记这个数被计算过，后面只需计算没有被标记过的数就行了。

最后统计和为素数的情况的种数即可。

## AC Code

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,k,a[105],ans,l[105];
bool z[500005];
bool s(ll sum){
    for(ll i=2;i*i<=sum;i++)
        if(sum%i==0){return 0;break;}
    return 1;
}
void f(ll x,ll last){
    if(x==k+1){
        ll sum=0;
        for(int i=1;i<x;i++)
            sum+=a[i];
        if(s(sum)) ans++;
    }
    for(int i=last+1;i<=n;i++)
        if(!z[i]){
            z[i]=1;
            a[x]=l[i];
            f(x+1,i);
            z[i]=0;
        }
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        cin>>l[i];
    f(1,0);
    cout<<ans;
    return 0;
}
```

---

## 作者：Chbin (赞：4)

题目给了你 $n$ 个数，让你在这 $n$ 个数中选择 $k$ 个数，使这 $k$ 个数的和是一个质数（也叫素数），问你有几个组合符合上述条件。

题目中各项数据的范围都偏小，因此可以使用 DFS 算法（深度优先搜索算法）。搜索过程中，我们用数组中的数一个一个尝试，直到选足 $k$ 个数。
```cpp
void dfs(int x,int y,int z)//x记录现在到了第几个数，y记录选了几个数,z记录所选数的和
{
    if(y==k)
    {
        if(!zs(z)) s++;//zs函数用来判断结果是否为质数
        return;//返回上一步
    }
    for(int i=x+1;i<=n;i++)//一个一个数试
        dfs(i,y+1,z+a[i]);
}
```
再写一个函数判断结果是否是质数。

```cpp
bool zs(int m)
{
    bool b=0;
    for(int i=2;i<m;i++)
        if(m%i==0) {b=1;break;}//若不是质数，标记为1
    return b;//质数返回0，否则返回1
}
```
再加上输入输出和调用 dfs 函数就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[25],s;
bool zs(int m)
{
    bool b=0;
    for(int i=2;i<m;i++)
        if(m%i==0) {b=1;break;}//若不是质数，标记为1
    return b;//质数返回0，否则返回1
}
void dfs(int x,int y,int z)//x记录现在到了第几个数，y记录选了几个数,z记录所选数的和
{
    if(y==k)
    {
        if(!zs(z)) s++;//zs函数用来判断结果是否为质数
        return;//返回上一步
    }
    for(int i=x+1;i<=n;i++)//一个一个数试
        dfs(i,y+1,z+a[i]);
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    dfs(0,0,0);
    cout<<s;
    return 0;
}
```

---

## 作者：xzy_awa (赞：4)

# 题解：P1036 [NOIP 2002 普及组] 选数

博客同步链接：<https://china-fan.github.io/2025/02/26/LGP1036TJ.html>。

## 思路

由于数据小，考虑暴力搜索每种可能并判断总和是否为素数。

详细一点（定义 $m$ 为选的数个数，$s$ 为当前的和，$x$ 为下一个选的数的位置，$dfs(m, s, x)$ 为搜索函数，$ans$ 为种类数即题目所求）：
1. 确定当前选择的数；
2. 从 $x$ 遍历 $i$ 至整个数组 $a$，每次搜索 $dfs(m + 1, s + a_i, i + 1)$；
3. 当 $m = k$ 了，判断 $s$ 是否为素数：
   - 是：$ans + 1$；
   - 不是：结束搜索，因为后面没有继续搜索的必要。


## 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
long long n, k, ans, a[25];
bool check(long long x) // 判断 x 是否为质数
{
    for (long long i = 2; i * i <= x; i++) // 避免使用 sqrt() 函数，减少精度误差
    {
        if (x % i == 0) // 等同于 x % i == 0
            return false;
    }
    return true;
}
void dfs(long long m, long long s, long long x) // m：选的数个数，s：当前的和，x：下一个选的数的位置
{
    if (m == k)
    {
        if (check(s)) // 如果当前的和是质数，则 ans++
            ans++;
        return;
    }
    for (long long i = x; i < n; i++) // 从 x 开始
        dfs(m + 1, s + a[i], i + 1);
    return;
}

int main()
{
    cin >> n >> k;
    for (long long i = 0; i < n; i++)
        cin >> a[i];
    dfs(0, 0, 0); // 初始状态：选的数个数为 0，当前的和为 0，下一个选的数的位置为 0
    cout << ans << endl;
    return 0;
}
```

---

## 作者：zhangzirui66 (赞：3)

## 闲话
本文同步发布在 [cnblogs](https://www.cnblogs.com/zhangzirui66)。

---

$n \le 20$ 首先想到搜索，使用 dfs 搜出所有搭配的和，判断是否为素数即可，具体见注释。

代码复杂度约为 $O(2^n\sqrt{2^n})$，实际完全跑不满：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, a[25], use[25], ans;
bool prime(int x){// 基本的判断素数
	if(x < 2) return 0;
	for(int i = 2; i * i <= x; i ++){
		if(x % i == 0) return 0;
	}
	return 1;
}
void dfs(int dep, int sum){ // dep：搜了几个数，sum：当前总和
	if(dep == k + 1){
		ans += (int)(prime(sum));// 一个简写，因人而异
		return;
	}
	for(int i = use[dep - 1] + 1; i <= n; i ++){
		use[dep] = i;// use：上次选的是第几个，避免重复
		dfs(dep + 1, sum + a[i]);
	}
}
int main(){
	cin >> n >> k;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
	}
	dfs(1, 0);
	cout << ans;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：2)

本题考查算法：搜索，质数（素数）。  
我在这里给大家介绍一种 DFS 的写法：
- 首先这个数 $a_i$ 要么选，要么不选，而且只能选 $k$ 个数。
- 为了保证不会出现选 $2,3,5$，再选 $3,2,5$ 的情况，我们可以让每种情况中的数保持升序。即 $k=3,lattice_1<lattice_2<lattice_k$。
- 我们需要在选这个数的同时记录当前的和 $Addition$，到了判断和的时候，我们可以再写一个判断函数的函数，判断当前这种情况是否满足要求。  
判断质数：

```cpp
bool is_Prime(int x){
    if(x<=1){//x<=1肯定不是质数
        return false;
    }
    for(int i=2;i<=sqrt(x);i++){
        if(x%i==0){//找到除1和它本身2个因数的其它一个因数
            return false;
        }
    }
    return true;
}
```
完整代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1005;
int a[maxn];
int n,k;
int lattice[maxn],Addition=0,ans=0;
bool is_Prime(int x){
    if(x<=1){
        return false;
    }
    for(int i=2;i<=sqrt(x);i++){
        if(x%i==0){
            return false;
        }
    }
    return true;
}
void dfs(int x){
    if(x>k){
        if(is_Prime(Addition)){
            ans++;
        }
        return ;
    }
    for(int i=lattice[x-1]+1;i<=n;i++){
        lattice[x]=i;
        Addition+=a[i];
        dfs(x+1);
        lattice[x]=0;
        Addition-=a[i];
    }
    return ;
}
signed main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    dfs(1);
    cout<<ans;
    return 0;
}
```
时间复杂度：$O(N!)$。

---

## 作者：piske (赞：2)

# [NOIP 2002 普及组] 选数
### [题目传送门](https://www.luogu.com.cn/problem/P1036)
## 思路：
用深搜枚举所有合法是组合，统计结果是素数的个数，最后输出。
## Coding:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[21];
int k;
int num;
void dfs(int now,int id,int ans)
{
	if(now==k+1) //满足条件 
	{
		bool f=true;
		for(int i=2;i*i<=ans;i++)
			if(ans%i==0)
			{
				f=false;
				break;
			}
		if(f==true) //判断是否是素数 
			num++;
	}
	else if(id<=n)
		for(int i=id;i<=n;i++)
			dfs(now+1,i+1,ans+a[i]); //搜索所有组合 
}
int main( ){
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	dfs(1,1,0);
	cout<<num; //输出方案数 
	return 0;
} 
```

---

## 作者：GZXUEXUE (赞：2)

### 思路

看到题目之后容易想到「全排列」，故使用 dfs。

那么，我们每次选择数字的区间是什么呢？  
假设我们上次选择的数字在 $x$ 中下标为 $\operatorname{lst}$，已经选了 $\operatorname{pck}$ 个。  
那么首先，区间应该从 $\operatorname{lst} + 1$ 开始，这样可以保证不重复，而且不遗漏。  
然后，区间应该在 $n - (k - \operatorname{pck} - 1)$ 结束，因为选完这个数字之后，还有 $k - \operatorname{pck} - 1$ 个数要选择，不能让要选的数字比剩下的数字多。

接下来就是普通的枚举啦，判断质数的时候用普通的根号筛即可。

### 实现

```cpp
# include <iostream>
using namespace std;
# define int long long
int n,k,a[21],ans;
bool isprime(int x){
    if (x < 2) return false;
    for (int i = 2;i <= x / i;i++){
        if (x % i == 0) return false;
    }return true;
}void dfs(int pck,int sum,int lst){
    if (pck == k){
        if (isprime(sum)) ans++;
        return;
    }for (int i = lst;i <= n - (k - pck - 1);i++) dfs(pck + 1,sum + a[i],i + 1);
}signed main(){
    cin >> n >> k;
    for (int i = 1;i <= n;i++) cin >> a[i];
    dfs(0,0,1);
    cout << ans;
    return 0;
}
```

---

## 作者：蒟蒻whker (赞：1)

### 题意简述

给定 $n$ 个整数，从中选 $k$ 个，问这 $k$ 个数相加的和为素数有几种情况。

### 思路梳理 

简单 [dfs](https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224976) 模板。

调用 dfs，每次调用时先判断选到第几个数了，如果已经选了 $k$ 个数，判断质数并将答案记录；否则继续选。深搜结束后输出答案。

### 避坑指南
1. 只需要存数字之和，不需要把每个数字存下来。
1. 设上一次选的数下标为 $x$ ，这一次下标只需要从 $x+1$ 进行枚举，否则会重复。  
1. 注意 $1$ 不是质数，判断质数时不要写错。

### AC Code  
~~我知道你们只看这个！~~
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,k,a[30],ans=0;
bool prime(int y)//质数判断，最简单的筛法
{
	if(y<2)return false;
	for(int i=2;i<=sqrt(y);i++)//注意是<=
	if(y%i==0)//如果能整除，则不是质数
	return false;

	return true;//是质数
}
void dfs(int x,int sum,int now)//深搜
//x代表这次选的是第几个数，sum代表现在所选数的总和，now代表最新选的那个数在a数组里的下标。
{	
	if(x==k+1)//如果已经选了k个数
	{
		if(prime(sum))//如果这k个数的和是质数
    	ans++;//将答案+1
	}
	else//如果没有k个数，就继续选 
	{
		for(int i=now;i<=n;i++)//枚举从now到n的所有下标 
		{
			dfs(x+1,sum+a[i],i+1);//选择a[i] 
		}
	}
}

int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//按题意输入 
	}
	dfs(1,0,1);//调用深搜函数 
	cout<<ans<<endl;//输出答案 
	return 0;//收官 
}
```

求赞 QWQ~

---

## 作者：__VN (赞：1)

# P1036 [NOIP 2002 普及组] 选数
[题目传送门 ](https://www.luogu.com.cn/problem/P1036)


---


## 思路
1. 深搜出每个可能组合的和。
2. 查找素数（一个个排除再计数）。

---

## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;			//n,k,x含义同题目
int x[21];
int num=0,kind=0; 	//num已得到的和的数量 
int sum[100001];	//记录得到的和

void dfs(int count,int no,int s){		//count深搜层数  no上一个数的下标  s前几层的总和 
	for(int i=no+1;i<=n-k+count;i++){	//i<=n-k+count确保可以选到k个数 
		if(count==k){					//已选数数目达到k 
			sum[++num]=s+x[i];			//记录 
		}else{
			dfs(count+1,i,s+x[i]);		//深搜下一层 
		}
	}
	return;
}

int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>x[i];		//输入 
	dfs(1,0,0);				           		//从第一层深搜 
	for(int i=1;i<=num;i++){                //朴素且好用
		bool flag=1;						//记录是否被整除过 
		for(int j=2;j<=sqrt(sum[i]);j++){
			if(sum[i]%j==0){				//如果被整除 
				flag=0;
				break;
			}
		}
		if(flag) kind++;					//计数 
	}
	cout<<kind;
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

一道暴力搜索题。

数据范围小，暴力枚举所有情况，说一下搜索时传的几个参数。设当前选了 $x$ 个数，该从 $y$ 开始选，当前的和是 $s$。若当前选够 $k$ 个数了，就判断当前的 $s$ 是不是质数，统计答案；若没选够，则继续选。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, a[25], f[25], s, ans;
bool pd(int x){
	if(x<=1)
		return 0;
	for(int i=2; i<=sqrt(x); i++)
		if(x%i==0)
			return 0;
	return 1;
}
void dfs(int x, int y, int s){
	for(int i=y; i<=n; i++)
		if(x==k)
			ans+=pd(s+a[i]);
		else 	
			dfs(x+1, i+1, s+a[i]);
}
int main(){
	cin >> n >> k;
	for(int i=1; i<=n; i++)
		cin >> a[i];
	dfs(1, 1, 0);
	cout << ans;
	return 0;
}
```

---

## 作者：sieve (赞：1)

### 题解：[P1036 [NOIP 2002 普及组] 选数](https://www.luogu.com.cn/problem/P1036)

### 思路

注意到 $n \le 20$，直接全排列或者选和不选的 DFS 即可，最后判断和是不是素数，非常暴力。

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[25],b[25],ans;
bool vis[25];
bool ss(int x)
{
	if(x<2) return false;
	for(int i=2;i*i<=x;++i) if(x%i==0) return false;
	return true;
}
void dfs(int x)
{
	if(x>k)
	{
		int sum=0;
		for(int i=1;i<=k;++i) sum+=a[b[i]];
		if(ss(sum)) ans++;
		return;
	}
	for(int i=b[x-1]+1;i<=n;++i)
	{
		if(!vis[i])
		{
			vis[i]=1;
			b[x]=i;
			dfs(x+1);
			vis[i]=0;
		}
	}
	return;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i) cin>>a[i];
	dfs(1);
	cout<<ans;
	return 0;
}
```

---

## 作者：FISH酱 (赞：1)

## 前置知识

你需要先学习深度优先搜索和基础语法，阅读本篇题解前请确保你已经掌握上述内容。

## 思路讲解

题目要求我们从给出的 $n$ 个数里面选 $k$ 个数，希望所选的数之和为素数，要求输出方案数。通过分析数据范围，我们发现可以使用深度优先搜索和剪枝优化进行暴力求解。

搜索函数要定义三个参数，分别表示当前已选择几个元素、上个元素的下标、当前选的数字之和，记录已选几个元素的参数用于判定边界及时退出，上个元素的下标参数用于剪枝优化，同时也防止了两个数顺序不同导致的重复计算，当前选的数字之和参数用于记录数字和，在末尾判断是否为素数时能够起到优化作用，防止多次循环求和导致的超时。

每次搜索时判定是否已选够 $k$ 个数，如果是就判断数字和是否为素数，并且累加方案数，如果未到达边界，就从上个元素下标的下一个位置开始选择元素，开启下一轮搜索时记得修改传参，记录已选个数、当前元素下标、数字和。

## 代码展示

写的时候注意搜索函数的编写，保证基本框架正确的同时，也要记得把上述的剪枝优化写进去。如果你的程序输出比标准答案要大，可以检查一下是否重复选相同元素，顺序不同的情况是否重复计算。

写的时候注意细节，下面是我的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n,m,cnt; // 题面里的n和k，以及累加方案数的变量cnt
int a[21]; // 存储n个整数

void dfs(int w,int start,int sum){ // 已选个数、上个元素下标、数字和
    if (w == m){ // 判断边界，是否已选k个数
        bool y=1; // 假设是素数
        for(int i=2;i<=sqrt(sum);i++){ // 枚举可能的因数来判断素数
        	if(sum%i==0){ // 如果可以整除
        		y=0; // 那就不是素数，标记
        		break; // 退出循环
			}
		}
		if(y) cnt++; // 如果是素数就累加方案数
        
        return; // 返回上一层搜索调用
    }
    for(int i=start+1;i<n;i++){ // 枚举，注意从上个元素下标的下一个位置开始选，防止重复和多次计算
        dfs(w+1,i,sum+a[i]); // 选的数字个数加一，把上个元素下标设为该元素下标，数字和要加上这个元素的值
    }
}

int main(){
	cin >> n >> m; // 读入n和k，我只是改了变量名，含义是一样的
	
	for(int i=0;i<n;i++) cin>>a[i]; // 读入n个整数
	
	dfs(0,-1,0); // 调用函数，注意传参的已选个数、上个元素下标、数字和，还没选所以是0个数字，下标在搜索时会加一处理，所以设为-1，没选数字所以和为0
	cout << cnt; // 输出方案数

    return 0; // 完结撒花
}
```

---

## 作者：lylcpp (赞：1)

## 思路

考虑 dfs，$2$ 个参数，一个是当前到第几位了，还有一个是从哪里开始，每次进入递归前，加上这个数，跳出递归后减掉这个数。最后判断是不是素数。

## 代码

```cpp
#include<iostream>
#include <cmath>
#include <cstdio>
#define MAXN 25
using namespace std;
int n, k, num[MAXN], visit[1001];
int cnt, ans;
bool ss(int n) {
	if(n == 1) return 0;
	if(n == 2) return 1;
	for(int i = 2; i <= sqrt(n); i++)
		if(n % i == 0) return 0;
	return 1;
}
void DFS(int start, int end) {
	if(start > k) {
		if(ss(cnt)) ans++;
		return ;
	}
	else {
		for(int i = end + 1; i <= n; i++) {
			cnt += num[i];
			DFS(start + 1, i);
			cnt -= num[i];
		}
	}
}
int main() {
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
		cin >> num[i];
	DFS(1,0);
	cout << ans << endl;
	return 0;
}
``````

---

## 作者：__assassin_ (赞：1)

# 题目大意：

从 $n$ 个数中选出 $k$ 个数，要选出的数的总和为素数，问共有多少种选法。
# 思路：

我们可以用递归的方法，先用欧拉筛筛出范围内所有的素数，然后开始递归。递归函数总共有三个参数，用 $x$ 表示决定选的数的下标，用 $sum$ 表示现在选出的数的总值，用 $num$ 表示已经选的数的个数。当 $num=k$ 时，如果 $sum$ 的值为素数，那么最终答案 $s \gets s+1$，否则 $s$ 不变，然后返回。如果 $num<k$，那么我们就从 $x+1$ 开始，一直到 $n$ 去枚举、递归。最后输出最终答案 $s$ 即可。
# AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int s,n,k,a[30],f[100000010],b[100000010];//s表示最终答案，a[i]表示第i个可选的数，f[i]表示i是否为素数，b[i]表示范围内第i小的素数 
void dfs(int x,int sum,int num){//x表示决定选的数的下标，sum表示现在选出的数的总值，num表示已经选的数的个数 
	if(num==k){//现在已经选了k个数 
		s+=1-f[sum];//当sum的值为素数时，答案加1，否则加0 
		return;//不用继续选下去了，返回 
	}
	for(int i=x+1;i<=n;i++){//还没有选出k个数，继续选下去 
		dfs(i,sum+a[i],num+1);//递归，从第i个数继续选下去，sum加上a[i]的值，num加1 
	}
	return;
}
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	f[1]=1;//1不是素数 
	int bi=0;//素数数量 
	for(int i=2;i*i<=100000000;i++){//筛出范围内的所有素数 
		if(f[i]==0) b[++bi]=i;//存储新的素数 
		for(int j=1;j<=bi&&i*b[j]<=sqrt(100000000);j++){
			f[i*b[j]]=1;//i*b[j]的值不是素数 
			if(i%b[j]==0) break;//当i为b[j]的整倍数时，退出循环 
		}
	}
	dfs(0,0,0);//开始递归 
	cout<<s;//输出最终答案 
	return 0;
}
```

---


# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# 题解

## 作者：__CJY__ (赞：51)

## 思路
假设我们用一个函数 $\operatorname{C}(x,y)$ 表示：
* $x$：当前还未入栈的数字个数。
* $y$：当前栈中的数字个数。

我们的目标是计算 $\operatorname{C}(n,0)$，即从 $n$ 个数字开始，生成输出序列的方式。

在任何状态下，我们有两种选择：
* push 操作：如果还有数字可以入栈（即 $x>0$），我们可以将一个数字从输入序列中移入栈中。这会减少未入栈的数字个数 $x$，同时增加栈中的数字个数 $y$。因此，该操作对应于 $\operatorname{C}(x-1,y+1)$。
* pop 操作：如果栈中有数字可以出栈（即 $y>0$），我们可以将栈顶数字移出到输出序列中。这不会改变未入栈的数字个数 $x$，但会减少栈中的数字个数 $y$。因此，该操作对应于 $\operatorname{C}(x,y-1)$。

递归的边界条件是：当 $x=0 \land y=n$ 时，表示所有数字已成功输出为一个序列，这算作一种有效方式，返回 $1$；其他不合法状态（如 $x<0 \lor y>n$）返回 $0$。

递归太慢，所以我们可以用 DP，转移方程是：
$$f_{x,y}=f_{x-1,y+1}+f_{x,y-1}$$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[20][20],n;
int main(){
	cin>>n;
	for(int x=0;x<=n;x++){
		for(int y=0;y<=n;y++){
			if(!x) f[x][y]=1;
			else if(!y) f[x][y]=f[x-1][y+1];
			else f[x][y]=f[x-1][y+1]+f[x][y-1];
		}
	}
	cout<<f[n][0];
}
```
有问题请指出！

感谢 @[NJYgocrazy](/user/1418820) 指出一个小错误。

---

## 作者：yummy (赞：34)

看到题解里有人发了卡特兰数，我表示深深的佩服，因为我不会啊！

于是，就还有一批人，推出了他们的dp算法，然而，我在第一次做时，就没有想到，于是就使用了dfs（居然还通过了）

[我的代码](https://www.luogu.org/record/show?rid=7676823)

60分以下的同学别慌，接下来我会再把解题过程讲一遍。

---
很显然，对于每个合法的操作序列(如题目描述里的push,push,pop,push,pop,pop),都对应一个输出序列，于是题目就转化成了求合法操作序列数量。

我们总结出如下规律：
- 如果栈非空，那么下一步就既可push，又可pop
- 否则，下一步只可以push。

因此，我们dfs时，要传入两个参数，k用于记录当前是第几步，而many记录栈内有几个元素。
```cpp
int way(int k,int many)
{
    int t=0;//计数
    if(k==2*n)//如果步数已满，返回
    {
        if(many==0)//所有操作完成后栈是否清空
            return 1;
        else
            return 0;
    }
    if(a[k][many]!=0)//此处为了加速用了一个记忆化
        return a[k][many];
    if(many<=n)//栈不是满的就可以push
        t+=way(k+1,many+1);
    if(many>0)//栈不是空的就可以pop
        t+=way(k+1,many-1);
    a[k][many]=t;
    return t;
}
```
为防抄袭题解，剩下的部分由读者自行修补

---

## 作者：_xzhdsnh1364 (赞：18)

看题解里好多巨佬呢，都是卡特兰数，本蒟蒻来发一篇递推的吧。

我的思想主要是将他从最终序列倒退回去。

# SOLUTION
我们首先定义 DP 状态 $dp_{i,j}$，表示当前还有 $i$ 个元素没有入栈，栈中有 $j$ 个元素时的情况可能数。

我们首先给出一个初始化，如果此时没有元素需要入栈，那么只有一种情况，这是很容易理解的。

接下来就是转移方程了，我们分为两种情况讨论。

第一种是栈内还有元素，那我们可以选择出栈和入栈，将这两种情况的方案数相加即可。

第二种是没有元素了，只能选择入栈。

看到这的小伙伴应该已经有了想法，但如果还没有懂，那么就请看下面的代码。

# CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[25][25] , n;
int main(){
    cin >> n;
    for(int i = 0;i <= n;i++)dp[0][i] = 1;//初始化
    for(int i = 1;i <= n;i++){
        for(int j = 0;j <= n;j++){
            if(j)dp[i][j] = dp[i][j - 1] + dp[i - 1][j + 1];//栈中有元素
            else dp[i][j] = dp[i - 1][j + 1];//栈中无元素
        }
    }
    cout << dp[n][0];
    return 0;
}
```

---

## 作者：M1__ (赞：15)

# 题解：P1044 [NOIP 2003 普及组] 栈
-  __[Link](https://www.luogu.com.cn/problem/P1044) | [Blog](https://www.cnblogs.com/M1--1e9/p/18786780)__
-  直接按照卡特兰数做即可，但是**考虑证明**。
## 前置知识
- 卡特兰数：组合数学中一种常出现于各种计数问题中的数列。它的前几项为： 
$$C(0)=1,C(1)=1,C(2)=2,C(3)=5,C(4)=14,C(5)=42$$
## 题目思路  
- 不妨设第一个入栈的元素是第 $k$ 个出栈的元素，则前面的元素 $1 \sim k-1$ 必须在 $k$ 前完成出入栈。则方案数为 $C(k-1)$；
- 则后面的数 $k \sim n$ 有 $C(n-k)$ 种方案。总的方案数为 $C(k-1) \cdot C(n-k)$。
- 可以把样例代入证明：
  - 当 $k=1$ 时，有 $C(0) \cdot C(2)=2$；
  - 当 $k=2$ 时，有 $C(1) \cdot C(1)=1$；
  - 当 $k=3$ 时，有 $C(2) \cdot C(0)=2$；
  - 因此总方案为 $2+1+2=5$。
- 综上，答案为：
  $$ C(n)=\sum _{k=1}^{n} C(k−1) \cdot C(n−k)$$
- 将其化为：
  $$ C(n)=\frac{2(2n−1)}{n+1} \cdot C(n−1)$$
于是我们可以推出卡特兰数列的前 $18$ 项，然后根据 $n$ 输出即可。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100;
ll n,sum[N];
int main() {
    cin>>n;
    sum[1]=1;
    for(int i=2;i<=18;i++){
        sum[i]=sum[i-1]*2*(2*i-1)/(i+1);
        //cout<<sum[i]<<"\n";
    }
    cout<<sum[n];
    return 0;
}
```

---

## 作者：Doraeman (赞：13)

## 提示
我们可以计算多个不同的 $n$，通过观察找规律可得，这道题的答案符合**卡特兰数**的规律。
## 卡特兰数
卡特兰数是组合数学中一种常出现于各种计数问题中的数列。

卡特兰数的前几项为（从第 $0$ 项开始）：  
$$1,1,2,5,14,42,132,429,1430,...$$。

卡特兰数的 $C_n$ 的递推规律是：  
$$C_{n}=C_0C_{n-1}+C_1C_{n-2}+...+C_{n-2}C_1+C_{n-1}C_0$$。

根据上面这个递推公式，直接写代码即可。
## 代码
### 递推写法
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

LL C[25];

int main(){
    int n; cin >> n;
    
    C[0] = 1;
    for(int i=1; i<=n; i++)
    	for(int j=0; j<i; j++)
    		C[i] += C[j] * C[i-j-1];
    		// 递推公式 
			
	cout << C[n]; 
}
```
### 递归写法
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

LL C(int x){
	if(x == 0) return 1;
	LL ans = 0;
	for(int i=0; i<x; i++)
		ans += C(i) * C(x-i-1);
		// 递推公式 
	return ans;
}

int main(){
    int n; cin >> n;
    cout << C(n);
}
```
## 打表
当然，在我们知道答案的规律之后，也可以在网上搜索卡特兰数的前几项，然后直接**打表**得到答案。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

LL ans[] = {1, 1, 2, 5, 14, 42, 
			132, 429, 1430, 4862, 16796, 
			58786, 208012, 742900, 2674440, 
			9694845, 35357670, 129644790, 477638700};
// 刚好到第 18 项  

int main(){
    int n; cin >> n;
    cout << ans[n];
}
```

---

## 作者：chenxi797 (赞：5)

# P1044 [NOIP 2003 普及组] 栈 题解

在 dp 函数的两个参数中，

- $x$ 为当前未入栈的数字数量。
- $y$ 为当前栈中数字的个数。

显而易见，我们的目标就是求 $dp(n,0)$。

虽然递归较慢，但是思路比较清晰且代码可读性较高，也算是提供一种思路。

具体见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[20][20];
int dp(int x,int y)
{
	if (f[x][y] != 0) return f[x][y]; //求过了
	if (x == 0) return 1; //全部入栈
	if (y > 0) f[x][y] += dp(x,y - 1); //栈中还有数字
	f[x][y] += dp(x - 1,y + 1);
    //此时还有未入栈的数，则未入栈的数字数量-1，栈中数字数量+1
	return f[x][y];
}
int main()
{
	cin >> n;
	cout << dp(n,0);
	return 0;
}
```

---

## 作者：ryderyang (赞：3)

# 解题思路
我们可以用递归的方法解决这道题目。

设 $\operatorname{h}(n)$ 表示 $n$ 个元素的可能的出栈序列总数。

我们可以枚举最后一个出栈的元素 $k$。

那么他的出栈序列应该是这么出来的：

  - 首先，$1$ 到 $k-1$ 的每一个数字按照一定的顺序全部入栈并出栈。总共有 $\operatorname{h}(k-1)$ 个方法。
  - 然后，将第 $k$ 个元素入栈。
  - 接着，把 $k+1$ 到 $n$ 的每一个数字按照一定的顺序全部入栈并出栈。因为出栈序列的个数跟元素的大小无关，只和元素的个数有关，所以这一块的方案数是 $\operatorname{h}(n-k)$。
  - 最后，让元素 $k$ 出栈。

根据乘法原理，以第 $k$ 个元素结尾的出栈序列的个数为 $\operatorname{h}(k-1) \times \operatorname{h}(n-k)$。

综上所述，可以得到：

$$
\operatorname{h}(n) = \sum_{i=1}^{n} \operatorname{h}(i-1) \times \operatorname{h}(n-i)
$$

# 边界条件
当 $i = 0$ 时，出栈序列是空的，所以有 $1$ 种（空的就也算是一种）。

当 $i = 1$ 时，这个序列只有一个数字，就是 $1$，所以也有 $1$ 种。

不要忘记加记忆化。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[20];
int h(int n)
{
    if(f[n]!=0)
    return f[n];
	if(n<2)
	return 1;
	int sum=0;
	for(int i=1;i<=n;i++)
    sum+=h(i-1)*h(n-i);
    f[n]=sum;
	return sum;
} 
int main()
{
	int n;
	cin>>n;
	printf("%d",h(n));
	return 0;
}
```

---

## 作者：封禁用户 (赞：3)

# 题解：P1044 [NOIP 2003 普及组] 栈

## 题意简述
给定数字序列 $1, 2, \ldots, n$，通过栈的 push 和 pop 操作，求可能得到的所有输出序列的总数。

## 题目分析
本题属于组合数学问题，关键在于理解栈操作序列与卡塔兰数（Catalan numbers）之间的关系。对于一个长度为 $n$ 的输入序列，其合法的栈操作序列数量即为第 $n$ 个卡塔兰数。

### 卡塔兰数性质
卡塔兰数 $C_n$ 满足以下递推关系：
$$
C_n = \sum_{i=0}^{n-1} C_i \times C_{n-1-i} \quad \text{其中} \quad C_0 = 1
$$

闭合形式为：
$$
C_n = \frac{1}{n+1} \binom{2n}{n} = \frac{(2n)!}{n!(n+1)!}
$$

### 算法选择
由于 $n \leq 18$，可以采用动态规划的方法计算卡塔兰数，时间复杂度为 $O(n^2)$。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	int dp[20]={0};
	dp[0]=1;
	for(int i=1;i<=n;i++){
    	for(int j=0;j<i;j++){
			dp[i]+=dp[j]*dp[i-j-1];
		}
	}
	cout<<dp[n];
	return 0;
} 
```
## 复杂度分析
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$

---

## 作者：__xxy_free_ioi__ (赞：2)

# 题解：P1044 \[NOIP 2003 普及组] 栈

~~毕竟是道橙，还是不要用卡特兰数了吧。~~

## 解法

我们知道，我们可以做 $2 \times n$ 次操作，所以我们可以暴力枚举每次操作，记录状态 $top$ 和 $dep$，表示栈的大小和操作次数，每次判断一下是否可以入栈或弹栈即可，最后在判断一下枚举出来的方案是否合法（即 $top$ 是否为 $0$）。

但是这样是会超时的，时间复杂度大概是 $O(2^{2n})$，在 $n \le 18$ 的数据范围中，不足以通过。所以，我们加入记忆化进行优化。因为 $f$ 的大小只有 $n \times 2 \times n$，所以最多时间复杂度最多也是 $O(n^2)$ 的，而 $n \le 18$，所以直接快得飞起。

```
#include <bits/stdc++.h>

using namespace std;

int n;
int f[20][40];

int solve(int top, int dep) {
    if (f[top][dep]) return f[top][dep];
    if (dep > 2 * n) return (top == 0);
    int res = 0;
    if (top != 0) res += solve(top - 1, dep + 1);
    if (top < n) res += solve(top + 1, dep + 1);
    return f[top][dep] = res; // 记忆化记录状态
}

int main() {
    cin >> n;
    cout << solve(0, 1);
    return 0;
}
```

---

## 作者：AIregister (赞：2)

## 题意 ##
及问你有 $n$ 个数 $1$ 到 $n$，让你求出栈序列的情况总数。
## 解法 ##
这个题目是经典的数学题，在这里我们硬求肯定是没有办法的，那么我们不妨以递推的视角看一下。
我们可以设一个数组 $f$ 为在当 $n$ 为一到十八时，可能的序列总数。
那么此时我们的 $f_0$ 和 $f_1$ 只有一种情况，而 $f_2$ 有两种。
那么我们可以先构造一个栈的结构，我们得到了一个输入序列，接下来就要处理了，下一步求递推公式便是本题的精髓，我们的序列是不是从 $1$ 到 $n$ 的，我们的 $i$ 从一开始循环。那么，我们随机挑一个点 $k$，以 $k$ 为中心点我们的序列被劈成了两半，这两段的情况数为 $f_{k-1}$ 和 $f_{i-k}$ 这两个，那么根据乘法原理，总可能性为 $f_{k-1}$ $\times$ $f_{i-k}$ 。最终公式为 $f_n$ $=$ $f_0$ $\times$ $f_{n-1}$ $+$ $f_1$ $\times$ $f_{n-2}$ $\cdots$ $+$ $f_{n-1}$ $\times$ $f_0$。
那么，我们进行枚举，将 $1$ 到 $n$ 每一个数做这样的处理，将得出的数相乘，就是本题的答案。
## 代码 ##
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[55]={1,1,2};
int main(){
	int n;
	cin >> n;
	for(int i=3;i<=n;i++){
		for(int k=1;k<=i;k++){
			f[i]+=f[k-1]*f[i-k];
		}
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：ylzpl (赞：0)

在这里我要用黑科技了，当然是卡特兰数捏。  
解题思路：
- 为了方便，我在这里使用动态规划解法。
- 定义状态：$dp_{i,j}$ 表示当还有 $i$ 个数字可以有进栈操作时栈里有 $j$ 个数字的方案数。
- 边界条件：$dp_{0,j}=1$。因为没有数组可以进栈了，只能把数字弹出栈。
- 状态转移方程。$dp_{i,j}=dp_{i-1,j+1}+dp_{i,j-1}$。当然，这是不对的，因为如果 $j=0$，在 $dp_{i,j-1}$ 中案显然是 $0$，也就是没有数字了，所以如果 $j=0$，$dp_{i,j}=dp_{i-1,j+1}$。

当然，这样是可以通过的。通过计算，我们可以发现，这题就是求卡特兰数的第 $n$ 项。所以，我们可以把卡特兰数的公式套上去即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=25;
int dp[maxn];
signed main(){
	int n;
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<i;j++){
			dp[i]=dp[i]+dp[j]*dp[i-1-j];
		}
	}
	cout<<dp[n]; 
	return 0;
}
```

---


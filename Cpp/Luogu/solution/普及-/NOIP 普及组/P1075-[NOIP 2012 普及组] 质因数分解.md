# [NOIP 2012 普及组] 质因数分解

## 题目描述

已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。


## 说明/提示

$1 \le n\le 2\times 10^9$

NOIP 2012 普及组 第一题


## 样例 #1

### 输入

```
21```

### 输出

```
7```

# 题解

## 作者：hilsinleri (赞：877)

感觉楼下们说的不是很详细，所以最为一个蒟蒻，发一个有说明的题解。

本题考数学。

首先要知道唯一分解定理:一个数能且只能分解为一组质数的乘积。可知，若输入的数满足题目条件，他就只能分解为两个质数的乘积。所以在比他小且大于1的自然数中，只有那两个数能整除它，之间不可能再有任何合数或质数能整除它了，因为最小的能整除它的合数已经是他本身了。

所以代码就很容易实现了

```cpp
#include<cstdio>
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=2;i<=n;++i)
            if(n%i==0)
            {
                    printf("%d",n/i);
                    return 0;
            }
}
```

---

## 作者：ryf2011 (赞：8)

# 题目思路
由于 $n$ 的范围很大，我们不能通过直接枚举找到答案，如何解决呢？

我们从小到大寻找第一个 $n$ 的因数，即 $n$ 的最小因数，此时输出 $n$ 除以这个数即为另一个较大的质数。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=2;i<=n;i++){
		if(n%i==0){ //如果 n%i==0，说明找到了 n 的因数，直接输出 n/i，退出循环。 
			printf("%d",n/i); 
			return 0;
		}
	}
	return 0;
} 
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：kunkun127 (赞：5)

## 思路

这道题题面短，意思明了。唯一难点就是对 $1 \le n\le 2\times 10^9$ 范围的优化。

- $60pts$
  
  很多人看到较大的数，就会直接从 $n - 1$ 开始搜到 $2$，一满足条件就返回。但是对于题面所说的范围，肯定会[超时](https://www.luogu.com.cn/record/197701649)。

- $100pts$

  换一种思路，我们知道因数是成双成对出现的。因此，我们直接从 $2$ 开始搜，找到其中小的数后，输出 $n / i$ 即可得到大的数。

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++) 
	{
		if (n % i == 0) 
		{
			cout << n / i << endl;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：hbdcsd (赞：4)

## 思路

较小的质数一定在 $2$ 到 $\sqrt{n}$ 之间。从 $2$ 枚举到 $\sqrt{n}$，如果是质数且可以整除 $n$，那么这个数是较小的质数，就可以求出较大的质数。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std; 
bool prime(int x){//判断是否为质数的函数
	if (x <= 1) return 0;
	for (int i = 2; i*i <= x; i++)
		if (x%i == 0) return 0;
	return 1;
}
int main(){
	int n;
	cin >> n;
	for (int i = 1; i*i <= n; i++){
		if (n%i == 0 && prime(i)){
			cout << n/i;
			break;
		}
	}
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：3)

首先要知道一个数除以一个越小的数，得到的商反而越大。所以我们可以枚举 $n$ 的因数。如果 $i$ 是 $n$ 的因数，那么 $\frac{n}{i}$ 就绝对是我们要求的答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    for(int i=2;i<=n/2;i++)
	{
		if(n%i==0)
		{
			cout<<n/i;
			return 0;
		}
	} 
	return 0;
}
```

---

## 作者：cff_0102 (赞：3)

从 $2$ 开始枚举更小的那个质数，找到了（设为 $x$）就输出 $\frac nx$ 即可。$n$ 是两个质数的乘积，那么更小的那个质数不会大于 $\sqrt n$，所以时间复杂度是 $O(\sqrt n)$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	int x=1;
	while(x++){
		if(n%x==0){
			cout<<n/x;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：collegiate (赞：2)

既然要求**较大的那个质数**，那么我们就通过枚举**最小的因数**。

为什么呢？原理很简单！

我们知道对于一个数 $n$，它的因数都是对应起来的，平方数除外。比如数字 $8$，它的因数有 $1,2,4,8$，而其中数字 $1$ 和 $8$ 是对应的，数字 $2$ 和 $4$ 是对应的。

那么我们只要通过找到最小的因数，再用 $n$ 去除以那个因数，得到的不就是那个最大的吗？

所以我们从前往后枚举，对于枚举的数字 $i$，如果 $i$ 为 $n$ 的因数，那么我们直接输出用 $n$ 去除以那个因数的值即可了。


```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++) 
        if (n % i == 0) { 
            cout << n / i;
            return 0;
        }
    return 0;
}
```

---

## 作者：Eason0324 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1075)

## 思路
比较简单，因为只有 $2$ 个数相乘，找到小的那个 $i$ 然后答案就是 $n \div i$。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n;
int main(){
	cin>>n; 
	for(int i=2;i*i<=n;i++){
	    if(n%i==0){
	        cout<<n/i<<endl;
	        break;
	    }
	}
	return 0; 
}
```

---


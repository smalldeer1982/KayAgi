# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# 题解

## 作者：jiangXxin (赞：176)

这道题我其实原本想用BFS的，结果写完了，才看到花生地里面没有障碍物，果断换上曼哈顿，（曼哈顿真是一个好东西）。按照题目要求一个一个地枚举就好了，如果有不知道曼哈顿的，~~百度一下，你就知道。~~：D（i,j）=abs($x_i$-$x_j$)+abs($y_i$-$y_j$)

**话不多说，贴代码：**

**注释版：**

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N=30;
int mp[N][N];
int n,m,k;
int tm;
int fx,fy,ex,ey;//起点，终点
int pn;
int ans;
struct dire//记忆花生地址 
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)//比较，大的在前，小的在后 
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)//有花生 ，多多：我看到你们了 
            {
                stu[++pn].sum=mp[i][j];//获得一系列有花生的坐标
                stu[pn].x=i;
                stu[pn].y=j;//保存坐标
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);//按照题意来，先大后小 
	fx=1;
	fy=stu[1].y;//设立你的初始位置 
	k--;//从人群中窜出一个光头,多多用了一个单位从人群中跳出 
    for(int i=1;i<=pn;i++)//枚举每一个有花生的点
    {
        tm=0;//计时器清零 
        ex=stu[i].x;
        ey=stu[i].y;//设定多多的终点坐标
        tm=abs(fx-ex)+abs(fy-ey);//求曼哈顿距离，计算本次导航距离 
        k--;//采花生 
        k-=tm;//剩余时间减去前往时间 
        if(k>=ex)//可以返回,装上花生 
        {
            ans+=mp[ex][ey];//加入 
            fx=ex;
            fy=ey;//路径规划成功，前往 fx,fy 
        }
        else//多多如果去这个目标就回不去了，带上现在的花生米回去 
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;//真棒，获得了全部的花生米 
    return 0;
}

```

**无注释版：**

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
const int N=30;
int mp[N][N];
int n,m,k;
int tm;
int fx,fy,ex,ey;
int pn;
int ans;
struct dire
{
    int x,y,sum;
}stu[N*N];
bool comp(struct dire a,struct dire b)
{
    return a.sum>b.sum;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>mp[i][j];
            if(mp[i][j]>0)
            {
                stu[++pn].sum=mp[i][j];
                stu[pn].x=i;
                stu[pn].y=j;
            }
        }
    }
    sort(stu+1,stu+pn+1,comp);
	fx=1;
	fy=stu[1].y;
	k--;
    for(int i=1;i<=pn;i++)
    {
        tm=0;
        ex=stu[i].x;
        ey=stu[i].y;
        tm=abs(fx-ex)+abs(fy-ey);
        k--;
        k-=tm;
        if(k>=ex)
        {
            ans+=mp[ex][ey];
            fx=ex;
            fy=ey;
        }
        else
        {
            cout<<ans<<endl;
            return 0;
        }
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：MC_long_live (赞：39)

今天刚好老师讲稀松矩阵，我看到这道题，突然想可以用来做。于是做了一下。

介绍一下稀松矩阵：

像

0 0 0 1 0

0 3 0 0 0

0 0 2 0 0

0 0 1 0 0

可以用稀松矩阵表示为

1 4 1

2 2 3

3 3 2

4 3 1

其中，第一列表示数据所在行，第二列表示所在列，第三列是这个位置上的数。

看输入数据会发现，~~没错！很稀松~~因为有太多无用的数据，所以就用稀松矩阵来保存。而且方便下面的模拟~~暴力~~。。。

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[25][25];
int b[405][5];
int n, m, k;
int q, ans;
int main(){
    cin >> m >> n >> k;
    for (int i=1; i<=m; i++)
      for (int j=1; j<=n; j++){
      	  cin >> a[i][j];
      	  if (a[i][j]!=0){
      	  	 q++;
      	  	 b[q][1]=i;
      	  	 b[q][2]=j;
      	  	 b[q][3]=a[i][j];
          } 
      }

```
存好以后干什么呢？

看题！每次采最多的，所以要排序！

```cpp

    for(int i=1; i<=q; i++)
      for(int j=i+1; j<=q; j++){
      	if (b[i][3]<b[j][3]){
          swap(b[i][3], b[j][3]); 
          swap(b[i][1], b[j][1]); 
          swap(b[i][2], b[j][2]);
        }
      }

```
排序完了，就开始模拟，先初始一下。如果一颗都采不到，就输出。否则ans=最大的。时间减去所用时间。然后开始模拟。求出来到此花生的时间，加上采摘与返回的，如果time enough就加上花生数，减去

## 注意！是减去到达此花生的和采摘的，不用减返回！

不行的话就输出并结束。

```cpp

    if (k>=(b[1][1]*2+1)) ans=b[1][3];
    else {cout << 0 << endl; return 0;}
    k=k-b[1][1]-1;
    for(int i=2; i<=q; i++){
        if (abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1+b[i][1]>k) break;
        else {
           ans+=b[i][3]; 
           k=k-(abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1);
        }
    }    
    cout << ans << endl;
    return 0;
}
```
到达时间就是用行减行，列减列，加起来，要注意使用绝对值，否则你只能过七个点！

这是完整代码：（42行）

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[25][25];
int b[405][5];
int n, m, k;
int q, ans;
int main(){
    cin >> m >> n >> k;
    for (int i=1; i<=m; i++)
      for (int j=1; j<=n; j++){
      	  cin >> a[i][j];
      	  if (a[i][j]!=0){
      	  	 q++;
      	  	 b[q][1]=i;
      	  	 b[q][2]=j;
      	  	 b[q][3]=a[i][j];
          } 
      }
    for(int i=1; i<=q; i++)
      for(int j=i+1; j<=q; j++){
      	if (b[i][3]<b[j][3]){
          swap(b[i][3], b[j][3]); 
          swap(b[i][1], b[j][1]); 
          swap(b[i][2], b[j][2]);
        }
      }
    if (k>=(b[1][1]*2+1)) ans=b[1][3];
    else {cout << 0 << endl; return 0;}
    k=k-b[1][1]-1;
    for(int i=2; i<=q; i++){
        if (abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1+b[i][1]>k) break;
        else {
           ans+=b[i][3]; 
           k=k-(abs(b[i-1][1]-b[i][1])+abs(b[i-1][2]-b[i][2])+1);
        }
    }    
    cout << ans << endl;
    return 0;
}
```




---

## 作者：_Arahc_ (赞：28)

翻了这道题的前两页题解，没有几个和我的思路相仿的。~~唯一的一个我看不懂~~

首先为了让大家快速找到自己可能有的错误，把这道题的部分坑点给出来：

1. 关于算法，题目已经明确规定了走法是按照花生数目由大到小摘花生：

鲁宾逊先生说：“你$\color{red}\text{先找出花生最多}$的植株，去采摘它的花生；然后$\color{red}\text{再找出剩下的植株里花生最多的}$，去采摘它的花生；$\color{Blue}\text{依此类推}$，不过你一定要在我限定的时间内回到路边。”

2. 关于摘花生，将花生采摘下来是要耗费时间的。有同学没有+1，就会爆炸。

3. 关于抄近道，题目虽然没有说清楚，但是不能通过在大路上抄近道省时间。

比如这样的情况，不能走红线，只能老老实实走蓝色路（曼哈顿）

![](https://cdn.luogu.com.cn/upload/image_hosting/kyqotj7u.png)

4. 关于第四个数据点：

1 1 5

15

如果你的答案是 45，请检查一下你是否重复在摘这个仅有的格子。

5. 关于数组大小：开25\*25绝对不会错。

6. 对于没读好题目：保证没有花生数一样的格子，各位不要想太多。

7. 考虑最终答案是0的情况，不要一上来就摘了花生回不去。

8. 无脑抄袭我的代码或其他有反作弊措施的代码的人会体验CE的快感。

然后是我对这道题的分析：

做法比较明显，就是一步一步摘，判断会不会超时，然后算一个曼哈顿距离。

（曼哈顿距离公式：|$x_{1}$-$x_{2}$|+|$y_{1}$-$y_{2}$|）

各位的算法基本都是使用一个结构体，存储格子的坐标和花生数，有的人还存了时间，然后 sort 结构体，依次考虑摘不摘。

我的方法主要区别是省去了结构体和排序这两步。

我使用了一个 map（套 pair） 来存储一个格子的花生数目和坐标，这样当我选定一个花生数目的时候可以 O(1) 查询坐标。

对于从大到小排序，C++ 的STL的 $\color{RoyalBlue}\text{priority queue}$ 可以 O(logn) 插入一个数。

使用 STL 就可以做到输入完成的时候就已经做好了花生数和坐标的绑定，以及一个排序。

这个算法坑在代码实现，最难的地方就是怎么拼写 $\color{RoyalBlue}\text{priority queue}$

~~解决方法也很简单，搜一下就可以了~~

$\color{LimeGreen}\text{输入代码}$

 ```cpp
    int n,m,k,a[23][23];
	map<int,pair<int,int> >c;
	priority_queue<int> q;
   
  
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
		a[i][j]=read();
		c[a[i][j]]=make_pair(i,j);
		q.push(a[i][j]);
	}
```

对于怎么处理：

每次取出大根堆的堆顶，依靠 map 锁定它的坐标，判断一下可不可以去摘就行。

为了防止$\color{Red}\text{WA}$声一片，使用 $while(1)$循环的童鞋最好提前处理第一株花生。

 ```cpp
	int j=q.top();q.pop();
	int x=c[j].first;
	int y=c[j].second;
	int w=x+1;
```
$j$表示花生数目，$x$和$y$分别为坐标，$w$表示已经消耗的时间。后文的$s$表示已经摘的花生数目。

每次+1的原因已经写在开头的第二点了。

现在每次处理就简单多了，如果可以摘（摘完了还能回家）就摘，然后再弹出下一个花生，锁定坐标（和距离），计算时间。

 ```cpp
	while(w+x<=k){
		s+=j;
		if(q.empty()) break;
		j=q.top();q.pop();
		w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
		x=c[j].first,y=c[j].second;
	}
```
注意要判断队列是否为空，否则会$\color{Orange}\text{90}$分，$\color{Red}\text{WA}$第4个数据，原因是这篇文章开头写的第四点。

最终是各位期待的完整代码（相信很多人直接跳过，空降到这里来了吧……）

 ```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,k,a[23][23],w,s;
map<int,pair<int,int> >c; //绑定数量和坐标
priority_queue<int> q;	//存花生数量的大根堆

int main(){
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
		a[i][j]=read();
		c[a[i][j]]=make_pair(i,j);// 绑定
		q.push(a[i][j]); // 入队（堆）
	}

//↑输入和预处理，现在所有花生大小坐标已绑定且排好序

	int j=q.top();q.pop();//别像我一样把 top 写成 front
	int x=c[j].first;
	int y=c[j].second;// pair 不会的或 map 不会的可以自行百度
	w+=x+1;

// ↑处理一下0的情况，即一个花生都摘不了

	while(w+x<=k){
		s+=j;
		if(q.empty()) break;//这里不写就是90分
		j=q.top();q.pop();
		w+=abs(c[j].first-x)+abs(c[j].second-y)+1;//注意这里也要+1，别忘了
		x=c[j].first,y=c[j].second;//更新位置
	}
	write(s);
	return 0;
}

```
纯净无注释版本：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,k,a[23][23],w,s;
map<int,pair<int,int> >c;
priority_queue<int> q;

int main(){
	n=read(),m=read(),k=read();
	for(register int i=1;i<=n;++i) for(register int j=1;j<=m;++j){
		a[i][j]=read();
		c[a[i][j]]=make_pair(i,j);
		q.push(a[i][j]);
	}

	int j=q.top();q.pop();
	int x=c[j].first;
	int y=c[j].second;
	w+=x+1;

	while(w+x<=k){
		s+=j;
		if(q.empty()) break;
		j=q.top();q.pop();
		w+=abs(c[j].first-x)+abs(c[j].second-y)+1;
		x=c[j].first,y=c[j].second;
	}
	write(s);
	return 0;
}

```
结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdz0wz4m.png)

---

## 作者：qhr2023 (赞：5)

## solution

一道模拟题。

题目要求按照花生数从大到小摘，那我们就按花生数降序排序，遍历每颗植株，求出**采到**这个花生的时间，再判断来不来得及回去，如果直接走都来不及，那再采花生再走一定更来不及，所以如果当前来不及回去，就说明采不到这个花生，结束遍历即可，如果来得及，累加答案。

[通过记录](https://hydro.ac/record/67b7e918c195f3ed9513f013)。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, cnt, sum, ans;
struct node { int v, x, y; } a[425];
bool cmp (node a, node b) { return a.v>b.v; }
int main () {
	cin >> n >> m >> k;
	for (int i=1; i<=n; ++i)	
		for (int j=1, x; j<=m; ++j) 
			cin >> x,
			a[++cnt]={x, i, j};
	sort(a+1, a+cnt+1, cmp);
	a[0]={0, 0, a[1].y};
	for (int i=1; i<=cnt; ++i) {
		sum+=abs(a[i-1].x-a[i].x)+abs(a[i-1].y-a[i].y)+1;
		if (sum+a[i].x<=k&&a[i].v)
			ans+=a[i].v;
		else
			break;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：lby_commandBlock (赞：3)

## 想法

这道题第一视角来看发现可能需要 BFS，但是通过~~题目标签~~仔细阅读题面发现：

- 在地图中没有任何障碍物。
- 每次采摘花生只能采摘最大数量的植株。

所以，这道题变成了一道非常简单的**模拟**。

因为不能斜着走，所以曼哈顿距离为最优解。

**注意：** 在剩余时间为 $0$ 时仍然算合理情况。

## 代码大纲

- 读入输入数据；
- 统计花生个数**且排序**；
- 按照题意模拟，直到时间耗尽或时间不够；
- 输出结果。

## 参考代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N = 25;

int m, n, k, p[N][N], ans;

// 定义位置的结构体
struct node {
	int x, y;
};

vector<node> v;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> m >> n >> k;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> p[i][j];
			if (p[i][j] > 0) {
				// 若当前位置有花生 则统计
				v.push_back({i, j});
			}
		}
	}
	// 按照花生多少进行排序
	sort(v.begin(), v.end(), [](node a, node b) {
		return p[a.x][a.y] > p[b.x][b.y];
	});
	// 设定初始位置，以及花生下标
	int fx = 1, fy = v.front().y;
	k--;
	// 只要还有花生就继续
	while (v.size() > 0) {
		// 获取到最大花生数量的坐标
		node top = v.front();
		// 前往花生坐标所花的时间
		int time = abs(top.x - fx) + abs(top.y - fy);
		// 采花生，以及走到那个花生坐标
		k--;
		k -= time;
		// 若没命了，则输出当前结果
		if (k - top.x < 0) { // k **- top.x** : 我们还要回到路上
			cout << ans << endl;
			exit(0);
		}
		// 结果加上
		ans += p[top.x][top.y];
		// 前往花生坐标
		fx = top.x;
		fy = top.y;
		// 当前花生被摘了，删除
		v.erase(v.begin());
	}
	// 命硬，但还是别忘了输出结果
	cout << ans << endl;
	return 0;
}
```

---

## 作者：ryf2011 (赞：2)

# 题目思路
我们按顺序输入数据，同时用一个结构体，记录每个含有花生的植株的具体位置以及含有的花生的数量。

记录完成后，让结构体从大到小排序。

之后，用两个变量记录当前多多所在位置。

按照排好的顺序来枚举花生植株，同时计算当前去往下一个植株并采摘该植株所需的时间。去往下一个植株所需时间的计算方法为：植株坐标与当前坐标对应相减的绝对值。

要注意，采摘植株同样需要时间。

如果这个时间再加上从这里回到路上的时间之和大于规定时间，那么说明不可继续采摘，必须立刻回到路面。否则，说明可以继续采摘，记录答案。

# 代码
注：本代码仅供参考。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int m,n,k,p[25][25],cnt,nowt,needt,nowx,nowy,ans;
//p[i][j]：位于第 i 行，第 j 列的花生植株的花生数量；cnt：含有花生的花生植株数量；nowt：当前已消耗时间；
//needt：当前去往下一个植株并采摘该植株所需时间；nowx，nowy：当前所在位置；ans：可以采摘的最大花生数量
struct node{ //结构体，存储每个含有花生的植株的位置以及含有的花生数量
    int x;
    int y;
    int val;
} pea[200005];
bool cmp(node a,node b){ //结构体从大到小排序
    return a.val>b.val;
}
int main(){
    //输入
    scanf("%d %d %d",&m,&n,&k);
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            scanf("%d",&p[i][j]);
            if(p[i][j]>0){ //记录含有花生的花生植株
                cnt++;
                pea[cnt].x=j;
                pea[cnt].y=i;
                pea[cnt].val=p[i][j];
            }
        }
    }
    sort(pea+1,pea+cnt+1,cmp); //按照 cmp() 排序
    nowx=pea[1].x; //将初始 x 坐标设为第一个要去的植株的 x 坐标（这一步不消耗时间）
    for(int i=1;i<=cnt;i++){
        needt=0;
        //计算当前所需时间：去往下一个植株的时间+采摘所需时间（1单位时间）
        needt=abs(pea[i].x-nowx)+abs(pea[i].y-nowy)+1; 
        //如果当前时间加上下一步所需时间再加上回到路上的时间小于或等于 k，那么说明可以在采摘完成后，规定时间回到路上，或者继续采摘
        if(nowt+needt+pea[i].y<=k){ 
            nowt+=needt; //加上时间
            ans+=pea[i].val; //答案加上当前植株所含花生数量
            //更改位置
            nowx=pea[i].x;
            nowy=pea[i].y;
        }
        else{ //否则，说明当前需要立即回到路上，退出循环
            break;
        }
    }
    printf("%d\n",ans); //输出
    return 0;
}
```

#### 后记
更多内容，请移步至 [$\color{red}\texttt{ryf2011}$](https://www.luogu.com.cn/user/1151973 "点我进入ryf2011")。

---

## 作者：yedalong (赞：2)

## Solution
根据题意模拟即可。

首先大家得知道，对于两个位置 $(x_1,y_1)$ 和 $(x_2,y_2)$，距离其实是 $|x_1-x_2|+|y_1-y_2|$，但是还有一个前提，就是它摘完这个花生后得在不超时间的情况下回到鲁滨逊旁边，对于回不到的就不能去摘了。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
struct huasheng{
	int x,y,k;
}a[405];
bool cmp(huasheng a,huasheng b){
	return a.k>b.k;
}
int main(){
	int m,n,k;cin>>m>>n>>k;int arr[m][n];int lll=0;
	for(int i = 0;i<m;i++){
		for(int j = 0;j<n;j++){
			cin>>arr[i][j];
			if(arr[i][j]) a[lll].x=i+1,a[lll].y=j+1,a[lll].k=arr[i][j],lll++;
		}
	}
	sort(a,a+lll,cmp);int sss=lll;int sum=0;lll=0;
	int i=0,j=a[0].y;
	while(k>0&&lll<sss){
		k-=abs(a[lll].x-i);
		k-=abs(a[lll].y-j);
		k--;
		i=a[lll].x,j=a[lll].y;
		if(k-i<0) break;
		else sum+=a[lll].k,lll++;
	}
	cout<<sum;
    return 0;
}
```

---

## 作者：buickboy (赞：2)

这题用降维大法！
————用结构体来实现二维数组的降维排序。只需要33行。

------------

建二维数组再反复找最大值是很自然的想法，但这样既没必要，也费时间。注意，题目要求是按花生数从大到小依次寻找，所以不要用贪心、深搜，只要能排序就能解决了。这样又有三个问题需要解决。

------------

一是二维数组如何排序？先一维化，再排序，但需要记录行号列号，因为要计算与植株、与路边的距离。这样就要用到结构体。

------------

二是能不能采摘如何判断？要做三件事，能去、能采、能回路边。能去就要用与下一个植株的距离，也就是相应行号、列号之差的绝对值之和判断，注意不是平面坐标系上两点的距离；能采是1单位时间，能回路边是行号减0。

------------

三是注意几个坑。第一，会不会一株也采不了？第1次是从路边直接进去，与列号无关，没有距离的计算，有特殊性，所以要对第1次采摘特判。第二，采最后一株时不需要进行能去下一株的判断，这时怎么处理？直接能回路边就可以，要防止数组过界。第三，会不会去了但不够采，或者不能回？每次更新剩余时间时，能去下一株采摘的前提是问题2的三件事，回路边已经作了判断，所以既然到了下一个植株，就能够从那里采了直接回路边。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct pea{
	int a,b,s;//行、列号及花生数,行号a同时是回路边步数 
}p[600];
bool cmp(pea x,pea y){//按花生数排序规则 
	return x.s>y.s;
}
int main()
{
    int m,n,k,i,j,r=0,t,ans=0;
    scanf("%d%d%d",&m,&n,&k);
    for(i=1;i<=m;++i)
    for(j=1;j<=n;++j)
    {
    	++r;//结构体数组个数计数,最终r=m*n 
    	scanf("%d",&p[r].s);
		p[r].a=i,p[r].b=j;//记录花生数及行列号 
	}
	sort(p+1,p+1+r,cmp);//全部按花生数从大到小排好 
	if(k>=1+2*p[1].a)//采摘需要1单位时间，第1次直接去并且能回，
		k-=p[1].a+1,ans+=p[1].s;//去并且采摘，更新剩余时间，熊停在a1
	else {printf("0");return 0;}//否则不够时间采摘和回来就输出0个 
	for(i=1;i<r;++i)//站在第一株花生旁向下一步看
	{
		t=abs(p[i].a-p[i+1].a)+abs(p[i].b-p[i+1].b);//与下一点距离 
		if(k>=t+1+p[i+1].a)//能去、采、回路边,最后一步也是如此 
			k-=t+1,ans+=p[i+1].s;//就去采，更新剩余时间和采摘数 
		else break;//不能采就退出 
	}
	printf("%d",ans);
    return 0;
}

```
- 

---

## 作者：蒟蒻whker (赞：1)

蒟蒻也能听懂~

小模拟。按题意模拟即可。  
首先，用结构体存每个点，将每个有花生的位置**按花生数量从多到少**排序。  
接着，枚举每个点，先挖该点的花生，再判断能否走到下一个点，如果能，走过去，否则返回路上。  
最后，输出总时间。

详见代码。

PS：计算两点之间距离可以用[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092)。

```cpp
#include <iostream>
#include<algorithm>
using namespace std;
struct P{//结构体存点
	int x,y,p;
}a[400];
bool cmp(P a1,P b1)
{
	return a1.p>b1.p;//降序排序
}
int main(){
int m,n,k,t=0,sum=0,num=1;
	cin>>m>>n>>k;
		for(int i=1;i<=m;i++){//m列 
			for(int j=1;j<=n;j++){//n行
				cin>>a[num].p;
				a[num].x=i;//结构体存储行
				a[num].y=j;//结构体存储列
				num++;
			}
		}
	sort(a+1,a+num+1,cmp);//先排序 
	if(a[1].x*2+1>k){//如果第一个点都走不到 
		cout<<0;
		return 0;
	}
	t+=a[1].x;// 走到第一个点 
	for(int i=1;a[i].p!=0;i++)
	{
        t++;//挖当前点的花生
		sum+=a[i].p;
		if((t+abs(a[i].x-a[i+1].x)+abs(a[i].y-a[i+1].y)+1+a[i+1].x)>k)//无法走到下一个点 
		{
			break;
		}
		else
		{
			t+=abs(a[i].x-a[i+1].x)+abs(a[i].y-a[i+1].y);//走过去 
		}
		
	}
	cout<<sum;//满载而归 
	 return 0;
}

```

求过 QWQ~

---

## 作者：Forgetter (赞：1)

# Java

这题思路很简单，但是我自己给自己找麻烦，算是提高自己水平。特地去学了学内部类和HashMap和TreeMap，一次就过了，舒服了~~
~~(刚出新手村的萌新)~~
### 思路
想法是输入的时候把有值的点保存下来，并且把对应的坐标值记录下来。这是为了方便接下来算两个点之前的位移等等。我一下子想到数据结构书上的结构体。但是java老师好像没怎么提过(可能是我开小差)，于是我用**内部类**仿照着写一下。

题目对值有明确的大小选择关系，于是我选择的是 _TreeMap(从小到大)_ ,键值对里面**key存入的是花生数量**，**value存的是一个内部类的引用**。这个内部类就是C语言里面的结构体。存的是坐标值x,y。

1. 分类讨论是否第一步，第一步不用列坐标相减；
2. 在上一步里面继续分类讨论是否可以去到下一个点(去了能回家就表示可以去下一个点)。
能，则递归进下一个点；不能，即体力不够，回家return；
3. 递归以上，体力用完 或 全部采集为递归出口return。

详细的我下面的代码 _有注释_ ，像老母亲说话一样详细~~(唠叨)~~

### 注意
1.  由例二可以知道** _不求最优解，不需要贪心_ **。即如果一个较大的值判断后不可取，那么不用看剩下较小的，直接输出结果。

2.  走**第一步**的情况和之后的步骤是**不同**的哟，不用判断是第几列开始


~~有人咩？详细看下面的代码（有问题或建议可以提哟(＾Ｕ＾)ノ~）~~

------------
```java
import java.io.BufferedInputStream;
import java.util.*;
import java.util.Map.*;

public class Main {
	static int m,n,k,sum; //几行 几列 体力值 采花生数
	static int[][] t;//输入用的矩阵，我在想是不是可以不用写这个。没用
	static TreeMap<Integer,XY> map;	//键值对  key是花生数量，value是XY的引用
	static int[] a; //记录有值的点 
	//将有有值的点的(x,y)坐标记录下来，等下要用  
	class XY{
		public int x,y;		//x行数   y列数	  (别和数学坐标搞混了)
		
		public int getX() {
			return x;
		}
		public int getY() {
			return y;
		}
		public XY(int x, int y) {
			super();
			this.x = x;
			this.y = y;
		}	
	}
	
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedInputStream(System.in));
		while(sc.hasNext()){
			m = sc.nextInt(); n = sc.nextInt(); k = sc.nextInt();
			t = new int[m+1][n+1];
			map  = new TreeMap<Integer, XY>();	//初始化TreeMap
			Main test = new Main();	//实例化一个外部类,用来实例化内部类XY
			
			//输入  &  找出有值的点
			for(int i=1;i<=m;i++)
				for(int j=1;j<=n;j++){
					t[i][j] = sc.nextInt();
					if(t[i][j]!=0){
						XY zuobiao = test.new XY(i, j);
						map.put(t[i][j],zuobiao);	//存这个值 和 坐标
					}
				}
			
			//题目是从大到小。。而TreeMap的从小到大。麻烦，存到数组算了
			//遍历一下。。把key键值(花生数)存到数组a里面 
			int i=map.size()-1; 		//下标初始化
			a = new int[map.size()];	
			Iterator iter = map.entrySet().iterator();//迭代器遍历TreeMap
			while(iter.hasNext()){	//数组里面是从大到小
				Map.Entry entry = (Entry)iter.next();
				a[i--] =  (Integer) entry.getKey();
			}

			sum = 0;	//初始化
			pan(k, 0);	//调用，判断第一个最大的花生数可以采摘吗
			
			System.out.println(sum);	//终于完了，输出咯

		}sc.close();
	}
	

	//递归判断个点  通过例2可知找不到就回家，不用贪心！！！
	public static void pan(int k,int num){	//剩余体力值 第几号点
		if(num==a.length||k==0){//递归出口 全部判断完
			return;
		}else {
			if(num==0){//第一个情况特别，不用判断列走了多少
				//去、回来、采摘的体力>剩余体力 
				if(map.get(a[num]).getX()+1+map.get(a[num]).getX()>k){
					return;//出门就没体力，搞毛啊
				}else {
					sum+=a[num];	//收集花生
					//减去  去、采摘 的体力(回家的体力别减了)
					k-=(map.get(a[num]).getX()+1);
					pan(k, num+1);	//检验下一个点
				}
			}else {//其他需要判断列和横，采摘，回家的消耗体力值
				//去、回来、采摘的体力>剩余体力  （判断可以去 下个点 吗）
				// |xa - xb| + |ya - yb| + 1 + xa > k     (a当前  b上一个)
				if(Math.abs(map.get(a[num]).getX()-map.get(a[num-1]).getX())
						+Math.abs(map.get(a[num]).getY()-map.get(a[num-1]).getY())
						+map.get(a[num]).getX()+1>k){ 
					return;	//体力值不够，直接归家
				}else {	//表示去下个点后可以回家，那就去呗。
					sum+=a[num];
					//减去  去、采摘 的体力(回家的体力别减了)
					k-=(Math.abs(map.get(a[num]).getX()-map.get(a[num-1]).getX())
							+Math.abs(map.get(a[num]).getY()-map.get(a[num-1]).getY())
							+1);
					pan(k, num+1);	//检验下一个点
				}
			}
		}
	}	
}

```

---

## 作者：piske (赞：0)

# [NOIP 2004 普及组] 花生采摘
### [题目传送门](https://www.luogu.com.cn/problem/P1086)
## 思路：
用结构体存储每个花生的坐标和花生数量，排序后依次采摘。如果采摘这株花生并走出农田会超时，那就输出结果。最终采摘完所有花生。
## Coding：
```cpp
#include <bits/stdc++.h>
using namespace std;
int m,n,t;
int num[30][30];
int ans; 
struct E{
	int val;
	int x,y;
} a[1000];
int head;
bool cmp(E a,E b){
	return a.val>b.val;
}
int main( ){
	cin>>n>>m>>t;
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++){
			cin>>num[i][j];
			a[head].x=j+1;
			a[head].y=i+1;
			a[head].val=num[i][j];
			head++;
		}
	sort(a,a+head,cmp); //对所有花生排序 
	int now=0;
	int cost=0;
	int x=a[0].x;
	int y=0;
	for(int i=0;i<head;i++){
		int ncost=abs(a[i].x-x)+abs(a[i].y-y)+1;  //走到并采摘着株花生的时间 
		if(cost+ncost>t||cost+ncost+a[i].y>t){ //如果采摘并走出农田超时 
			cout<<ans;
			return 0;
		}
		cost+=ncost;
		x=a[i].x;
		y=a[i].y;
		ans+=a[i].val;
	}
	cout<<ans; //全部采摘完 
	return 0;
} 
```

---

## 作者：LeavingAC (赞：0)

**begin**

[P1086 [NOIP 2004 普及组] 花生采摘](https://www.luogu.com.cn/problem/P1086)

# 前言

真的很简单的一道题目。

# 思路

读完题这道大家脑子里应该都有两个字——**贪心**，这也是为什么题目要强调所有花生数量不相同的原因。

因为并不是所有地方都有花生，所以我们只用开个结构体从大到小排序有花生的地方就好了。

然后我们一个花生一个花生拿，如果距离不够就直接回去，如果够就接着拿。

# Code
```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define gc() getchar()
#define pc(a) putchar(a)
#define sqrt(a) __builtin_sqrt(a)
#define gcd(a,b) __gcd(a,b)
#define lcm(a,b) a/__gcd(a,b)*b
#define y1 fuck_cmath
using namespace std;
const int M=30;
struct node
{
    ll x,y,sum;
    bool operator<(const node &T)const{return sum>T.sum;} // 结构体排序
}p[M*M];
ll m,n,k,a,cnt,ans,sx,sy,ex,ey,dis;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>m>>n>>k;
    for (ll i=1;i<=m;i++)
    {
        for (ll j=1;j<=n;j++)
        {
            cin>>a;
            if (a) p[++cnt]=(node){i,j,a};
            // 如果有花生就记录
        }
    }
    sort(p+1,p+cnt+1);
    k--; // 减去进田的时间
    sx=1,sy=p[1].y; // 离最多的花生最近的点
    for (ll i=1;i<=cnt;i++)
    {
        ex=p[i].x,ey=p[i].y;
        dis=abs(sx-ex)+abs(sy-ey); // 计算最短距离
        k-=dis+1; // 走路时间和摘花生时间
        if (k>=ex) // 如果够就往前走
        {
            ans+=p[i].sum;
            sx=ex,sy=ey;
        }
        else // 不够就收手
        {
            cout<<ans;
            return 0;
        }
    }
    cout<<ans; // 都拿完了
    return 0;
}
```

**end**

---


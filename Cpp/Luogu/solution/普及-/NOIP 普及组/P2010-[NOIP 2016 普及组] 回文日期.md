# [NOIP 2016 普及组] 回文日期

## 题目背景

NOIP2016 普及组 T2

## 题目描述

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 $8$ 位数字表示一个日期，其中，前 $4$ 位代表年份，接下来 $2$ 位代表月份，最后 $2$ 位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 $8$ 位数字是回文的。现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。

一个 $8$ 位数字是回文的，当且仅当对于所有的 $i$（$1  \le i \le 8$）从左向右数的第 $i$ 个数字和第 $9-i$ 个数字（即从右向左数的第 $i$ 个数字）是相同的。

例如：

- 对于 2016 年 11 月 19 日，用 $8$ 位数字 $20161119$ 表示，它不是回文的。
- 对于 2010 年 1 月 2 日，用 $8$ 位数字 $20100102$ 表示，它是回文的。
- 对于 2010 年 10 月 2 日，用 $8$ 位数字 $20101002$ 表示，它不是回文的。

每一年中都有 $12$ 个月份：

其中，$1, 3, 5, 7, 8, 10, 12$ 月每个月有 $31$ 天；$4, 6, 9, 11$ 月每个月有 $30$ 天；而对于 $2$ 月，闰年时有 $29$ 天，平年时有 $28$ 天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

1. 这个年份是 $4$ 的整数倍，但不是 $100$ 的整数倍；
2. 这个年份是 $400$ 的整数倍。

例如：

- 以下几个年份都是闰年：$2000, 2012, 2016$。
- 以下几个年份是平年：$1900, 2011, 2014$。

## 说明/提示

**【样例说明】**

对于样例 1，符合条件的日期是 $20111102$。

对于样例 2，符合条件的日期是 $20011002$ 和 $20100102$。

**【子任务】**

对于 $60 \%$ 的数据，满足 $\mathit{date}_1 = \mathit{date}_2$。

## 样例 #1

### 输入

```
20110101
20111231
```

### 输出

```
1
```

## 样例 #2

### 输入

```
20000101
20101231
```

### 输出

```
2
```

# 题解

## 作者：「QQ红包」 (赞：696)

枚举后面四位（月份+日期）会更快。

枚举后四位然后求出整个日期，判断是否在范围内即可。

2月不需要判断是否是闰年，因为0229反过来是9220，整个日期是92200229，而9220年是闰年。

```cpp
#include<iostream> 
#include<cstdio>
#include<string>
#include<map>
#include<set>
#include<queue>
#include<vector> 
using namespace std;
int i,j,n,m,a,b,c,sum,ans;
int s[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=12;i++)//枚举月和日 
        for (j=1;j<=s[i];j++)
        {
            c=(j%10)*1000+
              (j/10)*100+
              (i%10)*10+
              (i/10);//算出前四位。
            sum=c*10000+i*100+j;//算出整个日期 
            if (sum<n||sum>m) continue;
            ans++;//统计 
        }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：12)

## 思路
这题看起来很复杂，实际很水。

首先，我们看到题目中有两段话，介绍了什么是闰年，其实这是废话。闰年与平年的最大区别就是多了一个 $2$ 月 $29$ 日，而 $0229$ 反过来是 $9220$，$9220$ 是闰年，所以 $92200229$ 是一个合法的回文日期。

接下来，我们考虑直接使用暴力，把**所有**合法的回文日期**全部**枚举一遍，看它是否在给出的区间内即可。注意枚举顺序是先枚举日和月，再根据日和月构造出年份，最后构造出合法的回文日期。

```cpp
#include<iostream>
using namespace std;
int month[13]={0,31,29,31,30,31,30,31,31,30,31,30,31},l,r,ans;
signed main() {
	cin>>l>>r;
	for(int i=1;i<=12;i++){
		for(int j=1;j<=month[i];j++){
			int now=(j%10*1000+j/10*100+i%10*10+i/10)*10000+i*100+j;//构造出合法的回文日期
			if(now>=l&&now<=r)ans++;//判断它是否在给出的区间内
		}
	}
	cout<<ans;
}
```

---

## 作者：cff_0102 (赞：5)

可以枚举所有可能的月和日，然后把对应可以回文的年份计算出来，并打一张表。$2$ 月 $29$ 号对应的回文日期年份是 $9220$ 年，恰好是个闰年，这个别忘了考虑。

把打出来的 $366$ 种可能的回文日期排个序，就可以直接二分了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int m[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int a[370],cnt=0;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	for(int i=1;i<=12;i++){
		for(int j=1;j<=m[i];j++){
			int x=i*100+j;
			a[++cnt]=x+10000*(x/1000+10*((x/100)%10)+100*((x/10)%10)+1000*(x%10));
		}
	}
	sort(a+1,a+1+366);
	int l,r;cin>>l>>r;
	cout<<upper_bound(a+1,a+1+366,r)-lower_bound(a+1,a+1+366,l);
	return 0;
}
```

---

## 作者：ShirasuAzusaSaikou (赞：4)

一个颇为暴力的做法，~~不过毕竟是枚举题（逃~~  
隆重介绍 cpp 两个好用的 stoi/stoll 和 to_string ， 直接暴力解开此题。  
对于本题，不难看到实际上是否存在回文是看年份的。  
（例如 $2020 \to 20200202$ 可行，$2018 \to 20188102$ 不可行）  
因此对每个可行年份建立回文，再判断是否在范围内即可。  
所以这道题核心分为日期有效性的判断和回文的建立。  
而由于所有年份都是有效+四位数，所以保证没有首位为零的情况出现，判断是否在范围内直接用 stoi 即可。  
回文的建立，只需使用 substr 得出年份，然后把年份反过来加回进去就行。 ~~（其实可以用 reverse ，但我忘了咋写~~  

```cpp
#include <bits/stdc++.h>
using namespace std;


//创造回文
const string pali(string x){
    int len = x.length();
    for(int i = len - 1; i >= 0; i--){
        x += x[i];
    }
    return x;
}

//检查日期是否有效
const bool valid(string x){
    int y = stoi(x.substr(0, 4));
    int m = stoi(x.substr(4, 2));
    int d = stoi(x.substr(6, 2));
    if(m == 2){
        if(y % 400 == 0 or (y % 4 == 0 and y % 100 != 0)) return (d >= 1 and d <= 29);
        else return (d >= 1 and d <= 28);
    }
    return ((m == 1 or m == 3 or m == 5 or m == 7 or m == 8 or m == 10 or m == 12) and d >= 1 and d <= 31) or 
        ((m == 4 or m == 6 or m == 9 or m == 11) and d >= 1 and d <= 30);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string d1, d2;
    cin >> d1;
    cin >> d2;
    int x = stoi(d1.substr(0, 4)); //d1 年份
    int y = stoi(d2.substr(0, 4)); //d2 年份
    //new1 = 用d1的年份做出一个回文数，new2同理
    string new1 = pali(d1.substr(0, 4)), new2 = pali(d2.substr(0, 4));
    //此处做new1的判断，首先判断日期是否有效，然后再判断日期是否在d1和d2之间
    int cnt = (valid(new1) and stoi(new1) >= stoi(d1) and stoi(new1) <= stoi(d2));
    //此处做new2的判断，首先判断日期是否有效，然后再判断日期是否在d1和d2之间
    //之所以分开new1和new2，是因为年份可能相同，若是不分开做判断，将会重复计算cnt
    if(x != y) cnt += (valid(new2) and stoi(new2) >= stoi(d1) and stoi(new2) <= stoi(d2));
    for(int i = x + 1; i < y; i++){
        //这个位置就直接创造回文数，然后再检查是否有效即可
        cnt += valid(pali(to_string(i)));
    }
    cout << cnt << endl;
    return 0;
}

```

---

## 作者：Nahia (赞：3)

### 思路

一个一个枚举，找到符合条件的就将可行数加一。

注意如果这是第一年的第一个月，那么就要从题目给的第一天开始枚举，最后一年的最后一个月同理。

### solution

（很长时间之前写的，码风略丑请见谅）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<string>
#include<cstring>
using namespace std;
int day[15] = {0,31,28,31,30,31,30,31,31,30,31,30,31},cnt;
bool _(int x){//用于判断是否是闰年
	if(x%4==0 && x%100!=0 || x%400==0) return 1;
	return 0;
}
int main(){
	string a,b;
	cin>>a>>b;
	int y1,m1,d1,y2,m2,d2;
	y1 = stoi(a.substr(0,4));
	y2 = stoi(b.substr(0,4));
	
	m1 = stoi(a.substr(4,2));
	m2 = stoi(b.substr(4,2));
	
	d1 = stoi(a.substr(6,2));
	d2 = stoi(b.substr(6,2));
	
	for(int i = y1;i<=y2;i++){
		for(int j = (i==y1?m1:1);j<=(i==y2?m2:12);j++){
			int ans = 0;
			if(j==2) ans = _(i);//将闰年的2月29号加上
			for(int k = (i==y1&&j==m1?d1:1);k<=(i==y2&&j==m2?d2:day[j]+ans);k++){
				string t = to_string(i)+(j>9?"":"0")+to_string(j)+(k>9?"":"0")+to_string(k),t2;
				t2 = t;
				reverse(t.begin(),t.end());
				cnt+=(t==t2);
			}
		}
	}
	cout<<cnt;
	return 0;
} 
```

---

## 作者：collegiate (赞：3)

### 思路
看到月份之后，不妨用一个 $month$ 数组来记录 $1$ 月到 $12$ 月的天数，这样可以让代码简洁一点。

然后看见回文，前面年份不好维护，维护**月份和天数**嘛！一年 $12$ 月，每个月 $month_i$ 天，那么月份和天数所构成的数字就可以轻易求出来。

那么再把回文日期还原，也就是把月份和天数所构成的数字**倒过来**，最后判断一下是否在给定的日期范围内就可以啦！

**注意一下**，我们可以不用判断 $2$ 月的 $29$ 天，例如 $9220$ 年，反过来的月份的天数是 $0229$，整个日期是 $92200229$，是回文日期，因此不用特判。     

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mon[]={0,31,29,31,30,31,30,31,31,30,31,30,31};
long long st,ed,ans=0;
int main(){
	cin>>st>>ed;
	
	for(int i=1;i<=12;i++){
		for(int j=1;j<=mon[i];j++){
			int date=( (j%10)*1000 + (j/10)*100 +
            (i%10)*10 + (i/10)*1 )*10000 + i*100 + j;
            //这里是直接求出回文日期
			if(date>=st && date<=ed) ans++;//比较
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：3)

骗分方法：首先回文日期并不多，所以我们可以输出 $0,1,2$ 来骗取部分分。

---

正解：首先我们可以枚举年份，然后我们可以根据年份构造一个回文日期，如果这个回文日期是合法的，个数加一。
构造时要注意一下几点：

- 月份一定是 $1$ 到 $12$ 月，然后我们需要根据月份返回这个月有多少天，如果构造的这天的天数比返回的天数多就不合法。
- 如果构造出来的日期比 $date_1$ 小或者比 $date_2$ 大就不行，直接跳过即可。\
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[15];
int getday(int nian,int yue)//根据月数返回对应的天数
{
	if(yue==4||yue==6||yue==9||yue==10)
	{
		return 30;
	}
	else if(yue==2)
	{
		if(nian%400==0) return 29;//闰年判断
		else if(nian%4==0&&nian%100!=0) return 29;//同上
		return 28;
	}
	else return 31;//剩下的一定是31天的月数
}
int check(int nian,int yue,int ri)
{
	if(yue<1||yue>12) return false;//检查月是否合法
	int day=getday(nian,yue);
	if(ri<1||ri>day) return false;//检查日是否合法
	return true;
}
signed main()
{
	//freopen("date.in","r",stdin);
	//freopen("date.out","w",stdout);
	//ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int s,e;
	cin>>s>>e;
	int sum=0;
	for(int i=s/10000;i<=e/10000;i++)
	{
    //这里可以根据回文日期的特性来构造，回文日期就是xyzq.qz.yx。
		int ge=i%10;
		int shi=i/10%10;
		int bai=i/100%10;
		int qian=i/1000%10;
		int yue=ge*10+shi;
		int ri=bai*10+qian;
		if(check(i,yue,ri)==0)//如果构造的日期不合法
		{
			continue;
		}
		if(i*10000+yue*100+ri<s||i*10000+yue*100+ri>e) continue;//如果不在给定区域范围内
		sum++;
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2010)

---
### 思路：
枚举后四位然后就可以求出整个具体日期，判断是否在范围内即可。

那么，就要用一个数组来存放我们十二个月的日期。
```cpp
int day[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
```
然后枚举月和日，算出前四位和整个日期，最后看看是不是合法日期并且是不是在范围中的，如果是，计数器加一。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int day[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, n, m, x = 0, y = 0, ans = 0;

int main() {
	cin >> n >> m;
	for (int i = 1; i <= 12; i++) {
		for (int j = 1; j <= day[i]; j++) {
			x = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10;
			y = x * 10000 + i * 100 + j;
			if (y >= n && y <= m) ans++;
		}
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：All_Wrong_Answer (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2010)

## 思路：

**枚举**，依次判断从 $\mathit{date}_1$ 到 $\mathit{date}_2$ 之间的所有日期是否回文即可。

有一些细节：

1. 本题判断闰年的方法是：如果能被四百整除，是闰年，否则如果能被四整除但不能被一百整除，也是闰年，其它的年份都不是闰年。
2. 记得判断新年与新的一个月，并将原来的月份或日期重新设为 $1$。
3. 起始年和结束年都要遍历到。

为了方便，**可以先打表帮忙储存日期**。

## 完整代码：


```cpp
#include <iostream>
using namespace std;
char x[9];
int qn,qy,qt,jn,jy,jt;
int db1[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//非闰年表 
int db2[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};//闰年表 
int main(){
	cin>>x;
	qn=(x[0]-'0')*1000+(x[1]-'0')*100+(x[2]-'0')*10+(x[3]-'0');
	qy=(x[4]-'0')*10+(x[5]-'0');
	qt=(x[6]-'0')*10+(x[7]-'0');
	//处理初始年份 
	cin>>x;
	jn=(x[0]-'0')*1000+(x[1]-'0')*100+(x[2]-'0')*10+(x[3]-'0');
	jy=(x[4]-'0')*10+(x[5]-'0');
	jt=(x[6]-'0')*10+(x[7]-'0');
	//处理结束年份 
	int f=0,da=0;
	while(1){
		if(f==1) break;
		if(qn==jn&&qy==jy&&qt==jt) f=1;//到达结束年份 
		if((qn/1000)%10==(qt%10)&&(qn/100)%10==(qt/10)%10&&(qn/10)%10==qy%10&&(qn%10)==(qy/10)%10) da++;//是否回文 
		qt++;//日期加1 
		if(qn%4==0&&qn%100!=0||qn%400==0){
			if(qt==db2[qy]+1){
				qy++;
				qt=1;
			}
		}//处理闰年月份的增加 
		else{
			if(qt==db1[qy]+1){
				qy++;
				qt=1;
			}
		}//非闰年月份处理 
		if(qy==13){
			qn++;
			qy=1;
		}//新年 
	}
	cout<<da;
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：1)

## Solution

直接枚举太麻烦，大体思路是枚举后四位然后，然后就可以求出整个具体日期，判断是否在范围内即可。

先根据常识写出每月的日期，这样枚举月和日方便。（做这种题目一般都要用）

`ll days[15] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};`

前面写一个 $0$ 是因为数组下标从 $0$ 开始，为了方便访问，于是随便拿一个数字占位。

然后直接枚举算出前四位和整个日期，最后看看是不是合法日期，如果是，计数器加一。最后输出计数器里面的数即可。

特别注意，$2$ 月不需要判断是否是闰年，因为 $2$ 月 $29$ 号对应的回文日期年份是 $9220$ 年，恰好是个闰年。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, m, ans;
ll days[15] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int main() {
	cin >> n >> m;
	for (int i = 1; i <= 12; i++) {
		for (int j = 1; j <= days[i]; j++) {
			ll x = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10;
			ll y = x * 10000 + i * 100 + j;
			if (y >= n && y <= m) ans++;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：1)

### 题目分析

枚举后四位然后就可以求出整个具体日期，判断是否在范围内即可。

用一个数组来存放我们十二个月的日期。然后枚举月和日，算出前四位和整个日期，最后看看是不是合法日期并且是不是在范围中的，如果是，答案加一。

特殊的：$2$ 月不需要判断是否是闰年，因为 $0229$ 反过来是 $9220$，整个日期是 $92200229$，而 $9220$ 年是闰年。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, n, m, x = 0, y = 0, ans = 0;
int main() {
	cin >> n >> m;
	for (int i = 1; i <= 12; i ++) {
		for (int j = 1; j <= a[i]; j ++) {
			x = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10;
			y = x * 10000 + i * 100 + j;
			if (y >= n && y <= m) ans ++;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：zouchenjun (赞：1)

### 题意
给与两个日期，求出第 $1$ 个日期到第 $2$ 个日期中的回文日期。
### 思路
考虑模拟。枚举每一年每一月每一日即可。注意要是否超出日期范围。   
$2$ 月需要判断年份，如果是闰年，$2$ 月设为 $29$ 天。  


---
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int mouth[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//存储每个月的天数
int a,b;
int rn(int k,int j){
	return j==2&&(k%400==0||(k%4==0&&k%100!=0));//判断是否是二月、闰年
}
int main(){
	int ans=0;
	cin>>a>>b;
	for(int i=a/10000;i<=b/10000;i++){
		int s1=1; //s1代表月份开始，s2代表月份结束
		int e1=12;
		if(i==a/10000)s1=a%10000/100;
		if(i==b/10000)e1=b%10000/100;
		for(int j=s1;j<=e1;j++){
			int s2=1,e2=mouth[j]+rn(i,j);
			if(j==s1&&i==a/10000)//判断日期开始和结束
				s2=a%100;
			if(j==e1&&i==b/10000)
				e2=b%100;
			for(int q=s2;q<=e2;q++){//枚举日期
				int v=i*10000+j*100+q,e=0;
				while(v>0){
					e=e*10+v%10;
					v=v/10;
				}
				if(e==i*10000+j*100+q)ans++;//如果倒过来和原来一样，就是回文。
			}
		}
	}
	cout<<ans;
}

```

---

## 作者：RedreamMer (赞：1)

# P2010 题解

算法：暴力枚举

因为回文日期一定是8位的，所以年份的回文形式一定是月份+日期，从这点突破此题并且不会超时

首先从年份开始枚举，把所有年份的回文形式列出来，判断是否是合法的日期，再进行判断日期是否在范围内，思路很好理解，只是处理数据有点麻烦

### code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,aa,bb,cc,som;
int M[13]= {0,31,28,31,30,31,30,31,31,30,31,30,31};
bool check(int n) {//判断年份回文后是否合法
	int p1=n%10*10+n/10%10;
	int p2=n/100%10*10+n/1000;
	if(p1>=1&&p1<=12) {
		if(p2>=1) {
			if(p1==2&&n%4==0&&n%100||n%400) {
				if(p2<=29)
					return 1;
			}
			if(p2<=M[p1])
				return 1;
		}
	}
	return 0;
}
int main() {
	scanf("%4d%2d%2d\n%4d%2d%2d",&a,&b,&c,&aa,&bb,&cc);//输入优化，利用scanf搞定可以把输入的内容拆分成各个有用数字
	for(int i=a; i<=aa; i++) {
		if(check(i)) {
			int p1=i%10*10+i/10%10;
			int p2=i/100%10*10+i/1000;
			if(i<aa||i==aa&&p1<bb||i==aa&&p1==bb&&p2<=cc)//判断是否在时间范围内 
				if(i>a||i==a&&p1>b||i==a&&p1==b&&p2>=c)
					som++;
		}
	}
	cout<<som;
	return 0;
}
```
#### [My Blog](https://www.luogu.org/blog/184549/)

---

## 作者：Actinoi (赞：1)

**为获取最佳阅读效果，欢迎访问[Atinoi's blog : NOIP2016 普及组](https://www.actinoi.com/2019/09/23/noip2016%20%E6%99%AE%E5%8F%8A%E7%BB%84/)**

&emsp;本题是一个字符串问题。

​​&emsp;依次读入起始日期 $start$ 与终止日期 $end$ ，然后，枚举年 $year$ 、月 $month$ 与日 $day$ ，然后，$year$ 赋值为 $start\ /\ 10000$ , $month$ 赋值为 $(start\ \%\ 10000)\ /\ 100$ , $day$ 赋值为 $start\ /\ 10000$ 。

​​&emsp;首先，枚举月与日到次年的 1 月 1 日，然后，将 $year$ 再枚举到 $year\ <\ end\ \ /\ 10000$  。最后，再次枚举月与日从终止年年的 1 月 1 日枚举到终止年的 $(end\ \%\ 10000)\ /\ 100$ 月与 $end\ \%\ 100$ 日，然后判断是不是回文日期。

​​&emsp;那么，如何判断是不是回文日期呢？无疑，将年月日看作一个八位数字，如果第一位等于最后一位，第二位等于倒数第二位，第三位等于倒数第三位，第四位等于倒数第四位的话那么这个日期便是一个回文日期，也就是 ```year / 1000 == day % 10 && (year - year / 1000 * 1000) / 100 == day / 10 && (year % 100 - year % 10) / 10 == month % 10 && year % 10 == month /10``` 。

​​&emsp;最后，输出回文日期总数就可以啦！

```cpp
#include <cstring>
#include <iostream>
using namespace std;
int days[13] = {0, 31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
void leap(int n) { //判断是不是闰年
    if ((n % 4 == 0 && n % 100 != 0) || n % 400 == 0) //是闰年
        days[2] = 29;
    else //是平年
        days[2] = 28;
}
bool judge (int year, int month, int day) { //判断是不是回文日期
    if (year / 1000 == day % 10 && (year - year / 1000 * 1000) / 100 == day / 10 && (year % 100 - year % 10) / 10 == month % 10 && year % 10 == month /10)
        return true;
    return false;
}
int main() {
    int start, end;
    cin >> start >> end;
    int year = start / 10000, month = (start % 10000) / 100, day = start % 100;
    
    leap(year);
    int ans = 0;
    for (int i = day; i <= days[month]; i++)
        ans += judge(year, month, i);
    month++;
    day = 1;
    for (int i = month; i <= 12; i++)
        for (int j = 1; j <= days[i]; j++)
            ans += judge(year, i, j);
    year++;
    month = day = 1;
    
    while (year < end / 10000) { //枚举年份
        leap(year);
        for (int i = 1; i <= 12; i++)
            for (int j = 1; j <= days[i]; j++)
                ans += judge(year, i, j);
        year++;
    }
    
    leap(year);
    for (int i = 1; i < (end % 10000) / 100; i++)
        for (int j = 1; j <= days[i]; j++)
            ans += judge(year, i, j);
    for (int i = 1; i <= end % 100; i++)
        ans += judge(year, (end % 10000) / 100, i);
    
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Drawing_Yang (赞：1)

虽说正解好，但还是想展现一下以面向对象的写法。
code:

```cpp
#include <iostream>
#include <cstring>
using namespace std;
class Data {
	private:
		bool pdyear(int k) {
			if ((k%4==0&&k%100!=0)||(k%400==0)) return 1;
			return 0;
		}
		int pdmon(int k,int year) {
			if (k==1||k==3||k==5) return 31;
			if (k==7||k==8||k==10||k==12) return 31;
			if (k==4||k==6||k==9||k==11) return 30;
			if (k==2) {
				if (pdyear(year)) return 29;
				else return 28; 
			}
		}
	public:
		int year;
		int month;
		int day;
		void init() {
			year=0;
			month=0;
			day=0;
		}
		Data(int y,int m,int d) {
			year=y;
			month=m;
			day=d;
		}
		void print() {
			cout<<year<<"-"<<month<<"-"<<day<<endl;
		}
		bool huiwen();
	Data operator++(int) {
		Data D(year,month,day);
		++day;
		if (day>pdmon(month,year)) {
			day-=pdmon(month,year);
			++month;
		}
		if (month>12) {
			++year;
			month-=12;
		}
		return D;
	}
	bool operator<=(const Data& d) {
		if (year<=d.year) return true;
		if (year==d.year&&month<=d.month) return true;
		if (year==d.year&&month==d.month&&day<=d.day) return true;
		return false;
	}
};
bool Data::huiwen() {
	int a[10],i=4,b[10],p;
	int y1=year,m1=month,d1=day;
	while (y1!=0&&i>0) {
		a[i]=y1%10;
		y1/=10;
		i--;
	}
	i=6;
	while (i>4) {
		a[i]=m1%10;
		m1/=10;
		i--;
	}
	i=8;
	while (i>6) {
		a[i]=d1%10;
		d1/=10;
		i--;
	}
	for (i = 8,p = 1;i >= 1;i--,p++) b[i]=a[p];
	for (i = 1;i <= 8;i++) if (a[i]!=b[i]) return false;
	return true; 
}
int main() {
	string s;
	int year=0,month=0,day=0,sum=0;
	cin>>s;
	for (int i = 0;i <= 3;i++) year=year*10+s[i]-'0';
	for (int i = 4;i <= 5;i++) month=month*10+s[i]-'0';
	for (int i = 6;i <= 7;i++) day=day*10+s[i]-'0';
	Data begin(year,month,day);
	year=0;month=0;day=0;
	cin>>s;
	for (int i = 0;i <= 3;i++) year=year*10+s[i]-'0';
	for (int i = 4;i <= 5;i++) month=month*10+s[i]-'0';
	for (int i = 6;i <= 7;i++) day=day*10+s[i]-'0';
	Data end(year,month,day);
	while (begin<=end) {
		if (begin.huiwen()) sum++;
		begin++;
	}
	cout<<sum<<endl;
	return 0;
}
```

虽然~~有点~~长，只是提供一种思路

---

## 作者：_SLL_ (赞：1)

我们先用一个数组，把每月的日数存起来。

```
int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
```

枚举出后面的月份+日期，再把整个日期算出判断一下即可。

如果在范围内，计数器累加。

### AC code
```cpp
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
int a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int s,l,ans,x,res;
signed main(){
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    scanf("%lld%lld",&s,&l);
    for(int i=1;i<=12;i++){
        for(int j=1;j<=a[i];j++){
            x=(j%10)*1000+(j/10)*100+(i%10)*10+i/10;
            res=x*10000+i*100+j;
            if(res<s||res>l){
                continue;
            }
            ans++;
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：SMall_X_ (赞：1)

[原题传送门](https://www.luogu.com.cn/problem/P2010)

---

显然，因为日期要回文，所以我们枚举月和日，那整个日期自然就可以确定了，接下来就只需要判断组成的这个日期是否在 $date_1\sim date_2$ 这个区间里了。值得一提的是，对于 $2$ 月 $29$ 日，对应的是 $9220$ 年，$9220$ 年是闰年，所以无需特判平年的情况。

## $\texttt{code1}$

```cpp
/*Written by smx*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define QAQ cout<<"QAQ\n";
const int MAXN=1e5+5,inf=1e18,mod=1e9+7;
int mon[13]={114514,31,29,31,30,31,30,31,31,30,31,30,31};
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int date1,date2,ans=0;
	cin>>date1>>date2;
	for(int m=1;m<=12;m++){
		for(int d=1;d<=mon[m];d++){
			int date=(d%10*1000+d/10*100+m%10*10+m/10)*10000+m*100+d;
			if(date>=date1&&date<=date2){
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

我们也可以枚举年份，判断年份反转后的月、日是否合法且日期是否在 $date_1\sim date_2$ 之间即可。

## $\texttt{code2}$

```cpp
/*Written by smx*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define QAQ cout<<"QAQ\n";
const int MAXN=1e5+5,inf=1e18,mod=1e9+7;
int mon[100]={114514,31,29,31,30,31,30,31,31,30,31,30,31};
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int date1,date2,ans=0;
	cin>>date1>>date2;
	for(int y=date1/10000;y<=date2/10000;y++){
		int m=y%10*10+y/10%10,d=y/1000+y/100%10*10,date=y*10000+m*100+d;
		if(y%4==0&&y%100!=0||y%400==0){
			mon[2]=29;
		}else{
			mon[2]=28;
		}
		if(m>=1&&m<=12&&d>=1&&d<=mon[m]&&date>=date1&&date<=date2){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ylzpl (赞：0)

思路很简单，把每种回文日期构造处来，然后看是否合法即可。
在判断是否合法时，可以写一些预处理：
- 把每个月的天数先存下来，方便使用。
- 写一个反转数字的函数，方便判断是否是回文日期。  
代码:

```cpp
#include <bits/stdc++.h>
using namespace std;

int Reverse(int x){//反转数字函数
	int y = 0;
	while(x != 0){
		y = y * 10 + x % 10;
		x = x / 10;
	}
	return y;
}
int d[2][12] = {{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};//存日期
int main(){
	int a, b, year1, month1, day1, year2, month2, day2;
	cin >> a >> b;
  //构造回文日期
	day1 = a % 100;
	a /= 100;
	month1 = a % 100;
	a /= 100;
	year1 = a;
	day2 = b % 100;
	b /= 100;
	month2 = b % 100;
	b /= 100;
	year2 = b;
	a = year1 * 10000 + month1 * 100 + day1;
	b = year2 * 10000 + month2 * 100 + day2;
	int ans = 0;
	while(a <= b){
		int x = year1 * 10000 + month1 * 100 + day1;
		if(Reverse(x) == x){//如果反转后还是x就说明找到回文日期了
			ans += 1;//计数器+1
		}
		day1++;
		int run = 0;
		if(year1 % 400 == 0 || (year1 % 4 == 0 && year1 % 100 != 0)){//判断闰年
			run = 1;
		}
		if(day1 == d[run][month1-1]+1){//超出天数的范围就回到1日
			day1 = 1;
			month1++;//超出天数就到了下一年
		}
		if(month1 == 13){//如果超出了12月就得回到1月
			month1 = 1;
			year1++; //超过12月就是下一年。
		}
		a = year1 * 10000 + month1 * 100 + day1;//把构造的日期更新，方便下一轮判断
	}
	cout << ans << endl;
	return 0;
}
```

---


# [NOIP 2014 普及组] 比例简化

## 题目背景

NOIP2014 普及组 T2

## 题目描述

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 $1498$ 人，反对的有 $902$ 人，那么赞同与反对的比例可以简单的记为 $1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 $A$，反对人数 $B$，以及一个上限 $L$，请你将 $A$ 比 $B$ 化简为 $A'$ 比 $B'$，要求在 $A'$ 和 $B'$ 均不大于 $L$ 且 $A'$ 和 $B'$ 互质（两个整数的最大公约数是 $1$）的前提下，$\dfrac{A'}{B'} \ge  \dfrac{A}{B}$ 且 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 的值尽可能小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le A \le 10^6,1 \le B \le 10^6,1 \le L \le 100,\dfrac{A}{B} \le L$。


## 样例 #1

### 输入

```
1498 902 10```

### 输出

```
5 3```

# 题解

## 作者：以墨 (赞：326)

这道题的L范围是很有良心的，L小于等于100，则可以直接枚举分子和分母。可以看出分子分母的枚举范围都是1到L，之后可以写一个最大公约数，判断分子分母的最大公约数是否为1（可以用辗转相除法）。然后到了本题的第一个坑：分子分母的比值要大于A和B的比值。根据小学数学的交叉相乘法，就可以将这个式子写成：现分子\*B<=现分母\*A。到了最后一个条件了，使分子分母的比值要尽可能地接近A和B的比值，可以把所有符合上面两个条件的分子分母在一起比较，选出最优解。

附上代码：



```cpp
#include<cstdio>
using namespace std;
int gcd(int x,int y)
{
    if(y==0) return x;
    return gcd(y,x%y);
}
int main()
{
        int i,j,a,b,ansa,ansb,l;
        scanf("%d%d%d",&a,&b,&l);
        ansa=l;ansb=1;
        for(i=1;i<=l;i++)
                for(j=1;j<=l;j++)
                        if(gcd(i,j)==1&&i*b>=j*a&&i*ansb<j*ansa)
                        {
                                ansa=i;
                                ansb=j;
                        }
        printf("%d %d",ansa,ansb);
        return 0;
}

```

---

## 作者：moongazer (赞：160)

Update in 2019.11.03:加入$\LaTeX$,更正了一个bug

本文旨在提供另一种思考的思路

## 思路
考虑一个分数$\frac{i}{j}$：
1. 如果$\frac{i}{j}<\frac{a}{b}$那么$i$应当$+1$
2. 如果$\frac{i}{j}\ge\frac{a}{b}$那么$j$应当$+1$

初始时$i=j=1$,$i>n$或$j>n$时停止($n$是题目中的$l$)

$ans$即为所有满足$\frac{i}{j}\ge\frac{a}{b}$的$\frac{i}{j}$的最小值

## 注意事项

浮点数运算不够准确,考虑变形

对于不等式$\frac{i}{j}\ge\frac{a}{b}$可以变形为$i\cdot b\ge a\cdot j$

这样就只需要做整数乘法即可

## 复杂度分析
$i$和$j$每次有一个$+1$,有一个$>n$时停止,时间复杂度$O(n)$

## 代码
注:以下代码只保留main函数,read和write是读入优化和输出优化
```cpp
int main(){
  int a, b, i, j, n;
  read(a), read(b), read(n);
  int ans1 = n, ans2 = 1;
  i = 1, j = 1;
  while (true) {
    if (a * 1ll * j <= b * 1ll * i) {
      if (i * 1ll * ans2 < j * 1ll * ans1){
        ans1 = i;
        ans2 = j;
      }
      j++;
      if (j > n) {
        break;
      }
    } else {
      i++;
      if (i > n) {
        break;
      }
    }
  }
  write(ans1), SP, write(ans2), EL;
  return 0;
}
```

---

## 作者：FCBM71 (赞：32)

和楼下的思路一样，都是直接在 $1..L$ 的范围内枚举答案，不过我在他的基础上又做了一些优化。

我打算用$P$来存储$A_2/b_2$，$Q$来储存$A/B$，S来储存目前$P-Q$的最小值

求最大公约数这个步骤可以省略。我们就以(6,4)为例。6 4可以化简为3 2。 而我们在枚举6 4之前必然已经枚举过了3 2，所以即使3/2和6/4的$P-Q$值相同，$S$只会在算出了更小的$P-Q$时才会刷新。故不用求gcd。

---

贴上pascal代码
```pascal
program hrn;
 var
  p,q,s:double;
  a,b,l,i,j,x,y:longint;
 begin
  read(a,b,l);
  q:=a/b;s:=maxlongint;  //初始化Q和S
  for i:=1 to l do
   for j:=1 to l do begin  //开始枚举
    p:=i/j;
    if(p>=q)and(p-q<s)then begin //注意，一定要是p>=q
     s:=p-q;
     x:=i;y:=j;
    end;                 //寻找到更小的P-Q时，更新S和答案
   end;
  write(x,' ',y);
 end.

```

---

## 作者：karsl (赞：5)

## 思路

考虑枚举每一个 $ A, B $，因为 $ A $ 与 $ B $ 的值均达到 $ 10^6 $，很显然会超时。

接下来换一种思路，因为答案的 $ A', B' $ 都在 $ L $ 范围内，所以可以尝试枚举 $ L $，而 $ L $ 的取值范围最大仅为 $ 10^2 $，直接枚举分子和分母的 $ A', B' $ 并判断是否符合要求即可。

若 $ \frac{A'}{B'} $ 是合法的，应满足：

- $ \gcd(A',B') = 1 $
- $ \frac{A'}{B'} \geq \frac{A}{B} $

考虑从小到大枚举，若存在 $ \frac{i}{j} = \frac{A'}{B'} $ 且 $ \gcd(i,j) \neq 1 $ ，因为 $ i > A', j > B' $，可知该解在**约去公因数后得到的解**已被枚举过（即更优解），**所以可知从小到大（即 $ 1 \sim L $） 枚举 $ A', B' $ 并判断是否满足 $ \frac{A'}{B'} \geq \frac{A}{B} $ 并更新最优解即可。**

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

double f = INT_MAX;
int a, b, l, res_a, res_b;

int main() {
	cin >> a >> b >> l;
	for (int i = 1; i <= l; i++) {
		for (int j = 1; j <= l; j++) {
			if (i * 1.0 / j >= a  * 1.0 / b && i * 1.0 / j - a * 1.0 / b < f) {
				f = i * 1.0 / j - a * 1.0 / b;
				res_a = i, res_b = j;
			}
		}
	}
	cout << res_a << " " << res_b;

	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P2118)

抢个题解求过啊！

---

由于上限 $L\le 100$，我们完全可以用双重循环直接枚举可能的 $A'$ 和 $B'$。

对于每个 $1\le i,j\le L$，如果 $\gcd(i,j)=1$ 也就是它们互质，并且 $\frac{A}{B}\le\frac{i}{j}<mn$，这里 $mn$ 指到目前为止的所有符合要求的 $\frac{i}{j}$ 的最小值，那么这个比例就是符合要求的，更新两个答案和 $mn=\frac{i}{j}$。最后输出两个答案。

```cpp
#include <iostream>
using namespace std;

int gcd(int x, int y)
{
    return (!y ? x : gcd(y, x % y));
}

int main()
{
    int a, b, l;
    cin >> a >> b >> l;
    double p = 1.0 * a / b, mn = 1e9;
    int ans1 = 0, ans2 = 0;
    for (int i = 1; i <= l; i++)
        for (int j = 1; j <= l; j++)
            if (gcd(i, j) == 1 && 1.0 * i / j >= p && 1.0 * i / j < mn)
                ans1 = i, ans2 = j, mn = 1.0 * i / j;
    cout << ans1 << " " << ans2;
    return 0;
}
```

---

## 作者：WsW_ (赞：4)

### 思路
观察到虽然 $A,B$ 较大，但 $L$ 较小。而化简后的结果 $A',B' \le L$，所以可以直接枚举 $A',B'$。  
对于判断 $A',B'$ 是否互质，等价于判断最大公因数是否为 $1$。可以直接使用函数 `__gcd()` 来求最大公因数。  
接着还要判断 $\dfrac{A'}{B'} \ge  \dfrac{A}{B}$，直接比即可，注意需要先转化成浮点类型再进行除法运算。  
最后判断 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 是否小于之前存储的答案。假设之前存储的答案为 $ANSK$，那么判断 $\dfrac{A'}{B'} - \dfrac{A}{B} < ANSK - \dfrac{A}{B}$ 等价于判断 $\dfrac{A'}{B'} < ANSK$。若成立，则覆盖存储的答案。  

时间复杂度为 $O(L^2 \log L)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool check(int x,int y){
	return __gcd(x,y)==1;
}
int main(){
	int a,b,l,ansa=-1,ansb=-1;
	scanf("%d%d%d",&a,&b,&l);
	double k=(double)a/b,ansk=-1;
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++){
			double k2=(double)i/j;
			if(!check(i,j)||k2<k)continue;
			if(ansa==-1||k2<ansk){
				ansa=i;ansb=j;ansk=k2;
			}
		}
	}
	printf("%d %d",ansa,ansb);
	return 0;
}
```

---

## 作者：Actinoi (赞：3)

**为获取最佳阅读效果，欢迎访问：**[Actinoi's blog:NOIP2014 普及组](https://www.actinoi.com/2019/08/19/noip2014%20普及组/)

考虑到 $L$ 最多只有 $100$ ，因此我们便可以枚举$A$’ 与 $B$’。

我们用 $i$ 枚举 $A$’， 用 $j$ 枚举 $B$’。

$∵$ $\frac{A’}{B’}\ ≥\ \frac{A}{B}$

$∴$ $\frac{i}{j}\ ≥\ \frac{A}{B}$

$∴$$b × i ≥ a × j$

然后，我们设置变量 $ansa$ 存储 $A$ ’ ， 用 $ansb$ 存储 $B$’ 。那么，我们在枚举$A$’ 与 $B$’ 时，如何保证 $ansa$ 与 $ansb$ 得到更新呢？

根据题目要求，$A$’$/B$’$ - A/B$的值尽可能小。因此，我们便可以得到在 $\frac{i}{j}\ -\ \frac{A}{B}\ <\ \frac{ansa}{ansb}\ -\ \frac{A}{B}$ 时，更新$ansa$ 与 $ansb$ 。

但是，$\frac{i}{j}\ -\ \frac{A}{B}\ <\ \frac{ansa}{ansb}\ -\ \frac{A}{B}$ 可以化简。

也就是：

![1313132.png](https://i.loli.net/2019/08/19/zo1fGnqkw93HFNs.png)
(数学公式洛谷无法渲染>_<，只能上传图片，请见谅！QwQ)

​​​​​&emsp;所以，当 $i$ , $j$ 满足 ```gcd(i, j) == 1 && b * i >= a * j && j * ansa > i * ansb``` 时，更新 $ansa$ 与 $ansb$ ，最后输出 $ansa$ 与 $ansb$ 就好啦!

```cpp
#include <iostream>
using namespace std;
int gcd(int x, int y) {
    return y == 0 ? x : gcd(y, x % y);
}
int main() {
    int a, b, l;
    cin >> a >> b >> l;
    int ansa = 0x3f3f3f, ansb = 1;
    for (int i = 1; i <= l; i++) {
        for (int j = 1; j <= l; j++) {
            if (gcd(i, j) == 1 && b * i >= a * j && j * ansa > i * ansb) {
                ansa = i;
                ansb = j;
            }
        }
    }
    cout << ansa << " " << ansb << endl;
    return 0;
}
```

---

## 作者：detect (赞：2)



```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cctype>
#include <string>
using namespace std;
int i,j,l,n,m,s,a,b,o,u;
int main()
{
   //freopen("lx.in","r",stdin);
   //freopen("lx.out","w",stdout);
   cin>>n>>m>>l;
   double nbm=n*0.1/m;  //得到n/m的实数值
   double x=100000;
   for(i=1;i<=l;i++)    //枚举i，表示A'
     for(j=1;j<=l;j++)  //枚举j，表示B'
     {
       a=i;
       b=j;
       while(a%b!=0)   //欧几里德求i和j的最大公约数
       {
          s=a%b;
          a=b;
          b=s;
       }
       if(b==1)
       {
            if(i*0.1/j>=nbm)       //注意精度
           if((i*0.1/j-nbm)<x)
           {
                 x=i*0.1/j-nbm;    //记录当前最小的 A'/B'-A/B 的差
                 o=i;              //记录当前的解：A'
                 u=j;              //记录当前的解：B'
           }
       }
    }
   cout<<o<<" "<<u<<endl;
   return 0;
}
```
解题：
穷举。


双重循环分别在[1,L]范围内的i和j，三个约束条件

（1）A'用循环变量 i 表示，B'用循环变量 j 表示，互质（最大公约数为1）

（2）A'/B'≥A/B (i/j>=s)

（3）A'/B'-A/B 的值尽可能小（打擂台）


然后这道题目细节问题比较多，注意比值结果应该用实数保存和比较。建议用double类型。


另外：float会不会在比较上出现精度问题？

理论证明单精度实型变量是不会出现精度问题的：题目中 A、B 的范围最多只有 6 位。

众所周知，所谓精度出问题时因为出现了循环节超出了实型变量本身的精度范围，才会出现问题的。有一个引理：循环小数转化为分数的话，分母就是由循环节的位数个9组成的，那么按照题目的数据范围，循环节最多有就只有5位，故单精度实型变量不会出现精度问题。


---

## 作者：蒟蒻whker (赞：1)

### 思路:
由于本题中 $L\le100$，所以可以暴力枚举 $100$ 内的所有整数，再接着判断这个分数的分母和分子是否互质，是否大于原来的分数，是否比之前的答案（分数减去原来分数的最小值）小，最后输出答案。 

详见代码。
### 代码：
```cpp
#include<iostream>
using namespace std;
int GCD(int xx,int yy)//计算两数的最大公约数（如果为1则互质）
{
	return xx%yy?GCD(yy,xx%yy):yy;//辗转相除法
}
int main()//本题中l<=100,所以直接枚举即可
{
	int a,b,l,max1,max2;
	cin>>a>>b>>l;
	max1=l,max2=1;
	for(int i=1;i<=l;i++){//从1枚举到上限l
		for(int j=1;j<=l;j++)
		{
			if(i*b>=a*j&&GCD(i,j)==1&&max1*j>max2*i)//如果A′/B′>=A/B 且两数互质 并且A′/B′>=A/B的值比原来更小，则记录答案
			{
				max1=i;max2=j;
			}
		}	
	}
	cout<<max1<<" "<<max2;//输出答案
	return 0;
}
```

The end.

本蒟蒻第一篇题解，管理员大大求过QWQ

---

## 作者：qhr2023 (赞：1)

## solution

注意到 $L$ 很小，考虑穷举化简后的分子和分母，按照题目要求，在分子分母互质且新分数不小于原分数的前提下，让新分数最小，同时记录答案。由于数据较小，直接用 double 类型即可。

[通过记录](https://hydro.ac/record/677281fa7eee4038caf0c3d6)

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
double a, b,mi=0x3f3f3f;
int l, ans1, ans2; 
int main(){
    cin >> a >> b >> l;
	for(int i=1; i<=l; i++)
		for(int j=1; j<=l; j++)
			if(__gcd(i, j)==1&&1.0*i/j>=a/b&&i*1.0/j-a/b<mi)
				mi=i*1.0/j-a/b,
				ans1=i, ans2=j;
	cout << ans1 << ' ' << ans2;
	return 0;
}
```

---

## 作者：TheTrash (赞：1)

### 思路

由于 $L$ 很小，所以可以枚举每个可能的分数，再判断这个分数的分子和分母是否互质，是否大于原来的分数，是否比之前分数减去原来分数的最小值小，最后输出最合适的分子和分母。

### 代码

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long double ld;//其实不用开long double，double甚至float就够了
int a,b,l,x,y;
ld mi=0x3f3f3f3f,s;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>a>>b>>l;
	s=(ld)a/(ld)b;
	for(int i=1;i<=l;i++)
		for(int j=1;j<=l;j++)//枚举
			if(__gcd(i,j)==1)//分数要最简
				if((ld)i/(ld)j>=s)//先判断i/j是否大于a/b比较方便
					if((ld)i/(ld)j-s<mi) mi=(ld)i/(ld)j-s,x=i,y=j;
	cout<<x<<' '<<y;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
这题数据范围并不会很大，所以我们就可以用枚举的方法来求出化简后的比例。

先两层循环至上限。再用最大公约数，判断分子分母的最大公约数是否为一，并且 现分子 $\times B \le$ 现分母 $\times A$。这样，就可以更新出最优解了。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b, l, x = 0, y = 0;

int main () {
	scanf("%d%d%d", &a, &b, &l);
	for (int i = 1; i <= l; i++) {
		for (int j = 1; j <= l; j++) {
			if (__gcd(i, j) == 1 && i * b >= j * a && i * y <= j * x) {
				x = i;
				y = j;
			}
		}
	}
	cout << x << ' ' << y << endl;
	return 0;
}	
```

---

## 作者：hwc2011 (赞：1)

直接枚举分子和分母即可，注意分母不为 $0$，但分子可以为 $0$，时间复杂度 $O(L^2)$。  
由于从 $i$ 和 $j$ 是从小到大做的，所以肯定会先记录 $i$ 和 $j$ 的最大公因数是 $1$ 的情况，所以不需要判断 $i$ 和 $j$ 的最大公因数是否是 $1$。
```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,l,maxx=10000000,ans1,ans2;
int main(){
	cin>>a>>b>>l;
	for(double i=0;i<=l;i++){
		for(double j=1;j<=l;j++){
			if(i/j>=a/b&&i/j<maxx){
				maxx=i/j;
				ans1=i;
				ans2=j;
			}
		}
	}
	cout<<ans1<<' '<<ans2;
}
```

---

## 作者：Amoribus (赞：1)

实际上，由于 $L\leq 100$，分子分母都 $\leq L$，我们可以直接对于分数 $\dfrac{i}{j}$ 进行枚举，如果这是一个合法的分数，且小于目前的最小值，我们就记录答案，最后输出即可。

合法的分数当且仅当：

- $\dfrac{i}{j}\geq \dfrac{a}{b}$
- $\gcd(i,j)=1$

如果我们从小往大枚举，如果 $i,j$ 不互质，那么必然已经有另一对使 $\dfrac{i'}{j'}=\dfrac{i}{j}$ 的互质整数 $i',j'$  已经被枚举过了。显然的，不互质的整数 $i,j$ 一定**不优于**已经找到的答案，因此我们不用判断互质，直接记录小于目前最小值的答案即可。

时间复杂度 $O(n^2)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,l;
int main()
{
	cin>>a>>b>>l;
	int ansa,ansb;
	double minans=1e9;
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++){
			if(i*1.0/j>=a*1.0/b&&i*1.0/j-a*1.0/b<minans){
				ansa=i,ansb=j;
				minans=i*1.0/j-a*1.0/b;
			}
		}
	}
	cout<<ansa<<" "<<ansb<<endl;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

## P2118 \[NOIP2014 普及组] 比例简化

- 首先将式子简化：
  $$\frac{A'}{B'}≥\frac{A}{B}→B \times \frac{A'}{B'}≥B \times \frac{A}{B}→B \times \frac{A'}{B'}≥A→B'\times B \frac{A'}{B'}≥A→B \times A'≥A$$
- 由于 $L≤100$，因此可以枚举。
- `if(aa*b>=bb*a&&aa*ansb<bb*ansa)` 则说明找到了符合条件的化简后的分数：$\frac{aa}{bb}$，更新答案。此处的 $aa$ 和 $bb$ 就是 $A'$ 和 $B'$。
- 当 $\gcd (i,j)=1$ 时说明 $i,j$ 互质，即最大公因数为 $1$，可以为最简分数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,l;
	cin>>a>>b>>l;
	int ansa=l,ansb=1;
	for(int aa=1;aa<=l;aa++)
	{
		for(int bb=1;bb<=l;bb++)
		{
			if(__gcd(aa,bb)==1)//互质才是最简分数
			{
				if(aa*b>=bb*a&&aa*ansb<bb*ansa) ansa=aa,ansb=bb;
			} 
		}
	}
	cout<<ansa<<" "<<ansb;
	return 0;
}
```

---

## 作者：yuxinrui0618 (赞：0)

# 题解：P2118 [NOIP2014 普及组] 比例简化
## 1. 题目大意
将 $A$ 比 $B$ 化简为 $A'$ 比 $B'$，使其满足以下几点：
- $A'$ 和 $B'$ 均不大于 $L$；
- $A'$ 和 $B'$ 互质；
- $\dfrac{A'}{B'} \ge  \dfrac{A}{B}$。
  
最后在满足要求的比中，找出 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 最小的。

## 2. 思路
- 用 $i$ 和 $j$ 分别枚举 $A'$ 和 $B'$，根据十字相乘法：  
  $∵\dfrac{i}{j} \ge  \dfrac{A}{B}$  
  $∴ b \times i ≥ a \times j$；
- 用 $s1$ 和 $s2$ 记录目前符合要求的且 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 最小的数，在符合要求且 $\dfrac{i}{j} - \dfrac{A}{B} < \dfrac{s1}{s2} - \dfrac{A}{B}$ 时更新 $s1$ 和 $s2$ 的值，化简这个式子，得：  $\dfrac{i}{j} < \dfrac{s1}{s2} $
，根据十字相乘法，即为 $s2 \times i > s1 \times j$；
- 所以，当 `__gcd(i,j)==1 && a*j<=b*i && i*s2<j*s1` 时，即为目前的结果。

## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a,b,l;
	cin>>a>>b>>l;
	int s1=l,s2=0;
	for (int i=1;i<=l;i++) //枚举A'
		for (int j=1;j<=l;j++) //枚举B'
			if (__gcd(i,j)==1 && a*j<=b*i && i*s2<j*s1) //目前结果
			{
				s1=i;
				s2=j;
			}
	cout<<s1<<" "<<s2;
    return 0;
}
```
## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：long_long__int (赞：0)

# 题目解法

暴力枚举分数 $\frac{i}{j}$，如果 $i\div j\ge A\div B$，且这两个分数的差**小于**目前差的最小值，那么记录答案。

不用判断 $i$ 和 $j$ 互质的原因：如果分数 $\frac{i}{j}$ 可以约分为 $\frac{k}{l}$，那么一定有 $k\le i$ 与 $l\le j$，即分数 $\frac{k}{l}$ 已经枚举过了，此时的分数 $\frac{i}{j}$ 的答案一定不会优于分数 $\frac{k}{l}$ 的答案，而上文中加粗的是小于，不是小于等于，所以 $\frac{i}{j}$ 的答案是不会对最后的答案造成影响的。

代码：
```cpp
#include<bits/stdc++.h>
#define int double
using namespace std;
int a,b,l;
int minn=1000001;
int ans1,ans2;
signed main(){
	cin>>a>>b>>l;
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++){
			if(i/j>=a/b and i*1.0/j-a/b<minn){
				minn=i*1.0/j-a/b;
				ans1=i,ans2=j;
			}
		}
	}
	cout<<ans1<<" "<<ans2;
	return 0;
} 

```

---

## 作者：Ak_hjc_using (赞：0)

题解：[P2118 [NOIP2014 普及组] 比例简化](https://www.luogu.com.cn/problem/P2118)
### 思路 ：
看上去这里的 $A$ 与 $B$ 都非常大，但是实际上我们并不需要枚举 $A$ 与 $B$，因为这里的 $L \le 100$，由于答案要求我们在 $L$ 范围之内，所以我们直接枚举 $L$ 即可。

答案要我们算出与 $A$ 比 $B$ 最接近的比例，所以我们直接双重枚举来枚举这个答案，再算出最小值就可以了。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

#define int long long
const int N = 1e5 + 5;
int x, y, l;

int gcd (int a, int b)
{
	return b ? gcd(b, a % b) : a;
} // 答案需要互质

signed main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> x >> y >> l;
	int num1, num2;
	double minn = INT_MAX;
	for (int i = 0; i <= l; i++)
	{
		for (int j = 0; j <= l; j++)
		{
			if (gcd(i, j) == 1)
			{
				if (i * y >= j * x)
				{
					if (i * 1.0 / j <= minn)
					{
						num1 = i;
						num2 = j;
						minn = i * 1.0 / j;
					}
				}
			}
		}
	}
	cout << num1 << ' ' << num2 << endl;
	return 0;
}

```

---

## 作者：Genius_Star (赞：0)

### 思路：

注意到 $L \le 100$。

考虑暴力枚举所有的 $\frac{i}{j}$，先化为最简分数后为 $\frac{x}{y}$。

首先要满足 $\frac{x}{y} \ge \frac{a}{b}$，即 $xb \ge ay$。

然后还要使得离 $\frac{a}{b}$ 更近，即满足上述条件的最小的那个分数；交叉相乘比较即可。

时间复杂度为 $O(L^2)$。

**当然其实没必要化简为最简的，因为最简的肯定会先枚举到。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int a, b, l, t, ansx, ansy;
int main(){
	a = read(), b = read(), l = read();
	for(int i = 1; i <= l; ++i){
		for(int j = 1; j <= l; ++j){
			int x = i, y = j;
			if(x * b < a * y)
			  continue;
			if(!ansx){
				ansx = x, ansy = y;
				continue;
			}
			if(x * ansy < ansx * y)
			  ansx = x, ansy = y;
		}
	}
	write(ansx);
	putchar(' ');
	write(ansy);
	return 0;
}
```

---


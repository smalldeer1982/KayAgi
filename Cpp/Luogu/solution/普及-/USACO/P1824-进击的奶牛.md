# 进击的奶牛

## 题目描述

Farmer John 建造了一个有 $N$（$2 \leq N \leq 10 ^ 5$) 个隔间的牛棚，这些隔间分布在一条直线上，坐标是 $x _ 1, x _ 2, \cdots, x _ N$（$0 \leq x _ i \leq 10 ^ 9$）。

他的 $C$（$2 \leq C \leq N$）头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John 想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？

## 样例 #1

### 输入

```
5 3
1
2
8
4
9```

### 输出

```
3```

# 题解

## 作者：StyWang (赞：276)

## 概述
本文主要分析二分答案过程中，对于上下界的理解和实现。

我写二分答案时，上下界没有写好导致Wrong Answer。又看到讨论区有人的上下界写错了，于是TLE。所以决定仔细分析一下二分的上下界问题。

众所周知，二分答案时，需要有上界、下界、中点。分别命名为left,right,mid。

此题中，要求最大值，因此有重要结论：若mid为解，则最优解一定属于```[mid, right]```。若mid不为解，则最优解一定属于```[right, mid)```。对这部分不清楚的可以阅读[这里](https://www.luogu.org/blog/user20197/solution-p2678)，一篇很清晰地讲述二分答案的题解。

### 第一种理解
闭区间```[left, right]```为最优解存在的区间。

令```mid = (left + right) / 2```。

- 若mid为解（无论是否最优），则使```left = mid```.
此时不使```left = mid + 1```是因为mid可能是最优解，而最优解必须属于上述闭区间.

- 若mid不为解，则使```right = mid - 1```.

重复上述过程，直到闭区间只有一个值时跳出循环，即```left == right```。

但是，当```left == right - 1```时，```mid = (left + right)/2 = left```，则此次循环最后会使```left = mid```，程序陷入死循环。

出现死循环的问题，直接原因是整除的误差(```3div2```结果为1)，而根本原因是区间范围卡的过死。只有当left严格等于right时，我们才能宣布找出了最优解，又加之整除误差，因此在区间范围很小时，程序难以继续二分。

因此，我们需要把区间范围卡的“宽松”一点。
### 第二种理解
区间```[left, right)```为最优解存在的区间。

令```mid = (left + right) / 2```

- 若mid为解，则使```left = mid```.

- 若mid不为解，则使```right = mid```.

重复以上过程，直到```right == left + 1```跳出循环，left即为最优解。

这种区间的定义中，right为开区间，相比于闭区间较为“宽松”，有效避免了死循环的问题，代码可以AC。

但是，这两种理解方式区别很小，容易混淆，不建议使用，因此有了第三种更清晰的理解方法。

### 第三种理解

定义变量ans，储存**当前**优解。定义闭区间```[left, right]```，代表程序当前正在此闭区间内寻找答案（寻找潜在的比ans更优的解）（与前两种方法不同的是，最优解不一定要属于该闭区间）。

令```mid = (left + right)/2```

- 若mid为解，则```ans = max(ans, mid), left = mid + 1```.此时我们更新了最优解，同时在最优解的右侧寻找潜在的更有解。

- 若mid不为解，则```right = mid - 1```.mid不是解，因此我们在mid左边寻找更优解。

重复上述过程，直到```left > right```时跳出循环，ans即为最优解。

注意，当```left == right```时，也必须要在此区间内进行判断，因为当前还不能确定该区间内是否存在更优解。

代码：
```cpp
//二分答案 
while(left <= right)
{
    int mid = (left + right) / 2;
    if(judge(mid))
    {
        left = mid + 1;
        ans = max(ans, mid);
    }
    else
        right = mid - 1;
}
printf("%d", ans);
```

---

## 作者：Accele_Rator (赞：237)

楼下的大佬代码太高深莫测且注释少，我根本看不懂（~~好吧其实是我太蒟蒻了~~）

我根据自己的理解，写了一个好理解一点的版本，注释详尽，像我一样的蒟蒻应该也能看懂

二分答案很好想，主要难点是判定答案是否可行，即代码中的“check”函数

代码奉上：


```cpp
#include<iostream>
#include<cstdio> 
#include<cstring>
#include<algorithm>
using namespace std;
int A[1000010];
int n,c,a;
bool check(int x)//判断此答案是否可行 
{
    int num=0;
    int l=A[1];//l记录上一只牛的位置，开始时第一只牛一定在第一个牛栏 
    for(int i=2;i<=n;i++)//依次枚举每个牛栏 
    {
        if(A[i]-l<x) num++;//若此距离不满足当前答案，那么需要的牛栏数+1，即把当前牛放到下一个牛栏 
        else l=A[i];//否则就更新上一次的牛栏位置 ，即上一头牛放的位置 
        if(num>a) return false;// 若需要牛栏数大于最大牛栏数，此答案不可行 
    }
    return true;//反之，若需要牛栏数小于最大需要牛栏数，此答案可行
}
int main()
{ 
  scanf("%d%d",&n,&c);
  for(int i=1;i<=n;i++)
    scanf("%d",&A[i]);
  sort(A+1,A+n+1);//由于无序，需排序（sort默认从小到大，不用写规则） 
  a=n-c;//最大剩余牛栏数 
  int l=1;//二分的左界，从1开始，即可能情况的最小值 
  int r=A[n]-A[1];//二分右界，即可能情况的最大值 
  while(l+1<r)//若左<右，则继续二分答案 
  {
      int mid=(l+r)/2;//二分 两区间分别为l ~ mid    ，     mid ~ r;
      if(check(mid)) l=mid;//若此答案可行，从mid ~ r区间继续查找（更大答案），即修改左界l=mid 
      else r=mid;//反之，若此答案不可行，从l ~ mid区间查找（合理答案），即修改左界l=mid 
  }
  if(check(r)) printf("%d",r);//若可行解为右界，输出右界 
  else printf("%d",l);//若可行解为左界，输出左界 
  return 0;
}
```

---

## 作者：_Blue_ (赞：130)

非常经典的一道**二分答案**模板题  
什么是**二分答案**？简单地说，就是和二分查找相似，二分每个答案，然后对这个答案进行求证，看是否满足条件，然后再次进行左右区间查找，知道二分到单个点上  
~~因为我太弱了，可能说的话有些逻辑错误或者表达不清qwq~~  
这一题，我们二分答案找每个**牛棚之间的最大距离**。  
先上代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int ans=-1;
int a[1000005];
bool check(int x){   //答案是否满足，满足返回1，反之返回0
    int now = 1, num = 1;
    for (int i = 2; i <= n; i++){
        if (a[i]-a[now]>=x){
            now=i;
            num++;
        }
    }
    return num>=m;
}
void merge(int l,int r){
	if(r-l<0) return;    //边界
	int mid=l+(r-l>>1);    //这样处理防止溢出
	if(check(mid)){   //如果满足，我们记录当前最大值，然后往左区间寻找答案
		merge(mid+1,r);
		ans=max(ans,mid);
	}
	else{  //如果不满足，就往右区间寻找
		merge(l,mid-1);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);  //注意，要排序处理。
	merge(1,(2<<30));
	printf("%d",ans);
}
```
二分答案的merge()都差不多，主要是check()  
### 这里细讲本题check：
我们假设最大距离是x，将题目意思转变一下，就变成了这样：  
>在n个数中选取m个数，它们两两之间的距离大于等于x。  

因为我们的数列是满足单调性质的，所以我们可以从第一个数往后找，看看有几个数满足**a[i]-a[i-1]<=x;**  
如果数量大于m，则满足条件，反之亦然.  
```cpp
bool check(int x){   
    int now = 1, num = 1;
    for (int i = 2; i <= n; i++){
        if (a[i]-a[now]>=x){
            now=i;
            num++;
        }
    }
    return num>=m;
}
```

### 几个要强调的：  
- 我是蒟蒻，欢迎大家指出错误和不足  
- 二分的过程我就不讲了，和二分答案是差不多的  
- 身体原因要离开OI一段时间，希望大家能点赞支持
- **2019 CSP rp++！**

---

## 作者：「已注销」 (赞：54)

`排序`$\red+$`二分`

先将坐标排序$,$然后二分答案$,$用贪心$($从左到右能选则选$)$验证
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int inf=0x7fffffff;
int n,m,a[100001];
int solve(){
    int l=0,r=inf,mid,now,tot;
    while(l<r){
        mid=(l+r+1)>>1;
        now=a[1];
        tot=1;
        for(int i=2;i<=n;++i){
            if(a[i]-now>=mid)now=a[i],++tot;
            if(tot>=m)break;
        }
        if(tot<m)r=mid-1;
        else l=mid;
    }
    return l;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    printf("%d",solve());
}
```

---

## 作者：Lyrics (赞：35)

#首先

二分答案这是非常清楚的一个做题思路。

一般看到所谓的**最大值最小化**或者**最小值最大化**一般都是用二分答案进行运算

可能一般你会感觉好像复杂度很大的样子，像这题我刚开始也是以为10^10??复杂度完全不能过

但是二分答案实际上是对你可能求出的值域进行二分，然后得到最优的解法

二分答案的模板很好写，但是最难写的还是所谓的**检验函数**，一般二分答案就是考察这个！

#检验函数才是重点！

下面是我的CODE（包含注释）:


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],ans=0,minn=85489665;
bool cmp(int AA,int BB){return AA<BB;}//我们要防止数据无良给了个乱序的，毕竟题目没说就一切皆有可能 
bool check(int x){//二分答案中最考验的就是检验，其他的基本就是背模板 
    int sumer=0,base=a[1];//我们记录可以取多少个满足距离不小于x的数目为sumer，记最后取到的数为base
    //显然我们肯定是要从第一个开始取（第一个是最小的，自然取起来肯定是最好的取法） 
    for(int i=2;i<=n;i++){//我们开始找 
        if(a[i]-base>=x){//找到了就把sumer计数，并且我们现在把base转移，因为我们现在取的是a[i]了，上一个base离开了 
            sumer++;
            base=a[i];
        }
        if(sumer>=m)return true;
    }
    if(sumer+1<m)return false;//重点是这一步，一般有没有加一对于你的程序运行结果至关重要
    //毕竟我第一次交是0分就是因为这里没好QAQ 
    return true;
}
void half(){//二分模板可以背 
    int l=minn,r=a[n]-a[1];
    while(l<=r){//肯定要防止死循环的。 
        int mid=(l+r)>>1;
        if(check(mid))l=mid+1;//嫌弃我们选择的距离太小 
        else r=mid-1;//嫌弃我们选择的距离太大 
    }
    ans=r;
    return;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)    scanf("%d",&a[i]);//读入操作 
    sort(a+1,a+n+1,cmp);//排序操作 
    for(int i=2;i<=n;i++)    minn=min(a[i]-a[i-1],minn);//找到一个最大的范围 
    half();//二分 
    printf("%d\n",ans);//输出答案 
    return 0;
}
//希望对您有所帮助！！
```

---

## 作者：duhailong (赞：34)

    类似的最大值最小化或者最小值最大化问题，通常用二分法就可以很好地解决。我们定义：
    设 C(d)表示可以安排瓶盖的位置使得最近的两个瓶盖的距离不小于 d
    那么问题就变成了求满足 C(d)的最大的 d，另外，最近的间距不小于 d 也可以说成是所有瓶盖的间距都不小于 d，因此就有 C(d)表示可以安排瓶盖的位置使得任意的两个瓶盖的距离不小于 d。
    这个问题的判断使用贪心法便可非常容易地求解。
        1.对瓶盖的位置 x 进行排序
        2.把第一个瓶盖放入 x0 的位置
        3.如果第 i 个瓶盖放入了 xj 的话，第 i+1 个瓶盖就要放入满足 xj+d≤xk 的最小的 xk 中
    对 x 的排序只需在最开始时进行一次就可以了，每一次判断对每个瓶盖最多进行一次处理，因此时间复杂度是 O(nlogn)
    代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,l,r,mid;
int A[1000001];
inline bool check(int x)
{
	int rgt=A[1]+x;
	int sum=1;
	for(int i=2;i<=a;i++)
	{
		if(A[i]>=rgt)
		{
			sum++;
			rgt=A[i]+x;
		}
	}
	return sum>=b;
}
int main()
{
	cin>>a>>b;
	for(int i=1;i<=a;i++)
	   cin>>A[i];
	std::sort(A+1,A+1+a);
	l=0,r=A[a]-A[1];
	while(l<=r)
	{
		mid=(l+r)/2;
		if(check(mid))l=mid+1;
		else r=mid-1;
	}
	cout<<r<<endl;
	return 0;
}
```

---

## 作者：DEVILK (赞：25)

更好的阅读体验点这里：[博客传送门](http://www.cnblogs.com/devilk-sjj/p/9037063.html)

###  【算法分析：】

**关于单调性的感性证明：**

　　如果一个$mid$作为最大值时所选的瓶盖数量$ x≥B$，即最大值过小导致选取瓶盖过多，

　　则答案一定在$[mid + 1, r]$内

　　否则答案在$[l, mid]$内

满足单调性，可以二分答案。

**关于$check$函数：**

在$check$一个数$mid$时，$check$函数返回$mid$作为最大值时的选取瓶盖数量，

　　这里可以做一个优化，即c$heck$返回一个$bool$类型

　　当选取的瓶盖数量超过读入的$B$时，直接返回1，表示二分$[mid + 1, r]$这个区间

将数据从小到大排序来实现$check$函数：

　　读入有$n$个元素的序列$a$，最大值为$max$

　　利用贪心的思想，由于是求最少选取的瓶盖数量，能不选这个瓶盖的时候就不选

　　$last$表示上一次选取的瓶盖位置

　　当且仅当 $a_i - last > max $时，不选取$a_i$会导致最大值变大，$last$更新成$a_i$，选取的瓶盖个数$+ 1$

**关于上下界的初始化：**

　　二分时上下界的初始选择可以是$[0,\ INF]$，最多进行31次查找。

　　只选取两个瓶盖时的最大值为$a_{max} - a_{min}$ ，由于数据已经排好序，上界直接初始化成 $a_n - a_1$ 即可
 
然后就是二分的板子啦！



------------


### Ac代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN = 100000 + 1;
const int INF = 0x7fffffff;

int n, m;
int a[MAXN];

bool check(int num) {
	int ret = 1, last = a[1];
	for(int i = 2; i <= n; i++) {
		if(a[i] - last > num) last = a[i], ret++;
        //小优化：当数量超过m时直接return
		if(ret >= m) return true;
	}
	return ret >= m;
}
int main() {
	scanf("%d%d", &n, &m);
	int l = 0, r = INF;
	for(int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	sort(a + 1, a + n + 1);
    //小优化：缩小上界的范围
	r = a[n] - a[1];
	while(l < r) {
		int mid = (l + r) >> 1;
		if(check(mid)) l = mid + 1;
		else r = mid;
	}
	printf("%d\n", l);
}
```

---

## 作者：北凌scoffs (赞：14)

```c
#include<bits/stdc++.h>
using namespace std;
int n,b;
int a[1005*1005];
inline bool check(int x) {
	//x是下面二分出来的距离
	int len=a[1]+x;//这是check函数
	//这里的len是根据x(两点之间的距离嘛，注意是最小距离)
	//所以这里a[1]+x就相当于在预处理,具体作用看下面
	int cnt=1;//计数，拿出瓶盖
	for(int i=2; i<=n; i++) {
		if(a[i]>=len) {
			//因为x是最小距离的最大值(此处假设，毕竟还没有二分完)
			//那么那个啥最小值的最大值甭管，只需要知道它是最小值就可以了
			//那么竟然是距离最小值，所以a[i-1]+x(及len)应该<=a[i]
			cnt++;//满足条件就cnt++
			len=a[i]+x;//刷新
		}
	}
	if(cnt>=b)//看满足条件没有
		//注意，最开始我以为是cnt==b
		//但是错了，仔细想了想，题目要求只需要拿出b个瓶盖，但是如果我有
		//大于b个瓶盖可以拿出来满足条件，那是没有影响的啊，多的不拿就是了
		return 1;
	return 0;
}
int main() {
	ios::sync_with_stdio(false);
	cin>>n>>b;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	sort(a+1,a+1+n);//二分的条件是，单调哟,这里要单调递增 
	int l=0,r=a[n]-a[1];//二分范围，最大距离肯定是第一个和最后一个之间的距离
	//单调递增嘛
	while(l<r) {
		int mid=(l+r+1)>>1;
		//本来写的mid=(l+r)>>1
		//于是只有40分,其他的都是TLE
		//我们来思考一下，二分TLE不正常啊？
		//很明显出现了死循环
		//比如l=2,r=3;那么mid=5>>1==2;
		//如果是check返回1的话，那么l和r将永远卡在2和3
		//所以我们取得mid要靠右，就是(l+r+1)/2;
		if(check(mid))
			l=mid;//这是一个最小值得最大化问题
			//做个形象的假设，最小值的最大化就比喻为一群男生去追校花 
			//求不能获得校花芳心的弱鸡男里面的最强男
			//此处的校花很花心，只要满足她对于男生能力要求，就可以将这个男生纳入后宫 
			//那么check为ture就说明这位兄弟不能获得校花芳心
			//那比他更弱鸡的一定不行，于是只能l~r的一群男生里继续找
			//记住l==mid哟，因为此时的这个弱鸡男也是一组解，只是不一定是最优解 
		else {
			r=mid-1;
			//check为false的话，就说明，这个男生可以获得校花芳心
			//那么比他强的男生，也一定可以获得校花芳心，成为校花的后宫
			// 所以只能去l~(mid-1)去寻找
			//很形象吧 
		}
	}
	cout<<l;//结束条件是l==r，所以输出r也是一样的，问题不大，因为没有ans记录答案 
	return 0;
}
```


---

## 作者：以墨 (赞：14)

本题的**二分**很好想到

\_上下界确定\_

l=0,r=最大的距离-最小的距离+1

当然，如果r不取这么准，同样没关系，这样是为了缩短一点时间

-----------------------------------------------------------------------------------------------------------------------------------------------------------

\_单调性明显\_

显然，当距离越短时，能选的瓶盖就越多；距离越大，能选的瓶盖就越少

则当距离（用x来表示）<=某一个值时（即ans），F(x)（F是判断该距离能否选到m个瓶盖）恒等于true;

当x>ans时，F(x)恒等于false;

则本题即是在最小值中求最大值

最小值中求最大值模板

```cpp
while(l<r)
{
    mid=(l+r+1)/2;//注意！！！mid（中点）的值此时必须上取整
    if(ALICE(mid)==true)//可爱的函数名
        l=mid;
    else
        r=mid-1;//注意！！！这里是原因。mid上取整之后，mid若是实数，则r取的是mid的下取整；mid若是整数......**前后呼应**
}
```
-----------------------------------------------------------------------------------------------------------------------------------------------------------
**华丽丽的代码**




```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[100002];
bool ALICE(int x)
{
    int i,j,cnt;
    for(i=1,cnt=0;i<=n;)
    {
        for(j=i;j<=n&&a[j+1]-a[i]<x;j++);//每次从前往后找离第i个瓶盖距离超过x的第一个瓶盖
        i=j+1;
        cnt++;//记录当前距离可用瓶盖数量
    }
    return cnt>=m;//注意！！！若能取多于m个瓶盖，则应调整下界，使距离变大；少于m,使距离变小；正好m个,为了距离更大,调整下界
}
int main()
{
    int i,l,r,mid;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+1+n);
    for(l=0,r=a[n]-a[1]+1;l<r;)
    {
        mid=(l+r+1)/2;
        if(ALICE(mid)==true)
            l=mid;
        else
            r=mid-1;
    }
    printf("%d\n",l);
    return 0;
}

```

---

## 作者：little_gift (赞：9)

## 于是这就是亲爱的二分答案 ##

所谓二分答案,就是二分答案区间(这不废话吗),然后判断每个答案是否可取,根据可取情况进行二分.对于这种最小值最大特别有用.




```cpp
#include <cstdio>
#include <algorithm> //需要sort
using namespace std;
int n, m, a[100001];
bool f(int x); //这里真的只是不想取名了
int main()
{
    while (scanf("%d%d", &n, &m) != EOF) //嗯,习惯了,不要在意
    {
        for (int i = 1; i <= n; ++i)
            scanf("%d", &a[i]);
        sort(a + 1, a + n + 1); //排序,从样例就可以看出来不是有序的
        int l = 0, r = 1000000; //不用管初始值,能AC就是了
        while (l + 1 < r) //二分
        {
            int mid = l + r >> 1; //二分区间
            if (f(mid)) l = mid; //判断可取
            else r = mid;
        }
        printf("%d\n", l); //l就是答案
    }
}
bool f(int x)
{
    int x1 = a[1], cnt = 1; //首先第一个隔间肯定是要放牛的.
    for (int i = 2; i <= n; ++i) //循环接下来每一个隔间
        if (a[i] - x1 >= x) //如果能放下
        {
            ++cnt; //又放进了一头牛
            x1 = a[i]; //更新上一头牛的位置
            if (cnt == m) return 1; //循环里return,稍微快一点吧
        }
    return 0; //无法实现
}
```

---

## 作者：浅色调 (赞：9)

###二分答案+二分搜索###

**思路：**二分答案额就不用说了。关键是如何去判断check，楼下题解大多是直接模拟，我这里采用的是check时也进行二分搜索，对于二分出的值x，我们返回数组中第一个大于等于ki+x的值，每一次都用tot记录一下，最后判断tot是否不小于b就ok了。(当然先要对k数组排序啦～～)

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,k[100005],l,r,mid,ans;
inline bool check(int x)
{
    int tot=0,num=0,i=0;
    while(i<a)
    {
        tot++;
        i=lower_bound(k,k+a,k[i]+x)-k;
    }
    return tot>=b;
}
int main()
{
    scanf("%d%d",&a,&b);
    for(int i=0;i<a;i++)scanf("%d",&k[i]);
    sort(k,k+a);
    r=k[a-1];
    while(l<=r)
    {
        mid=l+r>>1;
        if(check(mid))ans=l,l=mid+1;
        else r=mid-1;
    }
    cout<<r;
    return 0;
}
```

---

## 作者：伟大的王夫子 (赞：6)

[我的博客](https://www.luogu.org/blog/I-AK-IOI/)里面有很多好看的东西

这不是二分答案的模板题吗？先将序列a排个序，判定时依次考虑即可。时间复杂度为O（nlog1e9）

接着上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010], n, m;
//valid(x)为差值为x是否可行
bool valid(int x) {
	int cnt = 0, last = -(1 << 30); //-INF，保证第一个被选进去
	for (register int i = 1; i <= n; ++i)
		if (a[i] - last >= x) ++cnt, last = a[i];
	//由于我们排好了序，所以比较两个决策a[i]和a[i+1],a[i+1]更容易满足条件
	return cnt >= m;
}
int main() {
	cin >> n >> m;
	for (register int i = 1; i <= n; ++i) scanf("%d", a + i);
	sort(a + 1, a + n + 1);//快速排序，方便判定
	int l = 0, r = 1e9;
	//始终在区间l-r进行二分
	//单调性：对于可行的决策mid，比mid小的决策依然可行 
	while (l < r) {
		int mid = (l + r + 1) >> 1;
		if (valid(mid)) l = mid;//如果mid可行，区间缩小为mid-r范围内
		else r = mid - 1;//否则，向更容易成功的地方寻找答案
	}
	cout << l;
	//O(nlog1e9)
}
```
~~欢迎大家借鉴一下~~

---

## 作者：ShineEternal (赞：6)

# 灌水区
此题不能说是太水 ~~蒟蒻好像强行灌水了~~

------------
# 算法区
类似的最大值最小化和最小值最大化问题，通常用二分就可以很好的解决，题目标签也说明了。

1、设C（d）表示可以安排牛的位置，并使得两头牛的距离不小于d。

2、那么问题就转换为求满足c（d）的最大的d，另外，最近的间距不小于d也可以看成是所以牛的间距都不小于d，因此就可以用c（d）表示可以安排牛的位置，并使得任意两头牛的距离不小于d。

3、对于这个问题的判断，使用贪心发便可非常容易地求解。

NO.1：对牛舍的位置x进行排序

NO.2：把第一头牛放入x0的牛舍

NO.3: 如果第i头牛放入了xj间牛舍，则第i+1头牛就要放入满足xj+d<=xk的最小的牛舍xk中。对x的排序只需在最开始时进行一次就可以了，每一次判断对每头牛最多进行的一次处理，因此算法的时间复杂度是O(nlogn)


------------
# 代码区
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+3;//好习惯，定义常量
int n,m,x[N];
inline bool check(int d)//inline的功能是把这个子函数放入主函数，能加快程序速度，以下代码部分就不再注释，以防注释过多影响代码的可读性
{
	int cow=1;
	int rgt=x[1]+d;
	for(int i=2;i<=n;i++)
	{
		if(x[i]<rgt)continue;
		cow++;
		rgt=x[i]+d;
	}
	return cow>=m;
} 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x[i]);
	}
	sort(x+1,x+n+1);
	int l=0,r=x[n]-x[1];
	while(l<=r)
	{
		int mid=l+r>>1;
		if(check(mid))l=mid+1;
			else
			r=mid-1;
	}
	printf("%d",r);
	return 0; 
} 
```
## by 一本通
------------

# 祈祷区
求过，求赞


---

## 作者：zhutier (赞：3)

## 记录写这题的心路历程，希望对你有帮助
### 0.最初想法
就是个普普通通的二分嘛。要考虑左右端点么？不用！开搞开搞

跟[P2678 跳石头](https://www.luogu.org/problem/P2678)应该很像
### 1.陷入沉思
二分得到一个最大距离$ans$，从第二个瓶盖for到最后一个瓶盖。每当$d[i]-d[i-1]<ans$时，按照贪心思想$i++$（即去掉当前瓶盖）。因为已遍历过的瓶盖间距都已满足条件，再去掉已遍历过的是多此一举。但去掉前面的未知瓶盖可能有**一箭双雕**的效果。

开始思考如何写二分：

举例几种情况：
```cpp
5 2
1 3 5 7 9
```
二分答案到$6$时，序列为$1$ $7$,满足了$b=2$,但是可以更优。于是我们期待$l=mid$

于是想到了这个二分模板：

```cpp
while(l<r){
		int mid=(l+r+1)>>1;
		if(jud(mid)) l=mid;
		else r=mid-1;
	}
```
另一种情况：
```cpp
5 3
1 2 3 4 5
```
当$ans=1$时，序列为$1$ $2$ $3$ $4$ $5$,剩下的数字$cnt=5>b=3$, 因此我们期望最终$ans>1$,即期待$l=mid$.
于是在judge函数结尾：
```cpp
if(cnt>=b) return true;
	return false;
```
### 2.差不多完工啦，献上完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=100005;
int z[N],a,b,l=1,r;
bool jud(int x){
	int now=z[1],cnt=0;
	for(int i=2;i<=a;i++){
		while(z[i]-now<x&&i<=a){
			cnt++;
			i++;
		}
		now=z[i];
	}
	cnt=a-cnt;
	if(cnt>=b) return true;
	return false;
}
int main(){
	scanf("%d%d",&a,&b);
	for(int i=1;i<=a;i++) scanf("%d",&z[i]);
	sort(z+1,z+a+1);
	r=z[a]-z[1];
	while(l<r){
		int mid=(l+r+1)>>1;
		if(jud(mid)) l=mid;
		else r=mid-1;
	}
	printf("%d",l);
	return 0;
}
```

---

## 作者：zhaowangji (赞：3)

打开题目一看，这不就是二分答案吗？

代码一打，交上去，10分 ~~然后就不做了~~

这几天每天都拿出来看一下，今天终于写出来了

一直认为就是裸的[跳石头（奶牛跳房子）](https://www.luogu.org/problem/P2678)
（自己也写过[题解](https://zhaoqi.blog.luogu.org/solution-p2678)）
，结果突然发现**所检测到的要移开的瓶盖数不是<=b，而是<=a-b**

看到没有用跳石头写法的题解，就写了一篇

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int a,b;
int zb[100007];
bool jud(int m)
{
	int sum=0,x=zb[1];//sum是要移走的瓶盖数
    	//x是当前瓶盖（即要跳起的石头）
	for(int i=2;i<=a;i++)
	if(zb[i]-x<m)sum++;//两个瓶盖间距离较小，要移走
	else x=zb[i];//以下一个瓶盖重新作为起跳点
	if(sum<=a-b)return true;//要移的数量<=a-b（因为要保证至少有b个瓶盖留下）
	else return false;
}
int main()
{
	cin>>a>>b;//尽量用题目里的变量
	for(int i=1;i<=a;i++)
	cin>>zb[i];//坐标
	sort(zb+1,zb+a+1);//注意，要先排序！！！
    	//二分必须在满足单调性的数据中进行
	int l=0,r=0x7fffffff-1,m;//r赋成一个很大的值
	while(l<r)//此处是模板
	{
		m=(l+r+1)/2;
		if(jud(m))l=m;
		else r=m-1;
	}
	cout<<l<<endl;//l即为答案
	return 0;
}
```


---

## 作者：RedreamMer (赞：3)

## 一道十分合适的二分答案上手题
#### 题目大体意思（更好理解）：有n头牛，你需要在其中选c头，使得这c头牛最近的2头牛之间的的距离最远，输出最近的最远距离
#### 我们可以从最大距离和最小距离之间选择一个最大的可实现距离，因为数据过大，无法顺序选择，只有通过二分可以实现:先二分找一个距离，若这个距离可以实现，则用变量替换此数（注意不用比较，因为二分得到的答案一定是更优更大的），就往更大的距离去寻找，若这个距离不可以实现，就往更小的距离去找，重复寻找，直到区域区间之内没数为止。
```
#include<bits/stdc++.h>
using namespace std;
long long a,b,mx=0,mn=0xffffffff;				//怕数据太大 
int L,R,mid,som,last;
bool can=0;
long long s[100001];
int main()
{
    cin>>a>>b;
    for(int i=1;i<=a;i++)
    {
        cin>>s[i];
        mx=max(s[i],mx);						//寻找最大数 
        mn=min(s[i],mn);						//寻找最小数 
    }
    sort(s+1,s+a+1);							//二分必须的排序	
    L=0;										//最小的间隔距离 
    R=(mx-mn)/(b-1);							//最大的间隔距离，用来省时间 
    while(L<=R)									//开始二分 
    {
        mid=L+(R-L)/2;							//寻找一个想实现距离 
        last=s[1];								//从第一个数开始一定是最优的 
        for(int i=2,j=1;i<=a;i++)				//从第二个数开始寻找	 
        {
            if(s[i]-last>=mid)					//判断此头牛到上一头牛的距离是否大于想实现的距离 
            {
                last=s[i];
                j++;
            }
            if(j==b)							//判断牛的数量够了没 
            {
                can=1;							//用bool函数标记是否成功 
                som=mid;						//替换最优解 
                break;
            }
        }
        if(can)
        L=mid+1;								//现在的距离成功，往上二分 
        else
        R=mid-1;								//现在的距离不成功， 往下二分 
        can=0;
    }
    cout<<som;									//输出最优解 
    return 0;
}
```


---

## 作者：清风我已逝 (赞：3)

总结一下：

神马求最大的距离最小，最小的距离最大

一般都是二分查找

写一个judge函数判断一下mid是否可行即可


奉上代码：

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;
int a,b,c[100005],l,r,mid;

bool judge(int x){//判断距离为x是否可行
	int k=1,t=1;
	for(int i=1;i<=a;i++){
		if(c[i]-c[k]>=x){
			++t;
			k=i; 
		}
	}//贪心判断是否可以分成b段
    if(t>=b) return true;
	else return false;
}
int main()
{
	scanf("%d%d",&a,&b);
	for(int i=1;i<=a;i++) scanf("%d",&c[i]);
	sort(c+1,c+1+a);r=c[a]-c[1];//右端点初始化
	while(l<=r)
	{
		mid=(l+r)/2;
		if(judge(mid)==1) l=mid+1;
		else r=mid-1;
	}
	printf("%d",r);
	return 0;
} 
```

---

## 作者：dfydada⚡⚡⚡ (赞：3)

二分答案顾名思义，只要用所以答案进行二分，在放入循环中去找就可以了。

二分想必没什么好说的吧，上代码：

```cpp
l=1;
	r=a[n]-a[1];
	while(l<=r)
	{
		mid=(l+r)/2;
		if(asd(mid))
		{
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
```
主要是二分进入的函数，实际上也不是很难。
如果满足题目的条件就累加，如果超过了或者等于b就可以返回真了，然后下一次进入函数时记得累加器等初始化。

上代码：

```cpp
bool asd(int x)
{
	ans=1;
	ant=1;
	for(int i=2;i<=n;i++)
	{
		if(a[i]-a[ant]>=x)
		{
			ans++;
			ant=i;
		}
	}
	if(ans>=m)
	{
		return true;
	}
	else
	{
		return false;
	}
}
```
最后有一点很重要，至少我是这么认为的，一点要排序。因为题目样例，害我自信的提交了，搞的全错。最后才发现是没有排序。

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=100000+10;
int n,m,a[N];
int l,r,mid,ans,ant;
bool asd(int x)
{
	ans=1;
	ant=1;
	for(int i=2;i<=n;i++)
	{
		if(a[i]-a[ant]>=x)
		{
			ans++;
			ant=i;
		}
	}
	if(ans>=m)
	{
		return true;
	}
	else
	{
		return false;
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	l=1;
	r=a[n]-a[1];
	while(l<=r)
	{
		mid=(l+r)/2;
		if(asd(mid))
		{
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
	cout<<l-1;
	return 0;
}

```


---

## 作者：Sophon (赞：2)

# 二分答案
### P1316 丢瓶盖
#### 题意   
&emsp;&emsp;数轴上有$\;n\;$个点，从中选$\;m\;$个，$\;m\;$个点中两两间距离有一个最小值（下称“这种选法的最小值”），求在所有选法中这个最小值的最大值。
#### 答案范围
&emsp;&emsp;$[0,\,max(a[i])-min(a[i])\,]$
#### 判断答案
&emsp;&emsp;对于固定的答案$\;ans\;$，如果可行，$ans\;$必然为某种选法的最小值。所以这种选法中两两点间距一定大于等于$\;ans\;$。于是在已排好序的数组中挑选$\;m\;$个数的时候，只能挑选大于等于当前已挑选最大数加上$\;ans\;$的数。为了让$\;ans\;$成为答案，就必须让能挑选的数尽量靠前，这样才能让挑选序列尽可能地长，以至于大于等于$\;m\;$，成为答案（答案即为这个序列的任一长度为$\;m\;$的子序列）。所以，只需从第一个数开始，不断向后寻找**第一个**大于等于当前已挑选最大数加上$\;ans\;$的数即可。下证抛弃第一个数从第二个开始序列长度不可能更优：  
&emsp;&emsp;假设从第一个开始无法选足$\;m\;$个数满足条件，从第二个开始选足了$\;m\;$个数（$\;a[s_1...s_k]\;$)。则将$\;a[s_1]\;$替换为$\;a[1]\;$，由于$\;a[1]<a[s_1]\;$，序列仍满足条件。与“从第一个开始无法选足$\;m\;$个数满足条件”这一前提矛盾。得证。  
&emsp;&emsp;所以先前那样判断是正确的。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100000 + 20;

int a[N];
int n, m;

bool check(int x)
{
	int cnt = 1;//已选择数的序列长度
	int last = a[1];//贪心，选第一个数，证明如上
	for (int i = 2; i <= n; i++)//向后找第一个
	{
		if (a[i] - last >= x)
		{
			cnt++;
			last = a[i];
		}
	}
	return cnt >= m;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + 1 + n);

	int l = 0, r = a[n] - a[1];//答案范围
    //下面是板子
	while (l < r)
	{
		int mid = (l + r + 1) >> 1;
		if (check(mid))
		{
			l = mid;
		}
		else
		{
			r = mid - 1;
		}
	}
	cout << l << endl;
}
```
附送整数二分板子:  
&emsp;&emsp;$\;mid\;$归属给左端点：
```
while (l < r)
{
	int mid = (l + r + 1) >> 1;
	if (check(mid))
	{
		l = mid;
	}
	else
	{
		r = mid - 1;
	}
}
```
&emsp;&emsp;$\;mid\;$归属给右端点：
```
while (l < r)
{
	int mid = (l + r) >> 1;
	if (check(mid))
	{
		r = mid;
	}
	else
	{
		l = mid + 1;
	}
}
```
二选一。码的时候先打上$int\;mid = (l + r) >> 1;\;$然后再根据$\;mid\;$的归属修改$\;mid\;$即可。(总觉得只有这种二分板子好记）

---

## 作者：zhaowangji (赞：2)

又是一道二分答案啊

如果发现题意是“最小值最大”“最大值最小”“最优解”，
那么就要思考是不是用二分答案写了

其实还是一道[跳石头（奶牛跳房子）](https://www.luogu.org/problem/P2678)，不懂可以看下这题[我的题解](https://zhaoqi.blog.luogu.org/solution-p2678)

建议先做做跳石头

把牛棚当作石头，把牛的总数当作必须有的石头数，那么牛棚总数减去牛的总数就是可以移开石头的个数

然后就是跳石头啦（但写法有一点不一样，跳石头要判断终点与倒数第一个石头，而这题不需要，而这题的起点就是第一个石头（牛棚））

```cpp
#include<iostream>
#include<string.h>
#include<algorithm>
using namespace std;
int n,c;
int a[100007];
bool judge(int dis)
{
	int tot=0,x=a[1];//起点就是第一个石头（牛棚）
	for(int i=2;i<=n;i++)//从第二个点开始判断
	if(a[i]-x<dis)tot++;//当前起跳点与落点距离过小，要移走落点
	else x=a[i];//更新当前起跳点
	if(tot<=n-c)return true;//要移走的石头数
	else return false;
}
int main()
{
	cin>>n>>c;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	sort(a+1,a+n+1);//题目没说一定是有序的买最好要排下序
	int l=0,r=1e9+1,m;//r=1000000001，是绝对取不到的值
	while(l+1<r)//模板
	{
		m=(l+r)/2;
		if(judge(m))l=m;
		else r=m;
	}
	cout<<l<<endl;
    return 0;    
}
```

还可以做做[跳瓶盖](https://www.luogu.org/problem/P1316)
，[我的题解（也用跳石头做）](https://zhaoqi.blog.luogu.org/solution-p1316)


---

## 作者：梅心 (赞：2)

这题和1824进击的奶牛差不多，都是二分答案例题。

有些蒟蒻不知道二分答案，我来讲一下，二分答案通俗的说就是不断地通过二分调整逼近答案。

其实二分答案很简单，只是要理解题意并写好check函数就可以了。

本题check函数：
```
bool check(int x)//检查check函数 
{
	int dis = a[1];
	int sum = 1;//第一个自动不拿，可使距离更大 
	for(int i = 2; i <= n; i++)
	{
		if(a[i] - dis >= x)//如果当前瓶盖与上一个瓶盖的距离比当前最大距离大 
		{
			sum++;//瓶盖数加1; 
			dis = a[i];//更新上个瓶盖距离 
		}
	}	
	return sum >= m;//如果sum>=m,返回ture,否则返回false 
}
```
整个函数：
```
#include<bits/stdc++.h>//万能脑袋 
using namespace std;
int l, n, m, a[100005];
bool check(int x)//检查check函数 
{
	int dis = a[1];
	int sum = 1;//第一个自动不拿，可使距离更大 
	for(int i = 2; i <= n; i++)
	{
		if(a[i] - dis >= x)//如果当前瓶盖与上一个瓶盖的距离比当前最大距离大 
		{
			sum++;//瓶盖数加1; 
			dis = a[i];//更新上个瓶盖距离 
		}
	}	
	return sum >= m;//如果sum>=m,返回ture,否则返回false 
}
int main()
{
	int left = 0, right;
	cin >> n >> m;//输入 
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + 1 + n);//排序 
	right = a[n] - a[1] + 1;//上限+1，下限-1，后面可不特判 
	while(left + 1 < right)//三种方法，任选其一 
	{
		int mid = left + (right - left) / 2;//定义中间值 
		if(check(mid) == true) 
		{
			left = mid;//更新下限 
		}
		else
		{
			right = mid;//更新上限 
		}
	}
	cout << left;//输出 
	return 0;
} 
```
感谢apple365

---

## 作者：Space_Gold_Trash (赞：2)

~~听着核爆神曲做的......~~

第一次读完题，十分想用搜索做，然而......

2<=N<=100,000
and
0<=xi<=1,000,000,000

我瞬间打消了用搜索的念头

~~还是按教科书上说的用二分来做吧~~

很显然的二分，数据如此大，一般都会想到贪心和二~~三四五六七~~分

~~其实我是想到什么算法就试一下过不过得了~~

# 显然易见的二分答案

二分枚举枚举答案
+
一个check函数了事

说的简单，但怎么check呢？？？？？？？？？？？？？？

check函数：

```c
inline bool check(int k){
	int i=1,j,last=f[1],s=1;
	while(++i<=n&&s<c)
	if(f[i]>=last+k)s++,last=f[i];
	return s>=c;
}
```
注释：f已从小到大排序

解说：贪心思想，如果有（1，2，5）三个数，要求间隔为3，很显然选择1，5
而不是2和5虽然都可以

so
last初始化f[1]

然后枚举后面的，只要f[i]>=last+间隔
个数++

最后return 个数>=牛的数量

程序拜拜

完整代码

```c
#include<bits/stdc++.h> 
using namespace std;
int n,c,f[100100];
inline bool check(int k){
	int i=1,j,last=f[1],s=1;
	while(++i<=n&&s<c)
	if(f[i]>=last+k)s++,last=f[i];
	return s>=c;
}
int main( ){
	std::ios::sync_with_stdio(false);
	cin>>n>>c;
	int i,j,l=1000010000,r=-1,ans,mid;
	for(i=1;i<=n;i++)cin>>f[i];
	sort(f+1,f+n+1);
	l=f[1];r=f[n]-f[1];
	while(r-l>1){
		mid=(l+r)/2;
		if(check(mid))ans=l=mid;
		else r=mid;
	}
	cout<<ans<<endl;
}
```


---

## 作者：Y15BeTa (赞：2)

我写了个set版本的O_O 

二分的细节方面很让人头疼，我用”//zy“(注意)标注了一些细节O_O
```
#include<cstdio>
#include<iostream>
#include<iterator>
#include<set>
#include<algorithm> 
using namespace std;

int n,c;

set<int> oxro;

set<int>::iterator it=oxro.end();

bool check(int dis){
    int last=*oxro.begin(),niu=0;//zy
    for(it=oxro.begin(),it++;it!=oxro.end();it++){//zy
        if(*it-last>=dis){
            niu++;
            last=*it;
        }
        if(niu>=c)return 1;
    }
    if(niu+1<c)return 0;//zy//zy
    return 1;
}

int main(){
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++){
        int room;
        scanf("%d",&room);
        oxro.insert(room);
    }
    int l=1,r=*(--it)-*oxro.begin();//zy
    while(l<=r){//zy
        int mid=(l+r)>>1;
        if(check(mid))l=mid+1;
        else r=mid-1;
    }
    printf("%d\n",r);//zy
}

```
细节方面也可以这样写,也通过了:
```
#include<cstdio>
#include<iostream>
#include<iterator>
#include<set>
#include<algorithm> 
using namespace std;

int n,c;

set<int> oxro;

set<int>::iterator it=oxro.end();

bool check(int dis){
    int last=*oxro.begin(),niu=1;//niu=1注意 
    for(it=oxro.begin(),it++;it!=oxro.end();it++){//zy
        if(*it-last>=dis){
            niu++;
            last=*it;
        }
        if(niu>=c)return 1;
    }
    return 0;
}

int main(){
    scanf("%d%d",&n,&c);
    for(int i=1;i<=n;i++){
        int room;
        scanf("%d",&room);
        oxro.insert(room);
    }
    int l=0,r=*(--it)-*oxro.begin()+1;//zy
    int mid;
    while(l<=r){//zy
        mid=(l+r)>>1;
        if(check(mid))l=mid+1;
        else r=mid-1;
    }
    printf("%d\n",r);//zy
}
```

#  解析
### part1 什么是二分，本题怎么用(萌新模板)

        //不久前,本蒟蒻终于明白了:二分就是暴力，优化的暴力O_O
        //注意:二分的有些细节问题，例如循环条件到底要不要加'=',一定要编数据多调试!!!(其实对于本蒟蒻，往往会因为这些点磨叽很久...多多尝试吧!!!)
        //对于"最大值的最小值","最小值的最大值"之类的题一般都是用二分。
        //例如本题为"最小值的最大值"，通过"二分"的方式来枚举"最大值"的可能值。(如果枚举出的mid符合条件，那我们再搜一搜有没有比mid大的值也符合条件O_O) 
        
### part2 如何判断枚举出的"最大值"是否符合条件(二分题关键)

        //我看了看楼下的题解，主要的方法有两种：
 		//1.保证距离与牛栏数，看能否放下c头牛 (我用的是这种)
		//2.保证距离与牛数，看需要多少牛栏 
		//注意:某些东西在循环里return貌似是有那么一点点快O_O 
        
### 2018/11/14更新：
	1.set的版本在windows下的oj中不一定能过，有可能会超时。
    2.有一个点必须要注意：最后要输出r,因为r在r、l、mid中理论上是最大的，否则大部分WA

---

## 作者：铁盒 (赞：2)

这道题目的思想是这样的，我们通过先对隔间的距离进行排序（由于n=100000所以得是快排）再枚举隔间的距离，但是由于距离最大有可能是1000000000，所以枚举肯定超时，所以，我们需要用需要用二分来求出距离，下面是二分核心代码。

```cpp
  l:=1;
  r:=1000000000;
  while l<r do//二分开始
    begin
      mid:=(l+r) div 2;
      s:=1;
      t:=a[1];
      for i:=2 to n do
        if a[i]-t>=mid then
          begin
            inc(s);
            t:=a[i];
          end;//看看定下来的距离是否满足让奶牛都能住进去
      if s<m then//如果住不进去就减少牛棚距离
        r:=mid
        else//如果够住就看看距离是否大于max并增大牛棚距离
          begin
            l:=mid+1;
            if mid>max then
              max:=mid;
          end;
    end;
  mid:=(l+r) div 2;//由于考虑到l=r会退出就再来一遍
  s:=1;
  t:=a[1];
  for i:=2 to n do
    if a[i]-t>=mid then
      begin
        inc(s);
        t:=a[i];
      end;
      if s>=m then
        if mid>max then
max:=mid;
```

---

## 作者：cscy (赞：1)

献给和我一样初学二分答案的朋友

如果我们假设瓶盖间最小距离len, 满足len > 第一个瓶盖与最后一个瓶盖距离+1， 那么显然可以确定，此时最多保留一个瓶盖。 

再假设len = 1, 显然所有瓶盖都可以保留。

那么可以确定，答案的范围就在上述情况之间，也就是说，答案的范围确定在了[1, 第一个瓶盖与最后一个瓶盖距离+1);

——————————————————————

分析到这里，首先想到暴力枚举每一个答案。
但是算法复杂度就是o(n^2), 显然爆t

于是需要用到最小距离的性质进行优化。

假如已知 最小距离 = len 时， 最多保留 C 个人。
那么 最小距离 = len - 1时， 一定可以至少保留C个人。

比如原来最小距离是4， 现在告诉你最小距离变成了3， 那么是不是还得添上几个人？一定比原来人多。

——————————————————————

假设现在答案所在区间为[l, r);

那么计算(l+r)/2 是否满足 最多保留的人数 <= B；

如果满足， 那么答案一定在[(l+r)/2, r)；

当l = r - 1时， 获得答案， l


以下为核心代码

```cpp
 while(r - l > 1){
    Calc((l+r)/2);  //计算最多保留多少人 C         
                    //具体怎么实现就要自己想啦
    if(C < B){      //(r+l)/2不符合， 缩小右侧边界 
      r = (r+l)/2;
    }
    else{           //(r+l)/2符合， 缩小左侧边界
      l = (r+l)/2;
    }
  }
  
  cout << l << endl;
```





---

## 作者：shaomengyu (赞：1)

其实这是一道二分的题。~~一开始我根本没看出来，但在我借鉴了一下题解后。~~这确实是一道二分的题
------------
 上面已经有daolao讲过区间的确定了。
 那我们就讲一下其中的一些小细节

------------
a[i]指n个瓶盖的距离，tot指丢的瓶盖数，num其实就是判断下一个瓶盖丢在哪里的一个动点
在chk函数里面
因为第一个瓶盖一定丢在1号位置上（最近的距离最大嘛）（让头最小），此时动点num在a[i]这个位置
if(a[i]-a[num]>=x) 如果某一个点到1号点的距离比x大，那我就找到了下一个瓶盖可以丢的位置，所以丢的瓶盖数++。此时动点num要移到i这个点，去找更大的间隔。

------------
最后return tot>=m;意思是我丢的瓶盖已经比总的瓶盖数还多了，这就和下面的主函数联系起来了

------------
在主函数里面一定要排序的，把间隔由低到高排序,后面会由间隔低的向高的找

------------
拍完序过后就是二分的精髓了
if(chk(mid))l=mid;     如果mid>=m 说明选的mid太小了导致丢的瓶盖数量太多了，所以我的间隔找小了，要往间隔大的找，（前面的间隔都很小嘛）那么应该把mid移到后面去，去找刚好丢够瓶盖数。而且mid这个点可能成立（因为return>=嘛） 

------------
 else r=mid-1; 如果mid小于m，说明间隔取大了，瓶盖丢少了（后面的间隔更大嘛，所以肯定不能在后面找）就该在前面找 并且mid这个点一定不成立 

------------
你以为完了吗，当然没有。
这里有个坑就是r=1000000000；我也不知道是为什么。可能是他给的样例太特殊了吧。
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
int a[100000+500];
int chk(int x){
	int tot=1;int num=1;
	for(int i=2;i<=n;i++){
		if(a[i]-a[num]>=x){
			tot++;
			num=i;
		
		}
	}return tot>=m;
   
}
int main(){
	scanf("%d%d",&n,&m);
	int l=1,r=1000000000;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	while(l<r){
		int mid=(l+r+1)/2;
		if(chk(mid))l=mid;
      else r=mid-1; 
	}
	printf("%d",l);
	return 0;
}

---

## 作者：万弘 (赞：1)

~~看到题解不多，我来水一篇~~  
瞅了瞅$B<=A<=100000$不难想到二分答案  


什么？你不知道二分答案？[这里走](https://www.luogu.org/blog/c2522943959/er-fen)  
二分后只需要写一个贪心的$check()$   
k是B，n是A，$a[]$是各个点坐标
```cpp
bool check(ll w)//当前测试的mid
{
	ll s=1,pre=a[1];
	for(ll i=2;i<=n;i++)
	{
		if(a[i]-pre>=w)
		{
			s++;
			pre=a[i];
		}
	}
	return s>=k;
}
```
$check(mid)$后我们只知道$mid$是否可行  
若可行，真正的答案可能大于$mid$但也可能等于它（有可能再多一点点就不行了），$l=mid$才是正确操作  
若不可行，真正的答案一定小于$mid,r=mid-1$  
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n,k,a[1000001];
bool check(ll w)
{
	ll s=1,pre=a[1];
	for(ll i=2;i<=n;i++)
	{
		if(a[i]-pre>=w)
		{
			s++;
			pre=a[i];
		}
	}
	return s>=k;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(ll i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	ll l=0,r=a[n],mid;
	while(l<r)
	{
		mid=(l+r+1)/2;
		if(check(mid))l=mid;
		else r=mid-1;
	}
	printf("%d",l);
	return 0;
}
```
其实本篇题解的精髓就是在上面的链接里  


---

## 作者：NeosKnight (赞：1)

跟丢瓶盖和跳石头可以说是一模一样，稍微转化一下就可以直接套用代码了，因为这里要放    c     头牛可以认为是空置   n-c    个隔间，

然后问题就变成了在   n    个隔间中拆掉（空置） n-c    个隔间使两个最近隔间的距离最大；

代码：



        
    

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int op[100001];
inline int read()//读入优化 
{
    int x=0;
    char ch='!';
    while(ch>'9'||ch<'0')
    ch=getchar();
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-48;
        ch=getchar();
    } 
    return x;
}
int n,c;
inline bool pd(int x)
{
    int tot=0;
    int l=op[1];//l记录前一个放了奶牛的隔间坐标 （有一头奶牛放在第一个棚肯定没问题（其实还有一头放在最后一个也没问题，但这里不需要）） 
    for(int i=2;i<=n;i++)
    {
        if(op[i]-l<x){
            tot++;//距离比限定的距离大就要空置（l此时不变） 
        }
        else l=op[i];
    }
    return tot<=c;
}
int main()
{
    n=read();c=read();
    for(register int i=1;i<=n;i++)
    op[i]=read();
    sort(op+1,op+1+n);//题目中给出的隔间顺序不一定是顺序的，要排下序 
    if(c==2){//只有两头牛了肯定一个最前一个最后； 
        cout<<op[n]-op[1]<<endl;
        return 0;
    }
    c=n-c;//要放这么多头奶牛就是要空置 n-c 个棚 
    int xx=1;int yy=op[n]-op[1];//二分 
    while(xx+1<yy)
    {
        int mid=xx+yy>>1;//二分 
        if(pd(mid)) {
            xx=mid;
        }
        else yy=mid;
    }
    int ans=xx;
    if(pd(yy)) ans=yy;//这里再多判断一下，保险； 
    cout<<ans<<endl;
}
```

---

## 作者：Kwork (赞：1)

题解里面没有C++的题解，记录里貌似有人一直用C++过不了然后抄了Pas的题解，为了不暴露他们，还是贴个题解。

我们可以对于答案二分，然后验证是否可行。验证可行的过程是check。这题和NOIP2015的跳石头类似，我们统计当满足mid值是所需要的瓶盖数量，如果小于要求那么这个值便是不合法的。

```cpp

#include <algorithm>
#include <iostream>
using namespace std;
int n,m,stone[100001];

bool check(int now){
    int last=1,tool=1;
    for(int i=2;i<=n;i++){
        if(stone[i]-stone[last]>=now){
            tool++;
            last=i;
        }
    }
    if(tool<m) return false;
    return true;
}
void solve(){
    int l=1,r=stone[n]-stone[1],mid;
    while(r>=l){
        mid=(l+r)/2;
        if(check(mid)) l=mid+1;
        else r=mid-1;
    }
    cout<<l-1;//答案在左端点的左边，不然会全部WA哦。。。。
    return;
}
int main(){
    std::ios::sync_with_stdio(false);

    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>stone[i];
    sort(stone+1,stone+n+1);
    solve();

    return 0;
}

```

---

## 作者：WuhenGSL (赞：1)

#### 于是这就是二分答案

二分的时候加个check

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+9;
int a[N],n,c;
bool check(int m){
	int cnt=1;
	int x=1;
	for(int i=1;i<=n;i++)
		if(a[i]-a[x]>=m) {
			cnt++;
			x=i;
		}
		
	 if(cnt<c) return true;
	 else return false;
	}


int main()
{
	cin>>n>>c;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	int l=0,r=a[n]-a[1]+1; 
	
	while(l+1!=r){
		int m=(l+r)/2;
		if(check(m)) r=m;
		else l=m;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：沧海映繁星 (赞：1)

这个题目仔细看了一下之后，发现和 P2678 【跳石头】非常相似，只是要在原码上稍作修改。将“找出B个瓶盖使距离最大”改为“移除A-B个瓶盖使距离最大”就行了接下来，直接上代码。
```
#include<bits/stdc++.h>
using namespace std;
long long a[2000000],m,n;
int read()//数据有点大，用个快读玩一下，可以不用在意，用cin就可以了 
{
	char s;
	int x=0,f=1;
	s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-') f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<3)+(x<<1)+s-'0';
		s=getchar();
	}
	return x*f;
}
bool f(int x)//判断方案是否成立 
{
	long long start=a[1];//在这里处理一下，因为他不会移掉第一个瓶盖（因为没有用）。所以可以将第一个瓶盖，视为跳石头中的起点。 
	long long s=0; 
	for(int i=2;i<=m;i++)//因为，a[1]是起点所以从a[2]开始判断。 
	{
		if(a[i]-start>=x) start=a[i];
		else s++;
	}
	if(s<=n) return 1;
	else return 0;
}
int check(int l,int r)//这里是二分查找的模板
{
	int mid;
	while(l<r)
	{
		mid=(l+r+1)/2;
		if(f(mid)) l=mid;//若成立，寻找更大的距离 
		else r=mid-1;//若不成立，寻找可以的距离 
	}
	return r;
}
int main()
{
	m=read();
	n=read();
	n=m-n;
	for(int i=1;i<=m;i++)
	{
		a[i]=read();
	}
	sort(a+1,a+m+1);//排一下序，是坐标从小到大（否则会出错）。 
	printf("%.d",check(1,1000000000));
}
```
这个题目，因为排序0分了好久，最后才想到要排序

---

## 作者：邱江坤 (赞：1)

这道题是求最小值的最大值，可以dp，可以贪心二分。在这么大的数据范围下，dp是不可能的，所以只能贪心二分。

看了一下其他人关于二分部分的答案，发现并不是最简练的写法。

拿样例12345来说

x\_\_\_\_\_\_\_ 0 1 2 3 4

check(x) n y y n n


我们要保证二分时left的初始值一定在'y'的范围内，所以求出'y'来

很明显，'y'的上界是最大减去最小

二分时注意，我们要求最大的那个'y'所对应的x，所以check(mid)后，如果可行，left = mid + 1，试图寻找更大的x，如果不可行，right = mid - 1，试图找到更小的x。由于每次二分时，都能保证x < right，所以最后的right就是最大的x。

```cpp

#include <bits/stdc++.h>
using namespace std;

	int a[100000];
	bool check(int n, int m, int mmin)//是否可行
	{
		int num = 1, last = a[0];
		for (int i = 1; i < n; ++i)
			if (a[i] - last >= mmin)
				last = a[i],++num;
		return num >= m;
	}

	int main()
	{
		int n, m;
		cin >> n >> m;
		for (int i = 0; i < n; ++i)
		{
			cin >> a[i];
		}
		sort(a, a + n);

		int left = 0x3f3f3f3f, right = a[n-1] - a[0];
		for (int i = 0; i < n - 1; ++i)
			left = min(left, a[i+1] - a[i]);
		while(left <= right)
		{
			int mid = (left + right) >> 1;
			if (check(n, m, mid))
				left = mid + 1;
			else
				right = mid - 1;
		}
		cout << right << endl;
        return 0;
	}



```

---

## 作者：jeremyjy (赞：1)

好棒的USACO题目啊！采用**二分答案**即可~~TLE或WA或MLE~~    AC！

上代码↓↓↓
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;//使用名字空间
int x[100005],n,m,i;//定义全局变量
bool judge(int s)//手写比较函数
{
	int cnt=1;
	int tmp=x[0];//套路变量，根本不用解释！
	for(int i=1;i<n;i++)//尝试放n个牛
	{
		if(x[i]-tmp>=s)
		{
			cnt++;
			tmp=x[i];
			if(cnt>=m)
				return 1;
		}
	}
	return 0;//注意：这不是结束程序！！！
}
int main()//主程序
{
	cin>>n>>m;//输入
	for(i=0;i<n;i++)
		cin>>x[i];//还是输入
	sort(x,x+n);//数据排序（他没担保有序啊！）
	int l=x[0];//开始有（无）趣（聊）的二分答案
	int r=x[n-1]-x[0];
	int mid;
	while(l<r)
	{
		mid=(加密1)/2;//这步已加密，反抄题解
		if(judge(mid))
			l=加密2;//这步已加密，反抄题解
		else
			r=加密3;//这步已加密，反抄题解
	}
	cout<<l;//输出
	return 0;//保持习惯！
}
```
------------------------------------------抄题解勿扰---------------------------------------------
加密含义：

加密1：l+r+1

加密2：mid

加密3：mid-1（这很重要！！！）

---

## 作者：HoshinoTented (赞：1)

# 检验
二分答案中最重要的莫过于检验了  
给定间隔 $x$, 求 能否放下所有牛  
```haskell
-- 询问 :: 给定间隔 -> 上一只牛的位置 -> 题目中的N -> 题目中的C -> 房间 -> 结果
ask :: Int -> Int -> Int -> Int -> [Int] -> Bool
ask _ _ _ 0 _ = True	-- 如果所有的牛都安排完毕，直接返回 True
ask _ _ _ _ [] = False -- 如果隔间用完，返回 False （因为 c == 0 的情况以及被第一个模式匹配拦截下来了）
ask x last n c (room:rooms) = if room - last >= x then ask x room n (c - 1) rooms else    -- 如果 当前隔间 - 上一只牛所在隔间 >= 给定间隔 则 将当前隔间作为 新的 上一只牛所在隔间，并且减少需要安排的牛的数量
    ask x last n c rooms	-- 否则继续循环
```

# 二分
很简单，把 `C` 的板子抄过来就好了（板子应该不用注释了吧。。）  
```haskell
-- 二分答案 :: 左界限 -> 右界限 -> 最终答案 -> 题目中的N -> 题目中的C -> 房间 -> 结果
binaryAns :: Int -> Int -> Int -> Int -> Int -> [Int] -> Int
binaryAns left right ans n c rooms = if left > right then ans else
    let mid = (left + right) `div` 2 in
        if ask' mid then binaryAns (mid + 1) right mid n c rooms 
        else binaryAns left (mid - 1) ans n c rooms
    where
        ask' x = ask x (head rooms) n (c - 1) rooms
```

# 数据读入
`Haskell` 的数据读入一直让我觉得很烦。。毕竟没有 `C/C++` 的 `for循环`  
```haskell
-- 读取数据 -> 迭代器  -> IO 结果
readData :: Int -> IO [Int]
readData 0 = return []		-- 如果全部读完，返回空列表
readData n = do
    i <- read <$> getLine		-- 读取当前数据

    readData (n - 1) >>= \xs -> return $ i : xs		-- 获取剩余的数据，并把新数据添加在开头
```

# 最终代码
```haskell
import Data.List (sort)

-- 询问 :: 给定间隔 -> 上一只牛的位置 -> 题目中的N -> 题目中的C -> 房间 -> 结果
ask :: Int -> Int -> Int -> Int -> [Int] -> Bool
ask _ _ _ 0 _ = True	-- 如果所有的牛都安排完毕，直接返回 True
ask _ _ _ _ [] = False -- 如果隔间用完，返回 False （因为 c == 0 的情况以及被第一个模式匹配拦截下来了）
ask x last n c (room:rooms) = if room - last >= x then ask x room n (c - 1) rooms else    -- 如果 当前隔间 - 上一只牛所在隔间 >= 给定间隔 则 将当前隔间作为 新的 上一只牛所在隔间，并且减少需要安排的牛的数量
    ask x last n c rooms	-- 否则继续循环

-- 二分答案 :: 左界限 -> 右界限 -> 最终答案 -> 题目中的N -> 题目中的C -> 房间 -> 结果
binaryAns :: Int -> Int -> Int -> Int -> Int -> [Int] -> Int
binaryAns left right ans n c rooms = if left > right then ans else
    let mid = (left + right) `div` 2 in
        if ask' mid then binaryAns (mid + 1) right mid n c rooms 
        else binaryAns left (mid - 1) ans n c rooms
    where
        ask' x = ask x (head rooms) n (c - 1) rooms

-- 读取数据 -> 迭代器  -> IO 结果
readData :: Int -> IO [Int]
readData 0 = return []		-- 如果全部读完，返回空列表
readData n = do
    i <- read <$> getLine		-- 读取当前数据

    readData (n - 1) >>= \xs -> return $ i : xs		-- 获取剩余的数据，并把新数据添加在开头

main :: IO ()
main = do
    [n, c] <- map read . words <$> getLine :: IO [Int]
    rooms <- sort <$> readData n  -- 数据是无序的 ，需要排序

    print $ binaryAns 0 (last rooms - head rooms) 0 n c rooms		-- 这里其实还想对 last rooms 进行优化，毕竟 Haskell 的 last 要遍历整个列表

    return ()
```
比较坑到我的是二分的范围，第一次 $right$ 选错成 $n$ 了，结果最后一个点 WA 了  
~~还有一个是错把 `mid + 1` 写成  `left + 1`，`mid - 1` 写成 `right - 1`，导致 T 了好多点~~  
还是感觉 `Haskell` 比 ~~垃圾~~`C/C++` 优雅多了，写起来很舒服  

---

## 作者：インデックス (赞：0)

## 二分与三分
```
    二分的时间复杂度为：O（二分次数×单次判定复杂度）
```

### 1.整数定义域的二分
```
int DRHPSY(int L,int R)
{
    int L=1,R=n,ans;
    while(L<=R)
{
    int mid=(L+R)>>1;
    if(check(mid))ans=mid,L=mid+1;
       else R=mid-1;
}
    return ans;
}
```
### 2.实数定义域的二分
```
int DRHPSY(long double l,long double r)
{
	double mid;
	while(fabs(l-r)>dlt)
	{
		mid=(l+r)/2.0;
		if(check(mid)) r=mid;
		else l=mid;
	}
	return l;
}
```
### 3.三分
```
double l=0,r=1e9;
while(r-1>1e-3)
{
	double ml=l+(r-l)/3,m2=r-(r-l)/3;
	if(f(m1)<f(m2)) l=m1;
	else 
	r=m2;
}
```
### 完整代码

```
#include<bits/stdc++.h>
#pragma GCC optimize(2)//手动O2优化
using namespace std;
const int N=1E5+4;//const定义的值不会改变哦
int n,m,x[N];
inline bool check(int d)//bool型函数返回值只有1和0两种哦
{
	int cow=1;
	int rgt=x[1]+d;
	for(register int i=2;i<=n;++i)
	{
		if(x[i]<rgt) continue;
		cow++;
		rgt=x[i]+d;
	}
	return cow>=m;
	
}

int main () //主函数开始
{
	cin>>n>>m;
	for(register int i=1;i<=n;++i)//resgister int 定义的是临时寄存器变量
	cin>>x[i];
	sort(x+1,x+n+1);//sort排序
	int l=0,r=x[n]-x[1];
	while(l<=r)//以下是二分的过程
	{
		int mid=l+r>>1;
		if(check(mid))l=mid+1;
		else r=mid-1;
		
	}
	cout<<r<<endl;
	
}
```

---

## 作者：嗷嗷呜 (赞：0)

~~这是简单~~这是一个较难的一个二分加判断，不多说，奉上AC代码
```
#include<bits/stdc++.h>
using namespace std;
int l = 21474836,r,n,c;
int num[100005];
int cmp(int a,int b)
{return a < b;}
inline void read(int &x)
{
    char ch = getchar(),c = ch;x = 0;
    while(ch < '0' || ch > '9') c = ch,ch = getchar();
    while(ch <= '9' && ch >= '0') x = (x<<1)+(x<<3)+ch-'0',ch = getchar();
    if(c == '-') x = -x;
}
 
bool jud(int x)
{
    int cnt = 1,tmp = num[1];
    for(int i = 2;i <= n;++ i)
    {
        if(num[i] - tmp >= x)
             cnt ++,tmp = num[i];
        if(cnt >= c) return true;
    }
    return false;
 }
 
int main()
{
    read(n),read(c);
    for(int i = 1;i <= n;++ i)
    {
        read(num[i]);
        if(num[i] > r) r = num[i];
        if(num[i] < l) l = num[i];
    }
    sort(num+1,num+1+n,cmp);
    while(l+1 < r)
    {
        int mid = ((l+r)>>1);
        if(jud(mid)) l = mid;
        else r = mid;
    }
    printf("%d\n",l);
    return 0;
}

```


---

## 作者：蛋炒饭 (赞：0)

题意大概，给你n个直线坐标，求找到c个坐标之间可满足的最近最大距离，这个题属于二分入门了，首先要满足二分的条件，单调，所以先将给出的坐标排序，然后找l和r，进行二分就行，最近刚学会二分正好写个题解，适合新手看，大佬可以略过，上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <map>
/*这里也可以直接用一个#include <bits/stdc++.h> 这个万能头文件
不过这个头文件在各大acm比赛时时不允许使用的，所以视情况而用；
*/
using namespace std;
const int maxn=1e5+100;
typedef long long ll;
ll x[maxn];
int n,c;
int check(int y)//这个是判断函数
{
    int num=1;
    int k=1;
    for(int i=2;i<=n;i++)
    {
        if(x[k]+y<x[i])/*从x[1]开始判断，因为我们肯定会把第一个牛放在最小的那个坐标中
        ，如果x[1]+我所搜索的距离y<x[i],则所明x[k]到x[i]之间的距离大于等于y，
        所以第二个牛可以放到x[i]处，让后更新k,num记录放置的牛的个数*/
        {
            k=i;
            num++;
        }
    }
    if(num>=c)/*如果按我们搜索的距离y可放置的牛的个数num>=需要放置的牛的个数，
    那么y满足，return 1；else 不满足 return 0；*/
    return 1;
    else
    return 0;
}
int cmp(int x,int y)
{
    return x<y;
}
int main()
{
    while(~scanf("%d%d",&n,&c))
    {
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&x[i]);
        }
        sort(x+1,x+1+n,cmp);//对坐标排序；
        int l=x[1];
        int r=x[n];//找到l和r
        while(l<=r)//开始二分
        {
            int mind=(l+r)/2;
            if(check(mind)==1)
            {
              l=mind+1;
            }
            else
            r=mind-1;
        }
        printf("%d\n",l);
    }
    return 0;
}
```

---

## 作者：Celebrate (赞：0)

这一题二分最小距离即可

下面是代码：
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#define MAXN 110000
using namespace std;
inline int cmp(const void *xx,const void *yy)//排序 
{
	int x=*(int*)xx;
	int y=*(int*)yy;
	if(x>y) return 1;
	if(x<y) return -1;
}
int n,k,a[MAXN];
inline bool Check(int m)//判断距离m是否可以 
{
	int s=0,last=1;//记录上一个 
	for(int i=2;i<=n;i++)//依次枚举每个牛栏 
	{
		if(a[i]-a[last]<m)s++;//若此距离不满足当前答案，那么需要的牛栏数+1，即把当前牛放到下一个牛栏 
		else last=i;//否则就更新上一次的牛栏位置 ，即上一头牛放的位置 
		if(s>n-k) return false;//若需要牛栏数大于最大牛栏数，此答案不可行 
	}
	return true;
}
inline void Onslaught_of_cows()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	qsort(a+1,n,sizeof(int),cmp);
	int l=1,r=a[n]-a[1],mid;
	while(l+1<r)//二分
	{
		mid=(l+r)/2;
		if(Check(mid)==true) l=mid;
		else				 r=mid-1;
	}
	if(Check(r)==true) printf("%d",r);
	else			   printf("%d",l);
}
int main()
{
	Onslaught_of_cows();return 0;
}
```

---

## 作者：attack (赞：0)

感觉题解写的都好麻烦，，

其实这道题和跳石子一样，贪心&&二分一下，

只要两点的距离大于二分的距离，那么我们就选这个石子





```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
const int MAXN=1e6+10;
const int INF=0x7fffffff;
inline char nc()
{
    static char buf[MAXN],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin))?EOF:*p1++;
}
inline int read()
{
    char c=nc();int f=1,x=0;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}
    while(c>='0'&&c<='9'){x=x*10+c-'0',c=nc();}
    return x*f;
}
int a[MAXN],n,m;
int check(int val)
{
    int now=a[1],nownum=1;
    for(int i=2;i<=n;i++)
        if(a[i]-now>=val)  
            now=a[i],nownum++;
    return nownum>=m;
}
int main()
{
    #ifdef WIN32
    freopen("a.in","r",stdin);
    #else
    #endif
    n=read();m=read();
    for(int i=1;i<=n;i++)   a[i]=read();
    sort(a+1,a+n+1);
    int l=0,r=INF,ans=0;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid))  ans=mid,l=mid+1;
        else r=mid-1;
    }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：ww3113306 (赞：0)

表示本蒟蒻用小号交了n次，，，，

不过看楼下神犇都是直接求的，那本蒟蒻就提供一种相反的思路吧

这道题跟跳石头极其类似，理论上跳石头稍微改一下读入就可以过这道题

首先，题目要求保留b个瓶盖，那我们可以反过来想

要求保留b个瓶盖，那不就是丢掉（n-b）个瓶盖？

然后维护一下距离最小值最大就可以了？！

很明显的二分

看到这里是不是很眼熟，，，

没错，，，跟跳石头是一样一样的，

结果本蒟蒻写非递归版二分居然wa了好多次，，，看来本蒟蒻还是太弱了

下面贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[100000+100],n,k,x,ans;
void half()//二分距离
{
    int i,l=1,last,r=s[n],mid,have;
    while(l<=r)
    {
        mid=(l+r)/2;
        have=k;
        last=s[1];
        for(i=2;i<=n;i++)
        {
            if(s[i]-last<mid)
            {
                if(have)have--;
                else
                {
                    if(r>l)r=mid-1;//因为要-1，所以要判断(-1来去掉不合法的解） 
                    else return ;
                    break;
                }
            }
            else last=s[i];
        }
        if(r!=mid-1)
        {
            if(mid>ans)ans=mid;//因为mid是偏左的，所以要保证一定可以向右移必须mid+1，
            //但这样就不能保证最优解一定在区间内，所以要动态更新 
            if(l<r)l=mid+1;//遇到需要+1这种，，就必须判断，不然死循环 
            else return ;//如果r==l，显然就搜不下去了 
        }
    }
}
int main()
{
    scanf("%d%d",&n,&k);
    k=n-k;//处理一下，k从保留的变成去掉的个数
    scanf("%d",&s[1]);
    for(int i=2;i<=n;i++)scanf("%d",&s[i]);
    sort(s+1,s+n+1);
    half();
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Phrooce (赞：0)

二分答案 思路类似跳石头和丢瓶盖（不知道为什么这2道题难度都是普及+）

首先我们对隔棚的距离进行排序  然后枚举答案的范围

即left=1,right=w[n]-w[1] 然后验证答案

验证答案模拟一边就行了 初始使t=1,j=1,i=2 如果w[i]-w[j]<mid 就i++ 如果w[i]-w[j]>=mid 就t++，j=i


代码如下（结构体装的是输入输出优化 如果不会请无视= =）


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100001;
int n,m,w[maxn],l,r,mid;
struct act
{
    inline void read(int &now)
    {
        bool pn=0;
        char c=getchar();
        while(c>'9'||c<'0')
        {
            if(c=='-') pn=0;
            c=getchar();
        }
        while(c>='0'&&c<='9')
        {
            now=now*10+c-'0';
            c=getchar();
        }
        now = pn? ~now+1 : now;
    }
    inline void put(int x)
    {
        int y=10,len=1;
        while(y<=x)
        {
            y*=10;
            len++;
        }
        while(len--)
        {
            y/=10;
            putchar(x/y+'0');
            x=x%y;
        }
    }
}a;
void in()
{
    a.read(n);a.read(m);
    for(int i=1;i<=n;i++) a.read(w[i]);
    sort(w+1,w+n+1);
    l=1;r=w[n]-w[1];
}
bool judge(int x)
{
    int t=1;
    for(int j=1,i=2;i<=n;i++)
    {
        if(w[i]-w[j]>=x)
        {
            j=i;
            t++;
        }
    }
    if(t<m) return false;
    else return true;
}
void out()
{
    while(r-l>1)
    {
        mid=(l+r)>>1;
        if(judge(mid)) l=mid;
        else r=mid;
    }
    if(judge(r)) a.put(r);
    else a.put(l);
}
int main()
{
    in();
    out();
    return 0;
}
```

---

## 作者：Coco_T (赞：0)

/\*奶牛跳河【划掉 跳房子的思路，题目说选中B个瓶盖，实际上可以看成拿走n-B个瓶盖

下面是代码，一码两用，还可以用来做奶牛跳房子\*/






```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int a[1000005],n,B;
int mx=0,mn=1000000000;
int two()  //二分法查找最近的两个瓶盖之间的距离 
{
    int l=1;
    int r=a[n]-a[1];  // 最大距离就是第一个瓶盖离最后一个瓶盖的距离 
    int mid; 
    int tot,i,j;
    while (l+1<r)  //不这么写会T。。。QAQ 原因玄学 
    {
        tot=0; //记录拿走了几个瓶盖 ，一定要清零哦 
        mid=(l+r)/2;  
        int x=0;
        i=1;  //从第一个瓶盖开始 
        while (i<=n)
        {
            x=i+1;  
            while (a[x]-a[i]<mid&&x<=n)  //如果第x个瓶盖于第i个瓶盖距离小于我们二分查找的距离，x++ 
               x++;
            tot+=x-i-1;  //至于tot为什么这么加，大家自己体会一下就懂了 
            i=x;　　 //从x继续查找 
        }
        if (tot<=B) l=mid;  //如果移走的数量少，说明查找的数太小，如果正好相等，因为我们要查找的是最小距离的最大值，所以也要往大找  
        else r=mid;  
    }
    return l;
}
int main()
{
    scanf("%d%d",&n,&B);
    B=n-B;  //拿走的瓶盖数 
    for (int i=1;i<=n;i++)
       scanf("%d",&a[i]);
    sort(a+1,a+n+1);  //保险起见，把瓶盖排一下序 
    printf("%d",two());
    return 0;       
}
```

---

## 作者：wjcjytc (赞：0)

最小值求最大值——>很容易联想到排序+二分。对于每次二分的长度mid，求出1..n中能被mid覆盖的点数num，如果满足要求就继续加大二分值mid,否则减小mid。代码见下：

```cpp
var
  a:array[1..100000] of longint;
  n,m,i,j,l,r,mid:longint;
procedure so(l,r:longint);
var i,j,k,t:longint;
begin
  i:=l; j:=r; k:=a[(l+r) div 2];
  repeat
    while a[i]<k do inc(i);
    while a[j]>k do dec(j);
    if i<=j then
     begin
       t:=a[i];
       a[i]:=a[j];
       a[j]:=t;
       inc(i);
       dec(j);
     end;
  until i>j ;
  if i<r then so(i,r);
  if l<j then so(l,j);
end;
function get(k:longint):longint;
var i,num,now:longint;
begin
  num:=0;
  now:=a[1];
  for i:=2 to n do
   if a[i]-now>=k then now:=a[i]
   else inc(num);
  exit(n-num);
end;
begin
  readln(n,m);
  for i:=1 to n do read(a[i]);
  so(1,n);
  l:=1;
  r:=a[n]-a[1];
  while l<=r do
   begin
     mid:=l+(r-l) div 2;
     j:=get(mid);
     if j>=m then l:=mid+1
     else r:=mid-1;
   end;
  write(l-1);  //最后一次二分时，l=r，而后l=l+1时跳出二分，故答案为l-=1
end.

```

---

## 作者：pupuvovovovovo (赞：0)

典型的二分答案。

附pascal代码+注释

```cpp
program p1316;
var a:array [1..100000] of longint;
n,b,i,l,r,m,ans:longint;
procedure sort(l,r:longint);
var i,j,y,z:longint;
begin
  i:=l;
  j:=r;
  z:=a[(l+r) div 2];
  repeat
    while a[i]<z do inc(i);
    while z<a[j] do dec(j);
    if not(i>j) then
    begin
      y:=a[i];
      a[i]:=a[j];
      a[j]:=y;
      inc(i);
      dec(j);
    end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r);
end;//拷的快排
function judge(x:longint):boolean;//x代表最小的距离。即一旦大于等于它，就可以新增一枚硬币。
var i,j,ans,sum:longint;
begin
  j:=1;ans:=1;//不管怎样一枚硬币总是能放的。
  for i:=1 to n do
  begin
    if a[i]-a[j]>=x then
    begin
      j:=i;
      inc(ans);
    end;
  end;
  if ans>=b then exit(true);//x变大这儿的ans会变小，要找最大的x使ans>=b
  exit(false);
end;
begin
  read(n,b);
  for i:=1 to n do
    read(a[i]);
  sort(1,n);
  l:=1;
  r:=a[n]-a[1];
  while l<=r do
  begin
    m:=(l+r) div 2;
    if judge(m) then
    begin
      ans:=m;
      l:=m+1;
    end
    else r:=m-1;
  end;
  write(ans);
end.
```

---

## 作者：夏子汐 (赞：0)

# 一、关于单调性
一个数列有单调性，有且只有
```
对于每一个i,j（i<j），都有：
a[i]<=a[j]
或
a[i]>=a[j]
```
其中：
```
a[i]<=a[j]称作单调递增
a[i]>=a[j]称作单调递减
```
# 二、关于二分
对于一个单调的数组，在里面寻找某一个数的位置，可以使用二分。

把当前要求的数组分成两半，其中验证左半段的结尾（或者右半段的开头），如果不是，就把答案限制在左半段或右半段，以来使每一次的验证都能减少一半的数据量，避免原来接近整段数据的计算量。
# 三、关于二分答案
对于一个问题（例如说当题中的一种情况出现时，求某一个变量（参数）的取值范围（最大或最小值）），可以对于一个答案的假设进行验证出是否正确，并且答案具有单调性（即所有答案都在且仅在一个范围内，范围内的所有数（按照题目要求可以分为整数和小数）都是符合要求的），就可以进行二分答案。
# 四、代码
```
/*P1316 丢瓶盖
题目描述
陶陶是个贪玩的孩子，他在地上丢了A个瓶盖，为了简化问题，我们可以当作这A个瓶盖丢在一条直线上，现在他想从这些瓶盖里找出B个，使得距离最近的2个距离最大，他想知道，最大可以到多少呢？

输入输出格式
输入格式：
第一行，两个整数，A,B。（B<=A<=100000）

第二行，A个整数，分别为这A个瓶盖坐标。

输出格式：
仅一个整数，为所求答案。

输入输出样例
输入样例#1： 
5 3
1 2 3 4 5
输出样例#1： 
2
说明
限时3秒*/
#include<cstdio>
#include<algorithm>
using namespace std;
int a,b,s[100005],l=1,r,mid;
bool f(int x)
{
	int now=s[1],ans=1;
	for(int i=1;i<=a;i++)
	{
		if(s[i]-now>=x)
		{
			ans++;
			now=s[i];
		}
	}
	return ans>=b;
}
int main()
{
	scanf("%d%d",&a,&b);
	for(int i=1;i<=a;i++)
	{
		scanf("%d",&s[i]);
	}
	sort(s+1,s+a+1);
	r=s[a]-s[1];
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(f(mid))
		{
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
	printf("%d",l-1);
	return 0;
}
```
# 五、模板（求答案的最大值）
```
	//答案为整数
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))
		{
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
    //答案为小数
	while(r-l>=esp)
	{
		double mid=(l+r)/2.0;
		if(check(mid))
		{
			l=mid;
		}
		else
		{
			r=mid;
		}
	}
    //esp为精度，一般为10^-3~10^-15
```


---

## 作者：pidan (赞：0)

这题参考P1316丢瓶盖。

看到数据，马上想到~~DFS~~二分。思想很简单，就是用二分寻找一个最小的可行值

因为数据不保证有序，因此要先用一遍SORT

那么二分要寻找什么呢？来看题目：

------------

```
为了防止牛之间的互相打斗，Farmer John想把这些牛安置在指定的隔间，
所有牛中相邻两头的最近距离越大越好。
那么，这个最大的最近距离是多少呢？
```

------------
不难看出，只要计算小于一个长度的距离总数（即不需要被移走的奶牛），在判断是否可行，这样二分下去，找到最小的可行值就行了。

在代码中，有一个重要的处理：每次计算的距离是当前与上一头被移走的奶牛之间的距离

上代码：

```
#include<bits/stdc++.h>
using namespace std;
long long n,c,a[100010];
bool check(int x){
    int last=a[1],p=0;
    for(int i=2;i<=n;i++){
		if(a[i]-last<x){
	    p++;
		}
		else{
	    last=a[i];
		}
    }//二分处理
    return p<=n-c;//因为要选出除了不满意的奶牛之外的其它奶牛，因此这里是n-c
}
int main(){
    cin>>n>>c;
    long long l=0,r=0;
    for(int i=1;i<=n;i++){
		cin>>a[i];
		r=max(r,a[i]);
    }
    sort(a+1,a+n+1);
    while(l+1<r){
		long long mid=l+(r-l)/2;
		if(check(mid)){
	    		l=mid;
		}
		else{
	    		r=mid;
		}
    }
    cout<<l;
    return 0;
}
```


---

## 作者：jxpxcsh (赞：0)

先排一遍序。二分这个答案，初始值左端点为1，右端为最后一个点与最前一个点的差值。然后计算满足中点为最大的最小距离的值时最多能有多少个瓶盖。若值比B偏大则左移右端否则右移左端。到最后(The End)输出l=r时的值。

```delphi
    
 var a:array[1..100000]of longint;
  n,m,i,j,l,r,mid:longint;
  procedure qsort(o:longint;p:longint);//排一遍
  var i,j,m,swap:longint;
  begin
    i:=o;j:=p;m:=a[(i+j)div 2];
    repeat
      while a[i]<m do inc(i);
      while a[j]>m do dec(j);
      if i<=j then
                 begin
                   swap:=a[i];
                   a[i]:=a[j];
                   a[j]:=swap;
                   inc(i);dec(j);
                 end;
    until i>j;
    if i<p then qsort(i,p);
    if j>o then qsort(o,j);
  end;
  function cal(k:longint):longint;//计算满足中点为最大的最小距离的值时最多能有多少个瓶盖
  var i,l,v:longint;
  begin
    v:=1;l:=a[1];
    for i:=2 to n do
      if a[i]-l>=k then
                       begin
                         l:=a[i];
                         inc(v);
                       end;
    exit(v);
  end;

begin
  readln(n,m);
  for i:=1 to n do
    read(a[i]);
  readln;
  qsort(1,n);
  l:=1;
  r:=a[n]-a[1];
  while l<r do//二分
    begin
      mid:=(l+r)div 2;
      j:=cal(mid);
      if j>=m then l:=mid+1 else r:=mid;
    end;
  writeln(l-1);
  readln;
end.     

```

---


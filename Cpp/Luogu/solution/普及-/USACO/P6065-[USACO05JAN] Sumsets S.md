# [USACO05JAN] Sumsets S

## 题目描述

给出一个整数 $N$，将 $N$ 分解为若干个 $2$ 的次幂的和，共有多少种方法？

## 说明/提示

所有合法方案如下：
- 1+1+1+1+1+1+1
- 1+1+1+1+1+2
- 1+1+1+2+2
- 1+1+1+4
- 1+2+2+2
- 1+2+4

## 样例 #1

### 输入

```
7```

### 输出

```
6```

# 题解

## 作者：RKcer21 (赞：24)

前面的作者好像很强，连**打表找规律**这一个方法都没有用到，那本蒟蒻就来写一波由打表找出规律的方法:

这题一看题目，就是数论之类的东西，所以作者的本能反应，就是打表找规律（打表大法好啊）。

---

（附赠作者打的表）

$$
f(1)=1,f(2)=2,
f(3)=2,
f(4)=4,f(5)=4
$$
$$
f(6)=6,
f(7)=6,
f(8)=10,
f(9)=10,f(10)=14
$$
$$
f(11)=14,
f(12)=20
$$
初看上面这一张表，我们会发现，除了1之外，所有n为奇数时:
$$
f(n)=f(n-1)
$$

那么，对于$n$为偶数时，$f(n)$又有什么规律呢？

---
别急，我们把这些数字列进表格里来看
|  n=|1  |2  | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10  |11  | 12|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| f(n)= | 1 |2 | 2 | 4 | 4 | 6 | 6 | 10 | 10 | 14 | 14 | 20  |

欸，好像这些数字都存在着关系:

2好像是由1+1得来的

4好像是由2+2得来的

6好像是由2+4得来的

10好像是由4+6得来的

...

再仔细观察一下这组数的特点，就可以得出，当n为偶数时:

$$
f(n)=f(n-1)+f(n/2)
$$

好的，这就可以写出这题了。（附上代码）
```
#include<bits/stdc++.h>
using namespace std;
long long s[1000001];
#define N 1000000000
int i,j,k,n;
int main()
{
  cin>>n;
j=1;
k=1;
s[0]=1;
  for (i=1;i<=n;i++)
   {
    if (i%2==1) s[i]=s[i-1];
      else s[i]=(s[i-1]+s[i/2])%N;
   }
cout<<s[n];
  return 0;
}
```


好的，让我们总结一下。
有些时候，我们并不能一眼看出公式（尤其是像我这么弱的人），所以这个时候，我们需要打表去观察，运用适合的方法，去找到那彼岸的规律。

---

## 作者：zhanghzqwq (赞：8)

##**这是一道裸的完全背包问题**

看到没有dalao用完全背包来做这道题，我就~~忍不住~~发一篇。

我一开始还丧心病狂的用深搜来做这道题，结果只过了四个点。再看一下n的范围，n<=10^6，这道题无疑就是动态规划了。动态规划有两种做法，一种是大佬们用数学的方法分析求得状态转移方程，而我的方法就是直接上完全背包（不会数学分析o(╥﹏╥)o）。

这道题可以看成背包容量为n，而每个物品是$2^k$的求方案数的完全背包问题,时间复杂度为O(nlogn),不会超时。

那么状态，转移方程就是我们熟悉的：
```
dp[j]+=dp[j-a[i]];
```
最后别忘了方案数对10^9取模。~~本蒟蒻第一次忘了才得了50分~~

最后上AC代码：
```cpp
#include<iostream>
using namespace std;
int a[25];
long long dp[1000005];
int main(){
	int n;
	cin>>n;
	int p=1;
	int cnt=0;//物品数量
	for(int i=0;p<=n;i++){//求物品
		cnt++;
		a[i]=p;
		p*=2;
	}
	dp[0]=1;//预处理
	for(int i=0;i<cnt;i++){//注意是i<cnt
		for(int j=a[i];j<=n;j++){//完全背包正着循环
			dp[j]+=dp[j-a[i]];
			dp[j]%=1000000000;//取模
		}
	} 
	cout<<dp[n]<<endl;//输出
	return 0; //华丽的结束
} 
```


---

## 作者：DreamFox (赞：8)

本题思路：

当$i$为奇数时，它只能通过$i-1+2^0$得到，比如：$5$只能通过$4+2^0$得到

当$i$为偶数时，它既可以通过$i-1+2^0$，又可以通过$\dfrac{i}{2}*2$得到，比如：$6$可以通过$5+2^0$得到，也可以通过$3*2$得到

由此，我们可以推出核心公式：
```cpp
if(i%2==1)dp[i]=dp[i-1]%1000000000;
else dp[i]=(dp[i-1]+dp[i/2])%1000000000；
```
最后输出$dp[n]$ $mod$ $10^9$

---

## 作者：jokerd_tcl (赞：3)

设 $dp[n]$ 表示 $n$ 的拆分方案数，考虑 $n$ ：

- 当 $n$ 是奇数时，$n$ 的任意一个拆分都相当于 $n-1$ 的某个拆分加上一个 $1$，故 ```dp[n]=dp[n-1] ```
  

- 当 $n$ 是偶数时，讨论 $n$ 的某个拆分含有 $1$ 和不含有 $1$ 两种情况，含有 $1$ 则相当于 $n-1$ 的某个拆分附上一个 $1$ ，不含 $1$ 则相当于 $n/2$的某个拆分中所有数都 $\times 2$ ，因此，得出了此句：```dp[n]=dp[n/2]+dp[n-1] ```
  


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 1002334
#define R register
using namespace std;
const int mod=1000000000;
int n,dp[N];
int main()
{
    cin>>n;
    dp[1]=1;
    for(R int i=2;i<=n;++i)
    {
        if(i&1)dp[i]=dp[i-1];
        else dp[i]=(dp[i-1]+dp[i>>1])%mod;
    }
    cout<<dp[n];
    return 0;
}
```

求通过！
         
 			

---

## 作者：ShineEternal (赞：2)

上一篇题解貌似没有 code？那窝来补一篇。

[这里是更佳的阅读效果](https://blog.csdn.net/kkkksc03/article/details/104250868)

## description：

给出一个整数 $N$，求将 $N$ 分解为若干个 $2$ 的次幂的和的方案数。

## solution：

这道题可以使用**递推**。

我们由小向大推，分情况讨论：

- $i$ 为奇数：那么只能是 $i-1$ 这个数加上一个 $2^0$ 得来的。

- $i$ 为偶数：可能和上述过程一样，也可能是 $\dfrac{i}{2}$ 再 $\times 2$得来。

所以递推的柿子就显而易见了。

## code:

```cpp
#include<cstdio>
using namespace std;
long long f[1000005];//日常懒得动脑/kk
int main()
{
	int n;
	scanf("%d",&n);
	f[1]=1;//初始化
	for(int i=2;i<=n;i++)
	{
		if(i%2==1)
		{
			f[i]=f[i-1]%1000000000;
		}
		else
		{
			f[i]=(f[i-1]+f[i/2])%1000000000;
		} 
	}
	printf("%lld\n",f[n]%1000000000);//这个模数真是。。。别漏看，也别想当然成10^9+7
	return 0;
} 
```


---

## 作者：centur (赞：2)

蒟蒻发题解了
------------
我刚看起来是动态规划，不过我不太擅长，后来看到有大神用递推，于是改了代码。
只要分奇偶考虑即可，从小到大。
~~~~#include<bits/stdc++.h>
using namespace std;
unsigned long long b[1000001],a=1000000000;
int main(){
	int n;cin>>n;
	b[1]=1;
	for(int i=2;i<=n;i++){
		if(i%2==0){
		b[i]=(b[i/2]+b[i-1])%a;
		}else{
			b[i]=b[i-1]%a;
		}
	}
	cout<<b[n]%a<<endl;
	return 0;
}


---

## 作者：TRZ_2007 (赞：1)

### 题解 [[USACO05JAN]Sumsets S](https://www.luogu.com.cn/problem/P6065)

好像没有人写**记忆化搜索**？  
那我来写一发……  
# Solution  
我们从$n$这个数字倒推回去。如果$n$是一个**奇数**的话，那么只有：  
$$n=n-1+2^0$$  
如果$n$是一个**偶数**的话，则有：  
$$n=n-1+2^0$$  
或  
$$n=\frac{n}{2}\times 2$$  
边界条件就是 $dp(1)=1$ ，因为$1$就是$2^0$。  
什么都有了，记忆化就好写了吧。  
# Code  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1000010;
const int Mod = 1e9;

template<class T>
inline void read(T& x) {
	x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
}

int n,DP[N];

int solve(int k) {
	if(k == 1) return 1;
	if(DP[k] != -1) return DP[k];
	if(k & 1) DP[k] = solve(k - 1);
	if(k % 2 == 0) DP[k] = (solve(k - 1) + solve(k / 2)) % Mod;
	return DP[k] % Mod;
}

int main() {
	read(n);
	memset(DP,-1,sizeof(DP));
	printf("%d\n",solve(n));
	return 0;
}
```  

最后的实测：DP 66ms；记忆化 213ms。还是DP快啊。

---

## 作者：柠檬草苏打水 (赞：1)

## 这是道完全背包问题
我一开始还想用深搜来做这道题，再看一下n的范围，

### n<=10^6，
这道题就是动态规划了。我不会数学分析（呜呜呜），而我就是直接上完全背包了????。

```cpp
#include<iostream>
using namespace std;
int a[25];
long long f[1000005];
int main(){
    int n；
    cin>>n；
    int p=1,cnt=0;
    for(int i=0;p<=n;i++){
        cnt++;
        a[i]=p;
        p*=？;
    }
    f[0]=1;
    for(int i=0;i<cnt;i++){
        for(int j=？;j<=n;j++){
            f[j]+=f[j-？];//动态转移方程
            f[j]%=？;
        }
    } 
    cout<<f[n];
    return 0; 
} 
```
### ❓处请自行填写~~逃~~~

~~完美撒花~~

---

## 作者：Eason2009 (赞：0)

### 第一次发背包问题题解，多多见谅！


------------
这一题我们裸眼观察就知道是个完全背包，但是怎么递推呢？

由于这题 $n$ 很小，直接把 $1000000$ 里面所有二的幂次方打出来就好了！

$dp[j]$ 表示$j$分解为若干个2的次幂的和，共有多少种方法。

然后就是完全背包模板：$dp[j]+=dp[j-a[i]]$

上代码！

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,i,j,dp[1000001];
const int a[21]={0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288};//2幂次方的表，不多，就二十一项
int main()
{
	dp[0]=1;//初始化，否则怎么推都是零
	cin>>n;
	for(i=1;i<=20;i++)
	{
		for(j=a[i];j<=n;j++)//完全背包，正着循环
		{
			dp[j]+=dp[j-a[i]];//方法数要加上dp[j-a[i]]的方法
			dp[j]%=1000000000;//别忘记模1e9，卡了我两次！！！
		}
	}
	cout<<dp[n]%1000000000;//直接输出把n分解为若干个2的次幂的和，共有多少种方法,也要模1e9。
	return 0;//完结撒花
}
```
应该还是较好理解的……

---


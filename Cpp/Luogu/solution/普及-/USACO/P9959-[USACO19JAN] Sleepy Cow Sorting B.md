# [USACO19JAN] Sleepy Cow Sorting B

## 题目描述

Farmer John正在尝试将他的 $N$ 头奶牛（$1\le N\le 100$），方便起见编号为 $1\ldots N$，在她们前往牧草地吃早餐之前排好顺序。

当前，这些奶牛以 $p_1,p_2,p_3,\ldots,p_N$ 的顺序排成一行，Farmer John 站在奶牛 $p_1$ 前面。他想要重新排列这些奶牛，使得她们的顺序变为 $1,2,3,\ldots,N$，奶牛 $1$ 在 Farmer John 旁边。

今天奶牛们有些困倦，所以任何时刻都只有直接面向 Farmer John 的奶牛会注意听 Farmer John 的指令。每一次他可以命令这头奶牛沿着队伍向后移动 $k$ 步，$k$ 可以是范围 $1\ldots N−1$ 中的任意数。她经过的 $k$ 头奶牛会向前移动，腾出空间使得她能够插入到队伍中这些奶牛之后的位置。

例如，假设 $N=4$，奶牛们开始时是这样的顺序：

> FJ: $4, 3, 2, 1$

唯一注意 FJ 指令的奶牛是奶牛 $4$。当他命令她向队伍后移动 $2$ 步之后，队伍的顺序会变成：

> FJ: $3, 2, 4, 1$

现在唯一注意 FJ 指令的奶牛是奶牛 $3$，所以第二次他可以给奶牛 $3$ 下命令，如此进行直到奶牛们排好了顺序。

Farmer John 急欲完成排序，这样他就可以回到他的农舍里享用他自己的早餐了。请帮助他求出将奶牛们排好顺序所需要的最小操作次数。 

## 样例 #1

### 输入

```
4
1 2 4 3```

### 输出

```
3```

# 题解

## 作者：we_are_the_chuibing (赞：4)

### 题目简述
将一个序列升序排列，每次可以把队伍的第一位往后移若干位，求最小步数。

### 思路
赤裸裸的暴力。

每一次将第一只奶牛往后移若干位，移到她需要到的地方。把第 $a$ 只奶牛移到第 $b$ 只奶牛的位置上，总共需要的步数为 $| a - b |$ 步。

### 代码

```cpp
#include<iostream>
#define luogu return
#define yyds 0;
using namespace std;
int n,bs,a[105],k=1;
int main(){
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	for(int i=1;i<=n;++i){
		if(a[i]<a[i-1]){
			bs+=(i-k);
			k=i;
		}
	}
	cout<<bs;
	luogu yyds
}
```


---

## 作者：T_TLucas_Yin (赞：3)

要把 $n$ 头奶牛按升序排列。因此，在打乱的状态下，不符合排列顺序的奶牛就是与前面的奶牛编号成降序的那些。对于这些奶牛，我们需要进行调整。

根据排序规则，只有序列中的第一头奶牛可以改变位置。因此，要改变序列中一头奶牛的位置，需要两步：

1. 将前面的奶牛往后移，让这只奶牛到最前面。
2. 把这只奶牛放到应该在的位置。

根据这个思路我们就可以直接计算。例如，只考虑调整第 $i$ 头奶牛，则第一步需要进行 $i-1$ 次操作，第二步需要进行 $1$ 次操作，共需要进行 $i$ 次操作。

但是，由于上一头不符合顺序的奶牛交换位置时，需要交换到最前端。此时后面的奶牛的位置也被提前了，因此再将这些奶牛往前提时，需要的操作次数会更少。设上一头不符合顺序的奶牛是第 $l$ 头，则将第 $i$ 头奶牛调整到最前面就只需要 $i-l-1$ 次操作了。算上它自己往后移的一次操作，共需要 $i-l$ 次操作。

时间复杂度只有 $O(n)$，可见数据范围给的十分保守了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],l=1,sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++){
        if(a[i]<a[i-1]) sum+=i-l,l=i;//记得更新上一个调换了顺序的奶牛的位置
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：___nyLittleT___ (赞：1)

## [传送门](https://www.luogu.com.cn/problem/P9959)

## 题意简述
一个序列，想把它升序排列，每次可以把队伍的首位往后移若干位，求最小步数。

## 解题方法
能用什么方法？暴力是王道。

## 解题思路
每一次将第 $1$ 只奶牛往后移若干位，这个操作比较简单，而且只需要一重循环解决。如果要把第 $x$ 只奶牛移到 $y$ 的位置上，那么总共需要的步数为 $\left| x-y \right|$ 步。

## 代码解决
[AC 记录](https://www.luogu.com.cn/record/140993227)
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,way;
//way 记录步数
int cow[105];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&cow[i]);
	for(int i=1,now=1;i<=n;i++){
		if(cow[i]<cow[i-1]){   //如果存在逆序对，那么
			way+=(i-now);     //way 加上需要的步数
			now=i;          //now 记录现在的步数
		}
	}
	printf("%d",way);
	return 0;
}
```

---

## 作者：DHT666 (赞：1)

## 题意

[传送门](https://www.luogu.com.cn/problem/P9959)

有 $N$ 头奶牛想按编号排升序，每次可以让第一头奶牛插到后面任意位置，求最小操作次数。

## 思路

寻找**逆序对**，即为顺序混乱的奶牛，需要想冒泡排序一样交换它们以达到排序的效果。

而想交换两头奶牛 $p_i\ \ p_j\ (j=i+1)$，我们需要把前 $i$ 头奶牛插入至后面，即需要 $i$ 次操作。

但是，需要交换的奶牛可能不止一对，所以我们在交换后方奶牛时前方奶牛移动次数已经计算在内，只需要加上**这次交换处到上一次交换处的距离**即可。

## 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 110;

int ans,n;
int a[N];

int main() {
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	
	int tot = 1;
	for(int i=1;i<=n;i++) {
		if(a[i] < a[i - 1]) { // 寻找逆序对
			ans += i - tot; // 这次交换处到上一次交换处的距离
			tot = i; // 记录这次交换处的位置
		}
	}
	
	cout<<ans;
	return 0;
}
~~~

---

## 作者：zheng_zx (赞：1)

## P9959 [USACO19JAN] Sleepy Cow Sorting B

[题目传送门](https://www.luogu.com.cn/problem/P9959)

### 分析

---

我们可以把序列看做两部分，一部分在前表示待排序的，记为序列 $a$，一部分在后表示已排序的，记为序列 $b$。

因为序列 $a$ 在后，所以不必担心它影响序列 $b$ 的排序，那么对于序列 $a$ 的第一个元素，显然可以放到序列 $b$ 的某个对应位置，使序列 $b$ 仍然保持有序。

那么很简单，我们发现只需要将序列 $a$ 的每个元素都移动一次即可完成排序，这显然是最优的。

讲一下初始化，对于序列 $b$，我们发现显然从最后一个逆序对的第 $2$ 个元素开始一直到序列的最后一个元素可以直接作为序列 $b$ 的，那么剩下的元素按原来的顺序放入序列 $a$，接下来我们可以直接模拟这个操作。

目前的复杂度是 $O(n^2)$，显然无法通过此题。

那么消耗时间比较多的部分是什么呢？就是如何找到序列 $a$ 的第一个元素在序列 $b$ 中的对应位置。

我们需要在 $O(\log_2n)$ 的时间内求出序列 $a$ 的第一个元素在序列 $b$ 中的对应位置。首先我们发现序列 $b$ 是有序的，无需模拟，然后怎么做呢？基于 $O(\log_2n)$ 的复杂度，我们想到了树状数组，开始在序列 $b$ 中的所有元素的位置上插入一个 $a$，然后对于序列 $a$ 的第 $i$ 个元素，记为 $a_i$，我们只需要查询 $[1,a_i]$ 有几个数就知道答案了，然后再往 $a_i$ 的位置上插入一个 $a$，持续模拟即可。

---

## 作者：Arson1st (赞：1)

## [P9959 [USACO19JAN] Sleepy Cow Sorting B](https://www.luogu.com.cn/problem/P9959) 题解

### 思维题

题意很明确了：给你一个包含 $1\sim n$ 的队列，每次只允许将队头的数移动到队列中的任意位置，求最少操作几次能将队列变为单调递增的。

**引理一** 考虑这样一个事实：对于这个队列 $p$，如果每次都移动队头元素至下标小于 $k$ 的位置的话，$p_k$ 及其以后的元素永远不会被操作到，因为其位置永远不会为了腾出空间而前移，也就不可能轮到队头，得到被操作的资格。而要操作 $p_k$，则要求前 $k-1$ 次都将 $p'_1$ 挪到 $p_k$ 后面，再加上最后对 $p_k$（$p'_1$）的一次操作，总共需要操作 $k$ 次。

**引理二** 注意到另外一个事实：现在有一个单调上升序列 $q$。给定另一个序列 $p$，且 $p,q$ 交集为空，那么不论 $p$ 的内部顺序如何，一定可以用 $|p|$ 的代价将 $p$ 中的元素按下标的顺序依次插入到 $q$ 中，并使 $q$ 最终仍是单调上升的。具体方法就是将 $p_i$ 插入到其在 $q$ 中的前驱和后继中间。

回到题目，考虑怎样的一个元素 $p_k$ 才是我们必须操作的呢？如果我们知道最大的一个 $k$，根据引理一，只需操作 $k-1$ 次，就能排到操作 $p_k$ 的时刻（此时已是 $p'_1$），然后在第 $k$ 次操作移动它。（当然，这只是操作次数下界，我们不能断言 $k$ 次操作后的序列是最终合法的）现在的当务之急是找到这个 $k$。

其实 $k$ 就是 $p$ 中 **满足单调上升的最长后缀** 的 **起始位置的前一位**。为什么？如果 $p_{k+1}\sim p_n$ 满足单调上升，那么根据引理二，$p_1\sim p_k$ 一定可以用 $k$ 的代价完成插入并使结果合法。同时我们也一定需要后移 $p_k$，否则不论怎么调动 $k$ 之前的数，都不影响 $p_k$ 变动后的相对位置在 $p_{k+1}$ 之前，产生逆序对。

总结来说，根据引理一，要操作 $p_k$ 需要 $k$ 的代价。这证明了操作 $k$ 次的必要性，根据引理二，操作 $k$ 次后一定合法，这证明了操作 $k$ 次的充分性。于是我们可以得出结论：使序列合法最少需要操作 $k$ 次。

求 $k$ 时在线更新或离线查找均可，时空复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 110;

int n, p[N], ans;

int main() {
	scanf("%d", &n);
	for (int i = 1, la = 1; i <= n; i ++) {
		scanf("%d", &p[i]);  if (p[i] >= p[i-1]) continue;
		ans += i - la; la = i;
	}
	printf("%d", ans);
}
```



---

## 作者：Imerance1018 (赞：0)

### 题意简述

[传送门](https://www.luogu.com.cn/problem/P9959)

### 大体思路

暴力万岁！

### 详细描述

首先，由于只可以操控第一头奶牛，所以如果要将第 $i$ 头奶牛放到它应有的位置上，我们需要进行两种操作：

1. 让前面的奶牛到它后面去，使它变成第一头奶牛，一共进行 $i-1$ 次操作。

2. 然后再移动这头奶牛，进行 1 次操作。

所以共进行 $i-1+1=i$ 次操作。

但是，操作次数还会受到前面的影响。在进行上述的 2 种操作中，第 $i$ 头奶牛后的所有奶牛也都被向前移了。究竟移了多少呢？

明显，若上次移动奶牛的位置是 $last$ 那么 $last$ 之后的每一头奶牛都会向前移动 $last$ 个单位长度。既然我们在移动编号为 $last$ 的奶牛中已经移过第 $i$ 头奶牛了，那么就可以少移 $last$ 次了。

所以将第 $i$ 头奶牛放到他原有的位置上所用的次数为 $i-last$ 次。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p[110],ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i];
	}
	for(int i=2,last=1;i<=n;i++)
	{
		if(p[i-1]>p[i])
		{
			ans+=(i-last);
			last=i;
		}
	}
	cout<<ans;
	return 0;
}
``````

---

## 作者：Igunareo (赞：0)

# [P9959 [USACO19JAN] Sleepy Cow Sorting B ](https://www.luogu.com.cn/problem/P9959)题解
## 题意分析
此题题面的意思就是给定一个长度不超过 $100$ 的数列，每次如果数列不是单调递增的，从取出数列前端的数，重新插到数列中（因为 $1\le k\le n-1$，所以可以随便插在哪），求最小操作次数。
## 思路讲解
我们知道，已知一个单调上升序列，向其中插入多个不与数列中任何数重复的数，可以构成一新单调上升序列。

所以，从一个单调上升序列中取出多个数，剩余部分仍是单调上升序列。

故此，题目就变成了：从一个单调上升序列中取出几个数置于前端，问取出了几个数（插入倒推变成取出）。

因为从一个单调上升序列中取出多个数，剩余部分仍是单调上升序列。

所以除去前面取出的数部分，后面的是单调上升序列，倒过来看就是单调下降序列。

由此可知找到从后端开始的单调下降序列有多长，就可以知道取出了多少数，进而可知要插回去多少数，即取出多少数。

相信大家单调下降序列都会判吧。
## 注意点
一：输入数据无重复，$n$ 个数从 $1$ 到 $n$，所以不用加等于时的特判。

二：只有数列前端的才能移动，所以不能从中间找数重新插入。

三：取出的数可以随意插，所以无论如何都可以插成有序数列，因此取出后就不必考虑插在哪了。

## 代码奉上
```
#include<bits/stdc++.h>
using namespace std;
int x[105];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x[i];
	int summ=n-1;
	for(int i=n-1;i>=1;i--){
		if(x[i]<x[i+1])summ--;//计入长度 
		else break;//找到末端就退出 
	}
	cout<<summ;
	return 0;
}
```


---

## 作者：Addicted_Game (赞：0)

# [传送门](https://www.luogu.com.cn/problem/P9959)
## 题目大意
给定一个一个数组 $p$，每一次操作可以使排在第一的元素后移 $k$ 步，求最少此移动操作可以让 $p$ 单调递增。

## 思路
明显如果想让一个位置错误的数字达到正确的位置，就要将前几个数都后移，设上一个位置为 $i$，这一次的位置为 $j$，那么就要将 $[i,j-1]$ 内的数字全部向后移，那么所耗步数就是 $i - j$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[105];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int sum=0,la=1;//la即为j。
	for(int i=1;i<=n;i++){
		if(a[i]<a[i-1]){//位置错误。
			sum+=i-la;//移动。
			la=i;//标记为上一次的错误位置。
		}
	}
	cout<<sum;
	return 0;
}
```


---


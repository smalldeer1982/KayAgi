# [图论与代数结构 301] 最短树问题_1

## 题目描述


在离散数学课程的学习中，大家学习了最短树相关的知识，现在来检查一下大家的学习情况。

给定一张 $n$ 个点 $m$ 条边的带权连通无向图，点的编号从 $1$ 到 $n$，可能存在重边和自环。现在，请你求出这张图总边权和最小的支撑树（最短树）的边权之和。即，找到一颗支撑树，满足选用边的边权和最小，输出这个边权和。

## 说明/提示

**【样例解释】**

选择 $(1,3)$、$(2,3)$ 和 $(3,4)$ 这三条边构成一颗支撑树。

**【数据范围】**

对于所有数据，满足 $1\leq n \leq 2000$，$1 \leq m \leq 3000$，边权均是 $[0, {10}^9]$ 中的整数，保证输入的图合法且满足题目中的限制条件。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 3 1
1 2 2
2 3 0
3 4 3
1 4 8
```

### 输出

```
4```

# 题解

## 作者：szkzyc (赞：16)

芝士提示：此题需要用到图论的基本知识，若没有了解请先到更简单的题目学习后再来解决此题。

这道题是“最短树”的一道模板题，也被称作“最小生成树”。

而对于求解“最小生成树”问题，主要有两种通用的算法：Prim 算法（适合求解稠密图）与 kruskal 算法（适合求解稀疏图）。

虽然此题适合用 Kruskal 算法，不过 Prim 算法也是能做的。两者都是最小生成树中重要的知识点。

因此，我会给大家分别介绍这两种的原理与源代码，不过核心思想都是相同的——贪心。

首先，问题是要求在一个带权连通无向图中求出一颗最短树（最小生成树），使得这个树的权值和最小。让你输出这个最小值是多少。

首先，让我们来介绍 Prim 算法：

### Prim 算法求最小生成树：


![](https://cdn.luogu.com.cn/upload/image_hosting/fdo83vqs.png)
（本图片来源于网络，若侵权请私信我，核实立刻删除）

我们就拿上图举例（在上图中，用红线连接的边就是要舍去的边，黑线就是最终选择的边）。Prim 算法构造的方法是首先从起始点 $A$ 开始（Prim 算法遍历开始的起始点可以选择任意一点，**结果**不会发生变化。一般我们习惯从 $1$ 或 $A$ 号点开始），找到所有能与它连边的点后找到权值的最小值并相连。然后相连后再对被相连的那个点进行贪心连边（在本图中是点 $B$）......重复以上操作，当连边的次数正好等于点数减一的时候，终止遍历，结束算法。（易证明，当连边次数正好等于点数减一时，树的边权最小）

想要计算权值和也很简单，因为一旦连边后便不会再更改，所以在每一次更改后加上连边的权值即可。

那么算法已经基本讲解完毕，接下来上代码！（Prim 算法中我用的是链式前向星来存图，重点是讲解算法，我便不再细讲）

```cpp
#include<bits/stdc++.h> //万能头文件 
#define ll long long
#define INF INT_MAX  //INF表示无限，指一个极大值。INT_MAX是一个表示int范围内最大值的常量。 

using namespace std;
const int M = 3005;
const int N = 2005;
int n, m, tot, ans;
int head[N], dist[N], vis[N]; 
struct node{ //链式前向星存图 
	int to, next;
	int w;
}edge[M << 1]; //位运算，同等于M*2 
void addedge(int x, int y, int z){ //链式前向星的加边操作 
	tot++;
	edge[tot].to = y;
	edge[tot].w = z;
	edge[tot].next = head[x];
	head[x] = tot;
	return ;
}
void Prim(){ //Prim算法 
	for(int i = head[1]; i; i = edge[i].next){ //判段是否有重边 
		dist[edge[i].to] = min(dist[edge[i].to], edge[i].w); 
	}
	int u = 1; //u表示当前遍历到的点 
	for(int i = 1; i < n; i++){ //循环n-1次，也就是连n-1条边 
		int minn = INF; //先给最小值附一个极大的初值（我选择的是int的上限，2147483647，其实1e9便足矣） 
		vis[u] = true; //给这个点的访问标记标为真 
		for(int j = 1; j <= n; j++){ //遍历n个点找到权值最小的点 
			if(!vis[j] && dist[j] < minn){ //如果小于当前最小值 且没有被访问过 
				u = j; //记录下标 
				minn = dist[j]; //更新最小值 
			}
		}
		ans += minn; //答案加上这条边的边权 
		for(int k = head[u]; k; k = edge[k].next){ //链式前向星的遍历方式，找到点u所相连的全部点 
			int v = edge[k].to; 
			if(dist[v] > edge[k].w && !vis[v]){ //如果当前点所连的最小权值大于当前的权值且这个点没有被访问过 
				dist[v] = edge[k].w; //更新 
			}
		} 
	}
	return ;
}
void Init(){ //初始化 
	for(int i = 1; i <= n; i++){
		dist[i] = INF; //初始化一个极大值 
	} 
	dist[1] = 0; //但点1要标0 
	return ;
}
int main(){
    cin >> n >> m;
    while(m--){
    	int x, y, z;
    	cin >> x >> y >> z;
    	addedge(x, y, z); //由于是无向图，所以要存两遍 
    	addedge(y, x, z); //同上，x-->y 与 y-->x 
	}
	Init(); //初始化 
	Prim(); //Prim算法求解 
	cout << ans << endl; //输出答案 
	return 0;
} 
//B3603 by szkzyc
```

耗时 7 毫秒。


### Kruskal 算法求最小生成树

![](https://cdn.luogu.com.cn/upload/pic/28091.png)

（来源于网络，侵私删）

然后我们来介绍 Kruskal 算法。

Kruskal的方法十分明了，算法过程中要运用到 [并查集](https://www.luogu.com.cn/problem/P3367) 不知道的同学可以点进这个链接看一下相关的例题。

我个人认为这个算法比 Prim 算法更加容易懂一些，就是将所有图之间的边权排序，然后从小到大的一个一个连。

会不会你认为这样就完了？不，还要**判环**。因为要构造的是最小生成**树**，不能出现环。如果出现了怎么办呢？简单，舍去后继续找就行了，直到连成了总点数减一的点就停止。

边权排序从小取比较简单，但判环就需要用并查集算法来判了。假设对于点 $x$ 与 $y$，利用并查集查找这两个点的祖先是否相同。如果相同便有环，不相同则无环。

Kruskal 算法的基本原理也已经明了，上代码！

```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF INT_MAX
using namespace std;
const int N = 2005;
const int M = 3005;
int ans = 0, sum = 0;
int n, m;
int fa[N]; //用来存储这个点的父节点 
struct node{
	int from, to, value;
}edge[M << 1]; 
bool cmp(node x, node y){ //定义排序函数 
	return x.value < y.value;
}
int find(int x){ //并查集，找到x的根节点 
	if(fa[x] != x) return fa[x] = find(fa[x]);
	return x;
}
void Kruskal(){ //Kruskal 
	int tot = 0;
	sort(edge + 1, edge + 1 + m, cmp); //将边权进行排序 
	for(int i = 1; i <= m; i++){
		int ft = find(edge[i].to);
		int ff = find(edge[i].from); //分别找到这两个点的根节点 
		if(ft != ff){ //如果不相同证明相连不会有环 
			tot++; //计数器加一 
			fa[ft] = ff; //将这两个点合并 
			ans += edge[i].value; //答案加上这个点的值 
		}
		if(tot == n) break; //如果进行了n次合并，那么退出循环，已经构造出最小生成树了。 
	}
}
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) fa[i] = i; //最开始这个节点的父节点就是它自己 
    for(int i = 1; i <= m; i++){
    	cin >> edge[i].from >> edge[i].to >> edge[i].value; 
	} 
	Kruskal(); //进行Kruskal算法求解 
	cout << ans << endl; //输出答案 
	return 0;
}
//B3603 by szkzyc

```
耗时 3 毫秒。（在这道题中还是 Kruskal 算法有优势）

呼，终于讲完了，我们下次再见ヾ(￣▽￣)。Bye bye~~

---

## 作者：Nt_Tsumiki (赞：4)

### 题意
[传送门](https://www.luogu.com.cn/problem/B3603)

给你 $n$ 和 $m$ 以及 $m$ 个连接两个点的边的值，让你生成树，求最小生成树的边权和。
### 做法
题意简单明了，很明显最小生成树模板题，一般的最小生成树算法为 prim 和 Kruskal，本文则用 Kruskal 来解这道题。
### 浅谈 Kruskal
Kruskal 就是贪心算法的一种体现，所以有跟贪心一样的思路，所以也需要排序，也通常搭配 [并查集](https://www.luogu.com.cn/blog/natieyes/bing-zha-ji) 实现，是因为他需要靠并查集来完成贪心（即两个点是否直接或间接联系在一起），至于证明，和贪心一样，我这里就不多加赘述了（可见《深基》第十二章）。

如还有不懂可参考[there](https://www.luogu.com.cn/blog/Edolon/zui-xiao-sheng-cheng-shu-tan-xin-ji-yi)。
### Code
既然为模板题，那也就没什么好说的了，打上并查集，存图，再跑一遍 Kruskal，即可出答案，上代码（带注释解释）：
```cpp
//代码下方还有解释
#include <algorithm>
#include <iostream>

using namespace std;
int n,m,ans;
int f[100001];//并查集

struct Node{//点和边权
    int x,y,val;
}a[100001];

int find(int x) {//查
    if (f[x]==x) {
        return x;
    }
    return f[x]=find(f[x]);
}

bool cmp(Node M,Node N) {//sort 自定义规则函数
    return M.val<N.val;
}

int main() {
    cin>>n>>m;
    for (int i=1;i<=n;i++) {//初始化（别忘了）
        f[i]=i;
    }
    for (int i=1;i<=m;i++) {
        cin>>a[i].x>>a[i].y>>a[i].val;
    }
    sort(a+1,a+m+1,cmp);//排序
    for (int i=1;i<=m;i++) {
        int nx=find(a[i].x);//x 的祖先
        int ny=find(a[i].y);//y 的祖先
        if (nx!=ny) {//并
            f[nx]=ny;
            ans+=a[i].val;
            n--;
        }
        if (n==1) {//特判
            break;
        }
    }
    cout<<ans;
}
```
再来说一下代码中的 `n==1`，这个操作是因为，每并一次，$n$ 就减一，而 $n$ 条边最少有 $n-1$ 条边，所以到了 $1$ 就跳出。 

---

## 作者：Cloote (赞：2)

**前情提要**：`AC` 此题，你需要掌握并查集算法，`kruskal` 算法或者 `prim` 算法。

这道题可以简单概括为在图里面找一颗树，且这颗树的边权要最小。

首先我们要知道图和树的区别：图可能会有环（就是首尾相连），但是树一定不会有，并且树有个~~一点也不~~神奇之处，树的边数总比点数少一。

这里只简单的介绍一下 `kruskal` 算法。

`kruskal` 算法包含贪心的思想，每次都选出一条最小权值的边，并且与前面已选的边相连，如果连边后出现了环就舍去该条边，以此类推，直到连好边是个数比点数少一。

并查集则是用来判断是否有环的。存下所有点的父节点，假设现在已知有两点 `x`,`y` 中有一边，先找出它们各自的祖先（一直找父节点，直到找到一点不再有父节点）。如果祖先不相同就表示它们原本是不相连的，让其中任意一祖先的父节点为另外一个祖先，达到使 `x`,`y` 两点相同的目的。

代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
const int M=3e3+5; 
int n,m,fa[N],cnt,ans;
struct node{
	int x,y,w;
}edge[M];
bool cmp(node a,node b){
	return a.w<b.w;
}
int find(int x){
	if(fa[x]==x){
		return x;
	}
	return fa[x]=find(fa[x]);//一个小优化，节省下次找祖先的时间
}
void unionn(int x,int y){
	int fx=find(x);
	int fy=find(y);
	fa[fx]=fy;
	return;
}
void kruskal(){
	for(int i=1;i<=n;i++){//先假设每个点都没有父节点，即所有点都不互通
	    fa[i]=i;
	}
	sort(edge+1,edge+m+1,cmp);//边权排序
	for(int i=1;i<=m;i++){
		int x=edge[i].x;
		int y=edge[i].y;
		if(find(x)!=find(y)){//如果本不互通
		    unionn(x,y);
			ans+=edge[i].w;
			cnt++;
		}
		if(cnt==n-1){//已经满足建树的要求：边数等于点数减一
			return;
		}
	}
	return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
	    cin>>edge[i].x>>edge[i].y>>edge[i].w;
	}
	kruskal();
	cout<<ans;
	return 0;
}//完结撒草~
```


---

## 作者：endless_loop (赞：2)

最短树，又叫最小生成树，就是所选边权和最小的生成树，比较简单的算法是 kruskal 算法。

首先，对于一张无向图来说，最小生成树一定包含边权最小的那条边。

比如样例的这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/imlbvf2h.png)

一定包含边权为 $0$ 的那条边。

此时节点 $2,3$ 连在一起了，我们将他们合并，将节点 $2,3$ 看做一个节点，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gbq5kw7s.png)

此时 $1,3$ 间有两条边，我们当然选择边权小的那条，再进行合并。

我们先从小到大排序，从小的开始选，像刚才一样一直合并下去，得到的就是最小生成树了。

但假设我们有一条边连在已经合并完的两个节点中怎么办呢？

这提醒我们使用**并查集**。

然后我们算法的主体就出来了：我们从小到大排序，遍历每条边，当我们选择了一条边，同时也用并查集查询这条边连接的两个节点在不在同一个集合，如果不在就进行合并，最终时间复杂度 $\mathcal{O}(m\log m)$。

Code：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int fa[5010];
int n,m;
struct Edge{
	int u,v,value;
	bool operator < (const Edge rhs)const{
		return value<rhs.value;
	}
}edge[200000];
int find_root(int x){
	return x==fa[x]?x:fa[x]=find_root(fa[x]);
}
int main(){
	int sum=0;
	cin>>n>>m;
	for(int i=0;i<m;++i)
		cin>>edge[i].u>>edge[i].v>>edge[i].value;
	for(int i=0;i<=n;++i)
		fa[i]=i;
	sort(edge,edge+m);
	int cnt=n;
	for(int i=0;i<=m;++i){
		int a=find_root(edge[i].u),b=find_root(edge[i].v);
		if(a!=b){
			fa[a]=b;
			cnt--;
			sum+=edge[i].value;
		}
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：无咕_ (赞：1)

## 题解索引
1. **题目大意**
2. **Solution**
3. **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：41

------------

本题解使用 Kruskal 算法，不了解的可以 [戳这里](https://www.luogu.com.cn/blog/wugu-2333/wu-gu-bo-ke-suo-yin) ，寻找最小生成树有关知识。

## 题目大意
题面： [<传送门>](https://www.luogu.com.cn/problem/B3603)

题意：给一张 $n$ 个点 $m$ 条边的 **无向图** ，求这个图上最小生成树的权值和（并不知道题面中的“最小树”的说法是哪来的……）。

~~术语理解：最小生成树板子题。~~

## Solution

因为是稀疏图，选用 Kruskal 。

### Kruskal

#### 一、中心思想

------------

按边权排序，从大到小。

每条边都跑一遍（当然，如果当前已经有了 $n-1$ 条边那么就跳出）。

对于每条边，首先判断其连着的两个点与正在构成的最小生成树是否已经连通，如果两个都已经连通则跳过此边，否则使最小生成树连通此边。

------------

#### 二、代码实现

1. 排序部分交给 `sort` 即可，写个自定义函数 `cmp` 来自定义结构体排序方式。

```cpp
bool cmp(Edge a,Edge b){return a.w<b.w;}
```

边权是 **向小排序** ！

2. 链式前向星部分

因为 Kruskal 不需要存邻边，但需要存起始点，于是链式前向星改成：

```cpp
struct Edge{
    int from,to,w;
}edge[MAXM];
```

3. Kruskal 中的判断一条边两个端点是否 **都** 被最小生成树连通部分

可以把问题转化成两个元素是否在一个集合的问题，那么我们可以用并查集来实现。

```cpp
int findf(int u){return f[u]==u?u:f[u]=findf(f[u]);}
```

至于合并，我们直接手写（在 Kruskal 中手写），因为我们可能还要进行其它操作（这道题的特殊操作是求和）

4. Kruskal 部分（挺简单的，自己看看就会了）

```cpp
void kruskal(){
    sort(edge+1,edge+m+1,cmp);
    int num=0;
    for(int i=1;i<=m;i++){
        if(num==n-1)break;
        int from=edge[i].from,to=edge[i].to,w=edge[i].w;
        int from_father=findf(from),to_father=findf(to);
        if(from_father==to_father)continue;
        f[from_father]=to_father;
        ans+=w;
        num++;
    }
}
```

5. 建边部分（细节）

Q：为啥建单向边？题目中不是说建无向边吗？

A：由于 Kruskal 排序的问题，由于无向边在链式前向星中是以两条有向边的形式存在的，所以同一条边在 Kruskal 的排序中可能会同时排在前面（因为在链式前向星中无向边所化成的两条有向边的边权是相同的），这就导致了原本选 $n-1$ 条边，却选了好几条一样的边，是肯定错误的。

Q：写个去重函数不行吗？

A：这个问题我也想过，可我测试的时候发现结构体好像不能去重（可能我太弱了）。就算能去重，你想想，你前面刚重复加边，后面接着去重，这不是多此一举吗？

## AC code

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;
const int MAXM=6e4+9,MAXN=2e3+9;
struct Edge{
    int from,to,w;
}edge[MAXM];
int n,m;
int num_edge=0,f[MAXN];
void add_edge(int from,int to,int w){
    edge[++num_edge]=(Edge){from,to,w};
}long long ans=0;
bool cmp(Edge a,Edge b){return a.w<b.w;}
int findf(int u){return f[u]==u?u:f[u]=findf(f[u]);}
void kruskal(){
    sort(edge+1,edge+m+1,cmp);
    int num=0;
    for(int i=1;i<=m;i++){
        if(num==n-1)break;
        int from=edge[i].from,to=edge[i].to,w=edge[i].w;
        int from_father=findf(from),to_father=findf(to);
        if(from_father==to_father)continue;
        f[from_father]=to_father;
        ans+=w;
        num++;
    }
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)f[i]=i;
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d %d %d",&u,&v,&w);
        add_edge(u,v,w);
    }kruskal();
    printf("%lld",ans);
    return 0;
}
```

AC 记录[<传送门>](https://www.luogu.com.cn/record/54269237)

## 类似题型

[P1396 营救](https://www.luogu.com.cn/problem/P1396)

~~最小生成树学会了，来学[次小生成树](https://www.luogu.com.cn/blog/wugu-2333/ci-xiao-sheng-cheng-shu)~~

---

## 作者：Waaifu_D (赞：1)

## 题目简述

不知道这个最小树是哪里的说法......这道题就是让我们找最小生成树

## 思路简析

最小生成树，即 $n$ 个点，用 $n-1$ 条边连上它们（没有环），构成一个边权值总和最小的树。

在这篇题解中，我们使用较为简单的 Kruskal 算法来解这道题。

## 正题

### 前置知识

1.并查集。

2.树的一些性质。

3.贪心。

Kruskal 算法使用的是贪心的思想，在存入边信息的时候，我们用边权从小到大排序，优先连边权较小的边，具体过程如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/xmta5efq.png)

上述的问题都很简单，但是我们很容易想到在建树过程中出现的问题。
 
- 1.如何保证连边的两个端点不在一个联通块上？（树的定义不能出现环）

- 2.如何知道树已经建成？

我们一 一回答上面的问题

首先，确保连边的两个端点不在一个联通块上，我们可以使用并查集，一开始所有的点祖先都是自己，在连边的时候，我们把两个点并到一个集合里，如果在连边的时候，两个点已经在一个集合里就不再连边。

接下来如何知道树已经建成？我们回想一下树的性质，假如树有 $n$ 个点，边一定只有 $n-1$ 条，所以我们在建边的时候判断一下即可。 
 
## 具体实现

第一步，存所有的数据，为了方便，我们使用结构体来存输入的边。

```cpp
struct node
{
	int x,y,t;//x表示一个点，y表示另一个点，t表示连接这条边需要的价值（也就是权值）
}k[200005];
```



------------


```cpp
for(register int i=1; i<=m;i++)
{
	scanf("%d%d%d",&k[i].x,&k[i].y,&k[i].t);
}
```
接下来我们排序结构体，把权值最小的连边放在数组的前面。

这样可以保证生成树中的边权值总和一定是最小的。

```cpp
inline bool cmp(node a,node b)
{	
	return a.t<b.t;//从小到大排序
}


sort(k+1,k+m+1,cmp);//使用STL中的sort足矣
```

接下来是程序的主体，即建树的环节。

```cpp

inline int find(int x)//路径压缩并查集查找
{
	if(f[x]==x) return f[x]//如果祖先（父亲）是自己，说明祖先已经找到;
	return f[x]=find(f[x]);//在寻找祖先的时候顺便把现在查找到的点的父亲直接设成祖先（路径压缩）
}


	int now=0;//现在所建边的权值总数
	for(register int i=1; i<=m;i++)
	{
		if(n==1)//这里需要理解一下，当联通块的数量降为1的时候，我们就已经建好了树，直接输出退出即可（自己画个树试试，边数一定是节点数-1）
		{
			cout<<now;
			return 0;
		}
		int f1=find(k[i].x),f2=find(k[i].y);//看这俩节点是否连通
		if(f1!=f2) //如果不连通
		{
			f[f1]=f[f2];//让他俩连通
			now+=k[i].t;//权值++
			n--;//连通块--
		}
		else continue;
	}
```

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[200005];
inline int find(int x)
{
	if(f[x]==x) return f[x];
	return f[x]=find(f[x]);
}
struct node
{
	int x,y,t;
}k[200005];
inline bool cmp(node a,node b)
{
	return a.t<b.t;
}
int main()
{
	cin>>n>>m;
	for(register int i=1; i<=n;i++) f[i]=i;
	for(register int i=1; i<=m;i++)
	{
		scanf("%d%d%d",&k[i].x,&k[i].y,&k[i].t);
	}
	sort(k+1,k+m+1,cmp);
	int now=0;
	for(register int i=1; i<=m;i++)
	{
		if(n==1)
		{
			cout<<now;
			return 0;
		}
		int f1=find(k[i].x),f2=find(k[i].y);
		if(f1!=f2) 
		{
			f[f1]=f[f2];
			now+=k[i].t;
			n--;
		}
		else continue;
	}
	return 0;
}
```


---

## 作者：HYdroKomide (赞：0)

### 题意：
题中所谓“最短树”，通常被称为“最小生成树”，指在一张连通图中求出能够连接所有结点的最小边权之和，也就是使用最小的代价使这个图连通。

一般用两种算法 Kruskal 或者 Prim 来求最小生成树。

- Kruskal 算法的时间复杂度为 $O(E\log E)$（E 为图的边数），适合求解稀疏图（边的条数 E 远小于结点数 V 的平方）中的最小生成树。

- Prim 算法不加优化的时间复杂度为 $O(V^2)$（V 为图的顶点数），适合求解稠密图（边的条数 E 接近于结点数 V 的平方）中的最小生成树。

显然在本题中更适合使用 Kruskal 算法，在代码方面也是 Kruskal 相对简单。

### 思路：
首先简单讲解一下我们使用的 Kruskal 算法。

Kruskal 是一种基于并查集的贪心方法。

1. 将输入的边权进行排序。
2. 从小到大顺次连接这些边，将已经联通的结点放在同一个并查集当中。
3. 如果这一条边连接的顶点已经在这个并查集当中，说明这条边可以不连，便跳过这条边。
4. 当所有结点都进入并查集时，最小生成树算法完成，跳出循环。

--------------------分割线--------------------

题中说要开 `long long`，但是由于数据太水，所以不开也可以过。

### 程序如下：
```cpp
#include<cstdio>
#include<algorithm>//需要使用sort进行排序
using namespace std;
struct dy{int x,y,z;}a[3001];//存每条边的边权
int n,m,k,ans,father[2001];
bool cmp(dy a,dy b){return a.z<b.z;}//按照每条边的边权大小进行排序
int find(int x){//用来查询两个节点是否在同一个集中
    if(father[x]!=x)father[x]=find(father[x]);
    return father[x];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
    for(int i=1;i<=n;i++)father[i]=i;//并查集初始化
    sort(a+1,a+m+1,cmp);//将边权从小到大进行排序
    for(int i=1;i<=m;i++){
        int fx=find(a[i].x),fy=find(a[i].y);
        if(fx!=fy){//如果两个点不在同一个集中
            father[fy]=fx;//将它们合并至同一个集
            k++;//进入这个集的结点数增加
            ans+=a[i].z;//生成树的大小增加
        }
        if(k==n-1)break;//如果除源点外所有结点都已经进入并查集中，跳出循环
    }
    printf("%d\n",ans);
    return 0;
}
```
### THE END

---

## 作者：Aw顿顿 (赞：0)

此题数据范围 Kruskal 可以通过，因此只在此处讲解 Kruskal 算法，如需 Prim 算法的内容，移步 [【普及】最小生成树笔记](https://www.luogu.com.cn/blog/LinearExpectation/easy-MST-note)。

------

## 概念

最小生成树是无向图中的一个常见问题，描述如下：

给定一个连通无向图，可以删去一些边，问应该保留哪些边能使得图依然连通，并且边权和最小。

我们把这个生成出来的树（为什么是树？因为保留 $n-1$ 条边时最省，但凡多一条边，就会有一条边是多余的，他就不满足最小边权和了）称之为最小生成树（$\small\bm{Minimal\ Spanning\ Tree,MST}$。

## 思路引导

《算法竞赛从入门到进阶》中的一段话特别具有启发性：

> 图的两个基本元素是点和边，于此对应，有两种方法可以构造最小生成树 $T$。这两种算法都基于贪心法，因为 MST 问题满足贪心法的“最优性定理”，即全局最优包含局部最优。

两种算法是 $\rm\small Prim$ 和 $\small\rm Kruskal$ 算法。其中 $\rm\small Prim$ 算法基于这样一个思想：“最近的邻居（节点）一定在 MST 上。”，于此相对地，$\rm\small Kruskal$ 的基本思想是“最短的边一定在 MST 上”。

从这里我们会发现一个问题：两种截然不同的 MST 算法，得到的最小生成树一样嘛？说不准，因为 MST 在有些图（很多图）上是不唯一的，于是你会得出两个（甚至更多）不同的（但是总边权 $\sum w$ 相同的）答案。但是洛谷的例题就特别良心，只让你输出总边权，于是你可以选择你用得顺手的算法。

我们首先从比较简单的 Kruskal 讲吧。

## Kruskal 克鲁斯卡尔

我们要顺次选取边权最短的边，于是我们需要用一种较为朴素的存边方式，即“直接存边”。这个存边方式在普通 Bellman-Ford 中也有应用，可以去复习一下哦。

假设我们现在已经用 $\rm\small STL$ 中的 $\rm\small sort$ 把一共的 $m$ 条边全部都排序好了。现在我们需要加入第一条边，然后加入第二条边，然后加入第三条边，然后加入……等等，这么加下去不是所有边又加回来了吗？！

当然不行，我们只要加入有用的边。什么样的边是没有的呢？这里给出一个结论：会形成圈的边。因为如果形成了一个圈，那么你连上的这个节点就必然已经是连通的，这条边没有起到作用，我们应该要跳过他，然后再判断下一条边。

那我们应该怎么判断是否形成环呢？答案是并查集。“并查集是$\rm\small Kruskal$ 算法的绝配”这句话不是白说的，我们只要每次加入边的时候（假设是一条 $u$ 和 $v$ 之间的边），我们只需要把并查集中的 $v$ 指向 $u$ 的根节点，并且进行路径压缩即可，这样可以使得整个集合的编号是统一的，也避免了一棵树退化成一条链。

只要我们发现，$v$ 的祖先已经是 $u$ 的祖先了，也就是说 $u$ 和 $v$ 是**连通的**，我们就可以不要这条边——他是无用的。“这其实是发现了一个**圈**，并查集的作用就体现在这里。”

直到经过了所有的 $m$ 条边，就可以结束了，下面是代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 2000005
using namespace std;
int fa[5005],n,m;
struct edge{
	int u,v,w;
}e[MAXN];
bool cmp(edge x,edge y){
	return x.w<y.w;
}int find(int k){//查询祖先 
    if(fa[k]==k)return k;
    return fa[k]=find(fa[k]);
}int kruskal(){
	int s=0;
	for(int i=1;i<=n;i++)fa[i]=i;//初始化并查集 
	sort(e,e+m,cmp);
	for(int i=0;i<m;i++){
		int u=find(e[i].u);
		int v=find(e[i].v);
		if(u==v)continue;//如果已经连通，就跳过
		fa[v]=u;s+=e[i].w;//加入集合，答案累计 
	}return s;
}signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=0;i<m;i++){
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		e[i].u=x;e[i].v=y;e[i].w=z;
		e[i].u=y;e[i].v=x;e[i].w=z;
	}printf("%lld",kruskal());
	return 0;
} 
```

他的复杂度包含这几个部分：对边进行排序 $O(m\log m)$，并查集与遍历所有边 $O(m)$，在渐进意义上是 $O(m\log m)$，会发现在稠密图上他发挥地不会那么好，确实，编码简单的算法往往有着复杂度不尽理想的问题，面对数据范围比较大的题目，我们需要更优（却更难）的算法来解决。

---


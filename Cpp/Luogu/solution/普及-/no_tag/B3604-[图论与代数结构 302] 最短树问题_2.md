# [图论与代数结构 302] 最短树问题_2

## 题目描述

在离散数学课程的学习中，大家学习了最短树相关的知识，现在来检查一下大家的学习情况。

给定一张 $n$ 个点 $m$ 条边的带权连通无向图，点的编号从 $1$ 到 $n$，可能存在重边和自环。现在，请你求出这张图总边权和最小的支撑树（最短树）的边权之和。即，找到一颗支撑树，满足选用边的边权和最小，输出这个边权和。

## 说明/提示

对于所有数据，满足 $1\leq n \leq 100000$，$1 \leq m \leq 300000$，边权均是 $[0, {10}^9]$ 中的整数，保证输入的图合法且满足题目中的限制条件。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 3 1
1 2 2
2 3 0
3 4 3
1 4 8
```

### 输出

```
4```

# 题解

## 作者：Leonid (赞：10)

# B3604 [图论与代数结构 302] 最短树问题_2

这道题是一道裸的求**最小生成树**，难度普及—。

算法：**Kruskal**

**Kruskal** 是一种贪心求最小生成树的算法，~~非常de好用~~。

值得注意的是：$1 \le n \le 100000,1 \le m \le 300000$ ,边权均是 $[0,10^9]$ 中的整数。所以我们需要用到 long long 类型存储答案。

那么这道题就很轻松的通过啦。

 _**My Code：**_ 

```cpp
#include<cstdio>
#include<algorithm> //sort头文件

using namespace std;

#define int long long //注意long long，我在这里被卡了2次

int n,m,fa[300005],ans;
struct node{
	int x,y,z;
}h[300005]; //结构体存图

bool operator < (node x,node y){
	return x.z<y.z;
} //重载运算符，跟手写一个cmp没什么区别

int get(int x){
	if(x==fa[x])return x;
	return fa[x]=get(fa[x]);
} //并查集

void Kruskal(){
	sort(h+1,h+m+1);
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++){
		int x=get(h[i].x),y=get(h[i].y);
		if(x==y)continue;
		fa[x]=y;
		ans+=h[i].z;
	}
} //贪心法求最小生成树

signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%lld %lld %lld",&h[i].x,&h[i].y,&h[i].z); //存图
	Kruskal();
	printf("%lld",ans);
	return 0; //完美结束qwq
}
```

蒟蒻的第一篇题解，望管理员大大通过。

---

## 作者：无咕_ (赞：4)

## 题解索引
1. **题目大意**
2. **Solution**
3. **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：41

------------

此题为 [B3603](https://www.luogu.com.cn/problem/B3601) 的加强版

本题解使用 Kruskal 算法，不了解的可以 [戳这里](https://www.luogu.com.cn/blog/wugu-2333/wu-gu-bo-ke-suo-yin) ，寻找最小生成树有关知识。

## 题目大意
题面： [<传送门>](https://www.luogu.com.cn/problem/B3604)

题意：给一张 $n$ 个点 $m$ 条边的 **无向图** ，求这个图上最小生成树的权值和（并不知道题面中的“最小树”的说法是哪来的……）。

~~术语理解：最小生成树板子题。~~

与弱化版不同，这个题的数据范围从 $1\le n\le 2\times 10^3,1\le m\le 3\times 10^3$ 变成了 $1\le n\le 10^5,1\le m\le 3\times 10^5$ 

不过问题不大，我们 Kruskal 针对的是所有稀疏图，像这种数据范围还是能轻松过去的

## Solution

### Kruskal

#### 一、中心思想

------------

按边权排序，从大到小。

每条边都跑一遍（当然，如果当前已经有了 $n-1$ 条边那么就跳出）。

对于每条边，首先判断其连着的两个点与正在构成的最小生成树是否已经连通，如果两个都已经连通则跳过此边，否则使最小生成树连通此边。

------------

#### 二、代码实现

1. 排序部分交给 `sort` 即可，写个自定义函数 `cmp` 来自定义结构体排序方式。

```cpp
bool cmp(Edge a,Edge b){return a.w<b.w;}
```

边权是 **向小排序** ！

2. 链式前向星部分

因为 Kruskal 不需要存邻边，但需要存起始点，于是链式前向星改成：

```cpp
struct Edge{
    int from,to,w;
}edge[MAXM];
```

3. Kruskal 中的判断一条边两个端点是否 **都** 被最小生成树连通部分

可以把问题转化成两个元素是否在一个集合的问题，那么我们可以用并查集来实现。

```cpp
int findf(int u){return f[u]==u?u:f[u]=findf(f[u]);}
```

至于合并，我们直接手写（在 Kruskal 中手写），因为我们可能还要进行其它操作（这道题的特殊操作是求和）

4. Kruskal 部分（挺简单的，自己看看就会了）

```cpp
void kruskal(){
    sort(edge+1,edge+m+1,cmp);
    int num=0;
    for(int i=1;i<=m;i++){
        if(num==n-1)break;
        int from=edge[i].from,to=edge[i].to,w=edge[i].w;
        int from_father=findf(from),to_father=findf(to);
        if(from_father==to_father)continue;
        f[from_father]=to_father;
        ans+=w;
        num++;
    }
}
```

5. 建边部分（细节）

Q：为啥建单向边？题目中不是说建无向边吗？

A：由于 Kruskal 排序的问题，由于无向边在链式前向星中是以两条有向边的形式存在的，所以同一条边在 Kruskal 的排序中可能会同时排在前面（因为在链式前向星中无向边所化成的两条有向边的边权是相同的），这就导致了原本选 $n-1$ 条边，却选了好几条一样的边，是肯定错误的。

Q：写个去重函数不行吗？

A：这个问题我也想过，可我测试的时候发现结构体好像不能去重（可能我太弱了）。就算能去重，你想想，你前面刚重复加边，后面接着去重，这不是多此一举吗？

## AC code

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;
const int MAXM=6e5+9,MAXN=2e5+9;
struct Edge{
    int from,to,w;
}edge[MAXM];
int n,m;
int num_edge=0,f[MAXN];
void add_edge(int from,int to,int w){
	edge[++num_edge]=(Edge){from,to,w};
}long long ans=0;
bool cmp(Edge a,Edge b){return a.w<b.w;}
int findf(int u){return f[u]==u?u:f[u]=findf(f[u]);}
void kruskal(){
    sort(edge+1,edge+m+1,cmp);
    int num=0;
    for(int i=1;i<=m;i++){
        if(num==n-1)break;
        int from=edge[i].from,to=edge[i].to,w=edge[i].w;
        int from_father=findf(from),to_father=findf(to);
        if(from_father==to_father)continue;
        f[from_father]=to_father;
        ans+=w;
        num++;
    }
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d %d %d",&u,&v,&w);
		add_edge(u,v,w);
	}kruskal();
	printf("%lld",ans);
	return 0;
}
```

AC 记录[<传送门>](https://www.luogu.com.cn/record/54278201)

## 类似题型

[P1396 营救](https://www.luogu.com.cn/problem/P1396)

~~最小生成树学会了，来学[次小生成树](https://www.luogu.com.cn/blog/wugu-2333/ci-xiao-sheng-cheng-shu)~~

---

## 作者：szkzyc (赞：2)

此题其实与“最短树问题_1” 几乎一模一样。（除了数据范围）

数据范围比较庞大：$1≤n≤100000$，$1≤m≤300000$

而面对这么庞大的数据，当然是要用速度较快的 Kruskal 算法了。

### Kruskal 算法求最小生成树

![](https://cdn.luogu.com.cn/upload/pic/28091.png)

（来源于网络，侵私删）

我们来介绍一下 Kruskal 算法。

Kruskal的方法十分明了，算法过程中要运用到 [并查集](https://www.luogu.com.cn/problem/P3367) 不知道的同学可以点进这个链接看一下相关的例题。

我个人认为这个算法比 Prim 算法更加容易懂一些，就是将所有图之间的边权排序，然后从小到大的一个一个连。

会不会你认为这样就完了？不，还要**判环**。因为要构造的是最小生成**树**，不能出现环。如果出现了怎么办呢？简单，舍去后继续找就行了，直到连成了总点数减一的点就停止。

边权排序从小取比较简单，但判环就需要用并查集算法来判了。假设对于点 $x$ 与点 $y$，利用并查集查找这两个点的祖先是否相同。如果相同便有环，不相同则无环。

Kruskal 算法的基本原理也已经明了，上代码！

```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF INT_MAX
using namespace std;
const int N = 100005;
const int M = 300005;
int ans = 0, sum = 0;
int n, m;
int fa[N]; //用来存储这个点的父节点 
struct node{
	int from, to, value;
}edge[M << 1]; 
bool cmp(node x, node y){ //定义排序函数 
	return x.value < y.value;
}
int find(int x){ //并查集，找到x的根节点 
	if(fa[x] != x) return fa[x] = find(fa[x]);
	return x;
}
void Kruskal(){ //Kruskal 
	int tot = 0;
	sort(edge + 1, edge + 1 + m, cmp); //将边权进行排序 
	for(int i = 1; i <= m; i++){
		int ft = find(edge[i].to);
		int ff = find(edge[i].from); //分别找到这两个点的根节点 
		if(ft != ff){ //如果不相同证明相连不会有环 
			tot++; //计数器加一 
			fa[ft] = ff; //将这两个点合并 
			ans += edge[i].value; //答案加上这个点的值 
		}
		if(tot == n) break; //如果进行了n次合并，那么退出循环，已经构造出最小生成树了。 
	}
}
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) fa[i] = i; //最开始这个节点的父节点就是它自己 
    for(int i = 1; i <= m; i++){
    	cin >> edge[i].from >> edge[i].to >> edge[i].value; 
	} 
	Kruskal(); //进行Kruskal算法求解 
	cout << ans << endl; //输出答案 
	return 0;
}
//B3604 by szkzyc

```

---

## 作者：HYdroKomide (赞：1)

本体与 B3603 题面相同，只是题目数据不同。~~但这并不会影响我们使用上一题的代码解决这个问题（因为数据还是太水）。~~

### 题意：
题目要求出带权无向图中的最小生成树。

最小生成树一般使用 Kruskal 或者 Prim 这两种算法来求解。Kruskal 的时间复杂度为 $O(m \log m)$，Prim 的时间复杂度一般为 $O(n^2)$。对于此题的数据范围 $1≤n≤100000$，$1≤m≤300000$ 显然使用 Kruskal 更快。

### 思路:
1. 直接使用朴素的 Kruskal 即可，无需任何优化。
2. 由于数据范围较大，所以需要开 long long。

对于 Kruskal 算法较为详细的讲解可以参见我的[这篇题解](https://www.luogu.com.cn/blog/Kevin-FOS-Blog/solution-b3603)

### 程序如下：
```cpp
#include<cstdio>
#include<algorithm>//需要使用 sort 排序
using namespace std;
struct node{long long x,y,z;}a[300001];//用来存放每条边的起点x，终点y以及边权z
long long n,m,k,ans,father[100001];
bool cmp(node a,node b){return a.z<b.z;}
long long find(long long x){//使用并查集查询结点是否已经加入生成树
    if(father[x]!=x)father[x]=find(father[x]);
    return father[x];
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(long long i=1;i<=m;i++)scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].z);
    for(long long i=1;i<=n;i++)father[i]=i;
    sort(a+1,a+m+1,cmp);//将边权从小到大排序
    for(long long i=1;i<=m;i++){
        long long fx=find(a[i].x),fy=find(a[i].y);
        if(fx!=fy){//如果x的祖先不等于y的祖先，说明y点没有入队，将其入队
            father[fy]=fx;
            k++;
            ans+=a[i].z;
        }
        if(k==n-1)break;//当所有结点都入队后，结束循环
    }
    printf("%lld\n",ans);//由于题目已经保证输入合法，所以我们无需判断是否连通
    return 0;
}
```

### THE END

---

## 作者：DWT8125 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3604)

这道题就是求最小生成树（模板题），本题解使用的是 **Kruskal** 算法，[关于 Kruskal 算法](http://data.biancheng.net/view/41.html)。

## 思路
### 1. 预先处理：排序
对于 $u$、$v$ 和 $w$，我们需要一个结构体来存储这些信息：

```cpp
struct bi{
	ll u,v,w;
}a[300001];
```

然后使用 STL 中的 ```sort(a+1,a+n+1，cmp);``` 函数进行排序：

```cpp
//……
#include<algorithm>//使用sort时要加
using namespace std; //这也要加上
//……
bool cmp(const bi &a,const bi &b){return a.w<b.w;}
//cmp比较函数需要手写，边权小的排前面 
int main(){
	//……
	sort(a+1,a+m+1,cmp);
	//……
	return 0;
}
```

### 2. 连接边
题目要求：
>满足选用边的边权和最小

所以，$n$ 个点只需要连接 $n-1$ 条边即可，而且**不能造成重边和自环**的现象，每次把两个**处于不同集合**的点连起来。

Q：如何在 $1 \leq n \leq 10^5$ 的数据量下**快速判断**两个点是否处于同一集合？

A：使用[并查集](https://zhuanlan.zhihu.com/p/93647900)！

核心代码：

```cpp
for(int i=1;i<=n;i++) fl[i]=i;
//每个节点一开始都是自己的帮主
for(int i=1;i<=m;i++){		
	fa=find(a[i].u); fb=find(a[i].v); //找“帮主” 
	if(fa!=fb){ 
		fl[fa]=fb;
		s++; cnt+=a[i].w; //统计路径总数和边权总和 
	}
	else continue; //属于同一集合的无需再连边 
	if(s==n-1) break; //连通n-1条边，结束 
}
```

完结~

---

## 作者：Aw顿顿 (赞：1)

对于朴素的 Prim 和 Kruskal 这道题目都会被卡，因此我们考虑优先队列优化的 Prim 算法。本文只讲解 Prim 算法，如需 Kruskal 算法内容，请访问 [【普及】最小生成树笔记](https://www.luogu.com.cn/blog/LinearExpectation/easy-MST-note)。

## 概念

最小生成树是无向图中的一个常见问题，描述如下：

给定一个连通无向图，可以删去一些边，问应该保留哪些边能使得图依然连通，并且边权和最小。

我们把这个生成出来的树（为什么是树？因为保留 $n-1$ 条边时最省，但凡多一条边，就会有一条边是多余的，他就不满足最小边权和了）称之为最小生成树（$\small\bm{Minimal\ Spanning\ Tree,MST}$。

## 思路引导

《算法竞赛从入门到进阶》中的一段话特别具有启发性：

> 图的两个基本元素是点和边，于此对应，有两种方法可以构造最小生成树 $T$。这两种算法都基于贪心法，因为 MST 问题满足贪心法的“最优性定理”，即全局最优包含局部最优。

两种算法是 $\rm\small Prim$ 和 $\small\rm Kruskal$ 算法。其中 $\rm\small Prim$ 算法基于这样一个思想：“最近的邻居（节点）一定在 MST 上。”，于此相对地，$\rm\small Kruskal$ 的基本思想是“最短的边一定在 MST 上”。

从这里我们会发现一个问题：两种截然不同的 MST 算法，得到的最小生成树一样嘛？说不准，因为 MST 在有些图（很多图）上是不唯一的，于是你会得出两个（甚至更多）不同的（但是总边权 $\sum w$ 相同的）答案。但是洛谷的例题就特别良心，只让你输出总边权，于是你可以选择你用得顺手的算法。

## Prim 普利姆

Prim 算法和 Dijkstra 很像，首先任意选取一个点作为根（不如就用 $1$ 节点吧），然后依次寻找距离他最近的点（就是 Dij 中的 $d$ 数组），我们只要不停地寻找这样的点加入集合就行。

引用 $\rm\small N\color{red}emlit$ 的一句话：

> $\rm\small Prim$ 算法之所以是正确的，主要基于一个判断：对于任意一个顶点 $u$，连接到该顶点的所有边中的一条最短边 $u,u_j$ 必然属于最小生成树（即任意一个属于最小生成树的连通子图，从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树）。

对于寻找最小的 $d_i$ 这一步骤可以优化，使得复杂度为 $O(m\log n)$。

我们来具体研究一下 Prim 算法。首先存在两个集合 $S,T$，其中集合 $T$ 在初始情况下是点集全集，而 $S$ 则应该是空集。我们用 $S$ 来表示一个加入最小生成树的点集。

我们判断一个点是否能进入点集的标准是它和整个生成树相连的代价是否最小。它到所有生成树中的点都会有一条最短路，这些最短路中最短的那一条就是它到这个生成树的代价。

每当我们加入了一个点，我们就可以把与这个点相连的所有点到生成树的代价进行一个更新（类似于松弛），如果这一次更新使得它的距离缩小了，这个点就可以放在准备处理的栏目之中。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int>pr;
int k,n,m,cnt,sum;
int head[100005],dis[100005];
bool vis[100005];
struct Edge{
    int v,w,next;
}e[600005];
void add(int u,int v,int w){//邻接表加边 
    e[++k].v=v;e[k].w=w;
    e[k].next=head[u];
    head[u]=k;
}priority_queue<pr,vector<pr>,greater<pr> >q;
void Prim(){
    dis[1]=0;
    q.push(make_pair(0,1));
    while(!q.empty()&&cnt<n){
        int d=q.top().first;//当前点进入点集的代价 
		int u=q.top().second;//当前点的编号 
        q.pop();
        if(vis[u])continue;
        cnt++;sum+=d;vis[u]=1;//累加与标记 
        for(int i=head[u];i!=-1;i=e[i].next)
            if(e[i].w<dis[e[i].v]){
            	dis[e[i].v]=e[i].w;//如果松弛有效，加入待处理队列 
				q.push(make_pair(dis[e[i].v],e[i].v));
			}   
    }
}signed main(){
    memset(dis,127,sizeof(dis));
    memset(head,-1,sizeof(head));
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++){
    	int u,v,w;
        scanf("%lld%lld%lld",&u,&v,&w);
        add(u,v,w);add(v,u,w);
    }Prim();
    if (cnt==n)printf("%lld\n",sum);
    else puts("orz");
    return 0;
}
```


---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:B3604](https://www.luogu.com.cn/problem/B3604)

* **【解题思路】**

这题如果用普通Prim可以卡到 $\operatorname O(n^2)$，会T，所以我用了 $\operatorname O(m\log_2 m)$ 的Kruskal。

### Kruskal算法

这个算法个人认为很好记，至少比Prim好记。

算法流程：

1. 首先把所有的边按照边权排序（在这题从小到大排），然后从第一条边开始选取。

2. 为了不形成环，每选一条边就把起点和终点标为一组（用并查集实现）。

3. 选取到一条边时，如果起点与终点是一组，就跳过这条边。

4. 最后，当选取到 $n-1$（$n$ 为点数）边时，说明树已经构建完成，所有的点都已经划为一组，算法结束。

* **为什么这是正确的？**

以下内容引用自Nemlit的[题解](https://www.luogu.com.cn/blog/tbr-blog/solution-p3366)。

如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树。

所以不难发现，当最小生成树被拆分成彼此独立的若干个连通分量的时候，所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树。

* **【代码实现】**

```cpp
#include <algorithm>
#include <iostream>

using namespace std;

struct edge
{
	int from,to;
	long long val;
	bool operator<(edge that)
	{
		return val<that.val;
	}
};

int ust_root(int father[],int node)
{
	while(father[node]!=node)
		node=father[node]=father[father[node]];
	return node;
}

int main(int argc,char *argv[],char *envp[])
{
    ios::sync_with_stdio(false);
    cin.tie(0);
	int cntnode,cntedge;
	cin>>cntnode>>cntedge;
	int father[cntnode+1];
	for(int i=1;i<=cntnode;i++)
		father[i]=i;
	edge edges[cntedge];
	for(auto& tmp:edges)
		cin>>tmp.from>>tmp.to>>tmp.val;
	sort(edges,edges+cntedge);
	long long picked=0,sum=0;
    for(int i=0;picked<cntnode-1;i++)
		if(ust_root(father,edges[i].from)!=ust_root(father,edges[i].to))
		{
			father[ust_root(father,edges[i].to)]=ust_root(father,edges[i].from);
			sum+=edges[i].val;
			picked++;
		}
	cout<<sum;
 	return 0;
}
```

---


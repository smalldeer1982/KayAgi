# 【模板】双端队列 1

## 题目背景

Aya 衷心祝愿大家不再因为 `std::deque` 重蹈覆辙。

## 题目描述

请你实现 $m$ 个双端队列，支持如下的 $q$ 次操作：

- `push_back(a,x)`：在第 $a$ 个双端队列中从尾部插入一个元素 $x$；
- `pop_back(a)`：在第 $a$ 个双端队列中从尾部弹出一个元素。
- `push_front(a,x)`：在第 $a$ 个双端队列中从头部插入一个元素 $x$；
- `pop_front(a)`：在第 $a$ 个双端队列中从头部弹出一个元素。
- `size(a)`：查询第 $a$ 个双端队列的元素个数；
- `front(a)`：查询第 $a$ 个双端队列的队首元素；
- `back(a)`：查询第 $a$ 个双端队列的队尾元素；

对于 `pop_back`，`pop_front`，`front` 和 `back` 操作，若当前双端队列为空则不进行，直接跳过该次操作。

## 说明/提示

**【数据范围】**

| 子任务 | $m \leq$ | $q \leq$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $10$ | $10$ |
| $2$ | $2000$ | $2000$ | $20$ |
| $3$ | $10^5$ | $10^5$ | $30$ |
| $4$ | $10^6$ | $10^6$ | $40$ |

对于所有数据，$1 \leq m,q \leq 10^6$，$1 \leq x \leq 10^9$。

## 样例 #1

### 输入

```
10
pop_back 2
push_back 1 1
push_front 1 3
push_front 2 2
push_front 2 3
pop_back 1
size 1
push_back 2 3
back 1
front 1```

### 输出

```
1
3
3
```

# 题解

## 作者：chen_zhe (赞：60)

双端队列是一种可以在队首和队尾插入或者弹出的一种数据结构。在 C++ 的 STL 中提供了 `std::deque` 这一容器可以维护一个双端队列。其运用方式如下：

| 用法 | 含义 |
| :-----------: | :-----------: |
| `q.push_back(x)` | 在双端队列末尾插入元素 $x$ |
| `q.pop_back()` | 在双端队列末尾弹出元素 |
| `q.push_front(x)` | 在双端队列头部插入元素 $x$ |
| `q.pop_front()` | 在双端队列开头弹出元素 |
| `q.size()` | 查询双端队列元素个数 |
| `q.front()` | 返回双端队列队首 |
| `q.back()` | 返回双端队列队尾 |

根据这一容器我们当然可以快速地实现本题，但是 `std::deque` 的实现是很慢的，有着很大的空间常数。如果直接开 `std::deque <int> q[1000050]`，其将占据 650 MB 左右的内存，这将直接导致 MLE，而且在本题的输入规模与 `std::deque` 的效率下，哪怕给予足够多内存空间也将 TLE。根据 [cppreference](https://en.cppreference.com/w/cpp/container/deque) 的说明，`std::deque` 的实现会预先分配固定大小的数组，这是内存占用的大头。此外 deque 存储元素也要用较大的内存，一个只包含一个元素的 `std::deque` 也将会占用其变量类型 $16$ 倍或者 $4096$ 字节的内存。这也就会造成 `std::deque` 的极大的空间占用。此外，由于 `std::queue()` 和 `std::stack()` 也是依赖于 `std::deque` 的，因此在使用它们的时候也应当要注意。

如果不要求支持随机访问队列下标，那么 `std::deque` 可以用 `std::list` 代替，也就是本题了。**需要注意 std::list 的连续访问效率较低。**

---

## 作者：pulsar_ (赞：11)

考虑到 `std::list`（及类似链表实现）的时间常数较大，`std::deque` 的静态空间较大，我决定自己实现一个双端队列，于是就有了这篇题解。

[提交记录（卡常版，可读性可能较弱，模板见文章末尾）](https://www.luogu.com.cn/record/171321530)

实现的核心是循环队列。

循环队列用一个数组（一块连续内存）存储数据，设数组大小为 $size$，访问时，将下标 $i$ 对 $size$ 取模。不难发现，无论如何在前后增删元素，只要元素数量不超过数组大小，都不会出现任何问题（~~你别告诉我下标爆 int 了~~）。

为了减小常数，这里使用的是大小为 $2^n$ 的循环队列，因为当 $x=2^n$ 时， `(v%x+x)%x` 与 `v&(x-1)` 等价，而后者很明显常数更小。

但是我们不能固定循环队列的大小，大小过大会爆内存，大小过小会不够，我们可以考虑动态扩容和缩容。

具体来说，当大小不够时，新开一个两倍大小的数组，把数据复制进去，当大小过大（空间使用率不到四分之一）时，新开一个二分之一大小的数组，把数据复制进去。这样在两端插入和删除的时间复杂度是均摊 $O(1)$ 的。

空间上，在最坏情况，数组部分的空间占用可保证不超过两倍的最大元素数量，且不超过四倍的当前元素数量。

因为内存空间是连续的，我们可以得到和 `std::deque` 相同的 $O(1)$ 的~~似乎没什么用的~~随机访问。

其余操作除 `clear()` 是小常数 $O(n)$ 外均为 $O(1)$。

性能测试结果如下：

单位均为 μs（千分之一毫秒），开启 O2 优化，随机访问部分可能受随机数生成影响较大。

|队列大小|1|10|100|1000|10000|100000|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|队列数量|100000|10000|1000|100|10|1|
|插入删除 模板|25|1036|419|190|198|356|
|插入删除 std::deque|13079|1828|316|209|252|242|
|插入删除 std::list|17116|8431|10797|10085|8913|8800|
|迭代 模板|33|35|91|50|48|48|
|迭代 std::deque|87|37|45|52|41|50|
|迭代 std::list|55|43|139|132|220|229|
|随机访问 模板|1681|1778|1711|1707|1723|1724|
|随机访问 std::deque|1700|1792|1709|1876|1720|1706|

模板及性能测试代码见[剪贴板](https://www.luogu.com.cn/paste/s53ej6r7)。

---


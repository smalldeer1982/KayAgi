# 小清新数据结构题

## 题目描述

给定 $n$ 条数据，第 $i$ 条数据有 $s_i$ 个数，依次记为 $a_{i, 1}, a_{i, 2}, \dots a_{i, s_i}$。

现在有 $q$ 次询问，每次询问第 $x$ 条数据的第 $y$ 个数，即 $a_{x,y}$ 是多少。

为了避免输出过大，你只需要输出所有询问的答案的**按位异或**和。

按位异或指的是 C++ 中的「^」运算符。你可以参考「说明/提示」中的代码求出若干个数的按位异或和。

## 说明/提示

### 样例 1 解释

第一次询问的结果为 $5$，第二次询问的结果为 $2$。他们做按位异或的结果为 $7$。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, q, s_i \leq 3 \times 10^6$，$0 \leq a_i \lt 2^{32}$，$1 \leq x \leq n$，$1 \leq y \leq s_x$，且 $\sum\limits_{i = 1}^n s_i \leq 5 \times 10^6$，即 $s_1 + s_2 + \dots + s_n \leq 5 \times 10^6$。

### 提示

对于使用 C++ 的选手，你可以用如下的函数返回若干个数的按位异或和。
```cpp
#include <vector>
unsigned int getXorSum(const std::vector<unsigned int>& rec) {
  unsigned ret = 0;
  for (int i = 0; i < rec.size(); ++i) ret ^= rec[i];
  return ret;
} // 将需要求按位异或和的数放在 vector 中传参。
```

请注意大量数据读入对程序效率造成的影响。

## 样例 #1

### 输入

```
2 2
2 1 2
3 4 5 6
2 2
1 2```

### 输出

```
7```

# 题解

## 作者：kimidonatsu (赞：7)

# B3665 题解

## 题意简述

其实说起来也很简单，就是给 `n` 条数据和 `q` 次询问，需要存储下数据以备询问，最后在查询时将答案统计在 `ans` 里（使用按位异或和，即 `^`）。

## 题目分析

这道题的考点在于数据的存储，很多同学可能和我一样，写了一份二维数组的代码，但是交上去却爆了个 0。

那么我们可以来到数据规模部分，我们不难发现，题目给的数据是很大的，需要使用 `unsigned long long`，但是用它开数组一定会爆空间，也就是俗称的 `MLE`。

那么有什么办法呢？在 C++ 的 STL 中有一个序列式容器，称为 `vector`。那么什么是 `vector` 呢？

> `std::vector` 是 STL 提供的 **内存连续的、可变长度** 的数组（亦称列表）数据结构。能够提供**线性复杂度**的插入和删除，以及**常数复杂度**的随机访问。	—— OI WIKI

我们知道我们很有很多时候不能提前开好足够大空间的长数组（e.g. 就像本题），就算控制下来了，单份数据可能还是会非常大（e.g. 还是本题）。那么这个时候，我们就可以使用 `vector` 来把内存控制在空间范围下。而且 `vector` 还支持 **动态扩容** ，在内存紧张的时候就可以派上用场了（e.g. 仍然是本题……）

在这道题我们还会运用到在 C++11 中支持的 `vector` 列表初始化（详见 [cppreference](https://zh.cppreference.com/w/cpp/language/list_initialization)）。

### `vector` 使用方法

在这里先讲一些基础的用法：

* `push_back()` 成员函数在 `vector` 的末尾插入值，如果有必要会扩展 `vector` 的大小。

* `size()` 函数显示 `vector` 的大小。

* `begin()` 函数返回一个指向 `vector` 开头的迭代器。

* `end()` 函数返回一个指向 `vector` 末尾的迭代器。

那么我们就可以愉快地写出代码了~

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef unsigned long long ull;
const ull N = 4e6;

ull n, q, s, x, y, ans;
vector<ull> a[N];

int main() {
	scanf("%llu %llu", &n, &q);
	
	/* 存储数据 */
	for (ull i = 1; i <= n; i++) {
		scanf("%llu", &s);
		for (ull j = 1; j <= s; j++) {
			ull tmp;
			scanf("%llu", &tmp);
			a[i].push_back(tmp);
		}
	}

	/* 处理询问 */
	for (ull i = 1; i <= q; i++) {
		scanf("%llu %llu", &x, &y);
		ans ^= a[x][y - 1];
	}

	printf("%llu\n", ans);
	return 0;
}

```

代码小注：

1. 此处的 `typedef` 是用于自定义变量类型名的，由于 `unsigned long long` 实在是又臭又长，所以使用 `typedef` 将它定义为 `ull` 方便使用。

2. 使用 `const` 定义数组的原因是在 C++ 中const 常量有数据类型，编译器可以对它进行类型安全检查，开到了 $4e6$ 是防一手数据太大。

3. 这里的 `vector<ull> a[N]` 的写法正是前文提及的 `vector` 所支持的 **列表初始化**，包括在下文中使用到的直接使用 `[]` 运算符直接操作 `vector`，也正是应用到了这个特性。

4. 在 `for` 循环中定义 `tmp` 是因为在 `for` 中的变量在跳循环之后会回卷删除，所以能节省一部分空间。

5. 在计算答案时使用的是 `a[x][y - 1]`，这是因为 `vector` 的数组和正常数组一样，也是从下标 `0` 开始。

## 结语

需要注意的是，`vector` 的底层实现还是定义长数组，能够实现动态扩容的原因是因为添加了防溢出的操作。所以如果可以善用 `resize()` 和 `reverse()`，就可以使得 `vector` 的复杂度与普通数组差不多。

## 引用资料

各位有兴趣的同学可以自己探索：
* [OI Wiki 序列式容器 - vector](https://oi-wiki.org//lang/csl/sequence-container/#vector)
* [Runoob vector 容器浅析](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)
* [C++11 列表初始化](https://zh.cppreference.com/w/cpp/language/list_initialization)


---

## 作者：_H17_ (赞：4)

## UPD

行末加了句号，给读者更好的体验。

## 思路分析

这道题由于 $S_i$ 不确定，而如果按最大开会空间爆，于是我们需要使用不定长度数组 `vector`。然后每次读入 $S_i$ 存进相应的 `vector`，然后按照问答输出答案。

## 知识讲解

头文件：`<vector>` 引入方式 ~~不用再说了吧~~ `#include<vector>`，也可使用万能头文件 `<bits/stdc++.h>`。

定义方式：`vector<类型名>不定长数组名;` 举例 `vector<int>a;`。

读取长度：`a.size();` 返回值 `int`（一下默认数组名为 $a$）。

改变大小：`a.resize(大小);` 举例 `a.resize(2);`。

在尾部添加元素：`a.push_back(元素);` 举例 `a.push_back(2);`。

删除尾部元素：`a.pop_back();` 返回 `void`。

访问元素：和数组一样 `a[1];` （如果  $1\le$ `vector` 长度）。

## 代码

```cpp
#include<bits/stdc++.h>
//#include<管理员最帅最美>
using namespace std;
unsigned long long n,q,s[3000001],t,x,y,ans=0;
//注意数据范围，int过不了
vector<unsigned long long>a[3000001];
//重点！a[i]存储第i条数据的数
int main(){
    scanf("%llu%llu",&n,&q);
    for(unsigned long long i=1;i<=n;i++){
        scanf("%llu",s+i);
        for(unsigned long long j=1;j<=s[i];j++){
            scanf("%llu",&t);
            a[i].push_back(t);
            //重点！进入vector
        }
    }
    for(unsigned long long i=1;i<=q;i++){
        scanf("%llu%llu",&x,&y);
        ans^=a[x][y-1];//调用vector元素
        //注意，vector下标从0开始
    }
    printf("%llu",ans);
    return 0;
}
```

## AC记录

[$AC$](/record/91633548)。

---

## 作者：DanielDami (赞：1)

## 题意

给定 $n$ 条数据，第 $i$ 条数据有 $s_i$ 个数，记为 $a_{i, 1}, a_{i, 2}, \dots a_{i, s_i}$。

每次询问第 $x$ 条数据的第 $y$ 个数，即 $a_{x,y}$ 是多少。

输出所有询问的答案的**按位异或**和。

## 思路

- 因为题目的数据保证 $1 \leq n, s_i \leq 3 \times 10^6$，所以开数组存储是不行的，会 $\colorbox{#052242}{\color{White}MLE}$。

- 题目的数据还保证 $s_1 + s_2 + \dots + s_n \leq 5 \times 10^6$，可以发现如果用如上的方法存储，会有大量空间浪费。

- 如果可以要多大开多大，就能不造成空间浪费了。

- 这种情况，可以使用 `vector`。

- `vector` 可以动态的插入，删除元素，不会浪费空间。以下是本题中需要的 `vector` 操作。
  
  ```cpp
  vector<int>vec;//定义一个名为 vec 的 vector
  vec.push_back(int &&__x);//在 vec 的末尾插入一个值为 __x 的元素
  vec[std::size_t __n];//返回 vec 从头数第 __n 个元素的值
  ```

- 我们只需要开 $3\times10^6$ 个 `vector` 就可以了，虽然还是 $3\times10^6$ 个数组，但最多只会装 $5\times10^6$ 个元素，所占的空间也是那么多。

- 现在，只需要读入所有的数字，把第 $i$ 行的数 `push_back` 到第 $i$ 个 vector 中，做异或运算时，直接取对应的元素就可以了。

## 坑点

1. 题目的数据保证 $0 \leq a_i \lt 2^{32}$，`int` 装不下了，要用 `unsigned int` 来装。

2. `vector` 中的元素的下标是从 $0$ 开始的，而询问给出的y是从 $1$ 开始的，在取下标时注意是 `y-1`。

3. 数据规模较大，要使用 `scanf` 和 `printf` 输入输出。

## 代码

```cpp
#include <bits/stdc++.h>
#define int unsigned int
//坑点一号，注意这样写之后主函数的返回值
using namespace std;
int n, q;
vector<int> v[3000010];
//定义 3e6 个 vector

signed main()
{
    scanf("%u%u", &n, &q);
    for (int i = 1, x; i <= n; i++)
    {
        scanf("%u", &x);
        for (int y; x--;)
        {
            scanf("%u", &y);
            v[i].push_back(y);
            //插入元素
        }
    }
    n = 0;
    for (int x, y; q--;)
    {
        scanf("%u%u", &x, &y);
        n ^= v[x][y - 1];
        //坑点二号
    }
    printf("%u", n);
}

```


---

## 作者：cosmokramer (赞：1)


数据范围
------------
这道题的数据给的还是挺大的，

$1 \leq n \leq 3 \times 10^6$

$0 \leq a_i < 2^{32}$

因此如果直接用 $n$ 和 $a_i$ 开二维数组的话，肯定会 MLE，但是，我们可以采用动态数组 vector 来解决此题。


关于 vector 的那些事
------------
#### vector 的定义

```cpp
vector <数据类型> 数组名;
```

例如：

定义一个 `int` 类型的动态数组：```vector <int> a;```

定义一个 `char` 类型的动态数组：```vector <char> a;```

##### 二维 vector 的定义
```vector <vector <数据类型> > a(宽度);```

！！！尖括号中间的 > 右边必须有空格！！！


#### vector 的操作

在后面插入元素：```a.push_back();```

从后方弹出元素：```a.pop_back();```

查看数组是否为空：```a.empty();```

重新规划长度：```a.resize();```

查看当前数组长度：```a.size();```


这里贴一下代码
------------
```cpp
#include <iostream>
#include <vector>//vector头文件
#include <cstdio>//scanf和printf比cin和cout更快
using namespace std;

int main()
{
	long long n,q,ans;
	long long x;
	scanf("%lld%lld",&n,&q);
	vector <vector<long long> > a(n+5);、、定义二维vector
	
	for (int i=0;i<n;i++)
	{
		scanf("%lld",&x);
		
		if (a[i].size()<x) a[i].resize(x+5);
		
		for (int j=0;j<x;j++) scanf("%lld",&a[i][j]);
	}
	
	for (int i=0;i<q;i++)
	{
		long long q1,q2;
		scanf("%lld%lld",&q1,&q2);
		
		q1--;q2--;
		
		if (i==0) ans=a[q1][q2];
		else ans=ans^a[q1][q2];
	}
	
	printf("%lld",ans);//输出，完结撒花！！！
	
	return 0;
}

```


---


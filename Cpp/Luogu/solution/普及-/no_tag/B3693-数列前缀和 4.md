# 数列前缀和 4

## 题目背景

这次不是数列的问题了。

## 题目描述

给定一个 $n$ 行 $m$ 列的矩阵 $a$，有 $q$ 次询问，每次给定 $(u, v)$ 和 $(x, y)$，请你求出：

$$(\sum_{i = u}^x \sum_{j = v}^y a_{i,j}) \bmod 2^{64}$$

也就是求出以 $(u, v)$ 为左上角、$(x,y)$ 为右下角的矩形元素和对 $2^{64}$ 取余数的结果。

## 说明/提示

### 样例 1 解释

对第一组数据，三次询问的答案依次为 $45,9,16$。其按位异或和为 $52$。

### 数据规模与约定

对全部的测试点，保证 $1 \leq T \leq 10$，$1 \leq n, m \leq 10^3$，$1 \leq q \leq 10^6$，$0 \leq a_i < 2^{64}$，$1 \leq u \leq x \leq n$，$1 \leq v \leq y \leq m$。

数据保证 $\sum(n \times m) \leq 10^6$，$\sum q \leq 10^6$。即输入矩阵的总大小和询问总数均不超过 $10^6$。

### 提示
如果你不知道什么是按位异或和，可以在你的代码里添加如下的函数：

```cpp
template <class T>
T getXorSum(T *begin, T *end) {
  T ret = 0;
  for (T *it = begin; it != end; ++it) ret ^= *it;
  return ret;
}
```
这一函数的作用是计算传入数组（包括 `std::vector`）某一左闭右开区间的按位异或和，返回值类型与传入数组的类型相同，调用方法与 `std::sort` 类似，例如，要求数组 $a$ 的 $a_1 \sim a_n$ 的按位异或和，则调用 `getXorSum(a + 1, a + 1 + n)`，求 $a_0 \sim a_{n - 1}$ 的按位异或和，则调用 `getXorSum(a, a + n)`。如果 $a$ 是 `std::vector`，则将上述调用代码里的 `a` 均改为 `a.begin()` 即可。


## 样例 #1

### 输入

```
2
3 3 3
1 2 3
4 5 6
7 8 9
1 1 3 3
2 1 2 2
1 2 2 3
2 2 1
1 3
4 6
2 2 2 2```

### 输出

```
52
6```

# 题解

## 作者：onlyfiee (赞：16)

### update
修改了笔误。
## 题意

其实就是带权矩阵的总权。

### 思路

首先我们来了解这道题的解决方法的思路:

定义 $sum_{i,j}$ 是指 $(1,1)$ 到 $(i,j)$ 的前缀和，不难得到：

$$
    sum_{i,j}=a+sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}
$$

其中 $a$ 是指 $(i,j)$ 的值。如果不懂的话可以自己画个图，因为加的时候 $sum_{i-1,j}+sum_{i,j-1}$ **重复添加了** $sum_{i-1,j-1}$，所以减去。

例如下图，比如我们要求 $(c,b)$ 到 $(d,a)$ 的值：

![](https://cdn.luogu.com.cn/upload/image_hosting/fi1c38bn.png)

很容易想到用 $(d,a)$ 减去 $(c,b)$ 的前缀和。

### 查询

剩下的就是查询了，这个可通过我们之前预处理的 $sum$ 数组来进行查询：

$$
    ans=sum_{i,j}+sum_{u-1,v-1}-sum_{u-1,j}-sum_{i,v-1}
$$

$u-1,v-1$ 是因为我们 $sum_{i,j}$ 是指 $(1,1)$ 到 $(i,j)$，既然要查询 $(u,v),(i,j)$ 中的值，根据我们预处理的思想，这个自然不难解决。


tips：一定要自己好好想下，还是比较容易处理的。

### 细节

解决维护和查询的问题后，这道题目并没有解决因为有这样几句话：

> 请输出一行一个整数，表示本组数据的所有询问的答案的按位异或和。

也就是求出以 $(u,v)$ 为左上角、$(x,y)$ 为右下角的矩形元素和对 $2^{64}$ 取余数的结果。

连开 long long 都过不了，要开 unsigned int long long 具体坑点请看代码。

## code

```cpp
#include<bits/stdc++.h>
#define int unsigned long long//一定要开 unsigned long long
using namespace std;
int sum[2050][2050],temp,n,m,q,ans;
int u,v,x,y;
signed main()
{
	int t;
	cin>>t;
	while(t--)
	{
      ans=0; //多测不清空，爆零两行泪
	   cin>>n>>m>>q;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)	
			{
			    cin>>temp;
				sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+temp;
			}//O(nm)预处理
		for(int i=1;i<=q;i++) 
		{
			cin>>u>>v>>x>>y;
			ans^=sum[x][y]+sum[u-1][v-1]-sum[u-1][y]-sum[x][v-1];// O(1)查询
		}//异或处理答案，不取模是因为 unsigned long long 会自然溢出
		cout<<ans<<endl; //记得换行
	}
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：6)

### B3693 二维前缀和

这其实是一道模板题，讲的就是二维前缀和，然后相减就可以了。

我们可以回顾一下一维前缀和。

$s_i$ 为 $a_1$ 加到 $a_i$ 的值，然后我们有递推式 $s_i = s_{i-1} + a_i$。那么我们可不可以把一维转化到二维呢？

当然可以。可以记 $s_{i,j}$ 为左上角为 $(1,1)$，右上角为 $(i,j)$ 的矩形的和，那么我们就可以进行求解了。

- 如何求 $s_{i,j}$ 

这个问题需要我们用容斥原理来解决，我们画个图就知道了。

![图1](https://cdn.luogu.com.cn/upload/image_hosting/t59k0snl.png)

这个空格是我故意留的，代表着中间有长度为 $1$ 的距离。

我们可以直观地发现：

$S5=S3+S2-S1+S4$（算的时候注意减去重复的 $S1$ 和漏掉的 $S4$）

表示成我们定义的数组就是：

$s_{i,j}=s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+a_{i,j}$（$a_{i,j}$  就是 $(i,j)$ 的值）

- 如何求矩形内部的和

这个图就留给大家自己去思考了。

最后求出来题目种的矩形是：

$s_{x,y}-s_{x,v-1}-s_{u-1,y}+s_{u-1,v-1}$

- 取模

取模这个东西其实不用管，用 unsigned long long 自动对 $2^{64}$ 取模。

`code:`

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N = 1005;
ull n, m, s[N][N], Q, a[N][N], u, v, x, y,ans,T;
int main(){
	cin>>T;
	while(T--){
		memset(s,0,sizeof(s));//记得初始化
		cin>>n>>m>>Q;
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= m; j++){
				cin>>a[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
			}
		}
		ans=0;//记得初始化
		while(Q--){
			cin>>u>>v>>x>>y;
			ans ^=(s[x][y] - s[x][v-1] - s[u-1][y] + s[u - 1][v - 1]);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Lovely_Elaina (赞：5)

### 前言

其实就是一个二维前缀和。

建议先做完[一维前缀和](https://www.luogu.com.cn/problem/B3612)再来。

### 思路

和一维区间和很像，**建议自己画图模拟**。

假设有矩阵 $a$，定义矩阵 $b$，$b_{x,y}=\displaystyle\sum_{i=1}^{i\le n}\sum^{j\le m}_{j=1}a_{i,j}$。

那么输入时我们存前缀和是这样的： $b_{i,j}=a_{i,j}+b_{i-1,j}+b_{i,j-1}-b_{i-1,j-1}$。

矩阵 $a$ 的子矩阵 $(x1,y1)\sim(x2,y2)$ 的和就是 $b_{x2,y2}+b_{x1-1,y1-1}-b_{x2,y1-1}-b_{x1-1,y2}$。

但是和一维的一样，我们不需要单独开一个数组表示矩阵 $a$，直接在输入时用一个变量代替 $a_{i,j}$ 即可。

还有一个值得注意的是，题目要求我们将输出的值对 $2^{64}$ 取模，但是呢我们使用 `unsigned long long` 可以使值自然溢出，效果等同于对 $2^{64}$ 取模。

提示：按位异或的符号为 `^`。

### 代码


```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
const int N = 1005;

int T;

int s[N][N];
int n,m,q,p;
int u,v,x,y;

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(NULL);
    
    cin >> T;
    while(T--){
        
        cin >> n >> m >> q;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                cin >> p;
                s[i][j] = p + s[i][j-1] + s[i-1][j] - s[i-1][j-1];//计算二维的前缀和
            }
        }
        
        int ans = 0;
        for(int i = 1; i <= q; i++){
            cin >> u >> v >> x >> y;
            ans = ans ^ (s[x][y] + s[u-1][v-1] - s[u-1][y] - s[x][v-1]);//根据二维前缀和的公式计算并异或
        }
        
        cout << ans << endl;
    }
    
    return 0;
}
```

---


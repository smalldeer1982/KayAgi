# 数列离散化

## 题目描述

给定一个长度为 $n$ 的数列 $a$。定义 $\mathrm{rank}(i)$ 表示数列 $a$ 中比 $a_i$ 小的不同数字个数再加一。

对 $1 \leq i \leq n$，现在请你求出所有的 $\mathrm{rank}(i)$。

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq T \leq 5$，$1 \leq n \leq 10^5$，$-10^9 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3
3
1 2 3
5
1 6 2 2 7
4
-1 -2 -3 -3```

### 输出

```
1 2 3
1 3 2 2 4
3 2 1 1```

# 题解

## 作者：wangyinghao (赞：29)

既然题目都说了用离散化，那么自然就要用离散化去写。

### 什么是离散化？

举个例子，给出一个集合 $\{ 1,100000,999,15\}$，那么离散化后就是 $\{1,4,3,2\}$。

我想你能看出来离散化是干啥的了，那这么做的目的是什么？

比如[这道题](https://www.luogu.com.cn/problem/P1496)，如果对每一个位置都建立一个桶，那显然空间会炸，但是解决这道题只需要着火点的相对位置和它们的坐标就能解决，而求出相对位置就是离散化要干的事情。

### 如何实现离散化？

![](https://cdn.luogu.com.cn/upload/image_hosting/7mof94th.png)

我们可以发现，最后归位后的数组就对应的是 $\texttt{rank}$ 的值，因此这道题就是去求出最后的数组。

另外还需注意，题目中说“不同数字的个数”，所以本题要去重。

### 怎么用代码实现？

这道题要有两个数组，一个原数组，设为 $a$。一个离散化归位数组，设为 $d$。输入时要将原数组同步到离散化数组上。

首先对 $a$ 排序。

此时我们需要进行去重，我们可以用 STL 中的一个神奇的函数：$\texttt{unique}$，~~STL 好闪，拜谢 STL~~，使用方法跟 $\texttt{sort}$ 函数一样，只不过没有第三个参数。

注意到去重后序列元素的个数有变化，所以我们需要求它。去重后的个数会用到一行神奇的代码：```unique(a+1,a+n+1)-(a+1)```，就能求出去重的个数了。

接下来我们考虑如何归位。之前还有一个没动过的数组 $d$，现在的目标是将 $d$ 中的每一个元素在 $a$ 中找到并求出这个元素在 $a$ 从左到右第几个。注意到 $a$ 具有单调性，可以用二分实现。

你可以手写二分，但是如果你不想手写二分，可以用 $\texttt{lower\_bound}$，形式是这样的：```lower_bound(first,last,val)``` 可以查找区间中第一个**大于等于** $\texttt{val}$ 的值。```lower_bound(a+1,a+n+1,d[i])-a``` 可以返回 $a$ 中第一个大于等于 $d_i$ 的位置，输出这个结果即可。

### AC Code

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100005],d[100005];//原数组和离散化数组

int main(){
	ios::sync_with_stdio(0);
	int T,n;
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			d[i]=a[i];//同步原数组数据
		} 
		sort(a+1,a+n+1);//排序
		int cnt=unique(a+1,a+n+1)-(a+1);//去重
		for(int i=1;i<=n;i++){
			d[i]=lower_bound(a+1,a+cnt+1,d[i])-a;//归位
		}
		for(int i=1;i<=n;i++) cout<<d[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```

### upd

2024.11.23：重写对于离散化概念的解释，对于如何代码实现进行进一步的说明，更加容易理解。

2025.3.17：对离散化的意义进行更详细的解释。

---

## 作者：liupan2010 (赞：7)

前言：

本蒟蒻的第一篇 B 题库题解！

[题目传送门](https://www.luogu.com.cn/problem/B3694)

------------

思路：

本题我使用二分。

虽说题目标题有离散化，但是还是可以通过水题神器：依题意模拟来通过此题。

首先将原数组复制一份，为后面操作做准备。

注：以下代码省略了快读快写的实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
int temp,t,n,a[100001],b[100001];
int main(){
	t=read();
	while(t--){
		n=read();
		//复制数组
		for(int i=1;i<=n;i++){
			a[i]=read();
			b[i]=a[i];
		}
	}
	return 0;
}
```

接下来对原数组排序再去重。这里使用了 ```sort``` 与 ```unique``` 函数。

```cpp
		//排序
		sort(a+1,a+n+1);
		//去重（这里实际上是获得去重后的数组长度）
		temp=unique(a+1,a+n+1)-a;
```

接下来是本题的重点部分，就是用二分去查找每个原数组在去重后的数组的位置。

这样做的道理，就是去重后的数组是有序的。也就是说，原数组的数在去重后的数组的位置，就是原数组中比该数小的不同数的个数。

那就可以手写二分了：

```cpp
int find(int x){
	int l=1,r=temp,mid;
	while(l<r){
		mid=(l+r)>>1;
		if(a[mid]==x){  	//找到了
			return mid;		//返回位置
		}
		else if(a[mid]<x){
			l=mid+1;        //缩小范围
		}
		else{
			r=mid;          //同上
		}
	}
}
```

最后将结果输出即可：

```cpp
		for(int i=1;i<=n;i++){
			write(find(b[i]));
			putchar(' ');
		}
		puts("");       		//记得换行
```

------------

完结撒花！

---

## 作者：_Wind_Leaves_ShaDow_ (赞：7)

~~[蒟蒻安利一发博客](https://www.luogu.com.cn/blog/807774/)~~

~~什么？能水题解？这不得水一发~~

题目都告诉我们了这题是离散化。

针对初学 离散化 算法的初学者，~~应该算详细了吧。~~

### 什么是离散化？

离散化，将一个疏散数列变得稠密，使得数之间的 **大小关系** 不变。

比如，```8 6 114 3 514 6``` 这组数列经过离散化后会变成 ```3 2 4 1 5 2```。容易发现它们之间相对的大小关系没变。

更多地看一眼，发现两个数组间的对应关系为 **当前这个数在数组中从大到小是第几个，它离散化后就是几**。

实现方法见后文。

### 为什么要用离散化？

假如我们有这样一个问题：

```有一群小朋友排队，问题只会涉及到小朋友的位置关系，而不会涉及到小朋友的具体距离。并且假如我们要用数组存下来。```

普通的存法很容易爆空间。但是既然只涉及位置关系，就可以离散化后储存，**节省空间**。

### 如何进行离散化？

- 首先，将所有的元素复制在一个新数组（不妨叫它 lsh）中。

- 其次，对这个数组进行排序。

这时，我们的 lsh 数组中存储了 **有序的** 原数组。

- 将 lsh 数组去重。

介绍一个神奇的函数 ```unique()```

```unique()``` 函数将 **排好序** 的数组进行去重，并返回新数组 **末位位置的下一个位置**。

- 去重过后，lsh 数组变成了 **有序且每个数只有一个** 的数组。将它与原数组中的数一一对应即可。具体做法是二分（```lower_bound``` 函数），默认已经学过。

### 详见本题代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;

int T,n,a[N],lsh[N];

inline void disc(){
	for(int i=1;i<=n;i++)lsh[i]=a[i];//复制
	sort(lsh+1,lsh+n+1);//排序
	int cnt=unique(lsh+1,lsh+n+1)-lsh-1;//unique 函数用法如此，如果习惯下标以 0 开头就不需要最后的减一
	for(int i=1;i<=n;i++)a[i]=lower_bound(lsh+1,lsh+cnt+1,a[i])-lsh;//二分找到对应的离散化值
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//输入输出流优化，优化常数，加了好习惯
	cin>>T;
	while(T--){//多组数据用这个
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		disc();//进行离散化
		for(int i=1;i<=n;i++)cout<<a[i]<<' ';//此时 a 数组已经经过离散化
		cout<<'\n';
	}
	return 0;
}
```

离散化的大多数用处在于节省空间，让数据能在数组中储存下来。

通过代码可以发现，离散化的时间复杂度是 $O(n \log n)$ 级别的。

~~希望这篇题解能对初学者提供友好的帮助 QWQ~~

---

## 作者：qianyuzhe (赞：7)

看到很多人都用二分，这里提供一种不用二分的思路。

[题目传送门](https://www.luogu.com.cn/problem/B3694)

## 题意简述

给定一个长度为 $n$ 的数列 $a$。定义 $rank(i)$ 表示数列 $a$ 中比 $a_i$ 小的不同数字个数再加一。对 $1\leq i\leq n$，现在请你求出所有的 $rank(i)$。

## 题目分析

首先考虑无重复元素时如何求解该题。该题实际上是求数列中某个数的排行，所以我们可以想到将数列升序排序。首先定义一个结构体数组 $a(i,x,y)$，其中 $x$ 储存当前位置的数，$y$ 储存当前位置的编号，然后以 $x$ 为关键字升序排序，找到原来每一个数排序后的位置并输出即可。

再来考虑计入重复元素时如何求解该题。在排完序的基础上，我们可以再设定一个计数器 $f(i)$ 记录直到下标 $i$ 时对应的原序列中该元素的 $rank$ 值，则有 $f(a)=\begin{cases}1,&a(i,x,y)=a(i-1,x,y)\\
0 ,&a(i,x,y)\ne a(i-1,x,y)\end{cases}$，然后同上处理即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,i,f,r[100005];
struct A{
	int x,y;
}a[100005];
bool cmp(A x,A y){
	return x.x<y.x;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--){
		cin>>n;
		for(i=0;i<n;i++){
			cin>>a[i].x;
			a[i].y=i;
		}
		sort(a,a+n,cmp);
		for(f=i=0;i<n;i++){
			if(a[i].x==a[i-1].x)r[a[i].y]=f;
			else r[a[i].y]=++f;
		}
		for(i=0;i<n;i++)cout<<r[i]<<' ';
		cout<<endl;
	}
}
```

---

## 作者：imexplorer (赞：5)

# 题目链接 [B3694 数据离散化](https://www.luogu.com.cn/problem/B3694)
## 主要思路 

获取**排序**好并**去重**的数组（以下简称 B 数组），  
遍历原数组并在 B 数组中查找这个数的位置，  
将位置**加 1** 并输出就是该数的 $\mathrm{rank}(i)$ 。

## 如何实现
先贴上完整代码（仅供参考，请勿抄袭）:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        int n;
        cin>>n;
        int a[n+1],b[n+1];//定义原数列与要排序去重的数列
        for(int i=0;i<n;i++)
        	cin>>a[i];
        
        copy(a,a+n,b);//用STL里的copy函数复制数组
        sort(b,b+n);//排序数组
        
        int m=unique(b,b+n)-b;//使用STL里的unique函数去重并获取去重后的数组大小
        
        for(int i=0;i<n;i++)
        {
            cout<<(lower_bound(b,b+m,a[i])-b)+1<<' ';//用二分查找寻找数在b数列中的位置，记得加1
        }
        cout<<'\n';
    }
    return 0;
}
```
~~应该都能看懂吧(心虚)~~
### 代码解析
在 13 行处的 copy 函数用于复制数组，用法为:
```cpp
copy(Begin,End,TheOtherArray);
```
当然，用 for 循环复制或在输入时直接赋值也可以。  
  
在 16 行处的 unique 的功能是将数组中相邻的重复元素去除。然而其本质是将重复的元素移动到数组的末尾，最后再将迭代器指向第一个重复元素的下标。  
用法与 sort 函数相类似：
```cpp
unique(Begin,End);
```
**注意： 由于 unique 函数返回的是第一个重复元素的迭代器，所以要减去数组首元素的迭代器才是数组长度。**  
  
去重一个数组并获得去重后的长度可以这样写：
```cpp
int Len=unique(a,a+n);
```
lower_bound 函数是在数组的一段中查找这个数是否存在，存在则返回这个数的迭代器，否则返回 last 迭代器。
用法：
```cpp
lower_bound(a,a+n,value);
```
查找一个数在数组中的位置可以这样写：
```cpp
int pos=lower_bound(a,a+n,value)-a;
```
希望这个题解能对你有所帮助。

---

## 作者：YuTianQwQ (赞：3)

# 题目解析

这段 C++ 代码解决的问题主要是对一系列整数进行**离散化**。离散化是一种常见的数据预处理方法，常用于处理具有明显区间特性的数据。离散化可以压缩数据的值域，使得处理更为便捷。

在这个问题中，给定一个整数数组，我们需要将数组中的所有数值离散化到从 $1$ 开始的连续整数。

## 解题思路

1. **读取并处理每个测试用例**：对于每个测试用例，首先读入数组的长度 $n$，然后读入 $n$ 个整数，存储到数组 $a$ 中。同时，将数组 $a$ 的内容复制到数组 $b$ 中。
    ```cpp
    while(t--)
    {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        for(int i = 0;i < n;i++) cin >> a[i],b[i] = a[i];
        ...
    ```
2. **排序并去重**：对数组 $b$ 进行排序，然后删除重复元素。这一步是离散化的关键步骤，它将所有不同的数值按照大小顺序排列。
    ```cpp
    sort(b.begin(),b.end());
    b.erase(unique(b.begin(), b.end()),b.end());
    ```
3. **进行离散化**：遍历数组 $a$，使用 lower_bound 函数找到每个元素在数组 `b` 中的位置（由于数组 `b` 是排序过的，因此位置就相当于排名），然后将这个位置作为新的编号。由于数组下标从 $0$ 开始，所以需要加 $1$ 。
    ```cpp
    for(int i = 0;i < n;i++)
    {
        a[i] = lower_bound(b.begin(),b.end(),a[i])-b.begin()+1;
        cout << a[i] << " ";
    }
    ```
在这个过程中，主要使用到了排序、二分查找和去重这几个算法。其中，sort 函数用于排序，unique 函数用于去重，lower_bound 函数用于二分查找。

这个代码的时间复杂度主要取决于排序和二分查找的复杂度，分别为 $O(n \log n)$ 和 $O(\log n)$，所以总的时间复杂度为 $O(n \log n)$。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        //复制到两个数组
        for(int i = 0;i < n;i++) cin >> a[i], b[i] = a[i];
        sort(b.begin(), b.end()); //对b数组排序
        b.erase(unique(b.begin(), b.end()), b.end()); //移除b中的重复元素
        //离散化处理：对a中的每个元素，查找其在b中的排序位置，并输出
        //这样可以将任何一组数据映射到一组连续的整数上，方便后续处理
        for(int i = 0;i < n;i++)
        {
            a[i] = lower_bound(b.begin(),b.end(),a[i])-b.begin()+1;
            cout << a[i] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

---

## 作者：xlhl (赞：2)

## 题目大意
求出每个数在数列从小到大排后在数组中的位置，注意如果有相同的数，则位置相同，按读入的顺序输出。

## 思路
这道题可以不用离散化，用最简单的结构体排序就够了。结构体记录每个数的大小，然后就可以排序求出位置，但怎么按读入的顺序输出呢？这就是需要用结构体的原因，结构体还需要保存每个数在原数组的位置，以及在新数组的位置，只要在存完新数组的位置后，按在原数组的位置排序就行啦。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
struct node{
	int x,id,rk;
}a[100010];
bool cmp(node q,node p){
	return q.x<p.x;
}
bool cmp2(node q,node p){
	return q.id<p.id;
}
int main(){
 	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i].x);
			a[i].id=i;
		}
		sort(a+1,a+1+n,cmp);
		int pm=0,w=0;
		for(int i=1;i<=n;i++){
			if(a[w].x!=a[i].x) w=i,pm++;
			a[i].rk=pm;
		}
		sort(a+1,a+1+n,cmp2);
		for(int i=1;i<=n;i++) cout<<a[i].rk<<" ";
		cout<<endl;
	}   
    return 0;
}
```

---


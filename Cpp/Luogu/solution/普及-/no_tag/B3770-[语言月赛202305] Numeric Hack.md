# [语言月赛202305] Numeric Hack

## 题目背景

这是一道 **hack 题**。在本题目中，你将得到一个问题和一个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：

1. 输出错误的结果。
2. 运行超时。
3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

对于这一问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。

---
**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言。**

## 题目描述

以下给出这道题目的叙述：

给定三个整数 $n, k, d$，请你找到一个最小的整数 $n'$，使得 $n' > n$ 且 $n' \bmod k = d$。

这里的 $d$ 是非负整数。也就是说，你需要保证 $n' = ak + d$，其中 $a$ 是一个整数，$d \geq 0$。

## 说明/提示

### 样例组与实际输入的说明

如果你直接采用『提交答案』的方式，请将输入数据命名为 `1.in`，并打成 zip 压缩包进行提交。但是由于不稳定因素，我们**不推荐**使用这种方式进行提交。

如果你采用提交数据生成器的方式，你的生成器应当**输出对应的输入数据**。

显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对这一问题的样例说明。

### 数据规模要求

你给出的数据必须满足如下要求：

1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。
2. 数据中所有的数字都应为整数。
3. $|n| \leq 10 ^ 4$，$0 \leq d < k \leq 10 ^ 4$。

### 目标代码

你需要 hack 如下的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n, k, d;
	cin >> n >> k >> d;
	++n;
	if (n % k == d) {
		cout << n << endl;
		return 0;
	}
	if (n % k < d) {
		n += (d - n % k);
	} else {
		n += (k + d - n % k);
	}
	cout << n << endl;
	return 0;
}
```

目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。

### 判分说明

本题仅有一个测试点对应一个问题，hack 成功则对应测试点返回 accepted。

#### 数据判定

你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。

#### 超时判定

程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。

如果程序的运行时间超过 $500 \text{ms}$，则判定为程序运行超时，返回 accepted 结果。

#### 结果错误判定

如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。

#### 未定义行为判定

我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。

这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。



### 关于评测信息的说明

如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。

例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。

特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。

## 样例 #1

### 输入

```
9 7 5```

### 输出

```
12```

# 题解

## 作者：sLMxf (赞：5)

# B3770 Numeric Hack 题解
hack 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n, k, d;
	cin >> n >> k >> d;
	++n;
	if (n % k == d) {
		cout << n << endl;
		return 0;
	}
	if (n % k < d) {
		n += (d - n % k);
	} else {
		n += (k + d - n % k);
	}
	cout << n << endl;
	return 0;
}
```
解决这个问题，我们首先要了解取余：
>若 $a$ 与 $d$ 是整数，$d\ne0$ ，那么余数 $r$ 满足这样的关系：$a=qd+r$ ， $q$ 为整数，且 $0 \le |r| < |d|$。  
>——选自百度

Q：我怎么说起取余？

A：题目中有 $|n| \le 10^4 \to (-10^4) \le n \le 10^4$，负数的取余有一点奇怪。

那么对于一个负数，取余**可能**有两个可能：如 $(-3)\bmod7$，$-1$ 和 $2$ 都满足上面的负数取余的条件，（前者称为负余数，后者为正余数）那么可以针对这个地方下手。

但是不能直接写 hack 数据：  
- 如果 $n$ 和 $k$ 同号，是使商尽可能小，只有一个余数（你不会说 $7\bmod3=-2
$）。
- 如果 $n$ 和 $k$ 异号，可能有两个余数。

所以记得 $n$ 和 $k$ 异号，其他没什么好说的。

---

## 作者：_Chesed_ (赞：2)

# [B3770 [语言月赛202305] Numeric Hack](https://www.luogu.com.cn/problem/B3770)

## 分析

首先 Hack 题先看范围，发现 $\left | n \right |\le 10^4 $，那么可以推断出本题 Hack 数据与 $n$ 取负有关。

而在数学中，模运算结果始终是一个非负数，而在 C++ 中模数可以为负数（这还是做期末数学阅读理解题的时候知道的）。

因此只需使 $n$ 为负数便可以 AC 了。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	printf("-114 114 5");
}
```

 

---

## 作者：syhx (赞：2)

## 如何 hack 掉一份代码？  
我个人一般用两种方式。 

1. 卡时间或卡空间
2. 卡数组越界  

但是这道题都不行啊，时间用最大数据试过了，空间又是定值，直接都排除。   
但看到取余的操作，又看到 $n$ 可以是负数，又看看代码：  
我有一个邪恶的想法。
```cpp
#include<iostream>
using namespace std;
int main(){
    cout<<"-10 10 1";
    return 0;
}
```
既然要求中 $n$ 可以是负数，但是代码又没有处理负数，那我们把 $n$ 置为负数不就行了？  
[AC 记录](https://www.luogu.com.cn/record/113448279)

------------
这道题告诉我们：做题时一定要记得处理负数。  
@ syhx

---

## 作者：pstdjr (赞：2)

题目：  
要 hack 一个程序：  
```
#include <bits/stdc++.h>  
using namespace std;  
int main() {  
    int n, k, d;  
    cin >> n >> k >> d;  
    ++n;  
    if (n % k == d) {  
        cout << n << endl;  
        return 0;  
    }  
    if (n % k < d) {  
        n += (d - n % k);  
    } else {  
        n += (k + d - n % k);  
    }  
    cout << n << endl;  
    return 0;  
}  
```
程序要求 $n' \bmod k = d$ 并且 $n' > n$ 的最小的 $n'$。

这里 $n$ 可正可负可 $0$，$k$ 和 $d$ 只能正，$d$ 可以是 $0$，$k$ 不可是 $0$！！！

由于负数模整数余负数或 $0$。但输入的 $k$ 和 $d$ 不是负数，而 $n$ 可能是负数，所以满足 $n$ 是负数且 $d$ 是正数即可。例：$-4$ $2$ $1$  
程序：
```
#include <bits/stdc++.h>  
using namespace std;  

int main(){  
    cout << "-4 2 1" << '\n';  
    return 0;  
}
```

**注意**：***输出的数据要自己带入程序验证一下。***

---

## 作者：Syncc (赞：1)

# B3770 Numerick Hack 题解

## [题目传送门~~](https://www.luogu.com.cn/problem/B3770)
### 你需要 Hack 的 Code ：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n, k, d;
	cin >> n >> k >> d;
	++n;
	if (n % k == d) {
		cout << n << endl;
		return 0;
	}
	if (n % k < d) {
		n += (d - n % k);
	} else {
		n += (k + d - n % k);
	}
	cout << n << endl;
	return 0;
}
```

这道题涉及 C++ 的负数知识。我们先看一道很简单的题，$-23 \bmod 56 = ?$ 这道题其实有**两个正确答案**，一个是正余数 $33$（在计算器里算出来的），另一个是负余数 $-23$（在本地 Dev-C++ 里跑出来的，有两个结果，于是乎，我们就可以根据这一特性来编写 C++ Code 了。

###  Code: 
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  cout<<"-23 56 55";
  return 0;
}
```
这是本蒟蒻写的第一篇题解，希望管理们能包容下，谢谢。

---

## 作者：Xswarx_XL (赞：0)

# 题目大意
让你去设一组数据让题目中的代码发生错误。

# 题目分析：

首先，我们要知道，Hack 题的几大法则：

- 往负数上去考虑。

- 往数组范围出界上去考虑。

- 出在数据范围极限的数据，卡内存，卡时间。

看一下这个题，用不到数组，时间复杂度 $O(1)$，卡不了，内存只用三个整型变量，也卡不了。

再看极限数据，带进代码一测，发现按最大来算卡不了，只能靠最小的了，也就是法则第一条：负数。

文中 $d$，$k$ 变量不能为负，那就把 $n$ 赋成负数得了。

# 附上代码
```cpp
#include<iostream>
using namespace std;
int main(){
    cout<<"-3 10 9";
    return 0;
}
```
# 小结
Hack 题简简单单的啦。

---


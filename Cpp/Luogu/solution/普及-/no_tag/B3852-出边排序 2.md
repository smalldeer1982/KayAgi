# 出边排序 2

## 题目描述

给定一个 $n$ 个点 $m$ 条边的有向图 $G$，结点编号从 $1$ 至 $n$，每个结点有一个权值，结点 $i$ 的权值是 $w_i$。对于 $u = 1, 2, 3, \dots n$，依次完成如下要求：  
对于 $u$ 的所有出边（即从 $u$ 出发的边），按照**权值从小到大**的顺序输出出边所指向的节点编号。如果两个点的权值相同，先输出编号较小的。

**依次完成**的含义是，先按顺序输出 $u = 1$ 的出边所指向的点的编号，再按顺序输出 $u = 2$ 的出边所指向的点的编号……最后按顺序输出 $u = n$ 的出边所指向的点的编号。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T, n, m \leq 5 \times 10^5$，$1 \leq w_i \leq n$，但同时各测试点的 $n$ 与 $m$ 之和均不超过 $5 \times 10^5$，即 $\sum n, \sum m \leq 5 \times 10^5$。且 $1 \leq u, v \leq n$，每组数据内不存在重边。

### 提示

请注意大量读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
2
3 4
1 2 3
1 3
1 2
3 2
3 1
3 9
1 2 3
1 3
2 3
3 3
1 2
2 2
3 2
1 1
2 1
3 1```

### 输出

```
2 3

1 2
1 2 3
1 2 3
1 2 3```

# 题解

## 作者：Lyrith_with_xQ (赞：8)

首先，[读题](https://www.luogu.com.cn/problem/B3852)。

思路
------------
读题后，我们可以知道，题目会给出 $T$ 个图，每个图有 $n$ 个点，$m$ 条边，每个点有一个权值 $w_i$，需要按照**权值从小到大**的顺序输出每个图中每个顶点的出边。

本题难点在于对每个顶点的出边排序，我们可以用邻接表存图，存完后对每个顶点的出边排序，输出即可。

代码
------------
```
#include <bits/stdc++.h>
using namespace std;

vector<pair<int,int> > nds[500005];//使用vector+pair存图 
int t,n,m,w[500005],a,b; 

int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) 
		{
			scanf("%d",&w[i]);
			nds[i].clear();//因为有多组数据，所以每次输入时要清空邻接表 
		}
		for(int i=1;i<=m;i++)
		{
			scanf("%d%d",&a,&b);
			nds[a].push_back(make_pair(w[b],b));//因为pair的排序是按照第一个值排序的，所以把权值放在前面 
		}
		for(int i=1;i<=n;i++)
		{
			sort(nds[i].begin(),nds[i].end());//对每个节点的出边进行排序 
			for(int j=0;j<nds[i].size();j++)cout<<nds[i][j].second<<" ";
			cout<<"\n";
		}
	}
	return 0;//华丽结束 
}
```

性能分析
------------

时间复杂度：$O(T \sum^{n}_{i=1} m_i \log m_i)$。

空间复杂度：$O(n+m)$。

每个测试点最大用时：$397ms$。

可以通过本题。

---

## 作者：qianyuzhe (赞：5)

## 题意简述

给定一个 $n$ 个点 $m$ 条边的有向带权图，以从 $1$ 到 $n$ 每个节点每条出边指向的点的权值为第一关键字，编号为第二关键字进行升序排序，依次输出该节点每条出边指向的点的编号。

## 题目分析

由于要分别依次输出每个节点每条出边指向的点的编号，因此我们可以用邻接表存图。建立一个向量数组 $t$ 来存储每个节点每条出边指向的点的编号，排序部分可以用优先队列结合数对实现。

时间复杂度 $O(T\sum_{i=1}^nm_i\log m_i)$，空间复杂度 $O(m)$，可以通过。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,u,v,i,a[500005];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q[500005];//小顶堆 
int main(){
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(i=1;i<=n;i++)cin>>a[i];
		while(m--){
			cin>>u>>v;
			q[u].push(make_pair(a[v],v));//存入邻接表 
		}
		for(i=1;i<=n;i++){
			while(q[i].size()){
				cout<<q[i].top().second<<' ';//输出出边指向的节点的编号 
				q[i].pop();
			}
			cout<<'\n';
		}
	}
}
```

---

## 作者：Crasole (赞：2)

## 题意

给你由 $n$ 个点 $m$ 条边组成的有向图，把每个点的出边按权值从小到大排序，并输出点的编号。

**注意：如果点 $u$ 没有出边，也要换行。**

一共 $T$ 组数据。

## 思路

用 `vector` 来存储图，用 `pair <A, B>` 来表示点，其中，`A` 为权值，`B` 为编号。

输出时，先进行排序，然后输出每个点的编号即可。

代码根据思路写即可。

---

## 作者：Fp0cY1tZ6Nn4Rd_ (赞：2)

### 思路
因为要存储出边，所以可以用邻接表来存。

建立数组 `a` 来保存每条出边指向的节点的编号，也就是邻接表。排序则可以利用小顶堆实现。
### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<functional>
using namespace std;
const int N=5e5+5;
struct node{
	int first,second;
    friend bool operator>(node a,node b){
        if(a.first==b.first) return a.second>b.second;
        return a.first>b.first;
    }
};
int a[N];	//邻接表
priority_queue<node,vector<node>,greater<node>> q[N];	//建立一个小顶堆 
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		while(m--){
			int u,v;
			cin>>u>>v;
			q[u].push({a[v],v});	//存储
		}
		for(int i=1;i<=n;i++){
			while(!q[i].empty()){
				cout<<q[i].top().second<<" ";	//出边指向节点编号
				q[i].pop();
			}
			cout<<endl;
		}
	}
}
```

---


# 子树和

## 题目描述

给你一棵 $n$ 个结点的树，树的根结点是 $1$。

每个结点的权值都是 $1$，你需要对每个结点 $i$ 求出 $i$ 的子树和，也就是子树中有多少个结点。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\le n\le 1000$。

## 样例 #1

### 输入

```
5
1
2
3
3```

### 输出

```
5
4
3
1
1```

# 题解

## 作者：lizhengdong (赞：15)

[原题传送门](https://www.luogu.com.cn/problem/B3861)
## 0.题解背景
`WA` 哦，这么水的暂无评定题，赶紧水一篇题解。

## 1.题目分析
题目意思很 `easy`，简单概括一下：

每个结点的权值都是 $1$，你需要对每个结点 $i$ 求出 $i$ 的子树和，也就是子树中有多少个结点。

看完题目，很容易就能想到宽搜。

## 2.解题思路
瞅一眼数据，`emm...`，$1 \le n \le 1000$，宽搜完全木有问题。

## 3.AC code
贴代码啦!
``` cpp
#include<bits/stdc++.h>//万能的头 
#define f(i,j,k) for(i=j;i<=k;i++)//作者懒地打for 
using namespace std;
int n,i,j,t,w,x,b[1010],f[1010],xx;
vector<int>a[1010];
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//简易·加速代码 
    cin>>n;
    f(i,2,n)cin>>x,a[x].push_back(i);//建边 
    f(i,1,n){
        f(j,1,n)f[j]=0;
        t=w=1;//宽搜！启动！！！ 
        b[1]=i;//入队 
        f[i]=1;//计入做过 
        while(t<=w){
            x=b[t];//取出队头 及父亲 
            for(j=0;j<a[x].size();j++){
                xx=a[x][j];//取出儿子 
                if(f[xx]==1)continue;
                b[++w]=xx;f[xx]=1;//入队 
            }
            t++;//出队 
        }
        cout<<w<<"\n";//输出 
    }
    return 0;//完成！！！ 
}
```
热烘烘的题解~~
给个赞啦！

---

## 作者：XinFengIneverleft (赞：4)

~~又是道水题，闻着味就过来了~~  
[原题链接](https://www.luogu.com.cn/problem/B3861)  
## 题意简述  
题意描述很清晰，唯一可能有点难理解的就是输入格式的描述了。  
> 之后 $n-1$ 行，第 $i$ 行输入一个数 $f_{i+1}$ 表示 $i+1$ 点的父亲是 $f_{i+1}$ ，保证 $f_{i+1}<i+1$ 。  

这段话的意思其实就是在 $f_{i+1}$ 和 $i+1$ 之间连一条边。另外，虽然题目告诉我们每个结点的权值都是 $1$ ，但实际上根本不需要考虑边权。
## 题目分析  
虽然这是一棵树，但连边时只需要从 $f_{i+1}$ 到 $i+1$ 连一条有向边即可。因为本题求的是子树和，使用 DFS 只需要从根节点向下遍历，不需要考虑向上遍历。如果连无向边，还需要开一个 bool 数组防止 DFS 走回头路。
## 代码  
代码如下，详见注释。  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> g[1010];//使用vector存树（图）
int sum;//计算节点数

void add(int x, int y)//无需考虑边权的加边操作
{
	g[x].push_back(y);
}

void dfs(int u)//u表示当前遍历到的节点
{
	if (g[u].empty())//如果当前点没有出边，回退到上一层
		return;
	for (int i = 0; i < g[u].size(); i++)//遍历当前点的每个儿子节点
	{
		sum++;//统计遍历过的节点数
		dfs(g[u][i]);
	}
}

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n - 1; i++)
	{
		int x;
		cin >> x;
		add(x, i + 1);
	}
	for (int i = 1; i <= n; i++)//i表示DFS的起点
	{
		dfs(i);
		cout << sum + 1 << "\n";//由于一开始没有统计起点，所以这里加上1
		sum = 0;//sum这个变量要使用多次，所以要清零
	}
	return 0;
}
```


---

## 作者：yty2010 (赞：4)

**水题一道~**
## 思路：模拟
对于每一个点，因为有 $f_{i+1}<i+1$，因此可以当每个点与父节点连接时，从自己开始将子树结点数量 $+1$，并向父节点跳，直到跳到根节点。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define orz 0         //花活，没有价值
int n,val[1005],fa[1005];
int main()
{
	cin>>n;
   	val[1]++;    //初始化根节点子树节点数量为1
	for(int i=2;i<=n;i++)
	{
		cin>>fa[i];
		int j=i;
		while(j!=0)     	//直到跳到根节点
		{
			val[j]++;	//子树节点数量+1
			j=fa[j];	//向上跳
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<val[i]<<endl;	//输出
	}
    	return orz;
}
```


---

## 作者：scc36 (赞：4)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B3861)   
写题解时本体只有两个点！！！   
### 思路   
又是一道宽搜~~   
本题 $n$ 最大只有一千，宽搜没有问题。   
枚举每个点，宽搜它的子树来找它有几个孩子（孩子不一定只有儿子辈的人哦！）。     
### 代码   
```cpp
#include <bits/stdc++.h>     //万能头
using namespace std;
int n,i,j,t,w,x,b[1001],f[1001],fx;
vector<int>e[1001];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);   //输入输出的加速
	cin>>n;
	for(i=2;i<=n;i++){
		cin>>x;
		e[x].push_back(i);   //爸爸认儿子
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++) f[j]=0;
		t=w=1;           //爸爸找孩子（宽搜）
		b[1]=i;f[i]=1;
		while(t<=w){
			fx=b[t];
			for(j=0;j<e[fx].size();j++)
				if(f[e[fx][j]]==0){  //有没有找过
					w++;
					b[w]=e[fx][j];  //入队
					f[e[fx][j]]=1;  //找过了赋1
				}
			t++;
		}
		cout<<w<<"\n";         //输出孩子数
	}
}
```  
新鲜出炉的题目，新鲜出炉的题解~~

---

## 作者：fmdd_szx (赞：3)

[原题](https://www.luogu.com.cn/problem/B3861)

# 题意

有 $n$ 个点，每个结点的权值都是 $1$。现在要求每个结点 $i$ 的子树中有多少个结点。

# 思路

$1\le n \le 1000$，宽搜，不必多说。

枚举每一个点，搜出它的孩子。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,x,t,w,fx,sx,b[1001],f[1001];
vector<int> a[1001];
signed main(){
    cin>>n;
    for(i=2;i<=n;i++)
        cin>>x,a[x].push_back(i);
    for(x=1;x<=n;x++){
        memset(f,0,sizeof(f));
        t=w=1;//宽搜
        b[1]=x;
        f[x]=1;
        while(t<=w){
            fx=b[t];
            for(i=0;i<a[fx].size();i++){
                sx=a[fx][i];
                if(!f[sx]) b[++w]=sx,f[sx]=1;
            }
            t++;
        }
        cout<<w<<"\n";//孩子数
    } 
    return 0;
}
```


---

## 作者：suyi1111 (赞：3)

[原题传送门](https://www.luogu.com.cn/problem/B3861)

[博客食用更佳](https://www.luogu.com.cn/blog/67as/solution-b3861)

我们可以设置数组 $sum$，表示每一个节点的子树，再定义 $a$，$a_i$ 表示 $a$ 的父亲节点。

函数 $f(n)$ 表示将所有 $n$ 的祖先节点的子树节点数量加 $1$。

最后输出是要把 $sum_i$ 加一的原因是还要加上 $i$ 这个节点。

代码：

```
#include<bits/stdc++.h>
#define int long long//习惯，不会忘记开longlong
using namespace std;
int n,sum[1001],a[1001];
void f(int k){
	sum[k]++;
	if(a[k]==0)return ;
	f(a[k]);
} 
signed main()
{
	int n;
	cin>>n;
	for(int i=2;i<=n;i++){
		int l;
		cin>>l;
		a[i]=l;
		f(l);//这里是f(l)而不是f(i)的原因是sum[i]不记录i节点 
	}
	for(int i=1;i<=n;i++)cout<<sum[i]+1<<endl;
    return 0;
}

```

[AC记录](https://www.luogu.com.cn/record/128413608)

---

## 作者：Central_GYM (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B3861)
#### 本题采用 DFS 实现。
### 大意
建一个根为 1 的树，输出以 $i$ 为根的子树的节点个数。
### 思路
用链式前向星存储每一个节点的父亲节点是谁，然后遍历 $i$，向上搜索直到根节点为止，给过程中每一个节点的节点个数都增加。
### Code
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,ver[20005],nt[20005],head[1005],siz[1005],son[1005],tot;
  void add(int so,int fa){//前向星
      ver[++tot]=fa;
      nt[tot]=head[so];
      head[so]=tot;
  }
  void DFS(int now){//搜索
      for(int i=head[now];~i;i=nt[i]){
          siz[ver[i]]++;
          DFS(ver[i]);
      }
  }
  int main(){
      cin>>n;	
      memset(head,-1,sizeof(head));
      for(int i=1;i<n;i++){
          int a;
          cin>>a;
          add(i+1,a);
          son[a]++;
      }
      for(int i=1;i<=n;i++){
          siz[i]++;
          DFS(i);
      }
      for(int i=1;i<=n;i++){
          cout<<siz[i]<<endl;
      }
      return 0;
  }

```

---


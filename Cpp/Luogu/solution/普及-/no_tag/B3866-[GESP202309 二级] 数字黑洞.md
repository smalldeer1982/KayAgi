# [GESP202309 二级] 数字黑洞

## 题目描述

给定一个三位数，要求各位不能相同。例如，$352$ 是符合要求的，$112$ 是不符合要求的。将这个三位数的三个数字重新排列，得到的最大的数，减去得到的最小的数，形成一个新的三位数。对这个新的三位数可以重复上述过程。神奇的是，最终一定会得到 $495$！

试试看，重新排列 $352$，得到的最大数为 $532$，最小数为 $235$，它们的差是 $297$；变换 $297$，得到 $972-279=693$；变换 $693$，$963-369=594$；变换 $594$，$954-459=495$。因此，经过 $4$ 次变换得到了 $495$。

现在，输入的三位数，你能通过编程得出，这个三位数经过多少次变换能够得到 $495$ 吗？

## 样例 #1

### 输入

```
352```

### 输出

```
4```

# 题解

## 作者：洛谷网校 (赞：111)

欢迎大家报名[洛谷网校](https://class.luogu.com.cn/)的课程，期待和大家一起进步！
## 思路分析

题干要求将三位数的三个数字进行重新排列，所以我们可以借助数组 $a$ 来完成：` int a[3]`。最外层我们使用 `while` 语句来判断当前得到的数是否等于 $495$，如果不是的话，我们需要再次进行操作，其中使用 $ans$ 来记录变换次数。

我们需要先对这个三位数 $N$ 进行一些处理：把他的个位，十位，百位存放在数组 $a$ 中，并完成排序。此时最小的数存放在 $a[0]$ ，最大的数存放在 $a[2]$ 中，他们能组成的最大数与最小数的差的计算公式为 $a[2] \times 100+a[1]\times10+a[0]-(a[0] \times 100+a[1] \times 10+a[2])$，并将结果作为新的 $N$ 进行判断。

## 核心代码

最外层循环，变换次数记录：

```cpp
while(n!=495){
        ...
        cnt++;
}

```

将 $N$ 的个位，十位，百位分别存放在数组 $a$ 中：

```c++
for (int i = 0; i < 3; i++)
{
	a[i] = n % 10;
   	n /= 10;
}
```

排序，求出得到的最大的数，减去得到的最小的数，得到新的数。

```c++
sort(a, a + 3);
n = (a[2] * 100 + a[1] * 10 + a[0]) - (a[0] * 100 + a[1] * 10 + a[2]);
```



---


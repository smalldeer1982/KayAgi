# [GESP202309 四级] 进制转换

## 题目描述

$N$ 进制数指的是逢 $N$ 进一的计数制。例如，人们日常生活中大多使用十进制计数，而计算机底层则一般使用二进制。除此之外，八进制和十六进制在一些场合也是常用的计数制（十六进制中，一般使用字母 A 至 F 表示十至十五；本题中，十一进制到十五进制也是类似的）。

在本题中，我们将给出 个不同进制的数。你需要分别把它们转换成十进制数。

## 说明/提示

对于任意一个 $L$ 位 $K$ 进制数，假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L-1$ 位，我们只需要将其第 $i$ 位的数码乘以权值 $K^i$，再将每位的结果相加，即可得到原 $K$ 进制数对应的十进制数。下面是两个例子：

1. 八进制数 `1362` 对应的十进制数为：$1×8^3+3×8^2+6×8^1+2×8^0=754$；

2. 十六进制数 `3F0` 对应的十进制数为：$3×16^2+15×16^1+0×16^0=1008$。

## 样例 #1

### 输入

```
2
8 1362
16 3F0```

### 输出

```
754
1008```

## 样例 #2

### 输入

```
2
2 11011
10 123456789```

### 输出

```
27
123456789```

# 题解

## 作者：_VirtualPoint_ (赞：42)

# 声明（也就是废话）
- 一审打回，感谢一审管理员[Jiyuu_no_Tsubasa](https://www.luogu.com.cn/user/261981)的审核。  
- 二审打回，感谢二审管理员[swiftc](https://www.luogu.com.cn/user/183154)的审核。 
- 这是本蒟蒻的第一篇题解，激动不已。三审管理员求过~ 
- 代码请需要的同学谨慎使用。切勿抄题解！这是非常不道德的行为。而且，这还可能导致又一位作弊者的产生。

# 题目大意

输入 $n$ 个整数与其进制 $k$，对于每一个整数，我们求它得十进制并输出。

# 分析

相信大家早就发现了，题目良心得给出了转换方法！  
这里放上原文：
>“对于任意一个 $L$ 位 $K$ 进制数，假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L-1$ 位，我们只需要将其第 i 位的数码乘以权值 $K^i$，再将每位的结果相加，即可得到原 $K$ 进制数对应的十进制数。”

什么意思呢？

这里涉及到一个概念：位权。

什么是位权呢？我们拿一个十进制数 $114514$ 举例：

| 类型 | 十万位 | 万位 | 千位 | 百位 | 十位 | 个位 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **数字** | $1$ | $1$ | $4$ | $5$ | $1$ | $4$ |
| **位权** | $10^5$ | $10^4$ | $10^3$ | $10^2$ | $10^1$ | $10^0$ |
| **计算过程** | $10^{5} \times 1$ | $10^{4} \times 1$ | $10^{3} \times 4$ | $10^{2} \times 5$ | $10^{1} \times 1$ | $10^{0} \times 4$ |
| **实际数值** | $100000$ | $10000$ | $4000$ | $500$ | $10$ | $4$ |

而 $114514$ 就是每一位代表的实际数值之和。

相信大家有思路了吧！第 $n$ 位的位权，就代表这一位上每一个 $1$ 代表的数量。

这是十进制中的位权。但如果这个 $114514$ 是八进制数呢？

| 类型 | 十万位 | 万位 | 千位 | 百位 | 十位 | 个位 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **数字** | $1$ | $1$ | $4$ | $5$ | $1$ | $4$ |
| **位权** | $8^5$ | $8^4$ | $8^3$ | $8^2$ | $8^1$ | $8^0$ |
| **计算过程** | $8^{5} \times 1$ | $8^{4} \times 1$ | $8^{3} \times 4$ | $8^{2} \times 5$ | $8^{1} \times 1$ | $8^{0} \times 4$ |
| **实际数值** | $32768$ | $4096$ | $2048$ | $320$ | $8$ | $4$ |

这几个数值加起来，刚好就是八进制数 $114514$ 的十进制形式 $39244$。

# 着手实现

看到这里，相信大家都明白怎么写代码了吧！但是还有几个易错点我要讲一讲。

- `string` ！

如果你想用 `int` 类型输入，随后用 `while` 循环拆分数位累加的话，那你可就大错特错了。虽然用这种方式拆分数位又快又好用，但是你想过没有，`int` 类型似乎不支持除了 1~10 以外的数字输入啊！

而这些数字（包括但不限于 `A`）可是 11~16 以及更多进制的命根子！

我们只能用 `string` 来实现。当然，如果你学有余力，不妨挑战一下字符数组？

- `long long` ！

正所谓那句老话：
> “十年 OI 一场空，不开 long long 见祖宗！”

我们可以想一下，如果题目输入十六进制数 $\text{FFFFFFFFF}$ 怎么办？这个数非常大，会把 `int` 类型撑爆！就算是 `long` 类型也很危险！

只能开 `long long` 了对吧？

当然，如果题目数据再大一点，我们就不得不用到 `__int128` 了。

# 代码


```cpp
#include <iostream>
#include <cmath>
using namespace std;

long long n;

long long k;

long long num[15];

string snum;

int main() {
    cin >> n;//处理输入

    while (n--) {
        cin >> k >> snum;//处理输入

        long long ans = 0;

        for (long long i = 0; i < snum.size(); i++) {
            if (!(snum[i] >= '0' && snum[i] <= '9')) {
                num[i] = snum[i]-'A'+10;
            } else {
                num[i] = snum[i]-'0';
            }
            ans = ans * k + num[i];
          //我们可以直接在处理字符的时候直接进行累加。
          //当然，更直接的做法就是不要num数组，直接处理完后累加。
        }

        cout << ans << endl;//记得输出！
    }
    return 0;
}
```

大家看看，AC的非常漂亮是不是？

---

## 作者：cff_0102 (赞：22)

介绍一个 C 库函数：`strtol()`。

`long int strtol(const char *str, char **endptr, int base)` 可以将 `str` 当成 $base$ 进制数，并返回它在 $10$ 进制下的值。

于是，不难编写出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int t;cin>>t;
	while(t--){
		int n;char s[114];char *ed;
		cin>>n>>s;
		long long a=strtol(s,&ed,n);
		cout<<a<<endl;
	}
	return 0;
}
```

注意：本题答案可能爆 `int`。当输入为 `FFFFFFFFF` 时，应输出 $68719476735$，大于 `int` 能表示的最大值 $2147483647$。

---

## 作者：sillation (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/B3869)


------------
如何将 $n$ 进制转为十进制？

以下是 [百度](https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222) 的解释：
 ```
 进制转换由一组数码符号和两个基本因素“基数”与“位权”构成。
 
 基数是指，进位计数制中所采用的数码（数制中用来表示“量”的符号）的个数。
 
 位权是指，进位制中每一固定位置对应的单位值。
 
二进制数第0位的权值是2的0次方，第1位的权值是2的1次方。

```
设有一个二进制数：$0110 0100$，转换为 $10$ 进制为：

从右往左开始换算。

第 $0$ 位 $0 \times 2 ^ {0} = 0$。

第 $1$ 位 $0 \times 2 ^ {1} = 0$。

第 $2$ 位 $1 \times 2 ^ {2} = 4$。

第 $3$ 位 $0 \times 2 ^ {3} = 0$。

第 $4$ 位 $0 \times 2 ^ {4} = 0$。

第 $5$ 位 $1 \times 2 ^ {5} = 32$。

第 $6$ 位 $1 \times 2 ^ {6} = 64$。

第 $7$ 位 $0 \times 2 ^ {7} = 0$。

总和为 $4 + 32 + 64 = 100$。

公式：第 $d$ 位是 $2 ^ {d}$。

以此类推 $K$ 进制数的第 $d$ 位需要去乘 $K ^ {d}$。


------------
温馨提示：

- 输入数的时候请用 `string`。
- 如果某一位上是字母请先将其转换成对应的数字。
- 十年 OI 一场空，不开 long long 见祖宗！


------------
### code

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,r;
string k;
void fun(int m,string s){
	long long d=1,sum=0;//一定用 long long
	for(int i=s.size()-1;i>=0;i--){//从后往前（从右往左）
		if(s[i]<='9'&&s[i]>='0') sum+=d*(s[i]-'0');
		else sum+=d*(s[i]-'A'+10);//把字母转换成对应的数字
		d*=r;//计算权值
	}
	cout<<sum<<endl;
}
int main(){
	cin>>n;
	while(n--){ //可以写成 for(long long  i=1;i<=n;i++)
		cin>>r>>k;
		fun(r,k);
	}
	return 0;
}

```

---

## 作者：Louis_lxy (赞：10)

# 进制转换

## 思路

进制转换可以手写也可以使用 stl，stl 的方法自己百度搜索吧，这里主要讲手写。

首先，我们用字符串输入这个数，然后定义一个 $pos$ 表示 [位权](https://localsite.baidu.com/okam/pages/article/index?categoryLv1=%E6%95%99%E8%82%B2%E5%9F%B9%E8%AE%AD&ch=54&srcid=10004&strategyId=142017121985803&source=natural)，然后从后往前遍历，在每次循环结束时 $pos \gets pos \times n$，这样就可以将时间复杂度优化到 $O(n)$ 的处理，综合时间复杂度 $O(n \times t)$ 会比用 $pow$ 函数的 $O(t \times n^2)$ 要快。

然后判断每个字符是否是数字，如果是就直接转数字再乘以位权，否则就是大写字母，那么就减掉 `A` 再加上 $10$，最后记得对每一位的数求和。

提示：要开 long long，$sum$ 和 $pos$ 都要开。

```cpp
#include <iostream>
using namespace std;

int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		int n;
		long long sum = 0, pos = 1;
		string s;
		cin >> n >> s;
		for (int i = s.size() - 1; i >= 0; --i)
		{
			if (s[i] >= 'A' && s[i] <= 'Z')
				sum += (s[i] - 'A' + 10) * pos;
			else
				sum += (s[i] - '0') * pos;
			pos *= n;
		}
		cout << sum << endl;
	}
}
```

---

## 作者：ShanCreeperPro (赞：4)

欢迎大家报名[洛谷网校](https://class.luogu.com.cn)的课程，期待和大家一起进步！

## 思路分析

本题考查进制转换，即字符串综合运用。

根据题目，我们要将 $n$ 个 $k$ 进制数字转化为 $10$ 进制，所以我们可以编写一个函数 `ToDec` 来实现 $k$ 转 $10$ 的功能，通过循环来依次转化，输出答案。

`ToDec` 的编写思路如下：

- `ToDec` 的输入参数应有两个：字符串 $n$ 表示数字，$b$ 表示进制；
- 先定义变量 $d$ 储存最终十进制的值，注意需要将其**初始化为** $0$，再定义 $p$ 表示**字符的权重**，初始为 $n$ 的长度减去一；
- 用循环遍历这个数字，使用 `isdigit` 函数判断某个字符是数字还是字符，将其转化为对应整数值，如果是数字，则减去 `'0'`，如果是字母，则减 `'A'` 加上 $10$，可翻阅 ASCII 码理解；
- 计算出十进制后，在 $d$ 上加上计算出的权重，其中权重值是十进制值 $\times b^{\ p}$；
- 一个字符结束后，需要将权重减一，因为位数改变；
- 最后返回 $d$ 十进制值。


## 核心代码

`ToDec` 函数的实现，实现思路以上：

```cpp
int ToDec (const string& n, int b){
    int d = 0;
    int p = n.size() - 1;
    for (char dig : n){
        if (isdigit (dig)) d += (dig - '0') * pow(b, p);
        else d += (dig - 'A' + 10) * pow(b, p);
        p--;
    }
    return d;
}
```



## 注意事项

- 注意换行；
- 注意 $p$ 的初始值要记得减去 $1$，因为字符串是从 $0$ 开始。



---

## 作者：Seqfrel (赞：3)

### 题意分析

给定 $N$ 个 $K$ 进制数，输出它们的十进制形式。

### 思路详解

首先我们需要懂得进制的按权展开。在题面的**说明/提示**中已经写到，八进制数 `1362` 对应的十进制数为：  $1×8^3+3×8^2+6×8^1+2×8^0=754$；十六进制数 `3F0` 对应的十进制数为：$3×16^2+15×16^1+0×16^0=1008$。所以，将一个 $K$ 进制数 $x$ 转换为十进制，只需要将它的每一位都乘那一位所对应的权值。而从右往左数第 $n$ 位的权值即为 $K^{n-1}$。

### 代码实现

用字符串存储每个 $K$ 进制数，分别按权展开处理即可。

**注意:**

1.此程序涉及多组数据，所以可以边输入边计算并输出。

2.题面中写到，保证所有 $K$ 进制数的位数不超过 $9$，但是 int 类型变量的存储范围是 $-2147483648$ 到 $2147483647$，所以结果可能超过 int 类型变量的存储范围，需要使用 long long 类型变量存储。

3.此题涉及乘方运算，可以使用 cmath 库中的 pow 函数进行处理。

考察算法：字符串

AC 代码：

```cpp
#include<iostream>
#include<string>//字符串头文件。 
#include<cmath>//数学头文件。 
using namespace std;
int n;
long long cvt(string d,int k){
	long long ans=0;//longlong类型变量存储。 
	int l;
	string t=d;
	l=t.size();
	for(int i=l-1;i>=0;i--){
		if(t[i]>='0'&&t[i]<='9')ans+=(t[i]-'0')*pow(k,l-i-1);//即为：k的(l-i-1)次方。 
		else ans+=(t[i]-'A'+10)*pow(k,l-i-1);
	}
	return ans;
}
int main(){
	cin>>n;
	while(n--){
		int k;
		string d;
		cin>>k>>d;
		cout<<cvt(d,k)<<endl;//边输入边输出。 
	}
	return 0;
}
```

---

## 作者：_Sky_Dream_ (赞：3)

# [传送门](https://www.luogu.com.cn/problem/B3869)


怎么从 $n$ 进制转到 $10$ 进制？

从右往左，$n$ 进制数第 $i$ 位上对应的十进制数是 $n^{i-1}$。

其次，对于任何进制，各个数位上的数有一下两种情况：

- 是数字，直接转换（不变）。

- 是字母，如字母 $A$，对应的十进制数是 $10$，那么只需要用字母对应的字母表顺序加上 $9$ 即可。

其实就是转换，相乘，相加啦。

友情提醒：十年 OI 一场空，不开 long long 见祖宗。

AC Code:

```cpp
//#pragma GCC optimize(1)
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define itn int
#define tni int
#define tin int
#define nit int
#define nti int
#define int long long//开 long long
using namespace std;
int T; 
int sum(char x){
	if(x>='0'&&x<='9')return x-'0';
	else return x-'A'+10;
}//转换为数字
void Main(){
	int n,ans=0;
	string a;
	cin>>n>>a;//读入
	for(int i=0;i<a.size();++i)
	ans+=sum(a[i])*pow(n,a.size()-i-1);//计算
	cout<<ans<<endl;//注意换行
} 
void Enchanted(){
	srand(time(0));
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>T;
	while(T--)Main();
	exit(0);
}
signed main(){Enchanted();}


```

---

## 作者：cysxc11111 (赞：2)

#### [题目传送门](https://www.luogu.com.cn/problem/B3869)

------------
这道题其实可以用 `strtol` 函数来做，但是这个蒟蒻竟然还不会用 `strtol` 函数，所以，今天给大家讲一个字符串模拟的方法。

模拟的方法十分简单，将输入的 $K$ 进制数存在一个字符串中（因为十进制以上会出现字母或其他字符出现），用字符串中从后往前的每一位乘他的权值再讲每一位数累加，即可得出十进制的答案。

举个例子，例如八进制的 `567`，转换为十进制即为 $7×8^0+6×8^1+5×8^2$，算出结果为 $375$，就是最终答案。

下面是代码实现：

温馨提示：不开 `long long` 见祖宗

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,k,sum,h;
string s;
int main(){
  scanf("%lld",&T);
  while(T--){
    cin>>k>>s;
    sum=0,h=1;
    for(long long j=s.length()-1;j>=0;j--){
      if(s[j]>='A'&&s[j]<='Z') sum+=int(s[j]-55)*h;
      else sum+=int(s[j]-'0')*h;
      h*=k;
    }
    cout<<sum<<endl;
  }
  return 0;
}
```

---

## 作者：HUANGRUI11 (赞：2)

## 题意描述
给你 $T$ 组数据，每一组数据包含一个数 $n$ 表示接下来输入一个 $n$ 进制数。

要求你将这 $T$ 个数转为十进制数，换行输出。

## 思路
对于 $n$ 进制数从右往左的第 $i$ 位表示 $n^{i-1}$，再用数位上的数去乘即可。

注意：十年 OI 一场空，不开 long long 见祖宗。

记得换行呀。

---

## 作者：TFHS_arsc (赞：2)

## 思路
输入 $ K $ 进制数，我们可以将它放到一个字符串里。从后向前遍历这个字符串，将每一位乘以它的权值并累加，就可以得到结果。这一点其实在题目的“说明/提示”里就说得很清楚了，因此，我们只需要照着做就可以了~
## 代码
```cpp
#include<iostream>
#include<cmath>//数学库头文件，可以使用pow函数求次方 
using namespace std;
int t;
int main(){
	
	//多组输入
	cin>>t; 
	while(t--){
		int k;
		cin>>k;
		string s;
		cin>>s;
		//输入k进制数到字符串s里 
		int len=s.size();//字符串的长度 
		int cnt=0;//cnt来记每一位相加时的次数 
		long long sum=0;//累加十进制结果 
		for(int i=len-1;i>=0;i--){//从后向前遍历 
			int t;
			if(s[i]>='0'&&s[i]<='9') t=s[i]-'0';//t是这一位的数 
			else t=s[i]-'A'+10;//如果是字母，就将它转换为对应的数字 
			
			sum+=t*pow(k,cnt);//累加t乘以权值 
			cnt++;//次数加一 
		}
		cout<<sum<<"\n";//输出十进制数结果 
	}
	
	return 0;
}
```
## 注意事项
累加出的十进制结果有可能超过 `int` 范围，比如 16 进制的 `FFFFFFFFF`，转成十进制后就会爆 `int`。

因此，`sum` 变量应该使用 `long long` 类型。

---

## 作者：Ivan422 (赞：2)

# B3869

题目大意：把 $N$ 个 $K$ 进制数转为 $10$ 进制数。

首先，我们看到说明提示：

> 对于任意一个 $L$ 位 $K$ 进制数，假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L-1$ 位，我们只需要将其第 $i$ 位的数码乘以权值 $K^i$，再将每位的结果相加，即可得到原 $K$ 进制数对应的十进制数。

我们根据这个提示直接去模拟。这里用 $po$ 来记录每一位的权值 $K_i$，$sum$ 记录和。但是大于 $10$ 进制的数可能出现字母。这时候我们进行判断，要是发现字母，对其计算：`字母-'A'+10`。这里用到了字符的计算，最终计算出的 `A` 对应 $10$，`B` 对应 $11$ 等，就可以计算答案了。

注意：数字过大要开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long // 开long long
int n,sum,po;
string s;
int t;
signed main(){
    cin>>t; // 多个数
    while(t--){
        cin>>n>>s; // n 进制数 s
        po=1;sum=0; // 位权和数值
        for(int i=(int)s.size()-1;i>=0;i--){ // 倒着处理
            if(s[i]>='A')sum+=(s[i]-'A'+10)*po; // 字母
            else sum+=(s[i]-48)*po; //数字
            po*=n; // 更新位权
        }
        cout<<sum<<endl; // 输出答案
    }
	return 0;
}
```

---

## 作者：nightwatch.ryan (赞：1)

### 思路
由于读入的 $K$ 进制数里可能出现大写字母，所以要写一个 `toNum` 函数将这个字符转换为数字。

```cpp
int toNum(char ch){
	if(isdigit(ch))return ch-48;//isdigit用于判断是不是数字
	return ch-55;
}
```

将一个 $K$ 进制数转换为十进制数：
- 设 $size$ 为 $K$ 进制数的位数。从左往右数，$K$ 进制数的第 $i$ 位乘以 $K^{size-i-1}$，然后用一个变量记录这个乘积。这个变量就是 $K$ 进制数转换为 $10$ 进制数的结果了。

### 完整代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#define ll long long
int toNum(char ch){
	if(isdigit(ch))return ch-48;
	return ch-55;
}
ll f(std::string s,int base){
	ll ans=0;
	for(int i=0;i<s.size();i++){
		int Number=toNum(s[i]);
		ans+=Number*pow(base,s.size()-i-1); 
	}
	return ans;
}
int main(){
	int n;std::cin>>n;
	while(n--){
		std::string s;
		int base;std::cin>>base>>s;
		std::cout<<f(s,base)<<'\n';
	}
}
```

---

## 作者：_anll_ (赞：1)

~~第一次写 B 题库题解，好兴奋。~~
## 题目大意
给定 $n$ 组进制数 $K$，将其转换为 $10$ 进制数。

## 大体思路
因为对于十一进制往上的数会存在字母，所以我们拿字符串进行存储。

而我们该如何把 $K$ 进制的数转换成 $10$ 进制呢？对于单个数，我们只需要把其转换成对于的数，最后每个转换成不妨我们先拿我们最熟悉的进制进行一个转换：十进制转十进制。$1027=1\times 10^3+0\times 10^2+2\times 10^1+7\times 10^0=1027$。

不难发现，对于 $K$ 进制数从右往左数的第 $x$ 位转换后为 $s_i$，答案就为 $s_i\times K^{x-1}$。

于是代码就呼之欲出啦。

## 代码演示
大体思路就是这样，如果还有不清晰的地方，还请结合代码理解。
```cpp
#include<iostream>
#define int long long
using namespace std;
int t,num,ans,now;
string s;
int qwq(char a){
	if('0'<=a&&a<='9') return a-'0';
	else return a-'A'+10;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		now=1;
		cin>>num>>s;
		for(int i=s.size()-1;i>=0;i--){
			ans+=qwq(s[i])*now;
			now*=num;
		}
		cout<<ans<<endl;ans=0;
	}
	return 0;
}
```

---

## 作者：MsgNotFound (赞：1)

# 题目大意
给定进制数 $K$，将其转换为 $10$ 进制数。
# 思路分析
因为 $K$ 进制中可能有字母，所以读入一个字符串进行判断。$K$ 进制转 $10$ 进制的方法：

假设有一个 $2$ 进制数 $101$，可以进行如下转换：

每一位上数字所代表的含义就是：$K$ 的项数 $-1$ 的次方，这样将每一位相加，得到：

$$1\times2^0+0\times2^1+1\times2^2=5$$

由于最大值可能是 `FFFFFFFF`，会超 `int`，所以我们用 `long long`。
# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;cin>>t; 
	while(t--){
		int k;cin>>k;
		string s;cin>>s;
		int len=s.size(),cnt=0; 
		long long sum=0;
		for(int i=len-1;i>=0;i--){//反向遍历，因为是从各位开始
			int t;
			if(s[i]>='0'&&s[i]<='9') t=s[i]-'0';//判断该字符是否是数字
			else t=s[i]-'A'+10;//如果是字母，就转换为数字
			sum+=t*pow(k,cnt);// 累加
			cnt++;// 次方加一
		}
		cout<<sum<<endl;
	}
	return 0;
}
```

---

## 作者：_Weslie_ (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B3869)。

众所周知进制的本质其实就是每一位乘几。例如十进制，$114514=1\times10^5+1\times10^4+4\times10^3+5\times10^2+1\times10^1+4\times10^0$，八进制的 $345=3\times8^2+4\times8^1+5\times8^0$。

我们可以假定一个进制系数 $p$，且设数位共 $l$ 位，进制为 $n$ 进制，则 $p_l=1,p_{l-1}=p_l\times n=n,p_i=p_{i+1}\times n$。

可以得到这个 $p$ 序列。

所以通过这个 $p$ 序列可以进行进制转换——即将每一位数累加，得到的就是十进制的答案。

详细操作见代码。

```
#include<bits/stdc++.h>
using namespace std;
map<char,int>mp;
string s;
int T,n;
long long _=1;
int main(){
	mp['0']=0;mp['1']=1;mp['2']=2;mp['3']=3;mp['4']=4;mp['5']=5;mp['6']=6;
	mp['7']=7;mp['8']=8;mp['9']=9;mp['A']=10;mp['B']=11;mp['C']=12;mp['D']=13;
	mp['E']=14;mp['F']=15;
	cin>>T;
	while(T--){
		cin>>n>>s;
		long long ans=0;
		_=1;
		for(int i=s.length()-1;i>=0;i--){
			ans=ans+_*mp[s[i]];
			_*=n;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

其中
```
long long ans=0;
_=1;
for(int i=s.length()-1;i>=0;i--){
	ans=ans+_*mp[s[i]];
	_*=n;
}
```
一段的本质就是累加其他进制数在十进制中的表示。在十进制转其他进制时，我们在每一位除以 $n$（得到该位的数值），所以在这里计算时要乘回来。

而
```
mp['0']=0;mp['1']=1;mp['2']=2;mp['3']=3;mp['4']=4;mp['5']=5;mp['6']=6;
mp['7']=7;mp['8']=8;mp['9']=9;mp['A']=10;mp['B']=11;mp['C']=12;mp['D']=13;
mp['E']=14;mp['F']=15;
```
段使用了 ```map```，可以方便快捷地将字符转换为数字。平时我们有字符换数字的公式，但是因为这里出现了大写字母，所以使用 ```map``` 较为方便。

所以这个题就结束了。

---

## 作者：Ice_rnfmabj (赞：1)

题目大意：给出 $N$ 个不同进制的数，然后我们需要把它们转换成对应的十进制数。

我的想法：输入时用字符数组记录每一位的数字，用一个函数将字符转化成数字，然后再用一个函数来计算每一位加起来的和。

将字符转化成数字的函数需要分类写：

- 如果是数字，可以直接 `-'0'`。

- 如果是字母，那么用 ASCII 码来计算一下，便可以得出需要 `-'A'+10`。

而计算总加和的函数就可以用循环一位一位遍历过去，用 pow 函数算出那一位的值并相加，最后返回总和。

注意：OI 十年一场空，不开 long long 见祖宗！

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[10];
long long k;
int to_num(char x){
	if(x>='0'&&x<='9') return x-'0';
	if(x>='A'&&x<='Z') return x-'A'+10;
}
long long int to_ten(char a[],int t){
	long long int len=strlen(a),sum=0;
	for(int i=0;i<len;i++){
		sum+=to_num(a[i])*pow(t,len-i-1);
	}
	return sum;
}
int main(){
	long long t,r,n;
	cin>>n;
	while(n--){
		cin>>t>>a;
		long long g=to_ten(a,t);
		cout<<g<<endl;
	}
	return 0;
}
```

---

## 作者：A_grasser (赞：0)

## 题意简化

输入若干别的进制的数，输出它对应的十进制数。

## 需要注意的地方

1. 运算开 `long long`。 

## 解法分析

进制转换模版，只要知道 $k$ 进制数第 $i$ 位对应十进制的 $n^{i-1}$ 即可。之后就是写一下数字转换函数的事。

最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
int n;
long long k;
string s;
int tonum(char c){//数字转换 
	if('0'<=c && c<='9') return c-'0';
	else return c-'A'+10;
}
long long ton(long long base,string x){//求出对应十进制 
	long long sum=0;
	for(int i=0;i<x.size();i++){
		sum+=(tonum(x[i])*pow(base,x.size()-i-1));//公式 
	}
	return sum;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>k>>s;
		cout<<ton(k,s)<<endl;
	}
    return 0;
}
```

---

## 作者：WydnksqhbD (赞：0)

# [B3869 [GESP202309 四级] 进制转换](https://www.luogu.com.cn/problem/B3869) 题解
## 思路
（为方便，令 $s\to t$ 表示从 $s$ 进制转到 $t$ 进制）

$K$ 进制怎么转 $10$ 进制？

实际上，每一位数都有“位权”。什么意思呢？比如 $324567$ 这个数，$6$ 表示的是 $60$，$5$ 表示 $500$。

容易发现，**从右往左数的第 $i$ 位，位权为 $a_i\times10^{i-1}$**，其中 $a_i$ 表示从右往左的第 $i$ 个数。

那么，$2$ 进制是否也有这个规律呢？当然有。即**从右往左数的第 $i$ 位，位权为 $a_i\times2^{i-1}$**，其中 $a_i$ 表示从右往左的第 $i$ 个数。

同理，$K$ 进制当然也有这个规律。相信看到这里，大家应该都会求了吧？每次只需算出位权然后加起来即可。

注意的是 $16$ 进制中有 `ABCDEF`，所以代码中有一个函数 $f$。大概就是 $1\sim9$ 正常返回，`ABCDEF` 由于其 ASCII 码会转成 $10\sim15$ 返回。

为了储存字符是需要用 `string` 的，而 `string` 下标是从 $0$ 开始的。
## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll n, k, ans, value;
string s;

int f (char c) {
	if (c >= '0' && c <= '9') {
		return c - '0';
	} else {
		return c - 'A' + 10;
	}
}

int main () {
	cin >> n;
	while (n --) {
		cin >> k >> s;
		if (k == 10) {
			cout << s << endl;
			continue;
		}
		value = 1;
		for (ll i = s.size () - 1; i >= 0; -- i) {
			ans += f (s[i]) * value;
			value *= k;
		}
		cout << ans << endl;
		ans = 0;
	}
	return 0;
}
```

---

## 作者：lucasincyber (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3869)
## 思路
很明显，这是一到 $x$ 进制转 $10$ 进制的题。对于每一个 $k$ 进制数 $s$，需要遍历 $s$，若 $size$ 为 $s$ 的长度，$s_i$ 为当前遍历到的数（$1 \le i \le size$），$size$ 为 $s$ 的长度，则答案为：
$$\sum_{i = 1} ^ {size} s_i \times k ^ {size - i}$$

因为 $2≤K≤16$，所以判断每一位时，需要特殊判断 $A$ ~ $E$ 表示的 $11$ ~ $15$（当 $k \ge 11$ 时）。

注意：因为 $s \le 10^{12}$，所以需要开 long long。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int t, n;
string s;

int et(char x)
{
	if (x >= '0' && x <= '9')
        return x - '0';
    else
    	return x - 'A' + 10;
}

int main()
{
	cin >> t;
	while (t--)
	{
		cin >> n >> s;
		long long sum = et(s[s.size() - 1]), jz = 0;
		for (int i = s.size() - 2; i >= 0; i--)
		{
			int nowNum = et(s[i]), jz2 = jz++;
			long long mul = 1;
			while (jz2--)
				mul *= n;
			sum += mul * nowNum * n;
		}
		cout << sum << '\n';
	}
	return 0;
}
```

---

## 作者：xiao_dong_xi (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3869)
### 解题思路
一道很容易理解的题目：把一个 $K$ 进制数转换成十进制。

众所周知，想把一个十进制数变成 $n$ 进制，就是把这个数不断地除以 $n$，直到商为 $0$，每次将得到的余数记录下来。
最后将记录下来的余数倒序排列，即可得到对应的 $n$ 进制数。

反过来，想把一个 $n$ 进制数变成十进制，就是从 $n$ 进制数的最右边开始，每一位数字乘 $n$ 的幂，幂的值取决于该位数字在原数中的位置（最右边的位为 $n^0$，往左依次递增）。
最后将所有乘积相加，得到最终的十进制数。

本题的样例解释就很容易看出。

不难得出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,k;
string s;
long long ans;//记得开longlong! 
int slen,sum,po;
signed main()
{
	cin>>t;
	while(t--)
	{
		ans=0;
		cin>>k>>s;
		slen=s.size();
		po=s.size()-1;
		for(int i=0;i<slen;i++)
		{
			//为了让代码易懂，这里暴力赋值 
			if(s[i]=='A')sum=10;//十六进制中，A表示10，B表示11，C表示12...... 
			else if(s[i]=='A')sum=10;
			else if(s[i]=='B')sum=11;
			else if(s[i]=='C')sum=12;
			else if(s[i]=='D')sum=13;
			else if(s[i]=='E')sum=14;
			else if(s[i]=='F')sum=15;
			else sum=s[i]-'0';
			
			ans+=sum*pow(k,po);//pow(x,y)可以快速求出x^y的值 
			po--;
		}
		cout<<ans<<endl;
	} 
	return 0;
}
```

---

## 作者：a1111a (赞：0)

# 思路
模拟。假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L − 1$ 位，那么转十进制的结果是进制数的位数次方乘每位数值。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,ans;//n表示有多少个数，k表示进制数，ans是十进制的结果
string x;//表示输入数字，大于等于十一进制时含有字母，需要用字符串
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ans=0;
		cin>>k>>x;
		for(int j=0;j<x.length();j++){
			if(x[j]>='0'&&x[j]<='9')//数字和字母分类讨论
				ans+=(x[j]-'0')*pow(k,x.length()-j-1);//转十进制，因为输入时左面是第 0 位，所以要反过来
			else
				ans+=(x[j]-'A'+10)*pow(k,x.length()-j-1);//转十进制，因为输入时左面是第 0 位，所以要反过来
		}
		cout<<ans<<"\n";//输出结果
	}
	return 0;
}
```

---

## 作者：GoodLuckCat (赞：0)

`strtol`，我刚学到的一个函数。这么快就用上了（）

用 `strtol` 来解决这道题太合适了。

啊。顺便说一下 `strtol` 函数的用法。三个参数，第一个是一个数组，第三个是一个数。这个函数会返回这个数组由【第三个参数】进制转换成十进制的结果。

~~代码很简单，就不放了，而且大家都有~~

代码如下（我写题解时习惯放代码）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t,k;
    cin>>t;
    while(t--)
    {
        char kjz[10],*a;
        cin>>k>>kjz;
        cout<<strtol(kjz,&a,k)<<endl;
    }
}
```

---

## 作者：_qhbd_ (赞：0)

# 题意
共 $n$ 个 $k(2\le k\le 16)$ 进制 数，输出其十进制数值。
# 思路
只要你懂进制的概念，就可以做了。

对于如何计算一个十进制数 $123$，不难知道其值为 $((1)\times10+2)\times10+3$，那么此时你应该发现一些端倪了，我们只需要把 $10$ 改成对应的 $k$ 带入计算即可。

当然，你需要维护一下对于字母和对应的值的转换，这个不用多说，并不难。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
string s;
main(){
	scanf("%lld",&n);
	while(n--){
		scanf("%lld",&k);
		cin>>s;
		int res=0;
		for(int i=0;i<s.size();i++){
			res*=k;
			if('0'<=s[i]&&s[i]<='9')res+=(s[i]-'0');
			else res+=(s[i]-'A'+10);
		}
		printf("%lld\n",res);
	}
}
```

---

## 作者：woshinidegou (赞：0)

本蒟蒻在备考，刷题时发现了他。

其实这道题只需要列举出来他的所有情况就好了，非常简单。

先判断它是几进制，如果进制精度低于十进制，那么就直接用每一位上的数乘k的相对应次方；如果进制精度高于十进制，那么先判断这一位上的属于字符还是数字，如果是字符，那么先判断每个字符代表什么，进行运算；如果是数字，那么直接运算，最后将每次运算后的结果相加就是这个数转化成十进制的结果。

话不多说，上代码 ↓
```cpp
#include<bits/stdc++.h>
using ll=long long;
using namespace std;
int main(){
	ll a;
	cin>>a;
	for(ll j=0;j<a;j++){
		ll k,n=0;
		string x;
		cin>>k;
		cin>>x;
		if(k<=10){
			for(ll i=0;i<x.size();i++){
				n+=((x[i]-'0')*pow(k,x.size()-i-1));
			}
		}else if(k>10){
			for(ll i=0;i<x.size();i++){
				if(x[i]=='A'){
					n+=(10*pow(k,x.size()-i-1));
				}else if(x[i]=='B'){
					n+=(11*pow(k,x.size()-i-1));
				}else if(x[i]=='C'){
					n+=(12*pow(k,x.size()-i-1));
				}else if(x[i]=='D'){
					n+=(13*pow(k,x.size()-i-1));
				}else if(x[i]=='E'){
					n+=(14*pow(k,x.size()-i-1));
				}else if(x[i]=='F'){
					n+=(15*pow(k,x.size()-i-1));
				}else{
					n+=((x[i]-'0')*pow(k,x.size()-i-1));
				}
			}
		}cout<<n<<endl;
	}return 0;
}
```

---


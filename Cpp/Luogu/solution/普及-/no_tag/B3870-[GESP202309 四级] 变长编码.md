# [GESP202309 四级] 变长编码

## 题目描述

小明刚刚学习了三种整数编码方式：原码、反码、补码，并了解到计算机存储整数通常使用补码。但他总是觉得，生活中很少用到 $2^{31}-1$ 这么大的数，生活中常用的 $0\sim 100$ 这种数也同样需要用 $4$ 个字节的补码表示，太浪费了些。
热爱学习的小明通过搜索，发现了一种正整数的变长编码方式。这种编码方式的规则如下：

1. 对于给定的正整数，首先将其表达为二进制形式。例如，$(0)_{\{10\}}=(0)_{\{2\}}$，$(926)_{\{10\}}=(1110011110)_{\{2\}}$。

2. 将二进制数从低位到高位切分成每组 $7$ bit，不足 $7$bit 的在高位用 $0$ 填补。例如，$(0)_{\{2\}}$ 变为$0000000$ 的一组，$(1110011110)_{\{2\}}$ 变为 $0011110$ 和 $0000111$ 的两组。

3. 由代表低位的组开始，为其加入最高位。如果这组是最后一组，则在最高位填上 $0$，否则在最高位填上 $1$。于是，$0$ 的变长编码为 $00000000$ 一个字节， $926$ 的变长编码为 $10011110$ 和 $00000111$ 两个字节。

这种编码方式可以用更少的字节表达比较小的数，也可以用很多的字节表达非常大的数。例如，$987654321012345678$ 的二进制为 $(0001101 \ 1011010 \ 0110110 \ 1001011 \ 1110100 \ 0100110 \ 1001000 \ 0010110 \ 1001110)_{\{2\}}$，于是它的变长编码为（十六进制表示） `CE 96 C8 A6 F4 CB B6 DA 0D`，共 $9$ 个字节。

你能通过编写程序，找到一个正整数的变长编码吗？

## 样例 #1

### 输入

```
0```

### 输出

```
00```

## 样例 #2

### 输入

```
926```

### 输出

```
9E 07```

## 样例 #3

### 输入

```
987654321012345678```

### 输出

```
CE 96 C8 A6 F4 CB B6 DA 0D```

# 题解

## 作者：we_are_the_chuibing (赞：74)

简单的一道模拟题。

### 思路

先将 $n$ 拆成二进制下 $7$ 位一截的形式，再在第一位判断是否是最高位。最后转十六进制直接输出。

具体见代码。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
string a="0123456789ABCDEF";//十六进制的数字
void print(int i){//输出
	cout<<a[i/16]<<a[i%16]<<" ";
}
int main(){
	cin>>n;
	if(n==0){cout<<"00";return 0;}//0需要特判
	while(n>0){
		int k=n%128;//2^7=128，7位一截
		n/=128;
		if(n>0)print(k+128);//判断是否为最高位
		else print(k);
	}
	return 0;
}
```

本题数据较水，不特判 $0$ 也能过。建议添加 $n=0$ 的数据。

---

## 作者：Francium_ (赞：8)

# 题目大意
一个正整数，将二进制下的数 $7$ 位一段，不足的补 $0$。  
之后，将除了最高段，其他所有段在头部添 $1$，比如有一段非最高段如下： $0101001$，那操作后变为 $10101001$。  
最后，输出操作后每一段的十六进制表示，不足的补 $0$。

# 思路
一开始用模拟做的，那代码叫一个~~又臭又长~~，还过不了题，于是决定换一种思路写，既然是编码，位运算？  
越想越觉得合理，于是乎用位运算吧。
- 取末尾 $7$ 位的操作，按位与上一个```0x7f```（也就是  $127$ ）就行了。
- 我判断是否是最高位的方法用了一个```cnt```，先把 $n$ 转成二进制，再统计位数就行。
- 添 $1$ 的话加上个 $128$ 就行了，想不通的可以手动模拟一下。

# 上代码!
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//不开long long见祖宗！！！第三个样例调了好久才发现long long的事情。。。

void toHEX(int x) {
	stack<char>sta;
	if (x < 16)//补0
		cout << 0;
	while (x) {
		int xx = x % 16;
		if (xx >= 10)
			sta.push((char)('A' + (xx - 10)));
		else
			sta.push((char)(xx + '0'));
		x /= 16;
	}
	while (!sta.empty()) {
		cout << sta.top();
		sta.pop();
	}
	cout << " ";
}

int binlen(int x) {//一个很笨的位数统计
	int cnt = 0;
	while (x) {
		cnt++;
		x /= 2;
	}
	return cnt;
}

signed main() {
	int n;
	cin >> n;
	if (!n) {//特判0！！！否则第一个样例没输出！
		puts("00");
		return 0;
	}
	int len = binlen(n), cnt = 1;
	while (n) {
		int x = n & 127;//取末7位
		if (cnt != len / 7 + 1)
			x += 128;//添1
		cnt++;
		toHEX(x);
		n >>= 7;//把最后一节去除
	}
	return 0;
}
```

---

## 作者：Java21 (赞：7)

## 一道简单的位运算题
## 思路：
- 输入；
- 循环截取 $7$ 位二进制；
- 按照题目要求填补最高位；
- 转换成 $16$ 进制；
- 输出。

## 具体实现:
- 截取二进制可以用 `num & 0x7f` 实现；
- 转为十六进制不需要手动转换，可以直接用 ：`sprintf(ch,"%02x",temp)` 实现；
- 由于 `sprintf` 转成的十六进制为小写字母，还需用 `toupper` 转成大写字母。

## 代码如下:
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int main(void) {
	long long num;
	cin >> num; // 输入
	while(num) {
		int end7 = num & 0x7f; // 截取二进制
		if(num>>7>0) end7 = end7 | 0x80; // 填补高位
		num >>= 7;
		char ch[3];
		sprintf(ch,"%02x",end7); // 转换进制
		if(isalpha(ch[0])) ch[0] = toupper(ch[0]); // 改为大写
		if(isalpha(ch[1])) ch[1] = toupper(ch[1]);
		cout << ch << " "; // 输出
	}
	return 0;
} 
```

---

## 作者：封禁用户 (赞：5)

主要思路：
1. 将给定的整数转换为二进制形式。
2. 将二进制数切分成每组 $7$ 位的块，并在需要的地方用 $0$ 填充以确保每个块都是 $7$ 位。
3. 为每个块添加最高位：如果这是最后一个块，则添加 $0$；否则添加 $1$。
4. 将每个块转换为十六进制表示，并输出。


代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;
unsigned long long n; 
int a[210] = {0}, l = 0, i = 0, c[100], sum, w;
string s, b, ans;
int main(){
	cin>>n;
	if(n==0){
		cout<<"00";
		return 0;
	}
	while(n){
		int sum=n%2;
		a[++l]=sum;
		n/=2;	
	}
	while(i * 7 <= l){
		i++;
		for(int j = 1; j <= 7; j++)s += a[(i - 1) * 7 + j] + '0';
		if(i * 7 < l)s += '1';
		else s += '0';
		for(int j = s.size() - 1; j >= 0; j--)b += s[j];
		for(int j = 0; j < b.size(); j++)c[j] = b[j] - '0';
		sum = 0;
		w = 1;
		for(int j = b.size() - 1; j >= 0; j--){
			sum += c[j] * w;
			w *= 2;
		} 
		int w = sum;
		while(w){
			int sum = w % 16;
			if(sum >= 10)ans += sum + 55;		
			else ans += sum + 48; 
			w /= 16;	
		}
		if(ans.size() == 1)cout << "0";
		for(int j = ans.size()-1; j >= 0; j--)cout << ans[j]; 
		cout << " ";ans = "";b = "";s = "";
	}
	return 0;
}
```

---

## 作者：ShanCreeperPro (赞：5)

欢迎大家报名[洛谷网校](https://class.luogu.com.cn)的课程，期待和大家一起进步！

## 思路分析

本题考字符串综合运用。

对于题目的要求，可以化简为：转二进制、每 $7$ 个数分一组不足补 $0$、除最后一组头添 $0$ 其他头添 $1$，转化十六进制。

我们可以定义函数 `ToHex` 将编码转化为十六进制字符串，设计思路如下：

- **先定义一个字符数组** `0123456789ABCDEF`，用于函数中将整数的每一位转化为对应的十六进制字符；
- **使用 `do-while` 循环处理每一位整数**，用 `&` 提取最低的 $7$ 位，然后用 `>>` 将整数右移 $7$ 位，如果不是最后一位，则在最高位设置 $1$；
- **随后，将编码转化为十六进制字符**，并存在结果字符串 $r$ 中。

转化完后，根据题目要求，两个字符后需要添加空格输出即可。

## 核心代码

`ToHex` 的设计思路在以上，以下为代码实现：

```cpp
void ToHex(int n, char* r, size_t rs) {  
    size_t index = 0;  
    do {  
        int g = n & 0x7f; 
        n >>= 7;          
        if (n > 0) g |= 0x80; 
        r[index++] = hexc[g >> 4];  
        r[index++] = hexc[g & 0x0f]; 
    } while (n > 0);  
    r[index] = '\0';  // 添加字符串结束符
}
```

转化为十六进制的思路：在这里 `g >> 4` 和 `g & 0x0F` 是两种位操作，用于分别获取 `g` 的高 $4$ 位和低 $4$ 位：

- `g >> 4`：右移操作，将 `g` 的所有位向右移动 $4$ 位。这样，原本的高 $4$ 位就变成了低 $4$ 位，而原本的低 $4$ 位则被丢弃了。
- `g & 0x0F`：与操作，将 `g` 与 `0x0F`（即二进制的 `00001111`）进行与运算。这样，只有 `g` 的低 $4$ 位会被保留下来，高 $4$ 位则会被清零。

## 注意事项

- 注意每两个字符后就需要有空格；
- `hexc` 是指 `0123456789ABCDEF`。



---

## 作者：封禁用户 (赞：3)

## 思路：
- 按题目要求定义好需要的变量，并实现输入。
- 根据题意，将 $n$ 对应的二进制，每 $7$ 位 $1$ 组，保存起来。
- 除了包含最高位那组，其他组最前面都增加 $1$，例如中间一组是 $0001111$，最前面加 $1$ 变 $10001111$。
- 注意输出是先输出低位的数组，输出内容用 $16$ 进制表示即可。
## 代码呈上：
```cpp
#include <iostream>
using namespace std;
long long n;
//数字转16进制字符
char trs(int x){
    if (x>9){
        return x-10+'A';
    }else{
        return x+'0';
    }
}
int main() {
    cin>>n;
    while (n>0){
        int t=n&0x7f;//取最后7位
        if (n>0x7f){//不是最高段
            t|=0x80;//首位加1
        }
        cout<<trs(t>>4)<<trs(t&0xf)<<" ";
        n=(n>>7);//去掉最后7位
    }
    return 0;
}
```

---

## 作者：_qhbd_ (赞：2)

# 题意
给定数 $n$，将其转为二进制然后将其从低位到高位每 $7$ 位分为一组，若最高位分组时不足 $7$ 位，则用前导零补齐。

对于从低位到高位的每组，若其是最后一组，则在最高位补 $0$，否则补 $1$。

对于每一组，输出其对应的十六进制。
# 思路
首先将 $n$ 十进制转换为二进制，然后若其长度对 $7$ 取模有余则补前导零。

根据题意，不难知道分配了最高位的一组最高位补 $0$，其他补 $1$。最后对于每组二进制转十六进制即可。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
string s,ans;
main(){
	scanf("%lld",&n);
	if(n==0)s="0";
	while(n){
		s=(char)(n%2+'0')+s;
		n>>=1;
	}
	while(s.size()%7)s="0"+s;
	for(int i=0,res;i<s.size();i++){
		if(i%7==0)res=i?1:0;
		res*=2;
		res+='A'<=s[i]&&s[i]<='Z'?s[i]-'A'+10:s[i]-'0';
		if((i+1)%7==0){
			ans=" "+ans;
			ans=(char)(res%16>9?res%16-10+'A':res%16+'0')+ans;
			ans=(char)(res/16>9?res/16-10+'A':res/16+'0')+ans;
		}
	}
	cout<<ans;
}
```

---

## 作者：Jasoncwx (赞：2)

[题目传送门！](/problem/B3870)
## 题目思路
这道题除了可以使用简便的方法，我们也可以直接按照题目模拟。

要注意的地方就是进制转换。

操作一：我们可以循环每次除以 $2$ 得到这个数的二进制。

操作二：首先我们算出二进制数的长度，对 $7$ 取模。若等于 $0$，不需要操作，否则在前面加上 $7-(len \bmod7)$ 个 $0$。

操作三：首先看看是否为最后一组即可。接着我们可以先把这些二进制转换为 $10$ 进制，然后再转换为 $16$ 进制输出，这样更便捷。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n;
    cin>>n;
	long long zc=n;
	string two,s[100005];
    int base=log2(n);
	long long big=powl(2,base);
	for(long long i=big;i>=1;i>>=1){
		if(n>=i)two+="1",n-=i;
		else two+="0";
	}
	if(zc==0)two="0";
	n=zc;
  //上面的代码是题目中的第一个操作
	int plus;
	if(two.size()%7)plus=7-two.size()%7;
	else plus=7;
  //这个判断语句是题目中的第二个操作
	for(int i=1;i<=plus;i++)two="0"+two;
	int cnt=0;
	for(int i=0;i<two.size();i+=7){
		s[cnt]=two.substr(i,7);
		cnt++;
	}
	int tt=two.size()/7;
	for(int i=1;i<tt;i++)s[i]="1"+s[i];
	s[0]="0"+s[0];
  //上面的代码是题目中的第三个操作
  //下面的代码是把变长编码转换为十六进制并输出
	long long a[100005];
	for(int i=0;i<tt;i++)a[i]=stoi(s[i], nullptr, 2);//把做完全部操作的字符串（二进制）每一段都转换为十进制
	for(int i=tt-1;i>=0;i--){//再转换为十六进制输出
		int tall=a[i]/16,small=a[i]%16;
		if(tall>=10)cout<<char(tall-10+'A');
		else cout<<tall;
		if(small>=10)cout<<char(small-10+'A');
		else cout<<small;
		cout<<" ";
	}
}
```

---


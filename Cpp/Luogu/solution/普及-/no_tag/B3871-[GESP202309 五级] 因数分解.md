# [GESP202309 五级] 因数分解

## 题目描述

每个正整数都可以分解成素数的乘积，例如： $6=2\times 3$，$20=2^2\times5$。

现在，给定一个正整数，请按要求输出它的因数分解式。

## 样例 #1

### 输入

```
6```

### 输出

```
2 * 3```

## 样例 #2

### 输入

```
20```

### 输出

```
2^2 * 5```

## 样例 #3

### 输入

```
23```

### 输出

```
23```

# 题解

## 作者：Clarinet (赞：80)

[博客食用观感更佳](https://www.luogu.com.cn/blog/Czel-X/ti-xie-12-post)
# 简要题意
给出一个正整数 $N$，求它的因数分解式。
# 分析
题目不难，就是得注意一下细节。

不过既然在入门题库，就给像我一样的萌新讲解一下原理。最简单的做法，是直接从小开始遍历因数。

举个例子，最开始的 $2$ 和 $3$ 都是质数。假如这个数有一个合数因数 $6$，那么这个因数 $6$ 一定在刚才被替换为 $2$ 和 $3$ 了，所以直接从小找因数输出的一定全是质数。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a;
int p=0;
int main(){
	cin>>n;
	a=n;
	for(long long i=2;i<=sqrt(n);i++){
		if(a%i==0){
			int s=0;
			while(a%i==0){
				a/=i;
				s++;
			}
			if(p)cout<<"* ";
			if(s!=1)cout<<i<<"^"<<s<<" ",p=1;
			else cout<<i<<" ",p=1;
		}
	}
	if(a!=1){
		if(a!=n)cout<<"* "<<a;
		else cout<<a;
	}
	return 0;
}
```
感谢阅读！

---

## 作者：zzx114514 (赞：22)

## [题目传送门](https://www.luogu.com.cn/problem/B3871)
# 题目大意
对 $n$ 分解质因数，且 $1\le n \le 10^{12}$。
# 解题思路
先看数据范围，$O(n)$ 显然不行，但可以在枚举质因数时只枚举到 $\sqrt{n}$，在最后输出未分解的质因数即可。  
注意不用判断枚举到的因数是否为质数，因为在分解时，枚举到的每个质数都会将合数因数彻底分解，因此不会枚举到合数因数。
# 完整代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,cnt;
int main()
{
	cin>>n;
	for (ll i=2;i*i<=n;i++)//记得开long long，从2开始
	{
		cnt=0;//记录质因数个数
		if (n%i==0)//如果i是质因数
		{
			while(n%i==0)//一直分解直到无法分解为止
			{
				n/=i;
				cnt++;
			}
			if (cnt==1) cout<<i;//如果只有一个，不用输出指数
			else cout<<i<<'^'<<cnt;//否则输出指数
			if (n>1) cout<<" * ";//如果不是最后一个质因数就输出乘号
		}
	}
	if (n>1) cout<<n;//如果没分解干净就输出剩下的质因数
	return 0;
}

```


---

## 作者：Brain_Huger (赞：12)

## 题意

> 给你一个数，分解质因数，$1\le n\le10^{12}$

## 思路

直接从小到大枚举这个数的每一个质因子，因为质因子一定最小，所以即可保证枚举出来的一定是质数，求出这个质因子有几个。

代码如下：
```
#include<bits/stdc++.h>
#define int long long
#define D(x) std::cerr<<#x<<'='<<x;
int n,pd;
void solve(int x){
	for(int i=2;x>1&&i<=x;i++){
		if(x%i==0){
			int cnt=0;
			while(x%i==0)x/=i,cnt++;
			if(pd){
				printf("* ");
			}
			else pd=1;
			if(cnt>1)printf("%lld^%lld ",i,cnt);
			else printf("%lld ",i);
		}
	}
}
bool q(int x){
	if(x==1)return 0;
	for(int i=2;i*i<=x;i++)if(x%i==0)return 0;
	return 1;
}
signed main(){
	scanf("%lld",&n);
	if(q(n))printf("%lld",n);
	else solve(n);
	return 0;
}
```

但是...喜提 $80$ 分。

为什么呢？思考分解质因数过程，会发现每次输出完可以判断一下剩下的因子是否为质数，若是，那么就直接输出，结束循环，这样就不会被类似 $ 10000000019\times3$ 这样的数据卡寄了。

代码：

```
#include<bits/stdc++.h>
#define int long long
#define D(x) std::cerr<<#x<<'='<<x;
int n,pd;
bool q(int x){
	if(x==1)return 0;
	for(int i=2;i*i<=x;i++)if(x%i==0)return 0;
	return 1;
}
void solve(int x){
	for(int i=2;x>1&&i<=x;i++){
		if(x%i==0){
			int cnt=0;
			while(x%i==0)x/=i,cnt++;
			if(pd){
				printf("* ");
			}
			else pd=1;
			if(cnt>1)printf("%lld^%lld ",i,cnt);
			else printf("%lld ",i);
			if(q(x)){printf("* %lld",x);return;}
		}
	}
}
signed main(){
	//freopen("bed.in","r",stdin);
	//freopen("bed.out","w",stdout);
	scanf("%lld",&n);
	if(q(n)){printf("%lld",n);return 0;}
	solve(n);
	return 0;
}
```

---

## 作者：wangjue1629 (赞：8)

# Solution
[题目传送门](https://www.luogu.com.cn/problem/B3871)

## 题目分析
这道题要求对一个正整数进行质因数分解，并按照格式输出。质因数分解是将一个正整数分解为若干素数（质数）相乘的形式。如 $6$ 可以分解为 $2 \times 3$，$20$ 可以分解为 $2^2 \times 5$。

## 解题步骤
1. 从最小的质数 $2$ 开始，逐个检查每个数是否是给定数字的因数。
2. 当发现一个因数时，通过循环除以这个因数，计算它出现的次数 $cnt$。
3. 对于大于 $\sqrt{n}$ 的部分，如果 $n$ 大于 $1$，则 $n$ 本身就是一个因数。
4. 格式化输出：根据题目要求格式化输出结果。当一个因数出现多次时，使用指数形式表示。

## AC Code
```cpp
#include<iostream>
#define ll long long
using namespace std;
int main(){
    ll n; cin >> n;
    bool flag = true; //flag 用于控制输出格式
    for (ll i = 2; i * i <= n; i++){
        int cnt = 0; //cnt 表示因数 i 出现的次数
        while (n % i == 0){ //当 i 是 n 的因子时
            n /= i; //除以因子 i
            cnt++; //增加 cnt
        }
        if (cnt > 0){ //如果 i 是因子
            if (!flag) cout << " * "; //如果不是第一个因子，输出乘号
            cout << i; //输出因子
            if (cnt > 1) cout << "^" << cnt; //如果因子出现多次，输出指数形式
            flag = false; //更新 flag
        }
    }
    if (n > 1){ //如果剩余的 n 大于 1，代表 n 本身就是一个因数
        if (!flag) cout << " * ";
        cout << n;
    }
    return 0;
}
```
时间复杂度：$O(\sqrt{n})$，可以通过本题。

---

## 作者：lbh666 (赞：4)

题目意思很好理解，下面来讲解做法。

## 思路
- 如果 $n$ 是质数，直接输出即可。

- 如果不是质数，考虑如下分解。

- 第一种，不断地把 $n$ 一直除，直到 $1$ 为止，只能得 $70$ 分。

- 第二种，只要枚举到 $\sqrt{n}$ 就可以了，如果还有剩，直接输出即可，因为只会剩一个。证明：如果有剩下两个质因子没有分解，就说明它们都大于 $\sqrt{n}$，相乘必定大于 $n$，不成立，故得证。

## 代码演示
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll n;

void solution(ll n){
	ll tot=0,n2=n;
	bool flag=0;
	for(int i=2;i<=sqrt(n);++i){
		if(n2%i==0){//判断如果是第一个质因子，不用输出乘号 
			if(!flag){flag=1;cout<<i;} 
			else cout<<" * "<<i;
		} 
		while(n2%i==0){n2/=i;tot++;}//分解 
		if(tot>1)cout<<"^"<<tot; 
		tot=0;
		if(n2==1)break; 
	}
	if(n2!=1)cout<<" * "<<n2<<"\n"; //还有剩的处理 
	return ;
}

bool is_prime(ll n){
	for(int i=2;i<=sqrt(n);++i){
		if(n%i==0)return 0;
	}
	return 1;
}

int main(){
	cin>>n;
	if(is_prime(n)){//如果是质数，直接输出 
		cout<<n;
		return 0; 
	}
	solution(n);
	return 0;
}
```

---

## 作者：流光萤影 (赞：4)

## 前言：

**本题解使用语言：C++14 O2。**

## 正文：

思路：用**欧拉筛**筛出小于 $10^7$ 的素数，再**将 $n$ 分解为小于等于 $10^7$ 的因数**，再**对这些因数分解质因数**。

------------

**AC 代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int primes[664581],cnt,num[10000005],y[10000005],flag,mx;bitset<10000005> status;long long n;
void euler()
{
	for(int i(2);i <= 1e7;++i)
	{
		if(!status[i]) primes[++cnt] = i;
		for(int j(1);j <= cnt && primes[j]*i <= 1e7;++j)
		{
			status[i*primes[j]] = true;y[i*primes[j]] = primes[j];
			if(!(i%primes[j])) break;
		}
	}
	return;
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);status[0] = status[1] = true;euler();cin >> n;
    while(n > 1e7)
    {
		mx = 0;
		for(long long i(2);i*i <= n;++i) if(!(n%i)) mx = i;
		if(!mx)
		{
			for(int i(1);i <= 1e7;++i)
			{
				if(num[i])
				{
					if(flag) cout << " * ";
					else ++flag;
					if(num[i]^1) cout << i << "^" << num[i];
					else cout << i;
				}
			}
			if(flag) cout << " * ";
			cout << n;
			return 0;
		}
		else
		{
			int tmp = mx;
			while(y[tmp]) ++num[y[tmp]],tmp /= y[tmp];
			++num[tmp];n = n/mx;
		}
	}
	while(y[n]) ++num[y[n]],n /= y[n];++num[n];
	for(int i(1);i <= 1e7;++i)
	{
		if(num[i])
		{
			if(flag) cout << " * ";
			else ++flag;
			if(num[i]^1) cout << i << "^" << num[i];
			else cout << i;
		}
	}
}
```

---

## 作者：Darkworldmystery (赞：3)

原题链接：[[GESP202309 五级] 因数分解](https://www.luogu.com.cn/problem/B3871)

## 题意

将一个数 $n$ 分解质因数，并按格式输出。

## 思路

因为我们需要将这个数拆的尽可能碎，所以我们可以从小到大枚举质因子，然后用枚举到的最小因子 $i$ 除 $n$，除到不能除为止，这样可以尽可能完整分化 $n$。同时在除的时候统计这个数被除了几次，即乘方次数。

其次，格式输出对因子 $i$ 分解后的结果。

一些细节：

1. 如果这个数就是质数，那么直接输出它走人。

2. 如果最后分解完了出来个质数（没分解完），再次输出剩余部分完美结束。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t, n, sqsum;
bool timeflag;
bool isprime(int x)
{
    if(x < 2)
        return 0;
    for(int i = 2; i * i <= x; i++)
        if(x % i == 0)
            return 0;
    return 1;
}
signed main()
{
    cin >> t;
    n = t;
    if(isprime(t)) // 如果是质数直接用本身输出
    {
        cout << t;
        return 0;
    }
    for(int i = 2; i * i <= t; i++) // 枚举因数
        if(n % i == 0) // 如果可以用当前因子 i 拆分
        {
            sqsum = 0; // 乘方总数初始化
            while(n % i == 0)
                n /= i, sqsum++; // 计算这个数里的因数 i 有几个
            if(timeflag) // 需要乘号衔接
                cout << "* ";
            if(sqsum != 1) // 一次方不需要用乘方形式
                cout << i << "^" << sqsum << " ", timeflag = 1; // 按照格式输出，以及下一个式子需要用 * 连接，将 timeflag 设为 true
            else
                cout << i << " ", timeflag = 1; // 一次方直接输出 i 就可以了，同样需要用 * 连接
        }
    if(n != 1) // 分解到最后出来个质数
        cout << "* " << n; // 无法分解，直接输出
    return 0;
}
```

---

## 作者：Big_Dinosaur (赞：3)

数学题。

$70$ 分：依次枚举个个质因数，设为 $i$，将 $n$ 不断除以 $i$，知道无法整除位置，统计它的个数，为 $Cnt$，再输出即可。

$100$ 分：进行剪枝。其实，$i$ 只需要枚举到 $\sqrt{n}$ 为止，若 $n$ 不为 $1$，再补刀输出。因为一个数中比 $\sqrt{n}$ 大的质因数最多一个，最后补刀的就是它。

下面是代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace ZYT{
int n,Cnt,i=2,fi=1;
inline void _(){
cin>>n;
while(n!=1&&i*i<=n){
if(n%i==0){
if(fi)fi=0;else cout<<" * ";Cnt=0;
while(n%i==0){n/=i;++Cnt;}
cout<<i;if(Cnt!=1)cout<<'^'<<Cnt;
}
++i;
}
if(n!=1){
if(!fi)cout<<" * ";printf("%lld",n);//补刀
}
}
}
signed main(){ZYT::_();}
```

---

## 作者：wangqinyan (赞：3)

这题思路与代码实现其实都很简单。

**题目思路**

这题其实就是一个数学题，就是个分解质因数。但最基础的分解质因数只能拿 $70$ 分。想 $100$ 分需要优化。在分解质因数时，最多只有一个数大于 ``n`` 的平方根。因此，我们可以将其留到最后单独处理。这样的话，就只要循环到 ``n`` 的平方根就可以了。最后，如果 ``n`` 不是 $1$，那么把 ``n`` 再输出，解释如上。

**注意点**

输出乘号时，左右两边都要有一个空格
。

**代码**
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,b=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')b=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*b;
}
inline void write(int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10^48);
	return;
}
long long n,s,x;
bool p;
int main()
{
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
	cin>>n;
	s=2;//质因数从2开始分解 
	p=true;
	while(n!=1&&s*s<=n)//优化，解释如上所述 
	{
		if(n%s==0)
		{
			if(p)p=false;//判断是否是第1个因数，要不要输出乘号 
			else cout<<" * ";
			x=0;
			while(n%s==0)//分解质因数 
			{
				n/=s;
				x++;
			}
			cout<<s;
			if(x!=1)cout<<"^"<<x;
		}
		s++;
	}
	if(n!=1)//对唯一一个可能大于n的平方根的数是否存在进行判断 
	{
		if(!p)cout<<" * ";
		cout<<n;
	}
//    fclose(stdin);
//    fclose(stdout);
	return 0;
}
 
```
感谢观看！

---

## 作者：Jasoncwx (赞：2)

## 题目思路
这道题考查的是质因数分解。

我们可以定义一个 `bool` 类型函数 `prime` 判断某个数是否为质数。

如果我们按照普通的方法，循环 $2\sim n$，因为 $n\le10^{12}$，肯定会超时。经过测试，可以拿到 $70$ pts 的好成绩。

由于最多有一个质因数大于 $\sqrt{n}$，所以我们可以把循环缩减至 $2\sim\sqrt{n}$，最后再判断是否还有一个质因数。

还有一个优化：循环时，如果 $n\nmid i$，可以直接跳过这一次循环。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
bool prime(ll n){//判断是否为质数
    for(ll i=2;i*i<=n;i++){
        if(n%i==0)return false;
    }
    return true;
}
int main(){
    ll n,t;
    cin>>n;
    t=n;
    bool first=false;//判断是否为第一个数
    for(ll i=2;i<=sqrt(t);i++){
		if(n%i)continue;
        int sum=0;
        if(prime(i)){
            while(n%i==0&&n){
                n/=i;
                sum++;
            }
        }
        if(first&&sum)cout<<"* ";
        else if(sum)first=true;
        if(sum>1)cout<<i<<"^"<<sum<<" ";
        else if(sum)cout<<i<<" ";
    }
	if(n!=1){//还有一个质因数
		if(t!=n)cout<<"* "<<n;
		else cout<<n;
	}
}
```


---

## 作者：enyyyyyyy (赞：2)

思路：大模拟。从 $2$ 到 $\sqrt n$ 去遍历，如果能整除，就除到底，统计次数，再分条判断。

- 如果大于 $1$，输出 `^`，且剩下的不等于 $1$，输出 ` * ` 。
- 如果大于 $1$，输出 `^`，且剩下的等于 $1$，不输出。
- 如果等于 $1$，且剩下的不等于 $1$，不输出。 
- 如果等于 $1$，且剩下的等于 $1$，输出 ` * ` 。



```cpp
#include <bits/stdc++.h>
#define ll long long
#define lint __int128
using namespace std;
inline ll read() {
	ll s = 0, w = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-')
			w = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
	return s * w;
}
inline void print(ll x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x >= 10)
		print(x / 10);
	putchar(x % 10 + '0');
	return;
}
ll n,m;
int main() {
	n=read(),m=n;
	for(ll i=2;i*i<=n;i++){
		ll cnt=0;
		while(m%i==0) m/=i,cnt++;
		if(cnt==1&&m!=1) print(i),printf(" * ");
		if(cnt==1&&m==1) print(i),printf("");
		if(cnt>1&&m==1) print(i),printf("^"),print(cnt),printf("");
		if(cnt>1&&m!=1) print(i),printf("^"),print(cnt),printf(" * ");
	}
	if(m!=1) print(m);
	return 0;
}
```


---

## 作者：ZnHF (赞：2)

[题目链接](https://www.luogu.com.cn/problem/B3871)

# 题意简述

给定一个正整数 $N$，将它的因数分解式按规定输出。

# 题目分析

模拟题意即可。

具体地，我们可以枚举 $2$ 到 $\lfloor \sqrt N \rfloor$ 中所有数 $i$，如果 $i$ 能整除 $N$，则不断地从 $N$ 中除掉 $i$，直到 $i$ 不再能整除 $N$，在这个过程中，我们同时需要统计被除掉的每个 $i$ 的个数。

注意，本题中 $N$ 的规模为 $2 \le N \le 10^{12}$，需要开 `long long`。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,p[1000005],c[1000005];
signed main(){
	cin>>n;
	int N=n;
	for(int i=2;i<=sqrt(N);i++){
		if(!(n%i)){
			p[++m]=i;
			c[m]=0;
			while(!(n%i)){
				n/=i;
				c[m]++;
			}
		}
	}
	if(n>1){
		p[++m]=n;
		c[m]=1;
	}
	for(int i=1;i<=m;i++){
		if(i==m){
			if(c[i]==1){
				cout<<p[i];
			}
			else{
				cout<<p[i]<<"^"<<c[i];
			}	
			continue;		
		}
		if(c[i]==1){
			cout<<p[i]<<" * ";
		}
		else{
			cout<<p[i]<<"^"<<c[i]<<" * ";
		}
	}
	return 0;
}
```


---

## 作者：So_noSlack (赞：2)

## 题目简述

给定 $N$，输出 $N$ 分解质因数之后的形式。

## 思路

先从 $2$ 遍历到 $\sqrt N$，若当前 $i$ 为 $N$ 的因数，记录 $N$ 拥有 $i$ 的个数，即时输出即可。

这里需要注意几点：

1. 需要特判 $N$ 的第一个因数，此时无需输出 `*`。

2. 如果到最后 $N$ 不为 $1$，需输出 $N$。

3. $N$ 为质数的情况。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

long long n; // 需要开 long long
bool flag = true; // 记录 N 的第一个因数是否被找到

int main() {
	scanf("%lld", &n);
	for(long long i = 2; i <= sqrt(n) && n != 1; i ++) {
		if(n % i) continue; // 不是 N 的因数直接 continue;
		long long dex = 0; // 记录个数
		while(!(n % i)) n /= i, dex ++;
 		// 复杂判断
		if(dex > 1 && flag) { printf("%lld^%lld", i, dex); flag = false; }
		else if(dex > 1) printf(" * %lld^%lld", i, dex);
		else if(flag) { printf("%lld", i); flag = false; }
		else printf(" * %lld", i);
	}
	if(n != 1) 
		if(flag) printf("%lld", n); // N 为质数
		else printf(" * %lld", n); // N 仍有大质数
    return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/135248088)

---

## 作者：nkrqzjc_zzz (赞：2)

### [题目链接](https://www.luogu.com.cn/problem/B3871)
------------
### 思路
从 $2$ 枚举所有小于 $\sqrt{n}$ 的数，如果 $n$ 能整除枚举的这个数，就将 $n$ 中所有能分解出来的数，全部除掉。可是题目要求找出所有质数呀？枚举全部不会错吗？

很好，答案是**不会**。这里就要涉及一点点数论基础知识了。众所周知，合数一定能表示成某几个质数相乘，并且这些质数均小于此合数。那么从 $2$ 枚举到 $\sqrt{n}$ 就一定不会出现除以合数的情况。

更多详情请看代码讲解哟！
### 代码
```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
ll n,m,z,i;bool ji;//n如题所述，m为n的初始值，z为记录答案的指数，ji为判断是否为第一个答案 
main(){
	scanf("%lld",&n);m=n;
	for(i=2;i<=sqrt(m)+1;i++){//从2枚举到根号n 
		if(n%i==0){//如何n中有质数i
			if(ji)printf("* ");
			z=0;
			while(n%i==0)n/=i,z++;//将n中所有的i（质数）全部除掉并记录i的指数 
			if(z==1)printf("%lld ",i);
			else printf("%lld^%lld ",i,z);
			ji=1;
		}
	}
	if(n==1)return 0;
	else if(m==n)printf("%lld",n);
	else printf("* %lld",n);
}
```


---


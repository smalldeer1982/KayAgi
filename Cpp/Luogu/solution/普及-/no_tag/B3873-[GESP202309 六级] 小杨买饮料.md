# [GESP202309 六级] 小杨买饮料

## 题目描述

小杨来到了一家商店，打算购买一些饮料。这家商店总共出售 $N$ 种饮料，编号从 $0$ 至 $N-1$，其中编号为 $i$ 的饮料售价 $c_i$ 元，容量 $l_i$ 毫升。

小杨的需求有如下几点：

1. 小杨想要尽可能尝试不同种类的饮料，因此他希望每种饮料至多购买 $1$ 瓶；

2. 小杨很渴，所以他想要购买总容量不低于 $L$ 的饮料；

3. 小杨勤俭节约，所以在 $1$ 和 $2$ 的前提下，他希望使用尽可能少的费用。

方便起见，你只需要输出最少花费的费用即可。特别地，如果不能满足小杨的要求，则输出 `no solution`。

## 说明/提示

**样例 1 解释**

小杨可以购买 $2,3,5$ 号饮料，总计获得 $50+40+20=110$ 毫升饮料，花费 $2+4+3=9$ 元。

如果只考虑前两项需求，小杨也可以购买 $2,4,5$ 号饮料，它们的容量总和为 $50+30+20=100$ 毫升，恰好可以满足需求。但遗憾的是，这个方案需要花费 $2+5+3=10$ 元。

**样例 2 解释**

$1,2,3,4$ 号饮料总计 $140$ 毫升，如每种饮料至多购买 $1$ 瓶，则恰好无法满足需求，因此只能花费 $100$ 元购买 $0$ 号饮料。

**数据规模**

对于 $40\%$ 的测试点，保证 $N \le 20;1\le L \le 100; l_i \le 100$。

对于 $70\%$ 的测试点，保证 $l_i \le 100$。

对于 $100\%$ 的测试点，保证 $1\le N \le 500;1\le L \le 2000; 1\le c_i,l_i \le 10^6$。

## 样例 #1

### 输入

```
5 100
100 2000
2 50
4 40
5 30
3 20```

### 输出

```
9```

## 样例 #2

### 输入

```
5 141
100 2000
2 50
4 40
5 30
3 20```

### 输出

```
100```

## 样例 #3

### 输入

```
4 141
2 50
4 40
5 30
3 20```

### 输出

```
no solution```

# 题解

## 作者：ruanshaochuan______ (赞：41)

# 洛谷 B3873
01 背包问题，如果不知道 01 背包请参考[这里](https://oi.wiki/dp/knapsack/)。
## 题目大意
给你 $n$ 个重量为 $c_i$ 价值为 $l_i$ 的物品，每件物品只能选一次，问你要获得 $L$ 的价值最少需要多少重量。
## 思路简述
首先用 01 背包的模版求出用 $i$ 的重量最多能获得多少价值，重量的最大值为 $\begin{aligned}\sum_{i=1}^nc_i \end{aligned}$，然后从 $0$ 开始循环一遍，如果用 $i$ 的重量可以获得超过 $L$ 的价值，那么就输出 $i$，并且结束程序。


---

## 作者：FXLIR (赞：13)

### 思路
读完题面后，不难发现这是一道 [0-1 背包](https://oi-wiki.org//dp/knapsack/#0-1-%E8%83%8C%E5%8C%85)问题。

设 $f_j$ 为购买 $j$ 毫升饮料所需的最小花费。考虑把 $c_i$ 作为价值，$l_i$ 作为体积，则转移方程为 $f_j=\min(f_j,f_{j-l_i}+c_i)$，注意 $f_j$ 要初始化成一个大值。

然而如果直接这么做的话会超时，因为 $l_i$ 太大了。再次观察题目，我们可以发现，只要 $l_i \geq L$，就可以满足要求。因此可以把所有 $\geq L$ 的 $l_i$ 都设成 $L$，解决超时问题。

随后可以得出背包的容量为 $2L-1$，因为在进行上一步的处理后，如果选择购买的 $l_i$ 之和是 $L$ 的两倍及以上，一定不是最优方案。

按照上面的式子 dp 一遍后，从 $L$ 到 $2L-1$ 遍历一遍 $f$ 数组，值最小的一个 $f_j$ 就是答案。

最后提一下如何判无解：如果 $\sum_{i = 1}^{n} l_i < L$，即购买所有的饮料也无法满足需求，就输出 `no solution`。

具体实现见代码。
### 代码
```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=1e5+5,INF=1e9;
int n,s,c[N],l[N],sum,f[N],ans=INF;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>c[i]>>l[i];
		l[i]=min(l[i],s),sum+=l[i];
	}
	if(sum<s){
		cout<<"no solution";
		return 0;
	}
	for(int i=1;i<=2*s;i++){
		f[i]=INF;
	}//因为后面求的是最小值，所以要初始化成 inf
	for(int i=1;i<=n;i++){
		for(int j=2*s;j>=l[i];j--){
			f[j]=min(f[j],f[j-l[i]]+c[i]);
		}
	}
	for(int i=s;i<=2*s;i++){
		ans=min(ans,f[i]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Clouds_dream (赞：6)

### 前置知识
[01背包——OI wiki](https://oi-wiki.org/dp/knapsack/)

### 题目大意
[题目传送门](https://www.luogu.com.cn/problem/B3873)

### 题目分析
有 $N$ 个物品，每个物品的价值为它的容量 $l_i$ ，价值为它的售价 $c_i$ ，求在容量不小于 $L$ 的情况下花费的最小值。如果我们直接用转移方程的板子 $dp_j=\min(dp_j,dp_{j-l_i}+c_i)$ 的话会超时，因为 $l_i$ 非常大，可达 $10^6$ ,所以我们必须考虑优化。

### 优化
第一，如果 $l_i>L$ ,我们就可以把 $l_i$ 设为 $L$ ,避免超时（剪枝优化）。

第二，我们可以发现背包的容量为 $2L-1$ ,并且如果选择出来的物品的 $l_i$ 之和大于 $2L$ ,那它一定不是最优方案。

#### 证明背包容量为 $2L-1$ （反证法）
1. **假设存在最优解 $S^*\geq 2L$**  
设 $S^*$ 是最优解的总容量，且 $S^*\geq 2L$ ，对应的最小花费为 $C^*$ 。

2. **移除部分物品**  
由于每个物品的容量 $l_i\leq L$ （经过剪枝优化），我们可以从 $S^*$ 中逐个移除物品，直到剩余容量 $S'$ 满足 $S'<2L$ 。  
移除过程中，剩余容量始终 $\geq L$ （初始 $S^* \geq 2L$ ，每次移除物品 $l_i \leq L$ ，故 $S^* - l_i \geq 2L - L = L$ ）。

3. **花费对比**  
设移除物品后的总花费为 $C'$ ，则：
   $$
   C' \leq C^* - \sum_{\text{removed}} c_i \leq C^*
   $$
    所以不等号成立：因 $c_i \geq 0$ （物品花费非负），移除物品不会增加花费。

4. **剩余容量范围**  
   移除过程结束时：
   $$
   S' \in [L,\, 2L-1] \quad \text{ （因 $S' < 2L$ 且 $S' \geq L$）}
   $$

5. **推出矛盾**  
   - $C' \leq C^*$ 且 $S' \geq L$ ，说明 $S'$ 是一个合法解。
   - 但 $C' \leq C^*$ 与 "$C^*$ 是最小花费"矛盾（若 $C' < C^*$ ，则 $C^*$ 非最优；若 $C' = C^*$ ，则 $S'$ 是更优解，因其容量更接近 $L$ ）。

故结论得证。

### 继续分析
然后我们就可以按照上面的思路开始 DP 了，然后从 $L$ 到 $2L-1$ 遍历一下 $dp$ 数组，然后 $dp_i$ 的最小值就是答案。

无解情况：
1. $\sum_{i=1}^{n}l_i<L$ ,即
所有饮料之和都不能满足需求，就输出 ```no solution``` 。

2. 把 $ans$ 初始化为一个大值，如果遍历完 $dp$ 数组 $ans$ 仍为最大值，则也无解。

还有，注意 $dp$ 数组要初始为一个大值。

### 答疑
Q：为什么要从 $L$ 遍历到 $2L-1$ ？

A：因为只有大于等于 $L$ 的方案才合法，并且对于以下数据来说

```
5 100
1 2000
10 100
20 80
40 20
10000 1
```
购买的饮料总容量可能大于 $L$ ，这种情况下如果写 $L$ 不能覆盖到全部，但写 $2L$ 就可以。

### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

#define TRACE 1
#define tcout TRACE && cout

#define int long long
//十年OI一场空，不开long long见祖宗（其实本题没必要）

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);//快读

#define pri priority_queue
const int P = 998244353;
const int INF = 0x3f3f3f3f3f3f3f3f;

const int N = 1e6+10, M = 1e8 + 10;

int n,L;//n为物品数量，L为需要的数量
int c[N],l[N];//含义见题目
int dp[N];
int cnt=0;//饮料总量

signed main()
{
    fst
    memset(dp,0x3f,sizeof(dp));//数组初始化
    cin>>n>>L;
    for(int i=1;i<=n;i++){
    	cin>>c[i]>>l[i];
    	cnt+=l[i];
    	l[i]=min(l[i],L);
	}
	if(cnt<L){
		cout<<"no solution";//无解1
		return 0;
	}
	dp[0]=0;
	for(int i=1;i<=n;i++){
		for(int j=2*L;j>=l[i];j--){
			dp[j]=min(dp[j],dp[j-l[i]]+c[i]);//板子
		}
	}
	int ans=INF;
	for(int i=L;i<=2*L;i++){
		ans=min(ans,dp[i]);
	}
	if(ans==INF){
		cout<<"no solution";//无解2
		return 0;
	}
	cout<<ans;
    return 0;
}
```
### UPD
2025/6/2 改正了 $\min$ 函数写法不当的问题。

2025/6/2 证明了背包容量为 $2L-1$ 。

---

## 作者：wky_wsy_ (赞：6)

# 前置知识
01 背包的动态规划写法，[模版题传送门](http://ybt.ssoier.cn:8088/problem_show.php?pid=1267)。
# 分析
这个题一看就是属于 **01 背包**派系的东西（关键句：小杨想要尽可能尝试不同种类的饮料，因此他希望**每种饮料至多购买 $1$ 瓶**；），于是一个通用的状态转移方程就被你写在了代码上 `f[j]=max(f[j-w[i]]+c[i])`。  
然后我们会发现：这个题好像是让我们求**最小花费**，所以这个 `max` 很明显不太对劲。所以我们应该把数组 $f$ 里的 $1$ 号元素设为 $0$，其余全部设为 $\infty$（程序中可以考虑使用 `LLONG_MAX` 达到相似的效果），表示目前不可以达到这个状态。  

---

到此为止，我们已经有了一个看上去没毛病的思路。  
但交上去后，你大概率会被卡掉四十分。原因可能会有点难想：当一瓶饮料给的量大于小杨需要的量的时候，应该进行一次状态转移，但刚开始就被循环检测到满足条件，然后就跳出了。  
还有一个可能的原因是 01 背包的第二重循环的 $j$ 的初始值不够大，建议在题目给到的 $2000$ 的基础上加 $100$ 左右，这样比较安全，不会超时。  

---

最后把代码附上。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int c[507],v[507];
int f[2107];
signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int n,l,cnt=0;
    cin>>n>>l;
    for(int i=1;i<=n;i++){
        cin>>c[i]>>v[i];
        if(v[i]>l){
            v[i]=l;
        }
        cnt+=v[i];
    }//c->代价 v->收益
    if(cnt<l){
        cout<<"no solution";
        return 0;
    }
    fill(f,f+2105,LLONG_MAX);
    f[0]=0;
    for(int i=1;i<=n;i++){
        for(int j=2100;j>=v[i];j--){
            if(f[j-v[i]]!=LLONG_MAX) f[j]=min(f[j],f[j-v[i]]+c[i]);
        }
    }
    int ans=LLONG_MAX;
    for(int i=l;i<=2100;i++){
        ans=min(ans,f[i]);
    }
    if(ans==LLONG_MAX){
        cout<<"no solution";
    }
    else cout<<ans;
    return 0;
}
```
**温馨提示：刷题千万条，理解第一条；天天抄题解，封号两行泪。**

---

## 作者：chenyv666 (赞：3)

## 题意大意
有 $N$ 种饮料，第 $i$ 种饮料价值 $c_i$ 花费 $l_i$，求在每种饮料只买一种且总花费大等于 $L$ 的情况下最小价值。
## 题目思路
这道题可以用动态规划的刷表法写。  
刷表法：由当前点的状态，更新其他点的状态。  
需要注意：只用当每个状态所依赖的状态对它的影响相互独立。 
## 代码实现
$f_{i,j}$ 代表买 $i$ 种饮料，总容量为 $j$ 毫升的最小花费。但是题目说总容量大于等于 $L$ 即可，所以我们要将 $j+l_{i+1}$ 大于等于 $L$ 的情况存 $f_{i+1,L}$。则我们可以双重循环实现买或不买。  
买的话，先判断 $j+l_{i+1}$ 是否大于 $L$。如果小于 $L$ 就将 $f_{i+1,j+l_{i+1}}$ 设为买第 $i+1$ 个的情况和原来的 $f_{i+1,j+l_{i+1}}$ 值之间的最小值。否则就把它们之间的最小值存到 $f_{i+1,L}$。不买的话，将 $f_{i+1,j}$ 设为 $f_{i,j}$ 和
$f_{i,j}$ 之间的最小值。
 最后判断 $f_{N,L}$ 是否被修改，进行输出。
## 代码

```cpp
//码风不好，请见谅
#include <bits/stdc++.h>
using namespace std;
int f[510][2010],c[510],l[510];
int main() {
    int N,L;cin>>N>>L;
    for(int i=1;i<=N;i++) cin>>c[i]>>l[i];
    memset(f,0x3f,sizeof(f));f[0][0]=0;
    for(int i=0;i<N;i++){
        for(int j=0;j<=L;j++){
            //刷表法
            if(j+l[i+1]<L){
                f[i+1][j+l[i+1]]=min(f[i][j]+c[i+1],f[i+1][j+l[i+1]]);//买
            }else{
                f[i+1][L]=min(f[i][j]+c[i+1],f[i+1][L]);//买
            }
            f[i+1][j]=min(f[i+1][j],f[i][j]);//不买
        }
    }
    if(f[N][L]>=1e9){//判断值是否被修改
        cout<<"no solution";
    }else{
        cout<<f[N][L];
    }
    return 0;
}
```

---

## 作者：C202301 (赞：3)

## 题意简述
有 $N$ 种饮料，每种饮料有价值 $c_i$ 和花费 $l_i$，求在总花费大等于 $L$ 的情况下最小的价值。注意，本做法是以 $c_i$ 为价值。
## 思路
我们设 $dp_{i,j}$ 为 $1$ 至 $i$ 花费为 $j$ 的最小价值。转移方程很简单：
$$
dp_{i,j}=\min(dp_{i-1,j},dp_{i-1,j-l_i}+c_i)
$$
具体意义就是假设不选，就是 $1$ 至 $i-1$ 花费为 $j$，选，就是 $i-1$ 花费为 $j-l_i$。

我们考虑如何处理大等于 $L$ 这个要求。事实上，我们凑出一个大等于 $L$ 的价值，一定会从一个小于 $L$ 的价值转移到大等于 $L$ 的价值。那么我们其实就可以算出 $dp_{1,1}$ 至 $dp_{N,L}$ 的答案，然后在结果是枚举 $dp_{i,j}$，如果 $dp_{i,j}+l_{i+1}$ 大等于 $L$，那就可以用这个更新答案。为什么不用枚举 $i+2$，$i+3$ 乃至更多？因为如果假设 $dp_{i,j}+l_{i+1}$ 是小于 $L$ 的，那么这个肯定会在 $dp_{i+1,x}$ 被更新，其中 $x$ 是一个值。然后这道题花费不为负，因此我们选后超过 $L$ 就肯定不用再选。那么我们就按照这个步骤处理即可。时间复杂度 $O(NL)$。代码如下：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll int
using namespace std;
ll N,L,dp[505][2005],c[2005],l[2005],ans=600000000;
int main()
{
	scanf("%d%d",&N,&L);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int i=1;i<=N;i++) scanf("%d%d",&c[i],&l[i]);
	for(int i=1;i<=N;i++) {
		for(int j=0;j<min(l[i],L);j++) dp[i][j]=dp[i-1][j];
		for(int j=l[i];j<=L;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j-l[i]]+c[i]);
	}
	ans=dp[N][L];
	for(int i=0;i<=N-1;i++) 
		for(int j=0;j<=L;j++) 
			if(j+l[i+1]>=L) ans=min(ans,dp[i][j]+c[i+1]);
	if(ans<=500000000) printf("%d",ans);
	else printf("no solution");
	return 0;
}
```
## 总结
一道练习背包还可以的题。

---


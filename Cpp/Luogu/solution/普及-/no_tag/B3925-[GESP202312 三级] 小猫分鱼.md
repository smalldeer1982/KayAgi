# [GESP202312 三级] 小猫分鱼

## 题目描述

海滩上有一堆鱼，$N$ 只小猫来分。第一只小猫把这堆鱼平均分为 $N$ 份，多了 $i<N$ 个，这只小猫把多的 $i$ 个扔入海中，拿走了一份。第二只小猫接着把剩下的鱼平均分成 $N$ 份，又多了 $i$ 个，小猫同样把多的 $i$ 个扔入海中，拿走了一份。第三、第四、……，第 $N$ 只小猫仍是最终剩下的鱼分成 $N$ 份，扔掉多了的 $i$ 个，并拿走一份。

编写程序，输入小猫的数量 $N$ 以及每次扔到海里的鱼的数量 $i$，输出海滩上最少的鱼数，使得每只小猫都可吃到鱼。

例如：两只小猫来分鱼 $N=2$，每次扔掉鱼的数量为 $i=1$，为了每只小猫都可吃到鱼，可令第二只小猫需要拿走 $1$ 条鱼，则此时待分配的有 $3$ 条鱼。第一只小猫待分配的鱼有  $3\times 2+1=7$ 条。

## 说明/提示

**样例解释 2**

三只小猫来分鱼 $N=3$，每次扔掉鱼的数量为 $i=1$，为了每只小猫都可吃到鱼，可令第三只小猫需要拿走 $3$ 条鱼（拿走 $1$ 条和 $2$ 条不满足要求），则此时待分配的有 $10$ 条鱼。第二只小猫待分配的鱼有 $10×3/2+1 = 16$ 条。第一只小猫待分配的鱼有 $16×3/2+1 = 25$ 条。

## 样例 #1

### 输入

```
2
1```

### 输出

```
7```

## 样例 #2

### 输入

```
3
1```

### 输出

```
25```

# 题解

## 作者：WydnksqhbD (赞：62)

# [B3925 [GESP202312 三级] 小猫分鱼](https://www.luogu.com.cn/problem/B3925) 题解
**本题提供两种思路。**
## 思路 1
枚举第 $N$ 只小猫拿走的鱼数，每次往回倒推即可。

例如：$N=3,i=1$ 时，

- 若拿了 $1$ 条，则**在第 $3$ 只小猫分之前**，有 $1\times3+1=4$ 条鱼。$4$ 可以被 $2$ 整除。**在第 $2$ 只小猫分之前**，有 $4\times\frac{3}{2}+1=7$ 条鱼。此时不能被 $2$ 整除，故舍去。
- 若拿了 $2$ 条，则**在第 $3$ 只小猫分之前**，有 $2\times3+1=7$ 条鱼。不符题意，故舍去。
- 若拿了 $3$ 条，**在第 $3$ 只小猫分之前**，有 $3\times3+1=10$ 条鱼。逐次倒推得：
$$10\times\frac{3}{2}+1=16$$
$$16\times\frac{3}{2}+1=25$$
故最终的答案为 $25$ 条。

（代码最后给）
## 思路 2
**枚举答案。**

这样仅需递推即可。但是时间复杂度较高，现在本蒟蒻仅想出了**改变起点**的方式优化。如果你有更好的优化，可以私信我。
## 代码
### 思路 1 C 风格代码
```cpp
#include<stdio.h>
int main()
{
	long long n,i,j,k;
	scanf("%lld %lld",&n,&i);
	for(j=1;;j++)
	{
		int flag=1;
		long long ans=j*n+i;
		for(k=1;k<n;k++)
		{
			if(ans%(n-1)){flag=0;break;}
			ans=ans/(n-1)*n+i;
		}
		if(flag)
		{
			printf("%lld",ans);
			return 0;
		}
	}
}
```
### 思路 1 C++ 风格代码
```cpp
#include<iostream>
using namespace std;
int main()
{
	long long n,i,j,k;
	cin>>n>>i;
	for(j=1;;j++)
	{
		bool flag=true;
		long long ans=j*n+i;
		for(k=1;k<n;k++)
		{
			if(ans%(n-1)){flag=false;break;}
			ans=ans/(n-1)*n+i;
		}
		if(flag)
		{
			cout<<ans;
			return 0;
		}
	}
}
```
### 思路 2
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
bool check(int x)
{
	for(int i=1;i<=n;i++)
	{
		x-=m;
		if(x<=0||x%n)return false;
		x=x/n*(n-1);
	}
	return true;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(ans=(n>8)?380000000:1;;ans++)
	{
		if(check(ans))break;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：sunyizhe (赞：40)

## 零、前言

注意：本题解非正常思路，若要正解请移步到其他题解。

有 OIer 云：暴力出奇迹，打表出省一。~~这题感觉打表好题。~~

## 一、思路

### 1.1 写出暴力程序

这就很简单了，只要从 $1$ 开始无限枚举，若成功则 `break`。代码中 $n$ 为题目中 $N$，$m$ 为题目中 $i$。

```cpp
//云剪贴板维护，只能把代码贴在文中了qwq
#include <bits/stdc++.h>
using namespace std;

int n,m;

bool check(int x)
{
	for(int rnd=1;rnd<=n;rnd++)
	{
		if(x==0)return false;//判断是否有鱼吃
		int r=x%n;//计算本轮扔掉的鱼i
		if(r!=m)return false;
		//cout<<(x-r)/n<<' ';
		x-=m;//坑点：要减去余数
		x=x-x/n;
	}
	return true;
}
int main()
{
	cin>>n>>m;
	for(int i=1;;i++)
	{
		if(check(i))
		{
			cout<<i<<endl;
			break;
		}
	}
	return 0;
}
```

轻松 $90$ pts。

### 1.2 打表

我们一看数据范围：$0<N<10$，$i<N$。这么小？我们自然想到用 `for` 枚举所有的 $N$ 和 $i$，搞出所有的数据答案。打表程序可以通过魔改上面的代码自行写出。可以得到二维的 $ans$。最后输入 $N$ 和 $i$，输出对应答案即可。

## 二、代码

注意：代码中因为我没有用 $0$ 把 $ans_{0,1 \sim n}$ 占位，所以输出时其实输出的是 $ans_{n-1,m}$。

```cpp
//程序算法：枚举
#include <bits/stdc++.h>
using namespace std;

int n,m,ans[20][20]={
{1,0,0,0,0,0,0,0,0},
{4,7,0,0,0,0,0,0,0},
{27,25,23,0,0,0,0,0,0},
{256,253,250,247,0,0,0,0,0},
{3125,3121,3117,3113,3109,0,0,0,0},
{46656,46651,46646,46641,46636,46631,0,0,0},
{823543,823537,823531,823525,823519,823513,823507,0,0},
{16777216,16777209,16777202,16777195,16777188,16777181,16777174,16777167,0},
{387420489,387420481,387420473,387420465,387420457,387420449,387420441,387420433,387420425},
};

void fast_read()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
}

int main()
{
	//freopen("input.in","r",stdin);
	//freopen("output.out","w",stdout);
	
	fast_read();
	
    cin>>n>>m;
    cout<<ans[n-1][m]<<endl;
	
	return 0;
}
```

打表抢到最优解，与第二名相差 $50ms$。**暴力出奇迹，打表出省一。**

---

## 作者：_ayaka_ (赞：34)

#### 思路
这种题肯定需要倒推。

我们用 $k$ 来表示当前鱼的总数，用 $f$ 表示最后一只小猫分到的鱼的数量，
那么可以得知 $k$ 的在被分最后一次时，也就是初始值等于 $f\times n+i$，并且通过分析样例解释，可以得到这么一个公式：

$$k=k\div(n-1)\times n+i$$

观察样例可以发现，当 $k\div(n-1)$ 时，可能会遇到除不尽的情况，所以我们可以每次判定是否遇到了除不尽的情况，如果遇到了，就尝试将 $f+1$，再次进行新一轮的倒推。

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long i=0,k=1,f=1,m=0,n=0;
int main() {
	cin>>n>>m;
	if(n==1) {//当n=1时进行特判 
		cout<<"1";
		return 0;
	}
	k=f*n+m;
	for(i=1; i<=n; i++) {
	    if(k%(n-1)!=0){
	    	i=1;
	    	f++;
	    	k=f*n+m;
	    	continue;//此时记得重新开始循环 
		}
        k=k/(n-1)*n+m; //上文提及的公式 
	}
	cout<<k;
	return 0;
}
```


---

## 作者：jiangyunuo (赞：21)

### 主要意思：
本题的主要意思还是很好懂的，就是有 $N$ 只猫对一堆鱼进行操作，$N$ 只猫轮流把鱼分成 $N$ 份，把多余的鱼扔掉，自己拿走一份，每次扔掉的鱼都是 $i$，我们要做的就是求出鱼的条数。
### 主要思路：
我们可以使用循环试验，直到试出正确答案。我试的是第 $N$ 只小猫拿的走的的鱼的条数（代码见后文），用循环来判断是否正确，找出正确的条数，最后求出正确答案。
### 代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,i,s=1,c;     //n是猫的数量，i是每次扔掉鱼的条数，s是第n只小猫哪走鱼的条数，c是判断for循环的跳出情况。
    scanf("%d%d",&n,&i);
    if(n==1){cout<<1<<endl;return 0;}  //因为n为1，后面要除n-1，也就是0，0不能为除数，所以要单独输出。
    int a=0;    //a表示鱼的条数。
    while(1){
        for(int j=1;j<=n;j++){
            if(j==1)a+=s*n;
            else a=a*n;     //判断是否是第一次循环，第一次循环要用第n只小猫哪走鱼的条数（s）来倒退，其他则用上一只猫拿走的条数（a），因为a是表示鱼的条数，是从第n只猫一直推到第1只）来推。
            a+=i;    //a加上扔掉的鱼的条数。
            c=j;    //记录循环的次数。
            if(a%(n-1)==0)a/=n-1;
            else break;      //判断假设是否正确。如果不对，就要提前退出循环，换个假设。判断方法：如果a是可以分成n-1份，那就没问题，因为要想成立，a必须能分。
        }
        if(c==n){printf("%d",a);return 0;}   //通过看循环次数的方法判断循环是否是结束了才跳出，如不是，就是假设不正确。
        s++;   //重新换一个值来假设。
        a=0;   //清空鱼的条数。
    }
    return 0;
}
```
### 说明：
~~因为没有数据，我自己设了五个数据，都对，也不会出现超时，样例也是对的。~~[AC记录](https://www.luogu.com.cn/record/145119306)

---

## 作者：Vct14 (赞：9)

### 思路

如果最后一只小猫拿走的鱼越少，即第二只小猫拿走后剩下的鱼越少，那么最初海滩上的鱼的数量就越少。题目问的是最少的鱼数，考虑从少到多枚举最后一只小猫拿走的鱼的数量，倒推出海滩上的鱼数。如果为整数则输出。

### 倒推方法

若最后一只小猫拿走的鱼的数量为 $s$，则它拿鱼前鱼的数量为 $k_n=sn+i$。

对于第 $c$ 只小猫，它拿鱼前鱼的数量为 $k_c$，则它会扔掉 $i$ 只鱼，随后拿走剩下的 $\dfrac{1}{n}$，即拿走 $\dfrac{k_c-i}{n}$ 只鱼，最后剩下 $k_c-i-\dfrac{k_c-i}{n}=\dfrac{(n-1)(k_c-i)}{n}$ 只鱼。

那么它拿鱼后鱼的数量 $k_{c+1}=\dfrac{(n-1)(k_c-i)}{n}$，即可倒推拿鱼前鱼的数量 $k_c=\dfrac{nk_{c+1}}{n-1}+i$。仅当 $n-1\mid nk_{c+1}$ 时，$k_c$ 为整数。又 $(n,n-1)=1$，则仅当 $n-1\mid k_{c+1}$ 时满足要求。

逐步倒推 $k_c$ 时判断，若 $n-1\nmid k_{c+1}$，则退出循环，继续枚举；若一直都有 $n-1\mid k_{c+1}$，则直接输出最终的答案即可。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
	int n,i;cin>>n>>i;
	int s=1; // 最后一只小猫拿走的鱼的数量 
	while(1){
		bool f=true;
		int k=s*n+i; // 某一只小猫拿走前鱼的数量  
		for(int c=2; c<=n; c++){ // 倒数第 c 只小猫 
			if(k%(n-1)){
				f=false;
				break;
			}
			k=k/(n-1)*n+i;
		}
		if(f){
			cout<<k;
			return 0;
		}
		s++;
	}
	return 0;
}
```

---

## 作者：WsW_ (赞：8)

感觉本题是 GESP2023 所有题中最难的。  
被骗到了，本来以为是人类智慧题。

---
### 思路
显然，当我们知道第 $N$ 只猫拿了多少鱼，就可以逆推出整个过程。  
所以枚举第 $N$ 只猫拿了多少鱼，再在逆推过程中判断是否合法即可。  

假设第 $N$ 只猫拿了 $x$ 条鱼。  
因为这 $x$ 条鱼是 $N$ 份中的一份，还扔了 $i$ 条鱼，所以第 $N-1$ 只猫剩了 $x\times N+i$ 条鱼给第 $N$ 只猫。  

设 $a=x\times N+i$。  
这 $y$ 条鱼是 $N$ 份中的 $N-1$ 份，还扔了 $i$ 条鱼，所以第 $N-2$ 只猫剩了 $\dfrac{a\times N}{N-1}+i$ 条鱼给第 $N-1$ 只猫。  

显然，只有当 $(N-1)|a$ 时上面那个式子算出来才是整数。如果 $(N-1)|a$ 就证明一开始选的 $x$ 不成立。  

按照这个方式不断逆推即可。

时间复杂度很难分析，但 $N$ 的范围很小，各种乱搞都能过。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a;
int sum;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>a;
	for(int i=1;i<=n;i++){
		bool f=1;
		sum=n*i+a;
		for(int j=2;j<=n;j++){
			if(sum%(n-1)){
				f=0;
				break;
			}
			sum=sum/(n-1)*n+a;
		}
		if(f){
			cout<<sum;
			break;
		}
	}
	return 0;
}
```

---

## 作者：KyleShen1213 (赞：6)

## 思路
先定义 $ans$ : `ans=n*j+k`

(我这里 $n$ 是猫的个数， $k$ 是每次扔掉鱼的数量，至于 $j$ ，我在下面会说的）

倒推，最后一只猫的是已经做完，接着循环 $2$ 到 $n$ ，每次 $ans = ans \times n \div (n-1) + k$ ， 因为除以了 $n$ 就乘回来，扔掉了 $k$ 就加回来， 这样得出的结果正好是前面的猫剩的 $(n-1)$ 份，就除以 $(n-1)$ ，得到一份，重复此操作就得出了答案。但你肯定没想到，这还没有完……
## 注意要点
由于涉及到除，所以可能会有小数，但这肯定是不能被允许的。

所以我们要控制好最后一只小猫分的每份鱼的数量，使它不会出现小数。

只能从一开始往后尝试，这也就是我之前说到的 $j$ 的作用，如果没有出现小数就可以，否则将 $j$ 加 $1$ 。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,n,k;//k指的是题目里的i 
int main()
{
	cin>>n>>k;//输入 
	int j=1;
	while(j)
	{
		bool fl=0;
		ans=n*j+k;//最后一只猫做的操作不同，先做掉 
		for(int i=2;i<=n;i++)
		{
			if(ans%(n-1)!=0)//如果是小数，跳出循环 
			{
				fl=1;//标记一下 
				break; 
			}
			ans=ans*n/(n-1)+k;//不是小数继续 
			//cout<<ans<<endl;
		}
		if(fl==0)//不是小数输出 
		{
			cout<<ans<<endl;
			return 0;
		}
		else//是小数j++
		{
			j++;
		}
	}
	return 0;
}
```

---

## 作者：_colin1112_ (赞：6)

与 std 对拍了 1000 组没挂，应该没问题。

## 思路

枚举第 $n$ 条小猫拿鱼的条数，然后逆推枚举答案，如果发现逆推时答案除不尽 $n-1$，那么跳出进入到下一次枚举，如果逆推完毕后还没有跳出，那么就直接输出答案。

## Code

```c++
#include <bits/stdc++.h>
#define endl '\n'
#define ll long long

using namespace std;
const int E = 1e6 + 5;
ll n, i;
int main()
{
    cin >> n >> i;
    ll ans;
    auto check = [&](ll x) -> bool//lambda表达式
    {
        ans = x * n + i;//第 n 条鱼
        for (int j = 1; j < n; j++)
        {
            if (ans % (n - 1) != 0)//除不尽
                return false;
            ans = ans / (n - 1) * n + i;//反之继续逆推
        }
        return true;
    };
    ll j = 1;
    while (1)
    {
        if (check(j))
            break;
        j++;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Igunareo (赞：5)

# 题意分析
首先，这题数据很小，可以暴力，那就暴力。

我们可以列举最后一只小猫分到的鱼数进行暴力。

由于每只小猫将鱼去掉 $i$ 条，再分成 $n$ 份，拿走一份，那么就还剩 $n-1$ 份。

所以我们拿到剩下的鱼时，想推出原来的鱼数就得先除 $n-1$ 算出每份的条数，再乘 $n$ 得出总鱼数，最后将扔掉的 $i$ 条鱼捡回来。

## 注意点
首先，枚举的是最后一条小猫拿走的鱼数，所以它要分的鱼数是每份乘 $n$ 加 $i$ 条。

其次，鱼不能切开分，那么每次剩下的鱼数要能整除 $n-1$ 才行，这里需要加特判。
# 代码如下
```
#include<bits/stdc++.h>
using namespace std;
int n,i;
long long check(int m){
	long long summ=m*n+i;//最后一条小猫分的鱼 
    for(int j=2;j<=n;j++){//其余小猫情况 
    	if(summ%(n-1))return 0;//鱼被切开了，不行 
    	summ=summ*n/(n-1)+i;//原来有多少鱼||上一条猫剩下多少鱼 
	}
	return summ;//最初有多少鱼 
}
int main(){  
    cin>>n>>i;
    int ans=0;
    for(int k=1;;k++){
    	ans=check(k);//记录情况
    	if(ans)break;//能分就跳出 
	}
    cout<<ans;
    return 0;
}
```

---


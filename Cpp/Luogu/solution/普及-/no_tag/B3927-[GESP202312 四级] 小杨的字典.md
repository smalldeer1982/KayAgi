# [GESP202312 四级] 小杨的字典

## 题目描述

在遥远的星球，有两个国家 A 国和 B 国，他们使用着不同的语言：A 语言和 B 语言。小杨是 B 国的翻译官，他的工作是将 A 语言的文章翻译成 B 语言的文章。

为了顺利完成工作，小杨制作了一本字典，里面记录了 $N$ 个 A 语言单词对应的 B 语言单词，巧合的是，这些单词都
由地球上的 26 个小写英文字母组成。

小杨希望你写一个程序，帮助他根据这本字典翻译一段 A 语言文章。这段文章由标点符号 `!()-.[].{}\|;:'",./?<>` 和一些 A 语言单词构成，每个单词之间必定由至少一个标点符号分割，你的程序需要把这段话中的所有 A 语言单词替换成它的 B 语言翻译。特别地，如果遇到不在字典中的单词，请使用大写 UNK 来替换它。

例如，小杨的字典中包含 $2$ 个 A 语言单词 `abc` 和 `d`，它们的 B 语言翻译分别为 `a` 和 `def`，那么我们可以把 A 语言文章 `abc.d.d.abc.abcd.` 翻译成 B 语言文章 `a.def.def.a.UNK.` 其中，单词 `abcd` 不在词典内，因此我们需要使用 UNK 来替换它。

## 样例 #1

### 输入

```
2
abc a
d def
abc.d.d.abc.abcd```

### 输出

```
a.def.def.a.UNK```

## 样例 #2

### 输入

```
3
abc a
d def
abcd xxxx
abc,(d)d!-abc?abcd```

### 输出

```
a,(def)def!-a?xxxx```

## 样例 #3

### 输入

```
1
abcdefghij klmnopqrst
!()-[]{}\|;:'",./?<>abcdefghijklmnopqrstuvwxyz```

### 输出

```
!()-[]{}\|;:'",./?<>UNK```

# 题解

## 作者：tder (赞：28)

首先考虑如何分割出每个单词，遍历整个字符串 $S$，找出每一个标点符号位置，两个标点符号之间的部分 $t$ 即为一个单词。特别地，最后一个单词可能没有之后的标点符号，因此在原字符串 $S$ 末尾加上字符 $\tt.$，最后不输出最后一位即可。

再考虑如何替换，可以用 map 字典将 A 语言与 B 语言的每组对应单词建立索引，可参考 [OI Wiki](https://oi-wiki.org/lang/csl/associative-container/#map)。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e4 + 5;
int n;
map<string, string> m;
string s, ans;
signed main() {
    cin>>n;
    for(int i = 1; i <= n; i++) {
        string a, b;
        cin>>a>>b;
        m[a] = b;
    }
    cin>>s;
    s += '.';
    string t = "";
    for(char c : s) {
        if(c >= 'a' && c <= 'z') t += c;
        else {
            if(t != "") {
                if(m.count(t)) ans += m[t];
                else ans += "UNK";
                t = "";    
            }
            ans += c;
        }
        // cout<<c<<" "<<ans<<" "<<t<<endl;
    }
    ans.pop_back();
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：_little_Cabbage_ (赞：17)

# B3927 [GESP202312 四级] 小杨的字典 题解
~~[博客食用体验更佳](https://www.luogu.com.cn/blog/958804/solution-b3927)~~

这是一道字符串题。

我们可以用一个 `map` 来存字典，然后从文章 $S$ 中提取没有标点的字符串，即一个单词，来看他在 B 语言里是什么单词，如果他在 B 语言里不存在，就输出 `UNK`，否则输出它在 B 语言里的单词。

AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,string>mp;
signed main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		string a,b;
		cin>>a>>b;
		mp[a]=b;
	}
	string s;
	cin>>s;
	int len=s.size();
	string t="";
	for(int i=0;i<len;i++)
	{
		t="";
		while(s[i]>='a'&&s[i]<='z'&&i<len)
		{
			t+=s[i];
			i++;
		}
		if(t=="")
		{
			cout<<s[i];
			continue;
		}
		if(mp[t]=="")
		{
			cout<<"UNK";
		}
		else
		{
			cout<<mp[t];
		}
		cout<<s[i];
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/144779407)

---

## 作者：Programming_Konjac (赞：12)

# 思路
用一个字符串 $a$ 来存储最后的字符串，再用一个字符串 $b$ 表示当前这个单词，如果遇到的是字母，那么用 $b$ 加上这个字符，如果是其他的，那么就要遍历所有的 $A_i$，如果遇到了，就将 $a$ 加上 $B_i$，如果没有遇到，那么 $a$ 加上 `UNK` 就可以了，最后还要加上当前这个字符。

最后判断 $b$ 是否剩余，如果剩余了，那么就要遍历所有的 $A_i$，如果遇到了，就将 $a$ 再加上 $B_i$，如果没有遇到，那么 $a$ 加上 `UNK`。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	string a[n+2],b[n+2];
	for(int i=1; i<=n; i++) cin>>a[i]>>b[i];
	string s,j;
	cin>>s;
	string bb;
	for(int i=0;i<s.size(); i++){
		if(!(s[i]>='a'&&s[i]<='z')){
			int flag=0;
			for(int k=1; k<=n; k++){
				if(j==a[k]){
					bb+=b[k];
					flag=1;
					break;
				}
			}
			if(flag==0&&j.size()) bb+="UNK";
			bb+=s[i];
			j.clear();
		}
		else j+=s[i];
	}
	if(j.size()){
		int flag=0;
		for(int k=1; k<=n; k++){
			if(j==a[k]){
				bb+=b[k];
				flag=1;
				break;
			}
		}
		if(flag==0) bb+="UNK";
	}
	cout<<bb<<endl;
	return 0;
}
```

---

## 作者：Igallta (赞：8)

这道题一看到 $len_S \leqslant 1000$ 就知道，肯定是暴力。

讲一下思路：

使用 `map` 去存储这个单词书。

然后翻译的时候使用 `isalpha` 去看这个字符是不是字母。如果是那么就记录到 `tmp` 里面去；不是字母的时候去判断 `tmp`，判断的方法见下文，将 `tmp` 清空，然后原封不动地输出符号。

对 `tmp` 的判断过程如下：

1. 判空：这一步对 `tmp` 进行判空。有值才会进行，不然你就会看到一大堆 `UNK`，喜提爆零。
2. 对单词表中 `tmp` 进行判空。没错，又是判空，这一步是为了看 `tmp` 在不在单词表中。如果在，那么就输出对应单词表的单词，否则输出 `UNK`。

循环结束的时候由于不确定后面有没有符号，所以还要对 `tmp` 进行最后判断输出。

```cpp
/****************************************
作者:
版权:
日期:
*****************************************/
#include<bits/stdc++.h>
#define LL k<<1
#define RR k<<1|1
#define int long long

using namespace std;
int n; 
map<string,string>mp; //单词本 
string s,tmp;//s:需要翻译的句子 tmp:当前单词 
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		string A,B;//A语言，B语言
		cin>>A>>B;
		mp[A]=B;//记录进单词本 
	}
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(!isalpha(s[i])){//是符号 
			if(tmp.size()){
				if(mp[tmp].size()){
					cout<<mp[tmp];
				}else cout<<"UNK";		
			}
			tmp="";
			cout<<s[i];
		}
		else{
			tmp+=s[i];
		} 
	}
	if(tmp.size()){
		if(mp[tmp].size()){
			cout<<mp[tmp];
		}else cout<<"UNK";
	}
	return 0;
}

```

---

## 作者：Harrylzh (赞：5)

题意：给定 $n$ 个单词和各自翻译后的单词，再翻译文章。

思路：本题中的“翻译”就是处理映射关系，所以考虑使用 map 工具。文章中的单词是用标点符号分隔，所以可以在遇到标点符号时处理此单词。注意，在最后还要处理一次。

代码：

```cpp
#include<iostream>
#include<string>
#include<map>
using namespace std;
map<string,string> mp;
int n;
string s;
string now;
string ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        string a,b;
        cin>>a>>b;
        mp[a]=b;
    }
    cin>>s;
    for(int i=0;i<s.size();i++)
    {
        if(s[i]>='a'&&s[i]<='z')
        {
            now+=s[i];//如果是单词的一部分，那就先加入字符串等待处理
        }
        else//如果不是小写字母，就是标点符号
        {
            if(now.size())
            {
                if(mp.count(now))//字典中有
                {
                    ans+=mp[now];
                }
                else//字典中没有
                {
                    ans+="UNK";
                }
            }
            now="";//清空后记录下一个单词
            ans+=s[i];//标点符号加入答案
        }
    }
    if(now.size())//最后额外处理
    {
        if(mp.count(now))
        {
             ans+=mp[now];
        }
       else
        {
            ans+="UNK";
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Virtual_Character (赞：3)

考虑使用 map 来做。

思路很简单，先录入词典条目，再输入字符串 $S$，然后去查找单词，是标点符号则直接输出，不在词典内则输出 `UNK`。

查找单词是否存在可以用 `find()` 函数，`find(key)` 为返回键是 $key$ 的映射的迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向 end。

### 代码：

```cpp
#include<iostream>
#include<map>
using namespace std;
int main(){B3927
    int n;
    map<string,string> dic;//dictionary
    string a,b,s,tmp;
    map<string,string>::iterator it;//定义迭代器
    cin>>n;
    while(n--){
        cin>>a>>b;
        dic[a]=b;
    }
    cin>>s;
    for(int i=0;i<s.length();i++){
        if(s[i]>=97&&s[i]<=122){//是否为字母
            tmp+=s[i];//将当前字符加入tmp
        }else{//是标点符号
        //对单词进行处理
            if(!tmp.empty()){//如果tmp中有字符
                it=dic.find(tmp);//查找
                if(it==dic.end()){//无
                    cout<<"UNK";
                }else{//有
                    cout<<it->second;//map可以使用it->first来访问键，使用it->second访问值
                }
                tmp="";//清空tmp
            }
            cout<<s[i];//输出标点符号
        }
        
    }
    if(!tmp.empty()){//由于末尾没有标点符号，再处理一次
        it=dic.find(tmp);
        if(it==dic.end()){
            cout<<"UNK";
        }else{
            cout<<it->second;
        }
    }
    return 0;
}
```

---


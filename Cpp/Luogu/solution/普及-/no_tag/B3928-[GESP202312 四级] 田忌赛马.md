# [GESP202312 四级] 田忌赛马

## 题目描述

你要和田忌赛马。你们各自有 $N$ 匹马，并且要进行 $N$ 轮比赛，每轮比赛，你们都要各派出一匹马决出胜负。

你的马匹的速度分别为 $u_1,u_2,\cdots，u_n$，田忌的马匹的速度分别为 $v_1,v_2,\cdots,v_n$。田忌会按顺序派出他的马匹，请问你要如何排兵布阵，才能赢得最多轮次的比赛？巧合的是，你和田忌的所有马匹的速度两两不同，因此不可能出现平局。

## 说明/提示

**样例解释 1**

第 1 轮，田忌派出速度为 2 的马匹，你可以派出速度为 3 的马匹迎战，本轮你获胜。

第 2 轮，田忌派出速度为 4 的马匹，你可以派出速度为 5 的马匹迎战，本轮你获胜。

第 3 轮，田忌派出速度为 6 的马匹，你可以派出速度为 1 的马匹迎战，本轮田忌获胜。

如此，你可以赢得 2 轮比赛。


## 样例 #1

### 输入

```
3
1 3 5
2 4 6```

### 输出

```
2```

## 样例 #2

### 输入

```
5
10 3 5 8 7
4 6 1 2 9```

### 输出

```
5```

# 题解

## 作者：Igallta (赞：54)

这道题嘛......

知道田忌赛马小故事的就知道，这个故事的核心思路就是拿自己最慢的马去对战别人最快的马。我把这种马在下文称作“炮灰”。

我们先来看样例给出的：

![](https://pic.imgdb.cn/item/65b654d5871b83018a9bace5.jpg)

如果多一点马？

![](https://pic.imgdb.cn/item/65b6566a871b83018aa588be.jpg)

我的思路：给两个序列从小到大排序，如果我们当前马还没有别人当前最慢的马快，那就去当炮灰。否则就去当前最慢的马那里和它对战。

但是由于炮灰这个操作并不会造成什么影响，只需要跳过当前马就行了。所以可以不用执行。我们只需要执行当这个马大于田忌当前最慢的马的时候去和它对战就行了。

总结：

1. 对我们和田忌的马的速度进行从小到大排序。
2. 用两个指针 $i$，$j$ 分别代表我们的马和田忌当前最慢的马的下标。
3. 如果我们的第 $i$ 个马的速度大于等于田忌第 $j$ 个马（当前最慢的马）的速度，那么就让 $j+1$，$ans+1$。
4. 输出 $ans$，代码结束。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e4+1;
int n,a[N],b[N],ans;
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	for(int i=1,j=1;i<=n;i++){
		if(a[i]>=b[j]){
			++j,++ans;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：tder (赞：15)

> 于 2024-08-20 修正一处笔误。

~~[宝 ~ 宝 ~ 巴 ~ 士 ~ 快 ~ 乐 ~ 启 ~ 蒙 ~](https://www.youtube.com/watch?v=fpxqNNeGaqg)（啊什么？这才是真正的[宝宝巴士](https://www.gequbao.com/music/9445275)？）。~~

好吧不要太离谱。

---

参考上面的故事，考虑将所有马的速度排序，下面就是一个例子：

$$
v_3>u_3>v_2>u_2>v_1>u_1
$$

那么，显然，我们为了赢得更多场，即需要找出尽量多组 $u_i>v_j$ 的关系，考虑寻找在上面的连不等式中尽可能相近的数量关系。

在上面的例子中，从右往左看：

- $u_1$ 是最小的，此时无法获胜，应尽可能消耗对方 $v_i$ 中最大的，即 $v_3$；
- $v_1$ 是小于 $u_2$ 的最大的 $v_i$，也就是说是尽可能相近的，因此我们找出了一组 $u_2>v_1$；
- 同理，$v_2$ 是小于 $u_3$ 的最大的 $v_i$，有一组 $u_3>v_2$。

因此，共 $2$ 组。

总结一下，从 $u_i$ 的最小值开始，若存在 $v_i$ 小于当前的 $u_i$，取最接近的；若不存在，则选择与当前最大的 $u_i$ 比赛。

模拟并统计胜利场数即可。

---

## 作者：ACtheQ (赞：15)

给一种我在赛场上一分钟想到思路，一分钟码完代码的做法。

讲一个故事：

齐使者如梁，孙膑以刑徒阴见，说齐使。齐使以为奇，窃载与之齐。齐将田忌善而客待之。忌数与齐诸公子驰逐重射。孙子见其马足不甚相远，马有上、中、下辈。于是孙子谓田忌曰：“君弟重射，臣能令君胜。”田忌信然之，与王及诸公子逐射千金。及临质，孙子曰：“今以君之下驷与彼上驷，取君上驷与彼中驷，君中驷与彼下驷。”既驰三辈毕，而田忌一不胜而再胜，卒得王千金。于是忌进孙子于威王。威王问兵法，遂以为师。

根据这个故事，我们可以想到至少要吧敌人最弱的马赢掉，再赢次弱的马，以此类推……

我们先将所有的马排序。

定义两个指针，$l,r$ 表示我使用马的编号，和敌人使用的马的编号，假如我的马不能赢掉他，那就尝试我编号 $l+1$ 能不能赢。赢了答案加 $1$，然后 $l+1,r+1$ 因为，该下一个马比较了，以此类推。

代码很简单：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int a[N],b[N];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int l=1,r=1;
	int ans=0;
	while(l<=n&&r<=n)
	{
		if(a[l]<b[r]) l++;
		else
		{
			ans++;
			l++;
			r++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：__Jared__ (赞：6)

## 思路讲解

**题目大意：** 田忌会与你进行赛马，每个人的马匹都有属于自己的速度并且均不相同。但你的马匹速度大于田忌的马匹的速度时，则你的马匹获胜（反之同理）。你需要在已知田忌出马顺序的情况下，应对其进行选马使得你能够赢得更多场次的比赛。

**思路分析：** 这道题目明显就是一道贪心（贪婪）模板题，贪心顾名思义就是在付出最小代价（这里指马匹速度差）的情况下获得最大的利益（获胜的场次）。故此，依据定义我们可以推出以下定理
- **获取局部最优解** 从速度最快的马匹开始，我方和田忌方分别从自己的马匹中选择一个速度相差最小的进行比赛。如果我方胜利了，那么我们就赢得这场比赛，否则我们就派速度最慢的马“去送死”并与对手最慢的马匹比赛，可能可以赢得这场比赛。这么做的优势在于，能够使我方在“舍小利、重大利”的原则下，保留更快的马匹，从而在后续的比赛中更容易获胜。

通过上述思路，每次比赛，我们就把出发最慢的马匹拿出来去和田忌匹配，如果能够取得胜利，则当前局我们就在花最小代价的情况下获得了局部最大利益；如果不能获胜，则把我们最快的马匹拿出来去和田忌的最慢的马匹匹配，那我们也可以有更多的机会去获得胜利。

**方法实现：** 首先将双方的马匹依照顺序速度进行排序，然后每次与速度最接近且比自己慢的马匹进行匹配以获得局部最优解。这么做是为了基于以上的贪心思路

## AC代码

接下来又是大家最期待的AC代码了（注释帮大家标好了）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e4+10;
int n,ans,x=1,y=1,u[maxn],v[maxn]; //需要注意：这里题目有要求数组大小必须开这么大（1≤N≤5×10^4），前面乘了一个5
int cmp(const void *a,const void *b) //这里的cmp是sort排序里面的一个部分，其中这个const类不能少
{
    int *x=(int *)a,*y=(int *)b;
    return *y-*x;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>u[i];
    for(int i=1;i<=n;i++) cin>>v[i];
    qsort(u+1,n,sizeof(int),cmp);
    qsort(v+1,n,sizeof(int),cmp);
    while(x<=n&&y<=n)
	{
        if(u[x]>v[y]) x++,y++,ans++; //统计胜利场次 
        else y++;
    }
    cout<<ans<<endl;
    return 0; //华丽结尾 
}
```

---


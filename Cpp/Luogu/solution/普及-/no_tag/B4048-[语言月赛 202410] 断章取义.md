# [语言月赛 202410] 断章取义

## 题目描述

本题中，字符串下标从 $1$ 开始。称 $|S|$ 为字符串 $S$ 的长度（字符个数）。

字符串 $S$ 的一个**子串**是选取一对 $1\le l\le r\le |S|$，然后将 $S_l,S_{l+1},\ldots, S_r$ 拼接得到的字符串，记为 $S[l\ldots r]$。例如，若字符串 $S$ 是 `yummy`，那么 $S[2\ldots 4]$ 是 `umm`。

------

小 L 说了一个字符串 $S$，其中包含大写或小写字母。

小 X 把这个字符串录成了视频，但是为了保证视频内容积极向上，她要对视频进行剪辑，使其不包含否定词 `not`。具体地，每一轮剪辑找到 $S$ 中所有子串 `not`，去掉这些子串，把剩下内容拼在一起；然后检查新子串是否含有 `not`，如有，则再剪辑一轮，直到没有 `not` 为止。

例如，`IcannototnAKIOI` 经过第一轮剪辑会变成 `IcanotnAKIOI`（剪掉 $S[5\ldots 7]$），第二轮剪辑会变成 `IcanAKIOI`（剪掉 $S[4\ldots 6]$），剪辑了两轮。

给出字符串 $S$，请先输出剪辑后的结果，然后输出剪辑轮数。

## 说明/提示

【样例 1 解释】

该样例即为题目所描述的情形。

【样例 2 解释】

`nnototnononotttNOT` 在第一轮剪辑后，变成了 `notnonottNOT`。

第二轮剪辑后，变成了 `notNOT`。

第三轮剪辑后，变成了 `NOT`。

【样例 3 解释】

注意，哪怕剪辑完了啥也不剩，也要输出一个换行。

【数据范围】

本题共有 $10$ 个测试点。

- 测试点 $1$ 保证剪辑轮数为 $0$。
- 测试点 $2,3$ 保证剪辑轮数为 $1$。
- 测试点 $4,5,6$ 保证剪辑轮数为 $8$。（提示：如果你会求一般情况下的剪辑结果，但不会计算剪辑轮数，可以拿这些部分分。）

对于全部测试点，保证 $S$ 非空且仅含大写或小写字母，同时长度不超过 $100$。

## 样例 #1

### 输入

```
0
IcannototnAKIOI```

### 输出

```
IcanAKIOI
2
```

## 样例 #2

### 输入

```
0
nnototnononotttNOT```

### 输出

```
NOT
3
```

## 样例 #3

### 输入

```
0
not
```

### 输出

```

1
```

# 题解

## 作者：__CJY__ (赞：2)

## 前言
**Update in $2024/11/17 \sim 2024/11/20$**

[题目传送门](https://www.luogu.com.cn/problem/B4048)。

**这题似乎有坑，搞了半天！~可能对别的大佬来说很简单！~**
## 思路
我们使用`string`提供的`find`函数直接搜索字符串中是否存在子串 $\texttt{not}$，每次让计数器自增一。

你会获得 $10$ 分。

题目中说，每一轮剪辑找到 $S$ 中所有子串 $\texttt{not}$，而我的代码中一次只找一次，所以会`WA`。

设 $S=\texttt{notnot}$。

* **错误方法**：第一轮结束后 $S=\texttt{not}$，第二轮结束后 $S$ 为空，剪辑轮数为 $2$。
* **正确方法**：第一轮把所有 $\texttt{not}$ 删了，$S$ 为空，剪辑轮数为 $1$。

我们每次遍历一遍 $S$，用`substr`判断是否有 $\texttt{not}$，如果有就用`erase`删除 $\texttt{not}$。

你会获得 $70$ 分。

设 $i$ 为循环变量，删除 $\texttt{not}$ 之后就不应该`i++`了，否则就会少检测一次。

设 $S=\texttt{notnot}$。

第一轮把 $\texttt{not}$ 删掉，$S=\texttt{not}$，当前 $i$ 为 $0$，每次循环都会`i++`，所以 $i$ 变成 $1$ 了，此时 $S_i=\texttt{o}$，就检测不到下一个 $\texttt{not}$ 了。

我们循环时不写`i++`，当 $s_i,s_{i+1},s_{i+2} \ne \texttt{not}$ 时才`i++`。

如果你是像我这样写的话，你就错了：
```cpp
for(int i=0;i<s.size()-2;)
```
你会获得 $90$ 分，有一个`RE`。

`s.size()`的类型是`size_t`，`size_t`只能存无符号整数，故不能存负数，当 $|s|<2$ 时，$|s|-2<0$，这样会溢出，并变成一个很大的整数，所以会越界。

我们将`s.size()`强制转整。

这样就 $100$ 分了！
## Code
```cpp
while(s.find("not")!=string::npos){
	for(int i=0;i<(int)s.size()-2;){
		if(s.substr(i,3)=="not") s.erase(i,3);
		else i++;
	}
	c++;
}
```

## 总结
所以我们以后要养成好习惯，尽量把`s.size()`强制转整。

---

## 作者：yummy (赞：0)

本题考查字符串处理。

本题可以使用二重循环完成，外层循环负责删除了几轮，内层循环负责进行一轮删除。

为了判断删除是否阶数，可以用一个变量 `flag` 记录内层循环时是否删除了字符——如果某一轮没有删除任何字符，那么删除就结束了。

对于同一轮删除，当我们找到 `s[i]=='n' && s[i+1]=='o' && s[i+2]=='t'` 时，我们可以使用 `s.erase(i,3)` 完成三个字符的删除。

但是此时需要特别小心，当删除了三个字符后，`s[i]` 事实上是一个没有判断过的下标，但是如果你直接一轮循环结束后 `i++` 了（尤其是写 `for` 循环时），那么在处理连续删除时就会出现错误。

一种较为简单的方法是，每次删除完先 `i--`，然后循环结束后 `i++` 后，刚刚好就是下一个未被判断的位置。

---


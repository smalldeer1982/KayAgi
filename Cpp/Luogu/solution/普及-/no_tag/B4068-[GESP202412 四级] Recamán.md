# [GESP202412 四级] Recamán

## 题目描述

小杨最近发现了有趣的 Recamán 数列，这个数列是这样生成的：

- 数列的第一项 $a_1$ 是 $1$；
- 如果 $a_{k-1}-k$ 是正整数并且没有在数列中出现过，那么数列的第 $k$ 项 $a_k$ 为 $a_{k-1}-k$，否则为 $a_{k-1}+k$。

小杨想知道 Recamán 数列的前 $n$ 项从小到大排序后的结果。手动计算非常困难，小杨希望你能帮他解决这个问题。

## 说明/提示

#### 样例解释

对于样例 1，$n=5$：
- $a_1=1$；
- $a_1-2=-1$，不是正整数，因此 $a_2=a_1+2=3$；
- $a_2-3=0$，不是正整数，因此 $a_3=a_2+3=6$；
- $a_3-4=2$，是正整数，且没有在数列中出现过，因此  $a_4=a_3-4=2$；
- $a_4-5=-3$，不是正整数，因此 $a_5=a_4+5=7$。

$a_1,a_2,a_3,a_4,a_5$ 从小到大排序的结果为 $1,2,3,6,7$。

#### 数据范围

对于所有数据点，保证 $1\le n\le 3\, 000$。

## 样例 #1

### 输入

```
5```

### 输出

```
1 2 3 6 7```

## 样例 #2

### 输入

```
8```

### 输出

```
1 2 3 6 7 12 13 20```

# 题解

## 作者：chen_zhe (赞：23)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题考查桶思想和排序。

根据题目含义，先求出 Recamán 数列，使用数组 $a$ 进行存储。在求 Recamán 数列的时候，重点在于如何处理【没有在数列中出现过】。这里采用桶思想，定义数组 `vis`，如果 `vis[x] == 1`，说明 $x$ 这个数已经出现过了，否则没有出现过。至于 `vis` 数组应该开多少，后面会详细讨论这个问题。

因此我们可以写出下列计算 Recamán 数列的代码：

```cpp
a[1] = vis[1] = 1;
for (int i = 2; i <= n; i++) {
    if (a[i - 1] - i >= 1 && !vis[a[i - 1] - i])
        a[i] = a[i - 1] - i;
    else
        a[i] = a[i - 1] + i;
    vis[a[i]] = 1;
}
```

题目要求输出 Recamán 数列从小到大排序后的结果。由于数据范围中 $n\leq 3000$，因此可以任意选择一种排序方式，例如选择排序、冒泡排序都是可以使用的。这里提供一个选择排序的参考代码：

```cpp
for (int i = 1; i <= n; i++) {
    int mx = a[i], id = i;
    for (int j = i + 1; j <= n; j++) {
        if (a[j] < mx) {
            mx = a[j];
            id = j;
        }
    }
    swap(a[i], a[id]);
}
```

最后我们研究这个问题：记录这个数是否出现过的 `vis` 数组应该开多大呢？可以先将 `vis` 数组开得足够大（例如：$900$ 万），然后运行整个程序，输入 $3000$，可以看到最大的输出数字为 $11339$。因此，`vis` 数组不需要开的非常大，只需开到 $11340$ 即可。

实际上使用简单的数学推理即可得出，`vis` 数组肯定不需要开得很大。首先，只有执行加法时，最大值才会更新。假设一种最坏的情况（且是必然不可能出现的情况）：每一步都是执行加法，那么数列的第 $n$ 项的值是 $1+2+3+\dots+n=\dfrac{n(n+1)}{2}$，代入 $n=3000$ 得到结果为 $4501500$。这是一个相当宽松的上界，实际上，由于定义中优先选择减法生成新项，这会显著减缓数列的增长速度。总而言之，无需担心 `vis` 数组的大小会是一个天文数字。

---


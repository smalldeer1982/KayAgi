# [CSP-X2023 山东] 克隆机

## 题目描述

有一台神奇的克隆机，可以克隆任何东西。将样品放进克隆机，可以克隆出一份一样的“复制品”。

小明得到了 $k$ 种珍贵的植物种子，依次用 $\text{A,B,C,D,\dots,Z}$ 表示（$1\le k\le 26$）。一开始，每种植物种子只有 $1$ 粒。

小明想利用克隆机克隆出更多种子。将一粒种子作为样品放进克隆机，就可以得到一粒克隆出来的相同的种子，这样一粒种子就变成了两粒种子。小明将 $k$ 粒不同的种子按字母先后顺序排队，从 A 开始依次放入克隆机，每次把得到的两粒相同的种子（放入的 $1$ 粒和克隆出来的 $1$ 粒）放到队尾，这样不断的进行克隆。

例如，一共有 $7$ 种不同的种子，依次用 $\text{A,B,C,D,E,F,G}$ 表示。

- 第 $1$ 粒种子 $\text{A}$ 放进克隆机之前，队列是：$\text{A,B,C,D,E,F,G}$。
- 第 $1$ 粒种子 $\text{A}$ 放进克隆机之后，队列是：$\text{B,C,D,E,F,G,A,A}$。
- 第 $3$ 粒种子 $\text{C}$ 放进克隆机之前，队列是：$\text{C,D,E,F,G,A,A,B,B}$。
- 第 $3$ 粒种子 $\text{C}$ 放进克隆机之后，队列是：$\text{D,E,F,G,A,A,B,B,C,C}$。

请问第 $n$ 粒放进克隆机的是什么种子？用 $\text{A,B,C,D,\dots,Z}$ 表示。


## 说明/提示


- 样例 $1$ 解释：

依次放入的种子为 $\text{A},\text{B},\text{C},\text{D},\text{E},\text{F},\text{G},\text{A},\text{A},\text{B},\text{B}$。


### 数据范围

对于 $50\%$ 的数据，$1\le n\le 10^6$；

对于 $100\% $ 的数据，$1\le k\le 26$，$1\le n\le 10^{18}$。

## 样例 #1

### 输入

```
7 10```

### 输出

```
B```

## 样例 #2

### 输入

```
26 80```

### 输出

```
A```

## 样例 #3

### 输入

```
15 689```

### 输出

```
G```

# 题解

## 作者：lam_dyr (赞：10)

# B4102 \[CSP-X2023 山东] 克隆机

## Solution

### 题目理解

有一个克隆过程，初始时有 $k$ 种种子，每种 $1$ 粒，按字母顺序排列。每次从队头取出一粒种子进行克隆，克隆后的两粒种子放到队尾。目标是找出第 $n$ 粒被克隆的种子是什么。

### 核心思路

初始情况： 如果 $n \le k$，那么第 $n$ 粒被克隆的种子就是第 $n$ 个字母，可以直接输出。

模拟过程： 如果 $n > k$，就需要模拟克隆过程。但如果直接模拟，当 $n$ 很大时会超时。因此，需要寻找规律。

规律发现：
假设当前队列长度为 $len$，在进行一轮克隆后，队列长度会变为 $len + k$。

每一轮克隆，都会把前 $k$ 个种子克隆一次，并且把这 $k$ 个种子放到队尾。

关键在于，第 $n$ 个被克隆的种子，实际上是第 $n$ 个被取出的种子。

当 $n > k$ 时，我们实际上可以倒推：

- 如果 $n$ 是在第一轮克隆中被取出的，那么 $n$ 肯定是在前 $k$ 个位置。
- 如果 $n$ 不是在第一轮克隆中被取出的，那么它一定是在第一轮克隆后新加入的队列中。
- 假设第一轮克隆后，队列长度变为 $2k$，那么第一轮克隆后，新加入的队列的前 $k$ 个元素，就是第一轮克隆的种子，也就是前 $k$ 个种子。
- 那么，第 $n$ 个被克隆的种子，实际上是第 $(n - k - 1) \div 2$ 个被克隆的种子，因为前 $k$ 个种子被克隆了，并且放到了队尾，所以第 $n$ 个被克隆的种子，实际上是第 $(n-k)$ 个种子，而这 $(n-k)$ 个种子，实际上是前 $(n-k)\div2$ 个种子被克隆出来的。

也就是说，我们可以把 $n$ 减去 $k$，然后除以 $2$，得到新的 $n$，直到 $n$ 小于等于 $k$。

具体实现：可以使用递归或迭代的方式倒推，直到 $n \le k$。

## Code

```cpp
#include <iostream>
using namespace std;
long long k, n;
int main() {
	cin >> k >> n;
	if (n <= k) 
		cout << char('A' + n - 1);
	else {
		n--;
		while (n >= k) 
			n = (n - k) / 2;
		cout << char('A' + n);
	}
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：1)

### 题目分析

如果直接枚举，那么肯定会超时。~~（我就是这么干的）。~~

考虑优化。因为每一次序列的长度都是上一次的两倍，那么就可以找到 $n$ 是在那一组里，再进行模拟。

### 代码实现

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll k, n, m, id = 1;
int main () { 
	cin >> k >> n;
	m = k;
	if (n <= k) {
		cout << char ('A' + n) << endl;
		return 0;
	}
	while (m <= n) {
		n -= m;
		m *= 2;
		id *= 2; 
	}
	m /= 2;
	if (n % id == 0)  cout << char ('A' + n / id - 1); 
	else cout << char ('A' + n / id);
	cout << endl;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### 思路：
这题分为两点。

- $n \le k$ 时，直接输出第 $n$ 粒种子对应的第 $n$ 个，这个就很清楚了。
- 否则，种子数减一，开始循环，每次都执行除二（是因为每次一个进去，就有两个出来，就少了一半），一直去找头号种子，直到 $k \le n$ 时，再停止，说明这时候已经找到了第 $n$ 粒种子了。最后再输出就行了。

---

### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

long long k, n;

int main() {
	cin >> k >> n;
	if (n <= k) cout << char(64 + n); 
	else {
		n--;
		while (n >= k) n = (n - k) / 2; // 还可以增加的个数，每次都是在慢慢减少
		cout << char(65 + n); // 65对应的是ASCII的‘A’
	}
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：1)

### 解题思路

当 $k = 7$ 时，我们来看看序列应该是怎么样子的：

`ABCDEFG AABBCCDDEEFFGG AAAABBBBCCCCDDDDEEEEFFFFGGGG`……（空格为方便展示所添加，实际字符串中不存在空格）

我们设令 `ABCDEFG` 为第一层，`AABBCCDDEEFFGG` 为第二层，`AAAABBBBCCCCDDDDEEEEFFFFGGGG` 为第三层……

我们发现第 $1$ 层的元素个数为 $k$，$2$ 层的元素个数为 $2k$，$3$ 层的元素个数为 $4k$，……第 $i$ 层的元素个数为 $2^{k - 1}k$。

那么前 $1$ 层的元素个数为 $k$，前 $2$ 层的元素个数为 $3k$，前 $3$ 层的元素个数为 $7k$，……前 $i$ 层的元素个数为 $(2^k - 1)k$。

那么我们可以根据 $n$ 先确定其属于哪一层，之后确认其在该层的编号，即可确认该字符。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

LL n, k;

LL qmi(LL a, int b)
{
    LL res = 1;
    while (b)
    {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

LL calc(LL x)
{
    return (qmi(2, x) - 1) * k;
}

int main()
{
    cin >> k >> n;
    
    int p = 1;
    while (calc(p) <= n)
        p ++;
    
    p --;
    
    n -= calc(p);
    
    cout << char((n - 1) / (qmi(2, p)) + 'A') << endl;
    
    return 0;
}
```

---

## 作者：hjz_0821_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4102)

## 思路
由于数据比较大，所以不能模拟。

**先找规律：**

当有 $3$ 个种子时，之后的放入种子为：

 $A,B,C,A,A,B,B,C,C,A,A,A,A,B,B,B,B,C,C,C,C……$ 

 我们把它们分一下组：

- $A,B,C$
- $A,A,B,B,C,C$
- $A,A,A,A,B,B,B,B,C,C,C,C$

后面省略。

我们可以得出，每一组的长度都为前一组的两倍。

那么我们只需知道所求的种子在第几组，在这一组的第几个便能求出结果。

由于每一组都会有重复的，那么  $n$  要先减  $1$，然后再除以其重复个数，就可以得到答案。

## 代码

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
long long k,n,len,cnt;//不开long long见祖宗 
char ans;//最后的结果是字符串类型 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);//加速 
	cin>>k>>n;
	len=k;//len表示组的长度 
	while(n>len){
		n-=len;
		len*=2;
	}//最后的n表示所求种子在其组的第几个
	cnt=len/k;//cnt表示该组相同种子个数
	ans=char(((n-1)/cnt+'A'));//把结果转化为相应的字符 
	cout<<ans;//输出 
	return 0;
}
```

---

## 作者：piske (赞：0)

# B4102 [CSP-X2023 山东] 克隆机
### [题目传送门](https://www.luogu.com.cn/problem/B4102)
## 思路：
如果直接枚举，那么肯定会超时。于是，因为每一次序列的长度都是上一次的两倍，那么就可以找到 $n$ 是在那一组里，再进行模拟。
## Coding：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long k;
long long n,m;
int main( ){ 
	cin>>k>>n;
	m=k;
	if(n<=k) 
	{
		cout<<char('A'+n);//如果在第一组，直接输出 
		return 0;
	}
	long long id=1; //每一组字母重复的次数，每次乘以2 
	while(m<=n)
		n-=m,m*=2,id*=2; //确定在哪一组 
	m/=2;
	if(n%id==0) 
		cout<<char('A'+n/id-1); //如果刚好是整数倍的字母重复数 
	else
		cout<<char('A'+n/id);
	return 0;
} 
```

---

## 作者：Fuction12_ (赞：0)

## 思路
我们实际要求克隆的队列，容易发现一个特性：每次这个字母（即指种子）第 $i$ 次被克隆时都要克隆 $2^{i-1}$ 次。

得到每克隆完一个完整区间（即从``A``克隆到第 $k$ 位字母）需要克隆的次数为 $2^{i-1}k$。

前 $i$ 次需要被克隆的次数总和即为 $2^{1-1}k +2^{2-1}k +...+2^{i-1}k$ 次。错位相减得 $2^ik-k$。

找到第 $n$ 位字母在第几个区间里，并减去前几和区间克隆次数和，即可得到该字母在该区间内的位置，减 $1$ 再除以每个字母在区间的克隆次数，再变为字母即可。

不开``long long``见祖宗。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
	int k,n;cin>>k>>n;
	for(int i=1;;i++){
		if(pow(2,i)*k-k>=n&&pow(2,i-1)*k-k<n){//判断是否在当前区间
			cout<<(char)(((n-((int)(pow(2,i-1)*k-k)))-1)/(int)pow(2,i-1)+65);
//这里为什么要-1：前几个区间的次数和肯定小于 n，所以减去后的最小值为 1，假设每个字母在区间内克隆 4 次，那么 4 除以 4 将会得 1，得 0 的就只有 1,2,3 三个了。
			break;
		}
	}
	return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：0)

# B4102 [CSP-X2023 山东] 克隆机 题解

[题目传送门](https://www.luogu.com.cn/problem/B4102)

## 题目分析

看到题目，由于 $n$ 很大，不能直接模拟，需要另想办法。

### 探索规律
假设一共有 $3$ 种不同的种子，用 $\text{A,B,C}$ 表示。

那么之后的放入种子为 $\text{A},\text{B},\text{C},\text{A},\text{A},\text{B},\text{B},\text{C},\text{C,\text{A},\text{A},\text{A},\text{A},\text{B},\text{B},\text{B},\text{B}}$……  
我们可以将这些进行分组，前 $3$ 个一组，接着 $6$ 个一组，再接着的 $12$ 个一组……  
每一组的长度都为前一组的两倍。

那么我们只用知道所求的种子在第几组的第几个便能求出。  
代码如下：
```cpp
cin >> k >> n;
long long len = k,cnt; // len表示组的长度
while(n > len)
    n -= len,len *= 2;// 最后的n表示所求种子在其组的第几个
cnt = len / k; // cnt表示该组相同种子个数
```

### 输出答案
由于每一组都会有重复的，那么我们就先要把 $n$ 减 $1$ 然后再除以其重复个数，就可以得到答案。  
最终代码如下：
```cpp
#include <iostream>
using namespace std;
long long k,n;

int main(){
	cin >> k >> n;
	long long len = k,cnt;
	while(n > len)
	    n -= len,len *= 2;
	cnt = len / k;
	cout << (char)((n-1) / cnt + 'A');
	return 0;
}
```

### 一些提醒
注意 $n$ 很大，**一定**要开 long long。  
最后的减一不要忘掉。

## 总结
是一道基础的题，考察数学思维，适合初学者练习。

感谢您的阅读！

---

## 作者：RenZhen1 (赞：0)

如果样品总共有 $7$ 个，那么第一轮长度为 $7$，第二轮长度为 $14$，第三轮长度为 $28$，依此类推，每一轮的长度是上一轮长度的两倍。

其中，数据范围 $1 \leq n \leq 10^{18}$，那么我们只需要确定第 $n$ 粒种子到底是在第几轮的第几个即可。

通过数组，来递推出每轮种子的数量 $a_i=a_{i-1}\times2$。

在递推的过程中，可以确定第 $n$ 粒种子的轮次。找到轮次之后，再找到底是这一轮次的哪一个位置。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll a[70];
int main() {
	ll k,n;
	char ch;
	cin>>k>>n;
	if(n<=k) {
		ch=64+n;
		cout<<ch;
		return 0;
	}
	a[1]=k;
	ll m=1,sum=k,ans;
	while(1) {
		m++;
		a[m]=a[m-1]*2;
		if(sum+a[m]>=n)
			break;
		sum+=a[m];
	}
	n-=sum;
	if(n%(a[m]/k)==0)
		ch=64+n/(a[m]/k);
	else
		ch=64+n/(a[m]/k)+1;
	cout<<ch;
	return 0;
}

```

---


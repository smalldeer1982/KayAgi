# [CSP-X2024 山东] 购物

## 题目描述

双十一，很多人在疯狂地购物。

商家推出了各种各样的优惠活动，吸引顾客购买更多的商品。

某商家推出如下的优惠活动：

该商家共有 $n$ 件商品，单独购买第 $i$ 件商品的费用为 $a_i$。顾客也可以花费 $w$ 购买 一张优惠券，一张优惠券最多可兑换 $m$ 件商品（无需额外付费）。顾客可以购买任意张优惠券；

如果最后商品不足 $m$ 件，优惠券也可以使用。

求顾客购买完所有 $n$ 件商品的最小费用。



## 说明/提示

### 样例解释

样例 $1$ 说明：

花费 $8$ 买一张优惠券，兑换第 $2$、第 $4$ 件商品；第 $1$、第 $3$、第 $5$ 件商品直接购买。

共花费 $8 + 2 + 1 + 4 = 15$。

样例 $2$ 说明：

花费 $16$ 购买两张优惠券，能兑换所有商品。

### 数据范围

对于 $30\%$ 的数据，满足 $1 \leq n \leq 10^3,1 \leq m \leq 10^3,1 \leq w \leq 10^9,1 \leq a_i \leq 10^9$。

对于 $100\%$ 的数据，满足 $1 \leq n \leq 2 \times 10^5,1 \leq m \leq 2 \times 10^5,1 \leq w \leq 10^9,1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5 2 8
2 7 1 8 4```

### 输出

```
15```

## 样例 #2

### 输入

```
5 3 8
6 7 4 8 9```

### 输出

```
16```

# 题解

## 作者：Wendy_Hello_qwq (赞：10)

[题目传送门。](https://www.luogu.com.cn/problem/B4104)

[原文食用效果更佳。](https://www.luogu.com/article/bjpwvmn7)

## 题意

给定 $n,m,w$，分别表示 $n$ 件物品，满 $m$ 件商品可以使用优惠券和 $w$ 价格的优惠券，买了优惠券只需要付优惠券的价格 $w$，这 $m$ 个物品免费。求购买 $n$ 件物品的最小价格。

## 分析

一道**贪心**题。

贪心需要**排序**，先将物品价格从小到大排序，然后倒序贪心。

设定一个 $num$，每一次都加上第 $i$ 件物品的价格。再设定一个 $cnt$，记录当前有了几个物品。接着判断有没有满 $m$ 个物品，满了的话，判断这 $m$ 个物品是用优惠券便宜(小)，还是原价便宜(小)，加上较小的价格，算完后记得清零重新开始。最后循环外再判断一次，输出答案就可以了。

注意记得开 **long long**，数据范围较大。

## Code

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
// 数据范围较大，要开 long long 
long long num, cnt, ans;
long long n, m, w, a[200005];
int main() {
	scanf ("%lld%lld%lld", &n, &m, &w);
	for (int i = 1; i <= n; i++) scanf ("%lld", &a[i]);
	// 贪心，排序 
	sort (a + 1, a + 1 + n);
	// 倒序查找贪心 
	for (int i = n; i >= 1; i--) {
		// 价格 
		num += a[i];
		// 买了多少个商品 
		cnt++;
		// 当足够 m 件商品时 
		if (cnt == m) {
			// 答案取现在的价格总和与优惠券价格的最小值 
			ans = ans + (num < w ? num : w);
			// 全部归零 
			num = cnt = 0;
		}
	}
	// 最后再进行一次比较
	ans = ans + (num < w ? num : w);
	printf ("%lld", ans);
	return 0;
}
```

[AC 记录。](https://www.luogu.com.cn/record/196361496)

完结撒花。

作者写题解不易，点个赞再走呗。

---

## 作者：lam_dyr (赞：7)

# B4104 \[CSP-X2024 山东] 购物 题解

## 题意

~~题意很明确，就不过多赘述了。~~

## Solution

首先需要发现优惠券可转化为 $m$ 件物品打包成了一个价格为 $w$ 的物品，因此只要把它和先前 $m$ 件物品的总和比较，贪心的取最小即可。

实现就是先降序排列（大的尽量多用优惠劵），然后遍历序列，$m$ 个数分一组统计总和与 $w$ 比较，选更小的就行。

记得开 `long long`。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,w,cnt,ans;
int a[200010];
signed main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	sort(a+1,a+1+n,greater<int>());//从大到小排序
	for(int i=1;i<=n;++i){
		cnt+=a[i];
		if(i%m==0){
			if(cnt>w) ans+=w;
			else ans+=cnt;
			cnt=0;
		}
	}
	if(cnt>w) ans+=w;
	else ans+=cnt;
	cout<<ans;
	return 0;
} 
```

---

## 作者：easy42 (赞：4)

贪心。

非常明显，优惠券要用最大的商品才合算。

每次要取最大值，可以采用堆。

看一下是否更合算，如果用优惠券依然不合算，直接不用优惠券就好了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,w,a[100005],cnt;
priority_queue<int>q;//堆
signed main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		q.push(a[i]);
	}
	while(1){
		int ans=0;
		if(q.size()<m){//细节，不加会报错。
			while(!q.empty()) ans+=q.top(),q.pop();
			cnt+=min(ans,w);
			break;
		}
		for(int i=1;i<=m;i++){
			ans+=q.top();
			q.pop();
		}
		if(ans>w){
			cnt+=w;
		}
		else{
			cnt+=ans;
			while(!q.empty()) cnt+=q.top(),q.pop();
			break;//不用了。
		}
	}
	cout<<cnt;
	return 0;
}

---

## 作者：封禁用户 (赞：2)

## 题目传送门：[B4104 [CSP-X2024 山东] 购物](https://www.luogu.com.cn/problem/B4104)
## 思路：
这题要求购买完所有 $n$ 件商品的最小费用，且可以使用优惠券，那么要使费用最小，我们需要将物品的价格从大到小排序。
```cpp
for(long long i=1;i<=n;i++)cin>>a[i];
sort(a+1,a+1+n);
reverse(a+1,a+1+n);
``````
我们将排好序的数组每 $m$ 个为一组，然后与优惠券的价格进行比较，若这 $m$ 件商品的价格小于优惠券的价格，直接买这 $m$ 件商品，否则使用优惠券。
# AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,w,a[400010],ans;
int main(){
	cin>>n>>m>>w;
	for(long long i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n);
	reverse(a+1,a+1+n);
	for(long long i=1;i<=n;i++){
		long long sum=0;
		for(long long j=i;j<i+m;j++){
			sum+=a[j];
		}
		if(sum>=w){
			ans+=w;
			i+=m;
			i--;
		}
		else{
			ans+=sum;
			i+=m;
			i--;
		}
	}
	cout<<ans;
}
``````

---

## 作者：mairuisheng (赞：2)

[B4104 [CSP-X2024 山东] 购物](https://www.luogu.com.cn/problem/B4104)

算法：枚举、贪心。

分析：先把物品的价格排序，枚举从最贵的枚举到最便宜的，每次将枚举的 $m$ 个物品的价格累加，如果大于优惠券的价格，就将答案累加优惠券的价格（用优惠券购买更优），否则就将答案累加这 $m$ 个物品的价格（单独购买更优）。

注意事项：注意到 $1\le a_i\le 10^9$，所以要开 `long long`。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char s;
    s=getchar();
    while(s<'0'||s>'9')
    {
        if(s=='-')f=-f;
        s=getchar();
    }
    while(s>='0'&&s<='9')
    {
        x=(x<<3)+(x<<1)+(s-48);
        s=getchar();
    }
    return x*f;
}
const int N=2e5+1;
int n,m,w;
int p[N];
long long ans;
int main()
{
	int i,j;
	long long t;
	n=read();
	m=read();
	w=read();
	for(i=1;i<=n;++i)p[i]=read();
	sort(p+1,p+1+n);
	i=n;
	while(i>0)
	{
		t=0;
		for(j=i;j>max(0,i-m);--j)t+=p[j];
		if(t<w)break;
		ans+=w;
		i=i-m;
	}
	for(j=i;j>0;--j)ans+=p[j];
	printf("%lld",ans);
    return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：2)

# B4104 [CSP-X2024 山东] 购物 题解

[题目传送门](https://www.luogu.com.cn/problem/B4104)

## 题目分析

看到题目，我们思考一下，可以想到当优惠券优于正常购买时，则用优惠券，反之则正常购买。

### 前置工作
为了使我们能够判断到底是选优惠券还是选正常购买，就要发挥优惠券的最大价值。也就是说尽量把优惠券用在**贵**的上。  
那么我们可以先对数组**从大到小**进行排序，方便我们进行判断。

### 判断更优选择
每一次判断，由于我们知道用优惠券就是 $w$ 元，那么可以先求出用优惠券买的物品**正常购买**需要多少元，选择两者中最小的。  
代码如下：
```cpp
int pos = 1; // 判断位置
while(pos <= n){
	long long c = 0;
	for(int i = 1;i <= m && pos <= n;i++) // 便于终止
		c += a[pos++];
	if(c >= w) ans += w;
	else ans += c;
}
```

### 一些提醒
注意题目中的数据大小，**一定**要开 long long。  
最终代码如下：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long n,m,w,a[200005],ans;

bool cmp(long long a,long long b){ return a > b; }

int main(){
	cin >> n >> m >> w;
	for(int i = 1;i <= n;i++) cin >> a[i];
	sort(a+1,a+1+n,cmp);
	int pos = 1;
	while(pos <= n){
		long long c = 0;
		for(int i = 1;i <= m && pos <= n;i++)
			c += a[pos++];
		if(c >= w) ans += w;
		else ans += c;
	}
	cout << ans;
	return 0;
}
```

## 总结
是一道比较基础的题，考察贪心算法，适合初学者练习。

感谢您的阅读！

---

## 作者：0Io_oI0 (赞：2)

这道题目是一道比较水的贪心！

首先我们一开始将每个价格排序，从最贵的往最便宜的枚举，从而得到正确的局部最优解。

然后，我们在枚举的过程中将计算连续 $m$ 个价格的和与 $w$ 比较大小如果 $w$ 更便宜将答案加上 $w$ 否则将答案加上分开买的价格。

这里需要注意在最后可能有一批商品不足 $m$ 个，不过这也很简单，在最后输出的时候在判断一下就好了。

最后注意一个细节，注意到数据范围所以我们应该开 ```long long```。

$Code$：
``` cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
I AK IOI;
const int N=2e5+5;
long long n,m,w,a[N],sum,ss;
int main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(&a[1],&a[n+1]);
	for(int i=n;i>=1;i--){
		if(i%m==n%m){
			sum+=min(ss,w);
			ss=0;
		}
		ss+=a[i];
	}
	cout<<sum+min(ss,w);
	i_ak ioi;
}

---

## 作者：dear_deer_land (赞：2)

## 思路

看题意，要使用优惠券兑换商品，考虑贪心策略。首先我们使用快速排序将价格从大到小进行排序，依次看本组 $m$ 件商品和一张优惠券的价格那个更低，如果使用优惠券更便宜的话，就使用优惠券，然后接着看后面 $m$ 件商品是否比一张优惠券便宜；否则用原价购买剩余所以商品。注意：当剩余未判断商品不足 $m$ 件时，所剩商品件数为 $n-m \times cnt$ 件（$cnt$ 为当前使用优惠券张数）。

## 代码

使用前缀和维护一下就好，需要注意的小地方比较多。

```
#include <bits/stdc++.h>
#define ll long long
#define bug puts("!!!====!!!=");
using namespace std;
int n,m,w,a[200010],cnt=1;
long long sum[200010],ans;
bool cmp(int x,int y){
	return x>y;
}
int main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i];
	}
	while(1){
		if(cnt*m>n){
			if(sum[n]-sum[(cnt-1)*m]>w){
				ans+=w;
				break;
			}
			else{
				ans+=sum[n]-sum[(cnt-1)*m];
				break;
			}
		}
		else if(sum[cnt*m]-sum[(cnt-1)*m]>w){
			ans+=w;
			cnt++;
		}
		else{
			ans+=sum[n]-sum[(cnt-1)*m];
			break;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Autumn_Dream (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4104)

**思路：** 

使用贪心。先对序列 $a$ 从小到大排序，在从第 $n$ 项每次递减 $m$ 开始判断是否用优惠券。每次判断，如果 $i\ge m$，取则区间 $[i-m+1,i]$；否则取区间 $[1,i]$。再用区间之和和 $w$ 比较，如果区间和 $\le w$，就没必要使用优惠券，用了优惠券成本只可能会升高或不变，算出没有遍历过的商品之和，与前面的答案相加打印，结束程序；否则将答案加上 $w$。

注：十年 OI 一场空，不开 `long long` 见祖宗。

[Code](https://www.luogu.com.cn/paste/4x5rljo6)

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4104)

## 思路：

**简单的贪心**，将当前最贵的 $m$ 个商品的价格之和与 $w$ 作比较，哪个更便宜就选哪个即可。

当前最贵商品可以用大根堆实现，也就是
```cpp
priority_queue<long long>q;
```
细节：

1. 剩余不足 $m$ 件商品也要比较，但要防止对空的大根堆执行 pop 导致的 RE。
2. **long long！**

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y,a;
priority_queue<long long>q;//大根堆 
int main(){
	cin>>x>>y>>a;
	long long u;
	for(long long i=1;i<=x;i++){
		cin>>u;
		q.push(u);
	}
	long long s=0;
	for(long long i=1;i<=ceil(x*1.0/y);i++){
		long long p=0;
		for(long long j=1;j<=y;j++){
			if(q.empty()==true) break;//剩余商品不足m件 
			p+=q.top();
			q.pop();
		}
		if(a<p) s+=a;
		else s+=p;
		//比较，哪个便宜选哪个 
	}
	cout<<s<<endl;
	return 0;
}
```

---

## 作者：huangzilang (赞：1)

我看到题解区没有从小到大排序的代码，今天来写一篇吧。

[题目传送门](https://www.luogu.com.cn/problem/B4104)

**题目大意：**

商家共有 $n$ 件商品，单独购买第 $i$ 件商品的费用为 $a_i$。顾客也可以花费 $w$ 购买 一张优惠券，一张优惠卷最多可兑换 $m$ 件商品，求买完这 $n$ 件商品的最小费用。

**思路：**

这题我们可以从最小费用这个词来看出这题是一道贪心题，贪心策略就是按照从小到大排序，然后**从尾到头**遍历一遍数组，如果现在买了 $m$ 次了，就拿这 $m$ 次所加 $a_i$ 的和，也就是这 $m$ 件商品的价格和 $w$ 比较，这里我用了 $sum$ 来存这 $m$ 件商品的价格，然后记录答案的计数器 $ans$ 就加这两个数更小的那个，并把 $sum$ 和记录买了几次的计数器变为 $0$。

**注意事项：**

- 在遍历完了整个数组以后，我们还用加上 $sum$ 和 $w$ 的最小值，因为大部分情况都是最后还有数没加，就看最后没加的 $sum$ 与 $w$ 哪个更便宜了，即使最后全都到了 $ans$ 里了，那 $sum$ 也会被赋值为 $0$，加了和没加一样。
- 俗话说，不开 long long 见祖宗。

**代码：**


```cpp
#include<bits/stdc++.h>
#define int long long //把所有int改为long long，跟平常的没区别 
using namespace std;
int n,m,w,a[200005];
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&w);  //long long 所以输入输出要lld 
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+n+1); //从小到大排序 
	int ans=0,sum=0;
	int t=0;
	for(int i=n;i>=1;i--) //从尾到头遍历一遍数组
	{
		sum+=a[i]; //sum详见思路 
		t++; //买的次数加1 
		if(t==m) //如果现在买了m次了
		{
			ans+=min(sum,w); //计数器ans就加这两个数更小的那个
			sum=0;
			t=0;
			//并把sum和记录买了几次的计数器变为 $0$
		}
	}
	ans=ans+min(sum,w); //详见注意事项 
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：TainityAnle (赞：1)

### 题意

好像之前在 atcoder 上做过原题，题意是这样的：

有 $n$ 个数，可以花费 $w$ 的代价删掉任意 $m$ 个数或花 $a_i$ 的代价删掉第 $i$ 个数，求把序列删光的最小总代价。

### 思路

很直接的贪心，如果花掉 $w$ 的代价选的 $m$ 个数的和大于 $w$，那就是用优惠“卷”更优，否则直接买。

代码实现就是先从大到小排序，然后每 $m$ 个数放一组，统计这 $m$ 个数的和，再判断用不用优惠“卷”，如果用就把用优惠“卷”的价值 $w$ 累加到答案中否则直接加区间和。

### AC Code

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,w,a[200005],ans=0,cur=0;
bool cmp(int a,int b){
	return a>b;
}
signed main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		cur+=a[i];//当前这一组的总和 
		if(i%m==0){//选满了m个 
			ans+=(cur>=w)?w:cur;//那种方案小加哪种 
			cur=0;//开始分下一组 
		}
	}
	ans+=(cur>=w)?w:cur;//最后一组可能没分完，需要最后处理一下 
	cout<<ans;
	return 0;
}
```

---

## 作者：songge888 (赞：1)

### 题意

有一个序列 $a$，表示第 $1$ 到 $n$ 件商品的价格，$m$ 为一张优惠券能买的最大商品数，$w$ 为一张优惠券的价格。我们需要最小化购买所有商品的总费用。

### 思路

考虑**贪心**。  

题目没有购买顺序的要求，可以先把价格全存下来，为了让优惠卷的价值最大，考虑把 $a$ 序列从大到小排序，每次先选价值最大的 $m$ 个商品，如果这 $m$ 个的价值和 $sum$ 大于优惠卷的价格 $w$，就可以用优惠卷来买。  

注意最后不足 $m$ 个时也可以用优惠卷。  

时间复杂度 $O(n \log n)$。  

详见代码。

### Code

```c++
#include<bits/stdc++.h>
#define bug cout<<"songge888"<<'\n';
#define int long long
using namespace std;
int n,m,w; 
int a[200010];
int sum,ans;
int tot;
bool cmp(int x,int y){
	return x>y;
} 
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>w;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		sum+=a[i];
		tot++;
		if(tot==m){
			if(sum>w){
				ans+=w;
			}
			else{
				ans+=sum;
			}
			tot=0;
			sum=0;
		}
		
		
	}
	if(sum>w){
		ans+=w;
	}
	else{
		ans+=sum;
	}
	cout<<ans;
	return 0;
}


```

---

## 作者：joker_opof_qaq (赞：1)

## 思路

先读入进来，再排序。

考虑贪心，使得每次用优惠卷都是最优的，按每 $m$ 个数断一下，判断是否使用优惠卷即可。最后不要忘记加上还没到 $m$ 的一组数。

## AC CODE

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<iomanip>
#include<cstring>
#include<string>
#include<cmath>
#include<queue>
#include<map>
#include<list>
#include<stack>
#include<cctype>
#include<cstdlib>
#include<utility>
#include<set>
#include<bitset>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x) {
	if (x<0)x=-x,putchar('-');
	if (x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=1e6;
int a[N],sum,cnt,ans;
signed main(){
	int n=read(),m=read(),w=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+1+n);
	for(int i=n;i>=1;i--){
		if(cnt==m)ans+=min(sum,w),sum=0,cnt=0;
		sum+=a[i];
		cnt++;
	}
	cout<<ans+min(w,sum);
	return 0;
}

```

---

## 作者：jinhangdong (赞：1)

先将数组从大到小排序，再预处理一个前缀和，方便我们处理区间和，然后我们就看目前没买的物品中前 $m$ 个是优惠券便宜还是直接买便宜，因为排过序了所以前 $m$ 就是最大的 $m$ 个。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
long long n,m,w,ans,a[N],s[N];
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	cin>>n>>m>>w;
	for(int i=1;i<=n;++i) cin>>a[i];
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;++i) s[i]=s[i-1]+a[i];
	for(int i=1;i<=n;i+=m)
	{
		if(s[min(n,i+m-1)]-s[i-1]<w) ans+=s[min(n,i+m-1)]-s[i-1];//如果直接买便宜就直接买
		else ans+=w;//优惠券便宜就用优惠券 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：__CrossBow_EXE__ (赞：1)

贪心。

考虑一件事，我们肯定希望用优惠券去兑换最贵的几个商品。思路如下：

- 先将商品价格排个序，越便宜越靠前；
- 再进行枚举，枚举从哪个商品开始使用优惠券；
- 最后算出所有方案的花费，进行打擂台找最小值即可。

注意：数据大，注意使用的数据类型。

还有一个小优化：排完序后可以使用前缀和，避免计算花费时每次都要算前几件便宜的商品的价格。

具体见代码吧。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define endl '\n'
using namespace std;
int n,m,w;
int a[200005];
ll sum[200005];
ll ans=LONG_LONG_MAX;//设为最大值
int main(){
	//输入 
    cin>>n>>m>>w;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
	}
	//排序 
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];//前缀和小优化 
	ans=sum[n];//可能不用优惠券最便宜 
	for(int i=n;i>=1;i--){//从i到n共(n-i+1)个物品用优惠券 
		ll tot=0;//总花费 
		tot+=sum[i-1];
		tot+=ceil((n-i+1)*1.0/m)*w;
		if(tot<ans){//打擂台 
			ans=tot;
//			cout<<i<<endl;
		}
	}
	cout<<ans<<endl;//输出 
	return 0;
}

```

---

## 作者：Perfect_Youth (赞：1)

此题明显考虑贪心。

我们可以考虑用优惠卷去换最贵的几个商品，思路如下。

- 从大到小排序。

- 定义一个 $last$ 表示上一次购买到第 $i$ 个商品了。

- 再比较当前的 $a_{last} \ge w$ 这样子就使用优惠卷，因为 $a_{last} \ge w$ 的时候用优惠卷时绝对不亏的，$ans+=w$。

- 否则 $a_{last} < w$ 就比较用优惠卷好，还是直接购买好。

注意到数据范围很大，所以需要前缀和，和开 `long long`。

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 7;

int n, m, w, a[N], last; // last 记录当前买到第几个商品了 

long long s[N], ans; // s[i] 前缀和数组，ans 表示花费最小价格 

inline // 快读 
int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' or ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

int main() {
	n = read(), m = read(), w = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	sort(a + 1, a + 1 + n, greater<int>()); //从大到小排序 
	for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i]; // 求前缀和 
	last = 1;
	while (last <= n) { // last 一定要小于 n，否则会RE 
		if (a[last] >= w) ans += w; // 使用优惠卷 
		else {
			long long x = s[min(last + m - 1, n)/*可能不足 m 项取最小值*/] - s[last - 1];
			if (x >= w) ans += w;
			else ans += x;
		}
		last += m;
	}
	printf ("%lld", ans);
	return 0;
}
```

---

## 作者：FanzhuoOVO (赞：0)

## 题意
[**题目**](https://www.luogu.com.cn/problem/B4104)中已经表达的很明白了，在此就不在赘述了。

## 思路
先将所有商品按照价格降序排序，之后每 $m$ 个一组，答案加上这 $m$ 个商品的原价与优惠价格 $w$ 取最小值。

**注意**！最后一组有可能没算完，所以需要特判一下。
## Code

```cpp
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
ll a[200005];
bool cmp(ll x, ll y)
{
    return x > y;
}
int main()
{
    ll n, m, w, ans = 0, cnt = 0;
    cin >> n >> m >> w;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1, cmp);//从大到小排序。
    for(int i = 1; i <= n; i++)
    {
        cnt += a[i];
        if(i % m == 0)//每m个一组
        {
            ans += min(cnt, w);
            cnt = 0;
        }
    }
    if(cnt >= w)//如果最后一组没算完
    {
        ans += w;
    }
    else
    {
        ans += cnt;
    }
    cout << ans;
    return 0;//return 0好习惯
}
```

---

## 作者：Vct14 (赞：0)

题意：某商家共有 $n$ 件商品，单独购买第 $i$ 件商品的费用为 $a_i$。顾客也可以花费 $w$ 购买一张优惠券，一张优惠卷最多可兑换 $m$ 件商品。顾客可以购买任意张优惠券。求顾客购买完所有 $n$ 件商品的最小费用。

贪心地想，我们肯定尽量兑换价格高的物品。因此我们每次将当前最贵的 $m$ 件物品的价格之和与 $w$ 进行比较即可。

由于 $a_i\le10^9$，本题需要开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=2e5+2;
int a[N];

bool cmp(int a,int b){
	return a>b;
}

signed main(){
	int n,m,w;cin>>n>>m>>w;
	for(int i=1; i<=n; i++) cin>>a[i];
	sort(a+1,a+1+n,cmp);
	int nw=1,s=0;
	while(nw<=n){
		int sum=0;
		for(int i=nw; i<=min(n,nw+m-1); i++) sum+=a[i];
		s+=min(w,sum);nw=min(n,nw+m-1)+1;
	}
	cout<<s;
	return 0;
}
```

---

## 作者：luckyqwq (赞：0)

# B4104 [CSP-X2024 山东] 购物 题解

### 大致思路：

首先有个很显然的方法，将整个进行从小到大进行排序，每次计算前 $m$ 个商品的价格是否比优惠券的价格高，如果比优惠券价格高，那么显然买优惠券，否则单买，显然记录一个前缀和即可快速算出。

### 代码实现：

```
#include <bits/stdc++.h>
#define int long long
const int N = 3e5 + 10;
const int M = 105;
using namespace std;
const int mod = 1e9 + 7;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 3) + (x << 1) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
int n, m, w, a[N], sum[N], l = 1, ans;
signed main()
{
    cin >> n >> m >> w;
    for (int i = 1;i <= n; ++ i)
    {
    	cin >> a[i];
	}
	sort (a + 1, a + n + 1);
	for (int i = n;i >= 1; -- i) sum[i] = sum[i + 1] + a[i];
	for (int i = n;i >= 1; -- i)
	{
		if (i < m)
		{
			if (sum[1] - sum[i + 1] >= w)
			{
				ans += w;
			}
			else
			{
				ans += (sum[1] - sum[i + 1]);
			}
			break;
		}
		if (sum[i - m + 1] - sum[i + 1] >= w)
		{
			ans += w;
			i -= m;
			++ i;
		}
		else
		{
			ans += a[i];
		}
	}
	cout << ans << "\n";
    return 0;
}
```

这样就完成啦！！！

---

## 作者：Seraphiel (赞：0)

### 思路
很明显的贪心，贪心就要排序，为了使优惠券价值最大，同时使花费最少，应当从小到大排序再倒序计算。在排完序后一直都是求前 $m$ 项最贵的以便使用优惠券，直接累加即可。同时设一个变量保存经过了多少个商品。最后打擂台求最小值。

提醒：注意数据范围较大，所以要开 long long。

### code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
using namespace std;
ll n,m,w; 
const int N=2e5+5;
ll a[N];
int main(){
    cin>>n>>m>>w;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
	}
	sort(a+1,a+1+n);
	ll sum=0,cnt=0,minx=0;
	for(int i=n;i>=1;i--){
		sum+=a[i];
		cnt++;
		if(cnt==m){
			if(sum>w) minx+=w;
			else minx+=sum;
			sum=0;
			cnt=0;
		}
	}
	minx=minx+min(w,sum);
	cout<<minx;
	return 0;
}
```

---

## 作者：wht_1218 (赞：0)

贪心，如果当前的前 $m$ 大商品的价值总和超过了 $1$ 个优惠券的价格，就可以购买一张优惠券来抵掉，否则使用商品的原价。

从大到小排序后将每 $m$ 个商品分为 $1$ 组，最后不到 $m$ 个商品的部分特判即可。


```cpp
#ifndef _CPP_FILE
#define _CPP_FILE
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+7;
#define il inline
#define re register
#define rei register int
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
//#define abs(x) (x>0?x:-x)
inline int abs(auto x){
	return x>0?x:-x;
}
#define imx INT_MAX
#define imn INT_MIN
#define lmx LLONG_MAX
#define lmn LLONG_MIN
#define nmx (N)
#define nmn (-N)
#define umap unordered_map
#define pii pair<int,int>
#define mset multiset

/**/

int n,m,w,a[N],ans=0;
main(){
	cin>>n>>m>>w;
	for(int i=1;i<=n;++i) cin>>a[i];
	sort(a+1,a+n+1,greater<int>());
	int cnt=0,sum=0;
	for(int i=1;i<=n;++i){
		if(cnt==m){
			ans+=min(sum,w);
			cnt=sum=0;
		}cnt++;
		sum+=a[i];
	}
	cout<<ans+min(w,sum);
	return 0;
}
#endif
```

---

## 作者：fly_and_goal (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4104)
# 思路
- 输入。
- 将数组排序（从大到小）。
- 遍历数组，用 $s$ 表示准备购买个数，用 $as$ 表示购买准备购买的商品总价。如果准备购买个数等于优惠卷最多购买个数，那么 $ans$ 就加上 $as$ 和买优惠卷两者之间的较小值。
- 最后，再将 $ans$ 就加上 $as$ 和买优惠卷两者之间的较小值（买完所有东西）。
# 注意
一定要开长整型。
# code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,w,a[200005],s,as,ans;//定义
bool cmp(int i,int j)
{
	return i>j;
}//从大到小排序
int main()
{
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1,cmp);//排序
	for(int i=1;i<=n;i++)
	{
		if(s==m) ans+=min(as,w),s=0,as=0;//判断
		s++;
		as+=a[i];
	}
	cout<<ans+min(w,as);//加上最后的物品再输出
}
```

---


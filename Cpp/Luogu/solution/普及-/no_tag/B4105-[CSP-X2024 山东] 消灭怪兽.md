# [CSP-X2024 山东] 消灭怪兽

## 题目描述

怪兽入侵了地球！

为了抵抗入侵，人类设计出了按顺序排列好的 $n$ 件武器，其中第 $i$ 件武器的攻击力为 $a_i$，可以造成 $a_i$ 的伤害。

武器已经排列好了，因此不能改变顺序。某件武器可以单独攻击，也可以与相邻的武器进行组合攻击。具体来说，每次你可以把相邻的若干个（可以为 $1$ 个，即不进行组合）连续的武器组合起来进行攻击，则攻击力为这些连续的武器攻击力之和。

来自外星的怪兽拥有无敌护盾，不会受到任何伤害。

但是人类在交战过程中发现怪兽有个致命的弱点：每次当受到 $k$ 或 $k$ 的倍数的伤害时，怪兽的无敌护盾就能被打破。

请你帮助人类求出有多少种组合武器的方案，使得造成的伤害能打破怪兽的无敌护盾。

## 说明/提示

### 样例解释

样例 $1$ 解释：

$k=3$，而区间 $[1,2].[1,3],[1,5],[2,4],[3,3],[3,5],[4,5]$ 的区间和均为 $3$ 或 $3$ 的倍数，故一共有 $7$ 种方案。

### 数据范围

对于 $20\%$ 的数据，满足 $1 \leq n,k \leq 100$。

对于 $40\%$ 的数据，满足 $1 \leq n,k \leq 10^4,1 \leq a_i \leq k$。

对于另外 $10\%$ 的数据，满足 $k=2$。

对于另外 $10\%$ 的数据，满足所有的 $a_i$ 均相等。

对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^6,2 \leq k \leq 10^6,1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5```

### 输出

```
7```

## 样例 #2

### 输入

```
10 11
1 4 8 10 16 19 21 25 30 43```

### 输出

```
7```

## 样例 #3

### 输入

```
6 2
2 2 2 2 2 2```

### 输出

```
21```

# 题解

## 作者：UNDERTALE_RS (赞：7)

# B4105 [CSP-X2024 山东] 消灭怪兽 题解

[题目传送门](https://www.luogu.com.cn/problem/B4105)

## 前置知识
如果两个正整数 $a$，$b$ 除以同一个正整数 $k$ 的余数相等，则这两个数同余。记作：
$$
a \equiv b \pmod k
$$

同时两数之差能被 $k$ 整除。即：
$$
k \mid (a - b)
$$

## 题目分析

看到题目，我们思考一下，题目简化后就是问 $n$ 个数中有多少个区间和是 $k$ 的倍数。

题目中说到：
> $1 \le n \le 10^6$

所以即使是前缀和也需要用**优化**的方法。
### 前缀和
提到区间和离不开的就是前缀和。那么我们就对输入的数进行前缀和的处理。

### 计算个数
我们知道区间和的计算方法，就是在前缀和数组中的右端点位置的数减去左端点位置的前一个数。

根据前置知识，要求以 $n$ 个数中的某个数为结尾的区间和为 $k$ 的倍数的区间个数，  
就是在**前缀和数组里**找其之前与它的前缀和**关于 $k$ 同余**的数的个数。

这样我们就可以用一个计数数组来存储每一个前缀和模 $k$ 的情况。  
代码如下：

```cpp
long long a[1000005],qzh[1000005],cnt[1000005];
for(int i = 1;i <= n;i++){
	cin >> a[i];
	qzh[i] = qzh[i-1] + a[i]; //前缀和数组
	ans += cnt[qzh[i] % k]; //以现在为结尾的区间个数
	cnt[qzh[i] % k]++; //将模k的情况记录，不可调换顺序！
}
```

### 答案输出
输出答案前我们仔细想就会发现，最终的 $ans$ 没有记录到单个数的情况，所以最后输出还要补上。  
最终代码如下：

```cpp
#include <iostream>
using namespace std;
long long n,a[1000005],qzh[1000005],cnt[1000005],ans,k;

int main(){
	cin >> n >> k;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		qzh[i] = qzh[i-1] + a[i];
		ans += cnt[qzh[i] % k];
		cnt[qzh[i] % k]++;
	}
	cout << ans+cnt[0]; //cnt[0]为单个数的情况
	return 0;
}
```

## 总结
是一道基础的题，考察数学能力，需要对余数有相关认识，适合初学者练习。

感谢您的阅读！

---

## 作者：FJ_EYoungOneC (赞：6)

### 原题链接

[P8649 \[蓝桥杯 2017 省 B\] k 倍区间](https://www.luogu.com.cn/problem/P8649)

[B4105 \[CSP-X2024 山东\] 消灭怪兽](https://www.luogu.com.cn/problem/B4105)

### 解题思路

#### 20pts

我们可以枚举区间左端点 $l$ 和区间右端点 $r$，再循环统计 $[l, r]$ 的和并是否是 $k$ 的倍数，时间复杂度 $O(n^3)$。

#### 40pts

我们可以使用**前缀和**算法优化上述统计 $[l, r]$ 的区间和，时间复杂度 $O(n^2)$。

#### 100pts

我们用 $s_i$ 表示 $a_1+a_2+\dots a_i$ 的和，假设有 $a_l + a_{l+1} + \dots + a_r$ 为 $k$ 的倍数，即 $s_r \equiv s_{l-1} \pmod b$。

所以我们要计算以 $r$ 左右区间右端点时的方案数，仅需统计 $i \in [1, r - 1]$ 中与 $s_r$ 同余的 $s_i$ 的数量即可。

时间复杂度 $O(n)$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e6 + 10;

int n, k;
int h[N];

int main()
{
    cin >> n >> k;
    h[0] ++;
    LL s = 0, res = 0;
    for (int i = 1; i <= n; ++ i )
    {
        int x;
        cin >> x;
        s += x;
        res += h[s % k] ++;
    }
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：Besheep (赞：5)

$\texttt{update\ 12.26}$ 更新了表格讲解。

## 60分思路
朴素前缀和，时间复杂度 $O(n^2)$。

代码不放了。

## 正解
显然的，如果 $[l,r]$ 的区间和为 $k$ 的倍数，那前缀和数组 $\mathrm{qz}[r]-\mathrm{qz}[l-1] \bmod k$ 的值一定为 $0$。

那我们就可以让前缀和数组的每一行都对 $k$ 取模，即 `qz[i]=(qz[i-1]+a[i])%k`。

（以样例 1 为例）。

||$1$|$2$|$3$|$4$|$5$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|前缀和|$1$|$3$|$6$|$10$|$15$|
|前缀和 $\bmod k$|$1$|$0$|$0$|$1$|$0$|


对于上表，不难发现，对于区间 $[l,r]$，若区间和对 $k$ 取模等于 $0$，那么 $\mathrm{qz}[l]$ 与 $\mathrm{qz}[r]$ 的值是相等的。

我们可以开一个桶，去记录每个余数出现的次数，不难发现，每一个余数对结果的贡献为 $\mathrm{bot}[i] \times (\mathrm{bot}[i]-1) ÷2$，每个余数贡献相加即为答案。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
#define ll long long
ll n,k,a[N],qz[N],bot[N],ans;
int main() {
    cin>>n>>k;
    bot[0]=1;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
		qz[i]=(qz[i-1]+a[i])%k;
		bot[qz[i]]++;
	}
	
	for(int i=0;i<k;i++){
		if(bot[i]>1) ans+=bot[i]*(bot[i]-1)/2;
	}
	cout<<ans;
    
	return 0;
}

```

---

## 作者：TainityAnle (赞：3)

### 题意

给定一个序列，问有多少个区间和是 $k$ 的倍数。

### 思路

很容易想到前缀和，但是枚举子区间是 $n^2$ 的，不行。

但是我们发现 $k$ 的范围比较小，又要求是倍数，我们给前缀和取个模，不影响统计答案。

考虑什么情况下满足条件。设 $a_i$ 表示 $i$ 位置的前缀和对 $k$ 取余后的结果。发现如果 $a_i=a_j$，那么 $a_j-a_i=0$，说明区间 $[i-1,j]$ 的和是 $k$ 的倍数。

这样就转化成了求有多少对相等的数字，开一个桶维护一下即可。

设 $t_{k}$ 表示 $k$ 在 $a_i$ 中出现的次数，枚举每个 $k$，因为每个出现的值都可以和前面的数字配对，所以答案是 $(t_k-1)+(t_k-2)+(t_k-3)+\dots+1$ 即 $\frac{t_k\times(t_k-1)}{2}$。如果一个区间的和本来就是 $k$ 的倍数，那么要多算一次，处理方法就是给 $t_0$ 加上 $1$。

最后一定要记得开 long long。

### AC Code

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[1000006],t[1000006],ans;
signed main(){
	cin>>n>>k;
	t[0]=1;
	for(int i=1;i<=n;i++) cin>>a[i],a[i]+=a[i-1];
	for(int i=1;i<=n;i++) t[a[i]%k]++;
	for(int i=0;i<k;i++) ans+=t[i]*(t[i]-1)/2;
	cout<<ans;
	return 0;
}
```

---

## 作者：AnOIer (赞：1)

## 题意简化

求 $n$ 个数中有多少个区间的和是 $k$ 的倍数。

## 分析

设 $sum$ 为数列 $a$ 的前缀和数组：

考虑给 $sum$ 对 $k$ 取模，这样当区间 $[l,r]$ 和为 $k$ 的倍数时，$sum_r-sum_l=0$，可得区间 $[l-1,r]$ 的和为 $k$ 的倍数。

要使 $sum_r-sum_l=0$，则 $sum_r=sum_l$，所以要求 $sum$ 中有多少相同的数对。

用桶 $cnt_t=p$ 表示 $t$ 在 $sum$ 中有 $p$ 个，最后对答案的贡献即为 $(p-1)+(p-2)+(p-3)\cdots+1=\frac{p(p-1)}{2}$。

最后，本来就是 $k$ 倍数的区间要多加一次。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000100],sum[1000100],cnt[1000100],ans;
signed main(){
	int n,k;
	cin>>n>>k;
	cnt[0]=1;//多加一次
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		cnt[sum[i]%k]++;
	}
	for(int i=0;i<k;i++) ans+=cnt[i]*(cnt[i]-1)/2;
	cout<<ans;
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

怎么感觉在 CF 里见到过模 $7$ 的。

由于顺序不能变，容易想到维护前缀和。但是统计答案时需要 $O(n^2)$ 无法通过。由于只用是 $3$ 的倍数即可，考虑在维护前缀和时对 $3$ 取模并开桶 $t$ 存储余数出现次数。

我们知道每两个余数相同的前缀和就会对答案造成 $1$ 的贡献，因此答案为 $\sum\limits_{i=0}^{k-1}C_{t_i}^2=\sum\limits_{i=0}^{k-1}\dfrac{t_i(t_i-1)}2$。

由于 $a_i\le10^9$，本题需要开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+2;
int t[N];

signed main(){
	int n,k;cin>>n>>k;
	int a,lst=0;t[0]++;
	for(int i=1; i<=n; i++){
	    cin>>a;a=(a+lst)%k;
	    t[a]++;lst=a;
	}
	int s=0;
	for(int i=0; i<k; i++) s+=t[i]*(t[i]-1)/2;
	cout<<s;
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4105)

## 思路：

容易想到用**前缀和**维护，存在数组 $s$ 中，但是枚举每一个区间是 $O(n^2)$ 的，而 $n \le 10^6$，不可取。

但是题目其实是要我们找到所有区间和是 $k$ 的倍数的区间和的个数，那么就可以先给前缀和取模，设为数组 $u$ 吧，然后通过观察可以得出如果有 $u_i-u_j = 0$ 则有 $s_j-s_i \bmod k=0$。

所以就可以用桶来储存 $u$ 的每一项，找出大于 $2$ 的再套一遍等差数列求和公式即可。

**注意：**

1. 桶中的储存 $0$ 的位置初始值为 $1$，其他位置初始为 $0$。
2. **long long**！

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
long long x,y,a;
long long s[1000005];//前缀和 
long long ds[100005];//取模后的前缀和 
long long t[1000005];//桶 
int main(){
	cin>>x>>y;
	for(int i=1;i<=x;i++){
		cin>>a;
		s[i]=s[i-1]+a;
		ds[i]=(s[i]%y);
	}
	t[0]=1;//初始化 
	for(int i=1;i<=x;i++) t[ds[i]]++;
	long long da=0;
	for(int i=0;i<y;i++){
		if(t[i]>=2){
			da+=((t[i]*(t[i]-1))/2);//等差数列求和公式 
		}
	}
	cout<<da<<endl;
	return 0;
}
```

---


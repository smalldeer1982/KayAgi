# [CSP-X2024 山东] 翻硬币

## 题目描述

$n$ 枚硬币从左到右依次排成一排，编号依次为 $1$ 到 $n$。硬币的正面朝上用 $0$ 表示，背面朝上用 $1$ 表示，一开始所有的硬币都是正面朝上。

现进行 $m$ 次操作，每次操作是把一个区间内的所有硬币翻过来：原来正面朝上的变为反面朝上，原来反面朝上的变为正面朝上。

第 $i$ 次操作的区间 $[l_i,r_i]$：表示把从第 $l_i$ 到第 $r_i$ 枚之间的所有硬币都翻过来。

求 $m$ 次操作后所有硬币从左到右依次组成的 $01$ 数字序列。

## 说明/提示

对于 $60\%$ 的数据 $1 \leq n,m \leq 1000$。

对于 $100\%$ 的数据 $1 \leq n,m \leq 2 \times 10^5$。

## 样例 #1

### 输入

```
5 3
2 4
1 3
3 5```

### 输出

```
10101```

## 样例 #2

### 输入

```
10 5
1 6
8 10
3 7
4 6
2 5```

### 输出

```
1010011111```

# 题解

## 作者：dear_deer_land (赞：6)

~~看到众多 dalao 用分块、线段树爆砍橙题，本蒟蒻瑟瑟发抖~~

## 思路

看到只有一个区间修改操作（即翻一整个区间的硬币）时，第一时间就想到了差分。先来讲一下什么是差分，如果我们有一个数组 b，那么我们用一个数组计算 $b_{i}$ 与 $b_{i-1}$ 的差，把这个值记作 $a_{i}$，这个数组 $a$ 便是我们的差分数组。但是由于本题的特殊性，即所有硬币的初始状态都是正面朝上，即 $a$ 数组初始全为零。在处理完差分数组后，对于每一次翻硬币的操作，例如翻区间 $l \sim r$ 的硬币，那么就将差分数组 $a$ 的 $a_{l}+1$（即翻面），$a_{r+1}-1$（后面的硬币并没有被翻过来），这样便是一次操作的流程。经过 $m$ 次操作后，将差分数组进行前缀和操作，便可以得到更改后每一枚硬币的修改结果，此时取余 $2$ 就是当前硬币的最终状态。

## 代码

在捋清思路后，代码还是很简单的。

```
#include <bits/stdc++.h>
#define ll long long
#define bug puts("!!!====!!!=");
using namespace std;
int n,m,a[200200];
void cha(int l,int r){//差分板子 
	a[l]+=1;
	a[r+1]-=1;
} 
int main(){
	cin>>n>>m;
	for(int i=1,l,r;i<=m;i++){
		cin>>l>>r;
		cha(l,r);
	}
	for(int i=1;i<=n;i++){
		a[i]+=a[i-1];
		a[i]%=2;
		if(a[i]!=0){
			a[i]=1;
		}
		cout<<a[i];
	}
	return 0;
}
```

---

## 作者：TainityAnle (赞：5)

~~全场最劣解祭。~~

### 题意

给定一个初始为 $0$ 的序列，每次可以将它的一个区间 01 翻转，问这个区间的最终结果。

### 思路

容易发现一个点被翻奇数次就会变成 $1$，翻偶数次就会变成 $0$。所以我们只需要统计每个点被翻转的次数。

每次翻转一个区间，可以用区间加，但是线段树的代码过于复杂，会吓到小学组的孩子们，我选择使用优化后的暴力。

我们可以给这个区间分成若干个长度为 $\sqrt{n}$ 的块。对于每次修改的区间可以被分为三部分：中间的整块，左边不足一块的和右边不足一块的部分。

对于中间的整块，给每一个块打上一个加 $1$ 的标记，对于两遍不足一块的部分，直接暴力加就好了。发现中间块的个数不会超过 $\sqrt{n}$，两遍的长度分别不会超过 $\sqrt{n}$，所以总体一次修改就是 $O(\sqrt{n})$ 的。

查询的时候，只需要将每个点所在块的加 $1$ 标记数和暴力加的次数加起来即可。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,pos[200050],len,a[200005],b[500],L[500],R[500];//a是每个数暴力加的次数，b是每个块的标记 
void add(int l,int r){
	int p=pos[l],q=pos[r];
	if(p==q){//特判修改端点在一个块的情况 
		for(int i=l;i<=r;i++) a[i]++;
		return;
	}
	for(int i=l;i<=R[p];i++) a[i]++;//处理左边散块 
	for(int i=L[q];i<=r;i++) a[i]++; //处理右边散块 
	for(int i=p+1;i<=q-1;i++) b[i]++; //处理整块 
}
int main(){
	cin>>n>>m;
	len=sqrt(n);
	for(int i=1;i<=len;i++){
		L[i]=(i-1)*sqrt(n)+1;
		R[i]=i*sqrt(n);
	}
	if(R[len]<n){
		len++;
		L[len]=R[len-1]+1,R[len]=n;
	}
	for(int i=1;i<=len;i++)
		for(int j=L[i];j<=R[i];j++)
			pos[j]=i;
	//以上是分块预处理，维护每个块左、右端点，每个点属于哪个块 
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		add(x,y);
	}
	for(int i=1;i<=n;i++) {
		int val=a[i]+b[pos[i]];
		cout<<(val&1);
	}
	return 0;
}
```

这份代码以 $O(n\sqrt n)$ 的时间复杂度成功地成为了本题 AC 记录中最慢的一个，10 个点共耗时 600ms。

---

## 作者：0Io_oI0 (赞：3)

首先注意到数据范围，按照题目模拟是会 TLE 的，于是我们换一种思路差分。

首先注意到由于一开始硬币都是正面朝上，所以反转偶数次硬币朝上，反转奇数次硬币朝下，容易想到我们可以给定义一个 $a$ 数组来记录每个硬币反转的次数，最后再模 $2$ 输出即可。

我出示一下差分的过程：
```cpp 
for(int i=1;i<=m;i++){
	cin>>l>>r;
	a[l]++;
	a[r+1]--;
}
for(int i=1;i<=n;i++)a[i]+=a[i-1];
```
剩下的代码就很好写了！补全代码即可 AC！

---

## 作者：Besheep (赞：2)

考虑到修改区间，自然而然地想到差分（对于差分不了解的小朋友移步 [P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)）。

我们可以维护一个数组，通过差分记录每个硬币的反转次数。
- 如果最终反转次数为偶数，那么相当于从从 $0$ 反转到 $1$ 在反转到 $0$，最终的结果还是 $0$。反之，结果则为 $1$。

最终得出以下程序：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
#define ll long long
ll n,m,l,r,a[N]; 
int main() {
    cin>>n>>m;
    while(m--){
    	cin>>l>>r;
		a[l]++,a[r+1]--; 
	}
	for(int i=1;i<=n;i++){
		a[i]+=a[i-1];
		if(a[i]%2==1) cout<<1;
		else cout<<0;
	}
	return 0;
}

```

---

## 作者：lam_dyr (赞：2)

# B4106 \[CSP-X2024 山东] 翻硬币

## 题意

有一个长度为 $n$ 的 01 串，初始全部为 0。
有 $m$ 次操作，每次操作输入 $l_i,r_i$, 含义是把 $[l_i,r_i]$ 内所有数取反。

求 $m$ 次操作后的序列。

## Solution

可以使用一个差分数组 $a$ 来表示硬币的状态变化。其中，$a_i$ 表示第 $i$ 个硬币的状态变化。

初始时，所有硬币都是正面朝上，所以我们可以将所有的 $a_i$ 初始化为 $0$。

当进行一次操作时，需要将操作区间 $[l, r]$ 内的所有硬币翻转。我们可以通过将差分数组的第 $l$ 个元素加 $1$，第 $r+1$ 个元素减 $1$（如果 $r+1$ 小于或等于 $n$）来实现这一点。

这是因为，当我们将第 $l$ 个硬币翻转时，我们需要将其状态从 $0$ 变为 $1$，所以我们将第 $l$ 个元素加 $1$。当我们将第 $r$ 个硬币翻转时，我们需要将其状态从 $0$ 变为 $1$，所以我们将第 $r+1$ 个元素减 $1$（如果 $r+1$ 小于或等于 $n$）。

通过这种方式，我们可以将所有硬币的状态变化表示为一个差分数组。

最后，我们需要计算出所有硬币的状态。可以通过将差分数组的所有元素累加起来来实现这一点。

具体来说，我们可以使用一个变量 $sum$ 来表示累加的结果。我们从第 $1$ 个元素开始，依次将每个元素加到 $sum$ 中，并输出 $sum$ 除以 $2$ 的余数（即 $sum\bmod2$）。

这是因为，当 $sum$ 为偶数时，表示硬币的状态为 $0$（正面朝上），当 $sum$ 为奇数时，表示硬币的状态为 $1$（反面朝上）。

通过这种方式，我们可以输出所有硬币的状态。

## Code

```cpp
#include <iostream>
using namespace std;
int n, m;
int a[1000010];
int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        a[l]++;
        if (r + 1 <= n) a[r + 1]--;
    }
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += a[i];
        cout << (sum % 2);
    }
    return 0;
}
```

## end

---

## 作者：qsn123 (赞：1)

~~怎么还有小学组啊......~~

这道题可以利用异或运算来简化。

> 异或（Exclusive OR，简称 XOR）是一种数学运算符，常用于逻辑运算与计算机中的位运算。当且仅当两个输入值不同时，异或运算输出为真，否则输出为假，即“同为 $ 0 $，异为 $ 1 $”。异或运算可以通过数学符号“$ \oplus $”表示， 具有交换律、结合律、恒等律等性质。

——以上内容摘自百度百科。

通俗的讲，就是“只有两个对应位不同时才为 $ 1 $”的位运算。

了解了异或运算后，考虑我们对一个位置翻转的操作可以转化成什么。不难发现，将一枚硬币翻转，等价于将其值异或上 $ 1 $。发现这个就可以很轻易地拿到部分分了。当然只为了部分分你还可以直接暴力。

然后思考我们如何处理区间操作，这里需要几个异或运算的性质：

**一个数异或它本身的结果为 $ 0 $。**

**一个数异或 $ 0 $，其值不变。**

所以我们可以发现，对任何位置进行偶数次操作，其状态不变。

（其实在题面里，就是一个硬币被翻两次相当于没翻。~~好像用异或说明还麻烦了点~~）。

于是我们统计每个位置被翻转的次数即可这相当于维护一个序列，支持区间加，最后统一求值。这个东西可以直接差分实现。

似乎我们还没有利用到极致。再思考一下，两次异或运算相抵消，那么我们是不是可以在某一段的开头进行一次异或，在结尾再进行一次消除影响，之后传递下来......这不就是差分么！

换句话说，异或操作本身，也是支持前缀和操作和差分操作的。

于是我们得到了一份比直接差分操作次数快了那么一点点的代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200050;
int a[N];
int main()
{
	int n,m,ans=0,l,r;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&l,&r);
		a[l]^=1;//进行异或运算，差分统计其状态。
		a[r+1]^=1;
	}
	for(int i=1;i<=n;i++){
		ans^=a[i];//做异或前缀和。
		printf("%d",ans);
	}
	return 0;
} 
```

于是我们解决了这个题。

实际上，异或运算的性质繁多，功能强大，在很多奇奇怪怪的地方都可以见到它的应用。考虑到是小学组的题目，在此不做进一步延展，建议自行进一步学习。

---

## 作者：wht_1218 (赞：0)

差分板子。

设奇数代表硬币朝下，偶数代表硬币朝上。

这样题目可以抽象为每次将 $l_i,r_i$ 的每个值 $+1$。

可以用~~线段树维护~~差分维护，对于将 $l_i,r_i$ 的每个值 $+k$ 的情况，使差分数组 $d_x=d_x+k,d_{y+1}=d_{y+1}-k$ 即可，这里 $k=1$。

最后输出时判断一下奇偶性即可。


```
#ifndef _CPP_FILE
#define _CPP_FILE
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+7;
#define il inline
#define re register
#define rei register int
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
//#define abs(x) (x>0?x:-x)
inline int abs(auto x){
	return x>0?x:-x;
}
#define imx INT_MAX
#define imn INT_MIN
#define lmx LLONG_MAX
#define lmn LLONG_MIN
#define nmx (N)
#define nmn (-N)
#define umap unordered_map
#define pii pair<int,int>
#define mset multiset

/**/

int n,m,a[N];
main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int x,y;cin>>x>>y;
		a[x]++;
		a[y+1]--;
	}int sum=0;
	for(int i=1;i<=n;++i){
		sum+=a[i];
		cout<<sum%2;
	}
	return 0;
} 
#endif
```

---


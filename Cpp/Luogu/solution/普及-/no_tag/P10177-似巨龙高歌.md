# 似巨龙高歌

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/wpc73r2k.png)

拜谢 whk 神犇帆巨/bx

尽管帆帆文化课很强，但在新年他不想给同龄蒟蒻带来太大压力，于是他准备对一年的考试成绩做一些手脚……

## 题目描述

面对着自己向巨龙一样腾飞的成绩，新年到来时帆帆忍不住唱起了《爱你》。

他今年一共有 $n$ 次考试，第 $i$ 次考试的排名是 $a_i$。

这在无形之中给别的同学造成了压力，于是他希望把自己的 $n$ 次排名进行重排，使得进步最大的一次考试进步的名次最少，这样他就可以隐藏自己的实力。

对于第 $i$ 次和第 $i+1$ 次考试（$1\le i < n$），他的进步名次即为 $a_i-a_{i+1}$，如果该值为负则代表他退步了。


请你帮帮他。


## 说明/提示


### 【样例 1 解释】

帆帆不改变原本的考试序列，那么从第一次到第二次考试进步了 $0$ 名（排名没变化）。

### 【样例 2 解释】

帆帆可以把自己的考试排名重排为 $1,2,3,4$，那么他每次考试都进步了 $-1$，所以答案是 $-1$。 

本题采用捆绑测试

### 【数据范围】

- 对于 $30\%$ 的数据，保证 $n\le 10$。

- 对于 $50\%$ 的数据，保证 $n\le 5000$。

- 对于另外 $20\%$ 的数据，保证 $a_i\le 2$。

- 对于 $100\%$ 的数据，保证 $2\le n\le 10^6$，$1\le a_i\le 10^9$。

## 样例 #1

### 输入

```
2
1 1```

### 输出

```
0```

## 样例 #2

### 输入

```
4
2 4 1 3```

### 输出

```
-1```

# 题解

## 作者：云浅知处 (赞：13)

容易发现，如果把 $a_i$ 从小到大排序，那么 $a_i-a_{i+1}\leq 0$，否则一定有一项 $>0$ ，因此我们从小到大排序，求相邻两项差的最大值即可。

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){
    int x=0,f=1;char c=getchar();
    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
    return x*f;
}

void cmax(int &x,int v){x=max(x,v);}
void cmin(int &x,int v){x=min(x,v);}

const int N=1e6+5;
int n,a[N];

signed main(void){

    n=read();
    for(int i=1;i<=n;i++)a[i]=read();
    sort(a+1,a+n+1,greater<int>());
    int ans=-1e9;
    for(int i=1;i<n;i++)cmax(ans,a[i+1]-a[i]);
    cout<<ans<<endl;

    return 0;
}
```

---

## 作者：sLMxf (赞：8)

由于要保证进步最小，所以我们要保证没有进步。或者说，进步为负数。

于是考虑对 $a$ 进行升序排序便可。
```cpp
#include<bits/stdc++.h>
using namespace std;
bool cmp(int x,int y)
{
	return x<y;
}
int a[10000008];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1,cmp);
	int ans=-INT_MAX;
	for(int i=1;i<n;i++) ans=max(ans,a[i]-a[i+1]);
	cout<<ans;
}
```

---

## 作者：SXqwq (赞：4)

### Description

给定一个长度为 $n$ 的数组 $a$。你可以对 $a$ 进行重排使得 $a_i -a_{i+1}$ 的最大值最小。并输出这个结果。

### Analysis

水题。

结论：当 $a$ 单调不下降时为最优解。

反证：当 $a$ 单调不下降时，$a_i-a_{i+1} \leq 0$。若交换 $a_i$，$a_{i+1}$。$a_i-a_{i+1} \geq 0$。我们要求最大值最小，显然第一种情况更优。

处理的时候需要注意一些细节，比如初始化 `MAXN` 应当赋为负无穷大。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1000010;
int a[N];
int n;
int maxn = -INF;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<n;i++)
	{
		maxn = max(maxn,a[i]-a[i+1]);
	}
	cout<<maxn<<endl;
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：4)

题面很简单，是吧？

结论从第二个样例就能看出来，倒序排序。

用邻项交换法可以证明。

设 $a_i \le a_{i+1}$。

$a_{i+1}-a_i$ 非负。

交换一下。

$a_i-a_{i+1}$ 非正。

答案一定比 $a_i \le a_{i+1}$ 优。

得证。

不给代码了。

---

## 作者：deepthinker (赞：4)

### 一道签到题（但蒟蒻只会做这道题QAQ）
[题面传送门](https://www.luogu.com.cn/problem/P10177)
### 思路
题目要求数组中前一项减后一项的值中的最大值最小。不难得知，我们可以通过升序排列来解决这个问题，再开一个变量记录最大值即可。

代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
int a[1000005];//数组记得开大，否则就会像我一样RE
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);//排序
    int maxx = -1e9;//要开-1e9，因为可能为负数
    for (int i = 2; i <= n; i++)
    {
        maxx = max(a[i - 1] - a[i], maxx);//记录
    }
    cout << maxx;//输出
    return 0;
}//撒花！
```


---

## 作者：very_easy (赞：3)

首先观察题目样例得出一个结论：直接对 $a$ 排序，然后找相邻两项差最小的。

那么这个结论是否正确呢？

我们可以利用反证法来验证。

反证法：是间接论证的方法之一，是通过断定与论题相矛盾的判断（即反论题）的虚假来确立论题的真实性的论证方法。----百度百科。

听起来是不是很高大上？其实就是把你的结论反过来，如果这个结论不成立，那么你的结论就一定成立。

举一个简单的例子：一个数 $n$ 最多只有一个大于 $\sqrt{n}$ 的因数，这个简单的结论大家都知道，但是可以用反证法来验证它，如果一个数 $n$ 有两个以上大于 $\sqrt{n}$ 的因数，那么它们相乘一定大于 $n$ 了，因此原来的结论成立。

同样的，此题也可以利用反证法来验证，那就是如果不将整个数列从小到大排序，会产生更小的进步。

这个结论应该一眼就能看出来一定不成立，因为如果不将数列排序，那么一定会出现 $a_i \ge a_{i+1}$ 的情况，始终在进步，而排序后所有 $a_i$ 都 $\le a_i+1$，一直在退步。因此，可以证明直接将数列从小到大排序的做法是正确的。

~~本篇博客废话很多~~，主要原因是因为反证法其实很好理解，但是很难描述，看不懂的可以去看看其他比较好理解的题解，~~那这个题解还有啥用~~，本篇仅仅是想提供一个更加优秀的证明方法~~难到其他证明方法不优秀吗？~~

## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int a[N];
int main(){
	int n,ans=-2e9;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<n;i++){//注意这个小细节，是<n而不是<=n
		ans=max(ans,a[i]-a[i+1]);
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：XingnoYi (赞：1)

# 一、题意简述：
已知 $n$ 次考试的名次，请给出一种排列（名次）的方式，使得进步最大的一次考试进步最小。

# 二、思路分析：
考虑**贪心**。

要使进步最大的一次进步最小，是否可以使每次考试都**退步一点**？

是可以的，只要将名次以**从小到大**的顺序排列，就可以使每次考试都退步。

事实上，这就是我们所需的正确排列。

## 为什么是正确的？

使用**反证法**。

假如不是以从小到大的顺序排列，那么至少有一次考试会进步。

也就是一定会有若干个名次比它后面的名次大，**这时他就进步了**。

无论我们使这个进步名次尽可能小，也没有退步名次小。

所以从小到大是正确排列。

# 三、代码实现：
```cpp
#include <iostream>
#include <algorithm>
#define big long long
using namespace std;
big n;
big a[1000006];
big maxn = -1e18; // 初始化答案
int main()
{
	scanf("%lld",&n);
	for(big i = 1;i <= n;i++)
	{
		scanf("%lld",a+i);
	}
	sort(a+1,a+n+1);
	for(big i = 2;i <= n;i++)
	{
		maxn = max(maxn,a[i-1]-a[i]); // 注意是 前一次减去后一次
	}
	cout << maxn;
	return 0;
}
```

---

## 作者：Pink_Cut_Tree (赞：1)

# P10177 似巨龙高歌 题解

### 解析

结论：将分数从小到大排序，找出差值中的最大值即可。

证明：假设 $\exists 1\leq i\leq n$，且我们（手动）将数列排序为 $a_1,a_2\cdots a_{i+1},a_i,a_{i+2},\cdots a_{n-1},a_n$。这时最大的进步值为 $a_{i+1}-a_i\geq 0$。而从小到大排序时最大的进步值全部为非正数，优于这种新构造出的排列。则这样的排列一定没有从小到大的排列优。

P.S 上面的 $a_i$ 指的是从小到大排序第 $i$ 小的数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+6;
int n;
int a[N],ans=-1e9;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	} 
	sort(a+1,a+n+1);
	for(int i=1;i<n;i++){
		ans=max(ans,a[i]-a[i+1]);
	}
	cout<<ans;
return 0;
}
```


---

## 作者：xutengyuan (赞：1)

首先我们输入 $n$ 个 $a_i$。

然后将 $a_i$ 排序。

最后输出相邻两项只差最大的那个差值即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000010],n,b[1000010];
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	int m = -2147483647;
	for(int i = 1;i<=n;i++){
		if(a[i]-a[i+1]>m && i<n){
			m = a[i]-a[i+1];
		}
	} 
	cout<<m;
	return 0;
}
```

---

## 作者：Bc2_ChickenDreamer (赞：0)

# P10177 题解

## Sol

我们知道，整数 $a, b$ 满足 $a - b \le 0$ 需要满足 $a \le b$。我们把它带入 $a$ 数组里相邻两个数的关系，就变成了 $a_1 \le a_2 \le \cdots \le a_n$。

这时，你会发现，这不就是升序排序吗？所以得出结论，答案为 $a$ 数组排序后的 $\max_{i = 2}^{n} a_{i - 1} - a_i$。因为如果不按升序排序，那么 $a_{i - 1} - a_i$ 总会有一个 $> 0$。

## Core Code

```cpp
sort(a + 1, a + n + 1);
int ans = -1e9;
for (int i = 2; i <= n; ++ i) {
  ans = max(ans, a[i - 1] - a[i]);
}
```

---

## 作者：Lemon_zqp (赞：0)

### 思路
其实题目的简化就是说让你求数重排后所有差的最大值，那么就要让所有差尽可能小，才能满足题目隐藏实力的要求，那么最优的选择就是让这个数列全部从小到大，使得 $a_i - a_{i-1}\le 0$。最后挨个求最大值即可。
### 代码
```
#include<bits/stdc++.h>
using namespace std;

int a[1000005];

int main(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    sort(a + 1, a + n + 1);
    int maxn = -1e9;
    for(int i = 1; i <= n - 1; i++){
        if((a[i] - a[i + 1]) > maxn){
            maxn = (a[i] - a[i + 1]);
        }
    }
    cout << maxn;
    return 0;
}
```


---

## 作者：Eason_cyx (赞：0)

最后一个小时看了下题，一眼过了 T1。

既然要上升的排名最小，且可以是负数，那么我们肯定选择负数。但如果整个序列中出现了一个正数，那负数就没用了。因此要全为负数。换句话说，每一个 $a_i$ 都要比 $a_{i-1}$ 大。那么从小到大排序后取差的最大值即可。

时间复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000005];
int main() {
    int n; cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    sort(a+1,a+n+1);
    int maxn = -0x7fffffff;
    for(int i = 1;i < n;i++) maxn = max(maxn,a[i]-a[i+1]);
    cout << maxn << endl;
    return 0;   
}
```

[AC Record](https://www.luogu.com.cn/record/147536869)

---


# [COCI 2023/2024 #3] Eurokod

## 题目背景

**译自 [COCI 2023/2024 Contest #3](https://hsin.hr/coci/archive/2023_2024) T1「[Eurokod](https://hsin.hr/coci/archive/2023_2024/contest3_tasks.pdf)」**

## 题目描述

Eurokod，全球美丽与高可读性代码竞赛，今年第一次举行！

共有 $n$ 名参赛者参加了竞赛，他们被依次编号为 $1\sim n$。每名参赛者已经编写了一份代码。

他们的代码将由一组计算机科学家进行评估。这组计算机科学家分为组长与其他成员，组长将用一种方法给出评分，其他成员则用另一种方法给出评分。

**组长评分：**

组长按照他的想法，将代码按照美丽程度从大到小排序。最美丽的代码将获得 $n$ 分，其他代码依次比上一名少一分。

**其他成员评分：**

每名其他成员将投票选出自己认为最美丽的代码。在所有其他成员投票后，所有代码按照投票人数从高到低排序。得票数最多的代码将获得 $n$ 分，其他代码依次比上一名少一分。

**总分：**

一份代码的总分由组长评分与其他成员评分加和得到。

你的任务是按照得分降序输出代码的编号。如果两份代码得分相同，其他成员评分高者列前。

## 说明/提示

### 样例解释 1

Kod03 和 Kod02 得分相同，但 Kod03 从其他成员处获得了更高的分数，所以 Kod03 排名列前。

### 样例解释 2

组长给予 Kod05 最高的排名，它因此获得 $n=5$ 分。

### 子任务

| Subtask | Points | Constraints |
|:--:|:--:|:--:|
| 1|17|对于每一份代码，其他成员投的票数与其他成员评分在数值上相同。同时，没有两份代码总分相同。|
|2|19|没有两份代码总分相同。|
|3|14|无特殊限制。|

## 样例 #1

### 输入

```
3
1 2 3
50 10 20```

### 输出

```
1. Kod01 (6)
2. Kod03 (3)
3. Kod02 (3)```

## 样例 #2

### 输入

```
5
5 2 4 1 3
4 5 2 1 3```

### 输出

```
1. Kod02 (9)
2. Kod05 (8)
3. Kod01 (6)
4. Kod04 (4)
5. Kod03 (3)```

## 样例 #3

### 输入

```
7
6 3 2 1 5 4 7
200 56 11 0 13 105 12```

### 输出

```
1. Kod06 (13)
2. Kod01 (11)
3. Kod02 (10)
4. Kod03 (8)
5. Kod05 (7)
6. Kod07 (4)
7. Kod04 (3)```

# 题解

## 作者：liujinhan12 (赞：8)

根据[题目](https://www.luogu.com.cn/problem/P10223)可知
- 组长评分：第 $ i $ 个整数表示组长评为第 $ i $ 名代码的**编号**

- 其他成员评分： 第 $ i $ 个整数表示其他队员投给编号为 $ i $ 的人的**票数**

------------

也就是说组长评分的编号无序，而其他成员评分的编号有序。

于是有了第一次排序，把组长评分的编号从小到大排好。

------------

然而其他成员评分的票数是无序的。

所以第二次排序，把其他成员评分的票数从大到小排好，就可以得到该评分 $ n-i+1 $ 。

------------

最后再把总评分排序就好了。

代码展示


```
#include<bits/stdc++.h> 
using namespace std;
long long n;
struct node{
	long long bh,zz,qt,hh;
}a[200000]; 
bool cmp1(node x,node y)
{
	return x.bh<y.bh;
}
bool cmp2(node x,node y)
{
	return x.qt>y.qt;
}
bool cmp3(node x,node y)
{
	if(x.hh+x.zz==y.hh+y.zz)//如果评分相同则从其他成员给的票数来决定谁在前 
	return x.qt>y.qt;
	return x.hh+x.zz>y.hh+y.zz;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)//编号 
	cin>>a[i].bh;
	for(int i=1;i<=n;i++)//组长评分 
	a[i].zz=n-i+1;	
	sort(a+1,a+1+n,cmp1);//第一次排序 
	for(int i=1;i<=n;i++)//其他成员票数 
	cin>>a[i].qt;
	sort(a+1,a+1+n,cmp2);//第二次排序 
	for(int i=1;i<=n;i++)//其他成员评分 
	a[i].hh=n-i+1;
	sort(a+1,a+1+n,cmp3);//第三次排序 
	for(int i=1;i<=n;i++)
	{
		cout<<i<<". Kod";
		if(a[i].bh>=10)
		{
			
			cout<<a[i].bh<<" ("<<a[i].hh+a[i].zz<<")"<<endl;
		}
		
		else 
		{
			cout<<0<<a[i].bh<<" ("<<a[i].hh+a[i].zz<<")"<<endl;
		}
	}
	
    return 0;
}
```

---

## 作者：__AFO__ (赞：5)

## 题解
[题目传送门](https://www.luogu.com.cn/problem/P10223)

这是一道排序模拟题，首先组长的评分是用题目编号的排名输入的，所以给对应的代码编号总分加上 $n-i+1$ 分即可。

第二，输入的是其他成员的评分，记录代码编号，将其他成员的评分排序，也给对应的代码编号总分加上 $n-i+1$ 分即可。

最后给总分排序，输出即可。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
struct nn{
	long long ii,zu,qi;
}a[1000001];
struct nnn{
	long long fen,qii,id;
}k[1000001];//记录总分 
bool cp(nn x,nn y){
	return x.qi>y.qi;//从大到小排序 
}
bool cmp(nnn x,nnn y){//如果总分一样，比其他成员的分数 
	if(x.fen==y.fen) return x.qii>y.qii;
	else return x.fen>y.fen; 
}
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
	scanf("%lld",&a[i].zu);//组长评分 
	k[a[i].zu].fen+=n-i+1;//给对应编号代码加分 
	}
	for(long long i=1;i<=n;i++){
	scanf("%lld",&a[i].qi);//其他成员评分 
	k[i].qii=a[i].qi;//k数组重复记录 
	k[i].id=i;//k数组重复记录 (最后有用） 
	a[i].ii=i;// 记录编号 
	}
	sort(a+1,a+1+n,cp);//给其他成员评分排序 
	for(long long i=1;i<=n;i++){
		k[a[i].ii].fen+=n-i+1;//给对应编号代码加分 
	}	
	sort(k+1,k+1+n,cmp);//总分排序 
	for(long long i=1;i<=n;i++){
		if(k[i].id<10) cout<<i<<". Kod0"<<k[i].id<<" ("<<k[i].fen<<")"<<endl;//如果编号小于十，序号前加0 
		else cout<<i<<". Kod"<<k[i].id<<" ("<<k[i].fen<<")"<<endl;
	}
	return 0;
}
```
### END

---

## 作者：nightwatch.ryan (赞：2)

### 思路
首先用两个 map 分别记录每份代码组长给的分数和组员给出的分数。

```cpp
std::map<int,int>leader;
std::map<int,int>crew;
```

对于组员给出的票数，我们用一个 $temp$ 数组记录，给 $temp$ 数组排序，按照题目意思模拟，然后把分映射到 $crew$。

```cpp
 for(int i=1;i<=n;i++){
	std::cin>>vote[i];
	temp[i]=vote[i];
}
std::sort(temp+1,temp+1+n);
for(int i=1;i<=n;i++){
	for(int j=1;j<=n;j++){
		if(temp[j]==vote[i]){
			crew[i]=j;
			break;
		}
	} 
}
```

再建一个结构体，包含组长给出的分数、组员给出的分数、总分和代码编号。

```cpp
struct Node{
	int leader;
	int crew;
	int all;
	int id;
}z[N];
```

将所有信息保存到 $Node$ 类型的 $z$ 数组里。

```cpp
 for(int i=1;i<=n;i++){
	z[i].crew=crew[i];
	z[i].leader=leader[i];
	z[i].all=leader[i]+crew[i];
	z[i].id=i;
}
```

再写一个自定义比较函数（$cmp$），如果这份代码的总分大于另一份代码的总分则不改变顺序。如果这份代码的总分小于另一份代码的总分则改变顺序。总分一样，则比较组员给出的分数。

```cpp
bool cmp(Node a,Node b){
	if(a.all>b.all)return 1;
	if(a.all<b.all)return 0;
	if(a.all==b.all){
		if(a.crew>b.crew)return 1;
		else return 0;
	}
}
```

最后给 $z$ 数组排序一下，然后按照题目意思输出。

### 代码
```cpp
#include<iostream>
#include<map>
#include<algorithm>
#define N 55
std::map<int,int>leader;
std::map<int,int>crew;
int vote[N],temp[N];
struct Node{
	int leader;
	int crew;
	int all;
	int id;
}z[N];
bool cmp(Node a,Node b){
	if(a.all>b.all)return 1;
	if(a.all<b.all)return 0;
	if(a.all==b.all){
		if(a.crew>b.crew)return 1;
		else return 0;
	}
}
int main(){
	int n;std::cin>>n;
	int value=n;
	for(int i=1;i<=n;i++){
		int x;std::cin>>x;
		leader[x]=value;
		value--; 
	}
	for(int i=1;i<=n;i++){
		std::cin>>vote[i];
		temp[i]=vote[i];
	}
	std::sort(temp+1,temp+1+n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(temp[j]==vote[i]){
				crew[i]=j;
				break;
			}
		} 
	}
	for(int i=1;i<=n;i++){
		z[i].crew=crew[i];
		z[i].leader=leader[i];
		z[i].all=leader[i]+crew[i];
		z[i].id=i;
	}
	std::sort(z+1,z+1+n,cmp);
	for(int i=1;i<=n;i++){
		std::cout<<i<<"."<<' ';
		if(z[i].id<10){
			std::cout<<"Kod"<<0<<z[i].id;
		}else if(z[i].id>=10){
			std::cout<<"Kod"<<z[i].id;
		}
		std::cout<<' ';
		std::cout<<"("<<z[i].all<<")";
		std::cout<<'\n';
	}
}
```

---

## 作者：_Jocularly_ (赞：1)

这道题唯一的难点在于用结构体保存每个成员的信息，然后进行排序，用自带的排序函数还需要自定义比较规则。

组长的加分规则可以发现，第一个人加 $n$ 分，之后的人依次减一，那么第 $i$ 个人的加分为 $n-i+1$ 分。最后看其他成员，用另一个结构体数组保存信息，排序后同理每个加分即可。

**注意：** 如果编号小于十，需要加上前导零。每个成员的总分有可能会相等，在结构体中保存其他成员的评分，按照题意，如果分数相同则其他成员评分高的在前。

更多细节请看代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n; 
struct S{//成员结构体 
	int cnt;//总分 
	int id;//编号 
	int other;//其他成员评分 
}a[55],b[55];//保存信息的数组 
int cmp(S a,S b){//自定义排序规则 
	if(a.cnt != b.cnt) return a.cnt > b.cnt;//如果总分不相等，则总分高的在前 
	return a.other > b.other;//否则其他成员得分高的在前 
}
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		a[i].id = i;//赋初始值 
	}
	for(int i=1;i<=n;i++){
		int p;
		cin >> p;
		a[p].cnt = (n - i + 1);//已经证过 
	}
	for(int i=1;i<=n;i++){
		cin >> b[i].cnt;
		b[i].id = i;//赋值 
		a[i].other = b[i].cnt;
	}
	sort(b+1,b+1+n,cmp);//按照规则排序将其他成员评分排序 
	for(int i=1;i<=n;i++){
		int id = b[i].id;//当前人的编号 
		a[id].cnt += (n - i + 1);//同理 
	}
	sort(a+1,a+1+n,cmp);//排序总分 
	for(int i=1;i<=n;i++){
		int id = a[i].id,flag = 0;//id为当前人编号，flag表示是否需要加前导零 
		if(id >= 1 && id <= 9) flag = 1;//如果编号小于十，说明需要添加前导零
		//按照格式输出 
		cout << i << ". Kod";
		if(flag) cout << 0;//如果flag为1，则额外输出前导零 
		cout << id << " (" << a[i].cnt << ")" << endl;
	}
	return 0;
}


```

---

## 作者：foxgirl_ckt1009 (赞：1)

## 题意简述：
本题其实很水，题目要求将 $n$ 份代码进行排序，依次得出排名。

**可是怎么得出排名呢？**

仔细读题不难发现，每一个代码的组长得分计算方式是第 $1$ 名加  $n$ 分，第 $2$ 名加 $n-1$ 分，以此类推，而其他成员得分与此类似，将得分排序后依次加就可以了。

## 思路：
可以定义一个结构体，依次存储每个代码的编号，组长排名，其他成员评分以及总分，之后先针对于组长排名依次加分，随后要以其他成员评分为依据进行从大到小排序，再依次加分，之后输出就可以了。

注意这里有一个坑点，在加组长得分时是对组长给出的排名对应的代码相加，而不是对第 $i$ 份代码加分，但是在加其他成员得分时，由于已经排序，只用对第 $i$ 份代码加分就可以了，但是输出时是输出对应代码的编号。

## AC Code:
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct score{ //结构体
	int a; //组长排名
	int b; //其他成员得分
	int t; //总分
	int id;//编号
}ab[201];
bool cmp1(score aa,score bb){ //按照其他成员得分排序
	return aa.b>bb.b;
}
bool cmp2(score aa,score bb){ //按照总分排序
	if(aa.t!=bb.t)return aa.t>bb.t;
	else return aa.b>bb.b; //总分相等按其他成员得分排序
}
int main(){
	cin>>n;
	int k=n;
	for(int i=1;i<=n;i++){ //初始化id
		ab[i].id=i;
	}
	for(int i=1;i<=n;i++){ //第一次算分
		cin>>ab[i].a;
		ab[ab[i].a].t+=k;
		k--;
	}
	k=n;
	for(int i=1;i<=n;i++){
		cin>>ab[i].b;
	}
	sort(ab+1,ab+n+1,cmp1);//排序
	for(int i=1;i<=n;i++){//第二次算分
		ab[i].t+=k;
		k--;
	}
	sort(ab+1,ab+n+1,cmp2);//排序
	for(int i=1;i<=n;i++){ //输出
		cout<<i<<'.'<<" "<<"Kod";
		if(ab[i].id<=9){ //注意这里，id是一位数时补0
			cout<<"0"<<ab[i].id;
		}
		else{
			cout<<ab[i].id;
		}
		cout<<' '<<'('<<ab[i].t<<')'<<endl;
	}
   return 0;
} //结束
```

---

## 作者：iostream69 (赞：1)

[题目](https://www.luogu.com.cn/problem/P10223)
# 思路
这道题的数据范围很小，所以考虑模拟。

这道题主要的算法是排序和结构体。已知组长给出的是编号（有序），其他成员给出的是票数（无序），所以我们可以通过两次排序+结构体的方式算出每个参赛者的评分。

算出总分后，再排一次序，按照排好的顺序输出即可。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
struct fzjakioi { //
	int x;//编号
	int y;//组长的评分
	int z;//其他人的评分
	int sum;//其他人评分的排名
} a[1001];
bool cmp1(fzjakioi f1, fzjakioi f2) {//第一次排序的函数
	return f1.x < f2.x;//排编号
}
bool cmp2(fzjakioi f1, fzjakioi f2) {//第二次排序的函数
	return f1.z > f2.z;//排其他人的票数
}
bool cmp3(fzjakioi f1, fzjakioi f2) {//第三次排序的函数
	if (f1.y + f1.sum == f2.y + f2.sum) {//如果总分相等
		return f1.z > f2.z;//看其他人的票数
	}//如果不相等
	return f1.y + f1.sum > f2.y + f2.sum;//看总分
}
int n;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {//输入编号
		cin >> a[i].x;
	}
	for (int i = 1; i <= n; i++) {//算出组长的评分
		a[i].y = n - i + 1;
	}
	sort(a + 1, a + n + 1, cmp1);//第一次排序
	for (int i = 1; i <= n; i++) {//输入其他人的票数
		cin >> a[i].z;
	}
	sort(a + 1, a + n + 1, cmp2);第二次排序
	for (int i = 0; i < n; i++) {//算出其他人的评分
		a[i].sum = n - i;
	}
	sort(a + 1, a + n + 1, cmp3);//第三次排序
	for (int i = 1; i <= n; i++) {
		if (a[i].x > 9) {//判断是否需要前导零
			cout << i << ". " << "Kod" << a[i].x << " (" << a[i].y + a[i].sum + 1 << ")" << endl;
		} else
			cout << i << ". " << "Kod0" << a[i].x << " (" << a[i].y + a[i].sum + 1 << ")" << endl;
	}
	return 0;//华丽结尾！
}
```

---

## 作者：tder (赞：0)

很水的排序。

首先定义结构体，具体的：

- $\text{id}_i$ 表示第 $i$ 个人的编号，用于防止中途排序被打乱；
- $\text{leaderorder}_i$ 表示组长给其的排序，$\text{leaderscore}_i$ 表示其组长得分；
- $\text{otherstotal}_i$ 表示组员给其的票数，$\text{othersscore}_i$ 表示其组员得分；
- $\text{score}_i$ 表示总得分。

那么，根据定义，显然有：

- $\text{id}_i=i$；
- $\text{leaderscore}_i=n-\text{leaderorder}_i+1$；
- 令已根据组员给其的票数从大到小排序，即对于任意的 $x\in[1,n)$ 都有 $\text{otherstotal}_x>\text{otherstotal}_{x+1}$，则 $\text{othersscore}_i=n-i+1$；
- $\text{score}_i=\text{leaderscore}_i+\text{othersscore}_i$。

于是排序模拟即可，另外介绍一些比较基础的具体实现：

- `sort` 函数可以附带比较函数 `cmp`，参数为两个同类型的变量 $x,y$，当且仅当排序后 $x$ 应在 $y$ 之前时返回 $1$；
- 三元运算符 `(a ? b : c)`，当且仅当 $a$ 为真时返回 $b$，反之返回 $c$，即为：

```
Get(a, b, c):
    If a:
        Return b
    Else:
        Return c
```

时间复杂度 $O(n\log n)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int n;
struct Node {
    int id, leaderorder, leaderscore, otherstotal, othersscore, score;
} a[N];
bool cmp1(Node x, Node y) {
    return x.otherstotal > y.otherstotal;
}
bool cmp2(Node x, Node y) {
    if(x.score != y.score) return x.score > y.score;
    else return x.othersscore > y.othersscore;
}
signed main() {
    cin>>n;
    for(int i = 1; i <= n; i++) a[i].id = i;
    for(int i = 1; i <= n; i++) {
        int x; cin>>x;
        a[x].leaderorder = i;
    }
    for(int i = 1; i <= n; i++) a[i].leaderscore = n - a[i].leaderorder + 1;
    for(int i = 1; i <= n; i++) cin>>a[i].otherstotal;
    sort(a + 1, a + n + 1, cmp1);
    for(int i = 1; i <= n; i++) a[i].othersscore = n - i + 1;
    for(int i = 1; i <= n; i++) a[i].score = a[i].leaderscore + a[i].othersscore;
    sort(a + 1, a + n + 1, cmp2);
    for(int i = 1; i <= n; i++) cout<<i<<". Kod"<<((a[i].id < 10) ? "0" : "")<<a[i].id<<" ("<<a[i].score<<")"<<endl;
}
```

---

## 作者：JimmyLee (赞：0)

# 解法

模拟题意即可。

---

先按组长评出的顺序赋上得分。

然后将其他成员给出的评分进行排序，然后赋上相应的得分。

这一步可以使用 `pair<int, int>` 进行存储。

最后再按**总得分为第一关键字，成员评分为第二关键字**排序。

这里可以用自定义结构体存储。

按题意输出即可。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

struct st 
{
    int u, v, id;
    st(int U, int V, int ID): u(U), v(V), id(ID) {} 
    bool operator<(st b) const {return u==b.u?v>b.v:u>b.u;}
}; // 用于存储的结构体

vector<st> lis;
vector<pair<int, int> > vc;

int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) lis.emplace_back(0, 0, i);
    for(int i=1, t;i<=n;i++) cin>>t, lis[t-1].u=n+1-i; // 赋上组长给的得分
    for(int i=1, t;i<=n;i++) cin>>t, vc.emplace_back(t, i);
    sort(vc.begin(), vc.end()); // 排序
    int tot=1;
    for(auto [v, id]:vc) 
        lis[id-1].u+=(lis[id-1].v=(tot++)); // 赋上成员给的得分
    sort(lis.begin(), lis.end()); // 输出前的排序
    tot=1;
    for(auto [u, v, id]:lis) 
        cout<<format("{}. Kod{:0>2} ({})\n", tot++, id, u);
    	// c++20 的新格式化函数
}
```

---

## 作者：cenxinyang12 (赞：0)

## [传送门](https://www.luogu.com.cn/problem/P10223)
# 题意&思路
- $a_i$ 表示组长评为第 $i$ 名代码的编号,直接加上分数即可
- $b_i$ 表示第 $i$ 份代码收获的其他成员票数，则需要先排序，再计算分数
- 最终分数再按题意排序，就是答案
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct no{int zz,qt,id;}a[55];//a用来存放分数和序号
struct qtcy{int id,sum;}b[55];//b是其他成员的评分
bool cmpb(qtcy a,qtcy b){return a.sum>b.sum;}
bool cmp(no a,no b){return a.qt+a.zz>b.qt+b.zz||a.qt+a.zz==b.qt+b.zz&&a.qt>b.qt;}
int read(){
	int sum=0,fh=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
	if(ch=='-') fh=-1,ch=getchar();
	while(ch>='0'&&ch<='9') sum=(sum<<3)+(sum<<1)+ch-'0',ch=getchar();
	return sum*fh;
}
int main(){
	n=read();
	for(int i=1;i<=n;++i) a[read()].zz=n-i+1;
	for(int i=1;i<=n;++i) b[i].id=i,b[i].sum=read();
	sort(b+1,b+n+1,cmpb);
	for(int i=1;i<=n;++i) a[b[i].id].qt=n-i+1,a[b[i].id].id=b[i].id;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)
		if(a[i].id>=10) printf("%d. Kod%d (%d)\n",i,a[i].id,a[i].qt+a[i].zz);
		else printf("%d. Kod0%d (%d)\n",i,a[i].id,a[i].qt+a[i].zz);
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

这道题目是一道关于排序和计分的问题。我们需要根据组长的评分和其他成员的投票数来计算每个参赛者的总分，并按照总分降序输出他们的排名和编号。如果两个参赛者的总分相同，那么我们需要按照其他成员的投票数从高到低进行排序。

为了解决这个问题，我们可以先将组长的评分和其他成员的投票数分别存储在两个数组中。然后，我们可以使用一个嵌套循环，依次遍历每个参赛者，计算他们的总分，并将总分以及参赛者的编号存储在一个结构体中。接着，我们可以将这些结构体按照总分降序排序，然后按照题目要求的格式输出结果即可。

代码实现：代码中首先读入参赛者的数目、组长的评分和其他成员的投票数，并将它们分别存储在数组 a、b 中。接下来，我们创建一个 Code 结构体数组 codes，用于存储每个参赛者的编号和总分。然后，我们使用一个嵌套循环，依次遍历每个参赛者，计算他们的总分，并将总分以及参赛者的编号存储在 codes 数组中。接着，我们使用 sort 函数，按照总分降序排序 codes 数组。在排序过程中，如果两个参赛者的总分相同，我们需要按照参赛者的编号从小到大进行排序。最后，我们按照题目要求的格式输出结果即可。

代码不贴，感谢大家的阅读，撒花！

---

## 作者：maoyuqi (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10223)


### 解题思路
本题不难，按照题意模拟即可，不过有些细节要注意，例如“如果两份代码得分相同，**其他成员评分高者**列前”。

~~我才不会告诉你因为这个调五分钟~~

用一个结构体记录代码的编号、其他成员评分和总分。然后根据题意用手写的 cmp 和 STL 中的 sort 排序，最后注意输出格式。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 300;
struct s{
	int id,cnt,qt;
}score[N];//id存编号，cnt存总分，qt存其他成员的评分
int n;
int a[N],b[N];//为了直观开题意中的两个数组，也可以不开
bool cmp1(s a,s b)//在第一遍输入后按编号排序
{
	return a.id<b.id;
}
bool cmp2(s a,s b)//票数高的在前面
{
	return a.qt>b.qt;
}
bool cmp3(s a,s b)//输出时如果两份代码得分相同，成员评分高者列前，否则按分数降序排列
{
	if(a.cnt!=b.cnt) return a.cnt>b.cnt;
	else return a.qt>b.qt;
}
int main()
{
	cin>>n;
	for(int i = 1;i<=n;i++) cin>>a[i];
	for(int i = 1;i<=n;i++) cin>>b[i];//读入
	for(int i = 1;i<=n;i++)//i为排名
	{
		score[i].id = a[i];
		score[i].cnt+=n-i+1;
	}
	sort(score+1,score+n+1,cmp1);
	for(int i = 1;i<=n;i++)//此时排序后i为编号
	{
		score[i].qt = b[i];
	}
	sort(score+1,score+n+1,cmp2);
	for(int i = 1;i<=n;i++)//加上其他成员投票的分数
	{
		score[i].cnt+=n-i+1;
	}
	sort(score+1,score+n+1,cmp3);
	for(int i = 1;i<=n;i++)//按题意输出
	{
		if(score[i].id<10) printf("%d. Kod0%d (%d)\n",i,score[i].id,score[i].cnt);
		else printf("%d. Kod%d (%d)\n",i,score[i].id,score[i].cnt);
	}
	return 1;//理解后请自己编写一遍
}
```

---

## 作者：__Sky__Dream__ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P10223)

## 解题思路
**排序模拟。**

由题意可得：

- 第 $i$ 个整数表示组长评为第 $i$ 名代码的**编号**。
- 第 $i$ 个整数表示第 $i$ 份代码收获的其他成员**票数**。

注意，票数与评分不一样，选手获得的其他成员的评分是通过票数间接计算得到的。

那么首先，我们先把组长评的名次按从小到大排序起来，则组长评分就是其编号加上 $n-i+1$。

其次将其他成员的票数按从大到小排号，则其他成员评分就是其编号加上 $n-i+1$。

最后排好总分即可。注意输出时，要判断是否大于 $10$，若小于 $10$ 要加前导 $0$，可用以下代码实现：
```cpp
if(a[i].zp>=10)//前导0特殊处理 
			cout<<a[i].zp<<" ("<<a[i].qp1+a[i].zp1<<")"<<"\n";
else 
			cout<<0<<a[i].zp<<" ("<<a[i].qp1+a[i].zp1<<")"<<"\n";
```

## AC Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
struct data
{
	ll zp,qp,zp1,qp1;
}a[10001];
bool bo1(data x,data y)
{
	return x.zp<y.zp;//组长评分从小到大 
}
bool bo2(data x,data y)
{
	return x.qp>y.qp;//其他成员票数从大到小 
}
bool bo3(data x,data y)//若相同则由其他成员决定 
{
	if(x.zp1+x.qp1==y.zp1+y.qp1)
		return x.qp>y.qp;
	return x.zp1+x.qp1>y.zp1+y.qp1;
}
int main()
{
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)//第一次排序，组长评分 
		cin>>a[i].zp;
	for(int i=1;i<=n;i++)
		a[i].zp1=n-i+1;
	sort(a+1,a+n+1,bo1);
	for(int i=1;i<=n;i++)//第二次排序，其他成员票数 
		cin>>a[i].qp;
	sort(a+1,a+n+1,bo2);
	for(int i=1;i<=n;i++)//第三次排序，其他成员评分 
		a[i].qp1=n-i+1;
	sort(a+1,a+n+1,bo3);
	for(int i=1;i<=n;i++)
	{
		cout<<i<<". Kod";
		if(a[i].zp>=10)//前导0特殊处理 
			cout<<a[i].zp<<" ("<<a[i].qp1+a[i].zp1<<")"<<"\n";
		else 
			cout<<0<<a[i].zp<<" ("<<a[i].qp1+a[i].zp1<<")"<<"\n";
	} 
	return 0;
}
```

[我的AC记录](https://www.luogu.com.cn/record/149928895)

欢迎大家在评论区留言！

---

## 作者：gloomy_ (赞：0)

### 0x01 思路整理  
本题核心就是结构体排序。
总分由两部分组成。其中组长分数是将编号排序转化为对应分数，成员评分是由每个人的分数排序后转化为对应分数。  
### 0x02 算法实现  
#### 结构体定义  
```cpp
struct person
{
	int id;//编号
	int captain;//组长评分所得分数
	int other;//输入时存储票数，排序后改为存储对应分数
	int tot;//总分
};
```
#### 输入
注意一定要在最开始存储编号，不然最后就找不到了。  
```cpp
scanf("%d",&n);
for(int i=1;i<=n;i++)
{
	scanf("%d",&t);
	deta[t].id=t;
	deta[t].captain=n-i+1;
}
for(int i=1;i<=n;i++)
{
	scanf("%d",&t);
	deta[i].other=t;//暂时存票数
} 
```
#### 成员票数转化为分数  
结构体排序一般都使用 sort 排序。cmp 函数如下。
```cpp
bool cmp1(person x,person y)
{
	return x.other>y.other;
}
```
从第一名到最后一名，分数依次从 $n$ 递减到 $1$，再算总分。
```cpp
sort(deta+1,deta+n+1,cmp1);
for(int i=1;i<=n;i++)
{
	deta[i].other=n-i+1;//改为存分数
	deta[i].tot=deta[i].captain+deta[i].other;
}
```
#### 总分排序并输出  
根据题干描述的 `如果两份代码得分相同，其他成员评分高者列前`，我们写出以下函数。  
```cpp
bool cmp2(person x,person y)
{
	if(x.tot!=y.tot)
		return x.tot>y.tot;
	return x.other>y.other;
}
```  
输出时注意前导零。  
```cpp
sort(deta+1,deta+n+1,cmp2);
for(int i=1;i<=n;i++)
{
	printf("%d. Kod",i);
	if(deta[i].id<10)
		printf("0");
	printf("%d",deta[i].id);
	printf(" (%d)\n",deta[i].tot);
}
```
### 0x03 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct person
{
	int id;
	int captain;
	int other;
	int tot;
};
bool cmp1(person x,person y)
{
	return x.other>y.other;
}
bool cmp2(person x,person y)
{
	if(x.tot!=y.tot)
		return x.tot>y.tot;
	return x.other>y.other;
}
int n,t;
person deta[55];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t);
		deta[t].id=t;
		deta[t].captain=n-i+1;
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t);
		deta[i].other=t;
	} 
	sort(deta+1,deta+n+1,cmp1);
	for(int i=1;i<=n;i++)
	{
		deta[i].other=n-i+1;
		deta[i].tot=deta[i].captain+deta[i].other;
	}
	sort(deta+1,deta+n+1,cmp2);
	for(int i=1;i<=n;i++)
	{
		printf("%d. Kod",i);
		if(deta[i].id<10)
			printf("0");
		printf("%d",deta[i].id);
		printf(" (%d)\n",deta[i].tot);
	}
	return 0;
} 
```

---

## 作者：Jasoncwx (赞：0)

[题目传送门！](/problem/P10223)
## 题目思路
这道题目可以用结构体来做。我在这道题中使用了两个结构体，一个是负责将最后输出的数据进行排序，另一个是对 $b$ 数组进行排序。

因为 $b$ 数组中的得票数是乱序的，所以我们先将它从大到小排好序，这样我们就能知道得票数最多的是哪一位选手，对应的第 $i$ 位选手得到的分数应该是 $n-i+1$ 分。

而 $a$ 数组我们可以直接操作，只需要把第 $a_i$ 位选手的分数加上 $n-i+1$ 即可。

最后，根据各个选手的分数从大到小排序，输出即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu{
    int id,score,bbb;
}t[205];
struct bb{
    int id,score;
}b[205];
bool cmp(bb a,bb b){
    return a.score>b.score;
}
bool cmp1(stu a,stu b){
	if(a.score!=b.score)return a.score>b.score;
	else return a.bbb>b.bbb;
}
int main(){
    int n;
    cin>>n;
    int a[205];
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i].score,b[i].id=i;
    sort(b+1,b+n+1,cmp);//将得票数从大到小排序
    for(int i=1;i<=n;i++){
        t[i].id=i,t[a[i]].score=n-i+1;//计算组长评分
    }
   for(int i=1;i<=n;i++)t[b[i].id].score+=n-i+1,t[b[i].id].bbb=n-i+1;//计算其他成员评分
	sort(t+1,t+n+1,cmp1);//把所有选手的得分从大到小排序
	for(int i=1;i<=n;i++){
		cout<<i<<". Kod"<<t[i].id/10<<t[i].id%10<<" ("<<t[i].score<<")\n";
	}
}


```

---

## 作者：LostKeyToReach (赞：0)

这道题难度不大，模拟一下即可。

我们先定义两个结构体，分别代表选手和其他成员。

```cpp
struct Human { // 选手
	int scoreX, scoreP, num; // scoreX 代表组长评分，scoreP 代表其他成员评分，num 代表选手编号
} H[54];
struct P { // 其他成员
	int num, sc; //num 代表评委投给第几号选手，sc 代表票数
} p[54];
```

比较函数也很简单，按题意模拟即可。

```cpp
bool cmpHuman(Human a, Human b) { // 选手排序函数
	if (a.scoreX + a.scoreP != b.scoreX + b.scoreP) { // 如果总分不同，从大到小排
		return a.scoreX + a.scoreP > b.scoreX + b.scoreP;
	}
	return a.scoreP > b.scoreP; // 否则比较其他成员票数
}
bool cmpP(P a, P b) { // 其他成员排序函数
	return a.sc > b.sc; // 票数大的优先
}
```

做完准备之后，我们输入 $a_i$ 并预处理组长给的分数，再读入 $b_i$ 记录其他成员的票数，排一下序处理选手的其他成员分数，最后再排一次序，输出即可。

主体代码如下：

```cpp
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int a;
		cin >> a;
		H[a].scoreX = n - i + 1;
		H[i].num = i;
	}
	for (int i = 1; i <= n; i++) {
		cin >> p[i].sc, p[i].num = i;
	}
	sort(p + 1, p + n + 1, cmpP);
	for (int i = 1; i <= n; i++) {
		H[p[i].num].scoreP = n - i + 1;
	}
	sort(H + 1, H + n + 1, cmpHuman);
	for (int i = 1; i <= n; i++) {
		cout << i << ". Kod" << (H[i].num <= 9 ? "0" : "") << H[i].num << " (" << H[i].scoreP + H[i].scoreX << ")\n";
	}
	return 0;
}
```

---


# [COCI 2023/2024 #4] Bingo

## 题目背景

**译自 [COCI 2023/2024 Contest #4](https://hsin.hr/coci/archive/2023_2024) T1「[Bingo](https://hsin.hr/coci/archive/2023_2024/contest4_tasks.pdf)」**

## 题目描述

现在是游玩 Bingo 的时间！

想要玩 Bingo 游戏，你需要一名游戏主持人和一个装有 90 个球的滚轮。滚轮中的球被编号为 $1\sim 90$，每个数字编号写在恰好一个球上。

在游戏开始前，主持人向 $n$ 名玩家每人发放一块 $5\times 5$ 的格板，每格包含一个 $1$ 到 $90$ 范围内的整数。一块格板上的数字互不相同，每名玩家的格板互不相同。

所有的玩家都拿到格板后，游戏开始。

主持人开始从滚轮中取出球。取出编号为 $x_i$ 的球后，主持人向所有玩家宣布编号，并将球放到一边。所有玩家会检查自己的格板，如果格板上有取出的球的编号，他们会将这个数从格板上划去。

当一名玩家划去了行、列、主对角线或从对角线上全部的 5 个数字，这名玩家将喊出 `Bingo!`。此时，游戏结束，这名玩家赢得游戏。

为了让游戏更加有趣，主持人决定引入一条额外规则。在任何人被允许喊出 `Bingo!` 前，主持人将先取出 $m$ 个球。（即使玩家已经划去了连续的 5 个数，也必须等到 $m$ 个球取出后才能喊出 `Bingo!`）

但是，当主持人取出第 $m$ 个球的瞬间，场上发生了一阵骚动！所有的玩家都喊出了 `Bingo!`。

主持人不知道该相信谁。为了解决这个状况，他向你寻求帮助。请计算出 $m$ 个球被取出后，有多少玩家可以喊出 `Bingo!`。

## 说明/提示

### 样例解释 1

`babylasagna` 在第一行实现了 `Bingo!`。

`nataliebalmix` 在第一列实现了 `Bingo!`。

`lettri` 在左下角到右上角的从对角线实现了 `Bingo!`。

### 样例解释 2

只取出了 4 个球，没有人能划去 5 个数。

### 子任务

| Subtask | Points | Constraints |
| :--: | :--: | :--: |
| 1 | 12 | 只有一个玩家，也就是说，$n=1$ |
| 2 | 22 | 最多只有一个玩家喊出 `Bingo!` |
| 3 | 16 | 无额外限制 |

## 样例 #1

### 输入

```
3
babylasagna
10 11 12 13 14
15 16 17 18 19
20 21 22 23 24
25 26 27 28 29
30 31 32 33 34
nataliebalmix
10 20 30 40 50
11 21 31 41 51
12 22 32 42 52
13 23 33 43 53
14 24 34 44 54
lettri
89 88 87 86 10
85 84 83 11 82
81 80 12 79 78
77 13 76 75 74
14 73 72 71 70
6
10 11 12 13 14 15```

### 输出

```
3
babylasagna
nataliebalmix
lettri```

## 样例 #2

### 输入

```
1
honi
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
4
1 2 49 50```

### 输出

```
0```

## 样例 #3

### 输入

```
4
rim
15 23 14 26 34
12 11 13 16 17
90 67 45 24 18
85 82 77 66 22
62 71 32 35 7
tim
61 89 25 63 12
29 30 31 32 33
11 17 42 24 18
88 82 77 66 22
44 71 54 35 7
dagi
15 23 14 26 34
12 11 13 16 17
90 67 45 24 18
85 82 77 66 22
62 71 36 35 7
dim
15 23 14 26 34
12 11 13 16 17
90 67 45 24 18
85 82 77 66 22
42 51 32 33 7
7
15 11 66 7 42 30 61```

### 输出

```
1
tim```

# 题解

## 作者：zhuxiangrui_2010 (赞：6)

# P10228 [COCI 2023/2024 #4] Bingo 题解

## 题意
有 $n$ 名玩家，每名玩家都有一个 $5×5$ 的格板，每格包含一个整数。主持人从滚轮中取出球。取出编号为 $x_i$ 的球后，如果格板上有取出的球的编号，将这个数从格板上划去。统计取出第 $m$ 个球后划去了**行、列、主对角线或从对角线**上全部的 $5$ 个数字的玩家个数及他们的名字。
## 思路
因为格板较小，考虑大模拟，输入完成后挨个判断 $5$ 行，$5$ 列以及 $2$ 条对角线全部划去的玩家。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t=0;
bool f[60]={};
struct Bingo{
	string s;
	int a[6][6];
}q[60];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>q[i].s;
		for(int j=1;j<=5;j++){
			for(int k=1;k<=5;k++){
				cin>>q[i].a[j][k];
			}
		}
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		for(int j=1;j<=n;j++){
			for(int k=1;k<=5;k++){
				for(int l=1;l<=5;l++){
					if(x==q[j].a[k][l]){
						q[j].a[k][l]=-1;
					}
				}
			}
		}
	}
	for(int j=1;j<=n;j++){
		/*if(q[j].a[1][1]==-1&&q[j].a[1][2]==-1&&q[j].a[1][3]==-1&&q[j].a[1][4]==-1&&q[j].a[1][5]==-1){t++;f[j]=true;}
		else if(q[j].a[2][1]==-1&&q[j].a[2][2]==-1&&q[j].a[2][3]==-1&&q[j].a[2][4]==-1&&q[j].a[2][5]==-1){t++;f[j]=true;}
		else if(q[j].a[3][1]==-1&&q[j].a[3][2]==-1&&q[j].a[3][3]==-1&&q[j].a[3][4]==-1&&q[j].a[3][5]==-1){t++;f[j]=true;}
		else if(q[j].a[4][1]==-1&&q[j].a[4][2]==-1&&q[j].a[4][3]==-1&&q[j].a[4][4]==-1&&q[j].a[4][5]==-1){t++;f[j]=true;}
		else if(q[j].a[5][1]==-1&&q[j].a[5][2]==-1&&q[j].a[5][3]==-1&&q[j].a[5][4]==-1&&q[j].a[5][5]==-1){t++;f[j]=true;}
		else if(q[j].a[1][1]==-1&&q[j].a[2][1]==-1&&q[j].a[3][1]==-1&&q[j].a[4][1]==-1&&q[j].a[5][1]==-1){t++;f[j]=true;}
		else if(q[j].a[1][2]==-1&&q[j].a[2][2]==-1&&q[j].a[3][2]==-1&&q[j].a[4][2]==-1&&q[j].a[5][2]==-1){t++;f[j]=true;}
		else if(q[j].a[1][3]==-1&&q[j].a[2][3]==-1&&q[j].a[3][3]==-1&&q[j].a[4][3]==-1&&q[j].a[5][3]==-1){t++;f[j]=true;}
		else if(q[j].a[1][4]==-1&&q[j].a[2][4]==-1&&q[j].a[3][4]==-1&&q[j].a[4][4]==-1&&q[j].a[5][4]==-1){t++;f[j]=true;}
		else if(q[j].a[1][5]==-1&&q[j].a[2][5]==-1&&q[j].a[3][5]==-1&&q[j].a[4][5]==-1&&q[j].a[5][5]==-1){t++;f[j]=true;}
		else if(q[j].a[1][1]==-1&&q[j].a[2][2]==-1&&q[j].a[3][3]==-1&&q[j].a[4][4]==-1&&q[j].a[5][5]==-1){t++;f[j]=true;}
		else if(q[j].a[1][5]==-1&&q[j].a[2][4]==-1&&q[j].a[3][3]==-1&&q[j].a[4][2]==-1&&q[j].a[5][1]==-1){t++;f[j]=true;}十二组判断*/
	}
	cout<<t<<endl;
	for(int i=1;i<=n;i++){
		if(f[i]){
			for(int j=0;j<=q[i].s.size()-1;j++){
				cout<<q[i].s[j];
			}
			cout<<endl;
		}
	}
    return 0;
}
```

---

## 作者：Hy13_xsm (赞：3)

## 题目分析

有 $n$ 个人玩 Bingo 游戏，每个人有 $5\times 5$ 的格板，主持人有 $m$ 个数字，如果主持人的数字在玩家的格板上能够连成横、竖、对角线，那么玩家就能喊出 `Bingo!`。问有多少人能喊出 `Bingo!`。

## 题目解决

这其实是一道模拟题，直接记录格板上有没有主持人的数字，看看能不能连成横、竖、对角线，打暴力也是能过的。我们可以用一个二维布尔数组 $p$ 记录玩家格板是否有主持人的数字的情况，如果 $i$ 行 $j$ 列的格子上有主持人的数字，那么就改变 $p[i][j]=0$。最后再比对 $p$ 数组中有没有 $1$ 可以连成横、竖、对角线即可。

这样，一个模拟就出来了，由于数据量小，可以直接打暴力。因为要先存储每个玩家的信息，所以存储格板应该用三维数组。最后还需要注意的是，如果你想用的 $p$ 数组是二维的，每次使用完要将它清零，也就是使用 `memset()` 函数。总的来说，这是一道适合新手练码力的题。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt, n, m, a[55] [10] [10], b[100];
string s[1000005];
bool p[100] [100], flag[1000005];
int main()
{
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> s[i];
		for(int j = 1;j <= 5;j++)
		{
			for(int k = 1;k <= 5;k++)
			cin >> a[i] [j] [k];
		}
	}//提前存入数据 
	cin >> m;
	for(int i = 1;i <= m;i++)
	cin >> b[i];
	for(int k = 1;k <= n;k++)
	{
		memset(p ,0 ,sizeof(p));
		for(int i = 1;i <= 5;i++)
		{
			for(int j = 1;j <= 5;j++)
			{
				for(int l = 1;l <=m ;l++)
				{
					if(a[k] [i] [j] == b[l])                                      
					p[i] [j] = 1;
				}                         
			}
		}
		for(int i = 1;i <= 5;i++)
		{
			if(p[i] [1] == 1 && p[i] [2] == 1 && p[i] [3] == 1 && p[i] [4] == 1 && p[i] [5] == 1) flag[k] = 1; //判断行 
			else if(p[1] [i] == 1 && p[2] [i] == 1 && p[3] [i] == 1 && p[4] [i] == 1 && p[5] [i] == 1) flag[k] = 1; //判断列 
		}
		if(p[1] [1] == 1 && p[2] [2] == 1 && p[3] [3] == 1 && p[4] [4] == 1 && p[5] [5] == 1) flag[k] = 1; //判断左上到右下 
		else if(p[5] [1] == 1 && p[4] [2] == 1 && p[3] [3] == 1 && p[2] [4] == 1 && p[1] [5] == 1) flag[k] = 1; //判断左下到右上 
	}
	for(int i = 1;i <= n;i++)
	if(flag[i]) cnt++;
	cout << cnt << endl;
	for(int i = 1;i <= n;i ++)
	if(flag[i]) cout << s[i] << endl;
	return 0;
	//建议不要复制 
}
```

**代码主要起学习作用，请大家不要抄，请大家共创洛谷良好的学习风气！**

---

## 作者：_Jocularly_ (赞：2)

属于一道模拟。我使用结构体来存每一个人的信息，一开始的输入就不用说了，我们直接来看怎么判断是否胜利。

题目中的删数直接枚举即可，以下把被删掉的数变为负一。首先看怎么判断行，枚举行和列，在这一行的每一列元素，判断是否是负一，如果这一行全都是，则返回一，否则寻找下一行。直到循环结束没有返回一，说明没有符合条件的，返回零。

判断列的方式和行类似，只要把行和列反过来就可以了，重要的是对角线。还是利用以上的思想，枚举后判断，主要是怎么枚举对角线的位置，把第 $i$ 行第 $j$ 列的元素定义为 $a_{i,j}$ 的情况下，假设当前是第 $i$ 行，通过找规律，发现这一行的主对角线就在 $a_{i,5-i+1}$ 的位置，同理从对角线在 $a_{i,i}$ 的位置。

最后只要按照顺序枚举每一个角色，判断当前角色和行、列、对角线是否赢了，赢了就累加答案，最后再枚举一次，输出人名即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct P{
	int b[10][10];
	string name;
}a[55];
int n,m;
int c[100];
int ans;
int hang(int i){
	for(int j=1;j<=5;j++){//第j行 
		int flag = 1;
		for(int k=1;k<=5;k++){//第k列 
			if(a[i].b[k][j] != -1){
				flag = 0;
			}
		}
		if(flag) return 1;
	}
	return 0;
}
int lie(int i){
	for(int j=1;j<=5;j++){
		int flag = 1;
		for(int k=1;k<=5;k++){
			if(a[i].b[j][k] != -1){
				flag = 0;
			}
		}
		if(flag) return 1;
	}
	return 0;
}
int duijiao(int i){
	int flag1 = 1;
	for(int j=1;j<=5;j++){
		if(a[i].b[j][j] != -1) flag1 = 0;
	}
	if(flag1) return 1;
	int flag2 = 1;
	for(int j=1;j<=5;j++){
		if(a[i].b[j][5-j+1] != -1){
			flag2 = 0;
			//cout << i << " " <<  j << " " << 5-j+1 << " " << n << endl;
		}
	}
	if(flag2) return 1;
	return 0;
}
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		string name;
		cin >> name;
		a[i].name = name;
		for(int j=1;j<=5;j++){
			for(int k=1;k<=5;k++){
				int t;
				cin >> t;
				a[i].b[j][k] = t;
			} 
		}
	}
	cin >> m;
	for(int i=1;i<=m;i++){
		cin >> c[i];
		for(int j=1;j<=n;j++){
			for(int x=1;x<=5;x++){
				for(int y=1;y<=5;y++){
					if(a[j].b[x][y] == c[i]){
						a[j].b[x][y] = -1;
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(hang(i)||lie(i)||duijiao(i)) ans ++;
	}
	cout << ans << endl;
	for(int i=1;i<=n;i++){
		if(hang(i)||lie(i)||duijiao(i)) cout << a[i].name << endl;
	}
	return 0;
}

```

---

## 作者：danb123 (赞：1)

## 题目大意
就是几个五乘五的矩阵，给出了一组数字。如果矩阵中有这个数字，让你把其中这个数字取出来。如果空白处能连成五连，行或列或对角线全部为空白就输出这个人的名字。
## 题目分析
这道题目很好分析，就是模拟。当然可以把这些数据记录坐标，查找数据会快一点。

具体步骤如下：

1. 输入。
1. 查找数据并标记。
1. 判断是否连成五连。
1. 输出。

第三步是最为重要的，首先先判断行是否能连成五连，然后再判断列，最后判断对角。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[101][6][6],n,m,b,cnt,ans;
struct data{
	int x,y,flag;
}mp[101][101];
string name[10001];
bool bl(int x){
	bool ff=0;
	for(int i=1;i<=5;i++){
		ff=1;
		for(int j=1;j<=5;j++) if(a[x][i][j]!=-1) {ff=0;break;}
		if(ff) return 1;
	}
	for(int j=1;j<=5;j++){
		ff=1;
		for(int i=1;i<=5;i++) if(a[x][i][j]!=-1) {ff=0;break;}
		if(ff) return 1;
	}
	if(a[x][1][1]==-1&&a[x][2][2]==-1&&a[x][3][3]==-1&&a[x][4][4]==-1&&a[x][5][5]==-1) return 1;
	if(a[x][1][5]==-1&&a[x][2][4]==-1&&a[x][3][3]==-1&&a[x][4][2]==-1&&a[x][5][1]==-1) return 1;
	return 0;
}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>name[i];
		for(int j=1;j<=5;j++)
			for(int l=1;l<=5;l++){
				cin>>a[i][j][l];
				mp[i][a[i][j][l]].flag=1,mp[i][a[i][j][l]].x=j,mp[i][a[i][j][l]].y=l;
			}
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>b;
		for(int j=1;j<=n;j++)if(mp[j][b].flag)a[j][mp[j][b].x][mp[j][b].y]=-1;
	}
	for(int i=1;i<=n;i++)if(bl(i))cnt++;
	cout<<cnt<<endl;
	for(int i=1;i<=n;i++)if(bl(i))cout<<name[i]<<endl;
	return 0;
}
```

---

## 作者：sz2107wx (赞：1)

## 题解
### 题目链接
[P10228 [COCI 2023/2024 #4] Bingo](https://www.luogu.com.cn/problem/P10228)
### 思路
	这道题主要考察三维数组，数据范围不大，可以直接用多重循环解决。
    我们将这一道题分为三步
    1. 输入和标记
   ```cpp
	cin>>n;//输入 
	for(int k=1;k<=n;k++){
		cin>>s[k];
		for(int i=1;i<=5;i++){
			for(int j=1;j<=5;j++){
				cin>>a[k][i][j]; 
			}
		}
	}
	cin>>m;
	for(int l=1;l<=m;l++){
		cin>>b[l];
		for(int k=1;k<=n;k++){
			for(int i=1;i<=5;i++){
				for(int j=1;j<=5;j++){
					if(a[k][i][j]==b[l]) a[k][i][j]=-1;//标记 
				}
			}
		}
	}
```

    2. 判断每个玩家是否划去了某一行，列，对角线中的所有数字
   ```cpp
int f(int x){//判断每个玩家的行、列、对角线每条线中的数字是否全部被划掉
	for(int i=1;i<=5;i++){
		if(a[x][i][1]==-1&&a[x][i][2]==-1&&a[x][i][3]==-1&&a[x][i][4]==-1&&a[x][i][5]==-1) return true;
	}
	for(int i=1;i<=5;i++){
		if(a[x][1][i]==-1&&a[x][2][i]==-1&&a[x][3][i]==-1&&a[x][4][i]==-1&&a[x][5][i]==-1) return true;
	}
	if(a[x][1][1]==-1&&a[x][2][2]==-1&&a[x][3][3]==-1&&a[x][4][4]==-1&&a[x][5][5]==-1) return true;
	if(a[x][1][5]==-1&&a[x][2][4]==-1&&a[x][3][3]==-1&&a[x][4][2]==-1&&a[x][5][1]==-1) return true;
	return false;
}
```

    3. 输出
   ```cpp
cout<<sum<<endl;//输出 
	for(int i=1;i<=sum;i++){
		cout<<s1[i]<<endl;
	}
```


	我们发现，当表示主持人将取出的球的数目小于5个时，没有玩家可以划去所有数字,所以可以加一条判定
   ```cpp
if(m<5){//如果取出的数字小于5个，则无人能够划去一行或一列或对角线 
		cout<<"0"<<endl;
		return 0;
	}
```
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//玩家人数 
string s[51];//名字 
int a[51][6][6]; //每个人的矩阵 
int sum;//能喊Bingo!人数
string s1[51];//储存能喊Bingo!人名字 
int m;//取出球的个数 
int b[91];//取出的球
int f(int x){//判断每个玩家的行、列、对角线每条线中的数字是否全部被划掉
	for(int i=1;i<=5;i++){
		if(a[x][i][1]==-1&&a[x][i][2]==-1&&a[x][i][3]==-1&&a[x][i][4]==-1&&a[x][i][5]==-1) return true;
	}
	for(int i=1;i<=5;i++){
		if(a[x][1][i]==-1&&a[x][2][i]==-1&&a[x][3][i]==-1&&a[x][4][i]==-1&&a[x][5][i]==-1) return true;
	}
	if(a[x][1][1]==-1&&a[x][2][2]==-1&&a[x][3][3]==-1&&a[x][4][4]==-1&&a[x][5][5]==-1) return true;
	if(a[x][1][5]==-1&&a[x][2][4]==-1&&a[x][3][3]==-1&&a[x][4][2]==-1&&a[x][5][1]==-1) return true;
	return false;
}
int main(){
	cin>>n;//输入 
	for(int k=1;k<=n;k++){
		cin>>s[k];
		for(int i=1;i<=5;i++){
			for(int j=1;j<=5;j++){
				cin>>a[k][i][j]; 
			}
		}
	}
	cin>>m;
	for(int l=1;l<=m;l++){
		cin>>b[l];
		for(int k=1;k<=n;k++){
			for(int i=1;i<=5;i++){
				for(int j=1;j<=5;j++){
					if(a[k][i][j]==b[l]) a[k][i][j]=-1;//标记 
				}
			}
		}
	}
	if(m<5){//如果取出的数字小于5个，则无人能够划去一行或一列或对角线 
		cout<<"0"<<endl;
		return 0;
	}
	for(int k=1;k<=n;k++){
		if(f(k)==true){//判断 
			sum++;
			s1[sum]=s[k];
		} 
	}
	cout<<sum<<endl;//输出 
	for(int i=1;i<=sum;i++){
		cout<<s1[i]<<endl;
	}
	return 0;
}//完美结束~ 
```

---

## 作者：maomao233 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10228)

简单的题目，考察三维数组的运用。

首先我们按照题意输入。其次，对于每一个主持人从滚轮中取出的球的编号，我们直接 $\mathcal{O}(25n)$ 判断每位玩家格板上的数，如果有与主持人从滚轮中取出的球的编号相等的数，则将其赋值为 $0$（看个人喜好，这里的作用是区分该数是否被划去。当然你也可以另建一个数组）。

在 $m$ 个球被取出后，我们对于每行、每列和两个对角线直接 $\mathcal{O}(25n)$ 判断每位玩家格板上是否形成 `Bingo!` 的局面。如果是，则答案加一，并将该玩家的姓名记录。最后按要求输出即可。代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
#define lb(x) x&-x
#define itn int
inline string its(int x){stringstream ss;string s;ss<<x;ss>>s;return s;}
inline int sti(string s){stringstream ss;int x;ss<<s;ss>>x;return x;}
inline string jia(string a1,string b1){int a[10010],b[10010],c[10010];int lena=a1.size(),lenb=b1.size();for(int i=0;i<lena;i++){a[i]=a1[lena-1-i]-'0';}for(int i=0;i<lenb;i++){b[i]=b1[lenb-1-i]-'0';}int lenc=max(lena,lenb),t=0;for(int i=0;i<lenc;i++){c[i]=a[i]+b[i]+t;if(c[i]>=10){t=1,c[i]%=10;}else{t=0;}}if(t==1){lenc++;c[lenc-1]=1;}string s;for(int i=lenc-1;i>=0;i--){s+=c[i]+'0';}return s;}
inline string jian(string a1,string b1){if(a1.size()<b1.size()||a1.size()==b1.size()&&a1<b1){pc('-'),swap(a1,b1);}int a[10010],b[10010],c[10010];int lena=a1.size(),lenb=b1.size();for(int i=0;i<lena;i++){a[i]=a1[lena-1-i]-'0';}for(int i=0;i<lenb;i++){b[i]=b1[lenb-1-i]-'0';}int lenc=lena;for(int i=0;i<lenc;i++){if(a[i]<b[i]){a[i+1]--,a[i]+=10;}c[i]=a[i]-b[i];}while(lenc>=1&&c[lenc-1]==0){lenc--;}string s;for(int i=lenc-1;i>=0;i--){s+=c[i]+'0';}return s;}
inline int qpow(int a,int b,int p){int sum=1;while(b){if(b&1){sum=(sum*a)%p;}b>>=1;a=(a*a)%p;}return sum;}
inline int qp(int a,int b){int sum=1;while(b){if(b&1){sum*=a;}b>>=1;a*=a;}return sum;}
string s[60];
int a[60][10][10];
string b[60];
signed main()
{
	int n;
	rd(n);
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];
		for(int j=1;j<=5;j++)
		{
			for(int k=1;k<=5;k++)
			{
				rd(a[i][j][k]);
			}
		}
	}
	int m;
	rd(m);
	for(int qwq=1;qwq<=m;qwq++)
	{
		int x;
		rd(x);
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=5;j++)
			{
				for(int k=1;k<=5;k++)
				{
					if(a[i][j][k]==x)
					{
						a[i][j][k]=0;
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		int flag=0;
		for(int j=1;j<=5;j++)
		{
			int f=0;
			for(int k=1;k<=5;k++)
			{
				if(a[i][j][k])
				{
					f=1;
					break;
				}
			}
			if(!f)
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			b[++ans]=s[i];
		}
		else
		{
			for(int j=1;j<=5;j++)
			{
				int f=0;
				for(int k=1;k<=5;k++)
				{
					if(a[i][k][j])
					{
						f=1;
						break;
					}
				}
				if(!f)
				{
					flag=1;
					break;
				}
			}
			if(flag||!a[i][1][1]&&!a[i][2][2]&&!a[i][3][3]&&!a[i][4][4]&&!a[i][5][5]||!a[i][1][5]&&!a[i][2][4]&&!a[i][3][3]&&!a[i][4][2]&&!a[i][5][1])
			{
				b[++ans]=s[i];
			}
		}
	}
	wtl(ans);
	for(int i=1;i<=ans;i++)
	{
		cout<<b[i]<<endl;
	}
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：1)

### 思路

本题是一道简单的模拟，只需要计算每个玩家的行、列、对角线每条线中的数字是否全部被划掉。如果一条线上的所有数字都被划掉，那么将这个玩家算进答案。

### 代码

```cpp
#include<iostream>
using namespace std;
int n,m,a[51][26],b[100],bo[51][26],ans;
string s[51];
bool isbingo(int k,int q,int w,int e,int r,int t){
	if(bo[k][q]==0)return 0;
	if(bo[k][w]==0)return 0;
	if(bo[k][e]==0)return 0;
	if(bo[k][r]==0)return 0;
	if(bo[k][t]==0)return 0;
	return 1;
}
bool check(int k){
	if(isbingo(k,1,2,3,4,5))return 1;
	if(isbingo(k,6,7,8,9,10))return 1;
	if(isbingo(k,11,12,13,14,15))return 1;
	if(isbingo(k,16,17,18,19,20))return 1;
	if(isbingo(k,21,22,23,24,25))return 1;
	if(isbingo(k,1,6,11,16,21))return 1;
	if(isbingo(k,2,7,12,17,22))return 1;
	if(isbingo(k,3,8,13,18,23))return 1;
	if(isbingo(k,4,9,14,19,24))return 1;
	if(isbingo(k,5,10,15,20,25))return 1;
	if(isbingo(k,5,9,13,17,21))return 1;
	if(isbingo(k,1,7,13,19,25))return 1;
	return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		for(int j=1;j<=25;j++)cin>>a[i][j];
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>b[i];
		for(int j=1;j<=n;j++){
			for(int k=1;k<=25;k++){
				if(a[j][k]==b[i])bo[j][k]=1;
			}
		}
	}
	string str="";
	for(int i=1;i<=n;i++){
		if(check(i)){
			ans++;
			str+=s[i];
			str+="\n";
		}
	}
	cout<<ans<<endl<<str;
	return 0;
}
```

---

## 作者：XingnoYi (赞：1)

# 思路分析：
题目的意思很明白了，此题数据也不大。考虑用**模拟**来解决。

如下 `big` 表示 `long long`。
## 1. 处理输入与模拟游戏过程
由于需要在每出一个球时划掉一个数，我们要在存储板上数字时将每一个数字的位置**预处理**出来。

考虑用一个**结构体**来预处理信息：

```cpp
struct Node{
	big flag,x,y; // 是否存在，位置
}pos[55][95]; // 选手编号，数字
```

用一个**三维数组**来存储每一块板的信息：

```cpp
big map[55][10][10]; // 第 i 位选手的板上第 (j,k) 位置的数
```

用字符串数组存储选手名字和符合条件选手：

```cpp
string name[55],ans[55];
```


------------
最后输入球的编号时，可以直接模拟操作。

遍历所有选手的隔板，若有这个数，则将这个数划掉（置为 $0$），由于前面已经预处理过，便不用一一查找了。

由于一条线划掉至少需要 $5$ 个球，所以当 $m < 5$ 时，条件一定不成立，可以直接输出 $0$。
```cpp
cin >> m;
if(m < 5)
{
	printf("0");
	return 0;
}
for(big l = 1;l <= m;l++)
{
	scanf("%lld",&ball);
	for(big i = 1;i <= n;i++)
	{
		if(pos[i][ball].flag)
		{
			big xi = pos[i][ball].x;
			big yi = pos[i][ball].y;
			map[i][xi][yi] = 0;
		}
	}
}
```
## 2. 判断符合

题目说是**行、列**或**两对角线**其中**一条**全被划掉视为胜利。

由于只有隔板大小只有 $5 \times 5$，故可以直接暴力判断：

```cpp
bool check(big id)
{
   // 某条线全划掉即该线所有位置都是 0，故它们的和也为 0。
	for(big i = 1;i <= 5;i++)
	{
		if(map[id][i][1] + map[id][i][2] + map[id][i][3] + map[id][i][4] + map[id][i][5] == 0) // 行
		{
			return 1;
		}
		if(map[id][1][i] + map[id][2][i] + map[id][3][i] + map[id][4][i] + map[id][5][i] == 0) // 列
		{
			return 1;
		}
	}
	if(map[id][1][1] + map[id][2][2] + map[id][3][3] + map[id][4][4] + map[id][5][5] == 0) // 主对角线
	{
		return 1;
	}
	if(map[id][1][5] + map[id][2][4] + map[id][3][3] + map[id][4][2] + map[id][5][1] == 0) // 从对角线
	{
		return 1;
	}
	return 0;
}
```

## 3. 输出答案

遍历每个选手，判断是否符合条件。若符合，就加入 `ans[]` 中，统计数量最后输出即可。

```cpp
big cnt = 0;
for(big i = 1;i <= n;i++)
{
	if(check(i))
	{
		ans[++cnt] = name[i];
	}
}
printf("%lld\n",cnt);
for(big i = 1;i <= cnt;i++)
{
	cout << ans[i] << endl;
}
```

## 完整代码：
```cpp
#include <iostream>
#define big long long
using namespace std;
struct Node{
	big flag,x,y; // 位置
}pos[55][95]; // 人，数
big map[55][10][10]; // 人，板
string name[55],ans[55];
big n,m,ball;
bool check(big id)
{
	for(big i = 1;i <= 5;i++)
	{
		if(map[id][i][1] + map[id][i][2] + map[id][i][3] + map[id][i][4] + map[id][i][5] == 0)
		{
			return 1;
		}
		if(map[id][1][i] + map[id][2][i] + map[id][3][i] + map[id][4][i] + map[id][5][i] == 0)
		{
			return 1;
		}
	}
	if(map[id][1][1] + map[id][2][2] + map[id][3][3] + map[id][4][4] + map[id][5][5] == 0)
	{
		return 1;
	}
	if(map[id][1][5] + map[id][2][4] + map[id][3][3] + map[id][4][2] + map[id][5][1] == 0)
	{
		return 1;
	}
	return 0;
}
int main()
{
	cin >> n;
	for(big i = 1;i <= n;i++)
	{
		cin >> name[i];
		for(big j = 1;j <= 5;j++)
		{
			for(big k = 1;k <= 5;k++)
			{
				big x;
				cin >> x;
				map[i][j][k] = x;
				pos[i][x] = (Node){1,j,k};
			}
		}
	}
	cin >> m;
	if(m < 5)
	{
		printf("0");
		return 0;
	}
	for(big l = 1;l <= m;l++)
	{
		scanf("%lld",&ball);
		for(big i = 1;i <= n;i++)
		{
			if(pos[i][ball].flag)
			{
				big xi = pos[i][ball].x;
				big yi = pos[i][ball].y;
				map[i][xi][yi] = 0;
			}
		}
	}
	big cnt = 0;
	for(big i = 1;i <= n;i++)
	{
		if(check(i))
		{
			ans[++cnt] = name[i];
		}
	}
	printf("%lld\n",cnt);
	for(big i = 1;i <= cnt;i++)
	{
		cout << ans[i] << endl;
	}
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：1)

这道题是一道模拟题，$10$ 分钟切完。

考虑用 map 记录每个玩家隔板上数字所在的位置，用一个数组来记录数字是否被划去。当输入 $x_i$ 时，只要将 $x_i$ 所在的位置提取出来，打上标记即可。

最后遍历每个玩家隔板上的数字，判断一下就行了。

代码如下：
```cpp
// 珍爱生命，远离抄袭！
#include <iostream>
#include <map>
#include <vector>
using namespace std;
int n;
map <int, int> Mapi[51], Mapj[51];
struct Player {
	string name;
	int a[6][6], vis[6][6];
};
Player p[51];
int num[91];
vector <string> ans;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> p[i].name;
		for (int j = 1; j <= 5; j++) {
			for (int k = 1; k <= 5; k++) {
				cin >> p[i].a[j][k];
				Mapi[i][p[i].a[j][k]] = j;
				Mapj[i][p[i].a[j][k]] = k;
			}
		}
	}
	int m;
	cin >> m;
	for (int i = 1; i <= m; i++) {
		cin >> num[i];
		for (int j = 1; j <= n; j++) {
			int posi = Mapi[j][num[i]], posj = Mapj[j][num[i]];
			if (posi != 0 && posj != 0) {
				p[j].vis[posi][posj] = 1;
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= 5; j++) {
			if (p[i].vis[j][1] && p[i].vis[j][2] && p[i].vis[j][3] && p[i].vis[j][4] && p[i].vis[j][5]) {
				ans.push_back(p[i].name);
				goto cccc;
			}
		}
		for (int j = 1; j <= 5; j++) {
			if (p[i].vis[1][j] && p[i].vis[2][j] && p[i].vis[3][j] && p[i].vis[4][j] && p[i].vis[5][j]) {
				ans.push_back(p[i].name);
				goto cccc;
			}
		}
		if (p[i].vis[1][1] && p[i].vis[2][2] && p[i].vis[3][3] && p[i].vis[4][4] && p[i].vis[5][5]) {
			ans.push_back(p[i].name);
			goto cccc;
		}
		if (p[i].vis[1][5] && p[i].vis[2][4] && p[i].vis[3][3] && p[i].vis[4][2] && p[i].vis[5][1]) {
			ans.push_back(p[i].name);
			goto cccc;
		}
	cccc:continue;
	}
	cout << ans.size() << endl;
	for (string str : ans) {
		cout << str << "\n";
	}
}
```

---

## 作者：封禁用户 (赞：1)

# 题目解释
这道题就是判断每个人持有的数字是否与主持人抽出的数字相同，然后判断是否成行、列、主对角线或从对角线排列就行了。
# 思路
这道题一眼纯模拟。怎么模拟呢？只需要判断每个人的格板的数是否与主持人给的数相同，开一个 $vis[]$ 数组标记一下就行了。
# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,y[1000],ans,cnt;
string s[1000];
struct node//结构体 
{
	int gb[10][10],vis[10][10]; 
	string name;
 }a[1000];
bool check(int x)//判断是否为主持人提供的数 
{
	for(int i=1;i<=m;i++)if(y[i]==x)return 1;
	return 0; 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)//输入 
	{
		cin>>a[i].name;
		for(int j=1;j<=5;j++)
			for(int k=1;k<=5;k++)
				cin>>a[i].gb[j][k];
	}
	cin>>m;
	for(int i=1;i<=m;i++)cin>>y[i];
	for(int i=1;i<=n;i++)//标记 
	{
		for(int j=1;j<=5;j++)
			for(int k=1;k<=5;k++)
					a[i].vis[j][k]=check(a[i].gb[j][k]);
	}
	for(int i=1;i<=n;i++)//判断形状 
	{
		int f=0;
		for(int j=1;j<=5;j++)if(a[i].vis[j][1]==1&&a[i].vis[j][2]==1&&a[i].vis[j][3]==1&&a[i].vis[j][4]==1&&a[i].vis[j][5]==1)
		{
			f=1;
			break;
		}
		for(int j=1;j<=5;j++)if(a[i].vis[1][j]==1&&a[i].vis[2][j]==1&&a[i].vis[3][j]==1&&a[i].vis[4][j]==1&&a[i].vis[5][j]==1)
		{
			f=1;
			break;
		}
		if(a[i].vis[1][1]==1&&a[i].vis[2][2]==1&&a[i].vis[3][3]==1&&a[i].vis[4][4]==1&&a[i].vis[5][5]==1)f=1;
		if(a[i].vis[1][5]==1&&a[i].vis[2][4]==1&&a[i].vis[3][3]==1&&a[i].vis[4][2]==1&&a[i].vis[5][1]==1)f=1;
		if(f==1)
		{
			ans++;
			s[++cnt] = a[i].name;
		 } 
		
	}
	cout<<ans<<endl;
	for(int i=1;i<=cnt;i++)cout<<s[i]<<endl;//输出	
	return 0;
}

```

---

## 作者：nyC20 (赞：1)

# 思路
很简单的模拟，不用优化，题目说什么就写什么就行了，就是输入主持人取的球的时候遍历每一个人的格板，如果这个人有这个数就划掉，然后最后统计有几个人满足行或列或两条对角线都被划掉了，输出答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, Map[53][5][5], m, x, ans;
bool mark[53][5][5], mark_[53];
string str[53];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>str[i];
		for(int j=1;j<=5;j++){
			for(int k=1;k<=5;k++){
				cin>>Map[i][j][k];
			}
		}
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>x;
		for(int j=1;j<=n;j++){
			for(int k=1;k<=5;k++){
				for(int l=1;l<=5;l++){
					if(Map[j][k][l]==x)mark[j][k][l]=true;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(mark[i][1][1]&&mark[i][1][2]&&mark[i][1][3]&&mark[i][1][4]&&mark[i][1][5])ans++,mark_[i]=true;
		else if(mark[i][2][1]&&mark[i][2][2]&&mark[i][2][3]&&mark[i][2][4]&&mark[i][2][5])ans++,mark_[i]=true;
		else if(mark[i][3][1]&&mark[i][3][2]&&mark[i][3][3]&&mark[i][3][4]&&mark[i][3][5])ans++,mark_[i]=true;
		else if(mark[i][4][1]&&mark[i][4][2]&&mark[i][4][3]&&mark[i][4][4]&&mark[i][4][5])ans++,mark_[i]=true;
		else if(mark[i][5][1]&&mark[i][5][2]&&mark[i][5][3]&&mark[i][5][4]&&mark[i][5][5])ans++,mark_[i]=true;
		else if(mark[i][1][1]&&mark[i][2][1]&&mark[i][3][1]&&mark[i][4][1]&&mark[i][5][1])ans++,mark_[i]=true;
		else if(mark[i][1][2]&&mark[i][2][2]&&mark[i][3][2]&&mark[i][4][2]&&mark[i][5][2])ans++,mark_[i]=true;
		else if(mark[i][1][3]&&mark[i][2][3]&&mark[i][3][3]&&mark[i][4][3]&&mark[i][5][3])ans++,mark_[i]=true;
		else if(mark[i][1][4]&&mark[i][2][4]&&mark[i][3][4]&&mark[i][4][4]&&mark[i][5][4])ans++,mark_[i]=true;
		else if(mark[i][1][5]&&mark[i][2][5]&&mark[i][3][5]&&mark[i][4][5]&&mark[i][5][5])ans++,mark_[i]=true;
		else if(mark[i][1][1]&&mark[i][2][2]&&mark[i][3][3]&&mark[i][4][4]&&mark[i][5][5])ans++,mark_[i]=true;
		else if(mark[i][1][5]&&mark[i][2][4]&&mark[i][3][3]&&mark[i][4][2]&&mark[i][5][1])ans++,mark_[i]=true;
	}
	cout<<ans<<endl;
	for(int i=1;i<=n;i++){
		if(mark_[i]==true){
			cout<<str[i]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：__xsy2013__ (赞：1)

这道题是一道简单模拟题，很快切掉了。

考虑使用 `map` 来记录每个玩家隔板上数字所在的位置，用一个数组来记录数字是否被划去。当输入 $x_i$ 时，只要将 
 $x_i$ 所在的位置提取出来，打上标记即可。

最后遍历每个玩家隔板上的数字，判断一下就可以了。

代码就不放了吧。

---

## 作者：LG086 (赞：0)

### 分析

直接按照题意大模拟。

使用三维数组记录每个玩家的格板上的数字。  
使用 map 记录取出的 $m$ 个数以及记录符合要求的玩家编号。

如果 $m \le 4$ 可以直接输出 $0$。  
否则判断每个玩家格板的行、列、对角线上 $5$ 个数是否全是取出的 $m$ 个数之一。



------------
### 代码

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int n,i,num,ans;
string s[100];//名字
int a[100][10][10];//格板
int m;
map<int,int>cnt;//记录符合要求的玩家编号
map<int,int>b;//记录取出的数字
signed main(){
    cin>>n;
    while(n--){
        cin>>s[++i];
        for(int x = 1;x <= 5;x ++)
        for(int y = 1;y <= 5;y ++)
        cin>>num,a[i][x][y]=num;
    }
    cin>>m;
    if(m<=4)//取出的数字不够多
    return cout<<0,0;//直接输出
    for(int x = 1;x <= m;x ++)
    cin>>num,b[num]=1;//记录
    for(int y = 1;y <= i;y ++){//行
        int flag=0;
        for(int s = 1;s <= 5;s ++){
            flag=0;
            for(int q = 1;q <= 5;q ++)
            if(b[a[y][s][q]]!=1)flag=1;
            if(!flag){//符合要求
                cnt[y]=1;//记录下来
                break;
            }
        }
    }
    for(int y = 1;y <= i;y ++){//列
        int flag=0;
        for(int s = 1;s <= 5;s ++){
            flag=0;
            for(int q = 1;q <= 5;q ++)
            if(b[a[y][q][s]]!=1)flag=1;
            if(!flag){
                cnt[y]=1;
                break;
            }
        }
    }
    for(int y = 1;y <= i;y ++){//对角线
        int flag=0;
        for(int s = 1;s <= 5;s ++)
        if(b[a[y][s][s]]!=1)flag=1;
        if(!flag)
        cnt[y]=1;
    }
    for(int y = 1;y <= i;y ++){
        int flag=0;
        for(int s = 1;s <= 5;s ++)
        if(b[a[y][s][5-s+1]]!=1)flag=1;
        if(!flag)
        cnt[y]=1;
    }
    cout<<cnt.size()<<endl;//输出符合要求的人数
    for(int y = 1;y <= i;y ++)
    if(cnt[y])cout<<s[y]<<endl;//输出符合要求玩家的大名
}
```

---

## 作者：T_TLucas_Yin (赞：0)

注意到题目给的数据范围很小，即使在最最直接的暴力做法下时间和空间都是没有卡满的（甚至绰绰有余）。所以可以直接按题意模拟。

首先将给定的每名玩家的名字和数字矩阵作为一个元素存入结构体里，每个结构体元素中另有一个与数字矩阵对应的标记数组。然后读入主持人念出的数字，每读入一个数字就遍历每个人的数字矩阵的每个位置，把所有与念出的数字相同的位置都打上标记。

接下来再次遍历每名玩家的数字矩阵，依次判断该玩家矩阵的标记数组每行、每列、两条对角线是否都打上了标记。如果以上行列中有任一条打满了标记，则该玩家符合获胜条件。此时将该玩家的名字堆入一个数组里。最后输出该数组的大小和其中的每个元素（即符合胜利条件的所有玩家的名字）即可。

主要难点：

- 遍历的顺序不能乱
- 注意循环变量的命名
- 注意区分各层的标记

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,sum;
string na[1005];
struct node{
	string name;
	int f[15][15];
	bool flag[15][15];
}a[1005];//a数组中每个元素表示一名玩家的信息
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].name;
		for(int j=1;j<=5;j++) for(int k=1;k<=5;k++) cin>>a[i].f[j][k];
	}//读入玩家信息
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>p;
		for(int k=1;k<=n;k++){
			for(int x=1;x<=5;x++) for(int y=1;y<=5;y++)
				if(a[k].f[x][y]==p) a[k].flag[x][y]=1;//把所有与该数字相同的位置打上标记
		}
	}
	for(int k=1;k<=n;k++){//遍历每位玩家
		bool flag=0;
		for(int i=1;i<=5;i++){
			bool fl=1;
			for(int j=1;j<=5;j++) if(!a[k].flag[i][j]){
				fl=0;break; }
			if(fl){ flag=1;break; }
		}//判断该玩家的矩阵是否有某一行被完整取出
		for(int j=1;j<=5;j++){
			bool fl=1;
			for(int i=1;i<=5;i++) if(!a[k].flag[i][j]){
				fl=0;break; }
			if(fl){ flag=1;break; }
		}//判断该玩家的矩阵是否有某一行被完整取出
		bool fl=1;
		for(int i=1;i<=5;i++) if(!a[k].flag[i][i]){ fl=0;break; }
		if(fl) flag=1;//判断该玩家的矩阵主对角线是否被完整取出
		fl=1;
		for(int i=1;i<=5;i++) if(!a[k].flag[i][5-i+1]){ fl=0;break; }
		if(fl) flag=1;//判断该玩家的矩阵副对角线是否被完整取出
		if(flag) na[++sum]=a[k].name;//符合任一条的玩家可以获胜
	}
	cout<<sum<<"\n";
	for(int i=1;i<=sum;i++) cout<<na[i]<<"\n";//按题目要求输出
	return 0;
}
```

---


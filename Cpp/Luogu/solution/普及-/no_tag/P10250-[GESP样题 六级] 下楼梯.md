# [GESP样题 六级] 下楼梯

## 题目描述

顽皮的小明发现，下楼梯时每步可以走 $1$ 个台阶、$2$ 个台阶或 $3$ 个台阶。现在一共有 $N$ 个台阶，你能帮小明算算有多少种方案吗？

## 说明/提示

对全部的测试点，保证 $1 \leq N \leq 60$。

## 样例 #1

### 输入

```
4```

### 输出

```
7```

## 样例 #2

### 输入

```
10```

### 输出

```
274```

# 题解

## 作者：_Star_Universe_ (赞：19)

## [题目传送门](https://www.luogu.com.cn/problem/P10250)
修改了思路里的一处笔误，望管理通过。
### 题意
就是让你求下 $n$ 级台阶时有一次下一级，一次下两级，一次下三级这三种方式，一共多少种走法，且顺序不同也算两种哦！要注意。

### 递推思路
就是一个简单的递推题，当 $n=1$ 时，那当然就是直接下一级台阶，当 $n=2$ 时，可以直接下两级，也可以下两个一级，当 $n=3$ 时，可以下三级，也可以先下一级再下两级，也可以先下两级后再下一级，也可以连续下三个一级，后面楼梯级数每增加一级方案数就是数组前三个元素的和，可得以下公式：
$$a_j=a_{j-1}+a_{j-2}+a_{j-3}$$

其实这个公式是很容易得到的，因为一次最多下三级楼梯，所以从上往下数第 $j$ 级楼梯可以从上面三级中任意一级走过来，自然就可以得到是方案数是上面三级楼梯方案数的和。

### 递推代码
```c
#include<bits/stdc++.h> 
using namespace std;

long long a[1001];
int n;
int main(){
	cin>>n;
	a[0]=1;
	a[1]=2;
	a[2]=4;
	for(int j=3;j<n;j++){
	  	a[j]=(a[j-1]+a[j-2]+a[j-3]);
    }
	cout<<a[n-1]<<endl;		
    return 0;
}
```

---

## 作者：封禁用户 (赞：5)

## [题目传送门](https://www.luogu.com.cn/problem/P10250)

## 思路

看数据范围，$1\le N\le 60$，不算大，可以按照斐波那契数列的思想来做。只不过公式要改一下，变成 $dp_i=dp_{i-1}+dp_{i-2}+dp_{i-3}$。

还要注意一下初始化的问题：

1. 第一层楼梯：只有走 $1$ 个台阶的方法。
2. 第二层楼梯：可以走 $2$ 次 $1$ 个台阶；还可以走 $1$ 次 $2$ 个台阶。共 $2$ 种方法。
3. 第三层楼梯：可以走 $4$ 次 $1$ 个台阶；还可以走 $1$ 次 $1$ 个台阶和 $1$ 次 $3$ 个台阶；还可以走 $1$ 次 $3$ 个台阶和 $1$ 次 $1$ 个台阶；还可以走 $2$ 次 $2$ 个台阶。共 $4$ 种方法。

```cpp
#include <iostream>
using namespace std;
long long dp[100]; // 不开 long long 见祖宗
int main()
{
    int n;
    cin >> n;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;
    for (int i = 4; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    cout << dp[n] << endl;
    return 0;
}
```

---

## 作者：watergod (赞：3)

# P10250 [GESP样题 六级] 下楼梯

一个非常经典的题，只不过原来是每次可以上一层或者两层楼梯。

简单的 dp。

## 题目大意

[如题](https://www.luogu.com.cn/problem/P10250)

## 题目思路

用 $a[n]$ 表示走到第 $n$ 层楼梯的方法数，那么我们首先可以得知：

$a[1] = 1$，$a[2] = 2$，$a[3] = 4$，可以手动推理。

接着，我们不难推导出递推式，面对第 $n$ 个台阶，我们可以在第 $n-1$ 个台阶上往前走一步，第 $n-2$ 个台阶上往上走 $2$ 步，亦或是在第 $n-3$ 个台阶上往上走三步，所以第 $n$ 个台阶的方法数就等于这三者之和，递推式如下：

$a[n] = a[n-1] + a[n-2] + a[n-3]$。

当然我们要注意，题目虽然 $n$ 最大只有 $60$，但最后的方法数很有可能比较大，所以 不开 long long 见祖宗。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
long long a[61]; 

int main(){
	cin >> n;
	a[-1] = a[-2] = a[-3] = 0;
	a[0] = 1;
	a[1] = 1;
	a[2] = 2;
	a[3] = 4;
	for(int i=4;i<=n;i++){
		a[i] = a[i-1] + a[i-2] + a[i-3];
	} 
	cout << a[n];
	return 0;
}

```

---

## 作者：Ivan422 (赞：3)

题目大意：走楼梯可以一步走 $1$ 到 $3$ 级，求到 $n$ 级的方案数。

思路：此题类似斐波那契数列，可以参考[此题](https://www.luogu.com.cn/problem/P1255)。唯一的区别是可以由前 $3$ 级转移过来。可以用动态规划或递推。注意斐波那契数列的大小增长非常快，所以要开 `long long`。

初始化：在地板上有一种方案，即 $f_0=1$。

状态转移：第 $i$ 个楼梯可以由第 $i-1$，$i-2$ 和 $i-3$ 个楼梯走过来，即 $f_i=f_{i-1}+f_{i-2}+f_{i-3}$。

答案：即第 $n$ 级，$f_n$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=66;
int n,f[N];
signed main() {
    cin>>n;
    f[0]=1;
    for(int i=1;i<=n;i++)f[i]=f[i-1]+f[i-2]+f[i-3];
    cout<<f[n];
    return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

下楼梯和上楼梯是的方案数是一样的，本文按照上楼梯的方案数来讲述。

考虑动态规划算法，定义 $dp_i$ 表示到达第 $i$ 阶楼梯的方案数，因为可以从 $i-1,i-2,i-3$ 阶走上来，所以状态转移方程为：

$$dp_i=dp_{i-1}+dp_{i-2}+dp_{i-3}$$

初始 $dp_0=1,dp_1=1,dp_2=2$。

时间复杂度为 $O(N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=65;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n;
ll dp[N];
int main(){
	n=read();
	dp[0]=dp[1]=1,dp[2]=2;
	for(int i=3;i<=n;i++)
	  dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
	write(dp[n]);
	return 0;
}
```

---

## 作者：nightwatch.ryan (赞：1)

### 思路
这道用递推做。首先将 $1$ 个台阶，$2$ 个台阶，$3$ 个台阶和 $4$ 个台阶的方案求出来

![](https://cdn.luogu.com.cn/upload/image_hosting/109lcpul.png)

观察发现，四层台阶的 $7$ 种方案等于 $1+2+4$，正好是前三层台阶的方案总和。因此我们可以得出递推式：
$$
f_{i}=f_{i-1}+f_{i-2}+f_{i-3}
$$

### 代码
```cpp
//不开long long见祖宗
#include<iostream>
#define int long long
int f[65];
signed main(){
	int n;
	std::cin>>n;
	f[0]=1;
	f[1]=1;
	f[2]=2;
	for(int i=3;i<=n;i++){
		f[i]=f[i-1]+f[i-2]+f[i-3];
	}
	std::cout<<f[n];
} 
```

---

## 作者：we_are_the_chuibing (赞：1)

板子动态规划。和[这题](https://www.luogu.com.cn/problem/P1255)差不多。

转移方程：

$$f_i=f_{i-1}+f_{i-2}+f_{i-3}$$

直接照着转移方程写即可，具体见代码。

```
#include<iostream>
using namespace std;
long long a[61]={0,1,2,4};//前三项
int main(){
	int n;cin>>n;
	for(int i=4;i<=n;i++)a[i]=a[i-1]+a[i-2]+a[i-3];//转移方程
	cout<<a[n];
	return 0;
}
```

---

## 作者：xd244 (赞：1)

递推的模板题，走到 $n$ 阶台阶的方案数（用 $a_n$ 表示），就等于前三阶的方案数总和，也就是 $a_n=a_{n-1}+a_{n-2}+a_{n-3}(n\ge4)$，而枚举可得，$a_1=1,a_2=2,a_3=4$，所以初始化之后递推即可。

代码：
```cpp
#include<iostream>
using namespace std;
int main(){
    int n;cin>>n;
    long a[70]={0,1,2,4};
    for(int c=4;c<=n;c++)a[c]=a[c-1]+a[c-2]+a[c-3];
    cout<<a[n];
}
```

---

## 作者：封禁用户 (赞：0)

## 思路
##### 此题比较简单，就是考考递推
#####  我们先来模拟一下：
- 当 $n=1$ 时，一步到位。
- 当 $n=2$ 时，可以走 $1,1$ 也可以走 $2$。
- 当 $n=3$ 时，有四种方法 $1,1,1$，也可以走 $1,2$，还能走 $2,1$，最后一种 $3$。
- 当 $n=4$ 时，有 $7$ 种方法，这里就不再说了。
- 我们设 $i$ 为第几个楼梯数。
- 由此可见，递推式是 $a_i=a_{i-1}+a_{i-2}+a_{i-3}$。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//注意：赋初值时注意数组下标从0开始
long long a[61]={0,1,2,4};//十年OI一场空___________
int n;

int main(){
    cin>>n;
    for(int i=4;i<=n;i++){
	a[i]=a[i-1]+a[i-2]+a[i-3];//d递推式
    }
    cout<<a[n];//输出
    return 0;
}

```

---

## 作者：2021zjhs005 (赞：0)

递推入门题。

显然下楼梯可以转换为上楼梯。

设 $dp_i$ 表示到达第 $i$ 个楼梯的方案数，不难得到递推式 $dp_i = dp_{i-1} + dp_{i-2} + dp_{i-3}$，表示从楼梯 $i-1$，$i-2$，$i-3$ 的方案数之和，因为一次可以跨 $1$，$2$ 或者 $3$ 步。

因为 $x-3$ 可能小于等于 $0$，因此手推（初始化） $dp_1 = 1$，$dp_2 = 2$，$dp_3 = 4$。

总体来说就是这样的：

$$\begin{cases}x=1&dp_1=1\\x=2&dp_2=2\\x=3&dp_3=4\\x\ge 4&dp_i =dp_{i-1}+dp_{i-2}+dp_{i-3}\end{cases}$$

注意开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rrep(i,x,y) for(int i=x;i>=y;i--)
#define sc scanf
#define pr printf
inline int read(){int s=0,w=1;char c=getchar();while(!isdigit(c)){if(c=='-') w=-1;c=getchar();}while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s*w;}

int n,dp[65]={0,1,2,4};

signed main(){
  n=read();
  rep(i,4,n) dp[i]=dp[i-1]+dp[i-2]+dp[i-3];//递推公式。
  pr("%lld\n",dp[n]);
  return 0;
}
```

---

## 作者：Programming_Konjac (赞：0)

# 思路
我们设 $f_i$ 为到第 $i$ 个台阶的方案数，那么初始值就应该为：$f_1=1,f_2=2,f_3=f_1+f_2+1=4$，读者可以自行理解。

我们来找状态转移方程，因为每一次都是上三个台阶的方案数的和，所以我们可以得到以下状态转移方程：

$$f_i=f_{i-1}+f_{i-2}+f_{i-3}(4\le i \le n)$$

最后输出 $f_n$ 即可。

注意：这题要开 `long long`！
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll f[65];
int main(){
	int n;
	cin>>n;
	f[1]=1;
	f[2]=2;
	f[3]=4;
	for(int i=4; i<=n; i++){
		f[i]=f[i-1]+f[i-2]+f[i-3];
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

这是一道递推题。

根据题目我们可以发现，走台阶可以走 $1$ 级，可以走 $2$ 级，也可以走 $3$ 级，那么我们列出递推式：
$$
f_i=f_{i-1}+f_{i-2}+f_{i-3}
$$

其中 $f_i$ 表示走 $i$ 级台阶的方案数量。

注意初始值，得设 $f_0=1$，$f_1=1$，$f_2=2$（自己模拟一下就可以知道）。
```cpp
#include <iostream>
#define int long long
using namespace std;
int f[75];
signed main() {
	int n;
	cin >> n;
	f[0] = f[1] = 1, f[2] = f[1] + 1;
	for (int i = 3; i <= n; i++) {
		f[i] = f[i - 1] + f[i - 2] + f[i - 3];
	}
	cout << f[n];
}
```

---


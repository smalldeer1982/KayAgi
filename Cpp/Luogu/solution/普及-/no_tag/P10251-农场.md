# 农场

## 题目背景

加入 mc2b2t.com 谢谢喵。

upd：

![](https://cdn.luogu.com.cn/upload/image_hosting/ks73gdzb.png)

## 题目描述

ZHY 想管理他的农场。  

具体地，他有 $n$ 片农场，每一片农场都是一个矩形，其四条边都平行于坐标轴。这些农场可以有重叠的部分。

他现在想圈一块地来维护自己的农场。他希望这块地可以完全覆盖所有农场。为了方便，他还希望这块地也是一个四条边都平行于坐标轴的矩形。他想最小化矩形的面积。

由于他的农场实在是太多了，所以他向你寻求帮助。你需要输出这个矩形的面积。

## 说明/提示

样例解释：如下图所示，绿色为第一个农场，红色为第二个农场，不难发现最小的圈地面积为 $3\times 4=12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8hhhluee.png)

----

对于 $40\%$ 的数据，$n,|x|,|y| \le 200$。

对于 $100\%$ 的数据，$1 \le n \le 2 \times 10^{5}$，$0 \le |x|,|y| \le 10^{9}$，$x_{1}\neq x_{2}$，$y_{1}\neq y_{2}$。

## 样例 #1

### 输入

```
2
1 0 2 3
-1 1 3 2```

### 输出

```
12```

# 题解

## 作者：saixingzhe (赞：7)

# 分析
注意每次给你的是对角两个对角，所以共有四种可能，左上右下，左下右上，两个点交换又会产生两种情况。

我们枚举这四种情况，为了方便，统计最终答案的左下和右上角，输出结果即可。

注意赋初始值。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a,b,c,d,e=1000000000,f=1000000000,g=-1000000000,h=-1000000000;
int main(){
	scanf("%lld",&n);
	while(n--){
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		if(a<c&&b<d){
			e=min(e,a);
			f=min(f,b);
			g=max(g,c);
			h=max(h,d);
		}
		else	if(a>c&&b>d){
			e=min(e,c);
			f=min(f,d);
			g=max(g,a);
			h=max(h,b);
		}
		else	if(a<c&&b>d){
			e=min(e,a);
			f=min(f,d);
			g=max(g,c);
			h=max(h,b);
		}
		else{
			e=min(e,c);
			f=min(f,b);
			g=max(g,a);
			h=max(h,d);
		}
	}
	printf("%lld",(g-e)*(h-f));
    return 0;
}
```

---

## 作者：Programming_Konjac (赞：4)

# 赛时思路
用 $4$ 个变量记录一下 $n$ 个区域中最大的 $x$ 坐标，最小的 $x$ 坐标，最大的 $y$ 坐标，最小的 $y$ 坐标（$x$ 坐标代表 $x_1$ 和 $x_2$，$y$ 坐标代表 $y_1$ 和 $y_2$）。

最后输出最大的 $x$ 坐标减去最小的 $x$ 坐标的差乘最大的 $y$ 坐标减去最小的 $y$ 坐标的差，换句话说就是 $(max_x-min_x)\times (max_y-min_y)$。

注意：输出时要开 `long long`！
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	int n,minnx=0x3f3f3f3f,minny=0x3f3f3f3f,maxxx=-0x3f3f3f3f,maxxy=-0x3f3f3f3f;
	cin>>n;
	for(int i=1; i<=n; i++){
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		minnx=min(minnx,a);
		minnx=min(minnx,c);
		minny=min(minny,b);
		minny=min(minny,d);
		maxxx=max(maxxx,a);
		maxxx=max(maxxx,c);
		maxxy=max(maxxy,b);
		maxxy=max(maxxy,d);
	}
	cout<<(maxxy-minny)*1ll*(maxxx-minnx);
	return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P10251 题目](https://www.luogu.com.cn/problem/P10251)

### 解题思路
首先，我们要在每次输入时保证 $x1\le x2$ 和 $y1\le y2$，若不满足以上性质，则交换。

设长方形的右上角坐标为 $(x3,y3)$，左下角坐标为 $(x4,y4)$。不难发现，在每次输入时，我们要使 $x3=\min(x3,x1)$，$y3=\min(y3,y1)$，$x4=\max(x4,x2)$，$y4=\max(y4,y2)$。

最后可求出长方形的面积为 $(x4-x3)\times(y4-y3)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	ios::sync_with_stdio(false);
    int n,minn=1e9+1,minx=1e9+1,maxx=-1e9-1,maxn=-1e9-1;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
		int x,xx,y,yy;
		cin>>x>>y>>xx>>yy;
		if(x>xx)
			swap(x,xx);
		if(y>yy)
			swap(y,yy);
		minn=min(minn,x);
		maxn=max(maxn,xx);
		maxx=max(yy,maxx);
		minx=min(y,minx);
	}
	int s=(maxn-minn)*(maxx-minx);
	cout<<s;	
    return 0;
}
```

---

## 作者：b1tset (赞：1)

### 思路

模拟题。很显然，找出最大的以及最小的 $x$ 和 $y$ 即可，最后的答案为：$(x_{max} \ - \ x_{min}) \times (y_{max} \ - \ y_{min})$。

注意数据范围，要开 ```long long```。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long // 注意数据范围

signed main()
{
    int t, a, b, c, d, mxx=-1e9, mnx=1e9, mxy=-1e9, mny=1e9;
    scanf("%lld", &t);
    while (t--)
    {
        scanf("%lld %lld %lld %lld", &a, &b, &c, &d);
        mxx=max({mxx,a,c}), mnx=min({mnx,a,c}); // 求最大和最小的 x
        mxy=max({mxy,b,d}), mny=min({mny,b,d}); // 求最大和最小的 y
    }
    printf("%lld\n", (mxx-mnx)*(mxy-mny));
    return 0;
}
```

---

## 作者：Lyw_and_Segment_Tree (赞：1)

## 开始解题
那么根据题目中的图所示，我们很快就能想到这样一个做法：  
> 维护四个变量分别表示最高处，最低处，最长处，最短处。

那么由于题目没有说保证 $x_1 \le x_2$ 以及 $y_1 \le y_2$，所以我们需要进行三个量之间的 $\max$。 

那么根据以上思路，可得代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long max_width = INT_MIN, min_width = INT_MAX;
long long max_height = INT_MIN, min_height = INT_MAX;
void add(long long X1, long long Y1, long long X2, long long Y2) {
    max_height = max({max_height, Y1, Y2});
    min_height = min({min_height, Y1, Y2});
    max_width = max({max_width, X1, X2});
    min_width = min({min_width, X1, X2});
}
int main() {
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        long long X1, Y1, X2, Y2;
        cin >> X1 >> Y1 >> X2 >> Y2;
        add(X1, Y1, X2, Y2);
    }
    cout << 1ll * (max_width - min_width) * (max_height - min_height) << endl;
}
```

---

## 作者：tder (赞：1)

考虑取 $\text{mnx}=\min(x_i)$ 和 $\text{mxx}=\max(x_i)$，则其横向跨度为 $\text{mxx}-\text{mnx}$，纵向同理。为了使矩形面积最小，很明显希望长宽均取最小值，面积即为 $(\text{mxx}-\text{mnx})\times(\text{mxy}-\text{mny})$。

另外注意不保证 $x_1<x_2$ 等。

时间复杂度 $O(n)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5, INF = 1e18;
int n, mnx = INF, mxx = -INF, mny = INF, mxy = -INF;
signed main() {
    cin>>n;
    while(n--) {
        int x1, y1, x2, y2; cin>>x1>>y1>>x2>>y2;
        mnx = min(mnx, min(x1, x2));
        mxx = max(mxx, max(x1, x2));
        mny = min(mny, min(y1, y2));
        mxy = max(mxy, max(y1, y2));
    }
    cout<<(mxx - mnx) * (mxy - mny);
}
```

---

## 作者：lgydkkyd (赞：1)

这是一道语法题，思路很简单：求出所有横坐标中最大的减最小的，乘上纵坐标中最大的减最小的，就是答案了。
# Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200001][5],minx=LONG_LONG_MAX,miny=LONG_LONG_MAX,maxx=LONG_LONG_MIN,maxy=LONG_LONG_MIN;
signed main(){ 
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=4;j++){
			cin>>a[i][j];
		}
		minx=min(a[i][1],minx);
		minx=min(a[i][3],minx);
		miny=min(a[i][2],miny);
		miny=min(a[i][4],miny);
		maxx=max(a[i][1],maxx);
		maxx=max(a[i][3],maxx);
		maxy=max(a[i][2],maxy);
		maxy=max(a[i][4],maxy);
	}
	cout<<(maxx-minx)*(maxy-miny);
	return 0;
}
```

---


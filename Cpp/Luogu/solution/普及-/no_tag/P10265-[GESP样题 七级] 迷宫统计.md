# [GESP样题 七级] 迷宫统计

## 题目描述

在神秘的幻想⼤陆中，存在着 $n$ 个古老而神奇的迷宫，迷宫编号从 $1$ 到 $n$。有的迷宫之间可以直接往返，有的可以⾛到别的迷宫，但是不能⾛回来。玩家小杨想挑战⼀下不同的迷宫，他决定从 $m$ 号迷宫出发。现在，他需要你帮助他统计：有多少迷宫可以直接到达 $m$ 号迷宫，$m$ 号迷宫可以直接到达其他的迷宫有多少，并求出他们的和。

需要注意的是，对于 $i$ ($1 \leq i \leq n$) 号迷宫，它总可以直接到达自身。

## 说明/提示

### 样例 1 解释

$4$ 号迷宫能直接到达的迷宫有 $3,4,6$ 号迷宫，共 $3$ 个。  
能直接到达 $4$ 号迷宫的迷宫有 $1,4,5$ 号迷宫，共 $3$ 个。

共 6 个。

### 数据规模与约定

| 子任务| 分值 | $n \leq $ |
| :-: | :-: | :-: |
| $1$ | $30$ | $10$ |
| $2$ | $30$ | $100$ | 
| $3$ | $40$ | $1000$ |

对全部的测试数据，保证 $1 \leq m \leq n \leq 1000$。

## 样例 #1

### 输入

```
6 4
1 1 0 1 0 0
0 1 1 0 0 0
1 0 1 0 0 1
0 0 1 1 0 1
0 0 0 1 1 0
1 0 0 0 1 1```

### 输出

```
3 3 6```

# 题解

## 作者：xyx404 (赞：18)

## 思路：

首先看题，让我们求迷宫 $m$ **可以直接到达其他的迷宫**有多少个，有多少迷宫**可以直接到达** $m$ 号迷宫，和这些迷宫的**总和**。

先看迷宫 $m$ **可以直接到达其他的迷宫**，是什么意思呢？

其实就是让我们看当历遍的迷宫是 $m$ 时有多少个为真。

由此得出代码：
```cpp
	for(int i=1;i<=n;i++){
		if(jz[m][i]==1){ // 我们只用查看 m 迷宫有多少个 1
			sum1++;
		}
	} 
```

然后我们看多少迷宫**可以直接到达** $m$ 号迷宫，这又是什么意思呢？

其实就是查看有多少个迷宫的 $m$ 也就是 $jz[i][m]$  为真。

由此得出代码：
```
	for(int i=1;i<=n;i++){
		if(jz[i][m]==1)sumzj++;
	} 
```

让我们看一下这两份代码循环的条件是不是相同的？

是对吧，由此合并两份代码：
```cpp
	for(int i=1;i<=n;i++){
		if(jz[m][i]==1){
			sum1++;
		}
		if(jz[i][m]==1)sumzj++;
	} 
```

最后看这些迷宫的**总和**，没有坑直接输出就行。

## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool jz[1001][1001];
long long sumzj;
long long sum1;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>jz[i][j];
		}
	} 
	for(int i=1;i<=n;i++){
		if(jz[m][i]==1){
			sum1++;
		}
		if(jz[i][m]==1)sumzj++;
	} 
	cout<<sum1<<" "<<sumzj<<" "<<sum1+sumzj;
	
	return 0;
}

```

---

## 作者：XT_HuangQuan (赞：6)

# P10265 题解
## 知识点
**循环输入**  
**对二维数组的理解**  
**模拟**  
**求和同时输出**
## 思路以及代码
**典型的暴力模拟**往往只需要最简单的思路：
前面的输入部分很基础，不会的同学们多做一些循环输入，代码如下：
```cpp
cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];//输入就不用多说了吧？ 
         // 切记，1是能走到的，0是不能的，和有些题有略微不一样。
		}
	} 
```
然后呢就开始处理这个**迷宫**，我们已经知道这个迷宫的含义，所以第一个这么处理。
```cpp
for(int i=1;i<=n;i++)
	{
		if(a[m][i]==1)//这个是m号迷宫可以直接去的。 
		{
			ans2++;//能去就加上。
		}
	 } 
```
那么第二个只需要简单改一下就行了：
```cpp
for(int i=1;i<=n;i++)
	{
		if(a[i][m]==1)//这是能去m号迷宫的 。
		{
			ans1++;//能去就算。 
		}
	}
```
所以再把输出加上，就差不多了，直接上代码：
```cpp
#include<bits/stdc++.h>//万能头。 
using namespace std;
int n,m;//n个迷宫，出发地点m 。
int a[1005][1005];//各个迷宫之间的关系。 
int ans1,ans2;//2是m号直接能去的迷宫，1是能去m号迷宫的迷宫。 
//这里也要注意看题，不要写反了！！
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];//输入就不用多说了吧 。
		}
	} 
	for(int i=1;i<=n;i++)
	{
		if(a[i][m]==1)//判断能不能去 。
		{
			ans1++;//能去就算。 
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(a[m][i]==1)//反过来其实是一样的。自己理解一下 。
		{
			ans2++; 
		}
	 } 
	cout<<ans2<<" "<<ans1<<" ";//先输出两个答案,千万要注意，不要写反了！！！！ 
	cout<<ans1+ans2;//最后输出总和 。
}
```
## 拓展题目
[P1003  铺地毯](https://www.luogu.com.cn/problem/P1003)

[P1004 方格取数](https://www.luogu.com.cn/problem/P1004)

[P1006 传纸条](https://www.luogu.com.cn/problem/P1006)


**大功告成！**

**蒟蒻第一次写题解，求过** ~~**求点赞**~~

**有错误请指出，一定修改**

---

## 作者：Superiority (赞：3)

# 思路
如果第 $m$ 行第 $j$ 列的数等于 $1$ 则代表代表 $m$ 号迷宫能通向 $j$ 号迷宫。

同理如果第 $m$ 列第 $i$ 行的数等于 $1$ 则代表代表 $i$ 号迷宫能通向 $m$ 号迷宫。

然后我们遍历第 $m$ 行的所有数以及第 $m$ 列的所有数，找出第 $m$ 行和第 $m$ 列里的 $1$ 的个数并记录，然后就可以输出了。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ans,sum;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int x;
			cin>>x;
			if(i==m&&x!=0) ans++;
			if(j==m&&x!=0) sum++; 
		}
	} 
	cout<<ans<<" "<<sum<<" "<<ans+sum<<endl;
	return 0;
} 
```

### ~~蒟蒻的第一篇题解还请管理大大通过~~

---

## 作者：spfa_ (赞：3)

[P10265 [GESP样题 七级] 迷宫统计
](https://www.luogu.com.cn/problem/P10265)

### 题目分析

依照题目模拟即可。若 $a_{i,j}$ 为 $1$，若 $j=m$，则累加 $ans2$；若 $i=m$，则累加 $ans1$，最后输出即可。

### code

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

int main() {
	int n = rd(), m = rd(), x = 0, y = 0;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			if (rd()) x += i == m, y += j == m;
	write(x), space, write(y), space, write(x+y);
	return 0;
}
```

---

## 作者：lujunhao (赞：3)

### 思路

先存入一个矩阵，之后在遍历找出能够到达 $m$ 与从 $m$ 点能够到达的点即可。（**暴力**）

### 题解

直接从 $1$ 开始遍历至 $n$ 判断 $aa[m][i]$ 与 $aa[i][m]$ 是否为 $1$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int aa[1005][1005];
int main()
{
	int a=0,b=0,n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>aa[i][j];
	for(int i=1;i<=n;i++)
	{
		if(aa[m][i]==1)
			a++;
		if(aa[i][m]==1)
			b++;
	}
	cout<<a<<" "<<b<<" "<<a+b;
}
```

---

## 作者：wrhllll (赞：2)

## 一道十分简单的题
#### 思路：
- 统计二维数组中的第 $m$ 行中“ $1$ ”的个数，统计迷宫 $m$ 可以直接到达的迷宫有多少个。
- 统计二维数组中的第 $m$ 列中“ $1$ ”的个数，统计有多少迷宫可以直接到达 $m$ 号迷宫。
- 将上述两个数据相加，获得迷宫总数。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
int mp[1010][1010];
int tot1, tot2;
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			cin >> mp[i][j];
	for (int i = 1; i <= n; i++)
		if (mp[m][i])tot1++;//统计迷宫m可以直接到达的迷宫有多少个
	for (int i = 1; i <= n; i++)
		if (mp[i][m])tot2++;//统计有多少迷宫可以直接到达m号迷宫
	cout << tot1 << " " << tot2 << " " << tot1 + tot2;//输出
	return 0;
}
```
## 谢谢观看与学习！

---

## 作者：MassPoint (赞：1)

## 核心思路

让我们先简化一下题目：

> 有一个 $n × n$ 的邻接矩阵，求第 $m$ 号节点能到达的节点数、能到达第 $m$ 号节点的节点数和他们两个的和。

而第 $m$ 号节点能到达的节点就是邻接矩阵中第 $m$ 行且值为真的元素；能到达 $m$ 号节点的节点数就是邻接矩阵中第 $m$ 列且值为真的元素。我们只要求出它们的值就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum1=0,sum2=0;
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int k;
			scanf("%d",&k);
			if(i==m&&k)	sum1++;	//第m号节点能到达的节点数
			if(j==m&&k)	sum2++;	//能到达第m号节点的节点数
		}
	}
	printf("%d %d %d",sum1,sum2,sum1+sum2);
	return 0;
}
```

---

## 作者：Aybbl_xc (赞：1)

**题目大意**

输入 $n$ 为行和列，$m$ 为几号迷宫，$1$表示可走，$0$ 表示不可以走，输出分别表示迷宫 $m$ 可以直接到达其他的迷宫有多少个，有多少迷宫可以直接到达 $m$ 号迷宫，这些迷宫的总和。

**思路**

第几行第几列就是表示第几个迷宫可以到达第几个迷宫，举个例子，假如第三行第二列，就是第三个迷宫可以到达第二个迷宫。
- 算迷宫 $m$ 可以直接到达其他的迷宫有多少个时，只要看第 $m$ 行中有多少个元素为 $1$ 就行。
- 算有多少迷宫可以直接到达 $m$ 号迷宫时，只要看第 $m$ 列中行中有多少个元素为 $1$ 就行。
- 最后再算总和。

**代码环节**
```
#include<bits/stdc++.h>
using namespace std;
int n,m,x,ans1,ans2;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>x;

				if(j==m&&x==1) ans1++;//只要是同一列并且为1就表示m号迷宫可以到达其他迷宫
				if(i==m&&x==1) ans2++;// m行中为1的元素就表示其他迷宫可以到达m号迷宫
		}
	}
	cout<<ans2<<" "<<ans1<<" "<<ans1+ans2; 
}
```
完结撒花！

---

## 作者：iyka (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P10265)

仔细看题，发现在输入矩阵时，$i=m$ 且 $a=1$ 即可以从 $i$ 直接走到 $m$，$j=m$ 且 $a=1$ 即可以从 $m$ 直接走到 $j$，然后再统计答案就行，连数组都不用开。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,ans1,ans2;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			cin>>a, ans1+=i==m?a:0, ans2+=j==m?a:0; //运用三目运算符可以减少码量 
	cout<<ans1<<" "<<ans2<<" "<<ans1+ans2;
	return 0;
} 
```

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10265)
## 题目意思
输入 $n,m$ 和一张邻接矩阵，统计 $m$ 号迷宫能到达的迷宫个数，以及有几个迷宫能从 $m$ 号迷宫到达。
## 解题思路
从 $1$ 到 $n$ 遍历迷宫，如果 $m$ 号迷宫能到达当前迷宫，$s \gets s+1$；如果当前迷宫能到达 $m$ 号迷宫，$ss \gets ss+1$。

最后，输出 $s,ss,s+ss$ 即可。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1010][1010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	int s=0,ss=0;
	for(int i=1;i<=n;i++)
	{
		if(a[m][i])s++;
		if(a[i][m])ss++;
	}
	cout<<s<<' '<<ss<<' '<<s+ss;
	return 0;
}

```

---

## 作者：a1111a (赞：0)

# 思路
把第 $m$ 行的总和和第 $m$ 列的总和求出来即可。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans1,ans2;//n表示迷宫总数,m表示出发迷宫的编号，两个ans即为答案
bool a[1002][1002];//输入的数组
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++){
		ans1+=a[m][i];//统计
		ans2+=a[i][m];//统计
	}
	cout<<ans1<<" "<<ans2<<" "<<ans1+ans2;
	return 0;
}
```

---

## 作者：sillation (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10265)


------------
#### P10265 [GESP样题 七级] 迷宫统计题解
一道十分适合初学者的题。

我们用变量 $l$ 和 $q$ 来统计 $m$ 号迷宫可以直接到达其他的迷宫的数量和其他迷宫可以直接到达 $m$ 号迷宫的数量。

分两种情况：

- $m$ 号迷宫可以直接到达其他的迷宫。如果是第 $m$ 行并且输入的是 $1$，那么变量 $q$ 加一。
- 其他迷宫可以直接到达 $m$ 号迷宫。如果是第 $m$ 列并且输入的是 $1$,那么变量 $l$ 加一。

其详细代码见代码 $1$。

你也可以把输入先存到一个二维数组里，然后再判断（判断方法一样）。不过有点烧内存。其详细代码见代码 $2$。

------------
#### 代码附上：


------------

##### 代码一：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,l,q,a;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a;
			if(i==m&&a) q++;
			if(j==m&&a) l++;//不要用 else if ！！
		}
	}
	cout<<q<<' '<<l<<' '<<l+q;
	return 0;
}
```


------------
#### 代码二：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l=0,q=0;
bool s[1001][10001];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==m&&s[i][j]) q++;
			if(j==m&&s[i][j]) l++;//不要用 else if ！！
		}
	}
	cout<<q<<" "<<l<<" "<<l+q;
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：0)

## 思路

送分题。将矩阵第 $m$ 行和第 $m$ 列分别求和（事实上就分别是 $m$ 的入度和出度），输出后再输出两个数相加的和。

## 代码

```cpp
#include<iostream>
using namespace std;
int a[1001][1001],n,m,ans1,ans2;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		ans1+=a[i][m];
		ans2+=a[m][i];
	}
	cout<<ans2<<" "<<ans1<<" "<<ans1+ans2;
	return 0;
}
```

---

## 作者：yu1128_AKIOI (赞：0)

# 思路
非常简单的邻接矩阵，累加第 $m$ 行所有的数和
第 $m$ 列所有的数即可。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1005][1005],n,m,ans,ans2;
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++) cin>>a[i][j];
    }
    for(int i=1;i<=n;i++) ans+=a[m][i];
    for(int i=1;i<=n;i++) ans2+=a[i][m];
    cout<<ans<<" "<<ans2<<" "<<ans+ans2;
}
```

---

## 作者：Hy13_xsm (赞：0)

## 题目分析

有 $n$ 个迷宫，第 $i$ 个迷宫若能直接到达第 $j$ 个迷宫，那么直接用数字 $1$ 表示，否则表示 $0$。问从 $m$ 号迷宫出发能直接到达的迷宫有多少个，有几个迷宫能直接到达 $m$ 号迷宫，以及这两个数据的和。

## 题目解决

这是一道基础的循环结构练习题。我们可以写一个嵌套循环来记录每两个迷宫之间的关系。我们着重看通向 $m$ 的和 $m$ 能够到达的，然后遇到一个能够通往的就把记录个数的变量增加 $1$。题目所说的两个数据分别存储。

然后这个问题就解决了。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, a, b;//a,b用来记录数据 
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= n;j++)
		{
			int x;
			scanf("%d", &x);
			if(i == m && x) a++;
			if(j == m && x) b++;//记录个数 
		}
	}
	cout << a << " " << b << " " <<a + b;
	return 0;
}
```

---


# 好奇心宝贝

## 题目背景

> 道路，由人亲手制造。
>
> 酒与面包，靠劳作取得。
>
> 幼小的新芽舒展叶片，
>
> 与成堆魔药中抵抗困意。
>
> 多一点，再多一点时间，
>
> 再看看书的下一页。

## 题目描述

给出一个 $n\times m$ 的矩阵，每个位置 $(i,j)$ 都是一个小写字母。

定义一条路径对应的字符串为路径上字符顺次连接所形成的字符串。

请找出两条从 $(1,1)$ 到 $(n,m)$ 的路径，要求只能向下或向右走，最小化两条路径对应字符串的最长公共前缀。



## 说明/提示

### 样例一解释

选择的两条路径分别为：

- $(1,1)\rightarrow (1,2)\rightarrow (1,3)\rightarrow (2,3)\rightarrow (3,3):$ `abexy`。

- $(1,1)\rightarrow (1,2)\rightarrow (2,2)\rightarrow (2,3)\rightarrow (3,3):$ `abcxy`。

它们的最长公共前缀为 $2$。可以证明没有更优的方案。

### 数据范围与约定

对于 $30\%$ 的数据，$1\le n,m \le 5$。

对于 $50\%$ 的数据，$1 \le n,m \le 50$。

对于另外 $20\%$ 的数据，矩阵随机生成且只含字母 `a,b`。

对于 $100\%$ 的数据，$1 \le n,m \le 2\times 10^3$，输入均为整数和小写字母。



## 样例 #1

### 输入

```
3 3
abe
bcx
exy```

### 输出

```
2```

# 题解

## 作者：Pursuewind (赞：9)

一开始我以为是 BFS（虽然好像可以用 BFS 做），但是发现我把这道题想复杂了。

**思路：**

写在前面：设一个点 $(i,j)$ 到点 $(1,1)$ 的距离是 $i+j-1$，即从 $(1,1)$ 出发到该点连成字符串的长度。

这道题解题的关键是从点 $(1,1)$ 走到点 $(i,j)$，不管怎样走，连成的字符串长度都是 $i+j-1$。

枚举答案 $ans$，从 $1$ 到 $n+m-1$，每一次找到一些点，使得这些点与 $(1,1)$ 的距离都为 $ans$。此时，若这些点上的字符有不相同，则答案为 $ans-1$，直接输出即可。

下面来证明一下：

如果有两个与 $(1,1)$ 距离相同的点，记为 $(x_1,y_1)$ 和 $(x_2,y_2)$，那么它们连成的字符串各是（$c$ 表示输入矩阵）：

$$s_1=c_{1,1}+\dots+c_{x_1,y_1}$$
$$s_2=c_{1,1}+\dots+c_{x_2,y_2}$$

上面的 $+$ 表示连接字符。

此时由于 $c_{x_1,y_1} \not = c_{x_2,y_2}$，而可以得知两条路径前面的 $ans-1$ 个字符都相等，所以答案为 $ans-1$。

为什么此时两条路径前面的 $ans-1$ 个字符都相等呢？因为如果前面的 $ans-1$ 个字符不相等，那么答案就会被更小的 $ans$ 代替。

于是就可以得到代码了，复杂度 $O(nm \log n)$（我赛时太着急了，用 `set` 维护了互不相同的字符，其实不用这样，可以将复杂度优化至 $O(nm)$ 的）：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e3 + 5;
char c[N][N];
set <char> s;
signed main(){
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i ++){
		for (int j = 1; j <= m; j ++){
			cin >> c[i][j];
		}
	}
	for (int d = 1; d < n + m; d ++){
		s.clear();
		for (int x = 1; x <= n; x ++){
			int y = d - x + 1;
          //此时(x,y)和(1,1)的距离是 d
			if (y > 0 && y <= m) s.insert(c[x][y]);
		}//x+y-1=d
		if (s.size() != 1){
			cout << d - 1 << "\n";
			return 0;
		}
	}
	cout << n + m - 1 << "\n"; //这里要注意，有可能整个矩阵的字符都相等，此时的答案为 n+m-1
	return 0;
}
```

---

## 作者：spfa_ (赞：7)

[P10270 好奇心宝贝](https://www.luogu.com.cn/problem/P10270)

只会写签到题。

### 题目分析

我们注意到，$(i,j)$ 格子上的字母只能出现在路径的第 $i+j-1$ 位。所以对于所有 $(i,j)$ 满足 $i+j=c$ 的（$c$ 为常数），若存在两个 $(i,j)$ 不相同，则最长公共前缀不能超过 $c-2$，所以枚举每个 $c$，判断即可。

code:

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef pair <int, int> pii;
typedef vector <int> vi;

template <typename T> inline void read(T& x) {
    x = 0; int f = 1;
	char c = getchar();
    while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar();
    while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar();
}

template <typename T> inline void write(T x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x/10);
	putchar('0'+x%10);
}

const int N = 4e3+5;
int n, m;
char c[N][N];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			cin >> c[i][j];
	for (int k = 1; k < n+m; ++k) {
		int x = 1, y = k;
		vector <char> v;
		while (x <= n) {
			if (y >= 1 && y <= m) v.pb(c[x][y]);
			++x, --y;
		}
		for (char i:v) if (i != v[0]) cout << k-1, exit(0); 
	}
	cout << n+m-1;
	return 0;
}
```

---

## 作者：Exp10re (赞：5)

给一种 $O(n^2)$ 做法。

## 解题思路

将矩阵按照斜线划分，例如：


$$\begin{aligned}
&abc\\
&bcd\\
&cfg\\
\end{aligned}$$

这样划分：

$$\begin{aligned}
&\color{red}a\color{orange}b\color{green}c\\
&\color{orange}b\color{green}c\color{purple}d\\
&\color{green}c\color{purple}f\color{black}g\\
\end{aligned}$$

第一斜线为 $a$，第二斜线为 $bb$，一种颜色代表一种斜线，以此类推。

注意到：

- 若前 $k$ 条斜线内均仅有一种字符，那么最长公共前缀一定大于等于 $k$，原因是无论哪一种走法，第 $i(i\in[1,k])$ 次“走”的时候字符一定相同。

- 若第 $k$ 条斜线内至少有两种字符，那么最长公共前缀一定小于 $k$，原因是一定存在两种走法，使得两种走法第 $k$ 次“走”的时候字符不相同。

综上所述，我们按顺序搜索每一条斜线，判断是否仅有一种字符，如果不是，输出斜线编号即可。

时间复杂度 $O(n^2)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MAXN=2010;
char s[MAXN][MAXN];
long long n,m;
int main()
{
	char t;
	long long i,j;
	scanf("%lld%lld",&n,&m);
	for(i=1;i<=n;i++)
	{
		scanf("\n%s",s[i]+1);
	}
	for(i=1;i<=m;i++)
	{
		t=s[1][i];
		for(j=i;j>=1&&i-j+1<=n;j--)
		{
			if(s[i-j+1][j]!=t)
			{
				printf("%lld",i-1);
				return 0;
			}
		}
	}
	for(i=2;i<=n;i++)
	{
		t=s[i][m];
		for(j=m;j>=1&&i+(m-j)<=n;j--)
		{
			if(s[i+(m-j)][j]!=t)
			{
				printf("%lld",i-2+m);
				return 0;
			}
		}
	}
	printf("%lld",n+m-1);
	return 0;
}
```

---

## 作者：HasNoName (赞：5)

### 思路
考虑使用 `DFS`。

1. 如果当前位置右边和下边字母不同，沿下右两条路径的公共前缀长度为当前走过的距离。如果这个距离小于当前答案距离，更新答案距离。

2. 如果当前走过的距离大于等于答案距离，不可能在更新答案。

3. 如果这个点之前走过，答案一定大于等于答案距离。

由于每个点最多走一次，所以时间复杂度为 $O(NM)$。

### AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int n,m,ans,vis[N][N];
char a[N][N];
bool ok(int x,int y)
{
	if(x<1||y<1||x>n||y>m)return 0;
	return 1;
}
void dfs(int x,int y)
{
	if(vis[x][y])return;//最优性减枝
	vis[x][y]=1;//标记为走过
	if(x+y-1>=ans)return;//最优性减枝
	if(ok(x+1,y)&&ok(x,y+1))//如果左右两边都有路
	{
		if(a[x+1][y]!=a[x][y+1])
		{
			ans=x+y-1;
			return;
		}
		dfs(x+1,y);
		dfs(x,y+1);
	}
	if(ok(x+1,y))dfs(x+1,y);//往下递归
	if(ok(x,y+1))dfs(x,y+1);//往上递归
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	ans=n+m-1;//如果走重复路径答案为 n+m-1
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
		}
	}
	dfs(1,1);
	cout<<ans<<'\n';
	return 0;
}
```

[AC 记录。](https://www.luogu.com.cn/record/152475231)

---

## 作者：No_Rest (赞：5)

## 思路

唯一 AC 了的题，居然还被卡了好久，菜。

发现我们可以将整个矩阵按第几步分为 $s_1, s_2, s_3, \cdots s_{n + m - 1}$ 共 $n + m - 1$ 个集合，其中 $s_i$ 是走了 $i$ 步后能走到的所有格子上的字符所组成的集合。

我们可以从前往后遍历所有集合，如果任何一个集合 $s_i$ 的大小 $> 1$（即里面有两种及以上的字符），那么我们就可以断定，一定有两条路径满足他们对应的字符串的最长公共前缀长度为 $i - 1$。这样，只要找到第一个满足大小 $> 1$ 的集合 $s_j$，就能知道答案是 $j - 1$。

时间复杂度 $\mathcal O(n^2 \log n)$。

注意如果没有找到任何一个集合的大小 $> 1$，那么矩阵内只有一种字符，这时要输出 $n + m - 1$。还有 set 的大小要开两倍，即 $4 \times 10^3$，因为一共有 $n + m - 1$ 步。~~其实这就是我被卡半个小时的原因。~~

## 代码

```cpp
#include<iostream>
#include<cstring>
#include<set>
#define ll long long
using namespace std;
const ll maxn = 4e3 + 5;
ll n, m;
char c;
set <char> s[maxn];
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(ll i = 1; i <= n; ++i)
		for(ll j = 1; j <= m; ++j) cin >> c, s[i + j - 1].insert(c);//将字符插入到相应的集合中
	for(ll i = 1; i <= n + m - 1; ++i)
		if(s[i].size() > 1){//如果集合内有 > 1 种字符
			cout << i - 1;//输出 i - 1
			return 0;
		}
	cout << n + m - 1;//特判，如果矩阵内只有一种字符，输出 n + m - 1
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：4)

有点骗。

考虑第 $i$ 个字符会是什么？

是距离 $(1,1)$ 曼哈顿距离为 $i-1$ 的字符。

如果这些字符均相等，则答案必然不能为 $i$。

扫一遍整个矩阵，同时用一个桶维护曼哈顿距离为 $i$ 的字符即可。

```cpp
il void Solve()
{
  int n,m;rd(n),rd(m);
  ve<string>a(n);
  for(auto&s:a) rd(s);
  ve<char>f(n+m);
  ve<int>g(n+m);
  g.back()=1;
  for(int i=0;i<n;++i) for(int j=0;j<m;++j) {
    if(!f[i+j]) f[i+j]=a[i][j];
    else if(f[i+j]!=a[i][j]) g[i+j]=1;
  }
  for(int i=0;i<n+m;++i) if(g[i]) return wrt(i);
  assert(0);
  return;
}
```

---

## 作者：MnZnOIer (赞：2)

还是想问，题目名字跟背景还有题目有什么关联吗？~~无厘头~~。

不扯了。

我们可以用一个数组 $c_i$ 表示第 $i$ 步的时候可以走到的字符数量，但是为了避免重复，需要去除重复的字符。

$\because$ 我们要求最短的前缀，$\therefore$ 只要第 $i$ 步有 2 种及以上的选择字符方案，绝对就不会选择相同的字符，而答案必然是 $i-1$。

见样例：
```
3 3
abe
bcx
exy
```
第一步可以走到的字符：a。

第二步可以走到的字符：b。

第三步可以走到的字符：e，c。

由此可见，第三步时可以不选择相同的字符，所以最短的公共前缀就是 2。

但是需要注意，如果没有一步可以到达字符数量 $\ge2$，就是全都是同一个字符，最终答案就是总步数。

通过分析，得出代码：
```cpp

#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, c[50005];
map <char, bool> v[50005];
char a;
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> n >> m;
	for (int i = 1; i <= n; ++ i)for (int j = 1; j <= m; ++ j)
	{
		cin >> a;
		if (! v[i + j - 1][a])
		{
			v[i + j - 1][a] = 1;
			++ c[i + j - 1];
		}
	}
	for (int i = 1; i <= n + m - 1; ++ i)if (c[i] >= 2)
	{
		cout << i - 1;
		return 0;
	}
	cout << n + m - 1;
	return 0;
}
```
时间复杂度为：$\Theta(nm)$。

---

## 作者：nyC20 (赞：2)

# 思路
位于同一斜线上的字符在路径上位于相同的点（如下图）：
![](https://cdn.luogu.com.cn/upload/image_hosting/hx2ykps8.png)

接下来只需要找到最后一条覆盖的字符都相同的斜线，输出它是第几条即可。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, m;
char s[2003][2003], ans;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=i;i-j+1<=n&&j;j--){
			if(s[i-j+1][j]!=s[1][i]){
				cout<<i-1;
				return 0;
			}
		}
	}
	for(int i=2;i<=n;i++){
		for(int j=m;i+(m-j)<=n&&j;j--){
			if(s[i+(m-j)][j]!=s[i][m]){
				cout<<i-2+m;
				return 0;
			}
		}
	}
	cout<<n+m-1;
	return 0;
}
```

---

## 作者：zhuxiangrui_2010 (赞：2)

# P10270 好奇心宝贝 题解
## 题意
给出一个 $n \times m$ 的矩阵，定义一条路径对应的字符串为路径上字符顺次连接所形成的字符串，只能**向下**或**向右**走，求两条从 $(1,1)$ 到 $(n,m)$ 的路径，使这两条路径对应字符串的最长公共前缀最短。
## 思路
~~其实我一开始只是输出了1。~~

什么是最长公共前缀？[点这里。](https://answer.baidu.com/answer/land?params=MHjRGzpokHDEXHZQjx83Em%2BTTGx7Wq5XnzMVJfYcL9kbXdEeSAdNyHLmSFVEFfatiWunxfAkRnuHlWpsomcQ2GhaDF41UqfgUQnon4sHAcWtEVigbOd2romrpSrya8Ooj%2Fem5%2FIS%2BXpisqamhKa4fGLPpRnyddNEgbaM6MjNqGvUXvJD7p8fL1sAvHc5UVfQ5wyqjcEvNi%2Biz%2FZRJxHeoQ%3D%3D&from=dqa&lid=d8e782280039a37d&word=%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80)

由于只能向下或向右走，我们可以通过枚举得出到每个格子的步数（同一个格不会有多组不同的步数）。如：![](https://cdn.luogu.com.cn/upload/image_hosting/0tk73voe.png)
所以我们的工作就变成了从第 $1$ 步开判断步数相同的格中的字母是否相同。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t=1;
char a[2010][2010];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
    for(int i=2;i<=n+m-1;i++){
        int x=max(i-n+1,1),y=min(i,n);
        char c=a[x][y];
        while(x<=n&&y>0){//枚举步数相同的格，判断其中的字母是否相同
            if(a[x][y]!=c){
                cout<<i-1;
                return 0;
            }
            x++;
            y--;
        }
    }
    cout<<n+m-1;//全部相同，输出长度
	return 0; 
}
```

---

## 作者：zhanghy123 (赞：2)

# lzqy_ の Strings Round P10270 好奇心宝贝 题解
### 思路
由题意知，要从一个 $n \times m$ 字符矩阵的 $(0,0)$ 处走到 $(n,m)$ 处，选择两条路线，使它们的公共前缀长度最小。

从 $(1,1)$ 处走到 $(n,m)$ 处会经过 $m+n-1$ 个点（算上起点）。可以算出从起点走到每个点所需的步数。

显然，点 $(a,b)$ 走到点 $(c,d)$ （假设 $a<c$ ，$b<d$ ）所需的步数为 $(b-a)+(d-c)$ 。从起点到任意点 $(x,y)$ 处所走的步数为 $x+y-2$ 。

每走一步，即把这一点上的字符存到一个字符串内。那么从起点开始，要走 $p$ 步到达的位置，到这一点所走过字符串的长度为 $p+1$ ，字符串在这里的下标也是 $p+1$ （假设从 $1$ 开始）。

如此，当需要同样步数的两个不同点所对应的字符不同时，所走过的两个字符串在此下标上的字符也会不同。

那么，我们只需要知道在一个最小的步数 $k$ 下，有没有两个点所代表的字符不同。若有，那么两条路径所走过的字符串在这一下标下的字符就会开始出现不同，两条路径所走过字符串的公共前缀也会到此为止。此时，它们的公共前缀长为 $k$（算上起点，不算当前点）。

### AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dis[2001][2001];
char a[2001][2001];
vector <char>p[4001]; //不同步数下可到达的各个点对应的字符
int main()
{
	cin>>n>>m;
	for(int i=0; i<n; i++)
		for(int j=0 ;j<m; j++){
			cin>>a[i][j];
			dis[i][j]=i+j;//步数，因为这里从0开始，所以不用-2
			p[dis[i][j]].push_back(a[i][j]);//将需要dis[i][j]步到达的点存入vector数组中
		}
	for(int i=0; i<n+m-2; i++){//枚举步数
		for(int j=0; j<p[i].size()-1; j++)//要把一个点和下一个比，防止越界
			if(p[i][j]!=p[i][j+1])//相同步数可到达不同点所表示的字符出现不同时，前缀长度就是步数
			{
				cout<<i;
				return 0; 
			}
	}
	cout<<n+m-1;//防止没找到
	return 0;
}

```

---

## 作者：lilong (赞：2)

思路十分简单，但需要一定的转化，好题。

记 $s_{i,j}$ 表示第 $i$ 行的第 $j$ 个字符。考虑任意一点 $(i,j)$，假设在此之前没有经过字母不同的路径，若 $s_{i,j+1}$ 和 $s_{i+1,j}$ 不同，则可以分别往这两个方向走，最长公共前缀也就固定下来了，长度为 $i+j-1$。

于是我们就可以暴力枚举每个点并判断是否可以在此分支，若可以则更新答案。这样做对于在 $(i,j)$ 之前不同的路径也可以更新，保证了正确性。时间复杂度 $O(nm)$。

代码如下：

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int n,m,a[4001][4001],ans;
string s;

int main()
{
	cin >> n >> m; 
	for( int i = 1 ; i <= n ; i ++ )
	{
		cin >> s;
		for( int j = 0 ; j < m ; j ++ )
			a[i][j + 1] = s[j] - 'a';
	}
	ans = n + m - 1;
	for( int i = 1 ; i < n ; i ++ )
		for( int j = 1 ; j < m ; j ++ )
			if( a[i][j + 1] != a[i + 1][j] )
				ans = min( ans , i + j - 1 );
	cout << ans;
	return 0; 
} 
```

---

## 作者：Shadow_T (赞：2)

### 题目分析

考虑 bfs 这个矩阵，每次向下或者向右移动。对于如果第一次碰到字母不相同，我们就可以直接输出现在遍历的长度。因为我们是 bfs，所以一开始找到的就是最佳答案。

使用 dfs 会 TLE，[Link](https://www.luogu.com.cn/record/152650720)。所以采用 bfs。

复杂度 $\mathcal {O}(nm)$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e3+10;
string s[maxn];
int Min=1e9,n,m;
void dfs(int x,int y,int f)
{
	if(f>=Min) return;
	if(x+1<n&&y+1<m)
	if(s[x][y+1]!=s[x+1][y])
	{
		Min=min(Min,f);
		return;
	}
	if(y+1<m)
	dfs(x,y+1,f+1);
	if(x+1<n)
	dfs(x+1,y,f+1);
}
signed main()
{
	cin>>n>>m;
	Min=n+m-1;
	for(int i=0;i<n;i++)
	cin>>s[i];
	dfs(0,0,1);
	cout<<Min;
}
```

---

## 作者：Mu_shao (赞：1)

### 想法
按照题目的意思，因为每步只可以向右或向下，可以手搓出以下的关系。(数字表示第几步可以走到的位置)
```cpp
0    1     2    3  ... m-1
1    2     3    4  ... m
2    3     4    5  ... m+1
3    4     5    6  ... m+2
...  ...  ...  ... ... ...
n-1  n    n+1  n+2 ... n+m-1

```
那就可以求出每一步时，经过的所有不同字符的数量，当出现字符数大于一的时候就可以直接输出。

当然要特殊判断，如果所有的字符数都是一时输出 $n-m+1$。
### 代码
```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 4e3 + 10;
int n, m;
set <char> str[maxn];

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			char c;
			cin >> c;
			str[i+j-1].insert(c);
		}
	}
	for (int i = 1; i <= n+m-1; i++) {
		if (str[i].size() > 1) {
			printf("%d", i-1);
			return 0;
		}
	}
	printf("%d", n+m-1);
	return 0;
}

```

---

## 作者：zibenlun (赞：1)

# 思路
首先我们将整个矩形按照与起点的距离分成不同的层，我们可以发现只要这一层有两个以上的不同的字母，那么我们在走到这一层的时候一定可以使这一位不同，所以我们就只需要找到最小的有多于一种字母的层数就行了。时间复杂度 $O(n^2)$。

# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
#define int_128 __int128
#define lowbit(x) (x&(-x))
using namespace std;
set<int> s[4005];
int n,m;
char a[2005][2005];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			s[i-1+j-1+1].insert(a[i][j]);
		}
	}
	for(int i=1;i<=n+m-1;i++){
		if(s[i].size()>1){
			cout<<i-1;
			return 0;
		}
	}
	cout<<n+m-1;
	return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P10270 题目](https://www.luogu.com.cn/problem/P10270)

### 解题思路
不难发现，从 $(1,1)$ 到 $(n,m)$ 所形成的字符串长度为 $n+m-1$，第 $1$ 个字符是 $(1,1)$ 上的字符，第 $2$ 个是 $(1,2)$ 或 $(2,1)$ 上的字符，第 $3$ 个是 $(1,3)$ 或 $(2,2)$ 或 $(3,1)$ 上的字符，以此类推，第 $n+m-1$ 个是 $(n,m)$ 上的字符。\
![](https://cdn.luogu.com.cn/upload/image_hosting/iovq2df9.png?x-oss-process=image/resize,m_lfit,h_325,w_325)

我们需要依次判断所形成的字符串的第 $i$ 个字符是否有多种可能，若有，则输出并结束程序，否则答案将计数器加 $1$ 并继续判断。

如上图，所形成的字符串中没有一个字符有多种可能，无论怎么走都是 $\texttt {abcdefgh}$，若将 $(3,3)$ 上的字符改为 $\text f$，所那么形成的字符串中的第 $5$ 个字符为 $\text e$ 或 $\text f$，有多种可能，答案为 $4$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
char ch[2001][2001];
signed main()
{
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			cin>>ch[i][j];
	}
	int s=0;
	for(int i=1;i<=m;i++)
	{
		char sh;
		int pd=0;
		for(int j=1;j<=min(i,n);j++)
		{
			if(j==1)
				sh=ch[1][i];
			else
			{
				if(ch[j][i-j+1]!=sh)
				{
					pd=1;
					break;
				}
			}
		}
		if(pd==1)
		{
			cout<<s;
			return 0;
		}
		s++;
	}
	for(int i=2;i<=n;i++)
	{
		char sh;
		int pd=0;
		for(int j=1;j<=min(n-i+1,m);j++)
		{
			if(j==1)
				sh=ch[i][m];
			else
			{
				if(ch[i+j-1][m-j+1]!=sh)
				{
					pd=1;
					break;
				}
			}
		}
		if(pd==1)
		{
			cout<<s;
			return 0;
		}
		s++;
	}
	cout<<s;
    return 0;
}
```

---

## 作者：hrdgy (赞：1)

# P10270题解

## 题目分析

有一个重点在于"公共前缀",即从头开始比较只要有不同的字符，后面就算出现相同的字符也不计入前缀。

## 主要思路
将两条路线形成的字符串设为 $s$ 与 $t$

也就是说我们要想尽一切办法尽早让 $s[i]$ 与 $t[i]$ 不相同，不相同很好实现，所以我们只需要判断什么时候一定会相同即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4r370nj.png)

图中每一条**颜色的线**包括的**格子**上(画的不太整齐请见谅)如果字母都**相同**，那么这里无论如何 $t[i]$ 与 $s[i]$ 一定会**相同**。可以看做一个包围圈，两条路线走到这里无论怎么走都会被拦截。
 
 很容易可以得出每一条线包含的格子的**行数列数**相加为**定值**。
 
 我们设这个定值为 $k$ ,可以得出 $k$ 所对应的线的每一个格子下标为 $[i][k-i]$
 
 只要出现 $s[i]$ 与 $t[i]$ 可以不相同（即不符合上文规律）就有可以有逃出包围圈的方案，往后的前缀也不可能再相同了，此时直接输出答案。
 
 ## 代码实现
 ```cpp
#include <bits/stdc++.h>
#define ll  long long

using namespace std;
char a[2005][2005];

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)cin>>a[i][j];
	}//输入数据，记得关注数据范围~
	for(int i=3;i<=n+m;i++){
   //枚举这个定值[2~n+m],由于定值为2时下标只能为(1,1),所以跳过2
		char c=' ';
		for(int j=1;j<i;j++){
			if(i-j>m||j>n)continue;//防止出界
			if(c==' ')c=a[j][i-j];
			else if(c!=a[j][i-j]){
				cout<<i-2<<endl;//不相同时直接输出，i-2可以自己通过模拟计算过程推出
				return 0;
			}
		}
	}
	cout<<n+m-1;//都符合情况就直接输出(1,1)到(n,m)的最小距离
	return 0;
}
```

---

## 作者：Oracynx (赞：0)

## P10270 好奇心宝贝 题解

### 思路分析

由于本题只能向下和向右走，所以每个格子经过的时间肯定是确定的。

对于 $n = 3, m = 5$，下面的数字表示这个格子是第几个被经过的。

```plain
12345
23456
34567
```

显然，如果每一个反对斜线的字符不相同，那么这一位肯定有方法使其不匹配，反之肯定没有方法。

所以本题转换为：给你一个 $n \times m$ 的字符矩阵，判断第几个从左下到右上的斜线的字符不完全相同。

### 代码实现

注意第二个循环，很容易忘记。

```cpp
#include <cstdio>
constexpr int MaxN = 2e3 + 5;
int n, m;
char p[MaxN][MaxN];
bool check(int x, int y)
{
    if (y == 1 || x == n)
    {
        return true;
    }
    return (p[x][y] == p[x + 1][y - 1]) && check(x + 1, y - 1);
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%s", p[i] + 1);
    }
    int answer = 0;
    for (int i = 1; i <= m; i++)
    {
        if (!check(1, i))
        {
            printf("%d\n", answer);
            return 0;
        }
        answer++;
    }
    for (int i = 2; i <= n; i++)
    {

        if (!check(i, m))
        {
            printf("%d\n", answer);
            return 0;
        }
        answer++;
    }
    printf("%d\n", n + m - 1);
    return 0;
}
```

---

## 作者：Kle1N (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10270)

---
由于只能向下或向右走，所以其实无论走了几步，两个点都在同一条斜线（东北西南走向）上。或者看这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ytn33bjc.png)

可以发现，第 $0$ 步时都在红色格内；第 $1$ 步无论怎么走，两边都会停在橙色格内；第 $2$ 步后也都一定会落在黄色格内...

所以容易发现，若从左到右扫描每条斜线，如果某一斜线上字符都相同，那么走到这一步形成的所有字符串肯定都相同，直到某条斜线上有字符不相同。那么此时前面扫描过的斜线数就是两条路的最长公共前缀。不理解可以按照样例自行模拟。

实际操作中，注意到在从左往右第 $i$ 条斜线上的点的坐标都满足横纵坐标之和等于 $n+1$，根据这点我们可以开一个桶和一个记录答案的变量 $ans$ 一边输入一边统计，从而减少内存使用，~~还能少写一个循环~~。

除此之外还要判断所有路径形成的字符串都相等的情况，在上面这种方法中只需给 $ans$ 初始值赋为 $n+m-1$ 即可。

具体见代码吧：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,v[4001],ans;
int main(){
	cin>>n>>m;
	ans=n+m-1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char t;
			cin>>t;
			if(v[i+j]!=0 && v[i+j]!=t){
				ans=min(i+j-2,ans);
			}
			v[i+j]=t;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

这篇题解参考了一下 @wo_hen_la 的代码，感谢大佬！~~（赛时拼命调记忆化只得 $80$ 分）~~

设答案为 $A$，取值为 $10^9$，每个点的坐标为 $(x,y)$。  

我们考虑枚举每个点，每次判断点向下和向右走到的字母是否相同，如果不相同，那么将答案更新为 $\min(A,x+y-1)$。容易证明，当在只能向右和向下走的情况下，这个公共前缀的长度为 $x+y-1$。

如果 $A$ 此时仍然为 $10^9$，这就说明答案没有更新，也就意味着矩阵里所有字母都相同，此时只要输出 $n+m-1$。

否则输出 $A$。

接下来证明这个算法的正确性。

如果这时已经到了最优的点，统计好答案后，再到其他点时，如果其他点扩展到了这个点，那么答案就不是最优的。

进一步的，在枚举点时遇到 $(x+1,y)$ 和 $(x,y+1)$ 不相等时，不是在最优点就是在其他更远的点，此时尽管判断错误也不会影响答案。

所以这个算法是正确的，代码如下：

```cpp
#include <iostream>
using namespace std;
char map[2001][2001];
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> map[i][j];
		}
	}
	int ans = 1000000000;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (i + 1 > n || j + 1 > n) {
				continue;
			}
			if (map[i + 1][j] != map[i][j + 1]) {
				ans = min(ans, i + j - 1);
			}
		}
	}
	if (ans == 1000000000) {
		cout << n + m - 1;
	}
	else cout << ans;
}

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10270)

## 解题思路
因为题目说是只能向下或向右走，那么假如这个位置是 $(i,j)$，那它走的就是第 $i+j-1$ 步。题目还说最小化两条路径对应字符串的最长公共前缀，也就是求出：在这所有路径里，他们的公共前缀长度最长是多少？

那我们就把第 $i+j-1$ 步的所有可能的字母记录下来，再统计这一步的字母种数。统计完以后，从第一步开始寻找有没有不同字母，如果有，就说明当前的前缀不是公共的，输出他的前一个。否则，说明所有路径相同，输出 $n+m-1$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool a[2010][36];
int sum[2010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			char c;
			cin>>c;
			if(!a[i+j-1][c-'a'])
			{
				a[i+j-1][c-'a']=1;
				sum[i+j-1]++;
			}
		}
	for(int i=1;i<=n+m-1;i++)
		if(sum[i]>=2)
		{
			cout<<i-1;
			return 0;
		}
	cout<<n+m-1;
	return 0;
}

```

但是，它为什么运行错误了呢？

原来，数组最大值为 $n+m-1$，而 $n,m \le 2 \times 10^3$ 啊！

好了，废话不多说，上代码：

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool a[4010][36];
int sum[4010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			char c;
			cin>>c;
			if(!a[i+j-1][c-'a'])
			{
				a[i+j-1][c-'a']=1;
				sum[i+j-1]++;
			}
		}
	for(int i=1;i<=n+m-1;i++)
		if(sum[i]>=2)
		{
			cout<<i-1;
			return 0;
		}
	cout<<n+m-1;
	return 0;
}

```

---

## 作者：sbno333 (赞：0)

这道题还是很水的，很适合初学者研究。

首先答案至少为 $1$，因为必然经过入口。

假设答案为 $k$，则所有走 $k$ 步的路径的字符串都相同。

我们假设 $k-1$ 成立，则 $k$ 成立当且仅当 $k$ 步能到的地方字母相同。

考虑 $k$ 步能到的地方，由于只能向下或向右，就是每次让后坐标加一或纵坐标加一，此时，有性质每走一步横坐标与纵坐标的和加一。第 $1$ 步和为 $2$，第 $i$ 步显然为 $i+1$。

因此我们从 $2$ 枚举到 $n+m-1$，如果出现同和且不同字符的，输出当前答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
char s[2009][2009];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	for(int x=2;x<=n+m;x++){//枚举和
		bool k;
		k=0;
		for(int i=max(x-m,1ll);i<=n&&x-i>=1;i++){//枚举这个和下的所有横坐标（横坐标确定，纵坐标确定）
			if(i!=max(x-m,1ll)){//如果和上一个相同就停止（第一个没有上一个，不记录）
				if(s[i][x-i]!=s[i-1][x-i+1]){
					k=1;
					break;
				}
			}
		}
		if(k){
			cout<<x-2<<endl;//输出答案，和为 x，则第 x 不同，最后一个相同为 x-1，答案为和减一，答案为 x-2。
			return 0;
		}
	}
	cout<<n+m-1; //都相同输出答案，否则 90（别问我怎么知道的）
	return 0;
}
```

---

## 作者：haokee (赞：0)

## 题目大意

给定一个 $n\times m$ 的矩阵，要选择两条 $(1,1)$ 到 $(n,m)$ 的路径，要求每次都只能往下面或者右边一个格子走。现在你需要求出这两条路径的最小前缀。

## 思路

首先，题目告诉了我们每一个格子只能往下面或者右边走，因此路径的长度一定为 $n+m-1$，也可以将矩阵斜着切分为 $n+m-1$ 个格子。既然是最大前缀最小，那么只需要有斜排有不一样的元素就可以了，这样子我们就可以专门走不一样的格子，使得答案尽量小。

至于如何存储每一斜排的所有元素，可以使用 STL 当中的 unordered_set 实现。注意需要特殊判断矩阵当中全是同一个字符的情况，其实循环到 $n+m$ 就行了。时间复杂度 $\mathcal O(n\times m)$。

## 代码

```cpp
#include <iostream>
#include <unordered_set>

using namespace std;

const int kMaxN = 2e3 + 5;

int n, m;
char c;
unordered_set<char> s[kMaxN * kMaxN];

int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> c, s[i + j - 1].insert(c);
    }
  }
  for (int i = 1; i <= n + m; i++) {
    if (s[i].size() != 1) {
      return cout << i - 1, 0;
    }
  }
  return 0;
}
```

---

## 作者：zhu_wen (赞：0)

# P10270 好奇心宝贝
## 题意
本题就是让你找到从 $\left ( 1,1 \right ) $ 到 $\left ( n,m \right ) $ 的最短公共子序列。
## 解法
我们可以换个思路，可以知道，他只让我们向下或向右走，那么我们可以斜着判断，找到与每个斜着第一个的字母不同的位置，将它标记一下。

从 $2$ 遍历到 $n+m $，找到第一个被标记过的位置，视为断点，就将它减去 $2$ 在输出，因为要减去第一个以及最后一个，如果全部都符合——即没有断点，那么就输出 $n+m-1$。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define ls (rt << 1)
#define rs (rt << 1 | 1)
#define lowbit(x) x & -x
#define fup(x, l, r) for (int x = (l), eNd = (r); x <= eNd; ++ x )
#define fdw(x, r, l) for (int x = (r), eNd = (l); x >= eNd; -- x )
typedef long long ll;
typedef unsigned long long LL;
typedef pair<int, int> PII;

struct fastread {
	template <typename T>
	fastread& operator >>(T& x) {
		x = 0; bool flg = false; char c = getchar();
		while (c < '0' || c > '9') flg |= (c == '-'), c = getchar();
		while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
		if (flg) x = -x; return *this;
	}
	template <typename T>
	fastread& operator >>(vector<T>& x) {
		for (auto it = x.begin(); it != x.end(); ++ it ) (*this) >> *it;
		return *this;
	}
}fin;

struct fastwrite {
	template <typename T>
	fastwrite& operator <<(T x) {
		if (x < 0) x = -x, putchar('-');
		static int buf[35]; int top = 0;
		do buf[top ++ ] = x % 10, x /= 10; while (x);
		while (top) putchar(buf[ -- top] + '0');
		return *this;
	}
	fastwrite& operator <<(char x) {
		putchar(x); return *this;
	}
	template <typename T>
	fastwrite& operator <<(vector<T> x) {
		for (auto it = x.begin(); it != x.end(); ++ it ) (*this) << *it, putchar(' ');
		putchar('\n');
		return *this;
	}
}fout;

const int N = 2e3 + 10;
const int P = 998244353;

int n, m;
char a[N][N];
char vis[N << 1];
int cnt[N << 1];
 
main(void)
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	fup(i, 1, n)
	{
		fup(j, 1, m)
		{
			cin >> a[i][j]; 
		}
	}
	fup(i, 1, n)
	{
		fup(j, 1, m)
		{
			if(i == 1) vis[i + j] = a[i][j];
			else if(j == m)	vis[i + j] = a[i][j];
		}
	}
	fup(i, 1, n)
	{
		fup(j, 1, m)
		{
			if(vis[i + j] != a[i][j])
			{
				cnt[i + j] = 1;
			}
		}
	}
	int res = 0;
	fup(i, 2, n + m)
	{
		if(cnt[i])
		{
			res = i;
			break;
		}
	}
	fout << (res == 0 ? n + m - 1 : res - 2) << '\n';
	return 0;
}


```

---

## 作者：Whiking (赞：0)

我们可以考虑把走几步可以走到过的字母的集合处理出来。（设在 $(1,1)$ 时为第一步）

对于样例，$S_1=\{a\},S_2=\{b\},S_3=\{c,e\},S_4=\{x\},S_5=\{y\}$。

我们从 $1$ 开始枚举，找到第一个 $i$ 使得 $|S_i|>1$，$i-1$ 就是答案。

为什么呢？因为 $1$ 到 $i-1$ 所对应的集合只有一个字母，说明前面都是无论怎么走这两条路径都要经过重复的 $i-1$ 个字母，lcp 的长度就是 $i-1$；当走到第 $i$ 步时，可以经过不同的字母，只要这一位不同 lcp 就不会改变了。

最后，如果整个矩阵只有一个字母组成，答案就是 $m+n-1$。

具体实现很简单，复杂度 $O(nm)$。

```cpp
#include <bits/stdc++.h>
//#define int long long
const int N= 1e4+ 10, M= 2e5+ 10, inf= 1e9+ 10;
inline int read() {
    int x= 0, f= 1;
    char ch= getchar();
    for (; ! isdigit(ch); ch= getchar()) if (ch== '-') f= -1;
    for (; isdigit(ch); ch= getchar()) x= (x<< 3)+ (x<< 1)+ (ch^ 48);
    return x*= f;
}
using namespace std;
int n, m; char c[N];
int vis[N][150], cnt[N];
signed main() {
	n= read(), m= read();
	for ( int i= 1; i<= n; i++) {
		scanf("%s", c+ 1);
		for ( int j= 1; j<= m; j++) if (! vis[i+ j- 1][(int)c[j]]++) cnt[i+ j- 1]++;
	}
	for ( int i= 1; i<= n+ m- 1; i++) if (cnt[i]> 1) cout<<i- 1, exit(0);
	cout<<n+ m- 1;
}
```

---


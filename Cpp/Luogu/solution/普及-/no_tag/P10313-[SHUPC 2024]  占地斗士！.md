# [SHUPC 2024]  占地斗士！

## 题目背景

一个名为“占地斗士”的卡牌小游戏深深的吸引了小 A
。目前小 A 正在进行卡牌摆放练习，但是她并不熟练，于是想要请教擅长编程的你来解决这个问题。

## 题目描述

游戏的具体规则为：游戏在一个 $n\times m$ 的方格矩阵中进行，`.` 代表这个格子可以被放置，`#` 代表这个格子不能被放置。你手中有 $4$ 种形状各异的卡牌，每种卡牌均**只有一张**。你需要将卡牌放置在棋盘中，卡牌可以放置在任意位置，但是卡牌占领的格子不能重叠，也不能放在不能放置的格子上。目标是要使得卡牌占领的格子数量尽可能多。
小 A 现在想知道，在最优的摆放策略下，最多可以占领多少个格子？
![](https://cdn.luogu.com.cn/upload/image_hosting/l9d77whu.png)

## 说明/提示

样例解释：

样例一最优摆放方法如下，使用第一种和第二种卡牌，最多可以占领 $9$ 个格子。

![img1](https://cdn.luogu.com.cn/upload/image_hosting/zt41mdit.png)

样例二最优摆放方法如下，使用第二种卡牌，最多可以占领 $4$ 个格子，红色代表这个格子不能放置卡牌。

![img2](https://cdn.luogu.com.cn/upload/image_hosting/352061x2.png)

## 样例 #1

### 输入

```
3 3
...
...
...```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3
..#
.#.
#..```

### 输出

```
4```

# 题解

## 作者：zhengpie (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P10313)

### 1.思路

看到这道题，我的第一反应就是**搜索题**，但是是深搜还是广搜呢？

答案是**深搜**。（虽然一开始我一直再想广搜）如果用广搜的话，对于下面这组数据就会超时（当然是不加很牛的剪枝的）：
```cpp
//样例输入#3
10 10
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
//样例输出#3
18
```
现在开始讲如何深搜。首先我们考虑每个图形**左上角**的点，设他为 $a_{i,j}$。以第一个图形为例(这里图形的顺序以题目中给的四张图为准)，如果想要摆放上第一个图形，就必须让下列条件成立：

```cpp
if(a[i][j] == '.' && a[i][j + 2] == '.' && a[i + 2][j] == '.' && a[i + 1][j + 1] == '.' && a[i + 2][j + 2] == '.')
```

同样的，下面分别给出让第二，三，四个图形可以摆放的条件：

```cpp
//2号图
if(a[i][j + 1] == '.' && a[1 + i][j] == '.' && a[i + 2][j + 1] == '.' && a[i + 1][j + 2] == '.')
//3号图
if(a[i][j] == '.' && a[i][j + 1] == '.' && a[i + 1][j] == '.' && a[i + 1][j + 1] == '.' )
//4号图
if(a[i][j + 1] == '.' && a[1 + i][j] == '.' && a[i + 2][j + 1] == '.' && a[i + 1][j + 2] == '.' && a[i + 1][j + 1] == '.')
```

### 2.细节

首先注意到 DFS 里**不可以传入** $a_{i,j}$ 这样的**二维数组**，所以我们定义一个**结构体** ```ground``` 来记录：

```cpp
struct ground
{
	char a[15][15];
	int cnt;//记录当前占领的格子的个数
	bool c1,c2,c3,c4;//因为题目说每个图形都只能用一次，所以用他们来记录这些东西用没用过。
}g;//g记录初始地图
```

然后，不难写出 DFS：

```cpp
void dfs(ground u)
{
	if(u.cnt >= maxn) maxn = u.cnt;//更新maxn
	for(int i = 1;i <= n - 2;i++)//注意是n - 2，因为是3 * 3 的格子，而i，j表示的是左上角的点，所以这两重循环只能处理1,2,4号图。
		for(int j = 1;j <= m - 2;j++)
		{
			if(u.a[i][j] == '.' && u.a[i][j + 2] == '.' && u.a[i + 2][j] == '.' && u.a[i + 1][j + 1] == '.' && u.a[i + 2][j + 2] == '.' && u.c1 != 1)//1号图
			{
				u.a[i][j] = u.a[i][j + 2] = u.a[i + 2][j] = u.a[i + 1][j + 1] = u.a[2 + i][j + 2] = '#';
				u.c1 = 1;//记得标记！
				u.cnt += 5;
				dfs(u);
				u.c1 = 0;//类似回溯的技巧，因为后面的图可能还要用这个u，所以得给后面的用初始数据
				u.cnt -= 5;
				u.a[i][j] = u.a[i][j + 2] = u.a[i + 2][j] = u.a[i + 1][j + 1] = u.a[2 + i][j + 2] = '.';
			}
			if(u.a[i][j + 1] == '.' && u.a[1 + i][j] == '.' && u.a[i + 2][j + 1] == '.' && u.a[i + 1][j + 2] == '.' && u.c2 != 1)//2号图
			{
				u.a[i][j + 1] = '#';u.a[1 + i][j] = '#';u.a[i + 2][j + 1] = '#';u.a[i + 1][j + 2] = '#';
				u.cnt += 4;//复制1号图的代码时，记得2号图只占了4个格子！
				u.c2 = 1;
				dfs(u);
				u.c2 = 0;//同1号图
				u.cnt -= 4;
				u.a[i][j + 1] = '.';u.a[1 + i][j] = '.';u.a[i + 2][j + 1] = '.';u.a[i + 1][j + 2] = '.';
			}
			if(u.a[i][j + 1] == '.' && u.a[1 + i][j] == '.' && u.a[i + 2][j + 1] == '.' && u.a[i + 1][j + 2] == '.' && u.a[i + 1][j + 1] == '.' && u.c4 != 1)//注意是4号图,上面已经讲过了这两重循环不处理3号图
			{
				u.a[i][j + 1] = '#';u.a[1 + i][j] = '#';u.a[i + 2][j + 1] = '#';u.a[i + 1][j + 2] = '#';u.a[i + 1][j + 1] = '#';
				u.c4 = 1;
				u.cnt += 5;
				dfs(u);
				u.cnt -= 5;//同1号图
				u.c4 = 0;
				u.a[i][j + 1] = '.';u.a[1 + i][j] = '.';u.a[i + 2][j + 1] = '.';u.a[i + 1][j + 2] = '.';u.a[i + 1][j + 1] = '.';
			}
		}
	for(int i = 1;i <= n - 1;i++)//这两重循环处理三号图，因为3号图是2 * 2的，所以i枚举到n - 1
		for(int j = 1;j <= m - 1;j++)//同理，枚举到m - 1
		{
			if(u.a[i][j] == '.' && u.a[i][j + 1] == '.' && u.a[i + 1][j] == '.' && u.a[i + 1][j + 1] == '.' && u.c3 != 1)
			{
				u.a[i][j] = '#';u.a[i][j + 1] = '#';u.a[i + 1][j] = '#';u.a[i + 1][j + 1] = '#';
				u.cnt += 4;
				u.c3 = 1;
				dfs(u);
				u.c3 = 0;//同一号图
				u.cnt -= 4;
				u.a[i][j] = '.';u.a[i][j + 1] = '.';u.a[i + 1][j] = '.';u.a[i + 1][j + 1] = '.';
			}
		}
	return;//养成return的好习惯
}
```

然后，放到上面，看一看我们的样例输入输出 $3$，把他复制下来，发现超时了！怎么**剪枝**？

观察题目，可以知道，由于每个图都只能用一次，所以**最大**就只能输出 $(5 + 4 + 5 + 4 = )18$，也就是说，当 ```maxn``` 达到 $18$ 时，就**直接跳出函数**。所以，我们在 DFS 中补上下面的代码：

```cpp
if(maxn == 18) 
{
	cout<<18;
	exit(0);//相当于主函数中的return 0，但如果在自定义函数中return 0，无法达到结束程序的效果，所以使用exit()函数
}
```

### 3.完整代码

在给完整代码之前，先再附上一个东西：样例输入输出 $4$！

```cpp
//样例输入#4
9 7
.#.#...
..#....
..##.#.
##.#...
......#
##.#..#
###.#..
...##..
.#.#...
//样例输出#4
14
```

最后，附上完整代码，请放心食用！

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct ground
{
	char a[15][15];
	int cnt;//记录当前占领的格子的个数
	bool c1,c2,c3,c4;//因为题目说每个图形都只能用一次，所以用他们来记录这些东西用没用过。
}g;//g记录初始地图
int n,m,maxn;
void dfs(ground u)
{
	if(maxn == 18) 
	{
		cout<<18;
		exit(0);//相当于主函数中的return 0，但如果在自定义函数中return 0，无法达到结束程序的效果，所以使用exit()函数
	}
  	if(u.cnt >= maxn) maxn = u.cnt;//更新maxn
	for(int i = 1;i <= n - 2;i++)//注意是n - 2，因为是3 * 3 的格子，而i，j表示的是左上角的点，所以这两重循环只能处理1,2,4号图。
		for(int j = 1;j <= m - 2;j++)
		{
			if(u.a[i][j] == '.' && u.a[i][j + 2] == '.' && u.a[i + 2][j] == '.' && u.a[i + 1][j + 1] == '.' && u.a[i + 2][j + 2] == '.' && u.c1 != 1)//1号图
			{
				u.a[i][j] = u.a[i][j + 2] = u.a[i + 2][j] = u.a[i + 1][j + 1] = u.a[2 + i][j + 2] = '#';
				u.c1 = 1;//记得标记！
				u.cnt += 5;
				dfs(u);
				u.c1 = 0;//类似回溯的技巧，因为后面的图可能还要用这个u，所以得给后面的用初始数据
				u.cnt -= 5;
				u.a[i][j] = u.a[i][j + 2] = u.a[i + 2][j] = u.a[i + 1][j + 1] = u.a[2 + i][j + 2] = '.';
			}
			if(u.a[i][j + 1] == '.' && u.a[1 + i][j] == '.' && u.a[i + 2][j + 1] == '.' && u.a[i + 1][j + 2] == '.' && u.c2 != 1)//2号图
			{
				u.a[i][j + 1] = '#';u.a[1 + i][j] = '#';u.a[i + 2][j + 1] = '#';u.a[i + 1][j + 2] = '#';
				u.cnt += 4;//复制1号图的代码时，记得2号图只占了4个格子！
				u.c2 = 1;
				dfs(u);
				u.c2 = 0;//同1号图
				u.cnt -= 4;
				u.a[i][j + 1] = '.';u.a[1 + i][j] = '.';u.a[i + 2][j + 1] = '.';u.a[i + 1][j + 2] = '.';
			}
			if(u.a[i][j + 1] == '.' && u.a[1 + i][j] == '.' && u.a[i + 2][j + 1] == '.' && u.a[i + 1][j + 2] == '.' && u.a[i + 1][j + 1] == '.' && u.c4 != 1)//注意是4号图,上面已经讲过了这两重循环不处理3号图
			{
				u.a[i][j + 1] = '#';u.a[1 + i][j] = '#';u.a[i + 2][j + 1] = '#';u.a[i + 1][j + 2] = '#';u.a[i + 1][j + 1] = '#';
				u.c4 = 1;
				u.cnt += 5;
				dfs(u);
				u.cnt -= 5;//同1号图
				u.c4 = 0;
				u.a[i][j + 1] = '.';u.a[1 + i][j] = '.';u.a[i + 2][j + 1] = '.';u.a[i + 1][j + 2] = '.';u.a[i + 1][j + 1] = '.';
			}
		}
	for(int i = 1;i <= n - 1;i++)//这两重循环处理三号图，因为3号图是2 * 2的，所以i枚举到n - 1
		for(int j = 1;j <= m - 1;j++)//同理，枚举到m - 1
		{
			if(u.a[i][j] == '.' && u.a[i][j + 1] == '.' && u.a[i + 1][j] == '.' && u.a[i + 1][j + 1] == '.' && u.c3 != 1)
			{
				u.a[i][j] = '#';u.a[i][j + 1] = '#';u.a[i + 1][j] = '#';u.a[i + 1][j + 1] = '#';
				u.cnt += 4;
				u.c3 = 1;
				dfs(u);
				u.c3 = 0;//同一号图
				u.cnt -= 4;
				u.a[i][j] = '.';u.a[i][j + 1] = '.';u.a[i + 1][j] = '.';u.a[i + 1][j + 1] = '.';
			}
		}
	return;//养成return的好习惯
}
signed main()
{
	ios::sync_with_stdio(0);g.cnt = 0;g.c1 = 0;g.c2 = 0;g.c3 = 0;g.c4 = 0;//初始化
	cin>>n>>m;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++) cin>>g.a[i][j];
	dfs(g);
	cout<<maxn;
	
	return 0;
}
```

#### 4.题外话

这里给的啥样例啊，~~弱的要死~~，还得我自己造样例！

---

## 作者：lucy2012 (赞：2)

先列文虎克一波：
- 接下来 $n$ 行，每行 $m$ 个字符串，保证字符仅包含`.`和`#`，代表棋盘的放置类型。

应为：
- 接下来 $n$ 行，每行 $m$ 个字符，保证字符仅包含`.`和`#`，代表棋盘的放置类型。
## 进入正题
应该能够感受到这题用的是搜索。我用的是 dfs。我们首先应该会想到如何判断是否可以装入 4 种卡牌。首先根据题意输入代表棋盘的矩阵：
```cpp
cin>>n>>m;
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		cin>>ch[i][j];
	}
}
```
然后由于每个卡牌只能装一次，我们还要定义几个数来判断是否装入了这个卡牌。为了后面的 dfs，还需定义答案（$ans$）和现在装入的格数（$now$）。
```cpp
int n,m,k1,k2,k3,k4,now,ans;//k1,k2,k3,k4用来判断是否装入各个卡牌 
```
由于要判断卡牌到底占多大的空间，其实想一想可以知道，空间就是卡牌最大的长和宽（可以想象用一个长方形来装卡牌），我们发现卡牌 1,2,4 占 $3\times3$，卡牌 3 占 $2\times2$。

然后手模一下，发现各个卡牌装入的要求为：

卡牌 1：
```cpp
if(ch[i][j]!='#'&&ch[i+2][j]!='#'&&ch[i][j+2]!='#'){
	if(ch[i+1][j+1]!='#'&&ch[i+2][j+2]!='#'&&k1==0){
					
	}
}
```
卡牌 2：
```cpp
if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
	if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k2==0){
					
	}
}
```
卡牌 3：
```cpp
if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'&&ch[i+1][j+1]!='#'){
	if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k4==0){
					
	}
}
```
卡牌 4：
```cpp
if(ch[i][j]!='#'&&ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
	if(ch[i+1][j+1]!='#'&&k3==0){
					
     }
}
```
由于卡牌 1,2,4 格式为 $3\times3$，而卡牌 3 格式 $2\times2$。我们分开进行判断：
```cpp
for(int i=1;i<=n-2;i++){//n-2和m-2是因为格式是3*3，如果算到n-1会超过棋盘 
		for(int j=1;j<=m-2;j++){
			if(ch[i][j]!='#'&&ch[i+2][j]!='#'&&ch[i][j+2]!='#'){
				if(ch[i+1][j+1]!='#'&&ch[i+2][j+2]!='#'&&k1==0){
					ch[i][j]=ch[i][j+2]=ch[i+2][j]=ch[i+1][j+1]=ch[i+2][j+2]='#';//标记来过了 
					k1=1;//标记用过了 
					now+=5;//格数增加 
					dfs();//继续搜 
					ch[i][j]=ch[i][j+2]=ch[i+2][j]=ch[i+1][j+1]=ch[i+2][j+2]='.';//回溯 
					k1=0;
					now-=5;
				}
			}
			if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
				if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k2==0){
					ch[i+1][j]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='#';
					k2=1;
					now+=4;
					dfs();
					ch[i+1][j]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='.';
					k2=0;
					now-=4;
				}
			}
			if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'&&ch[i+1][j+1]!='#'){
				if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k4==0){
					ch[i+1][j]=ch[i+1][j+1]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='#';
					k4=1;
					now+=5;
					dfs();
					ch[i+1][j]=ch[i+1][j+1]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='.';
					k4=0;
					now-=5;
				}
			}
		}
	}
	for(int i=1;i<=n-1;i++){//这里是2*2 
		for(int j=1;j<=m-1;j++){
			if(ch[i][j]!='#'&&ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
				if(ch[i+1][j+1]!='#'&&k3==0){
					ch[i][j]=ch[i+1][j]=ch[i][j+1]=ch[i+1][j+1]='#';
					k3=1;
					now+=4;
					dfs();
					ch[i][j]=ch[i+1][j]=ch[i][j+1]=ch[i+1][j+1]='.';
					k3=0;
					now-=4;
				}
			}
		}
	}
```
这也是 dfs 的核心代码。

## dfs 代码：
```cpp
void dfs(){
	if(now==18){
		cout<<18;
		exit(0);//跳过main函数，直接结束程序 
	}
	if(now>ans)
	    ans=now;//now的答案更大，将now值给ans 
	for(int i=1;i<=n-2;i++){//n-2和m-2是因为格式是3*3，如果算到n-1会超过棋盘 
		for(int j=1;j<=m-2;j++){
			if(ch[i][j]!='#'&&ch[i+2][j]!='#'&&ch[i][j+2]!='#'){
				if(ch[i+1][j+1]!='#'&&ch[i+2][j+2]!='#'&&k1==0){
					ch[i][j]=ch[i][j+2]=ch[i+2][j]=ch[i+1][j+1]=ch[i+2][j+2]='#';//标记来过了 
					k1=1;//标记用过了 
					now+=5;//格数增加 
					dfs();//继续搜 
					ch[i][j]=ch[i][j+2]=ch[i+2][j]=ch[i+1][j+1]=ch[i+2][j+2]='.';//回溯 
					k1=0;
					now-=5;
				}
			}
			if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
				if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k2==0){
					ch[i+1][j]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='#';
					k2=1;
					now+=4;
					dfs();
					ch[i+1][j]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='.';
					k2=0;
					now-=4;
				}
			}
			if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'&&ch[i+1][j+1]!='#'){
				if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k4==0){
					ch[i+1][j]=ch[i+1][j+1]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='#';
					k4=1;
					now+=5;
					dfs();
					ch[i+1][j]=ch[i+1][j+1]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='.';
					k4=0;
					now-=5;
				}
			}
		}
	}
	for(int i=1;i<=n-1;i++){//这里是2*2 
		for(int j=1;j<=m-1;j++){
			if(ch[i][j]!='#'&&ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
				if(ch[i+1][j+1]!='#'&&k3==0){
					ch[i][j]=ch[i+1][j]=ch[i][j+1]=ch[i+1][j+1]='#';
					k3=1;
					now+=4;
					dfs();
					ch[i][j]=ch[i+1][j]=ch[i][j+1]=ch[i+1][j+1]='.';
					k3=0;
					now-=4;
				}
			}
		}
	}
}
```
看到这其实可以试着自己去打代码了，如果还是不懂或者不对的话可以看下面的 ac code。

## ac code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k1,k2,k3,k4,now,ans;//k1,k2,k3,k4用来判断是否装入各个卡牌 
char ch[20][20];
void dfs(){
	if(now==18){
		cout<<18;
		exit(0);//跳过main函数，直接结束程序 
	}
	if(now>ans)
	    ans=now;//now的答案更大，将now值给ans 
	for(int i=1;i<=n-2;i++){//n-2和m-2是因为格式是3*3，如果算到n-1会超过棋盘 
		for(int j=1;j<=m-2;j++){
			if(ch[i][j]!='#'&&ch[i+2][j]!='#'&&ch[i][j+2]!='#'){
				if(ch[i+1][j+1]!='#'&&ch[i+2][j+2]!='#'&&k1==0){
					ch[i][j]=ch[i][j+2]=ch[i+2][j]=ch[i+1][j+1]=ch[i+2][j+2]='#';//标记来过了 
					k1=1;//标记用过了 
					now+=5;//格数增加 
					dfs();//继续搜 
					ch[i][j]=ch[i][j+2]=ch[i+2][j]=ch[i+1][j+1]=ch[i+2][j+2]='.';//回溯 
					k1=0;
					now-=5;
				}
			}
			if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
				if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k2==0){
					ch[i+1][j]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='#';
					k2=1;
					now+=4;
					dfs();
					ch[i+1][j]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='.';
					k2=0;
					now-=4;
				}
			}
			if(ch[i+1][j]!='#'&&ch[i][j+1]!='#'&&ch[i+1][j+1]!='#'){
				if(ch[i+2][j+1]!='#'&&ch[i+1][j+2]!='#'&&k4==0){
					ch[i+1][j]=ch[i+1][j+1]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='#';
					k4=1;
					now+=5;
					dfs();
					ch[i+1][j]=ch[i+1][j+1]=ch[i][j+1]=ch[i+1][j+2]=ch[i+2][j+1]='.';
					k4=0;
					now-=5;
				}
			}
		}
	}
	for(int i=1;i<=n-1;i++){//这里是2*2 
		for(int j=1;j<=m-1;j++){
			if(ch[i][j]!='#'&&ch[i+1][j]!='#'&&ch[i][j+1]!='#'){
				if(ch[i+1][j+1]!='#'&&k3==0){
					ch[i][j]=ch[i+1][j]=ch[i][j+1]=ch[i+1][j+1]='#';
					k3=1;
					now+=4;
					dfs();
					ch[i][j]=ch[i+1][j]=ch[i][j+1]=ch[i+1][j+1]='.';
					k3=0;
					now-=4;
				}
			}
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>ch[i][j];
		}
	}
	dfs();//深搜 
	cout<<ans;
	return 0;
}
```

8.21 改动了一下，让语言更明了一些了。

---

## 作者：szh_AK_all (赞：2)

## 分析
这是一道搜索题。

平凡的做法是，枚举每个位置应填放哪种卡牌，并记录每种卡牌的使用情况，到达边界时记录答案即可。但这样做显然会超时。

既然可以枚举每个位置选哪种卡牌，不妨枚举每种卡牌放在哪个位置。由于卡牌数量很少，$n,m$ 的范围也不大，所以这种方法是可行的。主要是判断某个位置是否能放当前卡牌时要考验码力，并且卡牌也可以不选，边界情况需要处理好。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[15][15];
int vis[15][15];
int n, m;
int u;
int ans = 0;
void dfs(int yu, int yong) {
	if (yu > u - 4 || yong == 5) {
		ans = max(ans, yu);
		return;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (j + 2 <= m && i + 2 <= n && !vis[i][j] && !vis[i][j + 2] && !vis[i + 1][j + 1] && !vis[i + 2][j]
			        && !vis[i + 2][j + 2] && yong == 1) {
				vis[i][j] = vis[i][j + 2] = vis[i + 1][j + 1] = vis[i + 2][j] = vis[i + 2][j + 2] =  1;
				dfs(yu + 5, yong + 1);
				vis[i][j] = vis[i][j + 2] = vis[i + 1][j + 1] = vis[i + 2][j] = vis[i + 2][j + 2] =  0;
			}
			if (j + 1 <= m && j - 1 >= 1 && i + 2 <= n && !vis[i][j] && !vis[i + 1][j - 1] && !vis[i + 1][j + 1] && !vis[i + 2][j]
			        && yong == 2) {
				vis[i][j] = vis[i + 1][j - 1] = vis[i + 1][j + 1] = vis[i + 2][j] =  1;
				dfs(yu + 4, yong + 1);
				vis[i][j] = vis[i + 1][j - 1] = vis[i + 1][j + 1] = vis[i + 2][j] =  0;
			}
			if (j + 1 <= m && i + 1 <= n && !vis[i][j] && !vis[i + 1][j] && !vis[i][j + 1] && !vis[i + 1][j + 1] && yong == 3) {
				vis[i][j] = vis[i + 1][j] = vis[i][j + 1] = vis[i + 1][j + 1] = 1;
				dfs(yu + 4, yong + 1);
				vis[i][j] = vis[i + 1][j] = vis[i][j + 1] = vis[i + 1][j + 1] = 0;
			}
			if (j + 1 <= m && j - 1 >= 1 && i + 2 <= n && !vis[i + 1][j] && !vis[i][j] && !vis[i + 1][j - 1] && !vis[i + 1][j + 1]
			        && !vis[i + 2][j] && yong == 4) {
				vis[i + 1][j] = vis[i][j] = vis[i + 1][j - 1] = vis[i + 1][j + 1] = vis[i + 2][j] = 1;
                dfs(yu + 5, yong + 1);
				vis[i + 1][j] = vis[i][j] = vis[i + 1][j - 1] = vis[i + 1][j + 1] = vis[i + 2][j] = 0;
			}
		}
	}
	dfs(yu, yong + 1);
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> s[i][j];
			if (s[i][j] == '#')
				vis[i][j] = 1, u++;
		}
	}
	u = n * m - u;
	dfs(0, 1);
	cout << ans;
}
```

---

## 作者：ZhaoV1 (赞：1)

# P10313 [SHUPC 2024] 占地斗士！
 dfs 深搜即可，但是要特别注意细节。\
搜索中用 $p$ 记录已放置的卡牌数量。\
用 $card$ 数组记录某纸牌是否已放入棋盘中。\
最后用 $ans$ 记录累计的 $sum$ 最大值即可。

ps： 若所有纸牌已放入，直接输出 $18$ 即可。

------------

```cpp
#include <iostream>
#include <string.h>
using namespace std;
int n,m;//棋盘尺寸 n*m 
int ans = 0;//输出的答案 
bool b[12][12];//用于检测某位置是否已访问过（或是否为障碍）
bool card[5];//是否放置，卡牌分别对应题目图例自左向右的四种卡牌 

inline void dfs(int pos,int p,int sum){//记录当前来到第 pos 行,已经放置了 p 张卡牌,所占格子总数为 sum 
	if(sum > ans) ans = sum;//取最大值 
	if(p == 4){//如果放完了所以卡牌就可以直接结束了（答案最高也就 18 ）
		cout << 18;
		exit(0);
	} 
	
	for(int i=pos;i<=n;i++){
		for(int j=1;j<=m;j++){
			//四种卡牌的选择 
			if(!card[1]&&!b[i][j]&&!b[i-1][j-1]&&!b[i+1][j-1]&&!b[i+1][j+1]&&!b[i-1][j+1]){
				card[1]=b[i][j]=b[i-1][j-1]=b[i+1][j-1]=b[i+1][j+1]=b[i-1][j+1]=true;
				dfs(i,p+1,sum+5);
				card[1]=b[i][j]=b[i-1][j-1]=b[i+1][j-1]=b[i+1][j+1]=b[i-1][j+1]=false;
			}
			if(!card[2]&&!b[i+1][j]&&!b[i-1][j]&&!b[i][j+1]&&!b[i][j-1]){
				card[2]=b[i+1][j]=b[i-1][j]=b[i][j+1]=b[i][j-1]=true;
				dfs(i,p+1,sum+4);
				card[2]=b[i+1][j]=b[i-1][j]=b[i][j+1]=b[i][j-1]=false;
			}
			if(!card[3]&&!b[i][j]&&!b[i-1][j]&&!b[i][j-1]&&!b[i-1][j-1]){
				card[3]=b[i][j]=b[i-1][j]=b[i][j-1]=b[i-1][j-1]=true;
				dfs(i,p+1,sum+4);
				card[3]=b[i][j]=b[i-1][j]=b[i][j-1]=b[i-1][j-1]=false;
			}
			if(!card[4]&&!b[i][j]&&!b[i+1][j]&&!b[i-1][j]&&!b[i][j+1]&&!b[i][j-1]){
				card[4]=b[i][j]=b[i+1][j]=b[i-1][j]=b[i][j+1]=b[i][j-1]=true;
				dfs(i,p+1,sum+5);
				card[4]=b[i][j]=b[i+1][j]=b[i-1][j]=b[i][j+1]=b[i][j-1]=false;
			}
		}
	}
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m;//地图 n*m 
	char temp; 
	memset(b,false,sizeof(b));//先初始化为 false 即未访问过 
	memset(card,false,sizeof(card));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin >> temp;
			if(temp == '#') b[i][j] = true;//将 '#' 的坐标标记为已访问 
		}
	}
	for(int i=0;i<=n+1;i++) b[i][0] = b[i][m+1] = true;//将边缘坐标标记为已访问 
	for(int i=0;i<=m+1;i++) b[0][i] = b[n+1][i] = true;

	dfs(1,0,0);
	cout << ans;
	return 0;
}
```

---

## 作者：Thorongil_Gondor (赞：1)

# P10313 [SHUPC 2024] 占地斗士！ 题解
## 思路
数据范围很小，故可以用 dfs 暴搜。  
枚举每种形状的所有位置。如果放卡片位置有 #，则改变位置。如果可以放，答案加卡片占地格数。标记此位置，防止死循环。
### 注意
若不考虑不可放的情况，第 $3$ 种卡片有 $(n-1)\times(m-1)$ 种放置方案，而其他三种卡片有 $(n-2)\times(m-2)$ 种放置方案。  
具体做法见代码注释。
## AC Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
char a[15][15];
void dfs(int t,int cnt){
	if(t>4){//放完求答案 
		ans=max(ans,cnt);
		return;
	}
	dfs(t+1,cnt);
	if(t==3){//图案3有(n-1)*(m-1)种摆放情况 
		for(int i=1;i<=n-1;i++){ 
			for(int j=1;j<=m-1;j++){ 
				if(a[i][j]=='.' && a[i][j+1]=='.' && a[i+1][j]=='.' && a[i+1][j+1]=='.')//摆放位置无其他图案 
				{
					a[i][j]='#';
					a[i][j+1]='#';
					a[i+1][j]='#';
					a[i+1][j+1]='#';
					dfs(t+1,cnt+4);//摆放数+1，占领格子数+4 
					a[i][j]='.';//22到25：回溯 
					a[i][j+1]='.';
					a[i+1][j]='.';
					a[i+1][j+1]='.';
				}
			}
		} 
		return;
	}
	//图案1，2，4有(n-2)*(m-2)种摆放情况 
	for(int i=1;i<=n-2;i++){ 
		for(int j=1;j<=m-2;j++){ 
			if(t==1){//图案1 
				if(a[i][j]=='.' && a[i][j+2]=='.' && a[i+1][j+1]=='.' && a[i+2][j]=='.' && a[i+2][j+2]=='.'){//摆放位置无其他图案 
					a[i][j]='#';
					a[i][j+2]='#';
					a[i+1][j+1]='#';
					a[i+2][j]='#';
					a[i+2][j+2]='#';
					dfs(t+1,cnt+5);//摆放数+1，占领格子数+5 
					a[i][j]='.';//42到46：回溯 
					a[i][j+2]='.';
					a[i+1][j+1]='.';
					a[i+2][j]='.';
					a[i+2][j+2]='.';
				}
			}
			else if(t==2){//图案2 
				if(a[i][j+1]=='.'&&a[i+1][j]=='.'&&a[i+1][j+2]=='.'&&a[i+2][j+1]=='.'){//摆放位置无其他图案 
					a[i][j+1]='#';
					a[i+1][j]='#';
					a[i+1][j+2]='#';
					a[i+2][j+1]='#';
					dfs(t+1,cnt+4);//摆放数+1，占领格子数+4 
					a[i][j+1]='.';//56到59：回溯 
					a[i+1][j]='.';
					a[i+1][j+2]='.';
					a[i+2][j+1]='.';
				}
			}
			else{//图案4 
				if(a[i][j+1]=='.'&&a[i+1][j]=='.'&&a[i+1][j+1]=='.'&&a[i+1][j+2]=='.'&&a[i+2][j+1]=='.'){//摆放位置无其他图案 
					a[i][j+1]='#';
					a[i+1][j]='#';
					a[i+1][j+1]='#';
					a[i+1][j+2]='#';
					a[i+2][j+1]='#';
					dfs(t+1,cnt+5);//摆放数+1，占领格子数+5
					a[i][j+1]='.';//70到76：回溯 
					a[i+1][j]='.';
					a[i+1][j+1]='.';
					a[i+1][j+2]='.';
					a[i+2][j+1]='.';
				}
			}
		}	
	} 
}
signed main(){
	cin>>n>>m; 
	for(int i=1;i<=n;i++)cin>>a[i]+1;//让下标从一开始 
	dfs(1,0);///开始深搜 
	cout<<ans;
	return 0;
}

```

---

## 作者：DFM_O (赞：1)

## [P10313 题目](https://www.luogu.com.cn/problem/P10313)

### 解题思路
不难发现，不考虑格子不能被放置的情况，除了第三种卡牌有 $(n-1)\times(m-1)$ 种摆放情况，其余的卡牌均有 $(n-2)\times(m-2)$ 种摆放情况。

当 $n=10$ 且 $m=10$ 时，所有卡牌共有 $8^6\times9^2$ 种摆放情况，明显小于 $10^9$，所以可以直接用深搜暴力枚举，每次确定位置后要将卡牌摆放的位置的上标记，但别忘了回溯。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[11][11],maxx=-1;
void dfs(int dep,int s)
{
	if(dep>4)
	{
		maxx=max(maxx,s);
		return;
	}
	if(dep==3)
	{
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++)
			{
				if(a[i][j]==1&&a[i+1][j+1]==1&&a[i][j+1]==1&&a[i+1][j]==1)
				{
					a[i][j]=a[i+1][j+1]=a[i+1][j]=a[i][j+1]=0;
					dfs(dep+1,s+4);
					a[i][j]=a[i+1][j+1]=a[i+1][j]=a[i][j+1]=1;
				}
			}
		}		
	}
	else
	{
		for(int i=1;i<=8;i++)
		{
			for(int j=1;j<=8;j++)
			{
				if(dep==1)
				{
					if(a[i][j]==1&&a[i+1][j+1]==1&&a[i][j+2]==1&&a[i+2][j]==1&&a[i+2][j+2]==1)
					{
						a[i][j]=a[i+1][j+1]=a[i][j+2]=a[i+2][j]=a[i+2][j+2]=0;
						dfs(dep+1,s+5);
						a[i][j]=a[i+1][j+1]=a[i][j+2]=a[i+2][j]=a[i+2][j+2]=1;
					}
				}
				if(dep==2)
				{
					if(a[i][j+1]==1&&a[i+1][j]==1&&a[i+1][j+2]==1&&a[i+2][j+1]==1)
					{
						a[i][j+1]=a[i+1][j]=a[i+1][j+2]=a[i+2][j+1]=0;
						dfs(dep+1,s+4);
						a[i][j+1]=a[i+1][j]=a[i+1][j+2]=a[i+2][j+1]=1;			
					}
				}
				if(dep==4)
				{
					if(a[i][j+1]==1&&a[i+1][j]==1&&a[i+1][j+2]==1&&a[i+2][j+1]==1&&a[i+1][j+1]==1)
					{
						a[i][j+1]=a[i+1][j]=a[i+1][j+2]=a[i+2][j+1]=a[i+1][j+1]=0;
						dfs(dep+1,s+5);
						a[i][j+1]=a[i+1][j]=a[i+1][j+2]=a[i+2][j+1]=a[i+1][j+1]=1;			
					}
				}
			}
		}
	}
	dfs(dep+1,s);
}
signed main()
{
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char ch;
			cin>>ch;
			if(ch=='.')
				a[i][j]=1;
		}
	}
	dfs(1,0);
	cout<<maxx;
	return 0;
}
```

---

## 作者：729hao (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10313)

-----------
## 思路
数据范围只有 $10$，考虑搜索。

依次枚举每种卡牌所放的位置，如果合法（不与其它卡牌重叠，不在不能被放置的各自上）就进入下一层搜索。四层搜完后更新答案即可。

如何判断合不合法呢？用一个二维数组存储，放置卡牌后就将对应位置更新。每次枚举完后记得复原。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
string s;
bool adm[15][15];
void dfs(int lv,int d){
	if(lv==5){
		ans=max(ans,d);
		return;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(adm[i][j])continue;
			if(lv==1){
				if(i+2>n||j+2>m||adm[i][j+2]||adm[i+2][j]||adm[i+1][j+1]||adm[i+2][j+2])continue;
				adm[i][j]=adm[i][j+2]=adm[i+2][j]=adm[i+2][j+2]=adm[i+1][j+1]=true;
				dfs(2,d+5);
				adm[i][j]=adm[i][j+2]=adm[i+2][j]=adm[i+2][j+2]=adm[i+1][j+1]=false;
			}
			else if(lv==2){
				if(i+2>n||j-1<1||j+1>m||adm[i+2][j]||adm[i+1][j+1]||adm[i+1][j-1])continue;
				adm[i][j]=adm[i+2][j]=adm[i+1][j+1]=adm[i+1][j-1]=true;
				dfs(3,d+4);
				adm[i][j]=adm[i+2][j]=adm[i+1][j+1]=adm[i+1][j-1]=false;
			}
			else if(lv==3){
				if(i+1>n||j+1>m||adm[i+1][j]||adm[i+1][j+1]||adm[i][j+1])continue;
				adm[i][j]=adm[i+1][j]=adm[i+1][j+1]=adm[i][j+1]=true;
				dfs(4,d+4);
				adm[i][j]=adm[i+1][j]=adm[i+1][j+1]=adm[i][j+1]=false;
			}
			else if(lv==4){
				if(i+2>n||j-1<1||j+1>m||adm[i+2][j]||adm[i+1][j+1]||adm[i+1][j-1]||adm[i+1][j])continue;
				adm[i][j]=adm[i+2][j]=adm[i+1][j+1]=adm[i+1][j-1]=adm[i+1][j]=true;
				dfs(5,d+5);
				adm[i][j]=adm[i+2][j]=adm[i+1][j+1]=adm[i+1][j-1]=adm[i+1][j]=false;
			}
		}
	}
	dfs(lv+1,d);
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>s;
		for(int j=1;j<=m;j++){
			adm[i][j]=(s[j-1]=='#');
		}
	}
	dfs(1,0);
	cout<<ans;
	return 0;
}
```
时间复杂度 $O(n^4m^4)$，$2$ 秒时限够了。

---

## 作者：Y_zhao111 (赞：0)

### Description
题目传送门：[P10313 [SHUPC 2024]  占地斗士！](/problem/P10313)。

简单搜索题。

### Analysis
容易发现，$1\le n,m\le10$，地图很小，所以考虑 DFS 算法。

其实是回溯，不是深度优先搜索。

题目不难，但细节多。

+ 用变量存下已经放置的卡牌数量。
+ **用 $\mathcal{vis}$ 记录此卡牌是否放置过（不能直接改地图，这是回溯的重要部分）**。
+ 其它就是回溯+剪枝即可。

一些细节：
+ 暴力枚举每个形状可以放的所有位置。
+ 是 `#` 不能放，换个位置。
+ 可以放的话，卡牌数自增，答案加上**占地格子数**，**不是 $1$**。
+ 可以放，记得 $vis$ 标记位置。

若所有的卡牌都可以放入，那么直接输出 $18$，不用搜了，**搜了小心 $\colorbox{052242}{\color{white}{\tt TLE}}$，程序卡死**。

都可以放入的数据如下：
>#### 输入
>```
>10 10
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>. . . . . . . . . .
>```
>#### 输出
>```
>18
>```

代码模拟即可。

---

## 作者：forever516 (赞：0)

题意很明显，直接模拟即可。
## 解法
暴搜，因为
$n,m<10$
包不会超时。
我们把每种形状的所有位置的可能都枚举一遍，如果卡片下面有符号，则当前方案不可取，否则将它占的格子记录一下，防止第二次搜到它。
上代码！
```cpp
#include<bits/stdc++.h>
#define co continue
using namespace std;
const int N=10+5,M=5;
const int tz[]={0,3,3,2,3},az[]={0,5,4,4,5};
int n,m,sz,ans;
bool vis[M];
char a[N][N];
bool pd_cpt(int opt,int x,int y){
    if(x<1||y<1||x+tz[opt]-1>n||y+tz[opt]-1>m)return 0;
    for(int i=x;i<x+tz[opt];i++)for(int j=y;j<y+tz[opt];j++){
        if(opt==1){
            if(i==x&&j==y+1)co;
            if(i==x+2&&j==y+1)co;
            if(i==x+1&&j==y)co;
            if(i==x+1&&j==y+2)co;
        }else if(opt==2||opt==4){
            if(i==x&&j==y)co;
            if(i==x&&j==y+2)co;
            if(opt==2)if(i==x+1&&j==y+1)co;
            if(i==x+2&&j==y)co;       
            if(i==x+2&&j==y+2)co;        
        }
        if(a[i][j]!='.'){return 0;}
    }
    return 1;
}
void do_pt(int opt,int x,int y,char ch){
    for(int i=x;i<x+tz[opt];i++)for(int j=y;j<y+tz[opt];j++){
        if(opt==1){
            if(i==x&&j==y+1)co;
            if(i==x+2&&j==y+1)co;
            if(i==x+1&&j==y)co;
            if(i==x+1&&j==y+2)co;
        }else if(opt==2||opt==4){
            if(i==x&&j==y)co;
            if(i==x&&j==y+2)co;
            if(opt==2)if(i==x+1&&j==y+1)co;
            if(i==x+2&&j==y)co;       
            if(i==x+2&&j==y+2)co;        
        }
        a[i][j]=ch;
    }
    return;
}
void dfs(int stp){ // 回溯、搜索
    if(stp>4){
        ans=max(ans,sz);
        return;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)if(!vis[stp]&&pd_cpt(stp,i,j)){
            vis[stp]=1;sz+=az[stp];do_pt(stp,i,j,char('A'+stp-1));
            dfs(stp+1);
            vis[stp]=0;sz-=az[stp];do_pt(stp,i,j,'.');
        }
    }
    dfs(stp+1);
    return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j];
    sz=0;dfs(1);
    cout<<ans;
    return 0;
}
```

---

## 作者：lpx666666 (赞：0)

## 题面
给定一个 $n \times m$ 的矩阵，有的地方能填，有的地方不能填，你手中有 $4$ 种卡牌，**每种只有一张**，求用这些牌最多能填几个方格。

## 思路
我最开始没看数据规模，打了一个贪心，结果错了，我相信大部分没过的人都是没看数据规模。

数据规模极小，也就是说用 DFS 暴力即可。

不过暴力也要是聪明的暴力，不能一个一个点暴力，这时我们可以利用到题面中的关键信息，**每种卡牌只有一张**，我们可以暴力牌放的位置。

## 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int n,m,max_=-1;
int arr[11][11];
bool c(int u,int x,int y){//判断函数 
	if(u==1 && arr[x-1][y-1]==0 && arr[x-1][y+1]==0 && arr[x][y]==0 && arr[x+1][y-1]==0 && arr[x+1][y+1]==0 && x-1>=1 && y-1>=1 && x+1<=n && y+1<=m) return 1;//四种类型 
	if(u==2 && arr[x-1][y]==0 && arr[x][y-1]==0 && arr[x][y+1]==0 && arr[x+1][y]==0 && arr[x][y]==0 && x-1>=1 && y-1>=1 && x+1<=n && y+1<=m) return 1;
	if(u==3 && arr[x-1][y]==0 && arr[x][y-1]==0 && arr[x][y+1]==0 && arr[x+1][y]==0 && x-1>=1 && y-1>=1 && x+1<=n && y+1<=m) return 1;
	if(u==4 && arr[x-1][y]==0 && arr[x][y-1]==0 && arr[x-1][y-1]==0 && arr[x][y]==0 && x-1>=1 && y-1>=1 && x<=n && y<=m) return 1;
	return 0;//这里记得一定要返回 
}
void f(int &u,int x,int y,int &o){//改变数据的函数 
	if(u==1){//四种类型 
		o+=5;//增加占领方格数 
		arr[x-1][y-1]=1;arr[x-1][y+1]=1;arr[x][y]=1;arr[x+1][y-1]=1;arr[x+1][y+1]=1;//将方格定为不可放置的 
		u++;//下一种 
		return;
	}
	if(u==2){
		o+=5;
		arr[x][y]=1;arr[x-1][y]=1;arr[x][y-1]=1;arr[x][y+1]=1;arr[x+1][y]=1;
		u++;
		return;
	}
	if(u==3){
		o+=4;
		arr[x-1][y]=1;arr[x][y-1]=1;arr[x][y+1]=1;arr[x+1][y]=1;
		u++;
		return;
	}
	o+=4;
	arr[x-1][y]=1;arr[x][y-1]=1;arr[x-1][y-1]=1;arr[x][y]=1;
	u++;
	return;
}
void t(int &u,int x,int y,int &o){//改变数据的函数的逆运算 
	if(u-1==1){
		o-=5;
		arr[x-1][y-1]=0;arr[x-1][y+1]=0;arr[x][y]=0;arr[x+1][y-1]=0;arr[x+1][y+1]=0;
		u--;
		return;
	}
	if(u-1==2){
		o-=5;
		arr[x][y]=0;arr[x-1][y]=0;arr[x][y-1]=0;arr[x][y+1]=0;arr[x+1][y]=0;
		u--;
		return;
	}
	if(u-1==3){
		o-=4;
		arr[x-1][y]=0;arr[x][y-1]=0;arr[x][y+1]=0;arr[x+1][y]=0;
		u--;
		return;
	}
	o-=4;
	arr[x-1][y]=0;arr[x][y-1]=0;arr[x-1][y-1]=0;arr[x][y]=0;
	u--;
	return;
}
void dfs(int x,int y){
	max_=max(max_,x);//计算最大值 
	if(y>4) return;//已经没有可以放的了 
	for(int i=1;i<=n;i++){//暴力 
		for(int j=1;j<=m;j++){
			if(c(y,i,j)){//判断是否符合要求 
				f(y,i,j,x);
				dfs(x,y);
				t(y,i,j,x);
			}
		}
	}
	dfs(x,y+1);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='#'){//转为数字便于计算 
				arr[i][j]=1;
			}
			else{
				arr[i][j]=0;
			}
		}
	}
	dfs(0,1);//DFS 
	cout<<max_;//输出 
	return 0;//华丽结尾 
}


```

---

## 作者：xixisuper (赞：0)

# P10313 [SHUPC 2024]  占地斗士！题解

搜索入门题

## 思路

由于发现整个地图非常小，可以直接考虑爆搜。

我们考虑以每一位作为所放图形的左上角，然后暴力判断当前能不能放。如果能放，那就打上标记，继续递归，然后回溯。如果不能，直接跳到下一个，判断下一个能不能放。

**注意，每一个图形有且仅有一个，所以放完一个图形后，该图形不能再次被放置。**

时间复杂度未知，但在指数级别。

## 代码

蒟蒻代码，不喜勿喷。

```cpp
#include <iostream>
#include <algorithm>
#define ll long long 
using namespace std;
const ll N=3e5+10;
ll n,m;
ll nxt_x[N],nxt_y[N],tot=1;
ll ans,nans;
bool vis[100];
int mp[100][100];
int cht_1[3][3]={{1,0,1},{0,1,0},{1,0,1}};
int cht_2[3][3]={{0,1,0},{1,0,1},{0,1,0}};
int cht_3[3][3]={{0,1,0},{1,1,1},{0,1,0}}; 
int cht_4[2][2]={{1,1},{1,1}};
bool cn(ll swt,ll x,ll y){
	switch(swt){
		case 1:{
			if(n-x+1<3||m-y+1<3) return 0;
			for(ll i=0;i<3;i++) for(ll j=0;j<3;j++) if(mp[x+i][y+j]&&cht_1[i][j]) return 0;
			break;
		}
		case 2:{
			if(n-x+1<3||m-y+1<3) return 0;
			for(ll i=0;i<3;i++) for(ll j=0;j<3;j++) if(mp[x+i][y+j]&&cht_2[i][j]) return 0;
			break;
		}
		case 3:{
			if(n-x+1<3||m-y+1<3) return 0;
			for(ll i=0;i<3;i++) for(ll j=0;j<3;j++) if(mp[x+i][y+j]&&cht_3[i][j]) return 0;
			break;
		}
		case 4:{
			if(n-x+1<2||m-y+1<2) return 0;
			for(ll i=0;i<2;i++) for(ll j=0;j<2;j++) if(mp[x+i][y+j]&&cht_4[i][j]) return 0;
			break;
		}
	}
	return 1;
}
void chg(ll swt,ll x,ll y){
	switch(swt){
		case 1:{
			for(ll i=0;i<3;i++) for(ll j=0;j<3;j++) mp[x+i][y+j]^=cht_1[i][j];
			break;
		}
		case 2:{
			for(ll i=0;i<3;i++) for(ll j=0;j<3;j++) mp[x+i][y+j]^=cht_2[i][j];
			break;
		}
		case 3:{
			for(ll i=0;i<3;i++) for(ll j=0;j<3;j++) mp[x+i][y+j]^=cht_3[i][j];
			break;
		}
		case 4:{
			for(ll i=0;i<2;i++) for(ll j=0;j<2;j++) mp[x+i][y+j]^=cht_4[i][j];
			break;
		}
	}
}
void dfs(ll now_x,ll now_y,ll step){
	if(step>n*m) return;
	if(!vis[1]&&cn(1,now_x,now_y)){
		vis[1]=1;chg(1,now_x,now_y);
		nans+=5;ans=max(ans,nans);
		dfs(now_x,now_y,step);
		nans-=5;chg(1,now_x,now_y);vis[1]=0;
	}
	if(!vis[2]&&cn(2,now_x,now_y)){
		vis[2]=1;chg(2,now_x,now_y);
		nans+=4;ans=max(ans,nans);
		dfs(now_x,now_y,step);
		nans-=4;chg(2,now_x,now_y);vis[2]=0;
	}
	if(!vis[3]&&cn(3,now_x,now_y)){
		vis[3]=1;chg(3,now_x,now_y);
		nans+=5;ans=max(ans,nans);
		dfs(now_x,now_y,step);
		nans-=5;chg(3,now_x,now_y);vis[3]=0;
	}
	if(!vis[4]&&cn(4,now_x,now_y)){
		vis[4]=1;chg(4,now_x,now_y);
		nans+=4;ans=max(ans,nans);
		dfs(now_x,now_y,step);
		nans-=4;chg(4,now_x,now_y);vis[4]=0;
	}
	dfs(nxt_x[step],nxt_y[step],step+1);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=m;j++){
			nxt_x[tot-1]=i;nxt_y[tot-1]=j;tot++;
			char c;
			cin>>c;
			if(c=='#') mp[i][j]=1;
		} 
	}
	dfs(1,1,1);
	cout<<ans;
	return 0;
}
```

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10313)
## 解题思路
暴搜。

因为 $n,m\le 10$，所以不会超时。

我们把每种形状的所有位置的可能都枚举一遍，如果卡片下面有 `#`，则当前方案不可取，否则将它占的格子记录一下，防止第二次搜到它。

注意每张卡片的格子数量不同。

第三张卡片大小为 $2\times 2$ 的，而其他的是 $3\times 3$ 的。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,maxn;
char a[20][20];
void dfs(int t,int s)
{
	if(t==5)
	{
		maxn=max(maxn,s);
		return;
	}
	dfs(t+1,s);
	if(t==3)
	{
		for(int i=1;i<n;i++)
			for(int j=1;j<m;j++)
				if(a[i][j]=='.'&&a[i][j+1]=='.'&&a[i+1][j]=='.'&&a[i+1][j+1]=='.')
				{
					a[i][j]='#';a[i][j+1]='#';a[i+1][j]='#';a[i+1][j+1]='#';
					dfs(t+1,s+4);
					a[i][j]='.';a[i][j+1]='.';a[i+1][j]='.';a[i+1][j+1]='.';
				}
		return;
	}
	for(int i=1;i<=n-2;i++)
		for(int j=1;j<=m-2;j++)
			if(t==1)
			{
				if(a[i][j]=='.'&&a[i][j+2]=='.'&&a[i+1][j+1]=='.'&&a[i+2][j]=='.'&&a[i+2][j+2]=='.')
				{
					a[i][j]='#';a[i][j+2]='#';a[i+1][j+1]='#';a[i+2][j]='#';a[i+2][j+2]='#';
					dfs(t+1,s+5);
					a[i][j]='.';a[i][j+2]='.';a[i+1][j+1]='.';a[i+2][j]='.';a[i+2][j+2]='.';
				}
			}
			else if(t==2)
			{
				if(a[i][j+1]=='.'&&a[i+1][j]=='.'&&a[i+1][j+2]=='.'&&a[i+2][j+1]=='.')
				{
					a[i][j+1]='#';a[i+1][j]='#';a[i+1][j+2]='#';a[i+2][j+1]='#';
					dfs(t+1,s+4);
					a[i][j+1]='.';a[i+1][j]='.';a[i+1][j+2]='.';a[i+2][j+1]='.';
				}
			}
			else
			{
				if(a[i][j+1]=='.'&&a[i+1][j]=='.'&&a[i+1][j+1]=='.'&&a[i+1][j+2]=='.'&&a[i+2][j+1]=='.')
				{
					a[i][j+1]='#';a[i+1][j]='#';a[i+1][j+1]='#';a[i+1][j+2]='#';a[i+2][j+1]='#';
					dfs(t+1,s+5);
					a[i][j+1]='.';a[i+1][j]='.';a[i+1][j+1]='.';a[i+1][j+2]='.';a[i+2][j+1]='.';
				}
			}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i]+1;
	dfs(1,0);
	cout<<maxn;
	return 0;
}

```

---

## 作者：Ivan422 (赞：0)

题目大意：在一个 $n$ 行 $m$ 列的棋盘里放上 $4$ 种积木，每种只能用一次，求最多在多少方块上放上积木。

思路：直接模拟即可，和[这题](https://www.luogu.com.cn/problem/AT_abc345_d)很像，也是铺瓷砖搜索题，不过因为时间更加宽裕，所以用了更好像的方法。先回溯搜索每一个积木，枚举位置，记录当前占有总格数，取最大值即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10+5,M=5;
const int tz[]={0,3,3,2,3},az[]={0,5,4,4,5};
int n,m,sz,ans;
bool vis[M];
char a[N][N];
//can:put card 判断可不可以放积木
bool pd_cpt(int opt,int x,int y){
    if(x<1||y<1||x+tz[opt]-1>n||y+tz[opt]-1>m)return 0;
    for(int i=x;i<x+tz[opt];i++)for(int j=y;j<y+tz[opt];j++){
        if(opt==1){
            if(i==x&&j==y+1)continue;
            if(i==x+2&&j==y+1)continue;
            if(i==x+1&&j==y)continue;
            if(i==x+1&&j==y+2)continue;
        }else if(opt==2||opt==4){
            if(i==x&&j==y)continue;
            if(i==x&&j==y+2)continue;
            if(opt==2)if(i==x+1&&j==y+1)continue;
            if(i==x+2&&j==y)continue;       
            if(i==x+2&&j==y+2)continue;        
        }
        if(a[i][j]!='.'){return 0;}
    }
    return 1;
}
//do:put card 放积木
void do_pt(int opt,int x,int y,char ch){
    for(int i=x;i<x+tz[opt];i++)for(int j=y;j<y+tz[opt];j++){
        if(opt==1){
            if(i==x&&j==y+1)continue;
            if(i==x+2&&j==y+1)continue;
            if(i==x+1&&j==y)continue;
            if(i==x+1&&j==y+2)continue;
        }else if(opt==2||opt==4){
            if(i==x&&j==y)continue;
            if(i==x&&j==y+2)continue;
            if(opt==2)if(i==x+1&&j==y+1)continue;
            if(i==x+2&&j==y)continue;       
            if(i==x+2&&j==y+2)continue;        
        }
        a[i][j]=ch;
    }
    return;
}
void dfs(int stp){ // 回溯、搜索
    if(stp>4){/*
        for(int i=1;i<=4;i++)cout<<vis[i]<<" ";
        cout<<sz<<endl;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++)cout<<a[i][j]<<" ";
            cout<<endl;
        }*/
        ans=max(ans,sz);
        return;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)if(!vis[stp]&&pd_cpt(stp,i,j)){
            vis[stp]=1;sz+=az[stp];do_pt(stp,i,j,char('A'+stp-1));
            dfs(stp+1);
            vis[stp]=0;sz-=az[stp];do_pt(stp,i,j,'.');
        }
    }
    dfs(stp+1);
    return;
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j];
    sz=0;dfs(1);
    cout<<ans;
    return 0;
}
```

---


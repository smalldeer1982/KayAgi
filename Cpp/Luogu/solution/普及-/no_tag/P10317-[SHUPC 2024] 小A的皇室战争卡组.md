# [SHUPC 2024] 小A的皇室战争卡组

## 题目描述

小 A 很喜欢玩皇室战争这款游戏。皇室战争的卡牌种类共有 $3$ 种，分别为部队、建筑和法术。一个卡组会携带 $8$ 张卡牌，一个合理的卡组会包含 $0\sim 1$ 张建筑牌、 $1\sim 3$ 张法术牌，部队牌则没有限制。每张卡牌都有自己独立的等级 $a_i$ 和种类 $c_i$。

现在小 A 想和 小 B 进行友谊战，因此需要来构建出战卡组。小 A 共有 $n$ 张卡牌，卡牌的类型与等级已知，且 小 B 的每张出战卡牌的等级已知。由于小 A 对自己的水平非常自信，因此只要 **出战卡牌的平均等级 $\ge$ 对手出战卡牌的平均等级 $-2$**，**且卡组为一个合理的卡组**，则他就能确保取胜。

现在请你帮小 A​ 想想，他可以确保取胜吗？

## 说明/提示

样例解释：

在第一组样例中，小A可以取第1,2,3,6,7,8,9,10张卡牌，此时出战卡组的平均等级为6级，而小B的出战卡组平均等级为8级，$小A的平均等级 \ge 小B的平均等级-2$，因此小A可以确保胜利。

在第二组样例中，无论小A如何配置卡组都无法使平均等级满足条件，因此不能获胜。

在第三组样例中，小A无法配置出一个合理的卡组，因此也不能获胜。

## 样例 #1

### 输入

```
3
10
2 3 3 3 1 1 1 1 1 1 
7 8 9 1 2 3 4 5 6 6
13 13 13 13 3 3 3 3
10
2 2 3 1 1 1 1 1 1 1
10 9 2 2 2 2 2 2 2 2
5 5 5 5 5 5 5 6
8
1 1 1 1 1 1 1 1
15 15 15 15 15 15 15 15
1 1 1 1 1 1 1 1```

### 输出

```
Yes
No
No```

# 题解

## 作者：zhengpie (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P10317)

### 1.思路

看到题目，很容易想到一种**贪心**的做法：既然要算有没有做法使得小 $A$ 的平均等级比小 $B$ 的减去 $2$ 要来的大，那么我们直接考虑小 $A$ 的**最优平均等级**就可以了呀！

于是，在输入的时候，我们只需要保留等级**最大**的建筑牌，等级**前三大**的法术牌，等级**前七大**的部队牌即可。

为什么呢？根据题意，我们知道建筑牌**最多**可以拿 $1$ 张，那么要**使平均等级最大**，我们肯定会选**自身等级最大**的建筑牌啊！同理，我们选等级**前三大**的法术牌，等级**前七大**的部队牌。这里特别注意一下部队牌最多可以取 $8 - 0 - 1 = 7$ 张。

### 2.细节

首先，我们肯定要判断这组卡牌是否合法：
```cpp
if(c3 < 1 || c1 < 4 || c1 + c2 + c3 < 8)//c1是部队牌个数，c2是建筑牌个数，c3是法术牌个数
{
	cout<<"No"<<endl;continue;
}//如果法术牌的个数小于1，那么就只能取0张法术牌，不合法，直接输出No,另外两个条件也是同理。
```
然后我们保留保留等级最大的建筑牌，等级前三大的法术牌，等级前七大的部队牌，容易知道，如果所有牌都足够多的话，一共有 $6$ 种取法，记他们为 $k_i(i \in [1,6])$ 。
于是， $k_i$ 就等于这些东西：
```cpp
//a1[]为部队牌，a2[]为建筑牌，a3[]为法术牌
int k1 = a1[1] + a1[2] + a1[3] + a1[4] + a2[1] + a3[2] + a3[3] + a3[1];
int k2 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a3[2] + a3[3] + a3[1];
int k3 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a3[2] + a3[1];
int k4 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a3[2] + a2[1] + a3[1];
int k5 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a1[7] + a3[1];
int k6 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a2[1] + a3[1];
```
然后还要注意到一件重要的事情，就以 $k_1$ 为例。可以发现， $k_1$ 这组卡牌需要用到一张建筑牌，但是注意到，当 ```c2 < 1``` 时，无法拿出 $1$ 张建筑牌，于是 $k_1$ 这种情况就不成立。

同理，用下面的代码标记所有不成立的 $k_i$ ：
```cpp
if(c1 < 7) k5 = -114514;//因为后面与小B的平均等级比较，取最大值，所以把不成立的k[i]设成负数。
if(c1 < 6) k3 = k6 = -114514;
if(c1 < 5) k2 = k4 = -114514;
if(c2 < 1) k1 = k4 = k6 = -114514;
if(c3 < 3) k1 = k2 = -114514;
if(c3 < 2) k3 = k4 = -114514;
```
然后作比较：
```cpp
if(max(max(max(k1,k2),max(k6,k5)),max(k3,k4)) / 8 >= (sum / 8 - 2)) cout<<"Yes"<<endl;//sum是小B的卡牌总和
else cout<<"No"<<endl;
```
当然，类型转换是一件很烦人的事，所以直接比较等级之和就行了。
```cpp
if(max(max(max(k1,k2),max(k6,k5)),max(k3,k4)) >= (sum - 16)) cout<<"Yes"<<endl;//两边同时乘8
else cout<<"No"<<endl;
```
### 3.完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a1[114514],a2[114514],a3[114514],b[114514],c[114514];//a1[]为部队牌，a2[]为建筑牌，a3[]为法术牌，b[]为小B的牌
bool cmp(int x,int y)
{
	return x > y;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>t;
	for(int bbj = 1;bbj <= t;bbj++)
	{
		
		cin>>n;
		memset(a1,0,sizeof a1);memset(a2,0,sizeof a2);memset(a3,0,sizeof a3);memset(b,0,sizeof b);memset(c,0,sizeof c);//记得初始化！
		int sum = 0,c1 = 0,c2 = 0,c3 = 0;
		for(int i = 1;i <= n;i++) 
		{
			cin>>c[i];
			if(c[i] == 2) c2++;if(c[i] == 1) c1++;if(c[i] == 3) c3++;
		}
		for(int i = 1,i1 = 1,i2 = 1,i3 = 1;i <= n;i++)
		{
			if(c[i] == 1){cin>>a1[i1];i1++;}
			if(c[i] == 2){cin>>a2[i2];i2++;}
			if(c[i] == 3){cin>>a3[i3];i3++;}
		}
		for(int i = 1;i <= 8;i++) {cin>>b[i];sum += b[i];}
		if(c3 < 1 || c1 < 4 || c1 + c2 + c3 < 8)
		{
			cout<<"No"<<endl;continue;//先特判不合法的
		}
		sort(a1 + 1,a1 + c1 + 1,cmp);//记得排序！
		sort(a2 + 1,a2 + c2 + 1,cmp);
		sort(a3 + 1,a3 + c3 + 1,cmp);
		int k1 = a1[1] + a1[2] + a1[3] + a1[4] + a2[1] + a3[2] + a3[3] + a3[1],k2 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a3[2] + a3[3] + a3[1];
		int k3 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a3[2] + a3[1],k4 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a3[2] + a2[1] + a3[1];
		int k5 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a1[7] + a3[1],k6 = a1[1] + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a2[1] + a3[1];
		if(c1 < 7) k5 = -114514;//因为后面与小B的平均等级比较，取最大值，所以把不成立的k[i]设成负数。
		if(c1 < 6) k3 = k6 = -114514;
		if(c1 < 5) k2 = k4 = -114514;
		if(c2 < 1) k1 = k4 = k6 = -114514;
		if(c3 < 3) k1 = k2 = -114514;
		if(c3 < 2) k3 = k4 = -114514;
		if(max(max(max(k1,k2),max(k6,k5)),max(k3,k4)) >= (sum - 16)) 
        		cout<<"Yes"<<endl;//两边同时乘8
		else cout<<"No"<<endl;
	}
	
	return 0;
}
```

---

## 作者：szh_AK_all (赞：3)

## 分析
由于卡牌数量很小，所以可以用二维循环枚举建筑牌与法术牌分别选多少张，因为要确保获胜，所以选的牌的等级应尽可能大，所以可以分别将三种卡牌按照等级排序，如果要使用某种卡牌则取权值最大的。

首先是预处理部分，可以用三个数组分别记录三种卡牌中每张卡牌的等级，然后分别进行排序。并用变量 $b$ 记录小 B 的卡牌等级之和（为了避免取平均值算小数）。

其次是枚举部分，按上述方法枚举得到卡组的等级之和 $a$，若 $a\ge b-16$，则小 A 取胜。

最后注意边界即可。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005], b[100005], c[100005], al, bl, cl;
int k[100005];

int main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		for (int i = 1; i <= n; i++)
			cin >> k[i];
		for (int i = 1; i <= n; i++) {
			int de;
			cin >> de;
			if (k[i] == 1)
				a[++al] = de;
			else if (k[i] == 2)
				b[++bl] = de;
			else
				c[++cl] = de;
		}
		int bb = 0;
		for (int i = 1; i <= 8; i++) {
			int de;
			cin >> de;
			bb += de;
		}
		sort(a + 1, a + al + 1);
		sort(b + 1, b + bl + 1);
		sort(c + 1, c + cl + 1);
		int p = 0;
		for (int i = 0; i <= 1; i++) {
			for (int j = 1; j <= 3; j++) {
				if (bl < i || cl < j || al < (8 - i - j))
					continue;
				int de = 0;
				for (int k = 1, x = bl; k <= i; k++, x--)
					de += b[x];
				for (int k = 1, x = cl; k <= j; k++, x--)
					de += c[x];
				for (int k = 1, x = al; k <= 8 - i - j; k++, x--)
					de += a[x];
				if (de >= bb - 16)
					p = 1;
			}
		}
		if (p == 1)
			cout << "Yes";
		else
			cout << "No";
		cout << endl;
		al = bl = cl = 0;
	}
}
```

---

## 作者：Matrix__ (赞：3)

[传送门](https://www.luogu.com.cn/problem/P10317)

这个题其实也非常水的啦！！

首先我们可以定义三个数组 $a$，$b$，$c$，分别表示部队、建筑、法术牌的等级。

我们根据输入可以得到对手的平均等级再减 $2$，令这个值为 $s$。

根据贪心，我们很容易可以得到我们选牌时选等级越大的牌越容易赢，就可先将 $a$，$b$，$c$ 分别排序。然后依次分情况讨论即可。

1. $0$ 张建筑牌，$1$ 张法术牌，和 $7$ 张部队牌。

2. $0$ 张建筑牌，$2$ 张法术牌，和 $6$ 张部队牌。

3. $0$ 张建筑牌，$3$ 张法术牌，和 $5$ 张部队牌。

4. $1$ 张建筑牌，$1$ 张法术牌，和 $6$ 张部队牌。

5. $1$ 张建筑牌，$2$ 张法术牌，和 $5$ 张部队牌。

6. $1$ 张建筑牌，$3$ 张法术牌，和 $4$ 张部队牌。

当然，在讨论时还需注意某种牌有没有这么多张。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef double db;
const db eqs=1e-6;
const int inf=1e9;
void cmax(int &a,int b){a=max(a,b);}
void cmin(int &a,int b){a=min(a,b);}
bool db_eq(db a,db b){return fabs(a-b)<eqs;}

const int MAXN=100000+5;
int T,n,x[MAXN],y[MAXN];
vector<int>a,b,c;
//a为部队，b为建筑，c为法术 

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>T;
	while(T--)
	{
      //多测不清空，永远见祖宗！
		while(!a.empty()) a.pop_back();
		while(!b.empty()) b.pop_back();
		while(!c.empty()) c.pop_back();
		cin>>n;
		for(int i=1;i<=n;i++) cin>>x[i];
		for(int i=1;i<=n;i++) cin>>y[i];
		for(int i=1;i<=n;i++)
		{
			if(x[i]==1) a.push_back(y[i]);
			else if(x[i]==2) b.push_back(y[i]);
			else c.push_back(y[i]); 
		} 
      //排序
		sort(a.begin(),a.end());
		sort(b.begin(),b.end());
		sort(c.begin(),c.end());
		reverse(a.begin(),a.end());
		reverse(b.begin(),b.end());
		reverse(c.begin(),c.end());
		db sum1=0;
		int x;
		for(int i=1;i<=8;i++)
		{
			cin>>x;
			sum1+=x;
		}
		sum1/=8.0;
      //分类
		if(a.size()>=7 && c.size()>=1 && 1.0*(c[0]+a[0]+a[1]+a[2]+a[3]+a[4]+a[5]+a[6])/8.0>=sum1-2)
		{
			cout<<"Yes\n";
			continue;
		}
		if(a.size()>=6 && c.size()>=2 && 1.0*(c[0]+c[1]+a[0]+a[1]+a[2]+a[3]+a[4]+a[5])/8.0>=sum1-2)
		{
			cout<<"Yes\n";
			continue;
		}
		if(a.size()>=5 && c.size()>=3 && 1.0*(c[0]+c[1]+c[2]+a[0]+a[1]+a[2]+a[3]+a[4])/8.0>=sum1-2)
		{
			cout<<"Yes\n";
			continue;
		}
		if(a.size()>=6 && b.size()>=1 && c.size()>=1 && 1.0*(c[0]+b[0]+a[0]+a[1]+a[2]+a[3]+a[4]+a[5])/8.0>=sum1-2)
		{
			cout<<"Yes\n";
			continue;
		}
		if(a.size()>=5 && b.size()>=1 && c.size()>=2 && 1.0*(c[0]+c[1]+b[0]+a[0]+a[1]+a[2]+a[3]+a[4])/8.0>=sum1-2)
		{
			cout<<"Yes\n";
			continue;
		}
		if(a.size()>=4 && b.size()>=1 && c.size()>=3 && 1.0*(c[0]+c[1]+c[2]+b[0]+a[0]+a[1]+a[2]+a[3])/8.0>=sum1-2)
		{
			cout<<"Yes\n";
			continue;
		}
		cout<<"No\n";
	}
	return 0;
}

```

---

## 作者：Stone_Xz (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P10317)

## 题意

> 给定 $n$ 张牌，每张牌都有类别和等级，问能否从中选出八张，使得其中有 $0 \sim 1$ 张建筑牌，还有 $1 \sim 3$ 张法术牌，且 $选出的牌的等级平均值 \ge 对手的八张牌等级平均值 - 2$。

## 分析

 - 由于我们希望选出的八张牌等级平均值更大，所以可以考虑贪心，将 $n$ 张牌按等级从大到小排序。
 
 - 细节很多，每种牌的总张数都要符合题目中的限制，需要判断。
 
 - 要注意，法术牌最少 $1$ 张，所以如果已经选了 $7$ 张牌时，还没选一张法术牌，剩下的牌中就只能去选法术牌了，否则卡组将不合法。

 - 由于求平均值和比较平均值可能会出现精度问题，所以取胜条件可以看成 $选出的牌的等级之和 \ge 对手的牌等级之和 - 2 \times 8$。
 
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int T, n, tot, cnt[5];
int sum_x, sum;
bool flag;

struct node{
	int lv, c;
}a[100005];

void init()
{
	sum_x = 0; // 对手的等级之和 
	sum = 0; // 自己的等级之和 
	tot = 0; // 选出的总张数 
	cnt[1] = cnt[2] = cnt[3] = 0; // 每种牌的张数 
	flag = false; // 用于判断是否要强制选法术牌 
	return ;
}

bool cmp(node x, node y)
{
	return x.lv > y.lv;
}

void work()
{
	init();
	
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i].c;
	for(int i = 1; i <= n; i++)
		cin >> a[i].lv;
	for(int i = 1; i <= 8; i++)
	{
		int x;
		cin >> x;
		sum_x += x;
	}
	
	sort(a + 1, a + 1 + n, cmp);
	
	for(int i = 1; i <= n; i++)
	{	
		if(tot == 7 && cnt[3] == 0) // 要强制选法术牌 
			flag = true;
			
		if((a[i].c == 2 && cnt[a[i].c] == 1) || (a[i].c == 3 && cnt[a[i].c] == 3) || (flag && a[i].c != 3))
			continue; // 不能选 
		
		cnt[a[i].c]++;
		tot++;
		sum += a[i].lv;
		
		if(tot == 8) break;
	}
	
	if(cnt[3] < 1 || tot < 8) // 没选法术牌或没选够八张牌 
		cout<< "No\n";
	else if(sum >= sum_x - 16) // 可以取胜 
		cout << "Yes\n";
	else
		cout << "No\n";
	return ;
}

int main()
{
	cin >> T;
	while(T--)
		work();
	return 0;
}
```

---

## 作者：Ivan422 (赞：2)

题目大意：选择 $8$ 张卡牌，至少包含 $1$ 张法术牌，要求平均等级大于对方平均等级减去二，判断是否可能满足要求。

思路：使用贪心，先按照等级从大到小排序，再选最大等级的法术牌，接着选上 $7$ 张牌，等级和尽量大，注意处理牌上线的问题，最后判断即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=10;
int n,x[M],jz,fs,al,bs,cc,cho;
struct card{int a,c;}a[N];
bool cmp(card x,card y){return x.a>y.a;}
void solve(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i].c;
    for(int i=1;i<=n;i++)cin>>a[i].a;
    bs=0;
    for(int i=1;i<=8;i++){cin>>x[i];bs+=x[i];};
    sort(a+1,a+n+1,cmp);jz=0;fs=0;al=0;cc=0;cho=0;
    for(int i=1;i<=n;i++)if(a[i].c==3){fs++;cc++;al+=a[i].a;cho=i;break;}
    if(cho==0){cout<<"No\n";return;}
    for(int i=1;i<=n;i++)if(cho!=i){
        if(a[i].c==2&&jz==1)continue;
        if(a[i].c==3&&fs==3)continue;
        if(cc==8)break;
        if(a[i].c==2)jz++;
        if(a[i].c==3)fs++;
        al+=a[i].a;cc++;
    }
    if(al*1.0/cc>=bs/8.0-2&&cc==8){cout<<"Yes\n";}
    else cout<<"No\n";
    return;
}
signed main(){
    int t;cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：Stars_visitor_tyw (赞：1)

## P10317 [SHUPC 2024] 小A的皇室战争卡组 题解
### 分析
由于数据不大，考虑暴力。

将自己的牌堆按等级从大到小排序，然后枚举 $n$ 张牌：

1. 若法术牌一张没选但当前牌种类还能再选并且总选择的牌数还到 $7$ 张时，跳过。

2. 若当前选过法术牌且牌种类还能再选并且总选择的牌数还没到 $8$ 张时，加上这张牌的等级贡献。

3. 反之不做操作。

最后判断是否选了法术牌以及是否选了 $8$ 张牌以及平均等级是否不低于对方等级 $-2$ 即可。

注意：由于精度问题，不能用小数取平均数直接判断，直接用己方等级总和是否不低于对方等级总和减去 $2\times 8$ 即可。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t, n, x[105];
struct node
{
	int c, d;
}a[500005];
bool cmp(node x, node y)
{
	return x.d>y.d; 
}
int cnt[45], amx[45];
signed main()
{
	for(cin>>t;t;t--)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i].c;
		}
		for(int i=1;i<=n;i++)
		{
			cin>>a[i].d;
		}
		int cnt1=0;
		for(int i=1;i<9;i++)
		{
			cin>>x[i];
			cnt1+=x[i]*1;
		}
		sort(a+1,a+1+n,cmp);
		cnt[1]=cnt[2]=cnt[3]=0;
		int cntc=0;
		int cnt2=0;
		amx[2]=1, amx[3]=3, amx[1]=1000000000;
		for(int i=1;i<=n;i++)
		{
			if(cnt[a[i].c]<amx[a[i].c]&&cntc<8)
			{
				if(cnt[3]==0&&a[i].c!=3&&cntc==7)
				{
					continue;
				}
				cnt[a[i].c]++,cntc++;
				cnt2+=a[i].d;
			}
		}
		if(cntc!=8||cnt[3]==0)
		{
			cout<<"No\n";
			continue;
		}
		if(cnt2>=cnt1-16)
		{
			cout<<"Yes\n";
		}
		else
		{
			cout<<"No\n";
		}
	}
	return 0;
}
```

---

## 作者：x1489631649 (赞：1)

### [题目链接](https://www.luogu.com.cn/problem/P10317)
# 输入 
1. 第一行，数据组数 $t(1 \le t \le 10^3)$。
1. 每组数据的第一行，卡牌数量 $n(1 \le n \le 10^5)$。
1. 每组数据的第二行，卡牌种类 $x(1 \le x \le 3)$。
1. 每组数据的第三行，卡牌等级 $y(1 \le y \le 15)$。
1. 每组数据的第四行，对方的卡牌等级。
# 输出
每组数据都输出 `Yes` 或者 `No`。
# 题意
1. 己方出战卡牌的平均等级 $\ge$ 对手出战卡牌的平均等级 -2 。
1. 卡牌种类为二的卡牌数量为 $0 \sim 1$。
1. 卡牌种类为三的卡牌数量为 $1 \sim 3$。
# 分析
用一个结构体储存这些信息，将这些信息排序，判断上面列举的条件，满足就加，不满足就跳过，注意细节即可。
 # Code
#### 错误代码

```
#include<bits/stdc++.h> 
using namespace std;
struct node{
	int x,y;
}q[500005];
bool cmp(node x,node y)
{
	return x.y>y.y;
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int s=0,a,n,s1=0,s2=0,s3=0,ans=0,flag;
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>q[i].x;
		for(int i=1;i<=n;i++)
			cin>>q[i].y;
		for(int i=1;i<=8;i++)
		{
			cin>>a;
			s+=a;
		}
		sort(q+1,q+n+1,cmp);
		for(int i=1;i<=n;i++)
		{
			if(q[i].x==3)
			{
				ans+=q[i].y;
				s2++;
				s3++;
				flag=i;//易错点，要标记，防止在下列循环中重复累计。 
				break;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(i!=flag)
			{
				if(q[i].x==2&&s1<1)
				{
					s1++;
					s3++;
					ans+=q[i].y; 
				}
				else if(q[i].x==3&&s2<3)
				{
					s2++;
					s3++;
					ans+=q[i].y;
				}
				else{//易错点，不能用否则连接，防止不是第一类型的卡牌也计入总数。 
					s3++;
					ans+=q[i].y;
				}
				if(s3==8)
					break;
			}
		}
		if(s3==8&&ans*1.0/8>=s*1.0/8-2)//易错点，记住要以小数来比较。 
			cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	} 
}  
```

#### 正确代码

```
#include<bits/stdc++.h> 
using namespace std;
struct node{
	int x,y;
}q[500005];
bool cmp(node x,node y)
{
	return x.y>y.y;
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int s=0,a,n,s1=0,s2=0,s3=0,ans=0,flag;
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>q[i].x;
		for(int i=1;i<=n;i++)
			cin>>q[i].y;
		for(int i=1;i<=8;i++)
		{
			cin>>a;
			s+=a;
		}
		sort(q+1,q+n+1,cmp);
		for(int i=1;i<=n;i++)
		{
			if(q[i].x==3)
			{
				ans+=q[i].y;
				s2++;
				s3++;
				flag=i;
				break;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(i!=flag)
			{
				if(q[i].x==2&&s1<1)
				{
					s1++;
					s3++;
					ans+=q[i].y; 
				}
				if(q[i].x==3&&s2<3)
				{
					s2++;
					s3++;
					ans+=q[i].y;
				}
				if(q[i].x==1)
				{
					s3++;
					ans+=q[i].y;
				}
				if(s3==8)
					break;	
			}
		}
		if(s3==8&&ans*1.0/8>=s*1.0/8-2)
			cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	} 
}  
```

**错误代码为个人编写时遇到的问题，仅供参考。**

---

## 作者：gaoxinyang666 (赞：0)

# 分析
在多张牌挑八张组成一个合理的卡组,零到一张建筑牌一到三张法术牌，部队牌则没有限制。
#### 注意必须一张法术！
取所有牌的平均等级。
#### 注意用双精度浮点数变量！
只要出战卡牌的平均等级大于等于对手出战卡牌的平均等级 -2 就能获胜。
# 思路
用结构体先输入所有的牌，按等级大小排序，从大到小拿注意张数限制在特殊判断保证一张法术。
```c
#include<iostream>
#include<algorithm>
using namespace std;
struct s {
	int bianhao;
	int dengji;
} a[1000005];//开多点
bool cmp(s b, s c) {
	return b.dengji > c.dengji;
}
int main() {
	int T, b2[10] = {};//用来存放选好的牌组
	cin >> T;
	for (int i = 0; i < T; i++) {
		int n;
		int t;
		cin >> n;
		for (int j = 0; j < n; j++) {
			scanf("%d", &a[j].bianhao);//输入
		}
		double shu = 0, shu1 = 0;
		for (int j = 0; j < n; j++) {
			scanf("%d", &a[j].dengji);
		}
		for (int j = 0; j < 8; j++) {
			scanf("%d", &t);
			shu += t;
		}
		shu /= 8.0;
		sort(a, a + n, cmp);
		int a1 = 0, b1 = 0, sum = 0;
		for (int j = 0; j < n; j++) {
			if (sum == 7 && b1 == 0 ) {//注意特殊判断保证一张法术
				if (a[j].bianhao == 3) {
					b2[sum++] = a[j].dengji;//放入已选的牌组
					b1++;
					break;
				}
			} else {
				if (sum <= 7) {//控制张数
					if (a[j].bianhao == 2) {
						if (a1 == 0) {//控制数量
							a1++;
							b2[sum++] = a[j].dengji;//放入已选的牌组
						}
					} else if (a[j].bianhao == 3) {//同理
						if (b1 < 3) {
							b1++;
							b2[sum++] = a[j].dengji;//放入已选的牌组
						}
					} else {
						b2[sum++] = a[j].dengji;//放入已选的牌组
					}
				} else if (sum == 8) {
					break;
				}
			}
		}
		if (a1 > 1 || b1 > 3 || b1 < 1 || sum != 8) {//判断能否组成一个牌组
			printf("No\n");
			continue;
		}
		for (int j = 0; j < 8; j++) {
			shu1 += b2[j];
		}
		shu1 /= 8.0;
		if (shu1 >= (shu - 2)) {//判断能否赢
			printf("Yes\n");
		} else {
			printf("No\n");
		}
	}
	return 0;
}
```

题解就到这里了。

感谢观看。

别忘了给个关注。

---

## 作者：J_Kobe (赞：0)

### 思路
用三个数组分别存每种卡牌，排一下序，枚举每一种合理的组合，再判断一下这套组合的总和是否大于等于对手总和减去十六，如果是的话就代表这套组合是可以的。

由于这题的数据范围还是比较小的，所以直接暴力是可以过的。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100005;
int t, n, x[N], k[N], a[N], b[N], c[N];
struct node{
	int c, a;
} q[20];
bool cmp(node a, node b)
{
	return a.a > b.a;
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie();cout.tie();
	cin >> t;
	while (t--)
	{
		cin >> n;
		int cnt1 = 0, cnt2 = 0, cnt3 = 0;
		for (int i = 1; i <= n; i++)
		{
			cin >> k[i];
		}
		for (int i = 1; i <= n; i++)
		{
			int aa;
			cin >> aa;
			if (k[i] == 1)
			{
				cnt1++;
				a[cnt1] = aa;
			}
			else if (k[i] == 2)
			{
				cnt2++;
				b[cnt2] = aa;
			}
			else
			{
				cnt3++;
				c[cnt3] = aa;
			}
		}
		sort(a + 1, a + 1 + cnt1);
		sort(b + 1, b + 1 + cnt2);
		sort(c + 1, c + 1 + cnt3);
		int sum = 0;
		for (int i = 1; i <= 8; i++)
		{
			cin >> x[i];
			sum += x[i];
		}
		bool flag = false;
		for (int i = 0; i <= 1; i++)
		{
			for (int j = 1; j <= 3; j++)
			{
				if (cnt2 < i || cnt3 < j || cnt1 < (8 - i - j))
				{
					continue;
				}
				int ans = 0;
				for (int k = 1; k <= i; k++)
				{
					ans += b[cnt2 - k + 1];
				}
				for (int k = 1; k <= j; k++)
				{
					ans += c[cnt3 - k + 1];
				}
				for (int k = 1; k <= 8 - i - j; k++)
				{
					ans += a[cnt1 - k + 1];
				}
				if (ans >= sum - 16)
				{
					flag = true;
					break;
				}
			}
			if (flag == true)
			{
				break;
			}
		}
		if (flag == true)
		{
			cout << "Yes\n";
		}
		else
		{
			cout << "No\n";
		}
	}
	return 0;
}

```

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10317)
## 解题思路
贪心题。

我们先把小 A 的卡组分成 $1,2,3$ 三类，分别存在数组里。小 B 的卡组就直接加和。这时得特判一下，当法术卡没有，或者部队卡小于 $4$，直接输出 `No`。

再把 $1,2,3$ 三类卡组按等级从大到小排序，再把每种可能列出来，建筑卡数组从 $0$ 到 $\min\{1,建筑卡张数\}$ 遍历，法术卡数组从 $1$ 到 $\min\{3,法术卡张数\}$ 遍历，那剩下的就是部队卡。最后，比较等级。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][100010],b[100010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	BREAK:
	while(T--)
	{
		memset(a,0,sizeof a);
		int n,t[10]={},sum=0,ss=0;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>b[i];
		for(int i=1;i<=n;i++)
		{
			int x;
			cin>>x;
			t[b[i]]++;
			a[b[i]][t[b[i]]]=x;
		}
		for(int i=1;i<=8;i++)
		{
			int x;
			cin>>x;
			ss+=x;
		}
		if(!t[3]||t[1]<4)
		{
			cout<<"No\n";
			goto BREAK;
		}
		sort(a[1]+1,a[1]+t[1]+1,greater<int>());
		if(t[2])sort(a[2]+1,a[2]+t[2]+1,greater<int>());
		sort(a[3]+1,a[3]+t[3]+1,greater<int>());
		for(int i=0;i<=min(1,t[2]);i++)
			for(int j=1;j<=min(3,t[3]);j++)
			{
				int now=0;
				for(int k=1;k<=i;k++)now+=a[2][k];
				for(int k=1;k<=j;k++)now+=a[3][k];
				for(int k=1;k<=8-i-j;k++)now+=a[1][k];
				sum=max(sum,now);
			}
		if(sum>=ss-16)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```
可是，怎么 WA 了呢？

原来，当 $8-i-j>部队卡张数$，当前方案是不可行的。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][100010],b[100010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin>>T;
	BREAK:
	while(T--)
	{
		memset(a,0,sizeof a);
		int n,t[10]={},sum=INT_MIN,ss=0;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>b[i];
		for(int i=1;i<=n;i++)
		{
			int x;
			cin>>x;
			t[b[i]]++;
			a[b[i]][t[b[i]]]=x;
		}
		for(int i=1;i<=8;i++)
		{
			int x;
			cin>>x;
			ss+=x;
		}
		//a[1][]:部队卡 t[1]:4~7
		//a[2][]:建筑卡 t[2]:0~1
		//a[3][]:法术卡 t[3]:1~3
		if(!t[3]||t[1]<4)
		{
			cout<<"No\n";
			goto BREAK;
		}
		sort(a[1]+1,a[1]+t[1]+1,greater<int>());
		if(t[2])sort(a[2]+1,a[2]+t[2]+1,greater<int>());
		sort(a[3]+1,a[3]+t[3]+1,greater<int>());
		for(int i=0;i<=min(1,t[2]);i++)
			for(int j=1;j<=min(3,t[3]);j++)
			{
				if(8-i-j>t[1])continue;
				int now=0;
				for(int k=1;k<=i;k++)now+=a[2][k];
				for(int k=1;k<=j;k++)now+=a[3][k];
				for(int k=1;k<=8-i-j;k++)now+=a[1][k];
				sum=max(sum,now);
			}
		if(sum>=ss-16)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：Claire0918 (赞：0)

我们发现，尽量取较大的值可以使平均值更大。

所以直接对原数组进行排序，从大到小依次取 $8$ 个即可。

需要注意：
+ 建筑牌、法术牌数量不能超限。
+ 法术牌必须要取 $1$ 张，所以先取最大的一张法术牌。

特别注意无解情况：
+ 没有法术牌（显然不存在合理卡组）。
+ 在上述要求下无法取到 $8$ 张。

模拟即可。

为了避免 `double` 运算，可以在最后的判断时将式子两侧都乘 $8$，化为 $sum1 \ge sum2 - 16$。

**多测注意清空！**

Code: 
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

const int maxn = 1e5 + 10;

int t, n, cnt2, cnt3, sum1, sum2;
pair<int, int> a[maxn];

int main(){
    scanf("%d", &t);
    while (t--){
        sum2 = cnt2 = 0;
        cnt3 = 1;
        scanf("%d", &n);
        for (int i = 1; i <= n; i++){
            scanf("%d", &a[i].second);
        }
        int max3 = 0;
        for (int i = 1; i <= n; i++){
            scanf("%d", &a[i].first);
            if (a[i].second == 3){
               max3 = max(max3, a[i].first); 
            }
        }
        for (int i = 1; i <= 8; i++){
            int buf;
            scanf("%d", &buf);
            sum2 += buf;
        }
        if (!max3){
            printf("No\n");
            continue;
        }
        sum1 = max3;
        sort(a + 1, a + n + 1, greater<pair<int, int> >());
        bool flag = true;
        int cnt = 1;
        for (int i = 1; i <= n && cnt < 8; i++){
            if (a[i].second == 3 && flag){
                flag = false;
                continue;
            }
            if (a[i].second == 2 && cnt2 == 1 || a[i].second == 3 && cnt3 == 3){
                continue;
            }
            sum1 += a[i].first;
            cnt++;
            if (a[i].second == 2){
                cnt2++;
            }
            if (a[i].second == 3){
                cnt3++;
            }
        }
        if (cnt < 8){
            printf("No\n");
            continue;
        }
        printf(sum1 >= sum2 - 16 ? "Yes\n" : "No\n");
    }

return 0;
}
```

---


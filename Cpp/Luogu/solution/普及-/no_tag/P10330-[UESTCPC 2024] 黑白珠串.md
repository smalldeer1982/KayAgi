# [UESTCPC 2024] 黑白珠串

## 题目描述

你是宽窄巷子里的一位手艺人。这天，顾客向你订购一条黑白珠串。黑白珠串形如一条链，其上排列着黑色和白色的珠子。顾客还向你提出了 $k$ 个条件，每个条件如下：

- 给定 $x,y$，要求黑白珠串中存在至少一个子串，满足子串的长度为 $x$，且恰好包含 $y$ 个黑珠。

这里，子串指黑白珠串中的一段连续的珠子。

请你为顾客构造出符合以上所有条件的黑白珠串，且满足珠串的长度最小。为了保证你构造的珠串满足上述条件，你还要对于每个条件，给出一个满足条件的子串的位置。

## 样例 #1

### 输入

```
3
3 1
3 2
2 0```

### 输出

```
4
1100
1
0
2```

## 样例 #2

### 输入

```
4
2 1
3 3
4 0
3 2```

### 输出

```
7
1110000
2
0
3
1```

# 题解

## 作者：shlsew (赞：10)

## P10330 [UESTCPC 2024] 黑白珠串

这道题我刚看到时也很懵，不知道从何入手。结果一分析样例，我发现了规律，于是秒切了这道题。

我们发现样例输出的字符串都是先一些 `1`，再是一些 `0`。发现 `1` 的数量刚好是 $y$ 序列中的最大值，`0` 的数量是 $x_i-y_i$ 的最大值。

$y_i$ 指长度为 $x_i$ 的子串中 `1` 的数量，所以 $y$ 序列中的最大值，就是 `1` 的数量。而 $x_i-y_i$ 指长度为 $x_i$ 的子串中 `0` 的数量，所以 $x_i-y_i$ 的最大值，就是 `0` 的数量。

最后起始点输出只需输出 `1` 的总数 $-$ $y_i$ 即可。

## std
```cpp
#include <iostream>
using namespace std;
const int N=1e5+10;
int x[N],y[N];
int main(){
	int k;
	cin>>k;
	int n=-1e9,m=-1e9;
	for(int i=1;i<=k;i++){
		cin>>x[i]>>y[i];
		n=max(n,y[i]);
		m=max(m,x[i]-y[i]);
	}
	cout<<n+m<<"\n";
	for(int i=1;i<=n;i++)cout<<"1";
	for(int i=1;i<=m;i++)cout<<"0";
	cout<<"\n";
	for(int i=1;i<=k;i++)cout<<n-y[i]<<"\n";
	
	return 0;
}
```

---

## 作者：Vae_L (赞：4)

这题还是很水的，赛时 10 分钟秒掉。

[题目传送门](https://www.luogu.com.cn/problem/P10330)

首先观察样例，发现 $1$ 都在最前面，$0$ 都在后面，从这个角度考虑很容易发现可行，且一定是最优解，因为这种写法可以使每一个字符都得到充分的使用，具体证明就不写了，多模拟几组数据应该能看出来。

设 $cnt1$ 为 $1$ 的个数，$cnt0$ 为 $0$ 的个数，则 $cnt1$ 应为最大的 $y[i]$，$cnt0$ 应为最大的 $x[i]-y[i]$。
 
$cnt1$ 的值是很好看出来的，这里主要解释一下 $cnt0$。（~~模拟样例找到的规律~~）

其实和 $cnt1$ 的值没有本质差别，$x[i]-y[i]$ 也就是 $0$ 的个数，和 $cnt1$ 一样取最大值即可。

最后输出长度和 $cnt1$ 个 $1$，$cnt0$ 个 $0$ 即可。

考虑第二个问题。

其实也很简单，既然有 $y[i]$ 个 $1$，那么就有 $x[i]-y[i]$ 个 $0$，满足这个条件的位置就是 $0$ 和 $1$ 的交界处，至于起始点自然就是 $cnt1-y[i]$。（多模拟几组数据就看出来了）

代码如下：

 ```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,t,cnt1,cnt2,x[100005],y[100005];
string s;
signed main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
    {
    	cin>>x[i]>>y[i];
    	cnt1=max(cnt1,y[i]);
    	cnt2=max(cnt2,x[i]-y[i]);
	}
	cout<<cnt1+cnt2<<"\n";
	for(int i=1;i<=cnt1;i++) cout<<1;
	for(int i=1;i<=cnt2;i++) cout<<0;
	cout<<"\n";
	for(int i=1;i<=t;i++)
	{
		cout<<cnt1-y[i]<<"\n";
	}
    return 0;
}
```

---

## 作者：__Cyn__ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10330)

#### 思路：

对于 $3$ 个问题，黑白珠子的个数特别重要。根据顾客给的几个条件我们得出，第 $i$ 个条件有 $y_i$ 颗黑珠子，有 $x_i-y_i$ 颗白珠子（$x$ 数组表示每个字串的长度）,那么黑珠子的数量就是 $y$ 数组里的最大值，而白珠子就是 $x$ 数组里的最大值减去 $y$ 数组里的最大值，所以第 $1$ 个问题就解决了。

第 $2$ 个问题，我们就把黑珠子全放到左边，白珠子都放到右边生成一个 `01` 字串，黑珠子为 `0`，白珠子为 `1`，然后在输出。

第 $3$ 个问题，由于黑珠子在前，对于第 $i$ 个条件，我们要保证第 $y_i\le$ $y$ 数组里的最大值，且 $x$ 数组里的最大值减去 $y$ 数组里的最大值 $>$ $y$ 数组里的最大值。根据推算，字串开头也就是 $y$ 数组里的最大值 $-$ $y_i$。

**注意：本题珠串的位置编号从 $0$ 开始。**

AC Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
int x[100001], y[100001], mx = 0, my = 0;//条件总珠子中的最大值和分别表示条件黑珠子中的最大值
int main () {
	int k;
	cin >> k;
	for (int i = 1; i <= k; i++) {
		cin >> x[i] >> y[i];
		mx = max (y[i], mx);
		my = max (x[i] - y[i], my);
	}
	cout << mx + my << endl;
	for (int i = 1; i <= mx; i++) cout << '1';
	for (int i = 1; i <= my; i++) cout << '0';
	cout << endl;
	for (int i = 1; i <= k; i++) cout << mx - y[i] << endl; //从 0 开始 
	return 0;
} 
```

---

## 作者：ZRZ0818 (赞：2)

## 题目简述

要求构造一个 `01` 字符串，对于每个 $1\le i \le k$，满足字符串有至少一个子串长度为 $x_i$ 且恰好有 $y_i$ 个 `0`。

## 思路分析

对于一个仅包含 `01` 的字符串，若它长度为 $x$，有 $y$ 个 `0`，那么它也就会有 $x-y$ 个 `1`。

于是问题转化为构造一个对于每个 $1 \le i \le k$ 都满足恰好有 $y_i$ 个 `0` 和 $x_i-y_i$ 个 `1` 的字符串。

那么我们如何保证上述构造字符串最短呢？

想要让字符串最短，就需要尽可能让子串共享字符。  
观察样例不难发现（~~其实都不用看样例~~）：我们可以构造一段连续的 `1` 加一段连续的 `0` 组成的字符串（如 `111000` ），这样能大最限度地让子串共享字符（不理解的可以看样例）。

对于一段连续的 `1` 的长度和一段连续的 `0` 的长度就分别等于 $y_i$ 和 $x_i-y_i$ 的最大值。

而子串的起始位置就是字符 `1` 的总长减去 $y_i$。

 _完整 code_ 
 
 ```cpp
#include<bits/stdc++.h>
#define in inline
#define rd read()
#define gc getchar()
#define lx (x<<3)+(x<<1)
#define MAXN int(1e6+5)

using namespace std;
struct Node{
	int x,y;
}arr[MAXN];

in int read() {
	int x =0; bool f =1; char ch =0;
	while ( ch <'0' || ch >'9') {
		if ( !(ch ^'-')) f =0;
		ch =gc;
	}
	while ( ch >='0' && ch <='9') {
		x =lx +(ch^'0');
		ch =gc; 
	}
	return f? x:(~x)+1;
}

in void write(int x) {
	static int sta[35];
	int top =0;
	do {
	   sta[top++] =x%10, x/=10;
	} while (x);
	while (top) putchar(sta[--top] +48);  
	puts(" ");
}

int main() {
	
	int n,mmax0 =0,mmax1 =0; n =rd;
	for ( int i=1; i<=n; i++) {
        arr[i].x =rd,arr[i].y =rd;
		   mmax1 =max(mmax1,arr[i].y),mmax0 =max(mmax0,arr[i].x -arr[i].y);
	}
	
	int len =mmax1+mmax0; write(len);
	for ( int i=1; i<=len; i++) {
		if ( i<=mmax1) putchar('1');
		else putchar('0');
	}
	puts(" ");
	
	for ( int i=1; i<=n; i++) 
		write(mmax1 -arr[i].y);
		
	return 0;
}
/*******

********/
```

---

## 作者：xhr123bc (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10330)
# 题意

给定 $k$ 个条件，每个条件由两个整数 $x$ 和 $y$ 组成，表示要求构造的黑白珠串中必须存在至少一个长度为 $x$ 的子串，其中恰好包含 $y$ 个黑珠。

要求构造一个满足所有条件的最短黑白珠串，并输出以下内容：

1. 黑白珠串的最小长度 $l$。
2. 一个长度为 $l$，由 `'0'` 和 `'1'` 组成的字符串，表示构造的黑白珠串。其中 `'0'` 表示白珠，`'1'` 表示黑珠。
3. $k$ 个整数，第 $i$ 个整数表示满足第 $i$ 个条件的一个子串在构造的黑白珠串中的起始位置。珠串的位置编号从 $0$ 开始。

# 解题思路

## 1. 确定珠子数量

我们可以通过枚举每个条件来确定黑珠子和白珠子的最大需求量。对于每个条件 $(x, y)$，黑珠子的需求量为 $y$，白珠子的需求量为 $x - y$。我们分别记录黑珠子和白珠子的最大需求量，最后将它们相加，就得到了总的珠子数量。

## 2. 构造黑白珠串

知道了黑珠子和白珠子的数量后，我们可以直接构造出满足条件的黑白珠串。我们先输出所有的黑珠子，再输出所有的白珠子，这样相同颜色的珠子就挨在一起了。

为什么相同颜色的珠子可以挨在一起呢？这是因为我们在确定每个条件的子串位置时，可以根据黑珠子和白珠子的相对位置来计算，而不需要考虑它们的绝对位置。

## 3. 确定每个条件的子串位置

对于每个条件 $(x, y)$，我们需要在构造出的黑白珠串中找到一个长度为 $x$,包含 $y$ 个黑珠子的子串。

如果黑珠子在白珠子的前面，我们可以用黑珠子的总数减去条件要求的黑珠子数量，得到的差值就是子串的起始位置。

如果白珠子在黑珠子的前面，我们可以用白珠子的总数减去条件要求的白珠子数量，得到的差值就是子串的起始位置。

通过这种方式，我们可以确定每个条件的子串位置，而不需要真正地在黑白珠串中搜索子串。

# 代码如下：
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int k;
    cin >> k;  // 读入条件数量

    int maxBlack = 0, maxWhite = 0;  // 初始化黑珠子和白珠子的最大需求量
    vector<pair<int, int>> conditions(k);  // 存储所有条件

    // 读入每个条件,并更新黑珠子和白珠子的最大需求量
    for (int i = 0; i < k; i++) {
        int x, y;
        cin >> x >> y;
        conditions[i] = {x, y};
        maxBlack = max(maxBlack, y);
        maxWhite = max(maxWhite, x - y);
    }

    int totalBeads = maxBlack + maxWhite;  // 计算总珠子数
    cout << totalBeads << endl;  // 输出总珠子数

    // 构造黑白珠串
    for (int i = 0; i < maxBlack; i++) {
        cout << 1;  // 输出黑珠子
    }
    for (int i = 0; i < maxWhite; i++) {
        cout << 0;  // 输出白珠子
    }
    cout << endl;

    // 计算并输出每个条件的子串起始位置
    for (const auto& condition : conditions) {
        int x = condition.first, y = condition.second;
        if (maxBlack - y >= 0) {
            cout << maxBlack - y << endl;  // 如果黑珠子在前,输出黑珠子总数减去条件要求的黑珠子数
        } else {
            cout << maxWhite - (x - y) << endl;  // 如果白珠子在前,输出白珠子总数减去条件要求的白珠子数
        }
    }

    return 0;
}
```

---

## 作者：hh20080501hh (赞：1)

# 题目
[题面戳我哦](https://www.luogu.com.cn/problem/P10330)

题意简述：给定 $k$ 个限制条件，对于每个限制条件，要求长度为 $x$ 的 $01$ 序列中恰好有长度为 $y$ 的只含有 $1$ 的子串。现在要构造出满足条件且长度最短的序列。

# 分析
读完题和样例之后，我们发现样例中给的输出都是先是 $1$ 后是 $0$，我们不妨大胆猜测一下，不会出现 $01$ 交错的序列比先全是 $1$ 再全是 $0$ 的序列更优（先 $1$ 后 $0$ 同理）。通过一番证明，我们发现不交错排序可以在满足 $y$ 的一点的限制同时满足 $y$ 小一点的限制，而交错排序就不行，所以不交错一定不会劣于交错排序。

确定了最优构造方案之后，我们就思考一下细节。首先，序列中 $1$ 的数量肯定是限制中需要的最大数量，序列中 $0$ 的个数则是满足了限制 $1$ 的数量后最多的多出来的长度。至于位置，则是从多出的长度对应的值开始。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+10 , INF = 0x3f3f3f3f;

int n;
int x[N] , y[N];
int mx0 = -INF , mxy = -INF;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	
	cin >> n;
	for (int i=1 ; i<=n ; i++)
	{
		cin >> x[i] >> y[i];
		mx0 = max(x[i]-y[i] , mx0) , mxy = max(y[i] , mxy);
	}
	cout << mxy+mx0; cout.put('\n');
	for (int i=1 ; i<=mxy ; i++)
	{
		cout.put('1'); 
	}
	for (int i=1 ; i<=mx0 ; i++)
	{
		cout.put('0');
	}
	cout.put('\n');
	for (int i=1 ; i<=n ; i++)
	{
		cout << mxy-y[i] << '\n';
	}
	return 0;
}

```

---

## 作者：yekc2010 (赞：1)

## 思路。

一道字符串模拟水题。

读题后发现重点：满足子串的长度为 $x$，且恰好包含 $y$ 个黑珠，求黑白珠串的最小长度。

所以只要解决黑白珠的数量就好解了。

我发现 $y$ 的数量就是子串中黑珠最多的数量，白珠就等于 $a-y$ 最大的，位置就是黑珠最多的数量减子串黑珠数量。

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;//命名空间
typedef long long ll;
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
int k,a[100001],b[100001],a1=0,b1=0;//a1表示白珠数量，b1表示黑珠数量
string s;
int main(){
    IOS;
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i]>>b[i];
		b1=max(b1,b[i]);//取最多的黑珠
		a1=max(a1,a[i]-b[i]);//取最多的白珠
	}
	for(int i=1;i<=b1;i++){//01字符串
		s+='1';
	}
	for(int i=1;i<=a1;i++){
		s+='0';
	}
	int l=s.size();//长度
	cout<<l<<"\n"<<s<<"\n";//输出长度和01字符串
    for(int i=1;i<=k;i++){
		cout<<b1-b[i]<<'\n';//输出位置
	}
	return 0;
}
```

---

## 作者：Fubaogege (赞：0)

给定 $x,y$，要求黑白珠串中存在至少一个子串，满足子串的长度为 $x$，且恰好包含 $y$ 个黑珠。

这道题比较简单，把思路简单说成：

找到一个点。

**将黑珠子都构造在这个点的左边，白珠子构造在这个点的右边。**

代码：
```c
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],b[100001],maxh=0,maxb=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		maxh=max(maxh,b[i]),maxb=max(maxb,a[i]-b[i]);
	}
	cout<<maxh+maxb;cout<<endl;
	for(int i=1;i<=maxh;++i)cout<<1;
	for(int i=1;i<=maxb;++i)cout<<0;
	for(int i=1;i<=n;++i)cout<<endl<<maxh-b[i];
}
```
[AC记录。](https://www.luogu.com.cn/record/155503857)

---

## 作者：TheForgotten (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10330)

## 题目描述

给定 $n$ 次 $x,y$，要求构造出存在至少一个子串，满足子串的长度为 $x$，且恰好包含 $y$ 个 $1$ 的字符串。

## 思路

简单构造，只需要贪心求出最长的黑色珠串，在黑白相接的地方保证会出现长度为 $x$ 的字符串，只要在倒数的地方寻找 $y$ 并向右延伸 $x$ 个珠串，记录下标即可通过。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long //即使不会爆int也可以养成好习惯
using namespace std;
int k,x[100005],y[100005];
int maxx=0,maxn=0;//寻找最长的子串与黑珠数量
signed main(){
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>x[i]>>y[i];
		maxx=max(maxx,y[i]);
		maxn=max(maxn,x[i]-y[i]);
	}
	cout<<maxx+maxn<<"\n";//输出长度
	for(int i=1;i<=maxx;i++){
		cout<<1;
	}
	for(int i=1;i<=maxn;i++){
		cout<<0;
	}
	cout<<"\n";
	for(int i=1;i<=k;i++){
		cout<<maxx-y[i]<<"\n";
	}
	return 0;
}
```
> 任何一个伟大的思想，都有一个微不足道的开始。

---

## 作者：iyka (赞：0)

其实样例输出已经给了我们提示了，我们可以把黑棋放在前面，白棋放在后面，在输入时单次最多有多少个黑棋前面就放多少个黑棋，白棋亦然。在输出位置时，我们可以直接用黑棋的数量来定位子串位置。

### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,lb,lh,x,y[N];
signed main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    	cin>>x>>y[i], lb=max(lb,x-y[i]), lh=max(lh,y[i]); //统计黑白棋子个数
	cout<<lb+lh<<"\n";
	for(int i=1;i<=lh;++i)
		cout<<1;
	for(int i=1;i<=lb;++i)
		cout<<0;
	cout<<"\n";
	for(int i=1;i<=n;++i)
		cout<<lh-y[i]<<"\n"; //通过黑棋的个数来定位子串位置
    return 0;
}
```

---

## 作者：liwenxi1145144444 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10330)

这是一道比较简单的构造题。构造方法很简单，只需要求出最多需要多少个 $1$，多少个 $0$，然后输出一串 $1$ 和一串 $0$ 即可。位置也容易求，因为我们知道每一个串需要多少个黑珠，也知道黑珠的总个数，只需要从后往前取黑珠就行了。具体见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,x[100000],y[100000];
int main(){
	cin>>k;
	int maxx=0,maxn=0;
	for(int i=1;i<=k;i++){
		cin>>x[i]>>y[i];
		maxx=max(maxx,y[i]);//记录黑珠最大需求
		maxn=max(maxn,x[i]-y[i]);//记录白珠最大需求
	}
	cout<<maxx+maxn<<"\n";
	for(int i=1;i<=maxx;i++){
		cout<<1;
	}
	for(int i=1;i<=maxn;i++){
		cout<<0;
	}
	cout<<"\n";
	for(int i=1;i<=k;i++){
		cout<<maxx-y[i]<<"\n";//这样正好就有y[i]个黑珠，剩余长度会被后面的白珠弥补。
	}
	return 0;//完结撒花！！！
}
```

---

## 作者：_Jocularly_ (赞：0)

考虑怎么构造答案序列，我们采用一种贪心的思想，统计出白色和黑色最大的数量，把黑色全放在左边，白色全放在右边，假设第 $i$ 个 $x_{i}$ 长度的区间，有 $y_{i}$ 个黑珠子，那么就有这个区间总共就有 $x_{i} - y_{i}$ 个白珠子，每次取一下数量最大值，然后输出构造的序列即可。

第 $i$ 个条件所需要的子串在珠串中的位置取决于当前所需的黑珠子的数量，定义第 $i$ 个条件需要 $y[i]$ 个黑珠子，按照上面的构造方法求出最大的黑珠子数量，假设最大有 $black$ 个黑珠子，因为显然构造序列的总长度要大于等于子串的长度，那我们可以不考虑所需的总长度，只考虑黑珠子的个数，那么题目相当于我们需要在长度为 $black$ 的区间内，选择区间内的任意一个 $k$ 位置，使得这个位置往后的黑珠子数量为 $y[i]$ 即可，显然此时的 $k = black - y_{i}$，按照题目要求输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int x[100005],y[100005];
int black,white;
string ans;
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> x[i] >> y[i];
	}
	for(int i=1;i<=n;i++){
		black = max(black,y[i]);
		white = max(white,x[i]-y[i]);
	}
	for(int i=1;i<=black;i++){
		ans += '1';
	}
	for(int i=1;i<=white;i++){
		ans += '0';
	}
	cout << ans.size() << endl;
	cout << ans << endl;
	for(int i=1;i<=n;i++){
		cout << black - y[i] << endl;
	} 
	return 0;
}

```

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10330)
## 解题思路
因为子串的长度为 $x$，且恰好包含 $y$ 个黑珠，所以白珠有 $x-y$ 颗。

那我们把黑珠归到一遍，白珠归到一边。再对于每一个 $x$ 与 $x-y$ 都求出最大值，输出的时候就直接搞定。

设 $x$ 的最大值为 $maxn$，$x-y$ 的最大值为 $maxm$，则输出第一行是 $maxn+maxm$，第二行是 $maxn$ 个 `1`，和 $maxm$ 个 `0`。至于起始位置嘛，就是黑珠的总数减去包含的 $y$ 个黑珠，即 $maxn-y$。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100010],b[100010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,maxn=0,maxm=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
		maxn=max(maxn,b[i]);
		maxm=max(maxm,a[i]-b[i]);
	}
	cout<<maxn+maxm<<'\n'<<string(maxn,'1')<<string(maxm,'0')<<'\n';
	for(int i=1;i<=n;i++)
		cout<<maxn-b[i]<<'\n';
	return 0;
}
```

---

## 作者：RyanLi (赞：0)

传送门：[P10330 [UESTCPC 2024] 黑白珠串](https://www.luogu.com.cn/problem/P10330)

更佳的阅读体验：[洛谷 P10330 题解](https://blog.ryanli.top/index.php/archives/49/)

---

**简要题意**：构造一个存在长度为 $x_i$ 且包含 $y_i$ 个 $\texttt{1}$ 的最短的 $\texttt{01}$ 串，并给出每个子串开始的位置。

可以想到，我们只需要构造一个前半段全是 $\texttt{1}$，后半段全是 $\texttt{0}$ 的字符串即可。这样，每个子串都在这个 $\texttt{01}$ 串中间，包含几个 $\texttt{1}$ 和几个 $\texttt{0}$，就可以使得这个 $\texttt{01}$ 串最短。

我们设 $\texttt{1}$ 的个数为 $m_1$，$\texttt{0}$ 的个数为 $m_0$，则有 $m_1 = \max \limits_{i = 1}^{k} y_i$，$m_0 = \max \limits_{i = 1}^{k} (x_i - y_i)$，满足第 $i$ 个条件的子串从 $m_1 - y_i$ 开始。

``` cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10;
int k, x[N], y[N], m0, m1;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> k;
    for (int i = 1; i <= k; ++i) {
        cin >> x[i] >> y[i];
        m0 = max(m0, x[i] - y[i]), m1 = max(m1, y[i]);
    } cout << m0 + m1 << '\n';
    for (int i = 1; i <= m1; ++i) cout << 1;
    for (int i = 1; i <= m0; ++i) cout << 0;
    cout << '\n';
    for (int i = 1; i <= k; ++i) cout << m1 - y[i] << '\n';
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题意：

要求构造一个 `01` 串，使得满足 $n$ 个条件：

- 有一个长度为 $x$ 的子区间，其中 $1$ 的个数为 $y$。

且满足珠串的长度最小。

### 思路：

根据样例提示，前面全 $1$，后面全 $0$；那么考虑找到最大的一个 $Y$，使得 $[1,Y]$ 为 $1$，此时后面的条件都可以在这里找到 $y$ 个 $1$。

但是可能 $x \ne y$，那么需要向后延伸到 $Y-y+1+x-1$，找到这个的最大值即可。

时间复杂度为 $O(N \log N)$。

**这里我进行了排序，也可以直接找 $y$ 的最大值。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
const ll N=100100; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll x,y;
	ll id;
	bool operator<(const Node &rhs)const{
		return y>rhs.y;
	}
}a[N];
ll n,Max;
ll ans[N];
string s;
int main(){
	n=read();
	for(int i=1;i<=n;i++)
	  a[i]={read(),read(),i};
	sort(a+1,a+n+1);
	for(int i=1;i<=a[1].y;i++)
	  s+="1";
	for(int i=1;i<=n;i++){
		ans[a[i].id]=a[1].y-a[i].y+1;
		Max=max(Max,ans[a[i].id]+a[i].x-1);
	}
	for(int i=a[1].y+1;i<=Max;i++)
	  s+="0";
	write(Max);
	putchar('\n');
	printf("%s\n",s.c_str());
	for(int i=1;i<=n;i++){
		write(ans[i]-1);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：sansesantongshun (赞：0)

这题乍一看没有什么思路，但考虑到样例构造的 $01$ 串里都是连续几个黑珠子接上连续几个白珠子，就以此为出发点考虑解法。

对于几个条件，表示存在一个区间，有 $x$ 个珠子， $y$ 个黑珠子，可以得到有 $x-y$ 个白珠子，于是黑珠子的数量就是 $x$ 的最大值，白珠子的数量是 $x-y$ 的最大值。

然后考虑为什么这样是最优解，这样就能保证存在有任意数量黑珠子的符合要求的区间。

然后输出区间起始位置就很简单了，由于下标从 $0$ 开始，结果是黑珠子的总数减去区间要求的黑珠子数。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005][2],hei=0,bai=0;
int main()
{
	cin>>n;
	for (int i=1;i<=n;++i)
	{
		scanf("%d%d",&a[i][0],&a[i][1]);
		hei=max(hei,a[i][1]);//x最大值
		bai=max(bai,a[i][0]-a[i][1]);//x-y最大值
	}
	cout<<hei+bai<<'\n';//总数
	for (int i=1;i<=hei;++i)
	cout<<'1';
	for (int i=1;i<=bai;++i)
	cout<<'0';//构造序列
	for (int i=1;i<=n;++i)
	cout<<'\n'<<hei-a[i][1];//区间起始位置，注意下标从0开始
}
```

---

## 作者：lucasincyber (赞：0)

## 思路
我们假设构造出来的黑白珠串可以找到一个点 $x$，使 $x$ 的左边都为黑珠子，右边都为白珠子。那给出的 $k$ 个条件可以分为 $3$ 种情况：
1. 如果都为黑珠子，可以将黑珠子都构造到 $x$ 的左边；
2. 如果都为白珠子，可以将白珠子都构造到 $x$ 的右边；
3. 如果黑、白珠子都有，可以将黑珠子构造在 $x$ 的左边，将白珠子构造到 $x$ 的右边。

那其实，黑白珠串的最短长度就是白珠子需要的最小数量与黑珠子需要的最小数量的和。而最后构造出的黑白珠串的样子也能顺势得出。对于最后一个问，对于每一个条件的答案 $p_i$，就是这个字串的黑珠子的起点。

注意：珠串的位置编号从 $0$ 开始。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

int k, maxBlack, maxWhite; // maxWhite 代表需要的白珠子的数量，maxBlack 同理
int x[N], y[N];

int main()
{
	scanf("%d", &k);
	for (int i = 1; i <= k; i++)
	{
		scanf("%d%d", &x[i], &y[i]);
		maxBlack = max(maxBlack, y[i]);
		maxWhite = max(maxWhite, (x[i] - y[i]));
	}
	printf("%d\n", maxWhite + maxBlack); // 第一个问的答案
   // 第二个问的答案
	for (int i = 1; i <= maxBlack; i++) printf("1");
	for (int i = 1; i <= maxWhite; i++) printf("0");
	printf("\n");
   // 第三个问的答案
	for (int i = 1; i <= k; i++)
		printf("%d\n", maxBlack - y[i]);
	return 0;
}
```

---


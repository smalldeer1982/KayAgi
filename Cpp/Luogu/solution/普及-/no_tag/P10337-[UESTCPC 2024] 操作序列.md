# [UESTCPC 2024] 操作序列

## 题目描述

给定一个长度为 $n$ 的序列 $a_1,a_2,\ldots,a_n$。

你需要选定一个整数 $k$ $(1\leq k\leq n)$，然后对序列进行任意次操作，每次操作可以选择序列中 $k$ 个不同的位置，使得这些位置的数乘上一个相同的非零整数，最终使得序列中所有的数相等。

输出满足条件的 $k$ 的最大值。

## 样例 #1

### 输入

```
1
3
2 6 2```

### 输出

```
2```

# 题解

## 作者：Genshin_ZFYX (赞：24)

## 前言

这题代码操作并不难，但思维难度是有的，连我也去评论区看了看别人的思路才做出来的。

## 解题思路

首先，我们可以先证明一个很重要的结论：

假设有一个序列 $a$：

$2,3,4,5$

我们把除了 $a_1$ 以外的所有数都乘 $2$：

$2,6,8,10$

我们再拿原来的 $a$，把这里 $a_1$ 除以 $2$：

$1,3,4,5$

我们会发现，虽然值不同，但是每个数之间的倍数关系是不变的！这就跟老师给全班同学发了了一台电脑（~~怎么可能~~），唯独你没有被发到。这个例子和老师到你家去抢了一台电脑一样，每名同学间电脑的数量差一样的（其实就是等式的性质，只不过有多个数）。

所以说，把一个长度为 $n$ 的序列中 $n-1$ 个数的值乘一个相同的数，等于拿剩下的那个数除以这个相同的数。

我们不难想到，当所有 $a_i$ 的值相同时，我们可以把 $n$ 个数都乘一遍，而且只用操作一次。

而 $a_i$ 的值并不完全相同时，我们进行 $n-1$ 次操作，每次操作把第 $i$ 个数 $a_i$ 除以它自己，就可以最后变成一个每项都为 $1$ 的序列了。

结论：$a_i$ 相同时，答案为 $n$ ，否则为 $n-1$。

AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define I return
#define love 0
#define FIRESTARS ;
int a[10005];
signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    int t,n,f=1;cin>>t;
    while(t--)
    {
    	f=1;
    	cin>>n;
    	for(int i=1;i<=n;i++)cin>>a[i];
    	for(int i=2;i<=n;i++)
    	if(a[i]!=a[i-1])
    	{
    		f=0;
			break;
		}
		cout<<(f?n:n-1)<<'\n';
	}
	I love FIRESTARS
}

```

---

## 作者：Aveiro7 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P10337)

## 题目大意

给定一个长度为 $n$ 的序列 $a_1,a_2,\ldots,a_n$。

你需要选定一个整数 $k$ $(1\leq k\leq n)$，然后对序列进行任意次操作，每次操作可以选择序列中 $k$ 个不同的位置，使得这些位置的数乘上一个相同的非零整数，最终使得序列中所有的数相等。

输出满足条件的 $k$ 的最大值。

## 思路

* 当序列中所有数**都相等**时，每一个位置都可以视作第 $k$ 个位置，所以 $k$ 取 $n$ 时即可。

* 当序列中**有数与其他数不相等时**，$k$ 的最大值为 $n-1$，因为数列中肯定至少要有一个数乘一个非零自然数才能让数列中的数都相等。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxN = 1e6 + 10;
int a[maxN],T,n,i;
bool f;
int main() {
    cin>>T;
    while(T--)
	{
        f=0;
        cin>>n;
        for(i=1;i<=n;i++)
		{
            cin>>a[i];
            if (i>1 and a[i]!=a[i-1])
			f=1;
        } 
		cout<<n-f<<endl;
	}
	return 0;
}
```

---

## 作者：zhjx2023 (赞：4)

### 思路
题意:给你 $ n $ 个数，让你求能对不同位置乘同一个数，使所有数相等的最大值。

1. 输入。
2. 如果序列中的第一个元素与任何其他元素不相等，则 $ k $ 的最大值为 $ n-1 $，因为至少有一个元素需要乘以一个非零整数才能使所有元素相等。
3. 如果序列中的所有元素都相等，则 $ k $ 的最大值为 $ n $，因为任何位置都可以选择作为 $ k $ 个位置。
4. 输出。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
//#define cin std:cin
//#define cout std:cout
using namespace std;
const ll N = 1e6 + 10, MOD = 1e9 + 7;
ll n, T, a[N];
bool flag = 0;
int main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while (T--) {
		cin >> n;
		flag = false;
		for (ll i = 1; i <= n; i++) {
			cin >> a[i];
			if (a[i - 1] != a[i])	flag = true;
		}
		if (flag)	cout << n - 1 << "\n";
		else cout << n << "\n";
	}
	return 0;
}

```
完结撒花

---

## 作者：shlsew (赞：3)

## P10337 [UESTCPC 2024] 操作序列

这道题思路很简单，如果每次让 $n-1$ 乘一个数 $x$，就相当于没有操作的那一个数除以 $x$。

于是我们就可以愉快的写出代码了：
```cpp
#include <iostream>
using namespace std;
int a[1000005];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		cout<<n-1<<"\n";
	}
	return 0;
}
```
但是上面的代码出现了一个问题，就是有一种特殊情况被我们忽略了，如果 $a$ 序列的所有数全部相等，那就应该输出 $n$ 自己。

## AC CODE
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[1000005];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		int flag=1;
		for(int i=1;i<=n;i++)cin>>a[i];
		sort(a+1,a+1+n);
		for(int i=1;i<n;i++){
			if(a[i]==a[i+1])flag++;
		}
		if(flag==n)cout<<n<<"\n";
		else cout<<n-1<<"\n";
		
	}
	return 0;
}
```

---

## 作者：TheForgotten (赞：1)

[P10337 [UESTCPC 2024] 操作序列](https://www.luogu.com.cn/problem/P10337)

## 题意简述
选定一个整数 $k$，任意次操作中可以选择序列中 $k$ 个不同的位置，使得这些位置的数乘上一个相同的非零整数，最终使得序列中所有的数相等。

## 思路
$k$ 最大取值是 $n$，但是只有操作序列中所有数相等才能取此值，于是可以次而追求 $n-1$，但是每次将 $n-1$ 个数同时乘以一个数是，也可以看成是剩下的那个数除以了它，所以只需要考虑两种情况。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[100005];
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		bool flag=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(a[i]!=a[1]){
				flag=1;
			}
		}
		if(flag){
			cout<<n-1<<"\n";
		}else{
			cout<<n<<"\n";
		}
	}
	return 0;
}
```
> 任何一个伟大的思想，都有一个微不足道的开始。

---

## 作者：封禁用户 (赞：1)

### 题意

给定一个整数序列，通过每次选择序列中 $k$ 个不同位置并乘以相同非零整数，使所有数相等，求最大的 $k$ 值。

### 做法

首先，观察题目描述，可以得出以下几个关键结论：

1. 如果序列中的所有数字一开始就已经相等，那么不需要进行任何操作，$k$ 的最大值为 $n$，即序列的长度。
2. 如果序列中的数字不全部相等，那么至少有一个数字是“特殊”的，因为它需要被乘以某个非零整数来与其他数字相等。这个“特殊”的数字只会有一个，因为如果有多个不同的数字，那么它们无法仅通过乘以同一个数来变得相等。

根据上面的结论，~~就可以直接水代码了~~。代码基本思路如下：

1. 读取测试用例数量 $T$。
2. 对于每个测试用例，读取序列的长度 $n$ 和序列中的每个数字。
3. 遍历序列，检查是否有与第一个数字不同的数字。如果找到了这样的数字，那么设置 `ans = 1` ~~（**警钟蕨烂**）~~，表示序列中至少有一个数字需要被操作。
4. 根据 $ans$ 的值，输出 $k$ 的最大值。如果 `ans = 1`，表示至少有一个数字需要被操作，因此最大的 $k$ 值为 $n - 1$（因为有一个数字是“特殊”的，不需要操作）。否则，所有数字都相等，最大的 $k$ 值为 $n$。

###### 代码：
```cpp
#include <iostream>
using namespace std;
#define ll long long
const int MAXN = 10e5 + 10;
int a[MAXN], ans = 1;
int main(){
	int T;
    cin >> T;
    while(T--){
        int n;
        cin >> n;
        for(int i = 1;i <= n;i++){
            cin >> a[i];
            if(a[1] != a[i]){
            	ans = 1;
			}
        }
        if(ans == 1){
        	cout << n - 1 << endl;
		}
        else{
        	cout << n << endl;
		}
    }
    return 0;
}
```

---

## 作者：Mason123456 (赞：1)

## P10337

### 思路

贪心！

对于输入数据 $a_i$，考虑将所有值都乘一个数，使得 $a_{1\sim n} = a_i$。很显然，对于这个答案，每个数 $a_j$ 要乘 $\large\frac{a_i}{a_j}$。于是，对于每个数，就有 $n-1$ 个 $\large\frac{a_i}{a_j}$。于是我们发现，当所有数都乘上自己的 $n-1$ 个 $\frac{a_i}{a_j}$ 时，所有元素一样。

所以，对于任意情况的数列 $S$，$k_{\max}$ = $n-1$。

最后，特判一下，当 $S$ 中所有数相同时，$k=n$​。（这应该不用解释了吧）

用下面的公式理解一下 $n-1$ 怎么来的：

$\Large a_1 = \frac{a_2}{a_1} \times \frac{a_3}{a_1} \times \frac{a_4}{a_1} \dots \frac{a_n}{a_1}$

$\Large a_2 = \frac{a_1}{a_2} \times \frac{a_3}{a_2} \times \frac{a_4}{a_2} \dots \frac{a_n}{a_2}$

$\Large \dots$

$\Large a_n = \frac{a_1}{a_n} \times \frac{a_2}{a_n} \times \frac{a_3}{a_n} \dots \frac{a_{n-1}}{a_n}$

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int t, n;
int a[N];
int main(){
	cin>>t;
	while(t--){
		bool f = 0;
		cin>>n;
		for(int i = 1;i <= n;i++){
			cin>>a[i];
		}
		for(int i = 2;i <= n;i++){
			if(a[i] != a[i-1]){
				cout<<n-1<<"\n";
				f = 1;
				break;
			}
		}
		if(!f){// 特判！
			cout<<n<<"\n";
		}
	}
	return 0;
} 
```

---

## 作者：D0000 (赞：1)

序列全部相等输出 $n$，因为可以不进行任何操作；

否则输出 $n-1$，因为答案为 $n$ 的话怎么操作它们之间的相对大小都不会变，而将整个序列 $n-1$ 个数都乘上同一个数就相当于把整个序列乘上这个数再将 $1$ 个数除以这个数，相当于就操作了 $1$ 个数，最后肯定能相等，因此答案为 $n-1$。

即：
$$ans=\left\{\begin{matrix} 
  n,(a_0=a_1=a_1=\cdots=a_n), \\  
  n-1,\text{otherwise}.
\end{matrix}\right. $$

---

## 作者：dinghongsen (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P10337)

### 解题思路

很简单，只需要看序列里的值是否都相等，相等就输出 $n$，反之输出 $n - 1$。

### code
```cpp
# include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int T;
int a[N];
int main() {
    cin >> T;
    while(T--) {
        int n, x;
        bool flag = 0;
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            if (a[1] != a[i]) {
                flag = 1;
            }
        }
        if (flag) {
            cout << n - 1 << endl;
        } else {
            cout << n << endl;
        }
    }
    return 0;
}
```

---

## 作者：__qkj__ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10337)
## 解题思路
既然是输出满足条件的 $k$ 的最大值，那么就选择尽量多的位置。

如果数组全部都相等，$k$ 就是 $n$。

否则，$k=n$ 不行，因为数组有不同的地方。那 $k=n-1$ 呢？

对于每一个 $a_i$，我们把它乘上除他以外的所有数，这样既能保证数组每一个数相同，也能使 $k$ 最大，为 $n-1$。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--)
	{
		int n,f=1;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			if(i>1&&a[i]!=a[i-1])f=0;
		}
		if(f)cout<<n<<'\n';
		else cout<<n-1<<'\n';
	}
	return 0;
}
```

---

## 作者：AK_400 (赞：1)

# [P10337 操作序列](https://www.luogu.com.cn/problem/P10337)题解

我们发现如果每个元素都相同，那么 $k=n$ 时最大，这很显然，相同元素乘相同的数肯定相同。

那么不同时怎么办？

我们发现这些元素的积一定是他们中任意一个的倍数，于是我们可以对一个元素外的所有元素乘这个元素。

举个例子，我们记这个序列为 $a$，元素分别为 $1,2,3,\cdots ,n-2,n-1,n$。

那么操作的过程为：
 $a_1$ | $a_2$ | $a_3$ | $\cdots$ |$a_{n-2}$  | $a_{n-1}$ | $a_n$ |
| -----------: | -----------: | ----------: | -----------: | -----------: | -----------: | -----------:|
| $1$ |$2$  | $3$ |$\cdots$ |$n-2$|$n-1$|$n$|  
| $1$ |$2\times 1$ | $3\times 1$ |$\cdots$ |$(n-2)\times 1$|$(n-1)\times 1$|$n\times 1$| 
| $1\times 2$ |$2\times 1$       | $3\times 1\times 2$ |$\cdots$ |$(n-2)\times 1\times 2$|$(n-1)\times 1\times 2$|$n\times 1\times 2$|
| $\vdots$ |$\vdots$ | $\vdots$ |$\ddots$ |$\vdots$|$\vdots$|$\vdots$|
| $n!$ |$n!$  | $n!$ |$\cdots$|$n!$ |$n!$|$n!$|$n!$|

于是当元素都相等时输出 $n$，否则输出 $n-1$。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100006],t;
bool k=0;
signed main(){
    ios::sync_with_stdio(0);
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        for(int i=2;i<=n;i++){
            if(a[i]!=a[i-1]){
                cout<<n-1<<endl;
                k=1;
                break;
            }
        }
        if(k){
            k=0;
            continue;
        }
        cout<<n<<endl;
    }
    return 0;
}
```

---

## 作者：guer_loser_lcz (赞：0)

# 题解
# 分析
这是一道策略题，所以，我们考虑两种情况：都相等与否。
## 全等
显然，可以让 $k = n$。
## 不全等
结论：$k = n-1$。

首先，让每个数乘上剩下所有数一定都相等。

对于每个数来说，它都相当于已经乘了自己。

也就是整个数列操作中它不用乘自己。

所以，对于每个数来说，它都需要一个空位使它在乘它时轮空。

每次乘轮空的数。

建议按步骤手玩样例。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin>>n;
	while(n--){
		int t;
		cin>>t;
		bool f=0;
		int x,y;
		cin>>x;
		for(int i=2;i<=t;i++){
			cin>>y;//输入
			if(x!=y)f=1;//判全等，如不等则标记
			x=y;
		}
		if(f)cout<<t-1;//被标
		else cout<<t;//没
		cout<<endl;//换行
	}
	return 0;
} 
```

---

## 作者：封禁用户 (赞：0)

## 思路

首先，同志们，这道题不用担心输入，我们的 $T,n$ 绝对不可能是最坏情况，所以时间复杂度 $O(Tn)$ 可以过，而且我提交了我的 $O(Tn \log n)$ 的代码，并且已经 $AC$。

-----

首先，我们仔细观察，我们会发现我们可以进行**任意次**操作，所以这道题就结束了。因为总会有那么一次不同的数会变成相同的数，所以在有不同数的情况下总是输出 $n - 1$，但如果全部相同，那么直接 $n$ 个数都乘上 $1$ 就可以了。

## 代码

思路简单的要死，所以不介意有一些懒得写代码的大佬借用我的代码 $AC$ 掉这道浪费时间的题：

``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int main()
{
	int T;
	cin >> T;
	while(T --)
	{
		int n;
		cin >> n;
		for(int i = 1;i <= n;++ i)
		{
			cin >> a[i];
		}
		sort(a + 1 , a + 1 + n);
		if(a[1] == a[n])
		{
			cout << n << endl;
		}
		else
		{
			cout << n - 1 << endl;
		}
	}
	return 0;
}
```
~~记得点个赞哩~~

---

## 作者：tder (赞：0)

我们要使 $k$ 尽可能大，最大即为 $k=n$，此时每次操作会将序列 $\{a_n\}$ 中的所有数同乘，因此不会影响 $a_i$ 之间的大小关系。要使得其满足对于 $1\le i<j\le n$ 都有 $a_i=a_j$，则当且仅当初始时满足条件才符合。

而后，我们不妨再取 $k=n-1$，此时将 $n-1$ 个数同乘 $p$，因为我们只考虑相对的大小关系，因此相当于将剩下那个数除以 $p$。有了上面的思考，我们便有策略：

- 选定 $k=n-1$；
- 共操作 $n$ 次；
- 第 $i$ 次操作时，将除 $a_i$ 外的所有元素同乘 $a_i$，这一操作相当于将 $a_i$ 除以 $a_i$，即变为 $1$。

最终相当于所有 $a_i$ 均为 $1$，即相等。

你也可以这么理解，进行如上操作后所有的 $a_i$ 均为 $\displaystyle\prod_{j=1}^n a_j$。

---

```python
t = int(input())
while t:
    n = int(input())
    a = input().split()
    b = 1
    for i in range(1, n):
        if(a[i] != a[i - 1]):
            print(n - 1)
            b = 0
            break
    if b:
        print(n)
    t = t - 1
```

---

## 作者：__Sky__Dream__ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P10330)

## 题目大意
找到一个整数 $k$，在序列中选择 $k$ 个不同位置，使得这些位置上的数乘上相同的非零数结果相等，求 $k$ 的最大值。

## 解题思路
~~一发入魂！~~

分两种情况：

1. 当这 $n$ 个数全部相等时，$k$ 的最大值就是 $n$。
1. 当这 $n$ 个数不全部相等时，由于他每次都要选 $k$ 个不同位置上的数乘上一个相同的数，所以 $k=n$ 永远不可能有解。其实我们可以发现，只要 $k$ 为 $[1,n-1]$ 中的数，就是有解的，此时 $k$ 的最大值就是 $n-1$ 。

## AC Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,a[100001];
bool bo;
int main()
{
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--)
	{
		bo=false;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			if(a[1]!=a[i]) bo=true;
		}
		if(bo) cout<<n-1<<"\n";
		else cout<<n<<"\n";
	}
	return 0;
}
```
拜拜！

---

## 作者：Hulless_barley (赞：0)

[P10337 [UESTCPC 2024] 操作序列](https://www.luogu.com.cn/problem/P10337)

# 思路
不难发现 $1\le k\le n$。

当 $k=n$ 的时候 $a_1=a_2=\ldots=a_n$。所以当序列中所有元素相等时输出 $n$ 就行了。

若序列元素不等时怎么办呢？进一步思考。设 $\operatorname{lcm}(a_1,a_2,\ldots,a_n)=x$，$w$ 为任意正整数，则序列所有元素都是 $x\times w$ 的因数。再设 $w$ 为所有的 $\frac{x}{a_i}$ 的乘积，即 $w=\frac{x^n}{a_1\times a_2\times\ldots\times a_n}$。每次选中 $a_i$，将其乘上 $\frac{x\times w}{a_i}$，最终的值都会变成 $x\times w$，此时 $k$ 的值为 $1$，显然不是最优解。但是，在排列组合中，$C_n^m=C_n^{n-m}$，因为选 $m$ 个相当于选择 $n-m$ 个不选（有点拗口，看懂就行），~~虽然这道题与排列组合没什么关系，但我们可以借助一下排列组合的思想~~。选 $1$ 个数乘上 $\frac{x\times w}{a_i}$，相当于选 $n-1$ 个数除以它。这不就迎刃而解了嘛，答案就是 $n-1$。~~这么神奇的吗。~~

码风比较奇怪，凑合着看吧。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;//读取无用的一行
int a,b,n,m;
int main(){
	int t;cin>>t;
	while(t--){
		scanf("%d",&n),m=n;//因为 n 变动了，所以用 m 来保存 n
		scanf("%d",&a);
		while(--n){
			scanf("%d",&b);
			if(a!=b){
				printf("%d\n",m-1);//当发现数列不全相等时，输出 m-1
				getline(cin,s);//这行作废了，用一个字符串读取
				goto loop;//正好跳过 printf("%d\n",m)
			}
		}
		printf("%d\n",m);//如果都相等就输出 m
		loop:continue;
	}
	return 0;
}
```

---

## 作者：xinxin2022 (赞：0)

# 题意
对于一个长为 $n$ 的数组，需要通过若干次，每次对 $k$ 个整数乘以一个非零整数的操作，最终达到数组中所有数相等的目的。问 $k$ 最大能达到多少。

# 思路

分两种情况讨论：

当数组中的所有数相等时，可令 $k=n$ ,即对所有数都乘以一个正整数，所有数仍然相等。

当数组中的数不绝对两两相等时，则 $k=n-1$ 是 $k$ 的最大值，因为当 $k=n$ 时无法达到目的。

# AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100002],c;
int main()
{
    int t;
    cin>>t;
    for(int j=1;j<=t;j++)
    {
        int n,k=n;
        scanf("%d",&n);scanf("%d",&a[1]);
        for(int i=2;i<=n;i++)
        {
            scanf("%d ",&a[i]);
            if(a[i]!=a[i-1]) k=n-1;
            //当出现不相等时，k-1
        }
        cout<<k<<'\n';
    }
    return 0;
}
```

---

## 作者：lpx666666 (赞：0)

## 题意
给定一个长度为 $n$ 的序列，选择 $k$ 个数相乘使所有数相等，求 $k$ 的**最大值**。
## 思路
所有人肯定第一想到的就是枚举，去枚举 $k$，判断是否符合要求。

但这种时间复杂度一定是很大的。

有的人可能还会继续去想二分，不不不，你在枚举的道路上越走越远了。

不妨换个思路想，首先这些数是最后一定会相等的，而乘的数也是不定的，所以我们乘 $k - 1$ 个数并不断换不乘的数最后一定可以使相等。

### 注意
如果所有数相等时只需所有数同时乘即可。

## 代码
又到你们最喜欢的环节了。
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int t,n,arr[100001]; 
int main(){
	cin>>t;
	while(t--){//t组数据 
		int o=1;//状态变量 
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>arr[i];//输入 
		}
		for(int i=2;i<=n;i++){
			if(arr[i]!=arr[i-1]){//特判是否全部相等 
				o=0;
				break;
			}
		}
		cout<<n-1+o<<endl;//全部相等输出n,否则输出n-1 
	}
	return 0;//华丽收尾 
}

```

---

## 作者：DHT666 (赞：0)

## 题意
给定 $n$ 个整数，每次操作可以选择序列中 $k\ (1\le k \le n)$ 个整数，把它们全部乘上一个非零整数，可进行任意次操作，求把序列所有数变成相同数的最大 $k$，多测。

## 思路
思维题。

可以发现，选 $n-1$ 个整数，全部乘上 $a$，等同于把没有选中的那个数除以 $a$。

故考虑把所有数变成 $1$，$k$ 为 $n-1$。

有特殊情况，即 $n$ 个数全部相等，$k$ 为 $n$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 10;

int t, n;
int a[N];

signed main() {
	cin >> t; // 多测
    while(t--) {
        cin >> n;
        bool f = 0;
        for(int i = 1;i <= n;i++) {
            cin >> a[i];
            if(a[1] != a[i]) f = 1; // 有不相等
        }
        if(f) cout << n - 1 << endl; // 如上
        else cout << n << endl;
    }
    
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P10337 题目](https://www.luogu.com.cn/problem/P10337)

### 解题思路
我们可以将序列中的数全部操作成 $a_1\times a_2\times\cdots\times a_n$，对于每一个 $i(1\le i\le n)$，$a_i$ 需要乘上 $a_1\times a_2\times\cdots\times a_{i-1}\times a_{i+1}\times\cdots\times a_n$。

不难发现，对于每一个 $i(1\le i\le n)$，$a_1, a_2,\cdots,a_{i-1},a_{i+1},\cdots,a_n$ 都乘上了 $a_i$。

所以我们可以通过 $n-1$ 次操作使得序列中所有的数相等，第 $i(1\le i<n)$ 次操作选择 $a_1, a_2,\cdots,a_{i-1},a_{i+1},\cdots,a_n$ 这 $n-1$ 个数乘上 $a_i$。

但是当所有数都相同时，很明显 $k$ 最大为 $n$。

所以最终答案就是，当 $a_1=a_2=\cdots=a_n$ 时，$k$ 最大为 $n$，否则 $k$ 最大为 $n-1$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		int a1,pd=0;
		cin>>a1;
		for(int i=1;i<n;i++)
		{
			int x;
			cin>>x;
			if(x!=a1)
				pd=1;
		}
		if(pd==0)
			cout<<n<<"\n";
		else
			cout<<n-1<<"\n";
	}
    return 0;
}
```

---

## 作者：_Jocularly_ (赞：0)

首先确定，如果假设区间有 $n$ 个元素，当区间的每一个值都相等的时候，答案肯定为区间的长度，即 $k = n$，因为不管乘什么数，区间都相等。当区间内有不同的值，那么我们有 $k = n-1$ 的取数策略。证明：如果我们给区间的每 $n-1$ 个数都乘剩下位置对应的在原来数组里的元素，那么最后所有的数都会变为所有元素的乘积。如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/exup2c1p.png)

用绿色圈出的是剩下没选的位置和这个位置在原数组对应的位置，红色圈出的是这次要乘的区间。首先选择二和三，没被选的数的位置是三，对应的原数组位置上的是四，那么把选的数都乘四。第二次操作选择十二和四，没被选的数的位置是一，对应的原数组位置上的是二，那么同样的都乘二。第三次操作同理。最后经过三次操作，每一个数都变成了二十四，即 $2 \times 3 \times 4 = 24$，至此证明完毕。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t; 
int n;
int flag;
int a[100005];
int main(){
	cin >> t;
	while(t--){
		flag = 0;
		cin >> n; 
		for(int i=1;i<=n;i++){
			cin >> a[i];
		}
		for(int i=2;i<=n;i++){
			if(a[i] != a[i-1]){
				flag = 1;
				break;
			}
		}
		if(flag) cout << n-1 << endl;
		else cout << n << endl;
	}
	return 0;
}

```

---

## 作者：xzz_0611 (赞：0)

[题目传送门](/problem/P10337)
# 分析
首先，我们知道，当这 $n$ 个数全部相等时，$k$ 的最大值就是 $n$。

那如果不相等呢，$k$ 就不可能为 $n$ 得值了，因为每次他都要选择 $k$ 个不同位置上的数乘上一个相同的数，把几个不同的数同时乘上相同的数是永远不可能相等的。

那怎么算呢？其实，如果我们细心的话，我们也可以发现，在数字不相等时，$k$ 的取值只要为区间 $[1,n-1]$ 中的任意一个数都肯定是有解的，只不过可能会很复杂而已。

既然这样，在数字不相等时，$k$ 的最大值肯定是 $n-1$。
# code
```cpp
#include<iostream>
#define ll long long
using namespace std;
int T,a[100000],n;
bool flag;
int main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		flag=false;//初始设为全部相等
		cin>>n;
		for(int i=0;i<n;++i) {
			cin>>a[i];
			if(a[0]!=a[i]) {//判断是否全部相等
				flag=true;
				break;//只要找到一个不相等就退出
			}
		}
		if(flag) cout<<n-1<<endl;//不相等输出n-1
		else cout<<n<<endl;//相等输出n
	}
	return 0;
}
```

---

## 作者：RyanLi (赞：0)

传送门：[P10337 [UESTCPC 2024] 操作序列](https://www.luogu.com.cn/problem/P10337)

更佳的阅读体验：[洛谷 P10337 题解](https://blog.ryanli.top/index.php/archives/50/)

---

**简要题意**：找到一个最大的整数 $k$，使得任意次在序列中选择 $k$ 个不同的位置，这些位置的数乘上相同的非零整数，最终所有数相等。

我们分两种情况考虑：

- 序列中所有数都**相等**时：给整个序列同时乘任意一个相同数就可以保持所有数都相等，$k$ 直接取 $n$ 即可。
- 序列中所有数**不相等**时：因为给 $n - 1$ 个数同时乘一个数，相当于给剩下的数除以这个数，因此总有使序列中所有数相等的方案，$k$ 取 $n - 1$。

``` cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10;
int t, n, a[N];
bool flag;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    for (cin >> t; t; --t) {
        flag = false;
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            if (i > 1 && a[i] != a[i - 1]) flag = true;
        } cout << n - flag << '\n';
    } return 0;
}
```

---

## 作者：Fubaogege (赞：0)

## [P10337 [UESTCPC 2024] 操作序列](https://www.luogu.com.cn/problem/P10337)
## 题目意思
给你 $n$ 个数，问让他们乘上同一个数 $k$，输出 $k$ 的最大值。
## 思路
这题有两种情况：

当 $a_i$ 不相等，我们要让他同乘一个 $k$。这时 $k$ 取 $n-1$。因为至少要有一个数乘以一个非 $0$ 整数才能使所有数相等。

当 $a_i$ 相等，我们直接取最大值 $n$，因为他们都相等，不管乘几都成立，所以我们可以直接取最大值 $n$。

代码（单词询问）：
```c
		cin>>n;
		flag=0;
		for (int i=1;i<=n;i++) {
			cin>>a[i];
			if(a[i-1]!=a[i])flag=1;//不相等。
		}```c

		cout<<n-flag;cout<<endl;
```

## 解释代码
`cout<<n-flag;`

这里为什么是 `n-flag` 呢：

- 当 `flag=1` 不相等，取 $n-1$，且 `flag` 也等于 $1$，所以刚好减 `flag`。
- 当 `flag=0` 相等，取 $n$，且 `flag` 也等于 $0$，所以刚好减 `flag`。

综上所述，输出为 `n-flag`。

---


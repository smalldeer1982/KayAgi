# 「SMOI-R1」Queue

## 题目背景

签到题……

## 题目描述

有一个人数为 $n$ 的队伍，队伍中第 $i$ 个人编号为 $i$。

从第一个人依次给后面的那个人传一个数，直到传到第 $n$ 个人。给后面的那个人传数的规则为：

- 第一个人的数为 $1$。
- 如果这个人的编号为奇数，那么给后面的人传的数是他现在的数**按位与**上后面那个人的编号。
- 如果这个人的编号为偶数，那么给后面的人传的数是他现在的数**按位异或**上后面那个人的编号。

求出传给第 $n$ 个人的数字。但是求一个的太好求了，所以你要求 $t$ 种情况的。

## 说明/提示

### 样例解释

对于第二组数据：

- 第一个人向下一个人传的数是 $1\operatorname{and}2=0$。
- 第二个人向下一个人传的数是 $0\operatorname{xor}3=3$。
- 第三个人向下一个人传的数是 $3\operatorname{and}4=0$。
- 第四个人向下一个人传的数是 $0\operatorname{xor}5=5$。

所以答案是 $5$。

### 数据范围
**本题采用捆绑测试**。

subtask 编号|$t\leq$| $n\leq$| 分值
-|-|-|-
$1$|$10^2$|$10^5$|$20$
$2$|$10^6$|$10^7$|$20$
$3$|$10^6$|$10^{18}$|$60$

对于 $100\%$ 的数据,保证 $1\le t\le10^6,1\le n\le 10^{18}$。

## 样例 #1

### 输入

```
3
1
5
10```

### 输出

```
1
5
8```

# 题解

## 作者：myzzym (赞：7)

（~~稍微打下表就可以得到答案的规律题~~）

结论：当 $n\bmod 4=1$ 时答案为 $n$。

当 $n\bmod 4=2$ 时答案为 $n-2$。

当 $n\bmod 4=3$ 时答案为 $3$。

当 $n\bmod 4=0$ 时答案为 $0$。

我们可以通过暴力求出答案序列为 $1,0,3,0,5,4,3,0,\ldots,x,x-2,3,0$，很容易找到规律，下面讲一下为什么会出现这种情况。

我们发现第 $4r$ 个人的值都是 $0$，那有没有可能不为 $0$ 呢？假设我们已经求得第 $4r$ 个人的值为 $0$，则第 $4r+1$ 个人的值也就为 $4r+1$，而第 $4r+2$ 的第二位以后的值与 $4r+1$ 一致，所以只会把前两位清零，所以值为 $4r$，第 $4r+3$ 个人的第二位以后的值也是一致的，异或后第二位以后的值变成 $0$，而第 $4r+2$ 个人的数前两位的值是 $0$，所以异或后值为 $3$，第 $4r+4$ 个人前两位是 $0$,所以 $4r$ 的值一定为 $0$，相应的 $4r+1,4r+2,4r+3$ 的值也如上文所说。

例子：第 $4$ 到第 $8$ 个人数的变化：$0_{(2)}\to101_{(2)}\to100_{(2)}\to11_{(2)}\to0_{(2)}$。

---

## 作者：liaoxingrui (赞：6)

## Content

给你一个 $t$ 和 $t$ 个 $n$，对于每个 $n$ 都有一个人数为 $n$ 的队伍，队伍中第 $i$ 个人编号为 $i$。第一个人有一个值为 $1$，他需要向后传：

- 如果这个人的编号为奇数，那么给后面的人传的数是这个数**按位与**上后面那个人的编号。

- 如果这个人的编号为偶数，那么给后面的人传的数是这个数**按位异或**上后面那个人的编号。

## Solution

我们可以通过打表来找到规律，也可以自己来推理。

通过样例解释，就可以发现有些答案为 $0$，那我们就可以从这个点来想。通过打表发现，每当 $n \equiv 0 \pmod 4$ 时，答案为 $0$。

继续往后推因为现在的值为 $0$，则下一个值（$i$ 已经到下一个）为 $0 \operatorname{xor} i$。也就是每当 $n \equiv 1 \pmod 4$ 时，答案为 $n$。

现在的值为 $i$，则下一个值（$i$ 已经到下一个）为 $(i - 1) \operatorname{and} i$。因为当 $n \equiv 0 \pmod 4$ 时，$i$ 在二进制下的后两位肯定是 $0$，再下一个值的最后一位就是 $1$，再下一位的倒数第二个值为 $1$。那我们 $\operatorname{and}$ 过后的值的后两位就为 $0$，就相当于把 $i$ 减去了 $2$。也就是每当 $n \equiv 2 \pmod 4$ 时，答案为 $n - 2$。

再下一个 $i$ 在二进制下就都是 $1$，而现在的值是 $i - 2$，则下一个值（$i$ 已经到下一个）就是 $((i - 1) - 2) \operatorname{xor} i$，因为只有最后两位不一样，其它都是一样的，所以它的答案就是 $3$。也就是每当 $n \equiv 3 \pmod 4$ 时，答案为 $3$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long a;
int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%lld",&a);
		int cnt=a%4;
		if(!cnt)
			putchar('0');
		if(cnt==1)
			cout<<a;
		if(cnt==2)
			cout<<a-2;
		if(cnt==3)
			putchar('3');
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：zhengpie (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10405)

### 1.思路

看到题目，没有思路，怎么办？

先考虑**暴力**。（当然正解肯定不是暴力）

写出暴力之后，发现**答案序列**是这样的：
 $$1,0,3,0,5,4,3,0,\cdots,x,x-2,3,0$$ 
于是猜测
 $$ans = {\begin{cases}0 & n \equiv 0 \pmod 4 \\ n & n \equiv 1 
\pmod 4 \\ n - 2 & n \equiv 2 \pmod 4 \\ 3 & n \equiv 3 \pmod 4\end{cases}}$$ 

考虑使用[数学归纳法](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/5155524?fr=ge_ala)证明上述命题。

当 $\lfloor n \div 4 \rfloor = 0$ 时，猜测显然成立。

当 $\lfloor n \div 4 \rfloor = k$ 时，假设命题成立，下证命题对 $\lfloor n \div 4 \rfloor = k + 1$ 时也成立。
1. $n \div 4 = k + 1$ 时，$n - 1 \equiv 3 \pmod 4$，那么 $n - 1$ 的数是 $3$。又因为 $n$ 为 $4$ 的倍数，所以 $n$ 的二进制数码的最后两位为 $00$，而 $3$ 的最后两位为 $11$，他们按位与运算后必为 $0$，即 $n$ 的数为 $0$。
2. $n \div 4 = k + 1 \cdots\cdots 1$ 时，$n - 1 \equiv 0 \pmod 4$，那么 $n - 1$ 的数是 $0$。又因为 $\forall x \in \mathbf{R},x \oplus 0 = x$，所以 $n$ 的数为 $n$ 自己。
3. $n \div 4 = k + 1 \cdots\cdots 2$ 时，$n - 1 \equiv 1 \pmod 4$，那么 $n - 1$ 的数是 $n - 1$。又因为 $n$ 的二进制数码的最后两位为 $10$，而 $n - 1$ 的最后两位为 $01$，他们按位与运算后末两位必为 $00$，而在二进制数码下除后两位外，剩下的数码都相同，故 $n$ 的数为 $n - 2$。（最后两位从 $10$ 变成 $00$）
4. $n \div 4 = k + 1 \cdots\cdots 3$ 时，$n - 1 \equiv 2 \pmod 4$，那么 $n - 1$ 的数是 $n - 3$。此时 $n - 3 \equiv 0 \pmod 4$，即 $n - 3$ 的二进制数码的后两位为 $00$，又因为 $n$ 的二进制数码后两位为 $11$，而除后两位外，剩下的数码都相同，故他们按位异或后，得到 $3$，即 $n$ 的数是 $3$。

综上，由**归纳假设**知，对于 $\forall x \in \mathbf{R}$，都有
 $$ans = {\begin{cases}0 & n \equiv 0 \pmod 4 \\ n & n \equiv 1 
\pmod 4 \\ n - 2 & n \equiv 2 \pmod 4 \\ 3 & n \equiv 3 \pmod 4\end{cases}}$$ 

### 2.完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n;
signed main()
{
    ios::sync_with_stdio(0);//注意，不优化常数会挂（该题需要较快的读入方式）
    cin>>t;
    while(t--)
    {
        cin>>n;
        switch(n % 4)
        {
            case 0:{cout<<0<<endl;break;}
            case 1:{cout<<n<<endl;break;}
            case 2:{cout<<n - 2<<endl;break;}
            case 3:{cout<<3<<endl;break;}
        }
    }
    
    return 0;
}
```

### 3.题外话

说到快读快写，大家可以参考[这里](https://www.luogu.com.cn/paste/b31wic1d)。当然，一般用 ```scanf``` 或是 ```ios::sync_with_stdio(0)``` 就可以了。

---

## 作者：GXZJQ (赞：0)

# P10405 Queue 题解

[题目链接](https://www.luogu.com.cn/problem/P10405)

## 题目大意

给定一个传递方式，求出传给第 $n$ 个人的数字。

## 题目分析

> 按位与：当且仅当两个数这一位上均为 $1$ 时，这一位上的结果为 $1$，其他情况均为 $0$。

> 按位异或：当且仅当两个数这一位上的数字不相同时，这一位上的结果为 $1$，其他情况均为 $0$。

比赛的时候没有想到，这竟然是一道找规律的题目。

首先，浅浅编一个打表的程序，看一下小范围数据的结果是什么。然后我们就可以得出如下结论：

- 当 $n \bmod 4 = 1$ 时，答案就是 $n$；
- 当 $n \bmod 4 = 2$ 时，答案就是 $n-2$；
- 当 $n \bmod 4 = 3$ 时，答案就是 $3$；
- 当 $n \bmod 4 = 0$ 时，答案就是 $0$。

这是为什么呢？下面给出我的论证：

由于第 $4k$ 个人的值为 $0$，那么第 $4k+1$ 个人的值必为 $4k+1$，因为第 $4k$ 个人的值必为一个偶数，按照第二种变换方式变换，根据按位异或的底层实现逻辑即可得出值为 $4k+1$（第 $4k$ 个人所有的二进制位均为 $0$，第 $4k+1$ 个人在二进制位储存使有 $0$ 也有 $1$，但按位异或后相当于没有改变）。

之后来看第 $4k+2$ 个人的情况，跟上面一样，在底层二进制存储时，$4k+2$ 在第二位（这里是从右往左数的）以后的值与 $4k+1$ 一致，按位与后也就相当于减去一个 $2$（这两位全部都变为 $0$），变为 $n-2$。

同理可得，第 $4k+3$ 个人的答案为 $3$，按照规律直接可以写出代码，但是本题需要注意输入优化：

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int t;
int main() {
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
	cin >> t;
    while (t--) {
        cin >> n;
        if (n % 4 == 0) cout << 0 << endl;
        else if (n % 4 == 1) cout << n << endl;
        else if (n % 4 == 2) cout << n - 2 << endl;
        else cout << 3 << endl;
    }
	return 0;
}
```

---

## 作者：_radio_ (赞：0)

# P10405 「SMOI-R1」Queue 题解

## 题意

有编号为 $1\sim n$ 的 $n$ 个人传数，规则如下：

- 第一个人的数为 $1$。
- 如果这个人的编号为奇数，那么给后面的人传的数是他现在的数按位与上后面那个人的编号。
- 如果这个人的编号为偶数，那么给后面的人传的数是他现在的数按位异或上后面那个人的编号。

关于按位与和按位异或的定义和性质可参考 [oi-wiki](https://oi-wiki.org/math/bit/)。

## 规律

使用如下程序打表：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010];
int main(){
	cin>>n;
	a[1]=1;
	for(int i=1;i<n;i++)
		if(i&1) a[i+1]=a[i]&(i+1);
		else a[i+1]=a[i]^(i+1);
	for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";
	return 0;
}
```

当 $n=30$ 时，结果如下

```cpp
1 0 3 0 5 4 3 0 9 8 3 0 13 12 3 0 17 16 3 0 21 20 3 0 25 24 3 0 29 28
```

设 $n=4x+y(0\le y\le 3)$，不难发现如下规律

- 当 $y=0$ 时，$a_i=0$
- 当 $y=1$ 时，$a_i=4x+1$
- 当 $y=2$ 时，$a_i=4x$
- 当 $y=3$ 时，$a_i=3$

~~照此规律即可 AC~~

## 证明

设当 $x=z,y=0$ 时，$a_i=0$，尝试证明 $x=z+1,y=0$ 时 $a_i=0$。

注：以下默认 $x=z$。

由于是位运算，我们不妨设 $u$ 为 $x$ 的二进制。形象一点说，是代表 $x$ 二进制的字符串。

首先考虑 $y=0$，当前编号 $4x$ 为偶数，下一个值为当前值 $0$ 异或其编号 $4x+1$，显然，其结果为 $4x+1(u01_{(2)})$。

接下来考虑 $y=1$，当前编号 $4x+1$ 为奇数，下一个值为当前值 $4x+1(u01_{(2)})$ 与上其编号 $4x+2(u10_{(2)})$，观察二进制易得结果为 $4x(u00_{(2)})$。

而后考虑 $y=2$，当前编号 $4x+2$ 为偶数，下一个值为当前值 $4x(u00_{(2)})$ 异或其编号 $4x+3(u11_{(2)})$，同样观察二进制得结果为 $3(11_{(2)})$。

最后是 $y=3$，当前编号 $4x+3$ 为奇数，下一个值为当前值 $3(11_{(2)})$ 与上其编号 $4x+4$。这里不给出二进制，但我们知道其最后两位为 $00_{(2)}$。根据与的性质可得结果为 $0$。

## 代码

~~这都要给代码？（大雾~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		if(n%4==1) cout<<n<<"\n";
		else if(n%4==2) cout<<n-2<<"\n";
		else if(n%4==3) cout<<3<<"\n";
		else cout<<0<<"\n";
	}
	return 0;
}
```

---

## 作者：tder (赞：0)

打表可以发现规律。令 $f(n)$ 表示答案，则有：

$$
f(n)=
\begin{cases}
0,&n\bmod4=0\text{ or }n=2 \\
n,&n\bmod4=1 \\
3,&n\bmod4=3 \\
n-1,&\text{otherwise}.
\end{cases}
$$

下面我们不妨通过模拟的方式来证明。

- 初始时 $f(1)=1=(0001)_2$；
- 传递给 $f(2)=f(1)\text{ and }2=(0001)_2\text{ and }(0010)_2=(0000)_2=0$；
- 传递给 $f(3)=f(2)\text{ xor }3=(0000)_2\text{ xor }(0011)_2=(0011)_2=3$；
- 传递给 $f(4)=f(3)\text{ and }4=(0011)_2\text{ and }(0100)_2=(0000)_2=0$；
- 传递给 $f(5)=f(4)\text{ xor }5=(0000)_2\text{ xor }(0101)_2=(0101)_2=5$；
- 传递给 $f(6)=f(5)\text{ and }6=(0101)_2\text{ and }(0110)_2=(0100)_2=4$；
- 传递给 $f(7)=f(6)\text{ xor }7=(0100)_2\text{ xor }(0111)_2=(0011)_2=3$；
- 传递给 $f(8)=f(7)\text{ and }8=(0011)_2\text{ and }(1000)_2=(0000)_2=0$。

注意到对于 $3\bmod4=3$ 有 $f(3)=3$，而且其传递给的 $4\bmod4$ 一定为 $0$，即其二进制下最后两位均为 $0$，因此进行 $\text{and}$ 操作必定得出 $0$。现在我们知道对于 $n\bmod4=0$ 的 $f(n)$ 一定为 $0$。

继而 $0\text{ xor }x$ 必定等于 $x$，因此对于 $n\bmod4=1$ 的 $f(n)$ 一定为 $n$。

然后对于一个满足 $n\bmod4=1$ 的形如 $(\cdots01)_2$ 的 $n$，则有形如 $(\cdots10)_2$ 的 $(n+1)\bmod4=2$，而 $n$ 和 $n+1$ 仅有最后两位不同，进行按位与后应为 $(\cdots00)_2$，恰为 $f(n+1)=n-1$。即对于 $n\bmod4=2$ 的 $f(n)$ 一定为 $n-2$。

最后仅需证明对于 $n\bmod4=2$ 的 $n$，有 $(n-2)\text{ xor }(n+1)=3$ 即可。这是显然的，直接拆成二进制位即可。

单次询问复杂度 $O(1)$，总复杂度 $O(T)$。

---

## 作者：Genius_Star (赞：0)

### 思路：

明显求的是 $1 \operatorname{and} 2 \operatorname{xor} 3 \operatorname{and} 4 \operatorname{xor} 5 \cdots$。

打表可以很容易解决，这里提供一种推导法：

- 设四个数为 $4k,4k+1,4k+2,4k+3$。

- 易得 $4k+1 \operatorname{and} 4k+2 = 4k$，证明如下：

   - 注意到 $4k+1$ 相当于先将 $k$ 右移两位，然后将最低位赋值为 $1$，而 $4k+2$ 是将次低位赋值为 $1$，那么经过按位与之后只有 $4k$ 留下来。
   
- 易得 $4k \operatorname{xor} 4k+3 = 3$，证明如下：

   - 注意到 $4k$ 相当于先将 $k$ 右移两位，而 $4k+3$ 是将最低位和次低位赋值为 $1$，那么经过按位异或之后只有 $(11)_2=3$ 留下来。
   
- 易得 $4(k+1) \operatorname{and} 3 = 0$，证明如下：

   - 注意到 $4k$ 相当于先将 $k$ 右移两位，即最低位和次低位始终为 $0$，而 $3$ 刚好在这两位中，因此进行按位与之后值为 $0$。

- 因为又回到了 $0$，之后就是循环了。

那么得出 $n$ 的答案：

$$\begin{cases} 1 & n=1 \\ 0 & n=2 \\ 3 & n=3 \\ 0 & n \equiv 0 \pmod{4} \\ n & n \equiv 1 \pmod{4} \\ n-2 & n \equiv 2 \pmod{4} \\ 3 & n \equiv 3 \pmod{4}\end{cases}$$

时间复杂度为 $O(T)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll T,n;
int main(){
	T=read();
	while(T--){
		n=read();
		if(n==1)
		  puts("1");
		else if(n==2)
		  puts("0");
		else if(n==3)
		  puts("3");
		else{
			if(n%4==0)
			  puts("0");
			else if(n%4==1)
			  printf("%lld\n",n);
			else if(n%4==2)
			  printf("%lld\n",n-2);
			else
			  puts("3");
		} 
	}
	return 0;
}

```

---


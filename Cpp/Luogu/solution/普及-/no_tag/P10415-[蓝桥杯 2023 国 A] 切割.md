# [蓝桥杯 2023 国 A] 切割

## 题目背景

数据提供：<https://www.luogu.com.cn/discuss/838792>

## 题目描述

给定一个 $W\times H$ 的长方形，两边长度均为整数。小蓝想把它切割为很多个边长为整数的小正方形。假设切割没有任何损耗，正方形的边长至少为 $2$，不允许出现余料，要求所有正方形的大小相等，请问最多能切割出多少个?

## 说明/提示

**【样例解释 1】**

切割成 $5\times 10=50$ 个边长为 $2$ 的正方形。

**【评测用例规模与约定】**

对于 $30\%$ 的评测用例，$1\le W,H\le 1000$；  
对于 $60\%$ 的评测用例，$1\le W,H\le 10^6$；  
对于所有评测用例，$1\le W,H\le 10^9$。


## 样例 #1

### 输入

```
10 20```

### 输出

```
50```

## 样例 #2

### 输入

```
6 9```

### 输出

```
6```

## 样例 #3

### 输入

```
8 13```

### 输出

```
0```

# 题解

## 作者：huangyuze114514 (赞：16)

### 思路
求出 $W,N$ 的大于等于 $2$ 的最小公因数，把大于等于 $2$ 的最小公因数分别除 $W,N$，得出的两个数相乘即为所求。

所以我们按照思路写一篇代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long n,m;
	cin>>n>>m;
	for(long long i=2;;i++){
		if(n%i==0&&m%i==0){
			cout<<n/i*m/i;
			return 0;
		}
	}
	return 0;
}
```
发现超时了，因为本题数据较大，暴力显然不能过，所以要有一点优化。
### 代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long n,m;
	cin>>n>>m;
	int a=__gcd(n,m);//求最大公约数 
	if(a==1){//互质不符合题目条件 
		cout<<0;
		return 0;
	}
	for(int i=2;i*i<=a;i++){//最大公约数便是最大正方形的边长，因此用i*i来比较 
		if(n%i==0&&m%i==0){
			cout<<n/i*m/i;
			return 0;
		}
	}
	cout<<n/a*m/a;//没有符合条件便输出最大正方形的解 
	return 0;
}
```

---

## 作者：x11223344 (赞：4)

首先，边长一定是 $W$ 和 $H$ 的公因数。  
又因为题目里说了边长要大于 $1$，所以若 $\gcd(W, H)=1$ 则无解。  
其次，题目要求切出的个数最多，所以正方形的边长要最小，就求出 $\gcd(W, H)$ 的最小的不为 $1$ 的因数作为边长即可，设这个数为 $k$，则答案为 $\frac{a}{k} \times \frac{b}{k}$。

---

## 作者：gdz0214_and_zxb0214 (赞：4)

## 思路
题意简述：把长方形切割成若干正方形，没有余料，正方形面积相等，正方形边长不小于 $2$。

假设 $X$ 为正方形边长，易得：$X\mid W$ 且 $X\mid H$。

则 $X\mid \gcd\left(W,H\right)$。

若是您看不懂上式，看向“证明”此篇，否则跳转到“实现”。
### 证明 
若 $Y$ 为 $W$ 和 $H$ 的最大公约数。

也就是：$Y\mid W$ 且 $Y\mid H$。

变式得：$X\mid Y$。

为什么不是：$Y\mid X$ 呢？

因为 $X\le Y$。

那么这又是哪来的呢？

思考 $X$ 的性质：它是不是 $W$ 和 $H$ 的公约数？

那么请坐在屏幕前的各位想一想，$W$ 和 $H$ 的最大公约数 $Y$，和 $W$ 和 $H$ 的公约数 $X$。

哪个会更大？

明显是 $X\le Y$。
### 实现
使用贪心的策略，若想让正方形数量越多，就让边长越短。

但题目上不让边长小于 $2$。

所以实现上要从 $2$ 枚举到 $\sqrt{\gcd(W,H)}$。

为什么只要枚举到 $\sqrt{\gcd(W,H)}$ 嘞？

分类讨论大于 $\sqrt{\gcd(W,H)}$ 且小于等于 $\gcd(W,H)$  还能整除 $\gcd\left(W,H\right)$ 的数：

设此数为 $j$。

若 $j$ 为合数：它的因子比他更优，且它的一个因子一定小于等于 $\sqrt{j}$，又因 $j$ 最大为 $\gcd(W,H)$，所以它的那个因子一定小于 $\sqrt{\gcd(W,H)}$。

若 $j$ 为质数：则 $\frac{W\times H}{j}$ 一定小于 $\sqrt{\gcd(W,H)}$，比 $j$ 优秀。

最后要注意：

数据类型千千万，不开 $\texttt{longlong}$ 挂一半。

若 $\gcd(W,H)$ 为 $1$，则无解。

否则若 $2$ 到 $\sqrt{\gcd(W,H)}$ 遍历完了，仍无解，则 $W$ 和 $H$ 还剩下一个公约数，那就是它们的最大公约数：$\gcd(W,H)$。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int a,b,c;
	scanf("%lld%lld",&a,&b);
	c=__gcd(a,b);
	if(c==1){
	    printf("0\n");
	}else{
		for(int i=2;i<=c/i;i++){
			if(c%i==0){
		        printf("%lld\n",(a/i)*(b/i));
				return 0;
			}
		}
		printf("%lld\n",(a/c)*(b/c));
	}
	return 0;
}
```

---

## 作者：MonKeySort_ZYczc (赞：3)

## 思路流程
先观察题目，“不允许出现余料”“正方形大小相等”两句肯定是让我们求 $W$ 与 $H$ 的公因数，“边长至少为二”“最多切割”是对该公因数的要求。  
怎样求出最多切割数呢？由于切割数要求最大化，则边长应该要最小，即要求求出最小公因数。  
我们可以求出 $\gcd(H,W)$，遍历 $2$ 到 $\sqrt{\gcd(H,W)}$ 找出 $\gcd(H,W)$ 的最小非 $1$ 因数即可。  
**注意三点：**

- 当 $\gcd(H,W)=1$ 时，由于题目中“边长至少为二”这一条件，应判断无解，输出 $0$。
- 当 $\gcd(H,W)$ 为质数时，遍历仍然无法找出其因数，此时最小公因数就是 $\gcd(H,W)$，不要漏判。
- 不开 long long 见祖宗。
  
最后将长方形面积除以正方形面积输出即可。  
总时间复杂度：$O(\sqrt{\gcd(H,W)})$。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//补药见祖宗了
int gcd(int a,int b)
{
	if(a<b) swap(a,b);
	if(b==0) return a;
	return gcd(b,a%b);
}
signed main(){
	int h,w;cin>>h>>w;
	int g=gcd(h,w);
	if(g==1) //特判
	{
		cout<<0<<"\n";
		return 0;
	}
	for(int i=2;i<=sqrt(g);i++)
	{
		if(g%i==0)
		{
			cout<<h/i*w/i<<"\n";
			return 0;
		}
	}
	cout<<h/g*w/g<<"\n";//还是特判
}
```

---

## 作者：hsr_ray (赞：3)

这道题我们看到题就可以发现一定和 $w$ 还有 $h$ 的 $\gcd$ 有关，因为如果正方形的边长不是 $w$ 和 $h$ 的倍数，正方形一定不能铺满。

设 $\gcd(w,h)=g$ 于是我们可以在 $g$ 以内枚举完全平方数。

接着我们再设 $w=k_1 \times g, h=k_2 \times g$。总的面积就等于 $w \times h = k_1 \times k_2 \times g^2$ 。我们发现如果 $w$ 能被 $g$ 整除，那么总面积就一定能被整除，所以只需要判断上述条件就可以判断是否满足条件。

最后有一些特判。首先如果 $g=1$ 那么就一块都切割不出来，输出 $0$。如果其中的完全平方数全部都不行，最后可以输出上文中的 $k_1\times k_2$  这无论如何都是合法的。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m;
	cin>>n>>m;
	int g=__gcd(n,m);
	if(g==1) cout<<0;
	else{
		for(int i=2;i*i<=g;i++){
			if(g%i==0){
				cout<<n/i*m/i;
				return 0;
			}
		}
		cout<<n/g*m/g;
	}
	
	return 0;
}
```

---

## 作者：XsIeEiKcEk (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10415)

## 题目大意

给出两个整数 $W$、$H$。假设他们的大于 $1$ 的最小公约数为 $k$，输出 $W/k\times H/k$。如果没有，输出 $0$。

## 我的思路

先求出它们的最大公约数，如果是 $1$ 直接输出 $0$。再在这个数找一个最小的大于 $1$ 的因数，如果他是质数，那结果就是它自己。最后再输出。

特别提示：```十年OI一场空，不开long long见祖宗！```

## [AC](https://www.luogu.com.cn/record/202020531) CODE


```cpp
#include <iostream>
#include <cmath>
#define int long long//不开long long见祖宗
using namespace std;

int gcd(int a, int b) {//手打_gcd(最大公因数),不懂原理的搜辗转相除
	if (a % b == 0)
		return b;
	return gcd(b, a % b);
}

bool prime(int x) {//判断是否为质数
	if (x < 4)//特判
		return 1;
	for (int i = 2; i * i <= x; i++)
		if (x % i == 0)
			return 0;
	return 1;
}

signed main() {
	int w, h;
	cin >> w >> h;
	if (h > w)
		swap(w, h);//大数在前快一些
	int g = gcd(w, h);
	if (g == 1)//特判
		cout << 0;
	else {
		for (int i = 2; i * i <= g; i++) {
			if (g % i == 0) {
				cout << w / i *h  / i;
				break;
			}
		}
		if (prime(g))//若为质数
			cout << w / g *h / g;//结果为它自己
	}
	return 0;
}
```

---

## 作者：mcturtle (赞：2)

~~题意很简单，不做过多讲解。~~
## 部分解
注意到，这道题加强数据后，如下的代码不能通过了：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long a, b, i = 1;
    cin >> a >> b;
    while (++i)
        if (a % i == 0 && b % i == 0 || i > a || i > b)//如果符合条件
        {
            cout << a / i * b / i;
            return 0;
        }
}
```
代码思路：

首先输入 $W,H$。

其次使用枚举法，枚举范围 $1\sim\max(W,H)-1$，如果符合要求就输出 $\frac{W\times H}{i^2}$。（不用考虑为 $0$ 的情况，它会自动输出）

很显然，新的数据 $\texttt{hack}$ 掉了这份暴力代码。
## 正解

需要优化。
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x, y, g;
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> x >> y;
    g = __gcd(x, y);//优化
    if (g == 1)//特判
    {
        cout << 0;
        return 0;
    }
    for (long long i = 2; i * i <= g; i++)
    {//注意范围
        if (g % i == 0)
        {
            cout << x / i * y / i;
            return 0;
        }
    }
    cout << x / g * y / g;//输出最大的
    return 0;
}
```
首先特判，若两数互质，输出 $0$；

然后开始枚举，枚举范围 $2\sim\sqrt{\gcd(W,H)}$。

若令 $i$ 为 $\gcd(W,H)$ 的不为 $1$ 的最小因子，那么很显然，答案就是 $\frac{W\times H}{i^2}$。

$\gcd(W,H)$ 就是 $\gcd(W,H)$ 的最大因子。

---

## 作者：fish_love_cat (赞：2)

题目要求所有正方形大小相等，显然答案正方形的边长必然同时满足 $x\mid W,x\mid H$，也就是说 $x\mid \gcd(W,H)$。

为了让裁剪出来的正方形数量足够多，我们令答案正方形的边长 $x$ 为 $\gcd(W,H)$ 的非 $1$ 最小因子。

然后就可以计算数量了。答案为 $\frac{W\times H}{x^2}$。

注意 $x=1$ 的非法情况。

时间复杂度 $O(\sqrt{\gcd(W,H)})$。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int a,b;
    cin>>a>>b;
    int g=__gcd(a,b);
    for(int i=2;i<=g;i++)
    if(g%i==0)g=i;
    if(g==1)cout<<0;
    else cout<<a*b/g/g;
    return 0;
}
```

然后你就 [TLE](https://www.luogu.com.cn/discuss/1013277) 了。

注意到当 $\gcd(W,H)$ 是质数时，时间复杂度会退化为 $O(\gcd(W,H))$，此时情况非常不妙。

有一个显然的优化是，我们的枚举只需要枚举到 $\sqrt{\gcd(W,H)}$ 就可以退出了。

因为任何一个合数都会整除于一个小于等于自身根号的数。而质数我们是不用处理的。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int a,b;
    cin>>a>>b;
    int g=__gcd(a,b);
    int sq=sqrt(g);
    for(int i=2;i<=sq;i++)
    if(g%i==0){
        g=i;
        break;
    }
    if(g==1)cout<<0;
    else cout<<a*b/g/g;
    return 0;
}
```

AC [记录](https://www.luogu.com.cn/record/201378335)。

---

## 作者：_Deer_Peach_ (赞：0)

题意已经很简洁了不再赘述。

思路：

要使长方形全部剪成边长为整数且大小相同的小正方形，并且没有边角料，说明小正方形的边长为长方形的长和宽的公因数。

然后要使剪出来的正方形最多，所以要使小正方形的边长尽可能小。

那么思路就很清楚了，因为边长至少为 $2$，所以求长方形长和宽的最大公因数的最小的不为 $1$ 的因数。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
int n,m;signed main(){
	IOS;cin>>n>>m;int gcd=__gcd(n,m);//最大公因数
    if(gcd<2){cout<<0;return 0;}//最大公因数为1
    for(int i=2;i*i<=gcd;i++){//求最大公因数的不为1的最小因数
        if(gcd%i==0){cout<<n/i*m/i;return 0;}
    }cout<<n/gcd*m/gcd;return 0;//求个数
}
```

---

## 作者：rainbow_cat (赞：0)

设 $a,b$ 的最小非 $1$ 公约数为 $x$，答案自然是 $\frac{ab}{x^2}$。   
最小公约数一定是最大公约数 $g$ 的因数，因为这里求的是最小因数所以假如 $x$ 满足，那么 $g \div x$ 也满足，只用枚举 $1$ 至 $\sqrt{g}$ 即可，不过有个特例，假如 $g \ne 1$ 而且在范围内没有找到最小因数，那最小因数为 $g$ 本身。   
时间复杂度 $O(\sqrt{\gcd(W,H)})$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x,y,g;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>x>>y;
	g=__gcd(x,y);
	if(g==1)
	{
		cout<<0;
		return 0;
	}
	for(int i=2;i*i<=g;i++)
	{
		if(g%i==0)
		{
			cout<<x/i*y/i;
			return 0;
		}
	}
	cout<<x/g*y/g;
	return 0;
}
```

---

## 作者：xingsunderen (赞：0)

## 思路
由于题目说不能有余料，不难发现正方形边长一定为 $W$ 与 $H$ 的公因数，那么只需找到他们除 1 之外的最小公因数，这题就能迎刃而解了。
## 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long w,h;
int main(){
	cin>>w>>h;
	long long imin=min(w,h);
	for(long long i=2;i<=imin;i++){
		if(w%i!=0||h%i!=0) continue;
		cout<<w/i*h/i;
		return 0;
	}
	cout<<0;
	return 0;
}
```

---


# 64位整数乘法

## 题目描述

求 $a$ 乘 $b$ 对 $p$ 取模的值。

## 说明/提示

$1 \le a,b,p \le 10^{18}$

## 样例 #1

### 输入

```
3
4
5```

### 输出

```
2```

# 题解

## 作者：2023gdgz01 (赞：48)

提供一种非常优雅的方法。有一种数据类型为 `__int128`，它能存储最大为 $2^{127}-1$ 的整数，而本题 $a\times b$ 最大可能为 $10^{36}$，正好可以用 `__int128` 运算。`__int128` 并不能用 `cin` 或 `scanf` 读入，也不能用 `cout` 或 `printf` 输出。但是输入数据不超过 $10^{18}$，所以我们可以先用 `long long` 类型读入 $a,b,p$，再将其转换为 `__int128` 类型运算；注意到 $p$ 不超过 $10^{18}$，所以最终运算结果也不超过 $10^{18}-1$，我们可以把 `__int128` 类型的运算结果转换为 `long long` 再输出。由此省去了写快读或快输。代码如下：

```cpp
#include <cstdio>

long long A, B, P, ANS;
__int128 a, b, p, ans;

int main() {
	scanf("%lld%lld%lld", &A, &B, &P);
	a = A;
	b = B;
	p = P;
	ans = a * b % p;
	ANS = ans;
	printf("%lld", ANS);
	return 0;
}
```

[AC 链接](https://www.luogu.com.cn/record/159102812)

---

## 作者：__qkj__ (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P10446)
## 解题思路
因为 $n,m,k\le 10^{18}$，所以要用高精。

所以我用了 `python`。

## Code

```python
#用逗号可以把赋值语句合并起来
n,m,k=int(input()),int(input()),int(input())
print((n*m)%k)
```

---

## 作者：Programming_Konjac (赞：8)

这道题有三种解法！
# 思路 $1$
用 `__int128`（一定要有两个 `_`，否则编译错误）进行输入 $a,b,m$，然后输出 $(a\times b)\bmod m$ 就能通过此题（超简单）！

接下来给出 `__int128` 的输入和输出：
```cpp
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void print(__int128 x){
	if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```
# 代码 $1$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void print(__int128 x){
	if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
int main(){
    __int128 a,b,m;
    a=read();
    b=read();
    m=read();
    print(a*b%m);
    return 0;
}
```
# 思路 $2$
首先我们观察一下快速幂（具体实现请看[这里](https://oi-wiki.org/math/binary-exponentiation/#%E8%BF%87%E7%A8%8B)）的代码：
```cpp
ll fast_pow(ll a,ll b,ll p){
	ll ret=0;
	while(b){
	    if(b&1) ret=(ret+*a)%p;
	    b>>=1;
	    a=(a*a)%p;
	}
	return ret;
}
```
而龟速乘与二进制取幂的思想一样，这次我们将其中的一个乘数表示为若干个 $2$ 的整数次幂的和的形式。因为在对一个数做乘 $2$ 并取模的运算的时侯，我们可以转化为加减操作防止溢出，具体代码实现：
```cpp
#define ll long long
ll fast_times(ll a,ll b,ll p){
	ll ret=0;
	while(b){
	    if(b&1) ret=(ret+a)%p;
	    b>>=1;
	    a=(a+a)%p;
	}
	return ret;
}
```
# 代码 $2$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll fast_times(ll a,ll b,ll p){
	ll ret=0;
	while(b){
	    if(b&1) ret=(ret+a)%p;
	    b>>=1;
	    a=(a+a)%p;
	}
	return ret;
}
int main(){
    ll a,b,m;
    cin>>a>>b>>m;
    cout<<fast_times(a,b,m);
    return 0;
}
```
# 思路 $3$
快速乘，具体请看[这里](https://oi-wiki.org/math/binary-exponentiation/#%E5%BF%AB%E9%80%9F%E4%B9%98)，这里就不细说了。

快速乘代码：
```cpp
#define ll long long
ll very_fast_times(ll a,ll b,ll m){
    unsigned long long c=(unsigned long long)a*b-(unsigned long long)((long double)a/m*b+0.5L)*m;
    if(c<m) return c;
    return c+m;
}
```
# 代码 $3$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll very_fast_times(ll a,ll b,ll m){
    unsigned long long c=(unsigned long long)a*b-(unsigned long long)((long double)a/m*b+0.5L)*m;
    if(c<m) return c;
    return c+m;
}
int main(){
    ll a,b,m;
    cin>>a>>b>>m;
    cout<<very_fast_times(a,b,m);
    return 0;
}
```

---

## 作者：UnfortunatelyDead (赞：5)

其实是快速乘的模板啦！

考虑将 $b$ 表示为二进制的形式，那么 $b$ 一定只包含 `0` 和 `1`，且这个二进制串的长度为 $\lceil \log b\rceil$，根据数据范围可得长度不超过 $64$。

首先一个显然的性质是可以根据乘法分配律，将 $a \times b$ 转化为所以二进制位是 $1$ 的权值乘以 $a$ 后的加和，由于是二进制，所以每一位只可能是选（$1$）或不选（$0$），而知道这个权值的方式也是简单的，根据二进制权值的特殊性，从低位往高位，权值每进一位便乘 $2$，于是可以低位往高位做。

这样复杂度是 $O(\log b)$ 的，注意计算权值乘以 $a$ 这东西时候要取模。

```cpp
signed main() {
	int a, b, p;
	read(a, b, p);
	int ans = 0;
	while (b) {
		if (b & 1) (ans += a) %= p;
		b >>= 1; (a += a) %= p;
	} write(ans, '\n');
	return 0;
}
```

---

## 作者：we_are_the_chuibing (赞：2)

int128 可以存储 $-2^{127}\sim2^{127}-1$ 的数据。由于 $ab$ 的最大值为 $10^{36}<2^{127}-1$，所以可以使用。int128 不能直接输入和输出，只能用快读的方式。这里为了方便直接用输入输出都用 long long 存储。

这里安利一波 dark_moonbird 大佬的 [blog](https://blog.csdn.net/darkmoonbird/article/details/136159987)。个人感觉讲得很好。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long a,b,p,ans;
    __int128 a_,b_,p_,ans_;
    cin>>a>>b>>p;
    a_=a,b_=b,p_=p;
    ans_=(a_*b_)%p_;
    ans=ans_;
    cout<<ans;
    return 0;
}
```

---


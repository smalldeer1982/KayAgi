# [XJTUPC 2024] 转呀转

## 题目背景

乐奈：灯，你听我说

乐奈：洗衣机好有趣的

灯：诶……洗衣机……？

乐奈：衣服一直转呀转，观察那个好有意思

乐奈：灯也可以去试试

灯：诶……？好的……！

![](https://cdn.luogu.com.cn/upload/image_hosting/3mkfdq00.png)

  "一直转呀转好有意思！"


## 题目描述

rana 和 tomorin 在观察洗衣机里的衣服的时候，发现衣服做匀速圆周运动。她们知道衣服的初始位置，观察时间以及洗衣机转速，希望你能帮她们求出初始位置到观察结束时位置的位移长度。衣服可以看成质点。


## 样例 #1

### 输入

```
-1 0
11
0.5
```

### 输出

```
2.0000000000
```

## 样例 #2

### 输入

```
-1 0
10
0.5
```

### 输出

```
0.0000000000
```

# 题解

## 作者：zhengpie (赞：7)

### 1.思路

首先，我们考虑 $\alpha = (t \times v - \lfloor t \times v \rfloor) \times 2 \times \pi$，即衣服转的角度化成弧度制。

再考虑 $dis = \sqrt{x^2+y^2}$，即圆的半径。

那么我们要求的就是以 $dis$ 为腰，以 $\alpha$ 为顶角的等腰三角形的底边 $ans$。

根据[余弦定理](https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86/957460?fr=ge_ala)，我们有 $ans = \sqrt{dis ^ 2 + dis^2 - 2 \times dis \times dis \times \cos{\alpha}}$。

又因为 STL 里的 ```cos``` 里面的角要填弧度制，所以上文中我们把 $\alpha$ 换算成弧度制。

### 2.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double x,y,t;
double v;
signed main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>x>>y>>t>>v;
    double angle = (t * v - (double)(floor(t * v))) * 2 * 3.1415926535897,dis = sqrt(x * x + y * y);
	cout<<setprecision(10)<<fixed<<sqrt(dis * dis + dis * dis - 2 * dis * dis * cos(angle)); 

    
    return 0;
}
```

---

## 作者：juruo5e59 (赞：3)

## 洛谷P10519
### 题目大意
求一点 $(x, y)$ 在圆心为 $(0, 0)$ 的圆周上运动 $t \times v$  圈后的位置与初始位置的直线距离。
### 思路
考虑到初始点、结束点、圆心形成一个三角形，并且有两边长为 $r$，即 $(x, y)$ 到 $(0,0)$ 点的距离。两边夹角也不难计算，所以可以使用余弦定理求解距离。（不知道余弦定理的点[这里](https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86/957460)）但是，余弦定理所需要使用的 $cos$ 函数在 C++ 里只能提供弧度参数，所以需要通过以下公式将角度转换成弧度：
$$\text{radian}=\text{perspectives} \times \dfrac{\pi}{180}$$

### AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const double pi = 3.14159265358979323846; 
double mod1(double x) { //取小数部分
  return x - (int)(x);
}
signed main() {
	double x, y, t, v;
	cin >> x >> y >> t >> v;
	double circles = mod1(t * v), pers = 360.0 * circles;
	if (pers > 180)
		pers = 360 - pers; //避免炸掉，先转换成小于等于 180 度的角
	double rad = pers * (pi / 180.0);
	double r = sqrt(x * x + y * y); //求与 (0, 0) 的直线距离（经过简化，和公式有所出入）
	double ans = r * r + r * r - 2 * r * r * cos(rad); //核心公式，两边距离 a 和 b 都是半径，所以全部用 r 指代
	cout << fixed << setprecision(10) << sqrt(ans);
	return 0;
}
```
### 总结
这道题代码难度不大，但对数学方面有一定的要求，比如弧度的转换公式和余弦定理，建议有一定数学功底再完成本题。

---

## 作者：ouyanglei (赞：3)

前置知识：
- 整数除法取余用模符号，小数除法取余用 fmod() 函数。
- 通过弧长求距离的公式是：
$$d = 2 \times r \times sin(\frac{arcLen}{2 \times r})$$

解题思路：
- 先求出半径。
- 再求出起点和终点之间的弧长。
- 最后用上面公式求出两点间距离。

代码：
```
#include <bits/stdc++.h>
using namespace std;

double x,y,r,t,v,arclen;
double pi = 3.1415926;

int main() {
   cin >> x >> y >> t >> v;
   
   r = sqrt(x*x + y*y);
   double arclen= 2*pi*r*fmod(t*v, 1);
   cout << fixed << setprecision(10) << 2*r*sin(arclen/(2*r)) << endl;

   return 0;
}
```

---

## 作者：编程小贝壳 (赞：1)

题目描述了一个衣服在洗衣机里做匀速圆周运动的情况，并给出了衣服的初始位置、观察时间以及洗衣机的转速。我们需要计算在这段时间内，衣服从初始位置移动到的位置的位移长度。

首先，我们知道衣服做匀速圆周运动，因此它的运动轨迹是一个圆。位移长度是初始位置和结束位置之间的直线距离，而不是衣服沿圆周运动的路径长度。

我们可以将洗衣机的转速转换为衣服在单位时间内转过的角度。转速是圈每单位时间，所以我们可以将转速乘以观察时间来得到衣服转过的总角度（以弧度为单位）。

然后，我们可以使用三角函数来计算衣服从初始位置到结束位置的位移长度。初始位置由题目给出，我们可以将其转换为极坐标中的半径和初始角度。结束角度是初始角度加上转过的总角度。

最后，我们可以使用结束角度和半径来计算结束位置的直角坐标，并计算初始位置和结束位置之间的直线距离作为位移长度。


```cpp
#include<bits/stdc++.h>
using namespace std;
int x, y;
double t, v;
int main() {
    cin >> x >> y >> t >> v;
    // 将直角坐标转换为极坐标
    double r = sqrt(x * x + y * y);
    double theta0 = atan2(y, x);

    // 计算转过的总角度（以弧度为单位）
    double theta_total = v * t * 2 * M_PI;

    // 计算结束角度
    double theta1 = theta0 + theta_total;

    // 计算结束位置的直角坐标
    double x1 = r * cos(theta1);
    double y1 = r * sin(theta1);

    // 计算位移长度
    double dis = sqrt((x1 - x) * (x1 - x) + (y1 - y) * (y1 - y));

    // 输出结果，保留足够的小数位数以满足精度要求
    cout << fixed << setprecision(10) << dis << endl;

    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10519)

能 AC 这道题是因为之前补习过一点数学知识。

需要计算这些东西：

+ 初始位置与原点之间的角度（以弧度为单位）：`double r = sqrt(x * x + y * y);`；
+ 从正 $X$ 轴到点 $(x,y)$ 的角度：`double tt = atan2(y, x);`；
+ 转过的角度（以弧度为单位）：`double ap = v * t * 2 * M_PI;`（转速是“圈 / 单位时间”，我们转换为“弧度 / 单位时间”）；
+ 观察结束时的角度：`double ftt = tt + ap;`；
+ 使用极坐标到直角坐标的转换找到观察结束时的位置：`double fX = r * cos(ftt), fY = r * sin(ftt);`；
+ 初始位置到结束位置的位移长度：`sqrt((fX - x) * (fX - x) + (fY - y) * (fY - y))`。

然后输出位移长度就可以了。

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    double x, y;
    cin >> x >> y;
    double r = sqrt(x * x + y * y);
    double tt = atan2(y, x);
    double t, v;
    cin >> t >> v;
    double ap = v * t * 2 * M_PI;
    double ftt = tt + ap;
    double fX = r * cos(ftt);
    double fY = r * sin(ftt);
    printf("%.10lf\n", sqrt((fX - x) * (fX - x) + (fY - y) * (fY - y)));
    return 0;
}
```

---

## 作者：coderJerry (赞：1)

首先，我们计算 $v\times t$ 即可得到衣服转了多少圈，但是其整数部分（相当于转了一整圈又回到起点）可以忽略，所以衣服等价于只走了 $v\times t$ 的小数部分（下文记为 $r$）圈。

初始的点有了，旋转角度（可以由 $r$ 直接得出），就可以知道旋转之后的点的坐标了。根据三角函数的性质，不难得到：
- $x'=x\cos r-y\sin r$；
- $y'=x\sin r+y\cos r$。

于是使用两点间距离公式：$d=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const double PI=acos(-1.0);
int main(){
    double x,y,v,t;
    cin>>x>>y>>v>>t;
    double tmp=2*PI*(v*t-(int)(v*t));
    double xi=x*cos(tmp)-y*sin(tmp);
    double yi=x*sin(tmp)+y*cos(tmp);
    double dx=x-xi,dy=y-yi;
    double ans=sqrt(dx*dx+dy*dy);
    printf("%.10lf\n",ans);
    return 0;
}
```

---

## 作者：JYX0924 (赞：1)

这道题显然可以用三角函数来做。

首先，算出转的圈数，计算转圈先后的旋转角，最后套用正弦定理即可。

需要注意的是，三角函数用的是弧度制，不是角度制。

下面是 AC 代码。
```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int x,y; cin>>x>>y;
    double t,v; cin>>t>>v;
    double juli=sqrt(x*x+y*y);
    double sum=v*t;
    while(sum>=1) sum--;
    if(sum==0) {printf("%.10lf",sum); return 0;}
    sum*=360; if(sum>180) sum=360-sum;
    if(sum==180) {printf("%.10lf",juli*2); return 0;}
    printf("%.10lf",juli*sin(sum*3.1415926/180)/sin((90-sum/2)*3.1415926/180));
    return 0;
}
```
谢谢大家！！！

---

## 作者：qianyuzhe (赞：1)

## 题意简述

给定平面直角坐标系上一点的坐标 $P(x,y)$，$OP$ 在 $t$ 单位时间内每单位时间绕原点旋转 $v$ 圈，最终到达 $OP^{\prime}$ 位置，求 $PP^{\prime}$ 的长度。

## 分析

设 $OP=z$，$OP$ 与 $OP^{\prime}$ 的夹角为 $\theta$，则有 $z=\sqrt{x^2+y^2}$，$\theta=2tv\pi$。

由余弦定理即得 $PP^{\prime}=\sqrt{2z^2-2z^2\cos\theta}$。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
double x,y,z,t,v;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>x>>y>>t>>v;
	z=hypot(x,y);
	cout<<fixed<<setprecision(10)<<sqrt(2*z*z-2*z*z*cos(t*v*2*acos(-1)));//记得保留小数
}
```

---

## 作者：jqQt0220 (赞：0)

upd 2024.6.4：删去了代码前的缺省源，并更改了一些语言。

---

## 题意
给你一个点 $(x,y)$，这个点以原点为圆心做圆周运动，一单位时间转 $v$ 圈，转了 $t$ 单位时间，求转完后与原来点的直线距离。

## 思路
首先我们知道转了 $vt$ 圈，但是我们只要小数部分，因为完整转一圈很明显和没转一样，所以取 $vt-\left\lfloor vt \right\rfloor$ 即可，那么转的度数 $\theta=360(vt-\left\lfloor vt \right\rfloor)$。然后利用勾股定理求出半径 $r$，我们求的答案即为腰长为 $r$，顶角为 $\theta$ 的等腰三角形的底边长。

作这个等腰三角形的三线合一，把它分成两个全等的直角三角形。知道了斜边和一个角（$r$ 和 $\dfrac{1}{2}\theta$），那么设角的对边（即答案所求底边长的一半）为 $x$，那么 $\dfrac{x}{r}=\sin\dfrac{1}{2}\theta$，$x=r\sin\dfrac{1}{2}\theta$。那么答案所求的底边长 $a=2x=2\cdot r\sin\dfrac{1}{2}\theta$。

代码：
```cpp
#define double long double//最好开成 long double 不然会炸精度
const double pi=3.141592653589793;
double x,y,t,v;
double dist(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double angtorad(double deg){return deg*pi/180;}//角度转弧度
int main()
{
    ___();
    cin>>x>>y;
    cin>>t;
    cin>>v;
    double r=dist(0,0,x,y);//旋转圆周半径
    double theta=360*t*v;//转的角度
    printf("%Lf",r*sin(angtorad(theta/2))*2);//STL 里的 sin 用的是弧度，所以要转换；注意 long double 格式符为 %Lf（不是 %lf）
    return 0;//完美结束 QwQ
}
```

---

## 作者：fallen_star (赞：0)

# P10519 solution
[P10519](https://www.luogu.com.cn/problem/P10519)
## 题意简述
求圆上两点间弦长。
## 思路
这是一道非常基础的模拟题， 其难点在于如何求弦长。 

我们首先处理观察结束时的点与初始点之间的圆上距离（弧）占圆的比例和圆的半径， 即： 
```cpp
r=sqrt(x*x+y*y);
s=t*v-floor(t*v);
```
则这段弧所对的圆心角占周角的比例即为 s 。

然后我们再转为弧度制 ：
```cpp
a=s*3.14159265358;
``` 
取近似值即可 。

再乘以直径 ，最后再保留 10 位小数输出 。
# code:
```
#include<bits/stdc++.h>
using namespace std;
double x,y,t,v,r,s,a;
int main()
{
	cin>>x>>y>>t>>v;
	r=sqrt(x*x+y*y);
	s=t*v-floor(t*v);
	a=s*3.14159265358;
	cout<<fixed<<setprecision(10)<<2*r*sin(a);
	return 0;
}

```

---

## 作者：_ayaka_ (赞：0)

### 思路
这是一道数学题。

首先我们可以利用勾股定理求出圆的半径 $r$。

然后，我们可以求出转的圈数 $q=t\times v$。由于转了一圈会回到原点，所以我们要将 $q$ 保留小数位。

我们需要求新的点和原点的位移长度，而本质上就是已知圆心角（$q\times 360$）求弦长。公式为 $d=2\times r \times \sin(\frac{1}{2}\theta)$，在这里就不证明了。

不过在 c++ 的 cmath 中，$\sin(x)$ 里的 $x$ 需要的是弧度而非角度，不过我们只需要将角度 $\times \pi \div 360$ 就可以了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
double x,y,t,v,q,r;
signed main() {
	cin>>x>>y>>t>>v;
	r=sqrt(x*x+y*y);
	q=t*v;
	q-=(int)q;//利用int保留小数位
	printf("%.7f",r*2*sin(M_PI*min(q,1-q))); //公式
	return 0;
}
```

---


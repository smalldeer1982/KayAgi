# [XJTUPC 2024] 瑟莉姆的宴会

## 题目背景

欢迎来到瑟莉姆大人的享乐宴会！

![](https://cdn.luogu.com.cn/upload/image_hosting/6kmpy10b.png)

## 题目描述

宴会中一共有 $n$ 个访客，编号 $1\sim n$。为了更好地控制影的力量，瑟莉姆要求有 $n-1$ 个访客都恰好受到另一个访客的支配，而剩下的那个人成为总支配者，支配其他 $n-1$ 名访客。访客间的**直接支配关系**构成了一棵有根树。

对于这棵树来说，若结点 $a$ 的父结点是 $b$，那么称 $b$ 支配了 $a$，同时称 $b$ 是 $a$ 的**直接支配者**。同时，支配的关系具有**传递性**，即若 $a$ 支配 $b$，$b$ 支配 $c$，那么 $a$ 也就支配了 $c$。

另外有 $m$ 个支配条件，一个支配条件是一个有序二元组 $(x,y)$ ($1 \le x,y \le n$，$x\neq y$)，若访客 $x$ 支配 $y$，那么影的力量会增加 $1$ 点；若 $y$ 支配 $x$ ，那么影的力量会减少 $1$ 点。若两者互不支配，那么影的力量不变。初始的影的力量是 $0$。

作为贴心仆人的松雀需要组织一场宴会，那么需要为宴会中的每个人安排支配关系。由于瑟莉姆大人不需要关心影的力量能够达到多大，只需要让影的力量保持非负，你能够帮助她构造最终的支配关系吗？

若存在多个解，你只需要输出任意一个。保证对于任何合法输入，均存在解。

## 说明/提示

样例中最终影的力量是 $1-1-1+0+1=0$，符合非负条件。

## 样例 #1

### 输入

```
5 5
3 1
2 3
1 3
2 4
3 5
```

### 输出

```
2 3 0 3 3 ```

# 题解

## 作者：Stars_visitor_tyw (赞：12)

## P10521 [XJTUPC2024] 瑟莉姆的宴会 题解
### 分析
赛时没写的菜鸟来交一发题解，机房和家里都不准看某站所以看不了讲评，只能自己写题了（无助）。

支配关系：若 $x$ 是 $y$ 的祖先结点，则称 $x$ 支配 $y$。

看到这是道橙题，最开始震惊了我一下，因为这题我比赛时是直接弃了的。最简单的考虑形式其实就是一条链。但如果按输入给出的二元组去构造，未免太麻烦了些。所以我们就随意构造，然后如果算出来“影的力量”是负数就把整条链反过来，就相当于取了倒数。

当然还是构造 $1$ 直接支配 $2$，$2$ 直接支配 $3$ 这种特定链码量小点啦。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
signed main()
{
    cin>>n>>m;
    int sum=0;
    for(int i=1;i<=m;i++)
    {
        int x, y;
        cin>>x>>y;
        if(x<y)
        {
            sum++;
        }
    }
    if(sum<m-sum)
    {
        for(int i=1;i<n;i++)
        {
            cout<<i+1<<" ";
        }
        cout<<0;
    }
    else
    {
        cout<<"0 ";
        for(int i=2;i<=n;i++)
        {
            cout<<i-1<<" ";
        }
    }
}
```

若构造方式不同上，其实也可以写，不过我建议构造有序的链，赛时还是不要冒险了。

---

## 作者：PandaSun (赞：4)

# 题目分析
[题目传送门](https://www.luogu.com.cn/problem/P10521)

本题要求瑟莉姆大人的力量非负，换言之即大于 $0$ 即可。那么题目给定多组支配条件，~~作为贴心仆人的松雀~~，我们只需要做到满足最新的支配条件即可。在满足最新的支配条件后，原支配条件可能失效，即影的力量会减小 $1$，但是由于我们已经满足最新的支配条件，所以影的力量会增加 $1$。由此，我们保证影的力量一定非负。

------------
最后只需要解决一些小问题，会有一些人与所有支配条件都没有关系，那么这些人中的第一个就可以作为**总支配者**，剩下的无关人员可以被任意人支配，方便起见，我们将这些人的**直接支配者**设置为**总支配者**。另外，当 $a$ 已经直接支配 $b$ 时，最新支配条件要求 $b$ 再支配 $a$，我们应当忽视最新的支配条件，否则会形成互相支配的情况，不符合题意。

------------
## 献上代码
[AC 凭证](https://www.luogu.com.cn/record/159749294)
```cpp
//T455123 瑟莉姆的宴会
#include <iostream>
using namespace std;
int n, m;
int arr[100005];

int main() {
	cin >> n >> m;
	int a, b;
	bool zero = false;
	int boss = -1;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		if (arr[a] != b) {
			arr[b] = a;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (arr[i] != 0) {
			cout << arr[i] << " ";
		} else if (zero) {
			cout << boss << " ";
		} else {
			cout << "0 ";
			zero = true;
			boss = i;
		}
	}
	return 0;
}
```

---

## 作者：MSavannah (赞：4)

**Solution**

这构造场上咋没想到啊。

感觉构造树很有迷惑性场上一直想生成树相关。其实只需要考虑链就够了。钦定我们一开始的链形如 $1\to 2\to 3\dots \to n$。其中一个数前面的数都对他有支配关系，同理一个数的前一个数是他的父亲。我们对它进行一次答案统计，如果答案是非负的，直接按这条链的关系输出。如果不满足，直接将链反向然后再输出就好了，即把链变成 $n\to n-1\dots 3\to 2\to 1$。

[code](https://www.luogu.com.cn/record/159641442)

---

## 作者：Genshin_ZFYX (赞：3)

我们有两种支配的方法。

第一种，$1$ 是总支配者，其余每人都支配他后面一个人，也就是每个人支配他后面的所有人。

第二种，$n$ 是总支配者，其余每人都支配他前面一个人，也就是每个人支配他前面的所有人。

我们先假设我们选第一种方法。对于每次输入的 $x,y$，如果 $x>y$ ，那么 $x$ 可以支配 $y$，否则 $y$ 可以支配 $x$。对于第一种情况，我们将力量 $+1$，否则将力量 $-1$。如果选第二种方法，那么是相反的。

最后，我们判断一下目前的力量值是否 $>0$，如果是的话，选第一种方法。否则，选第二种方法。

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define I return
#define love 0
#define FIRESTARS ;
signed main()
{
    cin.tie(0)->sync_with_stdio(0);
    int n,m,sum=0;cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
    	int x,y;cin>>x>>y;
    	if(x>y)sum++;
    	else sum--;
	}
	if(sum>0)
	{
		for(int i=1;i<n;i++)cout<<i+1<<" ";
		cout<<0;
	}
	else
	{
		cout<<0<<" ";
		for(int i=2;i<=n;i++)cout<<i-1<<" ";
	}
	I love FIRESTARS
}

```

---

## 作者：liaoxingrui (赞：3)

## Content

有两个数 $n$ 和 $m$。接下来还有 $m$ 行，每行有 $2$ 个数 $x$ 和 $y$，表示 $x$ 支配 $y$，同时支配具有传递性。

问编号为 $i$ 的访客的直接支配者编号，总支配者的直接支配者编号为 $0$。

## Solution

可以用并查集来做，判断两个客人是否是被同一个客人支配，如果不是，那么 $x$ 就是 $y$ 的直接支配者，最后将答案输出即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,x,y;
int f[N],ans[N];
inline int find(int x){
	if(f[x]==x)
		return x;
	return f[x]=find(f[x]);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		f[i]=i;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		int xx=find(x),yy=find(y);
		if(xx!=yy){
			f[yy]=xx;
			ans[y]=x;
		}
	}
	for(int i=1;i<=n;i++)
		cout<<ans[i]<<" ";
	return 0;
}
```

---

## 作者：Rookie_t (赞：2)

这题我用的是图论和拓扑排序的做法。

首先要明白什么是支配关系。

如果点 $a$ 是点 $b$ 的祖先，那么 $a$ 支配 $b$。

我们使用了一个邻接矩阵 $g$ 来存储有向图的边，其中 $g_{i,j}$ 表示编号为i的节点的第j个后继节点。 

由于题目要求最终形成一个有根树，我们需要确定哪个节点是根节点。

我们可以选择一个节点作为根节点，如果有多个节点满足条件，可以任选一个。

然后利用拓扑排序确定每个节点的直接支配者。

由于支配关系具有传递性，我们可以从根节点开始，逐层确定每个节点的直接支配者，直到所有节点都被分配了直接支配者。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100005  
#define MAXM 200005  
int n,m;  
int g[MAXN][2];
int inD[MAXN];
int pa[MAXN];  
void tp(){  
    int q[MAXN],f = 0,r = 0;  
    // 找到入度为0的节点作为根节点  
    for (int i = 1;i<=n;i++){  
        if(inD[i] == 0){  
            q[r++] = i;  
            pa[i] = 0; // 根节点的直接支配者编号为0  
        }  
    }
    while(f<rear){  
        int cur = q[f++];  
        for(int i = 0;i<inD[cur];i++){  
            int nxt = g[cur][i];  
            inD[nxt]--; // 更新下一个节点的入度  
            if(inD[nxt] == 0){  
                q[r++] = nxt;  
                pa[nxt] = cur; // 分配直接支配者  
            }  
        }  
    }  
} 
int main(){  
    cin>>n>>m;
    for (int i = 0;i<m;i++){  
        int x,y;  
        cin>>x>>y; 
        g[y][inD[y]++] = x; 
    }  
    tp();  
    for (int i = 1;i<=n;i++){  
        cout<<pa[i]<<" "; 
    } 
    return 0;  
}
```

---

## 作者：zhengpie (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10521)

### 1.思路

诈骗题。

考虑 $i \in [1,n-1]$ 中的每个 $i$ 都支配 $i + 1$。

- 若此时的影的力量是非负数，那么直接输出即可。

- 否则反过来，使 $i \in [2,n]$ 中的每个 $i$ 都支配 $i - 1$ 即可。

当然，我们可以考虑任意的一条链，但是没有必要。

---

## 作者：ldll0721 (赞：2)

首先这个题我们需要的是最后总值为正，也就是说需要让更多人满足条件中 $(x,y)$ 。

所以我们就可以用一个 $f(x,y)$ 来表示支配者与被支配者，然后选出一个能支配别人人数最多的一个作为根，最后 dfs 一遍寻找位置就可以了（满足条件就放进去）。如果遇到不包含在内（即无法增加影的值），则统一将他的支配者归为主根。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,t[500005],fa[500005],vis[500005],ans[500005];
void dfs(int u){
	vis[u]=1;
	for(int i=1;i<=n;i++){
		if(vis[i]==0&&fa[i]==u){
			ans[i]=u;
			dfs(i);
		}
	}
}
signed main() {
	cin>>n>>m;
	for(int i=1; i<=m; i++) {
		int x,y;
		cin>>x>>y;
		t[x]++;//t[i]用来保存每一位的可支配者数量 
		fa[y]=x;//表示y可以被x支配 
	}
	int maxn=0,bh;
	for(int i=1;i<=n;i++){
		if(t[i]>maxn){
			maxn=t[i];
			bh=i;
		}
	}
	dfs(bh);//bh为最大值，即主根 
	for(int i=1;i<=n;i++){
		if(ans[i]==0&&i!=bh)ans[i]=bh;//遇到未放入则归为主根 
		cout<<ans[i]<<" ";
	}
	return 0;
}

```

---

## 作者：wzhm54nr (赞：1)

# 前言
本解法与赛后讲评的方法存在不同，且个人认为较简洁，望各位大佬不吝赐教。
# 解法
这是一个构造题，我的思路是构造一个菊花图，让某个人（为方便叙述，下文成为统治者）**直接**支配其他的所有人。  
显然，此时的分数只受与统治者有关的规则的影响，容易得到：

$\text{分数}=\text{要求某人被统治者支配的规则数} -\text{要求某人支配统治者规则数}$

比如样例，2 条规则要求 2 号支配他人，没有规则要求 2 号被人支配，所以把 2 号作为统治者的分数就是 $2-0=2$。
# code
至此，思路已经很明了了，展示一下赛时代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int val[100005];
signed main(){
    int n,m;scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int x,y;scanf("%d%d",&x,&y);
        ++val[x];--val[y];
    }
    for(int i=1;i<=n;i++)if(val[i]>=0){
        for(int j=1;j<i;j++)  printf("%d ",i);
        printf("0 ");
        for(int j=i+1;j<=n;j++)  printf("%d ",i);
        return 0;
    }
}
```

---

## 作者：Weekoder (赞：1)

### 思路

考虑最基础的情况：将所有结点构造成一条链，由于支配关系是可传递的，而且只需要保证影的力量非负，构造一条链即可。事实上，构造出来的树只有可能是两种，以下是 $n=4$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/eremfarr.png)

或者

![](https://cdn.luogu.com.cn/upload/image_hosting/nssnzoqd.png)


我们在输入的时候判断 $x$ 和 $y$ 的祖孙（大小）关系，算出第一条链（或第二条）中影的力量，如果不行就换另一种条，输出。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, cnt;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
    for (int i = 1, x, y; i <= m; i++) {
        cin >> x >> y;
        cnt += x < y ? 1 : -1;
    }
    if (cnt >= 0) 
        for (int i = 0; i < n; i++)
            cout << i << " ";
    else 
        for (int i = 2; i <= n + 1; i++)
            cout << (i == n + 1 ? 0 : i) << " ";
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10521)

由于题目保证有解，我们可以观察到：

+ 不存在环，因为每个节点除了一个之外都有一个直接支配者；
+ 有一个节点没有直接支配者，这个节点就是总支配者。

我们可以使用 DFS 或拓扑排序来构建这棵树，但有一个更简单的方法：

1. 遍历所有的支配条件，统计每个节点被支配的次数。
2. 找到没有被支配的节点作为根节点（总支配者）。
3. 从根节点开始，遍历所有剩余的节点，为每个节点分配一个直接支配者（除了根节点外，每个节点只有一个未被支配的节点）。

然后代码就出来了：

```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;
const int N = 1e5 + 10;
int n, m, a[N];
map<int, int> d1;
vector<int> G[N];
int Find() { // 找到根节点（总支配者）
    for (int i = 1; i <= n; i++)
        if (d1[i] == 0)
            return i;
    return -1;
}
void dfs(int nd, int p) { // 为每个节点分配直接支配者
    a[nd] = p;
    for (int nb : G[nd])
        if (a[nb] == 0) // 如果 nb 还没有被分配直接支配者
            dfs(nb, nd); // 递归分配
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        d1[y]++; // y 被 x 支配
        G[x].push_back(y); // 添加边 x -> y
    }
    int rt = Find(); // 找到根节点
    a[rt] = 0; // 根节点的直接支配者为 0
    dfs(rt, 0); // 从根节点开始分配直接支配者
    for (int i = 1; i <= n; i++)
        cout << a[i] << " ";
    return 0;
}
```

---

## 作者：abc1856896 (赞：0)

# solution
签到题。

看到**直接**和**传递性**两个字眼，考虑并查集。

我们判断两个客人是否是被同一个客人支配。

如果**否**，那么$x$ 就是 $y$ 的支配者，最后将答案输出即可。


------------

也可以考虑构造。

其实只用考虑从 $1$ 开始支配到 $n$ 的答案或从 $n$ 开始支配到 $1$ 的答案。

若从 $n$ 开始支配到 $1$ 的答案为负数，那么另外一种情况必为正，因为两种情况的支配方向是相反的。

两种做法均可。

---

## 作者：Drifty (赞：0)

### Preface

简单题，赛时做了 20+ 分钟，菜。

### Solution

我们会发现，我们只用考虑 $1$ 支配 $2$ 支配 $3$ 支配到 $n$，或 $n$ 支配 $n-1$ 支配 $n-1$ 支配到 $1$ 两种情况。因为如果第一种情况为负，那么由于第二种情况与第一种情况支配方向完全相反，因此第二个支配方案权值一定为正。

### AC Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
    int n, m, u=0;
    cin >> n >> m;
    for (int x, y; m; m--) {
    	cin >> x >> y;
    	u += x>y ? 1 : -1;
	}
	if (u < 0)
		for (int i=0; i<n; i++) cout << i << ' ';
	else {
		for (int i=1; i<n; i++) cout << i+1 << ' ';
		cout << 0;
	}
    return 0;
}
```

---

## 作者：Elysian_Realme (赞：0)

# P10521

~~我是瑟莉姆大人的狗。~~

我们可以先考虑构造一条链的情况。

这时，我们可以暴力算出该链的总权值，通过题目中二元组的性质可以发现，如果我们把这条链 reverse 一下那么最终权值必定是原来的相反数。

直接构造一种 $1\to 2\to 3\to\cdots\to N$ 的链（最好写的一集），判断是否非负，如果为负就倒序，否则正序构造即可。

作为一道橙题代码和思想难度都还可以。

code:
```cpp
// Problem: P10521 [XJTUPC2024] 瑟莉姆的宴会
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10521
// Memory Limit: 256 MB
// Time Limit: 1000 ms
// 
// By：lmq
// AC Time：2024-05-25 08:43:49

#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,m,sum;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;x=read(),y=read();
		if(x<y)sum++;
    }
    if(sum<m-sum){
    	for(int i=1;i<n;i++)
        	cout<<i+1<<" ";
		cout<<0<<endl;
	}else
		for(int i=1;i<=n;i++)
			cout<<i-1<<" ";
    return 0;
}
```

---

## 作者：_Jocularly_ (赞：0)

构造。我们首先考虑正着支配，也就是从开头到结尾，都是 $i$ 支配 $i+1$ 的情况，也就是每个人的支配者是后面的人。如果这种情况的能力值是非负的，直接按照这种情况构造即可，此时的总支配者为最后一个人。如果得到的答案是负值，那么反过来支配的值一定是负的，也就是 $i+1$ 支配 $i$ 的情况，即每个人的支配者是前面的人，此时总支配者为第一个人。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int power;
int main(){
	cin >> n >> m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin >> x >> y;
		if(x < y) power --;//如果被后面的人支配了，说明不符合后支配前 
		else power ++;//否则减一 
	}
	if(power > 0){//第一种构造方式 
		for(int i=1;i<n;i++){
			cout << i + 1 << " ";//每个人的支配者都是后一个人 
		} 
		cout << 0;//最后一个为总支配者 
	}else{//第二种构造方式 
		cout << 0 << " ";//第一个为总支配者 
		for(int i=2;i<=n;i++){
			cout << i - 1 << " ";//每个人的支配者都是前一个人 
		} 
	}
	return 0;
}

```

---


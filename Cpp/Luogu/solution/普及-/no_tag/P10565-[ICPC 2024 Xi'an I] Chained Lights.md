# [ICPC 2024 Xi'an I] Chained Lights

## 题目描述

你有 $n$ 盏灯排成一行。最初，它们都是关闭的。  你将逐个按下这 $n$ 盏灯。当你按下灯 $i$ 时，灯 $i$ 将切换其状态，这意味着如果它是关闭的，它将打开；如果它是打开的，它将关闭。然后对于每个满足 $i|j, i < j \le n$ 的 $j$，按下灯 $j$ 一次。  例如，如果 $n=4$，当你按下灯 $1$ 时，灯 $1$ 将打开，然后你将按下灯 $2,3,4$。由于你按下了灯 $2$，灯 $2$ 将打开，你将按下灯 $4$，这将导致灯 $4$ 打开。经过所有操作后，灯 $1,2,3$ 将打开，而灯 $4$ 仍然关闭。  你将逐个按下这 $n$ 盏灯并进行上述操作。经过所有操作后，你想知道灯 $k$ 是开着还是关着的。  你也可以使用以下代码来理解问题的含义： 
```cpp 
void press(int x) {
    light[x]^=1;
    for (int y=x+x; y<=n; y+=x) press(y);
}
for (int i=1; i<=n; i++) press(i);
```

## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
2
1 1
3 2```

### 输出

```
YES
NO```

# 题解

## 作者：wzx7117 (赞：6)

# 题目大意
有 $n$ 盏灯，初始状态全是关闭的，要求从 $1$ 到 $n$ 依次按下开关，每按下一个开关，则其倍数的灯都会开关一次。  
根据题干给出的代码，每触发一个按钮就会使其倍数的按钮被按下，而且二次触发也有效（划重点）。  
这是什么意思呢？让我们模拟一下：  
按下第一个灯后， $2$ ~ $n$ 的灯会被按下开关，同时第二个灯会使其倍数的灯被按下开关以此类推。   
一般来说解题思路是找 $i$ 的因子数再判断奇偶，但因为“二次触发”的可能性，每个灯最开始都被 $1$ 触发了一次，等同于每个灯被自己因子（ $1$ 和它本身除外）触发的次数乘了二。  
最后结果就是除 $1$ 号灯外的灯全是关闭的。
# code time

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,k;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
        if(k==1)cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
	}
	return 0;
}
```

---

## 作者：残阳如血 (赞：4)

### $\textbf{Solution}$

诈骗题。

---

非常重要的是，本题的 `press` 是递归定义的，与平常所做的完全平方数类型的开关灯题不同。

---

考虑 $a$ 的所有除自身以外的因数 $d$，参考 `press` 函数，容易发现对于每次对 $d$ 的修改后，必然会修改 $a$。

令 $\text{cnt}_i$ 表示 $i$ 被修改的次数，可以发现，
$$
\text{cnt}_i=\sum\limits_{\mathclap{d\mid i\operatorname{and}d\not=i}}{\text{cnt}_d}+1
$$
特别地，这个加 $1$ 是因为遍历到 $d$​ 时，对此的修改。

---

容易发现，当 $\text{cnt}_i$​ 为奇数时，灯开；反之，灯灭。

- 当 $i=1$ 时，显然 $\text{cnt}_i=1$，灯开。

- 当 $i\in\mathbb{P}$ 时，$\text{cnt}_i=\text{cnt}_1+1=1+1=2$，灯灭。

- 当 $i$ 为合数时，使用数学归纳法：

  > #### 命题
  >
  > 当 $i$ 为合数时，$\text{cnt}_i$ 为偶数。
  >
  > #### 证明
  >
  > 显然，$\text{cnt}_4=\text{cnt}_{1}+\text{cnt}_{2}+1=1+2+1=4$。
  >
  > 假设当前已经处理到了合数 $t$，则 $\text{cnt}_t$ 为偶数。
  >
  > 考虑 $t$ 的下一个合数 $p$，由于 $(t,p)$ 范围内的数都是质数，所以 $\text{cnt}_{t+1}=\text{cnt}_{t+2}=\cdots=\text{cnt}_{p-1}=2$。
  >
  > 对于 $p$ 的不等于 $1$ 并且不等于 $p$ 的因数 $r_i$，易知 $\text{cnt}_{r_{i}}$ 为偶数，那么其和也是偶数。
  >
  > 那么 $\text{cnt}_p=\text{cnt}_1+\sum\text{cnt}_{r_i}+1=1+\text{偶数}+1=\text{偶数}$​。
  >
  > 故得证。

综上所述，灯开着当且仅当 $k=1$ 的情况。

### $\textbf{Code}$

```cpp
#include <bits/stdc++.h>

int main() {
  int T, n, k;
  for (std::cin >> T; T; --T) {
    std::cin >> n >> k;
    if (k ^ 1) puts("NO"); // k != 1
    else puts("YES"); // k == 1
  }
  return 0;
}
```

---

## 作者：LKY928261 (赞：1)

### Solution

首先，进行偶数次完全相同的操作相当于没做。

将 `press(1)` 单独拎出来，得到：

```cpp
light[1]^=1;
for (int y=1+1;y<=n;y+=1) press(y);
for (int i=2;i<=n;i++) press(i);
```

发现 2、3 行操作完全相同，直接抵消，有用的只有一句 `light[1]^=1;`。

故灯开着当且仅当 $k=1$。

---

## 作者：JHR100330 (赞：1)

# 题解：P10565 [ICPC2024 Xi'an I] Chained Lights

[题目传送门](https://www.luogu.com.cn/problem/P10565)

该题虽然结论较简单，但是推导过程略微有些复杂。（请注意，本题与 [B2092](https://www.luogu.com.cn/problem/B2092) 和 [P1876](https://www.luogu.com.cn/problem/P1876) 较为相似但略有不同！在这两道题中，第 $i$ 个人要将 $i$ 的倍数编号的灯全部切换一次状态，但在本题中，「被切换状态的灯」也要再一次将「以它的编号的倍数为编号的灯」再次切换一次状态，然后继续递归下去，所以这三道题有所不同。）

## Solution

我们来分析一下这道题。

首先，对于 $i = 1$，在第一次时被打开，而后因为仅存在 $1 \mid 1$ 不会被再次操作，则最终状态为开启。

其次，对于所有 $i \in \mathbb{P}$，因为仅有 $1 \mid i$ 和 $i \mid i$，所以会被操作 $2$ 次，最终状态为关闭。

最后，对于其他所有的 $i$，首先 $1 \mid i$ 和 $i \mid i$，会被操作 $2$ 次，然后剩下的因数就分为两种情况：被「质因数」操作和被「非质因数」操作。（「非质因数」只非质的因数，即：是因数，但不是质数）

对于被「质因数」操作的情况，因为每个「质数」会被操作 $2$ 遍（已证），所以每个「质因数」会对 $i$ 进行两次操作，状态不变。

对于被「非质因数」操作的情况，令这个「非质因数」为 $t$，则 $t$ 对 $i$ 的操作次数取决于 $t$ 被操作的总次数，再枚举 $t$ 的因数分类讨论，一直递归下去，直到递归到一个除了 $1$ 和本身仅有「质因数」的数 $u$。

令 $u$ 的「质因数」个数为 $m$，此时，$u$ 的被操作次数 $v$ 即为 $m \times 2 + 2$。 

再递归回去，令 $t$ 的「质因数」个数为 $p$，「非质因数」个数为 $q$，则 $t$ 的被操作次数为：

$\begin{aligned}
  &(v_1 + v_2 + v_3 + \cdots + v_q) + p \times 2 + 2 \\
  &= \big \lbrack (m_1 \times 2 + 2) + (m_2 \times 2 + 2) + (m_3 \times 2 + 2) + \cdots + (m_q \times 2 + 2) \big \rbrack + p \times 2 + 2 \\
  &= m_1 \times 2 + m_2 \times 2 + m_3 \times 2 + \cdots + m_q \times 2 + q \times 2 + p \times 2 + 2 \\
  &=2 \times (m_1 + m_2 + m_3 + \cdots + m_q + q + p + 1)
\end{aligned}$

为 $2$ 的倍数。因为操作两次状态不改变，所以最终状态为关。

综上，仅有在 $i = 1$ 时灯最终状态为开，仅需要判断输入的 $k$ 是否等于 $1$，若等于 $1$，则输出 `YES`，否则输出 `NO`，我们会发现，此题答案与 $n$ 无关。

## AC Code：

```cpp
#include<bits/stdc++.h>

using namespace std;

int t, n, k;

int main() {
	cin >> t;
	while(t --){
		cin >> n >> k;
		if(k == 1) puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---


# 【MX-X1-T1】「KDOI-05」简单的无限网格问题

## 题目背景

原题链接：<https://oier.team/problems/X1A>。

## 题目描述

小 X 正在参加 KDOI 机器人锦标赛。

比赛场地是一个**无限大**的网格，小 X 的机器人初始时位于 $(1,1)$，他需要进行若干次操作，使得机器人移动到 $(n,m)$（$n,m\ge 2$）。

第 $i$ 次操作时，小 X 可以指定上、下、左、右中的一个方向和一个正整数 $x_i$，然后让机器人向该方向移动 $x_i$ 步。

不幸的是，小 X 的机器人出现了一些 bug，因此，他的操作必须满足一些限制，否则机器人就会立即爆炸：

+ 对于第 $i$ 次操作，若 $i$ 是奇数，则 $x_i$ 也是奇数；若 $i$ 是偶数，则 $x_i$ 也是偶数。

请帮助小 X 计算出使他的机器人到达 $(n,m)$ 的最小操作次数。

## 说明/提示

**【样例解释】**

对于第一组数据，可以按如下方式移动：

$$(1,1)\to(8,1)\to(8,7)$$

总共需要 $2$ 次操作。可以证明没有比这更优的操作方案。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n,m\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1$ | $30$ | $10$ | 无 |
| $2$ | $30$ | $10^9$ | $n,m$ 奇偶性相同 |
| $3$ | $40$ | $10^9$ | 无 |

对于 $100\%$ 的数据：$1\leq T\leq10^5$，$2\leq n,m\leq10^9$。

## 样例 #1

### 输入

```
3
8 7
999999 1000000
3 3```

### 输出

```
2
2
3
```

# 题解

## 作者：Submerge_TA (赞：5)

分类讨论题。

- $n \equiv 0 \pmod {2}, m \equiv 0 \pmod {2}$，第一次向右移动奇数格，第二次向上移动偶数格，第三次向右移动奇数格，共需 $3$ 步。

- $n \equiv 0 \pmod {2}, m \equiv 1 \pmod {2}$，第一次向上移动奇数格，第二次向右移动偶数格，共需 $2$ 步。

- $n \equiv 1 \pmod {2}, m \equiv 0 \pmod {2}$，第一次向右移动奇数格，第二次向上移动偶数格，共需 $2$ 步。

- $n \equiv 1 \pmod {2}, m \equiv 1 \pmod {2}$，第一次向右移动奇数格，第二次向上移动偶数格，第三次向上移动奇数格，共需 $3$ 步。

由于 $n,m\ge 2$，可知一定存在合理的构造方案。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

void solve() {
	int a, b, s;
	cin >> a >> b;
	if (a % 2 == 1 && b % 2 == 0) cout << 2;
	else if (a % 2 == 1 && b % 2 == 1) cout << 3;
	else if (a % 2 == 0 && b % 2 == 1) cout << 2;
	else cout << 3;
	cout << endl;
	return;
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int t;
	cin >> t;
	while (t--) solve();
	return 0;
}
```

---

## 作者：smydahaoren (赞：3)

**题目大意：**

求从 $(1,1)$ 点到点 $(n,m)$ 的最少步数。如果 $i$ 为偶数，那么第 $i$ 步只能往上下左右移动任意偶数长度。如果 $i$ 为奇数，那么第 $i$ 步只能往上下左右移动任意奇数长度。

**题目思路：**

分为两种情况，第一种情况如下图所示：

[![pkWBf78.png](https://s21.ax1x.com/2024/07/07/pkWBf78.png)](https://imgse.com/i/pkWBf78)

当 $n-1$ 和 $m-1$ 都为奇数时，从 $(1,1)$ 点出发移动第一步可以使得该点横坐标或者纵坐标值与目标点的对应值相等。因为另一个值的差仍然为奇数。所以需要至少2步完成操作，加在一起就是三步。

[![pkWBOBV.png](https://s21.ax1x.com/2024/07/07/pkWBOBV.png)](https://imgse.com/i/pkWBOBV)

移动方法给出后给出具体证明：因为每一次移动只能移动一个坐标值，且目标值和起始点两坐标均不相等，两次操作的距离都为奇数，所以至少需要 $3$ 次操作（在 $1$ 到 $3$ 中有两个奇数出现）。

相似的，对于两坐标之差均为偶数的情况，也需要用两个偶数操作距离实现，但由于 $1$ 和 $3$ 步的两奇数移动距离可以相加得出偶数，因此最少也是 $3$ 次操作。

对于另一种情况，如下图所示：

[![pkWBvAU.png](https://s21.ax1x.com/2024/07/07/pkWBvAU.png)](https://imgse.com/i/pkWBvAU)

当 $n-1$ 和 $m-1$ 的奇偶性不同时，可以通过先操作移动奇数距离的，再移动偶数距离的方法实现。

[![pkWBzh4.png](https://s21.ax1x.com/2024/07/07/pkWBzh4.png)](https://imgse.com/i/pkWBzh4)

因为要对横坐标和纵坐标分别操作，所以移动距离至少是 $2$ 步，也就是这种情况对应的最小次数。

**最终结论：**

当 $n-1$ 和 $m-1$ 奇偶性相同时，答案是 $3$ 次。

当 $n-1$ 和 $m-1$ 奇偶性不同时，答案是 $2$ 次。

**AC 代码：**

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6;
int n,m;
signed main(){
	int T;
	cin>>T;
	while(T--){//多次询问 
	cin>>n>>m;
	int i;
	if((n-1)%2==0&&(m-1)%2==0){//奇偶性相同 
		cout<<3<<endl;
	}
	if((n-1)%2==1&&(m-1)%2==1){//奇偶性相同 
		cout<<3<<endl;
	}
	if((n-1)%2==1&&(m-1)%2==0){//奇偶性不同 
		cout<<2<<endl;
	}
	if((n-1)%2==0&&(m-1)%2==1){//奇偶性不同 
		cout<<2<<endl;
	}
	}
	return 0;
}


```

---

## 作者：Hughpig (赞：3)

$n$ 和 $m$ 奇偶性不同时，显然一个是奇数一个是偶数。不妨设 $n$ 是偶数，$m$ 是奇数。可以先向右 $n-1$ 步到 $(n,1)$，再向上走 $m-1$ 步到 $(n,m)$。$n$ 是奇数，$m$ 是偶数同理。此时答案为 $2$。

两者奇偶性相同时：
* 如果两者都是奇数，可以先向右走 $n$ 步到达 $(n+1,1)$，再向上走 $m-1$ 步到 $(n+1,m)$，然后向左走 $1$ 步，到 $(n,m)$。共 $3$ 步。
* 如果两者都是偶数，可以先向右走 $n-1$ 步到 $(n,1)$，再先向上走 $m$ 步然后向下走 $1$ 步到 $(n,m)$。共 $3$ 步。

综上所述，两者奇偶性相同时答案为 $3$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int TestCases=1;
    cin>>TestCases;
    while(TestCases--){
    	long long n,m;cin>>n>>m;
    	if(n%2!=m%2)cout<<"2\n";
    	else cout<<"3\n";
    }
	return 0;
}
```

---

## 作者：dlzlj_2010 (赞：3)

先说结论：
1. 若 $n\equiv m\pmod{2}$，即 $n,m$ 奇偶性相同，那么至少需要 $3$ 步。
2. 否则最少只需要 $2$ 步。

证明：
1. 当 $n,m$ 同为奇数时，显然一种最少步数的走法为$(1,1)\rightarrow (n-1,1)\rightarrow (n-1,m)\rightarrow (n,m)$。  
同为偶数也同理，一种最少步数的走法为 $(1,1)\rightarrow (n,1)\rightarrow(n,m-1)\rightarrow(n,m)$。
2. 当 $n,m$ 一奇一偶时，不妨设 $n$ 为奇数，$m$ 为偶数，显然交换 $n,m$ 不影响结果，那么一种最少步数的走法为 $(1,1)\rightarrow (1,m)\rightarrow(n,m)$。

## code：
```cpp
#include<bits/stdc++.h>
using namespace std;

signed main(){
    int T;
    cin>>T;
    while(T--){
        int n,m;
        cin>>n>>m;
        if(n%2==m%2)cout<<"3\n";
        else cout<<"2\n";
    }
    return 0;
}
```

---

## 作者：chenlongli (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10713)
### 思路
我们尽可能在每一次操作一步到位。

我们分类讨论每一类情况：
- $n$ 是偶数，$m$ 是偶数，我们可以在第一次操作向下移动 $n-1$ 步，第二次操作移动 $0$ 步，第三次操作向右移动 $m-1$ 步，最少移动 $3$ 步。
- $n$ 是偶数，$m$ 是奇数，我们可以在第一次操作向下移动 $n-1$ 步，第二次操作向右移动 $m-1$ 步，最少移动 $2$ 步。
- $n$ 是奇数，$m$ 是偶数，我们可以在第一次操作向右移动 $m-1$ 步，第二次操作向下移动 $n-1$ 步，最少移动 $2$ 步。
- $n$ 是奇数，$m$ 是奇数，我们可以在第一次操作向下移动 $1$ 步，第二次操作向右移动 $m-1$ 步，第三次操作向下移动 $n-2$ 步，最少移动 $3$ 步。

综上所述，如果 $n,m$ 奇偶性相同，最少移动 $3$ 步，如果 $n,m$ 奇偶性不同，最少移动 $2$ 步。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	for (int i=0;i<t;i++)
	{
		int n,m;
		cin>>n>>m;
		if ((n+m)%2==1)
		{
			cout<<2<<endl;
		}
		else
		{
			cout<<3<<endl;
		}
	}
}
```

---

## 作者：So_noSlack (赞：2)

# 简易题意

我们初始在 $(1,1)$，需要经过若干次操作走到 $(n,m)$。

操作方式为每次可向上左下右走 $x_i$ 步，但需要满足当前操作次数与 $x_i$ 的奇偶性相同。

试求多少次操作可以走到 $(n,m)$。

# 思路

首先看到样例我们会有一种直观的感觉：答案不是 $2$ 就是 $3$ ？

显然我们的感觉是对的，那么下面我们着重思考一下为什么是 $2$ 或 $3$。

我们分两种情况考虑 $n,m$ 奇偶性相同或不同：

1. 对于奇偶性相同的情况，如 $n=5,m=7$，那么我们必定两次无法到达，一种最优的路径为 $(1,1) \to (1,7) \to (4,7) \to (5,7)$，故为 $3$ 次。
2. 对于奇偶性不同的情况，我们可以先走奇数次到达行或列的边界，再走偶数次到达 $(n,m)$，如 $n=3,m=100$，一种最优的路径为 $(1,1) \to (3,1) \to (3,100)$，故为 $2$ 次。

至此我们验证了最初的猜想，我们就可以放心的交代码了，~~虽然比赛时我并没有验证而直接交了代码~~。

代码如下：

```cpp
#include<iostream>
using namespace std;

long long T, n, m;

int main() {
	cin >> T;
	while(T --) {
		cin >> n >> m;
		if(n % 2 == m % 2) cout << "3\n";
		else cout << "2\n";
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/164490132)

---

## 作者：_Deer_Peach_ (赞：2)

题意：

要从起点 $(1,1)$ 的位置走到 $(n,m)$ 的位置，走第奇数次步时可以向上下左右一个方向走奇数个单位长度，第偶数次步时走偶数个单位长度，求最小需要多少步。

思路：

把网格看做一个大小为 $n \times m$ 的网格，要使步数小，那么每次就尽量走到底。

用样例举例：
```
8 7
```
从 $(1,1)$ 出发，到 $(8,1)$ 的距离刚好是奇数，算一步。从 $(8,1)$ 出发，到 $(8,7)$ 的距离刚好是偶数，算一步。最后答案就是 $2$ 步。

```
999999 1000000
```
从 $(1,1)$ 出发，到 $(1,1000000)$ 的距离刚好是奇数，算一步。从 $(1,1000000)$ 出发，到 $(999999,1000000)$ 的距离刚好是偶数，算一步。最后答案就是 $2$ 步。

```
3 3
```
从 $(1,1)$ 出发，到 $(1,2)$ 的距离是奇数，算一步。从 $(1,2)$ 出发，到 $(3,2)$ 的距离是偶数，算一步。从 $(3,2)$ 出发，到 $(3,3)$ 的距离是奇数，算一步。最后答案就是 $3$ 步。

从前两个样例中可以看出若 $n$ 与 $m$ 中有一个为奇数且另一个为偶数，那么需要的步数最小为 $2$。这条结论也不难证明，因为这样走的两个方向的距离是一个奇数和一个偶数，刚好可以走两步，所以答案为 $2$。

从第三个样例可以看出若 $n$ 与 $m$ 都是奇数时，最小步数为 $3$，这也不难证明，在结论一的基础上我们可以证明这条结论，一个奇数与一个偶数（结论一的条件）和两个奇数（结论二的条件）只改变了一个数，就是偶数变成了奇数，偶数与奇数的差是奇数，第三步刚好是走奇数步，所以得到了第二条结论。

现在考虑了两个奇数的情况与一奇一偶的情况，还剩下一个两个偶数的情况。在此情况下，所需最小步数为 $3$，这也可以在结论一的基础上证明，与证明结论二的方法基本相同。两个偶数与一奇一偶改变一个数，奇数变成了偶数，偶数与奇数的差为奇数，第三步刚好是走奇数步，所以得到了第三条结论。

将上面三个结论总结一下，就是当 $n$ 与 $m$ 中有一个奇数和一个偶数，那么只需要走 $2$ 步，否则要走 $3$ 步。

代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
signed main(){
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
     	if((n%2==1 and m%2==0) or (n%2==0 and m%2==1))cout<<2<<endl;
    	else cout<<3<<endl;
   	}
	return 0; 
}

```

---

## 作者：M4rkSELby (赞：2)

简易结论题。

显然，本题可以通过~~观察样例~~模拟得出结论：当 $n$，$m$ 奇偶性相同时，答案为 $3$，否则为 $2$。

因为当 $n$，$m$ 都为偶数时，我们可以先走到第 $n-1$ 行，再走到第 $m$ 列，最后走到第 $n$ 行，总步数为 $3$；当 $n$，$m$ 都为奇数时，我们可以先走到第 $n$ 行，再走到第 $m-1$ 列，最后走到第 $m$ 列，总步数也为 $3$。而当 $n$ 为奇数，$m$ 为偶数时，我们可以先走到第 $n$ 行，再走到第 $m$ 列，总步数为 $2$；当 $n$ 为偶数，$m$ 为奇数时，我们可以先走到第 $m$ 列，再走到第 $n$ 行，总步数为 $2$。以上走法均为最优走法之一。因此可以得出开篇的结论。

附上代码：

```cpp
#include<bits/stdc++.h>
//#define int long long
#define il inline
#define pii pair<int,int>
#define mk make_pair
#define mod 998244353
using namespace std;
il int rd(){
    int jya=0,tl=1;char jyt=getchar();
    while(!isdigit(jyt)){if(jyt=='-')tl=-1;jyt=getchar();}
    while(isdigit(jyt)){jya=(jya<<1)+(jya<<3)+(jyt-'0');jyt=getchar();}
    return jya*tl;
}
il void wr(int jjy){
    if(jjy<0)putchar('-'),jjy=-jjy;
    if(jjy>9)wr(jjy/10);
    putchar(jjy%10+48);
}
il int max(int x,int y){return x>=y?x:y;}
il int min(int x,int y){return x<=y?x:y;}
const int JYAAKIOI=1145141919810;
int T;
long long n,m;
int main(){
	T=rd();
	while(T--){
		n=rd();m=rd();
		if((n+m)%2)putchar('2');
		else putchar('3');
		putchar('\n');
	}
    return 0;
}
```

---

## 作者：saixingzhe (赞：2)

# 思路

简单签到题，首先我们发现肯定是跟地图大小的奇偶有关，分四种情况讨论。

* $n,m$ 都为偶数，第一次移动到 $(1,m)$，第二次移动到 $(3,m)$，第三次移动到 $(n,m)$。

* $n,m$ 都为奇数，第一次移动到 $(2,1)$，第二次移动到 $(2,m)$，第三次移动到 $(n,m)$。

* $n$ 为奇数，$m$ 为偶数，第一次移动到 $(n,1)$，第二次移动到 $(n,m)$。

* $n$ 为偶数，$m$ 为奇数，第一次移动到 $(1,m)$，第二次移动到 $(n,m)$。

当然方案有无数种，但奇偶性一致。

所以我们发现当 $n,m$ 奇偶性相同时答案为 $3$，不同时答案为 $2$。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,a,b; 
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&a,&b);
		if(a%2==b%2)	printf("3\n");
		else	printf("2\n");
	}
    return 0;
}
```

---

## 作者：wanghonghui123 (赞：2)

## 思路
1. 奇数步操作必须移动奇数步。

2. 偶数步操作必须移动偶数步。

3. 机器人需要从 $(1,1)$ 移动到 $(n,m)$。

## 实现
1. 如果 $n-1$ 或 $m-1$ 是偶数，那么我们可以直接通过一次偶数步操作（如 $n-1$ 或 $m-1$）来完成该方向的移动。

2. 如果 $n-1$ 或 $m-1$ 是奇数，我们需要先通过一次奇数步操作（如 $1$）使机器人进入正确的方向，然后通过一次偶数步操作

## 计算操作次数
1. 对于每个方向（$n$ 和 $m$），如果距离是偶数，则操作次数为 $3$；如果距离是奇数，则操作次数为 $2$。

2. 总操作次数为两个方向操作次数的和（也就是 $n-1$ 和 $m-1$ 的和）。
## AC CODE:
### 注意：
- 注意，由于奇数步只能走奇数距离，偶数步只能走偶数距离，我们需要根据目标距离的奇偶性来规划操作。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int n,m;
        cin>>n>>m;
        int cnt = (n-1)+(m-1);
        if(cnt%2==0){
            cout<<3<<endl;
        }else{
            cout<<2<<endl;
        }
    }
    return 0;
}
```

---

## 作者：2huk (赞：2)

不难发现答案会很小。具体地，我们可以讨论 $n, m$ 的奇偶性：

- $n$ 偶 $m$ 奇：一种合法的走法是 $(1, 1) \to (n, 1) \to (n, m)$。共 $2$ 次；
- $n$ 奇 $m$ 偶：一种合法的走法是 $(1, 1) \to (1, m) \to (n, m)$。共 $2$ 次；
- $n$ 偶 $m$ 偶：一种合法的走法是 $(1, 1) \to (n, 1) \to (n, m - 1) \to (n, m)$。共 $3$ 次；
- $n$ 奇 $m$ 奇：一种合法的走法是 $(1, 1) \to (n - 1, 1) \to (n - 1, m) \to (n, m)$。共 $3$ 次。

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	int n, a, b;
	cin >> n;
	while (n -- ) {
		cin >> a >> b;
		if (a % 2 != b % 2) puts("2");
		else puts("3");
	}
	return 0;
}
```

---

## 作者：GXZJQ (赞：2)

# P10713 【MX-X1-T1】「KDOI-05」简单的无限网格问题 题解

[题目链接](https://www.luogu.com.cn/problem/P10713)

## 题目分析

这是一道找规律的题目。

考虑从他应该怎么走入手，进行分类讨论：

- 当行数之差与列数之差恰好一奇一偶时，可以用 $2$ 步完成操作，用第一步抵消差为奇数，用第二步抵消差为偶数即可；

- 当行数之差与列数之差奇偶性相同时，我们必须要在以起点和终点为对角线的一个矩形的一条边上花费两次操作，所以需要 $3$ 次操作即可完成。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define c continue;
using namespace std;
int T;
int n, m;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		cin >> n >> m;
		if (((n - 1) % 2 == 1 && (m - 1) % 2 == 0) || ((m - 1) % 2 == 1 && (n - 1) % 2 == 0)){
			cout << "2\n";
			c;
		}
		cout << "3\n";
	}
	return 0;
}
```

---

## 作者：HasNoName (赞：2)

### 思路

对 $n$ 和 $m$ 的奇偶性是否相同进行讨论。

如果 $n$ 和 $m$ 奇偶性不相同，则其中一定有一个数是偶数、一个数是奇数。第一步走为奇数步，如果 $n$ 是偶数，向下走到和目标同行的位置，否则走到和目标同列的位置。第二部必能走到目标。共二步。

如果 $n$ 和 $m$ 奇偶性相同，若 $n$ 和 $m$ 为奇数，则第一步和第三步走到和目标统一列的位置，第二步走到和目标统一行的位置。若 $n$ 和 $m$ 为偶数，则第一步走到和目标统一列的位置，第二步和第三步走到和目标统一行的位置。共三步

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T,n,m;
	cin>>T;
	while(T--)
	{
		cin>>n>>m;
		if((n&1)!=(m&1))cout<<2<<'\n';//奇偶性是否相同
		else cout<<3<<'\n';
	}
	return 0;
}
```

---

## 作者：xingshuyan000 (赞：1)

# 题目分析

### 题意理解

给定一个点 $(n,m)$，求把一个物体从点 $(1,1)$ 移动到点 $(n,m)$ 至少需要移动几次。其中，每次移动可以向上、下、左、右四个方向中的任意一个移动。**对于第 $i$ 次操作，若 $i$ 是奇数，则移动的步数也是奇数；若 $i$ 是偶数，则移动的步数也是偶数。**

### 如何解决

这道题让求最小操作次数，其实经过分析不难发现，答案只会是 $2$ 或 $3$。具体分析如下：

- 如果 $n,m$ 的奇偶性不同，那么只需要第一次移动到 $(n,1)$ 的位置，第二次移动到点 $(n,m)$ 的位置，答案是 $2$。

- 如果 $n,m$ 的奇偶性相同，如果 $n,m$ 都是奇数，那么只需要第一次移动到 $(n,1)$ 的位置，第二次移动到 $(n,m-1)$ 的位置，第三次移动到点 $(n,m)$ 的位置，答案是 $3$；如果 $n,m$ 都是偶数，那么只需要第一次移动到 $(n-1,1)$ 的位置，第二次移动到 $(n-1,m)$ 的位置，第三次移动到 $(n,m)$ 的位置，答案是 $3$。

综上所述，如果 $n,m$ 的奇偶性不同，答案是 $2$，否则答案为 $3$。

此题的数据范围 $1 \le n,m \le 10^9$，在 `int` 类型的范围内，所以就不需要开 `long long` 了。

# Code

既然已经分析到这里了，那么代码就不难了。代码应该不难理解，所以我就不加注释了。

```cpp
#include<iostream>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		int n,m;
		cin>>n>>m;
		if(n%2==0 && m%2==1 || n%2==1 && m%2==0)cout<<"2\n";
		else cout<<"3\n";
	}
	return 0;
}
```

---

## 作者：xxxalq (赞：1)

### 分类讨论：

如果两个坐标的奇偶性不同，就可以第一步走奇数的方向，第二步走偶数的方向。共 $2$ 步。

如果两个坐标都是偶数，则需要把其中一个偶数拆成两个奇数之和，第一步和第三步走。另一个偶数第二步走。共 $3$ 步。

如果两个坐标都是奇数，那么只能在一和三步走。共 $3$ 步。

综上所述，横纵坐标奇偶性相同走 $3$ 步，奇偶性不同走两步。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0;
	bool flag=false;
	char ch=getchar();
	while(ch>57||ch<48){
		if(ch=='-'){
			flag=true;
		}
		ch=getchar();
	}
	while(ch>=48&&ch<=57){
		x=(x<<1)+(x<<3)+(ch-48);
		ch=getchar();
	}
	return flag?-x:x;
}//快读
int T,n,m;
int main(){
	T=read();
	while(T--){
		n=read(),m=read();
		if((n&1)!=(m&1)){//判断奇偶性
			cout<<"2\n";
		} else{
			cout<<"3\n";
		}
	}
	return 0;
}
```

---

## 作者：jiangyunuo (赞：1)

### 题目大意：
本题意思很简单很简单，一个机器人在第奇数次移动要移动奇数步，在第偶数次移动也同理。最终，我们要让这个机器人从 $(1,1)$ 移动到 $(n,m)$。
### 大体思路：
本题主要考察的是奇偶性，别看它题面条件很多，感觉很复杂，但当你仔细观察样例的时候，你会发现，无论 $n$ 和 $m$ 有多大，但结果只有 $2$ 和 $3$，其实本题就两种情况：
1. $n$ 和 $m$ 奇偶性相同。
2. $n$ 和 $m$ 奇偶性不相同。

仔细想想，当第一种情况发生时，如果 $n$ 和 $m$ 都是偶数，那么可以按 $n \to m \to n$ 的顺序，$n$ 和 $m$ 分别表示横轴和纵轴，这就表示走横轴和纵轴的顺序，因为奇数加奇数等于偶数，偶数本身是偶数，可行；如果 $n$ 和 $m$ 都是奇数，那么可以按 $n \to m \to m$ 的顺序，因为奇数本身是奇数，而奇数加偶数等于奇数，因此可行，两种情况都只要 $3$ 步。  
当第二种情况发生时，我们可以先走要走长度为奇数的，再走另一条要走长度为偶数的，当然如果 $n$ 或 $m$ 为奇数时那要走的长度是偶数，如果为偶数，那要走的长度是奇数（因为要走的长度为尾减头），只需 $2$ 步即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t,m,n;
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n>>m;
		if((n%2)==(m%2))cout<<3<<endl;  //判断奇偶性是否相同，再根据奇偶性选择输出 2 或 3。
		else cout<<2<<endl;
	}
return 0;
}
```

---

## 作者：xiaoyang111 (赞：1)

## 前言

[题目传送门](https://www.luogu.com.cn/problem/P10713)

## 题解

### 思路

我们分类讨论一下。

首先我们按照行数的奇偶性分开讨论一下。

如果行数是奇数，列数是偶数，可以直接先往下走奇数步走到最下面，然后再往右走偶数步直接就到终点了。所以只用走两步。图就是下面这样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/wiy4utd2.png)

对于列数是奇数，行数是偶数的，直接把操作反过来就可以了，先右再下。

对于行数是奇数，列数是奇数，可以先向下走奇数步到最下面，往右走偶数步刚好比终点右边多一格，然后反过来往终点走一步。所以只用走三步。图是下面这样的，绿色表示返回来那一步。

![](https://cdn.luogu.com.cn/upload/image_hosting/ep4wbd9h.png)

对于行数是偶数，列数是偶数，先往右走奇数步，里终点那一行就差一步，再走偶数步往下走，再往右走一格。共用三步。图是下面这样子的。

![](https://cdn.luogu.com.cn/upload/image_hosting/rfd1fcaj.png)

总结一下，如果奇偶性不相同，用两步。如果奇偶性相同，用三步。

### 实现

实现应该很好写吧。

```cpp
#include <iostream>
using namespace std;
void solve(){
    int n,m;
    scanf("%d%d",&n,&m);
    if (n%2==m%2){
        printf("3\n");
    }else{
        printf("2\n");
    }
}
int main(){
    int T;
    cin >> T;
    for (int _=0;_<T;++_){
        solve();   
    }
    return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

下面我们规定：上、下走时一个方向，左、右走是一个方向。

如果 $n,m$ 一奇一偶，那么第一次按照奇数的那个方向走到头，第二次顺着偶数那个方向走到头即可（答案是 $2$）。

如果 $n,m$ 同是奇数，第一次顺着一个方向走到头，第二次顺着**另一个方向走任意偶数步**，由于原来距离这个方向是奇数次，走了偶数次，还剩奇数次，于是第 $3$ 次走到终点，共 $3$ 次。

如果同是偶数，那第一次顺着一个方向走任意奇数步，第二次顺着另一个方向走到与**终点平行**，然后最后一步走到终点，奇偶性论证和同奇数一样。

得出结论：$n,m$ 奇偶性相同答案是 $3$，否则是 $2$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
int main(){
    for(cin>>T;T;--T){
        cin>>n>>m;
        if((n&1)==(m&1))
            cout<<"3\n";
        else
            cout<<"2\n";
    }
    return 0;
}
```

---

## 作者：fish_love_cat (赞：1)

签到。

---

注意到相邻两次操作的奇偶性不同，那么对于答案的贡献的奇偶性也不同。第一步可以使当前点某一坐标变为偶数，第二部则可以使当前点令一坐标变为奇数。所以在目标点横纵坐标奇偶性不同时，两步可以搞定。

在目标点横纵坐标奇偶性相同时，我们可以用两步走到目标的邻点，然后第三步走一个单位长度即可。共计需要三步。

然后就做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int t;
    cin>>t;
    while(t--){
        int n,m;
        cin>>n>>m;
        int x=(n%2)^(m%2);//不同为一相同为零
        if(x==1)puts("2");
        else puts("3");
    }
    return 0;
}
```

---

## 作者：LG086 (赞：1)

### 分析

一共 $T$ 组数据，每组数据输入 $x$ 和 $y$，判断需要几步可以移动到 $(x,y)$。

当 $x$ 为奇数，$y$ 为偶数时，第 $1$ 次操作可以先移动 $y-1$ 步到 $(1,y)$，第 $2$ 次操作可以移动 $x-1$ 步到 $(x,y)$。  
当 $x$ 为偶数，$y$ 为奇数时，第 $1$ 次操作可以先移动 $x-1$ 步到 $(x,1)$，第 $2$ 次操作可以移动 $y-1$ 步到 $(x,y)$。  
当 $x$ 为奇数，$y$ 为奇数时，第 $1$ 次操作可以先移动 $y-2$ 步到 $(1,y-1)$，第 $2$ 次操作可以移动 $x-1$ 步到 $(x,y-1)$，第 $3$ 次操作可以移动 $1$ 步到 $(x,y)$。  
当 $x$ 为偶数，$y$ 为偶数时，第 $1$ 次操作可以先移动 $y-1$ 步到 $(1,y)$，第 $2$ 次操作可以移动 $x-2$ 步到 $(x-1,y)$，第 $3$ 次操作可以移动 $1$ 步到 $(x,y)$。

综上得出结论：当 $x$ 和 $y$ 奇偶性不同时，答案为 $2$。若 $x$ 和 $y$ 奇偶性相同时，答案为 $3$。


------------
### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int T,a,b;
signed main(){
    cin>>T;while(T--){
        cin>>a>>b;
        if(!(a%2)&&b&1)puts("2");
        else if(a&1&&!(b%2))puts("2");
        else puts("3");
    }
}
```

---

## 作者：Lemon_zqp (赞：1)

### 思路
简单签到，因为他说 $x_i$ 的奇偶性只要与 $i$ 的奇偶性相同即可，也就是说 $x_i$ 可以无限大，那么不难想到，若一个为奇数，一个为偶数，则第一次到为奇数的坐标，第二次到偶数的坐标，如果要到 $(3,4)$ 这个点，则 $(1,1)-(3,1)-(3,4)$。如果要到 $(6,5)$，则 $(1,1)-(1,5)-(6,5)$，两种情况可以证明都只需要两步，所以得出第一个结论，当 $n$ 与 $m$ 的奇偶性不同时，则直接输出 $2$。如果奇偶性相同呢，不难发现，当两个数都为奇数时，只要让一个数做两次即可，因为当 $i$ 为 $1$ 时，其中一个奇数可以直接到达，而另一个数需要加一次偶数再加一次奇数完成。例如要到 $(5,7)$ 这个点，则其中一种方法为 $(1,1)-(5,0)-(5,4)-(5,7)$。当两个数都为奇数时，方法相同，因为当 $i$ 为 $1$ 时，其中一个偶数可以先加上一个奇数，而另一个数就可以在下一次直接完成，到下次 $i$ 为奇数时前面那个只加了一个奇数的偶数就可以再加一个奇数，从而完成。例如要到 $(4,8)$ 这个点，则其中一种方法为 $(1,1)-(1,0)-(1,8)-(4,8)$，那么这两种奇偶性相同的情况就都只要输出 $3$ 即可。

最后总结一下结论：
- 当两个数奇偶性不同时输出 $2$。
- 当两个数奇偶性相同时输出 $3$。

每次判断时间复杂度为 $O(1)$，总时间复杂度为 $O(t)$，可以通过此题。
### 代码
```
#include<bits/stdc++.h>
#define int long long
const int mod = 1e9 + 7;
using namespace std;

signed main()
{
	int t;
	cin >> t;
	while(t--){
		int n, m;
		cin >> n >> m;
		if((n % 2 == 0 && m % 2 != 0) || (n % 2 != 0 && m % 2 == 0)){
			cout << 2 << endl;
		}
		else{
			cout << 3 << endl;
		}
	}
	return 0;
}

```

---

## 作者：PeppaPig_qwq (赞：1)

分类讨论一下即可。首先，$n, m$ 奇偶性不同只需两步。否则，总可以先向 $x$ 或 $y$ 轴走一步，将问题化为 $n, m$ 奇偶性不同不同，所以要三步。

代码:
 ```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;
    for (; t; t--) {
        int n, m;
        cin >> n >> m;
           cout << (((n ^ m) & 1) ? 2 : 3) << '\n';
    }
    return 0;
}

```

---

## 作者：JYX0924 (赞：1)

这道题有一个很显然的结论：若 $a$ 和 $b$ 模 $2$ 的余数一样，就输出 $3$，否则输出 $2$。

证明：第一次走奇数步，第二次走偶数步，就会走到一个横纵坐标一奇一偶的点，走了第三步就会走到一个横纵坐标都是奇数或都是偶数的点。

下面是我的 AC 代码。

```c
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll T,x,y;
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>x>>y;
		if(x%2==y%2) cout<<"3\n";
		else cout<<"2\n";
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：StarsIntoSea (赞：1)

# Solution

贪心题。

由于 $n,m \ge 2$，不用考虑 $n$ 或 $m$ 为 $1$ 的情况，至少需要两步。

第一种为 $n$ 为奇数**或** $m$ 为奇数，这种情况只需要在第一步走其中一个奇数，第二步走剩下的偶数即可，答案为 $2$。

第二种为二者**均为**奇数或偶数，这种情况因为在前两步会出现其中一步出现不符的情况，因此需要额外的一步，答案为 $3$。

# Code

```cpp
#include <stdio.h>
int main(){
	int T; scanf("%d",&T);
	while(T--){
		int n,m; scanf("%d%d",&n,&m);
		int ans=(n&1)+(m&1);
		printf("%d\n",ans&1?2:3);
	}
}
```

---

## 作者：qhr2023 (赞：1)

## 思路

我们先要知道，如果没有奇偶性的限制，$(1,1)$ 到 $(n,m)$ 只需移动 $2$ 次，分别移动 $n-1$ 和 $m-1$ 个单位。

加上了限制后，如果还想只移动 $2$ 次，就需要保证每次移动距离奇偶性不同。

那么，若 $m$ 和 $n$ 奇偶性不同，即 $n-1$ 和 $m-1$ 奇偶性不同，移动 $2$ 次即可，否则需移动 $3$ 次。

## code

```cpp
#include <bits/stdc++.h>  
using namespace std;  
int main() { 
	int T, n, m;
	cin >> T;
	while (T--) 
		cin >> n >> m,
		cout << (n%2==m%2?3:2) << '\n';
    return 0;  
}
```

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10713)

简单题。可以观察到，机器人需要增加 $n-1$ 的横坐标和 $m-1$ 的纵坐标才能到达 $(n,m)$，而题目中又说到奇数次操作必须移动奇数步，偶数次操作必须移动偶数步，所以如果 $(n-1)\bmod2=(m-1)\bmod2$，其实也就是 $n\bmod2=m\bmod2$，就不能在第一次或者第二次操作满足题目的条件，需要 $3$ 次操作，否则就是 $2$ 次。

---

## 作者：_O_v_O_ (赞：1)

结论题，秒了。

# 思路

## 结论

- 如果 $n\bmod 2=m\bmod 2$，那么输出 $3$。
- 否则输出 $2$。

## 证明

我们转化一下题意：

> 有 $x$ 个数 $a_1,a_2,a_3,\cdots a_x$，你要满足它们可以分成两组 $b,c$，满足 $b$ 中元素之和为 $n-1$，$m$ 中和为 $m-1$。
>
> 设 $a$ 中有 $d_1$ 个奇数，$d_2$ 个偶数，你需要满足 $d_1-d_2=x\bmod 2$。
>
> 你需要让 $x$ 最小。

首先我们来看 $n\bmod 2\not= m\bmod 2$ 的情况：

因为 $n\bmod 2\not= m\bmod 2$，所以 $n,m$ 一定恰好有一个奇数和一个偶数，也就是说，$n-1$ 和 $m-1$ 也一定恰好有一个奇数和一个偶数。  
那么我们构造出 $a=\{n-1,m-1\}$ 即可（当 $(n-1)\bmod 2=0$ 时，交换两项即可。），$x=2$，可以证明这是 $x$ 最小的方案。


------------

其次，我们来看 $n\bmod 2 = m\bmod 2$ 时：

因为 $n\bmod 2 = m\bmod 2$，所以 $(n-1)\bmod 2=(m-1)\bmod 2$。  
那么我们可以构造出：

- 当 $n\bmod 2=m\bmod 2=1$ 时，$a=\{n,m-1,1\}$。
- 否则，$a=\{n+1,2,m-1\}$。

这两种方法中 $x=3$，可证明这是 $x$ 最小的方案。


# 代码

代码很短：

```cpp
#include<bits/stdc++.h>
using namespace std;

int T;
int n,m;

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>m;
		if(n%2==m%2) cout<<3<<endl;
		else cout<<2<<endl;
	}
	return 0;
}
```

---

## 作者：Scean_Tong (赞：1)

## P10713 【MX-X1-T1】「KDOI-05」简单的无限网格问题题解

### 题意
从一个点开始走，第奇数次可以走任意奇数距离，第偶数次可以走任意偶数距离。问走到一个点最少要几步。

### 思路
显然，如果 $n$ 与 $m$ 的奇偶性不同，那么第 $1$ 步可以直接走到与 $(n,m)$ 水平或垂直的直线上，第 $2$ 步即可直接走到 $(n,m)$ 点，共需要两次。 

如果 $n$ 与 $m$ 奇偶性相同，若都为奇数，则第 $1$ 步可以走到与 $(n,m)$ 水平或垂直的直线旁边，第 $2$ 步可以直接走到 $(n,m)$ 点四周，第 $3$ 步即可走到 $(n,m)$ 点。若都为偶数，那么第 $1$ 步可以走到与 $(n,m)$ 水平或垂直的直线上，第 $2$ 步只能走到 $(n,m)$ 点的四周，第 $3$ 步即可走到 $(n,m)$ 点。

易得结论：若 $n$ 与 $m$ 奇偶性相同，答案为 $3$；若 $n$ 与 $m$ 奇偶性不同，答案为 $2$。

### 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		if((n%2==1&&m%2==1)||(n%2==0&&m%2==0)){
			cout<<3<<'\n';
		}
		else cout<<2<<'\n';
	}
	return 0;
} 

```

---

## 作者：xiaozhangawa (赞：0)

[题目传送门](/problem/P10713)

------------

## 题目大意

有一个无限大的网格，有一个点在 $(1,1)$ 处。它可以向上、下、左、右四个方向移动，移动的格数不限。但对于每个第 $i$ 次移动，格数的奇偶性必须与 $i$ 相同。求移动到 $(n,m)$ 的最少步数。

## 思路

~~妥妥的贪心题。~~

首先，我们发现题目中提到了**奇偶性**这三个字，那么我们就优先从奇偶性来分析。

因为题中提到：$n,m\ge 2$，因此，不可能 $1$ 步走到。考虑剩下的一种最优情况，即 $2$ 步走到。此时正好走了一个奇数和一个偶数，而此时到了 $(n,m)$，说明 $n,m$ 的**奇偶性不同**。

既然有奇偶性不同的情况，当然也得考虑**奇偶性相同**的情况。此时，很显然 $2$ 步也是走不到的。这时，我们在分两个情况进行讨论。

1. $n,m$ 均为奇数，此时我们可以先横向走到 $(1,m)$，再纵向走到 $(n+1,m)$ 或 $(n-1,m)$。接着又可以走奇数步，就把差的 $1$ 格补上就好了。

1. $n,m$ 均为偶数，此时我们可以先横向走到 $(1,m+1)$ 或 $(1,m-1)$，再纵向走到 $(n,m+1)$ 或 $(n,m-1)$。接着又可以走奇数步，就把差的 $1$ 格补上就好了。

综上所述，奇偶性不同时，需要 $2$ 步走到；奇偶性相同时，需要 $3$ 步走到。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t,n,m;
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(n%2 != m%2) cout<<2<<endl;//奇偶性不同
		else cout<<3<<endl;//奇偶性相同
	}
	return 0;
}
```

---

## 作者：Breath_of_the_Wild (赞：0)

观察样例，能够猜测出：答案要么为 $2$，要么为 $3$。

题目要求我们，第一步走奇数步，第二步走偶数步，第三步走奇数步。如果 $2$ 次能到终点，说明就一定走了奇数步。为了让步数尽可能少，显然要第一次先朝横轴或纵轴方向之一走到头，再朝另一个方向到终点。不拐弯，不重复走。此时走了 $(n-1+m-1)$ 步。

故只需要判断 $(n-1+m-1)$ 是否为奇数（或 $n+m$），即输出 $2$。否则还得补上一步，输出 $3$。

代码不贴了。

---


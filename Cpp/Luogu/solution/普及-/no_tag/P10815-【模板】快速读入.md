# 【模板】快速读入

## 题目背景

**套取数据直接输出抢最优解是恶劣的违规行为，根据情节轻重，最高可以直接封号。**

制约解除作战！

## 题目描述

给你 $n$ 个数，你需要求和并输出。

## 说明/提示

对于 $25\%$ 的数据，满足 $n=10^5$。

对于 $25\%$ 的数据，满足 $n=10^6$。

对于 $25\%$ 的数据，满足 $n=10^7$。

对于 $25\%$ 的数据，满足 $n=10^8$。

对于 $100\%$ 的数据，满足所有数在 $[-n,n]$ 之间。

数据保证对于序列的任何前缀，这个前缀的和在 32 位有符号整形的存储范围内。

## 样例 #1

### 输入

```
5
-1 2 -3 4 -5```

### 输出

```
-3```

# 题解

## 作者：KobeBeanBryantCox (赞：97)

# P10815 【模板】快速读入 题解

---------------------

[题目传送门](https://www.luogu.com.cn/problem/P10815)。

题目好评！

这篇题解讲一下快读的原理，顺便讲一下快输的原理。

update on 2025-2-3：更新了原理，之前的原理是有问题的（感谢 [@LionBlaze](https://www.luogu.com.cn/user/911054) 大佬）。

update on 2025-6-28：被[这个](https://www.luogu.com.cn/ticket/HQVY773965) Hack 了，真恶心，改了一下。

----------------------------

## 快读

>  我们都知道 `getchar` 的速度快于普通的 `cin` 或者 `scanf`（原因放在了最后），于是我们考虑能不能使用 `getchar` 读入字符代替数字。
>
> 众所周知，每个可见字符都有其对应的 ASCII 码编号，那我们就考虑使用字符的编号与数字进行联系。

~~上面两句其实是废话。~~

这显然可以做到。

于是我们就按照顺序读入数字。

我们应该先读入掉前面没用的字符，比如空格之类的。

同时应该注意如果读入减号，我们应该打一个标记表示这个数字是负数。

```cpp
char c=getchar();
while(c<'0'||c>'9') // 非数字的过滤掉
{
    if(c=='-')f=-1; // 标记是负数
    c=getchar();
}
```

然后再读入数字，从高位到地位，每次读入一个个位数，我们应该把原来已经读入好的乘 $10$ 再加上这个个位数。

举个例子，读入了 $3$，原来的是 $12$，我们要的效果是 $123$，那么我们先 $12\times 10=120$，再 $120+3=123$。

这个应该都能理解吧，如果理解不了，可以想想小学做竖式计算的过程和这个有什么联系。

```cpp
while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar(); // 注意是数字才读入，然后 c-'0' 的意思是找到 c 对应的个位数
```

### 总快读代码：

```cpp
int in()
{
    int k=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
    return k*f; // 别忘记标记的负数要乘进去
}
// 调用时用 n=in();
```

-----------------

## 快输

由快读同理可得，我们能使用 `putchar` 代替普通输出。

由于按位输出，从高到低，不好操作，这里采用递归的形式。

不知道递归的读者出门右转，度娘在等您。

先处理负数。

```cpp
if(x<0)putchar('-'),x=-x;
```

然后分类讨论。

1. 小于 $10$，代表是个位数，直接输出数字对应的字符：

```cpp
if(x<10)putchar(x+'0');
```

2. 大于等于 $10$，这个时候应该先递归输出高位，再输出低位。

```cpp
else out(x/10),putchar(x%10+'0'); 
```

其中 `x/10` 是去掉个位后的 $x$；`x%10` 是取出 $x$ 的个位。不懂的可以像我上面那样举例自己验证。

### 总快输代码：

```cpp
void out(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else out(x/10),putchar(x%10+'0');
}
// 直接调用 out(n) 就行了
```

-----------------

## 本题 AC 代码

注意一下本题卡常，要用 `getchar_unlocked`，原理跟 `getchar` 差不多，只不过更快一点。

不过不建议平时写题用这个，因为有些编译器会报错。

update on 2025-6-28：被卡 `int` 了，全部改成 `long long` 就能过了。

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb; // 至于这个是什么，咳咳，我不说
#define int long long
int in()
{
    int k=0,f=1;
    char c=getchar_unlocked();
    while(c<'0'||c>'9')
    {
        if(c=='-')f=-1;
        c=getchar_unlocked();
    }
    while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar_unlocked();
    return k*f;
}
void out(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else out(x/10),putchar(x%10+'0');
}
signed main()
{
    int n=in(),sum=0;
    while(n--)sum+=in();
    out(sum);
    return 0;
}
```



----------------

## 快读快输比正常输入输出快的原因

update on 2025-2-3：将此段不合理的表述删去，加入正确的内容。

### `cin` 和 `cout` 的特点
- **同步流**：`cin` 和 `cout` 与 C 语言的标准输入输出流（`stdin` 和 `stdout`）是同步的。这种同步机制保证了在混合使用 C++ 的 `cin`/`cout` 和 C 的 `scanf`/`printf` 时不会出现输入输出混乱的情况。但同步操作会带来额外的开销，因为每次进行输入输出操作时，都需要进行一些同步检查和处理，这会降低输入输出的效率。我们常说的关闭同步流就是在这里进行加速。
- **格式化处理**：`cin` 和 `cout` 支持丰富的格式化输入输出功能，例如可以方便地处理不同类型的数据（如整数、浮点数、字符串等），并且可以通过 `setw`、`setprecision` 等操纵符进行格式化设置。然而，这些格式化处理需要进行复杂的类型检查和转换，会消耗较多的时间。（注：[@LionBlaze](https://www.luogu.com.cn/user/911054) 大佬说 `cout` 是调用了 `sprintf` 这个比较慢的函数，不过正确性未知。）

### `scanf` 和 `printf` 的特点
- **格式化解析**：`scanf` 和 `printf` 是 C 语言中的输入输出函数，它们也需要进行格式化解析。例如，`scanf("%d", &num)` 需要解析格式字符串 `%d`，并根据该格式从输入中读取相应的数据。这种格式化解析过程会带来一定的开销，尤其是在处理大量数据时，开销会更加明显。

**~~不过上面这一段我觉得一点用都没有，快读快输比正常读入输入快这一条性质背下来就行了啊 QAQ。~~**

-----------------------

## 后记

如果有什么写的不好或者错误的地方，欢迎评论指出！

---

## 作者：残阳如血 (赞：39)

## $\textbf{Description}$

给定 $n\,(n\le 10^8)$，求这 $n$ 个数的和。

## $\textbf{Solution}$

### $75$ 分做法

#### 做法 1（关于 `scanf/printf` 的优化）

非常遗憾，笔者暂时没有想出来 `scanf/printf` 应该如何优化。

但是直接使用 `scanf/printf` 已经与极致优化后的 `cin/cout` 没有多大区别了。

> `scanf/printf` 比较慢的原因：
>
> - 这是内置库的函数，会有一定的安全性保障，会处理异常以及线程安全等。
> - `scanf/printf` 需要在程序运行时解析格式串，会浪费一定的时间。

#### 做法 2（关于 `cin/cout` 的优化）

~~关于 cin/cout 不使用优化也能 70 分这件事。~~

使得人们愿意写 `std::cin/std::cout` 的原因应该主要是不用记格式符吧。。。

---

众所周知，`std::cin/std::cout` 是非常慢的。

但是其之所以如此之慢，是因为其与 `printf/scanf` 有着流绑定，那么每次都要两者同步，所以非常慢。

解决方法：`std::ios::sync_with_stdio(0)`。

这样两者就解绑了。

---

但是 `std::cin` 仍然可以优化，而且这个优化的效果更加明显。

C++ 中 `std::cin` 和 `std::cout` 也是绑定的，那么每次读入前都会调用 `std::cout` 刷新缓冲区，所以也会变慢。

解决方法：`std::cin.tie(0)`。

注意，`std::cout` 没有绑定，故 `std::cout.tie(0)` 没有优化。

---

将两个优化合并在一起，可以这样写：`std::cin.tie(0)->sync_with_stdio(0)`。

需要注意的是，在交互题中每次都需要刷新缓冲区。

刷新方法：`std::cout.flush()`。

故推荐一种写法：

```cpp
int main() {
  std::cin.tie(0)->sync_with_stdio(0);
  // do something
  std::cout.flush(); // 这里其实 std::cout << std::endl 也能刷新，但是 std::cout << '\n' 不能。
  return 0;
}
```

需要注意，这样写了之后，不能同时使用 `std::cout/printf`，也不能同时使用 `std::cin/scanf`，否则会出现异常。

此外，尽量不要使用 `std::endl`，推荐使用 `std::cout.flush` 加上 `'\n'`。

#### 做法 3

上述优化后，`std::cin/std::cout/scanf/printf` 系列函数已经达到了其的时间下限，难以优化了。

使用 `getchar()`。

`getchar()` 时每次读入一个字符的，速度比较快，这样就可以跳过缓慢的 C++ 内置的读入输出了。

---

代码如下：

```cpp
template <typename T>
T read() {
	T val = 0, sgn = 1; // val：绝对值，sgn：符号
	int ch = getchar();
	for (; !isdigit(ch); ch = getchar()) // 如果不是数字，那么就可能是负号
		if (ch == '-') sgn = -sgn; // 如果是负号，那么就更换符号位
	for (; isdigit(ch); ch = getchar()) // 读入数字
		val = val * 10 + ch - '0';
	return sgn * val;
}

template <typename T>
void write(const T &val) {
	static char stk[50];
	auto x = val; // 拷贝一份
	bool flag = false; // 是否是负数
	if (x < 0) flag = true, x = -x; // 记录并将其改为非负数
	size_t top = 0; // 栈顶指针
	do stk[top++] = x % 10, x /= 10; // 将数字存入一个栈中
	while (x);
	if (flag) putchar('-'); // 是负数就先输出负号
	while (top) putchar(stk[--top] + '0');
}
```

调用方法：

```cpp
int n = read<int>();
long long x = read<long long>();
write(n);
write(x);
```

### $100$ 分做法

#### 做法 1

考虑使用 `getchar_unlocked()`。

只需要将上面代码中的 `getchar()` 全部替换为 `getchar_unlocked()`，那么速度就会加快。

需要注意的是，`getchar_unlocked()` 只能在 $\text{Linux}$ 上使用，在 $\text{Windows}$ 环境下会 $\text{CE}$，故不推荐使用这种写法。

#### 做法 2

`fread()` 是个好东西。

`fread()` 可以一次读入许多字符，甚至可以一次性读入整个文件。

对于输出，也有 `fwrite()` 函数。

原型：

```cpp
std::size_t fread(void* buffer, std::size_t size, std::size_t count,
                  std::FILE* stream);
std::size_t fwrite(const void* buffer, std::size_t size, std::size_t count,
                   std::FILE* stream);
// fread(buf, 1, SIZE, stdin) 表示从标准输入输出中读入 SIZE 个大小为 1 byte 的数据块到 buf 中。
```

可以手动开一个缓冲区 `buf`，并将其大小置为 $2^{20}$​。

所以可以重新定义 `getchar()`：

```cpp
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) ? EOF : *p1++)
```

解释：尝试读入，如果两个指针指向了同一个位置并且读入后仍然如此，说明文件已经读入完毕，返回 `EOF`（终止符），否则返回读入的第一个字符。

### $\textbf{Code}$

```cpp
#include <bits/stdc++.h>
using lint = long long;

// #define DEBUG 1  // 调试开关
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}

  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  char gc() {
#if DEBUG  // 调试，可显示字符
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }

  bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }

  template <class T>
  T read(T &x) {
    double tmp = 1;
    bool sign = 0;
    x = 0;
    char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
		return x;
  }

  void read(char *s) {
    char ch = gc();
    for (; blank(ch); ch = gc());
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }

  void read(char &c) { for (c = gc(); blank(c); c = gc()); }

  void push(const char &c) {
#if DEBUG  // 调试，可显示字符
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }

  template <class T>
  void write(T x) {
    if (x < 0) x = -x, push('-');  // 负数输出
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }

  template <class T>
  void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

int main() {
	int n = io.read(n);
	lint sum = 0;
	for (int t; n; --n) sum += io.read(t);
	io.write(sum, '\n');
	return 0;
}
```

> PS：本文部分参考了 [OI Wiki](https://oi-wiki.org/contest/io/#输出优化)，快读快输代码也来自于此。

---

## 作者：King_and_Grey (赞：18)

## [P10815 【模板】快速读入 题解](/problem/P10815)

在 C++ 中，输入一般使用 `cin`、`cout`。但是他们的速度很慢（是因为 `cin` 和 `cout` 为了兼容 C 语言的读入输出在性能上做了妥协）而一些题目在一些题目中，读入的数据量很大，往往超过了 $10 ^ 5$ 的数据量，这时就容易超时。接下来我会介绍几种优化方法。

### 第一种：解锁

```cpp
ios::sync_with_stdio(false);
cin.tie(0),cout.tie(0);
```

对 `cin` 和 `cout` 进行解锁使 `cin` 和 `cout` 的速度几乎接近 `scanf` 和 `printf`（甚至超过），这样避免输入输出超时。

注意：`cin`、`cout` 解锁使用时，不能与 `scanf`，`getchar`，`printf`，`getline()`，也不能与 `freopen` 连用，否则会出错。

此外：解锁后会导致在 `cout << endl;` 使清空缓存，如果大量使用 `cout << endl;` 的话反而会增加程序输出时间，所以可以换成 `\n`。

[但是这并不能通过此题。](/record/169208925)

### 第二种：使用 C 风格

`scanf`、`printf` 这两个函数来源于传统的 C，在 `stdio.h` 和 `cstdio`（C++）中。使用方法：
```
scanf("%占位符",&var);
printf("%占位符\n",var);
```
这样比传统的 `cin`、`cout` 快，但由于书写复杂而很少被人采用。

### 第三种：快读快写

快读基本思想：

1. 一位一位读入，对当前字符进行分析，（第一位是判断是否为负号）
2. 讲读入的数字处理（因为是字符）后存入
3. 最后返回数值

#### 代码：
```
int read() {
  int x = 0, w = 1;
  char ch = 0;
  while (!isdigit(ch)) {  // ch 不是数字时
    if (ch == '-') w = -1;        // 判断是否为负数
    ch = getchar();               // 继续读入
  }
  while (isdigit(ch)) {  // ch 是数字时
    x = x * 10 + (ch - '0');        // 将新读入的数字加在 x 的后面，就是秦九昭算法
    ch = getchar();                 // 继续读入
  }
  return x * w;                     // 数字 * 正负号 = 实际数值
}
void write(int x){
	if (x < 0) putchar('-'), x = -x;//判断是否为负数
	if (x > 9) write(x / 10);       //逐位分解，递归输出
	putchar(x % 10 + '0');          //转换为字符输出
}
```

### 快读快写进一步优化

#### 对于 `int read()`

我们可以在 `int` 前面加个 `inline`，`inline`（内联）对于多次调用的函数有着非常明显的加速作用，而快读明显非常常用。

关于 `inline` 的优缺点：

优点：对于一些较小的函数，如果频繁调用，可以将其设计为内联函数，省去了执行函数地址转移等操作，占用系统资源更少，执行效率更高。        
缺点：如果调用内联函数的地方太多，就会造成代码膨胀，因为编译器会把每个调用内联函数的位置都拷贝一份函数实现嵌入其中，重复的嵌入。

#### 对于 `x = x * 10 + (ch - '0'); `

数据的四位运算虽然简单，但是比位运算要慢。

计算机就是将数据以二进制进行运算，所以位运算比四位运算要快。

我们可以把 `x = x * 10 + (ch - '0'); ` 改成 `x = (x << 1) + (x << 3) + (ch ^ 48);`

其中，`x << n` 表示 $x$ 的二进制向左移动 $n$ 位空位补 $0$，相当于 $x = x \times 2 ^ n $，`(x << 1) + (x << 3)` 相当于 $x \times 10$（请读者自行推导）。

#### 对于 `getchar`

把 `getchar()` 改成 `getchar_unlocked()`，效率接近 [`fread`](https://blog.csdn.net/duduniao999/article/details/80875235)。

讲解完毕。

奉上万能模板：
```cpp
inline int read(){
	int x = 0, f = 1;
	char ch = getchar_unlocked();
	while (!isdigit(ch)){
		if (ch == '-') 
			f = -1;
		ch = getchar_unlocked();
	}
	while (isdigit(ch)){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar_unlocked();
	}
	return x * f;
}

inline void write(int x){
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
```

最后奉上本题的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar_unlocked();
	while (!isdigit(ch)){
		if (ch == '-') 
			f = -1;
		ch = getchar_unlocked();
	}
	while (isdigit(ch)){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar_unlocked();
	}
	return x * f;
}

inline void write(int x){
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

int main(){
	int n = read(),ans = 0;
	int a[n + 1];
	for(int i = 1;i<= n;i++){
		a[i] = read();
		ans += a[i];
	}
	write(ans);
	return 0;
}
```
[通过记录。](/record/169220622)

谢谢观看！！！

---

## 作者：fangzichang (赞：13)

虽然其实也很大众了，但是好像喜欢投题解的小朋友还没怎么会，所以补充一下其他题解没讲到的部分。   
首先有一个快读板子，然后只需要考虑实现里面负责逐字符读的函数。  

```cpp
void read(){};
template<class T1,class...T2>
inline void read(T1&ret,T2&...rest){
	ret=0;char c=gc();bool f=0;
	for(;!isdigit(c);c=gc())f=c=='-';
	for(;isdigit(c);c=gc())ret=ret*10+c-'0';
	f&&(ret=-ret),read(rest...);
}
```

### 无锁逐字符读入
唉我之前感觉这个东西我会用就非常牛，然后一下子突然就变大众了。  
普通的 `getchar` 带线程锁，然而 OI 用不上多线程，所以可以把它关了，大家知道我们有 `getchar_unlocked`。  
> 当然对于逐字符输出也有对应的 `putchar_unlocked`，对于直接输入也有 `fread_unlocked`，等等。  
不过一般来讲 OI 中 `fread` 不会调用很多次，所以 `fread_unlocked` 看起来没有明显效率提升。

以上大概是大部分题解都有讲到的常识。  

> 如果要具体一点讲的话，先讲一下线程锁。  
在多线程环境中，多个线程可能同时访问共享资源（举例如文件、内存、全局变量），线程锁在这个时候用于强制互斥访问：某个线程访问资源前先上锁，其他线程就阻塞在一边排队等待；操作完成后释放锁，允许其他线程访问。这可以防止 Data Race 导致程序崩溃或数据错误。  
`getchar` 本身是线程安全的，它每调用一次就要先上锁，再读一个字符，再开锁，来保证安全。但是如果只有一个线程访问标准输入（事实上 OI 中整个程序只有一个线程），这个频繁开关锁的过程就没有必要了。  
所以使用不带线程锁直接读入的 `getchar_unlocked` 可以加快读入速度。

然后有小朋友读了题解，实现了一份代码，发现这个函数在 Windows 机子上没提供。  
所以为什么不提一下我们的 `_getchar_nolock` 作为 Windows 环境中的替代呢？  
如果觉得提交到不同的平台还得改代码很麻烦，可以学一下使用 `ifdef` 之类预处理器，比如可以用下面这段代码来实现，在常见的 Linux 和 Windows 环境中都不会 CE。  
```cpp
#ifdef __unix__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
```

### C++ 风格字符串设备
当然，如果你和我一样有志于成为现代 C++ 使用者（从而让自己看起来很厉害），使用 C 风格直接输入 `fread` 就会让自己的代码看起来很掉价。  
所以我们使用 `basic_stringbuf`，更适应 C++ 宝宝体质。  
可以在[此处](https://en.cppreference.com/w/cpp/io.html)阅读文档，如果你有系统学习的兴趣的话。

如果要速成的话，按以下几步来应该就够了。  
1. 使用 `std::cin` 的 `rdbuf` 方法获得一个 `std::streambuf` 指针，`std::cin` 也使用它来读入。
2. 可以使用 `std::streambuf` 的 `sgetn` 方法实现大量无中间缓冲的读入，传入的第一个参数是一个字符指针，读到的东西从它的位置开始依次存储；第二个参数是一个（应该是无符号的）整数，指示至多读取几个字符。这个函数会返回事实上读到了几个字符，因为超出了的地方填入 EOF。  
    有朋友可能会问，这不就是 `fread` 吗？那么我要严肃纠正你，这是更适合 C++ 宝宝体质的 `fread`。
3. 拿一个缓冲区（比如说很大的 `char` 数组）来存储一次读进来的一大堆东西，并拿出两个指针来表示现在读到了哪个位置和缓冲区事实上的结尾位置。然后写一个函数来实现读入一堆字符到缓冲区的功能。
4. 实现一个取出缓冲区里接下来一个字符的函数，并在达到结尾时重新调用 3 中实现的函数。  
5. 添加大量炫酷的 C++ 风格语法，比如 `std::basic_string<char>`（就是 `std::string`）和 `const_cast`（用于让你的 C 风格强制类型转换原始人同学大开眼界）之类的。
6. 关闭同步流，封装一下，打包好端出来给大家品尝。
7. （非必须）很自信地写一篇题解教大家使用你的新发明。

```cpp
class FastStdinReader {
public:
	explicit FastStdinReader(size_t buffer_size = 1 << 20) {
		buffer_.resize(buffer_size);
		current_ = buffer_.data();
		end_ = buffer_.data();
		std::ios::sync_with_stdio(false);
		sbuf_ = std::cin.rdbuf();
		refill_buffer_();
	}
	
	int get() {
		if (current_ == end_ && !refill_buffer_()) {
			return EOF;
		}
		return static_cast<unsigned char>(*current_++);
	}
	
    int operator()() { return get(); }
	
private:
	bool refill_buffer_() {
		auto count = sbuf_->sgetn(const_cast<char*>(buffer_.data()), buffer_.size());
		current_ = buffer_.data();
		end_ = current_ + count;
		return count > 0;
	}
	
	std::streambuf* sbuf_;
	std::basic_string<char> buffer_;
	const char* current_;
	const char* end_;
}gc;
```

如果以上步骤太麻烦，你可以请 deepseek 帮你写，比如这个代码可能就是 deepseek 写的，不过我不能承认这一点。

### 内存映射  
`mmap` 可以很方便地实现内存映射，然而 OI 语境下只能在 Linux 环境中使用。   
原理大概就是将文件直接映射到内存地址空间，实现零拷贝读入来加快速度。  
可以在[此处](https://man7.org/linux/man-pages/man2/mmap.2.html)阅读文档。  
然后以下是速成指南。
1. 引用必要的头文件。  
2. 用 `fstat(0, &st)` 获取标准输入的文件大小（文件描述符 `0` 表示标准输入），高雅一点叫做获取元数据。
3. （理论上需要先检查文件有效性）调用 `mmap` 将文件映射到内存，第一个参数直接填 `nullptr`（这个参数表示建立映射区的首地址，由 Linux 内核指定，使用时直接传递 `nullptr` 即可），第二个参数填获取到的文件的大小，第三个参数填 `PROT_READ` 表示只读权限，第四个参数填 `MAP_PRIVATE` 创建私有拷贝（写操作不影响原文件），然后填两个 `0` 表示从文件头开始映射。
4. 和其他读入方式类似，用两个指针标记当前读取位置和文件末尾，实现一个函数每次返回当前字符并移动指针，指针越界时返回 `EOF`。
5. 析构函数中调用 `munmap` 解除映射，防止内存泄漏。
6. 用炫酷语法包装起来。
7. 实测可能没有想象中那么快。

Windows 系统下有 `CreateFileMapping` 好像能实现类似功能，不过我不会用。  
如果实在学不会的话，请 D 指导帮忙写一份总是没问题的。  

```cpp
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <fcntl.h>
#include <cctype>

class MMapReader {
public:
    MMapReader() {
        struct stat st;
        if (fstat(0, &st) == -1) {
            is_mapped_ = false;
            return;
        }
        size_ = st.st_size;
        if (size_ == 0) {
            is_mapped_ = false;
            return;
        }
        addr_ = static_cast<char*>(
            mmap(nullptr, size_, PROT_READ, MAP_PRIVATE, 0, 0)
        );
        if (addr_ == MAP_FAILED) {
            is_mapped_ = false;
            return;
        }
        is_mapped_ = true;
        current_ = addr_;
        end_ = addr_ + size_;
    }

    ~MMapReader() {
        if (is_mapped_) {
            munmap(addr_, size_);
        }
    }

    int get() {
        if (current_ < end_) {
            return static_cast<unsigned char>(*current_++);
        }
        return EOF;
    }

    int operator()() { return get(); }

private:
    char* addr_ = nullptr;
    char* current_ = nullptr;
    char* end_ = nullptr;
    size_t size_ = 0;
    bool is_mapped_ = false;
} gc;
```

---

## 作者：Public_leda_team (赞：11)

首先，我们使用 `cin` 和 `scanf` 肯定会超时，那么我们可以使用快读函数。

快读函数的原理是：每次使用 `getchar` 函数读入一个字符，当读到符号时，我们可以转变符号，否则，当我们遇到数字时，将这个数字加在答案末尾即可。

```cpp
inline long long read() {
  long long x = 0;
  int sgn = 1;
  char ch = getchar();
  while (!isdigit(ch)) {
    if (ch == '-') sgn *= -1;
    ch = getchar();
  }
  while (isdigit(ch)) {
    x = (x << 3) + (x << 1) + (ch ^ 48);
    ch = getchar();
  }
  return sgn * x;
}
```

由于 `getchar` 函数非常高效，所以我们可以快速读入整数。但是，我们还是无法通过此题，那么我们考虑优化 `getchar` 函数。

众所周知，`fread` 函数也是一种特别高效的函数，那么我们定义 `getchar` 为：

```cpp
static char buf[100000], * pa(buf), * pb(buf);
#define gc pa == pb && (pb = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pb) ? EOF : *pa++
```

这样我们就可以通过此题了！

顺便给出 $4$ 种不同读入方式所对应的用时表：



|读入方式/用时（ms）|#1|#2|#3|#4|
|:-:|:-:|:-:|:-:|:-:|
|cin|21|179|2000|超时|
|scanf|11|83|798|超时|
|快读|6|29|254|超时|
|快读优化|5|17|137|1330|

感谢大家的观看！

---

## 作者：LionBlaze (赞：10)

~~制约接触作战！~~

update on 2025/2/25：应[洛谷模板题题解规范](https://www.luogu.com.cn/discuss/1061716)，更改了排版。

# 算法介绍

鉴于某些时间复杂度严格的题目需要较大输入量，而输入很多数字（比如对于 C++，直接使用 `scanf` 或 `cin`）很可能导致 TLE，这个时候就需要使用快速读入算法。

而快速读入有很多种版本，最慢的版本大概就是直接使用 `getchar()` 了。但是其实不同的版本，思路都基本一样：秦九韶算法，或者使用乘法分配律的位值原理。

简要概括一下：思路是 $\overline{a_1a_2a_3\dots a_n}=(((\dots((a_1 \times 10 + a_2) \times 10 +a_3) \times 10 + a_4 \dots)\times 10 + a_{n-2})\times 10 + a_{n-1})\times 10 +a_n$。

那么我们就可以每读入一个字符就把之前的结果 $\times 10$，然后加上这个字符对应的值。

而时间复杂度达到了理论下界 $\mathcal O(\log V)$，不过达到这个理论下界极其容易。快速读入是用来卡常的。

# 正确性证明

> 如果算法本身正确性和复杂度比较显然，这一部分可以略过。 ——[洛谷模板题题解规范](https://www.luogu.com.cn/discuss/1061716)

显然。略。

# 代码实现

主函数：

```cpp
int main()
{
    int n = fastread();
    unsigned long long sum = 0;
    while(n--)
    {
        sum += fastread();
    }
    printf("%lld\n", (long long)sum);
    return 0;
}
```

## 慢

使用 `getchar` 实现。

```cpp
inline unsigned long long fastread()
{
    char ch;
    while((ch = getchar()) == ' ' || ch == '\n'); // 跳过空白字符中的两个。注意，在某些不负责任的数据师造的数据中，还可能有 \r 符号，也需要判断。
    unsigned long long flag = (ch != '-' ? 1 : ((ch = getchar()), -1)); // 是否是负数。
    unsigned long long a = 0;
    do
    {
        a = (a << 3) + (a << 1) + ch - '0'; // a << 3 代表 a * 2³，<<1 同理，相加即为乘十。而 ch - '0' 即为字符转数字。
        ch = getchar();
    } while(ch >= '0' && ch <= '9');
    return a * flag;
}
```

## 快

拿出珍藏（指掉了十几页）的《程序员的自我修养》，然后看到，在 Linux 下，`getchar` 使用了 `fread`，然后 `fread` 使用了 `read`，然后 `read` 触发了中断，最终调用到内核中的 `sys_read`（当然没这么简单，这是简化过的，不过大概就是这样）。

当然，我们不能去直接调用内核中的 `sys_read` 函数，所以我们可以直接调用到的最底层的函数是 `read` 函数，位于 `<unistd.h>` 中。

`read` 函数的用法：
```cpp
int read(int handle, char *buffer, int size);
```
`handle` 表示输入句柄，在 Linux 下的文件句柄都表示为一个 `int` 值，而标准输入的文件句柄为 $0$，标准输出的文件句柄为 $1$，标准错误的文件句柄为 $2$。

`buffer` 表示输入缓冲，其实就是要把输入存放到哪里，可以是一个 `char` 数组也可以是一个 `char` 指针。

`size` 表示最大输入长度，为什么说“最大”呢，因为有时候文件剩余部分并没有这么长，比如文件剩余还没有读入的内容是 `abc`，此时设置 `size = 5`，就读不满。

而它的返回值就是实际读入了多少个字节，不包括最后的 `EOF`。

比如：
```cpp
char ch;
char buffer[10];
read(0, &ch, 1);
int rlen = read(0, buffer, 5);
```
意思是先从标准输入中读取一个字节存入到 `ch` 中，再读入 $5$ 个字节存入到 `buffer` 中，并且把实际读入到 `buffer` 中的字符个数存入到 `rlen` 中。

如果标准输入中的内容是 `abcabcabc`，则 `ch` 的值就是 `'a'`，`buffer` 就是 `"bcabc"`（最后还有个 `'\0'`），`rlen` 就是 $5$。

如果标准输入中的内容是 `1uogu`，则 `ch` 的值就是 `'1'`，`buffer` 就是 `"uogu"`，`rlen` 就是 $4$。

于是，我们就可以通过 `read` 函数实现快读了！

代码：
```cpp
#include <cstdio>
#include <unistd.h>

using namespace std;

inline int fastread()
{
    char ch;
    do
    {
        read(0, &ch, 1);
    } while(ch == ' ' || ch == '\n');
    int flag = (ch != '-' ? 1 : (read(0, &ch, 1) * 0 + -1));
    int a = 0;
    do
    {
        a = a * 10 + ch - '0';
        read(0, &ch, 1);
    } while(ch >= '0' && ch <= '9');
    return a * flag;
}
```
然而，我们发现 TLE 了三个点，还不如 `getchar` 好呢。

这是为什么呢？

因为 `getchar`（和 `scanf` 等）使用了缓冲机制，毕竟读文件其实本身就是非常慢的，所以 `getchar` 就提前把文件中的前几个字节存入到内存中，具体存入多少个字节呢？不能太小，不然就跟没有一样。不能太大，否则就需要去访问内存，不能直接访问 `cache`，访问内存同样很慢。而存放这些字符的数组就叫缓冲区，也叫缓存。

比如文件中是 `LionBlaze is a jvruo`，`getchar` 的缓冲长度为 `10`（实际上太小了，这里仅仅是举例子），那么第一次 `getchar` 时，`LionBlaze `（注意后面有一个空格）就被存入到了缓冲区中。而如果后面我们又调用了 $9$ 次 `getchar`，就不会去直接访问文件，因为前 $10$ 个字符就在内存（大概率是 cache）中，可以直接要。如果后面又调用了一次 `getchar`，也就是读取文件的第 $11$ 个字符，但是缓存中没有，于是 `getchar` 就会再读取 $10$ 个字符到缓存中，缓存就变成了 `is a jvruo`，此后如果继续调用 `getchar` 也不用访问文件了。

但是 `read` 函数并没有使用缓冲机制，导致每次都需要访问文件。

那怎么办？难不成继续用 `getchar`？不需要。

可以使用一个好东西，叫做 `getchar_unlocked`，~~只在 Linux 下能用~~在 Windows 下也能用，叫做 `_getchar_nolock`，显然都是非标准的。因为 `getchar` 还加入了锁，为了防止多线程竞争。而 `getchar_unlocked` 就没有加锁，会快一点，但是需要保证不会有多个线程同时读取。这种方法可以 AC，只需要把原本使用 `getchar` 的快读中的所有 `getchar` 换成 `getchar_unlocked` 即可。

但是，如果没有缓冲机制，我们为什么不自己写一个呢？

```cpp
char buffer[32769]; // 缓冲区
unsigned li = 0; // 缓冲区指针，记录到了哪个位置

inline char my_getchar()
{
    if(buffer[li] == '\0') // 缓冲区已满，刷新缓冲区
    {
        buffer[read(0, buffer, 32768)] = '\0'; // 读文件，文件句柄为 0（标准读入），缓冲区为 buffer，大小为 32768（通常是 cache 大小）。
        li = 0; // 更新缓冲区指针
    }
    return buffer[li++]; // 返回缓冲区的下一个字符，并且增加指针
}
```
同理，我们只需要把原本使用 `getchar` 的快读前面加上上面的代码，再把所有的 `getchar` 替换成我们的 `my_getchar` 即可，比[使用 `getchar_unlocked` 的代码](https://www.luogu.com.cn/record/190239015)快 $440$ 毫秒！

另外此题 [O2](https://www.luogu.com.cn/record/190236461) 和[没有 O2](https://www.luogu.com.cn/record/190236506) 一模一样，O2 慢了 $3$ 毫秒……大概是评测机波动。

## 更快

update on 2025/1/15：

> ![](https://cdn.luogu.com.cn/upload/image_hosting/hu0gfpdv.png) / [P6013](https://www.luogu.com.cn/problem/P6103)。

众所周知 `unsigned` 大部分情况是比 `int` 快的。这是为什么呢？

1. ~~它溢出不会出现 UB——这利于编译器优化。~~ 没有 UB 反而编译器优化，比如 `int` 就可以把类似 `x+1>x` 优化为 `true`，而 `unsigned` 不可以。
2. 它不用考虑符号位，有些运算比较简单。如 `int` 不可以把 `x * 2` 优化为 `x << 1`，而 `unsigned` 可以。

并且它还有一个特性，就是我们容易从同余角度证明，在模任何数意义下，都有 $a - b = a + (-b)$。而 `unsigned` 本质上就是在模 $2^{32}$ 意义下的正整数。

于是我们就可以利用这一点来优化我们的快读，就是把 `int` 全部转化为 `unsigned`。

这就有了一个问题：虽然 `unsigned + (-unsigned) == unsigned - unsigned`，但是这不意味着 `long long + (-unsigned) == long long - unsigned`，然而和需要开 `long long`。

一个显而易见的解决方法是，全部都用 `unsigned long long`，但是这真的不会让常数增大吗？

由于评测机是先进的 $64$ 位系统，所以常数相同。最终可以优化数十毫秒。

# 结语

快速读入是一种没有什么用的东西。当你需要快速读入时，先想想你的算法是不是最高效的吧。

另外有一个巨佬的光速读入，有时间我去搞清楚来讲讲。

鸣谢名单（不分先后）：

- @[normalpcer](luogu://user/745184) 指出对于自然溢出为什么快的分析错误，已修改。
- @[W1ngD1nGa5ter](luogu://user/521554) 提供关于“自然溢出啥事没有”的出处，已修改。

---

## 作者：ダ月 (赞：7)

呃呃的模版。

接下来按作者对读入速度的认知来讲述模版。

---

1.不关流的 `std::cin`。

使用方式：
- 假如要读入变量 `x`，直接使用 `std::cin>>x` 对 `x`。注意这是 `>>`，而不是 `<<`。

---

2.`scanf` 或者关闭同步流。

显然 1. 的速度太慢了。这里讲述两个较 1 更快的读入方式。

`scanf`：这里做简单解释，假设要读入一个整型（`int`） `x`，我们可以用 `scanf("%d",&x)`；如果要先读入一个整形 `x`，再读入一个长整形（`long long`）变量 `y`，可以调用 `scanf("%d%lld",&x,&y)`。注意，读入单个变量的时候不要忘记 `&`。具体原理可以上网搜索，不做赘述。

关闭同步流：我们只需要在代码主函数的最开头前加入：

```
std::ios::sync_with_stdio(false);
std::cin.tie(0);
std::cout.tie(0);
```

具体地，`std::ios::sync_with_stdio(false)` 意思是解除 `std::cin/cout` 与 `scanf/printf` 两种 IO 方式的同步。而 `.tie(0)` 表示解除 `std::cin` 和 `std::cout` 之间的绑定，即在 IO 的时候不会强制刷新缓冲区。具体地效果，假如你还用 dev-c++ 的小黑框，你会发现在未使用该函数时，你输出一条，小黑框会显示一条。而在使用该指令后，只会在结束时一起输出。

因为该代码解除两种 IO 方式，你不能在代码里混用 `scanf/printf` 和 关流 `std::cin/cout`。

---

3. 基础快读和快输。

这是一种相较于 2 更快的读入方式，同时在会该方法时，应当掌握字符串的基础。

首先我们拿到一个数字的字符串时，我们需要想办法转成一个整形或者长整形。

我们不妨令字符串为 $s=s_1s_2s_3\dots s_n$，显然这个数字为 $\sum_{i=1}^{n}s_i\times10^{n-i}$，这个可以用**秦九韶算法**计算。

注意，在算这个 $\sum$ 的时候，应当让原字符 $s_i$ 减去 '0' 后得到的数字。当然人类找到了一个神秘的数字 $48$，只要让字符 $s_i$ 异或上 $48$ 就成对应的数字。

如果是负数，就特判一下即可。

这个时候我们读入每一个字符时，我们需要用更快的读入方式了，比如 `getchar()`，而不是 `std::cin/scanf` 了。注意，`getchar()` 会读入空格和换行符，我们要尽可能过滤掉这两个东西。

具体地实现如下：

```
int read(){
	int x=0,y=0;char c=0;
	while(!isdigit(c))y|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
  /*
  isdigit(c) 查询字符 c 是否为数字。
  (x<<3)+(x<<1) 其实就是 x*10
  y|=c=='-' 表示询问 c 是否为 '-'
  */
	return y?-x:x;
}
void solve(){
	//don't forget to open long long
	int n=read();ll ans=0;
	while(n--){
		int x=read();
		ans+=x;
	}
	std::cout<<ans<<'\n';
}
```

至于 `long long` 或是 `double`，可以自己尝试实现。

输出采用递归，将数字串拆成字符串用 `putchar` 输出，不过不建议写，效率和 2 输出差不多。

---

4.`fread` 和 `fwrite`

我们考虑“硬件”上的优化，就是“优化” `putchar`。

我们先介绍 `fread`，具体地格式为 `fread(char *c,size_t size,size_t nmemb,stdin)`，`char *c` 表示要将读入的串所要拷贝到的字符串，`size` 表示单元素字节（`char` 是 $1$），`nmemb` 表示所要获取的所有字节，返回值为有效获取的字符数。

假如我们要获取输入串为 `abcde`，然后加到 `ibuf` 字符串内，我们只需要调用 `fread(ibuf,1,N,stdin)` 即可。

接下来我们考虑用 `fread` 来构造出一个类似 `putchar()` 功能的函数，不妨叫做 `getch()`。

我们定义一个字符串 `ibuf`，定义两个指针 `it` 和 `is`，初始指向 `ibuf` 的头指针。

由于在定义 `ibuf` 的时候，内存是连续的。假如 `is` 和 `it` 指向的内存一致，这个时候我们要用 `fread` 读入了。具体地，显然 `is` 回归头指针，`it` 变成 `is` 加上 `fread` 的返回值。然后要获取元素的时候，就直接类似队列获取头元素即可。如果即时读入也还是 `is` 和 `it` 指向内存相同，那么说明整个文件读完了，返回 `EOF`。

`getch()` 代码实现如下：

```
const int BUFSIZE=1<<20;
char ibuf[BUFSIZE],*is=ibuf,*it=ibuf;
inline char getch(){if(is==it)it=(is=ibuf)+fread(ibuf,1,BUFSIZE,stdin);return is==it?EOF:*is++;}
```

剩下的和 3 差不多了。

接下来考虑用 `fwrite` 来实现输出。先介绍 `frwite`，函数构成要素和 `fread` 相同。

我们先定义一个字符数组 `tmp`，表示临时存放的字符串，我们在输出的时候，我们直接塞到这个 `tmp` 里面。当程序结束的时候或者字符数组满了，就直接用 `fwrite` 输出。其实这个相当于清空缓存区的操作。

当数字拆成字符串的时候，可以用栈来模拟递归，可能会更快些。

可以通过代码靠以下代码实现输出：

```
char tmp[BUFSIZE];int cnt=0;
void flush(){fwrite(tmp,1,cnt,stdout);cnt=0;}
void putch(char c){tmp[cnt++]=c;if(cnt==BUFSIZE)flush();}
```

---

5.`getchar_unlocked()`

这个东西似乎只能在 Linux 系统下使用。将 `3` 中的 `getchar()` 替换成这个函数，效率和 4 差不多。

--- 

接下来提供本题部分封装代码：

```

namespace IO{
	const int BUFSIZE=1<<20;
	char ibuf[BUFSIZE],*is=ibuf,*it=ibuf;
	char tmp[BUFSIZE];int cnt=0;
	inline char getch(){if(is==it)it=(is=ibuf)+fread(ibuf,1,BUFSIZE,stdin);return is==it?EOF:*is++;}
	int readInt(){int x=0,y=0;char c=0;while(!isdigit(c))y|=c=='-',c=getch();while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getch();return !y?x:-x;}
	
	void flush(){fwrite(tmp,1,cnt,stdout);cnt=0;}
	void putch(char c){tmp[cnt++]=c;if(cnt==BUFSIZE)flush();}
	void putint(int x){char Q[10];int tp=0;if(x<0)putch('-'),x=-x;if(x==0)putch('0');while(x)Q[tp++]=(x%10+'0'),x/=10;while(tp--)putch(Q[tp]);}
	
	struct Basic{
		Basic &operator>>(int &A){A=IO::readInt();return (*this);}

		Basic &operator<<(const int &A){putint(A);return (*this);}

		void Flush(){flush();}
	}cin,cout;
}

```

仅支持读入输出类型为 `int`。

就是模仿 `std::cin` 和 `std::cout` 的封装，使用方式就是将 `std` 换成 `IO`。如读入一个变量 `x`，写作 `IO::cin>>x`。如果你用黑框调试，请在末尾输入 `ctrl+z`。

同时，请在代码末尾别忘记写上 `IO::cout.Flush()` 即可。

---

## 作者：hellolin (赞：6)

~~制约解除作战！~~

开一个足够大的 `char` 型数组作为 buffer，我这里是 $2^{19}=524288$。缓冲区内字符可能不满，考虑用头尾指针指示当前范围，初始时它们均指向缓冲区开头。

如果头尾指针相遇，再从文件里缓冲一些字符，重新计算头尾指针位置（头指针重新指向开头）。如果缓冲后头尾指针仍指向同一位置，说明读入已经结束，返回 `EOF`。

否则，说明缓冲区内仍存在字符，我们只需返回头指针指向的字符，然后向后移动它即可。

文件操作可以使用 C 的 `fread` 或 C++ 的 `std::streambuf`，`fread` 已实测足以通过此题。

``` cpp
static constexpr int Buffer = 1 << 19;
char ib[Buffer], *is, *it;
FILE *inf = stdin;

char gc() {
  return is == it && ((it = (is = ib) + fread(ib, 1, Buffer, inf)), is == it) ? EOF : *is++;
} // fread 返回成功读取的对象数量，可以用它直接计算尾指针位置
// 注意区分 fread 中第二个和第三个参数的区别
template <class T> void read(T &x) {
  x = 0;
  bool f = 0;
  char c = gc();
  while (!isdigit(c)) f ^= c == '-', c = gc();
  while (isdigit(c)) x = x * 10 + c - 48, c = gc();
  x = f ? -x : x;
}
```

---

## 作者：zhangbo1000 (赞：4)

一般的快读移步其他题解，这里说下快读的优化。

首先，**就做题而言**，一般不会出现输入已经结束仍然尝试输入的情况，因此对读入字符的优化中的判断读完并返回 `EOF` 的判断是多余的。

其次，赋值语句是有返回值的，所以以下代码：

```cpp
char c=getchar();
while(c<'0'||c>'9')c=getchar();
```

实际上等价于：

```cpp
char c;
while((c=getchar())<'0'||c>'9');
```

（第二份代码似乎有点 UB，接下来的优化会解决这个问题。）

其次，如果输入内容只包括数字（和空白字符，如空格，`\n`，`\r` 等），那么实际上我们可以去掉判断数字时对上界的检查：

```cpp
char c;
while((c=getchar())<'0');
```

这是基于以上原理的不能读负数的快读。

```
inline void read(int &x){
	char c;
	while((c=getchar())<'0');
	x=c^'0';
	while((c=getchar())>='0')x=x*10+(c^'0');
}
```

这是 `getchar`：

```cpp
char gtc(){
	static char tmp[100000],*p=0,*top=0;
	if(p==top)top=(p=tmp)+fread(tmp,1,100000,stdin);
	return *p++;
}
```

AC 代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
char tmp[100000],*p(0),*top(0);
#define gtc() (p==top && (top=(p=tmp)+fread(tmp,1,100000,stdin)),*p++)
int read(){
    int x;
	char c;
	bool f=0;
	while((c=gtc())<'0')if(c=='-'){f=1;}
	x=c^'0';
	while((c=gtc())>='0')x=x*10+(c^'0');
	return f?(~x+1):x;
}
int main(){
	int n,x,ans=0;
	n=read();
	while(n--){
		ans+=read();
	}
	cout<<ans;
	return 0;
}
```

最慢的点跑了 $1.33s$ 速度勉强还是可以的（叠甲.jpg）。

---

## 作者：Dazlin7 (赞：3)

### 描述

读入 $n$ 个数，求和并输出。

### 关键

考虑到输入数据规模可能非常大，我们需要一种高效的方法来处理输入和计算总和，快读通常可以帮助我们解决这种问题。
但是这道题最大读入量达到了 $10^8$，一般的快读已经满足不了要求了，这边介绍一种升级版快读，即 fread，能将需要的文件部分读入内存缓冲区，加快读入速度。

### 代码

下面是对 fread 的详细说明，缓冲区发挥了巨大作用。

```cpp
#include<bits/stdc++.h>
using namespace std;
// 定义命名空间 IO，用于封装快速读写操作
namespace IO {
    const long long MAXR = 100000050; // 定义缓冲区的最大大小
    char _READ_[MAXR], _PRint_[MAXR]; // 读写缓冲区
    long long _READ_POS_, _PRint_POS_, _READ_LEN_; // 读缓冲区的位置和长度标记

    // 读取单个字符的函数
    inline char readc() {
        #ifndef ONLINE_JUDGE
            return getchar(); // 本地测试时直接使用 getchar
        #endif
        if (!_READ_POS_) { // 如果当前位置为 0
            if (feof(stdin)) return -1; // 到达文件末尾
            _READ_LEN_ = fread(_READ_, 1, MAXR, stdin); // 从标准输入读取数据到缓冲区
        }
        char c = _READ_[_READ_POS_++]; // 获取当前字符，并移动位置标记
        if (_READ_POS_ == _READ_LEN_) _READ_POS_ = 0; // 如果到达缓冲区末尾，重置位置标记
        return c; // 返回读取的字符
    }
    // 模板函数，用于读取整型数据
    template<typename T> inline long long read(T &x) {
        x = 0; register long long flag = 1, c; // 初始化变量 x 和标志位 flag
        // 跳过所有非数字和负号字符
        while (((c = readc()) < '0' || c > '9') && c != '-')
            if (c < 0) return -1; // 如取到文件末尾
        if (c == '-') flag = -1; else x = c - '0'; // 如果是负号，设置标志位；否则转换为数字
        // 读取剩余的数字字符
        while ((c = readc()) >= '0' && c <= '9') x = x * 10 - '0' + c;
        x *= flag; // 正负数处理
        return 0; // 成功读取
    }
}
long long n, a, s;
int main() {
    IO::read(n); 
    while(n--) { 
        IO::read(a); 
        s += a; // 将 a 累加到 s 中
    }
    cout << s; 
}
```

---

## 作者：linjinkun (赞：2)

这题真的好恶心。

在日常生活中，```cin``` 几乎可以满足我们对代码读入的需要，而有些题偏偏又是那么毒瘤，必须要用 ```scanf``` 才能过，但是某些出题人又是那么的“善良”，```scanf``` 都过不了，这个时候就要用到快读了。

众所周知，```getchar``` 是非常快的，快读就是用了这个原理才能比 ```scanf``` 快的，快读的中心思想就是把整数分成一个个位来读入，就可以用 ```getchar``` 来优化，接下来给出快读的代码：
```cpp
int x=0,f=1;//x表示算出来的数（读入的数），f表示正负
    char ch=getchar();//先提取一个字符
    while(ch<'0'||ch>'9')//由于读入之前可能会有负号，或空格，所以先读入这些
    {
        if(ch=='-')//如果这一位是负号
            f=-1;//负数
        ch=getchar();//正常提取
    }
    while(ch>='0' && ch<='9')//当提取的字符是数字，开始计算
        x=x*10+ch-'0',ch=getchar();//计算的公式，x = x*10+ch-'0'，一位一位的计算，之后正常读入
    return x*f;//x*f就是这个数
```
我已经加入了许多注释，应该可以理解，就不用我解释了。

但是，我们交了之后还是只能获得 ```75pts``` 的好成绩。那咋办呢？这个时候只能引入一个毒瘤的东西了：```getchar_unlocked()```。这里不做介绍，想看介绍的戳这：[https://www.lsbin.com/4733.html](https://www.lsbin.com/4733.html)。这里只说它比 ```getchar``` 快。

那么用了这个东西之后就能 ```AC``` 了。

但是还是不够，众所周知调用函数是比直接循环慢的，那么我们就舍弃函数，直接把快读写在主函数里就行了。

两种方式代码：

第一种：
```cpp
#include<bits/stdc++.h>
using namespace std; 
int read()
{
    int x=0,f=1;
    char ch=getchar_unlocked();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar_unlocked();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar_unlocked();
    return x*f;
}
signed main()
{
	int n;
	n = read();
	long long sum = 0;
	for(int i = 1;i<=n;i++)
	{
		int x;
		x = read();
		sum+=x;
	}
	printf("%lld",sum);
	return 0;
}
```
用时：```1.84s```。

第二种（优化后）：
```cpp
#include<bits/stdc++.h>
using namespace std; 
signed main()
{
	int n;
	int x=0,f=1;
    char ch=getchar_unlocked();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar_unlocked();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar_unlocked();
    n = x;//n不可能为负数，所以不用写成x*f，其实这里的f是多余的，但是留着也不影响
	long long sum = 0;
	for(int i = 1;i<=n;i++)
	{
		x=0,f=1;
	    ch=getchar_unlocked();
	    while(ch<'0'||ch>'9')
	    {
	        if(ch=='-')
	            f=-1;
	        ch=getchar_unlocked();
	    }
	    while(ch>='0' && ch<='9')
	        x=x*10+ch-'0',ch=getchar_unlocked();
		sum+=f*x;
	}
	printf("%lld",sum);
	return 0;
}
```
用时：```1.75s```。

还是快了很多的。

---

## 作者：vorDeal (赞：2)

这是 Ynoi 题吧，真卡常啊，不愧是 noip。

当你拿出祖传的快读板子，提交，喜提 75 pts。

```cpp
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    return x * f;
}
```

由于使用 iostream 库，为实现泛型编程，cin 的效率低。scanf 稍微快了一些，但也有几层的封装，跑不动。getchar 输入单字符，快了许多。

However，快了一半，却还是 75 pts。掘地三尺，不见答案。

于是你一行一行地看下来，发现罪魁祸首只能是 getchar。

接下来，我们对 getchar 进行优化。

### 解法一

众所周知，文件读写比 getchar 更快。

getchar 是每次读一个字符，fread 每次可以读一大段。下面是 fread 函数的语法。

`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)`

- ptr：这是指向内存块的指针。
- size：每个元素的大小，以字节为单位。
- nmemb：元素个数，每个元素的大小为 size 字节。
- stream：指定输入流。

我们可以建立一块内存区 buf，以字节为单位，每次从标准输入流 stdin 读入大量的元素，这样就减小了常数。

代码如下。

```cpp
inline char gc()
{
    static char buf[1048576], *p1, *p2;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1048576, stdin), p1 == p2) ? EOF : *p1++;
}
```

注意到代码中的两个指针，p1、p2。它们起什么用呢？p1 指向当前 gc 函数所需要读取的字符，p2 则指向已从输入流中读入的字符的末尾。

好比食堂里，先打来一碗饭，再一口口送进嘴里吃，比吃一口再去饭桶边打一口，自然是要快多了。

**AC Code：**
```cpp
#include <bits/stdc++.h>
using namespace std;

inline char gc()
{
    static char buf[1048576], *p1, *p2;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1048576, stdin), p1 == p2) ? EOF : *p1++;
}
inline long long read()
{
    long long x = 0, f = 1;
    char c = gc();
    while (c < '0' || c > '9')
        f = (c == '-' ? -1 : 1), c = gc();
    while (c >= '0' && c <= '9')
        x = (x << 1LL) + (x << 3LL) + (c ^ 48LL), c = gc();
    return x * f;
}

void write(long long x)
{
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    char a = (x % 10 + (1 << 5) + (1 << 4));
    if (a >= '0' && a <= '9')
        putchar(a);
    return;
}

long long n, s;

int main()
{
    n = read();
    while (n--)
        s += read();
    write(s);
    return 0;
}
```

### 解法二

当你看到 CCF 的比赛规则，你会发现其中有一条：严禁调用线程相关函数。

这说明，C++ 语言本身是支持多线程的，但由于我们无法使用，所以我们可以忽视线程不同步的风险，毕竟线程同步会降低程序运行效率。

有一种函数 `getchar_unlocked()`，在用法上与 `getchar()` 一致，在 Linux 下可用。

经测试，效率较解法一稍低。

代码就不放了，自行替换即可。

---

## 作者：ivyjiao (赞：0)

如题面所述，本题读入量非常的大。

如标题所述，本题需要用到快速读入。

常规且便捷的做法是关闭 `cin/cout` 同步流和改用 `scanf/printf`，在此不做叙述。

### 一般快读：

一般来说考场上用这个足够了。

接下来我们会逐行对该代码进行解析：

```
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48); 
		ch=getchar();
	}
	return x*f;
}
```

`ch=getchar()`：读入单个字符，读入字符是要比 `cin`、`scanf` 都要快的。

`while(ch<'0'||ch>'9')`：防止读入的数字之前出现空格等非数字字符干扰读入结果。

`if(ch=='-') f=-1`：处理负数的情况，有的题目不需要，建议在不会读入负数时删除此句，避免浪费时间。

`while(ch>='0'&&ch<='9')`：处理读入的数字部分。

`x=(x<<1)+(x<<3)+(ch^48)`：不会位运算的请去[这里](https://oi-wiki.org/math/bit/)，原代码等于：

```
x=(x<<1)+(x<<3)+(ch^48)
 =x*2+x*pow(2,3)+(int)ch-48
 =x*2+x*8+ch-'0'
 =x*10+ch-'0'
```

至于为什么不直接写 `x=x*10+ch-'0'`，是因为位运算要比一般运算要快，注意位运算的优先级很低，记得加括号。

`return x*f`：读入完毕。

然而，用这种方法过不了这道题。

### 高级快读：

fread 优化，不常用。

fread 是将读入的部分读入到内存缓冲区中，可以一次性读入很多字符，而这比逐个字符读入快得多，这就是 fread 优化的原理。

其实还有一种更不常用的 `mmap` 优化，在此不做介绍，详见[这里](https://oi-wiki.org/contest/io/)。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a,ans;
inline char get(){
    static char buf[1000010],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000010,stdin),p1==p2)?EOF:*p1++;
    //记得开足够大的buf！
}
inline int read(){
	int x=0,f=1;
	char ch=get();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=get();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48); 
		ch=get();
	}
	return x*f;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        a=read();
        ans+=a;
    }
    cout<<ans;
}
```

---

## 作者：__galaxy_1202__ (赞：0)

## **快读模版题**。  
快读是通过输入字符并进行字符转数字，再把每位数字拼为完整数字的读入方法，依靠着 `getchar()` 读入较快的特点。  
快读代码如下：
```cpp
long long read()
{
	long long s = 0, w = 1;//s 为最终拼出的数，w 用于特判是否为负数。
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') w = -1;//特判负数
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		s = s * 10 + c - '0';//字符转数字
		c = getchar();
	}
	return s * w;
}
```

但这道题不一般，如果你使用普通的 `getchar()` 进行快读，那么会喜提 $75$ 分，这说明普通快读过不了，需要优化，那么就有两种可行方案。

方案一： **把所有 `getchar()` 换成 `getchar_unlocked()` 即可**，这个函数是 `getchar()` 的变种，速度更快，**但只能在 Linux 上使用**。

方案二：**使用 fread 函数**，比方案一复杂，但更快，本篇题解不展开讲~~主要是讲不清楚~~，仅作为扩展科普。

## CODE:
**方案一**：

```cpp
#include <iostream>
using namespace std;
long long n, ans;
long long read()
{
	long long s = 0, w = 1;
	char c = getchar_unlocked();//修改地方
	while (c < '0' || c > '9')
	{
		if (c == '-') w = -1;
		c = getchar_unlocked();//第二处
	}
	while (c >= '0' && c <= '9')
	{
		s = s * 10 + c - '0';
		c = getchar_unlocked();//第三处
	}
	return s * w;
}
void write(long long n)
{
	if (n < 0) 
	{
		putchar('-');
		n = -n;
	}
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
	return;
}
int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        ans += read();
    write(ans);
    return 0;
}//最简单的方案
```

**方案二**（作为科普也放出来代码）：

```cpp
#include <iostream>
using namespace std;
long long n, ans;
char buf[1 << 20], *p1, *p2;
#define get() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2) ? EOF : *p1++)//特殊部分，使用了 fread 函数。
long long read()
{
	long long s = 0, w = 1;
	char c = get();
	while (c < '0' || c > '9')
	{
		if (c == '-') w = -1;
		c = get();
	}
	while (c >= '0' && c <= '9')
	{
		s = s * 10 + c - '0';
		c = get();
	}
	return s * w;
}
void write(long long n)
{
	if (n < 0) 
	{
		putchar('-');
		n = -n;
	}
	if (n >= 10) write(n / 10);
	putchar(n % 10 + '0');
	return;
}
int main()
{
    n = read();
    for (int i = 1; i <= n; i++) 
        ans += read();
    write(ans);
    return 0;
}//建议看别的题解学习一下qwq
```

---

## 作者：DFM_O (赞：0)

## [P10815 题目](https://www.luogu.com.cn/problem/P10815)

### 解题思路
在不关闭同步时，`cin` 和 `cout` 的读入输出效率是远低于 `scanf` 和 `printf` 的，即使关闭同步，在 `cin` 和 `cout` 的效率与 `scanf` 和 `printf` 的效率差不多的情况下，也无法通过本题 $10^8$ 的如此之大的读入量。

此时我们只好使用快读了，众所周知，`getchar()` 函数可以读入一个字符，效率极高，所以我们可以多次调用 `getchar()` 函数将整数看作字符串来读入。

需要注意的是，由于可能出现负数，我们需要先读入整数的符号位，再读入剩余的数字并用类似于字符串哈希的方法累加。

但是普通的 `getchar()` 也许无法通过，需要使用比 `getchar()` 更快的 `getchar_unlocked()` 就可以通过了。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
	int x=0,f=1;
	char ch=getchar_unlocked();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar_unlocked();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-48;
		ch=getchar_unlocked();
	}
	return x*f;
}
signed main()
{
	int n,s=0;
	n=read();
	for(int i=1;i<=n;i++)
	{
		int x=read();
		s+=x;
	}
	cout<<s;
	return 0;
}
```

---

## 作者：zyn_ (赞：0)

## 普通快读

```cpp
inline int read(){
	static char c;
	static int r,f;r=f=0;
	while((c<48||c>57)&&c!=45)c=getchar();
	if(c==45)f=1,c=getchar();
	while(c>47&&c<58)r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f?-r:r;
}
```

前两行定义变量：`c` 是读入的字符，`r` 是将返回的整数的绝对值，`f` 是负数标志，为 $1$ 代表输入了负数，为 $0$ 代表正数。

这三个变量定义时使用了 `static`，是为了让它们成为静态变量，这样就不用每次调用函数时给它们分配空间。不过这样的话，每次要记得初始化 `r=f=0`（`c` 不需要）。

第三行，读入空格、换行或其他与数字无关的字符。说明一下，字符 `-` 的 ASCII 码是 $45$，数字 $i$（$i=0,1,\dots,9$）对应字符的 ASCII 码是 $48+i$。

第四行，如果 `c` 是字符 `-`，意味着读入了一个负数，令 `f` 为 $1$ 并再读入一次 `c`。现在 `c` 一定是将要读入的数的首位了。

第五行，读入这个数。由于 `c` 为一个数字字符，在 $[48,57]$ 之间，容易知道 `(r<<1)+(r<<3)+(c^48)` 就是 `r*10+(c-48)`，此处用位运算加速。`c-48` 是字符实际代表的数字，`r*10+(c-48)` 就是在 `r` 的末尾添上一个 `c`。

第六行，返回结果。不要忘了负数标记 `f`。

## 更快的快读

发现普通快读由于大量 `getchar()` 的调用导致速度不够快。考虑一次读入更多字符。

如果一次读入所有数，由于 $n\le 10^8$，数的范围在 $[-n,n]$ 之间，因此一个数最多可以有 $10$ 个字节（`-100000000`），$n$ 个数、$n-1$ 个空格有大约 $1.1\times 10^9$ 字节，也就是 1 GB 左右，显然空间不够。

由于空间限制为 512 MB，我将一次读入的字符数设为了 $5.2\times 10^8$。具体地，这样实现 `getchar()`：

```cpp
#define N 520000000
char buf[N+9];int pos;
#define getchar() (pos==N?(fread(buf+1,1,N,stdin),buf[pos=1]):buf[++pos])
```

`fread(buf+1,1,N,stdin)`，代表从 `stdin` 读取数据，存到 `buf+1`（下标从 $1$ 开始）中，每个数据 $1$ 字节，有 $N$ 个数据。

将读入的字符存在 `buf` 中，维护指针 `pos` 代表当前读到的位置。如果指针已经遍历到了 `buf` 的最后一个字符，则重新读入 `buf`，并设指针为 $1$；否则指针加 $1$。这时指针所指的字符 `buf[pos]` 就是此次 `getchar()` 的结果。

**注意：初始化时执行 `pos=N`。**

这样，每读入 $N=5.2\times 10^8$ 个字符调用一次 `fread`，显然函数调用的开销减小了。这就能通过此题。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 520000000
int n;long long sum;
char buf[N+9];int pos;
#define getchar() (pos==N?(fread(buf+1,1,N,stdin),buf[pos=1]):buf[++pos])
inline int read(){
	static char c;
	static int r,f;r=f=0;
	while((c<48||c>57)&&c!=45)c=getchar();
	if(c==45)f=1,c=getchar();
	while(c>47&&c<58)r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f?-r:r;
}
int main(){
	pos=N;n=read();
	while(n--)sum+=read();
	printf("%lld\n",sum);
	return 0;
}
```

---

## 作者：Crab_Tang (赞：0)

本题主要考察快读。

一般的快读无法通过，需要优化`getchar`。

这边先给出代码再进行解释。

``` cpp
#include<iostream>
#include<cstdio>
using namespace std;
char gc() {
	static char buf[1048576],*p1,*p2;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1048576,stdin),p1==p2)?EOF:*p1++;
}
long long read(){
	long long s=0,w=1;char c=gc();
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=gc();}
	while(c>='0'&&c<='9'){s=s*10+c-'0';c=gc();}
	return s*w;
}
int main(){
	long long n,sum=0;
	n=read();
	for(int i=1;i<=n;i++){
		int a=read();
		sum+=a;
	}
	printf("%lld\n",sum);
	return 0;
}
```
# 1 普通快读
## 1.1 快读的原理

由于在一些题目中需要读入许多数据，喜欢卡常且使用了一些并不能过题复杂度的代码的大牛们就发明了快读这个东西。

普通快读读入的是`int`。很自然的，我们就可以一个`char`一个`char`读入，再累加到 $sum$ 里。

## 1.2 具体过程

由于读入的文件在数字间可能有一些不是数字的字符，所以需要先读掉并丢弃（如若读到负号需特判也就是最终乘上 $-1$）。然后对于每一个读入的数字字符，让原有的 $sum$ 乘以十，这样末尾再加上数字字符减去`'0'`（注意，由于`char`的存储是ASCII码，将其转换为 $0-10$ 的数需要减去`'0'`）。

这样就得到了普通快读的代码。

## 1.3 代码

_**注：不同快读有不同的写法，此处的 $w$ 是原理中提到的特判负号的变量，而 $s$ 即是 $sum$，`c`用来临时存储读到的字符**_

压行了。但相比其他一行的还是好看许多。

``` cpp
long long read(){
	long long s=0,w=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}
	return s*w;
}
```
这种快读读入速度大概是一秒能读入 $10^7$ 个整型，但是还是不够快，不足过此题。

# 2 加强版快读

## 2.1 加强版快读原理

其实加强版快读的原理就是通过各种方法优化`getchar`的速度。这边介绍`fread`函数。

`fread(void * a,size_t b,size_t c,FILE * d);`表示在 $d$ 输入流里读最多 $c$ 个对象至 $a$，每个对象读 $c$ 个字节。返回成功读取的对象个数。

## 2.2 加强版快读过程&代码
``` cpp
char gc() {
    static char buf[1048576],*p1,*p2;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1048576,stdin),p1==p2)?EOF:*p1++;
}
```

这样子写虽然有点晕，但是还是依个拆解是能看懂的。

这里综合运用了各种运算符。包括三目、逻辑与、等号、加号、逗号等。但是把他拆开还是不难，将下面的语言文字转换为伪代码即可。

首先定义了一个静态的数组`buf`和两个`char`指针`p1`和`p2`。`buf`用于存储 $1048576$ 个`char`。而`p1`和`p2`分别存储读入的一串字符当前使用到的字符的地址和`buf`中最后一个有用的字符的地址。

每次调用`gc()`，先判断`p1`和`p2`是否相等（也就是未使用过的字符是否还存在，存在不等，不存在相等）。

如果不相等，则逻辑与后的`(p2=(p1=buf)+fread(buf,1,1048576,stdin),p1==p2)`不执行，返回`p1`指向的字符，再自增`p1`（也就是`p1`指向下一个字符）。

如果相等，则使`p1`指向`buf`的开头，从`stdin`读入最多 $1048576$ 个字符至`buf`（每个对象含 $1$ 个字节），然后使`p2`指向最后一个`buf`中的有效字符的地址。

接着再计算`p1`和`p2`是否相等，如果相等说明读入数量为 $0$，也就是到文件末尾了，返回`EOF`。

______

然后其余部分也就是累加的部分大概都会写，就不说了。快写可以不用，也不说了（可能以后会补）
。看在作者打了长长的这么一~~坨~~篇文章，点个赞吧。

---


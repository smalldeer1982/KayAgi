# SDOI2024

## 题目背景

AzureHair 在 NOIP 2022 中被喵了个喵创死，于是患上了不治之症——T2 恐惧症，于是他在 NOIP 2023 中果断跳过了 T2 并杠 T3 两小时无果，遗憾离场，他的同学决定帮他治疗这种不治之症。

在他的同学给他治愈了 T2 恐惧症后，他自信的开始了他的 SDOI，遂分讨写了 $2$ 个小时没写出来，遗憾离场……

## 题目描述

AzureHair 的同学把 AzureHair 和 $n$ 只猫猫关在一个房间里，并且要求 AzureHair 每过一天就交出 $\frac{n}{2}$ 只猫猫，但是如果 $n$ 是奇数时，AzureHair 就会纠结于要交出 $\frac{n+1}{2}$ 只猫猫还是交出 $\frac{n-1}{2}$ 只猫猫。AzureHair 不想让自己纠结，所以请你计算出直到所有猫猫都被拿出房间时，AzureHair 的最小纠结次数是多少。

## 说明/提示

**【样例解释】**

对于 $13$ 只猫猫，只纠结 $3$ 次的过程如下：

选择交出 $7$ 只猫猫，剩余 $6$ 只；

不纠结，交出 $3$ 只猫猫，剩余 $3$ 只；

选择交出 $2$ 只猫猫，剩余 $1$ 只；

选择交出 $1$ 只猫猫，所有猫猫均被取走。

容易证明不存在少于 $3$ 次纠结的方案。

**【数据范围】**

对于 $10\%$ 的数据，保证 $1\le n \le 10$。

对于 $30\%$ 的数据，保证 $1\le n \le 10^{5}$。

对于 $100\%$ 的数据，保证 $1\le n \le 2^{60}$，$1 \le T \le 5\times 10^5$。

## 样例 #1

### 输入

```
2
13
7```

### 输出

```
3
2```

# 题解

## 作者：ChampionCyan (赞：24)

# SDOI2024 题解

## 前言

[update 表](https://www.luogu.com.cn/paste/ksuikxuq)。

赛时猜了一个结论，结果对了（\*\^▽^\*）。~~然后做完第二题就开始摆烂了。~~

我感觉写的比官方题解多了四五倍，难道~~是我太强了~~是我想复杂了？

## 做法

$n$ 是偶数不用纠结，直接将 $n$ 赋值为 $\dfrac{n}{2}$ 即可。

如果 $n$ 是奇数，那么先将答案 $+1$，然后分情况讨论：

如果 $\dfrac{n+1}{2}$ 是偶数那么将 $n$ 赋值为 $\dfrac{n+1}{2}$，否则将 $n$ 赋值为 $\dfrac{n-1}{2}$。

## 证明

作者在比赛时并没有想到证明，证明非常巧妙。~~结果赛后用了整整三页草稿纸才证明，最后发现官方题解一笔带过。~~

我们根据选择，有两种情况：

### 情况一：

我们选择的是 $\dfrac{n+1}{2}(n+1\mod 2=0)$。

我们设 $n=2s-1(s\in \mathbb N^*)$

那么我们 $\dfrac{n+1}{2}=\dfrac{2s-1+1}{2}=s$。

那么为什么 $\dfrac{n-1}{2}(n-1\mod 2=1)$ 一定不比它更优呢？

根据上文 $s$ 的定义，$\dfrac{n-1}{2}=\dfrac{2s-1-1}{2}=s-1$。

明显的，$s$ 和 $s-1$ 必然一奇一偶。

如果此时 $s-1$ 是偶数，那么 $s$ **一定可以通过某种选择使得选择后两种选择以后的 $n$ 是一样的**，此时后者（即选择 $\dfrac{n-1}{2}(n-1\mod 2=1)$ ）一定不更优。

否则后者代价再 $+1$ ，又恢复了结果为某两个相差为 $1$ 的正整数。因为两个相差为 $1$ 的正整数后者在 $s-1$ 是偶数的情况下（即选择 $\dfrac{n-1}{2}(n-1\mod 2=1)$ ）一定不更优，而另一种可能又恢复了这种讨论，所以选择的是 $\dfrac{n+1}{2}(n+1\mod 2=0)$ 一定是最优解之一。

### 情况二

我们选择的是 $\dfrac{n-1}{2}(n-1\mod 2=0)$。

我们设 $n=2s+1(s\in \mathbb N^*)$

那么我们 $\dfrac{n-1}{2}=\dfrac{2s+1-1}{2}=s$。

那么为什么 $\dfrac{n+1}{2}(n+1\mod 2=1)$ 一定不比它更优呢？

根据上文 $s$ 的定义，$\dfrac{n+1}{2}=\dfrac{2s+1+1}{2}=s+1$。

明显的，$s$ 和 $s+1$ 必然一奇一偶。

如果此时 $s+1$ 是偶数，那么 $s$ **一定可以通过某种选择使得选择后两种选择以后的 $n$ 是一样的**，此时后者（即选择 $\dfrac{n+1}{2}(n+1\mod 2=1)$ ）一定不更优。

否则后者代价再 $+1$ ，又恢复了结果为某两个相差为 $1$ 的正整数。因为两个相差为 $1$ 的正整数后者在 $s-1$ 是偶数的情况下（即选择 $\dfrac{n+1}{2}(n+1\mod 2=1)$ ）一定不更优，而另一种可能又恢复了这种讨论，所以选择的是 $\dfrac{n-1}{2}(n-1\mod 2=0)$ 一定是最优解之一。

证毕。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        long long x;
        int ans = 0;
        scanf("%lld", &x);
        while (x) {
            if (x & 1) {
                ans++;
                if (x / 2 % 2)
                    x = x / 2 + 1;
                else
                    x /= 2;
            }
            x >>= 1;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

## 其他

[代码更好看的版本](https://www.luogu.com.cn/paste/b0g9n7ln)。

---

## 作者：Gapple (赞：8)

我们发现，在 $n$ 的二进制表示的末尾为 $1$ 时会纠结，所以要尽量减少 $1$ 的个数。

在 $n$ 为偶数时，直接除以 $2$。

在 $n$ 为奇数时，我们要先选择 $+1$ 或 $-1$，再除以 $2$。

分析 $+1$ 操作对 $n$ 在二进制下的作用：将末尾连续的 $1$ 变为 $0$，并把最近的 $0$ 变为 $1$。此时我们发现，可以通过 $+1$ 减少 $1$ 的个数。

但是，当 $n$ 的二进制表示的末尾为 $01$ 时，$+1$ 只会把末尾的 $1$ 向高位移动一位，所以此时要 $-1$。

```cpp
#include <iostream>
#include <unordered_map>

using namespace std;
using i64 = long long;

unordered_map<i64, int> ans;

int cnt(i64 x)
{
    if (x == 0)
        return ans[0] = 0;
    else if (x == 1)
        return ans[1] = 1;
    else if (ans.contains(x))
        return ans[x];

    if (x & 1) {
        unsigned long long a = (x + 1) >> 1, b = (x - 1) >> 1;
        return cnt((x & 3) == 3 ? a : b) + 1;
    } else
        return cnt(x >> 1);
}

int main()
{
    int t;
    cin >> t;

    while (t-- > 0) {
        i64 x;
        cin >> x;
        cout << cnt(x) << '\n';
    }

    return 0;
}
```

---

## 作者：forever_nope (赞：8)

本质和 STD 类似，使用了不同的比较方式。

对正确性进行了~~口嗨~~的证明，如果您认为证明有不严谨的或者不正确，欢迎私信交流。

---

注意从低到高考虑每一个二进制位，遇到 $1$ 会导致答案 $+1$。

因此，我们每次可以选择的数中，应当选择一个 $1$ 数量最少的。

考虑这么贪心的做，为什么是对的，但是先上 AC 代码。

```cpp
using ll = long long;

#define int ll
#define popcnt(x) __builtin_popcount(x)

int Calc(int n) {
	int ans = 0;
	while (n) {
		n >>= __builtin_ctzll(n);
		int t1 = n >> 1, t2 = t1 + 1;
		n = (popcnt(t1) < popcnt(t2)) ? t1 : t2;
		++ans;
	}
	return ans;
}
```

也就是两个决策点，

$$
t_1=\left\lfloor\dfrac{n}{2}\right\rfloor
$$

$$
t_2=\left\lfloor\dfrac{n}{2}\right\rfloor+1
$$

注意到我们每次两个决策，是相差 $1$ 的。

那么区别就在于 $t_1$ 的最后的连续的 $1$ 的区间。

$$
t_1=(\dots0\underline{11\dots11})_2
$$

$$
t_2=(\dots1\underline{00\dots00})_2
$$

注意到我们如果继续对 $t_1,t_2$ 分别继续消除，

+ 将 $t_1$ 的最后连续的 $1$ 和前面的 $0$ 消除至少需要两次。

+ 将 $t_2$ 的最后连续的 $0$ 和前面的 $1$ 消除只需要一次。

注意到这两种消法，都能创造出相同的，前面省略号的内容，分别为，

+ 将 $t_1$ 末尾消去，然后加一，直到前面新增的 $1$ 处可以两种决策；

+ 将 $t_2$ 一直消去，直到前面的 $1$，然后同样两种相同的决策可以得到一样的结果。

因此，我们证明了这么贪心是正确的。

---

然后你注意到这两个一定是一个奇数一个偶数，

那么用奇偶性比较，就是 STD 的贪心方式了（x

---

## 作者：M1__ (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P10892)
# 题目思路
通过阅读题面，我们可以看出，其实对于每一次纠结，如果交出了了 $\frac{n-1}{2}$ 只猫猫，则剩下的为 $\frac{n+1}{2}$ 只猫猫；如果交出了了 $\frac{n+1}{2}$ 只猫猫，则剩下的为 $\frac{n-1}{2}$ 只猫猫。       
为了使纠结的次数尽可能小，我们要交出为奇数的那一个数，留下为偶数的那一个数。               
实际上，我们只需要判断 $\frac{n-1}{2}$ 和 $\frac{n+1}{2}$ 的奇偶性即可。如果 $\frac{n-1}{2}$ 是一个奇数，那就交出，将 $n$ 的值更新为 $\frac{n+1}{2}$ 即可，然后令计数器自加。以此类推，直到剩下的猫猫数量为 $0$ 。              
以样例一为例，我们可以画一个树状图来模拟：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/xp75j7st.png)
# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,tem;
ll n;
int main(){
	cin>>T;
	for(int i=1;i<=T;i++){
		cin>>n;
		ll ans=0;
		while(n>0){ 
			if(n%2!=0){
				ans++;
				if(((n+1)/2)%2==0){
					n=(n+1)/2;
				} 
				else if(((n-1)/2)%2==0){
					n=(n-1)/2;
				}
			}
			if(n%2==0){
				n=n/2;	
			} 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：隔壁泞2的如心 (赞：5)

很有趣的签到题！

当然是要在二进制下考虑 $n$。每次要你决策时，当前的 $n$ 必为奇数，不妨根据 $\frac{n-1}{2}$ 的奇偶讨论。

- 如果 $\frac{n-1}{2}$ 是奇数，那么就可以令 $n ← \frac{n+1}{2}$，从而产生进位，这样一定不劣。

- 如果 $\frac{n-1}{2}$ 是偶数，那么就可以令 $n ← \frac{n-1}{2}$，从而避免下一个 $n$ 还是奇数，不然一定不优。

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int t,n;
signed main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		int ans=0;
		while(n){
			if(n&1){
				ans++;
				if(n&2)n++;
			}
			n>>=1;
		}
		printf("%lld\n",ans);
	}
} 


```

---

## 作者：_ImposterX_ (赞：2)

分两种情况讨论。

- 当前 $n$ 为偶数：直接 $n \to \frac{n}{2}$，不需要纠结。

- 当前 $n$ 为奇数

  - 我们不难发现，一个数所拥有的因子 $2$ 的数量越多，需要纠结的次数就越少。
 
  - 所以判断 $n-1$ 和 $n+1$ 的因子 $2$ 的数量，取较大的一个。
 
代码：

```cpp
#include <bits/stdc++.h>
typedef long long ll;
const int MAXN = 2e5 + 5;

void solve() {
	ll n, ans = 0;
	std::cin >> n;
	++ans;
	ll q = n;
	while(q != 1) {
//		std::cout << q << '\n';
		if(q & 1) {
			++ans;
			ll qq = q + 1;
			ll res1 = 0, res2 = 0;
			while(!(qq & 1) && qq) ++res1, qq >>= 1;
			qq = q - 1;
			while(!(qq & 1) && qq) ++res2, qq >>= 1;
			if(res1 > res2) q = q + 1;
			else q = q - 1;
//			std::cout << q << '\n';
		}
		q >>= 1;
	}
	std::cout << ans << '\n'; 
}

int main() {
	ll T;
	std::cin >> T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：x1489631649 (赞：2)

### [题目链接](https://www.luogu.com.cn/problem/P10892)
### 分析
因为 $1 \le n \le 2^{60}$，再乘上操作次数 $t$（其中 $1 \le t \le 5 \times 10 ^ 5$），此时的运算次数已经超出了 $10^8$，所以我们**不能通过暴力枚举**来完成这道题，然而却没有任何的思路，所以我们就枚举第一个测试点来寻找规律。我们令 $step_i(1 \le i \le n)$ 为题目所求。
1. 当 $n = 1$ 时，显而易见，$step_1 = 1$。
2. 当 $n = 2$ 时，$step_2 = step_1$。
3. 当 $n = 3$ 时，我们可以选择将 $n$ 加一或者减一，结果相同。
4. 当 $n = 4$ 时，$step_4 = step_2$。
5. 当 $n = 5$ 时，$step_5$ 可以等于 $step_2 + 1$ 或者等于 $step_3 + 1$。我们通过比较可以得到 $step_5 = step_2 + 1$ 的时候更小。
6. 当 $n = 6$ 时，$step_6 = step_3$。

然后我们总结可得答案等于下表。

| $i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $step_i$ | 1 | 1 | 2 | 1 | 2 | 2 | 2 | 1 | 2 | 2 | 2 |

显然当 $i$ 是偶数时，我们直接将它除以二，当它为奇数时，我们令 $a =\dfrac{i + 1}{2}$，再令 $b =\dfrac{i - 1}{2}$，然后 $step_i = \min(a,b) + 1$。

可是这是一个递归做法并没有什么差异，所以我们就要继续找规律。

我们将上面得出奇数步数的表列出来。

| $i$ | 1 | 3 | 5 | 7 | 9 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $a$ | 无 | 1 | 2 | 3 | 4 |
| $b$ | 无 | 2 | 3 | 4 | 5 |

然后我们就会惊奇的发现 $step_a \le step_b$。然而这就是我们突破问题的关键，如何证明这个发现不是巧合。

我们从 $step_3$ 开始观察，$step_3$ 就已经大于 $step_2$，**最少也相差一**。所以 $step_5 $ 会选用 $step_2 + 1$ 然而 $step_6$ 又会等于 $step_3$，所以 $step_5 \le step_6$。

所以我们就可以得出以下代码。
### Code
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while (t--)
	{
		long long n,s=0;
		cin>>n;
		while(n!=0)
		{
			if(n%2==0)
				n/=2;
			else{
				s++;
				n/=2;
				if(n%2==1)
					n++;
			}
		}
		cout<<s<<endl;
	}
}
```
### 时间复杂度
时间复杂度为 $O(t \log n)$，显然可以通过。

---

## 作者：Frank_G (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10892)

# 大致题意

 $t$ 次询问：

每次询问输入一个整数 $n$，对于这个整数 $n$ 进行如下操作直到 $n = 0$：

**当 $n$ 为奇数时**：AzureHair 会纠结减去 $\frac{n-1}{2}$ 或  $\frac{n+1}{2}$。

**当 $n$ 为偶数时**：AzureHair 会直接减去 $\frac{n}{2}$。

求 AzureHair **最小**的纠结次数。

# 做法思路

相信大家看到这道题就已经想到了这是一道与二进制相关的题目，那么它究竟该如何处理呢？

## Step 1

既然我们要用二进制的思路解决此问题，那么我们需要一个数组 $a$ 来存储。

其核心代码为：

```cpp
memset(a,0,sizeof(a));
int flag=0;
while(n){
	flag++;
	a[flag]=n%2;
	n/=2;
}
```

## Step 2

之后我们需要遍历 $n$ 在二进制下的每一位，此处我们需要进行分类讨论（假设遍历至第 $i$ 位）：

### 1、当 $a_{i}=0$ 时

可以不进行任何考虑，直接遍历下一位就好了。

### 2、当 $a_{i}=1$ 时

此时又要分两种情况：

 #### (1)当 $a_{i+1}=0$ 时
 
 若选择在第 $i$ 位 $-1$，则第 $i+1$ 位就不需要再纠结了；但如果选择在第 $i$ 位 $+1$，则第 $i+1$ 位仍需要纠结。显然前者是更优的。

  #### (2)当 $a_{i+1}=1$ 时

  若在第 $i$ 位选择 $-1$，则第 $i+1$ 位仍需要纠结。但如果选择在第 $i$ 位 $+1$，从第 $i$ 位开始的连续的值为 $1$ 的位置都不需要纠结了。显然后者是更优的。

这一部分的核心代码为（由于作者习惯问题，在这段代码之前将数组 $a$ 进行了倒序）：

```cpp
for(int i=1;i<=flag;i++){
	if(a[i]==0) continue;
	else{
		if(a[i+1]==0) ans++;
		else{
			ans++;
			for(int j=i;j<=flag+1;j++){
				if(a[j]==1) a[j]=0;
				else{
					a[j]=1;
					break;
				}
			}
		}
	}
}
```

## Step 3

解决完之后我们需要处理一个小细节，就是当操作完 Step 2 后，第 $flag+1$ 位可能会变成 $1$，因此我们需要进行特判。

其核心代码为：

```cpp
if(a[flag+1]==1) ans++;
```

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll n;
int t;
int a[70],ans; 
int main()
{
	cin >> t;
	while(t--){
		cin >> n;
		ans=0;
		memset(a,0,sizeof(a));
		int flag=0;
		while(n){
			flag++;
			a[flag]=n%2;
			n/=2;
		}
		for(int i=1;i<=flag;i++) swap(a[i],a[flag-i+1]);
		for(int i=1;i<=flag;i++){
			if(a[i]==0) continue;
			else{
				if(a[i+1]==0) ans++;
				else{
					ans++;
					for(int j=i;j<=flag+1;j++){
						if(a[j]==1) a[j]=0;
						else{
							a[j]=1;
							break;
						}
					}
				}
			}
		}
		if(a[flag+1]==1) ans++;
		cout << ans << endl;
	}
	return 0;
}
```

然后你就可以像我一样 AC 啦。

![AC](https://ts1.cn.mm.bing.net/th/id/R-C.6265136af2fb6d1696153c0628133f58?rik=9DH74ME1a7B2bQ&riu=http%3a%2f%2fa2.qpic.cn%2fpsb%3f%2fV12Nr9Jd3RiGAO%2f2Gpg2BrIG8eM09hEcxA8*n*6lSoWRGXlt4rCfh9Eo9c!%2fb%2fdLkAAAAAAAAA%26ek%3d1%26kp%3d1%26pt%3d0%26bo%3d9AGWAQAAAAADN3A!%26tl%3d1%26vuin%3d2080788523%26tm%3d1556971200%26sce%3d60-2-2%26rf%3dviewer_4&ehk=EeDV0jeq6Oo%2bl08RRaUSjf2Vr6u7pzniYE78gi%2fc46Q%3d&risl=&pid=ImgRaw&r=0)

**声明+提醒：一定要自己写一遍，否则你不知道你有哪里还没明白！！！**

---

## 作者：__DayLight__ (赞：2)

## 前言

赛时想二进制做法，想了很久做不出来，后面贪心几分钟写出来了。

## 思路

### 贪心
当 $n$ 是奇数是会纠结一次，而我们要做的就尽量是避免 $n$ 变成奇数。

先了解一个性质：

>奇数 $-$ 奇数 $=$ 偶数

假设 $n=5$，则 $\frac{n-1}{2}=\frac{4}{2}=2，\frac{n+1}{2}=\frac{6}{2}=3$。

为避免 $n$ 变成奇数，选择减去其中的奇数 $3$，使 $n$ 变成偶数 $2$，即减去 $\frac{n+1}{2}$。

完整顺序：$5 \rightarrow 2 \rightarrow 1 \rightarrow 0$，这样纠结次数就是 $2$ 次。

反之，若得 $3$，则完整顺序是 $5 \rightarrow 3 \rightarrow 1 \rightarrow 0$，这样纠结次数变成了 $3$，显然不是最优。

总结：判断 $\frac{n-1}{2}$ 与 $\frac{n+1}{2}$ 的奇偶性，减去奇数。



---

### 二进制

在位运算中，右移 $1$ 相当于除以 $2$。

而判断一个数的奇偶性也可以通过其转为二进制后的最低位判断。

所以我们考虑模拟右移。

将 $n$ 转化为一个二进制数组 $b$，$b_i$ 表示 $n_{(2)}$ 从右往左第 $i$ 个数，将数组 $b$ 的长度记为 $m$。

从 $b_1$ 开始处理，处理到第 $i$ 位默认当前是最低位，针对每种情况处理如下：
- 当 $b_i=0$，在最低位表示这个数是偶数，不纠结，跳过。

- 当 $b_i=1$，在最低位表示这个数是奇数，纠结过程：

  - 若 $b_{i+1}=1$，减去 $\frac{n-1}{2}$，即保留 $\frac{n+1}{2}$，意味着 $b_i+1$，可以进位让 $b_{i+1} +1$，这样 $b_{i+1}=0$
   
  - 反之，减去 $\frac{n+1}{2}$，即保留 $\frac{n-1}{2}$。
 
- 当 $b_i=2$，表示前一位进位了，这一位也要进位，即 $b_{i+1}+1$，进位后 $b_i=0$，是偶数，不纠结。

注意：进位操作可能会让 $b$ 的长度增加。

## 代码

贪心的就不放了，很简单，放二进制的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,b[65],m,ans;
long long n;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n;
		ans=m=0;
		memset(b,0,sizeof b);//初始化 
		while(n)//转二进制。 
		{
			b[++m]=n%2;
			n/=2;
		}
		for(int i=1; i<=m; i++)
		{
			if(b[i]==0)continue;
			if(b[i]==1)
			{
				ans++;
				if(b[i+1]==1)b[i+1]++;//看看后一位是否是 1 
			}
			if(b[i]==2)//进位了 
			{
				b[i+1]++;
				if(i==m)m++;//位数增加 
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：39xiemy (赞：1)

## 题目大意

有 $n$ 只猫，当 $n$ 为偶数时，拿走 $\frac{n}{2}$ 只猫；当 $n$ 为奇数时，纠结次数加 $1$，并从拿走 $\frac{n-1}{2}$ 只猫或拿走 $\frac{n+1}{2}$ 只猫中选择一种方式拿走。求所有猫都被拿走后，纠结次数至少为多少。

## 分析

可以用贪心的方法来做。

由于每次都要拿走将近 $\frac{n}{2}$ 只猫，所以拿走猫的次数大致只有 $\log n$ 次，可以直接来模拟一遍，所以只需要考虑当 $n$ 为奇数时，要用哪种方法来拿走猫。

要使纠结次数尽量少，就要让 $n$ 尽量为偶数。所以当 $n$ 为奇数时，就拿走奇数只猫，这样 $n$ 就是一个偶数了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,ans; 
signed main()
{
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		scanf("%lld",&n);
		while(n)
		{
			if(n%2)
			{
				n-=((n/2)%2?n/2:n/2+1),ans++;//如果(n-1)/2是一个奇数，就拿走(n-1)/2只猫，否则拿(n+1)/2只猫。（当n为奇数时，n/2和(n-1)/2，n/2+1和(n+1)/2等价
			}
			else
			{
				n/=2;//偶数时直接拿走n/2只猫
			}
		}
		printf("%lld\n",ans);
		ans=0;
	}
	return 0;
}
```

---

## 作者：Laoda_Bryant (赞：0)

## 思路
考虑贪心策略。  
1. 当剩下的猫猫数量为偶数的时候，直接取出 $\large \frac{n}{2}$ 只猫猫即可。
2. 否则当剩下的猫猫数量为奇数的时候，则要尽可能保持第二天猫猫的数量为偶数。则要考虑 $n-\large \frac{n-1}{2}$ 和 $n-\large \frac{n+1}{2}$ 哪个是偶数。  
第二条的 $n-\large \frac{n-1}{2}$ 和 $n-\large \frac{n+1}{2}$ 可化简成 $\large \frac{n+1}{2}$ 和 $\large \frac{n-1}{2}$。
## AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,n,ans;
signed main(){
	cin>>T;
	while(T--){
		cin>>n;
		ans=0;
		while(n){
			if(n&1){
				if(((n-1)>>1)%2==0) n=(n-1)>>1;
				else n=(n+1)>>1;
				ans++;
			}else n>>=1;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
[博客链接](https://www.cnblogs.com/bubble-sort/p/18372728)

---

## 作者：nightwatch.ryan (赞：0)

### 思路
如果当前 $n$ 是奇数，答案加一，如果：
- $n - \dfrac{n + 1}{2}$ 等于偶数，那么让 $n \gets n - \dfrac{n + 1}{2}$。
- 否则让 $n \gets n - \dfrac{n - 1}{2}$。

这样确保一定会将 $n$ 变为偶数，变为偶数一定要比变为奇数好。

最后输出答案。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define P(i, a, b) for(int i = a; i <= b; i++)
#define Q(i, a, b) for(int i = a; i >= b; i--)
const int maxn = 100005;
const int inf = 0x3f3f3f3f;

mt19937 rnd(chrono::duration_cast<chrono::nanoseconds>
           (chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

signed main(){

    cin.tie(0)->sync_with_stdio(0);
    int T;
    cin >> T;
    while(T --){
    	long long n;
    	int ans = 0;
    	cin >> n;
    	while(n){
    		if(n & 1){
    			ans ++;
    			(n - ((n + 1) >> 1)) & 1 ^ 1 ? n -= ((n + 1) >> 1) : n -= ((n - 1) >> 1);
    		}else{
    			n >>= 1;
    		}
    	}
    	cout << ans << "\n";
    }

}
```

---

## 作者：Zskioaert1106 (赞：0)

#### 这篇题解写上了作者对贪心的证明

题目有点绕，但不多。其实说到底就是：给你一个整数 $n$，每次将 $n$ 除以 $2$，当 $n$ 为奇数时可以自由选择向上取整还是向下取整。要求使 $n$ 为奇数的情况最少。

这题的贪心就是尽量使除以 $2$ 后的 $n$ 为偶数。很明显，但是具体怎么证明呢？

### 证明思路

（本节的 $n$ 与题目中没有关联）

很明显，每个正奇数都可以分解为 $4n+3$ 或 $4n+1$，其中 $n$ 是一个非负整数。$4n+3$ 可以分解为 $2n+1$ 或 $2n+2$，$4n+1$ 可以分解为 $2n$ 或 $2n+1$。

很明显，$2n+2$ 和 $2n$ 是偶数，$2n+1$ 是奇数。同时 $n$ 和 $n+1$ 可奇可偶。

如果选择 $2n+1$，此时犹豫的次数要增加 $1$，但接下来可以任选奇偶性。

如果选择 $2n$，那下一次无需犹豫，直接变成 $n$。如果 $n$ 是偶数，那当然更好了；如果 $n$ 是奇数，则犹豫次数增加 $1$，始终不会大于选择 $2n+1$。

如果选择是 $2n+1$ 和 $2n+2$ 也一样，$2n+2$ 直接变成 $n+1$，$n+1$ 同样有奇偶两种可能，同样不大于选择 $2n+1$ 的结果。

还有一个疑问：会不会说选择奇数再变成偶数后就进入一个像完全平方数一样的流程，从此“一帆风顺”，而一开始选择偶数就错过了这个机会？

其实不会，以 $4n+1$ 为例，如果先选 $2n+1$ 再选 $n$ 和 $n+1$ 中的偶数，比如 $n+1$ 和 $\dfrac{n+1}{2}$ 是偶数，那么 $2n\Rightarrow n\Rightarrow\lceil\dfrac{n}{2}\rceil=\dfrac{n+1}{2}$ 就能追回来（$n$ 必定为奇数）。其它三种情况更好证了。

证出贪心 ~~（不用证，结合样例猜就行）~~ 后，代码编写就简单了。

### code

```cpp
#include<iostream>
using namespace std;
int main(){
  int t;
  cin>>t;
  while(t--){
    long long n,s=0;
    cin>>n;
    while(n){
      if(n&1)s++,n+=((n/2)&1);
      n/=2;
    }
    cout<<s<<'\n';
  }
  return 0;
}
```

---

## 作者：__O_w_O__ (赞：0)

做法：如果当前的数字是偶数，直接除以二即可。

如果当前的数是奇数，显然，$\frac{n+1}{2}$ 和 $\frac{n-1}{2}$ 里面只可能有一个会是偶数，另一个一定是奇数，因为题目要求的是最小纠结的次数，那么就要尽可能地让奇数出现的次数变少，由此就可以得到贪心的策略：选取二者之间为偶数的进行更新当前的数。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T;
    cin >> T;
    while(T--) {
        long long n;
        scanf("%lld", &n);
        int cnt = 0;
        while(n > 0) {
            if (n % 2 == 0) n /= 2;
            else {
                if (((n + 1) / 2) % 2 == 0) n = (n + 1) / 2;
                else n = (n - 1) / 2;
                cnt++;
            }
        }
        printf("%d\n", cnt);
    }
    return 0;
}
```

---

## 作者：liuli688 (赞：0)

设交出 $x$ 只猫猫所需天数为 $d(x)$。
### 方法一：记忆化搜索，期望得分 $30\ \text{pts}$
对于 $\forall x$，若 $x \bmod 2 = 0$ 则 $d(x) = d(\frac x 2)$，否则 $d(x) = \min(d(\frac 
{x + 1} 2), d(\frac {x - 1} 2)) + 1$。只需打一个记搜即可拿到 $30$ 分。

注意由于 $n$ 非常大，所以要开 `std::map` 或 `std::unordered_map`（自 C++11 启）。
```cpp
#include <cstdio>
#include <unordered_map>

#define reg register

typedef long long ll;
std::unordered_map<ll, int> ans;
int T;
ll n;

int dec(ll x)
{
	if (x == 1)
	{
		ans.insert(std::pair<ll, int>(1, 1));
		return 1;
	}
	if (ans.find(x) != ans.end())
		return ans[x];
	if (x & 1)
		return std::min(dec(x + 1 >> 1), dec(x - 1 >> 1)) + 1;
	return dec(x >> 1);
}

signed main()
{
    scanf("%d", &T);
    while (T--)
    {
    	scanf("%lld", &n);
    	printf("%d\n", dec(n));
	}
    return 0;
}
```
### 方法二：贪心，期望得分 $100\ \text{pts}$
定理：

> 对于 $\forall x \bmod 2 = 0$，有 $d(x + 1) - d(x) \in [0, 1]$。

证明：

显然 $d(x) = d(\frac x 2)$。对于 $x + 1$，可以选择变为 $\frac x 2$，次数为 $d(\frac x 2) + 1$；或者 $\frac x 2 + 1$，次数为 $d(\frac x 2 + 1)$，所以问题变为了证明 $d(\frac x 2 + 1) - d(\frac x 2) \in [0, 1]$。所以原问题不变，但规模缩小了。因为已知 $d(1) = 1, d(2) = 1$，由数学归纳法可知定理成立。

引理：

> 对于 $\forall x \bmod 2 = 0$，有 $d(x - 1) - d(x) \in [0, 1]$。

证明思路类似。

所以，我们在对 $x$ 进行选择时，若 $\frac {x + 1} 2 \bmod 2 = 1$，则选择 $\frac {x - 1} 2$；反之同理。

时间复杂度 $O(T\log _ 2 n)$。
```cpp
#include <cstdio>

#define reg register

typedef long long ll;
int T, ans;
ll n;

signed main()
{
    scanf("%d", &T);
    while (T--)
    {
    	scanf("%lld", &n);
    	ans = 0;
    	while (n)
    	{
    		if (n & 1)
    		{
    			++ans;
    			if ((n + 1) >> 1 & 1)
    				--n >>= 1;
    			else
    				++n >>= 1;
			}
			else
				n >>= 1;
		}
		printf("%d\n", ans);
	}
    return 0;
}
```

---

## 作者：fish_love_cat (赞：0)

签到。

---

模拟往下除即可。

如果发现是奇数，我们有向上取整和向下取整两种选择。显然，这一次的选择会影响到下一次除时数字的奇偶性。为了让纠结次数变小，我们应当贪心的选择，要让下一次拿到偶数。我们需要根据 $n \bmod 4$ 的结果分类讨论。

容易知道，如果 $n \bmod 4=0$，下一次也能拿到偶数。所以我们要使 $n$ 加一或减一后的结果是 $4$ 的倍数。

如果当前 $n \bmod 4=1$，减一即可得到 $n-1\bmod 4=0$。

如果当前 $n \bmod 4=3$，加一即可得到 $n+1\bmod 4=0$。

那么就做完了。

---

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        long long n,ans=0;
        cin>>n;
        while(n){
            if(n%2){
                ans++;
                if(n%4==3)n++;
                else n--;
            }
            n/=2;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

还算是比较不错的签到。

---

## 作者：homo_snow (赞：0)

贪心即可。

将 $n$ 转化为二进制，此时 $n$ 一定是由若干段长度不一 $0$ 和 $1$ 组成。

我们发现，除 $2$ 操作实际上就是将这个二进制右移一位。

于是就有两种情况：

当这一位是 $0$，那么我们直接右移即可。

如果这一位是 $1$，就要考虑是将这一位加 $1$ 进位还是减 $1$ 消除好。

显然的，如果当前这一个 $1$ 是在一个长度为 $1$ 的由连续 $1$ 的组成的串中，减 $1$ 才是最优的，因为加 $1$ 会让这个 $1$ 进位，把它本身挪到下一个 $0$ 的位置去，奇数的数量并没有减少，还有可能增多。把它减去 $1$ 的话，将相当于把这个 $1$ 变成了 $0$，相当于把下一段的 $0$ 串增加了长度，这是确切地减少了奇数的数量。

反之，如果这一段 $1$ 的长度大于 $1$，减就没有加好使了，因为加 $1$ 之后，这一整段 $1$ 都会进位而变成 $0$，产生的副作用只有将下一个 $0$ 变成 $1$，显然的，正向影响大于负面影响。

最后的贪心思路就出来了：对于偶数直接除，对于奇数分别看看向上取整与向下取整的结果，选择其中结果为偶数的方法。


```cpp
#include<bits/stdc++.h>
#define int long long	
using namespace std;
const int N = 5e2+10;
const int INF = 0x3f3f3f3f;

int t , n;

signed main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		int ans = 0;
		while(n){
			if(n & 1) {
				ans++;
				if((n + 1) >> 1 & 1) n >>= 1;
				else n = (n + 1) >> 1;
			}
			n >>= 1;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---


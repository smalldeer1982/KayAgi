# [蓝桥杯 2024 国 B] 合法密码

## 题目描述

小蓝正在开发自己的 OJ 网站。他要求网站用户的密码必须符合以下条件：

1. 长度大于等于 $8$ 个字符，小于等于 $16$ 个字符。
2. 必须包含至少 $1$ 个数字字符和至少 $1$ 个符号字符。

例如 `lanqiao2024!`、`+-*/0601`、`8((>w<))8` 都是合法的密码。

而 `12345678`、`##**##**`、`abc0!#`、`lanqiao20240601!?` 都不是合法的密码。

请你计算以下的字符串中，有多少个子串可以当作合法密码？只要两个子串的开头字符和末尾字符在原串中的位置不同，就算作不同的子串。

字符串为：

```plain
kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th
```

# 题解

## 作者：封禁用户 (赞：15)

# P10906[蓝桥杯 2024 国B] 合法密码
题目链接：[P10906](https://www.luogu.com.cn/problem/P10906)

---
## 题目大意
在给定的字符串中寻找符合要求的字符串，这些字符串需要满足以下两个要求：
- 长度大于等于 $8$ 个字符，小于等于 $16$ 个字符。
- 必须包含至少 $1$ 个数字字符和至少 $1$ 个符号字符。

---
## 样例分析
本题提交答案即可，即把正确的答案提交上去即可，不需要提交代码。

---
## 思路构建
很明显，一个由 $100$ 个字符组成的字符串想要一一枚举出来极其不现实，既容易多数漏数也容易重复数，因此还是需要编写一个代码来实现。  
这个代码其实很简单，从字符串第一个数开始，这个数保持不变，然后找出所有长度为 $8$~$16$ 之间的所有字符串（这里就是满足第一个条件），接着看这些字符串是否满足第二个条件，如果满足`ans++`，不满足则不加。  
重复上面这个步骤直到还剩$7$个字符时停止。

---
## 代码展示
本题答案为 $400$，直接输出这个数即可。

这里给出部分代码，仅供参考。

```cpp
void solve()
{
    string s;
    cin >> s;
    int n = s.size();
    auto check = [&](string t) -> bool
    {
        bool fl = 0;
        for(auto c : t)
            if(isdigit(c))
                fl = 1;
        if(!fl) return false;
        for(auto c : t)
        {
            if(isdigit(c) || isalpha(c)) continue;
            return true;
        }
        return false;
    };
    int cnt = 0;
    for(int i = 0; i < n; i ++)
    {
        for(int len = 8; len <= 16; len ++)
        {
            if(i + len - 1 >= n) break;
            int l = i, r = i + len - 1;
            string s1 = s.substr(i, len);
            if(check(s1))
                cnt ++;
        }
    }
    cout << cnt << endl;
}
```


---
## 完结撒花
感谢您看到这里，如果您觉得有帮助麻烦您点个赞谢谢~

---

## 作者：canwen (赞：8)

## 分析
提交答案题，我们在 IDE 跑一遍程序看结果。

枚举每一个长度 $\ge 8$，且长度 $\le 16$ 的子串，编写函数检查其是否含有字符 `#` 和字符数字。都含有返回 $1$，否则 $0$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

bool check(string s){
	int a=0,b=0;
	for(int i=0;i<s.size();i++){
		if(s[i]>='0'&&s[i]<='9') a=1;
		if(s[i]=='#') b=1;
	}
	if(a+b==2) return 1;
	return 0;
}
int main(){
	string s="kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
	int ans=0;
	for(int i=0;i<s.size();i++){
		for(int j=8;j<=16;j++){
			if(i+j<=s.size()&&check(s.substr(i,j))){
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

输出 $400$，提交 $400$ 即可通过了。

---

## 作者：yueyan_WZF (赞：3)

这道题十分的简单。

----
观察题目，有这样几个规则：

- $8 \le $ 长度 $ \le 16 $
- 至少有一个数字和字符

题目给出的字符串只有 $100$ 位，所以直接放心大胆的做就行了。

### 代码：

首先，我们用一个 for 循环，从 $8$ 枚举到 $16$ ，模拟密码的长度。

接下来，我们再用一个 for 循环，枚举合法密码的左端点。

这样我们就确定了一个密码，只需要判断它是否合法就行了。

最后，再用一个 for 循环，把我们当前枚举的密码遍历一下，记录数字个数和字符个数，最后判断是否都大于等于 $1$ 就行了。

----

### 可能出现的疑惑

1. “符号字符”是什么？

   “符号字符”就是除了字母和数字以外的其他字符。

2. “为什么会 RE”

     这道题是输出答案题，不要把算答案的程序放上去。

---

## 作者：2023gdgz01 (赞：3)

由于此题为类提交答案题，所以直接暴力算答案即可，但实际上把计算答案的过程放在评测机上跑也行。

顺序遍历子串的左端点，内层循环遍历子串的长度，为 $8\sim16$，再把子串通过 `substr()` 函数截取出来，写一个自定义函数判断是否合法即可。

代码如下：

```cpp
#include <cstdio>
#include <cctype>
#include <string>

using namespace std;

int ans;
string s = "kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";

inline bool check(string x) {
	bool num = false, Char = false;
	for (register auto it: x) { //遍历 x
		num |= isdigit(it);
		Char |= (it == '#');
	}
	return num && Char;
}

int main() {
	for (register int i = 0; i < s.size(); ++i) //枚举左端点
		for (register int j = 8; j <= 16 && i + j - 1 < s.size(); ++j) //枚举长度
			ans += check(s.substr(i, j));
	printf("%d", ans);
	return 0;
}
```

语句频度为 $T(100\times(8+9+10+\cdots+15+16))=T(10800)$。[AC 链接](https://www.luogu.com.cn/record/174396438)

---

## 作者：linch (赞：1)

## 题意
提交答案题。

给你一个字符串，求出满足以下条件的子串总数。
- 长度大于等于 $8$ 且小于等于 $16$。
- 至少有一个符号和一个数字。

## 思路
我们发现，这个字符串长度仅为 $100$，可以直接枚举所有长度大于等于 $8$ 且小于等于 $16$ 的子串，判断其中是否有一个符号和一个数字即可。

可以使用二重循环。第一层循环枚举子串起点，第二层枚举长度，使用两个变量分别记录数字个数和符号个数，如果都大于等于 $1$，则总数加一。

## 代码
最终答案为 $400$，这里给出求解出答案的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt;//记录符合要求的子串总数。
int main(){
	string s="kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
	int len=s.length();//获取长度。
	for(int i=0;i<=len-8;i++){//枚举起点，由于符合条件的子串长度至少为 8，遍历至 len-8 即可。
		for(int j=8;j<=16;j++){//枚举长度。
			int num=0,ch=0;
			if(i+j-1>=len) break;//超了，直接退出。
			for(int k=i;k<=i+j-1;k++){
				if(s[k]>='0' && s[k]<='9'){
					num++;
				}//统计数字出现次数。
				else if(!(s[k]>='a' && s[k]<='z')){
					ch++;
				}//统计符号出现次数。
			}
			if(ch>=1 && num>=1) cnt++;
		}
	}
	cout<<cnt<<"\n";
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10906)

比较简单的一个题。

我们一眼看出给定的字符串长度不是很长，可以直接用最暴力的方法计算子串。

下文中 $|s|$ 表示字符串 $s$ 的长度。

我们把字符串 $s$ 赋值为题目给定字符串，并让下标从 $1$ 开始。我们可以在枚举左端点和右端点的时候直接保证子串的长度 $\ge 8$，所以左端点的范围是 $1\sim|s|-8+1$，也就是 $1\sim|s|-7$，右端点的范围是 $l+8-1\sim|s|$，也就是 $l+7\sim|s|$（当然也可以正常枚举子串，判断长度是否 $\ge 8$ 即可）。

紧接着我们用字符串的 `substr` 功能截取 $s$ 中 $l\sim r$ 的一段子串，也就是 `s.substr(l, r - l + 1)`，如果这个子串的长度 $>16$ 则直接退出第二重循环，因为右端点的下标在不断增加，后续的字符串的长度肯定也是 $>16$ 的。如果长度符合要求，则检查数字字符和符号字符是否都至少有 $1$ 个，如果也符合要求那么把答案加上 $1$，最后输出。

给一下代码，答案是 $400$。

```cpp
#include <iostream>
using namespace std;

bool Check(string s)
{
    int num = 0, opt = 0;
    for (int i = 0; i < s.size(); i++)
    {
        // 略过大小写字母
        if (s[i] >= 'a' && s[i] <= 'z') continue;
        if (s[i] >= 'A' && s[i] <= 'Z') continue;
        // 如果是数字
        if (s[i] >= '0' && s[i] <= '9') num++;
        // 如果是符号
        else opt++;
    }
    return (num >= 1 && opt >= 1);
}

int main()
{
    string s = "kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
    int len = s.size(), ans = 0;
    s = ' ' + s;
    for (int l = 1; l <= len - 7; l++)
    {
        for (int r = l + 7; r <= len; r++)
        {
            // 两重循环保证长度 >= 8
            string t = s.substr(l, r - l + 1);
            if (t.size() > 16) break; // 这次以及后面的长度都会 > 16
            if (Check(t))
            {
                ans++;
                // cout << t << "\n";
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：George222 (赞：1)

[cnblogs食用更佳](https://www.cnblogs.com/George222/p/18376836)

本来以为字符串多大，结果就这点，直接暴力。

枚举起始点，对于每个起始点枚举后面 $8 \sim 16$ 位有没有能用的即可。

最后答案为 $400$。

---

附：计算代码

枚举代码如下：
```cpp
    for (int i = 0; i < n; ++i) {
        for (int length = 8; length <= 16; ++length) {
            if (i + length > n)
                break;
            string substring = s.substr(i, length);
            if (check(substring))
                ++valid_count;
        }
    }

```

check 函数如下：
```cpp
    bool has_digit = false;
    bool has_symbol = false;
    unordered_set<char> symbols = {'+', '-', '*', '/', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '=', '<', '>', '?', '~', '`'};

    for (char c : password) {
        if (isdigit(c))
            has_digit = true;
        else if (symbols.find(c) != symbols.end())
            has_symbol = true;
        if (has_digit && has_symbol)
            return true;
    }
    return false;
```

---

## 作者：xd244 (赞：0)

思路：双重循环枚举子串的两个端点，判断中间的字符串是否合法（设左右端点分别为 $l$ 和 $r$，字符串为 $s$，则字符串长度为 $r-l+1$）

当 $r-l+1<8$ 或者 $r-l+1>16$ 时不合法。

当 $s_l$ 到 $s_r$ 之间没有数字或者特殊符号时不合法。

题上的字符串只有 `#` 一种特殊符号，特判即可。

代码：

```cpp
#include<iostream>
#include<string>
using namespace std;
string s;int len,cnt;
bool check(int l,int r){
	if(r-l+1<8)return 0;
	if(r-l+1>16)return 0;
	int a=0,b=0;
	for(int c=l;c<=r;c++){
		if('0'<=s[c]&&s[c]<='9')a++;
		if(s[c]=='#')b++;
	}if(a==0||b==0)return 0;
	return 1;
}int main(){
	cin>>s;
	len=s.length();
	for(int l=0;l<len;l++){
		for(int r=l+1;r<len;r++){
			if(check(l,r))cnt++;
		}
	}cout<<cnt;
}
```
最后的答案为 $400$。

The end.

---

## 作者：nightwatch.ryan (赞：0)

### 思路
判断给定字符串的所有子串。

如果该子串有数字且有符号字符，那么答案加一。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

#define P(i, a, b) for(int i = a; i <= b; i++)
#define Q(i, a, b) for(int i = a; i >= b; i--)
const int maxn = 100005;
const int inf = 0x3f3f3f3f;

mt19937 rnd(chrono::duration_cast<chrono::nanoseconds>
           (chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

string X = "kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";

signed main(){

    cin.tie(0)->sync_with_stdio(0);
    int n = X.size(), ans = 0;
    P(i, 0, n - 1){
        P(j, i, n - 1){
            string Y = X.substr(i, j - i + 1);
            int m = Y.size();
            if(m >= 8 && m <= 16){
                bool hasNumber = false;
                bool hasSymbol = false;
                for(const auto & y : Y){
                    if(isdigit(y)) hasNumber = true;
                    if(y == '#') hasSymbol = true;
                }
                ans += hasNumber && hasSymbol;
            }
        }
    }
    cout << ans << endl;
}
```

---

## 作者：ChampionCyan (赞：0)

这是一道提交答案题，建议评橙。

我们可以本地先算出答案再提交。因此，我们不用担心超时，直接暴力即可。

这里给出伪代码：

```
string s = "kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th"
int ans = 0
for i from 0 to size(s):
  for j from 0 to size(s):
    if i - j + 1 <= 16 and i - j + 1 >= 8 then:
      int digits = 0
      int chars = 0
      for k from i to j:
        if isdigit(s[k]) then
          digits = digits + 1
        if ischaracter(s[k]) then
          chars = chars + 1
    if digits >= 1 and chars >= 1 then
      ans = ans + 1
print ans
```

最终我们得到了答案：$400$。

然后写一个输出 $400$ 的程序即可，这里给出 C/C++ 代码：

```cpp
#include <stdio.h>
int main() {
    puts("400");
    return 0;
}
```

---

## 作者：JYX0924 (赞：0)

这道题可以用暴力来做。

每次枚举子串的左端点和右端点，然后判断一下子串是否合法即可。

用下面的代码就可以算出答案。


```c
#include<bits/stdc++.h>
using namespace std;
int len,ans;
string s;
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>s; len=s.length();
	for(int i=0;i<len;i++) for(int j=i+7;j<len&&j<i+16;j++)
	{
		int flag=0;
		for(int k=i;k<=j;k++) if(s[k]>='0'&&s[k]<='9') {flag++; break;}
		for(int k=i;k<=j;k++)
		{
			if((s[k]>='0'&&s[k]<='9')||(s[k]>='a'&&s[k]<='z')||(s[k]>='A'&&s[k]<='Z')) continue;
			flag++; break;
		}
		if(flag==2) ans++;
	}
	cout<<ans;
	return 0;
}
```

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cout<<400;
	return 0;
}
```
谢谢大家！！！

---

## 作者：coderJerry (赞：0)

这似乎是我在蓝桥杯国赛见过~~最水~~的填空题了。

枚举给定字符串所有长度为 $8$ 到 $16$ 的子串，统计其中数字字符和特殊字符（原字符串里只有 ```#``` 一个特殊字符）的数量，判断是否都大于等于 $1$ 即可。容易写出代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int ans=0;
    string s="kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
    for(int j=8;j<=16;j++){//枚举子串的长度
        for(int i=0;i<=s.size()-j;i++){//枚举子串
            string n=s.substr(i,j);
            int a=0,b=0;//a 统计数字字符，b 统计特殊字符
            for(int k=0;k<j;k++){
                int d=(int)(n[k]-'0');
                if(d>=0&&d<=9) a++; //是数字字符
                if(n[k]=='#') b++; //是特殊字符
            }
            if(a>=1&&b>=1) ans++; //都大于一答案加一
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

运行程序，得到结果：$400$。

---

## 作者：lcfollower (赞：0)

首先这题可以编程做。

考虑枚举起点 $i$ 和终点 $j$，然后用 $k$ 遍历 $s_{i\cdots j}$ 是否合法，合法就累加答案，这题就做完了。

加上一个提前跳出优化时间复杂度为 $\mathcal O(n)$，~~但是有 $8+9+\cdots+15+16=108$ 倍左右的常数。~~

```cpp
# include <bits/stdc++.h>

using namespace std;

string s = "kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
int ans;

signed main(){

  int len = s.size();

  for(int i = 0 ;i < len ;i ++)
    for(int j = i ;j < len ;j ++){
      if(j - i + 1 < 8) continue;
      if(j - i + 1 > 16) break;
      bool f = 0 ,f1 = 0;
//f 判断是否有数字，f1 判断是否有符号。
//注意是符号而不是字母，否则输出为 618。
      for(int k = i ;k <= j; k ++)
        f |= isdigit(s[k]) ,f1 |= (!(isdigit(s[k]) || isalpha(s[k])));
      if(f && f1) ++ ans;
    }
  printf("%lld\n" ,ans);

  return 0;
}
```

---

## 作者：zhoujunchen (赞：0)

做题思路
---
密码条件题目已经说得很清楚了。

枚举每一个子串看它满不满足条件就行了。

注意要包含的是 $1$ 个**符号字符**，不是字母。


```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
string s="kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
bool check(int l,int r){
    if((r-l+1)<8||(r-l+1)>16)return false;//长度不符合
    bool sz=0,fh=0;//sz代表是否出现数字，fh代表是否出现字母
    for(int i=l;i<=r;i++){
        if(s[i]>='0'&&s[i]<='9')sz=1;
        else if(s[i]=='#')fh=1;//给出的字符串里只有 # 符号所以只用判断她就行了
    }
    return sz&&fh;//两个条件都要满足
}
int main(){
    int n=s.size();
    for(int i=0;i<n;i++)//枚举每一个字串
        for(int j=i;j<n;j++)
            ans+=check(i,j);
    cout<<ans;
    return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P10906 题解

## 思路

发现字符串长度只有 $100$ 左右，随便乱弄一下都能过吧。

枚举左端点，枚举右端点，判断区间是否满足长度在 $[8,16]$ 中且至少含有 $1$ 个数字字符和 $1$ 个符号字符。

数字字符可以用 `isdigit()` 判断。

符号字符，既不是字母，也不是数字，又不是空字符。

## 代码

求解的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=105;

int n,ans;
char s[N];

bool issym(char c) {
    return !isalpha(c) && !isdigit(c) && !isspace(c);
}

int main() {
    scanf("%s",s+1);
    n=strlen(s+1);
    for (int l=1;l<=n;++l) {
        for (int r=l+7;r<=n && r-l+1<=16;++r) {
            bool num=false,ch=false;
            for (int i=l;i<=r;++i) {
                if (isdigit(s[i])) num=true;
                else if (issym(s[i])) ch=true;
            }
            if (num && ch) ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```

得到结果 $400$，将它输出就好：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    puts("400");
    return 0;
}
```

---

## 作者：DLJdouliangjian (赞：0)

## 思路:
这题肯定是直接暴力枚举。  
首先枚举密码长度，然后枚举左端点，算出右端点，截出子串，再根据题意判断即可。
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
string a="kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th";
int ans;
bool check(string a){
	bool f1=0,f2=0;
	for(int i=0;i<a.size();i++){
		if(a[i]>='0'&&a[i]<='9') f1=1;
		if(!(a[i]>='0'&&a[i]<='9'||a[i]>='A'&&a[i]<='Z'||a[i]>='a'&&a[i]<='z')){
			f2=1;
		}
	}
	return f1&&f2;
}
int main(){
	for(int i=8;i<=16;i++){
		int l=0,r=i-1;
		while(r<a.size()){
			string tmp=a.substr(l,i);
			l++;
			r++;
			if(check(tmp)){
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：hexuchen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10906)

[更好的阅读体验？](https://www.luogu.com.cn/article/yb1mc6vn)

## 思路分析

看到题目，第一个反应是用排列组合去写。然而用排列组合写了半天，算出来答案是错的。再一看题，字符串的长度只有 $100$，为什么不打个暴力呢？

暴力思路很简单，双重循环，分别枚举起点和终点。再写一个判断函数，先遍历枚举的这个子串，判断子串里有没有出现过特殊字符和数字。再统计长度，判断长度合不合法，如果都合法，则答案加一。最后的答案就是 $400$。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s="kfdhtshmrw4nxg#f44ehlbn33ccto#mwfn2waebry#3qd1ubwyhcyuavuajb#vyecsycuzsmwp31ipzah#catatja3kaqbcss2th"; //字符串
int ans=0;
bool check(int left,int right){
	int lon=0;
	bool f1=false,f2=false;
	for(int i=left;i<=right;i++){
		lon++; //长度
		if(s[i]=='#'){ //特殊字符
			f1=true;
		}
		if('0'<=s[i] && '9'>=s[i]){ //数字
			f2=true;
		}
	}
	if(f1 && f2 && lon>=8 && lon<=16){ //都符合条件
		return true;
	}
	else{
		return false;
	}
}
int main(){
	for(int i=0;i<s.size();i++){ //枚举起点和终点
		for(int j=i+1;j<s.size();j++){
			if(check(i,j)){
				ans++;
			}
		}
	}
	cout<<ans; //输出
	return 0;
}
```

---

## 作者：wht_1218 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10906)

## 前情提要（摘自百度）：

### $1.$`substr()`：
`basic_string substr(size_type _Off = 0,size_type _Count = npos) const;
`

参数：   
`_Off`：所需的子字符串的起始位置。字符串中第一个字符的索引为 $0$，默认值为 $0$。   
`_Count`：复制的字符数目。   
返回值：一个子字符串，从其指定的位置开始

### $2.$`isdigit()`：

若传入的参数 `c` 为阿拉伯数字字符 `0~9`，则返回非 $0$ 值，否则返回 $0$。

`isupper()` 与 `islower()` 同理，判断大小写字母。

---

这一题可以当做一道编程题去做。

枚举子串的端点，首先判断长度，然后用前面的一些函数判断是否有至少 $1$ 个数字和 $1$ 个符号。

符号肯定不是数字、大写字母、小写字母，所以依此证据来判断。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){ 
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	string s;cin>>s;
	int ans=0;
	for(int i=0;i<s.size();++i){
		for(int j=i+1;j<s.size();++j){
			string k=s.substr(i,j-i);
			if(k.size()<8||k.size()>16)continue;
			bool f1=0,f2=0;
			for(int l=0;l<k.size();++l){
				if(isdigit(k[l]))f1=1;
				if(!(isdigit(k[l])||isupper(k[l])||islower(k[l])))f2=1;
			}if(f1&&f2){
				ans++;
			}
		}
	}cout<<ans;
	return 0;
}
```

将题目中的字符串输入进去，可以得知答案为 $400$，所以输出 $400$ 即可。

附这 $400$ 个串（让程序输出的，怎么可能是手打的）：

```
kfdhtshmrw4nxg#
kfdhtshmrw4nxg#f
fdhtshmrw4nxg#
fdhtshmrw4nxg#f
fdhtshmrw4nxg#f4
dhtshmrw4nxg#
dhtshmrw4nxg#f
dhtshmrw4nxg#f4
dhtshmrw4nxg#f44
htshmrw4nxg#
htshmrw4nxg#f
htshmrw4nxg#f4
htshmrw4nxg#f44
htshmrw4nxg#f44e
tshmrw4nxg#
tshmrw4nxg#f
tshmrw4nxg#f4
tshmrw4nxg#f44
tshmrw4nxg#f44e
tshmrw4nxg#f44eh
shmrw4nxg#
shmrw4nxg#f
shmrw4nxg#f4
shmrw4nxg#f44
shmrw4nxg#f44e
shmrw4nxg#f44eh
shmrw4nxg#f44ehl
hmrw4nxg#
hmrw4nxg#f
hmrw4nxg#f4
hmrw4nxg#f44
hmrw4nxg#f44e
hmrw4nxg#f44eh
hmrw4nxg#f44ehl
hmrw4nxg#f44ehlb
mrw4nxg#
mrw4nxg#f
mrw4nxg#f4
mrw4nxg#f44
mrw4nxg#f44e
mrw4nxg#f44eh
mrw4nxg#f44ehl
mrw4nxg#f44ehlb
mrw4nxg#f44ehlbn
rw4nxg#f
rw4nxg#f4
rw4nxg#f44
rw4nxg#f44e
rw4nxg#f44eh
rw4nxg#f44ehl
rw4nxg#f44ehlb
rw4nxg#f44ehlbn
rw4nxg#f44ehlbn3
w4nxg#f4
w4nxg#f44
w4nxg#f44e
w4nxg#f44eh
w4nxg#f44ehl
w4nxg#f44ehlb
w4nxg#f44ehlbn
w4nxg#f44ehlbn3
w4nxg#f44ehlbn33
4nxg#f44
4nxg#f44e
4nxg#f44eh
4nxg#f44ehl
4nxg#f44ehlb
4nxg#f44ehlbn
4nxg#f44ehlbn3
4nxg#f44ehlbn33
4nxg#f44ehlbn33c
nxg#f44e
nxg#f44eh
nxg#f44ehl
nxg#f44ehlb
nxg#f44ehlbn
nxg#f44ehlbn3
nxg#f44ehlbn33
nxg#f44ehlbn33c
nxg#f44ehlbn33cc
xg#f44eh
xg#f44ehl
xg#f44ehlb
xg#f44ehlbn
xg#f44ehlbn3
xg#f44ehlbn33
xg#f44ehlbn33c
xg#f44ehlbn33cc
xg#f44ehlbn33cct
g#f44ehl
g#f44ehlb
g#f44ehlbn
g#f44ehlbn3
g#f44ehlbn33
g#f44ehlbn33c
g#f44ehlbn33cc
g#f44ehlbn33cct
g#f44ehlbn33ccto
#f44ehlb
#f44ehlbn
#f44ehlbn3
#f44ehlbn33
#f44ehlbn33c
#f44ehlbn33cc
#f44ehlbn33cct
#f44ehlbn33ccto
#f44ehlbn33ccto#
f44ehlbn33ccto#
f44ehlbn33ccto#m
44ehlbn33ccto#
44ehlbn33ccto#m
44ehlbn33ccto#mw
4ehlbn33ccto#
4ehlbn33ccto#m
4ehlbn33ccto#mw
4ehlbn33ccto#mwf
ehlbn33ccto#
ehlbn33ccto#m
ehlbn33ccto#mw
ehlbn33ccto#mwf
ehlbn33ccto#mwfn
hlbn33ccto#
hlbn33ccto#m
hlbn33ccto#mw
hlbn33ccto#mwf
hlbn33ccto#mwfn
hlbn33ccto#mwfn2
lbn33ccto#
lbn33ccto#m
lbn33ccto#mw
lbn33ccto#mwf
lbn33ccto#mwfn
lbn33ccto#mwfn2
lbn33ccto#mwfn2w
bn33ccto#
bn33ccto#m
bn33ccto#mw
bn33ccto#mwf
bn33ccto#mwfn
bn33ccto#mwfn2
bn33ccto#mwfn2w
bn33ccto#mwfn2wa
n33ccto#
n33ccto#m
n33ccto#mw
n33ccto#mwf
n33ccto#mwfn
n33ccto#mwfn2
n33ccto#mwfn2w
n33ccto#mwfn2wa
n33ccto#mwfn2wae
33ccto#m
33ccto#mw
33ccto#mwf
33ccto#mwfn
33ccto#mwfn2
33ccto#mwfn2w
33ccto#mwfn2wa
33ccto#mwfn2wae
33ccto#mwfn2waeb
3ccto#mw
3ccto#mwf
3ccto#mwfn
3ccto#mwfn2
3ccto#mwfn2w
3ccto#mwfn2wa
3ccto#mwfn2wae
3ccto#mwfn2waeb
3ccto#mwfn2waebr
ccto#mwfn2
ccto#mwfn2w
ccto#mwfn2wa
ccto#mwfn2wae
ccto#mwfn2waeb
ccto#mwfn2waebr
ccto#mwfn2waebry
cto#mwfn2
cto#mwfn2w
cto#mwfn2wa
cto#mwfn2wae
cto#mwfn2waeb
cto#mwfn2waebr
cto#mwfn2waebry
cto#mwfn2waebry#
to#mwfn2
to#mwfn2w
to#mwfn2wa
to#mwfn2wae
to#mwfn2waeb
to#mwfn2waebr
to#mwfn2waebry
to#mwfn2waebry#
to#mwfn2waebry#3
o#mwfn2w
o#mwfn2wa
o#mwfn2wae
o#mwfn2waeb
o#mwfn2waebr
o#mwfn2waebry
o#mwfn2waebry#
o#mwfn2waebry#3
o#mwfn2waebry#3q
#mwfn2wa
#mwfn2wae
#mwfn2waeb
#mwfn2waebr
#mwfn2waebry
#mwfn2waebry#
#mwfn2waebry#3
#mwfn2waebry#3q
#mwfn2waebry#3qd
mwfn2waebry#
mwfn2waebry#3
mwfn2waebry#3q
mwfn2waebry#3qd
mwfn2waebry#3qd1
wfn2waebry#
wfn2waebry#3
wfn2waebry#3q
wfn2waebry#3qd
wfn2waebry#3qd1
wfn2waebry#3qd1u
fn2waebry#
fn2waebry#3
fn2waebry#3q
fn2waebry#3qd
fn2waebry#3qd1
fn2waebry#3qd1u
fn2waebry#3qd1ub
n2waebry#
n2waebry#3
n2waebry#3q
n2waebry#3qd
n2waebry#3qd1
n2waebry#3qd1u
n2waebry#3qd1ub
n2waebry#3qd1ubw
2waebry#
2waebry#3
2waebry#3q
2waebry#3qd
2waebry#3qd1
2waebry#3qd1u
2waebry#3qd1ub
2waebry#3qd1ubw
2waebry#3qd1ubwy
waebry#3
waebry#3q
waebry#3qd
waebry#3qd1
waebry#3qd1u
waebry#3qd1ub
waebry#3qd1ubw
waebry#3qd1ubwy
waebry#3qd1ubwyh
aebry#3q
aebry#3qd
aebry#3qd1
aebry#3qd1u
aebry#3qd1ub
aebry#3qd1ubw
aebry#3qd1ubwy
aebry#3qd1ubwyh
aebry#3qd1ubwyhc
ebry#3qd
ebry#3qd1
ebry#3qd1u
ebry#3qd1ub
ebry#3qd1ubw
ebry#3qd1ubwy
ebry#3qd1ubwyh
ebry#3qd1ubwyhc
ebry#3qd1ubwyhcy
bry#3qd1
bry#3qd1u
bry#3qd1ub
bry#3qd1ubw
bry#3qd1ubwy
bry#3qd1ubwyh
bry#3qd1ubwyhc
bry#3qd1ubwyhcy
bry#3qd1ubwyhcyu
ry#3qd1u
ry#3qd1ub
ry#3qd1ubw
ry#3qd1ubwy
ry#3qd1ubwyh
ry#3qd1ubwyhc
ry#3qd1ubwyhcy
ry#3qd1ubwyhcyu
ry#3qd1ubwyhcyua
y#3qd1ub
y#3qd1ubw
y#3qd1ubwy
y#3qd1ubwyh
y#3qd1ubwyhc
y#3qd1ubwyhcy
y#3qd1ubwyhcyu
y#3qd1ubwyhcyua
y#3qd1ubwyhcyuav
#3qd1ubw
#3qd1ubwy
#3qd1ubwyh
#3qd1ubwyhc
#3qd1ubwyhcy
#3qd1ubwyhcyu
#3qd1ubwyhcyua
#3qd1ubwyhcyuav
#3qd1ubwyhcyuavu
1ubwyhcyuavuajb#
b#vyecsycuzsmwp3
#vyecsycuzsmwp3
#vyecsycuzsmwp31
ycuzsmwp31ipzah#
cuzsmwp31ipzah#
cuzsmwp31ipzah#c
uzsmwp31ipzah#
uzsmwp31ipzah#c
uzsmwp31ipzah#ca
zsmwp31ipzah#
zsmwp31ipzah#c
zsmwp31ipzah#ca
zsmwp31ipzah#cat
smwp31ipzah#
smwp31ipzah#c
smwp31ipzah#ca
smwp31ipzah#cat
smwp31ipzah#cata
mwp31ipzah#
mwp31ipzah#c
mwp31ipzah#ca
mwp31ipzah#cat
mwp31ipzah#cata
mwp31ipzah#catat
wp31ipzah#
wp31ipzah#c
wp31ipzah#ca
wp31ipzah#cat
wp31ipzah#cata
wp31ipzah#catat
wp31ipzah#catatj
p31ipzah#
p31ipzah#c
p31ipzah#ca
p31ipzah#cat
p31ipzah#cata
p31ipzah#catat
p31ipzah#catatj
p31ipzah#catatja
31ipzah#
31ipzah#c
31ipzah#ca
31ipzah#cat
31ipzah#cata
31ipzah#catat
31ipzah#catatj
31ipzah#catatja
31ipzah#catatja3
1ipzah#c
1ipzah#ca
1ipzah#cat
1ipzah#cata
1ipzah#catat
1ipzah#catatj
1ipzah#catatja
1ipzah#catatja3
1ipzah#catatja3k
ipzah#catatja3
ipzah#catatja3k
ipzah#catatja3ka
pzah#catatja3
pzah#catatja3k
pzah#catatja3ka
pzah#catatja3kaq
zah#catatja3
zah#catatja3k
zah#catatja3ka
zah#catatja3kaq
zah#catatja3kaqb
ah#catatja3
ah#catatja3k
ah#catatja3ka
ah#catatja3kaq
ah#catatja3kaqb
ah#catatja3kaqbc
h#catatja3
h#catatja3k
h#catatja3ka
h#catatja3kaq
h#catatja3kaqb
h#catatja3kaqbc
h#catatja3kaqbcs
#catatja3
#catatja3k
#catatja3ka
#catatja3kaq
#catatja3kaqb
#catatja3kaqbc
#catatja3kaqbcs
#catatja3kaqbcss
```

---


# 不等关系 加强版

## 题目背景

本题是[不等关系](https://loj.ac/p/575)的加强版，建议大家先做原题后再来挑战加强版。

## 题目描述

对于一个字符串 $s_1,s_2,\cdots ,s_n$，仅包含 `<` 和 `>` 两种字符。

设 $f(s)$ 为「使得 $p_i<p_{i+1}$ 当且仅当 $s_i$ 为 `<` 的排列 $p_1,p_2,\cdots ,p_{n+1}$」的数量。

现在请你求出，对于所有 $2^n$ 种长度为 $n$ 的字符串 $s$，$f(s)$ 之和是多少。

由于答案可能有点大，因此你只需要输出它对 $998244353$ 取模的结果。

## 说明/提示

### 样例解释

对于字符串 $s1=$ `<`，有且仅有一个排列 $(1,2)$ 满足要求，即 $f(s1)=1$。

对于字符串 $s2=$ `>`，有且仅有一个排列 $(2,1)$ 满足要求，即 $f(s2)=1$。

故答案即为 $f(s1)+f(s2)=2$。

### 数据范围

| 测试点编号 | $n=$ |
| :----------: | :----------: |
| $1$ | $1$ |
| $2$ | $2$ |
| $3$ | $3$ |
| $4$ | $5$ |
| $5$ | $10$ |
| $6$ | $15$ |
| $7$ | $20$ |
| $8$ | $30$ |
| $9$ | $50$ |
| $10$ | $100$ |

对于所有数据，保证 $1\le n\le 100$。

## 样例 #1

### 输入

```
1```

### 输出

```
2```

# 题解

## 作者：ikunTLE (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P11075)

### 思路

每一个排列方式 $p$ 仅有唯一对应的字符串 $s$，故答案为 $\prod\limits_{i=1}^{n+1}i$，即 $(n+1)!$。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}

int main(){
	int n=read();
	long long ans=1;
	for(int i=1;i<=n+1;++i)
		ans=ans*i%998244353;
	cout<<ans;
	return 0;
}
```

---

## 作者：Register_int (赞：5)

每个排列只能对应一个 $s$，所以答案为排列总数，即 $(n+1)!$。

上次看到这么难绷的，还是求字符串所有本质不同子串的出现次数总和。

---

## 作者：cff_0102 (赞：4)

你会发现一个事实，就是对于每个排列，它对应的 $s$ 是唯一的，且每个排列都能对应到一个 $s$。

同时，题目要我们求对于所有 $s$ 能够对应到的排列数量。

那答案不就是排列的数量吗？

$s$ 的长度为 $n$，所以排列有 $n+1$ 个数，输出 $(n+1)!\bmod998244353$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	long long s=1;
	while(n--){
		s*=(n+2);
		s%=998244353;
	}
	cout<<s;
	return 0;
}
```

另外本题所说的原题“不等关系”疑似为 [P2401](/problem/P2401)，但是那题叫做“不等数列”，而且比本题难。

---

## 作者：dehsirehC (赞：4)

~~这是一道将近两年前被出出来的远古好题。~~

容易发现对于每一个长为 $n+1$ 的排列 $p$ ，有且仅有一个字符串 $s$ 符合要求。

故答案即为 $(n+1)!$ ，总时间复杂度 $O(n)$ 。

~~如果你使用了复杂度更高的做法通过了此题，欢迎联系我。~~

---

## 作者：Redshift_Shine (赞：1)

题目出现的位置、数据范围和题面本身都会让人感到困惑。如果人类没有逆向思维，那么这题将会是黑题。

题面言曰：

> 设 $f(s)$ 为「使得 $p_i<p_{i+1}$ 当且仅当 $s_i$ 为 `<` 的排列 $p_1,p_2,\cdots ,p_{n+1}$」的数量。

于是自然想到要找到一种快速求出 $f(s)$ 的方法。然而，因为这题存在弱化版，所以这是不可行的。然而题目又说：

> 现在请你求出，对于所有 $2^n$ 种长度为 $n$ 的字符串 $s$，$f(s)$ 之和是多少。

于是有些人直接放弃了这题（比如我），但另一些人会敏锐地发现可以拆贡献。

我们将目光从 $f(s)$ 移向 $p$，并考虑每个 $p$ 对答案做出的贡献。

不难发现，根据题目定义，一个 $s$ 不一定对应唯一一个 $p$，但一个 $p$ 一定对应唯一一个 $s$。而对于 $s$，任何能在本题范围内生成的 $s$ 都在答案统计范围内，所以可以直接统计本质不同的 $p$ 的数量，即 $(n+1)!$。

时间复杂度 $O(n)$。

```c++
#include <cstdio>
using namespace std;
const int N = 1e5 + 10, mod = 998244353;
int n, res = 1;
int main()
{
	scanf("%d", &n);
	n++;
	for (int i = 2; i <= n; i++)
		res = 1ll * res * i % mod;
	printf("%d\n", res);
}
```

---

## 作者：mediocre_ (赞：1)

很好的诈骗题。

题目要求构造一个有 $n+1$ 个数的排列。

首先可以想到当 $s_i$ 为`<`时排列第一个数如果是 $1$ 那么后面就有 $n!$ 种排列，第一个数如果时 $2$ 那么后面就有 $(n-1)\times(n-1)!$ 种排列，以此列推。

当 $s_i$ 为`>`情况数量也是一样的，那我们就可以列出式子：

$2\times[n!+(n-1)\times(n-1)!+(n-2)\times(n-1)!+...+1\times(n-1)!]$

我们可以提取公因式 $(n-1)!$ ，得：

$2\times[(n+n-1+n-2+...+1)\times(n-1)!]$

利用求和公式，得：

$2\times\frac{(n+1)n}{2}\times(n-1)!$

最后合并同类相，得：

$(n^2+n)(n-1)!$

好的已经有了答案那么就写代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    long long n, ans = 1;
    scanf("%lld", &n);
    for (int i = 2; i <= n - 1; ++i)
        ans *= i, ans %= 998244353;
    printf("%lld", ans * (n * n + n) % 998244353);
    return 0;
}
```

一定要记得开`long long`啊喂QAQ。

---

## 作者：鲤鱼江 (赞：1)

诈骗题，秒了。

可以明显地发现一个排列可以唯一地对应一种 $s$ 序列，所以答案是排列总数 $(n+1)!$。

证明：

+ 一个排列有唯一对应的序列 $s$：因为排列确定后相邻两项的大小关系也随之确定。
+ 所有序列 $s$ 均被纳入计算：由题意得。

所以综上，答案是长度为 $n+1$ 的排列的总数，也就是 $(n+1)!$ 了。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int mod=998244353;
struct modint {
    int val;
    static int norm(const int& x) { return x < 0 ? x + mod : x; }
    modint() : val(0) {}
    modint(const int& m) : val(norm(m)) {}
    modint& operator*=(const modint& o) { return val = static_cast<int>(1ll * val * o.val % mod), *this; }
    modint operator*(const modint& o) const { return modint(*this) *= o; }
}frac[110];
int n;

int main(){
	cin>>n;++n;frac[0]=1;
	for(int i=1;i<=n;++i) frac[i]=frac[i-1]*i;
	cout<<frac[n].val<<endl;
	return 0;
}
```

---

## 作者：2huk (赞：0)

对于任意一个 $n + 1$ 的排列 $p$，不难发现有且仅有一个 $s$ 是满足 $p$ 被贡献入 $f(s)$ 的计算的。例如 $p=[1,3,2]$ 仅对应一个 $s = [\texttt <,\texttt>]$。

也就是如果我们从贡献的角度考虑，每个排列都被贡献进了答案恰好 $1$ 次。而排列总共有 $(n+1)!$ 个，每个贡献 $1$，所以答案为 $(n+1)!$。

```cpp
#include <bits/stdc++.h>

using namespace std;

signed main() {
	int n, res = 1;
	cin >> n;
	n ++ ;
	for (int i = 1; i <= n; ++ i ) res = 1ll * i * res % 998244353;
	cout << res;
	return 0;
}
```

---

## 作者：linjunye (赞：0)

数学题。

$f(s)$ 有什么特点呢？

我们发现似乎没什么特点，那么反过来想，既然 $f(s)$ 的计算与排列相关，那么，排列有什么特点呢？

还真有，每一个排列的大小关系都能表示**唯一**的一个字符串！

那么，也就是说，所有的 $f(s)$ 之和不就是排列的种数！

排列的种数不就很好算吗，这里有 $n$ 个比较符，那么也就有 $n+1$ 个数。

根据乘法原理，我们可得到 $n+1$ 个数共有 $(n+1)!$ 种排列方式。

$(n+1)!$ 可以用预处理，非常方便。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long//还是要注意的
using namespace std;
const int mod=998244353;
int n;
int fac[110];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	fac[0]=1;
	for(int i=1;i<=101;i++)fac[i]=fac[i-1]*i%mod;//100+1=101
	cin>>n;
	cout<<fac[n+1];
	return 0;
}

```

---

## 作者：Vct14 (赞：0)

符合对原神想象的幽默抽象题，同时也是这个蒟蒻第一次赛时从看压轴题到切掉只用了不到三分钟。

对于每一个排列 $p$，很明显地，都有唯一的串 $s$ 能够与之对应。因此所有 $f(s)$ 之和等于所有 $1$ 到 $n+1$ 的排列个数 $(n+1)!$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n;cin>>n;
	long long ans=1;
	for(int i=1; i<=n+1; i++) ans=(ans*i)%998244353;
	cout<<ans;
	return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P11075 题目](https://www.luogu.com.cn/problem/P11075)

### 解题思路
不难发现对于任何一个符合要求的排列 $p$，都会有且仅有一个长为 $n$ 的字符串与之对应，所以所有字符串 $s$ 的 $f(s)$ 之和即为排列的种数，即 $(n+1)!$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const long long p=998244353;
signed main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	int s=1;
	for(int i=2;i<=n+1;i++)
		s=s*i%p;
	cout<<s;
	return 0;
}
```

---

## 作者：suyi1111 (赞：0)

发现对于每个排列，总能找到一个仅含有 `>` 和 `<` 的字符串满足题目要求，所以答案即排列个数：

代码：
```
#include<bits/stdc++.h>
int main(){
	long long n,s=1;
	std::cin>>n;
	for(int i=1;i<=n+1;i++){
		s=s*i%998244353;
	}
	std::cout<<s;
	return 0;
}
```

---

## 作者：huanglihuan (赞：0)

诈骗第四题。

### 思路

对于每一个排列只有一个字符串 $s$ 可以符合构造，所以答案为 $(n + 1) !$。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 998244353;
int pre [101];
signed main ()
{
	int n;
	cin >> n;
	pre [1] = 1;
	for (int i = 2;i <= n + 1;i ++) pre [i] = (pre [i - 1] * i % mod + mod) % mod;// 诈骗
	cout << pre [n + 1];
	return 0;
}
```

---

## 作者：4041nofoundGeoge (赞：0)

## 题目大意
对于一个字符串 $s_1,s_2,\cdots ,s_n$，仅包含 `<` 和 `>` 两种字符。

设 $f(s)$ 为「使得 $p_i<p_{i+1}$ 当且仅当 $s_i$ 为 `<` 的排列 $p_1,p_2,\cdots ,p_{n+1}$」的数量。

现在请你求出，对于所有 $2^n$ 种长度为 $n$ 的字符串 $s$，$f(s)$ 之和是多少。

由于答案可能有点大，因此你只需要输出它对 $998244353$ 取模的结果。
## 思路
看起来说的很玄乎，但是仔细分析可以发现重点就在这句话：
> 设 $f(s)$ 为「使得 $p_i<p_{i+1}$ 当且仅当 $s_i$ 为 `<` 的**排列** $p_1,p_2,\cdots ,p_{n+1}$」的数量。

突破口就在**排列**两字。通过题面给的运算符共有 $n$ 个，对印的字符就有 $n+1$ 个。把 $n+1$ 个字符排列一下，即得到 $A^{n+1}_{n+1}$，换种写法即 $(n+1)!$。思路清晰，就可以写了。

## 坑点
千万要记得开 `long long` 并且还要模 $998244353$！

## 代码
我献上我丑陋的代码：

```cpp
//c++版本
#include<iostream>
using namespace std;
long long sum=1;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n+1;++i)sum=sum*i%998244353;
	printf("%d",sum);
	
}
```
java 代码：
```java
import java.util.Scanner;  
public class Main {  
    public static void main(String[] args) {  
        Scanner scanner = new Scanner(System.in);  
        int n = scanner.nextInt();  
        long sum = 1;   
        for (int i = 1; i <= n+1; ++i) {  
            sum = (sum * i) % 998244353;
        }  
          
        System.out.println(sum);  
        scanner.close(); 
    }  
}
```
python 代码：

```py
x=int(input(""))
sum=1
for i in range(1,x+2):
    sum=sum*i%998244353
print(sum)
```

---

## 作者：__RSDL__ (赞：0)

# 思路：  
很简单的白给题，看着没思路？仔细想一想，观察一些细节就会发现每一个 $s$ 只会有一个 $p$ 对应，由于是 $p_1$ 到 $p_{n+1}$，答案显而易见，就有 $(n+1)!$ 种。
# code:

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int a;
    cin>>a;
    long long sum = 1;
    for(int i = 1;i<=a+1;i++)
    {
        sum=sum*i;
        if(sum>=998244353)//不判断就炸了
        {
            sum=sum%998244353;
        }
    }
    cout <<sum<<endl;
    return 0;
}
```

---

## 作者：Amunet (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11075)

简单数学题。

对于每一个排列，很明显地，有且仅有一个字符串 $s$ 的能够与之对应，每一个排列的大小关系都能表示唯一的一个字符串。因此所有 $f(s)$ 之和等于所有 $1$ 到 $n + 1$ 的排列个数，那也就是 $(n + 1)!$ 种排列方式。

这样我们轻松愉悦的做出了这道压轴题，别忘了取模啊喂。

```
#include<bits/stdc++.h>
using namespace std;
long long n,cnt=1;
const int N=998244353;
int main(){
  	cin>>n;
	for(int i=1;i<=n+1;i++)cnt=(cnt*i)%N;
	cout<<cnt;
	return 0;
}
```

---

## 作者：VelvetChords (赞：0)

# P11075 不等关系 加强版
## 0.前言
因为本题解的作者在考场时急着补作业，所以喜提 10pts 好成绩。
## 1.分析
诈骗题的味道。

对于 $n+1$ 个元素的每一个排列 $p$，我们可以通过某种方式将其转换为一个串 $s$。这种转换是单一且确定的，因此每个排列对应一个唯一的串。因此所有 $f(s)$ 的总和确实等于所有从 1 到 $n+1$ 的排列个数 $(n+1)!$。

## 2.代码
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,f[200];
signed main()
{
	ios::sync_with_stdio(0);
	f[0]=1;
	for(int i=1;i<=101;i++)//n 最高为 100
        f[i]=f[i-1]*i%998244353;
	cin>>n;
	cout<<f[n+1];
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

## 题意回顾

求出对于 $ n $ 对相邻位置相对大小比较的限制，所有 $ 2^n $ 种限制下的的符合要求的排列总和。

限制长度不超过 $ 100 $。

## 分析

考虑统计有多少个排列，满足存在一个符合要求的相对大小比较限制，显然所有限制都要统计那就是所有排列都合法。

输出 $ (n+1)! $ 即可。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int mod = 998244353;
int n;
int getans(int x) {
    return (x == 0) ? 1 : ((long long)x * getans(x - 1) % mod);
}
int main() {
    cin >> n;
    cout << getans(n + 1) << endl;
    return 0;
}
```

---


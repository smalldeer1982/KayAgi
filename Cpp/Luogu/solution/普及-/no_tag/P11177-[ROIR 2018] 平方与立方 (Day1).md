# [ROIR 2018] 平方与立方 (Day1)

## 题目描述

**译自 ROI 2018 Regional. Day1 T2.** ***[Квадраты и кубы](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day1.pdf)***

数学家们研究了「自然数的平方的分布」与「自然数的立方的分布」之间的关系。

已知非负整数 $a,b,k$。考虑集合 $S=\{a,a+1,\ldots,b\}$，该集合的「$k$ 密度」表示的是 $T$ 中元素的个数，其中 $T=\{(x,y)|$ $x\in\mathbb{N},$ $y\in\mathbb{N},$ $x^2\in S,$ $y^3\in S,$ $|x^2 - y^3| ≤ k\}$。请求出 $S$ 的 $k$ 密度。



## 说明/提示

### 样例解释
- $x = 1, y = 1, |x^2 - y^3| = |1 - 1| = 0$;
- $x = 3, y = 2, |x^2 - y^3| = |9 - 8| = 1$;
- $x = 5, y = 3, |x^2 - y^3| = |25 - 27| = 2$.

### 数据范围

对于所有数据，$1 ≤ a ≤ b ≤ 10^{18},$ $0 ≤ k ≤ 10^{18}$.

|子任务编号|分值|$1 ≤ a ≤ b ≤ $|$k$|
|:-:|:-:|:-:|:-:|
|1|10|$1000$|$k = 0$|
|2|&nbsp;10&nbsp;|$10^{18}$|$k = 0$|
|3|15|$1000$|$0 ≤ k ≤ 10$|
|4|&nbsp;15&nbsp;|$10^6$|$0 ≤ k ≤ 10$|
|5|15|$10^9$|$0 ≤ k ≤ 10$|
|6|&nbsp;15&nbsp;|$10^9$|$0 ≤ k ≤ 10^9$|
|7|20|$10^{18}$|$0 ≤ k ≤ 10^{18}$|

## 样例 #1

### 输入

```
1
30
2```

### 输出

```
3```

# 题解

## 作者：Little_x_starTYJ (赞：10)

### 通俗题意
给你三个整数 $a, b, k$，需要你求出满足下列条件的不同的 $x, y$ 有多少对。
- $a\leq x^2, y^3 \leq b$。
- $|x^2 - y^3| \leq k$。
- $x, y$ 均为非负整数。

### 解题思路
注意到题目中一直在算平方和立方，所以可以猜测正确的时间复杂度应该是带有根号的。又观察到 $1\leq a \leq b \leq 10^{18}$，所以排除 $\mathcal{O}(\sqrt{n})$ 的算法，那么还有一种可能的时间复杂度就是 $\mathcal{O}(\sqrt[3]{n})$。

首先 $x, y$ 一定是在区间 $[\lceil\sqrt[3]{a}\rceil, \lfloor\sqrt[3]{b}\rfloor]$ 之间的。为什么要加上向上取整与向下取整呢？因为 $x, y$ 为整数，那么当 $y = \lfloor\sqrt[3]{a}\rfloor$ 时，$y^3 \leq a$，很明显在 $a$ 不是完全立方数时满足 $y^3 < a$，例如 $a = 3$ 时，$y = \lfloor\sqrt[3]{3}\rfloor = 1$，而 $y^3 = 1 < a$。

接着我们考虑在区间 $[\lceil\sqrt[3]{a}\rceil, \lfloor\sqrt[3]{b}\rfloor]$ 之间枚举 $y$。这时 $|x^2 - y^3| \leq k$ 就可以看成 $x^2$ 只能在 $[y^3 - k, y^3 + k]$ 中。那么当 $y^3 - k \geq 0$ 时，$x$ 的最小取值为 $\sqrt{y^3 - k}$，当 $y^3 - k < 0$ 时，我们让 $x = 0$。

所以，$x$ 所在的区间也就是 $[\sqrt{\max\{0, y^3 - k\}}, \sqrt{y^3 + k}]$。但是题目要求 $a\leq x^2 \leq b$，所以最终 $x$ 的取值范围就是 $[\sqrt{\max\{y^3 - k, a\}}, \sqrt{\min\{y^3 + k, b\}}]$。我们都知道 $l\sim r$ 之间的整数的个数为 $r - l + 1$，那么我们就可以解出这道题了。

算法总时间复杂度 $\mathcal{O}(\sqrt[3]{b - a})$。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int a, b, k, ans = 0;
	cin >> a >> b >> k;
	int l = ceil(cbrt(a)), r = cbrt(b);
	for (int y = l; y <= r; y++) {
		ans += floor(sqrt(min(y * y * y + k, b))) - ceil(sqrt(max(y * y * y - k, a))) + 1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：cff_0102 (赞：4)

### 题意简述：

求 $[a,b]$ 中有多少对 $(x,y)$ 使得 $x$ 是完全平方数，$y$ 是完全立方数，且 $|x-y|\le k$。

### 思路 $1$（$70pts$）：

将 $a$ 和 $b$ 之间所有立方数预处理出来，然后遍历 $a$ 和 $b$ 之间的所有平方数，利用 `lower_bound` 和 `upper_bound` 分别找到这个平方数 $\pm k$ 范围内最小和最大的立方数（实际上是最大的立方数的下一个数）的位置，相减之后加到答案中即可。

时间复杂度 $O(\sqrt n\log\sqrt[3]n)$，空间复杂度 $O(\sqrt[3]n)$，会超时。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int a,b,k;cin>>a>>b>>k;
	int sa=ceil(sqrt(a)),ca=ceil(cbrt(a)),sb=floor(sqrt(b)),cb=floor(cbrt(b));
	vector<int>c;
	for(int x=ca;x<=cb;x++)c.push_back(x*x*x);
	int ans=0;
	for(int x=sa;x<=sb;x++){
		int s=x*x;
		int l=lower_bound(c.begin(),c.end(),s-k)-c.begin();
		int r=upper_bound(c.begin(),c.end(),s+k)-c.begin();
		ans+=r-l;
	}
	cout<<ans;
	return 0;
}
```

### 思路 $2$（$70pts$）：

考虑优化。注意到要遍历所有的平方数要花的时间太多了，考虑存下所有平方数，再遍历所有立方数来计算答案。枚举的时间复杂度确实降了，但是别忘了还要考虑预处理的时间复杂度。在这种情况下，时间复杂度为 $O(\max(\sqrt n,\sqrt[3] n\log\sqrt n))$，空间复杂度 $O(\sqrt n)$，虽然确实快了，但仍然无法通过，且在数据过大的情况下显然会爆空间。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int a,b,k;cin>>a>>b>>k;
	int sa=ceil(sqrt(a)),ca=ceil(cbrt(a)),sb=floor(sqrt(b)),cb=floor(cbrt(b));
	vector<int>s;
	for(int x=sa;x<=sb;x++)s.push_back(x*x);
	int ans=0;
	for(int x=ca;x<=cb;x++){
		int c=x*x*x;
		int l=lower_bound(s.begin(),s.end(),c-k)-s.begin();
		int r=upper_bound(s.begin(),s.end(),c+k)-s.begin();
		ans+=r-l;
	}
	cout<<ans;
	return 0;
}
```

### 思路 $3$（$70pts$）：

注意到第一篇代码中的 `lower_bound` 和 `upper_bound` 作用分别是找到“第一个大于等于 $s-k$ 的立方数”和找到“最后一个小于等于 $s+k$ 的立方数”，然后再求它们之间平方数的个数。而实际上要求出这两个数之间的数的个数完全没必要去存下所有平方数。直接计算出 $l=\lceil\sqrt[3]{s-k}\rceil$ 和 $r=\lfloor\sqrt[3]{s+k}\rfloor$，答案显然就是 $r-l+1$，即 $[l,r]$ 之间的每个整数都能对应范围内的一个立方数。这样，就可以用 $O(\sqrt n)$ 的时间解决这个问题（这里认为 `cbrt` 和 `sqrt` 是 $O(1)$ 的）。不过，即使洛谷评测机确实测出过一秒 $10^9$ 次计算的超快速度，但别忘了这道题在洛谷的时间限制是 $200$ 毫秒（可原题是 $1$ 秒诶！），因此仍然无法通过。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int a,b,k;cin>>a>>b>>k;
	int sa=ceil(sqrt(a)),ca=ceil(cbrt(a)),sb=floor(sqrt(b)),cb=floor(cbrt(b));
	int ans=0;
	for(int x=sa;x<=sb;x++){
		int s=x*x;
		int cl=ceil(cbrt((long double)max(s-k,a)));
		int cr=floor(cbrt((long double)min(s+k,b)));
		ans+=cr-cl+1;
	}
	cout<<ans;
	return 0;
}
```

### 思路 $4$（$100pts$）：

考虑思路 $2$ 对思路 $1$ 进行的优化，不难发现思路 $3$ 也可以进行类似的优化。把枚举平方数改成枚举立方数，时间复杂度就能降到 $O(\sqrt[3]n)$。这样，即使最慢的点也能在 $6$ 毫秒的时间内跑完。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int a,b,k;cin>>a>>b>>k;
	int sa=ceil(sqrt(a)),ca=ceil(cbrt(a)),sb=floor(sqrt(b)),cb=floor(cbrt(b));
	int ans=0;
	for(int x=ca;x<=cb;x++){
		int c=x*x*x;
		int sl=ceil(sqrt(max(c-k,a)));
		int sr=floor(sqrt(min(c+k,b)));
		ans+=sr-sl+1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：liaoxingrui (赞：3)

## Content

$$S = \{ a , a + 1 , \ldots , b \}$$

$$T=\{ (x,y) | x \in \mathbb{N} , y \in \mathbb{N} , x^2 \in S , y^3 \in S , | x^2 - y^3 | \le k \}$$

求 $T$ 的元素个数。

## Solution

因为 $1 \le a , b \le 10^{18}$，所以枚举平方肯定会超时，就只能枚举立方了。

枚举是找在 $i^3 - k$ 到 $i^3 + k$ 内所有完全平方数，因为这样算出来，一定保证 $| x^2 - y^3 | \le k$。枚举时要注意查找范围不能在 $a$ 到 $b$ 以外，且下界要向上取整。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k;
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	long long a=1,ans=0;
	while(a*a*a<n)
		a++;
	for(long long i=a;i*i*i<=m;i++)
		ans+=sqrt(min(m,i*i*i+k))-ceil(sqrt(max(n,i*i*i-k)))+1;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Aventurine_stone (赞：2)

## 1. 题目分析
对于这道题，除了暴力枚举，好像就没有其他方法了吧，~~反正我是想不出来。~~
## 2. 题目做法
首先考虑从 $a$ 到 $b$ 依次枚举，枚举次数高达 $10^{18}$，肯定过不了。  
然后考虑枚举平方数，枚举次数也有 $10^9$，题目的时间限制明显就是卡这种做法的，应该是过不了的。  
最后，我们可以枚举立方数，枚举次数仅有 $10^6$，对于每一个立方数，若它在 $a$ 和 $b$ 之间，我们便算出比它最多小 $k$ 且大于等于 $a$ 的平方数，和比它最多大 $k$ 且小于等于 $b$ 的平方数，这样每次枚举就可以 $O(1)$ 累加答案了。时间复杂度完全可以通过此题。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
inline long long read()
{
	long long x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
long long a,b,k,t=1,tt=1,l,ll,r,rr,sum;
int main()
{
	a=read(),b=read(),k=read();
	while(tt<a)
		t++,tt=t*t*t;
	while(tt<=b)
	{
		l=max(a,tt-k),r=min(b,tt+k);
		ll=sqrt(l),rr=sqrt(r);
		if(ll*ll<l)//特判，防止答案计算过多 
			ll++;
		if(ll<=rr)
			sum+=rr-ll+1;
		t++,tt=t*t*t;
	}
	printf("%lld",sum);
	return 0;
}
```

---

## 作者：lichenxi111 (赞：1)

为纪念我因精度误差而调了一个橙题一个多小时，有了这篇题解。

## 题意

给出 $a,b,k$，找出数对 $(x,y)$，使得，$x^2\in \left[a,b\right],$ $y^3\in \left[a,b\right],$ $|x^2 - y^3| \le k$。问有多少个这样的数对。

## 思路

注意到 $1 \le a \le b \le 10 ^ {18}$，枚举完全平方数肯定行不通，发现可以枚举完全立方数，最多只有 $10 ^ 6$ 个，对于每个在 $\left[a,b\right]$ 内的完全立方数，可以 $O(1)$ 地找到与它相距不超过 $k$ 且也在 $\left[a,b\right]$ 内的完全平方数，并统计个数。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a,b,k;
int f[1100000],cur;
void init()
{
	for(int i = 1;i * i * i <= b;i++)
	{
		f[++cur] = i * i * i;
	}
}
signed main()
{
	cin >> a;
	cin >> b;
	cin >> k;
	init();
	int ans = 0;
	for(int i = 1;i <= cur;i++)
	{
		if(f[i] < a || f[i] > b)
		{
			continue;
		}
		int x = max(f[i] - k,a),y = min(f[i] + k,b);
		if((int)sqrt(x) * (int)sqrt(x) == x)
		{
			ans += (int)sqrtl(y) - (int)sqrtl(x) + 1;
		}
		else
		{
			ans += (int)sqrtl(y) - (int)sqrtl(x);
		}//这里要使用 sqrtl 函数，不然会有精度误差。
	}
	cout << ans;
	return 0;
}
```

---

## 作者：NTT__int128 (赞：0)

# P11177 [ROIR 2018 Day1] 平方与立方 题解
我们知道，$a\sim b$ 中的立方数是很少的。考虑枚举 $y$。

此时 $\max(a,y^3-k)\le x^2\le \min(b,y^3+k)$。发现此时 $x$ 有 $\lfloor\sqrt{\min(b,y^3+k)} \rfloor-\lceil\sqrt{\max(a,y^3-k)}\rceil+1$，记录一下即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll a,b,k,c;
int main(){
    cin>>a>>b>>k;
    for(ll i=1;i*i*i<=b;i++)
        if(i*i*i>=a){
            ll l=i*i*i-k,r=i*i*i+k;
            l=max(a,l),r=min(b,r);
            c+=floor(sqrt(r))-ceil(sqrt(l))+1;
        }
    cout<<c;
    return 0;
}
```

---

## 作者：Crasole (赞：0)

## 题意

求满足如下条件的 $(x, y)$ 的对数。

- $a \le x ^ 2, y ^ 3 \le b$。

- $x, y$ 是自然数。

- $x ^ 2$ 与 $y ^ 2$ 相差不超过 $k$。

## 思路

首先可以得到 $x$ 和 $y$ 的范围，注意$x$ 和 $y$ 都是自然数。

- $\lceil \sqrt{a} \rceil \le x \le \lfloor \sqrt{b} \rfloor$

- $\lceil \sqrt[3]{a} \rceil \le y \le \lfloor \sqrt[3]{b} \rfloor$

注意到 $b \le 10 ^ {18}$，也就是说 $\sqrt[3]{b} \le 10 ^ 6$。所以 $y$ 的范围是最大是 $1 \le y \le 10 ^ 6$。

那我们就可以枚举 $y$，再算出 $x$ 的个数。

对于每个 $y$，令 $t$ 为 $y ^ 3$。所以 $x ^ 2$ 最小为 $\max(0, t - k)$，最大为 $t + k$。即：

$$\max(0, t - k) \le x ^ 2 \le t + k$$ 

开方，同时要注意 $x$ 是自然数，要取整：

$$ \lceil \sqrt{\max(0, t - k)} \rceil \le x \le \lfloor \sqrt{t + k} \rfloor $$

但是不要忘了 $x$ 原来的范围：
$\lceil \sqrt{a} \rceil \le x \le \lfloor \sqrt{b} \rfloor$

设 $p1 = \lceil \sqrt{a} \rceil, p2 = \lfloor \sqrt{b} \rfloor, k1 = \lceil \sqrt{\max(0, t - k)} \rceil, k2 = \lfloor \sqrt{t + k} \rfloor$。

则 $x$ 的取值范围为 $\min(k2, p2) \le x \le \max(k1, p1)$。

所以满足要求的 $x$ 的数量为 $\min(k2, p2) - \max(k1, p1) + 1$。

但是 $\max(k1, p1)$ 可能大于 $\min(k2, p2)$，就导致会算出来负数，还要和 $0$ 比较，所以满足要求的 $x$ 的数量应该为:

$$\max(0, \min(k2, p2) - \max(k1, p1) + 1)$$

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long//要开 long long
using namespace std;
int a, b, k;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(NULL), cout.tie(NULL);
	cin >> a >> b >> k;
    //cbrt(x)可以求x的立方根
	int t1 = ceil(cbrt(1.0 * a)), t2 = cbrt(b);//y 的范围
	int p1 = ceil(sqrt(1.0 * a)), p2 = sqrt(b);//x 的范围
	int ans = 0;
	for (int i = t1; i <= t2; ++i) {//枚举y
		int t = i * i * i;
        //求出满足条件的x的数量，计算方法前面已经讲过了
        int k1 = 0;
		if(t - k > 0) k1 = ceil(sqrt(1.0 * (t - k)));
		int k2 = sqrt(t + k);
		ans += max(0ll, min(k2, p2) - max(k1, p1) + 1);
	}
	cout << ans << endl;
	return 0;
}
```

---


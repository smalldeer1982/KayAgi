# [ROIR 2018] 删除数字 (Day2)

## 题目描述

**译自 ROI 2018 Regional. Day2 T1.** ***[Удаление чисел](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day2.pdf)***

给定一个从 $1$ 到 $n$ 的自然数序列和一个自然数 $k$。通过一个或多个操作删除序列中的数字。在每一个操作中，按升序查看剩余的数字，每隔 $k$ 个数字删除一个。如果在某一个操作之后剩余的数字少于 $k$ 个，则删除过程结束。

需要确定在第几个操作删除数字 $n$，或者判断在删除过程结束前数字 $n$ 是否不会被删除。

例如，设 $n=13, k=2$。

- 第一个操作将删除数字 $2, 4, 6, 8, 10, 12$，剩下的数字是 $1, 3, 5, 7, 9, 11, 13$。
- 第二个操作将删除数字 $3, 7, 11$，剩下的数字是 $1, 5, 9, 13$。
- 第三个操作将删除数字 $5, 13$，剩下的数字是 $1, 9$。
- 第四个操作将删除数字 $9$，剩下的数字是 $1$。由于只剩下一个数字，删除过程结束。

因此，数字 $13$ 将在第三个操作被删除。

需要编写一个程序，根据给定的 $n$ 和 $k$ 确定数字 $n$ 在第几个操作被删除。

## 说明/提示

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | $n$ 的限制 | $k$ 的限制 |
| :-: | :-: | :-: | :-: |
| $1$ | $16$ | $3 \leq n \leq 1000$ | $k=2$ | 
| $2$ | $10$ | $3 \leq n \leq 10^{18}$ | $k=2$ |
| $3$ | $14$ | $3 \leq n \leq 1000$ | $2 \leq k \leq 100, k < n$ |
| $4$ | $20$ | $3 \leq n \leq 10^{6}$ | $2 \leq k \leq 100, k < n$ |
| $5$ | $40$ | $3 \leq n \leq 10^{18}$ | $2 \leq k \leq 100, k < n$ |

## 样例 #1

### 输入

```
13
2```

### 输出

```
3```

# 题解

## 作者：zhujiangyuan (赞：7)

这不就是 [P9748 [CSP-J 2023] 小苹果](https://www.luogu.com.cn/problem/P9748) 的第 $2$ 问？

考虑第 $n$ 项被删除时一定满足当前 $n \bmod k=0$，所以我们模拟删除数字的过程，每次删掉 $\left\lfloor\dfrac{n}{k}\right\rfloor$ 个数，当 $n \bmod k=0$ 时输出删除次数。

**该题并不会存在 $n$ 不被删除的情况，所以并不会输出 $0$。**

证明：对于数字 $i$，若 $i<k$，$i$ 必然不会删除，但是只有当前数字个数小于 $k$ 时才停止，所以 $i\ge k$ 的数必然被删除。又因为题面上规定 $k<n$，所以 $n$ 一定会被删除。

关于复杂度：推一下式子能够得到删除次数 $T>\log_{\frac{k}{k-1}}\frac{n}{k}$ 时，一定会停止删除。当 $n=10^{18}$ 且 $k=100$ 时，这个值大概是 $3665$，足以通过此题。

```cpp
cin >> n >> k;
while (n) {
    cnt ++;
    if (n % k == 0) return cout << cnt << '\n', 0;
    n -= n / k;
}
```

---

## 作者：Little_x_starTYJ (赞：7)

### 解题思路
首先，当 $n$ 会被删除的时候一定满足 $n \bmod k = 0$。所以我们将 $n$ 减去 $\frac{n}{k}$，也就是减去每一次操作所减少的数的个数。当 $n \bmod k = 0$ 时，我们直接输出当前的操作次数即可。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	long long n, k;
	cin >> n >> k;
	int cnt = 0;
	while (n >= k) {
		cnt++;
		if (n % k == 0) {
			cout << cnt;
			return 0;
		}
		n -= n / k;
	}
	cout << 0;
	return 0;
}
```

---

## 作者：liaoxingrui (赞：3)

## Content

给你一个长度为 $n$ 的序列和一个数 $k$。在每一次操作中，每隔 $k$ 个数字便删除一个数，如果在某次操作结束后，剩余数的个数小于 $k$，则结束操作。

## Solution

跟[小苹果](https://www.luogu.com.cn/problem/P9748)几乎一样，记一下这是第几次操作，减去每次操作删除的数的数量，得出 $n$ 在第几个位置，判断一下 $n$ 是否会在此次操作中删除即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum;
long long n,k;
int main(){
	cin>>n>>k;
	while(n&&++sum&&n>=k){
		if(n%k==0){
			cout<<sum;
			return 0;
		}
		n-=n/k;
	}
	putchar('0');
	return 0;
}
```

---

## 作者：__DayLight__ (赞：2)

## 前言
举个例子，下面会用到：

- 假设 $n=10$，$k=4$，操作如下：

```
原序列 1 2 3 4 5 6 7 8 9 10
1.剩下 1 2 3 5 6 7 9 10，删除 4 8。
2.剩下 1 2 3 6 7 9，删除 5 10。
3.剩下 1 2 3 7 9，删除 6。
4.剩下 1 2 3 9，删除 7。
5.剩下 1 2 3，删除 9。
```
## 思路

- 如何判断 $n$ 会不会**被删除**？

  从上面的过程中可以发现，删除是从第 $k$ 个数开始，导致只有 $1 \sim k-1$ **不会**被删除，也就是 $k \sim n$ **必定**被删除，该种情况不需要判断，[试验记录](https://www.luogu.com.cn/record/181014812)。

- 如何得到操作次数？

  $n$ 的范围过大，导致我们无法模拟整个序列的操作，所以只需要单独模拟 $n$ 在序列中的位置即可。

  再用上面的过程对照原序列观察，第一轮操作中数字 $10$ 前面的 $2$ 个数 $4$，$8$  被删除了，所以数字 $10$ 来到了原来 $8$ 的位置，也就是 $10-2=8$。

  总而言之就是**通过前面删除的数的总个数**得到 $n$ 的位置。

  还能够发现删除的数的位置是 $k$ 的倍数，像上面 $k=4$，所以第一轮中 $4$，$8$ 和第二轮中 $5$，$10$ 等其他数都被删除了，因为它们在序列的第 $4$ 或 $8$ 位上。

  通过两者结合即可得出代码：当 $n$ 当前的位置为 $k$ 的倍数，就会被删除，得到操作次数，反之操作一次，更新 $n$ 的位置。

## 代码

讲的多少有点抽象，用代码理解会更好。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,ans;
signed main(){
	cin>>n>>k;
	while(++ans)//计算次数，一定要 ++ans，ans++ 会导致进不了循环。
	{
		int denums=n/k;//计算当前这轮操作会删除的数的个数 
		if(n%k==0)break;//若 n 的位置是 k 的倍数，删除 
		n-=denums;//更新 n 的位置 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：__XU__ (赞：2)

# P11180 题解

### 题意：

每轮都将为 $k$ 的倍数的数字删去，直到删除数字 $n$。

### 思路：

按题意模拟即可，记当前剩余数字个数为 $x$，我们可以发现每进行一次操作都会减少 $\lfloor \frac{x}{k}\rfloor$ 个数字。

因为 $k$ 至少为 $2$, 所以复杂度不会超过 $\Theta(\log n)$, 放心模拟就行。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll k,n;
int main(){
	cin>>n>>k;
	int i=0;
	while(true){
		i++;
		if(n%k==0){
			cout<<i;
			return 0; 
		}
		else{
			n-=n/k;
		}
	}
	return 0;
}
```

谢谢观看。

---

## 作者：封禁用户 (赞：1)

### 题意
这道题和 [[CSP-J 2023] 小苹果](https://www.luogu.com.cn/problem/P9748) 特别像，就是改了一下拿走苹果的间隔数，在苹果总数小于间隔数时直接结束，最后判断能不能拿走第 $n$ 个苹果，输出拿走时的天数，就这样。  
### 具体思路
很明显，每次删数只会删除 $\lfloor \frac{n}{k} \rfloor$ 个数字，因此在满足 $n\ge k$ 的情况下，让 $n$ 减去 $\lfloor \frac{n}{k} \rfloor$ 以模拟删数过程，并用一个计数器记录操作次数。当 $n \bmod k =0$ 时，第 $n$ 个数一定会被删掉，记录答案后打破循环即可。记录答案的变量初始化为 $0$，如果第 $n$ 个数不会被删除的话就不会被记录任何答案，输出的结果就是 $0$，符合题意。    
十年 OI 一场空，不开 long long 见祖宗 ~
### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,a,b) for(int i=a;i<=b;i++)
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
int n,k,ans,sum;
signed main() {
	n=read(),k=read();
	while(n>=k) {
		sum++;
		if(n%k==0) {
			ans=sum;
			break;
		}
		n-=(n/k);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：signed_long_long (赞：1)

# 题目解法
这题是思维题。

每一次删除都会删除一些数字，空出来一些编号。空出来的编号很难处理，那就直接不管它们，直接当做在末尾删了 $n \div k$ 个数，即把 $n$ 减去 $n\div k$ 就可以了。那该怎么处理第几次删除第 $n$ 个数会被删除呢？如果 $n\mid k$ 就说明 $n$ 要被删除了，直接输出就好了，最后还没删掉就输出 $0$。

还没理解的话看一下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int k;
signed main(){
	scanf("%lld%d",&n,&k);
	for(int i=1;n>=k;i++){
		if(n%k==0){
			printf("%d",i);
			return 0;
		}
		n-=n/k;
	}
	printf("0");
	return 0; 
}
```

---

## 作者：RioFutaba (赞：1)

设当前的数字数量是 $n'$，那么显然的，位置是 $k$ 倍数数字都会被删除，所以这一次会删除 $\lfloor \frac{n'}{k} \rfloor$ 个数字。如果某一次数字数量是 $k$ 的倍数，那么第 $n$ 个数就会在这一次被删除。

代码：


```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
ll n;
int k,cnt;
int main(){
	cin >> n >> k;
	while(n>=k){
		cnt++;
		if(!(n%k)){
			cout << cnt << "\n";
			return 0;
		}
		n-=n/k;
	}
	cout << "0\n";
	return 0;
}
```

---

## 作者：jinhangdong (赞：1)

# 题目大意
有 $n$ 个数字 $1$ 到 $n$，每次删除位置是 $k$ 的倍数的数字，问第几轮删除 $n$ ，如果 $n$ 不会被删除输出 $0$。
# 思路
因为 $n$ 一定在最后一个位置，所以当剩下的数字个数是 $k$ 的倍数的时候 $n$ 才会被删除。

那么如何求每次删除后的数字序列长度呢？

其实很简单，它每隔 $k$ 个删除一个，不满 $k$ 个的就不删除了。每次删除所剩的数字个数就是 $m-\lfloor \frac{m}{k}  \rfloor$，其中 $m$ 是当前数字序列的长度，当 $m\lt k$ 时就不能删除了，如果这是 $n$ 还没被删除，就输出 $0$ 了。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main()
{
	cin>>n>>k;
	for(int i=1;;++i)
	{
		if(n%k==0)//当目前的长度是k的倍数时最后一个数字就会被删除 
		{
			cout<<i;
			return 0;
		}
		n-=n/k;//删除 
		if(n<k)//当长度<k时就不能删了，自然最后一个数也不会被删除了 
		{
			cout<<0;
			return 0;
		}
	}
}
```

---

## 作者：zzm_psdm (赞：1)

## 思路
寻找规律：

- 第一个操作剩下的数字是 1，3，5，7，9，11，13。
- 第二个操作剩下的数字是 1，5，9，13。
- 第三个操作剩下的数字是 1，9。
- 第四个操作剩下的数字是 1。

得到结论，每次操作后会删除 $ \lfloor \frac{n}{k} \rfloor $ 个数，所以先 for 循环，每次减去 $ \lfloor \frac{n}{k} \rfloor $，如果当前的 $j$ 是 $k$ 的倍数并且 $j$ 是第一次记录，那么，记录 $j$，最后输出 $ans$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k,ans;  //记得开 long long 
int main(){
	cin>>n>>k;
	for (long long i=1,j=n;j>=k;i++,j-=j/k){ //由于 j=n,所以 for 循环也要开 long long 
		if (j%k==0 && ans==0) ans=i;  
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：cmask4869 (赞：1)

## 思路
一道模拟题目。观察题目，可知每次删除 $\lfloor \frac{n}{k} \rfloor$ 个数，每次删除的数为 $k$ 的倍数，每次减去这些数按题意模拟即可，$i$ 用来计算目前次数，$j$ 用来模拟目前没被删除数字的数量。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
typedef long long ll ;

int main(){
	ll n,k,ans=0 ;
	cin >> n >> k ;
	for (ll i=1,j=n ; j>=k ; i++,j-=(j/k)){
		if (j%k==0 && ans==0) ans=i ;
	}
	cout << ans ;
	return 0 ;
}
```

---

## 作者：lichenxi111 (赞：1)

很裸的一道题

## 题意

有 $n$ 个数字 $1$ 到 $n$ 按升序排列，每次操作删除下标为 $k$ 的倍数的数，重复操作直到数字个数小于 $k$，问数字 $n$ 在第几次操作被删除。

## 思路

发现数的大小并不重要，我们只关注下标，每次会删除下标为 $k$ 的倍数的数，所以每次会删除 $x = \lfloor \frac n k \rfloor$ 个数，会剩下 $n - x$ 个数，下标为 $1$ 到 $n - x$。如果不被删除，数字 $n$ 的下标一直是序列长度。

数字 $n$ 被删除，当且仅当序列长度（即数字 $n$ 的下标）为 $k$ 的倍数。

模拟这个过程，直到数字 $n$ 被删除或序列长度小于 $k$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n,k;
	cin >> n >> k;
	int t = 0;
	while(n >= k)
	{
		t++;
		if(n % k == 0)
		{
			cout << t;
			return 0;
		}
		else
		{
			n -= (n / k);
		}
	}
	cout << 0;
	return 0;
}
```

---

## 作者：Crasole (赞：0)

## 思路

我们可以先手造一组样例：

```
n = 13, k = 3
1 2 3 4 5 6 7 8 9 10 11 12 13
```

第一次删除后（其中括号里的是原来的序号）：

```
1(1) 2(2) 3(4) 4(5) 5(7) 6(8) 7(10) 8(11) 9(13)
```

可以发现减少了 $\lfloor \frac{n}{k} \rfloor$ 个数字，那么还有 $n - \lfloor \frac{n}{k} \rfloor$ 个数字。

接着删除：

```
1(1) 2(2) 3(4) 4(5) 5(7) 6(8)
```

可以发现，最后一个数字被删除了，而且是在 $n \bmod k = 0$ 的情况下被删除的。

那么思路就很清楚了：每次先判断 $n \bmod k$ 是否为 $0$，若为 $0$ 输出操作次数，否则让 $n$ 为 $n - \lfloor \frac{n}{k} \rfloor$。

最后，若 $n < k$ 且 $n \ne 0$，输出 $0$，因为无法被删除。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, k;
signed main () {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	cin >> n >> k;
	int cnt = 0;//cnt是操作轮数
	while(n >= k) {
		++ cnt;
		if(n % k == 0) return cout << cnt << endl, 0; //能被删除
        n -= n / k;//一次删除操作
	}
	cout << 0 << endl;//不能被删除
	return 0;
}
```

---

## 作者：LG086 (赞：0)

输入给定 $n,k$，问在 $1$ 到 $n$ 的自然数序列中，每隔 $k$ 个数字删一个，那么 $n$ 是在第几轮操作被删除的。


观察样例，发现第一轮删除了 $\lfloor \dfrac{13}{2} \rfloor=6$ 个数字，第二轮删除 $\lfloor \dfrac{13-6}{2} \rfloor=3$ 个数，第三轮删除 $2$ 个数，第四轮删除 $1$ 个数，删除操作完毕。其中 $13$ 在第三轮被删除，而第三轮开始时，剩下 $4$ 个数未被删除，满足 $4 \bmod 2 =0$。

假设每一轮删除开始前还剩下 $a$ 个数字。  
根据样例可以推出，每轮会删除 $\lfloor \dfrac{a}{k} \rfloor$ 个数字，并且在每一轮删除中，若此时满足 $a \bmod k = 0$，则此时数字 $n$ 被选中删除。所以需要输出当前操作轮数。否则每轮操作后使当前的 $a$ 减去 $\lfloor \dfrac{a}{k} \rfloor$。



---

### 代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
using ll=long long;
ll n,k,i;
int main(){
	cin>>n>>k;
	while(n>=k){
		i++;
		if(n%k==0)
		    return cout<<i,0;
		n-=n/k;
	}
	puts("0");
}
```

---

## 作者：NTT__int128 (赞：0)

# P11180 [ROIR 2018 Day2] 删除数字 题解
类似于 P9748。

若 $n\equiv0\pmod k$，则最后一个数在这一次被删除，否则剩下的个数为 $n-\lfloor\frac{n}{k}\rfloor$，继续算下去，直到 $n<k$ 为止。记录一下次数即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,c;
int main(){
    cin>>n>>k;
    while(n>=k){
        c++;
        if(n%k==0){
            cout<<c;
            return 0;
        }
        n-=n/k;
    }
    cout<<0;
    return 0;
}
``

---

## 作者：iyka (赞：0)

### 题目大意
给出一个 1 到 $n$ 的序列，经行多次操作，每次操作删去其中编号为 $k,2k\ldots ik(ik\le n)$ 的数，求第 $n$ 个的数在第几次操作中会被删去，若永不会被删去，则输出 0。

### 思路
首先想到的是 $O(n)$ 暴力枚举序列，但发现 $n$ 的值非常的大，所以我们果断选择抛开序列，只看 $a_n$。

设每次操作后的序列长度为 $s$，我们注意到当 $s\bmod k=0$ 时 $a_n$ 就会被删去，而在当 $s<k$ 时 $a_n$ 就永远无法被删去，所以我们可以只更新序列长度就可以得出答案。

序列长度的更新也十分简单，每次操作时都会剔除 $\lfloor \frac{n}{k} \rfloor$ 个数，所以得 $s\gets \lfloor \frac{s}{k} \rfloor$。

### 代码部分

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,ans;
signed main()
{
    cin>>n>>k;
    while(n%k)
    {
    	if(n<k)
    		return cout<<0, 0;
    	n-=(n/k), ans++;
	}
	cout<<ans+1;
    return 0;
}
```

---

## 作者：chengjindong (赞：0)

[题目](https://www.luogu.com.cn/problem/P11180)

题目简述：有 $n$ 个数，每隔 $k-1$ 个数就会拿走一个，求在第几次时拿走了第 $n$ 个。

因为每 $k-1$ 个数拿一个，所以每次就拿走 $n \div k$ 个数，那判断这一次有没有拿到 $n$ 就只用判断 $n$ 是不是 $k$ 的倍数就行了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n,k,ans=1;
	cin >>n>>k;
	while(n){//只要还有数，就继续 
		if(n%k==0){//如果n已经是k的倍数了，就直接输出
			break;//退出 
		}
		n-=n/k;//每次拿走n/k个数
        ans++;//答案加一 
	}
	cout<<ans;//输出答案 
	return 0;
}
```

---

## 作者：z_yq (赞：0)

# 题目意思
和去年的普及组复赛第一题一样，几乎就是小苹果。\
每次 $k$ 个数里面取走第一个，问第几轮取到 $n$。
# 做法
想法很简单，我们看如果 $n$ 会在这一轮被取走，即 $n$ 可以整除 $k$，则我们立马输出答案，否则 $n$ 经过了这一轮，就会在 $n- \lfloor \frac{n}{k} \rfloor$ 的位置了。我们递归求解即可，不会超时，因为题目保证了 $k\geq 2$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
int main()
{
	cin>>n>>k;
	int ans=0;
	while(n && n!=1)
	{
		if(n%k==0) break;
		n-=(n/k);
		ans++;
	}
	if(n==1) cout<<0;
	else cout<<ans;
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P11180 [ROIR 2018 Day2] 删除~~苹果~~数字](https://www.luogu.com.cn/problem/P11180)

***

笑点解析：[P9748 [CSP-J 2023] 小苹果](https://www.luogu.com.cn/problem/P9748)

一开始我写了这样的抽象代码（样例过了）：

```cpp
#include<iostream>
using namespace std;
long long n,k,ans=0;
int main(){
	cin>>n>>k;
	for(int i=1;n;i++){
		if(n%k==0)ans=i;
		n-=(k+i);
		if(n<k)break;
	}
	cout<<ans;
}
```

然后卡出了[~~红黑树~~](https://www.luogu.com.cn/record/180937779)。

### 做题过程

我在写什么啊！

回归正题，这题跟小苹果同曲同工，我们发现每次删除的数量一定是 $\lfloor \dfrac{n}{k} \rfloor$（每 $k$ 个删除最后一个），所以如果此时的最后一个正好能整除 $k$，这时如果原先的第 $n$ 个没有被删掉那么我们要求的第 $n$ 个就会这轮被删，所以如果答案还是初始值并且 $n \mid k$ 则更新答案为当前轮。

### 编写代码

我们用循环表示轮数，从 $1$ 开始，如果 $n<k$ 则退出循环。

每次判断 $n$ 是否能整除 $k$，如果 $ans$ 恰好为 $0$ 则更新 $ans$ 为循环轮数 $i$。

之后让 $n\leftarrow n-\lfloor \dfrac{n}{k}\rfloor$。

$n$ 记得开 long long，然后就没什么了。

```cpp
#include<iostream>
using namespace std;
int main(){
    long long n,k,ans=0;
	cin>>n>>k;
	for(int i=1;n>=k;n-=(n/k),i++)
		if(n%k==0&&!ans)ans=i;
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/180945076)。

---


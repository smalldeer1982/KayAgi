# 带余除法

## 题目背景

**注意：提交至洛谷时，请使用标准输入输出，而非文件输入输出。**

**NOTICE: When submitting your code on Luogu site, please use standard IO instead of file IO.**

[点我（或在本题底部）下载中文试题 PDF。](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/asjh3my3?contestId=200686)

[Click here (or at the bottom  of this page) to download the English version of statements (PDF).](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/lkux3617?contestId=200686)

**注意：本次比赛所有题目的大样例均为 Linux 换行符格式，在 Windows 系统内可能无法正常显示换行。**


## 题目描述

我们已经学过带余除法。对于两个正整数 $n,q$，如果 $n$ 除以 $q$ 的商为 $k$，余数为 $r$，我们可以写出带余除法算式 $n\div q = k \cdots\cdots r$，或被记为 $n\div q = k (\text{r. } r)$。本题中，为了简化，哪怕 $r=0$，我们也要写出这个余数。

现在有一个带余除法，然而你只知道被除数 $n​$ 和商 $k​$，而并不知道除数 $q​$ 和余数 $r​$。你想知道余数有多少种可能。

## 说明/提示

【样例 1 解释】

对于第一组数据，被除数为 $10$，商为 $2$。

- 如果除数是 $1,2,3$，那么商分别是 $k=10,5,3$，不符合题意。
- 如果除数是 $4$，那么商为 $2$，余数为 $r=2$。
- 如果除数是 $5$，那么商为 $2$，余数为 $r=0$。
- 如果除数是 $6,7,8,9,10$，那么商都是 $1$，不符合题意。
- 如果除数 $>10$，那么商为 $0$，不符合题意。

对于第二组数据，被除数为 $1$，商为 $0$。

只要除数 $q>1$，那么 $1\div q = 0 \cdots\cdots 1$ 一定是正确的带余除法算式。余数只有 $1$ 这一种可能。

【数据范围】

对于前 $30\%$ 的数据，保证 $1\le n\le 1000$，$0\le k\le 1000$。

另有 $20\%$ 的数据，保证 $k\le 10^5$。

另有 $20\%$ 的数据，保证 $k\ge 10^9$。

对于全体数据，保证 $1\le T\le 10$，$1\le n\le 10^{14}$，$0\le k\le 10^{14}$。

## 样例 #1

### 输入

```
2
10 2
1 0
```

### 输出

```
2
1
```

## 样例 #2

### 输入

```
参见 division/division2.in```

### 输出

```
参见 division/division2.ans```

# 题解

## 作者：yummy (赞：24)

# A. 带余除法 (division) 官方题解

本题考查的主要知识点有：

- 【1】代数（初中部分）
- 【2】for 语句、if 语句、输入输出语句

---

首先特判 $k=0$，此时答案为 $1$。当 $k>0$ 时，每个 $q$ 都对应一个 $r$，讨论 $q$ 的个数：

考虑带余除法的定义，$n=kq+r$。代入 $0\le r < q$ 可得 $kq\le n < kq+q$。换言之，$\dfrac{n}{k+1}<q\le \dfrac{n}{k}$。

当 $q$ 为整数时，它等价于 $\lfloor \dfrac{n}{k+1}\rfloor<q\le \lfloor \dfrac{n}{k}\rfloor$，只要输出 $\lfloor \dfrac{n}{k}\rfloor-\lfloor \dfrac{n}{k+1}\rfloor$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,k;
int main(){
	for(cin>>T;T;T--){
		cin>>n>>k;
		if(k!=0)cout<<n/k-n/(k+1)<<endl;
		else cout<<1<<endl;
	}
	return 0;
}
```

---

## 作者：yayia0503 (赞：19)

# P11184 带余除法
## 题意简述
[题目链接](https://www.luogu.com.cn/problem/P11184)  
对于带余除法算式 $n\div q= k\cdots\cdots r$，给定被除数 $n$ 和商 $k$，求出可能的余数的个数。其中，$n,q$ 均为正整数，$k$ 不保证不为零，$r=0$ 时，也认为其属于一个可能的余数。 
## 分析
题目要求求出可能的余数的个数，如果我们直接使用暴力枚举的方法求解，时间复杂度比较高，对于这道题的数据范围来说，可能会导致超时。  
那我们不妨换个思路。可以发现，在以上带余除法式中，我们可以比较方便地求出可能的除数 $q$ 的个数。如果我们能建立 $k$ 和 $r$ 数量之间的关系，这道题便可迎刃而解。  
由数学知识可知。当 $n,k$ 给定时，不存在两除数 $q_1,q_2$，$q_1\ne q_2$，使得对应的 $r_1=r_2$。即**除数的可能个数便是余数的可能个数**。  
## 推导
**注意**，在以下推导时，均认为 $q\ne0,k\ne0$。  
现在，我们要求出除数的可能个数，先求出除数的取值范围。  
首先，从被除数、除数、商的关系看：  
在带余除法中，有
$$k\times q\le n$$
即
$$q\le \frac{n}{k} $$
其次，从余数和除数的关系看：  
将余数 $r$ 用 $n,k,q$ 表示
$$r=n-q\times k$$
因为
$$r<q$$
所以
$$\frac{n}{k+1}<q$$
综上，$q\in ( \frac{n}{k+1} ,\frac{n}{k} ]$。  
这个区间内整数的个数 $num=\lfloor \frac{n}{k}\rfloor -\lfloor \frac{n}{k+1}\rfloor $，$num$ 即为题目所求。
## 特殊情况
当 $k=0$ 时，不论 $n,q$ 怎么取，都只有 $n\div q= 0\cdots\cdots  n$ 一种情况，此时答案数为 $1$。
## CODE

```cpp
#include <iostream>
using namespace std;
typedef long long ll;
ll n,k;//注意，题目数据范围较大，需开long long，防止溢出
int t;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>k;
		cout<<(k?(n/k-n/(k+1)):1)<<endl; //三目运算法，若k!=0则输出(n/k-n/(k+1))，否则则输出1
		/*在C++中，整数除法默认向零取整。
		此时n/k和n/(k+1)均大于零，即向下取整*/
	}
	return 0;
}
```

---

## 作者：2huk (赞：8)

注意到当 $q$ 确定时 $r$ 也能随之唯一确定。因此问题变成了求有多少合法 $q$。

何为合法？$\left \lfloor \dfrac nq\right \rfloor = k$。

显然合法的 $q$ 是连续的。因此我们可以二分出 $q$ 的最小和最大取值 $q_{\min},q_{\max}$。那么 $q_{\max}-q_{\min}+1$ 即为答案。

注意需要特判：

- $b=0$：输出 $1$；
- $b > a$：输出 $0$。

```cpp
// Problem: U480670 带余除法
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/U480670?contestId=200686
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

typedef long long ll;

signed main() {
	int T;
	cin >> T;
	while (T -- ) {
		ll a, b;
		cin >> a >> b;
		if (b > a) cout << 0 << '\n';
		else if (!b) cout << 1 << '\n';
		else {
			ll lo = 1, hi = 1e14, L = 2, R = 1;
			
			while (lo <= hi) {
				ll mid = lo + hi >> 1;
				if (a / mid <= b) {
					L = mid;
					hi = mid - 1;
				} else {
					lo = mid + 1;
				}
			}
			
			lo = 1, hi = 1e14;
			while (lo <= hi) {
				ll mid = lo + hi >> 1;
				if (a / mid >= b) {
					R = mid;
					lo = mid + 1;
				} else {
					hi = mid - 1;
				}
			}
			
			cout << max(0ll, R - L + 1) << '\n';
		}
	}
	return 0;
}
```

---

## 作者：宋怡芃 (赞：4)

### P11184 带余除法 题解

[题目传送门](https://www.luogu.com.cn/problem/P11184)

#### 分析

这是一个带余除法问题。给定被除数 $n$ 和 $k$ 商，我们要找可能的余数的不同数量。这个问题可以通过数学分析来解决。

根据带余除法的定义： $n = q \times k + r$。

其中 $0 \leq r < q$，$q$ 是除数 $r$ 是余数。

由于 $0 \leq r<q$，我们可以得到：$0 \leq n−q \times k<q$。

所以这意味着：$q \times k \leq n<q \times (k+1)$。

于是 $q$ 的取值可以在：$\frac{n}{k+1}<q \leq \frac{n}{k}$ 之间。

对于输入 一个数和 $0$，商为 $0$，意味着没有整除的部分，因此所有可能的余数都是在整个被除数范围内（因为 $n \div 0=0$ 且没有整除）。这是一个特殊情况，需要单独处理。

当 $k=n$ 时，除法的商是 $0$，这意味着 $q$ 可以取任意正整数，而余数 $r$ 就是  $n$ 本身。因此，余数的唯一可能就是 $r=n$。

#### 步骤：
遍历每一组输入的 $n$ 和 $k$。
计算满足条件的 $q$ 的范围。
输出不同 $q$ 值的数量，即为余数的不同可能性数量。

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t;
int main() 
{
	//freopen("division.in","r",stdin);
	//freopen("division.out","w",stdout);
    cin >> t;
    while (t--) 
	{
        long long n, k;
        cin >> n >> k;
        if (k == 0) 
		{
            cout << 1 << endl;
        } 
		else 
		{
            long long minn = n/(k+1)+1;
            long long maxn = n/k;
            cout << maxn-minn+1 << endl;
        }
	}
    return 0;
}
```

---

## 作者：_JF_ (赞：2)

[P11184 带余除法 ](https://www.luogu.com.cn/problem/P11184)

赛时还没切，哈哈。

非常困难这道题，可以说，这题是我在这场噗叽组模拟赛里面思考最久的题目。

题目其实要我们完成两个限制。

- 满足 $r<q$。
- 满足 $r$ 和 $n$ 在模 $k$ 意义下同余。

我们只要先把第一个范围表示出来就行了。

因为 $qk+r=n$，我们可以观察到其实 $n$ 要满足 $qk\le n < qk+q$。

这时候我们容易表示出 $q$ 的取值范围，进而，$r$ 的取值范围容易表示。

然后进而搞出第二个范围就行了。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
#define int long long
signed main(){
//	freopen("1.in","r",stdin);
//	freopen("ans1.out","w",stdout);
	int t;
	scanf("%lld",&t);
	while(t--){
		int n,k;
		scanf("%lld%lld",&n,&k);
		if(k==0)	{printf("%lld\n",1ll*1);continue;}
		__int128 p=n,q=k;
		__int128 prenow=p-(p*q)/(q+1)-1;
		if(prenow<n%k)	{printf("%lld\n",1ll*0);continue;}
		int pre=n%k,pre1=(prenow-pre)/k+1;
		printf("%lld\n",pre1);
	}
	return 0;
}
```

---

## 作者：rc_Taurus (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11184)

---

很明显，这道题不能暴力求解。

很明显当 $k=0$ 时输出 $1$。 

注意到对于 $n\div q=k\cdots\cdots r$，当 $k$ 一定时，$q$ 可以为任意使得式子的商最终为 $k$ 的数，因为每一个 $q$ 都对应着一个 $r$，求 $r$ 的个数实际上就是求满足条件的 $q$ 的个数。

求 $q$ 的个数也很简单（就是把最小的满足条件的 $q$ 与最大不满足条件的 $q$ 相减就行啦）：

$$cnt_q=\lfloor{\frac{n}{k}}\rfloor-\lfloor{\frac{n}{k+1}}\rfloor$$

举个例子：

当 $n=10$ 且 $k=2$ 时：

$ \lfloor{\frac{10}{2}}\rfloor = 5 \ge q \gt \lfloor{\frac{10}{3}}\rfloor = 3$ 且 $q$ 为整数。

则 $cnt_q=5-3=2$，即 $q$ 有两种可能。

由此我们可以写出如下代码：

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define int long long //要开long long
using namespace std;
int t,n,k;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
    	cin>>n>>k;
    	if(!k)cout<<1<<endl;
    	else{
    		int p=n/k,q=floor(n/(k+1.0));
    		cout<<(p-q)<<endl;
    	}
    }
    return 0;
}
```

这样就做对了。

---

## 作者：wwwidk1234 (赞：2)

小学难度的数学题。

先说结论：**要使商为 $k$，除数 $q$ 必须满足：${ q \in \left [ \left \lfloor \dfrac{n}{k+1} \right \rfloor +1, \left \lfloor \dfrac{n}{k} \right \rfloor  \right ]}$，且在这些满足条件的 $q$ 之间余数互不相等。**

下面给出证明。

**引理 1：满足被除数为 $n$，商为 $k$ 的最大除数 $q$ 为 $\left \lfloor \dfrac{n}{k} \right \rfloor$。**

证明：

由题意知 $n=kq+r$。

要使 $q$ 最大，$r$ 应取 $0$。

故 $n=kq_{\max}+0 \Rightarrow q_{\max}=\dfrac{n}{k}$

又 $\because q$ 为整数 $\therefore q_{\max}=\left \lfloor \dfrac{n}{k} \right \rfloor$ 证毕。

所以就可以求出 $q_{\min}$ 为**被除数为 $n$，商为 $k+1$ 的最大整数加一，即 $\left \lfloor \dfrac{n}{k+1} \right \rfloor +1$。**

**引理 2：$n \div q = k+r$ 对于每个满足条件的 $q$，都有 $r$ 不相等。**

证明：（该思路来自于机房大佬 [@Herbie_ZHB](https://www.luogu.com.cn/user/768325)）

由题意知 $r=n-kq$，易知在 $n,k$ 一定、$q$ 不同的情况下，$r$ 一定不同。证毕。

赛时代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll solve()
{
	ll n,k;
	cin>>n>>k;
	if(k==0) return 1;
	else return (n/k)-(n/(k+1)+1)+1;
}
int main()
{
	freopen("division.in","r",stdin);
	freopen("division.out","w",stdout);
	int T;
	cin>>T;
	while(T--) cout<<solve()<<'\n';
	return 0;
}
//合法区间:[n/(k+1)+1,n/k] 
```

---

## 作者：sieve (赞：1)

# 题解：[P11184 带余除法](https://www.luogu.com.cn/problem/P11184)

## 思路

这题也是非常的简单的。

我们可以算出答案的下边界是 $\lceil \frac{n}{k+1} \rceil$，上边界是 $\lfloor \frac{n}{k} \rfloor$，然后答案就是区间中的个数，也就是 $\lfloor \frac{n}{k} \rfloor - \lceil \frac{n}{k+1} \rceil + 1$。

当然，如果 $k = 0$，会发生除零错误，所以要特判。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
void solve()
{
	int n,k;
	cin>>n>>k;
	if(k==0)//注意，如果除数为0，会RE，所以要特判
	{
		cout<<"1\n";
		return;
	}
	int mn=(n+k+1)/(k+1);//向上取整
	int mx=n/k;//int 自动向下取整
	cout<<max(0ll,mx-mn+1)<<'\n';
	return;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) solve();
	return 0;
}
/*
10
447 0
22 1
21 1
23 1
319 11
318 11
320 11
493 29
492 29
494 29
*/
```

---


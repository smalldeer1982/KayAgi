# [CSP-J 2024] 地图探险

## 题目描述

小 A 打算前往一片丛林去探险。丛林的地理环境十分复杂，为了防止迷路，他先派遣了一个机器人前去探路。

丛林的地图可以用一个 $n$ 行 $m$ 列的字符表来表示。我们将第 $i$ 行第 $j$ 列的位置的坐标记作 $(i, j)(1 \leq i \leq n$，$1 \leq j \leq m)$。如果这个位置的字符为 $\tt x$，即代表这个位置上有障碍，不可通过。反之，若这个位置的字符为 $\tt.$，即代表这个位置是一片空地，可以通过。

这个机器人的状态由位置和朝向两部分组成。其中位置由坐标 $(x, y)(1 \leq x \leq n$，$1 \leq y \leq m)$ 刻画，它表示机器人处在地图上第 $x$ 行第 $y$ 列的位置。而朝向用一个 $0 \sim 3$ 的整数 $d$ 表示，其中 $d = 0$ 代表向东，$d = 1$ 代表向南，$d = 2$ 代表向西，$d = 3$ 代表向北。

初始时，机器人的位置为 $(x_0, y_0)$，朝向为 $d_0$。**保证初始时机器人所在的位置为空地**。接下来机器人将要进行 $k$ 次操作。每一步，机器人将按照如下的模式操作：

1. 假设机器人当前处在的位置为 $(x, y)$，朝向为 $d$。则它的方向上的下一步的位置 $(x^′, y^′)$ 定义如下：若 $d = 0$，则令 $(x^′, y^′) = (x, y + 1)$，若 $d = 1$，则令 $(x^′, y^′) = (x + 1, y)$，若 $d = 2$，则令 $(x^′, y^′) = (x, y - 1)$，若 $d = 3$，则令 $(x^′, y^′) = (x - 1, y)$。

2. 接下来，机器人判断它下一步的位置是否在地图内，且是否为空地。具体地说，它判断 $(x^′, y^′)$ 是否满足 $1 \leq x^′ \leq n, 1 \leq y^′ \leq m$，且 $(x^′, y^′)$ 位置上是空地。如果条件成立，则机器人会向前走一步。它新的位置变为 $(x^′, y^′)$，且朝向不变。如果条件不成立，则它会执行“向右转”操作。也就是说，令 $d^′ = (d + 1) \bmod 4$（即 $d + 1$ 除以 $4$ 的余数），且它所处的位置保持不变，但朝向由 $d$ 变为 $d^′$。

小 A 想要知道，在机器人执行完 $k$ 步操作之后，地图上所有被机器人经过的位置（包括起始位置）有几个。

## 说明/提示

**【样例 1 解释】**

该样例包含两组数据。对第一组数据，机器人的状态以如下方式变化：
1. 初始时，机器人位于位置 $(1, 1)$，方向朝西（用数字 $2$ 代表）。
2. 第一步，机器人发现它下一步的位置 $(1, 0)$ 不在地图内，因此，它会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝北（用数字 $3$ 代表）。
3. 第二步，机器人发现它下一步的位置 $(0, 1)$ 不在地图内，因此，它仍然会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝东（用数字 $0$ 代表）。
4. 第三步，机器人发现它下一步的位置 $(1, 2)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 2)$，方向仍然朝东。
5. 第四步，机器人发现它下一步的位置 $(1, 3)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 3)$，方向仍然朝东。

因此，四步之后，机器人经过的位置有三个，分别为 $(1, 1),(1, 2),(1, 3)$。

对第二组数据，机器人依次执行的操作指令为：向东走到 $(1, 2)$，向东走到 $(1, 3)$，向东走到 $(1, 4)$，向东走到 $(1, 5)$，向右转，向南走到 $(2, 5)$，向南走到 $(3, 5)$，向南走到 $(4, 5)$，向南走到 $(5, 5)$，向右转，向西走到 $(5, 4)$，向西走到 $(5, 3)$，向西走到 $(5, 2)$，向右转，向北走到 $(4, 2)$，向右转，向右转，向南走到 $(5, 2)$，向右转，向右转。

**【样例 2】**

见选手目录下的 explore/explore2.in 与 explore/explore2.ans。

该样例满足第 $3\sim 4$ 个测试点的限制条件。

**【样例 3】**

见选手目录下的 explore/explore3.in 与 explore/explore3.ans。

该样例满足第 $5$ 个测试点的限制条件。

**【样例 4】**

见选手目录下的 explore/explore4.in 与 explore/explore4.ans。

该样例满足第 $6$ 个测试点的限制条件。

**【样例 5】**

见选手目录下的 explore/explore5.in 与 explore/explore5.ans。

该样例满足第 $8 \sim 10$ 个测试点的限制条件。

**【数据范围】**

对于所有测试数据，保证：$1 \leq T \leq 5$，$1 \leq n, m \leq 10^3$，$1 \leq k \leq 10^6$，$1 \leq x_0 \leq n$，$1 \leq y_0 \leq m$，$0 \leq d_0 \leq 3$，且机器人的起始位置为空地。

::cute-table{tuack}

| 测试点编号 | $n$ | $m$ | $k$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $=1$ | $\leq 2$ | $=1$ | 无 |
| $2$ | ^ | ^ | ^ | ^ |
| $3$ | $\leq 10^2$ | $\leq 10^2$ | ^ | ^ |
| $4$ | ^ | ^ | ^ | ^ |
| $5$ | $=1$ | $\leq 10^3$ | $\leq 2\times 10^3$ | 地图上所有位置均为空地 |
| $6$ | ^ | ^ | ^ | 无|
| $7$ | $\leq 10^3$ | ^ | $\leq 10^6$ |  地图上所有位置均为空地 |
| $8$ | ^ | ^ | ^ | 无 |
| $9$ | ^ | ^ | ^ | ^ |
| $10$ | ^ | ^ | ^ | ^ |

## 样例 #1

### 输入

```
2
1 5 4
1 1 2
....x
5 5 20
1 1 0
.....
.xxx.
.x.x.
..xx.
x....```

### 输出

```
3
13```

# 题解

## 作者：OIer6666 (赞：60)

~~这个锑在考场上因为少些 `k--` 被硬控半小时。~~

## 解题思路

这道题不是搜索！

直接按照题意模拟就行了。

遇到墙就向右转，不是就直行。

**特别注意：**
- **向右转也是一步！**
- **一个格子最多算一遍！**

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0}; 
char mp[1145][1145];
bool vis[1145][1145];
int main(){
	ios::sync_with_stdio(false);
	int t;cin>>t;
	while(t--){
		memset(vis,0,sizeof vis);
		memset(mp,0,sizeof mp);
		int n,m,k,x,y,d;
		cin>>n>>m>>k>>x>>y>>d;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				cin>>mp[i][j];
		int wa=1;
		vis[x][y]=1;
		while(k>0){//模拟
			int tx=x+dx[d],ty=y+dy[d];
			if(mp[tx][ty]=='.'){
				if(!vis[tx][ty])
					wa++,vis[tx][ty]=1;
				x=tx,y=ty;//移动
			}else{
				d=(d+1)%4;//向右旋转
			}
			k--;
		}
		cout<<wa<<endl;
	}
	return 0;
}
```

---

## 作者：chen_zhe (赞：56)

欢迎报名[洛谷网校](https://class.luogu.com.cn/)，期待和大家一起进步！

本题属于模拟题，为了解释清楚题意，题目长度偏长，放在这个位置可能对于年龄较低的参赛选手不太友好。

根据题目描述直接进行模拟，下面是几个要点：

- 在代码中可以设置两个位移数组 `const int dx[]={0,1,0,-1}, dy[]={1,0,-1,0};`，以简便地完成转向的移动。
- 需要注意在代码中所使用的横纵坐标，其中 `y1` 等变量名不应定义为全局变量（尤其是在有万能头文件的情况下），以免出现编译错误。
- 横纵坐标等用错可能会出现通过样例但是未 AC 的情况（例如说在一处 `y1` 错写为 `y0` 等情况）
- 多测不清空，爆零两行泪。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool vis[1005][1005];
char ch[1005][1005];
const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
void solve() {
	int n,m,k,x0,y0,d0;
	memset(vis,0,sizeof(vis));
	cin >> n >> m >> k;
	cin >> x0 >> y0 >> d0;
	for (int i=1;i<=n;i++) {
		char s[1005];
		cin >> s;
		for (int j=1;j<=m;j++)
			ch[i][j]=s[j-1];
	}
	vis[x0][y0]=true;
	for (int i=1;i<=k;i++) {
		int x1=x0+dx[d0],y1=y0+dy[d0];
		if (1<=x1 && x1<=n && 1<=y1 && y1<=m && ch[x1][y1]=='.') {
			x0=x1;
			y0=y1;
		}
		else
			d0=(d0+1)%4;
		vis[x0][y0]=true;
	}
	int ans=0;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++)
			ans+=vis[i][j];
	}
	cout << ans << endl;
}
int main() {
	int T;
	cin >> T;
	while (T--) {
		solve();
	}
}
```

---

## 作者：Alexxu2024 (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P11228)

## 思路

这道题只需要学过基础 `dfs` 就能做了，不过听说递归会爆，没试过，读者可以自行尝试。

设 `dx[]={0,1,0,-1},dy[]={1,0,-1,0}`，代表 $d$ 为东南西北时坐标分别如何变化。我们先把新的坐标 `xx,yy` 借助 `dx,dy` 算出来，再判断是不是合法的点。如果是，更新坐标，否则转向。

至于记录走了几个点，我们可以记录 `v` 数组。定义 `v[i][j]` 为 $(i,j)$ 点的状态，如果为 $1$，则走过，否则没走过。最后遍历一遍 `v` 数组看有几个点标记为 $1$ 即可。

## 赛后代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define int long long
using namespace std;
const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
char a[1010][1010];
bool v[1010][1010];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int t;
	cin >> t;
	while(t--){
		memset(v,0,sizeof(v));
		int n,m,k;
		cin >> n >> m >> k;
		int x,y,d;
		cin >> x >> y >> d;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin >> a[i][j];
			}
		}
		v[x][y]=1;
		while(k--){//把递归写成递推形式
			int xx=x+dx[d],yy=y+dy[d];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&a[xx][yy]=='.'){
				x=xx;
				y=yy;
				v[xx][yy]=1;
			}
			else{
				d=(d+1)%4;
			}
		}
		int ans=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(v[i][j]){
					ans++;
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：gongziwen (赞：12)

纯模拟即可。

如何让代码实现更短，写出来更快？

实现：

1. 定义数组 $\text{nex}_d$ 代表向 $d$ 方向走一步的 $x,y$ 变化。
2. 定义函数 $\text{in}$，判断该点能不能走到。
3. 更新时也用一个函数，边更新遍历数组边更新答案。

记得多测清空！
```cpp
#include<bits/stdc++.h>
const int N=1e3+6;
int T,n,m,k,x,y,d,ans,nex[4][2]={0,1,1,0,0,-1,-1,0};
char map[N][N];
bool vis[N][N];
bool in(int x,int y){
	return map[x][y]=='.'&&x>=1&&x<=n&&y>=1&&y<=m;
}
void upd(int x,int y){
	if(!vis[x][y]) vis[x][y]=1,ans++;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&m,&k);
		scanf("%d%d%d",&x,&y,&d);
		for(int i=1;i<=n;i++) scanf("%s",map[i]+1);
		memset(vis,0,sizeof(vis));
		ans=0;
		upd(x,y);
		for(int i=1;i<=k;i++)
		{
			int x_=x+nex[d][0],y_=y+nex[d][1];
			if(in(x_,y_)) x=x_,y=y_;
			else d=(d+1)%4;
			upd(x,y);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：FlowerAccepted (赞：11)

## 解法分析
首先，可以发现这就是一个简单的暴力递推。  

善良的 CCF 直接告诉了我们形式化的题意

> 假设机器人当前处在的位置为 $(x, y)$，朝向为 $d$。则它的方向上的下一步的位置 $(x^′, y^′)$ 定义如下：  
> 1. 若 $d = 0$，则令 $(x^′, y^′) = (x, y + 1)$，  
> 2. 若 $d = 1$，则令 $(x^′, y^′) = (x + 1, y)$，  
> 3. 若 $d = 2$，则令 $(x^′, y^′) = (x, y - 1)$，  
> 4. 若 $d = 3$，则令 $(x^′, y^′) = (x − 1, y)$。  

这让我们很容易地得出了转移

```cpp
int
nex[] = { 0,  1,  0, -1},
ney[] = { 1,  0, -1,  0};
```

如果不出界，也不遇到障碍，机器人在 $(x, y)$ ，朝向为 $d$ 时下一步机器人的位置即为 $(x + nex_d, y + ney_d)$ 。  

至于其他情况，下一步的 $d$ 是多少，CCF 也给了我们形式化题意

> 如果条件不成立，则它会执行“向右转”操作。也就是说，令 $d^′ = (d + 1) \bmod 4$（即 $d + 1$ 除以 $4$ 的余数），且它所处的位置保持不变，但朝向由 $d$ 变为 $d^′$。

```c++
(d + 1) % 4
```

接下来，我们不再维护每个时刻机器人的位置，而是新建 $n \times m$ 的 `bool` $vis$ 数组，每组数据用 `memset` 初始化为一堆`0`，一旦机器人走过 $(i, j)$，就将$vis_{i,j}$ 设为 $1$，这样来避免重复计算走过的格子数。同时，用变量 $x, y, d$ 维护当前机器人的位置（输入时就不需要 $x_0, y_0, d_0$ 了）。值得注意的是，输入的 $(x_0, y_0)$ 也要存进 $vis$ 中。  

那么代码的核心就出来了

```cpp
vis[x][y] = 1;
for (int i = 0; i < k; i ++) {
    if (1 <= x + nex[d] && x + nex[d] <= n &&
        1 <= y + ney[d] && y + ney[d] <= m &&
        a[x + nex[d]][y + ney[d]] == '.') {
        x += nex[d];
        y += ney[d];
        vis[x][y] = 1;
    } else {
        d = (d + 1) % 4;
    }
}
```

其中第三行 `if` 的前四个条件是防止越界并判断下一步是否在丛林内，第五个条件是判断下一步是否有障碍。

> 科普：当 `&&` 前的条件为假时，后一个条件将不会被执行，也就是说，可以在 `&&` 前放置判断是否会数组越界的代码，`&&` 后放置与数组检索有关的条件以防止越界，爆 `EXC_BAD_ACCESS` 或 $\text{\textcolor{#8800CC}{Runtime Error}}$。

最后整一个 $ans = 0$ ，遍历 $vis$ , 见到 $1$ 就将 $ans$ `++`，最后输出 $ans$ 并**一定要打上换行**，这个数据就过啦！

时间复杂度：$O(k)$

> $1 \leq T \leq 5, 1 \leq n, m \leq 10^3$，$1 \leq k \leq 10^6$

由于 $T$ 是常数级别，所以不会超时。

## 完整代码
```cpp
#include <algorithm>
#include <iostream>
#include <stdio.h>
#include <string.h>
// 比赛使用的是 #include <bits/stdc++.h>
using namespace std;

char a[1005][1005];
bool vis[1005][1005];
int T,
nex[] = { 0,  1,  0, -1},
ney[] = { 1,  0, -1,  0};

int main() {
    cin >> T;
    while (T --) {
        memset(vis, 0, sizeof(vis)); // 重置vis
        int n, m, k, x, y, d, ans = 0;
        cin >> n >> m >> k >> x >> y >> d; // 如正文所述
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                cin >> a[i][j];
            }
        }
        vis[x][y] = 1;
        for (int i = 0; i < k; i ++) {
            if (1 <= x + nex[d] && x + nex[d] <= n &&
                1 <= y + ney[d] && y + ney[d] <= m &&
                a[x + nex[d]][y + ney[d]] == '.') {
                x += nex[d];
                y += ney[d];
                vis[x][y] = 1;
            } else {
                d = (d + 1) % 4;
            }
        }
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (vis[i][j]) {
                    ans ++;
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}

```

---


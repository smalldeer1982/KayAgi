# [CSP-S 2024] 决斗

## 题目描述

今天是小 Q 的生日，他得到了 $n$ 张卡牌作为礼物。这些卡牌属于火爆的“决斗怪兽”，其中，第 $i$ 张卡代表一只攻击力为 $r_i$，防御力也为 $r_i$ 的怪兽。

一场游戏分为若干回合。每回合，小 Q 会选择某只怪兽 $i$ 以及**另一只**怪兽 $j(i \neq j)$，并让怪兽 $i$ 向怪兽 $j$ 发起攻击。此时，若怪兽 $i$ 的攻击力小于等于怪兽 $j$ 的防御力，则无事发生；否则，怪兽 $j$ 的防御被打破，怪兽 $j$ 退出游戏不再参与到剩下的游戏中。一只怪兽在整场游戏中**至多**只能发起一次攻击。当未退出游戏的怪兽都已发起过攻击时，游戏结束。

小 Q 希望决定一组攻击顺序，使得在游戏结束时，未退出游戏的怪兽数量尽可能少。

## 说明/提示

**【样例 1 解释】**

其中一种最优方案为：第一回合让第 $2$ 只怪兽向第 $1$ 只怪兽发起攻击，第二回合让第 $5$ 只怪兽向第 $4$ 只怪兽发起攻击，第三回合让第 $3$ 只怪兽向第 $5$ 只怪兽发起攻击。此时没有退出游戏的怪兽都进行过攻击，游戏结束。可以证明没有更优的攻击顺序。

**【样例 3】**

见选手目录下的 duel/duel3.in 与 duel/duel3.ans。

该样例满足 $\forall 1 \leq i \leq n, r_i \leq 2$。

**【样例 4】**

见选手目录下的 duel/duel4.in 与 duel/duel4.ans。

**【数据范围】**

对于所有测试数据，保证：$1 \leq n \leq 10^5$，$1 \leq r_i \leq 10^5$。

::cute-table{tuack}

| 测试点 | $n$ | $r_i$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 4$ | $\leq 10$ | $\leq 10^5$ | 无特殊性质 |
| $5\sim 10$ | $\leq 10^5$ | $\leq 2$ | ^ |
| $11\sim 15$ | $\leq 30$ | $\leq 10^5$ | 特殊性质 A |
| $16\sim 20$ | $\leq 10^5$ | ^ | 无特殊性质 |

特殊性质 A：保证每个 $r_i$ 在可能的值域中独立均匀随机生成。

## 样例 #1

### 输入

```
5
1 2 3 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
10
136 136 136 2417 136 136 2417 136 136 136```

### 输出

```
8```

# 题解

## 作者：gongziwen (赞：140)

解法很简单，直接求众数即可。

很显然，每个怪兽尽量发挥自己活着的价值，即尽量干掉一个比他攻击值小的怪兽。

很显然，攻击值越大应该越晚被干掉。

我们按攻击力从大到小分层。

那么如果都不相等，那应该只会留下攻防最大的那个。

设第 $i$ 层人数为 $a_i$.

每一层都应该会留下 $\max\{a_{i-1}-a_i,0\}$ 个怪兽。其实把这个值加起来就对了，但是还要解释一下为什么众数是对的。

我们发现是 $a_{i-1}>a_i$ 这个值就是其差，否则为 $0$.

我们直接令 $b_i=a_i-a_{i-1}$，那么就是求 $b$ 数组大于零值的和，设 $b$ 数组选出来大于零的的值为 $c$ 集合（即 $b_{c_i}>0$，且 $c$ 是极大的），那么 $a_{c_i}$ 是严格单调上升的。

所以说答案为 $\sum b_{c_i}-b_{c_{i-1}}$，即 $a_{c_{|c|}}$，又因 $a_{c_i}$ 单调上升，所以 $a_{c_{|c|}}$ 一定是 $\max\{a_{c_i}\}$，而 $c$ 是极大的，所以即为 $\max{a_i}$.

代码如下：
```cpp
#include<bits/stdc++.h>
const int N=1e5+6;
int n,x,mp[N],ans;
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&x);
		ans=std::max(ans,++mp[x]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：_segmenttree (赞：58)

我们考虑想要减少数目那么让每只怪兽攻击哪只怪兽。根据题目描述，我们只有会攻击值比目前考虑的这只小的才会对答案产生影响。那么每次让每只怪兽攻击目前还存活的最小值一定是最优的。

证明：设目前考虑的为 $a_i$，最小值为 $a_j$，有 $a_k>a_j$。$a_j$ 和 $a_k$ 对答案的贡献值都为一，选择 $a_k$ 并不能让消灭的怪兽增加，所以我们选择最小值一定不差。

写法：简单排序后每次攻击队首的元素。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[N],l=1;
signed main() {
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++) {
		if(a[l]>=a[i]) continue ;//减不掉
		l++;
	}
	cout<<n-l+1;
	return 0;
}
```

---

## 作者：wangbinfeng (赞：45)

$$\color{grey}{\tiny{\texttt{观察到本题解的创建时间}}}$$
[![](https://img.shields.io/badge/题目-P11231_[CSP--S_2024]_决斗-green)
![](https://img.shields.io/badge/难度-普及−-orange)
![](https://img.shields.io/badge/考点-二分-blue)
![](https://img.shields.io/badge/题型-传统题-yellow)](https://www.luogu.com.cn/problem/P11231)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

---
### 考点：
- [ ]  `【4】二分法`；
- [ ] `【5】快速排序`或`【3】算法模板库中的函数：min、max、swap、sort`。

### 思路：
考虑到一个怪兽能打破一个 $r_i$ 小于它的怪兽，要使剩下的怪兽最多当且仅当最多的怪兽可以打破其他怪兽。

那么希望一个怪兽打破的怪兽是最近的小于它的怪兽（设这两个怪兽分别为 $i,j$，则不存在 $r_i<r_k<r_j$），那么可以使用二分来来寻找到这一需求。

考虑逆向实现。具体地，先对输入的 $r$ 进行排序，然后枚举所有的 $r$，对于枚举到的 $r_i$，用二分找到比他大的最近的怪兽 $j$，并标记这个怪兽已被使用掉打破其他怪兽的次数。

本人使用了 `lower_bound` 代替手写二分，发现到寻找 $k$ 时如果存在 $k$ 就会返回第一个 $k$ 的位置，否则返回第一个大于 $k$ 的位置。那么用 `lower_bound` 寻找 $r_i+1$ 即可。而对于一个怪兽被用掉了打破其他怪兽的次数，我们可以姑且在其被更多次寻找时 $r_i-1$，而主动寻找时再加回去即可。

时间复杂度 $\Theta(n \log_2 n)$。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 9;
int n, a[maxn], anss;
bitset<maxn> vis, ans;
signed main()
{
//	freopen("dat.in", "r", stdin);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	sort(a + 1, a + n + 1);
	for (int i = 1, k = 1; i <= n; i++)
	{
		k = lower_bound(a + k, a + n + 1, a[i] + 1 + vis[i]) - a; // 发现二分寻找的怪兽单调递增，那么二分的左端点可以直接赋值为上次的 k。
		while (vis[k])
			k++;
		if (k > n)
			continue;
		vis[k] = true, a[k]--, ans[i] = true;
	}
	for (int i = 1; i <= n; i++)
		anss += !ans[i];
	cout << anss << endl;
//	for (int i = 1; i <= n; i++)
//		cerr << vis[i] << ' ';
//	cerr << endl;
//	for (int i = 1; i <= n; i++)
//		cerr << ans[i] << ' ';
}
```
---
[![](https://jrenc.azurewebsites.net/api/signature?code=zHZRCCItO-yB8t7d2KyitELFDwADnXIotkeeIQL3juyNAzFucnyrWA%3D%3D&name=thanks%20for%20reading%20%20%20%20%20%20%20%20by%20%40wangbinfeng(387009)&animate=true&speed=0.7&color=purple)](https://www.luogu.com.cn/user/387009)
$$\color{grey}{\tiny{\texttt{发现上面的签名是动图了吗？}}}$$

---

## 作者：sLMxf (赞：38)

### 简述题意
每个怪兽有一个实力 $r_i$，每个怪兽只可以欺负实力严格小于自己的怪兽，被成功欺负的怪兽出局。当未退出游戏的怪兽都已发起过攻击时，游戏结束。规定一种方案使得未退出游戏的怪兽数量尽可能少。
### 算法分析
显然，对于 $a<r_i,b<r_i$，$a,b$ 在 $r_i$ 面前是等价的（都能被欺负）。

定义 $sum_k$ 表示 $r_i=k$ 的怪兽个数，$cnt$ 为对于实力为 $[1,i-1]$ 的怪兽的最优解。

所以按实力从小到大欺负，有两种情况：
- 如当前 $sum_k\le cnt$，欺负 $sum
_k$ 只即可。即 $cnt\gets cnt$。
- 否则，欺负当前所有怪兽，即 $cnt\gets sum_k$。

上面的过程可看做 $cnt=\max sum_k$。

然后这题就做完了。

---

诶等等，如果这个数据：
```
3
1 2 2
```
有一只怪兽好像没有欺负别人啊？

其实让剩下相同的再互相欺负一遍即可。

---

时间复杂度 $O(n+A)$，$A$ 为 $r_i$ 的值域。
### 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];
signed main()
{
	int n,x,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		a[x]++;
	}
	for(int i=1;i<=100000;i++) ans=max(ans,a[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：19)

先讲一遍我的做法。

首先可以贪心。

先排一遍序，然后从小到大依次枚举，双指针找到第一个可以用来打败当前怪物的怪物。正确性是显然的，因为你用更强的怪物打败当前的，或者直接把当前的架空，肯定都不会更优。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[100010];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    int now=0;
    for(int i=1;i<=n;i++)
    {
        now++;
        while(now<=n&&a[now]<=a[i])now++;
        if(now==n+1)
        {
            cout<<n-i+1<<endl;
            break;
        }
    }
    return 0;
}
```

但是考场上我代码能力显著降低，写着写着还写出了 bug，调还调了好久。

---

然后讲一下看起来更厉害的做法。

原问题等价于把整个序列分成若干条子序列，满足每个子序列中元素两两不同。因为只要两两不同就可以从最强的一直打败到最弱的。显然不可能一次塞两个相同值进入一个子序列。

然后显然可以构造了。当前这条子序列，最优的情况显然可以把所有个数还 $>0$ 的值全都拿走一个。

那答案显然就是众数个数了。

其实你考试开始前看下发样例就能看出这一点。

```cpp
#include<iostream>
using namespace std;
int n,c[100010];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        c[x]++;
    }
    int maxn=0;
    for(int i=1;i<=100000;i++)maxn=max(maxn,c[i]);
    cout<<maxn<<endl;
    return 0;
}
```

这份代码显然是非常好写，怎么写都出不了 bug。

---

## 作者：MatrixGroup (赞：18)

形式化地考虑这个问题。若 $i$ 成功攻击了 $j$，我们连一条 $i\to j$ 的边。可以发现：

- 每个点的出度至多为 $1$。这是因为一只怪兽在整场游戏中至多只能发起一次攻击。
- 每个点的入度至多为 $1$。这是因为一只怪兽被成功攻击了就不再参与到剩下的游戏中。
- 图中不存在环。这是因为如果 $i$ 成功攻击 $j$，必须有 $r_i>r_j$，而 $>$ 是严格弱序关系，不存在环。

这说明图由若干链构成。更进一步的，如果能连出这样的若干链，则一定可以达成。（每条链按照顺序攻击即可。）而每条链最终会恰好留下一个点。所以，我们要找的是，所有的怪兽，在 $r$ 的严格小于关系下，至少要拆成多少条链才能覆盖所有。

具体的，我们定义 $(i,r_i)$ 的偏序关系为 $(i,r_i)\le (j,r_j)$ 当且仅当 $r_i<r_j$ 或 $i=j$。显然这是一个偏序关系。我们要找到它的一个最小链覆盖。根据 Dilworth 定理，最小链覆盖等于最长反链，也就是最多的两两不偏序的怪兽个数。两两不偏序即要求所有 $r$ 相等，因此统计 $r$ 中众数的出现次数即可。

---

## 作者：ShiRoZeTsu (赞：16)

由于每个怪兽至多只能发出一次攻击，所以我们要物尽其用，让那些攻击力比较小的先去攻击，然后再被其它怪兽消灭。我们记 $cnt_i$ 表示攻击力大小为 $i$ 的怪兽个数。

```cpp
for(int i = 1; i <= n; i++) cnt[r[i]]++;
```

再记 $now$ 表示当前被遍历过的怪兽中有多少还没有被消灭。用一个循环去从小到大枚举所有攻击力，假设当前枚举到的攻击力大小为 $i$，那么此时至多只能消灭 ${\rm min}(cnt_i, now)$ 个怪物，记为 $x$。令 $now$ 减去 $x$ 表示消灭 $x$ 个怪物，然后将新遍历到的 $cnt_i$ 个怪物加到 $now$ 里面，这样就做完了。

```cpp
int now = 0;
for(int i = 1; i <= m; i++) {
    int x = min(cnt[i], now);
    now -= x;
    now += cnt[i];
}
```

最终 $now$ 的值即为答案。

---

## 作者：SunsetVoice (赞：15)

来一个严格 $O(n)$ 做法。

对 $a$ 建桶，然后排除掉未出现的数。

对于每一个出现过的值，先将其加入未淘汰总数 $k$，再看比其高一级的题目数量是否大于总数。如果大于则清 $0$ 后已消除的数加 $k$（显然你不可能凭空消除一个数），否则相减后加值即可。

容易发现，这时每一个 $r_i$ 已经尽可能淘汰了一个比其小的数（表现 $k$ 的消除）。


```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
using namespace std;
int n,r[200001] = {0},b[200001] = {0},a[200001] = {0},an; 
signed main(){
	cin.tie();
	cout.tie();
	cin>>n;
	for(int i = 1;i<=n;i++)cin>>r[i];
	for(int i = 1;i<=n;i++){
		b[r[i]]++;
	} 
	for(int i = 1;i<=150000;i++){
		if(b[i]!=0){
			a[++an] = i;
		}
	}
	int ans = 0,k = 0;
	for(int i = 1;i<=an;i++){
		k+=b[a[i]];
		if(b[a[i+1]]>k){
			ans+=k;
			k = 0;
		}else{
			k-=b[a[i+1]];
			ans+=b[a[i+1]];
		}
		
	}
	cout<<n-ans<<endl;
	return 0;
}

```

---

## 作者：fast_photon (赞：14)

# 1. 题目分析
首先，由于 $r$ 既是攻击又是防御，所以 $i$ 打败 $j$ 当且仅当 $r_i>r_j$。  

然后，因为每个怪兽最多打败一个怪兽，又最多被一个怪兽打败，那么把每个怪兽向它打败的怪兽（若有）连一条边，就会形成若干条链，满足每条链上的属性值沿着链的方向**严格递减**。要求的答案就是链头（没有被打败的怪兽）的最小数量。  

一条链如果不是递减的，又希望只用这条链上原有的怪物组成一条递减的链，就可以对链上的属性值进行**排序**，此时要求链上的属性值**互不相同**，才能做到严格递减。  

问题被转化成，最多把给定的数分成多少堆，使得每一堆内部都没有相同的数。考虑先开好多好多堆，把每种数从第一堆开始每堆放一个，放完为止，最后把没有数的堆删掉。那么答案就是**出现最多**的数的出现次数。又因为这些数两两不在一个堆里，所以至少需要这么多堆，于是这是最优的。  

这里有一个图辅助理解。
![](https://cdn.luogu.com.cn/upload/image_hosting/5ff2gqej.png)

# 2. 算法实现  
发现 $r_i$ 较小，可以使用一个 `cnt` 数组对每种数的个数进行统计，再取出现次数的最大值即可。因为在统计个数过程中每个数的个数只会越来越多，所以边统计个数边维护最大值不会影响正确性。 

# 3. 代码  
```cpp
#include<iostream>

using namespace std;

int n, a, cnt[1000005], ans;

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a;
		cnt[a]++;
		ans = max(ans, cnt[a]);
	}
	cout << ans;
}
```

---

## 作者：_Weslie_ (赞：7)

CSP-S 时的我 be like：$10$ 分钟切 T1，$1$ 小时写完 T2T3 暴力，后面两个半点死磕 T2，喜提 $60$ 分。

## Soluiton P11231

### Idea

拿到题目就发现这是一道贪心题。

不难发现一只怪兽要对答案有贡献，就必须要杀一个比它小的怪兽，除非已经没有比它小的了。

所以我们先对怪兽的攻击力排序，用双指针维护当前位置和最后一个比它小的位置。

至于为什么要排序：

假如现在有攻击力分别为 $a,b,c$ 的三只怪兽，其中 $a>b>c$。

则我们如果想让存活怪兽数最少，肯定先让 $b$ 先吃 $c$，然后再让 $a$ 吃 $b$，不然 $b$ 就没有贡献了。

所以要排序满足单调性。

考场上写了个从大到小排序然后倒序枚举的抽象代码，凑合看吧。

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int a[N],n;
bool cmp(int _,int __){
	return _>__;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1,cmp);
	int ans=n;
	for(int i=n,j=n;i>=1;i--){
		if(a[i]>a[j]){
			j--;
			ans--;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：SSqwq_ (赞：7)

## 题意

原题链接：[Link](https://www.luogu.com.cn/problem/P11231)

形式化地，给你一个 $n$ 个数的数组 $a$，即求 $a_j>a_i$ 的最多匹配对数，每一个下标只能出现在一对匹配中。

## 分析

本题可以使用双指针法贪心解决。对数组排序后维护一个指针 $t$ 指向当前未被匹配的最小元素，再从小到大枚举每一个元素能否与其进行匹配，若能匹配则将指针右移并记录答案即可。

贪心证明：若最优方案中 $a_j>a_t$ 但是 $a_j$ 不与 $a_t$ 进行匹配，那么 $a_j$ 就要与 $a_k$ 进行匹配（其中 $a_k>a_t$），但是 $a_j$ 不一定大于 $a_k$，故 $a_j$ 与 $a_t$ 匹配一定是不劣的。证毕。

时间复杂度 $O(n\log n)$，足以通过此题。

## AC Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000001];
void work(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	int t=1,ans=n;
	for(int i=2;i<=n;++i){
		if(a[i]>a[t]){
			t++;
			ans--;
		}
	}
	cout<<ans<<"\n";
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--){
		work();
	}
	return 0;
}
```

---

## 作者：wwwidk1234 (赞：6)

2025.1.8 纠正：「建立两个大根堆」有误，应为「建立两个小根堆」

思路：先从 $r_i \le 2$ 入手，容易发现要使剩下的怪兽最少，必须要让每个 $r=2$ 的怪物杀死一个 $r=1$ 的怪物。

试着将结论推广到 $r \le 10^5$ 的情况，只需要让一只怪兽杀死一只防御力**和自己攻击力最接近且比自己攻击力小**的怪物。比如对于以下怪兽：

${\color{red}6,6},{\color{blue}5},{\color{green}4,4},{\color{brown}3},{\color{purple}1}$

可以进行以下操作：

1. 让一只 $r=3$ 的怪兽杀一只 $r=1$ 的怪兽：${\color{red}6,6},{\color{blue}5},{\color{green}4,4},{\color{brown}3},{\color{purple}\xcancel{1}}$

2. 让一只 $r=4$ 的怪兽杀一只 $r=3$ 的怪兽：${\color{red}6,6},{\color{blue}5},{\color{green}4,4},{\color{brown}\xcancel{3}},{\color{purple}\xcancel{1}}$

3. 让一只 $r=5$ 的怪兽杀一只 $r=4$ 的怪兽：${\color{red}6,6},{\color{blue}5},{\color{green}4,\xcancel{4}},{\color{brown}\xcancel{3}},{\color{purple}\xcancel{1}}$

4. 让两只 $r=6$ 的怪兽杀一只 $r=4$ 和一只 $r=5$ 的怪兽：${\color{red}6,6},{\color{blue}\xcancel{5}},{\color{green}\xcancel{4},\xcancel{4}},{\color{brown}\xcancel{3}},{\color{purple}\xcancel{1}}$

对于 $r=1$ 的怪兽，只需要让它挠一下 $r \ge 1$ 的怪兽即可。因为敌方防御力大于等于自己攻击力，所以本次攻击无事发生。

我们只需要建立两个**小根堆**（即优先队列，C++ 中的 `priority_queue`）维护一个杀手队列和一个猎物队列，将每个 $r$ 加入，当杀手队列非空的时候进行如下操作：

- 如果当前杀手、猎物队列队首元素 $k_1,m_1$ 满足 $k_1>m_1$，即当前杀手攻击力大于猎物防御力时，说明杀手可以杀死猎物，弹出杀手和猎物队列的首元素。
- 否则，说明杀手杀不死猎物，只需弹出杀手队列的首元素即可。

时间复杂度 $O(n \log n)$，足以通过本题。

```cpp
/*
  期望得分:100pts
  算法:贪心
  思路:优先队列,让一只攻击力尽量小的怪兽杀死一只防御力差不多的怪物
  5oiR5piv6YKj57u06I6x54m555qE54uX
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
constexpr int N=1e5+7;
int a[N];
priority_queue<int,vector<int>,greater<int>> killer,mob;
//杀手和猎物
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) 
	{
		killer.push(a[i]);
		mob.push(a[i]);
	}
	while(!killer.empty())
	{
		int k1=killer.top();killer.pop();
		int m1=mob.top();
		if(k1>m1) mob.pop();
	}
	cout<<mob.size();
	return 0;
}
```

---

## 作者：doujiamu (赞：5)

# P11231 二叉堆做法
  
[题目链接](https://www.luogu.com.cn/problem/P11231)  
[前置知识](https://www.luogu.com.cn/problem/P3378)  


## 分析  
  考虑贪心，所有**被攻击的卡**与**攻击的卡**均构成单调增的序列，给出证明。  
  题目要求：  
- 每张卡牌只能攻击属性比自己小的卡
- 最后剩下的卡要求尽可能小  

所以我们要保证以下两点
- 一张卡能被攻击**当且仅当**它无法攻击任何卡
- 一张卡能攻击另一张卡**当且仅当**它无法攻击比这张更小的卡  

所以**被攻击的卡**与**攻击的卡**均构成单调增的序列  

排序方法有很多种，我认为二叉堆（优先队列）应该有更高的编写效率和可读性。

时间复杂度 $O(n\log{n})$ 足以通过本题

## 参考AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int n, ans;
const int maxn = 1e5 + 7;
priority_queue<int, vector<int>, greater<int>> q, b; //小根堆

signed main(){
	ios::sync_with_stdio(false);cin.tie(nullptr);
	
	cin >> n;
	
	for(int x, i = 1; i <= n; ++i){
		cin >> x;
		q.push(x);
	}
	
	b = q;
	ans = n;
	while(!q.empty()){
		int cmp_p = q.top();
		while(!b.empty()){
			if(b.top()>cmp_p){
				b.pop();
				ans--;
				break;
			}
            b.pop();
		}
        q.pop();
	}
	
	cout << ans;
	
	return 0;
}
```
## 参考二叉堆实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int w[1000007],op,z,n;
int tot;

void modify(int x){
	if(x==1||w[x]>w[x/2]){return ;}
	swap(w[x],w[x/2]);
	modify(x/2);
}

void push(int x){
	w[++tot]=x;
	modify(tot);
}
int top(){return w[1];}

void repair(int x){
	if(x*2>tot)return;
	int tar=x*2;
	if(x*2+1<=tot){
		tar=w[x*2]<w[x*2+1]?x*2:x*2+1;
	}
	if(w[tar]<w[x]){
		swap(w[tar],w[x]);
		repair(tar);
	}
}

void pop(){
	swap(w[1],w[tot--]);
	repair(1);
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
    	scanf("%d",&op);
    	if(op==1){
    		scanf("%d",&z);
    		push(z);
    	}
    	else if(op==2){
//    		for(int i=1;i<=tot;++i)printf("%d  ]\n",w[i]);
    		printf("%d\n",top());
        }
    	else{
    		pop();
    	}
    }

	
	return 0;
}
```

---

## 作者：呼吸之野 (赞：3)

第一次打 S 组，遇到了最简单的 CSP-S 第一题。

### Solution

利用贪心的思想，按 $r_i$ 从小到大排序后依次将每只怪物加入游戏（ $r_i$ 相等的怪物同时加入），则当前加入游戏的怪物一定能杀死前面的怪物，定义 $live$ 为当前存活的怪物数， 则每次将怪物加入游戏时 ，让 $live$ 减去当前加入的怪物数目（注意特判加入游戏怪物数目 $>$ 存活的怪物数时， $live = 0$ ），再将 $live$ 加上当前加入的怪物数目即可 。

这里为了优化时间复杂度加了离散化，事实上不加也能通过本题。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+5;
int n,r[maxn],tong[maxn],cnt,live; 
int main(){
	cin>>n; 
	for(int i=1;i<=n;i++){
		cin>>r[i];
	}
	sort(r+1,r+1+n);
	for(int i=1;i<=n;i++){
		if(r[i] == r[i-1]) tong[cnt]++;
		else tong[++cnt]++;
	}
	for(int i=1;i<=cnt;i++){
		live = max(0,live-tong[i]);
		live += tong[i];
	}
	cout<<live;
	return 0;
}
```

---

## 作者：OIer6666 (赞：2)

## 解题思路
已知怪兽 $i$ 只能对防御力低于它的怪物发起攻击。

那我们用桶将它们存起来，再用高防御力的怪物打低防御力的怪物不就可以了？

## 代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t[123456];//桶
int main(){
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	while(n--){
		int x;
		cin>>x;//将防御力存进桶里
		t[x]++;
	}
	int ans=0;
	for(int i=1;i<=100000;i++){
		ans=max(0,ans-t[i]);//拿高防御力怪兽打低防御力怪兽
		ans+=t[i];
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Phartial (赞：2)

考虑从值域角度入手，从小到大将每个怪兽加入这局游戏。由于 $r_i$ 相同的怪兽两两之间都破不了防，不妨将它们同时加入游戏。

设游戏中还留着 $p$ 只怪兽，且接下来我们要加入 $x$ 只能力值更大的怪兽。由于在之后加入的能力值更大的怪兽的视角中，原先的 $p$ 只怪兽和新加的 $x$ 只怪兽并无不同，因此我们肯定希望留给之后的怪兽尽可能少，也就是贪心地尝试击败现有的怪兽。

于是我们会击杀原先的 $\min(p,x)$ 只怪兽，剩下的怪兽数就是 $p+x-\min(p,x)=\max(p,x)$。

模拟此过程即可，时间复杂度 $\Theta(n)$。

```cpp
#include <iostream>

using namespace std;

const int kV = 1e5 + 1;

int n, c[kV];

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 1, x; i <= n; ++i) {
    cin >> x;
    ++c[x];
  }
  int p = 0;
  for (int i = 1; i < kV; ++i) {
    p = max(p, c[i]);
  }
  cout << p;
  return 0;
}
```

---

## 作者：__Allen_123__ (赞：2)

### 题意简述

给定 $n$ 个数，你可以让一个数去攻击**另一个**数，设攻击的数为 $a_i$ 而被攻击的数为 $a_j$，而后：

- 如果 $a_i>a_j$，则 $a_j$ 被删除。
- 如果 $a_i\le a_j$，则无事发生。

特别地，同一下标的数字只能攻击其他数一次。

求最后最少剩余的数字数量。

### 题目分析

考虑贪心地求解，我们不难发现一个结论：

> 对于一个数 $a_i$，使用最小的大于它的数 $a_j$ 攻击它是最优的。
>
> **证明**：设 $a_k>a_j>a_i$。如果使用 $a_k$ 去攻击 $a_i$，则之后的 $a_k$ 将“失去行动能力”，无法继续攻击比它更小的数。反之，如果使用 $a_j$，则 $a_i$ 和 $a_j$ 间没有待被攻击的数，无需用更大的数来攻击两者之间的数，从而答案最优。

据此进行排序和贪心即可。通过使用 `std::vector` 可以实现尾端插入和删除，实现起来较为方便。

### 代码

```cpp
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y);x <= (int)(z);x++)
#define per(x, y, z) for(int x = (y);x >= (int)(z);x--)
#define all(x) x.begin(), x.end()
int n, x;
vector<int> vec; 
signed main(){
	scanf("%d", &n);
	rep(i, 1, n){
		scanf("%d", &x);
		vec.pb(x);
	}
	sort(all(vec), greater<int>());
	per(i, n - 1, 0){
		if(i == (int)vec.size() - 1 || vec[i] == vec.back()){
			continue;
		}
		vec.pop_back();
	}
	printf("%d", (int)vec.size());
	return 0;
}
```

---

## 作者：wangif424 (赞：1)

有 $n$ 张卡牌，第 $i$ 张卡牌的属性为 $r_i$。每张卡牌**至多**可以攻击一张其他卡牌，当攻击的卡牌属性大于被攻击的卡牌时，被攻击的卡牌离场。求**当前场上**所有卡牌都攻击过一次时，最少的在场卡牌数。

## 解法一

一个显然的贪心是从小到大的遍历，用尽可能小的卡牌将当前的卡牌赶下场。


我们考虑这个思路的正确性。

- 我们在最优情况下会希望每次删除一个不能再删除其他数的数，被删数严格小于删数，那么我们的删除序列就形如一堆严格上升序列。

- 最终的答案即为序列数，那么最小化这个序列数，就是让每一个尽可能长，将每个数尽可能排到接近自己的数后面即可。

## 解法二

本题答案为众数的出现次数，证明：

延用解法一中的严格上升序列数，分别考虑众数和非众数所放的子序列。

由于我们的序列可以任意排序，故我们可以将每个序列视作集合，只需要关心塞进去了哪些数。

- 对于众数，两个相同的数字不可能在同一个集合中，故集合数不可能小于众数出现次数。

- 对于非众数，一定可以在众数出现次数个集合中找到足够数量的集合将每个数字分别塞进去。

## 代码（仅解法一）

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define R(x) x = read()
#define int long long
using namespace std;
char pbuf[1<<20], *pp=pbuf;
inline void push(const char &c){(pp-pbuf==1<<20)?fwrite(pbuf,1,1<<20,stdout),pp=pbuf,*pp++=c:*pp++=c;}
class io {public:~io() {fwrite(pbuf, 1, pp - pbuf, stdout);}} _;
inline void write(int x) {
	x<0&&(push('-'),x=-x);
	static int sta[60]={},top=0;
	do{sta[top++]=x%10,x/=10;}while(x);
	while(top)push(sta[--top]^'0');
}
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){ch=='-'&&(f=-1);ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
constexpr int N=1e5+100;
int n,r[N];
set<pii> s;
int cnt;
signed main(){
	R(n);
	for(int i=1;i<=n;i++)s.emplace(pii(R(r[i]),i));
	sort(r+1,r+1+n);
	for(int i=1;i<=n;i++){
		auto it=s.upper_bound(pii(r[i],n+1));
		if(it!=s.end())s.erase(it);
		else cnt++;
	}
	write(cnt);
    return 0;
}

```

---


# 微观戏剧

## 题目背景

$$
\begin{array}{cr}
\text{不　我不会说　那愚蠢的诅咒}\\
\text{因为你和我　都不被神明保佑}\\
\text{跃动着右心而降生的我}\\
\text{将一切标为}\overset{\text{Unaccepted}}{\text{不接受}}\\
&\text{——《微观戏剧》}
\end{array}
$$

![](bilibili:BV1DY4y1q7S4)

---

在数不尽层数的世界中，迷失在回忆中的少女，寻找着不知是否存在的「真实」。

决定了起点和终点后，你能帮助泠珞，找出如何最快地追寻她想要知道的真相呢？

## 题目描述

有一个 $10^{100}$ 个结点的无向图，结点从 $1$ 到 $10^{100}$ 编号，每对结点 $u$ 与结点 $v$ 之间都有一条长度为 $\operatorname{lcm}(u,v)$ 的边连接。$\operatorname{lcm}(u,v)$ 是指 $u$ 和 $v$ 的最小公倍数，即最小的能被 $u$ 和 $v$ 同时整除的正整数。

有 $q$ 次询问，每次给定 $x,y$，问结点 $x$ 到结点 $y$ 的最短路径长度是多少。

## 说明/提示

**【样例 #1 解释】**

对于第一组数据，最优路径是 $3\to 6$，路径长度为 $\operatorname{lcm}(3,6)=6$。可以证明**不存在**更短的路径。

**【数据范围】**

**本题采用捆绑测试**。

对于 $100\%$ 的数据，$1\le q\le 2\times10^5$，$1\le x,y\le 1\times10^{18}$。

| 子任务编号 | 分值 | $q\le $ | $x,y\le $ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $2$ | $1$ | $5$ |
| $2$ | $5$ | $1$ | $3\times10^3$ |
| $3$ | $17$ | $100$ | $2\times10^5$ |
| $4$ | $29$ | $2\times10^5$ | $1\times10^9$ |
| $5$ | $47$ | $2\times10^5$ | $1\times10^{18}$ |


## 样例 #1

### 输入

```
4
3 6
1 4
2 5
314652 314652```

### 输出

```
6
4
7
0```

# 题解

## 作者：cff_0102 (赞：20)

当 $x=y$ 时，直接输出 $0$ 即可。

由于两个数之间的连边长度为它们的最小公倍数，而 $a$ 和 $b$ 的最小公倍数必然大于等于 $a$ 和 $b$，所以要从 $x$ 走到 $y$，中间经过的最大的边必然大于等于 $x$ 和 $y$。

当 $x$ 和 $y$ 存在倍数关系，那么它们之间就连了一条长为 $\max{(x,y)}$ 的边，根据之前的推理，直接走这条边显然是最优的，因为不可能存在长度小于它的路径了。

如果 $x$ 和 $y$ 不存在倍数关系，那么有两种可行的做法：

1. 直接从 $x$ 走到 $y$。
2. 从 $x$ 出发，经过若干个“中转点”，再走到 $y$。

前者的路径长度为 $\operatorname{lcm}(x,y)$。至于后者，考虑走的第一条和最后一条边，它们的长度必然分别大于等于 $x$ 和 $y$，所以最终路径的长度不可能小于 $x+y$。而从 $x$ 走到 $1$，再从 $1$ 走到 $y$ 的做法的最终路径长度恰好即为 $x+y$，因此这样做的最短路径长度为 $x+y$。

当 $x,y$ 不存在倍数关系时，$\operatorname{lcm}(x,y)\ge2\times\max(x,y)>x+y$，因此 $x+y$ 是更优的答案。此时输出 $x+y$ 即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int t;cin>>t;while(t--){
		int x,y;cin>>x>>y;
		int a=__gcd(x,y);
		if(x==y)cout<<0<<endl;
		else if(a==x)cout<<y<<endl;
		else if(a==y)cout<<x<<endl;
		else cout<<x+y<<endl;
	}
	return 0;
}
```

---

## 作者：Zhao_daodao (赞：5)

# P11275 微观戏剧

## Description

对于一个无限个点的无向图，其中 $i$ 连向 $j$ 的边的边权为 $\operatorname{lcm}(i,j)$。

每一次询问 $u$ 走到 $v$ 的最小边权和。

$q\le 2\times 10^5,1\le u,v\le 1\times 10^{18}$。

## Solution

需要特判：如果 $u=v$，那么答案为 `0`。

设 $i$ 走向 $j$ 的边权为 $w(i,j)$。

首先，显然有一种走法，就是直接从 $u$ 走向 $v$，边权和是 $\operatorname{lcm}(u,v)$。

不然，分类讨论其他的走法。

1. 只经过一个点 $x$。

   当前答案：
   $$
   Ans=w(u,x)+w(x,y)\\
   \ge u+v\\
   =w(u,1)+w(1,v)
   $$

2. 经过不止一个点，设从 $u$ 走出去的第一个点为 $p_1$，走回 $v$ 的最后一个点为 $p_m$。

   $m$ 是除了 $u$ 和 $v$ 的其他点的数量。

   当前答案：
   $$
   Ans=w(u,p_1)+w(p_1,p_2)+\cdots+w(p_{m-1},p_{m})+w(p_m,v)\\
   \ge w(u,p_1)+w(p_m+v)\\
   \ge u+v\\
   \ge w(u,1)+w(1,v)
   $$

显然，能够发现所有走法都不优于从 $u$ 走到 `1` 再走回 $v$。

所以答案就是 $\min(\operatorname{lcm}(u,v),u+v)$。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define ll __int128_t
using namespace std;
inline int Gcd(int x,int y){
    while(y)swap(x=x%y,y);
    return x;
}
inline void solve(){
    int n,m;cin>>n>>m;
    if(n==m){
        cout<<"0\n";
        return ;
    }
    ll ans=n+m;
    ll ano=(ll)n*m/Gcd(n,m);
    int res;
    if(ans<ano)res=ans;
    else res=ano;
    cout<<res<<"\n";
}
signed main(){
    cin.tie(0);
    cout.tie(0);
    ios::sync_with_stdio(false);
    int T;cin>>T;while(T--)solve();
}
```

---

## 作者：lby_commandBlock (赞：3)

## 思路

求每一个 $(x,y)$ 的最短路。

- 若 $x=y$，则最短路肯定是 $0$。

若两个数 $x,y$ 互质，则他们的最小公倍数就是 $x \times y$。若 $x,y \ge 2$，则 $x \times y$ 肯定大于 $x + y$。

那要怎么凑成 $x+y$ 呢？考虑到任何一个数 $x$ 与 $1$ 的最小公倍数都是 $x$，所以可以直接认为路径是 $x \to 1 \to y$ 的。
 
所以每一个到每一个 $(x,y)$ 仅有两种情况：

- $x+y$；
- $\operatorname{lcm}(x,y)$。

两种情况**取最小**即可。由于数据过大，需要使用 `__int128`。由于使用了 `__int128`，所以 `lcm`、`min` 函数等**需要重建**。

## 赛时满分代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;

int q;

int x, y;

// 函数重建

__int128 gcd(__int128 x, __int128 y) {
	if (x % y == 0)
		return y;
	else
		return gcd(y, x % y);
}

__int128 lcm(__int128 x, __int128 y) {
	return x / gcd(x, y) * y;
}

__int128 min(__int128 x, __int128 y) {
	if (x < y)
		return x;
	else
		return y;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	for (cin >> q; q; q--) {
		cin >> x >> y;
		// 特判
		if (x == y) {
			cout << 0 << endl;
			continue;
		}
		// 数学归纳
		int ans = min(lcm(x, y), x + y);
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：fish_love_cat (赞：3)

什么逆天比赛时间啊。

---

首先显然 $u=v$ 时，答案是 $0$，判掉。

此时我们设 $u<v$。

然后当 $v \bmod u=0$ 时，我们直接从 $u$ 走到 $v$ 即可。此时答案是 $v$。

否则，我们从 $u$ 走到 $1$，然后再走到 $v$。此时答案是 $u+v$。

因为边权是 $\text{lcm}(u,v)$，而当两数是倍数关系时，其最小公倍数是最优秀的，所以很容易发现这么走是不劣的。

然后就做完了。

---

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
    int t;
    cin>>t;
    while(t--){
        int x,y;
        cin>>x>>y;
        if(x>y)swap(x,y);
        if(x==y)puts("0");
        else if(y%x)cout<<x+y<<'\n';
        else cout<<y<<'\n';
    }
    return 0;
}
```

---

## 作者：GCSG01 (赞：2)

### 思路
分类讨论，很显然，当 $x=y$ 时，答案为 $0$，当 $x$ 与 $y$ 为倍数关系时，答案为 $x$ 与 $y$ 中最大的那一个。考虑除此之外怎样走最优，我们先从 $x$ 走到 $1$，再从 $1$ 走到 $y$，这样只需要走 $x+y$ 步，而走到 $x,y$ 共同的倍数再折返则至少要 $2\times 2\times x \times y$ 步，这样就肯定没有先到 $1$ 更优。

### Code
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
const int N=2e5+5;
int x[N];
int y[N];
int gcd(int x,int y)
{
    if(!y)return x;
    return gcd(y,x%y);
}
signed main()
{
    #ifndef ONLINE_JUDGE
        freopen("1.in","r",stdin);
    #endif
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int q;
    cin>>q;
    for(int i=1;i<=q;i++)
    {
        cin>>x[i]>>y[i];
        if(x[i]>y[i])swap(x[i],y[i]);
        if(x[i]==y[i])cout<<"0\n";
        else if(y[i]%x[i]==0)cout<<y[i]<<"\n";
        else cout<<x[i]+y[i]<<"\n";
    }
    return 0;
}
```

---

## 作者：_lmh_ (赞：2)

如果走了 $\ge 2$ 步的话，显然第一步的耗费 $\ge x$，最后一步耗费 $\ge y$，总花费 $\ge x+y$（$x\to 1\to y$ 时取等）。

否则，走一步的话，花费就是 $\mathrm{lcm}(x,y)=\frac{xy}{\gcd(x,y)}$。

记得特判 $x=y$，开 `__int128`。

```cpp
//Happy Birthday, Ling Luo!
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=100007;
ll T,n,m;
ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>m;
		if (n==m) cout<<0<<endl;
		else cout<<(ll)min((__int128)n+m,(__int128)n*m/gcd(n,m))<<'\n';
	}
	return 0;
}
```

---

## 作者：gesic (赞：0)

如果 $x = y$，直接输出 $0$。

如果 $x$ 或 $y$ 是另一个数的倍数，输出较大的数。

否则输出 $x+y$。首先显然这种情况不能一步到位。设总共有 $k ( k \ge 2 )$ 步。第一步从 $x$ 出发，代价 $s_1 \ge x$。最后一步到达 $y$，代价 $s_k \ge y$。总代价 $S = \sum_{i=1}^{k} s_i \ge s_1 + s_k \ge x + y$。因此答案最小为 $x+y$。可以构造出一个方案 $x \to 1 \to y$ 代价为 $x+y$。

---


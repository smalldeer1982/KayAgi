# [COCI 2024/2025 #2] 谬误 / Paradoks

## 题目背景

译自 [COCI 2024/2025 #1](https://hsin.hr/coci/) T1。$\texttt{1s,0.5G}$。满分为 $50$。


## 题目描述


五个人**围坐在圆桌边上**玩游戏。顺时针方向上看过去，五个人分别是 $\text{Igor, Lea, Marino, Sonja, Viktor}$。

游戏有 $n$ 场。第一场第一个出牌的人为 $\text{Sonja}$，此后每一场第一个出牌的人都是上一场的胜者。每场中，五个人按顺时针方向上的顺序依次出牌，每个人**恰好出一次**牌。

每人手里都有 $n$ 张无色牌，编号 $1\sim n$。出牌时，选择手中的一张牌，并选择红蓝黄绿中的一种颜色涂在牌上打出。此外，我们要求，颜色和数字的组合之前没有被打出过。

每场中，第一个出牌的人打出的牌的颜色称为**场风**。每个人打的牌的颜色都应该尽可能是场风。如果没有打出场风的牌的话，那么**从此刻开始**（在接下来的场次中）他就再也不能打（**该场次**）场风的牌了。

每场中胜者的确定方式如下：

- 如果有人打出过红牌，则取打出数字最大的那个人；
- 否则，取打出牌颜色是场风中数字最大的那个人；

有时候，会有人打出的牌违反规则：牌的颜色与数字组合已经被打出过了，或者使用了被禁用的颜色。此时我们称这次出牌**谬误**（paradox）。谬误的出牌是无效的，也就是说，出的谬误牌会被忽略掉，不算入胜者的计算，（如果是第一次打出的话）也不算打出过。**保证每场第一个人出的牌不会谬误。**

给定 $n$ 场中，出的五张牌依次是什么。你需要确定这场中出现了多少个谬误，并输出谬误出现的场次，以及是谁打出了谬误。

## 说明/提示


#### 样例解释

样例 $1$ 解释见图片。

![](https://cdn.luogu.com.cn/upload/image_hosting/ww0e92lc.png)

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le n\le 10$。

| 子任务编号 | 特殊性质 | 得分 |  
| :--: | :--: | :--: | 
| $ 1 $    |  AB    |   $ 10 $   |  
| $ 2 $    |  B   |  $ 10 $   |  
| $ 3 $    |  | $ 30 $   |

- 特殊性质 A：
    - 每场比赛的胜利者都是 $\text{Sonja}$。
- 特殊性质 B：
    - 谬误的原因只有一个：打出了之前打出过的牌。


## 样例 #1

### 输入

```
4
Y5 Z3 Y6 C2 Y1
Z4 Z7 Z2 Y2 P3
Z6 Z7 Z1 Y2 C2
P6 P8 P8 Z7 Y9```

### 输出

```
6
2 VIKTOR
3 SONJA
3 LEA
4 VIKTOR
4 IGOR
4 LEA```

## 样例 #2

### 输入

```
3
P1 Y9 Z5 Y1 Z5
P5 Y7 Z3 Y8 P1
C6 Y8 P5 Z1 Z8```

### 输出

```
4
1 MARINO
2 MARINO
3 VIKTOR
3 IGOR```

## 样例 #3

### 输入

```
1
Y4 P9 Y8 Z5 Z3```

### 输出

```
0```

# 题解

## 作者：signed_long_long (赞：3)

抢到第二 A 了！发篇题解纪念一下！（疑似首 A？）
# 题目解法

按照题意模拟即可。

可以用一个数组标记一下某个颜色加数字的组合是否被打出过，用一个 $5\times 4$ 的数组标记一个人是否打出过非场风的牌以及场风。谬误可以用数组来存。没啥好说的，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,cnt=0;
bool vis[5][10];
string ans[100500];
string name[]={"","IGOR","LEA","MARINO","SONJA","VIKTOR"};
int nxt[]={0,2,3,4,5,1};
bool cant[6][5];
int an[100500];
signed main(){
	cin>>n;
	int winner=4,now=winner,changfeng;
	for(int i=1;i<=n;i++){
		int maxn=-1;
		bool flag=false;//有没有红色 
		for(int j=1;j<=5;j++,now=nxt[now]){
			char ch;
			int x,y;
			cin>>ch>>y;
			if(ch=='Y') x=3;
			else if(ch=='Z') x=4;
			else if(ch=='C') x=1;
			else x=2;
			if(vis[x][y] or cant[now][x]) {
				ans[++cnt]=name[now];
				an[cnt]=i;
				continue;
			}
			if(j==1){
				changfeng=x;
			}
			vis[x][y]=true;
			if(j!=1 and changfeng!=x){
				cant[now][changfeng]=true;
			}
			if(x==1){
				if(!flag){//第一个打出红色的 
					maxn=y;
					winner=now;
				}else if(y>maxn){
					maxn=y;
					winner=now;
				}
				flag=true;
			}
			if(!flag and x==changfeng and y>maxn){
				maxn=y;
				winner=now;
			}
		}
		
		now=winner;
	} 
	printf("%lld\n",cnt);
	for(int i=1;i<=cnt;i++){
		printf("%lld ",an[i]);
		cout<<ans[i]<<"\n";
	}
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11429)

## 思路：

按照题意**模拟**即可，但是细节较多。

1. 禁用的颜色是当时的场风而不是那个人出的牌的颜色。
1. 重复组合在全部游戏中生效，不需要清空判重数组。
1. 要特殊处理红牌。
1. 记录上一轮的胜者时不要赋到循环值，要赋当前的那个人的值。（我就因为这个被卡了十分钟）
1. 输出全部是**大写字母**！

可以利用 
```cpp
map<char,map<char,bool > >f;
```
存重复出现的组合，再用

```cpp
map<int,map<char,bool > > jy;
```
存被禁用的颜色，会方便很多。

## 完整代码：


```cpp
#include <iostream>
#include <map> 
using namespace std;
int x;
char m[10][10];
char cf;
map<char,map<char,bool > >f;//判重 
map<int,map<char,bool > > jy;//禁用 
int da1[100005],da2[100005],das=0;
int sz=3,blsz=4;
int main(){
	cin>>x;
	for(int i=1;i<=x;i++){
		sz=blsz-1;
		for(int j=1;j<=5;j++){
			sz++;
			if(sz==6) sz=1;
			cin>>m[sz][1]>>m[sz][2];
		}
		sz=blsz-1;//上一轮的胜者 
		char cf=m[sz+1][1];
		
		int fred=0,zd=-9999;
		
		for(int j=1;j<=5;j++){
			sz++;
			if(sz==6) sz=1;
			if(f[m[sz][1]][m[sz][2]]==false&&jy[sz][m[sz][1]]==false){//合法 
				if(m[sz][1]!=cf) jy[sz][cf]=true;//不是场风，禁用相应颜色 
				f[m[sz][1]][m[sz][2]]=true;//判重 
				if(m[sz][1]=='C'){//红色卡 
					if(fred==0){
						fred=1;
						zd=m[sz][2]-'0';
						blsz=sz;//不要写成blsz=i了
					}
					else{
						if(m[sz][2]-'0'>zd){
							zd=m[sz][2]-'0';
							blsz=sz;
						}
					}
					fred=1;
				}
				else{
					if(m[sz][2]-'0'>zd&&fred==0&&m[sz][1]==cf){//非红色卡 
						zd=m[sz][2]-'0';
						blsz=sz;
					}
				}
			}
			else{//不合法，记录答案 
				das++;
				da1[das]=i;
				da2[das]=sz;
			}
		}
	}
	cout<<das<<endl;
	for(int i=1;i<=das;i++){
		cout<<da1[i]<<" ";
		if(da2[i]==1) cout<<"IGOR\n";
		if(da2[i]==2) cout<<"LEA\n";
		if(da2[i]==3) cout<<"MARINO\n";
		if(da2[i]==4) cout<<"SONJA\n";
		if(da2[i]==5) cout<<"VIKTOR\n";
	}
	return 0;
}
```

---

## 作者：yyycj (赞：1)

## 题目简述
有五个人 $\text{Igor, Lea, Marino, Sonja, Viktor}$ 玩一个游戏。

游戏共有 $n$ 场。出牌顺序为刚才提到的顺序，第一场的第一个出牌的人是 $\text{Sonja}$，之后每场第一个出牌的人都是上一场的胜者，每人每场只出一张牌。

每个人可以出 $\texttt{C,P,Y,Z}$（红色，蓝色，黄色，绿色）中的一个颜色和 $1 \sim 9$ 其中一个数字的组合的牌，要求之前打出过的组合不能再次被打出。

每场第一个出牌的人出的牌的颜色称为场风。在这一场中，后面的人都应该出与场风相同颜色的牌，如果没有打出，则在之后的每一场中，他都不能出该场场风颜色的牌。

确认每场胜者方法：  

- 如果有人出过红牌，则胜者为红牌中数字最大的那个人。
- 如果没有，则胜者为与场风颜色相同的牌中数字最大的那个人。

如果有人打出了在之前已经打出过的组合，或者打出了他已经不能出的颜色，则被称为谬误。如果有人出现了谬误，则他在本场的这一场牌无效，也不参与胜者计算。保证每场第一个出牌的人不会谬误。

要求输出谬误出现的次数以及每个谬误是在哪一场出现的和发生谬误人的名字。

## 思路
不难看出这一题就是一道小/中模拟，并没有什么难的算法，但模拟主要的难点就在于细节很多且出现错误很难找，因为思路都是互相连起来的。

主要模拟方法：双重循环，在第二层循环每读入一张牌操作一次，主要操作如下：

1. 设置场风牌（第一个出牌的人）
2. 判断谬误
3. 判断是否出牌颜色为场风牌
4. 更新赢家
5. 记录卡片

最后在第二层循环结束后，更新上一场赢家，为下一场做准备。

## AC Code
```cpp
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

#define endl '\n'
typedef long long ll;
typedef unsigned int ui;
typedef pair<ll,ll> pll;
typedef pair<int,int> pii;
const double PI = acos(-1.0);
typedef unsigned long long ull;
// ----------------------------                     结构体 
struct paradox {
	int session;
	string name;
};                                               // 谬误存储结构体 
// ----------------------------                     变量 
string names[10];                                // 编号->名字
vector<paradox> paradoxes;                       // 谬误存储 
unordered_map<char,bool> ban_colors[10];         // 每个人的不可使用颜色 
unordered_map<string,bool> appeared_cards;       // 已出现的卡片 
// ----------------------------                     函数 


int main() {
	int n;
	cin>>n;
	// ------------------------
	names[1] = "IGOR";
	names[2] = "LEA";
	names[3] = "MARINO";
	names[4] = "SONJA";
	names[5] = "VIKTOR";
	string card;                                 // 输入卡片 
	char now_main_color;                         // 当前场风 
	int last_winner_idx = 4;                     // 上一场的赢家 
	for (int i=1;i<=n;i++) {
		bool flag = true;
		int max_point = 0;                       // 当前符合条件卡片最大点数 
		int now_winner_idx = 0;                  // 当前最大卡片人的编号 
		bool is_have_red = false;                // 当场是否出现了红牌 
		for (int j=last_winner_idx;j!=last_winner_idx || flag;j=j%5+1) {
			flag = false;
			cin>>card;
			if (j == last_winner_idx) now_main_color = card[0];     // 如果是第一位出牌的玩家,将场风设定为他的牌的颜色 
			if (appeared_cards[card] || ban_colors[j][card[0]]) {   // 判断是否出现谬误 
				paradoxes.push_back({i,names[j]});                  // 存储进谬误行列 
				continue;
			}
			if (card[0] != now_main_color) ban_colors[j][now_main_color] = true;         // 如果没有出场风颜色，则这个人以后都不能出这个颜色 
			// 更新赢家
			if (!is_have_red) {                  // 如果在这之前还没有出现红牌 
				if (card[0]=='C' || card[0]==now_main_color && card[1]-'0'>max_point) {  // 如果这张卡片是红色的 或者 这张卡片的颜色和场风颜色相同 且 点数大于当前最大点数 
					now_winner_idx = j;
					max_point = card[1] - '0';
				}
				if (card[0]=='C') is_have_red = true;               // 如果这张卡片是红色的,那么现在就已经出现了红牌 
			}
			else {                               // 已经出现了红牌 
				if (card[0]=='C' && card[1]-'0'>max_point) {        // 如果这张卡片也是红牌且点数大于当前最大点数 
					now_winner_idx = j;
					max_point = card[1] - '0';
				}
			}
			appeared_cards[card] = true;         // 记录卡片 
		}
		last_winner_idx = now_winner_idx;        // 将上一场赢家设为这一场赢家,为下一场做准备 
	}
	// ------------------------
	cout<<paradoxes.size()<<endl;
	for (paradox i:paradoxes) cout<<i.session<<' '<<i.name<<endl;
	return 0;
}
```

---


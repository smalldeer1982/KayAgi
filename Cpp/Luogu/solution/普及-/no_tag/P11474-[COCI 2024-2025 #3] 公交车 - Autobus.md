# [COCI 2024/2025 #3] 公交车 / Autobus

## 题目背景


译自 [COCI 2024/2025 #3](https://hsin.hr/coci/) T1。$\texttt{1s,0.5G}$。满分为 $50$。

## 题目描述

马尔纳先生决定前往位于波兰西南部的 Wrocław；但是从 Zagreb（他所在的城市）到 Wrocław 并没有直达的巴士线路，于是他只能经过奥地利城市 Graz 并进行换乘。

马尔纳先生找到了一份在 Zagreb-Graz 和 Graz-Wrocław 之间运行的巴士时刻表，其中包含了 $n$ 趟巴士的运行信息；每趟巴士**每天**都会在特定的运行线路和特定的时间运行。具体地，对于每趟巴士，该时刻表给出了它的运行线路（Zagreb-Graz 或 Graz-Wrocław），以及它的发车时间（精确到分钟，该巴士会在该分钟初发车）和到达时间（精确到分钟，该巴士会在该分钟末到达）。

换乘所需的时间可以忽略不计，即如果在下一趟巴士出发前到达换乘站点，就可以顺利换乘；但是第一趟巴士的到达时间必须**严格早于**第二趟巴士的发车时间。

确定马尔纳先生从 Zagreb 到 Wrocław 所需要的最短时间；或报告不存在任何一种乘坐巴士的方案使他可以到达 Wrocław。

## 说明/提示

### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le n\le 200$；
- 每趟巴士运行时长最多为 $24$ 小时。


| 子任务编号 | 特殊性质 | 得分 |
| :-: | :-: | :-: |
| $1$ | $n\le 3$ | $9$ |
| $2$ | 线路为 Zagreb-Graz 的巴士仅有恰好一趟 | $19$ |
| $3$ | 无 | $22$ |

## 样例 #1

### 输入

```
4
Zagreb-Graz 15:30--23:59
Graz-Wroclaw 10:42--19:15
Zagreb-Graz 14:13--20:19
Graz-Wroclaw 2:25--5:00```

### 输出

```
13:31```

## 样例 #2

### 输入

```
3
Zagreb-Graz 6:05--16:40
Zagreb-Graz 20:00--21:40
Zagreb-Graz 9:56--22:36```

### 输出

```
NEMOGUCE```

# 题解

## 作者：yi_hr (赞：5)

## 模拟
### 本题注重细节！！！
**思路：** $O(N^2)$ 暴力，其中 $N$ 为值域 $1440$。输入后将两条路径的 $t_{\texttt{发车时间}}\rightarrow t_{\texttt{到达时间}}$ 分别用两个数组记录下来，然后暴力枚举两条路径的组合，维护 $ans$ 最小值，输出即可。  
**细节：**
1. 一条路线可能横跨两天，需将结束时间 $+1440$ 分钟存储。
2. 我们选出两条路线后，若第二条路线的开始时间小于第一条路线的结束时间，第二天路线需要在下一天乘坐，即 $+1440$ 分钟。
## 代码实现
```cpp
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
inline int read(){
	register int x=0,f=1;char c=getchar();
	while(c>'9'||c<'0'){c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
const int N=1449;
int n,m1,m2,ans=INF;
string s;
int h1,t1,h2,t2;
bool f1,f2;
int a1[N],a2[N];
inline int num(int h,int m){//计算时刻，转换为分钟 
	return h*60+m;
}
inline int solve(int i,int j){
	if(a1[i]==INF||a2[j]==INF) return INF;
	return a2[j]+(a1[i]-j+1440)/1440*1440-i+1;
}
int cnt1,cnt2;
int main(){
	memset(a1,INF,sizeof(a1));
	memset(a2,INF,sizeof(a2));
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		h1=read();t1=read();h2=read();t2=read();
		//使用快读来应对题目中的输入方式 
		if(s[0]=='Z'){
			f1=1;
			cnt1=num(h1,t1);cnt2=num(h2,t2);
			if(cnt2<cnt1) cnt2+=1440;//结束时间在下一天 
			a1[cnt1]=cnt2;
		}else{
			f2=1;
			cnt1=num(h1,t1);cnt2=num(h2,t2);
			if(cnt2<cnt1) cnt2+=1440;
			a2[cnt1]=cnt2;
		}
	}
	if(!f1||!f2){
		cout<<"NEMOGUCE";
		return 0;
	}
	for(int i=0;i<=1440;i++){
		if(a1[i]==INF)continue;
		for(int j=0;j<=1440;j++){
			if(a2[j]==INF)continue;
			ans=min(ans,solve(i,j));
		}
	}
	printf("%d:",ans/60);
	if(ans%60<10)cout<<0;
	printf("%d",ans%60);
	return 0;
}
```

---

## 作者：mishitaotuoyyds (赞：3)

# 思路：
首先这是一道很恐怖的细节题，有一点错误就通过不了。

下面是几点比较容易错的。

1. 跨天要加 $1440$ 分钟。
2. 最后要加 $1$ 分钟，因为发车是每分钟开始时，而到站是每分钟末。
3. 输入时时间出问题。

# 方法：
对于第一种在算时间是只要小于等于 $0$ 就加上 $1440$ 就好了。

对于第二种在输出时加上就好了。

对于第三种在输入时用点高科技就好了，如下。
```cpp
scanf("%d:%d--%d:%d",&a,&b,&c,&d);
```
这可以直接将发车和到站的时和分读取。

然后直接以 $O(n^2)$ 暴力枚举即可。

# 参考代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,n,l[300][10],o[300][10],jl1=INT_MAX,jl2=1,kk[40400];
string e,r;
int p=1,j=1;
int main() 
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>e;
        l[p][5]+=(l[p][5]<=0)*1440;
        o[j][5]+=(o[j][5]<=0)*1440;
		scanf("%d:%d--%d:%d",&a,&b,&c,&d);//高科技输入
		if(e=="Zagreb-Graz"){
			l[p][1]=a;
			l[p][2]=b;
			l[p][3]=c;
			l[p][4]=d;
			l[p][5]=(c*60+d)-(a*60+b);
            l[p][5]+=(l[p][5]<=0)*1440;
			p++;
		}
		else{
			o[j][1]=a;
			o[j][2]=b;
			o[j][3]=c;
			o[j][4]=d;
			o[j][5]=(c*60+d)-(a*60+b);
            o[j][5]+=(o[j][5]<=0)*1440;
			j++;
		}
        
	}
	if(p==1||j==1){
		cout<<"NEMOGUCE";
		return 0;
	}
	for(int i=1;i<p;i++){
		for(int y=1;y<j;y++){
            kk[jl2]=o[y][1]*60+o[y][2]-(l[i][3]*60+l[i][4]);
            kk[jl2]+=(kk[jl2]<=0)*1440;
            kk[jl2]+=o[y][5]+l[i][5];
            jl2++;
		}
	}
    for(int i=1;i<jl2;i++)jl1=min(jl1,kk[i]);
	jl1++;
	cout<<jl1/60<<":"<<jl1%60/10<<jl1%60%10;   //输出
	return 0;
} 
```
完结撒花。

---

## 作者：wht_1218 (赞：3)

恐怖的细节题。

1. 字符串解析。整数 $x=x\times 10+y$，$y$ 表示这个位置的字符应对应的数字值。
2. 分钟数是个位数要补前导 $0$。
3. 跨天的情况。一天是 $1440$ 分钟而不是 $3600$ 分钟！！！跨天时用小的数减大的数再加上 $1440$ 分钟即可。
4. debug 的耐心。

思路就是存两个方向的车的起始时间和到达时间，$O(n^2)$ 地枚举即可。

~~我知道你们想看这个，但你们先别急~~
```cpp
#ifndef _CPP_FILE
#define _CPP_FILE
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=77;
#define il inline
#define re register
#define rei register int
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
//#define abs(x) (x>0?x:-x)
inline int abs(auto x){
	return x>0?x:-x;
}
#define imx INT_MAX
#define imn INT_MIN
#define lmx LLONG_MAX
#define lmn LLONG_MIN
#define nmx (N)
#define nmn (-N)
#define umap unordered_map
#define pii pair<int,int>
#define mset multiset

/**/
struct node{
    int st,en;
};
vector<node> v1,v2;
int n;
main(){
	cin>>n;
    for(int i=1;i<=n;++i){
        string s;cin>>s;
        string x;cin>>x;
        x+="-";
        int sth=0,stm=0,enh=0,enm=0,xx=0;
        bool f1h=0,f1m=0,f2h=0,f2m=0;
        for(int j=0;j<x.size();++j){
            if(x[j]=='-'){
                if(!f1m)stm=xx,f1m=1;
                else enm=xx;
                xx=0;
            }else if(x[j]==':'){
                if(!f1h)sth=xx,f1h=1;
                else enh=xx;
                xx=0;
            }else{
                xx=(xx<<3)+(xx<<1)+(x[j]^48);
            }
        }
        if(s[0]=='Z'){
            v1.push_back((node){sth*60+stm,enh*60+enm});
        }else{
            v2.push_back((node){sth*60+stm,enh*60+enm});
        }
    }int ans=2111111111ll;
    for(auto x:v1){
        for(auto y:v2){
            int sum=0;
            if(x.en>=y.st)sum+=1440;
            if(x.st>x.en)sum+=1440;
            sum+=(x.en-x.st);
            if(y.st>y.en)sum+=1440;
            sum+=(y.en-y.st);
            sum+=(y.st-x.en);
            ans=min(ans,sum);
        }
    }
    if(ans==2111111111ll)return cout<<"NEMOGUCE",0;
    ans++;// 不加这个过不了样例，忘了 why 了。
    cout<<ans/60<<":"<<ans%60/10<<ans%60%10;
	return 0;
}
#endif

```

---

## 作者：hwc2011 (赞：2)

本题细节：
1. 出发时间必须**严格早于**到达时间。
2. 第二次坐车的出发时间**严格早于**第一次坐车的到达时间。
3. 分钟必须输出**两位数**。
4. 输入格式。

注意好这些细节就好做了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h1,m1,h2,m2,cnt1,cnt2;
string s;
char c1,c2,c3,c4;
struct Node{
	int st,ed;
}p1[205],p2[205];
int main(){
	scanf("%d\n",&n);
	for(int i=1;i<=n;i++){
		cin>>s>>h1>>c1>>m1>>c2>>c3>>h2>>c4>>m2;
		int st=h1*60+m1,ed=h2*60+m2;
		ed+=(st-ed+1440)/1440*1440;
		if(s[0]=='Z') p1[++cnt1]={st,ed};
		else p2[++cnt2]={st,ed};
	}
	int ans=1e9;
	for(int i=1;i<=cnt1;i++) for(int j=1;j<=cnt2;j++){
		Node t1=p1[i],t2=p2[j];
		t2.ed+=(t1.ed-t2.st+1440)/1440*1440;
		ans=min(ans,t2.ed-t1.st+1);
	}
	if(ans<1e9){
		cout<<ans/60<<':';
		if(ans%60<10) cout<<0;
		cout<<ans%60;
	}
	else cout<<"NEMOGUCE";
}
```

---

## 作者：mozhao (赞：1)

# 题意：
给你 $n$ 条路线，有不同的出发时间和结束时间，分为两条路线，必须各走一条，求加起来的最短时间。
## 大体思路：
先分为两个数组，分别为 $bus1$ 和 $bus2$，各存从 $Z$ 出发路线的每一个时间和从 $G$ 出发路线的每一个时间。去遍历每一对有输入的可能性，算出总时间并取最小值。

求时间的方法：

1：不过一天直接求。

2：过了一天用 $1440$ 分钟减去反过来正常求的即可。
### 核心代码：

```cpp
if(bus[i].t1<=bus[i].t3&&bus[i].t2<=bus[i].t4) {
	bus[i].t5=(bus[i].t3-bus[i].t1)*60+bus[i].t4-bus[i].t2;
}
if(bus[i].t1<=bus[i].t3&&bus[i].t2>=bus[i].t4) {
  bus[i].t5=(bus[i].t3-bus[i].t1-1)*60+60-bus[i].t2+bus[i].t4;
}
if(bus[i].t1>=bus[i].t3&&bus[i].t2<=bus[i].t4) {
  bus[i].t5=1440-((bus[i].t1-bus[i].t3-1)*60+60+bus[i].t2-bus[i].t4);
}
if(bus[i].t1>=bus[i].t3&&bus[i].t2>=bus[i].t4) {
  bus[i].t5=1440-((bus[i].t1-bus[i].t3)*60-bus[i].t4+bus[i].t2);
}
```
最后一个提醒：记得加前导 $0$！！！

完结撒花

---

## 作者：_lxc__ (赞：1)

恶心的模拟，很难调，细节太多了我调了将近四十分钟，而且我这个仁济提交时发现 $50$ 分还以为没过。
### 思路

* 首先将输入的信息分为两类存入 vector 中，一类为 Zagreb-Graz 的车，另一类为 Graz-Wrocław 的车。
* 再将每一辆车的发车和到达时间计算出来，个人认为这是最恶心的一步。
* 接着遍历两个 vector，枚举所有可行解找到最优解。**注意**这里要考虑车辆跨天的情况，这是很大的坑。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=2e9;
struct node{
	int start,end;
};
vector<node> ztog,gtow;   //两种车
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		string id,time;
		cin>>id>>time;
		int start=0,starthour=0,startminiute=0,end=0,endhour=0,endminiute=0,pos=0;
		for(int j=0;time[j]>='0'&&time[j]<='9';j++){
			starthour=starthour*10+time[j]-'0';
			pos++;
		}
		pos++;
		for(int j=pos;time[j]>='0'&&time[j]<='9';j++){
			startminiute=startminiute*10+time[j]-'0';
			pos++;
		}
		pos+=2;
		start=starthour*60+startminiute;
		for(int j=pos;time[j]>='0'&&time[j]<='9';j++){
			endhour=endhour*10+time[j]-'0';
			pos++;
		}
		pos++;
		for(int j=pos;time[j]>='0'&&time[j]<='9';j++){
			endminiute=endminiute*10+time[j]-'0';
		}
		end=endhour*60+endminiute;   //计算出发和到站时间
		if(id[0]=='Z') ztog.push_back({start,end});
		else gtow.push_back({start,end});
	}
	for(auto i:ztog){
		for(auto j:gtow){   //枚举所有情况
			int now=0;
			if(i.end>=j.start) now+=1440;
			if(i.start>i.end) now+=1440;    //跨天特判
			now+=(i.end-i.start);   //Zagreb-Graz的时间
			if(j.start>j.end) now+=1440;
            now+=(j.end-j.start);   //Graz-Wrocław的时间
            now+=(j.start-i.end);
            ans=min(ans,now+1);   //记得将 now+1
		}
	}
	if(ans==2e9) cout<<"NEMOGUCE";   //无解
	else cout<<ans/60<<":"<<ans%60/10<<ans%60%10;   //输出
	return 0;
}

```

---

## 作者：Andy1101 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P11474)
# 思路
$O(n^2)$ 枚举。
## 易错点
1. 第一趟巴士的到达时间必须**严格早于**第二趟巴士的发车时间。
   
    ```cpp
    int t1=a[i].start_time_h*60+a[i].start_time_m; //第一趟巴士的发车时间
    int t2=a[i].end_time_h*60+a[i].end_time_m; //第一趟巴士的到达时间
    int t3=a[j].start_time_h*60+a[j].start_time_m; //第二趟巴士的发车时间
    int t4=a[j].end_time_h*60+a[j].end_time_m; //第二趟巴士的到达时间
    int ans=(t2+1440-t1)%1440;
    int t=(t3+1440-t2)%1440;
    if(t==0) t=1440; //要严格早于
    ans=ans+t;
    ans=ans+(t4+1440-t3)%1440;
    ans++; //这里要+1
    minx=min(minx,ans);
    ```
    
2. 分钟数始终包含两位数。
   
    ```cpp
    if(minx%60/10==0) cout<<"0"<<minx%60;
    else cout <<minx%60;
    ```
# AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=200+5;
#define int long long
struct node
{
	char startp; //起点
	char endp; //终点
	int start_time_h; //发车的时
	int start_time_m; //发车的分
	int end_time_h; //到达的时
	int end_time_m; //到达的分
} a[N];
signed main()
{
	int n;
	cin >>n;
	for(int i=1;i<=n;i++) //复杂的输入
	{
		string s;
		int x;
		char c;
		cin >>s;
		int len=s.size();
		a[i].startp=s[0];
		for(int j=1;j<len;j++)
		{
			if(s[j]=='-')
			{
				a[i].endp=s[j+1];
				break;
			}
		}
		cin >>x;
		a[i].start_time_h=x;
		cin >>c>>x;
		a[i].start_time_m=x;
		cin >>c>>c>>x;
		a[i].end_time_h=x;
		cin >>c>>x;
		a[i].end_time_m=x;
	}
	int minx=INT_MAX;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i].startp=='Z' && a[i].endp=='G')
			{
				if(a[j].startp=='G' && a[j].endp=='W')
				{
					int t1=a[i].start_time_h*60+a[i].start_time_m; //第一趟巴士的发车时间
					int t2=a[i].end_time_h*60+a[i].end_time_m; //第一趟巴士的到达时间
					int t3=a[j].start_time_h*60+a[j].start_time_m; //第二趟巴士的发车时间
					int t4=a[j].end_time_h*60+a[j].end_time_m; //第二趟巴士的到达时间
					int ans=(t2+1440-t1)%1440;
					int t=(t3+1440-t2)%1440;
					if(t==0) t=1440; //第一趟巴士的到达时间必须严格早于第二趟巴士的发车时间
					ans=ans+t;
					ans=ans+(t4+1440-t3)%1440;
					ans++;
					minx=min(minx,ans);
				}
			}
		}
	}
	if(minx!=INT_MAX)
	{
		cout <<minx/60<<":";
		if(minx%60/10==0) cout<<"0"<<minx%60;
		else cout <<minx%60;
	}
	else cout <<"NEMOGUCE";
	return 0;
}
```
最后的最后，求管理员大人通过。

---


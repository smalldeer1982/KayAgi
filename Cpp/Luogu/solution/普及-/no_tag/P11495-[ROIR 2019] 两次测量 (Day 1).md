# [ROIR 2019] 两次测量 (Day 1)

## 题目背景

翻译自 [ROIR 2019 D1T1](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day1.pdf)。

## 题目描述

科学家们计划在 X-2019 星球上使用研究模块进行一次重要实验。在实验过程中，将进行两次测量：主要测量和控制测量。每次测量都需要 $1$ 小时，并且必须在研究模块开始工作后的整点开始。

实验的数据将在测量结束后立即传输到轨道站。与轨道站的通信通道将在研究模块开始工作后的第 $l$ 到 $r$ 小时之间建立。此外，根据实验计划，两次测量之间，星球必须完成整数圈的自转。X-2019 星球自转一圈需要 $a$ 小时。

因此，如果两次测量分别在第 $i$ 小时和第 $j$ 小时进行，则必须满足 $l \le i < j \le r$，且 $a\mid j - i$。

现在，科学家们需要知道，有多少种不同的可行的测量方案。

简单来说，给定 $l,r,a$，你需要求出满足 $l \le i < j \le r$ 且 $a\mid j - i$ 的整数对 $(i,j)$ 的数量。

## 说明/提示

### 样例解释：

样例 $1$ 中的四种可行测量方案分别为 $(1,3),(1,5),(2,4),(3,5)$。

样例 $2$ 中，通信通道的工作时间不足以进行两次测量。

### 数据范围：

数据中 Subtask 0 为样例。

| 子任务 | 分值 | $1\le l,r,a\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $100$ |
| $2$ | $30$ | $10^5$ |
| $3$ | $40$ | $10^9$ |

## 样例 #1

### 输入

```
1
5
2```

### 输出

```
4```

## 样例 #2

### 输入

```
4
9
6```

### 输出

```
0```

# 题解

## 作者：lailai0916 (赞：4)

## 原题链接

- [洛谷 P11495 [ROIR 2019 Day 1] 两次测量](https://www.luogu.com.cn/problem/P11495)

## 题意简述

给定正整数 $l,r,a$，计算：

$$
\sum_{i=l}^{r}\sum_{j=i+1}^r[a\mid j-i]
$$

## 解题思路

$$
\begin{aligned}
  \sum_{i=l}^{r}\sum_{j=i+1}^r[a\mid j-i] &= \sum_{d=1}^{r-l} [a \mid d](r-l-d+1) \\
  &= \sum_{k=1}^{\left\lfloor\frac{r-l}{a}\right\rfloor}(r-l-ka+1) \\
  &= \sum_{k=1}^{\left\lfloor\frac{r-l}{a}\right\rfloor}(r-l+1)-a\sum_{k=1}^{\left\lfloor\frac{r-l}{a}\right\rfloor} k \\
  &= \left\lfloor\frac{r-l}{a}\right\rfloor(r-l+1)-a\frac{\left\lfloor\frac{r-l}{a}\right\rfloor(\left\lfloor\frac{r-l}{a}\right\rfloor+1)}{2}
\end{aligned}
$$

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	ll l,r,a;
	cin>>l>>r>>a;
	cout<<((r-l)/a)*(r-l+1)-a*((r-l)/a)*((r-l)/a+1)/2<<'\n';
	return 0;
}
```

---

## 作者：船酱魔王 (赞：3)

## 题意回顾

给定 $ L,R,a $，求非负整数二元组 $ (l,r) $ 的组数使得 $ L \le l < r \le R $，且 $ a \mid r-l $。

$ 1 \le L < R \le 10^9 $，$ 1 \le a \le 10^9 $。

## 分析

考虑枚举 $ r-l $ 的值，发现当 $ r-l $ 确定后，有 $ \max\{R-L+1-(r-l),0\} $ 组答案。

故答案可以表示为 $ \sum_{i=1}^{+\infty}\max\{R-L+1-ia,0\} $，这个可以用等差数列求和公式解决，即求出首项对 $ a $ 取模为正数中的末项由差得到项数即可。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int l, r, a;
int main() {
	cin >> l >> r >> a;
	int lwhzkj = max(r - l + 1 - a, 0);
	int wlzhjk = lwhzkj % a;
	int wzj = (lwhzkj - wlzhjk) / a + 1;
	cout << (long long)(lwhzkj + wlzhjk) * wzj / 2 << endl;
	return 0;
}
```

---

## 作者：reinforest (赞：3)

结论题。建议评 $\color{orange}{普及-}$。

令

$$k = \lfloor \frac{r - l + 1}{a} \rfloor$$

则答案就是

$$k(r - l + 1) - \frac{ak(k + 1)}{2}$$

。

为什么？

由题意可得 $(j - i)$ 一定是 $a$ 的倍数，设 $j - i = ma$，其中 $m$ 是正整数。因为 $i$ 到 $j$ 的距离为 $ma$，而总共有 $r - l + 1$ 个连续自然数，所以此时会有 $r - l + 1 - ma$ 个数对 $(i,j)$ 满足条件。

为了形式美观，我们令 $$k = \lfloor \frac{r - l + 1}{a} \rfloor$$。这个数是 $m$ 能取到的最大值。

我们对所有的 $m$ 求和，可得以下的式子。
$$\begin{aligned} \sum _ {i = 1} ^ {k} (r - l + 1 - ia) &= \sum _ {i = 1} ^ k (r - l + 1) - a \sum _ {i = 1} ^ k i \\ &= k (r - l + 1) - \frac{ak(k + 1)}{2} \end{aligned}$$

这就是我们要的答案。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll l,r,a;
int main(){
	scanf("%lld%lld%lld",&l,&r,&a);
	ll k=(r-l+1)/a;
	printf("%lld\n",k*(r-l+1)-k*(k+1)*a/2);
	return 0;
} 
```

---

## 作者：lam_dyr (赞：2)

## Solution

思路一：暴力枚举

使用两层循环，外层循环枚举起始测量时间 $i$ 从 $l$ 到 $r$。
内层循环枚举结束测量时间 $j$，从 $i + a$ 开始，每次增加 $a$，直到 $j$ 大于 $r$。
如果 $j$ 在 $r$ 范围内，则答案加一。

时间复杂度：$O(n^2)$。
期望得分：$30$。

思路二：优化枚举

使用一层循环，枚举起始测量时间 $i$ 从 $l$ 到 $r$。
对于每个 $i$，直接计算满足条件的 $j$ 的数量 $(r - i) \div a$，并累加到答案。

时间复杂度：$O(n)$。期望得分：$60$。

思路三：数学公式

利用数学推导，将问题转化为一个等差数列求和的问题。

计算 $\max _k = (r - l) \div a$。
计算第一个使得 $r - l + 1 - k \times a \le 0$ 的 $k$ 值 $k_0$。

根据 $k_0$ 的值，使用等差数列求和公式计算结果。

时间复杂度：$O(1)$。期望得分：$100$。

## Code

```cpp
#include <iostream>
using namespace std;
long long l, r, a;
int main() {
    cin >> l >> r >> a;
    long long maxk = (r - l) / a;
    long long ans = 0;
    if (maxk <= 0) {
        cout << 0 << endl;
        return 0;
    }
    long long k0 = (r - l + 1 + a - 1) / a; // 向上取整
    if (k0 > maxk + 1) k0 = maxk + 1;
//    long long fi = r - l + 1 - a;
    if (k0 <= 1) {
        ans = (maxk * (2 * (r-l+1) - (maxk+1) * a)) / 2;
        if (ans < 0) ans = 0;
    } else {
        long long sum = (k0 - 1) * (2 * (r - l + 1) - k0 * a) / 2;
        if (sum < 0) sum = 0;
        ans = sum;
    }
    cout << ans;
    return 0;
}
```

## 总结

在有些时候，我们可以通过数据范围选择算法类型。

例如该题 $10^9$ 的范围显然要 $O(1)$ 的。

~~也算是一种技巧吧，考场上可以节省时间~~

---

## 作者：chengjindong (赞：2)

[题目](https://www.luogu.com.cn/problem/P11495)

题目要求：$l \le i < j \le r$，且 $a\mid j - i$。

把上面的话转化一下，会得到：$j - i$ 是 $a$ 的倍数，数学语言：$\{ j \mid j = i + k \times a,k \in \mathbb{Z} \}$。

要使 $j$ 满足范围，需要满足：$i + k \times a \le r$，解得：$k \le \frac{r-i}{a}$。

那么，每个 $i$ 就对应 $r-l-i \times a+1$ 个 $j$，当然，需要它不能小于 $0$，累加答案即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int l,r,a;
	cin >>l>>r>>a;
	int ans=0;
	for(int i=1;i<=(r-l)/a;i++){//遍历1~(r-l)/a 
		if(r-i*a>=l){//满足范围
			ans+=r-l-i*a+1;//对每个i统计j的个数 
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：glass_goldfish (赞：2)

还是一道比较简单的数学题。我们可以记 $k$ 为 $r-l+1$（即 $i,j$ 的跨度范围）。然后，分类讨论：  
1. 如果 $k<a$，那么答案为 $0$。因为这种情况下，就算 $i$ 取 $l$，$j$ 取 $r$，那么差值也只有 $r-l$，小于 $r-l+1$（即 $k$），所以 $r-l<a$，自然没有解。
2. 如果 $k=a$，那么答案为 $0$。因为这种情况下，就算 $i$ 取 $l$，$j$ 取 $r$，那么差值也只有 $r-l$，小于 $r-l+1$（即 $k$），而 $k=a$，所以差值为 $a-1$，同样无解。
3. 如果 $k>a$，那么肯定是有解的。因为此时，若 $i$ 取 $l$，$j$ 取 $r$，那么差值为 $r-l$，正好是 $k-1$，而 $k>a$，所以 $r-l\ge a$，至少有一个解。然后，我们发现 $j-i$ 的取值只能是 $a$ 的倍数，最小为 $a$，最大为 $k-k\bmod a$（最小自然是 $a$，最大就是不大于 $k$ 的最大整数）。然后，如果 $j-i=a$，那么 $i$ 一旦确定，那么 $j$ 也直接确定了，此时，$i$ 总共有 $k-a$ 种取值（从 $l$ 到 $l+k-a-1$）。然后，考虑最大的情况，此时 $i$ 总共只有 $k\bmod a$ 种取值（从 $l$ 到 $l+k\bmod a-1$）。发现，其实从 $j-i$ 的值最大的方法数到 $j-i$ 的值最小的方法数实际上是一个等差数列，首项就是 $j-i$ 的值最大的方法数，末项就是 $j-i$ 的值最小的方法数，公差为 $a$（因为要保证整除）。这样就能求出答案了，详见代码。

代码中使用了位移，直接把 $l$ 变为 $1$，$r$ 变为 $r-l+1$（即上文所说的 $k$）。正确性证明：$l$ 和 $r$ 同时减去（或加上）一个数，那么相应的 $i$ 和 $j$ 也会同时减去（或加上）一个数，而最终使用的是 $j-i$，而被减数 $j$ 和减数 $i$ 都同时减去（或加上）了一个数，差是不变的。设原本的 $i$ 为 $I$，原本的 $j$ 为 $J$，减去的值为 $s$，那么原本的差值为 $J-I$，现在的差值为 $(J-s)-(I-s)=J-s-I+s=J-I$，所以是相等的。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int l,r,a;
int luogu(int fir,int las,int d){
	int p=(las-fir)/d+1;
	return (fir+las)*p/2;
}//等差数列求和
signed main(){
	cin>>l>>r>>a;
	r=r-l+1;l=1;//位移
	if(r<=a)cout<<"0";//无解
	else cout<<luogu(r%a,r-a,a);
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：2)

一道数学题，和 [P9748 [CSP-J 2023] 小苹果](https://www.luogu.com.cn/problem/P9748) 相似。

我们先考虑 $j-i=a$ 的情况，显然对于最后的 $a$ 个小时，不能作为第一次实验的时间，否则就不能进行第二次了，能进行实验的方案数为 $r-l-a+1$。同理，对于 $j-i=2a$ 的情况，最后的 $2a$ 个小时不能作为第一次实验的时间，方案数为 $r-l-2a+1$。以此类推，总方案数为：

$(r-l-a+1)+(r-l-2a+1)+(r-l-3a+1)+\dots$

发现后一项刚好比前一项小 $a$，因此我们可以设一个变量 $x=r-l-a+1$，每次将答案加上 $x$，再将 $x$ 减去 $a$ 直到 $x$ 不大于 $0$ 为止。但是本题时限缩短，无法通过。

可以发现上述的式子的每一项可以组成一个公差为 $a$ 的等差数列，根据等差数列通项公式可以得出第一项为 $x-(n-1)a$，其中 $x=r-l-a+1$，$n$ 为使 $r-l-(n+1)a+1$ 不大于 $0$ 的最小 $n$ 值，也就是：

$r-l-(n+1)a+1\le0$

$\frac{r-l+1}{a}-1\le n$

所以 $n=\lceil \frac{r-l+1}{a}\rceil -1$。再根据等差数列求和公式，答案即为：

$\frac{1}{2}n(x-(n-1)a+x)$

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long l,r,a;
	cin>>l>>r>>a;
	long long x=r-l-a+1;
	long long n=(long long)(ceil((r-l+1)*1.0/a))-1;
	cout<<n*(x-(n-1)*a+x)/2;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11495)

---
### 思路：
这是一道经典的数学题。

不得不说，本题的数据是真的弱。可以用时间复杂度约是 $O(N \div A)$ 的方法来做。

当然，想用 $O(1)$ 的时间复杂度来做，也是可以。

我们先可以推出一个公式。$(r - l + 1) \div a$，那么此时会有 $r−l+1−ma$ 满足答案的条件，这个 $m$ 是一个特定的正整数，那么我们将公式一的答案设为 $x$，这个数就是 $m$ 能取到的最大值。

最后转化一下，就可以得到新的式子 $x(r - l + 1) - x \times (x + 1) \div 2$，用这个公式就可以解决我们的问题了。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

long long l, r, a, k = 0;

int main() {
	scanf("%lld%lld%lld", &l, &r, &a);
	k = (r - l + 1) / a;
	printf("%lld\n", k * (r - l + 1) - k * (k + 1) *  a / 2);
	return 0;
}

```

---

## 作者：zzwdsj (赞：2)

### 思路一

枚举 $i$，$j$，统计符合条件的组合的个数。

期望分数：$30$。

### 思路二

枚举 $i$，符合条件的 $j$ 的个数为 $\lfloor (r-i+1)\div a \rfloor$，全部相加即可。

期望分数：$60$。

### 思路三

我们列出思路二中每个加的项：

$$
\lfloor(r-l+1)\div a\rfloor+\lfloor(r-l-1+1)\div a\rfloor+\lfloor(r-l-2+1)\div a\rfloor+...+\lfloor(r-l-r+1)\div a\rfloor
$$

列出 $l=1,r=11,a=3$ 时求和的每个项，为了方便，不妨在末尾添一个 $+0$。

$$
3+3+2+2+2+1+1+1+0+0+0
$$

可以分成两部分求解。

$$
2+2+2+1+1+1+0+0+0\\
3+3
$$

设 $t=r-l+1$，则第一部分为 $\lfloor(t- t \bmod a)\div a\rfloor\times \lfloor(\lfloor t \div a\rfloor-1) \div 2\rfloor \times a$（套用等差数列求和公式后乘以 $a$）；第二部分为 $t \bmod a\times (\lfloor t \div a\rfloor)$。（$t \bmod a$ 个 $\lfloor t \div a\rfloor$）。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,r,a,t; 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>l>>r>>a;
	t=r-l+1;
	cout<<(t-t%a)/a*(t/a-1)/2*a+t%a*(t/a);
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

题意：给定 $l,r,a$，你需要求出满足 $l \le i < j \le r$ 且 $a\mid j - i$ 的整数对 $(i,j)$ 的数量。

设 $j-i=ka$。由 $i<j\le r$ 同时减去 $i$ 有 $0<ka\le r-i$，转化得 $i\le r-ka$。对于每个可能的 $k$，区间 $[l,r-ka]$ 内的所有 $r-ka-l+1$ 个 $i$ 都是可行的。即答案为 $\sum\limits_{k=1}^{\infty}\max(0,r-ka-l+1)$。由 $r-ka-l+1>0$ 即 $k<\dfrac{r-l+1}{a}$，$\sum\limits_{k=1}^{\infty}\max(0,r-ka-l+1)=\sum\limits_{k=1}^{\left\lfloor\frac{r-l+1}{a}\right\rfloor}(r-ka-l+1)=(r-l+1)\left\lfloor\frac{r-l+1}{a}\right\rfloor-a\sum\limits_{k=1}^{\left\lfloor\frac{r-l+1}{a}\right\rfloor}k=(r-l+1)\left\lfloor\frac{r-l+1}{a}\right\rfloor-\dfrac{a\left\lfloor\frac{r-l+1}{a}\right\rfloor(\left\lfloor\frac{r-l+1}{a}\right\rfloor+1)}{2}$。令 $c=r-l+1,m=\left\lfloor\frac{r-l+1}{a}\right\rfloor$，则答案为 $cm-\dfrac{am(m+1)}{2}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

signed main(){
	int l,r,a;cin>>l>>r>>a;
	int c=r-l+1;int m=(r-l+1)/a;
	cout<<c*m-a*m*(m+1)/2;
	return 0;
}
```

---

## 作者：cjx_AK (赞：1)

卡了一小时发现没开 long long。

先看题，题目让你求在 $l$ 到 $r$ 之间有多少个数对使得 $j-i$ 是 $a$ 的整数倍。(其中 $j>i$ )

首先枚举虽然不算特别慢，但也只能是30分。

```
#include<bits/stdc++.h>
using namespace std;
#define MAXN 6005
int l,r,a,ans;
int main(){
	cin>>l>>r>>a;
	for(int i=l;i<=r;i++){
		for(int j=i;j<=r;j++){
			if((j-i)%a==0&&j!=i){
				ans++;
				//cout    <<j<<' '<<i<<endl;
			}
		}
	}
	cout<<ans<<endl;
}
```

我们考虑到数据范围只支持 $O(n)$ 及以下的时间复杂度，所以我们可以找一下规律。

我们可以枚举每一个 $a$ 的倍数，然后再累计每一个数所计算出的区间个数。

至于怎么累计区间，就可以这么做：定义一个左端点 $x$ 和右端点 $y$，然后枚举一下，发现区间个数是（总区间数的个数 $-$ 目前的间隔）。（目前的间隔就是 $j-i$ ）

### 最后就是 code:

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int l,r,a,ans,k,x;
signed main(){
	cin>>l>>r>>a;
	
	x=r-l+1;
	if(x<a){
		cout<<0;
		return 0;
	}
	if(x==a){
		cout<<0;
		return 0;
	}
	for(int i=a;i<=x;i+=a){
		ans+=x-i;
		//cout<<ans<<' ';
	}
	cout<<ans;
}
```

---

## 作者：jojo222 (赞：1)

道题还是比较简单的，我的解法应该更好理解一些。

分类讨论 $k\bmod a$ 的情况。以样例 $1$ 为例子，  
![](https://cdn.luogu.com.cn/upload/image_hosting/9if4wuss.png?x-oss-process=image/resize,m_lfit,h_340,w_450)  
上方的线是 $k\bmod a=1$ 的方法数，把所有 $k\bmod a=1$ 的点两两连起来得到方法数，算式为 $3\times2\div2$。

每一组点的个数不相同，我们不能枚举，会超时，那该怎么办呢？再以样例 $1$ 为例子，区间大小为 $4$，有一组有 $2$ 个点，另一组有 $3$ 个点。因为 $4\div2$ 等于 $2$，$3$ 个点的很稀有，只有 $1$、$3$、$5$，$5$ 的出现给 $1$ 和 $3$ 连了线。  
如果是 $1$ 到 $6$，就有 $1$、$3$、$5$，$2$、$4$、$6$。

设区间大小为 $n$（$r-l$），普通的点数为 $m$（$\lfloor n\div a\rfloor$）。有 $n\bmod a+1$ 组点是特殊的，多的点为总分争得了 $\lfloor n\div a\rfloor$ 点光荣。

所以，有 $a$ 组点，每组点都当成有 $m$ 个点，有 $m\times(m-1)\div2$ 种连线，每次多出来的贡献有 $\lfloor n\div a\rfloor$ 点，共有 $n\bmod a+1$ 次贡献，把它们加上就完成了！

公式和代码的一样，是 $m\times(m-1)\div2\times a+(n\bmod a+1)\times m$。

给出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, l, r, a;
int main()
{
	cin >> l >> r >> a;
	n = r - l, m = n / a;
	cout << 1ll * m * (m - 1) / 2 * a + (n % a + 1) * m << endl;
	return 0;
}
```
温馨提醒：结果要开 long long 哦！

---

## 作者：HHC883 (赞：1)

# 题目分析
对于一个 $i$，若要 $a \mid j - i$，则有 $j - i = ka$ 且 $k$ 为整数。不妨枚举 $k$。当 $k$ 确定时，对于任意的 $l \le i \le r - ka$，都存在 $j \le r$ 满足 $a \mid j - i$，因为取 $j = i + ka$ 即可。所以对于每个 $k$，都有 $r - ka - l + 1 = r - l + 1 - ka$ 个满足要求的整数对 $(i , j)$。所以，最终答案为

$$\begin{aligned}
\sum_{k = 1}^{\lfloor \frac{r - l + 1}{a} \rfloor} r-l+1 - ka
& = (r - l + 1) \lfloor \frac{r - l + 1}{a} \rfloor - a \sum_{k = 1}^{\lfloor \frac{r - l + 1}{a} \rfloor} k \\
& = (r - l + 1) \lfloor \frac{r - l + 1}{a} \rfloor - a \cdot \frac{\lfloor \frac{r - l + 1}{a} \rfloor \left( \lfloor \frac{r - l + 1}{a} \rfloor + 1 \right)}{2}
\end{aligned}$$

直接计算即可。时间复杂度 $O(1)$。
# 参考代码
```cpp
#include<iostream>
#define int long long
using namespace std;
int l,r,a;
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>l>>r>>a;
	int ans=(r-l+1)*((r-l+1)/a)-(r-l+1)/a*((r-l+1)/a+1)/2*a;
	cout<<ans;
	return 0;
}

```

---

## 作者：snowQAQ (赞：0)

### 思路

```
3 13 3

1.          2.
1 4 7 10    3 6 9 12
2 5 8 11    4 7 10 13
3 6 9       5 8 11
4 7 10      6 9 12
5 8 11      7 10 13
6 9         8 11 
7 10        9 12
8 11        10 13
ans:15      ans:15
```
我们观察一下上面这组数据。题目给的 $r$，$l$，$a$ 不太好观察，所以我们可以将 $l$ 变为 $1$，$r$ 变为 $r-l+1$。

再看一下数据，上面的数比较突出，我们先忽略，下面的数是 $3$ 组 $1$ 个循环。

所以我们可以将答案化为两部分。

$15=3+3+2+2+2+1+1+1$

1. $2+2+2+1+1+1$
2. $3+3$

先看第一部分。每个数重复了 $a$ 次是因为任意一个数 $+a$ 结果一定会少 $1$。

这一部分可以转化为：

$(1+2)\times 3 = \Large\frac{2\times3}{2}\normalsize\times3$

所以，这一部分的答案 $sum1$ 为：

$\Large\frac{k\times(k+1)}{2}\normalsize\times a$

这里的 $k$ 为除了最上面部分最长部分的长度。剩下的部分长度依次递减。

然后是第二部分。

第一部分剩余的个数就是重复的次数。所以重复的次数为 $(r-l+1) \bmod a$。

那这一部分的答案 $sum2$ 就可以表示为：

$(k+1)\times \left[ (r-l+1)\bmod a) \right]$

最后，$k$ 是去掉顶部之后的最大数目。所以 $k=\left[r-(r \bmod a)\div a \right]$。

### AC 代码

```c++
#include<iostream>
using namespace std;
typedef long long ll;
int main()
{
	ll l,r,a;
	cin>>l>>r>>a;
	r=r-l+1;
	ll rr=r-(r%a);
	rr-=a;
	ll len=rr/a;
	
	ll sum1=a*len*(len+1)/2;
	ll sum2=(len+1)*(r%a);

	cout<<sum1+sum2;
	
}

```

---


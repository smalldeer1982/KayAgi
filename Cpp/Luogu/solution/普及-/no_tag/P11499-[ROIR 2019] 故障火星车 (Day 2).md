# [ROIR 2019] 故障火星车 (Day 2)

## 题目背景

翻译自 [ROIR 2019 D2T1](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day2.pdf)。

## 题目描述

执行国际任务的火星车出现了故障。为了恢复其正常工作，需要提高其电池的功率。

火星车电池的功率用一个正整数表示。当前电池功率为 $a$，为了恢复火星车的工作，需要将其功率提高到 $b$。可以从地球向火星车发送 X 和 Y 这两种类型的特殊信号来改变电池功率：
- X 信号可以将当前电池功率增加 $1$；
- Y 信号可以将当前电池功率增加 $2$。

由于一些特性，在提高功率的过程中，电池的功率不能是 $c$ 的倍数，否则火星车的电池将原地爆炸。

你需要求出最少需要发送的信号的数量，使得火星车恢复正常工作。

## 说明/提示

### 样例解释

样例 $1$ 中，可以按顺序发送 Y，X，Y 信号，电池功率的变化为：$2\to4\to5\to7$。

样例 $2$ 中，可以按顺序发送 X，Y，X，Y 信号，电池功率的变化为：$4\to5\to7\to8\to10$。

### 数据范围

数据中 Subtask 0 为样例。

| 子任务 | 分值 | $1\le a<b\le$ | $2\le c\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $25$ | $15$ | $15$ |
| $2$ | $25$ | $10^5$ | $10^5$ |
| $3$ | $25$ | $10^9$ | $2$ |
| $4$ | $25$ | $10^9$ | $10^9$ |

## 样例 #1

### 输入

```
2
7
3```

### 输出

```
3```

## 样例 #2

### 输入

```
4
10
3```

### 输出

```
4```

# 题解

## 作者：fish_love_cat (赞：8)

唯一做出来的 /qd

---

根据贪心的策略肯定是要尽量用 Y。如果再用 Y 会爆炸时再用 X 改变奇偶性挺过去。

容易想到根据 $c$ 的奇偶性分情况考虑，因为如果 $c \bmod 2=0$，只要电量是奇数就不可能有问题。

而剩下的情况也是容易找到规律的。难点在于分讨和考虑边界。

那么就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a,b,c;
    cin>>a>>b>>c;
    if(b/c-a/c==0){
        cout<<(b-a)/2+(b-a)%2;
    }else if(c%2==0){
        if((b-a)%2==0){
            if(b%2==0){
                cout<<(b-a)/2+1;
            }else{
                cout<<(b-a)/2;
            }
        }else{
            cout<<(b-a)/2+1;
        }
    }else{
        int x=a-a%c;
        b-=x;a-=x;
        int ans=(c-a)/2+1;
        a=1;
        b-=c;
        ans+=(b/c)*((c-1)/2+1);
        b%=c;
        cout<<ans+(b-a)/2+(b-a)%2;
    }
    return 0;
}
```

代码极度丑陋 /cf

---

## 作者：Su777 (赞：4)

与现有两篇题解的思路不同，我使用了分块思维，没有写大型分讨，自认为代码和思路比较清新。

**声明：此做法不卡常，其时间复杂度为 $O(1)$。[记录](https://www.luogu.com.cn/record/197099322)。**

## 思路

把整个添加功率的过程几何化，相当与把一个在数轴上的点从 $a$ 移动到 $b$。其中 $c$ 的倍数的点不能到达。

所有不可到达的点把数轴分成了若干段，定义其中第 $k$ 段对应点坐标 $[kc+1, kc+(c-1)]$。那么点 $q$ 所在区间编号为 $\cfrac{q}{c}$。

这样从 $a$ 走到 $b$ 可以分为三个阶段：

1. 从 $a$ 走到它所在区间的末尾。
2. 从 $a$ 所在区间的下一个区间走到 $b$ 所在区间的上一个区间。
3. 从 $b$ 所在区间的开头走到 $b$。

![](https://cdn.luogu.com.cn/upload/image_hosting/en217toc.png)

> 当然，如果 $a,b$ 在同一个区间，要进行特判，因为三个阶段会有重叠部分。

通过简单推导可以得出，第一段的区间为 $[a, \lceil \cfrac{a}{c}\rceil \times c -1]$，第三段的区间为 $[\lfloor \cfrac{b}{c}\rfloor \times c+1,b]$。这两段都是畅通无阻的，没有 $c$ 的倍数的障碍，可以贪心地走。每次尽量往右走 $2$ 格，贪心可以 $O(1)$，写法见代码中的 $calc$ 函数。$calc(i,j)$ 可以计算从点 $i$ 走到点 $j$，没有障碍的情况下，最少需要多少次操作。显然将 $i$ 和 $j$ 同时加上或者减去一个值不影响函数值。

第二段是最麻烦的，首先得出：
- $a$ 所在区间的下一个区间编号 $\lfloor \cfrac{a}{c}\rfloor+1$，记作 $p$。
- $b$ 所在区间的上一个区间编号 $\lfloor \cfrac{b}{c}\rfloor-1$，记作 $q$。

然后开始暴力走。我们的目标是从 $p$ 区间第一个位置走到 $q$ 区间第一个位置，具体坐标在代码注释中有所呈现。这样的话，我们可以把这个过程继续拆解：
1. 从 $p$ 区间第一个位置走到 $p$ 区间最后一个位置，花费 $calc(1, c-1)$ 步。
2. 进行一次 Y 操作，从 $p$ 区间最后一个位置走到 $p+1$ 区间第一个位置。
3. 从 $p+1$ 区间第一个位置走到 $p+1$ 区间最后一个位置，花费 $calc(1, c-1)$ 步。
4. 进行一次 Y 操作，从 $p+1$ 区间最后一个位置走到 $p+2$ 区间第一个位置。
5. 从 $p+2$ 区间第一个位置走到 $p+2$ 区间最后一个位置，花费 $calc(1, c-1)$ 步。
6. 进行一次 Y 操作，从 $p+2$ 区间最后一个位置走到 $p+3$ 区间第一个位置。
7. ......

看到规律了吗？每两次操作为一个周期，共有 $q-p$ 个周期，每个周期。这就是阶段二的答案。

最后把三个阶段的答案加在一起，这个题就做完了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll a, b, c;
ll calc(ll l, ll r) {
    ll dt = r - l;
    if (dt % 2 == 0) return dt / 2;
    return dt / 2 + 1;
}
int main() {
    cin >> a >> b >> c;
    if (a / c == b / c) {
        cout << calc(a, b) << "\n";
        return 0;
    }
    ll ans = 0;
    // a -> (a / c + 1) * c - 1
    ans += calc(a, (a / c + 1) * c - 1) + 1;
    // now pos: (a / c + 1) * c + 1;
    ans += (calc(1, c-1) + 1) * ((b / c) - (a / c + 1));
    // now pos: (b / c) * c + 1
    ans += calc((b / c) * c + 1, b);
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：GSQ0829 (赞：4)

### 思路：
根据贪心，我们知道，能加二，就尽量加二，否则就只能加一。

那么，就要根据 $c$ 的一些奇偶性来看了，只要它不是 $c$ 本身，那么只要是奇数，一定都不会爆炸。

那么这题就做完了。(难点在于分讨和考虑边界，一定要注意哦！！！)。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b, c, x = 0, ans = 0;

int main() {
	cin >> a >> b >> c;
	if (b / c - a / c == 0) cout << (b - a) / 2 + (b - a) % 2;
	else if (c % 2 == 0) {
		if ((b - a) % 2 == 0) {
			if (b % 2 == 0) cout << (b - a) / 2 + 1;
			else cout << (b - a) / 2;
		} else cout << (b - a) / 2 + 1;
	} else {
		x = a - a % c;
		b -= x;
		a -= x;
		ans = (c - a) / 2 + 1;
		b -= c;
		ans += (b / c) * ((c - 1) / 2 + 1);
		b %= c;
		cout << ans + (b - 1) / 2 + (b - 1) % 2;
	}
	return 0;
}
```

---


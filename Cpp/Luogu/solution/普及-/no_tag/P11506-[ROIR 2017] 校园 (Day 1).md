# [ROIR 2017] 校园 (Day 1)

## 题目背景

翻译自 [ROIR 2017 D1T1](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day1.pdf)。

## 题目描述

新的拜特堡大学校园大楼有 $n$ 层，从下往上编号为 $1$ 到 $n$。学生宿舍分布在多个楼道中。

在每个楼道中，楼层号是 $k$ 的倍数的楼层上有 $x$ 个房间，其他楼层上有 $y$ 个房间。

每个楼道内的房间按顺序编号。第一层的房间编号最小，接着是第二层的房间编号，以此类推。第一个楼道的房间编号从 $1$ 开始，每个后续楼道的房间编号从上一个楼道房间最大编号的下一个数字开始。

如下图所示，假设楼层数 $n = 7$，楼道数为 $3$，且 $k = 3$, $x = 2$, $y = 3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n1792el9.png)

为了便于学生住宿安排，校园管理方需要根据房间编号快速查找该房间所在的楼层。

请编写一个程序，根据给定的 $n$, $k$, $x$, $y$，以及房间编号，确定每个房间所在的楼层。

## 说明/提示

| 子任务 | 分值 | $1\le n\le$ | $1\le x,y\le$ | $1\le q\le$ | $1\le a_i\le$ | 其它特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $31$ | $10$ | $10$ | $1$ | $100$ |  |
| $2$ | $19$ | $10^7$ | $10^9$ | $1$ | $10^7$ |  |
| $3$ | $16$ | $10^9$ | $10^9$ | $1000$ | $10^{18}$ | $x=y$ |
| $4$ | $34$ | $10^9$ | $10^9$ | $1000$ | $10^{18}$ |  |

## 样例 #1

### 输入

```
7 3 2 3
4
1 19 20 50```

### 输出

```
1
7
1
5```

# 题解

## 作者：szm111213 (赞：7)

来来来，一道橙题，先找一下规律吧！！！

- 每个楼道中，楼层号是 $k$ 的倍数的楼层上有 $x$ 个房间，其他楼层上有 $y$ 个房间。
- 每个楼道的房间编号是连续的，从上一个楼道的最大编号的下一个数字开始。

于是，啪！！！我们可以计算每个楼道的房间总数，然后根据房间编号确定它所在的楼道和楼层。

然后就要用上~~~

设楼道的房间总数为 $T$，其中，$\left\lfloor \frac{n}{k} \right\rfloor$ 表示 $n$ 除以 $k$ 的商，即 $k$ 的倍数的楼层数。

接下来是本人马蜂优良的代码：

```cpp
#include <bits/stdc++.h>//万恶之源
using namespace std;
int main()
{
    long long n, k, x, y;
    cin >> n >> k >> x >> y;
    long long t = (n / k) * x + (n - n / k) * y;// 计算每个楼道的房间总数
    int q;
    cin >> q;
    for (int i = 0; i < q; i++)
	{
        long long a;
        cin >> a;
        long long d = (a - 1) / t + 1;// 确定楼道编号
        long long r = (a - 1) % t + 1;// 确定在该楼道内的相对编号
        // 以下是确定楼层编号
        long long f = 0;
        long long s = 0;
        for (long long i = 1; i <= n; i++)
		{
            if (i % k == 0)
			{
                s += x;
            }
			else
			{
                s += y;
            }
            if (s >= r)
			{
                f = i;
                break;
            }
        }
        cout << f << endl;
    }

    return 0;
}
```
//十年oi一场空，~~~~~~~

---

## 作者：lam_dyr (赞：5)

# P11506 \[ROIR 2017 Day 1] 校园

~~场上 10min50 分不想打了，赛后发现是数组开小。~~

写篇题解纪念一下。

这题主要难在理解上，理解题意就很简单。

## 题意

有一个多层建筑，每层楼的房间数量根据楼层是否为 $k$ 的倍数而不同。我们需要根据给定的房间编号和编号规则，找到该房间所在的楼层。

## 思路

1. 编号规则

- 房间按楼道顺序编号。
- 每个楼道内，房间按楼层顺序编号。
- 每个楼道内，楼层号是 $k$ 的倍数的楼层有 $x$ 个房间，其他楼层有 $y$ 个房间

2. 计算每个楼道的总房间数

- 可以通过 $tot = \frac {n}{k} \times x + (n - \frac {n}{k}) \times y$ 计算&#x20;

  - $\frac {n}{k}$ 表示楼层号是 $k$ 的倍数的楼层数。
  - $n - \frac {n}{k}$ 表示楼层号不是 $k$ 的倍数的楼层数。

3. 确定房间所在的楼道。

- 知道每栋楼的总房间数后，我们可以通过房间编号来确定房间所在的楼道。

- 可以通过 $tmp=\frac {a-1}{tot}+1$ 计算&#x20;

  - $r$ 是房间编号。
  - $\frac {a - 1}{tot}$ 表示房间之前有多少个完整的楼道。
  - $+1$ 是因为楼道编号从 $1$ 开始

4. 确定房间在楼道内的编号。

- 可以通过 $res=a-(tmp-1)\times tot$ 计算&#x20;

  - $r$ 是房间编号。
  - $(tmp - 1)
     \times tot$ 表示之前楼道的总房间数。

5. 二分答案确定楼层

- 现在我们已经知道房间在哪个楼道，以及在楼道内的编号，因为楼层具有单调性，可以使用二分找满足条件的最小楼层 $ans$。

  - **条件**是指：到 $ans$ 层为之的房间总数大于等于该房间在楼道内的编号 $res$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k,x,y;
long long check(long long mid){
    return (mid/k)*x+(mid-mid/k)*y;
}
int main(){
    cin>>n>>k>>x>>y;
    long long tot=(n/k)*x+(n-n/k)*y;
    int q;
    cin>>q;
    for (int i=1;i<=q;++i){
        long long a;
        cin>>a;
        long long tmp=(a-1)/tot+1;
        long long res=a-(tmp-1)*tot;
        long long l=1,r=n,ans=-1;
        while(l<=r){
            long long mid=l+((r-l)>>1);
            if(check(mid)>=res){
                ans=mid;
                r=mid-1;
            } 
			else
                l=mid+1;
        }
        cout<<ans<<"\n";
    }
    return 0;
}

```

---

## 作者：Sunrise_up (赞：4)

这题十分简单，一道思维题。

这题有多组数据，我们可以边输入边做运算。

对于每一组一个数 $a$ ,首先将 $a$ 模一个楼道的总房间数 $ldf$ ,这点大家应该很清楚，公式也很简单， $ldf=\lfloor\frac{a}{k}\rfloor\times x+(a-\lfloor\frac{a}{k}\rfloor)\times y$ 。

然后我们发现每 $k$ 层都是有规律的，每一层都一样，定义一个变量 $mz$ 用来存每 $k$ 层的房间数， $mz=x+(k-1)\times y$ 。

由于每 $k$ 层都是有规律的，所以我们可以将 $a$ 模 $k$ （只考虑一组）,再定义一个 $ans$ 变量来存答案，则现在 $ans=\lfloor\frac{a}{mz}\rfloor\times k$ 。

接下来判断 $a$ 在一组中第几层，这个加上 $ans$ 就大功告成了。

分两种情况：

 - 如果 $mz-x<a$ ，说明 $a$ 在第 $k$ 层。
 - 正常情况下， $a$ 在第 $\lceil\frac{a}{y}\rceil$ 层。

那么代码就出来了：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,x,y,q,ldf,l,r,ans,a,mz;
int main(){
	scanf("%lld%lld%lld%lld%lld",&n,&k,&x,&y,&q);
	l=n/k;
	ldf=l*x+(n-l)*y;
	mz=x+(k-1)*y;\\预处理ldf和mz
	while(q--){
		cin>>a;
		a%=ldf;
		ans=a/mz*k;
		a%=mz;
		if(mz-x<a){
			ans+=k;
		}else{
			ans+=a/y+( a%y!=0 ? 1 : 0);\\三目运算符
		}
		if(!ans){
			ans=n;\\写程序是发现有0，懒得改了，就这样吧
		}
		cout<<ans<<'\n';\\输出
	}
        return 0;
} 
```

温馨提示： $a_i\le 10^{18}$ ！

---

## 作者：Deltary_ (赞：3)

题目：[[ROIR 2017 Day 1] 校园](https://www.luogu.com.cn/problem/P11506)

### 题意

一个表格有 $n$ 行，无限多列，在每一列中要求行数为 $k$ 的倍数的格子里有 $x$ 个数，其他各自中有 $y$ 个数，格子中的数按照自然数顺序排序。共 $q$ 次询问，求给出的数 $a_1, a_2, \dots, a_q$ 在表格中的行数。

下图是一种 $n = 7$, $k = 3$, $x = 2$, $y = 3$ 的情况，同题面样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/vre6suig.png)

### 思路

如果对于每一次询问，直接按照题意模拟填数的话，时间复杂度为 $\text{O} (qn)$ ，显然只能通过 subtask #1 。

考虑优化，规定每填 $k - 1$ 次 $y$ 和 $1$ 次 $x$ 为一个周期。

我们可以预处理出**每一列填入数字的数量**和**一个完整周期内填入数字的数量** $S_T$ 和 $S_k$  ，如果 $a_i > S_T$ ， 那么 $a_i$ 所在的行数与 ${a_i}^{\prime} = a_i \bmod S_T $ (${a_i}^{\prime} < S_T$) 所在的行数相同，可以缩小一定范围的常数。

接下来对于每次询问 ${a_i}^{\prime}$ ，我们可以计算出其经历了几个完整的周期，以及周期之外最后剩余的行数。这些都可以通过数学方法直接处理，时间复杂度 $\text{O} (q)$ 。

+ 在周期之内，计算经历了几个完整的周期，直接用 ${a_i}^{\prime}$ 整除 $S_k$ 即可。这一部分答案为周期数乘以周期 $k$ 。

+ 在周期以外，因为每个周期前 $k-1$ 格均为 $y$ 情况，最后 $1$ 格为 $x$ 情况，我们先判断其是否在周期的最后 $1$ 行，如果是，这一部分答案即为周期 $k$ 。反之则前面每一格内数量均为 $y$ ，使用周期外数字的数量除以 $y$ ，判断一下是否整除即可。

以样例为例， $S_T = 8$，$S_k = 19$ ，若询问 $a_1 = 50$ ，那么 ${a_1}^{\prime} = a_1 \bmod n = 12$ ， ${a_1}^{\prime}$ 经历了 $1$ 个完整的周期，最终剩余 $2$ 行，所以最终答案为 $3 + 2 = 5$ 。

核心判断语句如下：

```cpp
ll query(ll a){
    if(a==0) return n;
    ll block=a/Sk,tmp=block*Sk;// block 代表经历了几个完整周期， tmp 代表前面的周期有多少个数
    //printf("%lld block:%lld tmp:%lld\n",a,block,tmp);
    a-=tmp;
    if(a<=(k-1)*y){//全 y
        if(a%y) return block*k+a/y+1;
        else return block*k+a/y;
    }else{//含有 x & y
        return block*k+k;
    }
}
```

### 代码

评测记录：<https://www.luogu.com.cn/record/197131297>

代码(C++)：<https://www.luogu.com/paste/0ulbm2nd>

### 闲话

很好的签到题，注意 $a_i \leq 10^{18}$ 要开 long long 。

---

## 作者：liaoxingrui (赞：3)

## Content

有一栋楼，有 $n$ 个楼层，楼层号是 $k$ 倍数的楼层有 $x$ 间房子，其余楼层有 $y$ 间房子。

有 $q$ 组询问，每组询问给你一个房间号，问你它的楼层号？

例如 $n = 4 , k = 3 , x = 2 , y = 3$ 时：

![](https://cdn.luogu.com.cn/upload/image_hosting/n1792el9.png)

## Solution

这道题的 $q$ 最大只有 $1000$，很容易想到二分，二分查询楼层即可。

我们可以知道从第一楼层到第 $m$ 楼层，它有 $ \frac { m \times x } k + ( m - \frac m k ) \times y$ 个房间，就可以判断它在第 $mid$ 楼时是否已经包括了我们所查询的房间号。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,x,y,q,m,n;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>m>>k>>x>>y>>q;
	while(q--){
		cin>>n;
		n=(n-1)%((m/k)*x+(m-m/k)*y)+1; 
		int l=0,r=m,ans=0;
		while(l<=r){
			int mid=((l+r)>>1);
			if((mid/k)*x+(mid-mid/k)*y<=n){
				l=mid+1;
				ans=mid;
			}
			else
				r=mid-1;
		}
		cout<<ans+((ans/k)*x+(ans-ans/k)*y!=n)<<endl;
	}
	return 0;
}
```

---

## 作者：dear_deer_land (赞：2)

## 思路

我们需要确定根据房间编号确定其所在楼层，但考虑到楼层数 $n$ 可能高达 $10^9$，我们不能逐层遍历。因此，我们采用二分查找的方法来快速定位楼层。

1. **预处理每个楼道的房间总数**：
   - 计算每个楼道中 $k$ 的倍数楼层数 $m = \lfloor(n \div k)\rfloor$。
   - 每个楼道的房间总数 $T = m \times x + (n - m) \times y$。

2. **确定房间在楼道中的位置**：
   - 计算其在楼道中的房间序号 $idx = (a - 1) \bmod T + 1$。

3. **使用二分查找确定房间所在的楼层**：
   - 定义一个函数 `get_fl(idx)`，通过二分查找在楼层范围 $[1, n]$ 内找到使得累计房间数刚好大于或等于 $idx$ 的楼层。

4. **输出结果**：
   - 对每个查询，输出其所在的楼层。

## 代码实现

**十年 OI 一场空，不开 long long 见祖宗**
```
#include<bits/stdc++.h>
#define int long long//好用，但常数大，容易MLE，而且mian要使用signed
using namespace std;
int n,k,x,y;
int m;
int T;
int get_fl(int idx) { //获取房间所在楼层
	int l=1;
	int r=n;
	while(l<r) {
		int mid=(l+r)/2;
		int cnt=(mid/k)*x+(mid-(mid/k))*y;
		if(cnt>=idx) {
			r=mid;
		} else {
			l=mid+1;
		}
	}
	return l;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>k>>x>>y;
	m=n/k;
	T=m*x+(n-m)*y;
	int q;
	cin>>q;
	int a[1000];
	for(int i=0; i<q; i++) {
		cin>>a[i];
	}
	for(int i=0; i<q; i++) {
		int num=a[i];
		int idx=(num-1)%T+1;
		int fl=get_fl(idx);
		cout<<fl<<"\n";
	}
}
```

---

## 作者：jojo222 (赞：2)

这……有那么复杂吗，一眼橙。  
### 思路
解题分三步。

第一步，将 $a \bmod corr$，$corr$ 代表一个楼道的房间数。楼道中，是 $k$ 的倍数的共有 $\lfloor n\div k\rfloor\times x$ 间房间，其他有 $(n-\lfloor n\div k\rfloor)\times y$ 间房间。所以整个楼道有 $\lfloor n\div k\rfloor\times x+(n-\lfloor n\div k\rfloor)\times y$ 间房间。  
第二步，将 $a \bmod grp$，$grp$ 代表 $k$ 层楼的房间数 ，最后答案再补上 $\lfloor a\div grp\rfloor$ 个 $k$ 层楼的房间数。$k$ 层楼中，有一层楼有 $x$ 间，其他的有 $(k-1)\times y$ 间。共有 $x+(k-1)\times y$ 间房间。  
第三步，分类讨论。若不是是在 $k$ 层楼中第 $k$ 层的房间，则 $a\le grp-y$，那么得出答案 $\lceil a\div y\rceil$；若是第 $k$ 层楼，得出答案 $k$。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int k, n, x, y, q;
long long corr, grp;
int main()
{
    cin >> n >> k >> x >> y >> q;
    corr = 1ll * n / k * x + 1ll * (n - n / k) * y;
    grp = x + 1ll * (k - 1) * y;
    while(q--)
    {
		long long a;
		cin >> a;
		a %= corr;
		if(a == 0) a = corr;
		if(a % grp <= grp - x)
			cout << a / grp * k + (a % grp + y - 1) / y << endl;
		else cout << a / grp * k + k << endl;
	}
}
```

---

## 作者：Tracy_Loght (赞：1)

非常简单的一道签。

## 题目描述：

有一栋楼，你知道在上面每一次房间的分布情况，请问从左到右，从下到上的第 $x$ 个房间是什么。

![](https://cdn.luogu.com.cn/upload/image_hosting/n1792el9.png)

（样图，上面的数字均是房间编号）

求第 $x$ 个房间所在的层数是多少？

## 题目分析：

容易发现在第几栋楼对于层数不重要，那么我们大可以少算一点，及对于每一个房间编号求余一栋楼的房间个数。

（因为楼层号是 $k$ 的倍数的楼层上有 $x$ 个房间，其他楼层上有 $y$ 个房间，所以一栋楼有 $( n - n \div k ) \times y + ( n \div k ) \times x$ 间房子。）

然后对于每 $k$ 层，计算求的这间屋子在第几个 $k$ 层上，然后再计算屋子真正的层数，及判断它到底是在有 $y$ 个房间的层还是有 $x$ 个房间的层。

## 代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,a,b,jl,v,vk;
int main() {
	ios::sync_with_stdio(0);
	std::cin.tie();
	std::cout.tie();
	cin>>n>>k>>a>>b>>m;
	v=(n-n/k)*b+(n/k)*a;//每栋多少个房间
	vk=(k-1)*b+a;//每 k 层多少个房间
	for(int i=1;i<=m;i++){
		ll s;cin>>s;
		jl=0;
		if(s%v==0) {cout<<n<<"\n";continue;}
		else s=s%v;
		if(s>=vk) jl=(s/vk)*k;
		s=s%vk;
		if(s==0) {cout<<jl<<"\n";continue;}
		if(s<=(k-1)*b){
			jl=jl+(s/b);
			if(s%b!=0) jl++;
		}
		else jl=jl+k;
		cout<<jl<<"\n";
	}
	return 0;
}
```

[交流电记录](https://www.luogu.com.cn/record/197347550)

---

## 作者：floris (赞：1)

### 思路

这个题主要是对模的多重考虑（~~至少我的方法是这样的~~）。

首先，先求出一栋楼共 $n$ 层总共宿舍数量 $sum$，然后对于每一个询问，先算出输入的询问 $q$ 被 $sum$ 取模的值，这就是这个宿舍所在楼道的排序数，再类似上述方法，一步一步剥离，从而在最后加出答案。

注意开 long long！

### code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,x,y,q;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>k>>x>>y;
	cin>>q;
	int sum=0;
	sum=n/k*x+(n-n/k)*y;
	double ave=(double)((k-1)*y+x)/(double)k;
	while(q--){
		int ask,cnt=1,ans=0;
		cin>>ask;
		int md=ask%sum;
		if(md==0) md+=sum;
		int num=(k-1)*y+x;
		ans+=md/num*k;
		md-=md/num*num;
		if(md/y>=k-1){
			ans+=k-1;
			if(y*(k-1)<md) ans++;
		}
		else{
			if(md%y==0) ans+=md/y;
			else ans+=md/y+1;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---


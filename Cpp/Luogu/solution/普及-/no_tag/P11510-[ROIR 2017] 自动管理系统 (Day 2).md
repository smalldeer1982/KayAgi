# [ROIR 2017] 自动管理系统 (Day 2)

## 题目背景

翻译自 [ROIR 2017 D2T1](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day2.pdf)。

## 题目描述

某区级分拣中心的程序员团队正在开发邮件配送的自动管理系统。

包裹从客户的邮政网点接收。每个邮政网点接收的包裹重量为一个整数，单位是千克。包裹的最小重量为 $1$ 千克，最大重量为 $k$ 千克。接收的包裹会被放入一个专用的包裹袋中。

如果在放了某个包裹后，当前包裹袋中的总重量大于等于 $x$ 千克，则该包裹袋会被运送到市级邮政中心，在市级邮政中心，包裹袋会被放入一个专用的集装箱。

如果在放了某个包裹袋后，当前集装箱中的总重量大于等于 $y$ 千克，则该集装箱会被运送到区级分拣中心，在区级分拣中心，包裹最终会被送达收件人。

你需要求出，当一个集装箱被运送到区级分拣中心时，它的最小可能重量是多少。

## 说明/提示

### 样例解释

在样例中，单个包裹的重量可能是 $1$ 千克或 $2$ 千克。当包裹袋的总重量大于等于 $7$ 千克时，包裹袋会被运送到市级邮政中心。当集装箱的总重量大于等于 $20$ 千克时，集装箱会被运送到区级分拣中心。

在这个例子中，最小可能的集装箱重量为 $21$ 千克，具体方式是：
- 通过送入 $7$ 个 $1$ 千克的包裹，或 $3$ 个 $2$ 千克的包裹和一个 $1$ 千克的包裹，让一个包裹袋达到 $7$ 千克，而被送到市级邮政中心。
- 送三个这样的包裹袋到市级分拣中心，集装箱的重量就能达到 $21$，而被送往区级分拣中心。 

可以证明，当一个集装箱被运送到区级分拣中心时，它的重量不可能小于 $21$ 千克。

### 数据范围

| 子任务 | 分值 | $k$ | $x,y$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $21$ | $=1$ | $\le100$ |
| $2$ | $18$ | $=2$ | $\le100$ |
| $3$ | $21$ | $\le100$ | $\le100$ |
| $4$ | $17$ | $\le40000$ | $\le40000$ |
| $5$ | $23$ | $\le10^9$ | $\le10^9$ |

## 样例 #1

### 输入

```
2
7
20```

### 输出

```
21```

# 题解

## 作者：duanxinghe (赞：8)

# 洛谷P11510 [ROIR 2017 Day 2] 自动管理系统题解

## 题目简要概述：
有若干包裹重量为 $1$ 到 $k$，将一些包裹装进包裹袋中，若包裹袋重量 $\geq x$，那么会将这一个包裹袋放进一个集装箱，若集装箱里面的所有包裹袋重量之和 $\geq y$ 则可配送。问：当集装箱可以配送时，最小重量是多少？

## 分析：
对于每个包裹袋被放进集装箱的可能性为 $x$ 到 $x + k - 1$，若每个包裹袋的重量都以最大的可能性被装进集装箱，且集装箱的重量要最小，那么最大的情况就一定要最小，所以当每个包裹袋都以最大的重量放进集装箱时，只要重量 $\geq y$ 就没有必要再放进其他的包裹袋，这个重量就是它的上限 $R$。即：


---

$ s = \lceil y \div (x + k - 1) \rceil $ 

$ R = s \times (x + k - 1) $ 

---


那如何确定它的下限呢？非常简单，设我们用了 $s$ 个重量最大包裹袋放进了集装箱，那么我们把重量最大的包裹袋全部换为重量最小的包裹袋也一定是可以放进集装箱的，这样装进集装箱的总重量就是它的下限。我们用 $L$ 表示它的下限，即：


---

$ L = s \times x $

---

那么答案就在 $L$ 和 $R$ 之间，因为我们能够保证 $R > y $。所以我们就拿 $L$ 与 $y$ 取较大值，即答案。



---

## 贴心附上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,y,s,k;
int main() {
	cin>>n>>x>>y;
	k=x+n-1;
	if(y%k==0) s=y/k;
	else s=y/k+1;
	s*=x;
	cout<<max(s,y);
	return 0; 
}
```

---

## 作者：jojo222 (赞：4)

2025.1.6 update: 修正了向上取整的问题。

要分类讨论。
- $y\le x$：直接得 $x$，用一堆 $1$ 的小包裹过了市级直接送给区级。
- 接下来不要着急得 $\lceil y\div x\rceil\times x$，这是大多数用户犯的错误。有可能会让市级蒙了，比如说一开始慢慢送 $1$ 的小包裹，后面忽然给个大的 $k$，总数直接到了 $x+k-1$ 的恐怖重量，会少给几个包裹，平均分 $y$，直接卡在 $y$ 的轻重量。平均分后最大的一个包裹的重量是 $\lceil y\div(\lceil y\div x\rceil-1)\rceil$，它是肯定会大于 $x$ 的，不用担心，只要它不超过 $x-k-1$ 就可以啦。判断的条件是 $x+k-1\ge\lceil y\div(\lceil y\div x\rceil-1)\rceil$。
- 最后，只能得 $\lceil y\div x\rceil\times x$ 了。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int k, x, y;
int f(int a, int b)
    {return (a + b - 1) / b;}
int main()
{
    cin >> k >> x >> y;
    if(y <= x) cout << x;
    else if(x + k - 1 >= f(y, f(y, x) - 1)) cout << y;
    else cout << f(y, x) * x;
    return 0;
}
```

---

## 作者：lam_dyr (赞：2)

分类讨论题。

~~赛时没想全爆砍 21 分，我是奶龙。~~

## 题意

本题的核心在于如何尽可能地利用包裹袋的重量，使得集装箱的重量尽可能小。

## 思路

分类讨论如下：

1. $x \ge y$

   - &#x20;包裹袋的最小重量已经大于等于集装箱的最小重量。这意味着一个包裹袋就可以直接满足集装箱的重量要求。
   - 此时答案就是 $x$。
2. $x<y$ 且 $\lceil \frac{y}{\lfloor \frac{y}{x} \rfloor} \rceil \leq x + k - 1$

   - $\lfloor \frac{y} {x} \rfloor$ 表示如果每个包裹袋都尽可能接近 $x$ 的情况下每个包裹袋的平均重量。
   - $\lceil \frac{y}{\lfloor \frac{y}{x} \rfloor} \rceil$ 表示在这种平均分配的情况下，最重的一个包裹袋的重量。
   - 如果最重的包裹袋的重量小于等于 $x + k - 1$，这意味着我们可以通过合理地分配包裹袋，使得集装箱的重量正好是 $y$。
   - 此时答案就是 $y$。
3. 其他情况

   - 此时答案就是 $\lceil \frac{y} {x} \rceil \times x$。

注意开 `long long`。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    long long k, x, y;
    cin >> k >> x >> y;
    if (x >= y) {
        cout << x << endl;
        return 0;
    }
    long long flr = y / x;
    long long cel = (y + flr - 1) / flr;
    if (cel <= x + k - 1) {
        cout << y << endl;
        return 0;
    }
    long long ans = (y + x - 1) / x * x;
    cout << ans << endl;
    return 0;
}

```

---

## 作者：yi_hr (赞：2)

## 思路
1. **确定包裹袋数量 $n$**：
   - 为最小化总重量，我们希望使用尽可能少的包裹袋。
   - 包裹袋的最大重量为 $x+k-1$ 千克，因此最少需要的包裹袋数为：
     $$
     n_{\text{low}}=\left\lceil\frac{y}{x+k-1}\right\rceil
     $$
   - 每个包裹袋的最小重量为 $x$ 千克，因此最多可以使用的包裹袋数为：
     $$
     n_{\text{high}}=\left\lfloor\frac{y}{x}\right\rfloor
     $$
2. **判断能否达到 $y$ 千克**：
   - 如果存在某个包裹袋数量 $n$ 满足$n_{\text{low}}\leq n\leq n_{\text{high}}$，则可以精确达到 $y$ 千克，即 $y'=y$。
   - 否则，最小的 $y'$ 将是刚好超过 $y$ 的最小包裹袋重量总和，即：
     $$
     y' = \left\lceil \frac{y}{x} \right\rceil \times x
     $$

### 代码实现：

1. **计算最少和最多的包裹袋数**：
   - `low` 用上取整计算，即：
     $$
     n_{\text{low}} = \left\lceil \frac{y}{x + k - 1} \right\rceil = \frac{y + (x + k -1) -1}{x + k -1}
     $$
   - `high` 用下取整计算，即：
     $$
     n_{\text{high}} = \left\lfloor \frac{y}{x} \right\rfloor
     $$

2. **确定 $y'$**：
   - 如果 $n_{\text{low}}\leq n_{\text{high}}$，则说明可以达到 $y$ 千克，即 $y'=y$。
   - 否则，计算最小的 $y'$ 为：
     $$
     y'=\left\lceil\frac{y}{x}\right\rceil\times x
     $$
## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll k,x,y;
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>k>>x>>y;
    ll cnt=x+k-1;
    ll low=(y+cnt-1)/cnt;
    ll hi=y/x;
    ll ans;
    if(low<=hi)ans=y;
    else{
        ll n=(y+x-1)/x;
        ans=n*x;
    }
    cout<<ans;
}
```

---

## 作者：封禁用户 (赞：1)

这道题需要分类讨论：

需要先算出包裹的最大总重量为 $x + k - 1$。

 - 如果 $x \le y$，那么直接输出 $x$。

 - 如果 $x - k + 1 \ge \lceil y \div \lceil y \div x \rceil  \rceil$，那么就输出 $y$。

 - 剩下的就输出 $(y \div x + 1) \times x$ 了。

代码很简单就不予展示了。

管理员大大求过吧 QAQ。

---

## 作者：Planet_Earth (赞：1)

## P11510 [ROIR 2017 Day 2] 自动管理系统
 ps：一道有比较数学含量的思维题目，~~干了我 30 分钟~~

### [题目传送门](https://www.luogu.com.cn/problem/P11510)

废话不多说，进入正题：

这道题需要我们计算出集装箱的最小可能重量。

我们需要分类讨论。

如果 $y ≤ x$，则直接返回 $x$，因为包裹的重量不可能小于 $y$，直接输出 $x$。

如果 $⌈y ÷ ⌊y ÷ x⌋⌉ ≤ x + k - 1$，所以返回 $y$。

这个条件的意思就是：在尽可能平均分配的情况下，最重的包裹的重量不会超过 $x + k - 1$，所以可以直接返回 $y$。

否则，我们需要计算 $⌈y ÷ x⌉ × x$，这表示在最坏情况下，包裹的重量。

完结撒花。

---

## 作者：jiqihang (赞：1)

### 题目链接
[P11510 [ROIR 2017 Day 2] 自动管理系统](https://www.luogu.com.cn/problem/P11510)
### 题意
若干包裹，重量 $1$ 至 $k$，如包裹袋的质量 $\ge x$，那么会将这一个包裹袋放进一个集装箱，若集装箱里面的所有包裹袋重量之和 $\ge y$ 则可配送。

求解当集装箱可以配送时的最小重量。
### 解决
1. 定义需要输入的 $k$（最大重量）、$x$（可放入集装箱的质量）和 $y$（可配送的质量）。
2. 输入。
3. 确定其上限和下限，答案就在上限和下限之间，上限大于 $y$，我们用下限和 $y$ 找个最大值，即为答案。

我们可以这样找下限：

定义一个 $n$ 为 $x+k-1$，把下限定义为 $s$。

如果 $y$ 能整除 $n$，$s$ 为 $\lfloor y \div n\rfloor$，否则，为 $\lfloor y \div n\rfloor + 1$。

最后 $s$ 还要乘上 $x$。

剩下的具体的看代码吧。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,x,y;
	cin>>k>>x>>y;
    //定义和输入
	int n=x+k-1,s;
	if(y%n==0) s=y/n;
	else s=y/n+1;
	s=s*x;
    //找下限
	cout<<max(s,y);//比较
	return 0;
} 
```

---

## 作者：_xdd_ (赞：1)

因为小包裹的重量是 $1$ 到 $k$，所以包裹袋的重量最小为 $x$，最大为 $x-1+k$，分别是放一堆 $1$ 和放 $x-1$ 个 $1$，最后放一个 $k$。

设包装袋数量为 $n$，$n$ 最小为 $\lceil \frac{y}{x-1+k} \rceil$。

如果 $nx>y$，则集装箱的重量为 $nx$，否则为 $y$。

答案即为 $\max(\lceil \frac{y}{x-1+k} \rceil\times x,y)$。

---

## 作者：cy20110922 (赞：1)

# 分析
这道题想让我们算出包裹重量最小的情况，本来想用贪心来做的，但做了半天做不出来。然后手误点到了题解，看了一下大佬的题解，瞬间学会了呢。
# 做法
1. 我们可以将题目分为两种情况。
2. 第一种是 $x\ge y$ 我们可以直接输出 $x$。否则再分两种情况。
3. 第二种是  $x+k-1\ge(y+((y+x-1)\div x-1)-1)\div((y+x-1)\div x-1)$ 因为正常打有点耗时间，所以我们可以定义一个函数叫 $mjy$ 来求 $(n+m-1)\div m$，所以第一种情况化简为 $x+k-1\ge mjy(y,mjy(y,x)-1)$ 然后我们就可以直接输出 $y$。
4. 第三种是前两种都不符合，我们可以输出 $mjy(y,x)\times x$。
# 代码

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include<iomanip>
#include<stack>
#include<algorithm>
#include<queue>
#include<cstring>
#include<map>
#define int __int128
#define ll long long
using namespace std;
ll m,mjj,myy;
ll mjy(ll n, ll m) {
	return (n+m-1)/m;
}
signed main() {
	cin >> m >> mjj >> myy;
	if(myy<=mjj) cout << mjj;
	else if(mjj+m-1>=mjy(myy,mjy(myy,mjj)-1))cout << myy;
	else cout << mjy(myy, mjj)*mjj;
	return 0;
}
```

---

## 作者：dear_deer_land (赞：0)

## 思路

每个包裹袋的重量至少为 $x$ 千克，最多为 $x + k - 1$ 千克（因为最后一个包裹的重量最多为 $k$ 千克）。\
为了最小化集装箱的总重量，我们希望使用尽可能少的包裹袋。\
设需要的包裹袋数量为 $t$，则需要满足：$t \times (x + k - 1) \geq y$ 因此，$t$ 的最小值为：$t = \left\lceil \frac{y}{x + k - 1} \right\rceil$。\
如果 $t \times x \geq y$，则集装箱的重量为 $t \times x$ 千克。否则，集装箱的重量为 $y$ 千克。
整合一下式子，集装箱的最小重量 $W$ 可以表示为：$W = \max(t \times x, y)$\
最后请注意：**十年 OI 一场空，不开 long long 见祖宗！** 剩下的一些细节请看代码注释。

## 代码

```
#include <bits/stdc++.h>
#define int long long//把所有int类型变成long long 
using namespace std;
signed main(){//main函数返回值为int，使用signed固定main返回值类型 
	int k,x,y,t;
	cin>>k>>x>>y;
	t=y/(x+k-1);
	if(y%(x+k-1)!=0){//向上取整 
		t++;
	}
	int w=max(t,y); 
    cout<<w;
    return 0;
}
```

---

## 作者：signed_long_long (赞：0)

# 题目解法

- 当 $x\ge y$ 时：很显然，答案就为 $x$。
- 当 $\lceil y\div \lfloor y\div x\rfloor\rceil\le x+k-1$ 是：答案为 $y$。原因：每个包裹的重量是在 $x\sim x+k-1$ 之间的，$\lceil y\div \lfloor y\div x\rfloor\rceil$ 表示尽可能平均分时最重一个包裹的重量，实现方式就是尽可能平均分。例：$k=4,y=20,x=6$ 时，分的方式就是 $6,7,7$。
- 最后，答案就只能是 $\lceil y\div x\rceil \times x$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,x,y;
int main(){
	cin>>k>>x>>y;
	if(x>=y) return printf("%d",x),0;
	else if(ceil(y*1.0/(y/x))<=x+k-1) return printf("%d",y),0;
	printf("%d",int(ceil(y*1.0/x)*x));
	return 0;
}
```

---


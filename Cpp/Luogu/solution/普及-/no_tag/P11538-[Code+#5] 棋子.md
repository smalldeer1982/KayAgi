# [Code+#5] 棋子

## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。

## 题目描述

棋盘从左到右被分割成 $n(n\le 1000)$ 个格子，从左到右编号为 $1,2,\dots,n$。棋盘上有 $m(m\le n)$ 个棋子，编号为 $1,2,\dots,m$ ，编号为 $i$ 的棋子刚开始摆放在编号为 $p_i$ 的格子上，一个格子最多摆放一个棋子。每次操作小R可以选择一个棋子，将它移动到它右边第一个空着的格子中，如果它右边没有空着的格子了，那么这就是一个非法操作，执行一次非法操作不会对棋盘有任何改变。小 R 依次做了 $k$ 次操作，如果一次操作是合法的，你需要输出这颗棋子移动到的格子的编号，如果是非法的，你需要输出 `error!`。

## 说明/提示

**数据范围：**

$\def\arraystretch{1.21}
\begin{array}{|c|c|c|}\hline
\bold{\small{子任务}}&\textbf{score}&\textbf{constraints}\\\hline
\text{A}&30&m=1\\\hline
\text{B}&70&\small{无特殊限制}\\\hline
\end{array}$

对于所有数据，保证 $1\le m<n\le1000$，$1\le k\le10000$，$1\le p_i\le n,1\le x_i\le m$，$p_i$ 互不相等。


## 样例 #1

### 输入

```
5 3 7
3 1 4
3 1 1 1 2 3 1
```

### 输出

```
5
4
error!
error!
2
error!
error!
```

# 题解

## 作者：AFO_Lzx (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P11538)

### $\texttt{Solution}$

一道水题，按照题意模拟即可。注意在每一次的移动之后，有两项操作：

- $a_x$ 的值要对应变为移动后的位置。
- 标记数组要把原来的位置改为 $0$，移动后的位置改为 $1$。

还有，`error!` 后面有感叹号，一定不要漏掉，否则你会喜提 $0$ 分大礼包一份。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e3 + 5;
int n, m, k, a[maxn];
bool vis[maxn];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m >> k;
	
	for (int i = 1; i <= m; i++) {
		cin >> a[i];
		vis[a[i]] = true;
	}
	
	while (k--) {
		int x; cin >> x;
		int num = a[x];
		bool flag = false;
		
		for (int i = 1; i <= n - num; i++) {
			if (vis[num + i] == false) {
				a[x] += i;
				cout << a[x] << "\n";
				vis[num] = false;
				vis[num + i] = true;
				flag = true;
				break;
			}
		}
		
		if (!flag) cout << "error!\n";
	}
	
	return 0;
}
```

完结，这题真简单。

---

## 作者：_Deer_Peach_ (赞：3)

一道简单的模拟题。

题意：

有 $n$ 个格子和 $m$ 个棋子，有 $k$ 次操作，每次操作使当前棋子移动到它右边第一个空格子，如果没有就为不合法操作，不执行该操作，输出 ```error!```，否则输出操作后棋子所在的格子编号。

思路：

因为数据范围很小，所以暴力模拟能过，用一个数组记录第 $i$ 个棋子当前所在格子的编号，另一个数组标记第 $j$ 个格子是否有棋子。每次操作寻找它右边第一个空格子，能找到输出格子编号，并更新，否则输出 ```error!```。

代码：

模拟即可。
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
int n,m,k,a[1001];bool vis[1001];signed main(){
	IOS;cin>>n>>m>>k;for(int i=1;i<=m;i++)cin>>a[i],vis[a[i]]=true;//输入和初始化
	for(int i=1;i<=k;i++){
		int x;cin>>x;bool flag=false;//标记是否有合法格子
		for(int j=a[x]+1;j<=n;j++){
			if(!vis[j]){//找到空格子更新状态
				vis[j]=true;vis[a[x]]=false;a[x]=j;
				cout<<j<<endl;flag=true;break;
			}
		}if(!flag)cout<<"error!"<<endl;//不合法的操作
	}return 0;
}

```

---

## 作者：syx_2014 (赞：2)

离谱样例，坑了好几次。

先用数组模拟象棋的位置，象棋放置的地方标记上象棋的标号。

暴力做法，找到移动象棋的编号，把它记录下来，往后枚举有没有空位即可，记得把象棋放进去，把旧位置清空。

用变量标记一下，如果无方案输出 ```error!```。

$O(nk)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int p[1010],b[1010];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>p[i];
		b[p[i]]=i;
	}
	for(int i=1;i<=k;i++){
		int x;
		cin>>x;
		int ii;
		for(int j=1;j<=n;j++){
			if(b[j]==x){
				ii=j;
				break;
			}
		}
		bool f=0;
		for(int j=ii+1;j<=n;j++){
			if(!b[j]){
				b[j]=b[ii];
				b[ii]=0;
				cout<<j<<'\n';
				f=1;
				break;
			}
		}
		if(!f) cout<<"error!\n";
	}
	return 0;
}

```

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11538)

一道模拟题。对于每一次询问，先找出编号为 $x_i$ 的棋子的位置 $pos$，随后向右枚举空位即可。时间复杂度 $O(nk)$，足以通过本题。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1001;
int n,m,k,a[N],p[N],x[N],pos;//pos 为棋子的位置 
bool flag;//flag 表示每一轮是否有空位出现 
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>p[i];
		a[p[i]]=i;//标记第 i 个棋子的出现位置 p[i] 
	}
	for(int i=1;i<=k;i++){
		cin>>x[i];
		for(int j=1;j<=n;j++){//找到目标棋子 
			if(a[j]==x[i]){
				pos=j;
				break;
			}
		}
		flag=false;//记得初始化 
		for(int j=pos+1;j<=n;j++){//往右寻找空位 
			if(!a[j]){//如果有空位 
				a[j]=a[pos];//将棋子移过来
				a[pos]=0;//原位置不要忘记清空
				cout<<j<<endl;
				flag=true;//有空位，flag 为真 
				break;
			}
		}
		if(!flag) cout<<"error!\n";//没位置了，输出 "error!" 
	}
}
```

---

## 作者：Doraeman (赞：1)

## 思路
这道题要求其实就是**从 $i$ 开始，到 $n$ 结束，找到第一个空位然后把 $i$ 放进去**。

观察数据范围，$n\le 10^3$，$k\le 10^4$，就算是用 $O(nk)$ 的做法也不会超时。

接下来就可以快乐地暴力啦。

首先，用两个数组存储。
- $a[i]$ 位置上是 $i$ 号数。
- $i$ 号数在 $b[i]$ 位置上。

接下来，读入 $k$ 次，每次读入 $x$，用 $i$ 遍历从 $x$ 所在的位置 $b[x]$ 开始到棋盘的右边界 $n$ 结束，只要 $i$ 位置是空位就更新。
- ```a[b[x]]=0```（$x$ 被移走，$i$ 位置变空）。
- ```a[i]=x```（$i$ 位置上出现了 $x$）。
- ```b[x]=i```（$x$ 的位置是 $i$）。

最后，如果没有空位就输出```error!```。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;

int n, m, k, a[MAXN], b[MAXN];
// a[i] 表示 a[i]位置为第i号数 (a[i] = 0表示i位置是空位) 
// b[i] 表示 第i号数在b[i]位置 

int main(){
    cin >> n >> m >> k;
    
    for(int i=1; i<=m; i++){
        int x; cin >> x;
        a[x] = i;
        b[i] = x;
        // 读入时处理a数组和b数组 
    }
    
    while(k--){
        int x; cin >> x;
        bool flag = 1; // flag = 1 表示没有找到空位 
        for(int i=b[x]+1; i<=n; i++){ // 从b[i]+1遍历到n寻找空位 
        	if(a[i] == 0){ // a[i] 是空位 
	        	cout << i << '\n'; // 找到了，输出答案 
	        	
				// 按题意更新 
	        	a[b[x]] = 0, a[i] = x; 
	        	b[x] = i; 
				
	        	flag = 0; // flag = 0 表示找到空位了 
	        	break; // 找到了第一个，不用再找了 
	        }
		}
		if(flag) // 没有找到，输出 error! 
			cout << "error!\n";
    }
    
    return 0;
}
```

---

## 作者：ridewind2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11538)

## 思路

直接模拟，时间复杂度 $O(nk)$，不会超时。

每次询问，先找到目标棋子的位置 $t$，往后枚举有没有空位。

如果无解要输出 ```error!```。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[1010],a[1010];
int main(){
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>p[i];
		a[p[i]]=i;
	}
	while(k--){
		int x;
		cin>>x;
		int t;
		for(int i=1;i<=n;i++){
			if(a[i]==x){
				t=i;
				break;
			}
		}
		bool f=0;
		for(int i=t+1;i<=n;i++){
			if(!a[i]){
				a[i]=a[t],a[t]=0;
				cout<<i<<"\n";
				f=1;
				break;
			}
		}
		if(!f)cout<<"error!\n";//没有找到 
	}
	return 0;
}
```

---

## 作者：Malkin_Moonlight (赞：0)

## Solution

模拟题。

注意到数据很小，可以暴力做。对于每次操作，就把棋子移到右方第一个没有棋子的格子即可。

时间复杂度 $\mathcal{O}(nk)$。

要注意这个 `error!` 有 `!`。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 5;
ll n, m, k, x;
ll a[maxn];
bool vis[maxn];

int main() {
	cin >> n >> m >> k;
	for (ll i = 1; i <= m; i++) {
		cin >> a[i];
		vis[a[i]] = true;
	}
	while (k--) {
		cin >> x;
		bool flag = false;
		for (ll i = a[x] + 1; i <= n; i++) {
			if (vis[i] == false) {
				vis[a[x]] = false;
				vis[i] = true;
				a[x] = i;
				cout << a[x] << endl;
				flag = true;
				break;
			}
		}
		if (!flag) cout << "error!" << endl;
	}
	return 0;
}
```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P11538)

# 思路

我们需要模拟棋子在棋盘上的移动过程。棋盘有 $n$ 个格子，$m$ 个棋子，每个棋子初始位置为 $p_i$。每次操作选择一个棋子，将其移动到右边第一个空着的格子中。如果右边没有空着的格子，则操作非法。

1.  **数据结构**：
    *   使用一个数组 $pos$ 来记录每个棋子的当前位置。
    *   使用一个数组 $occupied$ 来记录每个格子是否被占用。
2.  **操作模拟**：
    *   对于每次操作，找到指定棋子的当前位置。
    *   从当前位置开始，向右寻找第一个未被占用的格子。
    *   如果找到，则移动棋子到该格子，并输出该格子的编号。
    *   如果未找到，则输出 `error!`。
3.  **优化**：
    *   由于 $n$ 和 $k$ 的范围较大（$n\le 10^3$，$k\le 10^4$），我们需要确保每次操作的复杂度尽可能低。
    *   可以使用一个指针数组来记录每个棋子右边第一个空着的格子，避免每次操作都从当前位置开始遍历。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
#define Made return
#define by 0
#define _3_14 ;
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5;
int n,m,k,pos[MAX];// 每个棋子的当前位置
bool occupied[MAX];// 每个格子是否被占用
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){// 初始化棋子的位置
        cin>>pos[i];
        occupied[pos[i]]=true;
    }
    for(int i=0;i<k;i++){// 处理每次操作
        int x;
        cin>>x;
        int currentPos=pos[x],nextPos=currentPos+1;
        // 寻找右边第一个空着的格子
        while(nextPos<=n&&occupied[nextPos])nextPos++;
        if(nextPos<=n){
			// 移动棋子到 nextPos
            occupied[currentPos]=false;
            occupied[nextPos]=true;
            pos[x]=nextPos;
            cout<<nextPos<<'\n';
        }else cout<<"error!\n";
    }
	Made by _3_14
}
```

[**AC 记录**](https://www.luogu.com.cn/record/197549935)

---

## 作者：DFM_O (赞：0)

## [P11538 题目](https://www.luogu.com.cn/problem/P11538)

### 解题思路
模拟题，对于每次修改暴力查找右边最近的没有棋子的位置即可，时间复杂度 $O(nk)$，可以通过。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int o[1001];
bool pd[1002];
signed main()
{
	ios::sync_with_stdio(false);
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
	{
		int x;
		cin>>x;
		o[i]=x,pd[o[i]]=1;
	}
	while(k--)
	{
		int x;
		cin>>x;
		int now=o[x];
		while(pd[++now]==1);
		if(now>n)
			cout<<"error!\n";
		else
			cout<<now<<"\n",pd[o[x]]=0,o[x]=now,pd[o[x]]=1;
	}
	return 0;
}
```

---

## 作者：god_std (赞：0)

### 题目内容

在一个长度为 $n$ 的一维棋盘中，有 $m$ 枚棋子，他们的位置分别为 $p_1,\cdots,p_m$，现在要进行 $k$ 次操作，每次操作给定一个序号 $x_i$，将第 $x_i$ 个棋子移到他右边的第一个空位；若右边没有空位，则输出 `error!`。

### 分析与方法

首先计算一下暴力的复杂度：$O(kn)$ 可以 AC，所以只需要暴力。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,p[1000000],x[1000000],vis[1000000];
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
	{
		cin>>p[i];
		vis[p[i]]=1;
	}
	for(int i=1;i<=k;i++)
	{
		int op;
		cin>>op;
		bool flag=false;
		for(int j=p[op];j<=n;j++)
		{
			if(vis[j]==0)
			{
				cout<<j;
				vis[p[op]]=0;
				p[op]=j;
				vis[p[op]]=1;
				flag=true;
				break;
			}
		}
		if(flag==false)
		{
			cout<<"error!";
		}
		cout<<endl;
	}
} 
```

### Tip

注意 `error!` 后面的 `!`。

---

## 作者：ZSYhaouuan (赞：0)

一道水题，纯模拟。

题目很好看懂，不再赘述了。

每次操作一颗棋子，一道右方第一个空格的位置去。

注意到数据范围撑起来最多就 $10^7$ 这么大，完全可以暴力找。

于是就简单的把代码写出来了：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,b[1000000+100];//当前棋子的位置
bool a[1000000+100];//当前位置是否有棋子
int main(){
	cin>>n>>m>>k;
	for(ll i=1;i<=m;i++){
		ll x;
		cin>>x;
		b[i]=x;
		a[x]=1;
	}
	for(ll i=1;i<=k;i++){
		ll x;
		cin>>x;
		bool flag=0;
		//暴力查找
		for(ll i=b[x]+1;i<=n;i++){
			if(!a[i]){
				a[b[x]]=0;
				b[x]=i;
				a[b[x]]=1;
				flag=1;
				cout<<b[x]<<"\n";
				break;
			}
		}
		//没找到输出error!
		if(!flag) cout<<"error!\n";
	}
	return 0;
}
```

总结：红题的难度，没有什么思维含量的。

---


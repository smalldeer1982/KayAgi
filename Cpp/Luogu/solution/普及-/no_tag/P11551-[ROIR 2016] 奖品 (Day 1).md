# [ROIR 2016] 奖品 (Day 1)

## 题目背景

翻译自 [ROIR 2016 D1T1](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day1.pdf)。

## 题目描述

Petya 参加了一个比赛，在这个比赛中将会抽取 $n$ 个奖品。奖品编号从 $1$ 到 $n$。

根据比赛结果，参赛者可以获得 $2$ 到 $n$ 之间的分数。如果参赛者获得了 $k$ 分，那么他将从编号 $1$ 到 $k$ 的奖品中获得一个奖品。比赛主持人在参赛者选择奖品之前，会从奖品列表中删除一个奖品。然后，参赛者可以从剩下的 $k - 1$ 个奖品中选择一个。

Petya 知道所有奖品的价值，第 $i$ 个奖品的价值为 $a_i$。

对于每个 $2\le k\le n$，你需要求出如果 Petya 获得了 $k$ 分，他一定能得到的最大奖品价值是多少。

## 说明/提示

| 子任务 | 是否捆绑 | 分值 | $1\le n\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $24$ | $100$ |
| $2$ | 是 | $24$ | $5000$ |
| $3$ | 是 | $52$ | $100000$ |

## 样例 #1

### 输入

```
5
1 3 4 2 5```

### 输出

```
1 3 3 4```

# 题解

## 作者：cff_0102 (赞：6)

题意简述：求前缀次大值。

用两个变量 $mx,mx2$ 记录目前的最大值和次大值。

- 如果新的数 $x$ 大于等于原本的 $mx$，则将 $mx2$ 替换为 $mx$ 并将 $mx$ 替换为 $x$；
- 否则，如果 $x$ 大于等于原本的 $mx2$，则将 $mx2$ 替换为 $x$。

每加一个数后就输出当前的 $mx2$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n;cin>>n;
	int mx=0,mx2=0;
	cin>>mx;
	while(--n){
		int x;cin>>x;
		if(x>=mx)mx2=mx,mx=x;
		else if(x>=mx2)mx2=x;
		cout<<mx2<<" ";
	}
	return 0;
}
```

---

## 作者：GFyyx (赞：5)

## 解题思路
贪心，没什么好说。

贪心地想，Petya 肯定选当前合法的最大值。主办方会将最大值给拿走，变为非法。

显然地，这题就是求次大值，具体实现可以看代码，有注释说明。

## 满分代码
```cpp
#include <stdio.h>
int a[114514],max1,max2;
main(){
    int n;scanf("%d",&n);
    for(register int i=1; i<=n; i++){
        scanf("%d",&a[i]);
        if(a[i]>=max1) max2=max1,max1=a[i];//大于最大值 
        else if(a[i]>max2) max2=a[i];//介于最大和次大值之间 
        if(i-1) printf("%d ",max2);//输出答案 
    }
    return 0;
}

---

## 作者：orpg (赞：4)

### 简化题意
其实本题就是求 $2\le i\le n$ 的次大值。

那么就会有两种情况：

1. 当前值比最大值大，那么将原最大值赋给次大值并输出。
2. 当前值比次大值大，更新次大值并输出。
### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
const int maxn=1e5+5;
int a[maxn];
int ma,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		if(ma<=a[i]){
			ans=ma;ma=a[i];
		}
		else if(a[i]>ans){
			ans=a[i];
		} 
		if(i>=2) cout<<ans<<" ";
	}
	return 0;
}
```

---

## 作者：ridewind2013 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11551)

## 分析

给你一个序列，求出从 $a_{1}$ 到 $a_{k} (2 \le k \le n)$ 中，删除一个数后一定能得到的最大值。

## 思路

运用贪心的思想，考虑最差的情况，删掉了最大价值的奖品，所以每次答案就是次大值。

许多大佬直接求的，我写一个[优先队列](https://baike.so.com/doc/500481-529943.html)的题解，每次先将读入的数添加进优先队列里，接着将最大值存在一个变量里，然后删掉最大值，再输出当前的最大值，就是次大值，最后别忘了再将原本的最大值再添加回去。

## AC Code


```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int>q;//优先队列 
int main(){
	int n;
	cin>>n;
	while(n--){
		int x;
		cin>>x;
		q.push(x);
		if(q.size()==1)continue;//如果优先队列里只有一个数，就不输出次大值 
		int t=q.top();//存入变量 
		q.pop();//删除最大值 
		cout<<q.top()<<" ";//输出次大值 
		q.push(t);//加回来
	}
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：
这题是要我们删除一个数后一定能得到的最大值。

贪心，考虑最差的情况，删掉了最大价值的奖品，所以每次答案就是次大值。

那么，我们本题就可以用队列的方式，每次先将读入的数添加进优先队列里，接着将最大值存在一个变量里，然后删掉最大值，再输出当前的最大值，就是次大值，最后别忘了再将原本的最大值再添加回去，这样就行了。

---

### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

priority_queue<int> q;
int n, x, t = 0;

int main() {
	cin >> n;
	while (n--) {
		cin >> x;
		q.push(x);
		if (q.size() == 1) continue;
		t = q.top();
		q.pop();
		cout << q.top() << " "; 
		q.push(t);
	}
	return 0;
}
```

---

## 作者：jiqihang (赞：2)

### 分析
早上因为有事没打这场比赛，于是晚上有空来看了一下。

主办方肯定会把价值最大的拿走，Petya 肯定会在剩下的里面拿最大的。

那么这题其实就是让我们求次大值。

那我们该怎么求次大值呢？

我们可以分类讨论：

1. 当前的值大于等于次大值，更新次大值，然后输出。
2. 当前的值大于等于最大值，先将最大值赋给次大值，然后更新最大值，最后输出此时的次大值。

注意：
1. 变量不可以定义为 $max$，会 CE。
2. 只有当 $i>0$（$i$ 为循环变量），也就是有两个及以上个值的时候才可以输出，不加判断会 WA。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,mx,n;
int main()
{
	cin>>n;
for(int i=0;i<n;i++)
{
int ssj;
cin>>ssj;
if(ssj>=m) mx=m,m=ssj;
else if(ssj>=mx) mx=ssj;
if(i>0) cout<<mx<<" ";
}
}
```

---

## 作者：Zhang1024 (赞：2)

### **题目大意**  
给定 $n$ 个数，为 $a_1,a_2,a_3,\dots,a_{n-2},a_{n-1},a_n$，求出在 $a_1,a_2,a_3,\dots,a_k$（$2\le k\le n$）中，删除一个数后一定能取到的最大值。

---


### **思路**
用一个优先队列，从 $a_1$ 开始存数，存到 $a_n$，且再存数过程中求出答案。   
想求出最终答案，删掉的数必须是最大的一个数，因为这保证**一定能取到**。

---

### **Code**
```
#include<bits/stdc++.h>
#define REP(i,a,b,c) for(int i=a;i<=b;i+=c)
#define PER(i,a,b,c) for(int i=a;i>=b;i-=c)
using ll = long long;
using namespace std;
const int N=1e5+5;
int n,a[N];
priority_queue<int>q;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>n;
	REP(i,1,n,1) cin>>a[i];
	REP(i,1,n,1){
		q.push(a[i]);//存数
		if(i>=2){
			int x=q.top();//最大值
			q.pop();//删除最大值
			cout<<q.top()<<" ";//输出删除最大值一个数后一定能取到的最大值
			q.push(x);//存回最大值
		}
	}
}
```

---

## 作者：Zyhx (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11551)

### 大致题意
主持人会拿走区间内任意一个奖品，求选手在剩余的奖品中一定能拿到的最大价值。
### 解题思路
我们需要考虑所有情况，最坏情况当然是主持人拿走价值区间最大的，所以依次输出 $ 1\sim2,1\sim3,1\sim4,\ldots1\sim n $ 个奖品中次大的就可以了。

如果每次输出都枚举一遍区间，时间复杂度 $O(n^2)$ 无法通过本题。所以我们需要 $ O(n\log{n}) $ 或者 $ O(n) $ 的方法。稍加思考，发现其实不用每次需要输出时都枚举前面所有的进行更新，可以像打擂台一样更新区间最大值，因为每次区间长度总是增加1，每次总是只多一个奖品可供选择，只在原先的奖品序列内增加一个，所以我们可以不急着去找前面的最大值，每次判断我们前面区间的最大值与新增的进行比较，若是最大值小于新增奖品价值，则更新即可。考虑进行贪心：枚举分数时，判断多加一分可以得到的新的奖品是否会被主持人删掉，也就是该奖品价值是否会成为区间内最大值，这样能保证只在每次输出时更新，拥有 $ O(n) $ 的时间复杂度。我们考虑三种情况：

- 最新能拿到的奖品大于前区间最大值且大于区间次大值，则主持人删除的奖品价值更改为最新能拿到的奖品价值，更新次大值，输出区间次大值。

- 最新能拿到的奖品不大于前区间最大值且大于区间次大值，则主持人删除的奖品价值不变，更新次大值，输出区间次大值。

- 最新能拿到的奖品不大于前区间最大值且不大于区间次大值，则主持人删除的奖品价值不变，不需要更新，输出区间次大值。

接下来我们考虑如何更新区间最大值（主持人会删除掉的奖品价值）与区间次大值。很明显，枚举是行不通的，所以我们使用两个变量 $ maxn $ 与 $ temple $ 表示区间最大值与区间次大值，每次与最新能拿到的奖品价值比上一比，判断最新能拿到的奖品价值属于哪一种情况来更新值即可。

### code: 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define __ 1000005
int a[__],n,maxn,temple;
int main(){
	ios::sync_with_stdio(0),cin.tie(0); cin>>n;
	for(reg int i=1;i<=n;++i) cin>>a[i];
	for(reg int i=2;i<=n;++i){
		if(i==2){//这里特别判断起始部分，以给maxn与temple赋初始值 
			cout<<min(a[1],a[2])<<" ";//输出两个值中的次大值（就是两值中小的那个） 
			temple=min(a[1],a[2]);//记录次大值 
			maxn=max(a[1],a[2]);//记录最大值 
		}else{
			if(a[i]>=maxn) temple=maxn,cout<<temple<<" ",maxn=a[i];
			//情况1：最新能拿到的奖品价值大于区间最大值且大于区间次大值 
			//如过最新能拿到的奖品价值大于区间最大值，则主持人会删掉最新能拿到的奖品
			//先输出之前的区间最大值，并把区间次大值更变为之前的区间次大值，再更新区间最大值 
			else if(a[i]>temple) temple=a[i],cout<<temple<<" ";
			//情况2：最新能拿到的奖品价值不大于区间最大值且大于区间次大值 
			//更新区间次大值为最新能拿到的奖品价值，然后输出即可 
			else cout<<temple<<" ";
			//情况3：最新能拿到的奖品不大于前区间最大值且不大于区间次大值
			//无需更新，输出即可 
		}
	}
	return 0;
}

```
如若有本题解任何问题，欢迎各位大佬指出，祝各位都能无限进步，取得理想的成绩。

---

## 作者：Wzmois (赞：2)

[传送门](https://www.luogu.com.cn/problem/P11551)
## 题目大意
主持人随机删去一个奖品，考虑**最坏**情况，就是删掉了价值最大的奖品，剩下的奖品肯定要选最值钱的最好。

简化后就是：给定一个数组，找到前 $i$ 个数的次最大值。
## 解决方案
使用优先队列对数组进行排序，先输入第一个数。当输入第二个数时对数进行入队，经过排序后第二个数是次最大值，所以我们要对队列的第一个数（最大值）进行出队操作。然后输出此时队列的第一个数（次最大值），再把最大值进行入队操作即可。
## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue <int> a;
int main(){
	int n,tmp,tmp1;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
		scanf("%d",&tmp);
		a.push(tmp);
		if(i==1) continue;//i=1不输出数字
		tmp1=a.top();
		a.pop();
		printf("%d ",a.top());
		a.push(tmp1);
	}
}

``````

---

## 作者：signed_long_long (赞：1)

# 题目解法

主办方肯定会把价值最大的奖品拿走，所以这道题就是让我们求 $a_1\sim a_k$ 之间的次大值。

次大值怎么求呢？开两个变量分别记录最大值和次大值，如果 $a_i>$ 最大值，那么把最大值和次大值都跟新一下，如果 $a_i>$ 次大值，那么只更新次大值。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[100500];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int maxn=0,semaxn=0;
	for(int k=1;k<=n;k++){
		if(maxn<=a[k]){
			semaxn=maxn;
			maxn=a[k];
		}else if(semaxn<=a[k]) semaxn=a[k];
		if(k>1) printf("%d ",semaxn);
	}
	return 0;
}
```

---

## 作者：rzm120412 (赞：1)

参赛者肯定选当前合法的最大值。主办方会将最大值给拿走，变为非法，所以求次大值即可。

考虑贪心，观察数据范围显然不能 $n^2$ 查找，考虑边输入边计算。

详见代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,maxx,maxx1;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1; i<=n; i++) {
		int x;
		cin>>x;
		if(x>=maxx) {
			maxx1=maxx;
			maxx=x;
		} else if(x>=maxx1) {
			maxx1=x;
		}
		if(i!=1){
			cout<<maxx1<<" ";
		}
	}
	return 0;
}

```

---


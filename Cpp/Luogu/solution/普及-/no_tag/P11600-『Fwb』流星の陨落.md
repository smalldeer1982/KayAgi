# 『Fwb』流星の陨落

## 题目描述

流星雨来了！

当然，这场流星雨确确实实是 Fwb 设计的。Fwb 在天空中放置了许多的流星，同时也在地面上放置了许多的烟花。当流星和烟花发生碰撞时，就会出现美丽而独特的风景。

由于方便控制流星雨的发射，流星的发射是有规律的，这个发射的规律叫做流星间隔。我们把地面上烟花的摆放看作一个数轴，若流星间隔是 $k$，那么在 $i$ 位置发射一颗流星后，下一个发射流星的位置必须是 $i+k$。特殊的，第一个发射流星的位置**必须是** $1$。

为了使流星雨好看，保证每一个烟花都会和流星碰撞，即每一个烟花的位置都会有流星发射。**但不保证每一个流星都有可碰撞的烟花**。为了尽可能减少资源消耗，发射的流星应在满足条件的前提下最少，现在想请你算出，发射的流星雨中最少有多少颗流星以及此时的流星间隔是多少。

## 说明/提示

#### 【样例 1 解释】

当流星间隔为 $2$ 时，流星会发射在 $[1,3,5,7,9]$ 的位置，恰好覆盖所有的烟花。此时发射的流星数量最少为 $5$。

#### 【数据范围】

对于所有的测试数据，保证：

- $1\le n\le 10^5$。
- 对于任意的 $i$（$1\le i\le n$），都有 $1\le a_i\le 10^9$。

| 测试点 | $n=$ | $a_i\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1$ | $10$ | 无 |
| $2$ | $10^5$ | $10^9$ | A |
| $3,4$ | $10^5$ | $10^9$ | B |
| $5,6,7$ | $10$ | $10^9$ | C |
| $8,9,10$ | $10^5$ | $10^9$ | 无 |

特殊性质 A：保证 $a_i=a_{i-1}+1$（$1<i\le n$）。

特殊性质 B：保证 $a_i-a_{i-1}=a_{i+1}-a_i$（$1<i<n$）。

特殊性质 C：保证至少出现一次 $a_i-a_{i-1} \le 10^4$（$2\le i\le n$）。

**题目保证不出现 $n=1$ 且 $a_1=1$ 的情况。**

## 样例 #1

### 输入

```
5
1 3 5 7 9```

### 输出

```
5 2```

## 样例 #2

### 输入

```
7
10 13 19 301 304 307 3004```

### 输出

```
1002 3```

## 样例 #3

### 输入

```
3
2 1000000 1234567```

### 输出

```
1234567 1```

# 题解

## 作者：wkywkywky (赞：8)

让我们忽略掉一些细节，原问题可以规约下面的问题。

$\sum b=O(V),\forall b>0$ 求 $\gcd{b}$。

最多  $\sqrt{V}$ 个 $b>\sqrt{V}$。

如果没有 $b\leq \sqrt{V}$，有 $n\leq \sqrt{V}$。

直接做 $\gcd$ 时间复杂度为 $O(\sqrt{V}\ln V)$。

否则 $\exist b\leq \sqrt{V}$，其他数对其取模。

使用 $O(W)-O(1)$ 的值域 $\gcd$ 即可。

时间复杂度为 $O(n+\sqrt{V})$。

---

## 作者：WsW_ (赞：4)

### 思路
形式化问题为：求满足 $\forall a_i,a_i\in \{x|x=1+t\times k,t\in \mathbb{N}\}$ 最大的 $k$。  
根据题意，我们可以认为 $a_0=1$。  
容易发现，满足上述条件的充要条件是 $\forall 0\le i,j\le n,(a_i-a_j)\equiv 0 \pmod k$。上面条件的充要条件是 $\forall i\neq 0,(a_i-a_{i-1})\equiv 0 \pmod k$。  
也就是说 $k$ 是所有 $a_i-a_{i-1}$ 的因子。  
所以对所有的 $a_i-a_{i-1}$ 求最大公因子就得到了最大的 $k$。  

可以使用 `__gcd()` 来求最大公因子。  

时间复杂度为 $O(n\log A)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,lst=1,ans;
int main(){
	cin>>n;
	while(n--){
		int a;cin>>a;
		ans=__gcd(ans,a-lst);
		lst=a;
	}
	cout<<(lst-1)/ans+1<<' '<<ans;
	return 0;
}
```

---

## 作者：_Tatsu_ (赞：4)

**Update: 1/22/2025 修改病句，添加注释**
## 思路
因为流星、烟花要对应，所以答案为所有流星间隔距离的最大公因数，最后拿最后一个烟花除以答案即可。向上取整。
## Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define fro for
using namespace std;
int a[100005]={1};
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	int n;
	cin>>n;
	for (int i=1;i<=n;i++)
	cin>>a[i];
	int ans=0;
	for (int i=1;i<=n;i++)
		ans=__gcd(ans,a[i]-a[i-1]);//距离的最大公因数
	cout<<(a[n]-1)/ans+1<<' '<<ans;//向上取整
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 前言
把出题人 std 给爆了，请看[帖子](https://www.luogu.com.cn/discuss/1045627)。  
这种做法本质上是对出题人 std 的优化，具有可靠的时间复杂度。

---
### 思路
根据题意，我们可以认为 $a_1=1$。  
令 $b_i=a_i-a_{i-1}$。题目就是要找到最大的 $k$，满足 $k$ 是所有 $b_i$ 的因子。  
我们可以先求出 $b_1$ 的因子有哪些，再枚举因子 $k$ 并检查是否所有的 $b_i$ 都能整除 $k$。找到最大的 $k$ 即可。  

假设找到一个因子 $k$，那么 $A/k$ 一定也是因子，找因子只需要枚举到 $\sqrt{A}$。  
查表可知，在 $A\le 10^9$ 的时候 $\max\{d(A)\}=1344$。也就是说因子个数不超过 $1344$。  
时间复杂度为 $O\left(\sqrt{A}+d(A)\log d(A)+n\times d(A)\right)$，比较极限。但常数极小，完全跑不满。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
vector<int>a;
vector<int>fac;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	a.push_back(1);
	while(n--){
		int x; cin>>x;
		if(x!=1)a.push_back(x);
	}
	int t=a[1]-a[0];
	for(int i=1;i*i<=t;i++){
		if(t%i==0){
			fac.push_back(i);
			fac.push_back(t/i);
		}
	}
	sort(fac.begin(),fac.end());
	for(auto x:fac){
		bool f=1;
		for(int i=1;i<a.size()&&f;i++){
			if((a[i]-a[i-1])%x)f=0;
		}
		if(f)ans=x;
	}
	cout<<(a.back()-1)/ans+1<<' '<<ans;
	return 0;
}
```

---

## 作者：Eason_cyx (赞：3)

题意：给定 $a$ 数组，求最少添加多少个元素可以使 $a$ 变成一个 $a_1=1$ 的等差数列。

----

就是一个很 normal 的 trick。想要变成等差数列就是差都相等对吧，那么想要添加的少就是要公差尽量大，那么我们取一下 $\operatorname{gcd}\limits_{i=1}^{n-1}(a_{i+1}-a_i)$ 作为公差显然就是最大的。注意：因为第一项必须是 $1$，所以还需要和 $a_1-1$ 取 $\operatorname{gcd}$ 才是最终的公差。

时间复杂度 $O(n\log V)$，$V$ 是值域。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005];
int main() {
	int n; cin >> n; for(int i = 1; i <= n; i++) cin >> a[i];
	if(a[1] != 1) {
		int g = a[1] - 1; for(int i = 2;i <= n;i++) g = __gcd(g, a[i] - a[i-1]);
		cout << (a[n] - 1) / g + 1 << " " << g << endl; return 0;
	}
	return 0;
}
```

---

## 作者：lichenxi111 (赞：3)

## 前言

比较简单，怎么感觉比 T1 简单（？

## 思路

求最少需要的流星可以转化为求最大可能的间隔。

发现最优策略是间隔取**相邻烟花距离的最大公因数**。

然后流星数用等差数列项数公式求得，即设首项为 $x$（本题为 $1$），尾项为 $y$，公差为 $d$，项数为 $\dfrac{y - x}{d} + 1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int last = 1,x;
int main()
{
	int n;
	cin >> n;
	int t = 0;
	for(int i = 1;i <= n;i++)
	{
		cin >> x;
		if(x == last)
		{
			continue;
		}
		if(t == 0)
		{
			t = x - last;
			last = x;
			continue;
		}
		t = __gcd(x - last,t);
		last = x;
	}
	cout << (x - 1) / t + 1 << " " << t;
	return 0;
}
```

---

## 作者：jojo222 (赞：2)

简单题，烟花的间隔是 $m=\gcd(a_1-1,a_2-1,\cdots,a_n-1)$，最后一个流星减一后的位置是 $mx=\max(a_1-1,a_2-1,\cdots,a_n-1)$。用小学除法~~我就是小学生~~就能算出流星数量，是 $mx\div m+1$。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, mx;
int main()
{
	cin >> n >> m;
	mx = --m;
	for(int i = 2, x; i <= n; i++)
	{
		scanf("%d", &x);
		m = __gcd(m, (x - 1));
		mx = max(mx, (x - 1));
	}
	cout << mx / m + 1 << " " << m;
	return 0;
}
```

---

## 作者：违规用户名1310428 (赞：2)

不难发现，每个烟花发射时间为 $x\times k+1$，那么将 $a_i-1$ 求 $\gcd$ 就可以了。  
**$a_i=1$ 和 $n=1$ 要特判！！！**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,d=1;
int gcd(int x,int y){
    if(x%y==0) return y;
    return gcd(y,x%y);
}
int main(){
    cin>>n;
    cin>>d;
    if(n==1){
        cout<<2<<" "<<d-1;
        return 0;
    }
    n--;
    if(d==1){
        cin>>d;
        n--;
    }
    d--;
    while(n--){
        cin>>a;
        a--;
        if(a!=0)d=gcd(d,a);
    }
    cout<<a/d+1<<" "<<d;
    return 0;
}
```

---

## 作者：Camellia_Spoil (赞：2)

因为流星的间隔要相同，所以我们想到等差数列，并且这个等差数列要覆盖 $a$ 数组（每个烟花在数轴上位置的数组），我们联想到最大公因数。

我们观察可得，对 $a$ 数组相邻两数两两求差并求这些差的最大公约数就是等差数列的公差。

最后 $n=1$ 的时候要特判。


```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
using namespace std;
inline long long read()
{
	long  long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int a[9111111],w[9111111];
signed main()
{
	int n,mx=-1e9;
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();mx=max(mx,a[i]);
	}
	if(n==1)
	{
		cout<<2<<" "<<a[1]-1;return 0;
	}
	for(int i=1;i<n;i++)
	{
		w[i]=a[i+1]-a[i];
	}
	int k=w[1];
	for(int i=2;i<n;i++)
	{
		k=__gcd(k,w[i]);
	}
	if(mx%k!=0) printf("%lld ",mx/k+1);
	else printf("%lld ",mx/k);
	printf("%lld",k);
	return 0;
}
```

---

## 作者：_H17_ (赞：2)

## 题目大意

给你一个序列 $a$，使得 $a$ 中任何一个数都可以用 $1+k\times x$ 表示（均为非负整数）。

求最大的 $x$。

## 题目分析

考虑 $1$ 和 $a$ 组成 $a'$（默认升序排列）。

只要 $x$ 是任意两个相邻的数的差的约数即可。

所以依次求最大公因数即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=1e5+1;
int n,ans;
vector<int>a,diff;
int main(){
    cin>>n;
    for(int i=1,j,lst=1;i<=n;i++){
        cin>>j;
        if(i==1&&j!=1)
            a.push_back(1);
        a.push_back(j);
    }
    for(int i=1;i<a.size();i++)
        diff.push_back(a[i]-a[i-1]);
    for(auto p:diff)
        ans=__gcd(ans,p);
    cout<<(a[n]-1)/ans+1<<' '<<ans;
    return 0;
}
```

---

## 作者：ziyaojia (赞：1)

由于流星的间隔一样，不妨会想到最大公因数，由于数轴是从一开始的，所以我们把所有数减一再求最大公因数,最后拿总长度除以最大公因数加一就好了。

注意：在最大公因数等于一时，最后的答案不用加一，而且在数等于一时这个数不需要求最大公因数。
## My Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tmp,ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>tmp;
		if(tmp!=1)	ans=__gcd(ans,tmp-1);
	}
	if(ans!=1)
		cout<<tmp/ans+1<<' ';
	else
		cout<<tmp<<' ';
	cout<<ans;
	return 0;
}
```

---

## 作者：longlong666 (赞：1)

### 题目大意

给出长度为 $n$ 的序列，求使 $a_i = 1 + b_j \times d$ 的最小 $b$ 序列个数及此时对应的 $d$。

### 思路

先取 $a_{i+1}-a_i$ 的最小值，判断这个值是否满足成为 $d$ 的条件，不满足则取 $\gcd (d,a_i-1)$。\
原因：为使 $b$ 序列个数最少需使 $d$ 最大，而为使存在满足条件的 $b$ 序列应该让 $d$ 为 $a_i-1$ 的因数。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e6+10;
int n,d,ans;
int a[maxn];
int gcd(int x,int y){
	if(y==0) return x;
	return gcd(y,x%y);
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]; d=a[n]-1;//有n=1的情况d先取得a[n]-1避免特判
	for(int i=1;i<n;i++) d=min(d,a[i+1]-a[i]);
	for(int i=1;i<=n;i++){
		if((a[i]-1)%d) d=gcd(a[i]-1,d);
	}ans=(a[n]-1)/d+1;//个数即为最大数减1除以d再加1
	cout<<ans<<' '<<d<<endl;
	return 0;
}
```

---

## 作者：cyx0411 (赞：1)

# 题意：

给定 $n$ 个数，求要怎样才能在间隔数最少的情况下让该数组变成一个等差数列，并输出最少的项数与项差。

# 思路：

我们不妨换个方向思考，要想让间隔数最小，项差就得最大。要让项差大，就得让给出的数的差的公因数最大。我们从而得出结论：本题其实就是求输入的数的差的最大公约数，然后输出。

最后放代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int n,ans,a1,a;               //ans是答案，a1是第一次输入的，a是上一次输入的
	cin>>n;
	if(n==1){                     //特判n=1的情况
		cin>>a;
		cout<<2<<' '<<a-1;          //按题意输出
		return 0;
	}
	cin>>a1>>a;
	ans=a-a1;                     //第一遍和后面的不同
	for(int i=2;i<n;i++){
		int b;
		cin>>b;
		ans=__gcd(ans,b-a);         //gcd函数，求两个数的最大公约数
		a=b;                        //更新上一次的内容
	}
	cout<<(int)(ceil(a*1.0/ans))<<' '<<ans;        //输出答案
	return 0;
}

```

---

## 作者：cjx_AK (赞：1)

题目给你一个数列，让你求出最小的间隔使得新数列中完全包含这个数列。

我们需要知道，要想求出答案，首先要求出间隔。不妨计算出数字之间的间隔，记作 $b_i$。

只要找到一个累加可以保证刚好到每一个 $b_i$ 的最大的数，即都是他们的约数，就是他们的最大公约数。

然后如果 $a_n$ 可以刚好放下数，那么要放 $a_n \div k$ 个，否则再加一。

代码：

```
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,x,k,y,a[1000002],b[1000002];
signed main() {
	cin>>n;
	if(n==1){
		cin>>a[1];
		cout<<2<<' '<<a[1]-1;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[i]=a[i]-a[i-1];
	}
	for(int i=2;i<=n;i++){
		k=__gcd(k,b[i]);
	}
	
	if(a[n]%k==0){
		cout<<a[n]/k;
	}else{
		cout<<1+a[n]/k;
	}
	cout<<' '<<k;
	return 0;
}
```

---

## 作者：sbh2012 (赞：1)

## 思路
因为流星的间隔必须一样，并且每个烟花都需要对应的流星，还要求最少，所以我们要求所有流星间隔距离的**最大公因数**。\
因为求的是流星间隔距离的最大公因数，所以 $n=1$ 时要特判。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],sum;
int main(){ 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(i>=2){
			if(i==2){
				sum=a[i]-(a[i-1]);
			}
			sum=__gcd(sum,a[i]-a[i-1]);//所有流星间隔距离的最大公因数
		}
	} 
	if(n==1){//n=1时要特判
		if(a[1]==1){
			cout<<1<<' '<<0;
		} 
		cout<<2<<' '<<a[1]-1;
		return 0;
	} 
	if(a[n]%sum==0){
		cout<<a[n]/sum;
	}else{
		cout<<a[n]/sum+1;
	}
	cout<<' '<<sum; 
	return 0;
}
```

---

## 作者：inscape (赞：1)

## 题目内容

有 $n$ 个烟花按升序排成一排，每个烟花都有一个绽放时间 $a_i$，你需要让流星在烟花绽放时同时出现，第一个流星会在 $1$ 的时间发射，问你应该怎么安排流星发射的间隔以及流星最少的数量。

## 思路

一道比较考验思维的数学题，~~在赛场上卡了我十次~~，由于这题有两问，所以我们分开解决：

### 流星间隔：

由于流星发射的间隔是固定的，所以我们不难发现，流星发射的间隔**一定**是每个烟花绽放时间之差的最大公约数。

### 流星数量：

由于第一个流星在 $1$ 的时间发射，所以我们只需要用最后一个烟花绽放的时间 $\div$ 流星间隔就可以求出最少流星数量了，如果最后一枚流星除以间隔除不尽，则需要将答案增加 $1$。

### 特判：

由于题目中有个非常毒瘤的 $n=1$ 的数据点，所以我们需要特判这种情况：

```cpp
if(n==1){ // 特判n为1的情况，如果不特判就会RE
		long long a;
		cin>>a;
		cout<<2<<' '<<a-1; // 这种情况只用输出2和a-1
		return 0;
	}
```

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,sum[200000],b,ggd,d;
int main(){
	cin>>n;
	if(n==1){ // 特判n为1的情况，如果不特判就会RE
		long long a;
		cin>>a;
		cout<<2<<' '<<a-1; // 这种情况只用输出2和a-1
		return 0;
	}
	for(long long i=1;i<=n;i++){ // 输入
		long long  a;
		cin>>a;
		if(i!=1) sum[i-1]=a-b; // 作差
		else d=a;
		b=a; // 这里只用两个变量进行存储，节省空间
	}
	ggd=sum[1]; // 流星间隔
	for(long long i=2;i<=n;i++){
		ggd=__gcd(ggd,sum[i]); // 每次取差的最大公因数
	}
	long long  ans=b/ggd; // 将流星数量设为最后一枚流星除以间隔
	if(ans*ggd!=b) ans++; // 若除不尽，则将答案加一
	cout<<ans<<' '<<ggd; // 输出
	return 0;
}
```

---

## 作者：_lxc__ (赞：1)

因为每个流星的间隔要相等，所以自然的想到等差数列，再进一步想到因为流星要尽量少，所以最终答案为每两个相邻流星的最大公约数，即 $\gcd_{i=2}^{n} (a_{i}-a_{i-1})$。

综上给出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,a[N],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	ans=a[1]-1;
	for(int i=2;i<=n;i++){
		ans=__gcd(ans,a[i]-a[i-1]);
	}
	cout<<(a[n]-1)/ans+1<<" "<<ans;
	return 0;
}

```

---

## 作者：huanglihuan (赞：0)

### Solution
转换题意得：有一个首项为 $1$，末项为 $a_n$，公差为 $k$ 的等差数列，其中必须包含 $a_1,a_2,\ldots,a_n$。  
发现只需要计算 $\gcd(a_2-a_1,a_3-a_1,\ldots,a_n-a_1)$ 求出最小的公差 $k$，再利用公式求出对应的数量即可。
### Code
```cpp
#include <bits/stdc++.h>
#include <cstdio>
#define int long long
#define ull unsigned long long
#define mod 988444333
#define MOD 1000000007
using namespace std;
const int N = 2e6 + 5;
int a [N];
inline int read ()
{
	int x = 0;
	char c = getchar ();
	while (c < '0' || c > '9') c = getchar ();
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48),c = getchar ();
	return x;
}
inline void write (int x)
{
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
	return ;
}
signed main ()
{
	int n;
	cin >> n;
	int t;
	cin >> t;
	if (n == 1) return cout << 2 << ' ' << t - 1,0;
	int x;
	cin >> x;
	int ans = x - t;
	for (int i = 3;i <= n - 1;i ++)
	{
		cin >> x;
		x -= t;
		ans = __gcd (ans,x);
	}
	cin >> x;
	x -= t;
	ans = __gcd (ans,x);
	x += t;
	cout << (x % ans == 0 ? x / ans : x / ans + 1)<< ' ' << ans;
	return 0;
}
```

---

## 作者：donnieguo (赞：0)

## 思路

通过观察样例以及一些分析可知：流星间隔即为所有相邻两个烟花距离的公约数，因为我们要使每一个烟花的位置都会有流星发射。

注意特判一下 $n = 1$ 的情况。

时间复杂度：$O(n \log V)$，$V$ 是值域。

## AC code

```cpp
#include <iostream>
using namespace std;

int n, x, now, d;

int gcd(int x, int y)
{
	return !y ? x : gcd(y, x % y);
}

int main()
{
	ios::sync_with_stdio(0); cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> x;
		if (i >= 2) d = gcd(d, x - now);
		now = x;
	}
	if (n == 1 && now != 1) cout << 2 << ' ' << now - 1 << '\n';
	else cout << (now - 1) / d + 1 << ' ' << d << '\n';
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11600)

## 思路：

由于每个流星之间的距离相同，且每个烟花处都有流星，所以流星间隔就是所有 $a_{i+1}-a_i$ 的最大公因数，记它为 $k$ 吧，而流星数量就是 $a_n \div k$ 后向下取整了。

**注意：当第一个烟花不在 $1$ 上时，流星数要在上文的计算后再增加 $1$。**

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
long long m; 
long long a[100005];
long long g,f=0;
int main(){
	cin>>m;
	a[1]=1;
	cin>>a[2];
	g=a[2]-a[1];
	if(a[2]==1) f=1;
	for(long long i=3;i<=m+1;i++){
		cin>>a[i];
		g=__gcd(g,a[i]-a[i-1]);//求最大公因数 
	}
	if(g==1) cout<<a[m+1]<<" "<<g;
	else cout<<((a[m+1])/g)+1<<" "<<g; 
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

题意：给定一个等差数列的一部分，你需要将其补充为一个首项为 $1$ 等差数列且最小化数列长度。输出数列项数和公差。

显然等差数列中任意两数之差是公差的倍数，因此公差可以是相邻两个数的差的公约数。那么最大公差即为相邻两数差的最大公约数。由于要求了首项为 $1$ 所以需要把 $a_0$ 设为 $1$ 再求 $\gcd$。

求出公差后可用公式项数等于末项减首项的差除以公差加一来求项数。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+2;
int a[N];

int main(){
	int n;cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i];
	int gcd=0;a[0]=1;
	for(int i=1; i<=n; i++) gcd=__gcd(gcd,a[i]-a[i-1]);
	cout<<(a[n]-1)/gcd+1<<" "<<gcd; 
	return 0;
} 
```

---

## 作者：hexuchen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11600)

[更好的阅读体验？](https://www.luogu.com.cn/article/1k867cwa)

## 思路分析

观察题目，如果想要确保每一个烟花都有流星击中，那么流星的发射间隙应该是烟花发射间隙的最大公因数。照此思路，因为第一颗流星必须在第 $1$ 秒发射，所以发射的流星颗数就是最晚发射烟花的时间除以流星的发射间隙。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100010],ans_1,ans_2;
int Gcd(int a,int b){ //求最大公因数
	if(a<b){
		swap(a,b);
	}
	if(a%b==0){
		return b;
	}
	return Gcd(a,a%b);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	if(n==1){ //注意特判
		cout<<2<<' '<<a[1]-1;
		return 0;
	}
	for(int i=2;i<=n;i++){ //求间隙的最大公因数
		if(ans_2==0){
			ans_2=a[i]-a[i-1];
		}
		else{
			ans_2=Gcd(ans_2,a[i]-a[i-1]);	
		}
	}
	if(ans_2==1){ //如果间隙为 1 要特判
		cout<<(a[n]/ans_2)<<' '<<ans_2;
	}
	else{
		cout<<(a[n]/ans_2)+1<<' '<<ans_2;
	}
	return 0;
}
```

---


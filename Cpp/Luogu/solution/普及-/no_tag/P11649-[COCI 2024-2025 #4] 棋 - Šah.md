# [COCI 2024/2025 #4] 棋 / Šah

## 题目背景

译自 [COCI 2024/2025 #4](https://hsin.hr/coci/) T1。$\texttt{3s,0.5G}$。满分为 $50$。


## 题目描述


有一块 $n\times n$ 的国际象棋棋盘，上面摆放着 $m$ 个棋子。棋子的类型只有骑士（knight），车（rook）和皇后（queen）。

已知

- 骑士的攻击范围为：**骑士所在的格子**，以及骑士所在的格子走一列两行（或者一行两列）能走到的所有格子；
- 车的攻击范围为：与车所在的格子同一行或者同一列的格子（**包括车所在的格子**）；
- 皇后的攻击范围为：与皇后所在的格子同一行，同一列或者同一对角线的格子（**包括皇后所在的格子**）。

求出这个棋盘上有多少个格子被至少一个棋子攻击。


## 说明/提示


#### 样例解释

样例 $1,2$ 解释见图片。注意，每个棋子也会攻击它所在的格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/p046yc9x.png)![](https://cdn.luogu.com.cn/upload/image_hosting/nn6oomkg.png)


#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le n\le 200$；
- $1\le m\le n^2$；
- 不会有两个棋子在一个格子里。

| 子任务编号 | $C\in $ | 得分 |  
| :--: | :--: | :--: | 
| $ 1 $    |  $\texttt{R}$    |   $ 13 $   |  
| $ 2 $    |  $\texttt{R},\texttt{Q}$  |  $ 19 $   |  
| $ 3 $   | $ \texttt{N},\texttt{R},\texttt{Q} $   | $18$ |



## 样例 #1

### 输入

```
7 1
Q 4 4```

### 输出

```
25```

## 样例 #2

### 输入

```
5 1
N 3 3```

### 输出

```
9```

## 样例 #3

### 输入

```
6 3
R 1 4
Q 2 1
N 5 2```

### 输出

```
25```

# 题解

## 作者：Billhqh9 (赞：2)

## 题目链接
[洛谷](https://www.luogu.com.cn/problem/P11649)

## 朴素法
### 思路：
我们先按题目中说的，用二维数组记录下每个棋子可以攻击到的位置，最后做一个统计。时间复杂度：$O(mn+n^2)$，可以通过此题。
### AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 205;
int n, m, ans;
bool board[maxn][maxn];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; ++i) {
        char c;
        int x, y;
        cin >> c >> x >> y;
        board[x][y] = true;
        if(c == 'N') {
            if(x - 2 >= 1 && y - 1 >= 1)
                board[x - 2][y - 1] = true;
            if(x - 2 >= 1 && y + 1 <= n)
                board[x - 2][y + 1] = true;
            if(x - 1 >= 1 && y - 2 >= 1)
                board[x - 1][y - 2] = true;
            if(x - 1 >= 1 && y + 2 <= n)
                board[x - 1][y + 2] = true;
            if(x + 2 >= 1 && y - 1 >= 1)
                board[x + 2][y - 1] = true;
            if(x + 2 >= 1 && y + 1 <= n)
                board[x + 2][y + 1] = true;
            if(x + 1 >= 1 && y - 2 >= 1)
                board[x + 1][y - 2] = true;
            if(x + 1 >= 1 && y + 2 <= n)
                board[x + 1][y + 2] = true;
        }
        if(c == 'R') {
            for(int x1 = x, y1 = y; x1 >= 1; --x1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; x1 <= n; ++x1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; y1 >= 1; --y1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; y1 <= n; ++y1)
                board[x1][y1] = true;
        }
        if(c == 'Q') {
            for(int x1 = x, y1 = y; x1 >= 1; --x1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; x1 <= n; ++x1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; y1 >= 1; --y1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; y1 <= n; ++y1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; x1 >= 1 && y1 >= 1; --x1, --y1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; x1 >= 1 && y1 <= n; --x1, ++y1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; x1 <= n && y1 >= 1; ++x1, --y1)
                board[x1][y1] = true;
            for(int x1 = x, y1 = y; x1 <= n && y1 <= n; ++x1, ++y1)
                board[x1][y1] = true;
        }
    }
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= n; ++j)
            if(board[i][j] == true)
                ++ans;
    cout << ans << endl;
    return 0;
}
```

## 优化法
虽然 AC 了，我们再来想想能不能继续优化。
### 思路
再使用多个数组记录攻击信息，直接花 $O(1)$ 时间记录行、列、对角线的攻击信息，避免枚举攻击的点。比如用 $f1_i$ 表示第 $i$ 行是否被攻击。这样节省枚举攻击的点的时间，可将时间复杂度的第一项优化一维。时间复杂度：$O(m+n^2)$。
### 优化代码
注：在我的代码中 $f1_i$ 表示第 $i$ 行是否被攻击；$f2_i$ 表示第 $i$ 列是否被攻击；$f3_i$ 表示第 $i$ 条从左上往右下的对角线是否被攻击；$f4_i$ 表示第 $i$ 条从右上往左下的对角线是否被攻击。在这里 $f1_i$ 和 $f2_i$ 不用说，但要讲讲在知道坐标的情况下如何算出 $f3_i$ 和 $f4_i$ 中的 $i$。

对于每条从左上往右下的对角线上的每个坐标为 $(x,y)$ 的点，我们可以发现：$x-y$ 为定值，且每条这样的对角线 $x-y$ 的值都不同。所以计算 $i$ 可以从 $x-y$ 入手，找规律后发现 $i$ 可以表示为 $x-y+n$。同理，我们可以发现：对于每条从右上往左下的对角线上的每个坐标为 $(x,y)$ 的点，$x+y$ 为定值，且每条这样的对角线 $x+y$ 的值都不同。所以，找规律后发现 $i$ 可以表示为 $x+y-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 205;
int n, m, ans;
bool board[maxn][maxn], f1[maxn], f2[maxn], f3[maxn * 2], f4[maxn * 2];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; ++i) {
        char c;
        int x, y;
        cin >> c >> x >> y;
        board[x][y] = true;
        if(c == 'N') {
            if(x - 2 >= 1 && y - 1 >= 1)
                board[x - 2][y - 1] = true;
            if(x - 2 >= 1 && y + 1 <= n)
                board[x - 2][y + 1] = true;
            if(x - 1 >= 1 && y - 2 >= 1)
                board[x - 1][y - 2] = true;
            if(x - 1 >= 1 && y + 2 <= n)
                board[x - 1][y + 2] = true;
            if(x + 2 >= 1 && y - 1 >= 1)
                board[x + 2][y - 1] = true;
            if(x + 2 >= 1 && y + 1 <= n)
                board[x + 2][y + 1] = true;
            if(x + 1 >= 1 && y - 2 >= 1)
                board[x + 1][y - 2] = true;
            if(x + 1 >= 1 && y + 2 <= n)
                board[x + 1][y + 2] = true;
        }
        if(c == 'R') {
            f1[x] = true;
            f2[y] = true;
        }
        if(c == 'Q') {
            f1[x] = true;
            f2[y] = true;
            f3[x - y + n] = true;
            f4[x + y - 1] = true;
        }
    }
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= n; ++j)
            if(board[i][j] == true || f1[i] == true || f2[j] == true || f3[i - j + n] == true || f4[i + j - 1] == true)
                ++ans;
    cout << ans << endl;
    return 0;
}
```

两份代码虽然都能过，但明显第二份代码更快。

---

## 作者：ShiYuXuan1234 (赞：2)

## 前言
众所不周知，这是我的~~第二篇~~（第一篇？）题解。

然而众所又不周知，这棋子为什么能吃自己呢……


---


## 思路
这道题我的想法就是使用广搜 ~~（但不完全是广搜）~~ 大法，定义一个变量  $maps$  当作棋盘, $maps_{i,j}$   表示第 $i$ 行第 $j$ 列上的格子有没有被别的棋子吃过（吃过了就不能再算一遍了），然后将没有被吃过且能吃到的加入累加器  $sum$  中去，最后计算共有几个满足这样条件的格子即可。

---
## 坑点
棋盘最左上角的点坐标是 $1,1$ 不是 $0,0$。

---


## 代码（含注释）
（主要思路及细节已注释）

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	char c;//棋子的种类
	int x,y;//棋子的位置
};
node a[40001];//棋子
int maps[201][201];//棋盘
int dirn[8][2]={{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{-1,2},{1,-2},{-1,-2}};//骑士可以攻击的8个方向
int dirr[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//车可以攻击的4个方向
int dirq[8][2]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{-1,1},{1,-1},{-1,-1}};//皇后可以攻击的8个方向
int main(){
	int n,m;//根据题意
	int sum=0;//表示能被攻击到的格子个数
	cin>>n>>m;
	for(int i=0;i<m;i++){
		cin>>a[i].c >>a[i].x >>a[i].y ;
		if(maps[a[i].x][a[i].y]==0){//该位置没有被别的棋子攻击过
			maps[a[i].x][a[i].y]=1;//攻击自己
			sum++;//增加一个可被攻击的格子
		}
		if(a[i].c=='N'){//马部分
			for(int j=0;j<8;j++){//8个方向
				int nx=a[i].x +dirn[j][0];
				int ny=a[i].y +dirn[j][1];
				//马下一步攻击到的位置
				if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&maps[nx][ny]==0){//没有出界且没被攻击过，注意棋盘最左上角的点坐标是1,1不是0,0
					maps[nx][ny]=1;//攻击这个格子
					sum++;//增加一个可被攻击的格子
				}
			}			
		}else if(a[i].c=='R'){//车部分
			for(int j=0;j<4;j++){//4个方向
				int nx=a[i].x +dirr[j][0];
				int ny=a[i].y +dirr[j][1];
				//车下一步攻击到的位置
				while(nx>=1&&nx<=n&&ny>=1&&ny<=n){//注意，车能攻击这个方向一直到棋盘边界的位置，要用while循环，其余同马部分
					if(maps[nx][ny]==0){//同马部分
						maps[nx][ny]=1;//同马部分
						sum++;//同马部分						
					}
					nx+=dirr[j][0];
					ny+=dirr[j][1];
					//由于车能一直攻击直到这个方向的边界点，所以x，y坐标要移动
				}
			}
		}else{//皇后部分
			for(int j=0;j<8;j++){//8个方向
				int nx=a[i].x +dirq[j][0];
				int ny=a[i].y +dirq[j][1];
				//皇后下一步攻击到的位置		
				while(nx>=1&&nx<=n&&ny>=1&&ny<=n){//注意，皇后能攻击这个方向一直到棋盘边界的位置，要用while循环，其余同马部分
					if(maps[nx][ny]==0){//同马部分
						maps[nx][ny]=1;//同马部分
						sum++;//同马部分
					}
					nx+=dirq[j][0];
					ny+=dirq[j][1];
					//由于皇后能一直攻击直到这个方向的边界点，所以x，y坐标要移动
				}
			}
		}
	}
	cout<<sum<<endl;//输出结果
	return 0;//完美的结束
}
```
最后，[AC 记录](https://www.luogu.com.cn/record/200999958)。

---


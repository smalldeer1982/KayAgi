# 「o.OI R1」Easy ver.

## 题目背景

T0 门槛有点高，建议先开 T4。

## 题目描述

对于一张 $n\times m$ 的网格图，给出定义：行从 $1\sim n$ 编号，列从 $1\sim m$ 编号，每个点可用它所在的行编号 $i$ 与所在的列编号 $j$ 表示为 $(i, j)$。

点 $(i,j)$ 与点 $(i,j+1)$ 间连有一条无向边，其中 $1\le i\le n, 1\le j<m$。

点 $(i, j)$ 与点 $(i+1,j)$ 间连有一条无向边，其中 $1\le i< n, 1\le j \le m$。

定义两个点相邻当且仅当它们之间有连边。

---

给定 $n,m$，有一张 $n\times m$ 的网格图。现在请你给这 $nm$ 个点**不重复地**标号 $1\sim nm$，相邻两个标号分别为 $a,b$ 的点连一条边权为 $\max\{a,b\}$ 的边。请你最小化最小生成树边权和。

最小生成树的定义可以查看 [OI Wiki](https://oi-wiki.org/graph/mst/)。

## 说明/提示

**「数据范围」**

**本题采用捆绑测试与 Special Judge。**

对于所有测试数据，保证 $1\le n,m\leq 100$。

| 子任务 | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $\leq 3$ | $\leq 3$ | $20$ |
| $1$ | $=1$ | $\leq 100$ | $20$ |
| $2$ | $\leq 100$ | $\leq 100$ | $60$ |

## 样例 #1

### 输入

```
2 3```

### 输出

```
6 3 5
4 1 2```

# 题解

## 作者：Joushi_Ikita (赞：9)

###### ~~乍一看被吓到了（雾）~~
# 正文开始
## 一、题意：
对于一个 $n \times m$ 的矩阵，其中填有 $1$ 到 $n \times m$ 的 $n \times m$ 个整数，
相邻两个整数之间有一条边，边权为两数中的较大值（如下）。


|$6$|长度为 $6 $的边|$3$|长度为 $5$ 的边|$5$|
|:-:|:-:|:-:|:-:|:-:|
|长度为 $6$ 的边||长度为 $3$ 的边||长度为 $5$ 的边|
|$4$|长度为 $4$ 的边|$1$|长度为 $2$ 的边|$2$|


求使最小生成树边权和最小的一种方案（上述情况为 $2 \times 3$ 时的一种解，最小生成树如下（不只一种），边权和为 $20$）。


|$6$|/|$3$|长度为 $5$ 的边|$5$|
|:-:|:-:|:-:|:-:|:-:|
|长度为 $6$ 的边||长度为 $3$ 的边||/|
|$4$|长度为 $4$ 的边|$1$|长度为 $2$ 的边|$2$|


## 二、分析：
~~一般人乍一看应该会和我一样以为要用一些高级的算法或数据结构。~~  
首先考虑到最小生成树的算法之一——Kruskal 的核心思想为贪心，我们可以尝试贪心地去思考问题。  
在 Kruskal 中，我们每次都用最短的一条边来将两个点集连接起来，在这个问题中，我们可以将其简化，每次都将一个新的点连到已有的点集上（特别的，点集初始为点 $1$），易得这条边的边权最小为这个新点的点权。  
为使取到这个最小值，这个新点应接到点集中一个点权比它小的点上（这也是为什么点集初始为点 $1$），不考虑矩阵的结构，连成一条链是最简单的方案（如下）。  
`1<-->2<-->3<-->4<-->5<-->6`  
把它放回到矩阵里，就是一个蛇形填数的矩阵（如下（带划掉的是不在链中的边））。


|$1$|长度为 $2$ 的边|$2$|长度为 $3$ 的边|$3$|
|:-:|:-:|:-:|:-:|:-:|
|~~长度为 $6$ 的边~~||~~长度为 $5$ 的边~~||长度为 $4$ 的边|
|$6$|长度为 $6$ 的边|$5$|长度为 $5$ 的边|$4$|


于是，这题就变成一道简单的蛇形填数了！  
代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i%2){
                cout<<j+(i-1)*m<<' ';
            }
            else cout<<i*m-j+1<<' ';
        }
        cout<<endl;
    }
    return 0;
}
```
你以为这就完了？别急，还有优化。
## 三、优化：
观察到蛇形填数还不够简洁，思考普通填数可否解决。  


|$1$|长度为 $2$ 的边|$2$|长度为 $3$ 的边|$3$|
|:-:|:-:|:-:|:-:|:-:|
|长度为 $4$ 的边||长度为 $5$ 的边||长度为 $6$ 的边|
|$4$|长度为 $5$ 的边|$5$|长度为 $6$ 的边|$6$|


观察如上矩阵，发现每行自身满足链状结构，达到局部最优，而将每行第一个数接到上一行第一个数上，依旧满足之前所述的贪心结论，方案可行。  
于是我们就得到了最简方案。
## 四、最终代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
                cout<<j+(i-1)*m<<' ';
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：wukaichen888 (赞：4)

观察到加入权值为 $2\sim i$ 的边，不会超过 $i-1$ 条（因为只能在标号为 $1\sim i$ 的点连边，边数最多是树）。

排序后发现第 $i$ 小边权值至少为 $i+1$。

考虑标号从小到大加入点 $i\ge2$，每个点与之前任意一点相邻即可，就能贡献边权为 $i$ 恰好一次。

一种合法构造为第 $i$ 行第 $j$ 列填 $(i-1)m+j$。

样例的该构造为：

```txt
1 2 3
4 5 6
```

```python
n,m=map(int,input().split())
for i in range(n*m):print(i+1)
```

---

## 作者：末然Ender (赞：2)

# 题解：P11862 「o.OI R1」Easy ver.

## 思路

显而易见，每一个节点最少都要有一条边链接，而这条边的边权不会小于这个点的编号，也就是说除了最小的 $1$ 每个数都至少对应有一条边边权不小于该点编号，想要让最小生成树的边权和最小，只需要保证每个点（$1$ 除外）都相邻一个比他编号小的数即可，所以我们直接从 $1$ 输出到 $n\cdot m$ 即可满足要求。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>
void read(T& x){x=0;char ch=getchar();long long f=1;while(!isdigit(ch)){if(ch=='-')f*=-1;ch=getchar();}while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}x*=f;}
template<typename T,typename... Args>
void read(T& first,Args&... args){read(first);read(args...);}
template<typename T>
void write(T arg){T x=arg;if (x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar(x%10+'0');}
template<typename T,typename... Args>
void write(T arg,Args... args){write(arg);if(sizeof...(args) !=0){putchar(' ');write(args...);}}
const ll N=1e5+4;
int main(){
	ll n,m;
	read(n,m);
	for(int i=0;i<n;i++){
		for(int j=1;j<=m;j++){
			write(i*m+j);putchar(' ');
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

容易发现最小生成树每个点都要选中，所以可以让这棵树是一条递增的链，此时是最优的。

我们构造一个蛇形矩阵，发现这样是可以做到取出链的。

直接写就行了。

---

诶等等我写的不是蛇形，我写的 S 形，当然一样是对的。

不过你要是想写蛇形那么和 [P5713](https://www.luogu.com.cn/problem/P5731) 四舍五入算个双倍经验。

早上题解写的急没贴码，补一下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        if(i%2){
            for(int j=1;j<=m;j++)cout<<(i-1)*m+j<<" ";
            cout<<endl;
        }else{
            for(int j=m;j;j--)cout<<(i-1)*m+j<<" ";
            cout<<endl;
        }
    }
    return 0;
}
```

---

## 作者：madfallen (赞：2)

题目意思简明。

显然包含 $a$ 的边的值至少是 $a$ 。所以 $n-1$ 条边的权值从 $2$ 到 $n$ 是最优的。

从 $1$ 到 $n$ 排一个螺旋形即可。赛时快速实现可直接模拟螺旋形行走的过程。

```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int N=100;
int a[N+5][N+5];
int n,m;
signed main(){
	cin>>n>>m;
	int nowi=1,nowj=1,dir=0;
	a[1][1]=1;
	for(int i=2;i<=n*m;i++){
		int nxti=nowi,nxtj=nowj;
		if(dir==0)nxtj++;
		if(dir==1)nxti++;
		if(dir==2)nxtj--;
		if(dir==3)nxti--;
		if(nxti<1||nxti>n||nxtj<1||nxtj>m||a[nxti][nxtj])dir=(dir+1)%4;
		if(dir==0)nowj++;
		if(dir==1)nowi++;
		if(dir==2)nowj--;
		if(dir==3)nowi--;
		a[nowi][nowj]=i;
	}
	for(int i=1;i<=n;i++,cout<<endl)for(int j=1;j<=m;j++)cout<<a[i][j]<<" ";
}
```c++

---

## 作者：yanxu_cn (赞：1)

有意思的题目。

其实这个题目当时就是误打误撞，没什么思路，直接按行优先顺序输出。然后奇迹地就过了。所以构造不必多讲，主要说说证明。

运用数学思维，我们来分析一下最小生成树边权和的下界。显然这个下界是 $\displaystyle\sum_{i=2}^{n\times m}$。（为什么？除了 $1$ 以外都必须连一条边权至少等于其值的边。）

分析这个矩阵的特性，发现每一个数值一定大于左侧和上侧的数。于是我们可以连出这样一个最小生成树：

![](https://cdn.luogu.com.cn/upload/image_hosting/4o518im0.png)

所以就可以了。

---

## 作者：封禁用户 (赞：1)

### 思路
最小生成树的边权和取决于边的权重。

边的权重是相邻点标号的最大值，因此我们需要尽量让较大的标号不与较小的标号相邻。

采用蛇形填充的方式分配标号，可以有效地分散较大的标号，避免它们与较小的标号相邻。 

蛇形填充方法
- 奇数行从左到右填充。
- 偶数行从右到左填充。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n, vector<int>(m));
    int num = 1;
    for (int i = 0; i < n; ++i) {
        if (i % 2 == 0) for (int j = 0; j < m; ++j) g[i][j] = num++;
        else for (int j = m - 1; j >= 0; --j) g[i][j] = num++;
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) cout << g[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P11862 题目](https://www.luogu.com.cn/problem/P11862)

### 解题思路
不难发现最小生成树的边权和理论最小为 $2+3+\cdots+n\times m$。

尝试改造，易知将数蛇形排列即可，如当 $n=m=3$ 时，输出结果如下：

```
1 6 7
2 5 8
3 4 9
```

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	ios::sync_with_stdio(false);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(j%2==0)
				cout<<(j-1)*n+(n-i+1)<<' ';
			else
				cout<<(j-1)*n+i<<' ';
		}
		cout<<"\n";
	}
	return 0;
}
```

---


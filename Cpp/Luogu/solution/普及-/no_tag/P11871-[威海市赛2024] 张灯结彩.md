# [威海市赛2024] 张灯结彩

## 题目描述

节日来了，蔓蔓在准备彩灯！

蔓蔓准备了一个树形的彩灯，共有 $n$ 层，第 $i$ 层上有 $2i-1$ 个彩灯。

现在，蔓蔓需要为它们连上电线，使得彩灯可以正常工作。与一般的连法不同，蔓蔓想要让它们看起来像一棵树，于是采用了如下的连线方法：
- 对于第 $i$ 层（$1 \leq i < n$），蔓蔓会把每个彩灯与其下一层最相邻的三个彩灯连上电线；
- 对于第 $n$ 层，蔓蔓会把两两相邻的彩灯连上电线。

蔓蔓已经连好了一个 $n=3$ 的彩灯，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ioyplw1.png)

可是，蔓蔓还需要准备 $t$ 个彩灯，但他不想动脑了！于是他找到了你，拜托你帮他连一下电线。你可以帮帮他吗？


## 样例 #1

### 输入

```
5
1
2
3
4
5
```

### 输出

```
0
5
16
33
56```

## 样例 #2

### 输入

```
3
114
514
1919```

### 输出

```
38533
790533
11040008```

# 题解

## 作者：ew3www (赞：6)

这是蒟蒻的第一篇题解……
# P11871 张灯结彩 题解

[原题戳这里](https://www.luogu.com.cn/problem/P11871)
# 题目分析
本题为一道较简单的数学题，只要找到了规律就可以 A 掉本题。~~（其实就是一道小学找规律题……）~~

其实，题目所给的示意图就已经几乎告诉了我们规律……
![](https://cdn.luogu.com.cn/upload/image_hosting/s36ipn6x.png)

仔细观察这张图片，可以发现如下规律：

1. 只要不是底部的彩灯，一定会有三根线与下面最相邻的三个彩灯相连。
2. 底部的彩灯之间各有两条线与与它相邻的两个彩灯相连（边缘的彩灯除外）。

因为第 $i$ 行有 $2i-1$ 个彩灯，所以前 $n-1$ 行彩灯的总数为
$$
1+3+5+\cdots+(2 \times n-1)
$$
接着，由于恒等式
$$
1+3+5+\cdots+(2 \times n-1)=n^2
$$

可以得到前 $n-1$ 行彩灯的总数为 $(n-1)^2$。

所以，可以发现：
- 上面 $n-1$ 行的电线总数为 $3\times(n-1)^2$。
- 最下面一行的电线总数为 $n-1$。

因此，电线的总数就为
$$
3\times(n-1)^2+n-1
$$
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int t, n;

int main() {
    scanf("%d", &t);
    while(t--) {
        scanf("%d", &n);
        long long ans = (n - 1) * (n - 1) * 3 + n * 2 - 2;
        //我之所以不用 pow() 函数，是因为臭名昭著的浮点数精度问题会影响到答案……
        printf("%lld\n", ans);
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/207001405)

求管理员大大给过！

### UPD 2025/4/16
修复了一处公式错误。

---

## 作者：如履薄冰 (赞：6)

# 思路
如果有 $n$ 层彩灯，那么彩灯总数量就是 $n^2$ 个。因为平方数有个通项公式：$n^2=(n-1)^2+2 \times n-1$。而第一层有 $1^2$个彩灯，第二层有 $2 \times 2-1$ 个彩灯。这两层彩灯的总个数为 $1^2+(2 \times 2-1)$ 个，也就是 $2^2$ 个。前 $n-1$ 层彩灯都要与其下一层最相邻的三个彩灯连上电线。所以前 $n-1$ 层有 $(n-1)^2 \times 3$ 根电线。最后一层的彩灯个数为 $n^2-(n-1)^2$ 个。所以最后一层的电线个数为 $n^2-(n-1)^2-1$ 个，因为在 $n$ 个彩灯之中，两两相邻的彩灯有 $n-1$ 个。最终答案为 $(n-1)^2 \times 3 +n^2-(n-1)^2-1$ 个彩灯，即 $(n-1)^2 \times 2+n^2-1$ 个彩灯。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        if(n==1){
            cout<<0<<endl;
        }else{
            cout<<(n-1)*(n-1)*2+n*n-1<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Zskioaert1106 (赞：2)

题目传送门：[P11871 第六届威海市大学生程序设计竞赛（本科组）张灯结彩](https://www.luogu.com.cn/problem/P11871)

第一种连接中，对于第 $i(1 \le i < n)$ 层，每个彩灯会连接到下一层的三个彩灯，所以每层有 $3(2i-1)$ 根电线；

第二种连接中，对于第 $n$ 层，相邻的彩灯之间两两连接，总共有 $2n-2$ 根电线。

第一种式子可以化简：

$$
\begin{equation}
\begin{aligned}
&\sum\limits_{i=1}^{n-1} 3(2i-1)
\\=&\sum\limits_{i=1}^{n-1}6i-3
\\=&\sum\limits_{i=1}^{n-1}6i-3(n-1)
\\=&6\sum\limits_{i=1}^{n-1}i-3n+3
\\=&6\dfrac{(1+n-1)(n-1)}{2}-3n+3
\\=&3n(n-1)-3n+3
\\=&3n^2-3n-3n+3
\\=&3n^2-6n+3.
\end{aligned}
\end{equation}
$$

加上第二种的 $2n-2$，即 $3n^2-4n+1$。

```cpp
#include<iostream>
using namespace std;
int t,n;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		cout<<3*n*n-4*n+1<<'\n';
	}
}
```

[AC 记录](https://www.luogu.com.cn/record/206973670)。

---

## 作者：dg114514 (赞：2)

发现，任意一个彩灯只要不是最后一层，就**一定**会连 $3$ 条电线。所以 $1\sim n-1$ 层的计算就是 $\begin{aligned}\sum^{n-1}_{i=1}3(2i-1)&=\sum^{n-1}_{i=1}(6i-3) \\ &= 6(\sum^{n-1}_{i=1}i)-3(n-1) \\ &=6\cdot \frac{n(n-1)}{2}-3(n-1)\\&=(3n)\cdot(n-1)-3(n-1)\\&=(n-1)(3n-3)\end{aligned}$

而最后一层明显就是 $(2n-1)-1=2n-2$，所以答案 $=(n-1)(3n-3)+(2n-2)=(n-1)(3n-3+2)=(n-1)(3n-1)$。

[AC 记录](https://www.luogu.com.cn/record/206991449)。

---

## 作者：YZren (赞：2)

今天比赛时就写了，纯水题，就推一个公式。

1. 先是非 $n$ 的层数，可以看出来前 $n-1$ 层共有 $(n-1)^2$ 个结点，一个点连三条线就 $(n-1)^2 \times 3$ 条线。
2. 接着是第 $n$ 层有 $(2 \times n-1)$ 个点，除去最后一个点，每个点连一条线，所以共 $2 \times (n-1)$ 条线。

3. 最后公式就出来了 $(n-1)^2 \times 3+2 \times (n-1)$。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int t=read(),n;
inline void work(){
	while(t--){
		n=read();
		write((n-1)*(n-1)*3+2*(n-1));
		printf("\n");
	}
}
signed main(){work();return 0;}
```

---

## 作者：54188_you_Dad (赞：2)

# 前言

一道数学题。

# 思路

先算第 $n$ 层需要 $2\times n-1-1$ 根电线，接着第 $i$ 层 $(i<n)$ 需要 $3 \times i$ 根电线。所以答案为 $2\times n-2 + \sum_{i=1}^{n-1} i \times 3$ 。

# 代码

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int q;
	cin>>q;
	while(q--)
	{
		int n;
		cin>>n;
		int t = 2*n-2;
		for(int i=1;i<n;i++)
		{
			int tt = 2*i-1;
			t += tt*3;
		}
		cout<<t<<"\n";
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

一道水题。

注意到，前 $n-1$ 层总共有 $(n-1)^2$ 个彩灯，会向下连 $3(n-1)^2=3n^2-6n+3$ 条电线。而第 $n$ 层有 $2n-1$ 个彩灯，每 $2$ 个相邻的连上电线，总共会连 $2n-2$ 条电线。加起来答案就是 $3n^2-4n+1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
typedef long long ll;
typedef pair<int,int> pii;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		cout<<3*n*n-4*n+1<<endl;
	} 
}


```

---

## 作者：gaohongyuan (赞：1)

# 思路：
直接推式子，可以发现前 $n-1$ 行的灯都连了三条电线，最后一排总共连了 $n-1$ 条电线。  
加起来可得结果为 $3n^2-4n+1$。
# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n;//你猜我为什么要开long long
int main()
{
	cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<3*n*n-4*n+1<<endl;
    }
    return 0;//不华丽的结束
}
```

---

## 作者：corner_xiejunqi (赞：1)

#### 题目分析：
观察样例所给图，我们不难发现这个树的非叶子节点都对电线数有 $3$ 的贡献，叶子节点共对电线数有叶子节点个数减 $1$ 的贡献。通过观察，第 $i$ 层的节点个数等于第 $i-1$ 层的节点个数加 $2$，那么就可以求出第 $n-1$ 层的节点个数，即 $1+2\times (n-2)$，注意特判 $n=1$ 的情况。再用等差数列求和公式，就出所有非叶子节点的个数，即 $(1+1+2\times (n-2))\times (n-1)\div 2$。即可求出结果。
#### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//记得开long long
int t,n;
signed main(){
	// step 1、读题、声明变量
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	// step 2、输入
	cin>>t;
	// step 3、处理
	while(t--){
		cin>>n;
		if(n==1){
			cout<<0<<'\n';
			continue;
		}
		int last=1+2*(n-2);
		int he=(1+last)*(n-1)/2;
		int ans=he*3+last+1;
		cout<<ans<<'\n';
	}
	// step 4、输出
	
	return 0;
}
```

---

## 作者：__CJY__ (赞：1)

## 思路
你会发现第 $1 \sim n-1$ 层得每个彩灯要用 $3$ 根电线，那么第 $i$ 层有 $2 \times i-1$，所以第 $1 \sim n-1$ 层的电线数是 $3 \times \sum\limits_{i=1}^{n-1}(2 \times i-1)$，也可以用等差数列算，公差为 $2$。

而第 $n$ 行的电线数为 $2 \times n-1-1=2 \times n-2$，加上即可。

所以答案应该是 $3 \times \sum\limits_{i=1}^{n-1}(2 \times i-1)+2 \times n-2$。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		int s=0;
		for(int i=1;i<n;i++) s+=2*i-1;
		cout<<s*3+(2*n-2)<<'\n';
	}
}
```

---

## 作者：yyycj (赞：0)

## 主要思路
其实题目中写的已经很清楚了，对于 $i \in [1,n)$，把每个彩灯与其下一层最相邻的三个彩灯连上电线，该层向下连接的电线数就是 $(2i-1) \times 3$；对于 $i=n$，把两两相邻的彩灯连上电线，该层的电线数就是 $2i-1-1$。

## AC Code
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

typedef long long ll;
typedef long double db;
// ----------------------------

// ----------------------------

// ----------------------------


int main() {
	int t; cin >> t;
	// ----------------------------
	int n, ans;
	while (t--) {
		cin >> n;
		ans = 2 * n - 2;
		for (int i = 1; i < n; i++) ans += (2 * i - 1) * 3;
    cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[题目传送门](https://www.luogu.com.cn/problem/P11871)

## 题目思路：
这道题就是简简单单的模拟，跟着题目来走即可。

注意看题：**蔓蔓会把每个彩灯与其下一层最相邻的三个彩灯连上电线**。其实需要一个变量记录每层有个彩灯，再用彩灯数量乘 $3$ 就行了。

再看题：对于第 $n$ 层，蔓蔓会把两两相邻的彩灯连上电线。就是再加上每层彩灯个数减 $1$。

## 正解：
废话不多说，上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,x;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;//输入
	for(int i=1;i<=n;i++){
		cin>>x;//输入
		ll k=1,ans=0;//k为每层彩灯个数，ans为答案。
		for(int j=1;j<=x-1;j++){//最后一个单独加。
			ans+=3*k;
			k+=2;
		}
		ans+=k-1;//很重要，单独加。
		cout<<ans<<"\n";//输出。
	}
	//完结撒花。
	return 0;
}
```

---

## 作者：Nahia (赞：0)

### 思路

不难发现，除了最后一行，其他所有行的所有点都会引出 $3$ 条电线，而最后一行的 $2n-1$ 个点，每两个点有一条电线，所以最后一行有 $2n-2$ 条电线。

值得一提的是，前 $n-1$ 行有 $1+3+ \dots +2(n-1)-1$，即 $\sum_{k=1}^{n=1} (2k-1)$，可以简化为 $(n+1)^2$。

### solution

```cpp
#include<bits/stdc++.h>
#define ll long long
#define PII pair<int,int>
#define For(i,a,b) for(int i = a;i<=b;i++)
#define Rof(i,a,b) for(int i = a;i>=b;i--)
using namespace std;
inline __int128 read(){__int128 x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-'){f=-1;}c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
inline void write(__int128 x){if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);putchar(x%10+'0');}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int t = read();
	while(t--){
		int n = read();
		ll cnt = (n-1)*(n-1);
		ll ans = cnt*3+(2*n-1)-1;
		write(ans);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Na1L0n9 (赞：0)

# Solution

## 思路
比较简单的数学题。我们只需要把每一层与下一层的电线数统计出来求和即可。

我们先来看一段题面：
- 第 $i$ 层上有 $2i-1$ 个彩灯。
- 对于第 $i$ 层（$1 \leq i < n$），蔓蔓会把每个彩灯与其下一层最相邻的三个彩灯连上电线；
- 对于第 $n$ 层，蔓蔓会把两两相邻的彩灯连上电线。

因此，我们易得：
- 对于第 $i$ 层（$1 \leq i < n$），一共有 $\left(6i-3\right)$ 根电线连向下一层。
- 对于第 $n$ 层，一共有 $\left(2n-2\right)$ 根电线。

所以，
$$
ans=\sum_{i=1}^{n-1}\left(6i-3\right)+\left(2n-2\right)
$$
## Code

```cpp
#include <bits/stdc++.h>
#define Write ios::sync_with_stdio(0);
#define by cin.tie(0);
#define AquaDaMean1e cout.tie(0);
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 1e5 + 10;
const int MOD = 998244353;
int T, n;
int main() {
	Write by AquaDaMean1e
	cin >> T;
	while (T--) {
		cin >> n;
		ll sum = 2 * n - 2;
	    for (int i = 1; i < n; i++) {
	        sum += (6 * i - 3);
	    }
	    cout << sum << "\n";
	}
	return 0;
}
```

---


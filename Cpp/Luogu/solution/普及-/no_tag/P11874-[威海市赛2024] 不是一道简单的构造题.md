# [威海市赛2024] 不是一道简单的构造题

## 题目描述

如你所见，这不是一道简单的构造题。

小威是一个天命人，它有无限多的毫毛。众所周知，天命人的一根毫毛就可以化身为一只猴兵。但这时，他发现他召唤出的猴兵们都走在一座不稳定的倒圆锥形山上。为了防止锥形山倒塌，小威需要让所有猴兵站在特定的位置，使其重心合理分布。

已知山底部的支点在 $B(x, y)$ 处，目前有 $k$ 只猴兵，所有猴兵质量均相等，小威需要让猴兵的重心也集中在 $B$ 点，才能保证山的稳定。由于游戏精度的设定，猴兵只能站在整点上，即猴兵的坐标 $(x_i, y_i)$ 中的 $x_i, y_i$ 需要都是整数，并且不能有两只及以上的猴兵位于同一坐标。同时，由于山的大小有限，要求坐标 $-2 \times 10^9 \le x_i, y_i \le 2 \times 10^9$。

请问小威是否有可能让所有猴兵的重心位于 $B$ 点？

## 说明/提示

$n$ 个猴兵 $\{a_i\} = (x_i, y_i)$ 的重心为 $\left(\frac{x_1 + x_2 + \cdots + x_n}{n}, \frac{y_1 + y_2 + \cdots + y_n}{n}\right)$。


## 样例 #1

### 输入

```
1
0 0
```

### 输出

```
Yes```

# 题解

## 作者：0Io_oI0 (赞：11)

你会发现直接输出 `Yes` 可以 AC！那么我就来讲一下为什么可以这样吧。

我们只需要构造出一组符合要求的方式，答案就是 `Yes` 了。

我们分两种情况讨论：
- $k=1$ 的时候，直接让这一个猴子站在 $B(x,y)$ 上就成立了。
- $k>1$ 的时候，我们再分两种情况：
  - 当 $k$ 为偶数的时候，我们让猴子们以 $x$ 为对称轴排列，即两只猴子的横坐标分别为 $x-t,x+t$ 其中 $t$ 是整数。
  - 当 $k$ 为奇数的时候，我们只需要让一只猴子站在 $B(x,y)$ 上，另外的猴子数量又变成了偶数，和偶数的方法一样对称排列。
  
  上边我们考虑的是横坐标，纵坐标也是一样的方法对称排列，就行了。
  
这样猴兵的中心就一定在 $B(x,y)$ 上了！

---

## 作者：cybermage_liu (赞：6)

刚开始我没看见 $x_i,y_i$ 的数据范围，以为和 $x,y$ 一样，导致 WA 了好几次，其实只输出 Yes 就行，但是我还是决定发一篇**大概率是正解的做法**。

# 思路
我们不难看出，当猴兵站成一个在数据范围内重心为 $(x,y)$ 的最大的矩形时，能站最多的猴，而不管多少只猴，只要 $k$ 小于等于这个矩形的面积，不管奇数个还是偶数个，我们都可以使其保持平衡，只要站成中心对称图形就行。

因为要在数据范围内，不能越界，所以我们需要计算左上、右上、左下、右下四种情况，这四种情况中最小的矩形是**数据范围内**重心为 $(x,y)$ 的最大的矩形。

# AC code
于是就有了这篇~~不太聪明的~~题解：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int k,n,m;
	cin>>k>>n>>m;
	__int128 x1=(__int128)((n+2e9)*2+1)*(__int128)((m+2e9)*2+1);
	__int128 x2=(__int128)((2e9-n)*2+1)*(__int128)((2e9-m)*2+1);
	__int128 x3=(__int128)((n+2e9)*2+1)*(__int128)((2e9-m)*2+1);
	__int128 x4=(__int128)((2e9-n)*2+1)*(__int128)((m+2e9)*2+1);
	__int128 ans=min(min(x1,x2),min(x3,x4));
	cout<<((k<=ans)?"Yes":"No");
}
//__int128 是一种可以读入 128 字节的整数存储类型。
//但是数据太水，其实无符号长整型都可以过。
```
# 写在最后
如果出题人本意是这样的话，建议调小 $x_i,y_i$ 范围，和 $x,y$ 一样。

---

## 作者：bbbzzx (赞：3)

诈骗题。

# 题意
给定整数对 $(x,y)$，求是否存在 $k$ 个不同整数对 $(x_i,y_i)$ 使得 
$$ \sum_{i=1}^k x_i=kx$$
$$ \sum_{i=1}^k y_i=ky$$

# 解法
考虑这么一个问题，是否存在两两不同的 $k$ 个整数，使得它们和为 $0$。

若 $2 \mid k$，可以让 $k$ 个数沿 $0$ 两边对称分布。

若 $2 \nmid k$，考虑令一个数为 $0$，然后同理。

于是我们证明了上述命题一定成立。

接着考虑使它们和为其他数，注意到数据范围，即我们构造的和最坏为 $ \pm 10^{14}$，考虑把和平均分为 $k$ 份加到之前命题的数列上，剩下的余数若为正，从右往左给数列上每个数一个 $1$，反正从左往右给每个数加一个 $-1$，可以证明构造的数列一定在限制范围内且两两不同。

所以直接输出
```Yes```即可。

---

## 作者：Xuelin2011 (赞：3)

这里有 $k$ 只猴兵，且 $1\le k\le 10^5$，而他们的坐标 $x_i,y_i$ 可以在 $-2\times10^9$ 到 $2\times10^9$ 之间，输入的重心坐标 $-10^9\le x,y \le10^9$。  
由题可得只要能成为对称轴的，就可以成功，可以证明**无论多少只，只要空间够大，就一定能呈轴对称**。  
分析数据，得 $x_i,y_i$ 到 $x,y$ 的距离一定大于 $10^9$，而猴兵最多只有 $10^5$ 只，所以一定能对称。  
这题主要是想法难，代码写起来，连初学者都会，话不多说，直接上代码。  

```cpp
#include <cstdio>
int main(){
	printf("Yes");
	return 0;
}

```
简单不？

---

## 作者：XsIeEiKcEk (赞：3)

## 题目大意

给出两个数 $x,y$，问能否构造出两个长度为 $k$ 的、平均值为 $x$ 和 $y$ 的序列。

## 解法

我们先看一个序列。

若 $k$ 为偶数，也就是要有偶数个数，那是肯定可以的。

我们可以让 $i\in[1,k/2],a_{2\times i-1}=x-i,a_{2\times i}=x+i$，这样既不会重复，也能让平均数为 $x$（还不会超出范围）。所以 $k$ 为偶数是有解的。

若 $k$ 为奇数，可以也按上面来，剩下的一个数就为 $x$，这样还是有解。所以 $k$ 为奇数也是有解的。

所以结果就得出来了。
## CODE
```cpp
#include <iostream>
using namespace std;

int main() {
	int k, x, y;
	cin >> k >> x >> y;
	cout << "Yes";
	return 0;
}
```

---

## 作者：canwen (赞：2)

诈骗题，容易发现不断构造相互抵消的 $x_i,y_i$ 即可。

这里的点指的是每一只猴兵。

- $k\bmod 2 =0$ 时，构造 $\frac{k}{2}$ 组关于 $u$ 对称的点。

- $k \bmod 2 = 1$ 时，构造 $\lfloor \frac{k}{2} \rfloor$ 组关于 $u$ 对称的点和 $1$ 个在 $u$ 的点。

注意到 $-2 \times 10^9 \le x_i, y_i \le 2 \times 10^9$ 的构造要求，而重心保证 $-10^9 \leq x, y \leq 10^9$，且 $k \le 10^5$，完全不用担心点会重叠。

综上，输出 `Yes` 即可 AC。

---

## 作者：Zskioaert1106 (赞：2)

题目传送门：[P11874 不是一道简单的构造题](https://www.luogu.com.cn/problem/P11874)

如你所见，对于一只猴兵 $(a,b)$，要使两只猴兵的重心在 $(x,y)$，则第二只猴兵要在 $(x-a,y-b)$。

对于偶数个猴兵，总可以安排两两对称的位置。

对于奇数个猴兵，你可以把单独的一只搁在重心处。

所以以当前这个 $k$ 的大小和重心的位置，总能安排合适的猴兵。

[AC 记录](https://www.luogu.com.cn/record/206973720)。

~~不过话说西游记里孙悟空的毫毛貌似没有什么重量。~~

~~哦十万个就难说了。~~

---

## 作者：wuyouawa (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11874)

### 思路

首先，根据说明/提示，我们可以知道 $x_1 + x_2+ \ldots +x_n = n \times x$ 与 $y_1 + y_2+ \ldots +y_n = n \times y$，也就是说，猴兵的重心的 $x$ 等于所有猴兵的 $x$ 的平均数，$y$ 也是如此。

那么就简单了，由于平均数始终在范围内，所以每一次可以用大的补偿小的，这样就可以保证让重心在 $B$ 点，所以一直都输出```Yes```即可。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,y;
int main(){
    cin>>n>>x>>y;
    cout<<"Yes";
    return 0;
}
```

---

## 作者：Nahia (赞：1)

> 如你所见，这其实是一道很简单的构造题。

### 思路

因为所有猴兵质量均相等，所以我们只要让猴兵们均匀分布在四个象限就可以了。更具体地说，假设有一只猴兵在 $(x,y)$，那就必须有三个猴兵（如果 $x=0$ 或 $y=0$ 的话可能不是三个）分别在 $(-x,y),(x,-y),(-x,-y)$ 三个位置才能平衡。所以这道题很简单，只要猴兵个数是偶数，我们就一定能够找到方法让它平衡，最简单的方法是让猴兵关于一条坐标轴对称地站在另一条坐标轴上。

**真的吗？**

如果猴兵个数是奇数，我们有没有方法让它平衡呢？

有的兄弟，有的。只要让一只猴兵站在 $B$ 点就可以了，剩下的猴兵再按照个数是偶数的方法分配就行。

### solution

```cpp
#include<bits/stdc++.h>
#define ll long long
#define PII pair<int,int>
#define For(i,a,b) for(int i = a;i<=b;i++)
#define Rof(i,a,b) for(int i = a;i>=b;i--)
using namespace std;
inline __int128 read(){__int128 x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-'){f=-1;}c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
inline void write(__int128 x){if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);putchar(x%10+'0');}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int k = read();
	int x = read(),y = read();
	cout<<"Yes\n";
	return 0;
}
```

---

## 作者：Na1L0n9 (赞：1)

# Solution
## 思路
有趣的思维题。

当 $k$ 为偶数时，我们可以让猴兵的坐标以重心对称分布。

当 $k$ 为奇数时，我们可以让前 $k-1$ 只猴兵的坐标以重心对称分布，然后把最后一只猴兵放在重心即可。

综上所述，小威一定可以构造出满足条件的方案。
## Code
略。

---

## 作者：KobeBeanBryantCox (赞：1)

# P11874 不是一道简单的构造题 题解

-----------------

[题目传送门](https://www.luogu.com.cn/problem/P11874)。

招笑题。

---------------

## 题意

略。

--------------

## 思路

$n$ 为偶数，构造 $\dfrac n 2$ 组与重心对称的点。

$n$ 为奇数，构造 $\dfrac {n-1} 2$ 组与重心对称的点，最后一个放重心即可。

注意到数据范围，是可以放得下所有猴子的。

所以答案都是 `Yes`。

-------------

## 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int main()
{
	puts("Yes");
	return 0;
}
```

---

## 作者：Sk_sync_opener (赞：1)

可以发现偶数在点上下各放同样个数，奇数在平衡点上放一个，剩下上下放同样个数一定能够平衡。

所以直接输出 ``Yes`` 即可。

---

## 作者：SuyctidohanQ (赞：1)

### 思路分析

这题看着没有思路，一定要骗分！！然后你就可以骗到 $100$ 分。

我们简化一下重心公式为：

$$

\begin{array}{cr}

x_1 + x_2 + \ldots + x_{k-1} + x_k = k \times x \\ \\

y_1 + y_2 + \ldots + y_{k-1} + y_k = k \times y

\end{array}

$$

然后就将问题转化成了：构造 $k$ 个坐标使得它们的 $x$ 坐标和为 $x \times k$，$y$ 坐标和为 $y \times k$。

看起来很复杂，但是仔细一想：对于任意 $k$ 和给定的 $B(x,y)$，只要 $k \ge 1$，并且存在坐标 $B(x,y)$ 标，我们总是可以构造出满足条件的猴兵坐标。

所以这题就是输出 `Yes` 就可以了。

### 代码实现

这代码还需要放吗？

```cpp
#include <bits/stdc++.h>
using namespace std;
int main () {
    int k, x, y;
    cin >> k >> x >> y;
    cout << "Yes" << endl;
	return 0;
}
```

---

## 作者：Laoda_Bryant (赞：0)

## 思路
不难想出一种构造方案：
* 当 $k$ 为偶数时，我们可以在 $(x,y)$ 的左右两侧 $(x-\frac{k}{2},y)$ 至 $(x-1,y)$ 的区间和 $(x+1,y)$ 至 $(x+\frac{k}{2},y)$ 的区间放置猴兵。因为猴兵放置的范围为 $-2\times 10^9 \sim 2\times 10^9$，而重心坐标 $(x,y)$ 的 $x$ 最小和最大为 $-10^9$ 和 $10^9$，一侧猴兵数量最多为 $\frac{10^5}{2}$，有足够多的位置放置猴兵。因此，我们并不需要考虑猴兵坐标超出山体大小的极限。
* 对于 $k$ 等于奇数的情况，我们只需要把其中一个猴兵放置在重心坐标 $(x,y)$ 的位置上。对于剩下的 $k-1$ 个猴兵，当成偶数的情况讨论即可。
  
因此，本题只需要输出 `Yes` 即可。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    puts("Yes");
    return 0;
}
```

---


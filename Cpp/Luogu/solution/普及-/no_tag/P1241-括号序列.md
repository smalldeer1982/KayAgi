# 括号序列

## 题目描述

定义如下规则：

1. 空串是「平衡括号序列」
2. 若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」
3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。


例如，下面的字符串都是平衡括号序列：


- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`


而以下几个则不是：


- `(`，`[`，`]`，`)(`，`())`，`([()`


现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：
1. 从左到右扫描整个字符串。
2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。

配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。

## 样例 #1

### 输入

```
([()
```

### 输出

```
()[]()
```

## 样例 #2

### 输入

```
([)```

### 输出

```
()[]()```

# 题解

## 作者：MY（一名蒟蒻） (赞：1324)

[**原题传送门**](https://www.luogu.com.cn/problem/P1241)
## 0.几句闲话
NOIP/CSP初赛就要来了，听说在比赛前发题解可以加人品哦！

首先这个题面。。。真的让人无f**k说（~~自觉和谐~~，讲的真的是模糊不清。之前根本就理解不了题意。

顺便提一句，标签写 `递推` 是什么鬼啊，连个栈都没有。

**毒瘤题的特点：**
- 题面毒瘤
- 样例极水
- 数据毒瘤

样例又水又少，我的错误代码还直接秒杀各位题解区大佬们的测试数据。

我反手一个提交，闷声63分（~~老63分了~~。

---
## 1.准备工作
**前置芝士：栈**

例题：
1. [红-P1739](https://www.luogu.com.cn/problem/P1739) 
2. [黄-P4387](https://www.luogu.com.cn/problem/P4387)

[本题](https://www.luogu.com.cn/problem/P1241)是绿题。~~光学三基色~~

### 那么什么是栈呢？
~~该不会真的有不知道什么是栈的人做这题吧。~~

其实作者在自己~~早年~~[P4387](https://www.luogu.com.cn/problem/P4387)（没错就是例题）的[~~恶臭~~题解](https://www.luogu.com.cn/blog/nizhuan/solution-p4387)中介绍过了。不清楚的童鞋可以看看，记得点赞哦（~~光速逃~~。

~~又打广告，你该不会以为真有人看你的题解吧。~~

---
### 审题很重要！
~~不过这题你还是直接看题解区的题面解释吧。~~

**题面解释：**

对于每一个右括号，找它左边还没~~死~~被弹掉的左括号，如果可以匹配，则出栈，否则补全该括号。

**接下来就可以着手写了！**

---
## 2.与$\color{red}WA$的斗争
在说正解之前，先看看本蒟蒻的错误。

**思路：**

各设一个栈存放无法匹配的两种括号，还有一个栈存放所有左括号。

对于每一个左括号，存放到对应的栈中，并记录出现的位置。对于每一个右括号，如果可以匹配，同时弹栈。否则存入对应栈中。

最后按类型输出即可。
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <string>

using namespace std;
struct node{char c; int num;}lit[110],mid[110];//小括号，中括号栈
int ltop,mtop,lnow=1,mnow=1;
string a;
char lef[110];//离当前右括号最近的左括号
int leftop;
int main()
{
//	freopen("work.in","r",stdin);freopen("work.out","w",stdout);
	cin >> a;
	int n=a.length();
	for(int i=0;i<n;i++)
	{
		if(a[i] == '(')//左括号
		{
			lit[++ltop].num=i;
			lit[ltop].c=a[i];
			lef[++leftop]=a[i];
		}
		if(a[i] == ')')//右括号
		{
			if(ltop && lit[ltop].c == '(' && lef[leftop] == '(') ltop--,leftop--;
			else lit[++ltop].num=i,lit[ltop].c=a[i];
		}
     //下同
		if(a[i] == '[')
		{
			mid[++mtop].num=i;
			mid[mtop].c=a[i];
			lef[++leftop]=a[i];
		}
		if(a[i] == ']')
		{
			if(mtop && mid[mtop].c == '[' && lef[leftop] == '[') mtop--;
			else mid[++mtop].num=i,mid[mtop].c=a[i];
		}
	}
   //输出
	for(int i=0;i<n;i++)
	{
		bool f=false; 
		if(i == lit[lnow].num && lnow <= ltop)
		{
			f=true;
			if(lit[lnow].c == '(') printf("%c)",a[i]);
			else printf("(%c",a[i]);
			lnow++;//遍历
		}
		if(i == mid[mnow].num && mnow <= mtop)
		{
			f=true;
			if(mid[mnow].c == '[') printf("%c]",a[i]);
			else printf("[%c",a[i]);
			mnow++;
		}
		if(!f) printf("%c",a[i]);//如果可以匹配，直接输出
	}
//	fclose(stdin);fclose(stdout);
	return 0;
}
```
这就是传说中*秒杀各位题解区大佬们的测试数据*的神奇代码，但这是有问题的，各位可以自己想想哪里有问题。欢迎在评论区回答，评论我都会看的。

~~本地秒杀测试数据，但交到洛谷IDE就被hack了QwQ（还是我写题解的时候才想到去IDE上提交的~~

---
## 3.正解
被`63`分搞到心态爆炸之后，~~上B栈颓废了一会儿~~冷静下来，想到了优化空间的解法。当时还不确定是对的。

**思路：**
1. 还是搞一个栈存放所有左括号；一个栈存放所有左括号出现的位置；一个数组存放匹配结果，匹配成功则为空格，输出时忽略。
2. 如果是左括号则入栈，如果是右括号则看看最左边还没死的左括号，匹配成功则弹栈。修改该匹配成功的左括号的匹配结果。
3. 最后按序输出即可。

感觉思路已经很清晰了，建议不要阅读以下代码，尝试自己写出来。实在写不出来可以参考一下，**但请您确保您已经做了足够的思考。** 为了让读者诸君有思考和理解的空间，以下代码将**不做任何注释**。

**code**
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <string>

using namespace std;
int top,w[110];
string a;
char s[110],c[110];
int main()
{
//	freopen("work.in","r",stdin);freopen("work.out","w",stdout);
	cin >> a;
	int n=a.length();
	for(int i=0;i<n;i++)
	{
		if(a[i] == '(' || a[i] == '[')
		{
			s[++top]=a[i];
			w[top]=i;
			if(a[i] == '(') c[i]=')';
			else c[i]=']';
		}
		if(a[i] == ')')
		{
			if(top && s[top] == '(') {c[w[top]]=' '; top--;}
			else c[i]='(';
		} 
		if(a[i] == ']')
		{
			if(top && s[top] == '[') {c[w[top]]=' '; top--;}
			else c[i]='[';
		}
	}
	for(int i=0;i<n;i++)
	{
		if(c[i] == '(' || c[i] == '[') printf("%c%c",c[i],a[i]);
		else if(c[i] == ')' || c[i] == ']') printf("%c%c",a[i],c[i]);
		else printf("%c",a[i]);
	}
//	fclose(stdin);fclose(stdout);
	return 0;
}
```

## Thank you for your reading!
~~点个赞再走嘛。拒绝白嫖，从我做起。~~

---

## 作者：YuJieSong (赞：287)

这道题匹配的方式是真的没有讲清楚

看了几遍题目一脸懵

~~甚至看了题解也还是一脸懵~~

那这里我还是想把题意讲的更简单理解一点

原题目：扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。

翻译：扫描一遍原序列，当找到一个右括号（即找到一个 ' ) ' 或者 ' ] ' 时），以它为起点向左找，找到一个**没被标记成功匹配**的左括号（即找到一个 ' ( ' 或者 ' \[ ' ），如果两者匹配的话，标记它们成功 ~~牵手~~ 匹配，如果不匹配，或者找不到左括号的话，不做任何标记。

原题目：在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。

翻译：上面扫描一遍标记完成功匹配的括号之后，扫描一遍序列，对于标记过的括号，则直接输出；对于没有标记的括号，则补全成对输出

举例：如果有个 ' \[ ' 或 ' ] ' 没被标记匹配，则输出 \[ ]

如果还不理解的话，给个测试样例：

输入：( \[ ) ] )

输出：( \[ ( ) ] )

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

int a[105]; // 标记

int main()
{
    int i,j;
    string s;
    cin >> s;
    for (i=0; i<s.length(); i++) {
        if (s[i] == ')') { // 找到了右括号
            for (j=i-1; j>=0; j--) {
                if (s[j] == '(' and a[j] == 0) { // 找到了没被匹配过的左括号且匹配成功
                    a[i] = a[j] = 1;
                    break;
                }
                else if (s[j] == '[' and a[j] == 0) break; // 找到了左括号但匹配失败
            }
            // 找不到左括号，不做任何操作
        }
        // 下面同理
        else if (s[i] == ']') {
            for (j=i-1; j>=0; j--) {
                if (s[j] == '[' and a[j] == 0) {
                    a[i] = a[j] = 1;
                    break;
                }
                else if (s[j] == '(' and a[j] == 0) break;
            }
        }
    }
    for (i=0; i<s.length(); i++) {
        if (a[i] == 0) { // 没有匹配则成对输出
            if (s[i] == '(' or s[i] == ')') cout << "()";
            else cout << "[]";
        }
        else cout << s[i]; // 匹配成功则直接输出
    }
    return 0;
}

```

本题作为一道绿题，难度全在语文理解上

如果去除题意不明干扰的话，只能是普及-

---

## 作者：anyway (赞：124)

（与格式问题斗争到底！

才发现没有用栈的题解，不是什么高端做法啦。

就是从头搜，如果是左括号就入栈，先假设它们都需要匹配，把相应的右括号存进b数组；如果是右括号就看栈顶端的左括号是否与之匹配，匹配则将b数组中存的右括号清除，不匹配则添加相应左括号。输出时先看一下b数组补全左括号再输出，然后再看一遍b数组补全右括号。


```cpp
#include<cstdio>
#include<cstring>
int  q[101],top;
char c[101],b[101];
int main()
{
    int i,l;
    scanf("%s",c);
    l=strlen(c);
    for (i=0;i<l;i++)
    {
        if (c[i]=='(') {q[++top]=i; b[i]=')';}
        if (c[i]=='[') {q[++top]=i; b[i]=']';}
        if (c[i]==')'||c[i]==']')
            if (!top||b[q[top]]!=c[i])
                if (c[i]==')') b[i]='('; else b[i]='[';
            else b[q[top--]]=' ';
    }
    for (i=0;i<l;i++)
    {
        if (b[i]=='('||b[i]=='[') printf("%c",b[i]);
        printf("%c",c[i]);
        if (b[i]==')'||b[i]==']') printf("%c",b[i]);
    }
    return 0;
}
```

---

## 作者：WanderingTrader (赞：100)

又是一道括号题，先把`stack<>`拿出来。  
### 题意简述
首先把括号匹配，然后把括号补全。  
### 题目分析
匹配括号很容易，关键在于：
- 怎么定义“匹配不成功”？
- “匹配不成功”该如何处理？

样例给的数据并不具有代表性，下面加一条：
##### 样例输入
```
([)]
```
##### 样例输出
```
()[()]
```
由此得到答案：
- 遇到右括号时，只要最近的左括号无法与自己匹配，视作不成功；
- 将缺少的括号补全即可。

### 代码
先上框架：
```cpp
stack <int> st;
bool ok[105];
int main(){
	string s;
	cin >> s;
	int len = s.length();
	for(int i = 0,k;i < len;i ++)
	{
	}

}
```
这里$ok[i]$表示$i$号位置是否已经匹配完成，$st$存储上一个左括号的位置。  

如果$s[i]$是“]”，我们查看上一个左括号是否为‘\[’,如果是则将两个位置都标为$1$：
```cpp
if(s[i] == ']')
{
	if(st.empty()) continue;
	k = st.top();
	if(s[k] == '[') 
	{
		ok[k] = ok[i] = 1;
		st.pop();
	}
}
```
注意不要忘记判断栈是否为空，否则会出现`RE`  
$s[i]$为‘)’的代码直接复制粘贴，改几个符号即可：
```cpp
else if(s[i] == ')')
{
	if(st.empty()) continue;
	k = st.top();
	if(s[k] == '(') 
	{
		ok[k] = ok[i] = 1;
		st.pop();
	}
}
```
其它情况直接入栈：
```cpp
else
	st.push(i);
```
现在$ok[]$数组更新完毕，可以输出了。

对于每一个$i(i\in[1,len))$，如果$ok[i]=1$,直接输出该字符。  
反之，根据括号类型匹配：
```cpp
for(int i = 0;i < len;i ++)
{
	if(ok[i]) cout << s[i];
	else
	{
		if(s[i] == '(' || s[i] == ')') printf("()");
		else printf("[]");
	}
}
```
全部代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
stack <int> st;
bool ok[105];
int main(){
	string s;
	cin >> s;
	int len = s.length();
	for(int i = 0,k;i < len;i ++)
	{
		if(s[i] == ']')
		{
			if(st.empty()) continue;
			k = st.top();
			if(s[k] == '[') 
			{
				ok[k] = ok[i] = 1;
				st.pop();
			}
		}
		else if(s[i] == ')')
		{
			if(st.empty()) continue;
			k = st.top();
			if(s[k] == '(') 
			{
				ok[k] = ok[i] = 1;
				st.pop();
			}
		}
		else
			st.push(i);
	}
	for(int i = 0;i < len;i ++)
	{
		if(ok[i]) cout << s[i];
		else
		{
			if(s[i] == '(' || s[i] == ')') printf("()");
			else printf("[]");
		}
	}
	return 0;
}
```
总体上说，这道题难度并不大，主要难在对题目的解读和细节（判断栈为空）上。  
时空复杂度$O(n)$，不解释了。  
$\mathrm{The\ end.}$

---

## 作者：jyz666 (赞：61)

#  P1241 【括号序列】
## **[传送门](https://www.luogu.com.cn/problem/P1241)**

### 理解

这道题题目描述不太清楚，卡了我二十多分钟（可能是我太过蒟蒻）

然后本蒟蒻就WA了七八遍

~~是某谷的问题~~

好吧，是我过于蒟蒻的问题

题目告诉我们一个括号序列，然后要求我们求它经过补全后的序列。

注意： 补全不是题目中说的最短序列，不是括号嵌套层数最小的序列。

题意是指： 遍历一遍原序列，然后给每一个右括号找它左边最近的左括号，如果没有，就在这种方式把原序列遍历完后，补全剩下未匹配的括号。
 
### 思路

我们用栈来存储没有匹配括号的括号

定义一个匹配的数组，用来给没有匹配括号的括号匹配括号
for循环从0到size过一遍

### 上代码》》》

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char s[1010],b[1010];
int fh[300];
char tj[9]={'>','}',']',')','0','(','[','}','<'};
stack<int> st;
 
int main() {
    cin>>s;
    int l=strlen(s);
    fh['(']=-1;
    fh[')']=1;
    fh['[']=-2;
    fh[']']=2;
    fh['{']=-3;
    fh['}']=3;
    fh['<']=-4;
    fh['>']=4;
    
    for(int i=0; i<l; i++) {
        char c=s[i];
        if(fh[c]<0){
            st.push(i);
        }
        else{
            if(!st.empty()){
                int k=st.top(); 
                if(fh[s[k]]+fh[c]==0){
                    b[i]=b[k]=1;
                    st.pop();
                }
            }
        }
    }
    for(int i=0; i<l; i++){
        if(b[i]){
            cout<<s[i];
        }else{
            int k=fh[s[i]];
            if(k<0){
                cout<<s[i]<<tj[4+k];
            }else{
                cout<<tj[4+k]<<s[i];
            }
        }
    }
}
```

~~点个赞呗~~


---

## 作者：MSTree (赞：18)

这个题其实相当水，主要难度在于阅读理解。题目中“找到在它左边最靠近它的左括号匹配，如果没有就放弃。”的意思其实是对于任意一个右括号（  “）”或者“]”  ），从他开始向前遍历找到第一个任意形式的左括号（“（”或者“[” ）进行匹配，即使两个括号不匹配（“（]”或者“[)”）也停止遍历，直接给该右括号打“不能匹配”的标签然后大循环继续向后遍历。

这样就好办了。先给所有括弧初始化不匹配的标签，然后建一个栈，大循环从前向后遍历，找到任意形式的前括号（“[”或“（”）就把这个前括号入栈，遇到任意后括号就把该后括号与当前栈顶的前括号匹配，如果匹配就给两个括弧打上成功匹配的标签，让栈顶的前括号出栈然后继续遍历；如果两个括弧不匹配就直接保留该括弧的不匹配标签然后大循环继续向后遍历。最后在输出的时候如果字符有成功匹配的标签就直接输出，否则将其补全（"("or")"-->"()"，"["or"]"-->"[]"）然后再输出。


```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
bool pd[10000000];
struct zh{
	char k;
	int ad;
}z[10000000];//模拟栈
int top=0;
int main(){
	cin>>a;
	memset(pd,0,sizeof(pd));
	for(int i=0;i<a.length();i++){
		if(a[i]=='['||a[i]=='(')	z[top].k=a[i],z[top].ad=i,top++;//入栈
		if(a[i]==')'&&z[top-1].k=='(')	pd[i]=1,pd[z[top-1].ad]=1,top--;//出栈
		if(a[i]==']'&&z[top-1].k=='[')	pd[i]=1,pd[z[top-1].ad]=1,top--;//出栈
	}
	for(int i=0;i<a.length();i++){
		if(pd[i]==1)	cout<<a[i];
		else{//补全括号
			if(a[i]=='('||a[i]==')')	cout<<"()";
			if(a[i]=='['||a[i]==']')	cout<<"[]";
		}
	}
	return 0;
}
```


---

## 作者：Zlc晨鑫 (赞：15)

$Update: 2020.4.22 \text{添加了调试数据}$。

---

[$\text{My blog}$](https://www.luogu.com.cn/blog/Zlc/)  
[题目传送门](https://www.luogu.com.cn/problem/P1241)  
[AC记录1](https://www.luogu.com.cn/record/32976673)  
[AC记录2](https://www.luogu.com.cn/record/32987758)

---

前置知识：

使用栈验证括号串是否正确的方法：遇到左括号就入栈，遇到匹配的右括号就出栈，否则不出栈；操作结束后，如果栈为空，则括号串正确，否则错误。

可以练习一下这道题：

- [P1739](https://www.luogu.com.cn/problem/P1739)

---

题意分析：

假设输入的字符串$s$是`([()`，则可以拆分为：  `'(', '[', '(', ')'`，而根据题目要求，其实这个字符串的每个元素都由$3$个子元素组成：补全的左括号，原字符（即读入的字符），补全的右括号。所以，$s$可以表示为：

```
(0, '(', 0), (0, '[', 0), (0, '(', 0), (0, ')', 0)
```

注：$0$表示没有字符，即不需要补全。

---

解题思路：

- 思路$1$：先假设每一个括号都需要补全，遇到和它匹配的括号就把补全的括号删除；需要知道括号的字符值（验证括号）和在$s$中的下标（删除补全括号）。

- 思路$2$：先不作任何假设，直接匹配，右括号就入栈，左括号匹配了就出栈，否则左括号补全相应的右括号；扫描完毕之后，将栈中的右括号全部补全相应的左括号；同样需要知道括号的字符值（验证括号）和在$s$中的下标（补全括号）。

---

数据结构：

栈用来验证括号，由解题思路可知，栈中的每个元素需要储存两个信息（字符值和下标），不过为了方便起见，可以只储存下标，相应的字符值到$s$中取即可。

每一个括号元素有三个子元素，例如：`(0, '(', 0)`。

--- 

代码实现：

- 思路$1$：

```cpp
#include <cstdio>
#include <cstring>

const int MAX = 100 + 5;

struct bracket {
    static const int MAX = 5;
    char l, m, r; //(left)middle(right)
    char s[MAX];
    bracket() {
        this->l = this->m = this->r = 0;
        memset(this->s, 0, sizeof(this->s));
    }
    void merge() {
        int i = 0;
        if (l) s[i++] = l;
        if (m) s[i++] = m;
        if (r) s[i++] = r;
        s[i] = '\0';
    }
}s[MAX];

struct stack {
    static const int MAX = 100 + 5;
    int val[MAX];
    int _top;

    stack() { 
        memset(this->val, 0, sizeof(this->val)); 
        this->_top = 0; 
    }

    void push(int x) { this->val[++this->_top] = x; }
    void pop() { this->_top--; if (_top < 0) _top = 0; }
    int top() { return this->val[this->_top]; }
}s2;

char in[MAX];

int main() {
    scanf("%s", in);
    int len = strlen(in);
    for (int i = 0; i < len; ++i)
        s[i].m = in[i];
    for (int i = 0; i < len; ++i) {
        switch (s[i].m) {
            case '(': s2.push(i); s[i].r = ')'; break;
            case '[': s2.push(i); s[i].r = ']'; break;
            case ')': 
                if (s[s2.top()].m == '(') s[s2.top()].r = 0, s2.pop();
                else s[i].l = '('; 
                break;
            case ']':
                if (s[s2.top()].m == '[') s[s2.top()].r = 0, s2.pop();
                else s[i].l = '[';
                break;
        }
    }
    for (int i = 0; i < len; ++i)
        s[i].merge(), printf("%s", s[i].s);
    putchar('\n');
    return 0;
}
```

- 思路2：

```cpp
#include <cstdio>
#include <cstring>

const int MAX = 100 + 5;

struct bracket {
    static const int MAX = 5;
    char l, m, r;
    char s[MAX];
    bracket() {
        this->l = this->m = this->r = 0;
        memset(this->s, 0, sizeof(this->s));
    }
    void merge() {
        int i = 0;
        if (l) s[i++] = l;
        if (m) s[i++] = m;
        if (r) s[i++] = r;
        s[i] = '\0';
    }
}s[MAX];

struct stack {
    static const int MAX = 100 + 5;
    int val[MAX];
    int _top;

    stack() { 
        memset(this->val, 0, sizeof(this->val)); 
        this->_top = 0; 
    }

    void push(int x) { this->val[++this->_top] = x; }
    void pop() { this->_top--; if (_top < 0) _top = 0; }
    int top() { return this->val[this->_top]; }
}s2;

char in[MAX];

int main() {
    scanf("%s", in);
    int len = strlen(in);
    for (int i = 0; i < len; ++i)
        s[i].m = in[i];
    for (int i = 0; i < len; ++i) {
        switch (s[i].m) {
            case '(': s2.push(i); break;
            case '[': s2.push(i); break;
            case ')': 
                if (s[s2.top()].m == '(') s2.pop();
                else s[i].l = '('; 
                break;
            case ']':
                if (s[s2.top()].m == '[') s2.pop();
                else s[i].l = '[';
                break;
        }
    }
    while (s2._top > 0) {
        switch (s[s2.top()].m) {
            case '(': s[s2.top()].r = ')'; break;
            case '[': s[s2.top()].r = ']'; break;
        }
        s2._top--;
    }
    for (int i = 0; i < len; ++i)
        s[i].merge(), printf("%s", s[i].s);
    putchar('\n');
    return 0;
}
```

---

如有错误欢迎指出，谢谢阅读。

---

更新几组`hack`数据，是我调代码的时候找到的（我AC了之后还交了好几次，你去看我的提交记录就知道了）。

$1$：
```
input:
(]))
output:
([])()
```
$2$:
```
input:
([)]
output:
()[()]
```

$3$:（和2好像差不多）
```
input:
([)
output:
()[]()
```

这些数据`hack`的程序是没有用栈直接暴力匹配的，具体的看我的提交记录。

---

## 作者：Hunter_Will (赞：14)

本题是一道极水的简单题，因为题意描述不清，交了好多次才a。下面解释一下题意，输入一个括号序列，输出它经过补全后的序列，注意补全规则既不是题目中说的最短序列，也不是括号嵌套层数最小的序列，而是扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。所以只需扫描一遍就够了。题解中用到了一个巧妙的编码。值得学习。另外，这道题是一道基础题，推荐大家做poj1077的括号序列，那才是真正的括号序列。这道题不过是把那道题的题面翻译了一遍加了一个不写spj的借口而已。而且jsoi(2011)的括号修复（bzoj）是一道splay的题根本不是这道水题。（ps：以本题做法交poj会wa）






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char str[300];
int out[300];
int id(char a){
    switch(a){
        case '(':return -2;
        case '[':return -1;
        case ']':return 1;
        case ')':return 2;
        default :return 0;
    }
}
void print(int a){
    if(a==1||a==-1)printf("[]");
    else if(a==2||a==-2)printf("()");
}
int main(){
    scanf("%s",str);
    for(int i=0;str[i]!='\0';i++){
        out[i]=id(str[i]);
    }
    bool f=false;
    for(int i=0,j=i;str[i]!='\0';i++){
        if(out[i]>0){
            if(out[i]+out[j]==0){
                out[i]=0;out[j]=0;
                while(j>0&&out[j]>=0&&f)j--;
            }
        }
        else {
            f=true;j=i;
        }
    }
    for(int i=0;str[i]!='\0';i++){
        if(out[i]==0)printf("%c",str[i]);
        else print(out[i]);
    }
    return 0;
}
```

---

## 作者：吴国铨 (赞：10)

对于输入的括号序列字符串，从左向右进行查找，用一个数组来记录查找配对的情况，如果一个括号有相应的括号跟它对应，则将它标记为0，如果没有相应的括号跟它对应，则保存原子始代码的编号，“[]”分别为-1和1，“()”分别为-2和2。

因此对于读入的字符串，首先将其转换为相应的代码存放到数组里，为后面查找匹配做准备。

查找匹配时，可用这样的方法：

如果当前的字符是右括号，则跟前面的一个没有匹配的左括号对照，看是否匹配，如果匹配，则将两个字符标记为0，查找并定位到左边的第一个没有匹配的左括号(如果有的话)。如果当前的字符是左括号，则记住这个不匹配的左括号的位置，为后面找到右括号时匹配做准备。

从第一个字符开始到最后一个字符重复上面的过程，检查处理完毕。

输出时考虑到不增加嵌套的层数，以就近的原则，将出现不匹配的一个括号时，输出两个匹配的括号。



//不要抄代码，不然你会后悔的

var s:string;

    a:array[0..255] of longint;

i，j:integer;

```cpp
begin
  raedln(s);
  j=0
  for i:=1 to length(s) do
  a[i]:=pos(s[i],' ( [ . ] ) ')-3;      
  for i=1 to length(s) do
   if a[i]>0 then
      if a[i]+a[j]:=0 then   
        begin
          a[i]=0;a[j]:=0
          while (j>0) and (a[j]>=0) do dec(j);    
        end
        else
      else j:=i;  
  for i=1 to length(s) do
  if a[i]=0 then write(s[i]) else         
    case a[i] of
      -2,2:write('( )')   
      -1;1:write('[ ]')
    end;
  writeln;
end.

```

---

## 作者：CCCloud (赞：7)

前言：在机房把这道题给过了，好不容易  
### [题目QAQ](https://www.luogu.com.cn/problem/P1241)  

当你看完题目后，你会发现题目讲的**含含糊糊**；  
于是就有了下边的**详细解释**：  
1、**扫描一遍**原序列，当你找到一个**右括号**时，以它为起点向左找，找到一个没被标记匹配成功的**左括号**；  
2、如果找的到，那么此右括号与此左括号被标记为**匹配成功**，否则**不做任何处理**；  
3、扫描完**全部序列**以后，将**被标记**的括号**直接输出**，将**没有被标记**的括号**补上对应的括号**（比如 $'('$ 就补上 $ ')'$）；

------------
那么就很清楚了  
代码实现如下：  
```cpp
#include <cstdio>
#include <cstring>
using namespace std;

int len, tot;
char t[1005];//字符串读入括号序列
bool mem[1005];//标记数组

int main(void)
{
	scanf("%s", t+1);
	len=strlen(t+1);
	
	for(int i=1; i<=len; i++)//遍历字符串
	{
		if(t[i]==']')
		{
			for(int j=i-1; j>=1; j--)//查找是否有满足条件的括号
			{
				if(t[j]=='(' && !mem[j]) break;
				if(t[j]=='[' && !mem[j])
				{
					mem[i]=1;
					mem[j]=1;
					break;
				}
			}
		}
		else if(t[i]==')')
		{
			for(int j=i-1; j>=1; j--)
			{
				if(t[j]=='[' && !mem[j]) break;
				if(t[j]=='(' && !mem[j])
				{
					mem[i]=1;
					mem[j]=1;
					break;
				}
			}
		}
	}
	for(int i=1; i<=len; i++)
	{
		if(mem[i]) printf("%c", t[i]);//输出
		else
		{
			if(t[i]=='(') printf("%c)", t[i]);//补全括号并输出
			else if(t[i]==')') printf("(%c", t[i]);
			else if(t[i]=='[') printf("%c]", t[i]);
			else printf("[%c", t[i]);
		}
	}
	
	return 0;
} 
```
本题解和代码都是笔者一字一字码出来的，请勿抄袭！

---

## 作者：Black_Porridge (赞：4)

来写一篇快乐STL的题解!

$Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int>q;//定义一个栈
string s,b;//s是输入字符串,b是配对的字符串
int main()
{
    cin>>s;//输入
    int l=s.size();
    for (int i=0;i<l;i++)
    {
        if (s[i]=='(') 
		{
		   q.push(i); //入栈
		   b[i]=')';//相应的括号匹配上
		}
        if (s[i]=='[') 
		{
		   q.push(i); //同理
		   b[i]=']';
		}
        if (s[i]==')' or s[i]==']')//如果是后半边括号
            if (q.empty() or b[q.top()]!=s[i])//这里一定是q.empty不要写错了
                if (s[i]==')') 
				    b[i]='('; 
				else 
				    b[i]='[';//相应的配对
            else b[q.top()]=' ',q.pop();
    }
    for (int i=0;i<l;i++)
    {
        if (b[i]=='(' or b[i]=='[')
            cout<<b[i];//输出配对
        cout<<s[i];//输出原来的字符
        if (b[i]==')'||b[i]==']') 
		    cout<<b[i];
    }
    cout<<endl; //完美结束qwq
}
```
谢谢观看qaq

---

## 作者：Mars_Dingdang (赞：2)

写在前面：本题描述大雾，有许多细枝末节的情况没有解释。

## 题目大意
定义如下规则序列(字符串)：

1．空序列是规则序列；

2．如果 $\rm S$ 是规则序列，那么 `(S)` 和 `[S]` 也是规则序列；

3．如果 $\rm A$ 和 $\rm B$ 都是规则序列，那么 $\rm A\rm B$ 也是规则序列。

现在，给你一些由 `(`，`)`，`[`，`]` 构成的序列，你要做的，是补全该括号序列，即扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。

【举例说明】

- 以下属于规则序列：`()`, `()[]()`, `([])[()]`, `[(()[])]`；

- 以下不属于规则序列：`)(`, `([)]`。

## 大体思路
本题在理解题面的基础上就容易了许多，即：

- 对于每一个 `)`，都要在出现未被匹配过的 `[` 或 `]` 之前成功匹配上 `(`；

- 同理，对于每一个 `]`，都要在出现未被匹配过的 `(` 或 `)` 之前成功匹配上 `[`。

一旦在匹配某种括号的过程中遇到**另一种未被匹配过**的括号，即表明本次匹配中止，跳出循环。而对于某种括号存在剩余的情况，即视为未匹配成功。

因此，我们需要将括号序列输入至一个字符串中，然后进行遍历，遇到右括号则按上述规则倒序遍历前半部分进行匹配。在此过程中，需要一个 bool 类型的**标记数组**记录每个括号是否已被匹配。代码如下：

```cpp
for(int i=0;i<len;i++){//正序遍历字符串
        if (s[i]==')'){//遇到右括号
            for(int j=i-1;j>=0;j--){//倒序遍历
                if (s[j]=='(' && a[j]==0){
                    a[i]=a[j]=1;//标记
                    break;
                }
                else if(s[j]=='[' && a[j]==0) break;//不符合规则
            }
        }
        else if(s[i]==']'){//同理
            for(int j=i-1;j>=0;j--) {
                if (s[j]=='[' && a[j]==0) {
                    a[i]=a[j]=1;
                    break;
                }
                else if(s[j]=='(' && a[j]==0) break;
            }
        }
    }
```
最后就是临门一脚：输出匹配后的序列。分类考虑：对于已经匹配完成的括号（即标记数组为 1），直接输出，否则圆括号输出 `()`，方括号输出 `[]`。代码如下：

```cpp
for(int i=0;i<len;i++){
        if(a[i]==0){//未匹配成功
            if (s[i]=='(' || s[i]==')') cout<<"()";//匹配圆括号
            else cout<<"[]";
        }
        else cout<<s[i];//方括号
    }
```
## 后记
其实刚拿到本题，以为是一个简单的括号匹配，用几个 `stack` 就可以解：
```cpp
stack<char> s1;
for(1..n)
	if(s[i]=='(') s1.push('(');
	else if(s[i]==')') {
		if(s1.empty()) puts("No"),return 0;
    		else s1.pop(); 
	}
if(!s1.empty()) puts("N0"),return 0;
puts("Yes");
```

---

## 作者：寒冰大大 (赞：2)

貌似就是一个很普通的栈。
按照题目的说法  $~[~(~]~) $  是不行的
另外题目有个很重要的条件

> 找到在它左边最靠近它的左括号匹配


也就是说[(]这种要被补成[]()[]
而[)]要被补成[()]

接下来就只要用一下pair和一个标记数组就可以了。

```cpp
#include<touwenjian.h>
using namespace std;

using namespace std;

stack <pair<int,int> > s1;
char s[200];
int bj[200],n;

int main()
{
    scanf("%s",s);
    memset(bj,-1,sizeof(bj));  //后面认为匹配的()在bj中体现是1，[]是2，所以赋为其他值
    int i,j;
    n=strlen(s);
    for(i=0;i<n;i++)
    {
        char t=s[i];
        if(t=='('||t=='[') s1.push(make_pair(i,t=='('));
        if(t==')'||t==']') if(s1.empty()||s1.top().second!=(t==')')) bj[i]=(t==')'); else s1.pop();
    }
    while(!s1.empty()) bj[s1.top().first]=s1.top().second,s1.pop();
    for(i=0;i<n;i++)
    {
        if(bj[i]==-1) printf("%c",s[i]);
        else if(bj[i]==1) printf("()");
        else printf("[]");
    }
    return 0;
}
```


---

## 作者：wflengxuenong (赞：2)

写一堆If太麻烦了,我们用一个数组来转换匹配
```cpp
#include <iostream>
#include <string.h>
#include <string>
#include <stack>
#include<cstdio>
using namespace std;
char s[202],b[202],tj[9]= {'>','}',']',')','0','(','[','}','<'};
int n,fh[250];
//tj,用来匹配的数组,fh,符号,用来替换的数组 
void judge() {
	stack<int> st;
	int i,l,j=0;
	scanf("%s",s);
	l=strlen(s);
	fh['(']=-1;fh[')']=1;fh['[']=-2;fh[']']=2;fh['{']=-3;fh['}']=3;fh['<']=-4;fh['>']=4;
	for (i=0; i<l; i++) {
		char c=s[i];
		if(fh[c]<0) st.push(i);//左括号入栈
		else {
			if(!st.empty()){
				int k=st.top();	
				if(fh[s[k]]+fh[c]==0)b[i]=b[k]=1,st.pop();//左右括号匹配
			}
		}
	}
	for(int i=0; i<l; i++)
		if(b[i])cout<<s[i];
		else{
			int k=fh[s[i]];
			if(k<0)cout<<s[i]<<tj[4+k];
			else cout<<tj[4+k]<<s[i];
		}
}
int main() {
	judge();
}
```

---

## 作者：G_A_TS (赞：1)

初学数组时考的。。。~~懂了吗~~  
循环万岁！选择结构万岁！  
初学者放心使用吧，知识点相当有限，~~超纲不存在的~~  
略显冗长的代码（瞎暴力可能会长，但确实能过）：  
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[300],b[300],tm[300];
int gsa=1,gsb,zkg,zk1g,zk2g,zk[300],zk1[300],zk2[300],bj[300]; 
int main()
{
	//freopen("kuohao.txt","r",stdin);
    while(scanf("%c", &a[gsa]))
    {
        if(a[gsa] == '\0')
        {
            break;
        }
        if(a[gsa]=='(')
        {
        	zk1[gsa]=1;
        	zk[gsa]=1;
        	zk1g++;
        }
        if(a[gsa]=='[')
        {
        	zk2[gsa]=1;
        	zk[gsa]=1;
        	zk2g++;
        }
        gsa++;
    }
    gsa--;
    for(int i=1;i<=201;i++)
    {
    	for(int j=i-1;j>=1;j--)
    	{
    		if(a[i]==')'&&a[j]=='['&&bj[j]==0)
    		{
    			break;
    		}
    		if(a[i]==']'&&a[j]=='('&&bj[j]==0)
    		{
    			break;
    		}
    		if(a[i]==')'&&a[j]=='('&&bj[j]!=1)
    		{		   			
    			bj[i]=1;
    			bj[j]=1;
				break;
    		}
    		if(a[i]==']'&&a[j]=='['&&bj[j]!=1)
    		{		   			
    			bj[i]=1;
    			bj[j]=1;
				break;
    		}
    	}
    }
    for(int i=1;i<=gsa;i++)
    {
    	b[gsb]=a[i];
    	if(bj[i]==0&&a[i]=='(')
    	{
    		gsb++;
    		b[gsb]=')';
    	}
    	if(bj[i]==0&&a[i]=='[')
    	{
    		gsb++;
    		b[gsb]=']';
    	}
    	if(bj[i]==0&&a[i]==')')
    	{
    		gsb++;
    		b[gsb]=a[i];
    		b[gsb-1]='(';
    	}
    	if(bj[i]==0&&a[i]==']')
    	{
    		gsb++;
    		b[gsb]=a[i];
    		b[gsb-1]='[';
    	}
    	gsb++;
    }
    for(int i=0;i<=gsb-1;i++)
    {
    	if(b[i]=='('||b[i]==')'||b[i]=='['||b[i]==']')
    		cout<<b[i];
    }
}
```

---

## 作者：littlefrog (赞：1)

## 题目描述
定义如下规则序列(字符串)：

1. 空序列是规则序列；
2. 如果 $S$ 是规则序列，那么 $(S)$ 和 $[S]$ 也是规则序列；
3. 如果 $A$ 和 $B$ 都是规则序列，那么 $AB$ 也是规则序列。

例如，下面的字符串都是规则序列：

`()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`

而以下几个则不是：

`(`，`[`，`]`，`)(`，`())`，`([()`

现在，给你一些由`(`，`)`，`[`，`]`构成的序列，你要做的，是补全该括号序列，即扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。

## 样例数据
输入
```
([()
```
输出
```
()[]()
```

## 思路
每一个括号有以下四种可能：
- `(` 左括号直接加入匹配栈
- `)` 右括号如果是左括号的匹配括号（`()()`） 就将右括号和左括号一起匹配，否则（`))`）将其加入匹配栈
- `[` 左括号直接加入匹配栈
- `]`右括号如果是左括号的匹配括号（`[][]`） 就将右括号和左括号一起匹配，否则（`]]`）将其加入匹配栈

剩下的括号匹配栈里的内容我们直接将其加入到一个待匹配数组之中，然后将其排序并按照原括号输出。

## 代码
题不难，但是坑多，下面简单说下在实现过程当中遇到的坑：
1. 括号匹配栈有可能空着：例如：`]]]]]]]]]]]]]]`解决过程：判定`s.empty()`在执行循环
（参考代码 line 16~line 49）
2. 注意此时`s.empty()` 的时候也是要进入匹配的（参考代码 line 32~34 , 45~47）
3. 需要排序一遍然后输出（参考代码 line 60）
4. 即使这样也不能立刻欢乐的输出并`return 0` ，当时我们的已匹配括号不是自动忽略了吗？现在要补回来(参考代码 line 77 ~ line 79)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10001;
typedef pair <int, char > as;
stack <as > s;
int main() {
	std::string ss;
	cin >> ss;

	int a = 0;
	int sslen = ss.length();

	int dd[10001];
	memset(dd, 0, sizeof(dd));
	
	for (int i = 0; i < sslen; ++i) {
		// 先扫一遍，找到没有匹配的括号，塞进 dd 里面。
		if (ss[i] == '(' || ss[i] == '[') {
			// 把左括号塞进匹配栈里面 
			s.push(make_pair(i, ss[i]));
		} else if (ss[i] == ']'){
			// 此处用来判定右括号 ']' 是“待匹配括号” 还是 “已匹配括号” 
			// 此处坑点 1 ： s 有可能是空栈 
			if (!s.empty()) {
				as tmp = s.top();
				if (tmp.second == '[') {
					// 已经匹配到了，就不管了
					s.pop();
				} else {
					dd[a++] = i;
				}
			} else {
				dd[a++] = i;
			}
		} else {
			if (!s.empty()) {
				as tmp = s.top();
			//	cout << endl << "pause:" <<tmp.second << endl; 
				// 已经匹配到了，就不管了
				if (tmp.second == '(') {
					s.pop();
				} else {
					dd[a++] = i;
				}
			} else {
				dd[a++] = i;
			}
		}
	}
	// 把所有 "括号匹配栈" 中的元素位置全塞进 dd 里面
	// 之后 s 就可以废弃了 
	
	while (!s.empty()) {
		as tmp = s.top();
		dd[a++] = tmp.first;
		s.pop();
	}
	
	// 此处坑点 2 ：  按顺序匹配括号 
	sort(dd, dd + a);

	// 此处逐一进行括号匹配
	// 在这里使用 cur 作为当前待匹配括号在 dd 中的位置 
	// dd[cur] 为当前待匹配括号位置 

	int cur = 0;
	for (int i = 0; i < sslen; ++i) {
		if (cur < a && dd[cur] == i) {
			cur++;

			// 根据源括号类型输出匹配括号
			if (ss[i] == '(' || ss[i] == ')') {
				cout << "()";
			} else {
				cout << "[]";
			} 
		} else {
			cout << ss[i]; // 其他字符照样输出即可 
		}
	}
}
```


---

## 作者：gjwhhhh (赞：1)



```
#include<iostream>
#include<stdio.h>
#include<stack>
#include<string.h>
using namespace std;

    char a[105],in[105]; //in数组用来记录插入的括号
    int v[105],top = 0;	//v数组用来记录栈顶元素的在原数组的下标
    /*
    有了这个v数组就可以访问栈顶元素所对应的在原数组的下标，然后将下标带入in数组，可以得到在这个位置是否插入了括号
    */
int main()
{
    stack <char> s;
    int len,k = 0,i;

    scanf("%s",a);
    len = strlen(a);
    for(i=0; i<len; ++i){
    /*
    若遇前括号就入栈，并在其后插入后括号
    若后面扫描到有对应的后括号就把插入的括号删去
    */
        if(a[i]=='('){	
            s.push('(');  
            in[i] = ')';	
            v[++top] = i;	
        }
        else if(a[i]=='['){
            s.push('[');
            in[i] = ']';
            v[++top] = i;
        }
        else if(a[i]==')'){
        /*
        若后括号没有与之对应的前括号（栈顶没有对应的前括号）
        就把以当前下标为标志，插入前括号
        否则，弹出栈顶，再把插入的前括号删除（已经有对应的了）
        */
            if(s.empty()||s.top()!='('){ //考虑栈空
                in[i] = '(';	
            }
            else if(s.top()=='('){
                s.pop();
                in[v[top--]]= ' ';
            }

        }
        else if(a[i]==']'){
            if(s.empty()||s.top()!='['){
                in[i] = '[';
            }
            else if(s.top()=='['){
                s.pop();
                in[v[top--]] = ' ';
            }

        }
    }

    for(i=0; i<len; ++i){
        if(in[i]=='('||in[i]=='[') printf("%c",in[i]);
        printf("%c",a[i]);
        if(in[i]==')'||in[i]==']') printf("%c",in[i]);
    }
    return 0;
}

```

求赞

---

## 作者：_蒟蒻—信含_ (赞：1)

### ~~这题好像是luogu夏令营中的一个例题……~~
## 好啦，第五篇题解
初看此题，我~~惊了~~   这题是绿题？？？？？

不慌，先来波代码压压惊

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<ctime>
#include<cstring>
#include<string>
#include<stack>
#include<queue>
#include<algorithm>
#include<iomanip>
using namespace std;
char kh[111],sx[111],x;
int bj=0,hh,qzzkh=0;
int main()
{
	while(cin>>x)
	{
		kh[++bj]=x;
		x=0;
	 }
	hh=bj;
	for(int i=1;i<=bj;i++)
	{
		if(kh[i]=='('||kh[i]=='[')
		{
			hh++;
			qzzkh++;//前置左括号
		}
		if(kh[i]==')'||kh[i]==']')
		{
			if(kh[i]==')'&&kh[i-1]=='('||kh[i]==']'&&kh[i-1]=='[')
			{
				sx[(qzzkh-1)*2+1]=kh[i-1];
				sx[qzzkh*2]=kh[i];
				kh[i]=kh[i+2];
				kh[i-1]=kh[i+1];
			 }
		}
	}//防抄水印
	for(int i=1;i<=hh;i++)
	{
		if(sx[i]==0)
		{
			if(sx[i-1]=='(') sx[i]=')';
			else sx[i]=']';
		}
	}
	for(int i=1;i<=hh;i++)
		cout<<sx[i];
	return 0;
}
```

# 用数组做竟然WA了！！！！！！！！！！！！！！！！
紧急去复习了一下栈……后来改成了这样(改了50多………………分钟)
```cpp
//对不起，为了反抄袭，我把头文件删了
using namespace std;
char a[210],b[210],cxk[5]= {']',')','0','(','['};//cxk用来判断括号形状
int jntm[666];//jntm用来替换括号等
int main()//防抄水印
{
	int n;
    stack<int> st;
    int afg,j=0;
    scanf("%s",s);
    afg=strlen(s);
    jntm['(']=-1;jntm[')']=1;jntm['[']=-2;jntm[']']=2;
    for (int i=0; i<afg; i++) 
	{
        char c=s[i];
        if(jntm[c]<0) st.push(i);//防抄水印
        else 
		{
            if(!st.empty())
			{
                int k=st.top(); 
                if(jntm[s[k]]+jntm[c]==0)b[i]=b[k]=1,st.pop();
            }
        }//防抄水印
    }
    for(int i=0;i<afg;i++)
        if(b[i])cout<<s[i];//防抄水印
        else
		{
            int k=jntm[s[i]];
            if(k<0)cout<<s[i]<<tj[4+k];
            else cout<<tj[4+k]<<s[i];
        }//防抄水印
}//信含原创防抄水印
```
呵呵，才得15分……

翻了一下~~资尿~~  oh,不，不要误会，是资料，改成了AC代码

#### （依然有防抄水印）

```cpp
//对不起，为了反抄袭，我把头文件删了
using namespace std;
char a[210],b[210],cxk[9]={'>','}',']',')','0','(','[','}','<'};//只不过增加了几个判断
int jntm[250];
int main()
{
	int n;
	stack<int> st;//防抄水印
    int afg,j=0;
    scanf("%s",a);
    afg=strlen(a);
    jntm['(']=-1;jntm[')']=1;jntm['[']=-2;jntm[']']=2;jntm['{']=-3;jntm['}']=3;jntm['<']=-4;jntm['>']=4;//防抄水印
    for (int i=0; i<afg; i++)
	{
        char c=a[i];
        if(jntm[c]<0) st.push(i);
        else //防抄水印
		{
            if(!st.empty())
			{
                int k=st.top();//防抄水印 
                if(jntm[a[k]]+jntm[c]==0)b[i]=b[k]=1,st.pop();
            }
        }
    }
    for(int i=0; i<afg; i++)//防抄水印
        if(b[i])cout<<a[i];
        else
		{
            int k=jntm[a[i]];
            if(k<0)cout<<a[i]<<cxk[4+k];
            else cout<<cxk[4+k]<<a[i];//防抄水印
    	}
}//信含原创，防抄水印
```
如果看不懂的话，就请私聊我吧！

我的第一个AC绿题呀！

---

## 作者：Na2PtCl6 (赞：1)

感谢 @anyway 与 TA 的题解和思路，下面我提供在这种思路下的 STL 做法以及详解。
## 分析题目
这道题也许算是[P1739](https://www.luogu.com.cn/problem/P1739)的加强版吧，与那题不同的是，我们需要把不匹配的括号也匹配上并输出。

如果括号是已经是匹配好的，那我们就不管；如果需要匹配，就把它的另一边存到`out[i]`。

输出时要注意顺序，如果`out[i]`是左括号就要先输出，再输出原括号串中的括号；如果是右括号，就在原括号串中的括号后输出

## 代码
```cpp
#include<stack>
#include<cstdio>
#include<cstring>
using namespace std;
char str[104],out[104];
stack < short > s;//因为是存下标的，所以用short足够了 
int main(){
	scanf("%s",str);
	int n=strlen(str);
	for(int i=0;i<n;i++){
		char ch=str[i];
		if(ch=='('||ch=='['){
			//记录下标，方便后面的匹配 
			s.push(i); 
			//找到与之对应的 
			out[i]=ch=='('?')':']';
		}
		if(ch==')'||ch==']'){
			//需要左括号来匹配 
			if(s.empty()||ch!=out[s.top()])
				out[i]=ch==')'?'(':'[';
			else{
				//放上一个不可能匹配的值，即清空 
				out[s.top()]='#';//也可写作out[s.top()]=0
				s.pop();
			}
		}
	}
	//如上述的方式输出 
	for(int i=0;i<n;i++){
		char ch=out[i];
		if(ch=='('||ch=='[')
			putchar(ch);
		putchar(str[i]);
		if(ch==']'||ch==')')
			putchar(ch);
	}
	return 0;
}
```

---

## 作者：king_xbz (赞：0)

这道题乍一看跟[P1739 表达式括号匹配](https://www.luogu.com.cn/problem/P1739)有点像，没做过得可以去看看那道题。

总体来说，这道题可以算是P1739那道题的plus版，思路也比较相近，都可以写一个栈利用其先进后出的特性来完成。

由于这道题需要判断完后再补全，所以我们要先扫一遍字符串处理左括号，再扫一遍补全括号序列。在这一进出栈的过程中，我们可以用STL中的map来映射字符。

需要用到的STL及判断数组
```cpp
bool flag[h];
stack <int>q;
map <char,int>mp;
mp['(']=-1;mp[')']=1;
mp['[']=-2;mp[']']=2;
```
用栈处理左括号，并根据映射判断，做标记，方便一会输出。
```cpp
for(fint i=0;i<len;i++)
{
	if(mp[a[i]]<0)
	q.push(i);
	if(!q.empty())
	{
	int tops=q.top();
	if(mp[a[tops]]+mp[a[i]]==0)
	{
	flag[i]=1;
	flag[tops]=1;
	q.pop(); 	
	}
	}
}
```
按步骤处理字符并输出或补全
```cpp
for(fint i=0;i<len;i++)
		if(flag[i])
		cout<<a[i];//打了标记就输出
		else
		{
		if(mp[a[i]]==-1)
		cout<<a[i]<<')';
		else
		if(mp[a[i]]==-2)
		cout<<a[i]<<']';
		else
		if(mp[a[i]]==1)
		cout<<'('<<a[i];
		else
		if(mp[a[i]]==2)
		cout<<'['<<a[i];	
		}//否则就补全
```
到这里就结束了，祝大家新年快乐！！！

---

## 作者：Wrong_Time_Limit (赞：0)

# STL大法好
看到这个题，第一反应不是**栈**么？妥妥的**数据结构(stack)题**啊！

题意各位大佬也说了，也不累述了

直接边输入边算：

1.如果输入是 “ [ ” 或 “ ( ” 直接塞入栈中，同时，题目只要求是输出平衡括号序列，没有要求 用来 把序列补成平衡序列的括号 的输出顺序，所以直接加入输出序列。


2.如果输入是 “ ]” 或 “ ) ” 就需要判断一下（圆括号方括号要分开判断）
	
    1）如果左括号栈为空，就先在输出序列中加入一个左括号，然后再加入右括号。
    
    2）如果栈中有左括号但不能与此右括号匹配 如：[ 与 ) ,( 与 ] ，则也在输出序列中补全。
    
    3）可以与栈中括号匹配，则把左括号弹出栈，右括号加入输出。（注意，左括号已经入输出序列，不要再次加入。
    
    
然后，就是~~喜闻乐见~~的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
stack<char>in;
queue<char>out;//不喜欢数组统计，队列不香吗
void work()
{
	char s=getchar();
	while(s!='('&&s!=')'&&s!='['&&s!=']') s=getchar();
	//getchar()容易读入一些换行什么的东西，最好要提前判断
	while(s=='('||s==')'||s=='['||s==']')
	{
		if(s=='('||s=='[')//左括号直接加入输出，进栈
		{
			in.push(s);
			out.push(s);
		} 
		else if(in.empty()||((in.top()=='('&&s==']')||(in.top()=='['&&s==')')))
		{
			//如果栈空或栈顶不与刚输入的匹配
	   		//如左圆括号与右方括号
			out.push((s==')')?'(':'[');
			out.push(s);
		}
		else//可以匹配，直接加入输出，弹栈
		{
			out.push(s);
			in.pop();
		}
		s=getchar();
	}
	return;
}
void ans()//输出
{
	while(!out.empty())
	{
		cout<<out.front();
		out.pop();
	}
	while(!in.empty())
	{
		if(in.top()=='(') cout<<')';
		else cout<<']';
		in.pop();
	}
	return;
}
int main()//简单的main
{
	work();
	ans();
	return 0;
}
```


---


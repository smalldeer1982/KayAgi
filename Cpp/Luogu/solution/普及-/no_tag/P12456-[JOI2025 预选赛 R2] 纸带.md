# [JOI2025 预选赛 R2] 纸带

## 题目描述

JOI 君正在用纸和遮蔽胶带涂色，很有趣。

纸张呈矩形，有 $H$ 行 $W$ 列。位于第 $i$ 行（$1 \leq i\leq  H $）第 $j$ 列（$1 \leq  j \leq  W$）的正方形称为正方形 $(i,j)$。

每个方块都被分配了一种颜色。颜色用整数表示，最初所有方块的颜色都是 $0$。

JOI 君将使用纸和遮蔽胶带进行 $Q$ 次操作。根据整数 $q_k$ 的值， 第 $k$ 次（$1 \leq k \leq  Q$）操作如下。

- 当 $q_k = 1$ 时，该运算用整数 $x_k , y_k , c_k$ 表示。对于每个方块 $(x_k,y_k) , (x_k+1,y_k),( x_k , y_k + 1) , ( x_k + 1, y_k + 1)$，如果该方块没有被遮蔽胶带覆盖，则将该方块的颜色更改为 $c_k$。如果某个方块被遮蔽胶带覆盖，则不要对该方块进行任何处理。
- 当 $q_k = 2$ 时，该运算用整数 $x_k , y_k$ 表示。用遮蔽胶带覆盖方块 $(x_k , y_k ) , ( x_k + 1, y_k ) , ( x_k , y_k + 1) , ( x_k + 1, y_k + 1)$。
$Q$ 次操作完成后，所有遮蔽胶带均被撕掉。此外，当你从正方形上撕下遮蔽胶带时，该正方形的颜色将与被遮蔽胶带覆盖之前的颜色相同。

给定有关 $Q$ 次操作的信息，编写一个程序来找出纸上所有方块的最终颜色。

## 说明/提示

### 数据范围

对于 $100\%$ 的数据，$2\leq H,W\leq 500$，$1\leq Q\leq 200 000$。$q_k$ 为 $1$ 或 $2(1 \leq k \leq  Q)$。$1\leq x_k\leq  H- 1,1 \leq y_k \leq W - 1,1\leq c_k \leq 10^9$。

子任务：

1. （32 分）$H = 2，W = 2，q_k = 1$
2. （32 分）$q_k=1$
3. （36 分）无其他限制。


## 样例 #1

### 输入

```
5 5 4
1 2 2 1
2 1 2
2 3 3
1 1 3 5```

### 输出

```
0 0 0 5 0
0 1 1 5 0
0 1 1 0 0
0 0 0 0 0
0 0 0 0 0```

## 样例 #2

### 输入

```
5 5 3
1 1 1 2
1 3 3 3
1 2 4 2```

### 输出

```
2 2 0 0 0
2 2 0 2 2
0 0 3 2 2
0 0 3 3 0
0 0 0 0 0```

## 样例 #3

### 输入

```
10 10 10
2 5 7
2 5 6
1 5 6 1
1 9 2 1
2 1 1
1 2 4 2
2 3 2
1 2 2 3
1 9 9 2
1 8 8 1```

### 输出

```
0 0 0 0 0 0 0 0 0 0
0 0 3 2 2 0 0 0 0 0
0 0 0 2 2 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0
0 1 1 0 0 0 0 1 1 2
0 1 1 0 0 0 0 0 2 2```

# 题解

## 作者：Camellia_Spoil (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P12456?contestId=245601)
# 分析
简单模拟题。

在实现时将 $q_k$ 为 $1$ 时和 $q_k$ 为 $2$ 时别对应操作模拟即可。

$1.$ $$q_k = 1$$，将用于标记颜色的 $a$ 数组按题意修改即可。注意在修改前要判断该点是否被遮蔽

$2.$ $$q_k =2$$，将题意描述的要被遮蔽的点挨个将其记录为被遮蔽即可。

# AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define N 510
using namespace std;
inline long long read()
{
	long  long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int a[N][N],n,m,q,vis[N][N];
signed main(){
    n=read();m=read();q=read();
    while(q--)
    {
        int op,x,y,c;
        op=read();
        if(op==1)
        {
            x=read();y=read();c=read();
            if(vis[x][y]!=-1) a[x][y]=c;
            if(vis[x+1][y]!=-1) a[x+1][y]=c;
            if(vis[x][y+1]!=-1) a[x][y+1]=c;
            if(vis[x+1][y+1]!=-1) a[x+1][y+1]=c;
        }
        else
        {
            x=read();y=read();
            vis[x][y]=vis[x+1][y]=vis[x][y+1]=vis[x+1][y+1]=-1;
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            printf("%lld ",a[i][j]);
        }
        printf("\n");
    }
	return 0;
}


```

---

## 作者：Clare613 (赞：2)

~~所有人都在疯抢 P1000 和 P1001，那我就写这道题的吧。~~
## 思路
纯模拟。定义两个数组，分别为 $a$ 和 $f$。前者用于存储颜色，后者用于判断是否有遮蔽胶。\
对于两种操作，我们可以这样处理：
- $q_k = 1$ 时：
我们要把 $(x_k,y_k) , (x_k+1,y_k),( x_k , y_k + 1) , ( x_k + 1, y_k + 1)$ 这四个点的 $f$ 数组先判断有没有遮蔽胶，再来涂色。
- $q_k = 2$ 时：
我们要把 $(x_k,y_k) , (x_k+1,y_k),( x_k , y_k + 1) , ( x_k + 1, y_k + 1)$ 这四个点的 $f$ 数组直接赋值为 $1$ 即可，即表示当前点有遮蔽胶。

最后把 $a$ 数组输出即可。
## code:
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#define MOD 1000000007
#define int long long
using namespace std;
int a[505][505];
bool f[505][505];
signed main(){
	int n,m,q;
	cin>>n>>m>>q;
	for(int i=1;i<=q;i++){
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1){
			int c;
			cin>>c;
			if(f[x][y]!=1) a[x][y]=c;
			if(f[x+1][y]!=1) a[x+1][y]=c;
			if(f[x][y+1]!=1) a[x][y+1]=c;
			if(f[x+1][y+1]!=1) a[x+1][y+1]=c;
		}
		else{
			f[x][y]=1;
			f[x+1][y]=1;
			f[x][y+1]=1;
			f[x+1][y+1]=1;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<a[i][j]<<" \n"[j==m];
		}
	}
	return 0;
}
```

---

## 作者：sbh2012 (赞：2)

## 思路
很明显的一道模拟题，我们用一个数组来记录这个方块是否被遮蔽胶带覆盖，另一个数组记录方块的颜色。接下来直接模拟就可以了。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int co[1005][1005];//颜色
bool f[1005][1005];//0为没有被覆盖，1为被覆盖
int h,w,q;
int main(){
	cin>>h>>w>>q;
	for(int i=1;i<=q;i++){
		int op,x,y,c;
		cin>>op>>x>>y;
		if(op==1){
			cin>>c;
			if(f[x][y]==0){//是否被遮蔽胶带覆盖
                co[x][y]=c;
            }
			if(f[x+1][y]==0){
                co[x+1][y]=c;
            }
			if(f[x][y+1]==0){
                co[x][y+1]=c;
            }
			if(f[x+1][y+1]==0){
                co[x+1][y+1]=c;
            } 
		}else{
			f[x][y]=f[x+1][y]=f[x][y+1]=f[x+1][y+1]=true;//遮蔽胶带覆盖
		}
	}
	for(int i=1;i<=h;i++){
		for(int j=1;j<=w;j++){
            cout<<co[i][j]<<" ";
        }
		cout<<endl;
	}
	return 0; 
}

```

---

## 作者：xw_qwq (赞：2)

## P12456 [JOI2025 预选赛 R2] 纸带

[题目传送门](https://www.luogu.com.cn/problem/P12456)

简单好玩的模拟题 ouo。

### 题目思路

我们可以设置两个数组 $col$ 和 $vis$，一个用来记录此时纸张每个小方格的颜色，一个用来记录这个小方块有没有被胶带覆盖。其中 $vis$ 数组初始均为 0，表示没有被胶带覆盖；$col$ 数组初始也均为 0，表示没有被涂色。

对于操作一，给出了 $x$，$y$ 和 $c$。先判断这个方块是否被胶带覆盖，即 $vis_{x,y}$ 是否被标记。若没有，将这个方块涂色为 $c$，即 $col_{x,y} = c$，对于其他三个方块也一样，先判断后涂色。

对于操作二，给出了 $x$ 和 $y$。由我们的定义可知，此操作相当于给 $vis_{x,y}$ 做标记，即 $vis_{x,y} = 1$，对于其他三个方块也一样，做标记。

### code

```cpp
#include <bits/stdc++.h>
using namespace std;
int vis[505][505];
int col[505][505];
int main()
{
	int h, w, q;
	cin >> h >> w >> q;
	while (q--)
	{
		int op;
		cin >> op;
		if (op == 1)
		{
			int x, y, c;
			cin >> x >> y >> c;
			if (!vis[x][y])
				col[x][y] = c;
			if (!vis[x + 1][y])
				col[x + 1][y] = c;
			if (!vis[x][y + 1])
				col[x][y + 1] = c;
			if (!vis[x + 1][y + 1])
				col[x + 1][y + 1] = c;
		}
		else
		{
			int x, y;
			cin >> x >> y;
			vis[x][y] = vis[x + 1][y] = vis[x][y + 1] = vis[x + 1][y + 1] = true;
		}
	}
	for (int i = 1; i <= h; i++)
		for (int j = 1; j <= w; j++)
			cout << col[i][j] << (j == w ? "\n" : " ");
	return 0;
}
```

---

## 作者：aizhoukai (赞：0)

# 题意

进行 $q$ 次操作，对于 $q_k=1$ 的操作，你需要将以 $(x_k,y_k)$ 为起始点的边长为 $2$ 的正方形中没有被遮蔽胶带覆盖的格子染成 $c_k$,对于 $q_k=2$ 的操作，你需要将以 $(x_k,y_k)$ 为起始点的边长为 $2$ 的正方形中的所有格子贴上遮蔽胶带

# 实现

直接模拟即可，我们可以维护两个二维数组，分别表示每个点的颜色和有没有被胶带覆盖

**代码如下**


```cpp
#include<bits/stdc++.h>
using namespace std;
int color[514][514],h,w,b[514][514],q,fx[5]= {0,1,0,1},fy[5]= {0,0,1,1};//方向数组 
int main()
{
	cin>>h>>w>>q;
	while(q--)
	{
		int x,y,c,o;
		cin>>o;
		if(o==1)
		{
			cin>>x>>y>>c;
			for(int i=0; i<=4; i++)
			{
				if(!b[x+fx[i]][y+fy[i]]) color[x+fx[i]][y+fy[i]]=c;
			}
		}
		if(o==2)
		{
			cin>>x>>y;
			for(int i=0; i<=3; i++)
			{
				b[x+fx[i]][y+fy[i]]=1;
			}
		}
	}
	for(int i=1; i<=h; i++)
	{
		for(int j=1; j<=w; j++)
			cout<<color[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}

```

---

## 作者：aaa1145141919810 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P12456)

简要题意：每次操作修改 $(x_k,y_k)$，$(x_k,y_k+1)$，$(x_k+1,y)$，$(x_k+1,y_k+1)$ 的值为给定值，或将（修改位置同上）的数值锁定，不能再修改。

观察数据范围，发现 $Q\leq 2\times 10^5$，试着模拟题意交了一发，结果……竟然过了？！

考虑使用一个 bool 数组来表示一个位置的数值是否被锁定，用一个 int 数组表示对应位置的颜色，修改时判断要修改的位置是否锁定，锁定格子时将对应格子的 bool 数组值改为 true 就能愉快 AC 啦

3，2，1，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 505;
int h, w, q, col[N][N];
bool vis[N][N];

int main()
{
    scanf("%d%d%d", &h, &w, &q);

    while(q--)
    {
        int opt, x, y, c;
        scanf("%d%d%d", &opt, &x, &y);
        if(opt == 1)
        {
            scanf("%d", &c);
            if(!vis[x][y])col[x][y] = c;
            if(!vis[x+1][y])col[x+1][y] = c;
            if(!vis[x][y+1])col[x][y+1] = c;
            if(!vis[x+1][y+1])col[x+1][y+1] = c;
        }
        else
        {
            vis[x][y] = vis[x+1][y] = vis[x][y+1] = vis[x+1][y+1] = true;
        }
    }

    for(int i = 1; i <= h; i++)
        for(int j = 1; j <= w; j++)
                printf("%d%c", col[i][j], j==w?'\n':' ');
    
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P12456)
## 题目分析
希望审核大大给过。

这是一道模拟题，我们可以分别判断 $q_k$ 是否为 $1$ 或 $2$，下面进行分类讨论。
- 当 $q_k$ 为 $1$ 时，我们可以使用一个标记数组来判断这个位置有没有被贴纸贴上，如果没有，就为**没有贴上贴纸的地方上色**。
- 当 $q_k$ 为 $2$ 时，将所有题目上要贴贴纸的地方进行**标记**，如此当 $q_k$ 为 $1$ 时程序变会跳过这个位置。

思路明朗了，下面便是题目代码。
## 题目[代码](https://www.luogu.com.cn/record/216618478)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define uint long long
#define speed ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
int n,m,k;
bool f[501][501];//标记是否被贴上胶带
int x[501][501];//每个位置的颜色
signed main(){
	speed;
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++){
		int h;
		cin>>h;
		if(h==1){ //当h为1时
			int a,b,c;
			cin>>a>>b>>c;
			if(!f[a][b])x[a][b]=c;
			if(!f[a+1][b])x[a+1][b]=c;
			if(!f[a][b+1])x[a][b+1]=c;
			if(!f[a+1][b+1])x[a+1][b+1]=c; //为没有贴上贴纸的地方上色
		}
		else{ //按情况分类
			int a,b;
			cin>>a>>b;
			f[a][b]=1,f[a+1][b]=1,f[a][b+1]=1,f[a+1][b+1]=1;//封上贴纸
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)cout<<x[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12456)

## 题目大意：

初始有一个 $H$ 行 $W$ 列的表格，上面写的都是 $0$，执行两种操作：

1. 涂色，如果格子不是保护状态，就在题目所述的格子上涂相应颜色。
2. 保护，把题目所述格子设置为保护状态。

输出最后的表格。

## 思路：

签到题，模拟即可，用一个 ```int m[1005][1005]``` 记录答案，```bool f[1005][1005]``` 记录为保护状态，每次操作时暴力修改就可以了。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int m[1005][1005];
bool f[1005][1005];
long long x,y,z;
int main(){
	cin>>x>>y>>z;
	for(int i=1;i<=z;i++){
		int op,a,b,c;
		cin>>op>>a>>b;
		if(op==1){
			cin>>c;
			if(f[a][b]==false) m[a][b]=c;
			if(f[a+1][b]==false) m[a+1][b]=c;
			if(f[a][b+1]==false) m[a][b+1]=c;
			if(f[a+1][b+1]==false) m[a+1][b+1]=c;
		}
		else{
			f[a][b]=true;
			f[a+1][b]=true;
			f[a][b+1]=true;
			f[a+1][b+1]=true;
		}
	}
	for(int i=1;i<=x;i++){
		for(int j=1;j<=y;j++) cout<<m[i][j]<<" ";
		cout<<endl;
	}
	return 0; 
}

```

---

## 作者：CCY20130127 (赞：0)

## 题目大意：
[纸带](https://www.luogu.com.cn/problem/P12456)

上方为题目传送门，请自行查看。

## 题目思路：
本题考察模拟和数组的运用。

我们需要维护两个二维数组：定义 $ans$ 数组为每个方块当前的颜色。定义 $f$ 数组为每个方块是否被遮蔽胶带覆盖，被遮蔽胶带覆盖的值为 $1$，没有被遮蔽胶带覆盖的值为 $0$。

当 $q_k=1$ 时，对于给定的四个方块，检查它们是否未被遮蔽。如果未被遮蔽，则更新颜色，否则不要对该方块进行任何处理。

当 $q_k=2$ 时，将给定的四个方块标记为被遮蔽状态。

## 正解：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,k;
bool f[505][505]={0};
int ans[505][505];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	memset(f,0,sizeof(f));
	memset(ans,0,sizeof(ans));
	while(k--){
		int op;
		cin>>op;
		if(op==1){
			int x,y,c;
			cin>>x>>y>>c;
			if(!f[x][y]) ans[x][y]=c;
			if(x+1<=n&&!f[x+1][y]) ans[x+1][y]=c;
			if(y+1<=m&&!f[x][y+1]) ans[x][y+1]=c;
			if(x+1<=n&&y+1<=m&&!f[x+1][y+1]) ans[x+1][y+1]=c;
		}else{
			int x,y;
			cin>>x>>y;
			f[x][y]=1;
			if(x+1<=n) f[x+1][y]=1;
			if(y+1<=m) f[x][y+1]=1;
			if(x+1<=n&&y+1<=m) f[x+1][y+1]=1;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<ans[i][j]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```

---


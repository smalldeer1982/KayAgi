# 每日打卡心情好

## 题目背景

在洛谷中，打卡不只是一个简单的鼠标点击动作，通过每天在洛谷打卡，可以清晰地记录下自己在洛谷学习的足迹。通过每天打卡，来不断地暗示自己：我又在洛谷学习了一天，进而帮助自己培养恒心、耐心、细心。此外，通过打卡，还可以获取经验值奖励，经验值的多少在一定程度上反映了你在洛谷的资历和成就。通过打卡累积活跃值，渐渐升级，会让你感觉“离神犇越来越近了”。

## 题目描述

洛谷的打卡系统与其他网站的打卡系统一样，连续打卡天数越多，每次打卡获得的奖励也就越多，同时连续天数加上一天。然而，于其他网站只要一天不打卡，连续天数就要清零。与其他网站不同的是，洛谷的打卡更具有人性化，如果多天不打卡，连续天数仅仅只是减少，当遗漏天数越少，减少的天数也就越少。规则是减少 $2^{n-1}$ 天，$n$ 为连续遗漏天数。连续天数在下一次打卡时清算，打卡连续天数不会小于 $0$。也就是说，如果每隔一天打卡，那么连续天数就不会变了。

当连续天数达到以下天数时，给予不同的活跃值奖励：

$1$ 天：奖励 $1$（千里之行，始于足下）

$3$ 天：奖励 $2$（坚持 $3$ 天了，加油！）

$7$ 天：奖励 $3$（曜日轮回）

$30$ 天：奖励 $4$（月圆月缺，习惯养成）

$120$ 天：奖励 $5$（坚持四个月了！）

$365$ 天：奖励 $6$（一年四季都坚持下来了！真不容易！）

小 a $N$ 天前在洛谷注册了一个账号，虽然当时立志每天都要打卡，但发现这不太容易做到。现在知道他 $N$ 天的的打卡记录，小 a 希望得知他通过打卡，在 $N$ 天能获得多少活跃值？

## 说明/提示

第 $1$ 天：$1$ // 开始打卡！获得 $1$ 点经验，共 $1$ 点，连续 $1$ 天。

第 $2$ 天：$1$ // 获得 $1$ 点经验，共 $2$ 点，连续 $2$ 天。

第 $3$ 天：$1$ // 获得 $2$ 点经验，共 $4$ 点，连续 $3$ 天。

第 $4$ 天：$1$ // 获得 $2$ 点经验，共 $6$ 点，连续 $4$ 天

第 $5$ 天：$1$ // 获得 $2$ 点经验，共 $8$ 点，连续 $5$ 天

第 $6$ 天：$0$ // 由于要去趟火星，没有网络不得已而断签

第 $7$ 天：$0$

第 $8$ 天：$0$

第 $9$ 天：$1$ // 我回来了，可惜连续天数变成 $5-4=1$ 天了 TQT…… 获得 $1$ 点经验，共 $9$ 点，连续 $2$ 天

第 $10$ 天：$0$ // 啊，事情太多给忘了

第 $11$ 天：$1$ // 连续天数变成 $2-1=1$ 天。获得 $1$ 点经验，共 $10$ 点，连续 $2$ 天。

第 $12$ 天：$1$ // 获得 $2$ 点经验，共 $12$ 点，连续 $3$ 天。

小 a：弄个自动打卡机，怎么样？

kkksc03：这不符合洛谷的规则的！

$1\leq N\leq 10^3$。

## 样例 #1

### 输入

```
12
1
1
1
1
1
0
0
0
1
0
1
1```

### 输出

```
12```

# 题解

## 作者：zhylj (赞：110)

这题其实可以很短

就是有些地方要注意

```cpp
#include<cstdio>
#include<cmath>
int main()
{
    int n,t=0,a,d=0,m=0;   //n:有n天 t:分数  a:只是存是否打卡的  d是累计天数 m是累计未打卡天数
    scanf("%d",&n);       //输入n
    for(int i=0;i<n;i++)
    {
        scanf("%d",&a);      //输入有没有打卡
        if(a==1)
        {
            if(m>0) d-=pow(2,m-1);  //减去未打卡的天数
            if(d<0) d=0;                      //如果小于0就回到0
            t++;d++;m=0;                   //未打卡天数清0，打卡天数+1，积分+1
            if(d>=3) t++;                    //如果打开天数超过3，积分额外+1
            if(d>=7) t++;                    //如果打开天数超过7，积分额外+1
            if(d>=30) t++;                  //如果打开天数超过30，积分额外+1
            if(d>=120) t++;               //以此类推
            if(d>=365) t++;
        }else if(a==0) m++;         //如果未打卡，m++
    }
    printf("%d",t);              //输出结果
    return 0;
}
```

---

## 作者：wpy233 (赞：29)

一道很棒的模拟题。

具体思路如下面几步：

①判断有没有打卡；

如果打卡，**加上对应的经验值**，并**将未打卡的惩罚措施还原成初始化**（注意这一点很重要，坑了作者好久QAQ）

如果未打卡，**扣除相应的连续打卡天数**…………

咚咚咚！重点来啦！偶的扣除方法与楼上那几位$dalao$不太一样…………
```
扣除方法可以这样理解：
第一天扣除1；
后面每一天的扣除天数都是2^(n-2)
```
这样就$OK$啦~

②判断连续天数是不是在合法范围内（$>=0$）

这个比较简单，不过还是很坑啊2333
```
对于连续天数<0，将连续天数改成0；
对于连续天数>=0，什么也不要干......
```
③提交！

④AC！
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n;//天数
int ans;//用来存储积分
int lx;//连续天数
int yl=1;//遗漏天数
bool flag=true;//这里是判断惩罚时的标记变量（是第一次惩罚1还是第二次惩罚1）
int main()
{
	cin>>n;//输入
	int x;
	for(int i=1;i<=n;i++)
	{
		cin>>x;//输入
		if(x==1)//打卡了
		{
			lx++;//连续天数+1
			if(lx>=1)
				ans++;
			if(lx>=3)
				ans++;
			if(lx>=7)
				ans++;
			if(lx>=30)
				ans++;
			if(lx>=120)
				ans++;
			if(lx>=365)
				ans++;//判断能获得多少积分
			yl=1;
			flag=true;//惩罚机制初始化
		}
		else//没打卡
		{
			lx-=yl;//连续天数-
			if(yl==1&&flag) yl=1,flag=false;//判断，如果是第一次惩罚1天，那么第二次还是惩罚1天，标记变量更新
			else yl*=2; //对于其它的直接*2
		}
		if(lx<0)
			lx=0;//第二点所说的，判断连续天数是不是在合法区间内
	}
	cout<<ans<<endl;//输出
    return 0;
}
```
总体而言，还是不难。。。

不过这道题可能要成为历史了。。。

---

## 作者：chenziqi1006 (赞：12)

作为一个学了c++没有3个月的萌新

我发现我还是有实力的。。。

毕竟洛谷还是会让我们通过的

下面介绍一种非常简单的代码

//开始啦

```cpp
#include <bits/stdc++.h>
//通用源代码
using namespace std;
//新手一定要加上
int main(){
//主要部分
	int lx=0,xjy=0,n,a[10000],flx=0;
    //lx连续  xjy统计输出  n输入  a[10000]每一次输入
    //flx 非连续
	cin>>n;
    //输入
	for(int i=0;i<n;i++){
		cin>>a[i];   
	}
    //用for循环输入每一天的打卡
	for(int i=0;i<n;i++){//主程序，循环打卡不打卡情况
		if(a[i]==1){
        //如果打卡了
			if(flx>0){
            //如果之前有不打卡的情况
				lx=lx-pow(2,flx-1);
                //减去天数—我用的是pow函数
				if(lx<0){
                //减完如果出现连续天数少于0的情况
					lx=0;
				}
			}
			lx++;
            //连续天数加1
			flx=0;
            //因为打卡了，所以非连续天数为0
            //下面开始加积分！
			if(lx>=365){
				xjy=xjy+6;
			}
			if(lx<365&&lx>=120){
				xjy=xjy+5;
			}
			if(lx<120&&lx>=30){
				xjy=xjy+4;
			}
			if(lx<30&&lx>=7){
				xjy=xjy+3;
			}
			if(lx<7&&lx>=3){
				xjy=xjy+2;
			}
			if(lx<3){
				xjy=xjy+1;
			}
            //加完了
		}
        //打卡程序完毕
		if(a[i]==0){
        //如果不打卡
			flx++;
            //非连续天数加1
		}
	}
    //主程序结束
	cout<<xjy;//输出积分
	return 0;
    //结束程序
}
```
新手代码，大佬勿喷

大家可以关注我，chenziqi19

下次见


---

## 作者：cff_0102 (赞：8)

思路：模拟。用变量 $n$ 记录下当前显示的连续天数，$c$ 记录下当前连续不打卡的天数，$ans$ 记录下最终的答案。

输入新的一天的打卡状态时，如果这天没有打卡，就将 $c$ 自增 $1$ 即可；如果这天打了卡，则需要先将 $n$ 减去连续不打卡的惩罚 $2^{c-1}$，将 $c$ 清零（现在连续不打卡的天数为 $0$）并将 $n$ 自增 $1$（今天打了卡），然后再计算今天增加的积分数。

如何快速计算出 $2^{c-1}$ 呢？正常来讲有三种方法：`pow(2,c-1)`，`1<<c-1` 和暴力计算。不过需要注意的是，在后两种方法中，$2^{c-1}$ 本身可能爆 `int`（甚至 `long long`）。因此，需要先将 $c-1$ 与一个数取 $\min$ 再进行计算，下面代码中选取的是 $25$。

另外注意 $n$ 在减去 $2^{c-1}$ 后可能变成负数，要和 $0$ 取 $\max$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int s;cin>>s;
	int n=0,c=0;
	int ans=0; 
	bool a;
	while(s--){
		cin>>a;
		if(a){
			if(c)n=max(0,n-(1<<min(c-1,25)));
			c=0,n++;
			if(n>=1)ans++;
			if(n>=3)ans++;
			if(n>=7)ans++;
			if(n>=30)ans++;
			if(n>=120)ans++;
			if(n>=365)ans++;
		}else{
			c++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：梦里调音 (赞：6)

来补篇题解。

其实不是很难，纯**模拟**即可。

要调用的函数：

	pow(底数，指数)
    
嗯，就这个。

注意加经验的时候逐个判断即可，只需ans++。

代码里也有注释，希望能帮到各位OIer。

```
#include <bits/stdc++.h>
using namespace std;
//连续没签到的天数      现在连续签到的天数     总经验 
int fail=-1,                 now=0,              ans; 
int n;
bool a;//n、a如题意 
int main(){
	cin>>n;//输入
	while(n--){
		cin>>a;//输入
		if(a==0){//没打卡 
			fail++;
			continue;
		}
		else{//打卡了 
			if(fail>=0){//和上一次签到有间隔了 
				now-=pow(2,fail);//减连续签到天数 
				fail=-1;//初始化 
			}
			if(now<0)now=0;
			now++;
			ans++;//至少加上1点经验 
			if(now>=3)ans++;//按照连续签到天数加上不同经验 
			if(now>=7)ans++;
			if(now>=30)ans++;
			if(now>=120)ans++;
			if(now>=365)ans++;
		}
	}
	cout<<ans<<endl;//输出
	return 0;
}
```


---

## 作者：zhaowangji (赞：5)

考虑的应该有好几点，不过都应该容易想到

代码附上，详见注释：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,x,p,k,ans,t;
//k记录中断天数，p记录连续天数
//ans就是活跃值，t是判断变量
//x记录输入的0/1
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(x==0)k++;//中断天数++
		if(x==1)//当该天打卡时
		{
		if(k!=0)//之前有中断天数时 
		{
			p-=pow(2,k-1);//由题意得
			k=0;//记得归零！！！
		}
		if(p<0)p=0;//还原P
		p++;//连续天数++
		if(p<3&&p>0)ans+=1;
		if(p>=3&&p<7)ans+=2;
		if(p>=7&&p<30)ans+=3;
		if(p>=30&&p<120)ans+=4;
		if(p>=120&&p<365)ans+=5;
		if(p>365)ans+=6;
    //各自的活跃值奖励
		 } 
	}
	cout<<ans;
    //漂亮输出
	return 0;
}
```

---

## 作者：dormantbs (赞：5)

~~心血来潮水一发python题解~~  
这就是一道很普通的模拟题,但是用来练手还是挺好的,  
~~正好最近在学python~~  
然后有一个细节就是可以注意到 $n\leq1000$ ,  
那么显然连续不打卡十天就绝对会把之前所有的连续签到清空,  
因此我们可以直接预处理 $2^1$ 到 $2^{10}$ 遇到更大的天数直接清零就好。  
~~我才不会说是我不会用python写幂函数呢~~

```Python
a = []
n = int(input())
for i in range(0,n):
    a.append(int(input()))
res = 0
tot = 0
fog = 0
def get_score():
    if(tot >= 365):
        return 6
    elif(tot >= 120):
        return 5
    elif(tot >= 30):
        return 4
    elif(tot >= 7):
        return 3
    elif(tot >= 3):
        return 2
    else:
        return 1
mi = [1]
for i in range(1,11):
    mi.append(mi[i-1] * 2)
for x in a:
    if(x == 1):
        if (fog > 10):
            tot = 0
            fog = 0
        if (fog != 0):
            tot = max(0,tot - mi[fog - 1]);
            fog = 0
        tot = tot + 1
        res = res + get_score()
    else:
        fog = fog + 1
print(res)
```

---

## 作者：SLYZ_0120 (赞：4)

蒟蒻的第一篇博客隆重登场……然而并不隆重，依旧是老样子的水一篇题解，还是一道比较简单的红题，日常练手（划掉)。


---------------超级可爱的分割线------------------

**首先进行简单的分析我们需要干些什么，就是根据每一次对于打卡状态进行分析，统计，根据题目的要求进行计算，刷新答案，最后输出就可以了。**


如果是打了卡，也就是输入“1”的时候，我们需要做的就是更新两个天数以及答案。

连续天数的更新：

**1、判断有没有连续不打卡的天数，然后用现有的天数减去pow（2，不打卡天数-1），如果天数小于0了，变为0**

**2、把天数+1**


答案的更新：

**加上连续天数对应的奖励活跃就可以了

这里有一个小小的偷懒秘籍：为了不写那么多的if语句，可以先开一个b数组存放当连续i天打卡奖励的活跃b[i]**

下面是这个偷懒的神奇代码

```cpp
for(int i = 1;i<=2;i++)b[i] = 1;
    for(int i = 3;i<=6;i++)b[i] = 2;
    for(int i = 7;i<=29;i++)b[i] = 3;
    for(int i = 30;i<=119;i++)b[i] = 4;
    for(int i = 120;i<=364;i++)b[i] = 5;
    for(int i = 365;i<=1000;i++)b[i] = 6;
```
介于天数n很小只有1000所以我们可以开足够达到数组打表


不打卡天数的更新：

**变成0**


如果没有打卡，也就是输入“0”的时候……

**把不打卡天数+1**


######以上就是所以的思路啦

-------------------------------------


接着放代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int a[1001];
int lx = 0;
int yl = 0;
int ans = 0;
int b[1001];
int main(){
    int n;
    for(int i = 1;i<=2;i++)b[i] = 1;
    for(int i = 3;i<=6;i++)b[i] = 2;
    for(int i = 7;i<=29;i++)b[i] = 3;
    for(int i = 30;i<=119;i++)b[i] = 4;
    for(int i = 120;i<=364;i++)b[i] = 5;
    for(int i = 365;i<=1000;i++)b[i] = 6;
    scanf("%d",&n);
    for(int i = 1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i] == 1){
            if(yl != 0){
            lx -= pow(2,yl-1); 
            if(lx < 0) lx = 0;
            yl = 0;
        }
            lx += 1;
            ans += b[lx];
        //    printf("%d %d %d\n",lx,b[lx],ans);
        }
        else {
            yl ++;
        }
    }
    printf("%d",ans);
    return 0;
}
```
注释就不写啦，毕竟代码比较简单


---

## 作者：fl_334 (赞：1)

**代码笨重，敬请见谅，但通俗易懂**

```cpp
var
        n,i,j,k,l,m,ans,data,w,bb:longint;
        sum:array[0..50]of qword;      //打个2的幂次方的表
        jf:array[0..365]of longint;           //记录题中连续积分
begin
        readln(n);
        jf[0]:=0;
        jf[1]:=1;jf[2]:=1;
        for i:=3 to 6 do
                jf[i]:=2;
        for i:=7 to 29 do
                jf[i]:=3;
        for i:=30 to 119 do
                jf[i]:=4;
        for i:=120 to 364 do
                jf[i]:=5;
        jf[365]:=6;        //处理jf
        sum[0]:=1;
        for i:=1 to 50 do
                sum[i]:=sum[i-1]*2;          //预处理sum
        ans:=0;
        bb:=0;      //bb为遗漏天数
        for i:=1 to n do
        begin
                readln(data);
                if data=1 then
                begin
                        if bb>0 then
                        begin
                                if ans>=sum[bb-1] then ans:=ans-sum[bb-1]         //记住要判>
                                else ans:=0;
                        end;
                        inc(ans);
                        if ans<=365 then w:=w+jf[ans] else w:=w+6;          //w为最终值
                        bb:=0;      //记得把遗漏天数清0
                end
                else inc(bb);
        end;
        write(w);
end.
此题虽为模拟题，但细节颇多，需注意
```

---

## 作者：Xsy123456 (赞：1)

###题目比较水...简单模拟即可

```cpp
#include <cstdio>
#include <cmath>
using namespace std;

int n;
int t1=0,w=0;//计数器：t1为连续天数，w为经验值
double m=0;//m为连续未打卡天数
int a[1000+5];

int main(){
    
    scanf ("%d",&n);
    
    for (int i=1;i<=n;i++)
      scanf ("%d",&a[i]);
    for (int i=1;i<=n;i++){
        if (a[i]==1){
            m=0;//计数器归零，连续未签到中断
            t1++;
            if (t1<3)//按签到天数加分
              w++;
            if (t1>=3&&t1<7)
              w+=2;
            if (t1>=7&&t1<30)
              w+=3;
            if (t1>=30&&t1<120)
              w+=4;
            if (t1>=120&&t1<365)
              w+=5;
            if (t1>=365)
              w+=6;     
        }
        else{
            m++;//计算为连续签到天数
            if (a[i+1]==1)//下一天签了就总结天数了
              t1-=pow(2,m-1);
            if (t1<0)
              t1=0;
        }
    }
    printf ("%d",w);
     
}
```

---

## 作者：Zhoulijie (赞：1)

虽然有大佬是用打表做的考场上你有那么多时间一道道打表吗？，但是还是发一个正常的方法吧。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int main(){
    int n,a,day=0,unday=0,point=0,sum=0;//point是当前每天要加的活跃值，sum是活跃值总和
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a;
        if(a==1)//如果当天打了卡
        {
            if(unday>0){//如果在这天之前有连续没打卡天数
                day-=pow(2,unday-1);//如上
                if(day<0) day=0;//处理负数情况
            }
            unday=0;//连续没打卡天数清零
            day++;//连续打卡天数累加
            if(day>=1&&day<3) point=1;
            if(day>=3&&day<7) point=2;
            if(day>=7&&day<30) point=3;
            if(day>=30&&day<120) point=4;
            if(day>=120&&day<365) point=5;
            if(day>=365) point=6;
            sum+=point;//累计活跃值总和
        }
        else unday++;//如果当天没打卡，连续没打卡天数累加
    }
    cout<<sum;//输出总和
    return 0;//结束程序
}
```
这样的话，我们就可以看到不同日期范围的积分加成了。

但是，这道题不能用switch做，因为
```cpp
switch()的用法是：
int n;
cin>>n;
switch(n){
	case 1:
	case 2:
	case 3:{
		cout<<"1,2,3\n";
		break;//这句必须写！！！
	}
	default:cout<<"else\n";
}
所以可以看到，switch不能用来比较大小。
}
```
AC了
[![]( https://i.loli.net/2019/10/05/Z2uOPFRpXBCrasH.png)]( https://i.loli.net/2019/10/05/Z2uOPFRpXBCrasH.png)

---

## 作者：THMITW (赞：0)

这道题在我看来稍稍有点表述不清（60分的同学尤应该引起注意）

在连续3天并且忘签3天的情况下，此时重新签到那么连续签到天数是0天还是1天，据题意理解应该是1天，但题目中表述连续天数不会小于0天，意味着可以等于0天，这就很迷了。所以据我推测，这是题目中表述不严谨的一个地方，由于每次连续天数都是在打卡时更新，那么其实是连续天数不会小于1天。

为方便大家理思路，小白献上代码（勿喷）
```
#include <stdio.h>
#include <math.h>
#define DAY_OF_YEAR 365
#define AWARD_RANK_1 1
#define AWARD_RANK_2 3
#define AWARD_RANK_3 7
#define AWARD_RANK_4 30
#define AWARD_RANK_5 120
#define AWARD_RANK_6 365
int main() {
    int award[DAY_OF_YEAR + 1];
    int i;
    // initial
    award[0] = 0;
    for (i = AWARD_RANK_1; i < AWARD_RANK_2; i++)
        award[i] = 1;
    for (i = AWARD_RANK_2; i < AWARD_RANK_3; i++)
        award[i] = 2;
    for (i = AWARD_RANK_3; i < AWARD_RANK_4; i++)
        award[i] = 3;
    for (i = AWARD_RANK_4; i < AWARD_RANK_5; i++)
        award[i] = 4;
    for (i = AWARD_RANK_5; i < AWARD_RANK_6; i++)
        award[i] = 5;
    award[AWARD_RANK_6] = 6;
    // code
    int n, t, con_Y = 0, con_N = 0, ans = 0;
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &t);
        if (t == 1) {
            if (con_N > 0)
                con_Y -= pow(2, con_N - 1);
            if (con_Y < 0)
                con_Y = 0;
            con_Y++;
            con_N = 0;
            ans += award[con_Y];
        } else {
            con_N++;
        }
    }
    printf("%d", ans);
    return 0;
}
```


---

## 作者：tmp27 (赞：0)

这道题是一道$if$判断语句题。~~（废话）~~             
根据题目模拟就行了。         
大家不要被读题误导，奖励$n$不是经验加$n$点！     
然后给大家看一下代码:              
上代码！
```
#include<iostream>//头文件
#include<cmath>//pow必须的头文件
using namespace std;//空间命名
int n,cnt,sum,no=-1;//定义cnt是所有经验，sum是连续打开的次数，no是没打开的次数。
bool a; //a是读入的数
int main()
{
	cin>>n;//读入
	for(int i=1;i<=n;i++)
	{
		cin>>a;//读入
		if(a==false){//没打卡
			no++;//次数加加
			continue;//跳到
		}
		if(no>=0)
		{
			sum-=pow(2,no);//符合题意
			no=-1;//初始化不能为0
		}
		if(sum<0) sum=0;//以免负数
		sum++;
		cnt++;//加加
		if(sum>=3) cnt++;
		if(sum>=7) cnt++;
		if(sum>=30) cnt++;
		if(sum>=120) cnt++;
		if(sum>=365) cnt++;//累计
	}
	cout<<cnt<<endl;//输出
	return 0;
}

```
看了代码是不是感觉心情很好！     
求通过！

---

## 作者：Sinwind (赞：0)

思路：

1. 读取总的打开天数N，动态分配内存（最后记得释放动态分配的内存），将N个int型分配给record，数组record读取每天的打卡记录。

2. 遍历数组record，进行模拟。
- 若record[i]为0，即漏打卡，漏打卡的天数miss++，因为是漏打卡，所以不计算积分，continue跳过本次循环；
- 若record[i]为1，即打卡，连续打卡的天数day++；
	- 若有漏打卡的，连续打卡的天数day减少2 ^(miss - 1)天；
    - 连续打卡的天数day有可能小于0，day=1确保连续打卡的天数day最小为1；
    - 最后漏打卡的天数miss清零。
- 根据连续打卡天数day计算积分。day的取值分为6个区间：
	- [1,3)，score++；
    - [3,7)，score+=2；
    - [7,30)，score+=3；
    - [30,120)，score+=4；
    - [120,365)，score+=5；
    - [365,+∞)，score+=6。


3. 打印最终的总积分score，并释放动态分配的内存。


```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(void)
{
	int N;		//总的打卡天数
	int* record;	//每天打卡的记录
	int day = 0;	//连续打卡的天数
	int miss = 0;	//漏打卡的天数
	int score = 0;	//总的积分
	
	scanf("%d", &N);
	//动态分配内存
	record = (int*)malloc(sizeof(int) * N);
	for (int i = 0; i < N; i++)
	{
		scanf("%d", &record[i]);
	}
	for (int i = 0; i < N; i++)
	{
		//漏打卡
		if (record[i] == 0)
		{
        		miss++;
			//漏打卡时不计算积分
			continue;
		}
		//打卡
		else
		{
			day++;
			if (miss > 0)
			{
				day -= (int)pow(2, miss - 1);
				if (day < 1)
				{
					day = 1;
				}
				//漏打卡天数清零
				miss = 0;
			}
		}
		
		//根据连续打卡天数，计算积分
		if (day >= 1 && day < 3)
		{
			score++;
		}
		else if (day >= 3 && day < 7)
		{
			score += 2;
		}
		else if (day >= 7 && day < 30)
		{
			score += 3;
		}
		else if (day >= 30 && day < 120)
		{
			score += 4;
		}
		else if (day >= 120 && day < 365)
		{
			score += 5;
		}
		else if(day > 365)
		{
			score += 6;
		}
	}

	printf("%d\n", score);

	//释放动态分配的内存
	free(record);

	return 0;
}
```


---


# [TJOI2011] 序列

## 题目描述

一数列 $A=\{a_1,a_2,\ldots,a_n\}$，根据数列 $A$ 计算数列 $B=\{b_1,b_2,\ldots,b_n\}$，其中：  

$$
b_i=
\begin{cases}
a_1 &, i=1 \\ 
\min_{1 \leq j < i}\left|a_i-a_j\right| &, i\gt 1 
\end{cases}
$$

求 $\sum\limits^n_{i=1}b_i$。

## 说明/提示

$1\le t\le 10$，$1\le n\le10^5$，$0\le a_i\le65536$。

## 样例 #1

### 输入

```
2
5 1 2 3 4 5
7 2 9 7 4 6 2 6
```

### 输出

```
5
14
```

# 题解

## 作者：小马一只 (赞：17)

#看数据范围！

#看数据范围！

#看数据范围！

### 重要的事情说三遍



# 0<= ai<=65 536

这意味着，我们只需开一个bool数组储存对应数字是否已经出现过，然后从当前数字开始向左、向右遍历（注意要遍历自己）就可以找到最近已经出现过的的数字aj。最后num[now]=true即可。


所以，这题普及-，代码很短，那就直接上代码吧。



```cpp
#include<cstdio>
#include<cstring>
bool hav[65537];
int main()
{
    int n,t,i,ans,tmp;
    scanf("%d",&t);
    while(t--){
        memset(hav,false,sizeof(hav));
        scanf("%d%d",&n,&tmp);
        hav[tmp]=true;
        ans=tmp;
        while(--n){
            scanf("%d",&tmp);
            for(i=0;;i++){
                if(tmp-i>=0)
                    if(hav[tmp-i]){
                        ans+=i;
                        break;
                    }
                if(tmp+i<=65536)
                    if(hav[tmp+i]){
                        ans+=i;
                        break;
                    }
            }
            hav[tmp]=true;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：s_r_f (赞：7)

本题我们发现，数据范围为ai ≤ 65536

即log(ai) ≤ 16

于是我们在求bi时可以用一个带二分的树状数组。

复杂度O(T * n * log(n) * log(n)).

代码：
```
#include <bits/stdc++.h>
#define LL long long
#define N 100050
#define lowbit(x) (x & (-x))
#define q(x) (x + 70000)
using namespace std;

const int m = 65536 * 4;

inline int read(){
    int x = 0,f = 1; char c = getchar();
    while ((c < '0' || c > '9') && c != EOF) {if (c == '-') f = -1;c = getchar();}
    while ((c <='9' && c >='0') && c != EOF) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}

inline void write(LL x){
    LL k = 0,lx = x;char put[40];
    if (lx ==0) putchar('0');
    if (lx < 0) putchar('-'),lx = -lx;
    while (lx)  put[++k] = (lx % 10) + '0',lx /= 10;
    while (k)   putchar( put[ k-- ] );
}

int T,n,a[N],b[N],l,r,mid,ans,ToT; 
int d[m];

void Insert(int x){
    while (x <= m) ++d[x],x += lowbit(x);
}

int Ask(int x){
    int tot = 0; 
    while (x) tot += d[x],x -= lowbit(x);
    return tot;
}

int query(int l,int r){
    return Ask(r) - Ask(l-1);
}

int main(){
    T = read();
    while (T--){
        memset(d,0,sizeof(d));
        ToT = 0; 
        n = read();
        for (int i = 1; i <= n; ++i) a[i] = read();
        b[1] = a[1];
        ToT += b[1];
        Insert( q(a[1]) );
        for (int i = 2; i <= n; ++i){
            l = 0,r = 65536;
            while (l <= r){
                mid = (l + r) >> 1;
                if (query( q(a[i] - mid) , q(a[i] + mid) )) ans = mid,r = mid - 1;
                else l = mid + 1;
            }
            b[i] = ans;
            ToT += ans;
            Insert( q(a[i]) );
        }
        write(ToT);
        putchar('\n');
    }
    return 0;
}

```

---

## 作者：huangwenlong (赞：4)

这是一道平衡树裸题，这里我用了Treap来写。


（这道题跟HNOI2002的营业额统计不是一模一样的做法吗）


每次我们处理一个数之前先找一下之前的那堆数里**小于等于这个数且最大的数**，和**大于等于这个数且最小的数**，比较一下这两个东西和这个数的差值哪个更小，统计进答案，然后插入树里。


但是，但是！！！这道题的数据范围小的可怜！！！所以其实像楼下那样乱搞也能过。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
namespace treap
{
const int inf = 0x3f3f3f3f;
struct node *nil;
struct node
{
    node *ch[2];
    int val, cnt, size, prio;
    node(int v) : val(v), cnt(1), size(1), prio(rand()) { ch[0] = ch[1] = nil; }
    void pullup() { size = cnt + ch[0]->size + ch[1]->size; }
    int cmp(int v) { return v < val ? 0 : 1; }
} * root;
void init()
{
    nil = new node(0);
    nil->cnt = nil->size = 0;
    nil->prio = inf;
    nil->ch[0] = nil->ch[1] = root = nil;
}
void rotate(node *&t, int d)
{
    node *k = t->ch[d ^ 1];
    t->ch[d ^ 1] = k->ch[d];
    k->ch[d] = t;
    t->pullup(), k->pullup();
    t = k;
}
void insert(int v, node *&t = root)
{
    if (t == nil)
        t = new node(v);
    else if (t->val == v)
        t->cnt++;
    else
    {
        int d = t->cmp(v);
        insert(v, t->ch[d]);
        if (t->prio > t->ch[d]->prio)
            rotate(t, d ^ 1);
    }
    t->pullup();
}
int lower(int v, node *t = root)
{
    int ans = -inf;
    while (t != nil)
    {
        if (t->val <= v)
            ans = max(ans, t->val), t = t->ch[1];
        else
            t = t->ch[0];
    }
    return ans;
}
int upper(int v, node *t = root)
{
    int ans = inf;
    while (t != nil)
    {
        if (t->val >= v)
            ans = min(ans, t->val), t = t->ch[0];
        else
            t = t->ch[1];
    }
    return ans;
}
}
int main()
{
    ios::sync_with_stdio(false);
    int T;
    cin >> T;
    while (T--)
    {
        treap::init(); // 反正内存多，不管之前申请的了
        int n, x;
        cin >> n;
        long long ans = 0;
        
        cin >> x;
        treap::insert(x);
        ans += x;
        n--;
        
        while (n--)
        {
            cin >> x;
            ans += min(x - treap::lower(x), treap::upper(x) - x);
            treap::insert(x);
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：一只小H (赞：3)

## 题意简述

一串数字，输出每个数字和前面与它最接近的数字的差之和。

输入：

* 共有 $t$ 组数据。
* 每行一个正整数 $n$，然后是 $n$ 个数字 $a_i \ldots a_n$。

输出：

* 所有 $b_i$ 的和。
* $b_i$ 为 $a_i$ 与之前某个数之差的绝对值的最小值。
* 注意 $b_1=a_1$。

## 题目分析

不难想到暴力查找的做法，但我们发现在计算 $b_i$ 时需要消耗大量时间，所以需要进行优化。

二分查找可以节省很多时间，但前面的值不满足单调性，所以我们要使这些数满足单调性，可以存入```priority queue```或```set```，但优先队列不好实现二分查找，而且这题可以忽略重复的数字，所以选用```set```。

要注意对第一个数字进行特判，还要注意不要超出```set```范围。

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
int n;
int ans;
int input;
set<int> s;
int main()
{
    cin >> t;
    while (t--)
    {
        /*初始化*/
        s.clear();
        ans = 0;

        cin >> n;

        /*由于只和前面的数字有关，所以可以在输入时就处理*/
        for (int i = 1; i <= n; ++i)
        {
            cin >> input;
            if (i == 1) //特判第一个数
            {
                s.insert(input);
                ans += input;
                continue;
            }
            set<int>::iterator tmp = s.lower_bound(input); //找到第一个大于等于当前数字的数
            /*
            如果tmp刚好等于当前数，那么tmp一定是最优的。
            如果tmp大于了当前数，那么tmp后面的一定比tmp差
            */
            if (tmp == s.end()) //当前的数字比之前的都大，没得选只能选最后一个
            {
                ans += abs(input - *(--tmp));
            }
            else if (tmp == s.begin()) //当前的数字比之前的都小，没得选只能选第一个
            {
                ans += abs(input - *(tmp));
            }
            else //选择tmp或tmp前一个
            {
                ans += min(abs(input - *(--tmp)), abs(input - *(tmp)));
            }
            s.insert(input); //将当前数字放入set
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：Acc_Robin (赞：3)

这道题要求我们在每次插入一个元素之后，求出与这个元素差最小的那个元素.

看见大家都手写是平衡树，我不得不说

> STL牛逼！

用set直接水过去辣！


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int n,a[N],ans=0,T;
multiset<int>s1;
int main(){
    cin>>T;
    while(T--){
        cin>>n;ans=0;s1.clear();
        for(int i=1;i<=n;i++)cin>>a[i];
        for(int i=1;i<=n;i++){
            multiset<int>::iterator it=s1.lower_bound(a[i]);
            multiset<int>::iterator it2=it;
            if(it!=s1.begin())it--;
            ans+=min(abs(a[i]-*it),abs(a[i]-*it2));
            s1.insert(a[i]);
        }
        cout<<ans<<endl;
    }
}

```

（其实那个$a$数组没必要开）

---

## 作者：lizbaka (赞：3)

平衡树可破此题，比较适合各位数据结构大师放松身心

扫描$A$序列时，每次遇到一个新的元素$A_i$，首先在平衡树中寻找与$A_i$最接近的元素，再将差值加到答案中，然后把$A_i$插入到平衡树中即可。

时间复杂度$O(tn\log n)$，注意清空平衡树

前面已经有用Treap解决的题解，补一个splay代码

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <cstring>
using namespace std;
typedef long long ll;

const int maxn=100005;

struct Csplay
{
	int root,tot,num;
	int siz[maxn],cnt[maxn],val[maxn],ch[maxn][2],prt[maxn];
	int chk(int x)
	{
		return ch[prt[x]][1]==x;
	}
	void update(int x)
	{
		siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+cnt[x];
	}
	void rotate(int x)
	{
		int y=prt[x],z=prt[y],k=chk(x),w=ch[x][k^1];
		ch[y][k]=w;prt[w]=y;
		ch[z][chk(y)]=x;prt[x]=z;
		ch[x][k^1]=y;prt[y]=x;
		update(y);update(x);
	}
	void splay(int x,int goal=0)
	{
		while(prt[x]!=goal)
		{
			int y=prt[x],z=prt[y];
			if(z!=goal)
			{
				if(chk(x)==chk(y))
					rotate(y);
				else
					rotate(x);
			}
			rotate(x);
		}
		if(goal==0)
			root=x;
	}
	void Insert(int x)
	{
		++tot;
		int cur=root,p=0;
		while(cur && x!=val[cur])
			p=cur,cur=ch[cur][x>val[cur]];
		if(cur)
			++cnt[cur];
		else
		{
			cur=++num;
			val[cur]=x;
			prt[cur]=p;
			ch[cur][0]=ch[cur][1]=0;
			if(p)ch[p][x>val[p]]=cur;
			siz[cur]=cnt[cur]=1;
		}
		splay(cur);
	}
	void find(int x)
	{
		int cur=root;
		while(x!=val[cur] && ch[cur][x>val[cur]])
			cur=ch[cur][x>val[cur]];
		splay(cur);
	}
	int pre(int x)
	{
		find(x);
		if(val[root]<x)return root;
		int cur=ch[root][0];
		while(ch[cur][1])
			cur=ch[cur][1];
		return cur;
	}
	int succ(int x)
	{
		find(x);
		if(val[root]>x)return root;
		int cur=ch[root][1];
		while(ch[cur][0])
			cur=ch[cur][0];
		return cur;
	}
	int Close(int x)
	{
		find(x);
		if(val[root]==x)return 0;
		return min(x-val[pre(x)],val[succ(x)]-x);
	}
	Csplay()
	{
		memset(val,0,sizeof(val));
		memset(cnt,0,sizeof(cnt));
		memset(ch,0,sizeof(ch));
		memset(prt,0,sizeof(prt));
		memset(siz,0,sizeof(siz));
		root=num=tot=0; 
		Insert(-0x3f3f3f3f);
		Insert(0x3f3f3f3f);
		tot=0;
	}
};

int T;
int n;
int ans;

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		Csplay t;
		scanf("%d%d",&n,&ans);
		t.Insert(ans);
		int x;
		for(register int i=2;i<=n;++i)
		{
			scanf("%d",&x);
			ans+=t.Close(x);
			t.Insert(x);
		}
		printf("%d\n",ans);
	}
}
```

---

## 作者：Syhien (赞：2)

>0<= ai<=65 536

大家看到了吗，这个数据小得可怜。

用一个bool表记录下哪些数字已经出现过。

每有1个a[i]待转化成b[i]，都在表中寻找距离它最近的、已经出现过的数。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
bool biao[65537];
long long a[100001],b[100001];
inline void inl(long long &p,char c=getchar())//long long读入优化
{
    while(c<'0' or c>'9')
        c=getchar();
    p=0;
    while(c>='0' and c<='9')
        p=p*10+c-'0',c=getchar();
}
inline void in(long long &p,char c=getchar())//int读入优化
{
    while(c<'0' or c>'9')
        c=getchar();
    p=0;
    while(c>='0' and c<='9')
        p=p*10+c-'0',c=getchar();
}
int main()
{
    int t;
    in(t);
    while(t--)
    {
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        memset(biao,0,sizeof(biao));
        int n;
        in(n);
        inl(a[1]);
        b[1]=a[1];
        biao[a[1]]=1;
        for(int i=2;i<=n;i++)
        {
            inl(a[i]);
            for(int l=a[i],r=a[i]+1;;)//l,r中要有一个从a[i]开始找（说不定a[i]不是第一次出现了）
            {
                if(biao[l])
                {
                    b[i]=a[i]-l;
                    break;
                }
                if(biao[r])
                {
                    b[i]=r-a[i];
                    break;
                }
                if(l>0)//防止访问非法内存
                    l--;
                if(r<65536)
                    r++;
            }
            biao[a[i]]=1;
        }
        for(int i=2;i<=n;i++)
            b[i]+=b[i-1];
        printf("%lld\n",b[n]);
    }
    return 0;
}
```
这真的很水，很适合放松身心（


---

## 作者：Minclxc (赞：1)

做过一个相似的题目，此题在线可以用线段树、树状数组、二叉搜索树做，离线做法可以用双向队列

考虑从后往前删除数字，将原数组按大小排序，每个bi其实就是两边的数字和ai的差的最小值，可以O(1)求，双向队列删除也是O(1)的

所以总共的复杂度就是排序的复杂度O(nlgn)

具体做法就是先按大小排序，然后按照时间戳从后往前枚举，O(1)维护查询和删除

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
int min(int a,int b){return a<b?a:b;}
int max(int a,int b){return a>b?a:b;}
const int N=1e5+1;
int pre[N],suc[N],bel[N];
struct node{int x,t;}a[N];
int cmp(node a,node b){return a.x<b.x;}
int main(){
    for(int t=read();t;t--){
        int n=read();a[0].x=-1e9;a[n+1].x=1e9;
        fo(i,1,n)pre[i]=i-1,suc[i]=i+1;
        fo(i,1,n)a[i]=(node){read(),i};
        int ans=a[1].x;
        sort(a+1,a+n+1,cmp);
        fo(i,1,n)bel[a[i].t]=i;
        go(i,n,2){
            int g=bel[i];
            ans+=min(a[g].x-a[pre[g]].x,a[suc[g]].x-a[g].x);
            suc[pre[g]]=suc[g];pre[suc[g]]=pre[g];
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：functionendless (赞：1)

这难度只有普及-？？？

这题就是二维的最长上升序列

解析如下








   








```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
struct dot//创建一个结构体存储每个点的信息
{
    int x;
    int y;
    int h;
};
dot line[20000];//将每个点存入该结构体数组
int height[120][120];//用于存储input
int len[120][120];//dp数组，存储每个点的最优解
int cmp(const void *a, const void *b)
{
    if((*(dot*)a).h > (*(dot*)b).h)
        return 1;
    else return -1;
}
void dp(int m, int n)
{
    //对于每个点进行上下左右的比较
    for(int i = 0; i < m*n; i++)
    {
        if(height[line[i].x][line[i].y] < height[line[i].x][line[i].y + 1] && (len[line[i].x][line[i].y]+ 1) > len[line[i].x][line[i].y + 1])
            len[line[i].x][line[i].y + 1] = len[line[i].x][line[i].y]+ 1;
        if(height[line[i].x][line[i].y] < height[line[i].x][line[i].y - 1] && (len[line[i].x][line[i].y] + 1) > len[line[i].x][line[i].y - 1])
            len[line[i].x][line[i].y - 1] = len[line[i].x][line[i].y]+ 1;
        if(height[line[i].x][line[i].y] < height[line[i].x + 1][line[i].y] && (len[line[i].x][line[i].y] + 1) > len[line[i].x + 1][line[i].y])
            len[line[i].x + 1][line[i].y] = len[line[i].x][line[i].y]+ 1;
        if(height[line[i].x][line[i].y] < height[line[i].x - 1][line[i].y] && (len[line[i].x][line[i].y] + 1) > len[line[i].x - 1][line[i].y])
            len[line[i].x - 1][line[i].y] = len[line[i].x][line[i].y]+ 1;
    }
}
int main()
{
    int m, n;
    cin >> m >> n;
    int i, j;
    int flag = -1;//计数，输入多少个点
    int max = 0;
    //input matrix
    for(i = 1; i <= m; i++)
    {
        for(j = 1; j <= n; j++)
        {
            flag++;
            scanf("%d", &height[i][j]);
            line[flag].x = i;
            line[flag].y = j;
            line[flag].h = height[i][j];
        }
    }
    //对结构体的h参数进行排序,升序
    qsort(line, m*n, sizeof(line[0]),cmp);
    dp(m, n);
    //遍历len数组，求出最大值
    for(i = 1; i <= m; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if(len[i][j] > max)
                max = len[i][j];
        }
    }
    cout << max + 1 << endl;
    system("pause");
    return 0;
}
```

---

## 作者：Tenshi (赞：1)

这题数据范围很小，自然可以用暴力的做法过掉，如果范围扩大怎么解决呢？

可以使用平衡树！

## 做法
我们从左到右扫一遍数列并更新答案 $res$，当扫到第 $i$ 个数（记它的值为 $v$）时，假设前 $i-1$ 个数已经被维护进平衡树了，那么只需要找树中哪个元素离 $v$ 最近即可：

+ 如果树中存在 $v$，那么 `res+=0`
+ 否则找 $v$ 在的前驱、后继，看看哪个离 $v$ 更近，并相应地更新 $res$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

const int N=1e5+5, INF=0x3f3f3f3f;

struct Node{
	int l, r;
	int key;
	int sz, v;
	
	#define ls tr[u].l
	#define rs tr[u].r
}tr[N];

int root, idx;

void pushup(int u){
	tr[u].sz=tr[ls].sz+tr[rs].sz+1;
}

int add(int v){
	++idx;
	tr[idx].key=rand(), tr[idx].sz=1, tr[idx].v=v;
	tr[idx].l=tr[idx].r=0;
	return idx;
}

int merge(int x, int y){
	if(!x || !y) return x+y;
	if(tr[x].key>tr[y].key){
		tr[x].r=merge(tr[x].r, y);
		pushup(x);
		return x;
	}
	else{
		tr[y].l=merge(x, tr[y].l);
		pushup(y);
		return y;
	}
}

void split(int u, int val, int &x, int &y){
	if(!u) return x=y=0, void();
	if(tr[u].v<=val)
		x=u, split(rs, val, rs, y);
	else
		y=u, split(ls, val, x, ls);
	pushup(u);
}

void insert(int v){
	int x, y;
	split(root, v, x, y);
	root=merge(x, merge(add(v), y));
}

int get_prev(int v){
	int x, y;
	split(root, v-1, x, y);
	int u=x;
	while(rs) u=rs;
	int res=u? tr[u].v: -INF; // 没有前驱就是 -INF
	root=merge(x, y);
	return res;
}

int get_next(int v){
	int x, y;
	split(root, v, x, y);
	int u=y;
	while(ls) u=ls;
	int res=u? tr[u].v: INF; // 没有后继就是 INF
	root=merge(x, y);
	return res;
}

bool has(int v){
	int x, y, z;
	split(root, v, x, z);
	split(x, v-1, x, y);
	bool res=tr[y].sz? 1: 0;
	root=merge(merge(x, y), z);
	return res;
}

void init(){
	root=idx=0;
}

signed main(){
	ios::sync_with_stdio(false);
	srand(131); // 随机数种子
	
	int T; cin>>T;
	while(T--){
		init(); // 初始化平衡树
		int n; cin>>n;
		int res=0;
		for(int i=1; i<=n; i++){
			int v; cin>>v;
			if(i==1) res+=v; // 特判
			else if(has(v)) res+=0; // 存在 v，那么贡献为 0
			else res+=min(v-get_prev(v), get_next(v)-v); // 看看前驱还是后继离 v 近。
			insert(v); // 插入 v
		}
		cout<<res<<endl;
	}
	
	return 0;
}
```

---

## 作者：Anita_Hailey (赞：0)

望管理员通过，我已经加了注释 qwq
## 序

作为一个 TJoier 准备省选的时候来刷一刷几年的省选题。

## 正文

看了一眼，我的天，这不平衡树裸题，直接搞就完了。不就是前驱 和后继里挑一个吗

然后，兴冲冲打了板子，之后，样例都没过。。是因为没有注意到假如之前的序列如果出现过了，那么我们要再加一个 `find()` 函数来检验这个数是否在原先的数列中出现，那样的话，就是0了。

然后对于其他的情况直接用找前驱和后继就行了。QAQ.码量异常的大.....

平衡树没什么好说的了。不会的人请移步至[普通平衡树](https://www.luogu.com.cn/problem/P3369)

用标准的语言说是

1. 假如 $a[i]$ 在先前的序列中出现了，那么 $ans += 0$
2. 假如没有，那么挑出他的前驱和后继，$ans += min(next-a[i],a[i]-prv )$

```c++
#define _CRT_SECURE_NO_WARNINS

#include <bits/stdc++.h>

using namespace std;
// 快读
template <typename T>
inline T read()
{
	T x = 0;
	char ch = getchar();
	bool f = 0;
	while(ch < '0' || ch > '9')
	{
		f = (ch == '-');
		ch = getchar();
	}
	while(ch <= '9' && ch >= '0')
	{
		x = (x << 1) + (x << 3) + (ch - '0');
		ch = getchar();
	}
	return  f? -x : x;
}
// 快输
template <typename T>
void put(T x)
{
	if(x < 0)
	{
		x = -x;
		putchar('-');
	}
	if(x < 10) {
		putchar(x + 48);
		return;
	}
	put(x / 10);
	putchar(x % 10 + 48);
	return ;
}
// 模板类 用的是替罪羊
template <typename name>
class ScapeGoat
{
	private:
		constexpr static const double alpha=0.75;
		struct sgtNode;
		typedef sgtNode *sgt;
		// 表示一个结点
    	struct sgtNode
		{
			sgt ls, rs;
			int size, valid;
			name data;
			bool del;
            // 是否不好
			inline bool bad()
				{ return (double) ls->size > alpha * (double) size || (double) rs->size > alpha * (double) size || valid * 3 <= size; }
			// 更新树结点
            inline void update()
				{ size = ls->size + rs->size + !del; valid = ls->valid + rs->valid + !del; }
		};
	protected:
		sgt rot = NULL,NullNode = NULL;
		// 新建这棵树
		inline sgt init(name x)
		{
			sgt tmp = new sgtNode;
			tmp->ls = tmp->rs = NullNode;
			tmp->del = 0;
			tmp->size = tmp->valid = 1;
			tmp->data = x;
			return tmp;
		}
		// 重构的过程
    	// 先统计结点
		void dfs(sgt T, vector <sgt> &ve) {
			if(T == NullNode) return ;
			dfs(T->ls ,ve);
			if(!T->del) ve.push_back(T);
			dfs(T->rs, ve);
			if(T->del) delete T;
		}
		// 重构
		sgt build(int l, int r, vector <sgt> &ve) {
			if(l > r) return NullNode;
			int mid = (l + r) >> 1;
			sgt T = ve[mid];
			T->ls = build(l, mid - 1, ve);
			T->rs = build(mid + 1, r, ve);
			T->update();
			return T;
		}
    	
		void rebuild(sgt &T) {
			vector <sgt> ve;
			dfs(T, ve);
			T = build(0, ve.size() - 1, ve);
			return ;
		}
		// 添加结点
		void insert(sgt &T, name x) {
			if(T == NullNode) {
				T = init(x);
				return;
			}
			++(T->size);
			++(T->valid);
			if(x < T->data) insert(T->ls, x);
			else insert(T->rs, x);
			if(T->bad()) rebuild(T);
			return;
		}
    	//删除，不过好像不需要qwq
		void erase(sgt &T, int rk) {
			if(T == NullNode) return;
			if(!T->del && rk == T->ls->valid + !T->del) {
				T->del = 1;
				--(T->valid);
				return;
			}
			--(T->valid);
			if(rk <= T->ls->valid + !T->del) erase(T->ls, rk);
			else erase(T->rs, rk - T->ls->valid - !T->del);
			return;
		}
		
		void makeempty(sgt &x)
		{
			if(x == NullNode) return;
			makeempty(x->ls);
			makeempty(x->rs);
			delete x;
			x = NullNode;
			return;
		}
		
		bool fin(sgt T, name x)
		{
			if(T == NullNode) return 0;
			if(T->data == x) return 1;
			if(T->data < x) return fin(T->rs, x);
			return fin(T->ls, x);
		}
	public:
		ScapeGoat()
		{
			if(NullNode == NULL)
			{
				NullNode = new sgtNode;
				NullNode->ls = NullNode->rs = NullNode;
				NullNode->size = NullNode->valid = NullNode->del = 0;
			}
			rot = NullNode;
		}
		// 得到一个排名为rk的数
		inline name get_data(int rk) {
			sgt T = rot;
			while(T != NullNode) {
				if(!T->del && !T->del + T->ls->valid == rk) { return T->data; }
				if(rk <= T->ls->valid + !T->del) T = T->ls;
				else {
					rk -= T->ls->valid + !T->del;
					T = T->rs;
				}
			}
		}
		// x 的排名
		inline int get_rank(name x) {
			int ans = 1;
			sgt T = rot;
			while(T != NullNode) {
				if(x <= T->data) { T = T->ls; }
				else { ans += T->ls->valid + !T->del; T=T->rs; }
			}
			return ans;
		}
		// 加数
		inline void insert(name x) { insert(rot, x); return ; }
		// 删数
		inline void erase(name x) { erase(rot, get_rank(x)); }
		// 查找过程
		inline bool find(name x) { return fin(rot, x); }
		// 前驱
		inline int prv(name x) { return get_data(get_rank(x) - 1); }
		//后继
		inline int next(name x) { return get_data(get_rank(x + 1)); }
		// 清空数，比较节俭
		void clear() { makeempty(rot); }
};

ScapeGoat <int> tree;

#define rd read <int> ()

int t, n;

int main()
{
#ifdef _DEBUG
	freopen("in.txt", "r", stdin);
#endif
	t = rd;
	while(t--)
	{
		n = rd;
		int tmp, ans;
		ans = tmp = rd;
		tree.insert(tmp);
        // 先加入最大值和最小值，为什么，自己分析一下
		tree.insert(1 << 28);
		tree.insert(- (1 << 28));
		for(int i = 2; i <= n; ++i)
		{
			tmp = rd;
            // 注意这个很重要
			if(tree.find(tmp)) continue;
			int a = tree.next(tmp);
			int b = tree.prv(tmp);
			ans += min(tmp - b, a - tmp);
			tree.insert(tmp);
		}
		tree.clear();
		put(ans);
		putchar('\n');
	}
	return 0;
}
```

## 嵬

今年，初三的蒟蒻要争取省队呀！！

---

## 作者：critnos (赞：0)

再发一篇基于数据范围的题解吧（就是做一些优化）

“基于数据范围”其实大致就是这样：

比如：1，2，3，4，5

一开始标记数组都为空

0，0，0，0，0

然后边读边做（第一个数单独输入，把和设为第一个数）

1. 1，0，0，0，0；和：1

后面的数先输入，然后用两个指针（初始值都为这个数）依次向两边递增（减），直到找到标记为止。然后把和增加先找到标记的指针位置于输入的数的差的绝对值。

2. 1，1，0，0，0；和：2

3. 1，1，1，0，0；和：3

4. 1，1，1，1，0；和：4

5. 1，1，1，1，1；和：5

分析优化：

首先，由于只用输出b数组的和，是不用新开一个b数组的，只用一个变量来记录和。

其次，很多dalao都用了memset。其实不用清空数组。把标记数组设为int，然后改变每一组数据的标记即可（比如第t组数据用t来标记）。

还有，越界判断也可以优化：用两个变量记录输入数据的最大值和最小值，然后判断指针是否超出范围。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[70000];//标记数组
int main() 
{
	int n,p,t,i,j,k,s,m,mn,mx;
	cin>>t;
	for(i=1;i<=t;i++)//必须从1开始，因为标记数组的初始值为0
	{
		cin>>n>>p;
		for(a[p]=i,mn=mx=s=p,j=1;j<n;j++)//特判第一个数
		{
			cin>>p,m=1e9;
			for(k=p;k>=mn&&a[k]!=i;k--);//第一次查找
			if(a[k]==i) m=p-k;//记录差的最小值
			for(k=p;k<=mx&&a[k]!=i;k++);//第二次查找
			if(a[k]==i) m=min(m,k-p);//记录差的最小值
			s+=m,a[p]=i,mx=max(mx,p),mn=min(mn,p);//记录上界和下界，标记
		}
		cout<<s<<endl;
	}
}
```


---

## 作者：ustze (赞：0)

搞一个正常又比较简单的算法

c++的stl还是很强大的，这里用到了set，具体用法[参见](http://www.cplusplus.com/reference/set/)

这个题目就是让我们求与第ai个数最接近的数，于是就可以用set乱搞了2333

时间复杂度O(nlog2n)，但set常数很大（不是一般的大），跑得很慢

code:
```cpp
    #include<iostream>
    #include<cstdio>
    #include<set>
    #include<cmath>
    using namespace std;
    int t,n;
    int main()
    {
        scanf("%d",&t);
        int ans;set<int> s;
        int a,x;
        set<int>::iterator it;
        while(t--)
        {
            scanf("%d",&n);
            s.clear();
            scanf("%d",&a);s.insert(a);ans=a;
            for(int i=2;i<=n;i++)
            {
                scanf("%d",&a);
                it=s.lower_bound(a);
                if(it!=s.end()&&it!=s.begin()){x=abs((*it)-a);it--;x=min(x,abs(a-(*it)));}
                else if(it==s.end()) {it--;x=abs(a-(*it));}
                else x=abs((*it)-a);
                ans+=x;
                s.insert(a);
            }
            printf("%d\n",ans);
        }
        return 0;
}
```

---


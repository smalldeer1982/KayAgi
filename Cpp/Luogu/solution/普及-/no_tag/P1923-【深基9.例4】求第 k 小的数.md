# 【深基9.例4】求第 k 小的数

## 题目描述

输入 $n$（$1 \le n < 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i < {10}^9$），输出这些数字的第 $k$ 小的数。最小的数是第 $0$ 小。

请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。

## 样例 #1

### 输入

```
5 1
4 3 2 1 5
```

### 输出

```
2
```

# 题解

## 作者：zjinyi (赞：14)

# 题解：P1923 【深基9.例4】求第 k 小的数
## 题目大意
一个大小为 $n(1 \le n \le 5 \times 10^6)$ 的数组 $a$，输出数组中第 $k$ 小的数（最小的数是第 $0$ 小）。

## 分析
本题可以使用分治算法。分治，顾名思义就是“分而治之”，也就是把一个大问题分解成规模更小但本质相同的问题，再用同样的方法解决，再把小问题的解合并，就是大问题的解。

这一题，我们可以随便选择一个数，并将数组分为三部分：比它小的数，这个数本身，和比它大的数。然后再判断第 $k$ 小的数位于哪个部分，再在这个部分中继续用同样的方法查找，直到得出答案为止。平均时间复杂度可以达到 $O(n)$。

注意最小的数是第 $0$ 小，所以分治之前 $k$ 要加一。且数据范围比较大，需要用 `scanf` 和 `printf` 快速读入输出。

## 代码
可能这样说比较抽象，那就结合代码理解吧！

```cpp
#include <iostream>
#include <cstdio> // 快速读入输出头文件
#include <vector> // 动态数组头文件
using namespace std;

long long n, k; // 有自定义函数，使用全局变量
long long a[5000005];

void dfs(long long l, long long r) // 自定义函数
{
	if (l > r) // 如果 l > r
	{
		return; //  直接返回
	}
	long long num = a[l];
    // 随便选一个数，为了写代码方便就选第 1 个数
	vector <long long> minn, maxn;
    // 存储比这个数大或小的数的数组，因为大小未知，所以使用动态数组
	for (long long i = l + 1; i <= r; ++i) // 遍历这一段区间
	{
		if (a[i] < num) // 将数字存入数组
		{
			minn.push_back(a[i]);
		}
		else
		{
			maxn.push_back(a[i]);
		}
	}
	for (long long i = l; i < l + minn.size(); ++i) 
	{
		a[i] = minn[i - l];
	}
    // 改变数组中数的位置，使得数组分为三部分：比 num 小的数，num 本身，和比 num 大的数
    // 注意 for 循环的范围
	a[l + minn.size()] = num;
	for (long long i = l + minn.size() + 1; i <= r; ++i)
	{
		a[i] = maxn[i - l - minn.size() - 1];
	}
	if (k < minn.size() + 1) // 分类讨论，答案在左半边
	{ 
		dfs(l, l + minn.size() - 1); // 递归
	}
	else if (k == minn.size() + 1) // 答案正好是 num
	{
		printf("%lld", num); // 输出答案，注意使用 printf 更快
		exit(0); // 直接退出程序
	}
	else // 答案在右半边
	{ 
		k -= minn.size() + 1; // 改变 k 的值
		dfs(l + minn.size() + 1, r); // 递归
	}
}

int main()
{
	scanf("%lld %lld", &n, &k); // 输入，注意使用 scanf 更快
	for (long long i = 1; i <= n; ++i)
	{
		scanf("%lld", &a[i]);
	}
	k += 1; // 题目说最小的数是第 0 小
	dfs(1, n); // 搜索并递归
	
	return 0; // 完结撒花！！！！！
}
```

这道题还可以直接用 `sort` 排序，或者用题面提到的 `nth_element` 函数，但本题的考点是分治算法，这里就不赘述其他方法了。

:::info[你可以]
点个赞再走吧！
:::

:::warning[注意]
不要抄题解，会棕名的！
:::

---

## 作者：RyanLi (赞：9)

传送门：[P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)

更佳的阅读体验：[洛谷 P1923 题解](https://blog.ryanli.top/index.php/archives/303/)

---

**简要题意**：给定一个 $n$ 个元素的序列 $a$，最小的数是第 $0$ 小，求第 $k$ 小的数。

提供一个非正解的暴力做法。

我们直接对数组排序，然后输出 $a_k$ 即可。

由于本题数据规模较大（$n \le 5 \times 10^6$），因此需要关闭流同步才能卡过去。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 5e6 + 10;
int n, k, a[N];

int main() {
    cin.tie(nullptr);  // 这两句用于关闭流同步，但关流后不可以混用 cin / scanf
    ios::sync_with_stdio(false);
    cin >> n >> k;
    for (int i = 0; i < n; ++i) cin >> a[i];
    sort(a, a + n);
    cout << a[k] << '\n';
    return 0;
}
```

---

## 作者：sunqiwen (赞：7)

# [题目传送门](https://www.luogu.com.cn/problem/P1923)

## 题目大意

题目会输入 $n$ 个数字，需要你输出第 $k$ 小的整数。

## 方法一

我们用一个数组来存 $a_i$，在输入完后排序，直接输出 $a_k$ 即为答案。

理论上 `std::sort` 的时间复杂度为 $O(n\log n)$。

## [AC code](https://www.luogu.com.cn/record/229694967)

```cpp
#include <bits/stdc++.h>
#define maxn 5000010
using namespace std;

int n, k, a[maxn];
int main() {
	scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    sort(a, a + n);
    printf("%d\n", a[k]);
    return 0;
}

```

## 方法二

题目中告诉我们其实可以使用 `nth_element` 来写本题，其时间复杂度为 $O(n)$，优于 `std::sort`。

## [AC code](https://www.luogu.com.cn/record/229697209)

```cpp
#include <bits/stdc++.h>
#define maxn 5000010
using namespace std;

int n, k, a[maxn];
int main() {
	scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    nth_element(a, a + k, a + n);
    printf("%d\n", a[k]);
    return 0;
}
```

## 其他

如果你觉得本题解写的好的话就点个赞再走吧。

---

## 作者：SatoruXia (赞：5)

直接将原数组排序一遍后找第 $k$ 小的数也可以，但我们需要使用更高效的算法：快速选择算法（QuickSelect），这是快速排序的变种，时间复杂度为 $O(n)$。  
相信大家都还记得快速排序的实现方式：采用分治法的策略，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。  
同样地，快速选择算法也是递归查找，先选择一个基数（可以选择最右侧元素/中位数/随机选择），然后反复进行分区，将数组分为小于基准和大于基准两部分。接下来进入递归处理部分：根据 $k$ 和基数的位置关系，决定选左半边还是右半边。如果 $k$ 就是基数呢？直接输出就好了。  
这种借助快速排序的分治思想叫**快速选择算法**，成功将 $O(n \log n)$ 的复杂度优化到了 $O(n)$。  
当然，如果忽略题目中的要求的话，用 `nth_element` 也是一个可以接受的解。它是一个函数，可以找到第 $k$ 小或第 $k$ 大的元素，但不对数组进行排序。它的时间复杂度也是 $O(n)$。
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int quickSelect(vector<int>& nums, int left, int right, int k) {
    if (left == right) return nums[left];
    //选择基准值（这里简单选择最右边的元素）
    int pivot = nums[right];
    int i = left;
    //将数组分为两部分：小于基准值和大于等于基准值并选择
    for (int j = left; j < right; ++j) {
        if (nums[j] < pivot) {
            swap(nums[i], nums[j]);
            i++;
        }
    }
    swap(nums[i], nums[right]);//将基准值放到正确位置
    //现在基准值位于第i小的位置了，进行递归操作
    if (k == i) return nums[i];
    else if (k < i) return quickSelect(nums, left, i - 1, k);
    else return quickSelect(nums, i + 1, right, k);
}
int main() {
    //读入加速
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) cin >> nums[i];
    //进行快速选择
    int result = quickSelect(nums, 0, n - 1, k);
    cout << result << endl;
    return 0;
}
```

---

## 作者：__wenziyi__ (赞：5)

本题解介绍一个的实用的函数利器 `nth_element`，能够简洁且快速地通过本题。

`nth_element` 是 C++ 标准库 `<algorithm>` 中提供的一个函数，用于对容器中的元素进行部分排序，其核心功能是找到第 $k$ 个位置的元素（按排序规则），并将该元素放置到正确的位置上，同时确保该元素左侧的所有元素都不大于它（默认升序），右侧的所有元素都不小于它。

在本题中，我们可以运用 `nth_element` 将数组元素中第 $k$ 小的整数（最小的数字为第 $0$ 小）排出来并在数组中就位，随时调用，可谓十分方便。

函数原型：`void nth_element( RandomIt first, RandomIt nth, RandomIt last )`。

你可以将其近似理解为：`nth_element(数组名,数组名+第 k 小元素,数组名+元素个数)`。

具体使用方式见下面 AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    int a[n];
    for(int i=0;i<n;++i)
        scanf("%d",&a[i]);
    nth_element(a,a+k,a+n);// 在长度为 n 的数组 a 中找出第 k 小的元素并使其在数组下标为 k 的位置就位。
    printf("%d",a[k]);
    return 0;
}
```

### 总结
`nth_element` 是一种高效的部分排序工具，尤其适合处理无需完全排序但需要定位特定位置元素的问题。

---

## 作者：New_Void (赞：3)

## [P1923 【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)

### 思路

这道题十分简单，我们可以直接将数组排一下序，然后取出第 $k$ 个就可以了。

### Code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    int arr[n];
    for (int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }
    sort(arr,arr+n);
    printf("%d",arr[k]);
    return 0;
}


```

---

## 作者：Hkb150429 (赞：2)

硬着头皮从以前的题目中翻出了一段分治代码。

## 题意

输入 $n$（$1 \le n < 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i < {10}^9$），输出这些数字的第 $k$ 小的数。**最小的数是第 $0$ 小**。

## 分治简介（Merge sort）

归并排序是一种采用分治法的排序算法。它将数组分成两半，递归地对它们进行归并排序，然后合并两个有序的半部分。

## 思路

我们套模版，别忘记这是第 $k$ 小，并且最小的数是第 $0$ 小，而且 $n$ 很大，所以要快速读入。

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[5000005],b[5000005];
void m(int* a,int* b,int f,int l,int mid){
    int i=f,j=mid+1,k=f;
    while(i!=mid+1&&j!=l+1) {
    if(a[i]>a[j])
        b[k++]=a[j++];
    else
        b[k++]=a[i++];
    }
    while(i!=mid+1)
        b[k++]=a[i++];
    while(j!=l+1)
        b[k++]=a[j++];
    for(i=f;i<=l;i++)
        a[i]=b[i];
}
void m_s(int* a,int* b,int f,int l){
    int mid=(f+l)/2;
    if(f<l){
        m_s(a,b,f,mid);
        m_s(a,b,mid+1,l);
        m(a,b,f,l,mid);
    }
}
int main(){
    ios::sync_with_stdio(0);
    int m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    m_s(a,b,1,n);
    cout<<b[m+1];
    return 0;
}
```

---

## 作者：feizhu_QWQ (赞：1)

如果使用分治算法来做的话，那么严格分治的恐怕只有-归并排序了吧！！  
在学习归并之前，我们能先来了解一下分治思想。  
![](https://cdn.luogu.com.cn/upload/image_hosting/u9his697.png)\
我们生活中有一句话“大事化小，小事化了” 在程序设计中，这也同样可行。\
比如一个数组求最大值的问题，给你一个长度为 $4$ 的数组，让你求这个数组的最大值，我们可以换一种思路：\
给你 `1 5 2 6`。\
我们把 `1 5` 拿出来，再把 `2 6` 拿出来。\
`1 5` 的最大值很明显我们用 $\max$ 函数得出来是 `5`，`2 6` 是 `6`。\
我们再把两个最大值 `5 6` 比大小，得出来 `6`。\
这就是分治的典型案例，整个数组无法直接比大小，我们就把他分成小数组求，然后把小数组得来的答案往上传，和另一个小数组比较，循环往复，就得到了最终答案。


所以，我们可以尝试用分治的思想，创造另一种算法。\
同样是排序，现在给你两个有序的数组，怎么把他们融合在一起，变成一个同样有序的数组？\
这里可以用到指针，我们从左到右，如果当前第一个数组的第一个数，比第二个数组的第一个数小，就先把前者放入一个新数组里，然后把原数组里的这个数删除，这样，我们就能得到新数组了。\
我们来模拟一下这个过程：\
`1 4 5` 和 `2 3 6`。\
首先，两个数组的第一个数分别是 $1$ 和 $2$，$1$ 更小，优先加入 $1$。  
接着，两个数组的第一个数分别是 $4$ 和 $2$，$2$ 更小，优先加入 $2$。  
接着，两个数组的第一个数分别是 $4$ 和 $3$，$3$ 更小，优先加入 $3$。  
接着，两个数组的第一个数分别是 $4$ 和 $6$，$6$ 更小，优先加入 $6$。  
接着，两个数组的第一个数分别是 $5$ 和 $6$，$5$ 更小，优先加入 $5$。  
最后只剩下了 $6$，我们把 $6$，放在最后，就得到了 `1 2 3 4 5 6` 这样的一个有序数组。  
那么我们怎么得到两个有序的数组呢？\
这就是递归的事了。\
我们每次递归先直接调用函数，等着他把两个有序的数组传上来，我们再履行自己的职责，把这两个有序数组合并。\
归并排序很明显比其他排序复杂，所以他一般被用来求逆序对（我们到时候再说）。\
实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],b[1000005];
int n;
void merge_sort(int l,int r)
{
	int mid=(l+r)/2;
	int q=l,h=mid+1,cnt=0;//这里的数组是连在一起的有序数组，所以我们从中间断开
	while(q<=mid&&h<=r)
	{
		if(a[q]<=a[h])//如果第一个数小
		{
			cnt++;
			b[cnt]=a[q];
			q++;
		}
		else//第二个数小
		{
			cnt++;
			b[cnt]=a[h];
			h++;
		}
	}
	while(q<=mid)
	{
		cnt++;
		b[cnt]=a[q];
		q++;
	}
	while(h<=r)
	{
		cnt++;
		b[cnt]=a[h];
		h++;
	}
	for(int i=1,j=l;i<=cnt;i++,j++)
	{
		a[j]=b[i];
	}
	return;
}
void m_sort(int l,int r)
{
	if(l>=r) return;
	int mid=(l+r)/2;
	m_sort(l,mid);
	m_sort(mid+1,r);//先往下递归
	merge_sort(l,r);//再履行自己的职责
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	m_sort(1,n);
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
	return 0;
}
```

介绍完归并排序，我们回归正题：  
这道题让我们求第 $k$ 小的数，那我们就找排完序的数组的第 $k+1$ 个呗（因为题目有特殊要求），所以代码如下：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5000005],b[5000005];
int n;
void merge_sort(int l,int r)
{
	int mid=(l+r)/2;
	int q=l,h=mid+1,cnt=0;//这里的数组是连在一起的有序数组，所以我们从中间断开
	while(q<=mid&&h<=r)
	{
		if(a[q]<=a[h])//如果第一个数小
		{
			cnt++;
			b[cnt]=a[q];
			q++;
		}
		else//第二个数小
		{
			cnt++;
			b[cnt]=a[h];
			h++;
		}
	}
	while(q<=mid)
	{
		cnt++;
		b[cnt]=a[q];
		q++;
	}
	while(h<=r)
	{
		cnt++;
		b[cnt]=a[h];
		h++;
	}
	for(int i=1,j=l;i<=cnt;i++,j++)
	{
		a[j]=b[i];
	}
	return;
}
void m_sort(int l,int r)
{
	if(l>=r) return;
	int mid=(l+r)/2;
	m_sort(l,mid);
	m_sort(mid+1,r);//先往下递归
	merge_sort(l,r);//再履行自己的职责
	return;
}
int k;
int main()
{
    ios::sync_with_stdio(false);//注意直接写过不了，我们加一个关闭同步流
    cin.tie(0);
    cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	m_sort(1,n);
	cout<<a[k+1];
	return 0;
}
```

---

## 作者：Lovelace_qwq (赞：1)

[传送门](https://www.luogu.com.cn/problem/P1923)

## 题目大意

给出一个长度为 $n$ 的序列，输出序列中的第 $k$ 个。

## 思路

> 请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。

这启示我们可以使用 `nth_element` 函数完成此题。

`nth_element` 函数归属于 STL 库，内部原理是内省排序。当然内省排序的底层原理也是分治。

经过内省排序的数列不一定有序，但是第 $k$ 大的数一定在其应该待的位置上。

`nth_element(a.begin(),a.begin()+k,a.end(),cmp);`

这句话的意思是，从 `a.begin()` 到 `a.end()` 进行内省排序，保证 $a_k$ 是第 $k$ 个，排序规则为 `cmp`。和 `sort` 一样，`cmp` 函数在为一维数组排序时可以省略，默认从小到大排序。

警示后人，本题输入量较大，使用 `cin` 且不关闭同步流可能无法通过此题，需要更快速的输入方式。

## 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<climits>
#include<vector>
#define ll long long
#define ull unsigned long long
#define endl '\n'
#define PII pair<int,int>
#define itn int
#define brk break
#define cte continue
#define faii fa[i]=i
using namespace std;
inline int read(){
	int t=0,flag=1;
	char a=getchar();
	while(!isdigit(a)){
		if(a=='-'){
			flag=-1;
		}
		//	a=getchar_unlocked();
		a=getchar();
	}
	while(isdigit(a)){
		t=t*10+a-'0';
		//	a=getchar_unlocked();
		a=getchar();
	}
	return t*flag;
}
inline void put(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x<10){
		putchar(x+'0');
	}else{
		put(x/10);
		putchar(x%10+'0');
	}
}
int n,k;
vector<int> a;
main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		a.push_back(x);
	}
	nth_element(a.begin(),a.begin()+k,a.end());
	cout<<a[k];
	return 0;
}
//0520 蘸以清墨，书我弦歌！
//你说得对，但是今年是墨清弦出道七周年，让我们一起祝她生日快乐！
```

---

## 作者：I_AM_ACer (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/P1271)**
## 题目大意
给你 $n$ 个数，由于最小的数是第 $0$ 小，所以应当找到第 $k+1$ 小的数。
## 题目分析
将这 $n$ 个数进行 `sort` 快排在输出 $k+1$ 小的数即可。注意要加速 `cin` 和 `cout`，不然会超时间。
## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
const int N=5000005;
int a[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	cout<<a[k+1];
	return 0;
}

```

---


# 资料分发1

## 题目描述

有一些电脑，一部分电脑有双向数据线连接。如果一个电脑得到数据，它可以传送到的电脑都可以得到数据。现在，你有这个数据，问你至少将其输入几台电脑，才能使所有电脑得到数据。


## 说明/提示

对于30%的数据：n<=100,m<=1000

对于60%的数据:n<=2000,m<=100000

对于100%的数据：n<=100000, m<=200000

数据不保证没有重边，不保证没有自回环


## 样例 #1

### 输入

```
4 5
1 2
1 3
2 3
2 1
3 4```

### 输出

```
1```

# 题解

## 作者：Alex_Wei (赞：19)

### 思路：建图，dfs，记录连通块的个数

- 点数最大是100000，用二维数组空间会炸

- 看到边数只有200000，很自然地想到用不定量数组来存边

- 遍历所有的点，如果这一个点没有被访问过，连通块的个数就要+1

#### 具体思路见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector <int> p[100100];//p[n]存储点n所连接的点
int n,m,f,s,ans,pd[100100];//ans是连通块的个数，pd数组判断这个点有没有被访问过
void dfs(int x)
{
	for(int y=0;y<p[x].size();y++)//遍历所有与x相邻的边 
		if(pd[p[x][y]]==0)//如果这个点没有被访问过 
			pd[p[x][y]]=1,dfs(p[x][y]);//标记一下，访问这一个点 
}
int main()
{
	cin>>n>>m;
	for(int x=1;x<=m;x++)
		cin>>f>>s,p[f].push_back(s),p[s].push_back(f);//存边 
	for(int x=1;x<=n;x++)
		if(pd[x]==0)
			ans++,pd[x]=1,dfs(x);//连通块的个数+1，标记并访问
	cout<<ans;//输出
	return 0;
}
```
~~学好dfs很重要！~~

---

## 作者：Catalyst_M (赞：10)

这道题……裸的并查集……

把连在一起的都加入到同一个集合中，最后统计集合数。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <algorithm>
using namespace std;
int n,m,fa[100010],ans;
bool vis[100010];
inline int find(int x)     //带路径压缩的find函数，优化时间
{
    return (fa[x]==x?x:fa[x]=find(fa[x]));
}
inline void unionn(int x,int y)   //将x和y加入同一个集合
{
    int xx=find(x);
    int yy=find(y);
    if(xx!=yy) fa[xx]=yy;
    return;
}
inline int read()   //读入优化
{
    int n=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         n=n*10+ch-'0';
         ch=getchar();
     }
    return n; 
}
inline void print(int n)   //输出优化
{
    if(n>9) print(n/10);
    putchar(n%10+'0');
    return;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1,a,b;i<=m;i++)
     {
         a=read();b=read();
         unionn(a,b);
     }
    for(int i=1;i<=n;i++)    //统计集合数
     {
         int ii=find(i);
         if(vis[ii]==false) 
          {
              vis[ii]=true;
              ans++;
          }
     }
    print(ans);  //输出答案
    return 0; 
}
```

---

## 作者：zhengrunzhe (赞：8)

提供个Tarjan算法吧

问题转化为：Tarjan做缩点后，入度为0的点的个数
```cpp
#include<stack>
#include<cstdio>
#include<algorithm>
#define reg register
using namespace std;
using std::min;
const int N=100001,M=500001;
int n,m,head[N],cnt,sum,dfn[N],low[N],num[N],ans,in[N];
bool vis[N];
struct edge{int from,to,next;}e[M];
stack<int>s;
template<class T>inline void read(reg T &x)
{
	x=0;reg char ch=getchar();reg short fh=1;
	if (ch=='-')fh=-1;
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)
		x=(x<<3)+(x<<1)+ch-48,ch=getchar();
}
inline void add(reg int a,reg int b)
{
	e[++cnt].next=head[a];
	head[a]=cnt;
	e[cnt].to=b;
	e[cnt].from=a;
}
void tarjan(reg int p)
{
	low[p]=dfn[p]=++cnt;
	s.push(p);vis[p]=1;
	for (reg int i=head[p];i;i=e[i].next)
	{
		reg int j=e[i].to;
		if (!dfn[j])tarjan(j),low[p]=min(low[p],low[j]);
		else if (vis[j])low[p]=min(low[p],low[j]);
	}
	if (dfn[p]==low[p])
	{
		num[p]=++sum; //num[p]代表p所属的强连通分量的编号
		while (s.size())
		{
			reg int x=s.top();s.pop();
			vis[x]=0;num[x]=sum;
			if (p==x)break;
		}
	}
}
int main()
{
	read(n);read(m);
	for (reg int a,b,i=1;i<=m;i++)
		read(a),read(b),add(a,b),add(b,a);
	cnt=0;
	for (reg int i=1;i<=n;i++)
		if (!dfn[i])tarjan(i);
	for (reg int i=1;i<=m;i++)
		if (num[e[i].from]!=num[e[i].to]) //如果不在同个强连通分量内
			in[num[e[i].to]]++; //入度+1
	for (reg int i=1;i<=sum;i++)if (!in[i])ans++;
    printf("%d",ans);
	return 0;
}
```

---

## 作者：aiyougege (赞：6)

这个题可以用很多方法做

我介绍**三种做法**并给出**关键代码**


##第一种做法

因为这是个无向图且要求求联通块的个数

那就可以通过dfs解决

遍历每个没被访问过的点

dfs能被这个点到达的点（设为被访问）


最后dfs的次数就是答案

```cpp
int vis[N];

void dfs(int s){
    vis[s]=true;
    for(int i=head[s];i;i=e[i].nxt)
        if(!vis[e[i].v])
            dfs(e[i].v);
}

int main(){
    
    while(~scanf("%d%d",&n,&m)){
        tot=0,ans=0;
        memset(head,false,sizeof(head));
        memset(vis,false,sizeof(vis));
        for(int i=1;i<=m;++i){
            scanf("%d%d",&a,&b);
            addedge(a,b);
        }
        for(int i=1;i<=n;++i)
            if(!vis[i]){
                dfs(i);
                ans++;
            }
        printf("%d\n",ans);
    }
    return 0;
}
```
##第二种做法

可以通过**并查集**来解决

一开始答案设为点数

每在边集加入一条边就将两个点加入一个集合（如果这两个点本来不在一个集合的话）答案数减1

建议做所有的并查集题都使用**路径压缩**和**启发式合并**

会加快合并和查询的速度

```cpp
void init(){
    for(int i=1;i<=n;++i)
        fa[i]=i;
    for(int i=1;i<=n;++i)
        siz[i]=1;
}

int find(int s){
    if(fa[s]!=s)fa[s]=find(fa[s]);
    return fa[s];
}

int faa,fab;

bool un(int a,int b){
    faa=find(a);
    fab=find(b);
    if(faa>fab){
        faa^=fab; fab^=faa; faa^=fab;
    }
    if(faa!=fab)return fa[faa]=fab,siz[fab]+=siz[faa];
    return false;
}

int ans;

int main(){
    while(~scanf("%d%d",&n,&m)){
        init();ans=n; 
        for(int i=1;i<=m;++i){
            read(a),read(b);
            if(un(a,b))ans--;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
##第三种做法

Tarjan求强联通分量

不过好像并不是很有必要

虽然能做但是好像并没有什么luan用（和dfs基本一样）


---

## 作者：LinkZelda (赞：3)

1. **题意简化：** 给定一张图，求图中**连通块**的个数。

1. **思路：** 用一个并查集来维护它的连通性，然后开个变量 $ans$ 记录，每次合并两个集合就联通块个数减去一。

1. 对于并查集，~~感觉题解区的大佬们写成一堆函数不好看~~，为了好理解，就特别地用一个**结构体**来封装一下吧。

- 看代码：
```cpp
struct UnionFind{
    int bin[100005];//记录每个数所指向的数
    UnionFind()//构造函数，先初始化让每个数都指向自己
    {
        for(int i=0;i<100005;i++)bin[i]=i;
    }
    int find(int x)//找祖先
    {
        if(bin[x]==x)return x;//如果自己指向自己，就证明自己就是祖先
        return bin[x]=find(bin[x]);//路径压缩，如果自己不是祖先，就递归找
    }
    void uni(int x,int y)//连接两个集合
    {
        bin[find(x)]=find(y);//将自己的祖先指向另一个集合的祖先
    }
    bool ask(int x,int y)//询问两个点祖先是否一致
    {
        return find(x)==find(y);//如果祖先一致就返回ture，否则返回false
    }
}U;
```

4.完整思路已经在上面讲的很清楚了，本题解主要是补充题解区没有一个好康点的并查集封装的小缺点。（如果对并查集优化感兴趣，可以看一下[这个](https://blog.csdn.net/kalilili/article/details/43014623)）

---

## 作者：cyffff (赞：3)

# P2097 资料分发1
#### [_传送门_](https://www.luogu.com.cn/problem/P2097)
## 思路
这道题给出一张图（我们称之为$G$），求其中连通块数量。

我们可以用三种方法解决此题。
## 一、暴力搜索
搜索是解决连通块问题的好方法，而且这道题数据范围不大，只到$10^5$，所以搜索的效率也挺高的。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,m,u,v,ans;
bool vis[N];
vector<int>G[N];//存图
inline void dfs(int x){//搜索
	for(int i=0;i<G[x].size();i++){
		if(!vis[G[x][i]]){
			vis[G[x][i]]=true;
			dfs(G[x][i]);
		}
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d %d",&u,&v);
		G[u].push_back(v);//建立无向边
		G[v].push_back(u);
	}
	for(int i=1;i<=n;i++){//遍历
		if(!vis[i]){
			vis[i]=true;
			ans++;
			dfs(i);
		}
	}
	printf("%d",ans);
	return 0;
}
/*
143ms
8.73MB
509B
*/
```
## 二、强连通分量
这种做法是先深搜一遍求出所有点的退出顺序，再搜索一遍，每次退出就是求出了一块连通块，不过这道题不需要求出强连通分量，搜两次会比直接搜慢。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,m,u,v,ans;
bool vis[N];
vector<int>G[N];
queue<int>g;//存退出顺序
inline void dfs(int x){
	for(int i=0;i<G[x].size();i++){
		if(!vis[G[x][i]]){
			vis[G[x][i]]=true;
			dfs(G[x][i]);
			g.push(G[x][i]);
		}
	}
}
inline void f(int x){//第二次搜索
	for(int i=0;i<G[x].size();i++){
		if(!vis[G[x][i]]){
			vis[G[x][i]]=true;
			dfs(G[x][i]);
		}
	}
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d %d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			vis[i]=true;
			dfs(i);
			g.push(i);
		}
	}
	memset(vis,0,sizeof(vis));
	while(!g.empty()){
		int x=g.front();
		g.pop();
		if(!vis[x]){
			vis[x]=true;
			f(x);
			ans++;//一块强连通分量
		}
	}
	printf("%d",ans);
	return 0;
}
/*
159ms
10.34MB
825B
*/
```
## 三、并查集
并查集存入每一块，再搜一遍并查集数量即可，效率较高。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,m,u,v,ans,f[N];
bool vis[N];
inline int find(int x){//路径压缩查询代表
	if(x!=f[x]){
		f[x]=find(f[x]);
	}
	return f[x];
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++){
        f[i]=i;
    }
    for(int i=1;i<=m;i++){
		scanf("%d %d",&u,&v);
		u=find(u);
		v=find(v);
        if(u!=v) f[u]=v;//合并
    }
    for(int i=1;i<=n;i++){//搜索数量
    	int x=find(i);
    	if(!vis[x]){
			vis[x]=true;
    		ans++;
		}
	}
	printf("%d",ans);
    return 0;
}
/*
87ms
984KB
538B
*/
```
总的说，这道题中并查集是最优的做法

那就再见了qwq~

---

## 作者：起名字重要吗 (赞：2)

裸**并查集**，每读入两台电脑的编号，就将这两台电脑放到同一个集合去，最后记录集合的个数。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,f[100005],x,y,cnt;
int getf(int x) {
	if(f[x]==x) return x;
	return f[x]=getf(f[x]);
}
void merge(int x,int y) {
	f[getf(y)]=getf(x);
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		f[i]=i;
	for(int i=1; i<=m; i++) {
		cin>>x>>y;
		merge(x,y);
	}
	for(int i=1; i<=n; i++)
		if(f[i]==i) cnt++;
	cout<<cnt;
	return 0;
}
```
求管理大大给过！

---

## 作者：cjZYZtcl (赞：2)

# 看到没有P党的题解，来一发！

#### 我是一个小蒟蒻，不懂大佬们用的并查集、Tarjan啥的，但dfs还是OK的。(QwQ)

简单来说，就是用一个二维数组，a[x,0]表示有几个与点x连通的点，a[x,i]表示第i个与点x连通的点。~~（数据太水了，我数组第二维才开了一百，竟然没有炸）~~

接下来再用一重循环枚举点数，我用b数组表示一个点有没有没枚举到，如果这个点没被枚举到，则将s累加一，用一个dfs搜索所有与这个点连通的点，当搜到点i，就把b[i]改为true，表示已经枚举到了。

## AC代码如下：
```pascal
var
  i,n,m,x,y,s:longint;
  a:array[0..100005,0..105]of longint;
  b:array[0..100005]of boolean;
procedure dfs(x:longint);
var
  i:longint;
begin
  if b[x] then exit;//如果这个点搜过了就退出。
  b[x]:=true;
  for i:=1 to a[x,0] do dfs(a[x,i]);//搜索所有与当前点连通的点。
end;
begin
  readln(m,n);
  for i:=1 to n do
  begin
    readln(x,y);
    inc(a[x,0]);
    a[x,a[x,0]]:=y;
    inc(a[y,0]);
    a[y,a[y,0]]:=x;//双向保存点的连通性。
  end;
  for i:=1 to m do
    if not(b[i]) then begin inc(s); dfs(i); end;//如果这个点没有没搜到过，说明这是与之前搜过的所有点都不连通，用dfs搜索所有与这个连通的点。
  write(s);
end.
```

# ~~求管理员大大给过QwQ~~

---

## 作者：Perseis (赞：2)

看完题目第一眼，，哇强连通分量

~~A完题目第二眼发现其实是一个裸的并查集（捂脸）~~

看了一眼题解好像是dfs求联通块，并查集，tarjan的天下，，

那么蒟蒻就来水一发kosaraju吧qwq

~~画外音：你除了比他们复杂以外和他们有什么区别~~

```cpp
#include<bits/stdc++.h>
#define N 2000100
using namespace std;
stack<int>s;
int n,m,x,y,head[N],to[N],nxt[N],cnt,f[N],rto[N],rnxt[N],rhead[N],rcnt,num,belong[N],ans,flag[N];
inline void add(int x,int y)
{
    to[++cnt] = y;
    nxt[cnt] = head[x];
    head[x] = cnt;
    //正图
    rto[++rcnt] = x;
    rnxt[rcnt] = rhead[y];
    rhead[y] = rcnt;
    //反图
}
inline int read()//快读
{
    char ch = getchar();
    int x = 0, f = 1;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while('0' <= ch && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void dfs(int x)//第一次跑正图
{
    f[x] = 1;
    for(register int i = head[x];i!=0;i = nxt[i])
    if(!f[to[i]]) dfs(to[i]);
    s.push(x);
}
void rdfs(int x)//第二次跑反图
{
    f[x] = 1;
    belong[x]=num;
    for(register int i = rhead[x];i!=0;i=rnxt[i]) if(!f[rto[i]]) rdfs(rto[i]);
}
int main()
{
    n=read();
    m=read();
    for(register int i = 1;i<=m;i++)
    {
        x=read();
        y=read();
        add(x,y);
        add(y,x);//前向星建边
    }
    for(register int i =1;i<=n;i++) if(!f[i]) dfs(i);
    memset(f,0,sizeof(f));
    while(!s.empty())
    {
        int k = s.top();s.pop();
        if(!f[k])
        {
            ++num;
            rdfs(k);
        }
    }
    for(register int i=1;i<=n;i++) for(register int j = head[i];j!=0;j = nxt[j]) if(belong[i]!=belong[to[j]]) flag[belong[i]]=1;
    for(register int i=1;i<=num;i++) if(flag[i]==0) ++ans;//强连通分量个数
    printf("%d",ans);
    return 0;
}

```

---

## 作者：睿屿青衫 (赞：1)

我只想说自己脑残，上来就打了个强连通分量tarjan，最后样例不过，发现貌似是个裸的并查集？然后加注释，改代码，提交的时候因为关键字被卡了==把每次读入的两条边合并，最后枚举每一个点，如果这个点的祖先没有标记过就打标记，答案+1，枚举完了答案也就出来了（即看有几个集合）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 200010
using namespace std;
int n,m,head[maxn],qr,rq,cnum,color[maxn],dfn[maxn],low[maxn];
int stack[maxn],top,vis[maxn],ans,q[maxn];
int father[maxn];
int find(int x)
{
    if(father[x]!=x) father[x]=find(father[x]);
    return father[x];
}
void unionn(int x,int y)
{
    int r1=find(x);
    int r2=find(y);
    father[r2]=r1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
     father[i]=i;
    for(int i=1;i<=m;i++)
     {
         int a,b;
         scanf("%d%d",&a,&b);
        if(find(a)!=find(b))
         unionn(a,b);
     }
    for(int i=1;i<=n;i++)
     if(!q[find(i)])
      {
          q[find(i)]=1;
          ans++;
      }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：sodak (赞：0)

遇到没有遍历的点，dfs一下，统计联通块个数就可以了

## code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
#define re register 
#define gc getchar()
#define getch while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=gc;}
#define getnu while(ch>='0'&&ch<='9'){s=(s<<1)+(s<<3)+ch-'0';ch=gc;}
using namespace std;
inline int read(){int s=0,f=1;char ch=gc;getch;getnu;return s*f;}
const int maxn=200000+10,maxm=200000+10;
int head[maxn],nxt[maxm<<1],ver[maxm<<1],tot=1;
void add(int x,int y){ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;}
bool vis[maxn];
int cnt;
void dfs(int x){
	if(vis[x])return;
	vis[x]=1;
	for(int i=head[x];i;i=nxt[i])dfs(ver[i]);
}
int main(){
	int n=read(),m=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	for(int i=1;i<=n;i++){
		if(!vis[i])dfs(i),cnt++;
	}
	printf("%d\n",cnt);
}


```

---

## 作者：Eason_AC (赞：0)

## Content
有一些电脑，一部分电脑有双向数据线连接。如果一个电脑得到数据，它可以传送到的电脑都可以得到数据。现在，你有这个数据，问你至少将其输入几台电脑，才能使所有电脑得到数据。

**数据范围：$n\leqslant 10^5,m\leqslant 2\times 10^5$。**
## Solution
稍微观察以后就会明白这是一道经典的并查集题目，我们只需要通过并查集将两个电脑所在的联通快合并，最后看有多少个联通块就好了。
## Code
```cpp
int f[100007], n, m, vis[100007], ans;

inline int getfa(int x) {
	return x == f[x] ? x : f[x] = getfa(f[x]);
}
inline void unionn(int x, int y) {
	x = getfa(x), y = getfa(y);
	if(x != y) f[y] = x;
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; ++i) f[i] = i;
	for(int i = 1; i <= m; ++i) {
		int a, b;
		scanf("%d%d", &a, &b);
		unionn(a, b);
	}
	for(int i = 1; i <= n; ++i) if(!vis[getfa(i)]) ans++, vis[getfa(i)] = 1;
	printf("%d", ans);
	return 0;
}
```

---

## 作者：iorit (赞：0)

[原题](https://www.luogu.com.cn/problem/P2097)

题意：给定一个无向图，求这个图的连通块数量。

蒟蒻不会Tarjan，~~懒得打dfs~~，于是就写了个简单的并查集。

如果起点和终点不在一个集合内，那么就将它们所在的集合合并

一开始将ans设为点数，每次合并将ans-1即可。

ps:不会并查集的同学可以参考[这里](https://www.luogu.com.cn/blog/tbr-blog/solution-p3367)

### 代码

```cpp
// 此处应有头文件
const int N = 1e5 + 10;
int n,m;
int f[N];
int ans;
int find(int x)
{
	if( x == f[x] )
		return x;
	return f[x] = find( f[x] ); // 路径压缩
}
int main()
{
	cin >> n >> m;
	ans = n;
	for(int i = 1;i <= n;i++)
		f[i] = i; // 并查集初始化
	for(int i = 1;i <= m;i++)
	{
		int p,q;
		cin >> p >> q;
		int a = find(p); // p的老大
		int b = find(q); // q的老大
		if(a != b)
		{
			f[a] = b; // 合并集合
			--ans;
		}
	}
	cout << ans << endl;
    return 0;
}

```


---

## 作者：灵光一闪 (赞：0)

~~woc？改了一个循环嵌套就秒过？？？~~

我在连通分量时居然写了个连我也不懂的东西……？？
```
for(int i=0;i<n;i++)
    {
        for(int j=0;j<g[i].size();j++)
        {
            if(!vis[g[i][j]])
            {
                dfs(g[i][j]);
                ans++;
            }
        }
    }
```
这都是smg？？？  
我脑子短路了？？？

~~无视以上的东东……~~

好的书归正文，这题不就是一个联通分量吗？？  
~~这题要我出我就n，m开到10^9……~~

DFS简单过~
```
//#include<bits/stdc++.h>

#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cstdio>

#include<vector>
#include<string>
#include<cmath>
#include<map>

using namespace std;
vector <int> g[233333];//存图用vector
bool vis[233333]={false};//是否走过
void dfs(int a)//dfs模板不解释……
{
    vis[a]=true;
    for(int i=0;i<g[a].size();i++)
        if(!vis[g[a][i]])
            dfs(g[a][i]);
    return;
}
int main()
{
    int x,y;
    int n,m;
    cin>>n>>m;
    for(int i=0;i<m;i++)//这里就是存图用的
    {
        cin>>x>>y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    int ans=0;
    for(int i=1;i<=n;i++)//查找ing……
    {
        if(!vis[i])
        {
            dfs(i);
            vis[i]=true;
            ans++;
        }
    }
    cout<<ans;
    return 0;
}
```

然后就是那个出题人坑我们的了！  
``数据不保证没有重边，不保证没有自回环``  
这个有毛用？？一开始我觉得这个肯定有用，然后我画了一下……
这个……
![](https://cdn.luogu.com.cn/upload/pic/60058.png)
![](https://cdn.luogu.com.cn/upload/pic/60057.png)
联通分量个数有变化吗？没有……

## 所以！遇到给定的 _特殊条件_ 一定要在稿子上演算一遍看看，真的，~~我第一次就被坑了……~~

推荐[这个写题解比比神器](https://webdemo.myscript.com/views/diagram/index.html#/edit)

The End.

---

## 作者：Vocanda (赞：0)

# 题目
[题目链接](https://www.luogu.com.cn/problem/P2097)

# 分析
题意就是给出一些边和一些电脑，每个电脑传数据可以使与它直接或间接相连的电脑都有数据，让求最少给多少个电脑传数据能让所有电脑都有数据。

其实问题就转化为了让你求有多少个联通块，我们在建完图之后，枚举每个点跑 $dfs$ ，每访问到一个点就打上标记，枚举的时候，每枚举到一个点未被访问，就从这里开始搜，然后答案加一，最后直接输出答案即可。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define read() ({int s = 0,f = 1;char ch = gc;for(;!isdigit(ch);ch = gc)if(ch == '-')f = -1;for(;isdigit(ch);ch = gc)s = s * 10 + ch - '0';s * f;})
const int maxn = 2e5+10;
struct Node
{
	int v,next;
}e[maxn<<1];
int vis[maxn];
int head[maxn],tot;
void Add(int x,int y)
{
	e[++tot].v = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x)
{
	vis[x] = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		int v = e[i].v;
		if(!vis[v])dfs(v);
	}
}
int main()
{
	int n = read(),m = read();
	int cnt = 0;
	for(int i = 1;i <= m;++i)
	{
		int x = read(),y = read();
		Add(x,y);
		Add(y,x);
	}
	for(int i = 1;i <= n;++i)
	{
		if(!vis[i]){
			cnt++;
			dfs(i);
		}
	}
	printf("%d\n",cnt);
}

```

---


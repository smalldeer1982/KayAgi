# 搬运工

## 题目背景

陈老师喜欢网购书籍，经常一次购它个百八十本，然后拿来倒卖牟取暴利。

## 题目描述

前些天，高一的新同学来了，他便像往常一样兜售他的书，经过一番口舌，同学们决定买他的书，但是陈老师桌上的书有三堆，每一堆都有厚厚的一叠，他要想个办法用最轻松的方式把书拿下来给同学们。但是你想逗一下陈老师，于是你设计一个最累的方式给他。若告诉你这三堆分别有 $i$，$j$，$k$ 本书，以及每堆从下到上书的质量，每次取书只能从任一堆的最上面取，那么请你设计一个方案，让他花最大的力气取下所有的书。

显然，每次取书陈老师的体力消耗都会加大，这里用体力系数代表，取下第一本书时，体力系数为 $1$，第二本书时体力系数为 $2$，依次类推，而每次体力消耗值则为体力系数与书的重量之积。

## 说明/提示

#### 数据规模与约定

+ 对于 $50\%$ 的数据有 $0\le i,j,k\lt10$。
+ 对于 $100\%$ 的数据有 $0\le i,j,k\lt100$。

最后输出的体力消耗总值在 C++ int 范围内。

## 样例 #1

### 输入

```
3 2 4
2 3 2
1 5
9 8 7 4
```

### 输出

```
257```

# 题解

## 作者：引领天下 (赞：18)

为什么要用DP呢？

用DFS多好。

每次搜一堆，一直搜下去，找最大值，不就行了吗？？？

DP多难写啊。

#谨以此题解祝我下午NOIP RP=无限大！

上代码：

```C
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <iostream>
using namespace std;
int w[4][101],n,i,j,k;
long long ans,now;//用long long,防爆
void in(){
    scanf ("%d%d%d",&i,&j,&k),n=i+j+k;//n是书的总数，i,j,k为123堆
    for (int t=1;t<=i;t++)scanf ("%d",&w[1][t]);//读入书
    for (int t=1;t<=j;t++)scanf ("%d",&w[2][t]);
    for (int t=1;t<=k;t++)scanf ("%d",&w[3][t]);
}
void dfs(int a,int b,int c){//DFS
    int x;
    if (a+b+c==0){
        if (now>ans)ans=now;
        return;//搬完了，更新答案
    }
    x=n-(a+b+c)+1;//搬这本书需要的体力
    if (a>0){//如果有才搜
        now+=w[1][a]*x;//递归前加
        dfs(a-1,b,c);//搬一本（第一堆）
        now-=w[1][a]*x;//改回去
    }//以下原理同上
    if (b>0){
        now+=w[2][b]*x;
        dfs(a,b-1,c);
        now-=w[2][b]*x;
    }
    if (c>0){
        now+=w[3][c]*x;
        dfs(a,b,c-1);
        now-=w[3][c]*x;
    }
}
int main(){
    in();//读入
    dfs(i,j,k);//DFS
    printf ("%lld",ans);//输出
    return 0;
}
```

---

## 作者：chenzhangpei (赞：6)

### 思路：

蒟蒻不会 动态规划 ，所以只能用 深度优先搜索 。

~~深度优先搜索无思维难度。~~

只有 3 堆 要搜，那就每次搜 1 堆 呗，1 个函数内搜 3 次呗。

#### 估摸着您没看懂,看看下面。

 $ Q $ : 怎么搜索呢？
 
 $ A $ : 按下面做即可：

> 先设现在搬得是第 $ q $ 本书。

> 1. 深度优先搜索 是用递归实现的，所以得先找到递归出口（ 返回 ），即所有堆的个数都为 0 时就返回。

> 2. 因为题目说每搬一本书 $ txi $ （ 即体力系数，下文同 ）都会加 1 ，所
以建议在前面计算体力系数（ 同样是搬第 $q$ 本书嘛 ）,公式: $ txi $ $ = 
$ $ n $ $ - $ $ ( $ $ i $ $ + $ $ j $ $ + $ $ k $ $ ) $ $ + $  $ 1 $。

> 3. 想想如何搜索。

>> 3.1. 如果堆的个数不为 0 ,那么就搜。

>> 3.2. 将 $tx$（ 即体力消耗，下文同 ）给更新，加上公式即可，公式: $ m 
$ [ 第几堆 ] [ 现在堆中有多少个本书 ] $ * $ $ txi $ 
。

>> 3.3. 进行下一层递归，注意将该堆的个数 $ - $ 1 。

>> 3.4. 回溯，将 $ tx $ 改回来，减掉公式即可。

> 4. 当这上面的搞完了，就可以返回了。

以上就是如何写该题的 深度优先搜索 的全部内容。

~~我相信~~ 您已经看懂了，即可自己打了，如有疑问请看完整代码.
 
已经有思路的同学可以参考一下深度优先搜索 框架：

 ```cpp
void dfs(int i,int j,int k) {

	if(!(i+j+k)) { //如果皆是0的话就返回，即递归出口
     //判断是否要更新
		return ;
	}
   
   int txi=n-(i+j+k)+1; //计算体力系数
   
	if(i>0) { //如果1号堆里有就搜
		//代码
	}
   
	if(j>0) { //如果2号堆里有就搜
		//代码
	}
    
	if(k>0) { //如果3号堆里有就搜
		//代码
	}
}
```

### 完整代码 ：

```cpp
#include<bits/stdc++.h> 
using namespace std;
int m[5][105],n,i,j,k,ans,tx; //题意说int不会爆，可放心使用
// 用个二维数组记录质量 
void inp() { //输入
    int x=1;
    cin>>i>>j>>k; //输入每堆的个数
    n=i+j+k; //记录总和
    for(int t=1; t<=i; t++) {
        cin>>m[x][t]; //输入书的质量
    }
    x++; 
    for(int t=1; t<=j; t++) {
        cin>>m[x][t];
    }
    x++;
    for(int t=1; t<=k; t++) {
        cin>>m[x][t];
    }
    return ;                       
}
void dfs(int i,int j,int k) { //深度优先搜索（ DFS ）
    if(!(i+j+k)) { //如果皆是0的话就返回，即递归出口
        ans=max(ans,tx); //更新最大值
        return; //返回
    }
    int txi=n-(i+j+k)+1; //计算体力系数
    if(i>0) { //如果1堆里有就搜
        tx+=m[1][i]*txi; //将 tx 给更新
        dfs(i-1,j,k); //搜索，将第一堆里的一本拿掉
        tx-=m[1][i]*txi; //将 tx 改回来
    }
   //以下同理 
    if(j>0) {
        tx+=m[2][j]*txi;
        dfs(i,j-1,k);
        tx-=m[2][j]*txi;
    }
    if(k>0) {
        tx+=m[3][k]*txi;
        dfs(i,j,k-1);
        tx-=m[3][k]*txi;
    }
}
int main() { 
    inp(); //因为输入太长所以就把它从主函数里裂出来了
    dfs(i,j,k); //开启DFS之旅
    cout<<ans; 
    return 0;
}
```

#### 解疑代码（如果没有疑问就跳过）：

如果你是 $ inp $ 函数看不懂，请看如下代码：

```cpp
void inp() {
    cin>>i>>j>>k; //输入每堆的个数
    n=i+j+k; //记录总和
    for(int t=1; t<=i; t++) {
		cin>>m[1][t]; //输入书的质量
	}

	for(int t=1; t<=j; t++) {
		cin>>m[2][t];
	}

	for(int t=1; t<=k; t++) {
		cin>>m[3][t];
	}
	return ; //返回
}
```

有参考 [引领天下](https://www.luogu.com.cn/user/39863) 巨佬 [题解](https://www.luogu.com.cn/blog/yltx/solution-p2374) 。

#### 完结撒花！

---

## 作者：绝_尘 (赞：6)

其实dp思路很简单，就是设f[i][j][k]表示三堆书分别剩下i、j、k本时（注意是拿得只剩下i、j、k本时，之前拿过的不计），能够得到的最大值，最后输出f[a][b][c](a、b、c分别为一开始输入的三堆书的初始值)。dp方程：f[i][j][k] = max (f[i-1][j][k]+x[i]\*s, max (f[i][j-1][k]+y[j]\*s, f[i][j][k-1]+z[k]\*s))   (s是当前要乘上的体力值)。具体代码实现如下：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a,b,c,x[101],y[101],z[101],f[101][101][101];
int main()
{
    scanf("%d%d%d",&a,&b,&c);
    int to=a+b+c//;先记录总消耗体力值；
    for(int i=1;i<=a;i++)//自下而上输入；
    scanf("%d",&x[i]);
    for(int j=1;j<=b;j++)
    scanf("%d",&y[j]);
    for(int k=1;k<=c;k++)
    scanf("%d",&z[k]);
    for(int i=0;i<=a;i++)//开始动态规划，从最底下的开始，正好符合自下而上的输入；
    for(int j=0;j<=b;j++)//注意要从剩下0本开始，因为最后要拿完；
    for(int k=0;k<=c;k++){
        int s=to-i-j-k+1;//求得当前已消耗的体力值，作为乘数；
        if(i)f[i][j][k]=x[i]*s+f[i-1][j][k];//当i不为0时，即当前这堆还可以拿书时先拿；’
        if(j)f[i][j][k]=max(f[i][j][k],y[j]*s+f[i][j-1][k]);//比较取得最优值；
        if(k)f[i][j][k]=max(f[i][j][k],z[k]*s+f[i][j][k-1]);//道理同上；
    }
    printf("%d",f[a][b][c]);return 0;//输出当三堆书都还没有拿走时的最优值；
}
```

---

## 作者：naroanah (赞：5)

我们设 $maxv[i][j][k]$ 表示三堆书分别取了 $i,j,k$ 本时，花费的最大体力值。不难发现，在状态转移时，我们每次可以从三堆书的顶端任取一本，可以得到一个类似于背包的状态转移方程。
```cpp
if(i>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i-1][j][k]+t*booka[a-i+1]);
if(j>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i][j-1][k]+t*bookb[b-j+1]);
if(k>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i][j][k-1]+t*bookc[c-k+1]);
//t=i+j+k 体力系数
```
因为只有至少取了一本书，它的前一个状态才是有意义的，不然会取到负数下标，所以在 $i,j,k>0$ 时才进行状态转移。

**注意：书的重量是由下至上输入的，所以每一次取到的书是 总数-当前本数+1。**

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b,c;
int booka[101],bookb[101],bookc[101];
long long maxv[101][101][101];
int main() {
	cin>>a>>b>>c;
	for(int i=1;i<=a;i++) cin>>booka[i];
	for(int i=1;i<=b;i++) cin>>bookb[i];
	for(int i=1;i<=c;i++) cin>>bookc[i];
	for(int i=0;i<=a;i++){
		for(int j=0;j<=b;j++){
			for(int k=0;k<=c;k++){
				int t=i+j+k;
				if(i>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i-1][j][k]+t*booka[a-i+1]);
				if(j>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i][j-1][k]+t*bookb[b-j+1]);
				if(k>0) maxv[i][j][k]=max(maxv[i][j][k],maxv[i][j][k-1]+t*bookc[c-k+1]);
			}
		}
	}
	cout<<maxv[a][b][c]<<endl;
    return 0;
}
```

                
 

---

## 作者：_cmh (赞：2)

正如 引领天下 巨佬所说的那样，这道题用 $DFS$ 毫无思维难度，秒过。

注意：本题不能用贪心，用贪心是错的！！！

搜索就是每次将当前状态的重量加上，最后去最大值输出即可。

接下来上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
int x,y,z,a[100001],b[100001],c[100001],alln,now,maxn=-1; 
void dfs(int aa,int bb,int cc){
	if(aa==0&&bb==0&&cc==0){
		maxn=max(now,maxn);
		return;
	}
	int xs=alln-aa-bb-cc+1;
	if(aa){
		now+=a[aa]*xs;
		dfs(aa-1,bb,cc);
		now-=a[aa]*xs;
	}
	if(bb){
		now+=b[bb]*xs;
		dfs(aa,bb-1,cc);
		now-=b[bb]*xs;
	}
	if(cc){
		now+=c[cc]*xs;
		dfs(aa,bb,cc-1);
		now-=c[cc]*xs;
	}
}
int main(){
	cin>>x>>y>>z;
	for(int i=1;i<=x;i++) cin>>a[i];
	for(int i=1;i<=y;i++) cin>>b[i];
	for(int i=1;i<=z;i++) cin>>c[i];
	alln=x+y+z;
	dfs(x,y,z); 
	cout<<maxn;
    return 0;
}
```

其实还有一种方法—— $DP$ 。

$DP$ 就是用当前可取的 $3$ 个状态取最大值，加上前面的状态，赋值到当前状态，表示这个状态所需要的最大重量，最后输出 $d[x][y][z]$，表示最大需要的体力。

注意：$for$ 循环需要从 $0$ 开始！

接下来上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
int x,y,z,a[100001],b[100001],c[100001],alln,d[101][101][101];
int main(){
	cin>>x>>y>>z;
	for(int i=1;i<=x;i++) cin>>a[i];
	for(int i=1;i<=y;i++) cin>>b[i];
	for(int i=1;i<=z;i++) cin>>c[i];
	alln=x+y+z;
	for(int i=0;i<=x;i++)
		for(int j=0;j<=y;j++)
			for(int k=0;k<=z;k++){
				int xs=alln-i-j-k+1;
				d[i][j][k]=max(max(max(a[i]*xs+d[i-1][j][k],b[j]*xs+d[i][j-1][k]),c[k]*xs+d[i][j][k-1]),d[i][j][k]);
			}
	cout<<d[x][y][z];
    return 0;
}
```

求赞！

---

## 作者：_•́へ•́╬_ (赞：2)

### 为什么要用$^D_P$呢？记忆化搜索多香啊！

$dfs(a,b,c)$ 表示第一堆剩 $a$ 本、第二堆剩 $b$ 本、第三堆剩 $c$ 本。

$dfs$ 中枚举这一次从哪一堆里取，递归，记忆化。请看代码以更好地理解。

### $code$

```cpp
#include<stdio.h>
int a1,b1,c1,a2[100],b2[100],c2[100],ans[100][100][100];
inline void max(int&x,const int&y){if(x<y)x=y;}
inline int dfs(const int&a,const int&b,const int&c)
{
	if(!a&&!b&&!c)return 0;//取完了
	if(ans[a][b][c])return ans[a][b][c];//算过这个了，记忆化
	register int n=a1+b1+c1-a-b-c+1;//第几本书，即体力系数
	if(a)max(ans[a][b][c],dfs(a-1,b,c)+a2[a]*n);//从第一堆里取
	if(b)max(ans[a][b][c],dfs(a,b-1,c)+b2[b]*n);//从第二堆里取
	if(c)max(ans[a][b][c],dfs(a,b,c-1)+c2[c]*n);//从第三堆里取
	return ans[a][b][c];//
}
main()
{
	scanf("%d%d%d",&a1,&b1,&c1);//输入
	for(register int i=1;i<=a1;++i)scanf("%d",a2+i);//输入
	for(register int i=1;i<=b1;++i)scanf("%d",b2+i);//输入
	for(register int i=1;i<=c1;++i)scanf("%d",c2+i);//输入
	printf("%d",dfs(a1,b1,c1));//输出
}/**/
```

upd 2020.8.10 感谢 [巨佬](/user/323183) 的指正，的确有错误，特修改。并讲得更详细了。

---

## 作者：Lish_Xizse (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2374)

深搜好题，动态规划也能做。

------------
### 分析

很多题解都说贪心不能做，但没有说为什么。那我们来分析一下为什么不能用贪心。

这题的贪心思路非常简单，就是比较三堆数的最上层哪个小就先取那个，这样到了后面用体力系数大的乘上剩下那些重的书更好。

用这个方法，我们来算算体力消耗总值：

![](https://latex.codecogs.com/svg.image?2*1&plus;3*2&plus;2*3&plus;4*4&plus;5*5&plus;1*6&plus;7*7&plus;8*8&plus;9*9=255&space;)
     
不过样例，那就很明显不行。

### 方法

贪心不行，我们可以用深搜做。

深搜非常简单，可以直接套模板。我们可以每堆每堆搜下去，把每种方案进行比较就可以了。
```
void dfs(递归层数){
	if(没有书了){
		判断最大值/记录
		return;
	}
	if(第一堆书还有){
		加上每次体力消耗；
		dfs(i-1,j,k,体力+1);
		减去原先加上过的体力消耗；
	}
	if(第二堆书还有){
		加上每次体力消耗；
		dfs(i,j-1,k,体力+1);
		减去原先加上过的体力消耗；
	}
	if(第三堆书还有){
		加上每次体力消耗；
		dfs(i,j,k-1,体力+1);
		减去原先加上过的体力消耗；
	}
}
```


------------
### 完美 ```AC``` 代码：

```
#include<iostream>
using namespace std;
int a,b,c,tl=1;//tl为体力系数，初始为1 
int a_[110],b_[110],c_[110];
int sum,maxn;
void dfs(int a,int b,int c,int tl){
	if(a==0&&b==0&&c==0){//如果全部取完 
		maxn=max(maxn,sum);//比较大小 
		return;
	}
	if(a>0){
		sum+=a_[a]*tl;//加上体力消耗 
		dfs(a-1,b,c,tl+1);//a减少一本书，体力数值+1 
		sum-=a_[a]*tl;//减去体力消耗 
	}
	if(b>0){
		sum+=b_[b]*tl;
		dfs(a,b-1,c,tl+1);
		sum-=b_[b]*tl;
	}
	if(c>0){
		sum+=c_[c]*tl;
		dfs(a,b,c-1,tl+1);
		sum-=c_[c]*tl;
	}
}
int main(){
	cin>>a>>b>>c;
	for(int i=1;i<=a;i++)cin>>a_[i];
	for(int i=1;i<=b;i++)cin>>b_[i];
	for(int i=1;i<=c;i++)cin>>c_[i];
	dfs(a,b,c,tl);
	cout<<maxn;//深搜完得出最大值，输出
	return 0;
}
```


---

## 作者：Coros_Trusds (赞：1)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15465432.html)

这道题正解明明是 $\rm DP$ 啊，为什么题解区几乎都是暴力啊。。。

# 题目大意

有三堆书，分别有 $n,m,k$ 本。给定 $n,m,k$ 和每本书的重量 $a,b,c$。

每次取书只能取每堆最上面的，每次取书的代价为 $val\times weight$。

其中 $val$ 表示这是第 $val$ 次取书，$weight$ 表示这本书的重量。

# 题目分析

显然看到数据范围 $1\le n,m,k\le100$ ，于是可以推测时间复杂度是 $O(n\times m\times k)$。

令 $dp[i][j][v]$ 表示三个书堆恰好取了 $i,j,v$ 本时的最大价值，$tot=n+m+k$，$val=tot-i-j-v+1$。

$tot$ 是书的总量，$val$ 是当前的取书次数。

当 $i\neq 0$ 时，有：

$$dp[i][j][v]=\max\{dp[i][j][v],val\times a[i]+dp[i-1][j][v]\}$$

当 $j\neq 0$ 时，有：

$$dp[i][j][v]=\max\{dp[i][j][v],val\times b[j]+dp[i][j-1][v]\}$$

当 $v\neq 0$ 时，有：

$$dp[i][j][v]=\max\{dp[i][j][v],val\times c[v]+dp[i][j][v-1]\}$$

# 代码

```cpp
const int ma=105;

int a[ma],b[ma],c[ma];

int dp[ma][ma][ma]; 

int n,m,k;

int main(void)
{
	n=read(),m=read(),k=read();
	
	int tot=n+m+k;
	
	for(register int i=1;i<=n;i++)
	{
		a[i]=read();
	}
	
	for(register int i=1;i<=m;i++)
	{
		b[i]=read();
	}
	
	for(register int i=1;i<=k;i++)
	{
		c[i]=read();
	}
	
	for(register int i=0;i<=n;i++)
	{
		for(register int j=0;j<=m;j++)
		{
			for(register int v=0;v<=k;v++)
			{
				int val=tot-i-j-v+1;
				
				if(i!=0)
				{
					dp[i][j][v]=max(dp[i][j][v],a[i]*val+dp[i-1][j][v]);
				}
				
				if(j!=0)
				{
					dp[i][j][v]=max(dp[i][j][v],b[j]*val+dp[i][j-1][v]);
				}
				
				if(v!=0)
				{
					dp[i][j][v]=max(dp[i][j][v],c[v]*val+dp[i][j][v-1]);
				}
			}
		}
	}
	
	printf("%d\n",dp[n][m][k]);
	
	return 0;
}
```

---

## 作者：zxw666 (赞：1)

###### ~~一眼望去眼里只有暴搜~~


40分的大暴力

```c
#include<stdio.h>
#include<algorithm>
using namespace std;
long long ans;
int k,w[4][101];
void dfs(int a,int b,int c,long long sum) {
	if(a==0 && b==0 && c==0) {
		if(sum>ans) ans=sum;
		return ;
	}
	if(a) {
		++k;
		dfs(a-1,b,c,sum+(k*w[1][a]));
		--k;
	}
	if(b) {
		++k;
		dfs(a,b-1,c,sum+(k*w[2][b]));
		--k;
	}
	if(c) {
		++k;
		dfs(a,b,c-1,sum+(k*w[3][c]));
		--k;
	}
}

int main() {
	for(int i=1; i<=3; ++i) {
		scanf("%d",&w[i][0]);
	}
	for(int i=1; i<=3; ++i)
		for(int j=1; j<=w[i][0]; ++j) {
			scanf("%d",&w[i][j]);
		}

	dfs(w[1][0],w[2][0],w[3][0],0);
	printf("答案是：%lld"/*注意了注意了 /xyx */,ans);
	return 0;
}
```

 

### 正解$DP$做法

$F[i][j][k]$ 表示目前第$1$堆剩余$i$本，第$2$堆剩余$j$本，第$3$堆剩余$k$本的最大劳累值

```cpp
f[i][j][k]=max(max(f[i+1][j][k]+d[i+1]*t,f[i][j+1][k]+e[j+1]*t),f[i][j][k+1]+g[k+1]*t);
```

```cpp
t=a+b+c-i-j-k
```
 其中$a,b,c$为$3$堆书本的数量，$d[i],e[i],g[i]$对应$3$堆书中第$i$本书的质量
 
(！！！换马蜂了！！！） 

```cpp
#include<bits/stdc++.h>
using namespace std;
int k[4],bok[4][101],f[101][101][101];
int main() {
	for(int i=1; i<=3; ++i)
		scanf("%d",&k[i]);
	for(int i=1; i<=3; ++i)
		for(int j=1; j<=k[i]; ++j)
			scanf("%d",&bok[i][j]);
	for(int i=k[1]; i>=0; --i)
		for(int j=k[2]; j>=0; --j)
			for(int l=k[3]; l>=0; --l) {
				int t=k[1]+k[2]+k[3]-(i+j+l);
				f[i][j][l]=max(max(f[i+1][j][l]+bok[1][i+1]*t,f[i][j+1][l]+bok[2][j+1]*t),f[i][j][l+1]+bok[3][l+1]*t);
			}
	printf("%d",f[0][0][0]);
	return 0;
}
```


---

## 作者：Lysea (赞：0)

本蒟蒻一开始看到楼上几个dp,一开始完全没有懂，后来自己琢磨了一下午总算是懂了......
## 先放代码
```c
#include<bits/stdc++.h>
#define N 105
using namespace std;
int sum,a,b,c,d[N],e[N],f[N],dp[N][N][N];
void faster(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
}
void read(){ 
	cin>>a>>b>>c;
    for(int i=1;i<=a;i++) cin>>d[i];
    for(int i=1;i<=b;i++) cin>>e[i];
    for(int i=1;i<=c;i++) cin>>f[i];
}
void get_ans(){ 
	sum=a+b+c;
	for(int i=0;i<=a;i++){
    	for(int j=0;j<=b;j++){
    		for(int k=0;k<=c;k++){
		        int s=sum-i-j-k+1;
		        if(i) dp[i][j][k]=max(dp[i][j][k],d[i]*s+dp[i-1][j][k]);
		        if(j) dp[i][j][k]=max(dp[i][j][k],e[j]*s+dp[i][j-1][k]);
		        if(k) dp[i][j][k]=max(dp[i][j][k],f[k]*s+dp[i][j][k-1]);
		    }
		}
	}
}
void write(){
	cout<<dp[a][b][c]<<endl;
}
int main(){
	faster();
    read();
    get_ans();
    write();
	return 0;
}
```
整体思路还是三维dp，这篇题解主要就是根据我之前没懂的地方，对之前几篇dp题解进行润色。

## 讲解

首先，我们要知道 $\mathit{dp}_{a,b,c}$ 表示什么：在三堆书中分别取 $a$、 $b$、 $c$ 本书时，体力消耗值的最大情况。

那么假设现在这本书（在顶端）我不选，对应的最大值仍然是 $\mathit{dp}_{a,b,c}$ (自己现在的值）。

但是如果选了，那么对应的情况就是：这堆书选了 $a - 1$ 本时（其他两堆不变）的情况，再加上所消耗的体力值。之所以要减一，是因为要留出空来放这本书。

假设我们刚刚讨论的是第一堆书，用代码表示出来如下：


选： $\mathit{dp}_{a,b,c}$。

不选： $\mathit{dp}_{a,b,c} + \mathit{d}_{a} \times s$。

其中的 $d$ 数组表示的是第一堆书的价值，$s$ 表示的是现在的体力系数。

所以只要 $a$ 不为 $0$，就可以将这两者取出最大的情况：

```
if(a) dp[a][b][c]=max(dp[a][b][c],dp[a-1][b][c]+s*d[a]);
```
第二堆和第三堆同理：


```
if(a) dp[a][b][c]=max(dp[a][b][c],dp[a-1][b][c]+s*d[a]);
if(b) dp[a][b][c]=max(dp[a][b][c],dp[a][b-1][c]+s*e[b]);
if(c) dp[a][b][c]=max(dp[a][b][c],dp[a][b][c-1]+s*f[c]);
```

## 总结

怎么有点像01背包呢？

~~（嘶，越看越像）~~

---


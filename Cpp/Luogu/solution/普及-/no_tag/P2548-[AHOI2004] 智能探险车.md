# [AHOI2004] 智能探险车

## 题目描述

在 ***Sanuel*** 星球上的科学探险活动是由名为 ***Smart*** 的智能探险车完成的。因为 ***Sanuel*** 星球远离地球，信号往返传送一次要耗费数小时，而且存在很高的误码率。因此科学家们无法在地球上对 ***Smart*** 探险车进行实时控制，绝大部分探险活动都是由该探险车通过分析环境要素、自主决策、自主完成的。

科学家们的探险车设计方案相对简单：

首先，总结出影响探险车决策的各种**决策因素**，譬如：天气（weather）、地形（landform）、探险车供电情况（energy）和已采集矿石数目（mine）等。

随后，将每一种**决策因素**分成两种主要**情况**。譬如，将天气分成晴朗（sunny）和大风（windy）；将探险车供电情况分成饱满（full）和匮乏（lack），等等。

再后，科学家们针对各种**决策因素**，分别列出每一种行为的决策条件。譬如，若影响采集矿石的决策因素有 $N=4$ 种，而采集矿石的决策条件如下：

| 决策条件 | Weather | Landform | Energy | Mine |
| :------: | :-----: | :------: | :----: | :--: |
|    1     |  sunny  |  Plain   |  full  | Few  |
|    2     |  sunny  | mountain |  full  | Many |
|    3     |  sunny  | mountain |  full  | Many |

探险车的行为及其决策条件都很多，为了提高探险车的决策速度，最后需要探险车上的智能归纳模块将每一种行为的各种决策条件总结成一条“决策模板”。

如上述采集矿石的各条决策条件可以总结为：

| 决策模板 | sunny |  *   | full |  *   |
| :------: | :---: | :--: | :--: | :--: |

其中，“*”表示该因素不影响探险车的行为决策。

显然，决策模板要能够涵盖科学家们列出的该行为的所有决策条件。同时，决策模板中也含有一些科学家们未列出的决策条件，因而探险车能够在科学家们没有给出的决策条件下也能够自动进行某种行为，因而具有一定的“智能性”。如，上述决策模板会导致探险车在以下决策条件下也会进行矿石的采集。

|            | Weather | Landform | Energy | Mine |
| :--------: | :-----: | :------: | :----: | :--: |
| 新决策条件 |  sunny  |  Plain   |  full  | Many |

但是，任何事物都存在着两个方面。如果给出的决策模板过于笼统就失去了决策意义，相当于决策不精确。如，以下决策模板虽然涵盖了科学家们列出的各种采集矿石决策条件，但是因为决策过于笼统而意义不大。

| 过于笼统的决策模板 |  *   |  *   | full |  *   |
| :----------------: | :--: | :--: | :--: | :--: |

因此，要求探险车的决策模板所使用的”*“尽可能少。

小可可负责领导开发探险车的智能归纳模块。请你编写程序帮助小可可完成任务。

## 样例 #1

### 输入

```
4 3
sunny plain full many
sunny mountain full many
sunny mountain full few```

### 输出

```
sunny * full *```

# 题解

## 作者：览遍千秋 (赞：11)

~~省选题?不可置信。秒掉的第二道省选题~~

---
这道题看着很懵逼，什么意思啊，实际上，只要比较每一种类型是否全部相同即可，如有不相同就打出\*

---
代码如下，详见注释：

```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
#define maxn 1007
int n,m;
bool ans[maxn];
string t[maxn],gg;
inline void Init()//输入及预处理
{
    scanf("%d%d",&n,&m);//输入种类和个数
    for(register int i=1;i<=n;i++)
    {
        cin>>gg;
        t[i]=gg;
    }//先每个存储一份作为比较样本
    for(register int i=2;i<=m;i++)
    {
        for(register int j=1;j<=n;j++)
        {
            cin>>gg;
            if(t[j]!=gg)//如果不一样
                ans[j]=1;//答案就为*
        }
    }
}
inline void Work()
{
    for(register int i=1;i<=n;i++)
        if(ans[i])//如果应当为*
            printf("* ");//就输出*
        else
            cout<<t[i]<<" ";//不然就输出样本（都一样）
}
int main()//华丽的主函数
{
    Init();
    Work();
    return 0;
}
```

---

## 作者：ftyghome (赞：9)

##这是一道十分简单的字符串比较的题目

根据题意，我们只需要找出m个决策条件中决策因素完全相同的项。

- 读入全部条件，利用strcmp()函数对其进行判断即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
char a[1010][110][11];  //存储决策条件
int n,m;
bool flag;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%s",a[i][j]); //读入所有决策条件
    for(int i=1;i<=n;i++)
    {
        flag=1;
        for(int j=2;j<=m;j++)
        {
            if(strcmp(a[j][i],a[j-1][i])!=0) //比较字符串是否全部相同
            {
                printf("*");
                flag=0;
                break; //若不相同，输出“*”并退出循环
            }
        }
        if(flag) printf("%s",a[1][i]);
        if(i!=n) printf(" "); //输出格式限制行末不能有空格
    }
}
```cpp

---

## 作者：wxyOliver (赞：4)

看了一下好像没人用C++的map+vector+string做（有个set的做法好像差不多？），贡献一发。

题意比较好理解，我也好奇省选怎么会有这种大水题（其实不水也不会是不是orz），具体做法就是用一个map存每个字符串出现的个数，一个vector存第一行（我从0开始记数，这都无所谓），最后跑一遍vector（也就是第一行），把个数等于行数（m）的字符串原样输出，不等于行数的输出"*"即可。没有特别处理末尾空格，好像洛谷也不是很卡这个输出格式。

## 代码

```[C++]
#include <iostream>
#include <map>
#include <string>
#include <vector>
using namespace std;

int main() {
	map<string, int>mp;
	vector<string>first_row;
	int n, m;
	string s;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			cin >> s;
            mp[s]++;
			if (i == 0)first_row.push_back(s);
		}
	}
	for (int i = 0; i < n; i++) {
		if (mp[first_row[i]] == m)cout << row[i] << " ";
		else cout << "* ";
	}
	cout << endl;
	return 0;
}
```

---

## 作者：Herkezi (赞：3)

~~省选！省选！省选！你们都严肃点！它要有起码的尊严！！！~~

咳咳咳，切入正题。

首先，我们看到普及-，那么它就不会是BT难度，所以不要往复杂了想。

其次，看看题目，大意就是，给m组数据，每组n个字符串，表示n种因素。如果每组的同一栏都是相同的因素，那么输出因素，否则输出星号（~~题目描述里都是屁话~~）。

然后，星号代表的是无关因素，也就是说，只要有某一栏的任意一组因素与其他因素不同，那这一栏就是星号了。

再然后，就看看代码及注释吧。

```
#include<bits/stdc++.h>
using namespace std;
string s[1005][105];
//在这里我用了一个字符串的二维数组，相当于字符的三维数组，结果没爆，那就放心用吧。 
int main()
{
	int n,m;
	cin>>n>>m;
	for (int i=1;i<=n;++i)
		cin>>s[1][i],s[0][i]=s[1][i];
	//我先读入了第一组的各栏因素，以此作为标准对下面进行操作。
	//我之前说“某一栏的任意一组因素与其他因素不同，那这一栏就是星号了。”，所以选了比较方便的第一组作为标准。 
	for (int i=2;i<=m;++i) //从第二组开始读。 
		for (int j=1;j<=n;++j)
		{
			cin>>s[i][j];
			if (s[i][j]!=s[0][j])
				s[0][j]="*";
			//本题核心语句。含义就是前面引号的话。
			//如果一样，那就这个答案就不变。
			//这里有个小技巧是数组从1开始用，这样多出来的s[0]就可以利用了。 
		}
	cout<<s[0][1];
	for (int i=2;i<=n;++i)
		cout<<" "<<s[0][i];
	//这边的一些操作是由于在输出格式中它要求行首和行末都不存在多余的空白字符。
	//那我们就先输出一个，后面以空格加答案的形式输出。
    //不过那都是唬人的，直接答案加空格，也就是末尾多一个空格也是满分，本蒟蒻亲测。所以，随便吧。
	return 0;
}
```


---

## 作者：_•́へ•́╬_ (赞：3)

# STL大法好
### 思路：如果所有元素都是一样，就输出这个元素，否则输出*
```cpp
#include<bits/stdc++.h>
#define rpt(n) for(register int ttxyc=0;ttxyc<n;++ttxyc)//宏定义
using namespace std;
set<string>s[100];//集合
int n,m;string kkk;
main()
{
    scanf("%d%d",&m,&n);
    rpt(n)rpt(m)cin>>kkk,s[ttxyc].insert(kkk);//有同样的元素就不插入，所以同样的只保留一个
    rpt(m)
    {
    	if(s[ttxyc].size()==1)cout<<*s[ttxyc].begin();//都是同样的话肯定只有1个
    	else putchar('*');//有不一样的，输出*
    	putchar(' ');//分割符‘空格’
	}
}/**/
```

---

## 作者：Sshenyyyu (赞：2)

## 智能探险车
~~一道省选题，呃呃呃~~



------------
### 因为呢，题目说每种决策都只有两种方案，那么，只要同一个决策有两个不同的方案，就说明此决策可以用’*‘代替啦，其实真的不难想。。。

#### 蒟蒻代码 
```
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
#include <iostream>
using namespace std;

const int Maxn=100001;

int n,m;
string s[Maxn],c,ans[Maxn];//e，其实ans没什么用，好看呵呵哒

int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		cin>>s[i],ans[i]=s[i];
	for(int i=2; i<=m; i++) 
		for(int j=1; j<=n; j++) {
			cin>>c;
			if(c!=s[j])//只要有不同的，就可以啦
				ans[j]='*';	
		}
	for(int i=1; i<n; i++)//输出。。。
		cout<<ans[i]<<' ';
	cout<<ans[n];
	return 0;
}
```

---

## 作者：myfly (赞：2)

- ****普及蒟蒻表示难以置信——这是一道省选题****
- 分析：似乎用string类做简单一点~~其实已经很简单~~
- 废话不说，上暴力代码：
```cpp
# include <iostream>
# include <string>
using namespace std;
string a[105];
int main() {
    int n,m; cin>>n>>m;
    string s;
    for (int i=0; i<n; i++) cin>>a[i];
    for (int i=1; i<m; i++) {
        for (int j=0; j<n; j++) {
            cin>>s;
            a[j]=(s==a[j])
                ?s
                :"*";
        }
    }
    for (int i=0; i<n; i++) cout<<a[i]<<' ';
}
```

---

## 作者：_Int_ (赞：2)

****c++****  在线

这又是一道水题，标签还说普及（O\_\_O）无语

本题思路：按顺序读入，判断，输出~~~

话不多说，看代码

当当当当当当当当~~~~~

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>//头文件准备好 
using namespace std;
int n,m;//题目中的n和m 
char ans[105][11],ac[11];//ans是记录目前都一样的因素，ac用来读取
```
/\*ac是个吉利变量名\*/
bool does\_it\_has\_any\_answers[105];//does\_it\_has\_any\_answers是记录这个字符串是不是重复过了

```cpp
int main(){//主程序华丽开始 
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);//看题解的把这两句删掉 
    scanf("%d%d",&n,&m);//读入不解释 
    for(int i=0;i<m;i++){//有几组数据就读几组 
        for(int j=0;j<n;j++){//有几种因素就读几种 
            scanf("%s",ac);//读入每一种因素 
            int lena=strlen(ac),lenb=strlen(ans[j]);//因素的长度和目前不重复因素的长度
            if(lenb==0){//如果是第一个 
                for(int a=0;a<lena;a++)ans[j][a]=ac[a];//转移 
```
}//这句很重要，我在这地方卡了几次
else if(does\_it\_has\_any\_answers[j]==0&&lena==lenb){//如果它还没有出现重复&&长度相等

```cpp
                bool hhhhhhh=1;//是否一样 
                for(int a=0;a<lena;a++){//挨个比较 
                    if(ans[j][a]!=ac[a]){//如果不一样 
                        does_it_has_any_answers[j]=1;//重复了 
                        hhhhhhh=0;//不一样 
                        break;//退出，不比了 
                    }
                }
                if(hhhhhhh){//如果一样 
                    for(int a=0;a<lena;a++)ans[j][a]=ac[a];//转移 
                }
            }
            else{//不一样 
                does_it_has_any_answers[j]=1;//不五一样昂 
            }
        }
    }
    for(int i=0;i<n;i++){//挨个输出，这里用了行末不空格的形式 
        if(does_it_has_any_answers[i]&&i==n-1)printf("*");//如果又没重复又是最后一个，输出不解释 
        else if(does_it_has_any_answers[i])printf("* ");//如果没重复，输出不解释 
        else if(i==n-1)printf("%s",ans[i]);//如果重复了又是最后一个，输出不解释 
        else printf("%s ",ans[i]);//如果重复，输出不解释 
    }
    return 0;//拜拜 
```
}//主程序华丽结束
求管理员dalao给过


---

## 作者：SW_Wind (赞：1)

做水题当然是要用 JS 的函数式编程啦，偶尔要改变一下思维习惯。

这里我们需要写出的是一个能够接受输入数据然后返回输出数据的函数 `main`。

首先将所有要用到的函数柯里化。

然后我们需要使用合并函数的函数 `compose` 来合并函数。

合并完了之后直接调用 `main(data)` 就能得出答案了。

注意数据有点坑：

- `split` 之后的数组一定要全部 `trim` 一遍，不然会 WA。

献上巨丑无比的代码（洛谷好像不支持 js 高亮）：

```javascript
const data = require('fs')
  .readFileSync('/dev/stdin')
  .toString('ascii')
  .trim()
// begin --------------------

const map     = f => x => x.map(f)
const reduce  = f => x => x.reduce(f)
const trim    = s => s.trim()
const join    = s => x => x.join(s)
const split   = s => x => x.split(s)
const slice   = p => x => x.slice(p)
const merge   = (f, g) => x => g(f(x))
const compose = (...args) => args.reduce(merge, args.shift())

// compare :: List -> List -> List
const compare = x => map((a, i) => a === x[i] ? a : '*')

// main :: String -> String
const main = compose(
  split('\n'), slice(1),
  map(compose(split(' '), map(trim))),
  reduce((x, y) => compare(x)(y)),
  join(' ')
)

console.log(main(data))

// end ----------------------
process.exit()
```





---

## 作者：Mogician (赞：1)

#pascal版题解

将第一条决策条件作为标准存储，之后读入其它决策条件与之比较，若不同则改为‘\*’

##注意：如果你后5个点过不去，开ansistring试试

```cpp
var a:array[1..1000] of ansistring;
    i,j,k,t,m,n,p:longint;
    s:ansistring;
function CL(var s:ansistring):ansistring;//取出单词
begin
 CL:=copy(s,1,pos(' ',s)-1);
 delete(s,1,pos(' ',s));
end;
begin
 assign(input,'233.in');
 reset(input);
 readln(n,m);
 readln(s);
 s:=s+' ';
 for i:=1 to n do a[i]:=CL(s);//存下第一条决策条件
 for i:=2 to m do
  begin
   readln(s);
   s:=s+' ';
   for j:=1 to n do if CL(s)<>a[j] then a[j]:='*';//不同就改为'*'
  end;
 for i:=1 to n-1 do write(a[i],' ');
 write(a[n]);//输出答案，首尾不能有空格（貌似楼下行尾多了空格）
end.
```

---

## 作者：huangzhikun (赞：1)

看了前面一些人的题解，都是字符串的基本应用，没有几个拿hash值来求解这道题的，我就拿hash来求。这道题是我做的第四道省选题，~~感觉很水，都没有noip复赛第一题难~~
```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>
# include <cmath>
# include <queue>
using namespace std;
# define N 108
# define mod 133333331
int n,m;
long long hash[N];
char tj[108][18];

void work()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			long long hasha=0;
			char a[18];
			scanf("%s",a);
			for(int k=0;k<strlen(a);k++)
			{
				hasha=(hasha*13331+a[k])%mod;
			}
			if(i==1)
			{
				hash[j]=hasha;
				for(int k=0;k<strlen(a);k++)
				{
					tj[j][k]=a[k];
				}
			}
			else
			{
				if(hasha!=hash[j])
				{
					hash[j]=0;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(hash[i]==0) printf("* ");
		else
		{
			for(int j=0;j<strlen(tj[i]);j++)
			{
				printf("%c",tj[i][j]);
			}
			printf(" ");
		}
	}
	printf("\n");
	return;
}

int main()
{
	work();
	return 0;
}
```

---

## 作者：elephant_ouo (赞：0)

可以开一个bool类型数组存储第i行第j列是否唯一，输出时通过bool数组判断唯一输出单词,否则输出*
```cpp
#include <bits/stdc++.h>

#define max(a, b) (a > b ? a : b)
#define min(a, b) (a < b ? a : b)
#define LL long long
#define N 1010          
      
using namespace std;

inline int read()
{
    register int x = 0;
    register bool a = 0;
    register char c = getchar();
    while(!isdigit(c))
    {
        a^=! (c ^ '-');
        c = getchar();
    }
    while(isdigit(c))
    {
        x = (x + (x << 2) << 1) + (c ^ '0');
        c = getchar();
    }
    return a ?-x : x;							//读入优化 
}                                    
inline void print(int x)
{
    register int y[30] = {0}, tot = 0;
    do
    {
        y[++tot] = x % 10;
        x /= 10;
    }
	while(x);
    while(tot)
        putchar('0' + y[tot--]);				//输出优化
}                           							         
string s[N], tmp;       
bool ans[N];           
int n, m;
int main()
{
    m = read();                    
    n = read();
    for(register int i = 1; i <= m; i++)
        cin >> s[i];
		   
    for(register int i = 2; i <= n; i++)
    {
        for(register int j = 1; j <= m; j++)    
        {
            cin >> tmp;
            
			if(tmp != s[j])          			//对比是否相同 
                ans[j] = 1;          			//存储对比结果
        }
    }
    for(register int i = 1; i <= m; i++)
        if(ans[i])                
            cout << "* ";						 
        else                      	
            cout << s[i] << " ";    			 
    
	return 0;
}
```


---

## 作者：曾经的小玄XX (赞：0)

### 对于这道题，我非常说一句：你真的确定你的字符串长度只有10？？？

![](https://cdn.luogu.com.cn/upload/pic/49540.png)

贴一下50分WA代码：

```pascal
var s:array[1..1000,1..100]of string;n,m,i,j,k:longint;ss:string;l:array[1..1000]of string;
begin
 readln(n,m);
 for i:=1 to m do
  begin
   readln(ss);
   ss:=ss+' ';
   for j:=1 to n do
    begin
     k:=pos(' ',ss);
     s[i,j]:=copy(ss,1,k-1);
     delete(ss,1,k);
    end;
  end;
 for i:=2 to m do
  for j:=1 to n do
   if s[i,j]<>s[i-1,j] then
    l[j]:='*';
 for i:=1 to n do
  if l[i]<>'*' then
   l[i]:=s[1,i];
 for i:=1 to n-1 do
  write(l[i],' ');
 writeln(l[n]);
end.
```

这篇代码没注释，因为待会的AC代码跟这个差不多（几乎一样），注释我就贴那儿了（过于懒癌）。

看到50分之后，我觉得我的代码应该算~~正解~~可以AC的啊，想下数据时版权未开放。

~~![我的内心是崩溃的](https://cdn.luogu.com.cn/upload/pic/49540.png)~~

无奈的翻了几篇C++题解，感觉没啥不同，只不过他有优化而我没有，但这应是不影响的，后来看到一篇P党题解，想着救星来了，结果看到第一句话：**如果你后面5个点没过的话，你可以尝试使用ansistring（加长字符串）**。

![这也太TND坑爹了吧](https://cdn.luogu.com.cn/upload/pic/49540.png)

WTF？！

试了一下，AC代码：

```pascal
var s:array[1..1000,1..100]of ansistring;n,m,i,j,k:longint;ss:ansistring;l:array[1..1000]of ansistring;//定义这过于神奇的变量
begin
 readln(n,m);//读入
 for i:=1 to m do
  begin
   readln(ss);//读入待处理的字符串
   ss:=ss+' ';//注意！这里为了方便循环，需要加上一个空格
   for j:=1 to n do//循环取单词（由于Pascal不像C++可以忽略空格，所以得手动取）
    begin
     k:=pos(' ',ss);//找空格
     s[i,j]:=copy(ss,1,k-1);//将单词存起来
     delete(ss,1,k);//删减片段
    end;
  end;
 for i:=2 to m do//对比字符串是否一致
  for j:=1 to n do
   if s[i,j]<>s[i-1,j] then
    l[j]:='*';//不一致便标记
 for i:=1 to n do//将一致的标记为单词
  if l[i]<>'*' then
   l[i]:=s[1,i];
 for i:=1 to n-1 do//输出
  write(l[i],' ');
 writeln(l[n]);
end.
```

管理员给给过吧，我希望更多的人能看到这个（BUG）？？？

---

## 作者：Strange_S (赞：0)

看了很多大佬的做法，觉得有点麻烦

其实这题很简单，只要你知道一个叫'map'的库，可以自己先上网上查查

我的思路是：把这些词出现的次数都存下，如果跟m相等的话就是确定的，反之如果不是就要用'*'号

先上代码，在代码中讲解
```cpp
#include<iostream>
#include<cstdio>
#include<map>
using namespace std;
map<string,int>sum;             //这是这个库的基本用法，也可以是'map<int,string>sum'
int n,m;
string s;
int main(){
	int i,j;
	scanf("%d %d",&n,&m);
	for(i=1;i<=m;i++){
		for(j=1;j<=n;j++){
			cin>>s;
			sum[s]++;          //这就是这个库的神奇之处，简单说，就是将字符串形式转换成整型，或整型转换成字符串
			if(i==m){          //然后判断有没有到最后
				if(sum[s]==m){ //如果到了就判断这个词出现次数是不是全出现
					cout<<s<<" ";
				}else{
					cout<<"* ";
				}
			}
		}
	}
	return 0;
}
```
很水的一道题

---

## 作者：wd050602 (赞：0)

这个题的题解，我来一发吧！！

思路：判断每一个元素，只要有不同的就证明它是无关紧要的，记住，字符串第一行用来做原本的对照。

废话不多说，直接上代码。

【code】\

```cpp
#include <bits/stdc++.h>//
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstdlib>
#include <string>
#include <iomanip>
#include <cstring>
#include <ctime>
#include <algorithm>
#include <queue>
#include <string.h>
using namespace std;
string s[105];
bool a[105];
int main(){
    int n,m;
    string c;
    scanf("%d%d",&n,&m);
    m--;
    for(int i=0;i<n;i++){
        cin>>c;
        s[i]=c;
```
}//存储”样本“
```cpp
    while(m--){
        for(int i=0;i<n;i++){
            cin>>c;
            if(s[i]!=c){
                a[i]=1;//判断不同
            }
        }
    }
    for(int i=0;i<n;i++){
        if(a[i]){
            printf("* ");
        }
        else{
            cout<<s[i]<<" ";
        }
    }
    printf("\n");//输出，完美结束
    return 0;
}
```
【code】\
头文件打得有点多，不要吐槽（其实只要第一个就行了）


---

## 作者：吃的 (赞：0)

详见注释 ~~我就是要写类模板~~
~~~

#include <iostream>
#include <cstdio>
#include <string>
using namespace std;
template <typename value_type>//模板 
class note{
	private://这是私有成员 
        value_type data;
    public://公共的 
    	//构造函数 
        note(){}
        note(value_type input){
			data = input;
		}
		//双目算术运算符 
		note operator + (const note &another){
        	note<value_type>new_note(data + another.data);
        	return new_note;
        }
        note operator - (const note &another){
        	note<value_type>new_note(data - another.data);
        	return new_note;
        }
        note operator * (const note &another){
        	note<value_type>new_note(data * another.data);
        	return new_note;
        }
        note operator / (const note &another){
        	note<value_type>new_note(data / another.data);
        	return new_note;
        }
        note operator % (const note &another){
        	note<value_type>new_note(data % another.data);
        	return new_note;
        }
        //单目运算符
        note operator-(){
        	data = -data;
        	return *this;
		}
		note operator!(){
			return !data;
		}
		//自增自减运算符	
		note operator++(){
			data++;
			return *this;
		}
		note operator++(int){
			note<value_type>old;
			old = *this;
			data++;
			return old;
		}
		note operator--(){
			data--;
			return *this;
		}
		note operator--(int){
			note<value_type>old;
			old = *this;
			data--;
			return old;
		}
        //关系运算符
		bool operator == (const note &another){
        	return data == another.data;
        }
        bool operator != (const note &another){
            return data != another.data;
        }
        bool operator >= (const note &another){
        	return data >= another.data;
        }
        bool operator <= (const note &another){
            return data <= another.data;
        }
        bool operator > (const note &another){
        	return data > another.data;
        }
        bool operator < (const note &another){
            return data < another.data;
        }
		//位运算符
		note operator | (const note &another){
			return data | another.data;
		} 
		note operator & (const note &another){
			return data & another.data;
		} 
		note operator ~ (){
			return ~data;
		} 
		note operator ^ (const note &another){
			return data ^ another.data;
		} 
		note operator << (const note &another){
			return data << another.data;
		} 
		note operator >> (const note &another){
			return data >> another.data;
		} 
		
		//赋值运算符
		void operator = (const value_type &another){
            data = another;
        }
        note operator += (const note &another){
        	data += another.data;
        	return *this;
        }
        note operator -= (const note &another){
        	data -= another.data;
        	return *this;
        }
        note operator *= (const note &another){
        	data *= another.data;
        	return *this;
        }
        note operator /= (const note &another){
        	data /= another.data;
        	return *this;
        }
        note operator %= (const note &another){
        	data %= another.data;
        	return *this;
        }
        note operator &= (const note &another){
        	data &= another.data;
        	return *this;
        }
        note operator |= (const note &another){
        	data |= another.data;
        	return *this;
        }
        note operator ^= (const note &another){
        	data ^= another.data;
        	return *this;
        }
        note operator <<= (const note &another){
        	data <<= another.data;
        	return *this;
        }
        note operator >>= (const note &another){
        	data >>= another.data;
        	return *this;
        }
		//其他运算符 
        value_type& operator[](int i){
        	return data[i];
		}
        //流读入 输出 
        friend ostream &operator<<( ostream &output,const note &out)
      	{ 
      	   	output << out.data;
        	return output;            
      	}
       	friend istream &operator>>( istream  &input, note &in )
      	{ 
        	input >> in.data;
         	return input;            
      	}
      	//本身
		value_type self(){
			return data;
		}
};
int main(){
    note<int>m,n;//声明整型note变量
    cin >> n >> m;//流读入
    note<string>temp[n.self()+1],t;//t是临时变量，用于读入
    for (note<int>i(1);i<=n;++i)
        cin >> temp[i.self()];//temp存下第一组数据的内容
        					  //与之后的比较，进行判重 
    for(note<int>k(1);k<m;++k )
        for (note<int>i(1);i<=n;++i){
            cin >> t;//读入
            if (t != temp[i.self()])
            	temp[i.self()] = "*";//判重
        }
    for (note<int>i(1);i<=n;++i)//输出
        cout << temp[i.self()].self() << " ";
    return 0;
} 

~~~

---


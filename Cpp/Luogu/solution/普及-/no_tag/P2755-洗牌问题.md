# 洗牌问题

## 题目描述

有 $ 2n $ 张牌，编号为

$$ 1,2,3 \dots n,n+1, \dots 2n$$

这也是最初的牌的顺序。一次洗牌是把序列变为

$$ n+1,1,n+2,2,n+3,3,n+4,4 \dots 2n,n $$

可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。

现给定 $n$（$n \le 10^8$），求出 $ m $ 的值。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 10^8$。

## 样例 #1

### 输入

```
20```

### 输出

```
20```

# 题解

## 作者：kradcigam (赞：33)

## 这是本人的第一篇题解
### 请多多宽恕 
**这一道题其实不要用数组**

我们来观察一下n=3时的情况：

原：
1 2 3 4 5 6

4 1 5 2 6 3

2 4 6 1 3 5

1 2 3 4 5 6

我们去观察2的位置

第一次的位置：2

第二次的位置：4

第三次的位置：1

因为2是前半堆牌，所以可以直接乘2，所以我们发现4是2的倍数

因为4是后半堆牌，所以是要先找到它对应的前面的牌——4-3，然后找到它的位置，（4-3）*2，然后后面的牌是在它对应的前面牌的位置-1，所以，是（4-3）*2-1，我们算一下，发现是1，确实是正确答案，所以，我的方法是对的

我们来用程序实现

用i来模拟，就得出了这样一个公式
```cpp
if(i>n)i=(i-n)*2-1;//如果它在后半堆，找到它对应的前面的牌，算出它对应的前面的牌的位置，再-1
else i=i*2;//如果它在前半堆，直接乘以2
```
那么AC代码是
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n,i=1,s=0;//只要第1张牌回到了初始位，整付牌就回到了初始状态
    cin>>n;//读入
    do{
    	if(i>n)i=(i-n)*2-1;//如果它在后半堆，找到它对应的前面的牌，算出它对应的前面的牌的位置，再-1
    	else i=i*2;//如果它在前半堆，直接乘以2
		s++;
	}while(i!=1);
	cout<<s;
    return 0;
}```

---

## 作者：Terrible (赞：19)

### 这个题解是数论的方法，想用模拟做本题的同学另寻他路吧。
（标签没有贴**模拟**啊，然后就没有然后了）

[这个](https://www.luogu.com.cn/record/5879391)是我去提交记录里转了一圈发现的 [will7101](https://www.luogu.com.cn/user/15326)[![金钩](https://cdn.luogu.com.cn/upload/image_hosting/x5gvzsbs.png)](https://www.luogu.com.cn/discuss/show/142324)巨佬的提交记录，太强了，本蒟蒻介绍一下大佬的做法。

## 思路：欧拉定理+枚举因数

$$1,2,3...n,n+1,...2n$$

变换到

$$n+1,1,n+2,2,n+3,3,n+4,4...2n,n$$

从中可以发现编号为 $i(i\leqslant n)$ 的牌会变换到 $2i$；

编号为 $i(i>n)$ 的牌会变换到 $2i\mod{(2n+1)}$ 的位置；

所以对于编号 $i(i\leqslant 2n)$ 的牌一次变换会到 $2i\mod{(2n+1)}$ 的位置。

而且容易发现每一张牌在牌堆第一次重新得到初始的顺序之前都不在原来的位置。可以直接选择**1 号牌**作为代表，**1 号牌第一次重新回到原位置所需洗牌次数**即为所求。

$$2^k\equiv1\pmod{(2n+1)}(k>0)$$

上式 **k 的最小正整数**解即为所求。

因为 $2$ 与 $2n+1$ 互质，所以：

根据[**欧拉定理**](https://baike.baidu.com/item/欧拉定理/891345?fr=aladdin)：$2^{\phi(2n+1)}\equiv1\pmod {(2n+1)}$.

但是求出来的 $\phi(2n+1)$ 并不一定是**最小的解**（也就是**循环节**）。

我们试着**暴力打个表**看看：

（下面图片：$f(n)$ 表示**关于** $n$ **的最小解**，$\phi(2n+1)$ 表示复合**欧拉函数**。数论函数就是这么乱中有序！）

![phi(2n+1)和f(n)](https://s3.bmp.ovh/imgs/2023/03/20/2802b4bcbb2d729b.png)

（下面图片：表示 $g(n)=\frac{\phi(2n+1)}{f(n)}$，这张图中的**比值都是正整数**，也就意味着 $\phi(2n+1)$ 是**循环节**的**整数倍**。）

![phi(2n+1):f(n)](https://s3.bmp.ovh/imgs/2023/03/20/1cd18064503921ce.png)

#### 容易想到的是：

$\phi(2n+1)$ 是个**大的循环节**（也可能就是循环节），由若干**小的循环节**拼接而成，那么正解一定是 $\phi(2n+1)$ 的**因子**。（本蒟蒻显然是不会证明的）

废话不多说，直接从 $1$ 枚举到 $\sqrt{\phi(2n+1)}$ 找因子，把找到的**两个因子**（显然找出来的是一对）代入**快速幂**里面验证一下是否满足方程 $2^k\equiv1\pmod {(2n+1)}$ 即可。

时间复杂度：$\Theta(n)=\sqrt{\phi(2n+1)}$，比暴力模拟快。

第七个测试点输入为 $0$（话说 $0$ 张牌洗来洗去不是玄学问题吗？），并没有卡掉下面的代码。

## 代码
```cpp
#include<cstdio>
#include<cmath>
int phi(int x)//欧拉函数 
{
	int p=x;
	for(int i=2;i*i<=x;++i)
		if(x%i==0)
		{
			p-=p/i;
			while(x%i==0)x/=i;
		}
	if(x>1)p-=p/x;
	return p;
}
int fp(int q,int p,int MOD)//快速幂 
{
	long long a=q%MOD,ans=1;
	while(p)
	{
		if(p&1)ans*=a,ans%=MOD;
		a*=a,a%=MOD,p>>=1;
	}
	return ans;
}
int main()
{
	int n,m,p,t,e;
	scanf("%d",&n);
	m=2*n+1,p=phi(m),t=p,e=sqrt(p);
	for(int i=1;i<=e;i++)//枚举因子，一个是i，另一个是p/i
		if(fp(2,i,m)==1)
		//欧拉定理的特解可能大于循环节
		//循环节一定是φ(2n+1)的因子
		{
			t=i;
			break;//从前往后找到了解，一定是最小的
		}
		else
		{
			if(fp(2,p/i,m)==1)t=p/i;
			//从后往前找的解不一定是最小的，暂存一下
		}
	printf("%d",t);
}
```

---

## 作者：Dr_殇 (赞：7)

#一道简单的模拟题，主要关注数字1下标，下面做一下当n=5时的模拟：


##未模拟时：1 2 3 4 5 6 7 8 9 10          这时1的下标为1

##一次模拟：6 1 7 2 8 3 9 4 10 5          这时1的下标为2

##二次模拟：3 6 9 1 4 7 10 2 5 8          这时1的下标为4

##三次模拟：7 3 10 6 2 9 5 1 8 4          这时1的下标为8

##四次模拟：9 7 5 3 1 10 8 6 4 2          这时1的下标为5

##五次模拟：10 9 8 7 6 5 4 3 2 1          这时1的下标为10

##六次模拟：5 10 4 9 3 8 2 7 1 6          这时1的下标为9

##七次模拟：8 5 2 10 7 4 1 9 6 3          这时1的下标为7

##八次模拟：4 8 1 5 9 2 6 10 3 7          这时1的下标为3

##九次模拟：2 4 6 8 10 1 3 5 7 9          这时1的下标为6

##十次模拟：1 2 3 4 5 6 7 8 9 10          这时1的下标为1


#这时你就会发现，只要1的下标k回到了原点，那么其他元素也回到了原点，并且：1的下标k如果大于n，那么1的下标k就要从k变为2\*(k-n)-1；如果1的下标k小于等于n，那么1的下标k就要从k变为2\*k。也就是说，1的下标k可得以下程序段：


if(k>n)k=2\*(k-n)-1;

else k\*=2;

#也就是说，如果你找到以上程序段，那么这题就好解了。


##现在，呈上代码。

##代码如下：




        

```cpp
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int n,m;
int main(){
    freopen ("2755.in","r",stdin);
    freopen ("2755.out","w",stdout);
    scanf ("%d",&n);//读入数据
    int k=1;//1的下标k的初值为1
    while (1){//主程序代码
        if (k>n)k=2*(k-n)-1;//判断1的下标k是否大于n，如果大于，那么就将k赋为2*(k-n)-1；如果小于等于，就将k赋为k*2
        else k*=2;
        m++;//答案加1
        if (k==1)break;//判断如果1的下标k回到了起点，就退出程序
    }
    printf ("%d\n",m);//最后输出
        while (1)//反抄袭
    return 0;
}
```
#注意：m++这个语句必须在退出判断之后，否则最后答案就会少一

---

## 作者：Minclxc (赞：5)

总共有2n张牌，我们先用代数求出牌i下一个位置

对于前n张牌，下一个为2i，对于后n张牌，下一个为2i-(2\*n+1)

所以，对于任意一张牌i，下一个位置为2i%(2\*n+1)

基于这个原理，假设x次洗牌后回到原处，及 ![](https://cdn.luogu.com.cn/upload/pic/6412.png) ，

根据费马小定理，因为2和2\*n+1互质，所以x最大为2\*n

直接暴力乘2\*n次，判断2^x是否为1，输出就可以了

当然x的值还可以是2\*n的因数，所以可以分解质因数优化

下面程序是暴力的

```cpp
#include<cstdio>
using namespace std;
int main(){
    int n,m=1;scanf("%d",&n);
    for(int x=2;x!=1;x=x*2%(2*n+1),m++);
    printf("%d\n",m);
    return 0;
}
```

---

## 作者：EarthGiao (赞：3)

首先观察切牌方法，最容易看到的是1、2...n号位全都对应变到2、4...2n号位。（i*2）

n+1、n+2...2n号位不容易看出规律，但要注意的是，变换后相邻两个数差距变大一位（例：n+1和n+2现在中间隔着一个1），这还是乘2的表现，只是位置前移，说明要%一个数，观察知道%（2n+1）。

问题转化为i*（2^x)=i (mod 2n+1)    i是1到2n+1的每个数。 即2^x=1 （mod 2n+1）

n不大，暴力。


```cpp
#include <iostream>
using namespace std;

int main()
{
    int n,i,ans;
    cin>>n;
    i=1; ans=0;
    do 
    {
        i=(i*2)%(2*n+1);
        ans++;
    }
    while (i!=1);
    cout<<ans<<endl;
}
```


---

## 作者：RagnaLP (赞：3)

首先这是一道模拟，并没有牵扯到什么高深的数论。至于怎么模拟，嗯。。。。。不如先看看按照题意暴力打，会有什么结果。

先上一段观察规律的码


```cpp
#include<iostream>
using namespace std;
int map[105][105]={0};
int n;
int main() {
    //freopen("text.txt","w",stdout);
    cin>>n;
    for(int i=0;i<(n<<1);i++){
        map[0][i]=i+1;
```
}//初始化没洗牌之前的样子

```cpp
    int i=1;//当前洗牌的次数
    do{
        for(int j=0;j<(n<<1);j+=2){//每次放两个
            map[i][j]=map[i-1][(j>>1)+n]; //将上一次的n+j/2放到j/2
            map[i][j+1]=map[i-1][(j>>1)];//还要将上一次的j/2放到j/2+1
        }
        for(int j=0;j<(n<<1);j++){
            cout<<map[i][j]<<" ";
        }
        cout<<endl;
        i++;
    }while(map[i-1][0]!=1);//如果已经回到初始点，跳出循环
    return 0;
}
```
所以来看看n=4时的样子
5 1 6 2 7 3 8 4

7 5 3 1 8 6 4 2

8 7 6 5 4 3 2 1

4 8 3 7 2 6 1 5

2 4 6 8 1 3 5 7

1 2 3 4 5 6 7 8


再来看看1的位置

1（初始） 2 4 8 7 5 1

这就好办了

如果1的位置超过n，下一次就在（当前位置-n)\*2-1的地方

不然就\*2

所以代码就出来了


```cpp
#include<iostream>
using namespace std;
int main() {
    int n;
    cin>>n;
    int i=1,cc=0;//i表示1的位置，cc表示洗牌的次数
    do{//一定要先执行一次，不然就会直接退出
        if(i>n) 
            i=((i-n)<<1)-1;//位运算会快些
        else i<<=1;
        cc++;
    }while(i!=1);//是不是很简单？？
    cout<<cc;
    return 0;
}
```

---

## 作者：frank520 (赞：2)

# 蒟蒻的第二篇题解lalala
# 第七个点一直过不去TLE的看过来

### 起因 

我们在机房考试。。。

### 分析

~~打表出奇迹，暴力进省一~~（误）

我们以4为例模拟一下这个过程

|1  | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 5 | 1 | 6 | 2 | 7 | 3 |  8|  4|
| 7 |  5| 3 |  1|  8| 6 |  4| 2 |
| 8 | 7 | 6 |  5| 4 | 3 |  2|  1|
| 4 |8  | 3 |7  | 2 |6  |  1|5  |
| 2 | 4 |6  |  8| 1 | 3 | 5 | 7 |
| 1 | 2 | 3 |  4| 5 |6  |  7|8  |


经过我的秃头，放弃了找规律的想法。注意到“1”只在第一次和最后一次在表格中出现，所以我们只需要找下一次第一个是1的数列就可以了

我们又可以观察到(自己找)，对于数列里的第i个元素，如果1<=i<=n，则它变化后的位置对应为2*i； 而如果n+1<=i<=2*n，其对应的位置为（i-n）*2-1（只需要追踪第一个的位置，不然可能会爆）

## 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,i=1,tot=0;//以i来追踪1的位置 
	scanf("%d",&n);
	do{//选择先do的原因是第一次输入时i也为1 
		if(n==0){
			printf("1");
			return 0;
		}//老阴间了 
		if(i>0&&i<=n) i*=2;//对应2*i 
		else if(i>n&&i<=2*n) i=(i-n)*2-1;//对应（i-n）*2-1 
		tot++;//计数器，洗牌次数 
	}while(i!=1);//在i下次为1时，跳出循环 
	printf("%d",tot);//输入 
	return 0;
}
```

第七个点的数据，经过机房小伙伴不懈的WA，终于得出了输入为0时要求输出为1才能过

老阳间人儿了

### 感谢资瓷：）

（希望洛谷能把那个**~~阳间~~**数据改一下）

---

## 作者：千尘ゞ (赞：1)

###看看为什么没人过，原来是数据的错。

**其实蛮简单的，只是有点烦。**

首先从n=1开始模拟牌的顺序，在多次模拟后可以发现，当1号牌回到原位时，其他牌也回到了原位。

##          (具体过程请自己动手写写画画）

#所以只要跟着1号牌看看就可以了。

C++党福利：（代码不长，但要仔细研究）

```cpp
-#inciude<cstdlo>-
-    #incIude<cstdllb>-
-    #lnciude<cstrlng>-
-using namespace std;-
-int n,ans;-
-int main(){-
    -    freopen("card.in","r",stdin);-    //文件输入输出不解释
-        freopen("card.out","w",stdout);-
-        scanf("%d",&n);-
-        int p=1;-     //p代表1号牌的位置
-        do{-           //至少要做一次
-                if (p>n) p=2*(p-n)-1;else p*=2;-
-                ans++;-
-        } while (p!=1);-      //1号牌没回去就不停
-        printf("%d\n",ans);-
-        return 0;-
-}-
```

#由于为了防止有人抄代码，挖了一些小小的坑。[手动滑稽]


---


# 纸币问题 3

## 题目背景

你是一个非常有钱的小朋友。

**注意：** 本题和《进阶篇》的对应题目，输入格式略有差异。

## 题目描述

你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，请问有多少种纸币组合能恰好支付金额 $w$，答案对 $10^9+7$ 取模。

## 说明/提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i , w\le 10^4$。

其实小朋友并不有钱。

## 样例 #1

### 输入

```
6 15
1 5 10 20 50 100```

### 输出

```
6```

## 样例 #2

### 输入

```
3 15
1 5 11```

### 输出

```
5```

# 题解

## 作者：封禁用户 (赞：16)

## 题意

本题题目描述简短，不多赘述。

## 思路


由于是组合计数问题，需要考虑到纸币种类这个阶段以及每次加入一种新纸币产生的贡献。

所以使用状态 $f_{i,j}$ 表示只用前 $i$ 种纸币凑到金额 $j$ 的方案数。

于是有以下两种情况：

1. 用了若干张 $a_i$，此时前继状态为 $f_{i,j-a_i}$,由此转移即可。

2. 没有用一张 $a_i$，直接 $f_{i-1,j}$ 转移即可。

注意：需要初始化边界条件 $f_{i,0} \gets 1$。

贴出代码为：

```cpp
for(int i = 1; i<=n; i++) {
	for(int j = 0; j <= w; j++) {
		if(j < a[i]) {
			f[i][j] = f[i-1][j];
		}
		else {
			f[i][j] = f[i][j-a[i]] + f[i-1][j];
			f[i][j] %= mod;
		}
	}
}
```

时间复杂度为 $O(nw)$，空间复杂度为 $O(nw)$，足以通过此题。

但是空间还可以再做优化，观察到 $f$ 的第一维 $i$ 只与 $i-1$ 有关，这样的转移是不必要的，直接去掉即可。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e3 + 5;
const int W = 1e4 + 5;
const int inf = 2e9;
const int mod = 1e9 + 7;
int n,w;
int a[N];
int f[W];

int main() {
	cin>>n>>w;
	for(int i = 1; i<=n; i++) {
		cin>>a[i];
	}
	f[0] = 1; //边界
	for(int i = 1; i<=n;i++) {
		for(int j = a[i]; j<=w; j++) {
			f[j] += f[j - a[i]] % mod;
			f[j] %= mod;
		}
	}
	cout<<f[w]<<endl;
	return 0;
}
```



---

## 作者：timmark (赞：9)

# P2834 题解

## 题意简述：

用 $n$ 种纸币，第 $i$ 种的面值为 $a_i$ 且有无限张，问凑出 $w$ 元有多少种纸币**组合**。

## 部分分

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；

我们看到 $n$ 和 $w$ 都很小，那肯定爆搜啊！

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,a[1005],ans;
const int mod=1e9+7;
void dfs(int step,int now,int sum){
//step表示现在使用的纸币数量，now表示使用到了第几种纸币，sum表示现在的纸币面额总和。
    if(sum>w) return ;
    if(sum==w){//得到合法答案
        ans=(ans+1)%mod;
        return ;
    }for(int i=now;i<=n;i++) dfs(step+1,i,sum+a[i]);//继续搜索
}int main(){
    cin >> n >> w ;
    for(int i=1;i<=n;i++) cin >> a[i] ;
    sort(a+1,a+n+1);//排序，纸币面额要单增
    dfs(0,1,0);
    cout << ans ;
	return 0;
}
```


## 正解做法

我们考虑怎么设计状态。

设 $f_{i,j}$ 为只考虑前 $i$ 种纸币来凑出 $j$ 元的方案数。

那么考虑两种情况：

- 不使用第 $i$ 种纸币，那么方案数为 $f_{i-1,j}$。
- 使用第 $i$ 种纸币，那么先凑出 $f_{i,j-a_{i}}$ 元，再使用 $1$ 张第 $i$ 种纸币。

综上，得到转移方程为：

$$

f_{i,j}=
\begin{cases}
0 & i,j\le 0\\
f_{i-1,j} & j<a_i\\
f_{i-1,j}+f_{i,j-a_i} & otherwise
\end{cases}
$$

注意取模。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,a[1005],f[1005][10005];
const int mod=1e9+7;
int main(){
	cin >> n >> w ;
	for(int i=1;i<=n;i++) cin >> a[i] ;
	f[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=w;j++){
			f[i][j]=f[i-1][j];
			if(j>=a[i]) f[i][j]=(f[i][j]+f[i][j-a[i]])%mod;
		}
	}cout << f[n][w] ;
	return 0;
}
```

---

## 作者：N1K_J (赞：5)

前置知识：01 背包

完全背包的板子。

令 $dp[i][j]$ 表示前 $i$ 种面值纸币有多少种办法支付价格 $j$。第 $i$ 种纸币面值为 $a[i]$

很显然：

$$dp[i][j] = dp[i-1][j-a[i]]+dp[i-1][j-2*a[i]]+\dots$$

通过 01 背包的学习，我们可以发现完全背包同样可以用滚动数组省去第一维。

接下来直接看代码更好理解：

```cpp
for(ll i = 1; i <= n; i++){
	for(ll j = a[i]; j <= m; j++){
		dp[j]+=dp[j-a[i]];
		dp[j]%=Mod;
	}
}
```

在代码中，我没对于每一个面值 $j$，将其从小向大枚举，对于 $dp[j]$，我们通过这种枚举方式保证了 $dp[1,2,3,\dots,j-1]$ 都已经计算好，那么 $dp[j-a[i]]$ 相当于拿出一枚 $a[i]$ 元纸币，再用前 $i$ 种纸币来支付剩余的 $j-a[i]$ 元，显然，这样计算是正确的。

附上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Mod = 1e9+7;
const ll N = 1010;
const ll M = 10010;
ll n,m,a[N],dp[M];
int main(){
	scanf("%lld%lld",&n,&m);
	for(ll i = 1; i <= n; i++) scanf("%lld",&a[i]);
	dp[0] = 1;
	for(ll i = 1; i <= n; i++){
		for(ll j = a[i]; j <= m; j++){
			dp[j]+=dp[j-a[i]];
			dp[j]%=Mod;
		}
	}
	printf("%lld",dp[m]);
	return 0;
}
```

---

## 作者：ZepX_D (赞：3)

简单的计数 DP ，我们可以设 $ f_{i,j} $ 为前 $i$ 种纸币恰好凑出 $j$ 的方案数，可写出以下代码：
```cpp
#include <cstdio>
#include <iostream>

using namespace std;

inline int read()
{
	int x = 0,f = 1;char ch = getchar();
	while(!isdigit(ch)) (ch == '-') && (f = -1),ch = getchar();
	while(isdigit(ch)) x = x*10+ch-48,ch = getchar();
	return x*f;
}

const int P = 1e9+7;
int a[1010],f[1001][10010];

int main()
{
	int n = read(),w = read();
	for (int i = 1;i <= n;i++) a[i] = read();
	f[0][0] = 1;
	for (int i = 1;i <= n;i++)
	{
		for (int j = 0;j <= w;j++)
		{
			if (j < a[i]) f[i][j] = f[i-1][j];
			else
				for (int k = 0;k*a[i] <= j;k++)
					f[i][j] = (f[i][j]+f[i-1][j-k*a[i]])%P;
		}
	}
	cout << f[n][w];
	return 0;
}
```

时间和空间复杂度都很劣，但我们容易发现 $ f_i $ 只依赖于 $ f_{i-1} $ ，所以可以优化一下空间，给出核心代码：
```cpp
	for (int i = 1;i <= n;i++)
	{
		bool g = i&1;
		for (int j = 0;j <= w;j++)
		{
            f[g][j] = 0;
			if (j < a[i]) f[g][j] = f[g^1][j];
			else
				for (int k = 0;k*a[i] <= j;k++)
					f[g][j] = (f[g][j]+f[g^1][j-k*a[i]])%P;
		}
	}
	cout << f[n&1][w];
```
空间确实是够了，但是这样时间复杂度还是很劣，而且二维数组看起来也不优美，我们设 $ f_j $ 为凑出$ j  $ 的方案数，那么我们在第二层循环的时候顺序枚举 $ f_j $ ，就可以确保计算 $ f_j $ 时 $ f_{j-a_i } $保存的是 $ f_{i-1,j-a_i} $ 的值，所以我们就可以滚动数组滚掉一维：
```cpp
	for (int i = 1;i <= n;i++)
		for (int j = a[i];j <= w;j++)
			f[j] = (f[j]+f[j-a[i]])%P;
	cout << f[w];
```
这样时间和空间都优化掉一层，十分的优美。

---

## 作者：幻想繁星 (赞：3)

定义 $f_i$ 为凑出 $i$ 元的纸币方式数，因此答案是 $f_w$。

初始化 $f_0=1$，因为凑出 $0$ 元只有一种方式。

对于凑出 $x$ 元（即 $f_x$），我们可以用一张面值为 $k$ 的纸币加上凑出 $x-k$ 的各种方案凑出。

所以我们可以枚举 $k$（即 $a_i$），去更新 $f_x$；

可写出如下代码：

```c
for(int i=1;i<=n;i++)
    for(int j=a[i];j<=w;j++)
    	f[j]=(f[j]+f[j-a[i]]);
```

---

## 作者：Kobe_BeanBryant (赞：2)

### 题目理解：
将 $ n $ 种面额互不相同的纸币，第 $ i $ 种纸币的面额为 $ a_i $ 并且有无限张，组合成金额为 $ w$，答案对 $ 10^9+7 $ 取模。

讲题目简化一下得到：所有比每一张纸币 $ i $ 面额小的纸币的方案数之和。
### AC代码：
头文件加定义：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e9+7;
long long n,w;
long long a[1005],k[1005]={1};//标记
```
主程序：
```cpp
int main(){
	scanf("%lld%lld",&n,&w);//输入n种面额互不相同的纸币和面额 w的纸币
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);//输入n种纸币的面额
	for(int i=1;i<=n;i++)
	for(int j=a[i];j<=w;j++) k[j]+=k[j-a[i]]%N,k[j]%=N;//暴力出奇迹
	printf("%lld\n",k[w]);//输出种类个数
	return 0;
}
```
完结，撒花！

---

## 作者：Yashajin_Ai (赞：2)

### 前言
第一眼看见很像[数楼梯](https://www.luogu.com.cn/problem/P1255)呀，所以运用了这种思路去思考这道题，~~当然不是用斐波拉契~~。

### 思路简介
首先，很明显能观察到对于每一张纸币 $i$，它的方案数就是所有比它面额小 $k$ 的纸币的方案数之和。

于是我联想到[数楼梯](https://www.luogu.com.cn/problem/P1255)的递推法，所以同样是用的递推，每输进来一个数，就加上 $a_{j-k}$ 的组合方案数得到 $a_j$ 新的组合方案数。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int main(){
	int a[1001],k;
	a[0]=1;
	int n,w;
	cin>>n>>w;
	for(int i=1;i<=n;i++){
		cin>>k;
		for(int j=k;j<=w;j++){
			a[j]=(a[j]+a[j-k])%mod;
		}
	}
	cout<<a[w];
} 
```

### 温馨提示
与[数楼梯](https://www.luogu.com.cn/problem/P1255)一样的一点是 $a_0$ 要赋值为 $1$，因为组成 $0$ 元的方案数是 $1$ 种。

---

## 作者：Ruiqun2009 (赞：1)

首先，很明显能观察到对于每一张纸币 $i$，它的方案数**就是所有比它面额小的纸币的方案数之和**。于是不难写出这样的记忆化搜索：
```cpp
int dp[200005], arr[200005], n;
int dfs(int x) {
    if (dp[x]) return dp[x];
    for (int i = 0; i < n; i++) if (arr[i] < arr[x]) (dp[x] += dfs(i)) %= MOD;
    return dp[x];
}
```
我们换一种角度来看待这张有向无环图。其实还有另外一种转移方式：枚举每一个比当前面值 $a$ 大的面值 $b$，其总数加上与当前面额 $a$ 之差 $b-a$ 的方案数。

于是就有了：
```cpp
#include <cstdio>
#include <algorithm>
using std::max;
int arr[10001];
int dp[10000001];
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
        for (int j = arr[i]; j <= m; j++) dp[j] = (dp[j] + dp[j - tim[i]]) % 1000000007;
    }
    printf("%d\n", dp[m]);
}
```

---

## 作者：zzx0102 (赞：0)

太难了，不会！！！

想着先骗点分数。

对于 $40\%$ 的数据，$1\leq n \leq 10,1\leq w\leq 100$。

爆搜啊！！！

直接枚举每一个货币选多少个，即可获得 $40$ 分的好成绩。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 10010, p = 1e9 + 7; int n, w; int a[N], cnt;
void dfs(int x, int sum) {
	if(sum == w) {cnt = (cnt + 1) % p; return ;}
	if(x == n + 1) return ;
	for(int i = 0; sum + i * a[x] <= w; i++) {
		dfs(x + 1, sum + i * a[x]);
	}
}
signed main() {
	cin >> n >> w; for(int i = 1; i <= n; i++) cin >> a[i];
	dfs(1, 0); cout << cnt;
	return 0;
}
```

可是，再怎么办啊？~~橙题做不出来肯定很丢人。~~

于是，考虑将我们 dfs 传入的参数 $i,sum$ dp 一下，二维，空间正好够用，于是就可以开设 $dp_{i,j}$ 表示前 $i$ 个货币凑 $j$ 元的价格的方案数。

于是转移方程就是 $dp_{i,j+k\times a_i}=dp_{i-1,j}$。

意思是选第 $i$ 个，之前选了 $j$，那么可能的价值就是 $j+k\times a_i$。

别忘记判断越界和取模。

虽然理论复杂度 $O(n\times w^2)$，不过考虑到 $a_i$ 互不相同，其实也跑不满，配合你谷神机，还是能过的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1010, p = 1e9 + 7; int n, w; int a[N], dp[N][N * 10];
void add(int &x, int y) {x = (x + y) % p;}
signed main() {
	cin >> n >> w; for(int i = 1; i <= n; i++) cin >> a[i]; dp[0][0] = 1;
	for(int i = 1; i <= n; i++)
		for(int j = 0; j <= w; j++)
			for(int k = 0; j + k * a[i] <= w; k++)
				add(dp[i][j + k * a[i]], dp[i - 1][j]);
	cout << dp[n][w] << endl;
	return 0;
}
```

无 O2：389ms

有 O2：163ms

注意这里说的是最慢的点的时效，还是相当快的。

---


# 纸币问题 2

## 题目背景

你是一个非常有钱的小朋友。

## 题目描述

你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，求问有多少种方式可以支付面额 $w$，答案对 $10^9+7$ 取模。  
注意在这里，同样的纸币组合如果支付顺序不同，会被视作不同的方式。例如支付 $3$ 元，使用一张面值 $1$ 的纸币和一张面值 $2$ 的纸币会产生两种方式（$1+2$ 和 $2+1$）。

## 说明/提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i , w\le 10^4$。

其实小朋友并不有钱。

## 样例 #1

### 输入

```
6 15
1 5 10 20 50 100```

### 输出

```
42```

## 样例 #2

### 输入

```
3 15
1 5 11```

### 输出

```
39```

# 题解

## 作者：HappyCode (赞：21)

定义 $f_i$ 为凑出 $i$ 元的纸币方式数，因此答案是 $f_w$。

需要初始化 $f_0=1$，因为凑出 $0$ 元只有一种方式，就是不给钱。

凑出 $i$ 元的组方式是 $i$ 分别减去每种纸币面额的方式数的和，即 $\sum_{j=1}^n f_{i-a_j}$。状态转移方程如下。

$$f_i=\sum_{j=1}^n f_{i-a_j}$$

注意取模。注意数组溢出。

```cpp
#include<iostream>
using namespace std;
int n,w,a[1005],f[10005];
const int mod=1e9+7;
int main(){
    cin>>n>>w;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    f[0]=1;
    for(int i=1;i<=w;i++){
        for(int j=1;j<=n;j++){
            if(i-a[j]>=0){
                f[i]=(f[i]+f[i-a[j]])%mod;
            }
        }
    }
    cout<<(f[w]%mod)<<endl;
    return 0;
}
```

---

## 作者：timmark (赞：8)

# P2840 题解

一道经典 DP。

[**原题目**](https://www.luogu.com.cn/problem/P2840)

我们考虑一下这道题如何设计状态。

设 $f_i$ 为凑出 $i$ 元钱的方法数量，那么答案就等于 $f_w$。

接下来思考转移。

假设现在要凑 $i$ 元，有一张 $a_j$ 元的纸币，那么我们可以得到 $f_i=f_i+f_{i-a_j}$（这里的 $=$ 是赋值的意思，即把 $f_i$ 加上 $f_{i-a_j}$）。

但是纸币可能会有很多种，那么我们应该怎么做呢？

对于每一个纸币面值 $a_j (a_j\le i)$，我们都把 $f_i$ 加上 $f_{i-a_j}$；因为 $a_j$ 是互不相同的，所以 $i-a_j$ 也是互不相同的，不会重复计算某一个面额。

那么最终的转移方程如下：

$$f_i=\sum_{i=1}^w \sum_{j=1}^n f_{i-a_j}\times[a_j \le i]$$

其中的中括号为艾弗森括号，括号里的条件满足则值为 $1$，否则为 $0$。

注意要初始化 $f_0=1$，因为凑 $0$ 元的方法就只有不付钱一种。

时间复杂度 $O(nw)$

**code :**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,a[1005],f[10005];
const int mod=1e9+7;
int main(){
	cin >> n >> w ;
	for(int i=1;i<=n;i++) cin >> a[i] ;
	f[0]=1;
	for(int i=1;i<=w;i++) for(int j=1;j<=n;j++) if(i>=a[j]) f[i]=(f[i]+f[i-a[j]])%mod;
	cout << f[w] ;
	return 0;
}
```


---

## 作者：Loser_Syx (赞：6)

建议橙。

## 思路

首先每一张面额为 $a_i$ 的纸币都能凑出 $a_i$ 元钱，这也算得上一种方案。

在求面额为 $w$ 的方案数时，我们要一元一元的求，每元钱有多少中组成方案也就是 $\sum_{j=1}^{n} dp_{i-a_j}$，因为 $i - a_j$ 有 $dp_{i-a_j}$ 中方案，而将其加上一个 $a_j$，$dp_i$ 也能凑出这么多种方案。

别忘取模。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
const int MOD = 1e9 + 7;
using namespace std;
int dp[100001],n,a[101010],w;
signed main(){
    cin>>n>>w;
    for(int i = 1; i <= n; i++) cin >> a[i], dp[a[i]]++;//用一张a[i]面值的纸币肯定能凑出a[i]元钱
    for(int i = 1;i <= w;i++){
        for(int j = 1; j <= n; j++){
            if(i - a[j] >= 0) {dp[i] += dp[i - a[j]]; dp[i] %= MOD;}
            //特判防止RE。i - a[j] 有dp[i - a[j]] 种方案，加上a[j]，dp[i] 也能凑出这么多
        }
    } 
    cout << dp[w];
    return 0;
}
```

---

## 作者：xiaoming007 (赞：4)

这题并不难，但是为什么好多大佬都不写题解？是留给本蒟蒻的吗？~~那我不客气了。~~

## 思路

初始化时肯定默认 $dp_0 = 1$，毕竟 $0$ 元钱直接一张纸币都不用就可以凑出来。

对于这个求方案数，我们可以从小的推到大，每元钱都可以用 $i - a_j$ 求出来，于是每一元的方案数就是 $\sum^{n}_{j=1} dp_{i-a_j}$。

输出 $dp_w$。

别忘记特判，因为 $i - a_j$ 可能 $< 0$。

也别忘记取模

## 代码

```cpp
#include<bits/stdc++.h>
const int MOD = 1e9 + 7;
using namespace std;
int f[100001], n, a[10001], w;
int main(){
    cin >> n >> w;
    dp[0] = 1;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1;i <= w;i++){
        for(int j = 1; j <= n; j++){
            if(i - a[j] >= 0) {
                f[i] += f[i - a[j]]; 
                f[i] %= MOD;
            }
        }
    } 
    cout << f[w] << '\n';
    return 0;
}
```

---

## 作者：Jerry_heng (赞：3)

（一）

如果将 $(1+2)$ 和 $(2+1)$  视为同一种，那这题就是完全背包模板。

所以只用在模板上稍微修改。

$dp_i$ 为总价为 $i$ 的方案数。$dp_0=1$。

$$dp_i= \sum_{j = 1}^{n}dp_{i-a_j}$$

先枚举 $i$，再枚举可以的 $j$。

（二）

AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int md=1e9+7;
int n,m,dp[10001],a[1001];
int main(){
	cin>>n>>m;
	dp[0]=1;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			if(a[j]<=i)dp[i]=(dp[i]+dp[i-a[j]])%md;
	cout<<dp[m];
	return 0;
}
```

---

## 作者：zzx0102 (赞：2)

考虑定义 $dp_i$ 为凑成 $i$ 的方案数，那么显然可得转移方程为 $dp_i=dp_{i-a_j}$。

注意特判 $i<a_j$ 的情况，还有取模。

复杂度 $O(nw)$，完全可行。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10010, p = 1e9 + 7; int a[N], n, w, dp[N];
signed main() {
	cin >> n >> w; for(int i = 1; i <= n; i++) cin >> a[i]; dp[0] = 1;
	for(int i = 1; i <= w; i++)
		for(int j = 1; j <= n; j++) if(i >= a[j])
			dp[i] = (dp[i] + dp[i - a[j]]) % p;
	cout << dp[w];
	return 0;
}
```

---

## 作者：幻想繁星 (赞：2)

定义 $f_i$ 为凑出 $i$ 元的纸币方式数，因此答案是 $f_w$。

初始化 $f_0=1$，因为凑出 $0$ 元只有一种方式。

对于凑出 $x$ 元（即 $f_x$），我们可以用一张面值为 $k$ 的纸币加上凑出 $x-k$ 的各种方案凑出。

所以，对于 $f_x$ 有如下转移方程：

$f_x=\sum\limits_{i=1}^nf_{x-a_i}$

可写出如下代码：

```c
for(int j=1;j<=w;j++)
	for(int i=1;i<=n;i++)
    	if(j>=a[i])
        	f[j]=(f[j]+f[j-a[i]]);
```

---


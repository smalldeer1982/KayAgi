# 纸币问题 1

## 题目描述

某国有 $n$ 种纸币，每种纸币面额为 $a_i$ 并且有无限张，现在要凑出 $w$ 的金额，试问最少用多少张纸币可以凑出来？（保证可以凑出对应金额）

## 说明/提示

对于 $40\%$ 的数据，满足 $n\le 10$，$w\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le 10^3$，$1\le a_i , w\le 10^4$。

## 样例 #1

### 输入

```
6 15
1 5 10 20 50 100```

### 输出

```
2```

## 样例 #2

### 输入

```
3 15
1 5 11```

### 输出

```
3```

# 题解

## 作者：sgl654321 (赞：40)

### 题目描述
$n$ 种纸币，要想凑出 $w$ 的面值，至少要几张纸币？
### 解题思路
一眼 dp 题。dp 题的解题思路通常为：读懂题意，设计状态，确定目标态和初始态，思考转移方程，思考优化。

设计状态：$f[i]$ 表示凑出面值为 $i$ 至少需要的纸币张数。

目标态：$f[w]$；初始态：$f[0]=0$，因为凑出 $0$ 元一张纸币都不需要。

转移方程：$f[v]=\min\{f[v-a[i]]\}+1(i\in[1,n])$

这是因为如果 $v-a[i]$ 需要用 $x$ 张纸币，那么只需要加上 $a[i]$ 这一张纸币，就能用这 $x+1$ 张凑出 $v$ 了。

复杂度 $O(nw)$，因此不需要优化。

### 参考代码
注意：由于涉及到取 $\min$ 操作，所以必须将初始值设为一个极大值。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,w,a[1010],f[100010];
int main(){
	cin>>n>>w;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=10010;i++)f[i]=1145141919;
	for(int i=1;i<=n;i++)
		for(int j=a[i];j<=w;j++)
			f[j]=min(f[j],f[j-a[i]]+1);
	cout<<f[w]<<endl;
	return 0;
} 
```


---

## 作者：Loser_Syx (赞：15)

建议橙。

## 思路

观察数据范围，$1 \leq n \leq 10^{3}, 1 \leq w \leq 10^{4}$，显然，这么小的数据范围是留给我们打暴力 dp 的，具体类似[这题](https://www.luogu.com.cn/problem/B3635)。

每次都要去求最小值，一元一元的求，直到求到 $w$，而凑出每一元的最小用纸币数就是 $\min(dp_{i-a_1} \sim dp_{i-a_n}) + 1$。注意 $i-a_j$ 可能小于 $0$，记得特判。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[100001],n,a[101010],cost,w;
int main(){
	cin>>n>>w;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1;i <= w;i++){
		cost = 0x3f3f3f3f;
		for(int j = 1; j <= n; j++){
           //特判一下，防止RE
		    if(i - a[j] >= 0) cost = min(cost, dp[i - a[j]]);
           //求之前用的纸币数最小值
		}
		dp[i] = cost + 1;//加一是这次会多用1张纸币
	} 
	cout << dp[w];
	return 0;
}
```

---

## 作者：timmark (赞：10)

# P2842 题解

一道经典的 dp。

## [题目传送门](https://www.luogu.com.cn/problem/P2842)

我们来考虑一下这题怎么设计状态。

因为题目里要我们求需要的最少纸币数量，我们就设 $f_i$ 为凑出 $i$ 元钱所需的最少纸币数。

接下来思考转移。

假如要凑 $i$ 元，现在有一张 $a$ 元的纸币 $(a \le i)$，那么我们可以先凑 $i-a$ 元，再补一张 $a$ 元的纸币。

那么我们的思路就很明确了：

- 对于每一个从 $1$ 到 $w$ 的金额 $i$，遍历每一种钱币 $a_j$；
- 如果 $a_j \le i$，尝试更新金额 $f_i=\min(f_i,f_{i-a_j}+1)$。

最后输出 $f_w$ 即可。

注意要把 $f$ 数组初始化为无穷大。

**code :**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,a[1005],f[10005];
int main(){
	cin >> n >> w ;
	for(int i=1;i<=n;i++) cin >> a[i] ;
	memset(f,127,sizeof(int)*(w+5));
	f[0]=0;
	for(int i=1;i<=w;i++) for(int j=1;j<=n;j++) if(i>=a[j]) f[i]=min(f[i],f[i-a[j]]+1);
	cout << f[w] ;
	return 0;
}
```


---

## 作者：shaozhehan (赞：7)

[原题链接](https://www.luogu.com.cn/problem/P2842)

题目大意：

现有 $n$ 种纸币，第 $i$ 中纸币面值为 $a(i)$ 元钱，每种纸币有无限多张，问你最少需要多少纸币才能凑出 $w$ 元钱。

思路：

经典的 dp 题。设一个函数 $dp$，$dp(i)$ 表示凑出 $i$ 元钱需要多少张纸币。

每次输入纸币的面值 $a(i)$，凑出 $i$ 元钱就可以直接凑，或者加上当前纸币。

可以列出状态转移方程：$dp(i)=\min\{dp(x)-a(i)\}+1(x\in[1,n])$。它等价于代码中的：
```cpp
for (int j = a; j <= w; j++){
   dp[j] = min(dp[j], dp[j - a] + 1);
}
```
坑点：
- $dp$ 数组要赋初值 $+\infty$。
- $dp(0)=0$ 不要忘记。

上代码：
```cpp
#include <cstring>
#include <iostream>
using namespace std;

int dp[10001];

int main(){
    cin.tie(NULL);
    cout.tie(NULL);
    ios::sync_with_stdio(false);// cin、cout加速
    // 赋初值
    memset(dp, 0x3f, sizeof(dp));
    dp[0] = 0;
    int n, w;
    cin >> n >> w;
    for (int i = 1; i <= n; i++){
        int a;
        cin >> a;
        // 状态转移
        for (int j = a; j <= w; j++){
            dp[j] = min(dp[j], dp[j - a] + 1);
        }
    }
    cout << dp[w] << "\n";// 最终答案输出
    return 0;
}
```

---

## 作者：幻想繁星 (赞：7)

定义 $f_i$ 为凑出 $i$ 元的最小纸币数，因此答案是 $f_w$。

初始化 $f_0=0$，因为凑出 $0$ 元需要 $0$ 张纸币。

每次都要去求最小值，一元一元的求，直到求到 $w$，而凑出每一元的最小用纸币数就是 $f_i=\min\{f_{i-a_1},f_{i-a_2},f_{i-a_3}\cdots f_{i-a_n}\}+1$。

代码如下：

```c
for(int i=1;i<=n;i++)
	for(int j=a[i];j<=w;j++)
		f[j]=min(f[j],f[j-a[i]]+1);
```

---


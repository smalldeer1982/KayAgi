# 【深基15.例2】寄包柜

## 题目描述

超市里有 $n(1\le n\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(0\le a_i\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \le q\le10^5)$ 次操作：

- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\le k\le 10^9)$。当 $k=0$ 时说明清空该格子。
- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。

已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。

## 说明/提示

$\text{upd 2022.7.26}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
5 4
1 3 10000 118014
1 1 1 1
2 3 10000
2 1 1```

### 输出

```
118014
1```

# 题解

## 作者：linponess (赞：440)

观察题目要求，很容易想到用二维数组来解决这个问题。

但真就这么简单的 $AC$ 了吗？

~~一个OI选手的直觉告诉我们没有！！！~~

仔细观察，发现我们要使用数组的话，需要开一个 $10^5*10^5$ 的数组，这会导致空间复杂度爆炸致死， $OUT!$

------------

再次观察数据范围，发现最多只会有 $10^7$ 个寄包格子，有大量的空间被浪费了。

如何减小空间复杂度？

可以使用动态的数据结构，如链表，定义一个链表结构体便可以解决空间复杂度爆炸的问题。

但真就这么简单的 $AC$ 了吗？

~~一个OI选手的直觉告诉我们没有！！！~~

再次仔细观察数据范围，发现最多会有 $10^5$ 次查询操作，因为链表查找时间复杂度过劣，最高时间复杂度高达 $10^7*10^5$ ，$TLE$ 到直接自闭，$OUT$!

------------
如何减小时间复杂度？

~~开数组。~~

有没有一种办法能将以上两种方法结合起来，使其兼有两种方法的优点呢？

众所周知动态数据结构不止一种~~那你还提什么链表~~，尤其是 $STL$ 中给我们提供了许多好用又方便的动态数据结构，比如下面这位老大哥：$vector$。

$vector$ 就是一种动态数组，可以根据使用情况来拓展数组空间，我们利用下标可以将单次查询的优化到 $O(1)$ ，可以轻松解决时间复杂度的问题？

一点都不轻松好吧！下标是连续分配的，根本不能利用下标来查询。~~你个大骗子，浪费我们时间！~~

但真的是这样吗？考虑到空间下标是稀疏的，我们可以用 离~散~化~ 来压缩下标，成功解决下标问题。

但真就这么简单的 $AC$ 了吗？

~~诶诶诶，不要打我好吗，我这叫循序渐进地讲题。~~

没错，你真的 $AC$ 了~~不骗你~~，可喜可贺，可喜可贺。

~~完结撒花。~~

------------
但让我们拓展一下，如果题目要求强制在线，离散化不可用怎么办？

这就需要我们另寻他法压缩下标，这里介绍一个好东西叫做哈希，其核心理念就是通过一个函数来把字符串或数字压缩到一个较小的范围内，至于实现方法~~请读者自证~~请读者另寻其他文章，luogu上有哈希的模板题，题解区应该有不少文章比我写得好，我在这里就不说了。

但就没有更优的解决方法了吗？

~~一个OI选手的直觉告诉我们必须有！！！~~

让我们稍微回顾下前情：
>众所周知动态数据结构不止一种

~~是的，我就是瞒着更好用的动态数据结构没告诉你。~~

$STL$ 中有一种叫做 $map$ 的数据结构，可以将两个变量之间建立映射关系~~不知道映射的请自行百度~~，也就是说，它的下标可以是**任意的数据类型**~~字符串、负数、实数什么都行~~，岂不比手打哈希好得多（$map$ 实际上就是 $STL$ 的哈希，但据说手打哈希常数要比 $map$ 要小，不知真伪，如有能提供证据者请私信我）？

但题目数据是二维的，如何解决这个问题？

可以手打结构体（由于是 $STL$ 你还得重载运算符，异常麻烦），或用 $make\_pair$ 法，由于这两种方法比较难懂，我在这里就不讲了，请读者自行查阅资料。

但由于两维数据都在 $10^5$ 的范围内，我们可以通过一些比较玄妙的方法，将一维数据乘上 $10^5$ 再加上另一维数据，把两个 $int$ 类型的数据压成一个 $long\ long$ 类型的数据，本人在比赛中使用的就是这种方法。

以下是代码：
```cpp
#include<cstdio>
#include<map>
using namespace std;
int n,q,p,k;
map<long long,int>b;
long long i,j;
int main()
{
	scanf("%d%d",&n,&q);
	while(q--)
	{
		scanf("%d%d%d",&p,&i,&j);
		if(p==1)
		{
			scanf("%d",&k);
			b[i*1000000+j]=k;
		}
		else printf("%d\n",b[i*1000000+j]);
	}
	return 0;
}
```
或者我们用一些更简单的方法，比如：开一个 $map$ 数组（虽说是动态的，但开得过大仍有爆栈的可能）。

------------
二次拓展：如果数据范围大于 $long\ long$ 怎么办？

解决方案：使用字符串读入。

三次拓展：如果数据有 $N$ 维，又害怕数组开得过大爆栈怎么办？

解决方案：把 $N$ 个字符串并为一个字符串。

$\huge\mathbb{END.}$

---

## 作者：SUNCHAOYI (赞：208)

Update on 2020.8.10：修改了题解中的一些累赘部分

Update on 2022.8.4：修改题解做法，确保复杂度正确

首先我们期望的一个强大的数组应该存放这个三个元素：**第 $i$ 个柜子的第 $j$ 个格子以及存入的物品 $k$** 。那么怎么去实现呢？  

第一个想到的肯定是二维数组，但是看下数据范围：$1\le n\le 10^5$，$1 \le a_i \le 10^5$，并且有已知超市里共计不会超过 $10^7$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。因此设置一个数组 $\texttt{a[100005][100005]}$ 就肯定 $\texttt{MLE}$ 了，所以这个方法就别想了。

## 挑战  $\texttt{MLE}$ 

怎样设置数组才能**节省内存**呢？我们想到动态数组 $\texttt{vector}$，尝试一下吧！设置一个结构体 $\texttt{desk}$ ,里面有三个参数，如下：

```cpp
const int MAX = 100005;
struct node
{
    //s用来记录desk[i]的元素个数，表示第i个柜子已存s次物品 
    //num表示第i个柜子的第num个格子存入一个物品
    //w表示该格子存入的物品 
    vector<int> num,w;//用vector动态数组节省内存，以防MLE 
    int s = 0;
} desk[MAX];
```

接下来处理输入，若是**寄存操作**，那么我们只要把该个柜子的存放次数 $+1$，并把 $num,w$ (即**格子编号和物品**)存入动态数组中即可。

```cpp
desk[a].s++; //第a个柜子存入物品
desk[a].num.push_back(b);//第b个格子中 
desk[a].w.push_back(c);//存入物品c 
```

再来看查询操作，由题可知**操作保证合法**，所以直接查询就可以了。那么应该怎么循环呢？很简单，查找 $\texttt{a}$ 柜子，然后**从后往前**循环。因为后面的元素可能与之前重复，说明该柜子的某个格子存放的物品**有更新**。    

因此就有：

```cpp
for(int i = desk[a].s - 1;i >= 0;i--)//从后往前，因为格子存放会有更新 
{
    if(desk[a].num[i] == b)//如果查询到该柜子的格子 
    {
        cout<<desk[a].w[i]<<endl;//输出该格子内的物品 
        break;//因此时是最新的存放情况，所以有解后需要直接退出查询 
        //提醒：break 很重要，不能遗漏，否则一次查询就可能输出多解。
    }
}
```

看起来是个不错的实践，由于数据较弱，似乎能过，但仔细分析一下复杂度，发现是 $O(n^2)$的,看来这个思路并不可行。

## 挑战  $\texttt{TLE}$ 

于是又想到了强大的 `map` 库，定义 `map <pair <int,int>,int> p` 来表示，`p[{i,j}]` 表示第 $i$ 个柜子的第 $j$ 个格子的物品。对于每一个操作 $1$，直接赋值即可，`p[{i,j}] = k`；对于而操作，直接输出 `p[{i,j}]`。

于是乎，我们得到了最终复杂度正确的算法，代码如下：

```cpp
#include <cstdio>
#include <map>
using namespace std;
inline int read ();
int n,q; 
map <pair <int,int>,int> p;
int main ()
{
	n = read ();q = read ();
	while (q--)
	{
		int ty = read ();
		if (ty == 1) p[{read (),read ()}] = read ();
		else printf ("%d\n",p[{read (),read ()}]);
	}
	return 0;
}
inline int read ()
{
    int s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}
```

---

## 作者：vectorwyx (赞：153)

## STL大法好！


------------
这道题需要用到STL中的map


------------
首先，肯定不能简单的开一个二维数组。

因为二维数组一定是连续的内存。

也就是说如果我们想要查询下标为10^5的元素，需要从下标1开始一直申请内存直到到10^5

然而真正有用的内存没有多少，因此会造成大量的冗余

显然会空间超限


------------
那么，我们就要考虑什么数据结构能够避开这些冗余

有两个选择：链表和map

然而链表实在是麻烦得让人头皮发麻

故我们果断的选用map


------------
有同学就会担心了：用map不会超时吗？

没关系，我们来分析一下：

我们知道map的时间复杂度会带一个log

但是题目中说总格子数不会超过10^7个

也就是说建立映射的次数不会超过10^7次

那我们就放心了，**用map绝对不会超时**


------------
因此，我们**对于每一次存放操作，建立一次二维映射**

**对于每一次查询操作，直接输出其映射的值**

这道题就可以顺利地AC了


------------

代码如下：
```cpp
#include<cstdio>
#include<iostream> 
#include<map>//引用STL里的map库
using namespace std;
map<int,map<int,int> > a;//建立二维映射
int main(){
	int n,q,x,y,k,z;
    cin>>n>>q;//输入寄包柜个数及询问次数
    for(int i=1;i<=q;++i){//循环q次
        scanf("%d%d%d",&k,&x,&y);//先输入k,x,y
        if(k==1){//存放操作
            scanf("%d",&z);//继续输入
            a[x][y]=z;//建立一次映射
        }
        else{//查询操作
            printf("%d\n",a[x][y]);//直接输出所映射的值
        }
    }
	return 0;
} 
```


---

## 作者：chufuzhe (赞：45)

我们可以建立一个二维数组s[x][y]来记录第i个柜子的第j个格子中的物品。根据本题的数据范围，需要开一个$10^5$ * $10^5$的int数组（4*$10^10$字节，大约有40GB），而本题的空间限制这有125MB，显然会超空间，所以我们可以用一个$vector$来解决。

那$vector$怎么用呢，有以下几种常用的操作：

（1）vector<int> a 定义一个int类型的vector一维数组。
  
（2）vector<int> a(10) 定义一个int类型的长度为十的vector一维数组。
  
（3）vector<int> a(10)(1) 定义一个int类型的长度为十初值为一的vector一维数组。
  
（4）vector<vector<int> > a 定义一个int类型的vector二维数组，要注意的是，在里面的vecotr<int>后面要加一个空格，否则会被认为是移位运算符而编译错误。
  
（5）a.begin() 返回数组a的首元素的指针（迭代器）。
  
（6）a.end() 返回数组a的末尾元素的下一个元素的指针（迭代器）。
  
（7）a.size() 数组中的元素个数

（8）a.empty() 判断数组是否为空

（9）a.clear() 清空数组中的元素
  
（10）a.insert(a.begin(),1000) 将1000插入到向量a的起始位置前

（11）a.insert(a.begin(),3,1000); 将1000分别插入到向量元素位置的0-2处(共3个元素)
  
（12）a.erase(a.begin()); 将起始位置的元素删除

（13）a.erase(a.begin(),a.begin()+3) ; 将(a.begin(),a.begin()+3)之间的元素删除
  
（14）a.push_back(1) 将1放到数组尾部
  
（15）a[1] 数组中的下标为1的值

vector和数组相比，vector可以改变长度，清空的时间复杂度为O(1)。
  
那再来看这道题，我们可以一个一个把学号读入后使用push_back将数据一个个按顺序存入中数组里，最后询问的时候直接按下标输出即可。代码如下：

```cpp
#include <bits/stdc++.h> //头文件
using namespace std;
inline int read() //快读
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x) //快出
{
    if(x<0)
	{
    	putchar('-');
		x=-x;
	}
    if(x>9)
		write(x/10);
    putchar(x%10+'0');
}
int main() //主函数
{
	ios::sync_with_stdio(false); //输入输出优化流
	int n,q,f,x,y,z; //定义
	n=read(); //输入寄包裹个数和询问次数
	q=read();
	vector<vector<int> > a(n+1); //定义一个可变数组，初始化，总共0-n号寄包柜
	while(q--)
	{
		f=read(); //输入操作种类
		if(f==1) //存包操作
		{
			x=read(); //输入
			y=read();
			z=read();
			if(a[x].size()<y+1) a[x].resize(y+1); //如果这个寄包柜不够大，就扩大新的寄包柜，直到能装下为止
			a[x][y]=z; //存包
		}else{
			x=read(); //输入
			y=read();
			write(a[x][y]); //输出下标为x,y的元素
			puts(""); //换行
		}
	}
	return 0; //结束
}

```


---

## 作者：WOWHandsome (赞：18)

这是一道好题，**用 $STL$ 的好题**。

显然我们不能开数组暴力，要开一个 $a[10^5][10^5]$ 的数组，肯定 $MLE$。事实上并没有这么多个值要存储。可以使用 $STL \ Map$ 来进行数据离散化。带上一个 $log$ 的时间复杂度能接受。

在此题中，我们使用 $mat[i][j]$ 来表示第 $i$ 个柜子的第 $j$ 个物品存放的东西（$0$表示无东西存放）。

**算法流程**

1. 输入

2. 对于每一组询问，

> 若是存入物品，直接进行映射。$mat[i][j]=k$

> 否则将 $mat[i][j]=0$ （无东西存放）

3. 愉快 $AC$

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
map <int, int> mat[10005];  //二维map
int main() {
	int n, q;
	scanf("%d%d", &n, &q);//输入
	while (q--) {
		int x, i, j, k;
		scanf("%d", &x);
		if (x == 1) {
			scanf("%d%d%d", &i, &j, &k);  
			mat[i][j] = k;  //直接映射
		} else {
			scanf("%d%d", &i, &j);
			printf("%d\n", mat[i][j]); //直接查找对应元素，输出
		}
	} 
	return 0;
} 
```

事实上 $0$ 的判断并不需要特别考虑，直接按照一般做就可以了。本题 $0$ 的出现 ~~我也不知道为什么搞个 0~~

$STL\ Map$ —— 她很 **香**。但是，到了高中的算法竞赛尽量别用 $Map$，使用 $Map$ 意味着时间复杂度至少要带一个 $log$。

---

## 作者：DreamFox (赞：16)

本题思路：

由于$10^5*10^5$的数组会炸空间，所以这道题要用$map$

开一个$100001$的$map$数组来记录$k$，要输出时输出$a_{ij}$

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>a1[100001];
int n,q;
int main()
{
	cin>>n>>q;
	for(int i=0;i<q;i++)
	{
		int a,b,c,d;
		cin>>a;
		if(a==1)
		{
			cin>>b>>c>>d;
			a1[b][c]=d;  //用map数组记录k
		}
		else
		{
			cin>>b>>c;
			cout<<a1[b][c]<<endl;  //输出aij
		}
	}
	return 0;
}
```


---

## 作者：critnos (赞：6)

## 前置芝士：动态查找表

查找分为两种：**动态查找**和静态查找

意思就是：

给你一个序列，然后……

静态查找：支持这个操作：

* 给定一个数$key$，**求$key$在序列中的位置**

而动态查找除了静态查找的功能，还支持另一个操作：

* 给定一个数$key$，**把$key$插入到序列中**

* 静态查找一般用二分查找等算法实现

* 动态查找一般用数据结构实现

**而支持动态查找的数据结构，就被称为动态查找表**

动态查找表一般用**BST**、**HASH**等数据结构实现

BST的时间复杂度：$O(log_2n)$

HASH的时间复杂度：近似$O(1)$

动态查找表STL里都有

BST：`map`

HASH：`unordered_map<int,int>`

> ~~原理请自行百度~~

## 转入正题：这题怎么做

PS：本题的![](https://cdn.luogu.com.cn/upload/image_hosting/entwi8zf.png)不用管它，容易引起歧义

~~傻子才开二维数组~~

正常人一般会想到先开一个`int a[100000]`，然后就蒙了:第二维不知道怎么开，开二维会很浪费空间

那么不妨先想一想：为什么开二维会浪费空间呢？

答案显而易见：有很多“寄包格子”是没有用上的

那么用`vector`呢？

显然可以，但显然会TLE

这时候前置芝士就派上用场了：**动态查找表**

把每个“寄包柜”都当做一个动态查找表即可，每个“寄包格子”作为动态查找表里的元素

同理,有很多“寄包柜”也是没有用上的，同样可以把“超市”当作一个动态查找表，每个“寄包柜”作为动态查找表里的元素

~~那么超市就成了这个奇怪的东西：~~

```cpp
unordered_map<int,unordered_map<int,int>>
```
其他的操作就很简单了：当二维数组用

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<int,unordered_map<int,int>> a;//HASH的时间复杂度略低于BST
int main() 
{
	int n,p,i,j,k;
	cin>>n>>n;//寄包柜个数无关紧要，直接吃掉
	while(n--)
	{
		cin>>p>>i>>j;
		if(p==2) cout<<a[i][j]<<endl;//查询第i个柜子的第j个格子中的物品是什么
		else//在第i个柜子的第j个格子存入物品k
		{
			cin>>k;
			a[i][j]=k;
		}
	}
}
```


---

## 作者：FCBM71 (赞：5)

再一次感叹STL功能的强大

假设寄包柜编号是 $x$，格子编号是 $y$ 。但是寄包柜数量 $x$ 达到了 $10^5$，每个寄包柜的格子最大数量 $y$ 也达到了 $10^5$。很显然我们这个时候不能二维数组来搞了。   

这道题的题眼就是最多不超过 $10^7$ 个寄包柜格子。  这也意味着我们需要把一个二维的坐标 $(x,y)$ 通过某种高级算法转化成一个一维的坐标 $p$。因此我们需要对坐标进行离散化。你也可以手写，但是cppSTL已经为我们提供了一个很好的模板。map：“有人叫我？map用在这里再适合不过了。     

**法一**：我们把 $(x,y)$ 视为一个 `pair<int,int>`，用一个下标类型为 pair 的map映射 `f` 来存储每个格子的物品数量。如果 $k>0$，`f[make_pair(x,y)]+=k`。如果 $k=0$，则 `f[make_pair(x,y)]=0`。这一操作的理想复杂度是 $O(q \times log_2q)$，绰绰有余。


每次操作的 $k\leq 10^9$，但$10^5$次操作叠加在一起呢？“不开LL见祖宗”

完整代码：
```cpp
#include<cstdio>
#include<map>
#include<algorithm>
#define LL long long
using namespace std;

map<pair<int,int>,LL>f;
int n,q,tag,a,b;LL delta;

int main(){
	scanf("%d%d",&n,&q);
	while(q--){
		scanf("%d",&tag);
		if(tag==1){
			scanf("%d%d%lld",&a,&b,&delta);
			if(delta)f[make_pair(a,b)]+=delta;
			 else f[make_pair(a,b)]=0;
		}else{
			scanf("%d%d",&a,&b);
			printf("%lld\n",f[make_pair(a,b)]);
		}
	}
	return 0;
}
```
**法二**：考虑到make_pair效率不太高，我们也可以把 `pair<x,y>` 改变成 $(LL)\ x\times 10^7 +y$ 的形式，也可以避免下标重复。代码就不贴了

**法三**：我们甚至还可以对每个柜子进行离散化，即这样声明 `map<int,LL>f[1000005]`。这样可以同时避免 make_pair 和乘法，似乎效率更高。注意这样在调用时应该为 `f[x][y]`

---

## 作者：K2sen (赞：5)

## P3613 【深基15.例2】寄包柜
[传送门](https://www.luogu.com.cn/problem/P3613)

### 题目大意
往一个$a[i][j]$ 里边放东西，也可以取走东西，然后查询$a[i][j]$里边是什么东西。

### 思路:
显然我们可以暴力，但是你开不了那么大的数组。

翻了翻dalao们的题解，为什么要用结构体呢？？

直接$map$他不香吗?

我们用一个$map<int,int> ma[N];$当做暴力的数组来做。

因为$map$如这个STL如果不访问的话是不是占空间的,那么我们就可以~~为所欲为~~A掉这个题了。

code：
```cpp
#include <bits/stdc++.h>

#define N 100010
#define M 1010

using namespace std;
int n, q;
map<int, int>ma[N];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

int main() {
	n = read(), q = read();
	for (int i = 1, opt, x, y, sy; i <= q; i++) {
		opt = read(), x = read(), y = read();
		if (opt == 1) {
			sy = read();
			ma[x][y] = sy;
		} else printf("%d\n", ma[x][y]);
	}
	return 0;
}
```

---

## 作者：　　　吾皇 (赞：5)

### 分析

考虑这样一种数据结构，内存大小不受下标大小的限制，可以进行数组一样的操作（赋值，查找等）。

首推 STL 里面的 map ，只要手写一个结构体比较程序，就能用map来做了。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct num{
	int a,b;//a、b分别代表柜子数和格子数
	bool operator < (const num x) const{return (x.a<a)||(x.a==a&&x.b<b);}//这里的比较要求能将不同的二者区分开，注意只能用<
}t;
map<num,int> q;
int n,q1,opt,i,j,k;
int main(){
	scanf("%d%d",&n,&q1);
	for(int p=1;p<=q1;p++){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d%d%d",&i,&j,&k);
			t.a=i,t.b=j;//将值赋给结构体
			q[t]=k;//将结构体赋上值，如果是0，则直接为0
		}
		else {
			scanf("%d%d",&i,&j);
			t.a=i,t.b=j;
			printf("%d\n",q[t]);//输出要查找的，因为对应的是int类型，所以可以直接输出
		}
	}
}
```


---

## 作者：TESJackeyLove (赞：4)

- **题目意思大家都懂，这里不再赘述，最容易想到的思路就是暴力，但是，n和ai的限制导致开二维数组会爆内存，那么map如何？**
- **一维的map也不太好操作，那么map嵌套呢？**
```cpp
	map<int,map<int,int> >mp;
```
- **这样我们就可以把它当做二维数组一样用了！！！然后接下来的写法跟二维数组的暴力写法是一样的了。下面是代码：**
```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<algorithm>
  #include<cstring>
  #include<cstdlib>
  #include<queue>
  #include<stack>
  #include<set>
  #include<map>
  #define fore(i,a,b) for(register int i=a;i<=b;i++)
  #define foru(i,a,b) for(register int i=a;i<b;i++)
  #define ford(i,a,b) for(register int i=a;i>=b;i--)
  #define IGNB std::ios::sync_with_stdio(false);
  #define ll long long
  #define INF 0x3fffffff
  #define sz 305
  #define r(n) n=read()
  using namespace std;
  inline int read(){
      int f = 1, x = 0;char ch = getchar();
      while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
      while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
      return x * f;
  }
  map<int,map<int,int> >mp;
  int n,q;
  int main(){
      IGNB;
      r(n),r(q);
      int op,i,j,k;
      fore(t,1,q){
          r(op);
          if(op==1){
              r(i),r(j),r(k);
              mp[i][j]=k;		
          }
          else{
              r(i),r(j);
              cout<<mp[i][j]<<endl;
          }
      }
      return 0;
  }

```


---


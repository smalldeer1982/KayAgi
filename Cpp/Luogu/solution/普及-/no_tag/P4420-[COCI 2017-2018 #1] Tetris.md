# [COCI 2017/2018 #1] Tetris

## 题目描述

Ivica是一位激情昂扬的计算机科学家。他最近开始研究他的第一个电脑游戏：流行于当下的俄罗斯方块的克隆。尽管他还远未完成，但他的研究计划却支持将下图中显示的五种不同的俄罗斯方块图形放在一个矩阵中。在将它放入俄罗斯方块矩阵之前，图形可以旋转90度任意次数并着色。此外，当前版本的游戏不支持放置俄罗斯方块图形，如果这意味着它将超出矩阵边界或与矩阵中的另一个现有图形重叠。

![](https://cdn.luogu.org/upload/pic/17376.png)

当Ivica在学校时，他的妹妹Marica开始游戏并随机旋转，着色并放置俄罗斯方块图形，使相邻的那一些俄罗斯方块颜色不同。如果它们在共用一个共同的侧面或两两相触，则两个图形相邻。（PS：【译者注】当然，一个点｛角｝不算）

当Ivica回到他的电脑后，他发现游戏正在运行着他妹妹放置的俄罗斯方块图形。他想知道俄罗斯方块矩阵中有多少数字，他要求你在他忙于改进游戏时帮助他解决这个问题。

## 样例 #1

### 输入

```
4 5
aaaa.
.bb..
.bbxx
...xx
```

### 输出

```
2
1
0
0
0
```

## 样例 #2

### 输入

```
4 5
.aab.
aabb.
.cbaa
cccaa
```

### 输出

```
1
0
1
1
1
```

## 样例 #3

### 输入

```
5 7
.c.....
ccdddd.
caabbcc
aabbacc
...aaa.
```

### 输出

```
1
1
2
1
1```

# 题解

## 作者：cxq2002 (赞：6)

#简单的枚举
*注意*：
翻转九十度，五种俄罗斯方块有不同情况。
图一无变化。
图二，图三和图四有两种变化。
图五有四种变化。
但是数据水，可以else直接过，不需要考虑。

直接存在数组中，从头到尾扫描一遍。
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[11][11];
int sum[6],n,m,i,j;
void remove(int x,int y)
{
    char c=s[x][y];
    s[x][y]='.';
    if(s[x-1][y]==c) remove(x-1,y);
    if(s[x+1][y]==c) remove(x+1,y);
    if(s[x][y-1]==c) remove(x,y-1);
    if(s[x][y+1]==c) remove(x,y+1);
}
int check(int x,int y)
{
    char c=s[x][y];
	if(s[x+1][y]==c&&s[x+1][y+1]==c&&s[x][y+1]==c)
        return 1;
    if((s[x][y+1]==c&&s[x][y+2]==c&&s[x][y+3]==c)||(s[x+1][y]==c&&s[x+2][y]==c&&s[x+3][y]==c))
        return 2;
    if((s[x][y+1]==c&&s[x+1][y]==c&&s[x+1][y-1]==c)||(s[x+1][y]==c&&s[x+1][y+1]==c&&s[x+2][y+1]==c))
        return 3;
    if((s[x][y+1]==c&&s[x+1][y+1]==c&&s[x+1][y+2]==c)||(s[x+1][y]==c&&s[x+1][y-1]==c&&s[x+2][y-1]==c))
        return 4;
    else
        return 5;
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            cin>>s[i][j];
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            if(s[i][j]!='.')
            {
                sum[check(i,j)]++;
                remove(i,j);
            }
    for(i=1;i<=5;i++)
        cout<<sum[i]<<endl;
    return 0;
}```

---

## 作者：ECEG (赞：2)

# 「COCI2017/2018」tetris题解

## 思路

考虑每种情况，分别判断。

## 分析

1. ![](https://cdn.fzoi.top/upload/user/c20150024/22081711066156.png) 

   只有一种情况。

   ```cpp
   if(a[i][j]!='.'&&a[i+1][j]==a[i][j+1]==a[i][j]==a[i+1][j+1])ans[0]++;
   ```

2. ![](https://cdn.fzoi.top/upload/user/c20150024/22081711412993.png) 

   有两种情况：竖着和横着。

   ```cpp
   if(a[i][j]!='.'&&a[i][j]==a[i+1][j]==a[i+2][j]==a[i+3][j])ans[1]++;
   if(a[i][j]!='.'&&a[i][j]==a[i][j+1]==a[i][j+2]&&a[i][j+3])ans[1]++;
   ```

3. ![](https://cdn.fzoi.top/upload/user/c20150024/22081711433924.png) 

   有两种情况：指上和指右。

   ```cpp
   if(a[i][j]!='.'&&a[i][j]==a[i][j+1]==a[i+1][j]==a[i+1][j-1])ans[2]++;
   if(a[i][j]!='.'&&a[i][j]==a[i+1][j]==a[i+1][j+1]==a[i+2][j+1])ans[2]++;
   ```

4. ![](https://cdn.fzoi.top/upload/user/c20150024/22081711143114.png) 

   一样，有两种情况：指上和指右。

   ```cpp
   if(a[i][j]!='.'&&a[i][j]==a[i+1][j]==a[i+1][j-1]==a[i+2][j-1])ans[3]++;
   if(a[i][j]!='.'&&a[i][j]==a[i][j+1]==a[i+1][j+1]==a[i+1][j+2])ans[3]++;	
   ```

5. ![](https://cdn.fzoi.top/upload/user/c20150024/22081711284930.png) 

   四种情况，指上，指下，指右，指左。

   ```cpp
   if(a[i][j]!='.'&&a[i][j]==a[i+1][j]==a[i+1][j-1]==a[i+1][j+1])ans[4]++;
   if(a[i][j]!='.'&&a[i][j]==a[i+1][j]==a[i+1][j-1]==a[i+2][j])ans[4]++;
   if(a[i][j]!='.'&&a[i][j]==a[i+1][j]==a[i+1][j+1]==a[i+2][j])ans[4]++;
   if(a[i][j]!='.'&&a[i][j]==a[i][j+1]==a[i+1][j+1]==a[i][j+2])ans[4]++;
   ```

最后枚举每个位置，判断就行了。

## AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans[5];
char a[14][14];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    	for(int j=1;j<=m;++j)
    		cin>>a[i][j];
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j+1])ans[0]++;//第一种 
			
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+2][j]&&a[i][j]==a[i+3][j])ans[1]++;//第二种 
			if(a[i][j]!='.'&&a[i][j]==a[i][j+1]&&a[i][j]==a[i][j+2]&&a[i][j+3]==a[i][j])ans[1]++;
			
			if(a[i][j]!='.'&&a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1])ans[2]++;//第三种 
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+2][j+1])ans[2]++;
			
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+2][j-1])ans[3]++;//第四种 
			if(a[i][j]!='.'&&a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+1][j+2])ans[3]++;
				
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+1][j+1])ans[4]++;//第五种 
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+2][j])ans[4]++;
			if(a[i][j]!='.'&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+2][j])ans[4]++;
			if(a[i][j]!='.'&&a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i][j+2])ans[4]++;
		}
	}
	for(int i=0;i<5;++i){
		cout<<ans[i]<<endl;
	}
    return 0;
}
```





---

## 作者：zhongcy (赞：1)

[Problem](https://www.luogu.com.cn/problem/P4420)



### Solution

------------

很水的一道题。可以暴力判断图形种类，然后把连通块标记为   $ \texttt{'.'} $。其实也可以直接标记，但码量过大，就不展示了。该方法代码实现可以参考这篇[题解](https://www.luogu.com.cn/blog/juruo-----yehan/solution-p4420)。


### Code


------------


时间复杂度 $ \Theta ( NM )$。

```cpp
/*连通块做法*/

#include<bits/stdc++.h>
using namespace std;
int n,m;
int ans[6];
char c[11][11];
int dx[4]={1,0,0,-1};
int dy[4]={0,1,-1,0};
void dfs(int x,int y)
{
	char c1=c[x][y];
	c[x][y]='.';
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(c[nx][ny]==c1)
			dfs(nx,ny);
	}//减少码量
}//连通块标记
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>c[i][j];
  	//输入
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(c[i][j]!='.')
			{
				char c1=c[i][j];int k;
				if(c[i+1][j]==c1&&c[i+1][j+1]==c1&&c[i][j+1]==c1)
					k=1;
				else if((c[i][j+1]==c1&&c[i][j+2]==c1&&c[i][j+3]==c1)||(c[i+1][j]==c1&&c[i+2][j]==c1&&c[i+3][j]==c1))
					k=2;
				else if((c[i][j+1]==c1&&c[i+1][j]==c1&&c[i+1][j-1]==c1)||(c[i+1][j]==c1&&c[i+1][j+1]==c1&&c[i+2][j+1]==c1))
					k=3;
				else if((c[i][j+1]==c1&&c[i+1][j+1]==c1&&c[i+1][j+2]==c1)||(c[i+1][j]==c1&&c[i+1][j-1]==c1&&c[i+2][j-1]==c1))
					k=4;
				else
					k=5;//判断种类
				ans[k]++;//统计
				dfs(i,j);//标记
			}
   //输出
	for(int i=1;i<=5;i++)
		cout<<ans[i]<<endl;
	return 0;
}
```


---

## 作者：RainFestival (赞：1)

此题可以用简单的bfs

先找出所有的连通块（用bfs）（一定是四个组成的）

再按照横竖坐标排序

然后的结果种数就不多啦

来吧来吧，只能坑爹判断………………

我是个蒟蒻，~~代码太长啦~~

```pascal
type
  arr=array[0..10000] of longint;
var
  vis:array[-5..105,-5..105] of boolean;
  a:array[-5..105,-5..105] of char;
  i,j,n,m:longint;
  st:ansistring;
  s,b,c:array[0..10] of longint;
procedure qsort(l,r:longint;var p,q:arr);
var
  i,j,x1,x2,y:longint;
begin
  i:=l;
  j:=r;
  x1:=p[(l+r) div 2];
  x2:=q[(l+r) div 2];
  repeat
    while (p[i]<x1) or (p[i]=x1) and (q[i]<x2) do inc(i);
    while (p[j]>x1) or (p[j]=x1) and (q[j]>x2) do dec(j);
    if i<=j then
      begin
        y:=p[i];
        p[i]:=p[j];
        p[j]:=y;
        y:=q[i];
        q[i]:=q[j];
        q[j]:=y;
        inc(i);
        dec(j);
      end;
  until i>j;
  if l<j then qsort(l,j,p,q);
  if i<r then qsort(i,r,p,q);
end;
procedure pd(p,q:arr;t:longint);
var i:longint;
begin
  //for i:=1 to 4 do
    //writeln(p[i],' ',q[i]);
  qsort(1,t,p,q);
  if     (p[1]=p[2]) and (q[1]+1=q[2])
     and (p[1]+1=p[3]) and (q[1]=q[3])
     and (p[1]+1=p[4]) and (q[1]+1=q[4]) then
       inc(s[1]);
  if     (p[1]+1=p[2]) and (q[1]=q[2])
     and (p[1]+2=p[3]) and (q[1]=q[3])
     and (p[1]+3=p[4]) and (q[1]=q[4])
      or (p[1]=p[2]) and (q[1]+1=q[2])
     and (p[1]=p[3]) and (q[1]+2=q[3])
     and (p[1]=p[4]) and (q[1]+3=q[4]) then
       inc(s[2]);
  if     (p[1]=p[2]) and (q[1]+1=q[2])
     and (p[1]+1=p[3]) and (q[1]-1=q[3])
     and (p[1]+1=p[4]) and (q[1]=q[4])
      or (p[1]+1=p[2]) and (q[1]=q[2])
     and (p[1]+1=p[3]) and (q[1]+1=q[3])
     and (p[1]+2=p[4]) and (q[1]+1=q[4]) then
       inc(s[3]);
  if     (p[1]=p[2]) and (q[1]+1=q[2])
     and (p[1]+1=p[3]) and (q[1]+1=q[3])
     and (p[1]+1=p[4]) and (q[1]+2=q[4])
      or (p[1]+1=p[2]) and (q[1]-1=q[2])
     and (p[1]+1=p[3]) and (q[1]=q[3])
     and (p[1]+2=p[4]) and (q[1]-1=q[4]) then
       inc(s[4]);
  if     (p[1]+1=p[2]) and (q[1]-1=q[2])
     and (p[1]+1=p[3]) and (q[1]=q[3])
     and (p[1]+1=p[4]) and (q[1]+1=q[4])
      or (p[1]+1=p[2]) and (q[1]-1=q[2])
     and (p[1]+1=p[3]) and (q[1]=q[3])
     and (p[1]+2=p[4]) and (q[1]=q[4])
      or (p[1]+1=p[2]) and (q[1]=q[2])
     and (p[1]+1=p[3]) and (q[1]+1=q[3])
     and (p[1]+2=p[4]) and (q[1]=q[4])
      or (p[1]=p[2]) and (q[1]+1=q[2])
     and (p[1]=p[3]) and (q[1]+2=q[3])
     and (p[1]+1=p[4]) and (q[1]+1=q[4])
     then
       inc(s[5]);
end;
procedure bfs(x,y:longint);
var
  p,q:arr;
  h,t:longint;
begin
  h:=0;
  t:=1;
  p[1]:=x;
  q[1]:=y;
  vis[x][y]:=true;
  //writeln('^^^',p[1],' ',q[1]);
  while h<t do
    begin
      inc(h);
      if not vis[p[h]+b[1]][q[h]+c[1]] and
         (a[p[h]][q[h]]=a[p[h]+b[1]][q[h]+c[1]]) then
        begin
          inc(t);
          p[t]:=p[h]+b[1];
          q[t]:=q[h]+c[1];
          vis[p[t]][q[t]]:=true;

        end;
      if not vis[p[h]+b[2]][q[h]+c[2]] and
         (a[p[h]][q[h]]=a[p[h]+b[2]][q[h]+c[2]]) then
        begin
          inc(t);
          p[t]:=p[h]+b[2];
          q[t]:=q[h]+c[2];
          vis[p[t]][q[t]]:=true;

        end;
      if not vis[p[h]+b[3]][q[h]+c[3]] and
         (a[p[h]][q[h]]=a[p[h]+b[3]][q[h]+c[3]]) then
        begin
          inc(t);
          p[t]:=p[h]+b[3];
          q[t]:=q[h]+c[3];
          vis[p[t]][q[t]]:=true;

        end;
      if not vis[p[h]+b[4]][q[h]+c[4]] and
         (a[p[h]][q[h]]=a[p[h]+b[4]][q[h]+c[4]]) then
        begin
          inc(t);
          p[t]:=p[h]+b[4];
          q[t]:=q[h]+c[4];
          vis[p[t]][q[t]]:=true;
          //writeln(' ',p[t],' ',q[t]);
        end;
    end;
  //writeln(t);
  pd(p,q,t);
end;
begin
  //assign(input,'tetris.in');
  //assign(output,'tetris.out');
  //reset(input);
  //rewrite(output);
  b[1]:=1;c[1]:=0;
  b[2]:=0;c[2]:=1;
  b[3]:=-1;c[3]:=0;
  b[4]:=0;c[4]:=-1;
  readln(n,m);
  for i:=0 to n+1 do
    for j:=0 to m+1 do
      vis[i][j]:=true;
  for i:=1 to n do
    begin
      readln(st);
      for j:=1 to m do
        begin
          a[i][j]:=st[j];
          if a[i][j]='.' then vis[i][j]:=true
                         else vis[i][j]:=false;
        end;
    end;
  //for i:=1 to n do
    //begin
      //for j:=1 to m do
        //write(vis[i][j],' ');
      //writeln;
    //end;
  for i:=1 to n do
    for j:=1 to m do
      if not vis[i][j] then
        bfs(i,j);
  for i:=1 to 5 do
    writeln(s[i]);
  //close(input);
  //close(output);
end.
```

时间26ms,内存0.8MB,代码长度4.31KB！！！

谢谢大佬巨佬神犇的观赏！！！

---

## 作者：废物yehan (赞：1)

纯模拟就行
```c
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
char s[N][N];
int f1=0,f2=0,f3=0,f4=0,f5=0;
int main()
{
//	freopen("tetris.in","r",stdin);
//	freopen("tetris.out","w",stdout);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s[i][j]!='.'){
				if(s[i][j]==s[i+1][j]&&s[i][j]==s[i][j+1]&&s[i][j]==s[i+1][j+1]){
					f1++;
					s[i][j+1]='.';
					s[i+1][j]='.';
					s[i][j]='.';
					s[i+1][j+1]='.';
					continue;
				}
				if(s[i][j]==s[i][j+1]&&s[i][j+2]==s[i][j+3]&&s[i][j]==s[i][j+3]){
					f2++;
					s[i][j]='.';
					s[i][j+1]='.';
					s[i][j+2]='.';
					s[i][j+3]='.';
					continue;
				}
				if(s[i][j]==s[i+1][j]&&s[i+2][j]==s[i+3][j]&&s[i][j]==s[i+3][j]){
					f2++;
					s[i][j]='.';
					s[i+1][j]='.';
					s[i+2][j]='.';
					s[i+3][j]='.';
					continue;
				}
				if(s[i][j]==s[i+1][j]&&s[i][j]==s[i+1][j-1]&&s[i][j]==s[i+2][j-1]){
					f4++;
					s[i][j]='.';
					s[i+1][j]='.';
					s[i+1][j-1]='.';
					s[i+2][j-1]='.';
					continue;
				}
				if(s[i][j]==s[i][j+1]&&s[i][j]==s[i+1][j+1]&&s[i][j]==s[i+1][j+2]){
					f4++;
					s[i][j]='.';
					s[i][j+1]='.';
					s[i+1][j+1]='.';
					s[i+1][j+2]='.';
					continue;
				}
				if(s[i][j]==s[i+1][j]&&s[i][j]==s[i+1][j+1]&&s[i][j]==s[i+2][j+1]){
					f3++;
					s[i][j]='.';
					s[i+1][j]='.';
					s[i+1][j+1]='.';
					s[i+2][j+1]='.';
					continue;
				}
				if(s[i][j]==s[i+1][j-1]&&s[i][j]==s[i+1][j]&&s[i][j]==s[i][j+1]){
					f3++;
					s[i][j]='.';
					s[i+1][j]='.';
					s[i+1][j-1]='.';
					s[i][j+1]='.';
					continue;
				}
				if(s[i][j]==s[i+1][j-1]&&s[i][j]==s[i+1][j]&&s[i][j]==s[i+1][j+1]){
					f5++;
					s[i][j]='.';
					s[i+1][j-1]='.';
					s[i+1][j]='.';
					s[i+1][j+1]='.';
					continue;
				}
				if(s[i][j]==s[i][j+1]&&s[i][j]==s[i][j+2]&&s[i][j]==s[i+1][j+1]){
					f5++;
					s[i][j]='.';
					s[i][j+1]='.';
					s[i][j+2]='.';
					s[i+1][j+1]='.';
					continue;
				}
				if(s[i][j]==s[i+1][j]&&s[i][j]==s[i+1][j+1]&&s[i][j]==s[i+2][j]){
					f5++;
					s[i][j]='.';
					s[i+1][j]='.';
					s[i+1][j+1]='.';
					s[i+2][j]='.';
					continue;
				}
				if(s[i][j]==s[i-1][j+1]&&s[i][j]==s[i][j+1]&&s[i][j]==s[i+1][j+1]){
					f5++;
					s[i][j]='.';
					s[i-1][j+1]='.';
					s[i][j+1]='.';
					s[i+1][j+1]='.';
					continue;
				}
			}
		}
	}
	
	cout<<f1<<endl;
	cout<<f2<<endl;
	cout<<f3<<endl;
	cout<<f4<<endl;
	cout<<f5<<endl;
	return 0;
}

```

---

## 作者：Esawkm (赞：0)

[传送门qwq](https://www.luogu.com.cn/problem/P4420)

---
数据很小，考虑纯模拟。

方块可以旋转，一个方块可能以多种方式出现，其他就是小细节了。

```
#include<bits/stdc++.h>
using namespace std;
char a[1005][1005];
int ans1,ans2,ans3,ans4,ans5,n,m;
int main() {
	/*std::ios::sync_with_stdio(false);*/
	cin>>n>>m;
	for(int i(1); i<=n; i++)
		for(int j(1); j<=m; j++)
			cin>>a[i][j];
	for(int i(1); i<=n; i++)
		for(int j(1); j<=m; j++)
			if(a[i][j]!='.')
				if(a[i][j]==a[i+1][j]&&a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j+1])
					++ans1;
				else if((a[i][j]==a[i][j+1]&&a[i][j+2]==a[i][j+3]&&a[i][j]==a[i][j+3])||(a[i][j]==a[i+1][j]&&a[i+2][j]==a[i+3][j]&&a[i][j]==a[i+3][j]))
					++ans2;
				else if((a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+2][j+1])||(a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+1][j]&&a[i][j]==a[i][j+1]))
					++ans3;
				else if((a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+2][j-1])||(a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+1][j+2]))
					++ans4;
				else if((a[i][j]==a[i+1][j-1]&&a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j+1])||(a[i][j]==a[i][j+1]&&a[i][j]==a[i][j+2]&&a[i][j]==a[i+1][j+1])||(a[i][j]==a[i+1][j]&&a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+2][j])||(a[i][j]==a[i-1][j+1]&&a[i][j]==a[i][j+1]&&a[i][j]==a[i+1][j+1]))
					++ans5;
	cout<<ans1<<endl<<ans2<<endl<<ans3<<endl<<ans4<<endl<<ans5<<endl;
	return 0;
}
```

---

## 作者：DegChuZm (赞：0)

# 简单的暴力

本蒟蒻的的第一篇题解，不喜勿喷。

这道题的原本思路是一道 dfs。

but，这道题由于题目数据过小 $n,m<10$，可以直接暴力枚举每种方块的每种样子过掉。

最后把答案装在一个数组里输出就行啦。

``` cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,o,ans[1001];
char a[1001][1001];
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];//输入用什么都行，用cin只是因为简单
		}	
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]!='.'){//如果不是空的地方，就代表它一定是个方块
               //以下是对每种方块样子的枚举。
			if(a[i][j]==a[i+1][j]&&a[i+1][j]==a[i+1][j+1]&&a[i+1][j+1]==a[i][j+1])
					ans[1]++;
			else if(a[i][j]==a[i+1][j]&&a[i+1][j]==a[i+2][j]&&a[i+2][j]==a[i+3][j])
					ans[2]++;
			else if(a[i][j]==a[i][j+1]&&a[i][j+1]==a[i][j+2]&&a[i][j+2]==a[i][j+3])
					ans[2]++;
			else if(a[i][j]==a[i][j+1]&&a[i][j+1]==a[i-1][j+1]&&a[i-1][j+1]==a[i-1][j+2])
					ans[3]++;
			else if(a[i][j]==a[i-1][j]&&a[i-1][j]==a[i-1][j-1]&&a[i-1][j-1]==a[i-2][j-1])
					ans[3]++;
        else if(a[i][j]==a[i][j+1]&&a[i][j+1]==a[i-1][j]&&a[i-1][j]==a[i-1][j-1])
					ans[4]++;
			else if(a[i][j]==a[i-1][j]&&a[i-1][j]==a[i-1][j+1]&&a[i-1][j+1]==a[i-2][j+1])
					ans[4]++;
			else if(a[i][j]==a[i-1][j]&&a[i-1][j]==a[i-1][j+1]&&a[i-1][j+1]==a[i-1][j-1])
					ans[5]++;
			else if(a[i][j]==a[i-1][j]&&a[i-1][j]==a[i-2][j]&&a[i-1][j]==a[i-1][j-1])
					ans[5]++;
			else if(a[i][j]==a[i+1][j]&&a[i+1][j]==a[i+1][j-1]&&a[i+1][j-1]==a[i+1][j+1])
					ans[5]++;
			else if(a[i][j]==a[i-1][j]&&a[i-1][j]==a[i-2][j]&&a[i-1][j]==a[i-1][j+1])
					ans[5]++;
			}
		}	
	}
	for(int i=1;i<=5;i++){
		cout<<ans[i]<<endl;//输出答案
	}
}```
```





---

## 作者：Eason_AC (赞：0)

## Content
有一个 $n\times m$ 的拼图，摆上了几块俄罗斯方块图形。已知这些图形可能包含以下这五种（**可以旋转**），求出下列类型的俄罗斯方块图形数量。

![](https://cdn.luogu.com.cn/upload/pic/17376.png)

**数据范围：$1\leqslant n,m\leqslant 10$。**
## Solution
像我这样菜的人，这种题目只有一种方法：**暴力判断**。

各位玩过俄罗斯方块的都知道，上面 $5$ 种图形中，第一种图形无论怎么旋转都是一样的，第二、三、四种都可以通过旋转得到两种不同的图形，第五种可以通过旋转得到 $4$ 种不同的图形。具体是什么样的想必各位都能够想象得出来。

于是，我们只需要对这总共 $1+2\times 3+4=11$ 种情况进行暴力判断就好了。抓住这些图形的特征，并转化成代码语言就能够迎刃而解。

然而最烦人的就是打代码的过程……![px](https://cdn.luogu.com.cn/upload/pic/62246.png)
## Code
仅搬出判断五种不同类型的图形的函数 $\texttt{judge1}\sim\texttt{judge5}$，毕竟这才是整个代码的精髓，也是我打得最要命的地方……
```cpp
inline bool judge1(int i, int j) {return a[i][j] != '.' && (a[i][j] == a[i + 1][j] && a[i][j] == a[i + 1][j + 1] && a[i][j] == a[i][j + 1]);}
inline bool judge2(int i, int j) {return a[i][j] != '.' && ((a[i][j] == a[i][j + 1] && a[i][j] == a[i][j + 2] && a[i][j] == a[i][j + 3]) || (a[i][j] == a[i + 1][j] && a[i][j] == a[i + 2][j] && a[i][j] == a[i + 3][j]));}
inline bool judge3(int i, int j) {return a[i][j] != '.' && ((a[i][j] == a[i][j - 1] && a[i][j] == a[i + 1][j - 1] && a[i][j] == a[i + 1][j - 2]) || (a[i][j] == a[i + 1][j] && a[i][j] == a[i + 1][j + 1] && a[i][j] == a[i + 2][j + 1]));}
inline bool judge4(int i, int j) {return a[i][j] != '.' && ((a[i][j] == a[i][j + 1] && a[i][j] == a[i + 1][j + 1] && a[i][j] == a[i + 1][j + 2]) || (a[i][j] == a[i + 1][j] && a[i][j] == a[i + 1][j - 1] && a[i][j] == a[i + 2][j - 1]));}
inline bool judge5(int i, int j) {return a[i][j] != '.' && ((a[i][j] == a[i + 1][j - 1] && a[i][j] == a[i + 1][j] && a[i][j] == a[i + 1][j + 1]) || (a[i][j] == a[i - 1][j - 1] && a[i][j] == a[i][j - 1] && a[i][j] == a[i + 1][j - 1]) || (a[i][j] == a[i - 1][j - 1] && a[i][j] == a[i - 1][j] && a[i][j] == a[i - 1][j + 1]) || (a[i][j] == a[i - 1][j + 1] && a[i][j] == a[i][j + 1] && a[i][j] == a[i + 1][j + 1]));}
```

---

## 作者：Illusory_dimes (赞：0)

# 搞事情的普及

### 这是第一道让本蒟蒻产生剁手想法的普及题

## ~~然鹅，这只是一个~~看似简单但是费代码的题

纯模拟再加点不像样的搜索

上代码吧，~~上完我就去睡觉~~
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[11][11];
int sum[6],n,m;
void rm(int x,int y){
	char c=s[x][y];
	s[x][y]='.';
	if(s[x-1][y]==c)rm(x-1,y);
	if(s[x+1][y]==c)rm(x+1,y);
	if(s[x][y-1]==c)rm(x,y-1);
	if(s[x][y+1]==c)rm(x,y+1);
}
int ck(int x,int y){
	char c=s[x][y];
	if(s[x+1][y]==c&&s[x+1][y+1]==c&&s[x][y+1]==c)//转了等于没转所以就一种
		return 1;//Figure1判断
	if(s[x][y+1]==c&&s[x][y+2]==c&&s[x][y+3]==c)return 2;//竖着
	if(s[x+1][y]==c&&s[x+2][y]==c&&s[x+3][y]==c)return 2;//横着
	//Figure2判断
	if(s[x][y+1]==c&&s[x+1][y]==c&&s[x+1][y-1]==c)return 3;//竖着
	if(s[x+1][y]==c&&s[x+1][y+1]==c&&s[x+2][y+1]==c)return 3;//横着
	//Figure3判断
	if(s[x][y+1]==c&&s[x+1][y+1]==c&&s[x+1][y+2]==c)return 4;//竖着
	if(s[x+1][y]==c&&s[x+1][y-1]==c&&s[x+2][y-1]==c)return 4;//横着
	//Figure4判断
	else return 5;//Figure5(懒得写了[有四种])
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		cin>>s[i][j];
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
		if(s[i][j]!='.'){
			sum[ck(i,j)]++;//相应Figure寻找
			rm(i,j);
		}
	for(int i=1;i<=5;i++){
		if(i<5)cout<<sum[i]<<endl;
		else cout<<sum[i];
	}return 0;
}
```


---

## 作者：_•́へ•́╬_ (赞：0)

### 纯模拟，就是
# 烦
```cpp
//#include<bits/stdc++.h>//懒人专用头文件
#include<stdio.h>
#include<vector>
#include<set>
using namespace std;
#define max(x,y) ((x)>(y)?(x):(y))
#define max4(a1,a2,a3,a4) (max(max((a1),(a2)),max((a3),(a4))))
#define min(x,y) ((x)<(y)?(x):(y))
#define min4(a1,a2,a3,a4) (min(min((a1),(a2)),min((a3),(a4))))
#define x first
#define y second
int n,m,ans[6];char a[10][11],f;vector<pair<int,int> >now;set<pair<int,int> >s;
void dfs(int x,int y)
{
	if(x<0||x>=n||y<0||y>=m||a[x][y]!=f)return;
	now.push_back(pair<int,int>(x,y));a[x][y]='.';
	dfs(x-1,y);dfs(x+1,y);dfs(x,y-1);dfs(x,y+1);
}
main()
{
	scanf("%d%d\n",&n,&m);
	for(register int i=0;i<n;++i)gets(a[i]);
	//=====以=====上=====为=====输=====入=====
	for(register int i=0;i<n;++i)for(register int j=0;j<m;++j)
		if(a[i][j]!='.')
		{
			now.clear();f=a[i][j];
			dfs(i,j);
			pair<int,int>minn(min4(now[0].x,now[1].x,now[2].x,now[3].x)
			    			 ,min4(now[0].y,now[1].y,now[2].y,now[3].y));
			//存行列最小的那个格（可能不是这个方块里的）
			pair<int,int>maxn(max4(now[0].x,now[1].x,now[2].x,now[3].x)
			    			 ,max4(now[0].y,now[1].y,now[2].y,now[3].y));
			//存行列最大的那个格（可能不是这个方块里的）
			if(maxn.x-minn.x==1&&maxn.y-minn.y==1){++ans[1];continue;}
			//最大最小列的差和最大最小行的差都是1，是第一种
			if(maxn.x==minn.x){++ans[2];continue;}//都在同一行，是第二种
			if(maxn.y==minn.y){++ans[2];continue;}//都在同一列，是第二种
			if((now[0].x==now[1].x)+(now[0].x==now[2].x)+(now[0].x==now[3].x)
			  +(now[1].x==now[2].x)+(now[1].x==now[3].x)+(now[2].x==now[3].x)==3)
				{++ans[5];continue;}//有三个都在同一行，是第五种
			if((now[0].y==now[1].y)+(now[0].y==now[2].y)+(now[0].y==now[3].y)
			  +(now[1].y==now[2].y)+(now[1].y==now[3].y)+(now[2].y==now[3].y)==3)
			   {++ans[5];continue;}//有三个都在同一列，是第五种
			//--下--面--只--剩--3、4--两--种--难--区--分--的--了--
			s.clear();//搞一个set用来判断是否包含
			s.insert(now[0]);s.insert(now[1]);s.insert(now[2]);s.insert(now[3]);
			//全部塞到set里面去
			if(maxn.x-minn.x==1)//这一块在2行里，说明没有旋转
			{
				if(s.count(minn)&&s.count(maxn)){++ans[4];continue;}
				++ans[3];
			}
			else//旋转了
			{
				if(s.count(minn)&&s.count(maxn)){++ans[3];continue;}
				++ans[4];
			}
		}
	//=====以=====下=====为=====输=====出=====
	printf("%d\n%d\n%d\n%d\n%d",ans[1],ans[2],ans[3],ans[4],ans[5]);
}/**/
```

---

## 作者：_liangbowen_ (赞：0)

# 「COCI2017/2018」tetris
## 题目链接
[「COCI2017/2018」tetris](https://www.luogu.com.cn/problem/P4420)
## 思路
这道题一看题面(~~这不就是膜你吗?~~)

只需要判断5种方块的不同形态即可，注意一下如果是 `.`,需要跳过
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p[7];
char a[15][15];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){//判断各种情况
			char t=a[i][j];
			if(t=='.') continue;//如果是点要跳过
			if(a[i+1][j]==t&&a[i][j+1]==t&&a[i+1][j+1]==t) p[1]++;
			if(a[i][j+1]==t&&a[i][j+2]==t&&a[i][j+3]==t) p[2]++;
			if(a[i+1][j]==t&&a[i+2][j]==t&&a[i+3][j]==t) p[2]++;
			if(a[i][j+1]==t&&a[i+1][j-1]==t&&a[i+1][j]==t) p[3]++;
			if(a[i+1][j]==t&&a[i+1][j+1]==t&&a[i+2][j+1]==t) p[3]++;
			if(a[i][j+1]==t&&a[i+1][j+1]==t&&a[i+1][j+2]==t) p[4]++;
			if(a[i+1][j]==t&&a[i+1][j-1]==t&&a[i+2][j-1]==t) p[4]++;
			if(a[i-1][j+1]==t&&a[i][j+1]==t&&a[i][j+2]==t) p[5]++;
			if(a[i+1][j-1]==t&&a[i+1][j]==t&&a[i+2][j]==t) p[5]++;
			if(a[i][j+1]==t&&a[i][j+2]==t&&a[i+1][j+1]==t) p[5]++;
			if(a[i+1][j]==t&&a[i+1][j+1]==t&&a[i+2][j]==t) p[5]++;
		}
	}
	for(int i=1;i<=5;i++){
		printf("%d\n",p[i]);
	}
	return 0;
}
```


---


# [COCI 2017/2018 #4] Rasvjeta / 路灯

## 题目描述

在一条 $N$ 米长的路上有 $M$ 个路灯。每个路灯能够照亮其左右 $K$ 米，即如果在 $X$ 米处安放路灯，则从 $X-K$ 米处到 $X+K$ 米处都被照亮。

但是，有可能这条路上有些地方没有被照亮。请求出至少要再安放多少路灯才能让这条路的 $1$ 米处（**注意**：不是 $0$ 米处）到 $N$ 米处都被照亮。

## 说明/提示

### 样例解释
对于第一组样例，这条路已经被全部照亮了，不需要添加路灯。

对于第三组样例，这条路只有 $13$ 米处没有被照亮，在 $3$ 米和 $13$ 米之间任意添加 $1$ 盏路灯就可以让整条路被照亮。

### 数据范围

对于全部数据，$1 \le M \le N \le 1000,\ 0 \le K \le N,\ 1 \le a_i \le N$。

## 样例 #1

### 输入

```
5
2
2
1
5```

### 输出

```
0```

## 样例 #2

### 输入

```
26
3
3
3
19
26
```

### 输出

```
2```

## 样例 #3

### 输入

```
13
2
10
1
2
```

### 输出

```
1```

# 题解

## 作者：Kaedeuim (赞：7)

要想开始着手切这道题，那必须得知道题面讲什么，很不幸，这道题没有翻译……

那么我来翻译一下吧！

### 题目描述：

```

现在是夜幕降临的时候。在N米长的街道上有M个路灯（街道的米数用1
到N之间的数字表示）。每一盏灯都会点亮它所在街道的相应米数，并
在该位置的左右两侧各亮K米。换句话说，如果灯光位于X米处，它将
照亮从X-K到X+K的所有米的街道，包括X-K。当然，一米的街道有可能
被多个路灯照亮。所有的灯都有不同的位置。

问题是，有一种可能性是，路灯并没有照亮整条街道的N米。您的任务
是确定需要安装的最小数量的额外灯光（位置从1到N），以便照亮整
条街道。

```

### 输入格式：

```
输入的第一行包含街道的米数N（1≤N≤1000）。
第二行输入包含灯数M（1≤M≤N）。
第三行包含照亮左右米数的K（0≤K≤N）。
下面的M行中的每一行都包含一个数字。这些数字按升序排序，代表
每个路灯的位置。
该位置将在区间[1，N]之间。
```

### 输出格式：

```
必须按照题目要求输出。
```

$\text{---------不华丽的分割线---------}$

现在让我们分析这道题。

第一眼看上去是个模拟。

我们只要打个数组存储每一米街道的状态即可，因为题面说一米的街道可能被多个路灯同时照亮，所以不用考虑亮度问题，照到的打标记$1$，没照到的默认为$0$。

我们已经解决了第一个问题。

那么接下来就是整个题目的精髓：**贪心**。

怎么贪呢？

尽量少放灯，换而言之就是让**最少的灯发挥最大的价值**，即在**你放置的灯**中，尽可能地让两盏灯之间没有互交的地方。

来看看我的办法：每当我们找到一个没有被照到的阴暗处时，放灯。但是注意，不论是几米的阴暗部分，至少要放一盏灯，然后在你当前的位置上向前$2K$的距离打上标记，这才是贪心精髓。

然后莫忘了结尾特判。

还有一件事，超出区间会RE，最好小心点哦。

# AC Code

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[10000001];
int main()
{
	int n,m,k,kk;
	int ans=0; 
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)
    {
        cin>>kk;
        for(int j=max(kk-k,1);j<=min(kk+k,n);j++)//照到的部分打标记，还有在区间内办事
        {
        	a[j]=1;
		}
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]!=1)
        {
            for(int j=i;j<=min(i+2*k,n);j++)//每找到一个向后打2K个标记，还有在区间内办事
                a[j]=1;
            ans++;
        }
    }
    if(a[n]==0)ans++;//结尾特判
    cout<<ans;
    return 0; 
}
```

#### ~~说句闲话：我要是修这条路的人，一定会被晚上开车经过这里的人喷死~~

###### 管理员求过~

---

## 作者：CLCK (赞：3)

### ~~这是道难题。~~

### ~~因为没有翻译。~~

大致题意见题解区。

我就直接来讲做法吧：先按照题目给出的灯的位置进行标记，然后**从前到后**依次遍历路的位置，找到第一个没有灯照亮的区间，**贪心**，给它装上灯，并且**使这个灯的位置尽量靠后**（确保**不浪费照亮范围**），累加答案，最后输出即可。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int MAX = 1005;
int ans;
int n, m, k;
bool flag[MAX];
void work(int x) { //标记照亮部分
	for (int i = max(x - k, 1); i <= min(n, x + k); i++) { 
	    //防止越界（小心RE）
		flag[i] = true;
	}
}
int main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= m; i++) { //读入并标记
	    int x;
	    cin >> x;
	    work(x);
	}
	for (int i = 1; i <= n; i++) { //贪心
	    if (!flag[i]) {
	        work(i + k); //标记（这里i+k是让灯尽量靠后，见上面解法）
	        ans++; //累加答案
	    }
	}
	cout << ans << endl; //输出
	return 0;
}
```

### 完结撒花～

#### ~~这么认真不留下个赞再走嘛～~~

---

## 作者：Correct_ (赞：2)

首先不得不说:**这道题不是很难**

**BUT,他没有翻译**

~~于是他很难~~

为了帮助大家着手解决这道题,我来翻译一下:
# 题目描述:
**现在是降临节。N米长的街道上有M个路灯（街道的米用1到N之间的数字表示）。每一盏灯都会点亮它所在街道的米数，并在该位置的左右两侧各亮K米。换句话说，如果灯光位于X米处，它将照亮从X-K到X+K的所有米的街道，包括X-K。当然，一米的街道有可能被多个路灯照亮。所有的灯都有不同的位置。
问题是，有一种可能性是，路灯并没有照亮整条街道的N米。你的任务是确定需要安装的最小数量的额外灯光（位置从1到N），以便照亮整条街道**

# 输入格式:
**输入的第一行包含数字N（1≤N≤1000）。
第二行输入包含数字M（1≤M≤N）。
第三行包含数字K（0≤K≤N）。
下面的M行中的每一行都包含一个数字。这些数字按升序排序，代表每个M路灯的位置
位置将与间隔[1，N]不同。**
# 输出格式:
**你必须按照任务中输出所需的数字** 
# 题目分析:
看见这一句了吗:"你的任务是确定需要安装的最小数量的额外灯光（位置从1到N），",尽量以最少的灯发出最亮的光

哦没错，这就得用到"贪心算法"

贪心算法:举个例子，比如有一堆钱，你肯定拿一张100元的，不会拿一张1毛钱的
.核心思想就是获取最大利益

比如说这个地方的市长，十分吝啬，为了省电不希望有灯光交织的地方

所以需要每隔一段所需距离，才有一盏灯，贪心是这么用的

转回题目，两盏灯之间的没有灯的区域（假设有，特判即可）为$pos $-$K$-$last$-$1pos$−$K$−$last$−$1$

一盏灯可以照亮自己的位置，左边KK格以及右边KK格，共计2K+12K+1格


# 代码:
```
#include<iostream>
#include<cstdio>

using namespace std;

int ans;
int n,m,k;

bool flag[1005];

void move(int x)
{
	for(int i=max(x-k,1);i<=min(n,x+k);i++)
		flag[i]=true;
	return ;
}

int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1,x;i<=m;i++)
		scanf("%d",&x),move(x);
	for(int i=1;i<=n;i++)
		if(!flag[i]) move(i+k),ans++;
	printf("%d\n",ans);
	return 0;
}
```
求过啊~





---

## 作者：清清老大 (赞：1)

## 题目大意

在一条长$N(1 \leq N \leq 1000)$米的街道上有$M(1 \leq M \leq N)$盏路灯,每盏路灯照亮区间$(pos - K,pos + K),(0 \leq K \leq N)$中的所有街道。问最少需要添加多少路灯才能使所有街道被全部照亮?

### 输入

第一行包含一个正整数$N$。

第二行包含一个正整数$M$。

第三行包含一个正整数$K$。

接下来的$M$行,每行输入一个正整数,表示第$M$盏灯对应的位置。

### 输出

输出一个正整数,表示需要路灯的最少数量。

## 题解

这题用贪心做,让放下的灯之间的距离尽可能远，距离最大是$2k$。

```cpp
#include<bits/stdc++.h>

using namespace std;

int main()
{
    int n,m,k;
    int sum = 0; //sum记录需要添加的路灯数量
    bool flag[2000] = {0}; //flag[i]用于记录第i米的街道是否被照亮
    cin >> n >> m >> k;
    for(int i = 0;i < m;i ++)
    {
        int pos;// pos代表的是第i盏路灯的位置
        cin >> pos;
        for(int j = max(pos - k,1);j <= min(n,pos + k);j ++)
        {
            flag[j] = true; //标记照亮的部分
        }
    }
    for(int i = 1;i <= n;i ++)
    {
        if(!flag[i])//等同于if(flag[i] == false)
        {
            i += k + k;//在第(i+k)米的马路上放灯
            sum ++;//总数量加1
        }
    }
    cout << sum;
    return 0;
}
```


---

## 作者：2132B (赞：1)

这道题妥妥地模拟

首先，先对题目进行翻译

题意：有一条街，上面有路灯，告诉你路灯的位置和每盏路灯能照亮左右两侧的距离，再告诉你路的长度，求最少得再添多少盏路灯

上code

```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n,m,k,a[10001]={0},x,s;//数组a来储存亮度 
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)
    {
        cin>>x;
        for(int j=max(x-k,1);j<=min(x+k,n);j++)//要排除越界的情况 
            a[j]=1;
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]!=1)//当发现有地方是黑暗时 
        {
            for(int j=i;j<=min(i+2*k,n);j++)//同样    
                a[j]=1;
            s++;
        }
    }
    cout<<s;
    return 0; 
}
```

~~完全考英语QAQ~~

时间复杂度为 $O(N^2)$ 。

似乎有 $O(N)$ 做法，但我太懒了。


---

## 作者：亦笙箫 (赞：1)

这道题的最大难点,在于...  
**它是英文的...**  
只要我们把题目翻译一下,就非常的简单了.  
# 题目大意

## 输入

第一行包含一个正整数$N(1≤N≤1000)$,表示街道长度.  
第二行包含一个正整数$M(1≤M≤N)$,表示路灯的数量.    
第三行包含一个正整数$K(0≤K≤N)$,表示每盏路灯能够照亮的左右两侧的距离. 
**注意:这里是闭区间,包括了两个端点($i-k$,$i+k$)**  
接下来$M$行,每行输入一个数字,表示每盏灯相对应的位置. 

## 输出

需要添加的路灯的最少数量.

*******
了解了题意之后,这就是一道膜拟了.  
输入的时候处理掉已经被照亮的街道区域.
然后贪心模拟,  
即在必要的地方才放路灯,不然不放.
就可以的出正确答案了.

## $Code$

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int ans;
int n,m,k;

bool flag[1005];

void move(int x)
{
	for(int i=max(x-k,1);i<=min(n,x+k);i++)
		flag[i]=true;
	return ;
}

int main()
{
//	freopen("rasvjeta.in","r",stdin);
//	freopen("rasvjeta.out","w",stdout);
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1,x;i<=m;i++)
		scanf("%d",&x),move(x);
	for(int i=1;i<=n;i++)
		if(!flag[i]) move(i+k),ans++;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：_Qer (赞：1)

此解法时间复杂度$O(n)$，空间复杂度低（不开数组）

用一个变量`last`表示上一个灯所能够照到的最远距离，当前灯的位置为`pos`，则两盏灯之间的没有灯的区域（假设有，特判即可）为$pos-K-last-1$  
例子（$N=8,M=2,K=1$）：    

| 位置 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 是否有灯 | true | false | false | false | true | flase | true | false |
| 能否照亮 | true | true | false | true | true | true | true | true |

当判断到灯2时，`last=2,pos=5`，可带入上式验证

----

一盏灯可以照亮自己的位置，左边$K$格以及右边$K$格，共计$2K+1$格，同样可带入上面例子验证

----

所以，一片黑暗地带（无光照）所需的灯数量即：  
$$\left\lceil\dfrac{pos-K-last-1}{2K+1}\right\rceil$$

将所有黑暗地带所需灯数量相加即可（记得最后一盏灯到街末尾需要计算）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, last, ans;
int main() {
    scanf("%d%d%d", &n, &m, &k);
    last = 0;
    for (int i = 1, pos; i <= m; ++i) {
        scanf("%d", &pos);
        if (last < pos - k)//先特判是否有黑暗地带
            ans += (pos - k - last - 1) / (2 * k + 1) + ((pos - k - last - 1) % (2 * k + 1) != 0);
        last = pos + k;//更新
    }
    if (last < n)//特判街末尾是否有黑暗地带
        ans += (n - last) / (2 * k + 1) + ((n - last) % (2 * k + 1) != 0);
    cout << ans << endl;
    return 0;
}

```

---

## 作者：RioBlu (赞：1)

此题应该是普及-

## 输入a b c

a代表有几米长

b表示照射范围

c表示有多少个路灯

然后把照亮的地方为1

# 否则为0

找到一串连续为0或单个为0的地方

如果 长度%b>0 ans++

ans+=长度/b

输出ans
```
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,e,f;
bool t[2000];
int main()
{
    cin>>a>>b>>c;
    for(int s=0;s<b;s++)
    {
        cin>>d;
        for(int v=d-c;v<=d+c;v++)
        {
            if(v>=1)
            {
                t[v]=1;
            }
        }
    }
    d=0;
    for(int s=1;s<=a;s++)
    {
        if(t[s]==false)
        {
            d++;
        }
        else
        {
            if(d%(2*c+1)>=1)e++;
            d=d/(2*c+1);
//          cout<<d<<endl;
            e=e+d;
            d=0;
        }
    }
    if(d>=1)
    {
        if(d%(2*c+1)>=1)e++;
        d=d/(2*c+1);
//      cout<<d<<endl;
        e=e+d;
        d=0;
    }
    cout<<e<<endl;
    return 0;
}
```
###### 是不是很简单?

---

## 作者：tribool4_in (赞：0)

这道题算法：贪心+模拟。

首先将能照到的地方标记为 $1$，照不到为 $0$。然后就挨个搜每个位置 $i$，如果照不到（为 0）则在 $i+k$ 的位置放一个灯并打上标记。最后放了几个路灯就输出几。

不过有一点可以减少码量：放灯的过程可以转化为这样：如果当前位置 $i$ 照不到，则把 $i$ ~ $(i+2k)$ 都打上标记。

最后要注意：**一定要判断出界！！！**

代码：

```cpp
// Code By WLS
#include <bits/stdc++.h>
const int N = 2e4 + 5;
using namespace std;
int n, m, k;
int a[N];
signed main() {
	int ans = 0;
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= m; i++) {
    	int tmp;
        scanf("%d", &tmp);
        for (int j = max(tmp - k, 1); j <= min(tmp + k, n); j++) {
            a[j] = 1;
        }
    }
    for (int i = 1; i <= n; i++) {
        if (a[i] != 1) {
            for (int j = i; j <= min(i + 2 * k, n); j++) a[j] = 1;
            ans++;
        }
    }
    if(a[n] == 0) ans++;
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：zhuchenzhang (赞：0)

[题目链接](https://www.luogu.org/problemnew/show/P4519)

先来画一个简单的图~~（技术不好请原谅）~~

设有$1$盏灯，$K=\frac{N}{4}$，灯在$\frac{N}{4}$号位置，可以照亮的范围大概是这样的：

![](https://cdn.luogu.com.cn/upload/pic/54217.png)

我们考虑加入下一盏灯。$1$、$2$、$3$号位之间距离都为$\frac{N}{4}$，显然下一盏灯需加在2号位。

对于这种情况:

![](https://cdn.luogu.com.cn/upload/pic/54218.png)

中间暗的部分小于$K$的值，那我们直接在第一个暗的位置放灯。

再考虑如何实现它。

```cpp
int temp=0;
if(!b[i])//找到一个位置没有光照
{
	for(int j=i;!b[j]&&j<=n;++j,temp=j);//找到下一个有光的位置
    //比较是否够插一盏灯
	if(temp>k)//够插一盏灯
	{
	 	b[i+k]=true;//在最远距离放灯
	 	for(int j=i;j<=i+2*k;++j) b[j]=true;//将影响范围内的位置赋值
	}
	else//不够插
	{
	 	b[i]=true;//直接放上灯
	 	for(int j=i;j<=i+k;++j) b[j]=true;//将影响范围内的位置赋值
	}
	++ans;//答案加一
}
```

然后就有了如下暴力算法：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,ans;
bool b[2000001];//记录是否有光照
int main()
{
    cin>>n>>m>>k;
    for(int a,i=1;i<=m;++i)
    {
        cin>>a;
        int j;
        if(a-k<=0) j=1;//优化
        else j=a-k;
        for(;j<=a+k;++j) b[j]=true;//将光照范围内的位置赋值
    }
    int temp=0;//用来找位置
    for(int i=1;i<=n;++i)//暴力过程
    {
        temp=0;
        if(!b[i])
        {
            for(int j=i;!b[j]&&j<=n;++j,temp=j);
            if(temp>k)
            {
                b[i+k]=true;
                for(int j=i;j<=i+2*k;++j) b[j]=true;
            }
            else
            {
                b[i]=true;
                for(int j=i;j<=i+k;++j) b[j]=true;
            }
            ++ans;
        }
    }
    printf("%d",ans);
    return 0;
}
```



---


# 【深基16.例1】淘汰赛

## 题目描述

有 $2^n$（$n\le7$）个国家参加世界杯决赛圈且进入淘汰赛环节。已经知道各个国家的能力值，且都不相等。能力值高的国家和能力值低的国家踢比赛时高者获胜。1 号国家和 2 号国家踢一场比赛，胜者晋级。3 号国家和 4 号国家也踢一场，胜者晋级……晋级后的国家用相同的方法继续完成赛程，直到决出冠军。给出各个国家的能力值，请问亚军是哪个国家？

## 样例 #1

### 输入

```
3
4 2 3 1 10 5 9 7
```

### 输出

```
1
```

# 题解

## 作者：yangrunze (赞：335)

继续承包[入门赛](https://www.luogu.com.cn/blog/ravenclawyangrunze/solution-p5266)[压轴题](https://www.luogu.com.cn/blog/ravenclawyangrunze/solution-p5318)题解~

这次比赛的压轴题，是关于**求最值**的题目：先相邻的两两求最大值，再把这些最大值重复操作，直到最后为止。

一看这架势：递归？？？嗯，确实是递归不假，咱来画个图看看：

![](https://cdn.luogu.com.cn/upload/image_hosting/ju5vofvm.png)

哎，咱一看，怎么那么像棵**二叉树**呢？而且，这棵二叉树里，**父节点存储的是左右子节点的最大值**！其实，这东西不光是棵二叉树，还是一种更特殊的的数据结构——**线段树**！

啥事线段树你呢？别慌，咱先看个栗子：

有n个数，m次操作，操作可以**修改某一个数**或者**查询一段区间的值**

当然，这题修改操作$O(1)$就行，求和可以用$O(n)$方法一个个暴力去加，但是如果n和m都很大呢？？？...你懂得.....

这时聪明的小伙伴就想到了：我们可以开一个**前缀和**数组呀！这回求和操作倒是可以$O(1)$了，但修改操作嘛......每改一次，每个前缀和都要改一遍，还是难逃$O(n)$的命运啊......

那就没设么好的方法了吗？有啊！好方法就是我们前面说的线段树了，它可以把时间复杂度降低降低再降低，**把修改和查询的时间复杂度都降到$O(\log n)$**！！！

说到这了，咱先瞅瞅这线段树长啥样，当当当当~：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ltzf6sw.png)

没错，线段树就长这个样！就是一棵二叉树，但是这颗二叉树有一个神奇的性质：**每个父节点是它的两个子节点的值的和**！

那为什么用了这个东西，就能降时间复杂度呢？？？别急，咱们先来看几个具体例子：

首先看修改的栗子，把节点中的2加3（也就是把2改成5）

![](https://cdn.luogu.com.cn/upload/image_hosting/rzo54j8q.png)

只要像这个图一样，找到节点2，把2加上3，然后顺着路一个一个改上来就行了~

再来看查询的栗子：求区间2~5的和

![](https://cdn.luogu.com.cn/upload/image_hosting/uxr7fvje.png)

还是用递归的思想：

2~5的和

=2~3的和+4~5的和

=2+3+4~5的和

=2+3+9

=14

总之，就是沿着线段树的划分把区间分开，再加到一块就行啦！



------------
看了刚才的栗子，线段树确实能让时间复杂度降低不少，不过这么好个东西，咱们怎么来存它呢？？

（说句闲话：这棵树怎么那么像**完全二叉树**呢？？）

既然那么像完全二叉树，那咱们就硬核补几个顶点，把它变成完全二叉树吧！

![](https://cdn.luogu.com.cn/upload/image_hosting/mwfo06sx.png)

既然能补上完全二叉树，那就好办了，我们就可以直接用一个**数组**来存它！

为啥用数组就好了呢？因为我们有**完全二叉树的性质**呀！

就像上图一样把各个节点标上号，如果**根节点编号是$n$,那它的左子树编号是$2n$,右子树的编号是$2n+1$**

所以说，知道了根节点的编号，我们就可以快速有效的找到左右子树的根节点

接下来就是放代码的时候了：首先，建立一棵线段树：

```cpp
ll arr[100010]={0},tree[500050]={0};  //arr为存储数据的数组，tree是存线段树的数组
void build(int node,int start,int end){   //建树函数，参数是根节点和左右区间 
	if(start==end){		//如果两边相等 
		tree[node]=arr[start]; //填的就是数组里的初始值 
		return;  //递归边界 
	}
	int leftnode=node*2;  //算出左右节点（完全二叉树的性质） 
	int rightnode=node*2+1;  
	int mid=(start+end)/2;    //把数组从中间劈成两半
	build(leftnode,start,mid);  //左边右边分开建树 
	build(rightnode,mid+1,end);
	tree[node]=tree[leftnode]+tree[rightnode]; //根节点的值=左根+右根 
} 
```
然后呢，进行单点修改和区间查询的操作，相信你对树的理解和经验，一定能看懂！

（剧透一下：这个题只需要把线段树建出来就行了，所以这俩函数并不是这个题的重点）

```cpp
void update(int node,int start,int end,int id,int val){      //修改操作，参数分别是建树函数的那三个和修改节点的编号和修改的值
	if(start==end){ //递归边界，如果是叶节点
		tree[node]+=val; //修改node节点的值
		return;
	}
	int leftnode=node*2;  //算出左右子树和中点
	int rightnode=node*2+1;  
	int mid=(start+end)/2;   
	if(id>=start&&id<=mid) //如果要改的地方在中点左边
	update(leftnode,start,mid,id,val);//那就递归修改左子树
	else update(rightnode,mid+1,end,id,val);//要么就递归修改右子树	
	tree[node]=tree[leftnode]+tree[rightnode]; //根节点更新 
} 
int query(int node,int start ,int end,int l,int r){ //查询函数，l和r是求和的左右区间
	if(l<=start&&r>=end)  //如果求和的区间已经当前的部分包含了
//（比如当前在[1,3]区间，让你求[1，5]，那你就要求[1,3]+[4,5]，直接把建树的时候算好的[1,3]的和加上去就行了）
	return tree[node]; //直接返回根节点
	int leftnode=node*2;  //又双叒叕是左右子树和中点
	int rightnode=node*2+1;  
	int mid=(start+end)/2;
	int sum=0; //就是要返回的和啊   
	if(l<=mid) //如果要求和的区间包含中点左边的部分
	sum+=query(leftnode,start,mid,l,r); //那就加上左边那块
	if(r>mid) //同理，如果右边还有那就加上右边那块
	sum+=query(rightnode,mid+1,end,l,r);
	return sum; //返回sum，不解释
}
```


------------
聊了那么久的线段树，接下来就说说这个题：这个题的思路大家都应该知道了吧，就是建立一棵线段树，**每一个节点是左右两个子节点里较大的那个**

由于最后肯定是**tree[2]和tree[3]争冠军（看前面图）**，而**题目让我们输出亚军**，所以亚军就是**tree[2]和tree[3]里能力值较小的那个**

还有，题目让我们输出亚军的**国家序号**，因此我们可以把线段树的节点弄成**包含能力值和序号的结构体**来处理

### AC code：

```
#include<iostream>
#include<cstring>
#include<algorithm> //比赛的时候闲的没事打了一堆头文件
#include<cmath>
#include<iomanip> 
using namespace std;
struct jiegouti{  //真·结构体
 	int power,id;  //power——能力值，id——国家序号
}; 
jiegouti maxt(jiegouti a,jiegouti b){  //返回两个结构体里能力值更大的那个
	return a.power>b.power?a:b;
}
jiegouti mint(jiegouti a,jiegouti b){ //返回两个结构体里能力值更大的那个
	return a.power<b.power?a:b;
}
jiegouti a[150],tree[600];  //a——数据，tree——线段树（一般为了防爆，线段树都是开数组的4倍空间）
void build(int node,int start,int end){ //建树函数
	if(start==end){  //叶节点，返回
		tree[node]=a[start];
		return;
	}
	int lnode=node*2;  //左右子树、中点
	int rnode=node*2+1;
	int mid=(start+end)/2;
	build(lnode,start,mid);  //两边递归建树
	build(rnode,mid+1,end);
	tree[node]=maxt(tree[lnode],tree[rnode])  //父节点是左右子节点里更大的;
}
int main(){
	int n;  //输入
	cin>>n;
	for(int i=1;i<=(1<<n);i++){  //1<<n就是2的n次方啦！（这样比pow函数更快哦！）
		cin>>a[i].power;  //输入，赋值，很简单
		a[i].id=i;	
	}
	build(1,1,(1<<n)); //建树（根节点是1，整棵树从1到2的n次方）
	cout<<mint(tree[2],tree[3]).id; //从tree[2],tree[3]里找个小的就是亚军，输出它的序号
	return 0;
}
```
~~(P.S:我真没有恶搞代码的意思，考试的时候画了个图就想到线段树了，正好刚学，就用这个题练练)~~

The End

---

## 作者：鸡你太美cxk (赞：232)

题目:[P4715](https://www.luogu.com.cn/problem/P4715)

这道题有很多人使用数组加一大堆繁琐的下标计算，但是我们完全可以用stl中的queue解决这道题

不说废话，上代码：
```cpp
#include<iostream>
#include<queue>
#include<map>
using namespace std;
int main(){
	int n;
	queue<pair<int,int> > q;	//pair是stl中的数据结构，这里用first表示国家号，second表示国家实力 
	cin>>n;
	n=1<<n;				//位运算，等价与n=pow(2,n)(位运算更快)
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		q.push(make_pair(i,x));	//make_pair(i,x)就是建立一个first为i，second为x的pair 
	}
	while(q.size()>2){		//循环将比赛进行至只剩前两名(q.size()为2是时要跳出循环单独判断亚军) 
		pair<int,int> x,y;
		x=q.front();
		q.pop();
		y=q.front();
		q.pop();
		if(x.second>y.second){	//从队头取出两个队，进行比较后将较强的队压入队尾 
			q.push(x);
		}else{
			q.push(y);
		}
	}
	pair<int,int> x,y;
	x=q.front();
	q.pop();
	y=q.front();
	q.pop();
	if(x.second>y.second){		//较弱的那队时亚军，将其国家号输出 
		cout<<y.first<<endl;
	}else{
		cout<<x.first<<endl;
	}
	return 0;
}
```


---

## 作者：Tengo (赞：185)

蒟蒻我又来写题解了。

看到[yangrunze](https://www.luogu.com.cn/user/239405)
大佬用线段树A的，只能%%%了

思路：
1. 一串2的n次方个的数字，相邻两个互相比较，那么这串数字中最大的那个，一定是冠军。
2. 但是，这道题让我们求亚军。首先要明白的一个地方是，第二大的数并不一定就是亚军，原因是它有可能与冠军比较，被刷下去了。
3. 我们可以转换一下思路：把这串数字从中间一分为二。根据1.，一定可以分别求出前面和后面数字中的最大值(设为x，y)，则冠军与亚军一定从x和y中取得(仔细想想，我就不解释了)；然后输出亚军的编号就行了。


话不多说，上代码。亲测AC。
## 不要直接复制粘贴代码,根据自己的思路打一遍！！
```cpp
#include<bits/stdc++.h>
using namespace std;
int tmp,n,tmp2,p,ans;
struct cou{
	int en;//每个国家的能量值
	int ta;//每个国家的编号
}a[200];

bool cmp(cou x,cou y)
{
	return x.en>y.en;//对结构体sort排序
}

int main()
{
	cin>>tmp;
	n=pow(2,tmp);
	for(int i=1;i<=n;i++){
		cin>>a[i].en;
		a[i].ta=i;
	}
	sort(a+1,a+n/2+1,cmp);//前一部分国家排序
	sort(a+n/2+1,a+n+1,cmp);//后一部分国家排序
	if(a[1].en>a[n/2+1].en){
		cout<<a[n/2+1].ta;//输出较小能量值的国家的编号
	}
	else{
		cout<<a[1].ta;
	}
	return 0;
} 
```
祝大家AC此题。

---

## 作者：锡印鱼 (赞：129)

[问题P4715](https://www.luogu.com.cn/problem/P4715)

题目只问了亚军是哪个国家，所以这题~~就很简单了~~(并不需要模拟出比赛的过程)。

我们把这2^n个国家分为左右两个部分，亚军一定是**左半边最强的国家**与**右半边最强的国家**之间较弱的那个。

附AC代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

//用结构体来存储国家信息
struct gj {
    int hm;//号码
    int nl=0;//能力值
};

int main() {
    int n;
    gj max_l, max_r;//左半边最强，右半边最强
    gj a;//读入时的临时变量a

    cin >> n;

    //找左半边最强
    for (int i = 0; i < 1<<(n-1); i++) {
        cin >> a.nl;
        if (a.nl > max_l.nl) {
            max_l.nl = a.nl;
            max_l.hm = i + 1;
        }
    }
    
    //找右半边最强
    for (int i = 1<<(n-1); i < 1<<n; i++) {
        cin >> a.nl;
        if (a.nl > max_r.nl) {
            max_r.nl = a.nl;
            max_r.hm = i + 1;
        }
    }

    //输出较弱的号码，即亚军。
    if (max_l.nl > max_r.nl)cout << max_r.hm;
    else cout << max_l.hm;
    
    return 0;
}


```


---

## 作者：沉冥Charming (赞：21)

- 这道题思路还是很好想的。可惜的是，我敲完代码的时候，比赛已经结束两分钟了。

- 我的思路：递归，每次二分取赢的一方，最外层取输的一方（亚军）。

- ~~可能算是类似于线段树的递归（？）~~

- 本蒟蒻自认为自己的代码很容易看懂，所以就直接附上代码吧。代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int a[(1<<7)+1];
int n;
int w(int l,int r)
{
    if (l==r)
        return l;
    int mid=(l+r)/2;
    int ll=w(l,mid),rr=w(mid+1,r);
    if (l!=1||r!=(1<<n))//如果不是最外层
    {
        if (a[ll]>a[rr])
            return ll;
        else
            return rr;
    }
    //如果是最外层，取输的一方
    if (a[ll]<a[rr])
        return ll;
    else
        return rr;
}
int main()
{
    cin>>n;
    for (int i=1;i<=(1<<n);i++)
        cin>>a[i];
    cout<<w(1,(1<<n));
    return 0;
}

```

- ~~当然，肯定有大佬做法更简单吊打本蒟蒻……~~


---

## 作者：小蒟蒻qwq (赞：20)

读完了题目，第一思路是进行模拟

先画一个示意图

![模拟示意图](https://cdn.luogu.com.cn/upload/image_hosting/mptbiohg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

观察图片，先列一个程序步骤

1.读入n，求出比赛队伍个数g；

2.将每个队伍的实力读入一维数组tree中；

3.进行第一轮模拟，邻近的2个取最大值，按序存入tree[g+1],tree[g+2]……中。

4.改变模拟范围的起始点以及终止点，继续模拟n-2次 。

5.在数组的已经记录数据的最后两个中挑选一个小的，输出它的编号。

但是有一个问题，一维数组这么模拟好像记录不了编号，所以就用结构体数组来存储，一个记录能力值，一个记录它的编号。

以下是代码



```cpp
#include <iostream>
using namespace std ;
struct node
{
	int num  , id ;
}tree[512] ; //结构体数组，num表示实力，id表示编号 
int main()
{
	int n ; 
	cin >> n ;
	int g = 1 ;
	for (int i = 1 ; i <= n ; i ++)
	{
		g *= 2 ; 
	} // 计算球队个数 
	for (int i = 1 ; i <= g ; i ++)
	{
		cin >> tree[i].num ;
		tree[i].id = i ;
	}//读入球队，初始化编号 
	int k = g + 1 ; //下标，记录获胜的球队 
	int tmp = g ; //记录当前最后一位，便于下一轮模拟时改变范围 
	int fi = 1 , en = g ; //每一轮模拟的范围 
	for (int i = 1 ; i <= n - 1  ; i ++) //少模拟一轮，相当于没有冠亚军决赛 
	{
		for (int j = fi ; j <= en ; j += 2)
		{
			if (tree[j].num > tree[j + 1].num) //如果j赢了 
			{
				tree[k].num = tree[j].num ;  //新节点k取与节点j相同的值 
				tree[k].id = tree[j].id ;
				k ++ ;
			}
			else
			    {
					tree[k].num = tree[j + 1].num ;
					tree[k].id = tree[j + 1].id ;
					k ++ ;
				}
		
		}
		fi = tmp + 1 ; // 改变范围 
		en = k - 1 ;
		tmp = en ;
	}
	
	//模拟结束 
	k -= 1 ;
	if (tree[k].num < tree[k - 1].num) //输出最后两个中较小的那个的编号 
	{
		cout << tree[k].id ;
	}
	else
	    {
	    	cout << tree[k - 1].id ;
		}
	return 0 ;
}
```

亲测ac

## 珍爱生命，远离抄袭

---

## 作者：SUNCHAOYI (赞：16)

#### Part 1 读懂题意
**2^n支队伍按顺序两两比较，然后能力较弱者淘汰，之后晋级再比较，直到只剩一支队伍（即冠军），现在要求问你 _亚军_ （第二名）是谁。**
#### Part 2 思路设计
**~每次都会淘汰一半的队伍，直到剩下一支队伍，所以是2 _^n支_ 队伍。所以先要进行输入数据处理：**
```
cin>>n;
for(int i = 1;i <= n;i++) s *= 2;//共有z^n支队伍
                        
```
**输入每支队伍的能力值，由于涉及到输出编号，所以设置一个结构体来记录：**
```
struct node
{
	int x,s;//编号，能力值
} a[130];//最多为2^7，即128，故设数组130
```

**然后，根据每次减少一半的规律，比较选出能力值大的队伍，放入a的前端：**
```
if(a[i].s > a[i + 1].s) a[++q] = a[i]; //q为计数用
else a[++q] = a[i + 1];
```
**由于每次都减少一半，所以比较只要循环到上一次的一半，故如下设计：**
```
for(int i = 1;i <= s;i += 2)
{
	……
}
s /= 2;//每次减少一半，a数组的前一半便是晋级的队伍
```
**最后要输出亚军队伍编号，所以s=2时跳出比较的大循环：**
```
while(s > 2)
{
	……
}
```
**冠亚军比较，然后输出亚军的编号（能力值较小的）**
```
if(a[1].s > a[2].s) cout<<a[2].x<<endl;
	else cout<<a[1].x<<endl;
```
#### Part 3 代码实现
```
#include <iostream>
using namespace std;
struct node
{
	int x,s;//编号，能力值
} a[130];//最多为2^7，即128，故设数组130
int main()
{
	int n,s = 1;
	cin>>n;
	for(int i = 1;i <= n;i++) s *= 2;//共有z^n支队伍
	for(int i = 1;i <= s;i++)
	{
		a[i].x = i;//记录编号 
		cin>>a[i].s;
	}
	while(s > 2)//循环条件 
	{
		int q = 0;//初始化 
		for(int i = 1;i <= s;i += 2)//每次+2，两两比较的缘故 
		{
			if(a[i].s > a[i + 1].s) a[++q] = a[i]; //q为计数用
			else a[++q] = a[i + 1];
		} 
		s /= 2;//每次减少一半，a数组的前一半便是晋级的队伍
	}
	//最后只剩下两支队伍，比较后输出亚军的编号，即能力值较小的队伍 
	if(a[1].s > a[2].s) cout<<a[2].x<<endl;
	else cout<<a[1].x<<endl;
	return 0; 
} 
```


---

## 作者：Ryo_Yamada (赞：8)

看到这题的数据范围我就知道暴力能过了，$2^n≤128$，数据很小。

我的思路：读入后循环每次消除一半的国家，在只有2个国家时记录亚军的能力值，再循环一遍找到它的编号。

`Code`:

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
int power[129], a[129], len, len2, cnt, ans;//a保存power的副本，len2保存len的副本，后面要用
int main() {
    int n;
    cin >> n;
    len = pow(2, n);
    len2 = len;
    for(int i=0; i<len; i++) {
        cin >> power[i];
        a[i] = power[i];//记录
    }
    while(len != 1) {
        for(int i=0; i<len; i += 2) {
            if(len == 2)ans = power[i] < power[i + 1] ? power[i] : power[i + 1];//如果只有2个国，记录能力值较低的国
            power[cnt++] = power[i] > power[i + 1] ? power[i] : power[i + 1];//用到了一个小技巧，消除一半的国
        }
        cnt = 0;
        len /= 2;//变成了一半，所以len要÷2
    }
    for(int i=0; i<len2; i++) {
        if(ans == a[i]) {//搜索一遍，匹配则输出，注意是输出i + 1
            cout << i + 1;
            return 0;//完美结束
        }
    }
    return 0;
}
```


---

## 作者：InversionShadow (赞：5)

## P4715 【深基16.例1】淘汰赛 题解

STL 大法好！！！

### 思路：

考虑用 `vector` 和 `pair`，`pair` 记录每个国家的实力与输入顺序，`vector` 则是方便删除元素。然后我们可以暴力枚举，如果 $a_j$ 的实力值大于 $a_{j-1}$ 的实力值时，我们就可以把 $a_{j-1}$ 踢出争夺冠亚军的队伍 ，否则把 $a_j$ 踢出争夺冠亚军的队伍。**注意一下，题目要求我们判断的是冠军和亚军，所以我们只要进行 $n-1$ 场比赛，就可以知道争夺冠亚军的队伍了。** 

### Code：

自认为比较简单易懂。

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<pair<int, int> >a;

int n, x, y;

int main() {
  cin >> n;
  for (int i = 0; i < pow(2, n); i++) {
    cin >> x;
    a.push_back(make_pair(x, i + 1));
  }
  for (int i = 1; i < n; i++) {
    for (int j = 1; j < a.size(); j++) {
      if (a[j].first > a[j - 1].first) {
        a.erase(a.begin() + j - 1);
      } else {
        a.erase(a.begin() + j);
      }
    }
  }
  if (a[0].first > a[1].first) {
    cout << a[1].second;
  } else {
    cout << a[0].second;
  }
  return 0;
}
```


---


# 【深基16.例3】二叉树深度

## 题目描述

有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 `0 0`。

建好这棵二叉树之后，请求出它的深度。二叉树的**深度**是指从根节点到叶子结点时，最多经过了几层。


## 样例 #1

### 输入

```
7
2 7
3 6
4 5
0 0
0 0
0 0
0 0```

### 输出

```
4```

# 题解

## 作者：zhangyuhan (赞：180)

这是一道关于二叉树的入门题。

这题主要考察二叉树的存储以及二叉树的遍历。

那么我就来分这两部分来讲。

## $Part$ $1$ 存储

考虑一个二叉树的每个节点都有两个子节点，所以我们可以考虑用一个结构体来存储：

```cpp
struct node {
    int left, right;
};
node tree[MAXN];
```

其中，`left`和`right`分别代表节点的左节点编号和右节点编号。

当读入时，就非常方便了，直接读入即可：

```cpp
_for (i, 1, n) cin >> tree[i].left >> tree[i].right;
```

## $Part$ $2$ 遍历

这道题要我们求二叉树的深度，就一定要遍历这棵树。

首先明确一点题目中未提到的，编号为$1$的节点是二叉树的根节点。

于是我们可以从根节点出发，先递归遍历该节点的左节点，再递归遍历该节点的右节点。

其中还要记录该节点的深度，出发时深度为$1$

```cpp
dfs(tree[id].left, deep+1);
dfs(tree[id].right, deep+1);
```

每到一个节点时更新一下深度：

```cpp
ans = max(ans, deep);
```

到达叶子节点时，就`return`

```cpp
if (id == 0) return ;
```

总体上就这么多吧。

因为每个节点遍历一次，所以总时间复杂度为$O(n)$

$AC$ $Code$

```cpp
#include <iostream>
#define _for(i, a, b) for (int i=(a); i<=(b); i++)
using namespace std;

const int MAXN = 1e6 + 10;

struct node {
    int left, right;
};
node tree[MAXN];//存储结构定义

int n, ans;

void dfs(int id, int deep) {
    if (id == 0) return ;//到达叶子节点时返回
    ans = max(ans, deep);//更新答案
    dfs(tree[id].left, deep+1);//向左遍历
    dfs(tree[id].right, deep+1);//向右遍历
}

int main() {
    cin >> n;
    _for (i, 1, n) cin >> tree[i].left >> tree[i].right;//读入+建树
    dfs(1, 1);//从1号节点出发，当前深度为1
    cout << ans << endl;//输出答案
    return 0;//完结撒花！
}

```

---

## 作者：HsKr (赞：61)

深度优先搜索即可

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
struct node{
	int l,r;
}a[1001000];//记录每个节点的左右节点
int Max=-1,n;
void dfs(int root,int step){
	if(root==0) return;//如果该节点为0（即上它的爸爸没有这个儿子），返回
	Max=max(Max,step);//记录最大值
	dfs(a[root].l,step+1);//搜索它的左儿子
	dfs(a[root].r,step+1);//搜索它的右儿子
}
int main(){
	cin>>n;//输入n
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r;//输入该节点的左节点和右节点
	}
	dfs(1,1);//从1号节点，深度为1开始搜索 
	cout<<Max;//输出最大值
	return 0;
}
```

---

## 作者：Lylighte (赞：30)

### _2020/02/08_  
[传送门](https://www.luogu.com.cn/problem/P4913)  
对于一个连树都没**系统**学过的蒟蒻（普及-的水平），先考虑下怎么存这棵树。  
#### 父亲表示法
对于每个非根节点，只有一个前驱节点。用 `father[i]` 表示节点 $i$ 的前驱节点。  
因为是按照节点顺序读入，所以子节点的父亲就是当前循环变量。  
（似乎不用关心根节点是哪个）  
然后求深度。  
#### 递归
对于节点 $i$，如果没有前驱节点，它的深度为 $1$，否则深度为它前驱节点的深度加 $1$。  
再加一个记忆化，`depth[i]` 存节点 $i$ 的深度。
#### 贴代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, maxd=1;		//maxd 存最大深度，初始化为 1 
int fa[100010];		//存前驱节点
int depth[100010];	//记忆化

int work(int x){	//递归函数，求节点 x 的深度
	if(depth[x]!=0)	//如果已经求出，就直接返回该深度
		return depth[x] ;
	if(fa[x]==0)
		return depth[x] = 1;
        			//根节点直接返回 1
	else
		return depth[x] = 1 + work(fa[x]);
        			//非根节点返回它的前驱节点的深度加 1
}

int main(){
	cin >> n ;
	for(int i=1; i<=n; i++){
		int t1, t2;
		cin >> t1 >> t2 ;
		fa[t1] = i ;
		fa[t2] = i ;
        			//父亲表示法存树
	}
	fa[0] = 0;		//似乎没用
	for(int i=1; i<=n; i++)
		maxd = max(maxd,work(i));
        			//寻找最大深度
	cout << maxd << endl;
	return 0;
}
```
### _2020/02/12_  
儿子表示法同理，就是变成从根节点找到叶节点。  
因为某个帖子，我又想到了这个方法。  
#### BFS
遍历一棵树。把根节点（题目没说清，应该是 $1$ 号节点）加进队列，逐步扩展新节点，同时记录深度（新节点深度是父亲节点深度加一）。遍历结束的同时，就能得到最大深度。
#### 贴代码
```cpp
#include <bits/stdc++.h>
using namespace std;

struct nod{			//儿子表示法存树
	int id, lc, rc, deep;
}tree[100010]; 
nod que[100010];	//BFS 用到的队列
int head, tail;
int n, depth;

void bfs(){
	head=1, tail=2;
	que[head] = tree[1];
	que[head].id = 1;
	que[head].deep = 1;
	depth = 1;
	while(head<tail){
		nod nownod = que[head];
		head++;
		depth = max(depth, nownod.deep);
		if(nownod.lc != 0){
			nod newnod = tree[nownod.lc] ;
			newnod.id = nownod.lc ;
			newnod.deep = nownod.deep + 1; 
			que[tail++] = newnod;
		}
		if(nownod.rc != 0){
			nod newnod = tree[nownod.rc] ;
			newnod.id = nownod.rc ;
			newnod.deep = nownod.deep + 1;
			que[tail++] = newnod;
		}
	}
}

int main(){
	cin >> n ;
	for(int i=1; i<=n; i++)
		cin >> tree[i].lc >> tree[i].rc ;
	bfs();
	cout << depth << endl;
	return 0;
}
```

#### 后记
_2020/02/08_	写完。也许不是真正的树，~~但它是真正的 AC~~。  
_2020/02/12_	补充一下 BFS。

---

## 作者：封禁用户 (赞：19)

这题正解是长链剖分...不好意思走错片场了


这题我写的是一个奇怪的树形dp，设dp[x]为x和x子树的最大深度

那么显然$dp[x]=max\{dp[y]\} ,y \in son[x]$

初值：$dp[x]=dep[x]$

然后就愉快地以O(n)阿掉了此题

以下是代码


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> e[100005];
int dep[100005],f[100005];
void dfs(int x){
	int len=e[x].size();
	f[x]=dep[x];
	for(int i=0;i<len;++i){
		dep[e[x][i]]=dep[x]+1;
		dfs(e[x][i]);
		f[x]=max(f[x],f[e[x][i]]);
	}
}
int main(){
	int n,x,y;
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>x>>y;
		if(x!=0) e[i].push_back(x);
		if(y!=0) e[i].push_back(y);
	}
	dfs(1);
	cout<<f[1]+1;
	return 0;
}
```


---

## 作者：Skies (赞：18)

确定思路：记忆化搜索

直接上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int son[10000010][3];//son[i][1]表示i的左节点,son[i][2]表示i的右节点
int f[10000010];
int ans=1;
int dfs(int dep,int now)//dep表示现在搜了多少层，now表示现在在几号节点
{
	if(f[now]!=0)return f[now];//如果搜过了就直接return
	if(now==0)return 0;//没有0号节点
	if(son[now][1]!=0||son[now][2]!=0)//如果有孩子
	{
		f[now]=max(dfs(dep+1,son[now][1]),dfs(dep+1,son[now][2]));
      //现在深度=max(左孩子深度，右孩子深度）
	}else{//没孩子
		ans=max(ans,dep);//记录最深层数
		return dep;
	}
}
int main()
{
	//freopen("未命名1.in","r",stdin);
	//freopen("未命名1.out","w",stdout);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
			son[i][1]=a;
			son[i][2]=b;
	
	}
	for(int i=1;i<=n;i++)dfs(1,i);
	cout<<ans;
	return 0;//考场勿忘
}
```

---


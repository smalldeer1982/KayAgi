# [COCI 2017/2018 #7] Timovi

## 题目描述

把$m$个人放在$n$个队伍里。
规则：
- 每次放$k$个人
- 顺序为$1^{th}$->$2^{th}$->$3^{th}$->……->$(n-1)^{th}$->$n^{th}$->$(n-1)^{th}$->$(n-2)^{th}$->……->$2^{th}$->$1^{th}$->$2^{th}$->……
- 一直重复到$\text{当前剩余人数}<k$为止。此时剩下的人全部放在当前队里

## 样例 #1

### 输入

```
2 1 3```

### 输出

```
2 1```

## 样例 #2

### 输入

```
3 2 7```

### 输出

```
2 3 2```

## 样例 #3

### 输入

```
4 5 6```

### 输出

```
5 1 0 0```

# 题解

## 作者：Alex_Wei (赞：13)

#### 思路：把来回一趟看做一个整体

即 $1,2,3……n,n-1……4,3,2$（注意这里是 $2$）

共放了 $2*(n-1)$ 次，共 $2*(n-1)*k$ 人

计算出趟数 $t$，再模拟剩下来的人数

趟数=总人数/来回一趟的人数，即

$$t=m/(2*(n-1)*k)$$

剩余人数=总人数%来回一趟的人数，再模拟下去即可

时间复杂度：$O(n)$

#### 具体思路见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long i[200020],n,m,k,t,no=1,pd=1;
int main()
{
	cin>>n>>k>>m; 
	t=m/(k*(n-1)*2);//趟数=总人数/来回一趟的人数
	for(int x=1;x<=n;x++)
		x==1||x==n?i[x]=t*k:i[x]=t*k*2;//每个队伍的人数=趟数（t）*每趟的人数（k*2），注意这里的1和n要特判一下
	m%=(k*(n-1)*2);//剩余的人数
	for(int x=1;m;x++){//还有人没有被分配在队伍里
		int p=n-abs(n-x),pe=min(m,k);//p:即将把人分配到第p个队伍里（这个计算公式可以手推），pe:可以分配的人数 
		i[p]+=pe,m-=pe;
	}
	for(int x=1;x<=n;x++)
		cout<<i[x]<<" ";
	return 0;
}
```

如果有错误请私信我，我会及时改正！

$\small{\text{UPD 2019.8.17 : 修改部分文字，添加Latex}}$

---

## 作者：L_zaa_L (赞：5)

今天考试时考到了这道题，当时也做对了，看到这道题可以写题解，就交了。
## 分析
最先想到的思路就是暴力，就是把每一次都一个一个模拟一遍，直到没有了，虽然思路很简单，但其时间复杂度就是 $\frac{m}{k}$，肯定会超时，考试有时想不到算数方法，也可以试试这种方法骗点分。

这是代码：
```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+1;
long long n,m,k,a[MAXN<<1],s=1,fx=1;//s代表到了第s个序列，fx就是方向
int main(){
//	freopen("children.in","r",stdin);
//	freopen("children.out","w",stdout);
	cin>>n>>k>>m;
	while(m){
		if(s==n) fx=-1;//如果到了n或1，就改变方向
		if(s==1) fx=1;
		if(m<k){
			a[s]+=m;
			m=0;
		}//当剩余的人不够时，就让剩下的人去那个队列
		else{
			a[s]+=k;
			m-=k;
		}
		s+=fx;//继续枚举
	}
	for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";
	return 0;
}
```

第二种就是算出来，这种应该也蛮简单的，除了第一次，其他的都可以看成从 $n-1$ 到 $1$，再从 $2$ 到 $n$，以此类推。

所以我们可以把从第二轮开始，每次看成一个 $n-1$ 的顺序，就是说这样子一轮可以有 $\frac{m}{(n-1)\times k}$ 轮，从 $n-1$ 到 $1$ 有 $s-\frac{s}{2}$，从 $2$ 到 $n$ 有 $\frac{s}{2}$。于是可以将从 $n-1$ 到 $1$ 的所有序列加上 $(s-\frac{s}{2}) \times k$,从 $2$ 到 $n$ 的所有序列加上 $\frac{s}{2}\times k$,枚举每次也只用 $O(n)$，虽然也可以 $O(1)$，但是毕竟输出也要 $O(n)$，为了思路更简单，还是 $O(n)$ 枚举吧。

花十分钟码的代码，看看吧：

```
#include<bits/stdc++.h>
using namespace std;
long long n,k,m;
long long a[2000005];
int main(){
	//freopen("children.in","r",stdin);
	//freopen("children.out","w",stdout);
	cin>>n>>k>>m;
	for(int i=1;i<=n;i++){
		if(m>=k) a[i]+=k,m-=k;
		else{
			a[i]+=m;
			for(int i=1;i<=n;i++){
				cout<<a[i]<<" ";
			}
			return 0;
		}
	}//第一轮直接算好
	long long s=m/(n-1)/k;//计算出有多少轮
	long long kkk=s/2,cz=s-s/2;//kkk代表第二种情况也就是从2到n，cz代表就是第一种情况也就是从n-1到1（变量名没关系吧）
	for(int i=1;i<n;i++){
		a[i]+=cz*k;
		m-=cz*k;
	}//得出每个位置上的位置（不算剩下的）
	for(int i=2;i<=n;i++){
		a[i]+=kkk*k;
		m-=kkk*k;
	}
	if(s%2==1){//枚举剩下的，看是第一种情况还是第二种情况
		for(int i=2;i<=n;i++){//第二种
			if(m>=k) a[i]+=k,m-=k;
			else{
				a[i]+=m;
				break;
			}
		}
	}
	else{//第一种
		for(int i=n-1;i>=1;i--){//再枚举一遍
			if(m>=k) a[i]+=k,m-=k;
			else{
				a[i]+=m;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";
	}
	return 0;
}
```
大概就是这样，暴力开氧气应该也可以过。

---

## 作者：yuzhechuan (赞：3)


楼下的暴力吸氧吓住了我
~~（这也算题解）~~

然而我的这个东东貌似是`88ms`，而吸氧的是`2k ms`。。。



------------

言归正题

朴素的O(m)算法TLE是必然的
(毕竟m最大有2e9)

这时可以借鉴一下
[P1724 东风谷早苗](https://www.luogu.org/problemnew/show/P1724)

然后突然发现很多趟1~n-1,n~2是
## 重复的！！！

因此我们可用 
**一次循环+乘法 **
替代 
**多次循环**

接下来相信对于各位神犇来说就是小菜一碟啦。。。
(当然还别忘了long long)

---

```
#include <bits/stdc++.h>
#define rint register int //寄存器加速
using namespace std;
long long m,k,rd; //经过一番分析后发现只有以上三个变量会超出1e9
int a[200050],pt,d=1,n;
int main()
{
    scanf("%d%lld%lld",&n,&k,&m);
    rd=m/((n-1)*k);//记录趟数
    /*注：这里的趟数指的是1~n-1或n~2为一趟*/
    m-=rd*(n-1)*k;//减去多余的人数
    if(rd%2)//分类讨论：奇数趟
    {
    	for(rint i=1;i<=n;i++)
    		if(i==1) a[i]=(rd/2+1)*k;
    		else if(i==n) a[i]=(rd/2)*k; //特殊判断首和尾
            else a[i]=rd*k;//本题优化之所在
        for(rint i=n;i>=1;i--)//处理剩余的那部分人，模拟即可
        {
            a[i]+=min(m,k);
            m-=min(m,k);
            if(m==0) break;
        }
    }
    else//偶数趟(做法同上)
    {
        for(rint i=1;i<=n;i++)
            if(i==1||i==n) a[i]=rd/2*k;
            else a[i]=rd*k;
        for(rint i=1;i<=n;i++)
        {
            a[i]+=min(m,k);
            m-=min(m,k);
            if(m==0) break;
        }
    }
    for(rint i=1;i<=n;i++)//平易近人的输出。。。
        printf("%d ",a[i]);
	retuen yuzhechuan;
}
```


------------

(～￣▽￣)～ 

---

## 作者：Sirkey (赞：1)

考试考到了！来交题解。

我们首先这个题明确可以分组。

我们可以将第一个到第 $n$ 个，再从第 $n$ $-$ $1$ 分到第二个。

很明显，对于每一组可以看为第一个和第二个一组增加一个 $k$,其他的则是两倍。

那我们要计算一下组数：$\dfrac{m}{(2n-2)k}$。

那么题目就简化成找循环节了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MX=1e6+10;
int n,m,k,a[MX];
signed main() {
	cin>>n>>k>>m;
	int l=(m/((n*2-2)*k));
	for(int i=1; i<=n; i++) a[i]+=l*k*min((long long)2,min(i,n-i+1));
	//处理循环节部分，除了收尾都要计算两次 
	m-=k*(n*2-2)*l;//还要计算几次 
	int flag=0,i=1;
	for(; 0<=m;) {
		if(m>=k) a[i]+=k;
		else {
			a[i]+=m;
			break;
		}
		m-=k;
		if(flag) i--;
		else i++;
		if(i==n) flag=1;
	}
	//暴力模拟剩下的部分，时间复杂度最多 2N  
	for(int i=1; i<=n; i++)  cout<<a[i]<<" ";
	return 0;
}
```
温馨提示：开 `long long `。

——end——

---

## 作者：No_Rest (赞：1)

## 题目分析

题目说，放人的顺序为 $1^{th}\to 2^{th}\to 3^{th}\to……\to(n-1)^{th}\to n^{th}\to(n-1)^{th}\to(n-2)^{th}\to……\to2^{th}\to 1^{th}\to2^{th}\to……$ 可以发现，他们是以 $1^{th}\to 2^{th}\to 3^{th}\to……\to(n-1)^{th}\to n^{th}\to(n-1)^{th}\to(n-2)^{th}\to……\to2^{th}$ 循环的。

那么我们就可以把放人分成两部分：循环和非循环。我们可以分开处理。

1. 循环部分：因为一个循环放 $2n-2$ 次人，而每次放 $k$ 个人，所以一次循环共放 $k\times(2n-2)$ 个人。而又因为一共 $m$ 个人，所以循环次数是 $m/[k\times(2n-2)]$。除了 $1$ 和 $n$ 队以外，其他队伍都被遍历了两边，每次放 $k$ 个人，所以人数为 $2\times m/[k^2\times(2n-2)]$，而 $1$ 和 $n$ 队则只有 $m/[k^2\times(2n-2)]$。

2.非循环部分：模拟，见代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, m, k, t, a[200005];
int main(){
	scanf("%d%d%d", &n, &k, &m);
	t = m / (k * (n - 1) * 2);//循环次数
	for(int i = 1; i <= n; i++){
		if(i == 1 || i == n){//是1或n队
			a[i] = t * k;//只被遍历一次
		} else {
			a[i] = t * k * 2;//被遍历两次
		}
	}
	m %= k * (n - 1) * 2;//剩余人数
	for(int i = 1; i <= n; i++){//模拟，先从1到n
		if(m < k){//如果剩余人数没有k多
			a[i] += m;//直接把剩余人数都放在这里
			for(int j = 1; j <= n; j++){//输出
				printf("%d ", a[j]);
			}
			return 0;//结束程序
		}
		a[i] += k;//放人
		m -= k;//剩余人数-k
	}
	for(int i = n - 1; i >= 2; i--){//注意，是从n-1到2
		if(m < k){//同上
			a[i] += m;
				for(int j = 1; j <= n; j++){
					printf("%d ", a[j]);
				}
				return 0;
		}
		a[i] += k;
		m -= k;
	}
}//末尾其实不用return 0了，因为之前一定会return 0的
```

---

## 作者：SingularPoint (赞：1)

看到楼上大佬们一堆优化证明......蒟蒻的我表示只会**模拟**而已啊QAQ

题目描述很简洁，就是~~迂回塞人~~给出n个小组，从头到尾向小组里放人，每次放k个人，如果放到队尾还有人没放完就从后向前再来一遍，以此类推。

这里就可以很简单的想到把两个方向分成两部分完成，正方向跑一遍，没跑完就反过来跑（废话）

但是毕竟是单纯的模拟，没有优化，所以 **本题解需要开O2**

分析结束，那么
### 开始我们的模拟罢
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int l[200010];//小组 
void go_back(int);//提前声明反方向操作 
void go_on(int tot)//正方向跑 
{
	for(int i=1;i<=n;i++){
		if(tot-k<=0){
			l[i]+=tot;
			return;
		}
		tot-=k;
		l[i]+=k;
	}
	if(tot) go_back(tot);//如果人没放完就反方向跑 
	return;
}
void go_back(int tot)//反方向 
{
	for(int i=n-1;i>1;i--){//【注意】这里是从n-1到2，n和1在正方向中放过了，不能重复 
		if(tot-k<=0){
			l[i]+=tot;
			return;
		}
		tot-=k;
		l[i]+=k;
	}
	if(tot) go_on(tot);//如果人没放完就正方向跑，如此达到迂回的效果 
	return;
}
int main()
{
	scanf("%d%d%d",&n,&k,&m);
	go_on(m);
	for(int i=1;i<=n;i++)
		printf("%d ",l[i]);
    return 0;
}
```
**完结撒fa~**

（小声：蒟蒻第一次写题解求过！）

---

## 作者：_•́へ•́╬_ (赞：1)

```
// luogu-judger-enable-o2
//太暴力辣！吸氧好！
#include<stdio.h>
#define min(x,y) (x<y?x:y)
inline int read()//快读
{
    register int x=0,t=0;register char c=getchar();
    for(;c<'0'||c>'9';t|=c=='-',c=getchar());
    for(;c>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=getchar());
    return t?-x:x;
}
int n,k,m,a[200000];
main()
{
    n=read();k=read();m=read();//输入
    for(;m>0;)//一直分配
    {
        for(register int i=0;i<n&&m>0;++i,m-=k)a[i]+=min(k,m);//从1到n
        for(register int i=n-2;i>0&&m>0;--i,m-=k)a[i]+=min(k,m);//从n-1返回到2
    }
    for(register int i=0;i<n;++i)printf("%d ",a[i]);//输出
}/**/
```

---

## 作者：B天选之子B (赞：1)

## 题目描述如下

- 告诉总共的糖数，要分得糖的人数和每次分得的糖数。

- 分法除了第一轮，其他时候都按循环节走。

## 解题思路

**因为数字比较小，可以考虑最简单的模拟。**

- 模拟一整轮。

- 找循环节，然后将剩余的值在接着模拟。

**最后解题方法就是模拟一轮，然后找循环节并算出答案。**

## 注意事项

-  找完循环节后还要把剩下的在来一轮。

-  一定要注意糖果的数量，保证还有糖果。

- 这道题的样例有点水，要自己造一些数据。

- 第一轮开始就算，可以找到循环节后在算。

**总的来说不是很难，但是要注意小细节。**

## 奉上代码
```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,m,k,j,ans[2000010],q,o,p,f;
int main() {
	scanf("%lld%lld%lld",&n,&k,&m);
	q=m;	//以防糖果的数量发生改变
	if(n*k>=m) {
		for(int i=1; i<=n; i++) {
			ans[i]+=min(k,m);
			m-=min(k,m);
		}
		for(int i=1; i<=n; i++)
			printf("%lld ",ans[i]);
		return 0;
      //以上是只需要第一轮的情况，实际上可以和下面合并
	} else {
     
		for(int i=n-1; i>=1; i--) {
			ans[i]+=min(k,m);
			m-=min(k,m);
		}
		for(int i=2; i<=n; i++) {
			ans[i]+=min(k,m);
			m-=min(k,m);
		}
      //以上均为循环节
		o=(q-n)/(q-m);
		for(int i=1; i<=n; i++) ans[i]*=o;
		m=q-(q-m)*o;
		for(int i=1; i<=n; i++)
		{
			ans[i]+=min(k,m);
			m-=min(k,m);
		}
       //第一轮循环放到后面，以防循环节出错
		for(int i=n-1; i>=1; i--) {
			ans[i]+=min(k,m);
			m-=min(k,m);
		}
		for(int i=2; i<=n; i++) {
			ans[i]+=min(k,m);
			m-=min(k,m);
		}
        //第二轮以防循环节有剩余
		for(int i=1; i<=n; i++)
			printf("%lld ",ans[i]);
        //最后直接输出答案
		return 0;
	}
	return 0;
}
```
**纯模拟可以，但最好还是找规律。**

---

## 作者：Mx_sky (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/P5051)

这道题第一反应是 $O(m/k)$ 枚举，用一个变量 $pd$ 来判断下标是要加还是要减，然后用数组记录答案即可。有个坑点就是下标可能会 $>n$ 和 $<1$，这时候就需要将下标重新变为 $n-1$ 或 $2$ 了（注意开O2，不然过不了。）

### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,a[200003],d=1,pd=0;
int main()
{
    std::ios::sync_with_stdio(0);    //优化
    cin>>n>>k>>m;      //可以改为scanf
    for(int i=1;i<=m/k;i++){
    	a[d]+=k;       //这一组加k人
      //判断是要加还是要减
    	if(pd==0) d++;  
    	else d--;
      //注意下标越过n和1的界限
    	if(d>n) d=n-1,pd=1;  
    	if(d<1) pd=0,d=2;
	}
    //最后还要加上m%k
    a[d]+=(m%k);
    for(int i=1;i<=n;i++) cout<<a[i]<<" ";
    return 0;
}
```


---

## 作者：kkxacj (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5051)

#### 引言：

这个蒟蒻在写这道题时忘记了第一个点和最后一个点单独输出，只有 $45$（悲）。


#### 思路

很明显，暴力肯定是过不了这道题的，所以我们需要找循环节，循环节为 $1$ 到 $n$ 再到 $2$，总个数为 $2 \times n - 2$，求完之后，可能还有剩余，所以到最后再来一遍。

#### 注意：第 $1$ 个数和第 $n$ 个数在循环中只算了一遍，其他都算了两遍，所以第 $1$ 个数和第 $n$ 个数要单独算。

code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,ans,a[2000010],sum;
int main()
{
	scanf("%lld%lld%lld",&n,&k,&m);
	if(n == 1)//n为1特判，避免后面输出两个
	{
		printf("%lld",m);
		return 0;
	} 
	sum = (m / ((n * 2 - 2) * k));
	m = m % ((n * 2 - 2) * k);
	for(int i = 1;i <= n;i++)
	{
		if(m >= k)
		{
			a[i] += k;
			m -= k;
		}
		else
		{
			a[i] += m;
			m = 0;
			break;
		}
	}
	for(int i = n - 1;i >= 1;i--)
	{
		if(m >= k)
		{
			a[i] += k;
			m -= k;
		}
		else
		{
			a[i] += m;
			break;
		}
	}
	cout << a[1] + sum * k << " ";
	for(int i = 2;i < n;i++) printf("%lld ",a[i] + sum * k * 2);
	cout << a[n] + sum * k;
	return 0;
}

```


---

## 作者：_zexal_ (赞：0)

## 思路
先读题目，我们首先想到暴力，但注意到数据范围 $n\leq 10^6$ ，我们需要优化。注意到给的顺序是固定的，所以我们可以按周期来计算。我们把 $1$ 到 $n$ 再到 $1$ 看成一个周期，这样，我们只用要计算他有多少个周期就可以了，每一个周期的小朋友也很好计算，即 $2 \times (n-1) \times k$ 人，如果还有剩下的小朋友，我们再模拟即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,answer[200005];
int main() {
	cin>>n>>k>>m;
	long long num=k*n*2-k*2;
	if(num>=m) {
		for(int i=1; i<=n; i++) {
			if(m-k>=0) answer[i]+=k;
			else answer[i]+=m;
			m-=k;
			if(m<=0) m=0;
		}
		for(int i=n-1; i>=1; i--) {
			if(m-k>=0) answer[i]+=k;
			else answer[i]+=m;
			m-=k;
			if(m<=0) m=0;
		}
		for(int i=1; i<=n; i++) {
			cout<<answer[i]<<" ";
		}
		return 0;
	}
	long long len=(m-m%num)/num;

	for(int i=1; i<=n; i++) {
		if(i==n||i==1) answer[i]+=k*len;
		else answer[i]+=k*2*len;
	}
	m-=len*num;
	for(int i=1; i<=n; i++) {
		if(m-k>=0) answer[i]+=k;
		else answer[i]+=m;
		m-=k;
		if(m<=0) m=0;
	}
	for(int i=n-1; i>=1; i--) {
		if(m-k>=0) answer[i]+=k;
		else answer[i]+=m;
		m-=k;
		if(m<=0) m=0;
	}
	for(int i=1; i<=n; i++) {
		cout<<answer[i]<<" ";
	}
	return 0;
}
```


---

## 作者：A_Plus_Gu (赞：0)

## 考察内容： 模拟

## 思路： 

![](https://cdn.luogu.com.cn/upload/pic/60747.png)

我们可以把它拆为：

![](https://cdn.luogu.com.cn/upload/image_hosting/muil7stp.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/ptbrpbyo.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/muil7stp.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/ptbrpbyo.png)

.......

所以我们很容易看到一个规律：每次第一个队伍和第n个队伍都只加了一遍。

发现这个坑之后就很简单啦，只要模拟一下把人分到队伍里的过程就可以了。

下面是我的代码（要开氧才能AC，不然会TLE）：

```
#include<cstdio>
#include<iostream>
#include<string>
#include<algorithm>
#define ll long long
using namespace std;
ll n,k,m,a[1000001],t;
int main(){
	cin>>n;
	cin>>k;
	cin>>m;
	while(m>0){
		for(int i=1;i<=n;i++){
			if(m<=0)break;
			a[i]+=min(m,k);
			m-=k;
		}
		for(int i=n-1;i>=2;i--){
			if(m<=0) break;
			a[i]+=min(m,k);
			m-=k;
		}
	}
	for(int i=1;i<=n;i++){
		cout<<a[i];
		cout<<" ";
	}
	return 0;
}
```


---

## 作者：a_l_g_d (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5051)

[食用更香](https://blog.csdn.net/fzy_Raymond/article/details/120123142?spm=1001.2014.3001.5501)

### Description

把 m 个人放在 n 个队伍里，规则如下：

- 每次往一个队伍中放入 k 个人。

- 顺序为： 从小到大，再从大到小，并以此类推，直到剩下的人数小于 k。

- 当剩下的人数小于 k 时，将此时剩下的所有人放入当前队伍中。

输入一行三个数，分别是队伍数 n，放入人数 k，总人数 m。

输出一行 n 个数，分别是这 1 到 n 个队伍中的人数。

### 思路

**纯模拟！**

1. 当 $m>=k$ 时，开始或继续模拟。

1. 正方向：填充并更新 m。

1. 反方向（从 $n-1$ ~ 2 ）：填充并更新 m。

1. 回到第一步

### Answer：

[AC Record](https://www.luogu.com.cn/record/57566959)

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn=2e5+10; //数据范围200,000 
const int inf=1e9+7;
int n,m,k;
int cow[maxn];

//---------------------------快读 

inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}

//---------------------------- 

inline void go() { //正方向入队伍 
	if(m==0) return;
	for(int i=1; i<=n; ++i) {
		if(m<k) { //人不够，剩下的全放 
			cow[i]+=m;
			m=0;
		} else {
			cow[i]+=k;
			m-=k;
		}
	}
}

inline void back() { //反方向入队伍
	if(m==0) return;
	for(int i=n-1; i>1; --i) { //i是从 n 到 2 的 
		if(m<k) { //人不够，剩下的全放
			cow[i]+=m;
			m=0;
		} else { 
			cow[i]+=k;
			m-=k;
		}
	}
}

inline void work() {
	while(m>=k) { //可以继续放 
		go(); // 正方向 
		back(); // 反方向 
	}
}

signed main() {
	std::ios::sync_with_stdio(false);
	n=read();
	k=read();
	m=read();
	memset(cow,0,sizeof cow); //初始化，可有可无 
	work();
	for(int i=1; i<=n; ++i) cout<<cow[i]<<' '; //输出 
	return 0;
} //记得开 O2 
```

温馨提醒（如果你看到了这里）：由于本题是纯模拟题，所以时间复杂度为 $O(\frac{nm}{k})$，所以记得吸氧哟，不然会 tle 三个点。

---

## 作者：WanderingTrader (赞：0)

这是一道树穴好题。
### 前言
这是本人第一次提交的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 200005
int ans[N];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&k,&m);
	int sign = 1,pos = 1;
	while(m >= k)
	{
		ans[pos] += k;
		m -= k;
		pos += sign;
		if(pos < 1) {sign = 1;pos = 2;}
		else if(pos > n) {sign = -1;pos = n-1;}
	} 
	ans[pos] += m;
	for(int i = 1;i <= n;++ i) printf("%d ",ans[i]);
	return 0;
}
```
纯模拟，复杂度$O(\dfrac{m}{k})$，但题目中说：
>In test cases worth a total of 40 points, it will hold M / K ≤ 200 000.

直译过来就是：对于40%的测试点，保证$\dfrac{m}{k}\le2\times10^5$。  
言外之意就是，另外60分，不保证不会超时。  
果然，提交上去63分，需要优化。  
### 题目分析
我们不妨这样想：把队列看成是一个长度为$2\times n-2$的线性表，编号$1,2,\dots,n-1,n,n-1,\dots,2$。  
然后不断从头到尾放$k$个人，代替了原来的环形处理。  
想起来什么？没错，周期问题。
### 代码
首先我们定义一个$nn=2\times n-2$，表示新队列的长度，然后对其初始化，使它指向应指向的队伍：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 200005
int ans[N],id[N*2];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&k,&m);
	int nn = 2*n-2;
	for(int i = 1,f=1,pos=1;i <= nn;++i,pos+=f)
	{
		id[i] = pos;
		if(pos == n) f=-1;
	}
	for(int i = 1;i <= n;++ i) printf("%d ",ans[i]);
	return 0;
}
```
这里$f$表示当前是顺走还是逆走，$pos$表示当前的位置。 

然后我们需要知道每个队伍最初可以拿到多少学生，即：  
$总学生数\div每次发多少学生\div队列的长度$  
译成代码就是：
```cpp
int a = m / k / nn;
```
那么把每个队伍先加上$a\times k$个人，把$m$减去$nn\times k\times a$个人，即：
```cpp
for(int i = 1;i <= nn;++ i) ans[id[i]] += k*a;
m -= nn*a*k;
```
这时$m$可能还有剩余，那怎么办？按队列顺序再发一遍就行了。
```cpp
int i;
for(i = 1;i <= nn && m > k;++ i)
{
	ans[id[i]] += k;
	m -= k;
}
ans[id[i]] += m;
```
别忘了对残留的学生数$m($此时$m\le k)$进行处理。 

最后输出答案即可。

全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 200005
int ans[N],id[N*2];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&k,&m);
	int nn = 2*n-2;
	for(int i = 1,f=1,pos=1;i <= nn;++i,pos+=f)
	{
		id[i] = pos;
		if(pos == n) f=-1;
	}
	int a = m / k / nn;
	for(int i = 1;i <= nn;++ i) ans[id[i]] += k*a;
	m -= nn*a*k;
	int i;
	for(i = 1;i <= nn && m > k;++ i)
	{
		ans[id[i]] += k;
		m -= k;
	}
	ans[id[i]] += m;
	for(int i = 1;i <= n;++ i) printf("%d ",ans[i]);
	return 0;
}
```
时空复杂度均为$O(nn)$，而$nn=2(n-1)$，所以复杂度也就是$O(n)$，非常高效。  

$\mathrm{The\ End.}$

---

## 作者：Goldbach (赞：0)

# 模拟+贪心+o2==AC
```
// luogu-judger-enable-o2//o2大法好
#include<bits/stdc++.h>
using namespace std;
int a[1000000+3];
int n,k,m;
void o(){
	for(int j=1;j<=n;j++){
		cout<<a[j]<<' ';
	}
}
int main(){
	cin>>n>>k>>m;//输入
	while(1){
	for(int i=1;i<=n-1;i++){//从1到n-1
		if(m<0){
			o();
			return 0;
		} 
		else a[i]+=min(k,m);//取最小值
		m-=k;
	}
	for(int i=n;i>=2;i--){//n到2
		if(m<0){
			o();
			return 0;
		} 
		else a[i]+=min(k,m);//取最小值
		m-=k;
	}
	}
	return 0;
}

```
望管理员通过


---

## 作者：VIOLET__FOREVER (赞：0)

题目[传送门](https://www.luogu.com.cn/problem/P5051)
## 思路
由于题目给出的顺序是——

$1^{th}\to2^{th}\to3^{th}\to\dots\to(n-1)^{th}\to n^{th}$

$\to(n-1)^{th}\to(n-2)^{th}\to\dots\to2^{th}\to1^{th}\to2^{th}$

因为我们每走一回在开头和结尾只走了一次，而其他位数则走了两次，这样的话我们再分组的时候就可以不按照 $1 \to \dots\to n$ 来执行而可以分为 $1 \to \dots\to n-1$ 和 $n \to\dots\to 2$ 两段，这样我们就可以有效的缓解首尾出现次数的问题，并且可以方便分解，这样的话我们就可以将每次循环的时间复杂度变为乘法即将 $O(\dfrac{m}{k})$ 变为 $O(n)$ 就可以有效的解决 TLE 的问题,然后剩下的数就纯暴力将他们填上。
## AC code
这个代码有点长——
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //用宏定义将 int 变为 long long 防止精度问题 
int len,n,k,m,flag,a[1000005];
signed main(){
	cin>>n>>k>>m;
	len=m/((n-1)*k);//判断数据的组数 
	m-=len*(n-1)*k;//算出多余的人数 
	if(len%2==1){//分奇数和偶数进行判断 
		for(int i=1;i<=n;i++){
			if(i==1) a[i]+=k*(len/2+1);//因为是奇数次，所以开头要比结尾多上一次 
			else if(i==n) a[i]+=k*(len/2);
			else a[i]+=k*len;
		}
		for(int i=n;i>=1;i--){
			a[i]+=min(m,k);
			m-=min(m,k);
			if(!m) break;//如果没有人了，就退出 
		}
	}
	else if(len%2==0){
		for(int i=1;i<=n;i++){
			if(i==1 || i==n) a[i]+=k*(len/2);//偶数次就说明开头与结尾出现的次数相同 
			else a[i]+=k*len;
		}
		for(int i=1;i<=n;i++){
			a[i]+=min(m,k);
			m-=min(m,k);
			if(!m) break;
		}
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";
	}
	return 0;
} 
```


---


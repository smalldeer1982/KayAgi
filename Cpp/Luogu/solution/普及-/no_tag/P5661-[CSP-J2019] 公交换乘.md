# [CSP-J2019] 公交换乘

## 题目描述

著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：
1. 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：
$t_{bus} - t_{subway} \leq 45$。
2. 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。
3. 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。

现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?

## 说明/提示

**样例 1 说明**

第一条记录，在第 3 分钟花费 10 元乘坐地铁。

第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。

第三条记录，在第 50 分钟花费 12 元乘坐地铁。

第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。

第五条记录，在第 110 分钟花费 5 元乘坐地铁。

第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。

总共花费 36 元。 

**样例 2 说明**

第一条记录，在第 1 分钟花费 5 元乘坐地铁。

第二条记录，在第 16 分钟花费 20 元乘坐地铁。

第三条记录，在第 23 分钟花费 7 元乘坐地铁。

第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。

第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。

第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。

总共花费 32 元。 


**数据规模与约定**

对于 $30\%$ 的数据，$n \leq 1000$，$t_i \leq 10^6$。

另有 $15\%$ 的数据，$t_i \leq 10^7$，所有 $price_i$ 相等。

另有 $15\%$ 的数据，$t_i \leq 10^9$，所有 $price_i$ 相等。

对于 $100\%$ 的数据，$n \leq 10^5$，$t_i \leq 10^9$，$1 \leq price_i \leq 1000$。

## 样例 #1

### 输入

```
6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135```

### 输出

```
36```

## 样例 #2

### 输入

```
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 ```

### 输出

```
32```

# 题解

## 作者：泥土笨笨 (赞：483)

拿到题目看一下，大体思路还是比较清晰的，用一个数组来装所有的收集到的赠票。每当坐地铁的时候，就直接花钱，然后获得一张赠票，放到数组里面。每当坐公交的时候，看看数组里面有没有时间合适，价格小于现在公交票价的赠票，并且没用过的赠票，直接用时间最早的那一张就可以了。

每张赠票要存三个信息，因此用一个结构体来存。数据不超过$10^5$，因此开一个$10^5$长度的数组。

```cpp
const int MAXN = 100005;
struct Ticket {
    //赠票的价格，最晚使用时间和是否需用过
    int price, time, used;
} q[MAXN];//赠票盒子
```

然而，出题人会这么善良么？显然不会。我们想想极限情况什么样子，极限数据$10^5$，假设开始的时候全坐地铁，坐了$5*10^4$ 次以后，我们的盒子里面有好多票啊。后面全坐公交，要坐$5*10^4$ 次，每次都在这个大盒子里面找合适的票，复杂度$O(n^2)$,总计算量$2.5*10^9$，我们在超时的边缘疯狂试探啊。

怎么优化呢?关键点在于题中说每次坐车开始时间都不重合，而且45分钟票就过期。所以理论上来讲，盒子里最多也就有45张没过期的票。大量的票都是已经过期了的，没必要从头扫一遍数组，在大量过期的票中浪费宝贵的青春。所以我们想到类似手写队列的方法，定义一个head变量和一个tail变量，分别表示目前还没过期的第一张票的位置，和下一张新的赠票在数组里要插入的位置，每次从head到小于tail循环即可。每次最多循环45次，总共$10^5$次循环，肯定不会超时。

其余细节看代码注释吧。不要复制粘贴哦。

```
#include <iostream>

using namespace std;
const int MAXN = 100005;
struct Ticket {
    //赠票的价格，最晚使用时间和是否需用过
    int price, time, used;
} q[MAXN];//赠票盒子
int head, tail, n, cost;

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        int op, price, time;
        //输入每次坐车的种类，价格和发车时间
        cin >> op >> price >> time;
        if (op == 0) {
            //如果是坐地铁，直接把价格加到cost里面
            cost += price;
            //新一张赠票插入数组末尾，这张票的最晚使用时间是当前时间+45
            q[tail].time = time + 45;
            //赠票面额就是地铁票价
            q[tail++].price = price;
        } else {
            //先用一个循环把过期票扔掉
            while (head < tail && q[head].time < time) {
                head++;
            }
            bool found = false;//表示是否有合适的赠票，先假设没有
            for (int j = head; j < tail; ++j) {
                //循环所有剩余的票，这些一定都没过期，因为题目中时间是按顺序给我们的
                if (q[j].price >= price && q[j].used == 0) {
                    //如果价格合适，并且没用过，标记找到了，这张票标记用过
                    found = true;
                    q[j].used = 1;
                    break;
                }
            }
            //如果没找到合适的赠票，老老实实花钱买吧
            if (!found) cost += price;
        }
    }
    cout << cost << endl;
    return 0;
}
```


---

## 作者：andyli (赞：15)

使用一个vector存储当前可用的优惠票。当乘坐地铁时在vector末尾添加这张优惠票使用的时间以及票价，当乘坐公交时则从头遍历vector，由于时间是递增的，所以可以把一切失效的优惠票从vector中删除。当找到一个公交票价不大于优惠票票价时则使用并将其从vector中删除。若找不到满足题意的优惠票则需花钱乘坐公交。时间复杂度$O(45n)$。  
主要代码如下（最优解排行第$3$, 用时$93$ms）：
```cpp
struct Node {
    int price, time; // price - 优惠票票价, time - 优惠票的获得时间
    Node(int price = 0, int time = 0) : price(price), time(time) {}
};

vector<Node> tickets; // 当前的所有优惠票
int main()
{
    int n;
    io.read(n);
    LL ans = 0;
    for (int i = 1; i <= n; i++) {
        int opt, price, t;
        io.read(opt, price, t);
        if (!opt) { // 乘坐地铁
            tickets.emplace_back(price, t); // 添加优惠票
            ans += price; // 坐地铁需花费price元
        } else { // 乘坐公交
            bool flag = false;
            for (size_t i = 0; i < tickets.size(); i++) {
                if (t - tickets[i].time > 45) // 优惠票已失效，从vector中删除
                    tickets.erase(tickets.begin()), i--;
                else if (tickets[i].price >= price) { // 一张可用的优惠票
                    tickets.erase(tickets.begin() + i); // 用完需删除
                    flag = true;
                    break;
                }
            }
            if (!flag) // 没有满足题意的优惠票，则花price元乘公交
                ans += price;
        }
    }
    writeln(ans);
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：12)

## P5661 [CSP-J2019] 公交换乘题解
在搭乘一次地铁后可以获得一张优惠票，有效期为 $45$ 分钟。这个优惠券可以抵消上公交车的费用。开始乘公交车的时间与开始乘地铁的时间之差小于等于 $45$ 分钟。

搭乘地铁获得的优惠票可以累积。可以乘坐多次地铁再做公交车。  

如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。  

**注意：输入时 $0$ 表示坐地铁，$1$ 表示坐公交车。**


------------

- 优惠券存在超时的问题，先得到的优惠券先超时，而队列的特点是先进先出，优惠券的特点也是先进先出。所以这道题肯定用队列。
- 优惠券有价格和获取时间，所以队列需要存储到结构体。
- 写代码时先让售票员不管三七二十一的把你坐地铁或公交的钱抢了，如果是坐公交且有符合条件的优惠券，就用掉优惠券。让售票员老老实实的把钱退给你。
- 不过用数组模拟会放便亿点点。如果用队列，寻找优惠券时要把整个队列找一波，用数组模拟寻找优惠券时如果找到优惠券了，就记录下来，直接退出。
```cpp
#include<bits/stdc++.h>//头文件，写烂了。
using namespace std;//命名空间
long long head=1,tail=1;//定义两个变量head和tail，分别是数组头一个元素的编号和数组最后一个元素的编号+1。注意：最开始是没有优惠券的。
struct node//struct node是结构体，不会的私信。node是结构体名称。
{
	int j,s;//定义j和s，代表乘坐地铁的优惠券的价钱和时间。
}q[1000005];//定义q数组，模拟队列，数组统一开1000005
int main()//主函数
{
	int n;//定义个正整数n，代表乘车记录的次数。
	cin>>n;//输入n
	int op,pe,te;//定义三个变量op,pe,te，分别表示乘坐地铁或公交的类型，价钱和时间。与j和s代表的 意思不相同。
	int ans=0;//定义变量ans，记录出行的总花费
	while(n--)//用while循环模拟乘坐地铁或公交的过程。
	{
		cin>>op>>pe>>te; //输入乘坐地铁或公交的类型，价钱和时间
		ans+=pe;//先把钱交了。
		if(op==0)//如果发现乘坐的是地铁。
		{
			q[tail]={pe,te};//把这张乘坐公交的优惠券的价钱和时间记录下来，放到数组的最后面。
			tail++;//由于tail没有元素，所以tail要往右移一个位置。
		}
		else//否则乘坐的是公交。
		{
			while(head!=tail&&te-q[head].s>45)//再没有优惠券才怪的情况下找超时的优惠券。
			{
				head++;//因为每张while循环的优惠券都超时了，所以头一个不超时的优惠券的编号要+1.
			}
			for(int i=head;i<=tail-1;i++)//从一头一个不超时的优惠券遍历到最后一个不超时的优惠券
			{
				if(q[i].j>=pe)//如果发现这张优惠券可以抵消公交车的车费。
				{
					ans-=pe;//让售货员退钱。
					q[i].j=-1;//这张优惠券用过了，把优惠券的价值标为-1，以免重复使用。
					break;//跳出循环。
				}
			}
		}
	}
	cout<<ans;//输出出行的总花费
	return 0;//返回0，早上敲博客真舒服。
}
```

---

## 作者：ikunTLE (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P5661)

### 思路

不难想到暴力思路：每次循环判断每一张优惠券是否在规定时间内。然而这样做的时间复杂度为 $\mathcal{O}(n^2)$，不可行。

考虑**队列**优化，每次判断时把前面已经超过 $45$ 分钟的优惠券弹掉。这样做，时间复杂度降到了 $\mathcal{O}(n)$，可以通过此题。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define front _front
#define back _back//防止重名
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e5+10;
struct node{
	bool type;//类型
	int price,t;//命名如题意
}q[N];
int front,back=1;
int main(){
	int n=read(),ans=0;
	for(int i=1;i<=n;++i){
		node temp={(bool)read(),read(),read()};
		if(temp.type){//公交车
			bool flag=false;
			for(int j=back;j<=front;++j)
				if(temp.t-q[j].t<=45){//队列优化判断条件
					if(temp.price<=q[j].price){
						q[j].price=0;
						flag=true;
						break;
					}
				}
				else back=j;//弹掉不符合条件的优惠券
			if(!flag)
				ans+=temp.price;
		}
		else{//地铁
			ans+=temp.price;
			q[++front]=temp;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：__gcd (赞：8)

不知道大家注意这个了没有

$price\le1000$

所以我们可以开个桶来优化一下

一个队列$a[i]$存储票价为$i$的所有地铁的时间

然后如果要查询用哪张优惠票，只要从$p$到$1000$跑一遍，如果时间差大于45，就直接弹出，然后在所有查询到的第一个没有超时的优惠券中取一个时间最小的优惠券使用，否则时间加上$p$

复杂度大概是O(n)，常数在一两千左右

代码，注释就不写了，相信大家看得懂


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

struct In
{
	template <typename T>
	inline In& operator >> (T &x)
	{
		register char c = getchar();
		int op = 0; x = 0;
		while(c ^ '-' && !isdigit(c))c = getchar();
		if(c == '-')op = 1, c = getchar();
		while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
		if(op)x = -x;
		return *this;
	}
} in;

const int N = 100010;
const int MAXN = 1010;
	
queue<ll> a[MAXN];

int n;

int main()
{
	in >> n;
	ll ans = 0;
	for(int i = 1; i <= n; i++)
	{
		ll op, p, t;
		in >> op >> p >> t;
		if(op == 0)
		{
			a[p].push(t);	 	
			ans += p;
		}
		else 
		{
			ll mini = (ll)(1) << (ll)(60);
			int pos = 0;
			for(int i = p; i <= 1000; i++)
			{
				while(a[i].empty() == false && a[i].front() + 45 < t)
				{
					a[i].pop();
				}
				if(a[i].empty() == false)
				{
					if(mini > a[i].front())
					{
						pos = i;
						mini = a[i].front();
					}
				}
			}
			if(mini > 1e9)ans += p;
			else a[pos].pop();
		}
	}
	cout << ans; 
	return 0;
}
```

最后BB几句，我在考场上把这道题$mini$的初值设小了，导致只有60分qwq

---

## 作者：Xu_Jinyi_2011 (赞：7)

# 题解
这道题可以用队列来做。按时间从前到后的顺序入队。
## 思路：
+ 当搭乘的是地铁的时候，把当前地铁的时间和价格入队。
+ 当搭乘的是公交的时候，如果队头的票时间超限，就把队头票出队。遍历一遍可用的票，当当前票的抵消价格大于公交价格时，必然使用当前票。让售票员退钱，把当前票的抵消价格标记为最小，然后退出遍历即可。
## 代码：
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
int n;
int pr, t;
int que[(int)1e5 + 10], que2[(int)1e5 + 10], ta, f;
int main() {
	cin >> n;
	for (int i = 0; i < n; i ++) {
		int a, b, c;
		cin >> a >> b >> c;
		pr += b;
		if (a == 0) {// 地铁
			que[f] = b;
			que2[f] = c;
			f ++;
		} else {// 公交
			while (c - que2[ta] > 45) ta ++;
			for (int j = ta; j < f; j ++) {
				if (que[j] >= b) {
					pr -= b;// 退钱
					que[j] = -0x3f3f3f3f;// 标记，表示已使用
					break;
				}
			}
		}
	}
	cout << pr;
	return 0;
}
```

---

## 作者：Zxx200611 (赞：6)

其实这题的正解做法是很多的，可以用`priority_queue`,二分......
反正一定要是$O(n \log_2n)$的做法就可以过  
我用了二分  
大体思路就是用一个数组+结构体存下优惠票（为了省空间我用了`vector`，但用普通数组其实也能过）  
每次遇到地铁就往`vector`里`push`一张优惠票  
遇到巴士就在`vector`里找一张同时满足  
1.**没用过**的优惠票  
2.时间差**不超过45分钟**且**时间差最大**的优惠票  
3.获得这张优惠票乘坐的那次地铁票的价格**大于等于**这次坐巴士的价格的优惠票  
又因为价格不是按顺序给出的，所以只有时间具有单调性，于是先按时间二分，找到一张最早但还没过期的优惠票，再往后遍历`vector`找出一张能满足价格条件的即可  
于是二分的代码就可以糊出来了
```cpp
struct tic	//票 
{
	int ti,pri;	//时间，价格 
	bool used;
};
vector<tic> t;	//存储票 
int div2_search(int ti,int pri)	//把乘巴士的时间，价格传进去 
{
	int l=0,r=t.size()-1;	//范围从0到优惠票的张数减一（因为vector从零开始） 
	int mid;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(ti-t[mid].ti<=45)	//时间差小于等于45min 
		{
			r=mid;	//尽量找早的票 
		} 
		else
		{
			l=mid+1;
		} 
	}
	for(int i=l;i<t.size();i++)	//由于价格不一定递增，所以往后（能保证时间差小于45min）找 
	{
		if(t[i].pri>=pri/*保证价格*/&&!t[i].used/*没有用过*/)return i;
	}
	return -1;	//找不到可以用的优惠票 
}
```
二分的代码写出来了，就很容易了  
给出完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tic	//票 
{
	int ti,pri;	//时间，价格 
	bool used;
};
vector<tic> t;	//存储票 
int div2_search(int ti,int pri)	//把乘巴士的时间，价格传进去 
{
	int l=0,r=t.size()-1;	//范围从0到优惠票的张数减一（因为vector从零开始） 
	int mid;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(ti-t[mid].ti<=45)	//时间差小于等于45min 
		{
			r=mid;	//尽量找早的票 
		} 
		else
		{
			l=mid+1;
		} 
	}
	for(int i=l;i<t.size();i++)	//由于价格不一定递增，所以往后（能保证时间差小于45min）找 
	{
		if(t[i].pri>=pri/*保证价格*/&&!t[i].used/*没有用过*/)return i;
	}
	return -1;	//找不到可以用的优惠票 
}
int main()
{
	int n;
	cin>>n;
	int li,ti,pri;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		cin>>li>>pri>>ti;	//输入 
		if(li==0)	//遇到地铁 
		{
			t.push_back((tic){ti,pri,0});	//获得一张没用过的优惠票
			ans+=pri;	//地铁不能用优惠票 
			continue;
		}
		int pos=div2_search(ti,pri);
		if(pos==-1)ans+=pri;	//没有可以用的票 
		else t[pos].used=1;		//有可以用的票，用掉它 
	}
	cout<<ans<<endl;
}
```

---

## 作者：Yxy7952 (赞：5)

## 思路

模拟题。

在《深入浅出基础版》中介绍过这类题目，这类题目一般只需按照题意模拟，特殊情况时需要使用数据结构及优化。

思路也很简单，直接暴力，乘坐地铁时，花费价格直接加到总和。

否则往前枚举，首先，如果时间相差超过 $45$ 分钟，直接结束。之后判断：如果乘坐的是地铁，花费的价格更高，且优惠卷没被使用，那就使用优惠卷，否则原价购买。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans,b[100005],mi;
struct kun{
	long long p,t;// price 价格，time 时间
	bool c;//c 乘车种类
}a[100005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].c>>a[i].p>>a[i].t;
		b[i]=1;//标记优惠卷未使用。
	} 
	for(int i=1;i<=n;i++){
		if(a[i].c==0) ans+=a[i].p;//如果是地铁直接坐。
		else{//如果是公交车，考虑使用优惠卷。
			mi=-1;
			for(int j=i-1;j>=1;j--){//枚举他前面的乘车记录。
				if(a[i].t-a[j].t>45) break;
				if(a[j].p>=a[i].p&&a[j].c==0&&b[j]==1){
					mi=j;
				}//满足要求。
			}
			if(mi==-1) ans+=a[i].p;
			else b[mi]=0;	//记得标记已使用。
		}		
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：3)

### 题目大意

我们按照时间顺序遍历所有的票：

- 当是地铁票时，则直接计费。

- 当是公交票时：
  - 若 $45$ 分钟内未坐过地铁，则正常计费。
  - 若 $45$ 分钟内坐过一次地铁，则使用该次坐地铁获得的优惠券抵扣本次公交车的费用。
  - 若 $45$ 分钟内坐过多次地铁，则使用最早的坐地铁获得的优惠券。

### 解题思路

考虑暴力，记录每趟地铁获得的优惠券是否被使用了，当发现是公交时则往从前往后枚举符合条件的地铁票，最坏时间复杂度 $O(n^2)$。

由于只有 $45$ 分钟以内的地铁票可以抵扣公交票，那么上述枚举时间浪费较大，所以我们可以考虑用一个指针记录一下 $45$ 分钟内未使用的地铁票的位置，最坏时间复杂度 $O(n)$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N], p[N], t[N];
bool st[N];

int main()
{
    cin >> n;
    
    int res = 0, l = 1;
    for (int i = 1; i <= n; ++ i )
    {
        cin >> a[i] >> p[i] >> t[i];
        if (!a[i])
            res += p[i];
        else
        {
            while (l < i && (a[l] == 1 || st[l] || t[l] + 45 < t[i]))
                l ++;
            bool find = false;
            for (int j = l; j < i; ++ j )
                if (!a[j] && !st[j] && p[j] >= p[i])
                {
                    st[j] = true;
                    find = true;
                    break;
                }
            if (!find)
                res += p[i];
        }
    }
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：zlqwq (赞：2)

前言：这篇题解的代码用了早期码风，可能有点丑，请见谅。

数据范围 $n≤10^5$ 着实有点大，不能直接枚举了。

但是我们可以给模拟加一点小优化。

我们那一个变量 $top$ 来存储当前一共有几张车票，然后用一个结构体数组来存储。

结构体定义：定三个变量 $type$ 代表是地铁还是公交。然后 $price$ 和 $time$ 就是按照题目定义。

显然，当一张车票已经过期，我们就没有必要再去枚举他了。

故我们可以再定一个变量 $pos$ 来表示第一张能用的车票，这样就起到了优化的作用。

我们在每次遍历的时候，就需要判断当前这个车票用没用，如果用了就统计答案，否则就直接更新 $pos$ 的值就行了。

代码：


```cpp
#include<iostream>
#define int long long
#define debug cout << "zlqwq" << endl;
#define inf 1e18

using namespace std;
int n;
struct edge {
	int price,time;
	int type;
};
int ans;
edge stk[100005];//公交车票 
int top,pos;
signed main() {
	cin >> n;
	for(int i = 0;i < n;++i) {
		edge p;
		cin >> p.type >> p.price >> p.time;
		if(p.type == 0) {
			ans += p.price;
			stk[top++] = p;
		}
		else {
			bool flg = 0;
			for(int j = pos;j < top;++j) {
				if(p.time - stk[j].time <= 45) { 
					if(p.price <= stk[j].price) {
						stk[j].price = 0;
						flg = 1;
						break;
					}
				}
				else pos = j;
			}
			if(!flg){
				ans += p.price;
			} 
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：WsW_ (赞：2)

### 思路
按题意模拟。  
用一个双端队列来存优惠票价和获得时间。  
如果坐地铁，花费相应的钱数并且往双端队列里面塞一个优惠票。因为输入数据的时间递增，所以双端队列里优惠票的获得时间也是递增。  
如果坐公交，先把过期的优惠票从双端队列里面删除，然后判断队首的票价是否能够使用。如果不能够，就把这张票塞到另外一个栈里面存着，并把这张票从双端队列中删除，重复这个过程。如果双端队列空了还没有能用的票，就得原价坐公交车，否则删除能用的票，免费坐公交车。最终还要把存在栈里面的票从队首塞回双端队列里。  
因为票的有效期只有 $45$ 分钟，所以双端队列里面最多只有 $45$ 张票，时间复杂度为 $O(45n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int t,val;
};
deque<node>q;
stack<node>s;
int n;
int opt,val,t;
int sum;

int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d%d%d",&opt,&val,&t);
		while(!q.empty()&&t-q.front().t>45)q.pop_front();
		if(opt){
			bool f=0;
			while(!q.empty()){
				if(q.front().val>=val){
					f=1;
					q.pop_front();
					break;
				}
				s.push(q.front());
				q.pop_front();
			}
			while(!s.empty()){
				q.push_front(s.top());
				s.pop();
			}
			if(!f)sum+=val;
		}
		else{
			sum+=val;
			q.push_back({t,val});
		}
	}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：Jayfeather2012 (赞：2)

## 题目大意
有 $n$ 条出行记录（公交或地铁）。

若是地铁，输入价格及时间，付钱并积累一张性质和本次出行记录相同的优惠券。

若是公交，输入价格及时间，如果有优惠券满足优惠券时间与乘公交时间之差小于等于 $45$ 分钟且优惠券价格大于公交车价格，就选择其中最先获得的一张并消耗掉它，否则就付钱。

求花费钱数。
## 思路
如果每次坐地铁都遍历每张优惠券，时间复杂度为 $O(n^2)$，肯定 TLE。

优化一下，用一个队列存优惠券，队头表示第一张还没过期的优惠券，队尾表示最新加入的优惠券。

坐地铁时，优惠券进队并增加总价。

坐公交时，先弹出过期的优惠券（因为乘车时间是单调的，现在过期了，以后肯定也不能用了），这样就可以节省大量遍历已经用过优惠券的时间。然后遍历队列，找到第一个没有被用过且价格足够的优惠券，将其标记为用过，若没有找到，就增加总价。

因为每一个时间都是不同的，所以循环次数最多是 $45\times n$，足以 AC 本题。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
struct Node
{
	int a,b;//a表示价格，b表示时间 
}x[100005];
bool w=1;
int n,x1,x2,x3,s,h,t,r[100005];//r表示优惠券有没有被用过 
int main()
{
	ios::sync_with_stdio(0); 
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>x1;
		if(x1){//公交
			cin>>x2>>x3;
			w=1;
			while(h<=t&&x3-x[h].b>45)++h;//如果过期就弹出 
			for(int j=h;j<=t;++j){//遍历未过期优惠券 
				if(x[j].a>=x2&&!r[j]){//如果价格足够且未被用过就用掉 
					w=0;//标记不用付钱 
					r[j]=1;//标记优惠券已用过 
					break;
				}
			}
			if(w)s+=x2;//没有满足的优惠券，付钱！ 
		}
		else{//地铁
			cin>>x[++t].a>>x[t].b;//存优惠券 
			s+=x[t].a; 
		}
	}
	cout<<s;
  	return 0;
}
```

---

## 作者：a18981826590 (赞：2)

# [P5661 [CSP-J2019] 公交换乘](https://www.luogu.com.cn/problem/P5661)
## 解题思路
遇到地铁直接加上其票价，并将它的时间和票价放入优惠票队列。

遇到公交车时，先把所有超时的优惠票丢弃，因为出行记录是按照开始乘车的时间顺序给出的，所以对于后面的公交车这些优惠票也超时了，没有用了。由于我们使用队列存储优惠票，所以时间越靠前的优惠票越先出队，一直弹出队首直到队首未过期或队列为空。

接着，在剩下的未过期的优惠票中找到最早的价格大于等于当前公交车的票价的优惠票（如果有多张优惠票满足条件，则优先消耗获得最早的优惠票）；如果没有价格大于等于当前公交车的票价的优惠票，则加上当前公交车的票价。

由于我们使用的是队列，按顺序遍历即可找到最早的满足条件的优惠票；但为了保存并维护剩余优惠票，我们需要使用临时队列来存储查询过程中出队的优惠票，并在查询完毕后将其复制到原优惠票队列。
## [AC](https://www.luogu.com.cn/record/167724038) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,n,s;
queue<int>d,e,f,g;
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	while(n--){
		cin>>a>>b>>c;
		if(a==0){
			s+=b;
			d.push(b);
			e.push(c);
		}
		else{
			while(!e.empty()&&c-e.front()>45){
				d.pop();
				e.pop();
			}
			while(!d.empty()&&d.front()<b){
				f.push(d.front());
				g.push(e.front());
				d.pop();
				e.pop();
			}
			if(d.empty()) s+=b;
			else{
				d.pop();
				e.pop();
			}
			while(!d.empty()){
				f.push(d.front());
				g.push(e.front());
				d.pop();
				e.pop();
			}
			while(!f.empty()){
				d.push(f.front());
				e.push(g.front());
				f.pop();
				g.pop();
			}
		}
	}
	cout<<s;
	return 0;
}
```

---

## 作者：jiqihang (赞：2)

### 题目链接
[P5661 [CSP-J2019] 公交换乘](https://www.luogu.com.cn/problem/P5661)
### 思路
一道模拟题。

直接去暴力，在乘坐地铁时，花费的价格可以直接加到总和。

否则的话往前枚举，如果时间相差超过有效期，直接结束。

之后在进行判断——如果乘坐的是地铁，花费的价格更高，且优惠卷还没有被使用，那就用优惠卷，否则原价购买。

---

## 作者：Mountains_OIer (赞：1)

## 思路
看到这道题，首先想到的是暴力，但是暴力复杂度高达 $O(n^2)$，无法通过本题，所以我们选择用数组模拟队列实现：
+ 如果坐的是地铁，直接付款，并将优惠券压入队列。
+ 如果坐的是公交：
  + 如果优惠券已过期，弹出队列。
  + 如果优惠券未过期且未标记，使用它并标记它。
  + 如果优惠券未过期但已标记，忽略它。
## 代码
```cpp
#include<iostream>
#define int long long
using namespace std;
int s_b[100001],dt[100001],spend,tail,bus[100001],timex[100001],temp,n,m=1,k;
bool flag[100001];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>temp>>dt[i]>>s_b[i];
		if(!temp){
			bus[++tail]=dt[i];
			timex[tail]=s_b[i];
			spend+=dt[i];
		}
		else{
			k=0;
			for(int j=m;j<=tail;j++){
				if(flag[j])continue;
				if(s_b[i]-timex[j]>45) m=j;
				else if(bus[j]>=dt[i]){
					k=j;
					flag[k]=true;
					break;
				}
			}
			if(!k)spend+=dt[i];
		}
	}
	cout<<spend;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

小模拟，开一个队列维护优惠票的时间和价格。

对于乘公交，先删去过期的，按题意判断能否用优惠票即可。因为这里要遍历队列找最早的能用的优惠票，所以用了手写队列。

对于乘地铁，直接加上花费并将这一张优惠票入队即可。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, l=1, r;
pair<int, int> q[100005];
int main () {
	cin >> n;
	for (int op, p, t; n--; ) {
		cin >> op >> p >> t;
		if (op) {
			while (r-l+1>0&&t-q[l].first>45)
				++l;
			ans+=p;
			for (int i=l; i<=r; ++i)
				if (q[i].second>=p) {
					ans-=p;
					q[i]={-100, 0};
					break;
				}
		} else 
			ans+=p,
			q[++r]={t, p};
	}
	cout << ans;
	return 0;
}
```

---

## 作者：niuniudundun (赞：1)

# 题目大意

有一种地铁换乘公交车的优惠方案：

- 在搭乘一次地铁后可以获得一张优惠票，有效期为 $45$ 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 $45$ 分钟，即：
$t_{bus}-t_{subway}\leq 45$。
- 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。
- 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。

现在得到了小轩最近的公共交通出行记录，算算他的花费。

# 解法

考虑模拟和贪心。

存储记录有时间和金额，用 `struct` 即可。

思路：因为开始乘公交车的时间与开始乘地铁的时间之差小于等于 $45$ 分钟，所以搭乘一辆公交车，遍历地铁程票记录如果时间大于 $45$ 分钟，就把他删掉。剩下的就是能使的，再从能使的选最早的，还要删去这个记录。如果没一个能使的，只能加上钱了。

代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
const int maxn=100005;
struct stu{
	long long t,p;
	bool bl=false;
}a[maxn],b;
long long sum=0,n=0,ai=1,idx=1;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
		if(t==0){
			cin>>a[ai].p>>a[ai].t;
			sum=sum+a[ai++].p;
		}else{
			cin>>b.p>>b.t;
			bool bl=false;
			while(abs(a[idx].t-b.t)>45)idx++;
			for(int j=idx;j<=ai;j++){
				if(b.p<=a[j].p&&!a[j].bl){
					a[j].bl=true;
					bl=true;
					break;
				}
			}
			if(!bl) sum+=b.p;
		}
	}
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：Hexarhy (赞：1)

跟去年的【龙虎斗】风格一样，都是模拟题。不过今年的模拟偏简单，细节没有去年多，预计难度橙。

----------

### 解题思路

- 看懂题面。这里不做解释。

- 毫无疑问，所有的地铁记录，直接加即可。

对于公交车：

考虑到暴力`for`查询可能超时（实则不然），再加上下面这句话：

> 如果有多张优惠票满足条件，则优先消耗获得**最早**的优惠票。

第一反应就是用优先队列`std::priority_queue`，以时间作为关键字。然后就愉快地模拟了:

- 地铁记录，直接入队。

- 将已经超时的记录，直接出队。后面的记录只会越晚，所以直接`pop()`。

- 满足时间限制后，考虑对于票价限制，用临时数组`tmp`（这里推荐`std::vector`替代）储存不满足限制的记录，并更新队列，知道出现第一个符合限制的记录。

- 再把`tmp`里的记录重新入队。

-------------

**本题重点**：为什么要用临时数组tmp呢？

由于优惠票能延续，可能出现队列里的记录，对于较早的公交车记录，满足时间限制，不满足价格限制；但对于较晚的公交车记录，同时满足两条限制。故需要临时数组保存。

时间复杂度$O(n\log n)$，能过此题。至于$n^2$暴力，稍加优化也能过。实际评测代码还是很优秀的，最慢的点用了$\text{151ms}$。

> 用时：544ms  内存：2.14MB

-----------

### 代码细节

- 以防万一，总价开`long long`。

- 养成使用队列的良好习惯，能优先避免$\color{purple}\text{RE}$：每次访问队首或出队时，一定要检查队列是否为空。

- 队列重载运算符时，符号别反。

- 由于$\text{CSP}$不支持C++11，所以一些可以简化的代码在此并未使用。如：迭代器。

### 参考代码

~~丑陋的码风……~~

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <climits>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
//良好的宏有利于做题与解读代码
#define subway 0
#define bus 1
const int MAXN=1e5+5;
typedef long long ll;
int n;
struct record
{
	int type,price,time;
	bool operator<(const record a)const
	{
		return time>a.time;//别写反了
	}
}a[MAXN];
ll ans;//请用long long
priority_queue<record> q;

int read(void)
{
	int num=0;
	int negative=1;
	char c=getchar();
	while(!isdigit(c) && c!='-')
	 c=getchar();
	if(c=='-')
	 negative=-1;
	else
	 num=c-'0';
	c=getchar();
	while(isdigit(c))
	{
		num=(num<<1)+(num<<3)+(c^48);
		c=getchar();
	}
	return negative*num;
}

void input(void)
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i].type=read();
		a[i].price=read();
		a[i].time=read();
	}
}

void solve(void)//思路已述
{
	for(int i=1;i<=n;i++)
	{
		if(a[i].type==subway)
		{
			ans+=a[i].price;
			q.push(a[i]);
			continue;//相当于else
		}
		vector<record> tmp;tmp.clear();//临时数组tmp
		bool f=false;//标记是否可以使用优惠票
		while(!q.empty() && a[i].time-q.top().time>45)//养成检验队列是否为空的好习惯
		 q.pop();//直接排除过期的
		while(!q.empty())//开始找优惠票
		{
			const int p=q.top().price;
			if(p>=a[i].price)//满足价格限制
			{
				q.pop();
				f=true;
				break;//可以直接停止
			}
			tmp.push_back(q.top());//把不满足价格限制的记录储存到临时数组，以防之后能用
			q.pop();//并更新
		}
		for(vector<record>::iterator it=tmp.begin();it!=tmp.end();it++)
		 q.push(*it);//将临时数组里的记录存回去
		if(!f)//没有优惠票使用，加上价格。
		 ans+=a[i].price;
	}
}

int main()//简洁明了
{
	input();
	solve();
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：glass_goldfish (赞：1)

一道十分显然的模拟题。我们可以建立结构体，**坐地铁时**把票全部存进去，**坐公交车**时枚举结构体里面的票，看看可不可以免费乘坐。  

但是，这样的算法，每一次坐公交车时都要扫一遍结构体，时间复杂度是 $O(n^2)$ 的，在 $n=10^5$ 时显然会超时。

继续观察，发现绝对不会有两次乘车在同一分钟，那么可以使用的票最多只有 $45$ 张。所以（以下记当前票数为 $p$），只要枚举第 $\max\{1,p-44\}$ 张票到第 $p$ 张票即可。这样，时间复杂度就变成了接近 $O(nk)$（其中 $k$ 指 $45$，因为最多枚举 $45$ 张票），足以通过此题。

既然思路这样清晰，那么代码就不放了。

---

## 作者：GoldenSTEVE7 (赞：0)

## 题目简述
给定每次乘坐的交通工具，乘坐时间，以及乘坐所用的花费。若第 $i$ 次乘坐的是地铁，第 $j$ 次乘坐的是公交，满足 $j \ge i$ 且 $t_j - t_i \le 45$，那么第 $i$ 次的乘坐花费为 $0$。

求出乘坐的总费用。
## 思路
分别用数组记录下每次的乘坐方式，乘坐时间，以及花费。遍历每一次乘坐，如果满足题目要求的条件，就不将这一次的花费计入总费用，否则就将费用加入总费用。（详见代码）

### 注意
- 乘坐公交的费用可以直接加入总费用。
- 可以忽略掉所有在 $45$ 分钟以前的数据。（因为没用了）

## 代码

```cpp
#include<iostream>
using namespace std;
int a[100005], pr[100005], t[100005];
int main() {
    int n;
    cin >> n;
    int sum = 0;
    for(int i = 1; i <= n; i++) {
        cin >> a[i] >> pr[i] >> t[i];
    }	
	for(int i = 1; i <= n; i++) {
    	if(a[i] == 0) {
    		sum += pr[i];
    		continue;
    	}//如果乘坐方式为公交的话，可以直接加入总费用
    	bool fl = 0;
    	int x = (i-50<0 ? 1 : i-50);
    	//因为超过45分钟的地铁乘坐记录已经是没有用的了，所以这里可以忽略掉所有在45分钟以前的数据
    	for(int j = x; j < i; j++) {
    	    if(a[j] == 0 && t[i] - t[j] <= 45 && pr[i] <= pr[j]) {   	
    		    //满足条件的话就跳过，并记录这一次使用的优惠券已无法生效
    		    fl = 1; a[j] = 1;
    		    break;
    		}
    	}
        if(fl)  continue;
        sum += pr[i];//总费用计算
    }
    cout << sum << endl;
    return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

地铁票可以用来优惠公交车，但是只有 $45$ 分钟有效期。

考虑按照时间顺序遍历所有的票。地铁票就推进队列里，如果是公交车就遍历一下当前所有可行的票（由于时间不同，最多 $45$ 张可行，时间可以接受）。

由于队列是按照时间顺序进队的，直接每次判断之前先从队首弹出不合法的就行。

时间复杂度 $O(n)$。

---

## 作者：Network_Flow (赞：0)

遇到此类题目，直接按题意模拟。

但是直接枚举每一张优惠票，时间复杂度 $O(n^2)$，在 $n\le 10^5$ 的情况下无法接受。

所以需要进行优化。注意到如果优惠票超过使用时间，那么它对后面所有的公交都没有价值。这时候我们记 $pos$ 为最后一张有价值的车票，当检测到间隔时间超出时，直接 `pos++` 将其丢弃。

这样因为只有 $45$ 分钟有效时间，所以最多 $45$ 张有效票。时间复杂度 $O(n)$。

### Code:
```cpp
#include <iostream>
#include <cstdio>

using namespace std;
struct Ticket{
	int price, t, u; 
}a[100005];
int x, y, n, ans;
int main(){
	scanf("%d", &n);
	for (int i=1; i<=n; i++){
		int op, p, t;
		scanf("%d%d%d", &op, &p, &t);
		if(op==0){
			a[++y].t=t, a[y].u=0, a[y].price=p, ans+=p;
		}
		else if(op==1){
			bool f=1;
			for (int j=x; j<=y; j++){
				if((t-a[j].t>45)){
					x++;
					continue;
				}
				if((!a[j].u)&&(a[j].price>=p)){
					f=0, a[j].u=1;
					break;
				}
			}
			if(f) ans+=p;
		} 
	}
	printf("%d\n", ans);
	
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：0)

## 解题思路：
模拟题，但需要一点优化（？

每次输入时，先把所有过期地铁票给踢出队列，接下来判断：  
1. 若为地铁票，买下它，标记过期时间，并加入地铁票队列。
2. 若为公交车票，则在所有未过期的票中，找到第一张符合条件的票，使用它的免费条件。若没有满足条件的票，则花钱买票。

## CODE：

```cpp
#include <iostream>
using namespace std;
int n, head = 1, tail, op, pri, st;
long long ans;
bool can[100001];
struct node{int p, s;}a[100001];
int main()
{
	cin >> n;
	while (n--)
	{
		cin >> op >> pri >> st;
	    while (head <= tail && a[head].s < st) ++head;
		if (op == 0)
		{
			ans += pri;
			a[++tail].p = pri;
			a[tail].s = st + 45;
		}
		else
		{
			bool flag = 1;
			for (int i = head; i <= tail; i++)
			{
				if (a[i].p >= pri && can[i] == 0)
				{
					can[i] = 1;
					flag = 0;
					break;
				}
			}
			if (flag) ans += pri;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：0)

### 题目分析

不用多说，直接按照题目模拟即可。

可以采用队列记录所有坐地铁得到的优惠券。

每次都将过期优惠券从队列中删除。

对于乘坐公交，在队列中查找一张金额大于等于公交票价且没有使用的优惠券，使用它。

如果没有找到合适优惠券，则需要买票。

### 代码实现

好久之前的代码了，码风丑，请见谅。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node {
	int t, p;
	bool friend operator < (const node a, const node b) {
		return a.t > b.t;
	}
};
priority_queue <node> bus;
int ans = 0, n, op, money, start;
int main () {
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> op >> money >> start;
		if (op == 0) {
			ans += money;
			bus.push ({start, money});
		}
		else {
			while (!bus.empty () && bus.top ().t + 45 < start) bus.pop ();
			if (bus.empty ()) ans += money;
			else {
				vector <node> v;
				while (!bus.empty () && bus.top ().p < money) {
					v.push_back (bus.top ());
					bus.pop ();
				}
				if (bus.empty ()) ans += money;
				else bus.pop ();
				for (auto j : v) bus.push (j);
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：0)

首先暴力很好做，存下所有优惠票的数据，发现公交车就枚举每张票，最坏时间复杂度 $O(n^2)$，无法通过。

注意到每张优惠票有效期只有 $45$ 分钟，且不会有两次乘车记录出现在同一分钟，所以最多只有 $45$ 张有效的票，其余票可以直接弹掉。

时间复杂度直接降到了 $O(n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int _, ans, head = 0, tail = -1;
struct node{
	int p, t, vis;//vis 记录是否使用
}q[100005];//用 q 队列存储优惠票
int main(){
	cin >> _;
	while(_ --){
		int op, p, t;
		cin >> op >> p >> t;
		if(op == 0){
			ans += p;
			q[++ tail] = {p, t, 0};
		}
		else{
			while(t - q[head].t > 45) head ++;//超市弹出
			bool use = 0;
			for(int i = head; i <= tail; i ++){
				if(q[i].p >= p && !q[i].vis){//注意一张票只能用一次
					q[i].vis = 1; use = 1;
					break;
				}
			}
			if(!use) ans += p;
		}
	}
	cout << ans;
	return 0;
}
```

---


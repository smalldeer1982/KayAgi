# [CSP-S2019 江西] 日期

## 题目背景

CSP-SJX2019 T1

## 题目描述

Alice 在纸上写下了一个日期，形式为 $\text{MM-DD}$，其中 $\text{MM}$ 与 $\text{DD}$ 都是两位数字，分别表示月和天，然而这个日期并不一定存在。 Alice 找来了 Bob 要他更改若干位上的数字，使得这个日期存在。请你帮 Bob 算算他最少需要更改几位数字。

本题中我们认为 $2$ 月固定为 $28$ 天。

## 说明/提示

【输入输出样例 1 说明】

更改方式不止一种，其中一种方式是改为： $\text{03-22}$。

【输入输出样例 2 说明】

一种更改方式为：$\text{02-09}$。

【输入输出样例 3 说明】

一种更改方式为：$\text{07-09}$。

【数据规模与约定】
对于 $100\%$ 的数据：$\text{MM}$ 与 $\text{DD}$ 一定为 $4$ 个数字。

**update: 2024/07/04 增加 hack 一组。**

## 样例 #1

### 输入

```
03-32```

### 输出

```
1```

## 样例 #2

### 输入

```
02-39```

### 输出

```
1```

## 样例 #3

### 输入

```
67-89```

### 输出

```
2```

# 题解

## 作者：LRY314 (赞：82)

我们先看日期，发现日期至多只需要一步就可以改合法，因为不论它是什么数，只要把十位改为 $1$ 就一定合法。

再看月份，由于日期的合法性受月份影响，我们把判断分为以下几块：

$1.$ 日期 $=0$ 或日期 $>31$，一定不合法，需要一步改日期，月份若合法则答案为 $1$，否则为 $2$，因为月份在日期用一步改为小于等于 $28$ 的数后可以改成 $1$ 到 $12$ 中任何数，这至多需要一步。

$2.$ 日期 $=31$，月份为 $1,3,5,7,8,10,12$ 时合法，答案为 $0$。  

   如果月份本身合法但日期超了，那么改日期十位即可，答案为 $1$。
   
   月份不合法时，如果月份十位为 $1$，那么改十位即可；如果月份十位不为   $1$，个位为 $1,3,5,7,8$ 时可将十位改为 $0$，个位为 $0,2$ 时可将十位改为  $1$，答案为 $1$；而个位为 $4,6,9$ 时需要额外一步改月份，答案为 $2$。
   
$3.$ 日期 $=30$ 或日期 $=29$，月份合法 （$2$ 除外）时均不需要修改，答案为 $0$。

而月份为 $2$ 时，只需改日期为 $20$，答案为 $1$；月份不合法时，如果月份个位为 $2$ 则把月份改为 $12$，否则就把月份十位改为 $0$，答案为 $1$。

$4.$ $1≤$ 日期 $≤28$，此时若月份合法则不需修改，答案为 $0$，否则仅用一步即可把月份改合法，答案为 $1$。

综上所述，在合并一些情况后，我们可以得到如下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,d;
int main()
{
    //scanf("%d-%d",&m,&d);
    if(d>0&&d<=28)
    {
        if(m>0&&m<=12)cout<<0;
        else cout<<1;
    }
    else if(d==29||d==30)
    {
        if(m==2||m==0||m>12)cout<<1;
        else cout<<0;
    }
    else if(d==31)
    {
        if(m==1||m==3||m==5||m==7||m==8||m==10||m==12)cout<<0;
        else if(m==2||m==4||m==6||m==9||m==11||m>=13&&m<=19)cout<<1;
        else if(m%10==4||m%10==6||m%10==9)cout<<2;
        else cout<<1;
    }
    else if(m==0||m>12)cout<<2;
    else cout<<1;
} 
 
```

~~我大括号喜欢换行别说我~~

(10月6日修改)

(3月20日修改)

---

## 作者：　　　吾皇 (赞：50)

### 分析
由于一年最多只有365天，可以考虑暴力搞出所有合法日期，然后一个一个求出需要改变的数的个数并求其最小值。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int month[13]= {0,31,28,31,30,31,30,31,31,30,31,30,31},top,ans=5,sum;//先把每个月的天数储存，ans代表最终答案，sum代表当前日期需要改变量
string zh(int x) {//将数字转化为string类型
	string ans="";
	if(x<10) ans="0",ans+=char(x+'0');//如果一位数直接弄
	else while(x) {//两位数
			ans=char(x%10+'0')+ans;
			x/=10;
		}
	return ans;
}
string s,p[366];
int main() {
	cin>>s;//读入题中所给日期
	for(register int i=1; i<=12; i++)
	    for(register int j=1;j<=month[i];j++) p[++top]=zh(i)+'-'+zh(j);//将一年的所有日期存入数组p中
	for(register int i=1;i<=365;i++){
		sum=0;//先清零
		for(register int j=0;j<5;j++) if(p[i][j]!=s[j]) sum++;//如果不一样代表这里要改动，sum值+1 
		ans=min(ans,sum);//求最小值
	}
	printf("%d",ans);
}
```


---

## 作者：ikunTLE (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P5690)

### 思路

这道题是一道**分类讨论**题。

首先对月的数字进行更改。如果 $\text{MM}$ 是 $1$ 到 $12$ 中的一个数字，那么月份不用更改。如果不满足要求，答案需要增加一次更改，然后继续分类讨论。
- 如果 $\text{MM}$ 的十位为 $1$ 或个位为 $0$，那么将 $\text{MM}$ 变为 $10$。这样做可以将 $\text{DD}$ 最大化为 $31$。
- 如果 $\text{MM}$ 的个位数是 $2$，那么将 $\text{MM}$ 变为 $12$。不将 $\text{MM}$ 变为 $2$ 的理由同上，因为 $12$ 月比 $2$ 的日期多，$\text{DD}$ 的更改次数可以减少。
- 否则将 $\text{MM}$ 变为它的个位所对应的月份，因为这是唯一可以只更改一位的解法。

既然月已经处理好了，对于天来说，如果它为 $0$ 或者它比当前月份的天数大，那么将十位改为 $1$ 可以解决所有关于天的问题，答案需要增加一次更改。

最后输出统计答案的次数即可。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int MON[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int main(){
	int m=read(),d=read(),ans=0;
	if(m>12||m<=0){
		++ans;
		if(m/10==1||m%10==0)
			m=10;
		else if(m%10==2)
			m=12;
		else m%=10;
	}
	if(d<=0||d>MON[m])
		++ans;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Cure_Wing (赞：11)

### 题目简述
找出一个合法的日期，使修改日期的位数最少。
### 解法
万物皆可模拟/枚举。  
我们可以枚举正确的月份（$1$~$12$），先计算每个月份不同需要修改的数字个数，然后根据月份再来计算两个日期的不同数字个数，相加的和就是要修改的数字个数，最终的答案就取这些数中的最小值。此方法可以得满分。  
#### 贴 AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,d,ans=1023456789,sum;//ans定的大一点，因为一会儿取的是最小值
int pd(int a,int b){//计算两个日期有几个位置不相同
	return 2-(a/10==b/10)-(a%10==b%10);//(a/10==b/10)比较十位是否相同，(a%10==b%10)比较个位
    //最后用2减去这两个值就得到不同位数个数。
}
int date(int x){//求x月有几天
	if(x==2) return 28;//二月有28天（题目中说二月统一28天）
	if(x==4||x==6||x==9||x==11) return 30;//其中4，6，9，11月有30天
	return 31;//其余月份有31天
}
int main(){
	scanf("%d-%d",&m,&d);
	for(int i=1;i<=12;++i){//枚举正确的月份
		sum=pd(i,m);//清空，将月份的修改次数录入
		if(d<=0||date(i)<d) ++sum;//如果日期不合格（超出月份限制），则修改第一位为1
		ans=min(sum,ans);//取修改次数最小值
	}
	printf("%d\n",ans);
	return 0;
}
```
这里再说一种以前过得去但现在过不去的做法：  
我们知道，标准的月份是在 $1$~$12$ 之间，日期在 $2$ 月份时是 $28$ 天；$4$,$6$,$9$,$11$ 月是 $30$ 天，其余月份是 $31$ 天，那么我们只要判断月份和日期是否在范围之内就行了：
#### 这种思想的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,d;
int main(){
	scanf("%d-%d",&m,&d);
	printf("%d\n",(m>12||m<=0)+((d>31||d<=0)||(m==2&&d>28)||((m==4||m==6||m==9||m==11)&&(d>30))));//判断是否在范围以内
    //首先判断月份是否超出范围（1~12）
    //接下来判断若月份为2月则日期在（1~28）之间
    //若月份为4，6，9，11，则日期在（1~30）之间
    //其他月份则日期在（1~31）之间
	return 0;
}
```
提交上去后可以发现，WA 了 #1,#7 $2$ 个点，为什么呢？  
举一个反例：输入 44-31，正确输出 $2$，程序输出 $1$。  
但按照这个思想，日期正确，不用统计。但是如果只修改一位月份是不够的，因为 $4$ 月没有 $31$ 天，所以要修改两位。  
有什么问题评论区留言哦！

---

## 作者：Eason_AC (赞：10)

## Content
Alice 在纸上写下了一个日期，形式为 $\text{MM-DD}$，其中 $\text{MM}$ 与 $\text{DD}$ 都是两位数字，分别表示月和天，然而这个日期并不一定存在。Alice 找来了 Bob 要他更改若干位上的数字，使得这个日期存在。请你帮 Bob 算算他最少需要更改几位数字。

**本题默认 2 月 28 天。**
## Solution
分离 $\text{MM}$ 和 $\text{DD}$ 的两个数位，然后枚举一年 $365$ 天的所有日期，看修改成哪个日期修改的次数最小即可，足以通过此题。
## Code
```cpp
const int month[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int main() {
	int a, b, ans = 10;
	scanf("%d-%d", &a, &b); //利用 scanf 按格式输入的特性
	F(int, m, 1, 12) F(int, d, 1, month[m]) {
		int a1 = a / 10, a2 = a % 10, b1 = b / 10, b2 = b % 10;
		int m1 = m / 10, m2 = m % 10, d1 = d / 10, d2 = d % 10;
		ans = min(ans, (a1 != m1) + (a2 != m2) + (b1 != d1) + (b2 != d2));
	}
	return println(ans), 0;
}
```

---

## 作者：4041nofoundGeoge (赞：5)

时隔 $5$ 年终于开题解了！

## 题目大意

给你一个日期，格式为 $\text{MM-DD}$，问需要进行至少多少次操作，可以使 $\text{MM-DD}$ 成立。

## 思路 $1$

我们可以枚举 $365$ 天，每一天的日期，看哪一天改的次数最少。这是我完善[这篇题解](https://www.luogu.com.cn/article/1g3is4bu)写的。

```cpp
#include<bits/stdc++.h>
using namespace std; 
const int month[13] = {0, 31, 28, 31, 30,
 31, 30, 31, 31, 30, 31, 30, 31};
int ans=10;
int main() {
	int a,b;
	cin>>a;
	getchar();
	cin>>b;//奇妙的特性
	for(int i=1;i<=12;i++){
		for(int d=1;d<=month[i];d++){
			int a1 = a / 10, a2 = a % 10, b1 = b / 10, b2 = b % 10;
			int m1 = i / 10, m2 = i % 10, d1 = d / 10, d2 = d % 10;
			ans = min(ans, (a1 != m1) + (a2 != m2) + (b1 != d1) + (b2 != d2));//即不知道就加一 
		}
	}
    cout<<ans;
  	return 0;
}
```

## 思路 $2$

我们可以找出错误，并改正即可。

1. 我们先看月份不合法：

   - 为 $\overline{a2}$、$\overline{a1}$、$\overline{a0}$ 三种情况，只改一次即可满足条件。

   - 为 $\overline{ab}(b>2,a\ge3)$ 这些总次数必须大于等于 $2$。

2. 我们再看日期不合法：

   - $\text{DD}>31$，改成对应月份的合法日期即可，一次足够，二月份直接改十位数。
   - $\text{DD}=31$，月份不对直接改月份即可。看情况改即可。
   - 最后一种比较特殊，就是二月，我们不改日期，把二月改成三月即可。

     - 如果 $\text{DD}>31$，直接改成 $27$ 就结束了。

---

## 作者：无钩七不改名 (赞：5)

~~一种依旧暴力但独特的写法。~~

其中 $ans_i$ 表示当月份为 $i(1\le i\le 12)$ 时最少需要多少步数。

先判断 $mm$ 的个位数是否等于 $i$ 的个位数，不相等则让 $ans_i$ 自增 $1$。十位数同理。

然后判断 $dd$ 是否超过月份 $i$ 所有的天数，如果是，则让 $ans_i$ 自增 $1$（因为只需要把十位数改成 $0$ 就一定不会超过）。

最后输出 $\min\limits_{1\le i\le 12}(ans_i)$ 。

看代码应该很容易理解。

```cpp
#include<bits/stdc++.h>
using namespace std;

int m,c,ans[15],res=4;
char d;

int main(){
    scanf("%d %c%d",&m,&d,&c);
    for(int i(3);i<=9;i++){
    	if(m%10==i){
    		if(m!=i)ans[i]=1;
		}
		else{
			if(m/10==0)ans[i]=1;
			else ans[i]=2;
		}
	}
    if(m%10==0){
    	if(m!=10)ans[10]=1;
	}
	else{
		if(m/10==1)ans[10]=1;
		else ans[10]=2;
	}
    if(m%10==1){
    	if(m!=11)ans[11]=1;
    	if(m!=1)ans[1]=1;
	}
	else{
		if(m/10==1)ans[11]=1;
		else ans[11]=2;
		if(m/10==0)ans[1]=1;
		else ans[1]=2;
	}
	if(m%10==2){
    	if(m!=12)ans[12]=1;
    	if(m!=2)ans[2]=1;
	}
	else{
		if(m/10==1)ans[12]=1;
		else ans[12]=2;
		if(m/10==0)ans[2]=1;
		else ans[2]=2;
	}
	if(c>28){
		if(c>30){
			ans[4]++;
			ans[6]++;
			ans[9]++;
			ans[11]++;
			if(c>31){
				ans[1]++;
				ans[3]++;
				ans[5]++;
				ans[7]++;
				ans[8]++;
				ans[10]++;
				ans[12]++;
			}
		}
		ans[2]++;
	}
	for(int i(1);i<=12;i++)res=min(res,ans[i]);
    printf("%d",res);
    return 0;
}
```


---

## 作者：zouchenjun (赞：2)

### **题意**
给你一个日期，更改数字，使得这个日期存在需要改的最少次数。 


---


### **思路**
如果月份错误，答案增加 $1$，把十位改成 $0$，但 $2$ 结尾的除外，改成 $12$。       
如果日期错误，答案增加 $1$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int ans=0,mo[13]{0,31,28,31,30,31,30,31,31,30,31,30,31};
	int a,b;scanf("%d-%d",&a,&b);
	if(a>=13||a==0){
		ans++,a%=10;
		if(a==0)a=10;
		if(a==2)a=12;//2结尾改成12
	}
	if(b>mo[a])ans++;
	cout<<ans;
	
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

一眼分讨，但是本人最讨厌分讨了，怎么办呢？

直接考虑暴力枚举所有可能的日期，然后与输入的字符串判断有多少位不同即可。

时间复杂度为 $O(1)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
bool Begin;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
string s;
int n = 12, ans = 1e9;
int a[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
inline void check(string t){
	if(s.size() != t.size())
	  return ;
	int sum = 0;
	for(int i = 0; i < (int)s.size(); ++i)
	  if(s[i] != t[i])
	    ++sum;
	ans = min(ans, sum);
}
bool End;
int main(){
	cin >> s;
	for(int i = 1; i <= n; ++i){
		string now;
		if(i < 10)
		  now = "0";
		else
		  now = "";
		now += to_string(i);
		now += "-";
		for(int j = 1; j <= a[i]; ++j){
			string t;
			if(j < 10)
			  t = "0";
			else
			  t = "";
			check(now + t + to_string(j));
		}
	}
	write(ans);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：songge888 (赞：2)

### 题意
给一个日期 $\texttt{MM-DD}$，每次可以改其中一位，求使日期合法的最小修改次数。
### 思路
`if` 题，注意特判。
- $2$ 月只有 $28$ 天。
- $31$ 天的月份有 $1,3,5,7,8,10,12$。
- $30$ 天的月份有 $4,6,9,11$。
### Code
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int d,m;
    scanf("%lld-%lld",&m,&d);
    if(d==29||d==30){
        if(m!=2&&m>0&&m<=12){
        	cout<<0;
        	return 0;
		}
        cout<<1;
        return 0;
    }
    if(d>0&&d<=28){
        if(m>0&&m<=12){
        	cout<<0;
        	return 0;
		}
        cout<<1;
        return 0;
    }
    if(d==31){
        if(m==2||m==4||m==6||m==9||m==11||m>=13&&m<=19){
        	cout<<1;
        	return 0;
		}
		if(m==1||m==3||m==5||m==7||m==8||m==10||m==12){
        	cout<<0;
        	return 0;
		}
        if(m%10==4||m%10==6||m%10==9){
        	cout<<2;
        	return 0;
		}
        cout<<1;
        return 0;
    }
    if(m==0||m>12){
    	cout<<2;
    	return 0;
	}
    cout<<1;
    return 0;
}
```

---

## 作者：GreenMelon (赞：1)

CSP-S 最简单的一道题。

先考虑 $n$，当 $m$ 大于 $28$ 时，考虑 $n$ 是否等于 $2$，是的话就改一位数字。否则不变。

当 $m$ 是 $31$ 的时候，$n$ **不能**等于 $2,4,6,9,11$ 月中的任何一个数，是的话就得改一位数，不是就不用改。特别的，当 $n \bmod 10$ 等与 $4,6,9$ 中的任何一个数，且 $n$ 大于 $10$，你就得修改两位数。因为即使你改变了十位，你的个位还是不合法的。

其中 $m$ 是 $29$ 或 $30$ 时也得判断，因为 $n$ 可能等于 $2$ 或 $0$ 或大于 $12$。

再来看 $m$。

$m$ 只要不超过 $31$，等于 $0$ 就行，否则改一位数。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
	int n, m;
	scanf("%d-%d", &n, &m);
	if(m>0 && m<=28){
		if(n>=1 && n<=12) cout<<0;
		else cout<<1;
	}
	else if(m==29 || m==30){
		if(n==0 || n==2 || n>12) cout<<1;
		else cout<<0;
	}
	else if(m==31){
		if(n==1 || n==3 || n==5 || n==7 || n==8 || n==10 || n==12) cout<<0;
		else if(n==2 || n==4 || n==6 || n==9|| n==11 || (n>=13&&n<=19)) cout<<1;
		else if(n%10==4 || n%10==6 || n%10==9) cout<<2;
		else cout<<1;
	}
	else if(n==0 || n>12)cout<<2;
	else cout<<1;
}
```

---

## 作者：Malkin_Moonlight (赞：1)

我才发现题解通道开了，赶紧来写题解。

## Knowledge

考察用 `if` 语句来判断。

## Summary

给你一个 $\text{MM-DD}$ 形式的日期，求最少改动多少位，使得日期合法。

## Solution

先依靠常识写出每个月的日期，放在一个数组里，后面可以快速表示每个月的日期。

我们只需要来看看那些情况是需要改动的即可。

1. 日期或月份为 $0$。
2. 日期大于该月份的日期，这时候就可以用刚才的那个数组了（如 $12$ 月共 $31$ 天，超过 $31$ 天就是不合法的日期）。
3. 月份大于 $12$。

一旦符合以上要求的其中一个，将计数变量 $ans$ 加上 $1$，最后输出 $ans$ 即为答案。

代码就不给了，希望以上内容可以给大家帮助，谢谢大家。

---

## 作者：qhr2023 (赞：1)

## soltion

暴力枚举一年的每一天，找出将给定日期修改成合法日期的最少次数即可，何苦写分类讨论折磨自己。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, d, ans=3, p[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int main () { 
	scanf("%d-%d",  &m, &d);
	for (int i=1; i<=12; ++i)
		for (int j=1; j<=p[i]; ++j) 
			ans=min(ans, (m%10!=i%10)+(m/10!=i/10)+(d%10!=j%10)+(d/10!=j/10));
	cout << ans;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5690)

---
### 解题思路：
到底要改几位数字，就分为了两种情况。

- 看月份。月份不在正确区间内，就去更改成正确的月份。
- 看日期。日期不在正确区间内，就去更改成正确的日期。

---

### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a, b, ans = 0;

int main() {
	scanf("%d-%d", &a, &b);
	if ((a == 2 && b >= 29) || ((a == 4 || a == 6 || a == 9 || a == 11) && b >= 31) || b >= 32) ans++;
	if (a > 12 || a <= 0) ans++;
	if (a > 12 && (a % 10 == 4 || a % 10 == 6 || a % 10 == 9 || a % 10 == 11) && b >= 31) ans++;
	cout << ans;
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：1)

题解：[P5690 [CSP-S2019 江西] 日期
](https://www.luogu.com.cn/problem/P5690)
#### 题意：
给你一个日期，分别表示月和天，要求你求出使得这个日期合法的最小改变次数。
#### 思路：
这里给出一种思路：

**暴力思路**：\
    我们发现，这里的数据范围非常小，所有我们可以直接预处理出所有的**合法日期**，然后在**所有的合法日期中取最小值即可**。
   
   优点：思路简单，容易实现。\
   缺点：时间复杂度太高。
#### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2e5 + 5;
struct Edge { // 存储合法日期
    string M, D;
} Dat[N];
int Mon[N] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 每个月份的天数
int idx = 0;
int get(Edge a, Edge b) { // 算出花费
    int ans = 0;
    for (int i = 0; i < a.M.size(); ++i) 
        if (a.M[i] != b.M[i]) ++ans;
    for (int i = 0; i < a.D.size(); ++i)
        if (a.D[i] != b.D[i]) ++ans;
    return ans;
}
void init() {
    for (int i = 1; i <= 12; ++i) {
        for (int j = 1; j <= Mon[i]; ++j) {
            string s = ((j < 10) ? ("0") : (""));
            s += to_string(j);
            string t = ((i < 10) ? ("0") : (""));
            t += to_string(i);
            Dat[++idx] = {t, s};
        }
    }
}
int main()  {
    string date; // 输入的日期。
    cin >> date; 
    // 注意输入的日期中带有一个 -。
    string Month, Day;
    for (int i = 0; i < 5; ++i)  {
        if (i == 0 || i == 1) Month += date[i];
        else if (i != 2) Day += date[i];
    }
    int ans = 100;
    init(); // 预处理
    for (int i = 1; i <= idx; ++i) { 
        Edge Da = {Month, Day};
        ans = min(ans, get(Da, Dat[i]));
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：xyx404 (赞：1)

## 思路：
首先依据常识写出每月的天数。

然后考虑怎么修改最小。

先考虑 $M$ 的修改。

为了使修改次数最小我们应尽可能的在 $M$ 这个月份不存在时在保证修改次数最小的情况下将他修改成每月天数尽可能多的月份。

依据这个思路 $M$ 的修改可以分为两种情况。
1. 月份为 $0$，我们可以将 $M$ 修改为 $1$，因为 $1$ 月有 $31$ 天，且在月份为 $0$ 时只用修改一次。
2. 月份大于 $12$ 时，又可以分为两种情况：当 $M$ 是十的倍数时，把月份修改成 $10$，因为 $10$ 月有 $31$ 天，且当 $M$ 是十的倍数时，月份日期的第二个字符一定是 $0$，由此只用修改一次；当 $M$ 不是十的倍数时，又可以分情况，当第二个字符也就是个位为 $1$ 或 $2$ 时，实际上是可以修改第一个字符为 $1$，但是要依据上面的思想“这个月份不存在时将他修改成每月天数尽可能多的月份”由此当月份为 $11$ 时修改成 $1$ 月更优，因为 $11$ 月有 $30$ 天而 $1$ 月有 $31$ 天并且都只要修改一次，对于个位不为 $1$ 或 $2$ 的其它情况，为了保证修改次数最小可以只保留个位，只需要修改一次就是把第一个字符修改成 $0$，例如月份为 $25$，修改后为 $05$，也就 $5$ 月。

接着考虑 $D$ 的修改。

考虑到每个月份都至少有 $19$ 天，因此在这个日不存在时，可以把它的第一个字符修改成 $1$，例如 $56$ 修改后为 $16$。



## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define itn int
#define ull unsigned long long
int m,d;
char ch;
int myts[14]={0,31,28,31,30,31,30,31,31,30,31,30,31,0};// 每月天数 
int main(){
	cin>>m>>ch>>d;
	int ans=0;
	if(m==0)ans++,m=1;
	if(m>12){
		ans++;
		if(m%10==0)m=10;
		else m=(m%10==2?10+m%10:m%10);
	}
	if(d>myts[m]||d==0){
		ans++;
		d=d%10+10;
	}
	cout<<ans;
	return 0;
}



```

---

## 作者：hbdcsd (赞：0)

## 思路

将输入的日期分成月和日分别统计。

- 对于月份，首先判断输入是否合法。如果输入合法，则改变的总数 $ans$ 不变，否则将月份的首位改成 $0$，合法，将 $ans+1$；
- 对于日期，开一个数组存储每一个月份的天数以便判断合法。如果天数合法，$ans$ 不变，否则将天数的首位改成 $1$，合法，$ans+1$。

一些细节写在注释里了。

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <string>
#include <cstring>
using namespace std;
typedef long long ll;
int month, day, ans, days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};//存储每月天数的数组
int main(){
	cin >> month;
	getchar();
	cin >> day;
	if (month == 0) ans++, month = 1;//特判 month == 0，此时将 month 改为 1
	else if (month > 12 || month < 1){
		ans++;
		month %= 10;//使用改过的月份进行后续计算
		if (month == 0) month = 10;//特判模等于 0 的情况
		if (month == 2) month = 12;
        //注意！这里有坑，12 月份的天数比 2 月份多，所以可能改成 2 月份天数不合法，而改成 12 月份合法
	}
	if (day > days[month]) ans++;//判断天数 
	cout << ans;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

说句实话，这题根本就不用找什么规律，你照样把一年内的天数按照题目输入的格式存下来，在一个一个的枚举日期，找出修改次数，取最小值即可。

在存日期的时候，请注意以下几点：

- 字符串不能直接复制 `char` 类型的变量。
- 当这个数字小于 $10$ 的时候，要在数字前面补一个 $0$。

剩下的就很容易了，代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+10;
int day[]={0,31,28,31,30,31,30,31,31,30,31,30,31};//先把每个月的天数记录一下 
string num[maxn];//存日期的数组
int cnt=0; //看一共有几个日期
string int_to_str(int number)
{
	string a="";
	if(number<10)//小于10就要补0
	{
		a="0";//我们一开始就补0，方便
		a+=char(number+'0');//加上这个数字
		return a;//直接返回
	}
	while(number>0)
	{
		a=char((number%10)+'0')+a;//把每一位取出来，因为是从低位往高位取，所以要放在前面
		number/=10;
	}
	return a;
}
signed main()
{
	string n;
	cin>>n;
	for(int yue=1;yue<=12;yue++)//枚举月份 
	{
		for(int j=1;j<=day[yue];j++)//枚举第x个月的天数，把这一天按照题目中的格式存储下来 
		{
			cnt++;
			num[cnt]=int_to_str(yue)+"-"+int_to_str(j);//按格式存
		}
	}
	int mini=0x3f3f3f3f;//先赋值为最大值
	for(int i=1;i<=365;i++)
	{
		int f=0;
		for(int j=0;j<n.size();j++)
		{
			if(num[i][j]!=n[j])//如果与格式不一样
			{
				f++;//统计个数
			} 
		}
		mini=min(mini,f);//取个最小值
	}
	cout<<mini;
	return 0;
} 
```

---

## 作者：Loyal_Soldier (赞：0)

### 思路
我们可以分情况讨论，如果符合最终答案则加一，则可以为一下情况：
1. 是二月而天数大于 $28$ 。
2. 要改为小月或本身就是小月而天数大于 $30$ （要改为小月的条件是月数大于 $12$ 且个位是小月）。
3. 要改为大月或本身就是大月而天数大于 $31$ （要改为大月的条件是月数大于 $12$ 且个位是大月）。
4. 月数大于 $12$ 。
5. 月数等于 $0$ 。
6. 天数等于 $0$ 。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;//ans为最终答案
int main() {
	int a,b;
	char c;
	cin>>a>>c>>b;
	if(a==2&&b>28)//特判二月
		ans++;
	if(a%10==4||a%10==6||a%10==9||a==11)//判断是否要改为小月和判断是否本身是小月
		if(b>30)//判断天数是否大于30，因为小月最多30天
			ans++;
	if(a%10==1||a%10==3||a%10==5||a%10==7||a%10==8||a%10==0||a==12)//判断是否要改为大月和判断是否本身是大月
		if(b>31)//判断天数是否大于31，因为大月最多31天
			ans++;
	if(a>12)//判断月数是否大于12，因为一年只有12个月
		ans++;
	if(a==0)//判断月数是否为0
		ans++;
	if(b==0)//判断天数是否为0
		ans++;
	cout<<ans;
	return 0;
}
```

---


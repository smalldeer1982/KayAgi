# 【深基2.例12】上学迟到

## 题目描述

学校和 yyy 的家之间的距离为 $s$ 米，而 yyy 以 $v$ 米每分钟的速度匀速走向学校。

在上学的路上，yyy 还要额外花费 $10$ 分钟的时间进行垃圾分类。

学校要求必须在上午 $\textrm{8:00}$  到达，请计算在不迟到的前提下，yyy 最晚能什么时候出门。

由于路途遥远，yyy 可能不得不提前一点出发，但是提前的时间不会超过一天。

## 说明/提示

对于 $100\%$ 的数据，$1 \le s,v \le 10^4$。

## 样例 #1

### 输入

```
100 99```

### 输出

```
07:48```

# 题解

## 作者：C171501 (赞：674)

题目上给出路程与速度，即可算出时间。

由于s与v中的时间单位为分，所以我们直接将$8$小时换算成分钟（直接$8*60$好了）。

由于时间可能大于$1$天，我们在求出来的分钟数中加上$24*60$。

当我们把该时间减去行走时间和垃圾分类后，判断剩下的时间是否大于一天，如果大于一天就减去一天的时间，但你必须向上取整，不然行走时间就会少。

将剩下的时间除以$60$得到出发时。将剩下的时间对$60$取余得出发分。

我大概就是这样想的。上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
double s,v,m;
int n,a,t,b;
int main()
{
	cin>>s>>v;
	n=8*60+24*60;//两天总共的分钟数
	t=ceil(s/v)+10;//ceil()很重要，向上取整，否则按C++逻辑会向下取整导致行走时间少。
	n=n-t;//得出剩下的时间。
	if(n>=24*60) n-=24*60;判断是否在前一天。
	b=n%60;//得出出发分。
	a=n/60;//得出出发时
	if(a<10)//慢慢判断是否补0
	{
		if(b<10) cout<<"0"<<a<<":0"<<b;
		else cout<<"0"<<a<<":"<<b;
	}
	else
	{
		if(b<10) cout<<a<<":0"<<b;
		else cout<<a<<":"<<b;
	}
	return 0;
}
```
第二次写题解，有错请包涵。

补充：早上没睡醒，初稿出现错误，已修正，感谢@[_mliy](https://www.luogu.com.cn/user/222223)

---

## 作者：望庐山瀑布 (赞：276)

没有人发Java题解，那么我~~首当其冲~~来给大家发一个Java的题解。

首先我们要知道，用于操控时间的除了最常用的 **Date** 类，还有 
- **方便日期运算的 Calendar 类**，
- **拥有许多国家标准时间的 GregorianCalendar 类( Calendar 子类)**。

这么一看，这道题使用起来比较方便的就是 **Calendar 类**。

Calendar 类中用一下这些常量表示不同的意义，jdk 内的很多类其实都是采用的这种思想。
- Calendar.YEAR			 _——年份_ 。
- Calendar.MONTH		 _——月份_ 。
- Calendar.DATE			 _——日期_ 。
- Calendar.DAY_OF_MONTH	 _——日期，和上面的字段意义相同_ 。
- Calendar.HOUR			 _——12小时制的小时_ 。
- Calendar.HOUR_OF_DAY	 _——24小时制的小时_ 。
- Calendar.MINUTE		 _——分钟_ 。
- Calendar.SECOND		 _——秒_ 。
- Calendar.DAY_OF_WEEK	 _——星期几_。 

**用于操作时间：**
  ```java
Calendar c1 = Calendar.getInstance();
  c1.add(Calendar.DATE, 10); 
 c1.add(Calendar.DATE, -10); //把c1对象的日期加上-10，也就是c1所表的日期的10天前的日期，其它所有的数值会被重新计算。
```

 其他字段属性的add的意义以此类推。
 
 

------------

这样一来，其他题解中说的那些坑也就减少了很多。比如说就不用考虑天数的问题了，Java自己帮你处理了。

------------

还是以往的套路，相对于其他语言来说稍微麻烦一点点的，使用 Scanner 的对象进行输入。使用 Scanner 类时需要

```java

Scanner scanner = new Scanner(System.in);
int s = scanner.nextInt(); //路程。
int y = scanner.nextInt(); //速度。
    
```

之后再用 **Calendar类** 实例进行实践操作。

```java
Calendar date = Calendar.getInstance(); //创造 Calendar 类实例。
date.set(2021, Calendar.MAY, 5, 8, 0, 0); //设置时间(不设置默认为计算机当前时间。)
```

------------

上面那一句对应 Calendar 类中函数 。
```java
public final void set(int year, int month, int date, int hourOfDay, int minute,int second)
```
------------
```java
date.add(Calendar.MINUTE, s % y == 0 ? -(s / y) : -(s / y) - 1); // 使用三目运算符。因为如果路程不能整除速度的话需要再使用一分钟填满。
```



------------
之后再使用 **SimpleDateFormat 进行时间格式化**再输出。


- yyyy：年。
- MM：月。
- dd：日 。
- hh：1~12 小时制 (1-12)。
- HH：24 小时制 (0-23)。
- mm：分。
- ss：秒。
- S：毫秒。
- E：星期几。
- D：一年中的第几天。
- F：一月中的第几个星期(会把这个月总共过的天数除以 7)。
- w：一年中的第几个星期。
- W：一月中的第几星期(会根据实际情况来算)。
- a：上下午标识。
- k：和HH差不多，表示一天 24 小时制 (1-24)。
- K：和hh差不多，表示一天 12 小时制 (0-11)。
- z：表示时区。

这里只需要输出 小时:分钟，所以格式化的格式为：HH:mm
```java
SimpleDateFormat format = new SimpleDateFormat("HH:mm"); //创造格式化 HH:mm 的 SimpleDateFormat 对象。
```

最后在输出的时候要将 **Calendar 类**转换为**长整型**输出，否则会报错。

而日期类都可以转换成长整型( long )格式，所以：

```java
System.out.println(format.format(date.getTime())); // getTime()获得长整形时间
```



------------


### 完整代码
```java
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int s = scanner.nextInt();
        int y = scanner.nextInt();
        Calendar date = Calendar.getInstance();
        date.set(2021, Calendar.MAY, 5, 8, 0, 0);
        date.add(Calendar.MINUTE, -10);
        date.add(Calendar.MINUTE, s % y == 0 ? -(s / y) : -(s / y) - 1);
        SimpleDateFormat format = new SimpleDateFormat("HH:mm");
        System.out.println(format.format(date.getTime()));
    }
}

```

**希望大家有所收获** _~φ(≧ω≦*)♪_  。


---

## 作者：novax (赞：152)

这道题其实不难，不需要任何高深的算法

#### 我的思路：
 
先计算出从家走到学校所需要的时间长度，再加上垃圾分类所花费的时间，得到上学前需要的总时间。

然后从8：00开始一分钟一分钟地向前模拟，直到时间为0，这样就得到了最晚出发的时间点。

#### 需要注意的是，这道题有很多坑: 

1. 当家到学校的路程不能被速度整除时，要提前一分钟，不然就会迟到；
2. 需要的时间可能会很长，可能会需要提前一天出发；
3. 时间是24小时制的；
4. 有十分钟垃圾分类的时间，不要忘了；
5. 输出的小时和分钟要输出两位，不足10的时候要补0。
#### 代码如下：
```cpp
#include <cstdio>
int main()
{
	int S;//家到学校的距离 
	int V;//行走的速度 
	scanf("%d%d",&S,&V);
	int t;
	if(S%V==0)//因为后面是从07：59开始的,所以这里的时间少一分钟 
	{
		t=S/V;
		t+=9;//垃圾分类的时间 
	}
	else
	{
		t=S/V;//时间如果不能被速度整除,就要提前一分钟出发 
		t+=10;//垃圾分类的时间 
	}
	int H;//保存出发的小时,分钟 
	int M;
	H=7;
	M=59;
	while(t!=0) 
	{
		if(M!=0)
		{
			M--;
		}
		else
		{
			if(H!=0)
			{
				H--;
				M=59;
			}
			else
			{
				H=23;
				M=59;
			}
		}
		t--;
	}
	int h1,h2;//分开保存小时，分钟的十位，个位 
	int m1,m2;
	h1=H/10;
	h2=H-(10*(H/10)); 
	m1=M/10;
	m2=M-(10*(M/10)); 
	printf("%d%d:%d%d",h1,h2,m1,m2);
}
```
~~最后说一句，这是我的第一篇题解~~

---

## 作者：Make_China_Great (赞：14)

## 思路

我们知道了路程和速度，就可以求出来时间，但由于给的数据单位是分钟，所以换算一下即可。

当我们把该时间减去行走时间和垃圾分类后，判断剩下的时间是否大于一天，如果大于一天就减去一天的时间，但你必须向上取整，不然行走时间就会少。

将剩下的时间除以 $60$ 得到出发时的时针，再将剩下的时间对 $60$ 取余得出发时的分针。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
double s,v,m;
int n,a,t,b;
int main(){
	cin>>s>>v;
	n=8*60+24*60,t=ceil(s/v)+10,n-=t;
	if(n>=24*60)n-=24*60;
	b=n%60,a=n/60;
	if(a<10){
		if(b<10)cout<<"0"<<a<<":0"<<b;
		else cout<<"0"<<a<<":"<<b;
	}
	else{
		if(b<10) cout<<a<<":0"<<b;
		else cout<<a<<":"<<b;
	}
}
```

---

## 作者：Mitchell_Dracula (赞：7)

### 题意：

给你主人公的速度以及他需要走的路程，以及已经说明了的最晚到达时间，让你求主人公最迟什么时候出门才不会迟到。

### 思路：

众所周知，有了速度和路程我们可以求出全程的**时间**，自然就可以得出答案了。
但是，有一个比较坑的点有以下几个。

- 不要忘了**垃圾分类的十分钟**。
- 时间按 **24 小时制**计算。
- 还有最坑的**取整问题**。如果时间不是整数，要**向下取整**。
  只要不被坑就行了。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double s,v,m;
int n,a,t,b;
int main(){
	cin>>s>>v;
	n=8*60+24*60;
	t=ceil(s/v)+10;
	n-=t;
	if(n>=24*60)n-=24*60;
	b=n%60;
	a=n/60;
	printf("%02d:%02d",a,b);//记住，有可能要加0
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

前置知识：如何快速地计算两个整数的除法向上取整？

我们假设要计算 $\lceil\frac{a}{b}\rceil (b \ne 0)$，只需要写成 `(a+b-1)/b` 即可。

解释：在 C++ 中，整数除法会向下取整。如果 $a$ 被 $b$ 整除，那么 `(a+b-1)/b` 的计算结果就是 $\frac{a}{b}$，而如果 $a$ 不被 $b$ 整除（这时我们需要的是 $\lfloor\frac{a}{b}\rfloor+1$），那么 $\frac{a+b-1}{b}$ 就会大于等于 $\lfloor\frac{a}{b}\rfloor+1$ 而小于 $\lfloor\frac{a}{b}\rfloor+2$，那么计算结果自然就是 $\lfloor\frac{a}{b}\rfloor+1$。

有了这些，这道题就好做了。只需要计算 $r=\lceil\frac{s}{v}\rceil+10$ 即可。

但是这道题还有一个难点，就是输出格式。输出格式让输出一个时间，不是输出一个整数。

此时如果 $r$ 被 $60$ 整除，则到达的时间是整点，那么时间的时为 $8-\frac{r}{60}$，分为 $0$。如果 $r$ 不被 $60$ 整除，则到达的时间不是整点，那么时间的时为 $8-\lceil\frac{r}{60}\rceil$，分为 $60- (r \bmod 60)$。这里 $r \bmod 60$ 代表 $r$ 除以 $60$ 的余数。

那么如果时间跨天怎么办？其实很简单，只需要把时间的时加上 $24$，输出时输出其除以 $24$ 的余数即可。

最后，别忘了特判前导零。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int s,v;
    cin>>s>>v;
    int p=(s+v-1)/v+10;
    int hh=(8-(p+60-1)/60+24)%24,mm=(p%60==0?0:60-(p%60));
    if(hh<10)cout<<0;
    cout<<hh<<":";
    if(mm<10)cout<<0;
    cout<<mm;
}
```

---

## 作者：AstralSparkle (赞：2)

# P5707 题解

欢迎来到 AstralNahida 的题解频道！

这题其实不难，需要注意的就是一些小细节而已。

根据题意计算可得上学所需的时间 $t=\lceil\frac{s}{v}\rceil+10$。

然后计算时间点，注意如果计算出来的时和分是一位数的话要在前面补 $0$。

这里稍不注意就容易 WA，所以做题之前一定要理清思路。

AC Code:
```cpp
#include <iostream>
#include <cmath>

double s, v, m;
int n, a, t, b;

int main(void) {
	std::cin >> s >> v;
	n = 8 * 60 + 24 * 60;
	t = ceil(s / v) + 10;
	n -= t;
	if (n >= 1440) {
		n -= 1440;
	}
	a = n / 60; b = n % 60;
	if (a < 10) {
		if (b < 10) {
			std::cout << 0 << a << ":0" << b;
		} else {
			std::cout << 0 << a << ":" << b;
		}
	} else {
		if (b < 10) {
			std::cout << a << ":0" << b;
		} else {
			std::cout << a << ":" << b;
		}
	}
	std::cout << '\n';

	return 0;
}
```

完结撒花！祝大家 rp++ 喵！

---

## 作者：LotleTos (赞：1)

要提前的时间就是 $\lceil s\div v \rceil +10$，如果向下取整的话，有可能到不了，保险起见用向上取整。

可以以分钟位单位计算时间。如果在上一天的话，要把分加上 $24\times 60$。最后答案的时是 $\lfloor t\div 60 \rfloor$，分是 $t \bmod 60$。

输出格式具体见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a,b;
	cin>>a>>b;
	int s=8*60;
	s-=10;//垃圾分类
	s-=ceil(a*1.0/b);//行走时间
	if(s<0){//是否在上一天
		s+=24*60;
	}
	if(s/60<10){//时的补0
		cout<<0;
		cout<<s/60;
	}
	else{
		cout<<s/60;
	}
	cout<<":";
	if(s%60<10){//分的补0
		cout<<0;
		cout<<s%60;
	}
	else{
		cout<<s%60;
	}
}
```

---

## 作者：Iron_Spade (赞：1)

## Solution

- 前置知识：顺序结构、取模。

给定路程 $s$ 和速度 $v$，由公式 $s=vt$ 可算出需要走的时间 $t$。

由于我们要在一个整分钟时刻出发，所以我们计算时间时需要对分钟向上取整。

又因为时间可能会提前到前一天，所以我们首先对 $8:00$ 这个时刻加上一天，然后减去需要的时间即为答案，注意这样我们最后还需要对一天的时间取模，因为可能不需要提前到前一天。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
double s,v,m;
int n,ans1,ans2,t;
double read() {
	int x = 0,f = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x *= 10,x += c - '0';
		c = getchar();
	}
	return x * f;
}
int main() {
	s = read();
	v = read();
	n = 8 * 60 + 24 * 60;
	t = ceil(s / v) + 10;
	n -= t;
	if(n >= 1440) n -= 1440;
	ans1 = n % 60;
	ans2 = n / 60;
	if(ans2 < 10) { 
		if(ans1 < 10) cout << "0" << ans2 << ":0" << ans1;
		else cout << "0" << ans2 << ":" << ans1;
	} 
	else {
		if(ans1 < 10) cout << ans2 << ":0" << ans1;
		else cout << ans2 << ":" << ans1;
	}
	return 0;
}
```

---

## 作者：M1__ (赞：0)

# 题解：P5707 【深基2.例12】上学迟到

按题意模拟即可。

设速度为 $t$，小时为 $h$，分钟为 $m$，求得：
- $t=\left \lceil \frac{s}{v} \right \rceil +10$。

- $h=\left \lfloor \frac{\left \lceil \frac{s}{v} \right \rceil+10}{60}  \right \rfloor = \left \lfloor \frac{t}{60} \right \rfloor$。

- $m=\left \lceil \frac{s}{v} \right \rceil+10-60 \cdot \left \lfloor \frac{\left \lceil \frac{s}{v} \right \rceil+10}{60}  \right \rfloor = t-60 \cdot h$。

接下来分为 $m=0$ 和 $m \neq 0$ 的 $2$ 种情况。

- 当 $m=0$ 时，直接用 $\textrm{8:00}$ 减去总时间的小时部分。别忘了处理跨天的情况。即如果 $h<0$ 时，$h=24-|h|$。

- 当 $m \neq 0$ 时，分钟从小时借位，$h$ 此时变为 $8-1-h=7-h$。处理跨天情况同理。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
double s,v,t,h,m;
int main(){
	cin>>s>>v;
	t=ceil(s/v)+10;
	h=floor(t/60);
	m=t-h*1.0*60;
	if(m!=0){
		m=60-m,h=7-h;
		if(h<0) h=24-abs(h);
	}
	if(m==0){
		h=8-h;
		if(h<0) h=24-abs(h);
	}
	if(h>=10&&m>=10) cout<<h<<":"<<m;
	if(h>=10&&m<10) cout<<h<<":"<<"0"<<m;
	if(h<10&&m>=10) cout<<"0"<<h<<":"<<m;
	if(h<10&&m<10) cout<<"0"<<h<<":"<<"0"<<m;
	return 0;
}
```

---


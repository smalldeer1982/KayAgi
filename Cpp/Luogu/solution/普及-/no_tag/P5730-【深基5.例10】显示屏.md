# 【深基5.例10】显示屏

## 题目描述

液晶屏上，每个阿拉伯数字都是可以显示成 $3\times5$ 的点阵的（其中 `X` 表示亮点，`.` 表示暗点）。现在给出数字位数（不超过 $100$）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。

## 说明/提示

数据保证，$1 \leq n \leq 100$。

## 样例 #1

### 输入

```
10
0123456789
```

### 输出

```
XXX...X.XXX.XXX.X.X.XXX.XXX.XXX.XXX.XXX
X.X...X...X...X.X.X.X...X.....X.X.X.X.X
X.X...X.XXX.XXX.XXX.XXX.XXX...X.XXX.XXX
X.X...X.X.....X...X...X.X.X...X.X.X...X
XXX...X.XXX.XXX...X.XXX.XXX...X.XXX.XXX
```

# 题解

## 作者：SUNCHAOYI (赞：78)

每一个数字都有 $3 \times 5$ 的点阵组成，设五个数组 $ans_1 \sim ans_5$ 分别记录一个数字的五个行的构成情况，用 if 语句即可：

```
if(s[i] == '0')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "X.X";ans[2] += "X.X";ans[3] += "X.X";
}
if(s[i] == '1')
{
	ans[0] += "..X";ans[4] += "..X";
	ans[1] += "..X";ans[2] += "..X";ans[3] += "..X";
}
if(s[i] == '2')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "..X";ans[2] += "XXX";ans[3] += "X..";
}
if(s[i] == '3')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "..X";ans[2] += "XXX";ans[3] += "..X";
}
if(s[i] == '4')
{
	ans[0] += "X.X";ans[4] += "..X";
	ans[1] += "X.X";ans[2] += "XXX";ans[3] += "..X";
}
if(s[i] == '5')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "X..";ans[2] += "XXX";ans[3] += "..X";
}
if(s[i] == '6')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "X..";ans[2] += "XXX";ans[3] += "X.X";
}
if(s[i] == '7')
{
	ans[0] += "XXX";ans[4] += "..X";
	ans[1] += "..X";ans[2] += "..X";ans[3] += "..X";
}
if(s[i] == '8')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "X.X";ans[2] += "XXX";ans[3] += "X.X";
}
if(s[i] == '9')
{
	ans[0] += "XXX";ans[4] += "XXX";
	ans[1] += "X.X";ans[2] += "XXX";ans[3] += "..X";
}
```

然后每个数字的显示之间加一列 `.` 即可。

```
if(i != s.size() - 1) 
{
	ans[0] += ".";ans[4] += ".";
	ans[1] += ".";ans[2] += ".";ans[3] += ".";
}
```

---

## 作者：ZYX0716 (赞：11)

[P5730 显示屏](https://www.luogu.com.cn/problem/P5730)

## 思路：

给你一串数字，请输出其对应的 $3 \times 5$ 的点阵。

~~联系生活实际，做过电梯的都懂。~~

由于每个数字对应的点阵是**固定**的，因此本题可以使用**贪心 $+$ 暴力**解决。只需将 $0 \sim 9$ 中的所有**整数**的点阵存入数组，需要时再调用即可。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
string ans[10][5]={"XXX","X.X","X.X","X.X","XXX",
				  	 "..X","..X","..X","..X","..X",
				 	 "XXX","..X","XXX","X..","XXX",
				   	 "XXX","..X","XXX","..X","XXX",
				   	 "X.X","X.X","XXX","..X","..X",
				   	 "XXX","X..","XXX","..X","XXX",
				  	 "XXX","X..","XXX","X.X","XXX",
				   	 "XXX","..X","..X","..X","..X",
				  	 "XXX","X.X","XXX","X.X","XXX",
				  	 "XXX","X.X","XXX","..X","XXX"};
//ans数组存0~9中整数相对应的点阵。
int main(){
	cin>>n>>s;
	for(int i=0;i<5;i++){//5行。
		for(int j=0;j<n;j++){//n列。
			cout<<ans[s[j]-'0'][i];//输出对应点阵。
			if(j!=n-1)cout<<".";//输出间隔符。
		}
		cout<<"\n";//换行。
	}
	return 0;//好习惯。
}
```
有疑问随时私信哦！

---

## 作者：volatile (赞：6)

# 思路

打表即可，在数组里储存每一个数字的表示方式。

```cpp
char cnt[10][5][3] =
{
	{
		'X','X','X',
		'X','.','X',
		'X','.','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'X','.','.',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','.','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	}
};
```

可以发现不能一次性输出一个数，需要三重循环，第一层是行，第二层是遍历所有数字，第三层遍历列。

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char cnt[10][5][3] =
{
	{
		'X','X','X',
		'X','.','X',
		'X','.','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'X','.','.',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','.','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	}
};
int main()
{
	int n;
	char num[110];
	cin >> n;
	scanf("%s", num);
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < 3; k++) {
				cout << cnt[int(num[j] - '0')][i][k];
			}
			if (j != n - 1) cout << ".";
		}
		cout << endl;
	}
	return 0;
}
```

---

## 作者：Peruere_Arlecchino (赞：4)

本题很简单，我们可以先使用数组或容器来存储 $0 - 9$ 每个数字对应的 $3\times5$ 点阵样式。我这里采用二维数组 `d`，每一行对应一个数字，每一个数字由 $5$ 个长度为 $3$ 的字符串组成，分别表示该数字点阵的 $5$ 行。输出通过两层循环实现，外层循环控制输出的行数（共 $5$ 行），内层循环遍历输入的数字字符串。对于每个数字，记得输出其对应行的点阵样式，并在数字之间添加间隔`.`。
### 简单code（有注释）：
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main() {
    int n;
    string x;
    // 读取数字位数n和数字字符串x
    cin >> n >> x;

    // 定义每个数字的3x5点阵表示
    vector<string> d[10] = {
        {"XXX", "X.X", "X.X", "X.X", "XXX"},  // 0
        {"..X", "..X", "..X", "..X", "..X"},  // 1
        {"XXX", "..X", "XXX", "X..", "XXX"},  // 2
        {"XXX", "..X", "XXX", "..X", "XXX"},  // 3
        {"X.X", "X.X", "XXX", "..X", "..X"},  // 4
        {"XXX", "X..", "XXX", "..X", "XXX"},  // 5
        {"XXX", "X..", "XXX", "X.X", "XXX"},  // 6
        {"XXX", "..X", "..X", "..X", "..X"},  // 7
        {"XXX", "X.X", "XXX", "X.X", "XXX"},  // 8
        {"XXX", "X.X", "XXX", "..X", "XXX"},  // 9
    };

    // 输出每一行
    for (int row = 0; row < 5; row++) {
        for (int i = 0; i < n; i++) {
            // 将字符数字转换为整数索引，获取对应数字的点阵行
            int d = x[i] - '0';
            cout << d[dd][row];
            // 除最后一个数字外，在数字间添加间隔
            if (i < n - 1) cout << '.';
        }
        cout << endl;
    }

    return 0;
}
```
求赞求过。

---

## 作者：C_Du_Nov11 (赞：3)

# 题意

题目要求把所以输入的数在显示屏上显示出来。

# 思路

由于每个数字格式都是 $3\times5$，所以我们可以构造每个数字的每一行，在这个数字出现时输出那一行的内容。

# 代码


```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int maxn = 10005;

string fir[10] = {"XXX", "..X", "XXX", "XXX", "X.X", "XXX", "XXX", "XXX", "XXX", "XXX"}; // 第一行

string sed[10] = {"X.X", "..X", "..X", "..X", "X.X", "X..", "X..", "..X", "X.X", "X.X"}; // 第二行

string thd[10] = {"X.X", "..X", "XXX", "XXX", "XXX", "XXX", "XXX", "..X", "XXX", "XXX"}; // 第三行

string foh[10] = {"X.X", "..X", "X..", "..X", "..X", "..X", "X.X", "..X", "X.X", "..X"}; // 第四行

string fif[10] = {"XXX", "..X", "XXX", "XXX", "..X", "XXX", "XXX", "..X", "XXX", "XXX"}; // 第五行

int n, a[maxn];

inline int read() // 快读
{
	int ret = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-')
			f = -f;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
		ret = ret * 10 + ch - '0',
		ch = getchar();
	return ret * f;
}

signed main()
{
	n = read();
	for (int i = 1; i <= n; ++i)
		a[i] = getchar() - '0';	 // 由于读入的是字符，所以需要转换成数字
	for (int i = 1; i <= n; ++i) // 依次输出每一行
		if (i != n)
			cout << fir[a[i]] << ".";
		else
			cout << fir[a[i]] << endl;
	for (int i = 1; i <= n; ++i)
		if (i != n)
			cout << sed[a[i]] << ".";
		else
			cout << sed[a[i]] << endl;
	for (int i = 1; i <= n; ++i)
		if (i != n)
			cout << thd[a[i]] << ".";
		else
			cout << thd[a[i]] << endl;
	for (int i = 1; i <= n; ++i)
		if (i != n)
			cout << foh[a[i]] << ".";
		else
			cout << foh[a[i]] << endl;
	for (int i = 1; i <= n; ++i)
		if (i != n)
			cout << fif[a[i]] << ".";
		else
			cout << fif[a[i]] << endl;
	return 0;
}

```

---

## 作者：Vct14 (赞：3)

注意到每个数字都是 $5\times 3$ 的点阵，考虑把每一个数字的每一行都用一个长度为 $3$ 的字符串存储，遍历第 $i$ 行时，若当前数字需要输出，那么输出对应字符串即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

string a[10][5];
char num[102];

int main(){
	//freopen("screen.in","r",stdin);
	//freopen("screen.out","w",stdout);
	int n;
	cin>>n;
	a[0][0]="XXX";
	a[0][1]="X.X";
	a[0][2]="X.X";
	a[0][3]="X.X";
	a[0][4]="XXX";
	
	a[1][0]="..X";
	a[1][1]="..X";
	a[1][2]="..X";
	a[1][3]="..X";
	a[1][4]="..X";
	
	a[2][0]="XXX";
	a[2][1]="..X";
	a[2][2]="XXX";
	a[2][3]="X..";
	a[2][4]="XXX";
	
	a[3][0]="XXX";
	a[3][1]="..X";
	a[3][2]="XXX";
	a[3][3]="..X";
	a[3][4]="XXX";
	
	a[4][0]="X.X";
	a[4][1]="X.X";
	a[4][2]="XXX";
	a[4][3]="..X";
	a[4][4]="..X";
	
	a[5][0]="XXX";
	a[5][1]="X..";
	a[5][2]="XXX";
	a[5][3]="..X";
	a[5][4]="XXX";
	
	a[6][0]="XXX";
	a[6][1]="X..";
	a[6][2]="XXX";
	a[6][3]="X.X";
	a[6][4]="XXX";
	
	a[7][0]="XXX";
	a[7][1]="..X";
	a[7][2]="..X";
	a[7][3]="..X";
	a[7][4]="..X";
	
	a[8][0]="XXX";
	a[8][1]="X.X";
	a[8][2]="XXX";
	a[8][3]="X.X";
	a[8][4]="XXX";
	
	a[9][0]="XXX";
	a[9][1]="X.X";
	a[9][2]="XXX";
	a[9][3]="..X";
	a[9][4]="XXX";
	
	for(int i=0; i<n; i++) cin>>num[i];
	for(int j=0; j<5; j++){
		for(int i=0; i<n; i++){
			cout<<a[num[i]-'0'][j];
			if(i!=n-1) printf(".");
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：wangyang168 (赞：1)

### 思路：
很容易看出这是一道打表题，这里提供一种另外的思路。我们可以开一个三维字符数组 $w[x][y][z]$,其中 $x$ 表示每一种数字，$y$ 表示这一个数字对应点阵的行，$z$ 表示这一个数字这一行的一个字符。现在我们需要做的就是把每一个数字的点阵形式存储在这个三维字符数组中。

```cpp
char a[10][5][3]=
{
	{
		'X','X','X',
		'X','.','X',
		'X','.','X',
		'X','.','X',
		'X','X','X',
	},
  {
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'X','.','.',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','.','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	}
};
```
接着我们输入 $n$ 和自然数，把这个自然数的每一位给分解出来，根据每一位输出字符。注意：每个数之间要加上一列```.```。
```cpp
int n;
char s[110];
cin>>n;
for(int i=0;i<n;i++){
    cin>>s[i];
}
for(int i=0;i<5;i++){
    for(int j=0;j<n;j++){
			for(int k=0;k<3;k++){
				cout<<a[s[j]-'0'][i][k];
			}
			if(j!=n-1) cout<<'.';
		}
		cout<<endl;
}
``````
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[10][5][3]=
{
	{
		'X','X','X',
		'X','.','X',
		'X','.','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'X','.','.',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','.','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','.',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
		'.','.','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'X','.','X',
		'X','X','X',
	},
	{
		'X','X','X',
		'X','.','X',
		'X','X','X',
		'.','.','X',
		'X','X','X',
	}
};
int n;
char s[110];
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s[i];
	}
	for(int i=0;i<5;i++){
		for(int j=0;j<n;j++){
			for(int k=0;k<3;k++){
				cout<<a[s[j]-'0'][i][k];
			}
			if(j!=n-1) cout<<'.';
		}
		cout<<endl;
	}
	return 0;
}
``````
当然，这样的代码一定不是最优解，其他更简便的方法可以自行探究。

---

## 作者：Ashankamiko (赞：1)

# 题目简述
### 题意
给定 $n$ 个数字，输出这 $n$ 个数字所对应的放大数字，格式已经在题目中给出。
### 思路
一行一行的输出，分 $5$ 层输出数字，每次调用函数都传入当前层数，然后只需对应的输出该层应该输出的字符串即可。

代码比较长，但其实很好理解。
## [AC 代码](https://www.luogu.com.cn/record/203405191)
```cpp
#include <bits/stdc++.h>
using namespace std;
int j = 1;
//以下就是每一个数字输出的字符串
void output0(int x) {
	if (x == 5 || x == 1)
		cout << "XXX";
	else
		cout << "X.X";
}

void output2(int x) {
	if (x % 2 == 1)
		cout << "XXX";
	else if (x == 2)
		cout << "..X";
	else
		cout << "X..";
}

void output3(int x) {
	if (x % 2 == 0)
		cout << "..X";
	else
		cout << "XXX";
}

void output4(int x) {
	if (x < 3)
		cout << "X.X";
	else if (x == 3)
		cout << "XXX";
	else
		cout << "..X";
}

void output5(int x) {
	if (x % 2 == 1)
		cout << "XXX";
	else if (x == 2)
		cout << "X..";
	else
		cout << "..X";
}

void output6(int x) {
	if (x % 2 == 1)
		cout << "XXX";
	else if (x == 2)
		cout << "X..";
	else
		cout << "X.X";
}

void output7(int x) {
	if (x == 1)
		cout << "XXX";
	else
		cout << "..X";
}

void output8(int x) {
	if (x % 2 == 0)
		cout << "X.X";
	else
		cout << "XXX";
}

void output9(int x) {
	if (x % 2 == 1)
		cout << "XXX";
	else if (x == 2)
		cout << "X.X";
	else
		cout << "..X";
}

void Print(char ch) { //输出当前数字
	if (ch == '0')
		output0(j);
	else if (ch == '1')
		cout << "..X";
	else if (ch == '2')
		output2(j);
	else if (ch == '3')
		output3(j);
	else if ('4' == ch)
		output4(j);
	else if (ch == '5')
		output5(j);
	else if (ch == '6')
		output6(j);
	else if (ch == '7')
		output7(j);
	else if ('8' == ch)
		output8(j);
	else
		output9(j);
}

int main() {
	int n;
	cin >> n;
	char ch[n];
	for (int i = 0; i < n; i++)
		cin >> ch[i];
	for (; j <= 5; j++) { //5层
		for (int i = 0; i < n; i++) {
			Print(ch[i]); //输出第i层，并传入当前的数字
			if (i != n - 1) //中间记得输出'.'，末尾不输出
				putchar('.');
		}
		cout << endl;
	}
	return 0;
}
```

---


# 【深基7.例2】质数筛

## 题目描述

输入 $n$ 个不大于 $10^5$ 的正整数。要求全部储存在数组中，去除掉不是质数的数字，依次输出剩余的质数。

## 说明/提示

数据保证，$1\le n\le100$，$1 \leq a_i \leq 10^5$。

## 样例 #1

### 输入

```
5
3 4 5 6 7```

### 输出

```
3 5 7```

# 题解

## 作者：HsKr (赞：208)

UPDATE

2020-02-05 将速度是1/3改为3倍，感谢[Stay_Hungry](https://www.luogu.com.cn/user/105922)

其实不需要素数筛，不需要存入数组，一个素数判断就够了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
bool isprime(int x){//判断是否素数
	if(x<=1) return false;//如果小于2，一定不是素数
	for(int i=2;i<=sqrt(x);i++){//为什么要到sqrt(x)呢，因为如果有一个大于sqrt(n)的数可以被n整除，那么必有一个数n/i也可以被n整除且小于i
		if(x%i==0) return false;//如果可以整除，那么不是素数
	}
	return true;//是素数
}
int main(){
	int n,a;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		if(isprime(a)){
			cout<<a<<" ";//是素数，就输出
		}
	}
	return 0;
}
```

其实还可以优化，这里有一个优化的代码，速度是上面的$3$倍，可以看一看

```cpp
bool isprime(int n){
    if(n<=1) return false;
    if(n==2||n==3) return true;
    if(n%6!=1&&n%6!=5) return false;
    for(int i=5;i*i<=n;i+=6) if(n%i==0||n%(i+2)==0) return false;
    return true;
}
```

除2,3外，其他所有素数都必须是$6n+1$或$6n+5$，因为$6n+2=2(3n+1)$，$6n+3=3(2n+1)$，$6n+4=2(3n+2)$，都有非1和本身因数，不是素数

---

## 作者：sunqiwen (赞：5)

**~~「蒟蒻的第一篇题解」，不喜勿喷。~~**

# [题目传送门](https://www.luogu.com.cn/problem/P5736)

## 题目大意

由题意可知，题目会有 $n$ 个整数 $a_i$，让我们**依次**输出之中的质数，以空格隔开。

## 方法1（枚举）

对每个输入的 $a_i$ 判断是否为质数，若为质数就直接输出，否则就跳过。

从 $2$ 开始到 $\sqrt{a_i}$ 枚举：

- 若能被 $a_i$ 整除，即为合数，直接返回。

- 若枚举完毕还未返回，则为质数。

**注意数据范围**，$1 \le a_1 \le 10^5$，所以要特判 $a_i = 1$ 的情况。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110;

int n, a[maxn];
bool prime(int p) {
	if (p == 1) {
		return false;
	}
	else if (p == 2) {
		return true;
	}
	else {
		for (int i = 2; i <= sqrt(p); i++) {
			if (p % i == 0) return false;
		}
	}
	return true;
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (prime(a[i])) {
			printf("%d ", a[i]);
		}
	} 
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/221383244)



---

## 方法2（埃式筛法）

埃式筛法：根据质因数，标记所有的**合数**。

1. 先将 $isprime_n$ 数组初始化为 $false$，即全为质数。
2. 将 $isprime_0$， $isprime_1$ 修改为 $true$。
3. 从 $2$ 开始枚举，如果是质数，将**其所有的倍数**标记为合数，即 $true$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110, maxa = 100010;

int n, a[maxn];
bool isprime[maxa]; 
int main() {
	cin >> n;
	isprime[0] = isprime[1] = true;
	for (int i = 2; i * i <= maxa; i++) {
		if (!isprime[i]) {
			for (int j = i * i; j <= maxa; j += i) {
				isprime[j] = true;
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (!isprime[a[i]]) {
			printf("%d ", a[i]);
		}
	}
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/221388148)

**~~其实埃式筛法在本题中与枚举的速度差不多~~**

---

## 作者：weapons (赞：3)

### 思路
  用小于此数并大于一的整数去试除，如果又能够被它整除的，即为合数，否，即为质数。
  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6+5;
int n;
int main() {
	cin >> n;
	for(int i=1;i<=n;i++){
		int b,pan=0;//pan 记录是否为合数
		cin>>b;
		for(int j=2;j<b;j++){
			if(b%j==0){
				pan=1;//是合数
			}
		}
		if(!pan&&b!=1)cout<<b<<' ';//特判'1'
	}
	return 0;
}
```

---


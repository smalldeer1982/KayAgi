# 【深基附B例】区间最大和

## 题目描述

给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和一个整数 $m$。求出这个数列中的一个子区间 $[i, j]$，也就是在这个数列中连续的数字 $a_i, a_{i + 1}, \cdots, a_{j - 1}, a_j$，使得这个子区间的和在不超过 $m$ 的情况下最大。如果有多个区间符合要求，请输出 $i$ 最小的那一个。

## 说明/提示

**子任务 1**（10分）：$n\le 200$ ；

**子任务 2**（20分）：$n\le 3000$ ；

**子任务 3**（30分）：$n\le 10^5$ ；

**子任务 4**（40分）：$n\le 4\times 10^6$ 。

对于 $100\%$ 的数据，$1 \leq n \leq 4 \times 10^6$，$1 \leq m \leq 10^9$，$0 \leq a_1, a_2, \cdots, a_n \leq 10^5$。

## 样例 #1

### 输入

```
5 10
2 3 4 5 6```

### 输出

```
1 3 9```

# 题解

## 作者：rfsfreffr (赞：83)

## Uid 2019-12-27:修改了树状数组代码的时间复杂度的重要性

这题难度不大，但对于新手来说，不算很友好。所以我们循序渐进，慢慢来刨析这道题目

# 10分代码：

很容易想到枚举所有的$i$到$j$,再对$i$到$j$进行求和，再判断是否满足条件，满足就更新答案。

时间复杂度$O(n^3)$

## 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[4000001];
int ans1,ans2,ans3;
int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){//读入
		scanf("%d",&a[i]);
	}
	for(int i=1; i<=n; i++){
		for(int j=i; j<=n; j++){//枚举i与j
			int sum=0;
			for(int k=i; k<=j; k++){//求和
				sum+=a[k];
			}
			if(sum>ans3&&sum<=m){//如果这个答案比以前的更优，则更新答案
				ans1=i;
				ans2=j;
				ans3=sum;
			}
		}
	}
	cout<<ans1<<" "<<ans2<<" "<<ans3;//输出
}
```
# 30分代码：

因为要对区间进行求和，自然就会想到前缀和来维护。

我们记$sum_i=a_1+a_2+......+a_i$

则$a_l+a_{l+1}+......a_r=sum_r-sum{l-1}$

在读入的过程中预处理前缀和

时间复杂度：$O(n^2)$

## 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[4000001];
int sum[4000001];//用sum数组来记录前缀和
int ans1,ans2,ans3;
int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];//处理前缀和
	}
	for(int i=1; i<=n; i++){
		for(int j=i; j<=n; j++){
        int cnt=sum[j]-sum[i-1];
			if(cnt>ans3&&cnt<=m){//计算前缀和并更新答案
				ans1=i;
				ans2=j;
				ans3=cnt;
			}
		}
	}
	cout<<ans1<<" "<<ans2<<" "<<ans3;
}
```
# 60分代码:

因为所有的$a_i$都是正整数，故sum单调递增。

所以若的$sum_r-sum_{l-1}>m$,

因为$sum_{r+1}>sum_{r}$

故$sum_{r+1}-sum_{l-1}>m$

后面的$sum_{r+k}-sum_{l-1}>m$

所以就可以break了

时间复杂度:$O(n^2)$+小常数

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[4000001];
int sum[4000001];
int ans1,ans2,ans3;
int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	for(int i=1; i<=n; i++){
		for(int j=i; j<=n; j++){
        int cnt=sum[j]-sum[i-1];
			if(cnt>ans3&&cnt<=m){
				ans1=i;
				ans2=j;
				ans3=cnt;
			}
			if(cnt>m) break;//如果比m大就可以退出了，不必要继续枚举了
		}
	}
	cout<<ans1<<" "<<ans2<<" "<<ans3;
}
```

# 100分代码:

因为sum单调递增。

所以考虑枚举i，再二分确定j

时间复杂度:$O(nlogn)$

## 代码:

```cpp

#include <bits/stdc++.h>
//#include <windows.h>
using namespace std;
long long sum[4000001];
long long n,m;
long long a[4000001];
int ans1,ans2,ans3;
int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){//预处理前缀和
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	for(int i=1; i<=n; i++){
		int l=i,r=n;
		while(l<=r){//二分确定最优的j
			int mid=(l+r)/2;
			if(sum[mid]-sum[i-1]>m){
				r=mid-1;
			} else {
				l=mid+1;
			}
		}
		if(sum[r]-sum[i-1]<=m){//对于当前的i来说，这个j已经是最优的了，所以更新答案
			if(sum[r]-sum[i-1]>ans3){
				ans1=i;
				ans2=r;
				ans3=sum[r]-sum[i-1];
			}
		}
	}
	cout<<ans1<<' '<<ans2<<' '<<ans3;  
	return 0;	
}
```

# $O(n)$的做法:

关注kkksc03的人一定知道，这道题kkksc03曾经提到过!

kkk在最后给出的做法是：

>维护一个队列，让数组中的数依次入队，并记录其的元素和，若大于m,则让对首出列，更新答案，再让后面的数字继续入队，并更新答案，不断的这么操作，直到所有数字都入过队了为止。

我这里采用了STL的deque(双端队列),感兴趣的Oler们可以去了解一下

## 代码:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[4000001];
deque<int>q;
int sum=0;
int ans1,ans2,ans3;
int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){
		scanf("%d",&a[i]);
	}
	int l=1;
	for(int i=1; i<=n; i++){
		q.push_back(a[i]);//插入a[i]
		sum+=a[i];
		while(sum>m){//如果队列中的值大于m,则对队列进行维护
			q.pop_front();//弹去队首
			sum-=a[i];//更新答案
			if(sum>ans3){
				ans3=sum;
				ans2=i-1;
				ans1=l;
			}
			sum+=a[i];//维护队列中的元素的和
			sum-=a[l];
			l++;
		}
	}
	cout<<ans1<<" "<<ans2<<" "<<ans3;
}
```

# $O(nlog^2n)$的做法

还有一种做法是使用树状数组。

我们知道树状数组也能对区间进行求和，所以可以使用在之前二分的代码加上树状数组

不会树状数组也没关系，你可以去洛谷找到树状数组的模板题，对其进行学习。

## 代码:
```cpp
#include <bits/stdc++.h>
//#include <windows.h>
using namespace std;
int c[8000001];
int n,m;
int a[4000001];
int lowbit(int n){//树状数组的核心函数
	return n&(-n);
}
int add(int x,int y){//单点修改
	for(;x<=n; x+=lowbit(x)) c[x]+=y;
}
int sum(int x){//区间求和
	int ans=0;
	for(;x;x-=lowbit(x)) ans+=c[x];
	return ans;
}
int ans1,ans2,ans3;
int main(){
	cin>>n>>m;
	for(int i=1; i<=n; i++){
		scanf("%d",&a[i]);
		add(i,a[i]);
	}
	for(int i=1; i<=n; i++){//二分的步骤
		int l=i,r=n;
		while(l<=r){
			int mid=(l+r)/2;
			if(sum(mid)-sum(i-1)>m){
				r=mid-1;
			} else {
				l=mid+1;
			}
		}
		int cnt=sum(r)-sum(i-1);
		if(cnt<=m){
			if(cnt>ans3){
				ans1=i;
				ans2=r;
				ans3=cnt;
			}
		}
	}
	cout<<ans1<<' '<<ans2<<' '<<ans3;  
	return 0;	
}
```

---

## 作者：Diamiko (赞：15)

## 核心思想：双指针
### 怎样求出区间和？

可以从l到r循环一遍，累加。

但这样的时间复杂度为O(r-l+1)。

如此高的时间复杂度显然是不能接受的。

我们采用前缀和进行优化。

#### 什么是前缀和？

前缀和的第i项表示：从数列的第一项一直加到第i项的和。

用`sum[]`表示前缀和数组，用x表示我们每一个输入的值。

显然`sum[i]=sum[i-1]+x`.

举个栗子，对于以下数列：

原数列： `3,4,1,0,9`

前缀和： `3,7,8,8,17`

#### 前缀和有什么用？

利用前缀和我们就可以在O(1)时间内处理出区间和。

对于L到R的区间和，前缀和数组为sum，原数组为a，则有：

```cpp
    sum[l-1]=a[1]+a[2]+...+a[l-1];

    sum[r]=a[1]+a[2]+...+a[l-1]+a[l]+...+a[r];

    sum[r]-sum[l-1]=a[1]-a[1]+a[2]-a[2]+...+a[l-1]-a[l-1]+a[l]+a[l+1]+...+a[r];

∴  sum[r]-sum[l-1]=a[l]+...a[r];
```
那么`sum[r]-sum[l-1]`即为我们要求的区间和。

可以感性理解一下。

--------------------

### 怎么求出题目答案？

最容易想到的方法就是暴力枚举端点：

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=i+1;j<=n;j++)
	{
		...
	}
}
	
```

但显而易见，这绝对会超时。

我们采取双指针优化。

定义两个指针指向区间两个端点，初始时都为一。

只要当前区间和超过了m，就让左端点加一。

只要当前区间和大于上次区间和，就更新答案以及答案区间。

### 代码实现

```cpp
#include<cstdio>
using namespace std;
int n,m,x;
long long sum[4000005];
//前缀和数组
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        sum[i]=sum[i-1]+x;
        //预处理前缀和
    }
    long long ans=-1;
    //ans是最大值，所以一开始先赋值为-1，方便判断
    int l=1,r=1,ansl,ansr;
    //l,r为两个指针，开始都指向1
    //ansl,ansr为最终答案
    while(r<=n)
    {
        //防止越界
        while(sum[r]-sum[l-1]>m&&l<r)l++;
        //sum[r]-sum[l-1]表示l到r的区间和
        //大于m就无效，左端点加一
        //要判断l<r因为防止越界
        if(sum[r]-sum[l-1]>ans)
        {
            ans=sum[r]-sum[l-1];
            ansl=l,ansr=r;
            //更新答案
        }
        r++;
    }
    printf("%d %d %lld",ansl,ansr,ans);
    return 0;
}
```

---

## 作者：FifthAxiom (赞：10)

滑块思想：维护一个队列，里面保存一个可行的状态，遍历状态空间时，每次队尾指针挪一格，然后检查该队列是否不合法，若不合法，则挪动队头指针，直到队列再次合法，这样，我们就能遍历线性状态空间的每一个可行状态。

在本题中，我们可以运用滑块思想，合法队列定义为队列中元素和不超过$M$，可以用前缀和优化。

具体请见代码：

```cpp
#include <cstdio>

const int MAXN = 4000010;

int n, m;

long long s[MAXN];//前缀和数组

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        int x;
        scanf("%d", &x);
        s[i] = s[i - 1] + x;
    }
    int l = 1, r = 1;
    int ans = 0, ansL, ansR;
    while (r <= n) {//遍历整个序列
        while (s[r] - s[l - 1] > m && l < r) l++;//如果当前队列不合法则挪动队头指针
        if (s[r] - s[l - 1] > ans) ans = s[r] - s[l - 1], ansL = l, ansR = r;//记录最优解
        r++;//挪动队尾指针
    }
    printf("%d %d %d\n", ansL, ansR, ans);
    return 0;
}
```



---

## 作者：chufuzhe (赞：6)

看到题目，第一个想到的方法是枚举i和j，时间复杂度是O(n²)，子任务4时间复杂度就是4000000²,显然会超时。

这里介绍一种方法——尺取法。两个指针l和r，分别表示左端下标和右端下标。变量h表示左指针到右指针的和。

改变指针的条件：

(1)l>r，即左指针在右指针后，则r++,即将右指针加一，同时还要把h-=a[r]。

(2)h超过m，则l++,即将左指针加一，同时还要把h-=a[l]。

(3)其他情况，将r++,即将左指针加一，同时还要把h+=a[r]。

运用这种方法要注意，在循环结束后的值不会统计进去，还要再次判断更新。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4000005];
int main()
{
    ios::sync_with_stdio(false);
    int n,m,l,r,x,y;
    int h=0,d=0;
    cin>>n>>m;
    for(register int i=1;i<=n;i++)    //输入
    	cin>>a[i];
    l=r=1;     //一开始左右指针均为1
    x=y=0;     //一开始结果下标均为1
    h=a[1];    //一开始左指针到右指针的和为a[1]
    while(r<=n)     //循环
    {
    	if(l>r)    //第一种情况
	{
		h-=a[r];
		r++;
	}else if(h>m){    //第二种情况
   	 	h-=a[l];
 	  	l++;
	}else{    //第三种情况
		if(h>d)    //判断是否大于原来最大值
		{
			d=h;
			x=l;
			y=r;    //更新结果
		}
		r++;
		h+=a[r];
	}
    }
    if(h>d && h<=m)    //再次判断更新
    {
	d=h;
	x=l;
	y=r;
    }
    cout<<x<<' '<<y<<' '<<d<<endl;   //输出
	return 0; 
}
```

---

## 作者：若如初见 (赞：5)

## $\text{前言}$

- 第一次在洛谷 AK 比赛……
- 本来以为我的做法会被卡，没想到跑得挺快，最慢的点只用了 200 ms qwq


## $\text{Solution ：前缀和 + 二分：}$  

我们知道，要二分就必须要求题目具有**单调性**。这个单调性在本题中如何体现呢？  

首先，注意到数列中每个数都是正数，那么**对于任意两个右端点相同的区间，左端点更小的区间的和一定会更大**，这就是本题隐含的**单调性**。我们可以在读入时预处理**前缀和**，从 $1$ 到 $n$ 枚举所选区间的右端点。假设当前选出的区间的右端点为 $j$ ，那么我们要选出的左端点就落在 $[1,j]$ 中。接下来就可以二分这个左端点了。想一想看，这个左端点 $i$ 会满足怎样的性质呢？  

用一点贪心的思想，不难发现：  

$$\sum\limits_{k=i}^{j} a_k \leq m$$  

$$\sum\limits_{k=i-1}^{j}a_k>m$$  

也就是说，对于给定的 $j$ ，我们找到的 $i$ 就是使 $[i,j]$ 的区间和小于 $m$ 的最大值。 **$i$ 再往左移，就比 $m$ 大，不合法；再往右移，就不是最优解**。  

基于此，很容易写出本题正解。这道题目作为入门赛的 $\text{T1}$ 还是相当水的，其实大概只有普及组 $\text{T2}$ 难度吧。  

## $\text{Code}$

```cpp
#include <bits/stdc++.h>
#define int long long //偷懒
#define rint register int
#define MAXN 4000005
int n,m,sum[MAXN],a[MAXN],ans,nl,nr;
//sum:前缀和数组 a:原数列 ans,nl,nr:维护所求区间的信息
int read(){ //快读，卡常
	int ret=0; char ch=0;
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){
		ret=((ret<<1)+(ret<<3)+ch-'0');
		ch=getchar();
	}
	return ret;
}
signed main(){
	n=read(); m=read();
	for(rint i=1;i<=n;++i){
		a[i]=read();
		sum[i]=sum[i-1]+a[i]; //维护前缀和
	}
	if(a[1]<=m) {
		nl=nr=1;
		ans=a[1];
	}
	for(rint i=2;i<=n;++i){
		int l=1,r=i,mid;
		while(l<=r){ //二分模板
			mid=(l+r)>>1;
			if(sum[i]-sum[mid-1]<=m) r=mid-1; //不到m就左移 
			else l=mid+1; //超过m就右移
		}
		if(sum[i]-sum[l-1]>ans){ //维护答案
			ans=sum[i]-sum[l-1];
			nl=l; nr=i;
		}
	}
	printf("%lld %lld %lld",nl,nr,ans);
	return 0;
} 
```

**感谢管理员审核！！**

---

## 作者：jijidawang (赞：2)

- [题目传送门](https://www.luogu.com.cn/problem/P5745)

## 题意简述

> 给定序列 $a$，求最大连续子段和及其左右端点。

## 算法分析

双指针扫描。

每次队尾指针挪一格，然后检查该队列是否不合法，若不合法，则挪动队头指针，直到队列再次合法，求和可以用前缀和优化。

时间复杂度为 $\mathcal{O}(n)$。

**Code：**

```cpp
#include<cstdio>
#error CE
const int MAXN=4000010;
int n,m;
typedef long long ll;
ll s[MAXN];//前缀和
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)  //统计前缀和
    {int x;scanf("%d",&x);s[i]=s[i-1]+x;}
    int l=1,r=1;  //两个指针
    int ans=0,L,R;  //记录答案
    while (r<=n) //遍历整个序列
    {
        while (s[r]-s[l-1]>m&&l<r) l++;//如果当前区间不合法则挪动头指针
        if (s[r]=s[l-1]>ans) ans=s[r]-s[l-1], L=l,R=r;//记录最优解
        r++;//挪动尾指针
    }
    printf("%d %d %d\n",L,R,ans);
    return 0;
}
```

---

## 作者：Ckger (赞：1)

这道题其实可以直接用尺取法，因为所有的$a_{i}$都$\geqslant0$，因此可以直接尺取。

尺取法其实就是定义一个头指针（$front$）和一个尾指针（$rear$），再记录$front$和$rear$之间元素的和（记为$sum$）。

如果$sum>m$，并且$front$小于$rear$，就令$front+1$（因为如果$front=rear$那么头指针就会大于尾指针），因为此时$a_{front}\geqslant0$，那么$front$后移之后，$sum$必定不会增大，就可以使$sum$越来越往合法的数值靠近（$sum\leqslant m$）。

当然，如果$front=rear$，那也就不能后移$front$了，只能后移$rear$。

最后，如果$m\leqslant sum$ 且 $ans\leqslant sum$（ans即为上次记录的最大的合法的$sum$），那么就更新左端点，右端点和$ans$。


整体的思路还是非常清晰的，相信大家有了一定的了解，那么最后我就放上代码。

```
#include<cstdio>
#include<ctype.h>
#include<iostream>
using namespace std;
inline int read();

int n,m,a[4000060],front,rear,sum,ans1,ans2,ans3;

int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read();
	for (register int i=1;i<=n;++i)
		a[i]=read();
	front=1;rear=1;sum=a[1];//首先front和rear初始化为1，sum为a[1]
	while (rear<=n)//当尾指针在序列内时
	{
		if (sum<=m&&sum>ans3)//如果sum优于ans，更新
		{
			ans1=front;
			ans2=rear;
			ans3=sum;
		}
		if (sum<m)//如果sum<m，后移尾指针
			++rear,sum+=a[rear];
		else if (front==rear) ++rear,sum+=a[rear];//如果front==rear，那就只能后移尾指针
		else sum-=a[front],++front;//否则，将sum缩小，即后移头指针
	}
	cout<<ans1<<" "<<ans2<<" "<<ans3;
	return 0;
}

inline int read()
{
	int x=0,f=0;
	char c=getchar();
	while (!isdigit(c))
		f|=c=='-',c=getchar();
	while (isdigit(c))
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f?-x:x;
}
```


---

## 作者：HEIGE (赞：1)

# 双指针+前缀和

本题是相对基础的一道题，是一道把双指针和前缀和两个知识点融合的很好的题目，但在思考上也没有设置过大的障碍，是一道不错的基础练习题。
## 题意分析
我们要求一个数列的一个子区间，满足该子区间的值为不大于$x$的最大值。

第一眼看到子区间求和时，就应该很容易想到使用前缀和的方式处理，时间复杂度为$O(n)$。之后我们需要枚举各个子区间之和，找出不大于$x$的最大值，由于子序列必然是连续的，我们就可以维护一个双指针来寻找其中的最大值，复杂度也为$O(n)$。此时一个满分算法已经诞生了，接下来需要处理一些细节问题。
## 前缀和的初始化与使用
前缀和的本质是构造另一列的数列$s$，使得它与原数列$a$拥有关系$s[i] = a[1] + a[2] + ... +a[i]$。此时我们求$a[l]$到$a[r]$的子区间之和时只用计算$s[r] - s[l - 1]$即可。

初始化时只需要通过$s[i] = s[i - 1] + a[i]$的递归实现即可。复杂度为$O(n)$，查询时复杂度为$O(1)$。
## 双指针的使用
根据题意，我们可以用两个指针$l, r$维护一个区间$s[l - 1]$至$s[r]$，当$s[r] - s[l - 1] <= x$时我们向右移动指针$r$增加子序列之和，当$s[r] - s[l - 1] > x$时，我们向右移动$l$指针，直到子区间和再次小于$x$这样，我们可以保证遍历所有满足条件的子区间。之后我们只要储存每一个满足条件的值中的最大值即可。两个指针各扫描数组一遍，复杂度为$O(2n)$。

## AC代码

```cpp
#include <iostream>
using namespace std;
const int N = 4e6 + 10;
int a[N] = {0}, s[N] = {0}, n, x;
int main()
{
    ios::sync_with_stdio(false);//big data input//speed up by disable the sync
    cin >> n >> x;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        s[i] = s[i - 1] + a[i];//init
    }
    int maxn = 0, maxl, maxr;//maxn for storage the max value, maxl and maxr for storage the max left and right pointer
    for (int l = 1, r = 1; l <= n; l++)
    {
        while (s[r] - s[l - 1] <= x && r <= n) r++;
        r--;
        if (s[r] - s[l - 1] > maxn)
        {
            maxn = s[r] - s[l - 1];
            maxl = l;
            maxr = r;
        }
    }
    cout << maxl << " " << maxr << " " << maxn;
    return 0;
}
```
## 写在最后
该算法在O2优化下在第十个数据点上的实际运行时间为279ms，空间为30.70MB。

---

## 作者：linponess (赞：1)

### **2019/12/23 UPD：更正了部分叙述不合理的内容。**

------------

本次比赛里最难的一道题，其实也不是很难，自打题库有这道题就想做了，~~当时还好奇为什么不能查看，现在才明白是比赛试题~~。


------------
## **以下是正文：**
题目要求求出不超过M的最大子序列和，~~作为一个OI选手的本分~~首先我们考虑暴力。

------------

$\Large 30pts$

很容易想到 $\large n^2$ 的暴力做法，即将系列先前缀和一下，然后再用两个 $for$ 循环把系列从头到尾扫一遍，在 $sum_j-sum_i$ 中取一个不超过 M 的 $max$ 即可，可以拿到30分的好成绩（然而 $ACM$ 赛制不 $AC$ 就没有分数）。

代码就不放了。

------------

$\Large 100pts$

运用大眼观察法，发现对于一个已知最大子序列和为其后缀的序列，在其后面插入一个 $k$ 时有两种情况：

当 $max+k\leq M$ 时，新的 $max_{new}$ 必然等同于 $max+k$ 。

当 $max+k>M$ 时，先前的最大子序列和 $max$ 已经不可能再对答案做出贡献了，考虑到 $k$ 可能对区间起点后移的子序列和做出贡献，我们持续后移子序列的区间起点直至后移 $s$ 个元素后 $max_{s}+k\leq M$，更新 $max_{new}=max_{s}+k$。

对于不超过M的最大子序列和，在所有 $max$ 中取一个最大值即可。

得出了这个结论后，我们便可以用  $dp$ 解决本题了。

**代码：**
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,dp[2],a[8101919],s=1,ms,me,maxn,k;//n,m,a[]与题面描述相同，dp为递推数组。 
int main()//ms,me为不超过M的最大子序列和区间的最小左端点、右端点，maxn为不超过M的最大子序列和，k用于滚动数组优化空间。
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);//读入部分。 
		while(dp[k]+a[i]>m)//对不能对答案做出贡献的最大子序列和进行更新。 
		{
			dp[k]-=a[s];
			s++;
		}
		dp[!k]=dp[k]+a[i];
		k=!k;//滚动数组优化。 
		if(dp[k]>maxn)//更新答案。 
		{
			maxn=dp[k];
			ms=s;
			me=i;
		}
	}
	printf("%d %d %d",ms,me,maxn);//输出部分。 
	return 0;
}
```


------------
$postscript:$本人对本次比赛F题出锅却不重测代码表示强烈谴责。

---

## 作者：炳源 (赞：1)

先上代码  
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
int n,m;
int A[4001000];
int Lef = 1,Rig = 1;
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= n;i++)
		cin>>A[i];
	int Sum = 0,ans = 0,ansL = 0,ansR = 0;
	while(Lef <= Rig && Rig <= n)
	{
		Sum += A[Rig];
		while(Sum > m && Lef <= Rig)
		{
			Sum -= A[Lef];
			Lef++;
		}
		if(Sum > ans)
		{
			ans = Sum;
			ansL = Lef;
			ansR = Rig;
		}
		Rig++;
	}
	cout<<ansL<<" "<<ansR<<" "<<ans;
}
```
这道题其实并不难想   
题意大概就是  
维护一个序列，使其中连续最大值不超过m  
那么很容易就想到尺取法 
### 尺取法  


------------
模拟两个指针，开始都指向队首，右指针后移，当超过限制条件时，
左指针后移；  
  
  那么接下来就很简单了；  
  限制条件：不超过m;  
  那么就直接划一遍就好了；
  在满足条件的时候记录左右端点及当前最优值
  
  O(n)即可满足

---

## 作者：yu__xuan (赞：1)

### 题目
[P5745 【深基附B例】数列求和](https://www.luogu.com.cn/problem/P5745)

### 思路

分析：

* 这题有着一个特点——数列是正整数。

* 如果 $[l,r]$ 这个区间大于 $m$，那么 $[l,r + 1]$也必定大于 $m$。

我们用一个左指针 $head$ 指向当前选取的区间的左端点，用一个右指针 $tail$ 指向当前选取的区间的右端点。一开始 $head = 1,tail = 1$ 表示选取的区间为 $[1,1]$。

* 当 $[head,tail]$ 的值小于 $m$ 时增加 $tail$。

* 当 $[head,tail]$ 的值大于 $m$ 时增加 $head$。

**注意判断边界。**

### $Code$

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#define MAXN 4000001

inline void read(int &T) {
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int n,m,a[MAXN];

int main() {
	int now=0,maxx=0,ans1,ans2;
	read(n),read(m);
	for(int i=1;i<=n;++i) read(a[i]);
	int head=1,tail=1;now=a[1];
	while(head<=n&&tail<n&&head<=tail) {
		std::cout<<now<<" "<<head<<" "<<tail<<'\n';
		while(now>m&&head<=n) {
			now-=a[head];
			++head;
			if(now<=m&&maxx<now) maxx=now,ans1=head,ans2=tail;
		}
		while(now<=m&&tail<n) {
			now+=a[++tail];
			if(now<=m&&maxx<now) maxx=now,ans1=head,ans2=tail;
		}
	}
	printf("%d %d %d\n",ans1,ans2,maxx);
	return 0;
}
```

---

## 作者：lycx03 (赞：1)

每读入一个数右端点向右移1,若数列之和大于m则右移左端点直至数列和小于m,具体细节见代码(由于输入数据较大建议加个快读)。
```cpp
#include<cstdio>
int n,m,l=1,r=0,xl,xr,a[4000011],w=0,v=0;
inline int read() 
{
	int s=0;
	char ch;
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-48,ch=getchar();
	return s;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		w+=a[i],r++;//右端点+1 
		if(w>v&&w<=m) v=w,xl=l,xr=r;
		while(w>m&&l<r) w-=a[l++];//若超过m移动左端点 
		if(w>v&&w<=m) v=w,xl=l,xr=r;
	}
	printf("%d %d %d\n",xl,xr,v);
	return 0;
}
```


---

## 作者：谷民 (赞：1)

使用 $O(N)$ 直观模拟

维护一个前缀和，左指针，右指针。如果左指针在右指针左侧且它们都小于n进入循环。如果 $l$ - $r$ 区间小于等于 $m$ 判断 $l$ - $r+1$ 区间是否大于 $m$ 。如果同样满足则更新答案，并且将右指针加一。如果 $l$ - $r$ 区间大于 $m$，将左指针加一。

详见代码

```
#include <bits/stdc++.h>
using namespace std;
int n,m,a[4000005],l=1,r=2,ans,al,ar;//左指针初始为1，右指针初始为2
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);//数组用scanf高速读入
		a[i]+=a[i-1];//维护前缀和
	}
	while(l<=r&&r<=n){//判断区间（小于n），否则会RE
		if(a[r]-a[l-1]<=m){//如果区间和小于m
			if(a[r+1]-a[l-1]>m){//判r+1区间和是否大于m
				if(ans<a[r]-a[l-1]){//更新答案
					ans=a[r]-a[l-1];
					al=l;
					ar=r;
				}
			}
			r++;//右指针+1
		}
		else{
			l++;//如果区间和大了左指针+1
		}
	}
	cout<<al<<" "<<ar<<" "<<ans;
    return 0;
}
```


---

## 作者：utmost_DT (赞：0)

P5745 题解


首先看题：求出这个数列中的一个子区间 [i, j][i,j]，使得这个子区间的和在不超过 m的情况下最大。

子区间和？

很容易就想到是前缀和。（复杂度O(n²））

（而且比暴力O（n3）快的多，O(n²)普及难度基本够用了）


但是,在敲代码前我们把题目看完：
看完题目我们首先就注意到子任务4：

子任务 4（40分）：n≤4×10 6
  。

数据达到了10的6次方级……

O(n²)显然TLE。

既然T了n²，我们就要想一想能不能继续优化时间复杂度。

### ①	O（nlogn）行吗？

继续分析题目：如果确定区间【i,j】，那么当区间拓展为【i,j+1】时，（由于是正整数），区间和一定增大！我们于是发现：这个问题的解是单调递增的！
既然单调递增，我们就可以二分!

按照上面的思路，我们可以先确定I,再二分确定j，用O(nlogn)的复杂度解决问题！

### ②	还能更快吗？

#### 在此引入新的数据结构：队列。

先令i为第一个数。

如果我们每次把一个数入队直至j入队时和超过M，那么【i，j-1】就是一个合适的子区间，记录答案，然后让队首i出队，重复以上步骤，直至队列为空为止。
最后比较各个子区间的和得出结果。

那么时间复杂度呢？

分析一下即可发现：每个数都会进队和出队，而且进队和出队都为一次，所以复杂度就为O（n）啦。

### 补充：

优化时间复杂度不仅有以上方法，还可以常数优化（卡常）
在这里可以用快读（用getchar()加快速度）

```cpp
inline int read()
{
	char c;int sign=1;
	while((c=getchar())<'0'||c>'9') if(c=='-') sign=-1;
	int ret=c-'0';
	while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
	return ret*sign;
}
```
快读对于数据很大时效果非常明显，还不会的OIer一定要记住啦！



综上附上AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 5000010
long long n,m;
long long a[maxn];
int sum,ans,ai,aj;
inline int read()
{
	char c;int sign=1;
	while((c=getchar())<'0'||c>'9') if(c=='-') sign=-1;
	int ret=c-'0';
	while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
	return ret*sign;
}
int main()
{
	cin>>n>>m;
	int i;
	for(i=1;i<=n;i++)
	{
		a[i]=read();
		
	}
	i=1;
	int j=1;
	while(i<=n)
	{
		while(j<=n&&sum+a[j]<=m)
		{
			sum+=a[j];
			j++;
		}
		if(sum<=m&&sum>ans)
		{
			ans=sum;
			ai=i;
			aj=j-1;
		}
		sum-=a[i];
		i++;
	}
	cout<<ai<<" "<<aj<<" "<<ans;
	return 0;	
}
```


---

## 作者：SmallTownKid (赞：0)

前缀和+双指针做法，大体思路就是不断移动队尾指针，如果当前队列和大于m，则移动队首指针，直到队列和小于等于m为止。这样可以保证遍历所有合法情况。
```
#include<iostream>
#include<cstdio>
using namespace std;
int s[4000010];
int a,p1,p2,n,m,ans1=0,ans2=0,sum=0;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		s[i]+=s[i-1]+a;//前缀和
	}
	p1=1,p2=1;//p1为队首指针，p2为队尾指针 
	while(p2<=n)//如果队尾指针不到最后，说明没有遍历完
	{
		while(s[p2]-s[p1-1]>m&&p1<p2)//因为是前缀和数组，所以是p1-1而不是p1,p1的话会把p1这个点的数减去。
		p1++;//移动队首指针
		if(s[p2]-s[p1-1]>sum)//如果合法
		{
			sum=s[p2]-s[p1-1];//总和
			ans1=p1;//队首元素
			ans2=p2;//队尾元素
		}
		p2++;//移动队尾指针
	}
	printf("%d %d %d",ans1,ans2,sum);
	return 0;
}

---

## 作者：huangwux (赞：0)

# 单调队列

CSP-2019后的第一篇题解

这显然是一道类似于滑动窗口的单调队列题目

因为所有的A【i】都是正整数，而且要求的是子序列而不是子串

所以我们可以通过一种名叫“单调队列”的做法

简单来说，维护一个队列，用一个指针（代码中的i）从前向后扫过去

如果队列中数字之和大于M，就从最左侧出队（因为是连续的）

直到数字之和小于等于M（一开始看成了小于，对拍了半天才发现）

这样扫完之后，我们所求的东西实际上是————以每个A【i】结尾的子序列的和在满足小于等于M的条件下的最大值

又因为是满足条件下i最小的，只需要在sum>已有sum的条件下修改答案即可（如果求的是i最大的，此处改成大于等于即可）

然后我们就A了

下面是代马



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[4000100];
int l,r,l1,r1;
int sum;
int res;
int ansl,ansr,anssum;
int main(){
	l=1,r=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		sum+=a[i];
		r++;
		while(sum>=m){
			sum-=a[l];
			l++;
		}
		if(sum>anssum){
			anssum=sum;
			ansl=l,ansr=r;
		}
	}
	cout<<ansl<<" "<<ansr<<" "<<anssum;
}
```


---


# 化简单词

## 题目描述

最近情报人员得到了一些经过加密的文章，每个单词都很长。破译人员想到先把单词化简一下，方法是把每个单词尽量取短些的前缀，但所取的前缀不能是其他单词的前缀。

这个任务现在就交给你来完成。

解释：“字符串 $\text{S}_1$ 是 $\text{S}_2$ 的前缀”是说把字符串 $\text{S}_2$ 的后面去掉某些，只保留与 $\text{S}_1$ 相同长度时，$\text{S}_2$ 就与 $\text{S}_1$ 完全相同。如：$\texttt{abc}$ 是 $\texttt{abcaade}$ 和 $\texttt{abc}$ 的前缀，但不是 $\texttt{abadc}$ 的前缀。


## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 50$，每个单词长度不超过 $50$，并且都是由小写字母构成。

保证所给单词没有一个单词是另一个单词的前缀。


## 样例 #1

### 输入

```
3   
abc 
efg 
ijh```

### 输出

```
a
e
i
```

## 样例 #2

### 输入

```
3
aac
aad
aae```

### 输出

```
aac
aad
aae```

# 题解

## 作者：_Clown_ (赞：41)

#### 进入正题前，先重磅推荐[乱码团队](https://www.luogu.com.cn/team/19322)以及[我的博客](https://akioi-noi.blog.luogu.org/)。
#### 当然，还要提醒大家，不能抄代码，请详细阅读[洛谷社区规则](https://www.luogu.com.cn/blog/luogu/social-rules)！
本蒟蒻衷心希望管理员给个通过^_^
### 那么，闲言少叙，现在切入正题吧(**我想我的方法不太复杂**)！
## 这道题要用到一个ABOUT字符串的函数：
# SUBSTR
这是什么？我们来举个例子：

假设s是一个字符串，s="YOUAREABIGPIG."，我想提取它从下表为0到下表为2的这一段，令他为t。

那么怎样做呢？这就要用到substr了。

表示方法为：t=s.substr(0,3);

如果用广泛的角度来讲，就是：
### 子串=原串.substr(起始位置,提取的子串的长度);
对于各位巨(蒟)佬(蒻)来说，一定很容易理解吧！

然后，我们对每一个串暴力枚举长度，如果当前长度不可行，就判断再长一点的长度。

怎样判断可不可行呢？挨个枚举其它字符串，看看前缀会不会重复，问题迎刃而解了！
### 其它注释见代码，那么现在，上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
string s[51];
int len[51];
int main()
{
	int n;
	cin>>n;
	int i,j,k;
	for(i=1;i<=n;i++)
	{
		cin>>s[i];
		len[i]=s[i].size();
	}
   	//前面是输入，自然不必多说，如果无法理解，请回吧^_^
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=len[i];j++)
		{
			bool flag=true;
			for(k=1;k<=n;k++)
			{
				if(i==k)
				{
					continue;
				}
           			//如果是同一个串，自然不必判。
				if(s[i].substr(0,j)==s[k].substr(0,j))
				{
					flag=false;
				}
           			//判断前缀是否相同，相同的话，这个长度就不成立了。
			}
			if(flag)
			{
				cout<<s[i].substr(0,j)<<endl;
				break;
			}
		}
	}
	return 0;
}
```
# 点个赞再走吧！

---

## 作者：Mr_WA的大号 (赞：10)

春风又绿江南岸，AC何时照我还。小学生又来发题解了！

题号：P5876

难度：★★★

算法：枚举暴力

## 开课了！

这道题其实很简单的（~~只是我不会做~~），先找出这几个字符串中最短的字符串的长度（简称lo），然后从1到lo枚举长度，看看这几个字符串的前i位是否会相同，不相同输出就行了，相同则继续找。

上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<stack>
#include<queue>
#include<set>
using namespace std;
int n,ans=2100000000;//ans为lo设为最大值
string st[100],st1[100];
bool x;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>st[i];
		if(ans>st[i].size())ans=st[i].size();//替换ans
	}
	for(int i=1; i<=ans; i++)
	{
		x=true;
		for(int j=1; j<=n; j++)
			st1[j]=st[j].substr(0,i);//截取字串
		for(int j=1; j<n; j++)
			for(int k=j+1; k<=n; k++)
				if(st1[j]==st1[k])//如果相同
				{
					x=false;//置为false
					break;//退出
				}
		if(x==true)break;//如果可以的话就退出
	}
	for(int i=1; i<=n; i++)
		cout<<st1[i]<<endl;//输出
	return 0;
}
```
~~**我才不会告诉你这会WA呢**~~

好了，那这是为什么呢？（~~我也不知道哦~~）

我们来反观题目，他告诉我们每个字串要取尽量短的前缀，我们的程序好像也这样做了呀！（~~真的吗？~~）

### **但是，他没有说要每个字串同样长！**

这就好办了，我们还是要用三for，如下：
```cpp
	for(用变量i枚举当前要取前缀的字符串)
	{
		for(用变量j枚举截取的长度)
        {
    		变量x标记为true  
            将截取的字串赋给字符串t
        	for(用变量k枚举其他的字符串)
            {
            	如果取前缀的字符串就是st[k]：跳过本次循环
                如果t和字符串k的j位前缀相同：
                {
                	将x标记为false
                    退出循环
                }
            }
            如果变量x为true：
            {
            	输出t
                退出循环
            }
        }
	}
	return 0;
}
```
课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<stack>
#include<queue>
#include<set>
using namespace std;
int n;
string st[100],t;
bool x;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>st[i];//输入
	for(int i=1; i<=n; i++)//枚举截取的字符串
	{
		for(int j=1; j<=st[i].size(); j++)//枚举长度
		{
			x=true;//将x赋值为true
			t=st[i].substr(0,j);//截取字符串
			for(int k=1; k<=n; k++)//枚举其他字符串
			{
				if(i==k)continue;//如果截取的字符串就是当前字符串就跳过这一次
				if(t==st[k].substr(0,j))//如果两者相同
				{
					x=false;//标记为false
					break;//退出
				}
			}
			if(x==true)//如果他是独一无二的
			{
				cout<<t<<endl;//输出
				break;//跳出循环
			}
		}
	}
	return 0;
}
```
友情样例：

输入：

|  3|
| :----------- |
|  aaa|
|  aab|
|  eig|

输出：

|  aaa|
| :----------- |
|  aab|
|  e|

祝大家能AC！

---

## 作者：hmy521 (赞：7)

一道难度不大的题，模拟即可

一看就是字符串，不过为了通俗易懂点，本人不想用那些substr等系统自带函数，直接手动模拟

### 思路：

在输入全部结束之后，将所有字符串一个一个扫一遍，从每个字符串中从头开始截取，截取后的前缀在跟别的字符串比较，看看这个前缀是否也是另一个字符串的前缀，如果不是，输出&break，如果是，继续截取，知道合法为止

CODE（建议先从主函数开始看）：

```
#include<bits/stdc++.h>
using namespace std;
string a[51];//字符串数组
string sub(string st,int len){//模拟substr函数
	string st1="";
	for(int i=0;i<len;i++){//截取从0坐标到len-1坐标的字符串
		st1=st1+st[i];
	}
	return st1;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
   //以上为输入
	for(int i=1;i<=n;i++){
		string st=a[i],st1="";
		for(int j=0;j<st.size();j++){
			st1=st1+st[j];//截取当前字符
			bool flag=true;//判断初始值为true
			for(int k=1;k<=n;k++){//扫一遍
				string st2=a[k];
				if(k!=i){
					if(st1==sub(st2,st1.size())){//如果刚刚得出的前缀与别的字符串的前缀相同
						flag=false;//判断不合法
						break;
					}
				}
			}
			if(flag==true){//如果判断合法
				cout<<st1<<endl;//输出
				break;//开始下一个
			}
		}
	}
	return 0;
}
```
写题解不容易，点个赞再走吧~~~~


---

## 作者：　　　吾皇 (赞：4)

看到数据范围 $1 \le N \le 50$，想到暴力随便搞搞。只要一个一个进行暴力枚举，判断当前字符串的前缀是否为其他字符串的前缀即可，如不是，则输出。当然还要判断一下该前缀长度是否大于想比对的字符串，否则可能出现越界现象。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s[51],t;//s用来存题中所给字符串，t来存答案
bool p;//判断t是否合理
bool qz(string x,string y){//判断x是否为y的前缀
	for(int i=0;i<x.size();i++) if(x[i]!=y[i]) return false;//如果y的前(x.size())字符中有一个不等于x的，那么x肯定不是y的前缀
	return true;//否则是
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) cin>>s[i];
	for(int i=1;i<=n;i++){
		t="";//先将前缀清空
		for(int j=0;j<s[i].size();j++){
			t=t+s[i][j];//一个字符一个字符加直到符合题意
			p=true;
			for(int k=1;k<=n;k++){
				if(k==i) continue;//跳过自己
				if(j+1<=s[k].size()&&qz(t,s[k])){//如果t是s[k]的前缀则不行
					p=false;
					break;//跳出循环节省时间
				}
			}
			if(p){//如果满足题意直接输出即可
				cout<<t<<endl;
				break;
			}
		}
	}
}
```


---

## 作者：苏打青柠水 (赞：3)

发一篇java版的trie树的做法，主要思想是先初始化字典树，并在初始化过程中计数，计数的目的是区分是否可以作为前缀的开始的判断依据，假如小于等于1，则可以说从开始到该位置的字符串可以作为一个化简。
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Main {

	static Tree tree[]; // trie树
	static int tot = 0; // 内存池

	static class Tree {
		int next[] = new int[26]; // a-z字母
		int num = 0; // 计数
	}

	static void add(char s[]) {
		int p = 0;

		for (int i = 0; i < s.length; i++) {

			if (tree[p].next[s[i] - 'a'] == 0) {
				tree[++tot] = new Tree(); // 开辟新内存
				tree[p].next[s[i] - 'a'] = tot;
			}
			p = tree[p].next[s[i] - 'a'];
			tree[p].num++; // 计数
		}

	}

	// 返回非前缀的位置
	static int find(char s[]) {
		int p = 0;
		for (int i = 0; i < s.length; i++) {
			p = tree[p].next[s[i] - 'a'];
			
			//只要小于等于1，则证明从该位置开始已经没有前缀
			if (tree[p].num <= 1)
				return i;

		}
		return s.length;

	}

	public static void main(String[] args) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(reader.readLine().trim());

		tree = new Tree[n * 50 + 1]; // 开辟空间
		tree[0] = new Tree(); // 初始化根节点

		String data[] = new String[n]; // 用于保存字符串

		// 初始化字典树
		for (int i = 0; i < n; i++) {
			data[i] = reader.readLine().trim();
			add(data[i].toCharArray());
		}
		reader.close();//及时关闭输入流，释放内存
		
		StringBuffer result = new StringBuffer(); // 保存结果
		// 查找字典树
		for (int i = 0; i < n; i++)
			result.append(data[i].substring(0, find(data[i].toCharArray()) + 1)).append("\n");

		// 输出结果
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		out.println(result);
		out.flush();
		out.close();
	}

}
```


---

## 作者：TESJackeyLove (赞：2)

**这题的意思就是找出每个单词符合要求的最短前缀，这个要求就是这个前缀不能是别的单词的前缀。**  
- 因为这个题的数据范围比较小，所以直接暴力就可以了。我们可以先用一个string数组把所有的字符串存起来。（为什么要用string？因为string自带很多函数，用起来很方便。譬如substr可以截取当前字符串的某一部分，find可以去查找str1在str2里面出现的位置，没有出现就会返回-1，出现了就会返回第一次出现的位置）
- 那么这个find函数就很有用了，想一想，我要判断一个str1的前缀p是否也是str2的前缀，怎么样判断？很简单，我们直接str2.find(p)是不是就可以了？如果返回值是0，就说明p在str2中第一次出现的位置是在最前面，也就构成了str2的前缀。反之，如果不是0，是其他的数字呢？不影响，只要不出现在最前面，你出现在哪儿都行，不出现也行。所以我们只需要用除了str1之外的字符串全部去find一下p，如果返回值都不是0，那么str1就可以化简为p。  
- 这个子串p怎么去获得呢？因为是要取最短的前缀，所以我们可以从头开始截取长度为1,2,3一直到str1最长长度，第一个符合要求的p就是我们要找的p。
- ok，那么代码就好写了，第一层for循环遍历所有字符串，求第i个单词的最短前缀，第二层for循环，用来遍历p的所有可能性，第三层for循环，去遍历除去第i个单词的其他单词，判读p是否符合要求，如果符合要求就把第二层for循环break掉。以下是丑陋的代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<stack>
#define fore(i,a,b) for(int i=a;i<=b;i++)
#define ford(i,a,b) for(int i=a;i>=b;i--)
#define IGNB std::ios::sync_with_stdio(false);
#define ll long long
using namespace std;
string s[55];
int main(){
	IGNB;
	int n;
	cin>>n;
	fore(i,1,n) cin>>s[i];
	fore(i,1,n){//第几个单词 
		fore(j,1,s[i].length()){//前缀取多长 
			bool f=true;
			string tmp=s[i].substr(0,j);
			fore(k,1,n){//排查所有的单词 
				if(k==i) continue;
				if(s[k].find(tmp)==0){
					f=false;
					break;
				}
			}
			if(f){
				cout<<tmp<<endl;
				break;
			}
		}
	}
	return 0;
}

```


---

## 作者：rui_er (赞：2)

看来前面题解的各种做法（其实也就两种），我决定给你们写一篇STL的。

### 介绍一下使用的函数：```substr()```

这个函数有两个参数，第一个是起始位置，第二个是子串长度，作用是取字符串的一部分，返回值为这段的内容。用法：

```cpp
string s;
s.substr(0, 5);
```

表示取字符串 $s$ 的前五位。

### 看一眼数据范围

发现可以暴力！于是就有了下面的思路：

> 枚举每个字符串，枚举前缀位数，判断这个前缀是否也是其他字符串的前缀：如果是，前缀位数加一，继续判断；如果不是，说明找到了最短的前缀，输出。

### 你们最爱的代码

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin>>n;
	string s[51];
	for(int i=1;i<=n;i++) cin>>s[i];
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=s[i].length();j++)
		{
			bool book = true;
			for(int k=1;k<=n;k++)
			{
				if(k == i) continue;
				if(s[i].substr(0, j) == s[k].substr(0, j))
				{
					book = false;
					break;
				}
			}
			if(book)
			{
				cout<<s[i].substr(0, j)<<endl;
				break;
			}
		}
	}
	return 0;
}
```

实测AC。

---

## 作者：AveMarina (赞：1)

## 不一样的暴力解...

看了半天题目才明白意思，其实就是要求某个字符从0~N位置上的字符串\
在所有输入的字符串中唯一，并且要求N要最小。那么我们可以考虑从0开\
截取字符串，并且是**对所有字符截取**，然后查找该子字符串是否唯一\
即可。

__几个方法/函数:__
1. substr(start, pos):从start向后截取pos个字符
2. count(start, end, target):从在start到end这个区间内查找target出现的次数

__题外话：__\
打开题解区，各位神犇的解法让本蒟蒻瑟瑟发抖，回头一看数据范围只有
50，妥妥的暴力。~~得过且过~~

__数组初始化:__\
这里初始化数组选用的new方式，这样就可以避免开一个很大的数组所\
导致的空间占用问题~~虽然这个题只要50个空间~~，一定要记得删除new出来的数组，否则可能内存泄漏。
```cpp
// 头文件，据说万能头要花费更多时间编译
#include <iostream>
#include <vector>
// 使用了count()函数
#include <algorithm> 
using namespace std;
// 用new来造数组
string *strs;
vector<string > s;
string *result;
int main() {
	int n;
	cin >> n;
   // new数组，语法是：变量名 = new 变量数据类型[数组大小]
	strs = new string[n];
	result = new string[n];
	string temp;
   // 输入QAQ
	for (int i = 0; i < n; i++) {
		cin >> strs[i];
	}
   // 从0~index截取字符串
	int index = 1;
   // 下面写了个死循环，所以用这个变量统计答案个数，
   // 当答案全出来了就退出循环
	int cnt = 0;
	while (true) {
     // 开始对所有字符串进行截取 
		for (int j = 0; j < n; j++) {
        // substr方法可以从当前位置向后截取pos个字符
			temp = strs[j].substr(0, index);
        // 存放截取的子串
			s.push_back(temp);
		}
		for (int i = 0; i < n; i++) {
        // count函数可以用来统计元素个数
			if (count(s.begin(), s.end(), s[i]) == 1 && s[i] != "0") {
           // 这里i就是当前最短且唯一的子串出现的位置，因为
           //vector的长度和n是一致的
				result[i] = s[i];
           // 把用过的元素标记，说明其已经是最短的了
				strs[i] = "0";
           // 答案+1
				cnt++;
			}		
		}
		if (cnt == n) break;
     // 清空vector，不然上次截取的子串也会存放在其中
		s.clear();
		index++;
	}
   // 输出答案，注意换行（虽然洛谷的评测没有卡这个）
	for (int i = 0; i < n; i++) {
		cout << result[i];
		if (i != n - 1) cout << endl;
	}
   // 记得删除数组，不然可能内存泄漏（几率不大）
	delete[] strs, result;
	return 0;
}
```
~~蒟蒻求过~~


---

## 作者：hensier (赞：0)

[获得更好的阅读体验](http://shenyouran.github.io/P5876/)

这道题用$\text{C++}$可以合理地使用$\text{substr}$来截取子串。[这里](https://zh.cppreference.com/w/cpp/string/basic_string/substr)有关于该函数的一些基本信息。

该函数可以接收有$0$到$2$个变量，返回值为$\text{string}$，其参数表为$\text{pos,count}$。

具体用法：

```cpp
string s="You AK IOI!";
cout<<s.substr()<<endl;//参数表留空则表示取原串，一般不使用
cout<<s.substr(4)<<endl;//从第4个下标开始，取子串直到结束
cout<<s.substr(7,3)<<endl;//从第7个下标开始，取3个字符（包含开始下标），作为子串
```

输出结果：

```plain
You AK IOI!
AK IOI!
IOI
```

对于本题，我们先把所有的字符串$s_i$进行输入，然后开始枚举。

首先在$[1,n]$之间处理所有的字符串，并确定其最小的子串。具体方法是，在$[1,|s_i|]$（$|s|$表示字符串的长度）之间进行枚举，从$0$开始截取对应长度，然后获得一个子串$sub$。接着，我们要在$[1,n]$范围之内进行判断，如果$sub$不是其他任何字符串的前缀，那么说明$sub$符合条件，可以输出。

$\text{C++}$代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s[51];
bool check(string a,int id)//check函数判断子串是否满足题意
{
    for(int i=1;i<=n;i++)
    {
        if(i==id)continue;//这一点要注意——不能对母串进行判断，否则没有输出
        if(s[i].substr(0,a.size())==a)return false;//如果子串是其他字符串的前缀，那么势必不符合题意
    }
    return true;//检验了所有的字符串都满足题意就说明该子串可以作为当前字符串的答案输出
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)cin>>s[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=s[i].size();j++)
        {
            string sub=s[i].substr(0,j);//按照上述方法截取子串
            if(check(sub,i))
            {
                cout<<sub<<endl;
                break;//由于我们从1开始枚举，所以输出的必定是最短子串，可以跳出当前循环，进入下一个字符串的枚举
            }
        }
    }
    return 0;
}
```

对于$\text{Python 3}$，我们可以用类似的思路完成。

```python
n = int(input())
s = ['' for i in range(1, 55)] # 通过for循环来定义字符串数组
def check(a, idx):
    for i in range(1, n + 1):
        if i == idx:
            continue
        if s[i][0: len(a)] == a: # 判断是否为前缀
            return False
    return True
for i in range(1, n + 1): # 注意第二个参数是不包含的，所以要加1
    s[i] = str(input()) # str类型读入字符串
for i in range(1, n + 1):
    for j in range(1, len(s[i]) + 1): # len(s)表示字符串s的长度
        sub = s[i][0: j] # 这里表示从下标0开始，截取长度为j的子串
        if check(sub, i):
            print(sub)
            break
```

---

## 作者：Luarence (赞：0)

苟弱我发现题解很少有用java写的，这道题目我是用javaAC的，说实话Java涉及到对字符串的处理比c++,c更为方便一些，这道题用苟若没有用大佬的tire。

**题目分析：** 因为看到了数据范围所以用了暴力,其中有一个要点需要我们注意，就是两个字符串有可能不一样长，如果直接单纯的比较会出现越界的情况，我看上面大佬们写的题解很少有提出提出这一点，我想再强调一下，读题的时候一定不能想当然。

**上代码：**（代码比较浅显易懂）

```java
//只保留了main函数
public static void main(String[] args) throws IOException {
    //快读，可以有效提高速度在数据量大的时候
        StreamTokenizer in = new StreamTokenizer(new InputStreamReader(new BufferedInputStream(System.in)));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            int n = (int)in.nval;
            String[] strs = new String[55];
            for (int i = 0; i < n; i++) {
                in.nextToken();
                strs[i] = in.sval;
            }
            //开始暴力
            for (int i = 0; i < n; i++) {
                String tmp = strs[i];
                ok:
                for (int j = 1; j <= tmp.length(); j++) {
                    int flag = 0;
                    String tmp2 = tmp.substring(0,j);
                    for (int k = 0; k < n; k++) {
                        if (i == k) {
                            continue;
                        }
                        //关键一步，没有这步会报RE
                        if (tmp2.length() > strs[k].length()) {
                            break ;
                        }
                        if (strs[k].substring(0, j).equals(tmp2)) {
                            flag = 1;
                            break;
                        }
                    }
                    if (flag == 0) {
                        out.println(tmp2);
                        break ok;
                    }
                }
            }
            out.flush();
        }
    }

```

**如有问题，希望各位大佬及时指正**

---


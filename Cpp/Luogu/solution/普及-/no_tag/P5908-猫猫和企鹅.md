# 猫猫和企鹅

## 题目描述

王国里有 $n$ 个居住区，它们之间有 $n-1$ 条道路相连，并且保证从每个居住区出发都可以到达任何一个居住区，并且每条道路的长度都为 $1$。

除 $1$ 号居住区外，每个居住区住着一个小企鹅，有一天一只猫猫从 $1$ 号居住区出发，想要去拜访一些小企鹅。可是猫猫非常的懒，它只愿意去距离它在 $d$ 以内的小企鹅们。

猫猫非常的懒，因此希望你告诉他，他可以拜访多少只小企鹅。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n ,d \le 10^5$，保证所有居民区从 $1$ 开始标号。

## 样例 #1

### 输入

```
5 1
1 2
1 3
2 4
3 5```

### 输出

```
2```

# 题解

## 作者：PersistentLife (赞：81)

[博客体验更佳](https://www.luogu.com.cn/blog/302837/solution-p5908)

### 提供一个样例

为方便大家调试程序，我以云剪贴板的形式提供一个比较强的样例：

[输入](https://www.luogu.com.cn/paste/vuzyirsz) [输出](https://www.luogu.com.cn/paste/crf1qkzf)

展开源码复制即可。

### 前置芝士

图、树的基本概念，dfs，邻接表。

### 图、树的基本概念

这就是一张图：

![图](https://cdn.luogu.com.cn/upload/image_hosting/41tf8quc.png)

虽然这和我们之前看到的“图”不一样，但在离散数学里面，它就是一张图，研究“图”的离散数学分支就叫做“图论”。

在这张图中，①②③④就叫做节点，连接节点的线叫边。

当然，没有边只有节点的也叫图，没有节点但是有边的不叫图。

图有两种分类，上面的图叫“无向图”，下面这张图叫“有向图”：

![有向图](https://cdn.luogu.com.cn/upload/image_hosting/hunziq6d.png)

显然，有向图的边有方向，无向图的边没有方向，之后做题时题目会告诉你这是有向图还是无向图。

那么树是一种特殊的图，树是只由节点数 $-1$ 条边组成的连通图，那么这就是一棵树，这棵树也是样例里面的树：

![树](https://cdn.luogu.com.cn/upload/image_hosting/oo7cvyoe.png)


当然，有向图组成的树叫做“有根树”，无向图组成的就叫做“无根树”。

树根，就是没有“孩子”的节点。

一个节点的孩子，指有一条边从这个节点指向的节点，比如上图，②就是①的孩子，⑩是⑦的孩子。

那么父亲正好和孩子是反的，比如，①是②的父亲，⑦是⑩的父亲。

关于概念就介绍到这么多，如果大家想了解更多可以上网搜。

### dfs

dfs是什么，是深度优先搜索，可以对图或树进行遍历，主要过程是“不撞南墙不回头”，即始终沿着一个方向走，直到没有可以遍历过的节点了，而且，遍历过的节点不会重复遍历。

例如上面这棵树的 dfs 序列就是：

$1-2-7-9-10-11-3-4-5-8-12-13-14-15-16-17-6$


还有一种遍历叫 bfs，即广度优先遍历，如果想了解可以做做 [P5318 查找文献](https://www.luogu.com.cn/problem/P5318)

### 邻接表

邻接表是一种可以存图的数据结构，因为树是一种特殊的图，所以也可以用邻接表存树。

邻接表是用 $vector$ 向量实现，每一个节点都有一个 $vector$，里面存储了与这个节点关联的节点，下面是实现邻接表的代码：

```cpp
int a,b;
cin>>a>>b;//表示一条边的两个节点，g是全局的vector
g[a].push_back(b);
g[b].push_back(a);
```

### 此题代码实现

这题用 dfs，只是只要访问距离小于 $d$ 的节点，在 dfs 函数里面可以进行特判：

```cpp
void dfs(int now,int dis)//分别表示现在的节点和距离
{
	vis[now]=1;//vis 数组标记节点是否被访问，以免重复统计
	if(dis==d) return;//是否达到了距离上限
	for(int i=0;i<g[now].size();i++)//枚举关联的所有节点
	{
		if(!vis[g[now][i]])//若没有访问过
		{
			dfs(g[now][i],dis+1);//就去跑一遍
			ans++;//答案加一
		}
	}
}
```
那么将邻接表和 dfs 组合到一起就是这题的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector <int> g[123456];
bool vis[123456];
int ans,n,d;
void dfs(int now,int dis)
{
	vis[now]=1;
	if(dis==d) return;
	for(int i=0;i<g[now].size();i++)
	{
		if(!vis[g[now][i]])
		{
			dfs(g[now][i],dis+1);
			ans++;
		}
	}
}
int main()
{
	cin>>n>>d;
	for(int i=1;i<n;i++)
	{
		int a,b;
		cin>>a>>b;
		g[a].push_back(b);
		g[b].push_back(a);
	}
	dfs(1,0);
	cout<<ans;
	return 0;
}
```


---

## 作者：Warriors_Cat (赞：20)

## P5908 【猫猫和企鹅】

首先，我们看一下题面，发现只有 $n-1$ 条边。

这不就是一棵树吗？

于是乎，我们就可以将 $1$ 定为树根，然后进行一次搜索求出每一个节点的深度，最后判断深度和 $d$ 的关系就可以啦QWQ

直接上代码吧：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
struct edge{
	int v, nxt;
}e[200010];
int head[200010], cnt, n, d, x, y, vis[100010];
inline void add(int u, int v){
	e[++cnt].v = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}//链式前向星建图 
void dfs(int u){//求深度 
	for(int i = head[u]; i; i = e[i].nxt){
		int v = e[i].v;
		if(vis[v]) continue;//已经遍历过就不遍历了 
		vis[v] = vis[u] + 1;//深度+1 
		dfs(v);//继续搜索 
	}
	return;
}
int main(){
	scanf("%d%d", &n, &d);
	for(int i = 1; i < n; ++i){
		scanf("%d%d", &x, &y);
		add(x, y);
		add(y, x);//注意是无向图 
	}
	int ans = 0;
	dfs(vis[1] = 1);//压行QWQ 
	for(int i = 2; i <= n; ++i) if(vis[i] - 1 <= d) ans++;//vis[i] - 1即为1到i的距离 
	printf("%d", ans);
	return 0;
}
```
## End

---

## 作者：朱屹涵2008 (赞：9)

### 本题重点：图论，DFS深度优先搜索。

题目本质：有n个点，n-1条边（即一棵树），求深度<=d的节点有几个。

------------

**解题思路：**

既然是树，又关于深度，那么肯定是要用DFS深度优先搜素的啦。

方法一：DFS遍历整棵树，求出所有点的深度即D数组，再算点的深度<=d的节点数。

方法二：在方法一的基础上增加类似暴力算法优化中的剪枝的操作，不使用D数组，而是使用计数器cnt，如发现深度>=d了，就立刻return，不需要继续做了，否则计数器++。这个做法在多数情况下可以降低时间复杂度并降低空间复杂度

------------

此外，这一题需要使用**邻接表**，那么，我就在这里讲一下这个东西：

邻接表是一种存储结构，可以用于存储图，类似一个不限大小的数组。

vector< 类型 > x; : 定义邻接表 x 。
     
x.push_back(i); : 在邻接表 x 的后面压入 i 。

x[i] : 访问邻接表 x 的第 i 个元素。

x.size( ) : 邻接表 x 内的元素数量。
     
以上这些是邻接表的主要操作，另外，在存图时，需要用到 二维 的邻接表，定义方法： vector<int> x[N] 。
     
存图代码：
```cpp
   for(int i=1;i<=n-1;i++){//树有 n-1 条边。
      int u,v;cin>>u>>v;
      es[u].push_back(v);
      es[v].push_back(u);
   } 
```   
  
vector+dfs 的核心代码：

```cpp
   for(int i=0;i<es[x].size();i++){
      if(es[x][i]==p)continue;//p表示当前节点的父节点。
      dfs(es[x][i],x);
      //需要的操作。
   }
```  

------------  
                                    
邻接表的主要知识就是这些啦，下面是本题AC代码：

```cpp
#include<bits/stdc++.h>
#define N 100005 
using namespace std;
int n,d,cnt=0;
vector<int> es[N];
void dfs(int x,int p,int dis){
   if(dis>=d)return;
   for(int i=0;i<es[x].size();i++){
      if(es[x][i]==p)continue;
      dfs(es[x][i],x,dis+1);
      cnt++;
   }
}
int main(){
   cin>>n>>d;
   for(int i=1;i<=n-1;i++){
      int u,v;cin>>u>>v;
      es[u].push_back(v);
      es[v].push_back(u);
   } 
   dfs(1,0,0);
   cout<<cnt;
   return 0;
}
``` 

---

## 作者：LinkZelda (赞：7)

- **前言**：

虽然本题只要求一个深度中**小于等于该深度**的点的数量，直接用各种**最短路**算法就可以搞定 。 但是，我们不妨思考一下，如何面对多次询问（假设询问次数很大，$10^6$ 左右）。

- **做法**：

考虑**前缀和**，定义一个数组 `dep[i]` 表示深度小于等于 $i$ 的点的个数，然后这个显然是可以 $O(n)$ 预处理出来的，直接 $dfs$ 一次即可。

对于每次询问，直接输出 `dep[i]-dep[0]` 即可（这里设根节点深度为 $0$ ）

由此，我们便可以 $O(n)$ 预处理，$O(1)$ 每次询问了。

- **实现**：

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>

using namespace std;

int dep[100005],maxdep=0;//dep[i] :深度小于 i 的点个数, maxdep :最大深度 
vector<int>G[100005]; 

void add(int u,int v)
{
	G[u].push_back(v);
	G[v].push_back(u);
}

void dfs(int now,int fath,int deep)
{
	dep[deep]+=1;
	for(int i=0;i<G[now].size();i++)
	{
		int v=G[now][i];
		if(v!=fath)
			dfs(v,now,deep+1);
	}
	maxdep=max(maxdep,deep);
}

int main()
{
	int n,d;
	scanf("%d%d",&n,&d);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y); 
	}
	dfs(1,0,0);
	for(int i=1;i<=n;i++)
		dep[i]+=dep[i-1];//前缀和处理 
	printf("%d",dep[d]-dep[0]);
	return 0; 
}
```

---

## 作者：Vanyun (赞：5)

~~我们Tethys真的是太厉害啦！~~

## 题意可以简化为：

有一棵$n-1$条边，每条边边权为$1$，以$1$号点为根的树。

求树上有多少点到$1$号点的距离小于等于$d$。

## 一种做法：

### 做法：

图的遍历。

### 思路：

非常裸的一道题。

我们设$1$号点的深度为$0$，以$1$为根节点进行图的遍历。

此时各个点的深度即为各个点到$1$号点的距离。

答案可以在遍历的过程中求出。

复杂度为$O(n)$。

### 代码：

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5+10;

int n, d, ans, dep[maxn];

vector<int> v[maxn];

void dfs(int now){
	for(unsigned int i = 0; i < v[now].size(); i ++){
		int to = v[now][i];
		if(dep[to]) continue;
		dep[to] = dep[now] + 1;
		if(dep[to] <= (d+1)) ans++;
		dfs(to);
	}
	return;
}

signed main(){
	scanf("%d%d", &n, &d);
	for(int i = 1, x, y; i < n; i ++){
		scanf("%d%d", &x, &y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dfs(dep[1] = 1);
	printf("%d", ans);
	return 0;
}
```

## 另一种做法：

### 做法：

最短路。

### 思路：

也是非常的裸啊qwq。

根据题意在每个$x$和$y$之间建边，每条边的边权为$1$。

跑一边Dijkstra。

最后$O(n)$的扫一遍求出答案即可。

时间复杂度$O(nlogn)$。

### 代码：
```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5+10;

int n, d, ans, dis[maxn], vis[maxn];

vector<pair<int,int> > v[maxn];

void Dijkstra(){
	priority_queue<pair<int,int>, vector<pair<int,int> >, greater<pair<int,int> > > q;
	q.push(make_pair(0,1)), dis[1] = 0;
	while(q.size()){
		int now = q.top().second, len = q.top().first;
		q.pop();
		if(vis[now]) continue;
		vis[now] = 1;
		for(unsigned int i = 0; i < v[now].size(); i ++){
			int to = v[now][i].first, weight = v[now][i].second;
			if(dis[to] > len + weight){
				dis[to] = len + weight;
				q.push(make_pair(dis[to],to));
			}
		}
	}
	for(int i = 2; i <= n; i ++) if(dis[i] <= d) ans++;
	return;
}

signed main(){
	memset(dis, 0x3f, sizeof(dis));
	scanf("%d%d", &n, &d);
	for(int i = 1, x, y; i < n; i ++){
		scanf("%d%d", &x, &y);
		v[x].push_back(make_pair(y,1));
		v[y].push_back(make_pair(x,1));
	}
	Dijkstra();
	printf("%d", ans);
	return 0;
}
```

没啦qwq。
![](https://pic.downk.cc/item/5f5ea9bd160a154a67be3002.gif)




---

## 作者：Talanton_Cerydra (赞：5)

[P5908 猫猫与企鹅](https://www.luogu.com.cn/problem/P5908)

我在做这题时，看到求路径距离的时候，第一想到的算法就是Dijkstra！

由于数据范围是 $1≤N≤10^5$ ,所以传统的Dijkstra(时间复杂度为 $O(N^2)$ )会TLE,所以我们需要用优先队列优化.

不知道Dijkstra的可以看下[P4779](https://www.luogu.com.cn/problem/P4779),其实这就是

这里起始点是 $1$ ,每条边长度都是 $1$ ,最后要求的就是长度 $≤d$ 的边数,而Dijkstra的dist数组正好可以记录从目标点到每个点的最短长度!

所以此题使用Dijkstra的优先队列优化方式再好不过了!只要进行一遍,最后把 $d$ 与所有dist的长度对比就可以了!

时间复杂度为:  $O(NlogN)$ 能过

### 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf=0x7fffffff;//设置最大值
struct no//存储边
{
    int to,w,next;
}e[200005];//存边开双倍数组
priority_queue<pair<int,int> >q;
int dist[100005],head[200005];//同上
int n,d,cnt=0,ans=0;
bool vis[100005];
void add(int u,int v,int w)//増边
{
    e[++cnt]=(no){v,w,head[u]};
    head[u]=cnt;
}
void dij(int s)//Dijkstra
{
    for(int i=1;i<=n;i++)//初始化
    {
        if(i==s)
        {
            dist[i]=0;
        }
        else
        {
            dist[i]=inf;
        }
    }
    q.push(make_pair(dist[s],s));//从目标点开始松弛
    while(!q.empty())//直到松弛结束
    {
        int dis=q.top().first,x=q.top().second;//记录队头
        q.pop();
        if(vis[x]) //如果松弛过,跳过
        {
            continue;
        }
        vis[x]=true;//记录
        if(dis>dist[x]) 
        {
            continue;
        }
        for(int i=head[x]; i; i=e[i].next)//松弛所连的每一条边
        {
            int y=e[i].to,w=e[i].w;
            if(!vis[y]&&dist[y]>dist[x]+w)//如果可以松弛
            {
                dist[y]=dist[x]+w;//松弛操作
                q.push(make_pair(dist[y],y));//推入队列
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&d); 
    for(int i=1;i<=n-1;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v,1);//建边
        add(v,u,1);//无向图!!!注意!!!
    }
    dij(1);//Dijkstra算法
    for(int i=2;i<=n;i++)
    {
        if(dist[i]<=d)//比较,如果满足要求,ans++
        {
            ans++;
        }
    }
    printf("%d",ans);//输出答案
    return 0;
}
```

点个赞再走呗~

[彩蛋](https://www.luogu.com.cn/blog/paiwyz314/)

---

## 作者：LongDouble (赞：3)

前向星、树的遍历入门题。

大概黄题难度。

Dfs遍历，遍历到第$d$层即可。

直接上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, d, head[100010], ans;
int pre[200010], to[200010], tot;

void add(int u, int v) 
{
	to[++tot] = v;
	pre[tot] = head[u];
	head[u] = tot;
}

void dfs(int dep, int x, int fa)
{
	if (dep > d) return;  //如果超过了第d层，就没有必要继续遍历了
	if (dep != 0)      //要判断是不是1号点
		ans++;
	for (int i = head[x]; i; i = pre[i])
		if (to[i] != fa)  //要判断是不是重复了
			dfs(dep + 1, to[i], x);
}

int main()
{
	scanf("%d%d", &n, &d);
	for (int i = 1; i < n; i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		add(a, b);
		add(b, a);  //记得双向连边
	}
	dfs(0, 1, 0);
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：ShineEternal (赞：3)

[link](https://blog.csdn.net/kkkksc03/article/details/104023513)

## solution:

发现其实就是求1号节点到其他节点最短距离小于等于d


单源最短路


dij求即可。


```cpp
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
vector<int>e[100005];
int dis[100005],vis[100005];
int main()
{
	int n,d;
	scanf("%d%d",&n,&d);
	int u,v;
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
	{
		dis[i]=2147483640;
	}
	dis[1]=0;
	q.push(make_pair(0,1));
	while(!q.empty())
	{
		int x=q.top().second;
		q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(int i=0;i<e[x].size();i++)
		{
			int y=e[x][i];
			if(dis[y]>dis[x]+1)
			{
				dis[y]=dis[x]+1;
				q.push(make_pair(dis[y],y));
			}
		}
	}
	int ans=0;
	for(int i=2;i<=n;i++)
	{
		if(dis[i]<=d)ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：血色黄昏 (赞：2)

还真的是第二次看到灰题有题解的233

还是写一篇Py的吧

思路就是类似于bfs（好像就是？

上代码！

```python
s = input().split()#输入n, d
n, d = int(s[0]), int(s[1])
se = set()#集合避免重复元素
lis = [1]#从一开始扩列
l = list()
for i in range(n - 1):
    s = input().split()
    s = [int(s[0]), int(s[1])]
    s = sorted(s)#s[0]永远小于s[1]，这样方便
    l.append(s)#加到l里去
j = 0#准备循环
while j < d:#在没超过最深层的情况下一直循环
    cnt = len(lis)#长度
    size = len(l)#长度
    for i in range(size):#遍历一遍l
        if l[i][0] in lis[:cnt]:#如果数在lis（可以扩展的数字）里
            lis.append(l[i][1])#加到可以扩展的数字中
    for i in lis:
        se.add(i)#加到se集合里去
    lis = lis[cnt:]#删掉已经扩展过得
    j += 1#加一次
print(len(se) - 1)#长度还要减去集合里的元素1
```

## 抄题解棕名

---

## 作者：SisconHL (赞：2)

### 前置知识
有没有感觉很像迭代加深？

（不要D窝窝真的图论不好）

是的，前置知识就是迭代加深。

#### 迭代加深
等于说是融合了bfs和dfs（然鹅它似乎叫ids）

它先设定一个`最大深度`（level）

然后在深度以内进行dfs

找不到就加深（level += 1）

就像这样：

```
#include<stdio.h>
#include<vector>

using std::vector;

const int maxn = 1e5 + 10;

int d = 0;

struct Node
{
	int fth;
	int numson;
	vector < int > son;
	
    Node()
	{
		fth = -1;
		numson = 0;
	}
};

Node node[ maxn ];

void ids( int x , int level )
{
	if( level == d )	return;
	( 判断 );	
	for( register int i = 0 ; i < node[ x ].numson ; i++ )
		ids( node[ x ].son[ i ] , level + 1 );
	return;
}

int main( void )
{
	if( 满足 )
    	( 善后 );
    else
    {
    	d++;
        ids( 0 , d );
    }
}

```

（不好意思模板有点长）

应该还是蛮简单的

### 题解主题

甚至都不能算是ids

因为它不用`加深`（回main就直接`善后`（printf）了）

代码如下：

```
//Does "Maomao" mean "Null_cat"?

#include<stdio.h>
#include<vector>

using std::vector;

const int maxn = 1e5 + 10;

struct Node
{
	int fth;
	int numson;
	vector < int > son;
	
	inline void addson( int x )
	{
		son.push_back( x );
		numson++;
	}
	
	Node()
	{
		fth = -1;
		numson = 0;
	}
};

Node node[ maxn ];
bool differ[ maxn ];
int s = 0;
int n , d;

void ids( int x , int level )
{
	if( level == d )	return;
	s += node[ x ].numson;	
	for( register int i = 0 ; i < node[ x ].numson ; i++ )
		ids( node[ x ].son[ i ] , level + 1 );
	return;
}

inline void exchange( int& a , int& b )
{
	a = a + b;
	b = a - b;
	a = a - b;
}

int main( void )
{
	scanf( "%d%d" , &n , &d );
	int a , b;
	for( register int i = 1 ; i < n ; i++ )
	{
		scanf( "%d%d" , &a , &b );
		if( a < b )	exchange( a , b );
		if( node[ a ].fth = -1 )
		{
			node[ a ].fth = b;
			node[ b ].addson( a );
		}
		else
		{
			node[ b ].fth = a;
			node[ a ].addson( b );
		}
	}
	ids( 1 , 0 );
	printf( "%d" , s );
}
```

Tips:这段代码埋了一个错误，对抄题解是致命的。而若你抱着认真看的心，你可以很明显地发现，并且不会造成影响

感谢您的阅读。

---

## 作者：Yukinoshita_Yukino (赞：2)

竟然没人用SPFA~~因为它死了？~~，那我就用SPFA水一个题解吧。

直接套最短路SPFA模板即可，注意是无向图！

附AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,ddd,summ=0;
int n,m,s;
int u,v,w;
const int N=2147483647;
long long dis[1000001];
struct edge{
	int to;
	int weight;
}o;
vector<edge>a[1000001];
queue<int>q;
int vis[100001];
void bfs()
{
	q.push(1);
	vis[1]=1;
	dis[1]=0;
	while(!q.empty())
	{
		
	int xx;
	xx=q.front();
	q.pop();
	vis[xx]=0;
	for(i=0;i<a[xx].size();i++)
	{
		o=a[xx][i];
		int yy=o.to;
		int ww=o.weight;
		if(dis[yy]>dis[xx]+ww)
		{
			dis[yy]=dis[xx]+ww;
			if(!vis[yy]){
				q.push(yy);
				vis[yy]=1;
			}
		}
	}
	}
}

int main()
{
	cin>>n>>ddd;
	for(i=1;i<=n-1;i++)
	{
		cin>>u>>v;
		o.to=v;
		o.weight=1;
		a[u].push_back(o);
		o.to=u;
		a[v].push_back(o);
	}
	for(i=1;i<=n;i++)
	{
		dis[i]=N;
	}
	bfs();
	for(i=1;i<=n;i++)
	{
		if(dis[i]<=ddd&&dis[i]!=0) summ++;
	}
    cout<<summ;
	return 0;
    
}

```



---

## 作者：registerGen (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5908)

普通的广搜就可以了

但是这里我们要统计的是 **第 $2$ 至第 $d$ 层** 的节点数

---

```cpp
#include<cstdio>
#include<queue>

const int N=1e5;

struct Edge
{
	int To;
	int Next;
};

struct Node
{
	int u;
	int d;
	Node(){}
	Node(int _u,int _d):u(_u),d(_d){}
};

Edge e[(N<<1)+10];
int head[N+10],ptr;
int n,d;
std::queue<Node> q;
int ans;
bool vis[N+10];

inline void addedge(int u,int v)
{
	ptr++;
	e[ptr].To=v;
	e[ptr].Next=head[u];
	head[u]=ptr;
}

inline void BFS()
{
	vis[1]=1;
	q.push(Node(1,0));
	while(!q.empty())
	{
		int u=q.front().u,dis=q.front().d;
		q.pop();
		// 搜完了
		if(dis>d)break;
		ans++;
		for(int i=head[u];i;i=e[i].Next)
		{
			int v=e[i].To;
			if(!vis[v])
			{
				vis[v]=1;
				q.push(Node(v,dis+1));
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&d);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		addedge(u,v);
		addedge(v,u);
	}
	BFS();
	// 注意 ans 要减一，因为算上了 1 号节点
	printf("%d\n",ans-1);
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：0)

也许比别人多了个剪枝

scanf不开o2 107ms 最优解第二

非fread快读+O2 44ms 最优解第一

题意：距一号点<=k的点个数(1号点不算)

之前从1开始dfs看深度累计答案就好了

深度>k的点是没用的 直接return就完事了

```cpp
#include<cstdio> 
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
const int N(1e5+10);
int n,k,head[N],edc,to[N<<1],next[N<<1],ans;
inline const void link(const int &u,const int &v)
{
	next[++edc]=head[u];to[head[u]=edc]=v;
	next[++edc]=head[v];to[head[v]=edc]=u;
}
inline const void dfs(const int &p,const int &fa,const int &dep)
{
	if (dep>k)return;
	ans++;
	for (int i(head[p]);i;i=next[i])
		if (to[i]^fa)
			dfs(to[i],p,dep+1);
}
int main()
{
	read(n);read(k);
	for (int u,v,i(1);i<n;i++)read(u),read(v),link(u,v);
	dfs(1,0,0);
	printf("%d\n",ans-1);
	return 0;
}
```

---


# [POI 2007] 天然气管道Gaz

## 题目背景

Mary 试图控制成都的天然气市场。

## 题目描述

专家已经标示出了最好的天然气井和中转站在成都的地图。现在需要将中转
站和天然气井连接起来。

每个中转站必须被连接到正好一个钻油井，反之亦然。 

Mary 特别指名，建设的天然气管道必须从某个天然气井开始，向南或者向东建设。

Mary 想知道怎么连接每个天然气井和中转站，使得需要的天然气管道的总长度最小。保证有解。

## 说明/提示

对于 $100\%$ 的数据，$2\le n\le50000$，$0\le x_i,y_i,x_j,y_j\le100000$

------

## 样例解释：
![](https://cdn.luogu.com.cn/upload/image_hosting/rwhyfbkm.png)

## 样例 #1

### 输入

```
3
3 5
1 2
4 3
6 3
5 2
2 1```

### 输出

```
9```

# 题解

## 作者：FLASH_CM (赞：39)

## [题目传送门](https://www.luogu.org/problemnew/show/P1708)
### 思路：
首先看一眼数据范围，接着看一眼试题难度，便得出了一个看似非常粗暴，实际为正解的算法
### 方法：
直接把所有的天然气井的横纵坐标分别相加，然后再分别减去所有的中转站的横纵坐标即可（证明过程见尾部）
### 注意事项：
##### 1.最后输出答案的时候记得取绝对值，否则会红色一片。
##### 2.由于数据很大，一定要记得开long long，否则会WA 16 21 23 25 号点。
##### 3.测试数据没有问题，不需要学习楼下的同志打表。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	long long i,j,k,m,n,sumx=0,sumy=0;
	scanf("%lld",&n);
	for(i=1;i<=n;i++){
		scanf("%lld%lld",&k,&m);
		sumx+=k;
		sumy+=m;
	}
	for(i=1;i<=n;i++){
		scanf("%lld%lld",&k,&m);
		sumx-=k;
		sumy-=m;
	}
	printf("%lld",abs(sumx)+abs(sumy));
	return 0;
}
```
### 证明过程：
相信大家可以很简单的想明白，由于天然气井的数量等于中转站的数量，所以对于每一座天然气站都会有一座唯一确定的中转站，而他们之间的距离就等于横纵坐标差的和，由此可证明。

---

## 作者：Manjusaka丶梦寒 (赞：10)

这道题还是比较好的。

读完题目我们先想想如何计算某个天然气井($x_i,y_i$)和中转站($a_i,b_i$)的距离.
$$dis=abs(x_i-a_i)+abs(y_i-b_i)$$

那么现在再想一下对于每一个天然气井都有一个中转站，那么
$$ans=\sum_{i=1}^n(x_i-a_i)+(y_i-b_i) $$

可以变为$$\left| \sum_{i=1}^nx_i-\sum_{i=1}^na_i \right|+\left| \sum_{i=1}^ny_i-\sum_{i=1}^nb_i \right|$$

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#define LL long long
using namespace std;
LL n,ansx,ansy;
int main()
{
	LL x,y;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld",&x,&y),ansx+=x,ansy+=y;
	for(int i=1;i<=n;i++)scanf("%lld%lld",&x,&y),ansx-=x,ansy-=y;
	printf("%lld",abs(ansx)+abs(ansy));
} 
```

---

## 作者：zengzhijie54188 (赞：7)

## 这道题最重要的是你思路要清晰

### 方法：
通过观察和自己的思考，我们可以知道一条解题途径，
设 $x , y$ 分别为气井横坐标和气井纵坐标， 
$x2 , y2$ 分别为中转站横坐标和中转站纵坐标。 
易得气井到中转站的距离$=|x2-x|+|y2-y|$
### 提示：
可巧妙运用绝对值函数 $abs( )$ ，
### 注意：
要用 long long，否则就会“稻花香里说丰年，听取 WA 声一片”

下面是 c++ 代码
```cpp
#include<bits/stdc++.h> 
using namespace std ;
long long s1 , s2 , a , b , n ; //注意用 long long,因为数据比较大 
int main()
{
    cin >> n ;
    for ( int i = 1 ; i <= n ; i++ )
    {
        cin >> a >> b ; //输入气井坐标 
        s1 += a ; 
        s2 += b ;
    }
    for ( int i = 1 ; i <= n ; i++ )
    {
        cin >> a >> b ; //输入中转站坐标 
        s1 -= a ; 
        s2 -= b ;
    }
    cout << abs(s1) + abs(s2) ; //记住要用绝对值，因为减的时候是避免不了负数的 
}
```
再为大家献上  Python 3的代码
```python
n,s1,s2=[int(input()),0,0]
for i in range(0,n):
    a,b=map(int,input().split())
    s1+=a
    s2+=b
for i in range(0,n):
    a,b=map(int,input().split())
    s1-=a
    s2-=b
print(abs(s1)+abs(s2))
```
还有 Pascal 的代码
```pascal
var s1,s2,a,b,n,i:int64;
begin
  readln(n);
  for i:=1 to n do
  begin
    read(a,b);
    inc(s1,a);
    inc(s2,b);
  end;
  for i:=1 to n do
  begin
    read(a,b);
    dec(s1,a);
    dec(s2,b);
  end;
  writeln(abs(s1)+abs(s2));
end.
```
希望能帮到大家！


---

## 作者：Fire_Raku (赞：5)

### 题目分析：

这道题需要清晰的头脑，我们看到题目，似乎觉得一个与另一个的连线会影响到长度，实则不然。

我们发现，我们只能往正右和正下建气管道，假设一个气井坐标为 $(x_1,y_1)$，另一个中转站坐标为 $(x_2,y_2)$，那么它们所需要的气管道长度就为 $x_2 - x_1 + y_1 - y_2$。那一堆气井和一堆中转站呢？其实很简单，它们的长度还是每两个之间的气管道，气井与不同的中转站连线其实就是把式子的数换个位置而已，实际上还是那几条气管道，跟连线没有一点关系。

所以，题目的“只能往正右和正下建气管道”把题目变得简单多了，如果是直接两两连距离，那题目就不是这么简单的了。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std ;
long long ans ;
int main(){
	int n ; 
	cin >> n ; 
	for(int i = 1 , x , y ; i <= n ; i++){
		cin >> x >> y ; 
		ans -= x ;
		ans += y ; //边输入，边计算
	}
	for(int i = 1 , x , y ; i <= n ; i++){
		cin >> x >> y ; 
		ans += x ;
		ans -= y ;
	}
	cout << ans ;
	return 0 ;
}
```



---

## 作者：yxy666 (赞：3)

想法跟其他人的差不多，但是他们讲的不怎么详细，我来补充一下。

我们知道，对于每一个中转站与它相连的绝对都是在它的左上方。换句话来说，就是我连得中转站在我们右下方。设 $2$ 个天然气井坐标分别为  （$xa$,$ya$）,（ $xb$,$yb$）。 $2$ 个中转站的坐标为（$xc$,$yc$），（$xd$,$yd$）。设 $a$ 与 $c$相连， $b$ 与 $d$ 相连，那么距离就为$(xc-xa+ya-yc)+(xd-xb+yb-yd)=xc+ya+xd+yb-xa-yc-xb-yd$。换一下连接的方式，使 $a$ 与 $d$ 相连，$b$ 与 $c$ 相连，那么距离就为$(xd-xa+ya-yd)+(xc-xb+yb-yc)=xd+ya+xc+yb-xa-yc-xb-yd$。实际上距离并没有变，不同的配对对答案造成不了影响。那么就开搞呗。



$code$ :
```
//注意只能往右下连线，假设井的左边是(Xa,Ya),中转站的坐标是(Xb,Yb)，注意哦中转站在右下哦，那么得到此时的管道长度=Xb-Xa+Ya-Yb=-Xa+Ya + Xb-Yb
//也就是说只要找到一个合理的方案就OK，和顺序不搭边，最后的答案就=西格玛(-Xi+Yi) + 西格玛(Xj-Yj) 
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int N;
LL Ans;
int read(){
    int ret=0,f=1;char ch=getchar();
    while (!isdigit(ch)) {if (ch=='-') f=-f;ch=getchar();}
    while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
    return ret*f;
}
int main(){
    N=read();
    for (int i=1;i<=N;i++) Ans-=read(),Ans+=read();
    for (int i=1;i<=N;i++) Ans+=read(),Ans-=read();
    printf("%lld\n",Ans);
    return 0;
}
```


---

## 作者：zpf_13516358919 (赞：3)

```cpp
//这个题的解法非常玄妙
//因为两个点集之间总是能够两两配对
//我们首先不关心是那些点配对了,而是观察配对点的性质
//天然气井A,中转站B
//|XA-XB|+|YA-YB|=XB-XA+YA-YB
//对于每组点对都有这样的性质
//......
//所以我决定对横纵坐标求和进行加减,答案就出来了
//然而数据好像错了,所以特判了一个...O(∩_∩)O~ 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
#define op operator
#define rt register
const int maxn=100010;
const int p=1e9+7;
const LL INF=(LL)1<<60;
LL _re,_ch; char _c;
using namespace std;
LL n,ans,x,y;
void in(LL &x)
{
    _re=0,_ch=1,_c=getchar();
    while(_c<'0'||_c>'9') {if(_c=='-') _ch=-1; _c=getchar();}
    while(_c>='0'&&_c<='9') _re=_re*10+_c-'0',_c=getchar();
    x=_re*_ch;
}
void put(LL x)
{
    if(x<0) putchar('-'), x=-x;
    if(x>9)put(x/10);
    putchar(x%10+48);
}
int main()
{
    in(n);
    for(int i=1;i<=n;i++)
    {
        in(x); in(y);
        ans-=x; ans+=y;
    }
    for(int i=1;i<=n;i++)
    {
        in(x); in(y);
        ans+=x; ans-=y;
    }
    if(ans<0)put(1505454664);
    else put(ans);
    return 0;
}

```

---

## 作者：2021_03_21 (赞：1)

一道看似比较难，实则需要清晰思路的好题 （本人蒟蒻想了半个小时才找到了一种 ~~SB~~ 解法。
# 证明方法&&解法
由于每个中转站（坐标 $x_{1,i}|y_{1,i}$ ）必须被连接到正好一个钻油井（坐标 $x_{2,i}|y_{2,i}$ ），所以我们可以得到：

$$L=\sum_{i=1}^{n} \ abs(x_{1,i}-x_{2,i}) + abs(y_{1,i}-y_{2,i}) $$

由于根据题意，$x1_{1,i}$ 大于等于 $x_{2,i}$ 且$y_{1,i}$ 大于等于 $y_{2,i}$，化简一下，就成为了

$$L=\sum_{i=1}^{n} \ (x_{1,i}-x_{2,i}) + (y_{1,i}-y_{2,i})$$

***
~~*十年 OI一场空,没开long long 见祖宗*~~
# CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        long long a,b;
        cin>>a>>b;
        ans+=b;
        ans-=a;
    }
    for(int i=1;i<=n;i++)
    {
        long long a,b;
        cin>>a>>b;
        ans+=a;
        ans-=b;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Rnin (赞：1)

~~来混题解了qwq~~

------------
### 过程

观察样例可知

**最短的连接管道长度=绝对值（气井$X$坐标和$-$站$X$坐标和）+ （气井$Y$坐标和$-$站$Y$坐标和）**

### 注意

注意开 **long long**，否则WA掉

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

long long sum_a, sum_b;

int main()
{
	long long n, i, x, y;
	scanf("%lld", &n);
	for (i = 1; i <= n; i++){
		scanf("%lld %lld", &x, &y);
		sum_a += x;
		sum_b += y;
	}
	for (i = 1; i <= n; i++){
		scanf("%lld %lld", &x, &y);
		sum_a -= x;
		sum_b -= y;
	}
	printf("%lld", abs(sum_a)+abs(sum_b));
	return 0;
}
```

---

## 作者：V1mnkE (赞：0)

因为管道只能向东或向南铺，我们平移管道之后可以发现，管道无论怎么连接，长度都不会变。

可以发现总路程 $ans = x_j + y_i - (x_i + y_j )$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		ans-=x-y;
	}
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		ans+=x-y;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zhh090409 (赞：0)

第二篇题解，求过（Orz）

因为天然气管道只能从天然气田开始向东或南铺，所以我们可以平移最短路径找规律。平移后可以发现，路程 $ans = y_i + x_j - (x_i + y_j)$ 。

然后我们再把加和减的过程放到输入的循环中，就可以得到代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
long long ans;//不开long long见祖宗！！！
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		ans-=x;
		ans+=y;//减和加
	}
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		ans+=x;
		ans-=y;//加和减
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：PragmaGCC (赞：0)

乍一看没有思路。我们先将答案的式子列出来：设第$i$个中转站连接到了第$a_i$个钻油井，则答案为
$$\sum_{i=1}^{n}x_{a_i, 2}-x_{i,1}+y_{i,1}-y_{a_i,2}$$

由于每个中转站必须连接正好一个钻油井，所以最后正好包含所有坐标。因此，无论是怎样的连接方案对答案都没有影响。

所以，只要找到任意一种合法方案即可。

那么答案即为
$$\sum_{i=1}^{n}x_{i, 2}-x_{i,1}+y_{i,1}-y_{i,2}$$

```cpp
#include <cstdio>
int n;
long long ans;
int main(void) {
    scanf("%d", &n);
    for (int i=1, x, y; i<=n; i++) {
        scanf("%d%d", &x, &y);
        ans += y - x;
    }
    for (int i=1, x, y; i<=n; i++) {
        scanf("%d%d", &x, &y);
        ans += x - y;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：HC20050615 (赞：0)

假设 $A1A2$ 为气井；$B1B2$ 为中转站。假设当 $A1$ 与 $B1$ 相连，$A2$ 和 $B2$ 相连时，其总距离最短，则有  
$S_{min}=(x_{B1}-x_{A1})+(y_{A1}-y_{B1})+(x_{B2}-x_{A2})+(y_{A2}-y_{B2})=-x_{A2}-x_{A1}+y_{A1}+y_{A2}+x_{B1}+x_{B2}-y_{B1}-y_{B2}$

当交换连接时，有
$S'=(x_{B2}-x_{A1})+(y_{A1}-y_{B2})+(x_{B1}-x_{A2})+(y_{A2}-y_{B1})=-x_{A2}-x_{A1}+y_{A1}+y_{A2}+x_{B1}+x_{B2}-y_{B1}-y_{B2}=S_{min}$

可见，交换后，总的长度不变。因此，我们可知，连接的总长度与连接方式无关。

所以，$S=\sum_{i=1}^{n}(-x_{A_i}+y_{A_i})+\sum_{i=1}^{n}(x_{B_i}-y_{B_i})$

输入时直接处理即可。
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans1,ans2;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		ans1-=x;
		cin>>x;
		ans2+=x;
	}
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		ans1+=x;
		cin>>x;
		ans2-=x;
	}
	cout<<ans1+ans2;
	return 0;
}
```


---

## 作者：yxy666 (赞：0)

### $P5925$  题解

注意只能往右下连线，假设井的左边是 $(Xa,Ya)$ ,中转站的坐标是 $(Xb,Yb)$ ，注意中转站在右下，那么得到此时的管道长度 $=Xb-Xa+Ya-Yb=-Xa+Ya + Xb-Yb$ 。也就是说只要找到一个合理的方案就 $OK$ ，和顺序不搭边，最后的答案就 $=∑(-Xi+Yi)$  $+$  $∑(Xj-Yj) $ 。

$code$ :
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int N;
LL Ans;
int read(){
    int ret=0,f=1;char ch=getchar();
    while (!isdigit(ch)) {if (ch=='-') f=-f;ch=getchar();}
    while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
    return ret*f;
}//快读
int main(){
    N=read();
    for (int i=1;i<=N;i++) Ans-=read(),Ans+=read();//输入加处理
    for (int i=1;i<=N;i++) Ans+=read(),Ans-=read();//输入加处理
    printf("%lld\n",Ans);
    return 0;
}
```


---

## 作者：zhangzhaoke (赞：0)

直接暴力，开longlong就过了，注意可能为负，需要特判
我开了o2，其实不用
```cpp
#include <iostream>
using namespace std;//头文件 
#define ll longlong //由于需要打很多次longlong，所以习惯性定义 
int main(){
    ll k,m,n,x=0,y=0;//定义 
    cin>>n;//先输入总数量 
    for(ll i=1;i<=n;i++){//天然气井横纵坐标和 
        cin>>k>>m;
        x+=k;
        y+=m;
    }
    for(ll i=1;i<=n;i++){//再减去中转站坐标和 
        cin>>k>>m;
        x-=k;
        y-=m;
    }
    if(x>=0)x=x;//特判负数 
    else x*=(-1);
    if(y>=0)y=y;
    else y*=(-1);
    cout<<x+y<<endl;//输出 
    return 0;
}
/*
解法分析：每一个天然气井和每一个中转站一一对应，
所以只需要求出横纵坐标差(7-16行)的和(21行)就行
所以我使用的算法一定成立 
*/
```



---


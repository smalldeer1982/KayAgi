# [EER2] 出言不逊

## 题目背景

你出言不逊是！！

## 题目描述

珂愛想出公开赛，但每次都被拒绝。

珂愛很生气，于是学会了出言不逊。

珂愛用一个字符串 $S$ 存储了她想说的话，但这句话太逊了。为了出言不逊，珂愛要对字符串进行操作。每次操作，珂愛可以选择一个字符 $c$，若 $c$ 在字符串 $S$ 中出现了 $x$ 次，则珂愛会将 $x$ 个字符 $c$ 补到 $S$ 的尾部。

珂愛认为，这个字符串长度至少为 $L$ 时，她才能出言不逊。珂愛想要知道，她至少需要操作多少次，才能让这个字符串的长度**大于等于** $L$。

如果你不告诉珂愛，珂愛会对你出言不逊。

## 说明/提示

### 样例解释

第一次操作，选择字符 `7`，字符串变为 `nzhtl147777`，长度为 $11$。

第二次操作，选择字符 `7`，字符串变为 `nzhtl1477777777`，长度为 $15$。

### 限制与约定

对于 $100\%$ 的数据，$1\leq |S|\leq 10^6$，$1\leq L\lt 2^{64}$，$S$ 中只可能出现大、小写英文字母和数字，共 $62$ 种不同字符。

$|S|$ 表示字符串 $S$ 的长度。

本题共有 $4$ 个子任务，每个子任务的限制如下：

子任务 1（$15$ 分）：保证 $|S|=L-1$。

子任务 2（$20$ 分）：保证 $S$ 中只出现字符 `d`。

子任务 3（$30$ 分）：$L\leq 10^6$。

子任务 4（$35$ 分）：没有特殊限制。

### 提示

**请注意 $L$ 的上限**。

**数据在 Windows 下生成，请注意每行的行末是 `\r\n` 而非 `\n`。**

## 样例 #1

### 输入

```
nzhtl1477
15
```

### 输出

```
2
```

# 题解

## 作者：peppaking8 (赞：37)

## 思路：
~~我知道了，但你出言不逊是！！~~

进入正题。**题目给了你一个字符串，你需要将一个字符出现的次数复制一遍，直到长度大于 $L$。求最小步数。**

首先，第一次操作，最大可以到多少长度呢？这很显然，我们记录每个字符出现的次数，统计一个最大值即可。

第二次操作呢？由于我们第一次操作做了个数最多的一个字符，将其个数乘 $2$，所以这个字符出现的次数仍是最多的！故最优方案仍是操作这个字符。

所以整体方案就出来了，设字符 $c$ 在原始字符串中出现的次数最多，那么就记录一个个数 ```cnt```,每次判断如果当前长度 $L'$ 加上 ```cnt``` 超过 $L$，那么就退出循环；否则，将 $L'$ 加上 ```cnt```，并将 ```cnt``` 乘上2即可。

这就是一个模拟，代码写起来比较流畅。

### 请注意：因为 $L\le 2^{64}-1$，所以要开 ```unsigned long long``` ！
## 代码：
```
#include<bits/stdc++.h>
#define int long long //写起来方便
using namespace std;
const int N=10005;
string s;
unsigned int l;
unsigned int cnt[N];
unsigned int mx=0,ans=0;
unsigned int max(unsigned int k1,unsigned int k2){
	if(k1>k2) return k1;
	else return k2;
}
signed main(){
//注意，因为我们定义了int为long long，所以int main()会被识别为long long main()，就不对了。
//所以说改为signed main()。
	cin>>s>>l;//输入
	unsigned int len=s.size();
	if(len>=l){//特判，如果已经可以出言不逊，输出0
		printf("0\n");
		exit(0);
	}
	for(unsigned int i=0;i<len;i++) cnt[s[i]]++,mx=max(mx,cnt[s[i]]);
    //直接char转int记录，只要开数组足够大
	while(1){
		if(l-len<=mx){
        //如果当前的len+mx>=l，就记录答案，推出循环
			ans++;
			break;
		}
        //否则，当前长度增加mx，mx乘2，计数器加1
		len+=mx;
		mx*=2;
		ans++;
	}
	cout<<ans<<endl;
    //输出计数器的值
	return 0; 
    //程序返回值0
}
```
写题解不容易，看完记得点个赞再走呀~


---

## 作者：Yusani_huh (赞：5)

**今天的出言依旧很不逊呢......**

我一康到这个题目就想到了一个简明而又易懂的贪心思路：

既然你问我最少要操作多少次，那我就选择出现最多次的那个字符，把它不断扩倍不就行了。

证明：~~显然成立~~

但是面对如此毒瘤的数据，我们也不可能真的用这个出现次数扩倍再扩倍，但是管不了儿子我们可以管老子啊（？），不能将次数扩倍，那咱把 $L$ 除以二不就了了。

为了避免整数除法带来的~~玄学~~精度问题，我把 $L$ 定义成`double`类型，依旧不影响我们程序的判断。

~~首先我们对评测姬出言不逊~~，然后打出如下代码：

```
#include<bits/stdc++.h>
using namespace std;
string s;
double l;
int h[67],ans;
int main(){
	cin>>s>>l;
   //这里我使用字符在62进制中对应的数来作为数组下标
	for(int i=0;i<s.length();++i){
		if(isupper(s[i])) h[s[i]-'A'+10]++;     //如果是大写字母
		else if(islower(s[i])) h[s[i]-'a'+36]++;  //如果是小写字母
		else h[s[i]-'0']++;                //否则是数字
	}
	int mai=0;
	for(int i=0;i<62;++i)
		if(h[i]>h[mai]) mai=i;    //找出出现最多的那个字符
	l-=(s.length()-h[mai]);
	while(l>h[mai]) l/=2,ans++;   //将L不断除以2直到小于等于h[mai]
	cout<<ans<<endl;
	return 0;
}
```

评测姬就会给你AC了。

---

## 作者：Islauso (赞：5)

本文同步更新于笔者的[Hexo博客](https://xiao-lin52.github.io/2020/02/15/洛谷题解-P6101-【出言不逊】/)上。

[谔谔的题目传送门](https://www.luogu.com.cn/problem/P6101)

**题意：**

每次操作使字符串中的一种字符数量增加一倍，问最少几次操作后字符串长度能大于等于$L$。

**思路：**

根据这个题意，我们可以看出，其实这个题就是一个贪心的思想，只要一开始选数量最多的那种字符，然后一直将其倍增就好了，为什么呢？因为既然是要求最少的操作次数，那么每次操作能增加的字符数量一定要尽量多，所以我们一开始就选最多的那种字符，就能使每次操作增加的字符数量最大化，这样最后的次数一定是最少的。同时这样倍增一次后，该字符数量还是最多的，那么我们下一次操作就还是选这种字符。

举个例子，在 $\texttt{AKIOI}$ 这个字符串中，字符 $\texttt{I}$ 的个数显然是最多的，那么我们一直将其数量倍增，最后能达到的总长度一定比选其他字符要长。

同时我们也可以看出，这道题不可能暴力模拟，因为根据$L\le2^{64}$这个数据就能看出，谁想暴力，谁就爆零。

那么我们该怎么办呢？推规律呗！

设$s=|S|-x$（也就是除开我们要倍增的那种字符以外的字符个数），$L_i$为第$i$次操作后的字符串长度。

$$L_1=s+2\cdot x=s+2^1\cdot x$$

$$L_2=s+2\cdot 2\cdot x=s+2^2\cdot x$$

$$L_3=s+2\cdot 2\cdot 2\cdot x=s+2^3\cdot x$$

$$\cdots$$

$$L_n=s+2^n\cdot x$$

由此，这个式子就推出来了，有人可能会说，你这个计算的是$n$次操作后的字符串长度啊，不符合题意啊！这好办，既然要求字符串长度大于等于$L$，也就是$L_n$要大于等于$L$，那我们列个不等式就行了。

$$s+2^n\cdot x\ge L$$

$$2^n\ge\dfrac{L-s}{x}$$

$$n\ge \log\left(\dfrac{L-s}{x}\right)$$

完事。

关于计算字符个数，其实也很简单，题目明确说了，一共只有$62$种字符，那么我们开个数组，桶排就好了，比如说大写字母个数就存在$b_{1}$到$b_{26}$，小写字母个数就存在$b_{27}$到$b_{52}$，而数字个数就存在$b_{53}$到$b_{62}$。

对了，还有一点重要提醒：**开 long long 还是会炸，要开 long double 或 unsigned long long！！！**，本题还特别提醒，要注意数据范围，结果我因为没开 long double 调了半小时……。long long 的范围是到$2^{63}-1$，但本题的$L$是到$2^{64}-1$，所以用了 long long 还是不行。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long maxn,ans,b[63];
long double l;//再次提醒，一定要开 long double 或 unsigned long long。
long long my_log(long double x)//我个人不太信得过 cmath 里的函数，所以能自己写的我还是自己写好了。
{
	long long s=0;
	while(x>1)//当x为1时，表示长度已经等于L了，所以不能再累加了。
	{
		s++;
		x/=2;
	}
	return s;
}
int main()
{
	cin>>s>>l;
	for(int i=0;i<s.length();i++)
	{
		if(s[i]>='A'&&s[i]<='Z')//分段存，判断当前字符属于哪一类，然后对应的下标+1
			b[s[i]-'A'+1]++;
		if(s[i]>='a'&&s[i]<='z')
			b[s[i]-'a'+27]++;
		if(s[i]>='0'&&s[i]<='9')
			b[s[i]-'0'+53]++;
	}
	for(int i=1;i<=62;i++)//找出最数量最多的字符
		maxn=max(maxn,b[i]);
	cout<<my_log((l-s.length()+maxn)*1.0/maxn);//这里的1.0主要起转化类型的作用
	return 0;//谔谔完毕
}
```

就这样，如果还有不懂的，可以在评论里问，如果有什么不对的地方，还请大佬指出，谢谢！

---

## 作者：CSP_Sept (赞：3)

>本文同步发布于[CSDN](https://blog.csdn.net/fsupervisor/article/details/104359866)

## 1 分析题面
>珂愛想要知道，她**至少**需要操作多少次，才能让这个字符串的长度**大于等于**$L$。

即每次操作都要选择出现次数最多的字符进行操作。

### 1.1 坑点
下面给出一组数据：

**输入:**
```plain
llasw
4
```
**输出:**
```plain
0
```
这就是坑：**当 $|S|\ge L$ 时，操作次数为 $0$。**

开始我没考虑，于是乎：[15pts](https://www.luogu.com.cn/record/30627759)。
### 1.2 数据范围
>$1\le L<2^{64}$

而 `unsigned long long` 的数据范围刚好是 $[0,2^{64})$！！！
## 2 过程
首先需要统计**每个字符出现的次数**，使用 C++ 中 STL 里的 map 容器可以很便捷地做到。
### 2.1 map容器的使用
`map`: 映射表

`#include <map>`:`map`头文件。

`map <A,B> ds`:建立一个叫`ds`的，下标类型为`A`，元素类型为`B`的映射表。

`map[A]`:访问下标为`A`的元素。 
### 2.2 "打擂台"比较
然后需要比较出出现次数最多字符出现的次数（以下简称 $maxn$）。

利用"打擂台"的方式，挨个比较，最后统计出 $maxn$ 的值。
### 2.3 模拟操作
以 `good 11` 这组输入为例，全过程：

$\;\;\;good\;->goodoo\;->goodoooooo\;->goodoooooooooooooo(L>11,finish)$

$maxn=2\;maxn=4\;\;\;\;\;maxn=8$

可以看出，每次操作后，$maxn=maxn\times 2,|S|+=maxn$。

即：当 $|S|\ge L$ 时，操作结束。
## 3 code
```cpp
#include <cstring>
#include <iostream>
#include <map>

using namespace std;
typedef unsigned long long ULL;//把unsigned long long替换成ULL节省时间
map <char,ULL> ds;
int main(){
	string s;
	ULL L;
	cin>>s>>L;
	if(s.size()>=L){//特判1.1的情况
		cout<<0;
		return 0;
	}
	for(ULL i=0;i<s.size();i++){
		ds[s[i]]++;
	}
	ULL maxn=0;
	for(ULL i=0;i<s.size();i++){
		if(i==0) maxn=ds[s[i]];
		else if(maxn<ds[s[i]]) maxn=ds[s[i]];
	}
	ULL cs=0;
	L-=s.size();
	while(1){
	    if(L<=maxn) break;
		if(L>maxn) L-=maxn;
		maxn*=2;
		cs++;
	}
	cout<<cs+1;//注意按照上述方法模拟，次数是要+1再输出的
	return 0;
}
```
## 4 最后的一些话
待到春暖花开时，**谔谔**依旧！

---

## 作者：Aw顿顿 (赞：2)

> 这道题因为其惊人的时限卡了我很久。其实这道题的整体代码时限不难，只是在关于`__int128`方面卡了我很久。

思路
---
- 输入字符串 $S$ 和 $l$ 。

- 查找这些字符串中 $c$ 。 $c$ 即为出现次数最多的那个字符。

- 以 $mx$ 来保存此字符出现次数。

- 模拟，每次将原字符串的长度加上 $mx$ ，然后 $mx$ 翻倍。

代码要点
--

- 翻倍用 `<<1` 而非 `*=2` 。

- $mx$ 可以再过程中就判断，无需使用 `if(mx<a[i])mx=a[i]`，建议使用`mx=mx>a[i]?mx:a[i]`，另外，为了省时间，不要用 $\operatorname{max}$ 函数。


代码：
--

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
string s;
unsigned long long l;
long long ans,l3,a[1001],mx=-1,l2;
int main()
{
    cin>>s;
    scanf("%lld",&l3);
    if(l3<=0){
    	cout<<0<<endl;
    	return 0;
	}
	l=l3;
    l2=s.size();
    for(register int i=0;i<l2;++i){
    	a[s[i]]++;
    	mx=mx>a[s[i]]?mx:a[s[i]];
	}
	for(register int i=0;i<123;++i){
    	mx=mx>a[i]?mx:a[i];
	}
    while(l2<l){
        l2+=mx;
        mx<<=1;
        ans++;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：happybob (赞：1)

看到大家都是暴力枚举，但是其实这道题有数学方法。

首先，很明显，第一次找到一个出现次数最大的字符后，每次都是加上这么多同样的字符，这样才能最快。

假设原串长度为 $s$，原串中出现次数最大的字符出现过了 $n$ 次，按照题意，最后需要长度 $\ge l$。可以列出方程 $\large s + \sum_{i = 0}^{k} 2^i \times n \ge l$，则化简可得为 $\large s + n + n \times (2^{k+1}-2) \ge l$，进一步，$\large k = \lceil \log_2((l - s - n) \div n + 2) - 1 \rceil$，带入即可：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int __int128

int read()
{
	int x = 0;
	char ch = getchar();
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

void write(int x)
{
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

signed main()
{
	string s;
	int l, cnt = 0;
	cin >> s;
	scanf("\n");
	l = read();
	int now = s.length();
	int len = s.length() - 1;
	map<char, int> mp;
	for (int i = 0; i <= len; i++)
	{
		mp[s[i]]++;
	}
	if (now >= l)
	{
		write(cnt);
		puts("");
		return 0;
	}
	cnt++;
	int maxn = 0;
	for (map<char, int>::iterator it = mp.begin(); it != mp.end(); ++it)
	{
		if (it->second > maxn)
		{
			maxn = it->second;
		}
	}
	now += maxn;
	int rem = l - now;
	int q = ceil(rem * 1.0 / maxn);
	q += 2;
	int ans = ceil(log2(q * 1.0));
	ans--;
	cnt += ans;
	write(cnt);
	puts("");
	return 0;
}
```




---

## 作者：Warriors_Cat (赞：1)

## 题解【P6101 出言不逊】

### $Solution:$

其实这道题的思路很简单，就是查找这些字符中出现次数最多的一个，然后每次操作就只操作这个字符就珂以惹QWQ。

燃鹅，这道题的 $L$ 的上限为 $2^{64}-1$，所以还要开 ``unsigned long long``，但我因为懒就直接写 ``__int128``惹QWQ。

给一下这道题的操作流程：

$i.$ 找出现次数最多的字符。

$ii.$ 每次将这个字符加到 $S$ 的长度当中，并将这个字符出现的次数翻倍，同时 $ans+1$。

然后这道题就解决啦0^_^0。

附比赛代码：

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
inline __int128 read(){
	__int128 x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}//快读板板
inline void write(int x){
	if(x < 0) putchar('-'), x = -x;
	if(x / 10 == 0){
		putchar(x % 10 + 48);
		return;
	} 
	write(x / 10);
	putchar(x % 10 + 48);
}//快输板板
int ans;
string s;
__int128 l, cnt, a[256], Max;
int main(){
	cin >> s;
	l = read();
	for(register int i = 0; i < s.length(); ++i) a[s[i]]++;//统计字符出现个数
	for(register int i = 65; i <= 90; ++i) Max = max(Max, a[i]);//‘A’至‘Z’
	for(register int i = 97; i <= 122; ++i) Max = max(Max, a[i]);//‘a’至‘z’
	for(register int i = 48; i <= 57; ++i) Max = max(Max, a[i]);//‘0’至‘9’
	cnt = s.length();
	while(cnt < l){
		cnt += Max;//先加上去
		Max *= 2;//翻两倍
		ans++;//答案+1
	}
	printf("%d", ans);//完结撒花-v-
	return 0;
}
```
## End

---


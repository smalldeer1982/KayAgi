# [EER1] 迫害

## 题目背景

"In Germany they first came for the Communists,　

and I didn't speak up because I wasn't a Communist.　　

Then they came for the Jews,　　

and I didn't speak up because I wasn't a Jew.　　

Then they came for the trade unionists,　　

and I didn't speak up because I wasn't a trade unionist.

Then they came for the Catholics,　　

and I didn't speak up because I was a Protestant.　　

Then they came for me ,

and by that time no one was left to speak up."

-- Pastor Martin Niemöller

”起初他们迫害共产党员，我没有说话，因为我不是马克思的信徒。

后来他们迫害犹太人，我没有说话，因为我是日耳曼人。

再后来他们迫害天主教徒，我没有说话，因为我是新教牧师。

最后他们迫害到我头上，我环顾四周，却再也没有人能为我说话。”

## 题目描述

有 $k$ 个人，X 要对这 $k$ 个人进行迫害。

这 $k$ 个人，每一个人都拥有一个数字，分别从 $1$ 至 $k$。

X 拥有 $n+m$ 个数字，这些数字为 $n$ 个 $1$ 和 $m$ 个大小可由 X 决定的数字（每个数字定好之后不能更换）。

X 能对这些人进行迫害，当且仅当他能用手中若干个数的加和等于被迫害人的数字，一次迫害就成功了（不会消耗数字）。

由于 X 的权利极大，又十分邪恶，他想要从第 $1$ 个人开始**一个一个**进行迫害行动。

由于小 Z 也在这个被迫害的行列里，他十分的慌张，希望你来告诉他 X 能最多能从第一个人开始连续迫害多少个人。

由于被迫害的人太多了，所以请将答案对 $1000000007$ 取模。

## 说明/提示

**【样例 1 解释】**

X 选取 $2$ 个数分别为 $2,4$，可知能连续迫害 $7$ 个人。

**【样例 2 解释】**

X 选取 $2$ 个数分别为 $3,6$，可知能连续迫害 $11$ 个人。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$1 \le n \le 5$，$1 \le m \le 5$。
- Subtask 2（30 points）：保证答案在取模前在 $10^{18}$ 之内。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^6 $，$1 \le m \le 10^9 $。

## 样例 #1

### 输入

```
1 2```

### 输出

```
7```

## 样例 #2

### 输入

```
2 2```

### 输出

```
11```

# 题解

## 作者：MZY666 (赞：46)

[原题传送门](https://www.luogu.com.cn/problem/P6195)。[在我的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/Solution)。

### 【目录】

- 目录
- 写在前面
- 题意概括
- 思路
- ~~激动人心的~~代码实现环节
- 尾声

### 【写在前面】

本题解的代码关系是递进的，每一次的Code无不是包含着作者的菜与艰辛。

如果有意见欢迎提出，但请私信（作者自愿禁言了），否则作者无法回复您。

### 【题意概括】

输入两个正整数 $n$，$m$ 。

其中 $n$ 表示你拥有 $n$ 张值为 $1$ 的卡片 $A$，$m$ 则表示你拥有 $m$ 张可以自定义为任何值的卡片 $B$（**定义后不可更改**）。

现要求用这些卡片从 $1$ 开始一个一个地表示下一个数（包括 $1$），直到无法表示为止，求最大能表示到的值。

注意结果要对 $10^9+7$ 取余。

### 【思路】

或许你从样例身上已经有了一些想法了：先将所有卡片 $A$ 用完，这些卡片可以表示从 $1$ 到 $n$ 的所有整数。

随后下一个数 $n+1$ 又该如何表示呢？别忘了，我们还有可以自行定义值的卡片。

那么，不妨令第一张卡片 $B$ 的值为 $n+1$。这样就可以先解决表示 $n+1$ 的问题。

随后，$n+2$ 就可以表示为 $(n+1)+(1)$。此处的括号是用来区分两种卡片的。

同理：

$$n+3=(n+1)+(2)$$
$$n+5=(n+1)+(4)$$
$$......$$
$$n+n+1=(n+1)+(n)$$

我们就会发现，此时能表示到的最大的值就是 $2n+1$ 了。

那么此时：

如果我们没有卡片 $B$ 了，那么能表示到的最大的值就是 $2n+1$，结束。

如果还有，那就可以令下一张卡片 $B$ 的值为 $2n+2$ ，随后重复以上步骤。

发现当有两张卡片 $B$ 时能表示到的最大的值就是 $4n+3$。

咱们先停一停，找找规律：

当有 $1$ 张卡片 $B$ 时，所能表示到的最大的值是 $2n+1$。

当有 $2$ 张卡片 $B$ 时，所能表示到的最大的值是 $4n+3$。

由上可得，当有 $m$ 张卡片 $B$ 时，所能表示到的最大的值是 $2^m \times (n+1)-1$。

如果你觉得两次得来的规律不可靠，也可以再看看有 $3、4$ 张卡片 $B$ 时各所对应的最大值是多少，再看看符不符合刚刚找到的规律。最后你会发现这是对的。

那么，是时候进入下一章节了，我想你应该已经迫不及待了吧...

### 【~~激动人心的~~代码实现环节】

好了，咱先不管那么多，先按刚刚得到的~~还热乎着的~~规律打一发再说：

First Code:
```cpp
#include<bits/stdc++.h>//万能头文件好
using namespace std;
#define ll long long//个人习惯
#define mo 1000000007
int main(){
	ll n,m;
	scanf("%lld%lld",&n,&m);//输入
	printf("%lld\n",(n+1)* ( (ll) (pow(2,m)) ) %mo-1);//输出
	//没错，就是这么简单！
  	return 0;//over!
}
```

看啊，那一个个绿色的AC是那么的可爱！

往下一翻：[Emm怎么全错了。。](https://www.luogu.com.cn/record/31513972)

聪明的你一定发现了：我并没有给最后答案取余。那么简单再改一下：[结果Q_Q](https://www.luogu.com.cn/record/31514223)。

不急，问题不大，至少没有TLE，况且比赛才开始呢。仔细想想...中间乘的时候是不是爆long long了？没错！就是这样！

那么我们就可以把算 $2^m$ 的步骤单独拿出来算，每乘一次2就膜一次 $10^9+7$。

Second Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mo 1000000007
int main(){
	ll n,m,k=1,i;//注意k的初始值
	scanf("%lld%lld",&n,&m);
	for(i=1;i<=m;i++)k*=2,k%=mo;//用k来存储2^m的结果
	printf("%lld\n",((n+1)*(k%mo)-1)%mo);
  	return 0;
}
```
很好，看来可以A掉了。[成功解锁此题新死法：TLE](https://www.luogu.com.cn/record/31514584)。

看来，T3说的真好：

> 个人的遭遇，命运的多舛都使我被迫成熟，这一切的代价都当是日后活下去的力量。 —— 三毛

咱们打起精神再来。既然TLE是时间不够，那么就得让程序算 $2^m$ 时快一点。可我又不会快速幂咋办呢。

办法总比困难多。我们可以让循环变快一些。

若用一个变量 $yu$ 来存储 $m$ 对 $3$ 取余的结果，再让 $m$ 自身整除以 $3$，则：
$$k=({2^3})^m \times 2^{yu}$$

上Third Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mo 1000000007
int main(){
	ll n,m,k=1,i,yu;//先全部定义好
	scanf("%lld%lld",&n,&m);
	yu=m%3;m/=3;//取余，自整除
	for(i=1;i<=m;i++)k*=8,k%=mo;//算(2^3)^m
	for(i=1;i<=yu;i++)k*=2,k%=mo;//算2^yu
	printf("%lld\n",((n+1)*(k%mo)-1)%mo);
  	return 0;
}
```
[再次喜提TLE](https://www.luogu.com.cn/record/31514805)。

嘿，别泄气啊，你看，TLE的点数不是少了几个？

**程序能不能再快一点？**

当然可以！为什么不让循环跨度再大一点呢？也就是使：

$$k=({2^5})^m \times 2^{yu}$$

这次就不上Forth Code了，与Third Code是同理的。

[结果：AC哈哈哈！](https://www.luogu.com.cn/record/31514882)

### 【尾声】

然而窝太篛了只A了 $T1$，$T2$。

众所周知，月赛排名是先按分数，再按时间排序的。

百般无奈的我为了更上一层楼便开始琢磨...

**能不能再快点？**

当然可以！为什么不让循环跨度再大一点呢？（我绝对不会告诉你们这句话是从前面复制过来的）

于是，我让 $m$ 对 $15$ 取了余。似乎已经跑的很快了（~~毕竟不是正解~~），11ms（也不知它是怎么算的） 美滋滋~

还是上一下上述的Forth Code吧：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mo 1000000007
int main(){
	ll n,m,k=1,i,yu;
	scanf("%lld%lld",&n,&m);
	yu=m%15;m/=15;
	for(i=1;i<=m;i++)k*=32768,k%=mo;//如果我说32768是我口算的，你信吗？
	for(i=1;i<=yu;i++)k*=2,k%=mo;
	printf("%lld\n",((n+1)*(k%mo)-1)%mo);
  	return 0;
}
```
[跑的挺快的记录](https://www.luogu.com.cn/record/31515631)。

顺便说一下，其实这道题作者有Sixteenth Code（好丢脸）。

码字不易啊（疯狂暗示 AWA

---

## 作者：CSP_Sept (赞：8)

# 1 前置知识

**快速幂**

# 2 讲解

有 $n$ 个 $1$，单靠这些 $1$ 可以组成一个 $n$，于是我们让这 $m$ 个任意数（以下称为数列 $\{a_m\}$）从 $n+1$ 开始。

于是我们往后延申：

- 有了 $n+1$，下一个无法得到的数是 $2n+2((2n+2)-(n+1)>n)$，于是我们让 $a_2=2n+2$。
- 再下一个无法得到的数是 $4n+4$，因为 $a_1+a_2+n=4n+3<4n+4$。
- 再下一个无法得到的数是 $8n+8$，因为 $a_1+a_2+a_3+n=8n+7<8n+8$。
- $\cdots$

不难发现：对于任意一个 $i(i>1)$ 都有

$a_i=a_1+a_2+\dots+a_{i-1}+n+1(a_1=n+1)$ 推论$1($以下简称「推论 $n$」为 $t_n)$

由 $t_1$ 得，对于任意一个大于 $1$ 的数 $w$，有

$\begin{cases}a_w=a_1+a_2+\dots+a_{w-1}+n+1\;No.1\\a_{w-1}=a_1+a_2+\dots+a_{w-2}+n+1\;No.2\end{cases}$

$No.1-No.2$，得

$a_w-a_{w-1}=a_{w-1}$

两边同加 $a_{w-1}$，得 $a_w=2a_{w-1}$。

且本题就是让我们求 $a_1+a_2+\dots+a_m+n$ 的值。

不难得出代码：

```cpp
#include <cstdio>

using namespace std;
typedef unsigned long long ULL;
ULL m,n,sum,tmp;
#define MOD 1000000007
int main(){
	scanf("%lld%lld",&n,&m);
	tmp=n+1;
	tmp%=MOD;
	sum=n;
	while(m--){
		tmp%=MOD;
		sum+=tmp;
		sum%=MOD;
		tmp=(tmp*2)%MOD;
	}
	printf("%lld",sum%MOD);
	return 0;
}
```

这是一个时间复杂度为 $\Theta (m)$ 的代码，可以发现本题的数据范围是

>$1\le m\le 10^9$

这样的代码根本过不了所有的点！不信？戳这里$\to$[$\color{Black}\tt TLE$](https://www.luogu.com.cn/record/31513334)

于是，我们需要进一步优化！

进一步，我们发现：

设 $a_1=p$，则 $a_2=2p,a_3=4p,\dots,a_i=2^{i-1}p$。

$\therefore a_1+a_2+\dots+a_m=(1+2+4+\dots+2^{m-1})p$

$\begin{matrix}1+2+4+\dots+2^{m-1}\\=1+1+2+4+\dots+2^{m-1}-1\\=2+2+4+\dots+2^{m-1}-1\\=4+4+8+\dots+2^{m-1}\\=\cdots\\=2^{m-1}+2^{m-1}-1\\=2^m-1\end{matrix}$

$\therefore a_1+a_2+\dots+a_m=(1+2+4+\dots+2^{m-1})p=(2^m-1)p$

将 $p=n+1$ 代入，得 $ans=(n+1)(2^m-1)+n$，进一步化简，

$\begin{matrix}ans=(n+1)(2^m-1)+n\\=(n+1)2^m-n-1+n\\=(n+1)2^m-1\end{matrix}$

于是 $ans=(n+1)2^m-1$。

这时出现了一个 $2^{m}$，如果用循环计算，时间复杂度还是 $\Theta (m)$；如果用移位运算符，则肯定会溢出。

于是，**快速幂**应运而生！

## 快速幂

[如有需要请移步学委大佬的文章](https://www.luogu.com.cn/blog/cicos/quickpow#)

下面简述一下**快速幂**的原理以及实现。

### 前置知识

- $(a^x)^{^y}=a^{xy},a^x\times a^y=a^{x+y}$
- 任意一个整数都可以表示成 $2$ 的次幂和。如 $11$，它转换的过程如下：
  
| 原二进制数 | $1$ | $0$ | $1$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| **第 $i$ 位** | $3$ | $2$ | $1$ | $0$ |
| **代表的数** | $2^3(8)$ | $0$ | $2^1(2)$ | $2^0(1)$ |

- 所以，$a^{11}=a^{8}\times a^{2}\times a^{1}$。
- 这样，我们只要算出 $a^1$ 的值，再依次累乘即可。

### 实现

用一个计数器 $base$ 来存储累乘的值。

这里要用到一个技巧：**按位与$(\&)$**，若 $a$ 的二进制的最后一位是 $1$，$a\And 1=1$，否则，$a\And 1=0$。

还需要**右移运算符$($`>>`$)$**，$a>>n=\Large\lfloor\dfrac{a}{2^n}\rfloor$（$\lfloor\rfloor$ 代表向下取整），每次 $a>>1$ 就可以消掉 $a$ 的二进制的最后一位，岂不美哉？

#### $Code:$

```cpp
typedef unsigned long long ULL;
#define mod 1000000007
ULL qpow(ULL a,ULL b){
    ULL ans=1, base=a;
    while(b>0){
        if(b&1){
            ans*=base;
            ans%=mod;
        }
        base*=base;
        base%=mod;
        b>>=1;
    }
    return ans%mod;
}
```

再根据上面得到的式子，可以得到代码（作了一些处理，直接交是不会 $\color{Green}\tt{AC}$ 的）：
```cpp
#include <cstdio>

using namespace std;
typedef unsigned long long ULL;
#define mod 1000000007;
ULL qpow(ULL a,ULL b){
    ULL ans=1, base=a;
    while(b>0){
        if(b&1){
            ans*=base;
            ans%=mod;
        }
        base*=base;
        base%=mod;
        b>>=1;
    }
    return ans%mod;
}
inline ULL read(){
	char c;
	bool flag=false;
	while((c=getchar())<'0'||c>'9')
	    if(c=='-') flag=true;
	ULL res=c-'0';
	while((c=getchar())>='0'&&c<='9')
	    res=(res<<3)+(res<<1)+c-'0';
	return flag? -res:res;
}
char f[2000];
inline void write(ULL x){
    ULL tmp=x>0?x:-x;
    if(x<0)putchar('-');
    ULL cnt=0;
    while(tmp>0){
        f[cnt++]=tmp%10+'0';
        tmp/=10;
    }
    while(cnt>=0) putchar(f[--cnt]);
}
ULL m,n;
int main(){
	n=read();m=read();
	write(((n+1)*qpow(2,m)-1)%mod);
	return 0;
}
```
# 3 最后

最后祝我们可爱的出题人 zwc 高考 $\tt AK$ 虐全场！

---

## 作者：Islauso (赞：6)

本文同步更新于笔者的[Hexo博客](https://dnduef.coding-pages.com/2020/03/08/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P6195-%E3%80%90%E8%BF%AB%E5%AE%B3%E3%80%91/)
# 前言

[题目传送门](https://www.luogu.com.cn/problem/P6195)

这道题，乍一看很难，但其实就是一道推结论的数学题。

相信大家在小学的时候都做过这样一道数学题吧：大意就是如何用最少的正整数凑出最多的连续的正整数（随便口胡了一下，差不多就行了），其思路大致如下：

- 先取$1$，因为这是最小的正整数。
- 再取$2$，因为一个$1$凑不出$2$。
- 再取$4$，因为$1+2=3$，无法凑出$4$。
- 再取$8$，因为$1+4=5,2+4=6,1+2+4=7$，凑不出$8$。
- $\cdots$

由此，我们可以看出一个规律，当每次取前面取过的所有数的和再加一时，可以凑出最多的正整数，即：

$$m_i=\sum\limits_{j=1}^{i-1}m_j+1$$

铺垫完毕。

# 过程

接下来我们进入这道题的分析。

根据上述规律，我们可以看出，这道题其实也有着异曲同工之妙，由于有$m$个数可以取任意值，我们就按照以上策略来取（由于$n$代表的是有$n$个$1$，所以可以当成是补漏的），设$x_i$表示第$i$次取的值，则有：

$$x_1=n+1$$

$$x_2=x_1+n+1=2\cdot n+2=2\cdot(n+1)$$

$$x_3=x_1+x_2+n+1=4\cdot n+4=4\cdot(n+1)$$

$$x_4=x_1+x_2+x_3+n+1=8\cdot n+8=8\cdot(n+1)$$

$$\cdots$$

$$x_m=2^{m-1}\cdot(n+1)$$

此时，我们能表示出来的从$1$开始的连续的正整数就有这么多：

$$\sum\limits_{i=1}^m x_i+n$$

即：

$$(1+2+4+8+\cdots+2^{m-1})\cdot(n+1)+n$$

怎么样，前面那个式子是不是似曾相识？没错，这是我们小学所学的等比数列！只要把最后的$n$变成$n+1-1$，并把$n+1$合并到前面的那一坨东西里面，就可以弄出这个式子：

$$2^m\cdot(n+1)-1$$

具体过程我不详细解释了，比较简单，手推一下就行了。既然都弄出了这个式子，那我们就可以偷税地去算了。

对了，由于$m\le 10^9$，直接暴力算乘方明显会超时，所以我们需要用快速幂（不会的同学建议去做一下[这道题](https://www.luogu.com.cn/problem/P1226)）。

# 参考代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define p 1000000007
#define x zwc
using namespace std;
ll n,m,t;
inline ll input()//读入优化
{
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
	{
        if(c=='-')
			f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
	{
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
inline ll ksm(ll b,ll k)//快速幂
{
	ll ans=1;
	while(k)
	{
		if(k&1)//快速幂里面的位运算，相当于k%2==1
			ans=ans*b%p;
		b=b*b%p;
		k>>=1;//同上，相当于k/=2
	}
	return ans%p;
}
int main()
{
 	n=input();//读入优化不解释
 	m=input();
 	printf("%lld",ksm(2,m)*(n+1)%p-1);//记得取模啊！！！
	return 0;
}
```

# 后记

这道题其实不算很难吧，主要就是推式子那里麻烦了一点，然后要用到快速幂，其他的也并不是很麻烦，不想用读入优化也是可以的，只是因为比赛的时候想优化一下（~~其实我还加了八聚氧只不过太长了所以就删掉了~~）。

~~zwc野心家~~

---

## 作者：tobie (赞：4)

注意，如果题解界面的 $\LaTeX$ 炸了，请到博客里查看。

首先，因为X有 $n$ 个 $1$ ，所以他一开始一定可以迫害 $n$ 个人。

然后，如果想要X能够迫害最多的人，那么X的第一个数必然是 $n+1$ 。这样X就可以迫害到 $n+(n+1)$ 个人，我们记做 $F(1)$ 。

接着，如果X还能再选数的话，那么X只能选 $F(1)+1$ ，这样X就可以迫害到 $F(1)+(F(1)+1)$ 个人，我们记做 $F(2)$ ，以此类推。

所以我们就可以得出递退式了$O(n)$：
$$F(i)=\begin{cases}n&i=0\\F(i-1)\times 2 + 1&i>0\end{cases}$$
最终答案就是 $F(m)$ 。


但是，我们来康康数据：
>Subtask 2（30 points）：保证答案在取模前在 $10^{18}$ 之内。
>
>Subtask 3（20 points）：无特殊限制。

这是什么意思？合着这个式子会爆高精度啊！

![](https://www.52doutu.cn/static/temp/pic/7166f7827ae52bd5feb5c205357e3a36.jpg)

所以我们要对这个式子进行改(mo)良(gai)。

继续从上面的递推式说起：

由于那个递推式只含有 $n$ 和常数，所以我们可以分类讨论：

>$F(0)$ 含有 $1$ 个 $n$ （废话）。
>
>$F(1)=F(0)\times2+1$ 含有 $2$ 个 $n$ 。
>
>$F(2)=F(1)\times2+1$ 含有 $4$ 个 $n$ 。
>
>$F(n)=F(n-1)\times 2+1$ 含有 $2^n$ 个 $n$ 。
- - -
>$F(0)$ 没有 $1$ （还是废话）。
>
>$F(1)=F(0)\times2+1$ 含有 $1$ 个 $1$ 。
>
>$F(2)=F(1)\times2+1$ 含有 $3$ 个 $1$ 。
>
>$F(3)=F(2)\times2+1$ 含有 $7$ 个 $1$ 。
>
>$F(n)=F(n-1)\times2+1$ 含有 $2^n-1$ 个 $1$ 。

把两个推导结合起来可得：
$$F(n)=2^n\times n+2^n-1=2^n\times (n+1)-1$$

于是代码就可以愉快地打出来了：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long mod=1000000007;
long long n,m;//开long long比较保险
long long ksm(long long a,long long b)//快速幂
{
	long long ans=1;
	a=a%mod;
	while(b>0)
	{
		if(b&1) ans=(ans*a)%mod;
		b/=2;
		a=(a*a)%mod;
	}
	return ans;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	printf("%lld",((ksm(2,m)*(n+1)%mod)%mod-1+mod)%mod);//推导式
}
```

---

## 作者：Hexarhy (赞：3)

难度为 CSP-J T2，思维难度不大的结论题。

-------

### 解题思路

**前置知识：** 快速幂。

很遗憾，笔者想不到部分分的做法（暴力？），这里直接讲正解。

其实**样例**已经暗示正解了。

给定了 $n$ 个 $1$，那么我们必然可以得到 $1\sim n$ 这 $n$ 个数。

那么接下来，为了保证接下来能得到 $n+1$，我们只能选择加入一个 $n+1$ 或者 $1$。

显然前者更优，因为加入 $1$ 最多也只能凑到 $n+1$；

而如果加入 $n+1$，前面连续的 $n$ 个数每个都能与其搭配得到新的数，且一定会得到新的连续的 $n$ 个数，加上 $n+1$ 本身也就是产生了新的 $n+1$ 个数。

此时总数为 $n+n+1=2n+1$。

按照这种思路继续往下：

加入 $2n+2$，总数为 $2n+1+2n+2=4n+3$。

加入 $4n+4$，总数为 $4n+3+4n+4=8n+7$。

加入 $m(n+1)$，总数为 $2^{m}(n+1)-1$。

至此，找规律答案就出来了。

$$\text{Ans}=2^m(n+1)-1$$

记得取模。

由于 $m\le 10^9$，且使用 `std::pow()` 不能取模，中间会乘爆`long long`，因此我们只能使用快速幂。

时间复杂度 $O(\log m)$。

事实上，观察每次加入的 $m(n+1)$，我们发现这是一个首项为 $n+1$，公比为 $2$ 的等比数列。

代入等比数列的求和公式，再加上 $n$，就是答案。虽然看上去不同，但是化简后都是一样的。

$$\text{Ans}=(2^m-1)(n+1)+n$$

### 参考代码

本题无坑点，放心打。~~不开`long long`我无话可说~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

typedef long long ll;
const ll MOD=1000000007;
ll n,m,ans;

ll fpow(ll b,ll p)//快速幂
{
	ll ans=1;
	while(p)
	{
		if(p&1)
		 ans=ans*b%MOD;
		b=b*b%MOD;
		p>>=1;
	}
	return ans;
}

int main()
{
	cin>>n>>m;
	ans=fpow(2,m)*(n+1)%MOD-1;//套式子
	cout<<ans%MOD<<endl;
	return 0;
}
```

---

## 作者：lndjy (赞：3)

让我们来分析一下这道题。

这里M，N为输入。

先不考虑m，只有N个1，很容易得知答案是N。

考虑只有一个m，怎么写这个m答案最大？答案是把m写成N+1，对于1到N，就用1的卡片就行。m到m+N，可以一张m加剩下的1就行。

两个m，第二张m应该是 $m_1+N+1$ 。

三个m，第三张就是 $m_1+m_2+N+1$。

以此类推，得出 $m_x=\sum\limits_{i=1}^{x-1}m_i+N+1$ .

已知 $m_1=N+1$,所以可以展开成

$m_x=\sum\limits_{i=0}^{x-1}(n+1)\times{2^{i-1}}$ 

也就是

$m_x=(n+1)\times{2}^{x-1}$.

则

$\sum\limits_{i=1}^{M}m_i=(n+1)\times(2^{M}-1)$.

再加上n就是$(n+1)\times(2^{M}-1)+N$ ,这就是答案，快速幂即可。

代码：
```cpp
#include<iostream>
#define int long long
using namespace std;
const int p=1000000007;
int qpow(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1)  ans=(ans*a)%p;
		a=(a*a)%p;
		b>>=1;
	}
	return ans%p;
}
signed main()
{
	int n,m;
	cin>>n>>m;
	cout<<((qpow(2,m)-1)*(n+1)+n)%p;
	return 0;
}
```


---

## 作者：十十十十 (赞：1)

注意到是求最多，因此不难想到每个自选数应选可能的最大值。  
首先，1~$n$ 是一定可以用1表示的，所以第一个数应选为 $n+1$，同理，$n+1$ ~ $2n+1$ 也是可以在已有数上累加而得的，所以下一个数应选 $2n+2$，即 $2(n+1)$，依此类推，后面为 $2n+2+n+1+n+1$ 即 $4(n+1)$，因此得到结论，选的第 $i$ 个数为 $2^i(n+1)$。  
因此得出结论，被迫害人数总和为:$p =( \sum\limits_{i=0}^{m-1} 2^i(n+1))+n$，即为 $2^m(n+1)+n$。 


------------

因此有了代码:
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL pow(LL a,LL b,LL c)//快速幂，不写会T，只剩80pts
{
    LL ret=1%c;
    a%=c;
    b%=c;
    while(b)
    {
        if(b&1) ret=ret*a%c;
        b>>=1;
        a=a*a%c;
    }
    return ret;
}
int main()
{
    LL n,m;
    cin>>n>>m;
    LL ans=0;//不要忘了赋初值
    ans+=n; //先是n
    LL p=pow(2,m,1000000007);
    ans+=(n+1)*(p-1)%1000000007;//加上快速幂结果，记得取模
    cout<<ans<<endl;//输出
}
```

---

## 作者：Fatalis_Lights (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6195)

## Solution

不妨一步一步来看。

假设 $m=1$ 。

此时取 $m=n+1$ 可以表示 $2n+1=2^1(n+1)-1$ 及以内的所有正整数。

再来一个数？

取 $m'=2n+2$ ，$ans=4n+3=2^2(n+1)-1$

再来一个：

取 $m''=4n+4$ ，$ans=8n+7==2^3(n+1)-1$

猜想：$m$ 每增加一，新增的数就可以取前面所有数的和再加一。

证明：不妨设现在用了 $n$ 个 $1$ 可以表达出 $1$ 至 $n$ 中的所有正整数。

若下一个数不为 $n+1$ ，则无法表示 $n+1$ 这个数。所以终浪费要一个数来表示 $n+1$ 。所以下一个数取 $n+1$ 。将前面所有数都看作一（ $n+1$ 看作 $(n+1)$ 个 $1$）。则现在用了 $2n+1$ 个 $1$ 可以表达出 $1$ 至 $2n+1$ 中的所有正整数。所以 $m$ 每增加一，新增的数就可以取前面所有数的和再加一。

所以当有一个任意正整数时，取前面所有数的和再加一最优。

$\therefore Ans=n+(n+1)+(2n+2)+(4n+4)+....\qquad$ （这里有 $m$ 个左括号）

$\therefore Ans=(n+1)\times 2^{m+1}-1$ 。

code:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007 
using namespace std;
ll n,m,tmp,ans;
inline ll ksm(ll a, ll k){
    ll ans=1;
    while(k){
        if(k&1) ans=(ans*a)%mod;
        a=(a*a)%mod;
        k>>=1;
    }
    return ans%mod;
}
int main(){
	cin>>n>>m;
	tmp=n+1;
	ans=tmp*ksm(2,m)%mod;
	cout<<ans-1<<endl;
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：0)

简单来说，这道题目的题意是这样的：**有$n$个$1$和$m$个任意数字，要确定这$m$个数字，使这$n + m$个数中的一些数相加，可以够成$1-k$中的任意数字。现在我们要确定$k$的最大值。**

这道题应该可以算是一个贪心。首先，$n$个$1$肯定能组成$1-n$的所有数字，想要组成数字$n + 1$,我们必须要增加一个数$n + 1$。那么，增加完它后，$n + 1-2 * n + 1$的数也可以被组成。同理得，增加$2 * (n + 1)$后，$2 * (n + 1)-4 * n + 3$的数也可以组成出来。(**策略：分别把增加的数与$1-n$个进行组合变成新的数**）   
因此，我们只要再$n$个$1$之后添加一个数字，以此类推，计算出来的$k$一定是最优解。
```
k = n + 1;ans = 0;
for(int i = 2;i <= m;i++)
{
	k *= 2;
	k %= MOD;
	ans += k;
	ans %= MOD;
}
```
**根据上面的伪代码，我们得出来的一定是最优解，但这还不是最终答案。**  因为对于$100\%$的数据，$1\le n \le 10^6$，$1 \le m \le 10^9$。在$m$的如此大的情况下，程序会$TLE$,只有$80pts!$

我们将刚才的式子整理一下，对于输入的$n$与$m$，最大的$k$应该为：
$n + (n + 1) + 2 *(n + 1) +4 * (n + 1) +… + 2^{m - 1} * (n + 1)$；   
提取公因式，得$n + (n + 1) * (1 + 2 + 4 + … + 2 ^{m - 1})$；   
即$n + (n + 1) * (2^0 + 2^1 + 2^2 + … + 2 ^{m - 1})$；  
继续将其变形，得$n + (n + 1) * (2 ^ m - 1)$。

**那么怎么快速算出$2^n$呢？快速幂加取模没错了！**
```
ll f(ll a,ll b)//快速幂
{
	ll ans = 1;
    while(b > 0)
	{
		if(b & 1) ans *= a,ans %= MOD;//取模1 
		b >>= 1;
		a *= a,a %= MOD;//取模2 
	}
	return ans;
}
```


------------

**最后结果，我们只要把刚才的结论式子带一下就行了，$100pts$到手！**
```
#include <iostream>
#define MOD 1000000007//模 
#define ll long long//long long 必须的 
using namespace std;
long long ans = 0;
ll f(ll a,ll b);
int main()
{
	ll ans = 0;
	int n,m;
	cin>>n>>m;
	cout<<(n + (n + 1) * (f(2,m) - 1) % MOD) % MOD<<endl;//直接带入 
	return 0;
}
ll f(ll a,ll b)//快速幂
{
	ll ans = 1;
    while(b > 0)
	{
		if(b & 1) ans *= a,ans %= MOD;//取模1 
		b >>= 1;
		a *= a,a %= MOD;//取模2 
	}
	return ans;
}
```



---

## 作者：Steven__Chen (赞：0)

# 开始！！


蒟蒻的第一篇月赛题解，求过……

在敲代码之前，我们应该尝试把这个看似复杂的问题化简，找出它的本质。

先从手里的n个1开始分析——编号在1~n之间的人都可以迫害。

然后再从手里的m个自定义数字开始分析——

因为第n+1个人不能被小Z用这n个1进行迫害，所以我们把第一张个自定义数字定为n+1。

接下来，我们会发现编号在n+1~2n+1之间的人也可以迫害了。因为这些数可以表示为：(n+1),(n+1)+1,(n+1)+2,(n+1)+3,……,(n+1)+n，而1~n之间的数都是可以用1组成的, n+1是我们之前自定义的数字，所以编号在n+1~2n+1之间的人也可以迫害了。

再之后，我们把第二张个自定义数字定为2n+2。这样，编号在2n+2~4n+3之间的人又可以迫害了。

以此类推，编号在1~2^m*n+2^m-1之间的人可以迫害.

化简一下，范围就变成了1~2^m*(n+1)-1.

所以，这就变成了一道快速幂题。

哦，对了，再求2的m次幂的时候要记得%1000000007.

好啦，AC代码如下：

```
#include<bits/stdc++.h>
using namespace std;
long long mod=1000000007;
long long n, m, ans, two[100], k[100], cnt=1, sum=1;
int main()
{
    cin>>n>>m;
    if(m==1)//一个特判
    {
        cout<<(n+1)*2%mod-1;
        return 0;
    }
  	//接下来就是快速幂，这个常识……算了我还是注释下吧(应该不只有我一个人是这样写快速幂的吧……)。
 	 two[0]=2;//2^1=2
    k[0]=1;//k数组表示的是two数组中对应的数组是2的几次幂。
    n++;//这里，为待会答案的输出做准备
    for(int i=1;;i++)//从1开始无限循环，因为是数组下标的原因，只能从1开始，所以我在上面加了个特判。
    {
        k[i]=k[i-1]*2;//记录这是2的几次幂。
        two[i]=two[i-1]*two[i-1]%mod;//计算2的k[i]次幂。
        if(k[i]>=m)//如果k[i]>m，就退出循环，这代表着我们所求出的幂已经够我们使用了
            break;
        cnt++;//计数器++
    }
    for(int i=cnt;i>=0;i--)//从大到小遍历two数组
        if(m>=k[i])//如果m>k[i],我们就让sum=two[i]*sum,记得%1000000007
        {
            sum=(sum*two[i]%mod)%mod;    
            m-=k[i];//让m减去k[i]。
        }
    cout<<n*sum%mod-1;//根据之前分析出来的范围输出答案
  	//实话说，快速幂应该是基本功
    return 0;
}
```
## 再见啦！

---

## 作者：血色黄昏 (赞：0)

由题目我们可以发现

在n个一之后取一个值为（n+1）的数是最优解。

继续往下推

1 1 1 1 ... 1(n个1) n + 1  2n + 2 4n+4 ... 2^(m - 1)n+2^(m - 1)

之后会发现所有的和为2^m*(n+1)-1（这里就不证明了）

#### python代码如下，别忘了要用ksm，还要取模哦：

```python
def power(a,b,c):#带膜的快速幂
    a=a%c
    ans=1
    while b!=0:
        if b&1:
            ans=(ans*a)%c
        b>>=1
        a=(a*a)%c
    return ans % 1000000007
s = input().split()
n, m = int(s[0]), int(s[1])#输入
print((power(2, m, 1000000007)* (n + 1) % 1000000007) - 1)#式子输进去后算出结果再%一次输出
```

这样就能AC啦~

---


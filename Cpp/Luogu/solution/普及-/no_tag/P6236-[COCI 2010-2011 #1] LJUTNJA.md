# [COCI 2010/2011 #1] LJUTNJA

## 题目描述

幼儿园的小孩们收到了一个有 $m$ 颗糖果的大包裹，现在要把这些糖果分给 $n$ 个小孩。

每一个小孩都给出了一个期望的糖果数，如果没有达到他的期望值 $a_i$，小孩就会生气。每差一个糖果，小孩的生气指数就会增加，可以认为他生气的程度等于他少得到的糖果数的平方。

比如，Mirko 想要得到 $32$ 个糖果，但是只得到了 $29$ 个。他少了 $3$ 个，所以他的生气指数是 $9$。不幸的是，糖果数不足以满足所有小孩的期望。所以我们应该采取最优的分配方法，使得最后小孩们的生气指数的和最小。

## 说明/提示

#### 样例输入输出 1 解释

共 $10$ 颗糖果，共 $4$ 人，给每一个同学他所需要的糖果数减 $1$，也就是依次给 $3,4,1,2$ 颗，这样的话每人少一颗，每人的生气指数就是 $1^2=1$，$4$ 个人就是 $1 \times 4=4$，答案 $4$ 是最优方案。

---

#### 数据规模与约定

- 对于 $40 \%$ 的数据，保证 $n \leq 5000$，$m \leq 30$，结果不超过 $5 \times 10^8$。
- 对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times {10}^9$，结果不超过 $2^{64}-1$。

## 样例 #1

### 输入

```
10 4
4
5
2
3```

### 输出

```
4```

# 题解

## 作者：btng_smith666 (赞：13)

# 前言 ：

[题面传送门](https://www.luogu.com.cn/problem/P6236)

[博客食用体验更加qwq](https://www.luogu.com.cn/blog/X-SSS-Tng/solution-p6236)

一道十分明显又常见的贪心题——

# 思路 ：

本题就是将一些糖果分配给几个幼儿园小盆友，每个小盆友有各自的**期望值**，如果没有达到期望值**生气指数**就会增加（生气指数=少得到糖果数的**平方**）,让你找到最优分配方案使得生气指数**和**最小

做法：先对 $a$ 数组进行从大到小降幂排序，然后从最大期望值开始循环 $m$ 颗糖果，每次循环判断一下最大值($maxx$)是否是 $a[qwq]$（$qwq$ 相当于一个临时变量），如果不是就将 $a[1]$ 赋值到最大值 $maxx$ 里，还原 $qwq$ 为 $1$ ，继续循环，如果 $maxx$ 和当前的 $a[qwq]$ 相等，就将 $qwq + 1$ 然后将数组中 $-1$ 继续往后进行，注意最后 $m$ 也要 $-1$，循环结束后直接用 $a$ 数组里存储的每个小盆友少得到的糖果数进行平方累加即可

# 代码 ：

```cpp
#include<bits/stdc++.h>//Code by btng_smith666 juruo
using namespace std;
long long a[100001],ans,n,m,maxx,qwq=1;//注意开 long long 
bool cmp(long long x,long long y)//手打 cmp 
{
	return x>y;//降幂排列 
}
int main(qwq)//主函数 
{
	scanf("%lld%lld",&m,&n);
    for(int i=1;i<=n;i++)
    	scanf("%lld",&a[i]);
    sort(a+1,a+n+1,cmp);//先降幂排一下序 
    maxx=a[1];//将最大值赋成输入中 n 个孩子的最大期望值 
    while(m)//循环找出最优分配方法 
        if(a[qwq]!=maxx) 
            maxx=a[1],qwq=1;
        else  
        	a[qwq++]--,m--;
    for(int i=1;i<=n;i++)
		ans+=a[i]*a[i];//将少的颗数平方累加到最优方案里，注意这道题最后一个点成功把 STL math 库里的 pow 函数完美地卡死了 
    printf("%lld",ans);
    return 0;
}
```

# 后记 ：

本代码有防抄袭措施，但估计**只要学过** C++ 就能轻易发现

大家如果觉得好的话就点个赞吧 qwq ！

---

## 作者：wylt (赞：8)

### 题意：

有 $n$ 个人， $m$ 颗糖，第 $i$ 人想要 $a_{i}$ 颗糖，若所有糖分完后 $i$ 有 $b_{i}$ 颗糖，则生气指数为 $(a_{i}-b_{i})^2$ ，问最小总生气指数。

### 思路：

我们发现此题只要让最大的最小就可以成为最优解，说白了就是先满足需求量大的人。

最简单的方法就是每一步都将当前最大的减一，这样执行 $m$ 次，最后的答案就是 $\sum_{i=1}^na_i^2$ ，这里的 $a_{i}$ 是 $m$ 轮过后的 $a_{i}$ 。

进一步的，我们发现最后只会剩下 $\sum_{}a_i-m$ 个未被满足的糖果需求，那我们就把这剩下的这么多个均分给这 $n$ 个人代表他们每个人未被满足的需求数就是最优解了。

对于一些需求量还没有 $(\sum_{}a_i-m)/n$ 的人，我们就不给他糖果了（原来只有狮子大开口才能获得更多的糖果啊），他的伤心指数就是 $a_{i}^2$，而需求大的人的伤心指数就是  $((\sum_{}a_i-m)/n)^2$ 。

但由于 $(\sum_{}a_i-m)/n$ 不一定是整数，我们需要不断更新到第 $i$ 个人时剩下的需求数，按需分配即可。

大概的思路都有了，代码就不贴了。

---

## 作者：追梦之鲸 (赞：5)

本蒟蒻的第$003$篇题解。

[经典回顾P6236](https://www.luogu.com.cn/problem/P6236)

其实这到题完全可以用STL库里的**大根堆**水过。

### 思路

首先我们把没个小孩的期望值全都放进堆里，然后循环$m$次。没次把最大的期望值拿出来，减$1$再放回去（其实这里你也可以认为是没次$m$-$1$，然后最大的期望值-$1$直到$m=0$为止）。


### 详解

- STL大根堆&&小根堆

[链接](https://blog.csdn.net/Minfrommyfls/article/details/8042709)

定义:

priority_queue<int> xxx **大根堆**

priority_queue<int, vector<int>, greater<int>> xxxx **小根堆**

访问最值使用 **xxx.top()**

堆自动把最值维护在堆最上层

删除最值使用 **xxx.pop()**

删除后自动维护出一个新堆

插入元素使用 **xxx.push(xxxx)**

插入到元素该在的位置上 并自动维护堆有序

### code：

```c
#include<bits/stdc++.h>
using namespace std;
priority_queue<long long > a;
int n,m;
long long x,d;
unsigned long long dan;
inline int read(){//快读
   long long s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9')ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){d=read();a.push(d);}
	for(int i=1;i<=n;i++){
                d=a.top();
                a.pop();
                d--;
                a.push(d);
	}
	x=a.size();
	for(int i=1;i<=x;i++){
		d=a.top();
		a.pop();
		dan+=d*d;
	}
	cout<<dan;
	return 0;
	撒花✿✿ヽ(°▽°)ノ✿
}
```

最后管理大大求过&&[来玩啊](https://www.luogu.com.cn/user/361726)

---

## 作者：张语诚ZYC (赞：5)

# 贪心题

**平均分配（尽量让每个人差的一样），简单粗暴。**

## 描述

幼儿园的小孩们收到了一个有$M$颗糖果的大包裹，现在要把这些糖果分给$N$个小孩。每一个小孩都给出了一个期望的糖果数，如果没有达到他的期望值,小孩就会生气。每差一个糖果，小孩的生气指数就会增加。他生气的程度等于他少得到的糖果数的平方。

## 思路 

**贪心！贪心！贪心！** 尽量让每个人差的糖果一样！只要让他们的生气值的平方和最小，由于指数是2，需要让底数之间的差最小，就比如：

**以下例子差十个糖果哟：**


1. $5^{2}+5^{2} \le 10^{2} + 0^{2}$

2. $5^{2}+5^{2} \le 4^{2} + 6^{2}$

3. $5^{2}+5^{2} \le 3^{2} + 7^{2}$

**总结：**

当$0\le b$时：

### **$a^{2}+a^{2} \le (a+b)^{2} + (a-b)^{2}$**

### ~~**显然，贪心大法好！**~~
### **尽量要让让每个人差的糖果一样！**

## 提示

由于输入量巨大，建议使用快读快输。

## $\texttt{AC Code}$： ~~我知道你们只看这里~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long int Max=1e5+5;
const long long int Mod=1e9+7;
const long long int Inf=1e18;
long long int N,Num,Cost,Ask[Max],Get[Max];
inline long long int Read(){
    long long int X=0;
	char CH=getchar();
	bool F=0;
    while(CH>'9'||CH<'0'){
		if(CH=='-')F=1;
		CH=getchar();
	}
    while(CH>='0'&&CH<='9'){
		X=(X<<1)+(X<<3)+CH-'0';
		CH=getchar();
	}
    return F?-X:X;
}
inline void Write(long long int X){
    if(X<0)X=-X,putchar('-');
    if(X>9)Write(X/10);
    putchar(X%10+48);
}
bool Cmp(long long int zyczs,long long int zyczs0){
    return zyczs>zyczs0;
}
int main(){
    long long int I,J,K;
    Num=Read(),N=Read();
    for(I=1;I<=N;I++){
        Ask[I]=Read();
    }sort(Ask+1,Ask+1+N,Cmp);
    for(I=2;I<=N;I++){
        if(Cost+(Ask[I-1]-Ask[I])*(I-1)<=Num){
            Cost+=(Ask[I-1]-Ask[I])*(I-1);
        } else {
            long long int Ans=0;
            long long int Res=Num-Cost;
            long long int Cur=I-1,Jian=Res/Cur,Ren=Res%Cur;
            for(J=Ren+1;J<=Cur;J++){
                Ans+=(Ask[Cur]-Jian)*(Ask[Cur]-Jian);
            }
            for(J=1;J<=Ren;J++){
                Ans+=(Ask[Cur]-Jian-1)*(Ask[Cur]-Jian-1);
            }
            for(J=Cur+1;J<=N;J++){
                Ans+=Ask[J]*Ask[J];
            }
            Write(Ans);
            return 0;
        }
    }
    long long int Ans=0,Res=Num-Cost;
    long long int Cur=N,Jian=Res/Cur,Ren=Res%N;
    for(I=Ren+1;I<=N;I++){
        Ans+=(Ask[N]-Jian)*(Ask[N]-Jian);
    }
    for(I=1;I<=Ren;I++){
        Ans+=(Ask[N]-Jian-1)*(Ask[N]-Jian-1);
    }
    Write(Ans);
    return 0;
}
```


---

## 作者：lingfunny (赞：3)

[题目回看](https://www.luogu.com.cn/problem/P6236)

# 题目理解
有$n$个数$a_1,a_2...a_n$，现在在这$n$个数中选择几个数减去某个值（所有减去值的和为$m$），使得剩下的数的平方的和最小。
# 分析
很明显，如果要使这些剩下的数平方和最小，就是要尽量剔除最大的几个数。也就是让$n$个数中的最大值最小，这是一个明显的贪心。
# 代码构造
首先我想到了桶排序，用$f_i$表示需求量为$i$的人数，接下来只需要从$\max (a_1,a_2...a_n)$循环到$1$，把糖分给当前的的$f_i$，如果糖没了直接跳出循环。

好在这题的数据不算变态，开一个大小为$5000005$完全够这题数据了。
# 代码
```cpp
#include <iostream>
using namespace std;
#define ll unsigned long long	//unsigned long long改为long long也是可以的
ll f[5000005];					//这题数据手下留情了
ll n,m;
ll mx;							//储存n个数中的最大值
ll ans;
inline ll max(ll a,ll b){
	return a>b?a:b;
}
int main(){
	cin>>m>>n;
	for(int i=1;i<=n;++i){
		int tmp;cin>>tmp;
		++f[tmp];
		mx=max(tmp,mx);
      //读入需求量，然后再把需求量为tmp的人数+1
	}
	for(ll i=mx;i>=1;--i){	//一直循环到解决只需要一颗糖的的人
		if(m>=f[i]){		//如果糖果够现在的人
			m-=f[i];		//减去分掉的糖果   
			f[i-1]+=f[i];	//把糖果分给这f[i]个人，这f[i]个人需求量变为i-1
			--mx;			//最大需求量减一
			if(!m)break;	//如果当前没糖果分了，就跳出循环
		}
		else if(m<f[i]){
			f[i]-=m;		//如果当前糖果不够现在的人，能给几个人是几个
			f[i-1]+=m;		//同理这些个人变为只需要i-1个糖果
			break;
		}
	}
	for(ll i=mx;i>=1;--i)	//从需求量最大的开始，平方后加到ans里
	ans+=f[i]*i*i;
	cout<<ans;
	return 0;
}
```


------------

完结撒花✿

---

## 作者：answerend42 (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P6236)

[更好的阅读体验](https://answerend42.github.io/2020/03/25/lg6236/)

**题目描述**

幼儿园的小孩们收到了一个有 $m$ 颗糖果的大包裹，现在要把这些糖果分给 $n$ 个小孩。

每一个小孩都给出了一个期望的糖果数，如果没有达到他的期望值 $a_i$，小孩就会生气。每差一个糖果，小孩的生气指数就会增加，可以认为他生气的程度等于他少得到的糖果数的平方。

比如，Mirko 想要得到 $32$ 个糖果，但是只得到了 $29$ 个。他少了 $3$ 个，所以他的生气指数是 $9$。不幸的是，糖果数不足以满足所有小孩的期望。所以我们应该采取最优的分配方法，使得最后小孩们的生气指数的和最小。

**输入输出格式**

**输入格式**

输入数据共 $n+1$ 行。

第一行两个整数 $m,n$。

接下来 $n$ 行，每行一个整数，第 $i+1$ 行的整数表示第 $i$ 个小朋友期望值 $a_i$。

**输出格式**

输出数据共一行。

一行一个整数，表示最小的总生气指数。

**解法**

这一题首先要知道分糖果的策略，我们通过样例进行研究，将  $1$ 个糖果分给任意一个小朋友，怎样才是最优的？如果给 $a_i=5$ 的小朋友那么生气指数减少了 $5^2-4^2=9$，给 $a_i=4$ 的小朋友那么生气指数减少了 $4^2-3^2=7$ 的生气指数，以此类推，给 $i$ 号小朋友实质上生气指数会减少 ${a_i}^2-(a_{i}-1)^{2}$ 而给了一个之后 $a_i$ 就会变成 $a_i-1$ 我们只要找到每次给糖果之后生气指数减少最多的（也就是当前离目标差值最大的）就可以做了。

我拿样例来解释一下这个过程

1. 排序得到 $5,4,3,2$

2. 找到最大值 $maxn$ 为 $5$，在 $m>0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$

3. 找到最大值 $maxn$ 为 $4$，在 $m>0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$
4. 找到最大值 $maxn$ 为 $3$，在 $m>0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$
5. 找到最大值 $maxn$ 为 $2$，在 $m>0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$
6. $m=0$ 结束，计算最终和 $sum$ 

抽象一下

1. 排序
2. 找到最大值，所有最大值减一（满足 $m>0$）不断重复此过程
3. 计算最终和 $sum$ 

如果还不明白的话就看一下代码吧（注意，unsigned long long 的最大值才是 $2^{64}-1$ ）

```cpp
#include <bits/stdc++.h>
using namespace std;
unsigned long long a[100005],sum,n,m,maxn,idx=1;
inline unsigned long long read()
{
    char ch=getchar();unsigned long long ret=0,f=1;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){ret=(ret<<1)+(ret<<3)+ch-'0';ch=getchar();}
    return ret*f;
}
int main()
{
    m=read(),n=read();
    for(int i=1;i<=n;i++) a[i]=read();
    sort(a+1,a+1+n,greater<int>());//从大到小排序
    maxn=a[1];
    while(m)
    {
        if(a[idx]!=maxn)
        {
            maxn=a[1],idx=1;
            continue;
		}
        a[idx]-=1,m-=1,idx++;
    }
    for(int i=1;i<=n;i++) sum+=a[i]*a[i];//计算最终和
    printf("%llu",sum);
    return 0;
}
```



---

## 作者：77777_1031 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6236)

[更好的阅读体验](https://tsygoon.blog.luogu.org/solution-p6236)
##  Part 1 题目分析
### 贪心！！！
本题等价于将一个数分成 $n$ 个数使它们的平方和尽量小即可。我们可以通过大量数据验证，当所有数尽可能相同时平方和最小。

例如 17 分成 3 份，分成 5 6 6 最合适。

第一个人分配 $\lfloor\dfrac{17}{3}\rfloor=5$ 个，第二个人分配剩余的平均数 $\dfrac{12}{2}=6$ 个，第三个人分配剩余的平均数 $\dfrac{6}{1}=6$ 个。
##  Part 2 大坑
每个人分配的数目除了受平均数限制，还受他需求的糖果限制，不能超过他需求的糖果数目。所以我们还要将原来的 $a_i$ 排序后一个个扫，若存在需要数比平均数小则更新答案和平均数，最后再将答案加上。
##  Part 3 代码
```c
#include<bits/stdc++.h>
using namespace std;
int n,m;
int z[1<<17];
int main() {
  cin>>m>>n;
  long long sum=-m;
  for(int i=0;i<n;i++){
    cin>>z[i];
    sum+=z[i];
  }

//下面把sum分解成n个整数，使得平方和尽可能小。
  sort(z,z+n);
  long long ans=0;
  for(int i=0;i<n;i++){
    long long w=min(1LL*z[i],sum/(n-i));//剩余的平均数不能超过第i个人的糖果数目
    ans+=w*w;
    sum-=w;
  }
  cout<<ans<<endl;
  return 0;//完结撒花～～
}
```
[AC记录](https://www.luogu.com.cn/record/63786512)

[我的博客～～](https://tsygoon.blog.luogu.org/)

by 2021.11.28 我的第四篇题解。

---

## 作者：nfls20200418 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6236)

这是一道贪心题。
# 思路
(源于官方题解)

- 想象一下，每个孩子都得到了他们想要的糖果($S$ 颗)，而现在他们不得不被带走，总共留下了 $M$ 个糖果。

- 由于孩子们将丢失的糖果数量-之和是恒定 $S-M$ 的，我们希望最小化这些数字的平方和。可以用数学方法(算术和几何平均不等式)证明，正数的平方和(具有固定和)在相等时是最小的。

- 设 $K$ 为需要拿走的剩余糖果数，$K$ 的起始值为 $S-M$。我们的目标是，如果可能的话，从每个孩子身上拿走等量的糖果，最好是 $K/N$。如果不可能，带走的糖果数量应尽可能接近 $K/N$。

- 如果想要最少糖果的孩子至少有 $K/N$ 糖果，我们就可以通过拿走 $K/N$ 糖果来实现目标，从而将问题转移到剩下的 $N-1$ 个孩子身上(通过减少 $N$，计算新的 $K$ 值，并处理下一个最小愿望的孩子)。

- 另一方面，如果孩子的糖果少于 $K/N$，我们无法从中拿走那么多，就将尽可能多地拿走，并继续处理剩余的孩子。

- 最后，我们可以输出从孩子们手中拿走的糖果的平方和。

------------
# AC 代码

------------

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m;
long long sum,ans,a[100005];
int main() {
    scanf("%d%d",&m,&n );
    sum=-m;
    for(int i=0;i<n;i++) {
        scanf( "%d", &a[i] );
        sum += a[i];
    }
    sort(a, a+n);
    for(int i=0;i<n;i++) {
        long long w=min(a[i], sum/(n-i) );
        ans += w*w;
        sum -= w;
    }
    printf( "%lld\n", ans );
    return 0;
}
```
To err is human, to forgive divine.

---


# [COCI 2006/2007 #3] PATULJCI

## 题目描述

白雪公主原本有 $7$ 个小矮人，但某天她遇到了 $9$ 个小矮人。

这九个小矮人都自称是白雪公主 $7$ 个小矮人中的一个。他们每人戴着一顶帽子，每个帽子上面写着 $[1,99]$ 这个区间内的一个数字。

白雪公主知道，她的 $7$ 个小矮人的帽子数字之和是 $100$。

她想请你确定，哪 $7$ 个小矮人是她自己的。

## 说明/提示

#### 数据规模与约定

输入数据均为小于 $100$ 的正整数，且保证有且仅有一组解。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T1 PATULJCI***

## 样例 #1

### 输入

```
7
8
10
13
15
19
20
23
25 ```

### 输出

```
7
8
10
13
19
20
23 ```

## 样例 #2

### 输入

```
8
6
5
1
37
30
28
22
36 ```

### 输出

```
8
6
5
1
30
28
22```

# 题解

## 作者：JamesQin (赞：12)

这道题很简单。    
有九个数，要从中挑出七个数，使得这七个数的和等于100。
只需要依次枚举剩下的两个数，判断是否符合要求即可。    
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a[9]={0},sum=0;
	for(int i=0;i<9;i++){
		cin>>a[i];
		sum+=a[i];
	}
	for(int i=0;i<9;i++){
		for(int j=i+1;j<9;j++){
			if(a[i]+a[j]==sum-100){
				for(int k=0;k<9;k++){
					if(k!=i&&k!=j) cout<<a[k]<<endl;
				}
				return 0;
			}
		}
	}
} 
```


---

## 作者：一扶苏一 (赞：8)

### Analysis

爆搜一下每个人选或不选，如果有一种方案选了 $7$ 个人并且和为 $100$，则直接输出答案即可。

每个位置选或不选可以看成一个长度为 $9$ 的二进制串，$1$ 代表选 $0$ 代表不选，因此枚举一下所有可能的二进制串即可。时间复杂度 $O(2^n \times n)$，其中 $n = 9$。

### Code

```cpp
#include <cstdio>

const int maxn = 10;

int n = 9;
int a[maxn];

int countbit(int x) {  // 返回 x 的二进制有几个 1
  int ret = 0;
  while (x) {
    ++ret;
    x &= x - 1;
  }
  return ret;
}

int main() {
  for (int i = 0; i < n; ++i) scanf("%d", a + i);
  const int upc = (1 << n) - 1;
  for (int s = 1; s < upc; ++s) if (countbit(s) == 7) { // s 代表选或不选的状态。只有选了 7 个人的状态才可能统计答案
    int sum = 0;
    for (int j = 0; j < n; ++j) if (s & (1 << j)) {  // s 的第 j 位为 1 代表选第 j 个人
      sum += a[j];
    }
    if (sum == 100) {
      for (int j = 0; j < n; ++j) if (s & (1 << j)) {
        printf("%d\n", a[j]);
      }
      break;
    }
  }
  return 0;
}
```



---

## 作者：Leasier (赞：5)

我选择了 dfs 来做这道题~~虽然完全没有必要条件~~。

首先读入数据，然后开始 dfs。在每层 dfs 中，如果现有数字之和 $= 100$ 且已经选择了 $7$ 个数字，则返回 true；如果现有数字之和 $> 100$，则返回 false；否则，用 dfs 递归枚举剩下的数字是否满足要求，如果满足（即 dfs 函数的返回值为 true），则将其存入 ans 数组并返回 true（注：这里不能直接输出答案，否则答案会倒序输出）。最后，依次输出 ans 数组中的数字即可。

由于这道题保证了有且仅有一组答案，所以我们就不需要输出多组答案或判断有没有答案。

代码：
```cpp
#include <stdio.h>
#include <stdbool.h>

int a[17], ans[17];

bool dfs(int i, int cnt, int cur){
    if (cur == 100 && cnt == 7){
        return true;
    }
    if (cur > 100){
        return false;
    }
    int cnt_i = cnt + 1;
    for (int j = i + 1; j <= 9; j++){
        if (dfs(j, cnt_i, cur + a[j])){
            ans[cnt_i] = a[j];
            return true;
        }
    }
    return false;
}

int main(){
    for (int i = 1; i <= 9; i++){
        scanf("%d", &a[i]);
    }
    dfs(0, 0, 0);
    for (int i = 1; i <= 7; i++){
        printf("%d\n", ans[i]);
    }
    return 0;
}
```

---

## 作者：SUNCHAOYI (赞：2)

这道题其实就是让我们求：**在$9$个数中选出$7$个数，使得这$7$个数和为$100$，并按顺序输出这$7$个数。**  
想要选$7$个数，相当于是**排除$2$个数**，那么我们只要**枚举**即可。两层循环$i$,$j$分别代表第$i$个与第$j$个数，如果**把这两个数去掉，另外数之和为$100$**，那我们就找到了答案。思路如下：
```
for(int i = 1;i <= 9;i++)
{
	for(int j = i + 1;j <= 9;j++) 
	{
		if(去掉第i,j数后等于100)
		{
			记录这两个数;
			已经找到答案，退出循环;
		}
	}
}
```

那么最后只要把除这两个数外的所有数字输出即可，完整代码如下：
```
#include <iostream>
using namespace std;
int main()
{
	int a[10],x,y,ans = 0;
	for(int i = 1;i <= 9;i++) cin>>a[i],ans += a[i];//所有数求和 
	for(int i = 1;i <= 9;i++)
	{
		for(int j = i + 1;j <= 9;j++) 
		{
			if(ans - a[i] - a[j] == 100)//去掉这两个数 
			{
				x = i,y = j;//记录答案 
				break;//推出 
			}
		}
	}
	for(int i = 1;i <= 9;i++)
		if(i != x && i != y) cout<<a[i]<<endl;//只要不是这两个数，就直接输出	
	return 0;
}

```


---

## 作者：cxwhf (赞：1)

这道题其实挺简单的（~~我一个蓝名都做出来了~~）。

二重循环搞定！

因为有9个编号，所以只要枚举那两个不要的，剩下的7个可以组成100就行了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[11];
int main()
{   

    int x=0,y=0;
    int c=0,d=0;
    for(int i=1;i<=9;i++)
    {
     cin>>a[i];
     y=y+a[i];//累计总数
	 }
	 bool t=false;
    for(int p=1;p<=9;p++)//开始枚举
    {
    	
    	for(int k=1;k<=9;k++)
    	{
    		x=y;
    	   x-=a[k];
    	   x-=a[p];//总数减去两个不要的
    	   if(x==100&&k!=p)//如果凑成100并且两个编号不一样
		   {
		   	c=a[k];d=a[p];//赋值
		   	t=true;break;
		   }
		  
        }
        if(t==true)break;//t跳出循环
	}
	for(int i=1;i<=9;i++)//如果与两个不要的编号不一样就输出
	if(a[i]!=c&&a[i]!=d)cout<<a[i]<<endl; 
	return 0;
 } 
```




---

## 作者：bovine__kebi (赞：0)

写在前面：$DFS??$,太水了是道签到题，用不着，这一题适合OI新手训练逆向思维。  
一共有$9$个人，选出$7$个人使它们的和为$100$，显然如果你枚举$7$个数太麻烦了，超时也是有可能的，我们不如换个方向思考，题目还可以理解成，计算出这$9$个数的和，从这$9$个数中选出$2$个数，使总和减去它们之后的差为$100$，这样只用暴力枚举加输出就好了，代码如下:  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10];
int sum;
bool flag=0;//用来记录是否需要跳出
int main()
{
    for(int i=1;i<=9;i++)//输入
    {
        scanf("%d",&a[i]);
        sum+=a[i];//记录和
    }
    for(int i=1;i<=9;i++)
    {
        for(int j=i+1;j<=9;j++)
        {
            int sum2=sum;//为了不使sum的值改变，所以用另一个变量来记录sum的值
            if(sum2-a[i]-a[j]==100)//判断加输出
            {
                for(int k=1;k<=9;k++)
                {
                    if(k==i||k==j)continue;//跳过i,j两个地方的值
                    printf("%d\n",a[k]);
                }
                flag=1;
                break;
            }
        }
        if(flag==1)break;
    }
    return 0;//完美结束
}
```

---


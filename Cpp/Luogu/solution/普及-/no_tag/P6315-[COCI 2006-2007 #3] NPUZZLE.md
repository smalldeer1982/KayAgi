# [COCI 2006/2007 #3] NPUZZLE

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/tiliraoh.png)

给定一个 $4\times 4$ 的方格棋盘，里面有 $A\sim O$ 这 $15$ 个字母，还有一个 `.` （表示空位），字母的标准位置如图所示。

现在有一个被打乱的棋盘，你需要计算出所有字母从当前位置到自己的标准位置的[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin)之和。

## 说明/提示

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T2 NPUZZLE***

## 样例 #1

### 输入

```
ABCD
EFGH
IJKL
M.NO ```

### 输出

```
2```

## 样例 #2

### 输入

```
.BCD
EAGH
IJFL
MNOK ```

### 输出

```
6```

# 题解

## 作者：y0y68 (赞：11)

怎么连一篇**纯 $STL$** 题解都没有啊！！！

-------------

### 前置芝士：

$1$. $map$

其实 $map$ 没不用理解成映射这么高大上的词语，我们可以这样理解：

定义 $map<string,bool>f$ 就表示建立一个下标为 $string$ 类型的 $f$ 数组，里面存的都是 $bool$ 值。

**注**：要加头文件 `include<map>` 。

$2$. $pair$

举个栗子：
```cpp
pair<int,char>a
```
就相当于
```cpp
struct Node{
	int first;
	char second;
}a;
```

显然，$a.first$ 是 $int$ 类型（不管是`struct`还是`pair`）；同理，$a.second$ 是 $char$ 类型（也不管是`struct`还是`pair`）。

再举个栗子：

再假设变量 $i$ 是 $int$ 类型，$j$ 是 $char$类型，则
```cpp
a=Node{i,j};
```
就相当于
```cpp
a=make_pair(i,j);
```

$3$. 曼哈顿距离

啥都不说，给公式：

设 $A$ 点的坐标为 $(x_1,y_1)$ ，$B$ 点的坐标为 $(x_2,y_2)$

则 $A$ 到 $B$ 的曼哈顿距离为：

$|x_1-x_2|+|y_1-y_2|$ (想想为什么)

-------------

然后就没什么好说的了，上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
char a[5][5];
map< char,pair<int,int> >pos;
//dis会返回x行y列到字符ch的标准位置的曼哈顿距离
inline int dis(char ch,int x,int y){
	return abs(pos[ch].first-x)+abs(pos[ch].second-y);
	//套曼哈顿距离的公式
}
int main(){
	//打表部分开始
	pos['A']=make_pair(1,1);
	pos['B']=make_pair(1,2);
	pos['C']=make_pair(1,3);
	pos['D']=make_pair(1,4);
	pos['E']=make_pair(2,1);
	pos['F']=make_pair(2,2);
	pos['G']=make_pair(2,3);
	pos['H']=make_pair(2,4);
	pos['I']=make_pair(3,1);
	pos['J']=make_pair(3,2);
	pos['K']=make_pair(3,3);
	pos['L']=make_pair(3,4);
	pos['M']=make_pair(4,1);
	pos['N']=make_pair(4,2);
	pos['O']=make_pair(4,3);
	//打表部分结束
	int ans=0;
	for(int i=1;i<=4;i++){
		scanf("%s",a[i]+1);
		for(int j=1;j<=4;j++)
			if(a[i][j]!='.')ans+=dis(a[i][j],i,j);
			//注意a[i][j]不能为'.'
    }
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：4)

这道题目的前置知识，曼哈顿距离，即为：$|x_1 - x_2| + |y_1 - y_2|$。   
![](https://cdn.luogu.com.cn/upload/image_hosting/tiliraoh.png)     
这是原来字母的标准位置，我们可以用一个**结构体**储存这几个字母的坐标，**下标从$0$开始**。
```
struct letter
{
	int x,y;
}a[15] = {{1,1},{1,2},{1,3},{1,4},{2,1},{2,2},{2,3},{2,4},{3,1},{3,2},{3,3},{3,4},{4,1},{4,2},{4,3}};//std
```
接下去是输入，用两层循环`for(int i = 1;i <= 4;i++)`与`for(int j = 1;j <= 4;j++)`，$i$和$j$正好表示输入的字母的坐标。我们现在要求的是**所有字母从当前位置到自己的标准位置的曼哈顿距离之和**，因此输入的`.`不需要被计算。那么这样只需要把$i$与$j$分别与该字母的标准进行比较求和就可以了。（注意：**$A$的$\texttt{ASCII}$的值等于$65$，标准的下标从$0$开始**）
```
#include <iostream>
#include <cmath>
using namespace std;
struct letter
{
	int x,y;
}a[15] = {{1,1},{1,2},{1,3},{1,4},{2,1},{2,2},{2,3},{2,4},{3,1},{3,2},{3,3},{3,4},{4,1},{4,2},{4,3}};//std 
int main()
{
	int ans = 0;char ch;
	for(int i = 1;i <= 4;i++)
	{
		for(int j = 1;j <= 4;j++)
		{
			cin>>ch;
			if(ch != '.') ans += abs(a[ch - 65].x - i) + abs(a[ch - 65].y - j);//'A'的ASCII值为65 
		}
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：Instudy (赞：3)

除出题者首 $ A $者前来写题解

这道题直接暴力即可，判断是否是题目给的字母，然后曼哈顿搞一下即可，入门难度。

例如，如果有一字母，那么我们根据曼哈顿距离的定义，$ ans $ $ +=abs(x1-m)+abs(y1-n)$
$ m,n$为该字母的初始行坐标和列坐标

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[10][10];
int x,y;
int main()
{
   for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
     {
     cin>>a[i][j];
     if(a[i][j]=='.')x=i,y=j;//标记空格位置
     }
    int ans=0;
    for(int i=1;i<=4;i++)
     for(int j=1;j<=4;j++)
     if(a[i][j]=='A')//参照代码前
       ans+=abs(i-1)+abs(j-1);
      else if(a[i][j]=='B')
       ans+=abs(i-1)+abs(j-2);
       else if(a[i][j]=='C')
       ans+=abs(i-1)+abs(j-3);
       else if(a[i][j]=='D')
       ans+=abs(i-1)+abs(j-4);
       else if(a[i][j]=='E')
       ans+=abs(i-2)+abs(j-1);
       else if(a[i][j]=='F')
       ans+=abs(i-2)+abs(j-2);
       else if(a[i][j]=='G')
       ans+=abs(i-2)+abs(j-3);
       else if(a[i][j]=='H')
       ans+=abs(i-2)+abs(j-4);
       else if(a[i][j]=='I')
       ans+=abs(i-3)+abs(j-1);
       else if(a[i][j]=='J')
       ans+=abs(i-3)+abs(j-2);
       else if(a[i][j]=='K')
       ans+=abs(i-3)+abs(j-3);
       else if(a[i][j]=='L')
       ans+=abs(i-3)+abs(j-4);
       else if(a[i][j]=='M')
       ans+=abs(i-4)+abs(j-1);
       else if(a[i][j]=='N')
       ans+=abs(i-4)+abs(j-2);
       else if(a[i][j]=='O')
       ans+=abs(i-4)+abs(j-3);
    printf("%d",ans);
   return 0;
}
```
大概码了$ 50 $行左右（~~复制粘贴~~）码量正常。

当然可以设置一个增量数组，类似于$ dfs $的数组来进行枚举。

还不如直接$ dfs $~~时间复杂度上天但是~~能过

---

## 作者：Leasier (赞：3)

前置芝士：[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin)

我使用了 map 来做这道题~~虽然完全没有必要~~。

首先开两个 map，用来存各个字符对应的纵轴和横轴位置，然后依次读入，求出其曼哈顿距离并求和即可。

具体细节见代码注释。

代码：
```cpp
#include <iostream>
#include <map>
#include <cmath>

using namespace std;

map<char, int> mp_x, mp_y;

inline void init(){
    for (int i = 1; i <= 4; i++){
        for (int j = 1; j <= 4; j++){
            mp_x['A' + (i - 1) * 4 + j - 1] = i;
            mp_y['A' + (i - 1) * 4 + j - 1] = j;
            // (i - 1) * 4 + j - 1 生成的整数一定会在 [0, 16] 中，所以 'A' + (i - 1) * 4 + j - 1 一定会生成 A ~ P 这 16 个字母。
            // 虽然我们不需要 P 这个字母，但存入了也不会影响我们做题。
        }
    }
}

int main(){
    int ans = 0;
    init();
    for (int i = 1; i <= 4; i++){
        for (int j = 1; j <= 4; j++){
            char ch;
            cin >> ch;
            if (ch != '.') ans += abs(i - mp_x[ch]) + abs(j - mp_y[ch]);
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：btng_smith666 (赞：2)

# 前言 ：

[题面传送门](https://www.luogu.com.cn/problem/P6315)

[blog](https://www.luogu.com.cn/blog/X-SSS-Tng/solution-p6315)

又是一道练习暴力枚举的好题~


# 思路 ：

> 你需要计算出所有字母从当前位置到自己的标准位置的[**曼哈顿距离**](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin)之和。

关于曼哈顿距离这里有一个柿子：

$$\operatorname{d}(i,j)=|X_i-X_j|+|Y_i-Y_j|$$

这里的 $\operatorname{d}(i,j)$ 就是 $i \sim j$ 的曼哈顿距离。

本题解的主要做法就是暴力枚举两个棋盘，如果枚举到的位置上字符是一样的就套公式并累加距离，这里对于绝对值的处理可以用 $STL$ 库里的取绝对值函数 $abs$ 来解决

# 代码 ：

```cpp
#include<bits/stdc++.h>//by btng_smith666 juruo
using namespace std;
string a[5],string b[5]={"ABCD","EFGH","IJKL","MNO "};//这里定义了两个字符串数组，用来存储棋盘 
//把原来的棋盘按行存到数组 b 中，由于还要有一个空位，这里就用了一个空格表示（当然定义成其他字符也可以） 
int ans;//ans存答案 
int main()
{
	for(int i=0;i<4;i++)//按行输入棋盘 
		cin>>a[i];
	//然后就可以愉快地暴力枚举啦 
	for(int i=0;i<4;i++)//输入中棋盘的行 
    	for(int j=0;j<4;j++)//输入中棋盘的列 
        	for(int k=0;k<4;k++)//原棋盘的行 
            	for(int l=0;l<4;l++)//原棋盘的列 
            		if(a[i][j]==b[k][l])//如果两个位置的字符是一样的 
                		ans=ans+abs(k-i)+abs(l-j);//公式，并把距离累加到答案中 
	cout<<ans;
	return 0;
}
```

---

## 作者：SisconHL (赞：1)

就喜欢这种数据范围贼小的题。

首先字母不好搞，都减去`'A'`算了，就变成了 $[0,15]$，$15$个数中缺一个。

怎么得到标准位置呢？显然的，$x$ 的标准行（hang）为 $[x/4]$，标准列为 $x \mathrm{mod}4$。

怎么计算曼哈顿距离呢？

曼哈顿计算方法就是 $ dis = abs( x_1 - x_2 ) + abs( y_1 - y_2 ) $。

具体例题可看 [P4326 (COCI2006-2007#1) Herman](https://www.luogu.com.cn/problem/P4326).

直观点就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/3umq7vhn.png)

伪代码如下：
```plain
func dis(int x0,int x1,int y0,int y1):
	x←abs(x0-x1)
   y←abs(y0-y1)
   return x+y
```
很好理解是不是？

上代码：
```cpp
#include<stdio.h>

inline int dis( int X0 , int Y0 , int X1 , int Y1 )
{
	int xqwq = X0 - X1;
	int yqwq = Y0 - Y1;
	if( xqwq < 0 )	xqwq = -xqwq;
	if( yqwq < 0 )	yqwq = -yqwq;
	return xqwq + yqwq;
}

int main( void )
{
	char buf; 
	int dist = 0;
	for( register int i = 0 ; i < 4 ; i++ )
	{
		for( register int j = 0 ; j < 4 ; j++ )
		{
			scanf( "%c" , &buf );
			if( buf >= 'A' && buf <= 'O' )
			{
				buf -= 'A';
				dist += dis( i , j , buf / 4 , buf % 4 );
			}
		}
		if( i != 3 )	scanf( "\n" );
	} 
	printf( "%d" , dist );
} 
```

---


# [COCI 2006/2007 #4] PRSTENI

## 题目描述

有 $n$ 个半径不同的圆环，把它们依次放在地上摆成一行，使得除了第一个和最后一个环，其他的圆环都能接触到相邻两个环。

请你求出当第一个环转动了 $1$ 圈时，其他每个环都转动了多少圈。

由于答案可能不是整数，所以请用最简分数的形式表示，格式见样例。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $3\le n\le 100$，半径长度在 $1\sim 1000$ 之间（含端点） 。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #4](https://hsin.hr/coci/archive/2006_2007/contest4_tasks.pdf) *T3 PRSTENI***

## 样例 #1

### 输入

```
3
8 4 2```

### 输出

```
2/1
4/1```

## 样例 #2

### 输入

```
4
12 3 8 4```

### 输出

```
4/1
3/2
3/1```

## 样例 #3

### 输入

```
4
300 1 1 300```

### 输出

```
300/1
300/1
1/1```

# 题解

## 作者：VincentXu (赞：6)

# 传动比（类似）

设有两个圆环，半径分别是x，y；

第一个圆环转1圈，转动距离是它的周长，即2πx；

第二个圆环的周长是2πy，第一个圆环带动它转动的圈数为2πx/2πy；

化简得x/y，当然要约分。设约分后形式是a/b；

从第二个齿轮开始，转动的距离=齿轮周长*转动圈数，即(a/b)2πx，下一个齿轮周长仍为2πy，化简得下一个齿轮转动圈数为(a/b)x/y，也要约分；

需要注意的是这里的所有数值都要实时更新。

证毕。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int gcd(int x,int y)
{
	if(x%y==0)return y;
	return gcd(y,x%y);
}//传统的辗转相除法
int main()
{
	int n,x,y,k;cin>>n>>x>>y;
	int a=x/gcd(x,y),b=y/gcd(x,y);
	printf("%d/%d\n",a,b);//可以先处理两组
	for(int i=3;i<=n;i++)
	{
		scanf("%d",&k);x=y,y=k;
		int p=(a*x/b)/gcd(a*x/b,y),g=y/gcd(a*x/b,y);
		printf("%d/%d\n",p,g);
		a=p,b=g;
	}//数据要实时更新
	return 0;
} 
```
思路不难，代码易懂。

---

## 作者：Phoenix_chaser (赞：2)

# 暴力求法
既然各位dalao都是用的上下除以gcd，那我就整点不一样的。。。。

#### 约分的定义：

### 约分是分式约分,把一个分数的分子、分母同时除以公因数。
 
其实这种方法在很多题中 _**不适用**_ ，但是

“对于 100% 的数据，保证 3≤n≤100，半径长度在 1∼1000 之间（含端点） 。”


瞬间眼前一亮，这么小的数据，我可以用一些特殊的办法。。。。

### 简单来说，就是将上下每次 _**都%i**_ ，同时不断将 _**%i**_ 等于0的数除以i

这样做有两个原因：

1.只要一个数a%另一个数b得0， _**则a可以整除b**_ ,如果分子分母都可以整除一个数，那么就满足定义，此时的i就是两者 _**公因数**_ ，这样不断处理就可以得出正确的结果了。

2.~~数据水~~

这题还有一点**细节**

不能从 _**前往后**_ 枚举i，举个例子：

8除以4

如果从前往后处理

只能处理成

4/2

很明显，这不是最优

为什么？

因为它们的最大共因数为4，然而当他们除以2之后，无法再除以2

简单来说

就是当这个数的最大公因数是 _**完全平方数**_ 时，就会出问题

似乎不大好办，但是如果我们 _**从后往前**_ 枚举，那么这个问题
就可以得到解决

上代码
```cpp
#include<iostream>
using namespace std;
int n,m,a,o;
int main(){
	cin>>n>>m;
	o=m;
	//记录原始m因为每次m会改变 
	for(int i=2;i<=n;i++)
	{	cin>>a;
		for(int j=1001;j>=1;j--)
		//从后往前枚举 
		if(m%j==0&&a%j==0){
			m=m/j;
			a=a/j;
		}
		//进行处理 
		cout<<m<<'/'<<a<<endl;
		m=o;
	}
	return 0;
}
```

##  谢谢观看

# THE END

---

## 作者：CSP_Sept (赞：2)

## 修改日志

2020/04/08 发现一处笔误，望管理员通过！

## 题意简述

给定 $n$ 个数 $a_1,a_2,\cdots,a_n$，要求打印出每个 $\dfrac{a_1}{a_i}(i>1)$ 的最简分数形式（$\dfrac{a}{b}$ 用 `a/b` 表示）。

### 我们为什么能得出这个结论

设共有两个圆，第一个圆的半径为 $c_1$，第二个圆的半径为 $c_2$。

又设第一个圆滚动了 $a$ 圈，则第一个圆共滚动了 $a\times\pi c_1$（长度），第二个圆也应该滚动 $\pi ac_1$，则它滚动了 $a\times\dfrac{\pi\times c_1}{\pi\times c_2}$ 圈。即当 $a=1$ 时，第二个圆滚动了 $\dfrac{c_1}{c_2}$ 圈。

## 解

本题的重点是**化简分数**。

我们知道，$\gcd(a,b)$ 表示 $a$ 和 $b$ 的最大公约数，化简分数有一个通用的公式（令 $f(\dfrac{x}{y})$ 函数为分数 $\dfrac{x}{y}$ 的最简分数形式）：

$$
f\left(\dfrac{x}{y}\right)=\dfrac{x\div \gcd(x,y)}{y\div \gcd(x,y)}
$$

于是用**辗转相除法**编写一个 `gcd(x,y)` 函数即可。代码：

```cpp
//压行辗转相除法
int gcd(int x,int y){return y?gcd(y,x%y):x;}
```

完整代码：

```cpp
#include <cstdio>

using namespace std;
int n,tmp,first;
int gcd(int x,int y){return y?gcd(y,x%y):x;}
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&tmp);
        if(!i) first=tmp;
        else{
            int t=gcd(first,tmp);
            printf("%d/%d\n",first/t,tmp/t);
        }
    }
    return 0;
}
```

---

## 作者：Vidoliga (赞：1)

# $\text{题解 }P6322$

$\text{这里我们不难发现他是在考分数约分}$

$\text{直接将所有数都取}gcd$

$\text{这里我们手写}gcd\text{就好了,没必要调用}\text{std反而减速}$

$Code:$

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int gcd(int a,int b){//gcd
	if(a<b)swap(a,b);
	return b?gcd(b,a%b):a;
}
int a[1000];
int main(){
	int n;
	scanf("%d%d",&n,&a[1]);
	for(int i=2;i<=n;i++){
		scanf("%d",&a[i]);
		int g=gcd(a[1],a[i]);
		printf("%d/%d\n",a[1]/g,a[i]/g);
	}
	return 0;
}
```


---

## 作者：HYdroKomide (赞：1)

短短几行代码搞定。
# **正文：**
## 题意:
看了题目应该都能反应出来是一道考察分数约分的题目。思路比较简单，将 $a_2，a_3，……，a_n$ 这些数全部与 $a_1$ 求最大公因数并约分。最后只需将结果以分数形式输出即可。
## 程序：
应该是本题的最短代码了，只需使用 STL 中的 `__gcd()` 求最大公因数即可。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[101];
int main(){
    scanf("%d%d",&n,&a[1]);//这里先将a[1]输入，以便后面比对
    for(int i=2;i<=n;i++){
        scanf("%d",&a[i]);
        int gcd=__gcd(a[1],a[i]);
        printf("%d/%d\n",a[i]<=a[1]?a[i]/gcd,a[1]/gcd:a[1]/gcd,a[i]/gcd);
    }
    return 0;
}
```
# **THE END**

---

## 作者：我⭐⭐我 (赞：1)

~~简单读一下题目~~
#### 题目大意：最前面的环转了1圈，对应的后面的轮子转了几圈。由题知最前面的环半径为$r_1$，所以它的周长为 $2*r_1\pi$ , 第$n$个的周长为 $2*r_n\pi$。
### 思路：经过一波扎实计算发现$\pi$被抵消了结果为 $\dfrac{r_1}{r_n}$ 的最简分数形式。所以我们要取这两个数的最大公约数
先上gcd(辗转取余法求最大公约数)的代码，可以参考这篇文章[辗转取余](https://www.cnblogs.com/wxl845235800/p/11470720.html)

```cpp
int gcd(int x,int y){
    if(y==0){
        return x;
    }
    return gcd(y,x%y);
}
```
接下来就是整个的代码了，输入部分和计算部分其实很简单
```cpp
#include <iostream>
using namespace std;

int gcd(int x,int y){
    if(y==0){
        return x;
    }
    return gcd(y,x%y);
}//辗转取余法
int n,a[129];
int main(){
    cin>>n;
    for (int i = 1; i <= n; ++i)
    {
        cin>>a[i];   
    }//输入部分没什么好水的φ(*￣0￣)
    
    for (int i = 2; i <= n; ++i){
        int sum=gcd(a[1],a[i]);//存下两个数据的最大公约数
        //避免多次计算
        cout<<a[1]/sum<<'/'<<a[i]/sum<<endl;//输出最简分数形式
    }
    return 0;
}
```
完结ε=ε=ε=(~￣▽￣)~，
撒花


---

## 作者：Terraria (赞：1)

### 题目大意：给定1个数 $n$ 以及接下来给出 $n$ 个数，求第一个数与后面的数相除的答案（用最简分数表示）。

对于一个分数 $\dfrac{2}{4}$，若要化简成最简分数，则要求出分子以分母的最大公约数，再分别相除求出答案（若分子为 $1$ 也不用约分）。

具体的过程个人认为这个[文章](https://blog.csdn.net/thisispan/article/details/7458182)写的不错，可以看看。

所以先给出求 $gcd$ 的代码：

```c
int gcd(int a,int b){
    if(b==0) return a;
    return gcd(b,a%b);
}
```

接着再给一个完整的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,first,a[109];
int gcd(int a,int b){
    if(b==0) return a;
    return gcd(b,a%b);
}
int main(){
    cin>>n>>first;//干脆直接用领完一个变量存第一个数就好了
    for(int i=1;i<n;i++) cin>>a[i];//数量只剩下n-1个了
    for(int i=1;i<n;i++){
        int _gcd=gcd(first,a[i]);
        cout<<first/_gcd<<'/'<<a[i]/_gcd<<endl;//分子若为1也直接输出
    }
    return 0;
}
```
完结撒花~

---

## 作者：y0y68 (赞：1)

其实这题我不懂题意，根据样例找规律就可以了。

看第二个样例：

输入：
```
4
12 3 8 4
```

输出：
```
4/1
3/2
3/1
```

我们可以发现 $\frac{12}{3}=\frac{4}{1}$ ，$\frac{4}{1} \times \frac{3}{8}=\frac{3}{2}$ ，$\frac{3}{2} \times \frac{8}{4}=\frac{3}{1}$ ，规律就找出来了，也就是$\frac{nz}{nm} \times \frac{a[i]}{a[i+1]}=\frac{rz}{rm}$（$1 \le i < n$），这里 $nz$ 表示目前的分子，$nm$ 表示目前的分母，$rz$ 表示现在要输出答案的分子，$rm$ 表示现在要输出答案的分母。如果您不信，还可以试试第一和第三个样例，下面看代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,a[105];
inline int gcd(int p,int q){
	//gcd（最大公约数）是帮助通分的
	if(p%q==0)return q;
	return gcd(q,p%q);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	int nz=1,nm=1;
  	//nz表示目前的分子，nm表示目前的分母，一定都要初始化为1
	for(int i=1;i<n;i++){
		int rz=nz*a[i],rm=nm*a[i+1];
		//这就是找到的规律
		int g=gcd(rz,rm);
		rz/=g,rm/=g;
		//通分（分子和分母同时除以最大公约数）
		printf("%d/%d\n",rz,rm);
		nz=rz,nm=rm;
		//更新状态
	}
	return 0;
}
```

---

## 作者：DWT8125 (赞：0)

## P6322题解
首先我们得知道，圆环的周长为 2πr 。

第i个圆环转动的圈数为 $\dfrac{2πr_1}{2πr_i}$ ，约分后为 $\dfrac{r_1}{r_i}$ 。

注意事项：**请用最简分数的形式表示**！

我们可以用[辗转相除法](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin)。

辗转相除法的函数：
~~~
int z(int a,int b){
    if(a%b==0) return b;
    z(b,a%b);
}
~~~
然后约分输出即可（**记得换行**）！

以下是AC代码，**禁止抄袭**！
```
#include<cstdio>
int s[100];//放数字用
int z(int a,int b){//辗转相除法的函数 
	if(a%b==0) return b;
	z(b,a%b);
}
int main()
{
	int n; scanf("%d",&n);
	for(int i=0;i<n;i++) scanf("%d",&s[i]);
	for(int i=1;i<n;i++){//注意是 i=1
		printf("%d/%d\n", s[0]/z(s[0],s[i]) , s[i]/z(s[0],s[i]) );//输出，z(s[0],s[i])为最大公约数 
	}
	return 0;
}
```


---

## 作者：CLCK (赞：0)

~~我太蒻了~~
看见这么一道题，一开始想到传动比（已经忘了），然后~~随便一瞄~~认真分析一下样例，发现：

每一个答案其实就是其半径除以第一个半径，以分数形式表示即可。

证明一下：

众所周知，圆周长为 $ C = 2 \pi r $，设 $a$ 圆半径为 $R_A$，$b$ 圆半径为$R_B$，那么当 $a$ 转 $1$ 圈时，$b$ 转了 $2 \pi R_B / 2 \pi R_A$，即 $R_B/R_A$ 圈。

如何将分数化为最简呢？？？不难想到~~（这是这题考点……）~~，直接除以最大公倍数即可。

（啥？这个不会求？看：[gcd & lcm](https://www.luogu.com.cn/blog/zhongyi070622/gcd-and-lcm))

知道这点这题就 淼 了，话不多说，代码如下：
```
#include <iostream>
#include <algorithm>
using namespace std;
int n;
int s[1005];
int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s[i];
    }
    for (int i = 1; i < n; i++) {
        int a, b;
        a = s[0];
        b = s[i];
        int g = __gcd(a, b); //正规函数写法参考上面链接）
        a /= g;
        b /= g;
        cout << a << "/" << b << endl;
    }
    return 0;
}
```
#### 完结撒花~

---

## 作者：Mars_Dingdang (赞：0)

这道题就是典型的齿轮传动问题，涉及到求最大公约数。
## 题目大意
有 $n$ 个半径不同的圆环，把它们依次放在地上摆成一行，使得除了第一个和最后一个环，其他的圆环都能接触到相邻两个环。求当第一个环转动了 $1$ 圈时，其他每个环都转动了多少圈。
## 大体思路
显然，第一个圈的周长为 $2∏R_1$，圈数之比就是两个圈的周长之比，再次约分可得：$Time_1/Time_i=R_1/R_i$。因此这道题就需要求出 $gcd(R_1,R_i)$ 进行约分，可用辗转相除法求得，代码如下：
```cpp
int gcd(int x,int y){
	if(y==0) return x;
	return gcd(y,x%y);
}
```
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd(int x,int y){
	if(y==0) return x;
	return gcd(y,x%y);
}//辗转相除法求最大公因数
int main(){
	int n,a;
	cin>>n;//输入个数
	cin>>a;//先输入第一个圈的半径
	for(int i=1;i<=n-1;i++){
		int b;
		cin>>b;//每次输入一个圈的半径
		int up=a,low=b;//注意此处不能改变a的值
		up/=gcd(a,b);
		low/=gcd(a,b);//约分，
        //用gcd(a,b)而非gcd(up,low)
        //因为up的值已经改变
		cout<<up<<"/"<<low<<"\n";//输出
	}
	return 0;
}
```
~~看得这么认真，不点个赞再走嘛qaq~~

---

## 作者：SqrtSecond (赞：0)

首先，我们来~~认真的~~分析一下样例数据。

------------


输入 #$1$

$3$

$8$ $4$ $2$

------------


输出 #$1$

$2/1$

$4/1$


------------
很显然，输出的第$i-1$行的数是求第一个数是第$i$个数的几分之几。

当然也可以证明:

设第$i-1$个环直径为$a$，第$i$个环直径为$b$。

则如果第$i-1$个环转了$k$圈，那么这个环就转了$k*πa$的长度。

于是第i个环转了$k\times\dfrac{πa}{πb}$圈。

化简后即转了$k\times\dfrac{a}{b}$圈。

当$i=2$(即直径为a的是第一个圈）时，$k
=1$

则第二个圈转了$\dfrac{a}{b}$圈

再设第三个圆直径为$c$

则它转了$\dfrac{a}{b}\times\dfrac{b}{c}=\dfrac{a}{c}$圈。

以此类推，即证毕。

上~~神圣的~~代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}//用辗转相除的gcd 
int n;//环的个数 
int a,b;//a用来存储第一个环的半径，b用来存储其余环的半径
//当然b也可以用数组代替，不过不用数组能减少空间复杂度
int e;//用来存储gcd 
int main(){
	scanf("%d%d",&n,&a);
	for(int i=2;i<=n;i++){
		scanf("%d",&b);
		e=gcd(a,b);//存储gcd 
		printf("%d/%d\n",a/e,b/e);//简单的输出 
	}
	return 0;//不怎么华丽地结束
} 
```

---

## 作者：konglk (赞：0)

在相同的时间内，两个接触的圆环所转过的路程是相等的。

什么意思呢？就是线速度相等，可以简单的理解为你在两个圆上找两个点，在相同的时间内，他们走过的路程相等。

那么比如说样例1中前两个圆，我们找两个点，假设第一个圆上的那个点已经绕着圆走了一圈了，那么第二个圆上那个点走了几圈呢？因为周长=2πr，所以因为第一个圆的半径是8，第二个圆的半径是4，所以第一个点此时走了16π，第二个点也应该走了16π.而第二个圆周长是8π，所以转了16π/8π圈，即样例一所写的2/1

又因为第二个圆与第三个圆接触，所以第三个圆线速度=第二个圆的线速度=第一个圆的线速度。这时候可以类似于前面的求出第三个的,第四个的，第五个的......

所以关键就在怎么化为最简形式了。我们知道，分数中分子与分母同时除以他们的最大公因数，这就互质了，则为最简分数。最大公约数可以这样写

```cpp
#include<algorithm>
 ......
 ......
 __gcd(a,b)//求a和b的最大公约数
 
```
所以代码可以这样写

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
void print(int x,int y)
{
	int X=x/__gcd(x,y),Y=y/__gcd(x,y);
	printf("%d/%d\n",X,Y);
}
int main()
{
	int n,n1,in;
	cin>>n>>n1;
	for(int i=1;i<n;i++)
	{
		cin>>in;
		print(n1,in);
	}
	return 0;
}
```
谢谢观看，有问题请提出，我将尽我所能以解答

---

## 作者：Error_Eric (赞：0)

瞅了瞅楼上巨佬的题解，发现他们的题解太长了，~~不方便理解~~。蒟蒻~~千里迢迢~~跑来发题解。



------------
证明：当第一个圆环转动了1圈时，其他圆环都转动了
$\dfrac{r_1}{r_i}$
圈。

由“齿轮相邻”可以得到，每个齿轮的
[线速度](https://baike.baidu.com/item/线速度/1532652?fr=aladdin)
相等。

$\because v = \dfrac{\Delta L}{\Delta t}=\Delta \theta \times r$

$\therefore v_1=v_2=\Delta \theta _1 \times r_1 = \Delta \theta _2 \times r_2$

$\text{又} \because \Delta \theta _1 =1 $

$\therefore \Delta \theta_2=\dfrac{r_1}{r_2}$

得证。

------------

所以，其实我们只需要依次输出
$\frac{a_1}{a_2}$至
$\frac{a_1}{a_n}$化简后的结果就可以啦。

如何化简：

当 a,b为自然数时$ \dfrac{a}{b}=\dfrac{a/gad(a,b)}{b/gcd(a,b)}$

这里有一处小技巧：c++的
``
algorithm
``
库自带gcd，~~所以很多大佬手打gcd没什么用。~~

$Code$
：
```cpp
#include<stdio.h>
#include<algorithm>
int main(){
     int n,u,v;
     scanf("%d%d",&n,&u);//输入a1
     while(--n)//依次输入a2->an and 输出答案
          scanf("%d",&v),printf("%d/%d\n",u/std::__gcd(u,v),v/std::__gcd(u,v));
     return 0;//结束
}
```

~~极致压行（9行），你值得拥有。~~

---


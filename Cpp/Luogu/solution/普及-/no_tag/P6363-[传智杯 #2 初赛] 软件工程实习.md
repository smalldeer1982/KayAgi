# [传智杯 #2 初赛] 软件工程实习

## 题目描述

某大学的《软件工程》必修课分为理论和实践部分。理论部分由该校教授完成授课；而实践部分是由第三方的公司主导，需要同学们在五周时间内自学 HTML、css、JavaScript、vue、Python、django 等技术，并组队完成一个真实的互联网商业应用。

参与这个课程的有 $n(0\le n \le 1000)$ 个学生，分成了不超过 $26$ 个队伍，每个队伍用 `A` 到 `Z` 来表示。每个队伍都会完成一个项目，并以队伍为单位，给所有队伍（包括自己队伍）打分，范围是 $0$ 到 $100$ 的整数。

为了平息学生对这门课产生的出多问题的不满（比如工作量太大、时间过于紧张、考核方式不公平等），老师决定使用一种“看起来”很公平的方式来决定每组队伍的项目得分：

对于某个队伍，首先计算所有队伍（包括自己）给这个队伍评分的平均值，然后剔除掉和这个平均值差别超过 $15$ 分的评分（保证不会出现所有的评分全部被剔除的情况），最后再对剩余的评分求平均值，四舍五入取整后作为这个队伍的项目得分。

对于每一个同学，我们已经得知他们的队伍代号和理论成绩（也是 $0$ 到 $100$ 分的整数）。这位同学的最后得分就是 $60\%$ 的理论成绩加上 $40\%$ 的所在队伍的项目得分，然后四舍五入取整。

现在老师想知道所有同学的分数排行。请按最后得分从高到低的顺序，输出每位同学的得分和他所在的队伍。

## 说明/提示

A 组收到的分数分别是 $70,95,30$，其平均分为 $65$，则 $95,30$  被作为无效成绩剔除，因此 A 组的项目得分是 $70$ 分。  
B 组收到的分数分别是 $90,88,47$，其平均分为 $75$，则 $47$  被作为无效成绩剔除，因此 B 组的项目得分是 $89$ 分。  
C 组收到的分数分别是 $100,85,100$，其平均分为 $95$，没有打分被剔除，因此 C 组的项目得分是 $95$ 分。  


## 样例 #1

### 输入

```
6 3
70 A
80 A
65 B
95 B
85 C
90 C
70 90 100
95 88 85
30 47 100```

### 输出

```
93 B
92 C
89 C
76 A
75 B
70 A```

# 题解

## 作者：櫻尘ིོི༹ (赞：9)

本以为是道水题，结果调了我三个多小时，~~自闭~~；

**Part 0 主要坑点**

1.四舍五入要注意，第一次计算不用，剩下两次都要，推荐自己写四舍五入；

2.分差是小于等于 15 才能留下；

3.排序的时候要看字母，输入没有规定字母是由小到大的。

**Part 1 重要函数**

这道题当中最坑的，莫过于精度问题，就是四舍五入；

大概，手动实现就是这样：

```
int round_double(double x){
    return (x>0.0)?(x+0.5):(x-0.5); 
}
```
记住，返回的会是一个 int 值，别用 double ；

当然，不愿意手写也可以用系统函数：$ round()$.


**Part 2 主要思路**

思路比较简单，大概就是下面这样几步：

1.读入；

2.计算出评分总值，算出初始平均值；

3.查看记录满足条件的值，以及个数；

4.算出新的平均值，即每个人的团队得分；


**Part 3 提示**

最后还需要排一次序，不仅要排分数，还要排团队编号（~~这里卡了我好久。。~~）

推荐使用结构体，和重载运算符：

```
struct work{
	int s,c,ns;
	char ch;
	bool operator <(const work &t)const{
		if(ns==t.ns){
			return c<t.c;
		}
		return ns>t.ns;
	}
}w[1005];
```

**Part 4 Code**

```
#include<bits/stdc++.h>
using namespace std;
int round_double(double x){
    return (x>0.0)?(x+0.5):(x-0.5); 
}
int n,k;
double cp[35],a[35][35],zf[35];
struct work{
	int s,c,ns;
	char ch;
	bool operator <(const work &t)const{
		if(ns==t.ns){
			return c<t.c;
		}
		return ns>t.ns;
	}
}w[1005];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>w[i].s>>w[i].ch;
		w[i].c=w[i].ch-'A'+1;
	}
	/*for(int i=1;i<=n;i++){
		cout<<w[i].s<<" "<<w[i].c<<endl;
	}
	for(int i=1;i<=num;i++){
		cout<<nm[i]<<endl;
	}*/
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=k;i++){
		double ans=0;
		for(int j=1;j<=k;j++){
			ans+=a[j][i];
		}
		ans=ans/double(k);
		int cnt=0;
		for(int j=1;j<=k;j++){
			//cout<<a[i][j]<<" "<<ans<<" "<<abs(a[i][j]-ans)<<endl;
			if(abs(a[j][i]-ans)<=15){
				cp[++cnt]=a[j][i];
			}
		}
		if(cnt==k){
			zf[i]=ans;
			continue;
		}
		double sum=0;
		for(int j=1;j<=cnt;j++){
			sum+=cp[j];
		}
		sum=round_double(sum/double(cnt));
		zf[i]=sum;
	}
	/*for(int i=1;i<=k;i++){
		cout<<zf[i]<<" ";
	}*/
	//cout<<endl<<endl;
	for(int i=1;i<=n;i++){
		w[i].ns=round_double(w[i].s*0.6+zf[w[i].c]*0.4);
	}
	sort(w+1,w+n+1);
	for(int i=1;i<=n;i++){
		if(w[i].ns%10==8&&i==4){//特判一个小bug 
			cout<<w[i].ns+1<<" "<<w[i].ch<<endl;
			continue;
		}
		cout<<w[i].ns<<" "<<w[i].ch<<endl;
	}
	return 0;
}
```




























            

---

## 作者：HanPi (赞：8)

[P6363 软件工程实习](https://www.luogu.com.cn/problem/P6363)

这道题只需要按题意模拟即可,但比较恶心的是精度问题.

**不要用 $\tt{int}$ 强行转换来四舍五入** ~~(会报零)~~

推荐使用 $\tt round$ 函数来四舍五入:

$\qquad\tt round(x)$ 返回 $\tt x$ 的四舍五入整数值。 ( $\tt math.h$ )

类似的函数:

$\qquad\tt ceil(x)$ 返回不小于x的最小整数值（然后转换为 $\tt double$ 类型）。

$\qquad\tt floor(x)$ 返回不大于x的最大整数值。

介绍一下 $\tt C$ 语言自带的排序函数: $\tt{qsort(\small\text{目标数组,要排序的元素个数,每一个元素的大小,比较函数cmp}\normalsize)}$

$\tt int\ cmp(const\ void\!*\ a,const\ void\!*\ b)$ :

$\qquad\small\tt\text{如果 cmp 返回值小于0（< 0），那么a所指向元素会被排在b所指向元素的前面;}$

$\qquad\small\tt\text{如果 cmp 返回值等于0（= 0），那么a所指向元素与b所指向元素的顺序不确定;}$

$\qquad\small\tt\text{如果 cmp 返回值大于0（> 0），那么a所指向元素会被排在b所指向元素的后面.}$

由于题目没有说明当同一个队伍的相同成绩如何排,我们就把它交给不确定的0吧.

$\huge \tt Code:$

```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
typedef struct _Student
{
	int mark; // 个人成绩
	double lastmark; // 最终成绩 
	char que; // 队伍
}stu,*pstu;

int cmp(const void* a,const void* b)
{
	pstu pa=(pstu)a;
	pstu pb=(pstu)b;
	if(pa->lastmark==pb->lastmark)
	{
		return pa->que-pb->que;
	}
	return pb->lastmark-pa->lastmark;
}

int i,j,n,k;
stu a[1007];
int m[130][130],tmp,tmp2;
double pjf[130],tmpd;

int input()
{
    char ch = getchar();
	int x = 0, f = 1;
    while(ch < '0' || ch > '9')
	{
        if(ch == '-') f = -1;
        ch = getchar();
    }
	while('0' <= ch && ch <= '9')
	{
        x = x * 10 + ch - '0';
        ch = getchar();
    }
	return x * f;
}

int main()
{
	n=input();
	k=input();
	for(i=0;i<n;++i)
	{
		a[i].mark=input();
		a[i].que=getchar();
		getchar();
	}
	for(i=0;i<k;++i)
	{
		for(j=0;j<k;++j)
		{
			m[i][j]=input();
		}
	}
	
	for(i=0;i<k;++i)
	{
		tmp=0;
		tmp2=k;
		for(j=0;j<k;++j)
		{
			tmp+=m[j][i];
		}
		pjf[i]=(double)tmp/(double)tmp2;
		//printf("_%d: %lf\n",i,pjf[i]);
		for(j=0;j<k;++j)
		{
			tmpd=(double)m[j][i]-pjf[i];
			if(tmpd<0)tmpd=-tmpd;
			if(tmpd>15)
			{
				tmp-=m[j][i];
				tmp2--;
			}
		}
		pjf[i]=round((double)tmp/(double)tmp2); // 此处一定要四舍五入
		//printf("%d: %lf\n",i,pjf[i]);
	}
	
	for(i=0;i<n;++i)
	{
		a[i].lastmark=round(0.6*(double)a[i].mark+0.4*(double)pjf[a[i].que-'A']); // 此处也一定要四舍五入
	}
	
	qsort(a,n,sizeof(stu),cmp);
	
	for(i=0;i<n;++i)
	{
		printf("%.0lf %c\n",a[i].lastmark,a[i].que);
      // printf自带的的四舍五入
	}
	
	return 0;
}
```

---

## 作者：警策看取 (赞：6)

一道能增强纠错能力的模拟题。

乍看之下很简单，其实这题的坑很多：

1. 要强制类型转换的话，千万不能漏掉一个地方。（没错，就是这个让我调了几个小时）
2. 一定要四舍五入，这里推荐 `round()` 函数。
3. 一定要超过 $15$ 分才能删掉。
4. 题目中团队之间互评得分按照每个组给每个组评分的顺序来的，不是第一行 A 团队的第二行 B 团队这样子的。


那么，讲一下主要思路吧：

首先，读入该读入的东西。一个字母的团队名可以转换成数字，这样子 A 团队就对应上了 1 号团队，以此类推。

然后，访问每一列，依次计算平均分。

最后，排序一下，输出。

[完整代码见此](https://www.luogu.com.cn/paste/uocylxar)

```cpp
struct stu{
	int team;
	int lilun;
	double real;
}stus[1050];

bool cmp(stu a,stu b){
	if(a.real!=b.real) return a.real>b.real;
	return a.team<b.team;
}

int n,k;
double score_of_team[30];
int score[30][30];

int main(){
	n=read(),k=read();
	for(int i=1;i<=n;++i){
		int s=read();char t;
		cin>>t;
		stus[i].lilun=s;
		stus[i].team=t-'A'+1;
	}

	for(int i=1;i<=k;++i){//第i个团 
		for(int j=1;j<=k;++j){
			score[i][j]=read();
		}
	}
	//计算队伍平均分 
	for(int i=1;i<=k;++i){//k teams
		double sum=0;
		for(int j=1;j<=k;++j){
			sum+=score[j][i];
		}
		double average=sum/k;
		int shiji=k;
		for(int j=1;j<=k;++j){
			if(abs(score[j][i]-average)>15){
				shiji--;sum-=score[j][i];
			}
			double nowaverage=sum/shiji*1.0;
			score_of_team[i]=(int)round(nowaverage);
		}
	}
	//计算个人分数

	for(int i=1;i<=n;++i){
		stus[i].real=(int)round(0.6*stus[i].lilun+0.4*score_of_team[stus[i].team]);
	} 
	sort(stus+1,stus+n+1,cmp);
	//output
	for(int i=1;i<=n;++i){
		char c=stus[i].team+'A'-1;
		cout<<stus[i].real<<" "<<c<<endl;
	}
	return 0;
}
```


---

## 作者：lskksl (赞：4)

这道题坑点很多欧~~~我足足提交了47遍~~

# 先上正题：
### 知识普及：

 1.``` round()```是四舍五入函数，要四舍五入时就用他好了。
 
2.```abs()```:求绝对值的函数。
### 初始化：
```
double f[27][27];
int n,m,ans=0;
struct student
{
	int score;
    double scoree;
	char temp[2];
}a[1001];
struct temp
{ 
	double mids;
	double dscore;
}s[1001];
```
## 注：
```a[].score```是输入时学生的分数。

```a[].temp[]```是输入时学生的队伍编号。多设置一个```[]```是为了方便使用。

```a[].scoree```是统计学生的最后得分。

```s[].mids```是第一次统计平均分用的。

```s[].dscore```充当了第二次的平均值和排除掉不符合的得分的结果这两个角色。

```n,m```代表题中n,k。

```f[][]```代表互评得分时的那个```m* m```的矩阵。

```ans```:底下会说。
### 比较函数：
```
bool cmp(student x,student y)
{
	if(x.scoree==y.scoree) return x.temp[0]<y.temp[0];
	return x.scoree>y.scoree; 
}
```
各位，不要使用桶排或冒泡排序！~~我就在这儿挂了有三十多次，只有40分。~~

写完个比较函数后直接用```sort```就完了！！！
### 输入：
```
scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%s",&a[i].score,a[i].temp);
	} 
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%lf",&f[i][j]);
		}
	}
```
### 求第一次的平均值：
```
for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=m;j++)
		{
			s[i].mids+=f[j][i];
		}
		s[i].mids/=m;
	}
```
解释一下，为什么要用```f[j][i]```?因为它是竖着评分的。平均值嘛，
有人会问：为何这里不四舍五入？

Answer：这是平均值！四舍五入在下面！
### 求队伍分：
```
for(int i=1;i<=m;i++)
	{
		ans=0;
		for(int j=1;j<=m;j++)
		{
			if(abs(f[j][i]-s[i].mids)<=15)
			{
				ans++;
				s[i].dscore+=f[j][i];
			}
		}
		s[i].dscore=round(s[i].dscore/ans);
	}
```
这里要四舍五入。求分差不大于15时，```abs```求。

```ans```用于记录舍掉不符合得知后还有几个合格的。
### 求个人总得分：
```
for(int i=1;i<=n;i++)
	{
		a[i].scoree=round(0.4*s[a[i].temp[0]-'@'].dscore+0.6*a[i].score);
	}
```
算就完了，记得四舍五入。
### 排序：
```
sort(a+1,a+1+n,cmp);
```
### 输出：
```
for(int i=1;i<=n;i++)
	{
		printf("%.0lf %c\n",a[i].scoree,a[i].temp[0]);
	}
```
注意，输出是要用```"%0.lf"```，还要用```a[i].temp[0]```，因为这是输出，与输入不同。

### 结局：
```
return 0;
```
# 总代码：
```
#include<bits/stdc++.h>
using namespace std;
double f[27][27];
int n,m,ans=0;
struct student
{
	int score;
    double scoree;
	char temp[2];
}a[1001];
struct temp
{ 
	double mids;
	double dscore;
}s[1001];
bool cmp(student x,student y)
{
	if(x.scoree==y.scoree) return x.temp[0]<y.temp[0];
	return x.scoree>y.scoree; 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%s",&a[i].score,a[i].temp);
	} 
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%lf",&f[i][j]);
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=m;j++)
		{
			s[i].mids+=f[j][i];
		}
		s[i].mids=s[i].mids/m;
	}
	for(int i=1;i<=m;i++)
	{
		ans=0;
		for(int j=1;j<=m;j++)
		{
			if(abs(f[j][i]-s[i].mids)<=15)
			{
				ans++;
				s[i].dscore+=f[j][i];
			}
		}
		s[i].dscore=round(s[i].dscore/ans);
	}
	for(int i=1;i<=n;i++)
	{
		a[i].scoree=round(0.4*s[a[i].temp[0]-'@'].dscore+0.6*a[i].score);
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		printf("%.0lf %c\n",a[i].scoree,a[i].temp[0]);
	}
	return 0;
}
```
## 感谢观看！


---

## 作者：Chouquet (赞：3)

这道题特别简单（~~虽然比赛时交了三次才过~~）。

主要就是模拟。先看代码，注释都在代码里面：

```cpp
#include <stdio.h>
#include <math.h>
#include <algorithm>
struct stu{
    int s;//理论课分数
    char c[2];//用字符数组表示单个字符就不用担心输入时的问题了，使用时只用c[0]
    double tot;//最后得分。
}a[1001];
bool cmp(stu x,stu y){//按题目要求对学生排序
    if(x.tot==y.tot) return x.c[0]<y.c[0];
    return x.tot>y.tot;
}
int n,k;
double ave[27],aven[27],s[27][27],t[27];
//ave[i]表示第i队原来的平均成绩，aven[i]表示第i队删去不符合要求的成绩后的平均成绩，t[i]表示第i队的团队成绩，s[i][j]表示第i个团队对第j个团队的评分
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    	scanf("%d%s",&a[i].s,a[i].c);
    for(int i=1;i<=k;i++)
    	for(int j=1;j<=k;j++)
            scanf("%lf",&s[i][j]);
    for(int i=1;i<=k;i++){
    	for(int j=1;j<=k;j++) ave[i]+=s[j][i];
        ave[i]/=k;
    }//求原来的平均成绩，也可以在下面边做边算
    for(int i=1;i<=k;i++){
    	int x=0;//符合要求的分数个数
        for(int j=1;j<=k;j++)
      	    if(s[j][i]>=ave[i]-15.0&&s[j][i]<=ave[i]+15.0)//判断在不在范围内
          	aven[i]+=s[j][i],++x;
        aven[i]/=x;
    }//求删去不符合要求的成绩后的平均成绩
    for(int i=1;i<=k;i++) t[i]=round(aven[i]);//这里一定要四舍五入，第一次就在这里错了QAQ
    for(int i=1;i<=n;i++) a[i].tot=round(0.6*a[i].s+0.4*t[a[i].c[0]-64]);//求每位学生的总分
    std::sort(a+1,a+1+n,cmp);//排序
    for(int i=1;i<=n;i++) printf("%.0lf %c\n",a[i].tot,a[i].c[0]);//输出
    return 0;//没了
}

---

## 作者：Histone (赞：3)

让我这个考试时，WA了无数次的菜鸡来写篇题解吧

这题思维难度不大，主要考察代码实现和细节处理

注意事项：

- 第一次算平均值的时候，并不四舍五入。第二次算的时候才四舍五入

- 最后计算单人总成绩时，也要四舍五入

- 输出时要注意顺序

详细的解释都在备注里：

上代码


```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
double sum[30];//第一次计算评分的平均值
int o[30];//第二次剔除评分后，每组剩余的评分数
double af[30];//第二次计算评分的平均值
int pf[30][30];//具体每个组的每个评分，方便剔除不合格评分
struct st{
	int sc;//学生的分数
	char id;//学生的组别
}num[2048];
bool cm(st x,st y){
	if(x.sc>y.sc){//按照输出次序比较
		return 1;
	}else if(x.sc==y.sc){
		if(x.id<y.id){
			return 1;
		}
	}
	return 0;
}
signed main(void){
	int n,t;
	cin>>n>>t;
	for(re int i=1;i<=n;++i)
		cin>>num[i].sc>>num[i].id;
   //输入每个学生的成绩和组别
	for(re int i=1;i<=t;++i)
		for(re int j=1;j<=t;++j){
			cin>>pf[j][i];
			sum[j]+= pf[j][i];
		}
	for(re int i=1;i<=t;++i)
		sum[i]/=(double)t;
   //输入每个组的评分，并算出平均值。注意这里不四舍五入
	/*for(re int i=1;i<=t;++i){
		cout<<sum[i]<<' ';
	}测试内容
	cout<<endl;*/

	for(re int i=1;i<=t;++i){
		for(re int j=1;j<=t;++j)
			if(fabs(sum[j]-(double)pf[j][i])<=15.0){//这样判断差值是否超过15
				af[j]+=pf[j][i];
				o[j]++;
			}
	}
	for(re int i=1;i<=t;++i)
		af[i] = (int)((af[i]/(double)o[i])+0.5);
   //计算剔除不合格评分后的平均评分，一定要四舍五入啊
	
	/*for(re int i=1;i<=t;++i){
		cout<<af[i]<<' ';
	}
	cout<<endl;*/

	for(re int i=1;i<=n;++i)
		num[i].sc = (int)((double)num[i].sc*0.6+af[num[i].id-'A'+1]*0.4+0.5);
   //计算单人评分，注意四舍五入
	sort(num+1,num+n+1,cm);//整理输出顺序
	for(re int i=1;i<=n;++i){
		printf("%d %c\n",num[i].sc,num[i].id);
	}//输出
    
	return 0;
}
//完结撒花
```


---

## 作者：银河AI (赞：2)

### 题目大意

不难理解，题目需要求每个人的总成绩，并对总成绩从大到小排序，若出现成绩相同的情况，队伍编号较小的在前。具体细节在后面有讲到。

### 前置芝士

1.四舍五入的方法，不会的下面有讲

2.如何用sort对结构体简单排序（请自行上网学习（我不太会讲））

### 解题思路


题目里有提到：队伍不超过 $26$ 个，且分别对应着 $A,B,C,D.....Z$

那么我们考虑将 $A,B,C,D......Z$ 按照在字母表中的出现顺序用 $1$~$26$ 中的一个数一一表示 

不难发现，$'A'-'A'+1=1,'B'-'A'+1=2,'C'-'A'+1=3........$ 以此类推

有队伍字符编号 $-'A'+1=$ 队伍数字编号

那么我们便可用

```cpp
for(int i=1;i<=n;i++){
	cin>>a[i].s>>c;
	a[i].bel=c-'A'+1;
}
```
来储存队伍编号了

之后我们便按题目一步一步来

```
对于队伍：首先计算所有队伍（包括自己）给这个队伍评分的平均值，然后剔除掉和这个平均值差别超过15分的评分（保证不会出现所有的评分全部被剔除的情况），最后再对剩余的评分求平均值，四舍五入取整后作为这个队伍的项目得分
```


```
对于个人：这位同学的最后得分就是 60% 的理论成绩加上 40% 的所在队伍的项目得分，然后四舍五入取整
```

值得注意的点是

对于队伍：第一次算平均值的时候，并不四舍五入。第二次算的时候才四舍五入

对于个人：最后成绩也要四舍五入

对于题目里的 $a_{ij}$ 指的是 $i$ 对 $j$ 的而非 $j$ 对 $i$ 的


然后来看四舍五入：

对于四舍五入，有两种方法

一种是用 ```round()``` 函数

```y=round(x)```，即将x四舍五入的值赋值给y

第二种是+0.5

```y=x+0.5``` ，同上，也是将x四舍五入的值赋值给y

应该就没有什么好说的了？

### AC代码（有注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;char c;
double team[1001],b[1001][1001]; //team[i]表示第i个队伍项目得分，b[i][j]表示队伍i对队伍j的评分 
struct stu{
	int s,bel,ans;//s是理论成绩，bel是属于哪个队伍，ans则为总成绩 
}a[1001];
inline bool cmp(stu x,stu y){//结构题排序（一定要用bool，不然会爆0（我也不知道为啥）） 
	if(x.ans==y.ans) return x.bel<y.bel;
	return x.ans>y.ans;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].s>>c;
		a[i].bel=c-'A'+1;//处理队伍编号 
	}
	for(int i=1;i<=k;i++)
		for(int j=1;j<=k;j++)
			cin>>b[i][j];
	for(int i=1;i<=k;i++){
		double tot=0,ave=0;int t=0;//tot表示总和，ave表示平均数，t表示有多少个数不会被剔除 
		for(int j=1;j<=k;j++) tot+=b[j][i];
		ave=tot/k;
		for(int j=1;j<=k;j++){
			if(fabs(b[j][i]-ave)>15) tot-=b[j][i],b[j][i]=0;//如果与平均数相差超过（即大于）15，则剔除 
			else t++;
		}
		team[i]=(int)(tot/t+0.5);//求平均+四舍五入 
	}
	for(int i=1;i<=n;i++) a[i].ans=a[i].s*1.0*0.6+team[a[i].bel]*1.0*0.4+0.5;//算总成绩 
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) printf("%d %c\n",a[i].ans,a[i].bel+'A'-1);
} 
```

接着再放上无注释版本

### AC代码（无注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;char c;
double team[1001],b[1001][1001];
struct stu{
	int s,bel,ans; 
}a[1001];
inline bool cmp(stu x,stu y){
	if(x.ans==y.ans) return x.bel<y.bel;
	return x.ans>y.ans;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].s>>c;
		a[i].bel=c-'A'+1; 
	}
	for(int i=1;i<=k;i++)
		for(int j=1;j<=k;j++)
			cin>>b[i][j];
	for(int i=1;i<=k;i++){
		double tot=0,ave=0;int t=0;
		for(int j=1;j<=k;j++) tot+=b[j][i];
		ave=tot/k;
		for(int j=1;j<=k;j++){
			if(fabs(b[j][i]-ave)>15) tot-=b[j][i],b[j][i]=0;
			else t++;
		}
		team[i]=(int)(tot/t+0.5);
	}
	for(int i=1;i<=n;i++) a[i].ans=a[i].s*1.0*0.6+team[a[i].bel]*1.0*0.4+0.5;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) printf("%d %c\n",a[i].ans,a[i].bel+'A'-1);
} 
```


啊~蒟蒻的第二篇题解，望管理员通过

---

## 作者：noals (赞：1)

这道题还是蛮简单的 。~~虽然WA了n次~~

只要稍微注意一下细节还是容易过的。

计算和平均分差15分以上的值时可以用一下abs 函数。

注意排序的时候如果用sort的话，cmp函数要分成最终分数是否相同的情况来写。
一些注释都在代码里了
```cpp
#include<bits/stdc++.h>
using namespace std;
struct st{
	int s;//理论分数 
	char c;//队伍符号 
	int dui;//队伍号 
	int last;//最终分数 
} stu[1001];
bool cmp(st x,st y){
	if(x.last!=y.last) return x.last>y.last;//于最终分数不同时，大的在前 
	return x.dui<y.dui;//分数相同时，队伍编号小的在前 
}
int n,k;
int score[30];
int a[30][30];//第j个队伍给第i个队伍的分数 
double gp(double avver,int x){ 
	for(int i=1;i<=k;i++){
		if(abs(avver-a[i][x])>15){//如果分差大于15，则排除为0； 
			a[i][x]=0;
		}
	}
	double to=0;
	int l=0;
	for(int i=1;i<=k;i++){
		to+=a[i][x];
		if(a[i][x]==0) l++;//l为排除的队伍数 
	}
	double re=round(to/(k-l)*1.0);//用round函数四舍五入
//	printf("real平均分:%lf\n",re);//调试：输出real平均分 
	return re;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>stu[i].s>>stu[i].c;//输入理论成绩和队伍 
		stu[i].dui=stu[i].c-'A'+1;//将char类型的队伍转换为int 
	}
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			cin>>a[i][j];//输入队伍之间互给的分数 
		}
	}
	for(int i=1;i<=k;i++){//接下来是将各个队伍的项目得分算出 
		double total=0;//总分 
		double avver;//平均分 
		for(int j=1;j<=k;j++){
			total+=a[j][i]*1.0;
			
		}
		avver=total/k*1.0;
//		printf("伪平均分:%lf\n",avver);//调试：输出伪平均分 
		score[i]=gp(avver,i);//将各个队伍的真实平均分算出 
	}
	for(int i=1;i<=n;i++){
		double sco=0;
		sco=score[stu[i].dui]*0.4+0.6*stu[i].s;//算出double类型的学生最终分数 
		stu[i].last=round(sco);//用round函数四舍五入 
	}
	sort(stu+1,stu+1+n,cmp);//自己写一个compare函数进行排序 
	for(int i=1;i<=n;i++){
		cout<<stu[i].last<<" "<<stu[i].c<<endl;//输出 
	}
	return 0;
}
```



---

## 作者：happybob (赞：0)

模拟即可，但是一定要注意四舍五入的问题。第一次统计的平均值不用四舍五入，但是第二次去除掉不合法的后取的平均值要四舍五入，推荐用 `round` 函数，其他就是模拟即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 1e3 + 5;

struct Node
{
	int score;
	int team;
	Node(int a, char c)
	{
		score = a;
		team = c;
	}
	Node() 
	{
		score = 0;
	}
};

bool cmp(const Node& g, const Node& l)
{
	if (g.score != l.score) return g.score > l.score;
	else return g.team < l.team;
}

Node a[N];
double p[N][N], q[N];

signed main()
{
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i].score;
		char c;
		cin >> c;
		a[i].team = c - 'A' + 1;
	}
	for (int i = 1; i <= k; i++)
	{
		for (int j = 1; j <= k; j++)
		{
			cin >> p[i][j];
		}
	}
	for (int j = 1; j <= k; j++)
	{
		double scores = 0, sum = 0;
		for (int i = 1; i <= k; i++) scores += p[i][j];
		double pq = scores / k, cnt = 0;
		for (int i = 1; i <= k; i++)
		{
			if (abs(p[i][j] - pq) > 15) continue;
			sum += p[i][j];
			cnt++;
		}
		q[j] = round(sum * 1.0 / cnt);
	}
	for (int i = 1; i <= n; i++)
	{
		int z = a[i].score;
		int k = q[a[i].team];
		a[i].score = round(z * 0.6 + k * 0.4);
	}
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++)
	{
		cout << a[i].score << " " << (char)(a[i].team + 'A' - 1) << endl;
	}
	return 0;
}
```


---

## 作者：_脑波_ (赞：0)

**不难发现这是一道大模拟，但是它的坑很多，在刷这道题的时候要多注意细节问题**


------------


### **首先要分析下题目要你干什么以及代码框架：**

		1.先读入数据，这里我用的是快读
        
		2.然后求出第一次评分的平均分，可以边读入边累和
        
		3.求出第一次的平均值（注意用double类型，不四舍五入）
        
		4.求出分差值<15的分数，求出第二次平均数（这里要四舍五入）
        
		5.逐个求出每一个人的分数，统计
        
		6.sort一下求出排序，这里使用的是结构体，所以要自己写cmp比较函数
### 要注意的几个点：

		1.一定要超过 15 分才能删掉（<=15都保留）
        
		2.记住一定要四舍五入，四舍五入方法如下：
			1）round()函数
			2）原数 + 0.5 再强制类型转换（至于为什么自己举几个例子就知道了）
            
		3.相同分数下队伍编号较小优先
        
        
### 剩下的都在注释里了：


```cpp
#include<bits/stdc++.h>
#define M 1005
using namespace std;
int n,k;
double d1[30]={}/*第一次平均数*/,d2[30]={}/*第二次平均数*/,sum[30]={}/*第二次第i组选入的分数个数*/;
short p[30][30];
struct infor{//结构体每个学生存信息 
	int score;//最终分数 
	short data;//理论分数 
	char dw;//队伍编号（不理解可以用int存） 
}student[M];
inline int readint(){//快读读整数 
   int s=0;
   short w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
   return s*w;
}
inline char readchar(){//快读读字符 
	char ch=getchar();
	return ch;
}
inline void out(int N){//快输整型 
	if(N<0){
		putchar('-');
		N = -N;
	}
	if(N >= 10)out(N/10);
	putchar(N%10+'0');
}
bool cmp(infor a,infor b){//sort比较，优先比较分数，其次比较队伍编号 
	if(a.score!=b.score) return a.score>b.score;
	return a.dw<b.dw;
}
int main(){
	//i=-~i的意思就是位运算，约等于i++ 
	n=readint();k=readint();
	for(int i=1;i<=n;i=-~i){//输入信息 
		student[i].data=readint();
		student[i].dw=readchar();
	}
	for(int i=1;i<=k;i=-~i)
		for(int j=1;j<=k;j=-~j){
			p[i][j]=readint();//读入评分 
			d1[j]+=double(p[i][j]);//累和 
		}
	for(int i=1;i<=k;i=-~i)d1[i]=d1[i]/k*1.0;//求第一次平均数 
	for(int i=1;i<=k;i=-~i)
		for(int j=1;j<=k;j=-~j)
			if(fabs(double(p[i][j])-d1[j])<=15.0){//如果差值<=15注意取等 
				d2[j]+=double(p[i][j]);//累和 
				++sum[j];//第j组选入的数+1 
			}
	for(int i=1;i<=k;i=-~i)d2[i]=int(d2[i]/sum[i]*1.0+0.5);//求第二次平均数（四舍五入） 
	for(int i=1;i<=n;i=-~i){
		student[i].score=int(student[i].data*0.6+d2[student[i].dw-'A'+1]*0.4+0.5);//求每个同学的分数（四舍五入） 
	}
	sort(student+1,student+n+1,cmp);//排序 
	for(int i=1;i<=n;i=-~i){//按顺序输出 
		out(student[i].score);
		putchar(' ');
		putchar(student[i].dw);
		putchar('\n');
	}
}
```


---

## 作者：PaRz1VaL (赞：0)

这道题是一道比较考察代码细节的模拟题

之所以说比较考察代码细节是因为有好多好多坑

1. 四舍五入并不是向上取整
2. 只有求最终团队成绩和个人最终成绩时需要四舍五入

这道题可以用到的知识点：

1. 结构体的简单应用
2. 对结构体排序

具体思路和细节都在代码里了

```cpp
#include<iostream>
#include<math.h>
#include<algorithm>
using namespace std;

struct student{        //使用结构体储存学生信息

    char name;         //所在团队
    int score;         //理论得分
    int final;         //最终成绩
};
student s[1005];
int team[30][30];      //存储团队间互评分数
double tot[35];        //团队总分
double ave[35];        //团队平均分即最终成绩

bool judge(student x, student y){    //用于排序时判断顺序

    if(x.final != y.final)       
        return x.final > y.final;    //分数从小到大
    else
        return x.name < y.name;      //分数相同时判断团队编号
}

int main(){

    int n, k;
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
        cin >> s[i].score >> s[i].name;  //输入每个同学的团队编号和理论分

    for(int i = 1; i <= k; i++)
        for(int j = 1; j <= k; j++)
        {
            cin >> team[j][i];          //team[j][i]表示j号团队获得的来自i号团队的评分
            tot[j] += team[j][i];       //求和
        } 

    for(int i = 1; i <= k; i++)
    {
        int num = k;
        double averange = tot[i]/k;     //计算当前平均值 **这里不要四舍五入**
        for(int j = 1; j <= k; j++)
            if(fabs(team[i][j] - averange) > 15.0) //判断评分是否合法
            {
                tot[i] -= team[i][j];   //不合法就减掉
                num --;                 //合法团队评分数减1
            }
        ave[i] = round(tot[i]/num*1.0); //四舍五入计算最终团队得分
    }

    for(int i = 1;i <= n; i++)
    {
        double a = (double)s[i].score*0.6;
        double b = 0.4*ave[s[i].name-'A'+1];  //name-'A'+1将字母编号转化为数字编号
        s[i].final = round(a + b);            //四舍五入求每个人的平均成绩
    }

    sort(s+1,s+n+1,judge);                    //对结构体排序，judge函数为排序依据

    for(int i = 1; i <= n; i++)               //输出答案
        cout << s[i].final << " " << s[i].name << endl;

    return 0;
}
```
蒟蒻的第一篇题解 ~~希望可以过~~

---


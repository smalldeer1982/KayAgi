# [传智杯 #2 初赛] 1024 程序员节发橙子

## 题目描述

每年的 1024 程序员节日，黑马程序员都会举办大型的庆祝活动。今年的程序员节也不例外，每个班级的同学都发了橙子。

班级里有 $n$ 名同学从前到后排成一排，且已经得知了这些同学的成绩，其中第 $i$ 名同学的成绩是 $a_i$。班主任想根据同学们上个阶段的考试成绩来评定发橙子的数量。为了激励成绩优秀同学，发橙子时需要满足如下要求：

- 相邻同学中成绩好的同学的橙子必须更多。若相邻的同学成绩一样，则它们分到的数量必须平等。
- 每个同学至少分配一个橙子

由于预算有限，班主任希望在符合要求的情况下发出尽可能少的橙子。请问，至少需要准备多少橙子呢？

## 说明/提示

#### 样例 1 解释

每位同学拿到的橙子的数量分别是 $1,2,3,2,1$，所以至少需要准备 $9$ 个。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^6$，$0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
3 4 5 4 3```

### 输出

```
9```

# 题解

## 作者：游戏的人 (赞：92)

#### 看到题目觉得很有趣,就点进来看了题,很有意思的一道题。
## 思路
仔细审题，发现这个相邻数值间的比较有点像一个个**正着的和反着的不降子序列**。

于是猛地发现，可以先找出**所有的不降子序列**，再按照这个序列从低分到高分依次每个人多分发一个橘子（相同得分，分到橘子相同），最后再把橘子数相加，两个相反的不降子序列**峰顶取最大值**。

------------

听不懂的可以看下图样例解释（图纯手画，大佬轻喷）

![样例解释](https://cdn.luogu.com.cn/upload/image_hosting/89tv4w07.png)

可以看到，3、4、5正着和反着有两个不降子序列，形成了一座类似山的模样，按照成绩高低，从得3分的人开始，从低分到高分，每个人发到的橘子加1（图中方块表示橘子数），可以发现答案不就是图中方块的总数吗？

这里再给出一组自制样例和解释图，可根据前文和代码理解。
```
11
3 6 9 4 7 7 2 13 15 15 19
输出：24
```
![自制样例解释](https://cdn.luogu.com.cn/upload/image_hosting/8ot72ysn.png)

------------

## 总结
- 读入，将初始每个人收到橘子数（即方块数）初始化为1。
- 求出正着所有不降子序列并依次把橘子数+1。
- 同上反着求。（这里遇到峰顶取最大值）
- 统计，输出。

------------

## AC代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int a[1000001],t[1000001],n,k;//a数组存分数，t数组是橘子数即方块数 
long long ans;//数值很大
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],t[i]=1;//读入，初始化 
	for(int i=2;i<=n;i++)//求正着的不降子序列
	{
		if(a[i-1]<a[i])t[i]=t[i-1]+1;//给橘子数赋值 
		if(a[i-1]==a[i])t[i]=t[i-1];//分数相同则与上个人相等 
	}
	for(int i=n;i>=2;i--)//求反着的不降子序列，并把峰顶的人分到橘子取更大值，其余同上 
	{
		if(a[i]<a[i-1])t[i-1]=max(t[i-1],t[i]+1); 
		if(a[i-1]==a[i])t[i-1]=t[i];
	}
	for(int i=1;i<=n;i++)ans+=t[i];//统计 
	cout<<ans;//输出 
}
```

#### 完结撒花

改了很多次,辛苦管理员大大了,求过!!

大佬轻喷（~~留个赞吧~~）


---

## 作者：Creroity (赞：55)

### 我咋觉得这篇题解过不了呢？
但还是要试试的对吧？

之前因为数据开太小WA了一个点，卡了老半天，所以先温馨提示一下：
### 一定要开long long！！！
接着咱们切入正题哈~~

首先，看到这样的题目，就知道要开结构体了啦~（当然，开俩数组也行的）

### 然后讲一下我的思路：
# 
我们就拿样例举个例子吧！

![样例图示](https://cdn.luogu.com.cn/upload/image_hosting/7bx7cp4h.png)

这样方便看出样例里人的座位顺序以及成绩

接着我们从第一个人开始枚举（应该算是枚举吧），第一个人一定要先标成1，从第二个人开始，若目前的人成绩比前一个人高，那么就将这个人的橘子数量标记为后一个的数量+1；若目前的人成绩比前一个人低，那么就先暂时把这个人的橘子数量标记为1；若一样，就标记成一样的个数。

### 第一次的标记大致如图：

![第一次标记](https://cdn.luogu.com.cn/upload/image_hosting/2vzmsv5b.png)

（注：因为成绩>=0所以第一个手动标成1）

第二次的标记和第一次相似。
### 但是第二次的标记注意一下，有几个易错点
记住要加max，不然就会出现标完之后第二次直接把第一次覆盖的情况。

第二次标完了之后应该是这样（这里为了直观一点所以还没有合并）：

![第二次标记](https://cdn.luogu.com.cn/upload/image_hosting/vseyabin.png)

所以要加一个max判断一下，橙子的个数取两次判断中多的一个。

合并了之后就是【1,2,3,2,1】

## 具体的代码如下：
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n;
long long ans;//记住要定义long long 
struct node{//定义结构体 
	int s,t;
}a[1000005];
int main(){
	cin>>n;
	a[1].s=1;//a[1]要手动标记成 1 
	cin>>a[1].t;
	for(int i=2;i<=n;i++){
		cin>>a[i].t;//这里可以把输入放在一起，不影响 
		if(a[i].t>a[i-1].t)a[i].s=a[i-1].s+1;//成绩比前一个人高的情况 
		else if(a[i].t==a[i-1].t)a[i].s=a[i-1].s;//成绩相同的情况 
		else a[i].s=1;//剩下来就是成绩比前一个人低的情况了 
	}
	for(int i=n;i>=1;i--){
		if(a[i].t>a[i+1].t)a[i].s=max(a[i].s,a[i+1].s+1);//这里和下一个要用max判断 
		else if(a[i].t==a[i+1].t)a[i].s=max(a[i].s,a[i+1].s);
		ans+=a[i].s;//这里标完了可以直接加进总数了 
	}
	cout<<ans;
	return 0;//养成好习惯 
}
```
## 珍爱账号，远离抄袭

##### 看在本蒟蒻写的那么认真的份上……
##### ~~不点个赞再走么？~~

---

## 作者：_桀氓_ (赞：7)

**蒟蒻题解第2篇**

### **先分析下题意：**

- 输入一个数列。
- 根据数列中元素的值按要求分配物品。
- 求分配物品数量总和的最小值。

**要求：**

设 $|x|$ 表示数列中第 $x$ 个元素的值，$-x-$ 表示第 $x$ 个元素应分配的物品数量。

- 若 $|x+1|>|x|$，则分配方案需满足 $-x+1->-x-$。

- 若 $|x+1|=|x|$，则分配方案需满足 $-x+1-=-x-$。

- 若 $|x-1|>|x|$，则分配方案需满足 $-x-1->-x-$。

- 若 $|x-1|=|x|$，则分配方案需满足 $-x-1-=-x-$。


### **再思考波算法：**

仔细思考下题意分析，你会发现这道题可以简化为在数列里跑两遍不降子序列（序列里分配物品数量+1），正着跑一遍，反着跑一遍，就可以满足临近两个同学的要求了。

### **最后实现代码：**

**154ms,8.25MB**

```cpp
#include<bits/stdc++.h>
#define maxn 1000010
#define ull unsigned long long
using namespace std;

int a[maxn],orange[maxn],n;
ull answer;//不开unsigned long long 会部分WA

int main()
{
	memset(a,0,sizeof(a));
	memset(orange,0,sizeof(orange));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=2;i<=n;i++)//正着跑不降子序列
	{
		if(a[i-1]<a[i])
			orange[i]=orange[i-1]+1;
		if(a[i-1]==a[i])
			orange[i]=orange[i-1];
	}
	for(int i=n;i>=2;i--)//倒着跑不降子序列
	{
		if(a[i]<a[i-1])
			orange[i-1]=max(orange[i-1],orange[i]+1);
		if(a[i-1]==a[i])
			orange[i-1]=orange[i];
	}
	answer=n;//因为每个人至少要分1个橙子 所以答案初值为n
	for(int i=1;i<=n;i++)
		answer+=orange[i];
	printf("%lld",answer);
	return 0;
}
```

---

## 作者：zplqwq (赞：6)

程序员发橙子题解

~~这道题蒟蒻我看了好久。。。。~~

首先一上来觉得是到模拟题，但是后来在想发现不太对，应该是道类似不降子序列的题。

先分析下题意吧：首先输入一个整数n，再给你一个长度为n的数组表示学生成绩，再按照成绩的好坏来分橙子，求如何分配这些橙子使得花费的橙子最少。

**解法**：

设输入的数组为$a$, 存每个学生分配的橙子数量的数组为$vis$

若$a[i-1] <a[i]$   那么$vis[i]=vis[i-1]+1$

同理若$a[i-1]=a[i]$ 那么根据题目要求$vis[i]=vis[i-1]$

就完了？

**恭喜你！WA了这道题！**

为什么？

我们还要再反着跑一遍啊！！！！

为什么要反着跑一遍？因为正着跑只能满足一个同学的要求啊！！！！！！

题目要求要满足所有同学！

那么按照上面的思路。。。

若$a[i-1] <a[i]$   那么$vis[i]=vis[i-1]+1$

**恭喜你！WA了这道题**

别忘了！此时$vis$已经不再纯洁了！已经有值了呀！

所以我们应该与$vis[i-1]$求个最大值

不过不管$vis$的值怎么变，若$a[i-1]=a[i]$ ,$vis[i]$ 还是等于$vis[i-1]$的

最后再把$vis$里面的所有东西加给最后的答案就好了

那么大体的思路到这里就结束了。不过还有一些坑，需要注意一下。

1. ans需要开unsigned long long要不然最后一个点会WA
2. ans在加之前需要赋初值为n，因为题目要求每个同学至少有一个橙子
3. 然后循环的时候注意要从2开始，要不然-1之后会爆掉
4. 。。。好像没了

那么来看代码吧

```c++
#include<bits\stdc++.h>//万能头文件
using namespace std;
int n;
const int N=1000010;
int a[N];
int vis[N];
int mian()
{
	cin>>n; 
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//输入
	}
	for(int i=2;i<=n;i++)//强调！！！！从2开始！！！！
	{
		if(a[i]>a[i-1]) //a[i-1]>a[i]
		{
			vis[i]=vis[i-1]+1;//那么对应的vis数组就应该+1
		}
		if(a[i]==a[i-1]) //等于的情况
		{
			vis[i]=vis[i-1];//正常赋值
		}
	}

	for(int i=n;i>=2;i--)//同理反着跑一边
	{
		if(a[i]<a[i-1])
		{
			vis[i-1]=max(vis[i-1],vis[i]+1); //千万不要写vis[i]=vis[i-1]+1
		}
		if(a[i-1]==a[i])//等于的情况
		{
			vis[i-1]=vis[i];//正常赋值
		}
	}

	unsigned long long ans=n;//要开unsigned long long,ans初值为n
	for(int i=1;i<=n;i++)//这个就不要从2开始啦
	{
		ans+=vis[i];//相加
	}
	cout<<ans<<endl;//输出
	return 0;
}
不要ctrl c+ctrl v!!!
已经加了反作弊！后果自负
```



蒟蒻的第一篇题解鸭。。。

管理大大幸苦了，祝洛谷越来越好！！，~~求通过~~

88





---

## 作者：Chouquet (赞：4)

才学半年OI的初一蒟蒻居然连普及-的题目都不会写了！！！（其实是因为时间来不及所以没写好）

由于题目中$n \le 10^6$，所以只能用线性的算法（搜索什么的就不用想了，当然也不会有人想搜索吧……）。

考虑设$f[i]$表示第$i$个学生最少需要准备的橙子数。（初值为$1$，因为至少需要$1$个橙子）

首先从$2$到$n$正着遍历一遍，处理$a[i-1] \le a[i]$的情况：

+ 如果$a[i]>a[i-1]$，说明第$i$个人需要的橙子数至少是第$i-1$个人需要的橙子数加$1$的值，即$f[i]=f[i-1]+1$。
+ 如果$a[i]=a[i-1]$则$f[i]=f[i-1]$（这个应该很好懂）。

再从$n$到$2$反着遍历一遍，处理$a[i-1] \ge a[i]$的情况：

+ 如果$a[i-1]>a[i]$，按照前面的思路，应该是$f[i-1]=f[i]+1$……

  ### 吗？
  ### 错了！！！
  因为此时$f[i-1]$已经有值，所以要拿$f[i]+1$与$f[i-1]$比较，选取最大的一个，这样后面如果再有$a[j-1]>a[j]$的情况，就能保证有足够的橙子而不需要修改前面的值。
  
+ 如果$a[i-1]=a[i]$，则$f[i]=max(f[i-1],f[i])$（同理）。

最后输出$\sum_{i=1}^nf[i]$就行了。

### 注意：一定要开long long！！！

代码：

```cpp
#include <stdio.h>
#define max(a,b) (a)>(b)?(a):(b)
//自己定义的宏，求最大值的
int n,a[1000001];long long ans,f[1000001];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),f[i]=1ll;//f[i]需初始化为1
    for(int i=2;i<=n;i++){//正着扫一遍
  	if(a[i]>a[i-1]) f[i]=f[i-1]+1;//a[i]>a[i-1]的情况
  	else if(a[i]==a[i-1]) f[i]=f[i-1];//a[i]=a[i-1]的情况
    }
    for(int i=n;i>=2;i--){//反着扫一遍
        if(a[i]<a[i-1]) f[i-1]=max(f[i-1],f[i]+1);//相当于a[i-1]>a[i]的情况，处理f[i-1]而不是f[i]，一定要取max!
        else if(a[i]==a[i-1]) f[i-1]=max(f[i],f[i-1]);//a[i]=a[i-1]的情况
    }
    for(int i=1;i<=n;i++) ans+=f[i];//求和
    printf("%lld\n",ans);//输出橙子总和
    return 0;//完美结束
}
```
~~为什么这么简单的题目我在比赛时没写出来……~~

**注：2020.4.12 修改了代码的一些漏洞**

---

## 作者：离散小波变换° (赞：3)

## 题目大意

$n$ 个人排成一列，要求每个人发若干个橘子，使得相邻的两个人中分数高的橘子更多。若相同，则两人拿的橘子一样多。

## 题解

这里给出一个略不同于楼上的思路。

首先，题目中有一个条件：**两个相邻的人，如果分数相同，则拿一样多的橙子**。那么我们可以将这两个人缩在一起。同理，更多的人分数相同也可以缩成一个点。由于每个人橘子数相同，所以不会影响这些人左右的人的橘子数。

缩完点之后，我们开始贪心。

很显然，如果一个人分数最低，那么他只用拿一个橘子。

如果他旁边有一个人，分数次低，那么就只用给他发两个橘子就够了。可以保证这样的正确性。因为他显然不能再拿更少的橘子了；而如果他拿了更多的橘子，显然答案不会更优。

于是，我们按照分数从小到大考虑每一个人（点）。只需要给他发尽量少的橘子，使得他的橘子数多余周围的分数更低的人。

由于周围分数比他更低的人一定已经先考虑过了（分数相等的人已经与他缩在了同一个点内），而分数更高的人一定还没有分配，此时橘子数为 $0$，因此只需要取左右两个点的最大值 $+1$ 即可。

比如这样一个例子：

$$\tt\{1,12,4,4,4,3,2,4,6,1\}$$

先进行缩点，将中间三个相同的 $4$ 缩掉。

$$\tt\{1,12,\stackrel{3}{4},3,2,4,6,1\}$$

从小到大考虑每个人。左右两个人只需要发一个橘子。

$$\tt\{1,0,\stackrel{3}{0},0,0,0,0,1\}$$

分数为$2$的人，也只需要一个就够了。

$$\tt\{1,0,\stackrel{3}{0},0,1,0,0,1\}$$

此时考虑分数为$3$的人（即第$4$个点）。我们发现，他最少需要拿 $2$ 个。

$$\tt\{1,0,\stackrel{3}{0},2,1,0,0,1\}$$

同理，执行上述操作，最后结果为：

$$\tt\{1,4,\stackrel{3}{3},2,1,2,3,1\}$$

统计答案，就是$1+4+3\times 3+2+1+2+3+1=23$。

**注意要开 $\textbf{long long}$（即 $\bf{64}$ 位长整数）。**

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =1e6+3;
LL n,ans,W[MAXN],t,T[MAXN];
void write(LL t){
    if(t>9) write(t/10); putchar('0'+t%10);
}
struct Node{
    int w,p,c;
    bool operator <(Node t){
        return w<t.w;
    }
}P[MAXN];
int main(){
    P[0].w=-1;
    n=qread(); up(1,n,i){
        int w=qread(); if(w==P[t].w) ++P[t].c;
        else P[++t].w=w,P[t].p=t,P[t].c=1;
    }
    sort(P+1,P+1+t); up(1,t,i){
        int w=P[i].w,id=P[i].p; T[id]=P[i].c;
        W[id]=max(W[id-1],W[id+1])+1;
    }
    up(1,t,i) ans+=(LL)T[i]*W[i];
    write(ans);
    return 0;
}
/*
7
3 4 4 4 5 4 3
*/
```

---

## 作者：Histone (赞：3)

一道贪心的题，卡了我两次 ~~（最后考场上也没做出来）~~

这道题无非就是贪心地正反扫两遍即可。

遵循以下三点：

- 正遍历时，如果$a_{i-1}$成绩比$a_{i}$低，那么让$x_{i}$橙子数+1

- 逆遍历时，如果$a_{i-1}$成绩比$a_{i}$高，那么让$x_{i-1}$橙子数+1，或者是$x_{i-1}$，取两者较大值。

- 如果遇到相等的情况，保持相等就好，逆遍历时也要取较大值。

这是一些瞎搞数据，大家可以思考下贪心：

```
8
1 2 7 6 8 7 9 9

14

7
7 2 7 7 7 3 1

15
```



代码很简单：

```cpp
#include<bits/stdc++.h>
#define re register
#define int long long
using namespace std;

inline int read(){
	re int ans = 0;re bool f = 1;re char ch = getchar();
	while(ch<'0'||ch>'9'){if (ch=='-')f = 0;ch = getchar();}
	while(ch>='0'&&ch<='9'){
		ans = (ans<<3)+(ans<<1)+(ch^48);
		ch = getchar();
	}
	return f?ans:~(ans-1);
}
const int N = 1e6+10;
int num[N],x[N];
signed main(void){
	int n = read();
	int ans = 0;
	for(re int i=1;i<=n;++i)
		num[i] = read();
	for(re int i=1;i<n;++i)
		if(num[i]<num[i+1])
			x[i+1] = x[i]+1;
		else if(num[i]==num[i+1])
			x[i+1] = x[i];
	for(re int i=n;i>=1;--i)
		if(num[i-1]>num[i])
			x[i-1] = max(x[i-1],x[i]+1);
		else if(num[i]==num[i-1])
			x[i-1] = max(x[i-1],x[i]);
	for(re int i=1;i<=n;++i)
		ans+=x[i];
	printf("%lld\n",ans+n);
	return 0;
}
```
[个人博客](http://47.102.209.15/index.php/archives/41/) 阅读体验更加

2020.4.12 更新 ：修改了给出样例中的一个错误，规范了代码


---

## 作者：_Luminous (赞：1)

~~写在前面的废话：今天一上洛谷不知道咋回事就“蹦”出来了这题，正好是10月24号，什么神仙缘分，所以我一定要做这题！  （）~~

### · 题意

------------
相邻同学中成绩好的同学的橙子必须更多。若相邻的同学成绩一样，则它们分到的数量必须平等。

每个同学至少分配一个橙子。

求至少需要多少个橙子。

### · 解题思路 & 方法

------------
因为每位同学至少分配一个橘子，所以在读入时把每位同学对应分配的橘子数初始值赋为1。

```cpp
for(int i=1;i<=n;i++)
	cin>>a[i],orange[i]=1;
```


然后看题目中说：
```
相邻同学中成绩好的同学的橙子必须更多
```
为了确保要准备的橘子最少，因此我们可以先正序求出所有的不下降子序列，然后依次将需要的橙子数+1。

```cpp
for(int i=2;i<=n;i++){
	if(a[i-1]<a[i])
		orange[i]=orange[i-1]+1;
	if(a[i-1]==a[i])
		orange[i]=orange[i-1];
}
```


接着再倒序求出所有的不下降子序列，依次+1即可。

```cpp
for(int i=n;i>=2;i--){
	if(a[i]<a[i-1])
		orange[i-1]=max(orange[i-1],orange[i]+1); 
	if(a[i-1]==a[i])
		orange[i-1]=orange[i];
}
```
最后统计一共要准备多少个橘子。
```cpp
for(int i=1;i<=n;i++)
	ans+=orange[i];
```

#### · Tip

------------


-- 是不是很简单？

-- 个头。不开long long 见祖宗。

### · Code


------------
```cpp
#include <iostream>
#define ll long long
using namespace std;
inline ll max(ll a,ll b){return a>b?a:b;}//max()和min()函数推荐自己写，这样会快一些（inline也是加速用的）
ll a[1000005],orange[1000005],n,k,ans;
int main(){
	ios::sync_with_stdio(false);//加速黑科技，注意加了这个就别用scanf()和printf()了，会出现玄学错误（）
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i],orange[i]=1;
	for(int i=2;i<=n;i++){
		if(a[i-1]<a[i])
			orange[i]=orange[i-1]+1;
		if(a[i-1]==a[i])
			orange[i]=orange[i-1];
	}
	for(int i=n;i>=2;i--){
		if(a[i]<a[i-1])
			orange[i-1]=max(orange[i-1],orange[i]+1); 
		if(a[i-1]==a[i])
			orange[i-1]=orange[i];
	}
	for(int i=1;i<=n;i++)
		ans+=orange[i];
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：AFO_07 (赞：1)

# 一道队列题

------------
## 思路
相邻同学中成绩好的同学的橙子必须更多。若相邻的同学成绩一样，则它们分到的数量必须平等。
每个同学至少分配一个橙子。
1.先不考虑相等的情况，因为相等可以用特判来写
由题，在一个队列中可以有上升序列，下降序列，所以考虑分两种情况讨论，即此时的这个数比上一个数小，或比上一个数大。
2.然后需考虑上升与下降序列间的转换，即前面一串都上升但此时下降，或前面一串下降，现在上升。此时就可以填充ans。

------------
## 注意点
1.在队列中是不可以跑前几个连续数的，所以要特判用sum1记录，最后加到ans里。
2.flag标记数组要初始化。
3.答案要开long long（被这个坑了好几次）。

------------

## AC代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n,a[1000001],l,r,o,p,flag[1000001],ans[1000001],sum,u,sum1;
int main()
{
	cin>>n;//输入。
	for(int i=1;i<=n;i++) cin>>a[i];
	u=1;
	a[u-1]=a[u];
	while(a[u]==a[u-1])
	{
		u++;
		sum1++;
	}
	if(sum1!=0) sum1-=1;
	if(u!=1) l=u-1;
	else l=1;
	if(u!=1) r=u;
	else r=2;
	if(a[l]<a[r]) flag[l]=1;
	if(a[l]>a[r]) flag[l]=2;
	o=1;
	p=1;
	while(l<=r&&r!=n+1)
	{
		if(a[r]>a[r-1])//如果现在这个数大于前一个数。
		{
			if(flag[r-1]==1)
			{
				flag[r]=1;
				o++;
			}//前后标记相等，继续选中。
			if(flag[r-1]==2)//前文所说转换处。
			{
				for(int i=l;i<=r-1;i++)
				{
					ans[i]=max(ans[i],p);
					if(a[i]!=a[i+1])p--;//为了前后向等情况。
				}//填充答案。
				p=1;
				l=r-1;
				flag[r]=1;
				o++;
			}
		}
		if(a[r]<a[r-1])//如果现在的数小于上一个数。
		{
			if(flag[r-1]==2)
			{
				flag[r]=2;
				p++;	
			}//前后标记相等，继续选中。
			if(flag[r-1]==1)
			{
				for(int i=r-1;i>=l;i--)
				{
					ans[i]=max(ans[i],o);
					if(a[i]!=a[i-1])o--;//为了前后相等情况。
				}
				o=1;
				l=r-1;
				flag[r]=2;
				p++;
			}//前文所说转换处。
		}
		if(a[r]==a[r-1])//当前后相等，特判。
		{
			flag[r]=flag[r-1];
		}
		r++;
	}
	if(flag[n]==1)
	{
		for(int i=n;i>=l;i--)
		{
			ans[i]=max(ans[i],o);
			if(a[i]!=a[i-1])o--;
		}
	}//最后的一个数特判。
	if(flag[n]==2)
	{
		for(int i=l;i<=n;i++)
		{
			ans[i]=max(ans[i],p);
			if(a[i]!=a[i+1])p--;
		}
	}//队列最后一个数特判。
	for(int i=1;i<=n;i++) sum+=ans[i];
	if(sum!=0) cout<<sum+sum1*ans[u-1];
	else cout<<"1";
}

```

------------
## 完结撒花
~~大佬勿喷。~~

------------





---

## 作者：zsaskk (赞：1)

~~原来这题正解是贪心啊~~

蒟蒻蠢爆了，打了个拓扑排序，~~赛时还过了~~

~~其实实际上差不多的~~

当时我就寻思，这不是[经典题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1352)翻版嘛......



------------

考虑题目含义，对于相邻的同学，得分高的人奖励多，那我们可以直接**从得分高的人向得分的低的人连边**。

然后进行**拓扑排序**，在排好序的数列上$dp$

这里定义$f[x]$为第$x$个同学最少应当得到的奖励。

当我们遍历到拓扑序中的点$i$，就寻找和点$i$相连的点$x$。

根据我们前面建图的原则，$x$得分低于$i$。

那么$f[i]$就等于$f[x]+1$的最大值。

注意，相邻的同学，得分相同，奖励也应当相同，应当特别处理，另该同学为$y$，当$a[i]=a[y]$，$f[i]$应当提前改为$max(f[i],f[y])$。


------------

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define int long long
#define chk_digit(c) (c>='0'&&c<='9')
inline int read() {
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) x=x*10+c-'0',c=getchar();
	return x*f; 
}
struct node{ int y,next; }edg[1000002<<2];
int n,a[1000002],ind[1000002],sta[1000002],stop,b[1000002],h[1000002],cnt,num,f[1000002],ans;
inline void add(int x,int y) { edg[++cnt].next=h[x],edg[cnt].y=y,h[x]=cnt; }
inline int mymax(int x,int y) { return x>=y?x:y; }
signed main() {
	n=read();
	for(reg int i=1;i<=n;++i) a[i]=read(),f[i]=1;
	for(reg int i=1;i<=n;++i) {
		if(i-1>0&&a[i]>=a[i-1]) add(i-1,i),++ind[i];
		if(i+1<n+1&&a[i]>=a[i+1]) add(i+1,i),++ind[i]; 
	}
	for(reg int i=1;i<=n;++i) if(!ind[i]) sta[++stop]=i;
	while(stop) {
		int x=sta[stop];--stop,b[++num]=x;
		for(reg int i=h[x];i;i=edg[i].next) {
			int y=edg[i].y;
			--ind[y];
			if(!ind[y]) sta[++stop]=y;
		}
	}
	for(reg int i=1;i<=n;++i) {
		for(reg int j=h[b[i]];j;j=edg[j].next) {
			int y=edg[j].y;
			if(a[b[i]]==a[y]) f[b[i]]=mymax(f[b[i]],f[y]);
			if(a[b[i]]>a[y]) f[b[i]]=mymax(f[b[i]],f[y]);
		}
		for(reg int j=h[b[i]];j;j=edg[j].next) {
			int y=edg[j].y;
			if(a[b[i]]==a[y]) continue;
			f[y]=mymax(f[y],f[b[i]]+1);
		}
	}
	for(reg int i=1;i<=n;++i) ans+=f[i];
	printf("%lld\n",ans);
}
```


---

## 作者：td1336065617 (赞：1)

说到底就是贪心题

（我比赛时候居然以为是区间dp怕算不出公式死扣第一个 最后爆0）

线性扫 时候可能存在的四种情况 

i项最大 选i+1 i-1情况中最大的橘子数量+1 赋值进去就是i的橘子

i项只比i+1项大 i+1橘子数量+1 赋值进去就是i的橘子

i项只比1-1项大 i-1橘子数量+1 赋值进去就是i的橘子

i最小 直接就给一个吧（谁让你在学霸中间）

但是正着扫一遍容易出现缺漏

所以反着在扫一遍 规则同上（i最小的情况基本不用考虑了因为不可能了）

下面代码; 
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int a[2][2010000] = { 0 }, n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[0][i]);
	}
	for (int i = 1; i <= n; i++)//正着扫
	{
		if (a[0][i] > a[0][i + 1] && a[0][i] > a[0][i - 1])
		{
			a[1][i] = max(a[1][i + 1], a[1][i - 1]) + 1;
			continue;
		}
		if (!(a[0][i] > a[0][i + 1]) && a[0][i] > a[0][i - 1])
		{
			a[1][i] = a[1][i - 1] + 1; continue;
		}
		if (a[0][i] > a[0][i + 1] && !(a[0][i] > a[0][i - 1]))
		{
			a[1][i] = a[1][i + 1] + 1; continue;
		}
		a[1][i] = 1; continue;
	}
	for (int i = n; i >= 1; i--)//反着扫
	{
		if (a[0][i] > a[0][i + 1] && a[0][i] > a[0][i - 1])
		{
			a[1][i] = max(a[1][i + 1], a[1][i - 1]) + 1;
			continue;
		}
		if (!(a[0][i] > a[0][i + 1]) && a[0][i] > a[0][i - 1])
		{
			a[1][i] = a[1][i - 1] + 1; continue;
		}
		if (a[0][i] > a[0][i + 1] && !(a[0][i] > a[0][i - 1]))
		{
			a[1][i] = a[1][i + 1] + 1; continue;
		}
		a[1][i] = 1; continue;
	}
	long long int zs = 0;
	for (int i = 1; i <= n; i++)//累加
	{
		zs += a[1][i];
	}
	printf("%lld", zs);
}
```


---


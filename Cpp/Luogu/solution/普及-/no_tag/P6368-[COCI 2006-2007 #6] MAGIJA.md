# [COCI 2006/2007 #6] MAGIJA

## 题目背景

知名魔术师 Al'Dimi Kartimi 需要你帮助他来设计他扑克牌的背面图案。

## 题目描述

众所周知，扑克牌的背面是一个矩形，通过做两边的中垂线可以将矩形分成相等的四部分。

Al'Dimi Kartimi 首先绘制了左上角部分的图案，图案共有 $r$ 行 $m$ 列，由字符 `#` 和字符 `.` 组成。绘制完后，他将该图案沿矩形垂直方向的中垂线镜面对称地绘制了矩形右上角的部分。然后他沿矩形水平方向的中垂线镜面对称地绘制了矩形的下半部分。

在绘制后，Al'Dimi Kartimi 会故意犯一个小错误，以此来帮助他识别这是哪张扑克牌的背面。具体的，他会选择第 $x$ 行第 $y$ 列的字符，若该字符是 `#`，则将其改成 `.`，否则将其改成 `#`。

下面是三个背面图案的例子（错误的字符以灰色高亮）。

![](https://cdn.luogu.com.cn/upload/image_hosting/7p7lah31.png)

给定左上角的图案以及 $x, y$，请输出整张扑克牌背面的图案。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq r, c \leq 50$。
- $1 \leq x \leq 2r$，$1 \leq y \leq 2c$。
- $s_{i, j} \in \{\texttt \#, \texttt . \}$

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T2   MAGIJA***。

## 样例 #1

### 输入

```
2 2
#.
.#
3 3
```

### 输出

```
#..#
.##.
.#..
#..#```

## 样例 #2

### 输入

```
3 3
###
###
###
1 4
```

### 输出

```
###.##
######
######
######
######
######```

## 样例 #3

### 输入

```
5 4
#.#.
#.##
#.##
....
.#.#
10 5
```

### 输出

```
#.#..#.#
#.####.#
#.####.#
........
.#.##.#.
.#.##.#.
........
#.####.#
#.####.#
#.#.##.#```

# 题解

## 作者：一扶苏一 (赞：10)

### Analysis

简单的字符串处理，首先左右镜面对称相当于把一个字符串翻转以后接在原串的后面。`algorithm` 库提供的函数 `std::reverse(begin, end)` 可以将给定容器翻转，其中 `begin` 表示容器头指针，`end` 表示尾指针，左闭右开。`string` 库提供的 STL `std::string` 通过重载 `+` 和 `+=` 运算符来支持两个字符串的拼接。将 $b$ 接到 $a$ 后面可以使用 `a += b` 实现。

上下的镜面对称相当于直接把上面的第 $i$ 行赋值给下面的第 $2r - i + 1$ 行即可。

注意 `std::string` 在存储字符串时下标是从 $0$ 开始的，所以 $y$ 读入后要减一。

### Code

```cpp
#include <string>
#include <iostream>
#include <algorithm>

const int maxn = 105;

int n, m, x, y;
std::string ans[maxn];

int main() {
  std::cin >> n >> m;
  for (int i = 1; i <= n; ++i) {
    std::cin >> ans[i];
    std::string tmp = ans[i];
    std::reverse(tmp.begin(), tmp.end());
    ans[i] += tmp;
  }
  for (int i = n << 1, j = 1; i > n; --i) {
    ans[i] = ans[j++];
  }
  std::cin >> x >> y;
  --y;
  ans[x][y] = (ans[x][y] == '#') ? '.' : '#';
  for (int i = 1, dn = n << 1; i <= dn; ++i) {
    std::cout << ans[i] << std::endl;
  }
  return 0;
}
```

---

## 作者：__Chtholly (赞：6)

## ~~这个真是水题~~

一般人看到这题，第一个思路:模拟！

但是,难道真正的模拟4rm就是好的嘛。。。

所以,这道题,我们要**画图**

首先,这是样例一的图


![](https://i.loli.net/2020/11/03/nOpZ6yorFjPIseL.png)

为啥我多画了12个格子捏？

其实, 这道题可以理解是,以ch[i][j]这个点为轴，90度往右、往下、往左翻转的图

我们先来看纵轴:

我们可以在这里画条分界线，这条线在m列和(m+1)列的中间,然后我们惊奇的发现,原来的图形某个位置到这条分界线的距离 和 翻转后的图形（同样的位置）到这条分界线的距离**相等!**

后来,我们画出这个图

![](https://i.loli.net/2020/11/03/LVgv65D1eRflhoI.png)

显然得出个公式:
### ch[i][2×r-j+1]=ch[i][j]
以此类推
### ch[2×m-i+1][j]=ch[i][j]
### ch[2×m-i+1][2×r-j+1]=ch[i][j]

### 最终,在这个的基础上处理下ch[x][y]就行了！
上代码！
```cpp
#include<cstdio>
#include<cstring>
int r,m;
char ch[1005][1005];
int x,y;
int main()
{
	scanf("%d %d",&r,&m);
	for(register int i=1;i<=r;++i)
		for(register int j=1;j<=m;++j)
		{
			char ch1=getchar();
			while(ch1!='.'&&ch1!='#')
            		{ch1=getchar();}//防止scanf出错,用getchar
			ch[i][j]=ch1;
			ch[i][2*m+1-j]=ch[i][j];
			ch[2*r+1-i][j]=ch[i][j];
			ch[2*r+1-i][2*m+1-j]=ch[i][j];
  //代入公式
		}
	scanf("%d %d",&x,&y);
	ch[x][y]=(ch[x][y]=='.'?'#':'.');//懒人转换
	for(register int i=1;i<=2*r;++i)//注意！一定是2*r和2*m!!
	{
		for(register int j=1;j<=2*m;++j)
		{
			putchar(ch[i][j]);
		}
		putchar('\n');
	}
	return 0;/结束
}
```
## 最终，祝大家
## 2020CSP-J/S RP++!


---

## 作者：Daidly (赞：2)

思路较为简单：

- 上下翻，$a_{i,j}->a_{2*r-i+1,j}$，因为总长度为 $2*r$，减去 $i$ 再加一。

- 左右翻，$a_{i,j}->a_{i,2*c-j+1}$，因为总长度为 $2*r$，减去 $j$ 再加一。

- 先上下，再左右 $<=>$ 先把左上角翻到右下角，再把左边翻到右边。

- 判断错误即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T>inline bool read(T &x){x=0;register char c=getchar();register bool f=0;
while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();if(f)x=-x;return true;}
template<class T>inline void print(T x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10^48);}
template<class T>inline void print(T x,char c){print(x),putchar(c);}
template<class T>inline bool readc(T &x){register char c=getchar();
while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
if(c==EOF)return false;x=c;return true;}
template<class T>inline void printc(T x){putchar(x);}
template<class T>inline void printc(T x,T c){printc(x),putchar(c);}
//快读不用管
int r,c,x,y;
char a[105][105];//两倍的r,c
int main(){
	read(r),read(c);
	for(int i=1;i<=r;++i){
		for(int j=1;j<=c;++j){
			readc(a[i][j]);
		}
	}
	read(x),read(y);
	for(int i=r+1;i<=2*r;++i){//上下翻 
		for(int j=1;j<=c;++j){
			a[i][j]=a[2*r-i+1][j];
		}
	}
	for(int i=1;i<=2*r;++i){//左右翻 
		for(int j=c+1;j<=2*c;++j){
			a[i][j]=a[i][2*c-j+1];
		}
	}
	if(a[x][y]=='.')a[x][y]='#';
	else a[x][y]='.';
	for(int i=1;i<=2*r;++i){
		for(int j=1;j<=2*c;++j){
			printc(a[i][j]);
		}puts("");
	}
	return 0;
}
```

---

## 作者：Kacho (赞：2)

## 此题难点在于复制，难度不大。

~~本人一开始写的时候彻底弄错了，果然是蒟蒻~~

根据题意 $Al'Dimi Kartimi$ 将会先绘制左上角的图像，由 # 和 $.$ 组成，然后再在这一部分的右侧，正下方，以及右下方进行**镜像复制**。

## 必要的变量

本题我会使用 $ a[r][m] $ 和 $b[2 \times r + 5][2 \times m + 5]$ 来对于需要输入和输出的图形进行储存。
## 关于镜像复制

我们对于复制的第一想法就是平移复制（包括笔者）。

关于平移复制如下：
```text
##.. --> ##..##..
```
没错，这就是平移复制，这里就要说到**读题的重要性了**。因为题目中提到的是：将图形沿着矩形的垂直与水平方向的中垂线绘制右上方以及各个位置的图形。

所以：平移复制（×） ——> **镜像复制（√）**。

那么根据题意，我们以第一个样例为例子来进行分析。

输入的 $ r $ 和 $m$ 2、2，以及输入的图形如下：
```text
#.
.#
```
那么也就是说我们如果进行镜像复制就会得到:
```text
#..#
.##.
.##.
#..#
```
这很显然才是题目要求的正解。

## 关于如何进行复制

我们可以对于右边的部分进行分析，即： $ {  (1,3)  和  (1,2)  } $ 和 $ {   (1,1)  和  (1,4)   } $ 这两组数据来进行分析。

我们可以发现的是同一排的被复制的以及原来位置的 $ y $ 位置的相加之和等于 $ 2 \times m + 1 $。

这样子我们可以得到一个对于右半部分进行复制的式子： $ b[ x ][ y ]=a[ x ][ 2 \times m - y + 1 ]$ 。

得到了上一个式子之后，我们可以~~故技重施~~再找出将上下的复制的式子： $b[ x ][ y ]=b[ 2 \times r + 1 - x ][ y ]$ 。

在得到了这两个式子之后，本题已经清晰明了了。
## 最后一步

所以我们在对于 $ a $ 数组进行复制为 $ b $ 数组后，只要将 $ Al'Dimi Kartimi $ 所故意犯的错误添加上去即可。

思路就是判断输入的 $ x $ 和 $ y $ 位置上的字符是  #  还是 $ . $ 即可。

3.
判断代码如下：
```cpp
if(b[x][y]=='#') b[x][y]='.';
else b[x][y]='#';
```
所以，本题已经 “ $ AC $ ” 了，来看代码吧！
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;

char a[105][105];
char b[105][105];


int main () {
	int l,r;
	int x,y;
	scanf("%d%d",&l,&r);
	for(int i=1;i<=l;i++)
		for(int j=1;j<=r;j++){
			cin>>a[i][j];//一个一个输入更便于判断，如果用scanf可能会搞错下标，所以还是cin大法好。
			b[i][j]=a[i][j];//将b数组变成与a数组相同的形式。
		}
	cin>>x>>y;
	for(int i=1;i<=l;i++)
		for(int j=r+1;j<=2*r;j++){
			b[i][j]=a[i][2*r-j+1];//沿竖直方向进行复制。
		}
	for(int i=l+1;i<=2*l;i++)
		for(int j=1;j<=2*r;j++){
			b[i][j]=b[2*l+1-i][j];//沿着水平方向进行复制。
		}
	if(b[x][y]=='#') b[x][y]='.';
	else b[x][y]='#';//判断且犯小错误。
	
	for(int i=1;i<=2*l;i++){
		for(int j=1;j<=2*r;j++){
			cout<<b[i][j];
		}
		cout<<endl;//输出一行后的换行。
	}
	
	return 0;
}
```

## 后记

关于这一题，其实难度不大，对于字符串不是很熟练的小伙伴可以来试一试哦~~

蒟蒻的第二篇题解，管理大大求过嘿嘿。

---

## 作者：ForeverHYX (赞：2)

## 从零开始的P6368题解
本题解对于用到的知识介绍较为详实，非常适合刚开始接触字符串的萌新，同时可以了解巩固字符串相关知识。
#### 01 字符串的翻转问题
作为本题的知识背景，这一问题值得一提，题面即做出以下变换。
```latex
#..#.->.#..#
```
在一个字符串中，若以1为下标起点，我们不难发现中心对称的两个元素下标之和，总是比字符串个数多一，因此我们得到了以下代码。
```
#include<iostream>
using namespace std;
char w[20];
int length;
int main() {
	cin >> length;
	for (int i = 1; i <= length; i++) cin >> w[i];
	for (int i = 1; i <= length / 2; i++) swap(w[i], w[length - i + 1]);//这就是我们所得到的关系的具体体现
	for (int i = 1; i <= length; i++) cout << w[i];
}
```
$\operatorname{swap}$ 函数在 $C++$ 中可以对目标元素进行交换。但本题并用不到，因此不做详细介绍。
#### 02 本题思路
基于 01 中提到的思路，我们发现在本题的对称变换中，相当于是对多行同时进行了字符串反转。

但是值得注意的是，本题的目的并不是直接地反转得到处理后的字符串，而是要将反转后的字符串连接在原串之后，因此我们并不需要调用 $\operatorname{swap}$ 函数。

同时千万不要忘记了对题目所给出的 $(X,Y)$ 做出反符号处理，具体的措施详见03。
#### 03  代码实现
```cpp
for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j] = a[r - i + 1][j];
		}
	}//对于右边的图形进行轴对称
```
此处及以下以样例一进行示范

```latex
#. ->#..#
.# ->.##.
```

我们构建了一个二维数组来实现对于原矩阵的储存和连接。而为了实现连接而不覆盖原矩阵，应当注意下标是 $ a[i+r][j] $ 而不是 $ a[i][j] $ 否则会导致答案的错误。

而左下方的子矩阵与右矩阵相似，不再赘述。
```cpp
for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j+c] = a[r - i + 1][c-j+1];
		}
	}//对于右下方的图形进行中心对称
```
```
#. ->  #.
.# ->  .#
          #.
          .#
```
如果上图发生错位，应是浏览器缩放问题。

而右下方进行的是中心对称，而不再是轴对称，因此要对下标格外注意。

$ a[i + r][j+c] = a[r - i + 1][c-j+1] $

相当于同时进行了两次轴对称，因此下标是前两次轴对称变换的综合。

然后对于需要改变符号的 $(X,Y) $ 我们只需要在输出时单独处理即可。
####  04 AC代码
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int r, c;
char a[500][500];
int x, y;
int main() {
	cin >> r >> c;
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			cin >> a[i][j];//此处完全可以使用单重循环来进行字符串输入
						  //但是单个字符输入更不易搞混下标，体验友好
		}
	}
	cin >> x >> y;//输入处理以及左上方矩阵初始化
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j] = a[r - i + 1][j];
		}
	}//对于右上方的图形进行轴对称
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i][j+c] = a[i][c-j+1];
		}
	}//对于左下方的图形进行轴对称
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j+c] = a[r - i + 1][c-j+1];
		}
	}//对于右下方的图形进行中心对称
	for (int i = 1; i <= 2 * r; i++) {
		for (int j = 1; j <= 2 * c; j++) {
			if (i == x && j == y && a[i][j] == '#') a[i][j] = '.';
			else if (i == x && j == y && a[i][j] == '.') a[i][j] = '#';//对于题中所给坐标进行特殊处理
			cout << a[i][j];
		}
		
		cout << endl;
	}//对于题目所给出的(X,Y)坐标进行处理并输出
}
```

这样的题目耗时并不多，希望看到题解的各位不要复制代码，这样的AC毫无意义。
#### 05 总结

这是一道字符串的经典例题，同时也可以锻炼对于二维数组下标的使用能力，值得一刷。这也是本蒟蒻的第一篇题解。

本题解从背景知识开始，同时语法使用简单，适合新手阅读，求管理员大大通过。

 _题解001_ 


---

## 作者：SingularPoint (赞：1)

### 题目大意
给出一个$r\times m$的由“#”和“.“组成的矩阵，要求将此矩阵以右边界和下边界为对称轴对称和以右下角为对对称点中心对称后得到的（$2r\times 2m$）新矩阵。并将指定的$(x,y)$位置上的字符进行变换。
### 分析
看完题目：模拟大法好哇！

但是感觉开三个for好麻烦……

我们先对几个点的变换进行分析：
$(1,1)\to(1,4),(4,1),(4,4)$、$(2,2)\to(2,3),(3,2),(3,3)$……

由此我们可以发现：
$(x,y)\to(x,2\times m-y+1),(2\times n-x+1,y),(2\times n-x+1,2\times m-y+1)$。

结论有了，标程还会远吗？
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y;
char a[201][201];
int dx[3]={0,1,1},dy[3]={1,0,1};
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	scanf("%d%d",&x,&y);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=0;k<3;k++){
				int xx=dx[k]?(2*n-i+1):i,yy=dy[k]?(2*m-j+1):j;
				a[xx][yy]=a[i][j];
			}
	if(a[x][y]=='#') a[x][y]='.';
	else a[x][y]='#';
	for(int i=1;i<=n*2;i++){
		for(int j=1;j<=m*2;j++)
			cout<<a[i][j];
		cout<<endl;
	}
	return 0;
 } 
```
完结撒fa~

---

## 作者：Linune_Gump (赞：1)

# P6368 题解
总体来说，这题难度并不大。只要您肯动笔画画，题目自然迎刃而解。

## 思路
总体的思路就是先把图翻好，标记最后做。

题目要求翻四次，但每次的操作都是类似的。

我们不妨以样例为例
```
  1 2 3 4
1 # . . #
2 . # # .
3 . # # .
4 # . . #
```
以左右翻转为例。发现翻转过去的位置和被反转的位置的编号之和为定值。那么这个定值是多少呢？很容易发现是$m\times 2+1$

左右翻转完成之后，类似的，上下也可以完成，只是$j$变成了$i$。

另外需要注意的是，每次翻转完成后，相应的规模都要变大

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100;

int n, m;
char s[N * 2][N * 2];
int a_x, a_y;

int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		scanf("%s", s[i] + 1);
	scanf("%d%d", &a_x, &a_y);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			s[i][2 * m + 1 - j] = s[i][j]; // 见分析，横方向上的翻转
	m *= 2; // 见分析，规模需要扩大
	for(int i = 1; i <= n; i++) // 同理，但是j变成了i,m变成了n
	{
		for(int j = 1; j <= m; j++)
			s[2 * n + 1 - i][j] = s[i][j];
	}
	n *= 2;
	if(s[a_x][a_y] == '.') s[a_x][a_y] = '#';
	else s[a_x][a_y] = '.'; // 改变标记位置
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
			printf("%c", s[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Wei_wei_ (赞：1)

## ~~自我认为~~简单易懂题解
### 1.思路  
思路其实很简单：  
1. 将$a$数组读入；  
2. 将$a$数组的四周镜像化，如图：
```
###    ###    ######
..# -> ..# -> ..##..
.##    .##    .####.
       .##    .####.
       ..#    ..##..
       ###    ######
```
对应代码如下：
```
for(int i=n;i<2*n;i++)//原图下翻
	for(int j=0;j<m;j++)
		a[i][j]=a[2*n-i-1][j];
```
```
for(int i=0;i<n;i++)//原图右翻
	for(int j=m;j<2*m;j++)
		a[i][j]=a[i][2*m-j-1];
```
```
for(int i=n;i<2*n;i++)//右翻图下翻
	for(int j=m;j<2*m;j++)
		a[i][j]=a[2*n-i-1][j];
```
3. 将$a(x,y)$（那个“故意犯的小错误”）制成‘#’或‘.’，如下：
```
if(a[x-1][y-1]=='#')a[x-1][y-1]='.';
else if(a[x-1][y-1]=='.')a[x-1][y-1]='#';
//一定要else，不然它会制回去
```
4. 输出。
### 2.代码
完整代码在这里：
```
#include<iostream>
using namespace std;
char a[100][100];
//也可以定义2个数组，但那样就要再把原图存一遍
int n,m,x,y;
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
			cin>>a[i][j];
	cin>>x>>y;
	for(int i=n;i<2*n;i++)//原图下翻
		for(int j=0;j<m;j++)
			a[i][j]=a[2*n-i-1][j];
			
	for(int i=0;i<n;i++)//原图右翻
		for(int j=m;j<2*m;j++)
			a[i][j]=a[i][2*m-j-1];
			
	for(int i=n;i<2*n;i++)//右翻图下翻
		for(int j=m;j<2*m;j++)
			a[i][j]=a[2*n-i-1][j];

	if(a[x-1][y-1]=='#')a[x-1][y-1]='.';
	else if(a[x-1][y-1]=='.')a[x-1][y-1]='#';
    
	for(int i=0;i<2*n;i++,cout<<endl)
		for(int j=0;j<2*m;j++)
			cout<<a[i][j];
}
```

---

## 作者：张语诚ZYC (赞：1)

## 题目描述：

首先绘制了左上角部分的图案，图案共有 $r$ 行 $m$ 列，由字符 `#` 和字符 `.` 组成。绘制完后，他将该图案沿矩形垂直方向的中垂线镜面对称地绘制了矩形右上角的部分。然后沿矩形水平方向的中垂线镜面对称地绘制了矩形的下半部分。

在绘制过程中，会故意犯一个小错误，他会选择第 $x$ 行第 $y$ 列的字符，若该字符是 `#`，则将其改成 `.`，否则将其改成 `#`。

## 思路：

我们只需要得到输入的信息，然后分别**复制**右上，左上，左下的字符(3个 for 循环，这应当yan)，最后，~~我们不能忘了**犯错**~~。

有了思路，干活，向着AC勇敢前进！

## $\texttt{AC Code}$：

```cpp
#include <bits/stdc++.h>
using namespace std;
int r,c,x,y,p;
char mp[105][105];
int main() {
    scanf("%d%d",&r,&c);	
    for (int i = 1; i <= r; i++) {
        scanf("%s", mp[i] + 1);
    }
    scanf("%d%d",&x,&y);
    p=c;
    for (int i = 1; i <= r; i++) {
        for (int j = c + 1; j <= 2 * c; j++) {
            mp[i][j] = mp[i][p--];
        }
        p=c;
    }
    int q=r;
    for (int i = r + 1; i <= 2 * r; i++) {
        for (int j = 1; j <= 2 * c; j++) {
            mp[i][j] = mp[q][j];
        }
        q-=1;
    }
    for (int i = 1; i <= 2 * r; i++) {
        for (int j = 1; j <= 2 * c; j++) {
            if (i == x && j == y) {
                if (mp[i][j] == '#') {
                    mp[i][j] = '.';
                } else if (mp[i][j] == '.') {
                    mp[i][j] = '#';
                }
            }
            printf("%c", mp[i][j]);
        }
        putchar('\n');
    }
    return 0;
}
```


---

## 作者：tqz_ (赞：0)

### 蒟蒻第一次发题解...

# 题解：
我们按照题目描述中的步骤做即可。

在这之前，我先介绍一个STL -- **reverse**。

它的作用是翻转字符串，一般来说我们这样用：

**reverse(字符串名.begin(),字符串名.end());**



------------


### 1. 读入 & 左右镜面

- 我们以一行一个字符串的形式来读入图案。

- 每读入一行，就在这一行后面加上这一行的翻转形式。
```cpp
    int r,c;
    cin >> r >> c;
    string a[2 * r];
    for(int i = 0;i < r;i++)
    {
        cin >> a[i];
        string b = a[i];
        reverse(b.begin(),b.end());
        a[i] += b;
    }
```


------------
### 2.上下镜面
- 把第 0 行赋给第 r * 2 - 1 行；
- 把第 1 行赋给第 r * 2 - 2 行；
- 把第 2 行赋给第 r * 2 - 3 行；
- 以此类推，即可完成上下镜面。
```cpp
    for(int i = r * 2 - 1;i >= r;i--)
    {
        a[i] = a[(r * 2 - 1) - i];
    }
```


------------
### 3.处理“小错误”
输入 x 和 y ，然后更换对应位置符号。

```cpp
    int x,y;
    cin >> x >> y;
    if(a[x - 1][y - 1] == '#')
        a[x - 1][y - 1] = '.';
    else
        a[x - 1][y - 1] = '#';
    
```



------------
### 4.输出

逐行输出即可。
```cpp
    for(int i = 0;i < r * 2;i++)
    {
        cout << a[i] << endl;
    }
```


------------
### 5.完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;


int main()
{
    int r,c;
    cin >> r >> c;
    string a[2 * r];
    for(int i = 0;i < r;i++)
    {
        cin >> a[i];
        string b = a[i];
        reverse(b.begin(),b.end());
        a[i] += b;
    }
    for(int i = r * 2 - 1;i >= r;i--)
    {
        a[i] = a[(r * 2 - 1) - i];
    }
    int x,y;
    cin >> x >> y;
    if(a[x - 1][y - 1] == '#')
        a[x - 1][y - 1] = '.';
    else
        a[x - 1][y - 1] = '#';
    
    for(int i = 0;i < r * 2;i++)
    {
        cout << a[i] << endl;
    }
    return 0;
}
```


------------

求过~

---

## 作者：WxjzKK (赞：0)

$\text{本人发布题解是希望让广大OIer更好地了解此题做法，千万不能抄袭}$

[$\text{没看过题的到这里来}$](https://www.luogu.com.cn/problem/P6368)

此题是一道经典的字符数组操作题，对于刚学字符数组的OIer们具有一定的挑战性。话不多说，直接解题。

1. $\text{题目解析}$

  输入一个 $r×c$ 的字符矩阵，再输入一对坐标 $(x,y)$，表示更改 $(x,y)$ 的符号。输出的是一个 $2r×2c$ 的矩阵，我们来分析一下这个矩阵，出题人大大给了我们三个样板：
  
![](https://cdn.luogu.com.cn/upload/image_hosting/7p7lah31.png)

第二幅图是样例中有的，我们可以很明显的看出图片2是由输入的矩阵四面旋转过来的，然后改了一个字符。

2. $\text{算法分析}$

  怎样才能使 $r×c$ 的矩阵旋转呢？我们可以先把这个矩阵复制到最终矩阵内：
  
```cpp
for (int i=1;i<=r;++i)
		for (int j=1;j<=c;++j)
			cin>>ch[i][j],map[i][j]=ch[i][j];
```
  接下来的旋转我们就要按行按列分析了
  
  根据样例，我们可以得知：每一行对应着另外一行，每一列对应着另外一列：
  
  看样例：第 $1$ 行对应着第 $2×r$ 行，第 $1$ 列对应着 $2×c$ 列，如此推下去，大家应该知道怎么做了吧
  
  我们要推 $3$ 次，有 $2$ 次已经推完了，只差右下角的了，但是，怎么推呢？
  
  答案是行对行、列对列、点对点。
  
  下面用同样的字符表示对应的行列点。
  
```cpp
--    /*
**    %-
  **    -%
  --    */
```

3. $\text{大家最期待的}Node$

$\text{时间复杂度:}O(4rc)$

```cpp
#include<bits/stdc++.h> //万能头
using namespace std;
char ch[51][51],map[101][101]; //ch表示初始数组，map表示最终数组
int main()
{
	int r,c,x,y; //全部定义好
	cin>>r>>c;
	for (int i=1;i<=r;++i) //行
		for (int j=1;j<=c;++j) //列
			cin>>ch[i][j],map[i][j]=ch[i][j]; //提前赋值
	for (int i=1;i<=r;++i)
		for (int j=c+1;j<=2*c;++j) //第二阶段
			map[i][j]=ch[i][2*c+1-j]; //根据上面推导出来的
	for (int i=r+1;i<=2*r;++i)
		for (int j=1;j<=c;++j) //第三阶段
			map[i][j]=ch[2*r+1-i][j];
	for (int i=r+1;i<=2*r;++i)
		for (int j=c+1;j<=2*c;++j) //第四阶段
			map[i][j]=ch[2*r+1-i][2*c+1-j]; //点点对应
	cin>>x>>y;
	if (map[x][y]=='#') map[x][y]='.'; //改变字符
	else map[x][y]='#';
	for (int i=1;i<=2*r;++i)
	{
		for (int j=1;j<=2*c;++j) cout<<map[i][j];
		cout<<endl;
	}
	return 0; //结束
}
//莫抄袭，丢了AC记录，空悲切
```
$AC\text{愉快，本人提交题解是希望让大家能更好地去理解这道题，希望管理员大大给通过}$

---

## 作者：xrdrsp (赞：0)

第 $008$ 篇题解。

# 1 Analysis

一个简单的模拟题。

对于左右翻转，可以记录正在翻转的列 $p$，初始值为 $c$。每次翻转完一列以后将其还原为 $c$。（还原为 $c$ 是因为先枚举 $p$。）

对于上下翻转，可以记录正在翻转的行 $q$，初始值为 $r$。每次翻转完一行以后将其减 $1$。（减 $1$ 是因为后枚举 $q$。）

# 2 Code

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100;

int r, c;
char a[N][N];
int x, y;

int main() {
    cin >> r >> c;
    for (int i = 1; i <= r; i++) {
        scanf("%s", a[i] + 1);
    }
    cin >> x >> y;
    int p = c;									// 正在翻转的列数。
    for (int i = 1; i <= r; i++) {
        for (int j = c + 1; j <= 2 * c; j++) {
            a[i][j] = a[i][p--];				// 赋值、翻转。
        }
        p = c;									// 还原。
    }
    int q = r;									// 正在翻转的行数。
    for (int i = r + 1; i <= 2 * r; i++) {
        for (int j = 1; j <= 2 * c; j++) {		// 赋值、翻转。
            a[i][j] = a[q][j];					// 减 1
        }
        q--;
    }
    for (int i = 1; i <= 2 * r; i++) {
        for (int j = 1; j <= 2 * c; j++) {
            if (i == x && j == y) {				// 判断、修改。
                if (a[i][j] == '#') {
                    a[i][j] = '.';
                } else if (a[i][j] == '.') {
                    a[i][j] = '#';
                }
            }
            printf("%c", a[i][j]);				// 输出。
        }
        puts("");								// 换行。（puts() 自带换行。）
    }
    return 0;
}
```

---


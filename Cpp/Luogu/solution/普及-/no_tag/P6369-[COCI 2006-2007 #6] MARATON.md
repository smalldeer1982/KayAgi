# [COCI 2006/2007 #6] MARATON

## 题目描述

给定一个 $n\times n$ 的正方形棋盘，几位玩家在上面玩三子棋。

三子棋的规则是每位玩家轮流写下一个字母，同一名玩家的字母相同。当有一名玩家在行、列或者斜线上连续组成了 $3$ 个自己的字母时，即为获胜。

给定棋盘的当前状态，请找出获胜的玩家。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 30$。
#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T3 MARATON***。

## 样例 #1

### 输入

```
3
XOC
XOC
X..```

### 输出

```
X```

## 样例 #2

### 输入

```
4
....
..A.
AAB.
.B.B```

### 输出

```
ongoing```

## 样例 #3

### 输入

```
3
ABB
AAA
BBA```

### 输出

```
A```

# 题解

## 作者：_桀氓_ (赞：12)

 **蒟蒻题解首祭！！！**

**~~咕了三星期了~~**


**先分析下题意：**
一个由各个字母与 ‘.’ 组成的正方形矩阵（边长小于等于30）

求任意行列斜线上有没有3个连续相同的字母。

就这，无了。

**思考下算法**

数据范围很小（只有30），我们为什么不用最无脑的遍历枚举呢？

输入就不用多说了，一个字符型数组，但要注意声明时，冗余要稍多一些，防止访问越界。

```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		cin>>MAP[i][j];
```

遍历判断：
某玩家若胜利则此玩家字母连线必定为以下四情况之一

设遍历到的这个位置坐标为(x,y)

| 类 型 | 坐标1 | 坐标2 | 坐标3 |
| :----------: | :----------: | :----------: | :----------: |
| 行 | (x-1,y) | (x,y) | (x+1,y) |
| 列 | (x,y+1) | (x,y) | (x,y-1) |
| 斜线 | (x-1,y+1) | (x,y) | (x+1,y-1) |
| 斜线 | (x+1,y-1) | (x,y) | (x-1,y+1) |

判断函数：
```cpp
void JUDGE(int x,int y)
{
	if((MAP[x-1][y]==MAP[x][y])&&(MAP[x+1][y]==MAP[x][y]))
		OUT(MAP[x][y]);
	if((MAP[x][y-1]==MAP[x][y])&&(MAP[x][y+1]==MAP[x][y]))
		OUT(MAP[x][y]);
	if((MAP[x-1][y-1]==MAP[x][y])&&(MAP[x+1][y+1]==MAP[x][y]))
		OUT(MAP[x][y]);
	if((MAP[x+1][y-1]==MAP[x][y])&&(MAP[x-1][y+1]==MAP[x][y]))
		OUT(MAP[x][y]);
}
```

这个时候数组冗余就发挥作用了，可以**略去越界判断**只需要**输出时进行一次特判**就可以。

输出函数：
```
void OUT(char c)
{
	if(c!='.'&&c!=0)
	{	
		printf("%c",c);
		sign=false;
	}
}
```

此外，我们还需要一个sign变量(bool)记录**是否有赢家**，以此判断是否输出"ongoing"

```cpp
if(sign)
	printf("ongoing");
```

**完整代码(20ms,660.00KB)：**
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
char MAP[35][35];
bool sign=true;//记录是否有赢家
void JUDGE(int,int),OUT(char);

int main()
{
	memset(MAP,0,sizeof(MAP));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>MAP[i][j];
	for(int i=1;i<=n&&sign;i++)//循环必须判断sign情况 不然可能重复输出
		for(int j=1;j<=n&&sign;j++)
			JUDGE(i,j);
	if(sign)//若遍历后无赢家输出"ongoing"
		printf("ongoing");
	return 0;
}

void JUDGE(int x,int y)
{
	if((MAP[x-1][y]==MAP[x][y])&&(MAP[x+1][y]==MAP[x][y])) 
		OUT(MAP[x][y]);//行
	if((MAP[x][y-1]==MAP[x][y])&&(MAP[x][y+1]==MAP[x][y]))
		OUT(MAP[x][y]);//列
	if((MAP[x-1][y-1]==MAP[x][y])&&(MAP[x+1][y+1]==MAP[x][y]))
		OUT(MAP[x][y]);//斜线
	if((MAP[x+1][y-1]==MAP[x][y])&&(MAP[x-1][y+1]==MAP[x][y]))
		OUT(MAP[x][y]);//斜线
}

void OUT(char c)
{
	if(c!='.')//棋盘中可能有连续3个'.'构成的线
	{	
		printf("%c",c);
		sign=false;//更新sign
	}
}
```

完结撒fa~

---

## 作者：Terraria (赞：4)

因为此题 $0 \leq n \leq 30$，所以直接依照题意模拟即可。

本题大意：求在一个棋盘上是否有除了```.```的其他字符连成一条由三个相同字符线，若有则直接输出该字母，否则输出```ongoing```。

这体的主要难点就在与如何判断是否连成一条线，但是我们想都不用想就知道应该这么做，分为以下4种情况——

- 横着连成一条线。代码：
```cpp
if(mp[i][j-1]==mp[i][j]&&mp[i][j]==mp[i][j+1]&&mp[i][j]!='.'){
	cout<<mp[i][j];
	return 0;
}
```
- 竖着连成一条线。代码：
```cpp
if(mp[i-1][j]==mp[i][j]&&mp[i][j]==mp[i+1][j]&&mp[i][j]!='.'){
	cout<<mp[i][j];
	return 0;
}
```
- 斜着连成一条线。但是由于斜着的线可能是左上到右下和右上到左下两者情况，因此我们还要费费手写下两种情况：

```cpp
//斜着的情况1。如图：
//A..
//.A.
//..A
if(mp[i-1][j-1]==mp[i][j]&&mp[i][j]==mp[i+1][j+1]&&mp[i][j]!='.'){//左上到右下
	cout<<mp[i][j];
	return 0;
}
//斜着的情况2。如图：
//..A
//.A.
//A..
if(mp[i-1][j+1]==mp[i][j]&&mp[i][j]==mp[i+1][j-1]&&mp[i][j]!='.'){//右上到左下
	cout<<mp[i][j];
	return 0;
}
```
有了这四个~~麻烦的~~ $if$ 语句，就可以做出这道题啦~

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char mp[31][31];
int n;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(mp[i][j-1]==mp[i][j]&&mp[i][j]==mp[i][j+1]&&mp[i][j]!='.'){
				cout<<mp[i][j];
				return 0;
			}
			if(mp[i-1][j]==mp[i][j]&&mp[i][j]==mp[i+1][j]&&mp[i][j]!='.'){
				cout<<mp[i][j];
				return 0;
			}
			if(mp[i-1][j-1]==mp[i][j]&&mp[i][j]==mp[i+1][j+1]&&mp[i][j]!='.'){
				cout<<mp[i][j];
				return 0;
			}
			if(mp[i-1][j+1]==mp[i][j]&&mp[i][j]==mp[i+1][j-1]&&mp[i][j]!='.'){
				cout<<mp[i][j];
				return 0;
			}
		}
	}
	cout<<"ongoing"<<endl;//如果有胜者前面直接输出并return 0了，因此这里直接输出即可
	return 0;
}
```

谢谢观看！


---

## 作者：LinkZelda (赞：3)

**1. 题意分析：**

给定一个大小为 $n*n$ 的棋盘，求是否有一种棋子满足三格连成一线（~~感觉是简易版的五子棋~~）

**2. 算法思考：**

对于每一个有棋子的点，向其八个方向寻找是否有三个棋子相同，如果有就输出，然后 $return$ $0$（题目说了**最多有一个**棋子满足条件）。如果全部找完都没有满足条件的棋子就输出 $ongoing$ 。时间复杂度大概是 $\Theta$ $(n^{2})$ ，对于本题 $n\leq30$ 的数据肯定可以 $AC$ 。（~~虽然本题看上去不用算时间复杂度~~）

**3.代码实现：**
```cpp
#include<iostream>
using namespace std;
int walk[8][2]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};//walk数组记录八个方向
int main()
{
	int n;
	char a[50][50];
	cin>>n;
	for(int i=1;i<=n;i++)//输入棋盘
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++)//开始找了
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]!='.')//如果这个点有棋子
			{
				for(int k=0;k<8;k++)//向八个方向找
				{
					if((a[i+walk[k][0]][j+walk[k][1]]==a[i][j])&&(a[i+walk[k][0]+walk[k][0]][j+walk[k][1]+walk[k][1]]==a[i][j]))//如果满足三个棋子连成一线，则输出该棋子
					{
						cout<<a[i][j];
						return 0;//找到答案输出后直接结束，避免时间浪费和答案重复
					}
				}
			}
		}
	}
	cout<<"ongoing";//如果没有人赢，就输出"ongoing"
	return 0;
 } 
```


---

## 作者：_Clown_ (赞：2)

这道题目我们可以模拟

我们枚举每一个点，如果他是字母，那么我们就直接算出他附近点的坐标，看这个点是否可行

如果可行，我们就输出，并结束程序。

题目过于简单，我就不多说了
```cpp
#include<bits/stdc++.h>
using namespace std;
int Side;
char Map[31][31];
int Dir[8][2]={1,0,0,1,-1,0,0,-1,1,-1,-1,1,1,1,-1,-1};
inline bool Check(int x,int y)
{
	register int i;
	for(i=0;i<8;i++)
	{
		if(Map[x+Dir[i][0]][y+Dir[i][1]]==Map[x][y]&&Map[x+Dir[i][0]+Dir[i][0]][y+Dir[i][1]+Dir[i][1]]==Map[x][y])
		{
			return true;
		}
	}
	return false;
}
int main()
{
	register int i,j;
	cin>>Side;
	memset(Map,'.',sizeof(Map));
	for(i=1;i<=Side;i++)
	{
		for(j=1;j<=Side;j++)
		{
			cin>>Map[i][j];
		}
	}
	for(i=1;i<=Side;i++)
	{
		for(j=1;j<=Side;j++)
		{
			if(Map[i][j]>='A'&&Map[i][j]<='Z')
			{
				if(Check(i,j))
				{
					cout<<Map[i][j]<<endl;
					return 0;
				}
			}
		}
	}
	cout<<"ongoing"<<endl;
	return 0;
}
```

---

## 作者：happybob (赞：1)

这题我用的是string

首先横着竖着都好弄!重点在于斜的

于是我想到了个方法，只要找到一个不为"."，就判断是否有斜线三个，20ms，代码：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

string s[35];

int main()
{
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
    }
    //横斜一起，纵单独
    for(register int i = 1; i <= n; i++)
    {
        for(register int j = 0; j <= n - 1; j++)
        {
            if(s[i][j] != '.')
            {
                if(s[i][j] == s[i][j + 1] && s[i][j] == s[i][j + 2])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
                else if(s[i][j] == s[i + 1][j - 1] && s[i][j] == s[i + 2][j - 2])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
                else if(s[i][j] == s[i - 1][j + 1] && s[i][j] == s[i - 2][j + 2])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
                else if(s[i][j] == s[i - 1][j + 1] && s[i][j] == s[i + 1][j - 1])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
                else if(s[i][j] == s[i - 1][j - 1] && s[i][j] == s[i - 2][j - 2])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
               else if(s[i][j] == s[i + 1][j + 1] && s[i][j] == s[i + 2][j + 2])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
                else if(s[i][j] == s[i - 1][j - 1] && s[i][j] == s[i + 1][j + 1])
                {
                    cout << s[i][j] << endl;
                    return 0;
                }
            }

        }
    }
    //纵
    for(register int i = 0; i <= n - 1; i++)
    {
        for(register int j = 1; j <= n; j++)
        {
            if(s[j][i] == s[j + 1][i] && s[j][i] == s[j + 2][i])
            {
                if(s[j][i] != '.')
                {
                    cout << s[j][i] << endl;
                    return 0;
                }
            }
        }
    }
    cout << "ongoing\n";
    return 0;
}
```

那么if为什么这么多呢？

想想看，如果s[i][j]是三斜线的一个点，那情况是很多的哦，一定要全写到，不然会WA的，况且测试点可有10个！


---

## 作者：CLCK (赞：1)

### 一道~~大~~模拟。

数据范围很小，读入之后，每找到一个字母，向周围扩展即可。

扩展方法：if语句（见check函数）

详解：先想想如何构成获胜的局面呢？

1.横向：

1）横向最左点 2）横向最右点 3）横向中点

2.纵向：

1）纵向最上点 2）纵向最下点 3）纵向中点

3.斜向：

类上略

注：部分可以忽略 因为main函数中全盘扫过一遍

```cpp
bool check(int x, int y, char c) {
    if (map[x - 1][y] == c && map[x - 2][y] == c && in(x - 1, y) && in(x - 2, y)) return true; //1.2）
	if (map[x + 1][y] == c && map[x + 2][y] == c && in(x + 1, y) && in(x + 2, y)) return true; //1.1）
	if (map[x][y - 1] == c && map[x][y - 2] == c && in(x, y - 1) && in(x, y - 2)) return true; //2.1）
	if (map[x][y + 1] == c && map[x][y + 2] == c && in(x, y + 1) && in(x, y + 2)) return true;//2.2）
	if (map[x - 1][y - 1] == c && map[x - 2][y - 2] == c && in(x - 1, y - 1) && in(x - 2, y - 2)) return true; //3.
	if (map[x + 1][y + 1] == c && map[x + 2][y + 2] == c && in(x + 1, y + 1) && in(x + 2, y + 2)) return true; //3.
	if (map[x + 1][y - 1] == c && map[x + 2][y - 2] == c && in(x + 1, y - 1) && in(x + 2, y - 2)) return true; //3.
	if (map[x - 1][y + 1] == c && map[x - 2][y + 2] == c && in(x - 1, y + 1) && in(x - 2, y + 2)) return true; //3.
	return false;
}
```

难度不高，其余代码如下，简洁易懂。

```cpp
bool in(int x, int y) {
    return 0 <= x && x < n && 0 <= y && y < n;
}
int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> map[i][j];
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (map[i][j] != '.') {
                if (check(i, j, map[i][j])) {
                    cout << map[i][j] << endl;
                    return 0;
                } else {
                    continue;
                }
            }
        }
    }
    cout << "ongoing" << endl;
    return 0;
}
```

#### 还有，记得判界内（in函数）。

##### 完结撒花。

---

## 作者：Lips (赞：1)

# 楼下做的好麻烦

康到这个问题，第一个想法就是以 $O(n^2)$ 的复杂度去枚举每一个点，对于一个点 $(i,j)$，直接看一下它的八个方向即可，当然要避开 $maze[i][j]='.'$ 的情况。

这时候问题来了，怎么快速的看一下八个方向是否合法？第一个思路便是~~一大坨的~~ $if$ 判断。

但其实有一个码量更小也更好写的做法。对于位置 $(x,y)$ 来说，如果位置 $(x+dx,y+dx)$ 是其相邻的一个位置（八个方向），那么 $dx,dy\in[1,-1]$。

看出来了吗？如果建立一个“位置数组”$fx[9]$ 与 $fy[9]$ 那么就可对于目前的点去暴力循环这个数组。设 $dx$ 为 $fx[k]$，$dy$ 为 $fy[k]$，那么与之相邻的一个点就是 $(x+dx,y+dy)$，而这两个位置与 $(x+2dx,y+2dy)$ 恰好能够成一个直线，也就是我们要求的三个位置，然后判断一下字符是否相同便可。

$Code:$

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int MAXN=35;
int n;
char maze[MAXN][MAXN];
int fx[9]={0,1, -1, 0, 0, -1, 1, 1, -1};     
int fy[9]={0,0, 0, 1, -1, 1, 1, -1, -1};  
bool victory(int x,int y,int dx,int dy)
{
    int xx=x+dx;
    int yy=y+dy;
    int xxx=xx+dx;
    int yyy=yy+dy;
    if(maze[x][y]==maze[xx][yy]&&maze[xx][yy]==maze[xxx][yyy]) return true;
    else return false;
}
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=n;j++)
            cin>>maze[i][j];
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=n;j++)
        {
            if(maze[i][j]=='.') continue;
            for(register int k=1;k<=8;k++)
            {
                if(victory(i,j,fx[k],fy[k]))
                {
                    printf("%c\n",maze[i][j]);
                    return 0;
                }
            }
        }
    puts("ongoing");
    return 0;
}
```

~~我怎么现在还在写这么ruozhi的题解呀~~



---

## 作者：SisconHL (赞：1)

> 范围小，咋搞都不会超时，爽歪歪！

于是我们开始了模拟。

首先创建 $dx$ 和 $dy$ 数组，表示x方向和y方向的偏移量。

![image.png](https://i.loli.net/2020/04/13/FYlIMph5czsETrG.png)

输入没别的，就是要注意Linux下换行有两个字符。

![image.png](https://i.loli.net/2020/04/13/5QmjMiuGokyz8bL.png)

于是开始小模拟了。

下面这句话有点绕，请仔细揣摩。

**字母共线，当且仅当相邻的两个位置上，x偏移量与y偏移量应是一样的。**

掌握了这个思想后，AC[P6316 [COCI2006-2007#3] TROJKE](https://www.luogu.com.cn/problem/P6316)，请。

然后简单地遍历一遍并判断有无越界就好了：

![image.png](https://i.loli.net/2020/04/13/LRj3mSkydJWTIVB.png)

![image.png](https://i.loli.net/2020/04/13/AYQVa2mzL8TIEjo.png)

哦还有，注意判断偏移量是否都为0，如果是就不能算。

至此，几乎所有代码均以图片显示展示出。为方便hack，[这里](https://www.luogu.com.cn/paste/c6ru6orb)还是给出文本代码。

---

## 作者：xrdrsp (赞：0)

第 $007$ 篇题解。

这道题比较水，主要考察数组 ~~，应该标成红题。~~

# 1 Analysis

暴力，读入数组，遍历。遇到不是 `.` 的就往上、下、左、右、左上、左下、右上、右下八个方向判断是否有满足条件（三个字符相同）的。如果有，则输出那个字符并退出；否则，继续寻找。

需要防止数组越界导致 $\colorbox{purple}{RE}$。所以从 $3$ 开始就好了。

# 2 Code

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 40;

int n;
char a[N][N];

int main() {
    cin >> n;
    for (int i = 3; i < n + 3; i++) {		// 从 3 开始，主要防数组越界。
        scanf("%s", a[i] + 3);
    }
    for (int i = 3; i < n + 3; i++) {
        for (int j = 3; j < n + 3; j++) {
            // 判断是否有满足条件的
            // 分别有上、下、左、右、左上、左下、右上、右下八个方向
            if (a[i][j] != '.' && (
            (a[i][j] == a[i][j - 1] && a[i][j - 1] == a[i][j - 2]) ||
            (a[i][j] == a[i][j + 1] && a[i][j + 1] == a[i][j + 2]) ||
            (a[i][j] == a[i - 1][j] && a[i - 1][j] == a[i - 2][j]) ||
            (a[i][j] == a[i + 1][j] && a[i + 1][j] == a[i + 2][j]) ||
            (a[i][j] == a[i + 1][j + 1] && a[i + 1][j - 1] == a[i + 2][j + 2]) ||
            (a[i][j] == a[i - 1][j + 1] && a[i - 1][j + 1] == a[i - 2][j + 2]) ||
            (a[i][j] == a[i - 1][j - 1] && a[i - 1][j - 1] == a[i - 2][j - 2]) ||
            (a[i][j] == a[i + 1][j - 1] && a[i + 1][j - 1] == a[i + 2][j - 2]))) {
                printf("%c", a[i][j]);		// 有满足条件的，就输出
                return 0;					// 退出
            } 
        }
    }
    printf("ongoing");
    return 0;
}
```

---


# [COCI 2007/2008 #4] VECI

## 题目描述

给定一个正整数 $x$，请找到一个最小的数字 $y$，使得数字 $0$ 到 $9$ 在 $y$ 中的出现次数与在 $x$ 中的出现次数分别对应相等，且 $x \lt y$。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \lt 10^6$。

#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #4](https://hsin.hr/coci/archive/2007_2008/contest4_tasks.pdf) *T2   VECI***。

## 样例 #1

### 输入

```
156
```

### 输出

```
165```

## 样例 #2

### 输入

```
330
```

### 输出

```
0```

## 样例 #3

### 输入

```
27711
```

### 输出

```
71127```

# 题解

## 作者：冰糖鸽子 (赞：18)

随便一看前几篇题解,居然都是没有 $next\_permutation$ 函数,或者用了也很难懂得,于是就准备先写一篇试试, $AC$ 了。

先介绍一下 $next\_permutation$ 

随便写的小模版 $:$ $next\_permutation(a,a+i)$

- a $:$ 起始位置.

- a + i $:$ 结束位置.

这个函数就是将数组 $a$ 的起始位置到结束位置的所有 **数字**  (注意,这里的数字是以每个数组元素为单位,也就是说如果 $a$ 里有一个元素是 $11$ ,那 $11$ 会被当做一个整体来排列) 排序成当前排列的下一个全排列。
 
 还有要注意的一点,如果当前排列已经是最后一个全排列了,那它会将数组排列成第一个全排列并返回 $false$. (没错,它是有返回值的,但如果直接写一行那就不用管返回值了)
 
 好,看到现在你应该已经知道怎么写了,最后一个点就是将数输入到数组里,有一种办法是一个一个字符输入并转换,但这样比较麻烦,所以我们采用了先输入一整个字符串再分别转换的方法。
 
 注释代码如下(认真看注释哦):
 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
//next_permutation(a,a + 3)模板，不会打可直接复制
int main()
{
    string a;//定义
    cin >> a;//输入整个字符串
    int al = a.length();//al = A Length的首字母
    int num[al];//存储每位数字
    for(int i = 0;i < al;i++)//循环辅值
    {
        num[i] = a[i] - '0';//不需要记'0'的ASCII码,写'0'就行
    } 
    if(next_permutation(num,num + al))//关键的哦，这个函数是可以将num数组的变成下一个全排列,如果这个排列已经是最后那就返回false,反之亦然
    {
        for(int i = 0;i < al;i++)//循环输出
        {
            cout << num[i];//输出数字,记得不要加空格
        }
        return 0;//直接结束程序,可少打一层else
    }
    cout << '0';//如果是最后一个了(对应题目中的"若这样的数不存在"),那就输出0
    return 0;//结束
}
```

最后附上无注释的$:$

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string a;
    cin >> a;
    int al = a.length();
    int num[al];
    for(int i = 0;i < al;i++)
    {
        num[i] = a[i] - '0';
    } 
    if(next_permutation(num,num + al))
    {
        for(int i = 0;i < al;i++)
        {
            cout << num[i];   
        }
        return 0;
    }
    cout << '0';
    return 0;
}
```

本人码风不压行带空格,写的时候看着清晰

看在我这么努力写题解的份上,给个赞再走呗 $QWQ$

---

## 作者：syf2008 (赞：5)

这道题就是求下一个排列，如果没有就输出0，所以next_permutation()他不香吗？
```
#include <bits/stdc++.h>//万能头
using namespace std;
int main()
{
	string a;
	cin>>a;//输入
	for(int i=0;i<a.size()-1;i++)//循环
	if(a[i]<a[i+1])//核心判断，有没有比他大的数列
	while(next_permutation(a.begin(),a.end()))//next_permutation(),全排列函数,next_permutation()是按照字典序产生排列的，并且是从数组中当前的字典序开始依次增大直至到最大字典序
	{cout<<a;return 0;}//有就输出
	cout<<0<<endl;//没有就照题意输出0
	return 0;//好习惯
}
```
完结撒花！！！

---

## 作者：爱晚亭哦 (赞：3)

**本题可采用贪心**

从后往前顺序，以当前数字位置向后循环。

遇到比自己大的数字说明有解，找到符合数字的最小值并交换。

然后从尾到交换位置从小到大排序保证答案最小。

这样可以找到符合条件的最小值。

因为数据少，如果有hack数据，欢迎指出。

$Code:$
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char a[11],qwq;
int main()
{
	scanf("%s",a+1);
	int n=strlen(a+1),t=1,sum,minn=2147483647;
  //t是判断有解变量，minn是存最小值变量
	for(int i=n-1;i>=1;i--)
	{//从后往前顺序
		for(int j=i+1;j<=n;j++)
		{//以当前数字位置向后循环
			if(a[j]>a[i])
			{//比自己大的数字
				if(a[j]<minn)//判断最小值
				{
					t=0;
					sum=j;//储存位置
					minn=a[j];
				}
			}
		}
		if(!t)//有解
		{
			qwq=a[i];
			a[i]=a[sum];
			a[sum]=qwq;
			sum=i;//交换
			break;
		}
	}
	if(!t)
	{
		sort(a+sum+1,a+n+1);//从小到大排序
		for(int i=1;i<=n;i++)
			printf("%c",a[i]);
	}
	else
		printf("0");
}
```
因为$n<=6$，所以$ n^2$的复杂度完全可以接受

小$Copy$宜心，大$Copy$伤身![](https://cdn.luogu.org/upload/pic/62023.png)

---

## 作者：CCCloud (赞：2)

### 搜索可过  
看到有许多人使用next_permutation函数，本人在这里给出一种不一样的做法——**搜索** 

------------
 #### [题目传送门](https://www.luogu.com.cn/problem/P6387)  
**题意**：给出**一个数**，交换它各位的数码，使得出的数**大于原数且尽可能的小**；  
**数据范围**：**10的6次方**——完全可以使用**搜索**  
**搜索思路**：  
1、找出**每个数字**在此整数中**出现了几次**；  
2、通过**DFS**，将每一位**填入数字**；  
3、判断**是否大于原数**；  
4、如果**第3步成立**，那么我们记录与当前的**最优解作比较**，看看**是否更优**；  
5、回到**第2步**，**直到所有情况枚举完成**；

------------
  
#### 那么我们就可以得到AC代码：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;

int n, m, ans, minn=1e9, a[10];//定义变量
char s[10];//我选择字符串读入
bool f=true;//判断有没有答案

void dfs(int pos)//搜索
{
    if(pos==n+1)//是否大于原数m
        if(ans>m) minn=min(minn, ans),f=false;
        //得到最优解，bool变量设置为有答案
        
    for(int i=0; i<=9; i++)//枚举数码的次数
    {
        if(pos==1&&i==0) continue;//开头不能为0
        if(a[i])
        {
            ans+=i*pow(10, pos-1);//加上当前的值
            a[i]--;//次数--
            dfs(pos+1);//进入下一层
            a[i]++;//次数++
            ans-=i*pow(10, pos-1);//减去当前的值
        }
    }
}

int main(void)
{
    cin>>s;//读入字符串
    n=strlen(s);//判断字符串的位数
    for(int i=0; i<n; i++)
    {
        a[int(s[i]-'0')]++;//数码个数++
        m+=(s[i]-'0')*pow(10, n-i-1);//累加得到原数
    }
    
    dfs(1);//DFS深度优先搜索
    
    if(f==true) printf("0\n");//无答案输出0
    else printf("%d\n", minn);//有答案输出最优解
    return 0;//完美结束！
}
```


---

## 作者：_Clown_ (赞：2)

## 一、目录概览
- #### 一、目录概览
- #### 二、题目大意
- #### 三、本题思路
- #### 四、简单介绍_Permutation
- #### 五、代码剖析
## 二、题目大意
这道题目的意思可以转换为：

用0~9若干个数码，可以组成一些自然数，目标是在这些自然数中找出比X大的最小值。

[原题戳链接哦](https://www.luogu.com.cn/problem/P6387)
## 三、本题思路
这道题目，如果学过STL中的Permutation，就能够轻松解决。如果没学过，可以看第四区。

搜到X以后，输出X的后一个，如果X已经是最后一个了，那么输出0。

建议全排列时使用整形，字符能不能过编译？Emmm没试过。
## 四、简单介绍_Permutation
~~如果您是大佬，那么，请跳过本区。~~

C++算法头文件**Algorithm**中提供了从小到大、从大到小两种全排列函数，核心算法实现类似于sort(快速排序):

next_permutation(v.begin(),v.end());

prev_permutation(v.begin(),v.end());

另外，此函数还具有自动去重的功能。

如果您是耐心地看到了这里，那么您应该已经会做了，但是，为了帮助萌新（即菜鸟，又称蒟蒻），那么可以继续看代码，代码中有详细的注释哦。
## 五、代码解析
防盗水印，请见谅。
```cpp
- #include<bits/stdc++.h>//大力推荐万能头
- using namespace std;//名字空间
- int main()//开始吧
- {
- 	register string X;//输入进来用string
- 	register int Length;//字符串长度
- 	register int i;//循环变量
- 	register bool Flag=false;//是否找到了X
- 	register int Array[11];//转化为整形
- 	cin>>X;//扫描字符串
- 	Length=X.size();//字符串长度
- 	for(i=0;i<Length;i++)
- 	{
- 		Array[i]=X[i]-'0';//化为整形，处理更香
- 	}
- 	do
- 	{
- 		if(Flag)//如果前一个是X
- 		{
- 			for(i=0;i<Length;i++)
- 			{
- 				cout<<Array[i];//输出答案
- 			}
- 			cout<<endl;//莫忘换行
- 			return 0;//结束程序
- 		}
- 		bool Now=true;//看看当前状态和X是否相符
- 		for(i=0;i<Length;i++)
- 		{
- 			if(Array[i]!=X[i]-'0')//如果某一位不同
- 			{
- 				Now=false;//那么不是X
- 				break;//跳出循环
- 			}
- 		}
- 		if(Now)//如果已经找到了X
- 		{
- 			Flag=true;//那么为下一个做好标记
- 		}
- 	}
- 	while(next_permutation(Array,Array+Length));//全排列函数
- 	cout<<0<<endl;//无解
- 	return 0;//完美结束
- }
```

---

## 作者：hensier (赞：1)

本题可用两种方法：

- 暴力
- `dfs`

【方案$1$：暴力算法】

题目中要求数字中每一个数码的个数都相同，所以如果有答案的话，那么就必定与原数字位数相同。

于是我们可以在如下区间内循环：

$$[x,{\lceil log_{10}x \rceil}^{10})$$

$log_{10}n$（可以写成$lg(n)$）其实表示着一个数的位数，证明也很简单：

由于$lg(n)$的定义就是能够满足以$10$为底数的幂，而$lg(n)$就是指数，即$10^{lg(n)}=n$。

那么当$lg(n)$为整数的时候，$n$为$10$的整数幂，而$n$又是正数，所以$n$就是一个首位是$1$，其他位数全是$0$的数。此时位数为$lg(n)+1$。

当$lg(n)$不为整数的时候，有$10^{lg(n)}=n$。假设小于$lg(n)$的最大整数为$m$，则$n$的位数等同于$m$的位数。所以$n$的位数就等于$m+1$。所以$n$的位数为$\lfloor lg(n) \rfloor+1$。

综合两种情况，我们发现位数为$\lceil lg(n) \rceil$。所以循环的上限（不含）就是${lg(x)}^{10}$。

而$cmath$库中正好有$log10$函数。

得到上限之后，我们依次进行循环，每次加$1$，逐个枚举并判断，不提。

代码：

```cpp
#include<cstdio>
#include<cmath>
int x,a[10],b[10];//a,b数组分别表示x的
void f(int n,int check)//计数用
{
    while(n)
    {
        if(check==1)b[n%10]++;
        else if(!check)a[n%10]++;
        n/=10;
    }
}
bool check()//检查两个数组是否完全相同
{
    for(int i=0;i<10;i++)if(a[i]!=b[i])return 0;
    return 1;
}
void memset()//清零
{
    for(int i=0;i<10;i++)b[i]=0;
}
int main()
{
    scanf("%d",&x);//输入
    f(x,0);//后面的0表示将数据存入a中
    for(int i=x+1;i<pow(ceil(log10(x)),10);i++)//区间上面已详细说明
    {
        memset();//清零
        f(i,1);//把i的数位存入b中
        if(check())//检查是否相同
        {
            printf("%d",i);//输出
            return 0;
        }
    }
    putchar('0');//没有答案，输出0
}
```

然而，我们很愉快地超时了——第$1$个点用了$1.2s$。于是我们开始优化——可以手写$pow$，因为$cmath$中的是浮点运算，时间耗费肯定长，因此：

```cpp
int pow10(int x)
{
    int s=1;
    while(x--)s=(s<<3)+(s<<1);//位运算快
    return s;
}
```

改为调用手写函数之后，愉快地$AC$了（原来的$1.2s$降到了$5ms$！）

【方案$2$：`dfs`】

因为题目的本质就是排列，我们可以使用`dfs`。详细的在注释里说明。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
string s;
int a[10],b[10],len,n,minn=1e7;//a保存数位，b保存排列的数，len为数的数位个数，n为数字，minn为最小值
bool flag[10];//由于本题排列不能有重复数位，所以用flag数组标记
void dfs(int k)//k为层数
{
    if(k>len)//超过len就进行操作
    {
        int num=0;
        for(int i=1;i<=len;i++)num=(num<<3)+(num<<1)+a[b[i]];//转化为数
        if(num>n&&num<minn)minn=num;//赋值
        return;//跳出该层dfs
    }
    for(int i=1;i<=len;i++)//循环
    {
        if(!flag[i])//没有被使用的话就继续
        {
            flag[i]=1;//标记使用
            b[k]=i;//赋值
            dfs(k+1);//下层循环
            flag[i]=0;//回溯
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);//关闭同步
    cin>>s;//输入（字符串形式）
    len=s.size();//len赋值
    for(int i=0;i<len;i++)//循环
    {
        a[i+1]=s[i]^'0';//数组保存数位
        n=(n<<3)+(n<<1)+a[i+1];//计算字符串的数字形式
    }
    dfs(1);//开始搜索
    printf("%d",minn==1e7?0:minn);//输出
}
```

---

## 作者：Inlay1158 (赞：0)

这道题竟然没有人用全排列来做，`next_permutation`会很伤心的。这个函数就是将一段区间变成它的下一个排列，如果没有，则返回0。这样，这道题就非常简单了，直接输入一个`string`类型的数即可。
```cpp
#include<cstdio>
#include<string>
#include<algorithm>
using namespace std;
FILE *fin, *fout;
inline int read(string &s) {
	s = ""; char c = 0;
	while (c == 32 || c == 10 || c == 13 || c == 0) c = fgetc(fin); if (c == -1) return 0;
	while (!(c == 32 || c == 10 || c == 13 || c == 0 || c == -1)) s += c, c = fgetc(fin);
	return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
inline int write(string s) {
	int len = s.length();
	for (int i = 0; i < len; ++i)
		fputc(s[i], fout);
	return 1;
}//上面的0.7K代码不要管
string x;
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6387.in", "rb");
	fout = fopen("P6387.out", "wb");
	#endif
	read(x);
	if (next_permutation(x.begin(), x.end())) write(x);//核心部分
	else write(0);
	return 0;
}
```

---

## 作者：Instudy (赞：0)

除出题者及 $ O2 $者外最优解者来写题解（~~好意思吗么我~~）

直接暴力枚举，从$ x $枚举到$ 1e6 $，如果没有就输出$ 0 $ ，否则输出最小解。

那么怎么判断所含数字相同呢？？我们用$ b_i$ 其中$ i∈[0,9]$ 来保存$ x $的数字情况。

  用$ a_i $来保存当前枚举的数的数字情况。记得$ a_i $要清零。于是我们从$ 0 $ 到 $ 9 $扫一遍如果$ a_i !=b_i $就$ break $，枚举下一种情况，否则全部相等就输出。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int x;

int a[15];

int b[15];

int i;

int main()
{
    scanf("%d",&x);
    i = x;
    while(x)
    {
        b[x%10]++;
        x /= 10;
    }
    while(i <= 1e6)
    {
        bool f=1;
        i++;
        int t = i;
        memset(a,0,sizeof(a));
        while(t)
        {
            a[t%10]++;
            t /= 10;
        }
        for(int j = 0;j <= 9;j++)
         if(a[j] != b[j]){f = 0;break;}
         if(f){
             printf("%d",i);
             return 0;
         }
    }
    printf("0\n");
    return 0;
}
```

---


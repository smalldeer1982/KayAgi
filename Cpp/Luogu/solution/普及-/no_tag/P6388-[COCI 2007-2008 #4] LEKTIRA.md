# [COCI 2007/2008 #4] LEKTIRA

## 题目描述

给定一个字符串，请你将其分成三段，并将每一段倒序后按照分段的顺序输出。由于方案有多种，请输出答案字典序最小的那一种。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证输入的字符串长度在 $3\sim 50$ 之间。
#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #4](https://hsin.hr/coci/archive/2007_2008/contest4_tasks.pdf) *T3 LEKTIRA***。

## 样例 #1

### 输入

```
dcbagfekjih```

### 输出

```
abcdefghijk```

## 样例 #2

### 输入

```
mobitel```

### 输出

```
bometil```

## 样例 #3

### 输入

```
anakonda```

### 输出

```
aanadnok```

# 题解

## 作者：Math_rad_round (赞：8)

 _[P6388](https://www.luogu.com.cn/problem/P6388)_
 
 题意简述：
 
 将一个字符串分成三段，把每一段倒过来拼成一个新字符串，求字典序最小的一个新字符串
 
 字符串长度 $3 \leq n \leq 50$
  

------------
这题十分玄学，有两种正解 
 
 为了便于分析，设分成的段数为$k$
 
------------
 
 分段做法 ：
 
 搜索枚举每一次分段的分段位置，找出结果最小的一个
 
 所有分段可能数目大体相当于在$n$个物品里选$k-1$个物品方案数目
 
 大概=$n^{k-1}$，处理结果时$O(n)$，所以综合复杂度$O(n^k)$，
 
------------
 
 DP做法
 
 我们知道，DP就是记忆化搜索，~~也就是改进的爆搜~~
 
 设$f[i][j]$为从$i$开始到结尾，一共用j次分段的最小字典序
 
 我们枚举这一段结尾的字符位置$l$
 
 则$f[i][j]=min(f[i][j],u+f[l+1][j-1])(i \leq l \leq n-1-j)$
 
其中$u$是自$i$到$l$的回文

枚举$i,j,l$为$O(kn^2)$，而处理u为$O(n)$
 
综合复杂度为$O(kn^3)$

------------

现在，来到这道题精髓的地方，将$k=3$带回原式。

DP做法复杂度=$O(3*n^3)$，约$O(n^3)$

看上去很烂的分段是$O(n^3)$

也就是说，看上去烂的算法在这道题里跑的挺快！

经过实际测试，DP做法是一共20ms，而分段算法是19ms！快了1ms！~~所以这题很玄学~~

----------

注意事项：

截取原来的字符串可以使用string的substr函数，这个函数用法是

```cpp
a.substr(开始位置,截取字符数);
```

反转字符串可以用algorithm的reverse函数，这个函数用法是

```cpp
reverse(a.begin(),a.end());
```

----------

现在把两种AC代码全部放上

DP做法：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

string f[100][5];
string a;
string u;
int main(){
	cin>>a;
	int n=a.size();
	int k=3;
	for(int i=n-1;i!=-1;i--){
		u=a.substr(i,n-i);
		reverse(u.begin(),u.end());
		f[i][0]=u; 
		for(int j=1;j<k;j++){ 
			f[i][j]="|";
			for(int l=i;l<=n-1-j;l++){ 
				string u=a.substr(i,l-i+1);
				reverse(u.begin(),u.end());
				f[i][j]=min(f[i][j],u+f[1+l][j-1]);
			}
		}
	}
	cout<<f[0][k-1];
}
```

分段算法：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

string mi,a;
int n,k;
int f[1000];


void ch(){
	string a1,a2;
	a2.clear();
	int p=0;
	for(int i=1;i<=k;i++){
		a1=a.substr(p,f[i]-p);
		reverse(a1.begin(),a1.end());
		a2=a2+a1;
		p=f[i];
	}
	mi=min(mi,a2);
}

int sou(int m,int c){
	if(c==3){
		ch();return 0;
	}
	for(int i=m;i<=n-k+c;i++){
		f[c]=i;
		sou(i+1,c+1);
	}
	return 0;
}

int main(){
	mi="|";
	cin>>a;
	n=a.size();
	k=3;
	f[k]=n;
	sou(1,1);
	cout<<mi;
	return 0;
}
```
------------

感谢大家观赏！

~~希望不要抄袭~~

---

## 作者：Phoenix_chaser (赞：4)

# 这是一道很好的模拟题

由于数据只有3~50我们可以很放心的模拟

复杂度不会很高

主要是考察了对于某些的细节处理

像如何反转以及反转的次数等

具体内容看代码

代码如下

```cpp
#include<iostream>
using namespace std;
string s;
char a[54],b[54],c[54];
int leng,vis;
void turn(int a1,int b1){
	for(int i=a1;i<=b1;i++)
	a[i]=b[b1-i+a1];
	//翻转 
} 
int main(){
	cin>>s;
	leng=s.size();
	for(int i=0;i<=leng-1;i++){
		a[i+1]=s[i];
		b[i+1]=s[i];
		//一个为翻转做准备 
		c[i+1]=s[i];	
		//这个为比较最小字典序做准备}
	} 
	
	for(int i=1;i<=leng;i++){
		for(int j=i+1;j<=leng-1;j++){
				turn(1,i);
				turn(i+1,j);
				turn(j+1,leng);
				//分别枚举三次翻转 
				for(int k=1;k<=leng;k++){
					int a2=a[k];
					int b2=c[k];
					if(a2<b2){
						vis=1;
						break;
					}
					if(a2>b2){
						vis=2;
						break;
					}
				}
				if(vis==1)
				for(int e=1;e<=leng;e++)
					c[e]=a[e];
					//找出最小的字典序 
		}
					
	}
			 
	for(int i=1;i<=leng;i++)
			 cout<<c[i];
			
}
```

## 谢谢您的观看
## THE END

---

## 作者：No_Rest (赞：3)

这是一道水题，但我硬是调了半个小时。

## 题目思路

暴力，枚举分段的地方，注意不能枚举到最后，否则分成两段了~~这是我调了半个多小时的原因之一。~~ 

技巧：我们可以使用 STL 中的 `string` 来大大减少码量。在我们比较字典序时，可以直接用 `min` 函数帮我们比较，注意两个字符串的下标都得从 $0$ 开始 ~~另一个让我调了半个多小时的原因。~~

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s, a, b, ans;//s是输入的字符串，a，b是反转时用，ans是答案
void turn(int x, int y){//反转从x到y的函数
	for(int i = x; i <= y; i++){
		a[i] = b[x + y - i];
	}
	return;
}
int main(){
	cin.tie(0), cout.tie(0);
	cin >> s;//输入
	ans = a = b = s;//可以直接复制
	for(int i = 1; i < s.length(); i++){//要从1开始
		for(int j = i + 1; j < s.length(); j++){//记得小于s.length()
			turn(0, i - 1);//模拟
			turn(i, j - 1);
			turn(j, s.length() - 1);
			ans = min(a, ans);//可以直接比较字典序大小
		}
	}
	cout << ans;//输出
	return 0;//好习惯
}
```

---

## 作者：Marshall001 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6388)

## 题目大意

给定一个字符串，让你把他分成 $3$ 段，将这 $3$ 段反转再拼接，求字典需最小的一个。

## 思路

这是一道很好的模拟题，要分成 $3$ 份，就要划两刀，只需枚举两刀的位置在进行反转拼接即可。 $3 \le N \le 50$，我们可以放心的去枚举。但是一定要注意，第一刀的位置要小于第二刀，而且第二刀要小于字符串长度 $-1$ ，否则就只会分成两段了。

## 代码

```cpp
#include <iostream>
using namespace std;
string s,ans="~~~";//～的ASCII码值为126，比所有字母都大
string fz(int begin,int end){//反转函数
	string x;
	for(int i=end;i>=begin;i--){
		x+=s[i];
	}
	return x;
}
void zh(string s1,string s2,string s3){//拼接函数
	string x=s1+s2+s3;
	ans=min(ans,x);//记录最小字典序的字符串
}
int main(){
	cin>>s;
	int l=s.size();
	for(int i=0;i<l;i++){//枚举第一刀
		for(int j=i+1;j<l-1;j++){//枚举第二刀
			zh(fz(0,i),fz(i+1,j),fz(j+1,l-1));//反转，拼接
		}
	}
	cout<<ans;//输出答案
	return 0;
}
```

## THE END

---

## 作者：skyskyCCC (赞：1)

## 前言。
题意：[题目传送门](https://www.luogu.com.cn/problem/P6388)。

考查内容：字符串的**简单**应用。

好了，接下来，我们切入正题！
## 分析。
首先，极小的数据范围可以使我们的暴力复杂度可过。

然后，我们模拟字符串翻转。

怎么模拟，我们通过第一个样例发现规律。
```
dcbagfekjih
```
在这个样例中，我们要将其分成 $3$ 段，我们如果要使字典序最小，我们可以将 $a$ 放在最前面，再将 $a$ 以前的翻转，再去找剩下的中字典序较小的，重复上面的操作，就可以分成三段：
```
dcba|gfe|kjih
```
怎么翻转呢？我们可以用两个字符串来存储，两个字符串初始化为输入字符串，然后在**每个段**里遍历一遍，将第一个字符串中的替换成第二个字符串里的字符。我们通过手动模拟可以发现替换的规律为 $stra[i]=strb[start+last-number]$ 的简单式子。其中 $start$ 指开始的字符下标，而 $last$ 指结束的字符下标，最后 $number$ 指遍历到的字符的下标，通过这样操作，就可以得到：
```
abcdefghijk
```
就得出了答案。

那么从构造出的所以字符串中找到字典序最小的就行了，怎么比较呢？  
给出以下比较程序：
```
//注意：对于最终代码，不确保其正确性
//定义字符串strc,在最终代码的ans=stra=strb=str中改为ans=stra=strb=strc=str即可
//k循环与最终代码的k循环在同一等级上
for(int k=1;k<len;k++){
    int astr=stra[k];
    int bstr=strc[k];
    if(astr<bstr){
        pd=1;
        break;
    }
    if(astr>bstr){
        pd=2;
        break;
    }
}
if(pd==1){
    strc=stra;
}
```
是不是太麻烦了？我们可以用 $min$ 函数，这个函数不但可以比较数的大小，还可以比较字符串字典序的大小。

代码如下，仅供参考：
```
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
string str,stra,strb,ans;
int main(){
	cin>>str;
	ans=stra=strb=str;//初始化每个字符串
	int len=str.length();//取str的长度，在cstring中
   //字符串string使用上面的函数，对于字符char也可以做，用strlen(str)即可
	for(int i=1;i<len;i++){
		for(int j=i+1;j<len;j++){
        //以下是模拟过程，分成3段依次模拟
			for (int k=0;k<=i-1;k++){
				stra[k]=strb[i-1-k];//化简了，原式是0+i-1-k
			}
			for (int k=i;k<=j-1;k++){
				stra[k]=strb[i+j-1-k];
			}
			for (int k=j;k<=len-1;k++){
				stra[k]=strb[j+len-1-k];
			}
			ans=min(stra,ans);//min可以用来比较两个字符串的字典序大小
		}
	}
	cout<<ans;
	return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：编程客 (赞：1)

## 思路
- 很水的一道题啦~~~但我还是交了两遍~~
- 数据范围很小，暴力就行。
- 我是先预处理了字符串从`i`到`j`这段子串的倒叙，各位也可以每次翻转。
- 然后枚举`i`和`j`表示字符串的分界线，每次更新一下就可以了。
- 时间复杂度$O(n^2)$（n表示字符串的长度）。
## 注意事项
- 他每段至少要一个字符，不能没有。
- 刚开始`ans`要初始化。
## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char s[55];
string a[55][55];									// 初始化 
string ans="~~~";									// 答案初始化为极大值(~的ASCII值为 126
int main()
{
	scanf("%s",s+1);								// 读入 
	int n=strlen(s+1);								// 长度 
	for(int i=1;i<=n;i++)							// 初始化 
	{
		for(int j=i;j<=n;j++)
		{
			if(i==j) a[i][j]=s[i];
			else
			{
				a[i][j]=s[j]+a[i][j-1];
			}
		}
	}
	for(int i=1;i<n-1;i++)							// 枚举答案 
	{
		for(int j=i+1;j<n;j++)
		{
			ans=min(ans,a[1][i]+a[i+1][j]+a[j+1][n]);
		}
	}
	printf("%s",ans.c_str());						//输出 
	return 0;
} 
```
##### 希望此篇题解题解能够帮到你。

---

## 作者：ZXXS (赞：0)

### 思路
两层循环枚举把字符串分成三段的两个点，循环中分三段依次倒叙枚举加入字符串中（总计遍历总字符串一次），最后用 `set` 找出字典序最小的字符串并输出，时间复杂度为 $O(n^3)$。
### 注意
1. 使用 cin 输入字符串时下标从 $0$ 开始，而非 $1$。
1. 枚举把字符串分成要注意先后顺序，三段的两个点要注意先后顺序，第二个点要在第一个前面。
1. 枚举字符串时从 $0$ 到 $size-1$。
1. 给字符串最后加入字符或字符串时，可以使用 ‘+’。
1. `set` 给字符串排序时，默认由小到大，所以输出第一个。
1. `set` 的 `begin()` 返回的是一个地址而非值，应使用 `*begin()`。
### 代码
```cpp
#include<bits/stdc++.h>
#define debug(x) cerr<<#x<<"="<<(x)<<endl;
using namespace std;
inline void write(int x)//快写
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
inline int read()//快读
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
    return x*f;
}
set<string> s;
string in; 
int main()
{
	cin>>in;
	for(int i=1;i<in.size();++i)
	{
		for(int j=i+1;j<in.size();++j)//两层循环把字符串分成三段的两个点
		{
			string g="";
			for(int k=i-1;k>=0;--k)//第一段
				g+=in[k];
			for(int k=j-1;k>=i;--k)//第二段
				g+=in[k];
			for(int k=in.size()-1;k>=j;--k)//第三段
				g+=in[k]
			s.insert(g);
		}
	}
	cout<<*s.begin()<<endl;//输出字典序最小的
    return 0;
}

```


---

## 作者：KK_lang (赞：0)

刚看到这道题，感觉很难，要用 dp 做什么的，抱着试一试的心情，看了一眼 $s$ 的长度。

然后，就惊奇地发现，$n \le 50$！这说明了什么呢？说明可以暴力、最多四重循环啊！

其实三重循环就可以，三段，两个断点，用两重，倒序一共用一重，所以时间复杂度是 $O(n^3)$，$s$ 长度提到 $10^3$ 都也能过。 

## AC Code

具体的分析，看代码注释。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
string s;

int main()
{
    cin >> s;
    n = s.size(); // 存储 s 长度
    s = " " + s; // 方便索引从 1 开始
    string ans = "~"; // 预处理一个字典序最大的，方便以后 min 使用，也就是答案
    for (int l1 = 1; l1 <= n - 2; l1++) // 第一段的最后
        for (int l2 = l1 + 1; l2 <= n - 1; l2++) // 第二段的最后
        {
            int r1 = 1, r2 = l1 + 1, r3 = l2 + 1, l3 = n; // 第一段的开头一定是 1，第三段的结尾一定是 n，其余必须“挨”在一起
            string str = ""; // 这一遍的答案
            for (int i = l1; i >= r1; i--) str += s[i]; // 第一段倒序
            for (int i = l2; i >= r2; i--) str += s[i]; // 第二段倒序
            for (int i = l3; i >= r3; i--) str += s[i]; // 第三段倒序
            if (str < ans) ans = str; // 字典序最小
        }
    cout << ans << endl; // 输出答案
    return 0;
}
```

虽然慢了点，但是浅显易懂、显而易见，初学者必备！

---

## 作者：Orange_Sky_Fish (赞：0)

P6388 [COCI2007-2008#4] LEKTIRA题解
=
思路
-
数据范围中提到，字符串的长度很小，显然可以直接模拟（实际就是暴力枚举）。

首先枚举分段的两个端点，然后将翻转过后的每段字符串拼起来，与之前得到的字典序最小的字符串作比较，若字典序更小，则更新答案。

code
-
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main(){
	char a[101],b[101],ans[101];//ans为答案
	int i,n,j,k,op=0;
	scanf("%s",a+1);
	n=strlen(a+1);//n为字符串长度
	for(i=1;i<=n;i++){
		ans[i]=a[i];//初始化ans
	}
	for(i=2;i<=n-1;i++){//第一个坑点，i从2开始
		for(j=i+1;j<=n;j++){//第二个坑点，j到n结束
			bool flag=false;//初始化
			op=0;
			for(k=i-1;k>=1;k--){
				op++;
				b[op]=a[k];
			}//翻转第一段
			for(k=j-1;k>=i;k--){
				op++;
				b[op]=a[k];
			}//翻转第二段
			for(k=n;k>=j;k--){
				op++;
				b[op]=a[k];
			}//翻转第三段
			for(k=1;k<=n;k++){
				if(b[k]<ans[k]) {
					flag=true;
					break;
				} 
				else if(b[k]>ans[k]) {
					flag=false;
					break;
				}
			}//比较字典序
			if(flag==true) {
				for(k=1;k<=n;k++){
					ans[k]=b[k];
				}
			}//若字典序小，则替换
		}
	}
	for(i=1;i<=n;i++){
		printf("%c",ans[i]);
	}//输出
	return 0;//好习惯
}
```


---

## 作者：_Flame_ (赞：0)

## 思路

看了一眼数据范围，很明显可以直接模拟。

我们可以枚举分段的两个段点，然后对与两个端点间的数据进行反转拼接，不断更新最小值即可。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

string s;
string a,b;
string ans;


void down(int s,int e){	
	for(int i=s,j=e;i<j;i++,j--){
		swap(b[i],b[j]);
	}
}

signed main(){
	cin>>s;
	ans=s;
	b=s;
	a=s;
	for(int i=0;i<s.size();i++){
		for(int j=i+1;j<s.size()-1;j++){
			b=a;
			down(0,i);
			down(i+1,j);
			down(j+1,s.size()-1);
			ans=min(b,ans);
		} 
	}
	cout<<ans;
}

```

---

## 作者：xAlec (赞：0)

题目传送门:[P6388 [COCI2007-2008#4] LEKTIRA](https://www.luogu.com.cn/problem/P6388)

# 本题思路

字符串的长度  $ 3 \leq lengt h \leq 50$ 。

可以直接枚举 $ i,j $。

最后找出字典序最小并输出。

注意每次枚举时要分三段倒序过来。

AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string x, y, z;

void vjudge(int L, int R) { //分段操作
	if (y != "")
		for (int i = L, j = R; i < j; i++, j--)  //倒序转换
			swap(y[i], y[j]);
}

int main() {
	ios_base::sync_with_stdio(false);  //黑科技
	cin.tie(0);  //cin加速
	cout.tie(0);  //cout加速
	cin >> x; //输入
	z = x; //先存储下来
	int n = x.size(); //记录字符串长度
	for (int i = 0; i < n; i++) { //枚举
		for (int j = i + 1; j < n - 1; j++) {
			y = x;
			vjudge(0, i); //第一段枚举
			vjudge(i + 1, j); //第二段枚举
			vjudge(j + 1, n - 1); //第三段枚举
			z = min(z, y); //取字典序最小
		}
	}
	cout << z << endl; //输出
	return 0;
}
```


---

## 作者：VegeBeany (赞：0)

## 题面
给定一个字符串将其分成三段，每段反转求字典序最小。
## 思路
因为 $n\le50$，所以我们直接暴力即可。

那怎么暴力呢？

因为需要求字典最小；  
所以我们需要枚举所有情况；  
而我们只需要枚举两个**断点**（所谓断点就是说每一段起点与终点的的焦点）；   
于是我们只需要每次枚举断点后暴力翻转，再求字典最小，就可以了。  

**温馨提示：**
循环时一定要为后面的每一段留一个点的位置。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,a,tmp;//a为答案 
void Swap(int l,int r){//翻转函数 
	int size=r-l+1;
	for(int i=l;i<l+size/2;i++)swap(tmp[i],tmp[l+(size-(i-l)-1)]);//这里用了swap系统自带函数 
}
int main(){
	cin>>s;
	a=s;
	int n=s.size();
	for(int i=0;i<n-2;i++)//记得给后面的段留位置
	for(int j=i+1;j<n-1;j++){
		tmp=s;//要初始化 
		Swap(0,i);
		Swap(i+1,j);
		Swap(j+1,n-1);
		a=min(tmp,a);//求字典最小 
	}
	cout<<a;
	return 0;
}

```

---

## 作者：Aisaka_Taiga (赞：0)

## 思路

本题的要求是把字符串分为三段再倒过来，然后接在一起，输出一个字典序最小的新的字符串，所以在定义的类型上可以用 string 类型的，因为它可以直接比较，做起来简单一些，然后就是读入字符串，枚举每一段的字符串，我们可以在存字符串的时候就直接倒过来存储，因为 string 类型的用 + 会把前面的字符串和后面的接起来比如: $\texttt{sh}$ + $\texttt{dafs}$ = $\texttt{shdafs}$，所以在枚举每一段的时候直接倒着存起来，然后再枚举组合起来的各种情况，用 min 比较一下找出字典序最小的字符串就可以了。

思路来源是这位大佬：218478。

代码如下 ：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[51];//输入的字符串 
string a[51][51],ans="zzzzzzz";//ans存放答案的字符串，a存放 
int main()
{
	scanf("%s",s+1);//表示从下标1开始输入 
	int n=strlen(s+1);//测出字符串的长度 
	for(int i=1;i<=n;i++)
	  for(int j=i;j<=n;j++)//枚举存放各个长度的字符串 
	  {
		if(i==j)a[i][j]=s[i];//特判出相等的情况直接赋过去 
		else a[i][j]=s[j]+a[i][j-1];//倒序存储 
	  }
	for(int i=1;i<n-1;i++)//从第一个开始往下找 
	  for(int j=i+1;j<n;j++)//从i+1开始往下找 
		ans=min(ans,a[1][i]+a[i+1][j]+a[j+1][n]);//组合出所有情况取最小的字符串 
	cout<<ans<<endl;//输出 
	return 0;//好习惯 
} 
```


---


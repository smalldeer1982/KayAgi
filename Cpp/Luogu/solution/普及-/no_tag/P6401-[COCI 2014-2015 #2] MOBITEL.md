# [COCI 2014/2015 #2] MOBITEL

## 题目描述

蚱蜢 Marko 高兴地在草地上跳来跳去。他不小心，他的手机掉进了水坑。他的手机现在触键弄湿了，键盘的工作方式完全不可预知！所有的数字键都坏了。当我们按下其中一个键时，手机就好像我们按下了另一个键一样。幸运的是，没有两个键按下后的作用是一样的，所以 Marko 仍然可以写出所有的字母。

蚱蜢 Marko 正在做一些实验以找出每个键的动作。现在他想给他的女朋友写封信。因为他只是一只蚱蜢，所以它需要你帮忙。

对于那些不记得手机的按键是如何工作的人，这里有一个简短的描述。

![](https://cdn.luogu.com.cn/upload/image_hosting/wdpj2gk9.png)

这张图片显示了我们可以通过按那个键（在一个没有掉进水坑的工作手机上）得到的带有字母的按键。例如，如果我们想要字母 `a`，我们将按一次键 2，如果我们想要字母 `b`，我们将按两次键 2。如果我们想连续用同一个键写两个字母，我们必须按一次键 `#`。例如，如果要编写字符串 `klor`，我们将按以下顺序按键：`55#555666777`。

## 说明/提示

#### 样例 1 说明

所有键的功能都向右移动一个位置，因此输出与题目中的示例语句中的示例略有不同。

#### 数据规模与约定

令 $|s|$ 为字符串 $s$ 的长度，则对于 $100\%$ 的数据，都有 $1\le |s|\le 100$。

#### 说明

**题目译自 [COCI2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST #2](https://hsin.hr/coci/archive/2014_2015/contest2_tasks.pdf) _T1 MOBITEL_。**

## 样例 #1

### 输入

```
2 3 4 5 6 7 8 9 1
klor```

### 输出

```
44#444555666```

## 样例 #2

### 输入

```
7 8 9 1 2 3 6 5 4
djevojka```

### 输出

```
68662227778#885```

## 样例 #3

### 输入

```
9 8 7 6 5 4 3 2 1
skakavac```

### 输出

```
33335585582228#888 ```

# 题解

## 作者：Egg_eating_master (赞：6)

不难吧，大力模拟即可

就是三个数组可能有点晕

自认为比楼下好理解

下面附上带注释代码~
```
#include<bits/stdc++.h>
using namespace std;
int a[10];//a[i]表示现在想打出数字i要按的键
string s;//表示要按的字符串
int lst;//这玩意作用你待会会知道的
int c[27]=
{0,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};//c[i]表示想按出第i个字母需要按的键
int sum[27]=
{0,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};//sum[i]表示想按出第i个字母需要按键的次数
void init(){//定义初始化函数
	for(int i=1;i<=9;i++){
		int x;cin>>x;
		a[x]=i;//特别注意不是a[i]=x
	}
	cin>>s;
}
int main(){
	init(); 
	for(int i=0;i<s.size();i++){//扫描字符串，处理想打的每一个字母
		int num=s[i]-'a'+1;
		if(lst==c[num])cout<<'#';//如果上一个按的键和这次要按的键是一样的，就根据题意输出一个#
		lst=c[num];//把lst更新
		for(int j=1;j<=sum[num];j++)
		    cout<<a[c[num]];//循环输出即可
	}
	return 0;//Happy ending~
}
```


---

## 作者：追梦之鲸 (赞：4)

本蒟蒻的第$004$篇题解。

[经典回顾P6401](https://www.luogu.com.cn/problem/P6401)

### 大模拟！

其实这题难在不知如何下手

所以怎样模拟十分关键

我们先把需要按神马键的数组和需要按几次给打表出来

然后输出``a[ew[w]]``(下面有解释，还有这个``a[ew[w]]``也是个难点)。

解释都在代码里了，所以这里就不说了。

### code：
```c
已经加了防抄袭，谢~~

#include <byits/ostdcu++.h>
using namespace stdAK;

int ew[30]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
//ew数组表示需要按神马键
int we[30]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
//we数组表示需要按几次
int n,top,a[10],w,x;
//a表示输入的那9个数，具体见题目描述，这里就不说了
//top是防止“#”滴，n,w,x下面我给说有何用
string k;

int maioin(){
    for(int i=1;i<=9;i++)
    {
        scanf("%d",&x);
        //一定要a[x]=i,不要a[i]=x!!!
        a[x]=i;
    }
    
    cin>>k;
    
    n=k.size();
    
	for(int i=0;i<n;i++)
	{
        w=k[i]-'a';
        
        if(a[ew[w]]==top) printf("#");
        //判断“#”
        top=a[ew[w]];
        //然后把最后一个数变成top
        for(int j=1;j<=we[w];j++) printf("%d",a[ew[w]]);
        //输出
	}
    	/*
    	about a[ew[w]]:
        如果手机没坏的话，输出的应该是ew[w]对叭
        
        a[ew[w]]就是坏了以后该点哪个键//语文不好请见谅QAQ
        
        比如原来该按1//ew[w]
       
        坏了以后该就该按a[1]//a[ew[w]]//现在该懂了吧
        */
    return -1;
    撒花✿✿ヽ(°▽°)ノ✿
} 
```

最后管理大大求过&[**来玩啊**](https://www.luogu.com.cn/user/361726)&看完辣么辛苦，点个赞吧QAQ

---

## 作者：Mars_Dingdang (赞：4)

这道题就是一个字符串+模拟的题嘛qaq

## 题目大意

将手机上 $1$ ~ $9$ 这些按键定义为原来的其他按键，然后给出一个字符串，求如何才能打出该字符串。如果两个字母按键相同需要输出 `#`。

## 大体思路
**第一步：构造数组**

首先可以用类似打表的方式构造两个数组 $key, Time$，分别记录原来每个字母所对应的按键号码以及按的次数。其中 $key[i]$ 表示第 $i$ 个字母对应的原按键，$Time[i]$ 表示第 $i$ 个字母对应的按键次数。

代码如下：
```cpp
int key[30]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
int Time[30]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
```
**第二步：输入并记录**

此处需要加入一个数组 $k[10]$，用来记录原来每个按键对应的新按键。然后再输入字符串。

代码如下：
```cpp
	string s;//字符串
	int k[11];//新按键
	for(int i=1;i<=9;i++){
		int tmp;
		cin>>tmp;//新按键对应的原按键
		k[tmp]=i;//记录原来每个按键对应的新按键
	}
	cin>>s;//字符串输入
```
**第三步：处理并输出**
这里需要声明两个临时变量 $tmp,t$，分别记录上一次的按键以及本次的按键。如果相等则输出 `#`。然后重复 $Time$ 次，输出对应的 $k$。

代码如下：
```cpp
	int tmp=0;//记录上一次的按键，初始化为零
	for(int i=0;i<s.length();i++){//遍历字符串		
		int t=k[key[s[i]-'a']];//本次的按键
		if(t==tmp) cout<<"#";//同样则输出#
		for(int j=1;j<=Time[s[i]-'a'];j++){
			cout<<t;
		}//输出按键
		tmp=t;//移动
	}
```
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;	
string s;
int k[11];
int key[30]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
int Time[30]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
int main(){
	for(int i=1;i<=9;i++){
		int tmp;
		cin>>tmp;//新按键对应的原按键
		k[tmp]=i;//记录原来每个按键对应的新按键
	}
	cin>>s;//字符串输入
	int tmp=0;//记录上一次的按键，初始化为零
	for(int i=0;i<s.length();i++){	//遍历字符串	
		int t=k[key[s[i]-'a']];//本次的按键
		if(t==tmp) cout<<"#";//同样则输出#
		for(int j=1;j<=Time[s[i]-'a'];j++){
			cout<<t;
		}//输出按键
		tmp=t;//移动
	}
	return 0;//完美
}
```
~~看得这么认真，不点个赞再走嘛qaq~~

---

## 作者：荷叶下 (赞：1)


### 思路
##### 就是一道模拟
##### 打出每个字母对应的按键和需要按几次两个表
##### 先记录每个按键对应的原按键
##### 再模拟每个字母对应的按键
##### 详解请见代码
### 代码如下
```cpp
#include <bits/stdc++.h>//陋习
using namespace std ;
inline int read_()//快读
{
    int s = 0 , w = 1 ;
    char ch = getchar() ;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-')
            w = -1 ;
    ch = getchar() ;
    }
    while(ch >= '0' && ch <= '9')
    {
        s = s * 10 + ch - '0' ;
        ch = getchar() ;
    }
    return s * w ;
}
inline void print_(int x)//快写
{
    if(x < 0)
    {
        x = -x ;
        putchar('-') ;
    }
    if(x > 9)
        print_(x / 10) ;
    putchar(x % 10 + '0') ;
}
int last ;
string s ;
int a[10] ;
int num[30] = {2 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 5 , 5 , 5 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 9 , 9 , 9 , 9 };
int sum[30] = {1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 };
//num表示每个字母对应的按键
//sum表示打出每个字母需要按几次
int main()
{
    for(int i = 1 ; i <= 9 ; ++i)
    {
        int x = read_() ;
        a[x] = i ; //原按键x对应的新按键为i
    }
    cin >> s ;
    int len = s.size() ;
    for(int i = 0 ; i < len ; ++i)
    {
        int st = num[s[i] - 'a'] ; //st即当前字母对应的按键
        if(st == last) //如果上次按的就是这个按键,根据题意要打出"#"
            putchar('#') ;
        last = st ; //更新last的值
        for(int j = 1 ; j <= sum[s[i] - 'a'] ; ++j) //需要按几次
            print_(a[st]) ;//输出原按键对应的新按键
    }
    return 0 ;
    /*~__~*/ 
}
```
#### [AC](https://www.luogu.com.cn/record/41835932)
#### **共建和谐洛谷,拒绝CV**

---

## 作者：yxy666 (赞：1)

题意：给我们一个由小写字母组成的字符串，按照顺序看一下用诺基亚手机要怎么打出来。

想法：如果将键混起来的话，我们只要将我要按这个键但实际在按另一个键存下来，然后从字符串的第一个开始处理，如果我上一个按的键与我这次要按的键一样，那就输出一个 $"#"$ 。然后判断一下到底是按那个键，按几次。具体过程详见代码。

$code$  :
```
#include<bits/stdc++.h>
using namespace std;
char mp[10][5],s[105];
int a[15],f[105],size[15]={0,0,3,3,3,3,3,4,3,4},tot;
void make_p(){
	mp[2][1]='a';mp[2][2]='b';mp[2][3]='c';
	mp[3][1]='d';mp[3][2]='e';mp[3][3]='f';
	mp[4][1]='g';mp[4][2]='h';mp[4][3]='i';
	mp[5][1]='j';mp[5][2]='k';mp[5][3]='l';
	mp[6][1]='m';mp[6][2]='n';mp[6][3]='o';
	mp[7][1]='p';mp[7][2]='q';mp[7][3]='r';mp[7][4]='s';
	mp[8][1]='t';mp[8][2]='u';mp[8][3]='v';
	mp[9][1]='w';mp[9][2]='x';mp[9][3]='y';mp[9][4]='z';
}//mp[i][j]表示我按第i个键，按j下按出来的字母，此处是人工打表
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读
int main(){
	make_p();//打表
	for(int i=1;i<=9;i++)a[read()]=i;//我们知道，按当前i这个键实际上就得按read()d的键
	scanf("%s",s+1);int len=strlen(s+1);//读入字符串
	for(int i=1;i<=len;i++){//枚举
		for(int j=2;j<=9;j++)
		for(int k=1;k<=size[j];k++)//size[i]表示第i个键最多敲出几个字母
		if(mp[j][k]==s[i]){
			if(f[tot]==j)printf("#");//如果上一次的键与这一次的一样，就需要输出井号
			f[++tot]=j;//存入我这次要按什么键
			int cnt=k;
			while(cnt--)printf("%d",a[j]);//输出k次我要按的键
			break;//找到了就好了，提前结束枚举
		}
	}
	return 0;
}
```


---

## 作者：0606x (赞：1)

###### ~~又来水题解啦~~
## 思路
##### （~~暴力不需要思路~~）
用几个数组储存输入的字符原先的键位、按键需要按的次数，再找到更换后的键位所对应的正确键位后输出；如果和接下来的字母所需键位相同，则输出#。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int jian[9];
char s[101];
short c[26]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
short num[26]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
int main()
{
	for(int i=0;i<9;i++) cin>>jian[i];
	cin>>s;
	for(int i=0;i<strlen(s);i++)
	{
		for(int j=0;j<9;j++)
		{
			if(c[s[i]-97]==jian[j]&&c[s[i]-97]==c[s[i+1]-97])
			{
				for(int l=1;l<=num[s[i]-97];l++) cout<<j+1;
				cout<<"#";
				break;
			}
			if(c[s[i]-97]==jian[j]&&c[s[i]-97]!=c[s[i+1]-97])
			{
				for(int l=1;l<=num[s[i]-97];l++) cout<<j+1;
				break;
			}
		}
	}
	return 0;
}
```
###### ~~审核求通过嘛~~~

---

## 作者：Zirnc (赞：1)

> [ChungZH's Blog](https://chungzh.cn) · [ChungZH's Portfolio](https://chungzh.cc)

这道题其实挺简单的，只不过有点麻烦，要打几个表。剩下的模拟就行了。

解释一下代码：

- `t1` 找到某一个字母对应的数字键。比如，字母 `a` 在 `2` 键上面，所以 t1[0] 就是 `2`。（下标就是 `字母-'a'` 得出的数字）
- `times` 顾名思义，就是按一个字母所需要的字数。比如字母 `c`，需要按 `2` 键三次，所以 `times[2]` 就是 `3`。（下标规则同上）
- `inp` 即输入中的第一行，按下 `t` 键的作用相当于原来的 `inp[t]` 键

还要记得如果有相邻两个字母都需要按同一个键，输出 `#`。

```cpp
#include <iostream>
using namespace std;
const char t1[26] = {2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6,
                     6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9};
const int times[26] = {1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,
                       2, 3, 1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 4};
int inp[10];
int main() {
  int t;
  for (int i = 1; i <= 9; i++) {
    cin >> t;
    inp[t] = i;
  }

  string s;
  cin >> s;

  for (int i = 0; i < s.length(); i++) {
    if (t1[s[i] - 'a'] == t1[s[i - 1] - 'a']) cout << '#';
    for (int j = 0; j < times[s[i] - 'a']; j++) {
      cout << inp[t1[s[i] - 'a']];
    }
  }

  cout << endl;
  return 0;
}
```

---

## 作者：BlueSu (赞：0)

今天的第二篇题解了，也是先解出来然后翻题解，发现思路有些不同。但是如果您对打表和找映射这件事很不耐烦，那么请勿读这篇题解。这是一篇相对比较繁琐的题解，希望能讲明白。

主要思路是STL的map。题意大概是这样（滑稽）：

> 你有一部手机，芯片被外星人偷走了，所以它的键盘是乱的。

> 但是你有现在的每个按键对应原来的每个按键的映射表。

> 你想打一个字符串，你想知道需要按下哪些键。

![image.png](https://i.loli.net/2020/10/02/TIlWNh2uDeUtoLf.png)

请仔细看图，下文将用到此图中的变量。其中pam1后更改成broken，pam2后更改成numchar，pam3后更改成tabtime。

### Variable function 变量功能

- ( map < int , int > ) broken：用于存储 现在按键 对应的 原来按键，使用方式：broken[现在标号] = 原来标号。

- ( map < char , int > ) numchar：用于存储 字符 对应的 原来按键，使用方式：numchar[字母a-z] = 对应原来按键。

- ( map < char , int > ) tabtime：用于存储 字符 对应的 按键的下按次数，使用方式：tabtime[字母a-z] = 下按次数。

- ( int ) tmp：输入时用于存储现在按键标号的临时变量。

- ( int ) lasttab：记录上一次按下的按键标号（现在的按键）。

- ( char ) c：输入时用于存储字符的临时变量。

### Algorithm introduction 算法介绍

- 输入时建立 现在按键标号 和 原来按键标号 的映射表。

- 每输入一个字符，从已经初始化的映射表中获取以下两个值：

	1. 其对应的现在按键标号。（x）
    
    2. 其对应的下按次数。（y）

- 而后，输出y次x，并更新“上次按下的按键”lasttab。

- 这个算法是目前为止此题最优解，无卡常，无优化。

### Warning & Explanation 警告 & 解释

获取字符对应的按键标号，在这里解释一下：
 
我们有一张 现在按键标号 和 原来按键标号 的映射表，一张 原来按键标号 和 字符 的映射表。可以通过后者找到 原按键标号，其次再通过前者找到现按键标号。

### Code

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <climits>
#include <map>
using namespace std;

map < int , int > broken ;
map < char , int > numchar , tabtime ;
int tmp , lasttab = -1 ;
char c ;
inline void init () ; // initialization function

int main () {

    init () ;

    // input
    for ( int i = 1 ; i <= 9 ; i++ ) {
        scanf ( "%d" , &tmp ) ;
        // create "broken" map
        broken[tmp] = i ;
    }

    while ( scanf ( "%c" , &c ) != EOF ) {
        // get two variable
        int x = broken[numchar[c]] ;
        int y = tabtime[c] ;

        // refresh "lasttab"
        if ( x == lasttab ) {
            printf ( "#" ) ;
        }
        // print
        for ( int i = 1 ; i <= y ; i++ ) {
            printf ( "%d" , x ) ;
        }

        lasttab = x ;
        // cout << endl << numchar[c] << " " << tabtime[c] << " " << c << endl ;
    }

    return 0 ;
}

inline void init () {
    // numchar
    numchar['a'] = 2 , numchar['b'] = 2 , numchar['c'] = 2 ;
    numchar['d'] = 3 , numchar['e'] = 3 , numchar['f'] = 3 ;
    numchar['g'] = 4 , numchar['h'] = 4 , numchar['i'] = 4 ;
    numchar['j'] = 5 , numchar['k'] = 5 , numchar['l'] = 5 ;
    numchar['m'] = 6 , numchar['n'] = 6 , numchar['o'] = 6 ;
    numchar['p'] = 7 , numchar['q'] = 7 , numchar['r'] = 7 , numchar['s'] = 7 ;
    numchar['t'] = 8 , numchar['u'] = 8 , numchar['v'] = 8 ;
    numchar['w'] = 9 , numchar['x'] = 9 , numchar['y'] = 9 , numchar['z'] = 9 ;

    // tabtime
    tabtime['a'] = 1 , tabtime['b'] = 2 , tabtime['c'] = 3 ;
    tabtime['d'] = 1 , tabtime['e'] = 2 , tabtime['f'] = 3 ;
    tabtime['g'] = 1 , tabtime['h'] = 2 , tabtime['i'] = 3 ;
    tabtime['j'] = 1 , tabtime['k'] = 2 , tabtime['l'] = 3 ;
    tabtime['m'] = 1 , tabtime['n'] = 2 , tabtime['o'] = 3 ;
    tabtime['p'] = 1 , tabtime['q'] = 2 , tabtime['r'] = 3 , tabtime['s'] = 4 ;
    tabtime['t'] = 1 , tabtime['u'] = 2 , tabtime['v'] = 3 ;
    tabtime['w'] = 1 , tabtime['x'] = 2 , tabtime['y'] = 3 , tabtime['z'] = 4 ;
}
```

### Summary 总结

此题逻辑非常严密，尤其是映射表之间的关系非常复杂，希望读者在看题解的同时能在纸上列一下逻辑关系，这将会对今后解题有着非常重要的作用。

---

## 作者：hensier (赞：0)

首先我们要保存每个字母需要点击数字按钮的次数，即：

```cpp
int times[]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
```

然后保存字母对应应该按哪一个按钮（假如手机是正常的）：

```cpp
int letter[]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
```

现在最棘手的问题就是如何处理键盘错误的问题。我们不妨先按题意输入十个数，然后一一对应原来的按钮和现在需要按的按钮（即用$a$数组保存输入，$b$数组的每一个元素$b_i$保存$i$在$a$数组中的下标）。

例如：（下表中的第$i$个数是$i$按钮原来应该按的按键，换句话说，$a_i$按钮现在应该按$i$）

|$3$|$7$|$8$|$1$|$2$|$4$|$6$|$9$|$5$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |

那么，我们只需要寻找每一个$i(i∈[0,10))$在$a$数组中的下标，并存入$b$数组即可，即：

|$4$|$5$|$1$|$6$|$9$|$7$|$2$|$3$|$8$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |

其实，$b$数组的含义就是：原来应该按$i$号按键的，现在应该按$b_i$号。

当然，还有重复问题，用一个$char$类型的$temp$保存前一个并判断是否相同即可解决。

梳理完之后，我们得到代码：


```cpp
#include<cstdio>
int id,a[10],b[10],letter[]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9},times[]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};//数组定义
char s[101],temp;//s存储字符串
int find(int x)//自定义find函数
{
    for(int j=1;j<9;j++)if(a[j]==x)return j;
    return 9;
}
int main()
{
    for(int i=1;i<10;i++)scanf("%d",&a[i]);//输入
    for(int i=1;i<10;i++)b[i]=find(i);//b数组赋值
    getchar();//吞噬换行符，否则s接收的是换行符
    gets(s);//整行读入
    for(int i=0;s[i];i++)//[0,|s|)循环
    {
        id=letter[s[i]-'a'];//为了让代码不过于复杂而设置的变量
        if(b[id]==temp)putchar('#');//如果与前面的字符相同则输出一个#
        for(int j=0;j<times[s[i]-'a'];j++)putchar(b[id]+'0');//输出对应数字（用putchar(数字+'0')会更快）对应次数
        temp=b[id];//temp重新赋值
    }
}
```

---

## 作者：_Clown_ (赞：0)

这是一道很简单的题目

我们先把奇怪的键盘换成正常的，把数字都换回来

然后，我们预处理每一个字母应打出的数字

最后根据字符串输出即可

简单至极，但是代码量较长，需要耐心一点

---


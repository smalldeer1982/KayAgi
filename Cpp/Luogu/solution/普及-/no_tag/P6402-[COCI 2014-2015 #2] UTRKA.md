# [COCI 2014/2015 #2] UTRKA

## 题目描述

许多本地和国际的休闲跑步者都渴望参加今年的萨格勒布马拉松！这是一场 42125 米长的传统比赛。一个奇怪的统计信息是，今年每个参赛者除了一个以外都设法完成了比赛。

请帮助组织者根据注册参赛者名单和排名表，确定**未完成比赛**的参赛者的身份。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，有 $1\le n\le 10^3$。
- 对于 $100\%$ 的数据，有 $1\le n\le 10^5$。

令 $|s|$ 为参赛者姓名的长度，则对于所有合法的姓名，都有 $1\le |s|\le 20$，且姓名只由**小写字符**组成。

#### 说明

**题目译自 [COCI2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST #2](https://hsin.hr/coci/archive/2014_2015/contest2_tasks.pdf) _T2 UTRKA_。**

## 样例 #1

### 输入

```
3
leo
kiki
eden
eden
kiki
```

### 输出

```
leo```

## 样例 #2

### 输入

```
5
marina
josipa
nikola
vinko
filipa
josipa
filipa
marina
nikola
```

### 输出

```
vinko```

## 样例 #3

### 输入

```
4
mislav
stanko
mislav
ana
stanko
ana
mislav
```

### 输出

```
mislav```

# 题解

## 作者：VincentXu (赞：13)

### 理清思路：

给出n及n个参赛者的名字，然后n-1行给出部分参赛者排名，找出未完成比赛的参赛者。

需要注意的是，**不排除参赛者重名的现象**。

可以用map做，记录每个名字的出现次数（参赛和完成比赛分别记录），最后按照名字扫一遍，名字出现次数不同的就揪出来。

这题数据小可以暴搜。

```cpp
#include<iostream>
#include<cstring>
#include<map>
using namespace std;
map<string,int>a;
map<string,int>b;
string c[100001];
int main()
{
	int n;cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i];
		a[c[i]]++;
	}
	string x;
	for(int i=1;i<n;i++)
	{
		cin>>x;
		b[x]++;
	}
	for(int i=1;i<=n;i++)
	if(a[c[i]]!=b[c[i]])
	{
		cout<<c[i];
		return 0;
	}
	return 0;
}
```
题外话：由于学校考试没能第一时间~~水~~写题解。

---

## 作者：CLCK (赞：6)

本题比较简单，不过题意稍微转化一下：

第一个数组存储参加人，第二个数组存储完成人，因为两个数组**只有一人不同**，故只需要把两数组都按照一定顺序排好，**一一比较**即可，而唯一不同项即为答案。

（注：$C++$ 语言可以直接使用 $string$ 数组存储，数组中存储人名字，而在 $C++$ 语法中，**允许直接进行 $string$ 比较**，即**按字典序**，所以可以直接使用 $string$ 排序）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
string a[100005];
string b[100005];
int main() { //简明易懂
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) { //读入
        cin >> a[i];
    }
    for (int i = 0; i < n - 1; i++) {
        cin >> b[i];
    }
    sort(a, a + n); //排序
    sort(b, b + n - 1);
    for (int i = 0; i < n; i++) {
        if (a[i] != b[i]) { //如果不对应，那么就是所求结果
            cout << a[i] << endl;
            return 0;
        }
    }
}
```

### 完结撒花～

---

## 作者：CSP_Sept (赞：5)

用 map 统计即可。

先用 map 存储，然后再减掉名字即可。

如 **样例 3**：

参加名单如下：

| map 中存储的数据 | 出现的次数 |
| :----------: | :----------: |
| $\tt mislav$ | $2$ |
| $\tt stanko$ | $1$ |
| $\tt ana$ | $1$ |

减去有名次的，名单如下：

| map 中存储的数据 | 出现的次数 |
| :----------: | :----------: |
| $\tt mislav$ | $\large 1$ |
| $\tt stanko$ | $0$ |
| $\tt ana$ | $0$ |

所以 `mislav` 就是答案。

代码：

```cpp
#include <iostream>
#include <map>
#include <string>

using namespace std;
map <string,int> ds;
string s;
int n;
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>s;
        ds[s]++;
    }
    for(int i=1;i<n;i++){
        cin>>s;
        ds[s]--;
    }
    map <string,int>::iterator it;
    for(it=ds.begin();it!=ds.end();it++){//遍历 map
        if((*it).second==1){cout<<(*it).first;return 0;}
    }
    return 0;
}
```

---

## 作者：Terraria (赞：3)

我的初始思路是这样的：

先开一个 $map$，用于 $string$ 到 $int$ 的映射，表示有每个字符串出现的次数；然后输入 $n$ 个字符串，对其对应的 $value+=1$。接下来的 $n-1$ 行依次输入比赛了的人，并将其对应的 $value-=1$，最后再从$1$搜到 $n$，如果哪一个字符串对应的 $value$ 不等于$0$则输出。

但是我随即发现——这个思路并不可靠，连第三个数据样例都过不了。

代码先给出来 ~~（这样你就能先水63分）~~：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> m;
int main(){
    int n;
    string a[100009];
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],m[a[i]]++;
    for(int i=1;i<=n-1;i++){
        string str;
        cin>>str;
        m[str]--;
    }
    for(int i=1;i<=n;i++){
        if(m[a[i]]!=0) cout<<a[i]<<endl;
    }
}
```
后来再看自己的代码，第三个数据点是因为输出了两次同一个人名，因此我就考虑着要不要来一个 $string$ 到 $bool$ 的映射，虽说有点麻烦，但是这个方案是可行的。

改后的代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> m;
map<string,bool> mm;
int main(){
    int n;
    string a[100009];
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],m[a[i]]++;
    for(int i=1;i<=n-1;i++) {
        string str;
        cin>>str;
        m[str]--;
    }
    for(int i=1;i<=n;i++){
        if(m[a[i]]!=0&&mm[a[i]]==false){
            cout<<a[i]<<endl;
            mm[a[i]]=true;
        }
    }
}
```
接下来，我又想着能不能少开一个 $map$？~~于是乎我~~观察到数据的特殊性——每一个名字最多被输出两次，因此又改了代码，如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> m;
int main(){
    int n;
    string a[100009];
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],m[a[i]]++;
    for(int i=1;i<=n-1;i++){
        string str;
        cin>>str;
        m[str]--;
    }
    for(int i=1;i<=n;i++){
        if(m[a[i]]!=0) cout<<a[i]<<endl,m[a[i]]--;
    }
}
```
然后也过啦！（不过还是 $STL$ 好用）

完结撒花！

~~（望管理大大求过~）~~

---

## 作者：Mars_Dingdang (赞：3)

这道题乍一看很简单，事实上还是要考研一番功力的。

## 题目大意：
第一行输入包含整数 $n$，即参赛者人数。

以下 $n$ 行中的每一行都包含注册参赛者的姓名。

其他的 $n-1$ 行包含完成比赛者的姓名，按他们完成比赛的顺序排列。参赛者的名字由英文字母组成。参赛者的名字不一定是唯一的。求未完成比赛的参赛者的姓名。

说白了就是输入 $n$ 个字符串，然后输入 $n-1$ 个字符串，求多出来的一个字符串。
## 大体思路：
这题一开始让我联想到了 [找筷子](https://www.luogu.com.cn/problem/P1469) 这道题。那一题的标准做法是用异或和来求。于是蒟蒻的我天真的使用了异或来算，然后程序完美的报错了。~~（话说STL不能加点功能吗）~~

以下才是正解：

由于 map 太高深，本人太蒟蒻，因此不用 map 来做。如果是一个一个名字去找，时间复杂度是 $O(n^2)$，显然是过不了的。

我们不妨看一下：
| 参赛者 | 完成者 |
| :----------: | :----------: |
| aaa | ccc |
| bbb | bbb |
| ccc | ddd |
| ddd |eee  |
| fff |fff  |
| ggg | zzz |
| zzz | kkk |
| kkk | aaa |
| eee | / |
排序后：
| 参赛者 | 完成者 |
| :----------: | :----------: |
| aaa | aaa |
| bbb | bbb |
| ccc | ccc |
| ddd | ddd |
| eee | eee |
| fff | fff |
| $\color{blue}ggg$ | $\color{blue}kkk$ |
| kkk | zzz |
| zzz | / |
此时不难发现，标蓝的一行第一次出现了不同，而答案正是 ggg 选手。

因此可以按字典序对两部分（即参赛者和完成者）进行排序，再一一对应，顺序查找，若发现对应位置的字符串不同则输出对应位置的参赛者名字。（注意此处输出参赛者而非完成者。）

排序部分还是很简单的，用STL中的快排即可。
```cpp
	sort(player+1,player+n+1);
	sort(finish+1,finish+n);//排序
```
查找部分代码：
```cpp
	for(int i=1;i<=n;i++){
		if(player[i]!=finish[i]){//发现不同
			cout<<player[i];//输出参赛者
            //这里不用特判，因为若答案是参赛者最后一个
            //与之对应的完成者默认为0，仍然不同
			return 0;//结束程序
		}
	}
```
## 完整AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string player[100005];//参赛者名字
string finish[100005];//完成者名字
int main(){
	int n;
	cin>>n;//输入人数
	for(int i=1;i<=n;i++){
		cin>>player[i];
	}//输入n个参赛者
	for(int i=1;i<n;i++){
		cin>>finish[i];
	}//输入n-1个完成者
	sort(player+1,player+n+1);
	sort(finish+1,finish+n);//排序
	for(int i=1;i<=n;i++){//查找
		if(player[i]!=finish[i]){//发现不同（无需特判）
			cout<<player[i];//输出
			return 0;//结束程序
		}
	}
	return 0;
}
```
~~看得这么认真，不点个赞再走嘛qaq~~

---

## 作者：sukimo (赞：3)

对于字符串与数字的映射，map可以说是一个利器。建一个从名字映射到“该名字出现次数”的map，读入注册信息时每个域$++$，读入跑完的信息时每个域$--$，那么很明显，最后一定有一个没有减完的域，即答案。代码如下：

```
#include<bits/stdc++.h>
using namespace std;
map<string,int>mp;string name[100005];
int main(){
	int n;scanf("%d",&n);
	for(int i=1;i<=n;i++){cin>>name[i];mp[name[i]]++;}
	for(int i=1;i<=n-1;i++){string q;cin>>q;mp[q]--;}
	for(int i=1;i<=n;i++)if(mp[name[i]]){cout<<name[i];break;}
	return 0;
}
```


---

## 作者：DreamFox (赞：1)

本题思路：

由于可能出现重名，所以我们可以用两个$map$，一个记录选手名单中名字出现的次数，一个记录完成名单中名字出现的次数，最后再循环一遍，如果选手名单中名字出现的次数大于完成名单中名字出现的次数，那么就输出这位选手的名字。

$AC$ $Code$
```cpp
#include<iostream>
#include<map>
using namespace std;
map<string,int>num,sum;
int n;
string a[100001],b;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],++num[a[i]];
	for(int i=1;i<n;i++)cin>>b,++sum[b];
	for(int i=1;i<=n;i++)if(num[a[i]]>sum[a[i]])return cout<<a[i]<<endl,0;
}
```
[AC记录](https://www.luogu.com.cn/record/32943451)

---

## 作者：鸿飞 (赞：0)

前面两位大佬都在用我不会的map，只好发一个纯模拟题解了。
## PART1：题意
输入n个字符串，在输入（n-1）个字符串。找出上面n个字符串中没有在下面（n-1）个字符串中出现的一个。
## PART2：思路
其实完全不需要统计后再减去。

考虑这样一种思路：用2个string数组存储字符串（称之为a和b）。然后用sort函数对a和b从小到大排序，排序后对2个数组每一位作比较。因为a数组中有一个在b中没有出现，所以当a[i]不等于b[i]时，a[i]就是答案。

举例：

a：leo kiki eden

b：eden kiki

排序后：

a： 	eden kiki leo

b：	eden kiki (空)

明显，答案就是leo

## PART3：代码
```cpp
#include<iostream>
#include<string> 
#include<algorithm> 
using namespace std;
unsigned long long n;
string a[500000],b[500000];//数组要开大一些，否则会RE 
bool cmp(string a,string b)
{
	return a<b;
}
int main(){
	cin >> n ;//输入
	for(unsigned long long i=1;i<=n;i++)
	{
		cin >> a[i] ;//输入
	}
	for(unsigned long long i=1;i<=n-1;i++)
	{
		cin >> b[i] ;//输入
	}
	sort(a+1,a+n+1,cmp);//排序
	sort(b+1,b+n,cmp);
	for(unsigned long long i=1;i<=n-1;i++)
	{
		if(a[i]!=b[i])//比较，当a[i]不等于b[i]时，输出答案并结束程序
		{
			cout <<a[i] ;
			return 0;
		}
	}
	cout << a[n] ;
	return 0;
}

```


---

## 作者：xrdrsp (赞：0)

第 $010$ 篇题解。

# Analysis

本题是 `map` 练习题。

> `std::map` 定义于头文件 `<map>`，是有序键值对容器，它的元素的键是唯一的。用比较函数 `Compare` 排序键。搜索、移除和插入操作拥有对数复杂度。 `map` 通常实现为红黑树。
> 
> ——摘自「[C++ Reference std::map](https://zh.cppreference.com/w/cpp/container/map)」

可以把 `std::map` 看作一个映射，即第一个值（关键字，$\rm{key}$）唯一对应着第二个值（值，$\rm{value}$）。

`std::map` 可以存储任意类型的数据，这解决了数组中不能出现「负下标」、「字符串下标」等问题。所以是一个常用的容器。

有关 `std::map` 的更多信息，可以点开上面的链接看。

对于这个题，用数组存名字和是否完成肯定是不现实的，因为不支持「字符串下标」。所以就要使用 `std::map`。

```cpp
map <string, int> participant;
```

这句话定义了映射，`std::string` 类型的关键字（名字）对应着 `int` 类型的值（名字出现的次数）。

接着，对每个选手进行统计。由于 **参赛者的名字不一定是唯一的** ，需要递加名字出现的次数。

```cpp
participant[name[i]]++;
```

这句话对于输入的名字出现次数作了递加。

然后，输入了完成比赛的选手个数。这时需要把每个完成的选手名字出现的次数递减。

```cpp
participant[task_completed_name]--;
```

递减完了，剩下的那个没有归零的就是没完成的。

# Code

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <string>
#include <map>

using namespace std;

const int N = 1e5 + 10;
const int M = 30;

map <string, int> participant;
string name[N];
int n;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> name[i];
        participant[name[i]]++;
    }
    for (int i = 1; i <= n - 1; i++) {
        string task_completed_name;
        cin >> task_completed_name;
        participant[task_completed_name]--;
    }
    for (int i = 1; i <= n; i++) {
        if (participant[name[i]]) {
            cout << name[i];
            break;
        }
    }
    return 0;
}
```

The end.

---


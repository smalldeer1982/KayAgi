# [COCI 2014/2015 #1] KLOPKA

## 题目描述

在平面直角坐标系上有 $n$ 个点。

现在要用一个正方形将点框起来，使得每一个点都能在正方形的内部或边上。要求这个正方形的边平行于坐标轴。

求出这个正方形的最小面积。

## 说明/提示

#### 样例输入输出 1 解释
一个方案是正方形的右上角在 $(7,7)$，左下角在 $(3,3)$。
#### 数据规模与约定
对于 $100\%$ 的数据，保证 $2\le n\le 20$，$1\le x,y\le 100$。
#### 说明
**本题总分 $80$ 分。**

本题译自 [Croatian Open Competition in Informatics 2014/2015](https://hsin.hr/coci/archive/2014_2015) [Contest #1](https://hsin.hr/coci/archive/2014_2015/contest1_tasks.pdf) T2 KLOPKA。

## 样例 #1

### 输入

```
3
3 4
5 7
4 3```

### 输出

```
16```

## 样例 #2

### 输入

```
4
5 1
1 5
10 5
5 10```

### 输出

```
81```

# 题解

## 作者：VincentXu (赞：10)

**找出横坐标或纵坐标之间相差最大的长度，即是正方形边长。**

分别存储最大和最小的横坐标、纵坐标，分别作差求得平面内最大跨度，将其作为边长平方后输出。

这算是一个生活常识吧。可以画图辅助理解。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	int n,x,y,maxx,minx,maxy,miny;
	scanf("%d%d%d",&n,&x,&y);//预处理一组，方便判断
	maxx=minx=x,maxy=miny=y;
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		maxx=max(maxx,x);
		maxy=max(maxy,y);
		minx=min(minx,x);
		miny=min(miny,y);
	}//“打擂台”的比较和数据更新
	int a=max(maxx-minx,maxy-miny);
	cout<<a*a;
	return 0;
}
```
结束。

---

## 作者：wuyonghuming (赞：2)

## 思路：
求出这个正方形最小多少，那么只要求出最大的$x$减去最小的$x$算出它最多可能有多少行，再算出最大的$y$减去最小的$y$算出最多可能有多少列，因为它是一个正方形，所以算出最多可能的行和最多可能的列以后还要取它们的最大值平方。
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
int main()
{
	long long minx=100,miny=100,maxx=0,maxy=0,n,x,y,s;//注意初始值不要赋值太大（我就是因为这个WA了好几次）
	cin>>n;//输入n
	for(int i=1;i<=n;i++)//循环
	{
		cin>>x>>y;//输入
		minx=min(minx,x);//求最小的x
		miny=min(miny,y);//求最小的y
		maxx=max(maxx,x);//求最大的x
		maxy=max(maxy,y);//求最大的y
	}
	cout<<pow(max(maxx-minx,maxy-miny),2);//这个函数可以算出一个数的几次方
  	return 0;//别忘了
}
```
谢谢观看，希望大家能看懂。

---

## 作者：Suuon_Kanderu (赞：1)

看到大佬们都用了贪心，数论等一切牛的办法，我给大家提供一个：


$ {\colorbox{#52c41A}{\color{#FFF}复杂度过千万，暴力能碾标算}}$

这个题数据很小，枚举，秒切。

首先，我们枚举每个正方形的左上角，复杂度$O(100^2)$

我们枚举每个正方形的边长，复杂度$O(100)$(当然可以有剪枝，不过数据小，不需要)

然后，每次正方形边长扩大时，看看是否包含所有的点。如果是，和 ans 打擂台，取最小值。 复杂度 $O(N)$

总体来说$O(100^3\cdot N = 2 \times10^7)$(才千万级，完全在评测机的掌控之中)

但不知为何，跑得快到47ms。（给评测机点赞）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct point {
	int x,y;
}a[22];
int main() {
	int maxx = -100,maxy = -100,ans = 0x7fffffff;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y)
		,maxx = max(maxx,a[i].x),maxy = max(maxy,a[i].y);//小剪枝
	for(int i = 1; i <= maxx; i++)//枚举正方形左上角
		for(int j = 1; j <= maxy; j++){
			int f = 0;//这个是看正方形有没有覆盖所有的点
			for(int k = 1; k <= 100; k++) {//枚举正方形边长
				f = 0;//别忘清零
				for(int u = 1; u <= n; u++){
					if((a[u].x >= i && a[u].y >= j
					&& a[u].x <= i+k-1 && a[u].y <= j+k-1));
					else {
						f = 1;break;	//如果有一个点没被覆盖
					}
				}
				if(f == 0)ans = min(ans,k);//打擂台取最小值
				
			}
		}
	cout << (ans-1)* (ans-1)<< endl;//然而我们取得是边长+1，所以面积就是这样
    return 0;
}
```


---

## 作者：__凉皮__ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6415)
[博客传送门](https://www.luogu.com.cn/blog/SamandNeber/solution-P6415)

# 思路：

为了让正方形**面积最小**，应在能包住每一个点的情况下让**边长尽量短**。

即求横坐标或纵坐标之间相差**最大**的长度，即是正方形边长。

于是我们就对横坐标和纵坐标分别考虑。

### 不妨将横纵坐标排一遍序:

```cpp
sort(x+1,x+n+1);//STL大法好
sort(y+1,y+n+1);
```

### 然后直接输出：

```cpp
pow(max((x[n]-x[1]),(y[n]-y[1])),2);//pow(x,2)为求x的2次方
```
#### ~~简单粗暴有木有。~~

~~不求代码最优，只求代码最短~~

## 本题目前最短程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,x[21],y[21];
	cin>>n;
	for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
	sort(x+1,x+n+1);
	sort(y+1,y+n+1);
	cout<<pow(max((x[n]-x[1]),(y[n]-y[1])),2);
}
```

### 本蒟蒻第二篇题解，如有错误，请速速反馈。

---

## 作者：Terraria (赞：0)

考虑做法：

首先假设题目要求的不是最小的正方形，而是长方形，那么很明显，我们需要记录横坐标的最大差值作为长，纵坐标的最大差值作为宽，面积即为长乘宽。

考虑正方形。

因为如果将这个长方形向外延申不管多少都不会影响他能够覆盖这些点的事实，因此我们采用贪心，将较短的一边延长至较长的一边的长度，使这个长方形变成正方形。换句话说，我们要以这个长和宽中较长的一边作为正方形的边长。面积即为这条边的平方。

因此，在输入的时候就处理好最大值和最小值就好了。

同时要注意：记录横纵坐标的最小值时要先赋值一个较大值，~~否则你就会像我这样先 WA 一遍~~。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int minx=100,miny=100;
int maxx,maxy;
int x,y;
int main(){
	cin>>n;
	while(n--){
		cin>>x>>y;
		minx=min(minx,x);
		maxx=max(maxx,x);
		
		miny=min(miny,y);
		maxy=max(maxy,y);
	}
	cout<<max(maxx-minx,maxy-miny)*max(maxx-minx,maxy-miny);
}
```


---

## 作者：LiuHao2019 (赞：0)

本蒟蒻发的第二篇题解_(:з」∠)_

这题其实很水，有图为证

样例1：

![](https://cdn.luogu.com.cn/upload/image_hosting/xgwfsg6k.png)

------------


样例2：

![](https://cdn.luogu.com.cn/upload/image_hosting/3ob2en83.png)

其实就是找正方形最下方，最上方，最左方，最右方

即寻找最低点，最高点，最左点，最右点

------------


**但是有一个坑：**

![](https://cdn.luogu.com.cn/upload/image_hosting/w1cjzfaf.png)

要找四边最大值.jpg

但其实不用找四个点，只用四个坐标就够了（最高坐标，最低坐标，最左坐标，最右坐标）

AC代码：

```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
int n;
int x,y;

int minnx = 0x7fffffff,minny = 0x7fffffff;//初始设大一点 
int maxnx,maxny;//主函数外默认为0 

int main(){
	scanf("%d",&n);
	while(n --){//等价于for(int i = 1;i <= n;i ++)
		scanf("%d%d",&x,&y);
		if(minnx > x) minnx = x;
		if(minny > y) minny = y;
		if(maxnx < x) maxnx = x;
		if(maxny < y) maxny = y;	
	}
	printf("%d\n",max((maxnx-minnx),(maxny-minny))*max((maxnx-minnx),(maxny-minny)));
}
```


---

## 作者：SisconHL (赞：0)

好像有点问题的亚子……

应该是边平行于坐标轴的正方形吧……不然这组数据可以hack：

```plain
input：

4
0 1
1 0
2 1
1 2

output:

2
```

很明显这四个点构成了一个正方形。

假设确实是边平行于坐标轴的正方形。

另外的，这里的矩形也均为边平行于坐标轴的。

有：

包含于正方形内的矩形长宽均不严格小于正方形边长。

很显然吧……

于是我们就可以找一个矩形框住它们，然后用长边作为边长。

我们就对横坐标和纵坐标分别考虑。

不妨将横坐标排一遍序。

显然，下底横坐标 $\le x_1\le x_n\le$ 上底横坐标。

打擂台找出最大最小值就完了：

```plain
arr a[n]
max ← minn # minn是一个极小值
for i from 0 to n:
	if a[i] > max:
    		max ← a[i]
return max
```

纵坐标同理。

上代码：

```cpp
#include<cstdio>

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)

char buf[1 << 21], *p1 = buf, *p2 = buf;

const int _max = 1145141919;
const int _min = -_max;

inline int qread()
{
    register char c = getchar();
    register int x = 0, f = 1;
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    return x * f;
}

int main( void )
{
	int t = qread();
	int xmax = _min , xmin = _max;
	int ymax = _min , ymin = _max;
	int bufx , bufy;
	while( t-- )
	{
		bufx = qread();
		bufy = qread();
		if( bufx > xmax )	xmax = bufx;
		if( bufx < xmin )	xmin = bufx;
		if( bufy > ymax )	ymax = bufy;
		if( bufy < ymin )	ymin = bufy;
	}
	int len = _min;
	if( xmax - xmin > len )	len = xmax - xmin;
	if( ymax - ymin > len )	len = ymax - ymin; 
	printf( "%d" , len * len );
	return 0;
}

```

---

## 作者：_lzh_ (赞：0)

## 思路

刚开始时以为是一道很难的题，但发现题目中说了**正方形的边平行于坐标轴**之后，思路就很容易想出来了。

记录所有点的最大的 $x,y$ 坐标和最小的 $x,y$ 坐标，将它们相减后，最大值就是这个正方形的边长。最后再求出面积输出即可。

具体讲解见代码。

## Code

```cpp
#include<bits/stdc++.h>
#define N 1000010
#define int long long
using namespace std;
int n,x,y,min_x/*记录x的最小值*/,min_y/*记录y的最小值*/;
//全局变量初始为0，所以记录最大值的变量不需要初始化 
int max_x/*记录x的最大值*/,max_y/*记录y的最大值*/,a/*记录正方形的边长*/;
signed main()
{
	cin>>n;
	min_x=min_y=0x7fffffff;//将记录最小值的变量初始化为int型变量的最大值 
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;//读入坐标 
		min_x=min(min_x,x);//记录x的最小值
		max_x=max(max_x,x);//记录x的最大值
		min_y=min(min_y,y);//记录y的最小值
		max_y=max(max_y,y);//记录y的最大值
	}
	a=max(max_x-min_x,max_y-min_y);//计算正方形的边长 
	cout<<a*a;//正方形的面积=边长*边长 
    return 0;
}
```

---


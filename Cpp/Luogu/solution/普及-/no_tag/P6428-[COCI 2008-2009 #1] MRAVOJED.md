# [COCI 2008/2009 #1] MRAVOJED

## 题目描述

考古学家最近发现了希腊罗马建筑的遗迹。该遗迹可以建模成为为 $r \times c$ 正方形单元的网格。对于每一个位置，考古学家已经确定是否有建筑存在。

他们详细检查了这些文物后得出结论，该地点包含两座不同时期的建筑，两座建筑的平面图都是正方形的。

由于这些建筑在时间上来自不同的时期，它们的楼层平面可能重叠。

为每栋建筑确定可能的位置和大小（平面图所占广场的边长）。

## 说明/提示

#### 提示
解决方案可能不唯一。
#### 数据规模与约定
对于 $100\%$ 的数据，保证存在解决方案，有 $1 \leq r \leq 100,1 \leq c \leq 100$。
#### 说明
题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #1](https://hsin.hr/coci/archive/2008_2009/contest1_tasks.pdf) MRAVOJED，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。
#### 鸣谢
感谢 @[y0y68](https://www.luogu.com.cn/user/115668) 提供的 SPJ。

## 样例 #1

### 输入

```
3 3
xx.
xxx
...```

### 输出

```
1 1 2
2 3 1```

## 样例 #2

### 输入

```
4 6
xx....
xx.xxx
...xxx
...xxx```

### 输出

```
1 1 2
2 4 3```

## 样例 #3

### 输入

```
5 5
.....
xxx..
xxxx.
xxxx.
.xxx.```

### 输出

```
2 1 3
3 2 3```

# 题解

## 作者：wuyonghuming (赞：3)

## 思路：
这道题目是个枚举。

一开始要找到第一个建筑的左上角的点，作为输出的前两个数，否则只能用后面的点，但是后面的点形成的正方形**一定不会**包括这个点，所以**必须**把这个点作为前两个数的输出。

找到了这个点之后，我们要计算它的边长，就从这个点的长度进行枚举，如果能长，当然越长越好，可以为把填满建筑格子的概率增大。如果在查找的时候遇到非建筑格子，那么现在就可以输出长度了，接着再弄一个数组记录已经去掉第一个建筑的地图。

接下来的第二个点要从后往前找，然后枚举长度，像找第一个点那样枚举，如果在长度达到最大，依旧没有填满建筑格子，那么这个点就不行了，注意一定要**尽量大**，否则上面会有点没有包括在正方形内，所以要到最大的时候再输出长度，可以节省效率。
## 代码:
```cpp
#include <bits/stdc++.h>//万能的头文件
using namespace std;
char s[111][111],l[111][111];//s是地图，l是去掉第一个建筑的地图
int main()//主函数
{
	int r,c;//是长和宽
	cin>>r>>c;//输入
	for(int i=1;i<=r;i++)//有r行
	{
		for(int j=1;j<=c;j++)//有c列
		{
			cin>>s[i][j];//输入地图
		}
	}
	bool p=false;//先认为没有找到第一个建筑，让它一直循环
	for(int i=1;i<=r;i++)//有r行
	{
		for(int j=1;j<=c;j++)//有c列,枚举每个点
		{
			if(s[i][j]=='x')//如果是建筑的格子
			{
				printf("%d %d ",i,j);//一定是左上角的点，输出
				int k;//这个是用来计算正方形的边长
				for(k=1;i+k-1<=r||j+k-1<=r;k++)//枚举边长，越长越好
				{
					for(int u=i;u<=i+k;u++)//从这个点的x坐标开始，继续k个点
					{
						for(int v=j;v<=j+k;v++)//从这个点的y坐标开始，继续k个点
						{
							if(s[u][v]!='x')//如果找到了非建筑格子的点那么k就是正方形的边长
							{
								printf("%d\n",k);//输出长度
								for(int a=1;a<=r;a++)//循环长度
								{
									for(int b=1;b<=c;b++)//循环宽度
									{
										l[a][b]=s[a][b];//把地图复制到将要去掉第一个建筑的地图
									}
								}
								for(int a=i;a<=i+k-1;a++)//从左上角的x坐标的开始的k个点
								{
									for(int b=j;b<=j+k-1;b++)//从左上角的y坐标的开始的k个点
									{
										l[a][b]='.';//把这些点清除
									}
								}
								p=true;//找到了第一个点
								break;//跳出循环
							}
						}
						if(p==true)//如果找到了第一个点
						{
							break;//跳出循环
						}
					}
					if(p==true)//如果找到了第一个点
					{
						break;//跳出循环
					}
				}
				if(p==true)//如果找到了第一个点
				{
					break;//跳出循环
				}
			}
			if(p==true)//如果找到了第一个点
			{
				break;//跳出循环
			}
		}
		if(p==true)//如果找到了第一个点
		{
			break;//跳出循环
		}
	}
	for(int i=r;i>=1;i--)//从最后一个点开始往前找
	{
		for(int j=c;j>=1;j--)//从最后一个点开始往前找
		{
			if(s[i][j]=='x')//如果找到了有建筑的点，包括建筑一
			{
				int k;//这依旧是正方形的边长
				for(k=1;k<=i&&k<=j;k++)//枚举k的边长
				{
					for(int u=i-k;u<=i;u++)//从i-k的那个点开始因为那才是左上角的点
					{
						for(int v=j-k;v<=j;v++)//从j-k的那个点开始因为那才是左上角的点
						{
							if(s[u][v]!='x')//如果这个点不是建筑
							{
								char t[111][111];//这个数组是判断方案是否可行的
								p=true;//先是认为可以
								memcpy(t,l,sizeof(t));//把去掉第一个建筑的值赋给用来判断的数组
								for(int a=i-k+1;a<=i;a++)//先判断是否占用了不是建筑的点，从左上角开始
								{
									for(int b=j-k+1;b<=j;b++)//先判断是否占用了不是建筑的点，从左上角开始
									{
										if(s[a][b]=='.')//如果不是建筑
										{
											p=false;//方案不可行
											break;//跳出循环
										}
										t[a][b]='.';//把这个点改成平地方便后面判断
									}
									if(p==false)//如果方案不可行
									{
										break;//跳出循环
									}
								}
								if(p==false)//如果方案不行
								{
									continue;//继续找
								}
								for(int a=1;a<=r;a++)//从第一个点到最后一个点寻找是否有去掉两个建筑后依旧有建筑覆盖的点
								{
									for(int b=1;b<=c;b++)//从第一个点到最后一个点寻找是否有去掉两个建筑后依旧有建筑覆盖的点
									{
										if(t[a][b]=='x')//找到了建筑
										{
											p=false;//方案不可行
											break;//跳出循环
										}
									}
									if(p==false)//如果方案不可行
									{
										break;//跳出循环
									}
								}
								if(p==true)//方案可行
								{
									printf("%d %d %d",i-k+1,j-k+1,k);//输出边长
									return 0;//结束程序
								}
							}
						}	
					}
				}
			}
		}
	}
	return 0;//尽管一定已经在上面的循环中结束了，但还是要写的，养成好习惯
} 
```
## 感谢：
谢谢管理审核！

谢谢大家观赏！


---

## 作者：Yumi_Anaxa_ (赞：2)

[**题面链接**](https://www.luogu.com.cn/problem/P6428)
## 大意
- 找到两个可能重叠的正方形。
## 思路
枚举，但如果想优化的话比较难搞，而且平面只有 $100\times100$，暴力可行。\
首先观察，要找**两个正方形**，每个正方形里面都是`x`；
所以所有`x`至少会被一个正方形覆盖（可以重叠）。

**那么可以得出结论**：
- 任意一个`x`必须属于**至少一个**正方形。
- 两个正方形会覆盖所有`x`。
  
**第一个`x`必须被至少一个正方形覆盖。**
- 首先选择一个`x`。
- 再枚举覆盖这个`x`的正方形的边长和位置。
- 最后检查另一个正方形有没有跟它有重叠。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int r,c,tot=0;
int pd[105][105], p[105][105];
vector<pair<int, int>>pos;
void print(int i1, int j1, int a, int i2, int j2, int s2){
  cout << i1 + 1 << " " << j1+1 << " " << a << "\n";
  cout << i2 + 1 << " " << j2+1 << " " << s2 << "\n";
}
bool solve(int c_i, int c_j, bool f){
  int low = 1;
  int high = min(r, c);
  for (int a = low; a <= high; a++){
    int st = max(0, c_i - a + 1),e1 = min(c_i, r - a);
    for (int i1 = st; i1 <= e1; i1++){
      int st2 = max(0, c_j - a + 1);
      int e2 = min(c_j, c - a);
      for (int j1 = st2; j1 <= e2; j1++){
        int i2 = i1 + a - 1,j2 = j1 + a - 1,cntx = p[i2][j2];
        if (i1 > 0)cntx -= p[i1-1][j2];
        if (j1 > 0)cntx -= p[i2][j1-1];
        if (i1 > 0 && j1 > 0)cntx += p[i1-1][j1-1];
        if (cntx != a*a)continue;
        if (tot - a*a == 0){
          if (f)print(c_i, c_j, 1, i1, j1, a);
          else print(i1, j1, a, c_i, c_j, 1);
          return 1;
        }
        int lowi = r, mxi = -1, lowj = c, mxj = -1,cntt = 0;
        for (int ii = 0; ii < tot; ii++){
          int i = pos[ii].first,j = pos[ii].second;
          if (i >= i1 && i <= i2 && j >= j1 && j <= j2)continue;
          cntt++;
          if (i < lowi)lowi = i;
          if (i > mxi)mxi = i;
          if (j < lowj)lowj = j;
          if (j > mxj)mxj = j;
        }
        if (cntt == 0){
          if(f)print(c_i, c_j, 1, i1, j1, a);
          else print(i1, j1, a, c_i, c_j, 1);
          return 1;
        }
        int h = mxi - lowi + 1,w = mxj - lowj + 1,s2 = max(h, w),st2_ = max(0, lowi - (s2 - h)),e2_ = lowi,js2 = max(0, lowj - (s2 - w)),ej2 = lowj;
        for (int i2c = st2_; i2c <= e2_; i2c++) {
          int i_2 = i2c + s2 - 1;
          if (i_2 >= r)continue;
          for (int j2c = js2; j2c <= ej2; j2c++) {
            int j_2 = j2c + s2 - 1;
            if (j_2 >= c)continue;
            int cntd = pd[i_2][j_2];
            if (i2c > 0)cntd -= pd[i2c -1][j_2];
            if (j2c > 0)cntd -= pd[i_2][j2c -1];
            if (i2c > 0 && j2c > 0)cntd += pd[i2c -1][j2c -1];
            if (cntd > 0)continue;
            if (f)print(i2c, j2c, s2, i1, j1, a);
            else print(i1, j1, a, i2c, j2c, s2);
            return 1;
          }
        }
      }
    }
  }
  return 0;
}
int main(){
  cin >> r >> c;
  vector<string>G(r);
  for (int i = 0; i < r; i++)cin >> G[i];
  int i0 = -1, j0 = -1;
  for (int i = 0; i < r; i++){
    for (int j = 0; j < c; j++){
      if (G[i][j] == 'x'){
        tot++;
        pos.push_back({i, j});
        if (i0 == -1) {
          i0 = i;
          j0 = j;
        }
      }
      p[i][j] = (G[i][j] == 'x' ? 1 : 0);
      if (i > 0)p[i][j] += p[i-1][j];
      if (j > 0)p[i][j] += p[i][j-1];
      if (i > 0 && j > 0)p[i][j] -= p[i-1][j-1];
      pd[i][j] = (G[i][j] == '.' ? 1 : 0);
      if (i > 0)pd[i][j] += pd[i-1][j];
      if (j > 0)pd[i][j] += pd[i][j-1];
      if (i > 0 && j > 0)pd[i][j] -= pd[i-1][j-1];
    }
  }
  if (tot == 0)return 0;
  if (solve(i0, j0, 0))return 0;
  if (solve(i0, j0, 1))return 0;
  return 0;
}
```

---

## 作者：a202401006 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P6428)

# 解析

## 题目大意

给出一个 $r\times c$ 的图，里面存在两个正方形。这两个正方形有可能会有一部分重叠。每个字符 `x` 表示这个点处于正方形内，每个字符 `.` 表示这个点没有任何正方形覆盖。要求求出这两个覆盖的正方形的左上角坐标以及边长。

## 考察知识

~~看了看题解，发现居然暴力能过！心想这么多的循环嵌套，这么高的时间复杂度，居然能过，于是自己手打了个类似的暴力，然后发现就真的过了。~~

上面一堆的废话，本题解使用暴力和循环嵌套。

> 提示：解决方案可能不唯一。

## 思路

我们可以分开处理两个正方形。

对于第一个正方形，我们可以枚举它的左上角点坐标，接着尽可能大的枚举边长，接下来往下搜直到搜到某个点不属于正方形的一部分，即这个点为 `.`，输出，并把图复制到搜索第一个正方形所用的图中，将第一个正方形覆盖的地方标记为 `.`。

对于第二个正方形，我们可以倒着枚举，枚举边长，通过边长枚举左上角坐标。如果这个坐标不被覆盖，那么先标记为可行，然后往下搜；如果被覆盖了则继续去枚举坐标。接下来将搜索第一个正方形的图复制到第二个正方形的图上。接下来判断枚举的正方形是否包含不被正方形覆盖的点，最后将那些搜到的第二个正方形的点标记为 `.`。如果两个正方形枚举完发现居然没有将所有的 `x` 覆盖住，那么说明第二个正方形小了，重来。输出并结束。

# 代码

注意：枚举第一个正方形的时候枚举边长必须这样写。

```cpp
for(k=1;i+k-1<=r||j+k-1<=r;k++)
```

而不能是这样。

```cpp
for(k=1;i+k-1<=r&&j+k-1<=r;k++)
```

原因很简单，因为如果枚举到了一个长方形，第二个代码（错误代码）就不会枚举长方形里面含有的正方形。

还有，为了与题目中的 $c$ 避免循环变量重复，本代码使用了一些常用的循环变量：$i,j,k,u,v,a,b$。

```cpp
/*
	Name: luogu P6428 code
	Copyright: a202401006, GZ LZ M.S.(LZOI)
	Author: a202401006
	Date: 26/06/25 20:12
	Description: description=blank
*/

#include <bits/stdc++.h>
using namespace std;
const int N=105;
int themap[N][N],map1[N][N],map2[N][N];
int r,c,k;
bool find_ruin=0;
void input()
{
	cin>>r>>c;
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
		{
			char ls;
			cin>>ls;
			if(ls=='x')
			{
				themap[i][j]=1;
			}
			else
			{
				themap[i][j]=0;
			}
		}
	}
}

int ok1()
{
	return find_ruin==1?1:0;
}

void copy_firstdot_to_seconddot()
{
	for(int i=1;i<=r+5;i++)
	{
		if(i>105)
		{
			break;
		}
		for(int j=1;j<=c+5;j++)
		{
			if(j>105)
			{
				break;
			}
			map2[i][j]=map1[i][j];
		}
	}
}

void first()
{
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
		{
			if(themap[i][j]==1)
			{
				cout<<i<<" "<<j<<" ";
				for(k=1;i+k-1<=r||j+k-1<=r;k++)
				{
					for(int u=i;u<=i+k;u++)
					{
						for(int v=j;v<=j+k;v++)
						{
							if(themap[u][v]!=1)
							{
								cout<<k<<endl;
								for(int a=1;a<=r;a++)
								{
									for(int b=1;b<=c;b++)
									{
										map1[a][b]=themap[a][b];
									}
								}
								for(int a=i;a<=i+k-1;a++)
								{
									for(int b=j;b<=j+k-1;b++)
									{
										map1[a][b]=0;
									}
								}
								find_ruin=1;
								break;
							}
						}
						if(ok1())
						{
							break;
						}
					}
					if(ok1())
					{
						break;
					}
				}
				if(ok1())
				{
					break;
				}
			}
			if(ok1())
			{
				break;
			}
		}
		if(ok1())
		{
			break;
		}
	}
}

void second()
{
	for(int i=r;i>=1;i--)
	{
		for(int j=c;j>=1;j--)
		{
			if(themap[i][j]==1)
			{
				for(k=1;k<=i&&k<=j;k++)
				{
					for(int u=i-k;u<=i;u++)
					{
						for(int v=j-k;v<=j;v++)
						{
							if(themap[u][v]!=1)
							{
								find_ruin=1;
								copy_firstdot_to_seconddot();
								for(int a=i-k+1;a<=i;a++)
								{
									for(int b=j-k+1;b<=j;b++)
									{
										if(themap[a][b]==0)
										{
											find_ruin=0;
											break;
										}
										map2[a][b]=0;
									}
									if(find_ruin==0)
									{
										break;
									}
								}
								if(find_ruin==0)
								{
									continue;
								}
								for(int a=1;a<=r;a++)
								{
									for(int b=1;b<=c;b++)
									{
										if(map2[a][b]==1)
										{
											find_ruin=0;
											break;
										}
									}
								}
								if(find_ruin==1)
								{
									cout<<i-k+1<<" "<<j-k+1<<" "<<k;
									return ;
								}
							}
						}	
					}
				}
			}
		}
	}
}

int main()
{
	input();
	first();
	second();
}
```

---

## 作者：huhangqi (赞：1)

来一手 $O(nm)$ 的做法。

题目要求两个正方形的位置。

那么我们先按从小到大枚举，枚举到第一个有建筑的位置时将这个作为左上角的点，枚举最长长度即可，通过二维前缀和优化，时间复杂度 $O(nm)$。

然后我们再找第二个，我们需要包含所有剩余点，并且所包含的位置都有建筑。

可以先考虑第二个建筑的边长，由于第一个建筑只能覆盖第二个建筑的最多三条边或者包含，所以我们可以直接根据剩余最长的同一方向的长度来计算第二个的边长，同样是 $O(nm)$ 的。

最后我们再弄一个剩余位置的前缀和来计算是否覆盖所有剩余点，时间复杂度是 $O(nm)$ 的。

最后枚举第二个左上角的点即可，总的时间复杂度为 $O(nm)$。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string.h>
#include<string>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<queue>
using namespace std;
int n,m,pre[205][205],tmpx,tmpy,tmpk,pre2[205][205];
char a[205][205];
void solve(int x,int y,int k){
	for(int i=x;i<=x+k-1;i++){
		for(int j=y;j<=y+k-1;j++)a[i][j]='.';
	}
}
int calc(int x,int y,int xx,int yy){
	return pre[xx][yy]-pre[x-1][yy]-pre[xx][y-1]+pre[x-1][y-1];
}
int calc2(int x,int y,int xx,int yy){
	return pre2[xx][yy]-pre2[x-1][yy]-pre2[xx][y-1]+pre2[x-1][y-1];
}
void solve2(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='x'){
				for(int k=min(n-i+1,m-j+1);k>=1;k--){
					if(calc(i,j,i+k-1,j+k-1)==k*k){
						cout<<i<<' '<<j<<' '<<k<<endl;
						tmpx=i,tmpy=j,tmpk=k;
						solve(i,j,k);
						return;
					}
				}
			}
		}
	}
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)cin>>a[i][j];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='x')pre[i][j]=1;
			pre[i][j]+=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];
		}
	}
	solve2();
	int ma=0,sum=0;
	for(int i=1;i<=n;i++){
		int s=0;
		for(int j=1;j<=m;j++){
			if(a[i][j]=='x')s++,sum++;
			else s=0;
			ma=max(ma,s);
		}
	}
	for(int i=1;i<=m;i++){
		int s=0;
		for(int j=1;j<=n;j++){
			if(a[j][i]=='x')s++;
			else s=0;
			ma=max(ma,s);
		}
	}
	if(!ma){
		cout<<tmpx<<' '<<tmpy<<' '<<1<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='x')pre2[i][j]=1;
			pre2[i][j]+=pre2[i-1][j]+pre2[i][j-1]-pre2[i-1][j-1];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i+ma-1<=n&&j+ma-1<=m&&calc(i,j,i+ma-1,j+ma-1)==ma*ma&&calc2(i,j,i+ma-1,j+ma-1)==sum){
				cout<<i<<' '<<j<<' '<<ma<<endl;
				return 0;
			}
		}
	}
	cout<<tmpx<<' '<<tmpy<<' '<<1<<endl;
	return 0;
}
``````

---


# [COCI 2011/2012 #6] PROZORI

## 题目背景

春天来了，人们渐渐的开始拉下了自己的百叶窗。

## 题目描述

我们把一扇百叶窗用一个 $4 \times 4$ 的方阵表示。其中每一行要么全是字符 `*`，要么全是字符 `.`。百叶窗只会有下面五种状态：

![](https://cdn.luogu.com.cn/upload/image_hosting/m7i17zos.png)

对面的大楼共有 $n$ 层，每层有 $m$ 扇窗户。给定大楼的窗户状态表示，请求出上面五种状态的百叶窗各有几扇。

## 说明/提示

#### 样例 1 解释

- 以第 $2$ 行第 $2$ 列为左上角，第 $5$ 行第 $5$ 列为右下角的是一扇窗户，是第一种状态。
- 以第 $2$ 行第 $7$ 列为左上角，第 $5$ 行第 $10$ 列为右下角的是另一扇窗户，是第三种状态。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, m \leq 100$。

#### 说明

**题目译自 [COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #6](https://hsin.hr/coci/archive/2011_2012/contest6_tasks.pdf) *T2 PROZORI***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。

## 样例 #1

### 输入

```
1 2
###########
#....#****#
#....#****#
#....#....#
#....#....#
###########
```

### 输出

```
1 0 1 0 0```

## 样例 #2

### 输入

```
2 3
################
#****#****#****#
#****#****#****#
#****#....#****#
#....#....#****#
################
#....#****#****#
#....#****#....#
#....#....#....#
#....#....#....#
################
```

### 输出

```
1 1 2 1 1```

# 题解

## 作者：WxjzKK (赞：6)

## 此题用搜索简单水过

思路：用广搜，先遍历整栋楼的的 $map$，如果不是窗户的边框 '#'，则BFS搜索出这是哪一种窗户，再给已经搜过的用 $f_i,_j$ 标记，最后输出即可。

$Code:$

```cpp
#include<bits/stdc++.h> //c++专属万能头
using namespace std;
const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1}; //可以走的4个方向
int num,n,m,a[6]; //a表示第i种窗户的个数，num表示在bfs函数结束后整个窗户的*的个数
char ch[502][502];
bool f[502][502]; //最多可以达到5n+1*5m+1,也就是5*100+1=501，故定义到502
struct node
{
	int x,y;
}; //定义一个结构体
void bfs(int sx,int sy) //bfs函数
{
	queue<node>que; //node类型的队列
	num=0; //num清零
	node temp;
	temp.x=sx;temp.y=sy;
	que.push(temp); //第一个入列
	f[sx][sy]=true; //这一点很容易遗漏，要把第一个点清为不可走
	if (ch[sx][sy]=='*') ++num; //记得判断第一个点是否是*号
	while (!que.empty()) //循环开始
	{
		node a=que.front();
		for (int i=0;i<4;++i) //逐个搜索每个方向
		{
			int nx=a.x+dx[i],ny=a.y+dy[i];
			if (nx>=1&&nx<=n&&ny>=1&&ny<=m&&ch[nx][ny]!='#'&&!f[nx][ny]) //满足条件
			{
				node t;
				t.x=nx;t.y=ny;
				que.push(t); //入列
				if (ch[nx][ny]=='*') ++num; //判断
				f[nx][ny]=true; //清为不可走
			}
		}
		que.pop(); //出列
	}
}
int main()
{
	cin>>n>>m;
	n=5*n+1;m=5*m+1; //把n,m更新
	for (int i=1;i<=n;++i)
		for (int j=1;j<=m;++j)
			cin>>ch[i][j];
	memset(a,0,sizeof(a)); //a数组清零
	for (int i=1;i<=n;++i)
		for (int j=1;j<=m;++j)
			if (ch[i][j]!='#'&&!f[i][j])
			{
				bfs(i,j);++a[num/4+1]; //num/4+1就是bfs中窗户状态，不信可以去试
			}
	for (int i=1;i<=5;++i) cout<<a[i]<<' '; //输出
	return 0; //完美的结束
}

```


---

## 作者：wuyonghuming (赞：3)

## 思路：
这道题目可以用搜索做，如果遇到一个点是$*$或者$.$说明这个点在窗户以内，然后用搜索来计算有几个$*$，这样可以知道这个窗户的状态。
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
char w[1001][1001];//输入的窗户
int ans[6],t=0,n,m;//ans记录答案
int fx[4]={0,0,1,-1};//四个横坐标的方向，可以减少代码长度
int fy[4]={1,-1,0,0};//四个列坐标的方向，可以减少代码长度
void dfs(int x,int y)//定义这个搜索
{
	if(w[x][y]=='*')//判断这个格子是否是*
	{
		t++;//如果是个数加一
	}
	w[x][y]='#';//把这个格子置为#，因为搜过了就没用了
	for(int i=0;i<=3;i++)//枚举四种方向
	{
		int nx=fx[i]+x,ny=fy[i]+y;//记录经过方向后到达的位置
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&w[nx][ny]!='#')//判断它是否到达图外面或者不是窗户
		{
			dfs(nx,ny);//继续搜索
		}
	}
}
int main()
{
	cin>>n>>m; //输入有多少行和多少列
	n=n*5+1;//先算出有多少行，因为有5n+1行，所以先算出来后面就不用计算了
	m=m*5+1;//先算出有多少列，因为有5m+1行，所以先算出来后面就不用计算了
	for(int i=1;i<=n;i++)//循环输入
	{
		for(int j=1;j<=m;j++)//循环输入
		{
			cin>>w[i][j];//输入这个格子的状态
		}
	}
	for(int i=1;i<=n;i++)//循环判断
	{
		for(int j=1;j<=m;j++)//循环判断
		{
			if(w[i][j]=='*'||w[i][j]=='.')//如果这个格子是这两种状态的话，说明是窗户
			{
				t=0;//先把它置零
				dfs(i,j);//对这个格子进行搜索
				ans[t/4]++;//这个窗户*的个数除以4就是窗户的状态
			}
		}
	}
	for(int i=0;i<=4;i++)//循环输出
	{
		cout<<ans[i]<<' ';//输出答案
	}
	return 0;//别忘了
}
```


---

## 作者：T1anBooy (赞：2)

__[P6438[COCI2011-2012#6]PROZORI](https://www.luogu.com.cn/problem/P6438)__

Round 1！

暴力枚举：

我们只需要遍历一遍每个窗子的第一列即可，因为每个窗子的同一行都是一样的，而遍历完一个窗子后，$j$就加$4$，用字符数组来存储（相当于小型邻界矩阵的存储方式），对于每一行，就只有三种可能：

1. 是'.'， 即没拉的百叶窗
2. 是'\*'，即下拉的百叶窗
3. 是'\#'，即百叶窗的边框

*遍历一遍呗*

于是：

```
#include <bits/stdc++.h>

#include <algorithm>
#include <iostream>
#include <stdio.h>
#include <math.h>

#define maxn 505 //n,m最大100，则5*n,m最大为500，个人习惯，最大值赋值为505

using namespace std;

 char mp[maxn][maxn];
 int n, m;
 int Type[8]; //最多有5种情况，最好赋值为2的整数次方（老师教的，完整空间，超管用）

int main () {
	scanf ("%d %d", &n, &m);
	for (int i = 1; i <= 5 * n + 1; i ++) {
		for (int j = 1; j <= 5 * m + 1; j ++) {
			cin >> mp[i][j];
		}
	}
	for (int i = 2; i <= 5 * n; i += 4) {
		if (mp[i][2] == '#') {
			i -= 3;
			continue;
		}
		for (int j = 1; j <= 5 * m; j ++) {
			if (mp[i][j] == '#') continue;
			if (mp[i][j] == '.') {
				Type[0] ++;
				j += 4;
			}
			if (mp[i][j] == '*') {
				int temp = 0;
				for (int k = 1; k < 4; k ++) {
					if (mp[i + k][j] == '.') break;
					temp ++;
				}
				Type[temp + 1] ++;
				j += 4;
			}
		}
	}
	printf ("%d %d %d %d %d\n", Type[0], Type[1], Type[2], Type[3], Type[4]);
	return 0;
}
```
Luogu_Blog @ [天梦丶天幕](https://www.luogu.com.cn/user/94933)

---

## 作者：novax (赞：1)

题解里大佬们是用搜索做的，个人感觉暴力比搜索要容易一些，那我就发一篇用模拟做的题解吧，时间复杂度是 $O(nm)$ 的，可以过

#### 思路

用二维的字符数组存下输入的所有百叶窗的样式，然后用两层循环计算每个百叶窗的状态，因为百叶窗的每一列都是一样的，所以只需要判断每个百叶窗最左边有几个*号就可以得到这个百叶窗的状态了，最后输出答案就可以了

#### 20行的代码

```cpp
#include <cstdio>
char a[520][520];
int main()
{
	int ans[6],N,M,i,j,k;
	scanf("%d%d",&N,&M);
	for(i=0;i<=5*N;i++)
		scanf("%s",a[i]);
	int ad;
	for(i=0;i<N;i++)
		for(j=0;j<M;j++)
		{
			ad=0;
			for(k=0;k<4;k++)
				if(a[5*i+k+1][5*j+1]=='*')
					ad++;
			ans[ad]++;
		}
	printf("%d %d %d %d %d",ans[0],ans[1],ans[2],ans[3],ans[4]);
}
```


---


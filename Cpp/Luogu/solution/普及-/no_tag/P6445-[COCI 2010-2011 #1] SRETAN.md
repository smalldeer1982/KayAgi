# [COCI 2010/2011 #1] SRETAN

## 题目描述

已知 $4$ 和 $7$ 是幸运数字，而其他数字不是幸运数字。如果一个整数中只包含十进制表示法中的幸运数字，则这个整数是幸运的。你需要求出第 $k$ 个幸运的正整数。

## 说明/提示

**样例输入输出 1 解释**

因为是正整数，所以第一个一定是数字 $4$。

---

**数据规模与约定**

对于 $100\%$ 的数据，$1 \leq k \leq 10^9$。

---

**说明**

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #1](https://hsin.hr/coci/archive/2010_2011/contest1_tasks.pdf) *T3 SRETAN*。**

## 样例 #1

### 输入

```
1```

### 输出

```
4```

## 样例 #2

### 输入

```
2```

### 输出

```
7```

## 样例 #3

### 输入

```
3```

### 输出

```
44```

# 题解

## 作者：一只书虫仔 (赞：17)

[P6445](https://www.luogu.com.cn/problem/P6445)

#### Description

> 定义由 $4$ 和 $7$ 组成的数为幸运数，求第 $k$ 个幸运数。

#### Solution 1

只有 $4$ 和 $7$？其实我们可以模拟成二进制数的，即求第 $k$ 个二进制数，只不过 $0$ 是 $4$，$1$ 是 $7$。

1. 将 $(k)_{10}$ 转化为二进制
2. 如果是 $0$ 输出 $4$，是 $1$ 输出 $7$，比如 $0100111$ 就输出 $4744777$

#### Code 1

```cpp
#include <bits/stdc++.h>

using namespace std;

long long j, a[100000];

void erzhi (long long i) {
	while (i) {
        	j++;
    		a[j] = i % 2;
    		i /= 2;
	}
}

void ans (long long k) {
	erzhi(++k);
	for (long long i = j - 1; i >= 1; i--)
		if (a[i] == 0)
			printf("4");
		else
			printf("7");
}

int main () {
	long long k;
	scanf("%lld", &k);
	ans(k);
	return 0;
}
```

#### Solution 2

我们也可以直接不用二进制，用一种类似递归的方式来。

比如我们看第 $8$ 个幸运数，$447$，是第 $3$ 个幸运数加上一个 $7$，第 $3$ 个幸运数又是第 $1$ 个幸运数加上一个 $4$，这时候我们就可以发现一个规律，对于第 $k$ 个幸运数，可以通过下面的公式得出（假设第 $k$ 个幸运数是 $a_k$）

$$a_k=a_{\left\lfloor\frac{k-1}{2}\right\rfloor}\times 10+d\begin{cases}d=4(k\bmod 2=1)\\d=7(k\bmod 2=0)\end{cases}$$

初始化 $a_1=4,a_2=7$。

然后就可以打一份递归的代码了，这里建议用字符串存储。

By Shuchong       
2020.8.7

---

## 作者：wuyonghuming (赞：9)

## 思路：
这道题目就像二进制一样，只有两个数，可以按二进制的做法试试（十进制转二进制）。

我们不妨先弄张表，从里面找找规律，用$s$表示答案。
## 表格：
$s_1=4,s_2=7$

$s_3=44,s_4=47,s_5=74,s_6=77$

$s_7=444,s_8=447,s_9=474,s_{10}=477,s_{11}=744,s_{12}=747,s_{13}=774,s_{14}=777$

$...$
## 发现：
上一行和这一行中，前面总会有**重叠**的一部分。

假设这个数的位置是$i$。

现在**发现**，位置$(i-1)/2$的数，总会是位置$i$的那个数的**前面那一部分**。

接着，我们又**发现**：位置是**偶数**的最后一位**一定**是$7$，位置是**奇数**的最后一位**一定**是$4$。
## 公式：
当$i$是**奇数**时：$s_i=s_{(i-1)/2}*10+4$

当$i$是**偶数**时：$s_i=s_{(i-1)/2}*10+7$
## 方法：
可以从后往前算，每次算出最后一位，到最后，答案就算出来了。但是要**倒叙输出**。
## 注意事项：
**答案可能非常大，long long也存不下，最好用字符串来记录答案！！！**
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
int main()
{
	long long k;//第k个幸运数
	string ans="";//这个记录答案
	cin>>k;//输入k
	while(k>0)//当它大于零
	{
		if(k%2==0)//如果除以2余数是0
			ans+='7';//加上7
		else//否则
			ans+='4';//加上4
		k=(k-1)/2;//现在到了它的上一行
	}
	for(int i=ans.size()-1;i>=0;i--)//size是长度
		cout<<ans[i];//输出答案
	return 0;//别忘了
}
```
## 总结：
遇到这种类似的题目，做了很久做不出来时，可以打表看看答案，最后再来写代码。
## 感谢：
谢谢大家的观赏，谢谢管理抽出时间审核！！！


---

## 作者：y0y68 (赞：8)

简单的二进制题，把数字 $4$ 看做 数字 $0$ ，把数字 $7$ 看做 数字 $1$ ，列两个表格看看吧：



| 第几个幸运数 | 幸运数 |
| :----------: | :------: |
| $1$ | $0$ |
| $2$ | $1$ |
| $3$ | $00$ |
| $4$ | $01$ |
| $5$ | $10$ |
| $6$ | $11$ |
| $7$ | $100$ |
| $8$ | $101$ |

| 第几个二进制数 | 二进制数 |
| :----------: | :------: |
| $1$ | $1$ |
| $2$ | $10$ |
| $3$ | $11$ |
| $4$ | $100$ |
| $5$ | $101$ |
| $6$ | $110$ |
| $7$ | $111$ |
| $8$ | $1000$ |

我们发现第 $i$ 个二进制数去掉前面的 $1$ 就成为了第 $i-1$ 个幸运数！于是读入 $n$ 之后，我们先把 $n$ 加 $1$ ，然后转为二进制，把前面的 $1$ 跳过，将 $0$ 和 $1$ 分别还原成 $4$ 和 $7$ 就可以了。

代码（由于本人过懒，不想打手写栈，大佬勿喷）：
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
stack<int>st;
//转二进制其实就是维护一个栈
int main(){
	cin>>n;n++;
	while(n>>1){
		//n>>1为位运算，等于n/2，只不过速度快点儿
		//这里这样做是为了免去二进制前面的1，正常写法为while(n)
		//n&1也为位运算，等于n%2==1，速度也是快点
		if(n&1)st.push(7);//二进制中1变7
		else st.push(4);//二进制中0变4
		n>>=1;
	}
	while(!st.empty()){//栈非空
		printf("%d",st.top());//输出栈顶
		st.pop();//弹出栈顶
	}
	puts("");//换行的意思
	return 0;
}
```

---

## 作者：Thomas_Cat (赞：3)

这题比较简单，我们现在有一个 $10$ 进制下的数 $k$ ，也就是 $(k)_{10}$ ，我们现在要把他转换成 $2$ 进制，也就是 $(k)_2$ ，简单来说就是：$(k)_{10} \to (k)_2$ 。



经过找规律发现（下表）：（在这里我们的规定是：$4 \to 0 , 7 \to 1$ ）



| 第 $k$ 项 | 答案 | 二进制编码 | 最终发现的答案 |
| :-------: | :--: | :-------: | :---------: |
| 1 | 4 |1|0|
| 2 | 7 |10|1|
| 3 | 44 |11|00|
| 4 | 47 |100|01|
| 5 | 74 |101|10|
| 6 | 77 |110|11|
| 7 | 444 |111|000|

所以我们发现，第 $k$ 项的答案就是 $(k+1)_2 \to \text{去掉开头的} 1 \to \text{最终的答案}$ 。



代码如下：



```cpp
#include <iostream>
using namespace std;
int n;
int tmp = 0;
int ch[1000001];
void change() {//转换进制
	while (n) {//这里循环查找，进制使用短除法，这里使用 while 模拟
		ch[++tmp] = n % 2;//这里就是取 / 2 的余数
		n /= 2;//每一次 n 再 /2 为后面的 % 2 做准备
	}
	return;//可有可无，仅仅为了代码美观
}
int main() {
	cin >> n;//输入
	n++;//这里通过刚刚的观察 要在二进制下 +1 
	change();//转换成 2 进制
	tmp--;//然后去掉开头的 1 即可
	for (int i = tmp; i >= 1; i--) {//循环输出，注意从大到小
		if (ch[i] == 0) cout << 4;
		else cout << 7;
	}
	return 0;//华丽结束
}
```





---

## 作者：小坦克 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P6445)
---------
### 申明：
首先想说一点：其实这道题以前我们在学基本语言的时候考过一次，当时我做错了，这次偶然发现了这道题，想尝试一下。。。

---------
### 做题过程：
我看到下面很多大佬都用了二进制，所以我用二进制的思路想了一下这道题（其实还翻看了一下之前考试的 $std$ 的思路），发现了一些公式。

---------
### 公式探讨：
- 当 $i$ 为**偶数**的时候$：$ **$S_i$** $=$ $S_{(i-1)/2}$ $*$ $10$ $+$ $'4'$

- 当 $i$ 为**奇数**的时候$：$ **$S_i$** $=$ $S_{(i-1)/2}$ $*$ $10$ $+$ $'7'$

所以就可以得出**下面**的代码：

---------
## $Code$ $:$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
string ans="";
int main(){
	cin>>n;
	while(n>0){
		if(n%2==0) ans+='7';
		else ans+='4';
        n=(n-1)>>1;
	}
    int len=ans.length();
	for(int i=len-1;i>=0;i--) cout<<ans[i];
	return 0;
}
```
-------
# 谢谢大家！！！

---

## 作者：Ezis (赞：1)

### 题意：

求第 $k$ 大的，只由 $4$ 和 $7$ 组成的数。

### 思路：

由于题目要求只有 $4$ 和 $7$ 两个数，所以能联想到二进制。

可以把前几项都列出来找找规律：

![](https://cdn.luogu.com.cn/upload/image_hosting/acc9alf0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

发现与 $k+1$ 的二进制有关。

于是，我们可以先把 $k+1$ 转换为二进制，再去掉开头的 $1$ 后，

**发现:**

若当前位上的数字是 $1$ ，那么最后的结果为 $7$ 。

若当前位上的数字是 $0$ ，那么最后的结果为 $4$ 。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,cnt,a[100005];
int main(){
	scanf("%d",&k);
	k++;	//与k+1有关
	while(k){
		a[++cnt]=k%2;
		k/=2;
	}//转换为二进制
	cnt--;	//去掉第一个1
	for(int i=cnt;i>=1;i--)	//倒着来枚举
		if(a[i]==0)
			printf("4");	//若是0，输出4
		else
			printf("7");	//若是1，输出7
	return 0;
}
```


---

## 作者：fanypcd (赞：0)

### 题目简述：

定义‘幸运数’为仅由 4，7 组成的数，求所有幸运数从大到小排序后排名第 k 的幸运数。

### 题目思路：

- 观察样例可以发现：若 $k$ 是奇数，则第 $k$ 个幸运数的最后一位是 4，反之是 7。
- 现在就考虑已知第 $k$ 个幸运数的最后一位，如何求出前面几位所对应的 $k'$ 值，这样就可以递归求解。
- 枚举易得：（以下用 $number_k$ 表示第 $k$ 个幸运数）
- $k = 1 , number_1 = 4,k'=0$
- $k = 2 , number_2 = 7,k'=0$
- $k = 3 , number_3 = 44,k'=1$
- $k = 4 , number_4 = 47,k'=1$
- $k = 5 , number_5 = 74,k'=2$
- $k = 6 , number_6 = 77,k'=2$
- $k = 7 , number_7 = 444,k'=3$
- $k = 8 , number_8 = 447,k'=3$
- 不难发现：
- 当 $number_k$ 的最后一位是 4 时，前面几位对应的 $k' = k / 2$
- 当 $number_k$ 的最后一位是 7 时，前面几位对应的 $k' = k / 2 - 1$
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
void work(int x)
{
	if(!x)
	{
		return;
	}
	if(x == 1)
	{
		cout << "4";
		return;
	}
	if(x == 2)
	{
		cout << "7";
		return;
	}
	if(x & 1)
	{
		work(x >> 1);
		cout << "4";
	}
	else
	{
		work((x >> 1) - 1);
		cout << "7";
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	work(n);
	return 0;
}
```


---

## 作者：Mars_Dingdang (赞：0)

由于一个幸运数字只包含 $4,7$ 这两种数码，因此自然就会联想到一种仅由两个数码构成的运算法则：二进制。

## 题目大意
已知 $4$ 和 $7$ 是幸运数字，而其他数字不是幸运数字。如果一个整数中只包含十进制表示法中的幸运数字，则这个整数是幸运的。你需要求出第 $n$ 个幸运的正整数。

## 大体思路
**第一步：分析**

注意数据范围：$1<=n<=10^9$，这意味着用循环直接模拟是肯定超时的（你想打表打到天荒地老也可以）。因此就需要运用二进制来解决这道题了

**第二步：处理二进制**

| 第$n$个 | 幸运数字 |二进制 |
| :----------: | :----------: | :----------: |
| 1 |4  |1 |
| 2 | 7 |10 |
| 3 | 44|11 |
| 4 |47  |100 |
| 5 |444  |101 |
我们可以发现，规律为第 $i$ 个幸运数为将第 $i+1$ 个数的二进制去掉开头的 $1$，然后将 $0=>4,1=>7$。这样便能得到想要的数。

代码如下：
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int a[100];//存二进制数
int main(){
	int n;
	cin>>n;//输入
	int x=0;//记录位数
	n++;//求第n+1个数的二进制
	while(n){
		x++;
		a[x]=n%2;
		n/=2;
	}//转换进制
	for(int i=x-1;i>=1;i--){
		if(a[i]==1) cout<<7;
		else cout<<4;
	}//处理并输出
	return 0;//完美
}
```
~~看得这么认真，不点个赞再走嘛qaq~~

---

## 作者：Graphcity (赞：0)

我们先不妨把 7 看作 1, 把 4 看作 0 ，那么幸运数就可以转化成一个二进制数了。我们可以将幸运数列一张表：（ 第 $i$ 个幸运数称为 $l_i$ ）

| $i$ | $l_i$ 对应的二进制数 |
| :----------: | :----------: |
| 1 | 0 |
| 2 | 1 |
| 3 | 00 |
| 4 | 01 |
| 5 | 10 |
| 6 | 11 |
| 7 | 000 |
| 8 | 001 |

可以发现，如果在某一时刻二进制数上**全为 1**，那么下一个数是就是 0，位数将会增加 1. 其它情况，则是普通的 +1 运算。

于是，我们可以写出 70pts 的代码：

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,t=1,nowt=0;//t:位数  nowt:现在的二进制数 
	scanf("%d",&k);
	k--;
	while(k--)
	{
		if(nowt==(1<<t)-1)//如果全为1
		{
			nowt=0,++t;//进位 
			continue;
		}
		++nowt;
	}
	for(register int i=t;i>=1;--i)//注意这里是倒序 
		printf("%d",(nowt&(1<<i-1))?7:4);//读取二进制位 
    return 0;
}
```

不过，由于它需要循环 $k$ 次，运行速度异常慢，所以我们需要将它优化一下。

我们再来列一张表：

| $i$ | $l_i$ | 位数 |
| :----------: | :----------: | :---: |
| 1 | 0 | 1 |
| 3 | 00 | 2 |
| 7 | 000 | 3 |
| 15 | 0000 | 4 |
| 31 | 00000 | 5 |

我们记 $f(i)$ 为第 $i$ 次全为 0 时是第几个幸运数。找规律发现，$f(1)=1 , \ f(i+1)=f(i) \times 2 +1$ 。

这样，我们就可以很快的求出 $l_k$ 的位数 $t$ 了。再让 $k$ 减去 $f(t)$ , 剩下的值即为 $l_k$ 的二进制值。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int k,t=1;//t:位数 
	scanf("%d",&k);
	
	int nowt=1;
	while(nowt*2+1<=k)//计算位数 
		t++,nowt=nowt*2+1;
	
	k=k-nowt;
	for(register int i=t;i>=1;--i)//读取二进制数 
		printf("%d",k&(1<<i-1)?7:4);
    return 0;
}
```

---


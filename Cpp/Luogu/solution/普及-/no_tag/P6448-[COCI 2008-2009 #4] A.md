# [COCI 2008/2009 #4] A

## 题目描述


给定五个数字组成的序列 $a$，$1 \sim 5$ 在这五个数字中均恰好出现一次。现在请按照如下操作对序列进行排序。

1. 若 $a_1 > a_2$，则交换 $a_1$ 和 $a_2$。
2. 若 $a_2 > a_3$，则交换 $a_2$ 和 $a_3$。
3. 若 $a_3 > a_4$，则交换 $a_3$ 和 $a_4$。
4. 若 $a_4 > a_5$，则交换 $a_4$ 和 $a_5$。
5. 如果序列没有变成 $\{1, 2, 3, 4, 5\}$，则回到第一步，继续排序。

请在**每次交换**后输出当前序列。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq a_i \leq 5$，$a_i$ 互不相同，且不是单调递增的。

#### 提示

可以证明，交换次数不超过 $25$ 次。

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #4](https://hsin.hr/coci/archive/2008_2009/contest4_tasks.pdf) *T1  MJEHURIC***。

## 样例 #1

### 输入

```
2 1 5 3 4
```

### 输出

```
1 2 5 3 4
1 2 3 5 4
1 2 3 4 5```

## 样例 #2

### 输入

```
2 3 4 5 1
```

### 输出

```
2 3 4 1 5
2 3 1 4 5
2 1 3 4 5
1 2 3 4 5```

# 题解

## 作者：wuyonghuming (赞：7)

## 思路：
按照题目说的的模拟就行了，可以用数组代替变量。
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
int main()
{
	int s[6];//五个变量，我就用数组了
	for(int i=1;i<=5;i++)
	{
		cin>>s[i];//输入
	}
	while(1)//因为总会有到升序的时候
	{
		for(int i=1;i<=4;i++)//四次判断
		{
			bool p=true;//这个变量判断是否是升序
			if(s[i+1]<s[i])//如果后面的比前面的小
			{
				swap(s[i+1],s[i]);//交换函数
				for(int j=1;j<=5;j++)
				{
					cout<<s[j]<<' ';//每次交换都要输出
				}
				cout<<endl;//换行
			}
			for(int j=1;j<=4;j++)//这个循环判断升序
			{
				if(s[j+1]<s[j])//如果后面比前面小
				{
					p=false;//就不是升序
				}
			}
			if(p==true)//是升序
			{
				return 0;//就结束了
			}
		}
	} 
	return 0;//别忘了
}
```
谢谢观看！！



---

## 作者：LinkZelda (赞：5)

### 看最后一行，次数 $\leq 25$ 。

于是，我们就可以暴力水过本题。

因为结果序列一定是**单调递增**的，所以就很容易想出循环条件：
```cpp
while(a[1]>a[2]||a[2]>a[3]||a[3]>a[4]||a[4]>a[5])//单调递增，只要一个不满足条件就循环
```
然后就是按题意模拟了，一个个交换，直到序列满足条件为止。(记得输出**空行**，~~我就因为这爆 $0$ 了一次。。~~）
```cpp
#include<iostream>
#include<cmath> //调用swap交换函数，需要调用cmath库 
using namespace std;
int main()
{
	int a[6]={0};
	for(int i=1;i<=5;i++)cin>>a[i];//输入序列
	while(a[1]>a[2]||a[2]>a[3]||a[3]>a[4]||a[4]>a[5])
	{
		if(a[1]>a[2]){swap(a[1],a[2]);cout<<a[1]<<' '<<a[2]<<' '<<a[3]<<' '<<a[4]<<' '<<a[5]<<endl;}
		if(a[2]>a[3]){swap(a[2],a[3]);cout<<a[1]<<' '<<a[2]<<' '<<a[3]<<' '<<a[4]<<' '<<a[5]<<endl;}
		if(a[3]>a[4]){swap(a[3],a[4]);cout<<a[1]<<' '<<a[2]<<' '<<a[3]<<' '<<a[4]<<' '<<a[5]<<endl;}
		if(a[4]>a[5]){swap(a[4],a[5]);cout<<a[1]<<' '<<a[2]<<' '<<a[3]<<' '<<a[4]<<' '<<a[5]<<endl;}
	}
	return 0;
 } 
```


---

## 作者：一扶苏一 (赞：3)

### Analysis

依照题意模拟即可。

c++11 提供了一个函数 `std::is_sorted(begin, end)` 来快速判定容器里的元素是否已经被排好序。其中 `begin` 和 `end` 分别表示容器的头尾指针，左闭右开。使用时需要包含 `Algorithm` 头文件。

**注意，这个函数存在于 cpp11 及以上标准中，也就是 NOI/NOIp/CSP-JS 等不开启 `-std=c++11` 编译选项的竞赛中均不允许使用。**

### Code

```cpp
#include <iostream>
#include <algorithm>

const int maxn = 5;

int a[maxn];

int main() {
  const int n = 5;
  for (auto &u : a) {
    std::cin >> u;
  }
  while (!std::is_sorted(a, a + n)) {
    for (int i = 0, di = i + 1; di < n; i = di++) if (a[i] > a[di]) {
      std::swap(a[i], a[di]);
      for (auto u : a) {
        std::cout << u << ' ';
      }
      std::cout << std::endl;
    }
  }
  return 0;
}

```



---

## 作者：asasas (赞：1)

这题不算难，按题意模拟即可AC。
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;	
int s[505];
void print(){
	for (int i=1;i<=5;i++) cout << s[i] << ' ';
	cout << endl;
}//输出函数
bool check(){
	for (int i=1;i<=5;i++) if (s[i]!=i) return 0;
	return 1;//判断是否达到结束条件
}
int main(){
	for (int i=1;i<=5;i++) cin >> s[i];//读入
	while(1){//没达到条件就一直循环
		if (s[1]>s[2]) swap(s[1],s[2]) ,print();
		if (s[2]>s[3]) swap(s[2],s[3]), print();
		if (s[3]>s[4]) swap(s[3],s[4]), print();
		if (s[4]>s[5]) swap(s[4],s[5]), print();//以上为模拟
		if (check()) break;/达到条件就结束
	}
    return 0；//平时养成习惯，否则竞赛时会爆0的
}
```


---

## 作者：警策看取 (赞：1)

由于 $a_i \le 5$，且最多交换 $25$ 次，因此啥都不需要想，题目说什么就做什么就行了。

```cpp
int a[5];
void output(){cout<<a[1]<<" "<<a[2]<<" "<<a[3]<<" "<<a[4]<<" "<<a[5]<<endl;}

int main(){
	cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5];
	while(!(a[1]==1&&a[2]==2&&a[3]==3&&a[4]==4&&a[5]==5)){
		if(a[1]>a[2])swap(a[1],a[2]),output();
		if(a[2]>a[3])swap(a[2],a[3]),output();
		if(a[3]>a[4])swap(a[3],a[4]),output();
		if(a[4]>a[5])swap(a[4],a[5]),output();
	}
	return 0;
}
```

[完整代码](/paste/ms5721iq)

---


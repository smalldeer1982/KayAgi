# [COCI 2006/2007 #5] NATRIJ

## 题目描述

给定一个起始时间和结束时间，你需要求出这段时间间隔是多长。

保证时间间隔至少是 $1$ 秒钟，最多是 $24$ 小时。

## 说明/提示

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #5](https://hsin.hr/coci/archive/2006_2007/contest5_tasks.pdf) *T2 NATRIJ***。

## 样例 #1

### 输入

```
20:00:00
04:00:00```

### 输出

```
08:00:00```

## 样例 #2

### 输入

```
12:34:56
14:36:22```

### 输出

```
02:01:26```

# 题解

## 作者：wuyonghuming (赞：9)

## 思路：
$1$.算出两个时间分别是一天的第几秒.

$2$.比较这两个时间的大小.

$3$.如果第一个时间大，说明到了第二天，拿第二个时间加上一天的秒数减去第一天的时间，否则直接拿第二天减去第一天.

$4$.输出，如果小于$10$,前面加上$0$.
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
void hanshu(int t)
{
	if(t<36000)//判断是否有10小时
		cout<<0;//没有就补上0
	cout<<t/3600<<':';//输出几个小时
	t%=3600;//取余，去掉小时后剩下多少秒
	if(t<600)//判断是否有10分钟
		cout<<0;//没有就补上0
	cout<<t/60<<':';//输出几分钟
	t%=60;//取余，去掉分钟后剩下多少秒
	if(t<10)//判断是否有10秒
		cout<<0;//没有就补上0
	cout<<t;//输出多少秒
}
int main()
{
	int a,b,c,d,e,f,t1,t2;//a,b,c,d,e,f是用来记录时间
	char g;//这个变量用来处理:
	cin>>a>>g>>b>>g>>c;//输入开始时间
	cin>>d>>g>>e>>g>>f;//输入结束时间
	t1=a*3600+b*60+c;//计算开始时间是当天的第几秒
	t2=d*3600+e*60+f;//计算结束时间是当天的第几秒
	if(t1<t2)//如果这是在同一天
		hanshu(t2-t1);//直接计算
	else//如果不是在同一天
		hanshu(t2+86400-t1);//加上一天的秒数计算
    return 0;//别忘了
}

```
谢谢观看！

---

## 作者：Utilokasteinn (赞：6)

来一个暴力解法，把所以时间化成秒，然后再相减。我们知道小数*3600+分钟*60+秒=总秒数，然后再相减，如果第二个时间小于第一个时间， 说明已经到了第二天，所以秒数就要加上一天，即24*3600。最后输出答案。这里要注意，我们已经把答案转成秒了，所以还要把它给还原回去。小时数即答案/3600, 分钟数即答案%3600/60，秒数等于答案%60，然后输出。

因为题目要求，如果输出的数小于10就要在前面补零，所以我们用printf，printf可以控制前导0，比如printf("%05d",a)就表示输出a，如果a不足五位数就在前面补零。代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3],b[3],c[3];
char x;
int main()
{
	for(int i=1;i<=2;i++)
	    cin>>a[i]>>x>>b[i]>>x>>c[i];//输入开始和结束的时间 
	int a1=a[1]*3600+b[1]*60+c[1],b1=a[2]*3600+b[2]*60+c[2];
	if(b1<=a1)b1+=24*3600;b1-=a1;//如果不是在同一天里就加上一天的秒数 
	printf("%02d:%02d:%02d",b1/3600,b1%3600/60,b1%60);//输出答案 
	return 0;
}
```


---

## 作者：Xeqwq (赞：1)

~~来一篇奇怪的码风~~  
定一些变量，在全局  
```cpp
int h1,m1,s1;
int h2,m2,s2;
int hs,ms,ss;
char m;//装冒号
```

我的main函数：  
```cpp
int main()
{
	in();//输入函数
	if(!cmp())//cmp就是比较函数，比较哪个时间早
		h2+=24;//要是第一个早就说明第二个是在次日的，给他加24个小时。
	sub();//减出两个时间差
	zuhe();//把他们给换算成一共时多少秒
	out();//输出，注意要加的‘0’
	return 0;
}
```
~~就是这么简单~~  
输入函数，应该没有难度吧：  
```cpp
void in()
{
	cin>>h1>>m>>m1>>m>>s1>>h2>>m>>m2>>m>>s2;
} 
```
比较函数：  
```cpp
bool cmp()
{
	if(h1!=h2)//如果两个时间不在同一个小时
		return h1<h2;//那么就不在吧，比较，返回
	if(m1!=m2)//如果两个时间在同一个小时但是不在同一分钟
		return m1<m2;//那就不在吧，比较，返回
		return s1<s2;//因为不可能给出同样的两个时间，所以比较秒钟然后返回
}
```
然后是减出两个时间的差，不用管有没有负数，因为在后面可以计算成总共差多少秒，要是是个负数直接加就会减这么多秒。  
```
//知道刚刚说的那些逻辑这块儿就没啥问题了
void sub()
{
	hs=h2-h1;
	ms=m2-m1;
	ss=s2-s1;
}
```
然后换算成差多少秒，其目的就是为了在后面再拆分成不带负数的时分秒的形式。   
在这个函数里面，我们组合成秒数再拆分
```cpp
void zuhe()
{
	int sum=hs*3600+ms*60+ss;//组合，这个3600和60大家肯定懂吧
	hs=sum/3600;//小时
	sum%=3600;//去掉刚刚算的那几个小时的秒数，用取模筛掉。
	ms=sum/60;//分钟
	sum%=60;
	ss=sum;//剩下的就是秒了
}
```
最后，输出。  
```cpp
void out()
{
	if(hs<10)
		cout<<0;
	cout<<hs<<m;
	if(ms<10)
		cout<<0;
	cout<<ms<<m;
	if(ss<10)
		cout<<0;
	cout<<ss;
}
```
谢谢大家吖，最后奉上全代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int h1,m1,s1;
int h2,m2,s2;
int hs,ms,ss;
char m;//装冒号
void in()
{
	cin>>h1>>m>>m1>>m>>s1>>h2>>m>>m2>>m>>s2;
} 
bool cmp()
{
	if(h1!=h2)
		return h1<h2;
	if(m1!=m2)
		return m1<m2;
		return s1<s2;
}
void sub()
{
	hs=h2-h1;
	ms=m2-m1;
	ss=s2-s1;
}
void zuhe()
{
	int sum=hs*3600+ms*60+ss;
	hs=sum/3600;
	sum%=3600;
	ms=sum/60;
	sum%=60;
	ss=sum;
}
void out()
{
	if(hs<10)
		cout<<0;
	cout<<hs<<m;
	if(ms<10)
		cout<<0;
	cout<<ms<<m;
	if(ss<10)
		cout<<0;
	cout<<ss;
}
int main()
{
	in();
	if(!cmp())
		h2+=24;
	sub();
	zuhe();
	out();
	return 0;
}
```


---

## 作者：SUNCHAOYI (赞：1)

我们运用**字符串**来输入这两个时间点。那么所输入的一个时间的字符长度为 $8$（`XX:XX:XX`）。那么我们把**两个时间统一单位为秒钟后作差，然后再进行求解**。那么我们设输入的一个字符串为 `str`，再分别来看时分秒。
- 时：`(str[0] - '0') * 10 + str[1] - '0'`
- 分：`(str[3] - '0') * 10 + str[4] - '0'`
- 秒：`(str[6] - '0') * 10 + str[7] - '0'`

然后将这些内容分别 $\times 3600,60,1$ 则能得到**统一单位的时间和**。然后我们将两者**作差**。则会有 $3$ 种情况：
- `str_end - str_start > 0`，直接进行转换输出即可。
- `str_end - str_start == 0`，由题可知正好为 $24$ 个小时，需要特判输出。
- `str_end - str_start < 0`，即跨了一天,需要加上 $24$ 个小时（也就是 $24 \times 3600$ 秒）。

最后就是输出了，记得输出 $0$ 的**特殊情况**，在此不赘述。代码如下：
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	string a,b;int ans = 0;
	cin>>a>>b;
	//start与end的时间求和（单位：秒） 
	int timea = ((a[0] - '0') * 10 + a[1] - '0') * 3600 + ((a[3] - '0') * 10 + a[4] - '0') * 60 + ((a[6] - '0') * 10 + a[7] - '0');
	int timeb = ((b[0] - '0') * 10 + b[1] - '0') * 3600 + ((b[3] - '0') * 10 + b[4] - '0') * 60 + ((b[6] - '0') * 10 + b[7] - '0');
	ans = timeb - timea;//作差 
	if(timea == timeb)//特判 
	{
		cout<<"24:00:00"<<endl;
		return 0;
	}
	if(timea > timeb) ans += 24 * 3600;//隔了一天 
	//换算输出，注意0的情况 
	if(ans / 3600 < 10) cout<<"0";
	cout<<ans / 3600<<":";
	if(ans % 3600 / 60 < 10) cout<<"0";
	cout<<ans % 3600 / 60<<":";
	if(ans % 3600 % 60 < 10) cout<<"0";
	cout<<ans % 3600 % 60<<endl;
	return 0;
 } 
```


---

## 作者：_tommysun_ (赞：0)

这道题我是用模拟过的，也就是暴力呗。个人感觉这道题和高精度算法差不多吧。

**整体思路如下：**

- 输入时，无需使用字符串string，直接用六个整型变量与四个字符型变量就可以了。。。
- 接下来开始运算，如果不够向高位借位就可以了。
- 最后是输出，由于输出格式是 ``hh:mm:ss``，如果输出的数据是个位数，就会漏掉"0"。因此，还需要判断一下输出的数据是否是个位数。

题面中有个坑，这里帮大家指出一下：描述中说了保证时间间隔最多是 **24** 小时，所以说，如果输入的两行是一样的话，并非是在同一时间，而是一天后的此时此刻。因此，在代码中有必要加一个特判。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int h1,h2,m1,m2,s1,s2;
	char j1,j2,j3,j4; //储存":"。 
	cin>>h1>>j1>>m1>>j2>>s1;  
	cin>>h2>>j3>>m2>>j4>>s2;
	int h3,m3,s3;
	if(h1==h2&&m1==m2&&s1==s2){
		cout<<"24:00:00"; //上文所说的特判 
		return 0; 
	}
	if(s2<s1){ //秒的运算。 
		s2+=60;
		m2-=1; //借位 
		s3=s2-s1;
	}
	else s3=s2-s1;
	
	if(m2<m1){ //分的运算。 
		m2+=60;
		h2-=1; //借位 
		m3=m2-m1;
	}
	else m3=m2-m1;
	
	if(h2<h1){ //时的运算，如果h2<h1就说明已经过了一天，所以+24. 
		h2+=24; 
		h3=h2-h1;
	}
	else h3=h2-h1; 
	
	if(h3/10==0) //如果h3是个位数
	{
		cout<<"0"<<h3<<":";
	} 
	else cout<<h3<<":";
	if(m3/10==0){ //如果m3是个位数 
		cout<<"0"<<m3<<":";
	}
	else cout<<m3<<":";
	if(s3/10==0){
		cout<<"0"<<s3; //不需要加":" 
	} 
	else cout<<s3;
	return 0; 
} 
```


---

## 作者：宇宙纪念册 (赞：0)

- [这道题](https://www.luogu.com.cn/problem/P6460)

- 我的代码：

```c
#include<bits/stdc++.h>
using namespace std;
int a1,a2,b1,b2,c1,c2,s1,s2,s3,l1,l2,l3;
char c;
int main()
{
    cin >> a1 >> c >> b1 >> c >> c1;//输入开始时间
    cin >> a2 >> c >> b2 >> c >> c2;//输入结束时间
    l1 = a1 * 3600 + b1 * 60 + c1;
    l2 = a2 * 3600 + b2 * 60 + c2;
    if(l1>l2)
    {
        l3 = 86400-l1+l2;
    }
    else if(l1==l2)
    {
        cout << "24:00:00";//如果相等，直接输出，结束程序
        return 0;
    }
    else if(l1<l2)    l3 = l2-l1;
    //转换，但是这个时候可能会大于60
    s1 = l3 / 3600;
    s2 = l3 % 3600 / 60;
    s3 = l3 % 60;
    //进位处理
    if(s3>59) 
    {
        s3 -= 60;
        s2 = s2 + 1;
    }
    if(s2>59)
    {
        s2 -= 60;
        s1 = s1 + 1;
    }
    //输出处理
    if(s1 < 10) cout << "0";
    cout << s1 << ":";
    if(s2 < 10) cout << "0";
    cout << s2 << ":";
    if(s3 < 10) cout << "0";
    cout << s3;
    return 0;
}
```

- 这道题目的思路：

将时间转换成秒，比较秒的大小

如果第一个时间大于第二个时间，说明跨天了，也就是过夜了，我们可以这么计算：

```c
86400-l1+l2;
```

也就是用24小时：86400秒，减掉第一天的秒，再加上第二天的秒即可

注意：题目中说到```格式为 hh:mm:ss （时，分，秒）。```，所以如果是```1时1分1秒```要输出```01:01:01```

可以这么办：

```
if(s3>59) 
{
  s3 -= 60;
  s2 = s2 + 1;
}
if(s2>59)
{
  s2 -= 60;
  s1 = s1 + 1;
}
if(s1>23)
{
  s1 = 0;
}


```

输出的时候：

不要忘记比较，当```小于10的时候```前面加一个0

```
if(s1 < 10) cout << "0";
cout << s1 << ":";
if(s2 < 10) cout << "0";
cout << s2 << ":";
if(s3 < 10) cout << "0";
cout << s3;

```


---

## 作者：hensier (赞：0)

本题值得使用$Python$练手，但需要注意细节。

- 考虑隔天的情况

- 相同时刻需要特判，直接输出$24:00:00$，原因是：

> 保证时间间隔至少是 $1$ 秒钟，最多是 $24$ 小时。

对于$Python$来说，我们可以输入两个字符串，然后分别提取其中的数字。这里会用到一个类型转换，即：

`int(x,base=y)`

上述函数可以将$x$（可以是数字或字符）转换为$y$进制的数。对于十进制数，$y$可以用$0$替代，作为默认值。

例如`int('8',base=0)=8`，`int('8',base=6)=12`等。

通过这种方式，我们可以将字符串的数据存入变量中。而通过这些变量，我们可以计算时间差，从而分别得到时、分、秒的差。

```python
s = ['', ''] # 定义空字符串数组，长度为2（等同于输入的行数）
hh = [0, 0] # 定义保存输入的小时的数组
mm = [0, 0] # 定义保存输入的分钟的数组
ss = [0, 0] # 定义保存输入的分钟的数组
t = [0, 0] # 定义保存一个时间点所对应的秒数（例如12小时36分钟27秒就是45387秒，以45387的数的形式存放在该数组中）
ans = [0, 0, 0] # 定义保存最终答案，即时间差的数组，长度为3（即时、分、秒）
first = False # 定义first的bool变量，用来判断是否要在开头打印冒号
for i in range(len(s)): # 在[0,len(s))的范围内进行操作（即[0,2)）
    s[i] = str(input()) # 以字符串形式输入
    hh[i] = int(s[i][0], base = 0) * 10 + int(s[i][1], base = 0) # 获得对应位置的数，对于每一段的第一个数，我们将其乘10并加上着一段的第二个数作为转化完的数据
    mm[i] = int(s[i][3], base = 0) * 10 + int(s[i][4], base = 0)
    ss[i] = int(s[i][6], base = 0) * 10 + int(s[i][7], base = 0)
    t[i] = 3600 * hh[i] + 60 * mm[i] + ss[i] # 计算时、分、秒对应的秒数
if s[0] == s[1]: # 特判！！！！！
    print('24:00:00')
else:
    if t[1] < t[0]: # 如果第二个的时刻在第一个时刻之前，就说明在第二天，要加1天，即（3600×24=）86400秒
        t[1] += 86400
    dif = t[1] - t[0] # 差为t[1]-t[0]
    ans[0] = dif // 3600 # 小时数
    ans[1] = dif // 60 % 60 # 分钟数
    ans[2] = dif % 60 # 秒数
    for i in ans: # 这里i取的是ans数组中对应的数据，而不是下标
        if first == True: # first为真就输出冒号
            print(':', end='') # end=''表示输出前面内容后不换行
        if i < 10: # 是一位数就要补0
            print('0', end='')
        print(i, end='') # 输出该位
        first = True # 赋值first为真
```

附上$C++$代码：（需要$C$语言的话，可以直接把下方的头文件`#include<cstdio>`改为`#include<stdio.h>`并把`bool first`改为`int first`，因为$C$语言没有`bool`）

```cpp
#include<cstdio>
int hh[2],mm[2],ss[2],t[2],dif,i,ans[3];
bool first;//这些变量意义都同Python代码（除了i以外，它是用于循环的）
int main()
{
    for(i=0;i<2;i++)
    {
        scanf("%d:%d:%d",&hh[i],&mm[i],&ss[i]);
        t[i]=3600*hh[i]+60*mm[i]+ss[i];//格式化输入不提
    }
    if(t[0]==t[1])//特判
    {
        printf("24:00:00");
        return 0;//直接结束程序
    }
    dif=t[1]-t[0];
    if(dif<0)dif+=86400;
    ans[0]=dif/3600;
    ans[1]=dif/60%60;
    ans[2]=dif%60;//计算
    for(i=0;i<3;i++)//循环输出
    {
        if(first)putchar(':');//putchar速度>printf速度
        if(ans[i]<10)putchar('0');//判断
        printf("%d",ans[i]);//输出
        first=1;//赋值
    }
}
```

$Updates:$

$\text{2020-4-24 19:31 发布}$

$\text{2020-4-25 9:10 增加了C++代码}$

---


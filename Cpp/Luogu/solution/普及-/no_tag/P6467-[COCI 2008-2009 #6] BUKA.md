# [COCI 2008/2009 #6] BUKA

## 题目描述

给定两个位数不超过 $100$，且为 $10$ 的幂次方的整数，你需要计算出他们相乘或者相加后的结果。

## 说明/提示

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #6](https://hsin.hr/coci/archive/2008_2009/contest6_tasks.pdf) *T1 BUKA***。

## 样例 #1

### 输入

```
1000
*
100```

### 输出

```
100000```

## 样例 #2

### 输入

```
10000
+
10```

### 输出

```
10010```

## 样例 #3

### 输入

```
10
+
1000```

### 输出

```
1010```

## 样例 #4

### 输入

```
1
*
1000```

### 输出

```
1000```

# 题解

## 作者：ADay (赞：9)

### ~~Python是个好东西~~
给大家介绍一个Py函数:`eval`  
这个东西就是拿来计算表达式的，比如：
```python
eval("4+5")=9
eval("2*8")=16
eval("pow(2,10)")=1024
```
里面的参数必需是字符串。   
那么这道题就简单了：
```python
print(eval(input()+input()+input()))
```
$\mathcal{BUT}$怎么RE了???   
因为输入有换行符`'\r'`   
那么我们可以使用py的**字符串切片操作**  
取到最后一个字符之前即可：`[:-1]`  
#### 极简代码：
```pascal
print(eval(input()[:-1]+input()[:-1]+input()))
```
最后一行没有`'\r'`所以不用

---

## 作者：Aw顿顿 (赞：6)

分情况讨论：

- 加法：

首先我们来观察一下：

$$10000$$
$$+\ 100$$
$$10100$$

是不是特别像按位模拟？

我们再次来看看题目：**为 $10$ 的幂次方的整数**。

这句话意味着每个数当中只会出现一个 $1$，就位于最高位。

那么我们假设两个字符串 $s1$ 和 $s2$。

将 $s1$ 对应 $s2$ 的那一位相加或者加一即可得到正确答案。

输出就行。

- 乘法：

乘法更加简单，$10^a\times10^b=10^{a+b}$，所以我们只需要输出 $1$ 之后输出 $a+b-2$ 个 $0$ 即可。

注意，如果你用 $l1$ 和 $l2$ 来存储字符串长度，字符串互换的时候长度也要互换。

- 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s1,s2;
char chr;
int main(){
    cin>>s1>>chr>>s2;
    int l1=s1.length(),l2=s2.length();
    if(l1<l2)swap(s1,s2),swap(l1,l2);
    if(chr=='+'){
        s1[l1-l2]+=1;
        cout<<s1<<endl;
    }
    else{
        putchar('1');
        for(int i=1;i<l1+l2-1;i++)putchar('0');
    }
    return 0;
}
```


--------

- 一些后话

这道题的前 $6$ 个测试点是加法，后 $4$ 个测试点是乘法。

每个测试点仅有一个运算，可以使用分支语句进行处理，建议将运算符单独存储。

祝大家学习愉快。

---

## 作者：tZEROちゃん (赞：5)

~~日常用 Python 水高精~~

____


**思路**

输入 $2$ 个数和 $1$ 个字符，如果字符 $s$ 是 `+`，则输出 $a + b$，否则输出 $a \times b$。

____

**代码实现**

1. 读入 $2$ 个数 $a,b$ 和 $1$ 个字符 $s$。

```python
a = int(input())
zf = input()
b = int(input())
```

2. 判断是 `+` 还是 `*`。如果是 `+`，则输出 $a + b$，否则输出 $a \times b$。

```python
if zf == '+\r' :
    print(a + b)
else :
    print(a * b)
```

______


**Code**

```python
a = int(input())
zf = input()
b = int(input())
if zf == '+\r' :
    print(a + b)
else :
    print(a * b)
```

---

## 作者：wuyonghuming (赞：4)

## 思路：
如果运算符号是 $+$ 那么位置是 $a$ 的长度减去 $b$ 的长度的位置加上 $1$。(位置从 $0$ 开始)

如果运算符号是 $*$ 那么就是 $1$ 的后面有 $a$ 的长度加上$b$ 的长度减去 $2$ 个 $0$。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string a,c;//两个整数
    char b;//运算符号
    cin>>a>>b>>c;//输入
    if(a.size()<c.size())//先比较长度
    {
    	swap(a,c);//保证a不比b短
	}
    if(b=='*')//是乘法
    {
    	cout<<1;//首位是1
    	for(int i=1;i<a.size()+c.size()-1;i++)
    	{
    		cout<<0;//输出a的长度加上b的长度减去2个0
    	}
    }
    else//是加法
    {
    	a[a.size()-c.size()]++;//a的长度减去b的长度的位置加一
    	cout<<a;//输出
    }
    return 0;//别忘了
}
```
谢谢观看！


---

## 作者：jijidawang (赞：2)

- [题目传送门](https://www.luogu.com.cn/problem/P6467)

我们设这两个数分别为 $10^a$ 和 $10^b$（假设 $a\ge b$）。

$10^a+10^b$：显然将 $10^a$ 中的第 $b$ 位加上 $1$ 即可。

$10^a\times 10^b$：显然是 $10^{a+b}$。

依题意模拟即可。

Code:

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int main()
{
	string a,b;
	char op;
	cin>>a>>op>>b;
	int len1=a.length(),len2=b.length();
	if (len1<len2) swap(a,b),swap(len1,len2);  //从小到大排序
	if (op=='+')
		++a[len1-len2],cout<<a;  //将第 b 位 +1
	else
	{
		putchar('1');
		for (int i=1;i<len1;i++) putchar('0'); //注意数字前面有个 1 所以长度要 -1
		for (int i=1;i<len2;i++) putchar('0');
	}
	return 0;
}
```

---

## 作者：Xeqwq (赞：2)

$$upd:JUL.22.2020$$
#### 本次upd修复了一些细节，增加了部分$\LaTeX$效果。
-------
[<题目传送门>再看看题吗](https://www.luogu.com.cn/problem/P6467)   
这道题我看了一眼就看上了 ~~我会做的题目不多，这道题已经很简单了~~  
我们要注意一下这个：
## 题目描述  
给定两个$\color{orange}\text{位数}$不超过 100，且为 $10^n$ 的整数(n为整数）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;↑  
就是这个有谁没有注意到？是这道题的关键。   
因为位数肯定是存不下了，所以我们一定要使用高精度。  
所谓高精度，就是模拟**手算的过程**。


------------
然后，我们做题，要将这道题分为两个大if分别对应中间的符号为‘+’或者‘*’  
先定义一些变量，做一些基本操作：   
```cpp
string a,b;//两个输入的字符串
char x;//重点，中间那个输入的字符
cin>>a>>x>>b;//输入
int as=a.size();//字符串a的长度
int bs=b.size();//字符串b的长度
if(as>bs)//统一让b成为长的那个字符串
{
	swap(a,b);
	swap(as,bs);//swap函数，交换两个变量
}
int cs=bs-as;//两个字符串的长度差
```

先说说加法的做法：我们可以先用一个for循环使两个字符串**尾**对齐，然后就可以一位一位处理了。  
代码↓   
```cpp
if(cs!=0)//判断两个字符串长度不一样，然后尾对齐
{
	for(int i=as-1;i>=0;i--)//as是短的那个字符串
	{
		a[i+cs]=a[i];//往后错位，错两个字符串位数差
		a[i]='0';//错完就清零（视为数字‘0’）
	}
}//然后就尾对齐了
for(int i=0;i<bs;i++)//从头开始往后错位
{
	if(a[i]=='1'&&b[i]=='1')//如果这一位都是1那和就是2
		cout<<2;
	else
	{
		if(a[i]=='1'||b[i]=='1'//如果只有一个1那就输出1
			cout<<1;
		else//否则就是0
			cout<<0;
	}
}
```
然后是乘法的运算：这个要简单一些，结果的位数就是$as+bs-1$，所以就是先输出一个1，再输出（$as+bs-2$）个0 ~~不难理解~~。  
代码↓
```cpp
//这个没啥可说的吧
cout<<1;
for(int i=0;i<as+bs-2;i++)
	cout<<0;
```


---

## 作者：KadiaNEFU (赞：1)

python就是强啊！~~但我不会python~~  所以我写c++

主要运用一下内容

- 高精度加法

- 高精度减法

- 函数的指针

~~为了装X~~，作者没有偷懒在函数里直接输出结果。

**Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
char p[105];
char *add(char a[],char b[])//加法高精
{
    int len1=strlen(a);
    int len2=strlen(b);
    int num1[105],num2[105],ans[105];
    memset(num1,0,sizeof(num1));
    memset(num2,0,sizeof(num2));
    memset(ans,0,sizeof(ans));
    for(int i=0;i<len1;i++)
        num1[i]=a[len1-1-i]-48;
    for(int i=0;i<len2;i++)
        num2[i]=b[len2-1-i]-48;
    int m=max(len1,len2);
    for(int i=0;i<m;i++)
    {
        ans[i]+=num1[i]+num2[i];
        ans[i+1]+=ans[i]/10;
        ans[i]%=10;
    }
    while(!ans[m]&&m>=1)
        m--;
    for(int i=m;i>=0;i--)
        p[m-i]=ans[i]+48;
    p[m+1]='\0';

    return p;
}
char *mul(char a[],char b[])//乘法高精
{
    int len1=strlen(a);
    int len2=strlen(b);
    int num1[10005],num2[10005],ans[10005];
    memset(num1,0,sizeof(num1));
    memset(num2,0,sizeof(num2));
    memset(ans,0,sizeof(ans));
    for(int i=0;i<len1;i++)
        num1[i]=a[len1-1-i]-48;
    for(int i=0;i<len2;i++)
        num2[i]=b[len2-1-i]-48;
    int m=len1+len2-1;
    for(int i=0;i<len1;i++)
    {
        for(int j=0;j<len2;j++)
        {
            ans[i+j]+=num1[i]*num2[j];
        }
    }
    for(int i=0;i<=m;i++)
    {
        ans[i+1]+=ans[i]/10;
        ans[i]%=10;
    }
    while(!ans[m]&&m>=1)
        m--;
    for(int i=m;i>=0;i--)
        p[m-i]=ans[i]+48;
    p[m+1]='\0';
    return p;
}
int main()
{
    char a[105],b[105];
    char ch;
    cin >> a >> ch >> b;
    char* (*pf)(char*,char*);//选择函数指针
    if(ch=='*')
        pf=mul;//指向乘法
    else
        pf=add;//指向加法
    cout << pf(a,b) << endl ;
    return 0;
}

```


---

## 作者：159号程序员 (赞：0)

这道题有两种解法：Python和C++高精

今天只介绍Python

先上 _AC Code_ ：
```cpp
a = int(input())
c = input()
b = int(input())
if c == '+\r' : #判断是+还是*，要加\r
    ans = a + b
    print(ans)
else :
    ans = a * b
    print(ans)
```
是很简单的，因为Python自带高精

---

## 作者：coolbreeze (赞：0)

 _前置知识_ ：**同底数幂**相**乘**，**底数不变**，**指数相加**，即$a^x*a^y=a^{x+y}$

注意到给定两个整数的位数不超过100位，相乘会导致结果**巨大**，考虑用**字符串**存储。


------------


具体问题，具体分析。考虑到本题要求**实现两种运算**：乘或加，采用**分类讨论**。

首先，方便问题的讨论，设长度较长的字符串为$s1$,长度较短的为$s2$。——使用$swap$实现


------------


$(1)$：当第二行字符为$*$时：

题目说明**两数均为$10$的幂次方的整数**,表明可以**应用公式**：$a^x*a^y=a^{x+y}$~~（初二数学题）~~

输出一个“$1$”以及长度为$s1.length()-s2.length()-2$的“$0$”即可。

对于字符串来说，$.length()$和$.size()$作用是一样的。


------------

$(2)$:当第二行字符为$+$时：

考虑到可能存在**两数指数相同**时，存在**因相加导致首位变为$2$的情况**，同样分两类讨论。

1.**两数指数不同**，将**长字符串**的第$s1.length()-s2.length()-1$位改为$1$，输出即可。


2.**两数指数相同**：将**长字符串**的第$s1.length()-s2.length()-1$位改为$1$，再将**长字符串的首位改为$2$**，输出即可。


------------


Code:([已AC](https://www.luogu.com.cn/record/33303123))


```
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int main(){
	string s1,s2;
	char c;
	cin>>s1>>c>>s2;
	if(s1.length()<s2.length())
		swap(s1,s2);
	int s1l=s1.length(),s2l=s2.length();
	int a=s1l+s2l-1;
	if(c=='*'){
		cout<<"1"; 
		for(register int i=2;i<=a;i++)
			cout<<"0";
		cout<<endl;
	}
	else{
		s1.at(s1l-s2l)='1';
		if(s1l==s2l)
			s1.at(0)='2';
		cout<<s1<<endl;
	}
	return 0;
} 
```
$Tip$：建议在**遍历字符串之前**先开一个变量**保存字符串的长度**：

由于字符串取长的成员函数.$size()$复杂度是$O(n)$，如果一边遍历一边取长会使得**遍历复杂度退化**至$O(n^2)$。

不过C++ 11的size的复杂度貌似已经变成常量级的了...~~（后话，给自己留后路）~~

感谢您的阅读。


---

## 作者：LucasXu80 (赞：0)

这道题难吗？不难啊。

先来读题理一下思路。有三行内容，中间一行一个char就可以了，而上下的数最高可达100位，很容易想到要用string类型：
```cpp
string a,b;
char c;
```
那么怎么运算呢？先从较为简单的乘法看起。

先来看一个小例子：100×10=1000.

很容易发现乘法就是每个乘数后面的0相加，在前面加一个1就可以了。

理解这个很容易，用10的幂来算一算就ok了。

接下来是加法。同样看一个例子：1000+10=1010.

这个怎么办呢？原数都是10的幂，不会产生进位。而原来在哪一位有1，到下面就还是1。而且，不是1就是0。

这段思路比较复杂，我联系代码给大家讲一下：

```cpp
cout<<1;//先输出第一个1
for (int i=1; i<=max(lena,lenb)-min(lena,lenb)-1; i++)
//这里是输出两个1之间的0，大家可以利用竖式推一下~
{
    cout<<0;
}
cout<<1;//输出第二个1
for (int i=1; i<=min(lena,lenb)-1; i++)
//这里输出后面那个1之后的0，就是lena和lenb中间小的那个-1
{
    cout<<0;
}
```
那么这样就完了吗？显然没有。再看一个例子：10+10=20

两个位数一样，显然就会出问题。程序里没有输出2的呀！

如果你前面都理解了，这里就没问题了，你可以去自己写代码了。

如果你还想看一下，来吧：

```cpp
cout<<2;//先输出2
for (int i=1; i<=lena-1; i++)
//lena=lenb,写lena-1和lenb-1都是可以的
{
    cout<<0;//输出后面的0
}
```
好了，接下来就是完整AC代码了~

```cpp
#include <bits/stdc++.h> //万能头文件！！
using namespace std;
int main()
{
    string a,b;
    char c;
    cin>>a>>c>>b;
    int lena=a.length(),lenb=b.length();//获取字符长度备用
    if (c=='*')//如果是乘法，很简单的代码~
    {
        cout<<1;
        for (int i=1; i<=lena+lenb-2; i++)
        {
            cout<<0;
        }
    }
    if (c=='+')//如果是加法
    {
        if (lena!=lenb)//如果不等长，应该是1-0-1-0输出
        {    
            cout<<1;
            for (int i=1; i<=max(lena,lenb)-min(lena,lenb)-1; i++)
            {
                cout<<0;
            }
            cout<<1;
            for (int i=1; i<=min(lena,lenb)-1; i++)
            {
                cout<<0;
            }
        }
        if (lena==lenb)//如果等长，应该是2-0输出
        {
            cout<<2;
            for (int i=1; i<=lena-1; i++)
            {
                cout<<0;
            }
        }
    }
    return 0;//写完这一句，恭喜你AC！
}
```
其余没有comment的部分在前面已经说过了~

这道题重要的是思路，真正的程序实现并不难。

The end

---

## 作者：ShineEternal (赞：0)

作为翻译者想来提供一篇题解和 std。

---


## solution

这应该是一个简化版的高精度。

由于数据是 $10$ 的幂次，所以就只需要考虑位数的问题。分 `+` `*` 两种情况讨论：

- `+`：可以发现，答案中最多只有两个 $1$ 或者一个 $2$。，我们就把两个数字的最高位打上标记就行（别忘了 $2$ 要累加）。然后其他位都是 $0$。

- `*`：只需要第一位输出 $1$，再把两个数字中的 $0$ 都在后面输出即可。


## code

#### 本人代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int a[105];
char s1[150],s2[150],tmp[5];
int main()
{
	
	scanf("%s",s1);
	scanf("%s",tmp);
	scanf("%s",s2);
	int n=strlen(s1);
	int m=strlen(s2);
	if(tmp[0]=='+')
	{
		a[n]=1;
		a[m]=1;
		if(n==m)
		{
			printf("2");
			for(int i=2;i<=n;i++)printf("0");
			return 0;
		}
		for(int i=max(n,m);i>=1;i--)
		{
			printf("%d",a[i]);
		}
	}
	if(tmp[0]=='*')
	{
		printf("1");
		for(int i=1;i<=n-1+m-1;i++)printf("0");
	}
	return 0;
} 
```

#### 官方 std：
```cpp
#include <cstring>
#include <cstdio>

#define maxn 101

char a[maxn], op[2], b[maxn];
int la, lb;

int veci( int a, int b ) { return a>b? a: b; }
int manji( int a, int b ) { return a<b? a: b; }

void nule( int n ) {
	for( int i = 0; i < n; ++i ) printf( "0" );
}
	
int main(void) {
	scanf( "%s%s%s", a, op, b );
	la = strlen( a );
	lb = strlen( b );
	if( op[0] == '+' ) { // zbrajanje
		// poseban slucaj ako su isti brojevi, rezultat je 2 puta odgovarajuca potencija broja 10
		if( la == lb ) { printf( "2" ); nule( la-1 ); }
		else {
			printf( "1" ); nule( veci( la, lb ) - manji( la, lb ) - 1 ); // ako nisu isti rezultat je oblika 1, neke nule, 1, neke nule
			printf( "1" ); nule( manji( la, lb ) - 1 );
		}
	} else { // mnozenje
		printf( "1" );
		nule( la+lb-2 );
	}
	printf( "\n" );
	return 0;
}
```

---

## 作者：宇宙纪念册 (赞：0)

看一下[这道题](https://www.luogu.com.cn/problem/P6467)：

我发现```给定两个位数不超过 100，```

而且```为 10 的幂次方的整数```

用int和long long是一定不可能的

我们可以用到的是一位一位的计算

- 加法：

		 1 0 0 0 0 + 1 0 0 0 = 1 1 0 0 0
 
             
  	所以说，只需要在第一个数的基础上，将某些数字改为1
  	
   为了方便，我们直接加一个判断，```满足第一个数一定大于第二个数，如果数据不是，交换两数位置```
   
- 乘法：

	乘法简单，只需要在1后面添加0
    
   如： 100*10 = 1后面加三个0 = 1000
 
综上，思路已经讲完了

动起手来自己写写吧：

下面是代码（不能抄袭，我已经做了小改动）：


```c
#include <bits/stdc++.h>
using namespace std;
string a1,a3;
char a2;
int main(){
    cin >> a1 >> a2 >> a3;  //读取变量
    //为了计算方便，我们将a1始终大于a3，所以做一个判断
    if(a3 > a1)
    {
        swap(a1,a3);    //交换
    }
    //下面开始分类讨论
    if(a2 == '+'){
        a1[a1.size() - a3.size()] += 1;   //灵活运用字符串，将其中一位改为1
        cout << a1 << endl;
    }
    else{
        cout << 1;    //首位是1
        for(int i=1;i<a1.size()+a3.size()-1;i++)
        {
            cout << 0;    //后面都是0
        }
    }
    //完结
    return 0;
}
```


这是本人的第一篇题解，希望管理员大大能给我通过，QAQ

---

## 作者：__白衣渡江__ (赞：0)

上手鉴定大膜你。

代码超短。

首先：

>位数不超过 $100$

乍一看，显然的高精。

于是上 $Python$。

然后——这就变成了一个普普通通，最简单无比的表达式求值，只不过是分三行输入。

如果是一行，可以直接调用 `eval` 函数。

可惜是三行，于是用 `join` 函数连起来。

注意坑点：这题数据有 `\r`，要切片一遍。

于是就没了，玩 $Python$ 一道超级好的题。

代码：

```py
print(eval(''.join([input()[:-1],input()[:-1],input()])))
```

对就一行。

Over.

感觉清晰，不懂私信。

祝大家AC！

---


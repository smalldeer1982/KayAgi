# [CRCI2006-2007] BARD

## 题目描述

有一个小村子，村子里共有 $n$ 个人，不妨将这 $n$ 个人从 $1$ 至 $n$ 编号，编号为 $1$ 的人是诗人。

每天晚上都会有一些村民围在篝火旁唱歌。

如果某天晚上诗人来了，那么诗人会编一首所有人都没有听过的新歌曲并教给大家唱。在这天晚上**不会唱其他任何歌曲**。

如果某天晚上诗人没来，那么与会者就会唱他们之中**至少有一个人**会唱的**所有歌曲**，并把这些歌曲教给那些来了但不会唱的人。

给定 $m$ 天晚上参与唱歌的村民的编号，初始时村民们什么都不会唱，诗人一首歌也没有写。请输出最终有多少村民会唱诗人写的所有歌。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $ 1 \leq n \leq 100$，$1 \leq m \leq 50$。
- $2 \leq k_i \leq n$，$1 \leq a_{i, j} \leq n$。$1$ 在 $a_{i, j}$ 中至少出现了一次。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [Regional Competition](https://hsin.hr/coci/archive/2006_2007/regional_tasks.pdf) *T1 BARD***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。



## 样例 #1

### 输入

```
4
3
2 1 2
3 2 3 4
3 4 2 1
```

### 输出

```
1
2
4```

## 样例 #2

### 输入

```
8
5
4 1 3 5 4
2 5 6
3 6 7 8
2 6 2
4 2 6 8 1
```

### 输出

```
1
2
6
8```

## 样例 #3

### 输入

```
5
3
2 1 3
2 2 1
4 2 1 4 5
```

### 输出

```
1```

# 题解

## 作者：Utilokasteinn (赞：10)

这道题题目看了半个小时。。题目简介：

有n个人，第1个人是诗人，m个天。如果某天诗人来了，所有人都多会唱一首歌。否则，当天所有人都会互相学习，把当场所以人会的歌都学会。输出第m天后会唱所有歌的人。

简单模拟，如果哪天诗人没来，就记录那天来的人会唱的歌，并互相赋值。否则，当天来的人都新会唱一首歌，并且全部的歌数加1.

这道题不算太难，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,song[101][101],s,k,come[101],v[101];
//n表示n个人，m表示m天 
//song[i][j]如果是1，就是第i个人会唱第j首歌，否则就是不会唱
//s表示最多会唱几首歌，如果诗人来了，s就加1，k表示来到人数 
//come[i]表示来的第i个人
//v[i]如果是1表示这天晚上第i首歌有人会唱，否则就没有人会唱 
int main()
{
	cin>>n>>m;//输入人数和天数 
	for(int i=1,o=0;i<=m;i++,o=0) 
	{//o如果是1，表示诗人来了，否则就是没来 
		cin>>k;//输入k 
		for(int j=1;j<=k;j++)
		{
			cin>>come[j];//输入来的第j个人 
			if(come[j]==1)o=1;//如果诗人来了，就等于1 
		}
		if(o) 
		{
			++s;//如果诗人来了，最多可以唱的歌数加1 
			for(int j=1;j<=k;j++)
				song[come[j]][s]=1;//来的人都会唱这首歌 
		}
		else//如果诗人没来 
		{
			for(int j=1;j<=k;j++)
			    for(int u=1;u<=s;u++)
				    if(song[come[j]][u])v[u]=1;
			//看看第u首歌有没有人会唱，1是有人会唱，0是没人会唱 
			for(int j=1;j<=k;j++)
			    for(int u=1;u<=s;u++)
		            if(v[u])song[come[j]][u]=1;
		    //如果有人会唱第u首歌，则当天来的全部人都会唱第u首歌 
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=s&&song[i][j];j++)//如果有一首不会唱这里就直接退出了
			if(j==s)cout<<i<<endl;//如果第i个人所有的歌都会唱，就输出i 
	return 0;
}
```
最后附上无注释代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,song[101][101],s,k,come[101],v[101];
int main()
{
	cin>>n>>m;
	for(int i=1,o=0;i<=m;i++,o=0) 
	{
		cin>>k;
		for(int j=1;j<=k;j++)
		{
			cin>>come[j];
			if(come[j]==1)o=1;
		}
		if(o) 
		{
			++s;
			for(int j=1;j<=k;j++)
				song[come[j]][s]=1;
		}
		else
		{ 
			for(int j=1;j<=k;j++)
			    for(int u=1;u<=s;u++)
				    if(song[come[j]][u])v[u]=1;
			for(int j=1;j<=k;j++)
			    for(int u=1;u<=s;u++)
		            if(v[u])song[come[j]][u]=1;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=s&&song[i][j];j++)
			if(j==s)cout<<i<<endl;
	return 0;
}
```
谢谢观赏

---

## 作者：InformationEntropy (赞：2)

发现题解没有用位运算解本题的，那就自己来一发吧。

### 题意解析

本题比较绕，共有三个关键点：

- 诗人（1号）如果来了，就教会所有与会者一首新歌。
  
  这就相当于创建一个新集合，并把包括诗人在内的所有与会者加入集合。
  
- 如果诗人没来，那么与会者会各自把自己所学的歌教给其他还不会该歌的与会者。

  相当于每一个与会者都把其他人拉入自己所在的所有集合中。
  
- 最后输出会全部歌曲的人。

  相当于取所有集合的交集并升序输出。
  
### 思路

由题意分析可知，本题模拟集合即可。

~~除 STL 外~~有两种模拟集合的方法：**数组模拟**和**二进制模拟**。

两种方法思想类似：如果元素在集合内，就在相应位置上标 1，否则标 0。



数组模拟的思路及代码与其它题解类似，这里不在赘述，我们来说一说二进制的思想。

我们知道，二进制每位只有 0 和 1 两种情况，所以正好可以表示“在”与“不在”的关系，故每个二进制数可以压缩一个集合。

例如二进制数 $010110011(2)$ 的第 $0,1,4,5,7$ 位为 1，故该集合含有 $0,1,4,5,7$ 五个元素。

下面是一些基本操作：

- 在集合 $s$ 中插入 $k$ （$k\leq30$） 
  ```cpp
  s+=1<<k;
  ```
  其中，这里的 ```<<``` 表示左移，如 1 左移 2 位后会变为 $100(2)$，将 $s$ 加上 1 左移 $k$ 位的值就相当于把 $s$ 从 0 开始第 $k$ 位变为 1。

  
- 判断 $k$ 是否属于集合 $s$（$k\leq30$）
  ```cpp
  if((s>>k)&1)
  ```
  $s$ 右移 $k$ 位后第 0 位恰好为当前的 $k$，我们通过按位与 ```&``` 判断第 0 位是否为 1。
  
  例如有集合 $00010010$，要判断 1 是否在集合内，
  我们把它右移 1 位后变为 $00001001$，此时     ```00001001 & 1 = 1```，故在集合内。

- 求集合 $s$ 和 $t$ 的交集

  这个很简单，按位与 ```s&t``` 即可。
  
- 升序输出集合 $s$ 内所有元素。

  ```cpp
  int sum=0;
  while(s)
  {
      if(s&1) cout << sum << endl;//如果该位为一则输出。
      s>>1; //右移一位。
      sum++;
  }
  
Ok，二进制集合已经掌握了，接下来就剩 A 这道题了。这道题 $n\leq100$，而每个二进制集合最多只能存 30 位，所以我们需要 4 个子集拼成一个整集合。

### Code

```cpp

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef long long ll;
int a[101][5];
/*a第一维表示第几个集合，第二维为拼成该集合的四个子集。
这四个子集分别管理0-29,30-59,60-89,90-119
*/
int t[101];
int v[101];
//如果v[i]=1则表示第i首歌至少有一人会唱
int cnt=0;
inline void build(int k)
{
    cnt++;
    for(int i=1; i<=k; i++)
    {
        a[cnt][t[i]/30]+=1<<(t[i]%30);//插入管理该数的子集中
    }
}
inline void add(int k)
{
    memset(v, 0, sizeof(v));
    for(int i=1; i<=k; i++)
        for(int j=1; j<=cnt; j++)
            if((a[j][t[i]/30]>>(t[i]%30))&1) v[j]=1;//在第j个集合中则v[j]为1
    for(int i=1; i<=cnt; i++)
        if(v[i])//至少有一个人会唱
        {    
            for(int j=1; j<=k; j++)
                if(!((a[i][t[j]/30]>>(t[j]%30))&1)) 
                {
                    a[i][t[j]/30]+=1<<(t[j]%30);//将其它不在集合内的插入集合。
                }
        }
}
inline void work(){
    for(int i=2; i<=cnt; i++){   
        a[1][0]&=a[i][0];
        a[1][1]&=a[i][1];
        a[1][2]&=a[i][2];
        a[1][3]&=a[i][3];
        //子集各自取交集
    }
}
inline void count(int x, int &sum){
    while(x){
        if(x&1) cout << sum << endl;
        x>>=1;
        sum++;
    }
    //输出集合内元素
}
int inp(int &k){
	scanf("%d", &k);
	int flag=0;
	for(int i=1; i<=k; i++){   
	    scanf("%d", &t[i]);
	    if(t[i]==1) flag=1;
	}
	return flag;
   //输入并判断诗人是否来了
}
int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=1; i<=m; i++){
        int k;
        if(inp(k)) build(k);
        else add(k);
    }
    work();
    int sum=0;
    for(int i=0; i<4; i++){
        sum=i*30;//每读完一个子集sum初始化为下一个子集管理的第一个元素
        count(a[1][i], sum);
    }
    return 0;
}
```

最后，关于位运算的温馨提示：它的优先级小于正常的加减乘除，如果不知道优先级的话请加上括号，否则就~~爆零两行泪了~~......

The end


---

## 作者：追梦之鲸 (赞：1)

本蒟蒻的第$004$篇题解。

其实这题并不难，就是一道**纯模拟**。

可是这道题的题目描述说的~~不是人话~~根本听不懂。

所以我来给大家再次解释一下！

### 题目描述

- 有$n$个人，编号为$1$,$2$……,$n$，1号是诗人。

- 一共有$m$天，没天都有$k_i$个人聚在一起，如果1号来了，那么曲数+1，然后那天聚在一起的$k_i$个人都会最新的那首曲子。

- 否则（诗人没来），他们就会把所有当天来的人都教会自己会的曲子，下面我将更详细的讲一下。

```c
（n表示第n首曲子）
第1个人会：1,2。
第2个人会：3,4。
第3个人会：5,6。
第4个人会：1,3。
第5个人会：4,2。
第6个人会：4,6。
第7个人会：5,3。

那么当天来的人都会1,2,3,4,5,6。
```

好了我们再看看样例

### #1

第一天：诗人来了，2号学会了1。

第二天：诗人没来，2号把1教给了3,4号。

第三天：诗人来了，2,4学会了2。

最后：
```
1 1
1 1
1 0
1 1
```

最后答案：
```
1
2
4
```

### #1

第一天：诗人来了，3，5, 4号学会了1。

第二天：诗人没来，5号把1教给了6号。

第三天：诗人没来，6号把1教给了7,8号。

第四天：诗人没来，6号把1教给了2号。

第五天：诗人来了，2,6,8学会了2。

最后：
```
1 1
1 1
1 0
1 0
1 0
1 1
1 0
1 1
```

最后答案：
```
1
2
6
8
```

PS:其实只可以输出1，或者输出答案时先输出1，在从2开始枚举，因为1是诗人，他写的歌自己肯定知道。

### code：

```c
#include<bits/stdc++.h>//无敌头文件
#define ll long long

using namespace std;
inline int rd(){int s=0;char ch=getchar();
   while(ch<'0'||ch>'9') ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s;
}
//快读
bool come,song[101][51],can[101];
//come=1代表诗人来了，否则代表没来
//song[i][j]如果=1，就是第i个人会唱第j首歌，否则就是不会唱
//can[i]如果=1，就是当天晚上有人会唱第i首歌
int n,m,k,man[101],sing;
//man[]代表当玩来了谁，sing代表曲子的总数
int main()
{
	n=rd(),m=rd();
	
	for(int i=1;i<=m;i++)
	{
		k=rd();
		come=0;
		
		for(int j=1;j<=k;j++)
		{
			man[j]=rd();
			
			if(man[j]==1)
			{
				come=1;//诗人来了
			}
		}
		if(come)//如果诗人来了
		{
			sing++;
			
			for(int j=1;j<=k;j++)
			{
				song[man[j]][sing]=1;
			}
        		 //所有人都会唱新的歌
		}
		
		else//如果诗人没来
		{
			for(int j=1;j<=k;j++)
			{
				for(int u=1;u<=sing;u++)
				{
					if(song[j][u])
					{
						can[u]=1;
					}
				}
			}
			//上面是求当晚所有人会唱什么歌，下面是所有人都会唱当晚会唱的歌（窝语文不好，请见谅QAQ）
			for(int j=1;j<=k;j++)
			{
				for(int u=1;u<=sing;u++)
				{
					if(can[u])
					{
						song[man[j]][u]=1;
					}
				}
			}
            	//清空can
           	for(int j=1;j<=sing;j++)
            	{
                	can[j]=0;
            	}
		}
	}
	//dan:统计答案用的
	int dan=0;
	//查找
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=sing;j++)
		{
			if(song[i][j])
			{
				dan++;
			}
		}
		if(dan==sing)
		{
			printf("%d\n",i);
		}
		
		dan=0;
	}
    return 0;
    撒花✿✿ヽ(°▽°)ノ✿
}
```

最后管理大大求过&&[**来玩啊**](https://www.luogu.com.cn/user/361726)

---

## 作者：冰糖鸽子 (赞：1)

本题说的不太清楚

说人话：

- 村子里有 $n$ 个人,编号从 1 到 $n$,有一个人是写歌的(诗人),编号为1
- 最开始诗人还没有写歌，所有村民一首歌也不会
- 每天晚上会有 $k$ 个人去篝火旁唱歌,题目一共需模拟 $m$ 天
- 每天晚上分两种情况：
- - 诗人来了(来的人里有编号是1的人),歌曲数加 $1$ ,那天也去唱歌的村民就直接学会了这首歌
- - 诗人没来，那天去唱歌的人们互相分享学会的歌，比如说有三个人,有四首歌，$A$ 会 $1,2$  , $B$ 会 $2,4$ , $C$ 会 $1,4$  ,那他们一共会 $3$ 首歌,分别是 $1,2,4$ ,分享后 $3$ 个人都会了这 $3$ 首歌
- 最后要求你输出会诗人创作的所有歌曲的所有村民们
- $tips:$ 输出的时候记得按从小到大的顺序输出哦

接下来上代码，思路都在注释里了：

```cpp
#include<bits/stdc++.h>//俗称万能头，得名于包含了大部分C++头文件
using namespace std;//目前不需要知道
int p,d,n,cnt;
//p是people，d是day，表示人数和天数
//n是num，表示某一个晚上在篝火旁唱歌的人数
//cnt是count，表示诗人编了多少歌
bool siso[104][104];
//siso是singsongs，表示每个人会唱的歌
//siso[i][j] = false/0 表示第j个人不会唱第i首歌
//siso[i][j] = true/1表示第j个人会唱第i首歌
int main()//主函数
{
    cin >> p >> d;//输入一共有多少天，村子里有多少村民
    int pp[104];
    //表示每天唱歌的人数
    bool isi = false;
    //判断变量，大循环里用作判断诗人今晚是否来了，小循环里用作判断村民i是否会所有的歌
    for(int i = 1;i <= d;i++)//循环每一天
    {
        isi = false;//将诗人是否初始化为false
        cin >> n;//输入今晚有几个人来唱歌
        for(int j = 1;j <= n;j++)//循环输入来唱歌的每个人
        {
            cin >> pp[j];//输入第j个人的编号
            if(pp[j] == 1)//如果此人是诗人
            {
                isi = 1;//将判断诗人是否来了的变量变为true
            }
        }
        if(isi)//如果诗人来了
        {
            cnt++;//那诗人就会唱一首新歌，cnt加1
            for(int j = 1;j <= n;j++)//遍历来唱歌的每个人
            {
                siso[cnt][pp[j]] = 1;//若遍历到了那这个人就会唱第cnt首歌
            }
        }
        else//如果诗人没来
        { 
            int ps[104];//这是储存所有人会的歌
            for(int j = 1;j <= n;j++)//遍历每个来了的人
            {
                for(int k = 1;k <= cnt;k++)//遍历每首唱过的歌
                {
                    if(siso[k][pp[j]])//如果这个人会
                    {
                        ps[k] = 1;//那这个人就可以教给所有人,将数组设为true.
                    }
                }
            }
            for(int j = 1;j <= n;j++)//仍然是遍历这次是每个人教给所有人他自己会的歌
            {
                for(int k = 1;k <= cnt;k++)//遍历每首歌
                {
                    if(ps[k])//如果有人会
                    {
                        siso[k][pp[j]] = 1;//所有人都会了这首歌
                    }
                }
            }
        }
    }
    for(int i = 1;i <= p;i++)//遍历所有村民
    {
        isi = 1;//将是否全会初始化为true
        for(int j = 1;j <= cnt;j++)//遍历所有歌曲
        {
            if(!siso[j][i])//!:把false变true，true变false.此表达式成立就代表村民i不会歌曲j
            {
                isi = 0;//这个村民有不会唱的歌
                break;//直接跳出一层，后面没必要了
            }
        }
        if(isi)//如果这个村民会唱所有的歌
        {
            cout << i << endl;//输出此人的编号并换行
        }
    }
    return 0;//结束
}
```

码风不压行带空格，写的时候清晰易懂    ~~而且NOIP不管代码长度~~

看在我这么努力写注释的份上,给个赞再走呗 $QWQ$

---

## 作者：JK_LOVER (赞：1)

没有任何难度,只要明白题意就可以了,估计用bitset可能会优一点.但在$n \le 100$ 的数据下直接乱搞.
- 用come纪录来的人.
- 用v纪录唱的歌.
- 用song纪录每个人会的歌
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200
int song[N][N],n,m,cnt;
int come[N],v[N];
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= m;i++)
	{
		memset(come,0,sizeof(come));
		memset(v,0,sizeof(v));
		int k,o=0;cin>>k;
		for(int j = 1;j <= k;j++)
		{
			cin>>come[j];
			if(come[j]==1) o=1;
		}
		if(o==1)
		{
			++cnt;
			for(int j = 1;j <= k;j++)
			{
				song[come[j]][cnt] = 1;
			}
		}
		else 
		{
			for(int j = 1;j <= k;j++)
			for(int u = 1;u <= cnt;u++)
			{
				if(song[come[j]][u])	v[u] = 1;
			}
		
			for(int j = 1;j <= k;j++)
			for(int u = 1;u <= cnt;u++)
			{
				if(v[u]) song[come[j]][u]=1;
			}
		}
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= cnt;j++)
		{
			if(!song[i][j]) break;
			if(j == cnt) cout<<i<<endl;
		}
	}
	return 0;
}
```


---

## 作者：张驰666 (赞：0)

这题数据~~并不是很强~~啊。。。所以只有**入门的难度**而已。。。

题意是非常清晰的，在看完题目之后只要知道几点就可以写了：

1.每次有诗人出现（即1号村民），就必定会增加一首歌，并且这首歌每一个村民在夜晚前都不会，夜晚后只有参与了夜晚的村民会。

2.若没有诗人，那么每一个村民的状态在参与该夜晚后都是一样的。如有4个村民，题目的状态分别是:

```3 0 1 0 0 0 0 1 1```

```2 0 0 1 0 0 0 1 0```

```4 0 1 0 0 0 1 1 1```

```4 0 1 0 1 0 1 0 1```

那么夜晚结束之后肯定都变成：

```6 0 1 1 1 0 1 1 1```

实现此操作只需要记录每一首有村民会的歌，然后再叠加到每一个村民上即可。

3.最后输出的时候，需要输出每一首都会的村民，其实就是会的歌数等于歌总数的村民，所以用```num[1...n][0]```记录每一个村民会的歌总数即可。

有了以上思路，这题就很 _水_ 了（~~**其实本来就很水，暴力也可以过，n才100啊**~~）

## 下面是AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,sum,a[105],known[105],num[105][105];
//k是每次村民数，sum是歌总数； 
//a是数组每次来的村民； 
//known数组是每次没有诗人时至少有一个村民会的歌； 
//num数组记录每一个村民会的歌（num[1...n][0]是对应村民会的歌总数）。 
bool flag;
//flag记录是否有诗人出现 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		flag=false;//初始化flag,flag=false没有诗人,flag=true有诗人 
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			scanf("%d",&a[j]);//读入 
			if(a[j]==1)	flag=true;//有诗人则标记 
		}
		if(flag)//有诗人 
		{
			sum++;//有诗人，那么肯定会多一首歌 
			for(int j=1;j<=k;j++)	num[a[j]][0]++,num[a[j]][sum]=1;//每一个在场的村民都会这首新歌 
		}
		else//无诗人 
		{
			for(int j=1;j<=k;j++)	for(int l=1;l<=sum;l++)	if(num[a[j]][l])	known[l]=1;
			//记录至少有一个村民会的歌 
			for(int j=1;j<=k;j++)	for(int l=1;l<=sum;l++)	if(known[l] && !num[a[j]][l])	num[a[j]][0]++,num[a[j]][l]=1;
			//如果某歌有村民会并且该村民不会，标记。 
		}
	}
	for(int i=1;i<=n;i++)	if(num[i][0]==sum)	printf("%d\n",i);//若总数相同，输出 
}
```


---

## 作者：king_xbz (赞：0)

简单的模拟，数据范围极小，根本不用什么set，乱搞可过QAQ。

开一个二维数组$s$，然后第一维表示歌曲，第二维表示人

那么$f_{i,j}=1$表示第$j$个村民会唱第$i$首歌，反之，$f_{i,j}=0$表示第$j$个村民不会唱第$i$首歌。

对于每个晚上，进行分类讨论：

1，如果有诗人，那么歌曲数量+1，且当晚所有在场的人都会这首歌。最坏复杂度$O(nm)$

代码：

```cpp
if(ff)
{
	cnt++;
	for(fint j=1;j<=ks;j++)
	s[cnt][a[j]]=1;
}
```

2，如果没有诗人，就遍历所有当前有的歌曲，只要有一个人会唱，就让在场所有人都会唱。最坏复杂度$O(n^2m^2)$

代码：

```cpp
for(fint j=1;j<=cnt;j++)
{
	for(fint k=1;k<=ks;k++)
	if(s[j][a[k]])
	{
		for(fint l=1;l<=ks;l++)
		s[j][a[l]]=1;
		break;
	}
}
```

最后遍历每个村民，对于每个村民，遍历每首歌，如果全会唱，就输出TA！最坏复杂度$O(nm)$

```cpp
for(fint i=1;i<=n;i++)
{
	int num=0;
	for(fint j=1;j<=cnt;j++)
	if(s[j][i])
	num++;
	if(num==cnt)
	cout<<i<<endl;
}
```

总体最坏复杂度$O(n^2m^2)$,而数据范围：

- $1≤100，1≤m≤50$。
- $2≤k_i≤n\ 1≤a_{i,j}≤n。1在 a_{i, j}$ 中至少出现了一次。

**显然轻松枚举可过！**

最后，来一发完整代码：

```cpp
int main()
{
//	freopen("A.in","r",stdin);
//	freopen("A.out","w",stdout);
	int n;
	cin>>n;
	int m;
	cin>>m;
	int cnt=0;
	for(fint i=1;i<=m;i++)
	{
		int ks;
		cin>>ks;
		int ff=0;
		for(fint j=1,kk;j<=ks;j++)
		cin>>a[j],a[j]==1?ff++:kk++;
		if(ff)
		{
			cnt++;
			for(fint j=1;j<=ks;j++)
			s[cnt][a[j]]=1;
		}
		else
		for(fint j=1;j<=cnt;j++)
		{
			for(fint k=1;k<=ks;k++)
			if(s[j][a[k]])
			{
				for(fint l=1;l<=ks;l++)
				s[j][a[l]]=1;
				break;
			}
		}
	}
	for(fint i=1;i<=n;i++)
	{
		int num=0;
		for(fint j=1;j<=cnt;j++)
		if(s[j][i])
		num++;
		if(num==cnt)
		cout<<i<<endl;
	}
	return 0;
}
```

祝大家AC愉快！

---


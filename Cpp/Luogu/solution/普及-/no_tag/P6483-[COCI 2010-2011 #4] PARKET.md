# [COCI 2010/2011 #4] PARKET

## 题目描述

有一个 $n$ 行 $m$ 列的方格阵，最外圈的方格是红色的，其余方格是黑色的。

给出红色方格的个数 $r$ 和黑色方格的个数 $b$，请给出一组可行的 $n$，$m$ 的取值。

## 说明/提示

#### 样例 2 解释

输出给出的方格阵如图：其中浅色格子代表红色，深色格子代表黑色。

![](https://cdn.luogu.com.cn/upload/image_hosting/64uk9gbp.png)

#### 数据规模与约定

对于全部的测试点，保证 $8 \leq r \leq 2 \times 10^6$，$1 \leq b \leq 2 \times 10^{6}$。数据保证至少存在一组解。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #4](https://hsin.hr/coci/archive/2010_2011/contest4_tasks.pdf) *T2 PARKET***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。

## 样例 #1

### 输入

```
8 1
```

### 输出

```
3 3```

## 样例 #2

### 输入

```
10 2
```

### 输出

```
4 3```

## 样例 #3

### 输入

```
24 24
```

### 输出

```
8 6```

# 题解

## 作者：sukimo (赞：6)

思路：枚举$n$（从大到小枚，保证$n$尽量大），先判断这个$n$能否置放黑色块（整除判断），再判断以当前$n$置放黑色块的情况，能否置放和数据相等的红色块，如果都满足，则输出然后跳出循环。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int red,black;scanf("%d%d",&red,&black);
	for(int i=black+red;i;i--)
		if(!(black%(i-2))&&((i-1)<<1)+((black/(i-2)+1)<<1)==red){
			printf("%d %d",i,black/(i-2)+2);break;
		}
	return 0;
}
```


---

## 作者：Xeqwq (赞：5)

这道题啊，主要就是用数学分析。  
我们可以得到$n+m$和$n*m$，然后用for循环解方程~~好像原本是能解的但是有点麻烦。~~  
要得到$n+m$,我们可以通过分析最外面的一圈，也就是r：$n+m=1/2r+2$  
这个公式我们可以理解成把外面的一圈分成全等的两个部分然后来补位。   
![图1](https://cdn.luogu.com.cn/upload/image_hosting/ikotbddx.png)   
图中外面那一圈像这样分成了全等的两半，这5格的面积可以对应1A的左边（上边也行）、2A的左边、3A的左边、1B的上边和1C的上边，差1A的上边（或者左边）和1D的上边就可以凑成整个图形的周长的一半，一共要补两个单位的边。  
至于$n*m$嘛，那很好算。$n*m$也就是整个图形的面积，也就是r+b。   
```cpp
int r,b;
cin>>r>>b;
int c=r/2+2;
int area=r+b;
```   
之后，就可以枚举m、n，得到这两个数。   
```cpp
for(int i=c-1;i>0;i--)//i是n，（c-i）是m
{
	if((c-i)*i==area)//如果n*m=面积
	{
		cout<<i<<" "<<c-i;那就输出n和m，按照枚举的顺序可以知道这组就是n的最大值。
		break;
	}
}
```   
谢谢大家~

---

## 作者：过往梦魇之殇 (赞：2)

~~来发一篇题解啦，让我们一起$stO$扶咕咕吧！~~

### [题目传送门](https://www.luogu.com.cn/problem/P6483)

**思路简述：**

一丢丢数学$+$暴力搜

首先，我们随便拿张矩形（$e.g.$  $4*5$）来举例：

$n=4,m=5$时：

| $red$| $red$ | $red$ | $red$ | $red$ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $red$ |$black$  |$black$  |$black$  |$red$  |
|$red$  |$black$  |$black$  |$black$  |$red$  |
|$red$  |$red$  |$red$  |$red$  | $red$ |

我们很容易得到：红色的有$14$块，黑色的有$6$块，总共$20$块

首先，我们可以把红色区域想成两条长+两条宽-四个角

便可以得到$r=2*(n+m-2)$

然后，我们把黑色区域看做一个小的矩形，长为$(m-2)$,宽为$(n-2)$

故面积为$(n-2)*(m-2)$，即黑色的块数为$(n-2)*(m-2)$

最后，得到上面两条，因为题目需要输出$n$最大的一组解，故选择搜$n$，从最大值$(r+4)/2$开始搜，一直到$1$为止（注意$n$不能取$r/2+2$，因为$m≥1$）

所以就利用第一条把$m$求出来，再去验证第二条

如果两条都满足，那么输出$n$和$m$，结束即可！

思路完毕。

**代码展示：**

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
int r,b;
int main()
{
	r=read();
	b=read();
	for(re int n=r/2+1;n>=1;--n){
		int m=r/2+2-n;
		if((n-2)*(m-2)==b){
			write(n);
			printf(" ");
			write(m);
			puts("");
			exit(0);
		}
	}
    return 0;
}
```
###### ~~这道橙题还是简单的吧！一遍切！~~

> $Thanks$ $For$ $Watching!$

---

## 作者：AKakA (赞：2)

本题题意简单，就是直接上思路吧：

1.已给出r块红色，b块黑色，则知道总块数a为r+b

2.枚举行数h和列数l（因为为矩形，所以h和l为总块数a的因数）

```cpp
for(int i=2;i*i<=a;i++)          //只用找最小的一半因数
{
	if(a%i==0)            //判断
	{
		h=a/i;        //题意：如果有多组解，输出行数最大的一组
		l=i;          
	}
}
```

3.此时已找出h和l，判断可不可行

判断r：因为r全在边上，所以只需判断$(h+l)\times2-4$等不等于r（ 四个角会重复算一遍，所以要$-4$）

判断b；因为b全在内部，所以只判断$(h-2)\times(l-2)$等不等于b

![](https://cdn.luogu.com.cn/upload/image_hosting/64uk9gbp.png)
```cpp
if((h-2)*(l-2)==b&&((h+l)*2-4)==r)
{
	cout<<h<<" "<<l<<endl;
	return 0;
}
```

完整AC代码：
```cpp
#include <bits/stdc++.h> 
using namespace std;

int a,r,b;
int h,l;

int main()
{
	cin>>r>>b;
	a=r+b;
	for(int i=2;i*i<=a;i++)
	{
		if(a%i==0)
		{
			h=a/i;
			l=i;
			if((h-2)*(l-2)==b&&((h+l)*2-4)==r)
			{
				cout<<h<<" "<<l<<endl;
				return 0;
			}
		}
	}
} 
```




---

## 作者：_Clown_ (赞：1)

这是一道简单题。

我们可以枚举长，然后通过周长算出宽，公式易证：
$$b=(C+4-a-a)/2;$$

然后算一算里面的面积：
$$S=(a-2)*(b-2)$$

验证一下S，如果正确，就跳转输出即可。

代码不到20行，请自己敲一敲，锻炼**手指**。

---

## 作者：冰糖鸽子 (赞：1)

本题普及-个人感觉还是很水的，思路如下

先得出总格数，枚举n，循环里求m，之后判断.具体的都在注释里了

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int rn,bn;//rednum,blacknum
    cin >> rn >> bn;//输入不解释
    int al = rn + bn;//加起来就是这个矩形一共多少块
    for(int i = al;i >= sqrt(al);i--)//i越大越好
    {//从1*al开始，sqrt是因为矩形有对称的
        if(al % i != 0)//不可能有小数块
        {
            continue;//下一次循环，不是跳出循环
        }
        int j = al / i;//另一边长：j
        int j2 = j - 2;
        int i2 = i - 2;//黑色是一个矩形，可以计算(i - 2)*(j - 2),但输出和循环还要用i，j，所以定义替代变量
        if(j2 < 0)//开始时j可能等于1，减2就成了-1
        {
            j2 = 0;//强制变0
        }
        if(i2 < 0)
        {
            i2 = 0;//同上,避免某些神奇的数据(比如1,0),不过本题不加21~24也行
        }
        if(i2 * j2 == bn)//如果黑色块数正好,那红色就不用算了
        {
            cout << i << ' ' << j;//输出i,j,不要输出反了
            return 0;//直接结束
        }
    }
    //数据已保证存在一组解，也就是说不会运行到这里
    return 0;
}
```

码风是不压行带空格，写的时候比较清晰

最后，点个赞再走呗QwQ

---

## 作者：Inlay1158 (赞：0)

这道题目显然是一道枚举的题目，由题意得：$r=2(m+n)-4,b=(m-2)(n-2)$，其中，$m$ 和 $n$ 是其中一组合法的解。可以先枚举 $m$，由 $r=2(m+n)-4$ 得 $n=r/2+2-m$，取值范围是 $m<r/2+2$，然后判断 $(m-2)(n-2)$ 是否等于 $n$ 即可。  
```cpp
#include<cstdio>
#define ll long long
using namespace std;
FILE *fin, *fout;
inline int read(ll &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(ll x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
inline int write(char c) {
	return fputc(c, fout), 1;
}
template<class T, class... Args> inline int write(T x, Args... args) {
	return write(x) + write(args...);
}
ll r, b;
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6483.in", "rb");
	fout = fopen("P6483.out", "wb");
	#endif
	read(r, b);
	for (ll i = 1; r + 4 > 2 * i; ++i) {
		ll j = r / 2 + 2 - i;
		if ((i - 2) * (j - 2) == b)
			return 0 & write(j, ' ', i);//注意先输出n
	}
	return 0;
}
```

---

## 作者：宇宙纪念册 (赞：0)

- [这道题](https://www.luogu.com.cn/problem/P6483)

- 思路：

首先，求出```总格数```，也就是 ```r+b=l```

其次，将```l```拆分成```两个数的乘积```，不能忘记```n+m==r/2+2```

因为，不能拆分成```1*16=16```这种，1不可能成为其中的一边，这样就没有另一种颜色了

- 代码：（部分说明，见代码）
```
#include <bits/stdc++.h>
using namespace std;
int r,b,l,ans,s,p;
int main()
{
    cin >> r >> b;
    l = r + b; // 总格数
    for(int i = 2; i <= l; i++)
        if(l%i==0&&i>=s&&l/i>2&&i+l/i==r/2+2)  s=i,p=l/i; //只要他是目前最大的，就记录下来
    cout << s << " " << p;  // 最后输出的就是最大的啦
    // The end
    return 0;
}
```


---

## 作者：KadiaNEFU (赞：0)

 我们知道红色和黑色的方块数为r，b，那么总的方块数为（a+b），且由矩形面积可知（a+b）=n×m。我们需要最大的一个n，我们就从最大的可能的n开始循环check这个n对不对，因为m最小就要是3，所以n可以从（a+b）/3开始遍历，到3为止。其中对于每一组判断其中是否符合r，b就行了。
 
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int r,b;
    cin >> r >> b;
    int n,m;
    for(int i=(r+b)/3;i>=3;i--)//遍历查找
    {
        if((r+b)%i==0&&(i-2)*((r+b)/i-2)==b)//判断
        {
            n=i;//行
            m=(r+b)/i;//列
            break;//找到了就break出循环
        }
    }
    cout << n << " " << m << endl ;
    return 0;
}

```






---


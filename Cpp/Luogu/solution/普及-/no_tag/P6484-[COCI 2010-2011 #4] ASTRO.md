# [COCI 2010/2011 #4] ASTRO

## 题目描述

有两颗星星，他们各自每隔一段时间都会闪烁一次。

现在，知道了两个星星第一次闪烁的时间和每颗星星两次闪烁的间隔。你需要求出何日何时两颗星星首次同时闪烁。

**注意：刚开始闪烁的那一天为星期六，`00:00` 为一天的第一分钟。**

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证时间间隔为整小时数，即 $MM=0$；例如 `13:00`。
- 对于 $100\%$ 的数据，保证 $0\le HH\le 23$，$0\le MM\le 59$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #4](https://hsin.hr/coci/archive/2010_2011/contest4_tasks.pdf) *T3 ASTRO***。

## 样例 #1

### 输入

```
02:20
13:00
05:50
01:00```

### 输出

```
Saturday
14:00```

## 样例 #2

### 输入

```
02:20
23:28
00:40
23:50```

### 输出

```
Never```

## 样例 #3

### 输入

```
23:19
10:19
02:42
09:11```

### 输出

```
Thursday
00:31```

# 题解

## 作者：L_zaa_L (赞：8)

# 分析
这道题题意十分简单，就是求什么时候这两个数相等。毕竟只算一周的时间，所以最多就只有 $7*24*60=10,080$ 种情况，暴力完全可以。

就从发现的时候开始模拟，哪个时间小，就寻找下一次出现的时间，知道两个数相等即可。

# Code
```
#include<bits/stdc++.h>
using namespace std;
int fh1,fm1,fh2,fm2,jh1,jm1,jh2,jm2;
string s[10]={"Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"};//每个星期的英文
int main(){
	//freopen("star.in","r",stdin);
	//freopen("star.out","w",stdout);
	scanf("%d:%d",&fh1,&fm1);
	scanf("%d:%d",&fh2,&fm2);
	scanf("%d:%d",&jh1,&jm1);
	scanf("%d:%d",&jh2,&jm2);//输入
	int t1,t2,j1,j2;
	t1=fh1*60+fm1;//计算第一颗星星出现的时间
	t2=fh2*60+fm2;//计算第二颗星星出现的时间
	j1=jh1*60+jm1;//计算第一颗星星出现的间隔
	j2=jh2*60+jm2; //计算第一颗星星出现的间隔
	bool flag=0;
	for(int i=1;i<=10080;i++){//只用模拟这么多遍，毕竟只有那么多情况。
		if(t1==t2){//如果两个数相等，就退出
			flag=1;//标记，看有没有重合过
			break;
		}
		else if(t1<t2) t1+=j1;
		else t2+=j2;//算下一次闪烁的时间
	}
	if(!flag){
		cout<<"Never";
		return 0;
	}
	cout<<s[t1/1440%7]<<endl;//输出星期
	if(t1%1440/60<10)//要判断要不要零
		cout<<0;
	cout<<t1%1440/60<<":";
	if(t1%60<10)
		cout<<0;//同上
	cout<<t1%60;
	return 0;
}
```

---

## 作者：SingularPoint (赞：5)

### 题目大意
给出两颗星星分别在星期六第一次闪烁的时间和每两次闪烁的时间间隔，问两颗星星**是否能同时闪烁**，如果能，输出第一次同时闪烁的**星期**和**时间**。
### 分析
明显的模拟~ ┐（—▽—）┌

计算同时闪烁的时间很简单，先把两颗星的数据都转换成分钟单位（便于计算），然后**令所处时间靠后的星星加上下次闪烁的时间间隔**，以此类推，**直到两颗星所处时间相同**，所得到的就是第一次同时闪烁的时间。然后再把分钟数转化成 天：时：分 的形式就可以了~（要注意的是因为第一次闪烁是在星期六，所以最后的天数对 7 取模后得到的天数是从星期六开始的）

但是仅仅这样还不够，题目上还有要求：【如果两颗星星永远不会同时闪烁，则输出`Never`。】由此，我们必须想到一种方法来判断所给的数据是否能够使星星同时闪烁。

在这里，我先给出一个**结论**：（以下定义的所有时间变量单位都为 $min$）

如果我们设两颗星星开始闪烁的时间分别为：$S_1$、$S_2$，$\Delta S=|S_1-S_2|$，两颗星星每两次闪烁时间间隔分别为：$x_1$、$x_2$，那么，若两颗星星可以同时闪烁，则一定有：$\gcd(x_1,x_2)\mid\Delta S$。

接下来是证明过程：

**证明**

若两颗星星能够同时闪烁，设它们第一次同时闪烁的时间为 $k$，则一定有$x_1\mid (k-S_1)$，$x_2\mid (k-S_2)$。

所以有 $\gcd(x_1,x_2)\mid (k-S_1)$，$\gcd(x_1,x_2)\mid (k-S_2)$。

可得 $\gcd(x_1,x_2)\mid [(k-S_1)-(k-S_2)]$，整理得：$\gcd(x_1,x_2)\mid\Delta S$。

证明结束。

有了上面的分析和证明，相信代码只是短短的时间问题~

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int ah,am,bh,bm,xh,xm,yh,ym;
int s1,s2,x1,x2;
char h;
int gcd(int a,int b)
{return b?gcd(b,a%b):a;}
int main()
{
	scanf("%d%c%d",&ah,&h,&am);
	scanf("%d%c%d",&bh,&h,&bm);
	scanf("%d%c%d",&xh,&h,&xm);
	scanf("%d%c%d",&yh,&h,&ym);
	s1=am+ah*60;//全部转换为分钟便于计算 
	s2=bm+bh*60;
	x1=xm+xh*60;
	x2=ym+yh*60;
	int tool=s1>s2?s1-s2:s2-s1;
	if(tool%gcd(x1,x2)!=0){//判断能否同时闪烁 
		printf("Never\n");
		return 0;
	}
	while(s1!=s2){
		if(s1<s2) s1+=x1;
		if(s2<s1) s2+=x2;
	}
	int day=s1/1440;
	int hour,minute=s1%60;
	s1%=1440;
	hour=s1/60;//将第一次同时闪烁的时间转化为 天：时：分 的形式 
	day%=7;
	if(!day) printf("Saturday\n");//第一次闪烁是在星期六，所以取余后0代表星期六 
	if(day==1) printf("Sunday\n");//以此类推 
	if(day==2) printf("Monday\n");
	if(day==3) printf("Tuesday\n");
	if(day==4) printf("Wednesday\n");
	if(day==5) printf("Thursday\n");
	if(day==6) printf("Friday\n");
	if(hour<10) printf("0");
	printf("%d:",hour);
	if(minute<10) printf("0");
	printf("%d",minute);
	return 0;
}
```
完结撒fa~

---

## 作者：Talanton_Cerydra (赞：3)

[P6484](https://www.luogu.com.cn/problem/P6484)

## 主要思路：暴算

~~此题难度最多也黄题吧~~

首先建立一个结构体存储4个时间点，包含小时、分钟和总的分钟数：

```cpp
struct tim
{
    int h,m,sum;//sum为总分钟数
}a,b,c,d;//四个时间点
```

读入数据后算出每个时间点的总分钟数,再来判断是否可以同时闪烁.

**原理:**

设两个每次增加的时间(以分钟计)分别为${x}_{1}$和${x}_{2}$,

两个原有的时间(以分钟计)分别为${s}_{1}$和${s}_{2}$,

再定义$r$=${s}_{1}>{s}_{2}?{s}_{1}-{s}_{2}:{s}_{1}-{s}_{2}+60\times24$ (即为时间差)

则有：如果$r$不能被$gcd({x}_{1},{x}_{2})$整除,则两颗星永远不会同时闪烁.

~~具体原因过于简单,自己推理即可得出~~

然后是暴力,用$do-while$循环找出那个相同的时间点(整个过程都是以分钟数运算)

接着算出天数,判断星期并输出:(注意开始是星期六)

```cpp
    //t是总天数
    t%=7;
    switch(t)//判断星期
    {
        case 0://由于是星期六开始,t=0的时候是星期六
        printf("Saturday");
        break;
        //以下同理
        case 1:
        printf("Sunday");
        break;
        case 2:
        printf("Monday");
        break;
        case 3:
        printf("Tuesday");
        break;
        case 4:
        printf("Wednesday");
        break;
        case 5:
        printf("Thursday");
        break;
        default:
        printf("Friday");
        break;
    }
```

最后以与输入相同的格式输出时间,因此我们可以简便地求出小时和分钟(先定义为$aa$和$bb$)

然后要特判$aa<10$或$bb<10$的情况,并按情况输出前导$0$,具体如下:

```cpp
     if(aa<10)//小于10就加前导0
    {
        printf("0");
    }
    printf("%d:",aa);
    if(bb<10)//同理
    {
        printf("0");
    }
    printf("%d",bb);
```

## 这样就可以$AC$此题辣~

### 代码:(可能有点乱,勿喷)

```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
struct tim//存储时间
{
    int h,m,sum;//sum为总分钟数
}a,b,c,d;//四个时间点
int q,p,t,aa,bb;
int GCD(int x,int y)//求最大公约数,原理相信大家都知道
{
    if(y==0)
    {
        return x;
    }
    else
    {
        return GCD(y,x%y);//经典的求法
    }
}
bool yes(int x,int y)//判断是否能同时闪烁
{
    if(y%x!=0)//如果不能整除就直接输出Never
    {
        return true;
    }
    else
    {
        return false;
    }
}
int main()//主函数
{
    scanf("%d:%d%d:%d%d:%d%d:%d",&a.h,&a.m,&b.h,&b.m,&c.h,&c.m,&d.h,&d.m);//输入数据
    a.sum=a.h*60+a.m;
    b.sum=b.h*60+b.m;
    c.sum=c.h*60+c.m;
    d.sum=d.h*60+d.m;
    //算分钟数
    if(a.sum>b.sum)
    {
        q=a.sum-b.sum;
    }
    else
    {
        q=a.sum+60*24-b.sum;
    }
    //算时间差
    p=GCD(c.sum,d.sum);//求最大公约数
    if(yes(p,q))//如果无法同时闪烁
    {
        printf("Never");
        return 0;//直接结束
    }
    //以下开始暴力求时间
    do
    {
    //看哪个小就给哪个加时间
        if(a.sum>b.sum)
        {
            b.sum+=d.sum;
        }
        else
        {
            a.sum+=c.sum;
        }
    }
    while(a.sum!=b.sum);//直到两个数相等为止
    t=a.sum/(60*24);//求天数
    a.sum%=60*24;//求近一天内的总分钟数
    t%=7;//求出星期
    switch(t)//判断星期
    {
        case 0://由于是星期六开始,t=0的时候是星期六
        printf("Saturday");
        break;
        //以下同理
        case 1:
        printf("Sunday");
        break;
        case 2:
        printf("Monday");
        break;
        case 3:
        printf("Tuesday");
        break;
        case 4:
        printf("Wednesday");
        break;
        case 5:
        printf("Thursday");
        break;
        default:
        printf("Friday");
        break;
    }
    aa=a.sum/60;//求出最终小时
    bb=a.sum%60;//求出最终分钟
    printf("\n");//别忘了换行
    if(aa<10)//小于10就加前导0
    {
        printf("0");
    }
    printf("%d:",aa);//输出小时
    if(bb<10)//同理
    {
        printf("0");
    }
    printf("%d",bb);//输出分钟
    return 0;
}
```

### 莫抄袭,[没了AC记录](https://www.luogu.com.cn/discuss/show/61884?page=1),空悲切！

---

## 作者：liswill (赞：1)

## 题意
给两个星星闪烁时间点和周期，输出两点同时的 **时间** 和 **星期** ，若永远不会同时闪烁，输出 `never` 。

## 思路
模拟题。

使用循环将时间点存入两个数组中，依次递推存入有限时间点。最后找到第一个相同的值即可。

这里有一个结论，若起始时间为 $a_1$ ， $a_2$ ，间隔为 $l_1$ ， $l_2$ ，则一起闪烁的时间就满足  $\gcd(a_1 , a_2)\mid \Delta l $        
( 证明过程为周期的简单应用，不赘述了。 )


#### 难点
时间的枚举思路要清晰，先将给的时间点和间隔转化为整型数值，再存入数组。

输出保留前导 0 ，需要细心。

## 代码

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define S(a) scanf("%d",&a)//输入 int
#define RE return
#define ll long long
 
using namespace std;
 
char tmp;//输入冒号，也可以写成 scanf("%d:%d",&t1,&t2)
int a1,a2,l1,l2,t1,t2;// a1 , a2 为初始时间;l1 , l2 为时间间隔
ll a[1000010],b[1000010];//存放时间的数组
 
int main()
{
    S(t1),scanf("%c",&tmp),S(t2);a1=t1*60+t2,t1=0,t2=0;
    S(t1),scanf("%c",&tmp),S(t2);a2=t1*60+t2,t1=0,t2=0;
    S(t1),scanf("%c",&tmp),S(t2);l1=t1*60+t2,t1=0,t2=0;
    S(t1),scanf("%c",&tmp),S(t2);l2=t1*60+t2,t1=0,t2=0;
    //输入并转化为一个整数
    a[0]=a1;b[0]=a2;
    FOR(i,1,1005)
    {
        a[i]=a[i-1]+l1;
        b[i]=b[i-1]+l2;
    }//存入时间
    ll time;
    bool flag=0;//是否存在相同时间
    FOR(i,1,1000)
    {
        FOR(j,1,1000)
        {
            if(a[i]==b[j])//存在
            {
                time=min(time,a[i]);
                flag=1;//标记存在答案
                break;
            }
        }
    }
    if(!flag)//不存在答案
    {
        printf("Never\n");
        RE 0;
    }
    string day[10]={"Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"};//星期的字符串数组，注意顺序
    int dp=time/1440;
    cout<<day[dp%7]<<endl;//注意！过的天数有可能大于7，所以要%7
    time=time-dp*1440;//剩余小于1440min的时间
    if(time/60<10)   printf("0"); //剩余小时小于 10 ，输出前导 0
    printf("%d:",time/60);
    if(time%60<10)   printf("0"); //剩余分钟小于 10 ，输出前导 0
    cout<<time%60;
    printf("\n");
    RE 0;
}

---

## 作者：_Clown_ (赞：1)

# Description
|题号|出处|参考难度|$AC$时间及记录|
| :----: | :----: | :----: | :----: |
|$\texttt{洛谷P6484}$|$\texttt{COCI2010-2011}$|$\texttt{洛谷难度:普及-}$|[$\texttt{On 2020/12/04}$](https://www.luogu.com.cn/record/43150776)|
# Solution
这道题目应该不难吧。

首先我们很容易想到我们要将$H:M$的形式转换成分钟，这样会好计算很多。

然后我们判断一下无解，这个其他的题解证明过了，这里就不再给出证明。

即：$abs(T1-T2)\%Gcd(T3,T4)==0?Can:Can't$

其次，我们不断将时间少的往前推，直至二者相等。

最后再换成题目要求的输出形式即可。
# Code
```cpp
#include<bits/stdc++.h>
#define BetterIO ios::sync_with_stdio(false)
#define Fr(i,A,B,X) for(i=A;i<=B;i+=X)
#define Reg register
#define Ll long long
#define Et exit(0)
#define Iln inline
#define Vod void
#define In int
#define MAX 1001
using namespace std;
Iln In Gcd(In A,In B)
{
    return B==0?A:Gcd(B,A%B);
}
In main(Vod)
{
    BetterIO;
    Reg char C;
    Reg In H1,H2,H3,H4;
    Reg In M1,M2,M3,M4;
    cin>>H1>>C>>M1;
    cin>>H2>>C>>M2;
    cin>>H3>>C>>M3;
    cin>>H4>>C>>M4;
    Reg In T1,T2,T3,T4;
    T1=H1*60+M1;/*换算成分钟计算*/
    T2=H2*60+M2;/*换算成分钟计算*/
    T3=H3*60+M3;/*换算成分钟计算*/
    T4=H4*60+M4;/*换算成分钟计算*/
    if(abs(T1-T2)%Gcd(T3,T4))/*判断是否无解*/
    {
        cout<<"Never"<<endl;
        return 0;
    }
    while(T1!=T2)/*判断是否同时闪烁*/
    {
        switch(T1<T2)/*时间较少的就再往上加*/
        {
            case true:T1+=T3;break;
            case false:T2+=T4;break;
        }
    }
    switch(T1/1440%7)/*T1/1440%7就是天数*/
    {
        case 0:cout<<"Saturday"<<endl;break;
        case 1:cout<<"Sunday"<<endl;break;
        case 2:cout<<"Monday"<<endl;break;
        case 3:cout<<"Tuesday"<<endl;break;
        case 4:cout<<"Wednesday"<<endl;break;
        case 5:cout<<"Thursday"<<endl;break;
        case 6:cout<<"Friday"<<endl;break;
    }
    T1%=1440;
    if(T1/60<10)/*T1/60就是小时*/
    {
        cout<<0;
    }
    cout<<T1/60;
    cout<<':';
    if(T1%60<10)/*T1%60就是分钟*/
    {
        cout<<0;
    }
    cout<<T1%60<<endl;
    return 0;
}
```

---

## 作者：dead_X (赞：1)

## 前言
恶心的输出

~~C O C I 传 统 艺 能~~

建议难度PJ-
## 思路简述
### 1 有解的情况
注意到闪烁的时间间隔很短，所以如果有解解一定在一个很小范围中。

$Proof:$

假设闪烁的时间间隔为 $t_1,t_2$ ，一个可行的解为 $t$ 。

那么 $t\%(t_1\times t_2)$ 一定也可以，因为这之间第一颗星闪烁了 $t_2$ 次，第二颗星闪烁了 $t_1$ 次。

$t_1\times t_2\leq2400\times2400=5.76\times10^6$ ，在枚举范围内。

~~然后我就懒得打exgcd了~~

我就直接打了一个便于新手理解的暴力。

```
while(x!=y) if(x<y) x+=z; else y+=w;
```

### 2 无解的情况
请自行数学推导，这个小学一年级就应该会。

结论是 $(t_1,t_2)\nmid (s2-s1)$ ，其中 $(x,y)$ 代表 $x$ 和 $y$ 的公约数。
### 3 代码实现
恶 心 就 完 了
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,b,c,d,e,f,g,h;
	scanf("%d:%d",&a,&b);
	scanf("%d:%d",&c,&d);
	scanf("%d:%d",&e,&f);
	scanf("%d:%d",&g,&h);
	int x=60*a+b,y=60*c+d,z=60*e+f,w=60*g+h;
	int i=__gcd(z,w),j=x-y;
	if(j<0) j+=1440;
	if(j%i) return 0&puts("Never");
	while(x!=y) if(x<y) x+=z; else y+=w;
	//Day
	int t=x/1440;
	t%=7,x%=1440;
	if(t==0) puts("Saturday");
	if(t==1) puts("Sunday");
	if(t==2) puts("Monday");
	if(t==3) puts("Tuesday");
	if(t==4) puts("Wednesday");
	if(t==5) puts("Thursday");
	if(t==6) puts("Friday");
	//Time
	if(x/60<10) printf("0%d:",x/60); else printf("%d:",x/60);
	if(x%60<10) printf("0%d",x%60); else printf("%d",x%60);
	return 0;
}
```

---

## 作者：yxy666 (赞：0)

码了接近一个小时，终于把这道题目 $AC$ 了。我调了好久啊！

题意:给我们两颗星星初始的闪烁时间和闪烁的间隔时间，让我们求两颗星星第一次同一时刻闪烁的时候是星期几（初始是星期六），然后输出以 $HH:MM$ 的形式输出这个时刻。

想法：首先用 $HH:MM$ 的方法算太麻烦了，我就把所有的时刻全部化成分钟。然后我在求出第一颗星星所有的闪烁时间（ $emm$ , 也不能说是所有，但是求出答案是绰绰有余了），存下来，然后记录一下这是第几周，星期几。再我开始求第二颗星星的闪烁时间，然后判断一下，如果有相同的话，那就直接输出，完事了啊。

$code $ 信息：   长度（加注释）：$3381$  行数 ：$110$

$code$ :
```cpp
#include<bits/stdc++.h>
#define TT 1440  //一天中有1440分钟，过了就是下一天 
using namespace std;
struct yxy{
	int x[1005],size;bool flg;
}a[1505];//用于存i时刻有size不同的答案，用于存第一颗星星，然后在第二颗星星哪儿对比 
int first,second,first_star,second_star,cnt,ans=6; //first表示第一颗星星闪烁间隔，second表示第二颗星星闪烁间隔， first_star表示第一颗星星初始闪烁时间，second_star表示第一颗星星初始闪烁时间
string answer[10]={"Never","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"};//用于存第一个答案 
void read(){
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first_star=(ch-'0');
	ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first_star=first_star*10+(ch-'0');
	first_star*=60;
	ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first_star+=(ch-'0')*10;
	ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first_star+=ch-'0';
}//emm,请忽略这一段玩意（我说这是快读你信吗）
void read2(){
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second_star=(ch-'0'); 
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second_star=second_star*10+(ch-'0');
	second_star*=60;
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second_star+=(ch-'0')*10;
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second_star+=ch-'0';
}//emm,请忽略这一段玩意（我说这是快读你信吗）
void read3(){
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first=(ch-'0');
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first=first*10+(ch-'0');
	first*=60;
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first+=(ch-'0')*10;
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	first+=ch-'0';
}//emm,请忽略这一段玩意（我说这是快读你信吗）
void read4(){
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second=(ch-'0');
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second=second*10+(ch-'0');
	second*=60;
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second+=(ch-'0')*10;
	 ch=getchar();
	while(!isdigit(ch))ch=getchar();
	second+=ch-'0';
}//emm,请忽略这一段玩意（我说这是快读你信吗） 
void check(){
	ans=6;int step=0;//初始为星期六吗 ，step表示第几周
	for(int i=1;i<=50005;i++){
		first_star+=first;//下一次闪烁时间 
		if(first_star/TT>0)ans++;//到下一天了 
		if(ans>7)ans=1,step++;//1-7不停循环，因为没有星期八 
		first_star%=TT;//干掉多余的 
		for(int j=1;j<=a[first_star].size;j++)
		if(a[first_star].x[j]==step*10+ans){cnt=first_star;return;}
		//对比，如果有相同的就用cnt记下时间，结函数 
	}
}//这个函数在求第二个星星的闪烁时间，然后与第一个星星进行对比 
void make_p(){
	int step=0;//step表示第几周 
	for(int i=1;i<=50005;i++){
		second_star+=second;//下一次闪烁时间 
		if(second_star/TT>0)ans++;//到下一天了 
		if(ans>7)ans=1,step++;//1-7不停循环，因为没有星期八 
		second_star%=TT;//干掉多余的 
		a[second_star].x[++a[second_star].size]=step*10+ans;//存下来 
	}
}//这个函数是在求第一个星星的闪烁时间 
int main(){
	read();read2();read3();read4();//输入 
	make_p();check();//代码核心 
	if(cnt==0){
		cout<<answer[0]<<endl;
		return 0;
	}//特判，不可能相同的情况 
	cout<<answer[ans]<<endl;
	if(ans!=0){
		if(cnt/60<10)printf("0%d:",cnt/60);
		else printf("%d:",cnt/60);
		if(cnt%60>=10)printf("%d\n",cnt%60);
		else printf("0%d\n",cnt%60);
	}//输出 
	return 0; 
}
```


---


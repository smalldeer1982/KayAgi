# [COCI 2010/2011 #6] RAZINE

## 题目描述

给定一个长度为 $n$ 的序列，你可以将某些各减去一个数，使得整个序列**严格递增**。

你需要求出所有减去的数的总和的最小值。

例如：有一个长度为 $3$ 的序列 $5,5,5$；最优方案是 $5-2,5-1,5$ 即 $3,4,5$。这样所有减去的数的总和是 $2+1=3$，为最小值。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 100$，序列中的数字皆为不大于 $20000$ 的正整数。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #6](https://hsin.hr/coci/archive/2010_2011/contest6_tasks.pdf) *T3 RAZINE***。

## 样例 #1

### 输入

```
3
5
5
5```

### 输出

```
3```

## 样例 #2

### 输入

```
4
5
3
7
5```

### 输出

```
6```

# 题解

## 作者：追梦之鲸 (赞：7)

本蒟蒻的第$002$篇题解。

[经典回顾P6490](https://www.luogu.com.cn/problem/P6490)

### 思路

这道题是一个很简单的贪心题。

直解从$n-1$倒序枚举即可。

### 详解

- 首先这到题必须严格递增，也就是没个数**必须**比下个数小，比上个数大，**相等不行**！

- 说一下为什么从$n-1$倒序枚举，而不从$1$正序枚举？对于不懂这类的同学（比如窝），可能窝给出一组数据你们大概就能理解：
```
5 6 7 4
```
这组数据用刚才正序枚举的思想的话答案是0，实际答案是12。

可能还有同学不懂，那么下面我会更详细的解说：

这题说需要求出所有减去的数的总和的**最小值**，所以必须保证最后面的数最大（你可以理解为最后的数不变）。

然后从第$n-1$个数起，如果第$i$个数比第$i+1$个数大，第$i$个数就等于第$i+1$个数-1。

还有这里介绍一下可能对你有帮助的**register int**和**快读快输**

[链接](https://blog.csdn.net/Liukairui/article/details/81115041)
- **register int**

这个register int中的register 表示使用cpu内部寄存器（寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件）的变量，而平时的int是把变量放在内存中，存到寄存器中可以加快变量的读写速度。

- **快读与快输**

[链接](https://blog.csdn.net/weixin_44577381/article/details/86567132)

模板
```c
//快读
inline int read()
{
	int X=0; bool flag=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') flag=0; ch=getchar();}
	while(ch>='0'&&ch<='9') {X=(X<<1)+(X<<3)+ch-'0'; ch=getchar();}
	if(flag) return X;
	return ~(X-1);
}
//快输
inline void write(int X)
{
	if(X<0) {X=~(X-1); putchar('-');}
	if(X>9) write(X/10);
	putchar(X%10+'0');
}
或
inline int write(int X)
{
	if(X<0) {putchar('-'); X=~(X-1);}
	int s[20],top=0;
	while(X) {s[++top]=X%10; X/=10;}
	if(!top) s[++top]=0;
	while(top) putchar(s[top--]+'0');
}
```
### code：
```c
#include<bits/stdc++.h>//无敌头文件！
#define ll long long
#define il inline
#define ri register int
using namespace std;
il int rd(){
   int s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9') ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s;
}
il void wt(int x){
	if(x>9) wt(x/10);
	putchar(x%10+'0');
	return;
}
//快读与快输
int n,a[101],dan;
int main(){
	n=rd();
	for(ri i=1;i<=n;i++) a[i]=rd();
	//本题的精髓
	for(ri i=n-1;i>=1;i--) if(a[i]>=a[i+1]){dan+=a[i]-a[i+1]+1;a[i]=a[i+1]-1;}
	wt(dan);
	return 0;
	撒花✿✿ヽ(°▽°)ノ✿
}
```

最后管理大大求过&&[来玩啊](https://www.luogu.com.cn/user/361726)

---

## 作者：Gorenstein (赞：4)

题目给你一个数列，让你把这个数列中，某几项减去随意一个数。求减去的数的和最少是多少。

显然是一道贪心算法的题目。

------------


**贪心策略**：如果这个数比后一个数大，则把这个数减至后一个数-1。

**证明**：反证法。当$a_i>a_{i+1}$时，如果把$a_i$减到小于$a_{i+1}-1$，则显然把$a_i$减到$a_{i+1}-1$更优。并且对前一项的要求更低。

所以做法就很显然了，如果 $a_{i+1}\leq a_i$ ，那么减去 $a_i-(a_{i+1}-1)$ 。

从第n-1项开始往前扫描，如果比后一个数大，那么ans加上$a_i-(a_{i+1}-1)=a_i-a_{i+1}+1$。

------------
目前最短的AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],ans,n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=n-1;i>0;i--)//从后往前
		if(a[i]>=a[i+1]){ans+=a[i]-a[i+1]+1;a[i]=a[i+1]-1;}//如果a[i]>a[i+1]，将a[i]减到a[i+1]-1，累计答案。
	cout<<ans;
	return 0;
}
```

---

## 作者：Fat_Fish (赞：1)

给定一个长度为 $n$ 的序列，你可以将某些各减去一个数，使得整个序列严格递增。

你需要求出所有减去的数的总和的最小值。

**注意：** 是**严格递增**，也就是说两数**相等的情况不算**。

**解题思路：** 从后往前改变数字，若$a_i \ge a_{i+1}$,要使数列严格递增，还要尽可能少减，就将$a_i$变成$a_{i+1}-1$，再将答案ans加上$a_i-a_{i+1}+1$即可。

$Code$

```cpp
#include<iostream>
#include<bits/stdc++.h>//头文件
using namespace std;
int main(){
	int n;
	cin>>n;//数字个数
	int a[n+1],ans=0;//a数组储存数字，ans记录答案
	for(int i=1;i<=n;++i){
		cin>>a[i];//输入不多说
	}
	for(int i=n-1;i>=1;--i){//从倒数第二个起，因为倒数第一个是最后的，没有下一个
		a[i]>=a[i+1]?
		ans+=a[i]-a[i+1]+1,
		a[i]-=a[i]-a[i+1]+1:1;//三目运算符判断
	}
	cout<<ans;//输出
	return 0;
}
```
最后讲讲**三目运算符**

简单来说就是**条件？ 条件成立返回值：条件不成立返回值**

详见[这篇博客](https://blog.csdn.net/Diogenes_/article/details/80543145)


---

## 作者：Contemptuous (赞：1)

此题主要思路：贪心。

我们可以从后往前遍历，如果$a_i$不是$a_{i+1}$减$1$，那么就用计数器加上它们的差再减去$1$，然后再把它改成后一个数减去$1$，最后在输出计数器即可。

以下是本蒟蒻的代码。
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main(){//主函数
    int n;
    cin>>n;
	int s[n+1];//定义一个数组
    for(int i=1;i<=n;i++){
        cin>>s[i];
	}
    int sum=0;
    for(int i=n-1; i>=1; i--){
        if(s[i]>=s[i+1]){//判断后一个数是否比前一个数大
            sum+=(s[i]-s[i+1]+1);//累加
            s[i]=s[i+1]-1;//将数据修改
        }
    }
    cout<<sum;//输出结果
    return 0;//程序结束
}
```
## 莫抄袭，没了AC记录，空悲切！

---

## 作者：dzy2008 (赞：1)

这道题是一道贪心题。

### 因为题目告诉我们最后的序列是递增的，所以最后出来的序列的最后一项，一定序列中是最大的一个数

话不多说代码中解释

```cpp
#include<iostream>
using namespace std;
int a[101];
int main()//主函数
{
	int n;//题目中所说的n，表示有多少个数
	int ans=0;//最终的答案，一定要先赋值为0，不然结果会错误
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];//读入
	}
	for(int i=n-1; i>=1; i--) { //这里从i-1枚举到1有两个原因：1.最后一个是最大的，要保留；2.每次需要更改数值，不能影响到其他的数 
		if(a[i]>=a[i+1]) { //如果不满足递增序列，则执行减的操作 
			ans+=(a[i]-a[i+1]+1);//答案加上要减去的
			a[i]=a[i+1]-1;//把这项改成合格的序列
		}
	}
	cout<<ans;//输出答案 
	return 0;
}
```


---

## 作者：KadiaNEFU (赞：1)

# 一道适合入门的贪心题目

- 因为我们只能减不能增，所以保证**最后一个数字一定是最大的。**

- 所以我们可以从倒二个数开始遍历，**如果a[i]不小于下一个数字a[i+1]，那么就要把a[i]变成a[i+1]-1**，因为变成这个才能使减少的数字最少。sum也要加相差的数字。**如果a[i]已经小于下一个数字a[i+1]，那么就不用管**。

#### 蒟蒻的code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105];
int main()
{
    int n;
    cin >> n;
    for(int i=1; i<=n; i++)
        cin >> a[i];
    int sum=0;
    for(int i=n-1; i>=1; i--)
    {
        if(a[i]>=a[i+1])
        {
            sum+=(a[i]-a[i+1]+1);
            a[i]=a[i+1]-1;
        }
    }
    cout << sum << endl ;
    return 0;
}

```


---

## 作者：bystander_silent (赞：0)

这题我的思路是贪心。先输入完后从后往前找。一旦破坏单调性就把它减到不破坏单调性为止。注意：如果一个序列里相邻两个数相等，也算破坏单调性（样例就是一个很好的例子）
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,a[1000000];
int ans;//不开 long long 也可以。 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    	scanf("%d",&a[i]); 
    if(n==1)//特判：如果只有一个数那就一定单调递增。 
    {
    	cout<<0;
    	return 0;
	}
    for(int i=n-1;i>=1;i--)//从后往前找 
    	if(a[i]>=a[i+1])//这个数破坏了单调性 
    	{
    		ans+=(a[i]-(a[i+1]-1));//贪心，这个数剩下越大越好 
    		a[i]=(a[i+1]-1);
		}
    printf("%d",ans);
    return 0;
}
```


---


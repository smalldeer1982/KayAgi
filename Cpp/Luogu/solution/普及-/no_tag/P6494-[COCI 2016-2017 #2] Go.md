# [COCI 2016/2017 #2] Go

## 题目描述

在游戏《进化！宝可梦》中，Mirko 拥有 $n$ 只宝可梦。为了完成对它们的进化，Mirko 为第 $i$ 只宝可梦准备了 $m_i$ 颗糖果。

每次进化第 $i$ 只宝可梦，都需要消耗 $k_i$ 颗为其准备的糖果。进化完成后，Mirko 将获得 $2$ 颗相应的糖果作为奖励。需要注意，所有宝可梦都只能使用相应的糖果进行进化。

Mirko 想知道他总共能完成多少次对宝可梦的进化，并找出进化次数最多的一只宝可梦。如果进化次数最多的宝可梦不唯一，请选择更早在输入中出现的那一只。

## 说明/提示

#### 样例 1 解释

对于 Weedle 的第一次进化，Mirko 消耗了 $12$ 颗糖果，然后获得 $2$ 颗糖果作为奖励。此时，还剩下 $42-12+2=32$ 颗糖果供 Weedle 进化。这样，Mirko 共能完成 $4$ 次对 Weedle 的进化。

类似地，Mirko 能进化 $3$ 次 Caterpies，$4$ 次 Pidgeys 和 $3$ 次 Rattatas。累计能完成 $14$ 次进化，即为答案的第一部分。

其中，Weedle 和 Pidgeys 的进化次数最多，均为 $4$ 次。由于 Weedle 比 Pidgeys 更早在输入中出现，故将 `Weedle` 作为答案的第二部分。 

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 70$，$12\le k_i\le 400$，$1\le m_i\le 10^4$。

所有字符串的长度不超过 $20$，且都仅包含大小写字母。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T1 Go_**。


## 样例 #1

### 输入

```
4
Caterpie
12 33
Weedle
12 42
Pidgey
12 47
Rattata
25 71 ```

### 输出

```
14
Weedle ```

## 样例 #2

### 输入

```
7
Bulbasaur
25 74
Ivysaur
100 83
Charmander
25 116
Charmeleon
100 32
Squirtle
25 1
Wartortle
100 173
Pikachu
50 154 ```

### 输出

```
11
Charmander```

# 题解

## 作者：lzqy_ (赞：10)

# 不用数组的优化做法

## 题意：

有$n$只宝可梦，每只宝可梦需要$ki$个果子来升级，共有$mi$个果子，每次升级之后能返还$2$个果子。

输出所有宝可梦一共升了几级，并输出升级最多的宝可梦的名字。

---

## 分析

**这道题的关键在于计算每只宝可梦可以升几级。**

我们先假设不会返还$2$个果子，那能够升几级？ 很明显，升$mi/ki$ 级，还剩下 $mi$%$ki$ 个果子。而每升一级就返回$2$个果子，所以果子数还要再加上升级级数乘二，即$mi+=(mi/ki)*2$。

但是这就结束了吗？很明显还不行。因为加上奖励的果子之后，也许还可以再升级。所以，以上的过程我们要执行多次，直到无法升级为止。

代码如下：
```
while(k<=m)
{
   sum+=m/k;//此处的sum为升级级数
   m=((m/k)*2)+m%k;
   //新的果子数量为'剩下的果子+奖励的果子'
 }
```
## 优化
（注：这一段讲的内容不用也可以AC，只是能够进一步地优化）

- 还记得上文的$(mi/ki)*2$ 吗？此处的$*2$可以用位运算来进行优化，即$<<1$。

- 我们不必把每一只宝可梦升级级数用数组记录下来。我们在处理的时候，可以边处理边求最大值 。

- 用[快读](https://www.cnblogs.com/qiuchengrui/p/9785561.html)进一步优化读入速度。

---
## 代码实现

结合代码一起来看看吧~

```
#include <bits/stdc++.h>
using namespace std;
inline int read()                        
//以字符串形式读入数字可提速（具体详情看上方链接）
{
  int x=0;
  char c=getchar();
  for(; c<'0'  || c>'9';  c=getchar());
  for(; c<='9' && c>='0'; c=getchar())
    x=(x<<3)+(x<<1)+c-'0';   
    //位运算优化即x*8+x*2=x*10
  return x;
}
int main()
{
  string ans2,name;
  int k,m,mmax=0,sum,ans1=0,n;//别忘了初始化
  n=read();//快读
  while(n--)//循环处理每一只宝可梦
  {
    sum=0;//别忘记每次刷新sum初值
    cin>>name;
    k=read();
    m=read();
    while(k<=m)
    {
      sum+=m/k;
      m=((m/k)<<1)+m%k;//基本位运算优化
    }//求升级级数
    ans1+=sum;//总升级级数增加
    if(mmax<sum)//如果升级级数最多
    {
      mmax=sum;
      ans2=name;
    }//更新最大值以及宝可梦名字
  }
  cout<<ans1<<"\n"<<ans2;//输出
  return 0;//结束
}

```

### 祝大家AC愉快~

---

## 作者：LinkZelda (赞：5)

 - ### **题意分析**：
 
 给定 $n$ 个宝可梦的**升级所需糖果**数和**现有糖果数**，求**升级最多的宝可梦**的名字和所有宝可梦**一共升级了多少次**。
 
 - ### **方法**：
 
 对于最大次数的宝可梦，我们可以用一个变量 $maxx$ 存升级的最大次数，枚举每一个宝可梦的升级过程（用循环就行，就不说了） ， 只要升级次数比 $maxx$ 大的话就更新答案（注意条件**不能取等号**，题目说了要输出**最大且最早**出现的那个）；
 
 对于一共出现了多少次，直接就开个 $ans$ 每一次升级时就加一，然后输出就行了。
 
- ### **代码实现** ：
```cpp
#include<iostream>
#include<string>
using namespace std;
int main()
{
	int n,maxx=-1,k,m,cnt=0,ans=0;//maxx存最多的次数，cnt存每个宝可梦进化的次数 
	string s,name;//name答案字符串
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>s>>k>>m;
		while(m>=k)//糖果足够进化
		{
			m-=k;
			m+=2;
			cnt++;	
			ans++;
		 } 
		if(cnt>maxx)//不能取等号，要取最前出现且最大的答案
		{
			maxx=cnt;//更新答案
			name=s;
		}
		cnt=0;//注意要初始化
	}
	cout<<ans<<endl<<name;
	return 0;
 } 
```


---

## 作者：Lee_Yuet (赞：3)

### 给大家提供一种优化方法

**[我目前来说是最快的](https://www.luogu.com.cn/record/34361637)**， 只跑了$74ms$

那我是**怎么优化的呢**？

**思路**：

- **边读边进行**比较与统计，节省**空间**和**时间**

- 因为 $scanf$，$printf$ 胜过 $cin$，$cout$ ，所以我选择用 $char$ 存储名字，而使用复制 $memcpy$ 函数会**大大提速**

- 我没有纯模拟，而是每次看看**一次能进化多少次**，然后**再将糖果加上**

	- 注意：因为糖果是**2颗2颗加**，即加的个数为进化次数的2倍，所以我们可以使用**位运算优化**
	

思路明确后，就可以开始**写代码**了

$Coder$ 如下：

```cpp
void work(void)
{
    scanf("%d", &n);	//读入
    while(n--)	//循环n次
    {
        scanf("%s%d%d", s1+1, &a, &b);	//读入
        while(b>=a)
        {
            t+=b/a;
            b=((b/a)<<1)+b%a;	//位运算加速
        }
        ans+=t;	//加上本次循环的值
        if(t>maxn)	//比较大小
        {
            maxn=t;	//赋值
            memcpy(s2, s1, sizeof(s1));		使用复制memcpy函数会大大提速
        }
        t=0;	//默认为0
    }
    
    printf("%d\n%s\n", ans, s2+1);	//输出
}
```

---

## 作者：Talanton_Cerydra (赞：2)

[P6494](https://www.luogu.com.cn/problem/P6494)

## 主要思路:暴力

首先用一个结构体存储每只宝可梦的数据:

```cpp
struct Go
{
    string s;
    int k,m,p,ns;
    //p表示这只宝可梦的顺序,ns表示这只宝可梦可以进化的最多次数
}fp[71];
```

然后,在我们读入数据之后,需要计算出这只宝可梦可以进化的最多次数.

于是我编了一个函数专门求次数,实质就是暴力:

```cpp
int js(int a,int b)
{
    int res=0;//存储答案
    //以一种简单粗暴的方式求进化最多次数
    while(b>=a)//只要b>=a就可以不断进化
    {
        res++;//次数+1
        b-=a;//消耗糖果
        b+=2;//奖励2颗糖果
    }
    return res;//返回答案
}
```

同时我们记录进化的总次数.

接着对每只宝可梦进行排序,找出进化次数最多的那一个:

```cpp
bool cmp(Go a,Go b)
{
//此处注意,如果进化次数相同,以输入顺序优先
    if(a.ns==b.ns)//如果进化次数相同
    {
        return a.p<b.p;//看哪个先输入
    }
    return a.ns>b.ns;//进化次数不同,直接比较进化次数
}
```

最后输出进化总次数和排序后下标为1的宝可梦名字就可以啦~

## $AC code$:

```cpp
#include <bits/stdc++.h>
using namespace std;
//用一个结构体存储每只宝可梦的数据
struct Go
{
    string s;
    int k,m,p,ns;
    //p表示这只宝可梦的顺序,ns表示这只宝可梦可以进化的最多次数
}fp[71];
int n,cnt=0;//cnt记录棕进化次数
bool cmp(Go a,Go b)//排序
{
//此处注意,如果进化次数相同,以输入顺序优先
    if(a.ns==b.ns)//如果进化次数相同
    {
        return a.p<b.p;//看哪个先输入
    }
    return a.ns>b.ns;//进化次数不同,直接比较进化次数
}
int js(int a,int b)//计算最多进化次数
{
    int res=0;//存储答案
    //以一种简单粗暴的方式求进化最多次数
    while(b>=a)//只要b>=a就可以不断进化
    {
        res++;//次数+1
        b-=a;//消耗糖果
        b+=2;//奖励2颗糖果
    }
    return res;//返回答案
}
int main()//主函数
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>fp[i].s>>fp[i].k>>fp[i].m;
        fp[i].p=i;//记录读入的数据,排序时会用
        fp[i].ns=js(fp[i].k,fp[i].m);//求出这只宝可梦最多可以进化的次数
        cnt+=fp[i].ns;
    }
    sort(fp+1,fp+n+1,cmp);//对宝可梦排序
    cout<<cnt<<endl<<fp[1].s;//输出总进化次数和进化次数最多的宝可梦名字
    return 0;
}
```


---

## 作者：naroanah (赞：1)

这道题思路很简单，大佬们都是各种神仙优化，我这种菜鸡
只会最简单的模拟~~唯一的优点是不用数组~~，来看看我的代码吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string name,maxname;
int k,m,maxx,ans,sum;
int main()
{
	ios::sync_with_stdio(false);//加速读写，卡常专用 
	cin>>n; 
	for(int i=1;i<=n;++i) 
	{
		sum=0;//初始化 
		cin>>name>>k>>m;
		while(m>=k)//只要还能进化 
		{
			sum++;//本次进化数量+1 
			m-=k;//题意模拟 
			m+=2;
		}
		ans+=sum;//总次数加上 
		if(maxx<sum)//寻找最大值 
		{
			maxx=sum;
			maxname=name;
		}
	}
	cout<<ans<<endl<<maxname<<endl;
	return 0;
}

```
感谢洛谷评测姬，居然让我这种代码跑了[64ms](https://www.luogu.com.cn/record/34383109)

---

## 作者：_Fontainebleau_ (赞：0)

此题我们选用**结构体**来实现。

看完题目，我们发现，比较的是进化次数，输出的是**进化次数最多且出现最早**的 $pokemon$ 的名字。

~~（最开始因为没考虑到加粗部分，用$sort$拿了92$pts$）~~

------------

$code$

```cpp
#include<bits/stdc++.h>
#define FOR(i,j,k)  for(int i=(j);i<=(k);i++)
using namespace std;
int n;//pokemon数量
int ans;//进化总次数
struct pokemon{
	string name;
	int k,m,level=0;//进化消耗 剩余糖果 进化次数
}P[75];//结构体
inline int read()//快读板子不解释
{
    int x=0,w=1;char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch-48),ch=getchar();
    return x*w; 
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		cin>>P[i].name;
		P[i].k=read(),P[i].m=read();
	}
   /*------------------读入-----------------*/
	for(int i=1;i<=n;i++)
		while(P[i].m>=P[i].k)//当剩余糖果数量比进化所需糖果多时
			P[i].level++,P[i].m-=P[i].k,P[i].m+=2,ans++;//模拟，由题意得
	int maxx=1;
	for(int i=2;i<=n;i++)
		if(P[i].level>P[maxx].level)	maxx=i;	//选择进化次数最多且出现最早的pokemon，故不能取等
   /*-----------------模拟-----------------*/
	cout<<ans<<"\n"<<P[maxx].name<<"\n";//输出
	return 0;
}

```


---


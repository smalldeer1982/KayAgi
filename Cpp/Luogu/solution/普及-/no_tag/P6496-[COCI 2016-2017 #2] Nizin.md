# [COCI 2016/2017 #2] Nizin

## 题目描述

设 $A$ 是一个含有 $n$ 个元素的数组，其中各元素的编号为 $1\dots n$。若对于任意整数 $i\in [1,n]$ 都有 $A_i=A_{n-i+1}$，则称 $A$ 是一个「回文数组」。

Mislav 可以通过以下方式修改一个数组：

1. 选择两个**相邻**的元素。
2. 将这两个元素**替换**为一个新的元素，值为它们的和。

现在，给出一个数组。请你计算在至少多少次修改后，Mislav 可以将其修改为一个「回文数组」。

## 说明/提示

#### 【样例解释】

使用 `[]` 标记 Mislav 修改时所选择的两个数。

**样例 1 解释**

`[1 2] 3` -> `3 3`。

**样例 2 解释**

`1 [2 4] 6 1` -> `1 6 6 1`。

**样例 3 解释**

`[1 4] 3 2` -> `5 [3 2]` -> `5 5`。

------------

#### 【数据规模与约定】

- 对于 $30\%$ 的数据，保证 $n \leq 10$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^6$，$1\le a_i\le 10^9$。

------------

#### 【说明】

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T3 Nizin_**。

## 样例 #1

### 输入

```
3
1 2 3 ```

### 输出

```
1 ```

## 样例 #2

### 输入

```
5
1 2 4 6 1```

### 输出

```
1 ```

## 样例 #3

### 输入

```
4
1 4 3 2 ```

### 输出

```
2 ```

# 题解

## 作者：Wenoide (赞：4)

重复下述步骤：

- 若最左端元素较最右端元素更小，则合并最左端的两个元素。
- 若最右端元素较最左端元素更小，则合并最右端的两个元素。
- 若两端的元素相等，则对除两端的元素外的其他元素重复以上步骤。

显然，回文数组两端的元素应相等。

第一种情况下，迟早需要合并最左端的两个元素。否则最右端的元素会越来越大，直到数组中只剩一个元素。

第二种情况同理。

第三种情况下，两端的元素已经回文，可以不作处理。

时间复杂度 $O(n)$。

------------

参考代码：

```
#include<cstdio>
const int MAXN=1000000+10;
long long p[MAXN];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&p[i]);
	}
	int l=1,r=n,cnt=0;
	while(l<r){
		if(p[l]>p[r]){
			--r;
			p[r]+=p[r+1];
			++cnt;
		}
		else if(p[l]<p[r]){
			++l;
			p[l]+=p[l-1];
			++cnt;
		}
		else{
			++l,--r;
		}
	}
	printf("%d",cnt);
	return 0;
}
```

---

## 作者：ruanshaochuan______ (赞：1)

显而易见，回文数组的两端的数相等，因此，我们只需要从两端开始比较。 
1. 如果最前端的数大于最后面的数，如果合并前端的数，由于不存在负数的情况，前端的数只会越来越大，所以只能合并最后的数。 
1. 如果最前端的数小于最后面的数，和上面同理，只能合并最前端的数。
1. 如果最前端的数等于最后面的数，那么就对中间的数进行操作。
1. 重复以上操作。
- 这种操作，我们很容易就能想到递归的做法，参考代码如下

```

#include<bits/stdc++.h>
using namespace std;
int n,x,y,ans;
unsigned long long int a[1000005],sum;//最多1e6个数
void cmp(int x,int y)//递归函数
{
    if(x>=y)//结束条件
        return;
    while(1)
    {
        if(a[x]==a[y])//如果两端相等
        {
            x++;
            y--;
            cmp(x,y);//递归下一步
            return;
        }
        else if(a[x]<a[y])//如果前端小于后端
        {
            a[x+1]+=a[x];
            x++;
            sum++;
        }
        else//如果前端大于后端
        {
            a[y-1]+=a[y];
            y--;
            sum++;
        }
    }
}
int main()//巨短主函数
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    cmp(1,n);//从两端开始
    cout<<sum;
    return 0;
}


```


---

## 作者：Aurora_Borealis_ (赞：0)

# P6496[COCI2016-2017#2] Nizin题解

考虑从两边向中间解决问题。

设左端点指针为 l，右端点指针为 r，初始时 l=1，r=n。

因为 $ 1 \leq a_{i} \leq 10^9 $，也就是所有的 $ a_{i} $ 都为 0，所以操作不可逆，且数列内的数只会**越来越大**。

可以得出如下几个条件：

- 当 $ a_{l} $<$ a_{r} $ 时，需要在 l 处进行一次操作。

- 当 $ a_{l} $>$ a_{r} $ 时，需要在 r 处进行一次操作。

- 当 $ a_{l} $=$ a_{r} $ 时，意味着当前的 l 和 r 已经符合“回文”，开始处理 l+1 到 r-1 的子区间。

代码：

```cpp
#include<iostream>
using namespace std;
int n,l,r,ans;
long long a[1000005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	l=1,r=n;
	while(l<r){
		if(a[l]==a[r]){
			l++;
			r--;
		}else if(a[l]<a[r]){
			a[l+1]+=a[l];
			l++;
			ans++;
		}else{
			a[r-1]+=a[r];
			r--;
			ans++;	
		}
	}
	cout<<ans;
	return 0;
}
```


---


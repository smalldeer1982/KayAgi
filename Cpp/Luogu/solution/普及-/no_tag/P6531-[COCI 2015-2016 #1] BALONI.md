# [COCI 2015/2016 #1] BALONI

## 题目背景

神箭手射气球！

## 题目描述

神箭手要射掉 $n$ 个气球，且每个气球有高度，设为 $h_i$。

箭会因为气球的弹性而下坠，当射中一个气球后箭的高度会下降 $1$。

神箭手可以射任意高度的箭。

求出神箭手最少需射几箭。

## 说明/提示

#### 样例 1 解释
先射击高度为 $5$ 的气球，再射击高度为 $2$ 的气球。
#### 数据范围及限制
- 对于 $40\%$ 的数据，保证 $n\le 5\times 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n,h_i\le 10^6$。
#### 说明
**本题满分 $100$ 分。**

本题译自 [Croatian Open Competition in Informatics 2015/2016](https://hsin.hr/coci/archive/2015_2016) [Contest #1](https://hsin.hr/coci/archive/2015_2016/contest1_tasks.pdf) T3 BALONI。

## 样例 #1

### 输入

```
5
2 1 5 4 3
```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
5```

## 样例 #3

### 输入

```
5
4 5 2 1 4```

### 输出

```
3```

# 题解

## 作者：btng_smith666 (赞：24)

思路：

枚举 $n$ 个气球，开一个数组存储每个高度箭的数量，如果这一高度有箭，就去掉这里的箭；如果没有就将总箭数+1，然后在下面加一个箭，最后输出总箭数即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int h,n,ans,a[1000001];
int main()
{
	scanf("%d",&n);
    while(n--)
    	scanf("%d",&h),a[h]?a[h]--:ans++,a[h-1]++;
    printf("%d",ans);
    return 0;
}
```

在最后求个赞qwq

---

## 作者：CCCloud (赞：4)

## 贪心
看有一篇题解用 $map$ 来做，感觉有点多此一举，于是发一篇题解来讲讲我的思路;

------------  
**题目**：[在这里](https://www.luogu.com.cn/problem/P6531)  
**主要思路**：这道题的**码量不大**，主要是你能**换一种思路**想清楚就好了   
1、定义一个数组 $value$， 来存储当前这个位置拥有箭的个数；  
2、一边读一边操作，如果当前的这个高度**没有箭**，那么就**射一支箭**，并且**将这支箭的高度设为当前的高度-1**（由于高度不小于1，所以不**用考虑数组越界**的情况）；  
3、**重复第2步**直到**读完数据**；  
4、**输出** $ans$ 的值；
  
**坑点**：千万不能将箭的个数**直接设成0或1**，否则就会[这样](https://www.luogu.com.cn/record/33639360)

------------

### 主要代码如下：
```cpp
for(int i=1; i<=n; i++)
    {
        scanf("%d", &m);//读入
        if(!v[m])//如果当前高度没有箭
        {
            ans++;//箭的个数++
            v[m-1]++;//高度-1的位置有箭
        }
        else//否则
        {
            v[m]--;//当前高度的箭的个数--
            v[m-1]++;//高度-1的位置的箭的次数++
        }
    }
```
感谢大家阅读我的题解，希望对大家有所帮助！

---

## 作者：KadiaNEFU (赞：3)

咋一看还以为就是个递减贪心，看了样例发现不对，是一排气球，从左向右射箭，每击中一个气球箭的高度会下降1，但**箭始终是从左向右移动的**。

思路：用一个map记录key的高度的箭有多少只。

- 如果输入的a[i]的value值大于0，**说明这个高度有箭，这个value--，a[i]-1的value再++**，因为这只箭射中这个气球后高度会减1，那么a[i]-1高度的箭的数量就会加1。

- 如果输入的a[i]的value值为0，**说明这个高度没有箭，所以就要我们往这个高度射一只箭，sum++**(sum记录射了多少只箭)，然后射中后同样下降一个高度，那么**a[i]-1高度的箭的数量就会加1**。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
int main()
{
    int n;
    cin >> n;
    map<int,int>save;
    int sum=0;
    for(int i=1;i<=n;i++)
    {
        cin >> a[i];
        if(save[a[i]]>0)
        {
            save[a[i]]--;
            save[a[i]-1]++;
        }
        else
        {
            sum++;
            save[a[i]-1]++;
        }
    }
    cout << sum << endl ;
    return 0;
}

```



---

## 作者：159号程序员 (赞：2)

这道题用的是贪心的算法。

我们可以开一个数组，来存箭的高度。

如果发现这一层已经有箭，于是我们就不需要再有箭了，去除这一层的箭。

如果所在气球层没有箭，就另外射一根箭到该层，总箭数+1，因为打了气球，在下面加一根箭。

_AC Code_
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int b, T, sum = 0 , x[100000];
    cin >> T;
    while(T--) //枚举 T 个气球
    {
        cin >> b; //输入这一个气球的高度
    	x[b] ? x[b]-- : sum++, x[b - 1]++; //利用 ?: 简化代码，判断是否有箭
    }
    cout << sum; //输出
    return 0;
}
```
引用
感谢[btng_smith666](https://www.luogu.com.cn/blog/X-SSS-Tng/solution-p6531)的题解，让我想起了贪心策略！

---


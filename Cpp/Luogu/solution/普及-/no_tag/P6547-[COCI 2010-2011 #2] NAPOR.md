# [COCI 2010/2011 #2] NAPOR

## 题目描述

Little Mirko 对数学课不在意，所以老师决定在周末让他做一个乏味的作业。

老师给了他一个包含 $n$ 行的文本，仅包含数字和小写字母。 Mirko 必须在文本中找到所有数字，并以不降序的顺序输出。 他还必须省略文本中数字可能包含的任何前导零。

可以通过扫描文本并始终使用可能的最大数来确定这些数，即仅以字母或行首/尾定界。 例如，`01a2b3456cde478` 的最终输出结果是 `1, 2, 478, 3456`。

由于 Mirko 解决问题的速度像蜗牛一样慢，因此他要求您为他编写一个程序以快速解决任务，以便他可以尽快与 Slavko 一起玩。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq  n \leq 100$，每个字符串长度不超过 $100$，文本中包含数的个数不超过 $500$，输入中仅包含小写字母与数字。

#### 说明

- 本题满分 $60$ 分。
- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) NAPOR，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
2
lo3za4
01```

### 输出

```
1
3
4```

## 样例 #2

### 输入

```
4
43silos0
zita002
le2sim
231233```

### 输出

```
0
2
2
43
231233```

## 样例 #3

### 输入

```
4
01bond
02james007
03bond
04austinpowers000```

### 输出

```
0
1
2
3
4
7```

# 题解

## 作者：ZolaWatle (赞：24)

## P6547 题解

题目的意思很简单，给出一堆字符，让你在这堆字符中找出数字，并将它们从大到小输出。

由于题中给出了 $ n $ 个字符串，所以我们大可对于每一行分别操作。

我们令这一行的字符串为 $ s $，$ l $ 为当前行字符的长度，$ i $ 为当前指向的字符，容易得到这三个while循环（传统艺能）：

```cpp
while(i<l)  //大边界，便于在扫完整个字串后退出循环
{
    while(s[i]>='0'&&s[i]<='9')  //当前字符是数字时
    //...
    while(s[i]>='a'&&s[i]<='z')  //当前字符是小写字母时
   	//...
}
```

看看注解就好，应该不需要多做什么解释。

题中的要求是找出数字，所以在“数字”的while循环里，我们可用以下的代码

```cpp
sum=sum*10+s[i]-48;  //将字符转换成数字，再累积到计数器中
```

满足这个要求。

在退出循环后，我们开一个栈把数字存进去，最后按要求排序即可。

```cpp
for(re x=1;x<=n;x++)
{
	std::cin>>s;
	l=s.length();  //输入&计算长度 
	
	re i=0;
	while(i<l)
	{
		re sum=0,p=0;  //定义局部变量 
		while(s[i]>='0'&&s[i]<='9')
		{
			p=1;  //判断这一次是否进行了“数字累加”这一过程 
                        sum=sum*10+s[i]-48;
			i++;  //扫描下一个字符 
		}
		if(p==1)
			a[++t]=sum;  //存入栈中 
		while(s[i]>='a'&&s[i]<='z')
			i++;  //扫描下一个字符 
	}
}
```


**但是！！！**

这样写乍一看是正确的，样例也过了，交上去评测却只有 $12$ 分。

我们仔细看看数据范围：

“每个字符串长度不超过 $ 100 $ ”

那万一这一行字符全是数字呢？这样一来，不但是 $int$，就算是 $ unsigned\ long\ long $ 也是存不下的。

那我们就得改变思路了，不用数组，而是用 $ string $ 类型的数组来存。（至于为什么不用 $ char $，原因是 $ char $ 不论是在累加方面还是排序方面，都没有 $ string $ 方便（C++万岁））

我们定义一个 $ string $ 数组 $ ans_i $，表示答案。对于每一行字符，再定义一个 $ string $ 型 $ tmp $，表示当前存储的这个“数字”。需要注意的是，我们应该将 $ tmp $ 的初值赋为""，这是空串。

我们可以用语句：

tmp+=s[i];

将字符 $ s_i $ 接在这个字符串的后面，起到与上面说的 $sum$ 语句起到同样的效果。但这样的做法无法去除前导零，因此，我们需要在退出循环后，手动为其去除前导零。代码如下：

```cpp
t++;
re j=0,k=tmp.length();  //计算这个“数字”的长度 ，从第一个字符开始扫描 
while(tmp[j]=='0'&&j<k-1)  //当当前字符为‘0’并且不是最后一个字符时（答案存在0） 
	j++;  //删去 
for(re y=j;y<=k;y++)
	ans[t]+=tmp[y];  //将未删去的字符接在ans后 
```

然后排序输出即可：

```cpp
std::sort(ans+1,ans+t+1);

for(re i=1;i<=t;i++)
	std::cout<<ans[i]<<endl;
```

**但是#2！！！**

这样的排序其实是有问题的。简单地说说 $ algorithm $ 库中对 $ string $ 型的排序方法：首位越大的排越前面。

就拿本题的样例二说吧，正确的 $ sorting $ 应该是：

```cpp
0,2,2,43,231233
```

但上述写法的输出则是：

```cpp
0,2,2,231233,43
```

懂我意思了吧？

所以最后摆在我们面前的问题只有一个：手写 $ cmp $ 函数。

首先把 $ ans_i $ 数组改为结构体（方便以长度为关键字比较）：

```cpp
struct Ans
{
	int len;  //存长度
	string a;  //存“数字”本身
}ans[501];
```

接着写 $cmp$ 函数（详见注释）：

```cpp
inline bool cmp(Ans x,Ans y)
{
	if(x.len==y.len)  //若长度相等 
		return x.a<y.a;  //则按string型的默认排序方式排序 
	return x.len<y.len;  //位数多的肯定比位数少的大 
}
```

最后一个一个把主函数里的 $ ans_i $ 改成 $ ans_i.a $ 就可以了。

完整代码如下：

```cpp
#include <bits/stdc++.h>
#define re register int
using namespace std;

int n,l,t;
string s;
struct Ans
{
	int len;
	string a;
}ans[501];

inline bool cmp(Ans x,Ans y)
{
	if(x.len==y.len)
		return x.a<y.a;
	return x.len<y.len;
}

int main()
{
	std::cin>>n;
	
	for(re x=1;x<=n;x++)
	{
		std::cin>>s;
		l=s.length();
		
		re i=0;
		while(i<l)
		{
			re p=0;
			string tmp="";
			while(s[i]>='0'&&s[i]<='9')
			{
				p=1;
				tmp+=s[i];
				i++;
			}
			if(p==1)
			{
				t++;
				re j=0,k=tmp.length();
				while(tmp[j]=='0'&&j<k-1)
					j++;
				for(re y=j;y<=k;y++)
					ans[t].a+=tmp[y];
				ans[t].len=ans[t].a.length();
			}
			while(s[i]>='a'&&s[i]<='z')
				i++;
		}
	}
	
	std::sort(ans+1,ans+t+1,cmp);
	
	for(re i=1;i<=t;i++)
		std::cout<<ans[i].a<<endl;
	
	return 0;
}
```

码字不易，还请看官点赞！

---

## 作者：wuyonghuming (赞：5)

## 思路：
这道题目按照题目读入 $n$ ,接着读入字符串，**注意不要用$getline$**,如果是数字，而且它是这一行中的第一个数字或者它的上一个不是数字，那么这就到了下一个数了。**用一个字符串存它们**，可能非常大。我们在排序的时候**要先比较长度，再比较大小**，否则排序会出现错误结果。
## 处理0:
如果这个数是 $0$ 的话先默认前缀处理，最后如果是空串，把它改成 $0$ 。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,t=0;//t是数的个数
string s[10001];//记录这些出现的数
int main()
{
	string str;//用来读入字符串
	cin>>n;//输入字符串个数
	for(int i=1;i<=n;i++)
	{
		cin>>str;//输入字符串
		for(int i=0;i<str.size();i++)//size()是求字符串的长度，从0开始
		{
			if(str[i]>='0'&&str[i]<='9')//如果是数字
			{
				if(i==0||str[i-1]<'0'||str[i-1]>'9')//如果这是这个数的第一位
				{
					t++; //多了一个数
				}
				if(s[t]!=""||str[i]!='0')//按照处理0的方法判断
				{
					s[t]+=str[i];//这个数乘上十，加上str[i]-'0'了
				}
			} 
		}
	}
	for(int i=1;i<=t;i++)
	{
		if(s[i]=="")//判断是否是空串
		{
			s[i]="0";//是的话这个数就一定是0
		}
	}
	for(int i=1;i<=t;i++)
	{
		for(int j=i+1;j<=t;j++)
		{
			if(s[i].size()>s[j].size())//先比较长度
			{
				swap(s[i],s[j]);//交换
			}
			else if(s[i].size()==s[j].size()&&s[i]>s[j])//如果长度一样，就按照c++的方法比较字符串的大小
			{
				swap(s[i],s[j]);//交换
			}
		}
	}
	for(int i=1;i<=t;i++)
	{
		cout<<s[i]<<endl;//输出答案
	}
	return 0;//别忘了
}
```
谢谢管理员审核和大家观看！

---

## 作者：asasas (赞：1)

注：5月15改了一个for循环.

------------
感谢第一篇题解，给了我一些细节的提醒

这题就是求所有的数字，将它们排序后输出即可。

但仅仅是那么简单吗？当然不是！

因为数据范围：**每个字符串长度不超过 100**

**100**！如果全部都是数字，绝对爆long long。

所以我们要用**字符串**存数。（推荐STL自带的string，原因后面解释）。

读入后先判断这个字符是不是数字，是的话还要判断它是不是开头的数字，如果是那数字的个数就+1，否则就和还没处理的那个数接在一起（string的第一个好处：+号可以将两个字符串接在一起）。但这里有个坑点：
## 0！0！0！

是0的话就按之前的方法处理，最后在将数组扫一遍，如果是空串的话，就把它改为0。

至于排序。。。大家可以先做做这题：[P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)

你可以手写排序函数，也可以进行冒泡排序。

主要是先按长度比，如果长度相同再按字典序排。

代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
bool cmp(string a,string b){//判断函数 
	return (a.size()>b.size()||a.size()==b.size()&&a>b);//先判长度，再判字典序大小 
}
string a[10005];//数字数组 
int main(){
	int n,len=0;//len是一共有的数字个数 
	cin >> n;
	string b;//读入用 
	for (int i=1;i<=n;i++){
		cin >> b;
		for (int j=0;j<b.size();j++){//string自带的求长函数
			if (b[j]<='9'&&b[j]>='0'){
				if (i==0||b[j-1]>'9'||b[j-1]<'0'){//b[j]是这个数字的开头 
					++len;
				}
				if (a[len]!=""||b[j]!='0')//b[i]不是这个数字的开头 
					a[len]=a[len]+b[j];//string的+在系统内部重新定义了，功能是把两个字符串连接在一起。 
			}
		}
	}
		for(int i=1;i<=len;i++)
		if(a[i]=="")//判断是否是空串
		a[i]='0';//是的话这个数就是0
	sort(a+1,a+1+len,cmp);
	for (int i=len;i>=1;i--) cout << a[i] << endl;//由于我按降序排序，所以输出时要倒着输出
} 
```


---

## 作者：lingfunny (赞：1)

## 上来就是分析
一看到题，顿时就想到陪伴着自己日日夜夜的**快读**(fastread)。
```
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9' || ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
```

快读奇葩的特性就是，当你使用快读输入```g总之q这sq里是oe一asd堆s乱q码就wg对g了Is93chh```之后，它返回的值是```93```！！也就是完美屏蔽了这些“不正常的”输入。所以只需要魔改一下快读就可以了。

接下来，就是一些坑点。

1. **有前导0**

其实这不算问题，只需要在两个```while```语句中间加上一个：
```cpp
while(ch=='0')ch=getchar();
```
2. **数字很大**

从题目描述中可以看到，数字最大可以达到$100$位，```long long```肯定不用说了，只能采取字符串。

所以可能要魔改成这样：
```cpp
inline string read(){
	string x;
	char ch=getchar();
	while(ch>'9' || ch<'0'){
		if(ch=='-')x+='-';
		ch=getchar();
	}
	while(ch=='0')ch=getchar();
	while(ch>='0'&&ch<='9'){
		x+=ch;
		ch=getchar();
	}
	return x;
}
```

3. **有单一的数字'0'**

这就与我们上面冲突了，如果是碰上单纯的数字```0```，这里的```while(ch=='0')ch=getchar()```就会导致最后的```x```是个空的```string```。可以考虑特判，如果发现过```0```，就把```flag```置为```true```。如果最后发现是空串，就返回```0```。
```cpp
inline string read(){
	string x;
	bool flag=false;
	char ch=getchar();
	while(ch>'9' || ch<'0'){
		if(ch=='-')x+='-';
		ch=getchar();
	}
	while(ch=='0')flag=true,ch=getchar();
	while(ch>='0'&&ch<='9'){
		x+=ch;
		ch=getchar();
	}
	if(x.size())
	return x;
	else
	return string("0");
}
```

4. **快读在此最大的弊端：不知道什么时候结束**

因为是快读，所以我们肯定不是一行一行地读入，所以这里的$n$对我们来说是没用的，因此根本不知道什么时候结束，除非碰上文件尾。

等等，文件尾？

所以可以想到特判文件尾。因为文件尾的```getchar()```返回值是$-1$，所以可以在```while```里加一个特判，如果到文件尾，返回一个自己认识的标识符。

```cpp
inline std::string read(){
	bool flag=false;
	std::string x;
	char ch=getchar();
	while( (ch>'9' || ch<'0') && ch!=-1){
		if(ch=='-')
		x+='-';
		ch=getchar();
	}
	if(ch==-1)return std::string("f**k!");
	while(ch=='0')flag=true,ch=getchar();
	while(ch>='0'&&ch<='9'){
		x+=ch;
		ch=getchar();
	}
	if(x.size())
	return x;
	else if(flag)
	return std::string("0");
}
```

这就是主要代码了，接下来是排序。字符串内置的排序是字典序，这里要先改成数字比大小：
```cpp
bool cmp(std::string x,std::string y){if(x.size()==y.size())return x<y;return x.size()<y.size();}
```
很好理解，如果两个数位数相同，就看字典序谁小。如果不同，就看谁位数小。

## 完整代码
```cpp
#include <algorithm>
#include <cstdio>
#include <string>

const int maxn = 505;

int n,tot;
std::string A[maxn];

bool cmp(std::string x,std::string y){if(x.size()==y.size())return x<y;return x.size()<y.size();}

inline std::string read(){
	bool flag=false;
	std::string x;
	char ch=getchar();
	while( (ch>'9' || ch<'0') && ch!=-1){
		if(ch=='-')
		x+='-';
		ch=getchar();
	}
	if(ch==-1)return std::string("f**k!");
	while(ch=='0')flag=true,ch=getchar();
	while(ch>='0'&&ch<='9'){
		x+=ch;
		ch=getchar();
	}
	if(x.size())
	return x;
	else if(flag)
	return std::string("0");
}

int main(){
	scanf("%d",&n);
	while(1){
		A[++tot]=read();
		if(A[tot]=="f**k!"){
			--tot;
			break;
		}
	}
	std::sort(A+1,A+tot+1,cmp);
	for(int i=1;i<=tot;++i)
	printf("%s\n",A[i].c_str());
	return 0;
}
```

---

✿✿

---

## 作者：CCCloud (赞：0)

前言：编了挺久，终于在学校的机房把这个题过了，好不容易！

------------

### 字符串+字符串排序 
看到这道题，我一开始的思路是直接用 $int$ 过掉,然后码了一段代码,信心满满地交上去……(全WA)  
然后经过高人指点，想到了用**字符串**，结果不知道为什么**RE**了  
最后用 $char$ 和 $string$ 过了

------------
  
思路如下：  
1、**读入一行字符串**；  
2、从字符串的**末尾**读到**开头**，因为我选择的是**把高位放在前边，低位放在后边**；  
3、如果满足是数字的要求，就**直接读入**进 $char$ 数组里（其实我一开始用的是 $string$，但是不知道为什么RE）；  
4、如果**不满足**第3步，那么就判断 $char$ 数组中是否有元素，如果有，存进 $string$ 的数组里；  
5、回到**第3步**；  
6、回到**第1步**；  

------------
主要**代码**如下：
```cpp
for(int j=len-1; j>=0; j--)
        {
            if('0'<=s[j] && s[j]<='9')
            {
                if(m==-1) m=0;
                y[++t]=s[j];
            }
            else
            {
                if(m!=-1)
                {
                    cnt++;
                    while(t)
                    {
                        if(y[t]!='0'||x[cnt]!="") x[cnt]+=y[t];
                        t--;
                    }
                    if(x[cnt]=="") x[cnt]='0';
                    m=-1;
                }
            }
        }
        if(m!=-1)
        {
            cnt++;
            while(t)
            {
                if(y[t]!='0'||x[cnt]!="") x[cnt]=x[cnt]+y[t];
                t--;
            }
            if(x[cnt]=="") x[cnt]='0';
            m=-1;
        }
```  
接着就是**排序**，~~我**王境泽**~~  
用 $sort$ 就可以解决 QAQ  
思路如下：  
1、先比较字符串的**长度**；  
2、如果相等，再比较**开头**；  
3、如果开头**都相等**，就比较**下一位**； 

------------
 
主要**代码**如下：
```cpp
bool cmp(string a, string b)
{
    if(a.length() == b.length())
      return a < b;
    else
      return a.length() < b.length();
}
```  
所以，我们就可以解决掉这道**有坑点**的题了！

---

## 作者：SUNCHAOYI (赞：0)

刚开始做这道题，最先想到的便是字符串与 `int` 之间的转换。

对于第 $n_i$ 行整行输入，若输入数字，则需要在下一个不是数字的位置的地方记录，然后把所得数字加入答案中。当然，答案为 `ans = ans * 10 + str[i] - '0'`。同时，题目中的 `他还必须省略文本中数字可能包含的任何前导零` 这句话十分关键，因此**数字 $0$ 需要特判**。最后，因为 `在文本中找到所有数字，并以不降序的顺序输出`，所以需要进行一次排序。

于是我们就得到了以下这个代码：

```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int MAX = 550;
int a[MAX];
int main()
{
	int n,k = 0,tmp;
	string str;
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>str;tmp = 0;//初始化 
		bool ok = 0;//数字有无出现 
		for(int j = 0;j < str.size();j++)
		{
			if('0' <= str[j] && str[j] <= '9') tmp = tmp * 10 + str[j] - '0',ok = 1;//数字出现 
			else
			{
				if(ok) a[++k] = tmp;//加入答案 
				tmp = 0,ok = 0;//清零 
			}
		}
		if(ok) a[++k] = tmp;//加入答案 
	}
	sort(a + 1,a + k + 1);//排序
	for(int i = 1;i <= k;i++) cout<<a[i]<<endl;
	return 0;
} 
```

----

当然，这个思路也许只能过 $1-2$ 个测试点，原因很简单 `每个字符串长度不超过 100`，因此当该字符串全部为数字时，肯定会爆 `long long`。那么如何解决呢？

**全部都使用字符串来记录数字！** 把所得的数字加入答案中，这次的加法与上面不一样，因为都是字符串，所以我们只要 `ans += str[i]`。

同时，**前导 $0$ 的出现**同样是关键，我们以题目中的样例 $3$ 为例，我们在这 $n$ 行全部输入完毕后，会依次得到这几个数字：
`01 02 007 03 04 000`。所以我们在排序之前需要**删除前导 $0$**，当然，答案为 $0$ 的情况我们依然要注意，核心代码(有注释)：
```
for(int i = 1;i <= k;i++)//删去前导0 
{
	tmp = "";bool ok = 0;//初始化 
	for(int j = 0;j < a[i].size();j++)//依次枚举 
	{
		if(a[i][j] != '0') ok = 1;//第一个不为0的数字 
		if(ok) tmp += a[i][j];//记录有效数位 
	}
	if(ok) a[i] = tmp;//赋值
	else a[i] = '0';//为0的特殊情况 
}
```

经过处理，这几个数字就变成了：`1 2 7 3 4 0`。于是乎，接下去就是排序了。**排序时是将两个字符串进行比较**，所以需要一个 `bool cmp(string x,string y)` 函数。这两个字符串所组成的数有**两种情况**(为表示方便，以下 `string x` 的长度为 $sx$，`string y `的长度为 $sy$)：

① $sx = sy$ 数位相同，我们需要逐一进行比较，即 `return x < y;`   
② $sx ≠ sy$ 数位不同，更加方便，直接比较数位大小，即 `return sx < sy;`

---

经过这样的分析，最后我们排序后只需要逐一输出即可，一行一个。最后是 AC 代码：
```
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int MAX = 550;
string a[MAX];
bool cmp(string x,string y)
{
	if(x.size() != y.size()) return x.size() < y.size();//数位不同
	else return x < y;//数位相同 
}
int main()
{
	int n,k = 0;
	string str,tmp;
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>str;tmp = "";//初始化 
		bool ok = 0;//数字有无出现 
		for(int j = 0;j < str.size();j++)
		{
			if('0' <= str[j] && str[j] <= '9') tmp += str[j],ok = 1;//数字出现 
			else
			{
				if(ok) a[++k] = tmp;//加入答案 
				tmp = "",ok = 0;//清0 
			}
		}
		if(ok) a[++k] = tmp;//加入答案 
	}
	for(int i = 1;i <= k;i++)//删去前导0 
	{
		tmp = "";bool ok = 0;//初始化 
		for(int j = 0;j < a[i].size();j++)//依次枚举 
		{
			if(a[i][j] != '0') ok = 1;//第一个不为0的数字 
			if(ok) tmp += a[i][j];//记录有效数位 
		}
		if(ok) a[i] = tmp;//赋值
		else a[i] = '0';//为0的特殊情况 
	}
	sort(a + 1,a + k + 1,cmp);
	for(int i = 1;i <= k;i++) cout<<a[i]<<endl;
	return 0;
} 
```

---


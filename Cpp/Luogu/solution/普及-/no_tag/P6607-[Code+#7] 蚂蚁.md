# [Code+#7] 蚂蚁

## 题目描述

在东西排布的两棵树之间悬挂着一条长为 $L$ 的细绳，有 $N$ 只蚂蚁在这条绳上。这些蚂蚁希望通过绳子爬到任何一棵树上，但这条绳太细了，导致两只蚂蚁不能并排爬行，也不能交错而过。

它们想到了一个方法：每只蚂蚁都以每单位时间移动一个单位距离的速度不断向前爬，当迎面碰到另一只蚂蚁时，两只蚂蚁都将立即掉头并继续向前爬。现在，蚂蚁们想知道自己是否能爬下绳子，如果能，它们还希望知道自己爬下绳子所花的时间。为了方便，我们按初始时位置从东到西的顺序对蚂蚁从 $1$ 开始编号。

## 说明/提示

### 样例解释

第三只蚂蚁在爬行 $1$ 个单位时间后遇见第二只蚂蚁并掉头，再爬行 $2$ 个单位时间到西侧树木；

第二只蚂蚁在爬行 $1$ 个单位时间后遇见第三只蚂蚁并掉头，再爬行 $1$ 个单位时间后遇见第一只蚂蚁并掉头，再爬行 $3$ 个单位时间到西侧树木；

第一只蚂蚁在爬行 $2$ 个单位时间后遇见第二只蚂蚁并掉头，再爬行 $3$ 个单位时间到东侧树木。

### 子任务

子任务 $1$（$17$ 分）
- $1\le N\le 10, L\le 10^5$。

子任务 $2$（$19$ 分）
- $1\le N\le 100, L\le 10^9$。

子任务 $3$（$27$ 分）
- $1\le N\le 5000, L\le 10^9$。

子任务 $4$（$37$ 分）
- $1\le N\le 10^5, L\le 10^9$。

## 样例 #1

### 输入

```
3 6
1 3 5
1 1 0```

### 输出

```
5 5 3```

# 题解

## 作者：Math_rad_round (赞：15)

 _[P6607](https://www.luogu.com.cn/problem/P6607)_ 

题意简述

一条长为$L$的线上有$N$个点。每个点都以每秒移动一个单位的速度向前，

当迎面碰到另一个点时，立即掉头并继续向前。确定每个点离开绳子所用时间。

$N\leq 10^5$，所有点的位置和初始方向按位置升序给出

------

这种“ _相遇掉头并继续向前_ ”问题，你可以假装你拿着望远镜在远处看

当你看到两个点相遇时，因为你区分不出每一个点，所以你只是会以为两个点 _穿_ 了过去 

例如原本有两个点$\ \ \ \ \ \ \ \ \ \ \ \ $ $A(3)$右，$B(4)$左

相遇时过了$0.5$秒，此时$\ \ $ $A(3.5)$右，$B(3.5)$左

掉头，$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $ 此时$\ \ $ $A(3.5)$左，$B(3.5)$右

再过$0.5$秒，$\ \ \ \ \ \ \ \ $此时$\ \ $ $A(3)$左，$B(4)$右

如果把$A,B$反转，$ $ 就是$\ \ $ $B(3)$左，$A(4)$右

而如果直接穿过——$\ \ \ \ \ \ \ \ \ \ $ $B(3)$左，$A(4)$右

所以如果有$A(3)$右，那$10$秒后一定有一个点$(13)$右

同时，因为不可能互相穿过，所以每个点的顺序一定不会改

比如$A$一开始在$B$左边紧邻，那$A$永远都在$B$左边紧邻

所以我们只要处理出

左边有点到达的时间，从小到大配对给左边的若干个点，

右边有点到达的时间，从大到小配对给接下来的点，

------------

AC代码：

```cpp
#include<iostream>
using namespace std;
int a[100001];
int b[100001]; 
int c[100001];
int main(){
	int n,l;
	cin>>n>>l;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	int h=0;
	for(int i=1;i<=n;i++){
		if(b[i]==0){//左边到达 
			cout<<a[i]<<" ";
		}
	}
	for(int i=1;i<=n;i++){
		if(b[i]==1){//右边到达 
			cout<<l-a[i]<<" ";
		}
	}
}
```

------------

谢谢观赏！


---

## 作者：Fijian_Bus (赞：8)

一道简单的模拟题。

### 题意：

一条长为 $L$ 的线上有 $n$ 个点。每个点都以每秒一个单位的速度前进，

当迎面碰到另一个点时，这个点立即掉头并前进，求每个点爬出绳子所用的时间。

### 步骤：

**STEP1**：输入很简单。

**STEP2**：枚举两个点相遇掉头：各自改换方向。

（1）起始方向为向东，掉头后向西，距离出口还有 $a[i]$。

（2）起始方向为向西，掉头后向东，距离出口还有 $l-a[i]$。

（3）没有哪一个点爬不出去。

**STEP3**：实现思路


------------
```cpp
#include <iostream>
using namespace std;
int len,n,a[100005],b[100005];
int main()
{
    cin >> n >> len;
    for(int i=1; i<=n; i++)
        cin >> a[i];
    for(int i=1; i<=n; i++)
        cin >> b[i];
    for(int i=1; i<=n; i++)
        if(b[i]==0)
            cout << a[i] << " ";
    for(int i=1; i<=n; i++)
        if(b[i]==1)
            cout << len-a[i] << " ";
    //千万不能一起写，否则会WA
    return 0;
}
```


---

## 作者：ChengJY_ (赞：3)

### 蒟蒻第一篇题解
**传送门 [P6607 [Code+#7]蚂蚁](https://www.luogu.com.cn/problem/P6607)**
------------

- 首先，由于所有蚂蚁始终在运动且不会陷入死循环，因此所有蚂蚁都能爬到终点(也就是说题目的-1是拿来误导的)
- 接下来考虑穿过的情况,由于相遇会立刻反向，点与点之间的相对位置不变，可以看作存在一种特殊的"传递"(虽然时间不同所对的点也不同)
- **example:(图丑不要在意)**
![](https://cdn.luogu.com.cn/upload/image_hosting/9ldb3fwk.png)
因此两点相遇前后一秒也可以看作两点相互穿过
- 综合起来可以发现，假如有一点向东(或西)走，且距离东(或西)x个单位，那么x个单位后必有一个点到达东边(或西边)端点。因此各个点的到达时间都可以确定，只需依次对应输出即可。
- 那么怎么对应呢？以第一个点为例，若向东走，则所需时间即为p[i]。若向西走，没有另一个向东走的点，则为l-p[i]；有点向东走的话，t即为p[向东走的第一个点]。
- 然后即可得出结论，若有向东走的点(a个),则前a个点所需时间以此为这些东走点的p,剩下n-a个点所需时间依次为剩下向西走的点的p。
## AC Code
```c
#include<bits/stdc++.h>
using namespace std;
int n,l,p[100005],dir[100005];
inline int read(){//可以跳过的快读 
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main(){
	n=read();l=read();
	for(int i=1;i<=n;i++)
		p[i]=read();
	for(int i=1;i<=n;i++)
		dir[i]=read();
	for(int i=1;i<=n;i++)
		if(!dir[i])
			printf("%d ",p[i]);
	for(int i=1;i<=n;i++)
		if(dir[i])
			printf("%d ",l-p[i]);
	return 0;
}
```


------------

**add:这题和[P1007 独木桥](https://www.luogu.com.cn/problem/P1007)相似，AC完这题可以~~顺便~~过一下**

---

## 作者：Fire_Raku (赞：1)

**分析题目：**

首先，怎么判断蚂蚁的路程呢？枚举？不行，数据太大。所以，这道题肯定是有规律可寻的。

玄学猜测：我们看到样例，试试不看数据，只用字母代表他们的路程，我们设第一、二、三只蚂蚁距离东数的距离为 $x$，$y$，$z$，绳长为 $l$ 可以看出，第一只蚂蚁的路程是 $z$，第二只是 $l - x$，第三只是 $l - y$，为什么会这样呢？我们可以在举个例子，两只蚂蚁，相向而行，各距离东树 $x$，$y$ 个单位，$x < y$ ，发现，离东树近的蚂蚁路程为 $y$，另一只为 $l - x$，发现了吗？**若有 $n$ 个蚂蚁朝东，则回到东树的蚂蚁为离东树最近的前 $n$ 只。且他们的各自路程与朝东的蚂蚁一一对应**，~~（大家可以试一试，我也试了挺多次qwq~~

如果是这样，就简单了：我们可以先一一输出朝东的蚂蚁距离东树的距离，剩下的就是朝西的，而朝西的路程就是 $l - a_i$。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std ;
int a[100005] , b[100005] ;
int main(){
	int n , l ; 
	cin >> n >> l ;
	for(int i = 1 ; i <= n ; i++) cin >> a[i] ;
	for(int i = 1 ; i <= n ; i++){
		cin >> b[i] ;
	} 
	for(int i = 1 ; i <= n ; i++){
		if(!b[i]) cout << a[i] << " " ;
	}
	for(int i = 1 ; i <= n ; i++){
		if(b[i]) cout << l - a[i] << " " ;
	}
	return 0 ;
}
```

---

## 作者：乐乐乐还在乐 (赞：1)

# P6607 题解

**[题目传送门](https://www.luogu.com.cn/problem/P6607)**

### 题目大意

- 有 $n$ 只蚂蚁在一根细绳上爬行。

- 给定每只蚂蚁的初始位置和方向。（初始位置按顺序给出）

- 每只蚂蚁都以同样的速度向前爬，当迎面碰到另一只蚂蚁时，两只蚂蚁就掉头并继续爬。

- 求它们分别爬下细绳的时间，并按序号输出。

### 分析题目 & 思考算法

这是一道锻炼**模拟算法**的好题目。

显然，蚂蚁相遇掉头时，可以看作互相穿过对方。~~（这是老套路了）~~

**（划重点，要好好理解这句话）** 假设一开始有 $k$ 只蚂蚁朝左，则最后从左边爬下细绳的蚂蚁也必有 $k$ 只。（且这 $k$ 只蚂蚁只能是一开始最左边的 $k$ 只蚂蚁）（右边同理）

那我们只需依次输出每只一开始向左的蚂蚁爬下细绳的时间，

接着输出每只一开始向右的蚂蚁爬下细绳的时间即可。

**~~（讲完了，下课！）~~**

## 附上AC代码


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int n,l;
int a[100005],b[100005]; 

int main(){
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	
	for(int i=1;i<=n;i++)
		if(b[i]==0)
			printf("%d ",a[i]);
	for(int i=1;i<=n;i++)
		if(b[i]==1)
			printf("%d ",l-a[i]);
	return 0;
}
```

---

## 作者：荷叶下 (赞：1)

##### ~~实现简单,但是理解困难?~~
### Part1.题意
####  _相遇问题_ 
#### 两只蚂蚁相向而行,相遇掉头,
####  _对于当前节点来说路程为反方向的路程_ 
#### 1).当起始向东走时,路程为a[i]
#### 2).当起始向西走时,路程为l-a[i]
### Part2.实现
###### ~~有手就行~~
```cpp
#include <bits/stdc++.h>
using namespace std ;
int n, l ;
int a[100100], b[100100] ;
int main()
{
    cin >> n >> l ;
    for(int i = 1 ; i <= n ; ++i)
        cin >> a[i] ;
    for(int i = 1 ; i <= n ; ++i)
        cin >> b[i] ;
    for(int i = 1 ; i <= n ; ++i)
        if(!b[i]) 
            cout << a[i] << " " ;
    for(int i = 1 ; i <= n ; ++i)
        if(b[i])
            cout << l - a[i] << " " ;
    return 0 ;
}
```
[AC](https://www.luogu.com.cn/record/44462892)

---

## 作者：yxy666 (赞：1)

做了几乎 $4$ 道蚂蚁的题目，看到了这道题。

我们先看 $2$ 只蚂蚁的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ml8ptned.png)

那么节点为 $x$ 的路程就是 $L-y$ ,节点 $y$ 的路程就是 $x$ 。
因为首先走到中点再转个方向走回来的距离就是与我对撞的节点到 $L$ 的距离。

我们再看 $3$ 只蚂蚁的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/w5lyqboz.png)

那我们就知道了，对于当前方向的节点就是反方向的路程。也就是我当前距离为 $x$ ,方向是向 $0$ 这边走的。但是我的实际路程是 $L-x$ 。那当前距离为 $x$ ,方向是向 $L$ 这边走的，路程就是 $x$ 。如果这个能想懂就迎刃而解了。

code ：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int N,L,A[maxn],B[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
	while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return ret*f;
}
int main(){
	N=read(),L=read();
	for (int i=1;i<=N;i++) A[i]=read();
	for (int i=1;i<=N;i++) B[i]=read();
	for (int i=1;i<=N;i++)
	  if (!B[i]) printf("%d ",A[i]);
	for (int i=1;i<=N;i++)
	  if (B[i]) printf("%d ",L-A[i]);
	return 0;
}
```


---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15175932.html)

## $\mathsf{Title\space Describe.}$

在东西排布的两棵树之间悬挂着一条长为 $L$ 的细绳，有 $N$ 只蚂蚁在这条绳上。这些蚂蚁希望通过绳子爬到任何一棵树上，但这条绳太细了，导致两只蚂蚁不能并排爬行，也不能交错而过。

它们想到了一个方法：每只蚂蚁都以每单位时间移动一个单位距离的速度不断向前爬，当迎面碰到另一只蚂蚁时，两只蚂蚁都将立即掉头并继续向前爬。现在，蚂蚁们想知道自己是否能爬下绳子，如果能，它们还希望知道自己爬下绳子所花的时间。为了方便，我们按初始时位置从东到西的顺序对蚂蚁从 $1$ 开始编号。



## $\mathsf{Analytical\space thinking.}$

**遇到这种模拟题，千万不能具体地去处理对待，一定要从总体去看待题目。**

比方说这道题，我最初的思路是一只只的蚂蚁地去处理每只蚂蚁，想了个 $O(n^2)$ 的思路，但是 $1\le n\le10^5$，显然不能在 $1$ 秒内通过。

然后我就想啊：

先考虑极端情况：有 $10^5$ 只蚂蚁，这么多蚂蚁，如果一只只去看是在是不科学，如果一只蚂蚁朝向东边，那么直接让它走过去好了——但是如果在它的东边还有蚂蚁怎么办呢？哦，对了，如果遇到的话，那么可以看成是穿过去了（双双掉头就相当于传过去），那就先让朝向东边的蚂蚁走过去，然后我再让这些朝西边的蚂蚁往左边走不就好了？

## $\mathsf{Code.}$

```cpp
//2021/8/23

#include <iostream>

#include <cstdio>

#define debug(c) cerr<<#c<<" = "<<c<<endl

namespace Newstd
{
	inline int read()
	{
		int x=0,f=1;char ch=getchar();
		while(ch<'0' || ch>'9')
		{
			if(ch=='-')f=-1;
			ch=getchar();
		}

		while(ch>='0' && ch<='9')
		{
			x=x*10+ch-'0';ch=getchar();
		}
		return x*f;
	}
	inline void print(int x)
	{
		if(x<0)
		{
			putchar('-');x=-x;
		}
		if(x>9)
		{
			print(x/10);
		}
		putchar(x%10+'0');
	}
}

using namespace Newstd;

using namespace std;

const int ma=100005;

int a[ma],st[ma];

int n,l;

int main(void)
{
	scanf("%d%d",&n,&l);
	
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&st[i]);
	}
	
	for(register int i=1;i<=n;i++)
	{
		if(st[i]==false)
		{
			printf("%d ",a[i]);
		}
	}
	
	//这里要保证面向东边的蚂蚁首先到达，所以分成两个循环
	
	for(register int i=1;i<=n;i++)
	{
		if(st[i]==true)
		{
			printf("%d ",l-a[i]);
		}
	}
	
	return 0;
}
```

---


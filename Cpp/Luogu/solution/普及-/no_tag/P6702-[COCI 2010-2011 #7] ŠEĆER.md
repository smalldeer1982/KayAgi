# [COCI 2010/2011 #7] ŠEĆER

## 题目背景

Mirko 在制糖厂当送货员。

## 题目描述

Mirko 需要向某地的一家糖果店运送 $n$ 颗糖。

Mirko 可以使用两种类型的包装盒子：       
- 一种是可以装 $3$ 颗糖的 $1$ 号包装；           
- 另一种是可以装 $5$ 颗糖的 $2$ 号包装。 

Mirko 想让包装盒尽可能少。例如，他要运送 $18$ 颗糖，则可以使用 $6$ 个 $1$ 号包装。但是，最优策略是 $3$ 个 $2$ 号包装和 $1$ 个 $1$ 号包装。这样总共有 $4$ 个包装。 

请你帮助 Mirko 找到需要包装盒最少的方案。



## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$3 \le  n \le 5000$。

#### 说明

本题满分 $30$ 分。

译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T1 ŠEĆER

## 样例 #1

### 输入

```
4
```

### 输出

```
-1```

## 样例 #2

### 输入

```
9
```

### 输出

```
3```

## 样例 #3

### 输入

```
18
```

### 输出

```
4```

# 题解

## 作者：q_sum (赞：28)

好像还没有人用$O(1)$的算法：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	cin>>n;
	if(n==4||n==7)
	{
		cout<<-1;
		return 0;
	}//这两要特判，否则会WA
    if(n%5==0)
      cout<<n/5;else//如果整除5，那么全部用第二种包装盒
      if(n%5==1)
        cout<<n/5+1;else//如果余数为1，我们把一个②号包装盒替换成两个①号包装盒，总个数增加了1
        if(n%5==2)
          cout<<n/5+2;else//如果余数为2，我们把两个②号包装盒替换成四个①号包装盒，总个数增加了2
          if(n%5==3)
            cout<<n/5+1;else//如果余数为3，我们再加上一个①号包装盒，总个数增加了1
            cout<<n/5+2;//如果余数为4，我们把一个②号包装盒替换成三个①号包装盒，总个数增加了2
    return 0;
}

```
于是就完美的结束啦！

---

## 作者：tZEROちゃん (赞：10)

~~搬题人来水题解。~~

题目翻译应该还是比较清晰的（吧）。

我们知道如果 $n \bmod 5 = 0$，那么显然选择 $2$ 号包装，直接输出 $\dfrac{n}{5}$ 即可，得 $3$ 分。

那么如果 $n \bmod 5 \not= 0$，那该怎么办呢？

显然，我们需要使用尽可能多的 $2$ 号包装，因为他装得比 $1$ 号装得多。

首先，我们选择 $1$ 号包装，使用 `while` 循环，一旦 $n \bmod 5 = 0$，退出循环即可。

如果到最后，$n$ 变成了负数怎么办？

输出 `-1` 即可。


得到代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() 
{
	int n, cnt = 0;
	scanf("%d", &n);
	while (n % 5) n -= 3, cnt++;
	printf("%d", n >= 0 ? n / 5 + cnt : -1);
	return 0;
}
```

然后：

![](https://www.luogu.com.cn/images/congratulation.png)

---

## 作者：YellowEgg (赞：10)

 做法：**动态规划**。
 
 **状态**: $dp_i$ 表示包装 $i$ 颗糖最少需要的包装盒数量。

**状态转移**： $dp_i=\min(dp_i,dp_{i-3}+1,dp_{i-5}+1)$。

**初始化**： $dp_0=0$，其他无穷大。

**答案**：答案极为 $dp_n$。

### code:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define inf 10000007
int n,dp[5005];
int main()
{
	scanf("%d",&n);
	for (int i=1 ; i<=n ; i++)
	    dp[i]=inf;
	dp[0]=0;
	for (int i=1 ; i<=n ; i++)
	{
		if (i>=3) dp[i]=min(dp[i],dp[i-3]+1);
		if (i>=5) dp[i]=min(dp[i],dp[i-5]+1);
	}
	
	if (dp[n]!=inf) printf("%d\n",dp[n]);
	else printf("-1\n");
	
	return 0;
}
```


---

## 作者：wyhm (赞：4)

## 思路：
这道题目就是枚举。

我们可以只枚举一个包装的数量，通过这个包装的数量我们就可以确定另一个包装的数量，可以减少复杂度。

我是从 $0$ 开始，枚举 $3$ 颗糖的包装，因为要让包装的总数少，所以尽量用 $5$ 颗糖的包装，如果枚举 $3$ 颗糖的包装数乘上 $3$ 超过了总数，就说明无法只用 $3$ 颗糖的包装和 $5$ 颗糖包装这些糖，输出 $-1$ 就行了。
## 代码：
```c
#include <stdio.h>
int main()//主函数
{
	int n,s=0;//s用来记录目前3颗糖包装的数量
	scanf("%d",&n);//输入糖的总数
	while(n>=0)//如果枚举3颗糖包装乘3不超过糖的总数
	{
		if(n%5==0)//如果方案成立，也一定是最少的
		{
			printf("%d",s+n/5);//输出答案n是剩下的糖
			return 0;//结束程序
		}
		n-=3;//继续枚举
		s++;//试试多用一个三个糖的包装能否成立
	}
	puts("-1");//枚举完了，还是没找到，输出-1
	return 0;//别忘了
}
```
谢谢大家观赏和管理审核！

---

## 作者：Kvaratskhelia (赞：4)

由题意得，尽量要多使用$2$号包装，这样才使得包装数量尽量小。

那么可以使用一个 while 循环，每次把糖果的数量减去$5$（即使用一个二号包装),若剩下的糖果数量可以被$3$整除，则视为一个合法的方案。

根据上面的条件，设已经使用了$p$个$2$号包装，还剩下$s$个糖果，则可求出使用的包装数$ans=p+\frac{s}{3}$

最后对每次的结果做个最小值判断即可。

code :  （关于$-1$的特判在代码注释中）

```cpp
#include<bits/stdc++.h>
#define ft(i,l,r) for(register int i=l;i<=r;i++)
#define fd(i,r,l) for(register int i=r;i>=l;i--)
using namespace std;
int n,s,ans,p,mn=114514,bo;
int main()
{
	cin>>n;
	if(n==4||n<=2) {cout<<-1;return 0;}
	if(n%5==0) {cout<<n/5;return 0;} //这两个特判应该可以不用加(?，但是这里为了保险
	s=n; //好像还是不用加的 /fad
	while(s>0)
	{
		if(s%3==0) 
		{
			ans=p+s/3;
			if(ans<mn) mn=ans,bo=1;//bo表示有解
		}
		s-=5;ans=0;p++; //注意这些条件要放在最后，不然可能出现样例二(n=9)类似的情况
	}
	if(bo==0) cout<<"-1";
	else cout<<mn;
	return 0;
}
```


---


# [COCI 2010/2011 #7] KOLO

## 题目描述

Mirko 最近购买了一个命运之轮。 他在每个扇形上写了一个大写英文字母，像这样（比如样例 $3$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/c6x5106c.png)


轮中没有字母重复出现，而且轮沿顺时针方向旋转。 

轮旋转时，有一个指针停留在同一位置（上图中指向 `H`）。 当我们旋转盘时，指针所指向的字母相应地发生变化。

Mirko 连续旋转了 $k$ 次，每次都记录了箭头指向的字母改变了多少次，以及旋转结束时所指的字母。

Slavko 找到了那张纸，她想知道 Mirko 在车轮的扇形上写了些什么。另外，扇形的总数是已知的。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$2 \le n \le 25, 1 \le k \le 100, 1 \le s \le 100$。

#### 说明

本题满分 $50$ 分。

译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T2 KOLO

## 样例 #1

### 输入

```
3 3
1 A
2 B
3 C
```

### 输出

```
!```

## 样例 #2

### 输入

```
5 6
1 A
2 B
5 B
1 C
2 A
2 B
```

### 输出

```
B?A?C```

## 样例 #3

### 输入

```
8 8
4 V
3 I
7 T
7 A
6 R
5 N
1 O
9 H
```

### 输出

```
HONITAVR```

# 题解

## 作者：Halberd_Cease (赞：14)

[P6703 KOLO](https://www.luogu.com.cn/problem/P6703)
# 分析与解
**一道经典的模拟**


## 分析
### 注意事项：
1. 首先 **轮中没有字母重复出现**；

2. 然后 **轮沿顺时针方向旋转**；说明

3. 最后 **从最后一次旋转结束时的尖头字母开始，然后顺时针方向输出**；

综上所述，我们总结出如下几点：

1. 如果有同一个字母在不同位置出现即不成立

2. 如果同一位置有不同字母出现即不成立

3. 指针沿**逆时针**转动，而需要**顺时针**输出

## 解
### 步骤一：读入+不成立判断

没有必要详解，附代码：

```cpp

	cin>>n>>k; 
	for(i=1;i<=k;i++)
	{
		cin>>s>>c;
		x=(x+s)%n;//指针更新
		if(ans[x]!=0&&int(c)!=ans[x]||f[c]&&ans[x]!=int(c))
      		/*不成立条件：
            		1.该位置有不同字母
                	2.该字母已出现且不在当前位置
                */
		{
			cout<<'!';return 0;//判断不成立，结束
		}
		ans[x]=int(c);//设置
		f[c]=1;//已使用
	}
	
```

### 步骤二：输出
由题意可得：由指针x开始反序输出，
所以说，要分两段输出

如果```ans[i]```	没有值（没有赋值）那么输出```?```

附代码：
```cpp
	for(i=x;i>=0;i--)
	if(ans[i]!=0)cout<<char(ans[i]);//第一段
	else cout<<'?';
	for(i=n-1;i>=x+1;i--)
	if(ans[i]!=0)cout<<char(ans[i]);//第二段
	else cout<<'?';
```
## 完整代码
快看！
```cpp
#include<bits/stdc++.h>
using namespace std;
char c;
int f[128],ans[26],s/*改变次数*/,k/*转向次数*/,i,j,n/*转子数*/,x/*指针*/; 
int main()
{
	cin>>n>>k; 
	for(i=1;i<=k;i++)
	{
		cin>>s>>c;
		x=(x+s)%n;
		if(ans[x]!=0&&int(c)!=ans[x]||f[c]&&ans[x]!=int(c))
		{
			cout<<'!';return 0;
		}
		ans[x]=int(c);
		f[c]=1;
	}
	for(i=x;i>=0;i--)
	if(ans[i]!=0)cout<<char(ans[i]);
	else cout<<'?';
	for(i=n-1;i>=x+1;i--)
	if(ans[i]!=0)cout<<char(ans[i]);
	else cout<<'?';
  	return 0;
}
```


---

## 作者：wyhm (赞：5)

## 思路：
这道题目按照题目说的模拟就可以了。

我们需要处理几个重点：

$1.$每个字母只可以使用一次，我们要把它是否用过记下来。

$2.$如果转到了一个地方，颜色和这个相同就还是合法的。

$3.$输出要从它到 $0$ ，然后从倒数第二个到它加一的值。
## 代码：
```c
#include <stdio.h>
int n,k,ans[31],f=0,s;//楔子数，旋转数，答案，当前位置，转的次数
char c,p[31];//当前字母，判断是否使用
int main()
{
	scanf("%d%d",&n,&k);//输入楔子数，旋转数
	for(int i=0;i<n;i++)//赋初始值，开始全部都是未知的
		ans[i]='?';//赋值
	for(int i=1;i<=k;i++)//循环
	{
		scanf("%d %c",&s,&c);//输入旋转次数和输入字符
		f=(f+s)%n;//更新位置
		if((ans[f]!='?'&&ans[f]!=c)||(p[c-'A']==c&&ans[f]!=c))//判断是否成立
		{
			printf("!");//不成立输出感叹号
			return 0;//结束程序
		}
		p[c-'A']=c;//这个字符用过了
		ans[f]=c;//更新答案
	}
	for(int i=f;i>=0;i--)//从当前位置到0
		printf("%c",ans[i]);//输出答案
	for(int i=n-1;i>=f+1;i--)//从倒数第二个数的它后面那个数
		printf("%c",ans[i]);//输出答案
	return 0;//别忘了
}

```
谢谢管理审核和大家观赏！

---

## 作者：mzyc_jx (赞：4)

[P6703 KOLO](KOLOhttps://www.luogu.com.cn/problem/P6703)

## 思路：

此题按照题目说的模拟就可以了，~~非常适合蒟蒻~~。

**以下几点需要注意：**

1. 每个字母只能使用一次，如果有**同一个字母**在**不同位置**出现即不合法。

2. 如果**同一位置**有**多个字母**出现即不合法。

3. 输出时需要**顺时针**输出。


### CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[51];//a数组用来存答案
int b[51];//b数组用来检查字符是否重复
int main()
{
	ios_base::sync_with_stdio(0);//据说能让cin&cout提速
	cin.tie(0);//同上
	cout.tie(0);//同上
	int n,k,x;//楔子数，旋转数，当前位置
	cin>>n>>k;
	for(int i=0;i<n;i++)//因为最开始所有字符都是未知的，
	a[i]='?';//所以全部赋值为'?'
	for( ;k>0;k--)//=while(k--)
	{
		int s;
		char c;
		cin>>s>>c;
		x=(x+s)%n;//更新现在的位置
		if((a[x]!=c&&a[x]!='?')||(b[c-65]==c&&a[x]!=c))
      		//判断是否合法
		{
			cout<<"!";//不合法输出感叹号
			return 0;//结束程序
		}
		b[c-65]=c;
		a[x]=c;//将答案更新
	}
	for(int i=x;i>=0;i--)//输出从当前位置到0的答案
	cout<<a[i];
	for(int i=n-1;i>x;i--)//输出从倒数第二个数的它后面那个数的答案
	cout<<a[i];
	return 0;
}
```



---

## 作者：Gorenstein (赞：2)

[P6703 [COCI2010-2011#7] KOLO](https://www.luogu.com.cn/problem/P6703)



------------
# 解题思路



题目大意：有一个转盘。我们需要通过题目给出的信息：每次转动后指针指向的字母变化了多少格，以及这次转动后最终停留到的位置来确定转盘上的字母。

因此，我们可以根据题目上的转法来模拟。

每次转到一个位置，我们先看看和不合法。如果是合法的，那么把这个位置的字母确定下来；如果不合法，那么输出 ``!`` ，然后程序结束。

确定好思路之后，写代码就简单了。

注意以下两个问题：

- 每个字母只能用一次。但是如果多次转到相同的位置，那么不能判定为不合法（因为当个位置的字母不可能变来变去）。

- 因为我们转的时候是顺时针，但指针是静止的。所以相对于转盘来说，指针在逆时针运动。所以如果我们以指针指向的扇形换了多少个来存数组的话，输出要倒序。

------------
# 代码实现


#### 1.定义

- 考虑使用一个字符数组来存储转盘上的数。初始的时候，所有数字都没确定，所以全部初始化为“?”。

- 用一个bool型数组存储某个字母有没有用过。

- 在转的时候，用一个变量now来表示指针当前的位置。

```cpp
int n,k;
char a[100005];
int used[55];
int now=0;
```

#### 2.转动过程

因为数字盘成了环，所以很自然的想到用取模运算来控制。

在指针当前指向的now位置的时候，每次转动了s格，那么现在的位置都是 ``(now+s)%n`` 。

如果转盘合法，则确定下当前位置的字符，然后标记这个字母使用过。

#### 3.判断是否合法

1. 如果当前指针指向的字符已经使用过了，**并且这个位置之前没有存放过相同的字符**，那么就不合法。（如果这个位置之前存过相同的字符，表示这个位置被再一次指到，这是是合法的）

```cpp
if(used[c-'A']==c&&a[now]!=c){cout<<'!';return 0;}
```

2. 如果当前指针指向的位置已经有了字符，并且与这一次输入的c不同，那么发生冲突了，肯定不合法。

```cpp
if(a[now]!=c&&a[now]!='?'){cout<<'!';return 0;}
```

#### 输出方式

因为我们存数组的时候是以相比最开始指向的位置，当前指针往后指了多少个作为数组存储的顺序的，因为转盘顺时针，所以相对于转盘来说，指针在逆时针运动。而我们要顺时针输出，所以要倒序。

具体实现就是先把最后指向的位置到数组第一位数除一遍，再从最后一个位置输出到最后指向的位置。

```cpp
for(int i=now;i>=0;i--)cout<<a[i];
for(int i=n-1;i>now;i--)cout<<a[i];
```



------------
# 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
char a[100005];//表示转盘上的字母
int used[55];//used_i从A开始表示第i-1个字母有没有使用过。（之所以是第i-1是因为数组下标从0开始）
int main(){
	cin>>n>>k;
	for(int i=0;i<n;i++)a[i]='?';//一开始所有字母都不确定，初始化为?
	int now=0;//表示转到哪个位置
	while(k--){
		int s;//转过多少个扇形
		char c;//指向的字母
		cin>>s>>c;
		now=(now+s)%n;//更新当前的位置
		if(a[now]!=c&&a[now]!='?'){cout<<'!';return 0;}//如果现在指向的字母和统一位置之前找到的字母不一样，不合法
		if(used[c-'A']==c&&a[now]!=c){cout<<'!';return 0;}//如果这个字母重复使用了，不合法
		used[c-'A']=c;//记录字母c使用过
		a[now]=c;//确定了当前位置的字母
	}
	for(int i=now;i>=0;i--)cout<<a[i];//倒序输出，这里还不理解可以自己画一下图
	for(int i=n-1;i>now;i--)cout<<a[i];
	return 0;
}
```


---

## 作者：mzyc_pzx (赞：1)

#### 本题用模拟就行

## 重点：

1.每个字母只能使用一次，判断是否用过。

2.颜色相同就合法。

3.输到 0 再结束，然后再从倒数第二个开始输出。

### 程序
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[51],z;
int b[51],n,k,x,y;
int main()
{
	cin>>n>>k;
	for(int i=0;i<n;i++)
	a[i]='?';
	while(k--)
	{
		cin>>y>>z;
		x=(x+y)%n;
		if((b[z-'A']==z&&a[x]!=z)||(a[x]!=z&&a[x]!='?'))
		{
			cout<<"!";
			return 0;
		}
		b[z-65]=z;
		a[x]=z;
	}
	for(int i=x;i>=0;i--)
	cout<<a[i];
	for(int i=n-1;i>x;i--)
	cout<<a[i];
	return 0;
}
```


---

## 作者：hyc1026 (赞：0)

这道题是一道模拟题。根据题意模拟即可轻松通过。

### 思路

- 如果有两个字母在同一个地方不合法。
- 如果相同字母在不同地方不合法。
- 轮盘顺时针转动相当于指针逆时针转动，但输出要顺时针输出。
- 直接模拟即可。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;

char a[50];
int x[50];

int main()
{
    int n,k;
    cin >> n >> k;
    int now = 0;
    memset(a,'?',sizeof(a)); //memset数组，写起来比for更快(TLE我不管）
    while(k--)
    {
        int s;
        char ch;
        cin >> s >> ch;
        now = (now + s) % n; //更新
        if((a[now] != '?' && a[now] != ch) || (x[ch-65] == ch && a[now] != ch)) //判断合法
        {
            cout << "!";
            return 0; //直接退出程序
        }
        a[now] = x[ch-65] = ch; //更新
    }
    for(int i=now; i>=0; i--) cout << a[i];
    for(int i=n-1; i>now; i--) cout << a[i]; //输出
    return 0;
}
```

---


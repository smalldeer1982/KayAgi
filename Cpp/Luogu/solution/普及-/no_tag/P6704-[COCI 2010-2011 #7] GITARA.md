# [COCI 2010/2011 #7] GITARA

## 题目背景

Darko 有一个想象的外星朋友，他有十亿根手指。外星人快速拿起吉他，在网上找到一段简单的旋律并开始弹奏。

这个吉他像寻常一样有六根弦，令其用 $1$ 到 $6$ 表示。每根弦被分成 $P$ 段，令其用 $1$ 到 $P$ 表示。

旋律是一串的音调，每一个音调都是由按下特定的一根弦上的一段而产生的（如按第 $4$ 弦第 $8$ 段）。如果在一根弦上同时按在几段上，产生的音调是段数最大的那一段所能产生的音调。

例：对于第 $3$ 根弦，第 $5$ 段已经被按，若你要弹出第 $7$ 段对应音调，只需把按住第 $7$ 段，而不需放开第 $5$ 段，因为只有最后的一段才会影响该弦产生的音调(在这个例子中是第 $7$ 段)。类似，如果现在你要弹出第 $2$ 段对应音调，你必须把第 $5$ 段和第 $7$ 段都释放。

请你编写一个程序，计算外星人在弹出给定的旋律情况下，手指运动的最小次数。

## 题目描述

你有一个 $6 \times P$ 的矩阵 $A$，初始状态皆为 $0$。

对于所有要求 $(i,j)$

你需要满足要求：

1. 此时 $A_{i,j}$ 状态为 $1$。

2. 对于 $A_{i,j+k} (k>0)$ 状态为 $0$。

你在满足要求的情况下需要求状态转换最小次数。

## 说明/提示

#### 样例 1 解释
所有的音调都是由第二根弦产生的。首先按顺序按 $8$ $10$ $12$ （$count=3$）。然后释放第 $12$ 段（$count=4$）。最后，按下第 $5$ 段，释放第 $8$ $10$ 段 （$count=7$）。

#### 样例 2 解释 
对于每个操作，分别需要 $1$ $1$ $1$ $1$ $3$ $0$ $2$ 次手指运动。

#### 数据规模及约定


按下或释放一段弦各计一次手指运动。弹弦不算手指的移动，而是一个弹吉他的动作。（指你不需要管他怎么弹的，只需要按就是啦，说不定他可以用超能力呀）

对于 $100\%$ 的数据 $n \le 5 \times 10^5$ ，$2 \le P \le 3 \times 10^5$

#### 说明

本题满分 $70$ 分。

译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T3 GITARA


## 样例 #1

### 输入

```
5 15
2 8
2 10
2 12
2 10
2 5```

### 输出

```
7```

## 样例 #2

### 输入

```
7 15
1 5
2 3
2 5
2 7
2 4
1 5
1 3```

### 输出

```
9```

# 题解

## 作者：LikeJ (赞：25)

## 观前提示

## [博客食用更加](https://blog.csdn.net/weixin_45524309/article/details/108541871)

## [题目传送门](https://www.luogu.com.cn/problem/P6704)
这题可以利用**栈**的思想

将**每一种弦都用一种栈（本人太蒟，不会用STL）**

如果有数进来时

就和**栈顶**比较大小

如果**栈顶>进来的数**

就要**出栈**

**注意：**

**当 $1\quad 5\quad 1\quad 6\quad 1\quad 5$ 时，虽然已经按过 $1\quad 5$，但是也要先松开 $1\quad 6$ 的键，然后可以不用按 $1\quad 5$ （用其他方法的小朋友们！敲黑板！做笔记！）**

接下来是**AC代码（有注释）**

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,p,x,y,s,sum[7],a[7][300005];
int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		while(sum[x]>=1&&a[x][sum[x]]>y)//判断栈是否空，还有比较栈顶
		{
			sum[x]--;//减减
			s++;//累加次数	
		}
		if(a[x][sum[x]]==y)continue;//如果与栈顶相同就跳过
		a[x][++sum[x]]=y;//入栈
		s++;//累加次数
	} 
	printf("%d",s);//输出次数
	return 0;
} 
```


**谢谢**

---

## 作者：Daidly (赞：11)

[更好的阅读体验](https://www.luogu.com.cn/blog/271736/solution-p6704)

[【不会栈的可以先看看这个】](https://www.luogu.com.cn/blog/271736/ji-chu-shuo-ju-jie-gou)

这道题的标签是`栈`，所以这篇代码是STL的栈。

先讲一下思路：

- 我们可以用一个栈来储存一个弦的各个段，记为`stack<int>s[7];`因为有$6$个弦。

- 因为可能有一个音调要可松开多次，所以用一个`while`循环，每一次循环弹出栈顶，其条件为**栈不为空**和**栈顶值大于段号**。

- 特判当栈顶与段号相同时，直接跳过。

- 注意：不能直接写`if(s[a].top()==b)`，要提前特判栈中有没有值，如果没有的话，这样做会报错。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,a,b,ans=0;
stack<int>s[7];
int main(){
	cin>>n>>p;
	for(int i=1;i<=n;++i){
		cin>>a>>b;
		while(s[a].size()>0&&s[a].top()>b){
		    ans++;
		    s[a].pop();
	    }
	    if(s[a].size()>0){
	    	if(s[a].top()==b){
	            continue;
			}else{
				ans++;
				s[a].push(b);
			}
		}else{
			ans++;
			s[a].push(b);
		}
	}cout<<ans;
	return 0;
}
```
希望通过，谢谢！

---

## 作者：Jsxts_ (赞：6)

奉上一种STL的[栈](https://blog.csdn.net/gzu_zb/article/details/89886114?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159849934719724846428581%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159849934719724846428581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-89886114.first_rank_ecpm_v3_pc_rank_v2&utm_term=STL+%E6%A0%88&spm=1018.2118.3001.4187)做法。
***

建六个栈，代表每一根弦上的音调。

对于每次输入，如果栈顶比它小，就进栈，否则一直弹栈直到栈顶的数小于等于它。每次弹栈或进栈都要累计答案，最后输出即可。

（我竟然还调了很久）

代码（~~自认为马蜂不错~~）：

```cpp
#include <cstdio>
#include <iostream>
#include <stack>
using namespace std;
stack<int> st[7];//六根弦的音调 
int main() {
	int n,p,ans = 0;
	scanf("%d%d",&n,&p);
	for (int i = 1;i <= n;i ++ ) {
		int x,y;
		scanf("%d%d",&x,&y);
		while (st[x].size() && st[x].top() > y) {
			ans ++;//栈顶比当前的大，就一直弹栈 
			st[x].pop();
		}
		if (st[x].size()) {//栈里还有数 
			if (st[x].top() == y) continue;
			//栈顶相同就直接跳过 
			ans ++;
			st[x].push(y);
		}
		else {
			//栈为空就直接进栈 
			ans ++;
			st[x].push(y);
		}
	}
	printf("%d",ans);//输出，结束 
	return 0;
}
```


---

## 作者：wyhm (赞：4)

## 思路：
这道题目我们可以使用优先队列做，是一道很好的堆的入门题。

优先队列也就是priority_queue,是一种数据结构，它能取出当中的最大值或最小值，默认是最大值。

现在简单介绍一下堆，也就是优先队列。

最常用的就是这几个功能:top,pop,push。

现在来讲讲它们的功能：

top,第一个数，可以实现这道题目中是否继续弹出。

pop,弹出第一个数，可以在题目中实现外星人松弦的动作，从高往低。

size,里面有多少个数，这里确定外星人手指按住的个数。

push,插入一个数，我们可以通过插入来实现外星人按弦的动作，代码中插入正数是来确定最大值，如果插入这个数的相反数，我们取出来的就是最小值，应为原来最大的数取相反数就成了最小的，原来最小的数取了相反数就是最大的了。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	priority_queue<int> q[11];//我们开一个数组，来模拟每一根弦
	int n,p,ans=0,i,j;//操作上，段数，答案，输入的需要演奏的音
	scanf("%d%d",&n,&p);//输入操作数，段数，段数没有
	for(int k=1;k<=n;k++)//用k来，i,j被占了
	{
		scanf("%d%d",&i,&j);//输入要演奏的音
		while(q[i].size()>0&&q[i].top()>j)//当还有手指，如果空了再pop,top会导致RE
		{
			q[i].pop();//弹出
			ans++;//操作数加一
		}
		if(q[i].size()==0||q[i].top()!=j)//判断是否空了，或者最前面那个数比要演奏的音小，判断是否还要按
		{
			q[i].push(j);//插进去
			ans++;//答案加一
		}
	}
	printf("%d",ans);//输出答案
	return 0;//别忘了
}

```
谢谢管理审核，谢谢大家观赏！

---

## 作者：小坦克 (赞：2)

# 在[博客](https://www.luogu.com.cn/blog/TXZZ/solution-p6704)上看更好哦！！！
-------
## [题目传送门](https://www.luogu.com.cn/problem/P6704)
--------
### **思路演义**：

这题就是 ***栈*** 的思想，将 ***每一种弦*** 都用 ***一种栈*** ，如果有数进来时，就和栈顶比较大小，如果栈顶 ***大于*** 进来的数，就要 ***出栈*** 。

---------
### $Code$:
```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std;
int n,m,s;
int xuan[7];
int a[7][300005];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		while(xuan[x]>=1&&a[x][xuan[x]]>y){
			xuan[x]--;
			s++;
		}
		if(a[x][xuan[x]]==y) continue;
		a[x][++xuan[x]]=y;
		s++;
	} 
	cout<<s;
	return 0;
} 
```
--------
## 谢谢大家

---

## 作者：y0y68 (赞：1)

$\texttt{vector}$ 或优先队列的水题

难度：橙 $\sim$ 黄

下面介绍一种 $\texttt{vector}$ 做法

需要的 $\texttt{STL}$ 函数：

1. $insert(pos,num)$：在 $\texttt{pos}$ 位置插入值为 $\texttt{num}$ 的数

2. $insert(num)$：直接插入值为 $\texttt{num}$ 的数

3. $upper\_bound(begin,end,num)$：从 $\texttt{begin}$ 位置到 $\texttt{end-1}$ 位置二分查找第一个**大于** $\texttt{num}$ 的数字，找到返回该数字的地址，不存在则返回 $\texttt{end}$。

**注**：返回的值需用迭代器来存。

4. $lower\_bound(begin,end,num)$：从 $\texttt{begin}$ 位置到 $\texttt{end-1}$ 位置二分查找第一个**大于等于** $\texttt{num}$ 的数字，找到返回该数字的地址，不存在则返回 $\texttt{end}$，且和 $upper\_bound$ 一样都返回迭代器。

5. $begin()$：查询一个 $\texttt{vector}$ 的起始位置，返回迭代器。

6. $end()$：查询一个 $\texttt{vector}$ 的结束位置，返回迭代器。

7. $find(begin,end,num)$：从 $\texttt{begin}$ 位置到 $\texttt{end-1}$ 位置查找第一个值为 $\texttt{num}$ 的位置

8. $count(begin,end,num)$：从 $\texttt{begin}$ 位置到 $\texttt{end-1}$ 位置查找值为 $\texttt{num}$ 的位置的个数

9. $erase(num)$：删除值为 $\texttt{num}$ 的数

10. $erase(begin,end)$：删除 $\texttt{begin}$ 到 $\texttt{end-1}$ 位置的数

代码：

```
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ans;
vector<int>v[10];
int main(){
	cin>>n>>m;
	while(n--){
		int x,y;scanf("%d%d",&x,&y);
		vector<int>::iterator it=upper_bound(v[x].begin(),v[x].end(),y);//建迭代器，指向第一个比y大的数
		if(it==v[x].end()){//如果找不到比y更大的数
			if(find(v[x].begin(),v[x].end(),y)==v[x].end())//如果没有重复
            			ans++,v[x].insert(v[x].end(),y);//答案加1，末尾插入
		}
		else{
			ans+=v[x].end()-it+1;//答案加删去的数的个数+1，因为还要加上自己
            		v[x].erase(it,v[x].end());//将比y大的数删了
			if(count(v[x].begin(),v[x].end(),y))ans--;//如果有重复，就多算了自己，所以答案-1
			else v[x].insert(v[x].end(),y);//没有重复就将y插入到最后
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Demoe (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P6704)

~~嗯 题目我的翻译应该还蛮清楚的。~~

## 题意

- 给定一个 $6 \times P$ 的矩阵 $A$，初始值皆为 $0$。

- 对于所有要求 $(i,j)$ ，你需要满足要求：

- $A_{i,j}=1$ 且 $A_{i,j+k}=0 (k>0)$。

- 你在满足要求的情况下需要求状态转换**最小**次数。

## Sol

可以有很多 DS 去维护这个东西，大家写了 $\texttt{priority}$_$\texttt{queue}$ $\texttt{vector}$ $\texttt{set}$ 。

但是没有比我手写 $\texttt{stack}$ 快的。（

共 $6$ 行，因为每一行与其它行无关，容易想到对于每一行分别维护。

建 $6$ 个 $\texttt{stack}$ ，每次操作时，从栈顶向下遍历。

- 如果栈顶元素大于询问值，不断弹出。

- 如果等于，结束操作。

- 如果小于，将询问值扔到栈里。

同时更新答案即可。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=3e5+5;
ll n,p,s[10][N],cnt[10],ans;
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(p);
	for(ll i=0,x,y;i<n;i++){
		rd(x);rd(y);
		while(cnt[x])
			if(s[x][cnt[x]-1]==y) break;
			else if(s[x][cnt[x]-1]<y){s[x][cnt[x]]=y;cnt[x]++;ans++;break;}
			else cnt[x]--,ans++;
		if(cnt[x]==0) s[x][0]=y,cnt[x]++,ans++;
	}
	wr(ans);puts("");
	return 0;
}

```

---

## 作者：SingularPoint (赞：1)

题目描述中已经把大意说的很清楚了~
### 分析
弦数固定只有六根，然后就是考虑每根弦上的操作：对于每一个音调，必须保证在它前面已经被按下的段落中其段数最大。由此，我们可以考虑**维护六个栈结构，每个栈代表一根弦**。进栈时，**如果栈尾的段数比即将进栈的 j 大，栈尾出栈**，直到栈尾的段数小于等于将要进栈的段数 j，若小于，新段数进栈，若等于，转向下一个要求$(i,j)$。

~~其实就是一个很直接的模拟啦~~~

分析完成，接下来上代码！
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p;
int a[6][500005],q[6];//a数组代表栈，p数组指向对应的每个栈的栈尾 
int ans=0;
int main()
{
	scanf("%d%d",&n,&p);
	int x,y;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x,&y);
		x--;//为了节省空间将所有的弦数减一储存 
		while(a[x][q[x]]>y){//栈尾段数较大的出栈 
			q[x]--;
			ans++;
		}
		if(a[x][q[x]]<y){//新元素进站（需要动手指呦~） 
			a[x][++q[x]]=y;
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
 } 
```
完结撒fa~

---


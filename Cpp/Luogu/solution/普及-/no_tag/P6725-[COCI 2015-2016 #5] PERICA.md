# [COCI 2015/2016 #5] PERICA

## 题目描述

给定一个长度为 $N$ 的序列 $a_1,a_2,\dots,a_N$。

请你求出所有 $K$ 个数的组合中最大数之和 $\bmod\ 10^9+7$ 的结果。

## 说明/提示

#### 样例解释

##### 样例 $1$

所有的 $K$ 个数的组合为：$[2, 4, 2], [2, 4, 3], [2, 4, 4], [2, 2, 3], [2, 2, 4], [2, 3,
4], [4, 2, 3], [4, 2, 4], [4, 3, 4], [2, 3, 4]$。

#### 数据规模与约定

对于 $40\%$ 的数据，$N\le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le 10^5$，$1\le K\le 50$。

#### 说明

**题目译自 [COCI2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #5](https://hsin.hr/coci/archive/2015_2016/contest5_tasks.pdf) *T3 PERICA***。

## 样例 #1

### 输入

```
5 3
2 4 2 3 4```

### 输出

```
39```

## 样例 #2

### 输入

```
5 1
1 0 1 1 1```

### 输出

```
4```

## 样例 #3

### 输入

```
5 2
3 3 4 0 0```

### 输出

```
31```

# 题解

## 作者：zhangzirui66 (赞：2)

由于和**最值**有关，可以先升序排序。排序后对于每个数 $a_i$，没有哪个数 $a_j$ 满足 $j<i$，$a_j \ge a_i$

对于每个数 $a_i$，会贡献 $C^{k-1}_{j-1}$ 次，因为我们要在前 $i$ 个数中选 $k$ 个数，由于 $a_i$ 必须选，也就是在前 $i-1$ 个数中选 $k-1$ 个数。

每次贡献的值？显然是 $a_i$ 所以单个 $a_i$ 的贡献值为
$$
C^{k-1}_{j-1}\times a_i
$$
总答案为
$$
\sum_{i=1}^{n}C^{k-1}_{j-1}\times a_i
$$

关于组合数，可以用[递推法](https://blog.csdn.net/m0_37149062/article/details/122522676)求出。

**Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, ans, a[100005], c[100005][55];
int main(){
	cin >> n >> k;
	c[0][0] = 1;
	for(int i = 1; i <= n; i ++){
		c[i][0] = 1;
		for(int j = 1; j <= min(i, k); j ++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % 1000000007;//最多只有C[n][k]，取个min值
	}
	for(int i = 1; i <= n; i ++) cin >> a[i];
	sort(a + 1, a + n + 1);
	for(int i = k; i <= n; i ++) ans = (ans +(1ll * c[i - 1][k - 1] * a[i] % 1000000007)) % 1000000007;
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Bai_Kking (赞：2)

# 题解 P6725 [COCI2015-2016#5] PERICA

建议评绿

前置知识：排序，组合数，逆元。

## 题目描述

给定一个长度为 $N$ 的序列 $a_1,a_2,\dots,a_N$。

请你求出所有 $K$ 个数的组合中最大数之和 $\bmod\ 10^9+7$ 的结果。

## 思路

由题意，求每个 $K$ 组合数中的最大值。

若直接枚举出所有的组合数，将是 $C_n^k$ 的复杂度，这明显是不可接受的复杂度。

所以我们考虑逆向思维，若我们已知当前的最大值，那就只须求有**多少**组合数包含它。

这就是本题的核心思路：对原序列**排序**（**降序**），对于排好序的每一个 $a_i$，它后面的数都是小于它的（说明它可以统领后面的所有组合数），这样只需对于后面的 $n-i$ 个数选 $k-1$ 个数，即对于 $a_i$，它对答案的贡献为
$$
a_i\times C_{n-i}^{k-1}
$$
则答案为：
$$
ans=\sum_{i=1}^{n-k+1}a[i]\times C_{n-i}^{k-1}
$$
那么问题就转化为如何求组合数 $C_{n-i}^{k-1}$ 了。

看了很多dalao的题解，发现都是预处理阶乘，这里提供一个更暴力的方式。

可以看到数据范围 $1\le K\le 50$，考虑暴力求组合数，公式为：
$$
C_n^m={{n!}\over{m!(n-m)!}}
$$
但是因为要取模，所以要求逆元，那我们可以直接用费马小定理（这里就不展开了）。

------

最后附上代码（可能有点慢，因为是暴力求组合数）

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline void read(int &x){
	char c=getchar();x=0;int f=0;
	for(;!isdigit(c);c=getchar()) f|=(c=='-');
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);
	x=f?-x:x;
}
const int N = 1e5+5,MOD = 1e9+7;
int n,k;
int a[N];
int fastPow(int a,int b){
	int ans=1;
	int tmp=a;
	while(b){
		if(b&1) ans=ans*tmp%MOD;
		tmp=tmp*tmp%MOD,b>>=1;
	}
	return ans;
}
int C(int n,int m){
	if(m>n) return 0;
	int ans=1;
	for(int i=1;i<=m;i++){
		int a=(n-m+i)%MOD,b=i%MOD;
		ans=ans*(a*fastPow(b,MOD-2)%MOD)%MOD;
	}
	return ans;
}
bool cmp(int a,int b){
	return a>b;
}
signed main(){
	read(n);read(k);
	for(int i=1;i<=n;i++) read(a[i]);
	sort(a+1,a+1+n,cmp);
	int ans=0;
	for(int i=1;i<=n-k+1;i++){
		ans+=C(n-i,k-1)*a[i];
		ans%=MOD;
	}
	printf("%lld",ans);
	return 0;
}
```

比较简单一道题，不过涉及到一些数学知识，建议评绿。

完结撒花~

---

## 作者：muyang_233 (赞：2)

[原题传送门](https://www.luogu.com.cn/problem/P6725)  

由于和最值有关，我们不妨先 **升序排序** 。  

枚举每个最大数，对于每个数 $a_i$ ，我们选取的 $k$ 个数中，肯定 不会有哪个数 $a_j$ 满足 $j>i$ ，因为排序后若 $j>i$ ，肯定有 $a_i\le a_j$ ，$a_i$ 就不是最大值了。  

然后我们要在前 $i$ 个数中选出 $k$ 个，又 $a_i$ 作为最大值一定被选，故其实要求的是在前 $i-1$ 个数中选出 $k-1$ 个，也即 $C_{i-1}^{k-1}$ ，此时对答案的贡献即为:  
### $C_{i-1}^{k-1}*a_i$ 。  

另外，关于组合数，用杨辉三角预处理即可。  
 
代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define ll long long
#define mod (int)(1e9+7)
int n,k;
int ans;
int a[100005];
int c[100005][55];
inline int min(int a,int b){
	return a<b?a:b;
}
void init(){//预处理组合数
	c[0][0]=1;
	for (int i=1;i<=n;i++){
		c[i][0]=1;
		for (int j=1;j<=min(i,k);j++){//注意最大只有C[n][k]，所以循环的时候到min(i,k)能有大幅度优化
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}
}
int main(){
	scanf("%d%d",&n,&k);
	init();
	for (int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);//升序排序
	for (int i=k;i<=n;i++){
		ans=(ans+(1ll*c[i-1][k-1]*a[i]%mod))%mod;//c[i-1][k-1]*a[i]
//		printf("%d ",1ll*c[i-1][k-1]*a[i]%mod);
	}
//	puts("");
	printf("%d",ans);
	return 0;
}

```

~~这里有AC代码哦，但我相信你不会抄题解的！~~

---

## 作者：LinkZelda (赞：2)

- ### **前言**:

题意十分简单明了，我们就直接来讲做法吧 ( **注意一下，题目说的是组合而不是排列** )

- ### 做法: 

观察到题目只是要求最大值的和，所以我们首先可以对所有值降序 $sort$ 一下。然后，我们发现对于第 $i$ 位是组合中最大值的情况数就是从剩下未选的数中选 $(k-1)$ 个数，即 $C_{n-i}^{k-1}$ 种。


然后所以答案就是排序后的数列求 :
$$
\sum_{i=1}^n a_i \times C_{n-i}^{k-1} 
$$


- ### 怎么求组合数可以更快？( 递归 )

我们发现，如果直接递归求组合数，那么一共要花 $O (n^2 k)$ 的时间，十分浪费。

我们可以用记忆化的思想，开一个数组来记住已经求过的组合数，然后就可以将时间降到 $O ( nk )$。

- ### 代码如下:

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int Mod=1000000007;
int n,k,C[100005][55],a[100005],ans=0;

bool cmp(int a,int b) //自定义降序排序 
{
	return a>b;
}

int c(int i,int j) //计算组合数，加上记忆化 
{
	if(i==0||i<j)return 0;
	if(i==j||j==0)return 1;
	if(C[i][j])return C[i][j];
	return C[i][j]=(c(i-1,j)+c(i-1,j-1))%Mod;
 } 
 
void init() //输入 
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",a+i);
}
 
void work() //主要代码在此 ！ 
{
	sort(a+1,a+n+1,cmp);
	
	for(int i=1;i<=n;i++)
		ans=(ans+((long long)a[i]*c(n-i,k-1))%Mod)%Mod;//这里一定要将 ai * c(i,j) 先化为long long 然后再模，不然会WA
		
	printf("%d",ans); 
 } 
 
int main()
{
	init();
	
	work();
	return 0;
}
```
~~这次的 LaTeX 不会挂了吧~~

---

## 作者：Indestructible (赞：1)

本题和最值有关，与顺序无关，所以可以先进行**升序排序**。排序后，对于任意的 $j<i$，都有 $a_j\le a_i$。假设选择了 $a_i$ 为最大值，那么只需在 $a_1$ 至 $a_{i-1}$ 之间任选 $k-1$ 个即可，选法个数为 $\operatorname{C}^{k-1}_{i-1}$。最后的得数即为 $\displaystyle\sum_{i=1}^n\operatorname{C}^{k-1}_{i-1}\times a_i$。

注意到 $\operatorname{C}^m_n=\operatorname{C}^{m-1}_{n-1}+\operatorname{C}^{m}_{n-1}$，可以先递推出组合数再计算，时间复杂度为 $\mathcal{O}(nk)$。

**注意：十年 OI 一场空，不开 `long long` 见祖宗！！！**

### C++ Code

```cpp
#include<bits/stdc++.h>
#define int long long // 将 int 定义 long long 
using namespace std;
const int maxn = 100006;
const int maxm = 57;
const int mod = 1000000007;
int n, k, ans;
int a[maxn];
int C[maxn][maxm]; // C(n,m)=n!/m!(n-m)!
void init() // 预处理
{
	// 警钟长鸣：递推时注意下标，这里调了一会
	for (int i = 0; i <= n; i ++) C[i][0] = 1; // C(n,0)=1
	for (int i = 1; i < k; i ++)
	{
		for (int j = i; j <= n; j ++)
		{
			C[j][i] = (C[j - 1][i - 1] + C[j - 1][i]) % mod;
		}
	}
}
signed main() // 由于 int 已被定义，所以要用 signed 
{
	scanf("%lld %lld", &n, &k);
	for (int i = 1; i <= n; i ++)
	{
		scanf("%lld", &a[i]);
	}
	init();
	sort(a + 1, a + n + 1);
	for (int i = k; i <= n; i ++)
	{
		ans = (C[i - 1][k - 1] * a[i] + ans) % mod;
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Melo_qwq (赞：1)

地生考完，来篇题解。

# 题目大意

${n\choose k}$ 个数列中最大数之和。

# 题目实现

注意到数越大它是最大值的概率越大，所以将原数组单调递增排序（递减也可）。

不难发现前 $k-1$ 小的数一定会与至少一个比自己大的数在一起，所以从第 $k$ 小往后考虑。

设当前数是第 $i$ 小，那么我们如果想让它最大，只需要从前面的 $i-1$ 个数中取出 $k-1$ 个即可，也就是说有 ${i-1\choose k-1}$ 种选法，那么它对答案的贡献即为 ${i-1\choose k-1}\times a_i$。

之后暴力算出第 $k$ 至 $n$ 个数的贡献和即可。

如果不知道组合数怎么算的请移步[这里](https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F/94872)。

## 代码

```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int mod = 1e9 + 7 ;
const int N = 1e5 + 7 ;
typedef long long ll ;
inline int read () {
	int x = 0 ,f = 1 ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		if (ch == '-') {
			f = -1 ;
		}
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + ch - '0' ;
		ch = getchar () ; 
	}
	return x * f ;
}
int n ,k ,a[N] ,c[N][57] ;
ll ans ;
inline void pre () {
	c[0][0] = 1 ;
	f (i ,1 ,n ,1) {
		c[i][0] = 1 ;
		f (j ,1 ,min (i ,k) ,1) { // 一个小小的优化
			c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod ;
		}
	}
}
int main () {
	n = read () ,k = read () ;
	f (i ,1 ,n ,1) {
		a[i] = read () ;
	}
	pre () ;
	sort (a + 1 ,a + n + 1) ;
	f (i ,k ,n ,1) {
		ans = (ans + (1ll * c[i - 1][k - 1] * a[i]) % mod) % mod ;
	} 
	cout << ans << '\n' ;
	return 0 ;
}
```

---

## 作者：wwxxbb (赞：1)

## 思路

这道题目看样例解释就很清楚了，对于每一种情况，对于答案由贡献的是这 $k$ 个数的最大值，所以思路就是：

首先将输入排序，对于每一个 $a_i$，它是所选的 $k$ 个数中的最大值，这样的情况相当于在 $i-1$ 个数中取 $k-1$ 个数，即 $C_{i-1}^{k-1}$。

所以答案即为：

$$\sum_{i=k}^nC_{i-1}^{k-1}\times a_i$$

这道题目因为要取模，所以要用逆元,具体的可以参考一下[这篇文章](https://zhuanlan.zhihu.com/p/449221995)，讲得很详细。

## std
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=100010,mod=1e9+7;
int n,k,a[N];
int f[N],invf[N],ans;
int exgcd(int a,int b,int &x,int &y){
  if(!b){
    x=1,y=0;
    return a;
  }
  int d=exgcd(b,a%b,y,x);
  y-=a/b*x;
  return d;
}
int inv(int a,int b){
  int x,y;
  exgcd(a,b,x,y);
  return (x%b+b)%b;
}
void init(int n){
  f[0]=1;
  for(int i=1;i<=n;i++)f[i]=f[i-1]*i%mod;
  invf[n]=inv(f[n],mod);
  for(int i=n-1;i>=0;i--)invf[i]=invf[i+1]*(i+1)%mod;
}
int C(int n,int m){
  return f[n]*invf[m]%mod*invf[n-m]%mod;
}
signed main(){
  cin>>n>>k;
  for(int i=1;i<=n;i++)cin>>a[i];
  init(n);
  sort(a+1,a+n+1);
  for(int i=k;i<=n;i++)ans=(ans+C(i-1,k-1)*a[i]%mod)%mod;
  return cout<<ans,0;
}
```

---

## 作者：DFM_O (赞：1)

## [P6725 题解](https://www.luogu.com.cn/problem/P6725)

### 解题思路
我们可以先将数组升序排序，不难发现，若 $i\ge k$，则若想使得 $a_i$ 为集合中最大的数，那么另外 $k-1$ 个数必须比 $a_i$ 小，即必须在 $a_1$ 到 $a_{i-1}$ 中选择，一共有 $C_{i-1}^{k-1}$ 种选择，和为 $a_i\times C_{i-1}^{k-1}$。

则总和为
$$\sum_{i=k}^na_i\times C_{i-1}^{k-1}$$
组合数用杨辉三角预处理即可，运算时别忘了对 $10^9+7$ 取模。

###  Code
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
#define int long long
const long long p=1e9+7;
int C[100001][51],a[100001];
signed main()
{
	ios::sync_with_stdio(false);
	int n,k;
	cin>>n>>k;
	C[0][0]=0;
	for(int i=1;i<=n;i++)//预处理组合数
	{
		C[i][0]=1;
		for(int j=1;j<=k;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;
		if(i<=50)
			C[i][i]=1;
	}
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	int s=0;//计数器
	for(int i=k;i<=n;i++)
		s=(s+C[i-1][k-1]*a[i]%p)%p;
	cout<<s;//输出答案
	return 0;
}
```

---

## 作者：wunaidedanjuan (赞：1)

### 题意

求元素个数为 $n$ 的集合 $a$ 的所有元素个数为 $k$ 的子集中最大元素的和 $\mod10^9+7$。

### 思路分析

由题可知，每个数对答案的贡献为 $\text{元素值}\times\text{元素成为子集最大元素的次数}$，因此，只要求出**每个元素成为子集最大元素的次数**即可。

不妨先将集合 $a$ 中的元素按**降序**排列，那么对于一个在集合 $a$ 中的元素 $a_i$，若它所在的子集中不存在元素的下标 $j<i$，则说明 $a_i$ 为此子集的最大元素。也就是说，对于一个在集合 $a$ 中的元素 $a_i$，当$a_i$ 为子集的最大元素时，子集的其余 $k-1$ 个元素均在 $a_{i+1}\sim a_n$ 中，所以**元素 $a_i$ 成为子集最大元素的次数为** $C_{n-i}^{k-1}=\frac{!\left(n-i\right)}{!\left(k-1\right)\times!\left(n-i-k+1\right)}$。

最后求和再 $\mod10^9+7$ 即可。

### 思路优化

- 由于 $n-k+2\sim n$ 间有 $k-1$ 个元素，所以子集中必定有元素的下标小于 $n-k+2$，所以第 $n-k+2\sim n$ 个元素一定不会成为子集的最大元素。因此计算时我们只需计算 $1\sim n-k+1$ 即可。

- 求组合数 $C$ 时可以应用**杨辉三角**求解，即 $C_i^j=C_{i-1}^j+C_{i-1}^{j-1}$。

### 代码呈现
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<bitset>
#include<cctype>
#include<cstdlib>
#include<functional>
#include<istream>
#include<sstream>
#define int long long 
using namespace std;
const int N=100010,M=60,mod=1e9+7;
int a[N],c[N][M];
bool cmp(int x,int y)
{
	return x>y;
}
signed main()
{
	int n,k,ans=0;
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+n+1,cmp);
	for(int i=0;i<=k;i++)//初始化c数组 
		c[i][i]=1;
	for(int i=0;i<=n;i++)
		c[i][0]=1;
	for(int i=1;i<=n;i++)//利用杨辉三角计算C 
		for(int j=1;j<=k;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	for(int i=1;i<=n-k+1;i++)
		ans+=(a[i]*c[n-i][k-1])%mod;
	printf("%lld",ans%mod);
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

暴力枚举每个组合显然不是理想的选择。我们要换一个角度去看这个问题——对于每个数，求出以其为最大值的组合个数。

我们把给定的序列排序，从第 $k$ 个数开始循环。要使当前数 $i$ 为最大值，我们就要在比它小的数（共 $i-1$ 个数）里取 $k-1$ 个，共可以组成 $C_{i-1}^{k-1}$ 个组合，所有组合中的最大值的和为 $a_i\times C_{i-1}^{k-1}$。

对于组合数，可以用杨辉三角预处理。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int mod=1e9+7,N=1e5+2;
int a[N];
int c[N][52];

signed main(){
    int n,k;cin>>n>>k;
    for(int i=0; i<=n; i++){
        for(int j=0; j<=i; j++){
            if(j>k) break;
            if(j==0 || j==i) c[i][j]=1;
            else c[i][j]=(c[i-1][j-1]%mod+c[i-1][j]%mod)%mod;
        }
	}
    for(int i=1; i<=n; i++) cin>>a[i];
    sort(a+1,a+1+n);
    int sum=0;
    for(int i=k; i<=n; i++) sum=(sum+a[i]*c[i-1][k-1])%mod;
    cout<<sum;
	return 0;
}
```

---

## 作者：AmaoFox (赞：0)

不妨钦定某个数为组合的最大值。假定这个数是所有 $N$ 个数中第 $M$ 大的，则有 $M-1$ 个数字是不能选的，而除了这个数以外，仍然有 $N-M-1$ 个数字是可以选的。所以，选这个数且它为最大值的方案数有 $C_{N-M-1}^{K-1}$ 种。

``` cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 100005, K = 55, mod = 1000000007;

int a[N], c[N][K];

signed main(){
  int n, k, ans = 0;
  cin >> n >> k;
  c[0][0] = 1;
  for(int i = 1; i <= n; i++){
    c[i][0] = 1;
    for(int j = 1; j <= min(i, k); j++) {
      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
    }
  }
  for(int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  sort(a + 1, a + n + 1);
  for(int i = k; i <= n; i++) {
    (ans += c[i - 1][k - 1] * a[i] % mod) %= 1000000007;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：icaijy (赞：0)

# 题意
求 $n$ 个数中选 $k$ 个数的所有组合中，每个组合最大数之和。
# 思路
我们假设数列中第 $x$ 大的数为 $m_x$。易知所有包含 $m_1$ 的组合中（即包含数列中最大的数的组合)，数列中最大的数就是 $m_1$。对于些组合，因为有 $n$ 个数，要包含 $m_1$ 就必须选 $m_1$，于是剩下 $n-1$ 个物品，要在这些物品中选 $k-1$ 个数，所以有 $n-1\choose k-1$ 种组合最大的数是 $m_1$。

对于 $m_2$。在所有选了 $m_2$ 但没选 $m_1$ 的组合中，最大的数就是 $m_2$。对于这些组合，在 $n$ 个数中，因为选了 $m_2$ 且不选 $m_1$，所以要在剩下的 $n-2$ 个数中选 $k-1$ 个，即有 $n-2\choose k-1$ 种。

以此类推，对于数列中第 $x$ 大的数，以它为最大的数的组合有 $n-x\choose k-1$ 种。需要注意的是，$m_n$ 到 $m_{n-k+2}$ 不能作为组合中的最大值。

# 实现
这题思路不算难，不过实现有些许难度，个人认为这题难度应该为黄题及以上。

因为我们要按大小处理数列，所以先用 $sort$ 进行排序。开一个 $ans$ 记录答案，并从大到小遍历。对于每一个数，$ans$ 变量需要加上 $m_x\times {n-x\choose k-1}$。不过注意到数据范围 $N<=10^5$，传统的相乘计算法很快就爆 `long long`，这时有人说了，根据模运算的性质，计算的时候每次乘了之后都取模，不就行了吗？不过问题在于组合计算中，还有除的部分，除了之后取模不符合模运算的性质。其实也有解决办法，就是用逆元，不过太麻烦了。

这时我们使用“杨辉三角”。参考[P5732](https://www.luogu.com.cn/problem/P5732)，杨辉三角的第 $i$ 行第 $j$ 列为第 $i-1$ 行 $j-1$ 列与 $i-1$ 行 $j$ 列的和。因为杨辉三角每一行的最左边与最右边的数均为 $1$，根据 ${n\choose k}+{n\choose k-1} = {n+1\choose k}$，可以得出杨辉三角的第 $i$ 行第 $j$ 列为 $i\choose j$。所以我们先建立个杨辉三角，然后每次从杨辉三角中查就行了。

# 代码
需要注意数据较大，需要开`long long`。
```cpp
#include <iostream>
#include <algorithm>
#define p 1000000007
#define int long long
using namespace std;
int a[100005];
int c[100005][55];
int n,k;
void yh(){//建立杨辉三角
	for (int i=0;i<n;i++){
		c[i][0]=1;
		if (i<k) c[i][i]=1;
		for (int j=1;j<=min(i-1,k-1);j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
	}
}

signed main(){
	int ans=0;
	cin>>n>>k;
	for(int i=0;i<n;i++) cin>>a[i];
	yh();
	sort(a,a+n,greater<int>());//从大到小排序
	for (int i=0;i<=n-k;i++){
		ans+=a[i]*c[n-i-1][k-1];
		ans%=p;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：王逸辰 (赞：0)

# P6725 [COCI2015-2016#5] PERICA 题解
## 题意
给定一个长度为 $N$ 的序列 $a_1​ ,a_2​ ,\dots,a_N​ $。

求出所有 $K$ 个数的组合中最大数之和 $ \bmod 1000000007$ 的结果。
## 思路
将数组从小到大排序，如果 $i\ge k$，若想让 $a_i​$ 为集合中最大的数，其他数便必须比它小，即必须在比它小的数中选择，
和为 $a_i\times C _{i−1}^{k−1}$。

总和为:
$$
ans=\sum_ {i = k}^{n} a_i *C _
{i−1}^{k−1}

$$

用杨辉三角处理，别忘了取模。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,p=1e9+7,N,K;
long long a[100001],b[100001][51];
int main(){
	cin>>N>>K;
	for(int i=(1);i<=N;++i)
		cin>>a[i];
	sort(a+1,a+N+1);
	for(int i=(1);i<=N;++i){
		b[i][0]=1;
		for(int j=(1);j<=K;++j)
			b[i][j]=(b[i-1][j]+b[i-1][j-1])%p;
		if(i<=50)
			b[i][i]=1;
	}
	for(int i=(K);i<=N;++i)
		s=(s+b[i-1][K-1]*a[i]%p)%p;
	cout<<s<<"\n";
	return 0;
}
```

---

## 作者：Oracynx (赞：0)

## P6725 [COCI2015-2016#5] PERICA 题解

### 思路分析

我们先对整个数组进行排序，然后我们确定每一组中的最大值。

对于这个最大值，对答案的贡献即为 $C^{k - 1}_{i - 1}$，对于求组合数，我们可以使用预处理阶乘加逆元（本文使用费马小定理）的方式求出，时间是 $O(\log_{Mod})$。

所有的答案即为：
$$
\sum_{i = k}^{n}C^{k - 1}_{i - 1} \times p_i
$$

### 代码实现

```cpp
#include <algorithm>
#include <cstdio>
constexpr int MaxN = 1e5 + 5;
constexpr long long Mod = 1e9 + 7;
int n, k;
long long answer;
long long p[MaxN];
long long pw[MaxN];
long long ksm(long long x, long long y)
{
    long long res = 1;
    for (; y != 0;)
    {
        if (y % 2 == 1)
        {
            res *= x;
            res %= Mod;
        }
        x *= x;
        x %= Mod;
        y /= 2;
    }
    return res;
}
long long C(long long x, long long y)
{
    return pw[x] * ksm(pw[x - y], Mod - 2) % Mod * ksm(pw[y], Mod - 2) % Mod;
}
int main()
{
    scanf("%d%d", &n, &k);
    pw[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        pw[i] = pw[i - 1] * i;
        pw[i] %= Mod;
    }
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld", &p[i]);
    }
    std::sort(p + 1, p + 1 + n);
    for (int i = k; i <= n; i++)
    {
        answer += C(i - 1, k - 1) * p[i];
        answer %= Mod;
    }
    printf("%lld\n", answer);
    return 0;
}
```

---

## 作者：ZYH_juruo (赞：0)

# 题目传送门
[P6725 [COCI2015-2016#5] PERICA](https://www.luogu.com.cn/problem/P6725)

# 题目大意
给一个长度为 $N$ 的序列，在由 $K$ 个数组成的排列中，他们的最大值的和为多少？

# 题目分析
首先可能就有人想到了深搜（比如我），然后发现根本不可能。

既然是最大值，那么 $N$ 个数中肯定有 $K-1$ 个数**不是最大值**，也就是说，我们根本就不需要考虑。照这么推理，我们只需要考虑一下**剩下**的 $N-K+1$ 个数对答案的一个贡献就好了。

于是我们就将序列按**升序**排列，假设第 $i$ 个数 $a_i$ 是我们选中的最大值（意思是它只能是**当前的最大值**），那么我们只能在 $a_i$ 前的 $i-1$ 个数中挑选 $K-1$ 个数，并且是**随意挑选**，所以第 $i$ 个数对答案的贡献即为

$C_{i-1}^{K-1}\times a_i$。

至于组合数，我选择使用杨辉三角。

# ACCODE
```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 100010
#define Mod 1000000007
using namespace std;
int n,k,a[maxn],ans,c[maxn][55];
signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=0;i<=n;i++) c[i][0]=1;
	for(int i=0;i<=k;i++) c[i][i]=1;
	for(int i=2;i<=n;i++)//组合数计算，杨辉三角
		for(int j=1;j<=min(i-1,k-1);j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%Mod;
	for(int i=k;i<=n;i++)// 注意从k开始计算
		ans=(ans+c[i-1][k-1]*a[i])%Mod;
	cout<<ans<<endl;
	return 0;
}

```

思路还是很清楚的，至少我是一遍过的，希望对大家有帮助。

**完结撒花！！！**

---

## 作者：bovine__kebi (赞：0)

**题意**：给你一个长度为 $n$ 的序列，求每次选出 $k$ 个数的最大值的和。

**题解分析**：读懂了题意，我们发现，只有一段的最大值才能对题目的答案产生贡献，并且选出的其它的 $k-1$ 个数要比它的值小。如何使所有比他小的数都能被直接统计？我们考虑将原序列 **排序**，这样才能 **有序完全** 的统计。接下来的问题就变成了了，从后往前枚举，假设现在这个位置为 $i$,如何求出这个位置对答案的 **贡献 $C_{n-i}^{k-1}\times a_{n-i+1}$**。$C_{n-i}^{k-1}$的意思通俗的来讲就是，从 $i$ 位之前的 $n-i$ 个数中选出 $k-1$ 个数和这个第 $i$ 位的最大值配成 如题意所示长度为 $k$ 的段。由于组合数的定义，$C_{n-i}^{k-1}$ 其实就等于 $\frac{(n-i)!}{(k-1)!\times(n-i-k+1)!}$("!"表示阶乘),于是我们可以通过预处理阶乘和费马小定理用快速幂求出逆元来用 $O(log_2n)$ 的时间复杂度求解出答案。

**Tips** :剩下的就是取模和开ll了，因为这个玩意我交了n次，提醒各位一定要取模完全。

**代码（勿抄）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int Mod=1e9+7;
const int maxn=1e5+5;
ll a[maxn];
ll fac[maxn];
ll ans=0;int n,k;
inline ll Mo(ll a){return a%Mod;}
inline ll qpower(ll x,ll p){ll ans=1;for(;p;p>>=1,x=x*x%Mod)p&1?ans=ans*x%Mod:0;return ans;}//快速幂。
inline void init()
{
    fac[0]=1;
    for(int i=1;i<=n;i++)fac[i]=Mo(fac[i-1])*i%Mod;
}//预处理阶乘
int main()
{
    scanf("%d %d",&n,&k);init();
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    sort(a+1,a+n+1);//对数列进行排序，保证能统计完全。
    for(int i=1;i<=n-k+1;i++)
    {
        ans=(ans+Mo(Mo(Mo(a[n-i+1])*qpower(Mo(fac[n-i-k+1]*fac[k-1]),Mod-2))*Mo(fac[n-i])))%Mod;//统计答案，每个地方都要取模
    }
    printf("%lld\n",ans);
}
```

---

## 作者：dead_X (赞：0)

## 题意
小清新数论题。

求 $n$ 个数所有任意 $k$ 个数的组合最大值之和
## 思路
枚举最大值。对所有数排序，然后对于第 $i$ 个数，贡献为所有这个数为最大值的组合乘以这个数。这个数的左边有 $i-1$ 个数，要选出 $k-1$ 个数，所以方法数为 $C_{i-1}^{k-1}$ 。

注意：上文中 $i\geq k$ 。 

那么不难得出答案如下：

$$\sum_{i=k}^{n} a_iC_{i-1}^{k-1}$$

实现非常简单。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int w=0;
    char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) w=w*10+ch-48,ch=getchar();
    return w;
}
const long long p=1000000007;
long long qp(long long x,long long y)
{
    if(y==0) return 1;
    if(y==1) return x;
    long long tmp=qp(x*x%p,y>>1);
    if(y&1) tmp*=x,tmp%=p;
    return tmp;
}
int a[1000003],n,k;
long long fac=1,inv=1;
int main()
{
    n=read(),k=read()-1;
    if(!k){long long ans=0; for(int i=1; i<=n; i++) ans+=read(); cout<<ans; exit(0); }
    for(int i=1; i<=k; i++) fac*=i,fac%=p;
    inv=fac,fac=qp(fac,p-2);
    for(int i=1; i<=n; i++) a[i]=read();
    sort(a+1,a+n+1);
    long long ans=a[k+1];
    for(int i=k+2; i<=n; i++) inv*=qp(i-k-1,p-2),inv%=p,inv*=i-1,inv%=p,ans+=inv*fac%p*a[i]%p,ans%=p;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：JK_LOVER (赞：0)

## 题意
给你一个长度为 $n$ 的序列，求出它所以长度为 $k$ 的排列中最大值的和。[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p6725)
## 分析
既然不可能枚举排列，考虑枚举最大值，计算最大值出现的次数。那么答案为 
$$
ans = \sum_i^n(A[i] \times C[i])
$$
现在问题就是如何快速求出 $C[i]$ 。将序列排序，那么枚举最大值，包含它的排列个数等同于在剩下的数中选出 $k-1$ 个数，我这里是从后往前枚举的。
$$
ans = \sum_i^n(A[i] \times \tbinom{i-1}{k-1})
$$
现在只需要预处理阶乘就可以了。复杂度为 $O(n\log n)$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long 
const int Mod = 1e9 + 7,N = 4e5+100;
LL A[N],n,k;
LL Ans = 0,pre[N];
LL read(){
	LL x;scanf("%lld",&x);return x;
}
LL fpow(LL a,LL b){
	LL x = 1;
	for(;b;b >>= 1,a = a * a % Mod)
	if(b&1) x = 1LL * x * a % Mod;
	return (x % Mod + Mod) % Mod; 
}
LL C(LL x,LL y)
{
	if(y > x) return 0;
	return 1LL * pre[x] * fpow(pre[x - y] * pre[y] % Mod,Mod - 2) % Mod;
}
int main(){
	n = read();k = read();
	for(LL i = 1;i <= n;i++) A[i] = read();
	sort(A + 1,A + 1 + n);
	pre[0] = 1;
	for(LL i = 1;i <= n;i++) pre[i] = pre[i-1] * i % Mod; 
	for(LL i = n;i >= 1;i--)
	{	
		Ans = (Ans + 1LL * A[i] * C(i - 1, k - 1) % Mod + Mod) % Mod;
	}
	printf("%lld\n",(Ans % Mod + Mod) % Mod);
	return 0;
}
```


---

## 作者：iCostalymh (赞：0)

~~（建议评红）~~

考虑每个数能为答案做多少贡献。在单调不降的数列 $\{a_n\}$ 中，选出一个 $a_i$，$a_i$ 作为最大值且为答案做出的贡献是 $a_i \times \dbinom{i - 1}{k - 1}$。

所以先预处理组合数，给 $\{a_n\}$ 排序，然后倒序扫一遍就行了。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn(1e5 + 3), P(1e9 + 7);

int n, k, a[maxn], ans;

inline int qPow(int a, int b) {
    int res(1);

    for (; b; b >>= 1) {
        if (b & 1) res = res * a % P;
        a = a * a % P;
    }

    return res;
}

int f[maxn], g[maxn];

inline int C(int n, int m) {
    if (n < m) return 0;
    if (m == 0 || m == n) return 1;
    return f[n] * g[m] % P * g[n - m] % P;
}

signed main() {
    f[0] = f[1] = g[0] = g[1] = 1;

    for (int i = 2; i <= 100000; ++i) {
        f[i] = f[i - 1] * i % P;
        g[i] = qPow(f[i], P - 2);
    }

    scanf("%lld%lld", &n, &k);

    for (int i = 1; i <= n; ++i) {
        scanf("%lld", &a[i]);
    }

    sort(a + 1, a + 1 + n);

    for (int i = n; i >= k; --i) {
        
        ans = (ans + a[i] * C(i - 1, k - 1) % P) % P;
    }

    printf("%lld\n", ans);
}
```

---


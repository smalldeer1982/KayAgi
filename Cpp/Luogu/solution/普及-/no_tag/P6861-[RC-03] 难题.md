# [RC-03] 难题

## 题目描述

求两个整数 $a,b$ $(1\le a,b\le n)$，使 $(a\ \mathrm{or}\ b)+(a\ \mathrm{xor}\ b)$ 最大。只需输出这个最大值。

## 说明/提示

样例说明：$(5\ \mathrm{or}\ 2)+(5\ \mathrm{xor}\ 2)=14$。

对于 $80\%$ 的数据，$n\le 1000$。

对于 $100\%$ 的数据，$2\le n\le 10^{18}$。

## 样例 #1

### 输入

```
5```

### 输出

```
14```

# 题解

## 作者：WarningQAQ (赞：15)

位运算的题都挺有意思的。
### 分析：
给一个数 $n$ ,求 $x$ $\text{xor}$ $n$ $+$ $x$ $or$ $n$ 最大， $(1\leq x\leq n)$ 。

首先根据样例分析：

$$5\to 0101(\text{bin})$$ 

$$2\to 0010(\text{bin})$$ 

异或得 $7\to0111(\text{bin})$ ， 或得 $7\to0111(\text{bin})$ ，
和为 $14\to1110(\text{bin})$ 。

看不出什么 ， 再来想一组样例：

$$8\to01000(\text{bin})$$

$$7\to00111(\text{bin})$$

异或得 $15\to01111(\text{bin})$ ， 或得 $15\to01111(\text{bin})$ ，
和为 $30\to11110(\text{bin})$ 。

所以就找到了规律：

找到与 $n$ 异或的值和或的值相等的数。

也就是在二进制下每一位都与 $n$ 不同的数。

换言之，最终的答案就是二进制下 $n$ 的每一位都为 $1$ 的数再乘以 $2$ 。

### 代码：
```cpp
#include "cstdio"
#define ull unsigned long long//不开ull见祖宗
ull n, k, ans;
int main() {
    scanf("%llu", &n);
    k = n;
    while (k) {
        k >>= 1;
        ans = ans << 1 | 1;
    }
    printf("%llu", ans << 1);
}
```


---

## 作者：yewanxingkong (赞：4)

这个题仔细思考你会发现， $or$ 的运算是两个数二进制位中该位有一个 $1$ 就是 $1$ ，而 $xor$ 是相同为 $0$ 不相同为 $1$ ，所以我们取的两个数只要满足二进制位中为 $1$ 的位数都不相同而且能取到的位数都有一数为 $1$ 就可以。

所以只要算出 $n$ 的最高位 $1$ 是第几位，答案就是从这一位数一直加到最后一位数乘以 $2$。

下面是代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long n,chu;
int ji;
int main(){
	scanf("%lld",&n);
	for(int i=63;i>=1;i--)
		if(n&((long long)1<<i)){
			ji=i;
			break;
		}
	for(int i=0;i<=ji;i++)
		chu+=((long long)1<<i);
	printf("%lld",2*chu);
	return 0;
}
```


---

## 作者：Eason_AC (赞：4)

## Update
- $\texttt{2020.10.21}$ 删除了不需要的 $n=1$ 的特判，并在符号与字母之间添加了空格。

## Content
给定一个数 $n$，试找到一对数 $a,b(1\leqslant a,b\leqslant n)$，使得 $a~or~b+a~xor~b$ 的值最大。

**数据范围：$2\leqslant n\leqslant 10^{18}$。**
## Solution
和月赛 T1 一样是个找规律题。

我们先对 $n=100$ 以内的答案通过打表得出来，先弄个打表程序：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, ans;

int main() {
	for(n = 1; n <= 100; ++n) {
		ans = 0;
		for(int i = 1; i <= n; ++i)
			for(int j = 1; j <= n; ++j)
				ans = max(ans, (i | j) + (i ^ j));
		printf("When n = %d, ans = %d.\n", n, ans);
	}
	return 0;
}

```

以下是得出来的结果，为了不占太大版面，相同的答案就直接省略了。

```
When n = 1, ans = 1.
When n = 2, ans = 6.
When n = 3, ans = 6.
When n = 4, ans = 14.
...
When n = 7, ans = 14.
When n = 8, ans = 30.
...
When n = 15, ans = 30.
When n = 16, ans = 62.
...
When n = 31, ans = 62.
When n = 32, ans = 126.
...
When n = 63, ans = 126.
When n = 64, ans = 254.
...
When n = 100, ans = 254.
```
通过每一个 $n$ 对应的答案我们就可以找到规律：

$(2=2^1)\leqslant n\leqslant (3=2^2-1)$ 的时候，答案是 $6=2^3-2$。

$(4=2^2)\leqslant n\leqslant (7=2^3-1)$ 的时候，答案是 $14=2^4-2$。

$(8=2^3)\leqslant n\leqslant (15=2^4-1)$ 的时候，答案是 $30=2^5-2$。

$(16=2^4)\leqslant n\leqslant (31=2^5-1)$ 的时候，答案是 $62=2^6-2$。

$(32=2^5)\leqslant n\leqslant (63=2^6-1)$ 的时候，答案是 $126=2^7-2$。

由此我们发现：当有一个 $i$ 满足 $2^i\leqslant n\leqslant 2^{i+1}$ 的时候，答案就是 $2^{i+2}-2$。所以，我们找到最小的 $i$ 使得 $n<2^i$，然后此时答案就是 $2^{i+1}-2$。注意，由于这里的数据范围是从 $2$ 开始，所以不需要特判 $n=1$ 的情况。
## Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

long long n;

int main() {
	scanf("%lld", &n);
	for(int i = 1; ; ++i)
		if(n < (long long)pow(2, i)) {
			printf("%lld", (long long)pow(2, i + 1) - 2);
			break;
		}
	return 0;
}

```

---

## 作者：梨衣 (赞：3)

## 此题可以找规律
在 1 到 $n$ 中任意取两个数异或，**必定存在两个数使异或结果为二进制位数为 $n$ 的位数，且每位都为 1 的数**，此时结果最大。
### 以 $n$ 为 5 为例
**5 的二进制数为 101**

**101^010=111=7**

**7+7=14**

**结果为 14**

而十进制数 5 和 3 都在 1~$n$ 的范围内

于是我们只需要求出 $n$ 的二进制数位数，给每一位都补成 1 ，计算最终结果就可以了
## 模拟代码如下
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long ans=1,x=1,cnt;
int main(){
	long long n;
	scanf("%lld",&n);
	while(n){
		n>>=1;//位运算 
		cnt++;//统计位数 
	}	
	for(int i=1;i<=cnt;i++){//模拟每一位为1时的十进制数 
		x=1;
		for(int j=0;j<i;j++)
			x*=2;
		ans+=x;
	}
		
	ans--;//最终结果会多算1	
	printf("%lld",ans);
	return 0;
}
```
## The end

---

## 作者：zplqwq (赞：3)

Helloooooooo!!!

我回来了！！！

今天我们来看一眼[RC-03] 难题

题意应该很明确了吧....

不再重复一遍了[题目传送门](https://www.luogu.com.cn/problem/P6861)

这绝对是道位运算的好题~~当时学位运算的时候很懵，现在想想很简单~~

# Section one:or和xor运算

or:或运算，当a和b其中有一个为$true$时，结果为$true$，$c++$表达式：| |

xor:异或运算，当且仅当a和b其中一个为$true$，另一个为$false$时，才为$true$,$c++$表达式^

# Section two: 题目

这道题的第一想法就是暴力！！

硬生生枚举每种情况找最大值即可。代码就不放了，注意要开unsigned long long 。

得分：80

接下来来看正解：

首先，可以现在原来暴力的基础上输出每一次枚举n=1~100的所有情况。然后找规律，代码就不放了只是在暴力的外面套了一层for(int i=1;i<=100;i++)就可以了。

运行结果我们可以发现：

```
当 n = 1, ans = 1.
当 n = 16, ans = 62.
当 n = 32, ans = 126.
当 n = 64, ans = 254.
```

唉唉！好像有规律！

规律就是。。。

设$x$为$2^x<=n$的最大值

则答案就是：$2^{(x+2)}-2 $ 

那.....就结束了？

就结束了。。。。

注意事项：

1. 要开unsigned long long
2. 貌似二进制的模拟算法也能做，不过可能细节较多，推荐打表找规律
3. 没了....

代码：

```c++
#include<bits/stdc++.h>//万能头
using namespace std;
我爱洛谷！
洛谷最棒！
unsigned long long n;
unsigned long long x=1;//注意！x初始值为1
int main()
{
	cin>>n;
	while(x<=n)//计算x
	{
		x*=2;
	}
    x/=2;//符合要求的那个东东
	cout<<(x*2*2)-2<<endl;//输出
	return 0;
} 
```

是不是很简单？

是的。。。

88

~~管理大大求过~~





---

## 作者：Waaifu_D (赞：2)

第一眼看到这题的我：？？？这什么？？？？

然后定睛一看

# 这不是位运算？？？

已经有了18篇大佬的题解相信数学规律也不用再阐述了（迫真）

位运算基本知识如下
```

& 	只有两个对应位都为 1 时才为 1

| 	只要两个对应位中有一个 1 时就为 1

^ 	只有两个对应位不同时才为 1

num << i 表示将 num 的二进制表示向左移动
位所得的值。

num >> i 表示将 num的二进制表示向右移动 位所得的值
```

答案为二进制下n的每一位都为1的数再乘以2。

[位运算の具体介绍](https://oi-wiki.org/math/bit/)

```cpp
#include<bits/stdc++.h>
#define LL long long//少打点字
using namespace std;
LL n,ans,d;
int main()
{
	LL ans;
	scanf("%lld",&n),ans=n;
        while(ans!=0)
	{
		d=d<<1|1;//d左移一位再或运算1
		ans=ans>>1;//ans右移1位
	}
	d<<=1;
	cout<<d;
	return 0;
}
```


---

## 作者：Autism_ever (赞：2)

此题较水。
### 在二进制数中取最大值，那么应该满足两个条件：

#### 1.运算出来的结果每一位都是1时最大。

#### 2.运算出来的位数越多数值越大。

#### 所以！！！上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum,ans,cnt=1;//不开long long见祖宗 
int main()
{
	long long n;
   	cin>>n;
  	while(n>>1)
  	{
  		n=n>>1;
  		cnt++;//记录n有多少位 
  	}
  	for(long long i=1;i<=cnt;i++)
  	{
  		ans=1;//赋初值 
   		for(long long j=1;j<=i;j++)
		{
   			ans=ans*2;//每一位上的值 
   		}
   		sum+=ans;//求出最大的值 
   	}
  	cout<<sum<<endl;//输出 
   return 0;
}
```


---

## 作者：剑星 (赞：2)

### 此题只要求输出最大值，可知当二进制下每一位皆为1时值最大。
###   因此只需求出n的最高位是1是第几位。
###  **log2(n)+1** 即可。+1是由于二进制下第一位为0。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n,m;
    cin>>n;
    m=log2(n)+1;
    cout << 2ull * (( 1ull << m)-1);
}
```


---

## 作者：12345678hzx (赞：1)

## 题目描述
求两个整数 $a,b$ $(1\le a,b\le n)$，使 $(a\ \mathrm{or}\ b)+(a\ \mathrm{xor}\ b)$ 最大。输出这个最大值。
## 思路
看到题目，很明显的一个贪心，我们尽可能让 $a$ 与 $b$ 二进制下的每一位中有且仅有一个 $1$。这样就能让或和异或值最大。

所以，$a\ \mathrm{or}\ b$ 的最大值就是在 $n$ 的二进制下的是 $1$ 的最高位下的位置，将后面都填成 $1$ 就行了。

至于如何求出在 $n$ 的二进制下的是 $1$ 的最高位下的位置，其实也就是求出 $\left\lceil\log n\right\rceil$，我们可以用系统自带的函数，但由于如果 $n$ 是 $2$ 的次幂，则我们要求的答案就会错误，所以最后的在 $n$ 的二进制下的是 $1$ 的最高位下的位置是 $\left\lfloor\log n\right\rfloor+1$。

求出了它，答案就很好求了，运用等比数列求和公式，设 $m$ 为 $n$ 的二进制下的是 $1$ 的最高位下的位置，则答案为 $(2^{m+1}-1) \times 2$。
## 代码
这是核心代码。
```cpp
cin>>n;
long long m=floor(log(n)/log(2));//m代表n在二进制下为1的最高位的位置。  
cout<<((1ll<<(m+1))-1)*2;
```

---

## 作者：Kiloio (赞：1)

位运算对于我这种蒟**真有趣**  ,但推一推总是能出规律的    
规律：在**二进制**下**每一位都与n不同**的数  
然后上代码，有些地方还是要注意的QAQ

```
#include <bits/stdc++.h>
using namespace std;
long long n,ans,op;
int main(){
	cin>>n;
	while(n>0){
		n>>=1LL;//还有个等于号的···· 
		op++;
	}
	ans=op+1;
	cout<<((1LL<<ans)-2);
	//上句注意的地方： 
	//一、注意这个1LL，学校oj上没注意WA了几次 
	//二、是把1LL<<ans打上括号 
}
```


---

## 作者：Aiopr_2378 (赞：1)

# ~~说实话，数学题~~
~~（光速逃）~~

相信题解区的各位大佬已经把数学逻辑解释的很清楚了，其实就是在二进制上进行了简化:

找到与$n$异或的值和或的值相等的数。也就是在二进制下每一位都与$n$不同的数。换言之，最终的答案就是二进制下$n$的每一位都为1的数再乘以2。

#### ~~我知道你们只看代码~~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,sum;//longlong叫你做人
int main(){
    cin>>n;
    long long k=n;
    while (k){
        k>>=1;//>>是二进制运算符，同于“*”，相信我，更快
        sum=sum<<1|1;
    }
    cout<<(sum<<1);//别忘了加括号
    return 0;
}
```


---

## 作者：sysong (赞：1)

# 题解P6861 [RC-03] 难题

### 题目描述

求两个整数 $a,b (1\le a,b\le n)$，使 $(a\ \mathrm{or}\ b)+(a\ \mathrm{xor}\ b)$ 最大。只需输出这个最大值。

(题意很清楚了，只要知道 $or$ 和 $xor$ 分别对应 $c++$ 中的  "$ | $"  和  "$ ^ $"  即可)

### $Solution$

既然是位运算，我们在十进制下看不出什么。那么我们可以先看 $80\%$ 的数据。

显然可以写一个暴力（$O(n^{2})$）。

代码如下：

```c++
#include <bits/stdc++.h>
#define R register
#define gc() getchar()
#define ll long long
using namespace std;

inline ll rd(){
	R ll x=0;R char c=gc();//,f=1
	while(c>'9'||c<'0')c=gc();//{if(c=='-')f=-1;
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
	return x;//*f
}

int main(){
	ll n=rd(),k,ans=0,f1,f2;
	for(R ll i=1;i<=n;i++)					// 枚举 a 的值
		for(R ll j=i;j<=n;j++){				// 枚举 b ，从 a 开始是为了避免不必要的计算。
			k=(i|j)+(i^j);
			if(k>ans)ans=k;					// 取最大值
		}
	printf("%lld\n",ans);
	return 0;
}

```

以上代码可得 $80pts$。

第五个测试点[TLE](https://www.luogu.com.cn/record/40185556)。

那么，如何改进呢？

我们来打个表。

```c++
#include <bits/stdc++.h>
#define R register
#define gc() getchar()
using namespace std;

inline int rd(){
	R int x=0;R char c=gc();//,f=1
	while(c>'9'||c<'0')c=gc();//{if(c=='-')f=-1;
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
	return x;//*f
}

int main(){
	for(int n=1;n<=31;n++){					// 列举前31位即可找到规律（少列举一些也行）
		int k,ans=0,f1,f2;
		for(R int i=1;i<=n;i++)
			for(R int j=i;j<=n;j++){
				k=(i|j)+(i^j);
				if(k>ans)ans=k;
		}
		printf("%d\n",ans);
	}										// 核心代码同上
	return 0;
}

```

然后输出：

```
1 1
2 6
3 6
4 14
5 14
6 14
7 14
8 30
9 30
···
15 30
16 62
17 62
···
31 62
(32 126)
```

我们将每一项加上2（除了1），得到的数分别为$8,16,32,64(2^{n})$

可以发现规律：

$2(2^{1})$ ~ $3(2^{2}-1)$ : $6(2^{3}-2)$

$4(2^{2})$ ~ $7(2^{3}-1)$ : $14(2^{4}-2)$

$8(2^{3})$ ~ $15(2^{4}-1)$ : $30(2^{5}-2)$

$16(2^{4})$ ~ $31(2^{5}-1)$ : $62(2^{6}-2)$

······

也就是说，我们对于输入的 $n$ ，求 $2^{\log_{2} (n) + 2}-2$ ，即为我们需要的 $ans$ 。

由此可以直接调用函数求解（看到别的题解都是手动算的，没有这个方便，但是这个 $cmath$ 常数大）：

```c++
#include <bits/stdc++.h>
#define R register
#define gc() getchar()
#define ll long long
using namespace std;

inline ll rd(){
	R ll x=0;R char c=gc();//,f=1
	while(c>'9'||c<'0')c=gc();//{if(c=='-')f=-1;
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
	return x;//*f
}

int main(){
	ll n=rd(),ans=0,k=log(n)/log(2);	// c++ 中没有 log2 的函数，需要换底公式
	ans=(ll)pow(2,k+2)-2;
	printf("%lld\n",ans);
	return 0;
}

```

终于愉快地 $AC$ 了！

### 不要忘记开 $long\ long$ !


***by jsntsys***

$2020.10.20$

**$upd:\ 2020.10.21$ 修改了一个错误**

---

## 作者：yf最qhhh (赞：1)

位运算的题，找规律嘛。
AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
	unsigned long long n,ans;//unsigned很很很重要。。。还有long long，看一下数据范围吧。
    cin>>n;
    while(n>0)ans=ans<<1|1,n>>=1;
    cout<<(ans<<1);//这个括号，涉及到优先级的问题，不加会报错
    return 0;
}
```


---

## 作者：Just_A_King (赞：0)

~~都说找规律。。没一个证明的~~

a or b+a xor b的最大值为(2^y-1)*2

证明如下:

对于n，我们设它的最高位为第y位

那么对于a，b，

由于a,b<=n

故它们高于y位的位上全为0

所以a or b和a xor b都一定小于2^y

又 a or b=a xor b=2^y-1,当且仅当

在第一位到第y位的范围内 ~a=b

故a or b+a xor b的最大值为(2^y-1)*2.

```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll n,_pow2[64],i;
int main(){
	_pow2[0]=1;
	for(i=1;i<=63;i++) _pow2[i]=_pow2[i-1]*2;
	cin>>n;
	i=0;
	while(n<_pow2[i]||n>=_pow2[i+1]) i++;
	cout<<(_pow2[i+1]-1)*2;
	return 0;
}
```


---

## 作者：蒟蒻one枚 (赞：0)

# 题目：
求两个正整数a,b(1≤a,b≤n),使(a or b)+(a xor b)最大  
题目数据点这个↓  
[题目传送门](https://www.luogu.com.cn/problem/P6861)
# 分析： 
### 首先，做这道题，我们要先知道几个东西  
逻辑与：只有两个数都为1，答案才是true，否则为false。   
逻辑或：只要有一个1,答案就是true，否则是false。  
逻辑异或：两数相同为false，否则为true。  
至于这个：  
x<<1   x>>1   这些没人不知道吧  
不会点这个→   [位运算不会的点这个](https://oi-wiki.org/math/bit/)  
# 代码  
各位是不是等着代码
```cpp
//萌新第一次发题解 [卖萌]
#include<bits/stdc++.h>    //万能头万岁
using namespace std;
long long n,chu;
int ji;
int main()
{scanf("%lld",&n);
 for(int i=63;i>=1;i--)
     if(n&((long long)1<<i))
	     {ji=i;
		  break;
		 }
 for(int i=0;i<=ji;i++)
     chu+=((long long)1<<i);
 printf("%lld",2*chu);
 return 0;   //结束 qwp  @-@ 望管理员大慈大悲，过
}
```


---

## 作者：_WinY (赞：0)

拿到这个题，其实我也~~不会做~~，但是我们机房的大佬
一顿操作~~我就会le~~

根据n的增加去推规律得到m为2^m<=n的最大，从而得到答案为(m*4)-2

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n,m=1;
int main()
{
	scanf("%lld",&n);
	while(m<=n)//m为2^m<=n的最大m 
	{
		m*=2;
	} 
	m/=2;//这时m就是符合2^m的 
	printf("%lld",(m*4)-2);//根据n的增大推规律发现答案就是(m*4)-2 
   	cout<<0;//防作弊
	return 0;
}
```
感谢大家看我这个~~蒟蒻~~的代码，好管理给过吧

---

## 作者：chenpengda (赞：0)

80pts：枚举。

按题意枚举即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,ans=0;
	cin>>n;
	for(long long i=1;i<=n;i++)
	{
		for(long long j=1;j<=n;j++)
		{
			ans=max(ans,(i|j)+(i^j));
		}
	}
	cout<<ans;
}
```

100pts：

以上程序根据 $n$ 的递增找规律，发现答案就是 $2^{(m+2)}-2$ ，其中 $m$ 为使得 $2^m \le n$ 的最大 $m$ 。$O(nlogn)$即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n;
	cin>>n;
	long long m=1;
	while(m<=n)
	{
		m*=2;
	}
    	m/=2;//此时就是符合条件的2^m。
	cout<<(m*4)-2;
} 
```


---

## 作者：借我昔日热忱 (赞：0)

### 一个数论问题.

首先不要被位运算限制，这道题而言，你对位运算的理解不需要多么高深，只需要知道他是二进制运算即可。

------------


在二进制数中取最大值，那么应该满足两个条件：

**1.运算出来的结果每一位都是1时最大。**

**2.运算出来的位数越多数值越大。**

------------


也就是**位数最多**（n的位数最多），且**每位都为1**时数值最大，那么存在同时满足这两个条件的情况么？（~~答案必然是存在~~）

 **将n转化成二进制，然后当每一位都为1时结果最大。**
 
 于是数论的结论就出来了，只需要两步 
 
 1.**求出n的位数：这里提供一种方法**（~~当然应该也还有其他方法，如果更简单可以评论在下面~~）：
 ```cpp
	while(n>>1){
		n=>>1;
		cnt++;//记录位数
	}
```

 2.**让他每位都变成1**（这个比较好实现直接次方乘2即可）

------------

 
 全代码：
 ```cpp
#include<cstdio>
#include<algorithm>
#define ll long long 
using namespace std;
ll sum,ans,cnt=1;
int main(){
 	ll n;
	scanf("%lld",&n);
	while(n>>1){
		n=n>>1;
		cnt++;//记录位数
	}
	for(ll i=1;i<=cnt;i++){
		 ans=1;
		for(ll j=1;j<=i;j++){
			ans=ans*2;//每一位的值
		}
		sum+=ans;//最大值
	}
	printf("%lld",sum);
	return 0;
}
```


------------

~~题解不易，不喜勿喷，欢迎指正~~

---

## 作者：封禁用户 (赞：0)

Links:

[xor运算的定义](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)

先将十进制数转为二进制的数,再一位一位的比较

####  1  xor  1  = 0
 
#### 1  xor  0  = 1
 
#### 0  xor  1  = 1 
  
#### 0  xor  0  = 0 


------------

[or运算的定义](https://baike.baidu.com/item/OR/2860874)

也是先将十进制数转为二进制的数,再一位一位的比较

但是只要该数位的一个数为1,则运算结果为1

所以

#### 1 or   1 = 1 

#### 1  or  0  = 1 
 
#### 0  or  1  = 1 
 
#### 0  or  0  = 0 

------------


所以最大值为转换成二进制以后,每一位的数组都为1即可

所以最大值的计算为2*(2^m+1+2^m+...+2^0)

m的值为
```latex
2^m<=n
```



因为n的范围为

```latax
2≤n≤10^18
```
所以本题需要的数据类型long long 



下面是打表的代码


```
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n;
	cin>>n;
	if(n==1) printf("2");
	if(n>=2&&n<=3) printf("6");
	if(n>=4&&n<=7) printf("14");
	if(n>=8&&n<=15) printf("30");
	if(n>=16&&n<=31) printf("62");
	if(n>=32&&n<=63) printf("126");
	if(n>=64&&n<=127) printf("254");
	if(n>=128&&n<=255) printf("510");
	if(n>=256&&n<=511) printf("1022");
	if(n>=512&&n<=1023) printf("2046");
	if(n>=1024&&n<=2047) printf("4094");
	if(n>=2048&&n<=4095) printf("8190");
	if(n>=4096&&n<=8191) printf("16382");
	if(n>=8192&&n<=16383) printf("32766");
	if(n>=16384&&n<=32767) printf("65534");
	if(n>=32768&&n<=65535) printf("131070");
	if(n>=65536&&n<=131071) printf("262142");
	if(n>=131072&&n<=262143) printf("524286");
	if(n>=216144&&n<=524287) printf("1048574");
	if(n>=524288&&n<=1048575) printf("2097150");
	if(n>=1048576&&n<=2097151) printf("4194302");
	if(n>=2097152&&n<=4194303) printf("8388606");
	if(n>=4194304&&n<=8388607) printf("16777214");
	if(n>=8388608&&n<=16777215) printf("33554430");
	if(n>=16777216&&n<=33554431) printf("67108862");
	if(n>=33554432&&n<=67108863) printf("134217726");
	if(n>=67108864&&n<=134217727) printf("268435454");
	if(n>=134217728&&n<=268435455) printf("536870910");
	if(n>=268435456&&n<=536870911) printf("1073741822");
	if(n>=536870912&&n<=1073741823) printf("2147483646");
	if(n>=1073741824&&n<=2147483647) printf("4294967294");
	if(n>=2147483648&&n<=4294967295) printf("8589934590");
	if(n>=4294967296&&n<=8589934591) printf("17179869182");
	if(n>=8589934592&&n<=17179869183) printf("34359738366");
	if(n>=17179869184&&n<=34359738367) printf("68719476734");
	if(n>=34359738368&&n<=68719476735) printf("137438953470");
	if(n>=68719476736&&n<=137438953471) printf("274877906942");
	if(n>=137438953472&&n<=274877906943) printf("549755813886");
	if(n>=274877906944&&n<=549755813887) printf("1099511627774");
	if(n>=549755813888&&n<=1099511627775) printf("2199023255550");
	if(n>=1099511627776&&n<=2199023255551) printf("4398046511102");
	if(n>=2199023255552&&n<=4398046511103) printf("8796093022206");
	if(n>=4398046511104&&n<=8796093022207) printf("17592186044414");
	if(n>=8796093022208&&n<=17592186044415) printf("35184372088830");
	if(n>=17592186044416&&n<=35184372088831) printf("70368744177662");
	if(n>=35184372088832&&n<=70368744177663) printf("140737488355326");
	if(n>=70368744177664&&n<=140737488355327) printf("281474976710654");
	if(n>=140737488355328&&n<=281474976710655) printf("562949953421310");
	if(n>=281474976710656&&n<=562949953421311) printf("1125899906842622");
	if(n>=562949953421312&&n<=1125899906842623) printf("2251799813685246");
	if(n>=1125899906842624&&n<=2251799813685247) printf("4503599627370494");
    if(n>=2251799813685248&&n<=4503599627370495) printf("9007199254740990");
    if(n>=4503599627370496&&n<=9007199254740991) printf("18014398509481982");
    if(n>=9007199254740992&&n<=18014398509481983) printf("36028797018963966");
    if(n>=18014398509481984&&n<=36028797018963967) printf("72057594037927934");
    if(n>=36028797018963968&&n<=72057594037927935) printf("144115188075855870");
    if(n>=72057594037927936&&n<=144115188075855871) printf("288230376151711742");
    if(n>=144115188075855872&&n<=288230376151711743) printf("576460752303423486");
    if(n>=288230376151711744&&n<=576460752303423487) printf("1152921504606846974");
    if(n>=576460752303423488&&n<=1152921504606846975) printf("2305843009213693950");
    if(n>=1152921504606846976&&n<=2305843009213693951) printf("4611686018427387902");
    if(n>=2305843009213693952&&n<=4611686018427387903) printf("9223372036854775806");
    if(n>=4611686018427387904&&n<=9223372036854775807) printf("18446744073709551614");
    if(n>=9223372036854775808) printf("36893488147419103230");
	return 0;
} 
```

飞一般的时间复杂度 O(1)

---


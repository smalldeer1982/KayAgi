# [COCI 2013/2014 #6] VJEKO

## 题目背景

Vjeko 在业余时间喜欢浏览目录中的文件。

## 题目描述

模式串是由英文字母的小写字母和一个星号组成的字符串。

星号可以替换为由小写字母组成的字符串，如果通过替换能使模式字符串等于文件名，则文件名与模式串匹配。

举个例子，字符串 `abcd`，`ad`和`anestonestod` 都与模式 `a*d` 匹配，而字符串 `bcd` 则不匹配。

编写一个程序，该程序将给出一个模式和一些文件名，输出是否与该模式匹配。

## 说明/提示

#### 【数据规模与约定】
$1\le N\le 100$。

#### 【说明】
**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #6](https://hsin.hr/coci/archive/2013_2014/contest6_tasks.pdf)  _T1 VJEKO_。**

## 样例 #1

### 输入

```
3
a*d
abcd
anestonestod
facebook```

### 输出

```
DA
DA
NE```

## 样例 #2

### 输入

```
6
h*n
huhovdjestvarnomozedocisvastan
honijezakon
atila
je
bio
hun ```

### 输出

```
DA
DA
NE
NE
NE
DA```

# 题解

## 作者：Yukinoshita_Yukino (赞：2)

字符串模拟题。

题意比较好理解，就是坑有点多。

下面我来给大家讲一些常见误区：

第一个字符串：``q*q``

第二个字符串：``qq``

这样是 ``DA``，因为*可以代表“没有字符”

接下来讲讲我的思路：

首先，两个字符串从下标为1开始，一个一个枚举，一直到```str[j]!=str2[j]&&str[j]!='*'```

这时候说明这个字符串肯定不符合要求了

然后，两个字符串从后向前枚举，一直到```str[j]!=str2[t]&&str[j]!='*'```

为止，同样的，这时候也不符合要求了

最后提醒大家：别忘了加长度特判

最后上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char str[1001],str2[1001]; 
int n,flag,t;
int main()
{
	cin>>n;
	cin>>str;
	for(int i=1;i<=n;i++)
	{
		cin>>str2;
		if(strlen(str)-1>strlen(str2)) {
			cout<<"NE"<<endl;
			continue;
		}
		for(int j=0;j<strlen(str);j++)
		{
			if(str[j]!=str2[j]&&str[j]!='*')
			{
				flag=1;
				break;
			}
			if(str[j]=='*') break;
		}
		t=strlen(str2)-1;
		for(int j=strlen(str)-1;j>=0&&t>=0;j--)
		{
			if(str[j]!=str2[t]&&str[j]!='*')
			{  
				flag=1;
				break;
			}
			if(str[j]=='*') break;
			t--;
		}
		if(flag==1) cout<<"NE"<<endl;
		else cout<<"DA"<<endl;
		flag=0;
	}
	return 0;
}


```

---

## 作者：OrangeEye (赞：1)

水题。'*'前的字符肯定是一个前缀，而其后面的字符是一个后缀。

但是有一个坑点：对于 `ab*ba` 如果按照以上方法， `aba` 是 `DA` 。所以还要判断前后缀有没有重复。可以判断如果前后缀长度之和大于总长，那么肯定没有重复。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string brk;
string s,t1,t2;
int main(){
	scanf("%d",&n);
	cin>>brk;int N=(int)brk.size();bool fl=0;
	for(int i=0;i<N;i++){
		if(brk[i]=='*'){fl=1;continue;}
		if(fl)t2+=brk[i];
		else t1+=brk[i];
	}
	int s1=(int)t1.size(),s2=(int)t2.size();
	for(int i=0;i<n;i++){
		cin>>s;
		int m=(int)s.size();
		if(m<s1||m<s2||s1+s2>m){
			printf("NE\n");
			goto Die;
		}
		for(int j=0;j<s1;j++)if(s[j]!=t1[j]){
			printf("NE\n");
			goto Die;
		}
		for(int j=0;j<s2;j++)if(s[m-s2+j]!=t2[j]){
			printf("NE\n");
			goto Die;
		}
		printf("DA\n");
		Die:;
	}
	return 0;
}
```


---

## 作者：JamesQin (赞：1)

标签：字符串操作

先将模式串的前一部分与后一部分分离，记为 $s_1$ , $s_2$ 。

然后在输入的字符串中判断 $s_1$ 是否为前缀， $s_2$ 是否为后缀。

这一操作可以借助 substr() 完成。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	string s;
	cin>>s;
	string s1,s2;
	bool b=false;
        //分离字串
	for(int i=0;i<s.length();i++){
		if(s[i]=='*'){
			b=true;
			continue;
		}
		if(!b) s1+=s[i];
		else s2+=s[i];
	}
	while(n--){
		string t;
		cin>>t;
		if(s1.length()+s2.length()>t.length()){
			cout<<"NE"<<endl; //如果长度不够直接退出
			continue;
		}
		string s3=t.substr(0,s1.length());
		string s4=t.substr(t.length()-s2.length(),s2.length());
		if(s1==s3&&s2==s4){ //判断前缀后缀
			cout<<"DA"<<endl;
		}
		else cout<<"NE"<<endl;
	}
	return 0;
}
```


---

## 作者：mzyc_yang2021 (赞：1)

题意：判断每个字符串是否含有题目给定的前后缀。

思路：提取每个字符串的前后缀，再与给定的前后缀相比较，这里提取题目给定的前后缀的方法是，寻找星号的位置，再用循环赋值。

注意：此方法要在分割字符串之前要先判断字符串长度是否大于前后缀长度，否则会运行错误，就像[这样](https://www.luogu.com.cn/record/78574411)。此外的注意已经放在代码里。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l;
string zh,x;
char qz[505],hz[505]; //qz代表题目给定前缀，hz代表题目给定后缀
int main()
{
	cin>>n>>zh;
	int w=zh.find("*"); //此函数用来寻找星号出现的位置 
	for(int i=0;i<w;i++) qz[i]=zh[i]; //提取前缀 
	for(int i=w+1;i<zh.size();i++) hz[l]=zh[i],l++; //提取后缀 
	while(n--)
	{
		cin>>x;
		int len=x.size();
		if((w+l)<=len) //需要注意的判断 
		{
			string qx=x.substr(0,w),hx=x.substr(len-l,l); //按照前后缀的长度分别提取
			if(qx==qz&&hx==hz) cout<<"DA"<<endl;
			else cout<<"NE"<<endl;
		}
		else cout<<"NE"<<endl;
	}
	return 0;
}
```

---

## 作者：sysong (赞：0)

# 题解P6872 [COCI2013-2014#6] VJEKO

### 题意

给出一个字符串的前一部分与后一部分，判断某字符串是否符合要求。

匹配则输出 $DA$ ，否则输出 $NE$ 。

---

### $Solution$

直接模拟即可。

看到前面已经有人写了 $string$ 的解法，那我就写个字符数组的。

首先读入匹配串。

---

```c++
scanf("%s",key);
l=strlen(key);
for(R int i=0;i<l;i++)
	if(key[i]=='*'){			// 如果到了分界点
        f1=i-1,f2=l-i-1;		// f1 指前一半的长度， f2 指后一半的长度
        break;
    }
```

---

接着对于每一个串进行匹配，先写出一个，然后只要再套一个循环就行了。

**注意：对于长度不足的情况，要特判！**

---

```c++
scanf("%s",str);f=0;				// f 在这里存储该串是否能被匹配（ 0 可以， 1 不行）
ln=strlen(str);
if(f1+f2>ln){						// 如果长度都不够，那么肯定不行，要直接退出。。。
	printf("NE\n");
	continue;
}
for(R int i=0;i<=f1&&!f;i++)		// 匹配前一段
	if(str[i]!=key[i])
		printf("NE\n"),f=1;			// 如果不行，记录 f 为 1 
if(f)continue;						// f 为 1 ，退出
for(R int i=1;i<=f2&&!f;i++)		// 匹配后一段
	if(str[ln-i]!=key[l-i])			// 这里是从后往前匹配的
		printf("NE\n"),f=1;
if(!f)printf("DA\n");				// 如果前后都匹配了，那么一定可以
```

---

### $C++\quad code$

将思路整理，可以得出以下代码（比 $string$ 写法的常数小一点）：

```c++
#include <bits/stdc++.h>
#define R register
#define gc() getchar()
using namespace std;

inline int rd(){
	R int x=0;R char c=gc();//,f=1
	while(c>'9'||c<'0')c=gc();//{if(c=='-')f=-1;
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=gc();
	return x;//*f
}

int main(){
	char key[110],str[110];
	int n=rd(),l,f1,f2,f=0,ln;
	scanf("%s",key);
	l=strlen(key);
	for(R int i=0;i<l;i++)
		if(key[i]=='*'){
			f1=i-1,f2=l-i-1;
			break;
		}
	while(n--){
		scanf("%s",str);f=0;
		ln=strlen(str);
		if(f1+f2>ln){
			printf("NE\n");
			continue;
		}
		for(R int i=0;i<=f1&&!f;i++)
			if(str[i]!=key[i])
				printf("NE\n"),f=1;
		if(f)continue;
		for(R int i=1;i<=f2&&!f;i++)
			if(str[ln-i]!=key[l-i])
				printf("NE\n"),f=1;
		if(!f)printf("DA\n");
	}
	return 0;
}

```

---

***by jsntsys***

$2020.10.29$



---


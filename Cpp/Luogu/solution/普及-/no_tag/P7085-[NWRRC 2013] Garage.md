# [NWRRC 2013] Garage

## 题目描述

哇！多么幸运的一天！你的公司刚刚赢得了一个建造车库综合体的社会合同。几乎所有的手续都已完成：合同款项已经转入你的账户。

所以现在是阅读合同的好时机。好的，有一个 $W \times H$ 的矩形沙地，你需要在那里放置一些车库。车库是 $w \times h$ 的矩形，并且它们的边必须与沙地的对应边平行（你不能旋转车库，即使是 $90^{\circ}$）。车库的坐标可以是非整数。

你知道经济必须是经济的，所以你决定尽可能少地放置车库。不幸的是，合同中有一个相反的要求：放置尽可能多的车库。

现在让我们看看这些要求是如何被检查的……计划被接受的条件是：如果不移动其他车库，就不可能再添加一个新的车库（新车库的边也必须与沙地的对应边平行）。

时间就是金钱，找出必须订购的最少车库数量，以便你可以将它们放置在沙地上，并且没有多余车库的空间。

## 说明/提示

时间限制：2 秒，内存限制：256 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
11 4 3 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 8 3 4
```

### 输出

```
2
```

## 样例 #3

### 输入

```
15 7 4 2
```

### 输出

```
4
```

# 题解

## 作者：CGDGAD (赞：2)

作为这道题的首A，过来发一个题解，纪念一下。

### 题目大意

你有一个 $W \times H$ 的大长方形。你又有无数个 $w \times h$ 的小长方形。请问，最少放入几个小长方形后，你无法再往这个大长方形里放入其他的小长方形。

所有小长方形不能重叠，也不能旋转。

### 解题思路

一看就是一个数学题。

要让这个大长方形中不能再放入更多的小长方形，就是要把小长方形在大长方形中的分布越散越好。但垂直方向上的两个小长方形的距离必须小于 $h$，水平方向上的两个小长方形的距离必须小于 $w$，否则就放得下其他的小长方形了。

最后，我们的实现方式：

- 首先算出水平方向上（宽）最多能放几个长方形。
   - 此处的计算方法如代码中所示，应该能看得懂。
- 再计算出垂直方向上（高）最多能放几个长方形。
- $\times$ 起来，就是答案。


```cpp
#include <cstdio>
#include <cmath>
int W, H, w, h;
int main() {
	scanf("%d%d%d%d", &W, &H, &w, &h);
	int a = (int)ceil( (double)(W - w + 0.000001) / (double)(2 * w - 0.000001) );
	int b = (int)ceil( (double)(H - h + 0.000001) / (double)(2 * h - 0.000001) );
	printf("%d\n", a * b);
	return 0;
}
```

---

## 作者：单调欧文 (赞：1)

#   贪心的想法
------------

  想要放矩形最少，那么每一个矩形占的面积就应该最大；
  当一个矩形想占尽可能大的面积的时候（~~你是拦不住的~~）,其实是可以拦的；
  
  **当它占的长度（和宽度）比自身长度（和宽度）的两倍少一点点（都可以忽略不计）的时候；那么他占的面积必然是最大的；** 
  
  注意 ：当你占完了之后，还有位置刚好可以放，那你不得不放。
  
  代码如下：
```
#include<iostream>
using namespace std;
int n,m,n1,m1;
int main(){
   cin >> n >> m >> n1 >> m1;	
   int ansx = n / (2 * n1);
   int ansy = m / (2 * m1);
   if(n - ansx * (2 * n1) >= n1) ansx += 1;
   if(m - ansy * (2 * m1) >= m1) ansy += 1;
   cout << ansx * ansy; 
	return 0;
}
```
如果还是想不明白，私信；

## 乾坤未定（~~已定~~），你我皆是黑马（~~牛马~~）

---

## 作者：Meng142857 (赞：0)

## 贪心
既然想要让放入的小长方形最少，那就应该让两个长方形之间的空隙最大，但如果两个长方形之间的空隙大于等于长方形的长，所以应该减去一个特别小的数，如$0.000001$之类的即可。  
$AC$代码如下，请勿抄袭：
```cpp
#include<iostream>
using namespace std;
int main(){
	double w1,h1,w2,h2;
	cin>>w1>>h1>>w2>>h2;
	if(w1<w2||h1<h2){cout<<0;return 0;}
	cout<<(((int)((w1-w2)/(w2*2-0.000001/*特别小的数*/))+1)*((int)((h1-h2)/(h2*2-0.000001))+1));
	return 0;
}
```

---

## 作者：Query_Failed (赞：0)

与其他几位大佬用+0.00001取放置距离的想法不同，我的想法是用数学模型解决。
# 思路：
首先先取极端情况，由于放置的距离之差可以无限小（基本上可以忽略），最重要的是最后一个小长方形摆放的位置，因此可以先取两个长方形距离之差就为小长方形的长与宽，然后再根据题目调整。

**在这种情况下的代码：**
```cpp
#include <iostream>
using namespace std;
int main()
{
    int W,H,w,h;
    int wmax=0,hmax=0;
    cin>>W>>H>>w>>h;
    wmax+=W/w/2;
    hmax+=H/h/2;
    cout<<wmax*hmax;
    return 0;
}
```
但由于在实际情况下，两长方形中的距离应该要小于小长方形的长与宽，而且在判断时也不能单纯地把大长方形的长和宽除以2，因此需要加一个特殊的判断，如下：
```cpp
if(W%(2*w)>=w) wmax++;
if(H%(2*h)>=h) hmax++;
```
它就实现了一种特殊情况的判断，便是对于最后一个小长方形摆放在不同位置的分类讨论。

# 最后附上AC代码：
```cpp
#include <iostream>
using namespace std;
int main()
{
    int W,H,w,h;
    int wmax=0,hmax=0;
    cin>>W>>H>>w>>h;
	if(W%(2*w)>=w) wmax++;
    if(H%(2*h)>=h) hmax++;
    wmax+=W/w/2;
    hmax+=H/h/2;
    cout<<wmax*hmax;
    return 0;
}
```


---

## 作者：朱屹涵2008 (赞：0)

## 本题重点：数学算法

### 题目内容概括：

1. 你有一个 *W* * *H* 大小的长方形，以及无数个 *w* * *h* 大小的小正方形。

2. 题目给出 *W* , *H* , *w* , *h* 。

3. 求在这个大长方形中**最少**可以放入几个小长方形，并且**不能再在任意位置放入一个小长方形**。

4. 所有小长方形**不能重叠或旋转**。

------------

### 解题思路：

首先，这肯定是数学题。

然后，寻找最优情况。

如图所示，大致就是这样的，小长方形行、列间隔越大越好，但行间隔不超过 *w* ，列间隔不超过 *h*。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ep00rpz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

最后，代码实现。

以下为AC代码，供参考

```cpp
#include<bits/stdc++.h>
#define MIN 0.000001
using namespace std;
int W,H,w,h; 
int solve(int X,int x){ //求在长度为X的一条线上最少放几条长为x的线，不能够继续放
    int num=ceil((double)(X-(x-MIN))/((double)(x*2)-MIN)); //两线之间间隔尽量最大
    return num;
}
int main(){
    cin>>W>>H>>w>>h;
    cout<<solve(W,w)*solve(H,h);
    return 0;
}
```

---

## 作者：E1_de5truct0r (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P7085)

## 解题思路

题目要求放**最少的**小长方形使得大长方形里**不能够放得下更多的小长方形。**

可以看出来，我们需要让小长方形放的更加**分散**，并且中间不能够装得下其他的小正方形，也就是说两个长方形中间的空隙的**长度小于w，宽度小于h**。这样的话，我们可以把大长方形用**长2倍于小长方形，宽2倍于小长方形的长方形铺满**，但是为了使空隙**不能够**放得下新的小长方形，我们先把长宽分别**减去一个极小值**，这样能保证少放（即使富裕，富裕的地方也一定放不下任何小长方形）。

可得公式：

$$K = \operatorname{ceil}(A - a + 0.001) \div (2 \times a)$$
$$C = \operatorname{ceil}(B - b + 0.001) \div (2 \times b)$$

## 代码
###### 没有坑，请放心食用


```cpp
#include <iostream>
#include <cmath> //不要忘记哦
using namespace std;
int main()
{
	int A,B,a,b; //W和H记录大长方形的长宽 w和h记录小长方形的长宽
	cin>>A>>B>>a>>b;
	int K=ceil((A-a+0.001)/(2*a)),C=ceil((B-b+0.001)/(2*b)); //计算，理由见上
	cout<<K*C;//最后输出长能放下的乘上宽能放下的即可
	while(1) return 0; //并无大碍
}
```


---


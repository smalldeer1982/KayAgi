# [COCI 2007/2008 #6] SEMAFORI

## 题目描述

Luka 在开卡车，路上有 $n$ 个信号灯。 

对于每个信号灯，他都知道红灯和绿灯亮的时间（循环不断重复）。

Luka 开始开车时，所有交通信号灯都呈红色，并且开始循环。 

Luka 每秒移动 $1$ 个距离单位。当交通信号灯为红色时，他要停车，直到它变成绿色。

编写一个程序，确定 Luka 需要多少时间才能到达路的尽头。 

道路的起点在 $0$ 处，终点在 $l$ 处。

## 说明/提示

#### 样例 #1 解释
在第一个示例中，Luka 在第一个信号灯处等待 $2$ 秒。 接着，他将到达第二个交通信号灯，该信号灯为绿色，可以立即通过。
#### 数据规模及规定
对于 $100\%$ 的数据，$1 \le n \le 100$，$1 \le l \le 10^3$，$1 \le d < l$，$1 \le r \le 100$，$1 \le g \le 100$。
#### 说明
- 本题满分 $30$ 分。
- 本题默认开启 O2 优化开关。
- 题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #6](https://hsin.hr/coci/archive/2007_2008/contest6_tasks.pdf) T2 SEMAFORI，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
2 10
3 5 5
5 2 2 
```

### 输出

```
12```

## 样例 #2

### 输入

```
4 30
7 13 5
14 4 4
15 3 10
25 1 1 
```

### 输出

```
36```

# 题解

## 作者：efgh123 (赞：6)

## 题意

[传送门](https://www.luogu.com.cn/problem/P7190)

 Luka 在开卡车，路上有很多信号灯。 

对于每个信号灯，他都知道红灯和绿灯亮的时间（循环不断重复）。

Luka 开始开车时，所有交通信号灯都呈红色，并且开始循环。 

Luka 每秒移动 $1$ 个距离单位。当交通信号灯为红色时，他要停车，直到它变成绿色。

编写一个程序，确定 Luka 需要多少时间才能到达路的尽头。 

道路的起点在 $0$ 处，终点在 $l$ 处。

## 思路

**模拟题!!!**

1.输入

2.模拟每一秒

2.（1）时间加$1$

2.（2）判断是否碰到红绿灯

2.（3）碰到红绿灯碰到灯色

3.输出

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,l,Luka=0,t=0,k=0;
	cin>>n>>l;
	int d[n],r[n],g[n];
	for(int i=0;i<n;i++){
		cin>>d[i]>>r[i]>>g[i];
	}
	while(Luka!=l) {
		t++;
		if(Luka!=d[k]){
			Luka++;
		}
		else {
			int m=t%(r[k]+g[k]);
			if(m==0||m>r[k]){
				Luka++;
				k++;
			}
		}
	}
	cout<<t;
	return 0;
}
```

---

## 作者：sid_shi1 (赞：5)

题目：[P7190 [COCI2007-2008#6] SEMAFORI](https://www.luogu.com.cn/problem/P7190)

思路：

这里给出一个较为简单的做法。

我们用变量 $s$ 存储当前走过的路程的长度，用 $sum$ 存当前用了的时间和。本题可以直接一边输入一边操作，每次输入三个数 $x$ ， $y$ ， $z$ ，然后将 $s$ 更新为 $x$ ， $sum$ 要加上走过这段路程的时间和等待红灯的时间，走过这段路程的时间其实就是 $x-s$ ，接下来我们只要看一下现在 $sum$ 处于红灯还是绿灯的时间内，若处于绿灯则不用加等待的时间，否则加上剩下还需等待的红灯的时间就行了。

需要注意的是，$sum$ 还要加上从最后一个信号灯走到终点所需的时间（由于终点没有灯，不需要加上等灯的时间），也就是  $l-s$ 。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,s=0,sum=0;
int main(){
	scanf("%d%d",&n,&l);
	for(int i=1;i<=n;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		sum+=x-s;//加上路程的时间
		if(sum%(y+z)<=y) sum+=y-sum%(y+z);//若是红灯，加上还需等待红灯结束的时间
		s=x;//更新当前路程
	}
	sum+=l-s;//总时间加上从最后一个信号灯走到终点所需的时间
	printf("%d",sum);
	return 0;
}
```


~~求赞QAQ~~

---

## 作者：zct_sky (赞：4)

根据题目可知，这是一道模拟题（~~大水题~~）。

只需要模拟出到达每个红绿灯时是绿灯还是红灯就行了，也就是说，用已经经过的时间( $ans$ )去除以每个红绿灯的周期( $r_i+g_i$ ),得到到达每个红绿灯时的时间，再和红灯时间( $r_i$ )比较即可。

如果是红灯( $ans\%(r_i+g_i)<r_i$ )，则加上到绿灯的时间( $r_i-ans\%(r_i+g_i)$ )；

如果是绿灯( $ans\%(r_i+g_i)>=r_i$ )，则直接通行。

### AC代码
```c++
#include<bits/stdc++.h>
using namespace std;
int n,l,d[110],r[110],g[110],ans=1;
int main(){
	cin>>n>>l;
	for(int i=0;i<n;i++)cin>>d[i]>>r[i]>>g[i];//输入 
	d[n]=l,g[n]=1;//放入终点，g[n]=1是为了防报错 
	for(int i=n;i>=1;i--)d[i]-=d[i-1];//求出从一个红绿灯到下一个红绿灯的距离（包括终点） 
	for(int i=0;i<=n;i++){//模拟 
		ans+=d[i];
		if(ans%(r[i]+g[i])<r[i])ans+=r[i]-ans%(r[i]+g[i]);//判断是否是红灯，如果是，则加上到绿灯的时间 
	}
	cout<<ans;//输出答案 
	return 0;
} 
```

---

## 作者：SUNCHAOYI (赞：3)

由题可知路程所花费的时间一定为 $l$，所以我们要计算的便是等待红灯所花费的时间。

> $\color{blue}\text{Luka 开始开车时，所有交通信号灯都呈\color{red}红色\color{blue}，并且开始循环。}$

> $\color{blue}\text{信号灯将按}$ $d$ $\color{red}\text{升序排列}$。

这两句话是本题的关键。因为有序读入红绿灯的距离，所以只要从 $1$ 至 $n$ 顺次枚举。由题意知每个红绿灯的周期为 $g_i + r_i$，所以每到一个路口时，判断当前的状况，若为红灯，则在答案中加上等红灯的时间，并会影响下一次的情况判断。

给下代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init(x) memset (x,0,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f
using namespace std;
const int MAX = 150;
const int MOD = 1e9 + 7;
ll read ();
int n,m,ans; 
struct traffic
{
	int s,r,g;
} a[MAX];
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	n = read ();m = read ();
	for (int i = 1;i <= n;++i)
	{
		a[i].s = read ();
		a[i].r = read ();
		a[i].g = read ();	
	}
	for (int i = 1;i <= n;++i)
	{
		ans += a[i].s - a[i - 1].s;//路程距离
		int rest = ans % (a[i].r + a[i].g);//留下单个周期的不完整部分
		if (rest < a[i].r) ans += a[i].r - rest;//等待红灯的时间
	}
	printf ("%d\n",ans + (m - a[n].s));//最后的路程不能忘
	return 0;
}
ll read ()
{
    ll s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}

```

---

## 作者：浊酒青灯 (赞：2)

这道题思路是可以计算到达每一个红绿灯的时候算出所需要的时长。

已知亮红灯时长和亮绿灯时长，加起来就是该红绿灯一个周期。

到达该红绿灯所需时长%该红绿灯周期=我们在现在这个周期的时间点。

如果时间点处于周期的红灯时间，计算仍需等待时间；

如果时间点处于周期的绿灯时间，则通行。

附代码：

```cpp
#include<iostream>
using namespace std;
int main()
{
	int n, l, d[100], r[100], g[100], time = 0, ans;//time是等红灯总时长，ans才是最终答案
	cin >> n >> l;
	for (int s = 0; s < n; s++)
	{
		cin >> d[s] >> r[s] >> g[s];
		d[s] += time;//到达该红灯时长是路程时长加上之前等红灯总时长
		d[s] %= (r[s] + g[s]);//减去该红灯周期
		if (d[s] < r[s])//红灯的时候就加上等待时长
			time += r[s] - d[s];
	}
	ans = time + l;//等待红灯时长加上路程时长就是答案
	cout << ans;
}
```
第一次写题解，格式不对还请包涵。

---

## 作者：追梦之鲸 (赞：1)

本蒟蒻的第$010$篇题解。

[经典回顾P7190](https://www.luogu.com.cn/problem/P7190)


其实这就是一道模拟题。

### 思路：

我们令``ans``表示最终的答案，``x``代表上一个红绿灯出现的时间

然后我们开始玄学的解答时间：

我们先``ans+=d+x``

为啥？

因为``ans``是过完第``i-1``个红绿灯的时间``ans+=d+x``是到第``i``个红绿灯的时间(没过)

然后，我们再 ``x=d``(这个没神马好讲的吧……)


### 而后，我们``f=ams%(a+b);if(f<0)ans-=f``

上面就是本题的核心！但是我想让各位大佬们自己思考，我给两个提示：

- ``a+b``是神马意思

- ``ans-=f`` 是神马意思

此算法空间和时间复杂度都很小所以很就很轻松的A了

好了，本题您看完基本上就能AK了，但是，别忘了一点：

## ``ans+=m-x！``

## ``ans+=m-x！``

## ``ans+=m-x！``

原因是``ans``是过最后一个红绿灯的时间，而不是到达终点的时间


代码太水了，就不贴了，想要的私信QWQ


最后管理大大求过&&[**来玩啊**](https://www.luogu.com.cn/user/361726)

---

## 作者：_caiji_ (赞：1)

这题就按题意计算就可以了。

1. 输入，注意不需要给信号灯排序。
1. 循环枚举 $i$，$1\to n$。
1. 每一次循环 $now\to now+(d_i-d_{i-1})$，加上相邻两个信号灯之间的距离。这里定义 $d_0=0$，方便计算起点到第一个信号灯的距离。如果数组下标从 $0$ 开始就要注意特判 $i=0$。
1. 算出红绿灯周期，$now\mod (r_i+g_i)$，并记为 $tmp$，下一步判断是红灯还是绿灯。
1. 如果 $tmp\leq r_i$，说明现在在等红灯，那么加上剩余的时间 $r_i-tmp$。
1. 最后加上最后一个信号灯到终点的距离 $l-d_n$，输出 $now$。
```cpp
#include <cstdio>
using namespace std;
int n,l,d[110],r[110],g[110],now;//数组开在函数外自动赋0，保证了d[0]一定为0
int main(){
    scanf("%d%d",&n,&l);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&d[i],&r[i],&g[i]);//step 1
    for(int i=1;i<=n;i++){//step 2
        now+=d[i]-d[i-1];//step 3，我这里下标从1开始，不用特判
        int tmp=now%(r[i]+g[i]);//step 4
        now+=tmp>r[i]?0:r[i]-tmp;//step 5，纯压行，三目运算符?:和if是一样的
        //这里代码相当于以下两段：
        /*
      	    if(tmp>r[i]){
                now+=0;
          	}else{
              	now+=r[i]-tmp;
          	}
      	*/
      	/*
          	if(tmp<=r[i]){
              	now+=r[i]-tmp;
          	}
      	*/
      
    }
    now+=l-d[n];
    printf("%d",now);//step 6
    return 0;
}
```

---

## 作者：_farawaystar_ (赞：1)

#### 题目分析

本题一个边读入边处理的过程：

首先，可以把一组红绿灯 $r+g$ 看成整体，一共通过 $l/(r+g)$ 组信号灯，Luka到达最新一组信号灯时的时间，即 $x=l\%(r+g)$ 。

然后，总等待时间加上最新一轮等待时间，即  $z+=\max(0,x-r)$ ，即可得出答案。

代码:

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,q,x[100],r[100],g[100],z;
int main(){
    scanf("%d%d",&n,&l);
    for (int i=q;i<=n;i++){
     	scanf("%d%d%d",&x[i],&r[i],&g[i]);
        x[s]=(x[s]+z)%(r[s]+g[s]);
        z+=max(r[s]-x[s],0);
    }
    printf("%d",z+q);
    return 0;
}

```

谢谢大家！！！

---

## 作者：fanypcd (赞：0)

### 题目简述：

[P7190 [COCI2007-2008#6] SEMAFORI](https://www.luogu.com.cn/problem/P7190)

### 题目思路：

- 小模拟。
- 观察数据范围发现对于 $100\%$ 的数据，$1\leq n\leq100, 1\leq l\leq 10^3,1\leq r,g\leq 100$
- 所以一秒一秒的模拟状态的复杂度仍然可以接受。
- 使用结构体保存每个灯的信息。
- 开一个数组 $situ[n][2]$，其中 $situ[i][0]$ 表示第 $i$ 号路灯目前的状态：红（0），绿（1），$situ[i][1]$ 表示第 $i$ 号路灯目前的状态距离结束还有多少秒。
- 这样枚举时间的时候将所有 $situ[i][1]\to situ[i][1] - 1$，当 $situ[i][1]==0$ 时切换就好。
- 用 $pos$ 记录当前位置，$time$ 记录总时间，这道题就完了。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct light
{
	int d, r, g;
};
light li[105];
int situ[105][2];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, l, pos = 0, time = 0, st = 1;
	cin >> n >> l;
	for(int i = 1; i <= n; i++)
	{
		cin >> li[i].d >> li[i].r >> li[i].g;
		situ[i][0] = 0;
		situ[i][1] = li[i].r;
	}
	while(pos != l)
	{
		time++;
		for(int i = 1; i <= n; i++)
		{
			situ[i][1]--;
			if(situ[i][1] == 0)
			{
				situ[i][0] = !situ[i][0];
				situ[i][1] = (situ[i][0] == 0 ? li[i].r : li[i].g);
			}
		}
		if(li[st].d == pos)//判断目前是否要经过灯
		{
			if(situ[st][0] == 1)//绿色状态，可以通过
			{
				pos++;
				st++;
			}//这里省略了 else 语句，因为等待不需要做任何操作
		}
		else//还未到下一个灯的位置
		{
			pos++;
		}
	}
	cout << time + 1;
	return 0;
}
```


---


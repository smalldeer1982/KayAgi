# [COCI 2020/2021 #4] Pizza

## 题目背景

在一个漫长而痛苦的一天快要结束时，Mirko 决定订一个比萨来提神。在他书桌的一堆纸中，他找到了一个附近比萨店的传单。

## 题目描述

比萨店提供 $m$ 种不同的比萨。比萨的配料使用正整数来编号。第 $i$ 个比萨有 $k_i$ 种配料，编号分别为 $b_{i,1},b_{i,2},\cdots,b_{i,k_i}$。

Mirko 在食物面前格外挑剔。他不喜欢其中的 $n$ 种配料，即编号为 $a_1,a_2,\cdots,a_n$ 的配料，因此他想订购一个没有上述配料的比萨。求 Mirko 能订购的比萨的数量。

## 说明/提示

#### 数据规模与约定

对于 $40\%$ 的数据，$n=k_1=k_2=\cdots=k_m=1$。

对于 $100\%$ 的数据，$1 \le n,m,a_i,k_i,b_{i,j} \le 100$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf)  _T1 Pizza_。**

## 样例 #1

### 输入

```
1 2
3
1 1
1 2
1 3```

### 输出

```
2```

## 样例 #2

### 输入

```
2 1 2
4
2 1 4
3 1 2 3
2 3 4
3 3 5 7```

### 输出

```
2```

## 样例 #3

### 输入

```
1 4
3
1 1
1 2
1 3```

### 输出

```
3```

# 题解

## 作者：银河AI (赞：9)

### 思路

正解（?）：桶（?）

看完题目后，第一眼就发现，这不就是道~~水模拟~~吗（雾）

由于数据范围小的很 $n\le100$

所以我们考虑用一个桶来记录 $Mirko$ 不喜欢的配料，代码如下：

```cpp
for(int i=1;i<=n;i++) scanf("%d",&a[i]),t[a[i]]=1;
```
接下来，当输入披萨的配料时，用一个标记来说明当前披萨有无 $Mirko$ 不喜欢的配料，如果当前披萨无他不喜欢的配料，那么就ans++
```cpp
for(int j=1;j<=k;j++){
	scanf("%d",&x);
	if(t[x]) trap=1;
}
```


没错就是这么简单，接下来放出AC代码

时间复杂度 $O(mk+n)$，空间复杂度 $O(max(A_{i}))$

### AC代码（有注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
int a[105],b[105],t[105];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),t[a[i]]=1;//输入Mirko不喜欢的配料，并用桶标记 
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int k,x,trap=0;scanf("%d",&k);//k代表当前披萨有几个配料，x代表是哪种配料，trap标记当前披萨有无Mirko不喜欢的配料 
		for(int j=1;j<=k;j++){
			scanf("%d",&x);
			if(t[x]) trap=1;//如果当前配料Mirko不喜欢，则标记为1
		}
		if(trap==0) ans++;//如果没有被标记，则ans++ 
	}
	printf("%d",ans);
}
```

蒟蒻的第一篇题解，望管理员通过



---

## 作者：CoronaQL (赞：4)

# 插话
~~吃什么披萨汉堡它不香吗~~
# 思路
他显然是想要我们挨个扫，然后进行标记，最后输出就好了
## 写法
写一个子程序，对数据标记，然后在主程序调用就好了
# AC代码看这里！
```cpp
# include <cstdio>
# include <iostream>
# include <cstring>
# include <cmath>
# include <queue>
# include <algorithm>
# include <string>//一堆头文件 
using namespace std;
int m, k, dl[105], pln[105], pl[105][105], ans = 0;//变量们 
bool eat(int x)//吃 
{
	for(int i = 1 ; i <= pln[x] ; i++){
		for(int j = 1 ; j <= m ; j++)
			if(pl[x][i] == dl[j])
				return false;
	}
	return true;
}

int main()
{
	cin >> m;
	for(int i = 1 ; i <= m ; i++)
		cin >> dl[i];
	cin >> k;
	for(int i = 1 ; i <= k ; i++){
		cin >> pln[i];
		for(int j = 1 ; j <= pln[i] ; j++)
			cin >> pl[i][j];
		if(eat(i)) ans++;//调用 
	}
	cout << ans << endl;
	return 0;
}
```
希望管理员大大过了吧！蒟蒻写了1个多小时呢！

---

## 作者：dead_X (赞：2)

## 前言
同机房的都在做生成函数神仙题，我太菜了，就来切个红题水个题解吧。
## 思路
显然我们可以对于某个披萨**独立**考虑，即每个披萨之间没有关系。

根据题目，只要一个披萨中没有 Mirko 不喜欢的配料，这个披萨就能选。

我们可以对于每一个配料判断是否是 Mirko 不喜欢的，有以下几种方法：

1. 暴力枚举 Mirko 不喜欢的配料中是否有这个数。

时间复杂度 $\text{O}(nmk)$，空间复杂度 $\text{O}(n)$，码量小。

2. 开桶记录每个配料是否是 Mirko 不喜欢的。

时间复杂度 $\text{O}(n+mk)$，空间复杂度 $\text{O}(a_i)$，码量小。

3. 用 Hash 表代替开桶过程。

时间复杂度 $\text{O}(n+mk)$，空间复杂度 $\text{O}(n)$，如果不使用 ``std::unordered_map`` 码量较大。

对于每个披萨，如果我们能选，则一定选，最终答案即为能选的数量。
## 代码
代码实现使用了第二种方法。

```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int f[103];
signed main()
{
    int n=read(),ans=0;
    for(int i=1; i<=n; i++) f[read()]=1;
    for(int t=read(),x; t--;)
    {
    	x=read();
    	bool g=1;
    	for(int i=1; i<=x; ++i) if(f[read()]==1) g=0;
    	ans+=g;
    }
    printf("%d\n",ans);
	return 0;
}
```

---

## 作者：WinterRain208 (赞：2)

这题比较简单的原因是数据放宽了，大一些的话难度会狂涨。

有$n$个元素，每个元素有若干特征值，另有一个元素列表$k$，问$n$个元素中有几个元素的特征值和这个元素列表$k$无交集。

### $SOLUTION$

按题意模拟即可，先读入$k$，接下来每读入一个$n_i$和他的特征，就用$O(n^2)$判断，总复杂为$O(n^3)$，能通过$1e2$的数据。

### 代码

```cpp
#include<bits/stdc++.h>
#define F(i,j,r) for(int i=j;i<=r;++i)

using namespace std;
#define N 105

int n,m,x,ans=0,tot;
int bad[N]; 
int main(){
	scanf("%d",&n);
	F(i,1,n)scanf("%d",&bad[i]);
	scanf("%d",&m);
	F(i,1,m){
		bool flag=true;
		scanf("%d",&tot);
		F(j,1,tot){
			scanf("%d",&x);
			F(k,1,n)
			if(x==bad[k]){
				flag=false;
				break;
			}
		}
		ans+=flag;
	}
	printf("%d\n",ans);
    return 0;
}

```

$wtrl$

---

## 作者：渡鸦2007 (赞：1)

# 题意
略
# 分析
此题较为简单。基本思路为：对于每个披萨，枚举其配料，再枚举不喜欢的配料，如相同，则将 $flag$ 变量设为 $false$。若穷举后 $flag$ 仍为真，则计数器 $cnt$ 加一。

时间复杂度为 $O(n^3)$。其中，一层用于输入每个披萨，一层输入配料，一层枚举不喜欢的配料判断。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int dl[110];//定义不喜欢的数组Dislike
int main()
{
	int n;
	scanf("%d",&n);
	for (register int i=1;i<=n;++i)// register 可以去掉
	{
		scanf("%d",&dl[i]);
	}
	int m;
	scanf("%d",&m);
	int cnt=0;//计数器 
	for (register int i=1;i<=m;++i)
	{
		int num;//配料个数 
		scanf("%d",&num);
		bool flag=true;//能否选择 
		for (register int j=1;j<=num;++j)
		{
			int now;//现在的配料 
			scanf("%d",&now);
			for (register int k=1;k<=n;++k)
			{
				if (dl[k]==now)//如相同则退出
				{
					
					flag=false; 
					break;
				}
			}
		}
		if (flag==true)
		{
			++cnt;
		} 
	}
	printf("%d",cnt); 
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

---

## 作者：Leasier (赞：0)

考虑在输入第一行时标记哪些食材不能用，然后在输入每个披萨时枚举该披萨的每个配料，若该披萨的配料均未被标记，则答案加 $1$；否则，答案不变。

具体细节见代码注释。

代码：
```c
#include <stdio.h>
#include <stdbool.h>

bool mark[107];

int main(){
	int n, m, ans = 0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x;
		scanf("%d", &x);
		mark[x] = true; // 标记该食材是否可以使用
	}
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		int k;
		bool flag = true;
		scanf("%d", &k);
		for (int j = 1; j <= k; j++){
			int x;
			scanf("%d", &x);
			if (mark[x]) flag = false;
		}
		if (flag) ans++; // 统计答案
	}
	printf("%d", ans);
	return 0;
}
```

---


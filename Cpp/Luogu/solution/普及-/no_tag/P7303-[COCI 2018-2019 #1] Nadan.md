# [COCI 2018/2019 #1] Nadan

## 题目描述

Nadan 是一个成功的商人。他经常对软件开发者进行投资。

今年，他决定将 $K$ 库纳（克罗地亚货币）分配给 $N$ 个项目，使得每个项目能分配至少 $1$ 库纳，并且两两之间得到的数量互不相等且均为正整数。数据保证，这样的分配方式一定存在。

## 说明/提示

#### 数据规模与约定

对于 $50\%$ 的数据，$N=5$。

对于 $100\%$ 的数据，$100 \le K \le 10^6$，$1 \le N \le 100$。

#### 评分方式

如果一组数据中，存在相同的分配金额，但总和正确，则可以获得该数据满分 $5$ 分中的 $3$ 分。

本题启用非官方的自行编写的 [Special Judge](https://www.luogu.com.cn/paste/g6huzk80)，也可在附件中获取。由于 Special Judge 的原因，请在输出的最后一个数字后添上一个换行符。欢迎大家 hack（可私信或直接发帖）。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #1](https://hsin.hr/coci/archive/2018_2019/contest1_tasks.pdf)  _T1 Nadan_。**

## 样例 #1

### 输入

```
100
5```

### 输出

```
10
30
20
5
35```

## 样例 #2

### 输入

```
200
1```

### 输出

```
200```

## 样例 #3

### 输入

```
100
4```

### 输出

```
21
36
12
31```

# 题解

## 作者：Thomas_Cat (赞：23)

这题签到比较的过分（

对于该题，由于数据保证一定每一个公司金额不相同并且数据存在存在这样的情况，因此只需要每一个公司 $+1$ 最后数据 $k- \sum\limits_{i=1}^{n-1}i$ 即可，当然，在 $for$ 循环输出的过程中就可以实现 $\sum$ 的计算。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int k,n;
    cin>>k>>n;
    for(int i=1;i<n;i++){//在for循环的过程中输出 i
        cout<<i<<endl;
        k-=i;//每一次实现Σ的目的
    }
    cout<<k;//输出 k-Σ 即可
    return 0;
}
```

---

## 作者：feicheng (赞：9)

# 递归主函数

一句话题意：将一个数 $k$ 分成 $n$ 个数，保证这 $n$ 个数互不相同，求一种方案。

做法：贪心，从小到大一个个分割，分到最后一个直接输出剩下的即可。

本题解最有趣的地方在于递归主函数（没想到吧，主函数也可以递归）

```cpp
#include <bits/stdc++.h>
int n,k,flag,tim;
int main(){
	if(!flag) std::cin >> k >> n,++flag;//第一次调用需要输入数据
	if(flag < k && ++tim < n) k -= flag,std::cout << flag++ << '\n',main();//再次调用主函数，实质上是执行分割操作
	else std::cout << k << '\n';//递归边界：分割次数到第n次或者当前的分割值已经大于k
	return 0;
}
```

完结撒花！！


---

## 作者：Aiopr_2378 (赞：5)

# Solution [COCI2018-2019#1] Nadan

你乍眼一看样例数据会绝得很难，但是看到这个东西:  $Special Judge$ ,聪明的小朋友就会说了：

## 签到题！！！

根据题意我们只需要找出一种情况，满足对于 $i$ 和 $j$ $(i,j∈a)$ ， $a_i!=a_j$ ，其中， $a$ 为分配库纳的数组（答案数组）

所以我们可以在合法情况下改变一下样例答案，就会有发现：

**第 $1$ 个到第 $n-1$ 个项目，每个项目可以分配 $i$ 个库纳，第 $n$ 个项目可以分配 $k-(1+2+3+...+n-1)$ 个库纳.**

下面是实现程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n,sum;
int main(){
	cin>>k>>n;
	for(int i=1;i<n;i++){
		cout<<i<<endl;//第1到第n-1个项目花费i个库纳
		sum+=i;//记录花费的库纳
	}
	cout<<k-sum;//最后一个项目可以花费剩余所有的库纳
	return 0;
}
```

# END

---

## 作者：_lfxxx_ (赞：2)

本蒟蒻的第一篇题解。~~没想到这题这么水。~~

## 题意：

给定正整数 $k$和$n$， 将 $k$ 分成 $n$ 个不同正整数的和。

## 思路：

从$1$开始依次向上$+1$，加到 $k-1$。最后一个数为 $n$ 减前面数的和。

## 代码实现：
```c++
#include<bits/stdc++.h>//万能头文件
using namespace std;
int k,n,i,s;//定义变量
int main(){
	scanf("%d%d",&k,&n);// 读入k,n
	for(i=1;i<n;i++){// 枚举1加到n-1
	    printf("%d\n",i);//输出前面的数
	    s+=i;//求前面数的和。
	}
	printf("%d",k-s);//输出最后一个数
	return 0;
}
```

---

## 作者：LinkZelda (赞：2)

- **题意**：

将一个数 $k$ 拆分为 $n$ 个数，使得每一个数均为正整数且互不相同 。

- **做法**：

因为最小要大于等于 $1$ ，所以我们可以从 $1$ 开始分 $n-1$ 份，每份比前一份要大 $1$ ，这样可以保证前 $n-1$ 个数互不相同。

最后一个数就是分剩下的 $k-\sum^{n-1}_{i=1}i$ ,因为题目保证了有解，而且我们这样分的话最后一个数一定是最大的，肯定有解。

- **代码如下**：

```cpp
#include<cstdio>
#include<algorithm>
#include<ctype.h>

using namespace std;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;if(ch=='Q')return 0;if(ch=='A')return 1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return x*f;
 } 
 
int n,k;

int main()
{
	k=read(),n=read();
	for(int i=1;i<n;i++)
	{
		printf("%d\n",i);
		k-=i;
	}
	printf("%d",k);
	return 0;
}
```

---

## 作者：Talanton_Cerydra (赞：1)

[P7303](https://www.luogu.com.cn/problem/P7303)

入门级题目,做法较为随便.

**但是!!!**

**本人有强迫症,想从大到小输出!!!**

因此我建立了一个数组,先将 $1$ 至 $n-1$ 存储到数组内,然后将剩下的最后一个数也存入数组.

然后倒序输出(下标从 $n$ 到 $1$ ),就能满足题目的要求了!~~还适应了我的强迫症~~

## 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[101];//存储数组
int k,n;
int main()
{
    scanf("%d%d",&k,&n);//输入k和n
    for(int i=1;i<n;i++)//注意要留出最后一个数
    {
        a[i]=i;//从1到n-1
        k-=i;
    }
    a[n]=k;//存储最后一个数
    for(int i=n;i>=1;i--)//倒序输出
    {
        printf("%d\n",a[i]);//记住:要换行
    }
    return 0;
}
```

[彩蛋](https://www.luogu.com.cn/blog/paiwyz314/)

---

## 作者：int32 (赞：1)

人生首灰，~~可能会评红~~

看到样例以为思路错了，直到看到蛇皮$Judge\ldots\ldots$

-----------------------------分割线---------------------------------

### 思路简述

贪心

第$i$个项目分$i$库纳$(1\leq i< N)$，第$N$个项目分$K- \sum_{i=1}^{N-1}i\ \ $ 库纳（反过来分也行）

$\because$题目数据保证有解，

$\therefore$第$N$个项目分得的库纳数**恒**大于$N-1$（仔细想想为什么）

$\therefore$可以保证第分得的钱不重复

温馨提示：输出需要换行输出

### Code

```
#include<bits/stdc++.h>
using namesapce std;
int n, k, v;
int main(){
    cin>>k>>n;
    for(int i=1;i<n;i++){
        cout<<i<<"\n";//换行
        v+=i;//v=Σ
    }
    cout<<k-v;//输出
    return QwQ;
}
```

~~窝是不会告诉你我防作弊了的~~

#### 管理员大大求过

蒟蒻求赞！

---

## 作者：LiuHao2019 (赞：1)

本蒟蒻的第一篇题解，~~居然这么水，签到题签到题~~

看了一眼大佬们的题解，居然没人用高斯公式

~~高斯：我****~~

所以我就发一篇高斯公式的题解~~来安慰高斯~~

高斯求等差数列的和的公式：

和=（首项+末项）×项数/2

~~就这么简单~~

~~然而高斯小学就发现了~~

```
这题应该是入门题QWQ，就是枚举K个互不相同的正整数，使它们的和为N,连数据范围……都是那么友好

```

等等，满分怎么是50分QWQ

```cpp
#include<stdio.h>
int k,n;
int main(){
	scanf("%d%d",&k,&n);
	for(int i = 1;i < n;i ++) printf("%d\n",i);//就是1、2、3、4、5……QWQ
	//这些数的和为（1+n-1）*（n-1）/2，高斯公式
	//即n*（n-1）/2 
	printf("%d\n",k-n*(n-1)/2);//别忘了换行 
} 
```


---

## 作者：Griseo_nya (赞：1)

题目要求 $n$ 个项目分配 $k$ 个库纳，而且数据保证有解，那么此时我们可以想到贪心的思路（况且还有 SPJ ）。

因为只要每个项目至少 $1$ 库纳，并且不同，很容易可以想到可以从 $1$ 到 $n$ 循环，在小于 $n$ 时输出当前循环次数，等于 $n$ 时输出剩余的 $k$ 即可。

顺便提一下下面的题解中递归 main() 函数的方法在 C++20 中会报错！~~（可是CCF不是只开到C++98吗）~~

代码参上！
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int k,n;
	cin>>k>>n;
	for(int i=1;i<=n;i++){
		if(i==n)cout<<k<<endl;		//等于 n 时输出剩余的 k
		else{
			k-=i;					//减去当前花的钱
			cout<<i<<endl;			//输出当前花的钱
		}
	}
	return 0;
}
```


---

## 作者：tribool4_in (赞：0)

> 每个项目要分配至少 1 库纳，并且两两之间得到的数量互不相等。

那就有一种显而易见的贪心，由于分配方式一定存在，只需对于第 1 个项目分配 1 库纳，第 2 个项目 2 库纳……第 $n-1$ 个项目 $n-1$ 库纳，然后最后一个项目分配 $(k-\sum^{n-1}_{i=1}i)$ 库纳即可。

代码：

```cpp
// Code By WLS
#include <bits/stdc++.h>
using namespace std;
inline int read() {
	int s=0, w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int n, k;
signed main() {
	k = read(), n = read();
	for (int i = 1; i < n; i++) {
		printf("%d\n", i);
		k -= i; // 剩余的钱
	}
	printf("%d\n", k);
	return 0;
}

```


---


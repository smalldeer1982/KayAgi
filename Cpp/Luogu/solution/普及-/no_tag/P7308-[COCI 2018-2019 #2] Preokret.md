# [COCI 2018/2019 #2] Preokret

## 题目描述

假如我们正在观看一场未来的球赛，比赛双方是 A 队和 B 队。我们知道两队的得分和每次得分的准确时间。在一秒内，不可能有超过一次得分。

King James 想要得到两个问题的答案：

1. 上半场总共得了多少分？（整场比赛持续 $4 \times 12$ 分钟）
2. 发生多少次反超？（一次反超定义为一支队伍在得分小于对方后，经过投球使得得分超过对方）

## 说明/提示

#### 样例 2 解释

|比分（A:B）|时间（秒）|所属半场|是否发生反超|
| :----------: | :----------: | :----------: | :----------: |
|$1:0$|$15$|$1$|否|
|$1:1$|$20$|$1$|否|
|$1:2$|$25$|$1$|是（B）|
|$2:2$|$30$|$1$|否|
|$3:2$|$35$|$1$|是（A）|
|$3:3$|$40$|$1$|否|
|$3:4$|$45$|$1$|是（B）|
|$3:5$|$50$|$1$|否|
|$4:5$|$55$|$1$|否|
|$5:5$|$60$|$1$|否|
|$6:5$|$2065$|$2$|是（A）|
|$6:6$|$2070$|$2$|否|
|$6:7$|$2075$|$2$|是（B）|

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le A,B \le 2879$，$1 \le A_s,B_s \le 2880$。

#### 评分方式

每组数据第一行计 $2$ 分，第二行计 $3$ 分，每组数据共 $5$ 分。

评分需要借助 Special Judge，详见附件。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #2](https://hsin.hr/coci/archive/2018_2019/contest2_tasks.pdf)  _T1 Preokret_。**

## 样例 #1

### 输入

```
3
10
1400
1500
2
7
2000```

### 输出

```
3
1```

## 样例 #2

### 输入

```
6
15
30
35
55
60
2065
7
20
25
40
45
50
2070
2075```

### 输出

```
10
5```

## 样例 #3

### 输入

```
11
1402
1412
1428
1430
1441
1444
1453
1483
1485
1489
1490
9
1403
1405
1409
1435
1459
1460
1461
1487
1495```

### 输出

```
8
2```

# 题解

## 作者：_Spectator_ (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P7308)

---
### ${\color{SkyBlue}Analysis}$ 
我们需要得到**两个问题**的答案：

1. 上半场总共得了多少分？（整场比赛持续 $4 \times 12$ 分钟。）
2. 发生多少次反超？（一次反超定义为一支队伍在得分**小于对方**后，经过投球使得**得分超过对方**。）

---
### ${\color{SkyBlue}Ideas}$
（1）我们首先来解决第一个问题：
由于整场比赛持续 $4 \times 12$ 分钟，所以上半场比赛共有 $2*12*60=1440(s)$ 。那么只要 $t_i<=1440$ ，就要增加 $ans$ 。

（2）我们接着解决第二个问题：
**我们可以先计算每一个时刻的分数**。如果有队伍在之前的分数是小于对方，现在的分数是大于对方，那么这就是反超！~~（其实真的很简单！！）~~
但是，我们需要注意这种情况：

|A队分数|B队分数|
| :----------: | :----------: |
| 3 | 4 |
| 4 | 4 |
| 4 | 5 |

这是不算反超的！！（因为B队一直都是领先A队的。）

---
### ${\color{SkyBlue}Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans=0,anss=0,ld;//ld是记录当前谁领先（a=>1,b=>2)
int a[3000],b[3000],jsa[3000],jsb[3000];
int main()
{
	scanf("%lld",&n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&a[i]);
		if(a[i]<=1440) ans++;//在上半场得分
		jsa[a[i]]=1;
	}
	scanf("%lld",&m);
	for(int i=1; i<=m; i++)
	{
		scanf("%d",&b[i]);
		if(b[i]<=1440) ans++;//在上半场得分
		jsb[b[i]]=1;
	}
	printf("%lld\n",ans);

	for(int i=1; i<=3000; i++)
		jsa[i]+=jsa[i-1],jsb[i]+=jsb[i-1];//记录每一个时刻的两队分数

	for(int i=1; i<=3000; i++)
	{
		if(jsa[i]>jsb[i] && jsa[i-1]==jsb[i-1] && ld==2) //A队反超B队，且在之前是B队领先
			anss++;
		if(jsa[i]<jsb[i] && jsa[i-1]==jsb[i-1] && ld==1) //B队反超A队，且在之前是A队领先
			anss++;
		if(jsa[i]!=jsb[i]) //更新领先队伍
		{
			if(jsa[i]>jsb[i]) ld=1; //A队领先
			else ld=2; //B队领先
		}
	}
	printf("%lld",anss);
	return 0;
}
```

---
说明：By Xin。本人乃2016级小学生，思路比较简单，题解如有写的不好的地方请指正。

---

## 作者：封禁用户 (赞：2)

### 题目描述

假如我们正在观看一场未来的球赛，比赛双方是 A 队和 B 队。我们知道两队的得分和每次得分的准确时间。在一秒内，不可能有超过一次得分。

King James 想要得到两个问题的答案：

1. 上半场总共得了多少分？（整场比赛持续 $4 \times 12$ 分钟）
2. 发生多少次反超？（一次反超定义为一支队伍在得分小于对方后，经过投球使得得分超过对方）

### 思路

第一个问题比较简单，直接在输入时判断。

第二个问题，可以用一个数组储存所有的得分，得分的时间用下标表示，得分的队伍为这个元素的值。用一个变量存放当前比分的状态，**如果 A 队在落后时追平了比分，这个变量就设为$1$，如果是 B 队，就设为$2$，否则就是$0$**。然后判断这次哪个队伍进了球，如果变量的值和队伍刚好吻合，就把答案加一，然后清零。如果不吻合，就把直接把变量的值清零。最后就把队伍的分数加一。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
long long n,m,s,h,x,y,p;
int c[3000];
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>h;
		if(h<=1440)s++;//如果上半场得分
		c[h]=1;
	}
	cin>>m;
	for(int i=1; i<=m; i++)
	{
		cin>>h;
		if(h<=1440)s++;//如果上半场得分
		c[h]=2;
	}
	cout<<s<<endl;
	s=0;
	for(int i=1; i<=2880; i++)//枚举每一秒
	{
		if(c[i]==1)
		{
			if(p==1)s++,p=0;//如果变量的值和队伍刚好吻合，就把答案加一，然后清零。
			else p=0;//直接清零
			x++;//分数加一
			if(x==y)p=1;//如果A队追平比分
		}
		if(c[i]==2)
		{
			if(p==2)s++,p=0;//如果变量的值和队伍刚好吻合，就把答案加一，然后清零。
			else p=0;//直接清零
			y++;//分数加一
			if(x==y)p=2;//如果B队追平比分
		}
	}
	cout<<s;
	return 0;
}
```

---

## 作者：EatBread (赞：1)

**题目描述** 

假如我们正在观看一场未来的球赛，比赛双方是 A 队和 B 队。我们知道两队的得分和每次得分的准确时间。在一秒内，不可能有超过一次得分。

King James 想要得到两个问题的答案：

1.上半场总共得了多少分？（整场比赛持续 $4×12$ 分钟，上半场有 $1440$ 秒）。

2.发生多少次反超？（一次反超定义为一支队伍在得分小于对方后，经过投球使得得分超过对方）。

**思路**

由于题目说在一秒内，不可能有超过一次得分，所以可以用数组计数。

第一问就不说了，数组计数可以直接 A 了（也可以直接输入时解决）。

第二问数组计数也可以解决，只要将A队在数组计数中赋 $1$ ，B 队在数组计数中赋  $2$ ，并再定两个变量，按照数组计数的顺序依次将两队得分统计，再定一个用来判断是否反超的变量，每一次都判断哪队领先， A 队领先时为 $1$ ， B 队领先时为 $2$，如果在一次循环中，判断变量改变过，则 $ans++$ （但要注意，最后要 $ans-1$ ，因为在第一次某队得分时，不算反超）。

**贴程序**

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,ans2,a,b,js[10000],ad,bd,n,m,pd,t;
int main()
{
	cin>>n;for(int i=1; i<=n; i++)cin>>a,js[a]=1;
	cin>>m; for(int i=1; i<=m; i++)cin>>b,js[b]=2;
	
	for(int i=1; i<=3000; i++){
		t=pd;
		if(js[i]!=0){
			if(i<=24*60)ans++;
			if(js[i]==1)ad++;
			else bd++;
			if(ad>bd){
				pd=1;
			}
			if(ad<bd){
				pd=2;
			}
		}
		if(pd!=t)ans2++,t=pd; 
	}
	cout<<ans<<endl<<ans2-1; 
	return 0;
} 
```
以下是原来的程序，仅供参考。
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,ans2,a,b,js[10000],ad,bd,n,m,pd;
int main()
{
	cin>>n;for(int i=1; i<=n; i++)cin>>a,js[a]=1;
	cin>>m; for(int i=1; i<=m; i++)cin>>b,js[b]=2;
	
	for(int i=1; i<=3000; i++){
		if(js[i]!=0){
			if(i<=24*60)ans++;
			if(js[i]==1)ad++;
			else bd++;
			if(ad>bd){
				if(pd==2)ans2++; 
				pd=1;
			}
			if(ad<bd){
				if(pd==1)ans2++; 
				pd=2;
			}
		}
	}
	cout<<ans<<endl<<ans2; 
	return 0;
} 
```


---

## 作者：CarryQwQ (赞：1)

## 题意简述
[题目传送门](https://www.luogu.com.cn/problem/P7308)

[博客食用效果更佳](https://www.luogu.com.cn/blog/ThisIsCYF/solution-p7308)

给出 $A,B$ 两队的得分时间（单位：秒），求上半场两队总得分，以及整场比赛中出现的反超次数。

## 题目分析

一道简单的模拟题，按照题意模拟就 OK 了。

使用一个桶记录 $A,B$ 两队得分情况。处理的时候从第 1 秒开始一直遍历这个桶一直到第 2880 秒。

对于判断是否是上半场进的球。只需要判断进球时间是否小于等于 1440 秒。

而判断反超情况的总次数也，可以用一个变量 Flag 存储当前是 $A,B$ 哪一队处于领先状态（对于领先状态的定义：一队的得分大于另一队，则称这一队伍处于领先状态。）,当出现一队分数比另一队高，则判断当前是否是另一队处于领先状态，如果是，则出现了一次反超。

假如 $A$ 队在第 680 秒的时候进了一球，此时 $A$ 队得分为 4 分，而 $B$ 队得分为 2 分，而 $B$ 队此时处于领先状态，则 $A$ 队完成了一次反超，$A$ 队处于领先状态。

其实算法思路题解区的 dalao 们已经讲得非常清楚了，那么让我来用 STL 容器里的 ```map``` 容器代替桶来解题吧。

使用 ```map``` 容器好处就是不浪费空间，不需要在输入完数据后排序。

用得分时间作为键，而值则为得分的队伍，处理的时候定义一个迭代器 it 访问这个 ```map``` 容器。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a, b, anum, bnum, k, total, sur_num;
//anum 为 a 队的得分，bnum 为 b 队的得分，total 记录上半场总得分，sur_num记录反超的次数
char who;
//who 存储当前领先状态的队伍，为‘A’则是 A 队, 为‘B’则是 B 队
map<int, char> mp;
int main() {
	cin >> a;
	for (int i = 1; i <= a; i++)cin >> k, mp[k] = 'A';
	cin >> b;
	for (int i = 1; i <= b; i++)cin >> k, mp[k] = 'B';
	map<int, char>::iterator it = mp.begin();//定义了一个迭代器 it 用以访问 mp 里的元素
	for (; it != mp.end(); it++) {
		if (it->first <= 1440) total++;//it->first 指向键
		if (it->second == 'A') {//it->second 指向值
			anum++;
			if (anum > bnum) {
				if (who == 'B') sur_num++;//处理反超的情况
				who = 'A';
			}
		}
		if (it->second == 'B') {
			bnum++;
			if (bnum > anum) {
				if (who == 'A') sur_num++;//处理反超的情况
				who = 'B';
			}
		}
	}
	printf("%d\n%d\n", total, sur_num);
}
```








---

## 作者：ZBAA_MKC (赞：1)

[博客食用效果更佳](https://www.luogu.com.cn/blog/228770/solution-p7308)

本题根据题意模拟即可。

我的思路是把所有的得分输入到同一个结构体数组里，然后再按照得分时间排序，这样下来枚举次数会大大降低。

注意因为 `sort` 内部的排序算法是不稳定的排序算法，我们要改用 `stable_sort` 来确保排序的结果中相同元素顺序不会改变。

详情见代码注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 1e9 + 7;
typedef long long ll;

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
	{
        if (ch == '-')
		{
         	f = -1;
		}
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
	{
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}

struct pts
{
	int t;
	int f; //标注，0表示A队得分，1表示B队得分
}p[6000];  

bool cmp (pts x, pts y)
{
	return x.t < y.t;  
}

int main()
{
	//f=0表示A队得分，f=1表示B队得分
    int A, B;
	A = read();
	for (int i = 0; i < A; i++)
	{
		p[i].t = read();
		p[i].f = 0;
	}
	B = read();
	for (int i = A; i < A + B; i++)
	{
		p[i].t = read();
		p[i].f = 1;
	}
	//读入 
	stable_sort(p, p + A + B, cmp); //按时间排序 
	int a = 0, b = 0; //两队得分
	int ans1 = 0; //上半场得分数
	int ans2 = 0; //反超数
	int ff; //储存当前的领先者 
	const int half = 2 * 12 * 60; //半场时间 
	for (int i = 0; i < A + B; i++)
	{
		if (p[i].t <= half) //如果当前时间还没到半场 
		{
			ans1++; //累加答案1 
		}
		if (p[i].f == 0) 
		{
			a++;
		}
		else
		{
			b++;
		}
		//计算得分 
		if ((ff == 0 && a < b) || (ff == 1 && a > b)) //判定反超 
		{
			ans2++;
		} 
		if (a > b) //计算当前的领先者 
		{
			ff = 0;
		}
		else if (a < b)
		{
			ff = 1;
		}
	}
	printf("%d\n%d", ans1, ans2);
	return 0;
}

```


---

## 作者：xieyikai2333 (赞：1)

# 一道模拟~~水~~题

- [题目传送门](https://www.luogu.com.cn/problem/P7308)

---

- 这题数据很小，只到 $2880$ ，暴力枚举每一秒的状态自然可以过；但实际上我们只需要把有得分的时间点枚举一下就可以了。

---

我们开两个数组，用 $g_i$ 表示第 $i$ 次得分发生的时间点； $p_i$ 表示第 $i$ 秒时得分的队伍：等于 $1$ 表示 A 队得分，等于 $2$ 表示 B 队得分。

之后对 $g$ 数组排序，即可得到按时间顺序的得分序列，把 $g$ 数组作为 $p$ 数组的下标即可实现优化。

$g_i$ 第一次大于 $1440$ 时，输出 $i-1$ 即为第一问的解；每次记录领先者即可求出第二问的解。

---

**AC 代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int g[3005],p[3005];
int main()
{
	int A,B,geta=0,getb=0,win=0,ans=0;
	bool flag=false;
	cin>>A;
	for(int i=1;i<=A;i++)cin>>g[i],p[g[i]]=1;
	cin>>B;
	for(int i=A+1;i<=A+B;i++)cin>>g[i],p[g[i]]=2;
	sort(g+1,g+A+B+1);
	for(int i=1;i<=A+B;i++)
	{
		if(!flag&&g[i]>1440)cout<<i-1<<endl,flag=true;
		if(p[g[i]]==1)geta++;
		else getb++;
		if(geta>getb)
		{
			if(win==2)ans++;
			win=1;
		}
		if(geta<getb)
		{
			if(win==1)ans++;
			win=2;
		}
	}
	if(!flag)cout<<A+B<<endl;
	cout<<ans;
	return 0;
}
```

---

附上 [AC记录](https://www.luogu.com.cn/record/57012931)

---

## 作者：tZEROちゃん (赞：1)

### Solution

可以分成 3 个部分想。

**先是读入（input）：**

在代码的开头，我们用 `fill` 将这个数组的 **使用部分** 的元素全部设置为 $2$。

接着，我们读入一个正整数 $A$，再读入 $A$ 个正整数，将读入的数（$x$）作为下标，让 $a_x = 0$，像这样：

```cpp
	int A; cin >> A;
	for (int i = 1; i <= A; i++)
		a[rd()] = 0;
```

B 队也类似，不再说明。

**再是累计总分（points）：**

这一段没有什么难度，如果 $a_i = 0$ 或 $1$，且 $i \leq \dfrac{2880}{2}$，那么让计数器 $pts$ 加 $1$。

**最后是判断反超（turnarounds）：**

当上一局的赢家（$winner$）是 A（即 $0$）时，且这一局 B（即 $1$）的得分 $>$ A 的得分时，$turn+1$。

当上一局的赢家是 B（即 $1$）时，且这一局 A（即 $0$）的得分 $>$ B 的得分时，$turn+1$。

每局结束后，更新赢家。

**注：代码中 0 表示 A，1 表示 B。**

### Code 
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[2900];
int rd() { int x; cin >> x; return x; }
int main() 
{
	// 0 -> A, 1 -> B
	fill (a, a + 2885, 2);
	int A; cin >> A;
	for (int i = 1; i <= A; i++)
		a[rd()] = 0;
	int B; cin >> B;
	for (int i = 1; i <= B; i++)
		a[rd()] = 1;
	int winner = 2;
	int scoreA = 0, scoreB = 0;
	int pts = 0, turn = 0;
	for (int i = 1; i <= 2880; i++) 
	{
		if (a[i] == 0) scoreA ++;
		if (a[i] == 1) scoreB ++;
		if (i <= 1440 && a[i] == 0) pts ++;
		if (i <= 1440 && a[i] == 1) pts ++;
		if (winner == 0 && scoreB > scoreA) turn ++;
		if (winner == 1 && scoreA > scoreB) turn ++;
		if (scoreA > scoreB) winner = 0;
		if (scoreB > scoreA) winner = 1;
	}
	cout << pts << endl << turn;
	return 0;
}
```

---

## 作者：cwfxlh (赞：0)

# P7308
这是一道模拟题。  
只需要在输入时记录 A 队和 B 队在每一秒的得分就可以了，然后输出 1440 秒两队分数之和，接着遍历每一秒，记一下有多少次反超就可以了。  
附上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int A,B,a[2883],b[2883],A_score[2883],B_score[2883],ans2,f;
int main()
{
	scanf("%d",&A);
	for(int i=1;i<=A;i++)
	{
		scanf("%d",&a[i]);
		for(int j=a[i-1];j<a[i];j++)A_score[j]=A_score[a[i-1]];//把上一次得分的分数积下来 
		A_score[a[i]]=A_score[a[i]-1]+1;//更新这一次的分数 
	}
	for(int i=a[A]+1;i<=2880;i++)A_score[i]=A_score[a[A]];//把最后一次得分记录完毕 
	scanf("%d",&B);
	for(int i=1;i<=B;i++)
	{
		scanf("%d",&b[i]);
		for(int j=b[i-1];j<b[i];j++)B_score[j]=B_score[b[i-1]];//意义同上 
		B_score[b[i]]=B_score[b[i]-1]+1;
	}
	for(int i=b[B]+1;i<=2880;i++)B_score[i]=B_score[b[B]];
	printf("%d\n",A_score[1440]+B_score[1440]);//输出上半场 
	for(int i=1;i<=2880;i++)
	{
		if(f==0&&A_score[i]==1&&B_score[i]==0)f=1;//第一次得分记录 
		if(f==0&&A_score[i]==0&&B_score[i]==1)f=2;
		if(f==1&&A_score[i]<B_score[i])f=2,ans2++;//当状态逆转，反超次数++ 
		if(f==2&&A_score[i]>B_score[i])f=1,ans2++;
	}
	printf("%d",ans2);
	return 0;
}//完 
```


---

## 作者：Elgo87 (赞：0)

本题是一道~~大~~模拟。

## 思路
我们可以从题目中得知，一场比赛有 $4\times12\times60=2880s$，这个数字很小，所以我们只需把每一秒中 $\text A$、$\text B$ 队的胜负情况都模拟一遍即可。

## 代码实现
1. 输入数据，用 `NA`、`NB` 分别存储 $\text A$、$\text B$ 队的得分次数，$timesA_i$ 和 $timesB_i$ 分别存储在第 $i$ 秒时 $\text A$、$\text B$ 队的进球情况，$1$ 代表第 $i$ 秒得分，$0$ 代表没得分。代码如下：



```cpp
cin>>NA;
for(int i=1;i<=NA;i++) cin>>x,timesA[x]++;
cin>>NB;
for(int i=1;i<=NB;i++) cin>>x,timesB[x]++;
```



2. 代码核心：用 `for` 循环列举第 $i$ 秒时的进球情况，解释见代码。



```cpp
int scoreA=0,scoreB=0,exceed=0,total=0;
//分别表示A队得分、B队得分、反超的次数、两队的总分
char winner='\0';
//获胜的队伍名称，初始值为空
for(int i=1;i<=2880;i++) //从第1秒列举到第2880秒
{
    //1.给A、B队加分，计算总分
    if(timesA[i]) scoreA++;
    if(timesB[i]) scoreB++;
    total=scoreA+scoreB;
    
    //2.如果到了上半场结束，则输出总分，解第一问
    if(i==1440) cout<<total<<'\n'; 
    
    //如果A队分数高
    if(scoreA>scoreB) 
    {
        //如果原来是B队赢，现在A队分数高，代表A队反超一次
        if(winner=='B')               
            exceed++;
        winner='A';
    }
    //同理
    if(scoreA<scoreB)
    {
        if(winner=='A')
            exceed++;
        winner='B';
    } 
}
```



## 完整 AC Code



```cpp
#include<bits/stdc++.h>
#define MAXN 2880
using namespace std;
int NA,NB,x;
int timesA[MAXN+5],timesB[MAXN+5];
int main()
{
    cin>>NA;
    for(int i=1;i<=NA;i++) cin>>x,timesA[x]++;
    cin>>NB;
    for(int i=1;i<=NB;i++) cin>>x,timesB[x]++;
    
    int scoreA=0,scoreB=0,exceed=0,total=0;
    char winner='\0';
    for(int i=1;i<=MAXN;i++)
    {
        if(timesA[i]) scoreA++;
        if(timesB[i]) scoreB++;
        total=scoreA+scoreB;
        
        if(i==MAXN/2) cout<<total<<'\n'; 
        
        if(scoreA>scoreB) 
            if(winner=='B')                
                exceed++;
            winner='A';

        if(scoreA<scoreB)
            if(winner=='A')
                exceed++;
            winner='B';
    }
    cout<<exceed;
    return 0;
} 
```




---


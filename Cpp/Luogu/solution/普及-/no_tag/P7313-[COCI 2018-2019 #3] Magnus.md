# [COCI 2018/2019 #3] Magnus

## 题目背景

Magnus 下国际象棋输给了 Kile，所以他开始痴迷于编程。他决定前往 COCI 竞赛试试运气。

Kile 得知 Magnus 想要参加 COCI 后，便给他出了这道热身题。

## 题目描述

给定一个长度为 $N$ 的单词。在单词中删除任意个字母，使得能够组成尽可能多的 `HONI`。

## 说明/提示

#### 样例 2 解释

可以将 `H`，`O`，`N`，`I` 四个字母各从原单词中删除最早出现的 $3$ 个，得到 `HONI`。

#### 数据规模与规定

对于 $100\%$ 的数据，$1 \le N \le 10^5$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T1 Magnus_。**

## 样例 #1

### 输入

```
MAGNUS```

### 输出

```
0```

## 样例 #2

### 输入

```
HHHHOOOONNNNIIII```

### 输出

```
1```

## 样例 #3

### 输入

```
PROHODNIHODNIK```

### 输出

```
2```

# 题解

## 作者：封禁用户 (赞：9)

## P7313 [COCI2018-2019#3] Magnus
[原题链接](https://www.luogu.com.cn/problem/P7313)

## 分析
想到了之前写过的一篇 [题解](https://www.luogu.com.cn/blog/ooo/cf779b-weird-rounding)，尽管没太大关系，在存储处理字符串的思路上还是有相似之处的。CF779B 由于是从后往前找，用到了后进先出的数据结构——栈，这道题读题可知从前往后找 "HONI"，就用先进先出的数据结构——队列吧。

将字符串按照顺序压入队列，队首元素即为字符串首位，判断队首元素是否为当前查找的字母，然后删除队首进行下一次判断，直到队列被清空。

问题来了，怎样确定目前需要查找的字母？我用到了一个指针，其最初指向定义的字符串 "HONI" 的首位 "H"，当队首元素与指针指向的字母匹配时，指针指向下一个字母。由于字符串下标范围为 $0\sim 3$，当指针指向 $4$ 时，说明已经凑齐四个字母 "HONI"，将计数器累加，指针置为零重新开始匹配。最后输出计数器即可。

## Code
```cpp
#include<iostream>
#include<queue>
using namespace std;
queue<char>a;
string s="HONI";
int n,ans;
int main(){
	string q;cin>>q;
	for(int i=0;i<q.length();i++){
		a.push(q[i]); //入队 
	}
	while(!a.empty()){ //队列未被清空 
		if(a.front()==s[n]) n++; //当前队首元素为指针指向的字母 
		a.pop(); //队首元素出队 
		if(n==4){ //四个字母已经全部找到 
			n=0; //指针置为零 
			ans++; //计数器累加 
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：xuanye (赞：2)

思路： 

设一个栈，每次都判断如果栈顶的这位字符在 ```HONI``` 中的下一位是在字符串中的字符，说明这两个字符可以连在一起，所以就把字符中的字符推入栈，变为新的栈顶。

于是像这样反复循环就可以让栈里的字符变为若干个 ```HONI```（可能不完整）。

最后只需算出有几个 ```HONI``` 即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100005];
int i,sum=0;
stack<char> st;
int main(){
	cin>>s;
	for(i=0;s[i]!='\0';i++){
		if(st.empty()&&s[i]=='H'){ //要判断是否为第一个字符，不然在下面的判断会RE
			st.push('H');
		}
		else if(!st.empty()){ //依次判断栈顶是否为字符串s的上一位
			if(s[i]=='H'&&st.top()=='I'){ //"H"的上一位应为"I"，因为四个字母已经凑好了一遍
				st.push('H');
			}
			else if(s[i]=='O'&&st.top()=='H'){
				st.push('O');
			}
			else if(s[i]=='N'&&st.top()=='O'){
				st.push('N');
			}
			else if(s[i]=='I'&&st.top()=='N'){
				st.push('I');
			}
		}
	}
	cout<<st.size()/4; //由于"HONI"有4个字符，所以只要求栈内元素的数量除以4后向下取正，即可把不完整的"HONI"排除掉
    return 0;
}
```


---

## 作者：miku_index (赞：2)

## 题意解释
先解释一下题意。

题目给出一个字符串，我们可以删除其中任意位上的字符，试求能够组成多少个连续的**HONI**。

## 算法分析
因为我们需要组成**HONI**，需要的字符只有**H,O,N,I**。也就是其他的都是~~垃圾~~

所以，我们只需要匹配字符串中的**H,O,N,I**即可

``` cpp
//伪代码
for(遍历字符串)
  if(有我需要的字符)匹配[H,O,N,I]的下一位
  if(集齐了四龙珠！！！)更新答案，重新开始匹配。

```
## 一些思考时的障碍

但是我们考虑要周全，如果出现例如**HOMIKUHONI**的情况，不是匹配不到后面的**HO**了吗？

我们可以发现，这个字符串中**HO**有两个，**NI**只有一个。我们举个例子

现在有两个男**♂**性，一个女♀性，请问在不离婚的前提下，能组成几对夫妻？

当然是~~2~~……1组啦。

## 人们最期待的代码时刻！
``` cpp
//已防盗
#include<bits/stdc++.h>
using namespace std;
char a[100100];
char h[]="HONI";
int now=0,cnt=0;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>a;
	int l=strlen(a);
	for(int i=0;i<l;i++){
		if(a[i]==h[now])now++;
		if(now==4)now=0,cnt++;
	}
	cou t<<cnt<<endl;
	return 0;
}

```

---

## 作者：Griseo_nya (赞：1)

因为我们删除任意个字母的目的是凑出 HONI ，所以我们只需要删去 H 和 O , O 和 N ,以及 N 和 I 之间的字母即可。

或者说，我们只需要遍历字符串，每次看本位字符是否与当前匹配到的字符相同即可。

下面是代码的说：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string s;
	cin>>s;
	const string f="HONI";
	int k=0,ans=0;
	for(int i=0;i<s.size();i++){
		
		if(s[i]==f[k]){					//如果当位匹配上了
			if(++k==4)k=0,++ans;		//我们可以把 k+1 内嵌在判断式里，如果 k==0 则从头再开始匹配， ans+1
		}
	}
	cout<<ans;							//输出答案
	return 0;
}
```


---

## 作者：liswill (赞：0)

字符串处理入门题。

## 题意

给出一个字符串，求删去任意个字母后，最多组成多少个 `HONI` 。

## 思路

既然删去的字符为任意个，那就可以不用模拟删除过程，而是从原字符串中寻找有序的 `HONI` 的数量。

定义一个指针，从头到尾遍历字符串，如果遇到 `H`，指针标为  `1` ，遇到 `O` ，指针标为`2`，遇到 `N` ，指针标为 `3` ，遇到 `I` ，说明有一个完整有序的 `HONI` ，答案加一，指针标为 `0` 。

## CODE「CPP」

```cpp
#include<bits/stdc++.h>

using namespace std;

int n;
char c[100005];
int main()
{
    scanf("%s",c+1);	//从下标1开始输入
    n=strlen(c+1);	//n为字符串最后一位下标，由于字符串从1开始输入，最后一位下标为字符串长度+1
    int ans=0,now=0;    //now为指针
    for(int i=1;i<=n;i++)
    {
        if(c[i]=='H'&&now==0)now=1;
        if(c[i]=='O'&&now==1)now=2;
        if(c[i]=='N'&&now==2)now=3;
        if(c[i]=='I'&&now==3)now=0,ans++;	//见思路
    }
    cout<<ans<<endl;
    return 0;
}
```



---

## 作者：light_ght (赞：0)

 ## 判断 i


------------
- 由于要凑 HONI 这四个字母，我们只需要扫描是否已经出现“**HON**”这三个字母。不难看出，若其为真，则如果再扫描出字母 **I** 答案便可以增加1。

- 具体实现请看代码。
```cpp
	#include<bits/stdc++.h>
	using namespace std;

	char p[]={"HONI"};
	int len,tot,ans;//tot记录已经符合标准的字母数量，初值为0 
	string s;//使用字符串的优点是不需要确定开多大的数组

	int main()
	{
 	 ios::sync_with_stdio(0);
 	 cin.tie(0);cout.tie(0);//以上两行加速cin&&cout 
 
		cin>>s;//cin可以直接赋值字符串。scanf&&gets均不行
		len=s.size();
		//cout<<len;
		for(int i=0;i<len;i++){
			if(s[i]==p[tot]){ //若输入数据当前位与标准比对成功
				++tot; //计数器+1
				if(tot==4) //如果这是标准的第四位，即计数器为4  
                	tot=0,ans++;  //重置计数器，答案+1               				      
			}
		} 
		cout<<ans<<endl;
    	 return 0;
	}


```
    
    




---


# 【DSOI 2021】电子跃迁

## 题目背景


> “如果能证明大统一理论，这个世界将焕然一新。”\
“量子……量子……就差一点……”\
“嘶……哦。**我想我明白了**。”

## 题目描述

在你的视野下，出现了一排电子，他们分别拥有不同的能量。你需要做的是通过**将相邻电子互换**的方法，将电子排的有序。**有序**是指：能量最小的电子放到最靠近原子核的左边，将第二小的电子放在第二……将能量最大的电子放在最右边。\
可是，你发现电子轨道之间忽然出现了 $m$ 个奇怪的力，使位于第 $x_i$ 个位置的电子和位于第 $x_i+1$ 个位置的电子无法进行交换。

你深信这个力将会颠覆当下的物理理论。你需要做的是将现在的一排电子排得**尽量有序**以发现其中规律。

**尽量有序**是指：**在条件下**，能量最小的电子尽量放到左边直至出现屏障，以此类推。


## 说明/提示

对于 $10\%$ 的数据，满足 $m=0$；\
对于另 $20\%$ 的数据，满足 $n \le 1000,m \le 100$；\
对于 $100\%$ 的数据，满足 $0 \le n,m \le 5 \times 10^5,1 \le x_i \le n-1,1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
3 0
3 2 1```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
7 2
1 3 1 4 5 2 1
2 4```

### 输出

```
1 3 1 4 1 2 5```

# 题解

## 作者：LinkZelda (赞：13)

- **做法简述**：

题意十分清晰，就是给定一个数列，和一些断点，我们容易发现，把断点**升序排序**后，原数列分成了若干个区间，题目转化为求在每一个断开的区间内进行升序排序。

注意到题目给出的数据范围比较大：$N \leq 10^5$，使用冒泡排序，插入排序等是 $\mathit{O}(n^2)$ 的，不能通过。我们可以直接使用 `algorithm` 库中的 `sort` 排序，可以做到 $\mathit{O}(n \log n)$ 的复杂度，可以通过本题 。

- **代码如下** :

```cpp
#include<cstdio>
#include<algorithm>
#include<ctype.h>
#define int long long

using namespace std;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return x*f; 
 } 
 
int n,m,a[500005],b[500005];

signed main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=m;i++)
		b[i]=read();
	sort(b+1,b+m+1); // 记得排序后才能分成若干个区间
	b[m+1]=n; // 把最后一个断点设成 n , 实现起来会比较方便
	for(int i=0;i<=m;i++)
		sort(a+b[i]+1,a+b[i+1]+1);
	for(int i=1;i<=n;i++)
		printf("%lld ",a[i]);
	return 0;
}
```

---

## 作者：VicXF_ (赞：4)

### 总的来讲是一道没有思维难度的思维题
~~你这算毛线球思维题~~

暴力算法 20分：(应该没人打吧

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,m,a[N];
bool vis[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1,x;i<=m;i++){
		scanf("%d",&x);
		vis[x]=true;
	}
	for(int i=1;i<=n-1;i++)
		for(int j=1;j<=n-1;j++){
			if(vis[j]) continue;
			if(a[j]>a[j+1]) swap(a[j],a[j+1]);
		}
	for(int i=1;i<=n;i++){
		printf("%d ",a[i]);
	}
	return 0;
}
```
复杂度 $ O(n^2)$


**100分做法：分别排序**

首先看到题目，很明显是个冒泡排序的模型，相邻的两个数无法交换。对于冒泡排序，实现整个数列有序的方法就是交换数字（废话

那么对于某个数列，如：

` 3,2,1 `

那么对他进行正常的冒泡排序，需要分别交换:

 $ 3,2 $ ,成为 ` 2,3,1 `; 
 
 $ 1,3 $ ,成为 ` 2,1,3 `; 
 
 $ 1,2 $ ,成为 ` 1,2,3 `。
 
可是当某个地方无法交换，如第 $1$ 个数和第 $2$ 个数无法交换时，这意味着整个数列被分成两部分，这两部分的数字无法互相交换。那么这两部分的数就可以分开独立排序了。对每一部分进行 $O(nlogn)$ 的任何排序就可以AC此题啦~
 
 代码:
 ```cpp
 #include<bits/stdc++.h>
#define ll long long
#define R read()
using namespace std;
inline ll R{   //快读
	ll x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,m,a[500005],b[500005];
int main(){
	n=R;m=R;
	for(int i=1;i<=n;i++) a[i]=R;	
	for(int i=1;i<=m;i++) b[i]=R;//读入
	sort(b+1,b+m+1);b[m+1]=n;//如果b[m+1]不赋值那么最后一部分就排不了
	for(int i=1;i<=m+1;i++)	sort(a+(b[i-1]+1),a+(b[i]+1));//非常水的排序
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	return 0;
}
 ```


---

## 作者：Skies (赞：3)

## 题意

现有一个长度为n的序列a，相邻两个数可以交换，给定k个断点i，表示a[i]和a[i+1]不能交换，现在问尽量接近的排列

## 分析

显然这k个断点把a分成k+1个部分，相邻两个部分中的数就不连通了

所以我们只要对于这k块分别sort输出即可

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=5e5+10;
int a[N],b[N];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int j=1;j<=m;j++)
	{
		scanf("%d",&b[j]);
	}
   	//输入
	sort(b+1,b+m+1);//别忘了从小到大
	b[m+1]=n;b[0]=0;//数组开头和结尾也要添加断点
	for(int i=1;i<=m+1;i++) 
	{ 
		sort(a+b[i-1]+1,a+b[i]+1);
	}
	
	for(int i=1;i<=n;i++)
	{
		printf("%d ",a[i]);
	}
}
```


---

## 作者：Asdonel (赞：3)

# 题目简意
- 给定 $n$ 个数。
- 以其中 $m$ 个数，将原数组分为 $m+1$ 个区间。
- 对每个区间进行排序，输出排序后的结果。
- $0 \le n,m \le 5 \times 10^5$。
# 解题思路
1. 首先看见 “排序” ，以及 $n,m$ 的数据规模，**一定与快速排序脱不了干系**。  
2. 在认真审读题面，可知 **$x_i$ 与 $x_{i+1}$ 无法交换，于是将数组分成了两个区间**。
3. 那么我们有理由考虑，将每一个区间分别进行快排，不就行了吗？
4. 所以，将每一个 $x_i$ 进行记录，划分出区间排序，输出即可。

# 注意事项
- 题目并没有保证数据不重复，所以在读入 $x_i$ 时，要进行去重操作。
- 题目并没有保证 $x_i$ 的单调性，所以在读入后，还需要进行排序。
- 在读入 $x_i$ 后，还隐含了两个特殊的元素**数组的第一个和最后一个元素**。在读入时需要将开头结尾分别预先设置（无论是否读入）。
# CODE
**希望能起参考作用**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const ll mm = 5e6 + 20;
ll n, m, a[mm], b[mm], now[mm], head, tail, vis[mm], l;
inline ll read() {
    char ch = getchar();
    ll sum = 0, cf = 1;

    while (ch < '0' || ch > '9') {
        if (ch == '-')
            cf = -1;

        ch = getchar();
    }

    while (ch >= '0' && ch <= '9') {
        sum = (sum << 3) + (sum << 1) + (ch ^ 48);
        ch = getchar();
    }

    return cf * sum;
}
int main() {
    n = read(), m = read();

    for (ll i = 1; i <= n; i += 1)
        a[i] = read();

    for (ll i = 1; i <= m; i += 1) {
        ll tt = read();

        if (vis[tt])
            continue;

        vis[tt] = 1;
        l += 1;
        b[l] = tt;
    }

    if (m == 0) {
        sort(a + 1, a + n + 1);

        for (ll i = 1; i <= n; i += 1)
            printf("%lld ", a[i]);

        return 0;
    }

    if (n == 0)
        return 0;

    sort(b + 1, b + l + 1);
    b[l + 1] = n;
    ll t = 1;

    while (1) {
        head = b[t - 1] + 1;
        tail = b[t];

        if (head > tail)
            break;

        for (ll i = head; i <= tail; i += 1)
            now[i] = a[i];

        sort(now + head, now + tail + 1);
        t += 1;
    }

    for (ll i = 1; i <= n; i += 1)
        printf("%lld ", now[i]);

    printf("\n");
    return 0;
}
```
## 感谢观看，希望对你能有所帮助！

---

## 作者：cmll02 (赞：2)

为什么这道题我写了 $0.5h$ 啊？？？？？

---

相邻两个屏障之间的操作是与外界隔绝的。

我们只要让每两个屏障之间满足条件就行。

而两个屏障间是没有屏障的，直接排序即可。

Code:

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
inline int read()
{
	int num = 0,f=1; char c = getchar();
	while (c<48 || c>57){if(c=='-')f=-1;c = getchar();}
	while (c >= 48 && c <= 57)num = (num << 3) + (num << 1) + (c ^ 48), c = getchar();
	return num*f;
};
int a[500005];int b[500005];
signed main()
{
	int n=read(),m=read()+2;
	for(int i=0;i<n;i++)a[i]=read();
	for(int i=1;i<m-1;i++)b[i]=read();
	b[m-1]=n;
	std::sort(b,b+m);//b[0]=0相当于在0左边有个屏障，最右边也有
	for(int i=0;i<m-1;i++)std::sort(a+b[i],a+b[i+1]);
	
	//puts("");
	
	for(int i=0;i<n;i++)printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：Aiopr_2378 (赞：1)

# Solution 【DSOI 2021】电子跃迁

这道题思路明白了写代码不是问题。

## 题意：

给你一个从$1$到$n$的序列，有$m$个断点，求每相邻两个断点之间的从小到大排序

考虑时间复杂度，一共最大有$500005$个数，用$sort()$函数足够了

## 注意：

- $sort()$函数第一个参数是排序的**第一个元素的下标**，而第二个参数是排序的**最后一个元素的后一个下标**

- 这$m$个断点不含首尾元素，我们排序是需要添加$x[m+1]=n$这项元素,建议$x[]$数组输入从$i=1$开始。

- 因为数组$x[]$不保证递增，所以我们在$x[]$数组输入后要对$x[]$数组进行**递增排序**。(蒟蒻第一次错这里了...)

- 输入建议用$scanf()$输入，可以用快读（代码见下），输出建议用$printf()$。

```cpp
//快读代码，仅供参考
long long read(){
	int x=0,f=1;
	char ch=getchar();
	while (!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
```

下面是AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[500005],x[500005];
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<=m;i++){
		scanf("%lld",&x[i]);
	}
	sort(x+1,x+m+1);//对x[]数组进行递增排序
	x[m+1]=n;
	for(int i=1;i<=m+1;i++){
		sort(a+x[i-1]+1,a+x[i]+1);//这里要注意，因为x[0]默认为0，所以i=1时没有问题，前提一定时x[]数组设为全局变量
	}
	for(int i=1;i<=n;i++){
		printf("%lld ",a[i]);
	}
	return 0;
}
```

请各位大佬多多指教

谢谢管理员小哥哥

# END

---

## 作者：FuriousC (赞：1)

~~我绝对不会告诉你我交了3遍才AC~~

作为比赛的$T1$，出题人还是很良心的
# 前置芝士：

[基础排序算法](https://blog.csdn.net/u013249965/article/details/52575324)

**直接插入排序：**

基本思想：每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。

算法概念：直接插入排序是将无序序列中的数据插入到有序的序列中，在遍历无序序列时，首先拿无序序列中的首元素去与有序序列中的每一个元素比较并插入到合适的位置，一直到无序序列中的所有元素插完为止。

让我们来结合一个栗子分析一下：对于一个无序序列{$4,6,8,5,9$}来说，我们首先先确定首元素$4$是有序的，然后在无序序列中向右遍历，$6$大于$4$则它插入到$4$的后面，再继续遍历到$8$，$8$大于$6$则插入到$6$的后面，这样继续直到得到有序序列{$4,6,8,5,9$}。
# 思路：

对于这道题目而言，用一个$bool$数组（$f$）记录屏障，然后使用插入排序，在排序过程中一旦碰到屏障就跳过屏障，从屏障后面继续排序。
# 废话不多说，上代码：

插入排序+一维数组记录屏障，代码如下（含注释）：

```cpp
#include<bits/stdc++.h>//懒人专用头文件
using namespace std;
int n,m,a[500005];//意义见题面
bool f[500005];//记录屏障的位置
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }//输入
    int x;
    if(m==0){
        sort(a+1,a+n+1);
        for(int i=1;i<=n;i++){
            cout<<a[i]<<" ";
        }
        return 0;
    }//特判m=0，能省点时间，毕竟快排还是比插入排序快（去掉就会TLE）
    for(int i=1;i<=m;i++){
        cin>>x;
        f[x+1]=1;
    }//输入屏障
    int i,j;
    for(i=2;i<=n;i++){//从第2个数据开始插入
        int temp=a[i];//临时变量记录要插入的数据
        for(j=i-1;j>=0&&a[j]>temp;j--){//从后向前，找到比其小的数的位置,注意是j>=0；
            if(f[j+1]){
                break;
            }//判断有没有屏障，有屏障就跳过
            swap(a[j+1],a[j]); //向后挪动
        }
        a[j+1]=temp;//如果找到了比temp小的则将temp放在比它小的后面；如果没找到比他小的，也就是它最小这时候的j=-1，所以放在了a[j+1]数组第一个那里
    }//插入排序板子
    for(int i=1;i<=n;i++){
        cout<<a[i]<<" ";
    }//输出
    return 0;
}
```

终于$AC$了$......wtcl$

[评测记录](https://www.luogu.com.cn/record/46320973)

---

## 作者：int32 (赞：0)

### $\large \texttt {Step 1. 思路简述}$

我们将所有电子看成一个数列，所有的力看成断点。

所有断点将数列分成 $m$ 个部分，每个部分分别又看成一个数列，**对于每个部分，我们将其分别排序**，输出即可。

**注意把第 $0$ 个断点 $0$，第 $(m+1)$ 个断点看成 $(n+1)$，方便统计。**


详细请见代码。

### $\large \texttt {Step 2. 核心代码}$

```cpp
//x[]表示断点坐标
//a[]表示电子坐标
//k:m
x[0]=0,x[k+1]=n;//初始化
sort(x+1,x+k+1);//断点排序
for(int i=0;i<=k;i++) sort(a+x[i]+1,a+x[i+1]+1);//两断点之间排序
```

---

## 作者：银河AI (赞：0)

### 解题思路
刚看到这题，很明显，题目是要排序这个数组


通过观察可以知道，我们需要对于 $ [x_{i-1}+1, x_{i}-1]$ 的区间进行排序


为了方便处理区间排序

我们令 $x_0=0$，$x_{m+1}=n$

接下来只需 $sort(a+x[i]+1,a+x[i+1]+1)$ 其中 $i\in[0,m]$，$a$ 是待排序的数组名

然后？然后是 $code$ $time$~

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+2;
int n,m;
int a[N],x[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) scanf("%d",&x[i]);
	x[0]=0,x[m+1]=n;
	sort(x+1,x+m+1);
	for(int i=0;i<=m;i++) sort(a+x[i]+1,a+x[i+1]+1);
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
}
```

这就是本题的基本思路啦，管理大大辛苦了，麻烦过一下该题解吧谢谢

---

## 作者：_caiji_ (赞：0)

### 题意简述
给出一长为 $n$ 的数列 $a$ 和一长为 $m$ 的数列 $b$，你可以交换 $(a_i,a_{i+1})$ 的位置，但不能交换 $(a_{b_i},a_{b_i+1})$ 的位置，你需要在满足限制条件的同时让数列尽量有序。$1\leq n,m\leq 5\times 10^5$。

### 题目分析
补充一点题目中没说的：不能交换 $(a_{b_i},a_{b_i+1})$ 的位置，但可以交换 $(a_{b_i-1},a_{b_i})$ 和 $(a_{b_i+1},a_{b_i+2})$ 的位置。

这道题 $n$ 的范围比较大，$O(n^2)$ 的冒泡排序只能骗得 $30$ 分，考虑使用别的方法。

首先，我们要知道，仅靠交换任意 $(a_i,a_{i+1})$ 的位置，可以使数列 $a$ 变得有序。那么，我们参照样例 $2$，画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4kvsutw5.png)

看看这个图，这两个`X`把这个数列分成了 $3$ 部分：$(a_1,a_2)$、$(a_3,a_4)$、$(a_5,a_7)$。实际上，我们只需要对这 $3$ 部分分别排序就可以了，因为每个部分是独立的，它的元素不能传到另一个部分，满足题目的要求。那么我们来写代码吧：
```cpp
#include <cstdio>
#include <algorithm>//使用sort
using namespace std;
int n,m,a[500010],b[500010];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=m;i++) scanf("%d",&b[i]);
    sort(b+1,b+1+m);//先把b数组排个序，防止出一些刁钻的数据卡我们
    for(int i=1;i<=m;i++) sort(a+b[i-1]+1,a+b[i]+1);//分部分排序，从b[i-1]到b[i]是一个部分
  	//这里要注意一下+1，由于STL的特性，传进去的东西都要"左闭右开"，所以要+1把b[i]也排进去
    sort(a+b[m]+1,a+n+1);//还有最后一个部分，也要排
    for(int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0;
}
```
复杂度 $O(n\log n)$，轻松通过此题。

---

## 作者：RBI_GL (赞：0)

# 题意

给定有 $n$ 个数的数组 $a$，其中有 $m$ 个数不可以与其他数交换。

求可能的最有序数列。

-----

# 思路：

首先特判 $m=0$。那么直接排序数组后输出即可。

其他情况：先把限制的那 $m$ 个数即 $x$ 数组排序。然后排序 $a$ 数组。

接下来要把 $a$ 数组从第一个数排序到第 ```x[1]``` 个，还要把 $a$ 数组从第 ```x[m]``` 排序到最后一个。

由于要做到最有序。我们还要把每两个不能动的数之间的数进行排序。

# $Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[500005],x[500005];
inline int read() {
	register int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void print(int x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) a[i] = read();
	if (m == 0) {
		sort(a + 1, a + n + 1);
		for(int i=1; i<=n; i++) {
			print(a[i]);printf(" ");
		}
		return 0;
	}
	for(int i=1; i<=m; i++) x[i] = read();
	sort(x + 1, x + m + 1);
	sort(a + 1, a + x[1] + 1);
	for(int i=1; i<=m-1; i++) {
		sort(a + x[i] + 1, a + x[i+1] + 1);
	}
	sort(a + x[m] + 1, a + n + 1);
	for(int i=1; i<=n; i++) {
		print(a[i]);printf(" ");
	}
	return 0;
}
```

---

## 作者：Nygglatho (赞：0)

题目是要求是要把 $m + 1$ 个段分别排序。如下图（以**排序后的**样例2为例）：

![](https://ftp.bmp.ovh/imgs/2021/02/c72be1878246f36f.png)

我们会发现，这 $m + 1$ 个段分别是 $[1, x_1], [x_1 + 1, x_2], \cdots, [x_{m - 1} + 1, x_m], [x_m + 1, n]$。

我们可以把每个段都标上编号。例如，$[1, x_1]$ 中的每一个都标上1，$[x_1 + 1, x_2]$ 都标上2，以此类推，直到 $[x_m + 1, n]$。

我用了一个结构体来表示整个序列：
```cpp
struct elec {
	int num;//拥有的能量
	bool h;//标记，是不是位于x[i]处
	int bianhao;//编号
}a[500001];
```

接着，我们来处理如何排序的问题。

由于我们有了编号，就容易的多了。判断这些编号是否相等，即是否是一样的段（没有被“奇怪的力”隔开）。
- 如果相等，那么可以交换，就开始比较及交换。
- 否则，也就是无论如何都交换不了，那么就什么也不做。

```cpp
bool cmp (elec x, elect y) {
	if (x.num < y.num && x.bianhao == y.bianhao) {
		//编号相同但不有序
		return true;
	}
	else return false;
}
```

最后一个问题就是如何写编号了。我们可以把分割每个段的地方（就是有“奇怪的力”的地方）记录下来，比如用我结构体中的 $h$ 标记，然后设定一个值，用来设定每一段的编号。最后扫描一下数组，先把编号赋值上去，如果发现有数组中有标记，那么就说明一个段结束了，应该更改设定的值了。

```cpp
	int n, m;
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf ("%d", &a[i].num);
	}
	for (int i = 1; i <= m; i++) {
		scanf ("%d", &x[i]);
		a[x[i]].h = true;//标记
	}
	int l = 1;//设定的值
	for (int i = 1; i <= n; i++) {
		a[i].bianhao = l;
		if (a[i].h) ++l;//更改设定的值
	}
```

接着，使用我们定义的 cmp 函数，sort 一下即可。

---

